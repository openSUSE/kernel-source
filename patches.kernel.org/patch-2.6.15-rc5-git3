From: Linus Torvalds <torvalds@osdl.org>
Subject: Linux 2.6.15-rc5-git3
Patch-mainline: 2.6.15-rc5-git3
Acked-by: olh@suse.de

diff --git a/Documentation/arm/00-INDEX b/Documentation/arm/00-INDEX
index d753fe5..2c6a3b3 100644
--- a/Documentation/arm/00-INDEX
+++ b/Documentation/arm/00-INDEX
@@ -16,5 +16,7 @@ empeg
 	- Empeg documentation
 mem_alignment
 	- alignment abort handler documentation
+memory.txt
+	- description of the virtual memory layout
 nwfpe
 	- NWFPE floating point emulator documentation
diff --git a/Documentation/dvb/README.dvb-usb b/Documentation/dvb/README.dvb-usb
index ac0797e..46b78b7 100644
--- a/Documentation/dvb/README.dvb-usb
+++ b/Documentation/dvb/README.dvb-usb
@@ -50,12 +50,12 @@ http://www.linuxtv.org/wiki/index.php/DV
 0. History & News:
   2005-06-30 - added support for WideView WT-220U (Thanks to Steve Chang)
   2005-05-30 - added basic isochronous support to the dvb-usb-framework
-               added support for Conexant Hybrid reference design and Nebula DigiTV USB
+	       added support for Conexant Hybrid reference design and Nebula DigiTV USB
   2005-04-17 - all dibusb devices ported to make use of the dvb-usb-framework
   2005-04-02 - re-enabled and improved remote control code.
   2005-03-31 - ported the Yakumo/Hama/Typhoon DVB-T USB2.0 device to dvb-usb.
   2005-03-30 - first commit of the dvb-usb-module based on the dibusb-source. First device is a new driver for the
-               TwinhanDTV Alpha / MagicBox II USB2.0-only DVB-T device.
+	       TwinhanDTV Alpha / MagicBox II USB2.0-only DVB-T device.
 
   (change from dvb-dibusb to dvb-usb)
   2005-03-28 - added support for the AVerMedia AverTV DVB-T USB2.0 device (Thanks to Glen Harris and Jiun-Kuei Jung, AVerMedia)
@@ -64,50 +64,50 @@ http://www.linuxtv.org/wiki/index.php/DV
   2005-02-02 - added support for the Hauppauge Win-TV Nova-T USB2
   2005-01-31 - distorted streaming is gone for USB1.1 devices
   2005-01-13 - moved the mirrored pid_filter_table back to dvb-dibusb
-             - first almost working version for HanfTek UMT-010
-             - found out, that Yakumo/HAMA/Typhoon are predecessors of the HanfTek UMT-010
+	     - first almost working version for HanfTek UMT-010
+	     - found out, that Yakumo/HAMA/Typhoon are predecessors of the HanfTek UMT-010
   2005-01-10 - refactoring completed, now everything is very delightful
-             - tuner quirks for some weird devices (Artec T1 AN2235 device has sometimes a
-               Panasonic Tuner assembled). Tunerprobing implemented. Thanks a lot to Gunnar Wittich.
+	     - tuner quirks for some weird devices (Artec T1 AN2235 device has sometimes a
+	       Panasonic Tuner assembled). Tunerprobing implemented. Thanks a lot to Gunnar Wittich.
   2004-12-29 - after several days of struggling around bug of no returning URBs fixed.
   2004-12-26 - refactored the dibusb-driver, splitted into separate files
-             - i2c-probing enabled
+	     - i2c-probing enabled
   2004-12-06 - possibility for demod i2c-address probing
-             - new usb IDs (Compro, Artec)
+	     - new usb IDs (Compro, Artec)
   2004-11-23 - merged changes from DiB3000MC_ver2.1
-             - revised the debugging
-             - possibility to deliver the complete TS for USB2.0
+	     - revised the debugging
+	     - possibility to deliver the complete TS for USB2.0
   2004-11-21 - first working version of the dib3000mc/p frontend driver.
   2004-11-12 - added additional remote control keys. Thanks to Uwe Hanke.
   2004-11-07 - added remote control support. Thanks to David Matthews.
   2004-11-05 - added support for a new devices (Grandtec/Avermedia/Artec)
-             - merged my changes (for dib3000mb/dibusb) to the FE_REFACTORING, because it became HEAD
-             - moved transfer control (pid filter, fifo control) from usb driver to frontend, it seems
-               better settled there (added xfer_ops-struct)
-             - created a common files for frontends (mc/p/mb)
+	     - merged my changes (for dib3000mb/dibusb) to the FE_REFACTORING, because it became HEAD
+	     - moved transfer control (pid filter, fifo control) from usb driver to frontend, it seems
+	       better settled there (added xfer_ops-struct)
+	     - created a common files for frontends (mc/p/mb)
   2004-09-28 - added support for a new device (Unkown, vendor ID is Hyper-Paltek)
   2004-09-20 - added support for a new device (Compro DVB-U2000), thanks
-               to Amaury Demol for reporting
-             - changed usb TS transfer method (several urbs, stopping transfer
-               before setting a new pid)
+	       to Amaury Demol for reporting
+	     - changed usb TS transfer method (several urbs, stopping transfer
+	       before setting a new pid)
   2004-09-13 - added support for a new device (Artec T1 USB TVBOX), thanks
-               to Christian Motschke for reporting
+	       to Christian Motschke for reporting
   2004-09-05 - released the dibusb device and dib3000mb-frontend driver
 
   (old news for vp7041.c)
   2004-07-15 - found out, by accident, that the device has a TUA6010XS for
-               PLL
+	       PLL
   2004-07-12 - figured out, that the driver should also work with the
-               CTS Portable (Chinese Television System)
+	       CTS Portable (Chinese Television System)
   2004-07-08 - firmware-extraction-2.422-problem solved, driver is now working
-               properly with firmware extracted from 2.422
-             - #if for 2.6.4 (dvb), compile issue
-             - changed firmware handling, see vp7041.txt sec 1.1
+	       properly with firmware extracted from 2.422
+	     - #if for 2.6.4 (dvb), compile issue
+	     - changed firmware handling, see vp7041.txt sec 1.1
   2004-07-02 - some tuner modifications, v0.1, cleanups, first public
   2004-06-28 - now using the dvb_dmx_swfilter_packets, everything
-               runs fine now
+	       runs fine now
   2004-06-27 - able to watch and switching channels (pre-alpha)
-             - no section filtering yet
+	     - no section filtering yet
   2004-06-06 - first TS received, but kernel oops :/
   2004-05-14 - firmware loader is working
   2004-05-11 - start writing the driver
diff --git a/Documentation/dvb/README.flexcop b/Documentation/dvb/README.flexcop
index a50c70f..5515469 100644
--- a/Documentation/dvb/README.flexcop
+++ b/Documentation/dvb/README.flexcop
@@ -174,7 +174,7 @@ Debugging
 Everything which is identical in the following table, can be put into a common
 flexcop-module.
 
-                  PCI                  USB
+		  PCI                  USB
 -------------------------------------------------------------------------------
 Different:
 Register access:  accessing IO memory  USB control message
diff --git a/Documentation/dvb/avermedia.txt b/Documentation/dvb/avermedia.txt
index 09020eb..2dc260b 100644
--- a/Documentation/dvb/avermedia.txt
+++ b/Documentation/dvb/avermedia.txt
@@ -1,6 +1,6 @@
 
 HOWTO: Get An Avermedia DVB-T working under Linux
-           ______________________________________________
+	   ______________________________________________
 
    Table of Contents
    Assumptions and Introduction
diff --git a/Documentation/dvb/cards.txt b/Documentation/dvb/cards.txt
index 19329cf..9e10092 100644
--- a/Documentation/dvb/cards.txt
+++ b/Documentation/dvb/cards.txt
@@ -16,7 +16,7 @@ Hardware supported by the linuxtv.org DV
   shielding, and the whole metal box has its own part number.
 
 
-o Frontends drivers: 
+o Frontends drivers:
   - dvb_dummy_fe: for testing...
   DVB-S:
    - ves1x93		: Alps BSRV2 (ves1893 demodulator) and dbox2 (ves1993)
@@ -24,7 +24,7 @@ o Frontends drivers: 
    - grundig_29504-491	: Grundig 29504-491 (Philips TDA8083 demodulator), tsa5522 PLL
    - mt312		: Zarlink mt312 or Mitel vp310 demodulator, sl1935 or tsa5059 PLL
    - stv0299		: Alps BSRU6 (tsa5059 PLL), LG TDQB-S00x (tsa5059 PLL),
-   			  LG TDQF-S001F (sl1935 PLL), Philips SU1278 (tua6100 PLL), 
+			  LG TDQF-S001F (sl1935 PLL), Philips SU1278 (tua6100 PLL),
 			  Philips SU1278SH (tsa5059 PLL), Samsung TBMU24112IMB
   DVB-C:
    - ves1820		: various (ves1820 demodulator, sp5659c or spXXXX PLL)
@@ -35,8 +35,8 @@ o Frontends drivers: 
    - grundig_29504-401	: Grundig 29504-401 (LSI L64781 demodulator), tsa5060 PLL
    - tda1004x		: Philips tda10045h (td1344 or tdm1316l PLL)
    - nxt6000 		: Alps TDME7 (MITEL SP5659 PLL), Alps TDED4 (TI ALP510 PLL),
-               		  Comtech DVBT-6k07 (SP5730 PLL)
-               		  (NxtWave Communications NXT6000 demodulator)
+			  Comtech DVBT-6k07 (SP5730 PLL)
+			  (NxtWave Communications NXT6000 demodulator)
    - sp887x		: Microtune 7202D
    - dib3000mb	: DiBcom 3000-MB demodulator
   DVB-S/C/T:
diff --git a/Documentation/dvb/contributors.txt b/Documentation/dvb/contributors.txt
index 2cbd2d0..4c33cce 100644
--- a/Documentation/dvb/contributors.txt
+++ b/Documentation/dvb/contributors.txt
@@ -15,7 +15,7 @@ Michael Holzt <kju@debian.org>
 
 Diego Picciani <d.picciani@novacomp.it>
   for CyberLogin for Linux which allows logging onto EON
-  (in case you are wondering where CyberLogin is, EON changed its login 
+  (in case you are wondering where CyberLogin is, EON changed its login
   procedure and CyberLogin is no longer used.)
 
 Martin Schaller <martin@smurf.franken.de>
@@ -57,7 +57,7 @@ Augusto Cardoso <augusto@carhil.net>
 Davor Emard <emard@softhome.net>
   for his work on the budget drivers, the demux code,
   the module unloading problems, ...
-  
+
 Hans-Frieder Vogt <hfvogt@arcor.de>
   for his work on calculating and checking the crc's for the
   TechnoTrend/Hauppauge DEC driver firmware
diff --git a/Documentation/dvb/readme.txt b/Documentation/dvb/readme.txt
index 754c98c..f5c50b2 100644
--- a/Documentation/dvb/readme.txt
+++ b/Documentation/dvb/readme.txt
@@ -20,7 +20,7 @@ http://linuxtv.org/downloads/
 
 What's inside this directory:
 
-"cards.txt" 
+"cards.txt"
 contains a list of supported hardware.
 
 "contributors.txt"
@@ -37,7 +37,7 @@ that require it.
 contains detailed informations about the
 TT DEC2000/DEC3000 USB DVB hardware.
 
-"bt8xx.txt" 
+"bt8xx.txt"
 contains detailed installation instructions for the
 various bt8xx based "budget" DVB cards
 (Nebula, Pinnacle PCTV, Twinhan DST)
diff --git a/Documentation/filesystems/ext3.txt b/Documentation/filesystems/ext3.txt
index 9ab7f44..9840d5b 100644
--- a/Documentation/filesystems/ext3.txt
+++ b/Documentation/filesystems/ext3.txt
@@ -57,19 +57,19 @@ oldalloc		This disables the Orlov block 
 			we'd like to get some feedback if it's the contrary for
 			you.
 
-user_xattr	(*)	Enables POSIX Extended Attributes. It's enabled by
-			default, however you need to confifure its support
-			(CONFIG_EXT3_FS_XATTR). This is neccesary if you want
-			to use POSIX Acces Control Lists support. You can visit
-			http://acl.bestbits.at to know more about POSIX Extended
-			attributes.
-
-nouser_xattr		Disables POSIX Extended Attributes.
-
-acl		(*)	Enables POSIX Access Control Lists support. This is
-			enabled by default, however you need to configure
-			its support (CONFIG_EXT3_FS_POSIX_ACL). If you want
-			to know more about ACLs visit http://acl.bestbits.at
+user_xattr		Enables Extended User Attributes. Additionally, you need
+			to have extended attribute support enabled in the kernel
+			configuration (CONFIG_EXT3_FS_XATTR). See the attr(5)
+			manual page and http://acl.bestbits.at to learn more
+			about extended attributes.
+
+nouser_xattr		Disables Extended User Attributes.
+
+acl			Enables POSIX Access Control Lists support.  Additionally,
+			you need to have ACL support enabled in the kernel
+			configuration (CONFIG_EXT3_FS_POSIX_ACL). See the acl(5)
+			manual page and http://acl.bestbits.at for more
+			information.
 
 noacl			This option disables POSIX Access Control List support.
 
diff --git a/Makefile b/Makefile
index b1c458c..9c23347 100644
--- a/Makefile
+++ b/Makefile
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 15
-EXTRAVERSION =-rc5
+EXTRAVERSION = -rc5-git3
 NAME=Affluent Albatross
 
 # *DOCUMENTATION*
@@ -408,7 +408,7 @@ outputmakefile:
 # of make so .config is not included in this case either (for *config).
 
 no-dot-config-targets := clean mrproper distclean \
-			 cscope TAGS tags help %docs check% kernelrelease
+			 cscope TAGS tags help %docs check%
 
 config-targets := 0
 mixed-targets  := 0
diff --git a/arch/arm/kernel/ptrace.c b/arch/arm/kernel/ptrace.c
index 9a340e7..2b84f78 100644
--- a/arch/arm/kernel/ptrace.c
+++ b/arch/arm/kernel/ptrace.c
@@ -242,6 +242,15 @@ get_branch_address(struct task_struct *c
 		 */
 		long aluop1, aluop2, ccbit;
 
+	        if ((insn & 0x0fffffd0) == 0x012fff10) {
+		        /*
+			 * bx or blx
+			 */
+			alt = get_user_reg(child, insn & 15);
+			break;
+		}
+
+
 		if ((insn & 0xf000) != 0xf000)
 			break;
 
diff --git a/arch/i386/kernel/kprobes.c b/arch/i386/kernel/kprobes.c
index 32b0c24..19edcd5 100644
--- a/arch/i386/kernel/kprobes.c
+++ b/arch/i386/kernel/kprobes.c
@@ -191,7 +191,7 @@ static int __kprobes kprobe_handler(stru
 			 */
 			save_previous_kprobe(kcb);
 			set_current_kprobe(p, regs, kcb);
-			p->nmissed++;
+			kprobes_inc_nmissed_count(p);
 			prepare_singlestep(p, regs);
 			kcb->kprobe_status = KPROBE_REENTER;
 			return 1;
diff --git a/arch/i386/kernel/smpboot.c b/arch/i386/kernel/smpboot.c
index d16520d..9ed449a 100644
--- a/arch/i386/kernel/smpboot.c
+++ b/arch/i386/kernel/smpboot.c
@@ -1338,8 +1338,7 @@ int __cpu_disable(void)
 	if (cpu == 0)
 		return -EBUSY;
 
-	/* We enable the timer again on the exit path of the death loop */
-	disable_APIC_timer();
+	clear_local_APIC();
 	/* Allow any queued timer interrupts to get serviced */
 	local_irq_enable();
 	mdelay(1);
diff --git a/arch/i386/kernel/traps.c b/arch/i386/kernel/traps.c
index c34d1bf..f0dffa0 100644
--- a/arch/i386/kernel/traps.c
+++ b/arch/i386/kernel/traps.c
@@ -650,13 +650,6 @@ fastcall void do_nmi(struct pt_regs * re
 
 	cpu = smp_processor_id();
 
-#ifdef CONFIG_HOTPLUG_CPU
-	if (!cpu_online(cpu)) {
-		nmi_exit();
-		return;
-	}
-#endif
-
 	++nmi_count(cpu);
 
 	if (!rcu_dereference(nmi_callback)(regs, cpu))
diff --git a/arch/i386/mm/ioremap.c b/arch/i386/mm/ioremap.c
index 5d09de8..8498b5a 100644
--- a/arch/i386/mm/ioremap.c
+++ b/arch/i386/mm/ioremap.c
@@ -223,9 +223,15 @@ void __iomem *ioremap_nocache (unsigned 
 }
 EXPORT_SYMBOL(ioremap_nocache);
 
+/**
+ * iounmap - Free a IO remapping
+ * @addr: virtual address from ioremap_*
+ *
+ * Caller must ensure there is only one unmapping for the same pointer.
+ */
 void iounmap(volatile void __iomem *addr)
 {
-	struct vm_struct *p;
+	struct vm_struct *p, *o;
 
 	if ((void __force *)addr <= high_memory)
 		return;
@@ -239,22 +245,37 @@ void iounmap(volatile void __iomem *addr
 			addr < phys_to_virt(ISA_END_ADDRESS))
 		return;
 
-	write_lock(&vmlist_lock);
-	p = __remove_vm_area((void *)(PAGE_MASK & (unsigned long __force)addr));
-	if (!p) { 
-		printk(KERN_WARNING "iounmap: bad address %p\n", addr);
+	addr = (volatile void *)(PAGE_MASK & (unsigned long __force)addr);
+
+	/* Use the vm area unlocked, assuming the caller
+	   ensures there isn't another iounmap for the same address
+	   in parallel. Reuse of the virtual address is prevented by
+	   leaving it in the global lists until we're done with it.
+	   cpa takes care of the direct mappings. */
+	read_lock(&vmlist_lock);
+	for (p = vmlist; p; p = p->next) {
+		if (p->addr == addr)
+			break;
+	}
+	read_unlock(&vmlist_lock);
+
+	if (!p) {
+		printk("iounmap: bad address %p\n", addr);
 		dump_stack();
-		goto out_unlock;
+		return;
 	}
 
+	/* Reset the direct mapping. Can block */
 	if ((p->flags >> 20) && p->phys_addr < virt_to_phys(high_memory) - 1) {
 		change_page_attr(virt_to_page(__va(p->phys_addr)),
 				 p->size >> PAGE_SHIFT,
 				 PAGE_KERNEL);
 		global_flush_tlb();
 	} 
-out_unlock:
-	write_unlock(&vmlist_lock);
+
+	/* Finally remove it */
+	o = remove_vm_area((void *)addr);
+	BUG_ON(p != o || o == NULL);
 	kfree(p); 
 }
 EXPORT_SYMBOL(iounmap);
diff --git a/arch/i386/pci/direct.c b/arch/i386/pci/direct.c
index 94331d6..e3ac502 100644
--- a/arch/i386/pci/direct.c
+++ b/arch/i386/pci/direct.c
@@ -13,7 +13,7 @@
 #define PCI_CONF1_ADDRESS(bus, devfn, reg) \
 	(0x80000000 | (bus << 16) | (devfn << 8) | (reg & ~3))
 
-static int pci_conf1_read(unsigned int seg, unsigned int bus,
+int pci_conf1_read(unsigned int seg, unsigned int bus,
 			  unsigned int devfn, int reg, int len, u32 *value)
 {
 	unsigned long flags;
@@ -42,7 +42,7 @@ static int pci_conf1_read(unsigned int s
 	return 0;
 }
 
-static int pci_conf1_write(unsigned int seg, unsigned int bus,
+int pci_conf1_write(unsigned int seg, unsigned int bus,
 			   unsigned int devfn, int reg, int len, u32 value)
 {
 	unsigned long flags;
diff --git a/arch/i386/pci/mmconfig.c b/arch/i386/pci/mmconfig.c
index dfbf80c..08a0849 100644
--- a/arch/i386/pci/mmconfig.c
+++ b/arch/i386/pci/mmconfig.c
@@ -19,21 +19,25 @@
 /* The base address of the last MMCONFIG device accessed */
 static u32 mmcfg_last_accessed_device;
 
+static DECLARE_BITMAP(fallback_slots, 32);
+
 /*
  * Functions for accessing PCI configuration space with MMCONFIG accesses
  */
-static u32 get_base_addr(unsigned int seg, int bus)
+static u32 get_base_addr(unsigned int seg, int bus, unsigned devfn)
 {
 	int cfg_num = -1;
 	struct acpi_table_mcfg_config *cfg;
 
+	if (seg == 0 && bus == 0 &&
+	    test_bit(PCI_SLOT(devfn), fallback_slots))
+		return 0;
+
 	while (1) {
 		++cfg_num;
 		if (cfg_num >= pci_mmcfg_config_num) {
-			/* something bad is going on, no cfg table is found. */
-			/* so we fall back to the old way we used to do this */
-			/* and just rely on the first entry to be correct. */
-			return pci_mmcfg_config[0].base_address;
+			/* Not found - fallback to type 1 */
+			return 0;
 		}
 		cfg = &pci_mmcfg_config[cfg_num];
 		if (cfg->pci_segment_group_number != seg)
@@ -44,9 +48,9 @@ static u32 get_base_addr(unsigned int se
 	}
 }
 
-static inline void pci_exp_set_dev_base(unsigned int seg, int bus, int devfn)
+static inline void pci_exp_set_dev_base(unsigned int base, int bus, int devfn)
 {
-	u32 dev_base = get_base_addr(seg, bus) | (bus << 20) | (devfn << 12);
+	u32 dev_base = base | (bus << 20) | (devfn << 12);
 	if (dev_base != mmcfg_last_accessed_device) {
 		mmcfg_last_accessed_device = dev_base;
 		set_fixmap_nocache(FIX_PCIE_MCFG, dev_base);
@@ -57,13 +61,18 @@ static int pci_mmcfg_read(unsigned int s
 			  unsigned int devfn, int reg, int len, u32 *value)
 {
 	unsigned long flags;
+	u32 base;
 
 	if (!value || (bus > 255) || (devfn > 255) || (reg > 4095))
 		return -EINVAL;
 
+	base = get_base_addr(seg, bus, devfn);
+	if (!base)
+		return pci_conf1_read(seg,bus,devfn,reg,len,value);
+
 	spin_lock_irqsave(&pci_config_lock, flags);
 
-	pci_exp_set_dev_base(seg, bus, devfn);
+	pci_exp_set_dev_base(base, bus, devfn);
 
 	switch (len) {
 	case 1:
@@ -86,13 +95,18 @@ static int pci_mmcfg_write(unsigned int 
 			   unsigned int devfn, int reg, int len, u32 value)
 {
 	unsigned long flags;
+	u32 base;
 
 	if ((bus > 255) || (devfn > 255) || (reg > 4095)) 
 		return -EINVAL;
 
+	base = get_base_addr(seg, bus, devfn);
+	if (!base)
+		return pci_conf1_write(seg,bus,devfn,reg,len,value);
+
 	spin_lock_irqsave(&pci_config_lock, flags);
 
-	pci_exp_set_dev_base(seg, bus, devfn);
+	pci_exp_set_dev_base(base, bus, devfn);
 
 	switch (len) {
 	case 1:
@@ -116,6 +130,37 @@ static struct pci_raw_ops pci_mmcfg = {
 	.write =	pci_mmcfg_write,
 };
 
+/* K8 systems have some devices (typically in the builtin northbridge)
+   that are only accessible using type1
+   Normally this can be expressed in the MCFG by not listing them
+   and assigning suitable _SEGs, but this isn't implemented in some BIOS.
+   Instead try to discover all devices on bus 0 that are unreachable using MM
+   and fallback for them.
+   We only do this for bus 0/seg 0 */
+static __init void unreachable_devices(void)
+{
+	int i;
+	unsigned long flags;
+
+	for (i = 0; i < 32; i++) {
+		u32 val1;
+		u32 addr;
+
+		pci_conf1_read(0, 0, PCI_DEVFN(i, 0), 0, 4, &val1);
+		if (val1 == 0xffffffff)
+			continue;
+
+		/* Locking probably not needed, but safer */
+		spin_lock_irqsave(&pci_config_lock, flags);
+		addr = get_base_addr(0, 0, PCI_DEVFN(i, 0));
+		if (addr != 0)
+			pci_exp_set_dev_base(addr, 0, PCI_DEVFN(i, 0));
+		if (addr == 0 || readl((u32 *)addr) != val1)
+			set_bit(i, fallback_slots);
+		spin_unlock_irqrestore(&pci_config_lock, flags);
+	}
+}
+
 static int __init pci_mmcfg_init(void)
 {
 	if ((pci_probe & PCI_PROBE_MMCONF) == 0)
@@ -131,6 +176,8 @@ static int __init pci_mmcfg_init(void)
 	raw_pci_ops = &pci_mmcfg;
 	pci_probe = (pci_probe & ~PCI_PROBE_MASK) | PCI_PROBE_MMCONF;
 
+	unreachable_devices();
+
  out:
 	return 0;
 }
diff --git a/arch/i386/pci/pci.h b/arch/i386/pci/pci.h
index 127d53a..f550781 100644
--- a/arch/i386/pci/pci.h
+++ b/arch/i386/pci/pci.h
@@ -74,3 +74,10 @@ extern spinlock_t pci_config_lock;
 
 extern int (*pcibios_enable_irq)(struct pci_dev *dev);
 extern void (*pcibios_disable_irq)(struct pci_dev *dev);
+
+extern int pci_conf1_write(unsigned int seg, unsigned int bus,
+			   unsigned int devfn, int reg, int len, u32 value);
+extern int pci_conf1_read(unsigned int seg, unsigned int bus,
+			  unsigned int devfn, int reg, int len, u32 *value);
+
+
diff --git a/arch/ia64/Kconfig b/arch/ia64/Kconfig
index b76ce1f..199eeaf 100644
--- a/arch/ia64/Kconfig
+++ b/arch/ia64/Kconfig
@@ -58,7 +58,7 @@ config IA64_UNCACHED_ALLOCATOR
 	bool
 	select GENERIC_ALLOCATOR
 
-config ZONE_DMA_IS_DMA32
+config DMA_IS_DMA32
 	bool
 	default y
 
diff --git a/arch/ia64/configs/sn2_defconfig b/arch/ia64/configs/sn2_defconfig
index 87cfd31..e1924cc 100644
--- a/arch/ia64/configs/sn2_defconfig
+++ b/arch/ia64/configs/sn2_defconfig
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.13-rc6
-# Tue Aug 16 14:40:41 2005
+# Linux kernel version: 2.6.15-rc4
+# Fri Dec  2 10:33:48 2005
 #
 
 #
@@ -16,6 +16,7 @@ CONFIG_INIT_ENV_ARG_LIMIT=32
 # General setup
 #
 CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 CONFIG_POSIX_MQUEUE=y
@@ -26,6 +27,7 @@ CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
 CONFIG_CPUSETS=y
+CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_EMBEDDED is not set
 CONFIG_KALLSYMS=y
 CONFIG_KALLSYMS_ALL=y
@@ -56,11 +58,29 @@ CONFIG_KMOD=y
 CONFIG_STOP_MACHINE=y
 
 #
+# Block layer
+#
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
 # Processor type and features
 #
 CONFIG_IA64=y
 CONFIG_64BIT=y
 CONFIG_MMU=y
+CONFIG_SWIOTLB=y
 CONFIG_RWSEM_XCHGADD_ALGORITHM=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_TIME_INTERPOLATION=y
@@ -68,6 +88,7 @@ CONFIG_EFI=y
 CONFIG_GENERIC_IOMAP=y
 CONFIG_SCHED_NO_NO_OMIT_FRAME_POINTER=y
 CONFIG_IA64_UNCACHED_ALLOCATOR=y
+CONFIG_ZONE_DMA_IS_DMA32=y
 # CONFIG_IA64_GENERIC is not set
 # CONFIG_IA64_DIG is not set
 # CONFIG_IA64_HP_ZX1 is not set
@@ -87,14 +108,10 @@ CONFIG_HZ_250=y
 # CONFIG_HZ_1000 is not set
 CONFIG_HZ=250
 CONFIG_IA64_L1_CACHE_SHIFT=7
-CONFIG_NUMA=y
-CONFIG_VIRTUAL_MEM_MAP=y
-CONFIG_HOLES_IN_ZONE=y
-CONFIG_ARCH_DISCONTIGMEM_ENABLE=y
 # CONFIG_IA64_CYCLONE is not set
 CONFIG_IOSAPIC=y
 CONFIG_IA64_SGI_SN_XP=m
-CONFIG_FORCE_MAX_ZONEORDER=18
+CONFIG_FORCE_MAX_ZONEORDER=17
 CONFIG_SMP=y
 CONFIG_NR_CPUS=512
 # CONFIG_HOTPLUG_CPU is not set
@@ -107,7 +124,17 @@ CONFIG_DISCONTIGMEM_MANUAL=y
 CONFIG_DISCONTIGMEM=y
 CONFIG_FLAT_NODE_MEM_MAP=y
 CONFIG_NEED_MULTIPLE_NODES=y
-CONFIG_HAVE_DEC_LOCK=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_ARCH_DISCONTIGMEM_ENABLE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_DISCONTIGMEM_DEFAULT=y
+CONFIG_NUMA=y
+CONFIG_VIRTUAL_MEM_MAP=y
+CONFIG_HOLES_IN_ZONE=y
+CONFIG_HAVE_ARCH_EARLY_PFN_TO_NID=y
 CONFIG_IA32_SUPPORT=y
 CONFIG_COMPAT=y
 CONFIG_IA64_MCA_RECOVERY=y
@@ -126,28 +153,35 @@ CONFIG_BINFMT_ELF=y
 # Power management and ACPI
 #
 CONFIG_PM=y
-CONFIG_ACPI=y
+# CONFIG_PM_LEGACY is not set
+# CONFIG_PM_DEBUG is not set
 
 #
 # ACPI (Advanced Configuration and Power Interface) Support
 #
+CONFIG_ACPI=y
 # CONFIG_ACPI_BUTTON is not set
 # CONFIG_ACPI_FAN is not set
 # CONFIG_ACPI_PROCESSOR is not set
 CONFIG_ACPI_NUMA=y
+CONFIG_ACPI_BLACKLIST_YEAR=0
 # CONFIG_ACPI_DEBUG is not set
 CONFIG_ACPI_POWER=y
 CONFIG_ACPI_SYSTEM=y
 # CONFIG_ACPI_CONTAINER is not set
 
 #
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
 # Bus options (PCI, PCMCIA)
 #
 CONFIG_PCI=y
 CONFIG_PCI_DOMAINS=y
 # CONFIG_PCI_MSI is not set
 CONFIG_PCI_LEGACY_PROC=y
-CONFIG_PCI_NAMES=y
 # CONFIG_PCI_DEBUG is not set
 
 #
@@ -191,8 +225,8 @@ CONFIG_SYN_COOKIES=y
 # CONFIG_INET_ESP is not set
 # CONFIG_INET_IPCOMP is not set
 # CONFIG_INET_TUNNEL is not set
-CONFIG_IP_TCPDIAG=y
-# CONFIG_IP_TCPDIAG_IPV6 is not set
+CONFIG_INET_DIAG=m
+CONFIG_INET_TCP_DIAG=m
 # CONFIG_TCP_CONG_ADVANCED is not set
 CONFIG_TCP_CONG_BIC=y
 CONFIG_IPV6=m
@@ -205,6 +239,11 @@ CONFIG_IPV6=m
 # CONFIG_NETFILTER is not set
 
 #
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
 # SCTP Configuration (EXPERIMENTAL)
 #
 # CONFIG_IP_SCTP is not set
@@ -220,8 +259,11 @@ CONFIG_IPV6=m
 # CONFIG_NET_DIVERT is not set
 # CONFIG_ECONET is not set
 # CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
 # CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
 
 #
 # Network testing
@@ -230,6 +272,7 @@ CONFIG_IPV6=m
 # CONFIG_HAMRADIO is not set
 # CONFIG_IRDA is not set
 # CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
 
 #
 # Device Drivers
@@ -244,6 +287,11 @@ CONFIG_FW_LOADER=y
 # CONFIG_DEBUG_DRIVER is not set
 
 #
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
 # Memory Technology Devices (MTD)
 #
 # CONFIG_MTD is not set
@@ -275,16 +323,7 @@ CONFIG_BLK_DEV_RAM=y
 CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_BLK_DEV_RAM_SIZE=4096
 CONFIG_BLK_DEV_INITRD=y
-CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_CDROM_PKTCDVD is not set
-
-#
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
-CONFIG_IOSCHED_DEADLINE=y
-CONFIG_IOSCHED_CFQ=y
 CONFIG_ATA_OVER_ETH=m
 
 #
@@ -349,6 +388,7 @@ CONFIG_IDEDMA_AUTO=y
 #
 # SCSI device support
 #
+# CONFIG_RAID_ATTRS is not set
 CONFIG_SCSI=y
 CONFIG_SCSI_PROC_FS=y
 
@@ -375,11 +415,13 @@ CONFIG_SCSI_CONSTANTS=y
 #
 CONFIG_SCSI_SPI_ATTRS=y
 CONFIG_SCSI_FC_ATTRS=y
-# CONFIG_SCSI_ISCSI_ATTRS is not set
+CONFIG_SCSI_ISCSI_ATTRS=m
+CONFIG_SCSI_SAS_ATTRS=y
 
 #
 # SCSI low-level drivers
 #
+CONFIG_ISCSI_TCP=m
 # CONFIG_BLK_DEV_3W_XXXX_RAID is not set
 # CONFIG_SCSI_3W_9XXX is not set
 # CONFIG_SCSI_ACARD is not set
@@ -389,15 +431,19 @@ CONFIG_SCSI_FC_ATTRS=y
 # CONFIG_SCSI_AIC79XX is not set
 # CONFIG_MEGARAID_NEWGEN is not set
 # CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
 CONFIG_SCSI_SATA=y
 # CONFIG_SCSI_SATA_AHCI is not set
 # CONFIG_SCSI_SATA_SVW is not set
 # CONFIG_SCSI_ATA_PIIX is not set
+# CONFIG_SCSI_SATA_MV is not set
 # CONFIG_SCSI_SATA_NV is not set
-# CONFIG_SCSI_SATA_PROMISE is not set
+# CONFIG_SCSI_PDC_ADMA is not set
 # CONFIG_SCSI_SATA_QSTOR is not set
+# CONFIG_SCSI_SATA_PROMISE is not set
 # CONFIG_SCSI_SATA_SX4 is not set
 # CONFIG_SCSI_SATA_SIL is not set
+# CONFIG_SCSI_SATA_SIL24 is not set
 # CONFIG_SCSI_SATA_SIS is not set
 # CONFIG_SCSI_SATA_ULI is not set
 # CONFIG_SCSI_SATA_VIA is not set
@@ -411,7 +457,6 @@ CONFIG_SCSI_SATA_VITESSE=y
 # CONFIG_SCSI_IPR is not set
 # CONFIG_SCSI_QLOGIC_FC is not set
 CONFIG_SCSI_QLOGIC_1280=y
-# CONFIG_SCSI_QLOGIC_1280_1040 is not set
 CONFIG_SCSI_QLA2XXX=y
 # CONFIG_SCSI_QLA21XX is not set
 CONFIG_SCSI_QLA22XX=y
@@ -451,6 +496,7 @@ CONFIG_DM_MULTIPATH_EMC=m
 CONFIG_FUSION=y
 CONFIG_FUSION_SPI=y
 CONFIG_FUSION_FC=y
+CONFIG_FUSION_SAS=y
 CONFIG_FUSION_MAX_SGE=128
 CONFIG_FUSION_CTL=m
 
@@ -479,6 +525,10 @@ CONFIG_NETDEVICES=y
 # CONFIG_ARCNET is not set
 
 #
+# PHY device support
+#
+
+#
 # Ethernet (10 or 100Mbit)
 #
 # CONFIG_NET_ETHERNET is not set
@@ -493,6 +543,7 @@ CONFIG_NETDEVICES=y
 # CONFIG_HAMACHI is not set
 # CONFIG_YELLOWFIN is not set
 # CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
 # CONFIG_SKGE is not set
 # CONFIG_SK98LIN is not set
 CONFIG_TIGON3=y
@@ -501,10 +552,10 @@ CONFIG_TIGON3=y
 #
 # Ethernet (10000 Mbit)
 #
+CONFIG_CHELSIO_T1=m
 # CONFIG_IXGB is not set
 CONFIG_S2IO=m
 # CONFIG_S2IO_NAPI is not set
-# CONFIG_2BUFF_MODE is not set
 
 #
 # Token Ring devices
@@ -583,6 +634,7 @@ CONFIG_HW_CONSOLE=y
 CONFIG_SERIAL_NONSTANDARD=y
 # CONFIG_ROCKETPORT is not set
 # CONFIG_CYCLADES is not set
+# CONFIG_DIGIEPCA is not set
 # CONFIG_MOXA_SMARTIO is not set
 # CONFIG_ISI is not set
 # CONFIG_SYNCLINKMP is not set
@@ -629,7 +681,8 @@ CONFIG_EFI_RTC=y
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
+CONFIG_AGP=y
+CONFIG_AGP_SGI_TIOCA=y
 # CONFIG_DRM is not set
 CONFIG_RAW_DRIVER=m
 # CONFIG_HPET is not set
@@ -641,12 +694,12 @@ CONFIG_MMTIMER=y
 # TPM devices
 #
 # CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
 
 #
 # I2C support
 #
 # CONFIG_I2C is not set
-# CONFIG_I2C_SENSOR is not set
 
 #
 # Dallas's 1-wire bus
@@ -657,12 +710,17 @@ CONFIG_MMTIMER=y
 # Hardware Monitoring support
 #
 # CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
 
 #
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -721,12 +779,15 @@ CONFIG_USB_UHCI_HCD=m
 #
 # USB Device Class drivers
 #
-# CONFIG_USB_BLUETOOTH_TTY is not set
 # CONFIG_USB_ACM is not set
 # CONFIG_USB_PRINTER is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
 #
 # CONFIG_USB_STORAGE is not set
 
@@ -751,9 +812,11 @@ CONFIG_USB_HIDINPUT=y
 # CONFIG_USB_MTOUCH is not set
 # CONFIG_USB_ITMTOUCH is not set
 # CONFIG_USB_EGALAX is not set
+# CONFIG_USB_YEALINK is not set
 # CONFIG_USB_XPAD is not set
 # CONFIG_USB_ATI_REMOTE is not set
 # CONFIG_USB_KEYSPAN_REMOTE is not set
+# CONFIG_USB_APPLETOUCH is not set
 
 #
 # USB Imaging devices
@@ -824,11 +887,13 @@ CONFIG_USB_MON=y
 # InfiniBand support
 #
 CONFIG_INFINIBAND=m
-CONFIG_INFINIBAND_USER_VERBS=m
+# CONFIG_INFINIBAND_USER_MAD is not set
+CONFIG_INFINIBAND_USER_ACCESS=m
 CONFIG_INFINIBAND_MTHCA=m
 # CONFIG_INFINIBAND_MTHCA_DEBUG is not set
 CONFIG_INFINIBAND_IPOIB=m
 # CONFIG_INFINIBAND_IPOIB_DEBUG is not set
+CONFIG_INFINIBAND_SRP=m
 
 #
 # SN Devices
@@ -858,16 +923,12 @@ CONFIG_REISERFS_FS_POSIX_ACL=y
 CONFIG_REISERFS_FS_SECURITY=y
 # CONFIG_JFS_FS is not set
 CONFIG_FS_POSIX_ACL=y
-
-#
-# XFS support
-#
 CONFIG_XFS_FS=y
 CONFIG_XFS_EXPORT=y
-CONFIG_XFS_RT=y
 CONFIG_XFS_QUOTA=y
 # CONFIG_XFS_SECURITY is not set
 CONFIG_XFS_POSIX_ACL=y
+CONFIG_XFS_RT=y
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
 CONFIG_INOTIFY=y
@@ -878,6 +939,7 @@ CONFIG_QUOTACTL=y
 CONFIG_DNOTIFY=y
 CONFIG_AUTOFS_FS=m
 CONFIG_AUTOFS4_FS=m
+CONFIG_FUSE_FS=m
 
 #
 # CD-ROM/DVD Filesystems
@@ -904,13 +966,11 @@ CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVPTS_FS_XATTR is not set
 CONFIG_TMPFS=y
-CONFIG_TMPFS_XATTR=y
-CONFIG_TMPFS_SECURITY=y
 CONFIG_HUGETLBFS=y
 CONFIG_HUGETLB_PAGE=y
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=m
 
 #
 # Miscellaneous filesystems
@@ -959,6 +1019,7 @@ CONFIG_CIFS=m
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -1028,18 +1089,21 @@ CONFIG_NLS_UTF8=y
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=m
 CONFIG_CRC32=y
-# CONFIG_LIBCRC32C is not set
+CONFIG_LIBCRC32C=m
 CONFIG_ZLIB_INFLATE=m
 CONFIG_ZLIB_DEFLATE=m
 CONFIG_GENERIC_ALLOCATOR=y
 CONFIG_GENERIC_HARDIRQS=y
 CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_PENDING_IRQ=y
 
 #
-# Profiling support
+# Instrumentation Support
 #
 # CONFIG_PROFILING is not set
+# CONFIG_KPROBES is not set
 
 #
 # Kernel hacking
@@ -1048,6 +1112,7 @@ CONFIG_GENERIC_IRQ_PROBE=y
 CONFIG_DEBUG_KERNEL=y
 CONFIG_MAGIC_SYSRQ=y
 CONFIG_LOG_BUF_SHIFT=20
+CONFIG_DETECT_SOFTLOCKUP=y
 # CONFIG_SCHEDSTATS is not set
 # CONFIG_DEBUG_SLAB is not set
 CONFIG_DEBUG_PREEMPT=y
@@ -1056,7 +1121,8 @@ CONFIG_DEBUG_PREEMPT=y
 # CONFIG_DEBUG_KOBJECT is not set
 CONFIG_DEBUG_INFO=y
 # CONFIG_DEBUG_FS is not set
-# CONFIG_KPROBES is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_RCU_TORTURE_TEST is not set
 CONFIG_IA64_GRANULE_16MB=y
 # CONFIG_IA64_GRANULE_64MB is not set
 # CONFIG_IA64_PRINT_HAZARDS is not set
@@ -1097,7 +1163,7 @@ CONFIG_CRYPTO_DES=m
 # CONFIG_CRYPTO_ANUBIS is not set
 CONFIG_CRYPTO_DEFLATE=m
 # CONFIG_CRYPTO_MICHAEL_MIC is not set
-# CONFIG_CRYPTO_CRC32C is not set
+CONFIG_CRYPTO_CRC32C=m
 # CONFIG_CRYPTO_TEST is not set
 
 #
diff --git a/arch/ia64/configs/tiger_defconfig b/arch/ia64/configs/tiger_defconfig
index 9bc8bca..b1e8f09 100644
--- a/arch/ia64/configs/tiger_defconfig
+++ b/arch/ia64/configs/tiger_defconfig
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.14-rc1
-# Wed Sep 14 15:17:57 2005
+# Linux kernel version: 2.6.15-rc4
+# Fri Dec  2 16:06:32 2005
 #
 
 #
@@ -59,17 +59,36 @@ CONFIG_KMOD=y
 CONFIG_STOP_MACHINE=y
 
 #
+# Block layer
+#
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
 # Processor type and features
 #
 CONFIG_IA64=y
 CONFIG_64BIT=y
 CONFIG_MMU=y
+CONFIG_SWIOTLB=y
 CONFIG_RWSEM_XCHGADD_ALGORITHM=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_TIME_INTERPOLATION=y
 CONFIG_EFI=y
 CONFIG_GENERIC_IOMAP=y
 CONFIG_SCHED_NO_NO_OMIT_FRAME_POINTER=y
+CONFIG_ZONE_DMA_IS_DMA32=y
 # CONFIG_IA64_GENERIC is not set
 CONFIG_IA64_DIG=y
 # CONFIG_IA64_HP_ZX1 is not set
@@ -82,18 +101,16 @@ CONFIG_MCKINLEY=y
 # CONFIG_IA64_PAGE_SIZE_8KB is not set
 CONFIG_IA64_PAGE_SIZE_16KB=y
 # CONFIG_IA64_PAGE_SIZE_64KB is not set
+CONFIG_PGTABLE_3=y
+# CONFIG_PGTABLE_4 is not set
 # CONFIG_HZ_100 is not set
 CONFIG_HZ_250=y
 # CONFIG_HZ_1000 is not set
 CONFIG_HZ=250
 CONFIG_IA64_L1_CACHE_SHIFT=7
-# CONFIG_NUMA is not set
-CONFIG_VIRTUAL_MEM_MAP=y
-CONFIG_HOLES_IN_ZONE=y
 CONFIG_IA64_CYCLONE=y
 CONFIG_IOSAPIC=y
-# CONFIG_IA64_SGI_SN_XP is not set
-CONFIG_FORCE_MAX_ZONEORDER=18
+CONFIG_FORCE_MAX_ZONEORDER=17
 CONFIG_SMP=y
 CONFIG_NR_CPUS=4
 CONFIG_HOTPLUG_CPU=y
@@ -106,7 +123,13 @@ CONFIG_FLATMEM_MANUAL=y
 CONFIG_FLATMEM=y
 CONFIG_FLAT_NODE_MEM_MAP=y
 # CONFIG_SPARSEMEM_STATIC is not set
-CONFIG_HAVE_DEC_LOCK=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_ARCH_DISCONTIGMEM_ENABLE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_VIRTUAL_MEM_MAP=y
+CONFIG_HOLES_IN_ZONE=y
 CONFIG_IA32_SUPPORT=y
 CONFIG_COMPAT=y
 CONFIG_IA64_MCA_RECOVERY=y
@@ -118,7 +141,6 @@ CONFIG_IA64_PALINFO=y
 #
 CONFIG_EFI_VARS=y
 CONFIG_EFI_PCDP=y
-# CONFIG_DELL_RBU is not set
 CONFIG_BINFMT_ELF=y
 CONFIG_BINFMT_MISC=m
 
@@ -126,6 +148,7 @@ CONFIG_BINFMT_MISC=m
 # Power management and ACPI
 #
 CONFIG_PM=y
+CONFIG_PM_LEGACY=y
 # CONFIG_PM_DEBUG is not set
 
 #
@@ -226,14 +249,16 @@ CONFIG_TCP_CONG_BIC=y
 # CONFIG_NET_DIVERT is not set
 # CONFIG_ECONET is not set
 # CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
 # CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
 
 #
 # Network testing
 #
 # CONFIG_NET_PKTGEN is not set
-# CONFIG_NETFILTER_NETLINK is not set
 # CONFIG_HAMRADIO is not set
 # CONFIG_IRDA is not set
 # CONFIG_BT is not set
@@ -295,14 +320,6 @@ CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_BLK_DEV_RAM_SIZE=4096
 CONFIG_BLK_DEV_INITRD=y
 # CONFIG_CDROM_PKTCDVD is not set
-
-#
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
-CONFIG_IOSCHED_DEADLINE=y
-CONFIG_IOSCHED_CFQ=y
 # CONFIG_ATA_OVER_ETH is not set
 
 #
@@ -400,6 +417,7 @@ CONFIG_SCSI_FC_ATTRS=y
 #
 # SCSI low-level drivers
 #
+# CONFIG_ISCSI_TCP is not set
 # CONFIG_BLK_DEV_3W_XXXX_RAID is not set
 # CONFIG_SCSI_3W_9XXX is not set
 # CONFIG_SCSI_ACARD is not set
@@ -409,6 +427,7 @@ CONFIG_SCSI_FC_ATTRS=y
 # CONFIG_SCSI_AIC79XX is not set
 # CONFIG_MEGARAID_NEWGEN is not set
 # CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
 # CONFIG_SCSI_SATA is not set
 # CONFIG_SCSI_DMX3191D is not set
 # CONFIG_SCSI_FUTURE_DOMAIN is not set
@@ -424,7 +443,6 @@ CONFIG_SCSI_SYM53C8XX_MAX_TAGS=64
 CONFIG_SCSI_QLOGIC_FC=y
 # CONFIG_SCSI_QLOGIC_FC_FIRMWARE is not set
 CONFIG_SCSI_QLOGIC_1280=y
-# CONFIG_SCSI_QLOGIC_1280_1040 is not set
 CONFIG_SCSI_QLA2XXX=y
 CONFIG_SCSI_QLA21XX=m
 CONFIG_SCSI_QLA22XX=m
@@ -463,6 +481,7 @@ CONFIG_DM_ZERO=m
 CONFIG_FUSION=y
 CONFIG_FUSION_SPI=y
 CONFIG_FUSION_FC=y
+# CONFIG_FUSION_SAS is not set
 CONFIG_FUSION_MAX_SGE=128
 CONFIG_FUSION_CTL=y
 
@@ -503,6 +522,7 @@ CONFIG_NET_ETHERNET=y
 CONFIG_MII=m
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
 # CONFIG_NET_VENDOR_3COM is not set
 
 #
@@ -727,6 +747,7 @@ CONFIG_MAX_RAW_DEVS=256
 # TPM devices
 #
 # CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
 
 #
 # I2C support
@@ -812,12 +833,15 @@ CONFIG_USB_UHCI_HCD=y
 #
 # USB Device Class drivers
 #
-# CONFIG_USB_BLUETOOTH_TTY is not set
 # CONFIG_USB_ACM is not set
 # CONFIG_USB_PRINTER is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
 #
 CONFIG_USB_STORAGE=m
 # CONFIG_USB_STORAGE_DEBUG is not set
@@ -1123,9 +1147,10 @@ CONFIG_GENERIC_IRQ_PROBE=y
 CONFIG_GENERIC_PENDING_IRQ=y
 
 #
-# Profiling support
+# Instrumentation Support
 #
 # CONFIG_PROFILING is not set
+# CONFIG_KPROBES is not set
 
 #
 # Kernel hacking
@@ -1142,7 +1167,8 @@ CONFIG_DETECT_SOFTLOCKUP=y
 # CONFIG_DEBUG_KOBJECT is not set
 # CONFIG_DEBUG_INFO is not set
 # CONFIG_DEBUG_FS is not set
-# CONFIG_KPROBES is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_RCU_TORTURE_TEST is not set
 CONFIG_IA64_GRANULE_16MB=y
 # CONFIG_IA64_GRANULE_64MB is not set
 # CONFIG_IA64_PRINT_HAZARDS is not set
diff --git a/arch/ia64/ia32/binfmt_elf32.c b/arch/ia64/ia32/binfmt_elf32.c
index a7280d9..4e7a6a1 100644
--- a/arch/ia64/ia32/binfmt_elf32.c
+++ b/arch/ia64/ia32/binfmt_elf32.c
@@ -261,8 +261,6 @@ elf32_set_personality (void)
 {
 	set_personality(PER_LINUX32);
 	current->thread.map_base  = IA32_PAGE_OFFSET/3;
-	current->thread.task_size = IA32_PAGE_OFFSET;	/* use what Linux/x86 uses... */
-	set_fs(USER_DS);				/* set addr limit for new TASK_SIZE */
 }
 
 static unsigned long
diff --git a/arch/ia64/ia32/ia32priv.h b/arch/ia64/ia32/ia32priv.h
index e3e9290..68ceb4e 100644
--- a/arch/ia64/ia32/ia32priv.h
+++ b/arch/ia64/ia32/ia32priv.h
@@ -305,7 +305,6 @@ struct old_linux32_dirent {
 #define ELF_DATA	ELFDATA2LSB
 #define ELF_ARCH	EM_386
 
-#define IA32_PAGE_OFFSET	0xc0000000
 #define IA32_STACK_TOP		IA32_PAGE_OFFSET
 #define IA32_GATE_OFFSET	IA32_PAGE_OFFSET
 #define IA32_GATE_END		IA32_PAGE_OFFSET + PAGE_SIZE
diff --git a/arch/ia64/kernel/kprobes.c b/arch/ia64/kernel/kprobes.c
index 2895d6e..89a7040 100644
--- a/arch/ia64/kernel/kprobes.c
+++ b/arch/ia64/kernel/kprobes.c
@@ -630,7 +630,7 @@ static int __kprobes pre_kprobes_handler
 			 */
 			save_previous_kprobe(kcb);
 			set_current_kprobe(p, kcb);
-			p->nmissed++;
+			kprobes_inc_nmissed_count(p);
 			prepare_ss(p, regs);
 			kcb->kprobe_status = KPROBE_REENTER;
 			return 1;
diff --git a/arch/ia64/kernel/process.c b/arch/ia64/kernel/process.c
index 2e33665..a4da715 100644
--- a/arch/ia64/kernel/process.c
+++ b/arch/ia64/kernel/process.c
@@ -721,8 +721,11 @@ flush_thread (void)
 	/* drop floating-point and debug-register state if it exists: */
 	current->thread.flags &= ~(IA64_THREAD_FPH_VALID | IA64_THREAD_DBG_VALID);
 	ia64_drop_fpu(current);
-	if (IS_IA32_PROCESS(ia64_task_regs(current)))
+	if (IS_IA32_PROCESS(ia64_task_regs(current))) {
 		ia32_drop_partial_page_list(current);
+		current->thread.task_size = IA32_PAGE_OFFSET;
+		set_fs(USER_DS);
+	}
 }
 
 /*
diff --git a/arch/ia64/kernel/salinfo.c b/arch/ia64/kernel/salinfo.c
index ca68e6e..1461dc6 100644
--- a/arch/ia64/kernel/salinfo.c
+++ b/arch/ia64/kernel/salinfo.c
@@ -293,7 +293,7 @@ retry:
 		if (file->f_flags & O_NONBLOCK)
 			return -EAGAIN;
 		if (down_interruptible(&data->sem))
-			return -ERESTARTSYS;
+			return -EINTR;
 	}
 
 	n = data->cpu_check;
diff --git a/arch/ia64/mm/discontig.c b/arch/ia64/mm/discontig.c
index 0f776b0..c87d6d1 100644
--- a/arch/ia64/mm/discontig.c
+++ b/arch/ia64/mm/discontig.c
@@ -50,8 +50,10 @@ static nodemask_t memory_less_mask __ini
  * To prevent cache aliasing effects, align per-node structures so that they
  * start at addresses that are strided by node number.
  */
+#define MAX_NODE_ALIGN_OFFSET	(32 * 1024 * 1024)
 #define NODEDATA_ALIGN(addr, node)						\
-	((((addr) + 1024*1024-1) & ~(1024*1024-1)) + (node)*PERCPU_PAGE_SIZE)
+	((((addr) + 1024*1024-1) & ~(1024*1024-1)) + 				\
+	     (((node)*PERCPU_PAGE_SIZE) & (MAX_NODE_ALIGN_OFFSET - 1)))
 
 /**
  * build_node_maps - callback to setup bootmem structs for each node
diff --git a/arch/ia64/sn/kernel/io_init.c b/arch/ia64/sn/kernel/io_init.c
index 05e4ea8..318087e 100644
--- a/arch/ia64/sn/kernel/io_init.c
+++ b/arch/ia64/sn/kernel/io_init.c
@@ -3,7 +3,7 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 1992 - 1997, 2000-2004 Silicon Graphics, Inc. All rights reserved.
+ * Copyright (C) 1992 - 1997, 2000-2005 Silicon Graphics, Inc. All rights reserved.
  */
 
 #include <linux/bootmem.h>
@@ -147,6 +147,24 @@ sal_get_pcidev_info(u64 segment, u64 bus
 }
 
 /*
+ * sn_pcidev_info_get() - Retrieve the pcidev_info struct for the specified
+ *			  device.
+ */
+inline struct pcidev_info *
+sn_pcidev_info_get(struct pci_dev *dev)
+{
+	struct pcidev_info *pcidev;
+
+	list_for_each_entry(pcidev,
+			    &(SN_PCI_CONTROLLER(dev)->pcidev_info), pdi_list) {
+		if (pcidev->pdi_linux_pcidev == dev) {
+			return pcidev;
+		}
+	}
+	return NULL;
+}
+
+/*
  * sn_fixup_ionodes() - This routine initializes the HUB data strcuture for 
  *	each node in the system.
  */
@@ -229,6 +247,50 @@ static void sn_fixup_ionodes(void)
 
 }
 
+/*
+ * sn_pci_window_fixup() - Create a pci_window for each device resource.
+ *			   Until ACPI support is added, we need this code
+ *			   to setup pci_windows for use by
+ *			   pcibios_bus_to_resource(),
+ *			   pcibios_resource_to_bus(), etc.
+ */
+static void
+sn_pci_window_fixup(struct pci_dev *dev, unsigned int count,
+		    int64_t * pci_addrs)
+{
+	struct pci_controller *controller = PCI_CONTROLLER(dev->bus);
+	unsigned int i;
+	unsigned int idx;
+	unsigned int new_count;
+	struct pci_window *new_window;
+
+	if (count == 0)
+		return;
+	idx = controller->windows;
+	new_count = controller->windows + count;
+	new_window = kcalloc(new_count, sizeof(struct pci_window), GFP_KERNEL);
+	if (new_window == NULL)
+		BUG();
+	if (controller->window) {
+		memcpy(new_window, controller->window,
+		       sizeof(struct pci_window) * controller->windows);
+		kfree(controller->window);
+	}
+
+	/* Setup a pci_window for each device resource. */
+	for (i = 0; i <= PCI_ROM_RESOURCE; i++) {
+		if (pci_addrs[i] == -1)
+			continue;
+
+		new_window[idx].offset = dev->resource[i].start - pci_addrs[i];
+		new_window[idx].resource = dev->resource[i];
+		idx++;
+	}
+
+	controller->windows = new_count;
+	controller->window = new_window;
+}
+
 void sn_pci_unfixup_slot(struct pci_dev *dev)
 {
 	struct pci_dev *host_pci_dev = SN_PCIDEV_INFO(dev)->host_pci_dev;
@@ -246,21 +308,23 @@ void sn_pci_unfixup_slot(struct pci_dev 
  */
 void sn_pci_fixup_slot(struct pci_dev *dev)
 {
+	unsigned int count = 0;
 	int idx;
 	int segment = pci_domain_nr(dev->bus);
 	int status = 0;
 	struct pcibus_bussoft *bs;
  	struct pci_bus *host_pci_bus;
  	struct pci_dev *host_pci_dev;
+	struct pcidev_info *pcidev_info;
+	int64_t pci_addrs[PCI_ROM_RESOURCE + 1];
  	struct sn_irq_info *sn_irq_info;
  	unsigned long size;
  	unsigned int bus_no, devfn;
 
 	pci_dev_get(dev); /* for the sysdata pointer */
-	dev->sysdata = kmalloc(sizeof(struct pcidev_info), GFP_KERNEL);
-	if (SN_PCIDEV_INFO(dev) <= 0)
+	pcidev_info = kzalloc(sizeof(struct pcidev_info), GFP_KERNEL);
+	if (pcidev_info <= 0)
 		BUG();		/* Cannot afford to run out of memory */
-	memset(SN_PCIDEV_INFO(dev), 0, sizeof(struct pcidev_info));
 
 	sn_irq_info = kmalloc(sizeof(struct sn_irq_info), GFP_KERNEL);
 	if (sn_irq_info <= 0)
@@ -270,22 +334,34 @@ void sn_pci_fixup_slot(struct pci_dev *d
 	/* Call to retrieve pci device information needed by kernel. */
 	status = sal_get_pcidev_info((u64) segment, (u64) dev->bus->number, 
 				     dev->devfn,
-				     (u64) __pa(SN_PCIDEV_INFO(dev)),
+				     (u64) __pa(pcidev_info),
 				     (u64) __pa(sn_irq_info));
 	if (status)
 		BUG(); /* Cannot get platform pci device information */
 
+	/* Add pcidev_info to list in sn_pci_controller struct */
+	list_add_tail(&pcidev_info->pdi_list,
+		      &(SN_PCI_CONTROLLER(dev->bus)->pcidev_info));
+
 	/* Copy over PIO Mapped Addresses */
 	for (idx = 0; idx <= PCI_ROM_RESOURCE; idx++) {
 		unsigned long start, end, addr;
 
-		if (!SN_PCIDEV_INFO(dev)->pdi_pio_mapped_addr[idx])
+		if (!pcidev_info->pdi_pio_mapped_addr[idx]) {
+			pci_addrs[idx] = -1;
 			continue;
+		}
 
 		start = dev->resource[idx].start;
 		end = dev->resource[idx].end;
 		size = end - start;
-		addr = SN_PCIDEV_INFO(dev)->pdi_pio_mapped_addr[idx];
+		if (size == 0) {
+			pci_addrs[idx] = -1;
+			continue;
+		}
+		pci_addrs[idx] = start;
+		count++;
+		addr = pcidev_info->pdi_pio_mapped_addr[idx];
 		addr = ((addr << 4) >> 4) | __IA64_UNCACHED_OFFSET;
 		dev->resource[idx].start = addr;
 		dev->resource[idx].end = addr + size;
@@ -294,23 +370,27 @@ void sn_pci_fixup_slot(struct pci_dev *d
 		else
 			dev->resource[idx].parent = &iomem_resource;
 	}
+	/* Create a pci_window in the pci_controller struct for
+	 * each device resource.
+	 */
+	if (count > 0)
+		sn_pci_window_fixup(dev, count, pci_addrs);
 
 	/*
 	 * Using the PROMs values for the PCI host bus, get the Linux
  	 * PCI host_pci_dev struct and set up host bus linkages
  	 */
 
- 	bus_no = (SN_PCIDEV_INFO(dev)->pdi_slot_host_handle >> 32) & 0xff;
- 	devfn = SN_PCIDEV_INFO(dev)->pdi_slot_host_handle & 0xffffffff;
+	bus_no = (pcidev_info->pdi_slot_host_handle >> 32) & 0xff;
+	devfn = pcidev_info->pdi_slot_host_handle & 0xffffffff;
  	host_pci_bus = pci_find_bus(segment, bus_no);
  	host_pci_dev = pci_get_slot(host_pci_bus, devfn);
 
-	SN_PCIDEV_INFO(dev)->host_pci_dev = host_pci_dev;
-	SN_PCIDEV_INFO(dev)->pdi_host_pcidev_info =
-	    					SN_PCIDEV_INFO(host_pci_dev);
-	SN_PCIDEV_INFO(dev)->pdi_linux_pcidev = dev;
+	pcidev_info->host_pci_dev = host_pci_dev;
+	pcidev_info->pdi_linux_pcidev = dev;
+	pcidev_info->pdi_host_pcidev_info = SN_PCIDEV_INFO(host_pci_dev);
 	bs = SN_PCIBUS_BUSSOFT(dev->bus);
-	SN_PCIDEV_INFO(dev)->pdi_pcibus_info = bs;
+	pcidev_info->pdi_pcibus_info = bs;
 
 	if (bs && bs->bs_asic_type < PCIIO_ASIC_MAX_TYPES) {
 		SN_PCIDEV_BUSPROVIDER(dev) = sn_pci_provider[bs->bs_asic_type];
@@ -320,11 +400,11 @@ void sn_pci_fixup_slot(struct pci_dev *d
 
 	/* Only set up IRQ stuff if this device has a host bus context */
 	if (bs && sn_irq_info->irq_irq) {
-		SN_PCIDEV_INFO(dev)->pdi_sn_irq_info = sn_irq_info;
-		dev->irq = SN_PCIDEV_INFO(dev)->pdi_sn_irq_info->irq_irq;
+		pcidev_info->pdi_sn_irq_info = sn_irq_info;
+		dev->irq = pcidev_info->pdi_sn_irq_info->irq_irq;
 		sn_irq_fixup(dev, sn_irq_info);
 	} else {
-		SN_PCIDEV_INFO(dev)->pdi_sn_irq_info = NULL;
+		pcidev_info->pdi_sn_irq_info = NULL;
 		kfree(sn_irq_info);
 	}
 }
@@ -338,6 +418,7 @@ void sn_pci_controller_fixup(int segment
 	int status = 0;
 	int nasid, cnode;
 	struct pci_controller *controller;
+	struct sn_pci_controller *sn_controller;
 	struct pcibus_bussoft *prom_bussoft_ptr;
 	struct hubdev_info *hubdev_info;
 	void *provider_soft = NULL;
@@ -349,10 +430,15 @@ void sn_pci_controller_fixup(int segment
 		return;		/*bus # does not exist */
 	prom_bussoft_ptr = __va(prom_bussoft_ptr);
 
- 	controller = kzalloc(sizeof(struct pci_controller), GFP_KERNEL);
+	/* Allocate a sn_pci_controller, which has a pci_controller struct
+	 * as the first member.
+	 */
+	sn_controller = kzalloc(sizeof(struct sn_pci_controller), GFP_KERNEL);
+	if (!sn_controller)
+		BUG();
+	INIT_LIST_HEAD(&sn_controller->pcidev_info);
+	controller = &sn_controller->pci_controller;
 	controller->segment = segment;
- 	if (!controller)
- 		BUG();
 
 	if (bus == NULL) {
  		bus = pci_scan_bus(busnum, &pci_root_ops, controller);
@@ -390,6 +476,29 @@ void sn_pci_controller_fixup(int segment
 	}
 
 	/*
+	 * Setup pci_windows for legacy IO and MEM space.
+	 * (Temporary until ACPI support is in place.)
+	 */
+	controller->window = kcalloc(2, sizeof(struct pci_window), GFP_KERNEL);
+	if (controller->window == NULL)
+		BUG();
+	controller->window[0].offset = prom_bussoft_ptr->bs_legacy_io;
+	controller->window[0].resource.name = "legacy_io";
+	controller->window[0].resource.flags = IORESOURCE_IO;
+	controller->window[0].resource.start = prom_bussoft_ptr->bs_legacy_io;
+	controller->window[0].resource.end =
+	    controller->window[0].resource.start + 0xffff;
+	controller->window[0].resource.parent = &ioport_resource;
+	controller->window[1].offset = prom_bussoft_ptr->bs_legacy_mem;
+	controller->window[1].resource.name = "legacy_mem";
+	controller->window[1].resource.flags = IORESOURCE_MEM;
+	controller->window[1].resource.start = prom_bussoft_ptr->bs_legacy_mem;
+	controller->window[1].resource.end =
+	    controller->window[1].resource.start + (1024 * 1024) - 1;
+	controller->window[1].resource.parent = &iomem_resource;
+	controller->windows = 2;
+
+	/*
 	 * Generic bus fixup goes here.  Don't reference prom_bussoft_ptr
 	 * after this point.
 	 */
@@ -421,7 +530,7 @@ void sn_pci_controller_fixup(int segment
 
 error_return:
 
-	kfree(controller);
+	kfree(sn_controller);
 	return;
 }
 
@@ -434,7 +543,7 @@ void sn_bus_store_sysdata(struct pci_dev
 		dev_dbg(dev, "%s: out of memory!\n", __FUNCTION__);
 		return;
 	}
-	element->sysdata = dev->sysdata;
+	element->sysdata = SN_PCIDEV_INFO(dev);
 	list_add(&element->entry, &sn_sysdata_list);
 }
 
diff --git a/arch/ia64/sn/kernel/sn2/ptc_deadlock.S b/arch/ia64/sn/kernel/sn2/ptc_deadlock.S
index 3fa9506..bebbcc4 100644
--- a/arch/ia64/sn/kernel/sn2/ptc_deadlock.S
+++ b/arch/ia64/sn/kernel/sn2/ptc_deadlock.S
@@ -39,9 +39,13 @@ sn2_ptc_deadlock_recovery_core:
 	mov	r8=r0
 
 1:
+	cmp.ne  p8,p9=r0,ptc1		// Test for shub type (ptc1 non-null on shub1)
+					// p8 = 1 if shub1, p9 = 1 if shub2
+
 	add	scr2=ALIAS_OFFSET,piowc	// Address of WRITE_STATUS alias register 
-	;;
-	ld8.acq	scr1=[scr2];;
+	mov	scr1=7;;		// Clear DEADLOCK, WRITE_ERROR, MULTI_WRITE_ERROR
+(p8)	st8.rel	[scr2]=scr1;;
+(p9)	ld8.acq	scr1=[scr2];;
 
 5:	ld8.acq	scr1=[piowc];;		// Wait for PIOs to complete.
 	hint	@pause
diff --git a/arch/mips/mm/init.c b/arch/mips/mm/init.c
index 3a49036..4ee91c9 100644
--- a/arch/mips/mm/init.c
+++ b/arch/mips/mm/init.c
@@ -67,8 +67,8 @@ unsigned long setup_zero_pages(void)
 
 	page = virt_to_page(empty_zero_page);
 	while (page < virt_to_page(empty_zero_page + (PAGE_SIZE << order))) {
-		set_bit(PG_reserved, &page->flags);
-		reset_page_mapcount(page);
+		SetPageReserved(page);
+		set_page_count(page, 1);
 		page++;
 	}
 
diff --git a/arch/powerpc/Kconfig b/arch/powerpc/Kconfig
index bb2efdd..db93dbc 100644
--- a/arch/powerpc/Kconfig
+++ b/arch/powerpc/Kconfig
@@ -227,7 +227,7 @@ config SMP
 	  If you don't know what to do here, say N.
 
 config NR_CPUS
-	int "Maximum number of CPUs (2-32)"
+	int "Maximum number of CPUs (2-128)"
 	range 2 128
 	depends on SMP
 	default "32" if PPC64
diff --git a/arch/powerpc/kernel/kprobes.c b/arch/powerpc/kernel/kprobes.c
index 511af54..5368f9c 100644
--- a/arch/powerpc/kernel/kprobes.c
+++ b/arch/powerpc/kernel/kprobes.c
@@ -177,7 +177,7 @@ static inline int kprobe_handler(struct 
 			save_previous_kprobe(kcb);
 			set_current_kprobe(p, regs, kcb);
 			kcb->kprobe_saved_msr = regs->msr;
-			p->nmissed++;
+			kprobes_inc_nmissed_count(p);
 			prepare_singlestep(p, regs);
 			kcb->kprobe_status = KPROBE_REENTER;
 			return 1;
diff --git a/arch/powerpc/kernel/setup_64.c b/arch/powerpc/kernel/setup_64.c
index 608fee7..e3fb783 100644
--- a/arch/powerpc/kernel/setup_64.c
+++ b/arch/powerpc/kernel/setup_64.c
@@ -102,7 +102,15 @@ int boot_cpuid_phys = 0;
 dev_t boot_dev;
 u64 ppc64_pft_size;
 
-struct ppc64_caches ppc64_caches;
+/* Pick defaults since we might want to patch instructions
+ * before we've read this from the device tree.
+ */
+struct ppc64_caches ppc64_caches = {
+	.dline_size = 0x80,
+	.log_dline_size = 7,
+	.iline_size = 0x80,
+	.log_iline_size = 7
+};
 EXPORT_SYMBOL_GPL(ppc64_caches);
 
 /*
diff --git a/arch/powerpc/mm/hash_utils_64.c b/arch/powerpc/mm/hash_utils_64.c
index 706e8a6..a33583f 100644
--- a/arch/powerpc/mm/hash_utils_64.c
+++ b/arch/powerpc/mm/hash_utils_64.c
@@ -601,7 +601,7 @@ int hash_page(unsigned long ea, unsigned
 	/* Handle hugepage regions */
 	if (unlikely(in_hugepage_area(mm->context, ea))) {
 		DBG_LOW(" -> huge page !\n");
-		return hash_huge_page(mm, access, ea, vsid, local);
+		return hash_huge_page(mm, access, ea, vsid, local, trap);
 	}
 
 	/* Get PTE and page size from page tables */
diff --git a/arch/powerpc/mm/hugetlbpage.c b/arch/powerpc/mm/hugetlbpage.c
index 6bc9dba..54131b8 100644
--- a/arch/powerpc/mm/hugetlbpage.c
+++ b/arch/powerpc/mm/hugetlbpage.c
@@ -148,43 +148,63 @@ int is_aligned_hugepage_range(unsigned l
 	return 0;
 }
 
+struct slb_flush_info {
+	struct mm_struct *mm;
+	u16 newareas;
+};
+
 static void flush_low_segments(void *parm)
 {
-	u16 areas = (unsigned long) parm;
+	struct slb_flush_info *fi = parm;
 	unsigned long i;
 
-	asm volatile("isync" : : : "memory");
+	BUILD_BUG_ON((sizeof(fi->newareas)*8) != NUM_LOW_AREAS);
+
+	if (current->active_mm != fi->mm)
+		return;
+
+	/* Only need to do anything if this CPU is working in the same
+	 * mm as the one which has changed */
 
-	BUILD_BUG_ON((sizeof(areas)*8) != NUM_LOW_AREAS);
+	/* update the paca copy of the context struct */
+	get_paca()->context = current->active_mm->context;
 
+	asm volatile("isync" : : : "memory");
 	for (i = 0; i < NUM_LOW_AREAS; i++) {
-		if (! (areas & (1U << i)))
+		if (! (fi->newareas & (1U << i)))
 			continue;
 		asm volatile("slbie %0"
 			     : : "r" ((i << SID_SHIFT) | SLBIE_C));
 	}
-
 	asm volatile("isync" : : : "memory");
 }
 
 static void flush_high_segments(void *parm)
 {
-	u16 areas = (unsigned long) parm;
+	struct slb_flush_info *fi = parm;
 	unsigned long i, j;
 
-	asm volatile("isync" : : : "memory");
 
-	BUILD_BUG_ON((sizeof(areas)*8) != NUM_HIGH_AREAS);
+	BUILD_BUG_ON((sizeof(fi->newareas)*8) != NUM_HIGH_AREAS);
 
+	if (current->active_mm != fi->mm)
+		return;
+
+	/* Only need to do anything if this CPU is working in the same
+	 * mm as the one which has changed */
+
+	/* update the paca copy of the context struct */
+	get_paca()->context = current->active_mm->context;
+
+	asm volatile("isync" : : : "memory");
 	for (i = 0; i < NUM_HIGH_AREAS; i++) {
-		if (! (areas & (1U << i)))
+		if (! (fi->newareas & (1U << i)))
 			continue;
 		for (j = 0; j < (1UL << (HTLB_AREA_SHIFT-SID_SHIFT)); j++)
 			asm volatile("slbie %0"
 				     :: "r" (((i << HTLB_AREA_SHIFT)
-					     + (j << SID_SHIFT)) | SLBIE_C));
+					      + (j << SID_SHIFT)) | SLBIE_C));
 	}
-
 	asm volatile("isync" : : : "memory");
 }
 
@@ -229,6 +249,7 @@ static int prepare_high_area_for_htlb(st
 static int open_low_hpage_areas(struct mm_struct *mm, u16 newareas)
 {
 	unsigned long i;
+	struct slb_flush_info fi;
 
 	BUILD_BUG_ON((sizeof(newareas)*8) != NUM_LOW_AREAS);
 	BUILD_BUG_ON((sizeof(mm->context.low_htlb_areas)*8) != NUM_LOW_AREAS);
@@ -244,19 +265,20 @@ static int open_low_hpage_areas(struct m
 
 	mm->context.low_htlb_areas |= newareas;
 
-	/* update the paca copy of the context struct */
-	get_paca()->context = mm->context;
-
 	/* the context change must make it to memory before the flush,
 	 * so that further SLB misses do the right thing. */
 	mb();
-	on_each_cpu(flush_low_segments, (void *)(unsigned long)newareas, 0, 1);
+
+	fi.mm = mm;
+	fi.newareas = newareas;
+	on_each_cpu(flush_low_segments, &fi, 0, 1);
 
 	return 0;
 }
 
 static int open_high_hpage_areas(struct mm_struct *mm, u16 newareas)
 {
+	struct slb_flush_info fi;
 	unsigned long i;
 
 	BUILD_BUG_ON((sizeof(newareas)*8) != NUM_HIGH_AREAS);
@@ -280,7 +302,10 @@ static int open_high_hpage_areas(struct 
 	/* the context change must make it to memory before the flush,
 	 * so that further SLB misses do the right thing. */
 	mb();
-	on_each_cpu(flush_high_segments, (void *)(unsigned long)newareas, 0, 1);
+
+	fi.mm = mm;
+	fi.newareas = newareas;
+	on_each_cpu(flush_high_segments, &fi, 0, 1);
 
 	return 0;
 }
@@ -639,8 +664,36 @@ unsigned long hugetlb_get_unmapped_area(
 	return -ENOMEM;
 }
 
+/*
+ * Called by asm hashtable.S for doing lazy icache flush
+ */
+static unsigned int hash_huge_page_do_lazy_icache(unsigned long rflags,
+						  pte_t pte, int trap)
+{
+	struct page *page;
+	int i;
+
+	if (!pfn_valid(pte_pfn(pte)))
+		return rflags;
+
+	page = pte_page(pte);
+
+	/* page is dirty */
+	if (!test_bit(PG_arch_1, &page->flags) && !PageReserved(page)) {
+		if (trap == 0x400) {
+			for (i = 0; i < (HPAGE_SIZE / PAGE_SIZE); i++)
+				__flush_dcache_icache(page_address(page+i));
+			set_bit(PG_arch_1, &page->flags);
+		} else {
+			rflags |= HPTE_R_N;
+		}
+	}
+	return rflags;
+}
+
 int hash_huge_page(struct mm_struct *mm, unsigned long access,
-		   unsigned long ea, unsigned long vsid, int local)
+		   unsigned long ea, unsigned long vsid, int local,
+		   unsigned long trap)
 {
 	pte_t *ptep;
 	unsigned long old_pte, new_pte;
@@ -691,6 +744,11 @@ int hash_huge_page(struct mm_struct *mm,
 	rflags = 0x2 | (!(new_pte & _PAGE_RW));
  	/* _PAGE_EXEC -> HW_NO_EXEC since it's inverted */
 	rflags |= ((new_pte & _PAGE_EXEC) ? 0 : HPTE_R_N);
+	if (!cpu_has_feature(CPU_FTR_COHERENT_ICACHE))
+		/* No CPU has hugepages but lacks no execute, so we
+		 * don't need to worry about that case */
+		rflags = hash_huge_page_do_lazy_icache(rflags, __pte(old_pte),
+						       trap);
 
 	/* Check if pte already has an hpte (case 2) */
 	if (unlikely(old_pte & _PAGE_HASHPTE)) {
@@ -703,7 +761,8 @@ int hash_huge_page(struct mm_struct *mm,
 		slot = (hash & htab_hash_mask) * HPTES_PER_GROUP;
 		slot += (old_pte & _PAGE_F_GIX) >> 12;
 
-		if (ppc_md.hpte_updatepp(slot, rflags, va, 1, local) == -1)
+		if (ppc_md.hpte_updatepp(slot, rflags, va, mmu_huge_psize,
+					 local) == -1)
 			old_pte &= ~_PAGE_HPTEFLAGS;
 	}
 
diff --git a/arch/powerpc/mm/numa.c b/arch/powerpc/mm/numa.c
index f72cf87..ba7a305 100644
--- a/arch/powerpc/mm/numa.c
+++ b/arch/powerpc/mm/numa.c
@@ -125,7 +125,7 @@ void __init get_region(unsigned int nid,
 
 	/* We didnt find a matching region, return start/end as 0 */
 	if (*start_pfn == -1UL)
-		start_pfn = 0;
+		*start_pfn = 0;
 }
 
 static inline void map_cpu_to_node(int cpu, int node)
diff --git a/arch/powerpc/mm/stab.c b/arch/powerpc/mm/stab.c
index cfbb4e1..51e7951 100644
--- a/arch/powerpc/mm/stab.c
+++ b/arch/powerpc/mm/stab.c
@@ -288,11 +288,6 @@ void stab_initialize(unsigned long stab)
 		return;
 	}
 #endif /* CONFIG_PPC_ISERIES */
-#ifdef CONFIG_PPC_PSERIES
-	if (platform_is_lpar()) {
-		plpar_hcall_norets(H_SET_ASR, stabreal);
-		return;
-	}
-#endif
+
 	mtspr(SPRN_ASR, stabreal);
 }
diff --git a/arch/powerpc/platforms/powermac/feature.c b/arch/powerpc/platforms/powermac/feature.c
index 0d7fa00..f6e22da 100644
--- a/arch/powerpc/platforms/powermac/feature.c
+++ b/arch/powerpc/platforms/powermac/feature.c
@@ -1650,11 +1650,19 @@ void pmac_tweak_clock_spreading(int enab
 	 */
 
 	if (macio->type == macio_intrepid) {
-		if (enable)
-			UN_OUT(UNI_N_CLOCK_SPREADING, 2);
-		else
-			UN_OUT(UNI_N_CLOCK_SPREADING, 0);
-		mdelay(40);
+		struct device_node *clock =
+			of_find_node_by_path("/uni-n@f8000000/hw-clock");
+		if (clock && get_property(clock, "platform-do-clockspreading",
+					  NULL)) {
+			printk(KERN_INFO "%sabling clock spreading on Intrepid"
+			       " ASIC\n", enable ? "En" : "Dis");
+			if (enable)
+				UN_OUT(UNI_N_CLOCK_SPREADING, 2);
+			else
+				UN_OUT(UNI_N_CLOCK_SPREADING, 0);
+			mdelay(40);
+		}
+		of_node_put(clock);
 	}
 
 	while (machine_is_compatible("PowerBook5,2") ||
@@ -1724,6 +1732,9 @@ void pmac_tweak_clock_spreading(int enab
 			pmac_low_i2c_close(ui2c);
 			break;
 		}
+		printk(KERN_INFO "%sabling clock spreading on i2c clock chip\n",
+		       enable ? "En" : "Dis");
+
 		pmac_low_i2c_setmode(ui2c, pmac_low_i2c_mode_stdsub);
 		rc = pmac_low_i2c_xfer(ui2c, 0xd2 | pmac_low_i2c_write, 0x80, buffer, 9);
 		DBG("write result: %d,", rc);
diff --git a/arch/powerpc/platforms/pseries/iommu.c b/arch/powerpc/platforms/pseries/iommu.c
index c78f2b2..2043659 100644
--- a/arch/powerpc/platforms/pseries/iommu.c
+++ b/arch/powerpc/platforms/pseries/iommu.c
@@ -109,6 +109,9 @@ static void tce_build_pSeriesLP(struct i
 	u64 rc;
 	union tce_entry tce;
 
+	tcenum <<= TCE_PAGE_FACTOR;
+	npages <<= TCE_PAGE_FACTOR;
+
 	tce.te_word = 0;
 	tce.te_rpn = (virt_to_abs(uaddr)) >> TCE_SHIFT;
 	tce.te_rdwr = 1;
@@ -143,10 +146,7 @@ static void tce_buildmulti_pSeriesLP(str
 	union tce_entry tce, *tcep;
 	long l, limit;
 
-	tcenum <<= TCE_PAGE_FACTOR;
-	npages <<= TCE_PAGE_FACTOR;
-
-	if (npages == 1)
+	if (TCE_PAGE_FACTOR == 0 && npages == 1)
 		return tce_build_pSeriesLP(tbl, tcenum, npages, uaddr,
 					   direction);
 
@@ -164,6 +164,9 @@ static void tce_buildmulti_pSeriesLP(str
 		__get_cpu_var(tce_page) = tcep;
 	}
 
+	tcenum <<= TCE_PAGE_FACTOR;
+	npages <<= TCE_PAGE_FACTOR;
+
 	tce.te_word = 0;
 	tce.te_rpn = (virt_to_abs(uaddr)) >> TCE_SHIFT;
 	tce.te_rdwr = 1;
diff --git a/arch/powerpc/platforms/pseries/lpar.c b/arch/powerpc/platforms/pseries/lpar.c
index a50e5f3..cf1bc11 100644
--- a/arch/powerpc/platforms/pseries/lpar.c
+++ b/arch/powerpc/platforms/pseries/lpar.c
@@ -298,18 +298,6 @@ long pSeries_lpar_hpte_insert(unsigned l
 	if (!(vflags & HPTE_V_BOLTED))
 		DBG_LOW(" hpte_v=%016lx, hpte_r=%016lx\n", hpte_v, hpte_r);
 
-#if 1
-	{
-		int i;
-		for (i=0;i<8;i++) {
-			unsigned long w0, w1;
-			plpar_pte_read(0, hpte_group, &w0, &w1);
-			BUG_ON (HPTE_V_COMPARE(hpte_v, w0)
-				&& (w0 & HPTE_V_VALID));
-		}
-	}
-#endif
-
 	/* Now fill in the actual HPTE */
 	/* Set CEC cookie to 0         */
 	/* Zero page = 0               */
diff --git a/arch/ppc/Kconfig b/arch/ppc/Kconfig
index 8fa51b0..cc3f64c 100644
--- a/arch/ppc/Kconfig
+++ b/arch/ppc/Kconfig
@@ -767,14 +767,14 @@ config CPM2
 	  on it (826x, 827x, 8560).
 
 config PPC_CHRP
-	bool "  Common Hardware Reference Platform (CHRP) based machines"
+	bool
 	depends on PPC_MULTIPLATFORM
 	select PPC_I8259
 	select PPC_INDIRECT_PCI
 	default y
 
 config PPC_PMAC
-	bool "  Apple PowerMac based machines"
+	bool
 	depends on PPC_MULTIPLATFORM
 	select PPC_INDIRECT_PCI
 	default y
@@ -785,7 +785,7 @@ config PPC_PMAC64
 	default y
 
 config PPC_PREP
-	bool "  PowerPC Reference Platform (PReP) based machines"
+	bool
 	depends on PPC_MULTIPLATFORM
 	select PPC_I8259
 	select PPC_INDIRECT_PCI
diff --git a/arch/ppc/kernel/smp.c b/arch/ppc/kernel/smp.c
index 43b8fc2..becbfa3 100644
--- a/arch/ppc/kernel/smp.c
+++ b/arch/ppc/kernel/smp.c
@@ -301,6 +301,10 @@ void __init smp_prepare_cpus(unsigned in
 
 	/* Probe platform for CPUs: always linear. */
 	num_cpus = smp_ops->probe();
+	
+	if (num_cpus < 2)
+		smp_tb_synchronized = 1;
+	
 	for (i = 0; i < num_cpus; ++i)
 		cpu_set(i, cpu_possible_map);
 
diff --git a/arch/ppc/platforms/pmac_feature.c b/arch/ppc/platforms/pmac_feature.c
index 1e69b05..6b7b3a1 100644
--- a/arch/ppc/platforms/pmac_feature.c
+++ b/arch/ppc/platforms/pmac_feature.c
@@ -1606,11 +1606,19 @@ void pmac_tweak_clock_spreading(int enab
 	 */
 
 	if (macio->type == macio_intrepid) {
-		if (enable)
-			UN_OUT(UNI_N_CLOCK_SPREADING, 2);
-		else
-			UN_OUT(UNI_N_CLOCK_SPREADING, 0);
-		mdelay(40);
+		struct device_node *clock =
+			of_find_node_by_path("/uni-n@f8000000/hw-clock");
+		if (clock && get_property(clock, "platform-do-clockspreading",
+					  NULL)) {
+			printk(KERN_INFO "%sabling clock spreading on Intrepid"
+			       " ASIC\n", enable ? "En" : "Dis");
+			if (enable)
+				UN_OUT(UNI_N_CLOCK_SPREADING, 2);
+			else
+				UN_OUT(UNI_N_CLOCK_SPREADING, 0);
+			mdelay(40);
+		}
+		of_node_put(clock);
 	}
 
 	while (machine_is_compatible("PowerBook5,2") ||
@@ -1680,6 +1688,8 @@ void pmac_tweak_clock_spreading(int enab
 			pmac_low_i2c_close(ui2c);
 			break;
 		}
+		printk(KERN_INFO "%sabling clock spreading on i2c clock chip\n",
+		       enable ? "En" : "Dis");
 		pmac_low_i2c_setmode(ui2c, pmac_low_i2c_mode_stdsub);
 		rc = pmac_low_i2c_xfer(ui2c, 0xd2 | pmac_low_i2c_write, 0x80, buffer, 9);
 		DBG("write result: %d,", rc);
diff --git a/arch/sparc/Makefile b/arch/sparc/Makefile
index dea48f6..4cdbb2d 100644
--- a/arch/sparc/Makefile
+++ b/arch/sparc/Makefile
@@ -34,7 +34,7 @@ libs-y += arch/sparc/prom/ arch/sparc/li
 # Renaming is done to avoid confusing pattern matching rules in 2.5.45 (multy-)
 INIT_Y		:= $(patsubst %/, %/built-in.o, $(init-y))
 CORE_Y		:= $(core-y)
-CORE_Y		+= kernel/ mm/ fs/ ipc/ security/ crypto/
+CORE_Y		+= kernel/ mm/ fs/ ipc/ security/ crypto/ block/
 CORE_Y		:= $(patsubst %/, %/built-in.o, $(CORE_Y))
 DRIVERS_Y	:= $(patsubst %/, %/built-in.o, $(drivers-y))
 NET_Y		:= $(patsubst %/, %/built-in.o, $(net-y))
diff --git a/arch/sparc/lib/atomic32.c b/arch/sparc/lib/atomic32.c
index cb3cf0f..de84f85 100644
--- a/arch/sparc/lib/atomic32.c
+++ b/arch/sparc/lib/atomic32.c
@@ -66,7 +66,6 @@ int atomic_add_unless(atomic_t *v, int a
 	return ret != u;
 }
 
-static inline void atomic_clear_mask(unsigned long mask, unsigned long *addr)
 /* Atomic operations are already serializing */
 void atomic_set(atomic_t *v, int i)
 {
diff --git a/arch/sparc64/kernel/kprobes.c b/arch/sparc64/kernel/kprobes.c
index 96bd09b..a97b0f0 100644
--- a/arch/sparc64/kernel/kprobes.c
+++ b/arch/sparc64/kernel/kprobes.c
@@ -138,7 +138,7 @@ static int __kprobes kprobe_handler(stru
 			 */
 			save_previous_kprobe(kcb);
 			set_current_kprobe(p, regs, kcb);
-			p->nmissed++;
+			kprobes_inc_nmissed_count(p);
 			kcb->kprobe_status = KPROBE_REENTER;
 			prepare_singlestep(p, regs, kcb);
 			return 1;
diff --git a/arch/um/include/um_uaccess.h b/arch/um/include/um_uaccess.h
index f8760a3..4567f1e 100644
--- a/arch/um/include/um_uaccess.h
+++ b/arch/um/include/um_uaccess.h
@@ -17,6 +17,8 @@
 #include "uaccess-skas.h"
 #endif
 
+#include "asm/fixmap.h"
+
 #define __under_task_size(addr, size) \
 	(((unsigned long) (addr) < TASK_SIZE) && \
          (((unsigned long) (addr) + (size)) < TASK_SIZE))
diff --git a/arch/um/kernel/skas/include/uaccess-skas.h b/arch/um/kernel/skas/include/uaccess-skas.h
index f611f83..64516c5 100644
--- a/arch/um/kernel/skas/include/uaccess-skas.h
+++ b/arch/um/kernel/skas/include/uaccess-skas.h
@@ -7,7 +7,6 @@
 #define __SKAS_UACCESS_H
 
 #include "asm/errno.h"
-#include "asm/fixmap.h"
 
 /* No SKAS-specific checking. */
 #define access_ok_skas(type, addr, size) 0
diff --git a/arch/x86_64/ia32/ia32_binfmt.c b/arch/x86_64/ia32/ia32_binfmt.c
index 830feb2..2b760d0 100644
--- a/arch/x86_64/ia32/ia32_binfmt.c
+++ b/arch/x86_64/ia32/ia32_binfmt.c
@@ -217,8 +217,7 @@ elf_core_copy_task_fpregs(struct task_st
 	if (!tsk_used_math(tsk))
 		return 0;
 	if (!regs)
-		regs = (struct pt_regs *)tsk->thread.rsp0;
-	--regs;
+		regs = ((struct pt_regs *)tsk->thread.rsp0) - 1;
 	if (tsk == current)
 		unlazy_fpu(tsk);
 	set_fs(KERNEL_DS); 
diff --git a/arch/x86_64/kernel/kprobes.c b/arch/x86_64/kernel/kprobes.c
index dddeb67..afe11f4 100644
--- a/arch/x86_64/kernel/kprobes.c
+++ b/arch/x86_64/kernel/kprobes.c
@@ -329,7 +329,7 @@ int __kprobes kprobe_handler(struct pt_r
 				 */
 				save_previous_kprobe(kcb);
 				set_current_kprobe(p, regs, kcb);
-				p->nmissed++;
+				kprobes_inc_nmissed_count(p);
 				prepare_singlestep(p, regs);
 				kcb->kprobe_status = KPROBE_REENTER;
 				return 1;
diff --git a/arch/x86_64/kernel/smpboot.c b/arch/x86_64/kernel/smpboot.c
index 683c33f..ecbd7b8 100644
--- a/arch/x86_64/kernel/smpboot.c
+++ b/arch/x86_64/kernel/smpboot.c
@@ -1181,7 +1181,7 @@ int __cpu_disable(void)
 	if (cpu == 0)
 		return -EBUSY;
 
-	disable_APIC_timer();
+	clear_local_APIC();
 
 	/*
 	 * HACK:
diff --git a/arch/x86_64/kernel/time.c b/arch/x86_64/kernel/time.c
index fdaddc4..7410279 100644
--- a/arch/x86_64/kernel/time.c
+++ b/arch/x86_64/kernel/time.c
@@ -59,7 +59,7 @@ static int notsc __initdata = 0;
 unsigned int cpu_khz;					/* TSC clocks / usec, not used here */
 static unsigned long hpet_period;			/* fsecs / HPET clock */
 unsigned long hpet_tick;				/* HPET clocks / interrupt */
-static int hpet_use_timer;
+static int hpet_use_timer;				/* Use counter of hpet for time keeping, otherwise PIT */
 unsigned long vxtime_hz = PIT_TICK_RATE;
 int report_lost_ticks;				/* command line option */
 unsigned long long monotonic_base;
@@ -908,12 +908,14 @@ void __init time_init(void)
 	if (!hpet_init())
                 vxtime_hz = (1000000000000000L + hpet_period / 2) /
 			hpet_period;
+	else
+		vxtime.hpet_address = 0;
 
 	if (hpet_use_timer) {
 		cpu_khz = hpet_calibrate_tsc();
 		timename = "HPET";
 #ifdef CONFIG_X86_PM_TIMER
-	} else if (pmtmr_ioport) {
+	} else if (pmtmr_ioport && !vxtime.hpet_address) {
 		vxtime_hz = PM_TIMER_FREQUENCY;
 		timename = "PM";
 		pit_init();
diff --git a/arch/x86_64/mm/ioremap.c b/arch/x86_64/mm/ioremap.c
index ecf7acb..0d260e4 100644
--- a/arch/x86_64/mm/ioremap.c
+++ b/arch/x86_64/mm/ioremap.c
@@ -247,9 +247,15 @@ void __iomem *ioremap_nocache (unsigned 
 	return __ioremap(phys_addr, size, _PAGE_PCD);
 }
 
+/**
+ * iounmap - Free a IO remapping
+ * @addr: virtual address from ioremap_*
+ *
+ * Caller must ensure there is only one unmapping for the same pointer.
+ */
 void iounmap(volatile void __iomem *addr)
 {
-	struct vm_struct *p;
+	struct vm_struct *p, *o;
 
 	if (addr <= high_memory) 
 		return; 
@@ -257,12 +263,31 @@ void iounmap(volatile void __iomem *addr
 		addr < phys_to_virt(ISA_END_ADDRESS))
 		return;
 
-	write_lock(&vmlist_lock);
-	p = __remove_vm_area((void *)((unsigned long)addr & PAGE_MASK));
-	if (!p)
+	addr = (volatile void *)(PAGE_MASK & (unsigned long __force)addr);
+	/* Use the vm area unlocked, assuming the caller
+	   ensures there isn't another iounmap for the same address
+	   in parallel. Reuse of the virtual address is prevented by
+	   leaving it in the global lists until we're done with it.
+	   cpa takes care of the direct mappings. */
+	read_lock(&vmlist_lock);
+	for (p = vmlist; p; p = p->next) {
+		if (p->addr == addr)
+			break;
+	}
+	read_unlock(&vmlist_lock);
+
+	if (!p) {
 		printk("iounmap: bad address %p\n", addr);
-	else if (p->flags >> 20)
+		dump_stack();
+		return;
+	}
+
+	/* Reset the direct mapping. Can block */
+	if (p->flags >> 20)
 		ioremap_change_attr(p->phys_addr, p->size, 0);
-	write_unlock(&vmlist_lock);
+
+	/* Finally remove it */
+	o = remove_vm_area((void *)addr);
+	BUG_ON(p != o || o == NULL);
 	kfree(p); 
 }
diff --git a/arch/x86_64/mm/numa.c b/arch/x86_64/mm/numa.c
index a828a01..15b67d2 100644
--- a/arch/x86_64/mm/numa.c
+++ b/arch/x86_64/mm/numa.c
@@ -53,6 +53,8 @@ static int __init populate_memnodemap(
 	int res = -1;
 	unsigned long addr, end;
 
+	if (shift >= 64)
+		return -1;
 	memset(memnodemap, 0xff, sizeof(memnodemap));
 	for (i = 0; i < numnodes; i++) {
 		addr = nodes[i].start;
@@ -65,7 +67,7 @@ static int __init populate_memnodemap(
 			if (memnodemap[addr >> shift] != 0xff)
 				return -1;
 			memnodemap[addr >> shift] = i;
-			addr += (1 << shift);
+                       addr += (1UL << shift);
 		} while (addr < end);
 		res = 1;
 	} 
diff --git a/arch/x86_64/pci/mmconfig.c b/arch/x86_64/pci/mmconfig.c
index a0838c4..9c4f907 100644
--- a/arch/x86_64/pci/mmconfig.c
+++ b/arch/x86_64/pci/mmconfig.c
@@ -8,10 +8,13 @@
 #include <linux/pci.h>
 #include <linux/init.h>
 #include <linux/acpi.h>
+#include <linux/bitmap.h>
 #include "pci.h"
 
 #define MMCONFIG_APER_SIZE (256*1024*1024)
 
+static DECLARE_BITMAP(fallback_slots, 32);
+
 /* Static virtual mapping of the MMCONFIG aperture */
 struct mmcfg_virt {
 	struct acpi_table_mcfg_config *cfg;
@@ -19,7 +22,7 @@ struct mmcfg_virt {
 };
 static struct mmcfg_virt *pci_mmcfg_virt;
 
-static char *get_virt(unsigned int seg, int bus)
+static char *get_virt(unsigned int seg, unsigned bus)
 {
 	int cfg_num = -1;
 	struct acpi_table_mcfg_config *cfg;
@@ -27,10 +30,9 @@ static char *get_virt(unsigned int seg, 
 	while (1) {
 		++cfg_num;
 		if (cfg_num >= pci_mmcfg_config_num) {
-			/* something bad is going on, no cfg table is found. */
-			/* so we fall back to the old way we used to do this */
-			/* and just rely on the first entry to be correct. */
-			return pci_mmcfg_virt[0].virt;
+			/* Not found - fall back to type 1. This happens
+			   e.g. on the internal devices of a K8 northbridge. */
+			return NULL;
 		}
 		cfg = pci_mmcfg_virt[cfg_num].cfg;
 		if (cfg->pci_segment_group_number != seg)
@@ -41,20 +43,30 @@ static char *get_virt(unsigned int seg, 
 	}
 }
 
-static inline char *pci_dev_base(unsigned int seg, unsigned int bus, unsigned int devfn)
+static char *pci_dev_base(unsigned int seg, unsigned int bus, unsigned int devfn)
 {
-
-	return get_virt(seg, bus) + ((bus << 20) | (devfn << 12));
+	char *addr;
+	if (seg == 0 && bus == 0 && test_bit(PCI_SLOT(devfn), &fallback_slots))
+		return NULL;
+	addr = get_virt(seg, bus);
+	if (!addr)
+		return NULL;
+ 	return addr + ((bus << 20) | (devfn << 12));
 }
 
 static int pci_mmcfg_read(unsigned int seg, unsigned int bus,
 			  unsigned int devfn, int reg, int len, u32 *value)
 {
-	char *addr = pci_dev_base(seg, bus, devfn);
+	char *addr;
 
+	/* Why do we have this when nobody checks it. How about a BUG()!? -AK */
 	if (unlikely(!value || (bus > 255) || (devfn > 255) || (reg > 4095)))
 		return -EINVAL;
 
+	addr = pci_dev_base(seg, bus, devfn);
+	if (!addr)
+		return pci_conf1_read(seg,bus,devfn,reg,len,value);
+
 	switch (len) {
 	case 1:
 		*value = readb(addr + reg);
@@ -73,11 +85,16 @@ static int pci_mmcfg_read(unsigned int s
 static int pci_mmcfg_write(unsigned int seg, unsigned int bus,
 			   unsigned int devfn, int reg, int len, u32 value)
 {
-	char *addr = pci_dev_base(seg, bus, devfn);
+	char *addr;
 
+	/* Why do we have this when nobody checks it. How about a BUG()!? -AK */
 	if (unlikely((bus > 255) || (devfn > 255) || (reg > 4095)))
 		return -EINVAL;
 
+	addr = pci_dev_base(seg, bus, devfn);
+	if (!addr)
+		return pci_conf1_write(seg,bus,devfn,reg,len,value);
+
 	switch (len) {
 	case 1:
 		writeb(value, addr + reg);
@@ -98,6 +115,30 @@ static struct pci_raw_ops pci_mmcfg = {
 	.write =	pci_mmcfg_write,
 };
 
+/* K8 systems have some devices (typically in the builtin northbridge)
+   that are only accessible using type1
+   Normally this can be expressed in the MCFG by not listing them
+   and assigning suitable _SEGs, but this isn't implemented in some BIOS.
+   Instead try to discover all devices on bus 0 that are unreachable using MM
+   and fallback for them.
+   We only do this for bus 0/seg 0 */
+static __init void unreachable_devices(void)
+{
+	int i;
+	for (i = 0; i < 32; i++) {
+		u32 val1;
+		char *addr;
+
+		pci_conf1_read(0, 0, PCI_DEVFN(i,0), 0, 4, &val1);
+		if (val1 == 0xffffffff)
+			continue;
+		addr = pci_dev_base(0, 0, PCI_DEVFN(i, 0));
+		if (addr == NULL|| readl(addr) != val1) {
+			set_bit(i, &fallback_slots);
+		}
+	}
+}
+
 static int __init pci_mmcfg_init(void)
 {
 	int i;
@@ -128,6 +169,8 @@ static int __init pci_mmcfg_init(void)
 		printk(KERN_INFO "PCI: Using MMCONFIG at %x\n", pci_mmcfg_config[i].base_address);
 	}
 
+	unreachable_devices();
+
 	raw_pci_ops = &pci_mmcfg;
 	pci_probe = (pci_probe & ~PCI_PROBE_MASK) | PCI_PROBE_MMCONF;
 
diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 82292b7..78927c0 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -316,7 +316,7 @@ static int acpi_pci_link_set(struct acpi
 	if (!link || !irq)
 		return_VALUE(-EINVAL);
 
-	resource = kmalloc(sizeof(*resource) + 1, GFP_KERNEL);
+	resource = kmalloc(sizeof(*resource) + 1, GFP_ATOMIC);
 	if (!resource)
 		return_VALUE(-ENOMEM);
 
diff --git a/drivers/block/cciss.c b/drivers/block/cciss.c
index a9e33db..c3441b3 100644
--- a/drivers/block/cciss.c
+++ b/drivers/block/cciss.c
@@ -1146,7 +1146,6 @@ static int revalidate_allvol(ctlr_info_t
 				del_gendisk(disk);
 			if (q)
 				blk_cleanup_queue(q);
-			put_disk(disk);
 		}
 	}
 
@@ -1465,9 +1464,10 @@ static int deregister_disk(struct gendis
 			request_queue_t *q = disk->queue;
 			if (disk->flags & GENHD_FL_UP)
 				del_gendisk(disk);
-			if (q)	
+			if (q) {
 				blk_cleanup_queue(q);
-			put_disk(disk);	
+				drv->queue = NULL;
+			}
 		}
 	}
 
@@ -3243,7 +3243,6 @@ static void __devexit cciss_remove_one (
 				del_gendisk(disk);
 			if (q)
 				blk_cleanup_queue(q);
-			put_disk(disk);
 		}
 	}
 
diff --git a/drivers/char/Kconfig b/drivers/char/Kconfig
index 970f70d..b46a72d 100644
--- a/drivers/char/Kconfig
+++ b/drivers/char/Kconfig
@@ -943,6 +943,15 @@ config RAW_DRIVER
           Applications should simply open the device (eg /dev/hda1)
           with the O_DIRECT flag.
 
+config MAX_RAW_DEVS
+	int "Maximum number of RAW devices to support (1-8192)"
+	depends on RAW_DRIVER
+	default "256"
+	help
+	  The maximum number of RAW devices that are supported.
+	  Default is 256. Increase this number in case you need lots of
+	  raw devices.
+
 config HPET
 	bool "HPET - High Precision Event Timer" if (X86 || IA64)
 	default n
@@ -974,15 +983,6 @@ config HPET_MMAP
 	  exposed to the user.  If this applies to your hardware,
 	  say N here.
 
-config MAX_RAW_DEVS
-	int "Maximum number of RAW devices to support (1-8192)"
-	depends on RAW_DRIVER
-	default "256"
-	help
-	  The maximum number of RAW devices that are supported.
-	  Default is 256. Increase this number in case you need lots of
-	  raw devices.
-
 config HANGCHECK_TIMER
 	tristate "Hangcheck timer"
 	depends on X86 || IA64 || PPC64 || ARCH_S390
diff --git a/drivers/char/drm/radeon_cp.c b/drivers/char/drm/radeon_cp.c
index 03839ea..9f2b4ef 100644
--- a/drivers/char/drm/radeon_cp.c
+++ b/drivers/char/drm/radeon_cp.c
@@ -1522,7 +1522,7 @@ static int radeon_do_init_cp(drm_device_
 
 	dev_priv->gart_size = init->gart_size;
 	dev_priv->gart_vm_start = dev_priv->fb_location
-	    + RADEON_READ(RADEON_CONFIG_APER_SIZE);
+	    + RADEON_READ(RADEON_CONFIG_APER_SIZE) * 2;
 
 #if __OS_HAS_AGP
 	if (!dev_priv->is_pci)
diff --git a/drivers/char/ipmi/ipmi_msghandler.c b/drivers/char/ipmi/ipmi_msghandler.c
index 6b302a9..1f56b4c 100644
--- a/drivers/char/ipmi/ipmi_msghandler.c
+++ b/drivers/char/ipmi/ipmi_msghandler.c
@@ -2986,7 +2986,7 @@ static void send_panic_events(char *str)
 	msg.cmd = 2; /* Platform event command. */
 	msg.data = data;
 	msg.data_len = 8;
-	data[0] = 0x21; /* Kernel generator ID, IPMI table 5-4 */
+	data[0] = 0x41; /* Kernel generator ID, IPMI table 5-4 */
 	data[1] = 0x03; /* This is for IPMI 1.0. */
 	data[2] = 0x20; /* OS Critical Stop, IPMI table 36-3 */
 	data[4] = 0x6f; /* Sensor specific, IPMI table 36-1 */
diff --git a/drivers/char/watchdog/mpcore_wdt.c b/drivers/char/watchdog/mpcore_wdt.c
index 9defcf8..b4d8434 100644
--- a/drivers/char/watchdog/mpcore_wdt.c
+++ b/drivers/char/watchdog/mpcore_wdt.c
@@ -180,10 +180,6 @@ static ssize_t mpcore_wdt_write(struct f
 {
 	struct mpcore_wdt *wdt = file->private_data;
 
-	/*  Can't seek (pwrite) on this device  */
-	if (ppos != &file->f_pos)
-		return -ESPIPE;
-
 	/*
 	 *	Refresh the timer.
 	 */
diff --git a/drivers/connector/cn_proc.c b/drivers/connector/cn_proc.c
index fcdf0ff..969d2b4 100644
--- a/drivers/connector/cn_proc.c
+++ b/drivers/connector/cn_proc.c
@@ -56,6 +56,7 @@ void proc_fork_connector(struct task_str
 	msg = (struct cn_msg*)buffer;
 	ev = (struct proc_event*)msg->data;
 	get_seq(&msg->seq, &ev->cpu);
+	getnstimestamp(&ev->timestamp);
 	ev->what = PROC_EVENT_FORK;
 	ev->event_data.fork.parent_pid = task->real_parent->pid;
 	ev->event_data.fork.parent_tgid = task->real_parent->tgid;
@@ -81,6 +82,7 @@ void proc_exec_connector(struct task_str
 	msg = (struct cn_msg*)buffer;
 	ev = (struct proc_event*)msg->data;
 	get_seq(&msg->seq, &ev->cpu);
+	getnstimestamp(&ev->timestamp);
 	ev->what = PROC_EVENT_EXEC;
 	ev->event_data.exec.process_pid = task->pid;
 	ev->event_data.exec.process_tgid = task->tgid;
@@ -114,6 +116,7 @@ void proc_id_connector(struct task_struc
 	} else
 	     	return;
 	get_seq(&msg->seq, &ev->cpu);
+	getnstimestamp(&ev->timestamp);
 
 	memcpy(&msg->id, &cn_proc_event_id, sizeof(msg->id));
 	msg->ack = 0; /* not used */
@@ -133,6 +136,7 @@ void proc_exit_connector(struct task_str
 	msg = (struct cn_msg*)buffer;
 	ev = (struct proc_event*)msg->data;
 	get_seq(&msg->seq, &ev->cpu);
+	getnstimestamp(&ev->timestamp);
 	ev->what = PROC_EVENT_EXIT;
 	ev->event_data.exit.process_pid = task->pid;
 	ev->event_data.exit.process_tgid = task->tgid;
@@ -165,6 +169,7 @@ static void cn_proc_ack(int err, int rcv
 	msg = (struct cn_msg*)buffer;
 	ev = (struct proc_event*)msg->data;
 	msg->seq = rcvd_seq;
+	getnstimestamp(&ev->timestamp);
 	ev->cpu = -1;
 	ev->what = PROC_EVENT_NONE;
 	ev->event_data.ack.err = err;
diff --git a/drivers/macintosh/windfarm_pm81.c b/drivers/macintosh/windfarm_pm81.c
index 322c74b..80ddf97 100644
--- a/drivers/macintosh/windfarm_pm81.c
+++ b/drivers/macintosh/windfarm_pm81.c
@@ -207,7 +207,7 @@ static struct wf_smu_sys_fans_param wf_s
 	},
 	/* Model ID 3 */
 	{
-		.model_id	= 2,
+		.model_id	= 3,
 		.itarget	= 0x350000,
 		.gd		= 0x08e00000,
 		.gp		= 0x00566666,
@@ -219,7 +219,7 @@ static struct wf_smu_sys_fans_param wf_s
 	},
 	/* Model ID 5 */
 	{
-		.model_id	= 2,
+		.model_id	= 5,
 		.itarget	= 0x3a0000,
 		.gd		= 0x15400000,
 		.gp		= 0x00233333,
diff --git a/drivers/md/raid1.c b/drivers/md/raid1.c
index 3066c58..229d7b2 100644
--- a/drivers/md/raid1.c
+++ b/drivers/md/raid1.c
@@ -320,7 +320,6 @@ static int raid1_end_write_request(struc
 		 * this branch is our 'one mirror IO has finished' event handler:
 		 */
 		r1_bio->bios[mirror] = NULL;
-		bio_put(bio);
 		if (!uptodate) {
 			md_error(r1_bio->mddev, conf->mirrors[mirror].rdev);
 			/* an I/O failed, we can't clear the bitmap */
@@ -377,7 +376,6 @@ static int raid1_end_write_request(struc
 		}
 		if (test_bit(R1BIO_BehindIO, &r1_bio->state)) {
 			/* free extra copy of the data pages */
-/* FIXME bio has been freed!!! */
 			int i = bio->bi_vcnt;
 			while (i--)
 				__free_page(bio->bi_io_vec[i].bv_page);
@@ -391,6 +389,9 @@ static int raid1_end_write_request(struc
 		raid_end_bio_io(r1_bio);
 	}
 
+	if (r1_bio->bios[mirror]==NULL)
+		bio_put(bio);
+
 	rdev_dec_pending(conf->mirrors[mirror].rdev, conf->mddev);
 	return 0;
 }
diff --git a/drivers/md/raid5.c b/drivers/md/raid5.c
index 36d5f8a..fafc4bc 100644
--- a/drivers/md/raid5.c
+++ b/drivers/md/raid5.c
@@ -98,7 +98,7 @@ static inline void __release_stripe(raid
 			list_add_tail(&sh->lru, &conf->inactive_list);
 			atomic_dec(&conf->active_stripes);
 			if (!conf->inactive_blocked ||
-			    atomic_read(&conf->active_stripes) < (NR_STRIPES*3/4))
+			    atomic_read(&conf->active_stripes) < (conf->max_nr_stripes*3/4))
 				wake_up(&conf->wait_for_stripe);
 		}
 	}
@@ -264,7 +264,8 @@ static struct stripe_head *get_active_st
 				conf->inactive_blocked = 1;
 				wait_event_lock_irq(conf->wait_for_stripe,
 						    !list_empty(&conf->inactive_list) &&
-						    (atomic_read(&conf->active_stripes) < (NR_STRIPES *3/4)
+						    (atomic_read(&conf->active_stripes)
+						     < (conf->max_nr_stripes *3/4)
 						     || !conf->inactive_blocked),
 						    conf->device_lock,
 						    unplug_slaves(conf->mddev);
@@ -1917,7 +1918,7 @@ static int run(mddev_t *mddev)
 			goto abort;
 		}
 	}
-memory = conf->max_nr_stripes * (sizeof(struct stripe_head) +
+	memory = conf->max_nr_stripes * (sizeof(struct stripe_head) +
 		 conf->raid_disks * ((sizeof(struct bio) + PAGE_SIZE))) / 1024;
 	if (grow_stripes(conf, conf->max_nr_stripes)) {
 		printk(KERN_ERR 
diff --git a/drivers/media/common/Kconfig b/drivers/media/common/Kconfig
index caebd0a..6a901a0 100644
--- a/drivers/media/common/Kconfig
+++ b/drivers/media/common/Kconfig
@@ -1,12 +1,12 @@
 config VIDEO_SAA7146
-        tristate
+	tristate
 	select I2C
 
 config VIDEO_SAA7146_VV
-        tristate
+	tristate
 	select VIDEO_BUF
 	select VIDEO_VIDEOBUF
 	select VIDEO_SAA7146
 
 config VIDEO_VIDEOBUF
-        tristate
+	tristate
diff --git a/drivers/media/common/Makefile b/drivers/media/common/Makefile
index 97b4341..bd458cb 100644
--- a/drivers/media/common/Makefile
+++ b/drivers/media/common/Makefile
@@ -1,5 +1,5 @@
-saa7146-objs    := saa7146_i2c.o saa7146_core.o 
-saa7146_vv-objs := saa7146_vv_ksyms.o saa7146_fops.o saa7146_video.o saa7146_hlp.o saa7146_vbi.o  
+saa7146-objs    := saa7146_i2c.o saa7146_core.o
+saa7146_vv-objs := saa7146_vv_ksyms.o saa7146_fops.o saa7146_video.o saa7146_hlp.o saa7146_vbi.o
 
 obj-$(CONFIG_VIDEO_SAA7146) += saa7146.o
 obj-$(CONFIG_VIDEO_SAA7146_VV) += saa7146_vv.o
diff --git a/drivers/media/common/ir-common.c b/drivers/media/common/ir-common.c
index 7972c73..97fa3fc 100644
--- a/drivers/media/common/ir-common.c
+++ b/drivers/media/common/ir-common.c
@@ -313,6 +313,7 @@ void ir_input_init(struct input_dev *dev
 	if (ir_codes)
 		memcpy(ir->ir_codes, ir_codes, sizeof(ir->ir_codes));
 
+
 	dev->keycode     = ir->ir_codes;
 	dev->keycodesize = sizeof(IR_KEYTAB_TYPE);
 	dev->keycodemax  = IR_KEYTAB_SIZE;
diff --git a/drivers/media/common/saa7146_core.c b/drivers/media/common/saa7146_core.c
index 206cc2f..2899d34 100644
--- a/drivers/media/common/saa7146_core.c
+++ b/drivers/media/common/saa7146_core.c
@@ -174,8 +174,8 @@ void saa7146_pgtable_free(struct pci_dev
 
 int saa7146_pgtable_alloc(struct pci_dev *pci, struct saa7146_pgtable *pt)
 {
-        u32          *cpu;
-        dma_addr_t   dma_addr;
+	u32          *cpu;
+	dma_addr_t   dma_addr;
 
 	cpu = pci_alloc_consistent(pci, PAGE_SIZE, &dma_addr);
 	if (NULL == cpu) {
@@ -405,7 +405,7 @@ static int saa7146_init_one(struct pci_d
 
 	pci_set_drvdata(pci, dev);
 
-        init_MUTEX(&dev->lock);
+	init_MUTEX(&dev->lock);
 	spin_lock_init(&dev->int_slock);
 	spin_lock_init(&dev->slock);
 
diff --git a/drivers/media/common/saa7146_fops.c b/drivers/media/common/saa7146_fops.c
index 3788898..09ec964 100644
--- a/drivers/media/common/saa7146_fops.c
+++ b/drivers/media/common/saa7146_fops.c
@@ -1,6 +1,6 @@
 #include <media/saa7146_vv.h>
 
-#define BOARD_CAN_DO_VBI(dev)   (dev->revision != 0 && dev->vv_data->vbi_minor != -1) 
+#define BOARD_CAN_DO_VBI(dev)   (dev->revision != 0 && dev->vv_data->vbi_minor != -1)
 
 /****************************************************************************/
 /* resource management functions, shamelessly stolen from saa7134 driver */
@@ -102,9 +102,9 @@ void saa7146_buffer_finish(struct saa714
 	/* finish current buffer */
 	if (NULL == q->curr) {
 		DEB_D(("aiii. no current buffer\n"));
-		return;	
+		return;
 	}
-			
+
 	q->curr->vb.state = state;
 	do_gettimeofday(&q->curr->vb.ts);
 	wake_up(&q->curr->vb.done);
@@ -143,13 +143,13 @@ void saa7146_buffer_next(struct saa7146_
 			// fixme: fix this for vflip != 0
 
 			saa7146_write(dev, PROT_ADDR1, 0);
-			saa7146_write(dev, MC2, (MASK_02|MASK_18));		
+			saa7146_write(dev, MC2, (MASK_02|MASK_18));
 
 			/* write the address of the rps-program */
 			saa7146_write(dev, RPS_ADDR0, dev->d_rps0.dma_handle);
 			/* turn on rps */
 			saa7146_write(dev, MC1, (MASK_12 | MASK_28));
-				
+
 /*
 			printk("vdma%d.base_even:     0x%08x\n", 1,saa7146_read(dev,BASE_EVEN1));
 			printk("vdma%d.base_odd:      0x%08x\n", 1,saa7146_read(dev,BASE_ODD1));
@@ -246,7 +246,7 @@ static int fops_open(struct inode *inode
 		goto out;
 	}
 	memset(fh,0,sizeof(*fh));
-	
+
 	file->private_data = fh;
 	fh->dev = dev;
 	fh->type = type;
@@ -275,7 +275,7 @@ out:
 		file->private_data = NULL;
 	}
 	up(&saa7146_devices_lock);
-        return result;
+	return result;
 }
 
 static int fops_release(struct inode *inode, struct file *file)
@@ -405,7 +405,7 @@ static struct file_operations video_fops
 static void vv_callback(struct saa7146_dev *dev, unsigned long status)
 {
 	u32 isr = status;
-	
+
 	DEB_INT(("dev:%p, isr:0x%08x\n",dev,(u32)status));
 
 	if (0 != (isr & (MASK_27))) {
@@ -454,11 +454,11 @@ int saa7146_vv_init(struct saa7146_dev* 
 	   handle different devices that might need different
 	   configuration data) */
 	dev->ext_vv_data = ext_vv;
-	
+
 	vv->video_minor = -1;
 	vv->vbi_minor = -1;
 
-	vv->d_clipping.cpu_addr = pci_alloc_consistent(dev->pci, SAA7146_CLIPPING_MEM, &vv->d_clipping.dma_handle);	
+	vv->d_clipping.cpu_addr = pci_alloc_consistent(dev->pci, SAA7146_CLIPPING_MEM, &vv->d_clipping.dma_handle);
 	if( NULL == vv->d_clipping.cpu_addr ) {
 		ERR(("out of memory. aborting.\n"));
 		kfree(vv);
@@ -468,7 +468,7 @@ int saa7146_vv_init(struct saa7146_dev* 
 
 	saa7146_video_uops.init(dev,vv);
 	saa7146_vbi_uops.init(dev,vv);
-	
+
 	dev->vv_data = vv;
 	dev->vv_callback = &vv_callback;
 
@@ -480,12 +480,12 @@ int saa7146_vv_release(struct saa7146_de
 	struct saa7146_vv *vv = dev->vv_data;
 
 	DEB_EE(("dev:%p\n",dev));
- 
+
 	pci_free_consistent(dev->pci, SAA7146_RPS_MEM, vv->d_clipping.cpu_addr, vv->d_clipping.dma_handle);
- 	kfree(vv);
+	kfree(vv);
 	dev->vv_data = NULL;
 	dev->vv_callback = NULL;
-	
+
 	return 0;
 }
 
@@ -498,7 +498,7 @@ int saa7146_register_device(struct video
 	DEB_EE(("dev:%p, name:'%s', type:%d\n",dev,name,type));
 
 	// released by vfd->release
- 	vfd = video_device_alloc();
+	vfd = video_device_alloc();
 	if (vfd == NULL)
 		return -ENOMEM;
 
@@ -530,7 +530,7 @@ int saa7146_register_device(struct video
 int saa7146_unregister_device(struct video_device **vid, struct saa7146_dev* dev)
 {
 	struct saa7146_vv *vv = dev->vv_data;
-	
+
 	DEB_EE(("dev:%p\n",dev));
 
 	if( VFL_TYPE_GRABBER == (*vid)->type ) {
diff --git a/drivers/media/common/saa7146_i2c.c b/drivers/media/common/saa7146_i2c.c
index fec6bea..8aabdd8 100644
--- a/drivers/media/common/saa7146_i2c.c
+++ b/drivers/media/common/saa7146_i2c.c
@@ -276,8 +276,8 @@ int saa7146_i2c_transfer(struct saa7146_
 	int i = 0, count = 0;
 	u32* buffer = dev->d_i2c.cpu_addr;
 	int err = 0;
-        int address_err = 0;
-        int short_delay = 0;
+	int address_err = 0;
+	int short_delay = 0;
 
 	if (down_interruptible (&dev->i2c_lock))
 		return -ERESTARTSYS;
@@ -325,7 +325,7 @@ int saa7146_i2c_transfer(struct saa7146_
 					if( 0 != (SAA7146_USE_I2C_IRQ & dev->ext->flags)) {
 						goto out;
 					}
-				        address_err++;
+					address_err++;
 				}
 				DEB_I2C(("error while sending message(s). starting again.\n"));
 				break;
@@ -336,14 +336,14 @@ int saa7146_i2c_transfer(struct saa7146_
 			break;
 		}
 
-	        /* delay a bit before retrying */
-	        msleep(10);
+		/* delay a bit before retrying */
+		msleep(10);
 
 	} while (err != num && retries--);
 
-        /* if every retry had an address error, exit right away */
-        if (address_err == retries) {
-	        goto out;
+	/* if every retry had an address error, exit right away */
+	if (address_err == retries) {
+		goto out;
 	}
 
 	/* if any things had to be read, get the results */
diff --git a/drivers/media/common/saa7146_vbi.c b/drivers/media/common/saa7146_vbi.c
index cb86a97..063986e 100644
--- a/drivers/media/common/saa7146_vbi.c
+++ b/drivers/media/common/saa7146_vbi.c
@@ -6,8 +6,8 @@ static int vbi_workaround(struct saa7146
 {
 	struct saa7146_vv *vv = dev->vv_data;
 
-        u32          *cpu;
-        dma_addr_t   dma_addr;
+	u32          *cpu;
+	dma_addr_t   dma_addr;
 
 	int count = 0;
 	int i;
diff --git a/drivers/media/common/saa7146_video.c b/drivers/media/common/saa7146_video.c
index 8dd4d15..1d96102 100644
--- a/drivers/media/common/saa7146_video.c
+++ b/drivers/media/common/saa7146_video.c
@@ -150,23 +150,23 @@ static int try_win(struct saa7146_dev *d
 	maxh  = vv->standard->v_max_out;
 
 	if (V4L2_FIELD_ANY == field) {
-                field = (win->w.height > maxh/2)
-                        ? V4L2_FIELD_INTERLACED
-                        : V4L2_FIELD_TOP;
-	        }
-        switch (field) {
-        case V4L2_FIELD_TOP:
-        case V4L2_FIELD_BOTTOM:
-        case V4L2_FIELD_ALTERNATE:
-                maxh = maxh / 2;
-                break;
-        case V4L2_FIELD_INTERLACED:
-                break;
-        default: {
+		field = (win->w.height > maxh/2)
+		        ? V4L2_FIELD_INTERLACED
+		        : V4L2_FIELD_TOP;
+		}
+	switch (field) {
+	case V4L2_FIELD_TOP:
+	case V4L2_FIELD_BOTTOM:
+	case V4L2_FIELD_ALTERNATE:
+		maxh = maxh / 2;
+		break;
+	case V4L2_FIELD_INTERLACED:
+		break;
+	default: {
 		DEB_D(("no known field mode '%d'.\n",field));
-                return -EINVAL;
+		return -EINVAL;
+	}
 	}
-        }
 
 	win->field = field;
 	if (win->w.width > maxw)
@@ -887,7 +887,7 @@ int saa7146_video_do_ioctl(struct inode 
 
 		DEB_EE(("VIDIOC_QUERYCAP\n"));
 
-                strcpy(cap->driver, "saa7146 v4l2");
+		strcpy(cap->driver, "saa7146 v4l2");
 		strlcpy(cap->card, dev->ext->name, sizeof(cap->card));
 		sprintf(cap->bus_info,"PCI:%s", pci_name(dev->pci));
 		cap->version = SAA7146_VERSION_CODE;
@@ -1011,19 +1011,19 @@ int saa7146_video_do_ioctl(struct inode 
 		err = set_control(fh,arg);
 		return err;
 	}
-        case VIDIOC_G_PARM:
-        {
-                struct v4l2_streamparm *parm = arg;
+	case VIDIOC_G_PARM:
+	{
+		struct v4l2_streamparm *parm = arg;
 		if( parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE ) {
 			return -EINVAL;
 		}
-                memset(&parm->parm.capture,0,sizeof(struct v4l2_captureparm));
+		memset(&parm->parm.capture,0,sizeof(struct v4l2_captureparm));
 		parm->parm.capture.readbuffers = 1;
 		// fixme: only for PAL!
 		parm->parm.capture.timeperframe.numerator = 1;
 		parm->parm.capture.timeperframe.denominator = 25;
-                return 0;
-        }
+		return 0;
+	}
 	case VIDIOC_G_FMT:
 	{
 		struct v4l2_format *f = arg;
@@ -1383,7 +1383,7 @@ static struct videobuf_queue_ops video_q
 
 static void video_init(struct saa7146_dev *dev, struct saa7146_vv *vv)
 {
-        INIT_LIST_HEAD(&vv->video_q.queue);
+	INIT_LIST_HEAD(&vv->video_q.queue);
 
 	init_timer(&vv->video_q.timeout);
 	vv->video_q.timeout.function = saa7146_buffer_timeout;
diff --git a/drivers/media/dvb/b2c2/flexcop-common.h b/drivers/media/dvb/b2c2/flexcop-common.h
index a94912a..344a3c8 100644
--- a/drivers/media/dvb/b2c2/flexcop-common.h
+++ b/drivers/media/dvb/b2c2/flexcop-common.h
@@ -132,7 +132,7 @@ int flexcop_eeprom_check_mac_addr(struct
  * I2C-channel of the flexcop.
  */
 int flexcop_i2c_request(struct flexcop_device*, flexcop_access_op_t,
-		        flexcop_i2c_port_t, u8 chipaddr, u8 addr, u8 *buf, u16 len);
+			flexcop_i2c_port_t, u8 chipaddr, u8 addr, u8 *buf, u16 len);
 
 /* from flexcop-sram.c */
 int flexcop_sram_set_dest(struct flexcop_device *fc, flexcop_sram_dest_t dest, flexcop_sram_dest_target_t target);
diff --git a/drivers/media/dvb/b2c2/flexcop-fe-tuner.c b/drivers/media/dvb/b2c2/flexcop-fe-tuner.c
index a353303..21a9045 100644
--- a/drivers/media/dvb/b2c2/flexcop-fe-tuner.c
+++ b/drivers/media/dvb/b2c2/flexcop-fe-tuner.c
@@ -298,7 +298,7 @@ static int flexcop_fe_request_firmware(s
 }
 
 static int lgdt3303_pll_set(struct dvb_frontend* fe,
-                            struct dvb_frontend_parameters* params)
+		            struct dvb_frontend_parameters* params)
 {
 	struct flexcop_device *fc = fe->dvb->priv;
 	u8 buf[4];
@@ -332,7 +332,7 @@ static int lgdt3303_pll_set(struct dvb_f
 			return -EREMOTEIO;
 	}
 
-        return 0;
+	return 0;
 }
 
 static struct lgdt330x_config air2pc_atsc_hd5000_config = {
diff --git a/drivers/media/dvb/bt8xx/dvb-bt8xx.c b/drivers/media/dvb/bt8xx/dvb-bt8xx.c
index 2e39809..77977e9 100644
--- a/drivers/media/dvb/bt8xx/dvb-bt8xx.c
+++ b/drivers/media/dvb/bt8xx/dvb-bt8xx.c
@@ -556,9 +556,9 @@ static int tdvs_tua6034_pll_set(struct d
 	dprintk("%s: tuner at 0x%02x bytes: 0x%02x 0x%02x 0x%02x 0x%02x\n",
 		__FUNCTION__, msg.addr, buf[0],buf[1],buf[2],buf[3]);
 	if ((err = i2c_transfer(card->i2c_adapter, &msg, 1)) != 1) {
-	        printk(KERN_WARNING "dvb-bt8xx: %s error "
-		        "(addr %02x <- %02x, err = %i)\n",
-		        __FUNCTION__, buf[0], buf[1], err);
+		printk(KERN_WARNING "dvb-bt8xx: %s error "
+			"(addr %02x <- %02x, err = %i)\n",
+			__FUNCTION__, buf[0], buf[1], err);
 		if (err < 0)
 			return err;
 		else
diff --git a/drivers/media/dvb/dvb-core/demux.h b/drivers/media/dvb/dvb-core/demux.h
index 7d7b006..9f02582 100644
--- a/drivers/media/dvb/dvb-core/demux.h
+++ b/drivers/media/dvb/dvb-core/demux.h
@@ -86,25 +86,25 @@ enum dmx_success {
 
 enum dmx_ts_pes
 {  /* also send packets to decoder (if it exists) */
-        DMX_TS_PES_AUDIO0,
+	DMX_TS_PES_AUDIO0,
 	DMX_TS_PES_VIDEO0,
 	DMX_TS_PES_TELETEXT0,
 	DMX_TS_PES_SUBTITLE0,
 	DMX_TS_PES_PCR0,
 
-        DMX_TS_PES_AUDIO1,
+	DMX_TS_PES_AUDIO1,
 	DMX_TS_PES_VIDEO1,
 	DMX_TS_PES_TELETEXT1,
 	DMX_TS_PES_SUBTITLE1,
 	DMX_TS_PES_PCR1,
 
-        DMX_TS_PES_AUDIO2,
+	DMX_TS_PES_AUDIO2,
 	DMX_TS_PES_VIDEO2,
 	DMX_TS_PES_TELETEXT2,
 	DMX_TS_PES_SUBTITLE2,
 	DMX_TS_PES_PCR2,
 
-        DMX_TS_PES_AUDIO3,
+	DMX_TS_PES_AUDIO3,
 	DMX_TS_PES_VIDEO3,
 	DMX_TS_PES_TELETEXT3,
 	DMX_TS_PES_SUBTITLE3,
@@ -121,17 +121,17 @@ enum dmx_ts_pes
 
 
 struct dmx_ts_feed {
-        int is_filtering; /* Set to non-zero when filtering in progress */
-        struct dmx_demux *parent; /* Back-pointer */
-        void *priv; /* Pointer to private data of the API client */
-        int (*set) (struct dmx_ts_feed *feed,
+	int is_filtering; /* Set to non-zero when filtering in progress */
+	struct dmx_demux *parent; /* Back-pointer */
+	void *priv; /* Pointer to private data of the API client */
+	int (*set) (struct dmx_ts_feed *feed,
 		    u16 pid,
 		    int type,
 		    enum dmx_ts_pes pes_type,
 		    size_t circular_buffer_size,
 		    struct timespec timeout);
-        int (*start_filtering) (struct dmx_ts_feed* feed);
-        int (*stop_filtering) (struct dmx_ts_feed* feed);
+	int (*start_filtering) (struct dmx_ts_feed* feed);
+	int (*stop_filtering) (struct dmx_ts_feed* feed);
 };
 
 /*--------------------------------------------------------------------------*/
@@ -139,35 +139,35 @@ struct dmx_ts_feed {
 /*--------------------------------------------------------------------------*/
 
 struct dmx_section_filter {
-        u8 filter_value [DMX_MAX_FILTER_SIZE];
-        u8 filter_mask [DMX_MAX_FILTER_SIZE];
-        u8 filter_mode [DMX_MAX_FILTER_SIZE];
-        struct dmx_section_feed* parent; /* Back-pointer */
-        void* priv; /* Pointer to private data of the API client */
+	u8 filter_value [DMX_MAX_FILTER_SIZE];
+	u8 filter_mask [DMX_MAX_FILTER_SIZE];
+	u8 filter_mode [DMX_MAX_FILTER_SIZE];
+	struct dmx_section_feed* parent; /* Back-pointer */
+	void* priv; /* Pointer to private data of the API client */
 };
 
 struct dmx_section_feed {
-        int is_filtering; /* Set to non-zero when filtering in progress */
-        struct dmx_demux* parent; /* Back-pointer */
-        void* priv; /* Pointer to private data of the API client */
+	int is_filtering; /* Set to non-zero when filtering in progress */
+	struct dmx_demux* parent; /* Back-pointer */
+	void* priv; /* Pointer to private data of the API client */
 
-        int check_crc;
+	int check_crc;
 	u32 crc_val;
 
-        u8 *secbuf;
-        u8 secbuf_base[DMX_MAX_SECFEED_SIZE];
-        u16 secbufp, seclen, tsfeedp;
+	u8 *secbuf;
+	u8 secbuf_base[DMX_MAX_SECFEED_SIZE];
+	u16 secbufp, seclen, tsfeedp;
 
-        int (*set) (struct dmx_section_feed* feed,
+	int (*set) (struct dmx_section_feed* feed,
 		    u16 pid,
 		    size_t circular_buffer_size,
 		    int check_crc);
-        int (*allocate_filter) (struct dmx_section_feed* feed,
+	int (*allocate_filter) (struct dmx_section_feed* feed,
 				struct dmx_section_filter** filter);
-        int (*release_filter) (struct dmx_section_feed* feed,
+	int (*release_filter) (struct dmx_section_feed* feed,
 			       struct dmx_section_filter* filter);
-        int (*start_filtering) (struct dmx_section_feed* feed);
-        int (*stop_filtering) (struct dmx_section_feed* feed);
+	int (*start_filtering) (struct dmx_section_feed* feed);
+	int (*stop_filtering) (struct dmx_section_feed* feed);
 };
 
 /*--------------------------------------------------------------------------*/
@@ -205,10 +205,10 @@ enum dmx_frontend_source {
 };
 
 struct dmx_frontend {
-        struct list_head connectivity_list; /* List of front-ends that can
+	struct list_head connectivity_list; /* List of front-ends that can
 					       be connected to a particular
 					       demux */
-        enum dmx_frontend_source source;
+	enum dmx_frontend_source source;
 };
 
 /*--------------------------------------------------------------------------*/
@@ -240,38 +240,38 @@ struct dmx_frontend {
 #define DMX_FE_ENTRY(list) list_entry(list, struct dmx_frontend, connectivity_list)
 
 struct dmx_demux {
-        u32 capabilities;            /* Bitfield of capability flags */
-        struct dmx_frontend* frontend;    /* Front-end connected to the demux */
-        void* priv;                  /* Pointer to private data of the API client */
-        int (*open) (struct dmx_demux* demux);
-        int (*close) (struct dmx_demux* demux);
-        int (*write) (struct dmx_demux* demux, const char* buf, size_t count);
-        int (*allocate_ts_feed) (struct dmx_demux* demux,
+	u32 capabilities;            /* Bitfield of capability flags */
+	struct dmx_frontend* frontend;    /* Front-end connected to the demux */
+	void* priv;                  /* Pointer to private data of the API client */
+	int (*open) (struct dmx_demux* demux);
+	int (*close) (struct dmx_demux* demux);
+	int (*write) (struct dmx_demux* demux, const char* buf, size_t count);
+	int (*allocate_ts_feed) (struct dmx_demux* demux,
 				 struct dmx_ts_feed** feed,
 				 dmx_ts_cb callback);
-        int (*release_ts_feed) (struct dmx_demux* demux,
+	int (*release_ts_feed) (struct dmx_demux* demux,
 				struct dmx_ts_feed* feed);
-        int (*allocate_section_feed) (struct dmx_demux* demux,
+	int (*allocate_section_feed) (struct dmx_demux* demux,
 				      struct dmx_section_feed** feed,
 				      dmx_section_cb callback);
-        int (*release_section_feed) (struct dmx_demux* demux,
+	int (*release_section_feed) (struct dmx_demux* demux,
 				     struct dmx_section_feed* feed);
-        int (*add_frontend) (struct dmx_demux* demux,
+	int (*add_frontend) (struct dmx_demux* demux,
 			     struct dmx_frontend* frontend);
-        int (*remove_frontend) (struct dmx_demux* demux,
+	int (*remove_frontend) (struct dmx_demux* demux,
 				struct dmx_frontend* frontend);
-        struct list_head* (*get_frontends) (struct dmx_demux* demux);
-        int (*connect_frontend) (struct dmx_demux* demux,
+	struct list_head* (*get_frontends) (struct dmx_demux* demux);
+	int (*connect_frontend) (struct dmx_demux* demux,
 				 struct dmx_frontend* frontend);
-        int (*disconnect_frontend) (struct dmx_demux* demux);
+	int (*disconnect_frontend) (struct dmx_demux* demux);
 
-        int (*get_pes_pids) (struct dmx_demux* demux, u16 *pids);
+	int (*get_pes_pids) (struct dmx_demux* demux, u16 *pids);
 
 	int (*get_caps) (struct dmx_demux* demux, struct dmx_caps *caps);
 
 	int (*set_source) (struct dmx_demux* demux, const dmx_source_t *src);
 
-        int (*get_stc) (struct dmx_demux* demux, unsigned int num,
+	int (*get_stc) (struct dmx_demux* demux, unsigned int num,
 			u64 *stc, unsigned int *base);
 };
 
diff --git a/drivers/media/dvb/dvb-core/dmxdev.c b/drivers/media/dvb/dvb-core/dmxdev.c
index 8028c3a..7b8373a 100644
--- a/drivers/media/dvb/dvb-core/dmxdev.c
+++ b/drivers/media/dvb/dvb-core/dmxdev.c
@@ -947,7 +947,7 @@ static int dvb_demux_do_ioctl(struct ino
 
 	case DMX_GET_STC:
 		if (!dmxdev->demux->get_stc) {
-		        ret=-EINVAL;
+			ret=-EINVAL;
 			break;
 		}
 		ret = dmxdev->demux->get_stc(dmxdev->demux,
diff --git a/drivers/media/dvb/dvb-core/dmxdev.h b/drivers/media/dvb/dvb-core/dmxdev.h
index 395a9cd..fd72920 100644
--- a/drivers/media/dvb/dvb-core/dmxdev.h
+++ b/drivers/media/dvb/dvb-core/dmxdev.h
@@ -53,51 +53,51 @@ enum dmxdev_state {
 };
 
 struct dmxdev_buffer {
-        u8 *data;
-        int size;
-        int pread;
-        int pwrite;
+	u8 *data;
+	int size;
+	int pread;
+	int pwrite;
 	wait_queue_head_t queue;
-        int error;
+	int error;
 };
 
 struct dmxdev_filter {
 	struct dvb_device *dvbdev;
 
-        union {
-	        struct dmx_section_filter *sec;
+	union {
+		struct dmx_section_filter *sec;
 	} filter;
 
-        union {
-                struct dmx_ts_feed *ts;
-                struct dmx_section_feed *sec;
+	union {
+		struct dmx_ts_feed *ts;
+		struct dmx_section_feed *sec;
 	} feed;
 
-        union {
-	        struct dmx_sct_filter_params sec;
-	        struct dmx_pes_filter_params pes;
+	union {
+		struct dmx_sct_filter_params sec;
+		struct dmx_pes_filter_params pes;
 	} params;
 
-        int type;
-        enum dmxdev_state state;
-        struct dmxdev *dev;
-        struct dmxdev_buffer buffer;
+	int type;
+	enum dmxdev_state state;
+	struct dmxdev *dev;
+	struct dmxdev_buffer buffer;
 
 	struct semaphore mutex;
 
-        /* only for sections */
-        struct timer_list timer;
-        int todo;
-        u8 secheader[3];
+	/* only for sections */
+	struct timer_list timer;
+	int todo;
+	u8 secheader[3];
 
-        u16 pid;
+	u16 pid;
 };
 
 
 struct dmxdev_dvr {
-        int state;
-        struct dmxdev *dev;
-        struct dmxdev_buffer buffer;
+	int state;
+	struct dmxdev *dev;
+	struct dmxdev_buffer buffer;
 };
 
 
@@ -105,16 +105,16 @@ struct dmxdev {
 	struct dvb_device *dvbdev;
 	struct dvb_device *dvr_dvbdev;
 
-        struct dmxdev_filter *filter;
-        struct dmxdev_dvr *dvr;
-        struct dmx_demux *demux;
+	struct dmxdev_filter *filter;
+	struct dmxdev_dvr *dvr;
+	struct dmx_demux *demux;
 
-        int filternum;
-        int capabilities;
+	int filternum;
+	int capabilities;
 #define DMXDEV_CAP_DUPLEX 1
-        struct dmx_frontend *dvr_orig_fe;
+	struct dmx_frontend *dvr_orig_fe;
 
-        struct dmxdev_buffer dvr_buffer;
+	struct dmxdev_buffer dvr_buffer;
 #define DVR_BUFFER_SIZE (10*188*1024)
 
 	struct semaphore mutex;
diff --git a/drivers/media/dvb/dvb-core/dvb_ca_en50221.c b/drivers/media/dvb/dvb-core/dvb_ca_en50221.c
index cb2e7d6..5956c35 100644
--- a/drivers/media/dvb/dvb-core/dvb_ca_en50221.c
+++ b/drivers/media/dvb/dvb-core/dvb_ca_en50221.c
@@ -498,7 +498,7 @@ static int dvb_ca_en50221_parse_attribut
 	/* process the CFTABLE_ENTRY tuples, and any after those */
 	while ((!end_chain) && (address < 0x1000)) {
 		if ((status = dvb_ca_en50221_read_tuple(ca, slot, &address, &tupleType,
-						        &tupleLength, tuple)) < 0)
+							&tupleLength, tuple)) < 0)
 			return status;
 		switch (tupleType) {
 		case 0x1B:	// CISTPL_CFTABLE_ENTRY
diff --git a/drivers/media/dvb/dvb-core/dvb_filter.c b/drivers/media/dvb/dvb-core/dvb_filter.c
index bd51439..c49fd0b 100644
--- a/drivers/media/dvb/dvb-core/dvb_filter.c
+++ b/drivers/media/dvb/dvb-core/dvb_filter.c
@@ -72,12 +72,12 @@ static int read_picture_header(u8 *headr
 	u8 pct;
 
 	if (pr) printk( "Pic header: ");
-        pic->temporal_reference[field] = (( headr[0] << 2 ) |
+	pic->temporal_reference[field] = (( headr[0] << 2 ) |
 					  (headr[1] & 0x03) )& 0x03ff;
 	if (pr) printk( " temp ref: 0x%04x", pic->temporal_reference[field]);
 
 	pct = ( headr[1] >> 2 ) & 0x07;
-        pic->picture_coding_type[field] = pct;
+	pic->picture_coding_type[field] = pct;
 	if (pr) {
 		switch(pct){
 			case I_FRAME:
@@ -93,17 +93,17 @@ static int read_picture_header(u8 *headr
 	}
 
 
-        pic->vinfo.vbv_delay  = (( headr[1] >> 5 ) | ( headr[2] << 3) |
+	pic->vinfo.vbv_delay  = (( headr[1] >> 5 ) | ( headr[2] << 3) |
 				 ( (headr[3] & 0x1F) << 11) ) & 0xffff;
 
 	if (pr) printk( " vbv delay: 0x%04x", pic->vinfo.vbv_delay);
 
-        pic->picture_header_parameter = ( headr[3] & 0xe0 ) |
+	pic->picture_header_parameter = ( headr[3] & 0xe0 ) |
 		((headr[4] & 0x80) >> 3);
 
-        if ( pct == B_FRAME ){
-                pic->picture_header_parameter |= ( headr[4] >> 3 ) & 0x0f;
-        }
+	if ( pct == B_FRAME ){
+		pic->picture_header_parameter |= ( headr[4] >> 3 ) & 0x0f;
+	}
 	if (pr) printk( " pic head param: 0x%x",
 			pic->picture_header_parameter);
 
@@ -124,18 +124,18 @@ static int read_gop_header(u8 *headr, st
 		       ((headr[0]<<4)& 0x30)| ((headr[1]>>4)& 0x0F),
 		       ((headr[1]<<3)& 0x38)| ((headr[2]>>5)& 0x0F));
 
-        if ( ( headr[3] & 0x40 ) != 0 ){
-                pic->closed_gop = 1;
-        } else {
-                pic->closed_gop = 0;
-        }
+	if ( ( headr[3] & 0x40 ) != 0 ){
+		pic->closed_gop = 1;
+	} else {
+		pic->closed_gop = 0;
+	}
 	if (pr) printk("closed: %d", pic->closed_gop);
 
-        if ( ( headr[3] & 0x20 ) != 0 ){
-                pic->broken_link = 1;
-        } else {
-                pic->broken_link = 0;
-        }
+	if ( ( headr[3] & 0x20 ) != 0 ){
+		pic->broken_link = 1;
+	} else {
+		pic->broken_link = 0;
+	}
 	if (pr) printk(" broken: %d\n", pic->broken_link);
 
 	return 0;
@@ -146,7 +146,7 @@ static int read_gop_header(u8 *headr, st
 /* needs 8 byte input */
 static int read_sequence_header(u8 *headr, struct dvb_video_info *vi, int pr)
 {
-        int sw;
+	int sw;
 	int form = -1;
 
 	if (pr) printk("Reading sequence header\n");
@@ -154,9 +154,9 @@ static int read_sequence_header(u8 *head
 	vi->horizontal_size	= ((headr[1] &0xF0) >> 4) | (headr[0] << 4);
 	vi->vertical_size	= ((headr[1] &0x0F) << 8) | (headr[2]);
 
-        sw = (int)((headr[3]&0xF0) >> 4) ;
+	sw = (int)((headr[3]&0xF0) >> 4) ;
 
-        switch( sw ){
+	switch( sw ){
 	case 1:
 		if (pr)
 			printk("Videostream: ASPECT: 1:1");
@@ -165,84 +165,84 @@ static int read_sequence_header(u8 *head
 	case 2:
 		if (pr)
 			printk("Videostream: ASPECT: 4:3");
-                vi->aspect_ratio = 133;
+		vi->aspect_ratio = 133;
 		break;
 	case 3:
 		if (pr)
 			printk("Videostream: ASPECT: 16:9");
-                vi->aspect_ratio = 177;
+		vi->aspect_ratio = 177;
 		break;
 	case 4:
 		if (pr)
 			printk("Videostream: ASPECT: 2.21:1");
-                vi->aspect_ratio = 221;
+		vi->aspect_ratio = 221;
 		break;
 
-        case 5 ... 15:
+	case 5 ... 15:
 		if (pr)
 			printk("Videostream: ASPECT: reserved");
-                vi->aspect_ratio = 0;
+		vi->aspect_ratio = 0;
 		break;
 
-        default:
-                vi->aspect_ratio = 0;
-                return -1;
+	default:
+		vi->aspect_ratio = 0;
+		return -1;
 	}
 
 	if (pr)
 		printk("  Size = %dx%d",vi->horizontal_size,vi->vertical_size);
 
-        sw = (int)(headr[3]&0x0F);
+	sw = (int)(headr[3]&0x0F);
 
-        switch ( sw ) {
+	switch ( sw ) {
 	case 1:
 		if (pr)
 			printk("  FRate: 23.976 fps");
-                vi->framerate = 23976;
+		vi->framerate = 23976;
 		form = -1;
 		break;
 	case 2:
 		if (pr)
 			printk("  FRate: 24 fps");
-                vi->framerate = 24000;
+		vi->framerate = 24000;
 		form = -1;
 		break;
 	case 3:
 		if (pr)
 			printk("  FRate: 25 fps");
-                vi->framerate = 25000;
+		vi->framerate = 25000;
 		form = VIDEO_MODE_PAL;
 		break;
 	case 4:
 		if (pr)
 			printk("  FRate: 29.97 fps");
-                vi->framerate = 29970;
+		vi->framerate = 29970;
 		form = VIDEO_MODE_NTSC;
 		break;
 	case 5:
 		if (pr)
 			printk("  FRate: 30 fps");
-                vi->framerate = 30000;
+		vi->framerate = 30000;
 		form = VIDEO_MODE_NTSC;
 		break;
 	case 6:
 		if (pr)
 			printk("  FRate: 50 fps");
-                vi->framerate = 50000;
+		vi->framerate = 50000;
 		form = VIDEO_MODE_PAL;
 		break;
 	case 7:
 		if (pr)
 			printk("  FRate: 60 fps");
-                vi->framerate = 60000;
+		vi->framerate = 60000;
 		form = VIDEO_MODE_NTSC;
 		break;
 	}
 
 	vi->bit_rate = (headr[4] << 10) | (headr[5] << 2) | (headr[6] & 0x03);
 
-        vi->vbv_buffer_size
-                = (( headr[6] & 0xF8) >> 3 ) | (( headr[7] & 0x1F )<< 5);
+	vi->vbv_buffer_size
+		= (( headr[6] & 0xF8) >> 3 ) | (( headr[7] & 0x1F )<< 5);
 
 	if (pr){
 		printk("  BRate: %d Mbit/s",4*(vi->bit_rate)/10000);
@@ -250,7 +250,7 @@ static int read_sequence_header(u8 *head
 		printk("\n");
 	}
 
-        vi->video_format = form;
+	vi->video_format = form;
 
 	return 0;
 }
@@ -308,7 +308,7 @@ static int get_ainfo(u8 *mbuf, int count
 	if (!found) return -1;
 
 	if (c+3 >= count) return -1;
-        headr = mbuf+c;
+	headr = mbuf+c;
 
 	ai->layer = (headr[1] & 0x06) >> 1;
 
@@ -368,7 +368,7 @@ int dvb_filter_get_ac3info(u8 *mbuf, int
 	if (c+5 >= count) return -1;
 
 	ai->layer = 0;  // 0 for AC3
-        headr = mbuf+c+2;
+	headr = mbuf+c+2;
 
 	frame = (headr[2]&0x3f);
 	ai->bit_rate = ac3_bitrates[frame >> 1]*1000;
@@ -396,159 +396,159 @@ EXPORT_SYMBOL(dvb_filter_get_ac3info);
 #if 0
 static u8 *skip_pes_header(u8 **bufp)
 {
-        u8 *inbuf = *bufp;
-        u8 *buf = inbuf;
-        u8 *pts = NULL;
-        int skip = 0;
+	u8 *inbuf = *bufp;
+	u8 *buf = inbuf;
+	u8 *pts = NULL;
+	int skip = 0;
 
 	static const int mpeg1_skip_table[16] = {
 		1, 0xffff,      5,     10, 0xffff, 0xffff, 0xffff, 0xffff,
-	        0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff
+		0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff
 	};
 
 
-        if ((inbuf[6] & 0xc0) == 0x80){ /* mpeg2 */
-                if (buf[7] & PTS_ONLY)
-                        pts = buf+9;
-                else pts = NULL;
-                buf = inbuf + 9 + inbuf[8];
-        } else {        /* mpeg1 */
-                for (buf = inbuf + 6; *buf == 0xff; buf++)
-                        if (buf == inbuf + 6 + 16) {
-                                break;
-                        }
-                if ((*buf & 0xc0) == 0x40)
-                        buf += 2;
-                skip = mpeg1_skip_table [*buf >> 4];
-                if (skip == 5 || skip == 10) pts = buf;
-                else pts = NULL;
+	if ((inbuf[6] & 0xc0) == 0x80){ /* mpeg2 */
+		if (buf[7] & PTS_ONLY)
+		        pts = buf+9;
+		else pts = NULL;
+		buf = inbuf + 9 + inbuf[8];
+	} else {        /* mpeg1 */
+		for (buf = inbuf + 6; *buf == 0xff; buf++)
+		        if (buf == inbuf + 6 + 16) {
+		                break;
+		        }
+		if ((*buf & 0xc0) == 0x40)
+		        buf += 2;
+		skip = mpeg1_skip_table [*buf >> 4];
+		if (skip == 5 || skip == 10) pts = buf;
+		else pts = NULL;
 
-                buf += mpeg1_skip_table [*buf >> 4];
-        }
+		buf += mpeg1_skip_table [*buf >> 4];
+	}
 
-        *bufp = buf;
-        return pts;
+	*bufp = buf;
+	return pts;
 }
 #endif
 
 #if 0
 static void initialize_quant_matrix( u32 *matrix )
 {
-        int i;
+	int i;
 
-        matrix[0]  = 0x08101013;
-        matrix[1]  = 0x10131616;
-        matrix[2]  = 0x16161616;
-        matrix[3]  = 0x1a181a1b;
-        matrix[4]  = 0x1b1b1a1a;
-        matrix[5]  = 0x1a1a1b1b;
-        matrix[6]  = 0x1b1d1d1d;
-        matrix[7]  = 0x2222221d;
-        matrix[8]  = 0x1d1d1b1b;
-        matrix[9]  = 0x1d1d2020;
-        matrix[10] = 0x22222526;
-        matrix[11] = 0x25232322;
-        matrix[12] = 0x23262628;
-        matrix[13] = 0x28283030;
-        matrix[14] = 0x2e2e3838;
-        matrix[15] = 0x3a454553;
+	matrix[0]  = 0x08101013;
+	matrix[1]  = 0x10131616;
+	matrix[2]  = 0x16161616;
+	matrix[3]  = 0x1a181a1b;
+	matrix[4]  = 0x1b1b1a1a;
+	matrix[5]  = 0x1a1a1b1b;
+	matrix[6]  = 0x1b1d1d1d;
+	matrix[7]  = 0x2222221d;
+	matrix[8]  = 0x1d1d1b1b;
+	matrix[9]  = 0x1d1d2020;
+	matrix[10] = 0x22222526;
+	matrix[11] = 0x25232322;
+	matrix[12] = 0x23262628;
+	matrix[13] = 0x28283030;
+	matrix[14] = 0x2e2e3838;
+	matrix[15] = 0x3a454553;
 
-        for ( i = 16 ; i < 32 ; i++ )
-                matrix[i] = 0x10101010;
+	for ( i = 16 ; i < 32 ; i++ )
+		matrix[i] = 0x10101010;
 }
 #endif
 
 #if 0
 static void initialize_mpg_picture(struct mpg_picture *pic)
 {
-        int i;
+	int i;
 
-        /* set MPEG1 */
-        pic->mpeg1_flag = 1;
-        pic->profile_and_level = 0x4A ;        /* MP@LL */
-        pic->progressive_sequence = 1;
-        pic->low_delay = 0;
-
-        pic->sequence_display_extension_flag = 0;
-        for ( i = 0 ; i < 4 ; i++ ){
-                pic->frame_centre_horizontal_offset[i] = 0;
-                pic->frame_centre_vertical_offset[i] = 0;
-        }
-        pic->last_frame_centre_horizontal_offset = 0;
-        pic->last_frame_centre_vertical_offset = 0;
-
-        pic->picture_display_extension_flag[0] = 0;
-        pic->picture_display_extension_flag[1] = 0;
-        pic->sequence_header_flag = 0;
+	/* set MPEG1 */
+	pic->mpeg1_flag = 1;
+	pic->profile_and_level = 0x4A ;        /* MP@LL */
+	pic->progressive_sequence = 1;
+	pic->low_delay = 0;
+
+	pic->sequence_display_extension_flag = 0;
+	for ( i = 0 ; i < 4 ; i++ ){
+		pic->frame_centre_horizontal_offset[i] = 0;
+		pic->frame_centre_vertical_offset[i] = 0;
+	}
+	pic->last_frame_centre_horizontal_offset = 0;
+	pic->last_frame_centre_vertical_offset = 0;
+
+	pic->picture_display_extension_flag[0] = 0;
+	pic->picture_display_extension_flag[1] = 0;
+	pic->sequence_header_flag = 0;
 	pic->gop_flag = 0;
-        pic->sequence_end_flag = 0;
+	pic->sequence_end_flag = 0;
 }
 #endif
 
 #if 0
 static void mpg_set_picture_parameter( int32_t field_type, struct mpg_picture *pic )
 {
-        int16_t last_h_offset;
-        int16_t last_v_offset;
+	int16_t last_h_offset;
+	int16_t last_v_offset;
 
-        int16_t *p_h_offset;
-        int16_t *p_v_offset;
+	int16_t *p_h_offset;
+	int16_t *p_v_offset;
 
-        if ( pic->mpeg1_flag ){
-                pic->picture_structure[field_type] = VIDEO_FRAME_PICTURE;
-                pic->top_field_first = 0;
-                pic->repeat_first_field = 0;
-                pic->progressive_frame = 1;
-                pic->picture_coding_parameter = 0x000010;
-        }
-
-        /* Reset flag */
-        pic->picture_display_extension_flag[field_type] = 0;
-
-        last_h_offset = pic->last_frame_centre_horizontal_offset;
-        last_v_offset = pic->last_frame_centre_vertical_offset;
-        if ( field_type == FIRST_FIELD ){
-                p_h_offset = pic->frame_centre_horizontal_offset;
-                p_v_offset = pic->frame_centre_vertical_offset;
-                *p_h_offset = last_h_offset;
-                *(p_h_offset + 1) = last_h_offset;
-                *(p_h_offset + 2) = last_h_offset;
-                *p_v_offset = last_v_offset;
-                *(p_v_offset + 1) = last_v_offset;
-                *(p_v_offset + 2) = last_v_offset;
-        } else {
-                pic->frame_centre_horizontal_offset[3] = last_h_offset;
-                pic->frame_centre_vertical_offset[3] = last_v_offset;
-        }
+	if ( pic->mpeg1_flag ){
+		pic->picture_structure[field_type] = VIDEO_FRAME_PICTURE;
+		pic->top_field_first = 0;
+		pic->repeat_first_field = 0;
+		pic->progressive_frame = 1;
+		pic->picture_coding_parameter = 0x000010;
+	}
+
+	/* Reset flag */
+	pic->picture_display_extension_flag[field_type] = 0;
+
+	last_h_offset = pic->last_frame_centre_horizontal_offset;
+	last_v_offset = pic->last_frame_centre_vertical_offset;
+	if ( field_type == FIRST_FIELD ){
+		p_h_offset = pic->frame_centre_horizontal_offset;
+		p_v_offset = pic->frame_centre_vertical_offset;
+		*p_h_offset = last_h_offset;
+		*(p_h_offset + 1) = last_h_offset;
+		*(p_h_offset + 2) = last_h_offset;
+		*p_v_offset = last_v_offset;
+		*(p_v_offset + 1) = last_v_offset;
+		*(p_v_offset + 2) = last_v_offset;
+	} else {
+		pic->frame_centre_horizontal_offset[3] = last_h_offset;
+		pic->frame_centre_vertical_offset[3] = last_v_offset;
+	}
 }
 #endif
 
 #if 0
 static void init_mpg_picture( struct mpg_picture *pic, int chan, int32_t field_type)
 {
-        pic->picture_header = 0;
-        pic->sequence_header_data
-                = ( INIT_HORIZONTAL_SIZE << 20 )
-                        | ( INIT_VERTICAL_SIZE << 8 )
-                        | ( INIT_ASPECT_RATIO << 4 )
-                        | ( INIT_FRAME_RATE );
-        pic->mpeg1_flag = 0;
-        pic->vinfo.horizontal_size
-                = INIT_DISP_HORIZONTAL_SIZE;
-        pic->vinfo.vertical_size
-                = INIT_DISP_VERTICAL_SIZE;
-        pic->picture_display_extension_flag[field_type]
-                = 0;
-        pic->pts_flag[field_type] = 0;
-
-        pic->sequence_gop_header = 0;
-        pic->picture_header = 0;
-        pic->sequence_header_flag = 0;
-        pic->gop_flag = 0;
-        pic->sequence_end_flag = 0;
-        pic->sequence_display_extension_flag = 0;
-        pic->last_frame_centre_horizontal_offset = 0;
-        pic->last_frame_centre_vertical_offset = 0;
+	pic->picture_header = 0;
+	pic->sequence_header_data
+		= ( INIT_HORIZONTAL_SIZE << 20 )
+		        | ( INIT_VERTICAL_SIZE << 8 )
+		        | ( INIT_ASPECT_RATIO << 4 )
+		        | ( INIT_FRAME_RATE );
+	pic->mpeg1_flag = 0;
+	pic->vinfo.horizontal_size
+		= INIT_DISP_HORIZONTAL_SIZE;
+	pic->vinfo.vertical_size
+		= INIT_DISP_VERTICAL_SIZE;
+	pic->picture_display_extension_flag[field_type]
+		= 0;
+	pic->pts_flag[field_type] = 0;
+
+	pic->sequence_gop_header = 0;
+	pic->picture_header = 0;
+	pic->sequence_header_flag = 0;
+	pic->gop_flag = 0;
+	pic->sequence_end_flag = 0;
+	pic->sequence_display_extension_flag = 0;
+	pic->last_frame_centre_horizontal_offset = 0;
+	pic->last_frame_centre_vertical_offset = 0;
 	pic->channel = chan;
 }
 #endif
@@ -588,11 +588,11 @@ int dvb_filter_pes2ts(struct dvb_filter_
 		buf[1]&=~0x40;
 	}
 	if (!len)
-	        return 0;
+		return 0;
 	buf[3]=0x30|((p2ts->cc++)&0x0f);
 	rest=183-len;
 	if (rest) {
-	        buf[5]=0x00;
+		buf[5]=0x00;
 		if (rest-1)
 			memset(buf+6, 0xff, rest-1);
 	}
diff --git a/drivers/media/dvb/dvb-core/dvb_filter.h b/drivers/media/dvb/dvb-core/dvb_filter.h
index b0848f7..375e3be 100644
--- a/drivers/media/dvb/dvb-core/dvb_filter.h
+++ b/drivers/media/dvb/dvb-core/dvb_filter.h
@@ -29,8 +29,8 @@ typedef int (dvb_filter_pes2ts_cb_t) (vo
 
 struct dvb_filter_pes2ts {
 	unsigned char buf[188];
-        unsigned char cc;
-        dvb_filter_pes2ts_cb_t *cb;
+	unsigned char cc;
+	dvb_filter_pes2ts_cb_t *cb;
 	void *priv;
 };
 
@@ -162,7 +162,7 @@ struct dvb_video_info {
 	u32 bit_rate;
 	u32 comp_bit_rate;
 	u32 vbv_buffer_size;
-        s16 vbv_delay;
+	s16 vbv_delay;
 	u32 CSPF;
 	u32 off;
 };
@@ -173,60 +173,60 @@ struct dvb_video_info {
 #define VIDEO_FRAME_PICTURE 0x03
 
 struct mpg_picture {
-        int       channel;
+	int       channel;
 	struct dvb_video_info vinfo;
-        u32      *sequence_gop_header;
-        u32      *picture_header;
-        s32       time_code;
-        int       low_delay;
-        int       closed_gop;
-        int       broken_link;
-        int       sequence_header_flag;
-        int       gop_flag;
-        int       sequence_end_flag;
-
-        u8        profile_and_level;
-        s32       picture_coding_parameter;
-        u32       matrix[32];
-        s8        matrix_change_flag;
+	u32      *sequence_gop_header;
+	u32      *picture_header;
+	s32       time_code;
+	int       low_delay;
+	int       closed_gop;
+	int       broken_link;
+	int       sequence_header_flag;
+	int       gop_flag;
+	int       sequence_end_flag;
+
+	u8        profile_and_level;
+	s32       picture_coding_parameter;
+	u32       matrix[32];
+	s8        matrix_change_flag;
 
-        u8        picture_header_parameter;
+	u8        picture_header_parameter;
   /* bit 0 - 2: bwd f code
      bit 3    : fpb vector
      bit 4 - 6: fwd f code
      bit 7    : fpf vector */
 
-        int       mpeg1_flag;
-        int       progressive_sequence;
-        int       sequence_display_extension_flag;
-        u32       sequence_header_data;
-        s16       last_frame_centre_horizontal_offset;
-        s16       last_frame_centre_vertical_offset;
-
-        u32       pts[2]; /* [0] 1st field, [1] 2nd field */
-        int       top_field_first;
-        int       repeat_first_field;
-        int       progressive_frame;
-        int       bank;
-        int       forward_bank;
-        int       backward_bank;
-        int       compress;
-        s16       frame_centre_horizontal_offset[OFF_SIZE];
-                  /* [0-2] 1st field, [3] 2nd field */
-        s16       frame_centre_vertical_offset[OFF_SIZE];
-                  /* [0-2] 1st field, [3] 2nd field */
-        s16       temporal_reference[2];
-                  /* [0] 1st field, [1] 2nd field */
-
-        s8        picture_coding_type[2];
-                  /* [0] 1st field, [1] 2nd field */
-        s8        picture_structure[2];
-                  /* [0] 1st field, [1] 2nd field */
-        s8        picture_display_extension_flag[2];
-                  /* [0] 1st field, [1] 2nd field */
-                  /* picture_display_extenion() 0:no 1:exit*/
-        s8        pts_flag[2];
-                  /* [0] 1st field, [1] 2nd field */
+	int       mpeg1_flag;
+	int       progressive_sequence;
+	int       sequence_display_extension_flag;
+	u32       sequence_header_data;
+	s16       last_frame_centre_horizontal_offset;
+	s16       last_frame_centre_vertical_offset;
+
+	u32       pts[2]; /* [0] 1st field, [1] 2nd field */
+	int       top_field_first;
+	int       repeat_first_field;
+	int       progressive_frame;
+	int       bank;
+	int       forward_bank;
+	int       backward_bank;
+	int       compress;
+	s16       frame_centre_horizontal_offset[OFF_SIZE];
+		  /* [0-2] 1st field, [3] 2nd field */
+	s16       frame_centre_vertical_offset[OFF_SIZE];
+		  /* [0-2] 1st field, [3] 2nd field */
+	s16       temporal_reference[2];
+		  /* [0] 1st field, [1] 2nd field */
+
+	s8        picture_coding_type[2];
+		  /* [0] 1st field, [1] 2nd field */
+	s8        picture_structure[2];
+		  /* [0] 1st field, [1] 2nd field */
+	s8        picture_display_extension_flag[2];
+		  /* [0] 1st field, [1] 2nd field */
+		  /* picture_display_extenion() 0:no 1:exit*/
+	s8        pts_flag[2];
+		  /* [0] 1st field, [1] 2nd field */
 };
 
 struct dvb_audio_info {
diff --git a/drivers/media/dvb/dvb-core/dvb_frontend.c b/drivers/media/dvb/dvb-core/dvb_frontend.c
index 6ffa6b2..95ea509 100644
--- a/drivers/media/dvb/dvb-core/dvb_frontend.c
+++ b/drivers/media/dvb/dvb-core/dvb_frontend.c
@@ -372,10 +372,10 @@ static int dvb_frontend_thread(void *dat
 
 	snprintf (name, sizeof(name), "kdvb-fe-%i", fe->dvb->num);
 
-        lock_kernel();
-        daemonize(name);
-        sigfillset(&current->blocked);
-        unlock_kernel();
+	lock_kernel();
+	daemonize(name);
+	sigfillset(&current->blocked);
+	unlock_kernel();
 
 	fepriv->status = 0;
 	dvb_frontend_init(fe);
diff --git a/drivers/media/dvb/dvb-core/dvb_frontend.h b/drivers/media/dvb/dvb-core/dvb_frontend.h
index 348c9b0..1e0840d 100644
--- a/drivers/media/dvb/dvb-core/dvb_frontend.h
+++ b/drivers/media/dvb/dvb-core/dvb_frontend.h
@@ -41,10 +41,10 @@
 #include "dvbdev.h"
 
 struct dvb_frontend_tune_settings {
-        int min_delay_ms;
-        int step_size;
-        int max_drift;
-        struct dvb_frontend_parameters parameters;
+	int min_delay_ms;
+	int step_size;
+	int max_drift;
+	struct dvb_frontend_parameters parameters;
 };
 
 struct dvb_frontend;
diff --git a/drivers/media/dvb/dvb-core/dvb_net.c b/drivers/media/dvb/dvb-core/dvb_net.c
index df536bd..86bba81 100644
--- a/drivers/media/dvb/dvb-core/dvb_net.c
+++ b/drivers/media/dvb/dvb-core/dvb_net.c
@@ -713,7 +713,7 @@ static int dvb_net_ts_callback(const u8 
 	if (buffer1_len > 32768)
 		printk(KERN_WARNING "length > 32k: %zu.\n", buffer1_len);
 	/* printk("TS callback: %u bytes, %u TS cells @ %p.\n",
-	          buffer1_len, buffer1_len / TS_SZ, buffer1); */
+		  buffer1_len, buffer1_len / TS_SZ, buffer1); */
 	dvb_net_ule(dev, buffer1, buffer1_len);
 	return 0;
 }
@@ -721,8 +721,8 @@ static int dvb_net_ts_callback(const u8 
 
 static void dvb_net_sec(struct net_device *dev, u8 *pkt, int pkt_len)
 {
-        u8 *eth;
-        struct sk_buff *skb;
+	u8 *eth;
+	struct sk_buff *skb;
 	struct net_device_stats *stats = &(((struct dvb_net_priv *) dev->priv)->stats);
 	int snap = 0;
 
@@ -754,7 +754,7 @@ static void dvb_net_sec(struct net_devic
 			return;
 		}
 		snap = 8;
-        }
+	}
 	if (pkt[7]) {
 		/* FIXME: assemble datagram from multiple sections */
 		stats->rx_errors++;
@@ -778,14 +778,14 @@ static void dvb_net_sec(struct net_devic
 	memcpy(eth + 14, pkt + 12 + snap, pkt_len - 12 - 4 - snap);
 
 	/* create ethernet header: */
-        eth[0]=pkt[0x0b];
-        eth[1]=pkt[0x0a];
-        eth[2]=pkt[0x09];
-        eth[3]=pkt[0x08];
-        eth[4]=pkt[0x04];
-        eth[5]=pkt[0x03];
+	eth[0]=pkt[0x0b];
+	eth[1]=pkt[0x0a];
+	eth[2]=pkt[0x09];
+	eth[3]=pkt[0x08];
+	eth[4]=pkt[0x04];
+	eth[5]=pkt[0x03];
 
-        eth[6]=eth[7]=eth[8]=eth[9]=eth[10]=eth[11]=0;
+	eth[6]=eth[7]=eth[8]=eth[9]=eth[10]=eth[11]=0;
 
 	if (snap) {
 		eth[12] = pkt[18];
@@ -807,7 +807,7 @@ static void dvb_net_sec(struct net_devic
 
 	stats->rx_packets++;
 	stats->rx_bytes+=skb->len;
-        netif_rx(skb);
+	netif_rx(skb);
 }
 
 static int dvb_net_sec_callback(const u8 *buffer1, size_t buffer1_len,
@@ -815,7 +815,7 @@ static int dvb_net_sec_callback(const u8
 		 struct dmx_section_filter *filter,
 		 enum dmx_success success)
 {
-        struct net_device *dev = filter->priv;
+	struct net_device *dev = filter->priv;
 
 	/**
 	 * we rely on the DVB API definition where exactly one complete
@@ -885,8 +885,8 @@ static int dvb_net_feed_start(struct net
 {
 	int ret = 0, i;
 	struct dvb_net_priv *priv = dev->priv;
-        struct dmx_demux *demux = priv->demux;
-        unsigned char *mac = (unsigned char *) dev->dev_addr;
+	struct dmx_demux *demux = priv->demux;
+	unsigned char *mac = (unsigned char *) dev->dev_addr;
 
 	dprintk("%s: rx_mode %i\n", __FUNCTION__, priv->rx_mode);
 	down(&priv->mutex);
@@ -1129,12 +1129,12 @@ static int dvb_net_stop(struct net_devic
 	struct dvb_net_priv *priv = dev->priv;
 
 	priv->in_use--;
-        return dvb_net_feed_stop(dev);
+	return dvb_net_feed_stop(dev);
 }
 
 static struct net_device_stats * dvb_net_get_stats(struct net_device *dev)
 {
-        return &((struct dvb_net_priv*) dev->priv)->stats;
+	return &((struct dvb_net_priv*) dev->priv)->stats;
 }
 
 static void dvb_net_setup(struct net_device *dev)
@@ -1360,10 +1360,10 @@ static struct file_operations dvb_net_fo
 };
 
 static struct dvb_device dvbdev_net = {
-        .priv = NULL,
-        .users = 1,
-        .writers = 1,
-        .fops = &dvb_net_fops,
+	.priv = NULL,
+	.users = 1,
+	.writers = 1,
+	.fops = &dvb_net_fops,
 };
 
 
diff --git a/drivers/media/dvb/dvb-core/dvb_ringbuffer.c b/drivers/media/dvb/dvb-core/dvb_ringbuffer.c
index fb6d94a..283c6e9 100644
--- a/drivers/media/dvb/dvb-core/dvb_ringbuffer.c
+++ b/drivers/media/dvb/dvb-core/dvb_ringbuffer.c
@@ -42,216 +42,216 @@
 
 void dvb_ringbuffer_init(struct dvb_ringbuffer *rbuf, void *data, size_t len)
 {
-        rbuf->pread=rbuf->pwrite=0;
-        rbuf->data=data;
-        rbuf->size=len;
+	rbuf->pread=rbuf->pwrite=0;
+	rbuf->data=data;
+	rbuf->size=len;
 
-        init_waitqueue_head(&rbuf->queue);
+	init_waitqueue_head(&rbuf->queue);
 
-        spin_lock_init(&(rbuf->lock));
+	spin_lock_init(&(rbuf->lock));
 }
 
 
 
 int dvb_ringbuffer_empty(struct dvb_ringbuffer *rbuf)
 {
-        return (rbuf->pread==rbuf->pwrite);
+	return (rbuf->pread==rbuf->pwrite);
 }
 
 
 
 ssize_t dvb_ringbuffer_free(struct dvb_ringbuffer *rbuf)
 {
-        ssize_t free;
+	ssize_t free;
 
-        free = rbuf->pread - rbuf->pwrite;
-        if (free <= 0)
-                free += rbuf->size;
-        return free-1;
+	free = rbuf->pread - rbuf->pwrite;
+	if (free <= 0)
+		free += rbuf->size;
+	return free-1;
 }
 
 
 
 ssize_t dvb_ringbuffer_avail(struct dvb_ringbuffer *rbuf)
 {
-        ssize_t avail;
+	ssize_t avail;
 
-        avail = rbuf->pwrite - rbuf->pread;
-        if (avail < 0)
-                avail += rbuf->size;
-        return avail;
+	avail = rbuf->pwrite - rbuf->pread;
+	if (avail < 0)
+		avail += rbuf->size;
+	return avail;
 }
 
 
 
 void dvb_ringbuffer_flush(struct dvb_ringbuffer *rbuf)
 {
-        rbuf->pread = rbuf->pwrite;
+	rbuf->pread = rbuf->pwrite;
 }
 
 
 
 void dvb_ringbuffer_flush_spinlock_wakeup(struct dvb_ringbuffer *rbuf)
 {
-        unsigned long flags;
+	unsigned long flags;
 
-        spin_lock_irqsave(&rbuf->lock, flags);
-        dvb_ringbuffer_flush(rbuf);
-        spin_unlock_irqrestore(&rbuf->lock, flags);
+	spin_lock_irqsave(&rbuf->lock, flags);
+	dvb_ringbuffer_flush(rbuf);
+	spin_unlock_irqrestore(&rbuf->lock, flags);
 
-        wake_up(&rbuf->queue);
+	wake_up(&rbuf->queue);
 }
 
 
 
 ssize_t dvb_ringbuffer_read(struct dvb_ringbuffer *rbuf, u8 *buf, size_t len, int usermem)
 {
-        size_t todo = len;
-        size_t split;
+	size_t todo = len;
+	size_t split;
 
-        split = (rbuf->pread + len > rbuf->size) ? rbuf->size - rbuf->pread : 0;
-        if (split > 0) {
-                if (!usermem)
-                        memcpy(buf, rbuf->data+rbuf->pread, split);
-                else
-                        if (copy_to_user(buf, rbuf->data+rbuf->pread, split))
-                                return -EFAULT;
-                buf += split;
-                todo -= split;
-                rbuf->pread = 0;
-        }
-        if (!usermem)
-                memcpy(buf, rbuf->data+rbuf->pread, todo);
-        else
-                if (copy_to_user(buf, rbuf->data+rbuf->pread, todo))
-                        return -EFAULT;
+	split = (rbuf->pread + len > rbuf->size) ? rbuf->size - rbuf->pread : 0;
+	if (split > 0) {
+		if (!usermem)
+		        memcpy(buf, rbuf->data+rbuf->pread, split);
+		else
+		        if (copy_to_user(buf, rbuf->data+rbuf->pread, split))
+		                return -EFAULT;
+		buf += split;
+		todo -= split;
+		rbuf->pread = 0;
+	}
+	if (!usermem)
+		memcpy(buf, rbuf->data+rbuf->pread, todo);
+	else
+		if (copy_to_user(buf, rbuf->data+rbuf->pread, todo))
+		        return -EFAULT;
 
-        rbuf->pread = (rbuf->pread + todo) % rbuf->size;
+	rbuf->pread = (rbuf->pread + todo) % rbuf->size;
 
-        return len;
+	return len;
 }
 
 
 
 ssize_t dvb_ringbuffer_write(struct dvb_ringbuffer *rbuf, const u8 *buf, size_t len)
 {
-        size_t todo = len;
-        size_t split;
+	size_t todo = len;
+	size_t split;
 
-        split = (rbuf->pwrite + len > rbuf->size) ? rbuf->size - rbuf->pwrite : 0;
+	split = (rbuf->pwrite + len > rbuf->size) ? rbuf->size - rbuf->pwrite : 0;
 
-        if (split > 0) {
-                memcpy(rbuf->data+rbuf->pwrite, buf, split);
-                buf += split;
-                todo -= split;
-                rbuf->pwrite = 0;
-        }
-        memcpy(rbuf->data+rbuf->pwrite, buf, todo);
-        rbuf->pwrite = (rbuf->pwrite + todo) % rbuf->size;
+	if (split > 0) {
+		memcpy(rbuf->data+rbuf->pwrite, buf, split);
+		buf += split;
+		todo -= split;
+		rbuf->pwrite = 0;
+	}
+	memcpy(rbuf->data+rbuf->pwrite, buf, todo);
+	rbuf->pwrite = (rbuf->pwrite + todo) % rbuf->size;
 
-        return len;
+	return len;
 }
 
 ssize_t dvb_ringbuffer_pkt_write(struct dvb_ringbuffer *rbuf, u8* buf, size_t len)
 {
-        int status;
-        ssize_t oldpwrite = rbuf->pwrite;
+	int status;
+	ssize_t oldpwrite = rbuf->pwrite;
 
-        DVB_RINGBUFFER_WRITE_BYTE(rbuf, len >> 8);
-        DVB_RINGBUFFER_WRITE_BYTE(rbuf, len & 0xff);
-        DVB_RINGBUFFER_WRITE_BYTE(rbuf, PKT_READY);
-        status = dvb_ringbuffer_write(rbuf, buf, len);
+	DVB_RINGBUFFER_WRITE_BYTE(rbuf, len >> 8);
+	DVB_RINGBUFFER_WRITE_BYTE(rbuf, len & 0xff);
+	DVB_RINGBUFFER_WRITE_BYTE(rbuf, PKT_READY);
+	status = dvb_ringbuffer_write(rbuf, buf, len);
 
-        if (status < 0) rbuf->pwrite = oldpwrite;
-        return status;
+	if (status < 0) rbuf->pwrite = oldpwrite;
+	return status;
 }
 
 ssize_t dvb_ringbuffer_pkt_read(struct dvb_ringbuffer *rbuf, size_t idx,
-                                int offset, u8* buf, size_t len, int usermem)
+		                int offset, u8* buf, size_t len, int usermem)
 {
-        size_t todo;
-        size_t split;
-        size_t pktlen;
-
-        pktlen = rbuf->data[idx] << 8;
-        pktlen |= rbuf->data[(idx + 1) % rbuf->size];
-        if (offset > pktlen) return -EINVAL;
-        if ((offset + len) > pktlen) len = pktlen - offset;
-
-        idx = (idx + DVB_RINGBUFFER_PKTHDRSIZE + offset) % rbuf->size;
-        todo = len;
-        split = ((idx + len) > rbuf->size) ? rbuf->size - idx : 0;
-        if (split > 0) {
-                if (!usermem)
-                        memcpy(buf, rbuf->data+idx, split);
-                else
-                        if (copy_to_user(buf, rbuf->data+idx, split))
-                                return -EFAULT;
-                buf += split;
-                todo -= split;
-                idx = 0;
-        }
-        if (!usermem)
-                memcpy(buf, rbuf->data+idx, todo);
-        else
-                if (copy_to_user(buf, rbuf->data+idx, todo))
-                        return -EFAULT;
+	size_t todo;
+	size_t split;
+	size_t pktlen;
+
+	pktlen = rbuf->data[idx] << 8;
+	pktlen |= rbuf->data[(idx + 1) % rbuf->size];
+	if (offset > pktlen) return -EINVAL;
+	if ((offset + len) > pktlen) len = pktlen - offset;
+
+	idx = (idx + DVB_RINGBUFFER_PKTHDRSIZE + offset) % rbuf->size;
+	todo = len;
+	split = ((idx + len) > rbuf->size) ? rbuf->size - idx : 0;
+	if (split > 0) {
+		if (!usermem)
+		        memcpy(buf, rbuf->data+idx, split);
+		else
+		        if (copy_to_user(buf, rbuf->data+idx, split))
+		                return -EFAULT;
+		buf += split;
+		todo -= split;
+		idx = 0;
+	}
+	if (!usermem)
+		memcpy(buf, rbuf->data+idx, todo);
+	else
+		if (copy_to_user(buf, rbuf->data+idx, todo))
+		        return -EFAULT;
 
-        return len;
+	return len;
 }
 
 void dvb_ringbuffer_pkt_dispose(struct dvb_ringbuffer *rbuf, size_t idx)
 {
-        size_t pktlen;
+	size_t pktlen;
 
-        rbuf->data[(idx + 2) % rbuf->size] = PKT_DISPOSED;
+	rbuf->data[(idx + 2) % rbuf->size] = PKT_DISPOSED;
 
-        // clean up disposed packets
-        while(dvb_ringbuffer_avail(rbuf) > DVB_RINGBUFFER_PKTHDRSIZE) {
-                if (DVB_RINGBUFFER_PEEK(rbuf, 2) == PKT_DISPOSED) {
-                        pktlen = DVB_RINGBUFFER_PEEK(rbuf, 0) << 8;
-                        pktlen |= DVB_RINGBUFFER_PEEK(rbuf, 1);
-                        DVB_RINGBUFFER_SKIP(rbuf, pktlen + DVB_RINGBUFFER_PKTHDRSIZE);
-                } else {
-                        // first packet is not disposed, so we stop cleaning now
-                        break;
-                }
-        }
+	// clean up disposed packets
+	while(dvb_ringbuffer_avail(rbuf) > DVB_RINGBUFFER_PKTHDRSIZE) {
+		if (DVB_RINGBUFFER_PEEK(rbuf, 2) == PKT_DISPOSED) {
+		        pktlen = DVB_RINGBUFFER_PEEK(rbuf, 0) << 8;
+		        pktlen |= DVB_RINGBUFFER_PEEK(rbuf, 1);
+		        DVB_RINGBUFFER_SKIP(rbuf, pktlen + DVB_RINGBUFFER_PKTHDRSIZE);
+		} else {
+		        // first packet is not disposed, so we stop cleaning now
+		        break;
+		}
+	}
 }
 
 ssize_t dvb_ringbuffer_pkt_next(struct dvb_ringbuffer *rbuf, size_t idx, size_t* pktlen)
 {
-        int consumed;
-        int curpktlen;
-        int curpktstatus;
+	int consumed;
+	int curpktlen;
+	int curpktstatus;
 
-        if (idx == -1) {
+	if (idx == -1) {
 	       idx = rbuf->pread;
 	} else {
-                curpktlen = rbuf->data[idx] << 8;
-                curpktlen |= rbuf->data[(idx + 1) % rbuf->size];
-	        idx = (idx + curpktlen + DVB_RINGBUFFER_PKTHDRSIZE) % rbuf->size;
+		curpktlen = rbuf->data[idx] << 8;
+		curpktlen |= rbuf->data[(idx + 1) % rbuf->size];
+		idx = (idx + curpktlen + DVB_RINGBUFFER_PKTHDRSIZE) % rbuf->size;
 	}
 
-        consumed = (idx - rbuf->pread) % rbuf->size;
+	consumed = (idx - rbuf->pread) % rbuf->size;
 
-        while((dvb_ringbuffer_avail(rbuf) - consumed) > DVB_RINGBUFFER_PKTHDRSIZE) {
+	while((dvb_ringbuffer_avail(rbuf) - consumed) > DVB_RINGBUFFER_PKTHDRSIZE) {
 
-                curpktlen = rbuf->data[idx] << 8;
-                curpktlen |= rbuf->data[(idx + 1) % rbuf->size];
-                curpktstatus = rbuf->data[(idx + 2) % rbuf->size];
+		curpktlen = rbuf->data[idx] << 8;
+		curpktlen |= rbuf->data[(idx + 1) % rbuf->size];
+		curpktstatus = rbuf->data[(idx + 2) % rbuf->size];
 
-                if (curpktstatus == PKT_READY) {
-                        *pktlen = curpktlen;
-                        return idx;
-                }
+		if (curpktstatus == PKT_READY) {
+		        *pktlen = curpktlen;
+		        return idx;
+		}
 
-                consumed += curpktlen + DVB_RINGBUFFER_PKTHDRSIZE;
-                idx = (idx + curpktlen + DVB_RINGBUFFER_PKTHDRSIZE) % rbuf->size;
-        }
+		consumed += curpktlen + DVB_RINGBUFFER_PKTHDRSIZE;
+		idx = (idx + curpktlen + DVB_RINGBUFFER_PKTHDRSIZE) % rbuf->size;
+	}
 
-        // no packets available
-        return -1;
+	// no packets available
+	return -1;
 }
 
 
diff --git a/drivers/media/dvb/dvb-core/dvb_ringbuffer.h b/drivers/media/dvb/dvb-core/dvb_ringbuffer.h
index d18e9c4..fa476f6 100644
--- a/drivers/media/dvb/dvb-core/dvb_ringbuffer.h
+++ b/drivers/media/dvb/dvb-core/dvb_ringbuffer.h
@@ -31,13 +31,13 @@
 #include <linux/wait.h>
 
 struct dvb_ringbuffer {
-        u8               *data;
-        ssize_t           size;
-        ssize_t           pread;
-        ssize_t           pwrite;
+	u8               *data;
+	ssize_t           size;
+	ssize_t           pread;
+	ssize_t           pwrite;
 
-        wait_queue_head_t queue;
-        spinlock_t        lock;
+	wait_queue_head_t queue;
+	spinlock_t        lock;
 };
 
 #define DVB_RINGBUFFER_PKTHDRSIZE 3
@@ -106,7 +106,7 @@ extern void dvb_ringbuffer_flush_spinloc
 ** returns number of bytes transferred or -EFAULT
 */
 extern ssize_t dvb_ringbuffer_read(struct dvb_ringbuffer *rbuf, u8 *buf,
-                                   size_t len, int usermem);
+		                   size_t len, int usermem);
 
 
 /* write routines & macros */
@@ -121,7 +121,7 @@ extern ssize_t dvb_ringbuffer_read(struc
 ** returns number of bytes transferred or -EFAULT
 */
 extern ssize_t dvb_ringbuffer_write(struct dvb_ringbuffer *rbuf, const u8 *buf,
-                                    size_t len);
+		                    size_t len);
 
 
 /**
@@ -133,7 +133,7 @@ extern ssize_t dvb_ringbuffer_write(stru
  * returns Number of bytes written, or -EFAULT, -ENOMEM, -EVINAL.
  */
 extern ssize_t dvb_ringbuffer_pkt_write(struct dvb_ringbuffer *rbuf, u8* buf,
-                                        size_t len);
+		                        size_t len);
 
 /**
  * Read from a packet in the ringbuffer. Note: unlike dvb_ringbuffer_read(), this
@@ -149,7 +149,7 @@ extern ssize_t dvb_ringbuffer_pkt_write(
  * returns Number of bytes read, or -EFAULT.
  */
 extern ssize_t dvb_ringbuffer_pkt_read(struct dvb_ringbuffer *rbuf, size_t idx,
-                                       int offset, u8* buf, size_t len, int usermem);
+		                       int offset, u8* buf, size_t len, int usermem);
 
 /**
  * Dispose of a packet in the ring buffer.
diff --git a/drivers/media/dvb/dvb-core/dvbdev.c b/drivers/media/dvb/dvb-core/dvbdev.c
index 477b4fa..a4aee86 100644
--- a/drivers/media/dvb/dvb-core/dvbdev.c
+++ b/drivers/media/dvb/dvb-core/dvbdev.c
@@ -47,7 +47,7 @@ static LIST_HEAD(dvb_adapter_list);
 static DECLARE_MUTEX(dvbdev_register_lock);
 
 static const char * const dnames[] = {
-        "video", "audio", "sec", "frontend", "demux", "dvr", "ca",
+	"video", "audio", "sec", "frontend", "demux", "dvr", "ca",
 	"net", "osd"
 };
 
@@ -90,15 +90,15 @@ static int dvb_device_open(struct inode 
 
 		file->private_data = dvbdev;
 		old_fops = file->f_op;
-                file->f_op = fops_get(dvbdev->fops);
-                if(file->f_op->open)
-                        err = file->f_op->open(inode,file);
-                if (err) {
-                        fops_put(file->f_op);
-                        file->f_op = fops_get(old_fops);
-                }
-                fops_put(old_fops);
-                return err;
+		file->f_op = fops_get(dvbdev->fops);
+		if(file->f_op->open)
+		        err = file->f_op->open(inode,file);
+		if (err) {
+		        fops_put(file->f_op);
+		        file->f_op = fops_get(old_fops);
+		}
+		fops_put(old_fops);
+		return err;
 	}
 	return -ENODEV;
 }
@@ -117,21 +117,21 @@ static struct cdev dvb_device_cdev = {
 
 int dvb_generic_open(struct inode *inode, struct file *file)
 {
-        struct dvb_device *dvbdev = file->private_data;
+	struct dvb_device *dvbdev = file->private_data;
 
-        if (!dvbdev)
-                return -ENODEV;
+	if (!dvbdev)
+		return -ENODEV;
 
 	if (!dvbdev->users)
-                return -EBUSY;
+		return -EBUSY;
 
 	if ((file->f_flags & O_ACCMODE) == O_RDONLY) {
-                if (!dvbdev->readers)
-		        return -EBUSY;
+		if (!dvbdev->readers)
+			return -EBUSY;
 		dvbdev->readers--;
 	} else {
-                if (!dvbdev->writers)
-		        return -EBUSY;
+		if (!dvbdev->writers)
+			return -EBUSY;
 		dvbdev->writers--;
 	}
 
@@ -143,10 +143,10 @@ EXPORT_SYMBOL(dvb_generic_open);
 
 int dvb_generic_release(struct inode *inode, struct file *file)
 {
-        struct dvb_device *dvbdev = file->private_data;
+	struct dvb_device *dvbdev = file->private_data;
 
 	if (!dvbdev)
-                return -ENODEV;
+		return -ENODEV;
 
 	if ((file->f_flags & O_ACCMODE) == O_RDONLY) {
 		dvbdev->readers++;
@@ -163,10 +163,10 @@ EXPORT_SYMBOL(dvb_generic_release);
 int dvb_generic_ioctl(struct inode *inode, struct file *file,
 		      unsigned int cmd, unsigned long arg)
 {
-        struct dvb_device *dvbdev = file->private_data;
+	struct dvb_device *dvbdev = file->private_data;
 
-        if (!dvbdev)
-	        return -ENODEV;
+	if (!dvbdev)
+		return -ENODEV;
 
 	if (!dvbdev->kernel_ioctl)
 		return -EINVAL;
@@ -334,63 +334,63 @@ EXPORT_SYMBOL(dvb_unregister_adapter);
    to the v4l "videodev.o" module, which is unnecessary for some
    cards (ie. the budget dvb-cards don't need the v4l module...) */
 int dvb_usercopy(struct inode *inode, struct file *file,
-	             unsigned int cmd, unsigned long arg,
+		     unsigned int cmd, unsigned long arg,
 		     int (*func)(struct inode *inode, struct file *file,
 		     unsigned int cmd, void *arg))
 {
-        char    sbuf[128];
-        void    *mbuf = NULL;
-        void    *parg = NULL;
-        int     err  = -EINVAL;
-
-        /*  Copy arguments into temp kernel buffer  */
-        switch (_IOC_DIR(cmd)) {
-        case _IOC_NONE:
+	char    sbuf[128];
+	void    *mbuf = NULL;
+	void    *parg = NULL;
+	int     err  = -EINVAL;
+
+	/*  Copy arguments into temp kernel buffer  */
+	switch (_IOC_DIR(cmd)) {
+	case _IOC_NONE:
 		/*
 		 * For this command, the pointer is actually an integer
 		 * argument.
 		 */
 		parg = (void *) arg;
 		break;
-        case _IOC_READ: /* some v4l ioctls are marked wrong ... */
-        case _IOC_WRITE:
-        case (_IOC_WRITE | _IOC_READ):
-                if (_IOC_SIZE(cmd) <= sizeof(sbuf)) {
-                        parg = sbuf;
-                } else {
-                        /* too big to allocate from stack */
-                        mbuf = kmalloc(_IOC_SIZE(cmd),GFP_KERNEL);
-                        if (NULL == mbuf)
-                                return -ENOMEM;
-                        parg = mbuf;
-                }
-
-                err = -EFAULT;
-                if (copy_from_user(parg, (void __user *)arg, _IOC_SIZE(cmd)))
-                        goto out;
-                break;
-        }
-
-        /* call driver */
-        if ((err = func(inode, file, cmd, parg)) == -ENOIOCTLCMD)
-                err = -EINVAL;
-
-        if (err < 0)
-                goto out;
-
-        /*  Copy results into user buffer  */
-        switch (_IOC_DIR(cmd))
-        {
-        case _IOC_READ:
-        case (_IOC_WRITE | _IOC_READ):
-                if (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))
-                        err = -EFAULT;
-                break;
-        }
+	case _IOC_READ: /* some v4l ioctls are marked wrong ... */
+	case _IOC_WRITE:
+	case (_IOC_WRITE | _IOC_READ):
+		if (_IOC_SIZE(cmd) <= sizeof(sbuf)) {
+		        parg = sbuf;
+		} else {
+		        /* too big to allocate from stack */
+		        mbuf = kmalloc(_IOC_SIZE(cmd),GFP_KERNEL);
+		        if (NULL == mbuf)
+		                return -ENOMEM;
+		        parg = mbuf;
+		}
+
+		err = -EFAULT;
+		if (copy_from_user(parg, (void __user *)arg, _IOC_SIZE(cmd)))
+		        goto out;
+		break;
+	}
+
+	/* call driver */
+	if ((err = func(inode, file, cmd, parg)) == -ENOIOCTLCMD)
+		err = -EINVAL;
+
+	if (err < 0)
+		goto out;
+
+	/*  Copy results into user buffer  */
+	switch (_IOC_DIR(cmd))
+	{
+	case _IOC_READ:
+	case (_IOC_WRITE | _IOC_READ):
+		if (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))
+		        err = -EFAULT;
+		break;
+	}
 
 out:
-        kfree(mbuf);
-        return err;
+	kfree(mbuf);
+	return err;
 }
 
 static int __init init_dvbdev(void)
@@ -427,10 +427,10 @@ error:
 
 static void __exit exit_dvbdev(void)
 {
-        devfs_remove("dvb");
+	devfs_remove("dvb");
 	class_destroy(dvb_class);
 	cdev_del(&dvb_device_cdev);
-        unregister_chrdev_region(MKDEV(DVB_MAJOR, 0), MAX_DVB_MINORS);
+	unregister_chrdev_region(MKDEV(DVB_MAJOR, 0), MAX_DVB_MINORS);
 }
 
 module_init(init_dvbdev);
diff --git a/drivers/media/dvb/dvb-core/dvbdev.h b/drivers/media/dvb/dvb-core/dvbdev.h
index a251867..0cc6e4a 100644
--- a/drivers/media/dvb/dvb-core/dvbdev.h
+++ b/drivers/media/dvb/dvb-core/dvbdev.h
@@ -68,8 +68,8 @@ struct dvb_device {
 	int writers;
 	int users;
 
-        /* don't really need those !? -- FIXME: use video_usercopy  */
-        int (*kernel_ioctl)(struct inode *inode, struct file *file,
+	/* don't really need those !? -- FIXME: use video_usercopy  */
+	int (*kernel_ioctl)(struct inode *inode, struct file *file,
 			    unsigned int cmd, void *arg);
 
 	void *priv;
@@ -97,7 +97,7 @@ we simply define out own dvb_usercopy(),
 generic_usercopy()  someday... */
 
 extern int dvb_usercopy(struct inode *inode, struct file *file,
-	                    unsigned int cmd, unsigned long arg,
+		            unsigned int cmd, unsigned long arg,
 			    int (*func)(struct inode *inode, struct file *file,
 			    unsigned int cmd, void *arg));
 
diff --git a/drivers/media/dvb/dvb-usb/vp702x-fe.c b/drivers/media/dvb/dvb-usb/vp702x-fe.c
index f20d8db..104b5d0 100644
--- a/drivers/media/dvb/dvb-usb/vp702x-fe.c
+++ b/drivers/media/dvb/dvb-usb/vp702x-fe.c
@@ -190,7 +190,7 @@ static int vp702x_fe_get_frontend(struct
 }
 
 static int vp702x_fe_send_diseqc_msg (struct dvb_frontend* fe,
-		                    struct dvb_diseqc_master_cmd *m)
+			            struct dvb_diseqc_master_cmd *m)
 {
 	struct vp702x_fe_state *st = fe->demodulator_priv;
 	u8 cmd[8],ibuf[10];
diff --git a/drivers/media/dvb/dvb-usb/vp7045-fe.c b/drivers/media/dvb/dvb-usb/vp7045-fe.c
index 2746edf..83f1de1 100644
--- a/drivers/media/dvb/dvb-usb/vp7045-fe.c
+++ b/drivers/media/dvb/dvb-usb/vp7045-fe.c
@@ -58,7 +58,7 @@ static int vp7045_fe_read_ber(struct dvb
 	struct vp7045_fe_state *state = fe->demodulator_priv;
 	*ber = (vp7045_read_reg(state->d, 0x0D) << 16) |
 	       (vp7045_read_reg(state->d, 0x0E) << 8) |
-	        vp7045_read_reg(state->d, 0x0F);
+		vp7045_read_reg(state->d, 0x0F);
 	return 0;
 }
 
diff --git a/drivers/media/dvb/frontends/at76c651.c b/drivers/media/dvb/frontends/at76c651.c
index 72a2b54..8e0f4b3 100644
--- a/drivers/media/dvb/frontends/at76c651.c
+++ b/drivers/media/dvb/frontends/at76c651.c
@@ -361,9 +361,9 @@ static int at76c651_read_ucblocks(struct
 
 static int at76c651_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings *fesettings)
 {
-        fesettings->min_delay_ms = 50;
-        fesettings->step_size = 0;
-        fesettings->max_drift = 0;
+	fesettings->min_delay_ms = 50;
+	fesettings->step_size = 0;
+	fesettings->max_drift = 0;
 	return 0;
 }
 
diff --git a/drivers/media/dvb/frontends/bcm3510.c b/drivers/media/dvb/frontends/bcm3510.c
index f6d4ee7..8ceb9a3 100644
--- a/drivers/media/dvb/frontends/bcm3510.c
+++ b/drivers/media/dvb/frontends/bcm3510.c
@@ -69,7 +69,7 @@ MODULE_PARM_DESC(debug, "set debugging l
 #define dbufout(b,l,m) {\
 	    int i; \
 	    for (i = 0; i < l; i++) \
-	        m("%02x ",b[i]); \
+		m("%02x ",b[i]); \
 }
 #define deb_info(args...) dprintk(0x01,args)
 #define deb_i2c(args...)  dprintk(0x02,args)
@@ -827,7 +827,7 @@ static struct dvb_frontend_ops bcm3510_o
 		.type = FE_ATSC,
 		.frequency_min =  54000000,
 		.frequency_max = 803000000,
-                /* stepsize is just a guess */
+		/* stepsize is just a guess */
 		.frequency_stepsize = 0,
 		.caps =
 			FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
diff --git a/drivers/media/dvb/frontends/cx22700.c b/drivers/media/dvb/frontends/cx22700.c
index 0c2ed44..755f774 100644
--- a/drivers/media/dvb/frontends/cx22700.c
+++ b/drivers/media/dvb/frontends/cx22700.c
@@ -355,10 +355,10 @@ static int cx22700_get_frontend(struct d
 
 static int cx22700_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings* fesettings)
 {
-        fesettings->min_delay_ms = 150;
-        fesettings->step_size = 166667;
-        fesettings->max_drift = 166667*2;
-        return 0;
+	fesettings->min_delay_ms = 150;
+	fesettings->step_size = 166667;
+	fesettings->max_drift = 166667*2;
+	return 0;
 }
 
 static void cx22700_release(struct dvb_frontend* fe)
@@ -407,7 +407,7 @@ static struct dvb_frontend_ops cx22700_o
 		.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
 		      FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
 		      FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 |
-	              FE_CAN_RECOVER
+		      FE_CAN_RECOVER
 	},
 
 	.release = cx22700_release,
diff --git a/drivers/media/dvb/frontends/cx22702.c b/drivers/media/dvb/frontends/cx22702.c
index d9a8ede..5de0e6d 100644
--- a/drivers/media/dvb/frontends/cx22702.c
+++ b/drivers/media/dvb/frontends/cx22702.c
@@ -2,7 +2,7 @@
     Conexant 22702 DVB OFDM demodulator driver
 
     based on:
-        Alps TDMB7 DVB OFDM demodulator driver
+	Alps TDMB7 DVB OFDM demodulator driver
 
     Copyright (C) 2001-2002 Convergence Integrated Media GmbH
 	  Holger Waechtler <holger@convergence.de>
diff --git a/drivers/media/dvb/frontends/cx22702.h b/drivers/media/dvb/frontends/cx22702.h
index 1f25088..5633976 100644
--- a/drivers/media/dvb/frontends/cx22702.h
+++ b/drivers/media/dvb/frontends/cx22702.h
@@ -2,7 +2,7 @@
     Conexant 22702 DVB OFDM demodulator driver
 
     based on:
-        Alps TDMB7 DVB OFDM demodulator driver
+	Alps TDMB7 DVB OFDM demodulator driver
 
     Copyright (C) 2001-2002 Convergence Integrated Media GmbH
 	  Holger Waechtler <holger@convergence.de>
diff --git a/drivers/media/dvb/frontends/cx24110.c b/drivers/media/dvb/frontends/cx24110.c
index 654d7dc..0c4db80 100644
--- a/drivers/media/dvb/frontends/cx24110.c
+++ b/drivers/media/dvb/frontends/cx24110.c
@@ -55,81 +55,81 @@ static int debug;
 	} while (0)
 
 static struct {u8 reg; u8 data;} cx24110_regdata[]=
-                      /* Comments beginning with @ denote this value should
-                         be the default */
-        {{0x09,0x01}, /* SoftResetAll */
-         {0x09,0x00}, /* release reset */
-         {0x01,0xe8}, /* MSB of code rate 27.5MS/s */
-         {0x02,0x17}, /* middle byte " */
-         {0x03,0x29}, /* LSB         " */
-         {0x05,0x03}, /* @ DVB mode, standard code rate 3/4 */
-         {0x06,0xa5}, /* @ PLL 60MHz */
-         {0x07,0x01}, /* @ Fclk, i.e. sampling clock, 60MHz */
-         {0x0a,0x00}, /* @ partial chip disables, do not set */
-         {0x0b,0x01}, /* set output clock in gapped mode, start signal low
-                         active for first byte */
-         {0x0c,0x11}, /* no parity bytes, large hold time, serial data out */
-         {0x0d,0x6f}, /* @ RS Sync/Unsync thresholds */
-         {0x10,0x40}, /* chip doc is misleading here: write bit 6 as 1
-                         to avoid starting the BER counter. Reset the
-                         CRC test bit. Finite counting selected */
-         {0x15,0xff}, /* @ size of the limited time window for RS BER
-                         estimation. It is <value>*256 RS blocks, this
-                         gives approx. 2.6 sec at 27.5MS/s, rate 3/4 */
-         {0x16,0x00}, /* @ enable all RS output ports */
-         {0x17,0x04}, /* @ time window allowed for the RS to sync */
-         {0x18,0xae}, /* @ allow all standard DVB code rates to be scanned
-                         for automatically */
-                      /* leave the current code rate and normalization
-                         registers as they are after reset... */
-         {0x21,0x10}, /* @ during AutoAcq, search each viterbi setting
-                         only once */
-         {0x23,0x18}, /* @ size of the limited time window for Viterbi BER
-                         estimation. It is <value>*65536 channel bits, i.e.
-                         approx. 38ms at 27.5MS/s, rate 3/4 */
-         {0x24,0x24}, /* do not trigger Viterbi CRC test. Finite count window */
-                      /* leave front-end AGC parameters at default values */
-                      /* leave decimation AGC parameters at default values */
-         {0x35,0x40}, /* disable all interrupts. They are not connected anyway */
-         {0x36,0xff}, /* clear all interrupt pending flags */
-         {0x37,0x00}, /* @ fully enable AutoAcqq state machine */
-         {0x38,0x07}, /* @ enable fade recovery, but not autostart AutoAcq */
-                      /* leave the equalizer parameters on their default values */
-                      /* leave the final AGC parameters on their default values */
-         {0x41,0x00}, /* @ MSB of front-end derotator frequency */
-         {0x42,0x00}, /* @ middle bytes " */
-         {0x43,0x00}, /* @ LSB          " */
-                      /* leave the carrier tracking loop parameters on default */
-                      /* leave the bit timing loop parameters at gefault */
-         {0x56,0x4d}, /* set the filtune voltage to 2.7V, as recommended by */
-                      /* the cx24108 data sheet for symbol rates above 15MS/s */
-         {0x57,0x00}, /* @ Filter sigma delta enabled, positive */
-         {0x61,0x95}, /* GPIO pins 1-4 have special function */
-         {0x62,0x05}, /* GPIO pin 5 has special function, pin 6 is GPIO */
-         {0x63,0x00}, /* All GPIO pins use CMOS output characteristics */
-         {0x64,0x20}, /* GPIO 6 is input, all others are outputs */
-         {0x6d,0x30}, /* tuner auto mode clock freq 62kHz */
-         {0x70,0x15}, /* use auto mode, tuner word is 21 bits long */
-         {0x73,0x00}, /* @ disable several demod bypasses */
-         {0x74,0x00}, /* @  " */
-         {0x75,0x00}  /* @  " */
-                      /* the remaining registers are for SEC */
+		      /* Comments beginning with @ denote this value should
+		         be the default */
+	{{0x09,0x01}, /* SoftResetAll */
+	 {0x09,0x00}, /* release reset */
+	 {0x01,0xe8}, /* MSB of code rate 27.5MS/s */
+	 {0x02,0x17}, /* middle byte " */
+	 {0x03,0x29}, /* LSB         " */
+	 {0x05,0x03}, /* @ DVB mode, standard code rate 3/4 */
+	 {0x06,0xa5}, /* @ PLL 60MHz */
+	 {0x07,0x01}, /* @ Fclk, i.e. sampling clock, 60MHz */
+	 {0x0a,0x00}, /* @ partial chip disables, do not set */
+	 {0x0b,0x01}, /* set output clock in gapped mode, start signal low
+		         active for first byte */
+	 {0x0c,0x11}, /* no parity bytes, large hold time, serial data out */
+	 {0x0d,0x6f}, /* @ RS Sync/Unsync thresholds */
+	 {0x10,0x40}, /* chip doc is misleading here: write bit 6 as 1
+		         to avoid starting the BER counter. Reset the
+		         CRC test bit. Finite counting selected */
+	 {0x15,0xff}, /* @ size of the limited time window for RS BER
+		         estimation. It is <value>*256 RS blocks, this
+		         gives approx. 2.6 sec at 27.5MS/s, rate 3/4 */
+	 {0x16,0x00}, /* @ enable all RS output ports */
+	 {0x17,0x04}, /* @ time window allowed for the RS to sync */
+	 {0x18,0xae}, /* @ allow all standard DVB code rates to be scanned
+		         for automatically */
+		      /* leave the current code rate and normalization
+		         registers as they are after reset... */
+	 {0x21,0x10}, /* @ during AutoAcq, search each viterbi setting
+		         only once */
+	 {0x23,0x18}, /* @ size of the limited time window for Viterbi BER
+		         estimation. It is <value>*65536 channel bits, i.e.
+		         approx. 38ms at 27.5MS/s, rate 3/4 */
+	 {0x24,0x24}, /* do not trigger Viterbi CRC test. Finite count window */
+		      /* leave front-end AGC parameters at default values */
+		      /* leave decimation AGC parameters at default values */
+	 {0x35,0x40}, /* disable all interrupts. They are not connected anyway */
+	 {0x36,0xff}, /* clear all interrupt pending flags */
+	 {0x37,0x00}, /* @ fully enable AutoAcqq state machine */
+	 {0x38,0x07}, /* @ enable fade recovery, but not autostart AutoAcq */
+		      /* leave the equalizer parameters on their default values */
+		      /* leave the final AGC parameters on their default values */
+	 {0x41,0x00}, /* @ MSB of front-end derotator frequency */
+	 {0x42,0x00}, /* @ middle bytes " */
+	 {0x43,0x00}, /* @ LSB          " */
+		      /* leave the carrier tracking loop parameters on default */
+		      /* leave the bit timing loop parameters at gefault */
+	 {0x56,0x4d}, /* set the filtune voltage to 2.7V, as recommended by */
+		      /* the cx24108 data sheet for symbol rates above 15MS/s */
+	 {0x57,0x00}, /* @ Filter sigma delta enabled, positive */
+	 {0x61,0x95}, /* GPIO pins 1-4 have special function */
+	 {0x62,0x05}, /* GPIO pin 5 has special function, pin 6 is GPIO */
+	 {0x63,0x00}, /* All GPIO pins use CMOS output characteristics */
+	 {0x64,0x20}, /* GPIO 6 is input, all others are outputs */
+	 {0x6d,0x30}, /* tuner auto mode clock freq 62kHz */
+	 {0x70,0x15}, /* use auto mode, tuner word is 21 bits long */
+	 {0x73,0x00}, /* @ disable several demod bypasses */
+	 {0x74,0x00}, /* @  " */
+	 {0x75,0x00}  /* @  " */
+		      /* the remaining registers are for SEC */
 	};
 
 
 static int cx24110_writereg (struct cx24110_state* state, int reg, int data)
 {
-        u8 buf [] = { reg, data };
+	u8 buf [] = { reg, data };
 	struct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = buf, .len = 2 };
 	int err;
 
-        if ((err = i2c_transfer(state->i2c, &msg, 1)) != 1) {
+	if ((err = i2c_transfer(state->i2c, &msg, 1)) != 1) {
 		dprintk ("%s: writereg error (err == %i, reg == 0x%02x,"
 			 " data == 0x%02x)\n", __FUNCTION__, err, reg, data);
 		return -EREMOTEIO;
 	}
 
-        return 0;
+	return 0;
 }
 
 static int cx24110_readreg (struct cx24110_state* state, u8 reg)
@@ -153,27 +153,27 @@ static int cx24110_set_inversion (struct
 
 	switch (inversion) {
 	case INVERSION_OFF:
-                cx24110_writereg(state,0x37,cx24110_readreg(state,0x37)|0x1);
-                /* AcqSpectrInvDis on. No idea why someone should want this */
-                cx24110_writereg(state,0x5,cx24110_readreg(state,0x5)&0xf7);
-                /* Initial value 0 at start of acq */
-                cx24110_writereg(state,0x22,cx24110_readreg(state,0x22)&0xef);
-                /* current value 0 */
-                /* The cx24110 manual tells us this reg is read-only.
-                   But what the heck... set it ayways */
-                break;
+		cx24110_writereg(state,0x37,cx24110_readreg(state,0x37)|0x1);
+		/* AcqSpectrInvDis on. No idea why someone should want this */
+		cx24110_writereg(state,0x5,cx24110_readreg(state,0x5)&0xf7);
+		/* Initial value 0 at start of acq */
+		cx24110_writereg(state,0x22,cx24110_readreg(state,0x22)&0xef);
+		/* current value 0 */
+		/* The cx24110 manual tells us this reg is read-only.
+		   But what the heck... set it ayways */
+		break;
 	case INVERSION_ON:
-                cx24110_writereg(state,0x37,cx24110_readreg(state,0x37)|0x1);
-                /* AcqSpectrInvDis on. No idea why someone should want this */
-                cx24110_writereg(state,0x5,cx24110_readreg(state,0x5)|0x08);
-                /* Initial value 1 at start of acq */
-                cx24110_writereg(state,0x22,cx24110_readreg(state,0x22)|0x10);
-                /* current value 1 */
-                break;
+		cx24110_writereg(state,0x37,cx24110_readreg(state,0x37)|0x1);
+		/* AcqSpectrInvDis on. No idea why someone should want this */
+		cx24110_writereg(state,0x5,cx24110_readreg(state,0x5)|0x08);
+		/* Initial value 1 at start of acq */
+		cx24110_writereg(state,0x22,cx24110_readreg(state,0x22)|0x10);
+		/* current value 1 */
+		break;
 	case INVERSION_AUTO:
-                cx24110_writereg(state,0x37,cx24110_readreg(state,0x37)&0xfe);
-                /* AcqSpectrInvDis off. Leave initial & current states as is */
-                break;
+		cx24110_writereg(state,0x37,cx24110_readreg(state,0x37)&0xfe);
+		/* AcqSpectrInvDis off. Leave initial & current states as is */
+		break;
 	default:
 		return -EINVAL;
 	}
@@ -185,18 +185,18 @@ static int cx24110_set_fec (struct cx241
 {
 /* fixme (low): error handling */
 
-        static const int rate[]={-1,1,2,3,5,7,-1};
-        static const int g1[]={-1,0x01,0x02,0x05,0x15,0x45,-1};
-        static const int g2[]={-1,0x01,0x03,0x06,0x1a,0x7a,-1};
-
-        /* Well, the AutoAcq engine of the cx24106 and 24110 automatically
-           searches all enabled viterbi rates, and can handle non-standard
-           rates as well. */
+	static const int rate[]={-1,1,2,3,5,7,-1};
+	static const int g1[]={-1,0x01,0x02,0x05,0x15,0x45,-1};
+	static const int g2[]={-1,0x01,0x03,0x06,0x1a,0x7a,-1};
+
+	/* Well, the AutoAcq engine of the cx24106 and 24110 automatically
+	   searches all enabled viterbi rates, and can handle non-standard
+	   rates as well. */
 
-        if (fec>FEC_AUTO)
-                fec=FEC_AUTO;
+	if (fec>FEC_AUTO)
+		fec=FEC_AUTO;
 
-        if (fec==FEC_AUTO) { /* (re-)establish AutoAcq behaviour */
+	if (fec==FEC_AUTO) { /* (re-)establish AutoAcq behaviour */
 		cx24110_writereg(state,0x37,cx24110_readreg(state,0x37)&0xdf);
 		/* clear AcqVitDis bit */
 		cx24110_writereg(state,0x18,0xae);
@@ -208,7 +208,7 @@ static int cx24110_set_fec (struct cx241
 		cx24110_writereg(state,0x1a,0x05); cx24110_writereg(state,0x1b,0x06);
 		/* set the puncture registers for code rate 3/4 */
 		return 0;
-        } else {
+	} else {
 		cx24110_writereg(state,0x37,cx24110_readreg(state,0x37)|0x20);
 		/* set AcqVitDis bit */
 		if(rate[fec]>0) {
@@ -219,10 +219,10 @@ static int cx24110_set_fec (struct cx241
 			cx24110_writereg(state,0x1a,g1[fec]);
 			cx24110_writereg(state,0x1b,g2[fec]);
 			/* not sure if this is the right way: I always used AutoAcq mode */
-           } else
+	   } else
 		   return -EOPNOTSUPP;
 /* fixme (low): which is the correct return code? */
-        };
+	};
 	return 0;
 }
 
@@ -245,72 +245,72 @@ static fe_code_rate_t cx24110_get_fec (s
 static int cx24110_set_symbolrate (struct cx24110_state* state, u32 srate)
 {
 /* fixme (low): add error handling */
-        u32 ratio;
-        u32 tmp, fclk, BDRI;
+	u32 ratio;
+	u32 tmp, fclk, BDRI;
 
-        static const u32 bands[]={5000000UL,15000000UL,90999000UL/2};
-        int i;
+	static const u32 bands[]={5000000UL,15000000UL,90999000UL/2};
+	int i;
 
 dprintk("cx24110 debug: entering %s(%d)\n",__FUNCTION__,srate);
-        if (srate>90999000UL/2)
-                srate=90999000UL/2;
-        if (srate<500000)
-                srate=500000;
+	if (srate>90999000UL/2)
+		srate=90999000UL/2;
+	if (srate<500000)
+		srate=500000;
 
-        for(i=0;(i<sizeof(bands)/sizeof(bands[0]))&&(srate>bands[i]);i++)
+	for(i=0;(i<sizeof(bands)/sizeof(bands[0]))&&(srate>bands[i]);i++)
 		;
-        /* first, check which sample rate is appropriate: 45, 60 80 or 90 MHz,
-           and set the PLL accordingly (R07[1:0] Fclk, R06[7:4] PLLmult,
-           R06[3:0] PLLphaseDetGain */
-        tmp=cx24110_readreg(state,0x07)&0xfc;
-        if(srate<90999000UL/4) { /* sample rate 45MHz*/
+	/* first, check which sample rate is appropriate: 45, 60 80 or 90 MHz,
+	   and set the PLL accordingly (R07[1:0] Fclk, R06[7:4] PLLmult,
+	   R06[3:0] PLLphaseDetGain */
+	tmp=cx24110_readreg(state,0x07)&0xfc;
+	if(srate<90999000UL/4) { /* sample rate 45MHz*/
 		cx24110_writereg(state,0x07,tmp);
 		cx24110_writereg(state,0x06,0x78);
 		fclk=90999000UL/2;
-        } else if(srate<60666000UL/2) { /* sample rate 60MHz */
+	} else if(srate<60666000UL/2) { /* sample rate 60MHz */
 		cx24110_writereg(state,0x07,tmp|0x1);
 		cx24110_writereg(state,0x06,0xa5);
 		fclk=60666000UL;
-        } else if(srate<80888000UL/2) { /* sample rate 80MHz */
+	} else if(srate<80888000UL/2) { /* sample rate 80MHz */
 		cx24110_writereg(state,0x07,tmp|0x2);
 		cx24110_writereg(state,0x06,0x87);
 		fclk=80888000UL;
-        } else { /* sample rate 90MHz */
+	} else { /* sample rate 90MHz */
 		cx24110_writereg(state,0x07,tmp|0x3);
 		cx24110_writereg(state,0x06,0x78);
 		fclk=90999000UL;
-        };
-        dprintk("cx24110 debug: fclk %d Hz\n",fclk);
-        /* we need to divide two integers with approx. 27 bits in 32 bit
-           arithmetic giving a 25 bit result */
-        /* the maximum dividend is 90999000/2, 0x02b6446c, this number is
-           also the most complex divisor. Hence, the dividend has,
-           assuming 32bit unsigned arithmetic, 6 clear bits on top, the
-           divisor 2 unused bits at the bottom. Also, the quotient is
-           always less than 1/2. Borrowed from VES1893.c, of course */
-
-        tmp=srate<<6;
-        BDRI=fclk>>2;
-        ratio=(tmp/BDRI);
-
-        tmp=(tmp%BDRI)<<8;
-        ratio=(ratio<<8)+(tmp/BDRI);
-
-        tmp=(tmp%BDRI)<<8;
-        ratio=(ratio<<8)+(tmp/BDRI);
-
-        tmp=(tmp%BDRI)<<1;
-        ratio=(ratio<<1)+(tmp/BDRI);
-
-        dprintk("srate= %d (range %d, up to %d)\n", srate,i,bands[i]);
-        dprintk("fclk = %d\n", fclk);
-        dprintk("ratio= %08x\n", ratio);
-
-        cx24110_writereg(state, 0x1, (ratio>>16)&0xff);
-        cx24110_writereg(state, 0x2, (ratio>>8)&0xff);
-        cx24110_writereg(state, 0x3, (ratio)&0xff);
+	};
+	dprintk("cx24110 debug: fclk %d Hz\n",fclk);
+	/* we need to divide two integers with approx. 27 bits in 32 bit
+	   arithmetic giving a 25 bit result */
+	/* the maximum dividend is 90999000/2, 0x02b6446c, this number is
+	   also the most complex divisor. Hence, the dividend has,
+	   assuming 32bit unsigned arithmetic, 6 clear bits on top, the
+	   divisor 2 unused bits at the bottom. Also, the quotient is
+	   always less than 1/2. Borrowed from VES1893.c, of course */
+
+	tmp=srate<<6;
+	BDRI=fclk>>2;
+	ratio=(tmp/BDRI);
+
+	tmp=(tmp%BDRI)<<8;
+	ratio=(ratio<<8)+(tmp/BDRI);
+
+	tmp=(tmp%BDRI)<<8;
+	ratio=(ratio<<8)+(tmp/BDRI);
+
+	tmp=(tmp%BDRI)<<1;
+	ratio=(ratio<<1)+(tmp/BDRI);
+
+	dprintk("srate= %d (range %d, up to %d)\n", srate,i,bands[i]);
+	dprintk("fclk = %d\n", fclk);
+	dprintk("ratio= %08x\n", ratio);
+
+	cx24110_writereg(state, 0x1, (ratio>>16)&0xff);
+	cx24110_writereg(state, 0x2, (ratio>>8)&0xff);
+	cx24110_writereg(state, 0x3, (ratio)&0xff);
 
-        return 0;
+	return 0;
 
 }
 
@@ -324,48 +324,48 @@ int cx24110_pll_write (struct dvb_fronte
 
 	dprintk("cx24110 debug: cx24108_write(%8.8x)\n",data);
 
-        cx24110_writereg(state,0x6d,0x30); /* auto mode at 62kHz */
-        cx24110_writereg(state,0x70,0x15); /* auto mode 21 bits */
+	cx24110_writereg(state,0x6d,0x30); /* auto mode at 62kHz */
+	cx24110_writereg(state,0x70,0x15); /* auto mode 21 bits */
 
-        /* if the auto tuner writer is still busy, clear it out */
-        while (cx24110_readreg(state,0x6d)&0x80)
+	/* if the auto tuner writer is still busy, clear it out */
+	while (cx24110_readreg(state,0x6d)&0x80)
 		cx24110_writereg(state,0x72,0);
 
-        /* write the topmost 8 bits */
-        cx24110_writereg(state,0x72,(data>>24)&0xff);
+	/* write the topmost 8 bits */
+	cx24110_writereg(state,0x72,(data>>24)&0xff);
 
-        /* wait for the send to be completed */
-        while ((cx24110_readreg(state,0x6d)&0xc0)==0x80)
+	/* wait for the send to be completed */
+	while ((cx24110_readreg(state,0x6d)&0xc0)==0x80)
 		;
 
-        /* send another 8 bytes */
-        cx24110_writereg(state,0x72,(data>>16)&0xff);
-        while ((cx24110_readreg(state,0x6d)&0xc0)==0x80)
+	/* send another 8 bytes */
+	cx24110_writereg(state,0x72,(data>>16)&0xff);
+	while ((cx24110_readreg(state,0x6d)&0xc0)==0x80)
 		;
 
-        /* and the topmost 5 bits of this byte */
-        cx24110_writereg(state,0x72,(data>>8)&0xff);
-        while ((cx24110_readreg(state,0x6d)&0xc0)==0x80)
+	/* and the topmost 5 bits of this byte */
+	cx24110_writereg(state,0x72,(data>>8)&0xff);
+	while ((cx24110_readreg(state,0x6d)&0xc0)==0x80)
 		;
 
-        /* now strobe the enable line once */
-        cx24110_writereg(state,0x6d,0x32);
-        cx24110_writereg(state,0x6d,0x30);
+	/* now strobe the enable line once */
+	cx24110_writereg(state,0x6d,0x32);
+	cx24110_writereg(state,0x6d,0x30);
 
-        return 0;
+	return 0;
 }
 
 static int cx24110_initfe(struct dvb_frontend* fe)
 {
 	struct cx24110_state *state = fe->demodulator_priv;
 /* fixme (low): error handling */
-        int i;
+	int i;
 
 	dprintk("%s: init chip\n", __FUNCTION__);
 
-        for(i=0;i<sizeof(cx24110_regdata)/sizeof(cx24110_regdata[0]);i++) {
+	for(i=0;i<sizeof(cx24110_regdata)/sizeof(cx24110_regdata[0]);i++) {
 		cx24110_writereg(state, cx24110_regdata[i].reg, cx24110_regdata[i].data);
-        };
+	};
 
 	if (state->config->pll_init) state->config->pll_init(fe);
 
diff --git a/drivers/media/dvb/frontends/l64781.c b/drivers/media/dvb/frontends/l64781.c
index 19b4bf7..1c7c912 100644
--- a/drivers/media/dvb/frontends/l64781.c
+++ b/drivers/media/dvb/frontends/l64781.c
@@ -2,7 +2,7 @@
     driver for LSI L64781 COFDM demodulator
 
     Copyright (C) 2001 Holger Waechtler for Convergence Integrated Media GmbH
-                       Marko Kohtala <marko.kohtala@luukku.com>
+		       Marko Kohtala <marko.kohtala@luukku.com>
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
@@ -433,7 +433,7 @@ static int l64781_init(struct dvb_fronte
 {
 	struct l64781_state* state = fe->demodulator_priv;
 
-        reset_and_configure (state);
+	reset_and_configure (state);
 
 	/* Power up */
 	l64781_writereg (state, 0x3e, 0xa5);
@@ -456,9 +456,9 @@ static int l64781_init(struct dvb_fronte
 	l64781_writereg (state, 0x0d, 0x8c);
 
 	/* With ppm=8000, it seems the DTR_SENSITIVITY will result in
-           value of 2 with all possible bandwidths and guard
-           intervals, which is the initial value anyway. */
-        /*l64781_writereg (state, 0x19, 0x92);*/
+	   value of 2 with all possible bandwidths and guard
+	   intervals, which is the initial value anyway. */
+	/*l64781_writereg (state, 0x19, 0x92);*/
 
 	/* Everything is two's complement, soft bit and CSI_OUT too */
 	l64781_writereg (state, 0x1e, 0x09);
@@ -477,10 +477,10 @@ static int l64781_init(struct dvb_fronte
 static int l64781_get_tune_settings(struct dvb_frontend* fe,
 				    struct dvb_frontend_tune_settings* fesettings)
 {
-        fesettings->min_delay_ms = 4000;
-        fesettings->step_size = 0;
-        fesettings->max_drift = 0;
-        return 0;
+	fesettings->min_delay_ms = 4000;
+	fesettings->step_size = 0;
+	fesettings->max_drift = 0;
+	return 0;
 }
 
 static void l64781_release(struct dvb_frontend* fe)
@@ -522,7 +522,7 @@ struct dvb_frontend* l64781_attach(const
 
 	/* The chip always responds to reads */
 	if (i2c_transfer(state->i2c, msg, 2) != 2) {
-	        dprintk("No response to read on I2C bus\n");
+		dprintk("No response to read on I2C bus\n");
 		goto error;
 	}
 
@@ -531,7 +531,7 @@ struct dvb_frontend* l64781_attach(const
 
 	/* Reading the POWER_DOWN register always returns 0 */
 	if (reg0x3e != 0) {
-	        dprintk("Device doesn't look like L64781\n");
+		dprintk("Device doesn't look like L64781\n");
 		goto error;
 	}
 
@@ -540,7 +540,7 @@ struct dvb_frontend* l64781_attach(const
 
 	/* Responds to all reads with 0 */
 	if (l64781_readreg(state, 0x1a) != 0) {
-	        dprintk("Read 1 returned unexpcted value\n");
+		dprintk("Read 1 returned unexpcted value\n");
 		goto error;
 	}
 
@@ -549,7 +549,7 @@ struct dvb_frontend* l64781_attach(const
 
 	/* Responds with register default value */
 	if (l64781_readreg(state, 0x1a) != 0xa1) {
-	        dprintk("Read 2 returned unexpcted value\n");
+		dprintk("Read 2 returned unexpcted value\n");
 		goto error;
 	}
 
diff --git a/drivers/media/dvb/frontends/l64781.h b/drivers/media/dvb/frontends/l64781.h
index 7e30fb0..947f65f 100644
--- a/drivers/media/dvb/frontends/l64781.h
+++ b/drivers/media/dvb/frontends/l64781.h
@@ -2,7 +2,7 @@
     driver for LSI L64781 COFDM demodulator
 
     Copyright (C) 2001 Holger Waechtler for Convergence Integrated Media GmbH
-                       Marko Kohtala <marko.kohtala@luukku.com>
+		       Marko Kohtala <marko.kohtala@luukku.com>
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
diff --git a/drivers/media/dvb/frontends/lgdt330x.c b/drivers/media/dvb/frontends/lgdt330x.c
index 6a33f5a..cb53018 100644
--- a/drivers/media/dvb/frontends/lgdt330x.c
+++ b/drivers/media/dvb/frontends/lgdt330x.c
@@ -301,10 +301,10 @@ static int lgdt330x_set_parameters(struc
 	static u8 lgdt3303_8vsb_44_data[] = {
 		0x04, 0x00,
 		0x0d, 0x40,
-        0x0e, 0x87,
-        0x0f, 0x8e,
-        0x10, 0x01,
-        0x47, 0x8b };
+	0x0e, 0x87,
+	0x0f, 0x8e,
+	0x10, 0x01,
+	0x47, 0x8b };
 
 	/*
 	 * Array of byte pairs <address, value>
diff --git a/drivers/media/dvb/frontends/mt312.c b/drivers/media/dvb/frontends/mt312.c
index 9c67f40..8d67228 100644
--- a/drivers/media/dvb/frontends/mt312.c
+++ b/drivers/media/dvb/frontends/mt312.c
@@ -554,7 +554,7 @@ static int mt312_set_frontend(struct dvb
 	if ((ret = mt312_write(state, SYM_RATE_H, buf, sizeof(buf))) < 0)
 		return ret;
 
-        mt312_reset(state, 0);
+	mt312_reset(state, 0);
 
 	return 0;
 }
@@ -695,7 +695,7 @@ static struct dvb_frontend_ops vp310_mt3
 		    FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 |
 		    FE_CAN_FEC_3_4 | FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 |
 		    FE_CAN_FEC_AUTO | FE_CAN_QPSK | FE_CAN_MUTE_TS |
-	            FE_CAN_RECOVER
+		    FE_CAN_RECOVER
 	},
 
 	.release = mt312_release,
diff --git a/drivers/media/dvb/frontends/nxt2002.c b/drivers/media/dvb/frontends/nxt2002.c
index 30786b1..52c4160 100644
--- a/drivers/media/dvb/frontends/nxt2002.c
+++ b/drivers/media/dvb/frontends/nxt2002.c
@@ -527,7 +527,7 @@ static int nxt2002_read_snr(struct dvb_f
 	else
 		snrdb = 1000*0 + ( 1000*(12-0) * ( temp2 - 0 ) / ( 0x7C00 - 0 ) );
 
-        /* the value reported back from the frontend will be FFFF=32db 0000=0db */
+	/* the value reported back from the frontend will be FFFF=32db 0000=0db */
 
 	*snr = snrdb * (0xFFFF/32000);
 
@@ -646,7 +646,7 @@ struct dvb_frontend* nxt2002_attach(cons
 	memcpy(&state->ops, &nxt2002_ops, sizeof(struct dvb_frontend_ops));
 	state->initialised = 0;
 
-        /* Check the first 5 registers to ensure this a revision we can handle */
+	/* Check the first 5 registers to ensure this a revision we can handle */
 
 	i2c_readbytes(state, 0x00, buf, 5);
 	if (buf[0] != 0x04) goto error;		/* device id */
@@ -672,7 +672,7 @@ static struct dvb_frontend_ops nxt2002_o
 		.type = FE_ATSC,
 		.frequency_min =  54000000,
 		.frequency_max = 860000000,
-                /* stepsize is just a guess */
+		/* stepsize is just a guess */
 		.frequency_stepsize = 166666,
 		.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
 			FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
diff --git a/drivers/media/dvb/frontends/nxt200x.c b/drivers/media/dvb/frontends/nxt200x.c
index 84b6288..aeafef4 100644
--- a/drivers/media/dvb/frontends/nxt200x.c
+++ b/drivers/media/dvb/frontends/nxt200x.c
@@ -339,7 +339,7 @@ static int nxt200x_writetuner (struct nx
 	switch (state->demod_chip) {
 		case NXT2004:
 			if (i2c_writebytes(state, state->config->pll_address, data, 4))
-	        	        printk(KERN_WARNING "nxt200x: error writing to tuner\n");
+				printk(KERN_WARNING "nxt200x: error writing to tuner\n");
 			/* wait until we have a lock */
 			while (count < 20) {
 				i2c_readbytes(state, state->config->pll_address, &buf, 1);
@@ -497,7 +497,7 @@ static int nxt2004_load_firmware (struct
 
 	/* calculate firmware CRC */
 	for (position = 0; position < fw->size; position++) {
-	        crc = nxt200x_crc(crc, fw->data[position]);
+		crc = nxt200x_crc(crc, fw->data[position]);
 	}
 
 	buf[0] = rambase >> 8;
diff --git a/drivers/media/dvb/frontends/nxt6000.c b/drivers/media/dvb/frontends/nxt6000.c
index 88a57b7..a458a3b 100644
--- a/drivers/media/dvb/frontends/nxt6000.c
+++ b/drivers/media/dvb/frontends/nxt6000.c
@@ -574,11 +574,11 @@ static struct dvb_frontend_ops nxt6000_o
 		.symbol_rate_max = 9360000,	/* FIXME */
 		.symbol_rate_tolerance = 4000,
 		.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
-	                FE_CAN_FEC_4_5 | FE_CAN_FEC_5_6 | FE_CAN_FEC_6_7 |
-	                FE_CAN_FEC_7_8 | FE_CAN_FEC_8_9 | FE_CAN_FEC_AUTO |
-	                FE_CAN_QAM_16 | FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |
-	                FE_CAN_TRANSMISSION_MODE_AUTO | FE_CAN_GUARD_INTERVAL_AUTO |
-	                FE_CAN_HIERARCHY_AUTO,
+		        FE_CAN_FEC_4_5 | FE_CAN_FEC_5_6 | FE_CAN_FEC_6_7 |
+		        FE_CAN_FEC_7_8 | FE_CAN_FEC_8_9 | FE_CAN_FEC_AUTO |
+		        FE_CAN_QAM_16 | FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |
+		        FE_CAN_TRANSMISSION_MODE_AUTO | FE_CAN_GUARD_INTERVAL_AUTO |
+		        FE_CAN_HIERARCHY_AUTO,
 	},
 
 	.release = nxt6000_release,
diff --git a/drivers/media/dvb/frontends/or51132.c b/drivers/media/dvb/frontends/or51132.c
index 78bded8..80e0f28 100644
--- a/drivers/media/dvb/frontends/or51132.c
+++ b/drivers/media/dvb/frontends/or51132.c
@@ -503,7 +503,7 @@ static int or51132_read_signal_strength(
 	rcvr_stat = rec_buf[1];
 	usK = (rcvr_stat & 0x10) ? 3 : 0;
 
-        /* The value reported back from the frontend will be FFFF=100% 0000=0% */
+	/* The value reported back from the frontend will be FFFF=100% 0000=0% */
 	signal_strength = (((8952 - i20Log10(snr_equ) - usK*100)/3+5)*65535)/1000;
 	if (signal_strength > 0xffff)
 		*strength = 0xffff;
diff --git a/drivers/media/dvb/frontends/s5h1420.c b/drivers/media/dvb/frontends/s5h1420.c
index f265418..1871509 100644
--- a/drivers/media/dvb/frontends/s5h1420.c
+++ b/drivers/media/dvb/frontends/s5h1420.c
@@ -494,7 +494,7 @@ static int s5h1420_getfreqoffset(struct 
 }
 
 static void s5h1420_setfec_inversion(struct s5h1420_state* state,
-			   	     struct dvb_frontend_parameters *p)
+				     struct dvb_frontend_parameters *p)
 {
 	u8 inversion = 0;
 
@@ -521,8 +521,8 @@ static void s5h1420_setfec_inversion(str
 
 		case FEC_3_4:
 			s5h1420_writereg(state, 0x30, 0x04);
-                        s5h1420_writereg(state, 0x31, 0x12 | inversion);
-                        break;
+		        s5h1420_writereg(state, 0x31, 0x12 | inversion);
+		        break;
 
 		case FEC_5_6:
 			s5h1420_writereg(state, 0x30, 0x08);
diff --git a/drivers/media/dvb/frontends/s5h1420.h b/drivers/media/dvb/frontends/s5h1420.h
index 872028d..73296f1 100644
--- a/drivers/media/dvb/frontends/s5h1420.h
+++ b/drivers/media/dvb/frontends/s5h1420.h
@@ -39,6 +39,6 @@ struct s5h1420_config
 };
 
 extern struct dvb_frontend* s5h1420_attach(const struct s5h1420_config* config,
-             struct i2c_adapter* i2c);
+	     struct i2c_adapter* i2c);
 
 #endif // S5H1420_H
diff --git a/drivers/media/dvb/frontends/sp8870.c b/drivers/media/dvb/frontends/sp8870.c
index 1c6b2e9..fc06cd6 100644
--- a/drivers/media/dvb/frontends/sp8870.c
+++ b/drivers/media/dvb/frontends/sp8870.c
@@ -67,16 +67,16 @@ static int debug;
 
 static int sp8870_writereg (struct sp8870_state* state, u16 reg, u16 data)
 {
-        u8 buf [] = { reg >> 8, reg & 0xff, data >> 8, data & 0xff };
+	u8 buf [] = { reg >> 8, reg & 0xff, data >> 8, data & 0xff };
 	struct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = buf, .len = 4 };
 	int err;
 
-        if ((err = i2c_transfer (state->i2c, &msg, 1)) != 1) {
+	if ((err = i2c_transfer (state->i2c, &msg, 1)) != 1) {
 		dprintk ("%s: writereg error (err == %i, reg == 0x%02x, data == 0x%02x)\n", __FUNCTION__, err, reg, data);
 		return -EREMOTEIO;
 	}
 
-        return 0;
+	return 0;
 }
 
 static int sp8870_readreg (struct sp8870_state* state, u16 reg)
@@ -305,7 +305,7 @@ static int sp8870_set_frontend_parameter
 static int sp8870_init (struct dvb_frontend* fe)
 {
 	struct sp8870_state* state = fe->demodulator_priv;
-        const struct firmware *fw = NULL;
+	const struct firmware *fw = NULL;
 
 	sp8870_wake_up(state);
 	if (state->initialised) return 0;
@@ -534,10 +534,10 @@ static int sp8870_sleep(struct dvb_front
 
 static int sp8870_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings* fesettings)
 {
-        fesettings->min_delay_ms = 350;
-        fesettings->step_size = 0;
-        fesettings->max_drift = 0;
-        return 0;
+	fesettings->min_delay_ms = 350;
+	fesettings->step_size = 0;
+	fesettings->max_drift = 0;
+	return 0;
 }
 
 static void sp8870_release(struct dvb_frontend* fe)
diff --git a/drivers/media/dvb/frontends/sp887x.c b/drivers/media/dvb/frontends/sp887x.c
index 73384e7..e3b6657 100644
--- a/drivers/media/dvb/frontends/sp887x.c
+++ b/drivers/media/dvb/frontends/sp887x.c
@@ -80,7 +80,7 @@ static int sp887x_readreg (struct sp887x
 	u8 b1 [2];
 	int ret;
 	struct i2c_msg msg[] = {{ .addr = state->config->demod_address, .flags = 0, .buf = b0, .len = 2 },
-		         { .addr = state->config->demod_address, .flags = I2C_M_RD, .buf = b1, .len = 2 }};
+			 { .addr = state->config->demod_address, .flags = I2C_M_RD, .buf = b1, .len = 2 }};
 
 	if ((ret = i2c_transfer(state->i2c, msg, 2)) != 2) {
 		printk("%s: readreg error (ret == %i)\n", __FUNCTION__, ret);
@@ -498,7 +498,7 @@ static int sp887x_sleep(struct dvb_front
 static int sp887x_init(struct dvb_frontend* fe)
 {
 	struct sp887x_state* state = fe->demodulator_priv;
-        const struct firmware *fw = NULL;
+	const struct firmware *fw = NULL;
 	int ret;
 
 	if (!state->initialised) {
@@ -528,10 +528,10 @@ static int sp887x_init(struct dvb_fronte
 
 static int sp887x_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings* fesettings)
 {
-        fesettings->min_delay_ms = 350;
-        fesettings->step_size = 166666*2;
-        fesettings->max_drift = (166666*2)+1;
-        return 0;
+	fesettings->min_delay_ms = 350;
+	fesettings->step_size = 166666*2;
+	fesettings->max_drift = (166666*2)+1;
+	return 0;
 }
 
 static void sp887x_release(struct dvb_frontend* fe)
@@ -581,7 +581,7 @@ static struct dvb_frontend_ops sp887x_op
 		.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
 			FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
 			FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 |
-	                FE_CAN_RECOVER
+		        FE_CAN_RECOVER
 	},
 
 	.release = sp887x_release,
diff --git a/drivers/media/dvb/frontends/stv0299.c b/drivers/media/dvb/frontends/stv0299.c
index 29c4866..177d71d 100644
--- a/drivers/media/dvb/frontends/stv0299.c
+++ b/drivers/media/dvb/frontends/stv0299.c
@@ -95,7 +95,7 @@ static int stv0299_writeregI (struct stv
 
 int stv0299_writereg (struct dvb_frontend* fe, u8 reg, u8 data)
 {
-        struct stv0299_state* state = fe->demodulator_priv;
+	struct stv0299_state* state = fe->demodulator_priv;
 
 	return stv0299_writeregI(state, reg, data);
 }
@@ -220,7 +220,7 @@ static int stv0299_wait_diseqc_idle (str
 
 static int stv0299_set_symbolrate (struct dvb_frontend* fe, u32 srate)
 {
-        struct stv0299_state* state = fe->demodulator_priv;
+	struct stv0299_state* state = fe->demodulator_priv;
 	u64 big = srate;
 	u32 ratio;
 
@@ -271,7 +271,7 @@ static int stv0299_get_symbolrate (struc
 static int stv0299_send_diseqc_msg (struct dvb_frontend* fe,
 				    struct dvb_diseqc_master_cmd *m)
 {
-        struct stv0299_state* state = fe->demodulator_priv;
+	struct stv0299_state* state = fe->demodulator_priv;
 	u8 val;
 	int i;
 
@@ -301,7 +301,7 @@ static int stv0299_send_diseqc_msg (stru
 
 static int stv0299_send_diseqc_burst (struct dvb_frontend* fe, fe_sec_mini_cmd_t burst)
 {
-        struct stv0299_state* state = fe->demodulator_priv;
+	struct stv0299_state* state = fe->demodulator_priv;
 	u8 val;
 
 	dprintk ("%s\n", __FUNCTION__);
@@ -328,7 +328,7 @@ static int stv0299_send_diseqc_burst (st
 
 static int stv0299_set_tone (struct dvb_frontend* fe, fe_sec_tone_mode_t tone)
 {
-        struct stv0299_state* state = fe->demodulator_priv;
+	struct stv0299_state* state = fe->demodulator_priv;
 	u8 val;
 
 	if (stv0299_wait_diseqc_idle (state, 100) < 0)
@@ -350,7 +350,7 @@ static int stv0299_set_tone (struct dvb_
 
 static int stv0299_set_voltage (struct dvb_frontend* fe, fe_sec_voltage_t voltage)
 {
-        struct stv0299_state* state = fe->demodulator_priv;
+	struct stv0299_state* state = fe->demodulator_priv;
 	u8 reg0x08;
 	u8 reg0x0c;
 
@@ -442,7 +442,7 @@ static int stv0299_send_legacy_dish_cmd 
 
 static int stv0299_init (struct dvb_frontend* fe)
 {
-        struct stv0299_state* state = fe->demodulator_priv;
+	struct stv0299_state* state = fe->demodulator_priv;
 	int i;
 
 	dprintk("stv0299: init chip\n");
@@ -461,7 +461,7 @@ static int stv0299_init (struct dvb_fron
 
 static int stv0299_read_status(struct dvb_frontend* fe, fe_status_t* status)
 {
-        struct stv0299_state* state = fe->demodulator_priv;
+	struct stv0299_state* state = fe->demodulator_priv;
 
 	u8 signal = 0xff - stv0299_readreg (state, 0x18);
 	u8 sync = stv0299_readreg (state, 0x1b);
@@ -489,7 +489,7 @@ static int stv0299_read_status(struct dv
 
 static int stv0299_read_ber(struct dvb_frontend* fe, u32* ber)
 {
-        struct stv0299_state* state = fe->demodulator_priv;
+	struct stv0299_state* state = fe->demodulator_priv;
 
 	if (state->errmode != STATUS_BER) return 0;
 	*ber = (stv0299_readreg (state, 0x1d) << 8) | stv0299_readreg (state, 0x1e);
@@ -499,7 +499,7 @@ static int stv0299_read_ber(struct dvb_f
 
 static int stv0299_read_signal_strength(struct dvb_frontend* fe, u16* strength)
 {
-        struct stv0299_state* state = fe->demodulator_priv;
+	struct stv0299_state* state = fe->demodulator_priv;
 
 	s32 signal =  0xffff - ((stv0299_readreg (state, 0x18) << 8)
 			       | stv0299_readreg (state, 0x19));
@@ -516,7 +516,7 @@ static int stv0299_read_signal_strength(
 
 static int stv0299_read_snr(struct dvb_frontend* fe, u16* snr)
 {
-        struct stv0299_state* state = fe->demodulator_priv;
+	struct stv0299_state* state = fe->demodulator_priv;
 
 	s32 xsnr = 0xffff - ((stv0299_readreg (state, 0x24) << 8)
 			   | stv0299_readreg (state, 0x25));
@@ -528,7 +528,7 @@ static int stv0299_read_snr(struct dvb_f
 
 static int stv0299_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)
 {
-        struct stv0299_state* state = fe->demodulator_priv;
+	struct stv0299_state* state = fe->demodulator_priv;
 
 	if (state->errmode != STATUS_UCBLOCKS) *ucblocks = 0;
 	else *ucblocks = (stv0299_readreg (state, 0x1d) << 8) | stv0299_readreg (state, 0x1e);
@@ -538,7 +538,7 @@ static int stv0299_read_ucblocks(struct 
 
 static int stv0299_set_frontend(struct dvb_frontend* fe, struct dvb_frontend_parameters * p)
 {
-        struct stv0299_state* state = fe->demodulator_priv;
+	struct stv0299_state* state = fe->demodulator_priv;
 	int invval = 0;
 
 	dprintk ("%s : FE_SET_FRONTEND\n", __FUNCTION__);
@@ -571,7 +571,7 @@ static int stv0299_set_frontend(struct d
 
 static int stv0299_get_frontend(struct dvb_frontend* fe, struct dvb_frontend_parameters * p)
 {
-        struct stv0299_state* state = fe->demodulator_priv;
+	struct stv0299_state* state = fe->demodulator_priv;
 	s32 derot_freq;
 	int invval;
 
@@ -596,7 +596,7 @@ static int stv0299_get_frontend(struct d
 
 static int stv0299_sleep(struct dvb_frontend* fe)
 {
-        struct stv0299_state* state = fe->demodulator_priv;
+	struct stv0299_state* state = fe->demodulator_priv;
 
 	stv0299_writeregI(state, 0x02, 0x80);
 	state->initialised = 0;
@@ -606,7 +606,7 @@ static int stv0299_sleep(struct dvb_fron
 
 static int stv0299_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings* fesettings)
 {
-        struct stv0299_state* state = fe->demodulator_priv;
+	struct stv0299_state* state = fe->demodulator_priv;
 
 	fesettings->min_delay_ms = state->config->min_delay_ms;
 	if (fesettings->parameters.u.qpsk.symbol_rate < 10000000) {
@@ -658,7 +658,7 @@ struct dvb_frontend* stv0299_attach(cons
 
 	/* create dvb_frontend */
 	state->frontend.ops = &state->ops;
-        state->frontend.demodulator_priv = state;
+	state->frontend.demodulator_priv = state;
 	return &state->frontend;
 
 error:
@@ -714,7 +714,7 @@ MODULE_PARM_DESC(debug, "Turn on/off fro
 
 MODULE_DESCRIPTION("ST STV0299 DVB Demodulator driver");
 MODULE_AUTHOR("Ralph Metzler, Holger Waechtler, Peter Schildmann, Felix Domke, "
-              "Andreas Oberritter, Andrew de Quincey, Kenneth Aafly");
+	      "Andreas Oberritter, Andrew de Quincey, Kenneth Aafly");
 MODULE_LICENSE("GPL");
 
 EXPORT_SYMBOL(stv0299_writereg);
diff --git a/drivers/media/dvb/frontends/tda10021.c b/drivers/media/dvb/frontends/tda10021.c
index eaf130e..425cd19 100644
--- a/drivers/media/dvb/frontends/tda10021.c
+++ b/drivers/media/dvb/frontends/tda10021.c
@@ -1,10 +1,10 @@
 /*
     TDA10021  - Single Chip Cable Channel Receiver driver module
-               used on the the Siemens DVB-C cards
+	       used on the the Siemens DVB-C cards
 
     Copyright (C) 1999 Convergence Integrated Media GmbH <ralph@convergence.de>
     Copyright (C) 2004 Markus Schulz <msc@antzsystem.de>
-                   Support for TDA10021
+		   Support for TDA10021
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
@@ -76,9 +76,9 @@ static u8 tda10021_inittab[0x40]=
 
 static int tda10021_writereg (struct tda10021_state* state, u8 reg, u8 data)
 {
-        u8 buf[] = { reg, data };
+	u8 buf[] = { reg, data };
 	struct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = buf, .len = 2 };
-        int ret;
+	int ret;
 
 	ret = i2c_transfer (state->i2c, &msg, 1);
 	if (ret != 1)
@@ -95,7 +95,7 @@ static u8 tda10021_readreg (struct tda10
 	u8 b0 [] = { reg };
 	u8 b1 [] = { 0 };
 	struct i2c_msg msg [] = { { .addr = state->config->demod_address, .flags = 0, .buf = b0, .len = 1 },
-	                          { .addr = state->config->demod_address, .flags = I2C_M_RD, .buf = b1, .len = 1 } };
+		                  { .addr = state->config->demod_address, .flags = I2C_M_RD, .buf = b1, .len = 1 } };
 	int ret;
 
 	ret = i2c_transfer (state->i2c, msg, 2);
diff --git a/drivers/media/dvb/frontends/tda10021.h b/drivers/media/dvb/frontends/tda10021.h
index 7d6a51c..53be939 100644
--- a/drivers/media/dvb/frontends/tda10021.h
+++ b/drivers/media/dvb/frontends/tda10021.h
@@ -1,10 +1,10 @@
 /*
     TDA10021  - Single Chip Cable Channel Receiver driver module
-               used on the the Siemens DVB-C cards
+	       used on the the Siemens DVB-C cards
 
     Copyright (C) 1999 Convergence Integrated Media GmbH <ralph@convergence.de>
     Copyright (C) 2004 Markus Schulz <msc@antzsystem.de>
-                   Support for TDA10021
+		   Support for TDA10021
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
diff --git a/drivers/media/dvb/frontends/tda1004x.c b/drivers/media/dvb/frontends/tda1004x.c
index 7968743..dd02aff 100644
--- a/drivers/media/dvb/frontends/tda1004x.c
+++ b/drivers/media/dvb/frontends/tda1004x.c
@@ -475,7 +475,7 @@ static int tda10046_fwupload(struct dvb_
 		ret = state->config->request_firmware(fe, &fw, TDA10046_DEFAULT_FIRMWARE);
 		if (ret) {
 			printk(KERN_ERR "tda1004x: no firmware upload (timeout or file not found?)\n");
-   	   		return ret;
+			return ret;
 		}
 		tda1004x_write_mask(state, TDA1004X_CONFC4, 8, 8); // going to boot from HOST
 		ret = tda1004x_do_upload(state, fw->data, fw->size, TDA10046H_CODE_CPT, TDA10046H_CODE_IN);
diff --git a/drivers/media/dvb/frontends/tda8083.c b/drivers/media/dvb/frontends/tda8083.c
index c05cf18..91baa9c 100644
--- a/drivers/media/dvb/frontends/tda8083.c
+++ b/drivers/media/dvb/frontends/tda8083.c
@@ -66,13 +66,13 @@ static int tda8083_writereg (struct tda8
 	u8 buf [] = { reg, data };
 	struct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = buf, .len = 2 };
 
-        ret = i2c_transfer(state->i2c, &msg, 1);
+	ret = i2c_transfer(state->i2c, &msg, 1);
 
-        if (ret != 1)
-                dprintk ("%s: writereg error (reg %02x, ret == %i)\n",
+	if (ret != 1)
+		dprintk ("%s: writereg error (reg %02x, ret == %i)\n",
 			__FUNCTION__, reg, ret);
 
-        return (ret != 1) ? -1 : 0;
+	return (ret != 1) ? -1 : 0;
 }
 
 static int tda8083_readregs (struct tda8083_state* state, u8 reg1, u8 *b, u8 len)
@@ -87,7 +87,7 @@ static int tda8083_readregs (struct tda8
 		dprintk ("%s: readreg error (reg %02x, ret == %i)\n",
 			__FUNCTION__, reg1, ret);
 
-        return ret == 2 ? 0 : -1;
+	return ret == 2 ? 0 : -1;
 }
 
 static inline u8 tda8083_readreg (struct tda8083_state* state, u8 reg)
@@ -132,14 +132,14 @@ static fe_code_rate_t tda8083_get_fec (s
 
 static int tda8083_set_symbolrate (struct tda8083_state* state, u32 srate)
 {
-        u32 ratio;
+	u32 ratio;
 	u32 tmp;
 	u8 filter;
 
 	if (srate > 32000000)
-                srate = 32000000;
-        if (srate < 500000)
-                srate = 500000;
+		srate = 32000000;
+	if (srate < 500000)
+		srate = 500000;
 
 	filter = 0;
 	if (srate < 24000000)
@@ -174,7 +174,7 @@ static void tda8083_wait_diseqc_fifo (st
 	unsigned long start = jiffies;
 
 	while (jiffies - start < timeout &&
-               !(tda8083_readreg(state, 0x02) & 0x80))
+	       !(tda8083_readreg(state, 0x02) & 0x80))
 	{
 		msleep(50);
 	};
diff --git a/drivers/media/dvb/ttpci/av7110.c b/drivers/media/dvb/ttpci/av7110.c
index 87ea527..992be0b 100644
--- a/drivers/media/dvb/ttpci/av7110.c
+++ b/drivers/media/dvb/ttpci/av7110.c
@@ -217,10 +217,10 @@ static int arm_thread(void *data)
 
 	dprintk(4, "%p\n",av7110);
 
-        lock_kernel();
-        daemonize("arm_mon");
-        sigfillset(&current->blocked);
-        unlock_kernel();
+	lock_kernel();
+	daemonize("arm_mon");
+	sigfillset(&current->blocked);
+	unlock_kernel();
 
 	av7110->arm_thread = current;
 
@@ -1535,7 +1535,7 @@ static int alps_bsrv2_pll_set(struct dvb
 	buf[2] = ((div & 0x18000) >> 10) | 0x95;
 	buf[3] = (pwr << 6) | 0x30;
 
-        // NOTE: since we're using a prescaler of 2, we set the
+	// NOTE: since we're using a prescaler of 2, we set the
 	// divisor frequency to 62.5kHz and divide by 125 above
 
 	if (i2c_transfer (&av7110->i2c_adap, &msg, 1) != 1)
@@ -1811,7 +1811,7 @@ static struct tda8083_config grundig_295
 static int philips_cd1516_pll_set(struct dvb_frontend* fe,
 				  struct dvb_frontend_parameters* params)
 {
-        struct av7110* av7110 = fe->dvb->priv;
+	struct av7110* av7110 = fe->dvb->priv;
 	u32 div;
 	u32 f = params->frequency;
 	u8 data[4];
@@ -2202,7 +2202,7 @@ static u8 read_pwm(struct av7110* av7110
 	struct i2c_msg msg[] = { { .addr = 0x50,.flags = 0,.buf = &b,.len = 1 },
 				 { .addr = 0x50,.flags = I2C_M_RD,.buf = &pwm,.len = 1} };
 
-        if ((i2c_transfer(&av7110->i2c_adap, msg, 2) != 2) || (pwm == 0xff))
+	if ((i2c_transfer(&av7110->i2c_adap, msg, 2) != 2) || (pwm == 0xff))
 		pwm = 0x48;
 
 	return pwm;
@@ -2245,7 +2245,7 @@ static int frontend_init(struct av7110 *
 			}
 
 			// Try the grundig 29504-451
-                        av7110->fe = tda8083_attach(&grundig_29504_451_config, &av7110->i2c_adap);
+		        av7110->fe = tda8083_attach(&grundig_29504_451_config, &av7110->i2c_adap);
 			if (av7110->fe) {
 				av7110->fe->ops->diseqc_send_master_cmd = av7110_diseqc_send_master_cmd;
 				av7110->fe->ops->diseqc_send_burst = av7110_diseqc_send_burst;
@@ -2271,12 +2271,12 @@ static int frontend_init(struct av7110 *
 		case 0x0001: // Hauppauge/TT Nexus-T premium rev1.X
 
 			// ALPS TDLB7
-                        av7110->fe = sp8870_attach(&alps_tdlb7_config, &av7110->i2c_adap);
+		        av7110->fe = sp8870_attach(&alps_tdlb7_config, &av7110->i2c_adap);
 			break;
 
 		case 0x0002: // Hauppauge/TT DVB-C premium rev2.X
 
-                        av7110->fe = ves1820_attach(&alps_tdbe2_config, &av7110->i2c_adap, read_pwm(av7110));
+		        av7110->fe = ves1820_attach(&alps_tdbe2_config, &av7110->i2c_adap, read_pwm(av7110));
 			break;
 
 		case 0x0006: /* Fujitsu-Siemens DVB-S rev 1.6 */
@@ -2421,9 +2421,9 @@ static int av7110_attach(struct saa7146_
 
 	dprintk(4, "dev: %p\n", dev);
 
-        /* Set RPS_IRQ to 1 to track rps1 activity.
-         * Enabling this won't send any interrupt to PC CPU.
-         */
+	/* Set RPS_IRQ to 1 to track rps1 activity.
+	 * Enabling this won't send any interrupt to PC CPU.
+	 */
 #define RPS_IRQ 0
 
 	if (budgetpatch == 1) {
diff --git a/drivers/media/dvb/ttpci/av7110_hw.c b/drivers/media/dvb/ttpci/av7110_hw.c
index 7442f56..87106e8 100644
--- a/drivers/media/dvb/ttpci/av7110_hw.c
+++ b/drivers/media/dvb/ttpci/av7110_hw.c
@@ -1203,15 +1203,15 @@ int av7110_osd_cmd(struct av7110 *av7110
 
 int av7110_osd_capability(struct av7110 *av7110, osd_cap_t *cap)
 {
-        switch (cap->cmd) {
-        case OSD_CAP_MEMSIZE:
-                if (FW_4M_SDRAM(av7110->arm_app))
-                        cap->val = 1000000;
-                else
-                        cap->val = 92000;
-                return 0;
-        default:
-                return -EINVAL;
-        }
+	switch (cap->cmd) {
+	case OSD_CAP_MEMSIZE:
+		if (FW_4M_SDRAM(av7110->arm_app))
+		        cap->val = 1000000;
+		else
+		        cap->val = 92000;
+		return 0;
+	default:
+		return -EINVAL;
+	}
 }
 #endif /* CONFIG_DVB_AV7110_OSD */
diff --git a/drivers/media/dvb/ttpci/av7110_v4l.c b/drivers/media/dvb/ttpci/av7110_v4l.c
index 6af74f7..b5aea41 100644
--- a/drivers/media/dvb/ttpci/av7110_v4l.c
+++ b/drivers/media/dvb/ttpci/av7110_v4l.c
@@ -120,8 +120,8 @@ static int ves1820_writereg(struct saa71
 
 static int stv0297_writereg(struct saa7146_dev *dev, u8 addr, u8 reg, u8 data)
 {
-        u8 buf [] = { reg, data };
-        struct i2c_msg msg = { .addr = addr, .flags = 0, .buf = buf, .len = 2 };
+	u8 buf [] = { reg, data };
+	struct i2c_msg msg = { .addr = addr, .flags = 0, .buf = buf, .len = 2 };
 
 	if (1 != saa7146_i2c_transfer(dev, &msg, 1, 1))
 		return -1;
diff --git a/drivers/media/dvb/ttpci/budget-core.c b/drivers/media/dvb/ttpci/budget-core.c
index 0498a05..017fcbc 100644
--- a/drivers/media/dvb/ttpci/budget-core.c
+++ b/drivers/media/dvb/ttpci/budget-core.c
@@ -87,7 +87,7 @@ static int start_ts_capture(struct budge
 	 *      Pitch: 188, NumBytes3: 188, NumLines3: 1024
 	 */
 
-        switch(budget->card->type) {
+	switch(budget->card->type) {
 	case BUDGET_FS_ACTIVY:
 		saa7146_write(dev, DD1_INIT, 0x04000000);
 		saa7146_write(dev, MC2, (MASK_09 | MASK_25));
diff --git a/drivers/media/dvb/ttpci/budget-patch.c b/drivers/media/dvb/ttpci/budget-patch.c
index 755df81..fc416cf 100644
--- a/drivers/media/dvb/ttpci/budget-patch.c
+++ b/drivers/media/dvb/ttpci/budget-patch.c
@@ -45,11 +45,11 @@ MAKE_BUDGET_INFO(ttbp, "TT-Budget/Patch 
 //MAKE_BUDGET_INFO(satel,"TT-Budget/Patch SATELCO PCI", BUDGET_TT_HW_DISEQC);
 
 static struct pci_device_id pci_tbl[] = {
-        MAKE_EXTENSION_PCI(ttbp,0x13c2, 0x0000),
+	MAKE_EXTENSION_PCI(ttbp,0x13c2, 0x0000),
 //        MAKE_EXTENSION_PCI(satel, 0x13c2, 0x1013),
-        {
-                .vendor    = 0,
-        }
+	{
+		.vendor    = 0,
+	}
 };
 
 /* those lines are for budget-patch to be tried
@@ -165,57 +165,57 @@ static int budget_diseqc_send_burst(stru
 
 static int budget_av7110_send_fw_cmd(struct budget_patch *budget, u16* buf, int length)
 {
-        int i;
+	int i;
 
-        dprintk(2, "budget: %p\n", budget);
+	dprintk(2, "budget: %p\n", budget);
 
-        for (i = 2; i < length; i++)
-        {
-                  ttpci_budget_debiwrite(budget, DEBINOSWAP, COMMAND + 2*i, 2, (u32) buf[i], 0,0);
-                  msleep(5);
-        }
-        if (length)
-                  ttpci_budget_debiwrite(budget, DEBINOSWAP, COMMAND + 2, 2, (u32) buf[1], 0,0);
-        else
-                  ttpci_budget_debiwrite(budget, DEBINOSWAP, COMMAND + 2, 2, 0, 0,0);
-        msleep(5);
-        ttpci_budget_debiwrite(budget, DEBINOSWAP, COMMAND, 2, (u32) buf[0], 0,0);
-        msleep(5);
-        return 0;
+	for (i = 2; i < length; i++)
+	{
+		  ttpci_budget_debiwrite(budget, DEBINOSWAP, COMMAND + 2*i, 2, (u32) buf[i], 0,0);
+		  msleep(5);
+	}
+	if (length)
+		  ttpci_budget_debiwrite(budget, DEBINOSWAP, COMMAND + 2, 2, (u32) buf[1], 0,0);
+	else
+		  ttpci_budget_debiwrite(budget, DEBINOSWAP, COMMAND + 2, 2, 0, 0,0);
+	msleep(5);
+	ttpci_budget_debiwrite(budget, DEBINOSWAP, COMMAND, 2, (u32) buf[0], 0,0);
+	msleep(5);
+	return 0;
 }
 
 static void av7110_set22k(struct budget_patch *budget, int state)
 {
-        u16 buf[2] = {( COMTYPE_AUDIODAC << 8) | (state ? ON22K : OFF22K), 0};
+	u16 buf[2] = {( COMTYPE_AUDIODAC << 8) | (state ? ON22K : OFF22K), 0};
 
-        dprintk(2, "budget: %p\n", budget);
-        budget_av7110_send_fw_cmd(budget, buf, 2);
+	dprintk(2, "budget: %p\n", budget);
+	budget_av7110_send_fw_cmd(budget, buf, 2);
 }
 
 static int av7110_send_diseqc_msg(struct budget_patch *budget, int len, u8 *msg, int burst)
 {
-        int i;
-        u16 buf[18] = { ((COMTYPE_AUDIODAC << 8) | SendDiSEqC),
-                16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+	int i;
+	u16 buf[18] = { ((COMTYPE_AUDIODAC << 8) | SendDiSEqC),
+		16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 
-        dprintk(2, "budget: %p\n", budget);
+	dprintk(2, "budget: %p\n", budget);
 
-        if (len>10)
-                len=10;
+	if (len>10)
+		len=10;
 
-        buf[1] = len+2;
-        buf[2] = len;
+	buf[1] = len+2;
+	buf[2] = len;
 
-        if (burst != -1)
-                buf[3]=burst ? 0x01 : 0x00;
-        else
-                buf[3]=0xffff;
+	if (burst != -1)
+		buf[3]=burst ? 0x01 : 0x00;
+	else
+		buf[3]=0xffff;
 
-        for (i=0; i<len; i++)
-                buf[i+4]=msg[i];
+	for (i=0; i<len; i++)
+		buf[i+4]=msg[i];
 
-        budget_av7110_send_fw_cmd(budget, buf, 18);
-        return 0;
+	budget_av7110_send_fw_cmd(budget, buf, 18);
+	return 0;
 }
 
 static int budget_patch_set_tone(struct dvb_frontend* fe, fe_sec_tone_mode_t tone)
@@ -276,7 +276,7 @@ static int alps_bsrv2_pll_set(struct dvb
 	buf[2] = ((div & 0x18000) >> 10) | 0x95;
 	buf[3] = (pwr << 6) | 0x30;
 
-        // NOTE: since we're using a prescaler of 2, we set the
+	// NOTE: since we're using a prescaler of 2, we set the
 	// divisor frequency to 62.5kHz and divide by 125 above
 
 	if (i2c_transfer (&budget->i2c_adap, &msg, 1) != 1) return -EIO;
@@ -294,7 +294,7 @@ static u8 alps_bsru6_inittab[] = {
 	0x01, 0x15,
 	0x02, 0x00,
 	0x03, 0x00,
-        0x04, 0x7d,   /* F22FR = 0x7d, F22 = f_VCO / 128 / 0x7d = 22 kHz */
+	0x04, 0x7d,   /* F22FR = 0x7d, F22 = f_VCO / 128 / 0x7d = 22 kHz */
 	0x05, 0x35,   /* I2CT = 0, SCLT = 1, SDAT = 1 */
 	0x06, 0x40,   /* DAC not used, set to high impendance mode */
 	0x07, 0x00,   /* DAC LSB */
@@ -413,7 +413,7 @@ static void frontend_init(struct budget_
 {
 	switch(budget->dev->pci->subsystem_device) {
 	case 0x0000: // Hauppauge/TT WinTV DVB-S rev1.X
-        case 0x1013: // SATELCO Multimedia PCI
+	case 0x1013: // SATELCO Multimedia PCI
 
 		// try the ALPS BSRV2 first of all
 		budget->dvb_frontend = ves1x93_attach(&alps_bsrv2_config, &budget->i2c_adap);
@@ -463,8 +463,8 @@ static void frontend_init(struct budget_
 /* written by Emard */
 static int budget_patch_attach (struct saa7146_dev* dev, struct saa7146_pci_extension_data *info)
 {
-        struct budget_patch *budget;
-        int err;
+	struct budget_patch *budget;
+	int err;
 	int count = 0;
 	int detected = 0;
 
@@ -472,12 +472,12 @@ static int budget_patch_attach (struct s
 #define RPS_IRQ 0
 #define HPS_SETUP 0
 #if PATCH_RESET
-        saa7146_write(dev, MC1, MASK_31);
-        msleep(40);
+	saa7146_write(dev, MC1, MASK_31);
+	msleep(40);
 #endif
 #if HPS_SETUP
-        // initialize registers. Better to have it like this
-        // than leaving something unconfigured
+	// initialize registers. Better to have it like this
+	// than leaving something unconfigured
 	saa7146_write(dev, DD1_STREAM_B, 0);
 	// port B VSYNC at rising edge
 	saa7146_write(dev, DD1_INIT, 0x00000200);  // have this in budget-core too!
@@ -486,29 +486,29 @@ static int budget_patch_attach (struct s
 	// debi config
 	// saa7146_write(dev, DEBI_CONFIG, MASK_30|MASK_28|MASK_18);
 
-        // zero all HPS registers
-        saa7146_write(dev, HPS_H_PRESCALE, 0);                  // r68
-        saa7146_write(dev, HPS_H_SCALE, 0);                     // r6c
-        saa7146_write(dev, BCS_CTRL, 0);                        // r70
-        saa7146_write(dev, HPS_V_SCALE, 0);                     // r60
-        saa7146_write(dev, HPS_V_GAIN, 0);                      // r64
-        saa7146_write(dev, CHROMA_KEY_RANGE, 0);                // r74
-        saa7146_write(dev, CLIP_FORMAT_CTRL, 0);                // r78
-        // Set HPS prescaler for port B input
-        saa7146_write(dev, HPS_CTRL, (1<<30) | (0<<29) | (1<<28) | (0<<12) );
-        saa7146_write(dev, MC2,
-          0 * (MASK_08 | MASK_24)  |   // BRS control
-          0 * (MASK_09 | MASK_25)  |   // a
-          0 * (MASK_10 | MASK_26)  |   // b
-          1 * (MASK_06 | MASK_22)  |   // HPS_CTRL1
-          1 * (MASK_05 | MASK_21)  |   // HPS_CTRL2
-          0 * (MASK_01 | MASK_15)      // DEBI
-           );
+	// zero all HPS registers
+	saa7146_write(dev, HPS_H_PRESCALE, 0);                  // r68
+	saa7146_write(dev, HPS_H_SCALE, 0);                     // r6c
+	saa7146_write(dev, BCS_CTRL, 0);                        // r70
+	saa7146_write(dev, HPS_V_SCALE, 0);                     // r60
+	saa7146_write(dev, HPS_V_GAIN, 0);                      // r64
+	saa7146_write(dev, CHROMA_KEY_RANGE, 0);                // r74
+	saa7146_write(dev, CLIP_FORMAT_CTRL, 0);                // r78
+	// Set HPS prescaler for port B input
+	saa7146_write(dev, HPS_CTRL, (1<<30) | (0<<29) | (1<<28) | (0<<12) );
+	saa7146_write(dev, MC2,
+	  0 * (MASK_08 | MASK_24)  |   // BRS control
+	  0 * (MASK_09 | MASK_25)  |   // a
+	  0 * (MASK_10 | MASK_26)  |   // b
+	  1 * (MASK_06 | MASK_22)  |   // HPS_CTRL1
+	  1 * (MASK_05 | MASK_21)  |   // HPS_CTRL2
+	  0 * (MASK_01 | MASK_15)      // DEBI
+	   );
 #endif
 	// Disable RPS1 and RPS0
-        saa7146_write(dev, MC1, ( MASK_29 | MASK_28));
-        // RPS1 timeout disable
-        saa7146_write(dev, RPS_TOV1, 0);
+	saa7146_write(dev, MC1, ( MASK_29 | MASK_28));
+	// RPS1 timeout disable
+	saa7146_write(dev, RPS_TOV1, 0);
 
 	// code for autodetection
 	// will wait for VBI_B event (vertical blank at port B)
@@ -521,38 +521,38 @@ static int budget_patch_attach (struct s
 	WRITE_RPS1(cpu_to_le32(CMD_UPLOAD |
 	  MASK_10 | MASK_09 | MASK_08 | MASK_06 | MASK_05 | MASK_04 | MASK_03 | MASK_02 ));
 #endif
-        WRITE_RPS1(cpu_to_le32(CMD_PAUSE | EVT_VBI_B));
-        WRITE_RPS1(cpu_to_le32(CMD_WR_REG_MASK | (GPIO_CTRL>>2)));
-        WRITE_RPS1(cpu_to_le32(GPIO3_MSK));
-        WRITE_RPS1(cpu_to_le32(SAA7146_GPIO_OUTLO<<24));
+	WRITE_RPS1(cpu_to_le32(CMD_PAUSE | EVT_VBI_B));
+	WRITE_RPS1(cpu_to_le32(CMD_WR_REG_MASK | (GPIO_CTRL>>2)));
+	WRITE_RPS1(cpu_to_le32(GPIO3_MSK));
+	WRITE_RPS1(cpu_to_le32(SAA7146_GPIO_OUTLO<<24));
 #if RPS_IRQ
-        // issue RPS1 interrupt to increment counter
-        WRITE_RPS1(cpu_to_le32(CMD_INTERRUPT));
-        // at least a NOP is neede between two interrupts
-        WRITE_RPS1(cpu_to_le32(CMD_NOP));
-        // interrupt again
-        WRITE_RPS1(cpu_to_le32(CMD_INTERRUPT));
+	// issue RPS1 interrupt to increment counter
+	WRITE_RPS1(cpu_to_le32(CMD_INTERRUPT));
+	// at least a NOP is neede between two interrupts
+	WRITE_RPS1(cpu_to_le32(CMD_NOP));
+	// interrupt again
+	WRITE_RPS1(cpu_to_le32(CMD_INTERRUPT));
 #endif
-        WRITE_RPS1(cpu_to_le32(CMD_STOP));
+	WRITE_RPS1(cpu_to_le32(CMD_STOP));
 
 #if RPS_IRQ
-        // set event counter 1 source as RPS1 interrupt (0x03)          (rE4 p53)
-        // use 0x03 to track RPS1 interrupts - increase by 1 every gpio3 is toggled
-        // use 0x15 to track VPE  interrupts - increase by 1 every vpeirq() is called
-        saa7146_write(dev, EC1SSR, (0x03<<2) | 3 );
-        // set event counter 1 treshold to maximum allowed value        (rEC p55)
-        saa7146_write(dev, ECT1R,  0x3fff );
+	// set event counter 1 source as RPS1 interrupt (0x03)          (rE4 p53)
+	// use 0x03 to track RPS1 interrupts - increase by 1 every gpio3 is toggled
+	// use 0x15 to track VPE  interrupts - increase by 1 every vpeirq() is called
+	saa7146_write(dev, EC1SSR, (0x03<<2) | 3 );
+	// set event counter 1 treshold to maximum allowed value        (rEC p55)
+	saa7146_write(dev, ECT1R,  0x3fff );
 #endif
-        // Fix VSYNC level
-        saa7146_setgpio(dev, 3, SAA7146_GPIO_OUTLO);
-        // Set RPS1 Address register to point to RPS code               (r108 p42)
-        saa7146_write(dev, RPS_ADDR1, dev->d_rps1.dma_handle);
-        // Enable RPS1,                                                 (rFC p33)
-        saa7146_write(dev, MC1, (MASK_13 | MASK_29 ));
+	// Fix VSYNC level
+	saa7146_setgpio(dev, 3, SAA7146_GPIO_OUTLO);
+	// Set RPS1 Address register to point to RPS code               (r108 p42)
+	saa7146_write(dev, RPS_ADDR1, dev->d_rps1.dma_handle);
+	// Enable RPS1,                                                 (rFC p33)
+	saa7146_write(dev, MC1, (MASK_13 | MASK_29 ));
 
 
-        mdelay(50);
-        saa7146_setgpio(dev, 3, SAA7146_GPIO_OUTHI);
+	mdelay(50);
+	saa7146_setgpio(dev, 3, SAA7146_GPIO_OUTHI);
 	mdelay(150);
 
 
@@ -560,17 +560,17 @@ static int budget_patch_attach (struct s
 		detected = 1;
 
 #if RPS_IRQ
-        printk("Event Counter 1 0x%04x\n", saa7146_read(dev, EC1R) & 0x3fff );
+	printk("Event Counter 1 0x%04x\n", saa7146_read(dev, EC1R) & 0x3fff );
 #endif
 	// Disable RPS1
-        saa7146_write(dev, MC1, ( MASK_29 ));
+	saa7146_write(dev, MC1, ( MASK_29 ));
 
 	if(detected == 0)
-                printk("budget-patch not detected or saa7146 in non-default state.\n"
-                       "try enabling ressetting of 7146 with MASK_31 in MC1 register\n");
+		printk("budget-patch not detected or saa7146 in non-default state.\n"
+		       "try enabling ressetting of 7146 with MASK_31 in MC1 register\n");
 
 	else
-                printk("BUDGET-PATCH DETECTED.\n");
+		printk("BUDGET-PATCH DETECTED.\n");
 
 
 /*      OLD (Original design by Roberto Deza):
@@ -641,83 +641,83 @@ static int budget_patch_attach (struct s
 */
 
 	// Setup RPS1 "program" (p35)
-        count = 0;
+	count = 0;
 
 
-        // Wait Source Line Counter Threshold                           (p36)
-        WRITE_RPS1(cpu_to_le32(CMD_PAUSE | EVT_HS));
-        // Set GPIO3=1                                                  (p42)
-        WRITE_RPS1(cpu_to_le32(CMD_WR_REG_MASK | (GPIO_CTRL>>2)));
-        WRITE_RPS1(cpu_to_le32(GPIO3_MSK));
-        WRITE_RPS1(cpu_to_le32(SAA7146_GPIO_OUTHI<<24));
+	// Wait Source Line Counter Threshold                           (p36)
+	WRITE_RPS1(cpu_to_le32(CMD_PAUSE | EVT_HS));
+	// Set GPIO3=1                                                  (p42)
+	WRITE_RPS1(cpu_to_le32(CMD_WR_REG_MASK | (GPIO_CTRL>>2)));
+	WRITE_RPS1(cpu_to_le32(GPIO3_MSK));
+	WRITE_RPS1(cpu_to_le32(SAA7146_GPIO_OUTHI<<24));
 #if RPS_IRQ
-        // issue RPS1 interrupt
-        WRITE_RPS1(cpu_to_le32(CMD_INTERRUPT));
+	// issue RPS1 interrupt
+	WRITE_RPS1(cpu_to_le32(CMD_INTERRUPT));
 #endif
-        // Wait reset Source Line Counter Threshold                     (p36)
-        WRITE_RPS1(cpu_to_le32(CMD_PAUSE | RPS_INV | EVT_HS));
-        // Set GPIO3=0                                                  (p42)
-        WRITE_RPS1(cpu_to_le32(CMD_WR_REG_MASK | (GPIO_CTRL>>2)));
-        WRITE_RPS1(cpu_to_le32(GPIO3_MSK));
-        WRITE_RPS1(cpu_to_le32(SAA7146_GPIO_OUTLO<<24));
+	// Wait reset Source Line Counter Threshold                     (p36)
+	WRITE_RPS1(cpu_to_le32(CMD_PAUSE | RPS_INV | EVT_HS));
+	// Set GPIO3=0                                                  (p42)
+	WRITE_RPS1(cpu_to_le32(CMD_WR_REG_MASK | (GPIO_CTRL>>2)));
+	WRITE_RPS1(cpu_to_le32(GPIO3_MSK));
+	WRITE_RPS1(cpu_to_le32(SAA7146_GPIO_OUTLO<<24));
 #if RPS_IRQ
-        // issue RPS1 interrupt
-        WRITE_RPS1(cpu_to_le32(CMD_INTERRUPT));
+	// issue RPS1 interrupt
+	WRITE_RPS1(cpu_to_le32(CMD_INTERRUPT));
 #endif
-        // Jump to begin of RPS program                                 (p37)
-        WRITE_RPS1(cpu_to_le32(CMD_JUMP));
-        WRITE_RPS1(cpu_to_le32(dev->d_rps1.dma_handle));
-
-        // Fix VSYNC level
-        saa7146_setgpio(dev, 3, SAA7146_GPIO_OUTLO);
-        // Set RPS1 Address register to point to RPS code               (r108 p42)
-        saa7146_write(dev, RPS_ADDR1, dev->d_rps1.dma_handle);
-        // Set Source Line Counter Threshold, using BRS                 (rCC p43)
-        // It generates HS event every TS_HEIGHT lines
-        // this is related to TS_WIDTH set in register
-        // NUM_LINE_BYTE3 in budget-core.c. If NUM_LINE_BYTE
-        // low 16 bits are set to TS_WIDTH bytes (TS_WIDTH=2*188
-        //,then RPS_THRESH1
-        // should be set to trigger every TS_HEIGHT (512) lines.
-        //
-        saa7146_write(dev, RPS_THRESH1, (TS_HEIGHT*1) | MASK_12 );
-
-        // saa7146_write(dev, RPS_THRESH0, ((TS_HEIGHT/2)<<16) |MASK_28| (TS_HEIGHT/2) |MASK_12 );
-        // Enable RPS1                                                  (rFC p33)
-        saa7146_write(dev, MC1, (MASK_13 | MASK_29));
-
-
-        if (!(budget = kmalloc (sizeof(struct budget_patch), GFP_KERNEL)))
-                return -ENOMEM;
-
-        dprintk(2, "budget: %p\n", budget);
-
-        if ((err = ttpci_budget_init (budget, dev, info, THIS_MODULE))) {
-                kfree (budget);
-                return err;
-        }
+	// Jump to begin of RPS program                                 (p37)
+	WRITE_RPS1(cpu_to_le32(CMD_JUMP));
+	WRITE_RPS1(cpu_to_le32(dev->d_rps1.dma_handle));
+
+	// Fix VSYNC level
+	saa7146_setgpio(dev, 3, SAA7146_GPIO_OUTLO);
+	// Set RPS1 Address register to point to RPS code               (r108 p42)
+	saa7146_write(dev, RPS_ADDR1, dev->d_rps1.dma_handle);
+	// Set Source Line Counter Threshold, using BRS                 (rCC p43)
+	// It generates HS event every TS_HEIGHT lines
+	// this is related to TS_WIDTH set in register
+	// NUM_LINE_BYTE3 in budget-core.c. If NUM_LINE_BYTE
+	// low 16 bits are set to TS_WIDTH bytes (TS_WIDTH=2*188
+	//,then RPS_THRESH1
+	// should be set to trigger every TS_HEIGHT (512) lines.
+	//
+	saa7146_write(dev, RPS_THRESH1, (TS_HEIGHT*1) | MASK_12 );
+
+	// saa7146_write(dev, RPS_THRESH0, ((TS_HEIGHT/2)<<16) |MASK_28| (TS_HEIGHT/2) |MASK_12 );
+	// Enable RPS1                                                  (rFC p33)
+	saa7146_write(dev, MC1, (MASK_13 | MASK_29));
+
 
+	if (!(budget = kmalloc (sizeof(struct budget_patch), GFP_KERNEL)))
+		return -ENOMEM;
 
-        dev->ext_priv = budget;
+	dprintk(2, "budget: %p\n", budget);
+
+	if ((err = ttpci_budget_init (budget, dev, info, THIS_MODULE))) {
+		kfree (budget);
+		return err;
+	}
+
+
+	dev->ext_priv = budget;
 
 	budget->dvb_adapter.priv = budget;
 	frontend_init(budget);
 
-        return 0;
+	return 0;
 }
 
 static int budget_patch_detach (struct saa7146_dev* dev)
 {
-        struct budget_patch *budget = (struct budget_patch*) dev->ext_priv;
-        int err;
+	struct budget_patch *budget = (struct budget_patch*) dev->ext_priv;
+	int err;
 
 	if (budget->dvb_frontend) dvb_unregister_frontend(budget->dvb_frontend);
 
-        err = ttpci_budget_deinit (budget);
+	err = ttpci_budget_deinit (budget);
 
-        kfree (budget);
+	kfree (budget);
 
-        return err;
+	return err;
 }
 
 static int __init budget_patch_init(void)
@@ -727,20 +727,20 @@ static int __init budget_patch_init(void
 
 static void __exit budget_patch_exit(void)
 {
-        saa7146_unregister_extension(&budget_extension);
+	saa7146_unregister_extension(&budget_extension);
 }
 
 static struct saa7146_extension budget_extension = {
-        .name           = "budget_patch dvb\0",
-        .flags          = 0,
+	.name           = "budget_patch dvb\0",
+	.flags          = 0,
 
-        .module         = THIS_MODULE,
-        .pci_tbl        = pci_tbl,
-        .attach         = budget_patch_attach,
-        .detach         = budget_patch_detach,
+	.module         = THIS_MODULE,
+	.pci_tbl        = pci_tbl,
+	.attach         = budget_patch_attach,
+	.detach         = budget_patch_detach,
 
-        .irq_mask       = MASK_10,
-        .irq_func       = ttpci_budget_irq10_handler,
+	.irq_mask       = MASK_10,
+	.irq_func       = ttpci_budget_irq10_handler,
 };
 
 module_init(budget_patch_init);
@@ -749,4 +749,4 @@ module_exit(budget_patch_exit);
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Emard, Roberto Deza, Holger Waechtler, Michael Hunold, others");
 MODULE_DESCRIPTION("Driver for full TS modified DVB-S SAA7146+AV7110 "
-                   "based so-called Budget Patch cards");
+		   "based so-called Budget Patch cards");
diff --git a/drivers/media/dvb/ttpci/budget.c b/drivers/media/dvb/ttpci/budget.c
index bc4ce75..fafe640 100644
--- a/drivers/media/dvb/ttpci/budget.c
+++ b/drivers/media/dvb/ttpci/budget.c
@@ -256,7 +256,7 @@ static int alps_bsrv2_pll_set(struct dvb
 	buf[2] = ((div & 0x18000) >> 10) | 0x95;
 	buf[3] = (pwr << 6) | 0x30;
 
-        // NOTE: since we're using a prescaler of 2, we set the
+	// NOTE: since we're using a prescaler of 2, we set the
 	// divisor frequency to 62.5kHz and divide by 125 above
 
 	if (i2c_transfer (&budget->i2c_adap, &msg, 1) != 1) return -EIO;
@@ -565,7 +565,7 @@ static u8 read_pwm(struct budget* budget
 	struct i2c_msg msg[] = { { .addr = 0x50,.flags = 0,.buf = &b,.len = 1 },
 				 { .addr = 0x50,.flags = I2C_M_RD,.buf = &pwm,.len = 1} };
 
-        if ((i2c_transfer(&budget->i2c_adap, msg, 2) != 2) || (pwm == 0xff))
+	if ((i2c_transfer(&budget->i2c_adap, msg, 2) != 2) || (pwm == 0xff))
 		pwm = 0x48;
 
 	return pwm;
@@ -593,7 +593,7 @@ static void frontend_init(struct budget 
 		budget->dvb_frontend = ves1x93_attach(&alps_bsrv2_config, &budget->i2c_adap);
 		if (budget->dvb_frontend) {
 			budget->dvb_frontend->ops->diseqc_send_master_cmd = budget_diseqc_send_master_cmd;
-		        budget->dvb_frontend->ops->diseqc_send_burst = budget_diseqc_send_burst;
+			budget->dvb_frontend->ops->diseqc_send_burst = budget_diseqc_send_burst;
 			budget->dvb_frontend->ops->set_tone = budget_set_tone;
 			break;
 		}
diff --git a/drivers/media/dvb/ttpci/budget.h b/drivers/media/dvb/ttpci/budget.h
index c6ef496..fdaa331 100644
--- a/drivers/media/dvb/ttpci/budget.h
+++ b/drivers/media/dvb/ttpci/budget.h
@@ -19,7 +19,7 @@ extern int budget_debug;
 #endif
 
 #define dprintk(level,args...) \
-            do { if ((budget_debug & level)) { printk("%s: %s(): ",__stringify(KBUILD_MODNAME), __FUNCTION__); printk(args); } } while (0)
+	    do { if ((budget_debug & level)) { printk("%s: %s(): ",__stringify(KBUILD_MODNAME), __FUNCTION__); printk(args); } } while (0)
 
 struct budget_info {
 	char *name;
diff --git a/drivers/media/dvb/ttpci/fdump.c b/drivers/media/dvb/ttpci/fdump.c
index 0b478db..c90001d 100644
--- a/drivers/media/dvb/ttpci/fdump.c
+++ b/drivers/media/dvb/ttpci/fdump.c
@@ -36,7 +36,7 @@ int main(int argc, char **argv)
     }
 
     fprintf(fd_out, "\n};\n\n");
-    
+
     fclose(fd_in);
     fclose(fd_out);
 
diff --git a/drivers/media/dvb/ttpci/ttpci-eeprom.c b/drivers/media/dvb/ttpci/ttpci-eeprom.c
index ac79ef1..18aa22b 100644
--- a/drivers/media/dvb/ttpci/ttpci-eeprom.c
+++ b/drivers/media/dvb/ttpci/ttpci-eeprom.c
@@ -13,7 +13,7 @@
     Holger Waechtler	Convergence
 
     Copyright (C) 2002-2003 Ralph Metzler <rjkm@metzlerbros.de>
-                            Metzler Brothers Systementwicklung GbR
+		            Metzler Brothers Systementwicklung GbR
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
@@ -48,41 +48,41 @@
 
 static int check_mac_tt(u8 *buf)
 {
-        int i;
-        u16 tmp = 0xffff;
+	int i;
+	u16 tmp = 0xffff;
 
-        for (i = 0; i < 8; i++) {
-                tmp  = (tmp << 8) | ((tmp >> 8) ^ buf[i]);
-                tmp ^= (tmp >> 4) & 0x0f;
-                tmp ^= (tmp << 12) ^ ((tmp & 0xff) << 5);
-        }
-        tmp ^= 0xffff;
-        return (((tmp >> 8) ^ buf[8]) | ((tmp & 0xff) ^ buf[9]));
+	for (i = 0; i < 8; i++) {
+		tmp  = (tmp << 8) | ((tmp >> 8) ^ buf[i]);
+		tmp ^= (tmp >> 4) & 0x0f;
+		tmp ^= (tmp << 12) ^ ((tmp & 0xff) << 5);
+	}
+	tmp ^= 0xffff;
+	return (((tmp >> 8) ^ buf[8]) | ((tmp & 0xff) ^ buf[9]));
 }
 
 static int getmac_tt(u8 * decodedMAC, u8 * encodedMAC)
 {
-        u8 xor[20] = { 0x72, 0x23, 0x68, 0x19, 0x5c, 0xa8, 0x71, 0x2c,
+	u8 xor[20] = { 0x72, 0x23, 0x68, 0x19, 0x5c, 0xa8, 0x71, 0x2c,
 		       0x54, 0xd3, 0x7b, 0xf1, 0x9E, 0x23, 0x16, 0xf6,
 		       0x1d, 0x36, 0x64, 0x78};
-        u8 data[20];
-        int i;
+	u8 data[20];
+	int i;
 
 	/* In case there is a sig check failure have the orig contents available */
 	memcpy(data, encodedMAC, 20);
 
 	for (i = 0; i < 20; i++)
-                data[i] ^= xor[i];
-        for (i = 0; i < 10; i++)
-                data[i] = ((data[2 * i + 1] << 8) | data[2 * i])
+		data[i] ^= xor[i];
+	for (i = 0; i < 10; i++)
+		data[i] = ((data[2 * i + 1] << 8) | data[2 * i])
 			>> ((data[2 * i + 1] >> 6) & 3);
 
-        if (check_mac_tt(data))
-                return -ENODEV;
+	if (check_mac_tt(data))
+		return -ENODEV;
 
 	decodedMAC[0] = data[2]; decodedMAC[1] = data[1]; decodedMAC[2] = data[0];
 	decodedMAC[3] = data[6]; decodedMAC[4] = data[5]; decodedMAC[5] = data[4];
-        return 0;
+	return 0;
 }
 
 static int ttpci_eeprom_read_encodedMAC(struct i2c_adapter *adapter, u8 * encodedMAC)
diff --git a/drivers/media/dvb/ttusb-budget/dvb-ttusb-budget.c b/drivers/media/dvb/ttusb-budget/dvb-ttusb-budget.c
index fd53d60..104df61 100644
--- a/drivers/media/dvb/ttusb-budget/dvb-ttusb-budget.c
+++ b/drivers/media/dvb/ttusb-budget/dvb-ttusb-budget.c
@@ -225,8 +225,8 @@ static int ttusb_i2c_msg(struct ttusb *t
 
 	err = ttusb_result(ttusb, b, 0x20);
 
-        /* check if the i2c transaction was successful */
-        if ((snd_len != b[5]) || (rcv_len != b[6])) return -EREMOTEIO;
+	/* check if the i2c transaction was successful */
+	if ((snd_len != b[5]) || (rcv_len != b[6])) return -EREMOTEIO;
 
 	if (rcv_len > 0) {
 
@@ -489,27 +489,27 @@ static int ttusb_send_diseqc(struct dvb_
 
 static int lnbp21_set_voltage(struct dvb_frontend* fe, fe_sec_voltage_t voltage)
 {
-        struct  ttusb* ttusb = (struct ttusb*)  fe->dvb->priv;
-        int ret;
-        u8 data[1];
-        struct i2c_msg msg = { .addr = 0x08, .flags = 0, .buf = data, .len = sizeof(data) };
-
-        switch(voltage) {
-        case SEC_VOLTAGE_OFF:
-                data[0] = 0x00;
-                break;
-        case SEC_VOLTAGE_13:
-                data[0] = 0x44;
-                break;
-        case SEC_VOLTAGE_18:
-                data[0] = 0x4c;
-                break;
-        default:
-                return -EINVAL;
-        };
+	struct  ttusb* ttusb = (struct ttusb*)  fe->dvb->priv;
+	int ret;
+	u8 data[1];
+	struct i2c_msg msg = { .addr = 0x08, .flags = 0, .buf = data, .len = sizeof(data) };
+
+	switch(voltage) {
+	case SEC_VOLTAGE_OFF:
+		data[0] = 0x00;
+		break;
+	case SEC_VOLTAGE_13:
+		data[0] = 0x44;
+		break;
+	case SEC_VOLTAGE_18:
+		data[0] = 0x4c;
+		break;
+	default:
+		return -EINVAL;
+	};
 
-        ret = i2c_transfer(&ttusb->i2c_adap, &msg, 1);
-        return (ret != 1) ? -EIO : 0;
+	ret = i2c_transfer(&ttusb->i2c_adap, &msg, 1);
+	return (ret != 1) ? -EIO : 0;
 }
 
 static int ttusb_update_lnb(struct ttusb *ttusb)
@@ -1184,45 +1184,45 @@ static struct tda1004x_config philips_td
 };
 
 static u8 alps_bsbe1_inittab[] = {
-        0x01, 0x15,
-        0x02, 0x30,
-        0x03, 0x00,
-        0x04, 0x7d,             /* F22FR = 0x7d, F22 = f_VCO / 128 / 0x7d = 22 kHz */
-        0x05, 0x35,             /* I2CT = 0, SCLT = 1, SDAT = 1 */
-        0x06, 0x40,             /* DAC not used, set to high impendance mode */
-        0x07, 0x00,             /* DAC LSB */
-        0x08, 0x40,             /* DiSEqC off, LNB power on OP2/LOCK pin on */
-        0x09, 0x00,             /* FIFO */
-        0x0c, 0x51,             /* OP1 ctl = Normal, OP1 val = 1 (LNB Power ON) */
-        0x0d, 0x82,             /* DC offset compensation = ON, beta_agc1 = 2 */
-        0x0e, 0x23,             /* alpha_tmg = 2, beta_tmg = 3 */
-        0x10, 0x3f,             // AGC2  0x3d
-        0x11, 0x84,
-        0x12, 0xb9,
-        0x15, 0xc9,             // lock detector threshold
-        0x16, 0x00,
-        0x17, 0x00,
-        0x18, 0x00,
-        0x19, 0x00,
-        0x1a, 0x00,
-        0x1f, 0x50,
-        0x20, 0x00,
-        0x21, 0x00,
-        0x22, 0x00,
-        0x23, 0x00,
-        0x28, 0x00,             // out imp: normal  out type: parallel FEC mode:0
-        0x29, 0x1e,             // 1/2 threshold
-        0x2a, 0x14,             // 2/3 threshold
-        0x2b, 0x0f,             // 3/4 threshold
-        0x2c, 0x09,             // 5/6 threshold
-        0x2d, 0x05,             // 7/8 threshold
-        0x2e, 0x01,
-        0x31, 0x1f,             // test all FECs
-        0x32, 0x19,             // viterbi and synchro search
-        0x33, 0xfc,             // rs control
-        0x34, 0x93,             // error control
-        0x0f, 0x92,
-        0xff, 0xff
+	0x01, 0x15,
+	0x02, 0x30,
+	0x03, 0x00,
+	0x04, 0x7d,             /* F22FR = 0x7d, F22 = f_VCO / 128 / 0x7d = 22 kHz */
+	0x05, 0x35,             /* I2CT = 0, SCLT = 1, SDAT = 1 */
+	0x06, 0x40,             /* DAC not used, set to high impendance mode */
+	0x07, 0x00,             /* DAC LSB */
+	0x08, 0x40,             /* DiSEqC off, LNB power on OP2/LOCK pin on */
+	0x09, 0x00,             /* FIFO */
+	0x0c, 0x51,             /* OP1 ctl = Normal, OP1 val = 1 (LNB Power ON) */
+	0x0d, 0x82,             /* DC offset compensation = ON, beta_agc1 = 2 */
+	0x0e, 0x23,             /* alpha_tmg = 2, beta_tmg = 3 */
+	0x10, 0x3f,             // AGC2  0x3d
+	0x11, 0x84,
+	0x12, 0xb9,
+	0x15, 0xc9,             // lock detector threshold
+	0x16, 0x00,
+	0x17, 0x00,
+	0x18, 0x00,
+	0x19, 0x00,
+	0x1a, 0x00,
+	0x1f, 0x50,
+	0x20, 0x00,
+	0x21, 0x00,
+	0x22, 0x00,
+	0x23, 0x00,
+	0x28, 0x00,             // out imp: normal  out type: parallel FEC mode:0
+	0x29, 0x1e,             // 1/2 threshold
+	0x2a, 0x14,             // 2/3 threshold
+	0x2b, 0x0f,             // 3/4 threshold
+	0x2c, 0x09,             // 5/6 threshold
+	0x2d, 0x05,             // 7/8 threshold
+	0x2e, 0x01,
+	0x31, 0x1f,             // test all FECs
+	0x32, 0x19,             // viterbi and synchro search
+	0x33, 0xfc,             // rs control
+	0x34, 0x93,             // error control
+	0x0f, 0x92,
+	0xff, 0xff
 };
 
 static u8 alps_bsru6_inittab[] = {
@@ -1350,7 +1350,7 @@ static int ttusb_novas_grundig_29504_491
 	u32 div;
 	struct i2c_msg msg = {.addr = 0x61,.flags = 0,.buf = buf,.len = sizeof(buf) };
 
-        div = params->frequency / 125;
+	div = params->frequency / 125;
 
 	buf[0] = (div >> 8) & 0x7f;
 	buf[1] = div & 0xff;
@@ -1487,7 +1487,7 @@ static int ttusb_probe(struct usb_interf
 
 	udev = interface_to_usbdev(intf);
 
-        if (intf->altsetting->desc.bInterfaceNumber != 1) return -ENODEV;
+	if (intf->altsetting->desc.bInterfaceNumber != 1) return -ENODEV;
 
 	if (!(ttusb = kmalloc(sizeof(struct ttusb), GFP_KERNEL)))
 		return -ENOMEM;
diff --git a/drivers/media/dvb/ttusb-budget/dvb-ttusb-dspbootcode.h b/drivers/media/dvb/ttusb-budget/dvb-ttusb-dspbootcode.h
index 95ee799..8c3cd54 100644
--- a/drivers/media/dvb/ttusb-budget/dvb-ttusb-dspbootcode.h
+++ b/drivers/media/dvb/ttusb-budget/dvb-ttusb-dspbootcode.h
@@ -2,1643 +2,1643 @@
 #include <asm/types.h>
 
 static u8 dsp_bootcode [] = {
-	0x08, 0xaa, 0x00, 0x18, 0x00, 0x03, 0x08, 0x00, 
-	0x00, 0x10, 0x00, 0x00, 0x01, 0x80, 0x18, 0x5f, 
-	0x00, 0x00, 0x01, 0x80, 0x77, 0x18, 0x2a, 0xeb, 
-	0x6b, 0xf8, 0x00, 0x18, 0x03, 0xff, 0x68, 0xf8, 
-	0x00, 0x18, 0xff, 0xfe, 0xf7, 0xb8, 0xf7, 0xbe, 
-	0xf6, 0xb9, 0xf4, 0xa0, 0xf6, 0xb7, 0xf6, 0xb5, 
-	0xf6, 0xb6, 0xf0, 0x20, 0x19, 0xdf, 0xf1, 0x00, 
-	0x00, 0x01, 0xf8, 0x4d, 0x01, 0xab, 0xf6, 0xb8, 
-	0xf0, 0x20, 0x19, 0xdf, 0xf0, 0x73, 0x01, 0xa5, 
-	0x7e, 0xf8, 0x00, 0x12, 0xf0, 0x00, 0x00, 0x01, 
-	0x47, 0xf8, 0x00, 0x11, 0x7e, 0x92, 0x00, 0xf8, 
-	0x00, 0x11, 0xf0, 0x00, 0x00, 0x01, 0x7e, 0xf8, 
-	0x00, 0x11, 0xf0, 0x00, 0x00, 0x01, 0x6c, 0x89, 
-	0x01, 0x9a, 0xf7, 0xb8, 0xee, 0xfc, 0xf0, 0x20, 
-	0xff, 0xff, 0xf1, 0x00, 0x00, 0x01, 0xf8, 0x4d, 
-	0x01, 0xbf, 0xf2, 0x73, 0x01, 0xb9, 0x4e, 0x02, 
-	0xf4, 0x95, 0xf5, 0xe3, 0x56, 0x02, 0x7e, 0x00, 
-	0x11, 0x00, 0xfa, 0x4c, 0x01, 0xb7, 0x6b, 0x03, 
-	0x00, 0x01, 0xf6, 0xb8, 0xee, 0x04, 0xf0, 0x74, 
-	0x0d, 0xa7, 0xf0, 0x74, 0x01, 0xc5, 0x4a, 0x11, 
-	0x4a, 0x16, 0x72, 0x11, 0x2a, 0xe6, 0x10, 0xf8, 
-	0x00, 0x11, 0xfa, 0x45, 0x01, 0xdb, 0xf4, 0x95, 
-	0xee, 0xff, 0x48, 0x11, 0xf0, 0x00, 0x2a, 0xc6, 
-	0x88, 0x16, 0xf4, 0x95, 0xf4, 0x95, 0x10, 0xee, 
-	0xff, 0xff, 0xf4, 0xe3, 0x6c, 0xe9, 0xff, 0xff, 
-	0x01, 0xd5, 0x10, 0xf8, 0x2a, 0xe7, 0xf8, 0x45, 
-	0x01, 0xe2, 0x10, 0xf8, 0x2a, 0xe7, 0xf4, 0xe3, 
-	0xf0, 0x74, 0x01, 0xff, 0xee, 0x01, 0x8a, 0x16, 
-	0x8a, 0x11, 0xfc, 0x00, 0xf7, 0xb8, 0xe9, 0x20, 
-	0x4a, 0x11, 0x09, 0xf8, 0x2a, 0xe6, 0xf8, 0x4e, 
-	0x01, 0xf3, 0xf2, 0x73, 0x01, 0xfd, 0xf4, 0x95, 
-	0xe8, 0x01, 0x72, 0x11, 0x2a, 0xe6, 0x49, 0x11, 
-	0x80, 0xe1, 0x2a, 0xc6, 0xf3, 0x00, 0x00, 0x01, 
-	0xe8, 0x00, 0x81, 0xf8, 0x2a, 0xe6, 0x8a, 0x11, 
-	0xfc, 0x00, 0xf4, 0x95, 0xf0, 0x73, 0x02, 0x00, 
-	0x10, 0xf8, 0x2a, 0x0f, 0xfc, 0x00, 0x4a, 0x11, 
-	0xf0, 0x74, 0x02, 0x02, 0x80, 0xf8, 0x2a, 0x10, 
-	0x73, 0x08, 0x00, 0x09, 0x40, 0xf8, 0x2a, 0x15, 
-	0x82, 0xf8, 0x00, 0x11, 0xf4, 0x95, 0x77, 0x10, 
-	0x03, 0xe8, 0xf5, 0xa9, 0xf8, 0x30, 0x02, 0x21, 
-	0x71, 0xf8, 0x2a, 0x10, 0x2a, 0x15, 0x56, 0xf8, 
-	0x2a, 0x0c, 0xf0, 0xe3, 0x4e, 0xf8, 0x2a, 0x16, 
-	0xe8, 0x00, 0x4e, 0xf8, 0x2a, 0x0c, 0x8a, 0x11, 
-	0xfc, 0x00, 0x4a, 0x06, 0x4a, 0x07, 0x4a, 0x1d, 
-	0x68, 0xf8, 0x00, 0x07, 0x7d, 0x3f, 0x69, 0xf8, 
-	0x00, 0x07, 0x40, 0x00, 0x68, 0xf8, 0x00, 0x1d, 
-	0xff, 0xfc, 0x6b, 0xf8, 0x2a, 0x0f, 0x00, 0x01, 
-	0x8a, 0x1d, 0x8a, 0x07, 0x8a, 0x06, 0xf4, 0xeb, 
-	0xee, 0xfd, 0x76, 0xf8, 0x2a, 0x0f, 0x00, 0x00, 
-	0x76, 0x00, 0x00, 0x00, 0xfb, 0x80, 0x19, 0x4c, 
-	0xf4, 0x95, 0xe8, 0x00, 0x80, 0xf8, 0x2a, 0x11, 
-	0xf9, 0x80, 0x19, 0x07, 0x80, 0xf8, 0x2a, 0x0e, 
-	0xf9, 0x80, 0x16, 0x66, 0x76, 0x00, 0x2a, 0x12, 
-	0x10, 0xf8, 0x2a, 0x11, 0xf9, 0x80, 0x18, 0xe3, 
-	0x10, 0xf8, 0x2a, 0x0e, 0xf9, 0x80, 0x16, 0x66, 
-	0x10, 0xf8, 0x2a, 0x0e, 0xf9, 0x80, 0x16, 0x87, 
-	0xee, 0x03, 0xfc, 0x00, 0x4a, 0x11, 0xf6, 0xb8, 
-	0xf4, 0x95, 0xf0, 0x20, 0x80, 0x00, 0x11, 0xf8, 
-	0x2a, 0x5a, 0xf8, 0x4d, 0x02, 0x93, 0x11, 0xf8, 
-	0x2a, 0x9f, 0xf8, 0x4c, 0x02, 0x7c, 0x77, 0x12, 
-	0x2a, 0x39, 0x49, 0x12, 0x01, 0xf8, 0x2a, 0x9f, 
-	0x89, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x71, 0x81, 
-	0x00, 0x11, 0x6c, 0xe1, 0xff, 0xab, 0x02, 0x93, 
-	0x6b, 0xf8, 0x2a, 0x9f, 0x00, 0x01, 0xe9, 0x05, 
-	0x01, 0xe2, 0x00, 0x03, 0x81, 0xf8, 0x2a, 0xa0, 
-	0xf0, 0x73, 0x02, 0x95, 0x72, 0x11, 0x2a, 0x9f, 
-	0xf4, 0x95, 0x10, 0xe1, 0x2a, 0x39, 0x6b, 0xf8, 
-	0x2a, 0x9f, 0x00, 0x01, 0x11, 0xf8, 0x2a, 0x9f, 
-	0x09, 0xf8, 0x2a, 0xa0, 0xf8, 0x4c, 0x02, 0x93, 
-	0x76, 0xf8, 0x2a, 0x5a, 0x00, 0x00, 0x76, 0xf8, 
-	0x2a, 0x9f, 0x00, 0x00, 0x76, 0xf8, 0x2a, 0xa0, 
-	0x00, 0x00, 0x88, 0x11, 0xf4, 0x95, 0x48, 0x11, 
-	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0xee, 0xfe, 
-	0x10, 0xf8, 0x2a, 0x5a, 0xf8, 0x44, 0x02, 0xb2, 
-	0x76, 0xf8, 0x2a, 0x5a, 0x00, 0x01, 0xf0, 0x74, 
-	0x02, 0x58, 0x88, 0x11, 0xf4, 0x95, 0x77, 0x10, 
-	0x80, 0x00, 0xf4, 0xa9, 0xf8, 0x30, 0x02, 0xb2, 
-	0x48, 0x11, 0xf0, 0x30, 0x00, 0xff, 0x80, 0x00, 
-	0x10, 0xf8, 0x2a, 0x5b, 0xf9, 0x80, 0x18, 0xd6, 
-	0xee, 0x02, 0x8a, 0x11, 0xfc, 0x00, 0xf4, 0x95, 
-	0x4a, 0x08, 0x4a, 0x09, 0x4a, 0x0a, 0x4a, 0x0b, 
-	0x4a, 0x0c, 0x4a, 0x0d, 0x4a, 0x10, 0x4a, 0x11, 
-	0x4a, 0x12, 0x4a, 0x13, 0x4a, 0x14, 0x4a, 0x15, 
-	0x4a, 0x16, 0x4a, 0x17, 0x4a, 0x17, 0x4a, 0x19, 
-	0x4a, 0x0e, 0x4a, 0x06, 0x4a, 0x07, 0x4a, 0x1a, 
-	0x4a, 0x1d, 0x4a, 0x1b, 0x4a, 0x1c, 0x68, 0xf8, 
-	0x00, 0x07, 0x7d, 0x3f, 0x69, 0xf8, 0x00, 0x07, 
-	0x40, 0x00, 0x68, 0xf8, 0x00, 0x1d, 0xff, 0xfc, 
-	0x48, 0x18, 0x68, 0xf8, 0x00, 0x18, 0xff, 0xfe, 
-	0xf4, 0x95, 0xf4, 0x95, 0x4a, 0x08, 0xee, 0xfd, 
-	0xf0, 0x74, 0x02, 0x58, 0x88, 0x11, 0xf4, 0x95, 
-	0x77, 0x10, 0x80, 0x00, 0xf4, 0xa9, 0xf8, 0x30, 
-	0x02, 0xef, 0x48, 0x11, 0xf0, 0x30, 0x00, 0xff, 
-	0x80, 0x00, 0x10, 0xf8, 0x2a, 0x5b, 0xf9, 0x80, 
-	0x18, 0xd6, 0xee, 0x03, 0x8a, 0x18, 0xf4, 0x95, 
-	0x8a, 0x1c, 0x8a, 0x1b, 0x8a, 0x1d, 0x8a, 0x1a, 
-	0x8a, 0x07, 0x8a, 0x06, 0x8a, 0x0e, 0x8a, 0x19, 
-	0x8a, 0x17, 0x8a, 0x17, 0x8a, 0x16, 0x8a, 0x15, 
-	0x8a, 0x14, 0x8a, 0x13, 0x8a, 0x12, 0x8a, 0x11, 
-	0x8a, 0x10, 0x8a, 0x0d, 0x8a, 0x0c, 0x8a, 0x0b, 
-	0x8a, 0x0a, 0x8a, 0x09, 0x8a, 0x08, 0xf4, 0xeb, 
-	0x4a, 0x11, 0x77, 0x11, 0x2a, 0x39, 0x76, 0x81, 
-	0x00, 0x55, 0x77, 0x12, 0x2a, 0x18, 0x10, 0xe2, 
-	0x00, 0x01, 0x80, 0xe1, 0x00, 0x01, 0x10, 0xe2, 
-	0x00, 0x02, 0x80, 0xe1, 0x00, 0x02, 0x76, 0xe1, 
-	0x00, 0x03, 0x00, 0x00, 0x76, 0xe1, 0x00, 0x04, 
-	0x00, 0xaa, 0xf0, 0x74, 0x02, 0x98, 0x8a, 0x11, 
-	0xfc, 0x00, 0x4a, 0x11, 0x88, 0x11, 0xf4, 0x95, 
-	0xf4, 0x95, 0x10, 0x81, 0x6f, 0xf8, 0x2a, 0x9e, 
-	0x0c, 0x88, 0xe8, 0xff, 0x18, 0xe1, 0x00, 0x01, 
-	0x1a, 0xf8, 0x2a, 0x9e, 0xf0, 0x30, 0x1f, 0xff, 
-	0x80, 0xf8, 0x2a, 0x9e, 0x8a, 0x11, 0xfc, 0x00, 
-	0x4a, 0x11, 0x77, 0x11, 0x2a, 0x39, 0x76, 0x81, 
-	0x00, 0x55, 0x77, 0x12, 0x2a, 0x18, 0x11, 0xe2, 
-	0x00, 0x01, 0x81, 0xe1, 0x00, 0x01, 0x11, 0xe2, 
-	0x00, 0x02, 0x81, 0xe1, 0x00, 0x02, 0x76, 0xe1, 
-	0x00, 0x03, 0x00, 0x02, 0x48, 0x08, 0x6f, 0xe1, 
-	0x00, 0x04, 0x0c, 0x98, 0xf0, 0x30, 0x00, 0xff, 
-	0x80, 0xe1, 0x00, 0x05, 0x76, 0xe1, 0x00, 0x06, 
-	0x00, 0xaa, 0xf0, 0x74, 0x02, 0x98, 0x8a, 0x11, 
-	0xfc, 0x00, 0x4a, 0x11, 0x77, 0x11, 0x2a, 0x39, 
-	0x76, 0x81, 0x00, 0x55, 0x77, 0x12, 0x2a, 0x18, 
-	0x10, 0xe2, 0x00, 0x01, 0x80, 0xe1, 0x00, 0x01, 
-	0x10, 0xe2, 0x00, 0x02, 0x80, 0xe1, 0x00, 0x02, 
-	0x76, 0xe1, 0x00, 0x03, 0x00, 0x04, 0x48, 0x11, 
-	0xf0, 0x00, 0x00, 0x04, 0x88, 0x12, 0xf4, 0x95, 
-	0x77, 0x13, 0x2a, 0x76, 0xe9, 0x00, 0xe5, 0x98, 
-	0xf3, 0x00, 0x00, 0x01, 0xf6, 0xb8, 0x48, 0x0b, 
-	0x08, 0xf8, 0x2a, 0x3c, 0xf8, 0x43, 0x03, 0x71, 
-	0x76, 0x82, 0x00, 0xaa, 0xf0, 0x74, 0x02, 0x98, 
-	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0xee, 0xf0, 
-	0x88, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x71, 0x81, 
-	0x00, 0x14, 0x71, 0xe1, 0x00, 0x01, 0x00, 0x15, 
-	0x49, 0x11, 0xf3, 0x00, 0x00, 0x02, 0x89, 0x11, 
-	0xe7, 0x82, 0x6d, 0xea, 0x00, 0x04, 0xe7, 0x83, 
-	0x6d, 0xeb, 0x00, 0x0a, 0x77, 0x1a, 0x00, 0x05, 
-	0xf0, 0x72, 0x03, 0xaa, 0x11, 0x81, 0xf2, 0xe8, 
-	0x80, 0x82, 0xe9, 0xff, 0x19, 0xe1, 0x00, 0x01, 
-	0xf1, 0xa0, 0x81, 0x92, 0x11, 0xe1, 0x00, 0x0c, 
-	0xf2, 0xe8, 0x80, 0x83, 0xe9, 0xff, 0x19, 0xe1, 
-	0x00, 0x0d, 0xf1, 0xa0, 0x81, 0x93, 0x6d, 0xe9, 
-	0x00, 0x02, 0x48, 0x18, 0x49, 0x18, 0x70, 0x00, 
-	0x00, 0x15, 0xf0, 0x00, 0x00, 0x04, 0xf3, 0x00, 
-	0x00, 0x0a, 0x80, 0x01, 0x81, 0x02, 0xf2, 0x74, 
-	0x0e, 0x54, 0xf4, 0x95, 0x48, 0x14, 0xee, 0x10, 
-	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0xf0, 0x74, 
-	0x0c, 0x5e, 0x80, 0xf8, 0x2a, 0x5c, 0x77, 0x12, 
-	0x2a, 0x39, 0x76, 0x82, 0x00, 0x55, 0x77, 0x11, 
-	0x2a, 0x18, 0x10, 0xe1, 0x00, 0x01, 0x80, 0xe2, 
-	0x00, 0x01, 0x10, 0xe1, 0x00, 0x02, 0x80, 0xe2, 
-	0x00, 0x02, 0x76, 0xe2, 0x00, 0x03, 0x00, 0x1c, 
-	0xf6, 0xb8, 0x56, 0xf8, 0x2a, 0x16, 0xf0, 0xf0, 
-	0xf0, 0xf8, 0x80, 0xe2, 0x00, 0x07, 0x56, 0xf8, 
-	0x2a, 0x16, 0xf1, 0xf0, 0xe8, 0xff, 0xf2, 0x80, 
-	0x80, 0xe2, 0x00, 0x06, 0x56, 0xf8, 0x2a, 0x16, 
-	0xf1, 0xf8, 0xe8, 0xff, 0xf2, 0x80, 0x80, 0xe2, 
-	0x00, 0x05, 0x57, 0xf8, 0x2a, 0x16, 0xe8, 0xff, 
-	0xf2, 0x80, 0x80, 0xe2, 0x00, 0x04, 0x56, 0xf8, 
-	0x27, 0x6c, 0xf0, 0xf0, 0xf0, 0xf8, 0x80, 0xe2, 
-	0x00, 0x0b, 0x56, 0xf8, 0x27, 0x6c, 0xf1, 0xf0, 
-	0xe8, 0xff, 0xf2, 0x80, 0x80, 0xe2, 0x00, 0x0a, 
-	0x56, 0xf8, 0x27, 0x6c, 0xf1, 0xf8, 0xe8, 0xff, 
-	0xf2, 0x80, 0x80, 0xe2, 0x00, 0x09, 0xe8, 0xff, 
-	0x57, 0xf8, 0x27, 0x6c, 0xf2, 0x80, 0x80, 0xe2, 
-	0x00, 0x08, 0x56, 0xf8, 0x27, 0x6a, 0xf0, 0xf0, 
-	0xf0, 0xf8, 0x80, 0xe2, 0x00, 0x0f, 0x56, 0xf8, 
-	0x27, 0x6a, 0xf1, 0xf0, 0xe8, 0xff, 0xf2, 0x80, 
-	0x80, 0xe2, 0x00, 0x0e, 0x56, 0xf8, 0x27, 0x6a, 
-	0xf1, 0xf8, 0xe8, 0xff, 0xf2, 0x80, 0x80, 0xe2, 
-	0x00, 0x0d, 0x57, 0xf8, 0x27, 0x6a, 0xe8, 0xff, 
-	0xf2, 0x80, 0x80, 0xe2, 0x00, 0x0c, 0x76, 0xe2, 
-	0x00, 0x13, 0x00, 0x00, 0x76, 0xe2, 0x00, 0x12, 
-	0x00, 0x00, 0x6f, 0xf8, 0x2a, 0x5c, 0x0c, 0x58, 
-	0x80, 0xe2, 0x00, 0x11, 0xe8, 0xff, 0x18, 0xf8, 
-	0x2a, 0x5c, 0x80, 0xe2, 0x00, 0x10, 0x76, 0xe2, 
-	0x00, 0x17, 0x00, 0x00, 0x76, 0xe2, 0x00, 0x16, 
-	0x00, 0x00, 0x6f, 0xf8, 0x2a, 0x9e, 0x0c, 0x58, 
-	0x80, 0xe2, 0x00, 0x15, 0xe8, 0xff, 0x18, 0xf8, 
-	0x2a, 0x9e, 0x80, 0xe2, 0x00, 0x14, 0x76, 0xe2, 
-	0x00, 0x1b, 0x00, 0x00, 0x76, 0xe2, 0x00, 0x1a, 
-	0x00, 0x00, 0x76, 0xe2, 0x00, 0x19, 0x00, 0x00, 
-	0x70, 0xe2, 0x00, 0x18, 0x27, 0x6e, 0x76, 0xe2, 
-	0x00, 0x1f, 0x00, 0x00, 0x76, 0xe2, 0x00, 0x1e, 
-	0x00, 0x00, 0x76, 0xe2, 0x00, 0x1d, 0x00, 0x00, 
-	0x76, 0xe2, 0x00, 0x1c, 0x00, 0x00, 0x76, 0xe2, 
-	0x00, 0x20, 0x00, 0xaa, 0xf0, 0x74, 0x02, 0x98, 
-	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0xee, 0xfe, 
-	0x10, 0xf8, 0x2a, 0x38, 0xf8, 0x45, 0x04, 0xed, 
-	0x77, 0x12, 0x2a, 0x18, 0x10, 0xe2, 0x00, 0x02, 
-	0x88, 0x11, 0xf4, 0x95, 0x77, 0x10, 0x00, 0x08, 
-	0x6d, 0xe9, 0xff, 0xdf, 0xf6, 0xa9, 0xf8, 0x20, 
-	0x04, 0x75, 0xf0, 0x73, 0x04, 0x7d, 0xf0, 0x10, 
-	0x00, 0x21, 0xf0, 0x00, 0x1a, 0x83, 0x48, 0x08, 
-	0x7e, 0xf8, 0x00, 0x08, 0xf4, 0xe2, 0xf0, 0x74, 
-	0x03, 0x0a, 0xf0, 0x73, 0x04, 0xea, 0x48, 0x12, 
-	0xf2, 0x74, 0x03, 0x23, 0xf0, 0x00, 0x00, 0x04, 
-	0xf2, 0x74, 0x03, 0x36, 0xf4, 0x95, 0xe8, 0x00, 
-	0xf0, 0x73, 0x04, 0xea, 0x77, 0x11, 0x2a, 0x18, 
-	0xe8, 0xff, 0x6f, 0xe1, 0x00, 0x04, 0x0d, 0x48, 
-	0x18, 0xe1, 0x00, 0x05, 0xf2, 0x74, 0x09, 0x69, 
-	0xf4, 0x95, 0xf2, 0xa0, 0xf0, 0x74, 0x03, 0x36, 
-	0xf0, 0x73, 0x04, 0xea, 0x77, 0x11, 0x2a, 0x18, 
-	0xe8, 0xff, 0x6f, 0xe1, 0x00, 0x04, 0x0d, 0x48, 
-	0x18, 0xe1, 0x00, 0x05, 0xf2, 0x74, 0x09, 0x41, 
-	0xf4, 0x95, 0xf2, 0xa0, 0xf0, 0x74, 0x03, 0x36, 
-	0xf0, 0x73, 0x04, 0xea, 0xf0, 0x74, 0x03, 0x57, 
-	0xf0, 0x73, 0x04, 0xea, 0x10, 0xf8, 0x2a, 0x1c, 
-	0xf0, 0x74, 0x12, 0xa4, 0xf2, 0x74, 0x03, 0x36, 
-	0xf4, 0x95, 0xe8, 0x00, 0xf0, 0x73, 0x04, 0xea, 
-	0x48, 0x12, 0xf2, 0x74, 0x03, 0x80, 0xf0, 0x00, 
-	0x00, 0x04, 0xf2, 0x74, 0x03, 0x36, 0xf4, 0x95, 
-	0xe8, 0x00, 0xf0, 0x73, 0x04, 0xea, 0x10, 0xf8, 
-	0x2a, 0x1c, 0xf0, 0x74, 0x12, 0xc5, 0xf2, 0x74, 
-	0x03, 0x36, 0xf4, 0x95, 0xe8, 0x00, 0xf0, 0x73, 
-	0x04, 0xea, 0x77, 0x11, 0x2a, 0x18, 0xe8, 0xff, 
-	0x6f, 0xe1, 0x00, 0x06, 0x0d, 0x48, 0x18, 0xe1, 
-	0x00, 0x07, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 
-	0xf2, 0xa0, 0x70, 0x00, 0x00, 0x12, 0x80, 0x01, 
-	0x10, 0xe1, 0x00, 0x04, 0xf0, 0x74, 0x0e, 0x7a, 
-	0xf2, 0x74, 0x03, 0x36, 0xf4, 0x95, 0xe8, 0x00, 
-	0xf0, 0x73, 0x04, 0xea, 0xf0, 0x74, 0x03, 0xbc, 
-	0x76, 0xf8, 0x2a, 0x38, 0x00, 0x00, 0xee, 0x02, 
-	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0x77, 0x11, 
-	0x2a, 0x39, 0x76, 0x81, 0x00, 0x55, 0x77, 0x12, 
-	0x2a, 0x18, 0x10, 0xe2, 0x00, 0x01, 0x80, 0xe1, 
-	0x00, 0x01, 0x10, 0xe2, 0x00, 0x02, 0x80, 0xe1, 
-	0x00, 0x02, 0x76, 0xe1, 0x00, 0x03, 0x00, 0x09, 
-	0x48, 0x11, 0xf0, 0x00, 0x00, 0x04, 0x88, 0x12, 
-	0xf4, 0x95, 0x77, 0x13, 0x2a, 0x86, 0xe9, 0x00, 
-	0xe5, 0x98, 0xf3, 0x00, 0x00, 0x01, 0xf6, 0xb8, 
-	0x48, 0x0b, 0x08, 0xf8, 0x2a, 0x3c, 0xf8, 0x43, 
-	0x05, 0x0a, 0x76, 0x82, 0x00, 0xaa, 0xf0, 0x74, 
-	0x02, 0x98, 0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 
-	0x77, 0x11, 0x2a, 0x39, 0x76, 0x81, 0x00, 0x55, 
-	0x77, 0x13, 0x2a, 0x18, 0x10, 0xe3, 0x00, 0x01, 
-	0x80, 0xe1, 0x00, 0x01, 0x10, 0xe3, 0x00, 0x02, 
-	0x80, 0xe1, 0x00, 0x02, 0x13, 0xe3, 0x00, 0x03, 
-	0x81, 0xe1, 0x00, 0x03, 0x48, 0x11, 0x77, 0x11, 
-	0x00, 0x00, 0xf8, 0x4d, 0x05, 0x44, 0xf0, 0x00, 
-	0x00, 0x04, 0x88, 0x12, 0x48, 0x13, 0xf0, 0x00, 
-	0x00, 0x04, 0x88, 0x13, 0xf4, 0x95, 0xf4, 0x95, 
-	0xe5, 0x98, 0x6d, 0x91, 0xf6, 0xb8, 0x48, 0x11, 
-	0x08, 0xf8, 0x2a, 0x3c, 0xf8, 0x43, 0x05, 0x3a, 
-	0xf0, 0x20, 0x2a, 0x39, 0x49, 0x11, 0xf5, 0x00, 
-	0x89, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x76, 0xe1, 
-	0x00, 0x04, 0x00, 0xaa, 0xf0, 0x74, 0x02, 0x98, 
-	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0x77, 0x11, 
-	0x2a, 0x39, 0x76, 0x81, 0x00, 0x55, 0x77, 0x12, 
-	0x2a, 0x18, 0x10, 0xe2, 0x00, 0x01, 0x80, 0xe1, 
-	0x00, 0x01, 0x10, 0xe2, 0x00, 0x02, 0x80, 0xe1, 
-	0x00, 0x02, 0x76, 0xe1, 0x00, 0x03, 0x00, 0x0c, 
-	0x48, 0x11, 0xf0, 0x00, 0x00, 0x04, 0x88, 0x12, 
-	0xf4, 0x95, 0x77, 0x13, 0x2a, 0x7a, 0xe9, 0x00, 
-	0xe5, 0x98, 0xf3, 0x00, 0x00, 0x01, 0xf6, 0xb8, 
-	0x48, 0x0b, 0x08, 0xf8, 0x2a, 0x3c, 0xf8, 0x43, 
-	0x05, 0x6a, 0x76, 0x82, 0x00, 0xaa, 0xf0, 0x74, 
-	0x02, 0x98, 0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 
-	0x77, 0x11, 0x2a, 0x39, 0x76, 0x81, 0x00, 0x55, 
-	0x77, 0x12, 0x2a, 0x18, 0x10, 0xe2, 0x00, 0x01, 
-	0x80, 0xe1, 0x00, 0x01, 0x10, 0xe2, 0x00, 0x02, 
-	0x80, 0xe1, 0x00, 0x02, 0x76, 0xe1, 0x00, 0x03, 
-	0x00, 0x19, 0x48, 0x11, 0xf0, 0x00, 0x00, 0x04, 
-	0x88, 0x12, 0xf4, 0x95, 0x77, 0x13, 0x2a, 0x5d, 
-	0xe9, 0x00, 0xe5, 0x98, 0xf3, 0x00, 0x00, 0x01, 
-	0xf6, 0xb8, 0x48, 0x0b, 0x08, 0xf8, 0x2a, 0x3c, 
-	0xf8, 0x43, 0x05, 0x93, 0x76, 0x82, 0x00, 0xaa, 
-	0xf0, 0x74, 0x02, 0x98, 0x8a, 0x11, 0xfc, 0x00, 
-	0x4a, 0x11, 0x88, 0x11, 0x10, 0xf8, 0x2a, 0x38, 
-	0xf8, 0x44, 0x05, 0xe3, 0x10, 0xf8, 0x2a, 0xa1, 
-	0xf8, 0x44, 0x05, 0xba, 0x6c, 0xe1, 0xff, 0x56, 
-	0x05, 0xe3, 0x72, 0x12, 0x2a, 0xa1, 0xf4, 0x95, 
-	0x70, 0xe2, 0x2a, 0x18, 0x00, 0x11, 0x6b, 0xf8, 
-	0x2a, 0xa1, 0x00, 0x01, 0xf0, 0x73, 0x05, 0xe3, 
-	0x72, 0x12, 0x2a, 0xa1, 0xf4, 0x95, 0x70, 0xe2, 
-	0x2a, 0x18, 0x00, 0x11, 0x10, 0xf8, 0x2a, 0xa1, 
-	0xf0, 0x00, 0x00, 0x01, 0x88, 0x12, 0xf4, 0x95, 
-	0xf4, 0x95, 0x6e, 0xe2, 0xff, 0xfc, 0x05, 0xd1, 
-	0x73, 0x12, 0x2a, 0xa1, 0x48, 0x11, 0xf0, 0x00, 
-	0x00, 0x05, 0x80, 0xf8, 0x2a, 0xa2, 0x10, 0xf8, 
-	0x2a, 0xa1, 0x08, 0xf8, 0x2a, 0xa2, 0xf8, 0x44, 
-	0x05, 0xe3, 0x6c, 0xe1, 0xff, 0xab, 0x05, 0xdd, 
-	0x76, 0xf8, 0x2a, 0x38, 0x00, 0x01, 0x76, 0xf8, 
-	0x2a, 0xa1, 0x00, 0x00, 0x76, 0xf8, 0x2a, 0xa2, 
-	0x00, 0x00, 0x8a, 0x11, 0xfc, 0x00, 0xf4, 0x95, 
-	0x4a, 0x08, 0x4a, 0x09, 0x4a, 0x0a, 0x4a, 0x0b, 
-	0x4a, 0x0c, 0x4a, 0x0d, 0x4a, 0x10, 0x4a, 0x11, 
-	0x4a, 0x12, 0x4a, 0x13, 0x4a, 0x14, 0x4a, 0x15, 
-	0x4a, 0x16, 0x4a, 0x17, 0x4a, 0x17, 0x4a, 0x19, 
-	0x4a, 0x0e, 0x4a, 0x06, 0x4a, 0x07, 0x4a, 0x1a, 
-	0x4a, 0x1d, 0x4a, 0x1b, 0x4a, 0x1c, 0x68, 0xf8, 
-	0x00, 0x07, 0x7d, 0x3f, 0x69, 0xf8, 0x00, 0x07, 
-	0x40, 0x00, 0x68, 0xf8, 0x00, 0x1d, 0xff, 0xfc, 
-	0x48, 0x18, 0x68, 0xf8, 0x00, 0x18, 0xff, 0xfe, 
-	0xf4, 0x95, 0xf4, 0x95, 0x4a, 0x08, 0xee, 0xff, 
-	0x10, 0xf8, 0x2a, 0x5b, 0xf9, 0x80, 0x18, 0x04, 
-	0xf0, 0x74, 0x05, 0xa2, 0xee, 0x01, 0x8a, 0x18, 
-	0xf4, 0x95, 0x8a, 0x1c, 0x8a, 0x1b, 0x8a, 0x1d, 
-	0x8a, 0x1a, 0x8a, 0x07, 0x8a, 0x06, 0x8a, 0x0e, 
-	0x8a, 0x19, 0x8a, 0x17, 0x8a, 0x17, 0x8a, 0x16, 
-	0x8a, 0x15, 0x8a, 0x14, 0x8a, 0x13, 0x8a, 0x12, 
-	0x8a, 0x11, 0x8a, 0x10, 0x8a, 0x0d, 0x8a, 0x0c, 
-	0x8a, 0x0b, 0x8a, 0x0a, 0x8a, 0x09, 0x8a, 0x08, 
-	0xf4, 0xeb, 0xee, 0xfd, 0x76, 0xf8, 0x2a, 0x38, 
-	0x00, 0x00, 0x76, 0xf8, 0x2a, 0x5a, 0x00, 0x00, 
-	0xe8, 0x01, 0x4e, 0x00, 0xfb, 0x80, 0x17, 0xd6, 
-	0xf4, 0x95, 0xe8, 0x01, 0x80, 0xf8, 0x2a, 0x5b, 
-	0x76, 0x00, 0x2a, 0x8f, 0xf9, 0x80, 0x16, 0xaa, 
-	0x10, 0xf8, 0x2a, 0x5b, 0xf9, 0x80, 0x17, 0x5c, 
-	0x10, 0xf8, 0x2a, 0x5b, 0xf9, 0x80, 0x17, 0x6f, 
-	0xfb, 0x80, 0x16, 0x66, 0xf4, 0x95, 0xe8, 0x1a, 
-	0xfb, 0x80, 0x16, 0x87, 0xf4, 0x95, 0xe8, 0x1a, 
-	0xfb, 0x80, 0x16, 0x66, 0xf4, 0x95, 0xe8, 0x1b, 
-	0xfb, 0x80, 0x16, 0x87, 0xf4, 0x95, 0xe8, 0x1b, 
-	0xee, 0x03, 0xfc, 0x00, 0x4a, 0x11, 0xf4, 0x95, 
-	0x13, 0x02, 0x88, 0x11, 0xe8, 0x00, 0xf8, 0x4d, 
-	0x06, 0x6a, 0xf3, 0x10, 0x00, 0x01, 0x89, 0x1a, 
-	0xf4, 0x95, 0xf0, 0x72, 0x06, 0x69, 0x1c, 0x91, 
-	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0x88, 0x11, 
-	0x12, 0x03, 0x11, 0x02, 0xf8, 0x45, 0x06, 0x79, 
-	0xf0, 0x10, 0x00, 0x01, 0x88, 0x1a, 0xf4, 0x95, 
-	0xf0, 0x72, 0x06, 0x78, 0x81, 0x91, 0x8a, 0x11, 
-	0xfc, 0x00, 0x4a, 0x11, 0xf4, 0x95, 0x71, 0x02, 
-	0x00, 0x11, 0x11, 0x03, 0x61, 0xf8, 0x00, 0x11, 
-	0x00, 0x01, 0xf8, 0x30, 0x06, 0x91, 0xf6, 0xb8, 
-	0x6f, 0xf8, 0x00, 0x11, 0x0c, 0x1f, 0x88, 0x11, 
-	0xf3, 0xe8, 0xe8, 0xff, 0x18, 0x81, 0xf1, 0xa0, 
-	0x81, 0x81, 0xf0, 0x73, 0x06, 0x9d, 0xf6, 0xb8, 
-	0x6f, 0xf8, 0x00, 0x11, 0x0c, 0x1f, 0x88, 0x11, 
-	0xf3, 0x30, 0x00, 0xff, 0xf0, 0x20, 0xff, 0x00, 
-	0x18, 0x81, 0xf1, 0xa0, 0x81, 0x81, 0x8a, 0x11, 
-	0xfc, 0x00, 0x4a, 0x11, 0xf4, 0x95, 0x11, 0x02, 
-	0x61, 0xf8, 0x00, 0x0b, 0x00, 0x01, 0xf8, 0x20, 
-	0x06, 0xb1, 0x49, 0x0b, 0xf6, 0x1f, 0x88, 0x11, 
-	0xf4, 0x95, 0xf4, 0x95, 0x10, 0x81, 0xf2, 0x73, 
-	0x06, 0xb8, 0xf0, 0x30, 0x00, 0xff, 0x49, 0x0b, 
-	0xf6, 0x1f, 0x88, 0x11, 0xf4, 0x95, 0xf4, 0x95, 
-	0x12, 0x81, 0xf4, 0x78, 0x8a, 0x11, 0xfc, 0x00, 
-	0x4a, 0x11, 0xf4, 0x95, 0x71, 0x02, 0x00, 0x12, 
-	0x13, 0x03, 0x88, 0x11, 0xe8, 0x00, 0xf8, 0x4d, 
-	0x06, 0xcc, 0xf3, 0x10, 0x00, 0x01, 0x89, 0x1a, 
-	0xf4, 0x95, 0xf0, 0x72, 0x06, 0xcb, 0x11, 0x92, 
-	0xf2, 0xc0, 0x81, 0x91, 0x8a, 0x11, 0xfc, 0x00, 
-	0x88, 0x12, 0x12, 0x02, 0x71, 0x01, 0x00, 0x13, 
-	0xf8, 0x45, 0x06, 0xdb, 0xf0, 0x10, 0x00, 0x01, 
-	0x88, 0x1a, 0xf4, 0x95, 0xf0, 0x72, 0x06, 0xda, 
-	0xe5, 0x98, 0xfc, 0x00, 0x4a, 0x11, 0xee, 0xfe, 
-	0x88, 0x11, 0x11, 0x04, 0x10, 0x06, 0x71, 0x05, 
-	0x00, 0x12, 0x61, 0xf8, 0x00, 0x12, 0x00, 0x01, 
-	0xf8, 0x20, 0x06, 0xea, 0xf0, 0x00, 0x00, 0x01, 
-	0xf6, 0xb8, 0xf0, 0x00, 0x00, 0x01, 0x6f, 0xf8, 
-	0x00, 0x12, 0x0f, 0x1f, 0x48, 0x08, 0x81, 0x00, 
-	0xf4, 0x7f, 0x80, 0x01, 0xf2, 0x74, 0x06, 0xba, 
-	0xf4, 0x95, 0x48, 0x11, 0xee, 0x02, 0x8a, 0x11, 
-	0xfc, 0x00, 0x4a, 0x11, 0xee, 0xfe, 0x88, 0x12, 
-	0x11, 0x04, 0x10, 0x06, 0x71, 0x05, 0x00, 0x13, 
-	0x61, 0xf8, 0x00, 0x13, 0x00, 0x01, 0xf8, 0x20, 
-	0x07, 0x09, 0xf0, 0x00, 0x00, 0x01, 0xf0, 0x00, 
-	0x00, 0x01, 0x88, 0x11, 0xf6, 0xb8, 0x6f, 0xf8, 
-	0x00, 0x13, 0x0f, 0x1f, 0x81, 0x00, 0x48, 0x11, 
-	0xf4, 0x7f, 0x80, 0x01, 0xf2, 0x74, 0x06, 0xce, 
-	0xf4, 0x95, 0x48, 0x12, 0x48, 0x11, 0xf0, 0x30, 
-	0xff, 0xfe, 0xee, 0x02, 0x8a, 0x11, 0xfc, 0x00, 
-	0x4a, 0x11, 0x4a, 0x16, 0x4a, 0x17, 0xee, 0xfc, 
-	0xf4, 0x95, 0x80, 0x02, 0x71, 0x08, 0x00, 0x16, 
-	0x10, 0x09, 0x71, 0x0b, 0x00, 0x17, 0x80, 0x03, 
-	0x71, 0x0a, 0x00, 0x11, 0x48, 0x17, 0xf8, 0x45, 
-	0x07, 0x3f, 0x70, 0x00, 0x00, 0x11, 0x10, 0x03, 
-	0xf0, 0x74, 0x06, 0x9f, 0x80, 0x01, 0x70, 0x00, 
-	0x00, 0x16, 0x10, 0x02, 0xf0, 0x74, 0x06, 0x7b, 
-	0x6d, 0x91, 0x6d, 0x96, 0x6c, 0xef, 0xff, 0xff, 
-	0x07, 0x2f, 0xee, 0x04, 0x8a, 0x17, 0x8a, 0x16, 
-	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0xee, 0xfe, 
-	0x10, 0xf8, 0x2a, 0xe8, 0x08, 0xf8, 0x2a, 0xe9, 
-	0xf8, 0x45, 0x07, 0x64, 0x76, 0x00, 0x00, 0x01, 
-	0x62, 0xf8, 0x2a, 0xe9, 0x00, 0x5e, 0xf2, 0x74, 
-	0x12, 0x0b, 0xf0, 0x00, 0x30, 0x40, 0x72, 0x11, 
-	0x2a, 0xe9, 0x77, 0x10, 0x00, 0x0f, 0xf5, 0xa9, 
-	0xf8, 0x20, 0x07, 0x61, 0x6b, 0xf8, 0x2a, 0xe9, 
-	0x00, 0x01, 0xf0, 0x73, 0x07, 0x64, 0x76, 0xf8, 
-	0x2a, 0xe9, 0x00, 0x00, 0xee, 0x02, 0x8a, 0x11, 
-	0xfc, 0x00, 0x4a, 0x11, 0x88, 0x11, 0xe8, 0x00, 
-	0x75, 0xf8, 0x00, 0x08, 0x00, 0x08, 0xe8, 0x00, 
-	0x75, 0xf8, 0x00, 0x08, 0x00, 0x09, 0xf6, 0xb8, 
-	0xf4, 0x95, 0xf0, 0x20, 0xfc, 0x3f, 0x75, 0xf8, 
-	0x00, 0x08, 0x00, 0x0d, 0xf0, 0x20, 0x0c, 0x30, 
-	0x75, 0xf8, 0x00, 0x08, 0x00, 0x0c, 0x76, 0xf8, 
-	0x2a, 0xe8, 0x00, 0x00, 0x76, 0xf8, 0x2a, 0xe9, 
-	0x00, 0x00, 0x6c, 0x81, 0x07, 0x92, 0x76, 0xf8, 
-	0x2a, 0xea, 0x00, 0x00, 0xfb, 0x80, 0x16, 0x76, 
-	0xf4, 0x95, 0xe8, 0x10, 0xe8, 0x00, 0x75, 0xf8, 
-	0x00, 0x08, 0x00, 0x00, 0xf0, 0x73, 0x07, 0xa8, 
-	0x76, 0xf8, 0x2a, 0xea, 0x00, 0x01, 0xfb, 0x80, 
-	0x16, 0x66, 0xf4, 0x95, 0xe8, 0x10, 0xfb, 0x80, 
-	0x16, 0x87, 0xf4, 0x95, 0xe8, 0x10, 0xe8, 0x00, 
-	0x75, 0xf8, 0x00, 0x08, 0x00, 0x00, 0xf6, 0xb8, 
-	0xf4, 0x95, 0xf0, 0x20, 0xff, 0xff, 0x75, 0xf8, 
-	0x00, 0x08, 0x00, 0x00, 0x8a, 0x11, 0xfc, 0x00, 
-	0xf4, 0x95, 0x4a, 0x08, 0x4a, 0x09, 0x4a, 0x0a, 
-	0x4a, 0x06, 0x4a, 0x07, 0x4a, 0x1d, 0x68, 0xf8, 
-	0x00, 0x07, 0x7d, 0x3f, 0x69, 0xf8, 0x00, 0x07, 
-	0x40, 0x00, 0x68, 0xf8, 0x00, 0x1d, 0xff, 0xfc, 
-	0x10, 0xf8, 0x2a, 0xea, 0xf8, 0x45, 0x07, 0xe1, 
-	0x10, 0xf8, 0x2a, 0xe8, 0xf0, 0x00, 0x00, 0x01, 
-	0xf0, 0x30, 0x00, 0x0f, 0x80, 0xf8, 0x2a, 0xe8, 
-	0x10, 0xf8, 0x2a, 0xe8, 0xf8, 0x44, 0x07, 0xd6, 
-	0xf6, 0xb8, 0xf4, 0x95, 0xf0, 0x20, 0xfc, 0x3f, 
-	0x75, 0xf8, 0x00, 0x08, 0x00, 0x0d, 0xf0, 0x20, 
-	0x0c, 0x30, 0x75, 0xf8, 0x00, 0x08, 0x00, 0x0c, 
-	0xe8, 0x00, 0x75, 0xf8, 0x00, 0x08, 0x00, 0x00, 
-	0xf6, 0xb8, 0xf4, 0x95, 0xf0, 0x20, 0xff, 0xff, 
-	0x75, 0xf8, 0x00, 0x08, 0x00, 0x00, 0x8a, 0x1d, 
-	0x8a, 0x07, 0x8a, 0x06, 0x8a, 0x0a, 0x8a, 0x09, 
-	0x8a, 0x08, 0xf4, 0xeb, 0xee, 0xff, 0xf2, 0x74, 
-	0x07, 0x67, 0xf4, 0x95, 0xe8, 0x01, 0xee, 0x01, 
-	0xfc, 0x00, 0x4a, 0x07, 0x4a, 0x1d, 0x68, 0xf8, 
-	0x00, 0x07, 0x7d, 0x3f, 0x69, 0xf8, 0x00, 0x07, 
-	0x40, 0x00, 0x68, 0xf8, 0x00, 0x1d, 0xff, 0xfc, 
-	0x8a, 0x1d, 0x8a, 0x07, 0xf4, 0xeb, 0x4a, 0x11, 
-	0x77, 0x11, 0x00, 0x28, 0x76, 0x81, 0x24, 0x00, 
-	0xe8, 0x00, 0x75, 0xf8, 0x00, 0x08, 0x00, 0x01, 
-	0xf2, 0x74, 0x07, 0x67, 0xf4, 0x95, 0xe8, 0x00, 
-	0x77, 0x11, 0x00, 0x1d, 0x68, 0x81, 0x00, 0x7f, 
-	0xf6, 0xb8, 0xf4, 0x95, 0xf0, 0x20, 0xff, 0x80, 
-	0x77, 0x11, 0x00, 0x1d, 0xf0, 0x30, 0x01, 0x00, 
-	0x1a, 0x81, 0x80, 0x81, 0xf0, 0x74, 0x0a, 0x33, 
-	0xf0, 0x74, 0x11, 0xac, 0xf9, 0x80, 0x13, 0x25, 
-	0xf9, 0x80, 0x16, 0x53, 0xf9, 0x80, 0x17, 0x82, 
-	0xf0, 0x74, 0x06, 0x2f, 0xf9, 0x80, 0x14, 0xb2, 
-	0xf9, 0x80, 0x19, 0x10, 0xf0, 0x74, 0x0d, 0xe3, 
-	0xf0, 0x74, 0x07, 0xe8, 0xf0, 0x74, 0x02, 0x36, 
-	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0x60, 0xf8, 
-	0x27, 0x7b, 0xff, 0xff, 0xf8, 0x30, 0x08, 0x39, 
-	0x71, 0xf8, 0x27, 0x7b, 0x27, 0x79, 0x60, 0xf8, 
-	0x27, 0x79, 0xff, 0xff, 0xf8, 0x30, 0x08, 0xb2, 
-	0x10, 0xf8, 0x29, 0x86, 0x08, 0xf8, 0x27, 0x79, 
-	0xf0, 0x30, 0x7f, 0xff, 0x88, 0x11, 0xf4, 0x95, 
-	0x77, 0x10, 0x40, 0x00, 0xf6, 0xa9, 0xf8, 0x30, 
-	0x08, 0x58, 0x10, 0xf8, 0x27, 0x79, 0x08, 0xf8, 
-	0x27, 0x7a, 0xf0, 0x30, 0x7f, 0xff, 0x88, 0x11, 
-	0xf4, 0x95, 0x77, 0x10, 0x40, 0x00, 0xf6, 0xa9, 
-	0xf8, 0x20, 0x08, 0x63, 0x76, 0xf8, 0x27, 0x79, 
-	0xff, 0xff, 0x76, 0xf8, 0x27, 0x7b, 0xff, 0xff, 
-	0xf7, 0xb8, 0xf2, 0x73, 0x08, 0xd9, 0xf0, 0x20, 
-	0xff, 0xff, 0xf6, 0xb8, 0x56, 0xf8, 0x27, 0x74, 
-	0xf0, 0xf9, 0x88, 0x11, 0x56, 0xf8, 0x27, 0x72, 
-	0xf0, 0xf9, 0x88, 0x12, 0xf4, 0x95, 0xf4, 0x95, 
-	0xe7, 0x20, 0xf4, 0xa9, 0xf8, 0x30, 0x08, 0x8f, 
-	0xf1, 0x20, 0x27, 0x7c, 0x48, 0x11, 0xf6, 0x00, 
-	0x88, 0x13, 0xf4, 0x95, 0xf4, 0x95, 0x10, 0x83, 
-	0x08, 0xf8, 0x27, 0x79, 0xf0, 0x30, 0x7f, 0xff, 
-	0x88, 0x13, 0xf4, 0x95, 0x77, 0x10, 0x40, 0x00, 
-	0xf5, 0xab, 0xf8, 0x30, 0x08, 0x8f, 0x6d, 0x91, 
-	0x48, 0x11, 0xf0, 0x30, 0x01, 0xff, 0x88, 0x11, 
-	0xf4, 0x95, 0xe7, 0x20, 0xf7, 0xa9, 0xf8, 0x30, 
-	0x08, 0x74, 0x6d, 0x89, 0x48, 0x11, 0xf0, 0x30, 
-	0x01, 0xff, 0xf0, 0xe7, 0xf4, 0x95, 0x48, 0x08, 
-	0x4e, 0xf8, 0x27, 0x74, 0x48, 0x08, 0xf1, 0xf9, 
-	0x89, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x71, 0xe1, 
-	0x27, 0x7c, 0x27, 0x7a, 0x60, 0xf8, 0x27, 0x7b, 
-	0xff, 0xff, 0xf8, 0x30, 0x08, 0xab, 0x48, 0x08, 
-	0x4e, 0xf8, 0x27, 0x72, 0x76, 0xf8, 0x27, 0x7b, 
-	0xff, 0xff, 0x76, 0xf8, 0x27, 0x79, 0xff, 0xff, 
-	0xf2, 0x73, 0x08, 0xd9, 0xf4, 0x95, 0xe8, 0x00, 
-	0x44, 0xf8, 0x27, 0x73, 0x40, 0xf8, 0x27, 0x75, 
-	0x82, 0xf8, 0x00, 0x11, 0xf4, 0x95, 0x77, 0x10, 
-	0x80, 0x00, 0xf6, 0xa9, 0xf8, 0x20, 0x08, 0xd8, 
-	0xf6, 0xb8, 0x10, 0xf8, 0x27, 0x73, 0xf0, 0x00, 
-	0x80, 0x00, 0x48, 0x08, 0x4e, 0xf8, 0x27, 0x74, 
-	0x48, 0x08, 0xf0, 0xf9, 0x88, 0x11, 0xf4, 0x95, 
-	0xf4, 0x95, 0x71, 0xe1, 0x27, 0x7c, 0x27, 0x7a, 
-	0xf7, 0xb8, 0x57, 0xf8, 0x27, 0x74, 0xf0, 0x62, 
-	0xff, 0xff, 0xf0, 0x40, 0xff, 0x80, 0xf2, 0x80, 
-	0x4e, 0xf8, 0x27, 0x74, 0xe8, 0x00, 0x8a, 0x11, 
-	0xfc, 0x00, 0x4a, 0x11, 0x4a, 0x16, 0xee, 0xfb, 
-	0x11, 0xf8, 0x27, 0x71, 0x09, 0xf8, 0x27, 0x73, 
-	0x89, 0x11, 0x88, 0x10, 0xf4, 0x95, 0xf4, 0x95, 
-	0xf6, 0xa9, 0xf8, 0x20, 0x08, 0xed, 0xf2, 0x73, 
-	0x09, 0x0e, 0xf4, 0x95, 0xe8, 0x00, 0xf6, 0x20, 
-	0x76, 0x00, 0x00, 0x41, 0xf0, 0x74, 0x12, 0xee, 
-	0x88, 0x16, 0xf4, 0x95, 0xf7, 0xb8, 0x6d, 0x96, 
-	0x10, 0xf8, 0x00, 0x16, 0xf8, 0x47, 0x09, 0x0a, 
-	0xe7, 0x61, 0x76, 0x00, 0x00, 0x00, 0x76, 0x01, 
-	0x00, 0x80, 0x76, 0x02, 0x00, 0xff, 0x76, 0x03, 
-	0x00, 0x00, 0xf2, 0x74, 0x0c, 0xb9, 0xf4, 0x95, 
-	0xe8, 0x00, 0x6c, 0xe9, 0xff, 0xff, 0x08, 0xfb, 
-	0x73, 0x16, 0x00, 0x0e, 0xf0, 0x66, 0x00, 0x41, 
-	0xee, 0x05, 0x8a, 0x16, 0x8a, 0x11, 0xfc, 0x00, 
-	0x4a, 0x11, 0xf4, 0x95, 0x71, 0x02, 0x00, 0x13, 
-	0xf6, 0xb8, 0x77, 0x11, 0x7f, 0xff, 0x57, 0xf8, 
-	0x27, 0x72, 0x48, 0x11, 0xf2, 0x80, 0xf0, 0x00, 
-	0x80, 0x00, 0x88, 0x11, 0xf6, 0x40, 0xf0, 0xe0, 
-	0xf1, 0xf1, 0xe8, 0x01, 0xf2, 0x80, 0x80, 0xf8, 
-	0x27, 0x78, 0x77, 0x12, 0x80, 0x00, 0x57, 0xf8, 
-	0x27, 0x72, 0x48, 0x12, 0xf2, 0x80, 0x88, 0x12, 
-	0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x82, 0x09, 0x38, 
-	0xe8, 0x00, 0x75, 0xf8, 0x00, 0x08, 0x00, 0x01, 
-	0xf0, 0x73, 0x09, 0x3d, 0xf0, 0x20, 0x80, 0x01, 
-	0x75, 0xf8, 0x00, 0x08, 0x00, 0x01, 0x70, 0x81, 
-	0x00, 0x13, 0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 
-	0xf0, 0x30, 0x7f, 0xff, 0x11, 0xf8, 0x29, 0x86, 
-	0xf5, 0x20, 0xf3, 0x30, 0x7f, 0xff, 0x89, 0x11, 
-	0xf4, 0x95, 0x77, 0x10, 0x40, 0x00, 0xf6, 0xa9, 
-	0xf8, 0x20, 0x09, 0x54, 0xf2, 0x73, 0x09, 0x67, 
-	0xf4, 0x95, 0xe8, 0x02, 0x6f, 0xf8, 0x27, 0x7a, 
-	0x0d, 0x20, 0xf3, 0x30, 0x7f, 0xff, 0x89, 0x11, 
-	0xf4, 0x95, 0x77, 0x10, 0x40, 0x00, 0xf6, 0xa9, 
-	0xf8, 0x20, 0x09, 0x64, 0xf2, 0x73, 0x09, 0x67, 
-	0xf4, 0x95, 0xe8, 0x01, 0x80, 0xf8, 0x27, 0x7b, 
-	0xe8, 0x00, 0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 
-	0x11, 0xf8, 0x29, 0x86, 0xf5, 0x20, 0xf3, 0x30, 
-	0x7f, 0xff, 0x89, 0x11, 0xf4, 0x95, 0x77, 0x10, 
-	0x40, 0x00, 0xf6, 0xa9, 0xf8, 0x20, 0x09, 0x7a, 
-	0xf2, 0x73, 0x09, 0x8d, 0xf4, 0x95, 0xe8, 0x02, 
-	0x6f, 0xf8, 0x27, 0x7a, 0x0d, 0x20, 0xf3, 0x30, 
-	0x7f, 0xff, 0x89, 0x11, 0xf4, 0x95, 0x77, 0x10, 
-	0x40, 0x00, 0xf6, 0xa9, 0xf8, 0x20, 0x09, 0x8a, 
-	0xf2, 0x73, 0x09, 0x8d, 0xf4, 0x95, 0xe8, 0x01, 
-	0x80, 0xf8, 0x27, 0x79, 0xe8, 0x00, 0x8a, 0x11, 
-	0xfc, 0x00, 0x4a, 0x11, 0xf4, 0x95, 0x71, 0x02, 
-	0x00, 0x12, 0x88, 0x11, 0xf6, 0xb8, 0x57, 0xf8, 
-	0x27, 0x72, 0xf0, 0x20, 0x7f, 0xff, 0xf2, 0x80, 
-	0xf0, 0x00, 0x80, 0x00, 0x80, 0x81, 0x57, 0xf8, 
-	0x27, 0x72, 0xe8, 0x01, 0xf3, 0xf1, 0xf2, 0x80, 
-	0x80, 0xf8, 0x27, 0x78, 0x77, 0x11, 0x80, 0x00, 
-	0x48, 0x11, 0x57, 0xf8, 0x27, 0x72, 0xf2, 0x80, 
-	0x88, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x81, 
-	0x09, 0xb5, 0xe8, 0x00, 0x75, 0xf8, 0x00, 0x08, 
-	0x00, 0x01, 0xf0, 0x73, 0x09, 0xba, 0xf0, 0x20, 
-	0x80, 0x01, 0x75, 0xf8, 0x00, 0x08, 0x00, 0x01, 
-	0x45, 0xf8, 0x27, 0x71, 0x43, 0xf8, 0x27, 0x73, 
-	0x83, 0xf8, 0x00, 0x11, 0xf4, 0x95, 0xe7, 0x20, 
-	0xf6, 0xa9, 0xf8, 0x30, 0x09, 0xc9, 0xf2, 0x73, 
-	0x09, 0xe4, 0x77, 0x12, 0x00, 0x00, 0x57, 0xf8, 
-	0x27, 0x72, 0xf0, 0x20, 0x7f, 0xff, 0xf2, 0x80, 
-	0x49, 0x12, 0xf5, 0x00, 0xf3, 0x00, 0x80, 0x00, 
-	0x61, 0xf8, 0x00, 0x0b, 0x80, 0x00, 0xf8, 0x30, 
-	0x09, 0xdc, 0xf1, 0x20, 0x80, 0x00, 0xf5, 0x20, 
-	0x89, 0x12, 0xf4, 0x95, 0x48, 0x12, 0x6f, 0xf8, 
-	0x27, 0x73, 0x0d, 0x00, 0xf4, 0x95, 0x49, 0x0b, 
-	0x4f, 0xf8, 0x27, 0x72, 0x8a, 0x11, 0xfe, 0x00, 
-	0x48, 0x12, 0xf4, 0x95, 0x4a, 0x11, 0x4a, 0x16, 
-	0x4a, 0x17, 0xee, 0xfc, 0xf4, 0x95, 0x71, 0x08, 
-	0x00, 0x16, 0x88, 0x17, 0xf0, 0x74, 0x08, 0x30, 
-	0x48, 0x18, 0x70, 0x00, 0x00, 0x16, 0xf2, 0x74, 
-	0x09, 0x8f, 0xf0, 0x00, 0x00, 0x02, 0x88, 0x11, 
-	0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x81, 0x0a, 0x0a, 
-	0xf2, 0x74, 0x08, 0xdb, 0xf4, 0x95, 0x48, 0x16, 
-	0x48, 0x18, 0x70, 0x00, 0x00, 0x16, 0xf2, 0x74, 
-	0x09, 0x8f, 0xf0, 0x00, 0x00, 0x02, 0x88, 0x11, 
-	0x10, 0x02, 0x70, 0x01, 0x00, 0x11, 0x80, 0x00, 
-	0xf2, 0x74, 0x06, 0xce, 0xf4, 0x95, 0x48, 0x17, 
-	0x49, 0x11, 0x48, 0x17, 0xf6, 0x00, 0x88, 0x17, 
-	0xe7, 0x60, 0xf5, 0xa9, 0xf8, 0x20, 0x0a, 0x2d, 
-	0x48, 0x16, 0xf6, 0x20, 0x88, 0x11, 0x48, 0x18, 
-	0x70, 0x00, 0x00, 0x11, 0xf2, 0x74, 0x09, 0x8f, 
-	0xf0, 0x00, 0x00, 0x02, 0x88, 0x11, 0x70, 0x01, 
-	0x00, 0x11, 0x10, 0x02, 0x80, 0x00, 0xf2, 0x74, 
-	0x06, 0xce, 0xf4, 0x95, 0x48, 0x17, 0xee, 0x04, 
-	0x48, 0x16, 0x8a, 0x17, 0x8a, 0x16, 0x8a, 0x11, 
-	0xfc, 0x00, 0xee, 0xfd, 0xe8, 0x00, 0x4e, 0xf8, 
-	0x27, 0x70, 0xe8, 0x00, 0x4e, 0xf8, 0x27, 0x72, 
-	0xe8, 0x00, 0x4e, 0xf8, 0x27, 0x74, 0xe8, 0x00, 
-	0x4e, 0xf8, 0x27, 0x76, 0x76, 0xf8, 0x27, 0x79, 
-	0xff, 0xff, 0x76, 0xf8, 0x27, 0x7a, 0x00, 0x00, 
-	0x76, 0xf8, 0x27, 0x7b, 0xff, 0xff, 0x76, 0xf8, 
-	0x27, 0x78, 0x00, 0x00, 0xe8, 0x00, 0x75, 0xf8, 
-	0x00, 0x08, 0x00, 0x01, 0x76, 0x00, 0x00, 0x00, 
-	0x76, 0x01, 0x02, 0x00, 0xf2, 0x74, 0x12, 0xdc, 
-	0xf0, 0x20, 0x27, 0x7c, 0xee, 0x03, 0xfc, 0x00, 
-	0x4a, 0x11, 0xee, 0xfc, 0xf4, 0x95, 0x4e, 0x00, 
-	0x77, 0x12, 0x7f, 0xff, 0xf6, 0xb8, 0x49, 0x12, 
-	0xf1, 0x80, 0xf3, 0x00, 0x80, 0x00, 0x89, 0x12, 
-	0xf0, 0xe0, 0xf1, 0xf1, 0x4f, 0x02, 0xe9, 0x01, 
-	0xf4, 0x95, 0x48, 0x0b, 0xf5, 0x40, 0x56, 0x02, 
-	0xf1, 0x80, 0x81, 0xf8, 0x27, 0x78, 0x77, 0x11, 
-	0x80, 0x00, 0x56, 0x00, 0x49, 0x11, 0xf1, 0x80, 
-	0x89, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x81, 
-	0x0a, 0x81, 0xe8, 0x00, 0x75, 0xf8, 0x00, 0x08, 
-	0x00, 0x01, 0xf0, 0x73, 0x0a, 0x86, 0xf0, 0x20, 
-	0x80, 0x01, 0x75, 0xf8, 0x00, 0x08, 0x00, 0x01, 
-	0x10, 0x82, 0xee, 0x04, 0x8a, 0x11, 0xfc, 0x00, 
-	0x4a, 0x11, 0xee, 0xfe, 0xf4, 0x95, 0x4e, 0x00, 
-	0x77, 0x11, 0x7f, 0xff, 0xf6, 0xb8, 0x49, 0x11, 
-	0xf1, 0x80, 0xf3, 0x00, 0x80, 0x00, 0x89, 0x11, 
-	0xf0, 0xe0, 0xf1, 0xf1, 0xe8, 0x01, 0xf2, 0x80, 
-	0x80, 0xf8, 0x27, 0x78, 0x56, 0x00, 0xf1, 0x20, 
-	0x80, 0x00, 0xf1, 0x80, 0xf4, 0x95, 0x49, 0x0b, 
-	0xf8, 0x4d, 0x0a, 0xab, 0xf0, 0x20, 0x80, 0x01, 
-	0x75, 0xf8, 0x00, 0x08, 0x00, 0x01, 0xf0, 0x73, 
-	0x0a, 0xaf, 0xe8, 0x00, 0x75, 0xf8, 0x00, 0x08, 
-	0x00, 0x01, 0xee, 0x02, 0x48, 0x11, 0x8a, 0x11, 
-	0xfc, 0x00, 0x4a, 0x11, 0x88, 0x12, 0x13, 0x02, 
-	0x77, 0x11, 0x00, 0x00, 0xf8, 0x4d, 0x0a, 0xcb, 
-	0xf3, 0x10, 0x00, 0x01, 0x89, 0x1a, 0xf4, 0x95, 
-	0xf0, 0x72, 0x0a, 0xca, 0x48, 0x11, 0x1c, 0xf8, 
-	0x29, 0x7e, 0x88, 0x11, 0x11, 0xf8, 0x29, 0x7e, 
-	0xf2, 0x00, 0x00, 0x01, 0x80, 0xf8, 0x29, 0x7e, 
-	0x81, 0x92, 0x48, 0x11, 0x8a, 0x11, 0xfc, 0x00, 
-	0x4a, 0x11, 0xf4, 0x95, 0x71, 0x02, 0x00, 0x11, 
-	0x88, 0x12, 0xf6, 0xb8, 0xf0, 0x20, 0x7f, 0xff, 
-	0x57, 0xf8, 0x27, 0x70, 0xf2, 0x80, 0xf0, 0x00, 
-	0x80, 0x00, 0x80, 0x82, 0x57, 0xf8, 0x27, 0x70, 
-	0xe8, 0x01, 0xf3, 0xf1, 0xf2, 0x80, 0x80, 0xf8, 
-	0x27, 0x78, 0x77, 0x12, 0x80, 0x00, 0x48, 0x12, 
-	0x57, 0xf8, 0x27, 0x70, 0xf2, 0x80, 0x88, 0x12, 
-	0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x82, 0x0a, 0xf4, 
-	0xe8, 0x00, 0x75, 0xf8, 0x00, 0x08, 0x00, 0x01, 
-	0xf0, 0x73, 0x0a, 0xf9, 0xf0, 0x20, 0x80, 0x01, 
-	0x75, 0xf8, 0x00, 0x08, 0x00, 0x01, 0x45, 0xf8, 
-	0x27, 0x75, 0xe7, 0x10, 0x43, 0xf8, 0x27, 0x71, 
-	0x83, 0xf8, 0x00, 0x12, 0x6d, 0xe8, 0x00, 0x04, 
-	0x6d, 0x8a, 0xf6, 0xaa, 0xf8, 0x30, 0x0b, 0x0a, 
-	0xf2, 0x73, 0x0b, 0x25, 0x77, 0x11, 0x00, 0x00, 
-	0x57, 0xf8, 0x27, 0x70, 0xf0, 0x20, 0x7f, 0xff, 
-	0xf2, 0x80, 0x49, 0x11, 0xf5, 0x00, 0xf3, 0x00, 
-	0x80, 0x00, 0x61, 0xf8, 0x00, 0x0b, 0x80, 0x00, 
-	0xf8, 0x30, 0x0b, 0x1d, 0xf1, 0x20, 0x80, 0x00, 
-	0xf5, 0x20, 0x89, 0x11, 0xf4, 0x95, 0x48, 0x11, 
-	0x6f, 0xf8, 0x27, 0x71, 0x0d, 0x00, 0xf4, 0x95, 
-	0x49, 0x0b, 0x4f, 0xf8, 0x27, 0x70, 0x48, 0x11, 
-	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0x4a, 0x16, 
-	0x4a, 0x17, 0xee, 0xf0, 0x88, 0x17, 0x10, 0x17, 
-	0x80, 0x05, 0x10, 0x16, 0x80, 0x06, 0x10, 0x15, 
-	0x80, 0x07, 0x71, 0x14, 0x00, 0x11, 0x10, 0x05, 
-	0xf0, 0x30, 0x00, 0x01, 0x88, 0x10, 0x10, 0x06, 
-	0xf0, 0x30, 0x00, 0x01, 0x80, 0x08, 0x49, 0x11, 
-	0x10, 0x05, 0xf6, 0x01, 0x80, 0x09, 0x10, 0x06, 
-	0x61, 0xf8, 0x00, 0x08, 0x00, 0x01, 0xf8, 0x20, 
-	0x0b, 0x4b, 0x10, 0x09, 0xf0, 0x00, 0x00, 0x01, 
-	0x80, 0x09, 0x71, 0x08, 0x00, 0x12, 0xf4, 0xaa, 
-	0xf8, 0x30, 0x0b, 0x54, 0x10, 0x09, 0xf0, 0x00, 
-	0x00, 0x01, 0x80, 0x09, 0x12, 0x09, 0x49, 0x11, 
-	0xf4, 0x7f, 0x80, 0x09, 0xf6, 0x20, 0x80, 0x0a, 
-	0x56, 0xf8, 0x27, 0x70, 0x4e, 0x0c, 0x10, 0x09, 
-	0x80, 0x00, 0x48, 0x18, 0xf2, 0x74, 0x0a, 0xce, 
-	0xf0, 0x00, 0x00, 0x04, 0x88, 0x16, 0xf4, 0x95, 
-	0xf4, 0x95, 0x6c, 0x86, 0x0b, 0x6d, 0xf2, 0x73, 
-	0x0c, 0x59, 0xf4, 0x95, 0xe8, 0x00, 0xf6, 0xb8, 
-	0xf4, 0x95, 0x56, 0x0c, 0xf0, 0xf9, 0x88, 0x12, 
-	0xf4, 0x95, 0xf4, 0x95, 0x70, 0xe2, 0x27, 0x7c, 
-	0x29, 0x86, 0xe8, 0x00, 0x80, 0x0e, 0x48, 0x11, 
-	0xf8, 0x45, 0x0b, 0xcc, 0x77, 0x10, 0x00, 0x01, 
-	0xf4, 0xa9, 0xf8, 0x30, 0x0b, 0x89, 0x6c, 0xe1, 
-	0xff, 0xfd, 0x0b, 0x8b, 0x10, 0xe7, 0x00, 0x02, 
-	0x80, 0x0e, 0xf0, 0x73, 0x0b, 0x8b, 0x10, 0x87, 
-	0x80, 0x0e, 0xe7, 0x10, 0xf5, 0xae, 0xf8, 0x20, 
-	0x0b, 0xb2, 0x70, 0x00, 0x00, 0x17, 0x70, 0x01, 
-	0x00, 0x16, 0x10, 0x04, 0xf0, 0x74, 0x06, 0xce, 
-	0x48, 0x17, 0x49, 0x16, 0xf6, 0x00, 0x88, 0x17, 
-	0x48, 0x11, 0xf6, 0x20, 0x88, 0x11, 0x10, 0x09, 
-	0xf6, 0x20, 0x80, 0x00, 0x48, 0x18, 0xf2, 0x74, 
-	0x0a, 0xce, 0xf0, 0x00, 0x00, 0x04, 0x88, 0x16, 
-	0x10, 0x04, 0x70, 0x00, 0x00, 0x17, 0x70, 0x01, 
-	0x00, 0x11, 0xf0, 0x74, 0x06, 0xce, 0x48, 0x11, 
-	0x00, 0x04, 0x80, 0x04, 0xf0, 0x73, 0x0b, 0xbc, 
-	0x70, 0x00, 0x00, 0x17, 0x70, 0x01, 0x00, 0x11, 
-	0x10, 0x04, 0xf0, 0x74, 0x06, 0xce, 0x48, 0x11, 
-	0x00, 0x04, 0x80, 0x04, 0x49, 0x11, 0x48, 0x16, 
-	0xf6, 0x20, 0x88, 0x16, 0xf4, 0x95, 0xf4, 0x95, 
-	0x6c, 0x86, 0x0b, 0xcc, 0x10, 0x0a, 0x80, 0x00, 
-	0x48, 0x18, 0xf2, 0x74, 0x0a, 0xce, 0xf0, 0x00, 
-	0x00, 0x04, 0x88, 0x16, 0x12, 0x0a, 0xf8, 0x45, 
-	0x0c, 0x33, 0x71, 0x0a, 0x00, 0x10, 0xf4, 0xae, 
-	0xf8, 0x30, 0x0c, 0x1c, 0x48, 0x16, 0xf0, 0xe1, 
-	0x88, 0x11, 0x12, 0x08, 0xf8, 0x45, 0x0b, 0xdb, 
-	0x6d, 0x89, 0x12, 0x07, 0xf8, 0x45, 0x0b, 0xe9, 
-	0x10, 0x07, 0x80, 0x00, 0x70, 0x02, 0x00, 0x11, 
-	0x10, 0x06, 0x80, 0x01, 0x10, 0x04, 0xf0, 0x74, 
-	0x06, 0xdc, 0xf0, 0x73, 0x0b, 0xef, 0x48, 0x11, 
-	0x6f, 0x00, 0x0c, 0x9f, 0x10, 0x04, 0xf0, 0x74, 
-	0x0a, 0xb3, 0x11, 0x0e, 0xf1, 0xc0, 0x81, 0x0e, 
-	0x10, 0x06, 0x49, 0x11, 0xf6, 0x00, 0x80, 0x06, 
-	0x10, 0x05, 0xf6, 0x20, 0x88, 0x11, 0xf0, 0x00, 
-	0x00, 0x01, 0x48, 0x08, 0x6f, 0x00, 0x0c, 0x9f, 
-	0x48, 0x18, 0xf2, 0x74, 0x0a, 0xce, 0xf0, 0x00, 
-	0x00, 0x04, 0x12, 0x07, 0xf8, 0x45, 0x0c, 0x11, 
-	0x10, 0x07, 0x80, 0x00, 0x70, 0x02, 0x00, 0x11, 
-	0x10, 0x06, 0x80, 0x01, 0x10, 0x04, 0xf0, 0x74, 
-	0x06, 0xdc, 0xf0, 0x73, 0x0c, 0x17, 0x48, 0x11, 
-	0x6f, 0x00, 0x0c, 0x9f, 0x10, 0x04, 0xf0, 0x74, 
-	0x0a, 0xb3, 0x11, 0x0e, 0xf1, 0xc0, 0x81, 0x0e, 
-	0xf0, 0x73, 0x0c, 0x33, 0x12, 0x07, 0xf8, 0x45, 
-	0x0c, 0x2a, 0x10, 0x07, 0x80, 0x00, 0x10, 0x06, 
-	0x80, 0x01, 0x10, 0x05, 0x80, 0x02, 0x10, 0x04, 
-	0xf0, 0x74, 0x06, 0xdc, 0xf0, 0x73, 0x0c, 0x30, 
-	0x12, 0x05, 0x6f, 0x00, 0x0c, 0x9f, 0x10, 0x04, 
-	0xf0, 0x74, 0x0a, 0xb3, 0x11, 0x0e, 0xf1, 0xc0, 
-	0x81, 0x0e, 0x76, 0x00, 0x00, 0x01, 0x48, 0x18, 
-	0xf2, 0x74, 0x0a, 0xce, 0xf0, 0x00, 0x00, 0x04, 
-	0x71, 0x04, 0x00, 0x11, 0x70, 0x81, 0x29, 0x86, 
-	0x10, 0x0e, 0x1c, 0xf8, 0x29, 0x86, 0x80, 0x0e, 
-	0x76, 0x00, 0x00, 0x01, 0x48, 0x18, 0xf2, 0x74, 
-	0x0a, 0xce, 0xf0, 0x00, 0x00, 0x04, 0x10, 0x0e, 
-	0x71, 0x04, 0x00, 0x11, 0x80, 0x81, 0x10, 0xf8, 
-	0x29, 0x86, 0xf0, 0x00, 0x00, 0x01, 0xf0, 0x30, 
-	0x7f, 0xff, 0x80, 0xf8, 0x29, 0x86, 0x10, 0x09, 
-	0xf0, 0x00, 0x00, 0x02, 0x80, 0x09, 0xee, 0x10, 
-	0x8a, 0x17, 0x8a, 0x16, 0x8a, 0x11, 0xfc, 0x00, 
-	0x10, 0xf8, 0x27, 0x75, 0x08, 0xf8, 0x27, 0x71, 
-	0xf0, 0x10, 0x00, 0x01, 0x48, 0x08, 0xfc, 0x00, 
-	0x4a, 0x11, 0x4a, 0x16, 0xee, 0xff, 0xf4, 0x95, 
-	0x71, 0x04, 0x00, 0x16, 0xf0, 0x00, 0x00, 0x01, 
-	0x48, 0x08, 0x4e, 0xf8, 0x29, 0x7c, 0x6d, 0xee, 
-	0xff, 0xfd, 0x48, 0x16, 0xf8, 0x45, 0x0c, 0x99, 
-	0x56, 0xf8, 0x29, 0x7c, 0xf0, 0x74, 0x0a, 0x5a, 
-	0x88, 0x11, 0x10, 0xf8, 0x29, 0x7d, 0xf0, 0x00, 
-	0x00, 0x01, 0x48, 0x08, 0x4e, 0xf8, 0x29, 0x7c, 
-	0x10, 0xf8, 0x29, 0x82, 0xf0, 0x00, 0x00, 0x01, 
-	0x88, 0x10, 0xf4, 0x95, 0xf4, 0x95, 0xf4, 0xa9, 
-	0xfa, 0x30, 0x0c, 0x96, 0x80, 0xf8, 0x29, 0x82, 
-	0x56, 0xf8, 0x29, 0x80, 0xf0, 0x00, 0x00, 0x01, 
-	0x4e, 0xf8, 0x29, 0x80, 0x73, 0x11, 0x29, 0x82, 
-	0x6c, 0xee, 0xff, 0xff, 0x0c, 0x76, 0xee, 0x01, 
-	0x8a, 0x16, 0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 
-	0x76, 0xf8, 0x29, 0x84, 0x00, 0x00, 0x76, 0xf8, 
-	0x29, 0x85, 0x00, 0x01, 0xe8, 0x00, 0x4e, 0xf8, 
-	0x2a, 0x0c, 0x76, 0xf8, 0x29, 0x86, 0x00, 0x00, 
-	0x76, 0xf8, 0x29, 0x87, 0x00, 0x00, 0x77, 0x11, 
-	0x29, 0x88, 0x76, 0x81, 0xaa, 0xaa, 0x76, 0xe1, 
-	0x00, 0x01, 0xaa, 0xaa, 0x76, 0xe1, 0x00, 0x02, 
-	0x00, 0x00, 0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 
-	0xee, 0xfc, 0xf4, 0x95, 0x71, 0x06, 0x00, 0x14, 
-	0x71, 0x07, 0x00, 0x13, 0x71, 0x08, 0x00, 0x12, 
-	0x71, 0x09, 0x00, 0x15, 0x77, 0x10, 0x00, 0xff, 
-	0xf4, 0xaa, 0xf8, 0x30, 0x0d, 0x44, 0x49, 0x13, 
-	0x53, 0xf8, 0x2a, 0x0c, 0x4f, 0xf8, 0x2a, 0x0c, 
-	0x73, 0x12, 0x00, 0x0e, 0xf1, 0x66, 0x00, 0x0d, 
-	0x89, 0x11, 0xf4, 0x95, 0x77, 0x10, 0x00, 0x01, 
-	0x71, 0xe1, 0x24, 0x00, 0x00, 0x11, 0xf4, 0xa9, 
-	0xf8, 0x30, 0x0d, 0x17, 0x77, 0x10, 0x00, 0x02, 
-	0xf4, 0xa9, 0xf8, 0x30, 0x0c, 0xec, 0x77, 0x11, 
-	0x29, 0x8a, 0x76, 0x81, 0x00, 0x00, 0xe8, 0x00, 
-	0x77, 0x14, 0x00, 0x00, 0x77, 0x13, 0x00, 0x00, 
-	0xf0, 0x73, 0x0d, 0x48, 0x6c, 0x83, 0x0c, 0xfa, 
-	0x77, 0x11, 0x29, 0x8a, 0x48, 0x12, 0xf0, 0xe8, 
-	0xf0, 0x40, 0x80, 0x00, 0x80, 0x81, 0xe8, 0x00, 
-	0x77, 0x14, 0x00, 0x00, 0xf0, 0x73, 0x0d, 0x48, 
-	0x49, 0x13, 0xf3, 0x40, 0x80, 0x00, 0x81, 0xf8, 
-	0x29, 0x8a, 0x61, 0xf8, 0x00, 0x15, 0x00, 0x01, 
-	0xf8, 0x20, 0x0d, 0x07, 0x69, 0xf8, 0x29, 0x8a, 
-	0x40, 0x00, 0x61, 0xf8, 0x00, 0x14, 0x00, 0x01, 
-	0xf8, 0x20, 0x0d, 0x0f, 0x69, 0xf8, 0x29, 0x8a, 
-	0x20, 0x00, 0x77, 0x11, 0x29, 0x8a, 0x49, 0x12, 
-	0xf3, 0xe8, 0x1b, 0x81, 0x81, 0x81, 0xf0, 0x73, 
-	0x0d, 0x48, 0x11, 0xf8, 0x29, 0x84, 0xf8, 0x4c, 
-	0x0d, 0x37, 0x77, 0x11, 0x29, 0x88, 0x76, 0x81, 
-	0xaa, 0xaa, 0x11, 0xf8, 0x29, 0x85, 0xf3, 0x10, 
-	0x00, 0x01, 0xf3, 0x40, 0xaa, 0x00, 0x81, 0xe1, 
-	0x00, 0x01, 0x76, 0x00, 0x00, 0x02, 0x80, 0x01, 
-	0x70, 0x02, 0x00, 0x14, 0x70, 0x03, 0x00, 0x13, 
-	0xf2, 0x74, 0x0b, 0x28, 0xf4, 0x95, 0x48, 0x11, 
-	0x71, 0xf8, 0x29, 0x85, 0x29, 0x84, 0xf0, 0x73, 
-	0x0d, 0x73, 0x76, 0x00, 0x00, 0x00, 0x80, 0x01, 
-	0x76, 0x02, 0x00, 0x00, 0x70, 0x03, 0x00, 0x13, 
-	0xf2, 0x74, 0x0b, 0x28, 0xf4, 0x95, 0xe8, 0x00, 
-	0xf0, 0x73, 0x0d, 0x73, 0x77, 0x11, 0x29, 0x8a, 
-	0x70, 0x81, 0x00, 0x13, 0x11, 0xf8, 0x29, 0x84, 
-	0xf8, 0x4c, 0x0d, 0x68, 0x77, 0x11, 0x29, 0x88, 
-	0x76, 0x81, 0xaa, 0xaa, 0x11, 0xf8, 0x29, 0x85, 
-	0xf3, 0x10, 0x00, 0x01, 0xf3, 0x40, 0xaa, 0x00, 
-	0x81, 0xe1, 0x00, 0x01, 0x76, 0x00, 0x00, 0x03, 
-	0x80, 0x01, 0x70, 0x02, 0x00, 0x14, 0x70, 0x03, 
-	0x00, 0x13, 0xf2, 0x74, 0x0b, 0x28, 0xf4, 0x95, 
-	0x48, 0x11, 0x71, 0xf8, 0x29, 0x85, 0x29, 0x84, 
-	0xf0, 0x73, 0x0d, 0x73, 0x76, 0x00, 0x00, 0x01, 
-	0x80, 0x01, 0x70, 0x02, 0x00, 0x14, 0x70, 0x03, 
-	0x00, 0x13, 0xf2, 0x74, 0x0b, 0x28, 0xf4, 0x95, 
-	0x48, 0x11, 0x6b, 0xf8, 0x29, 0x84, 0xff, 0xff, 
-	0xee, 0x04, 0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 
-	0xf5, 0x40, 0xf4, 0x95, 0x48, 0x0b, 0xf4, 0x78, 
-	0x88, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x6c, 0xe1, 
-	0xff, 0xb9, 0x0d, 0x88, 0xf2, 0x73, 0x0d, 0xa5, 
-	0xf4, 0x95, 0xe8, 0x60, 0xf2, 0x00, 0x00, 0x06, 
-	0x61, 0xf8, 0x00, 0x11, 0x00, 0x20, 0xf8, 0x30, 
-	0x0d, 0x98, 0x61, 0xf8, 0x00, 0x0b, 0x00, 0x01, 
-	0xf8, 0x20, 0x0d, 0xa3, 0xf2, 0x00, 0x00, 0x07, 
-	0xf0, 0x73, 0x0d, 0xa3, 0x61, 0xf8, 0x00, 0x0b, 
-	0x00, 0x01, 0xf8, 0x20, 0x0d, 0xa1, 0xf2, 0x73, 
-	0x0d, 0xa3, 0xf0, 0x00, 0x00, 0x01, 0xf0, 0x00, 
-	0x00, 0x02, 0x48, 0x08, 0xf4, 0x7f, 0x8a, 0x11, 
-	0xfc, 0x00, 0xee, 0xff, 0xf0, 0x74, 0x07, 0xfd, 
-	0xf0, 0x74, 0x07, 0x44, 0xf0, 0x74, 0x0d, 0xb4, 
-	0xf0, 0x74, 0x02, 0x05, 0xf0, 0x74, 0x04, 0x60, 
-	0xf0, 0x73, 0x0d, 0xaa, 0xee, 0xfd, 0x10, 0xf8, 
-	0x2a, 0xa3, 0xf8, 0x44, 0x0d, 0xcb, 0x10, 0xf8, 
-	0x2a, 0xa4, 0xf8, 0x45, 0x0d, 0xd7, 0x76, 0x00, 
-	0x02, 0x00, 0xf2, 0x74, 0x09, 0xe8, 0xf0, 0x20, 
-	0x22, 0x00, 0x76, 0xf8, 0x2a, 0xa4, 0x00, 0x00, 
-	0x76, 0xf8, 0x2a, 0xa7, 0x00, 0x00, 0xf0, 0x73, 
-	0x0d, 0xd7, 0x76, 0x00, 0x02, 0x00, 0xf2, 0x74, 
-	0x09, 0xe8, 0xf0, 0x20, 0x20, 0x00, 0x76, 0xf8, 
-	0x2a, 0xa3, 0x00, 0x00, 0x76, 0xf8, 0x2a, 0xa7, 
-	0x00, 0x01, 0xf0, 0x74, 0x0c, 0x5e, 0xf0, 0xe0, 
-	0xf0, 0x10, 0x3a, 0x98, 0xf8, 0x47, 0x0d, 0xe1, 
-	0x76, 0xf8, 0x27, 0x6e, 0x00, 0x00, 0xee, 0x03, 
-	0xfc, 0x00, 0x4a, 0x11, 0xee, 0xfe, 0x77, 0x11, 
-	0x20, 0x00, 0x76, 0x00, 0xaa, 0xaa, 0x76, 0x01, 
-	0x02, 0x00, 0xf2, 0x74, 0x06, 0x6c, 0xf4, 0x95, 
-	0x48, 0x11, 0x76, 0x00, 0x55, 0x55, 0x76, 0x01, 
-	0x02, 0x00, 0x48, 0x11, 0xf2, 0x74, 0x06, 0x6c, 
-	0xf0, 0x00, 0x02, 0x00, 0x76, 0xf8, 0x2a, 0xa3, 
-	0x00, 0x00, 0x76, 0xf8, 0x2a, 0xa4, 0x00, 0x00, 
-	0xe8, 0x00, 0x4e, 0x00, 0xfb, 0x80, 0x15, 0x3e, 
-	0xf4, 0x95, 0xe8, 0x04, 0x80, 0xf8, 0x2a, 0xa5, 
-	0x76, 0x00, 0x2a, 0xa8, 0xf9, 0x80, 0x14, 0x87, 
-	0x76, 0x00, 0x2a, 0xad, 0xfb, 0x80, 0x13, 0x62, 
-	0xf4, 0x95, 0xe8, 0x02, 0x10, 0xf8, 0x2a, 0xa5, 
-	0xf9, 0x80, 0x14, 0x63, 0xfb, 0x80, 0x16, 0x66, 
-	0xf4, 0x95, 0xe8, 0x1c, 0xfb, 0x80, 0x16, 0x87, 
-	0xf4, 0x95, 0xe8, 0x1c, 0xe8, 0x01, 0x4e, 0x00, 
-	0xfb, 0x80, 0x17, 0xd6, 0xf4, 0x95, 0xe8, 0x00, 
-	0x80, 0xf8, 0x2a, 0xa6, 0x76, 0x00, 0x2a, 0xb7, 
-	0xf9, 0x80, 0x16, 0xaa, 0x10, 0xf8, 0x2a, 0xa6, 
-	0xf9, 0x80, 0x17, 0x5c, 0x10, 0xf8, 0x2a, 0xa6, 
-	0xf9, 0x80, 0x17, 0x6f, 0xee, 0x02, 0x8a, 0x11, 
-	0xfc, 0x00, 0xf4, 0x95, 0x4a, 0x08, 0x4a, 0x09, 
-	0x4a, 0x0a, 0x4a, 0x07, 0x4a, 0x1d, 0x68, 0xf8, 
-	0x00, 0x07, 0x7d, 0x3f, 0x69, 0xf8, 0x00, 0x07, 
-	0x40, 0x00, 0x68, 0xf8, 0x00, 0x1d, 0xff, 0xfc, 
-	0x10, 0xf8, 0x2a, 0xa7, 0xf8, 0x44, 0x0e, 0x4b, 
-	0x76, 0xf8, 0x2a, 0xa3, 0x00, 0x01, 0xf0, 0x73, 
-	0x0e, 0x4e, 0x76, 0xf8, 0x2a, 0xa4, 0x00, 0x01, 
-	0x8a, 0x1d, 0x8a, 0x07, 0x8a, 0x0a, 0x8a, 0x09, 
-	0x8a, 0x08, 0xf4, 0xeb, 0x4a, 0x11, 0x4a, 0x16, 
-	0x4a, 0x17, 0xee, 0xfe, 0x88, 0x0e, 0x71, 0x08, 
-	0x00, 0x16, 0x71, 0x06, 0x00, 0x17, 0x11, 0x07, 
-	0xf0, 0x66, 0x00, 0x0d, 0xf0, 0x00, 0x25, 0xa0, 
-	0x88, 0x11, 0x76, 0x01, 0x00, 0x06, 0x81, 0x00, 
-	0xf2, 0x74, 0x06, 0xce, 0xf0, 0x00, 0x00, 0x01, 
-	0x76, 0x01, 0x00, 0x06, 0x70, 0x00, 0x00, 0x16, 
-	0x48, 0x11, 0xf2, 0x74, 0x06, 0xce, 0xf0, 0x00, 
-	0x00, 0x07, 0x70, 0x81, 0x00, 0x17, 0xee, 0x02, 
-	0x8a, 0x17, 0x8a, 0x16, 0x8a, 0x11, 0xfc, 0x00, 
-	0x4a, 0x11, 0x88, 0x0e, 0x71, 0x02, 0x00, 0x12, 
-	0x11, 0x03, 0xf0, 0x66, 0x00, 0x0d, 0xf0, 0x00, 
-	0x24, 0x00, 0x88, 0x11, 0xf4, 0x95, 0x70, 0x81, 
-	0x00, 0x12, 0x6e, 0xe2, 0xff, 0xfe, 0x0e, 0x8d, 
-	0xf4, 0x95, 0xe8, 0x00, 0xe8, 0x01, 0x80, 0xe1, 
-	0x00, 0x02, 0x76, 0xe1, 0x00, 0x03, 0x00, 0xff, 
-	0x76, 0xe1, 0x00, 0x04, 0x00, 0x00, 0x76, 0xe1, 
-	0x00, 0x0b, 0x00, 0x00, 0x76, 0xe1, 0x00, 0x0c, 
-	0x00, 0x00, 0x81, 0xe1, 0x00, 0x01, 0x8a, 0x11, 
-	0xfc, 0x00, 0x4a, 0x11, 0xee, 0xfc, 0x88, 0x0e, 
-	0xf4, 0x95, 0xf1, 0x66, 0x00, 0x0d, 0xf3, 0x00, 
-	0x24, 0x00, 0x89, 0x11, 0xf4, 0x95, 0xf4, 0x95, 
-	0x76, 0xe1, 0x00, 0x0c, 0x00, 0x00, 0x76, 0xe1, 
-	0x00, 0x0b, 0x00, 0x00, 0x76, 0xe1, 0x00, 0x02, 
-	0x00, 0x01, 0x76, 0x00, 0x00, 0x00, 0x76, 0x01, 
-	0x00, 0x00, 0x80, 0x02, 0x76, 0x03, 0x00, 0x00, 
-	0xf2, 0x74, 0x0c, 0xb9, 0xf4, 0x95, 0xe8, 0x00, 
-	0xee, 0x04, 0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 
-	0x88, 0x19, 0xf4, 0x95, 0x73, 0x19, 0x00, 0x0e, 
-	0xf1, 0x66, 0x00, 0x0d, 0xf2, 0x00, 0x24, 0x00, 
-	0x77, 0x15, 0x25, 0xa0, 0x77, 0x14, 0x00, 0x00, 
-	0x77, 0x1a, 0x00, 0x1f, 0xf0, 0x72, 0x0f, 0x14, 
-	0xf6, 0xb8, 0x49, 0x19, 0x09, 0x85, 0xf8, 0x4c, 
-	0x0f, 0x13, 0xf1, 0x00, 0x00, 0x05, 0x89, 0x11, 
-	0x49, 0x15, 0xf3, 0x00, 0x00, 0x01, 0x89, 0x13, 
-	0x49, 0x15, 0xf3, 0x00, 0x00, 0x07, 0x89, 0x12, 
-	0x11, 0x93, 0x1d, 0x91, 0x19, 0x92, 0x89, 0x10, 
-	0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x80, 0x0f, 0x13, 
-	0x11, 0x93, 0x1d, 0x91, 0x19, 0x92, 0x89, 0x10, 
-	0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x80, 0x0f, 0x13, 
-	0x11, 0x93, 0x1d, 0x91, 0x19, 0x92, 0x89, 0x10, 
-	0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x80, 0x0f, 0x13, 
-	0x11, 0x93, 0x1d, 0x91, 0x19, 0x92, 0x89, 0x10, 
-	0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x80, 0x0f, 0x13, 
-	0x11, 0x93, 0x1d, 0x91, 0x19, 0x92, 0x89, 0x10, 
-	0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x80, 0x0f, 0x13, 
-	0x11, 0x93, 0x1d, 0x91, 0x19, 0x92, 0x89, 0x11, 
-	0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x81, 0x0f, 0x13, 
-	0x6d, 0x94, 0x6d, 0xed, 0x00, 0x0d, 0x48, 0x14, 
-	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0x4a, 0x16, 
-	0x4a, 0x17, 0xee, 0xf8, 0x88, 0x17, 0x10, 0x0d, 
-	0x80, 0x04, 0x10, 0x0c, 0x80, 0x05, 0x71, 0x0e, 
-	0x00, 0x16, 0x73, 0x17, 0x00, 0x0e, 0xf0, 0x66, 
-	0x00, 0x0d, 0xf0, 0x00, 0x24, 0x00, 0x88, 0x11, 
-	0x10, 0xf8, 0x27, 0x63, 0xf8, 0x45, 0x0f, 0x32, 
-	0xf2, 0x74, 0x0e, 0x9f, 0xf4, 0x95, 0x48, 0x17, 
-	0x10, 0xf8, 0x27, 0x60, 0xf8, 0x44, 0x0f, 0x3d, 
-	0x60, 0xe1, 0x00, 0x02, 0x00, 0x01, 0xf8, 0x20, 
-	0x0f, 0x6d, 0xf0, 0x73, 0x11, 0x33, 0x10, 0x04, 
-	0x80, 0x00, 0x10, 0x05, 0xf0, 0x74, 0x06, 0x9f, 
-	0x11, 0x04, 0xf3, 0x00, 0x00, 0x01, 0x81, 0x04, 
-	0x6d, 0x8e, 0x77, 0x10, 0x00, 0x01, 0x71, 0xe1, 
-	0x00, 0x02, 0x00, 0x12, 0xf4, 0xaa, 0xf8, 0x30, 
-	0x0f, 0x62, 0x77, 0x10, 0x00, 0x02, 0xf4, 0xaa, 
-	0xf8, 0x30, 0x0f, 0x6d, 0x45, 0xe1, 0x00, 0x0b, 
-	0x88, 0x10, 0x43, 0xe1, 0x00, 0x0c, 0x83, 0xf8, 
-	0x00, 0x12, 0xf4, 0x95, 0xf4, 0x95, 0xf4, 0xaa, 
-	0xf8, 0x30, 0x0f, 0x6d, 0xf0, 0x73, 0x0f, 0x96, 
-	0xf5, 0x00, 0x81, 0x04, 0x49, 0x16, 0xf5, 0x20, 
-	0x89, 0x16, 0x76, 0xe1, 0x00, 0x0c, 0x00, 0x00, 
-	0x76, 0xe1, 0x00, 0x04, 0x00, 0x00, 0x48, 0x16, 
-	0xf8, 0x45, 0x11, 0x33, 0xf7, 0xb8, 0x71, 0xe1, 
-	0x00, 0x02, 0x00, 0x12, 0x10, 0xf8, 0x00, 0x12, 
-	0xf0, 0x10, 0x00, 0x03, 0xf8, 0x46, 0x0f, 0x8c, 
-	0x10, 0xf8, 0x00, 0x12, 0xf0, 0x10, 0x00, 0x03, 
-	0xf8, 0x45, 0x10, 0x16, 0x77, 0x10, 0x00, 0x01, 
-	0xf4, 0xaa, 0xf8, 0x30, 0x0f, 0x9c, 0x77, 0x10, 
-	0x00, 0x02, 0xf4, 0xaa, 0xf8, 0x30, 0x0f, 0xa8, 
-	0xf0, 0x73, 0x0f, 0x96, 0x77, 0x10, 0x00, 0x04, 
-	0xf4, 0xaa, 0xf8, 0x30, 0x10, 0xb7, 0x77, 0x10, 
-	0x00, 0x05, 0xf4, 0xaa, 0xf8, 0x30, 0x10, 0xbc, 
-	0xf2, 0x74, 0x0e, 0x9f, 0xf4, 0x95, 0x48, 0x17, 
-	0xf0, 0x73, 0x11, 0x31, 0x76, 0xe1, 0x00, 0x0c, 
-	0x00, 0x00, 0x76, 0xe1, 0x00, 0x0b, 0x00, 0x00, 
-	0x76, 0xe1, 0x00, 0x04, 0x00, 0x00, 0x76, 0xe1, 
-	0x00, 0x02, 0x00, 0x02, 0x11, 0xe1, 0x00, 0x0c, 
-	0xe8, 0x03, 0xf6, 0x20, 0x89, 0x12, 0xf4, 0x95, 
-	0x77, 0x10, 0x00, 0x03, 0xf5, 0xaa, 0xf8, 0x30, 
-	0x0f, 0xb6, 0x6b, 0xf8, 0x27, 0x6f, 0x00, 0x01, 
-	0x88, 0x10, 0xf4, 0x95, 0xf4, 0x95, 0xf5, 0xae, 
-	0xf8, 0x20, 0x0f, 0xbd, 0x48, 0x16, 0x80, 0x06, 
-	0x88, 0x13, 0xf4, 0x95, 0x77, 0x10, 0x00, 0x03, 
-	0xf6, 0xab, 0xf8, 0x20, 0x0f, 0xc8, 0x6b, 0xf8, 
-	0x27, 0x6f, 0x00, 0x01, 0x12, 0x06, 0xf8, 0x45, 
-	0x10, 0x00, 0x10, 0xe1, 0x00, 0x04, 0x80, 0x00, 
-	0x10, 0x05, 0x80, 0x01, 0x10, 0x04, 0x80, 0x02, 
-	0x10, 0x06, 0x80, 0x03, 0x48, 0x11, 0xf2, 0x74, 
-	0x07, 0x1e, 0xf0, 0x00, 0x00, 0x05, 0x10, 0x06, 
-	0x00, 0xe1, 0x00, 0x04, 0x80, 0xe1, 0x00, 0x04, 
-	0x10, 0x06, 0x00, 0xe1, 0x00, 0x0c, 0x80, 0xe1, 
-	0x00, 0x0c, 0x88, 0x12, 0x11, 0x06, 0x10, 0x04, 
-	0xf6, 0x00, 0x80, 0x04, 0x48, 0x16, 0xf6, 0x20, 
-	0x88, 0x16, 0x89, 0x13, 0xf4, 0x95, 0x77, 0x10, 
-	0x00, 0x03, 0xf6, 0xab, 0xf8, 0x20, 0x0f, 0xf5, 
-	0x6b, 0xf8, 0x27, 0x6f, 0x00, 0x01, 0x77, 0x10, 
-	0x00, 0x0c, 0x71, 0xe1, 0x00, 0x04, 0x00, 0x13, 
-	0xf6, 0xab, 0xf8, 0x20, 0x10, 0x00, 0x6b, 0xf8, 
-	0x27, 0x6f, 0x00, 0x01, 0x6c, 0xe2, 0xff, 0xfd, 
-	0x11, 0x31, 0xf6, 0xb8, 0x6f, 0xe1, 0x00, 0x05, 
-	0x0c, 0x48, 0x6f, 0xe1, 0x00, 0x06, 0x0c, 0x18, 
-	0xf0, 0x30, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x03, 
-	0x80, 0xe1, 0x00, 0x0b, 0x76, 0xe1, 0x00, 0x02, 
-	0x00, 0x03, 0x48, 0x16, 0xf8, 0x45, 0x11, 0x33, 
-	0x71, 0xe1, 0x00, 0x0c, 0x00, 0x12, 0x10, 0xe1, 
-	0x00, 0x0b, 0x49, 0x12, 0xf6, 0x20, 0x88, 0x13, 
-	0xe8, 0x0c, 0xf6, 0x20, 0x88, 0x10, 0xf4, 0x95, 
-	0xf4, 0x95, 0xf5, 0xab, 0xf8, 0x20, 0x10, 0x27, 
-	0x48, 0x13, 0x80, 0x06, 0x88, 0x10, 0xf4, 0x95, 
-	0xf4, 0x95, 0xf5, 0xae, 0xf8, 0x20, 0x10, 0x30, 
-	0x70, 0x06, 0x00, 0x16, 0x12, 0x06, 0xf8, 0x45, 
-	0x10, 0x5f, 0x10, 0xe1, 0x00, 0x04, 0x80, 0x00, 
-	0x10, 0x05, 0x80, 0x01, 0x10, 0x04, 0x80, 0x02, 
-	0x10, 0x06, 0x80, 0x03, 0x48, 0x11, 0xf2, 0x74, 
-	0x07, 0x1e, 0xf0, 0x00, 0x00, 0x05, 0x10, 0x06, 
-	0x00, 0xe1, 0x00, 0x04, 0x80, 0xe1, 0x00, 0x04, 
-	0x10, 0x06, 0x00, 0xe1, 0x00, 0x0c, 0x80, 0xe1, 
-	0x00, 0x0c, 0x88, 0x12, 0x11, 0x06, 0x10, 0x04, 
-	0xf6, 0x00, 0x80, 0x04, 0x48, 0x16, 0xf6, 0x20, 
-	0x88, 0x16, 0xf4, 0x95, 0x77, 0x10, 0x00, 0x0c, 
-	0x71, 0xe1, 0x00, 0x04, 0x00, 0x13, 0xf6, 0xab, 
-	0xf8, 0x20, 0x10, 0x5f, 0x6b, 0xf8, 0x27, 0x6f, 
-	0x00, 0x01, 0x77, 0x10, 0x00, 0x0c, 0xf6, 0xaa, 
-	0xf8, 0x20, 0x10, 0x6b, 0xf2, 0x74, 0x0e, 0x9f, 
-	0xf4, 0x95, 0x48, 0x17, 0x71, 0xe1, 0x00, 0x0c, 
-	0x00, 0x12, 0x77, 0x10, 0x00, 0x0c, 0xf4, 0xaa, 
-	0xf8, 0x30, 0x10, 0x7c, 0x77, 0x10, 0x00, 0x0c, 
-	0x71, 0xe1, 0x00, 0x0b, 0x00, 0x13, 0xf6, 0xab, 
-	0xf8, 0x30, 0x10, 0xb4, 0xe7, 0x30, 0xf7, 0xaa, 
-	0xf8, 0x30, 0x10, 0xb4, 0xf2, 0x74, 0x0e, 0xc1, 
-	0xf4, 0x95, 0x48, 0x17, 0x88, 0x12, 0xf4, 0x95, 
-	0xf4, 0x95, 0x6c, 0x82, 0x10, 0x8d, 0x76, 0xe1, 
-	0x00, 0x04, 0x00, 0x00, 0x76, 0xe1, 0x00, 0x02, 
-	0x00, 0x05, 0xf0, 0x73, 0x10, 0xb4, 0x76, 0xe1, 
-	0x00, 0x02, 0x00, 0x04, 0x77, 0x10, 0x00, 0x0c, 
-	0x71, 0xe1, 0x00, 0x0b, 0x00, 0x12, 0xf5, 0xaa, 
-	0xf8, 0x20, 0x10, 0x9a, 0xf0, 0x73, 0x10, 0x9c, 
-	0x77, 0x12, 0x00, 0x0c, 0x76, 0x00, 0x00, 0x00, 
-	0x70, 0x01, 0x00, 0x12, 0x70, 0x02, 0x00, 0x17, 
-	0x76, 0x03, 0x00, 0x01, 0x48, 0x11, 0xf2, 0x74, 
-	0x0c, 0xb9, 0xf0, 0x00, 0x00, 0x05, 0x76, 0xe1, 
-	0x00, 0x04, 0x00, 0x00, 0x77, 0x10, 0x00, 0x0c, 
-	0x71, 0xe1, 0x00, 0x0b, 0x00, 0x12, 0xf6, 0xaa, 
-	0xf8, 0x20, 0x11, 0x1c, 0x48, 0x16, 0xf8, 0x45, 
-	0x11, 0x33, 0x60, 0xe1, 0x00, 0x02, 0x00, 0x05, 
-	0xf8, 0x20, 0x10, 0xdf, 0x10, 0xe1, 0x00, 0x0b, 
-	0x08, 0xe1, 0x00, 0x0c, 0x11, 0xe1, 0x00, 0x04, 
-	0xf8, 0x4d, 0x10, 0xc7, 0x6b, 0xf8, 0x27, 0x6f, 
-	0x00, 0x01, 0x88, 0x10, 0xf4, 0x95, 0xf4, 0x95, 
-	0xf5, 0xae, 0xf8, 0x20, 0x10, 0xcf, 0x48, 0x16, 
-	0xf4, 0x95, 0x48, 0x08, 0xf8, 0x45, 0x11, 0x16, 
-	0x6f, 0xe1, 0x00, 0x0c, 0x0d, 0x00, 0x81, 0xe1, 
-	0x00, 0x0c, 0x11, 0x04, 0xf5, 0x00, 0x81, 0x04, 
-	0x49, 0x16, 0xf5, 0x20, 0x89, 0x16, 0xf0, 0x73, 
-	0x11, 0x0e, 0x10, 0xe1, 0x00, 0x0b, 0x71, 0xe1, 
-	0x00, 0x0c, 0x00, 0x12, 0x88, 0x10, 0xf4, 0x95, 
-	0xf4, 0x95, 0xf6, 0xaa, 0xf8, 0x30, 0x11, 0x16, 
-	0x49, 0x12, 0xf6, 0x20, 0x88, 0x10, 0xf4, 0x95, 
-	0xf4, 0x95, 0xf5, 0xae, 0xf8, 0x20, 0x10, 0xf3, 
-	0x48, 0x16, 0x80, 0x06, 0x48, 0x08, 0xf8, 0x45, 
-	0x11, 0x16, 0x10, 0x04, 0x70, 0x02, 0x00, 0x17, 
-	0x80, 0x00, 0x76, 0x03, 0x00, 0x00, 0x10, 0x06, 
-	0x80, 0x01, 0x10, 0x05, 0xf0, 0x74, 0x0c, 0xb9, 
-	0x10, 0x06, 0x00, 0xe1, 0x00, 0x0c, 0x80, 0xe1, 
-	0x00, 0x0c, 0x11, 0x06, 0x10, 0x04, 0xf6, 0x00, 
-	0x80, 0x04, 0x48, 0x16, 0xf6, 0x20, 0x88, 0x16, 
-	0x10, 0xe1, 0x00, 0x0c, 0x08, 0xe1, 0x00, 0x0b, 
-	0xf8, 0x45, 0x11, 0x1c, 0xf0, 0x73, 0x11, 0x31, 
-	0xf2, 0x74, 0x0e, 0x9f, 0xf4, 0x95, 0x48, 0x17, 
-	0xf0, 0x73, 0x11, 0x33, 0x76, 0xe1, 0x00, 0x0c, 
-	0x00, 0x00, 0x76, 0xe1, 0x00, 0x0b, 0x00, 0x00, 
-	0x76, 0xe1, 0x00, 0x02, 0x00, 0x01, 0x10, 0x04, 
-	0x80, 0x00, 0x10, 0x05, 0xf0, 0x74, 0x06, 0x9f, 
-	0x88, 0x12, 0xf4, 0x95, 0x77, 0x10, 0x00, 0xff, 
-	0xf4, 0xaa, 0xf8, 0x30, 0x11, 0x33, 0x6c, 0x86, 
-	0x0f, 0x70, 0xee, 0x08, 0x8a, 0x17, 0x8a, 0x16, 
-	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0xee, 0xfc, 
-	0xf4, 0x95, 0x71, 0x06, 0x00, 0x12, 0x88, 0x11, 
-	0x73, 0x12, 0x00, 0x0e, 0xf1, 0x66, 0x00, 0x0d, 
-	0xf3, 0x00, 0x24, 0x00, 0x89, 0x14, 0x13, 0x81, 
-	0xf7, 0x7a, 0xf3, 0x30, 0x00, 0x01, 0x81, 0xf8, 
-	0x27, 0x60, 0x13, 0xe1, 0x00, 0x01, 0xf7, 0x7c, 
-	0xf3, 0x30, 0x00, 0x03, 0x81, 0xf8, 0x27, 0x61, 
-	0xe9, 0x0f, 0x19, 0xe1, 0x00, 0x01, 0x81, 0xf8, 
-	0x27, 0x62, 0x71, 0xe4, 0x00, 0x03, 0x00, 0x13, 
-	0xf6, 0xb8, 0x49, 0x13, 0xf3, 0x00, 0x00, 0x01, 
-	0xf3, 0x30, 0x00, 0x0f, 0x49, 0x0b, 0x09, 0xf8, 
-	0x27, 0x62, 0xf8, 0x4d, 0x11, 0x75, 0x77, 0x10, 
-	0x00, 0xff, 0xf4, 0xab, 0xf8, 0x30, 0x11, 0x75, 
-	0x57, 0xf8, 0x27, 0x6c, 0xf3, 0x00, 0x00, 0x01, 
-	0x4f, 0xf8, 0x27, 0x6c, 0x76, 0xf8, 0x27, 0x63, 
-	0x00, 0x01, 0xf0, 0x73, 0x11, 0x78, 0x76, 0xf8, 
-	0x27, 0x63, 0x00, 0x00, 0x70, 0xe4, 0x00, 0x03, 
-	0x27, 0x62, 0x76, 0xf8, 0x27, 0x64, 0x00, 0x00, 
-	0x11, 0xf8, 0x27, 0x61, 0x61, 0xf8, 0x00, 0x0b, 
-	0x00, 0x02, 0xf8, 0x20, 0x11, 0x8d, 0xe9, 0x01, 
-	0x6f, 0xe1, 0x00, 0x02, 0x0f, 0x18, 0x81, 0xf8, 
-	0x27, 0x64, 0x11, 0xf8, 0x27, 0x61, 0x61, 0xf8, 
-	0x00, 0x0b, 0x00, 0x01, 0xf8, 0x20, 0x11, 0xa9, 
-	0x10, 0xf8, 0x27, 0x64, 0xf1, 0x00, 0x00, 0x04, 
-	0x89, 0x13, 0xe9, 0xb8, 0xf5, 0x20, 0x81, 0xf8, 
-	0x27, 0x65, 0x60, 0x84, 0x00, 0x02, 0xf8, 0x20, 
-	0x11, 0xa9, 0x70, 0x00, 0x00, 0x11, 0x70, 0x01, 
-	0x00, 0x13, 0x70, 0x02, 0x27, 0x65, 0xf2, 0x74, 
-	0x0f, 0x18, 0xf4, 0x95, 0x48, 0x12, 0xee, 0x04, 
-	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0x4a, 0x16, 
-	0x4a, 0x17, 0xee, 0xfc, 0xe8, 0x00, 0x4e, 0xf8, 
-	0x27, 0x66, 0xe8, 0x00, 0x4e, 0xf8, 0x27, 0x68, 
-	0xe8, 0x00, 0x4e, 0xf8, 0x27, 0x6c, 0xe8, 0x00, 
-	0x4e, 0xf8, 0x27, 0x6a, 0x77, 0x12, 0x27, 0x40, 
-	0x77, 0x11, 0x24, 0x00, 0x77, 0x1a, 0x00, 0x1f, 
-	0xf0, 0x72, 0x11, 0xdb, 0x70, 0x92, 0x00, 0x11, 
-	0x76, 0xe1, 0x00, 0x01, 0xff, 0xff, 0x76, 0x81, 
-	0x00, 0x00, 0x76, 0xe1, 0x00, 0x02, 0x00, 0x00, 
-	0x76, 0xe1, 0x00, 0x03, 0x00, 0xff, 0x76, 0xe1, 
-	0x00, 0x0c, 0x00, 0x00, 0x76, 0xe1, 0x00, 0x0b, 
-	0x00, 0x00, 0x76, 0xe1, 0x00, 0x04, 0x00, 0x00, 
-	0x6d, 0xe9, 0x00, 0x0d, 0xf0, 0x20, 0x25, 0xa0, 
-	0xf1, 0x00, 0x00, 0x07, 0x89, 0x11, 0xf1, 0x00, 
-	0x00, 0x01, 0x81, 0x02, 0x88, 0x16, 0xf4, 0x95, 
-	0x77, 0x17, 0x00, 0x20, 0x76, 0x86, 0x00, 0xff, 
-	0x76, 0x00, 0x00, 0x00, 0x76, 0x01, 0x00, 0x06, 
-	0x10, 0x02, 0xf0, 0x74, 0x06, 0x6c, 0x76, 0x00, 
-	0x00, 0x00, 0x76, 0x01, 0x00, 0x06, 0xf2, 0x74, 
-	0x06, 0x6c, 0xf4, 0x95, 0x48, 0x11, 0x10, 0x02, 
-	0xf0, 0x00, 0x00, 0x0d, 0x80, 0x02, 0x6d, 0xe9, 
-	0x00, 0x0d, 0x6d, 0xee, 0x00, 0x0d, 0x6c, 0xef, 
-	0xff, 0xff, 0x11, 0xe8, 0xf0, 0x74, 0x0c, 0x9d, 
-	0xee, 0x04, 0x8a, 0x17, 0x8a, 0x16, 0x8a, 0x11, 
-	0xfc, 0x00, 0x4a, 0x11, 0x4a, 0x16, 0x4a, 0x17, 
-	0xee, 0xfa, 0x88, 0x11, 0x10, 0x0a, 0x49, 0x11, 
-	0xf8, 0x4d, 0x12, 0x9f, 0x48, 0x08, 0xf8, 0x45, 
-	0x12, 0x9f, 0x80, 0x04, 0x12, 0x81, 0xf5, 0x78, 
-	0x89, 0x12, 0xf4, 0x95, 0xf4, 0x95, 0x6c, 0xe2, 
-	0xff, 0xb9, 0x12, 0x8a, 0x61, 0xf8, 0x00, 0x08, 
-	0x00, 0x80, 0xf8, 0x30, 0x12, 0x8a, 0x13, 0xe1, 
-	0x00, 0x01, 0xf0, 0xe8, 0xf7, 0x78, 0xf1, 0xa0, 
-	0xf2, 0x30, 0x1f, 0xff, 0x88, 0x17, 0xf4, 0x95, 
-	0x77, 0x12, 0x24, 0x00, 0x77, 0x16, 0x00, 0x00, 
-	0x77, 0x13, 0x00, 0x20, 0xf6, 0xb8, 0x48, 0x17, 
-	0x08, 0xe2, 0x00, 0x01, 0xf8, 0x45, 0x12, 0x42, 
-	0x6d, 0xea, 0x00, 0x0d, 0x6d, 0x96, 0x6c, 0xeb, 
-	0xff, 0xff, 0x12, 0x34, 0xf0, 0x73, 0x12, 0x90, 
-	0x56, 0xf8, 0x27, 0x6a, 0xf0, 0x00, 0x00, 0x01, 
-	0x4e, 0xf8, 0x27, 0x6a, 0x60, 0x82, 0x00, 0x01, 
-	0xf8, 0x30, 0x12, 0x54, 0x70, 0x00, 0x00, 0x16, 
-	0xf2, 0x74, 0x11, 0x38, 0xf4, 0x95, 0x48, 0x11, 
-	0xf0, 0x73, 0x12, 0x90, 0x70, 0x00, 0x00, 0x16, 
-	0xf2, 0x74, 0x11, 0x38, 0xf4, 0x95, 0x48, 0x11, 
-	0x72, 0x10, 0x2a, 0x9e, 0xf4, 0x95, 0xf4, 0xaf, 
-	0xf8, 0x30, 0x12, 0x6e, 0x76, 0x00, 0x00, 0x00, 
-	0x76, 0x01, 0x00, 0xbc, 0x70, 0x02, 0x00, 0x16, 
-	0x76, 0x03, 0x00, 0x00, 0xf2, 0x74, 0x0c, 0xb9, 
-	0xf4, 0x95, 0x48, 0x11, 0xf0, 0x73, 0x12, 0x90, 
-	0x10, 0xf8, 0x27, 0x6e, 0xf8, 0x44, 0x12, 0x90, 
-	0x76, 0x00, 0x00, 0x00, 0x76, 0x01, 0x00, 0xbc, 
-	0x70, 0x02, 0x00, 0x16, 0x76, 0x03, 0x00, 0x00, 
-	0xf2, 0x74, 0x0c, 0xb9, 0xf4, 0x95, 0x48, 0x11, 
-	0xf0, 0x74, 0x0c, 0x5e, 0xf0, 0xe0, 0xf0, 0x10, 
-	0x13, 0x88, 0xf8, 0x42, 0x12, 0x90, 0x76, 0xf8, 
-	0x27, 0x6e, 0x00, 0x01, 0xf0, 0x73, 0x12, 0x90, 
-	0x56, 0xf8, 0x27, 0x66, 0xf0, 0x00, 0x00, 0x01, 
-	0x4e, 0xf8, 0x27, 0x66, 0x6d, 0xe9, 0x00, 0x5e, 
-	0x56, 0xf8, 0x27, 0x68, 0xf0, 0x00, 0x00, 0x01, 
-	0x4e, 0xf8, 0x27, 0x68, 0x71, 0x04, 0x00, 0x12, 
-	0x6e, 0xea, 0xff, 0xff, 0x12, 0x18, 0x70, 0x04, 
-	0x00, 0x12, 0xee, 0x06, 0x8a, 0x17, 0x8a, 0x16, 
-	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0xee, 0xfe, 
-	0x88, 0x0e, 0xf4, 0x95, 0xf0, 0x66, 0x00, 0x0d, 
-	0xf0, 0x00, 0x25, 0xa0, 0x88, 0x11, 0xf4, 0x95, 
-	0xf4, 0x95, 0x76, 0x81, 0x00, 0xff, 0x76, 0x00, 
-	0x00, 0x00, 0x76, 0x01, 0x00, 0x06, 0xf2, 0x74, 
-	0x06, 0x6c, 0xf0, 0x00, 0x00, 0x01, 0x76, 0x00, 
-	0x00, 0x00, 0x76, 0x01, 0x00, 0x06, 0x48, 0x11, 
-	0xf2, 0x74, 0x06, 0x6c, 0xf0, 0x00, 0x00, 0x07, 
-	0xee, 0x02, 0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 
-	0x88, 0x0e, 0xf4, 0x95, 0xf0, 0x66, 0x00, 0x0d, 
-	0xf0, 0x00, 0x24, 0x00, 0x88, 0x11, 0xf4, 0x95, 
-	0xf4, 0x95, 0x76, 0xe1, 0x00, 0x01, 0xff, 0xff, 
-	0x76, 0x81, 0x00, 0x00, 0x76, 0xe1, 0x00, 0x02, 
-	0x00, 0x00, 0x76, 0xe1, 0x00, 0x03, 0x00, 0xff, 
-	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0xf4, 0x95, 
-	0x13, 0x03, 0x88, 0x11, 0xfa, 0x4d, 0x12, 0xec, 
-	0x71, 0x02, 0x00, 0x12, 0xf3, 0x10, 0x00, 0x01, 
-	0x89, 0x1a, 0xf4, 0x95, 0xf0, 0x72, 0x12, 0xeb, 
-	0x70, 0x91, 0x00, 0x12, 0x8a, 0x11, 0xfc, 0x00, 
-	0xf4, 0x95, 0x4a, 0x0b, 0x4a, 0x0c, 0x4a, 0x0d, 
-	0xf7, 0xb8, 0xee, 0xfe, 0x10, 0xf8, 0x00, 0x08, 
-	0x11, 0x06, 0xf1, 0xc0, 0x83, 0x00, 0xf4, 0x85, 
-	0x11, 0x06, 0xf7, 0x85, 0x81, 0x06, 0xf6, 0xb8, 
-	0xec, 0x0f, 0x1e, 0x06, 0x61, 0x00, 0x80, 0x00, 
-	0xf8, 0x20, 0x13, 0x05, 0xf4, 0x84, 0xee, 0x02, 
-	0x8a, 0x0d, 0x8a, 0x0c, 0x8a, 0x0b, 0xfc, 0x00, 
-	0xf4, 0x95, 0x4a, 0x0b, 0x4a, 0x0c, 0x4a, 0x0d, 
-	0xee, 0xfe, 0xf7, 0xb8, 0x80, 0x00, 0x10, 0xf8, 
-	0x00, 0x08, 0xf4, 0x85, 0x11, 0x06, 0xf7, 0x85, 
-	0x81, 0x06, 0xf6, 0xb8, 0xec, 0x0f, 0x1e, 0x06, 
-	0xf0, 0xf0, 0x61, 0x00, 0x80, 0x00, 0xf8, 0x20, 
-	0x13, 0x20, 0xf4, 0x84, 0xee, 0x02, 0x8a, 0x0d, 
-	0x8a, 0x0c, 0x8a, 0x0b, 0xfc, 0x00, 0x4a, 0x11, 
-	0x77, 0x11, 0x00, 0x7b, 0x76, 0x81, 0x2e, 0xec, 
-	0x77, 0x11, 0x00, 0x7b, 0xee, 0xff, 0x71, 0x81, 
-	0x00, 0x11, 0xee, 0x01, 0x76, 0xe1, 0x00, 0x01, 
-	0x00, 0x00, 0x76, 0xe1, 0x00, 0x04, 0x00, 0x00, 
-	0x76, 0xe1, 0x00, 0x06, 0x00, 0x00, 0x76, 0xe1, 
-	0x00, 0x62, 0x00, 0x00, 0x76, 0xe1, 0x00, 0x76, 
-	0x00, 0x00, 0x76, 0xe1, 0x00, 0x92, 0x00, 0x00, 
-	0x76, 0xe1, 0x00, 0x94, 0x00, 0x00, 0x76, 0xe1, 
-	0x00, 0xb0, 0x00, 0x00, 0x76, 0xe1, 0x00, 0xb3, 
-	0x00, 0x00, 0x76, 0xe1, 0x00, 0xbe, 0x00, 0x00, 
-	0x76, 0xe1, 0x00, 0xbf, 0x00, 0x00, 0x76, 0xe1, 
-	0x00, 0xc1, 0x00, 0x00, 0x76, 0xe1, 0x00, 0xc3, 
-	0x00, 0x00, 0x76, 0xe1, 0x00, 0xc5, 0x00, 0x00, 
-	0x76, 0xe1, 0x00, 0xc7, 0x00, 0x00, 0x76, 0x81, 
-	0x00, 0x00, 0x8a, 0x11, 0xf4, 0x95, 0xf4, 0xe4, 
-	0x4a, 0x11, 0x4a, 0x16, 0x4a, 0x17, 0xee, 0xff, 
-	0xf4, 0x95, 0x71, 0x06, 0x00, 0x16, 0xfb, 0x80, 
-	0x16, 0xa2, 0x88, 0x17, 0xf4, 0x95, 0xf7, 0xb8, 
-	0x10, 0xf8, 0x00, 0x17, 0xf0, 0x10, 0x00, 0x02, 
-	0xfa, 0x46, 0x13, 0x88, 0x77, 0x11, 0x00, 0x00, 
-	0x10, 0xf8, 0x00, 0x17, 0xf0, 0x10, 0x00, 0x02, 
-	0xf8, 0x45, 0x13, 0xf9, 0x10, 0xf8, 0x00, 0x17, 
-	0xf8, 0x45, 0x14, 0x39, 0x10, 0xf8, 0x00, 0x17, 
-	0xf0, 0x10, 0x00, 0x01, 0xf8, 0x45, 0x14, 0x1f, 
-	0xf0, 0x73, 0x14, 0x52, 0x10, 0xf8, 0x00, 0x17, 
-	0xf0, 0x10, 0x00, 0x03, 0xf8, 0x45, 0x13, 0xd3, 
-	0x10, 0xf8, 0x00, 0x17, 0xf0, 0x10, 0x00, 0x06, 
-	0xf8, 0x44, 0x14, 0x52, 0x77, 0x12, 0x00, 0x7b, 
-	0x71, 0x82, 0x00, 0x14, 0x61, 0xe4, 0x00, 0x07, 
-	0x00, 0x40, 0xf8, 0x30, 0x14, 0x52, 0x49, 0x14, 
-	0x48, 0x17, 0xf6, 0x00, 0x88, 0x12, 0xf4, 0x95, 
-	0x77, 0x13, 0x00, 0x55, 0x77, 0x11, 0x00, 0x57, 
-	0x6d, 0xea, 0x00, 0x3b, 0xe5, 0x01, 0x10, 0xe6, 
-	0x00, 0x06, 0x80, 0x81, 0x48, 0x14, 0x00, 0xf8, 
-	0x00, 0x17, 0x88, 0x12, 0xf4, 0x95, 0x77, 0x11, 
-	0x00, 0x55, 0x10, 0xe2, 0x00, 0x40, 0x80, 0x81, 
-	0x77, 0x11, 0x00, 0x57, 0x10, 0xe6, 0x00, 0x07, 
-	0x80, 0x81, 0x77, 0x11, 0x00, 0x55, 0x10, 0xe2, 
-	0x00, 0x45, 0x80, 0x81, 0x10, 0xe6, 0x00, 0x08, 
-	0x77, 0x11, 0x00, 0x57, 0x80, 0x81, 0x77, 0x11, 
-	0x00, 0x55, 0x10, 0xe2, 0x00, 0x4a, 0x80, 0x81, 
-	0x77, 0x11, 0x00, 0x57, 0x10, 0xe6, 0x00, 0x09, 
-	0x80, 0x81, 0xf2, 0x73, 0x14, 0x52, 0x77, 0x11, 
-	0x03, 0xc0, 0x77, 0x12, 0x00, 0x7b, 0x10, 0x82, 
-	0xf0, 0x00, 0x00, 0x07, 0x88, 0x13, 0xf4, 0x95, 
-	0xf4, 0x95, 0x96, 0x1b, 0xf8, 0x30, 0x14, 0x52, 
-	0x10, 0xe3, 0x00, 0x35, 0x77, 0x12, 0x00, 0x55, 
-	0x80, 0x82, 0x77, 0x12, 0x00, 0x57, 0x10, 0xe6, 
-	0x00, 0x04, 0x80, 0x82, 0x77, 0x12, 0x00, 0x55, 
-	0x10, 0xe3, 0x00, 0x37, 0x80, 0x82, 0x77, 0x12, 
-	0x00, 0x57, 0x10, 0xe6, 0x00, 0x05, 0x80, 0x82, 
-	0x48, 0x11, 0xf0, 0x40, 0x00, 0x10, 0xf2, 0x73, 
-	0x14, 0x50, 0xf0, 0x40, 0x00, 0x20, 0x77, 0x12, 
-	0x00, 0x7b, 0x10, 0x82, 0xf0, 0x00, 0x00, 0x07, 
-	0x88, 0x12, 0xf4, 0x95, 0xf4, 0x95, 0x96, 0x0d, 
-	0xf8, 0x30, 0x14, 0x52, 0x10, 0xe2, 0x00, 0x34, 
-	0x77, 0x13, 0x00, 0x55, 0x80, 0x83, 0x77, 0x13, 
-	0x00, 0x57, 0x10, 0xe6, 0x00, 0x02, 0x80, 0x83, 
-	0x10, 0xe2, 0x00, 0x36, 0x77, 0x12, 0x00, 0x55, 
-	0x80, 0x82, 0x77, 0x12, 0x00, 0x57, 0x10, 0xe6, 
-	0x00, 0x03, 0x80, 0x82, 0x48, 0x11, 0xf0, 0x40, 
-	0x00, 0x04, 0xf2, 0x73, 0x14, 0x50, 0xf0, 0x40, 
-	0x00, 0x08, 0x77, 0x12, 0x00, 0x7b, 0x10, 0x82, 
-	0xf0, 0x00, 0x00, 0x07, 0x88, 0x12, 0xf4, 0x95, 
-	0xf4, 0x95, 0x96, 0x0e, 0xf8, 0x30, 0x14, 0x52, 
-	0x10, 0xe2, 0x00, 0x33, 0x77, 0x12, 0x00, 0x55, 
-	0x80, 0x82, 0x77, 0x12, 0x00, 0x57, 0x10, 0xe6, 
-	0x00, 0x01, 0x80, 0x82, 0x48, 0x11, 0xf2, 0x73, 
-	0x14, 0x50, 0xf0, 0x40, 0x00, 0x02, 0x77, 0x12, 
-	0x00, 0x7b, 0x10, 0x82, 0xf0, 0x00, 0x00, 0x07, 
-	0x88, 0x12, 0xf4, 0x95, 0xf4, 0x95, 0x96, 0x0f, 
-	0xf8, 0x30, 0x14, 0x52, 0x10, 0xe2, 0x00, 0x32, 
-	0x77, 0x12, 0x00, 0x55, 0x77, 0x13, 0x00, 0x57, 
-	0x80, 0x82, 0x48, 0x11, 0xe7, 0x62, 0xf0, 0x40, 
-	0x00, 0x01, 0xe5, 0x01, 0x88, 0x11, 0xf4, 0x95, 
-	0x77, 0x12, 0x00, 0x7b, 0x48, 0x11, 0x71, 0x82, 
-	0x00, 0x12, 0x1a, 0xe2, 0x00, 0x07, 0x80, 0xe2, 
-	0x00, 0x07, 0xf9, 0x80, 0x16, 0x9a, 0xee, 0x01, 
-	0x8a, 0x17, 0x48, 0x11, 0x8a, 0x16, 0x8a, 0x11, 
-	0xf4, 0xe4, 0x4a, 0x11, 0x88, 0x11, 0x77, 0x0e, 
-	0x00, 0x05, 0x77, 0x12, 0x00, 0x55, 0xe8, 0x04, 
-	0xf6, 0xb8, 0x28, 0xe1, 0x00, 0x02, 0xee, 0xff, 
-	0x80, 0x82, 0x77, 0x12, 0x00, 0x57, 0xf0, 0x20, 
-	0x80, 0x00, 0xee, 0x01, 0x1a, 0x82, 0x77, 0x12, 
-	0x00, 0x57, 0x80, 0x82, 0xe8, 0x01, 0x32, 0xe1, 
-	0x00, 0x02, 0xf5, 0x82, 0x77, 0x11, 0x00, 0x54, 
-	0xf6, 0x93, 0x18, 0x81, 0x77, 0x11, 0x00, 0x54, 
-	0xf2, 0xa0, 0x80, 0x81, 0x8a, 0x11, 0xf4, 0x95, 
-	0xf4, 0xe4, 0x4a, 0x11, 0x4a, 0x16, 0xf4, 0x95, 
-	0x71, 0x04, 0x00, 0x11, 0xfb, 0x80, 0x16, 0xa2, 
-	0x88, 0x16, 0xf4, 0x95, 0x77, 0x12, 0x00, 0x55, 
-	0x10, 0xe6, 0x00, 0x03, 0x80, 0x82, 0x77, 0x12, 
-	0x00, 0x56, 0x10, 0xe1, 0x00, 0x02, 0x77, 0x13, 
-	0x00, 0x56, 0x80, 0x82, 0x77, 0x12, 0x00, 0x56, 
-	0x10, 0xe1, 0x00, 0x03, 0x80, 0x82, 0x10, 0xe1, 
-	0x00, 0x04, 0x77, 0x12, 0x00, 0x56, 0x80, 0x82, 
-	0x77, 0x12, 0x00, 0x56, 0x10, 0xe1, 0x00, 0x01, 
-	0x80, 0x82, 0xe7, 0x12, 0xe5, 0x01, 0xf9, 0x80, 
-	0x16, 0x9a, 0x8a, 0x16, 0x8a, 0x11, 0xf4, 0xe4, 
-	0x4a, 0x11, 0x4a, 0x16, 0x4a, 0x17, 0xee, 0xf9, 
-	0x77, 0x11, 0x00, 0x7b, 0x76, 0x00, 0x00, 0x16, 
-	0x76, 0x01, 0x00, 0x17, 0x76, 0x02, 0x00, 0x1a, 
-	0x76, 0x03, 0x00, 0x1b, 0x76, 0x04, 0x00, 0x1c, 
-	0x76, 0x05, 0x00, 0x1d, 0x71, 0x81, 0x00, 0x17, 
-	0x71, 0xe7, 0x00, 0x06, 0x00, 0x11, 0x10, 0x81, 
-	0xf8, 0x44, 0x14, 0xdf, 0xf9, 0x80, 0x16, 0x53, 
-	0xf6, 0xb8, 0xfb, 0x80, 0x15, 0x85, 0xf0, 0x20, 
-	0xff, 0xff, 0xf6, 0xb8, 0xfb, 0x80, 0x16, 0x08, 
-	0xf0, 0x20, 0xff, 0xff, 0x77, 0x11, 0x00, 0x7b, 
-	0x71, 0x81, 0x00, 0x17, 0x76, 0xe7, 0x00, 0x06, 
-	0x00, 0x01, 0x48, 0x17, 0x77, 0x16, 0x00, 0x00, 
-	0x77, 0x10, 0x00, 0x04, 0x77, 0x15, 0x00, 0x03, 
-	0x77, 0x14, 0x00, 0x02, 0x77, 0x13, 0x00, 0x01, 
-	0xf0, 0x00, 0x00, 0x39, 0x76, 0xe7, 0x00, 0x08, 
-	0x00, 0x1f, 0x76, 0xe7, 0x00, 0x07, 0x00, 0x00, 
-	0x88, 0x0e, 0x77, 0x1a, 0x00, 0x05, 0x48, 0x17, 
-	0xf0, 0x00, 0x00, 0x09, 0x88, 0x12, 0x48, 0x18, 
-	0x88, 0x19, 0xe8, 0x00, 0xf0, 0x72, 0x15, 0x2c, 
-	0x73, 0x19, 0x00, 0x11, 0x76, 0x82, 0x00, 0x00, 
-	0x11, 0x91, 0x73, 0x11, 0x00, 0x19, 0x70, 0xe2, 
-	0x00, 0x03, 0x00, 0x16, 0x70, 0xe2, 0x00, 0x04, 
-	0x00, 0x13, 0x70, 0xe2, 0x00, 0x05, 0x00, 0x14, 
-	0x81, 0xe2, 0x00, 0x01, 0x70, 0xe2, 0x00, 0x06, 
-	0x00, 0x15, 0x70, 0xe2, 0x00, 0x07, 0x00, 0x10, 
-	0x80, 0xe2, 0x00, 0x02, 0x73, 0x0e, 0x00, 0x11, 
-	0xf1, 0x00, 0x00, 0x1e, 0x6d, 0xee, 0x00, 0x05, 
-	0x6d, 0xeb, 0x00, 0x05, 0x6d, 0xec, 0x00, 0x05, 
-	0x6d, 0xed, 0x00, 0x05, 0x6d, 0xe8, 0x00, 0x05, 
-	0xf0, 0x00, 0x00, 0x01, 0x81, 0x91, 0x6d, 0xea, 
-	0x00, 0x08, 0x73, 0x11, 0x00, 0x0e, 0xee, 0x07, 
-	0x76, 0xe7, 0x00, 0x41, 0x00, 0x24, 0x76, 0xe7, 
-	0x00, 0x46, 0x00, 0x25, 0x76, 0xe7, 0x00, 0x4b, 
-	0x00, 0x26, 0x76, 0xe7, 0x00, 0x50, 0x00, 0x27, 
-	0x8a, 0x17, 0x8a, 0x16, 0x8a, 0x11, 0xf4, 0xe4, 
-	0x4a, 0x11, 0x4a, 0x16, 0xee, 0xfe, 0x88, 0x11, 
-	0x56, 0x06, 0x4e, 0x00, 0xf9, 0x80, 0x16, 0xa2, 
-	0xf7, 0xb8, 0x10, 0xf8, 0x00, 0x11, 0xf0, 0x10, 
-	0xff, 0xff, 0xfa, 0x45, 0x15, 0x60, 0x77, 0x16, 
-	0xff, 0xff, 0x77, 0x12, 0x00, 0x7b, 0x49, 0x11, 
-	0x10, 0x82, 0xf6, 0x03, 0xf0, 0x00, 0x00, 0x09, 
-	0x88, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x10, 0x81, 
-	0xf8, 0x44, 0x15, 0x71, 0xf2, 0x73, 0x15, 0x71, 
-	0xf4, 0x95, 0xe7, 0x16, 0x77, 0x11, 0x00, 0x7b, 
-	0x10, 0x81, 0xf0, 0x00, 0x00, 0x09, 0x88, 0x11, 
-	0xf4, 0x95, 0x77, 0x12, 0x00, 0x06, 0x10, 0x81, 
-	0xf8, 0x45, 0x15, 0x5c, 0x6e, 0xea, 0xff, 0xff, 
-	0x15, 0x69, 0x6d, 0xe9, 0x00, 0x08, 0x76, 0x86, 
-	0x00, 0x01, 0xe9, 0x01, 0x56, 0x00, 0xf1, 0x80, 
-	0x10, 0xf8, 0x00, 0x0b, 0xf8, 0x45, 0x15, 0x7e, 
-	0xfb, 0x80, 0x15, 0x85, 0xf4, 0x95, 0x48, 0x16, 
-	0xf9, 0x80, 0x16, 0x9a, 0xee, 0x02, 0x48, 0x16, 
-	0x8a, 0x16, 0x8a, 0x11, 0xf4, 0xe4, 0x4a, 0x11, 
-	0xee, 0xff, 0xfb, 0x80, 0x16, 0xa2, 0x88, 0x11, 
-	0xf4, 0x95, 0x77, 0x10, 0xff, 0xff, 0xf4, 0xa9, 
-	0xf8, 0x30, 0x15, 0xc4, 0x10, 0xe1, 0x00, 0x03, 
-	0x77, 0x12, 0x00, 0x55, 0x80, 0x82, 0x77, 0x12, 
-	0x00, 0x56, 0x76, 0x82, 0x00, 0x00, 0x77, 0x12, 
-	0x00, 0x56, 0x76, 0x82, 0x00, 0x00, 0x77, 0x12, 
-	0x00, 0x56, 0x76, 0x82, 0x00, 0x00, 0x77, 0x12, 
-	0x00, 0x56, 0x76, 0x82, 0x00, 0x00, 0x77, 0x12, 
-	0x00, 0x56, 0x76, 0x82, 0x00, 0x00, 0x10, 0xe1, 
-	0x00, 0x02, 0xf0, 0x00, 0x00, 0x08, 0x32, 0xf8, 
-	0x00, 0x08, 0x77, 0x12, 0x00, 0x54, 0xe8, 0x01, 
-	0xf4, 0x82, 0xf4, 0x93, 0x18, 0x82, 0x77, 0x12, 
-	0x00, 0x54, 0xf0, 0x40, 0x00, 0x00, 0x80, 0x82, 
-	0x10, 0xe1, 0x00, 0x01, 0xf9, 0x80, 0x16, 0x76, 
-	0x10, 0xe1, 0x00, 0x01, 0xf9, 0x80, 0x16, 0x66, 
-	0xf0, 0x73, 0x16, 0x03, 0x77, 0x11, 0x00, 0x7b, 
-	0x71, 0x81, 0x00, 0x11, 0x71, 0xe1, 0x00, 0x07, 
-	0x00, 0x12, 0x76, 0x82, 0x00, 0x00, 0x10, 0xe1, 
-	0x00, 0x09, 0xf9, 0x80, 0x15, 0x85, 0x77, 0x11, 
-	0x00, 0x7b, 0x71, 0x81, 0x00, 0x11, 0x10, 0xe1, 
-	0x00, 0x09, 0xfb, 0x80, 0x15, 0x85, 0xf0, 0x00, 
-	0x00, 0x08, 0x77, 0x11, 0x00, 0x7b, 0x71, 0x81, 
-	0x00, 0x11, 0x10, 0xe1, 0x00, 0x09, 0xfb, 0x80, 
-	0x15, 0x85, 0xf0, 0x00, 0x00, 0x10, 0x77, 0x11, 
-	0x00, 0x7b, 0x71, 0x81, 0x00, 0x11, 0x10, 0xe1, 
-	0x00, 0x09, 0xfb, 0x80, 0x15, 0x85, 0xf0, 0x00, 
-	0x00, 0x18, 0x77, 0x11, 0x00, 0x7b, 0x71, 0x81, 
-	0x00, 0x11, 0x10, 0xe1, 0x00, 0x09, 0xfb, 0x80, 
-	0x15, 0x85, 0xf0, 0x00, 0x00, 0x20, 0x77, 0x11, 
-	0x00, 0x7b, 0x71, 0x81, 0x00, 0x11, 0x10, 0xe1, 
-	0x00, 0x09, 0xfb, 0x80, 0x15, 0x85, 0xf0, 0x00, 
-	0x00, 0x28, 0xf9, 0x80, 0x16, 0x9a, 0xee, 0x01, 
-	0x8a, 0x11, 0xf4, 0xe4, 0x4a, 0x11, 0xee, 0xff, 
-	0xfb, 0x80, 0x16, 0xa2, 0x88, 0x11, 0xf4, 0x95, 
-	0x77, 0x10, 0xff, 0xff, 0xf4, 0xa9, 0xf8, 0x30, 
-	0x16, 0x41, 0x77, 0x11, 0x00, 0x55, 0x76, 0x81, 
-	0x00, 0x1e, 0x77, 0x11, 0x00, 0x56, 0x76, 0x81, 
-	0x00, 0x00, 0x77, 0x11, 0x00, 0x56, 0x76, 0x81, 
-	0x00, 0x00, 0x77, 0x11, 0x00, 0x56, 0x76, 0x81, 
-	0x00, 0x00, 0x77, 0x11, 0x00, 0x56, 0x76, 0x81, 
-	0x00, 0x00, 0x77, 0x11, 0x00, 0x56, 0x76, 0x81, 
-	0x00, 0x00, 0x77, 0x11, 0x00, 0x56, 0x76, 0x81, 
-	0x00, 0x00, 0x77, 0x11, 0x00, 0x56, 0x76, 0x81, 
-	0x00, 0x00, 0x77, 0x11, 0x00, 0x56, 0x76, 0x81, 
-	0x00, 0x00, 0x77, 0x11, 0x00, 0x56, 0x76, 0x81, 
-	0x00, 0x00, 0x77, 0x11, 0x00, 0x56, 0xf2, 0x73, 
-	0x16, 0x4e, 0x76, 0x81, 0x00, 0x00, 0x77, 0x11, 
-	0x00, 0x7b, 0x71, 0x81, 0x00, 0x11, 0x71, 0xe1, 
-	0x00, 0x07, 0x00, 0x12, 0x76, 0x82, 0x00, 0x00, 
-	0x10, 0xe1, 0x00, 0x39, 0xf9, 0x80, 0x16, 0x08, 
-	0xf9, 0x80, 0x16, 0x9a, 0xee, 0x01, 0x8a, 0x11, 
-	0xf4, 0xe4, 0x4a, 0x11, 0x77, 0x11, 0x00, 0x7b, 
-	0x10, 0x81, 0xf0, 0x00, 0x00, 0x04, 0x88, 0x11, 
-	0xf4, 0x95, 0xf4, 0x95, 0x10, 0x81, 0xfa, 0x44, 
-	0x16, 0x63, 0xf4, 0x95, 0xee, 0xff, 0x76, 0x81, 
-	0x00, 0x01, 0xee, 0x01, 0x8a, 0x11, 0xf4, 0xe4, 
-	0xf0, 0x10, 0x00, 0x10, 0x4a, 0x11, 0x32, 0xf8, 
-	0x00, 0x08, 0xee, 0xff, 0x77, 0x11, 0x00, 0x01, 
-	0xe8, 0x01, 0xee, 0x01, 0xf4, 0x82, 0x1a, 0x81, 
-	0x80, 0x81, 0x8a, 0x11, 0xf4, 0x95, 0xf4, 0xe4, 
-	0xf0, 0x10, 0x00, 0x10, 0x4a, 0x11, 0x32, 0xf8, 
-	0x00, 0x08, 0xee, 0xff, 0xe8, 0x01, 0x77, 0x11, 
-	0x00, 0x00, 0xf4, 0x82, 0xee, 0x01, 0xf4, 0x93, 
-	0x18, 0x81, 0x80, 0x81, 0x8a, 0x11, 0xf4, 0x95, 
-	0xf4, 0xe4, 0x4a, 0x11, 0xf0, 0x10, 0x00, 0x10, 
-	0x77, 0x11, 0x00, 0x00, 0x32, 0xf8, 0x00, 0x08, 
-	0xee, 0xff, 0x11, 0x81, 0xe8, 0x01, 0xee, 0x01, 
-	0x77, 0x11, 0x00, 0x00, 0xf4, 0x82, 0xf2, 0xa0, 
-	0x80, 0x81, 0x8a, 0x11, 0xf4, 0x95, 0xf4, 0xe4, 
-	0xf2, 0x73, 0x16, 0x9e, 0xf6, 0xbb, 0xf4, 0x95, 
-	0xf4, 0x95, 0xf4, 0x95, 0xf4, 0x95, 0xf4, 0xe4, 
-	0xf2, 0x73, 0x16, 0xa6, 0xf7, 0xbb, 0xf4, 0x95, 
-	0xf4, 0x95, 0xf4, 0x95, 0xf4, 0x95, 0xf4, 0xe4, 
-	0x4a, 0x11, 0x4a, 0x16, 0xf4, 0x95, 0x71, 0x04, 
-	0x00, 0x16, 0xfb, 0x80, 0x16, 0xa2, 0x88, 0x11, 
-	0xf4, 0x95, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 
-	0x76, 0x82, 0x00, 0x0e, 0x10, 0xe6, 0x00, 0x0e, 
-	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x80, 0x82, 
-	0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 
-	0x00, 0x0d, 0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 
-	0x10, 0xe6, 0x00, 0x0d, 0x80, 0x82, 0x71, 0xe1, 
-	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x0c, 
-	0x10, 0xe6, 0x00, 0x0c, 0x71, 0xe1, 0x00, 0x06, 
-	0x00, 0x12, 0x80, 0x82, 0x71, 0xe1, 0x00, 0x05, 
-	0x00, 0x12, 0x76, 0x82, 0x00, 0x0b, 0x10, 0xe6, 
-	0x00, 0x0b, 0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 
-	0x80, 0x82, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 
-	0x76, 0x82, 0x00, 0x0a, 0x71, 0xe1, 0x00, 0x06, 
-	0x00, 0x12, 0x10, 0xe6, 0x00, 0x0a, 0x80, 0x82, 
-	0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 
-	0x00, 0x09, 0x10, 0xe6, 0x00, 0x09, 0x71, 0xe1, 
-	0x00, 0x06, 0x00, 0x12, 0x80, 0x82, 0x71, 0xe1, 
-	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x08, 
-	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x10, 0xe6, 
-	0x00, 0x08, 0x80, 0x82, 0x71, 0xe1, 0x00, 0x05, 
-	0x00, 0x12, 0x76, 0x82, 0x00, 0x07, 0x10, 0xe6, 
-	0x00, 0x07, 0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 
-	0x80, 0x82, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 
-	0x76, 0x82, 0x00, 0x06, 0x71, 0xe1, 0x00, 0x06, 
-	0x00, 0x12, 0x10, 0xe6, 0x00, 0x06, 0x80, 0x82, 
-	0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 
-	0x00, 0x05, 0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 
-	0x10, 0xe6, 0x00, 0x05, 0x80, 0x82, 0x71, 0xe1, 
-	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x04, 
-	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x10, 0xe6, 
-	0x00, 0x04, 0x80, 0x82, 0x71, 0xe1, 0x00, 0x05, 
-	0x00, 0x12, 0x76, 0x82, 0x00, 0x03, 0x71, 0xe1, 
-	0x00, 0x06, 0x00, 0x12, 0x10, 0xe6, 0x00, 0x03, 
-	0x80, 0x82, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 
-	0x76, 0x82, 0x00, 0x02, 0x10, 0xe6, 0x00, 0x02, 
-	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x80, 0x82, 
-	0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 
-	0x00, 0x01, 0x10, 0xe6, 0x00, 0x01, 0x71, 0xe1, 
-	0x00, 0x06, 0x00, 0x12, 0x80, 0x82, 0x71, 0xe1, 
-	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x00, 
-	0x71, 0xe1, 0x00, 0x06, 0x00, 0x13, 0xe7, 0x62, 
-	0xe5, 0x01, 0xf9, 0x80, 0x16, 0x9a, 0x8a, 0x16, 
-	0x8a, 0x11, 0xf4, 0xe4, 0x4a, 0x11, 0x88, 0x11, 
-	0xf4, 0x95, 0xf4, 0x95, 0x71, 0xe1, 0x00, 0x05, 
-	0x00, 0x12, 0xee, 0xff, 0x76, 0x82, 0x00, 0x00, 
-	0xee, 0x01, 0x71, 0xe1, 0x00, 0x06, 0x00, 0x11, 
-	0x69, 0x81, 0x00, 0x01, 0x8a, 0x11, 0xf4, 0x95, 
-	0xf4, 0xe4, 0x4a, 0x11, 0x88, 0x11, 0xf4, 0x95, 
-	0xf4, 0x95, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 
-	0xee, 0xff, 0x76, 0x82, 0x00, 0x01, 0xee, 0x01, 
-	0x71, 0xe1, 0x00, 0x06, 0x00, 0x11, 0x69, 0x81, 
-	0x00, 0x01, 0x8a, 0x11, 0xf4, 0x95, 0xf4, 0xe4, 
-	0x4a, 0x11, 0x77, 0x11, 0x00, 0x7b, 0x10, 0x81, 
-	0xf0, 0x00, 0x00, 0x94, 0x88, 0x11, 0xf4, 0x95, 
-	0xf4, 0x95, 0x10, 0x81, 0xfa, 0x44, 0x17, 0x9c, 
-	0xf4, 0x95, 0xee, 0xff, 0xf9, 0x80, 0x16, 0x53, 
-	0x77, 0x11, 0x00, 0x7b, 0x10, 0x81, 0xf0, 0x00, 
-	0x00, 0x94, 0x88, 0x11, 0xf4, 0x95, 0xf4, 0x95, 
-	0x76, 0x81, 0x00, 0x01, 0xee, 0x01, 0x76, 0xe1, 
-	0x00, 0x01, 0x00, 0x00, 0x76, 0xe1, 0x00, 0x02, 
-	0x00, 0x21, 0x76, 0xe1, 0x00, 0x03, 0x00, 0x20, 
-	0x76, 0xe1, 0x00, 0x04, 0x00, 0x23, 0x76, 0xe1, 
-	0x00, 0x05, 0x00, 0x22, 0x76, 0xe1, 0x00, 0x06, 
-	0x00, 0x38, 0x76, 0xe1, 0x00, 0x07, 0x00, 0x39, 
-	0x76, 0xe1, 0x00, 0x08, 0x00, 0x15, 0x76, 0xe1, 
-	0x00, 0x09, 0x00, 0x14, 0x76, 0xe1, 0x00, 0x0a, 
-	0x00, 0x00, 0x76, 0xe1, 0x00, 0x0b, 0x00, 0x41, 
-	0x76, 0xe1, 0x00, 0x0c, 0x00, 0x40, 0x76, 0xe1, 
-	0x00, 0x0d, 0x00, 0x43, 0x76, 0xe1, 0x00, 0x0e, 
-	0x00, 0x42, 0x76, 0xe1, 0x00, 0x0f, 0x00, 0x48, 
-	0x76, 0xe1, 0x00, 0x10, 0x00, 0x49, 0x76, 0xe1, 
-	0x00, 0x11, 0x00, 0x1b, 0x76, 0xe1, 0x00, 0x12, 
-	0x00, 0x1a, 0x8a, 0x11, 0xf4, 0x95, 0xf4, 0xe4, 
-	0x4a, 0x11, 0xee, 0xfd, 0x88, 0x11, 0x56, 0x06, 
-	0x4e, 0x00, 0xf9, 0x80, 0x16, 0xa2, 0x77, 0x12, 
-	0x00, 0x7b, 0x77, 0x0e, 0x00, 0x09, 0x10, 0x82, 
-	0x28, 0xf8, 0x00, 0x11, 0xf0, 0x00, 0x00, 0x95, 
-	0x88, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x10, 0x81, 
-	0xf8, 0x45, 0x17, 0xf0, 0xf2, 0x73, 0x17, 0xfd, 
-	0x77, 0x11, 0xff, 0xff, 0x76, 0x81, 0x00, 0x01, 
-	0xe9, 0x01, 0x56, 0x00, 0xf1, 0x80, 0x10, 0xf8, 
-	0x00, 0x0b, 0xf8, 0x45, 0x17, 0xfd, 0xfb, 0x80, 
-	0x18, 0x10, 0xf4, 0x95, 0x48, 0x11, 0xf9, 0x80, 
-	0x16, 0x9a, 0xee, 0x03, 0x48, 0x11, 0x8a, 0x11, 
-	0xf4, 0x95, 0xf4, 0xe4, 0x4a, 0x11, 0x88, 0x11, 
-	0xf4, 0x95, 0xee, 0xff, 0x71, 0xe1, 0x00, 0x01, 
-	0x00, 0x11, 0xee, 0x01, 0x10, 0x81, 0x8a, 0x11, 
-	0xf4, 0x95, 0xf4, 0xe4, 0x4a, 0x11, 0xee, 0xff, 
-	0xfb, 0x80, 0x16, 0xa2, 0x88, 0x11, 0xf4, 0x95, 
-	0x77, 0x10, 0xff, 0xff, 0xf4, 0xa9, 0xf8, 0x30, 
-	0x18, 0xc3, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 
-	0x76, 0x82, 0x00, 0x00, 0x71, 0xe1, 0x00, 0x06, 
-	0x00, 0x12, 0x76, 0x82, 0x00, 0x00, 0x71, 0xe1, 
-	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x01, 
-	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x76, 0x82, 
-	0x00, 0x00, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 
-	0x76, 0x82, 0x00, 0x02, 0x71, 0xe1, 0x00, 0x06, 
-	0x00, 0x12, 0x76, 0x82, 0x00, 0x00, 0x71, 0xe1, 
-	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x03, 
-	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x76, 0x82, 
-	0x00, 0x00, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 
-	0x76, 0x82, 0x00, 0x04, 0x71, 0xe1, 0x00, 0x06, 
-	0x00, 0x12, 0x76, 0x82, 0x00, 0x00, 0x71, 0xe1, 
-	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x05, 
-	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x76, 0x82, 
-	0x00, 0x00, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 
-	0x76, 0x82, 0x00, 0x06, 0x71, 0xe1, 0x00, 0x06, 
-	0x00, 0x12, 0x76, 0x82, 0x00, 0x01, 0x71, 0xe1, 
-	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x07, 
-	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x76, 0x82, 
-	0x20, 0x00, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 
-	0x76, 0x82, 0x00, 0x08, 0x71, 0xe1, 0x00, 0x06, 
-	0x00, 0x12, 0x76, 0x82, 0x00, 0x00, 0x71, 0xe1, 
-	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x09, 
-	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x76, 0x82, 
-	0x00, 0x00, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 
-	0x76, 0x82, 0x00, 0x0a, 0x71, 0xe1, 0x00, 0x06, 
-	0x00, 0x12, 0x76, 0x82, 0x00, 0x00, 0x71, 0xe1, 
-	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x0b, 
-	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x76, 0x82, 
-	0x00, 0x00, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 
-	0x76, 0x82, 0x00, 0x0c, 0x71, 0xe1, 0x00, 0x06, 
-	0x00, 0x12, 0x76, 0x82, 0x00, 0x00, 0x71, 0xe1, 
-	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x0d, 
-	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x76, 0x82, 
-	0x00, 0x00, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 
-	0x76, 0x82, 0x00, 0x0e, 0x71, 0xe1, 0x00, 0x06, 
-	0x00, 0x12, 0x76, 0x82, 0x00, 0x00, 0x10, 0xe1, 
-	0x00, 0x07, 0xf9, 0x80, 0x16, 0x76, 0x10, 0xe1, 
-	0x00, 0x08, 0xf9, 0x80, 0x16, 0x76, 0x10, 0xe1, 
-	0x00, 0x07, 0xf9, 0x80, 0x16, 0x66, 0x10, 0xe1, 
-	0x00, 0x08, 0xf9, 0x80, 0x16, 0x66, 0xf0, 0x73, 
-	0x18, 0xd1, 0x77, 0x11, 0x00, 0x7b, 0x10, 0x81, 
-	0xfb, 0x80, 0x18, 0x10, 0xf0, 0x00, 0x00, 0x95, 
-	0x77, 0x11, 0x00, 0x7b, 0x10, 0x81, 0xfb, 0x80, 
-	0x18, 0x10, 0xf0, 0x00, 0x00, 0x9e, 0xf9, 0x80, 
-	0x16, 0x9a, 0xee, 0x01, 0x8a, 0x11, 0xf4, 0xe4, 
-	0x4a, 0x11, 0x88, 0x11, 0xee, 0xff, 0xf4, 0x95, 
-	0x10, 0x04, 0x71, 0xe1, 0x00, 0x03, 0x00, 0x11, 
-	0xee, 0x01, 0x80, 0x81, 0x8a, 0x11, 0xf4, 0x95, 
-	0xf4, 0xe4, 0x4a, 0x11, 0x4a, 0x16, 0xf4, 0x95, 
-	0x71, 0x04, 0x00, 0x16, 0xfb, 0x80, 0x16, 0xa2, 
-	0x88, 0x11, 0xf4, 0x95, 0x71, 0xe1, 0x00, 0x02, 
-	0x00, 0x12, 0x76, 0x82, 0x00, 0x10, 0x10, 0xe6, 
-	0x00, 0x01, 0x71, 0xe1, 0x00, 0x03, 0x00, 0x12, 
-	0x80, 0x82, 0x71, 0xe1, 0x00, 0x04, 0x00, 0x12, 
-	0x10, 0xe6, 0x00, 0x02, 0x80, 0x82, 0xe7, 0x62, 
-	0x71, 0xe1, 0x00, 0x02, 0x00, 0x13, 0xe5, 0x01, 
-	0xf9, 0x80, 0x16, 0x9a, 0x8a, 0x16, 0x8a, 0x11, 
-	0xf4, 0xe4, 0x4a, 0x11, 0x88, 0x11, 0xee, 0xff, 
-	0xee, 0x01, 0x10, 0xe1, 0x00, 0x01, 0x8a, 0x11, 
-	0xf4, 0x95, 0xf4, 0xe4, 0x4a, 0x11, 0x77, 0x11, 
-	0x00, 0x7b, 0x10, 0x81, 0xf0, 0x00, 0x00, 0xb3, 
-	0x88, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x10, 0x81, 
-	0xfa, 0x44, 0x19, 0x2a, 0xf4, 0x95, 0xee, 0xff, 
-	0xf9, 0x80, 0x16, 0x53, 0x77, 0x11, 0x00, 0x7b, 
-	0x10, 0x81, 0xf0, 0x00, 0x00, 0xb3, 0x88, 0x11, 
-	0xf4, 0x95, 0xf4, 0x95, 0x76, 0x81, 0x00, 0x01, 
-	0xee, 0x01, 0x76, 0xe1, 0x00, 0x01, 0x00, 0x00, 
-	0x76, 0xe1, 0x00, 0x02, 0x00, 0x13, 0x76, 0xe1, 
-	0x00, 0x03, 0x00, 0x26, 0x76, 0xe1, 0x00, 0x04, 
-	0x00, 0x25, 0x76, 0xe1, 0x00, 0x05, 0x00, 0x24, 
-	0x76, 0xe1, 0x00, 0x06, 0x00, 0x00, 0x76, 0xe1, 
-	0x00, 0x07, 0x00, 0x17, 0x76, 0xe1, 0x00, 0x08, 
-	0x00, 0x32, 0x76, 0xe1, 0x00, 0x09, 0x00, 0x31, 
-	0x76, 0xe1, 0x00, 0x0a, 0x00, 0x30, 0x8a, 0x11, 
-	0xf4, 0x95, 0xf4, 0xe4, 0x4a, 0x11, 0x4a, 0x16, 
-	0x4a, 0x17, 0xee, 0xff, 0xf4, 0x95, 0x71, 0x06, 
-	0x00, 0x17, 0xfb, 0x80, 0x16, 0xa2, 0x88, 0x11, 
-	0xf4, 0x95, 0xf7, 0xb8, 0x10, 0xf8, 0x00, 0x11, 
-	0xf0, 0x10, 0xff, 0xff, 0xfa, 0x45, 0x19, 0x73, 
-	0x77, 0x16, 0xff, 0xff, 0x77, 0x12, 0x00, 0x7b, 
-	0x77, 0x0e, 0x00, 0x05, 0x10, 0x82, 0x28, 0xf8, 
-	0x00, 0x11, 0xf0, 0x00, 0x00, 0xb4, 0x88, 0x11, 
-	0xf4, 0x95, 0xf4, 0x95, 0x10, 0x81, 0xf8, 0x44, 
-	0x19, 0x84, 0xf2, 0x73, 0x19, 0x84, 0xf4, 0x95, 
-	0xe7, 0x16, 0x77, 0x11, 0x00, 0x7b, 0x10, 0x81, 
-	0xf0, 0x00, 0x00, 0xb4, 0x88, 0x11, 0xf4, 0x95, 
-	0x77, 0x12, 0x00, 0x02, 0x10, 0x81, 0xf8, 0x45, 
-	0x19, 0x6f, 0x6e, 0xea, 0xff, 0xff, 0x19, 0x7c, 
-	0x6d, 0xe9, 0x00, 0x05, 0x61, 0xf8, 0x00, 0x17, 
-	0x00, 0x01, 0xfa, 0x20, 0x19, 0x8f, 0x76, 0x86, 
-	0x00, 0x01, 0xfb, 0x80, 0x19, 0x97, 0xf4, 0x95, 
-	0x48, 0x16, 0xf9, 0x80, 0x16, 0x9a, 0xee, 0x01, 
-	0x8a, 0x17, 0x48, 0x16, 0x8a, 0x16, 0x8a, 0x11, 
-	0xf4, 0xe4, 0x4a, 0x11, 0xee, 0xff, 0xfb, 0x80, 
-	0x16, 0xa2, 0x88, 0x11, 0xf4, 0x95, 0x77, 0x10, 
-	0xff, 0xff, 0xf4, 0xa9, 0xf8, 0x30, 0x19, 0xcc, 
-	0x71, 0xe1, 0x00, 0x02, 0x00, 0x12, 0x69, 0x82, 
-	0x00, 0x10, 0x71, 0xe1, 0x00, 0x02, 0x00, 0x12, 
-	0x68, 0x82, 0xf7, 0xff, 0x71, 0xe1, 0x00, 0x02, 
-	0x00, 0x12, 0x68, 0x82, 0xfb, 0xff, 0x71, 0xe1, 
-	0x00, 0x02, 0x00, 0x12, 0x68, 0x82, 0xff, 0xf0, 
-	0x71, 0xe1, 0x00, 0x03, 0x00, 0x12, 0x76, 0x82, 
-	0xff, 0xff, 0x71, 0xe1, 0x00, 0x04, 0x00, 0x12, 
-	0x76, 0x82, 0xff, 0xff, 0x71, 0xe1, 0x00, 0x02, 
-	0x00, 0x12, 0x69, 0x82, 0x00, 0x20, 0x71, 0xe1, 
-	0x00, 0x02, 0x00, 0x11, 0xf2, 0x73, 0x19, 0xda, 
-	0x68, 0x81, 0xff, 0xef, 0x77, 0x11, 0x00, 0x7b, 
-	0x10, 0x81, 0xfb, 0x80, 0x19, 0x97, 0xf0, 0x00, 
-	0x00, 0xb4, 0x77, 0x11, 0x00, 0x7b, 0x10, 0x81, 
-	0xfb, 0x80, 0x19, 0x97, 0xf0, 0x00, 0x00, 0xb9, 
-	0xf9, 0x80, 0x16, 0x9a, 0xee, 0x01, 0x8a, 0x11, 
-	0xf4, 0xe4, 0x00, 0xa4, 0x00, 0x00, 0x19, 0xdf, 
-	0x00, 0x01, 0x2a, 0xe6, 0x00, 0x00, 0x00, 0x01, 
-	0x2a, 0xe7, 0x00, 0x00, 0x00, 0x03, 0x2a, 0x12, 
-	0x0c, 0x01, 0xc3, 0x4f, 0x00, 0x00, 0x00, 0x01, 
-	0x2a, 0x15, 0x00, 0x00, 0x00, 0x02, 0x2a, 0x16, 
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x2a, 0x5d, 
-	0x00, 0x43, 0x00, 0x6f, 0x00, 0x70, 0x00, 0x79, 
-	0x00, 0x72, 0x00, 0x69, 0x00, 0x67, 0x00, 0x68, 
-	0x00, 0x74, 0x00, 0x20, 0x00, 0x54, 0x00, 0x65, 
-	0x00, 0x63, 0x00, 0x68, 0x00, 0x6e, 0x00, 0x6f, 
-	0x00, 0x54, 0x00, 0x72, 0x00, 0x65, 0x00, 0x6e, 
-	0x00, 0x64, 0x00, 0x20, 0x00, 0x41, 0x00, 0x47, 
-	0x00, 0x00, 0x00, 0x04, 0x2a, 0x76, 0x00, 0x30, 
-	0x00, 0x2e, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0c, 
-	0x2a, 0x7a, 0x00, 0x46, 0x00, 0x65, 0x00, 0x62, 
-	0x00, 0x20, 0x00, 0x32, 0x00, 0x37, 0x00, 0x20, 
-	0x00, 0x32, 0x00, 0x30, 0x00, 0x30, 0x00, 0x31, 
-	0x00, 0x00, 0x00, 0x09, 0x2a, 0x86, 0x00, 0x31, 
-	0x00, 0x34, 0x00, 0x3a, 0x00, 0x33, 0x00, 0x35, 
-	0x00, 0x3a, 0x00, 0x33, 0x00, 0x33, 0x00, 0x00, 
-	0x00, 0x0f, 0x2a, 0x8f, 0x00, 0x00, 0x00, 0x00, 
-	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0x00, 0x00, 0x00, 0x01, 0x2a, 0x9e, 0x00, 0x00, 
-	0x00, 0x01, 0x2a, 0x9f, 0x00, 0x00, 0x00, 0x01, 
-	0x2a, 0xa0, 0x00, 0x00, 0x00, 0x01, 0x2a, 0xa1, 
-	0x00, 0x00, 0x00, 0x01, 0x2a, 0xa2, 0x00, 0x00, 
-	0x00, 0x01, 0x29, 0x7e, 0x00, 0x00, 0x00, 0x02, 
-	0x29, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
-	0x29, 0x82, 0xff, 0xff, 0x00, 0x01, 0x2a, 0xa7, 
-	0x00, 0x00, 0x00, 0x05, 0x2a, 0xa8, 0x71, 0x41, 
-	0x20, 0x00, 0x20, 0x00, 0x00, 0x23, 0x04, 0x00, 
-	0x00, 0x0a, 0x2a, 0xad, 0x00, 0x00, 0x00, 0x00, 
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0x00, 0x0f, 0x2a, 0xb7, 0x00, 0x00, 0x00, 0x00, 
-	0x00, 0x00, 0x00, 0x40, 0x00, 0xa0, 0x82, 0x40, 
-	0x00, 0x08, 0x30, 0x7f, 0x00, 0x80, 0x01, 0x80, 
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0x00, 0x00, 0x00, 0x01, 0x27, 0x6e, 0x00, 0x00, 
-	0x00, 0x01, 0x27, 0x6f, 0x00, 0x00, 0x00, 0x00, 
-	0x00, 0x09, 0x00, 0x00, 0x1a, 0x83, 0x04, 0xe8, 
-	0x04, 0xcf, 0x04, 0xc5, 0x04, 0xba, 0x04, 0xb0, 
-	0x04, 0xac, 0x04, 0x9c, 0x04, 0x8c, 0x04, 0x81, 
-	0x00, 0x78, 0x00, 0x00, 0x01, 0x00, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xaa, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x02, 0x23, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x05, 0xe5, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x02, 0xb5, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x0e, 0x33, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0x00, 0x00, 
+	0x08, 0xaa, 0x00, 0x18, 0x00, 0x03, 0x08, 0x00,
+	0x00, 0x10, 0x00, 0x00, 0x01, 0x80, 0x18, 0x5f,
+	0x00, 0x00, 0x01, 0x80, 0x77, 0x18, 0x2a, 0xeb,
+	0x6b, 0xf8, 0x00, 0x18, 0x03, 0xff, 0x68, 0xf8,
+	0x00, 0x18, 0xff, 0xfe, 0xf7, 0xb8, 0xf7, 0xbe,
+	0xf6, 0xb9, 0xf4, 0xa0, 0xf6, 0xb7, 0xf6, 0xb5,
+	0xf6, 0xb6, 0xf0, 0x20, 0x19, 0xdf, 0xf1, 0x00,
+	0x00, 0x01, 0xf8, 0x4d, 0x01, 0xab, 0xf6, 0xb8,
+	0xf0, 0x20, 0x19, 0xdf, 0xf0, 0x73, 0x01, 0xa5,
+	0x7e, 0xf8, 0x00, 0x12, 0xf0, 0x00, 0x00, 0x01,
+	0x47, 0xf8, 0x00, 0x11, 0x7e, 0x92, 0x00, 0xf8,
+	0x00, 0x11, 0xf0, 0x00, 0x00, 0x01, 0x7e, 0xf8,
+	0x00, 0x11, 0xf0, 0x00, 0x00, 0x01, 0x6c, 0x89,
+	0x01, 0x9a, 0xf7, 0xb8, 0xee, 0xfc, 0xf0, 0x20,
+	0xff, 0xff, 0xf1, 0x00, 0x00, 0x01, 0xf8, 0x4d,
+	0x01, 0xbf, 0xf2, 0x73, 0x01, 0xb9, 0x4e, 0x02,
+	0xf4, 0x95, 0xf5, 0xe3, 0x56, 0x02, 0x7e, 0x00,
+	0x11, 0x00, 0xfa, 0x4c, 0x01, 0xb7, 0x6b, 0x03,
+	0x00, 0x01, 0xf6, 0xb8, 0xee, 0x04, 0xf0, 0x74,
+	0x0d, 0xa7, 0xf0, 0x74, 0x01, 0xc5, 0x4a, 0x11,
+	0x4a, 0x16, 0x72, 0x11, 0x2a, 0xe6, 0x10, 0xf8,
+	0x00, 0x11, 0xfa, 0x45, 0x01, 0xdb, 0xf4, 0x95,
+	0xee, 0xff, 0x48, 0x11, 0xf0, 0x00, 0x2a, 0xc6,
+	0x88, 0x16, 0xf4, 0x95, 0xf4, 0x95, 0x10, 0xee,
+	0xff, 0xff, 0xf4, 0xe3, 0x6c, 0xe9, 0xff, 0xff,
+	0x01, 0xd5, 0x10, 0xf8, 0x2a, 0xe7, 0xf8, 0x45,
+	0x01, 0xe2, 0x10, 0xf8, 0x2a, 0xe7, 0xf4, 0xe3,
+	0xf0, 0x74, 0x01, 0xff, 0xee, 0x01, 0x8a, 0x16,
+	0x8a, 0x11, 0xfc, 0x00, 0xf7, 0xb8, 0xe9, 0x20,
+	0x4a, 0x11, 0x09, 0xf8, 0x2a, 0xe6, 0xf8, 0x4e,
+	0x01, 0xf3, 0xf2, 0x73, 0x01, 0xfd, 0xf4, 0x95,
+	0xe8, 0x01, 0x72, 0x11, 0x2a, 0xe6, 0x49, 0x11,
+	0x80, 0xe1, 0x2a, 0xc6, 0xf3, 0x00, 0x00, 0x01,
+	0xe8, 0x00, 0x81, 0xf8, 0x2a, 0xe6, 0x8a, 0x11,
+	0xfc, 0x00, 0xf4, 0x95, 0xf0, 0x73, 0x02, 0x00,
+	0x10, 0xf8, 0x2a, 0x0f, 0xfc, 0x00, 0x4a, 0x11,
+	0xf0, 0x74, 0x02, 0x02, 0x80, 0xf8, 0x2a, 0x10,
+	0x73, 0x08, 0x00, 0x09, 0x40, 0xf8, 0x2a, 0x15,
+	0x82, 0xf8, 0x00, 0x11, 0xf4, 0x95, 0x77, 0x10,
+	0x03, 0xe8, 0xf5, 0xa9, 0xf8, 0x30, 0x02, 0x21,
+	0x71, 0xf8, 0x2a, 0x10, 0x2a, 0x15, 0x56, 0xf8,
+	0x2a, 0x0c, 0xf0, 0xe3, 0x4e, 0xf8, 0x2a, 0x16,
+	0xe8, 0x00, 0x4e, 0xf8, 0x2a, 0x0c, 0x8a, 0x11,
+	0xfc, 0x00, 0x4a, 0x06, 0x4a, 0x07, 0x4a, 0x1d,
+	0x68, 0xf8, 0x00, 0x07, 0x7d, 0x3f, 0x69, 0xf8,
+	0x00, 0x07, 0x40, 0x00, 0x68, 0xf8, 0x00, 0x1d,
+	0xff, 0xfc, 0x6b, 0xf8, 0x2a, 0x0f, 0x00, 0x01,
+	0x8a, 0x1d, 0x8a, 0x07, 0x8a, 0x06, 0xf4, 0xeb,
+	0xee, 0xfd, 0x76, 0xf8, 0x2a, 0x0f, 0x00, 0x00,
+	0x76, 0x00, 0x00, 0x00, 0xfb, 0x80, 0x19, 0x4c,
+	0xf4, 0x95, 0xe8, 0x00, 0x80, 0xf8, 0x2a, 0x11,
+	0xf9, 0x80, 0x19, 0x07, 0x80, 0xf8, 0x2a, 0x0e,
+	0xf9, 0x80, 0x16, 0x66, 0x76, 0x00, 0x2a, 0x12,
+	0x10, 0xf8, 0x2a, 0x11, 0xf9, 0x80, 0x18, 0xe3,
+	0x10, 0xf8, 0x2a, 0x0e, 0xf9, 0x80, 0x16, 0x66,
+	0x10, 0xf8, 0x2a, 0x0e, 0xf9, 0x80, 0x16, 0x87,
+	0xee, 0x03, 0xfc, 0x00, 0x4a, 0x11, 0xf6, 0xb8,
+	0xf4, 0x95, 0xf0, 0x20, 0x80, 0x00, 0x11, 0xf8,
+	0x2a, 0x5a, 0xf8, 0x4d, 0x02, 0x93, 0x11, 0xf8,
+	0x2a, 0x9f, 0xf8, 0x4c, 0x02, 0x7c, 0x77, 0x12,
+	0x2a, 0x39, 0x49, 0x12, 0x01, 0xf8, 0x2a, 0x9f,
+	0x89, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x71, 0x81,
+	0x00, 0x11, 0x6c, 0xe1, 0xff, 0xab, 0x02, 0x93,
+	0x6b, 0xf8, 0x2a, 0x9f, 0x00, 0x01, 0xe9, 0x05,
+	0x01, 0xe2, 0x00, 0x03, 0x81, 0xf8, 0x2a, 0xa0,
+	0xf0, 0x73, 0x02, 0x95, 0x72, 0x11, 0x2a, 0x9f,
+	0xf4, 0x95, 0x10, 0xe1, 0x2a, 0x39, 0x6b, 0xf8,
+	0x2a, 0x9f, 0x00, 0x01, 0x11, 0xf8, 0x2a, 0x9f,
+	0x09, 0xf8, 0x2a, 0xa0, 0xf8, 0x4c, 0x02, 0x93,
+	0x76, 0xf8, 0x2a, 0x5a, 0x00, 0x00, 0x76, 0xf8,
+	0x2a, 0x9f, 0x00, 0x00, 0x76, 0xf8, 0x2a, 0xa0,
+	0x00, 0x00, 0x88, 0x11, 0xf4, 0x95, 0x48, 0x11,
+	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0xee, 0xfe,
+	0x10, 0xf8, 0x2a, 0x5a, 0xf8, 0x44, 0x02, 0xb2,
+	0x76, 0xf8, 0x2a, 0x5a, 0x00, 0x01, 0xf0, 0x74,
+	0x02, 0x58, 0x88, 0x11, 0xf4, 0x95, 0x77, 0x10,
+	0x80, 0x00, 0xf4, 0xa9, 0xf8, 0x30, 0x02, 0xb2,
+	0x48, 0x11, 0xf0, 0x30, 0x00, 0xff, 0x80, 0x00,
+	0x10, 0xf8, 0x2a, 0x5b, 0xf9, 0x80, 0x18, 0xd6,
+	0xee, 0x02, 0x8a, 0x11, 0xfc, 0x00, 0xf4, 0x95,
+	0x4a, 0x08, 0x4a, 0x09, 0x4a, 0x0a, 0x4a, 0x0b,
+	0x4a, 0x0c, 0x4a, 0x0d, 0x4a, 0x10, 0x4a, 0x11,
+	0x4a, 0x12, 0x4a, 0x13, 0x4a, 0x14, 0x4a, 0x15,
+	0x4a, 0x16, 0x4a, 0x17, 0x4a, 0x17, 0x4a, 0x19,
+	0x4a, 0x0e, 0x4a, 0x06, 0x4a, 0x07, 0x4a, 0x1a,
+	0x4a, 0x1d, 0x4a, 0x1b, 0x4a, 0x1c, 0x68, 0xf8,
+	0x00, 0x07, 0x7d, 0x3f, 0x69, 0xf8, 0x00, 0x07,
+	0x40, 0x00, 0x68, 0xf8, 0x00, 0x1d, 0xff, 0xfc,
+	0x48, 0x18, 0x68, 0xf8, 0x00, 0x18, 0xff, 0xfe,
+	0xf4, 0x95, 0xf4, 0x95, 0x4a, 0x08, 0xee, 0xfd,
+	0xf0, 0x74, 0x02, 0x58, 0x88, 0x11, 0xf4, 0x95,
+	0x77, 0x10, 0x80, 0x00, 0xf4, 0xa9, 0xf8, 0x30,
+	0x02, 0xef, 0x48, 0x11, 0xf0, 0x30, 0x00, 0xff,
+	0x80, 0x00, 0x10, 0xf8, 0x2a, 0x5b, 0xf9, 0x80,
+	0x18, 0xd6, 0xee, 0x03, 0x8a, 0x18, 0xf4, 0x95,
+	0x8a, 0x1c, 0x8a, 0x1b, 0x8a, 0x1d, 0x8a, 0x1a,
+	0x8a, 0x07, 0x8a, 0x06, 0x8a, 0x0e, 0x8a, 0x19,
+	0x8a, 0x17, 0x8a, 0x17, 0x8a, 0x16, 0x8a, 0x15,
+	0x8a, 0x14, 0x8a, 0x13, 0x8a, 0x12, 0x8a, 0x11,
+	0x8a, 0x10, 0x8a, 0x0d, 0x8a, 0x0c, 0x8a, 0x0b,
+	0x8a, 0x0a, 0x8a, 0x09, 0x8a, 0x08, 0xf4, 0xeb,
+	0x4a, 0x11, 0x77, 0x11, 0x2a, 0x39, 0x76, 0x81,
+	0x00, 0x55, 0x77, 0x12, 0x2a, 0x18, 0x10, 0xe2,
+	0x00, 0x01, 0x80, 0xe1, 0x00, 0x01, 0x10, 0xe2,
+	0x00, 0x02, 0x80, 0xe1, 0x00, 0x02, 0x76, 0xe1,
+	0x00, 0x03, 0x00, 0x00, 0x76, 0xe1, 0x00, 0x04,
+	0x00, 0xaa, 0xf0, 0x74, 0x02, 0x98, 0x8a, 0x11,
+	0xfc, 0x00, 0x4a, 0x11, 0x88, 0x11, 0xf4, 0x95,
+	0xf4, 0x95, 0x10, 0x81, 0x6f, 0xf8, 0x2a, 0x9e,
+	0x0c, 0x88, 0xe8, 0xff, 0x18, 0xe1, 0x00, 0x01,
+	0x1a, 0xf8, 0x2a, 0x9e, 0xf0, 0x30, 0x1f, 0xff,
+	0x80, 0xf8, 0x2a, 0x9e, 0x8a, 0x11, 0xfc, 0x00,
+	0x4a, 0x11, 0x77, 0x11, 0x2a, 0x39, 0x76, 0x81,
+	0x00, 0x55, 0x77, 0x12, 0x2a, 0x18, 0x11, 0xe2,
+	0x00, 0x01, 0x81, 0xe1, 0x00, 0x01, 0x11, 0xe2,
+	0x00, 0x02, 0x81, 0xe1, 0x00, 0x02, 0x76, 0xe1,
+	0x00, 0x03, 0x00, 0x02, 0x48, 0x08, 0x6f, 0xe1,
+	0x00, 0x04, 0x0c, 0x98, 0xf0, 0x30, 0x00, 0xff,
+	0x80, 0xe1, 0x00, 0x05, 0x76, 0xe1, 0x00, 0x06,
+	0x00, 0xaa, 0xf0, 0x74, 0x02, 0x98, 0x8a, 0x11,
+	0xfc, 0x00, 0x4a, 0x11, 0x77, 0x11, 0x2a, 0x39,
+	0x76, 0x81, 0x00, 0x55, 0x77, 0x12, 0x2a, 0x18,
+	0x10, 0xe2, 0x00, 0x01, 0x80, 0xe1, 0x00, 0x01,
+	0x10, 0xe2, 0x00, 0x02, 0x80, 0xe1, 0x00, 0x02,
+	0x76, 0xe1, 0x00, 0x03, 0x00, 0x04, 0x48, 0x11,
+	0xf0, 0x00, 0x00, 0x04, 0x88, 0x12, 0xf4, 0x95,
+	0x77, 0x13, 0x2a, 0x76, 0xe9, 0x00, 0xe5, 0x98,
+	0xf3, 0x00, 0x00, 0x01, 0xf6, 0xb8, 0x48, 0x0b,
+	0x08, 0xf8, 0x2a, 0x3c, 0xf8, 0x43, 0x03, 0x71,
+	0x76, 0x82, 0x00, 0xaa, 0xf0, 0x74, 0x02, 0x98,
+	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0xee, 0xf0,
+	0x88, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x71, 0x81,
+	0x00, 0x14, 0x71, 0xe1, 0x00, 0x01, 0x00, 0x15,
+	0x49, 0x11, 0xf3, 0x00, 0x00, 0x02, 0x89, 0x11,
+	0xe7, 0x82, 0x6d, 0xea, 0x00, 0x04, 0xe7, 0x83,
+	0x6d, 0xeb, 0x00, 0x0a, 0x77, 0x1a, 0x00, 0x05,
+	0xf0, 0x72, 0x03, 0xaa, 0x11, 0x81, 0xf2, 0xe8,
+	0x80, 0x82, 0xe9, 0xff, 0x19, 0xe1, 0x00, 0x01,
+	0xf1, 0xa0, 0x81, 0x92, 0x11, 0xe1, 0x00, 0x0c,
+	0xf2, 0xe8, 0x80, 0x83, 0xe9, 0xff, 0x19, 0xe1,
+	0x00, 0x0d, 0xf1, 0xa0, 0x81, 0x93, 0x6d, 0xe9,
+	0x00, 0x02, 0x48, 0x18, 0x49, 0x18, 0x70, 0x00,
+	0x00, 0x15, 0xf0, 0x00, 0x00, 0x04, 0xf3, 0x00,
+	0x00, 0x0a, 0x80, 0x01, 0x81, 0x02, 0xf2, 0x74,
+	0x0e, 0x54, 0xf4, 0x95, 0x48, 0x14, 0xee, 0x10,
+	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0xf0, 0x74,
+	0x0c, 0x5e, 0x80, 0xf8, 0x2a, 0x5c, 0x77, 0x12,
+	0x2a, 0x39, 0x76, 0x82, 0x00, 0x55, 0x77, 0x11,
+	0x2a, 0x18, 0x10, 0xe1, 0x00, 0x01, 0x80, 0xe2,
+	0x00, 0x01, 0x10, 0xe1, 0x00, 0x02, 0x80, 0xe2,
+	0x00, 0x02, 0x76, 0xe2, 0x00, 0x03, 0x00, 0x1c,
+	0xf6, 0xb8, 0x56, 0xf8, 0x2a, 0x16, 0xf0, 0xf0,
+	0xf0, 0xf8, 0x80, 0xe2, 0x00, 0x07, 0x56, 0xf8,
+	0x2a, 0x16, 0xf1, 0xf0, 0xe8, 0xff, 0xf2, 0x80,
+	0x80, 0xe2, 0x00, 0x06, 0x56, 0xf8, 0x2a, 0x16,
+	0xf1, 0xf8, 0xe8, 0xff, 0xf2, 0x80, 0x80, 0xe2,
+	0x00, 0x05, 0x57, 0xf8, 0x2a, 0x16, 0xe8, 0xff,
+	0xf2, 0x80, 0x80, 0xe2, 0x00, 0x04, 0x56, 0xf8,
+	0x27, 0x6c, 0xf0, 0xf0, 0xf0, 0xf8, 0x80, 0xe2,
+	0x00, 0x0b, 0x56, 0xf8, 0x27, 0x6c, 0xf1, 0xf0,
+	0xe8, 0xff, 0xf2, 0x80, 0x80, 0xe2, 0x00, 0x0a,
+	0x56, 0xf8, 0x27, 0x6c, 0xf1, 0xf8, 0xe8, 0xff,
+	0xf2, 0x80, 0x80, 0xe2, 0x00, 0x09, 0xe8, 0xff,
+	0x57, 0xf8, 0x27, 0x6c, 0xf2, 0x80, 0x80, 0xe2,
+	0x00, 0x08, 0x56, 0xf8, 0x27, 0x6a, 0xf0, 0xf0,
+	0xf0, 0xf8, 0x80, 0xe2, 0x00, 0x0f, 0x56, 0xf8,
+	0x27, 0x6a, 0xf1, 0xf0, 0xe8, 0xff, 0xf2, 0x80,
+	0x80, 0xe2, 0x00, 0x0e, 0x56, 0xf8, 0x27, 0x6a,
+	0xf1, 0xf8, 0xe8, 0xff, 0xf2, 0x80, 0x80, 0xe2,
+	0x00, 0x0d, 0x57, 0xf8, 0x27, 0x6a, 0xe8, 0xff,
+	0xf2, 0x80, 0x80, 0xe2, 0x00, 0x0c, 0x76, 0xe2,
+	0x00, 0x13, 0x00, 0x00, 0x76, 0xe2, 0x00, 0x12,
+	0x00, 0x00, 0x6f, 0xf8, 0x2a, 0x5c, 0x0c, 0x58,
+	0x80, 0xe2, 0x00, 0x11, 0xe8, 0xff, 0x18, 0xf8,
+	0x2a, 0x5c, 0x80, 0xe2, 0x00, 0x10, 0x76, 0xe2,
+	0x00, 0x17, 0x00, 0x00, 0x76, 0xe2, 0x00, 0x16,
+	0x00, 0x00, 0x6f, 0xf8, 0x2a, 0x9e, 0x0c, 0x58,
+	0x80, 0xe2, 0x00, 0x15, 0xe8, 0xff, 0x18, 0xf8,
+	0x2a, 0x9e, 0x80, 0xe2, 0x00, 0x14, 0x76, 0xe2,
+	0x00, 0x1b, 0x00, 0x00, 0x76, 0xe2, 0x00, 0x1a,
+	0x00, 0x00, 0x76, 0xe2, 0x00, 0x19, 0x00, 0x00,
+	0x70, 0xe2, 0x00, 0x18, 0x27, 0x6e, 0x76, 0xe2,
+	0x00, 0x1f, 0x00, 0x00, 0x76, 0xe2, 0x00, 0x1e,
+	0x00, 0x00, 0x76, 0xe2, 0x00, 0x1d, 0x00, 0x00,
+	0x76, 0xe2, 0x00, 0x1c, 0x00, 0x00, 0x76, 0xe2,
+	0x00, 0x20, 0x00, 0xaa, 0xf0, 0x74, 0x02, 0x98,
+	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0xee, 0xfe,
+	0x10, 0xf8, 0x2a, 0x38, 0xf8, 0x45, 0x04, 0xed,
+	0x77, 0x12, 0x2a, 0x18, 0x10, 0xe2, 0x00, 0x02,
+	0x88, 0x11, 0xf4, 0x95, 0x77, 0x10, 0x00, 0x08,
+	0x6d, 0xe9, 0xff, 0xdf, 0xf6, 0xa9, 0xf8, 0x20,
+	0x04, 0x75, 0xf0, 0x73, 0x04, 0x7d, 0xf0, 0x10,
+	0x00, 0x21, 0xf0, 0x00, 0x1a, 0x83, 0x48, 0x08,
+	0x7e, 0xf8, 0x00, 0x08, 0xf4, 0xe2, 0xf0, 0x74,
+	0x03, 0x0a, 0xf0, 0x73, 0x04, 0xea, 0x48, 0x12,
+	0xf2, 0x74, 0x03, 0x23, 0xf0, 0x00, 0x00, 0x04,
+	0xf2, 0x74, 0x03, 0x36, 0xf4, 0x95, 0xe8, 0x00,
+	0xf0, 0x73, 0x04, 0xea, 0x77, 0x11, 0x2a, 0x18,
+	0xe8, 0xff, 0x6f, 0xe1, 0x00, 0x04, 0x0d, 0x48,
+	0x18, 0xe1, 0x00, 0x05, 0xf2, 0x74, 0x09, 0x69,
+	0xf4, 0x95, 0xf2, 0xa0, 0xf0, 0x74, 0x03, 0x36,
+	0xf0, 0x73, 0x04, 0xea, 0x77, 0x11, 0x2a, 0x18,
+	0xe8, 0xff, 0x6f, 0xe1, 0x00, 0x04, 0x0d, 0x48,
+	0x18, 0xe1, 0x00, 0x05, 0xf2, 0x74, 0x09, 0x41,
+	0xf4, 0x95, 0xf2, 0xa0, 0xf0, 0x74, 0x03, 0x36,
+	0xf0, 0x73, 0x04, 0xea, 0xf0, 0x74, 0x03, 0x57,
+	0xf0, 0x73, 0x04, 0xea, 0x10, 0xf8, 0x2a, 0x1c,
+	0xf0, 0x74, 0x12, 0xa4, 0xf2, 0x74, 0x03, 0x36,
+	0xf4, 0x95, 0xe8, 0x00, 0xf0, 0x73, 0x04, 0xea,
+	0x48, 0x12, 0xf2, 0x74, 0x03, 0x80, 0xf0, 0x00,
+	0x00, 0x04, 0xf2, 0x74, 0x03, 0x36, 0xf4, 0x95,
+	0xe8, 0x00, 0xf0, 0x73, 0x04, 0xea, 0x10, 0xf8,
+	0x2a, 0x1c, 0xf0, 0x74, 0x12, 0xc5, 0xf2, 0x74,
+	0x03, 0x36, 0xf4, 0x95, 0xe8, 0x00, 0xf0, 0x73,
+	0x04, 0xea, 0x77, 0x11, 0x2a, 0x18, 0xe8, 0xff,
+	0x6f, 0xe1, 0x00, 0x06, 0x0d, 0x48, 0x18, 0xe1,
+	0x00, 0x07, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12,
+	0xf2, 0xa0, 0x70, 0x00, 0x00, 0x12, 0x80, 0x01,
+	0x10, 0xe1, 0x00, 0x04, 0xf0, 0x74, 0x0e, 0x7a,
+	0xf2, 0x74, 0x03, 0x36, 0xf4, 0x95, 0xe8, 0x00,
+	0xf0, 0x73, 0x04, 0xea, 0xf0, 0x74, 0x03, 0xbc,
+	0x76, 0xf8, 0x2a, 0x38, 0x00, 0x00, 0xee, 0x02,
+	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0x77, 0x11,
+	0x2a, 0x39, 0x76, 0x81, 0x00, 0x55, 0x77, 0x12,
+	0x2a, 0x18, 0x10, 0xe2, 0x00, 0x01, 0x80, 0xe1,
+	0x00, 0x01, 0x10, 0xe2, 0x00, 0x02, 0x80, 0xe1,
+	0x00, 0x02, 0x76, 0xe1, 0x00, 0x03, 0x00, 0x09,
+	0x48, 0x11, 0xf0, 0x00, 0x00, 0x04, 0x88, 0x12,
+	0xf4, 0x95, 0x77, 0x13, 0x2a, 0x86, 0xe9, 0x00,
+	0xe5, 0x98, 0xf3, 0x00, 0x00, 0x01, 0xf6, 0xb8,
+	0x48, 0x0b, 0x08, 0xf8, 0x2a, 0x3c, 0xf8, 0x43,
+	0x05, 0x0a, 0x76, 0x82, 0x00, 0xaa, 0xf0, 0x74,
+	0x02, 0x98, 0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11,
+	0x77, 0x11, 0x2a, 0x39, 0x76, 0x81, 0x00, 0x55,
+	0x77, 0x13, 0x2a, 0x18, 0x10, 0xe3, 0x00, 0x01,
+	0x80, 0xe1, 0x00, 0x01, 0x10, 0xe3, 0x00, 0x02,
+	0x80, 0xe1, 0x00, 0x02, 0x13, 0xe3, 0x00, 0x03,
+	0x81, 0xe1, 0x00, 0x03, 0x48, 0x11, 0x77, 0x11,
+	0x00, 0x00, 0xf8, 0x4d, 0x05, 0x44, 0xf0, 0x00,
+	0x00, 0x04, 0x88, 0x12, 0x48, 0x13, 0xf0, 0x00,
+	0x00, 0x04, 0x88, 0x13, 0xf4, 0x95, 0xf4, 0x95,
+	0xe5, 0x98, 0x6d, 0x91, 0xf6, 0xb8, 0x48, 0x11,
+	0x08, 0xf8, 0x2a, 0x3c, 0xf8, 0x43, 0x05, 0x3a,
+	0xf0, 0x20, 0x2a, 0x39, 0x49, 0x11, 0xf5, 0x00,
+	0x89, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x76, 0xe1,
+	0x00, 0x04, 0x00, 0xaa, 0xf0, 0x74, 0x02, 0x98,
+	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0x77, 0x11,
+	0x2a, 0x39, 0x76, 0x81, 0x00, 0x55, 0x77, 0x12,
+	0x2a, 0x18, 0x10, 0xe2, 0x00, 0x01, 0x80, 0xe1,
+	0x00, 0x01, 0x10, 0xe2, 0x00, 0x02, 0x80, 0xe1,
+	0x00, 0x02, 0x76, 0xe1, 0x00, 0x03, 0x00, 0x0c,
+	0x48, 0x11, 0xf0, 0x00, 0x00, 0x04, 0x88, 0x12,
+	0xf4, 0x95, 0x77, 0x13, 0x2a, 0x7a, 0xe9, 0x00,
+	0xe5, 0x98, 0xf3, 0x00, 0x00, 0x01, 0xf6, 0xb8,
+	0x48, 0x0b, 0x08, 0xf8, 0x2a, 0x3c, 0xf8, 0x43,
+	0x05, 0x6a, 0x76, 0x82, 0x00, 0xaa, 0xf0, 0x74,
+	0x02, 0x98, 0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11,
+	0x77, 0x11, 0x2a, 0x39, 0x76, 0x81, 0x00, 0x55,
+	0x77, 0x12, 0x2a, 0x18, 0x10, 0xe2, 0x00, 0x01,
+	0x80, 0xe1, 0x00, 0x01, 0x10, 0xe2, 0x00, 0x02,
+	0x80, 0xe1, 0x00, 0x02, 0x76, 0xe1, 0x00, 0x03,
+	0x00, 0x19, 0x48, 0x11, 0xf0, 0x00, 0x00, 0x04,
+	0x88, 0x12, 0xf4, 0x95, 0x77, 0x13, 0x2a, 0x5d,
+	0xe9, 0x00, 0xe5, 0x98, 0xf3, 0x00, 0x00, 0x01,
+	0xf6, 0xb8, 0x48, 0x0b, 0x08, 0xf8, 0x2a, 0x3c,
+	0xf8, 0x43, 0x05, 0x93, 0x76, 0x82, 0x00, 0xaa,
+	0xf0, 0x74, 0x02, 0x98, 0x8a, 0x11, 0xfc, 0x00,
+	0x4a, 0x11, 0x88, 0x11, 0x10, 0xf8, 0x2a, 0x38,
+	0xf8, 0x44, 0x05, 0xe3, 0x10, 0xf8, 0x2a, 0xa1,
+	0xf8, 0x44, 0x05, 0xba, 0x6c, 0xe1, 0xff, 0x56,
+	0x05, 0xe3, 0x72, 0x12, 0x2a, 0xa1, 0xf4, 0x95,
+	0x70, 0xe2, 0x2a, 0x18, 0x00, 0x11, 0x6b, 0xf8,
+	0x2a, 0xa1, 0x00, 0x01, 0xf0, 0x73, 0x05, 0xe3,
+	0x72, 0x12, 0x2a, 0xa1, 0xf4, 0x95, 0x70, 0xe2,
+	0x2a, 0x18, 0x00, 0x11, 0x10, 0xf8, 0x2a, 0xa1,
+	0xf0, 0x00, 0x00, 0x01, 0x88, 0x12, 0xf4, 0x95,
+	0xf4, 0x95, 0x6e, 0xe2, 0xff, 0xfc, 0x05, 0xd1,
+	0x73, 0x12, 0x2a, 0xa1, 0x48, 0x11, 0xf0, 0x00,
+	0x00, 0x05, 0x80, 0xf8, 0x2a, 0xa2, 0x10, 0xf8,
+	0x2a, 0xa1, 0x08, 0xf8, 0x2a, 0xa2, 0xf8, 0x44,
+	0x05, 0xe3, 0x6c, 0xe1, 0xff, 0xab, 0x05, 0xdd,
+	0x76, 0xf8, 0x2a, 0x38, 0x00, 0x01, 0x76, 0xf8,
+	0x2a, 0xa1, 0x00, 0x00, 0x76, 0xf8, 0x2a, 0xa2,
+	0x00, 0x00, 0x8a, 0x11, 0xfc, 0x00, 0xf4, 0x95,
+	0x4a, 0x08, 0x4a, 0x09, 0x4a, 0x0a, 0x4a, 0x0b,
+	0x4a, 0x0c, 0x4a, 0x0d, 0x4a, 0x10, 0x4a, 0x11,
+	0x4a, 0x12, 0x4a, 0x13, 0x4a, 0x14, 0x4a, 0x15,
+	0x4a, 0x16, 0x4a, 0x17, 0x4a, 0x17, 0x4a, 0x19,
+	0x4a, 0x0e, 0x4a, 0x06, 0x4a, 0x07, 0x4a, 0x1a,
+	0x4a, 0x1d, 0x4a, 0x1b, 0x4a, 0x1c, 0x68, 0xf8,
+	0x00, 0x07, 0x7d, 0x3f, 0x69, 0xf8, 0x00, 0x07,
+	0x40, 0x00, 0x68, 0xf8, 0x00, 0x1d, 0xff, 0xfc,
+	0x48, 0x18, 0x68, 0xf8, 0x00, 0x18, 0xff, 0xfe,
+	0xf4, 0x95, 0xf4, 0x95, 0x4a, 0x08, 0xee, 0xff,
+	0x10, 0xf8, 0x2a, 0x5b, 0xf9, 0x80, 0x18, 0x04,
+	0xf0, 0x74, 0x05, 0xa2, 0xee, 0x01, 0x8a, 0x18,
+	0xf4, 0x95, 0x8a, 0x1c, 0x8a, 0x1b, 0x8a, 0x1d,
+	0x8a, 0x1a, 0x8a, 0x07, 0x8a, 0x06, 0x8a, 0x0e,
+	0x8a, 0x19, 0x8a, 0x17, 0x8a, 0x17, 0x8a, 0x16,
+	0x8a, 0x15, 0x8a, 0x14, 0x8a, 0x13, 0x8a, 0x12,
+	0x8a, 0x11, 0x8a, 0x10, 0x8a, 0x0d, 0x8a, 0x0c,
+	0x8a, 0x0b, 0x8a, 0x0a, 0x8a, 0x09, 0x8a, 0x08,
+	0xf4, 0xeb, 0xee, 0xfd, 0x76, 0xf8, 0x2a, 0x38,
+	0x00, 0x00, 0x76, 0xf8, 0x2a, 0x5a, 0x00, 0x00,
+	0xe8, 0x01, 0x4e, 0x00, 0xfb, 0x80, 0x17, 0xd6,
+	0xf4, 0x95, 0xe8, 0x01, 0x80, 0xf8, 0x2a, 0x5b,
+	0x76, 0x00, 0x2a, 0x8f, 0xf9, 0x80, 0x16, 0xaa,
+	0x10, 0xf8, 0x2a, 0x5b, 0xf9, 0x80, 0x17, 0x5c,
+	0x10, 0xf8, 0x2a, 0x5b, 0xf9, 0x80, 0x17, 0x6f,
+	0xfb, 0x80, 0x16, 0x66, 0xf4, 0x95, 0xe8, 0x1a,
+	0xfb, 0x80, 0x16, 0x87, 0xf4, 0x95, 0xe8, 0x1a,
+	0xfb, 0x80, 0x16, 0x66, 0xf4, 0x95, 0xe8, 0x1b,
+	0xfb, 0x80, 0x16, 0x87, 0xf4, 0x95, 0xe8, 0x1b,
+	0xee, 0x03, 0xfc, 0x00, 0x4a, 0x11, 0xf4, 0x95,
+	0x13, 0x02, 0x88, 0x11, 0xe8, 0x00, 0xf8, 0x4d,
+	0x06, 0x6a, 0xf3, 0x10, 0x00, 0x01, 0x89, 0x1a,
+	0xf4, 0x95, 0xf0, 0x72, 0x06, 0x69, 0x1c, 0x91,
+	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0x88, 0x11,
+	0x12, 0x03, 0x11, 0x02, 0xf8, 0x45, 0x06, 0x79,
+	0xf0, 0x10, 0x00, 0x01, 0x88, 0x1a, 0xf4, 0x95,
+	0xf0, 0x72, 0x06, 0x78, 0x81, 0x91, 0x8a, 0x11,
+	0xfc, 0x00, 0x4a, 0x11, 0xf4, 0x95, 0x71, 0x02,
+	0x00, 0x11, 0x11, 0x03, 0x61, 0xf8, 0x00, 0x11,
+	0x00, 0x01, 0xf8, 0x30, 0x06, 0x91, 0xf6, 0xb8,
+	0x6f, 0xf8, 0x00, 0x11, 0x0c, 0x1f, 0x88, 0x11,
+	0xf3, 0xe8, 0xe8, 0xff, 0x18, 0x81, 0xf1, 0xa0,
+	0x81, 0x81, 0xf0, 0x73, 0x06, 0x9d, 0xf6, 0xb8,
+	0x6f, 0xf8, 0x00, 0x11, 0x0c, 0x1f, 0x88, 0x11,
+	0xf3, 0x30, 0x00, 0xff, 0xf0, 0x20, 0xff, 0x00,
+	0x18, 0x81, 0xf1, 0xa0, 0x81, 0x81, 0x8a, 0x11,
+	0xfc, 0x00, 0x4a, 0x11, 0xf4, 0x95, 0x11, 0x02,
+	0x61, 0xf8, 0x00, 0x0b, 0x00, 0x01, 0xf8, 0x20,
+	0x06, 0xb1, 0x49, 0x0b, 0xf6, 0x1f, 0x88, 0x11,
+	0xf4, 0x95, 0xf4, 0x95, 0x10, 0x81, 0xf2, 0x73,
+	0x06, 0xb8, 0xf0, 0x30, 0x00, 0xff, 0x49, 0x0b,
+	0xf6, 0x1f, 0x88, 0x11, 0xf4, 0x95, 0xf4, 0x95,
+	0x12, 0x81, 0xf4, 0x78, 0x8a, 0x11, 0xfc, 0x00,
+	0x4a, 0x11, 0xf4, 0x95, 0x71, 0x02, 0x00, 0x12,
+	0x13, 0x03, 0x88, 0x11, 0xe8, 0x00, 0xf8, 0x4d,
+	0x06, 0xcc, 0xf3, 0x10, 0x00, 0x01, 0x89, 0x1a,
+	0xf4, 0x95, 0xf0, 0x72, 0x06, 0xcb, 0x11, 0x92,
+	0xf2, 0xc0, 0x81, 0x91, 0x8a, 0x11, 0xfc, 0x00,
+	0x88, 0x12, 0x12, 0x02, 0x71, 0x01, 0x00, 0x13,
+	0xf8, 0x45, 0x06, 0xdb, 0xf0, 0x10, 0x00, 0x01,
+	0x88, 0x1a, 0xf4, 0x95, 0xf0, 0x72, 0x06, 0xda,
+	0xe5, 0x98, 0xfc, 0x00, 0x4a, 0x11, 0xee, 0xfe,
+	0x88, 0x11, 0x11, 0x04, 0x10, 0x06, 0x71, 0x05,
+	0x00, 0x12, 0x61, 0xf8, 0x00, 0x12, 0x00, 0x01,
+	0xf8, 0x20, 0x06, 0xea, 0xf0, 0x00, 0x00, 0x01,
+	0xf6, 0xb8, 0xf0, 0x00, 0x00, 0x01, 0x6f, 0xf8,
+	0x00, 0x12, 0x0f, 0x1f, 0x48, 0x08, 0x81, 0x00,
+	0xf4, 0x7f, 0x80, 0x01, 0xf2, 0x74, 0x06, 0xba,
+	0xf4, 0x95, 0x48, 0x11, 0xee, 0x02, 0x8a, 0x11,
+	0xfc, 0x00, 0x4a, 0x11, 0xee, 0xfe, 0x88, 0x12,
+	0x11, 0x04, 0x10, 0x06, 0x71, 0x05, 0x00, 0x13,
+	0x61, 0xf8, 0x00, 0x13, 0x00, 0x01, 0xf8, 0x20,
+	0x07, 0x09, 0xf0, 0x00, 0x00, 0x01, 0xf0, 0x00,
+	0x00, 0x01, 0x88, 0x11, 0xf6, 0xb8, 0x6f, 0xf8,
+	0x00, 0x13, 0x0f, 0x1f, 0x81, 0x00, 0x48, 0x11,
+	0xf4, 0x7f, 0x80, 0x01, 0xf2, 0x74, 0x06, 0xce,
+	0xf4, 0x95, 0x48, 0x12, 0x48, 0x11, 0xf0, 0x30,
+	0xff, 0xfe, 0xee, 0x02, 0x8a, 0x11, 0xfc, 0x00,
+	0x4a, 0x11, 0x4a, 0x16, 0x4a, 0x17, 0xee, 0xfc,
+	0xf4, 0x95, 0x80, 0x02, 0x71, 0x08, 0x00, 0x16,
+	0x10, 0x09, 0x71, 0x0b, 0x00, 0x17, 0x80, 0x03,
+	0x71, 0x0a, 0x00, 0x11, 0x48, 0x17, 0xf8, 0x45,
+	0x07, 0x3f, 0x70, 0x00, 0x00, 0x11, 0x10, 0x03,
+	0xf0, 0x74, 0x06, 0x9f, 0x80, 0x01, 0x70, 0x00,
+	0x00, 0x16, 0x10, 0x02, 0xf0, 0x74, 0x06, 0x7b,
+	0x6d, 0x91, 0x6d, 0x96, 0x6c, 0xef, 0xff, 0xff,
+	0x07, 0x2f, 0xee, 0x04, 0x8a, 0x17, 0x8a, 0x16,
+	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0xee, 0xfe,
+	0x10, 0xf8, 0x2a, 0xe8, 0x08, 0xf8, 0x2a, 0xe9,
+	0xf8, 0x45, 0x07, 0x64, 0x76, 0x00, 0x00, 0x01,
+	0x62, 0xf8, 0x2a, 0xe9, 0x00, 0x5e, 0xf2, 0x74,
+	0x12, 0x0b, 0xf0, 0x00, 0x30, 0x40, 0x72, 0x11,
+	0x2a, 0xe9, 0x77, 0x10, 0x00, 0x0f, 0xf5, 0xa9,
+	0xf8, 0x20, 0x07, 0x61, 0x6b, 0xf8, 0x2a, 0xe9,
+	0x00, 0x01, 0xf0, 0x73, 0x07, 0x64, 0x76, 0xf8,
+	0x2a, 0xe9, 0x00, 0x00, 0xee, 0x02, 0x8a, 0x11,
+	0xfc, 0x00, 0x4a, 0x11, 0x88, 0x11, 0xe8, 0x00,
+	0x75, 0xf8, 0x00, 0x08, 0x00, 0x08, 0xe8, 0x00,
+	0x75, 0xf8, 0x00, 0x08, 0x00, 0x09, 0xf6, 0xb8,
+	0xf4, 0x95, 0xf0, 0x20, 0xfc, 0x3f, 0x75, 0xf8,
+	0x00, 0x08, 0x00, 0x0d, 0xf0, 0x20, 0x0c, 0x30,
+	0x75, 0xf8, 0x00, 0x08, 0x00, 0x0c, 0x76, 0xf8,
+	0x2a, 0xe8, 0x00, 0x00, 0x76, 0xf8, 0x2a, 0xe9,
+	0x00, 0x00, 0x6c, 0x81, 0x07, 0x92, 0x76, 0xf8,
+	0x2a, 0xea, 0x00, 0x00, 0xfb, 0x80, 0x16, 0x76,
+	0xf4, 0x95, 0xe8, 0x10, 0xe8, 0x00, 0x75, 0xf8,
+	0x00, 0x08, 0x00, 0x00, 0xf0, 0x73, 0x07, 0xa8,
+	0x76, 0xf8, 0x2a, 0xea, 0x00, 0x01, 0xfb, 0x80,
+	0x16, 0x66, 0xf4, 0x95, 0xe8, 0x10, 0xfb, 0x80,
+	0x16, 0x87, 0xf4, 0x95, 0xe8, 0x10, 0xe8, 0x00,
+	0x75, 0xf8, 0x00, 0x08, 0x00, 0x00, 0xf6, 0xb8,
+	0xf4, 0x95, 0xf0, 0x20, 0xff, 0xff, 0x75, 0xf8,
+	0x00, 0x08, 0x00, 0x00, 0x8a, 0x11, 0xfc, 0x00,
+	0xf4, 0x95, 0x4a, 0x08, 0x4a, 0x09, 0x4a, 0x0a,
+	0x4a, 0x06, 0x4a, 0x07, 0x4a, 0x1d, 0x68, 0xf8,
+	0x00, 0x07, 0x7d, 0x3f, 0x69, 0xf8, 0x00, 0x07,
+	0x40, 0x00, 0x68, 0xf8, 0x00, 0x1d, 0xff, 0xfc,
+	0x10, 0xf8, 0x2a, 0xea, 0xf8, 0x45, 0x07, 0xe1,
+	0x10, 0xf8, 0x2a, 0xe8, 0xf0, 0x00, 0x00, 0x01,
+	0xf0, 0x30, 0x00, 0x0f, 0x80, 0xf8, 0x2a, 0xe8,
+	0x10, 0xf8, 0x2a, 0xe8, 0xf8, 0x44, 0x07, 0xd6,
+	0xf6, 0xb8, 0xf4, 0x95, 0xf0, 0x20, 0xfc, 0x3f,
+	0x75, 0xf8, 0x00, 0x08, 0x00, 0x0d, 0xf0, 0x20,
+	0x0c, 0x30, 0x75, 0xf8, 0x00, 0x08, 0x00, 0x0c,
+	0xe8, 0x00, 0x75, 0xf8, 0x00, 0x08, 0x00, 0x00,
+	0xf6, 0xb8, 0xf4, 0x95, 0xf0, 0x20, 0xff, 0xff,
+	0x75, 0xf8, 0x00, 0x08, 0x00, 0x00, 0x8a, 0x1d,
+	0x8a, 0x07, 0x8a, 0x06, 0x8a, 0x0a, 0x8a, 0x09,
+	0x8a, 0x08, 0xf4, 0xeb, 0xee, 0xff, 0xf2, 0x74,
+	0x07, 0x67, 0xf4, 0x95, 0xe8, 0x01, 0xee, 0x01,
+	0xfc, 0x00, 0x4a, 0x07, 0x4a, 0x1d, 0x68, 0xf8,
+	0x00, 0x07, 0x7d, 0x3f, 0x69, 0xf8, 0x00, 0x07,
+	0x40, 0x00, 0x68, 0xf8, 0x00, 0x1d, 0xff, 0xfc,
+	0x8a, 0x1d, 0x8a, 0x07, 0xf4, 0xeb, 0x4a, 0x11,
+	0x77, 0x11, 0x00, 0x28, 0x76, 0x81, 0x24, 0x00,
+	0xe8, 0x00, 0x75, 0xf8, 0x00, 0x08, 0x00, 0x01,
+	0xf2, 0x74, 0x07, 0x67, 0xf4, 0x95, 0xe8, 0x00,
+	0x77, 0x11, 0x00, 0x1d, 0x68, 0x81, 0x00, 0x7f,
+	0xf6, 0xb8, 0xf4, 0x95, 0xf0, 0x20, 0xff, 0x80,
+	0x77, 0x11, 0x00, 0x1d, 0xf0, 0x30, 0x01, 0x00,
+	0x1a, 0x81, 0x80, 0x81, 0xf0, 0x74, 0x0a, 0x33,
+	0xf0, 0x74, 0x11, 0xac, 0xf9, 0x80, 0x13, 0x25,
+	0xf9, 0x80, 0x16, 0x53, 0xf9, 0x80, 0x17, 0x82,
+	0xf0, 0x74, 0x06, 0x2f, 0xf9, 0x80, 0x14, 0xb2,
+	0xf9, 0x80, 0x19, 0x10, 0xf0, 0x74, 0x0d, 0xe3,
+	0xf0, 0x74, 0x07, 0xe8, 0xf0, 0x74, 0x02, 0x36,
+	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0x60, 0xf8,
+	0x27, 0x7b, 0xff, 0xff, 0xf8, 0x30, 0x08, 0x39,
+	0x71, 0xf8, 0x27, 0x7b, 0x27, 0x79, 0x60, 0xf8,
+	0x27, 0x79, 0xff, 0xff, 0xf8, 0x30, 0x08, 0xb2,
+	0x10, 0xf8, 0x29, 0x86, 0x08, 0xf8, 0x27, 0x79,
+	0xf0, 0x30, 0x7f, 0xff, 0x88, 0x11, 0xf4, 0x95,
+	0x77, 0x10, 0x40, 0x00, 0xf6, 0xa9, 0xf8, 0x30,
+	0x08, 0x58, 0x10, 0xf8, 0x27, 0x79, 0x08, 0xf8,
+	0x27, 0x7a, 0xf0, 0x30, 0x7f, 0xff, 0x88, 0x11,
+	0xf4, 0x95, 0x77, 0x10, 0x40, 0x00, 0xf6, 0xa9,
+	0xf8, 0x20, 0x08, 0x63, 0x76, 0xf8, 0x27, 0x79,
+	0xff, 0xff, 0x76, 0xf8, 0x27, 0x7b, 0xff, 0xff,
+	0xf7, 0xb8, 0xf2, 0x73, 0x08, 0xd9, 0xf0, 0x20,
+	0xff, 0xff, 0xf6, 0xb8, 0x56, 0xf8, 0x27, 0x74,
+	0xf0, 0xf9, 0x88, 0x11, 0x56, 0xf8, 0x27, 0x72,
+	0xf0, 0xf9, 0x88, 0x12, 0xf4, 0x95, 0xf4, 0x95,
+	0xe7, 0x20, 0xf4, 0xa9, 0xf8, 0x30, 0x08, 0x8f,
+	0xf1, 0x20, 0x27, 0x7c, 0x48, 0x11, 0xf6, 0x00,
+	0x88, 0x13, 0xf4, 0x95, 0xf4, 0x95, 0x10, 0x83,
+	0x08, 0xf8, 0x27, 0x79, 0xf0, 0x30, 0x7f, 0xff,
+	0x88, 0x13, 0xf4, 0x95, 0x77, 0x10, 0x40, 0x00,
+	0xf5, 0xab, 0xf8, 0x30, 0x08, 0x8f, 0x6d, 0x91,
+	0x48, 0x11, 0xf0, 0x30, 0x01, 0xff, 0x88, 0x11,
+	0xf4, 0x95, 0xe7, 0x20, 0xf7, 0xa9, 0xf8, 0x30,
+	0x08, 0x74, 0x6d, 0x89, 0x48, 0x11, 0xf0, 0x30,
+	0x01, 0xff, 0xf0, 0xe7, 0xf4, 0x95, 0x48, 0x08,
+	0x4e, 0xf8, 0x27, 0x74, 0x48, 0x08, 0xf1, 0xf9,
+	0x89, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x71, 0xe1,
+	0x27, 0x7c, 0x27, 0x7a, 0x60, 0xf8, 0x27, 0x7b,
+	0xff, 0xff, 0xf8, 0x30, 0x08, 0xab, 0x48, 0x08,
+	0x4e, 0xf8, 0x27, 0x72, 0x76, 0xf8, 0x27, 0x7b,
+	0xff, 0xff, 0x76, 0xf8, 0x27, 0x79, 0xff, 0xff,
+	0xf2, 0x73, 0x08, 0xd9, 0xf4, 0x95, 0xe8, 0x00,
+	0x44, 0xf8, 0x27, 0x73, 0x40, 0xf8, 0x27, 0x75,
+	0x82, 0xf8, 0x00, 0x11, 0xf4, 0x95, 0x77, 0x10,
+	0x80, 0x00, 0xf6, 0xa9, 0xf8, 0x20, 0x08, 0xd8,
+	0xf6, 0xb8, 0x10, 0xf8, 0x27, 0x73, 0xf0, 0x00,
+	0x80, 0x00, 0x48, 0x08, 0x4e, 0xf8, 0x27, 0x74,
+	0x48, 0x08, 0xf0, 0xf9, 0x88, 0x11, 0xf4, 0x95,
+	0xf4, 0x95, 0x71, 0xe1, 0x27, 0x7c, 0x27, 0x7a,
+	0xf7, 0xb8, 0x57, 0xf8, 0x27, 0x74, 0xf0, 0x62,
+	0xff, 0xff, 0xf0, 0x40, 0xff, 0x80, 0xf2, 0x80,
+	0x4e, 0xf8, 0x27, 0x74, 0xe8, 0x00, 0x8a, 0x11,
+	0xfc, 0x00, 0x4a, 0x11, 0x4a, 0x16, 0xee, 0xfb,
+	0x11, 0xf8, 0x27, 0x71, 0x09, 0xf8, 0x27, 0x73,
+	0x89, 0x11, 0x88, 0x10, 0xf4, 0x95, 0xf4, 0x95,
+	0xf6, 0xa9, 0xf8, 0x20, 0x08, 0xed, 0xf2, 0x73,
+	0x09, 0x0e, 0xf4, 0x95, 0xe8, 0x00, 0xf6, 0x20,
+	0x76, 0x00, 0x00, 0x41, 0xf0, 0x74, 0x12, 0xee,
+	0x88, 0x16, 0xf4, 0x95, 0xf7, 0xb8, 0x6d, 0x96,
+	0x10, 0xf8, 0x00, 0x16, 0xf8, 0x47, 0x09, 0x0a,
+	0xe7, 0x61, 0x76, 0x00, 0x00, 0x00, 0x76, 0x01,
+	0x00, 0x80, 0x76, 0x02, 0x00, 0xff, 0x76, 0x03,
+	0x00, 0x00, 0xf2, 0x74, 0x0c, 0xb9, 0xf4, 0x95,
+	0xe8, 0x00, 0x6c, 0xe9, 0xff, 0xff, 0x08, 0xfb,
+	0x73, 0x16, 0x00, 0x0e, 0xf0, 0x66, 0x00, 0x41,
+	0xee, 0x05, 0x8a, 0x16, 0x8a, 0x11, 0xfc, 0x00,
+	0x4a, 0x11, 0xf4, 0x95, 0x71, 0x02, 0x00, 0x13,
+	0xf6, 0xb8, 0x77, 0x11, 0x7f, 0xff, 0x57, 0xf8,
+	0x27, 0x72, 0x48, 0x11, 0xf2, 0x80, 0xf0, 0x00,
+	0x80, 0x00, 0x88, 0x11, 0xf6, 0x40, 0xf0, 0xe0,
+	0xf1, 0xf1, 0xe8, 0x01, 0xf2, 0x80, 0x80, 0xf8,
+	0x27, 0x78, 0x77, 0x12, 0x80, 0x00, 0x57, 0xf8,
+	0x27, 0x72, 0x48, 0x12, 0xf2, 0x80, 0x88, 0x12,
+	0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x82, 0x09, 0x38,
+	0xe8, 0x00, 0x75, 0xf8, 0x00, 0x08, 0x00, 0x01,
+	0xf0, 0x73, 0x09, 0x3d, 0xf0, 0x20, 0x80, 0x01,
+	0x75, 0xf8, 0x00, 0x08, 0x00, 0x01, 0x70, 0x81,
+	0x00, 0x13, 0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11,
+	0xf0, 0x30, 0x7f, 0xff, 0x11, 0xf8, 0x29, 0x86,
+	0xf5, 0x20, 0xf3, 0x30, 0x7f, 0xff, 0x89, 0x11,
+	0xf4, 0x95, 0x77, 0x10, 0x40, 0x00, 0xf6, 0xa9,
+	0xf8, 0x20, 0x09, 0x54, 0xf2, 0x73, 0x09, 0x67,
+	0xf4, 0x95, 0xe8, 0x02, 0x6f, 0xf8, 0x27, 0x7a,
+	0x0d, 0x20, 0xf3, 0x30, 0x7f, 0xff, 0x89, 0x11,
+	0xf4, 0x95, 0x77, 0x10, 0x40, 0x00, 0xf6, 0xa9,
+	0xf8, 0x20, 0x09, 0x64, 0xf2, 0x73, 0x09, 0x67,
+	0xf4, 0x95, 0xe8, 0x01, 0x80, 0xf8, 0x27, 0x7b,
+	0xe8, 0x00, 0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11,
+	0x11, 0xf8, 0x29, 0x86, 0xf5, 0x20, 0xf3, 0x30,
+	0x7f, 0xff, 0x89, 0x11, 0xf4, 0x95, 0x77, 0x10,
+	0x40, 0x00, 0xf6, 0xa9, 0xf8, 0x20, 0x09, 0x7a,
+	0xf2, 0x73, 0x09, 0x8d, 0xf4, 0x95, 0xe8, 0x02,
+	0x6f, 0xf8, 0x27, 0x7a, 0x0d, 0x20, 0xf3, 0x30,
+	0x7f, 0xff, 0x89, 0x11, 0xf4, 0x95, 0x77, 0x10,
+	0x40, 0x00, 0xf6, 0xa9, 0xf8, 0x20, 0x09, 0x8a,
+	0xf2, 0x73, 0x09, 0x8d, 0xf4, 0x95, 0xe8, 0x01,
+	0x80, 0xf8, 0x27, 0x79, 0xe8, 0x00, 0x8a, 0x11,
+	0xfc, 0x00, 0x4a, 0x11, 0xf4, 0x95, 0x71, 0x02,
+	0x00, 0x12, 0x88, 0x11, 0xf6, 0xb8, 0x57, 0xf8,
+	0x27, 0x72, 0xf0, 0x20, 0x7f, 0xff, 0xf2, 0x80,
+	0xf0, 0x00, 0x80, 0x00, 0x80, 0x81, 0x57, 0xf8,
+	0x27, 0x72, 0xe8, 0x01, 0xf3, 0xf1, 0xf2, 0x80,
+	0x80, 0xf8, 0x27, 0x78, 0x77, 0x11, 0x80, 0x00,
+	0x48, 0x11, 0x57, 0xf8, 0x27, 0x72, 0xf2, 0x80,
+	0x88, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x81,
+	0x09, 0xb5, 0xe8, 0x00, 0x75, 0xf8, 0x00, 0x08,
+	0x00, 0x01, 0xf0, 0x73, 0x09, 0xba, 0xf0, 0x20,
+	0x80, 0x01, 0x75, 0xf8, 0x00, 0x08, 0x00, 0x01,
+	0x45, 0xf8, 0x27, 0x71, 0x43, 0xf8, 0x27, 0x73,
+	0x83, 0xf8, 0x00, 0x11, 0xf4, 0x95, 0xe7, 0x20,
+	0xf6, 0xa9, 0xf8, 0x30, 0x09, 0xc9, 0xf2, 0x73,
+	0x09, 0xe4, 0x77, 0x12, 0x00, 0x00, 0x57, 0xf8,
+	0x27, 0x72, 0xf0, 0x20, 0x7f, 0xff, 0xf2, 0x80,
+	0x49, 0x12, 0xf5, 0x00, 0xf3, 0x00, 0x80, 0x00,
+	0x61, 0xf8, 0x00, 0x0b, 0x80, 0x00, 0xf8, 0x30,
+	0x09, 0xdc, 0xf1, 0x20, 0x80, 0x00, 0xf5, 0x20,
+	0x89, 0x12, 0xf4, 0x95, 0x48, 0x12, 0x6f, 0xf8,
+	0x27, 0x73, 0x0d, 0x00, 0xf4, 0x95, 0x49, 0x0b,
+	0x4f, 0xf8, 0x27, 0x72, 0x8a, 0x11, 0xfe, 0x00,
+	0x48, 0x12, 0xf4, 0x95, 0x4a, 0x11, 0x4a, 0x16,
+	0x4a, 0x17, 0xee, 0xfc, 0xf4, 0x95, 0x71, 0x08,
+	0x00, 0x16, 0x88, 0x17, 0xf0, 0x74, 0x08, 0x30,
+	0x48, 0x18, 0x70, 0x00, 0x00, 0x16, 0xf2, 0x74,
+	0x09, 0x8f, 0xf0, 0x00, 0x00, 0x02, 0x88, 0x11,
+	0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x81, 0x0a, 0x0a,
+	0xf2, 0x74, 0x08, 0xdb, 0xf4, 0x95, 0x48, 0x16,
+	0x48, 0x18, 0x70, 0x00, 0x00, 0x16, 0xf2, 0x74,
+	0x09, 0x8f, 0xf0, 0x00, 0x00, 0x02, 0x88, 0x11,
+	0x10, 0x02, 0x70, 0x01, 0x00, 0x11, 0x80, 0x00,
+	0xf2, 0x74, 0x06, 0xce, 0xf4, 0x95, 0x48, 0x17,
+	0x49, 0x11, 0x48, 0x17, 0xf6, 0x00, 0x88, 0x17,
+	0xe7, 0x60, 0xf5, 0xa9, 0xf8, 0x20, 0x0a, 0x2d,
+	0x48, 0x16, 0xf6, 0x20, 0x88, 0x11, 0x48, 0x18,
+	0x70, 0x00, 0x00, 0x11, 0xf2, 0x74, 0x09, 0x8f,
+	0xf0, 0x00, 0x00, 0x02, 0x88, 0x11, 0x70, 0x01,
+	0x00, 0x11, 0x10, 0x02, 0x80, 0x00, 0xf2, 0x74,
+	0x06, 0xce, 0xf4, 0x95, 0x48, 0x17, 0xee, 0x04,
+	0x48, 0x16, 0x8a, 0x17, 0x8a, 0x16, 0x8a, 0x11,
+	0xfc, 0x00, 0xee, 0xfd, 0xe8, 0x00, 0x4e, 0xf8,
+	0x27, 0x70, 0xe8, 0x00, 0x4e, 0xf8, 0x27, 0x72,
+	0xe8, 0x00, 0x4e, 0xf8, 0x27, 0x74, 0xe8, 0x00,
+	0x4e, 0xf8, 0x27, 0x76, 0x76, 0xf8, 0x27, 0x79,
+	0xff, 0xff, 0x76, 0xf8, 0x27, 0x7a, 0x00, 0x00,
+	0x76, 0xf8, 0x27, 0x7b, 0xff, 0xff, 0x76, 0xf8,
+	0x27, 0x78, 0x00, 0x00, 0xe8, 0x00, 0x75, 0xf8,
+	0x00, 0x08, 0x00, 0x01, 0x76, 0x00, 0x00, 0x00,
+	0x76, 0x01, 0x02, 0x00, 0xf2, 0x74, 0x12, 0xdc,
+	0xf0, 0x20, 0x27, 0x7c, 0xee, 0x03, 0xfc, 0x00,
+	0x4a, 0x11, 0xee, 0xfc, 0xf4, 0x95, 0x4e, 0x00,
+	0x77, 0x12, 0x7f, 0xff, 0xf6, 0xb8, 0x49, 0x12,
+	0xf1, 0x80, 0xf3, 0x00, 0x80, 0x00, 0x89, 0x12,
+	0xf0, 0xe0, 0xf1, 0xf1, 0x4f, 0x02, 0xe9, 0x01,
+	0xf4, 0x95, 0x48, 0x0b, 0xf5, 0x40, 0x56, 0x02,
+	0xf1, 0x80, 0x81, 0xf8, 0x27, 0x78, 0x77, 0x11,
+	0x80, 0x00, 0x56, 0x00, 0x49, 0x11, 0xf1, 0x80,
+	0x89, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x81,
+	0x0a, 0x81, 0xe8, 0x00, 0x75, 0xf8, 0x00, 0x08,
+	0x00, 0x01, 0xf0, 0x73, 0x0a, 0x86, 0xf0, 0x20,
+	0x80, 0x01, 0x75, 0xf8, 0x00, 0x08, 0x00, 0x01,
+	0x10, 0x82, 0xee, 0x04, 0x8a, 0x11, 0xfc, 0x00,
+	0x4a, 0x11, 0xee, 0xfe, 0xf4, 0x95, 0x4e, 0x00,
+	0x77, 0x11, 0x7f, 0xff, 0xf6, 0xb8, 0x49, 0x11,
+	0xf1, 0x80, 0xf3, 0x00, 0x80, 0x00, 0x89, 0x11,
+	0xf0, 0xe0, 0xf1, 0xf1, 0xe8, 0x01, 0xf2, 0x80,
+	0x80, 0xf8, 0x27, 0x78, 0x56, 0x00, 0xf1, 0x20,
+	0x80, 0x00, 0xf1, 0x80, 0xf4, 0x95, 0x49, 0x0b,
+	0xf8, 0x4d, 0x0a, 0xab, 0xf0, 0x20, 0x80, 0x01,
+	0x75, 0xf8, 0x00, 0x08, 0x00, 0x01, 0xf0, 0x73,
+	0x0a, 0xaf, 0xe8, 0x00, 0x75, 0xf8, 0x00, 0x08,
+	0x00, 0x01, 0xee, 0x02, 0x48, 0x11, 0x8a, 0x11,
+	0xfc, 0x00, 0x4a, 0x11, 0x88, 0x12, 0x13, 0x02,
+	0x77, 0x11, 0x00, 0x00, 0xf8, 0x4d, 0x0a, 0xcb,
+	0xf3, 0x10, 0x00, 0x01, 0x89, 0x1a, 0xf4, 0x95,
+	0xf0, 0x72, 0x0a, 0xca, 0x48, 0x11, 0x1c, 0xf8,
+	0x29, 0x7e, 0x88, 0x11, 0x11, 0xf8, 0x29, 0x7e,
+	0xf2, 0x00, 0x00, 0x01, 0x80, 0xf8, 0x29, 0x7e,
+	0x81, 0x92, 0x48, 0x11, 0x8a, 0x11, 0xfc, 0x00,
+	0x4a, 0x11, 0xf4, 0x95, 0x71, 0x02, 0x00, 0x11,
+	0x88, 0x12, 0xf6, 0xb8, 0xf0, 0x20, 0x7f, 0xff,
+	0x57, 0xf8, 0x27, 0x70, 0xf2, 0x80, 0xf0, 0x00,
+	0x80, 0x00, 0x80, 0x82, 0x57, 0xf8, 0x27, 0x70,
+	0xe8, 0x01, 0xf3, 0xf1, 0xf2, 0x80, 0x80, 0xf8,
+	0x27, 0x78, 0x77, 0x12, 0x80, 0x00, 0x48, 0x12,
+	0x57, 0xf8, 0x27, 0x70, 0xf2, 0x80, 0x88, 0x12,
+	0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x82, 0x0a, 0xf4,
+	0xe8, 0x00, 0x75, 0xf8, 0x00, 0x08, 0x00, 0x01,
+	0xf0, 0x73, 0x0a, 0xf9, 0xf0, 0x20, 0x80, 0x01,
+	0x75, 0xf8, 0x00, 0x08, 0x00, 0x01, 0x45, 0xf8,
+	0x27, 0x75, 0xe7, 0x10, 0x43, 0xf8, 0x27, 0x71,
+	0x83, 0xf8, 0x00, 0x12, 0x6d, 0xe8, 0x00, 0x04,
+	0x6d, 0x8a, 0xf6, 0xaa, 0xf8, 0x30, 0x0b, 0x0a,
+	0xf2, 0x73, 0x0b, 0x25, 0x77, 0x11, 0x00, 0x00,
+	0x57, 0xf8, 0x27, 0x70, 0xf0, 0x20, 0x7f, 0xff,
+	0xf2, 0x80, 0x49, 0x11, 0xf5, 0x00, 0xf3, 0x00,
+	0x80, 0x00, 0x61, 0xf8, 0x00, 0x0b, 0x80, 0x00,
+	0xf8, 0x30, 0x0b, 0x1d, 0xf1, 0x20, 0x80, 0x00,
+	0xf5, 0x20, 0x89, 0x11, 0xf4, 0x95, 0x48, 0x11,
+	0x6f, 0xf8, 0x27, 0x71, 0x0d, 0x00, 0xf4, 0x95,
+	0x49, 0x0b, 0x4f, 0xf8, 0x27, 0x70, 0x48, 0x11,
+	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0x4a, 0x16,
+	0x4a, 0x17, 0xee, 0xf0, 0x88, 0x17, 0x10, 0x17,
+	0x80, 0x05, 0x10, 0x16, 0x80, 0x06, 0x10, 0x15,
+	0x80, 0x07, 0x71, 0x14, 0x00, 0x11, 0x10, 0x05,
+	0xf0, 0x30, 0x00, 0x01, 0x88, 0x10, 0x10, 0x06,
+	0xf0, 0x30, 0x00, 0x01, 0x80, 0x08, 0x49, 0x11,
+	0x10, 0x05, 0xf6, 0x01, 0x80, 0x09, 0x10, 0x06,
+	0x61, 0xf8, 0x00, 0x08, 0x00, 0x01, 0xf8, 0x20,
+	0x0b, 0x4b, 0x10, 0x09, 0xf0, 0x00, 0x00, 0x01,
+	0x80, 0x09, 0x71, 0x08, 0x00, 0x12, 0xf4, 0xaa,
+	0xf8, 0x30, 0x0b, 0x54, 0x10, 0x09, 0xf0, 0x00,
+	0x00, 0x01, 0x80, 0x09, 0x12, 0x09, 0x49, 0x11,
+	0xf4, 0x7f, 0x80, 0x09, 0xf6, 0x20, 0x80, 0x0a,
+	0x56, 0xf8, 0x27, 0x70, 0x4e, 0x0c, 0x10, 0x09,
+	0x80, 0x00, 0x48, 0x18, 0xf2, 0x74, 0x0a, 0xce,
+	0xf0, 0x00, 0x00, 0x04, 0x88, 0x16, 0xf4, 0x95,
+	0xf4, 0x95, 0x6c, 0x86, 0x0b, 0x6d, 0xf2, 0x73,
+	0x0c, 0x59, 0xf4, 0x95, 0xe8, 0x00, 0xf6, 0xb8,
+	0xf4, 0x95, 0x56, 0x0c, 0xf0, 0xf9, 0x88, 0x12,
+	0xf4, 0x95, 0xf4, 0x95, 0x70, 0xe2, 0x27, 0x7c,
+	0x29, 0x86, 0xe8, 0x00, 0x80, 0x0e, 0x48, 0x11,
+	0xf8, 0x45, 0x0b, 0xcc, 0x77, 0x10, 0x00, 0x01,
+	0xf4, 0xa9, 0xf8, 0x30, 0x0b, 0x89, 0x6c, 0xe1,
+	0xff, 0xfd, 0x0b, 0x8b, 0x10, 0xe7, 0x00, 0x02,
+	0x80, 0x0e, 0xf0, 0x73, 0x0b, 0x8b, 0x10, 0x87,
+	0x80, 0x0e, 0xe7, 0x10, 0xf5, 0xae, 0xf8, 0x20,
+	0x0b, 0xb2, 0x70, 0x00, 0x00, 0x17, 0x70, 0x01,
+	0x00, 0x16, 0x10, 0x04, 0xf0, 0x74, 0x06, 0xce,
+	0x48, 0x17, 0x49, 0x16, 0xf6, 0x00, 0x88, 0x17,
+	0x48, 0x11, 0xf6, 0x20, 0x88, 0x11, 0x10, 0x09,
+	0xf6, 0x20, 0x80, 0x00, 0x48, 0x18, 0xf2, 0x74,
+	0x0a, 0xce, 0xf0, 0x00, 0x00, 0x04, 0x88, 0x16,
+	0x10, 0x04, 0x70, 0x00, 0x00, 0x17, 0x70, 0x01,
+	0x00, 0x11, 0xf0, 0x74, 0x06, 0xce, 0x48, 0x11,
+	0x00, 0x04, 0x80, 0x04, 0xf0, 0x73, 0x0b, 0xbc,
+	0x70, 0x00, 0x00, 0x17, 0x70, 0x01, 0x00, 0x11,
+	0x10, 0x04, 0xf0, 0x74, 0x06, 0xce, 0x48, 0x11,
+	0x00, 0x04, 0x80, 0x04, 0x49, 0x11, 0x48, 0x16,
+	0xf6, 0x20, 0x88, 0x16, 0xf4, 0x95, 0xf4, 0x95,
+	0x6c, 0x86, 0x0b, 0xcc, 0x10, 0x0a, 0x80, 0x00,
+	0x48, 0x18, 0xf2, 0x74, 0x0a, 0xce, 0xf0, 0x00,
+	0x00, 0x04, 0x88, 0x16, 0x12, 0x0a, 0xf8, 0x45,
+	0x0c, 0x33, 0x71, 0x0a, 0x00, 0x10, 0xf4, 0xae,
+	0xf8, 0x30, 0x0c, 0x1c, 0x48, 0x16, 0xf0, 0xe1,
+	0x88, 0x11, 0x12, 0x08, 0xf8, 0x45, 0x0b, 0xdb,
+	0x6d, 0x89, 0x12, 0x07, 0xf8, 0x45, 0x0b, 0xe9,
+	0x10, 0x07, 0x80, 0x00, 0x70, 0x02, 0x00, 0x11,
+	0x10, 0x06, 0x80, 0x01, 0x10, 0x04, 0xf0, 0x74,
+	0x06, 0xdc, 0xf0, 0x73, 0x0b, 0xef, 0x48, 0x11,
+	0x6f, 0x00, 0x0c, 0x9f, 0x10, 0x04, 0xf0, 0x74,
+	0x0a, 0xb3, 0x11, 0x0e, 0xf1, 0xc0, 0x81, 0x0e,
+	0x10, 0x06, 0x49, 0x11, 0xf6, 0x00, 0x80, 0x06,
+	0x10, 0x05, 0xf6, 0x20, 0x88, 0x11, 0xf0, 0x00,
+	0x00, 0x01, 0x48, 0x08, 0x6f, 0x00, 0x0c, 0x9f,
+	0x48, 0x18, 0xf2, 0x74, 0x0a, 0xce, 0xf0, 0x00,
+	0x00, 0x04, 0x12, 0x07, 0xf8, 0x45, 0x0c, 0x11,
+	0x10, 0x07, 0x80, 0x00, 0x70, 0x02, 0x00, 0x11,
+	0x10, 0x06, 0x80, 0x01, 0x10, 0x04, 0xf0, 0x74,
+	0x06, 0xdc, 0xf0, 0x73, 0x0c, 0x17, 0x48, 0x11,
+	0x6f, 0x00, 0x0c, 0x9f, 0x10, 0x04, 0xf0, 0x74,
+	0x0a, 0xb3, 0x11, 0x0e, 0xf1, 0xc0, 0x81, 0x0e,
+	0xf0, 0x73, 0x0c, 0x33, 0x12, 0x07, 0xf8, 0x45,
+	0x0c, 0x2a, 0x10, 0x07, 0x80, 0x00, 0x10, 0x06,
+	0x80, 0x01, 0x10, 0x05, 0x80, 0x02, 0x10, 0x04,
+	0xf0, 0x74, 0x06, 0xdc, 0xf0, 0x73, 0x0c, 0x30,
+	0x12, 0x05, 0x6f, 0x00, 0x0c, 0x9f, 0x10, 0x04,
+	0xf0, 0x74, 0x0a, 0xb3, 0x11, 0x0e, 0xf1, 0xc0,
+	0x81, 0x0e, 0x76, 0x00, 0x00, 0x01, 0x48, 0x18,
+	0xf2, 0x74, 0x0a, 0xce, 0xf0, 0x00, 0x00, 0x04,
+	0x71, 0x04, 0x00, 0x11, 0x70, 0x81, 0x29, 0x86,
+	0x10, 0x0e, 0x1c, 0xf8, 0x29, 0x86, 0x80, 0x0e,
+	0x76, 0x00, 0x00, 0x01, 0x48, 0x18, 0xf2, 0x74,
+	0x0a, 0xce, 0xf0, 0x00, 0x00, 0x04, 0x10, 0x0e,
+	0x71, 0x04, 0x00, 0x11, 0x80, 0x81, 0x10, 0xf8,
+	0x29, 0x86, 0xf0, 0x00, 0x00, 0x01, 0xf0, 0x30,
+	0x7f, 0xff, 0x80, 0xf8, 0x29, 0x86, 0x10, 0x09,
+	0xf0, 0x00, 0x00, 0x02, 0x80, 0x09, 0xee, 0x10,
+	0x8a, 0x17, 0x8a, 0x16, 0x8a, 0x11, 0xfc, 0x00,
+	0x10, 0xf8, 0x27, 0x75, 0x08, 0xf8, 0x27, 0x71,
+	0xf0, 0x10, 0x00, 0x01, 0x48, 0x08, 0xfc, 0x00,
+	0x4a, 0x11, 0x4a, 0x16, 0xee, 0xff, 0xf4, 0x95,
+	0x71, 0x04, 0x00, 0x16, 0xf0, 0x00, 0x00, 0x01,
+	0x48, 0x08, 0x4e, 0xf8, 0x29, 0x7c, 0x6d, 0xee,
+	0xff, 0xfd, 0x48, 0x16, 0xf8, 0x45, 0x0c, 0x99,
+	0x56, 0xf8, 0x29, 0x7c, 0xf0, 0x74, 0x0a, 0x5a,
+	0x88, 0x11, 0x10, 0xf8, 0x29, 0x7d, 0xf0, 0x00,
+	0x00, 0x01, 0x48, 0x08, 0x4e, 0xf8, 0x29, 0x7c,
+	0x10, 0xf8, 0x29, 0x82, 0xf0, 0x00, 0x00, 0x01,
+	0x88, 0x10, 0xf4, 0x95, 0xf4, 0x95, 0xf4, 0xa9,
+	0xfa, 0x30, 0x0c, 0x96, 0x80, 0xf8, 0x29, 0x82,
+	0x56, 0xf8, 0x29, 0x80, 0xf0, 0x00, 0x00, 0x01,
+	0x4e, 0xf8, 0x29, 0x80, 0x73, 0x11, 0x29, 0x82,
+	0x6c, 0xee, 0xff, 0xff, 0x0c, 0x76, 0xee, 0x01,
+	0x8a, 0x16, 0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11,
+	0x76, 0xf8, 0x29, 0x84, 0x00, 0x00, 0x76, 0xf8,
+	0x29, 0x85, 0x00, 0x01, 0xe8, 0x00, 0x4e, 0xf8,
+	0x2a, 0x0c, 0x76, 0xf8, 0x29, 0x86, 0x00, 0x00,
+	0x76, 0xf8, 0x29, 0x87, 0x00, 0x00, 0x77, 0x11,
+	0x29, 0x88, 0x76, 0x81, 0xaa, 0xaa, 0x76, 0xe1,
+	0x00, 0x01, 0xaa, 0xaa, 0x76, 0xe1, 0x00, 0x02,
+	0x00, 0x00, 0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11,
+	0xee, 0xfc, 0xf4, 0x95, 0x71, 0x06, 0x00, 0x14,
+	0x71, 0x07, 0x00, 0x13, 0x71, 0x08, 0x00, 0x12,
+	0x71, 0x09, 0x00, 0x15, 0x77, 0x10, 0x00, 0xff,
+	0xf4, 0xaa, 0xf8, 0x30, 0x0d, 0x44, 0x49, 0x13,
+	0x53, 0xf8, 0x2a, 0x0c, 0x4f, 0xf8, 0x2a, 0x0c,
+	0x73, 0x12, 0x00, 0x0e, 0xf1, 0x66, 0x00, 0x0d,
+	0x89, 0x11, 0xf4, 0x95, 0x77, 0x10, 0x00, 0x01,
+	0x71, 0xe1, 0x24, 0x00, 0x00, 0x11, 0xf4, 0xa9,
+	0xf8, 0x30, 0x0d, 0x17, 0x77, 0x10, 0x00, 0x02,
+	0xf4, 0xa9, 0xf8, 0x30, 0x0c, 0xec, 0x77, 0x11,
+	0x29, 0x8a, 0x76, 0x81, 0x00, 0x00, 0xe8, 0x00,
+	0x77, 0x14, 0x00, 0x00, 0x77, 0x13, 0x00, 0x00,
+	0xf0, 0x73, 0x0d, 0x48, 0x6c, 0x83, 0x0c, 0xfa,
+	0x77, 0x11, 0x29, 0x8a, 0x48, 0x12, 0xf0, 0xe8,
+	0xf0, 0x40, 0x80, 0x00, 0x80, 0x81, 0xe8, 0x00,
+	0x77, 0x14, 0x00, 0x00, 0xf0, 0x73, 0x0d, 0x48,
+	0x49, 0x13, 0xf3, 0x40, 0x80, 0x00, 0x81, 0xf8,
+	0x29, 0x8a, 0x61, 0xf8, 0x00, 0x15, 0x00, 0x01,
+	0xf8, 0x20, 0x0d, 0x07, 0x69, 0xf8, 0x29, 0x8a,
+	0x40, 0x00, 0x61, 0xf8, 0x00, 0x14, 0x00, 0x01,
+	0xf8, 0x20, 0x0d, 0x0f, 0x69, 0xf8, 0x29, 0x8a,
+	0x20, 0x00, 0x77, 0x11, 0x29, 0x8a, 0x49, 0x12,
+	0xf3, 0xe8, 0x1b, 0x81, 0x81, 0x81, 0xf0, 0x73,
+	0x0d, 0x48, 0x11, 0xf8, 0x29, 0x84, 0xf8, 0x4c,
+	0x0d, 0x37, 0x77, 0x11, 0x29, 0x88, 0x76, 0x81,
+	0xaa, 0xaa, 0x11, 0xf8, 0x29, 0x85, 0xf3, 0x10,
+	0x00, 0x01, 0xf3, 0x40, 0xaa, 0x00, 0x81, 0xe1,
+	0x00, 0x01, 0x76, 0x00, 0x00, 0x02, 0x80, 0x01,
+	0x70, 0x02, 0x00, 0x14, 0x70, 0x03, 0x00, 0x13,
+	0xf2, 0x74, 0x0b, 0x28, 0xf4, 0x95, 0x48, 0x11,
+	0x71, 0xf8, 0x29, 0x85, 0x29, 0x84, 0xf0, 0x73,
+	0x0d, 0x73, 0x76, 0x00, 0x00, 0x00, 0x80, 0x01,
+	0x76, 0x02, 0x00, 0x00, 0x70, 0x03, 0x00, 0x13,
+	0xf2, 0x74, 0x0b, 0x28, 0xf4, 0x95, 0xe8, 0x00,
+	0xf0, 0x73, 0x0d, 0x73, 0x77, 0x11, 0x29, 0x8a,
+	0x70, 0x81, 0x00, 0x13, 0x11, 0xf8, 0x29, 0x84,
+	0xf8, 0x4c, 0x0d, 0x68, 0x77, 0x11, 0x29, 0x88,
+	0x76, 0x81, 0xaa, 0xaa, 0x11, 0xf8, 0x29, 0x85,
+	0xf3, 0x10, 0x00, 0x01, 0xf3, 0x40, 0xaa, 0x00,
+	0x81, 0xe1, 0x00, 0x01, 0x76, 0x00, 0x00, 0x03,
+	0x80, 0x01, 0x70, 0x02, 0x00, 0x14, 0x70, 0x03,
+	0x00, 0x13, 0xf2, 0x74, 0x0b, 0x28, 0xf4, 0x95,
+	0x48, 0x11, 0x71, 0xf8, 0x29, 0x85, 0x29, 0x84,
+	0xf0, 0x73, 0x0d, 0x73, 0x76, 0x00, 0x00, 0x01,
+	0x80, 0x01, 0x70, 0x02, 0x00, 0x14, 0x70, 0x03,
+	0x00, 0x13, 0xf2, 0x74, 0x0b, 0x28, 0xf4, 0x95,
+	0x48, 0x11, 0x6b, 0xf8, 0x29, 0x84, 0xff, 0xff,
+	0xee, 0x04, 0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11,
+	0xf5, 0x40, 0xf4, 0x95, 0x48, 0x0b, 0xf4, 0x78,
+	0x88, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x6c, 0xe1,
+	0xff, 0xb9, 0x0d, 0x88, 0xf2, 0x73, 0x0d, 0xa5,
+	0xf4, 0x95, 0xe8, 0x60, 0xf2, 0x00, 0x00, 0x06,
+	0x61, 0xf8, 0x00, 0x11, 0x00, 0x20, 0xf8, 0x30,
+	0x0d, 0x98, 0x61, 0xf8, 0x00, 0x0b, 0x00, 0x01,
+	0xf8, 0x20, 0x0d, 0xa3, 0xf2, 0x00, 0x00, 0x07,
+	0xf0, 0x73, 0x0d, 0xa3, 0x61, 0xf8, 0x00, 0x0b,
+	0x00, 0x01, 0xf8, 0x20, 0x0d, 0xa1, 0xf2, 0x73,
+	0x0d, 0xa3, 0xf0, 0x00, 0x00, 0x01, 0xf0, 0x00,
+	0x00, 0x02, 0x48, 0x08, 0xf4, 0x7f, 0x8a, 0x11,
+	0xfc, 0x00, 0xee, 0xff, 0xf0, 0x74, 0x07, 0xfd,
+	0xf0, 0x74, 0x07, 0x44, 0xf0, 0x74, 0x0d, 0xb4,
+	0xf0, 0x74, 0x02, 0x05, 0xf0, 0x74, 0x04, 0x60,
+	0xf0, 0x73, 0x0d, 0xaa, 0xee, 0xfd, 0x10, 0xf8,
+	0x2a, 0xa3, 0xf8, 0x44, 0x0d, 0xcb, 0x10, 0xf8,
+	0x2a, 0xa4, 0xf8, 0x45, 0x0d, 0xd7, 0x76, 0x00,
+	0x02, 0x00, 0xf2, 0x74, 0x09, 0xe8, 0xf0, 0x20,
+	0x22, 0x00, 0x76, 0xf8, 0x2a, 0xa4, 0x00, 0x00,
+	0x76, 0xf8, 0x2a, 0xa7, 0x00, 0x00, 0xf0, 0x73,
+	0x0d, 0xd7, 0x76, 0x00, 0x02, 0x00, 0xf2, 0x74,
+	0x09, 0xe8, 0xf0, 0x20, 0x20, 0x00, 0x76, 0xf8,
+	0x2a, 0xa3, 0x00, 0x00, 0x76, 0xf8, 0x2a, 0xa7,
+	0x00, 0x01, 0xf0, 0x74, 0x0c, 0x5e, 0xf0, 0xe0,
+	0xf0, 0x10, 0x3a, 0x98, 0xf8, 0x47, 0x0d, 0xe1,
+	0x76, 0xf8, 0x27, 0x6e, 0x00, 0x00, 0xee, 0x03,
+	0xfc, 0x00, 0x4a, 0x11, 0xee, 0xfe, 0x77, 0x11,
+	0x20, 0x00, 0x76, 0x00, 0xaa, 0xaa, 0x76, 0x01,
+	0x02, 0x00, 0xf2, 0x74, 0x06, 0x6c, 0xf4, 0x95,
+	0x48, 0x11, 0x76, 0x00, 0x55, 0x55, 0x76, 0x01,
+	0x02, 0x00, 0x48, 0x11, 0xf2, 0x74, 0x06, 0x6c,
+	0xf0, 0x00, 0x02, 0x00, 0x76, 0xf8, 0x2a, 0xa3,
+	0x00, 0x00, 0x76, 0xf8, 0x2a, 0xa4, 0x00, 0x00,
+	0xe8, 0x00, 0x4e, 0x00, 0xfb, 0x80, 0x15, 0x3e,
+	0xf4, 0x95, 0xe8, 0x04, 0x80, 0xf8, 0x2a, 0xa5,
+	0x76, 0x00, 0x2a, 0xa8, 0xf9, 0x80, 0x14, 0x87,
+	0x76, 0x00, 0x2a, 0xad, 0xfb, 0x80, 0x13, 0x62,
+	0xf4, 0x95, 0xe8, 0x02, 0x10, 0xf8, 0x2a, 0xa5,
+	0xf9, 0x80, 0x14, 0x63, 0xfb, 0x80, 0x16, 0x66,
+	0xf4, 0x95, 0xe8, 0x1c, 0xfb, 0x80, 0x16, 0x87,
+	0xf4, 0x95, 0xe8, 0x1c, 0xe8, 0x01, 0x4e, 0x00,
+	0xfb, 0x80, 0x17, 0xd6, 0xf4, 0x95, 0xe8, 0x00,
+	0x80, 0xf8, 0x2a, 0xa6, 0x76, 0x00, 0x2a, 0xb7,
+	0xf9, 0x80, 0x16, 0xaa, 0x10, 0xf8, 0x2a, 0xa6,
+	0xf9, 0x80, 0x17, 0x5c, 0x10, 0xf8, 0x2a, 0xa6,
+	0xf9, 0x80, 0x17, 0x6f, 0xee, 0x02, 0x8a, 0x11,
+	0xfc, 0x00, 0xf4, 0x95, 0x4a, 0x08, 0x4a, 0x09,
+	0x4a, 0x0a, 0x4a, 0x07, 0x4a, 0x1d, 0x68, 0xf8,
+	0x00, 0x07, 0x7d, 0x3f, 0x69, 0xf8, 0x00, 0x07,
+	0x40, 0x00, 0x68, 0xf8, 0x00, 0x1d, 0xff, 0xfc,
+	0x10, 0xf8, 0x2a, 0xa7, 0xf8, 0x44, 0x0e, 0x4b,
+	0x76, 0xf8, 0x2a, 0xa3, 0x00, 0x01, 0xf0, 0x73,
+	0x0e, 0x4e, 0x76, 0xf8, 0x2a, 0xa4, 0x00, 0x01,
+	0x8a, 0x1d, 0x8a, 0x07, 0x8a, 0x0a, 0x8a, 0x09,
+	0x8a, 0x08, 0xf4, 0xeb, 0x4a, 0x11, 0x4a, 0x16,
+	0x4a, 0x17, 0xee, 0xfe, 0x88, 0x0e, 0x71, 0x08,
+	0x00, 0x16, 0x71, 0x06, 0x00, 0x17, 0x11, 0x07,
+	0xf0, 0x66, 0x00, 0x0d, 0xf0, 0x00, 0x25, 0xa0,
+	0x88, 0x11, 0x76, 0x01, 0x00, 0x06, 0x81, 0x00,
+	0xf2, 0x74, 0x06, 0xce, 0xf0, 0x00, 0x00, 0x01,
+	0x76, 0x01, 0x00, 0x06, 0x70, 0x00, 0x00, 0x16,
+	0x48, 0x11, 0xf2, 0x74, 0x06, 0xce, 0xf0, 0x00,
+	0x00, 0x07, 0x70, 0x81, 0x00, 0x17, 0xee, 0x02,
+	0x8a, 0x17, 0x8a, 0x16, 0x8a, 0x11, 0xfc, 0x00,
+	0x4a, 0x11, 0x88, 0x0e, 0x71, 0x02, 0x00, 0x12,
+	0x11, 0x03, 0xf0, 0x66, 0x00, 0x0d, 0xf0, 0x00,
+	0x24, 0x00, 0x88, 0x11, 0xf4, 0x95, 0x70, 0x81,
+	0x00, 0x12, 0x6e, 0xe2, 0xff, 0xfe, 0x0e, 0x8d,
+	0xf4, 0x95, 0xe8, 0x00, 0xe8, 0x01, 0x80, 0xe1,
+	0x00, 0x02, 0x76, 0xe1, 0x00, 0x03, 0x00, 0xff,
+	0x76, 0xe1, 0x00, 0x04, 0x00, 0x00, 0x76, 0xe1,
+	0x00, 0x0b, 0x00, 0x00, 0x76, 0xe1, 0x00, 0x0c,
+	0x00, 0x00, 0x81, 0xe1, 0x00, 0x01, 0x8a, 0x11,
+	0xfc, 0x00, 0x4a, 0x11, 0xee, 0xfc, 0x88, 0x0e,
+	0xf4, 0x95, 0xf1, 0x66, 0x00, 0x0d, 0xf3, 0x00,
+	0x24, 0x00, 0x89, 0x11, 0xf4, 0x95, 0xf4, 0x95,
+	0x76, 0xe1, 0x00, 0x0c, 0x00, 0x00, 0x76, 0xe1,
+	0x00, 0x0b, 0x00, 0x00, 0x76, 0xe1, 0x00, 0x02,
+	0x00, 0x01, 0x76, 0x00, 0x00, 0x00, 0x76, 0x01,
+	0x00, 0x00, 0x80, 0x02, 0x76, 0x03, 0x00, 0x00,
+	0xf2, 0x74, 0x0c, 0xb9, 0xf4, 0x95, 0xe8, 0x00,
+	0xee, 0x04, 0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11,
+	0x88, 0x19, 0xf4, 0x95, 0x73, 0x19, 0x00, 0x0e,
+	0xf1, 0x66, 0x00, 0x0d, 0xf2, 0x00, 0x24, 0x00,
+	0x77, 0x15, 0x25, 0xa0, 0x77, 0x14, 0x00, 0x00,
+	0x77, 0x1a, 0x00, 0x1f, 0xf0, 0x72, 0x0f, 0x14,
+	0xf6, 0xb8, 0x49, 0x19, 0x09, 0x85, 0xf8, 0x4c,
+	0x0f, 0x13, 0xf1, 0x00, 0x00, 0x05, 0x89, 0x11,
+	0x49, 0x15, 0xf3, 0x00, 0x00, 0x01, 0x89, 0x13,
+	0x49, 0x15, 0xf3, 0x00, 0x00, 0x07, 0x89, 0x12,
+	0x11, 0x93, 0x1d, 0x91, 0x19, 0x92, 0x89, 0x10,
+	0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x80, 0x0f, 0x13,
+	0x11, 0x93, 0x1d, 0x91, 0x19, 0x92, 0x89, 0x10,
+	0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x80, 0x0f, 0x13,
+	0x11, 0x93, 0x1d, 0x91, 0x19, 0x92, 0x89, 0x10,
+	0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x80, 0x0f, 0x13,
+	0x11, 0x93, 0x1d, 0x91, 0x19, 0x92, 0x89, 0x10,
+	0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x80, 0x0f, 0x13,
+	0x11, 0x93, 0x1d, 0x91, 0x19, 0x92, 0x89, 0x10,
+	0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x80, 0x0f, 0x13,
+	0x11, 0x93, 0x1d, 0x91, 0x19, 0x92, 0x89, 0x11,
+	0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x81, 0x0f, 0x13,
+	0x6d, 0x94, 0x6d, 0xed, 0x00, 0x0d, 0x48, 0x14,
+	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0x4a, 0x16,
+	0x4a, 0x17, 0xee, 0xf8, 0x88, 0x17, 0x10, 0x0d,
+	0x80, 0x04, 0x10, 0x0c, 0x80, 0x05, 0x71, 0x0e,
+	0x00, 0x16, 0x73, 0x17, 0x00, 0x0e, 0xf0, 0x66,
+	0x00, 0x0d, 0xf0, 0x00, 0x24, 0x00, 0x88, 0x11,
+	0x10, 0xf8, 0x27, 0x63, 0xf8, 0x45, 0x0f, 0x32,
+	0xf2, 0x74, 0x0e, 0x9f, 0xf4, 0x95, 0x48, 0x17,
+	0x10, 0xf8, 0x27, 0x60, 0xf8, 0x44, 0x0f, 0x3d,
+	0x60, 0xe1, 0x00, 0x02, 0x00, 0x01, 0xf8, 0x20,
+	0x0f, 0x6d, 0xf0, 0x73, 0x11, 0x33, 0x10, 0x04,
+	0x80, 0x00, 0x10, 0x05, 0xf0, 0x74, 0x06, 0x9f,
+	0x11, 0x04, 0xf3, 0x00, 0x00, 0x01, 0x81, 0x04,
+	0x6d, 0x8e, 0x77, 0x10, 0x00, 0x01, 0x71, 0xe1,
+	0x00, 0x02, 0x00, 0x12, 0xf4, 0xaa, 0xf8, 0x30,
+	0x0f, 0x62, 0x77, 0x10, 0x00, 0x02, 0xf4, 0xaa,
+	0xf8, 0x30, 0x0f, 0x6d, 0x45, 0xe1, 0x00, 0x0b,
+	0x88, 0x10, 0x43, 0xe1, 0x00, 0x0c, 0x83, 0xf8,
+	0x00, 0x12, 0xf4, 0x95, 0xf4, 0x95, 0xf4, 0xaa,
+	0xf8, 0x30, 0x0f, 0x6d, 0xf0, 0x73, 0x0f, 0x96,
+	0xf5, 0x00, 0x81, 0x04, 0x49, 0x16, 0xf5, 0x20,
+	0x89, 0x16, 0x76, 0xe1, 0x00, 0x0c, 0x00, 0x00,
+	0x76, 0xe1, 0x00, 0x04, 0x00, 0x00, 0x48, 0x16,
+	0xf8, 0x45, 0x11, 0x33, 0xf7, 0xb8, 0x71, 0xe1,
+	0x00, 0x02, 0x00, 0x12, 0x10, 0xf8, 0x00, 0x12,
+	0xf0, 0x10, 0x00, 0x03, 0xf8, 0x46, 0x0f, 0x8c,
+	0x10, 0xf8, 0x00, 0x12, 0xf0, 0x10, 0x00, 0x03,
+	0xf8, 0x45, 0x10, 0x16, 0x77, 0x10, 0x00, 0x01,
+	0xf4, 0xaa, 0xf8, 0x30, 0x0f, 0x9c, 0x77, 0x10,
+	0x00, 0x02, 0xf4, 0xaa, 0xf8, 0x30, 0x0f, 0xa8,
+	0xf0, 0x73, 0x0f, 0x96, 0x77, 0x10, 0x00, 0x04,
+	0xf4, 0xaa, 0xf8, 0x30, 0x10, 0xb7, 0x77, 0x10,
+	0x00, 0x05, 0xf4, 0xaa, 0xf8, 0x30, 0x10, 0xbc,
+	0xf2, 0x74, 0x0e, 0x9f, 0xf4, 0x95, 0x48, 0x17,
+	0xf0, 0x73, 0x11, 0x31, 0x76, 0xe1, 0x00, 0x0c,
+	0x00, 0x00, 0x76, 0xe1, 0x00, 0x0b, 0x00, 0x00,
+	0x76, 0xe1, 0x00, 0x04, 0x00, 0x00, 0x76, 0xe1,
+	0x00, 0x02, 0x00, 0x02, 0x11, 0xe1, 0x00, 0x0c,
+	0xe8, 0x03, 0xf6, 0x20, 0x89, 0x12, 0xf4, 0x95,
+	0x77, 0x10, 0x00, 0x03, 0xf5, 0xaa, 0xf8, 0x30,
+	0x0f, 0xb6, 0x6b, 0xf8, 0x27, 0x6f, 0x00, 0x01,
+	0x88, 0x10, 0xf4, 0x95, 0xf4, 0x95, 0xf5, 0xae,
+	0xf8, 0x20, 0x0f, 0xbd, 0x48, 0x16, 0x80, 0x06,
+	0x88, 0x13, 0xf4, 0x95, 0x77, 0x10, 0x00, 0x03,
+	0xf6, 0xab, 0xf8, 0x20, 0x0f, 0xc8, 0x6b, 0xf8,
+	0x27, 0x6f, 0x00, 0x01, 0x12, 0x06, 0xf8, 0x45,
+	0x10, 0x00, 0x10, 0xe1, 0x00, 0x04, 0x80, 0x00,
+	0x10, 0x05, 0x80, 0x01, 0x10, 0x04, 0x80, 0x02,
+	0x10, 0x06, 0x80, 0x03, 0x48, 0x11, 0xf2, 0x74,
+	0x07, 0x1e, 0xf0, 0x00, 0x00, 0x05, 0x10, 0x06,
+	0x00, 0xe1, 0x00, 0x04, 0x80, 0xe1, 0x00, 0x04,
+	0x10, 0x06, 0x00, 0xe1, 0x00, 0x0c, 0x80, 0xe1,
+	0x00, 0x0c, 0x88, 0x12, 0x11, 0x06, 0x10, 0x04,
+	0xf6, 0x00, 0x80, 0x04, 0x48, 0x16, 0xf6, 0x20,
+	0x88, 0x16, 0x89, 0x13, 0xf4, 0x95, 0x77, 0x10,
+	0x00, 0x03, 0xf6, 0xab, 0xf8, 0x20, 0x0f, 0xf5,
+	0x6b, 0xf8, 0x27, 0x6f, 0x00, 0x01, 0x77, 0x10,
+	0x00, 0x0c, 0x71, 0xe1, 0x00, 0x04, 0x00, 0x13,
+	0xf6, 0xab, 0xf8, 0x20, 0x10, 0x00, 0x6b, 0xf8,
+	0x27, 0x6f, 0x00, 0x01, 0x6c, 0xe2, 0xff, 0xfd,
+	0x11, 0x31, 0xf6, 0xb8, 0x6f, 0xe1, 0x00, 0x05,
+	0x0c, 0x48, 0x6f, 0xe1, 0x00, 0x06, 0x0c, 0x18,
+	0xf0, 0x30, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x03,
+	0x80, 0xe1, 0x00, 0x0b, 0x76, 0xe1, 0x00, 0x02,
+	0x00, 0x03, 0x48, 0x16, 0xf8, 0x45, 0x11, 0x33,
+	0x71, 0xe1, 0x00, 0x0c, 0x00, 0x12, 0x10, 0xe1,
+	0x00, 0x0b, 0x49, 0x12, 0xf6, 0x20, 0x88, 0x13,
+	0xe8, 0x0c, 0xf6, 0x20, 0x88, 0x10, 0xf4, 0x95,
+	0xf4, 0x95, 0xf5, 0xab, 0xf8, 0x20, 0x10, 0x27,
+	0x48, 0x13, 0x80, 0x06, 0x88, 0x10, 0xf4, 0x95,
+	0xf4, 0x95, 0xf5, 0xae, 0xf8, 0x20, 0x10, 0x30,
+	0x70, 0x06, 0x00, 0x16, 0x12, 0x06, 0xf8, 0x45,
+	0x10, 0x5f, 0x10, 0xe1, 0x00, 0x04, 0x80, 0x00,
+	0x10, 0x05, 0x80, 0x01, 0x10, 0x04, 0x80, 0x02,
+	0x10, 0x06, 0x80, 0x03, 0x48, 0x11, 0xf2, 0x74,
+	0x07, 0x1e, 0xf0, 0x00, 0x00, 0x05, 0x10, 0x06,
+	0x00, 0xe1, 0x00, 0x04, 0x80, 0xe1, 0x00, 0x04,
+	0x10, 0x06, 0x00, 0xe1, 0x00, 0x0c, 0x80, 0xe1,
+	0x00, 0x0c, 0x88, 0x12, 0x11, 0x06, 0x10, 0x04,
+	0xf6, 0x00, 0x80, 0x04, 0x48, 0x16, 0xf6, 0x20,
+	0x88, 0x16, 0xf4, 0x95, 0x77, 0x10, 0x00, 0x0c,
+	0x71, 0xe1, 0x00, 0x04, 0x00, 0x13, 0xf6, 0xab,
+	0xf8, 0x20, 0x10, 0x5f, 0x6b, 0xf8, 0x27, 0x6f,
+	0x00, 0x01, 0x77, 0x10, 0x00, 0x0c, 0xf6, 0xaa,
+	0xf8, 0x20, 0x10, 0x6b, 0xf2, 0x74, 0x0e, 0x9f,
+	0xf4, 0x95, 0x48, 0x17, 0x71, 0xe1, 0x00, 0x0c,
+	0x00, 0x12, 0x77, 0x10, 0x00, 0x0c, 0xf4, 0xaa,
+	0xf8, 0x30, 0x10, 0x7c, 0x77, 0x10, 0x00, 0x0c,
+	0x71, 0xe1, 0x00, 0x0b, 0x00, 0x13, 0xf6, 0xab,
+	0xf8, 0x30, 0x10, 0xb4, 0xe7, 0x30, 0xf7, 0xaa,
+	0xf8, 0x30, 0x10, 0xb4, 0xf2, 0x74, 0x0e, 0xc1,
+	0xf4, 0x95, 0x48, 0x17, 0x88, 0x12, 0xf4, 0x95,
+	0xf4, 0x95, 0x6c, 0x82, 0x10, 0x8d, 0x76, 0xe1,
+	0x00, 0x04, 0x00, 0x00, 0x76, 0xe1, 0x00, 0x02,
+	0x00, 0x05, 0xf0, 0x73, 0x10, 0xb4, 0x76, 0xe1,
+	0x00, 0x02, 0x00, 0x04, 0x77, 0x10, 0x00, 0x0c,
+	0x71, 0xe1, 0x00, 0x0b, 0x00, 0x12, 0xf5, 0xaa,
+	0xf8, 0x20, 0x10, 0x9a, 0xf0, 0x73, 0x10, 0x9c,
+	0x77, 0x12, 0x00, 0x0c, 0x76, 0x00, 0x00, 0x00,
+	0x70, 0x01, 0x00, 0x12, 0x70, 0x02, 0x00, 0x17,
+	0x76, 0x03, 0x00, 0x01, 0x48, 0x11, 0xf2, 0x74,
+	0x0c, 0xb9, 0xf0, 0x00, 0x00, 0x05, 0x76, 0xe1,
+	0x00, 0x04, 0x00, 0x00, 0x77, 0x10, 0x00, 0x0c,
+	0x71, 0xe1, 0x00, 0x0b, 0x00, 0x12, 0xf6, 0xaa,
+	0xf8, 0x20, 0x11, 0x1c, 0x48, 0x16, 0xf8, 0x45,
+	0x11, 0x33, 0x60, 0xe1, 0x00, 0x02, 0x00, 0x05,
+	0xf8, 0x20, 0x10, 0xdf, 0x10, 0xe1, 0x00, 0x0b,
+	0x08, 0xe1, 0x00, 0x0c, 0x11, 0xe1, 0x00, 0x04,
+	0xf8, 0x4d, 0x10, 0xc7, 0x6b, 0xf8, 0x27, 0x6f,
+	0x00, 0x01, 0x88, 0x10, 0xf4, 0x95, 0xf4, 0x95,
+	0xf5, 0xae, 0xf8, 0x20, 0x10, 0xcf, 0x48, 0x16,
+	0xf4, 0x95, 0x48, 0x08, 0xf8, 0x45, 0x11, 0x16,
+	0x6f, 0xe1, 0x00, 0x0c, 0x0d, 0x00, 0x81, 0xe1,
+	0x00, 0x0c, 0x11, 0x04, 0xf5, 0x00, 0x81, 0x04,
+	0x49, 0x16, 0xf5, 0x20, 0x89, 0x16, 0xf0, 0x73,
+	0x11, 0x0e, 0x10, 0xe1, 0x00, 0x0b, 0x71, 0xe1,
+	0x00, 0x0c, 0x00, 0x12, 0x88, 0x10, 0xf4, 0x95,
+	0xf4, 0x95, 0xf6, 0xaa, 0xf8, 0x30, 0x11, 0x16,
+	0x49, 0x12, 0xf6, 0x20, 0x88, 0x10, 0xf4, 0x95,
+	0xf4, 0x95, 0xf5, 0xae, 0xf8, 0x20, 0x10, 0xf3,
+	0x48, 0x16, 0x80, 0x06, 0x48, 0x08, 0xf8, 0x45,
+	0x11, 0x16, 0x10, 0x04, 0x70, 0x02, 0x00, 0x17,
+	0x80, 0x00, 0x76, 0x03, 0x00, 0x00, 0x10, 0x06,
+	0x80, 0x01, 0x10, 0x05, 0xf0, 0x74, 0x0c, 0xb9,
+	0x10, 0x06, 0x00, 0xe1, 0x00, 0x0c, 0x80, 0xe1,
+	0x00, 0x0c, 0x11, 0x06, 0x10, 0x04, 0xf6, 0x00,
+	0x80, 0x04, 0x48, 0x16, 0xf6, 0x20, 0x88, 0x16,
+	0x10, 0xe1, 0x00, 0x0c, 0x08, 0xe1, 0x00, 0x0b,
+	0xf8, 0x45, 0x11, 0x1c, 0xf0, 0x73, 0x11, 0x31,
+	0xf2, 0x74, 0x0e, 0x9f, 0xf4, 0x95, 0x48, 0x17,
+	0xf0, 0x73, 0x11, 0x33, 0x76, 0xe1, 0x00, 0x0c,
+	0x00, 0x00, 0x76, 0xe1, 0x00, 0x0b, 0x00, 0x00,
+	0x76, 0xe1, 0x00, 0x02, 0x00, 0x01, 0x10, 0x04,
+	0x80, 0x00, 0x10, 0x05, 0xf0, 0x74, 0x06, 0x9f,
+	0x88, 0x12, 0xf4, 0x95, 0x77, 0x10, 0x00, 0xff,
+	0xf4, 0xaa, 0xf8, 0x30, 0x11, 0x33, 0x6c, 0x86,
+	0x0f, 0x70, 0xee, 0x08, 0x8a, 0x17, 0x8a, 0x16,
+	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0xee, 0xfc,
+	0xf4, 0x95, 0x71, 0x06, 0x00, 0x12, 0x88, 0x11,
+	0x73, 0x12, 0x00, 0x0e, 0xf1, 0x66, 0x00, 0x0d,
+	0xf3, 0x00, 0x24, 0x00, 0x89, 0x14, 0x13, 0x81,
+	0xf7, 0x7a, 0xf3, 0x30, 0x00, 0x01, 0x81, 0xf8,
+	0x27, 0x60, 0x13, 0xe1, 0x00, 0x01, 0xf7, 0x7c,
+	0xf3, 0x30, 0x00, 0x03, 0x81, 0xf8, 0x27, 0x61,
+	0xe9, 0x0f, 0x19, 0xe1, 0x00, 0x01, 0x81, 0xf8,
+	0x27, 0x62, 0x71, 0xe4, 0x00, 0x03, 0x00, 0x13,
+	0xf6, 0xb8, 0x49, 0x13, 0xf3, 0x00, 0x00, 0x01,
+	0xf3, 0x30, 0x00, 0x0f, 0x49, 0x0b, 0x09, 0xf8,
+	0x27, 0x62, 0xf8, 0x4d, 0x11, 0x75, 0x77, 0x10,
+	0x00, 0xff, 0xf4, 0xab, 0xf8, 0x30, 0x11, 0x75,
+	0x57, 0xf8, 0x27, 0x6c, 0xf3, 0x00, 0x00, 0x01,
+	0x4f, 0xf8, 0x27, 0x6c, 0x76, 0xf8, 0x27, 0x63,
+	0x00, 0x01, 0xf0, 0x73, 0x11, 0x78, 0x76, 0xf8,
+	0x27, 0x63, 0x00, 0x00, 0x70, 0xe4, 0x00, 0x03,
+	0x27, 0x62, 0x76, 0xf8, 0x27, 0x64, 0x00, 0x00,
+	0x11, 0xf8, 0x27, 0x61, 0x61, 0xf8, 0x00, 0x0b,
+	0x00, 0x02, 0xf8, 0x20, 0x11, 0x8d, 0xe9, 0x01,
+	0x6f, 0xe1, 0x00, 0x02, 0x0f, 0x18, 0x81, 0xf8,
+	0x27, 0x64, 0x11, 0xf8, 0x27, 0x61, 0x61, 0xf8,
+	0x00, 0x0b, 0x00, 0x01, 0xf8, 0x20, 0x11, 0xa9,
+	0x10, 0xf8, 0x27, 0x64, 0xf1, 0x00, 0x00, 0x04,
+	0x89, 0x13, 0xe9, 0xb8, 0xf5, 0x20, 0x81, 0xf8,
+	0x27, 0x65, 0x60, 0x84, 0x00, 0x02, 0xf8, 0x20,
+	0x11, 0xa9, 0x70, 0x00, 0x00, 0x11, 0x70, 0x01,
+	0x00, 0x13, 0x70, 0x02, 0x27, 0x65, 0xf2, 0x74,
+	0x0f, 0x18, 0xf4, 0x95, 0x48, 0x12, 0xee, 0x04,
+	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0x4a, 0x16,
+	0x4a, 0x17, 0xee, 0xfc, 0xe8, 0x00, 0x4e, 0xf8,
+	0x27, 0x66, 0xe8, 0x00, 0x4e, 0xf8, 0x27, 0x68,
+	0xe8, 0x00, 0x4e, 0xf8, 0x27, 0x6c, 0xe8, 0x00,
+	0x4e, 0xf8, 0x27, 0x6a, 0x77, 0x12, 0x27, 0x40,
+	0x77, 0x11, 0x24, 0x00, 0x77, 0x1a, 0x00, 0x1f,
+	0xf0, 0x72, 0x11, 0xdb, 0x70, 0x92, 0x00, 0x11,
+	0x76, 0xe1, 0x00, 0x01, 0xff, 0xff, 0x76, 0x81,
+	0x00, 0x00, 0x76, 0xe1, 0x00, 0x02, 0x00, 0x00,
+	0x76, 0xe1, 0x00, 0x03, 0x00, 0xff, 0x76, 0xe1,
+	0x00, 0x0c, 0x00, 0x00, 0x76, 0xe1, 0x00, 0x0b,
+	0x00, 0x00, 0x76, 0xe1, 0x00, 0x04, 0x00, 0x00,
+	0x6d, 0xe9, 0x00, 0x0d, 0xf0, 0x20, 0x25, 0xa0,
+	0xf1, 0x00, 0x00, 0x07, 0x89, 0x11, 0xf1, 0x00,
+	0x00, 0x01, 0x81, 0x02, 0x88, 0x16, 0xf4, 0x95,
+	0x77, 0x17, 0x00, 0x20, 0x76, 0x86, 0x00, 0xff,
+	0x76, 0x00, 0x00, 0x00, 0x76, 0x01, 0x00, 0x06,
+	0x10, 0x02, 0xf0, 0x74, 0x06, 0x6c, 0x76, 0x00,
+	0x00, 0x00, 0x76, 0x01, 0x00, 0x06, 0xf2, 0x74,
+	0x06, 0x6c, 0xf4, 0x95, 0x48, 0x11, 0x10, 0x02,
+	0xf0, 0x00, 0x00, 0x0d, 0x80, 0x02, 0x6d, 0xe9,
+	0x00, 0x0d, 0x6d, 0xee, 0x00, 0x0d, 0x6c, 0xef,
+	0xff, 0xff, 0x11, 0xe8, 0xf0, 0x74, 0x0c, 0x9d,
+	0xee, 0x04, 0x8a, 0x17, 0x8a, 0x16, 0x8a, 0x11,
+	0xfc, 0x00, 0x4a, 0x11, 0x4a, 0x16, 0x4a, 0x17,
+	0xee, 0xfa, 0x88, 0x11, 0x10, 0x0a, 0x49, 0x11,
+	0xf8, 0x4d, 0x12, 0x9f, 0x48, 0x08, 0xf8, 0x45,
+	0x12, 0x9f, 0x80, 0x04, 0x12, 0x81, 0xf5, 0x78,
+	0x89, 0x12, 0xf4, 0x95, 0xf4, 0x95, 0x6c, 0xe2,
+	0xff, 0xb9, 0x12, 0x8a, 0x61, 0xf8, 0x00, 0x08,
+	0x00, 0x80, 0xf8, 0x30, 0x12, 0x8a, 0x13, 0xe1,
+	0x00, 0x01, 0xf0, 0xe8, 0xf7, 0x78, 0xf1, 0xa0,
+	0xf2, 0x30, 0x1f, 0xff, 0x88, 0x17, 0xf4, 0x95,
+	0x77, 0x12, 0x24, 0x00, 0x77, 0x16, 0x00, 0x00,
+	0x77, 0x13, 0x00, 0x20, 0xf6, 0xb8, 0x48, 0x17,
+	0x08, 0xe2, 0x00, 0x01, 0xf8, 0x45, 0x12, 0x42,
+	0x6d, 0xea, 0x00, 0x0d, 0x6d, 0x96, 0x6c, 0xeb,
+	0xff, 0xff, 0x12, 0x34, 0xf0, 0x73, 0x12, 0x90,
+	0x56, 0xf8, 0x27, 0x6a, 0xf0, 0x00, 0x00, 0x01,
+	0x4e, 0xf8, 0x27, 0x6a, 0x60, 0x82, 0x00, 0x01,
+	0xf8, 0x30, 0x12, 0x54, 0x70, 0x00, 0x00, 0x16,
+	0xf2, 0x74, 0x11, 0x38, 0xf4, 0x95, 0x48, 0x11,
+	0xf0, 0x73, 0x12, 0x90, 0x70, 0x00, 0x00, 0x16,
+	0xf2, 0x74, 0x11, 0x38, 0xf4, 0x95, 0x48, 0x11,
+	0x72, 0x10, 0x2a, 0x9e, 0xf4, 0x95, 0xf4, 0xaf,
+	0xf8, 0x30, 0x12, 0x6e, 0x76, 0x00, 0x00, 0x00,
+	0x76, 0x01, 0x00, 0xbc, 0x70, 0x02, 0x00, 0x16,
+	0x76, 0x03, 0x00, 0x00, 0xf2, 0x74, 0x0c, 0xb9,
+	0xf4, 0x95, 0x48, 0x11, 0xf0, 0x73, 0x12, 0x90,
+	0x10, 0xf8, 0x27, 0x6e, 0xf8, 0x44, 0x12, 0x90,
+	0x76, 0x00, 0x00, 0x00, 0x76, 0x01, 0x00, 0xbc,
+	0x70, 0x02, 0x00, 0x16, 0x76, 0x03, 0x00, 0x00,
+	0xf2, 0x74, 0x0c, 0xb9, 0xf4, 0x95, 0x48, 0x11,
+	0xf0, 0x74, 0x0c, 0x5e, 0xf0, 0xe0, 0xf0, 0x10,
+	0x13, 0x88, 0xf8, 0x42, 0x12, 0x90, 0x76, 0xf8,
+	0x27, 0x6e, 0x00, 0x01, 0xf0, 0x73, 0x12, 0x90,
+	0x56, 0xf8, 0x27, 0x66, 0xf0, 0x00, 0x00, 0x01,
+	0x4e, 0xf8, 0x27, 0x66, 0x6d, 0xe9, 0x00, 0x5e,
+	0x56, 0xf8, 0x27, 0x68, 0xf0, 0x00, 0x00, 0x01,
+	0x4e, 0xf8, 0x27, 0x68, 0x71, 0x04, 0x00, 0x12,
+	0x6e, 0xea, 0xff, 0xff, 0x12, 0x18, 0x70, 0x04,
+	0x00, 0x12, 0xee, 0x06, 0x8a, 0x17, 0x8a, 0x16,
+	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0xee, 0xfe,
+	0x88, 0x0e, 0xf4, 0x95, 0xf0, 0x66, 0x00, 0x0d,
+	0xf0, 0x00, 0x25, 0xa0, 0x88, 0x11, 0xf4, 0x95,
+	0xf4, 0x95, 0x76, 0x81, 0x00, 0xff, 0x76, 0x00,
+	0x00, 0x00, 0x76, 0x01, 0x00, 0x06, 0xf2, 0x74,
+	0x06, 0x6c, 0xf0, 0x00, 0x00, 0x01, 0x76, 0x00,
+	0x00, 0x00, 0x76, 0x01, 0x00, 0x06, 0x48, 0x11,
+	0xf2, 0x74, 0x06, 0x6c, 0xf0, 0x00, 0x00, 0x07,
+	0xee, 0x02, 0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11,
+	0x88, 0x0e, 0xf4, 0x95, 0xf0, 0x66, 0x00, 0x0d,
+	0xf0, 0x00, 0x24, 0x00, 0x88, 0x11, 0xf4, 0x95,
+	0xf4, 0x95, 0x76, 0xe1, 0x00, 0x01, 0xff, 0xff,
+	0x76, 0x81, 0x00, 0x00, 0x76, 0xe1, 0x00, 0x02,
+	0x00, 0x00, 0x76, 0xe1, 0x00, 0x03, 0x00, 0xff,
+	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0xf4, 0x95,
+	0x13, 0x03, 0x88, 0x11, 0xfa, 0x4d, 0x12, 0xec,
+	0x71, 0x02, 0x00, 0x12, 0xf3, 0x10, 0x00, 0x01,
+	0x89, 0x1a, 0xf4, 0x95, 0xf0, 0x72, 0x12, 0xeb,
+	0x70, 0x91, 0x00, 0x12, 0x8a, 0x11, 0xfc, 0x00,
+	0xf4, 0x95, 0x4a, 0x0b, 0x4a, 0x0c, 0x4a, 0x0d,
+	0xf7, 0xb8, 0xee, 0xfe, 0x10, 0xf8, 0x00, 0x08,
+	0x11, 0x06, 0xf1, 0xc0, 0x83, 0x00, 0xf4, 0x85,
+	0x11, 0x06, 0xf7, 0x85, 0x81, 0x06, 0xf6, 0xb8,
+	0xec, 0x0f, 0x1e, 0x06, 0x61, 0x00, 0x80, 0x00,
+	0xf8, 0x20, 0x13, 0x05, 0xf4, 0x84, 0xee, 0x02,
+	0x8a, 0x0d, 0x8a, 0x0c, 0x8a, 0x0b, 0xfc, 0x00,
+	0xf4, 0x95, 0x4a, 0x0b, 0x4a, 0x0c, 0x4a, 0x0d,
+	0xee, 0xfe, 0xf7, 0xb8, 0x80, 0x00, 0x10, 0xf8,
+	0x00, 0x08, 0xf4, 0x85, 0x11, 0x06, 0xf7, 0x85,
+	0x81, 0x06, 0xf6, 0xb8, 0xec, 0x0f, 0x1e, 0x06,
+	0xf0, 0xf0, 0x61, 0x00, 0x80, 0x00, 0xf8, 0x20,
+	0x13, 0x20, 0xf4, 0x84, 0xee, 0x02, 0x8a, 0x0d,
+	0x8a, 0x0c, 0x8a, 0x0b, 0xfc, 0x00, 0x4a, 0x11,
+	0x77, 0x11, 0x00, 0x7b, 0x76, 0x81, 0x2e, 0xec,
+	0x77, 0x11, 0x00, 0x7b, 0xee, 0xff, 0x71, 0x81,
+	0x00, 0x11, 0xee, 0x01, 0x76, 0xe1, 0x00, 0x01,
+	0x00, 0x00, 0x76, 0xe1, 0x00, 0x04, 0x00, 0x00,
+	0x76, 0xe1, 0x00, 0x06, 0x00, 0x00, 0x76, 0xe1,
+	0x00, 0x62, 0x00, 0x00, 0x76, 0xe1, 0x00, 0x76,
+	0x00, 0x00, 0x76, 0xe1, 0x00, 0x92, 0x00, 0x00,
+	0x76, 0xe1, 0x00, 0x94, 0x00, 0x00, 0x76, 0xe1,
+	0x00, 0xb0, 0x00, 0x00, 0x76, 0xe1, 0x00, 0xb3,
+	0x00, 0x00, 0x76, 0xe1, 0x00, 0xbe, 0x00, 0x00,
+	0x76, 0xe1, 0x00, 0xbf, 0x00, 0x00, 0x76, 0xe1,
+	0x00, 0xc1, 0x00, 0x00, 0x76, 0xe1, 0x00, 0xc3,
+	0x00, 0x00, 0x76, 0xe1, 0x00, 0xc5, 0x00, 0x00,
+	0x76, 0xe1, 0x00, 0xc7, 0x00, 0x00, 0x76, 0x81,
+	0x00, 0x00, 0x8a, 0x11, 0xf4, 0x95, 0xf4, 0xe4,
+	0x4a, 0x11, 0x4a, 0x16, 0x4a, 0x17, 0xee, 0xff,
+	0xf4, 0x95, 0x71, 0x06, 0x00, 0x16, 0xfb, 0x80,
+	0x16, 0xa2, 0x88, 0x17, 0xf4, 0x95, 0xf7, 0xb8,
+	0x10, 0xf8, 0x00, 0x17, 0xf0, 0x10, 0x00, 0x02,
+	0xfa, 0x46, 0x13, 0x88, 0x77, 0x11, 0x00, 0x00,
+	0x10, 0xf8, 0x00, 0x17, 0xf0, 0x10, 0x00, 0x02,
+	0xf8, 0x45, 0x13, 0xf9, 0x10, 0xf8, 0x00, 0x17,
+	0xf8, 0x45, 0x14, 0x39, 0x10, 0xf8, 0x00, 0x17,
+	0xf0, 0x10, 0x00, 0x01, 0xf8, 0x45, 0x14, 0x1f,
+	0xf0, 0x73, 0x14, 0x52, 0x10, 0xf8, 0x00, 0x17,
+	0xf0, 0x10, 0x00, 0x03, 0xf8, 0x45, 0x13, 0xd3,
+	0x10, 0xf8, 0x00, 0x17, 0xf0, 0x10, 0x00, 0x06,
+	0xf8, 0x44, 0x14, 0x52, 0x77, 0x12, 0x00, 0x7b,
+	0x71, 0x82, 0x00, 0x14, 0x61, 0xe4, 0x00, 0x07,
+	0x00, 0x40, 0xf8, 0x30, 0x14, 0x52, 0x49, 0x14,
+	0x48, 0x17, 0xf6, 0x00, 0x88, 0x12, 0xf4, 0x95,
+	0x77, 0x13, 0x00, 0x55, 0x77, 0x11, 0x00, 0x57,
+	0x6d, 0xea, 0x00, 0x3b, 0xe5, 0x01, 0x10, 0xe6,
+	0x00, 0x06, 0x80, 0x81, 0x48, 0x14, 0x00, 0xf8,
+	0x00, 0x17, 0x88, 0x12, 0xf4, 0x95, 0x77, 0x11,
+	0x00, 0x55, 0x10, 0xe2, 0x00, 0x40, 0x80, 0x81,
+	0x77, 0x11, 0x00, 0x57, 0x10, 0xe6, 0x00, 0x07,
+	0x80, 0x81, 0x77, 0x11, 0x00, 0x55, 0x10, 0xe2,
+	0x00, 0x45, 0x80, 0x81, 0x10, 0xe6, 0x00, 0x08,
+	0x77, 0x11, 0x00, 0x57, 0x80, 0x81, 0x77, 0x11,
+	0x00, 0x55, 0x10, 0xe2, 0x00, 0x4a, 0x80, 0x81,
+	0x77, 0x11, 0x00, 0x57, 0x10, 0xe6, 0x00, 0x09,
+	0x80, 0x81, 0xf2, 0x73, 0x14, 0x52, 0x77, 0x11,
+	0x03, 0xc0, 0x77, 0x12, 0x00, 0x7b, 0x10, 0x82,
+	0xf0, 0x00, 0x00, 0x07, 0x88, 0x13, 0xf4, 0x95,
+	0xf4, 0x95, 0x96, 0x1b, 0xf8, 0x30, 0x14, 0x52,
+	0x10, 0xe3, 0x00, 0x35, 0x77, 0x12, 0x00, 0x55,
+	0x80, 0x82, 0x77, 0x12, 0x00, 0x57, 0x10, 0xe6,
+	0x00, 0x04, 0x80, 0x82, 0x77, 0x12, 0x00, 0x55,
+	0x10, 0xe3, 0x00, 0x37, 0x80, 0x82, 0x77, 0x12,
+	0x00, 0x57, 0x10, 0xe6, 0x00, 0x05, 0x80, 0x82,
+	0x48, 0x11, 0xf0, 0x40, 0x00, 0x10, 0xf2, 0x73,
+	0x14, 0x50, 0xf0, 0x40, 0x00, 0x20, 0x77, 0x12,
+	0x00, 0x7b, 0x10, 0x82, 0xf0, 0x00, 0x00, 0x07,
+	0x88, 0x12, 0xf4, 0x95, 0xf4, 0x95, 0x96, 0x0d,
+	0xf8, 0x30, 0x14, 0x52, 0x10, 0xe2, 0x00, 0x34,
+	0x77, 0x13, 0x00, 0x55, 0x80, 0x83, 0x77, 0x13,
+	0x00, 0x57, 0x10, 0xe6, 0x00, 0x02, 0x80, 0x83,
+	0x10, 0xe2, 0x00, 0x36, 0x77, 0x12, 0x00, 0x55,
+	0x80, 0x82, 0x77, 0x12, 0x00, 0x57, 0x10, 0xe6,
+	0x00, 0x03, 0x80, 0x82, 0x48, 0x11, 0xf0, 0x40,
+	0x00, 0x04, 0xf2, 0x73, 0x14, 0x50, 0xf0, 0x40,
+	0x00, 0x08, 0x77, 0x12, 0x00, 0x7b, 0x10, 0x82,
+	0xf0, 0x00, 0x00, 0x07, 0x88, 0x12, 0xf4, 0x95,
+	0xf4, 0x95, 0x96, 0x0e, 0xf8, 0x30, 0x14, 0x52,
+	0x10, 0xe2, 0x00, 0x33, 0x77, 0x12, 0x00, 0x55,
+	0x80, 0x82, 0x77, 0x12, 0x00, 0x57, 0x10, 0xe6,
+	0x00, 0x01, 0x80, 0x82, 0x48, 0x11, 0xf2, 0x73,
+	0x14, 0x50, 0xf0, 0x40, 0x00, 0x02, 0x77, 0x12,
+	0x00, 0x7b, 0x10, 0x82, 0xf0, 0x00, 0x00, 0x07,
+	0x88, 0x12, 0xf4, 0x95, 0xf4, 0x95, 0x96, 0x0f,
+	0xf8, 0x30, 0x14, 0x52, 0x10, 0xe2, 0x00, 0x32,
+	0x77, 0x12, 0x00, 0x55, 0x77, 0x13, 0x00, 0x57,
+	0x80, 0x82, 0x48, 0x11, 0xe7, 0x62, 0xf0, 0x40,
+	0x00, 0x01, 0xe5, 0x01, 0x88, 0x11, 0xf4, 0x95,
+	0x77, 0x12, 0x00, 0x7b, 0x48, 0x11, 0x71, 0x82,
+	0x00, 0x12, 0x1a, 0xe2, 0x00, 0x07, 0x80, 0xe2,
+	0x00, 0x07, 0xf9, 0x80, 0x16, 0x9a, 0xee, 0x01,
+	0x8a, 0x17, 0x48, 0x11, 0x8a, 0x16, 0x8a, 0x11,
+	0xf4, 0xe4, 0x4a, 0x11, 0x88, 0x11, 0x77, 0x0e,
+	0x00, 0x05, 0x77, 0x12, 0x00, 0x55, 0xe8, 0x04,
+	0xf6, 0xb8, 0x28, 0xe1, 0x00, 0x02, 0xee, 0xff,
+	0x80, 0x82, 0x77, 0x12, 0x00, 0x57, 0xf0, 0x20,
+	0x80, 0x00, 0xee, 0x01, 0x1a, 0x82, 0x77, 0x12,
+	0x00, 0x57, 0x80, 0x82, 0xe8, 0x01, 0x32, 0xe1,
+	0x00, 0x02, 0xf5, 0x82, 0x77, 0x11, 0x00, 0x54,
+	0xf6, 0x93, 0x18, 0x81, 0x77, 0x11, 0x00, 0x54,
+	0xf2, 0xa0, 0x80, 0x81, 0x8a, 0x11, 0xf4, 0x95,
+	0xf4, 0xe4, 0x4a, 0x11, 0x4a, 0x16, 0xf4, 0x95,
+	0x71, 0x04, 0x00, 0x11, 0xfb, 0x80, 0x16, 0xa2,
+	0x88, 0x16, 0xf4, 0x95, 0x77, 0x12, 0x00, 0x55,
+	0x10, 0xe6, 0x00, 0x03, 0x80, 0x82, 0x77, 0x12,
+	0x00, 0x56, 0x10, 0xe1, 0x00, 0x02, 0x77, 0x13,
+	0x00, 0x56, 0x80, 0x82, 0x77, 0x12, 0x00, 0x56,
+	0x10, 0xe1, 0x00, 0x03, 0x80, 0x82, 0x10, 0xe1,
+	0x00, 0x04, 0x77, 0x12, 0x00, 0x56, 0x80, 0x82,
+	0x77, 0x12, 0x00, 0x56, 0x10, 0xe1, 0x00, 0x01,
+	0x80, 0x82, 0xe7, 0x12, 0xe5, 0x01, 0xf9, 0x80,
+	0x16, 0x9a, 0x8a, 0x16, 0x8a, 0x11, 0xf4, 0xe4,
+	0x4a, 0x11, 0x4a, 0x16, 0x4a, 0x17, 0xee, 0xf9,
+	0x77, 0x11, 0x00, 0x7b, 0x76, 0x00, 0x00, 0x16,
+	0x76, 0x01, 0x00, 0x17, 0x76, 0x02, 0x00, 0x1a,
+	0x76, 0x03, 0x00, 0x1b, 0x76, 0x04, 0x00, 0x1c,
+	0x76, 0x05, 0x00, 0x1d, 0x71, 0x81, 0x00, 0x17,
+	0x71, 0xe7, 0x00, 0x06, 0x00, 0x11, 0x10, 0x81,
+	0xf8, 0x44, 0x14, 0xdf, 0xf9, 0x80, 0x16, 0x53,
+	0xf6, 0xb8, 0xfb, 0x80, 0x15, 0x85, 0xf0, 0x20,
+	0xff, 0xff, 0xf6, 0xb8, 0xfb, 0x80, 0x16, 0x08,
+	0xf0, 0x20, 0xff, 0xff, 0x77, 0x11, 0x00, 0x7b,
+	0x71, 0x81, 0x00, 0x17, 0x76, 0xe7, 0x00, 0x06,
+	0x00, 0x01, 0x48, 0x17, 0x77, 0x16, 0x00, 0x00,
+	0x77, 0x10, 0x00, 0x04, 0x77, 0x15, 0x00, 0x03,
+	0x77, 0x14, 0x00, 0x02, 0x77, 0x13, 0x00, 0x01,
+	0xf0, 0x00, 0x00, 0x39, 0x76, 0xe7, 0x00, 0x08,
+	0x00, 0x1f, 0x76, 0xe7, 0x00, 0x07, 0x00, 0x00,
+	0x88, 0x0e, 0x77, 0x1a, 0x00, 0x05, 0x48, 0x17,
+	0xf0, 0x00, 0x00, 0x09, 0x88, 0x12, 0x48, 0x18,
+	0x88, 0x19, 0xe8, 0x00, 0xf0, 0x72, 0x15, 0x2c,
+	0x73, 0x19, 0x00, 0x11, 0x76, 0x82, 0x00, 0x00,
+	0x11, 0x91, 0x73, 0x11, 0x00, 0x19, 0x70, 0xe2,
+	0x00, 0x03, 0x00, 0x16, 0x70, 0xe2, 0x00, 0x04,
+	0x00, 0x13, 0x70, 0xe2, 0x00, 0x05, 0x00, 0x14,
+	0x81, 0xe2, 0x00, 0x01, 0x70, 0xe2, 0x00, 0x06,
+	0x00, 0x15, 0x70, 0xe2, 0x00, 0x07, 0x00, 0x10,
+	0x80, 0xe2, 0x00, 0x02, 0x73, 0x0e, 0x00, 0x11,
+	0xf1, 0x00, 0x00, 0x1e, 0x6d, 0xee, 0x00, 0x05,
+	0x6d, 0xeb, 0x00, 0x05, 0x6d, 0xec, 0x00, 0x05,
+	0x6d, 0xed, 0x00, 0x05, 0x6d, 0xe8, 0x00, 0x05,
+	0xf0, 0x00, 0x00, 0x01, 0x81, 0x91, 0x6d, 0xea,
+	0x00, 0x08, 0x73, 0x11, 0x00, 0x0e, 0xee, 0x07,
+	0x76, 0xe7, 0x00, 0x41, 0x00, 0x24, 0x76, 0xe7,
+	0x00, 0x46, 0x00, 0x25, 0x76, 0xe7, 0x00, 0x4b,
+	0x00, 0x26, 0x76, 0xe7, 0x00, 0x50, 0x00, 0x27,
+	0x8a, 0x17, 0x8a, 0x16, 0x8a, 0x11, 0xf4, 0xe4,
+	0x4a, 0x11, 0x4a, 0x16, 0xee, 0xfe, 0x88, 0x11,
+	0x56, 0x06, 0x4e, 0x00, 0xf9, 0x80, 0x16, 0xa2,
+	0xf7, 0xb8, 0x10, 0xf8, 0x00, 0x11, 0xf0, 0x10,
+	0xff, 0xff, 0xfa, 0x45, 0x15, 0x60, 0x77, 0x16,
+	0xff, 0xff, 0x77, 0x12, 0x00, 0x7b, 0x49, 0x11,
+	0x10, 0x82, 0xf6, 0x03, 0xf0, 0x00, 0x00, 0x09,
+	0x88, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x10, 0x81,
+	0xf8, 0x44, 0x15, 0x71, 0xf2, 0x73, 0x15, 0x71,
+	0xf4, 0x95, 0xe7, 0x16, 0x77, 0x11, 0x00, 0x7b,
+	0x10, 0x81, 0xf0, 0x00, 0x00, 0x09, 0x88, 0x11,
+	0xf4, 0x95, 0x77, 0x12, 0x00, 0x06, 0x10, 0x81,
+	0xf8, 0x45, 0x15, 0x5c, 0x6e, 0xea, 0xff, 0xff,
+	0x15, 0x69, 0x6d, 0xe9, 0x00, 0x08, 0x76, 0x86,
+	0x00, 0x01, 0xe9, 0x01, 0x56, 0x00, 0xf1, 0x80,
+	0x10, 0xf8, 0x00, 0x0b, 0xf8, 0x45, 0x15, 0x7e,
+	0xfb, 0x80, 0x15, 0x85, 0xf4, 0x95, 0x48, 0x16,
+	0xf9, 0x80, 0x16, 0x9a, 0xee, 0x02, 0x48, 0x16,
+	0x8a, 0x16, 0x8a, 0x11, 0xf4, 0xe4, 0x4a, 0x11,
+	0xee, 0xff, 0xfb, 0x80, 0x16, 0xa2, 0x88, 0x11,
+	0xf4, 0x95, 0x77, 0x10, 0xff, 0xff, 0xf4, 0xa9,
+	0xf8, 0x30, 0x15, 0xc4, 0x10, 0xe1, 0x00, 0x03,
+	0x77, 0x12, 0x00, 0x55, 0x80, 0x82, 0x77, 0x12,
+	0x00, 0x56, 0x76, 0x82, 0x00, 0x00, 0x77, 0x12,
+	0x00, 0x56, 0x76, 0x82, 0x00, 0x00, 0x77, 0x12,
+	0x00, 0x56, 0x76, 0x82, 0x00, 0x00, 0x77, 0x12,
+	0x00, 0x56, 0x76, 0x82, 0x00, 0x00, 0x77, 0x12,
+	0x00, 0x56, 0x76, 0x82, 0x00, 0x00, 0x10, 0xe1,
+	0x00, 0x02, 0xf0, 0x00, 0x00, 0x08, 0x32, 0xf8,
+	0x00, 0x08, 0x77, 0x12, 0x00, 0x54, 0xe8, 0x01,
+	0xf4, 0x82, 0xf4, 0x93, 0x18, 0x82, 0x77, 0x12,
+	0x00, 0x54, 0xf0, 0x40, 0x00, 0x00, 0x80, 0x82,
+	0x10, 0xe1, 0x00, 0x01, 0xf9, 0x80, 0x16, 0x76,
+	0x10, 0xe1, 0x00, 0x01, 0xf9, 0x80, 0x16, 0x66,
+	0xf0, 0x73, 0x16, 0x03, 0x77, 0x11, 0x00, 0x7b,
+	0x71, 0x81, 0x00, 0x11, 0x71, 0xe1, 0x00, 0x07,
+	0x00, 0x12, 0x76, 0x82, 0x00, 0x00, 0x10, 0xe1,
+	0x00, 0x09, 0xf9, 0x80, 0x15, 0x85, 0x77, 0x11,
+	0x00, 0x7b, 0x71, 0x81, 0x00, 0x11, 0x10, 0xe1,
+	0x00, 0x09, 0xfb, 0x80, 0x15, 0x85, 0xf0, 0x00,
+	0x00, 0x08, 0x77, 0x11, 0x00, 0x7b, 0x71, 0x81,
+	0x00, 0x11, 0x10, 0xe1, 0x00, 0x09, 0xfb, 0x80,
+	0x15, 0x85, 0xf0, 0x00, 0x00, 0x10, 0x77, 0x11,
+	0x00, 0x7b, 0x71, 0x81, 0x00, 0x11, 0x10, 0xe1,
+	0x00, 0x09, 0xfb, 0x80, 0x15, 0x85, 0xf0, 0x00,
+	0x00, 0x18, 0x77, 0x11, 0x00, 0x7b, 0x71, 0x81,
+	0x00, 0x11, 0x10, 0xe1, 0x00, 0x09, 0xfb, 0x80,
+	0x15, 0x85, 0xf0, 0x00, 0x00, 0x20, 0x77, 0x11,
+	0x00, 0x7b, 0x71, 0x81, 0x00, 0x11, 0x10, 0xe1,
+	0x00, 0x09, 0xfb, 0x80, 0x15, 0x85, 0xf0, 0x00,
+	0x00, 0x28, 0xf9, 0x80, 0x16, 0x9a, 0xee, 0x01,
+	0x8a, 0x11, 0xf4, 0xe4, 0x4a, 0x11, 0xee, 0xff,
+	0xfb, 0x80, 0x16, 0xa2, 0x88, 0x11, 0xf4, 0x95,
+	0x77, 0x10, 0xff, 0xff, 0xf4, 0xa9, 0xf8, 0x30,
+	0x16, 0x41, 0x77, 0x11, 0x00, 0x55, 0x76, 0x81,
+	0x00, 0x1e, 0x77, 0x11, 0x00, 0x56, 0x76, 0x81,
+	0x00, 0x00, 0x77, 0x11, 0x00, 0x56, 0x76, 0x81,
+	0x00, 0x00, 0x77, 0x11, 0x00, 0x56, 0x76, 0x81,
+	0x00, 0x00, 0x77, 0x11, 0x00, 0x56, 0x76, 0x81,
+	0x00, 0x00, 0x77, 0x11, 0x00, 0x56, 0x76, 0x81,
+	0x00, 0x00, 0x77, 0x11, 0x00, 0x56, 0x76, 0x81,
+	0x00, 0x00, 0x77, 0x11, 0x00, 0x56, 0x76, 0x81,
+	0x00, 0x00, 0x77, 0x11, 0x00, 0x56, 0x76, 0x81,
+	0x00, 0x00, 0x77, 0x11, 0x00, 0x56, 0x76, 0x81,
+	0x00, 0x00, 0x77, 0x11, 0x00, 0x56, 0xf2, 0x73,
+	0x16, 0x4e, 0x76, 0x81, 0x00, 0x00, 0x77, 0x11,
+	0x00, 0x7b, 0x71, 0x81, 0x00, 0x11, 0x71, 0xe1,
+	0x00, 0x07, 0x00, 0x12, 0x76, 0x82, 0x00, 0x00,
+	0x10, 0xe1, 0x00, 0x39, 0xf9, 0x80, 0x16, 0x08,
+	0xf9, 0x80, 0x16, 0x9a, 0xee, 0x01, 0x8a, 0x11,
+	0xf4, 0xe4, 0x4a, 0x11, 0x77, 0x11, 0x00, 0x7b,
+	0x10, 0x81, 0xf0, 0x00, 0x00, 0x04, 0x88, 0x11,
+	0xf4, 0x95, 0xf4, 0x95, 0x10, 0x81, 0xfa, 0x44,
+	0x16, 0x63, 0xf4, 0x95, 0xee, 0xff, 0x76, 0x81,
+	0x00, 0x01, 0xee, 0x01, 0x8a, 0x11, 0xf4, 0xe4,
+	0xf0, 0x10, 0x00, 0x10, 0x4a, 0x11, 0x32, 0xf8,
+	0x00, 0x08, 0xee, 0xff, 0x77, 0x11, 0x00, 0x01,
+	0xe8, 0x01, 0xee, 0x01, 0xf4, 0x82, 0x1a, 0x81,
+	0x80, 0x81, 0x8a, 0x11, 0xf4, 0x95, 0xf4, 0xe4,
+	0xf0, 0x10, 0x00, 0x10, 0x4a, 0x11, 0x32, 0xf8,
+	0x00, 0x08, 0xee, 0xff, 0xe8, 0x01, 0x77, 0x11,
+	0x00, 0x00, 0xf4, 0x82, 0xee, 0x01, 0xf4, 0x93,
+	0x18, 0x81, 0x80, 0x81, 0x8a, 0x11, 0xf4, 0x95,
+	0xf4, 0xe4, 0x4a, 0x11, 0xf0, 0x10, 0x00, 0x10,
+	0x77, 0x11, 0x00, 0x00, 0x32, 0xf8, 0x00, 0x08,
+	0xee, 0xff, 0x11, 0x81, 0xe8, 0x01, 0xee, 0x01,
+	0x77, 0x11, 0x00, 0x00, 0xf4, 0x82, 0xf2, 0xa0,
+	0x80, 0x81, 0x8a, 0x11, 0xf4, 0x95, 0xf4, 0xe4,
+	0xf2, 0x73, 0x16, 0x9e, 0xf6, 0xbb, 0xf4, 0x95,
+	0xf4, 0x95, 0xf4, 0x95, 0xf4, 0x95, 0xf4, 0xe4,
+	0xf2, 0x73, 0x16, 0xa6, 0xf7, 0xbb, 0xf4, 0x95,
+	0xf4, 0x95, 0xf4, 0x95, 0xf4, 0x95, 0xf4, 0xe4,
+	0x4a, 0x11, 0x4a, 0x16, 0xf4, 0x95, 0x71, 0x04,
+	0x00, 0x16, 0xfb, 0x80, 0x16, 0xa2, 0x88, 0x11,
+	0xf4, 0x95, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12,
+	0x76, 0x82, 0x00, 0x0e, 0x10, 0xe6, 0x00, 0x0e,
+	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x80, 0x82,
+	0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 0x76, 0x82,
+	0x00, 0x0d, 0x71, 0xe1, 0x00, 0x06, 0x00, 0x12,
+	0x10, 0xe6, 0x00, 0x0d, 0x80, 0x82, 0x71, 0xe1,
+	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x0c,
+	0x10, 0xe6, 0x00, 0x0c, 0x71, 0xe1, 0x00, 0x06,
+	0x00, 0x12, 0x80, 0x82, 0x71, 0xe1, 0x00, 0x05,
+	0x00, 0x12, 0x76, 0x82, 0x00, 0x0b, 0x10, 0xe6,
+	0x00, 0x0b, 0x71, 0xe1, 0x00, 0x06, 0x00, 0x12,
+	0x80, 0x82, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12,
+	0x76, 0x82, 0x00, 0x0a, 0x71, 0xe1, 0x00, 0x06,
+	0x00, 0x12, 0x10, 0xe6, 0x00, 0x0a, 0x80, 0x82,
+	0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 0x76, 0x82,
+	0x00, 0x09, 0x10, 0xe6, 0x00, 0x09, 0x71, 0xe1,
+	0x00, 0x06, 0x00, 0x12, 0x80, 0x82, 0x71, 0xe1,
+	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x08,
+	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x10, 0xe6,
+	0x00, 0x08, 0x80, 0x82, 0x71, 0xe1, 0x00, 0x05,
+	0x00, 0x12, 0x76, 0x82, 0x00, 0x07, 0x10, 0xe6,
+	0x00, 0x07, 0x71, 0xe1, 0x00, 0x06, 0x00, 0x12,
+	0x80, 0x82, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12,
+	0x76, 0x82, 0x00, 0x06, 0x71, 0xe1, 0x00, 0x06,
+	0x00, 0x12, 0x10, 0xe6, 0x00, 0x06, 0x80, 0x82,
+	0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 0x76, 0x82,
+	0x00, 0x05, 0x71, 0xe1, 0x00, 0x06, 0x00, 0x12,
+	0x10, 0xe6, 0x00, 0x05, 0x80, 0x82, 0x71, 0xe1,
+	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x04,
+	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x10, 0xe6,
+	0x00, 0x04, 0x80, 0x82, 0x71, 0xe1, 0x00, 0x05,
+	0x00, 0x12, 0x76, 0x82, 0x00, 0x03, 0x71, 0xe1,
+	0x00, 0x06, 0x00, 0x12, 0x10, 0xe6, 0x00, 0x03,
+	0x80, 0x82, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12,
+	0x76, 0x82, 0x00, 0x02, 0x10, 0xe6, 0x00, 0x02,
+	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x80, 0x82,
+	0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 0x76, 0x82,
+	0x00, 0x01, 0x10, 0xe6, 0x00, 0x01, 0x71, 0xe1,
+	0x00, 0x06, 0x00, 0x12, 0x80, 0x82, 0x71, 0xe1,
+	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x00,
+	0x71, 0xe1, 0x00, 0x06, 0x00, 0x13, 0xe7, 0x62,
+	0xe5, 0x01, 0xf9, 0x80, 0x16, 0x9a, 0x8a, 0x16,
+	0x8a, 0x11, 0xf4, 0xe4, 0x4a, 0x11, 0x88, 0x11,
+	0xf4, 0x95, 0xf4, 0x95, 0x71, 0xe1, 0x00, 0x05,
+	0x00, 0x12, 0xee, 0xff, 0x76, 0x82, 0x00, 0x00,
+	0xee, 0x01, 0x71, 0xe1, 0x00, 0x06, 0x00, 0x11,
+	0x69, 0x81, 0x00, 0x01, 0x8a, 0x11, 0xf4, 0x95,
+	0xf4, 0xe4, 0x4a, 0x11, 0x88, 0x11, 0xf4, 0x95,
+	0xf4, 0x95, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12,
+	0xee, 0xff, 0x76, 0x82, 0x00, 0x01, 0xee, 0x01,
+	0x71, 0xe1, 0x00, 0x06, 0x00, 0x11, 0x69, 0x81,
+	0x00, 0x01, 0x8a, 0x11, 0xf4, 0x95, 0xf4, 0xe4,
+	0x4a, 0x11, 0x77, 0x11, 0x00, 0x7b, 0x10, 0x81,
+	0xf0, 0x00, 0x00, 0x94, 0x88, 0x11, 0xf4, 0x95,
+	0xf4, 0x95, 0x10, 0x81, 0xfa, 0x44, 0x17, 0x9c,
+	0xf4, 0x95, 0xee, 0xff, 0xf9, 0x80, 0x16, 0x53,
+	0x77, 0x11, 0x00, 0x7b, 0x10, 0x81, 0xf0, 0x00,
+	0x00, 0x94, 0x88, 0x11, 0xf4, 0x95, 0xf4, 0x95,
+	0x76, 0x81, 0x00, 0x01, 0xee, 0x01, 0x76, 0xe1,
+	0x00, 0x01, 0x00, 0x00, 0x76, 0xe1, 0x00, 0x02,
+	0x00, 0x21, 0x76, 0xe1, 0x00, 0x03, 0x00, 0x20,
+	0x76, 0xe1, 0x00, 0x04, 0x00, 0x23, 0x76, 0xe1,
+	0x00, 0x05, 0x00, 0x22, 0x76, 0xe1, 0x00, 0x06,
+	0x00, 0x38, 0x76, 0xe1, 0x00, 0x07, 0x00, 0x39,
+	0x76, 0xe1, 0x00, 0x08, 0x00, 0x15, 0x76, 0xe1,
+	0x00, 0x09, 0x00, 0x14, 0x76, 0xe1, 0x00, 0x0a,
+	0x00, 0x00, 0x76, 0xe1, 0x00, 0x0b, 0x00, 0x41,
+	0x76, 0xe1, 0x00, 0x0c, 0x00, 0x40, 0x76, 0xe1,
+	0x00, 0x0d, 0x00, 0x43, 0x76, 0xe1, 0x00, 0x0e,
+	0x00, 0x42, 0x76, 0xe1, 0x00, 0x0f, 0x00, 0x48,
+	0x76, 0xe1, 0x00, 0x10, 0x00, 0x49, 0x76, 0xe1,
+	0x00, 0x11, 0x00, 0x1b, 0x76, 0xe1, 0x00, 0x12,
+	0x00, 0x1a, 0x8a, 0x11, 0xf4, 0x95, 0xf4, 0xe4,
+	0x4a, 0x11, 0xee, 0xfd, 0x88, 0x11, 0x56, 0x06,
+	0x4e, 0x00, 0xf9, 0x80, 0x16, 0xa2, 0x77, 0x12,
+	0x00, 0x7b, 0x77, 0x0e, 0x00, 0x09, 0x10, 0x82,
+	0x28, 0xf8, 0x00, 0x11, 0xf0, 0x00, 0x00, 0x95,
+	0x88, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x10, 0x81,
+	0xf8, 0x45, 0x17, 0xf0, 0xf2, 0x73, 0x17, 0xfd,
+	0x77, 0x11, 0xff, 0xff, 0x76, 0x81, 0x00, 0x01,
+	0xe9, 0x01, 0x56, 0x00, 0xf1, 0x80, 0x10, 0xf8,
+	0x00, 0x0b, 0xf8, 0x45, 0x17, 0xfd, 0xfb, 0x80,
+	0x18, 0x10, 0xf4, 0x95, 0x48, 0x11, 0xf9, 0x80,
+	0x16, 0x9a, 0xee, 0x03, 0x48, 0x11, 0x8a, 0x11,
+	0xf4, 0x95, 0xf4, 0xe4, 0x4a, 0x11, 0x88, 0x11,
+	0xf4, 0x95, 0xee, 0xff, 0x71, 0xe1, 0x00, 0x01,
+	0x00, 0x11, 0xee, 0x01, 0x10, 0x81, 0x8a, 0x11,
+	0xf4, 0x95, 0xf4, 0xe4, 0x4a, 0x11, 0xee, 0xff,
+	0xfb, 0x80, 0x16, 0xa2, 0x88, 0x11, 0xf4, 0x95,
+	0x77, 0x10, 0xff, 0xff, 0xf4, 0xa9, 0xf8, 0x30,
+	0x18, 0xc3, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12,
+	0x76, 0x82, 0x00, 0x00, 0x71, 0xe1, 0x00, 0x06,
+	0x00, 0x12, 0x76, 0x82, 0x00, 0x00, 0x71, 0xe1,
+	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x01,
+	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x76, 0x82,
+	0x00, 0x00, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12,
+	0x76, 0x82, 0x00, 0x02, 0x71, 0xe1, 0x00, 0x06,
+	0x00, 0x12, 0x76, 0x82, 0x00, 0x00, 0x71, 0xe1,
+	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x03,
+	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x76, 0x82,
+	0x00, 0x00, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12,
+	0x76, 0x82, 0x00, 0x04, 0x71, 0xe1, 0x00, 0x06,
+	0x00, 0x12, 0x76, 0x82, 0x00, 0x00, 0x71, 0xe1,
+	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x05,
+	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x76, 0x82,
+	0x00, 0x00, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12,
+	0x76, 0x82, 0x00, 0x06, 0x71, 0xe1, 0x00, 0x06,
+	0x00, 0x12, 0x76, 0x82, 0x00, 0x01, 0x71, 0xe1,
+	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x07,
+	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x76, 0x82,
+	0x20, 0x00, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12,
+	0x76, 0x82, 0x00, 0x08, 0x71, 0xe1, 0x00, 0x06,
+	0x00, 0x12, 0x76, 0x82, 0x00, 0x00, 0x71, 0xe1,
+	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x09,
+	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x76, 0x82,
+	0x00, 0x00, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12,
+	0x76, 0x82, 0x00, 0x0a, 0x71, 0xe1, 0x00, 0x06,
+	0x00, 0x12, 0x76, 0x82, 0x00, 0x00, 0x71, 0xe1,
+	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x0b,
+	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x76, 0x82,
+	0x00, 0x00, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12,
+	0x76, 0x82, 0x00, 0x0c, 0x71, 0xe1, 0x00, 0x06,
+	0x00, 0x12, 0x76, 0x82, 0x00, 0x00, 0x71, 0xe1,
+	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x0d,
+	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x76, 0x82,
+	0x00, 0x00, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12,
+	0x76, 0x82, 0x00, 0x0e, 0x71, 0xe1, 0x00, 0x06,
+	0x00, 0x12, 0x76, 0x82, 0x00, 0x00, 0x10, 0xe1,
+	0x00, 0x07, 0xf9, 0x80, 0x16, 0x76, 0x10, 0xe1,
+	0x00, 0x08, 0xf9, 0x80, 0x16, 0x76, 0x10, 0xe1,
+	0x00, 0x07, 0xf9, 0x80, 0x16, 0x66, 0x10, 0xe1,
+	0x00, 0x08, 0xf9, 0x80, 0x16, 0x66, 0xf0, 0x73,
+	0x18, 0xd1, 0x77, 0x11, 0x00, 0x7b, 0x10, 0x81,
+	0xfb, 0x80, 0x18, 0x10, 0xf0, 0x00, 0x00, 0x95,
+	0x77, 0x11, 0x00, 0x7b, 0x10, 0x81, 0xfb, 0x80,
+	0x18, 0x10, 0xf0, 0x00, 0x00, 0x9e, 0xf9, 0x80,
+	0x16, 0x9a, 0xee, 0x01, 0x8a, 0x11, 0xf4, 0xe4,
+	0x4a, 0x11, 0x88, 0x11, 0xee, 0xff, 0xf4, 0x95,
+	0x10, 0x04, 0x71, 0xe1, 0x00, 0x03, 0x00, 0x11,
+	0xee, 0x01, 0x80, 0x81, 0x8a, 0x11, 0xf4, 0x95,
+	0xf4, 0xe4, 0x4a, 0x11, 0x4a, 0x16, 0xf4, 0x95,
+	0x71, 0x04, 0x00, 0x16, 0xfb, 0x80, 0x16, 0xa2,
+	0x88, 0x11, 0xf4, 0x95, 0x71, 0xe1, 0x00, 0x02,
+	0x00, 0x12, 0x76, 0x82, 0x00, 0x10, 0x10, 0xe6,
+	0x00, 0x01, 0x71, 0xe1, 0x00, 0x03, 0x00, 0x12,
+	0x80, 0x82, 0x71, 0xe1, 0x00, 0x04, 0x00, 0x12,
+	0x10, 0xe6, 0x00, 0x02, 0x80, 0x82, 0xe7, 0x62,
+	0x71, 0xe1, 0x00, 0x02, 0x00, 0x13, 0xe5, 0x01,
+	0xf9, 0x80, 0x16, 0x9a, 0x8a, 0x16, 0x8a, 0x11,
+	0xf4, 0xe4, 0x4a, 0x11, 0x88, 0x11, 0xee, 0xff,
+	0xee, 0x01, 0x10, 0xe1, 0x00, 0x01, 0x8a, 0x11,
+	0xf4, 0x95, 0xf4, 0xe4, 0x4a, 0x11, 0x77, 0x11,
+	0x00, 0x7b, 0x10, 0x81, 0xf0, 0x00, 0x00, 0xb3,
+	0x88, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x10, 0x81,
+	0xfa, 0x44, 0x19, 0x2a, 0xf4, 0x95, 0xee, 0xff,
+	0xf9, 0x80, 0x16, 0x53, 0x77, 0x11, 0x00, 0x7b,
+	0x10, 0x81, 0xf0, 0x00, 0x00, 0xb3, 0x88, 0x11,
+	0xf4, 0x95, 0xf4, 0x95, 0x76, 0x81, 0x00, 0x01,
+	0xee, 0x01, 0x76, 0xe1, 0x00, 0x01, 0x00, 0x00,
+	0x76, 0xe1, 0x00, 0x02, 0x00, 0x13, 0x76, 0xe1,
+	0x00, 0x03, 0x00, 0x26, 0x76, 0xe1, 0x00, 0x04,
+	0x00, 0x25, 0x76, 0xe1, 0x00, 0x05, 0x00, 0x24,
+	0x76, 0xe1, 0x00, 0x06, 0x00, 0x00, 0x76, 0xe1,
+	0x00, 0x07, 0x00, 0x17, 0x76, 0xe1, 0x00, 0x08,
+	0x00, 0x32, 0x76, 0xe1, 0x00, 0x09, 0x00, 0x31,
+	0x76, 0xe1, 0x00, 0x0a, 0x00, 0x30, 0x8a, 0x11,
+	0xf4, 0x95, 0xf4, 0xe4, 0x4a, 0x11, 0x4a, 0x16,
+	0x4a, 0x17, 0xee, 0xff, 0xf4, 0x95, 0x71, 0x06,
+	0x00, 0x17, 0xfb, 0x80, 0x16, 0xa2, 0x88, 0x11,
+	0xf4, 0x95, 0xf7, 0xb8, 0x10, 0xf8, 0x00, 0x11,
+	0xf0, 0x10, 0xff, 0xff, 0xfa, 0x45, 0x19, 0x73,
+	0x77, 0x16, 0xff, 0xff, 0x77, 0x12, 0x00, 0x7b,
+	0x77, 0x0e, 0x00, 0x05, 0x10, 0x82, 0x28, 0xf8,
+	0x00, 0x11, 0xf0, 0x00, 0x00, 0xb4, 0x88, 0x11,
+	0xf4, 0x95, 0xf4, 0x95, 0x10, 0x81, 0xf8, 0x44,
+	0x19, 0x84, 0xf2, 0x73, 0x19, 0x84, 0xf4, 0x95,
+	0xe7, 0x16, 0x77, 0x11, 0x00, 0x7b, 0x10, 0x81,
+	0xf0, 0x00, 0x00, 0xb4, 0x88, 0x11, 0xf4, 0x95,
+	0x77, 0x12, 0x00, 0x02, 0x10, 0x81, 0xf8, 0x45,
+	0x19, 0x6f, 0x6e, 0xea, 0xff, 0xff, 0x19, 0x7c,
+	0x6d, 0xe9, 0x00, 0x05, 0x61, 0xf8, 0x00, 0x17,
+	0x00, 0x01, 0xfa, 0x20, 0x19, 0x8f, 0x76, 0x86,
+	0x00, 0x01, 0xfb, 0x80, 0x19, 0x97, 0xf4, 0x95,
+	0x48, 0x16, 0xf9, 0x80, 0x16, 0x9a, 0xee, 0x01,
+	0x8a, 0x17, 0x48, 0x16, 0x8a, 0x16, 0x8a, 0x11,
+	0xf4, 0xe4, 0x4a, 0x11, 0xee, 0xff, 0xfb, 0x80,
+	0x16, 0xa2, 0x88, 0x11, 0xf4, 0x95, 0x77, 0x10,
+	0xff, 0xff, 0xf4, 0xa9, 0xf8, 0x30, 0x19, 0xcc,
+	0x71, 0xe1, 0x00, 0x02, 0x00, 0x12, 0x69, 0x82,
+	0x00, 0x10, 0x71, 0xe1, 0x00, 0x02, 0x00, 0x12,
+	0x68, 0x82, 0xf7, 0xff, 0x71, 0xe1, 0x00, 0x02,
+	0x00, 0x12, 0x68, 0x82, 0xfb, 0xff, 0x71, 0xe1,
+	0x00, 0x02, 0x00, 0x12, 0x68, 0x82, 0xff, 0xf0,
+	0x71, 0xe1, 0x00, 0x03, 0x00, 0x12, 0x76, 0x82,
+	0xff, 0xff, 0x71, 0xe1, 0x00, 0x04, 0x00, 0x12,
+	0x76, 0x82, 0xff, 0xff, 0x71, 0xe1, 0x00, 0x02,
+	0x00, 0x12, 0x69, 0x82, 0x00, 0x20, 0x71, 0xe1,
+	0x00, 0x02, 0x00, 0x11, 0xf2, 0x73, 0x19, 0xda,
+	0x68, 0x81, 0xff, 0xef, 0x77, 0x11, 0x00, 0x7b,
+	0x10, 0x81, 0xfb, 0x80, 0x19, 0x97, 0xf0, 0x00,
+	0x00, 0xb4, 0x77, 0x11, 0x00, 0x7b, 0x10, 0x81,
+	0xfb, 0x80, 0x19, 0x97, 0xf0, 0x00, 0x00, 0xb9,
+	0xf9, 0x80, 0x16, 0x9a, 0xee, 0x01, 0x8a, 0x11,
+	0xf4, 0xe4, 0x00, 0xa4, 0x00, 0x00, 0x19, 0xdf,
+	0x00, 0x01, 0x2a, 0xe6, 0x00, 0x00, 0x00, 0x01,
+	0x2a, 0xe7, 0x00, 0x00, 0x00, 0x03, 0x2a, 0x12,
+	0x0c, 0x01, 0xc3, 0x4f, 0x00, 0x00, 0x00, 0x01,
+	0x2a, 0x15, 0x00, 0x00, 0x00, 0x02, 0x2a, 0x16,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x2a, 0x5d,
+	0x00, 0x43, 0x00, 0x6f, 0x00, 0x70, 0x00, 0x79,
+	0x00, 0x72, 0x00, 0x69, 0x00, 0x67, 0x00, 0x68,
+	0x00, 0x74, 0x00, 0x20, 0x00, 0x54, 0x00, 0x65,
+	0x00, 0x63, 0x00, 0x68, 0x00, 0x6e, 0x00, 0x6f,
+	0x00, 0x54, 0x00, 0x72, 0x00, 0x65, 0x00, 0x6e,
+	0x00, 0x64, 0x00, 0x20, 0x00, 0x41, 0x00, 0x47,
+	0x00, 0x00, 0x00, 0x04, 0x2a, 0x76, 0x00, 0x30,
+	0x00, 0x2e, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0c,
+	0x2a, 0x7a, 0x00, 0x46, 0x00, 0x65, 0x00, 0x62,
+	0x00, 0x20, 0x00, 0x32, 0x00, 0x37, 0x00, 0x20,
+	0x00, 0x32, 0x00, 0x30, 0x00, 0x30, 0x00, 0x31,
+	0x00, 0x00, 0x00, 0x09, 0x2a, 0x86, 0x00, 0x31,
+	0x00, 0x34, 0x00, 0x3a, 0x00, 0x33, 0x00, 0x35,
+	0x00, 0x3a, 0x00, 0x33, 0x00, 0x33, 0x00, 0x00,
+	0x00, 0x0f, 0x2a, 0x8f, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x01, 0x2a, 0x9e, 0x00, 0x00,
+	0x00, 0x01, 0x2a, 0x9f, 0x00, 0x00, 0x00, 0x01,
+	0x2a, 0xa0, 0x00, 0x00, 0x00, 0x01, 0x2a, 0xa1,
+	0x00, 0x00, 0x00, 0x01, 0x2a, 0xa2, 0x00, 0x00,
+	0x00, 0x01, 0x29, 0x7e, 0x00, 0x00, 0x00, 0x02,
+	0x29, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
+	0x29, 0x82, 0xff, 0xff, 0x00, 0x01, 0x2a, 0xa7,
+	0x00, 0x00, 0x00, 0x05, 0x2a, 0xa8, 0x71, 0x41,
+	0x20, 0x00, 0x20, 0x00, 0x00, 0x23, 0x04, 0x00,
+	0x00, 0x0a, 0x2a, 0xad, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x0f, 0x2a, 0xb7, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x40, 0x00, 0xa0, 0x82, 0x40,
+	0x00, 0x08, 0x30, 0x7f, 0x00, 0x80, 0x01, 0x80,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x01, 0x27, 0x6e, 0x00, 0x00,
+	0x00, 0x01, 0x27, 0x6f, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x09, 0x00, 0x00, 0x1a, 0x83, 0x04, 0xe8,
+	0x04, 0xcf, 0x04, 0xc5, 0x04, 0xba, 0x04, 0xb0,
+	0x04, 0xac, 0x04, 0x9c, 0x04, 0x8c, 0x04, 0x81,
+	0x00, 0x78, 0x00, 0x00, 0x01, 0x00, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xaa, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x02, 0x23, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x05, 0xe5, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x02, 0xb5, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x0e, 0x33, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0x00, 0x00,
 };
 
diff --git a/drivers/media/dvb/ttusb-dec/ttusb_dec.c b/drivers/media/dvb/ttusb-dec/ttusb_dec.c
index 832d179..8abc218 100644
--- a/drivers/media/dvb/ttusb-dec/ttusb_dec.c
+++ b/drivers/media/dvb/ttusb-dec/ttusb_dec.c
@@ -1203,7 +1203,7 @@ static int ttusb_init_rc(struct ttusb_de
 	input_dev->keycode = rc_keys;
 
 	for (i = 0; i < ARRAY_SIZE(rc_keys); i++)
-                set_bit(rc_keys[i], input_dev->keybit);
+		set_bit(rc_keys[i], input_dev->keybit);
 
 	input_register_device(input_dev);
 
@@ -1529,7 +1529,7 @@ static void ttusb_dec_exit_rc(struct ttu
 	usb_free_urb(dec->irq_urb);
 
 	usb_buffer_free(dec->udev,IRQ_PACKET_SIZE,
-		           dec->irq_buffer, dec->irq_dma_handle);
+			   dec->irq_buffer, dec->irq_dma_handle);
 
 	if (dec->rc_input_dev) {
 		input_unregister_device(dec->rc_input_dev);
diff --git a/drivers/media/video/Kconfig b/drivers/media/video/Kconfig
index cc4a723..fc87efc 100644
--- a/drivers/media/video/Kconfig
+++ b/drivers/media/video/Kconfig
@@ -188,7 +188,7 @@ config VIDEO_ZORAN
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called zr36067.
- 
+
 config VIDEO_ZORAN_BUZ
 	tristate "Iomega Buz support"
 	depends on VIDEO_ZORAN
@@ -204,8 +204,8 @@ config VIDEO_ZORAN_DC10
 
 config VIDEO_ZORAN_DC30
 	tristate "Pinnacle/Miro DC30(+) support"
- 	depends on VIDEO_ZORAN
- 	help
+	depends on VIDEO_ZORAN
+	help
 	  Support for the Pinnacle/Miro DC30(+) MJPEG capture/playback
 	  card. This also supports really old DC10 cards based on the
 	  zr36050 MJPEG codec and zr36016 VFE.
@@ -260,7 +260,7 @@ config VIDEO_MXB
 	---help---
 	  This is a video4linux driver for the 'Multimedia eXtension Board'
 	  TV card by Siemens-Nixdorf.
-	  
+
 	  To compile this driver as a module, choose M here: the
 	  module will be called mxb.
 
@@ -274,7 +274,7 @@ config VIDEO_DPC
 	  for SAA7146 bases boards, so if you have some unsupported
 	  saa7146 based, analog video card, chances are good that it
 	  will work with this skeleton driver.
-	  
+
 	  To compile this driver as a module, choose M here: the
 	  module will be called dpc7146.
 
@@ -285,7 +285,7 @@ config VIDEO_HEXIUM_ORION
 	---help---
 	  This is a video4linux driver for the Hexium HV-PCI6 and
 	  Orion frame grabber cards by Hexium.
-	  
+
 	  To compile this driver as a module, choose M here: the
 	  module will be called hexium_orion.
 
@@ -297,7 +297,7 @@ config VIDEO_HEXIUM_GEMINI
 	  This is a video4linux driver for the Hexium Gemini frame
 	  grabber card by Hexium. Please note that the Gemini Dual
 	  card is *not* fully supported.
-	  
+
 	  To compile this driver as a module, choose M here: the
 	  module will be called hexium_gemini.
 
diff --git a/drivers/media/video/bt832.c b/drivers/media/video/bt832.c
index e406395..3ca1d76 100644
--- a/drivers/media/video/bt832.c
+++ b/drivers/media/video/bt832.c
@@ -231,18 +231,18 @@ bt832_command(struct i2c_client *client,
 
 static struct i2c_driver driver = {
 	.owner          = THIS_MODULE,
-        .name           = "i2c bt832 driver",
-        .id             = -1, /* FIXME */
-        .flags          = I2C_DF_NOTIFY,
-        .attach_adapter = bt832_probe,
-        .detach_client  = bt832_detach,
-        .command        = bt832_command,
+	.name           = "i2c bt832 driver",
+	.id             = -1, /* FIXME */
+	.flags          = I2C_DF_NOTIFY,
+	.attach_adapter = bt832_probe,
+	.detach_client  = bt832_detach,
+	.command        = bt832_command,
 };
 static struct i2c_client client_template =
 {
 	.name       = "bt832",
 	.flags      = I2C_CLIENT_ALLOW_USE,
-        .driver     = &driver,
+	.driver     = &driver,
 };
 
 
diff --git a/drivers/media/video/bttv-driver.c b/drivers/media/video/bttv-driver.c
index 3c58a2a..1ddf9ba 100644
--- a/drivers/media/video/bttv-driver.c
+++ b/drivers/media/video/bttv-driver.c
@@ -727,71 +727,71 @@ void free_btres(struct bttv *btv, struct
 
 static void set_pll_freq(struct bttv *btv, unsigned int fin, unsigned int fout)
 {
-        unsigned char fl, fh, fi;
+	unsigned char fl, fh, fi;
 
-        /* prevent overflows */
-        fin/=4;
-        fout/=4;
+	/* prevent overflows */
+	fin/=4;
+	fout/=4;
 
-        fout*=12;
-        fi=fout/fin;
+	fout*=12;
+	fi=fout/fin;
 
-        fout=(fout%fin)*256;
-        fh=fout/fin;
+	fout=(fout%fin)*256;
+	fh=fout/fin;
 
-        fout=(fout%fin)*256;
-        fl=fout/fin;
+	fout=(fout%fin)*256;
+	fl=fout/fin;
 
-        btwrite(fl, BT848_PLL_F_LO);
-        btwrite(fh, BT848_PLL_F_HI);
-        btwrite(fi|BT848_PLL_X, BT848_PLL_XCI);
+	btwrite(fl, BT848_PLL_F_LO);
+	btwrite(fh, BT848_PLL_F_HI);
+	btwrite(fi|BT848_PLL_X, BT848_PLL_XCI);
 }
 
 static void set_pll(struct bttv *btv)
 {
-        int i;
+	int i;
 
-        if (!btv->pll.pll_crystal)
-                return;
+	if (!btv->pll.pll_crystal)
+		return;
 
 	if (btv->pll.pll_ofreq == btv->pll.pll_current) {
 		dprintk("bttv%d: PLL: no change required\n",btv->c.nr);
-                return;
-        }
+		return;
+	}
 
-        if (btv->pll.pll_ifreq == btv->pll.pll_ofreq) {
-                /* no PLL needed */
-                if (btv->pll.pll_current == 0)
-                        return;
+	if (btv->pll.pll_ifreq == btv->pll.pll_ofreq) {
+		/* no PLL needed */
+		if (btv->pll.pll_current == 0)
+			return;
 		bttv_printk(KERN_INFO "bttv%d: PLL can sleep, using XTAL (%d).\n",
-                           btv->c.nr,btv->pll.pll_ifreq);
-                btwrite(0x00,BT848_TGCTRL);
-                btwrite(0x00,BT848_PLL_XCI);
-                btv->pll.pll_current = 0;
-                return;
-        }
+			btv->c.nr,btv->pll.pll_ifreq);
+		btwrite(0x00,BT848_TGCTRL);
+		btwrite(0x00,BT848_PLL_XCI);
+		btv->pll.pll_current = 0;
+		return;
+	}
 
 	bttv_printk(KERN_INFO "bttv%d: PLL: %d => %d ",btv->c.nr,
-                   btv->pll.pll_ifreq, btv->pll.pll_ofreq);
+		btv->pll.pll_ifreq, btv->pll.pll_ofreq);
 	set_pll_freq(btv, btv->pll.pll_ifreq, btv->pll.pll_ofreq);
 
-        for (i=0; i<10; i++) {
+	for (i=0; i<10; i++) {
 		/*  Let other people run while the PLL stabilizes */
 		bttv_printk(".");
 		msleep(10);
 
-                if (btread(BT848_DSTATUS) & BT848_DSTATUS_PLOCK) {
+		if (btread(BT848_DSTATUS) & BT848_DSTATUS_PLOCK) {
 			btwrite(0,BT848_DSTATUS);
-                } else {
-                        btwrite(0x08,BT848_TGCTRL);
-                        btv->pll.pll_current = btv->pll.pll_ofreq;
+		} else {
+			btwrite(0x08,BT848_TGCTRL);
+			btv->pll.pll_current = btv->pll.pll_ofreq;
 			bttv_printk(" ok\n");
-                        return;
-                }
-        }
-        btv->pll.pll_current = -1;
+			return;
+		}
+	}
+	btv->pll.pll_current = -1;
 	bttv_printk("failed\n");
-        return;
+	return;
 }
 
 /* used to switch between the bt848's analog/digital video capture modes */
@@ -1964,7 +1964,7 @@ static int setup_window(struct bttv_fh *
 	}
 
 	down(&fh->cap.lock);
-	kfree(fh->ov.clips);
+		kfree(fh->ov.clips);
 	fh->ov.clips    = clips;
 	fh->ov.nclips   = n;
 
@@ -2758,7 +2758,7 @@ static int bttv_do_ioctl(struct inode *i
 			fh->ov.w.height = fb->fmt.height;
 			btv->init.ov.w.width  = fb->fmt.width;
 			btv->init.ov.w.height = fb->fmt.height;
-			kfree(fh->ov.clips);
+				kfree(fh->ov.clips);
 			fh->ov.clips = NULL;
 			fh->ov.nclips = 0;
 
diff --git a/drivers/media/video/bttvp.h b/drivers/media/video/bttvp.h
index 3aa9c6e..1e6a563 100644
--- a/drivers/media/video/bttvp.h
+++ b/drivers/media/video/bttvp.h
@@ -45,6 +45,7 @@
 #include <media/tveeprom.h>
 #include <media/ir-common.h>
 
+
 #include "bt848.h"
 #include "bttv.h"
 #include "btcx-risc.h"
diff --git a/drivers/media/video/cx88/cx88-blackbird.c b/drivers/media/video/cx88/cx88-blackbird.c
index 4ae3f78..74e57a5 100644
--- a/drivers/media/video/cx88/cx88-blackbird.c
+++ b/drivers/media/video/cx88/cx88-blackbird.c
@@ -616,6 +616,8 @@ static int blackbird_load_firmware(struc
 
 	retval = request_firmware(&firmware, BLACKBIRD_FIRM_ENC_FILENAME,
 				  &dev->pci->dev);
+
+
 	if (retval != 0) {
 		dprintk(0, "ERROR: Hotplug firmware request failed (%s).\n",
 			BLACKBIRD_FIRM_ENC_FILENAME);
diff --git a/drivers/media/video/cx88/cx88-cards.c b/drivers/media/video/cx88/cx88-cards.c
index 2465166..951709a 100644
--- a/drivers/media/video/cx88/cx88-cards.c
+++ b/drivers/media/video/cx88/cx88-cards.c
@@ -567,6 +567,7 @@ struct cx88_board cx88_boards[] = {
 		.radio_type     = UNSET,
 		.tuner_addr	= ADDR_UNSET,
 		.radio_addr	= ADDR_UNSET,
+		.tda9887_conf   = TDA9887_PRESENT,
 		.input          = {{
 			.type   = CX88_VMUX_TELEVISION,
 			.vmux   = 0,
@@ -711,6 +712,7 @@ struct cx88_board cx88_boards[] = {
 		.radio_type     = UNSET,
 		.tuner_addr	= ADDR_UNSET,
 		.radio_addr	= ADDR_UNSET,
+		.tda9887_conf   = TDA9887_PRESENT,
 		.input          = {{
 			.type   = CX88_VMUX_TELEVISION,
 			.vmux   = 0,
diff --git a/drivers/media/video/cx88/cx88-input.c b/drivers/media/video/cx88/cx88-input.c
index 38b12eb..461019d 100644
--- a/drivers/media/video/cx88/cx88-input.c
+++ b/drivers/media/video/cx88/cx88-input.c
@@ -453,7 +453,6 @@ int cx88_ir_init(struct cx88_core *core,
 		input_dev->id.product = pci->device;
 	}
 	input_dev->cdev.dev = &pci->dev;
-
 	/* record handles to ourself */
 	ir->core = core;
 	core->ir = ir;
@@ -586,7 +585,6 @@ void cx88_ir_irq(struct cx88_core *core)
 MODULE_AUTHOR("Gerd Knorr, Pavel Machek, Chris Pascoe");
 MODULE_DESCRIPTION("input driver for cx88 GPIO-based IR remote controls");
 MODULE_LICENSE("GPL");
-
 /*
  * Local variables:
  * c-basic-offset: 8
diff --git a/drivers/media/video/cx88/cx88.h b/drivers/media/video/cx88/cx88.h
index 27fb080..77beafc 100644
--- a/drivers/media/video/cx88/cx88.h
+++ b/drivers/media/video/cx88/cx88.h
@@ -411,7 +411,6 @@ struct cx8802_dev {
 	struct videobuf_dvb        dvb;
 	void*                      fe_handle;
 	int                        (*fe_release)(void *handle);
-
 	/* for switching modulation types */
 	unsigned char              ts_gen_cntrl;
 
diff --git a/drivers/media/video/em28xx/em28xx-core.c b/drivers/media/video/em28xx/em28xx-core.c
index 9f6e5e5..e8a1c22 100644
--- a/drivers/media/video/em28xx/em28xx-core.c
+++ b/drivers/media/video/em28xx/em28xx-core.c
@@ -39,7 +39,7 @@ MODULE_PARM_DESC(core_debug,"enable debu
 #define em28xx_coredbg(fmt, arg...) do {\
 	if (core_debug) \
 		printk(KERN_INFO "%s %s :"fmt, \
-			 dev->name, __FUNCTION__ , ##arg); } while (0)
+			 dev->name, __FUNCTION__, ##arg); } while (0)
 
 static unsigned int reg_debug;
 module_param(reg_debug,int,0644);
@@ -48,7 +48,7 @@ MODULE_PARM_DESC(reg_debug,"enable debug
 #define em28xx_regdbg(fmt, arg...) do {\
 	if (reg_debug) \
 		printk(KERN_INFO "%s %s :"fmt, \
-			 dev->name, __FUNCTION__ , ##arg); } while (0)
+			 dev->name, __FUNCTION__, ##arg); } while (0)
 
 static unsigned int isoc_debug;
 module_param(isoc_debug,int,0644);
@@ -57,7 +57,7 @@ MODULE_PARM_DESC(isoc_debug,"enable debu
 #define em28xx_isocdbg(fmt, arg...) do {\
 	if (isoc_debug) \
 		printk(KERN_INFO "%s %s :"fmt, \
-			 dev->name, __FUNCTION__ , ##arg); } while (0)
+			 dev->name, __FUNCTION__, ##arg); } while (0)
 
 static int alt = EM28XX_PINOUT;
 module_param(alt, int, 0644);
@@ -116,47 +116,6 @@ void em28xx_print_ioctl(char *name, unsi
 	}
 }
 
-static void *rvmalloc(size_t size)
-{
-	void *mem;
-	unsigned long adr;
-
-	size = PAGE_ALIGN(size);
-
-	mem = vmalloc_32((unsigned long)size);
-	if (!mem)
-		return NULL;
-
-	memset(mem, 0, size);
-
-	adr = (unsigned long)mem;
-	while (size > 0) {
-		SetPageReserved(vmalloc_to_page((void *)adr));
-		adr += PAGE_SIZE;
-		size -= PAGE_SIZE;
-	}
-
-	return mem;
-}
-
-static void rvfree(void *mem, size_t size)
-{
-	unsigned long adr;
-
-	if (!mem)
-		return;
-
-	size = PAGE_ALIGN(size);
-
-	adr = (unsigned long)mem;
-	while (size > 0) {
-		ClearPageReserved(vmalloc_to_page((void *)adr));
-		adr += PAGE_SIZE;
-		size -= PAGE_SIZE;
-	}
-
-	vfree(mem);
-}
 
 /*
  * em28xx_request_buffers()
@@ -173,8 +132,10 @@ u32 em28xx_request_buffers(struct em28xx
 
 	dev->num_frames = count;
 	while (dev->num_frames > 0) {
-		if ((buff = rvmalloc(dev->num_frames * imagesize)))
+		if ((buff = vmalloc_32(dev->num_frames * imagesize))) {
+			memset(buff, 0, dev->num_frames * imagesize);
 			break;
+		}
 		dev->num_frames--;
 	}
 
@@ -217,8 +178,7 @@ void em28xx_queue_unusedframes(struct em
 void em28xx_release_buffers(struct em28xx *dev)
 {
 	if (dev->num_frames) {
-		rvfree(dev->frame[0].bufmem,
-		       dev->num_frames * PAGE_ALIGN(dev->frame[0].buf.length));
+		vfree(dev->frame[0].bufmem);
 		dev->num_frames = 0;
 	}
 }
diff --git a/drivers/media/video/em28xx/em28xx-i2c.c b/drivers/media/video/em28xx/em28xx-i2c.c
index b32d985..29e21ad 100644
--- a/drivers/media/video/em28xx/em28xx-i2c.c
+++ b/drivers/media/video/em28xx/em28xx-i2c.c
@@ -41,10 +41,10 @@ module_param(i2c_debug, int, 0644);
 MODULE_PARM_DESC(i2c_debug, "enable debug messages [i2c]");
 
 #define dprintk1(lvl,fmt, args...) if (i2c_debug>=lvl) do {\
-			printk(fmt , ##args); } while (0)
+			printk(fmt, ##args); } while (0)
 #define dprintk2(lvl,fmt, args...) if (i2c_debug>=lvl) do{ \
 			printk(KERN_DEBUG "%s at %s: " fmt, \
-			dev->name, __FUNCTION__ , ##args); } while (0)
+			dev->name, __FUNCTION__, ##args); } while (0)
 
 /*
  * em2800_i2c_send_max4()
diff --git a/drivers/media/video/em28xx/em28xx-video.c b/drivers/media/video/em28xx/em28xx-video.c
index abec32c..8ecaa08 100644
--- a/drivers/media/video/em28xx/em28xx-video.c
+++ b/drivers/media/video/em28xx/em28xx-video.c
@@ -45,7 +45,7 @@
 #define em28xx_videodbg(fmt, arg...) do {\
 	if (video_debug) \
 		printk(KERN_INFO "%s %s :"fmt, \
-			 dev->name, __FUNCTION__ , ##arg); } while (0)
+			 dev->name, __FUNCTION__, ##arg); } while (0)
 
 MODULE_AUTHOR(DRIVER_AUTHOR);
 MODULE_DESCRIPTION(DRIVER_DESC);
@@ -189,16 +189,6 @@ static DECLARE_RWSEM(em28xx_disconnect);
 
 /*********************  v4l2 interface  ******************************************/
 
-static inline unsigned long kvirt_to_pa(unsigned long adr)
-{
-	unsigned long kva, ret;
-
-	kva = (unsigned long)page_address(vmalloc_to_page((void *)adr));
-	kva |= adr & (PAGE_SIZE - 1);
-	ret = __pa(kva);
-	return ret;
-}
-
 /*
  * em28xx_config()
  * inits registers with sane defaults
@@ -616,7 +606,8 @@ static struct vm_operations_struct em28x
 static int em28xx_v4l2_mmap(struct file *filp, struct vm_area_struct *vma)
 {
 	unsigned long size = vma->vm_end - vma->vm_start,
-	    start = vma->vm_start, pos, page;
+	    start = vma->vm_start;
+	void *pos;
 	u32 i;
 
 	struct em28xx *dev = filp->private_data;
@@ -657,12 +648,10 @@ static int em28xx_v4l2_mmap(struct file 
 	vma->vm_flags |= VM_IO;
 	vma->vm_flags |= VM_RESERVED;	/* avoid to swap out this VMA */
 
-	pos = (unsigned long)dev->frame[i].bufmem;
+	pos = dev->frame[i].bufmem;
 	while (size > 0) {	/* size is page-aligned */
-		page = vmalloc_to_pfn((void *)pos);
-		if (remap_pfn_range(vma, start, page, PAGE_SIZE,
-				    vma->vm_page_prot)) {
-			em28xx_videodbg("mmap: rename page map failed\n");
+		if (vm_insert_page(vma, start, vmalloc_to_page(pos))) {
+			em28xx_videodbg("mmap: vm_insert_page failed\n");
 			up(&dev->fileop_lock);
 			return -EAGAIN;
 		}
diff --git a/drivers/media/video/em28xx/em28xx.h b/drivers/media/video/em28xx/em28xx.h
index 5c7a41c..1e2ee43 100644
--- a/drivers/media/video/em28xx/em28xx.h
+++ b/drivers/media/video/em28xx/em28xx.h
@@ -392,18 +392,18 @@ extern const unsigned int em28xx_bcount;
 /* printk macros */
 
 #define em28xx_err(fmt, arg...) do {\
-	printk(KERN_ERR fmt , ##arg); } while (0)
+	printk(KERN_ERR fmt, ##arg); } while (0)
 
 #define em28xx_errdev(fmt, arg...) do {\
 	printk(KERN_ERR "%s: "fmt,\
-			dev->name , ##arg); } while (0)
+			dev->name, ##arg); } while (0)
 
 #define em28xx_info(fmt, arg...) do {\
 	printk(KERN_INFO "%s: "fmt,\
-			dev->name , ##arg); } while (0)
+			dev->name, ##arg); } while (0)
 #define em28xx_warn(fmt, arg...) do {\
 	printk(KERN_WARNING "%s: "fmt,\
-			dev->name , ##arg); } while (0)
+			dev->name, ##arg); } while (0)
 
 inline static int em28xx_audio_source(struct em28xx *dev, int input)
 {
diff --git a/drivers/media/video/ir-kbd-gpio.c b/drivers/media/video/ir-kbd-gpio.c
index 6345e29..de1385e 100644
--- a/drivers/media/video/ir-kbd-gpio.c
+++ b/drivers/media/video/ir-kbd-gpio.c
@@ -291,13 +291,12 @@ struct IR {
 	u32                     mask_keycode;
 	u32                     mask_keydown;
 	u32                     mask_keyup;
-	u32			polling;
+	u32                     polling;
 	u32                     last_gpio;
 	struct work_struct      work;
 	struct timer_list       timer;
 
 	/* RC5 gpio */
-
 	u32 rc5_gpio;
 	struct timer_list timer_end;	/* timer_end for code completion */
 	struct timer_list timer_keyup;	/* timer_end for key release */
@@ -647,7 +646,7 @@ static int ir_probe(struct device *dev)
 		driver.any_irq = ir_rc5_irq;
 		driver.gpio_irq = NULL;
 		ir->rc5_gpio = 1;
-		 break;
+		break;
 	}
 	if (NULL == ir_codes) {
 		kfree(ir);
@@ -657,7 +656,7 @@ static int ir_probe(struct device *dev)
 
 	if (ir->rc5_gpio) {
 		u32 gpio;
-		/* enable remote irq */
+	    	/* enable remote irq */
 		bttv_gpio_inout(sub->core, (1 << 4), 1 << 4);
 		gpio = bttv_gpio_read(sub->core);
 		bttv_gpio_write(sub->core, gpio & ~(1 << 4));
@@ -726,6 +725,7 @@ static int ir_remove(struct device *dev)
 		del_timer(&ir->timer);
 		flush_scheduled_work();
 	}
+
 	if (ir->rc5_gpio) {
 		u32 gpio;
 
diff --git a/drivers/media/video/ir-kbd-i2c.c b/drivers/media/video/ir-kbd-i2c.c
index 124c502..740e543 100644
--- a/drivers/media/video/ir-kbd-i2c.c
+++ b/drivers/media/video/ir-kbd-i2c.c
@@ -40,6 +40,7 @@
 #include <linux/i2c.h>
 #include <linux/workqueue.h>
 #include <asm/semaphore.h>
+
 #include <media/ir-common.h>
 #include <media/ir-kbd-i2c.h>
 
@@ -278,7 +279,7 @@ static int ir_probe(struct i2c_adapter *
 
 static struct i2c_driver driver = {
 	.name           = "ir remote kbd driver",
-	.id             = I2C_DRIVERID_I2C_IR,
+	.id             = I2C_DRIVERID_INFRARED,
 	.flags          = I2C_DF_NOTIFY,
 	.attach_adapter = ir_probe,
 	.detach_client  = ir_detach,
@@ -296,15 +297,15 @@ static int ir_attach(struct i2c_adapter 
 	IR_KEYTAB_TYPE *ir_codes = NULL;
 	char *name;
 	int ir_type;
-        struct IR_i2c *ir;
+	struct IR_i2c *ir;
 	struct input_dev *input_dev;
 
-	ir = kzalloc(sizeof(struct IR_i2c), GFP_KERNEL);
+	ir = kzalloc(sizeof(struct IR_i2c),GFP_KERNEL);
 	input_dev = input_allocate_device();
 	if (!ir || !input_dev) {
 		kfree(ir);
 		input_free_device(input_dev);
-                return -ENOMEM;
+		return -ENOMEM;
 	}
 
 	ir->c = client_template;
@@ -360,7 +361,7 @@ static int ir_attach(struct i2c_adapter 
 	/* register i2c device
 	 * At device register, IR codes may be changed to be
 	 * board dependent.
-	*/
+	 */
 	i2c_attach_client(&ir->c);
 
 	/* If IR not supported or disabled, unregisters driver */
diff --git a/drivers/media/video/msp3400.c b/drivers/media/video/msp3400.c
index a23fb03..d86f8e9 100644
--- a/drivers/media/video/msp3400.c
+++ b/drivers/media/video/msp3400.c
@@ -134,7 +134,7 @@ struct msp3400c {
 	int rxsubchans;
 
 	int muted;
-	int left, right;        /* volume */
+	int left, right;	/* volume */
 	int bass, treble;
 
 	/* shadow register set */
@@ -882,6 +882,7 @@ static void watch_stereo(struct i2c_clie
 		msp->watch_stereo = 0;
 }
 
+
 static int msp3400c_thread(void *data)
 {
 	struct i2c_client *client = data;
@@ -889,6 +890,7 @@ static int msp3400c_thread(void *data)
 	struct CARRIER_DETECT *cd;
 	int count, max1,max2,val1,val2, val,this;
 
+
 	msp3400_info("msp3400 daemon started\n");
 	for (;;) {
 		msp3400_dbg_mediumvol("msp3400 thread: sleep\n");
@@ -1162,6 +1164,7 @@ static int msp3410d_thread(void *data)
 	int mode,val,i,std;
 
 	msp3400_info("msp3410 daemon started\n");
+
 	for (;;) {
 		msp3400_dbg_mediumvol("msp3410 thread: sleep\n");
 		msp34xx_sleep(msp,-1);
@@ -1384,6 +1387,7 @@ static int msp34xxg_thread(void *data)
 	int val, std, i;
 
 	msp3400_info("msp34xxg daemon started\n");
+
 	msp->source = 1; /* default */
 	for (;;) {
 		msp3400_dbg_mediumvol("msp34xxg thread: sleep\n");
@@ -1559,11 +1563,11 @@ static void msp_wake_thread(struct i2c_c
 static struct i2c_driver driver = {
 	.owner          = THIS_MODULE,
 	.name           = "msp3400",
-        .id             = I2C_DRIVERID_MSP3400,
-        .flags          = I2C_DF_NOTIFY,
-        .attach_adapter = msp_probe,
-        .detach_client  = msp_detach,
-        .command        = msp_command,
+	.id             = I2C_DRIVERID_MSP3400,
+	.flags          = I2C_DF_NOTIFY,
+	.attach_adapter = msp_probe,
+	.detach_client  = msp_detach,
+	.command        = msp_command,
 	.driver = {
 		.suspend = msp_suspend,
 		.resume  = msp_resume,
@@ -1574,7 +1578,7 @@ static struct i2c_client client_template
 {
 	.name      = "(unset)",
 	.flags     = I2C_CLIENT_ALLOW_USE,
-        .driver    = &driver,
+	.driver    = &driver,
 };
 
 static int msp_attach(struct i2c_adapter *adap, int addr, int kind)
diff --git a/drivers/media/video/saa6588.c b/drivers/media/video/saa6588.c
index dca3ddf..9233225 100644
--- a/drivers/media/video/saa6588.c
+++ b/drivers/media/video/saa6588.c
@@ -422,7 +422,6 @@ static int saa6588_attach(struct i2c_ada
 	s->timer.function = saa6588_timer;
 	s->timer.data = (unsigned long)s;
 	schedule_work(&s->work);
-
 	return 0;
 }
 
diff --git a/drivers/media/video/saa711x.c b/drivers/media/video/saa711x.c
index 59e13fd..31f7b95 100644
--- a/drivers/media/video/saa711x.c
+++ b/drivers/media/video/saa711x.c
@@ -59,7 +59,7 @@ MODULE_PARM_DESC(debug, " Set the defaul
 #define dprintk(num, format, args...) \
 	do { \
 		if (debug >= num) \
-			printk(format , ##args); \
+			printk(format, ##args); \
 	} while (0)
 
 /* ----------------------------------------------------------------------- */
diff --git a/drivers/media/video/saa7134/saa6752hs.c b/drivers/media/video/saa7134/saa6752hs.c
index cdd1ed9..a61d24f 100644
--- a/drivers/media/video/saa7134/saa6752hs.c
+++ b/drivers/media/video/saa7134/saa6752hs.c
@@ -523,7 +523,8 @@ static int saa6752hs_attach(struct i2c_a
 	h->standard = 0;
 
 	i2c_set_clientdata(&h->client, h);
-        i2c_attach_client(&h->client);
+	i2c_attach_client(&h->client);
+
 	return 0;
 }
 
@@ -597,19 +598,19 @@ saa6752hs_command(struct i2c_client *cli
 
 static struct i2c_driver driver = {
 	.owner          = THIS_MODULE,
-        .name           = "i2c saa6752hs MPEG encoder",
-        .id             = I2C_DRIVERID_SAA6752HS,
-        .flags          = I2C_DF_NOTIFY,
-        .attach_adapter = saa6752hs_probe,
-        .detach_client  = saa6752hs_detach,
-        .command        = saa6752hs_command,
+	.name           = "i2c saa6752hs MPEG encoder",
+	.id             = I2C_DRIVERID_SAA6752HS,
+	.flags          = I2C_DF_NOTIFY,
+	.attach_adapter = saa6752hs_probe,
+	.detach_client  = saa6752hs_detach,
+	.command        = saa6752hs_command,
 };
 
 static struct i2c_client client_template =
 {
 	.name       = "saa6752hs",
 	.flags      = I2C_CLIENT_ALLOW_USE,
-        .driver     = &driver,
+	.driver     = &driver,
 };
 
 static int __init saa6752hs_init_module(void)
diff --git a/drivers/media/video/saa7134/saa7134-alsa.c b/drivers/media/video/saa7134/saa7134-alsa.c
index 263c6e2..b24a26b 100644
--- a/drivers/media/video/saa7134/saa7134-alsa.c
+++ b/drivers/media/video/saa7134/saa7134-alsa.c
@@ -51,6 +51,7 @@ MODULE_PARM_DESC(debug,"enable debug mes
 #define MIXER_ADDR_LINE2	2
 #define MIXER_ADDR_LAST		2
 
+
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
 static int enable[SNDRV_CARDS] = {1, [1 ... (SNDRV_CARDS - 1)] = 0};
@@ -59,11 +60,14 @@ module_param_array(index, int, NULL, 044
 MODULE_PARM_DESC(index, "Index value for SAA7134 capture interface(s).");
 
 #define dprintk(fmt, arg...)    if (debug) \
-        printk(KERN_DEBUG "%s/alsa: " fmt, dev->name , ## arg)
+	printk(KERN_DEBUG "%s/alsa: " fmt, dev->name, ## arg)
+
+
 
 /*
  * Main chip structure
  */
+
 typedef struct snd_card_saa7134 {
 	snd_card_t *card;
 	spinlock_t mixer_lock;
@@ -208,8 +212,8 @@ static void saa7134_irq_alsa_done(struct
 
 static irqreturn_t saa7134_alsa_irq(int irq, void *dev_id, struct pt_regs *regs)
 {
-        struct saa7134_dmasound *dmasound = dev_id;
-        struct saa7134_dev *dev = dmasound->priv_data;
+	struct saa7134_dmasound *dmasound = dev_id;
+	struct saa7134_dev *dev = dmasound->priv_data;
 
 	unsigned long report, status;
 	int loop, handled = 0;
@@ -985,7 +989,7 @@ static int saa7134_alsa_init(void)
 	struct saa7134_dev *dev = NULL;
 	struct list_head *list;
 
-        printk(KERN_INFO "saa7134 ALSA driver for DMA sound loaded\n");
+	printk(KERN_INFO "saa7134 ALSA driver for DMA sound loaded\n");
 
 	list_for_each(list,&saa7134_devlist) {
 		dev = list_entry(list, struct saa7134_dev, devlist);
@@ -1004,6 +1008,7 @@ static int saa7134_alsa_init(void)
 		printk(KERN_INFO "saa7134 ALSA: no saa7134 cards found\n");
 
 	return 0;
+
 }
 
 /*
@@ -1027,3 +1032,6 @@ module_init(saa7134_alsa_init);
 module_exit(saa7134_alsa_exit);
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Ricardo Cerqueira");
+
+
+
diff --git a/drivers/media/video/saa7134/saa7134-cards.c b/drivers/media/video/saa7134/saa7134-cards.c
index 75abc20..672fb20 100644
--- a/drivers/media/video/saa7134/saa7134-cards.c
+++ b/drivers/media/video/saa7134/saa7134-cards.c
@@ -976,7 +976,7 @@ struct saa7134_board saa7134_boards[] = 
 		.radio_type     = UNSET,
 		.tuner_addr	= ADDR_UNSET,
 		.radio_addr	= ADDR_UNSET,
-		.tda9887_conf   = TDA9887_PRESENT | TDA9887_INTERCARRIER,
+		.tda9887_conf   = TDA9887_PRESENT | TDA9887_INTERCARRIER | TDA9887_PORT2_ACTIVE,
 		.inputs         = {{
 			.name = name_tv,
 			.vmux = 3,
diff --git a/drivers/media/video/saa7134/saa7134-core.c b/drivers/media/video/saa7134/saa7134-core.c
index 1a093bf..23d8747 100644
--- a/drivers/media/video/saa7134/saa7134-core.c
+++ b/drivers/media/video/saa7134/saa7134-core.c
@@ -71,6 +71,7 @@ static unsigned int radio_nr[] = {[0 ...
 static unsigned int tuner[]    = {[0 ... (SAA7134_MAXBOARDS - 1)] = UNSET };
 static unsigned int card[]     = {[0 ... (SAA7134_MAXBOARDS - 1)] = UNSET };
 
+
 module_param_array(video_nr, int, NULL, 0444);
 module_param_array(vbi_nr,   int, NULL, 0444);
 module_param_array(radio_nr, int, NULL, 0444);
diff --git a/drivers/media/video/saa7134/saa7134-empress.c b/drivers/media/video/saa7134/saa7134-empress.c
index e9ec69e..575f3e8 100644
--- a/drivers/media/video/saa7134/saa7134-empress.c
+++ b/drivers/media/video/saa7134/saa7134-empress.c
@@ -36,6 +36,7 @@ MODULE_AUTHOR("Gerd Knorr <kraxel@bytese
 MODULE_LICENSE("GPL");
 
 static unsigned int empress_nr[] = {[0 ... (SAA7134_MAXBOARDS - 1)] = UNSET };
+
 module_param_array(empress_nr, int, NULL, 0444);
 MODULE_PARM_DESC(empress_nr,"ts device number");
 
diff --git a/drivers/media/video/saa7134/saa7134-i2c.c b/drivers/media/video/saa7134/saa7134-i2c.c
index 7575043..df9dd36 100644
--- a/drivers/media/video/saa7134/saa7134-i2c.c
+++ b/drivers/media/video/saa7134/saa7134-i2c.c
@@ -333,7 +333,7 @@ static int attach_inform(struct i2c_clie
 	struct tuner_setup tun_setup;
 
 	d1printk( "%s i2c attach [addr=0x%x,client=%s]\n",
-		 client->driver->name, client->addr, client->name);
+		client->driver->name, client->addr, client->name);
 
 	/* Am I an i2c remote control? */
 
diff --git a/drivers/media/video/saa7134/saa7134-oss.c b/drivers/media/video/saa7134/saa7134-oss.c
index 5a57919..513a699 100644
--- a/drivers/media/video/saa7134/saa7134-oss.c
+++ b/drivers/media/video/saa7134/saa7134-oss.c
@@ -782,36 +782,36 @@ struct file_operations saa7134_mixer_fop
 
 static irqreturn_t saa7134_oss_irq(int irq, void *dev_id, struct pt_regs *regs)
 {
-        struct saa7134_dmasound *dmasound = dev_id;
-        struct saa7134_dev *dev = dmasound->priv_data;
-        unsigned long report, status;
-        int loop, handled = 0;
-
-        for (loop = 0; loop < 10; loop++) {
-                report = saa_readl(SAA7134_IRQ_REPORT);
-                status = saa_readl(SAA7134_IRQ_STATUS);
-
-                if (report & SAA7134_IRQ_REPORT_DONE_RA3) {
-                        handled = 1;
-                        saa_writel(SAA7134_IRQ_REPORT,report);
-                        saa7134_irq_oss_done(dev, status);
-                } else {
-                        goto out;
-                }
-        }
-
-        if (loop == 10) {
-                dprintk("error! looping IRQ!");
-        }
+	struct saa7134_dmasound *dmasound = dev_id;
+	struct saa7134_dev *dev = dmasound->priv_data;
+	unsigned long report, status;
+	int loop, handled = 0;
+
+	for (loop = 0; loop < 10; loop++) {
+		report = saa_readl(SAA7134_IRQ_REPORT);
+		status = saa_readl(SAA7134_IRQ_STATUS);
+
+		if (report & SAA7134_IRQ_REPORT_DONE_RA3) {
+			handled = 1;
+			saa_writel(SAA7134_IRQ_REPORT,report);
+			saa7134_irq_oss_done(dev, status);
+		} else {
+			goto out;
+		}
+	}
+
+	if (loop == 10) {
+		dprintk("error! looping IRQ!");
+	}
 out:
-        return IRQ_RETVAL(handled);
+	return IRQ_RETVAL(handled);
 }
 
 int saa7134_oss_init1(struct saa7134_dev *dev)
 {
 
-        if ((request_irq(dev->pci->irq, saa7134_oss_irq,
-                         SA_SHIRQ | SA_INTERRUPT, dev->name,
+	if ((request_irq(dev->pci->irq, saa7134_oss_irq,
+			 SA_SHIRQ | SA_INTERRUPT, dev->name,
 			(void*) &dev->dmasound)) < 0)
 		return -1;
 
@@ -905,25 +905,25 @@ static int saa7134_dsp_create(struct saa
 
 	err = dev->dmasound.minor_dsp =
 		register_sound_dsp(&saa7134_dsp_fops,
-                			dsp_nr[dev->nr]);
+				   dsp_nr[dev->nr]);
 	if (err < 0) {
 		goto fail;
 	}
 	printk(KERN_INFO "%s: registered device dsp%d\n",
-		dev->name,dev->dmasound.minor_dsp >> 4);
+	       dev->name,dev->dmasound.minor_dsp >> 4);
 
 	err = dev->dmasound.minor_mixer =
 		register_sound_mixer(&saa7134_mixer_fops,
-					mixer_nr[dev->nr]);
+				     mixer_nr[dev->nr]);
 	if (err < 0)
 		goto fail;
 	printk(KERN_INFO "%s: registered device mixer%d\n",
-		dev->name,dev->dmasound.minor_mixer >> 4);
+	       dev->name,dev->dmasound.minor_mixer >> 4);
 
 	return 0;
 
 fail:
-        unregister_sound_dsp(dev->dmasound.minor_dsp);
+	unregister_sound_dsp(dev->dmasound.minor_dsp);
 	return 0;
 
 
@@ -956,49 +956,50 @@ static int oss_device_exit(struct saa713
 
 static int saa7134_oss_init(void)
 {
-        struct saa7134_dev *dev = NULL;
-        struct list_head *list;
+	struct saa7134_dev *dev = NULL;
+	struct list_head *list;
 
-        printk(KERN_INFO "saa7134 OSS driver for DMA sound loaded\n");
+	printk(KERN_INFO "saa7134 OSS driver for DMA sound loaded\n");
 
-        list_for_each(list,&saa7134_devlist) {
-                dev = list_entry(list, struct saa7134_dev, devlist);
+	list_for_each(list,&saa7134_devlist) {
+		dev = list_entry(list, struct saa7134_dev, devlist);
 		if (dev->dmasound.priv_data == NULL) {
 			oss_device_init(dev);
 		} else {
-                	printk(KERN_ERR "saa7134 OSS: DMA sound is being handled by ALSA, ignoring %s\n",dev->name);
+			printk(KERN_ERR "saa7134 OSS: DMA sound is being handled by ALSA, ignoring %s\n",dev->name);
 			return -EBUSY;
 		}
-        }
+	}
 
-        if (dev == NULL)
-                printk(KERN_INFO "saa7134 OSS: no saa7134 cards found\n");
+	if (dev == NULL)
+		printk(KERN_INFO "saa7134 OSS: no saa7134 cards found\n");
 
 	dmasound_init = oss_device_init;
 	dmasound_exit = oss_device_exit;
 
-        return 0;
+	return 0;
 
 }
 
 static void saa7134_oss_exit(void)
 {
-        struct saa7134_dev *dev = NULL;
-        struct list_head *list;
+	struct saa7134_dev *dev = NULL;
+	struct list_head *list;
 
-        list_for_each(list,&saa7134_devlist) {
-                dev = list_entry(list, struct saa7134_dev, devlist);
+	list_for_each(list,&saa7134_devlist) {
+		dev = list_entry(list, struct saa7134_dev, devlist);
 
 		/* Device isn't registered by OSS, probably ALSA's */
 		if (!dev->dmasound.minor_dsp)
 			continue;
 
 		oss_device_exit(dev);
-        }
 
-        printk(KERN_INFO "saa7134 OSS driver for DMA sound unloaded\n");
+	}
+
+	printk(KERN_INFO "saa7134 OSS driver for DMA sound unloaded\n");
 
-        return;
+	return;
 }
 
 module_init(saa7134_oss_init);
diff --git a/drivers/media/video/tda9887.c b/drivers/media/video/tda9887.c
index 4249127..2f2414e 100644
--- a/drivers/media/video/tda9887.c
+++ b/drivers/media/video/tda9887.c
@@ -12,6 +12,7 @@
 #include <media/audiochip.h>
 #include <media/tuner.h>
 
+
 /* Chips:
    TDA9885 (PAL, NTSC)
    TDA9886 (PAL, SECAM, NTSC)
@@ -819,12 +820,12 @@ static int tda9887_resume(struct device 
 
 static struct i2c_driver driver = {
 	.owner          = THIS_MODULE,
-        .name           = "i2c tda9887 driver",
-        .id             = -1, /* FIXME */
-        .flags          = I2C_DF_NOTIFY,
-        .attach_adapter = tda9887_probe,
-        .detach_client  = tda9887_detach,
-        .command        = tda9887_command,
+	.name           = "i2c tda9887 driver",
+	.id             = -1, /* FIXME */
+	.flags          = I2C_DF_NOTIFY,
+	.attach_adapter = tda9887_probe,
+	.detach_client  = tda9887_detach,
+	.command        = tda9887_command,
 	.driver = {
 		.suspend = tda9887_suspend,
 		.resume  = tda9887_resume,
@@ -834,7 +835,7 @@ static struct i2c_client client_template
 {
 	.name      = "tda9887",
 	.flags     = I2C_CLIENT_ALLOW_USE,
-        .driver    = &driver,
+	.driver    = &driver,
 };
 
 static int __init tda9887_init_module(void)
diff --git a/drivers/media/video/tvaudio.c b/drivers/media/video/tvaudio.c
index c31bf28..5b20e81 100644
--- a/drivers/media/video/tvaudio.c
+++ b/drivers/media/video/tvaudio.c
@@ -188,7 +188,7 @@ static int chip_write(struct CHIPSTATE *
 		buffer[1] = val;
 		if (2 != i2c_master_send(&chip->c,buffer,2)) {
 			tvaudio_warn("%s: I/O error (write reg%d=0x%x)\n",
-						chip->c.name, subaddr, val);
+			chip->c.name, subaddr, val);
 			return -1;
 		}
 	}
@@ -216,7 +216,7 @@ static int chip_read(struct CHIPSTATE *c
 		chip->c.name);
 		return -1;
 	}
-	tvaudio_dbg("%s: chip_read: 0x%x\n",chip->c.name,buffer);
+	tvaudio_dbg("%s: chip_read: 0x%x\n",chip->c.name, buffer);
 	return buffer;
 }
 
@@ -235,7 +235,7 @@ static int chip_read2(struct CHIPSTATE *
 		return -1;
 	}
 	tvaudio_dbg("%s: chip_read2: reg%d=0x%x\n",
-			chip->c.name,subaddr,read[0]);
+		chip->c.name, subaddr,read[0]);
 	return read[0];
 }
 
@@ -248,7 +248,7 @@ static int chip_cmd(struct CHIPSTATE *ch
 
 	/* update our shadow register set; print bytes if (debug > 0) */
 	tvaudio_dbg("%s: chip_cmd(%s): reg=%d, data:",
-		chip->c.name,name,cmd->bytes[0]);
+		chip->c.name, name,cmd->bytes[0]);
 	for (i = 1; i < cmd->count; i++) {
 		if (debug)
 			printk(" 0x%x",cmd->bytes[i]);
@@ -322,7 +322,7 @@ static void generic_checkmode(struct CHI
 	int mode = desc->getmode(chip);
 
 	if (mode == chip->prevmode)
-		return;
+	return;
 
 	tvaudio_dbg("%s: thread checkmode\n", chip->c.name);
 	chip->prevmode = mode;
@@ -1506,18 +1506,18 @@ static int chip_attach(struct i2c_adapte
 		return -EIO;
 	}
 	tvaudio_info("%s found @ 0x%x (%s)\n", desc->name, addr<<1, adap->name);
-        if (desc->flags) {
-                tvaudio_dbg("matches:%s%s%s.\n",
-                        (desc->flags & CHIP_HAS_VOLUME)     ? " volume"      : "",
-                        (desc->flags & CHIP_HAS_BASSTREBLE) ? " bass/treble" : "",
-                        (desc->flags & CHIP_HAS_INPUTSEL)   ? " audiomux"    : "");
-        }
+	if (desc->flags) {
+		tvaudio_dbg("matches:%s%s%s.\n",
+			(desc->flags & CHIP_HAS_VOLUME)     ? " volume"      : "",
+			(desc->flags & CHIP_HAS_BASSTREBLE) ? " bass/treble" : "",
+			(desc->flags & CHIP_HAS_INPUTSEL)   ? " audiomux"    : "");
+	}
 
 	/* fill required data structures */
-	strcpy(chip->c.name,desc->name);
+	strcpy(chip->c.name, desc->name);
 	chip->type = desc-chiplist;
 	chip->shadow.count = desc->registers+1;
-        chip->prevmode = -1;
+	chip->prevmode = -1;
 	/* register */
 	i2c_attach_client(&chip->c);
 
@@ -1604,7 +1604,7 @@ static int chip_command(struct i2c_clien
 	struct CHIPSTATE *chip = i2c_get_clientdata(client);
 	struct CHIPDESC  *desc = chiplist + chip->type;
 
-	tvaudio_dbg("%s: chip_command 0x%x\n",chip->c.name,cmd);
+	tvaudio_dbg("%s: chip_command 0x%x\n", chip->c.name, cmd);
 
 	switch (cmd) {
 	case AUDC_SET_INPUT:
@@ -1624,7 +1624,7 @@ static int chip_command(struct i2c_clien
 
 	/* --- v4l ioctls --- */
 	/* take care: bttv does userspace copying, we'll get a
-					kernel pointer here... */
+	kernel pointer here... */
 	case VIDIOCGAUDIO:
 	{
 		struct video_audio *va = arg;
diff --git a/drivers/media/video/tveeprom.c b/drivers/media/video/tveeprom.c
index d95aece..cd7cf1b 100644
--- a/drivers/media/video/tveeprom.c
+++ b/drivers/media/video/tveeprom.c
@@ -753,7 +753,8 @@ tveeprom_detect_client(struct i2c_adapte
 	client->driver = &i2c_driver_tveeprom;
 	client->flags = I2C_CLIENT_ALLOW_USE;
 	snprintf(client->name, sizeof(client->name), "tveeprom");
-        i2c_attach_client(client);
+	i2c_attach_client(client);
+
 	return 0;
 }
 
diff --git a/drivers/media/video/tvp5150.c b/drivers/media/video/tvp5150.c
index 81e6d44..97431e2 100644
--- a/drivers/media/video/tvp5150.c
+++ b/drivers/media/video/tvp5150.c
@@ -31,7 +31,7 @@ MODULE_PARM_DESC(debug, "Debug level (0-
 #define dprintk(num, format, args...) \
 	do { \
 		if (debug >= num) \
-			printk(format , ##args); \
+			printk(format, ##args); \
 	} while (0)
 
 /* supported controls */
@@ -770,7 +770,6 @@ static int tvp5150_detect_client(struct 
 
 	if (debug > 1)
 		dump_reg(client);
-
 	return 0;
 }
 
diff --git a/drivers/media/video/video-buf-dvb.c b/drivers/media/video/video-buf-dvb.c
index 55f129e..0a4004a 100644
--- a/drivers/media/video/video-buf-dvb.c
+++ b/drivers/media/video/video-buf-dvb.c
@@ -13,6 +13,7 @@
  * (at your option) any later version.
  */
 
+
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/device.h>
@@ -247,3 +248,4 @@ EXPORT_SYMBOL(videobuf_dvb_unregister);
  * compile-command: "make DVB=1"
  * End:
  */
+
diff --git a/drivers/mfd/ucb1x00-ts.c b/drivers/mfd/ucb1x00-ts.c
index a984c0e..551061c 100644
--- a/drivers/mfd/ucb1x00-ts.c
+++ b/drivers/mfd/ucb1x00-ts.c
@@ -59,16 +59,18 @@ static int adcsync;
 
 static inline void ucb1x00_ts_evt_add(struct ucb1x00_ts *ts, u16 pressure, u16 x, u16 y)
 {
-	input_report_abs(ts->idev, ABS_X, x);
-	input_report_abs(ts->idev, ABS_Y, y);
-	input_report_abs(ts->idev, ABS_PRESSURE, pressure);
-	input_sync(ts->idev);
+	struct input_dev *idev = ts->idev;
+	input_report_abs(idev, ABS_X, x);
+	input_report_abs(idev, ABS_Y, y);
+	input_report_abs(idev, ABS_PRESSURE, pressure);
+	input_sync(idev);
 }
 
 static inline void ucb1x00_ts_event_release(struct ucb1x00_ts *ts)
 {
-	input_report_abs(ts->idev, ABS_PRESSURE, 0);
-	input_sync(ts->idev);
+	struct input_dev *idev = ts->idev;
+	input_report_abs(idev, ABS_PRESSURE, 0);
+	input_sync(idev);
 }
 
 /*
@@ -297,7 +299,7 @@ static void ucb1x00_ts_irq(int idx, void
 
 static int ucb1x00_ts_open(struct input_dev *idev)
 {
-	struct ucb1x00_ts *ts = (struct ucb1x00_ts *)idev;
+	struct ucb1x00_ts *ts = idev->private;
 	int ret = 0;
 
 	BUG_ON(ts->rtask);
@@ -334,7 +336,7 @@ static int ucb1x00_ts_open(struct input_
  */
 static void ucb1x00_ts_close(struct input_dev *idev)
 {
-	struct ucb1x00_ts *ts = (struct ucb1x00_ts *)idev;
+	struct ucb1x00_ts *ts = idev->private;
 
 	if (ts->rtask)
 		kthread_stop(ts->rtask);
@@ -386,6 +388,7 @@ static int ucb1x00_ts_add(struct ucb1x00
 	ts->ucb = dev->ucb;
 	ts->adcsync = adcsync ? UCB_SYNC : UCB_NOSYNC;
 
+	ts->idev->private = ts;
 	ts->idev->name       = "Touchscreen panel";
 	ts->idev->id.product = ts->ucb->id;
 	ts->idev->open       = ucb1x00_ts_open;
diff --git a/drivers/mmc/mmc.c b/drivers/mmc/mmc.c
index d336a1d..b586a83 100644
--- a/drivers/mmc/mmc.c
+++ b/drivers/mmc/mmc.c
@@ -932,8 +932,9 @@ static void mmc_read_scrs(struct mmc_hos
 
 		sg_init_one(&sg, (u8*)card->raw_scr, 8);
 
-		err = mmc_wait_for_req(host, &mrq);
-		if (err != MMC_ERR_NONE) {
+		mmc_wait_for_req(host, &mrq);
+
+		if (cmd.error != MMC_ERR_NONE || data.error != MMC_ERR_NONE) {
 			mmc_card_set_dead(card);
 			continue;
 		}
diff --git a/drivers/mtd/devices/blkmtd.c b/drivers/mtd/devices/blkmtd.c
index f9db52f..04f864d 100644
--- a/drivers/mtd/devices/blkmtd.c
+++ b/drivers/mtd/devices/blkmtd.c
@@ -113,7 +113,7 @@ static int bi_write_complete(struct bio 
 			ClearPageUptodate(page);
 			SetPageError(page);
 		}
-		ClearPageDirty(page);
+		clear_page_dirty(page);
 		unlock_page(page);
 		page_cache_release(page);
 	} while (bvec >= bio->bi_io_vec);
@@ -289,7 +289,7 @@ static int write_pages(struct blkmtd_dev
 			BUG();
 		}
 		memcpy(page_address(page)+offset, buf, start_len);
-		SetPageDirty(page);
+		set_page_dirty(page);
 		SetPageUptodate(page);
 		buf += start_len;
 		thislen = start_len;
@@ -336,7 +336,7 @@ static int write_pages(struct blkmtd_dev
 			}
 			pagenr++;
 			pagecnt--;
-			SetPageDirty(page);
+			set_page_dirty(page);
 			SetPageUptodate(page);
 			pagesc--;
 			thislen += PAGE_SIZE;
@@ -357,7 +357,7 @@ static int write_pages(struct blkmtd_dev
 			BUG();
 		}
 		memcpy(page_address(page), buf, end_len);
-		SetPageDirty(page);
+		set_page_dirty(page);
 		SetPageUptodate(page);
 		DEBUG(3, "blkmtd: write: writing out partial end\n");
 		thislen += end_len;
diff --git a/drivers/net/pcnet32.c b/drivers/net/pcnet32.c
index be31922..8f6cf8c 100644
--- a/drivers/net/pcnet32.c
+++ b/drivers/net/pcnet32.c
@@ -1251,12 +1251,7 @@ pcnet32_probe1(unsigned long ioaddr, int
 
     if (memcmp(promaddr, dev->dev_addr, 6)
 	|| !is_valid_ether_addr(dev->dev_addr)) {
-#ifndef __powerpc__
 	if (is_valid_ether_addr(promaddr)) {
-#else
-	if (!is_valid_ether_addr(dev->dev_addr)
-	    && is_valid_ether_addr(promaddr)) {
-#endif
 	    if (pcnet32_debug & NETIF_MSG_PROBE) {
 		printk(" warning: CSR address invalid,\n");
 		printk(KERN_INFO "    using instead PROM address of");
diff --git a/drivers/net/sk98lin/skge.c b/drivers/net/sk98lin/skge.c
index 00c5d7f..ae73439 100644
--- a/drivers/net/sk98lin/skge.c
+++ b/drivers/net/sk98lin/skge.c
@@ -818,7 +818,7 @@ uintptr_t VNextDescr;	/* the virtual bus
 		/* set the pointers right */
 		pDescr->VNextRxd = VNextDescr & 0xffffffffULL;
 		pDescr->pNextRxd = pNextDescr;
-		pDescr->TcpSumStarts = 0;
+		if (!IsTx) pDescr->TcpSumStarts = ETH_HLEN << 16 | ETH_HLEN;
 
 		/* advance one step */
 		pPrevDescr = pDescr;
@@ -2169,7 +2169,7 @@ rx_start:	
 		} /* frame > SK_COPY_TRESHOLD */
 
 #ifdef USE_SK_RX_CHECKSUM
-		pMsg->csum = pRxd->TcpSums;
+		pMsg->csum = pRxd->TcpSums & 0xffff;
 		pMsg->ip_summed = CHECKSUM_HW;
 #else
 		pMsg->ip_summed = CHECKSUM_NONE;
diff --git a/drivers/net/skge.c b/drivers/net/skge.c
index 7164678..8b6e2a1 100644
--- a/drivers/net/skge.c
+++ b/drivers/net/skge.c
@@ -2280,11 +2280,13 @@ static int skge_xmit_frame(struct sk_buf
  	}
 
 	if (unlikely(skge->tx_avail < skb_shinfo(skb)->nr_frags +1)) {
-		netif_stop_queue(dev);
-		spin_unlock_irqrestore(&skge->tx_lock, flags);
+		if (!netif_queue_stopped(dev)) {
+			netif_stop_queue(dev);
 
-		printk(KERN_WARNING PFX "%s: ring full when queue awake!\n",
-		       dev->name);
+			printk(KERN_WARNING PFX "%s: ring full when queue awake!\n",
+			       dev->name);
+		}
+		spin_unlock_irqrestore(&skge->tx_lock, flags);
 		return NETDEV_TX_BUSY;
 	}
 
diff --git a/drivers/net/tg3.c b/drivers/net/tg3.c
index 1828a6b..47bd4a3 100644
--- a/drivers/net/tg3.c
+++ b/drivers/net/tg3.c
@@ -68,8 +68,8 @@
 
 #define DRV_MODULE_NAME		"tg3"
 #define PFX DRV_MODULE_NAME	": "
-#define DRV_MODULE_VERSION	"3.43"
-#define DRV_MODULE_RELDATE	"Oct 24, 2005"
+#define DRV_MODULE_VERSION	"3.44"
+#define DRV_MODULE_RELDATE	"Dec 6, 2005"
 
 #define TG3_DEF_MAC_MODE	0
 #define TG3_DEF_RX_MODE		0
@@ -3565,12 +3565,15 @@ static int tg3_start_xmit(struct sk_buff
 	if (!spin_trylock(&tp->tx_lock))
 		return NETDEV_TX_LOCKED; 
 
-	/* This is a hard error, log it. */
 	if (unlikely(TX_BUFFS_AVAIL(tp) <= (skb_shinfo(skb)->nr_frags + 1))) {
-		netif_stop_queue(dev);
+		if (!netif_queue_stopped(dev)) {
+			netif_stop_queue(dev);
+
+			/* This is a hard error, log it. */
+			printk(KERN_ERR PFX "%s: BUG! Tx Ring full when "
+			       "queue awake!\n", dev->name);
+		}
 		spin_unlock(&tp->tx_lock);
-		printk(KERN_ERR PFX "%s: BUG! Tx Ring full when queue awake!\n",
-		       dev->name);
 		return NETDEV_TX_BUSY;
 	}
 
diff --git a/drivers/scsi/libata-core.c b/drivers/scsi/libata-core.c
index 665ae79..d0a0fdb 100644
--- a/drivers/scsi/libata-core.c
+++ b/drivers/scsi/libata-core.c
@@ -2443,7 +2443,7 @@ static void ata_sg_clean(struct ata_queu
 			struct scatterlist *psg = &qc->pad_sgent;
 			void *addr = kmap_atomic(psg->page, KM_IRQ0);
 			memcpy(addr + psg->offset, pad_buf, qc->pad_len);
-			kunmap_atomic(psg->page, KM_IRQ0);
+			kunmap_atomic(addr, KM_IRQ0);
 		}
 	} else {
 		if (sg_dma_len(&sg[0]) > 0)
@@ -2717,7 +2717,7 @@ static int ata_sg_setup(struct ata_queue
 		if (qc->tf.flags & ATA_TFLAG_WRITE) {
 			void *addr = kmap_atomic(psg->page, KM_IRQ0);
 			memcpy(pad_buf, addr + psg->offset, qc->pad_len);
-			kunmap_atomic(psg->page, KM_IRQ0);
+			kunmap_atomic(addr, KM_IRQ0);
 		}
 
 		sg_dma_address(psg) = ap->pad_dma + (qc->tag * ATA_DMA_PAD_SZ);
diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index 4afef5c..ce9d73a 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -542,10 +542,17 @@ static void scsi_requeue_command(struct 
 
 void scsi_next_command(struct scsi_cmnd *cmd)
 {
-	struct request_queue *q = cmd->device->request_queue;
+	struct scsi_device *sdev = cmd->device;
+	struct request_queue *q = sdev->request_queue;
+
+	/* need to hold a reference on the device before we let go of the cmd */
+	get_device(&sdev->sdev_gendev);
 
 	scsi_put_command(cmd);
 	scsi_run_queue(q);
+
+	/* ok to remove device now */
+	put_device(&sdev->sdev_gendev);
 }
 
 void scsi_run_host_queues(struct Scsi_Host *shost)
diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c
index 374853d..94e5167 100644
--- a/drivers/scsi/scsi_scan.c
+++ b/drivers/scsi/scsi_scan.c
@@ -266,8 +266,6 @@ static struct scsi_device *scsi_alloc_sd
 			/*
 			 * if LLDD reports slave not present, don't clutter
 			 * console with alloc failure messages
-
-
 			 */
 			if (ret == -ENXIO)
 				display_failure_msg = 0;
@@ -279,7 +277,6 @@ static struct scsi_device *scsi_alloc_sd
 
 out_device_destroy:
 	transport_destroy_device(&sdev->sdev_gendev);
-	scsi_free_queue(sdev->request_queue);
 	put_device(&sdev->sdev_gendev);
 out:
 	if (display_failure_msg)
diff --git a/drivers/serial/8250_pci.c b/drivers/serial/8250_pci.c
index 8d92adf..8adca0c 100644
--- a/drivers/serial/8250_pci.c
+++ b/drivers/serial/8250_pci.c
@@ -516,7 +516,7 @@ pci_timedia_setup(struct serial_private 
 		break;
 	case 3:
 		offset = board->uart_offset;
-		bar = 1;
+		/* FALLTHROUGH */
 	case 4: /* BAR 2 */
 	case 5: /* BAR 3 */
 	case 6: /* BAR 4 */
diff --git a/drivers/video/bw2.c b/drivers/video/bw2.c
index d3728f6..9248fe1 100644
--- a/drivers/video/bw2.c
+++ b/drivers/video/bw2.c
@@ -121,7 +121,6 @@ struct bw2_par {
 	unsigned long		fbsize;
 
 	struct sbus_dev		*sdev;
-	struct list_head	list;
 };
 
 /**
diff --git a/drivers/video/cfbcopyarea.c b/drivers/video/cfbcopyarea.c
index cdc7157..7441532 100644
--- a/drivers/video/cfbcopyarea.c
+++ b/drivers/video/cfbcopyarea.c
@@ -64,8 +64,8 @@ bitcpy(unsigned long __iomem *dst, int d
 	int const shift = dst_idx-src_idx;
 	int left, right;
 
-	first = ~0UL >> dst_idx;
-	last = ~(~0UL >> ((dst_idx+n) % bits));
+	first = FB_SHIFT_HIGH(~0UL, dst_idx);
+	last = ~(FB_SHIFT_HIGH(~0UL, (dst_idx+n) % bits));
 
 	if (!shift) {
 		// Same alignment for source and dest
@@ -216,8 +216,8 @@ bitcpy_rev(unsigned long __iomem *dst, i
 
 	shift = dst_idx-src_idx;
 
-	first = ~0UL << (bits - 1 - dst_idx);
-	last = ~(~0UL << (bits - 1 - ((dst_idx-n) % bits)));
+	first = FB_SHIFT_LOW(~0UL, bits - 1 - dst_idx);
+	last = ~(FB_SHIFT_LOW(~0UL, bits - 1 - ((dst_idx-n) % bits)));
 
 	if (!shift) {
 		// Same alignment for source and dest
diff --git a/drivers/video/cfbfillrect.c b/drivers/video/cfbfillrect.c
index 167d931..e5ff62e 100644
--- a/drivers/video/cfbfillrect.c
+++ b/drivers/video/cfbfillrect.c
@@ -110,8 +110,8 @@ bitfill_aligned(unsigned long __iomem *d
 	if (!n)
 		return;
 
-	first = ~0UL >> dst_idx;
-	last = ~(~0UL >> ((dst_idx+n) % bits));
+	first = FB_SHIFT_HIGH(~0UL, dst_idx);
+	last = ~(FB_SHIFT_HIGH(~0UL, (dst_idx+n) % bits));
 
 	if (dst_idx+n <= bits) {
 		// Single word
@@ -167,8 +167,8 @@ bitfill_unaligned(unsigned long __iomem 
 	if (!n)
 		return;
 
-	first = ~0UL >> dst_idx;
-	last = ~(~0UL >> ((dst_idx+n) % bits));
+	first = FB_SHIFT_HIGH(~0UL, dst_idx);
+	last = ~(FB_SHIFT_HIGH(~0UL, (dst_idx+n) % bits));
 
 	if (dst_idx+n <= bits) {
 		// Single word
@@ -221,8 +221,8 @@ bitfill_aligned_rev(unsigned long __iome
 	if (!n)
 		return;
 
-	first = ~0UL >> dst_idx;
-	last = ~(~0UL >> ((dst_idx+n) % bits));
+	first = FB_SHIFT_HIGH(~0UL, dst_idx);
+	last = ~(FB_SHIFT_HIGH(~0UL, (dst_idx+n) % bits));
 
 	if (dst_idx+n <= bits) {
 		// Single word
@@ -290,8 +290,8 @@ bitfill_unaligned_rev(unsigned long __io
 	if (!n)
 		return;
 
-	first = ~0UL >> dst_idx;
-	last = ~(~0UL >> ((dst_idx+n) % bits));
+	first = FB_SHIFT_HIGH(~0UL, dst_idx);
+	last = ~(FB_SHIFT_HIGH(~0UL, (dst_idx+n) % bits));
 
 	if (dst_idx+n <= bits) {
 		// Single word
diff --git a/drivers/video/cfbimgblt.c b/drivers/video/cfbimgblt.c
index a7770c4..910e233 100644
--- a/drivers/video/cfbimgblt.c
+++ b/drivers/video/cfbimgblt.c
@@ -76,18 +76,6 @@ static u32 cfb_tab32[] = {
 #define FB_WRITEL fb_writel
 #define FB_READL  fb_readl
 
-#if defined (__BIG_ENDIAN)
-#define LEFT_POS(bpp)          (32 - bpp)
-#define SHIFT_HIGH(val, bits)  ((val) >> (bits))
-#define SHIFT_LOW(val, bits)   ((val) << (bits))
-#define BIT_NR(b)              (7 - (b))
-#else
-#define LEFT_POS(bpp)          (0)
-#define SHIFT_HIGH(val, bits)  ((val) << (bits))
-#define SHIFT_LOW(val, bits)   ((val) >> (bits))
-#define BIT_NR(b)              (b)
-#endif
-
 static inline void color_imageblit(const struct fb_image *image, 
 				   struct fb_info *p, u8 __iomem *dst1, 
 				   u32 start_index,
@@ -109,7 +97,7 @@ static inline void color_imageblit(const
 		val = 0;
 		
 		if (start_index) {
-			u32 start_mask = ~(SHIFT_HIGH(~(u32)0, start_index));
+			u32 start_mask = ~(FB_SHIFT_HIGH(~(u32)0, start_index));
 			val = FB_READL(dst) & start_mask;
 			shift = start_index;
 		}
@@ -119,20 +107,20 @@ static inline void color_imageblit(const
 				color = palette[*src];
 			else
 				color = *src;
-			color <<= LEFT_POS(bpp);
-			val |= SHIFT_HIGH(color, shift);
+			color <<= FB_LEFT_POS(bpp);
+			val |= FB_SHIFT_HIGH(color, shift);
 			if (shift >= null_bits) {
 				FB_WRITEL(val, dst++);
 	
 				val = (shift == null_bits) ? 0 : 
-					SHIFT_LOW(color, 32 - shift);
+					FB_SHIFT_LOW(color, 32 - shift);
 			}
 			shift += bpp;
 			shift &= (32 - 1);
 			src++;
 		}
 		if (shift) {
-			u32 end_mask = SHIFT_HIGH(~(u32)0, shift);
+			u32 end_mask = FB_SHIFT_HIGH(~(u32)0, shift);
 
 			FB_WRITEL((FB_READL(dst) & end_mask) | val, dst);
 		}
@@ -162,6 +150,8 @@ static inline void slow_imageblit(const 
 	u32 i, j, l;
 	
 	dst2 = (u32 __iomem *) dst1;
+	fgcolor <<= FB_LEFT_POS(bpp);
+	bgcolor <<= FB_LEFT_POS(bpp);
 
 	for (i = image->height; i--; ) {
 		shift = val = 0;
@@ -172,22 +162,21 @@ static inline void slow_imageblit(const 
 
 		/* write leading bits */
 		if (start_index) {
-			u32 start_mask = ~(SHIFT_HIGH(~(u32)0, start_index));
+			u32 start_mask = ~(FB_SHIFT_HIGH(~(u32)0,start_index));
 			val = FB_READL(dst) & start_mask;
 			shift = start_index;
 		}
 
 		while (j--) {
 			l--;
-			color = (*s & 1 << (BIT_NR(l))) ? fgcolor : bgcolor;
-			color <<= LEFT_POS(bpp);
-			val |= SHIFT_HIGH(color, shift);
+			color = (*s & 1 << (FB_BIT_NR(l))) ? fgcolor : bgcolor;
+			val |= FB_SHIFT_HIGH(color, shift);
 			
 			/* Did the bitshift spill bits to the next long? */
 			if (shift >= null_bits) {
 				FB_WRITEL(val, dst++);
 				val = (shift == null_bits) ? 0 :
-					 SHIFT_LOW(color,32 - shift);
+					FB_SHIFT_LOW(color,32 - shift);
 			}
 			shift += bpp;
 			shift &= (32 - 1);
@@ -196,7 +185,7 @@ static inline void slow_imageblit(const 
 
 		/* write trailing bits */
  		if (shift) {
-			u32 end_mask = SHIFT_HIGH(~(u32)0, shift);
+			u32 end_mask = FB_SHIFT_HIGH(~(u32)0, shift);
 
 			FB_WRITEL((FB_READL(dst) & end_mask) | val, dst);
 		}
diff --git a/drivers/video/cg14.c b/drivers/video/cg14.c
index 1bed50f..a561471 100644
--- a/drivers/video/cg14.c
+++ b/drivers/video/cg14.c
@@ -206,7 +206,6 @@ struct cg14_par {
 	int			mode;
 	int			ramsize;
 	struct sbus_dev		*sdev;
-	struct list_head	list;
 };
 
 static void __cg14_reset(struct cg14_par *par)
diff --git a/drivers/video/cg3.c b/drivers/video/cg3.c
index a1354e7..9fcd896 100644
--- a/drivers/video/cg3.c
+++ b/drivers/video/cg3.c
@@ -124,7 +124,6 @@ struct cg3_par {
 	unsigned long		fbsize;
 
 	struct sbus_dev		*sdev;
-	struct list_head	list;
 };
 
 /**
diff --git a/drivers/video/cg6.c b/drivers/video/cg6.c
index 9debe64..050835e 100644
--- a/drivers/video/cg6.c
+++ b/drivers/video/cg6.c
@@ -265,7 +265,6 @@ struct cg6_par {
 	unsigned long		fbsize;
 
 	struct sbus_dev		*sdev;
-	struct list_head	list;
 };
 
 static int cg6_sync(struct fb_info *info)
@@ -612,7 +611,7 @@ static void cg6_chip_init(struct fb_info
 	struct cg6_par *par = (struct cg6_par *) info->par;
 	struct cg6_tec __iomem *tec = par->tec;
 	struct cg6_fbc __iomem *fbc = par->fbc;
-	u32 rev, conf, mode, tmp;
+	u32 rev, conf, mode;
 	int i;
 	
 	/* Turn off stuff in the Transform Engine. */
diff --git a/drivers/video/console/fbcon.c b/drivers/video/console/fbcon.c
index bcea87c..3660e51 100644
--- a/drivers/video/console/fbcon.c
+++ b/drivers/video/console/fbcon.c
@@ -2048,7 +2048,7 @@ static int fbcon_switch(struct vc_data *
 	struct fbcon_ops *ops;
 	struct display *p = &fb_display[vc->vc_num];
 	struct fb_var_screeninfo var;
-	int i, prev_console;
+	int i, prev_console, charcnt = 256;
 
 	info = registered_fb[con2fb_map[vc->vc_num]];
 	ops = info->fbcon_par;
@@ -2103,7 +2103,8 @@ static int fbcon_switch(struct vc_data *
 	fb_set_var(info, &var);
 	ops->var = info->var;
 
-	if (old_info != NULL && old_info != info) {
+	if (old_info != NULL && (old_info != info ||
+				 info->flags & FBINFO_MISC_ALWAYS_SETPAR)) {
 		if (info->fbops->fb_set_par)
 			info->fbops->fb_set_par(info);
 		fbcon_del_cursor_timer(old_info);
@@ -2120,6 +2121,13 @@ static int fbcon_switch(struct vc_data *
 
 	vc->vc_can_do_color = (fb_get_color_depth(&info->var, &info->fix)!=1);
 	vc->vc_complement_mask = vc->vc_can_do_color ? 0x7700 : 0x0800;
+
+	if (p->userfont)
+		charcnt = FNTCHARCNT(vc->vc_font.data);
+
+	if (charcnt > 256)
+		vc->vc_complement_mask <<= 1;
+
 	updatescrollmode(p, info, vc);
 
 	switch (p->scrollmode) {
@@ -2139,8 +2147,12 @@ static int fbcon_switch(struct vc_data *
 
 	scrollback_max = 0;
 	scrollback_current = 0;
-	ops->var.xoffset = ops->var.yoffset = p->yscroll = 0;
-	ops->update_start(info);
+
+	if (!fbcon_is_inactive(vc, info)) {
+	    ops->var.xoffset = ops->var.yoffset = p->yscroll = 0;
+	    ops->update_start(info);
+	}
+
 	fbcon_set_palette(vc, color_table); 	
 	fbcon_clear_margins(vc, 0);
 
@@ -2184,11 +2196,14 @@ static int fbcon_blank(struct vc_data *v
 		ops->graphics = 1;
 
 		if (!blank) {
+			if (info->fbops->fb_save_state)
+				info->fbops->fb_save_state(info);
 			var.activate = FB_ACTIVATE_NOW | FB_ACTIVATE_FORCE;
 			fb_set_var(info, &var);
 			ops->graphics = 0;
 			ops->var = info->var;
-		}
+		} else if (info->fbops->fb_restore_state)
+			info->fbops->fb_restore_state(info);
 	}
 
  	if (!fbcon_is_inactive(vc, info)) {
@@ -2736,8 +2751,12 @@ static void fbcon_modechanged(struct fb_
 		updatescrollmode(p, info, vc);
 		scrollback_max = 0;
 		scrollback_current = 0;
-		ops->var.xoffset = ops->var.yoffset = p->yscroll = 0;
-		ops->update_start(info);
+
+		if (!fbcon_is_inactive(vc, info)) {
+		    ops->var.xoffset = ops->var.yoffset = p->yscroll = 0;
+		    ops->update_start(info);
+		}
+
 		fbcon_set_palette(vc, color_table);
 		update_screen(vc);
 		if (softback_buf)
@@ -2774,8 +2793,13 @@ static void fbcon_set_all_vcs(struct fb_
 			updatescrollmode(p, info, vc);
 			scrollback_max = 0;
 			scrollback_current = 0;
-			ops->var.xoffset = ops->var.yoffset = p->yscroll = 0;
-			ops->update_start(info);
+
+			if (!fbcon_is_inactive(vc, info)) {
+			    ops->var.xoffset = ops->var.yoffset =
+				p->yscroll = 0;
+			    ops->update_start(info);
+			}
+
 			fbcon_set_palette(vc, color_table);
 			update_screen(vc);
 			if (softback_buf)
diff --git a/drivers/video/fbmem.c b/drivers/video/fbmem.c
index 6240aed..10dfdf0 100644
--- a/drivers/video/fbmem.c
+++ b/drivers/video/fbmem.c
@@ -722,14 +722,30 @@ static void try_to_load(int fb)
 int
 fb_pan_display(struct fb_info *info, struct fb_var_screeninfo *var)
 {
+	struct fb_fix_screeninfo *fix = &info->fix;
         int xoffset = var->xoffset;
         int yoffset = var->yoffset;
-        int err;
+        int err = 0, yres = info->var.yres;
+
+	if (var->yoffset > 0) {
+		if (var->vmode & FB_VMODE_YWRAP) {
+			if (!fix->ywrapstep || (var->yoffset % fix->ywrapstep))
+				err = -EINVAL;
+			else
+				yres = 0;
+		} else if (!fix->ypanstep || (var->yoffset % fix->ypanstep))
+			err = -EINVAL;
+	}
+
+	if (var->xoffset > 0 && (!fix->xpanstep ||
+				 (var->xoffset % fix->xpanstep)))
+		err = -EINVAL;
+
+        if (err || !info->fbops->fb_pan_display || xoffset < 0 ||
+	    yoffset < 0 || var->yoffset + yres > info->var.yres_virtual ||
+	    var->xoffset + info->var.xres > info->var.xres_virtual)
+		return -EINVAL;
 
-        if (xoffset < 0 || yoffset < 0 || !info->fbops->fb_pan_display ||
-            xoffset + info->var.xres > info->var.xres_virtual ||
-            yoffset + info->var.yres > info->var.yres_virtual)
-                return -EINVAL;
 	if ((err = info->fbops->fb_pan_display(var, info)))
 		return err;
         info->var.xoffset = var->xoffset;
diff --git a/drivers/video/ffb.c b/drivers/video/ffb.c
index 2584dae..c4870d5 100644
--- a/drivers/video/ffb.c
+++ b/drivers/video/ffb.c
@@ -359,7 +359,6 @@ struct ffb_par {
 	int			prom_parent_node;
 	int			dac_rev;
 	int			board_type;
-	struct list_head	list;
 };
 
 static void FFBFifo(struct ffb_par *par, int n)
diff --git a/drivers/video/leo.c b/drivers/video/leo.c
index 376d4a1..494287f 100644
--- a/drivers/video/leo.c
+++ b/drivers/video/leo.c
@@ -197,7 +197,6 @@ struct leo_par {
 	unsigned long		fbsize;
 
 	struct sbus_dev		*sdev;
-	struct list_head	list;
 };
 
 static void leo_wait(struct leo_lx_krn __iomem *lx_krn)
diff --git a/drivers/video/p9100.c b/drivers/video/p9100.c
index 18bcda2..b251e75 100644
--- a/drivers/video/p9100.c
+++ b/drivers/video/p9100.c
@@ -140,7 +140,6 @@ struct p9100_par {
 	unsigned long		fbsize;
 
 	struct sbus_dev		*sdev;
-	struct list_head	list;
 };
 
 /**
diff --git a/drivers/video/tcx.c b/drivers/video/tcx.c
index fe4f63f..2b27b44 100644
--- a/drivers/video/tcx.c
+++ b/drivers/video/tcx.c
@@ -125,7 +125,6 @@ struct tcx_par {
 	int			lowdepth;
 
 	struct sbus_dev		*sdev;
-	struct list_head	list;
 };
 
 /* Reset control plane so that WID is 8-bit plane. */
@@ -444,7 +443,7 @@ static void tcx_init_one(struct sbus_dev
 
 	tcx_reset(&all->info);
 
-	tcx_blank(0, &all->info);
+	tcx_blank(FB_BLANK_UNBLANK, &all->info);
 
 	if (fb_alloc_cmap(&all->info.cmap, 256, 0)) {
 		printk(KERN_ERR "tcx: Could not allocate color map.\n");
diff --git a/fs/inotify.c b/fs/inotify.c
index bf7ce1d..2fecb7a 100644
--- a/fs/inotify.c
+++ b/fs/inotify.c
@@ -364,11 +364,12 @@ static int inotify_dev_get_wd(struct ino
 /*
  * find_inode - resolve a user-given path to a specific inode and return a nd
  */
-static int find_inode(const char __user *dirname, struct nameidata *nd)
+static int find_inode(const char __user *dirname, struct nameidata *nd,
+		      unsigned flags)
 {
 	int error;
 
-	error = __user_walk(dirname, LOOKUP_FOLLOW, nd);
+	error = __user_walk(dirname, flags, nd);
 	if (error)
 		return error;
 	/* you can only watch an inode if you have read permissions on it */
@@ -933,6 +934,7 @@ asmlinkage long sys_inotify_add_watch(in
 	struct file *filp;
 	int ret, fput_needed;
 	int mask_add = 0;
+	unsigned flags = 0;
 
 	filp = fget_light(fd, &fput_needed);
 	if (unlikely(!filp))
@@ -944,7 +946,12 @@ asmlinkage long sys_inotify_add_watch(in
 		goto fput_and_out;
 	}
 
-	ret = find_inode(path, &nd);
+	if (!(mask & IN_DONT_FOLLOW))
+		flags |= LOOKUP_FOLLOW;
+	if (mask & IN_ONLYDIR)
+		flags |= LOOKUP_DIRECTORY;
+
+	ret = find_inode(path, &nd, flags);
 	if (unlikely(ret))
 		goto fput_and_out;
 
diff --git a/fs/xattr.c b/fs/xattr.c
index a9db225..bcc2156 100644
--- a/fs/xattr.c
+++ b/fs/xattr.c
@@ -245,7 +245,7 @@ listxattr(struct dentry *d, char __user 
 		error = d->d_inode->i_op->listxattr(d, klist, size);
 	} else {
 		error = security_inode_listsecurity(d->d_inode, klist, size);
-		if (size && error >= size)
+		if (size && error > size)
 			error = -ERANGE;
 	}
 	if (error > 0) {
diff --git a/include/asm-arm/arch-pxa/irq.h b/include/asm-arm/arch-pxa/irq.h
index d770e4b..48c60f5 100644
--- a/include/asm-arm/arch-pxa/irq.h
+++ b/include/asm-arm/arch-pxa/irq.h
@@ -12,8 +12,3 @@
 
 #define fixup_irq(x)	(x)
 
-/*
- * This prototype is required for cascading of multiplexed interrupts.
- * Since it doesn't exist elsewhere, we'll put it here for now.
- */
-extern void do_IRQ(int irq, struct pt_regs *regs);
diff --git a/include/asm-arm/io.h b/include/asm-arm/io.h
index ae69db4..0cf4d4f 100644
--- a/include/asm-arm/io.h
+++ b/include/asm-arm/io.h
@@ -42,9 +42,9 @@ extern void __raw_writesb(void __iomem *
 extern void __raw_writesw(void __iomem *addr, const void *data, int wordlen);
 extern void __raw_writesl(void __iomem *addr, const void *data, int longlen);
 
-extern void __raw_readsb(void __iomem *addr, void *data, int bytelen);
-extern void __raw_readsw(void __iomem *addr, void *data, int wordlen);
-extern void __raw_readsl(void __iomem *addr, void *data, int longlen);
+extern void __raw_readsb(const void __iomem *addr, void *data, int bytelen);
+extern void __raw_readsw(const void __iomem *addr, void *data, int wordlen);
+extern void __raw_readsl(const void __iomem *addr, void *data, int longlen);
 
 #define __raw_writeb(v,a)	(__chk_io_ptr(a), *(volatile unsigned char __force  *)(a) = (v))
 #define __raw_writew(v,a)	(__chk_io_ptr(a), *(volatile unsigned short __force *)(a) = (v))
diff --git a/include/asm-arm/memory.h b/include/asm-arm/memory.h
index a547ee5..3e57236 100644
--- a/include/asm-arm/memory.h
+++ b/include/asm-arm/memory.h
@@ -122,6 +122,7 @@ static inline void *phys_to_virt(unsigne
  */
 #define __pa(x)			__virt_to_phys((unsigned long)(x))
 #define __va(x)			((void *)__phys_to_virt((unsigned long)(x)))
+#define pfn_to_kaddr(pfn)	__va((pfn) << PAGE_SHIFT)
 
 /*
  * Virtual <-> DMA view memory address translations
diff --git a/include/asm-ia64/ia32.h b/include/asm-ia64/ia32.h
index 8e746b2..f8044a1 100644
--- a/include/asm-ia64/ia32.h
+++ b/include/asm-ia64/ia32.h
@@ -13,6 +13,8 @@
 
 # ifdef CONFIG_IA32_SUPPORT
 
+#define IA32_PAGE_OFFSET	0xc0000000
+
 extern void ia32_cpu_init (void);
 extern void ia32_mem_init (void);
 extern void ia32_gdt_init (void);
diff --git a/include/asm-ia64/local.h b/include/asm-ia64/local.h
index 1dbd584..dc51909 100644
--- a/include/asm-ia64/local.h
+++ b/include/asm-ia64/local.h
@@ -17,8 +17,8 @@ typedef struct {
 #define local_set(l, i)	atomic64_set(&(l)->val, i)
 #define local_inc(l)	atomic64_inc(&(l)->val)
 #define local_dec(l)	atomic64_dec(&(l)->val)
-#define local_add(l)	atomic64_add(&(l)->val)
-#define local_sub(l)	atomic64_sub(&(l)->val)
+#define local_add(i, l)	atomic64_add((i), &(l)->val)
+#define local_sub(i, l)	atomic64_sub((i), &(l)->val)
 
 /* Non-atomic variants, i.e., preemption disabled and won't be touched in interrupt, etc.  */
 
diff --git a/include/asm-ia64/sn/pcidev.h b/include/asm-ia64/sn/pcidev.h
index 49711d0..f65d222 100644
--- a/include/asm-ia64/sn/pcidev.h
+++ b/include/asm-ia64/sn/pcidev.h
@@ -3,15 +3,27 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 1992 - 1997, 2000-2004 Silicon Graphics, Inc. All rights reserved.
+ * Copyright (C) 1992 - 1997, 2000-2005 Silicon Graphics, Inc. All rights reserved.
  */
 #ifndef _ASM_IA64_SN_PCI_PCIDEV_H
 #define _ASM_IA64_SN_PCI_PCIDEV_H
 
 #include <linux/pci.h>
 
-#define SN_PCIDEV_INFO(pci_dev) \
-        ((struct pcidev_info *)(pci_dev)->sysdata)
+/*
+ * In ia64, pci_dev->sysdata must be a *pci_controller. To provide access to
+ * the pcidev_info structs for all devices under a controller, we extend the
+ * definition of pci_controller, via sn_pci_controller, to include a list
+ * of pcidev_info.
+ */
+struct sn_pci_controller {
+	struct pci_controller pci_controller;
+	struct list_head pcidev_info;
+};
+
+#define SN_PCI_CONTROLLER(dev) ((struct sn_pci_controller *) dev->sysdata)
+
+#define SN_PCIDEV_INFO(dev)	sn_pcidev_info_get(dev)
 
 #define SN_PCIBUS_BUSSOFT_INFO(pci_bus) \
 	(struct pcibus_info *)((struct pcibus_bussoft *)(PCI_CONTROLLER((pci_bus))->platform_data))
@@ -53,11 +65,13 @@ struct pcidev_info {
 	struct sn_irq_info	*pdi_sn_irq_info;
 	struct sn_pcibus_provider *pdi_provider;	/* sn pci ops */
 	struct pci_dev 		*host_pci_dev;		/* host bus link */
+	struct list_head	pdi_list;		/* List of pcidev_info */
 };
 
 extern void sn_irq_fixup(struct pci_dev *pci_dev,
 			 struct sn_irq_info *sn_irq_info);
 extern void sn_irq_unfixup(struct pci_dev *pci_dev);
+extern struct pcidev_info * sn_pcidev_info_get(struct pci_dev *);
 extern void sn_pci_controller_fixup(int segment, int busnum,
  				    struct pci_bus *bus);
 extern void sn_bus_store_sysdata(struct pci_dev *dev);
diff --git a/include/asm-ia64/spinlock.h b/include/asm-ia64/spinlock.h
index 5b78611..0c91a76 100644
--- a/include/asm-ia64/spinlock.h
+++ b/include/asm-ia64/spinlock.h
@@ -201,6 +201,16 @@ static inline void __raw_write_unlock(ra
 
 #endif /* !ASM_SUPPORTED */
 
-#define __raw_read_trylock(lock) generic__raw_read_trylock(lock)
+static inline int __raw_read_trylock(raw_rwlock_t *x)
+{
+	union {
+		raw_rwlock_t lock;
+		__u32 word;
+	} old, new;
+	old.lock = new.lock = *x;
+	old.lock.write_lock = new.lock.write_lock = 0;
+	++new.lock.read_counter;
+	return (u32)ia64_cmpxchg4_acq((__u32 *)(x), new.word, old.word) == old.word;
+}
 
 #endif /*  _ASM_IA64_SPINLOCK_H */
diff --git a/include/asm-powerpc/mmu.h b/include/asm-powerpc/mmu.h
index c1b4bba..29b0bb0 100644
--- a/include/asm-powerpc/mmu.h
+++ b/include/asm-powerpc/mmu.h
@@ -220,7 +220,8 @@ extern int __hash_page_64K(unsigned long
 			   unsigned int local);
 struct mm_struct;
 extern int hash_huge_page(struct mm_struct *mm, unsigned long access,
-			  unsigned long ea, unsigned long vsid, int local);
+			  unsigned long ea, unsigned long vsid, int local,
+			  unsigned long trap);
 
 extern void htab_finish_init(void);
 extern int htab_bolt_mapping(unsigned long vstart, unsigned long vend,
diff --git a/include/linux/cn_proc.h b/include/linux/cn_proc.h
index c948f67..1417de9 100644
--- a/include/linux/cn_proc.h
+++ b/include/linux/cn_proc.h
@@ -26,6 +26,7 @@
 #define CN_PROC_H
 
 #include <linux/types.h>
+#include <linux/time.h>
 #include <linux/connector.h>
 
 /*
@@ -65,6 +66,7 @@ struct proc_event {
 		PROC_EVENT_EXIT = 0x80000000
 	} what;
 	__u32 cpu;
+	struct timespec timestamp;
 	union { /* must be last field of proc_event struct */
 		struct {
 			__u32 err;
diff --git a/include/linux/dvb/audio.h b/include/linux/dvb/audio.h
index cc31444..2b87970 100644
--- a/include/linux/dvb/audio.h
+++ b/include/linux/dvb/audio.h
@@ -32,39 +32,39 @@
 
 
 typedef enum {
-        AUDIO_SOURCE_DEMUX, /* Select the demux as the main source */
+	AUDIO_SOURCE_DEMUX, /* Select the demux as the main source */
 	AUDIO_SOURCE_MEMORY /* Select internal memory as the main source */
 } audio_stream_source_t;
 
 
 typedef enum {
 	AUDIO_STOPPED,      /* Device is stopped */
-        AUDIO_PLAYING,      /* Device is currently playing */
+	AUDIO_PLAYING,      /* Device is currently playing */
 	AUDIO_PAUSED        /* Device is paused */
 } audio_play_state_t;
 
 
 typedef enum {
-        AUDIO_STEREO,
-        AUDIO_MONO_LEFT,
+	AUDIO_STEREO,
+	AUDIO_MONO_LEFT,
 	AUDIO_MONO_RIGHT
 } audio_channel_select_t;
 
 
 typedef struct audio_mixer {
-        unsigned int volume_left;
-        unsigned int volume_right;
+	unsigned int volume_left;
+	unsigned int volume_right;
   // what else do we need? bass, pass-through, ...
 } audio_mixer_t;
 
 
 typedef struct audio_status {
-        int                    AV_sync_state;  /* sync audio and video? */
-        int                    mute_state;     /* audio is muted */
-        audio_play_state_t     play_state;     /* current playback state */
-        audio_stream_source_t  stream_source;  /* current stream source */
-        audio_channel_select_t channel_select; /* currently selected channel */
-        int                    bypass_mode;    /* pass on audio data to */
+	int                    AV_sync_state;  /* sync audio and video? */
+	int                    mute_state;     /* audio is muted */
+	audio_play_state_t     play_state;     /* current playback state */
+	audio_stream_source_t  stream_source;  /* current stream source */
+	audio_channel_select_t channel_select; /* currently selected channel */
+	int                    bypass_mode;    /* pass on audio data to */
 	audio_mixer_t	       mixer_state;    /* current mixer state */
 } audio_status_t;                              /* separate decoder hardware */
 
@@ -74,8 +74,8 @@ struct audio_karaoke{  /* if Vocal1 or V
 	int vocal1;    /* into left and right t at 70% each */
 	int vocal2;    /* if both, Vocal1 and Vocal2 are non-zero, Vocal1 gets*/
 	int melody;    /* mixed into the left channel and */
-                       /* Vocal2 into the right channel at 100% each. */
-                       /* if Melody is non-zero, the melody channel gets mixed*/
+		       /* Vocal2 into the right channel at 100% each. */
+		       /* if Melody is non-zero, the melody channel gets mixed*/
 } audio_karaoke_t;     /* into left and right  */
 
 
diff --git a/include/linux/dvb/ca.h b/include/linux/dvb/ca.h
index 558af0c..c18537f 100644
--- a/include/linux/dvb/ca.h
+++ b/include/linux/dvb/ca.h
@@ -27,16 +27,16 @@
 /* slot interface types and info */
 
 typedef struct ca_slot_info {
-        int num;               /* slot number */
+	int num;               /* slot number */
 
-        int type;              /* CA interface this slot supports */
+	int type;              /* CA interface this slot supports */
 #define CA_CI            1     /* CI high level interface */
 #define CA_CI_LINK       2     /* CI link layer level interface */
 #define CA_CI_PHYS       4     /* CI physical layer level interface */
 #define CA_DESCR         8     /* built-in descrambler */
 #define CA_SC          128     /* simple smart card interface */
 
-        unsigned int flags;
+	unsigned int flags;
 #define CA_CI_MODULE_PRESENT 1 /* module (or card) inserted */
 #define CA_CI_MODULE_READY   2
 } ca_slot_info_t;
@@ -45,37 +45,37 @@ typedef struct ca_slot_info {
 /* descrambler types and info */
 
 typedef struct ca_descr_info {
-        unsigned int num;          /* number of available descramblers (keys) */
-        unsigned int type;         /* type of supported scrambling system */
+	unsigned int num;          /* number of available descramblers (keys) */
+	unsigned int type;         /* type of supported scrambling system */
 #define CA_ECD           1
 #define CA_NDS           2
 #define CA_DSS           4
 } ca_descr_info_t;
 
 typedef struct ca_caps {
-        unsigned int slot_num;     /* total number of CA card and module slots */
-        unsigned int slot_type;    /* OR of all supported types */
-        unsigned int descr_num;    /* total number of descrambler slots (keys) */
-        unsigned int descr_type;   /* OR of all supported types */
+	unsigned int slot_num;     /* total number of CA card and module slots */
+	unsigned int slot_type;    /* OR of all supported types */
+	unsigned int descr_num;    /* total number of descrambler slots (keys) */
+	unsigned int descr_type;   /* OR of all supported types */
 } ca_caps_t;
 
 /* a message to/from a CI-CAM */
 typedef struct ca_msg {
-        unsigned int index;
-        unsigned int type;
-        unsigned int length;
-        unsigned char msg[256];
+	unsigned int index;
+	unsigned int type;
+	unsigned int length;
+	unsigned char msg[256];
 } ca_msg_t;
 
 typedef struct ca_descr {
-        unsigned int index;
-        unsigned int parity;	/* 0 == even, 1 == odd */
-        unsigned char cw[8];
+	unsigned int index;
+	unsigned int parity;	/* 0 == even, 1 == odd */
+	unsigned char cw[8];
 } ca_descr_t;
 
 typedef struct ca_pid {
-        unsigned int pid;
-        int index;		/* -1 == disable*/
+	unsigned int pid;
+	int index;		/* -1 == disable*/
 } ca_pid_t;
 
 #define CA_RESET          _IO('o', 128)
diff --git a/include/linux/dvb/dmx.h b/include/linux/dvb/dmx.h
index ce3f829..2787b8a 100644
--- a/include/linux/dvb/dmx.h
+++ b/include/linux/dvb/dmx.h
@@ -1,4 +1,4 @@
-/* 
+/*
  * dmx.h
  *
  * Copyright (C) 2000 Marcus Metzler <marcus@convergence.de>
@@ -38,10 +38,10 @@ typedef enum
 {
 	DMX_OUT_DECODER, /* Streaming directly to decoder. */
 	DMX_OUT_TAP,     /* Output going to a memory buffer */
-	                 /* (to be retrieved via the read command).*/
+			 /* (to be retrieved via the read command).*/
 	DMX_OUT_TS_TAP   /* Output multiplexed into a new TS  */
-	                 /* (to be retrieved by reading from the */
-	                 /* logical DVR device).                 */
+			 /* (to be retrieved by reading from the */
+			 /* logical DVR device).                 */
 } dmx_output_t;
 
 
@@ -54,25 +54,25 @@ typedef enum
 
 typedef enum
 {
-        DMX_PES_AUDIO0,
+	DMX_PES_AUDIO0,
 	DMX_PES_VIDEO0,
 	DMX_PES_TELETEXT0,
 	DMX_PES_SUBTITLE0,
 	DMX_PES_PCR0,
 
-        DMX_PES_AUDIO1,
+	DMX_PES_AUDIO1,
 	DMX_PES_VIDEO1,
 	DMX_PES_TELETEXT1,
 	DMX_PES_SUBTITLE1,
 	DMX_PES_PCR1,
 
-        DMX_PES_AUDIO2,
+	DMX_PES_AUDIO2,
 	DMX_PES_VIDEO2,
 	DMX_PES_TELETEXT2,
 	DMX_PES_SUBTITLE2,
 	DMX_PES_PCR2,
 
-        DMX_PES_AUDIO3,
+	DMX_PES_AUDIO3,
 	DMX_PES_VIDEO3,
 	DMX_PES_TELETEXT3,
 	DMX_PES_SUBTITLE3,
@@ -90,8 +90,8 @@ typedef enum
 
 typedef enum
 {
-        DMX_SCRAMBLING_EV,
-        DMX_FRONTEND_EV
+	DMX_SCRAMBLING_EV,
+	DMX_FRONTEND_EV
 } dmx_event_t;
 
 
diff --git a/include/linux/dvb/osd.h b/include/linux/dvb/osd.h
index 0e1973d..880e684 100644
--- a/include/linux/dvb/osd.h
+++ b/include/linux/dvb/osd.h
@@ -98,43 +98,43 @@ typedef enum {
 } OSD_Command;
 
 typedef struct osd_cmd_s {
-        OSD_Command cmd;
-        int x0;
-        int y0;
-        int x1;
-        int y1;
-        int color;
-        void __user *data;
+	OSD_Command cmd;
+	int x0;
+	int y0;
+	int x1;
+	int y1;
+	int color;
+	void __user *data;
 } osd_cmd_t;
 
 /* OSD_OpenRaw: set 'color' to desired window type */
 typedef enum {
-        OSD_BITMAP1,           /* 1 bit bitmap */
-        OSD_BITMAP2,           /* 2 bit bitmap */
-        OSD_BITMAP4,           /* 4 bit bitmap */
-        OSD_BITMAP8,           /* 8 bit bitmap */
-        OSD_BITMAP1HR,         /* 1 Bit bitmap half resolution */
-        OSD_BITMAP2HR,         /* 2 bit bitmap half resolution */
-        OSD_BITMAP4HR,         /* 4 bit bitmap half resolution */
-        OSD_BITMAP8HR,         /* 8 bit bitmap half resolution */
-        OSD_YCRCB422,          /* 4:2:2 YCRCB Graphic Display */
-        OSD_YCRCB444,          /* 4:4:4 YCRCB Graphic Display */
-        OSD_YCRCB444HR,        /* 4:4:4 YCRCB graphic half resolution */
-        OSD_VIDEOTSIZE,        /* True Size Normal MPEG Video Display */
-        OSD_VIDEOHSIZE,        /* MPEG Video Display Half Resolution */
-        OSD_VIDEOQSIZE,        /* MPEG Video Display Quarter Resolution */
-        OSD_VIDEODSIZE,        /* MPEG Video Display Double Resolution */
-        OSD_VIDEOTHSIZE,       /* True Size MPEG Video Display Half Resolution */
-        OSD_VIDEOTQSIZE,       /* True Size MPEG Video Display Quarter Resolution*/
-        OSD_VIDEOTDSIZE,       /* True Size MPEG Video Display Double Resolution */
-        OSD_VIDEONSIZE,        /* Full Size MPEG Video Display */
-        OSD_CURSOR             /* Cursor */
+	OSD_BITMAP1,           /* 1 bit bitmap */
+	OSD_BITMAP2,           /* 2 bit bitmap */
+	OSD_BITMAP4,           /* 4 bit bitmap */
+	OSD_BITMAP8,           /* 8 bit bitmap */
+	OSD_BITMAP1HR,         /* 1 Bit bitmap half resolution */
+	OSD_BITMAP2HR,         /* 2 bit bitmap half resolution */
+	OSD_BITMAP4HR,         /* 4 bit bitmap half resolution */
+	OSD_BITMAP8HR,         /* 8 bit bitmap half resolution */
+	OSD_YCRCB422,          /* 4:2:2 YCRCB Graphic Display */
+	OSD_YCRCB444,          /* 4:4:4 YCRCB Graphic Display */
+	OSD_YCRCB444HR,        /* 4:4:4 YCRCB graphic half resolution */
+	OSD_VIDEOTSIZE,        /* True Size Normal MPEG Video Display */
+	OSD_VIDEOHSIZE,        /* MPEG Video Display Half Resolution */
+	OSD_VIDEOQSIZE,        /* MPEG Video Display Quarter Resolution */
+	OSD_VIDEODSIZE,        /* MPEG Video Display Double Resolution */
+	OSD_VIDEOTHSIZE,       /* True Size MPEG Video Display Half Resolution */
+	OSD_VIDEOTQSIZE,       /* True Size MPEG Video Display Quarter Resolution*/
+	OSD_VIDEOTDSIZE,       /* True Size MPEG Video Display Double Resolution */
+	OSD_VIDEONSIZE,        /* Full Size MPEG Video Display */
+	OSD_CURSOR             /* Cursor */
 } osd_raw_window_t;
 
 typedef struct osd_cap_s {
-        int  cmd;
+	int  cmd;
 #define OSD_CAP_MEMSIZE         1  /* memory size */
-        long val;
+	long val;
 } osd_cap_t;
 
 
diff --git a/include/linux/dvb/video.h b/include/linux/dvb/video.h
index 941045e..b1999bf 100644
--- a/include/linux/dvb/video.h
+++ b/include/linux/dvb/video.h
@@ -36,7 +36,7 @@
 
 typedef enum {
 	VIDEO_FORMAT_4_3,     /* Select 4:3 format */
-        VIDEO_FORMAT_16_9,    /* Select 16:9 format. */
+	VIDEO_FORMAT_16_9,    /* Select 16:9 format. */
 	VIDEO_FORMAT_221_1    /* 2.21:1 */
 } video_format_t;
 
@@ -54,7 +54,7 @@ typedef enum {
 
 
 typedef enum {
-        VIDEO_PAN_SCAN,       /* use pan and scan format */
+	VIDEO_PAN_SCAN,       /* use pan and scan format */
 	VIDEO_LETTER_BOX,     /* use letterbox format */
 	VIDEO_CENTER_CUT_OUT  /* use center cut out format */
 } video_displayformat_t;
@@ -66,7 +66,7 @@ typedef struct {
 } video_size_t;
 
 typedef enum {
-        VIDEO_SOURCE_DEMUX, /* Select the demux as the main source */
+	VIDEO_SOURCE_DEMUX, /* Select the demux as the main source */
 	VIDEO_SOURCE_MEMORY /* If this source is selected, the stream
 			       comes from the user through the write
 			       system call */
@@ -75,35 +75,35 @@ typedef enum {
 
 typedef enum {
 	VIDEO_STOPPED, /* Video is stopped */
-        VIDEO_PLAYING, /* Video is currently playing */
+	VIDEO_PLAYING, /* Video is currently playing */
 	VIDEO_FREEZED  /* Video is freezed */
 } video_play_state_t;
 
 
 struct video_event {
-        int32_t type;
+	int32_t type;
 #define VIDEO_EVENT_SIZE_CHANGED	1
 #define VIDEO_EVENT_FRAME_RATE_CHANGED	2
-        time_t timestamp;
+	time_t timestamp;
 	union {
-	        video_size_t size;
+		video_size_t size;
 		unsigned int frame_rate;	/* in frames per 1000sec */
 	} u;
 };
 
 
 struct video_status {
-        int                   video_blank;   /* blank video on freeze? */
-        video_play_state_t    play_state;    /* current state of playback */
-        video_stream_source_t stream_source; /* current source (demux/memory) */
-        video_format_t        video_format;  /* current aspect ratio of stream*/
-        video_displayformat_t display_format;/* selected cropping mode */
+	int                   video_blank;   /* blank video on freeze? */
+	video_play_state_t    play_state;    /* current state of playback */
+	video_stream_source_t stream_source; /* current source (demux/memory) */
+	video_format_t        video_format;  /* current aspect ratio of stream*/
+	video_displayformat_t display_format;/* selected cropping mode */
 };
 
 
 struct video_still_picture {
-        char __user *iFrame;        /* pointer to a single iframe in memory */
-        int32_t size;
+	char __user *iFrame;        /* pointer to a single iframe in memory */
+	int32_t size;
 };
 
 
@@ -111,19 +111,19 @@ typedef
 struct video_highlight {
 	int     active;      /*    1=show highlight, 0=hide highlight */
 	uint8_t contrast1;   /*    7- 4  Pattern pixel contrast */
-                             /*    3- 0  Background pixel contrast */
+			     /*    3- 0  Background pixel contrast */
 	uint8_t contrast2;   /*    7- 4  Emphasis pixel-2 contrast */
-                             /*    3- 0  Emphasis pixel-1 contrast */
+			     /*    3- 0  Emphasis pixel-1 contrast */
 	uint8_t color1;      /*    7- 4  Pattern pixel color */
-                             /*    3- 0  Background pixel color */
+			     /*    3- 0  Background pixel color */
 	uint8_t color2;      /*    7- 4  Emphasis pixel-2 color */
-                             /*    3- 0  Emphasis pixel-1 color */
+			     /*    3- 0  Emphasis pixel-1 color */
 	uint32_t ypos;       /*   23-22  auto action mode */
-                             /*   21-12  start y */
-                             /*    9- 0  end y */
+			     /*   21-12  start y */
+			     /*    9- 0  end y */
 	uint32_t xpos;       /*   23-22  button color number */
-                             /*   21-12  start x */
-                             /*    9- 0  end x */
+			     /*   21-12  start x */
+			     /*    9- 0  end x */
 } video_highlight_t;
 
 
diff --git a/include/linux/fb.h b/include/linux/fb.h
index 04a58f3..a973be2 100644
--- a/include/linux/fb.h
+++ b/include/linux/fb.h
@@ -617,6 +617,12 @@ struct fb_ops {
 
 	/* perform fb specific mmap */
 	int (*fb_mmap)(struct fb_info *info, struct file *file, struct vm_area_struct *vma);
+
+	/* save current hardware state */
+	void (*fb_save_state)(struct fb_info *info);
+
+	/* restore saved state */
+	void (*fb_restore_state)(struct fb_info *info);
 };
 
 #ifdef CONFIG_FB_TILEBLITTING
@@ -726,6 +732,18 @@ struct fb_tile_ops {
 						  from userspace */
 #define FBINFO_MISC_TILEBLITTING       0x20000 /* use tile blitting */
 
+/* A driver may set this flag to indicate that it does want a set_par to be
+ * called every time when fbcon_switch is executed. The advantage is that with
+ * this flag set you can really be shure that set_par is always called before
+ * any of the functions dependant on the correct hardware state or altering
+ * that state, even if you are using some broken X releases. The disadvantage
+ * is that it introduces unwanted delays to every console switch if set_par
+ * is slow. It is a good idea to try this flag in the drivers initialization
+ * code whenever there is a bug report related to switching between X and the
+ * framebuffer console.
+ */
+#define FBINFO_MISC_ALWAYS_SETPAR   0x40000
+
 struct fb_info {
 	int node;
 	int flags;
@@ -817,6 +835,18 @@ struct fb_info {
 
 #endif
 
+#if defined (__BIG_ENDIAN)
+#define FB_LEFT_POS(bpp)          (32 - bpp)
+#define FB_SHIFT_HIGH(val, bits)  ((val) >> (bits))
+#define FB_SHIFT_LOW(val, bits)   ((val) << (bits))
+#define FB_BIT_NR(b)              (7 - (b))
+#else
+#define FB_LEFT_POS(bpp)          (0)
+#define FB_SHIFT_HIGH(val, bits)  ((val) << (bits))
+#define FB_SHIFT_LOW(val, bits)   ((val) >> (bits))
+#define FB_BIT_NR(b)              (b)
+#endif
+
     /*
      *  `Generic' versions of the frame buffer device operations
      */
diff --git a/include/linux/i2c-id.h b/include/linux/i2c-id.h
index ef3b563..006c81e 100644
--- a/include/linux/i2c-id.h
+++ b/include/linux/i2c-id.h
@@ -108,7 +108,7 @@
 #define I2C_DRIVERID_SAA7127	72	/* saa7124 video encoder	*/
 #define I2C_DRIVERID_SAA711X	73	/* saa711x video encoders	*/
 #define I2C_DRIVERID_AKITAIOEXP	74	/* IO Expander on Sharp SL-C1000 */
-#define I2C_DRIVERID_I2C_IR	75	/* I2C InfraRed on Video boards */
+#define I2C_DRIVERID_INFRARED	75	/* I2C InfraRed on Video boards */
 
 #define I2C_DRIVERID_EXP0	0xF0	/* experimental use id's	*/
 #define I2C_DRIVERID_EXP1	0xF1
diff --git a/include/linux/inotify.h b/include/linux/inotify.h
index ee5b239..267c88b 100644
--- a/include/linux/inotify.h
+++ b/include/linux/inotify.h
@@ -47,6 +47,8 @@ struct inotify_event {
 #define IN_MOVE			(IN_MOVED_FROM | IN_MOVED_TO) /* moves */
 
 /* special flags */
+#define IN_ONLYDIR		0x01000000	/* only watch the path if it is a directory */
+#define IN_DONT_FOLLOW		0x02000000	/* don't follow a sym link */
 #define IN_MASK_ADD		0x20000000	/* add to the mask of an already existing watch */
 #define IN_ISDIR		0x40000000	/* event occurred against dir */
 #define IN_ONESHOT		0x80000000	/* only send event once */
diff --git a/include/linux/kprobes.h b/include/linux/kprobes.h
index e373c4a..c03f2dc 100644
--- a/include/linux/kprobes.h
+++ b/include/linux/kprobes.h
@@ -37,6 +37,7 @@
 #include <linux/spinlock.h>
 #include <linux/rcupdate.h>
 
+#ifdef CONFIG_KPROBES
 #include <asm/kprobes.h>
 
 /* kprobe_status settings */
@@ -147,7 +148,6 @@ struct kretprobe_instance {
 	struct task_struct *task;
 };
 
-#ifdef CONFIG_KPROBES
 extern spinlock_t kretprobe_lock;
 extern int arch_prepare_kprobe(struct kprobe *p);
 extern void arch_copy_kprobe(struct kprobe *p);
@@ -158,6 +158,7 @@ extern int arch_init_kprobes(void);
 extern void show_registers(struct pt_regs *regs);
 extern kprobe_opcode_t *get_insn_slot(void);
 extern void free_insn_slot(kprobe_opcode_t *slot);
+extern void kprobes_inc_nmissed_count(struct kprobe *p);
 
 /* Get the kprobe at this addr (if any) - called with preemption disabled */
 struct kprobe *get_kprobe(void *addr);
@@ -195,6 +196,11 @@ void add_rp_inst(struct kretprobe_instan
 void kprobe_flush_task(struct task_struct *tk);
 void recycle_rp_inst(struct kretprobe_instance *ri);
 #else /* CONFIG_KPROBES */
+
+#define __kprobes	/**/
+struct jprobe;
+struct kretprobe;
+
 static inline struct kprobe *kprobe_running(void)
 {
 	return NULL;
diff --git a/include/linux/list.h b/include/linux/list.h
index fbfca73..8e33882 100644
--- a/include/linux/list.h
+++ b/include/linux/list.h
@@ -202,12 +202,15 @@ static inline void list_del_rcu(struct l
  *
  * The old entry will be replaced with the new entry atomically.
  */
-static inline void list_replace_rcu(struct list_head *old, struct list_head *new){
+static inline void list_replace_rcu(struct list_head *old,
+				struct list_head *new)
+{
 	new->next = old->next;
 	new->prev = old->prev;
 	smp_wmb();
 	new->next->prev = new;
 	new->prev->next = new;
+	old->prev = LIST_POISON2;
 }
 
 /**
@@ -578,6 +581,27 @@ static inline void hlist_del_init(struct
 	}
 }
 
+/*
+ * hlist_replace_rcu - replace old entry by new one
+ * @old : the element to be replaced
+ * @new : the new element to insert
+ *
+ * The old entry will be replaced with the new entry atomically.
+ */
+static inline void hlist_replace_rcu(struct hlist_node *old,
+					struct hlist_node *new)
+{
+	struct hlist_node *next = old->next;
+
+	new->next = next;
+	new->pprev = old->pprev;
+	smp_wmb();
+	if (next)
+		new->next->pprev = &new->next;
+	*new->pprev = new;
+	old->pprev = LIST_POISON2;
+}
+
 static inline void hlist_add_head(struct hlist_node *n, struct hlist_head *h)
 {
 	struct hlist_node *first = h->first;
diff --git a/include/linux/mm.h b/include/linux/mm.h
index 29f02d8..e5677f4 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -163,7 +163,6 @@ extern unsigned int kobjsize(const void 
 #define VM_HUGETLB	0x00400000	/* Huge TLB Page VM */
 #define VM_NONLINEAR	0x00800000	/* Is non-linear (remap_file_pages) */
 #define VM_MAPPED_COPY	0x01000000	/* T if mapped copy of data (nommu mmap) */
-#define VM_INCOMPLETE	0x02000000	/* Strange partial PFN mapping marker */
 
 #ifndef VM_STACK_DEFAULT_FLAGS		/* arch can override this */
 #define VM_STACK_DEFAULT_FLAGS VM_DATA_DEFAULT_FLAGS
diff --git a/include/linux/parport_pc.h b/include/linux/parport_pc.h
index 7825c76..c6f7624 100644
--- a/include/linux/parport_pc.h
+++ b/include/linux/parport_pc.h
@@ -86,7 +86,7 @@ extern __inline__ void dump_parport_stat
 	unsigned char dcr = inb (CONTROL (p));
 	unsigned char dsr = inb (STATUS (p));
 	static char *ecr_modes[] = {"SPP", "PS2", "PPFIFO", "ECP", "xXx", "yYy", "TST", "CFG"};
-	const struct parport_pc_private *priv = (parport_pc_private *)p->physport->private_data;
+	const struct parport_pc_private *priv = p->physport->private_data;
 	int i;
 
 	printk (KERN_DEBUG "*** parport state (%s): ecr=[%s", str, ecr_modes[(ecr & 0xe0) >> 5]);
diff --git a/include/linux/rcupdate.h b/include/linux/rcupdate.h
index cce2559..a471f3b 100644
--- a/include/linux/rcupdate.h
+++ b/include/linux/rcupdate.h
@@ -100,6 +100,7 @@ struct rcu_data {
 	struct rcu_head *donelist;
 	struct rcu_head **donetail;
 	int cpu;
+	struct rcu_head barrier;
 };
 
 DECLARE_PER_CPU(struct rcu_data, rcu_data);
@@ -285,6 +286,7 @@ extern void FASTCALL(call_rcu_bh(struct 
 extern __deprecated_for_modules void synchronize_kernel(void);
 extern void synchronize_rcu(void);
 void synchronize_idle(void);
+extern void rcu_barrier(void);
 
 #endif /* __KERNEL__ */
 #endif /* __LINUX_RCUPDATE_H */
diff --git a/include/linux/sysctl.h b/include/linux/sysctl.h
index 6bc03c9..4be34ef 100644
--- a/include/linux/sysctl.h
+++ b/include/linux/sysctl.h
@@ -670,6 +670,9 @@ enum {
 	NET_DECNET_DST_GC_INTERVAL = 9,
 	NET_DECNET_CONF = 10,
 	NET_DECNET_NO_FC_MAX_CWND = 11,
+	NET_DECNET_MEM = 12,
+	NET_DECNET_RMEM = 13,
+	NET_DECNET_WMEM = 14,
 	NET_DECNET_DEBUG_LEVEL = 255
 };
 
diff --git a/include/linux/time.h b/include/linux/time.h
index bfbe92d..797ccd8 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -95,6 +95,7 @@ struct itimerval;
 extern int do_setitimer(int which, struct itimerval *value, struct itimerval *ovalue);
 extern int do_getitimer(int which, struct itimerval *value);
 extern void getnstimeofday (struct timespec *tv);
+extern void getnstimestamp(struct timespec *ts);
 
 extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
 
diff --git a/include/media/saa7146.h b/include/media/saa7146.h
index 2a897c3..e5be2b9 100644
--- a/include/media/saa7146.h
+++ b/include/media/saa7146.h
@@ -14,7 +14,7 @@
 #include <linux/vmalloc.h>	/* for vmalloc() */
 #include <linux/mm.h>		/* for vmalloc_to_page() */
 
-#define SAA7146_VERSION_CODE 0x000500   /* 0.5.0 */
+#define SAA7146_VERSION_CODE 0x000500	/* 0.5.0 */
 
 #define saa7146_write(sxy,adr,dat)    writel((dat),(sxy->mem+(adr)))
 #define saa7146_read(sxy,adr)         readl(sxy->mem+(adr))
@@ -112,7 +112,7 @@ struct saa7146_dev
 
 	/* different device locks */
 	spinlock_t			slock;
-        struct semaphore		lock;
+	struct semaphore		lock;
 
 	unsigned char			__iomem *mem;		/* pointer to mapped IO memory */
 	int				revision;	/* chip revision; needed for bug-workarounds*/
@@ -133,7 +133,7 @@ struct saa7146_dev
 	void (*vv_callback)(struct saa7146_dev *dev, unsigned long status);
 
 	/* i2c-stuff */
-        struct semaphore	i2c_lock;
+	struct semaphore	i2c_lock;
 	u32			i2c_bitrate;
 	struct saa7146_dma	d_i2c;	/* pointer to i2c memory */
 	wait_queue_head_t	i2c_wq;
diff --git a/include/media/saa7146_vv.h b/include/media/saa7146_vv.h
index 6469175..16af929 100644
--- a/include/media/saa7146_vv.h
+++ b/include/media/saa7146_vv.h
@@ -113,7 +113,7 @@ struct saa7146_vv
 	/* vbi capture */
 	struct saa7146_dmaqueue		vbi_q;
 	/* vbi workaround interrupt queue */
-        wait_queue_head_t		vbi_wq;
+	wait_queue_head_t		vbi_wq;
 	int				vbi_fieldcount;
 	struct saa7146_fh		*vbi_streaming;
 
@@ -181,10 +181,10 @@ struct saa7146_ext_vv
 };
 
 struct saa7146_use_ops  {
-        void (*init)(struct saa7146_dev *, struct saa7146_vv *);
-        int(*open)(struct saa7146_dev *, struct file *);
-        void (*release)(struct saa7146_dev *, struct file *);
-        void (*irq_done)(struct saa7146_dev *, unsigned long status);
+	void (*init)(struct saa7146_dev *, struct saa7146_vv *);
+	int(*open)(struct saa7146_dev *, struct file *);
+	void (*release)(struct saa7146_dev *, struct file *);
+	void (*irq_done)(struct saa7146_dev *, unsigned long status);
 	ssize_t (*read)(struct file *, char __user *, size_t, loff_t *);
 };
 
diff --git a/include/net/dn.h b/include/net/dn.h
index c1dbbd2..a4b6168 100644
--- a/include/net/dn.h
+++ b/include/net/dn.h
@@ -234,4 +234,8 @@ extern int decnet_di_count;
 extern int decnet_dr_count;
 extern int decnet_no_fc_max_cwnd;
 
+extern int sysctl_decnet_mem[3];
+extern int sysctl_decnet_wmem[3];
+extern int sysctl_decnet_rmem[3];
+
 #endif /* _NET_DN_H */
diff --git a/kernel/audit.c b/kernel/audit.c
index 0c56320..32fa03a 100644
--- a/kernel/audit.c
+++ b/kernel/audit.c
@@ -291,8 +291,10 @@ int kauditd_thread(void *dummy)
 			set_current_state(TASK_INTERRUPTIBLE);
 			add_wait_queue(&kauditd_wait, &wait);
 
-			if (!skb_queue_len(&audit_skb_queue))
+			if (!skb_queue_len(&audit_skb_queue)) {
+				try_to_freeze();
 				schedule();
+			}
 
 			__set_current_state(TASK_RUNNING);
 			remove_wait_queue(&kauditd_wait, &wait);
diff --git a/kernel/kprobes.c b/kernel/kprobes.c
index 5beda37..3bb71e6 100644
--- a/kernel/kprobes.c
+++ b/kernel/kprobes.c
@@ -246,6 +246,19 @@ static int __kprobes aggr_break_handler(
 	return ret;
 }
 
+/* Walks the list and increments nmissed count for multiprobe case */
+void __kprobes kprobes_inc_nmissed_count(struct kprobe *p)
+{
+	struct kprobe *kp;
+	if (p->pre_handler != aggr_pre_handler) {
+		p->nmissed++;
+	} else {
+		list_for_each_entry_rcu(kp, &p->list, list)
+			kp->nmissed++;
+	}
+	return;
+}
+
 /* Called with kretprobe_lock held */
 struct kretprobe_instance __kprobes *get_free_rp_inst(struct kretprobe *rp)
 {
@@ -399,10 +412,7 @@ static inline void add_aggr_kprobe(struc
 	INIT_LIST_HEAD(&ap->list);
 	list_add_rcu(&p->list, &ap->list);
 
-	INIT_HLIST_NODE(&ap->hlist);
-	hlist_del_rcu(&p->hlist);
-	hlist_add_head_rcu(&ap->hlist,
-		&kprobe_table[hash_ptr(ap->addr, KPROBE_HASH_BITS)]);
+	hlist_replace_rcu(&p->hlist, &ap->hlist);
 }
 
 /*
@@ -462,9 +472,16 @@ int __kprobes register_kprobe(struct kpr
 	int ret = 0;
 	unsigned long flags = 0;
 	struct kprobe *old_p;
+	struct module *mod;
+
+	if ((!kernel_text_address((unsigned long) p->addr)) ||
+		in_kprobes_functions((unsigned long) p->addr))
+		return -EINVAL;
+
+	if ((mod = module_text_address((unsigned long) p->addr)) &&
+			(unlikely(!try_module_get(mod))))
+		return -EINVAL;
 
-	if ((ret = in_kprobes_functions((unsigned long) p->addr)) != 0)
-		return ret;
 	if ((ret = arch_prepare_kprobe(p)) != 0)
 		goto rm_kprobe;
 
@@ -488,6 +505,8 @@ out:
 rm_kprobe:
 	if (ret == -EEXIST)
 		arch_remove_kprobe(p);
+	if (ret && mod)
+		module_put(mod);
 	return ret;
 }
 
@@ -495,6 +514,7 @@ void __kprobes unregister_kprobe(struct 
 {
 	unsigned long flags;
 	struct kprobe *old_p;
+	struct module *mod;
 
 	spin_lock_irqsave(&kprobe_lock, flags);
 	old_p = get_kprobe(p->addr);
@@ -506,6 +526,10 @@ void __kprobes unregister_kprobe(struct 
 			cleanup_kprobe(p, flags);
 
 		synchronize_sched();
+
+		if ((mod = module_text_address((unsigned long)p->addr)))
+			module_put(mod);
+
 		if (old_p->pre_handler == aggr_pre_handler &&
 				list_empty(&old_p->list))
 			kfree(old_p);
diff --git a/kernel/rcupdate.c b/kernel/rcupdate.c
index c4d159a..48d3bce 100644
--- a/kernel/rcupdate.c
+++ b/kernel/rcupdate.c
@@ -116,6 +116,10 @@ void fastcall call_rcu(struct rcu_head *
 	local_irq_restore(flags);
 }
 
+static atomic_t rcu_barrier_cpu_count;
+static struct semaphore rcu_barrier_sema;
+static struct completion rcu_barrier_completion;
+
 /**
  * call_rcu_bh - Queue an RCU for invocation after a quicker grace period.
  * @head: structure to be used for queueing the RCU updates.
@@ -162,6 +166,42 @@ long rcu_batches_completed(void)
 	return rcu_ctrlblk.completed;
 }
 
+static void rcu_barrier_callback(struct rcu_head *notused)
+{
+	if (atomic_dec_and_test(&rcu_barrier_cpu_count))
+		complete(&rcu_barrier_completion);
+}
+
+/*
+ * Called with preemption disabled, and from cross-cpu IRQ context.
+ */
+static void rcu_barrier_func(void *notused)
+{
+	int cpu = smp_processor_id();
+	struct rcu_data *rdp = &per_cpu(rcu_data, cpu);
+	struct rcu_head *head;
+
+	head = &rdp->barrier;
+	atomic_inc(&rcu_barrier_cpu_count);
+	call_rcu(head, rcu_barrier_callback);
+}
+
+/**
+ * rcu_barrier - Wait until all the in-flight RCUs are complete.
+ */
+void rcu_barrier(void)
+{
+	BUG_ON(in_interrupt());
+	/* Take cpucontrol semaphore to protect against CPU hotplug */
+	down(&rcu_barrier_sema);
+	init_completion(&rcu_barrier_completion);
+	atomic_set(&rcu_barrier_cpu_count, 0);
+	on_each_cpu(rcu_barrier_func, NULL, 0, 1);
+	wait_for_completion(&rcu_barrier_completion);
+	up(&rcu_barrier_sema);
+}
+EXPORT_SYMBOL_GPL(rcu_barrier);
+
 /*
  * Invoke the completed RCU callbacks. They are expected to be in
  * a per-cpu list.
@@ -217,15 +257,23 @@ static void rcu_start_batch(struct rcu_c
 
 	if (rcp->next_pending &&
 			rcp->completed == rcp->cur) {
-		/* Can't change, since spin lock held. */
-		cpus_andnot(rsp->cpumask, cpu_online_map, nohz_cpu_mask);
-
 		rcp->next_pending = 0;
-		/* next_pending == 0 must be visible in __rcu_process_callbacks()
-		 * before it can see new value of cur.
+		/*
+		 * next_pending == 0 must be visible in
+		 * __rcu_process_callbacks() before it can see new value of cur.
 		 */
 		smp_wmb();
 		rcp->cur++;
+
+		/*
+		 * Accessing nohz_cpu_mask before incrementing rcp->cur needs a
+		 * Barrier  Otherwise it can cause tickless idle CPUs to be
+		 * included in rsp->cpumask, which will extend graceperiods
+		 * unnecessarily.
+		 */
+		smp_mb();
+		cpus_andnot(rsp->cpumask, cpu_online_map, nohz_cpu_mask);
+
 	}
 }
 
@@ -457,6 +505,7 @@ static struct notifier_block __devinitda
  */
 void __init rcu_init(void)
 {
+	sema_init(&rcu_barrier_sema, 1);
 	rcu_cpu_notify(&rcu_nb, CPU_UP_PREPARE,
 			(void *)(long)smp_processor_id());
 	/* Register notifier for non-boot CPUs */
diff --git a/kernel/rcutorture.c b/kernel/rcutorture.c
index 88c28d4..49fbbef 100644
--- a/kernel/rcutorture.c
+++ b/kernel/rcutorture.c
@@ -409,9 +409,8 @@ rcu_torture_cleanup(void)
 	stats_task = NULL;
 
 	/* Wait for all RCU callbacks to fire.  */
+	rcu_barrier();
 
-	for (i = 0; i < RCU_TORTURE_PIPE_LEN; i++)
-		synchronize_rcu();
 	rcu_torture_stats_print();  /* -After- the stats thread is stopped! */
 	printk(KERN_ALERT TORTURE_FLAG
 	       "--- End of test: %s\n",
diff --git a/kernel/sys.c b/kernel/sys.c
index bce933e..eecf845 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -32,6 +32,7 @@
 
 #include <linux/compat.h>
 #include <linux/syscalls.h>
+#include <linux/kprobes.h>
 
 #include <asm/uaccess.h>
 #include <asm/io.h>
@@ -168,7 +169,7 @@ EXPORT_SYMBOL(notifier_chain_unregister)
  *	of the last notifier function called.
  */
  
-int notifier_call_chain(struct notifier_block **n, unsigned long val, void *v)
+int __kprobes notifier_call_chain(struct notifier_block **n, unsigned long val, void *v)
 {
 	int ret=NOTIFY_DONE;
 	struct notifier_block *nb = *n;
diff --git a/kernel/time.c b/kernel/time.c
index 245d595..b94bfa8 100644
--- a/kernel/time.c
+++ b/kernel/time.c
@@ -561,6 +561,28 @@ void getnstimeofday(struct timespec *tv)
 EXPORT_SYMBOL_GPL(getnstimeofday);
 #endif
 
+void getnstimestamp(struct timespec *ts)
+{
+	unsigned int seq;
+	struct timespec wall2mono;
+
+	/* synchronize with settimeofday() changes */
+	do {
+		seq = read_seqbegin(&xtime_lock);
+		getnstimeofday(ts);
+		wall2mono = wall_to_monotonic;
+	} while(unlikely(read_seqretry(&xtime_lock, seq)));
+
+	/* adjust to monotonicaly-increasing values */
+	ts->tv_sec += wall2mono.tv_sec;
+	ts->tv_nsec += wall2mono.tv_nsec;
+	while (unlikely(ts->tv_nsec >= NSEC_PER_SEC)) {
+		ts->tv_nsec -= NSEC_PER_SEC;
+		ts->tv_sec++;
+	}
+}
+EXPORT_SYMBOL_GPL(getnstimestamp);
+
 #if (BITS_PER_LONG < 64)
 u64 get_jiffies_64(void)
 {
diff --git a/mm/bootmem.c b/mm/bootmem.c
index e8c5671..16b9465 100644
--- a/mm/bootmem.c
+++ b/mm/bootmem.c
@@ -204,6 +204,8 @@ restart_scan:
 		unsigned long j;
 		i = find_next_zero_bit(bdata->node_bootmem_map, eidx, i);
 		i = ALIGN(i, incr);
+		if (i >= eidx)
+			break;
 		if (test_bit(i, bdata->node_bootmem_map))
 			continue;
 		for (j = i + 1; j < i + areasize; ++j) {
diff --git a/mm/memory.c b/mm/memory.c
index aa8af0e..d22f78c 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -349,6 +349,11 @@ void print_bad_pte(struct vm_area_struct
 	dump_stack();
 }
 
+static inline int is_cow_mapping(unsigned int flags)
+{
+	return (flags & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;
+}
+
 /*
  * This function gets the "struct page" associated with a pte.
  *
@@ -377,6 +382,8 @@ struct page *vm_normal_page(struct vm_ar
 		unsigned long off = (addr - vma->vm_start) >> PAGE_SHIFT;
 		if (pfn == vma->vm_pgoff + off)
 			return NULL;
+		if (!is_cow_mapping(vma->vm_flags))
+			return NULL;
 	}
 
 	/*
@@ -437,7 +444,7 @@ copy_one_pte(struct mm_struct *dst_mm, s
 	 * If it's a COW mapping, write protect it both
 	 * in the parent and the child
 	 */
-	if ((vm_flags & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE) {
+	if (is_cow_mapping(vm_flags)) {
 		ptep_set_wrprotect(src_mm, addr, src_pte);
 		pte = *src_pte;
 	}
@@ -1002,7 +1009,7 @@ int get_user_pages(struct task_struct *t
 			continue;
 		}
 
-		if (!vma || (vma->vm_flags & VM_IO)
+		if (!vma || (vma->vm_flags & (VM_IO | VM_PFNMAP))
 				|| !(vm_flags & vma->vm_flags))
 			return i ? : -EFAULT;
 
@@ -1226,50 +1233,6 @@ int vm_insert_page(struct vm_area_struct
 EXPORT_SYMBOL(vm_insert_page);
 
 /*
- * Somebody does a pfn remapping that doesn't actually work as a vma.
- *
- * Do it as individual pages instead, and warn about it. It's bad form,
- * and very inefficient.
- */
-static int incomplete_pfn_remap(struct vm_area_struct *vma,
-		unsigned long start, unsigned long end,
-		unsigned long pfn, pgprot_t prot)
-{
-	static int warn = 10;
-	struct page *page;
-	int retval;
-
-	if (!(vma->vm_flags & VM_INCOMPLETE)) {
-		if (warn) {
-			warn--;
-			printk("%s does an incomplete pfn remapping", current->comm);
-			dump_stack();
-		}
-	}
-	vma->vm_flags |= VM_INCOMPLETE | VM_IO | VM_RESERVED;
-
-	if (start < vma->vm_start || end > vma->vm_end)
-		return -EINVAL;
-
-	if (!pfn_valid(pfn))
-		return -EINVAL;
-
-	page = pfn_to_page(pfn);
-	if (!PageReserved(page))
-		return -EINVAL;
-
-	retval = 0;
-	while (start < end) {
-		retval = insert_page(vma->vm_mm, start, page, prot);
-		if (retval < 0)
-			break;
-		start += PAGE_SIZE;
-		page++;
-	}
-	return retval;
-}
-
-/*
  * maps a range of physical memory into the requested pages. the old
  * mappings are removed. any references to nonexistent pages results
  * in null mappings (currently treated as "copy-on-access")
@@ -1343,9 +1306,6 @@ int remap_pfn_range(struct vm_area_struc
 	struct mm_struct *mm = vma->vm_mm;
 	int err;
 
-	if (addr != vma->vm_start || end != vma->vm_end)
-		return incomplete_pfn_remap(vma, addr, end, pfn, prot);
-
 	/*
 	 * Physically remapped pages are special. Tell the
 	 * rest of the world about it:
@@ -1359,9 +1319,18 @@ int remap_pfn_range(struct vm_area_struc
 	 *   VM_PFNMAP tells the core MM that the base pages are just
 	 *	raw PFN mappings, and do not have a "struct page" associated
 	 *	with them.
+	 *
+	 * There's a horrible special case to handle copy-on-write
+	 * behaviour that some programs depend on. We mark the "original"
+	 * un-COW'ed pages by matching them up with "vma->vm_pgoff".
 	 */
+	if (is_cow_mapping(vma->vm_flags)) {
+		if (addr != vma->vm_start || end != vma->vm_end)
+			return -EINVAL;
+		vma->vm_pgoff = pfn;
+	}
+
 	vma->vm_flags |= VM_IO | VM_RESERVED | VM_PFNMAP;
-	vma->vm_pgoff = pfn;
 
 	BUG_ON(addr >= end);
 	pfn -= addr >> PAGE_SHIFT;
diff --git a/net/core/dev.c b/net/core/dev.c
index 0b48e29..a5efc9a 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -1113,7 +1113,8 @@ out:	
 void netdev_rx_csum_fault(struct net_device *dev)
 {
 	if (net_ratelimit()) {
-		printk(KERN_ERR "%s: hw csum failure.\n", dev->name);
+		printk(KERN_ERR "%s: hw csum failure.\n", 
+			dev ? dev->name : "<unknown>");
 		dump_stack();
 	}
 }
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index b7d13a4..83fee37 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -1725,7 +1725,7 @@ unsigned int skb_find_text(struct sk_buf
  * of the skb if any page alloc fails user this procedure returns  -ENOMEM
  */
 int skb_append_datato_frags(struct sock *sk, struct sk_buff *skb,
-			int getfrag(void *from, char *to, int offset,
+			int (*getfrag)(void *from, char *to, int offset,
 					int len, int odd, struct sk_buff *skb),
 			void *from, int length)
 {
diff --git a/net/decnet/af_decnet.c b/net/decnet/af_decnet.c
index f89e55f..d402e90 100644
--- a/net/decnet/af_decnet.c
+++ b/net/decnet/af_decnet.c
@@ -153,6 +153,7 @@ static struct proto_ops dn_proto_ops;
 static DEFINE_RWLOCK(dn_hash_lock);
 static struct hlist_head dn_sk_hash[DN_SK_HASH_SIZE];
 static struct hlist_head dn_wild_sk;
+static atomic_t decnet_memory_allocated;
 
 static int __dn_setsockopt(struct socket *sock, int level, int optname, char __user *optval, int optlen, int flags);
 static int __dn_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen, int flags);
@@ -446,10 +447,26 @@ static void dn_destruct(struct sock *sk)
 	dst_release(xchg(&sk->sk_dst_cache, NULL));
 }
 
+static int dn_memory_pressure;
+
+static void dn_enter_memory_pressure(void)
+{
+	if (!dn_memory_pressure) {
+		dn_memory_pressure = 1;
+	}
+}
+
 static struct proto dn_proto = {
-	.name	  = "DECNET",
-	.owner	  = THIS_MODULE,
-	.obj_size = sizeof(struct dn_sock),
+	.name			= "NSP",
+	.owner			= THIS_MODULE,
+	.enter_memory_pressure	= dn_enter_memory_pressure,
+	.memory_pressure	= &dn_memory_pressure,
+	.memory_allocated	= &decnet_memory_allocated,
+	.sysctl_mem		= sysctl_decnet_mem,
+	.sysctl_wmem		= sysctl_decnet_wmem,
+	.sysctl_rmem		= sysctl_decnet_rmem,
+	.max_header		= DN_MAX_NSP_DATA_HEADER + 64,
+	.obj_size		= sizeof(struct dn_sock),
 };
 
 static struct sock *dn_alloc_sock(struct socket *sock, gfp_t gfp)
@@ -470,6 +487,8 @@ static struct sock *dn_alloc_sock(struct
 	sk->sk_family      = PF_DECnet;
 	sk->sk_protocol    = 0;
 	sk->sk_allocation  = gfp;
+	sk->sk_sndbuf	   = sysctl_decnet_wmem[1];
+	sk->sk_rcvbuf	   = sysctl_decnet_rmem[1];
 
 	/* Initialization of DECnet Session Control Port		*/
 	scp = DN_SK(sk);
diff --git a/net/decnet/sysctl_net_decnet.c b/net/decnet/sysctl_net_decnet.c
index 02bca49..0e9d2c5 100644
--- a/net/decnet/sysctl_net_decnet.c
+++ b/net/decnet/sysctl_net_decnet.c
@@ -10,6 +10,7 @@
  *
  * Changes:
  * Steve Whitehouse - C99 changes and default device handling
+ * Steve Whitehouse - Memory buffer settings, like the tcp ones
  *
  */
 #include <linux/config.h>
@@ -37,6 +38,11 @@ int decnet_dr_count = 3;
 int decnet_log_martians = 1;
 int decnet_no_fc_max_cwnd = NSP_MIN_WINDOW;
 
+/* Reasonable defaults, I hope, based on tcp's defaults */
+int sysctl_decnet_mem[3] = { 768 << 3, 1024 << 3, 1536 << 3 };
+int sysctl_decnet_wmem[3] = { 4 * 1024, 16 * 1024, 128 * 1024 };
+int sysctl_decnet_rmem[3] = { 4 * 1024, 87380, 87380 * 2 };
+
 #ifdef CONFIG_SYSCTL
 extern int decnet_dst_gc_interval;
 static int min_decnet_time_wait[] = { 5 };
@@ -428,6 +434,33 @@ static ctl_table dn_table[] = {
 		.extra1 = &min_decnet_no_fc_max_cwnd,
 		.extra2 = &max_decnet_no_fc_max_cwnd
 	},
+       {
+                .ctl_name = NET_DECNET_MEM,
+                .procname = "decnet_mem",
+                .data = &sysctl_decnet_mem,
+                .maxlen = sizeof(sysctl_decnet_mem),
+                .mode = 0644,
+                .proc_handler = &proc_dointvec,
+                .strategy = &sysctl_intvec,
+        },
+        {
+                .ctl_name = NET_DECNET_RMEM,
+                .procname = "decnet_rmem",
+                .data = &sysctl_decnet_rmem,
+                .maxlen = sizeof(sysctl_decnet_rmem),
+                .mode = 0644,
+                .proc_handler = &proc_dointvec,
+                .strategy = &sysctl_intvec,
+        },
+        {
+                .ctl_name = NET_DECNET_WMEM,
+                .procname = "decnet_wmem",
+                .data = &sysctl_decnet_wmem,
+                .maxlen = sizeof(sysctl_decnet_wmem),
+                .mode = 0644,
+                .proc_handler = &proc_dointvec,
+                .strategy = &sysctl_intvec,
+        },
 	{
 		.ctl_name = NET_DECNET_DEBUG_LEVEL,
 		.procname = "debug",
diff --git a/net/ieee80211/Kconfig b/net/ieee80211/Kconfig
index 91b16fb..d18ccba 100644
--- a/net/ieee80211/Kconfig
+++ b/net/ieee80211/Kconfig
@@ -55,7 +55,7 @@ config IEEE80211_CRYPT_CCMP
 
 config IEEE80211_CRYPT_TKIP
 	tristate "IEEE 802.11i TKIP encryption"
-	depends on IEEE80211
+	depends on IEEE80211 && NET_RADIO
 	select CRYPTO
 	select CRYPTO_MICHAEL_MIC
 	---help---
diff --git a/net/ipv4/netfilter/Kconfig b/net/ipv4/netfilter/Kconfig
index 0bc0052..88a6065 100644
--- a/net/ipv4/netfilter/Kconfig
+++ b/net/ipv4/netfilter/Kconfig
@@ -56,8 +56,8 @@ config IP_NF_CONNTRACK_MARK
 	  instead of the individual packets.
 	
 config IP_NF_CONNTRACK_EVENTS
-	bool "Connection tracking events"
-	depends on IP_NF_CONNTRACK
+	bool "Connection tracking events (EXPERIMENTAL)"
+	depends on EXPERIMENTAL && IP_NF_CONNTRACK
 	help
 	  If this option is enabled, the connection tracking code will
 	  provide a notifier chain that can be used by other kernel code
@@ -66,8 +66,8 @@ config IP_NF_CONNTRACK_EVENTS
 	  IF unsure, say `N'.
 
 config IP_NF_CONNTRACK_NETLINK
-	tristate 'Connection tracking netlink interface'
-	depends on IP_NF_CONNTRACK && NETFILTER_NETLINK
+	tristate 'Connection tracking netlink interface (EXPERIMENTAL)'
+	depends on EXPERIMENTAL && IP_NF_CONNTRACK && NETFILTER_NETLINK
 	depends on IP_NF_CONNTRACK!=y || NETFILTER_NETLINK!=m
 	help
 	  This option enables support for a netlink-based userspace interface
diff --git a/net/ipv4/netfilter/ip_conntrack_core.c b/net/ipv4/netfilter/ip_conntrack_core.c
index 7a4ecdd..84c66db 100644
--- a/net/ipv4/netfilter/ip_conntrack_core.c
+++ b/net/ipv4/netfilter/ip_conntrack_core.c
@@ -1345,6 +1345,11 @@ static int kill_all(struct ip_conntrack 
 	return 1;
 }
 
+void ip_conntrack_flush(void)
+{
+	ip_ct_iterate_cleanup(kill_all, NULL);
+}
+
 static void free_conntrack_hash(struct list_head *hash, int vmalloced,int size)
 {
 	if (vmalloced)
@@ -1354,8 +1359,12 @@ static void free_conntrack_hash(struct l
 			   get_order(sizeof(struct list_head) * size));
 }
 
-void ip_conntrack_flush(void)
+/* Mishearing the voices in his head, our hero wonders how he's
+   supposed to kill the mall. */
+void ip_conntrack_cleanup(void)
 {
+	ip_ct_attach = NULL;
+
 	/* This makes sure all current packets have passed through
            netfilter framework.  Roll on, two-stage module
            delete... */
@@ -1363,7 +1372,7 @@ void ip_conntrack_flush(void)
 
 	ip_ct_event_cache_flush();
  i_see_dead_people:
-	ip_ct_iterate_cleanup(kill_all, NULL);
+	ip_conntrack_flush();
 	if (atomic_read(&ip_conntrack_count) != 0) {
 		schedule();
 		goto i_see_dead_people;
@@ -1371,14 +1380,7 @@ void ip_conntrack_flush(void)
 	/* wait until all references to ip_conntrack_untracked are dropped */
 	while (atomic_read(&ip_conntrack_untracked.ct_general.use) > 1)
 		schedule();
-}
 
-/* Mishearing the voices in his head, our hero wonders how he's
-   supposed to kill the mall. */
-void ip_conntrack_cleanup(void)
-{
-	ip_ct_attach = NULL;
-	ip_conntrack_flush();
 	kmem_cache_destroy(ip_conntrack_cachep);
 	kmem_cache_destroy(ip_conntrack_expect_cachep);
 	free_conntrack_hash(ip_conntrack_hash, ip_conntrack_vmalloc,
diff --git a/net/ipv4/netfilter/ip_conntrack_netlink.c b/net/ipv4/netfilter/ip_conntrack_netlink.c
index 3fce91b..91fe8f2 100644
--- a/net/ipv4/netfilter/ip_conntrack_netlink.c
+++ b/net/ipv4/netfilter/ip_conntrack_netlink.c
@@ -503,7 +503,7 @@ ctnetlink_parse_tuple_ip(struct nfattr *
 }
 
 static const size_t cta_min_proto[CTA_PROTO_MAX] = {
-	[CTA_PROTO_NUM-1]	= sizeof(u_int16_t),
+	[CTA_PROTO_NUM-1]	= sizeof(u_int8_t),
 	[CTA_PROTO_SRC_PORT-1]	= sizeof(u_int16_t),
 	[CTA_PROTO_DST_PORT-1]	= sizeof(u_int16_t),
 	[CTA_PROTO_ICMP_TYPE-1]	= sizeof(u_int8_t),
@@ -528,7 +528,7 @@ ctnetlink_parse_tuple_proto(struct nfatt
 
 	if (!tb[CTA_PROTO_NUM-1])
 		return -EINVAL;
-	tuple->dst.protonum = *(u_int16_t *)NFA_DATA(tb[CTA_PROTO_NUM-1]);
+	tuple->dst.protonum = *(u_int8_t *)NFA_DATA(tb[CTA_PROTO_NUM-1]);
 
 	proto = ip_conntrack_proto_find_get(tuple->dst.protonum);
 
@@ -728,11 +728,9 @@ ctnetlink_del_conntrack(struct sock *ctn
 			return -ENOENT;
 		}
 	}	
-	if (del_timer(&ct->timeout)) {
-		ip_conntrack_put(ct);
+	if (del_timer(&ct->timeout))
 		ct->timeout.function((unsigned long)ct);
-		return 0;
-	}
+
 	ip_conntrack_put(ct);
 	DEBUGP("leaving\n");
 
@@ -877,7 +875,7 @@ ctnetlink_change_status(struct ip_conntr
 		DEBUGP("NAT status: %lu\n", 
 		       status & (IPS_NAT_MASK | IPS_NAT_DONE_MASK));
 		
-		if (ip_nat_initialized(ct, hooknum))
+		if (ip_nat_initialized(ct, HOOK2MANIP(hooknum)))
 			return -EEXIST;
 		ip_nat_setup_info(ct, &range, hooknum);
 
diff --git a/net/ipv4/netfilter/ip_conntrack_proto_tcp.c b/net/ipv4/netfilter/ip_conntrack_proto_tcp.c
index aeb7353..e7fa29e 100644
--- a/net/ipv4/netfilter/ip_conntrack_proto_tcp.c
+++ b/net/ipv4/netfilter/ip_conntrack_proto_tcp.c
@@ -341,9 +341,10 @@ static int tcp_print_conntrack(struct se
 static int tcp_to_nfattr(struct sk_buff *skb, struct nfattr *nfa,
 			 const struct ip_conntrack *ct)
 {
-	struct nfattr *nest_parms = NFA_NEST(skb, CTA_PROTOINFO_TCP);
+	struct nfattr *nest_parms;
 	
 	read_lock_bh(&tcp_lock);
+	nest_parms = NFA_NEST(skb, CTA_PROTOINFO_TCP);
 	NFA_PUT(skb, CTA_PROTOINFO_TCP_STATE, sizeof(u_int8_t),
 		&ct->proto.tcp.state);
 	read_unlock_bh(&tcp_lock);
diff --git a/net/ipv4/netfilter/ip_nat_tftp.c b/net/ipv4/netfilter/ip_nat_tftp.c
index 2215317..43c3bd7 100644
--- a/net/ipv4/netfilter/ip_nat_tftp.c
+++ b/net/ipv4/netfilter/ip_nat_tftp.c
@@ -42,7 +42,10 @@ static unsigned int help(struct sk_buff 
 			 enum ip_conntrack_info ctinfo,
 			 struct ip_conntrack_expect *exp)
 {
-	exp->saved_proto.udp.port = exp->tuple.dst.u.tcp.port;
+	struct ip_conntrack *ct = exp->master;
+
+	exp->saved_proto.udp.port
+		= ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.udp.port;
 	exp->dir = IP_CT_DIR_REPLY;
 	exp->expectfn = ip_nat_follow_master;
 	if (ip_conntrack_expect_related(exp) != 0)
diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c
index 029c70d..b7325e0 100644
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@ -262,122 +262,139 @@ static __inline__ u16 tcp_select_window(
  * We are working here with either a clone of the original
  * SKB, or a fresh unique copy made by the retransmit engine.
  */
-static int tcp_transmit_skb(struct sock *sk, struct sk_buff *skb)
+static int tcp_transmit_skb(struct sock *sk, struct sk_buff *skb, int clone_it, gfp_t gfp_mask)
 {
-	if (skb != NULL) {
-		const struct inet_connection_sock *icsk = inet_csk(sk);
-		struct inet_sock *inet = inet_sk(sk);
-		struct tcp_sock *tp = tcp_sk(sk);
-		struct tcp_skb_cb *tcb = TCP_SKB_CB(skb);
-		int tcp_header_size = tp->tcp_header_len;
-		struct tcphdr *th;
-		int sysctl_flags;
-		int err;
+	const struct inet_connection_sock *icsk = inet_csk(sk);
+	struct inet_sock *inet;
+	struct tcp_sock *tp;
+	struct tcp_skb_cb *tcb;
+	int tcp_header_size;
+	struct tcphdr *th;
+	int sysctl_flags;
+	int err;
+
+	BUG_ON(!skb || !tcp_skb_pcount(skb));
+
+	/* If congestion control is doing timestamping, we must
+	 * take such a timestamp before we potentially clone/copy.
+	 */
+	if (icsk->icsk_ca_ops->rtt_sample)
+		__net_timestamp(skb);
 
-		BUG_ON(!tcp_skb_pcount(skb));
+	if (likely(clone_it)) {
+		if (unlikely(skb_cloned(skb)))
+			skb = pskb_copy(skb, gfp_mask);
+		else
+			skb = skb_clone(skb, gfp_mask);
+		if (unlikely(!skb))
+			return -ENOBUFS;
+	}
+
+	inet = inet_sk(sk);
+	tp = tcp_sk(sk);
+	tcb = TCP_SKB_CB(skb);
+	tcp_header_size = tp->tcp_header_len;
 
 #define SYSCTL_FLAG_TSTAMPS	0x1
 #define SYSCTL_FLAG_WSCALE	0x2
 #define SYSCTL_FLAG_SACK	0x4
 
-		/* If congestion control is doing timestamping */
-		if (icsk->icsk_ca_ops->rtt_sample)
-			__net_timestamp(skb);
-
-		sysctl_flags = 0;
-		if (tcb->flags & TCPCB_FLAG_SYN) {
-			tcp_header_size = sizeof(struct tcphdr) + TCPOLEN_MSS;
-			if(sysctl_tcp_timestamps) {
-				tcp_header_size += TCPOLEN_TSTAMP_ALIGNED;
-				sysctl_flags |= SYSCTL_FLAG_TSTAMPS;
-			}
-			if(sysctl_tcp_window_scaling) {
-				tcp_header_size += TCPOLEN_WSCALE_ALIGNED;
-				sysctl_flags |= SYSCTL_FLAG_WSCALE;
-			}
-			if(sysctl_tcp_sack) {
-				sysctl_flags |= SYSCTL_FLAG_SACK;
-				if(!(sysctl_flags & SYSCTL_FLAG_TSTAMPS))
-					tcp_header_size += TCPOLEN_SACKPERM_ALIGNED;
-			}
-		} else if (tp->rx_opt.eff_sacks) {
-			/* A SACK is 2 pad bytes, a 2 byte header, plus
-			 * 2 32-bit sequence numbers for each SACK block.
-			 */
-			tcp_header_size += (TCPOLEN_SACK_BASE_ALIGNED +
-					    (tp->rx_opt.eff_sacks * TCPOLEN_SACK_PERBLOCK));
-		}
+	sysctl_flags = 0;
+	if (unlikely(tcb->flags & TCPCB_FLAG_SYN)) {
+		tcp_header_size = sizeof(struct tcphdr) + TCPOLEN_MSS;
+		if(sysctl_tcp_timestamps) {
+			tcp_header_size += TCPOLEN_TSTAMP_ALIGNED;
+			sysctl_flags |= SYSCTL_FLAG_TSTAMPS;
+		}
+		if (sysctl_tcp_window_scaling) {
+			tcp_header_size += TCPOLEN_WSCALE_ALIGNED;
+			sysctl_flags |= SYSCTL_FLAG_WSCALE;
+		}
+		if (sysctl_tcp_sack) {
+			sysctl_flags |= SYSCTL_FLAG_SACK;
+			if (!(sysctl_flags & SYSCTL_FLAG_TSTAMPS))
+				tcp_header_size += TCPOLEN_SACKPERM_ALIGNED;
+		}
+	} else if (unlikely(tp->rx_opt.eff_sacks)) {
+		/* A SACK is 2 pad bytes, a 2 byte header, plus
+		 * 2 32-bit sequence numbers for each SACK block.
+		 */
+		tcp_header_size += (TCPOLEN_SACK_BASE_ALIGNED +
+				    (tp->rx_opt.eff_sacks *
+				     TCPOLEN_SACK_PERBLOCK));
+	}
 		
-		if (tcp_packets_in_flight(tp) == 0)
-			tcp_ca_event(sk, CA_EVENT_TX_START);
+	if (tcp_packets_in_flight(tp) == 0)
+		tcp_ca_event(sk, CA_EVENT_TX_START);
 
-		th = (struct tcphdr *) skb_push(skb, tcp_header_size);
-		skb->h.th = th;
-		skb_set_owner_w(skb, sk);
-
-		/* Build TCP header and checksum it. */
-		th->source		= inet->sport;
-		th->dest		= inet->dport;
-		th->seq			= htonl(tcb->seq);
-		th->ack_seq		= htonl(tp->rcv_nxt);
-		*(((__u16 *)th) + 6)	= htons(((tcp_header_size >> 2) << 12) | tcb->flags);
-		if (tcb->flags & TCPCB_FLAG_SYN) {
-			/* RFC1323: The window in SYN & SYN/ACK segments
-			 * is never scaled.
-			 */
-			th->window	= htons(tp->rcv_wnd);
-		} else {
-			th->window	= htons(tcp_select_window(sk));
-		}
-		th->check		= 0;
-		th->urg_ptr		= 0;
-
-		if (tp->urg_mode &&
-		    between(tp->snd_up, tcb->seq+1, tcb->seq+0xFFFF)) {
-			th->urg_ptr		= htons(tp->snd_up-tcb->seq);
-			th->urg			= 1;
-		}
-
-		if (tcb->flags & TCPCB_FLAG_SYN) {
-			tcp_syn_build_options((__u32 *)(th + 1),
-					      tcp_advertise_mss(sk),
-					      (sysctl_flags & SYSCTL_FLAG_TSTAMPS),
-					      (sysctl_flags & SYSCTL_FLAG_SACK),
-					      (sysctl_flags & SYSCTL_FLAG_WSCALE),
-					      tp->rx_opt.rcv_wscale,
-					      tcb->when,
-		      			      tp->rx_opt.ts_recent);
-		} else {
-			tcp_build_and_update_options((__u32 *)(th + 1),
-						     tp, tcb->when);
+	th = (struct tcphdr *) skb_push(skb, tcp_header_size);
+	skb->h.th = th;
+	skb_set_owner_w(skb, sk);
+
+	/* Build TCP header and checksum it. */
+	th->source		= inet->sport;
+	th->dest		= inet->dport;
+	th->seq			= htonl(tcb->seq);
+	th->ack_seq		= htonl(tp->rcv_nxt);
+	*(((__u16 *)th) + 6)	= htons(((tcp_header_size >> 2) << 12) |
+					tcb->flags);
+
+	if (unlikely(tcb->flags & TCPCB_FLAG_SYN)) {
+		/* RFC1323: The window in SYN & SYN/ACK segments
+		 * is never scaled.
+		 */
+		th->window	= htons(tp->rcv_wnd);
+	} else {
+		th->window	= htons(tcp_select_window(sk));
+	}
+	th->check		= 0;
+	th->urg_ptr		= 0;
 
-			TCP_ECN_send(sk, tp, skb, tcp_header_size);
-		}
-		tp->af_specific->send_check(sk, th, skb->len, skb);
+	if (unlikely(tp->urg_mode &&
+		     between(tp->snd_up, tcb->seq+1, tcb->seq+0xFFFF))) {
+		th->urg_ptr		= htons(tp->snd_up-tcb->seq);
+		th->urg			= 1;
+	}
+
+	if (unlikely(tcb->flags & TCPCB_FLAG_SYN)) {
+		tcp_syn_build_options((__u32 *)(th + 1),
+				      tcp_advertise_mss(sk),
+				      (sysctl_flags & SYSCTL_FLAG_TSTAMPS),
+				      (sysctl_flags & SYSCTL_FLAG_SACK),
+				      (sysctl_flags & SYSCTL_FLAG_WSCALE),
+				      tp->rx_opt.rcv_wscale,
+				      tcb->when,
+				      tp->rx_opt.ts_recent);
+	} else {
+		tcp_build_and_update_options((__u32 *)(th + 1),
+					     tp, tcb->when);
+		TCP_ECN_send(sk, tp, skb, tcp_header_size);
+	}
 
-		if (tcb->flags & TCPCB_FLAG_ACK)
-			tcp_event_ack_sent(sk, tcp_skb_pcount(skb));
+	tp->af_specific->send_check(sk, th, skb->len, skb);
 
-		if (skb->len != tcp_header_size)
-			tcp_event_data_sent(tp, skb, sk);
+	if (likely(tcb->flags & TCPCB_FLAG_ACK))
+		tcp_event_ack_sent(sk, tcp_skb_pcount(skb));
 
-		TCP_INC_STATS(TCP_MIB_OUTSEGS);
+	if (skb->len != tcp_header_size)
+		tcp_event_data_sent(tp, skb, sk);
 
-		err = tp->af_specific->queue_xmit(skb, 0);
-		if (err <= 0)
-			return err;
+	TCP_INC_STATS(TCP_MIB_OUTSEGS);
 
-		tcp_enter_cwr(sk);
+	err = tp->af_specific->queue_xmit(skb, 0);
+	if (unlikely(err <= 0))
+		return err;
+
+	tcp_enter_cwr(sk);
+
+	/* NET_XMIT_CN is special. It does not guarantee,
+	 * that this packet is lost. It tells that device
+	 * is about to start to drop packets or already
+	 * drops some packets of the same priority and
+	 * invokes us to send less aggressively.
+	 */
+	return err == NET_XMIT_CN ? 0 : err;
 
-		/* NET_XMIT_CN is special. It does not guarantee,
-		 * that this packet is lost. It tells that device
-		 * is about to start to drop packets or already
-		 * drops some packets of the same priority and
-		 * invokes us to send less aggressively.
-		 */
-		return err == NET_XMIT_CN ? 0 : err;
-	}
-	return -ENOBUFS;
 #undef SYSCTL_FLAG_TSTAMPS
 #undef SYSCTL_FLAG_WSCALE
 #undef SYSCTL_FLAG_SACK
@@ -1036,7 +1053,7 @@ static int tcp_write_xmit(struct sock *s
 
 		TCP_SKB_CB(skb)->when = tcp_time_stamp;
 
-		if (unlikely(tcp_transmit_skb(sk, skb_clone(skb, GFP_ATOMIC))))
+		if (unlikely(tcp_transmit_skb(sk, skb, 1, GFP_ATOMIC)))
 			break;
 
 		/* Advance the send_head.  This one is sent out.
@@ -1109,7 +1126,7 @@ void tcp_push_one(struct sock *sk, unsig
 		/* Send it out now. */
 		TCP_SKB_CB(skb)->when = tcp_time_stamp;
 
-		if (likely(!tcp_transmit_skb(sk, skb_clone(skb, sk->sk_allocation)))) {
+		if (likely(!tcp_transmit_skb(sk, skb, 1, sk->sk_allocation))) {
 			update_send_head(sk, tp, skb);
 			tcp_cwnd_validate(sk, tp);
 			return;
@@ -1429,9 +1446,7 @@ int tcp_retransmit_skb(struct sock *sk, 
 	 */
 	TCP_SKB_CB(skb)->when = tcp_time_stamp;
 
-	err = tcp_transmit_skb(sk, (skb_cloned(skb) ?
-				    pskb_copy(skb, GFP_ATOMIC):
-				    skb_clone(skb, GFP_ATOMIC)));
+	err = tcp_transmit_skb(sk, skb, 1, GFP_ATOMIC);
 
 	if (err == 0) {
 		/* Update global TCP statistics. */
@@ -1665,7 +1680,7 @@ void tcp_send_active_reset(struct sock *
 	TCP_SKB_CB(skb)->seq = tcp_acceptable_seq(sk, tp);
 	TCP_SKB_CB(skb)->end_seq = TCP_SKB_CB(skb)->seq;
 	TCP_SKB_CB(skb)->when = tcp_time_stamp;
-	if (tcp_transmit_skb(sk, skb))
+	if (tcp_transmit_skb(sk, skb, 0, priority))
 		NET_INC_STATS(LINUX_MIB_TCPABORTFAILED);
 }
 
@@ -1700,7 +1715,7 @@ int tcp_send_synack(struct sock *sk)
 		TCP_ECN_send_synack(tcp_sk(sk), skb);
 	}
 	TCP_SKB_CB(skb)->when = tcp_time_stamp;
-	return tcp_transmit_skb(sk, skb_clone(skb, GFP_ATOMIC));
+	return tcp_transmit_skb(sk, skb, 1, GFP_ATOMIC);
 }
 
 /*
@@ -1861,7 +1876,7 @@ int tcp_connect(struct sock *sk)
 	__skb_queue_tail(&sk->sk_write_queue, buff);
 	sk_charge_skb(sk, buff);
 	tp->packets_out += tcp_skb_pcount(buff);
-	tcp_transmit_skb(sk, skb_clone(buff, GFP_KERNEL));
+	tcp_transmit_skb(sk, buff, 1, GFP_KERNEL);
 	TCP_INC_STATS(TCP_MIB_ACTIVEOPENS);
 
 	/* Timer for repeating the SYN until an answer. */
@@ -1957,7 +1972,7 @@ void tcp_send_ack(struct sock *sk)
 		/* Send it off, this clears delayed acks for us. */
 		TCP_SKB_CB(buff)->seq = TCP_SKB_CB(buff)->end_seq = tcp_acceptable_seq(sk, tp);
 		TCP_SKB_CB(buff)->when = tcp_time_stamp;
-		tcp_transmit_skb(sk, buff);
+		tcp_transmit_skb(sk, buff, 0, GFP_ATOMIC);
 	}
 }
 
@@ -1997,7 +2012,7 @@ static int tcp_xmit_probe_skb(struct soc
 	TCP_SKB_CB(skb)->seq = urgent ? tp->snd_una : tp->snd_una - 1;
 	TCP_SKB_CB(skb)->end_seq = TCP_SKB_CB(skb)->seq;
 	TCP_SKB_CB(skb)->when = tcp_time_stamp;
-	return tcp_transmit_skb(sk, skb);
+	return tcp_transmit_skb(sk, skb, 0, GFP_ATOMIC);
 }
 
 int tcp_write_wakeup(struct sock *sk)
@@ -2030,7 +2045,7 @@ int tcp_write_wakeup(struct sock *sk)
 
 			TCP_SKB_CB(skb)->flags |= TCPCB_FLAG_PSH;
 			TCP_SKB_CB(skb)->when = tcp_time_stamp;
-			err = tcp_transmit_skb(sk, skb_clone(skb, GFP_ATOMIC));
+			err = tcp_transmit_skb(sk, skb, 1, GFP_ATOMIC);
 			if (!err) {
 				update_send_head(sk, tp, skb);
 			}
diff --git a/net/ipv4/tcp_vegas.c b/net/ipv4/tcp_vegas.c
index b7d296a..13e7e6e 100644
--- a/net/ipv4/tcp_vegas.c
+++ b/net/ipv4/tcp_vegas.c
@@ -215,14 +215,6 @@ static void tcp_vegas_cong_avoid(struct 
 		vegas->beg_snd_nxt  = tp->snd_nxt;
 		vegas->beg_snd_cwnd = tp->snd_cwnd;
 
-		/* Take into account the current RTT sample too, to
-		 * decrease the impact of delayed acks. This double counts
-		 * this sample since we count it for the next window as well,
-		 * but that's not too awful, since we're taking the min,
-		 * rather than averaging.
-		 */
-		tcp_vegas_rtt_calc(sk, seq_rtt * 1000);
-
 		/* We do the Vegas calculations only if we got enough RTT
 		 * samples that we can be reasonably sure that we got
 		 * at least one RTT sample that wasn't from a delayed ACK.
@@ -333,11 +325,11 @@ static void tcp_vegas_cong_avoid(struct 
 			else if (tp->snd_cwnd > tp->snd_cwnd_clamp)
 				tp->snd_cwnd = tp->snd_cwnd_clamp;
 		}
-	}
 
-	/* Wipe the slate clean for the next RTT. */
-	vegas->cntRTT = 0;
-	vegas->minRTT = 0x7fffffff;
+		/* Wipe the slate clean for the next RTT. */
+		vegas->cntRTT = 0;
+		vegas->minRTT = 0x7fffffff;
+	}
 }
 
 /* Extract info for Tcp socket info provided via netlink. */
diff --git a/net/ipv6/esp6.c b/net/ipv6/esp6.c
index 40d9a19..8bfbe99 100644
--- a/net/ipv6/esp6.c
+++ b/net/ipv6/esp6.c
@@ -248,7 +248,7 @@ static u32 esp6_get_max_size(struct xfrm
 	if (esp->conf.padlen)
 		mtu = ALIGN(mtu, esp->conf.padlen);
 
-	return mtu + x->props.header_len + esp->auth.icv_full_len;
+	return mtu + x->props.header_len + esp->auth.icv_trunc_len;
 }
 
 static void esp6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
diff --git a/net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c b/net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
index c0f1da5..a7e03cf 100644
--- a/net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
+++ b/net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
@@ -68,8 +68,8 @@ static int icmpv6_invert_tuple(struct nf
 		[ICMPV6_NI_REPLY - 128]		= ICMPV6_NI_REPLY +1
 	};
 
-	__u8 type = orig->dst.u.icmp.type - 128;
-	if (type >= sizeof(invmap) || !invmap[type])
+	int type = orig->dst.u.icmp.type - 128;
+	if (type < 0 || type >= sizeof(invmap) || !invmap[type])
 		return 0;
 
 	tuple->src.u.icmp.id   = orig->src.u.icmp.id;
@@ -129,12 +129,12 @@ static int icmpv6_new(struct nf_conn *co
 		[ICMPV6_ECHO_REQUEST - 128] = 1,
 		[ICMPV6_NI_QUERY - 128] = 1
 	};
+	int type = conntrack->tuplehash[0].tuple.dst.u.icmp.type - 128;
 
-	if (conntrack->tuplehash[0].tuple.dst.u.icmp.type - 128 >= sizeof(valid_new)
-	    || !valid_new[conntrack->tuplehash[0].tuple.dst.u.icmp.type - 128]) {
+	if (type < 0 || type >= sizeof(valid_new) || !valid_new[type]) {
 		/* Can't create a new ICMPv6 `conn' with this. */
-		DEBUGP("icmp: can't create new conn with type %u\n",
-		       conntrack->tuplehash[0].tuple.dst.u.icmp.type);
+		DEBUGP("icmpv6: can't create new conn with type %u\n",
+		       type + 128);
 		NF_CT_DUMP_TUPLE(&conntrack->tuplehash[0].tuple);
 		return 0;
 	}
diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c
index 62c0e5b..8827389 100644
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@ -992,13 +992,12 @@ static void tcp_v6_send_reset(struct sk_
 	/* sk = NULL, but it is safe for now. RST socket required. */
 	if (!ip6_dst_lookup(NULL, &buff->dst, &fl)) {
 
-		if ((xfrm_lookup(&buff->dst, &fl, NULL, 0)) < 0)
+		if (xfrm_lookup(&buff->dst, &fl, NULL, 0) >= 0) {
+			ip6_xmit(NULL, buff, &fl, NULL, 0);
+			TCP_INC_STATS_BH(TCP_MIB_OUTSEGS);
+			TCP_INC_STATS_BH(TCP_MIB_OUTRSTS);
 			return;
-
-		ip6_xmit(NULL, buff, &fl, NULL, 0);
-		TCP_INC_STATS_BH(TCP_MIB_OUTSEGS);
-		TCP_INC_STATS_BH(TCP_MIB_OUTRSTS);
-		return;
+		}
 	}
 
 	kfree_skb(buff);
@@ -1057,11 +1056,11 @@ static void tcp_v6_send_ack(struct sk_bu
 	fl.fl_ip_sport = t1->source;
 
 	if (!ip6_dst_lookup(NULL, &buff->dst, &fl)) {
-		if ((xfrm_lookup(&buff->dst, &fl, NULL, 0)) < 0)
+		if (xfrm_lookup(&buff->dst, &fl, NULL, 0) >= 0) {
+			ip6_xmit(NULL, buff, &fl, NULL, 0);
+			TCP_INC_STATS_BH(TCP_MIB_OUTSEGS);
 			return;
-		ip6_xmit(NULL, buff, &fl, NULL, 0);
-		TCP_INC_STATS_BH(TCP_MIB_OUTSEGS);
-		return;
+		}
 	}
 
 	kfree_skb(buff);
diff --git a/net/netfilter/Kconfig b/net/netfilter/Kconfig
index a84f922..794c41d 100644
--- a/net/netfilter/Kconfig
+++ b/net/netfilter/Kconfig
@@ -61,8 +61,8 @@ config NF_CONNTRACK_MARK
 	  instead of the individual packets.
 
 config NF_CONNTRACK_EVENTS
-	bool "Connection tracking events"
-	depends on NF_CONNTRACK
+	bool "Connection tracking events (EXPERIMENTAL)"
+	depends on EXPERIMENTAL && NF_CONNTRACK
 	help
 	  If this option is enabled, the connection tracking code will
 	  provide a notifier chain that can be used by other kernel code
diff --git a/net/netfilter/nf_conntrack_core.c b/net/netfilter/nf_conntrack_core.c
index 1da6783..a7c7b49 100644
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@ -1383,6 +1383,9 @@ void nf_conntrack_cleanup(void)
 		schedule();
 		goto i_see_dead_people;
 	}
+	/* wait until all references to nf_conntrack_untracked are dropped */
+	while (atomic_read(&nf_conntrack_untracked.ct_general.use) > 1)
+		schedule();
 
 	for (i = 0; i < NF_CT_F_NUM; i++) {
 		if (nf_ct_cache[i].use == 0)
diff --git a/net/netfilter/nfnetlink.c b/net/netfilter/nfnetlink.c
index a60c59b..95fdf04 100644
--- a/net/netfilter/nfnetlink.c
+++ b/net/netfilter/nfnetlink.c
@@ -162,7 +162,7 @@ nfnetlink_check_attributes(struct nfnetl
 		return -EINVAL;
 	}
 
-	min_len = NLMSG_ALIGN(sizeof(struct nfgenmsg));
+	min_len = NLMSG_SPACE(sizeof(struct nfgenmsg));
 	if (unlikely(nlh->nlmsg_len < min_len))
 		return -EINVAL;
 
@@ -236,8 +236,7 @@ static inline int nfnetlink_rcv_msg(stru
 	}
 
 	/* All the messages must at least contain nfgenmsg */
-	if (nlh->nlmsg_len < 
-			NLMSG_LENGTH(NLMSG_ALIGN(sizeof(struct nfgenmsg)))) {
+	if (nlh->nlmsg_len < NLMSG_SPACE(sizeof(struct nfgenmsg))) {
 		DEBUGP("received message was too short\n");
 		return 0;
 	}
diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c
index 499ae3d..3e24627 100644
--- a/net/packet/af_packet.c
+++ b/net/packet/af_packet.c
@@ -1587,23 +1587,47 @@ static inline struct page *pg_vec_endpag
 	return virt_to_page(one_pg_vec + (PAGE_SIZE << order) - 1);
 }
 
-static void free_pg_vec(char **pg_vec, unsigned order, unsigned len)
+static void free_pg_vec(char **pg_vec, unsigned int order, unsigned int len)
 {
 	int i;
 
-	for (i=0; i<len; i++) {
-		if (pg_vec[i]) {
-			struct page *page, *pend;
-
-			pend = pg_vec_endpage(pg_vec[i], order);
-			for (page = virt_to_page(pg_vec[i]); page <= pend; page++)
-				ClearPageReserved(page);
-			free_pages((unsigned long)pg_vec[i], order);
-		}
+	for (i = 0; i < len; i++) {
+		if (likely(pg_vec[i]))
+			free_pages((unsigned long) pg_vec[i], order);
 	}
 	kfree(pg_vec);
 }
 
+static inline char *alloc_one_pg_vec_page(unsigned long order)
+{
+	return (char *) __get_free_pages(GFP_KERNEL | __GFP_COMP | __GFP_ZERO,
+					 order);
+}
+
+static char **alloc_pg_vec(struct tpacket_req *req, int order)
+{
+	unsigned int block_nr = req->tp_block_nr;
+	char **pg_vec;
+	int i;
+
+	pg_vec = kzalloc(block_nr * sizeof(char *), GFP_KERNEL);
+	if (unlikely(!pg_vec))
+		goto out;
+
+	for (i = 0; i < block_nr; i++) {
+		pg_vec[i] = alloc_one_pg_vec_page(order);
+		if (unlikely(!pg_vec[i]))
+			goto out_free_pgvec;
+	}
+
+out:
+	return pg_vec;
+
+out_free_pgvec:
+	free_pg_vec(pg_vec, order, block_nr);
+	pg_vec = NULL;
+	goto out;
+}
 
 static int packet_set_ring(struct sock *sk, struct tpacket_req *req, int closing)
 {
@@ -1617,64 +1641,46 @@ static int packet_set_ring(struct sock *
 
 		/* Sanity tests and some calculations */
 
-		if (po->pg_vec)
+		if (unlikely(po->pg_vec))
 			return -EBUSY;
 
-		if ((int)req->tp_block_size <= 0)
+		if (unlikely((int)req->tp_block_size <= 0))
 			return -EINVAL;
-		if (req->tp_block_size&(PAGE_SIZE-1))
+		if (unlikely(req->tp_block_size & (PAGE_SIZE - 1)))
 			return -EINVAL;
-		if (req->tp_frame_size < TPACKET_HDRLEN)
+		if (unlikely(req->tp_frame_size < TPACKET_HDRLEN))
 			return -EINVAL;
-		if (req->tp_frame_size&(TPACKET_ALIGNMENT-1))
+		if (unlikely(req->tp_frame_size & (TPACKET_ALIGNMENT - 1)))
 			return -EINVAL;
 
 		po->frames_per_block = req->tp_block_size/req->tp_frame_size;
-		if (po->frames_per_block <= 0)
+		if (unlikely(po->frames_per_block <= 0))
 			return -EINVAL;
-		if (po->frames_per_block*req->tp_block_nr != req->tp_frame_nr)
+		if (unlikely((po->frames_per_block * req->tp_block_nr) !=
+			     req->tp_frame_nr))
 			return -EINVAL;
-		/* OK! */
-
-		/* Allocate page vector */
-		while ((PAGE_SIZE<<order) < req->tp_block_size)
-			order++;
 
 		err = -ENOMEM;
-
-		pg_vec = kmalloc(req->tp_block_nr*sizeof(char *), GFP_KERNEL);
-		if (pg_vec == NULL)
+		order = get_order(req->tp_block_size);
+		pg_vec = alloc_pg_vec(req, order);
+		if (unlikely(!pg_vec))
 			goto out;
-		memset(pg_vec, 0, req->tp_block_nr*sizeof(char **));
-
-		for (i=0; i<req->tp_block_nr; i++) {
-			struct page *page, *pend;
-			pg_vec[i] = (char *)__get_free_pages(GFP_KERNEL, order);
-			if (!pg_vec[i])
-				goto out_free_pgvec;
-
-			pend = pg_vec_endpage(pg_vec[i], order);
-			for (page = virt_to_page(pg_vec[i]); page <= pend; page++)
-				SetPageReserved(page);
-		}
-		/* Page vector is allocated */
 
 		l = 0;
-		for (i=0; i<req->tp_block_nr; i++) {
+		for (i = 0; i < req->tp_block_nr; i++) {
 			char *ptr = pg_vec[i];
 			struct tpacket_hdr *header;
 			int k;
 
-			for (k=0; k<po->frames_per_block; k++) {
-				
-				header = (struct tpacket_hdr*)ptr;
+			for (k = 0; k < po->frames_per_block; k++) {
+				header = (struct tpacket_hdr *) ptr;
 				header->tp_status = TP_STATUS_KERNEL;
 				ptr += req->tp_frame_size;
 			}
 		}
 		/* Done */
 	} else {
-		if (req->tp_frame_nr)
+		if (unlikely(req->tp_frame_nr))
 			return -EINVAL;
 	}
 
@@ -1701,7 +1707,7 @@ static int packet_set_ring(struct sock *
 
 		spin_lock_bh(&sk->sk_receive_queue.lock);
 		pg_vec = XC(po->pg_vec, pg_vec);
-		po->frame_max = req->tp_frame_nr-1;
+		po->frame_max = (req->tp_frame_nr - 1);
 		po->head = 0;
 		po->frame_size = req->tp_frame_size;
 		spin_unlock_bh(&sk->sk_receive_queue.lock);
@@ -1728,7 +1734,6 @@ static int packet_set_ring(struct sock *
 
 	release_sock(sk);
 
-out_free_pgvec:
 	if (pg_vec)
 		free_pg_vec(pg_vec, order, req->tp_block_nr);
 out:
@@ -1755,17 +1760,19 @@ static int packet_mmap(struct file *file
 	if (size != po->pg_vec_len*po->pg_vec_pages*PAGE_SIZE)
 		goto out;
 
-	atomic_inc(&po->mapped);
 	start = vma->vm_start;
-	err = -EAGAIN;
-	for (i=0; i<po->pg_vec_len; i++) {
-		if (remap_pfn_range(vma, start,
-				     __pa(po->pg_vec[i]) >> PAGE_SHIFT,
-				     po->pg_vec_pages*PAGE_SIZE,
-				     vma->vm_page_prot))
-			goto out;
-		start += po->pg_vec_pages*PAGE_SIZE;
+	for (i = 0; i < po->pg_vec_len; i++) {
+		struct page *page = virt_to_page(po->pg_vec[i]);
+		int pg_num;
+
+		for (pg_num = 0; pg_num < po->pg_vec_pages; pg_num++, page++) {
+			err = vm_insert_page(vma, start, page);
+			if (unlikely(err))
+				goto out;
+			start += PAGE_SIZE;
+		}
 	}
+	atomic_inc(&po->mapped);
 	vma->vm_ops = &packet_mmap_ops;
 	err = 0;
 

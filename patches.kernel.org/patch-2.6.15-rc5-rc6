From: Linus Torvalds <torvalds@osdl.org>
Subject: Linux 2.6.15-rc6
Patch-mainline: 2.6.15-rc6
Acked-by: olh@suse.de

## Automatically generated incremental diff
## From:   linux-2.6.15-rc5
## To:     linux-2.6.15-rc6
## Robot:  $Id: make-incremental-diff,v 1.12 2004/01/06 07:19:36 hpa Exp $

diff -urN linux-2.6.15-rc5/Documentation/arm/00-INDEX linux-2.6.15-rc6/Documentation/arm/00-INDEX
--- linux-2.6.15-rc5/Documentation/arm/00-INDEX	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/Documentation/arm/00-INDEX	2005-12-18 22:28:01.851932044 -0800
@@ -16,5 +16,7 @@
 	- Empeg documentation
 mem_alignment
 	- alignment abort handler documentation
+memory.txt
+	- description of the virtual memory layout
 nwfpe
 	- NWFPE floating point emulator documentation
diff -urN linux-2.6.15-rc5/Documentation/dvb/README.dvb-usb linux-2.6.15-rc6/Documentation/dvb/README.dvb-usb
--- linux-2.6.15-rc5/Documentation/dvb/README.dvb-usb	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/Documentation/dvb/README.dvb-usb	2005-12-18 22:28:01.859932401 -0800
@@ -50,12 +50,12 @@
 0. History & News:
   2005-06-30 - added support for WideView WT-220U (Thanks to Steve Chang)
   2005-05-30 - added basic isochronous support to the dvb-usb-framework
-               added support for Conexant Hybrid reference design and Nebula DigiTV USB
+	       added support for Conexant Hybrid reference design and Nebula DigiTV USB
   2005-04-17 - all dibusb devices ported to make use of the dvb-usb-framework
   2005-04-02 - re-enabled and improved remote control code.
   2005-03-31 - ported the Yakumo/Hama/Typhoon DVB-T USB2.0 device to dvb-usb.
   2005-03-30 - first commit of the dvb-usb-module based on the dibusb-source. First device is a new driver for the
-               TwinhanDTV Alpha / MagicBox II USB2.0-only DVB-T device.
+	       TwinhanDTV Alpha / MagicBox II USB2.0-only DVB-T device.
 
   (change from dvb-dibusb to dvb-usb)
   2005-03-28 - added support for the AVerMedia AverTV DVB-T USB2.0 device (Thanks to Glen Harris and Jiun-Kuei Jung, AVerMedia)
@@ -64,50 +64,50 @@
   2005-02-02 - added support for the Hauppauge Win-TV Nova-T USB2
   2005-01-31 - distorted streaming is gone for USB1.1 devices
   2005-01-13 - moved the mirrored pid_filter_table back to dvb-dibusb
-             - first almost working version for HanfTek UMT-010
-             - found out, that Yakumo/HAMA/Typhoon are predecessors of the HanfTek UMT-010
+	     - first almost working version for HanfTek UMT-010
+	     - found out, that Yakumo/HAMA/Typhoon are predecessors of the HanfTek UMT-010
   2005-01-10 - refactoring completed, now everything is very delightful
-             - tuner quirks for some weird devices (Artec T1 AN2235 device has sometimes a
-               Panasonic Tuner assembled). Tunerprobing implemented. Thanks a lot to Gunnar Wittich.
+	     - tuner quirks for some weird devices (Artec T1 AN2235 device has sometimes a
+	       Panasonic Tuner assembled). Tunerprobing implemented. Thanks a lot to Gunnar Wittich.
   2004-12-29 - after several days of struggling around bug of no returning URBs fixed.
   2004-12-26 - refactored the dibusb-driver, splitted into separate files
-             - i2c-probing enabled
+	     - i2c-probing enabled
   2004-12-06 - possibility for demod i2c-address probing
-             - new usb IDs (Compro, Artec)
+	     - new usb IDs (Compro, Artec)
   2004-11-23 - merged changes from DiB3000MC_ver2.1
-             - revised the debugging
-             - possibility to deliver the complete TS for USB2.0
+	     - revised the debugging
+	     - possibility to deliver the complete TS for USB2.0
   2004-11-21 - first working version of the dib3000mc/p frontend driver.
   2004-11-12 - added additional remote control keys. Thanks to Uwe Hanke.
   2004-11-07 - added remote control support. Thanks to David Matthews.
   2004-11-05 - added support for a new devices (Grandtec/Avermedia/Artec)
-             - merged my changes (for dib3000mb/dibusb) to the FE_REFACTORING, because it became HEAD
-             - moved transfer control (pid filter, fifo control) from usb driver to frontend, it seems
-               better settled there (added xfer_ops-struct)
-             - created a common files for frontends (mc/p/mb)
+	     - merged my changes (for dib3000mb/dibusb) to the FE_REFACTORING, because it became HEAD
+	     - moved transfer control (pid filter, fifo control) from usb driver to frontend, it seems
+	       better settled there (added xfer_ops-struct)
+	     - created a common files for frontends (mc/p/mb)
   2004-09-28 - added support for a new device (Unkown, vendor ID is Hyper-Paltek)
   2004-09-20 - added support for a new device (Compro DVB-U2000), thanks
-               to Amaury Demol for reporting
-             - changed usb TS transfer method (several urbs, stopping transfer
-               before setting a new pid)
+	       to Amaury Demol for reporting
+	     - changed usb TS transfer method (several urbs, stopping transfer
+	       before setting a new pid)
   2004-09-13 - added support for a new device (Artec T1 USB TVBOX), thanks
-               to Christian Motschke for reporting
+	       to Christian Motschke for reporting
   2004-09-05 - released the dibusb device and dib3000mb-frontend driver
 
   (old news for vp7041.c)
   2004-07-15 - found out, by accident, that the device has a TUA6010XS for
-               PLL
+	       PLL
   2004-07-12 - figured out, that the driver should also work with the
-               CTS Portable (Chinese Television System)
+	       CTS Portable (Chinese Television System)
   2004-07-08 - firmware-extraction-2.422-problem solved, driver is now working
-               properly with firmware extracted from 2.422
-             - #if for 2.6.4 (dvb), compile issue
-             - changed firmware handling, see vp7041.txt sec 1.1
+	       properly with firmware extracted from 2.422
+	     - #if for 2.6.4 (dvb), compile issue
+	     - changed firmware handling, see vp7041.txt sec 1.1
   2004-07-02 - some tuner modifications, v0.1, cleanups, first public
   2004-06-28 - now using the dvb_dmx_swfilter_packets, everything
-               runs fine now
+	       runs fine now
   2004-06-27 - able to watch and switching channels (pre-alpha)
-             - no section filtering yet
+	     - no section filtering yet
   2004-06-06 - first TS received, but kernel oops :/
   2004-05-14 - firmware loader is working
   2004-05-11 - start writing the driver
diff -urN linux-2.6.15-rc5/Documentation/dvb/README.flexcop linux-2.6.15-rc6/Documentation/dvb/README.flexcop
--- linux-2.6.15-rc5/Documentation/dvb/README.flexcop	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/Documentation/dvb/README.flexcop	2005-12-18 22:28:01.859932401 -0800
@@ -174,7 +174,7 @@
 Everything which is identical in the following table, can be put into a common
 flexcop-module.
 
-                  PCI                  USB
+		  PCI                  USB
 -------------------------------------------------------------------------------
 Different:
 Register access:  accessing IO memory  USB control message
diff -urN linux-2.6.15-rc5/Documentation/dvb/avermedia.txt linux-2.6.15-rc6/Documentation/dvb/avermedia.txt
--- linux-2.6.15-rc5/Documentation/dvb/avermedia.txt	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/Documentation/dvb/avermedia.txt	2005-12-18 22:28:01.859932401 -0800
@@ -1,6 +1,6 @@
 
 HOWTO: Get An Avermedia DVB-T working under Linux
-           ______________________________________________
+	   ______________________________________________
 
    Table of Contents
    Assumptions and Introduction
diff -urN linux-2.6.15-rc5/Documentation/dvb/cards.txt linux-2.6.15-rc6/Documentation/dvb/cards.txt
--- linux-2.6.15-rc5/Documentation/dvb/cards.txt	2005-12-18 22:27:53.055540120 -0800
+++ linux-2.6.15-rc6/Documentation/dvb/cards.txt	2005-12-18 22:28:01.860932445 -0800
@@ -16,7 +16,7 @@
   shielding, and the whole metal box has its own part number.
 
 
-o Frontends drivers: 
+o Frontends drivers:
   - dvb_dummy_fe: for testing...
   DVB-S:
    - ves1x93		: Alps BSRV2 (ves1893 demodulator) and dbox2 (ves1993)
@@ -24,7 +24,7 @@
    - grundig_29504-491	: Grundig 29504-491 (Philips TDA8083 demodulator), tsa5522 PLL
    - mt312		: Zarlink mt312 or Mitel vp310 demodulator, sl1935 or tsa5059 PLL
    - stv0299		: Alps BSRU6 (tsa5059 PLL), LG TDQB-S00x (tsa5059 PLL),
-   			  LG TDQF-S001F (sl1935 PLL), Philips SU1278 (tua6100 PLL), 
+			  LG TDQF-S001F (sl1935 PLL), Philips SU1278 (tua6100 PLL),
 			  Philips SU1278SH (tsa5059 PLL), Samsung TBMU24112IMB
   DVB-C:
    - ves1820		: various (ves1820 demodulator, sp5659c or spXXXX PLL)
@@ -35,8 +35,8 @@
    - grundig_29504-401	: Grundig 29504-401 (LSI L64781 demodulator), tsa5060 PLL
    - tda1004x		: Philips tda10045h (td1344 or tdm1316l PLL)
    - nxt6000 		: Alps TDME7 (MITEL SP5659 PLL), Alps TDED4 (TI ALP510 PLL),
-               		  Comtech DVBT-6k07 (SP5730 PLL)
-               		  (NxtWave Communications NXT6000 demodulator)
+			  Comtech DVBT-6k07 (SP5730 PLL)
+			  (NxtWave Communications NXT6000 demodulator)
    - sp887x		: Microtune 7202D
    - dib3000mb	: DiBcom 3000-MB demodulator
   DVB-S/C/T:
diff -urN linux-2.6.15-rc5/Documentation/dvb/contributors.txt linux-2.6.15-rc6/Documentation/dvb/contributors.txt
--- linux-2.6.15-rc5/Documentation/dvb/contributors.txt	2005-12-18 22:27:53.055540120 -0800
+++ linux-2.6.15-rc6/Documentation/dvb/contributors.txt	2005-12-18 22:28:01.860932445 -0800
@@ -15,7 +15,7 @@
 
 Diego Picciani <d.picciani@novacomp.it>
   for CyberLogin for Linux which allows logging onto EON
-  (in case you are wondering where CyberLogin is, EON changed its login 
+  (in case you are wondering where CyberLogin is, EON changed its login
   procedure and CyberLogin is no longer used.)
 
 Martin Schaller <martin@smurf.franken.de>
@@ -57,7 +57,7 @@
 Davor Emard <emard@softhome.net>
   for his work on the budget drivers, the demux code,
   the module unloading problems, ...
-  
+
 Hans-Frieder Vogt <hfvogt@arcor.de>
   for his work on calculating and checking the crc's for the
   TechnoTrend/Hauppauge DEC driver firmware
diff -urN linux-2.6.15-rc5/Documentation/dvb/readme.txt linux-2.6.15-rc6/Documentation/dvb/readme.txt
--- linux-2.6.15-rc5/Documentation/dvb/readme.txt	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/Documentation/dvb/readme.txt	2005-12-18 22:28:01.861932490 -0800
@@ -20,7 +20,7 @@
 
 What's inside this directory:
 
-"cards.txt" 
+"cards.txt"
 contains a list of supported hardware.
 
 "contributors.txt"
@@ -37,7 +37,7 @@
 contains detailed informations about the
 TT DEC2000/DEC3000 USB DVB hardware.
 
-"bt8xx.txt" 
+"bt8xx.txt"
 contains detailed installation instructions for the
 various bt8xx based "budget" DVB cards
 (Nebula, Pinnacle PCTV, Twinhan DST)
diff -urN linux-2.6.15-rc5/Documentation/filesystems/ext3.txt linux-2.6.15-rc6/Documentation/filesystems/ext3.txt
--- linux-2.6.15-rc5/Documentation/filesystems/ext3.txt	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/Documentation/filesystems/ext3.txt	2005-12-18 22:28:01.865932668 -0800
@@ -57,19 +57,19 @@
 			we'd like to get some feedback if it's the contrary for
 			you.
 
-user_xattr	(*)	Enables POSIX Extended Attributes. It's enabled by
-			default, however you need to confifure its support
-			(CONFIG_EXT3_FS_XATTR). This is neccesary if you want
-			to use POSIX Acces Control Lists support. You can visit
-			http://acl.bestbits.at to know more about POSIX Extended
-			attributes.
-
-nouser_xattr		Disables POSIX Extended Attributes.
-
-acl		(*)	Enables POSIX Access Control Lists support. This is
-			enabled by default, however you need to configure
-			its support (CONFIG_EXT3_FS_POSIX_ACL). If you want
-			to know more about ACLs visit http://acl.bestbits.at
+user_xattr		Enables Extended User Attributes. Additionally, you need
+			to have extended attribute support enabled in the kernel
+			configuration (CONFIG_EXT3_FS_XATTR). See the attr(5)
+			manual page and http://acl.bestbits.at to learn more
+			about extended attributes.
+
+nouser_xattr		Disables Extended User Attributes.
+
+acl			Enables POSIX Access Control Lists support.  Additionally,
+			you need to have ACL support enabled in the kernel
+			configuration (CONFIG_EXT3_FS_POSIX_ACL). See the acl(5)
+			manual page and http://acl.bestbits.at for more
+			information.
 
 noacl			This option disables POSIX Access Control List support.
 
diff -urN linux-2.6.15-rc5/MAINTAINERS linux-2.6.15-rc6/MAINTAINERS
--- linux-2.6.15-rc5/MAINTAINERS	2005-12-18 22:27:53.105542348 -0800
+++ linux-2.6.15-rc6/MAINTAINERS	2005-12-18 22:28:01.909934628 -0800
@@ -1284,8 +1284,8 @@
 S:	Supported
 
 INPUT (KEYBOARD, MOUSE, JOYSTICK) DRIVERS
-P:	Vojtech Pavlik
-M:	vojtech@suse.cz
+P:	Dmitry Torokhov
+M:	dtor_core@ameritech.net
 L:	linux-input@atrey.karlin.mff.cuni.cz
 L:	linux-joystick@atrey.karlin.mff.cuni.cz
 T:	git kernel.org:/pub/scm/linux/kernel/git/dtor/input.git
diff -urN linux-2.6.15-rc5/Makefile linux-2.6.15-rc6/Makefile
--- linux-2.6.15-rc5/Makefile	2005-12-18 22:27:53.106542392 -0800
+++ linux-2.6.15-rc6/Makefile	2005-12-18 22:28:01.910934673 -0800
@@ -1,8 +1,8 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 15
-EXTRAVERSION =-rc5
-NAME=Affluent Albatross
+EXTRAVERSION =-rc6
+NAME=Sliding Snow Leopard
 
 # *DOCUMENTATION*
 # To see a list of typical targets execute "make help"
@@ -408,7 +408,7 @@
 # of make so .config is not included in this case either (for *config).
 
 no-dot-config-targets := clean mrproper distclean \
-			 cscope TAGS tags help %docs check% kernelrelease
+			 cscope TAGS tags help %docs check%
 
 config-targets := 0
 mixed-targets  := 0
diff -urN linux-2.6.15-rc5/arch/alpha/kernel/machvec_impl.h linux-2.6.15-rc6/arch/alpha/kernel/machvec_impl.h
--- linux-2.6.15-rc5/arch/alpha/kernel/machvec_impl.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/arch/alpha/kernel/machvec_impl.h	2005-12-18 22:28:01.911934718 -0800
@@ -41,7 +41,7 @@
 #define CAT1(x,y)  x##y
 #define CAT(x,y)   CAT1(x,y)
 
-#define DO_DEFAULT_RTC rtc_port: 0x70
+#define DO_DEFAULT_RTC .rtc_port = 0x70
 
 #define DO_EV4_MMU							\
 	.max_asn =			EV4_MAX_ASN,			\
diff -urN linux-2.6.15-rc5/arch/arm/kernel/module.c linux-2.6.15-rc6/arch/arm/kernel/module.c
--- linux-2.6.15-rc5/arch/arm/kernel/module.c	2005-12-18 22:27:53.131543506 -0800
+++ linux-2.6.15-rc6/arch/arm/kernel/module.c	2005-12-18 22:28:01.936935832 -0800
@@ -101,6 +101,8 @@
 			break;
 
 		case R_ARM_PC24:
+		case R_ARM_CALL:
+		case R_ARM_JUMP24:
 			offset = (*(u32 *)loc & 0x00ffffff) << 2;
 			if (offset & 0x02000000)
 				offset -= 0x04000000;
diff -urN linux-2.6.15-rc5/arch/arm/kernel/ptrace.c linux-2.6.15-rc6/arch/arm/kernel/ptrace.c
--- linux-2.6.15-rc5/arch/arm/kernel/ptrace.c	2005-12-18 22:27:53.132543551 -0800
+++ linux-2.6.15-rc6/arch/arm/kernel/ptrace.c	2005-12-18 22:28:01.937935876 -0800
@@ -242,6 +242,15 @@
 		 */
 		long aluop1, aluop2, ccbit;
 
+	        if ((insn & 0x0fffffd0) == 0x012fff10) {
+		        /*
+			 * bx or blx
+			 */
+			alt = get_user_reg(child, insn & 15);
+			break;
+		}
+
+
 		if ((insn & 0xf000) != 0xf000)
 			break;
 
diff -urN linux-2.6.15-rc5/arch/arm/mach-pxa/pm.c linux-2.6.15-rc6/arch/arm/mach-pxa/pm.c
--- linux-2.6.15-rc5/arch/arm/mach-pxa/pm.c	2005-12-18 22:27:53.195546358 -0800
+++ linux-2.6.15-rc6/arch/arm/mach-pxa/pm.c	2005-12-18 22:28:02.001938728 -0800
@@ -155,19 +155,20 @@
 	PSPR = 0;
 
 	/* restore registers */
+	RESTORE_GPLEVEL(0); RESTORE_GPLEVEL(1); RESTORE_GPLEVEL(2);
+	RESTORE(GPDR0); RESTORE(GPDR1); RESTORE(GPDR2);
 	RESTORE(GAFR0_L); RESTORE(GAFR0_U);
 	RESTORE(GAFR1_L); RESTORE(GAFR1_U);
 	RESTORE(GAFR2_L); RESTORE(GAFR2_U);
-	RESTORE_GPLEVEL(0); RESTORE_GPLEVEL(1); RESTORE_GPLEVEL(2);
-	RESTORE(GPDR0); RESTORE(GPDR1); RESTORE(GPDR2);
 	RESTORE(GRER0); RESTORE(GRER1); RESTORE(GRER2);
 	RESTORE(GFER0); RESTORE(GFER1); RESTORE(GFER2);
 	RESTORE(PGSR0); RESTORE(PGSR1); RESTORE(PGSR2);
 
 #ifdef CONFIG_PXA27x
 	RESTORE(MDREFR);
-	RESTORE(GAFR3_L); RESTORE(GAFR3_U); RESTORE_GPLEVEL(3);
-	RESTORE(GPDR3); RESTORE(GRER3); RESTORE(GFER3); RESTORE(PGSR3);
+	RESTORE_GPLEVEL(3); RESTORE(GPDR3);
+	RESTORE(GAFR3_L); RESTORE(GAFR3_U);
+	RESTORE(GRER3); RESTORE(GFER3); RESTORE(PGSR3);
 	RESTORE(PWER); RESTORE(PCFR); RESTORE(PRER);
 	RESTORE(PFER); RESTORE(PKWR);
 #endif
diff -urN linux-2.6.15-rc5/arch/i386/kernel/kprobes.c linux-2.6.15-rc6/arch/i386/kernel/kprobes.c
--- linux-2.6.15-rc5/arch/i386/kernel/kprobes.c	2005-12-18 22:27:53.276549967 -0800
+++ linux-2.6.15-rc6/arch/i386/kernel/kprobes.c	2005-12-18 22:28:02.080942248 -0800
@@ -191,7 +191,7 @@
 			 */
 			save_previous_kprobe(kcb);
 			set_current_kprobe(p, regs, kcb);
-			p->nmissed++;
+			kprobes_inc_nmissed_count(p);
 			prepare_singlestep(p, regs);
 			kcb->kprobe_status = KPROBE_REENTER;
 			return 1;
diff -urN linux-2.6.15-rc5/arch/i386/kernel/smpboot.c linux-2.6.15-rc6/arch/i386/kernel/smpboot.c
--- linux-2.6.15-rc5/arch/i386/kernel/smpboot.c	2005-12-18 22:27:53.282550234 -0800
+++ linux-2.6.15-rc6/arch/i386/kernel/smpboot.c	2005-12-18 22:28:02.085942471 -0800
@@ -1338,8 +1338,7 @@
 	if (cpu == 0)
 		return -EBUSY;
 
-	/* We enable the timer again on the exit path of the death loop */
-	disable_APIC_timer();
+	clear_local_APIC();
 	/* Allow any queued timer interrupts to get serviced */
 	local_irq_enable();
 	mdelay(1);
diff -urN linux-2.6.15-rc5/arch/i386/kernel/traps.c linux-2.6.15-rc6/arch/i386/kernel/traps.c
--- linux-2.6.15-rc5/arch/i386/kernel/traps.c	2005-12-18 22:27:53.285550368 -0800
+++ linux-2.6.15-rc6/arch/i386/kernel/traps.c	2005-12-18 22:28:02.088942604 -0800
@@ -650,13 +650,6 @@
 
 	cpu = smp_processor_id();
 
-#ifdef CONFIG_HOTPLUG_CPU
-	if (!cpu_online(cpu)) {
-		nmi_exit();
-		return;
-	}
-#endif
-
 	++nmi_count(cpu);
 
 	if (!rcu_dereference(nmi_callback)(regs, cpu))
diff -urN linux-2.6.15-rc5/arch/i386/mm/ioremap.c linux-2.6.15-rc6/arch/i386/mm/ioremap.c
--- linux-2.6.15-rc5/arch/i386/mm/ioremap.c	2005-12-18 22:27:53.288550502 -0800
+++ linux-2.6.15-rc6/arch/i386/mm/ioremap.c	2005-12-18 22:28:02.091942738 -0800
@@ -223,9 +223,15 @@
 }
 EXPORT_SYMBOL(ioremap_nocache);
 
+/**
+ * iounmap - Free a IO remapping
+ * @addr: virtual address from ioremap_*
+ *
+ * Caller must ensure there is only one unmapping for the same pointer.
+ */
 void iounmap(volatile void __iomem *addr)
 {
-	struct vm_struct *p;
+	struct vm_struct *p, *o;
 
 	if ((void __force *)addr <= high_memory)
 		return;
@@ -239,22 +245,37 @@
 			addr < phys_to_virt(ISA_END_ADDRESS))
 		return;
 
-	write_lock(&vmlist_lock);
-	p = __remove_vm_area((void *)(PAGE_MASK & (unsigned long __force)addr));
-	if (!p) { 
-		printk(KERN_WARNING "iounmap: bad address %p\n", addr);
+	addr = (volatile void __iomem *)(PAGE_MASK & (unsigned long __force)addr);
+
+	/* Use the vm area unlocked, assuming the caller
+	   ensures there isn't another iounmap for the same address
+	   in parallel. Reuse of the virtual address is prevented by
+	   leaving it in the global lists until we're done with it.
+	   cpa takes care of the direct mappings. */
+	read_lock(&vmlist_lock);
+	for (p = vmlist; p; p = p->next) {
+		if (p->addr == addr)
+			break;
+	}
+	read_unlock(&vmlist_lock);
+
+	if (!p) {
+		printk("iounmap: bad address %p\n", addr);
 		dump_stack();
-		goto out_unlock;
+		return;
 	}
 
+	/* Reset the direct mapping. Can block */
 	if ((p->flags >> 20) && p->phys_addr < virt_to_phys(high_memory) - 1) {
 		change_page_attr(virt_to_page(__va(p->phys_addr)),
 				 p->size >> PAGE_SHIFT,
 				 PAGE_KERNEL);
 		global_flush_tlb();
 	} 
-out_unlock:
-	write_unlock(&vmlist_lock);
+
+	/* Finally remove it */
+	o = remove_vm_area((void *)addr);
+	BUG_ON(p != o || o == NULL);
 	kfree(p); 
 }
 EXPORT_SYMBOL(iounmap);
diff -urN linux-2.6.15-rc5/arch/i386/pci/direct.c linux-2.6.15-rc6/arch/i386/pci/direct.c
--- linux-2.6.15-rc5/arch/i386/pci/direct.c	2005-12-18 22:27:53.289550546 -0800
+++ linux-2.6.15-rc6/arch/i386/pci/direct.c	2005-12-18 22:28:02.092942782 -0800
@@ -13,7 +13,7 @@
 #define PCI_CONF1_ADDRESS(bus, devfn, reg) \
 	(0x80000000 | (bus << 16) | (devfn << 8) | (reg & ~3))
 
-static int pci_conf1_read(unsigned int seg, unsigned int bus,
+int pci_conf1_read(unsigned int seg, unsigned int bus,
 			  unsigned int devfn, int reg, int len, u32 *value)
 {
 	unsigned long flags;
@@ -42,7 +42,7 @@
 	return 0;
 }
 
-static int pci_conf1_write(unsigned int seg, unsigned int bus,
+int pci_conf1_write(unsigned int seg, unsigned int bus,
 			   unsigned int devfn, int reg, int len, u32 value)
 {
 	unsigned long flags;
diff -urN linux-2.6.15-rc5/arch/i386/pci/mmconfig.c linux-2.6.15-rc6/arch/i386/pci/mmconfig.c
--- linux-2.6.15-rc5/arch/i386/pci/mmconfig.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/arch/i386/pci/mmconfig.c	2005-12-18 22:28:02.094942872 -0800
@@ -19,21 +19,25 @@
 /* The base address of the last MMCONFIG device accessed */
 static u32 mmcfg_last_accessed_device;
 
+static DECLARE_BITMAP(fallback_slots, 32);
+
 /*
  * Functions for accessing PCI configuration space with MMCONFIG accesses
  */
-static u32 get_base_addr(unsigned int seg, int bus)
+static u32 get_base_addr(unsigned int seg, int bus, unsigned devfn)
 {
 	int cfg_num = -1;
 	struct acpi_table_mcfg_config *cfg;
 
+	if (seg == 0 && bus == 0 &&
+	    test_bit(PCI_SLOT(devfn), fallback_slots))
+		return 0;
+
 	while (1) {
 		++cfg_num;
 		if (cfg_num >= pci_mmcfg_config_num) {
-			/* something bad is going on, no cfg table is found. */
-			/* so we fall back to the old way we used to do this */
-			/* and just rely on the first entry to be correct. */
-			return pci_mmcfg_config[0].base_address;
+			/* Not found - fallback to type 1 */
+			return 0;
 		}
 		cfg = &pci_mmcfg_config[cfg_num];
 		if (cfg->pci_segment_group_number != seg)
@@ -44,9 +48,9 @@
 	}
 }
 
-static inline void pci_exp_set_dev_base(unsigned int seg, int bus, int devfn)
+static inline void pci_exp_set_dev_base(unsigned int base, int bus, int devfn)
 {
-	u32 dev_base = get_base_addr(seg, bus) | (bus << 20) | (devfn << 12);
+	u32 dev_base = base | (bus << 20) | (devfn << 12);
 	if (dev_base != mmcfg_last_accessed_device) {
 		mmcfg_last_accessed_device = dev_base;
 		set_fixmap_nocache(FIX_PCIE_MCFG, dev_base);
@@ -57,13 +61,18 @@
 			  unsigned int devfn, int reg, int len, u32 *value)
 {
 	unsigned long flags;
+	u32 base;
 
 	if (!value || (bus > 255) || (devfn > 255) || (reg > 4095))
 		return -EINVAL;
 
+	base = get_base_addr(seg, bus, devfn);
+	if (!base)
+		return pci_conf1_read(seg,bus,devfn,reg,len,value);
+
 	spin_lock_irqsave(&pci_config_lock, flags);
 
-	pci_exp_set_dev_base(seg, bus, devfn);
+	pci_exp_set_dev_base(base, bus, devfn);
 
 	switch (len) {
 	case 1:
@@ -86,13 +95,18 @@
 			   unsigned int devfn, int reg, int len, u32 value)
 {
 	unsigned long flags;
+	u32 base;
 
 	if ((bus > 255) || (devfn > 255) || (reg > 4095)) 
 		return -EINVAL;
 
+	base = get_base_addr(seg, bus, devfn);
+	if (!base)
+		return pci_conf1_write(seg,bus,devfn,reg,len,value);
+
 	spin_lock_irqsave(&pci_config_lock, flags);
 
-	pci_exp_set_dev_base(seg, bus, devfn);
+	pci_exp_set_dev_base(base, bus, devfn);
 
 	switch (len) {
 	case 1:
@@ -116,6 +130,37 @@
 	.write =	pci_mmcfg_write,
 };
 
+/* K8 systems have some devices (typically in the builtin northbridge)
+   that are only accessible using type1
+   Normally this can be expressed in the MCFG by not listing them
+   and assigning suitable _SEGs, but this isn't implemented in some BIOS.
+   Instead try to discover all devices on bus 0 that are unreachable using MM
+   and fallback for them.
+   We only do this for bus 0/seg 0 */
+static __init void unreachable_devices(void)
+{
+	int i;
+	unsigned long flags;
+
+	for (i = 0; i < 32; i++) {
+		u32 val1;
+		u32 addr;
+
+		pci_conf1_read(0, 0, PCI_DEVFN(i, 0), 0, 4, &val1);
+		if (val1 == 0xffffffff)
+			continue;
+
+		/* Locking probably not needed, but safer */
+		spin_lock_irqsave(&pci_config_lock, flags);
+		addr = get_base_addr(0, 0, PCI_DEVFN(i, 0));
+		if (addr != 0)
+			pci_exp_set_dev_base(addr, 0, PCI_DEVFN(i, 0));
+		if (addr == 0 || readl((u32 __iomem *)mmcfg_virt_addr) != val1)
+			set_bit(i, fallback_slots);
+		spin_unlock_irqrestore(&pci_config_lock, flags);
+	}
+}
+
 static int __init pci_mmcfg_init(void)
 {
 	if ((pci_probe & PCI_PROBE_MMCONF) == 0)
@@ -131,6 +176,8 @@
 	raw_pci_ops = &pci_mmcfg;
 	pci_probe = (pci_probe & ~PCI_PROBE_MASK) | PCI_PROBE_MMCONF;
 
+	unreachable_devices();
+
  out:
 	return 0;
 }
diff -urN linux-2.6.15-rc5/arch/i386/pci/pci.h linux-2.6.15-rc6/arch/i386/pci/pci.h
--- linux-2.6.15-rc5/arch/i386/pci/pci.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/arch/i386/pci/pci.h	2005-12-18 22:28:02.095942916 -0800
@@ -74,3 +74,10 @@
 
 extern int (*pcibios_enable_irq)(struct pci_dev *dev);
 extern void (*pcibios_disable_irq)(struct pci_dev *dev);
+
+extern int pci_conf1_write(unsigned int seg, unsigned int bus,
+			   unsigned int devfn, int reg, int len, u32 value);
+extern int pci_conf1_read(unsigned int seg, unsigned int bus,
+			  unsigned int devfn, int reg, int len, u32 *value);
+
+
diff -urN linux-2.6.15-rc5/arch/ia64/Kconfig linux-2.6.15-rc6/arch/ia64/Kconfig
--- linux-2.6.15-rc5/arch/ia64/Kconfig	2005-12-18 22:27:53.292550680 -0800
+++ linux-2.6.15-rc6/arch/ia64/Kconfig	2005-12-18 22:28:02.095942916 -0800
@@ -58,7 +58,7 @@
 	bool
 	select GENERIC_ALLOCATOR
 
-config ZONE_DMA_IS_DMA32
+config DMA_IS_DMA32
 	bool
 	default y
 
diff -urN linux-2.6.15-rc5/arch/ia64/configs/sn2_defconfig linux-2.6.15-rc6/arch/ia64/configs/sn2_defconfig
--- linux-2.6.15-rc5/arch/ia64/configs/sn2_defconfig	2005-12-18 22:27:53.296550858 -0800
+++ linux-2.6.15-rc6/arch/ia64/configs/sn2_defconfig	2005-12-18 22:28:02.100943139 -0800
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.13-rc6
-# Tue Aug 16 14:40:41 2005
+# Linux kernel version: 2.6.15-rc4
+# Fri Dec  2 10:33:48 2005
 #
 
 #
@@ -16,6 +16,7 @@
 # General setup
 #
 CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 CONFIG_POSIX_MQUEUE=y
@@ -26,6 +27,7 @@
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
 CONFIG_CPUSETS=y
+CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_EMBEDDED is not set
 CONFIG_KALLSYMS=y
 CONFIG_KALLSYMS_ALL=y
@@ -56,11 +58,29 @@
 CONFIG_STOP_MACHINE=y
 
 #
+# Block layer
+#
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
 # Processor type and features
 #
 CONFIG_IA64=y
 CONFIG_64BIT=y
 CONFIG_MMU=y
+CONFIG_SWIOTLB=y
 CONFIG_RWSEM_XCHGADD_ALGORITHM=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_TIME_INTERPOLATION=y
@@ -68,6 +88,7 @@
 CONFIG_GENERIC_IOMAP=y
 CONFIG_SCHED_NO_NO_OMIT_FRAME_POINTER=y
 CONFIG_IA64_UNCACHED_ALLOCATOR=y
+CONFIG_ZONE_DMA_IS_DMA32=y
 # CONFIG_IA64_GENERIC is not set
 # CONFIG_IA64_DIG is not set
 # CONFIG_IA64_HP_ZX1 is not set
@@ -87,16 +108,12 @@
 # CONFIG_HZ_1000 is not set
 CONFIG_HZ=250
 CONFIG_IA64_L1_CACHE_SHIFT=7
-CONFIG_NUMA=y
-CONFIG_VIRTUAL_MEM_MAP=y
-CONFIG_HOLES_IN_ZONE=y
-CONFIG_ARCH_DISCONTIGMEM_ENABLE=y
 # CONFIG_IA64_CYCLONE is not set
 CONFIG_IOSAPIC=y
 CONFIG_IA64_SGI_SN_XP=m
-CONFIG_FORCE_MAX_ZONEORDER=18
+CONFIG_FORCE_MAX_ZONEORDER=17
 CONFIG_SMP=y
-CONFIG_NR_CPUS=512
+CONFIG_NR_CPUS=1024
 # CONFIG_HOTPLUG_CPU is not set
 CONFIG_SCHED_SMT=y
 CONFIG_PREEMPT=y
@@ -107,7 +124,17 @@
 CONFIG_DISCONTIGMEM=y
 CONFIG_FLAT_NODE_MEM_MAP=y
 CONFIG_NEED_MULTIPLE_NODES=y
-CONFIG_HAVE_DEC_LOCK=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_ARCH_DISCONTIGMEM_ENABLE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_DISCONTIGMEM_DEFAULT=y
+CONFIG_NUMA=y
+CONFIG_VIRTUAL_MEM_MAP=y
+CONFIG_HOLES_IN_ZONE=y
+CONFIG_HAVE_ARCH_EARLY_PFN_TO_NID=y
 CONFIG_IA32_SUPPORT=y
 CONFIG_COMPAT=y
 CONFIG_IA64_MCA_RECOVERY=y
@@ -126,28 +153,35 @@
 # Power management and ACPI
 #
 CONFIG_PM=y
-CONFIG_ACPI=y
+# CONFIG_PM_LEGACY is not set
+# CONFIG_PM_DEBUG is not set
 
 #
 # ACPI (Advanced Configuration and Power Interface) Support
 #
+CONFIG_ACPI=y
 # CONFIG_ACPI_BUTTON is not set
 # CONFIG_ACPI_FAN is not set
 # CONFIG_ACPI_PROCESSOR is not set
 CONFIG_ACPI_NUMA=y
+CONFIG_ACPI_BLACKLIST_YEAR=0
 # CONFIG_ACPI_DEBUG is not set
 CONFIG_ACPI_POWER=y
 CONFIG_ACPI_SYSTEM=y
 # CONFIG_ACPI_CONTAINER is not set
 
 #
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
 # Bus options (PCI, PCMCIA)
 #
 CONFIG_PCI=y
 CONFIG_PCI_DOMAINS=y
 # CONFIG_PCI_MSI is not set
 CONFIG_PCI_LEGACY_PROC=y
-CONFIG_PCI_NAMES=y
 # CONFIG_PCI_DEBUG is not set
 
 #
@@ -191,8 +225,8 @@
 # CONFIG_INET_ESP is not set
 # CONFIG_INET_IPCOMP is not set
 # CONFIG_INET_TUNNEL is not set
-CONFIG_IP_TCPDIAG=y
-# CONFIG_IP_TCPDIAG_IPV6 is not set
+CONFIG_INET_DIAG=m
+CONFIG_INET_TCP_DIAG=m
 # CONFIG_TCP_CONG_ADVANCED is not set
 CONFIG_TCP_CONG_BIC=y
 CONFIG_IPV6=m
@@ -205,6 +239,11 @@
 # CONFIG_NETFILTER is not set
 
 #
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
 # SCTP Configuration (EXPERIMENTAL)
 #
 # CONFIG_IP_SCTP is not set
@@ -220,8 +259,11 @@
 # CONFIG_NET_DIVERT is not set
 # CONFIG_ECONET is not set
 # CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
 # CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
 
 #
 # Network testing
@@ -230,6 +272,7 @@
 # CONFIG_HAMRADIO is not set
 # CONFIG_IRDA is not set
 # CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
 
 #
 # Device Drivers
@@ -244,6 +287,11 @@
 # CONFIG_DEBUG_DRIVER is not set
 
 #
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
 # Memory Technology Devices (MTD)
 #
 # CONFIG_MTD is not set
@@ -275,16 +323,7 @@
 CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_BLK_DEV_RAM_SIZE=4096
 CONFIG_BLK_DEV_INITRD=y
-CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_CDROM_PKTCDVD is not set
-
-#
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
-CONFIG_IOSCHED_DEADLINE=y
-CONFIG_IOSCHED_CFQ=y
 CONFIG_ATA_OVER_ETH=m
 
 #
@@ -349,6 +388,7 @@
 #
 # SCSI device support
 #
+# CONFIG_RAID_ATTRS is not set
 CONFIG_SCSI=y
 CONFIG_SCSI_PROC_FS=y
 
@@ -375,11 +415,13 @@
 #
 CONFIG_SCSI_SPI_ATTRS=y
 CONFIG_SCSI_FC_ATTRS=y
-# CONFIG_SCSI_ISCSI_ATTRS is not set
+CONFIG_SCSI_ISCSI_ATTRS=m
+CONFIG_SCSI_SAS_ATTRS=y
 
 #
 # SCSI low-level drivers
 #
+CONFIG_ISCSI_TCP=m
 # CONFIG_BLK_DEV_3W_XXXX_RAID is not set
 # CONFIG_SCSI_3W_9XXX is not set
 # CONFIG_SCSI_ACARD is not set
@@ -389,15 +431,19 @@
 # CONFIG_SCSI_AIC79XX is not set
 # CONFIG_MEGARAID_NEWGEN is not set
 # CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
 CONFIG_SCSI_SATA=y
 # CONFIG_SCSI_SATA_AHCI is not set
 # CONFIG_SCSI_SATA_SVW is not set
 # CONFIG_SCSI_ATA_PIIX is not set
+# CONFIG_SCSI_SATA_MV is not set
 # CONFIG_SCSI_SATA_NV is not set
-# CONFIG_SCSI_SATA_PROMISE is not set
+# CONFIG_SCSI_PDC_ADMA is not set
 # CONFIG_SCSI_SATA_QSTOR is not set
+# CONFIG_SCSI_SATA_PROMISE is not set
 # CONFIG_SCSI_SATA_SX4 is not set
 # CONFIG_SCSI_SATA_SIL is not set
+# CONFIG_SCSI_SATA_SIL24 is not set
 # CONFIG_SCSI_SATA_SIS is not set
 # CONFIG_SCSI_SATA_ULI is not set
 # CONFIG_SCSI_SATA_VIA is not set
@@ -411,7 +457,6 @@
 # CONFIG_SCSI_IPR is not set
 # CONFIG_SCSI_QLOGIC_FC is not set
 CONFIG_SCSI_QLOGIC_1280=y
-# CONFIG_SCSI_QLOGIC_1280_1040 is not set
 CONFIG_SCSI_QLA2XXX=y
 # CONFIG_SCSI_QLA21XX is not set
 CONFIG_SCSI_QLA22XX=y
@@ -451,6 +496,7 @@
 CONFIG_FUSION=y
 CONFIG_FUSION_SPI=y
 CONFIG_FUSION_FC=y
+CONFIG_FUSION_SAS=y
 CONFIG_FUSION_MAX_SGE=128
 CONFIG_FUSION_CTL=m
 
@@ -479,6 +525,10 @@
 # CONFIG_ARCNET is not set
 
 #
+# PHY device support
+#
+
+#
 # Ethernet (10 or 100Mbit)
 #
 # CONFIG_NET_ETHERNET is not set
@@ -493,6 +543,7 @@
 # CONFIG_HAMACHI is not set
 # CONFIG_YELLOWFIN is not set
 # CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
 # CONFIG_SKGE is not set
 # CONFIG_SK98LIN is not set
 CONFIG_TIGON3=y
@@ -501,10 +552,10 @@
 #
 # Ethernet (10000 Mbit)
 #
+CONFIG_CHELSIO_T1=m
 # CONFIG_IXGB is not set
 CONFIG_S2IO=m
 # CONFIG_S2IO_NAPI is not set
-# CONFIG_2BUFF_MODE is not set
 
 #
 # Token Ring devices
@@ -583,6 +634,7 @@
 CONFIG_SERIAL_NONSTANDARD=y
 # CONFIG_ROCKETPORT is not set
 # CONFIG_CYCLADES is not set
+# CONFIG_DIGIEPCA is not set
 # CONFIG_MOXA_SMARTIO is not set
 # CONFIG_ISI is not set
 # CONFIG_SYNCLINKMP is not set
@@ -629,7 +681,8 @@
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
+CONFIG_AGP=y
+CONFIG_AGP_SGI_TIOCA=y
 # CONFIG_DRM is not set
 CONFIG_RAW_DRIVER=m
 # CONFIG_HPET is not set
@@ -641,12 +694,12 @@
 # TPM devices
 #
 # CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
 
 #
 # I2C support
 #
 # CONFIG_I2C is not set
-# CONFIG_I2C_SENSOR is not set
 
 #
 # Dallas's 1-wire bus
@@ -657,12 +710,17 @@
 # Hardware Monitoring support
 #
 # CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
 
 #
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -721,12 +779,15 @@
 #
 # USB Device Class drivers
 #
-# CONFIG_USB_BLUETOOTH_TTY is not set
 # CONFIG_USB_ACM is not set
 # CONFIG_USB_PRINTER is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
 #
 # CONFIG_USB_STORAGE is not set
 
@@ -751,9 +812,11 @@
 # CONFIG_USB_MTOUCH is not set
 # CONFIG_USB_ITMTOUCH is not set
 # CONFIG_USB_EGALAX is not set
+# CONFIG_USB_YEALINK is not set
 # CONFIG_USB_XPAD is not set
 # CONFIG_USB_ATI_REMOTE is not set
 # CONFIG_USB_KEYSPAN_REMOTE is not set
+# CONFIG_USB_APPLETOUCH is not set
 
 #
 # USB Imaging devices
@@ -824,11 +887,13 @@
 # InfiniBand support
 #
 CONFIG_INFINIBAND=m
-CONFIG_INFINIBAND_USER_VERBS=m
+# CONFIG_INFINIBAND_USER_MAD is not set
+CONFIG_INFINIBAND_USER_ACCESS=m
 CONFIG_INFINIBAND_MTHCA=m
 # CONFIG_INFINIBAND_MTHCA_DEBUG is not set
 CONFIG_INFINIBAND_IPOIB=m
 # CONFIG_INFINIBAND_IPOIB_DEBUG is not set
+CONFIG_INFINIBAND_SRP=m
 
 #
 # SN Devices
@@ -858,16 +923,12 @@
 CONFIG_REISERFS_FS_SECURITY=y
 # CONFIG_JFS_FS is not set
 CONFIG_FS_POSIX_ACL=y
-
-#
-# XFS support
-#
 CONFIG_XFS_FS=y
 CONFIG_XFS_EXPORT=y
-CONFIG_XFS_RT=y
 CONFIG_XFS_QUOTA=y
 # CONFIG_XFS_SECURITY is not set
 CONFIG_XFS_POSIX_ACL=y
+CONFIG_XFS_RT=y
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
 CONFIG_INOTIFY=y
@@ -878,6 +939,7 @@
 CONFIG_DNOTIFY=y
 CONFIG_AUTOFS_FS=m
 CONFIG_AUTOFS4_FS=m
+CONFIG_FUSE_FS=m
 
 #
 # CD-ROM/DVD Filesystems
@@ -904,13 +966,11 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVPTS_FS_XATTR is not set
 CONFIG_TMPFS=y
-CONFIG_TMPFS_XATTR=y
-CONFIG_TMPFS_SECURITY=y
 CONFIG_HUGETLBFS=y
 CONFIG_HUGETLB_PAGE=y
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=m
 
 #
 # Miscellaneous filesystems
@@ -959,6 +1019,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -1028,18 +1089,21 @@
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=m
 CONFIG_CRC32=y
-# CONFIG_LIBCRC32C is not set
+CONFIG_LIBCRC32C=m
 CONFIG_ZLIB_INFLATE=m
 CONFIG_ZLIB_DEFLATE=m
 CONFIG_GENERIC_ALLOCATOR=y
 CONFIG_GENERIC_HARDIRQS=y
 CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_PENDING_IRQ=y
 
 #
-# Profiling support
+# Instrumentation Support
 #
 # CONFIG_PROFILING is not set
+# CONFIG_KPROBES is not set
 
 #
 # Kernel hacking
@@ -1048,6 +1112,7 @@
 CONFIG_DEBUG_KERNEL=y
 CONFIG_MAGIC_SYSRQ=y
 CONFIG_LOG_BUF_SHIFT=20
+CONFIG_DETECT_SOFTLOCKUP=y
 # CONFIG_SCHEDSTATS is not set
 # CONFIG_DEBUG_SLAB is not set
 CONFIG_DEBUG_PREEMPT=y
@@ -1056,7 +1121,8 @@
 # CONFIG_DEBUG_KOBJECT is not set
 CONFIG_DEBUG_INFO=y
 # CONFIG_DEBUG_FS is not set
-# CONFIG_KPROBES is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_RCU_TORTURE_TEST is not set
 CONFIG_IA64_GRANULE_16MB=y
 # CONFIG_IA64_GRANULE_64MB is not set
 # CONFIG_IA64_PRINT_HAZARDS is not set
@@ -1097,7 +1163,7 @@
 # CONFIG_CRYPTO_ANUBIS is not set
 CONFIG_CRYPTO_DEFLATE=m
 # CONFIG_CRYPTO_MICHAEL_MIC is not set
-# CONFIG_CRYPTO_CRC32C is not set
+CONFIG_CRYPTO_CRC32C=m
 # CONFIG_CRYPTO_TEST is not set
 
 #
diff -urN linux-2.6.15-rc5/arch/ia64/configs/tiger_defconfig linux-2.6.15-rc6/arch/ia64/configs/tiger_defconfig
--- linux-2.6.15-rc5/arch/ia64/configs/tiger_defconfig	2005-12-18 22:27:53.297550903 -0800
+++ linux-2.6.15-rc6/arch/ia64/configs/tiger_defconfig	2005-12-18 22:28:02.102943228 -0800
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.14-rc1
-# Wed Sep 14 15:17:57 2005
+# Linux kernel version: 2.6.15-rc4
+# Fri Dec  2 16:06:32 2005
 #
 
 #
@@ -59,17 +59,36 @@
 CONFIG_STOP_MACHINE=y
 
 #
+# Block layer
+#
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
 # Processor type and features
 #
 CONFIG_IA64=y
 CONFIG_64BIT=y
 CONFIG_MMU=y
+CONFIG_SWIOTLB=y
 CONFIG_RWSEM_XCHGADD_ALGORITHM=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_TIME_INTERPOLATION=y
 CONFIG_EFI=y
 CONFIG_GENERIC_IOMAP=y
 CONFIG_SCHED_NO_NO_OMIT_FRAME_POINTER=y
+CONFIG_ZONE_DMA_IS_DMA32=y
 # CONFIG_IA64_GENERIC is not set
 CONFIG_IA64_DIG=y
 # CONFIG_IA64_HP_ZX1 is not set
@@ -82,18 +101,16 @@
 # CONFIG_IA64_PAGE_SIZE_8KB is not set
 CONFIG_IA64_PAGE_SIZE_16KB=y
 # CONFIG_IA64_PAGE_SIZE_64KB is not set
+CONFIG_PGTABLE_3=y
+# CONFIG_PGTABLE_4 is not set
 # CONFIG_HZ_100 is not set
 CONFIG_HZ_250=y
 # CONFIG_HZ_1000 is not set
 CONFIG_HZ=250
 CONFIG_IA64_L1_CACHE_SHIFT=7
-# CONFIG_NUMA is not set
-CONFIG_VIRTUAL_MEM_MAP=y
-CONFIG_HOLES_IN_ZONE=y
 CONFIG_IA64_CYCLONE=y
 CONFIG_IOSAPIC=y
-# CONFIG_IA64_SGI_SN_XP is not set
-CONFIG_FORCE_MAX_ZONEORDER=18
+CONFIG_FORCE_MAX_ZONEORDER=17
 CONFIG_SMP=y
 CONFIG_NR_CPUS=4
 CONFIG_HOTPLUG_CPU=y
@@ -106,7 +123,13 @@
 CONFIG_FLATMEM=y
 CONFIG_FLAT_NODE_MEM_MAP=y
 # CONFIG_SPARSEMEM_STATIC is not set
-CONFIG_HAVE_DEC_LOCK=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_ARCH_DISCONTIGMEM_ENABLE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_VIRTUAL_MEM_MAP=y
+CONFIG_HOLES_IN_ZONE=y
 CONFIG_IA32_SUPPORT=y
 CONFIG_COMPAT=y
 CONFIG_IA64_MCA_RECOVERY=y
@@ -118,7 +141,6 @@
 #
 CONFIG_EFI_VARS=y
 CONFIG_EFI_PCDP=y
-# CONFIG_DELL_RBU is not set
 CONFIG_BINFMT_ELF=y
 CONFIG_BINFMT_MISC=m
 
@@ -126,6 +148,7 @@
 # Power management and ACPI
 #
 CONFIG_PM=y
+CONFIG_PM_LEGACY=y
 # CONFIG_PM_DEBUG is not set
 
 #
@@ -226,14 +249,16 @@
 # CONFIG_NET_DIVERT is not set
 # CONFIG_ECONET is not set
 # CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
 # CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
 
 #
 # Network testing
 #
 # CONFIG_NET_PKTGEN is not set
-# CONFIG_NETFILTER_NETLINK is not set
 # CONFIG_HAMRADIO is not set
 # CONFIG_IRDA is not set
 # CONFIG_BT is not set
@@ -295,14 +320,6 @@
 CONFIG_BLK_DEV_RAM_SIZE=4096
 CONFIG_BLK_DEV_INITRD=y
 # CONFIG_CDROM_PKTCDVD is not set
-
-#
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
-CONFIG_IOSCHED_DEADLINE=y
-CONFIG_IOSCHED_CFQ=y
 # CONFIG_ATA_OVER_ETH is not set
 
 #
@@ -400,6 +417,7 @@
 #
 # SCSI low-level drivers
 #
+# CONFIG_ISCSI_TCP is not set
 # CONFIG_BLK_DEV_3W_XXXX_RAID is not set
 # CONFIG_SCSI_3W_9XXX is not set
 # CONFIG_SCSI_ACARD is not set
@@ -409,6 +427,7 @@
 # CONFIG_SCSI_AIC79XX is not set
 # CONFIG_MEGARAID_NEWGEN is not set
 # CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
 # CONFIG_SCSI_SATA is not set
 # CONFIG_SCSI_DMX3191D is not set
 # CONFIG_SCSI_FUTURE_DOMAIN is not set
@@ -424,7 +443,6 @@
 CONFIG_SCSI_QLOGIC_FC=y
 # CONFIG_SCSI_QLOGIC_FC_FIRMWARE is not set
 CONFIG_SCSI_QLOGIC_1280=y
-# CONFIG_SCSI_QLOGIC_1280_1040 is not set
 CONFIG_SCSI_QLA2XXX=y
 CONFIG_SCSI_QLA21XX=m
 CONFIG_SCSI_QLA22XX=m
@@ -463,6 +481,7 @@
 CONFIG_FUSION=y
 CONFIG_FUSION_SPI=y
 CONFIG_FUSION_FC=y
+# CONFIG_FUSION_SAS is not set
 CONFIG_FUSION_MAX_SGE=128
 CONFIG_FUSION_CTL=y
 
@@ -503,6 +522,7 @@
 CONFIG_MII=m
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
 # CONFIG_NET_VENDOR_3COM is not set
 
 #
@@ -727,6 +747,7 @@
 # TPM devices
 #
 # CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
 
 #
 # I2C support
@@ -812,12 +833,15 @@
 #
 # USB Device Class drivers
 #
-# CONFIG_USB_BLUETOOTH_TTY is not set
 # CONFIG_USB_ACM is not set
 # CONFIG_USB_PRINTER is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
 #
 CONFIG_USB_STORAGE=m
 # CONFIG_USB_STORAGE_DEBUG is not set
@@ -1123,9 +1147,10 @@
 CONFIG_GENERIC_PENDING_IRQ=y
 
 #
-# Profiling support
+# Instrumentation Support
 #
 # CONFIG_PROFILING is not set
+# CONFIG_KPROBES is not set
 
 #
 # Kernel hacking
@@ -1142,7 +1167,8 @@
 # CONFIG_DEBUG_KOBJECT is not set
 # CONFIG_DEBUG_INFO is not set
 # CONFIG_DEBUG_FS is not set
-# CONFIG_KPROBES is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_RCU_TORTURE_TEST is not set
 CONFIG_IA64_GRANULE_16MB=y
 # CONFIG_IA64_GRANULE_64MB is not set
 # CONFIG_IA64_PRINT_HAZARDS is not set
diff -urN linux-2.6.15-rc5/arch/ia64/ia32/binfmt_elf32.c linux-2.6.15-rc6/arch/ia64/ia32/binfmt_elf32.c
--- linux-2.6.15-rc5/arch/ia64/ia32/binfmt_elf32.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/arch/ia64/ia32/binfmt_elf32.c	2005-12-18 22:28:02.107943451 -0800
@@ -261,8 +261,6 @@
 {
 	set_personality(PER_LINUX32);
 	current->thread.map_base  = IA32_PAGE_OFFSET/3;
-	current->thread.task_size = IA32_PAGE_OFFSET;	/* use what Linux/x86 uses... */
-	set_fs(USER_DS);				/* set addr limit for new TASK_SIZE */
 }
 
 static unsigned long
diff -urN linux-2.6.15-rc5/arch/ia64/ia32/ia32priv.h linux-2.6.15-rc6/arch/ia64/ia32/ia32priv.h
--- linux-2.6.15-rc5/arch/ia64/ia32/ia32priv.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/arch/ia64/ia32/ia32priv.h	2005-12-18 22:28:02.108943495 -0800
@@ -305,7 +305,6 @@
 #define ELF_DATA	ELFDATA2LSB
 #define ELF_ARCH	EM_386
 
-#define IA32_PAGE_OFFSET	0xc0000000
 #define IA32_STACK_TOP		IA32_PAGE_OFFSET
 #define IA32_GATE_OFFSET	IA32_PAGE_OFFSET
 #define IA32_GATE_END		IA32_PAGE_OFFSET + PAGE_SIZE
diff -urN linux-2.6.15-rc5/arch/ia64/kernel/kprobes.c linux-2.6.15-rc6/arch/ia64/kernel/kprobes.c
--- linux-2.6.15-rc5/arch/ia64/kernel/kprobes.c	2005-12-18 22:27:53.309551437 -0800
+++ linux-2.6.15-rc6/arch/ia64/kernel/kprobes.c	2005-12-18 22:28:02.114943763 -0800
@@ -630,7 +630,7 @@
 			 */
 			save_previous_kprobe(kcb);
 			set_current_kprobe(p, kcb);
-			p->nmissed++;
+			kprobes_inc_nmissed_count(p);
 			prepare_ss(p, regs);
 			kcb->kprobe_status = KPROBE_REENTER;
 			return 1;
diff -urN linux-2.6.15-rc5/arch/ia64/kernel/process.c linux-2.6.15-rc6/arch/ia64/kernel/process.c
--- linux-2.6.15-rc5/arch/ia64/kernel/process.c	2005-12-18 22:27:53.316551749 -0800
+++ linux-2.6.15-rc6/arch/ia64/kernel/process.c	2005-12-18 22:28:02.121944075 -0800
@@ -721,8 +721,13 @@
 	/* drop floating-point and debug-register state if it exists: */
 	current->thread.flags &= ~(IA64_THREAD_FPH_VALID | IA64_THREAD_DBG_VALID);
 	ia64_drop_fpu(current);
-	if (IS_IA32_PROCESS(ia64_task_regs(current)))
+#ifdef CONFIG_IA32_SUPPORT
+	if (IS_IA32_PROCESS(ia64_task_regs(current))) {
 		ia32_drop_partial_page_list(current);
+		current->thread.task_size = IA32_PAGE_OFFSET;
+		set_fs(USER_DS);
+	}
+#endif
 }
 
 /*
diff -urN linux-2.6.15-rc5/arch/ia64/kernel/salinfo.c linux-2.6.15-rc6/arch/ia64/kernel/salinfo.c
--- linux-2.6.15-rc5/arch/ia64/kernel/salinfo.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/arch/ia64/kernel/salinfo.c	2005-12-18 22:28:02.122944119 -0800
@@ -293,7 +293,7 @@
 		if (file->f_flags & O_NONBLOCK)
 			return -EAGAIN;
 		if (down_interruptible(&data->sem))
-			return -ERESTARTSYS;
+			return -EINTR;
 	}
 
 	n = data->cpu_check;
diff -urN linux-2.6.15-rc5/arch/ia64/kernel/time.c linux-2.6.15-rc6/arch/ia64/kernel/time.c
--- linux-2.6.15-rc5/arch/ia64/kernel/time.c	2005-12-18 22:27:53.319551883 -0800
+++ linux-2.6.15-rc6/arch/ia64/kernel/time.c	2005-12-18 22:28:02.125944253 -0800
@@ -249,3 +249,32 @@
 	 */
 	set_normalized_timespec(&wall_to_monotonic, -xtime.tv_sec, -xtime.tv_nsec);
 }
+
+#define SMALLUSECS 100
+
+void
+udelay (unsigned long usecs)
+{
+	unsigned long start;
+	unsigned long cycles;
+	unsigned long smallusecs;
+
+	/*
+	 * Execute the non-preemptible delay loop (because the ITC might
+	 * not be synchronized between CPUS) in relatively short time
+	 * chunks, allowing preemption between the chunks.
+	 */
+	while (usecs > 0) {
+		smallusecs = (usecs > SMALLUSECS) ? SMALLUSECS : usecs;
+		preempt_disable();
+		cycles = smallusecs*local_cpu_data->cyc_per_usec;
+		start = ia64_get_itc();
+
+		while (ia64_get_itc() - start < cycles)
+			cpu_relax();
+
+		preempt_enable();
+		usecs -= smallusecs;
+	}
+}
+EXPORT_SYMBOL(udelay);
diff -urN linux-2.6.15-rc5/arch/ia64/kernel/uncached.c linux-2.6.15-rc6/arch/ia64/kernel/uncached.c
--- linux-2.6.15-rc5/arch/ia64/kernel/uncached.c	2005-12-18 22:27:53.320551927 -0800
+++ linux-2.6.15-rc6/arch/ia64/kernel/uncached.c	2005-12-18 22:28:02.126944297 -0800
@@ -53,7 +53,7 @@
 	if ((status != PAL_VISIBILITY_OK) &&
 	    (status != PAL_VISIBILITY_OK_REMOTE_NEEDED))
 		printk(KERN_DEBUG "pal_prefetch_visibility() returns %i on "
-		       "CPU %i\n", status, get_cpu());
+		       "CPU %i\n", status, raw_smp_processor_id());
 }
 
 
@@ -63,7 +63,7 @@
 	status = ia64_pal_mc_drain();
 	if (status)
 		printk(KERN_WARNING "ia64_pal_mc_drain() failed with %i on "
-		       "CPU %i\n", status, get_cpu());
+		       "CPU %i\n", status, raw_smp_processor_id());
 }
 
 
@@ -105,7 +105,7 @@
 	status = ia64_pal_prefetch_visibility(PAL_VISIBILITY_PHYSICAL);
 
 	dprintk(KERN_INFO "pal_prefetch_visibility() returns %i on cpu %i\n",
-		status, get_cpu());
+		status, raw_smp_processor_id());
 
 	if (!status) {
 		status = smp_call_function(uncached_ipi_visibility, NULL, 0, 1);
diff -urN linux-2.6.15-rc5/arch/ia64/kernel/vmlinux.lds.S linux-2.6.15-rc6/arch/ia64/kernel/vmlinux.lds.S
--- linux-2.6.15-rc5/arch/ia64/kernel/vmlinux.lds.S	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/arch/ia64/kernel/vmlinux.lds.S	2005-12-18 22:28:02.126944297 -0800
@@ -177,6 +177,9 @@
 	}
   . = ALIGN(PAGE_SIZE);		/* make sure the gate page doesn't expose kernel data */
 
+  .data.read_mostly : AT(ADDR(.data.read_mostly) - LOAD_OFFSET)
+        { *(.data.read_mostly) }
+
   .data.cacheline_aligned : AT(ADDR(.data.cacheline_aligned) - LOAD_OFFSET)
         { *(.data.cacheline_aligned) }
 
diff -urN linux-2.6.15-rc5/arch/ia64/mm/discontig.c linux-2.6.15-rc6/arch/ia64/mm/discontig.c
--- linux-2.6.15-rc5/arch/ia64/mm/discontig.c	2005-12-18 22:27:53.324552106 -0800
+++ linux-2.6.15-rc6/arch/ia64/mm/discontig.c	2005-12-18 22:28:02.130944476 -0800
@@ -50,8 +50,10 @@
  * To prevent cache aliasing effects, align per-node structures so that they
  * start at addresses that are strided by node number.
  */
+#define MAX_NODE_ALIGN_OFFSET	(32 * 1024 * 1024)
 #define NODEDATA_ALIGN(addr, node)						\
-	((((addr) + 1024*1024-1) & ~(1024*1024-1)) + (node)*PERCPU_PAGE_SIZE)
+	((((addr) + 1024*1024-1) & ~(1024*1024-1)) + 				\
+	     (((node)*PERCPU_PAGE_SIZE) & (MAX_NODE_ALIGN_OFFSET - 1)))
 
 /**
  * build_node_maps - callback to setup bootmem structs for each node
diff -urN linux-2.6.15-rc5/arch/ia64/sn/kernel/io_init.c linux-2.6.15-rc6/arch/ia64/sn/kernel/io_init.c
--- linux-2.6.15-rc5/arch/ia64/sn/kernel/io_init.c	2005-12-18 22:27:53.327552239 -0800
+++ linux-2.6.15-rc6/arch/ia64/sn/kernel/io_init.c	2005-12-18 22:28:02.134944654 -0800
@@ -3,7 +3,7 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 1992 - 1997, 2000-2004 Silicon Graphics, Inc. All rights reserved.
+ * Copyright (C) 1992 - 1997, 2000-2005 Silicon Graphics, Inc. All rights reserved.
  */
 
 #include <linux/bootmem.h>
@@ -147,6 +147,24 @@
 }
 
 /*
+ * sn_pcidev_info_get() - Retrieve the pcidev_info struct for the specified
+ *			  device.
+ */
+inline struct pcidev_info *
+sn_pcidev_info_get(struct pci_dev *dev)
+{
+	struct pcidev_info *pcidev;
+
+	list_for_each_entry(pcidev,
+			    &(SN_PCI_CONTROLLER(dev)->pcidev_info), pdi_list) {
+		if (pcidev->pdi_linux_pcidev == dev) {
+			return pcidev;
+		}
+	}
+	return NULL;
+}
+
+/*
  * sn_fixup_ionodes() - This routine initializes the HUB data strcuture for 
  *	each node in the system.
  */
@@ -229,6 +247,50 @@
 
 }
 
+/*
+ * sn_pci_window_fixup() - Create a pci_window for each device resource.
+ *			   Until ACPI support is added, we need this code
+ *			   to setup pci_windows for use by
+ *			   pcibios_bus_to_resource(),
+ *			   pcibios_resource_to_bus(), etc.
+ */
+static void
+sn_pci_window_fixup(struct pci_dev *dev, unsigned int count,
+		    int64_t * pci_addrs)
+{
+	struct pci_controller *controller = PCI_CONTROLLER(dev->bus);
+	unsigned int i;
+	unsigned int idx;
+	unsigned int new_count;
+	struct pci_window *new_window;
+
+	if (count == 0)
+		return;
+	idx = controller->windows;
+	new_count = controller->windows + count;
+	new_window = kcalloc(new_count, sizeof(struct pci_window), GFP_KERNEL);
+	if (new_window == NULL)
+		BUG();
+	if (controller->window) {
+		memcpy(new_window, controller->window,
+		       sizeof(struct pci_window) * controller->windows);
+		kfree(controller->window);
+	}
+
+	/* Setup a pci_window for each device resource. */
+	for (i = 0; i <= PCI_ROM_RESOURCE; i++) {
+		if (pci_addrs[i] == -1)
+			continue;
+
+		new_window[idx].offset = dev->resource[i].start - pci_addrs[i];
+		new_window[idx].resource = dev->resource[i];
+		idx++;
+	}
+
+	controller->windows = new_count;
+	controller->window = new_window;
+}
+
 void sn_pci_unfixup_slot(struct pci_dev *dev)
 {
 	struct pci_dev *host_pci_dev = SN_PCIDEV_INFO(dev)->host_pci_dev;
@@ -246,21 +308,23 @@
  */
 void sn_pci_fixup_slot(struct pci_dev *dev)
 {
+	unsigned int count = 0;
 	int idx;
 	int segment = pci_domain_nr(dev->bus);
 	int status = 0;
 	struct pcibus_bussoft *bs;
  	struct pci_bus *host_pci_bus;
  	struct pci_dev *host_pci_dev;
+	struct pcidev_info *pcidev_info;
+	int64_t pci_addrs[PCI_ROM_RESOURCE + 1];
  	struct sn_irq_info *sn_irq_info;
  	unsigned long size;
  	unsigned int bus_no, devfn;
 
 	pci_dev_get(dev); /* for the sysdata pointer */
-	dev->sysdata = kmalloc(sizeof(struct pcidev_info), GFP_KERNEL);
-	if (SN_PCIDEV_INFO(dev) <= 0)
+	pcidev_info = kzalloc(sizeof(struct pcidev_info), GFP_KERNEL);
+	if (pcidev_info <= 0)
 		BUG();		/* Cannot afford to run out of memory */
-	memset(SN_PCIDEV_INFO(dev), 0, sizeof(struct pcidev_info));
 
 	sn_irq_info = kmalloc(sizeof(struct sn_irq_info), GFP_KERNEL);
 	if (sn_irq_info <= 0)
@@ -270,22 +334,34 @@
 	/* Call to retrieve pci device information needed by kernel. */
 	status = sal_get_pcidev_info((u64) segment, (u64) dev->bus->number, 
 				     dev->devfn,
-				     (u64) __pa(SN_PCIDEV_INFO(dev)),
+				     (u64) __pa(pcidev_info),
 				     (u64) __pa(sn_irq_info));
 	if (status)
 		BUG(); /* Cannot get platform pci device information */
 
+	/* Add pcidev_info to list in sn_pci_controller struct */
+	list_add_tail(&pcidev_info->pdi_list,
+		      &(SN_PCI_CONTROLLER(dev->bus)->pcidev_info));
+
 	/* Copy over PIO Mapped Addresses */
 	for (idx = 0; idx <= PCI_ROM_RESOURCE; idx++) {
 		unsigned long start, end, addr;
 
-		if (!SN_PCIDEV_INFO(dev)->pdi_pio_mapped_addr[idx])
+		if (!pcidev_info->pdi_pio_mapped_addr[idx]) {
+			pci_addrs[idx] = -1;
 			continue;
+		}
 
 		start = dev->resource[idx].start;
 		end = dev->resource[idx].end;
 		size = end - start;
-		addr = SN_PCIDEV_INFO(dev)->pdi_pio_mapped_addr[idx];
+		if (size == 0) {
+			pci_addrs[idx] = -1;
+			continue;
+		}
+		pci_addrs[idx] = start;
+		count++;
+		addr = pcidev_info->pdi_pio_mapped_addr[idx];
 		addr = ((addr << 4) >> 4) | __IA64_UNCACHED_OFFSET;
 		dev->resource[idx].start = addr;
 		dev->resource[idx].end = addr + size;
@@ -294,23 +370,27 @@
 		else
 			dev->resource[idx].parent = &iomem_resource;
 	}
+	/* Create a pci_window in the pci_controller struct for
+	 * each device resource.
+	 */
+	if (count > 0)
+		sn_pci_window_fixup(dev, count, pci_addrs);
 
 	/*
 	 * Using the PROMs values for the PCI host bus, get the Linux
  	 * PCI host_pci_dev struct and set up host bus linkages
  	 */
 
- 	bus_no = (SN_PCIDEV_INFO(dev)->pdi_slot_host_handle >> 32) & 0xff;
- 	devfn = SN_PCIDEV_INFO(dev)->pdi_slot_host_handle & 0xffffffff;
+	bus_no = (pcidev_info->pdi_slot_host_handle >> 32) & 0xff;
+	devfn = pcidev_info->pdi_slot_host_handle & 0xffffffff;
  	host_pci_bus = pci_find_bus(segment, bus_no);
  	host_pci_dev = pci_get_slot(host_pci_bus, devfn);
 
-	SN_PCIDEV_INFO(dev)->host_pci_dev = host_pci_dev;
-	SN_PCIDEV_INFO(dev)->pdi_host_pcidev_info =
-	    					SN_PCIDEV_INFO(host_pci_dev);
-	SN_PCIDEV_INFO(dev)->pdi_linux_pcidev = dev;
+	pcidev_info->host_pci_dev = host_pci_dev;
+	pcidev_info->pdi_linux_pcidev = dev;
+	pcidev_info->pdi_host_pcidev_info = SN_PCIDEV_INFO(host_pci_dev);
 	bs = SN_PCIBUS_BUSSOFT(dev->bus);
-	SN_PCIDEV_INFO(dev)->pdi_pcibus_info = bs;
+	pcidev_info->pdi_pcibus_info = bs;
 
 	if (bs && bs->bs_asic_type < PCIIO_ASIC_MAX_TYPES) {
 		SN_PCIDEV_BUSPROVIDER(dev) = sn_pci_provider[bs->bs_asic_type];
@@ -320,11 +400,11 @@
 
 	/* Only set up IRQ stuff if this device has a host bus context */
 	if (bs && sn_irq_info->irq_irq) {
-		SN_PCIDEV_INFO(dev)->pdi_sn_irq_info = sn_irq_info;
-		dev->irq = SN_PCIDEV_INFO(dev)->pdi_sn_irq_info->irq_irq;
+		pcidev_info->pdi_sn_irq_info = sn_irq_info;
+		dev->irq = pcidev_info->pdi_sn_irq_info->irq_irq;
 		sn_irq_fixup(dev, sn_irq_info);
 	} else {
-		SN_PCIDEV_INFO(dev)->pdi_sn_irq_info = NULL;
+		pcidev_info->pdi_sn_irq_info = NULL;
 		kfree(sn_irq_info);
 	}
 }
@@ -338,6 +418,7 @@
 	int status = 0;
 	int nasid, cnode;
 	struct pci_controller *controller;
+	struct sn_pci_controller *sn_controller;
 	struct pcibus_bussoft *prom_bussoft_ptr;
 	struct hubdev_info *hubdev_info;
 	void *provider_soft = NULL;
@@ -349,10 +430,15 @@
 		return;		/*bus # does not exist */
 	prom_bussoft_ptr = __va(prom_bussoft_ptr);
 
- 	controller = kzalloc(sizeof(struct pci_controller), GFP_KERNEL);
+	/* Allocate a sn_pci_controller, which has a pci_controller struct
+	 * as the first member.
+	 */
+	sn_controller = kzalloc(sizeof(struct sn_pci_controller), GFP_KERNEL);
+	if (!sn_controller)
+		BUG();
+	INIT_LIST_HEAD(&sn_controller->pcidev_info);
+	controller = &sn_controller->pci_controller;
 	controller->segment = segment;
- 	if (!controller)
- 		BUG();
 
 	if (bus == NULL) {
  		bus = pci_scan_bus(busnum, &pci_root_ops, controller);
@@ -390,6 +476,29 @@
 	}
 
 	/*
+	 * Setup pci_windows for legacy IO and MEM space.
+	 * (Temporary until ACPI support is in place.)
+	 */
+	controller->window = kcalloc(2, sizeof(struct pci_window), GFP_KERNEL);
+	if (controller->window == NULL)
+		BUG();
+	controller->window[0].offset = prom_bussoft_ptr->bs_legacy_io;
+	controller->window[0].resource.name = "legacy_io";
+	controller->window[0].resource.flags = IORESOURCE_IO;
+	controller->window[0].resource.start = prom_bussoft_ptr->bs_legacy_io;
+	controller->window[0].resource.end =
+	    controller->window[0].resource.start + 0xffff;
+	controller->window[0].resource.parent = &ioport_resource;
+	controller->window[1].offset = prom_bussoft_ptr->bs_legacy_mem;
+	controller->window[1].resource.name = "legacy_mem";
+	controller->window[1].resource.flags = IORESOURCE_MEM;
+	controller->window[1].resource.start = prom_bussoft_ptr->bs_legacy_mem;
+	controller->window[1].resource.end =
+	    controller->window[1].resource.start + (1024 * 1024) - 1;
+	controller->window[1].resource.parent = &iomem_resource;
+	controller->windows = 2;
+
+	/*
 	 * Generic bus fixup goes here.  Don't reference prom_bussoft_ptr
 	 * after this point.
 	 */
@@ -421,7 +530,7 @@
 
 error_return:
 
-	kfree(controller);
+	kfree(sn_controller);
 	return;
 }
 
@@ -434,7 +543,7 @@
 		dev_dbg(dev, "%s: out of memory!\n", __FUNCTION__);
 		return;
 	}
-	element->sysdata = dev->sysdata;
+	element->sysdata = SN_PCIDEV_INFO(dev);
 	list_add(&element->entry, &sn_sysdata_list);
 }
 
diff -urN linux-2.6.15-rc5/arch/ia64/sn/kernel/sn2/ptc_deadlock.S linux-2.6.15-rc6/arch/ia64/sn/kernel/sn2/ptc_deadlock.S
--- linux-2.6.15-rc5/arch/ia64/sn/kernel/sn2/ptc_deadlock.S	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/arch/ia64/sn/kernel/sn2/ptc_deadlock.S	2005-12-18 22:28:02.135944698 -0800
@@ -39,9 +39,13 @@
 	mov	r8=r0
 
 1:
+	cmp.ne  p8,p9=r0,ptc1		// Test for shub type (ptc1 non-null on shub1)
+					// p8 = 1 if shub1, p9 = 1 if shub2
+
 	add	scr2=ALIAS_OFFSET,piowc	// Address of WRITE_STATUS alias register 
-	;;
-	ld8.acq	scr1=[scr2];;
+	mov	scr1=7;;		// Clear DEADLOCK, WRITE_ERROR, MULTI_WRITE_ERROR
+(p8)	st8.rel	[scr2]=scr1;;
+(p9)	ld8.acq	scr1=[scr2];;
 
 5:	ld8.acq	scr1=[piowc];;		// Wait for PIOs to complete.
 	hint	@pause
diff -urN linux-2.6.15-rc5/arch/ia64/sn/kernel/sn2/sn2_smp.c linux-2.6.15-rc6/arch/ia64/sn/kernel/sn2/sn2_smp.c
--- linux-2.6.15-rc5/arch/ia64/sn/kernel/sn2/sn2_smp.c	2005-12-18 22:27:53.329552328 -0800
+++ linux-2.6.15-rc6/arch/ia64/sn/kernel/sn2/sn2_smp.c	2005-12-18 22:28:02.136944743 -0800
@@ -202,7 +202,7 @@
 		     unsigned long end, unsigned long nbits)
 {
 	int i, opt, shub1, cnode, mynasid, cpu, lcpu = 0, nasid, flushed = 0;
-	int mymm = (mm == current->active_mm);
+	int mymm = (mm == current->active_mm && current->mm);
 	volatile unsigned long *ptc0, *ptc1;
 	unsigned long itc, itc2, flags, data0 = 0, data1 = 0, rr_value;
 	short nasids[MAX_NUMNODES], nix;
diff -urN linux-2.6.15-rc5/arch/ia64/sn/pci/pcibr/pcibr_reg.c linux-2.6.15-rc6/arch/ia64/sn/pci/pcibr/pcibr_reg.c
--- linux-2.6.15-rc5/arch/ia64/sn/pci/pcibr/pcibr_reg.c	2005-12-18 22:27:53.339552774 -0800
+++ linux-2.6.15-rc6/arch/ia64/sn/pci/pcibr/pcibr_reg.c	2005-12-18 22:28:02.146945189 -0800
@@ -25,7 +25,7 @@
  */
 void pcireg_control_bit_clr(struct pcibus_info *pcibus_info, uint64_t bits)
 {
-	union br_ptr *ptr = (union br_ptr *)pcibus_info->pbi_buscommon.bs_base;
+	union br_ptr __iomem *ptr = (union br_ptr __iomem *)pcibus_info->pbi_buscommon.bs_base;
 
 	if (pcibus_info) {
 		switch (pcibus_info->pbi_bridge_type) {
@@ -38,14 +38,14 @@
 		default:
 			panic
 			    ("pcireg_control_bit_clr: unknown bridgetype bridge 0x%p",
-			     (void *)ptr);
+			     ptr);
 		}
 	}
 }
 
 void pcireg_control_bit_set(struct pcibus_info *pcibus_info, uint64_t bits)
 {
-	union br_ptr *ptr = (union br_ptr *)pcibus_info->pbi_buscommon.bs_base;
+	union br_ptr __iomem *ptr = (union br_ptr __iomem *)pcibus_info->pbi_buscommon.bs_base;
 
 	if (pcibus_info) {
 		switch (pcibus_info->pbi_bridge_type) {
@@ -58,7 +58,7 @@
 		default:
 			panic
 			    ("pcireg_control_bit_set: unknown bridgetype bridge 0x%p",
-			     (void *)ptr);
+			     ptr);
 		}
 	}
 }
@@ -68,7 +68,7 @@
  */
 uint64_t pcireg_tflush_get(struct pcibus_info *pcibus_info)
 {
-	union br_ptr *ptr = (union br_ptr *)pcibus_info->pbi_buscommon.bs_base;
+	union br_ptr __iomem *ptr = (union br_ptr __iomem *)pcibus_info->pbi_buscommon.bs_base;
 	uint64_t ret = 0;
 
 	if (pcibus_info) {
@@ -82,7 +82,7 @@
 		default:
 			panic
 			    ("pcireg_tflush_get: unknown bridgetype bridge 0x%p",
-			     (void *)ptr);
+			     ptr);
 		}
 	}
 
@@ -98,7 +98,7 @@
  */
 uint64_t pcireg_intr_status_get(struct pcibus_info * pcibus_info)
 {
-	union br_ptr *ptr = (union br_ptr *)pcibus_info->pbi_buscommon.bs_base;
+	union br_ptr __iomem *ptr = (union br_ptr __iomem *)pcibus_info->pbi_buscommon.bs_base;
 	uint64_t ret = 0;
 
 	if (pcibus_info) {
@@ -112,7 +112,7 @@
 		default:
 			panic
 			    ("pcireg_intr_status_get: unknown bridgetype bridge 0x%p",
-			     (void *)ptr);
+			     ptr);
 		}
 	}
 	return ret;
@@ -123,7 +123,7 @@
  */
 void pcireg_intr_enable_bit_clr(struct pcibus_info *pcibus_info, uint64_t bits)
 {
-	union br_ptr *ptr = (union br_ptr *)pcibus_info->pbi_buscommon.bs_base;
+	union br_ptr __iomem *ptr = (union br_ptr __iomem *)pcibus_info->pbi_buscommon.bs_base;
 
 	if (pcibus_info) {
 		switch (pcibus_info->pbi_bridge_type) {
@@ -136,14 +136,14 @@
 		default:
 			panic
 			    ("pcireg_intr_enable_bit_clr: unknown bridgetype bridge 0x%p",
-			     (void *)ptr);
+			     ptr);
 		}
 	}
 }
 
 void pcireg_intr_enable_bit_set(struct pcibus_info *pcibus_info, uint64_t bits)
 {
-	union br_ptr *ptr = (union br_ptr *)pcibus_info->pbi_buscommon.bs_base;
+	union br_ptr __iomem *ptr = (union br_ptr __iomem *)pcibus_info->pbi_buscommon.bs_base;
 
 	if (pcibus_info) {
 		switch (pcibus_info->pbi_bridge_type) {
@@ -156,7 +156,7 @@
 		default:
 			panic
 			    ("pcireg_intr_enable_bit_set: unknown bridgetype bridge 0x%p",
-			     (void *)ptr);
+			     ptr);
 		}
 	}
 }
@@ -167,7 +167,7 @@
 void pcireg_intr_addr_addr_set(struct pcibus_info *pcibus_info, int int_n,
 			       uint64_t addr)
 {
-	union br_ptr *ptr = (union br_ptr *)pcibus_info->pbi_buscommon.bs_base;
+	union br_ptr __iomem *ptr = (union br_ptr __iomem *)pcibus_info->pbi_buscommon.bs_base;
 
 	if (pcibus_info) {
 		switch (pcibus_info->pbi_bridge_type) {
@@ -186,7 +186,7 @@
 		default:
 			panic
 			    ("pcireg_intr_addr_addr_get: unknown bridgetype bridge 0x%p",
-			     (void *)ptr);
+			     ptr);
 		}
 	}
 }
@@ -196,7 +196,7 @@
  */
 void pcireg_force_intr_set(struct pcibus_info *pcibus_info, int int_n)
 {
-	union br_ptr *ptr = (union br_ptr *)pcibus_info->pbi_buscommon.bs_base;
+	union br_ptr __iomem *ptr = (union br_ptr __iomem *)pcibus_info->pbi_buscommon.bs_base;
 
 	if (pcibus_info) {
 		switch (pcibus_info->pbi_bridge_type) {
@@ -209,7 +209,7 @@
 		default:
 			panic
 			    ("pcireg_force_intr_set: unknown bridgetype bridge 0x%p",
-			     (void *)ptr);
+			     ptr);
 		}
 	}
 }
@@ -219,7 +219,7 @@
  */
 uint64_t pcireg_wrb_flush_get(struct pcibus_info *pcibus_info, int device)
 {
-	union br_ptr *ptr = (union br_ptr *)pcibus_info->pbi_buscommon.bs_base;
+	union br_ptr __iomem *ptr = (union br_ptr __iomem *)pcibus_info->pbi_buscommon.bs_base;
 	uint64_t ret = 0;
 
 	if (pcibus_info) {
@@ -233,7 +233,7 @@
 			    __sn_readq_relaxed(&ptr->pic.p_wr_req_buf[device]);
 			break;
 		default:
-		      panic("pcireg_wrb_flush_get: unknown bridgetype bridge 0x%p", (void *)ptr);
+		      panic("pcireg_wrb_flush_get: unknown bridgetype bridge 0x%p", ptr);
 		}
 
 	}
@@ -244,7 +244,7 @@
 void pcireg_int_ate_set(struct pcibus_info *pcibus_info, int ate_index,
 			uint64_t val)
 {
-	union br_ptr *ptr = (union br_ptr *)pcibus_info->pbi_buscommon.bs_base;
+	union br_ptr __iomem *ptr = (union br_ptr __iomem *)pcibus_info->pbi_buscommon.bs_base;
 
 	if (pcibus_info) {
 		switch (pcibus_info->pbi_bridge_type) {
@@ -257,15 +257,15 @@
 		default:
 			panic
 			    ("pcireg_int_ate_set: unknown bridgetype bridge 0x%p",
-			     (void *)ptr);
+			     ptr);
 		}
 	}
 }
 
-uint64_t *pcireg_int_ate_addr(struct pcibus_info *pcibus_info, int ate_index)
+uint64_t __iomem *pcireg_int_ate_addr(struct pcibus_info *pcibus_info, int ate_index)
 {
-	union br_ptr *ptr = (union br_ptr *)pcibus_info->pbi_buscommon.bs_base;
-	uint64_t *ret = (uint64_t *) 0;
+	union br_ptr __iomem *ptr = (union br_ptr __iomem *)pcibus_info->pbi_buscommon.bs_base;
+	uint64_t __iomem *ret = NULL;
 
 	if (pcibus_info) {
 		switch (pcibus_info->pbi_bridge_type) {
@@ -278,7 +278,7 @@
 		default:
 			panic
 			    ("pcireg_int_ate_addr: unknown bridgetype bridge 0x%p",
-			     (void *)ptr);
+			     ptr);
 		}
 	}
 	return ret;
diff -urN linux-2.6.15-rc5/arch/ia64/sn/pci/tioca_provider.c linux-2.6.15-rc6/arch/ia64/sn/pci/tioca_provider.c
--- linux-2.6.15-rc5/arch/ia64/sn/pci/tioca_provider.c	2005-12-18 22:27:53.340552819 -0800
+++ linux-2.6.15-rc6/arch/ia64/sn/pci/tioca_provider.c	2005-12-18 22:28:02.146945189 -0800
@@ -38,10 +38,10 @@
 	uint64_t offset;
 	struct page *tmp;
 	struct tioca_common *tioca_common;
-	struct tioca *ca_base;
+	struct tioca __iomem *ca_base;
 
 	tioca_common = tioca_kern->ca_common;
-	ca_base = (struct tioca *)tioca_common->ca_common.bs_base;
+	ca_base = (struct tioca __iomem *)tioca_common->ca_common.bs_base;
 
 	if (list_empty(tioca_kern->ca_devices))
 		return 0;
@@ -215,7 +215,7 @@
 {
 	int cap_ptr;
 	uint32_t reg;
-	struct tioca *tioca_base;
+	struct tioca __iomem *tioca_base;
 	struct pci_dev *pdev;
 	struct tioca_common *common;
 
@@ -257,7 +257,7 @@
 	 * Set ca's fw to match
 	 */
 
-	tioca_base = (struct tioca *)common->ca_common.bs_base;
+	tioca_base = (struct tioca __iomem*)common->ca_common.bs_base;
 	__sn_setq_relaxed(&tioca_base->ca_control1, CA_AGP_FW_ENABLE);
 }
 
@@ -322,7 +322,7 @@
 tioca_dma_d48(struct pci_dev *pdev, uint64_t paddr)
 {
 	struct tioca_common *tioca_common;
-	struct tioca *ca_base;
+	struct tioca __iomem *ca_base;
 	uint64_t ct_addr;
 	dma_addr_t bus_addr;
 	uint32_t node_upper;
@@ -330,7 +330,7 @@
 	struct pcidev_info *pcidev_info = SN_PCIDEV_INFO(pdev);
 
 	tioca_common = (struct tioca_common *)pcidev_info->pdi_pcibus_info;
-	ca_base = (struct tioca *)tioca_common->ca_common.bs_base;
+	ca_base = (struct tioca __iomem *)tioca_common->ca_common.bs_base;
 
 	ct_addr = PHYS_TO_TIODMA(paddr);
 	if (!ct_addr)
diff -urN linux-2.6.15-rc5/arch/mips/mm/init.c linux-2.6.15-rc6/arch/mips/mm/init.c
--- linux-2.6.15-rc5/arch/mips/mm/init.c	2005-12-18 22:27:53.516560661 -0800
+++ linux-2.6.15-rc6/arch/mips/mm/init.c	2005-12-18 22:28:02.320952942 -0800
@@ -67,8 +67,8 @@
 
 	page = virt_to_page(empty_zero_page);
 	while (page < virt_to_page(empty_zero_page + (PAGE_SIZE << order))) {
-		set_bit(PG_reserved, &page->flags);
-		reset_page_mapcount(page);
+		SetPageReserved(page);
+		set_page_count(page, 1);
 		page++;
 	}
 
diff -urN linux-2.6.15-rc5/arch/powerpc/Kconfig linux-2.6.15-rc6/arch/powerpc/Kconfig
--- linux-2.6.15-rc5/arch/powerpc/Kconfig	2005-12-18 22:27:53.593564092 -0800
+++ linux-2.6.15-rc6/arch/powerpc/Kconfig	2005-12-18 22:28:02.395956283 -0800
@@ -227,7 +227,7 @@
 	  If you don't know what to do here, say N.
 
 config NR_CPUS
-	int "Maximum number of CPUs (2-32)"
+	int "Maximum number of CPUs (2-128)"
 	range 2 128
 	depends on SMP
 	default "32" if PPC64
diff -urN linux-2.6.15-rc5/arch/powerpc/kernel/kprobes.c linux-2.6.15-rc6/arch/powerpc/kernel/kprobes.c
--- linux-2.6.15-rc5/arch/powerpc/kernel/kprobes.c	2005-12-18 22:27:53.634565918 -0800
+++ linux-2.6.15-rc6/arch/powerpc/kernel/kprobes.c	2005-12-18 22:28:02.436958110 -0800
@@ -177,7 +177,7 @@
 			save_previous_kprobe(kcb);
 			set_current_kprobe(p, regs, kcb);
 			kcb->kprobe_saved_msr = regs->msr;
-			p->nmissed++;
+			kprobes_inc_nmissed_count(p);
 			prepare_singlestep(p, regs);
 			kcb->kprobe_status = KPROBE_REENTER;
 			return 1;
diff -urN linux-2.6.15-rc5/arch/powerpc/kernel/setup_64.c linux-2.6.15-rc6/arch/powerpc/kernel/setup_64.c
--- linux-2.6.15-rc5/arch/powerpc/kernel/setup_64.c	2005-12-18 22:27:53.664567255 -0800
+++ linux-2.6.15-rc6/arch/powerpc/kernel/setup_64.c	2005-12-18 22:28:02.465959402 -0800
@@ -102,7 +102,15 @@
 dev_t boot_dev;
 u64 ppc64_pft_size;
 
-struct ppc64_caches ppc64_caches;
+/* Pick defaults since we might want to patch instructions
+ * before we've read this from the device tree.
+ */
+struct ppc64_caches ppc64_caches = {
+	.dline_size = 0x80,
+	.log_dline_size = 7,
+	.iline_size = 0x80,
+	.log_iline_size = 7
+};
 EXPORT_SYMBOL_GPL(ppc64_caches);
 
 /*
diff -urN linux-2.6.15-rc5/arch/powerpc/kernel/syscalls.c linux-2.6.15-rc6/arch/powerpc/kernel/syscalls.c
--- linux-2.6.15-rc5/arch/powerpc/kernel/syscalls.c	2005-12-18 22:27:53.670567522 -0800
+++ linux-2.6.15-rc6/arch/powerpc/kernel/syscalls.c	2005-12-18 22:28:02.471959670 -0800
@@ -247,7 +247,7 @@
 #define OVERRIDE_MACHINE    0
 #endif
 
-static inline int override_machine(char *mach)
+static inline int override_machine(char __user *mach)
 {
 	if (OVERRIDE_MACHINE) {
 		/* change ppc64 to ppc */
diff -urN linux-2.6.15-rc5/arch/powerpc/mm/hash_utils_64.c linux-2.6.15-rc6/arch/powerpc/mm/hash_utils_64.c
--- linux-2.6.15-rc5/arch/powerpc/mm/hash_utils_64.c	2005-12-18 22:27:53.698568770 -0800
+++ linux-2.6.15-rc6/arch/powerpc/mm/hash_utils_64.c	2005-12-18 22:28:02.498960873 -0800
@@ -601,7 +601,7 @@
 	/* Handle hugepage regions */
 	if (unlikely(in_hugepage_area(mm->context, ea))) {
 		DBG_LOW(" -> huge page !\n");
-		return hash_huge_page(mm, access, ea, vsid, local);
+		return hash_huge_page(mm, access, ea, vsid, local, trap);
 	}
 
 	/* Get PTE and page size from page tables */
diff -urN linux-2.6.15-rc5/arch/powerpc/mm/hugetlbpage.c linux-2.6.15-rc6/arch/powerpc/mm/hugetlbpage.c
--- linux-2.6.15-rc5/arch/powerpc/mm/hugetlbpage.c	2005-12-18 22:27:53.699568815 -0800
+++ linux-2.6.15-rc6/arch/powerpc/mm/hugetlbpage.c	2005-12-18 22:28:02.499960917 -0800
@@ -148,43 +148,63 @@
 	return 0;
 }
 
+struct slb_flush_info {
+	struct mm_struct *mm;
+	u16 newareas;
+};
+
 static void flush_low_segments(void *parm)
 {
-	u16 areas = (unsigned long) parm;
+	struct slb_flush_info *fi = parm;
 	unsigned long i;
 
-	asm volatile("isync" : : : "memory");
+	BUILD_BUG_ON((sizeof(fi->newareas)*8) != NUM_LOW_AREAS);
+
+	if (current->active_mm != fi->mm)
+		return;
+
+	/* Only need to do anything if this CPU is working in the same
+	 * mm as the one which has changed */
 
-	BUILD_BUG_ON((sizeof(areas)*8) != NUM_LOW_AREAS);
+	/* update the paca copy of the context struct */
+	get_paca()->context = current->active_mm->context;
 
+	asm volatile("isync" : : : "memory");
 	for (i = 0; i < NUM_LOW_AREAS; i++) {
-		if (! (areas & (1U << i)))
+		if (! (fi->newareas & (1U << i)))
 			continue;
 		asm volatile("slbie %0"
 			     : : "r" ((i << SID_SHIFT) | SLBIE_C));
 	}
-
 	asm volatile("isync" : : : "memory");
 }
 
 static void flush_high_segments(void *parm)
 {
-	u16 areas = (unsigned long) parm;
+	struct slb_flush_info *fi = parm;
 	unsigned long i, j;
 
-	asm volatile("isync" : : : "memory");
 
-	BUILD_BUG_ON((sizeof(areas)*8) != NUM_HIGH_AREAS);
+	BUILD_BUG_ON((sizeof(fi->newareas)*8) != NUM_HIGH_AREAS);
 
+	if (current->active_mm != fi->mm)
+		return;
+
+	/* Only need to do anything if this CPU is working in the same
+	 * mm as the one which has changed */
+
+	/* update the paca copy of the context struct */
+	get_paca()->context = current->active_mm->context;
+
+	asm volatile("isync" : : : "memory");
 	for (i = 0; i < NUM_HIGH_AREAS; i++) {
-		if (! (areas & (1U << i)))
+		if (! (fi->newareas & (1U << i)))
 			continue;
 		for (j = 0; j < (1UL << (HTLB_AREA_SHIFT-SID_SHIFT)); j++)
 			asm volatile("slbie %0"
 				     :: "r" (((i << HTLB_AREA_SHIFT)
-					     + (j << SID_SHIFT)) | SLBIE_C));
+					      + (j << SID_SHIFT)) | SLBIE_C));
 	}
-
 	asm volatile("isync" : : : "memory");
 }
 
@@ -229,6 +249,7 @@
 static int open_low_hpage_areas(struct mm_struct *mm, u16 newareas)
 {
 	unsigned long i;
+	struct slb_flush_info fi;
 
 	BUILD_BUG_ON((sizeof(newareas)*8) != NUM_LOW_AREAS);
 	BUILD_BUG_ON((sizeof(mm->context.low_htlb_areas)*8) != NUM_LOW_AREAS);
@@ -244,19 +265,20 @@
 
 	mm->context.low_htlb_areas |= newareas;
 
-	/* update the paca copy of the context struct */
-	get_paca()->context = mm->context;
-
 	/* the context change must make it to memory before the flush,
 	 * so that further SLB misses do the right thing. */
 	mb();
-	on_each_cpu(flush_low_segments, (void *)(unsigned long)newareas, 0, 1);
+
+	fi.mm = mm;
+	fi.newareas = newareas;
+	on_each_cpu(flush_low_segments, &fi, 0, 1);
 
 	return 0;
 }
 
 static int open_high_hpage_areas(struct mm_struct *mm, u16 newareas)
 {
+	struct slb_flush_info fi;
 	unsigned long i;
 
 	BUILD_BUG_ON((sizeof(newareas)*8) != NUM_HIGH_AREAS);
@@ -280,7 +302,10 @@
 	/* the context change must make it to memory before the flush,
 	 * so that further SLB misses do the right thing. */
 	mb();
-	on_each_cpu(flush_high_segments, (void *)(unsigned long)newareas, 0, 1);
+
+	fi.mm = mm;
+	fi.newareas = newareas;
+	on_each_cpu(flush_high_segments, &fi, 0, 1);
 
 	return 0;
 }
@@ -639,8 +664,36 @@
 	return -ENOMEM;
 }
 
+/*
+ * Called by asm hashtable.S for doing lazy icache flush
+ */
+static unsigned int hash_huge_page_do_lazy_icache(unsigned long rflags,
+						  pte_t pte, int trap)
+{
+	struct page *page;
+	int i;
+
+	if (!pfn_valid(pte_pfn(pte)))
+		return rflags;
+
+	page = pte_page(pte);
+
+	/* page is dirty */
+	if (!test_bit(PG_arch_1, &page->flags) && !PageReserved(page)) {
+		if (trap == 0x400) {
+			for (i = 0; i < (HPAGE_SIZE / PAGE_SIZE); i++)
+				__flush_dcache_icache(page_address(page+i));
+			set_bit(PG_arch_1, &page->flags);
+		} else {
+			rflags |= HPTE_R_N;
+		}
+	}
+	return rflags;
+}
+
 int hash_huge_page(struct mm_struct *mm, unsigned long access,
-		   unsigned long ea, unsigned long vsid, int local)
+		   unsigned long ea, unsigned long vsid, int local,
+		   unsigned long trap)
 {
 	pte_t *ptep;
 	unsigned long old_pte, new_pte;
@@ -691,6 +744,11 @@
 	rflags = 0x2 | (!(new_pte & _PAGE_RW));
  	/* _PAGE_EXEC -> HW_NO_EXEC since it's inverted */
 	rflags |= ((new_pte & _PAGE_EXEC) ? 0 : HPTE_R_N);
+	if (!cpu_has_feature(CPU_FTR_COHERENT_ICACHE))
+		/* No CPU has hugepages but lacks no execute, so we
+		 * don't need to worry about that case */
+		rflags = hash_huge_page_do_lazy_icache(rflags, __pte(old_pte),
+						       trap);
 
 	/* Check if pte already has an hpte (case 2) */
 	if (unlikely(old_pte & _PAGE_HASHPTE)) {
@@ -703,7 +761,8 @@
 		slot = (hash & htab_hash_mask) * HPTES_PER_GROUP;
 		slot += (old_pte & _PAGE_F_GIX) >> 12;
 
-		if (ppc_md.hpte_updatepp(slot, rflags, va, 1, local) == -1)
+		if (ppc_md.hpte_updatepp(slot, rflags, va, mmu_huge_psize,
+					 local) == -1)
 			old_pte &= ~_PAGE_HPTEFLAGS;
 	}
 
diff -urN linux-2.6.15-rc5/arch/powerpc/mm/numa.c linux-2.6.15-rc6/arch/powerpc/mm/numa.c
--- linux-2.6.15-rc5/arch/powerpc/mm/numa.c	2005-12-18 22:27:53.704569037 -0800
+++ linux-2.6.15-rc6/arch/powerpc/mm/numa.c	2005-12-18 22:28:02.505961185 -0800
@@ -125,7 +125,7 @@
 
 	/* We didnt find a matching region, return start/end as 0 */
 	if (*start_pfn == -1UL)
-		start_pfn = 0;
+		*start_pfn = 0;
 }
 
 static inline void map_cpu_to_node(int cpu, int node)
diff -urN linux-2.6.15-rc5/arch/powerpc/mm/stab.c linux-2.6.15-rc6/arch/powerpc/mm/stab.c
--- linux-2.6.15-rc5/arch/powerpc/mm/stab.c	2005-12-18 22:27:53.708569216 -0800
+++ linux-2.6.15-rc6/arch/powerpc/mm/stab.c	2005-12-18 22:28:02.508961318 -0800
@@ -288,11 +288,6 @@
 		return;
 	}
 #endif /* CONFIG_PPC_ISERIES */
-#ifdef CONFIG_PPC_PSERIES
-	if (platform_is_lpar()) {
-		plpar_hcall_norets(H_SET_ASR, stabreal);
-		return;
-	}
-#endif
+
 	mtspr(SPRN_ASR, stabreal);
 }
diff -urN linux-2.6.15-rc5/arch/powerpc/platforms/powermac/feature.c linux-2.6.15-rc6/arch/powerpc/platforms/powermac/feature.c
--- linux-2.6.15-rc5/arch/powerpc/platforms/powermac/feature.c	2005-12-18 22:27:53.747570953 -0800
+++ linux-2.6.15-rc6/arch/powerpc/platforms/powermac/feature.c	2005-12-18 22:28:02.546963012 -0800
@@ -1650,11 +1650,19 @@
 	 */
 
 	if (macio->type == macio_intrepid) {
-		if (enable)
-			UN_OUT(UNI_N_CLOCK_SPREADING, 2);
-		else
-			UN_OUT(UNI_N_CLOCK_SPREADING, 0);
-		mdelay(40);
+		struct device_node *clock =
+			of_find_node_by_path("/uni-n@f8000000/hw-clock");
+		if (clock && get_property(clock, "platform-do-clockspreading",
+					  NULL)) {
+			printk(KERN_INFO "%sabling clock spreading on Intrepid"
+			       " ASIC\n", enable ? "En" : "Dis");
+			if (enable)
+				UN_OUT(UNI_N_CLOCK_SPREADING, 2);
+			else
+				UN_OUT(UNI_N_CLOCK_SPREADING, 0);
+			mdelay(40);
+		}
+		of_node_put(clock);
 	}
 
 	while (machine_is_compatible("PowerBook5,2") ||
@@ -1724,6 +1732,9 @@
 			pmac_low_i2c_close(ui2c);
 			break;
 		}
+		printk(KERN_INFO "%sabling clock spreading on i2c clock chip\n",
+		       enable ? "En" : "Dis");
+
 		pmac_low_i2c_setmode(ui2c, pmac_low_i2c_mode_stdsub);
 		rc = pmac_low_i2c_xfer(ui2c, 0xd2 | pmac_low_i2c_write, 0x80, buffer, 9);
 		DBG("write result: %d,", rc);
diff -urN linux-2.6.15-rc5/arch/powerpc/platforms/pseries/iommu.c linux-2.6.15-rc6/arch/powerpc/platforms/pseries/iommu.c
--- linux-2.6.15-rc5/arch/powerpc/platforms/pseries/iommu.c	2005-12-18 22:27:53.761571577 -0800
+++ linux-2.6.15-rc6/arch/powerpc/platforms/pseries/iommu.c	2005-12-18 22:28:02.560963635 -0800
@@ -109,6 +109,9 @@
 	u64 rc;
 	union tce_entry tce;
 
+	tcenum <<= TCE_PAGE_FACTOR;
+	npages <<= TCE_PAGE_FACTOR;
+
 	tce.te_word = 0;
 	tce.te_rpn = (virt_to_abs(uaddr)) >> TCE_SHIFT;
 	tce.te_rdwr = 1;
@@ -143,10 +146,7 @@
 	union tce_entry tce, *tcep;
 	long l, limit;
 
-	tcenum <<= TCE_PAGE_FACTOR;
-	npages <<= TCE_PAGE_FACTOR;
-
-	if (npages == 1)
+	if (TCE_PAGE_FACTOR == 0 && npages == 1)
 		return tce_build_pSeriesLP(tbl, tcenum, npages, uaddr,
 					   direction);
 
@@ -164,6 +164,9 @@
 		__get_cpu_var(tce_page) = tcep;
 	}
 
+	tcenum <<= TCE_PAGE_FACTOR;
+	npages <<= TCE_PAGE_FACTOR;
+
 	tce.te_word = 0;
 	tce.te_rpn = (virt_to_abs(uaddr)) >> TCE_SHIFT;
 	tce.te_rdwr = 1;
diff -urN linux-2.6.15-rc5/arch/powerpc/platforms/pseries/lpar.c linux-2.6.15-rc6/arch/powerpc/platforms/pseries/lpar.c
--- linux-2.6.15-rc5/arch/powerpc/platforms/pseries/lpar.c	2005-12-18 22:27:53.762571622 -0800
+++ linux-2.6.15-rc6/arch/powerpc/platforms/pseries/lpar.c	2005-12-18 22:28:02.561963680 -0800
@@ -298,18 +298,6 @@
 	if (!(vflags & HPTE_V_BOLTED))
 		DBG_LOW(" hpte_v=%016lx, hpte_r=%016lx\n", hpte_v, hpte_r);
 
-#if 1
-	{
-		int i;
-		for (i=0;i<8;i++) {
-			unsigned long w0, w1;
-			plpar_pte_read(0, hpte_group, &w0, &w1);
-			BUG_ON (HPTE_V_COMPARE(hpte_v, w0)
-				&& (w0 & HPTE_V_VALID));
-		}
-	}
-#endif
-
 	/* Now fill in the actual HPTE */
 	/* Set CEC cookie to 0         */
 	/* Zero page = 0               */
diff -urN linux-2.6.15-rc5/arch/ppc/Kconfig linux-2.6.15-rc6/arch/ppc/Kconfig
--- linux-2.6.15-rc5/arch/ppc/Kconfig	2005-12-18 22:27:53.798573226 -0800
+++ linux-2.6.15-rc6/arch/ppc/Kconfig	2005-12-18 22:28:02.596965239 -0800
@@ -767,14 +767,14 @@
 	  on it (826x, 827x, 8560).
 
 config PPC_CHRP
-	bool "  Common Hardware Reference Platform (CHRP) based machines"
+	bool
 	depends on PPC_MULTIPLATFORM
 	select PPC_I8259
 	select PPC_INDIRECT_PCI
 	default y
 
 config PPC_PMAC
-	bool "  Apple PowerMac based machines"
+	bool
 	depends on PPC_MULTIPLATFORM
 	select PPC_INDIRECT_PCI
 	default y
@@ -785,7 +785,7 @@
 	default y
 
 config PPC_PREP
-	bool "  PowerPC Reference Platform (PReP) based machines"
+	bool
 	depends on PPC_MULTIPLATFORM
 	select PPC_I8259
 	select PPC_INDIRECT_PCI
diff -urN linux-2.6.15-rc5/arch/ppc/kernel/smp.c linux-2.6.15-rc6/arch/ppc/kernel/smp.c
--- linux-2.6.15-rc5/arch/ppc/kernel/smp.c	2005-12-18 22:27:53.839575053 -0800
+++ linux-2.6.15-rc6/arch/ppc/kernel/smp.c	2005-12-18 22:28:02.636967022 -0800
@@ -301,6 +301,10 @@
 
 	/* Probe platform for CPUs: always linear. */
 	num_cpus = smp_ops->probe();
+	
+	if (num_cpus < 2)
+		smp_tb_synchronized = 1;
+	
 	for (i = 0; i < num_cpus; ++i)
 		cpu_set(i, cpu_possible_map);
 
diff -urN linux-2.6.15-rc5/arch/ppc/platforms/pmac_feature.c linux-2.6.15-rc6/arch/ppc/platforms/pmac_feature.c
--- linux-2.6.15-rc5/arch/ppc/platforms/pmac_feature.c	2005-12-18 22:27:53.881576924 -0800
+++ linux-2.6.15-rc6/arch/ppc/platforms/pmac_feature.c	2005-12-18 22:28:02.683969116 -0800
@@ -1606,11 +1606,19 @@
 	 */
 
 	if (macio->type == macio_intrepid) {
-		if (enable)
-			UN_OUT(UNI_N_CLOCK_SPREADING, 2);
-		else
-			UN_OUT(UNI_N_CLOCK_SPREADING, 0);
-		mdelay(40);
+		struct device_node *clock =
+			of_find_node_by_path("/uni-n@f8000000/hw-clock");
+		if (clock && get_property(clock, "platform-do-clockspreading",
+					  NULL)) {
+			printk(KERN_INFO "%sabling clock spreading on Intrepid"
+			       " ASIC\n", enable ? "En" : "Dis");
+			if (enable)
+				UN_OUT(UNI_N_CLOCK_SPREADING, 2);
+			else
+				UN_OUT(UNI_N_CLOCK_SPREADING, 0);
+			mdelay(40);
+		}
+		of_node_put(clock);
 	}
 
 	while (machine_is_compatible("PowerBook5,2") ||
@@ -1680,6 +1688,8 @@
 			pmac_low_i2c_close(ui2c);
 			break;
 		}
+		printk(KERN_INFO "%sabling clock spreading on i2c clock chip\n",
+		       enable ? "En" : "Dis");
 		pmac_low_i2c_setmode(ui2c, pmac_low_i2c_mode_stdsub);
 		rc = pmac_low_i2c_xfer(ui2c, 0xd2 | pmac_low_i2c_write, 0x80, buffer, 9);
 		DBG("write result: %d,", rc);
diff -urN linux-2.6.15-rc5/arch/ppc/syslib/ppc4xx_dma.c linux-2.6.15-rc6/arch/ppc/syslib/ppc4xx_dma.c
--- linux-2.6.15-rc5/arch/ppc/syslib/ppc4xx_dma.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/arch/ppc/syslib/ppc4xx_dma.c	2005-12-18 22:28:02.713970453 -0800
@@ -30,6 +30,7 @@
 
 #include <asm/system.h>
 #include <asm/io.h>
+#include <asm/dma.h>
 #include <asm/ppc4xx_dma.h>
 
 ppc_dma_ch_t dma_channels[MAX_PPC4xx_DMA_CHANNELS];
diff -urN linux-2.6.15-rc5/arch/sparc/Makefile linux-2.6.15-rc6/arch/sparc/Makefile
--- linux-2.6.15-rc5/arch/sparc/Makefile	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/arch/sparc/Makefile	2005-12-18 22:28:03.229993444 -0800
@@ -34,7 +34,7 @@
 # Renaming is done to avoid confusing pattern matching rules in 2.5.45 (multy-)
 INIT_Y		:= $(patsubst %/, %/built-in.o, $(init-y))
 CORE_Y		:= $(core-y)
-CORE_Y		+= kernel/ mm/ fs/ ipc/ security/ crypto/
+CORE_Y		+= kernel/ mm/ fs/ ipc/ security/ crypto/ block/
 CORE_Y		:= $(patsubst %/, %/built-in.o, $(CORE_Y))
 DRIVERS_Y	:= $(patsubst %/, %/built-in.o, $(drivers-y))
 NET_Y		:= $(patsubst %/, %/built-in.o, $(net-y))
diff -urN linux-2.6.15-rc5/arch/sparc/kernel/ebus.c linux-2.6.15-rc6/arch/sparc/kernel/ebus.c
--- linux-2.6.15-rc5/arch/sparc/kernel/ebus.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/arch/sparc/kernel/ebus.c	2005-12-18 22:28:03.231993533 -0800
@@ -22,7 +22,7 @@
 #include <asm/oplib.h>
 #include <asm/bpp.h>
 
-struct linux_ebus *ebus_chain = 0;
+struct linux_ebus *ebus_chain = NULL;
 
 /* We are together with pcic.c under CONFIG_PCI. */
 extern unsigned int pcic_pin_to_irq(unsigned int, char *name);
@@ -46,7 +46,7 @@
 	{ "SUNW,CS4231",	 0 },
 	{ "parallel",		 0 },
 	{ "se",			 2 },
-	{ 0, 0 }
+	{ NULL, 0 }
 };
 
 /*
@@ -55,7 +55,7 @@
  */
 static struct ebus_system_entry ebus_blacklist[] = {
 	{ "SUNW,JavaEngine1", je1_1 },
-	{ 0, 0 }
+	{ NULL, NULL }
 };
 
 static struct ebus_device_irq *ebus_blackp = NULL;
@@ -233,7 +233,7 @@
 			ebus_alloc(sizeof(struct linux_ebus_child));
 
 		child = dev->children;
-		child->next = 0;
+		child->next = NULL;
 		child->parent = dev;
 		child->bus = dev->bus;
 		fill_ebus_child(node, &regs[0], child);
@@ -243,7 +243,7 @@
 				ebus_alloc(sizeof(struct linux_ebus_child));
 
 			child = child->next;
-			child->next = 0;
+			child->next = NULL;
 			child->parent = dev;
 			child->bus = dev->bus;
 			fill_ebus_child(node, &regs[0], child);
@@ -275,7 +275,7 @@
 		}
 	}
 
-	pdev = pci_get_device(PCI_VENDOR_ID_SUN, PCI_DEVICE_ID_SUN_EBUS, 0);
+	pdev = pci_get_device(PCI_VENDOR_ID_SUN, PCI_DEVICE_ID_SUN_EBUS, NULL);
 	if (!pdev) {
 		return;
 	}
@@ -284,7 +284,7 @@
 
 	ebus_chain = ebus = (struct linux_ebus *)
 			ebus_alloc(sizeof(struct linux_ebus));
-	ebus->next = 0;
+	ebus->next = NULL;
 
 	while (ebusnd) {
 
@@ -325,8 +325,8 @@
 				ebus_alloc(sizeof(struct linux_ebus_device));
 
 		dev = ebus->devices;
-		dev->next = 0;
-		dev->children = 0;
+		dev->next = NULL;
+		dev->children = NULL;
 		dev->bus = ebus;
 		fill_ebus_device(nd, dev);
 
@@ -335,8 +335,8 @@
 				ebus_alloc(sizeof(struct linux_ebus_device));
 
 			dev = dev->next;
-			dev->next = 0;
-			dev->children = 0;
+			dev->next = NULL;
+			dev->children = NULL;
 			dev->bus = ebus;
 			fill_ebus_device(nd, dev);
 		}
@@ -353,7 +353,7 @@
 		ebus->next = (struct linux_ebus *)
 			ebus_alloc(sizeof(struct linux_ebus));
 		ebus = ebus->next;
-		ebus->next = 0;
+		ebus->next = NULL;
 		++num_ebus;
 	}
 	if (pdev)
diff -urN linux-2.6.15-rc5/arch/sparc/kernel/led.c linux-2.6.15-rc6/arch/sparc/kernel/led.c
--- linux-2.6.15-rc5/arch/sparc/kernel/led.c	2005-12-18 22:27:54.419600896 -0800
+++ linux-2.6.15-rc6/arch/sparc/kernel/led.c	2005-12-18 22:28:03.231993533 -0800
@@ -55,7 +55,7 @@
 	return len;
 }
 
-static int led_write_proc(struct file *file, const char *buffer,
+static int led_write_proc(struct file *file, const char __user *buffer,
 			  unsigned long count, void *data)
 {
 	char *buf = NULL;
diff -urN linux-2.6.15-rc5/arch/sparc/kernel/pcic.c linux-2.6.15-rc6/arch/sparc/kernel/pcic.c
--- linux-2.6.15-rc5/arch/sparc/kernel/pcic.c	2005-12-18 22:27:54.420600940 -0800
+++ linux-2.6.15-rc6/arch/sparc/kernel/pcic.c	2005-12-18 22:28:03.232993578 -0800
@@ -161,7 +161,7 @@
 static int pcic0_up;
 static struct linux_pcic pcic0;
 
-void * __iomem pcic_regs;
+void __iomem *pcic_regs;
 volatile int pcic_speculative;
 volatile int pcic_trapped;
 
diff -urN linux-2.6.15-rc5/arch/sparc/kernel/time.c linux-2.6.15-rc6/arch/sparc/kernel/time.c
--- linux-2.6.15-rc5/arch/sparc/kernel/time.c	2005-12-18 22:27:54.421600985 -0800
+++ linux-2.6.15-rc6/arch/sparc/kernel/time.c	2005-12-18 22:28:03.233993622 -0800
@@ -49,7 +49,7 @@
 enum sparc_clock_type sp_clock_typ;
 DEFINE_SPINLOCK(mostek_lock);
 void __iomem *mstk48t02_regs = NULL;
-static struct mostek48t08 *mstk48t08_regs = NULL;
+static struct mostek48t08 __iomem *mstk48t08_regs = NULL;
 static int set_rtc_mmss(unsigned long);
 static int sbus_do_settimeofday(struct timespec *tv);
 
@@ -342,7 +342,7 @@
 		/* XXX r/o attribute is somewhere in r.flags */
 		r.flags = clk_reg[0].which_io;
 		r.start = clk_reg[0].phys_addr;
-		mstk48t08_regs = (struct mostek48t08 *) sbus_ioremap(&r, 0,
+		mstk48t08_regs = sbus_ioremap(&r, 0,
 		    sizeof(struct mostek48t08), "mk48t08");
 
 		mstk48t02_regs = &mstk48t08_regs->regs;
diff -urN linux-2.6.15-rc5/arch/sparc/lib/atomic32.c linux-2.6.15-rc6/arch/sparc/lib/atomic32.c
--- linux-2.6.15-rc5/arch/sparc/lib/atomic32.c	2005-12-18 22:27:54.421600985 -0800
+++ linux-2.6.15-rc6/arch/sparc/lib/atomic32.c	2005-12-18 22:28:03.234993667 -0800
@@ -66,7 +66,6 @@
 	return ret != u;
 }
 
-static inline void atomic_clear_mask(unsigned long mask, unsigned long *addr)
 /* Atomic operations are already serializing */
 void atomic_set(atomic_t *v, int i)
 {
diff -urN linux-2.6.15-rc5/arch/sparc/mm/sun4c.c linux-2.6.15-rc6/arch/sparc/mm/sun4c.c
--- linux-2.6.15-rc5/arch/sparc/mm/sun4c.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/arch/sparc/mm/sun4c.c	2005-12-18 22:28:03.237993801 -0800
@@ -497,7 +497,7 @@
 	patch_kernel_fault_handler();
 }
 
-volatile unsigned long *sun4c_memerr_reg = NULL;
+volatile unsigned long __iomem *sun4c_memerr_reg = NULL;
 
 void __init sun4c_probe_memerr_reg(void)
 {
diff -urN linux-2.6.15-rc5/arch/sparc64/kernel/kprobes.c linux-2.6.15-rc6/arch/sparc64/kernel/kprobes.c
--- linux-2.6.15-rc5/arch/sparc64/kernel/kprobes.c	2005-12-18 22:27:54.426601207 -0800
+++ linux-2.6.15-rc6/arch/sparc64/kernel/kprobes.c	2005-12-18 22:28:03.240993934 -0800
@@ -138,7 +138,7 @@
 			 */
 			save_previous_kprobe(kcb);
 			set_current_kprobe(p, regs, kcb);
-			p->nmissed++;
+			kprobes_inc_nmissed_count(p);
 			kcb->kprobe_status = KPROBE_REENTER;
 			prepare_singlestep(p, regs, kcb);
 			return 1;
diff -urN linux-2.6.15-rc5/arch/um/Kconfig linux-2.6.15-rc6/arch/um/Kconfig
--- linux-2.6.15-rc5/arch/um/Kconfig	2005-12-18 22:27:54.433601519 -0800
+++ linux-2.6.15-rc6/arch/um/Kconfig	2005-12-18 22:28:03.248994291 -0800
@@ -289,6 +289,8 @@
 
 source "drivers/net/Kconfig"
 
+source "drivers/connector/Kconfig"
+
 source "fs/Kconfig"
 
 source "security/Kconfig"
diff -urN linux-2.6.15-rc5/arch/um/Makefile-x86_64 linux-2.6.15-rc6/arch/um/Makefile-x86_64
--- linux-2.6.15-rc5/arch/um/Makefile-x86_64	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/arch/um/Makefile-x86_64	2005-12-18 22:28:03.249994335 -0800
@@ -12,3 +12,7 @@
 
 ELF_ARCH := i386:x86-64
 ELF_FORMAT := elf64-x86-64
+
+# Not on all 64-bit distros /lib is a symlink to /lib64. PLD is an example.
+
+LINK-$(CONFIG_LD_SCRIPT_DYN) += -Wl,-rpath,/lib64
diff -urN linux-2.6.15-rc5/arch/um/include/sysdep-i386/stub.h linux-2.6.15-rc6/arch/um/include/sysdep-i386/stub.h
--- linux-2.6.15-rc5/arch/um/include/sysdep-i386/stub.h	2005-12-18 22:27:54.443601965 -0800
+++ linux-2.6.15-rc6/arch/um/include/sysdep-i386/stub.h	2005-12-18 22:28:03.257994692 -0800
@@ -6,8 +6,12 @@
 #ifndef __SYSDEP_STUB_H
 #define __SYSDEP_STUB_H
 
+#include <sys/mman.h>
 #include <asm/ptrace.h>
 #include <asm/unistd.h>
+#include "stub-data.h"
+#include "kern_constants.h"
+#include "uml-config.h"
 
 extern void stub_segv_handler(int sig);
 extern void stub_clone_handler(void);
@@ -76,23 +80,22 @@
 	return ret;
 }
 
-static inline long stub_syscall6(long syscall, long arg1, long arg2, long arg3,
-				 long arg4, long arg5, long arg6)
+static inline void trap_myself(void)
 {
-	long ret;
-
-	__asm__ volatile ("push %%ebp ; movl %%eax,%%ebp ; movl %1,%%eax ; "
-			"int $0x80 ; pop %%ebp"
-			: "=a" (ret)
-			: "g" (syscall), "b" (arg1), "c" (arg2), "d" (arg3),
-			  "S" (arg4), "D" (arg5), "0" (arg6));
-
-	return ret;
+	__asm("int3");
 }
 
-static inline void trap_myself(void)
+static inline void remap_stack(int fd, unsigned long offset)
 {
-	__asm("int3");
+	__asm__ volatile ("movl %%eax,%%ebp ; movl %0,%%eax ; int $0x80 ;"
+			  "movl %7, %%ebx ; movl %%eax, (%%ebx)"
+			  : : "g" (STUB_MMAP_NR), "b" (UML_CONFIG_STUB_DATA), 
+			    "c" (UM_KERN_PAGE_SIZE), 
+			    "d" (PROT_READ | PROT_WRITE),
+			    "S" (MAP_FIXED | MAP_SHARED), "D" (fd), 
+			    "a" (offset), 
+			    "i" (&((struct stub_data *) UML_CONFIG_STUB_DATA)->err) 
+			  : "memory");
 }
 
 #endif
diff -urN linux-2.6.15-rc5/arch/um/include/sysdep-x86_64/stub.h linux-2.6.15-rc6/arch/um/include/sysdep-x86_64/stub.h
--- linux-2.6.15-rc5/arch/um/include/sysdep-x86_64/stub.h	2005-12-18 22:27:54.443601965 -0800
+++ linux-2.6.15-rc6/arch/um/include/sysdep-x86_64/stub.h	2005-12-18 22:28:03.258994736 -0800
@@ -6,8 +6,12 @@
 #ifndef __SYSDEP_STUB_H
 #define __SYSDEP_STUB_H
 
+#include <sys/mman.h>
 #include <asm/unistd.h>
 #include <sysdep/ptrace_user.h>
+#include "stub-data.h"
+#include "kern_constants.h"
+#include "uml-config.h"
 
 extern void stub_segv_handler(int sig);
 extern void stub_clone_handler(void);
@@ -81,23 +85,23 @@
 	return ret;
 }
 
-static inline long stub_syscall6(long syscall, long arg1, long arg2, long arg3,
-				 long arg4, long arg5, long arg6)
+static inline void trap_myself(void)
 {
-	long ret;
-
-	__asm__ volatile ("movq %5,%%r10 ; movq %6,%%r8 ; "
-		"movq %7, %%r9; " __syscall : "=a" (ret)
-		: "0" (syscall), "D" (arg1), "S" (arg2), "d" (arg3),
-		  "g" (arg4), "g" (arg5), "g" (arg6)
-		: __syscall_clobber, "r10", "r8", "r9" );
-
-	return ret;
+	__asm("int3");
 }
 
-static inline void trap_myself(void)
+static inline void remap_stack(long fd, unsigned long offset)
 {
-	__asm("int3");
+	__asm__ volatile ("movq %4,%%r10 ; movq %5,%%r8 ; "
+			  "movq %6, %%r9; " __syscall "; movq %7, %%rbx ; "
+			  "movq %%rax, (%%rbx)": 
+			  : "a" (STUB_MMAP_NR), "D" (UML_CONFIG_STUB_DATA), 
+			    "S" (UM_KERN_PAGE_SIZE), 
+			    "d" (PROT_READ | PROT_WRITE), 
+                            "g" (MAP_FIXED | MAP_SHARED), "g" (fd), 
+			    "g" (offset),
+			    "i" (&((struct stub_data *) UML_CONFIG_STUB_DATA)->err)
+			  : __syscall_clobber, "r10", "r8", "r9" );
 }
 
 #endif
diff -urN linux-2.6.15-rc5/arch/um/include/um_uaccess.h linux-2.6.15-rc6/arch/um/include/um_uaccess.h
--- linux-2.6.15-rc5/arch/um/include/um_uaccess.h	2005-12-18 22:27:54.444602009 -0800
+++ linux-2.6.15-rc6/arch/um/include/um_uaccess.h	2005-12-18 22:28:03.258994736 -0800
@@ -17,6 +17,8 @@
 #include "uaccess-skas.h"
 #endif
 
+#include "asm/fixmap.h"
+
 #define __under_task_size(addr, size) \
 	(((unsigned long) (addr) < TASK_SIZE) && \
          (((unsigned long) (addr) + (size)) < TASK_SIZE))
diff -urN linux-2.6.15-rc5/arch/um/kernel/skas/clone.c linux-2.6.15-rc6/arch/um/kernel/skas/clone.c
--- linux-2.6.15-rc5/arch/um/kernel/skas/clone.c	2005-12-18 22:27:54.451602321 -0800
+++ linux-2.6.15-rc6/arch/um/kernel/skas/clone.c	2005-12-18 22:28:03.265995048 -0800
@@ -18,11 +18,10 @@
  * on some systems.
  */
 
-#define STUB_DATA(field) (((struct stub_data *) UML_CONFIG_STUB_DATA)->field)
-
 void __attribute__ ((__section__ (".__syscall_stub")))
 stub_clone_handler(void)
 {
+	struct stub_data *data = (struct stub_data *) UML_CONFIG_STUB_DATA;
 	long err;
 
 	err = stub_syscall2(__NR_clone, CLONE_PARENT | CLONE_FILES | SIGCHLD,
@@ -35,17 +34,21 @@
 	if(err)
 		goto out;
 
-	err = stub_syscall3(__NR_setitimer, ITIMER_VIRTUAL,
-			    (long) &STUB_DATA(timer), 0);
+	err = stub_syscall3(__NR_setitimer, ITIMER_VIRTUAL, 
+			    (long) &data->timer, 0);
 	if(err)
 		goto out;
 
-	err = stub_syscall6(STUB_MMAP_NR, UML_CONFIG_STUB_DATA,
-			    UM_KERN_PAGE_SIZE, PROT_READ | PROT_WRITE,
-			    MAP_FIXED | MAP_SHARED, STUB_DATA(fd),
-			    STUB_DATA(offset));
+	remap_stack(data->fd, data->offset);
+	goto done;
+
  out:
-	/* save current result. Parent: pid; child: retcode of mmap */
-	STUB_DATA(err) = err;
+	/* save current result. 
+	 * Parent: pid; 
+	 * child: retcode of mmap already saved and it jumps around this 
+	 * assignment
+	 */
+	data->err = err;
+ done:
 	trap_myself();
 }
diff -urN linux-2.6.15-rc5/arch/um/kernel/skas/include/uaccess-skas.h linux-2.6.15-rc6/arch/um/kernel/skas/include/uaccess-skas.h
--- linux-2.6.15-rc5/arch/um/kernel/skas/include/uaccess-skas.h	2005-12-18 22:27:54.451602321 -0800
+++ linux-2.6.15-rc6/arch/um/kernel/skas/include/uaccess-skas.h	2005-12-18 22:28:03.266995093 -0800
@@ -7,7 +7,6 @@
 #define __SKAS_UACCESS_H
 
 #include "asm/errno.h"
-#include "asm/fixmap.h"
 
 /* No SKAS-specific checking. */
 #define access_ok_skas(type, addr, size) 0
diff -urN linux-2.6.15-rc5/arch/um/scripts/Makefile.rules linux-2.6.15-rc6/arch/um/scripts/Makefile.rules
--- linux-2.6.15-rc5/arch/um/scripts/Makefile.rules	2005-12-18 22:27:54.460602722 -0800
+++ linux-2.6.15-rc6/arch/um/scripts/Makefile.rules	2005-12-18 22:28:03.281995761 -0800
@@ -21,11 +21,6 @@
 endef
 
 
-# The stubs and unmap.o can't try to call mcount or update basic block data
-define unprofile
-	$(patsubst -pg,,$(patsubst -fprofile-arcs -ftest-coverage,,$(1)))
-endef
-
 # cmd_make_link checks to see if the $(foo-dir) variable starts with a /.  If
 # so, it's considered to be a path relative to $(srcdir) rather than
 # $(srcdir)/arch/$(SUBARCH).  This is because x86_64 wants to get ldt.c from
diff -urN linux-2.6.15-rc5/arch/x86_64/ia32/ia32_binfmt.c linux-2.6.15-rc6/arch/x86_64/ia32/ia32_binfmt.c
--- linux-2.6.15-rc5/arch/x86_64/ia32/ia32_binfmt.c	2005-12-18 22:27:54.467603034 -0800
+++ linux-2.6.15-rc6/arch/x86_64/ia32/ia32_binfmt.c	2005-12-18 22:28:03.288996073 -0800
@@ -217,8 +217,7 @@
 	if (!tsk_used_math(tsk))
 		return 0;
 	if (!regs)
-		regs = (struct pt_regs *)tsk->thread.rsp0;
-	--regs;
+		regs = ((struct pt_regs *)tsk->thread.rsp0) - 1;
 	if (tsk == current)
 		unlazy_fpu(tsk);
 	set_fs(KERNEL_DS); 
diff -urN linux-2.6.15-rc5/arch/x86_64/kernel/kprobes.c linux-2.6.15-rc6/arch/x86_64/kernel/kprobes.c
--- linux-2.6.15-rc5/arch/x86_64/kernel/kprobes.c	2005-12-18 22:27:54.474603346 -0800
+++ linux-2.6.15-rc6/arch/x86_64/kernel/kprobes.c	2005-12-18 22:28:03.294996340 -0800
@@ -329,7 +329,7 @@
 				 */
 				save_previous_kprobe(kcb);
 				set_current_kprobe(p, regs, kcb);
-				p->nmissed++;
+				kprobes_inc_nmissed_count(p);
 				prepare_singlestep(p, regs);
 				kcb->kprobe_status = KPROBE_REENTER;
 				return 1;
diff -urN linux-2.6.15-rc5/arch/x86_64/kernel/smpboot.c linux-2.6.15-rc6/arch/x86_64/kernel/smpboot.c
--- linux-2.6.15-rc5/arch/x86_64/kernel/smpboot.c	2005-12-18 22:27:54.481603658 -0800
+++ linux-2.6.15-rc6/arch/x86_64/kernel/smpboot.c	2005-12-18 22:28:03.302996697 -0800
@@ -1181,7 +1181,7 @@
 	if (cpu == 0)
 		return -EBUSY;
 
-	disable_APIC_timer();
+	clear_local_APIC();
 
 	/*
 	 * HACK:
diff -urN linux-2.6.15-rc5/arch/x86_64/kernel/time.c linux-2.6.15-rc6/arch/x86_64/kernel/time.c
--- linux-2.6.15-rc5/arch/x86_64/kernel/time.c	2005-12-18 22:27:54.483603747 -0800
+++ linux-2.6.15-rc6/arch/x86_64/kernel/time.c	2005-12-18 22:28:03.304996786 -0800
@@ -59,7 +59,7 @@
 unsigned int cpu_khz;					/* TSC clocks / usec, not used here */
 static unsigned long hpet_period;			/* fsecs / HPET clock */
 unsigned long hpet_tick;				/* HPET clocks / interrupt */
-static int hpet_use_timer;
+static int hpet_use_timer;				/* Use counter of hpet for time keeping, otherwise PIT */
 unsigned long vxtime_hz = PIT_TICK_RATE;
 int report_lost_ticks;				/* command line option */
 unsigned long long monotonic_base;
@@ -908,12 +908,14 @@
 	if (!hpet_init())
                 vxtime_hz = (1000000000000000L + hpet_period / 2) /
 			hpet_period;
+	else
+		vxtime.hpet_address = 0;
 
 	if (hpet_use_timer) {
 		cpu_khz = hpet_calibrate_tsc();
 		timename = "HPET";
 #ifdef CONFIG_X86_PM_TIMER
-	} else if (pmtmr_ioport) {
+	} else if (pmtmr_ioport && !vxtime.hpet_address) {
 		vxtime_hz = PM_TIMER_FREQUENCY;
 		timename = "PM";
 		pit_init();
diff -urN linux-2.6.15-rc5/arch/x86_64/mm/ioremap.c linux-2.6.15-rc6/arch/x86_64/mm/ioremap.c
--- linux-2.6.15-rc5/arch/x86_64/mm/ioremap.c	2005-12-18 22:27:54.487603925 -0800
+++ linux-2.6.15-rc6/arch/x86_64/mm/ioremap.c	2005-12-18 22:28:03.308996964 -0800
@@ -247,9 +247,15 @@
 	return __ioremap(phys_addr, size, _PAGE_PCD);
 }
 
+/**
+ * iounmap - Free a IO remapping
+ * @addr: virtual address from ioremap_*
+ *
+ * Caller must ensure there is only one unmapping for the same pointer.
+ */
 void iounmap(volatile void __iomem *addr)
 {
-	struct vm_struct *p;
+	struct vm_struct *p, *o;
 
 	if (addr <= high_memory) 
 		return; 
@@ -257,12 +263,31 @@
 		addr < phys_to_virt(ISA_END_ADDRESS))
 		return;
 
-	write_lock(&vmlist_lock);
-	p = __remove_vm_area((void *)((unsigned long)addr & PAGE_MASK));
-	if (!p)
+	addr = (volatile void __iomem *)(PAGE_MASK & (unsigned long __force)addr);
+	/* Use the vm area unlocked, assuming the caller
+	   ensures there isn't another iounmap for the same address
+	   in parallel. Reuse of the virtual address is prevented by
+	   leaving it in the global lists until we're done with it.
+	   cpa takes care of the direct mappings. */
+	read_lock(&vmlist_lock);
+	for (p = vmlist; p; p = p->next) {
+		if (p->addr == addr)
+			break;
+	}
+	read_unlock(&vmlist_lock);
+
+	if (!p) {
 		printk("iounmap: bad address %p\n", addr);
-	else if (p->flags >> 20)
+		dump_stack();
+		return;
+	}
+
+	/* Reset the direct mapping. Can block */
+	if (p->flags >> 20)
 		ioremap_change_attr(p->phys_addr, p->size, 0);
-	write_unlock(&vmlist_lock);
+
+	/* Finally remove it */
+	o = remove_vm_area((void *)addr);
+	BUG_ON(p != o || o == NULL);
 	kfree(p); 
 }
diff -urN linux-2.6.15-rc5/arch/x86_64/mm/numa.c linux-2.6.15-rc6/arch/x86_64/mm/numa.c
--- linux-2.6.15-rc5/arch/x86_64/mm/numa.c	2005-12-18 22:27:54.488603970 -0800
+++ linux-2.6.15-rc6/arch/x86_64/mm/numa.c	2005-12-18 22:28:03.309997009 -0800
@@ -53,6 +53,8 @@
 	int res = -1;
 	unsigned long addr, end;
 
+	if (shift >= 64)
+		return -1;
 	memset(memnodemap, 0xff, sizeof(memnodemap));
 	for (i = 0; i < numnodes; i++) {
 		addr = nodes[i].start;
@@ -65,7 +67,7 @@
 			if (memnodemap[addr >> shift] != 0xff)
 				return -1;
 			memnodemap[addr >> shift] = i;
-			addr += (1 << shift);
+                       addr += (1UL << shift);
 		} while (addr < end);
 		res = 1;
 	} 
diff -urN linux-2.6.15-rc5/arch/x86_64/pci/mmconfig.c linux-2.6.15-rc6/arch/x86_64/pci/mmconfig.c
--- linux-2.6.15-rc5/arch/x86_64/pci/mmconfig.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/arch/x86_64/pci/mmconfig.c	2005-12-18 22:28:03.310997053 -0800
@@ -8,18 +8,21 @@
 #include <linux/pci.h>
 #include <linux/init.h>
 #include <linux/acpi.h>
+#include <linux/bitmap.h>
 #include "pci.h"
 
 #define MMCONFIG_APER_SIZE (256*1024*1024)
 
+static DECLARE_BITMAP(fallback_slots, 32);
+
 /* Static virtual mapping of the MMCONFIG aperture */
 struct mmcfg_virt {
 	struct acpi_table_mcfg_config *cfg;
-	char *virt;
+	char __iomem *virt;
 };
 static struct mmcfg_virt *pci_mmcfg_virt;
 
-static char *get_virt(unsigned int seg, int bus)
+static char __iomem *get_virt(unsigned int seg, unsigned bus)
 {
 	int cfg_num = -1;
 	struct acpi_table_mcfg_config *cfg;
@@ -27,10 +30,9 @@
 	while (1) {
 		++cfg_num;
 		if (cfg_num >= pci_mmcfg_config_num) {
-			/* something bad is going on, no cfg table is found. */
-			/* so we fall back to the old way we used to do this */
-			/* and just rely on the first entry to be correct. */
-			return pci_mmcfg_virt[0].virt;
+			/* Not found - fall back to type 1. This happens
+			   e.g. on the internal devices of a K8 northbridge. */
+			return NULL;
 		}
 		cfg = pci_mmcfg_virt[cfg_num].cfg;
 		if (cfg->pci_segment_group_number != seg)
@@ -41,20 +43,30 @@
 	}
 }
 
-static inline char *pci_dev_base(unsigned int seg, unsigned int bus, unsigned int devfn)
+static char __iomem *pci_dev_base(unsigned int seg, unsigned int bus, unsigned int devfn)
 {
-
-	return get_virt(seg, bus) + ((bus << 20) | (devfn << 12));
+	char __iomem *addr;
+	if (seg == 0 && bus == 0 && test_bit(PCI_SLOT(devfn), &fallback_slots))
+		return NULL;
+	addr = get_virt(seg, bus);
+	if (!addr)
+		return NULL;
+ 	return addr + ((bus << 20) | (devfn << 12));
 }
 
 static int pci_mmcfg_read(unsigned int seg, unsigned int bus,
 			  unsigned int devfn, int reg, int len, u32 *value)
 {
-	char *addr = pci_dev_base(seg, bus, devfn);
+	char __iomem *addr;
 
+	/* Why do we have this when nobody checks it. How about a BUG()!? -AK */
 	if (unlikely(!value || (bus > 255) || (devfn > 255) || (reg > 4095)))
 		return -EINVAL;
 
+	addr = pci_dev_base(seg, bus, devfn);
+	if (!addr)
+		return pci_conf1_read(seg,bus,devfn,reg,len,value);
+
 	switch (len) {
 	case 1:
 		*value = readb(addr + reg);
@@ -73,11 +85,16 @@
 static int pci_mmcfg_write(unsigned int seg, unsigned int bus,
 			   unsigned int devfn, int reg, int len, u32 value)
 {
-	char *addr = pci_dev_base(seg, bus, devfn);
+	char __iomem *addr;
 
+	/* Why do we have this when nobody checks it. How about a BUG()!? -AK */
 	if (unlikely((bus > 255) || (devfn > 255) || (reg > 4095)))
 		return -EINVAL;
 
+	addr = pci_dev_base(seg, bus, devfn);
+	if (!addr)
+		return pci_conf1_write(seg,bus,devfn,reg,len,value);
+
 	switch (len) {
 	case 1:
 		writeb(value, addr + reg);
@@ -98,6 +115,30 @@
 	.write =	pci_mmcfg_write,
 };
 
+/* K8 systems have some devices (typically in the builtin northbridge)
+   that are only accessible using type1
+   Normally this can be expressed in the MCFG by not listing them
+   and assigning suitable _SEGs, but this isn't implemented in some BIOS.
+   Instead try to discover all devices on bus 0 that are unreachable using MM
+   and fallback for them.
+   We only do this for bus 0/seg 0 */
+static __init void unreachable_devices(void)
+{
+	int i;
+	for (i = 0; i < 32; i++) {
+		u32 val1;
+		char __iomem *addr;
+
+		pci_conf1_read(0, 0, PCI_DEVFN(i,0), 0, 4, &val1);
+		if (val1 == 0xffffffff)
+			continue;
+		addr = pci_dev_base(0, 0, PCI_DEVFN(i, 0));
+		if (addr == NULL|| readl(addr) != val1) {
+			set_bit(i, &fallback_slots);
+		}
+	}
+}
+
 static int __init pci_mmcfg_init(void)
 {
 	int i;
@@ -128,6 +169,8 @@
 		printk(KERN_INFO "PCI: Using MMCONFIG at %x\n", pci_mmcfg_config[i].base_address);
 	}
 
+	unreachable_devices();
+
 	raw_pci_ops = &pci_mmcfg;
 	pci_probe = (pci_probe & ~PCI_PROBE_MASK) | PCI_PROBE_MMCONF;
 
diff -urN linux-2.6.15-rc5/drivers/acpi/pci_link.c linux-2.6.15-rc6/drivers/acpi/pci_link.c
--- linux-2.6.15-rc5/drivers/acpi/pci_link.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/acpi/pci_link.c	2005-12-18 22:28:03.335998167 -0800
@@ -316,7 +316,7 @@
 	if (!link || !irq)
 		return_VALUE(-EINVAL);
 
-	resource = kmalloc(sizeof(*resource) + 1, GFP_KERNEL);
+	resource = kmalloc(sizeof(*resource) + 1, GFP_ATOMIC);
 	if (!resource)
 		return_VALUE(-ENOMEM);
 
diff -urN linux-2.6.15-rc5/drivers/atm/adummy.c linux-2.6.15-rc6/drivers/atm/adummy.c
--- linux-2.6.15-rc5/drivers/atm/adummy.c	2005-12-18 22:27:54.518605307 -0800
+++ linux-2.6.15-rc6/drivers/atm/adummy.c	2005-12-18 22:28:03.341998435 -0800
@@ -123,7 +123,7 @@
 	}
 	memset(adummy_dev, 0, sizeof(struct adummy_dev));
 
-	atm_dev = atm_dev_register(DEV_LABEL, &adummy_ops, -1, 0);
+	atm_dev = atm_dev_register(DEV_LABEL, &adummy_ops, -1, NULL);
 	if (!atm_dev) {
 		printk(KERN_ERR DEV_LABEL ": atm_dev_register() failed\n");
 		err = -ENODEV;
diff -urN linux-2.6.15-rc5/drivers/base/memory.c linux-2.6.15-rc6/drivers/base/memory.c
--- linux-2.6.15-rc5/drivers/base/memory.c	2005-12-18 22:27:54.529605797 -0800
+++ linux-2.6.15-rc6/drivers/base/memory.c	2005-12-18 22:28:03.352998925 -0800
@@ -28,7 +28,6 @@
 static struct sysdev_class memory_sysdev_class = {
 	set_kset_name(MEMORY_CLASS_NAME),
 };
-EXPORT_SYMBOL(memory_sysdev_class);
 
 static char *memory_hotplug_name(struct kset *kset, struct kobject *kobj)
 {
diff -urN linux-2.6.15-rc5/drivers/block/cciss.c linux-2.6.15-rc6/drivers/block/cciss.c
--- linux-2.6.15-rc5/drivers/block/cciss.c	2005-12-18 22:27:54.548606643 -0800
+++ linux-2.6.15-rc6/drivers/block/cciss.c	2005-12-18 22:28:03.371999771 -0800
@@ -1146,7 +1146,6 @@
 				del_gendisk(disk);
 			if (q)
 				blk_cleanup_queue(q);
-			put_disk(disk);
 		}
 	}
 
@@ -1465,9 +1464,10 @@
 			request_queue_t *q = disk->queue;
 			if (disk->flags & GENHD_FL_UP)
 				del_gendisk(disk);
-			if (q)	
+			if (q) {
 				blk_cleanup_queue(q);
-			put_disk(disk);	
+				drv->queue = NULL;
+			}
 		}
 	}
 
@@ -3243,7 +3243,6 @@
 				del_gendisk(disk);
 			if (q)
 				blk_cleanup_queue(q);
-			put_disk(disk);
 		}
 	}
 
diff -urN linux-2.6.15-rc5/drivers/char/Kconfig linux-2.6.15-rc6/drivers/char/Kconfig
--- linux-2.6.15-rc5/drivers/char/Kconfig	2005-12-18 22:27:54.596608782 -0800
+++ linux-2.6.15-rc6/drivers/char/Kconfig	2005-12-18 22:28:03.423002044 -0800
@@ -943,6 +943,15 @@
           Applications should simply open the device (eg /dev/hda1)
           with the O_DIRECT flag.
 
+config MAX_RAW_DEVS
+	int "Maximum number of RAW devices to support (1-8192)"
+	depends on RAW_DRIVER
+	default "256"
+	help
+	  The maximum number of RAW devices that are supported.
+	  Default is 256. Increase this number in case you need lots of
+	  raw devices.
+
 config HPET
 	bool "HPET - High Precision Event Timer" if (X86 || IA64)
 	default n
@@ -974,15 +983,6 @@
 	  exposed to the user.  If this applies to your hardware,
 	  say N here.
 
-config MAX_RAW_DEVS
-	int "Maximum number of RAW devices to support (1-8192)"
-	depends on RAW_DRIVER
-	default "256"
-	help
-	  The maximum number of RAW devices that are supported.
-	  Default is 256. Increase this number in case you need lots of
-	  raw devices.
-
 config HANGCHECK_TIMER
 	tristate "Hangcheck timer"
 	depends on X86 || IA64 || PPC64 || ARCH_S390
diff -urN linux-2.6.15-rc5/drivers/char/drm/radeon_cp.c linux-2.6.15-rc6/drivers/char/drm/radeon_cp.c
--- linux-2.6.15-rc5/drivers/char/drm/radeon_cp.c	2005-12-18 22:27:54.709613817 -0800
+++ linux-2.6.15-rc6/drivers/char/drm/radeon_cp.c	2005-12-18 22:28:03.539007212 -0800
@@ -1311,7 +1311,9 @@
 
 static int radeon_do_init_cp(drm_device_t * dev, drm_radeon_init_t * init)
 {
-	drm_radeon_private_t *dev_priv = dev->dev_private;;
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	unsigned int mem_size;
+
 	DRM_DEBUG("\n");
 
 	dev_priv->is_pci = init->is_pci;
@@ -1521,8 +1523,11 @@
 					  + dev_priv->fb_location) >> 10));
 
 	dev_priv->gart_size = init->gart_size;
-	dev_priv->gart_vm_start = dev_priv->fb_location
-	    + RADEON_READ(RADEON_CONFIG_APER_SIZE);
+
+	mem_size = RADEON_READ(RADEON_CONFIG_MEMSIZE);
+	if (mem_size == 0)
+		mem_size = 0x800000;
+	dev_priv->gart_vm_start = dev_priv->fb_location + mem_size;
 
 #if __OS_HAS_AGP
 	if (!dev_priv->is_pci)
diff -urN linux-2.6.15-rc5/drivers/char/drm/radeon_drv.h linux-2.6.15-rc6/drivers/char/drm/radeon_drv.h
--- linux-2.6.15-rc5/drivers/char/drm/radeon_drv.h	2005-12-18 22:27:54.713613995 -0800
+++ linux-2.6.15-rc6/drivers/char/drm/radeon_drv.h	2005-12-18 22:28:03.543007391 -0800
@@ -379,6 +379,7 @@
 #	define RADEON_PLL_WR_EN			(1 << 7)
 #define RADEON_CLOCK_CNTL_INDEX		0x0008
 #define RADEON_CONFIG_APER_SIZE		0x0108
+#define RADEON_CONFIG_MEMSIZE		0x00f8
 #define RADEON_CRTC_OFFSET		0x0224
 #define RADEON_CRTC_OFFSET_CNTL		0x0228
 #	define RADEON_CRTC_TILE_EN		(1 << 15)
diff -urN linux-2.6.15-rc5/drivers/char/ipmi/ipmi_msghandler.c linux-2.6.15-rc6/drivers/char/ipmi/ipmi_msghandler.c
--- linux-2.6.15-rc5/drivers/char/ipmi/ipmi_msghandler.c	2005-12-18 22:27:54.750615644 -0800
+++ linux-2.6.15-rc6/drivers/char/ipmi/ipmi_msghandler.c	2005-12-18 22:28:03.581009084 -0800
@@ -2986,7 +2986,7 @@
 	msg.cmd = 2; /* Platform event command. */
 	msg.data = data;
 	msg.data_len = 8;
-	data[0] = 0x21; /* Kernel generator ID, IPMI table 5-4 */
+	data[0] = 0x41; /* Kernel generator ID, IPMI table 5-4 */
 	data[1] = 0x03; /* This is for IPMI 1.0. */
 	data[2] = 0x20; /* OS Critical Stop, IPMI table 36-3 */
 	data[4] = 0x6f; /* Sensor specific, IPMI table 36-1 */
diff -urN linux-2.6.15-rc5/drivers/char/ipmi/ipmi_si_intf.c linux-2.6.15-rc6/drivers/char/ipmi/ipmi_si_intf.c
--- linux-2.6.15-rc5/drivers/char/ipmi/ipmi_si_intf.c	2005-12-18 22:27:54.752615733 -0800
+++ linux-2.6.15-rc6/drivers/char/ipmi/ipmi_si_intf.c	2005-12-18 22:28:03.584009218 -0800
@@ -2399,7 +2399,8 @@
 			new_smi->handlers->cleanup(new_smi->si_sm);
 		kfree(new_smi->si_sm);
 	}
-	new_smi->io_cleanup(new_smi);
+	if (new_smi->io_cleanup)
+		new_smi->io_cleanup(new_smi);
 
 	return rv;
 }
@@ -2518,7 +2519,8 @@
 
 	kfree(to_clean->si_sm);
 
-	to_clean->io_cleanup(to_clean);
+	if (to_clean->io_cleanup)
+		to_clean->io_cleanup(to_clean);
 }
 
 static __exit void cleanup_ipmi_si(void)
diff -urN linux-2.6.15-rc5/drivers/char/mwave/mwavepub.h linux-2.6.15-rc6/drivers/char/mwave/mwavepub.h
--- linux-2.6.15-rc5/drivers/char/mwave/mwavepub.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/char/mwave/mwavepub.h	2005-12-18 22:28:03.592009574 -0800
@@ -69,7 +69,7 @@
 typedef struct _MW_READWRITE {
 	unsigned short usDspAddress;	/* The dsp address */
 	unsigned long ulDataLength;	/* The size in bytes of the data or user buffer */
-	void *pBuf;		/* Input:variable sized buffer */
+	void __user *pBuf;		/* Input:variable sized buffer */
 } MW_READWRITE, *pMW_READWRITE;
 
 #define IOCTL_MW_RESET           _IO(MWAVE_MINOR,1)
diff -urN linux-2.6.15-rc5/drivers/char/pcmcia/cm4000_cs.c linux-2.6.15-rc6/drivers/char/pcmcia/cm4000_cs.c
--- linux-2.6.15-rc5/drivers/char/pcmcia/cm4000_cs.c	2005-12-18 22:27:54.767616401 -0800
+++ linux-2.6.15-rc6/drivers/char/pcmcia/cm4000_cs.c	2005-12-18 22:28:03.599009886 -0800
@@ -1444,6 +1444,7 @@
 	dev_link_t *link;
 	int size;
 	int rc;
+	void __user *argp = (void __user *)arg;
 #ifdef PCMCIA_DEBUG
 	char *ioctl_names[CM_IOC_MAXNR + 1] = {
 		[_IOC_NR(CM_IOCGSTATUS)] "CM_IOCGSTATUS",
@@ -1481,11 +1482,11 @@
 	      _IOC_DIR(cmd), _IOC_READ, _IOC_WRITE, size, cmd);
 
 	if (_IOC_DIR(cmd) & _IOC_READ) {
-		if (!access_ok(VERIFY_WRITE, (void *)arg, size))
+		if (!access_ok(VERIFY_WRITE, argp, size))
 			return -EFAULT;
 	}
 	if (_IOC_DIR(cmd) & _IOC_WRITE) {
-		if (!access_ok(VERIFY_READ, (void *)arg, size))
+		if (!access_ok(VERIFY_READ, argp, size))
 			return -EFAULT;
 	}
 
@@ -1506,14 +1507,14 @@
 				status |= CM_NO_READER;
 			if (test_bit(IS_BAD_CARD, &dev->flags))
 				status |= CM_BAD_CARD;
-			if (copy_to_user((int *)arg, &status, sizeof(int)))
+			if (copy_to_user(argp, &status, sizeof(int)))
 				return -EFAULT;
 		}
 		return 0;
 	case CM_IOCGATR:
 		DEBUGP(4, dev, "... in CM_IOCGATR\n");
 		{
-			struct atreq *atreq = (struct atreq *) arg;
+			struct atreq __user *atreq = argp;
 			int tmp;
 			/* allow nonblocking io and being interrupted */
 			if (wait_event_interruptible
@@ -1597,7 +1598,7 @@
 		{
 			struct ptsreq krnptsreq;
 
-			if (copy_from_user(&krnptsreq, (struct ptsreq *) arg,
+			if (copy_from_user(&krnptsreq, argp,
 					   sizeof(struct ptsreq)))
 				return -EFAULT;
 
@@ -1641,7 +1642,7 @@
 			int old_pc_debug = 0;
 
 			old_pc_debug = pc_debug;
-			if (copy_from_user(&pc_debug, (int *)arg, sizeof(int)))
+			if (copy_from_user(&pc_debug, argp, sizeof(int)))
 				return -EFAULT;
 
 			if (old_pc_debug != pc_debug)
diff -urN linux-2.6.15-rc5/drivers/char/watchdog/booke_wdt.c linux-2.6.15-rc6/drivers/char/watchdog/booke_wdt.c
--- linux-2.6.15-rc5/drivers/char/watchdog/booke_wdt.c	2005-12-18 22:27:54.802617961 -0800
+++ linux-2.6.15-rc6/drivers/char/watchdog/booke_wdt.c	2005-12-18 22:28:03.635011490 -0800
@@ -72,7 +72,7 @@
 /*
  * booke_wdt_write:
  */
-static ssize_t booke_wdt_write (struct file *file, const char *buf,
+static ssize_t booke_wdt_write (struct file *file, const char __user *buf,
 				size_t count, loff_t *ppos)
 {
 	booke_wdt_ping();
@@ -92,14 +92,15 @@
 			    unsigned int cmd, unsigned long arg)
 {
 	u32 tmp = 0;
+	u32 __user *p = (u32 __user *)arg;
 
 	switch (cmd) {
 	case WDIOC_GETSUPPORT:
-		if (copy_to_user ((struct watchdog_info *) arg, &ident,
+		if (copy_to_user ((struct watchdog_info __user *) arg, &ident,
 				sizeof(struct watchdog_info)))
 			return -EFAULT;
 	case WDIOC_GETSTATUS:
-		return put_user(ident.options, (u32 *) arg);
+		return put_user(ident.options, p);
 	case WDIOC_GETBOOTSTATUS:
 		/* XXX: something is clearing TSR */
 		tmp = mfspr(SPRN_TSR) & TSR_WRS(3);
@@ -109,14 +110,14 @@
 		booke_wdt_ping();
 		return 0;
 	case WDIOC_SETTIMEOUT:
-		if (get_user(booke_wdt_period, (u32 *) arg))
+		if (get_user(booke_wdt_period, p))
 			return -EFAULT;
 		mtspr(SPRN_TCR, (mfspr(SPRN_TCR)&~WDTP(0))|WDTP(booke_wdt_period));
 		return 0;
 	case WDIOC_GETTIMEOUT:
-		return put_user(booke_wdt_period, (u32 *) arg);
+		return put_user(booke_wdt_period, p);
 	case WDIOC_SETOPTIONS:
-		if (get_user(tmp, (u32 *) arg))
+		if (get_user(tmp, p))
 			return -EINVAL;
 		if (tmp == WDIOS_ENABLECARD) {
 			booke_wdt_ping();
@@ -172,7 +173,7 @@
 	int ret = 0;
 
 	printk (KERN_INFO "PowerPC Book-E Watchdog Timer Loaded\n");
-	ident.firmware_version = cpu_specs[0].pvr_value;
+	ident.firmware_version = cur_cpu_spec->pvr_value;
 
 	ret = misc_register(&booke_wdt_miscdev);
 	if (ret) {
diff -urN linux-2.6.15-rc5/drivers/char/watchdog/mpcore_wdt.c linux-2.6.15-rc6/drivers/char/watchdog/mpcore_wdt.c
--- linux-2.6.15-rc5/drivers/char/watchdog/mpcore_wdt.c	2005-12-18 22:27:54.803618005 -0800
+++ linux-2.6.15-rc6/drivers/char/watchdog/mpcore_wdt.c	2005-12-18 22:28:03.636011535 -0800
@@ -180,10 +180,6 @@
 {
 	struct mpcore_wdt *wdt = file->private_data;
 
-	/*  Can't seek (pwrite) on this device  */
-	if (ppos != &file->f_pos)
-		return -ESPIPE;
-
 	/*
 	 *	Refresh the timer.
 	 */
diff -urN linux-2.6.15-rc5/drivers/char/watchdog/wdrtas.c linux-2.6.15-rc6/drivers/char/watchdog/wdrtas.c
--- linux-2.6.15-rc5/drivers/char/watchdog/wdrtas.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/char/watchdog/wdrtas.c	2005-12-18 22:28:03.639011668 -0800
@@ -320,7 +320,7 @@
 wdrtas_ioctl(struct inode *inode, struct file *file,
 	     unsigned int cmd, unsigned long arg)
 {
-	int __user *argp = (void *)arg;
+	int __user *argp = (void __user *)arg;
 	int i;
 	static struct watchdog_info wdinfo = {
 		.options = WDRTAS_SUPPORTED_MASK,
diff -urN linux-2.6.15-rc5/drivers/connector/cn_proc.c linux-2.6.15-rc6/drivers/connector/cn_proc.c
--- linux-2.6.15-rc5/drivers/connector/cn_proc.c	2005-12-18 22:27:54.807618184 -0800
+++ linux-2.6.15-rc6/drivers/connector/cn_proc.c	2005-12-18 22:28:03.640011713 -0800
@@ -56,6 +56,7 @@
 	msg = (struct cn_msg*)buffer;
 	ev = (struct proc_event*)msg->data;
 	get_seq(&msg->seq, &ev->cpu);
+	getnstimestamp(&ev->timestamp);
 	ev->what = PROC_EVENT_FORK;
 	ev->event_data.fork.parent_pid = task->real_parent->pid;
 	ev->event_data.fork.parent_tgid = task->real_parent->tgid;
@@ -81,6 +82,7 @@
 	msg = (struct cn_msg*)buffer;
 	ev = (struct proc_event*)msg->data;
 	get_seq(&msg->seq, &ev->cpu);
+	getnstimestamp(&ev->timestamp);
 	ev->what = PROC_EVENT_EXEC;
 	ev->event_data.exec.process_pid = task->pid;
 	ev->event_data.exec.process_tgid = task->tgid;
@@ -114,6 +116,7 @@
 	} else
 	     	return;
 	get_seq(&msg->seq, &ev->cpu);
+	getnstimestamp(&ev->timestamp);
 
 	memcpy(&msg->id, &cn_proc_event_id, sizeof(msg->id));
 	msg->ack = 0; /* not used */
@@ -133,6 +136,7 @@
 	msg = (struct cn_msg*)buffer;
 	ev = (struct proc_event*)msg->data;
 	get_seq(&msg->seq, &ev->cpu);
+	getnstimestamp(&ev->timestamp);
 	ev->what = PROC_EVENT_EXIT;
 	ev->event_data.exit.process_pid = task->pid;
 	ev->event_data.exit.process_tgid = task->tgid;
@@ -165,6 +169,7 @@
 	msg = (struct cn_msg*)buffer;
 	ev = (struct proc_event*)msg->data;
 	msg->seq = rcvd_seq;
+	getnstimestamp(&ev->timestamp);
 	ev->cpu = -1;
 	ev->what = PROC_EVENT_NONE;
 	ev->event_data.ack.err = err;
diff -urN linux-2.6.15-rc5/drivers/firmware/dell_rbu.c linux-2.6.15-rc6/drivers/firmware/dell_rbu.c
--- linux-2.6.15-rc5/drivers/firmware/dell_rbu.c	2005-12-18 22:27:54.813618451 -0800
+++ linux-2.6.15-rc6/drivers/firmware/dell_rbu.c	2005-12-18 22:28:03.646011980 -0800
@@ -105,8 +105,8 @@
 	int ordernum = 0;
 	int retval = 0;
 	unsigned int packet_array_size = 0;
-	void **invalid_addr_packet_array = 0;
-	void *packet_data_temp_buf = 0;
+	void **invalid_addr_packet_array = NULL;
+	void *packet_data_temp_buf = NULL;
 	unsigned int idx = 0;
 
 	pr_debug("create_packet: entry \n");
@@ -178,7 +178,7 @@
 						packet_data_temp_buf),
 					allocation_floor);
 			invalid_addr_packet_array[idx++] = packet_data_temp_buf;
-			packet_data_temp_buf = 0;
+			packet_data_temp_buf = NULL;
 		}
 	}
 	spin_lock(&rbu_data.lock);
diff -urN linux-2.6.15-rc5/drivers/i2c/busses/i2c-mv64xxx.c linux-2.6.15-rc6/drivers/i2c/busses/i2c-mv64xxx.c
--- linux-2.6.15-rc5/drivers/i2c/busses/i2c-mv64xxx.c	2005-12-18 22:27:54.844619832 -0800
+++ linux-2.6.15-rc6/drivers/i2c/busses/i2c-mv64xxx.c	2005-12-18 22:28:03.679013450 -0800
@@ -529,14 +529,15 @@
 	i2c_set_adapdata(&drv_data->adapter, drv_data);
 
 	if (request_irq(drv_data->irq, mv64xxx_i2c_intr, 0,
-		MV64XXX_I2C_CTLR_NAME, drv_data)) {
-
-		dev_err(dev, "mv64xxx: Can't register intr handler "
-			"irq: %d\n", drv_data->irq);
+			MV64XXX_I2C_CTLR_NAME, drv_data)) {
+		dev_err(&drv_data->adapter.dev,
+			"mv64xxx: Can't register intr handler irq: %d\n",
+			drv_data->irq);
 		rc = -EINVAL;
 		goto exit_unmap_regs;
 	} else if ((rc = i2c_add_adapter(&drv_data->adapter)) != 0) {
-		dev_err(dev, "mv64xxx: Can't add i2c adapter, rc: %d\n", -rc);
+		dev_err(&drv_data->adapter.dev,
+			"mv64xxx: Can't add i2c adapter, rc: %d\n", -rc);
 		goto exit_free_irq;
 	}
 
diff -urN linux-2.6.15-rc5/drivers/ide/Kconfig linux-2.6.15-rc6/drivers/ide/Kconfig
--- linux-2.6.15-rc5/drivers/ide/Kconfig	2005-12-18 22:27:54.858620456 -0800
+++ linux-2.6.15-rc6/drivers/ide/Kconfig	2005-12-18 22:28:03.694014119 -0800
@@ -807,14 +807,6 @@
        depends on SOC_AU1200 && BLK_DEV_IDE_AU1XXX
 endchoice
 
-config BLK_DEV_IDE_AU1XXX_BURSTABLE_ON
-        bool "Enable burstable Mode on DbDMA"
-        default false
-        depends BLK_DEV_IDE_AU1XXX
-        help
-          This option enable the burstable Flag on DbDMA controller
-          (cf. "AMD Alchemy 'Au1200' Processor Data Book - PRELIMINARY").
-
 config BLK_DEV_IDE_AU1XXX_SEQTS_PER_RQ
        int "Maximum transfer size (KB) per request (up to 128)"
        default "128"
@@ -940,7 +932,7 @@
 
 config BLK_DEV_MPC8xx_IDE
 	bool "MPC8xx IDE support"
-	depends on 8xx
+	depends on 8xx && IDE=y && BLK_DEV_IDE=y
 	help
 	  This option provides support for IDE on Motorola MPC8xx Systems.
 	  Please see 'Type of MPC8xx IDE interface' for details.
diff -urN linux-2.6.15-rc5/drivers/ide/ide-cd.c linux-2.6.15-rc6/drivers/ide/ide-cd.c
--- linux-2.6.15-rc5/drivers/ide/ide-cd.c	2005-12-18 22:27:54.860620545 -0800
+++ linux-2.6.15-rc6/drivers/ide/ide-cd.c	2005-12-18 22:28:03.697014253 -0800
@@ -1292,7 +1292,6 @@
 	struct cdrom_info *info = drive->driver_data;
 
 	info->dma = 0;
-	info->cmd = 0;
 	info->start_seek = jiffies;
 	return cdrom_start_packet_command(drive, 0, cdrom_start_seek_continuation);
 }
@@ -1344,8 +1343,6 @@
 	    (rq->nr_sectors & (sectors_per_frame - 1)))
 		info->dma = 0;
 
-	info->cmd = READ;
-
 	/* Start sending the read request to the drive. */
 	return cdrom_start_packet_command(drive, 32768, cdrom_start_read_continuation);
 }
@@ -1484,7 +1481,6 @@
 	struct cdrom_info *info = drive->driver_data;
 
 	info->dma = 0;
-	info->cmd = 0;
 	rq->flags &= ~REQ_FAILED;
 	len = rq->data_len;
 
@@ -1891,7 +1887,6 @@
 	/* use dma, if possible. we don't need to check more, since we
 	 * know that the transfer is always (at least!) frame aligned */
 	info->dma = drive->using_dma ? 1 : 0;
-	info->cmd = WRITE;
 
 	info->devinfo.media_written = 1;
 
@@ -1916,7 +1911,6 @@
 	rq->flags |= REQ_QUIET;
 
 	info->dma = 0;
-	info->cmd = 0;
 
 	/*
 	 * sg request
@@ -1925,7 +1919,6 @@
 		int mask = drive->queue->dma_alignment;
 		unsigned long addr = (unsigned long) page_address(bio_page(rq->bio));
 
-		info->cmd = rq_data_dir(rq);
 		info->dma = drive->using_dma;
 
 		/*
diff -urN linux-2.6.15-rc5/drivers/ide/ide-cd.h linux-2.6.15-rc6/drivers/ide/ide-cd.h
--- linux-2.6.15-rc5/drivers/ide/ide-cd.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/ide/ide-cd.h	2005-12-18 22:28:03.698014297 -0800
@@ -480,7 +480,6 @@
 
 	struct request request_sense_request;
 	int dma;
-	int cmd;
 	unsigned long last_block;
 	unsigned long start_seek;
 	/* Buffer to hold mechanism status and changer slot table. */
diff -urN linux-2.6.15-rc5/drivers/ide/ide-disk.c linux-2.6.15-rc6/drivers/ide/ide-disk.c
--- linux-2.6.15-rc5/drivers/ide/ide-disk.c	2005-12-18 22:27:54.861620590 -0800
+++ linux-2.6.15-rc6/drivers/ide/ide-disk.c	2005-12-18 22:28:03.698014297 -0800
@@ -1034,12 +1034,12 @@
 	struct ide_disk_obj *idkp = drive->driver_data;
 	struct gendisk *g = idkp->disk;
 
-	ide_cacheflush_p(drive);
-
 	ide_unregister_subdriver(drive, idkp->driver);
 
 	del_gendisk(g);
 
+	ide_cacheflush_p(drive);
+
 	ide_disk_put(idkp);
 
 	return 0;
diff -urN linux-2.6.15-rc5/drivers/ide/ide-dma.c linux-2.6.15-rc6/drivers/ide/ide-dma.c
--- linux-2.6.15-rc5/drivers/ide/ide-dma.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/ide/ide-dma.c	2005-12-18 22:28:03.699014342 -0800
@@ -90,11 +90,6 @@
 #include <asm/io.h>
 #include <asm/irq.h>
 
-struct drive_list_entry {
-	const char *id_model;
-	const char *id_firmware;
-};
-
 static const struct drive_list_entry drive_whitelist [] = {
 
 	{ "Micropolis 2112A"	,       "ALL"		},
@@ -139,7 +134,7 @@
 };
 
 /**
- *	in_drive_list	-	look for drive in black/white list
+ *	ide_in_drive_list	-	look for drive in black/white list
  *	@id: drive identifier
  *	@drive_table: list to inspect
  *
@@ -147,7 +142,7 @@
  *	Returns 1 if the drive is found in the table.
  */
 
-static int in_drive_list(struct hd_driveid *id, const struct drive_list_entry *drive_table)
+int ide_in_drive_list(struct hd_driveid *id, const struct drive_list_entry *drive_table)
 {
 	for ( ; drive_table->id_model ; drive_table++)
 		if ((!strcmp(drive_table->id_model, id->model)) &&
@@ -157,6 +152,8 @@
 	return 0;
 }
 
+EXPORT_SYMBOL_GPL(ide_in_drive_list);
+
 /**
  *	ide_dma_intr	-	IDE DMA interrupt handler
  *	@drive: the drive the interrupt is for
@@ -663,7 +660,7 @@
 {
 	struct hd_driveid *id = drive->id;
 
-	int blacklist = in_drive_list(id, drive_blacklist);
+	int blacklist = ide_in_drive_list(id, drive_blacklist);
 	if (blacklist) {
 		printk(KERN_WARNING "%s: Disabling (U)DMA for %s (blacklisted)\n",
 				    drive->name, id->model);
@@ -677,7 +674,7 @@
 int __ide_dma_good_drive (ide_drive_t *drive)
 {
 	struct hd_driveid *id = drive->id;
-	return in_drive_list(id, drive_whitelist);
+	return ide_in_drive_list(id, drive_whitelist);
 }
 
 EXPORT_SYMBOL(__ide_dma_good_drive);
diff -urN linux-2.6.15-rc5/drivers/ide/mips/Makefile linux-2.6.15-rc6/drivers/ide/mips/Makefile
--- linux-2.6.15-rc5/drivers/ide/mips/Makefile	2005-12-18 22:27:54.871621035 -0800
+++ linux-2.6.15-rc6/drivers/ide/mips/Makefile	2005-12-18 22:28:03.710014832 -0800
@@ -1 +1,4 @@
 obj-$(CONFIG_BLK_DEV_IDE_SWARM)		+= swarm.o
+obj-$(CONFIG_BLK_DEV_IDE_AU1XXX)	+= au1xxx-ide.o
+
+EXTRA_CFLAGS    := -Idrivers/ide
diff -urN linux-2.6.15-rc5/drivers/ide/mips/au1xxx-ide.c linux-2.6.15-rc6/drivers/ide/mips/au1xxx-ide.c
--- linux-2.6.15-rc5/drivers/ide/mips/au1xxx-ide.c	2005-12-18 22:27:54.873621124 -0800
+++ linux-2.6.15-rc6/drivers/ide/mips/au1xxx-ide.c	2005-12-18 22:28:03.711014876 -0800
@@ -31,865 +31,638 @@
  */
 #undef REALLY_SLOW_IO           /* most systems can safely undef this */
 
-#include <linux/config.h>       /* for CONFIG_BLK_DEV_IDEPCI */
 #include <linux/types.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/delay.h>
-#include <linux/timer.h>
-#include <linux/mm.h>
-#include <linux/ioport.h>
-#include <linux/hdreg.h>
+#include <linux/platform_device.h>
+
 #include <linux/init.h>
 #include <linux/ide.h>
 #include <linux/sysdev.h>
 
 #include <linux/dma-mapping.h>
 
+#include "ide-timing.h"
+
 #include <asm/io.h>
 #include <asm/mach-au1x00/au1xxx.h>
 #include <asm/mach-au1x00/au1xxx_dbdma.h>
 
-#if CONFIG_PM
-#include <asm/mach-au1x00/au1xxx_pm.h>
-#endif
-
 #include <asm/mach-au1x00/au1xxx_ide.h>
 
 #define DRV_NAME	"au1200-ide"
 #define DRV_VERSION	"1.0"
-#define DRV_AUTHOR	"AMD PCS / Pete Popov <ppopov@embeddedalley.com>"
-#define DRV_DESC	"Au1200 IDE"
-
-static _auide_hwif auide_hwif;
-static spinlock_t ide_tune_drive_spin_lock = SPIN_LOCK_UNLOCKED;
-static spinlock_t ide_tune_chipset_spin_lock = SPIN_LOCK_UNLOCKED;
-static int dbdma_init_done = 0;
+#define DRV_AUTHOR	"Enrico Walther <enrico.walther@amd.com> / Pete Popov <ppopov@embeddedalley.com>"
 
-/*
- * local I/O functions
- */
-u8 auide_inb(unsigned long port)
-{
-        return (au_readb(port));
-}
+/* enable the burstmode in the dbdma */
+#define IDE_AU1XXX_BURSTMODE	1
 
-u16 auide_inw(unsigned long port)
-{
-        return (au_readw(port));
-}
-
-u32 auide_inl(unsigned long port)
-{
-        return (au_readl(port));
-}
+static _auide_hwif auide_hwif;
+static int dbdma_init_done;
 
-void auide_insw(unsigned long port, void *addr, u32 count)
-{
 #if defined(CONFIG_BLK_DEV_IDE_AU1XXX_PIO_DBDMA)
 
-        _auide_hwif *ahwif = &auide_hwif;
-        chan_tab_t *ctp;
-        au1x_ddma_desc_t *dp;
-
-        if(!put_dest_flags(ahwif->rx_chan, (void*)addr, count << 1,
-				DDMA_FLAGS_NOIE)) {
-                printk(KERN_ERR "%s failed %d\n", __FUNCTION__, __LINE__);
-                return;
-        }
-        ctp = *((chan_tab_t **)ahwif->rx_chan);
-        dp = ctp->cur_ptr;
-        while (dp->dscr_cmd0 & DSCR_CMD0_V)
-                ;
-        ctp->cur_ptr = au1xxx_ddma_get_nextptr_virt(dp);
-#else
-        while (count--)
-        {
-                *(u16 *)addr = au_readw(port);
-                addr +=2 ;
-        }
-#endif
-}
-
-void auide_insl(unsigned long port, void *addr, u32 count)
-{
-        while (count--)
-        {
-                *(u32 *)addr = au_readl(port);
-                /* NOTE: For IDE interfaces over PCMCIA,
-                 * 32-bit access does not work
-                 */
-                addr += 4;
-        }
-}
-
-void auide_outb(u8 addr, unsigned long port)
-{
-        return (au_writeb(addr, port));
-}
-
-void auide_outbsync(ide_drive_t *drive, u8 addr, unsigned long port)
-{
-        return (au_writeb(addr, port));
-}
-
-void auide_outw(u16 addr, unsigned long port)
-{
-        return (au_writew(addr, port));
-}
-
-void auide_outl(u32 addr, unsigned long port)
+void auide_insw(unsigned long port, void *addr, u32 count)
 {
-        return (au_writel(addr, port));
+	_auide_hwif *ahwif = &auide_hwif;
+	chan_tab_t *ctp;
+	au1x_ddma_desc_t *dp;
+
+	if(!put_dest_flags(ahwif->rx_chan, (void*)addr, count << 1, 
+			   DDMA_FLAGS_NOIE)) {
+		printk(KERN_ERR "%s failed %d\n", __FUNCTION__, __LINE__);
+		return;
+	}
+	ctp = *((chan_tab_t **)ahwif->rx_chan);
+	dp = ctp->cur_ptr;
+	while (dp->dscr_cmd0 & DSCR_CMD0_V)
+		;
+	ctp->cur_ptr = au1xxx_ddma_get_nextptr_virt(dp);
 }
 
 void auide_outsw(unsigned long port, void *addr, u32 count)
 {
-#if defined(CONFIG_BLK_DEV_IDE_AU1XXX_PIO_DBDMA)
-        _auide_hwif *ahwif = &auide_hwif;
-        chan_tab_t *ctp;
-        au1x_ddma_desc_t *dp;
-
-        if(!put_source_flags(ahwif->tx_chan, (void*)addr,
-                                          count << 1, DDMA_FLAGS_NOIE)) {
-                printk(KERN_ERR "%s failed %d\n", __FUNCTION__, __LINE__);
-                return;
-        }
-        ctp = *((chan_tab_t **)ahwif->tx_chan);
-        dp = ctp->cur_ptr;
-        while (dp->dscr_cmd0 & DSCR_CMD0_V)
-                ;
-        ctp->cur_ptr = au1xxx_ddma_get_nextptr_virt(dp);
-#else
-        while (count--)
-        {
-                au_writew(*(u16 *)addr, port);
-                addr += 2;
-        }
-#endif
+	_auide_hwif *ahwif = &auide_hwif;
+	chan_tab_t *ctp;
+	au1x_ddma_desc_t *dp;
+
+	if(!put_source_flags(ahwif->tx_chan, (void*)addr,
+			     count << 1, DDMA_FLAGS_NOIE)) {
+		printk(KERN_ERR "%s failed %d\n", __FUNCTION__, __LINE__);
+		return;
+	}
+	ctp = *((chan_tab_t **)ahwif->tx_chan);
+	dp = ctp->cur_ptr;
+	while (dp->dscr_cmd0 & DSCR_CMD0_V)
+		;
+	ctp->cur_ptr = au1xxx_ddma_get_nextptr_virt(dp);
 }
 
-void auide_outsl(unsigned long port, void *addr, u32 count)
-{
-        while (count--)
-        {
-                au_writel(*(u32 *)addr, port);
-                /* NOTE: For IDE interfaces over PCMCIA,
-                 * 32-bit access does not work
-                 */
-                addr += 4;
-        }
-}
+#endif
 
 static void auide_tune_drive(ide_drive_t *drive, byte pio)
 {
-        int mem_sttime;
-        int mem_stcfg;
-        unsigned long flags;
-        u8 speed;
-
-        /* get the best pio mode for the drive */
-        pio = ide_get_best_pio_mode(drive, pio, 4, NULL);
-
-        printk("%s: setting Au1XXX IDE to PIO mode%d\n",
-                drive->name, pio);
-
-        spin_lock_irqsave(&ide_tune_drive_spin_lock, flags);
-
-        mem_sttime = 0;
-        mem_stcfg  = au_readl(MEM_STCFG2);
-
-        /* set pio mode! */
-        switch(pio) {
-                case 0:
-                        /* set timing parameters for RCS2# */
-                        mem_sttime =   SBC_IDE_PIO0_TWCS
-                                     | SBC_IDE_PIO0_TCSH
-                                     | SBC_IDE_PIO0_TCSOFF
-                                     | SBC_IDE_PIO0_TWP
-                                     | SBC_IDE_PIO0_TCSW
-                                     | SBC_IDE_PIO0_TPM
-                                     | SBC_IDE_PIO0_TA;
-                        /* set configuration for RCS2# */
-                        mem_stcfg |= TS_MASK;
-                        mem_stcfg &= ~TCSOE_MASK;
-                        mem_stcfg &= ~TOECS_MASK;
-                        mem_stcfg |= SBC_IDE_PIO0_TCSOE | SBC_IDE_PIO0_TOECS;
-
-                        au_writel(mem_sttime,MEM_STTIME2);
-                        au_writel(mem_stcfg,MEM_STCFG2);
-                        break;
-
-                case 1:
-                        /* set timing parameters for RCS2# */
-                        mem_sttime =   SBC_IDE_PIO1_TWCS
-                                     | SBC_IDE_PIO1_TCSH
-                                     | SBC_IDE_PIO1_TCSOFF
-                                     | SBC_IDE_PIO1_TWP
-                                     | SBC_IDE_PIO1_TCSW
-                                     | SBC_IDE_PIO1_TPM
-                                     | SBC_IDE_PIO1_TA;
-                        /* set configuration for RCS2# */
-                        mem_stcfg |= TS_MASK;
-                        mem_stcfg &= ~TCSOE_MASK;
-                        mem_stcfg &= ~TOECS_MASK;
-                        mem_stcfg |= SBC_IDE_PIO1_TCSOE | SBC_IDE_PIO1_TOECS;
-                        break;
-
-                case 2:
-                        /* set timing parameters for RCS2# */
-                        mem_sttime =   SBC_IDE_PIO2_TWCS
-                                     | SBC_IDE_PIO2_TCSH
-                                     | SBC_IDE_PIO2_TCSOFF
-                                     | SBC_IDE_PIO2_TWP
-                                     | SBC_IDE_PIO2_TCSW
-                                     | SBC_IDE_PIO2_TPM
-                                     | SBC_IDE_PIO2_TA;
-                        /* set configuration for RCS2# */
-                        mem_stcfg &= ~TS_MASK;
-                        mem_stcfg &= ~TCSOE_MASK;
-                        mem_stcfg &= ~TOECS_MASK;
-                        mem_stcfg |= SBC_IDE_PIO2_TCSOE | SBC_IDE_PIO2_TOECS;
-                        break;
-
-                case 3:
-                        /* set timing parameters for RCS2# */
-                        mem_sttime =   SBC_IDE_PIO3_TWCS
-                                     | SBC_IDE_PIO3_TCSH
-                                     | SBC_IDE_PIO3_TCSOFF
-                                     | SBC_IDE_PIO3_TWP
-                                     | SBC_IDE_PIO3_TCSW
-                                     | SBC_IDE_PIO3_TPM
-                                     | SBC_IDE_PIO3_TA;
-                        /* set configuration for RCS2# */
-                        mem_stcfg |= TS_MASK;
-                        mem_stcfg &= ~TS_MASK;
-                        mem_stcfg &= ~TCSOE_MASK;
-                        mem_stcfg &= ~TOECS_MASK;
-                        mem_stcfg |= SBC_IDE_PIO3_TCSOE | SBC_IDE_PIO3_TOECS;
-
-                        break;
-
-                case 4:
-                        /* set timing parameters for RCS2# */
-                        mem_sttime =   SBC_IDE_PIO4_TWCS
-                                     | SBC_IDE_PIO4_TCSH
-                                     | SBC_IDE_PIO4_TCSOFF
-                                     | SBC_IDE_PIO4_TWP
-                                     | SBC_IDE_PIO4_TCSW
-                                     | SBC_IDE_PIO4_TPM
-                                     | SBC_IDE_PIO4_TA;
-                        /* set configuration for RCS2# */
-                        mem_stcfg &= ~TS_MASK;
-                        mem_stcfg &= ~TCSOE_MASK;
-                        mem_stcfg &= ~TOECS_MASK;
-                        mem_stcfg |= SBC_IDE_PIO4_TCSOE | SBC_IDE_PIO4_TOECS;
-                        break;
-        }
-
-        au_writel(mem_sttime,MEM_STTIME2);
-        au_writel(mem_stcfg,MEM_STCFG2);
+	int mem_sttime;
+	int mem_stcfg;
+	u8 speed;
+
+	/* get the best pio mode for the drive */
+	pio = ide_get_best_pio_mode(drive, pio, 4, NULL);
+
+	printk(KERN_INFO "%s: setting Au1XXX IDE to PIO mode%d\n",
+	       drive->name, pio);
+
+	mem_sttime = 0;
+	mem_stcfg  = au_readl(MEM_STCFG2);
+
+	/* set pio mode! */
+	switch(pio) {
+	case 0:
+		mem_sttime = SBC_IDE_TIMING(PIO0);
+
+		/* set configuration for RCS2# */
+		mem_stcfg |= TS_MASK;
+		mem_stcfg &= ~TCSOE_MASK;
+		mem_stcfg &= ~TOECS_MASK;
+		mem_stcfg |= SBC_IDE_PIO0_TCSOE | SBC_IDE_PIO0_TOECS;
+		break;
+
+	case 1:
+		mem_sttime = SBC_IDE_TIMING(PIO1);
+
+		/* set configuration for RCS2# */
+		mem_stcfg |= TS_MASK;
+		mem_stcfg &= ~TCSOE_MASK;
+		mem_stcfg &= ~TOECS_MASK;
+		mem_stcfg |= SBC_IDE_PIO1_TCSOE | SBC_IDE_PIO1_TOECS;
+		break;
+
+	case 2:
+		mem_sttime = SBC_IDE_TIMING(PIO2);
+
+		/* set configuration for RCS2# */
+		mem_stcfg &= ~TS_MASK;
+		mem_stcfg &= ~TCSOE_MASK;
+		mem_stcfg &= ~TOECS_MASK;
+		mem_stcfg |= SBC_IDE_PIO2_TCSOE | SBC_IDE_PIO2_TOECS;
+		break;
+
+	case 3:
+		mem_sttime = SBC_IDE_TIMING(PIO3);
+
+		/* set configuration for RCS2# */
+		mem_stcfg &= ~TS_MASK;
+		mem_stcfg &= ~TCSOE_MASK;
+		mem_stcfg &= ~TOECS_MASK;
+		mem_stcfg |= SBC_IDE_PIO3_TCSOE | SBC_IDE_PIO3_TOECS;
+
+		break;
+
+	case 4:
+		mem_sttime = SBC_IDE_TIMING(PIO4);
+
+		/* set configuration for RCS2# */
+		mem_stcfg &= ~TS_MASK;
+		mem_stcfg &= ~TCSOE_MASK;
+		mem_stcfg &= ~TOECS_MASK;
+		mem_stcfg |= SBC_IDE_PIO4_TCSOE | SBC_IDE_PIO4_TOECS;
+		break;
+	}
 
-        spin_unlock_irqrestore(&ide_tune_drive_spin_lock, flags);
+	au_writel(mem_sttime,MEM_STTIME2);
+	au_writel(mem_stcfg,MEM_STCFG2);
 
-        speed = pio + XFER_PIO_0;
-        ide_config_drive_speed(drive, speed);
+	speed = pio + XFER_PIO_0;
+	ide_config_drive_speed(drive, speed);
 }
 
 static int auide_tune_chipset (ide_drive_t *drive, u8 speed)
 {
-        u8 mode = 0;
-        int mem_sttime;
-        int mem_stcfg;
-        unsigned long flags;
-#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
-        struct hd_driveid *id = drive->id;
+	int mem_sttime;
+	int mem_stcfg;
+	unsigned long mode;
 
-        /*
-         * Now see what the current drive is capable of,
-         * selecting UDMA only if the mate said it was ok.
-         */
-        if (id && (id->capability & 1) && drive->autodma &&
-            !__ide_dma_bad_drive(drive)) {
-                if (!mode && (id->field_valid & 2) && (id->dma_mword & 7)) {
-                        if      (id->dma_mword & 4)
-                                mode = XFER_MW_DMA_2;
-                        else if (id->dma_mword & 2)
-                                mode = XFER_MW_DMA_1;
-                        else if (id->dma_mword & 1)
-                                mode = XFER_MW_DMA_0;
-                }
-        }
+#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
+	if (ide_use_dma(drive))
+		mode = ide_dma_speed(drive, 0);
 #endif
 
-        spin_lock_irqsave(&ide_tune_chipset_spin_lock, flags);
+	mem_sttime = 0;
+	mem_stcfg  = au_readl(MEM_STCFG2);
 
-        mem_sttime = 0;
-        mem_stcfg  = au_readl(MEM_STCFG2);
-
-        switch(speed) {
-                case XFER_PIO_4:
-                case XFER_PIO_3:
-                case XFER_PIO_2:
-                case XFER_PIO_1:
-                case XFER_PIO_0:
-                        auide_tune_drive(drive, (speed - XFER_PIO_0));
-                        break;
+	if (speed >= XFER_PIO_0 && speed <= XFER_PIO_4) {
+		auide_tune_drive(drive, speed - XFER_PIO_0);
+		return 0;
+	}
+	      
+	switch(speed) {
 #ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
-                case XFER_MW_DMA_2:
-                        /* set timing parameters for RCS2# */
-                        mem_sttime =   SBC_IDE_MDMA2_TWCS
-                                     | SBC_IDE_MDMA2_TCSH
-                                     | SBC_IDE_MDMA2_TCSOFF
-                                     | SBC_IDE_MDMA2_TWP
-                                     | SBC_IDE_MDMA2_TCSW
-                                     | SBC_IDE_MDMA2_TPM
-                                     | SBC_IDE_MDMA2_TA;
-                        /* set configuration for RCS2# */
-                        mem_stcfg &= ~TS_MASK;
-                        mem_stcfg &= ~TCSOE_MASK;
-                        mem_stcfg &= ~TOECS_MASK;
-                        mem_stcfg |= SBC_IDE_MDMA2_TCSOE | SBC_IDE_MDMA2_TOECS;
-
-                        mode = XFER_MW_DMA_2;
-                        break;
-                case XFER_MW_DMA_1:
-                        /* set timing parameters for RCS2# */
-                        mem_sttime =   SBC_IDE_MDMA1_TWCS
-                                     | SBC_IDE_MDMA1_TCSH
-                                     | SBC_IDE_MDMA1_TCSOFF
-                                     | SBC_IDE_MDMA1_TWP
-                                     | SBC_IDE_MDMA1_TCSW
-                                     | SBC_IDE_MDMA1_TPM
-                                     | SBC_IDE_MDMA1_TA;
-                        /* set configuration for RCS2# */
-                        mem_stcfg &= ~TS_MASK;
-                        mem_stcfg &= ~TCSOE_MASK;
-                        mem_stcfg &= ~TOECS_MASK;
-                        mem_stcfg |= SBC_IDE_MDMA1_TCSOE | SBC_IDE_MDMA1_TOECS;
-
-                        mode = XFER_MW_DMA_1;
-                        break;
-                case XFER_MW_DMA_0:
-                        /* set timing parameters for RCS2# */
-                        mem_sttime =   SBC_IDE_MDMA0_TWCS
-                                     | SBC_IDE_MDMA0_TCSH
-                                     | SBC_IDE_MDMA0_TCSOFF
-                                     | SBC_IDE_MDMA0_TWP
-                                     | SBC_IDE_MDMA0_TCSW
-                                     | SBC_IDE_MDMA0_TPM
-                                     | SBC_IDE_MDMA0_TA;
-                        /* set configuration for RCS2# */
-                        mem_stcfg |= TS_MASK;
-                        mem_stcfg &= ~TCSOE_MASK;
-                        mem_stcfg &= ~TOECS_MASK;
-                        mem_stcfg |= SBC_IDE_MDMA0_TCSOE | SBC_IDE_MDMA0_TOECS;
-
-                        mode = XFER_MW_DMA_0;
-                        break;
-#endif
-                default:
-                        return 1;
-        }
-
-        /*
-         * Tell the drive to switch to the new mode; abort on failure.
-         */
-        if (!mode || ide_config_drive_speed(drive, mode))
-        {
-                return 1;       /* failure */
-        }
+	case XFER_MW_DMA_2:
+		mem_sttime = SBC_IDE_TIMING(MDMA2);
 
+		/* set configuration for RCS2# */
+		mem_stcfg &= ~TS_MASK;
+		mem_stcfg &= ~TCSOE_MASK;
+		mem_stcfg &= ~TOECS_MASK;
+		mem_stcfg |= SBC_IDE_MDMA2_TCSOE | SBC_IDE_MDMA2_TOECS;
+
+		mode = XFER_MW_DMA_2;
+		break;
+	case XFER_MW_DMA_1:
+		mem_sttime = SBC_IDE_TIMING(MDMA1);
+
+		/* set configuration for RCS2# */
+		mem_stcfg &= ~TS_MASK;
+		mem_stcfg &= ~TCSOE_MASK;
+		mem_stcfg &= ~TOECS_MASK;
+		mem_stcfg |= SBC_IDE_MDMA1_TCSOE | SBC_IDE_MDMA1_TOECS;
+
+		mode = XFER_MW_DMA_1;
+		break;
+	case XFER_MW_DMA_0:
+		mem_sttime = SBC_IDE_TIMING(MDMA0);
+
+		/* set configuration for RCS2# */
+		mem_stcfg |= TS_MASK;
+		mem_stcfg &= ~TCSOE_MASK;
+		mem_stcfg &= ~TOECS_MASK;
+		mem_stcfg |= SBC_IDE_MDMA0_TCSOE | SBC_IDE_MDMA0_TOECS;
 
-        au_writel(mem_sttime,MEM_STTIME2);
-        au_writel(mem_stcfg,MEM_STCFG2);
+		mode = XFER_MW_DMA_0;
+		break;
+#endif
+	default:
+		return 1;
+	}
+	
+	if (ide_config_drive_speed(drive, mode))
+		return 1;
 
-        spin_unlock_irqrestore(&ide_tune_chipset_spin_lock, flags);
+	au_writel(mem_sttime,MEM_STTIME2);
+	au_writel(mem_stcfg,MEM_STCFG2);
 
-        return 0;
+	return 0;
 }
 
 /*
  * Multi-Word DMA + DbDMA functions
  */
-#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
 
-static int in_drive_list(struct hd_driveid *id,
-                         const struct drive_list_entry *drive_table)
-{
-        for ( ; drive_table->id_model ; drive_table++){
-                if ((!strcmp(drive_table->id_model, id->model)) &&
-                        ((strstr(drive_table->id_firmware, id->fw_rev)) ||
-                        (!strcmp(drive_table->id_firmware, "ALL")))
-                )
-                        return 1;
-        }
-        return 0;
-}
+#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
 
 static int auide_build_sglist(ide_drive_t *drive,  struct request *rq)
 {
-        ide_hwif_t *hwif = drive->hwif;
-        _auide_hwif *ahwif = (_auide_hwif*)hwif->hwif_data;
-        struct scatterlist *sg = hwif->sg_table;
-
-        ide_map_sg(drive, rq);
-
-        if (rq_data_dir(rq) == READ)
-                hwif->sg_dma_direction = DMA_FROM_DEVICE;
-        else
-                hwif->sg_dma_direction = DMA_TO_DEVICE;
+	ide_hwif_t *hwif = drive->hwif;
+	_auide_hwif *ahwif = (_auide_hwif*)hwif->hwif_data;
+	struct scatterlist *sg = hwif->sg_table;
+
+	ide_map_sg(drive, rq);
+
+	if (rq_data_dir(rq) == READ)
+		hwif->sg_dma_direction = DMA_FROM_DEVICE;
+	else
+		hwif->sg_dma_direction = DMA_TO_DEVICE;
 
-        return dma_map_sg(ahwif->dev, sg, hwif->sg_nents,
-                          hwif->sg_dma_direction);
+	return dma_map_sg(ahwif->dev, sg, hwif->sg_nents,
+			  hwif->sg_dma_direction);
 }
 
 static int auide_build_dmatable(ide_drive_t *drive)
 {
-        int i, iswrite, count = 0;
-        ide_hwif_t *hwif = HWIF(drive);
+	int i, iswrite, count = 0;
+	ide_hwif_t *hwif = HWIF(drive);
 
-        struct request *rq = HWGROUP(drive)->rq;
+	struct request *rq = HWGROUP(drive)->rq;
 
-        _auide_hwif *ahwif = (_auide_hwif*)hwif->hwif_data;
-        struct scatterlist *sg;
+	_auide_hwif *ahwif = (_auide_hwif*)hwif->hwif_data;
+	struct scatterlist *sg;
 
-        iswrite = (rq_data_dir(rq) == WRITE);
-        /* Save for interrupt context */
-        ahwif->drive = drive;
-
-        /* Build sglist */
-        hwif->sg_nents = i = auide_build_sglist(drive, rq);
-
-        if (!i)
-                return 0;
-
-        /* fill the descriptors */
-        sg = hwif->sg_table;
-        while (i && sg_dma_len(sg)) {
-                u32 cur_addr;
-                u32 cur_len;
-
-                cur_addr = sg_dma_address(sg);
-                cur_len = sg_dma_len(sg);
-
-                while (cur_len) {
-                        u32 flags = DDMA_FLAGS_NOIE;
-                        unsigned int tc = (cur_len < 0xfe00)? cur_len: 0xfe00;
-
-                        if (++count >= PRD_ENTRIES) {
-                                printk(KERN_WARNING "%s: DMA table too small\n",
-                                drive->name);
-                                goto use_pio_instead;
-                        }
-
-                        /* Lets enable intr for the last descriptor only */
-                        if (1==i)
-                                flags = DDMA_FLAGS_IE;
-                        else
-                                flags = DDMA_FLAGS_NOIE;
-
-                        if (iswrite) {
-				if(!put_source_flags(ahwif->tx_chan,
-						(void*)(page_address(sg->page)
-							+ sg->offset),
-						tc, flags)) {
-					printk(KERN_ERR "%s failed %d\n",
-							__FUNCTION__, __LINE__);
+	iswrite = (rq_data_dir(rq) == WRITE);
+	/* Save for interrupt context */
+	ahwif->drive = drive;
+
+	/* Build sglist */
+	hwif->sg_nents = i = auide_build_sglist(drive, rq);
+
+	if (!i)
+		return 0;
+
+	/* fill the descriptors */
+	sg = hwif->sg_table;
+	while (i && sg_dma_len(sg)) {
+		u32 cur_addr;
+		u32 cur_len;
+
+		cur_addr = sg_dma_address(sg);
+		cur_len = sg_dma_len(sg);
+
+		while (cur_len) {
+			u32 flags = DDMA_FLAGS_NOIE;
+			unsigned int tc = (cur_len < 0xfe00)? cur_len: 0xfe00;
+
+			if (++count >= PRD_ENTRIES) {
+				printk(KERN_WARNING "%s: DMA table too small\n",
+				       drive->name);
+				goto use_pio_instead;
+			}
+
+			/* Lets enable intr for the last descriptor only */
+			if (1==i)
+				flags = DDMA_FLAGS_IE;
+			else
+				flags = DDMA_FLAGS_NOIE;
+
+			if (iswrite) {
+				if(!put_source_flags(ahwif->tx_chan, 
+						     (void*)(page_address(sg->page) 
+							     + sg->offset), 
+						     tc, flags)) { 
+					printk(KERN_ERR "%s failed %d\n", 
+					       __FUNCTION__, __LINE__);
 				}
-                        } else
+			} else 
 			{
-				if(!put_dest_flags(ahwif->rx_chan,
-						(void*)(page_address(sg->page)
-							+ sg->offset),
-						tc, flags)) {
-					printk(KERN_ERR "%s failed %d\n",
-							__FUNCTION__, __LINE__);
+				if(!put_dest_flags(ahwif->rx_chan, 
+						   (void*)(page_address(sg->page) 
+							   + sg->offset), 
+						   tc, flags)) { 
+					printk(KERN_ERR "%s failed %d\n", 
+					       __FUNCTION__, __LINE__);
 				}
-                        }
+			}
+
+			cur_addr += tc;
+			cur_len -= tc;
+		}
+		sg++;
+		i--;
+	}
 
-                        cur_addr += tc;
-                        cur_len -= tc;
-                }
-                sg++;
-                i--;
-        }
-
-        if (count)
-                return 1;
-
-use_pio_instead:
-        dma_unmap_sg(ahwif->dev,
-                     hwif->sg_table,
-                     hwif->sg_nents,
-                     hwif->sg_dma_direction);
+	if (count)
+		return 1;
 
-        return 0; /* revert to PIO for this request */
+ use_pio_instead:
+	dma_unmap_sg(ahwif->dev,
+		     hwif->sg_table,
+		     hwif->sg_nents,
+		     hwif->sg_dma_direction);
+
+	return 0; /* revert to PIO for this request */
 }
 
 static int auide_dma_end(ide_drive_t *drive)
 {
-        ide_hwif_t *hwif = HWIF(drive);
-        _auide_hwif *ahwif = (_auide_hwif*)hwif->hwif_data;
+	ide_hwif_t *hwif = HWIF(drive);
+	_auide_hwif *ahwif = (_auide_hwif*)hwif->hwif_data;
 
-        if (hwif->sg_nents) {
-                dma_unmap_sg(ahwif->dev, hwif->sg_table, hwif->sg_nents,
-                             hwif->sg_dma_direction);
-                hwif->sg_nents = 0;
-        }
+	if (hwif->sg_nents) {
+		dma_unmap_sg(ahwif->dev, hwif->sg_table, hwif->sg_nents,
+			     hwif->sg_dma_direction);
+		hwif->sg_nents = 0;
+	}
 
-        return 0;
+	return 0;
 }
 
 static void auide_dma_start(ide_drive_t *drive )
 {
-//      printk("%s\n", __FUNCTION__);
 }
 
-ide_startstop_t auide_dma_intr(ide_drive_t *drive)
-{
-        //printk("%s\n", __FUNCTION__);
-
-        u8 stat = 0, dma_stat = 0;
-
-        dma_stat = HWIF(drive)->ide_dma_end(drive);
-        stat = HWIF(drive)->INB(IDE_STATUS_REG);        /* get drive status */
-        if (OK_STAT(stat,DRIVE_READY,drive->bad_wstat|DRQ_STAT)) {
-                if (!dma_stat) {
-                        struct request *rq = HWGROUP(drive)->rq;
-
-                        ide_end_request(drive, 1, rq->nr_sectors);
-                        return ide_stopped;
-                }
-                printk(KERN_ERR "%s: dma_intr: bad DMA status (dma_stat=%x)\n",
-                                 drive->name, dma_stat);
-        }
-        return ide_error(drive, "dma_intr", stat);
-}
 
 static void auide_dma_exec_cmd(ide_drive_t *drive, u8 command)
 {
-        //printk("%s\n", __FUNCTION__);
-
-        /* issue cmd to drive */
-        ide_execute_command(drive, command, &auide_dma_intr,
-                            (2*WAIT_CMD), NULL);
+	/* issue cmd to drive */
+	ide_execute_command(drive, command, &ide_dma_intr,
+			    (2*WAIT_CMD), NULL);
 }
 
 static int auide_dma_setup(ide_drive_t *drive)
-{
-//      printk("%s\n", __FUNCTION__);
-
-        if (drive->media != ide_disk)
-                return 1;
-
-        if (!auide_build_dmatable(drive))
-                        /* try PIO instead of DMA */
-                        return 1;
+{       	
+	struct request *rq = HWGROUP(drive)->rq;
 
-        drive->waiting_for_dma = 1;
+	if (!auide_build_dmatable(drive)) {
+		ide_map_sg(drive, rq);
+		return 1;
+	}
 
-        return 0;
+	drive->waiting_for_dma = 1;
+	return 0;
 }
 
 static int auide_dma_check(ide_drive_t *drive)
 {
-//      printk("%s\n", __FUNCTION__);
+	u8 speed;
 
 #ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
-        if( !dbdma_init_done ){
-                auide_hwif.white_list = in_drive_list(drive->id,
-                                                      dma_white_list);
-                auide_hwif.black_list = in_drive_list(drive->id,
-                                                      dma_black_list);
-                auide_hwif.drive = drive;
-                auide_ddma_init(&auide_hwif);
-                dbdma_init_done = 1;
-        }
+
+	if( dbdma_init_done == 0 ){
+		auide_hwif.white_list = ide_in_drive_list(drive->id,
+							  dma_white_list);
+		auide_hwif.black_list = ide_in_drive_list(drive->id,
+							  dma_black_list);
+		auide_hwif.drive = drive;
+		auide_ddma_init(&auide_hwif);
+		dbdma_init_done = 1;
+	}
 #endif
 
-        /* Is the drive in our DMA black list? */
-        if ( auide_hwif.black_list ) {
-                drive->using_dma = 0;
-                printk("%s found in dma_blacklist[]! Disabling DMA.\n",
-                drive->id->model);
-        }
-        else
-                drive->using_dma = 1;
+	/* Is the drive in our DMA black list? */
+
+	if ( auide_hwif.black_list ) {
+		drive->using_dma = 0;
+
+		/* Borrowed the warning message from ide-dma.c */
+
+		printk(KERN_WARNING "%s: Disabling DMA for %s (blacklisted)\n",
+		       drive->name, drive->id->model);	       
+	}
+	else
+		drive->using_dma = 1;
+
+	speed = ide_find_best_mode(drive, XFER_PIO | XFER_MWDMA);
+	
+	if (drive->autodma && (speed & XFER_MODE) != XFER_PIO)
+		return HWIF(drive)->ide_dma_on(drive);
 
-        return HWIF(drive)->ide_dma_host_on(drive);
+	return HWIF(drive)->ide_dma_off_quietly(drive);
 }
 
 static int auide_dma_test_irq(ide_drive_t *drive)
-{
-//      printk("%s\n", __FUNCTION__);
-
-        if (!drive->waiting_for_dma)
-                printk(KERN_WARNING "%s: ide_dma_test_irq \
+{	
+	if (drive->waiting_for_dma == 0)
+		printk(KERN_WARNING "%s: ide_dma_test_irq \
                                      called while not waiting\n", drive->name);
 
-        /* If dbdma didn't execute the STOP command yet, the
-         * active bit is still set
+	/* If dbdma didn't execute the STOP command yet, the
+	 * active bit is still set
 	 */
-        drive->waiting_for_dma++;
-        if (drive->waiting_for_dma >= DMA_WAIT_TIMEOUT) {
-                printk(KERN_WARNING "%s: timeout waiting for ddma to \
+	drive->waiting_for_dma++;
+	if (drive->waiting_for_dma >= DMA_WAIT_TIMEOUT) {
+		printk(KERN_WARNING "%s: timeout waiting for ddma to \
                                      complete\n", drive->name);
-                return 1;
-        }
-        udelay(10);
-        return 0;
+		return 1;
+	}
+	udelay(10);
+	return 0;
 }
 
 static int auide_dma_host_on(ide_drive_t *drive)
 {
-//      printk("%s\n", __FUNCTION__);
-        return 0;
+	return 0;
 }
 
 static int auide_dma_on(ide_drive_t *drive)
 {
-//      printk("%s\n", __FUNCTION__);
-        drive->using_dma = 1;
-        return auide_dma_host_on(drive);
+	drive->using_dma = 1;
+	return auide_dma_host_on(drive);
 }
 
 
 static int auide_dma_host_off(ide_drive_t *drive)
 {
-//      printk("%s\n", __FUNCTION__);
-        return 0;
+	return 0;
 }
 
 static int auide_dma_off_quietly(ide_drive_t *drive)
 {
-//      printk("%s\n", __FUNCTION__);
-        drive->using_dma = 0;
-        return auide_dma_host_off(drive);
+	drive->using_dma = 0;
+	return auide_dma_host_off(drive);
 }
 
 static int auide_dma_lostirq(ide_drive_t *drive)
 {
-//      printk("%s\n", __FUNCTION__);
-
-        printk(KERN_ERR "%s: IRQ lost\n", drive->name);
-        return 0;
+	printk(KERN_ERR "%s: IRQ lost\n", drive->name);
+	return 0;
 }
 
 static void auide_ddma_tx_callback(int irq, void *param, struct pt_regs *regs)
 {
-//      printk("%s\n", __FUNCTION__);
-
-        _auide_hwif *ahwif = (_auide_hwif*)param;
-        ahwif->drive->waiting_for_dma = 0;
-        return;
+	_auide_hwif *ahwif = (_auide_hwif*)param;
+	ahwif->drive->waiting_for_dma = 0;
 }
 
 static void auide_ddma_rx_callback(int irq, void *param, struct pt_regs *regs)
 {
-//      printk("%s\n", __FUNCTION__);
+	_auide_hwif *ahwif = (_auide_hwif*)param;
+	ahwif->drive->waiting_for_dma = 0;
+}
 
-        _auide_hwif *ahwif = (_auide_hwif*)param;
-        ahwif->drive->waiting_for_dma = 0;
-        return;
+#endif /* end CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA */
+
+static void auide_init_dbdma_dev(dbdev_tab_t *dev, u32 dev_id, u32 tsize, u32 devwidth, u32 flags)
+{
+	dev->dev_id          = dev_id;
+	dev->dev_physaddr    = (u32)AU1XXX_ATA_PHYS_ADDR;
+	dev->dev_intlevel    = 0;
+	dev->dev_intpolarity = 0;
+	dev->dev_tsize       = tsize;
+	dev->dev_devwidth    = devwidth;
+	dev->dev_flags       = flags;
 }
+  
+#if defined(CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA)
 
 static int auide_dma_timeout(ide_drive_t *drive)
 {
 //      printk("%s\n", __FUNCTION__);
 
-        printk(KERN_ERR "%s: DMA timeout occurred: ", drive->name);
+	printk(KERN_ERR "%s: DMA timeout occurred: ", drive->name);
 
-        if (HWIF(drive)->ide_dma_test_irq(drive))
-                return 0;
+	if (HWIF(drive)->ide_dma_test_irq(drive))
+		return 0;
 
-        return HWIF(drive)->ide_dma_end(drive);
+	return HWIF(drive)->ide_dma_end(drive);
 }
-#endif /* end CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA */
+					
 
+static int auide_ddma_init(_auide_hwif *auide) {
+	
+	dbdev_tab_t source_dev_tab, target_dev_tab;
+	u32 dev_id, tsize, devwidth, flags;
+	ide_hwif_t *hwif = auide->hwif;
 
-static int auide_ddma_init( _auide_hwif *auide )
-{
-//      printk("%s\n", __FUNCTION__);
+	dev_id   = AU1XXX_ATA_DDMA_REQ;
 
-        dbdev_tab_t source_dev_tab;
-#if defined(CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA)
-        dbdev_tab_t target_dev_tab;
-        ide_hwif_t *hwif = auide->hwif;
-        char warning_output [2][80];
-        int i;
-#endif
-
-        /* Add our custom device to DDMA device table */
-        /* Create our new device entries in the table */
-#if defined(CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA)
-        source_dev_tab.dev_id = AU1XXX_ATA_DDMA_REQ;
+	if (auide->white_list || auide->black_list) {
+		tsize    = 8;
+		devwidth = 32;
+	}
+	else { 
+		tsize    = 1;
+		devwidth = 16;
+		
+		printk(KERN_ERR "au1xxx-ide: %s is not on ide driver whitelist.\n",auide_hwif.drive->id->model);
+		printk(KERN_ERR "            please read 'Documentation/mips/AU1xxx_IDE.README'");
+	}
 
-        if( auide->white_list || auide->black_list ){
-                source_dev_tab.dev_tsize       = 8;
-                source_dev_tab.dev_devwidth    = 32;
-                source_dev_tab.dev_physaddr    = (u32)AU1XXX_ATA_PHYS_ADDR;
-                source_dev_tab.dev_intlevel    = 0;
-                source_dev_tab.dev_intpolarity = 0;
-
-                /* init device table for target - static bus controller - */
-                target_dev_tab.dev_id          = DSCR_CMD0_ALWAYS;
-                target_dev_tab.dev_tsize       = 8;
-                target_dev_tab.dev_devwidth    = 32;
-                target_dev_tab.dev_physaddr    = (u32)AU1XXX_ATA_PHYS_ADDR;
-                target_dev_tab.dev_intlevel    = 0;
-                target_dev_tab.dev_intpolarity = 0;
-                target_dev_tab.dev_flags       = DEV_FLAGS_ANYUSE;
-        }
-        else{
-                source_dev_tab.dev_tsize       = 1;
-                source_dev_tab.dev_devwidth    = 16;
-                source_dev_tab.dev_physaddr    = (u32)AU1XXX_ATA_PHYS_ADDR;
-                source_dev_tab.dev_intlevel    = 0;
-                source_dev_tab.dev_intpolarity = 0;
-
-                /* init device table for target - static bus controller - */
-                target_dev_tab.dev_id          = DSCR_CMD0_ALWAYS;
-                target_dev_tab.dev_tsize       = 1;
-                target_dev_tab.dev_devwidth    = 16;
-                target_dev_tab.dev_physaddr    = (u32)AU1XXX_ATA_PHYS_ADDR;
-                target_dev_tab.dev_intlevel    = 0;
-                target_dev_tab.dev_intpolarity = 0;
-                target_dev_tab.dev_flags       = DEV_FLAGS_ANYUSE;
-
-                sprintf(&warning_output[0][0],
-                        "%s is not on ide driver white list.",
-                        auide_hwif.drive->id->model);
-                for ( i=strlen(&warning_output[0][0]) ; i<76; i++ ){
-                        sprintf(&warning_output[0][i]," ");
-                }
-
-                sprintf(&warning_output[1][0],
-                "To add %s please read 'Documentation/mips/AU1xxx_IDE.README'.",
-                        auide_hwif.drive->id->model);
-                for ( i=strlen(&warning_output[1][0]) ; i<76; i++ ){
-                        sprintf(&warning_output[1][i]," ");
-                }
-
-                printk("\n****************************************");
-                printk("****************************************\n");
-                printk("* %s *\n",&warning_output[0][0]);
-                printk("* Switch to safe MWDMA Mode!            ");
-                printk("                                       *\n");
-                printk("* %s *\n",&warning_output[1][0]);
-                printk("****************************************");
-                printk("****************************************\n\n");
-        }
+#ifdef IDE_AU1XXX_BURSTMODE 
+	flags = DEV_FLAGS_SYNC | DEV_FLAGS_BURSTABLE;
 #else
-        source_dev_tab.dev_id = DSCR_CMD0_ALWAYS;
-        source_dev_tab.dev_tsize       = 8;
-        source_dev_tab.dev_devwidth    = 32;
-        source_dev_tab.dev_physaddr    = (u32)AU1XXX_ATA_PHYS_ADDR;
-        source_dev_tab.dev_intlevel    = 0;
-        source_dev_tab.dev_intpolarity = 0;
+	flags = DEV_FLAGS_SYNC;
 #endif
 
-#if CONFIG_BLK_DEV_IDE_AU1XXX_BURSTABLE_ON
-        /* set flags for tx channel */
-        source_dev_tab.dev_flags =  DEV_FLAGS_OUT
-                                  | DEV_FLAGS_SYNC
-                                  | DEV_FLAGS_BURSTABLE;
-        auide->tx_dev_id = au1xxx_ddma_add_device( &source_dev_tab );
-        /* set flags for rx channel */
-        source_dev_tab.dev_flags =  DEV_FLAGS_IN
-                                  | DEV_FLAGS_SYNC
-                                  | DEV_FLAGS_BURSTABLE;
-        auide->rx_dev_id = au1xxx_ddma_add_device( &source_dev_tab );
+	/* setup dev_tab for tx channel */
+	auide_init_dbdma_dev( &source_dev_tab,
+			      dev_id,
+			      tsize, devwidth, DEV_FLAGS_OUT | flags);
+ 	auide->tx_dev_id = au1xxx_ddma_add_device( &source_dev_tab );
+
+	auide_init_dbdma_dev( &source_dev_tab,
+			      dev_id,
+			      tsize, devwidth, DEV_FLAGS_IN | flags);
+ 	auide->rx_dev_id = au1xxx_ddma_add_device( &source_dev_tab );
+	
+	/* We also need to add a target device for the DMA */
+	auide_init_dbdma_dev( &target_dev_tab,
+			      (u32)DSCR_CMD0_ALWAYS,
+			      tsize, devwidth, DEV_FLAGS_ANYUSE);
+	auide->target_dev_id = au1xxx_ddma_add_device(&target_dev_tab);	
+ 
+	/* Get a channel for TX */
+	auide->tx_chan = au1xxx_dbdma_chan_alloc(auide->target_dev_id,
+						 auide->tx_dev_id,
+						 auide_ddma_tx_callback,
+						 (void*)auide);
+ 
+	/* Get a channel for RX */
+	auide->rx_chan = au1xxx_dbdma_chan_alloc(auide->rx_dev_id,
+						 auide->target_dev_id,
+						 auide_ddma_rx_callback,
+						 (void*)auide);
+
+	auide->tx_desc_head = (void*)au1xxx_dbdma_ring_alloc(auide->tx_chan,
+							     NUM_DESCRIPTORS);
+	auide->rx_desc_head = (void*)au1xxx_dbdma_ring_alloc(auide->rx_chan,
+							     NUM_DESCRIPTORS);
+ 
+	hwif->dmatable_cpu = dma_alloc_coherent(auide->dev,
+						PRD_ENTRIES * PRD_BYTES,        /* 1 Page */
+						&hwif->dmatable_dma, GFP_KERNEL);
+	
+	au1xxx_dbdma_start( auide->tx_chan );
+	au1xxx_dbdma_start( auide->rx_chan );
+ 
+	return 0;
+} 
 #else
-        /* set flags for tx channel */
-        source_dev_tab.dev_flags = DEV_FLAGS_OUT | DEV_FLAGS_SYNC;
-        auide->tx_dev_id         = au1xxx_ddma_add_device( &source_dev_tab );
-        /* set flags for rx channel */
-        source_dev_tab.dev_flags = DEV_FLAGS_IN | DEV_FLAGS_SYNC;
-        auide->rx_dev_id         = au1xxx_ddma_add_device( &source_dev_tab );
-#endif
-
-#if  defined(CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA)
-
-        auide->target_dev_id           = au1xxx_ddma_add_device(&target_dev_tab);
+ 
+static int auide_ddma_init( _auide_hwif *auide )
+{
+	dbdev_tab_t source_dev_tab;
+	int flags;
 
-        /* Get a channel for TX */
-        auide->tx_chan = au1xxx_dbdma_chan_alloc(auide->target_dev_id,
-                                                 auide->tx_dev_id,
-                                                 auide_ddma_tx_callback,
-                                                 (void*)auide);
-        /* Get a channel for RX */
-        auide->rx_chan = au1xxx_dbdma_chan_alloc(auide->rx_dev_id,
-                                                 auide->target_dev_id,
-                                                 auide_ddma_rx_callback,
-                                                 (void*)auide);
-#else   /* CONFIG_BLK_DEV_IDE_AU1XXX_PIO_DBDMA */
-        /*
-         * Note: if call back is not enabled, update ctp->cur_ptr manually
-         */
-        auide->tx_chan = au1xxx_dbdma_chan_alloc(DSCR_CMD0_ALWAYS,
-                                                 auide->tx_dev_id,
-                                                 NULL,
-                                                 (void*)auide);
-        auide->rx_chan = au1xxx_dbdma_chan_alloc(auide->rx_dev_id,
-                                                 DSCR_CMD0_ALWAYS,
-                                                 NULL,
-                                                 (void*)auide);
+#ifdef IDE_AU1XXX_BURSTMODE 
+	flags = DEV_FLAGS_SYNC | DEV_FLAGS_BURSTABLE;
+#else
+	flags = DEV_FLAGS_SYNC;
 #endif
-        auide->tx_desc_head = (void*)au1xxx_dbdma_ring_alloc(auide->tx_chan,
-                                                             NUM_DESCRIPTORS);
-        auide->rx_desc_head = (void*)au1xxx_dbdma_ring_alloc(auide->rx_chan,
-                                                             NUM_DESCRIPTORS);
 
-#if defined(CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA)
-        hwif->dmatable_cpu = dma_alloc_coherent(auide->dev,
-                                                PRD_ENTRIES * PRD_BYTES,        /* 1 Page */
-                                                &hwif->dmatable_dma, GFP_KERNEL);
-
-        auide->sg_table = kmalloc(sizeof(struct scatterlist) * PRD_ENTRIES,
-                                GFP_KERNEL|GFP_DMA);
-        if (auide->sg_table == NULL) {
-                return -ENOMEM;
-        }
-#endif
-        au1xxx_dbdma_start( auide->tx_chan );
-        au1xxx_dbdma_start( auide->rx_chan );
-        return 0;
+	/* setup dev_tab for tx channel */
+	auide_init_dbdma_dev( &source_dev_tab,
+			      (u32)DSCR_CMD0_ALWAYS,
+			      8, 32, DEV_FLAGS_OUT | flags);
+ 	auide->tx_dev_id = au1xxx_ddma_add_device( &source_dev_tab );
+
+	auide_init_dbdma_dev( &source_dev_tab,
+			      (u32)DSCR_CMD0_ALWAYS,
+			      8, 32, DEV_FLAGS_IN | flags);
+ 	auide->rx_dev_id = au1xxx_ddma_add_device( &source_dev_tab );
+	
+	/* Get a channel for TX */
+	auide->tx_chan = au1xxx_dbdma_chan_alloc(DSCR_CMD0_ALWAYS,
+						 auide->tx_dev_id,
+						 NULL,
+						 (void*)auide);
+ 
+	/* Get a channel for RX */
+	auide->rx_chan = au1xxx_dbdma_chan_alloc(auide->rx_dev_id,
+						 DSCR_CMD0_ALWAYS,
+						 NULL,
+						 (void*)auide);
+ 
+	auide->tx_desc_head = (void*)au1xxx_dbdma_ring_alloc(auide->tx_chan,
+							     NUM_DESCRIPTORS);
+	auide->rx_desc_head = (void*)au1xxx_dbdma_ring_alloc(auide->rx_chan,
+							     NUM_DESCRIPTORS);
+ 
+	au1xxx_dbdma_start( auide->tx_chan );
+	au1xxx_dbdma_start( auide->rx_chan );
+ 	
+	return 0;
 }
+#endif
 
 static void auide_setup_ports(hw_regs_t *hw, _auide_hwif *ahwif)
 {
-        int i;
-#define ide_ioreg_t unsigned long
-        ide_ioreg_t *ata_regs = hw->io_ports;
-
-	/* fixme */
-        for (i = 0; i < IDE_CONTROL_OFFSET; i++) {
-                *ata_regs++ = (ide_ioreg_t) ahwif->regbase
-                            + (ide_ioreg_t)(i << AU1XXX_ATA_REG_OFFSET);
-        }
-
-        /* set the Alternative Status register */
-        *ata_regs = (ide_ioreg_t) ahwif->regbase
-                  + (ide_ioreg_t)(14 << AU1XXX_ATA_REG_OFFSET);
+	int i;
+	unsigned long *ata_regs = hw->io_ports;
+
+	/* FIXME? */
+	for (i = 0; i < IDE_CONTROL_OFFSET; i++) {
+		*ata_regs++ = ahwif->regbase + (i << AU1XXX_ATA_REG_OFFSET);
+	}
+
+	/* set the Alternative Status register */
+	*ata_regs = ahwif->regbase + (14 << AU1XXX_ATA_REG_OFFSET);
 }
 
 static int au_ide_probe(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
-        _auide_hwif *ahwif = &auide_hwif;
-        ide_hwif_t *hwif;
+	_auide_hwif *ahwif = &auide_hwif;
+	ide_hwif_t *hwif;
 	struct resource *res;
 	int ret = 0;
 
 #if defined(CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA)
-        char *mode = "MWDMA2";
+	char *mode = "MWDMA2";
 #elif defined(CONFIG_BLK_DEV_IDE_AU1XXX_PIO_DBDMA)
-        char *mode = "PIO+DDMA(offload)";
+	char *mode = "PIO+DDMA(offload)";
 #endif
 
-        memset(&auide_hwif, 0, sizeof(_auide_hwif));
-        auide_hwif.dev                  = 0;
+	memset(&auide_hwif, 0, sizeof(_auide_hwif));
+	auide_hwif.dev                  = 0;
 
 	ahwif->dev = dev;
 	ahwif->irq = platform_get_irq(pdev, 0);
@@ -902,11 +675,11 @@
 		goto out;
 	}
 
-        if (!request_mem_region (res->start, res->end-res->start, pdev->name)) {
+	if (!request_mem_region (res->start, res->end-res->start, pdev->name)) {
 		pr_debug("%s: request_mem_region failed\n", DRV_NAME);
-                ret =  -EBUSY;
+		ret =  -EBUSY;
 		goto out;
-        }
+	}
 
 	ahwif->regbase = (u32)ioremap(res->start, res->end-res->start);
 	if (ahwif->regbase == 0) {
@@ -914,130 +687,92 @@
 		goto out;
 	}
 
-        hwif                            = &ide_hwifs[pdev->id];
+	/* FIXME:  This might possibly break PCMCIA IDE devices */
+
+	hwif                            = &ide_hwifs[pdev->id];
 	hw_regs_t *hw 			= &hwif->hw;
-        hwif->irq = hw->irq             = ahwif->irq;
-        hwif->chipset                   = ide_au1xxx;
+	hwif->irq = hw->irq             = ahwif->irq;
+	hwif->chipset                   = ide_au1xxx;
 
-        auide_setup_ports(hw, ahwif);
+	auide_setup_ports(hw, ahwif);
 	memcpy(hwif->io_ports, hw->io_ports, sizeof(hwif->io_ports));
 
-#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_SEQTS_PER_RQ
-        hwif->rqsize = CONFIG_BLK_DEV_IDE_AU1XXX_SEQTS_PER_RQ;
-        hwif->rqsize                    = ((hwif->rqsize > AU1XXX_ATA_RQSIZE)
-                                        || (hwif->rqsize < 32)) ? AU1XXX_ATA_RQSIZE : hwif->rqsize;
-#else /* if kernel config is not set */
-        hwif->rqsize                    = AU1XXX_ATA_RQSIZE;
-#endif
-
-        hwif->ultra_mask                = 0x0;  /* Disable Ultra DMA */
+	hwif->ultra_mask                = 0x0;  /* Disable Ultra DMA */
 #ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
-        hwif->mwdma_mask                = 0x07; /* Multimode-2 DMA  */
-        hwif->swdma_mask                = 0x07;
+	hwif->mwdma_mask                = 0x07; /* Multimode-2 DMA  */
+	hwif->swdma_mask                = 0x00;
 #else
-        hwif->mwdma_mask                = 0x0;
-        hwif->swdma_mask                = 0x0;
+	hwif->mwdma_mask                = 0x0;
+	hwif->swdma_mask                = 0x0;
 #endif
-        //hwif->noprobe = !hwif->io_ports[IDE_DATA_OFFSET];
-        hwif->noprobe = 0;
-        hwif->drives[0].unmask          = 1;
-        hwif->drives[1].unmask          = 1;
-
-        /* hold should be on in all cases */
-        hwif->hold                      = 1;
-        hwif->mmio                      = 2;
-
-        /* set up local I/O function entry points */
-        hwif->INB                       = auide_inb;
-        hwif->INW                       = auide_inw;
-        hwif->INL                       = auide_inl;
-        hwif->INSW                      = auide_insw;
-        hwif->INSL                      = auide_insl;
-        hwif->OUTB                      = auide_outb;
-        hwif->OUTBSYNC                  = auide_outbsync;
-        hwif->OUTW                      = auide_outw;
-        hwif->OUTL                      = auide_outl;
-        hwif->OUTSW                     = auide_outsw;
-        hwif->OUTSL                     = auide_outsl;
 
-        hwif->tuneproc                  = &auide_tune_drive;
-        hwif->speedproc                 = &auide_tune_chipset;
+	hwif->noprobe = 0;
+	hwif->drives[0].unmask          = 1;
+	hwif->drives[1].unmask          = 1;
 
-#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
-        hwif->ide_dma_off_quietly       = &auide_dma_off_quietly;
-        hwif->ide_dma_timeout           = &auide_dma_timeout;
+	/* hold should be on in all cases */
+	hwif->hold                      = 1;
+	hwif->mmio                      = 2;
 
-        hwif->ide_dma_check             = &auide_dma_check;
-        hwif->dma_exec_cmd              = &auide_dma_exec_cmd;
-        hwif->dma_start                 = &auide_dma_start;
-        hwif->ide_dma_end               = &auide_dma_end;
-        hwif->dma_setup                 = &auide_dma_setup;
-        hwif->ide_dma_test_irq          = &auide_dma_test_irq;
-        hwif->ide_dma_host_off          = &auide_dma_host_off;
-        hwif->ide_dma_host_on           = &auide_dma_host_on;
-        hwif->ide_dma_lostirq           = &auide_dma_lostirq;
-        hwif->ide_dma_on                = &auide_dma_on;
-
-        hwif->autodma                   = 1;
-        hwif->drives[0].autodma         = hwif->autodma;
-        hwif->drives[1].autodma         = hwif->autodma;
-        hwif->atapi_dma                 = 1;
-        hwif->drives[0].using_dma       = 1;
-        hwif->drives[1].using_dma       = 1;
-#else /* !CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA */
-        hwif->autodma                   = 0;
-        hwif->channel                   = 0;
-        hwif->hold                      = 1;
-        hwif->select_data               = 0;    /* no chipset-specific code */
-        hwif->config_data               = 0;    /* no chipset-specific code */
-
-        hwif->drives[0].autodma         = 0;
-        hwif->drives[0].drive_data      = 0;    /* no drive data */
-        hwif->drives[0].using_dma       = 0;
-        hwif->drives[0].waiting_for_dma = 0;
-        hwif->drives[0].autotune        = 1;    /* 1=autotune, 2=noautotune, 0=default */
-        /* secondary hdd not supported */
-        hwif->drives[1].autodma         = 0;
-
-        hwif->drives[1].drive_data      = 0;
-        hwif->drives[1].using_dma       = 0;
-        hwif->drives[1].waiting_for_dma = 0;
-        hwif->drives[1].autotune        = 2;   /* 1=autotune, 2=noautotune, 0=default */
-#endif
-        hwif->drives[0].io_32bit        = 0;   /* 0=16-bit, 1=32-bit, 2/3=32bit+sync */
-        hwif->drives[1].io_32bit        = 0;   /* 0=16-bit, 1=32-bit, 2/3=32bit+sync */
+	/* If the user has selected DDMA assisted copies,
+	   then set up a few local I/O function entry points 
+	*/
 
-        /*Register Driver with PM Framework*/
-#ifdef CONFIG_PM
-        auide_hwif.pm.lock    = SPIN_LOCK_UNLOCKED;
-        auide_hwif.pm.stopped = 0;
-
-        auide_hwif.pm.dev = new_au1xxx_power_device( "ide",
-                                                &au1200ide_pm_callback,
-                                                NULL);
-        if ( auide_hwif.pm.dev == NULL )
-                printk(KERN_INFO "Unable to create a power management \
-                                device entry for the au1200-IDE.\n");
-        else
-                printk(KERN_INFO "Power management device entry for the \
-                                au1200-IDE loaded.\n");
+#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_PIO_DBDMA	
+	hwif->INSW                      = auide_insw;
+	hwif->OUTSW                     = auide_outsw;
 #endif
 
-        auide_hwif.hwif                 = hwif;
-        hwif->hwif_data                 = &auide_hwif;
+	hwif->tuneproc                  = &auide_tune_drive;
+	hwif->speedproc                 = &auide_tune_chipset;
+
+#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
+	hwif->ide_dma_off_quietly       = &auide_dma_off_quietly;
+	hwif->ide_dma_timeout           = &auide_dma_timeout;
+
+	hwif->ide_dma_check             = &auide_dma_check;
+	hwif->dma_exec_cmd              = &auide_dma_exec_cmd;
+	hwif->dma_start                 = &auide_dma_start;
+	hwif->ide_dma_end               = &auide_dma_end;
+	hwif->dma_setup                 = &auide_dma_setup;
+	hwif->ide_dma_test_irq          = &auide_dma_test_irq;
+	hwif->ide_dma_host_off          = &auide_dma_host_off;
+	hwif->ide_dma_host_on           = &auide_dma_host_on;
+	hwif->ide_dma_lostirq           = &auide_dma_lostirq;
+	hwif->ide_dma_on                = &auide_dma_on;
+
+	hwif->autodma                   = 1;
+	hwif->drives[0].autodma         = hwif->autodma;
+	hwif->drives[1].autodma         = hwif->autodma;
+	hwif->atapi_dma                 = 1;
 
-#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_PIO_DBDMA
-        auide_ddma_init(&auide_hwif);
-        dbdma_init_done = 1;
+#else /* !CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA */
+	hwif->autodma                   = 0;
+	hwif->channel                   = 0;
+	hwif->hold                      = 1;
+	hwif->select_data               = 0;    /* no chipset-specific code */
+	hwif->config_data               = 0;    /* no chipset-specific code */
+
+	hwif->drives[0].autodma         = 0;
+	hwif->drives[0].autotune        = 1;    /* 1=autotune, 2=noautotune, 0=default */
+#endif
+	hwif->drives[0].no_io_32bit     = 1;   
+
+	auide_hwif.hwif                 = hwif;
+	hwif->hwif_data                 = &auide_hwif;
+
+#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_PIO_DBDMA           
+	auide_ddma_init(&auide_hwif);
+	dbdma_init_done = 1;
 #endif
 
 	probe_hwif_init(hwif);
 	dev_set_drvdata(dev, hwif);
 
-        printk(KERN_INFO "Au1xxx IDE(builtin) configured for %s\n", mode );
+	printk(KERN_INFO "Au1xxx IDE(builtin) configured for %s\n", mode );
 
-out:
-        return ret;
+ out:
+	return ret;
 }
 
 static int au_ide_remove(struct device *dev)
@@ -1045,7 +780,7 @@
 	struct platform_device *pdev = to_platform_device(dev);
 	struct resource *res;
 	ide_hwif_t *hwif = dev_get_drvdata(dev);
-        _auide_hwif *ahwif = &auide_hwif;
+	_auide_hwif *ahwif = &auide_hwif;
 
 	ide_unregister(hwif - ide_hwifs);
 
@@ -1069,180 +804,11 @@
 	return driver_register(&au1200_ide_driver);
 }
 
-static void __init au_ide_exit(void)
+static void __exit au_ide_exit(void)
 {
 	driver_unregister(&au1200_ide_driver);
 }
 
-#ifdef CONFIG_PM
-int au1200ide_pm_callback( au1xxx_power_dev_t *dev,\
-                        au1xxx_request_t request, void *data) {
-
-        unsigned int d, err = 0;
-        unsigned long flags;
-
-        spin_lock_irqsave(auide_hwif.pm.lock, flags);
-
-        switch (request){
-                case AU1XXX_PM_SLEEP:
-                        err = au1xxxide_pm_sleep(dev);
-                        break;
-                case AU1XXX_PM_WAKEUP:
-                        d = *((unsigned int*)data);
-                        if ( d > 0 && d <= 99) {
-                                err = au1xxxide_pm_standby(dev);
-                        }
-                        else {
-                                err = au1xxxide_pm_resume(dev);
-                        }
-                        break;
-                case AU1XXX_PM_GETSTATUS:
-                        err = au1xxxide_pm_getstatus(dev);
-                        break;
-                case AU1XXX_PM_ACCESS:
-                        err = au1xxxide_pm_access(dev);
-                        break;
-                case AU1XXX_PM_IDLE:
-                        err = au1xxxide_pm_idle(dev);
-                        break;
-                case AU1XXX_PM_CLEANUP:
-                        err = au1xxxide_pm_cleanup(dev);
-                        break;
-                default:
-                        err = -1;
-                        break;
-        }
-
-        spin_unlock_irqrestore(auide_hwif.pm.lock, flags);
-
-        return err;
-}
-
-static int au1xxxide_pm_standby( au1xxx_power_dev_t *dev ) {
-        return 0;
-}
-
-static int au1xxxide_pm_sleep( au1xxx_power_dev_t *dev ) {
-
-        int retval;
-        ide_hwif_t *hwif = auide_hwif.hwif;
-        struct request rq;
-        struct request_pm_state rqpm;
-        ide_task_t args;
-
-        if(auide_hwif.pm.stopped)
-                return -1;
-
-        /*
-         * wait until hard disc is ready
-         */
-        if ( wait_for_ready(&hwif->drives[0], 35000) ) {
-                printk("Wait for drive sleep timeout!\n");
-                retval = -1;
-        }
-
-        /*
-         * sequenz to tell the high level ide driver that pm is resuming
-         */
-        memset(&rq, 0, sizeof(rq));
-        memset(&rqpm, 0, sizeof(rqpm));
-        memset(&args, 0, sizeof(args));
-        rq.flags = REQ_PM_SUSPEND;
-        rq.special = &args;
-        rq.pm = &rqpm;
-        rqpm.pm_step = ide_pm_state_start_suspend;
-        rqpm.pm_state = PMSG_SUSPEND;
-
-        retval = ide_do_drive_cmd(&hwif->drives[0], &rq, ide_wait);
-
-        if (wait_for_ready (&hwif->drives[0], 35000)) {
-                printk("Wait for drive sleep timeout!\n");
-                retval = -1;
-        }
-
-        /*
-         * stop dbdma channels
-         */
-        au1xxx_dbdma_reset(auide_hwif.tx_chan);
-        au1xxx_dbdma_reset(auide_hwif.rx_chan);
-
-        auide_hwif.pm.stopped = 1;
-
-        return retval;
-}
-
-static int au1xxxide_pm_resume( au1xxx_power_dev_t *dev ) {
-
-        int retval;
-        ide_hwif_t *hwif = auide_hwif.hwif;
-        struct request rq;
-        struct request_pm_state rqpm;
-        ide_task_t args;
-
-        if(!auide_hwif.pm.stopped)
-                return -1;
-
-        /*
-         * start dbdma channels
-         */
-        au1xxx_dbdma_start(auide_hwif.tx_chan);
-        au1xxx_dbdma_start(auide_hwif.rx_chan);
-
-        /*
-         * wait until hard disc is ready
-         */
-        if (wait_for_ready ( &hwif->drives[0], 35000)) {
-                printk("Wait for drive wake up timeout!\n");
-                retval = -1;
-        }
-
-        /*
-         * sequenz to tell the high level ide driver that pm is resuming
-         */
-        memset(&rq, 0, sizeof(rq));
-        memset(&rqpm, 0, sizeof(rqpm));
-        memset(&args, 0, sizeof(args));
-        rq.flags = REQ_PM_RESUME;
-        rq.special = &args;
-        rq.pm = &rqpm;
-        rqpm.pm_step = ide_pm_state_start_resume;
-        rqpm.pm_state = PMSG_ON;
-
-        retval = ide_do_drive_cmd(&hwif->drives[0], &rq, ide_head_wait);
-
-        /*
-        * wait for hard disc
-        */
-        if ( wait_for_ready(&hwif->drives[0], 35000) ) {
-                printk("Wait for drive wake up timeout!\n");
-                retval = -1;
-        }
-
-        auide_hwif.pm.stopped = 0;
-
-        return retval;
-}
-
-static int au1xxxide_pm_getstatus( au1xxx_power_dev_t *dev ) {
-        return dev->cur_state;
-}
-
-static int au1xxxide_pm_access( au1xxx_power_dev_t *dev ) {
-        if (dev->cur_state != AWAKE_STATE)
-                return 0;
-        else
-                return -1;
-}
-
-static int au1xxxide_pm_idle( au1xxx_power_dev_t *dev ) {
-        return 0;
-}
-
-static int au1xxxide_pm_cleanup( au1xxx_power_dev_t *dev ) {
-        return 0;
-}
-#endif /* CONFIG_PM */
-
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("AU1200 IDE driver");
 
diff -urN linux-2.6.15-rc5/drivers/ide/pci/sgiioc4.c linux-2.6.15-rc6/drivers/ide/pci/sgiioc4.c
--- linux-2.6.15-rc5/drivers/ide/pci/sgiioc4.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/ide/pci/sgiioc4.c	2005-12-18 22:28:03.716015099 -0800
@@ -622,12 +622,18 @@
 	ide_hwif_t *hwif;
 	int h;
 
+	/*
+	 * Find an empty HWIF; if none available, return -ENOMEM.
+	 */
 	for (h = 0; h < MAX_HWIFS; ++h) {
 		hwif = &ide_hwifs[h];
-		/* Find an empty HWIF */
 		if (hwif->chipset == ide_unknown)
 			break;
 	}
+	if (h == MAX_HWIFS) {
+		printk(KERN_ERR "%s: too many IDE interfaces, no room in table\n", d->name);
+		return -ENOMEM;
+	}
 
 	/*  Get the CmdBlk and CtrlBlk Base Registers */
 	base = pci_resource_start(dev, 0) + IOC4_CMD_OFFSET;
diff -urN linux-2.6.15-rc5/drivers/ide/pci/via82cxxx.c linux-2.6.15-rc6/drivers/ide/pci/via82cxxx.c
--- linux-2.6.15-rc5/drivers/ide/pci/via82cxxx.c	2005-12-18 22:27:54.881621481 -0800
+++ linux-2.6.15-rc6/drivers/ide/pci/via82cxxx.c	2005-12-18 22:28:03.719015233 -0800
@@ -80,6 +80,7 @@
 	u16 flags;
 } via_isa_bridges[] = {
 	{ "vt6410",	PCI_DEVICE_ID_VIA_6410,     0x00, 0x2f, VIA_UDMA_133 | VIA_BAD_AST },
+	{ "vt8251",	PCI_DEVICE_ID_VIA_8251,     0x00, 0x2f, VIA_UDMA_133 | VIA_BAD_AST },
 	{ "vt8237",	PCI_DEVICE_ID_VIA_8237,     0x00, 0x2f, VIA_UDMA_133 | VIA_BAD_AST },
 	{ "vt8235",	PCI_DEVICE_ID_VIA_8235,     0x00, 0x2f, VIA_UDMA_133 | VIA_BAD_AST },
 	{ "vt8233a",	PCI_DEVICE_ID_VIA_8233A,    0x00, 0x2f, VIA_UDMA_133 | VIA_BAD_AST },
diff -urN linux-2.6.15-rc5/drivers/ieee1394/hosts.h linux-2.6.15-rc6/drivers/ieee1394/hosts.h
--- linux-2.6.15-rc5/drivers/ieee1394/hosts.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/ieee1394/hosts.h	2005-12-18 22:28:03.725015500 -0800
@@ -41,6 +41,7 @@
         /* this nodes state */
         unsigned in_bus_reset:1;
         unsigned is_shutdown:1;
+	unsigned resume_packet_sent:1;
 
         /* this nodes' duties on the bus */
         unsigned is_root:1;
diff -urN linux-2.6.15-rc5/drivers/ieee1394/nodemgr.c linux-2.6.15-rc6/drivers/ieee1394/nodemgr.c
--- linux-2.6.15-rc5/drivers/ieee1394/nodemgr.c	2005-12-18 22:27:54.887621748 -0800
+++ linux-2.6.15-rc6/drivers/ieee1394/nodemgr.c	2005-12-18 22:28:03.726015545 -0800
@@ -1349,6 +1349,33 @@
 }
 
 
+/* Write the BROADCAST_CHANNEL as per IEEE1394a 8.3.2.3.11 and 8.4.2.3.  This
+ * seems like an optional service but in the end it is practically mandatory
+ * as a consequence of these clauses.
+ *
+ * Note that we cannot do a broadcast write to all nodes at once because some
+ * pre-1394a devices would hang. */
+static void nodemgr_irm_write_bc(struct node_entry *ne, int generation)
+{
+	const u64 bc_addr = (CSR_REGISTER_BASE | CSR_BROADCAST_CHANNEL);
+	quadlet_t bc_remote, bc_local;
+	int ret;
+
+	if (!ne->host->is_irm || ne->generation != generation ||
+	    ne->nodeid == ne->host->node_id)
+		return;
+
+	bc_local = cpu_to_be32(ne->host->csr.broadcast_channel);
+
+	/* Check if the register is implemented and 1394a compliant. */
+	ret = hpsb_read(ne->host, ne->nodeid, generation, bc_addr, &bc_remote,
+			sizeof(bc_remote));
+	if (!ret && bc_remote & cpu_to_be32(0x80000000) &&
+	    bc_remote != bc_local)
+		hpsb_node_write(ne, bc_addr, &bc_local, sizeof(bc_local));
+}
+
+
 static void nodemgr_probe_ne(struct host_info *hi, struct node_entry *ne, int generation)
 {
 	struct device *dev;
@@ -1360,6 +1387,8 @@
 	if (!dev)
 		return;
 
+	nodemgr_irm_write_bc(ne, generation);
+
 	/* If "needs_probe", then this is either a new or changed node we
 	 * rescan totally. If the generation matches for an existing node
 	 * (one that existed prior to the bus reset) we send update calls
@@ -1413,9 +1442,25 @@
 	return;
 }
 
-/* Because we are a 1394a-2000 compliant IRM, we need to inform all the other
- * nodes of the broadcast channel.  (Really we're only setting the validity
- * bit). Other IRM responsibilities go in here as well. */
+static int nodemgr_send_resume_packet(struct hpsb_host *host)
+{
+	struct hpsb_packet *packet;
+	int ret = 1;
+
+	packet = hpsb_make_phypacket(host,
+			0x003c0000 | NODEID_TO_NODE(host->node_id) << 24);
+	if (packet) {
+		packet->no_waiter = 1;
+		packet->generation = get_hpsb_generation(host);
+		ret = hpsb_send_packet(packet);
+	}
+	if (ret)
+		HPSB_WARN("fw-host%d: Failed to broadcast resume packet",
+			  host->id);
+	return ret;
+}
+
+/* Perform a few high-level IRM responsibilities. */
 static int nodemgr_do_irm_duties(struct hpsb_host *host, int cycles)
 {
 	quadlet_t bc;
@@ -1424,13 +1469,8 @@
 	if (!host->is_irm || host->irm_id == (nodeid_t)-1)
 		return 1;
 
-	host->csr.broadcast_channel |= 0x40000000;  /* set validity bit */
-
-	bc = cpu_to_be32(host->csr.broadcast_channel);
-
-	hpsb_write(host, LOCAL_BUS | ALL_NODES, get_hpsb_generation(host),
-		   (CSR_REGISTER_BASE | CSR_BROADCAST_CHANNEL),
-		   &bc, sizeof(quadlet_t));
+	/* We are a 1394a-2000 compliant IRM. Set the validity bit. */
+	host->csr.broadcast_channel |= 0x40000000;
 
 	/* If there is no bus manager then we should set the root node's
 	 * force_root bit to promote bus stability per the 1394
@@ -1463,6 +1503,13 @@
 		}
 	}
 
+	/* Some devices suspend their ports while being connected to an inactive
+	 * host adapter, i.e. if connected before the low-level driver is
+	 * loaded.  They become visible either when physically unplugged and
+	 * replugged, or when receiving a resume packet.  Send one once. */
+	if (!host->resume_packet_sent && !nodemgr_send_resume_packet(host))
+		host->resume_packet_sent = 1;
+
 	return 1;
 }
 
diff -urN linux-2.6.15-rc5/drivers/input/misc/wistron_btns.c linux-2.6.15-rc6/drivers/input/misc/wistron_btns.c
--- linux-2.6.15-rc5/drivers/input/misc/wistron_btns.c	2005-12-18 22:27:54.963625134 -0800
+++ linux-2.6.15-rc6/drivers/input/misc/wistron_btns.c	2005-12-18 22:28:03.807019154 -0800
@@ -320,7 +320,7 @@
 		},
 		.driver_data = keymap_acer_aspire_1500
 	},
-	{ 0, }
+	{ NULL, }
 };
 
 static int __init select_keymap(void)
diff -urN linux-2.6.15-rc5/drivers/input/mouse/alps.c linux-2.6.15-rc6/drivers/input/mouse/alps.c
--- linux-2.6.15-rc5/drivers/input/mouse/alps.c	2005-12-18 22:27:54.964625179 -0800
+++ linux-2.6.15-rc6/drivers/input/mouse/alps.c	2005-12-18 22:28:03.807019154 -0800
@@ -42,7 +42,7 @@
 	{ { 0x53, 0x02, 0x14 },	0xf8, 0xf8, 0 },
 	{ { 0x63, 0x02, 0x0a },	0xf8, 0xf8, 0 },
 	{ { 0x63, 0x02, 0x14 },	0xf8, 0xf8, 0 },
-	{ { 0x63, 0x02, 0x28 },	0xf8, 0xf8, 0 },
+	{ { 0x63, 0x02, 0x28 },	0xf8, 0xf8, ALPS_FW_BK_2 },		/* Fujitsu Siemens S6010 */
 	{ { 0x63, 0x02, 0x3c },	0x8f, 0x8f, ALPS_WHEEL },		/* Toshiba Satellite S2400-103 */
 	{ { 0x63, 0x02, 0x50 },	0xef, 0xef, ALPS_FW_BK_1 },		/* NEC Versa L320 */
 	{ { 0x63, 0x02, 0x64 },	0xf8, 0xf8, 0 },
diff -urN linux-2.6.15-rc5/drivers/macintosh/windfarm_pm81.c linux-2.6.15-rc6/drivers/macintosh/windfarm_pm81.c
--- linux-2.6.15-rc5/drivers/macintosh/windfarm_pm81.c	2005-12-18 22:27:55.017627541 -0800
+++ linux-2.6.15-rc6/drivers/macintosh/windfarm_pm81.c	2005-12-18 22:28:03.862021604 -0800
@@ -207,7 +207,7 @@
 	},
 	/* Model ID 3 */
 	{
-		.model_id	= 2,
+		.model_id	= 3,
 		.itarget	= 0x350000,
 		.gd		= 0x08e00000,
 		.gp		= 0x00566666,
@@ -219,7 +219,7 @@
 	},
 	/* Model ID 5 */
 	{
-		.model_id	= 2,
+		.model_id	= 5,
 		.itarget	= 0x3a0000,
 		.gd		= 0x15400000,
 		.gp		= 0x00233333,
diff -urN linux-2.6.15-rc5/drivers/md/raid1.c linux-2.6.15-rc6/drivers/md/raid1.c
--- linux-2.6.15-rc5/drivers/md/raid1.c	2005-12-18 22:27:55.031628164 -0800
+++ linux-2.6.15-rc6/drivers/md/raid1.c	2005-12-18 22:28:03.876022228 -0800
@@ -320,7 +320,6 @@
 		 * this branch is our 'one mirror IO has finished' event handler:
 		 */
 		r1_bio->bios[mirror] = NULL;
-		bio_put(bio);
 		if (!uptodate) {
 			md_error(r1_bio->mddev, conf->mirrors[mirror].rdev);
 			/* an I/O failed, we can't clear the bitmap */
@@ -377,7 +376,6 @@
 		}
 		if (test_bit(R1BIO_BehindIO, &r1_bio->state)) {
 			/* free extra copy of the data pages */
-/* FIXME bio has been freed!!! */
 			int i = bio->bi_vcnt;
 			while (i--)
 				__free_page(bio->bi_io_vec[i].bv_page);
@@ -391,6 +389,9 @@
 		raid_end_bio_io(r1_bio);
 	}
 
+	if (r1_bio->bios[mirror]==NULL)
+		bio_put(bio);
+
 	rdev_dec_pending(conf->mirrors[mirror].rdev, conf->mddev);
 	return 0;
 }
diff -urN linux-2.6.15-rc5/drivers/md/raid5.c linux-2.6.15-rc6/drivers/md/raid5.c
--- linux-2.6.15-rc5/drivers/md/raid5.c	2005-12-18 22:27:55.034628298 -0800
+++ linux-2.6.15-rc6/drivers/md/raid5.c	2005-12-18 22:28:03.880022407 -0800
@@ -98,7 +98,7 @@
 			list_add_tail(&sh->lru, &conf->inactive_list);
 			atomic_dec(&conf->active_stripes);
 			if (!conf->inactive_blocked ||
-			    atomic_read(&conf->active_stripes) < (NR_STRIPES*3/4))
+			    atomic_read(&conf->active_stripes) < (conf->max_nr_stripes*3/4))
 				wake_up(&conf->wait_for_stripe);
 		}
 	}
@@ -264,7 +264,8 @@
 				conf->inactive_blocked = 1;
 				wait_event_lock_irq(conf->wait_for_stripe,
 						    !list_empty(&conf->inactive_list) &&
-						    (atomic_read(&conf->active_stripes) < (NR_STRIPES *3/4)
+						    (atomic_read(&conf->active_stripes)
+						     < (conf->max_nr_stripes *3/4)
 						     || !conf->inactive_blocked),
 						    conf->device_lock,
 						    unplug_slaves(conf->mddev);
@@ -1917,7 +1918,7 @@
 			goto abort;
 		}
 	}
-memory = conf->max_nr_stripes * (sizeof(struct stripe_head) +
+	memory = conf->max_nr_stripes * (sizeof(struct stripe_head) +
 		 conf->raid_disks * ((sizeof(struct bio) + PAGE_SIZE))) / 1024;
 	if (grow_stripes(conf, conf->max_nr_stripes)) {
 		printk(KERN_ERR 
diff -urN linux-2.6.15-rc5/drivers/media/common/Kconfig linux-2.6.15-rc6/drivers/media/common/Kconfig
--- linux-2.6.15-rc5/drivers/media/common/Kconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/media/common/Kconfig	2005-12-18 22:28:03.882022496 -0800
@@ -1,12 +1,12 @@
 config VIDEO_SAA7146
-        tristate
+	tristate
 	select I2C
 
 config VIDEO_SAA7146_VV
-        tristate
+	tristate
 	select VIDEO_BUF
 	select VIDEO_VIDEOBUF
 	select VIDEO_SAA7146
 
 config VIDEO_VIDEOBUF
-        tristate
+	tristate
diff -urN linux-2.6.15-rc5/drivers/media/common/Makefile linux-2.6.15-rc6/drivers/media/common/Makefile
--- linux-2.6.15-rc5/drivers/media/common/Makefile	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/media/common/Makefile	2005-12-18 22:28:03.882022496 -0800
@@ -1,5 +1,5 @@
-saa7146-objs    := saa7146_i2c.o saa7146_core.o 
-saa7146_vv-objs := saa7146_vv_ksyms.o saa7146_fops.o saa7146_video.o saa7146_hlp.o saa7146_vbi.o  
+saa7146-objs    := saa7146_i2c.o saa7146_core.o
+saa7146_vv-objs := saa7146_vv_ksyms.o saa7146_fops.o saa7146_video.o saa7146_hlp.o saa7146_vbi.o
 
 obj-$(CONFIG_VIDEO_SAA7146) += saa7146.o
 obj-$(CONFIG_VIDEO_SAA7146_VV) += saa7146_vv.o
diff -urN linux-2.6.15-rc5/drivers/media/common/ir-common.c linux-2.6.15-rc6/drivers/media/common/ir-common.c
--- linux-2.6.15-rc5/drivers/media/common/ir-common.c	2005-12-18 22:27:55.036628387 -0800
+++ linux-2.6.15-rc6/drivers/media/common/ir-common.c	2005-12-18 22:28:03.882022496 -0800
@@ -313,6 +313,7 @@
 	if (ir_codes)
 		memcpy(ir->ir_codes, ir_codes, sizeof(ir->ir_codes));
 
+
 	dev->keycode     = ir->ir_codes;
 	dev->keycodesize = sizeof(IR_KEYTAB_TYPE);
 	dev->keycodemax  = IR_KEYTAB_SIZE;
diff -urN linux-2.6.15-rc5/drivers/media/common/saa7146_core.c linux-2.6.15-rc6/drivers/media/common/saa7146_core.c
--- linux-2.6.15-rc5/drivers/media/common/saa7146_core.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/media/common/saa7146_core.c	2005-12-18 22:28:03.883022540 -0800
@@ -174,8 +174,8 @@
 
 int saa7146_pgtable_alloc(struct pci_dev *pci, struct saa7146_pgtable *pt)
 {
-        u32          *cpu;
-        dma_addr_t   dma_addr;
+	u32          *cpu;
+	dma_addr_t   dma_addr;
 
 	cpu = pci_alloc_consistent(pci, PAGE_SIZE, &dma_addr);
 	if (NULL == cpu) {
@@ -405,7 +405,7 @@
 
 	pci_set_drvdata(pci, dev);
 
-        init_MUTEX(&dev->lock);
+	init_MUTEX(&dev->lock);
 	spin_lock_init(&dev->int_slock);
 	spin_lock_init(&dev->slock);
 
diff -urN linux-2.6.15-rc5/drivers/media/common/saa7146_fops.c linux-2.6.15-rc6/drivers/media/common/saa7146_fops.c
--- linux-2.6.15-rc5/drivers/media/common/saa7146_fops.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/media/common/saa7146_fops.c	2005-12-18 22:28:03.883022540 -0800
@@ -1,6 +1,6 @@
 #include <media/saa7146_vv.h>
 
-#define BOARD_CAN_DO_VBI(dev)   (dev->revision != 0 && dev->vv_data->vbi_minor != -1) 
+#define BOARD_CAN_DO_VBI(dev)   (dev->revision != 0 && dev->vv_data->vbi_minor != -1)
 
 /****************************************************************************/
 /* resource management functions, shamelessly stolen from saa7134 driver */
@@ -102,9 +102,9 @@
 	/* finish current buffer */
 	if (NULL == q->curr) {
 		DEB_D(("aiii. no current buffer\n"));
-		return;	
+		return;
 	}
-			
+
 	q->curr->vb.state = state;
 	do_gettimeofday(&q->curr->vb.ts);
 	wake_up(&q->curr->vb.done);
@@ -143,13 +143,13 @@
 			// fixme: fix this for vflip != 0
 
 			saa7146_write(dev, PROT_ADDR1, 0);
-			saa7146_write(dev, MC2, (MASK_02|MASK_18));		
+			saa7146_write(dev, MC2, (MASK_02|MASK_18));
 
 			/* write the address of the rps-program */
 			saa7146_write(dev, RPS_ADDR0, dev->d_rps0.dma_handle);
 			/* turn on rps */
 			saa7146_write(dev, MC1, (MASK_12 | MASK_28));
-				
+
 /*
 			printk("vdma%d.base_even:     0x%08x\n", 1,saa7146_read(dev,BASE_EVEN1));
 			printk("vdma%d.base_odd:      0x%08x\n", 1,saa7146_read(dev,BASE_ODD1));
@@ -246,7 +246,7 @@
 		goto out;
 	}
 	memset(fh,0,sizeof(*fh));
-	
+
 	file->private_data = fh;
 	fh->dev = dev;
 	fh->type = type;
@@ -275,7 +275,7 @@
 		file->private_data = NULL;
 	}
 	up(&saa7146_devices_lock);
-        return result;
+	return result;
 }
 
 static int fops_release(struct inode *inode, struct file *file)
@@ -405,7 +405,7 @@
 static void vv_callback(struct saa7146_dev *dev, unsigned long status)
 {
 	u32 isr = status;
-	
+
 	DEB_INT(("dev:%p, isr:0x%08x\n",dev,(u32)status));
 
 	if (0 != (isr & (MASK_27))) {
@@ -454,11 +454,11 @@
 	   handle different devices that might need different
 	   configuration data) */
 	dev->ext_vv_data = ext_vv;
-	
+
 	vv->video_minor = -1;
 	vv->vbi_minor = -1;
 
-	vv->d_clipping.cpu_addr = pci_alloc_consistent(dev->pci, SAA7146_CLIPPING_MEM, &vv->d_clipping.dma_handle);	
+	vv->d_clipping.cpu_addr = pci_alloc_consistent(dev->pci, SAA7146_CLIPPING_MEM, &vv->d_clipping.dma_handle);
 	if( NULL == vv->d_clipping.cpu_addr ) {
 		ERR(("out of memory. aborting.\n"));
 		kfree(vv);
@@ -468,7 +468,7 @@
 
 	saa7146_video_uops.init(dev,vv);
 	saa7146_vbi_uops.init(dev,vv);
-	
+
 	dev->vv_data = vv;
 	dev->vv_callback = &vv_callback;
 
@@ -480,12 +480,12 @@
 	struct saa7146_vv *vv = dev->vv_data;
 
 	DEB_EE(("dev:%p\n",dev));
- 
+
 	pci_free_consistent(dev->pci, SAA7146_RPS_MEM, vv->d_clipping.cpu_addr, vv->d_clipping.dma_handle);
- 	kfree(vv);
+	kfree(vv);
 	dev->vv_data = NULL;
 	dev->vv_callback = NULL;
-	
+
 	return 0;
 }
 
@@ -498,7 +498,7 @@
 	DEB_EE(("dev:%p, name:'%s', type:%d\n",dev,name,type));
 
 	// released by vfd->release
- 	vfd = video_device_alloc();
+	vfd = video_device_alloc();
 	if (vfd == NULL)
 		return -ENOMEM;
 
@@ -530,7 +530,7 @@
 int saa7146_unregister_device(struct video_device **vid, struct saa7146_dev* dev)
 {
 	struct saa7146_vv *vv = dev->vv_data;
-	
+
 	DEB_EE(("dev:%p\n",dev));
 
 	if( VFL_TYPE_GRABBER == (*vid)->type ) {
diff -urN linux-2.6.15-rc5/drivers/media/common/saa7146_i2c.c linux-2.6.15-rc6/drivers/media/common/saa7146_i2c.c
--- linux-2.6.15-rc5/drivers/media/common/saa7146_i2c.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/media/common/saa7146_i2c.c	2005-12-18 22:28:03.884022585 -0800
@@ -276,8 +276,8 @@
 	int i = 0, count = 0;
 	u32* buffer = dev->d_i2c.cpu_addr;
 	int err = 0;
-        int address_err = 0;
-        int short_delay = 0;
+	int address_err = 0;
+	int short_delay = 0;
 
 	if (down_interruptible (&dev->i2c_lock))
 		return -ERESTARTSYS;
@@ -325,7 +325,7 @@
 					if( 0 != (SAA7146_USE_I2C_IRQ & dev->ext->flags)) {
 						goto out;
 					}
-				        address_err++;
+					address_err++;
 				}
 				DEB_I2C(("error while sending message(s). starting again.\n"));
 				break;
@@ -336,14 +336,14 @@
 			break;
 		}
 
-	        /* delay a bit before retrying */
-	        msleep(10);
+		/* delay a bit before retrying */
+		msleep(10);
 
 	} while (err != num && retries--);
 
-        /* if every retry had an address error, exit right away */
-        if (address_err == retries) {
-	        goto out;
+	/* if every retry had an address error, exit right away */
+	if (address_err == retries) {
+		goto out;
 	}
 
 	/* if any things had to be read, get the results */
diff -urN linux-2.6.15-rc5/drivers/media/common/saa7146_vbi.c linux-2.6.15-rc6/drivers/media/common/saa7146_vbi.c
--- linux-2.6.15-rc5/drivers/media/common/saa7146_vbi.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/media/common/saa7146_vbi.c	2005-12-18 22:28:03.884022585 -0800
@@ -6,8 +6,8 @@
 {
 	struct saa7146_vv *vv = dev->vv_data;
 
-        u32          *cpu;
-        dma_addr_t   dma_addr;
+	u32          *cpu;
+	dma_addr_t   dma_addr;
 
 	int count = 0;
 	int i;
diff -urN linux-2.6.15-rc5/drivers/media/common/saa7146_video.c linux-2.6.15-rc6/drivers/media/common/saa7146_video.c
--- linux-2.6.15-rc5/drivers/media/common/saa7146_video.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/media/common/saa7146_video.c	2005-12-18 22:28:03.885022629 -0800
@@ -150,23 +150,23 @@
 	maxh  = vv->standard->v_max_out;
 
 	if (V4L2_FIELD_ANY == field) {
-                field = (win->w.height > maxh/2)
-                        ? V4L2_FIELD_INTERLACED
-                        : V4L2_FIELD_TOP;
-	        }
-        switch (field) {
-        case V4L2_FIELD_TOP:
-        case V4L2_FIELD_BOTTOM:
-        case V4L2_FIELD_ALTERNATE:
-                maxh = maxh / 2;
-                break;
-        case V4L2_FIELD_INTERLACED:
-                break;
-        default: {
+		field = (win->w.height > maxh/2)
+		        ? V4L2_FIELD_INTERLACED
+		        : V4L2_FIELD_TOP;
+		}
+	switch (field) {
+	case V4L2_FIELD_TOP:
+	case V4L2_FIELD_BOTTOM:
+	case V4L2_FIELD_ALTERNATE:
+		maxh = maxh / 2;
+		break;
+	case V4L2_FIELD_INTERLACED:
+		break;
+	default: {
 		DEB_D(("no known field mode '%d'.\n",field));
-                return -EINVAL;
+		return -EINVAL;
+	}
 	}
-        }
 
 	win->field = field;
 	if (win->w.width > maxw)
@@ -887,7 +887,7 @@
 
 		DEB_EE(("VIDIOC_QUERYCAP\n"));
 
-                strcpy(cap->driver, "saa7146 v4l2");
+		strcpy(cap->driver, "saa7146 v4l2");
 		strlcpy(cap->card, dev->ext->name, sizeof(cap->card));
 		sprintf(cap->bus_info,"PCI:%s", pci_name(dev->pci));
 		cap->version = SAA7146_VERSION_CODE;
@@ -1011,19 +1011,19 @@
 		err = set_control(fh,arg);
 		return err;
 	}
-        case VIDIOC_G_PARM:
-        {
-                struct v4l2_streamparm *parm = arg;
+	case VIDIOC_G_PARM:
+	{
+		struct v4l2_streamparm *parm = arg;
 		if( parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE ) {
 			return -EINVAL;
 		}
-                memset(&parm->parm.capture,0,sizeof(struct v4l2_captureparm));
+		memset(&parm->parm.capture,0,sizeof(struct v4l2_captureparm));
 		parm->parm.capture.readbuffers = 1;
 		// fixme: only for PAL!
 		parm->parm.capture.timeperframe.numerator = 1;
 		parm->parm.capture.timeperframe.denominator = 25;
-                return 0;
-        }
+		return 0;
+	}
 	case VIDIOC_G_FMT:
 	{
 		struct v4l2_format *f = arg;
@@ -1383,7 +1383,7 @@
 
 static void video_init(struct saa7146_dev *dev, struct saa7146_vv *vv)
 {
-        INIT_LIST_HEAD(&vv->video_q.queue);
+	INIT_LIST_HEAD(&vv->video_q.queue);
 
 	init_timer(&vv->video_q.timeout);
 	vv->video_q.timeout.function = saa7146_buffer_timeout;
diff -urN linux-2.6.15-rc5/drivers/media/dvb/b2c2/flexcop-common.h linux-2.6.15-rc6/drivers/media/dvb/b2c2/flexcop-common.h
--- linux-2.6.15-rc5/drivers/media/dvb/b2c2/flexcop-common.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/media/dvb/b2c2/flexcop-common.h	2005-12-18 22:28:03.885022629 -0800
@@ -132,7 +132,7 @@
  * I2C-channel of the flexcop.
  */
 int flexcop_i2c_request(struct flexcop_device*, flexcop_access_op_t,
-		        flexcop_i2c_port_t, u8 chipaddr, u8 addr, u8 *buf, u16 len);
+			flexcop_i2c_port_t, u8 chipaddr, u8 addr, u8 *buf, u16 len);
 
 /* from flexcop-sram.c */
 int flexcop_sram_set_dest(struct flexcop_device *fc, flexcop_sram_dest_t dest, flexcop_sram_dest_target_t target);
diff -urN linux-2.6.15-rc5/drivers/media/dvb/b2c2/flexcop-fe-tuner.c linux-2.6.15-rc6/drivers/media/dvb/b2c2/flexcop-fe-tuner.c
--- linux-2.6.15-rc5/drivers/media/dvb/b2c2/flexcop-fe-tuner.c	2005-12-18 22:27:55.037628432 -0800
+++ linux-2.6.15-rc6/drivers/media/dvb/b2c2/flexcop-fe-tuner.c	2005-12-18 22:28:03.886022674 -0800
@@ -298,7 +298,7 @@
 }
 
 static int lgdt3303_pll_set(struct dvb_frontend* fe,
-                            struct dvb_frontend_parameters* params)
+		            struct dvb_frontend_parameters* params)
 {
 	struct flexcop_device *fc = fe->dvb->priv;
 	u8 buf[4];
@@ -332,7 +332,7 @@
 			return -EREMOTEIO;
 	}
 
-        return 0;
+	return 0;
 }
 
 static struct lgdt330x_config air2pc_atsc_hd5000_config = {
diff -urN linux-2.6.15-rc5/drivers/media/dvb/bt8xx/dst_ca.c linux-2.6.15-rc6/drivers/media/dvb/bt8xx/dst_ca.c
--- linux-2.6.15-rc5/drivers/media/dvb/bt8xx/dst_ca.c	2005-12-18 22:27:55.040628565 -0800
+++ linux-2.6.15-rc6/drivers/media/dvb/bt8xx/dst_ca.c	2005-12-18 22:28:03.889022808 -0800
@@ -406,7 +406,7 @@
 	}
 	dprintk(verbose, DST_CA_DEBUG, 1, " ");
 
-	if (copy_from_user(p_ca_message, (void *)arg, sizeof (struct ca_msg))) {
+	if (copy_from_user(p_ca_message, arg, sizeof (struct ca_msg))) {
 		result = -EFAULT;
 		goto free_mem_and_exit;
 	}
@@ -579,7 +579,7 @@
 	return 0;
 }
 
-static int dst_ca_read(struct file *file, char __user *buffer, size_t length, loff_t *offset)
+static ssize_t dst_ca_read(struct file *file, char __user *buffer, size_t length, loff_t *offset)
 {
 	int bytes_read = 0;
 
@@ -588,7 +588,7 @@
 	return bytes_read;
 }
 
-static int dst_ca_write(struct file *file, const char __user *buffer, size_t length, loff_t *offset)
+static ssize_t dst_ca_write(struct file *file, const char __user *buffer, size_t length, loff_t *offset)
 {
 	dprintk(verbose, DST_CA_DEBUG, 1, " Device write.");
 
diff -urN linux-2.6.15-rc5/drivers/media/dvb/bt8xx/dvb-bt8xx.c linux-2.6.15-rc6/drivers/media/dvb/bt8xx/dvb-bt8xx.c
--- linux-2.6.15-rc5/drivers/media/dvb/bt8xx/dvb-bt8xx.c	2005-12-18 22:27:55.042628654 -0800
+++ linux-2.6.15-rc6/drivers/media/dvb/bt8xx/dvb-bt8xx.c	2005-12-18 22:28:03.890022852 -0800
@@ -556,9 +556,9 @@
 	dprintk("%s: tuner at 0x%02x bytes: 0x%02x 0x%02x 0x%02x 0x%02x\n",
 		__FUNCTION__, msg.addr, buf[0],buf[1],buf[2],buf[3]);
 	if ((err = i2c_transfer(card->i2c_adapter, &msg, 1)) != 1) {
-	        printk(KERN_WARNING "dvb-bt8xx: %s error "
-		        "(addr %02x <- %02x, err = %i)\n",
-		        __FUNCTION__, buf[0], buf[1], err);
+		printk(KERN_WARNING "dvb-bt8xx: %s error "
+			"(addr %02x <- %02x, err = %i)\n",
+			__FUNCTION__, buf[0], buf[1], err);
 		if (err < 0)
 			return err;
 		else
diff -urN linux-2.6.15-rc5/drivers/media/dvb/dvb-core/demux.h linux-2.6.15-rc6/drivers/media/dvb/dvb-core/demux.h
--- linux-2.6.15-rc5/drivers/media/dvb/dvb-core/demux.h	2005-12-18 22:27:55.043628699 -0800
+++ linux-2.6.15-rc6/drivers/media/dvb/dvb-core/demux.h	2005-12-18 22:28:03.892022941 -0800
@@ -86,25 +86,25 @@
 
 enum dmx_ts_pes
 {  /* also send packets to decoder (if it exists) */
-        DMX_TS_PES_AUDIO0,
+	DMX_TS_PES_AUDIO0,
 	DMX_TS_PES_VIDEO0,
 	DMX_TS_PES_TELETEXT0,
 	DMX_TS_PES_SUBTITLE0,
 	DMX_TS_PES_PCR0,
 
-        DMX_TS_PES_AUDIO1,
+	DMX_TS_PES_AUDIO1,
 	DMX_TS_PES_VIDEO1,
 	DMX_TS_PES_TELETEXT1,
 	DMX_TS_PES_SUBTITLE1,
 	DMX_TS_PES_PCR1,
 
-        DMX_TS_PES_AUDIO2,
+	DMX_TS_PES_AUDIO2,
 	DMX_TS_PES_VIDEO2,
 	DMX_TS_PES_TELETEXT2,
 	DMX_TS_PES_SUBTITLE2,
 	DMX_TS_PES_PCR2,
 
-        DMX_TS_PES_AUDIO3,
+	DMX_TS_PES_AUDIO3,
 	DMX_TS_PES_VIDEO3,
 	DMX_TS_PES_TELETEXT3,
 	DMX_TS_PES_SUBTITLE3,
@@ -121,17 +121,17 @@
 
 
 struct dmx_ts_feed {
-        int is_filtering; /* Set to non-zero when filtering in progress */
-        struct dmx_demux *parent; /* Back-pointer */
-        void *priv; /* Pointer to private data of the API client */
-        int (*set) (struct dmx_ts_feed *feed,
+	int is_filtering; /* Set to non-zero when filtering in progress */
+	struct dmx_demux *parent; /* Back-pointer */
+	void *priv; /* Pointer to private data of the API client */
+	int (*set) (struct dmx_ts_feed *feed,
 		    u16 pid,
 		    int type,
 		    enum dmx_ts_pes pes_type,
 		    size_t circular_buffer_size,
 		    struct timespec timeout);
-        int (*start_filtering) (struct dmx_ts_feed* feed);
-        int (*stop_filtering) (struct dmx_ts_feed* feed);
+	int (*start_filtering) (struct dmx_ts_feed* feed);
+	int (*stop_filtering) (struct dmx_ts_feed* feed);
 };
 
 /*--------------------------------------------------------------------------*/
@@ -139,35 +139,35 @@
 /*--------------------------------------------------------------------------*/
 
 struct dmx_section_filter {
-        u8 filter_value [DMX_MAX_FILTER_SIZE];
-        u8 filter_mask [DMX_MAX_FILTER_SIZE];
-        u8 filter_mode [DMX_MAX_FILTER_SIZE];
-        struct dmx_section_feed* parent; /* Back-pointer */
-        void* priv; /* Pointer to private data of the API client */
+	u8 filter_value [DMX_MAX_FILTER_SIZE];
+	u8 filter_mask [DMX_MAX_FILTER_SIZE];
+	u8 filter_mode [DMX_MAX_FILTER_SIZE];
+	struct dmx_section_feed* parent; /* Back-pointer */
+	void* priv; /* Pointer to private data of the API client */
 };
 
 struct dmx_section_feed {
-        int is_filtering; /* Set to non-zero when filtering in progress */
-        struct dmx_demux* parent; /* Back-pointer */
-        void* priv; /* Pointer to private data of the API client */
+	int is_filtering; /* Set to non-zero when filtering in progress */
+	struct dmx_demux* parent; /* Back-pointer */
+	void* priv; /* Pointer to private data of the API client */
 
-        int check_crc;
+	int check_crc;
 	u32 crc_val;
 
-        u8 *secbuf;
-        u8 secbuf_base[DMX_MAX_SECFEED_SIZE];
-        u16 secbufp, seclen, tsfeedp;
+	u8 *secbuf;
+	u8 secbuf_base[DMX_MAX_SECFEED_SIZE];
+	u16 secbufp, seclen, tsfeedp;
 
-        int (*set) (struct dmx_section_feed* feed,
+	int (*set) (struct dmx_section_feed* feed,
 		    u16 pid,
 		    size_t circular_buffer_size,
 		    int check_crc);
-        int (*allocate_filter) (struct dmx_section_feed* feed,
+	int (*allocate_filter) (struct dmx_section_feed* feed,
 				struct dmx_section_filter** filter);
-        int (*release_filter) (struct dmx_section_feed* feed,
+	int (*release_filter) (struct dmx_section_feed* feed,
 			       struct dmx_section_filter* filter);
-        int (*start_filtering) (struct dmx_section_feed* feed);
-        int (*stop_filtering) (struct dmx_section_feed* feed);
+	int (*start_filtering) (struct dmx_section_feed* feed);
+	int (*stop_filtering) (struct dmx_section_feed* feed);
 };
 
 /*--------------------------------------------------------------------------*/
@@ -205,10 +205,10 @@
 };
 
 struct dmx_frontend {
-        struct list_head connectivity_list; /* List of front-ends that can
+	struct list_head connectivity_list; /* List of front-ends that can
 					       be connected to a particular
 					       demux */
-        enum dmx_frontend_source source;
+	enum dmx_frontend_source source;
 };
 
 /*--------------------------------------------------------------------------*/
@@ -240,38 +240,38 @@
 #define DMX_FE_ENTRY(list) list_entry(list, struct dmx_frontend, connectivity_list)
 
 struct dmx_demux {
-        u32 capabilities;            /* Bitfield of capability flags */
-        struct dmx_frontend* frontend;    /* Front-end connected to the demux */
-        void* priv;                  /* Pointer to private data of the API client */
-        int (*open) (struct dmx_demux* demux);
-        int (*close) (struct dmx_demux* demux);
-        int (*write) (struct dmx_demux* demux, const char* buf, size_t count);
-        int (*allocate_ts_feed) (struct dmx_demux* demux,
+	u32 capabilities;            /* Bitfield of capability flags */
+	struct dmx_frontend* frontend;    /* Front-end connected to the demux */
+	void* priv;                  /* Pointer to private data of the API client */
+	int (*open) (struct dmx_demux* demux);
+	int (*close) (struct dmx_demux* demux);
+	int (*write) (struct dmx_demux* demux, const char* buf, size_t count);
+	int (*allocate_ts_feed) (struct dmx_demux* demux,
 				 struct dmx_ts_feed** feed,
 				 dmx_ts_cb callback);
-        int (*release_ts_feed) (struct dmx_demux* demux,
+	int (*release_ts_feed) (struct dmx_demux* demux,
 				struct dmx_ts_feed* feed);
-        int (*allocate_section_feed) (struct dmx_demux* demux,
+	int (*allocate_section_feed) (struct dmx_demux* demux,
 				      struct dmx_section_feed** feed,
 				      dmx_section_cb callback);
-        int (*release_section_feed) (struct dmx_demux* demux,
+	int (*release_section_feed) (struct dmx_demux* demux,
 				     struct dmx_section_feed* feed);
-        int (*add_frontend) (struct dmx_demux* demux,
+	int (*add_frontend) (struct dmx_demux* demux,
 			     struct dmx_frontend* frontend);
-        int (*remove_frontend) (struct dmx_demux* demux,
+	int (*remove_frontend) (struct dmx_demux* demux,
 				struct dmx_frontend* frontend);
-        struct list_head* (*get_frontends) (struct dmx_demux* demux);
-        int (*connect_frontend) (struct dmx_demux* demux,
+	struct list_head* (*get_frontends) (struct dmx_demux* demux);
+	int (*connect_frontend) (struct dmx_demux* demux,
 				 struct dmx_frontend* frontend);
-        int (*disconnect_frontend) (struct dmx_demux* demux);
+	int (*disconnect_frontend) (struct dmx_demux* demux);
 
-        int (*get_pes_pids) (struct dmx_demux* demux, u16 *pids);
+	int (*get_pes_pids) (struct dmx_demux* demux, u16 *pids);
 
 	int (*get_caps) (struct dmx_demux* demux, struct dmx_caps *caps);
 
 	int (*set_source) (struct dmx_demux* demux, const dmx_source_t *src);
 
-        int (*get_stc) (struct dmx_demux* demux, unsigned int num,
+	int (*get_stc) (struct dmx_demux* demux, unsigned int num,
 			u64 *stc, unsigned int *base);
 };
 
diff -urN linux-2.6.15-rc5/drivers/media/dvb/dvb-core/dmxdev.c linux-2.6.15-rc6/drivers/media/dvb/dvb-core/dmxdev.c
--- linux-2.6.15-rc5/drivers/media/dvb/dvb-core/dmxdev.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/media/dvb/dvb-core/dmxdev.c	2005-12-18 22:28:03.893022986 -0800
@@ -947,7 +947,7 @@
 
 	case DMX_GET_STC:
 		if (!dmxdev->demux->get_stc) {
-		        ret=-EINVAL;
+			ret=-EINVAL;
 			break;
 		}
 		ret = dmxdev->demux->get_stc(dmxdev->demux,
diff -urN linux-2.6.15-rc5/drivers/media/dvb/dvb-core/dmxdev.h linux-2.6.15-rc6/drivers/media/dvb/dvb-core/dmxdev.h
--- linux-2.6.15-rc5/drivers/media/dvb/dvb-core/dmxdev.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/media/dvb/dvb-core/dmxdev.h	2005-12-18 22:28:03.893022986 -0800
@@ -53,51 +53,51 @@
 };
 
 struct dmxdev_buffer {
-        u8 *data;
-        int size;
-        int pread;
-        int pwrite;
+	u8 *data;
+	int size;
+	int pread;
+	int pwrite;
 	wait_queue_head_t queue;
-        int error;
+	int error;
 };
 
 struct dmxdev_filter {
 	struct dvb_device *dvbdev;
 
-        union {
-	        struct dmx_section_filter *sec;
+	union {
+		struct dmx_section_filter *sec;
 	} filter;
 
-        union {
-                struct dmx_ts_feed *ts;
-                struct dmx_section_feed *sec;
+	union {
+		struct dmx_ts_feed *ts;
+		struct dmx_section_feed *sec;
 	} feed;
 
-        union {
-	        struct dmx_sct_filter_params sec;
-	        struct dmx_pes_filter_params pes;
+	union {
+		struct dmx_sct_filter_params sec;
+		struct dmx_pes_filter_params pes;
 	} params;
 
-        int type;
-        enum dmxdev_state state;
-        struct dmxdev *dev;
-        struct dmxdev_buffer buffer;
+	int type;
+	enum dmxdev_state state;
+	struct dmxdev *dev;
+	struct dmxdev_buffer buffer;
 
 	struct semaphore mutex;
 
-        /* only for sections */
-        struct timer_list timer;
-        int todo;
-        u8 secheader[3];
+	/* only for sections */
+	struct timer_list timer;
+	int todo;
+	u8 secheader[3];
 
-        u16 pid;
+	u16 pid;
 };
 
 
 struct dmxdev_dvr {
-        int state;
-        struct dmxdev *dev;
-        struct dmxdev_buffer buffer;
+	int state;
+	struct dmxdev *dev;
+	struct dmxdev_buffer buffer;
 };
 
 
@@ -105,16 +105,16 @@
 	struct dvb_device *dvbdev;
 	struct dvb_device *dvr_dvbdev;
 
-        struct dmxdev_filter *filter;
-        struct dmxdev_dvr *dvr;
-        struct dmx_demux *demux;
+	struct dmxdev_filter *filter;
+	struct dmxdev_dvr *dvr;
+	struct dmx_demux *demux;
 
-        int filternum;
-        int capabilities;
+	int filternum;
+	int capabilities;
 #define DMXDEV_CAP_DUPLEX 1
-        struct dmx_frontend *dvr_orig_fe;
+	struct dmx_frontend *dvr_orig_fe;
 
-        struct dmxdev_buffer dvr_buffer;
+	struct dmxdev_buffer dvr_buffer;
 #define DVR_BUFFER_SIZE (10*188*1024)
 
 	struct semaphore mutex;
diff -urN linux-2.6.15-rc5/drivers/media/dvb/dvb-core/dvb_ca_en50221.c linux-2.6.15-rc6/drivers/media/dvb/dvb-core/dvb_ca_en50221.c
--- linux-2.6.15-rc5/drivers/media/dvb/dvb-core/dvb_ca_en50221.c	2005-12-18 22:27:55.044628744 -0800
+++ linux-2.6.15-rc6/drivers/media/dvb/dvb-core/dvb_ca_en50221.c	2005-12-18 22:28:03.894023030 -0800
@@ -498,7 +498,7 @@
 	/* process the CFTABLE_ENTRY tuples, and any after those */
 	while ((!end_chain) && (address < 0x1000)) {
 		if ((status = dvb_ca_en50221_read_tuple(ca, slot, &address, &tupleType,
-						        &tupleLength, tuple)) < 0)
+							&tupleLength, tuple)) < 0)
 			return status;
 		switch (tupleType) {
 		case 0x1B:	// CISTPL_CFTABLE_ENTRY
diff -urN linux-2.6.15-rc5/drivers/media/dvb/dvb-core/dvb_filter.c linux-2.6.15-rc6/drivers/media/dvb/dvb-core/dvb_filter.c
--- linux-2.6.15-rc5/drivers/media/dvb/dvb-core/dvb_filter.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/media/dvb/dvb-core/dvb_filter.c	2005-12-18 22:28:03.896023119 -0800
@@ -72,12 +72,12 @@
 	u8 pct;
 
 	if (pr) printk( "Pic header: ");
-        pic->temporal_reference[field] = (( headr[0] << 2 ) |
+	pic->temporal_reference[field] = (( headr[0] << 2 ) |
 					  (headr[1] & 0x03) )& 0x03ff;
 	if (pr) printk( " temp ref: 0x%04x", pic->temporal_reference[field]);
 
 	pct = ( headr[1] >> 2 ) & 0x07;
-        pic->picture_coding_type[field] = pct;
+	pic->picture_coding_type[field] = pct;
 	if (pr) {
 		switch(pct){
 			case I_FRAME:
@@ -93,17 +93,17 @@
 	}
 
 
-        pic->vinfo.vbv_delay  = (( headr[1] >> 5 ) | ( headr[2] << 3) |
+	pic->vinfo.vbv_delay  = (( headr[1] >> 5 ) | ( headr[2] << 3) |
 				 ( (headr[3] & 0x1F) << 11) ) & 0xffff;
 
 	if (pr) printk( " vbv delay: 0x%04x", pic->vinfo.vbv_delay);
 
-        pic->picture_header_parameter = ( headr[3] & 0xe0 ) |
+	pic->picture_header_parameter = ( headr[3] & 0xe0 ) |
 		((headr[4] & 0x80) >> 3);
 
-        if ( pct == B_FRAME ){
-                pic->picture_header_parameter |= ( headr[4] >> 3 ) & 0x0f;
-        }
+	if ( pct == B_FRAME ){
+		pic->picture_header_parameter |= ( headr[4] >> 3 ) & 0x0f;
+	}
 	if (pr) printk( " pic head param: 0x%x",
 			pic->picture_header_parameter);
 
@@ -124,18 +124,18 @@
 		       ((headr[0]<<4)& 0x30)| ((headr[1]>>4)& 0x0F),
 		       ((headr[1]<<3)& 0x38)| ((headr[2]>>5)& 0x0F));
 
-        if ( ( headr[3] & 0x40 ) != 0 ){
-                pic->closed_gop = 1;
-        } else {
-                pic->closed_gop = 0;
-        }
+	if ( ( headr[3] & 0x40 ) != 0 ){
+		pic->closed_gop = 1;
+	} else {
+		pic->closed_gop = 0;
+	}
 	if (pr) printk("closed: %d", pic->closed_gop);
 
-        if ( ( headr[3] & 0x20 ) != 0 ){
-                pic->broken_link = 1;
-        } else {
-                pic->broken_link = 0;
-        }
+	if ( ( headr[3] & 0x20 ) != 0 ){
+		pic->broken_link = 1;
+	} else {
+		pic->broken_link = 0;
+	}
 	if (pr) printk(" broken: %d\n", pic->broken_link);
 
 	return 0;
@@ -146,7 +146,7 @@
 /* needs 8 byte input */
 static int read_sequence_header(u8 *headr, struct dvb_video_info *vi, int pr)
 {
-        int sw;
+	int sw;
 	int form = -1;
 
 	if (pr) printk("Reading sequence header\n");
@@ -154,9 +154,9 @@
 	vi->horizontal_size	= ((headr[1] &0xF0) >> 4) | (headr[0] << 4);
 	vi->vertical_size	= ((headr[1] &0x0F) << 8) | (headr[2]);
 
-        sw = (int)((headr[3]&0xF0) >> 4) ;
+	sw = (int)((headr[3]&0xF0) >> 4) ;
 
-        switch( sw ){
+	switch( sw ){
 	case 1:
 		if (pr)
 			printk("Videostream: ASPECT: 1:1");
@@ -165,84 +165,84 @@
 	case 2:
 		if (pr)
 			printk("Videostream: ASPECT: 4:3");
-                vi->aspect_ratio = 133;
+		vi->aspect_ratio = 133;
 		break;
 	case 3:
 		if (pr)
 			printk("Videostream: ASPECT: 16:9");
-                vi->aspect_ratio = 177;
+		vi->aspect_ratio = 177;
 		break;
 	case 4:
 		if (pr)
 			printk("Videostream: ASPECT: 2.21:1");
-                vi->aspect_ratio = 221;
+		vi->aspect_ratio = 221;
 		break;
 
-        case 5 ... 15:
+	case 5 ... 15:
 		if (pr)
 			printk("Videostream: ASPECT: reserved");
-                vi->aspect_ratio = 0;
+		vi->aspect_ratio = 0;
 		break;
 
-        default:
-                vi->aspect_ratio = 0;
-                return -1;
+	default:
+		vi->aspect_ratio = 0;
+		return -1;
 	}
 
 	if (pr)
 		printk("  Size = %dx%d",vi->horizontal_size,vi->vertical_size);
 
-        sw = (int)(headr[3]&0x0F);
+	sw = (int)(headr[3]&0x0F);
 
-        switch ( sw ) {
+	switch ( sw ) {
 	case 1:
 		if (pr)
 			printk("  FRate: 23.976 fps");
-                vi->framerate = 23976;
+		vi->framerate = 23976;
 		form = -1;
 		break;
 	case 2:
 		if (pr)
 			printk("  FRate: 24 fps");
-                vi->framerate = 24000;
+		vi->framerate = 24000;
 		form = -1;
 		break;
 	case 3:
 		if (pr)
 			printk("  FRate: 25 fps");
-                vi->framerate = 25000;
+		vi->framerate = 25000;
 		form = VIDEO_MODE_PAL;
 		break;
 	case 4:
 		if (pr)
 			printk("  FRate: 29.97 fps");
-                vi->framerate = 29970;
+		vi->framerate = 29970;
 		form = VIDEO_MODE_NTSC;
 		break;
 	case 5:
 		if (pr)
 			printk("  FRate: 30 fps");
-                vi->framerate = 30000;
+		vi->framerate = 30000;
 		form = VIDEO_MODE_NTSC;
 		break;
 	case 6:
 		if (pr)
 			printk("  FRate: 50 fps");
-                vi->framerate = 50000;
+		vi->framerate = 50000;
 		form = VIDEO_MODE_PAL;
 		break;
 	case 7:
 		if (pr)
 			printk("  FRate: 60 fps");
-                vi->framerate = 60000;
+		vi->framerate = 60000;
 		form = VIDEO_MODE_NTSC;
 		break;
 	}
 
 	vi->bit_rate = (headr[4] << 10) | (headr[5] << 2) | (headr[6] & 0x03);
 
-        vi->vbv_buffer_size
-                = (( headr[6] & 0xF8) >> 3 ) | (( headr[7] & 0x1F )<< 5);
+	vi->vbv_buffer_size
+		= (( headr[6] & 0xF8) >> 3 ) | (( headr[7] & 0x1F )<< 5);
 
 	if (pr){
 		printk("  BRate: %d Mbit/s",4*(vi->bit_rate)/10000);
@@ -250,7 +250,7 @@
 		printk("\n");
 	}
 
-        vi->video_format = form;
+	vi->video_format = form;
 
 	return 0;
 }
@@ -308,7 +308,7 @@
 	if (!found) return -1;
 
 	if (c+3 >= count) return -1;
-        headr = mbuf+c;
+	headr = mbuf+c;
 
 	ai->layer = (headr[1] & 0x06) >> 1;
 
@@ -368,7 +368,7 @@
 	if (c+5 >= count) return -1;
 
 	ai->layer = 0;  // 0 for AC3
-        headr = mbuf+c+2;
+	headr = mbuf+c+2;
 
 	frame = (headr[2]&0x3f);
 	ai->bit_rate = ac3_bitrates[frame >> 1]*1000;
@@ -396,159 +396,159 @@
 #if 0
 static u8 *skip_pes_header(u8 **bufp)
 {
-        u8 *inbuf = *bufp;
-        u8 *buf = inbuf;
-        u8 *pts = NULL;
-        int skip = 0;
+	u8 *inbuf = *bufp;
+	u8 *buf = inbuf;
+	u8 *pts = NULL;
+	int skip = 0;
 
 	static const int mpeg1_skip_table[16] = {
 		1, 0xffff,      5,     10, 0xffff, 0xffff, 0xffff, 0xffff,
-	        0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff
+		0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff
 	};
 
 
-        if ((inbuf[6] & 0xc0) == 0x80){ /* mpeg2 */
-                if (buf[7] & PTS_ONLY)
-                        pts = buf+9;
-                else pts = NULL;
-                buf = inbuf + 9 + inbuf[8];
-        } else {        /* mpeg1 */
-                for (buf = inbuf + 6; *buf == 0xff; buf++)
-                        if (buf == inbuf + 6 + 16) {
-                                break;
-                        }
-                if ((*buf & 0xc0) == 0x40)
-                        buf += 2;
-                skip = mpeg1_skip_table [*buf >> 4];
-                if (skip == 5 || skip == 10) pts = buf;
-                else pts = NULL;
+	if ((inbuf[6] & 0xc0) == 0x80){ /* mpeg2 */
+		if (buf[7] & PTS_ONLY)
+		        pts = buf+9;
+		else pts = NULL;
+		buf = inbuf + 9 + inbuf[8];
+	} else {        /* mpeg1 */
+		for (buf = inbuf + 6; *buf == 0xff; buf++)
+		        if (buf == inbuf + 6 + 16) {
+		                break;
+		        }
+		if ((*buf & 0xc0) == 0x40)
+		        buf += 2;
+		skip = mpeg1_skip_table [*buf >> 4];
+		if (skip == 5 || skip == 10) pts = buf;
+		else pts = NULL;
 
-                buf += mpeg1_skip_table [*buf >> 4];
-        }
+		buf += mpeg1_skip_table [*buf >> 4];
+	}
 
-        *bufp = buf;
-        return pts;
+	*bufp = buf;
+	return pts;
 }
 #endif
 
 #if 0
 static void initialize_quant_matrix( u32 *matrix )
 {
-        int i;
+	int i;
 
-        matrix[0]  = 0x08101013;
-        matrix[1]  = 0x10131616;
-        matrix[2]  = 0x16161616;
-        matrix[3]  = 0x1a181a1b;
-        matrix[4]  = 0x1b1b1a1a;
-        matrix[5]  = 0x1a1a1b1b;
-        matrix[6]  = 0x1b1d1d1d;
-        matrix[7]  = 0x2222221d;
-        matrix[8]  = 0x1d1d1b1b;
-        matrix[9]  = 0x1d1d2020;
-        matrix[10] = 0x22222526;
-        matrix[11] = 0x25232322;
-        matrix[12] = 0x23262628;
-        matrix[13] = 0x28283030;
-        matrix[14] = 0x2e2e3838;
-        matrix[15] = 0x3a454553;
+	matrix[0]  = 0x08101013;
+	matrix[1]  = 0x10131616;
+	matrix[2]  = 0x16161616;
+	matrix[3]  = 0x1a181a1b;
+	matrix[4]  = 0x1b1b1a1a;
+	matrix[5]  = 0x1a1a1b1b;
+	matrix[6]  = 0x1b1d1d1d;
+	matrix[7]  = 0x2222221d;
+	matrix[8]  = 0x1d1d1b1b;
+	matrix[9]  = 0x1d1d2020;
+	matrix[10] = 0x22222526;
+	matrix[11] = 0x25232322;
+	matrix[12] = 0x23262628;
+	matrix[13] = 0x28283030;
+	matrix[14] = 0x2e2e3838;
+	matrix[15] = 0x3a454553;
 
-        for ( i = 16 ; i < 32 ; i++ )
-                matrix[i] = 0x10101010;
+	for ( i = 16 ; i < 32 ; i++ )
+		matrix[i] = 0x10101010;
 }
 #endif
 
 #if 0
 static void initialize_mpg_picture(struct mpg_picture *pic)
 {
-        int i;
+	int i;
 
-        /* set MPEG1 */
-        pic->mpeg1_flag = 1;
-        pic->profile_and_level = 0x4A ;        /* MP@LL */
-        pic->progressive_sequence = 1;
-        pic->low_delay = 0;
-
-        pic->sequence_display_extension_flag = 0;
-        for ( i = 0 ; i < 4 ; i++ ){
-                pic->frame_centre_horizontal_offset[i] = 0;
-                pic->frame_centre_vertical_offset[i] = 0;
-        }
-        pic->last_frame_centre_horizontal_offset = 0;
-        pic->last_frame_centre_vertical_offset = 0;
-
-        pic->picture_display_extension_flag[0] = 0;
-        pic->picture_display_extension_flag[1] = 0;
-        pic->sequence_header_flag = 0;
+	/* set MPEG1 */
+	pic->mpeg1_flag = 1;
+	pic->profile_and_level = 0x4A ;        /* MP@LL */
+	pic->progressive_sequence = 1;
+	pic->low_delay = 0;
+
+	pic->sequence_display_extension_flag = 0;
+	for ( i = 0 ; i < 4 ; i++ ){
+		pic->frame_centre_horizontal_offset[i] = 0;
+		pic->frame_centre_vertical_offset[i] = 0;
+	}
+	pic->last_frame_centre_horizontal_offset = 0;
+	pic->last_frame_centre_vertical_offset = 0;
+
+	pic->picture_display_extension_flag[0] = 0;
+	pic->picture_display_extension_flag[1] = 0;
+	pic->sequence_header_flag = 0;
 	pic->gop_flag = 0;
-        pic->sequence_end_flag = 0;
+	pic->sequence_end_flag = 0;
 }
 #endif
 
 #if 0
 static void mpg_set_picture_parameter( int32_t field_type, struct mpg_picture *pic )
 {
-        int16_t last_h_offset;
-        int16_t last_v_offset;
+	int16_t last_h_offset;
+	int16_t last_v_offset;
 
-        int16_t *p_h_offset;
-        int16_t *p_v_offset;
+	int16_t *p_h_offset;
+	int16_t *p_v_offset;
 
-        if ( pic->mpeg1_flag ){
-                pic->picture_structure[field_type] = VIDEO_FRAME_PICTURE;
-                pic->top_field_first = 0;
-                pic->repeat_first_field = 0;
-                pic->progressive_frame = 1;
-                pic->picture_coding_parameter = 0x000010;
-        }
-
-        /* Reset flag */
-        pic->picture_display_extension_flag[field_type] = 0;
-
-        last_h_offset = pic->last_frame_centre_horizontal_offset;
-        last_v_offset = pic->last_frame_centre_vertical_offset;
-        if ( field_type == FIRST_FIELD ){
-                p_h_offset = pic->frame_centre_horizontal_offset;
-                p_v_offset = pic->frame_centre_vertical_offset;
-                *p_h_offset = last_h_offset;
-                *(p_h_offset + 1) = last_h_offset;
-                *(p_h_offset + 2) = last_h_offset;
-                *p_v_offset = last_v_offset;
-                *(p_v_offset + 1) = last_v_offset;
-                *(p_v_offset + 2) = last_v_offset;
-        } else {
-                pic->frame_centre_horizontal_offset[3] = last_h_offset;
-                pic->frame_centre_vertical_offset[3] = last_v_offset;
-        }
+	if ( pic->mpeg1_flag ){
+		pic->picture_structure[field_type] = VIDEO_FRAME_PICTURE;
+		pic->top_field_first = 0;
+		pic->repeat_first_field = 0;
+		pic->progressive_frame = 1;
+		pic->picture_coding_parameter = 0x000010;
+	}
+
+	/* Reset flag */
+	pic->picture_display_extension_flag[field_type] = 0;
+
+	last_h_offset = pic->last_frame_centre_horizontal_offset;
+	last_v_offset = pic->last_frame_centre_vertical_offset;
+	if ( field_type == FIRST_FIELD ){
+		p_h_offset = pic->frame_centre_horizontal_offset;
+		p_v_offset = pic->frame_centre_vertical_offset;
+		*p_h_offset = last_h_offset;
+		*(p_h_offset + 1) = last_h_offset;
+		*(p_h_offset + 2) = last_h_offset;
+		*p_v_offset = last_v_offset;
+		*(p_v_offset + 1) = last_v_offset;
+		*(p_v_offset + 2) = last_v_offset;
+	} else {
+		pic->frame_centre_horizontal_offset[3] = last_h_offset;
+		pic->frame_centre_vertical_offset[3] = last_v_offset;
+	}
 }
 #endif
 
 #if 0
 static void init_mpg_picture( struct mpg_picture *pic, int chan, int32_t field_type)
 {
-        pic->picture_header = 0;
-        pic->sequence_header_data
-                = ( INIT_HORIZONTAL_SIZE << 20 )
-                        | ( INIT_VERTICAL_SIZE << 8 )
-                        | ( INIT_ASPECT_RATIO << 4 )
-                        | ( INIT_FRAME_RATE );
-        pic->mpeg1_flag = 0;
-        pic->vinfo.horizontal_size
-                = INIT_DISP_HORIZONTAL_SIZE;
-        pic->vinfo.vertical_size
-                = INIT_DISP_VERTICAL_SIZE;
-        pic->picture_display_extension_flag[field_type]
-                = 0;
-        pic->pts_flag[field_type] = 0;
-
-        pic->sequence_gop_header = 0;
-        pic->picture_header = 0;
-        pic->sequence_header_flag = 0;
-        pic->gop_flag = 0;
-        pic->sequence_end_flag = 0;
-        pic->sequence_display_extension_flag = 0;
-        pic->last_frame_centre_horizontal_offset = 0;
-        pic->last_frame_centre_vertical_offset = 0;
+	pic->picture_header = 0;
+	pic->sequence_header_data
+		= ( INIT_HORIZONTAL_SIZE << 20 )
+		        | ( INIT_VERTICAL_SIZE << 8 )
+		        | ( INIT_ASPECT_RATIO << 4 )
+		        | ( INIT_FRAME_RATE );
+	pic->mpeg1_flag = 0;
+	pic->vinfo.horizontal_size
+		= INIT_DISP_HORIZONTAL_SIZE;
+	pic->vinfo.vertical_size
+		= INIT_DISP_VERTICAL_SIZE;
+	pic->picture_display_extension_flag[field_type]
+		= 0;
+	pic->pts_flag[field_type] = 0;
+
+	pic->sequence_gop_header = 0;
+	pic->picture_header = 0;
+	pic->sequence_header_flag = 0;
+	pic->gop_flag = 0;
+	pic->sequence_end_flag = 0;
+	pic->sequence_display_extension_flag = 0;
+	pic->last_frame_centre_horizontal_offset = 0;
+	pic->last_frame_centre_vertical_offset = 0;
 	pic->channel = chan;
 }
 #endif
@@ -588,11 +588,11 @@
 		buf[1]&=~0x40;
 	}
 	if (!len)
-	        return 0;
+		return 0;
 	buf[3]=0x30|((p2ts->cc++)&0x0f);
 	rest=183-len;
 	if (rest) {
-	        buf[5]=0x00;
+		buf[5]=0x00;
 		if (rest-1)
 			memset(buf+6, 0xff, rest-1);
 	}
diff -urN linux-2.6.15-rc5/drivers/media/dvb/dvb-core/dvb_filter.h linux-2.6.15-rc6/drivers/media/dvb/dvb-core/dvb_filter.h
--- linux-2.6.15-rc5/drivers/media/dvb/dvb-core/dvb_filter.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/media/dvb/dvb-core/dvb_filter.h	2005-12-18 22:28:03.897023164 -0800
@@ -29,8 +29,8 @@
 
 struct dvb_filter_pes2ts {
 	unsigned char buf[188];
-        unsigned char cc;
-        dvb_filter_pes2ts_cb_t *cb;
+	unsigned char cc;
+	dvb_filter_pes2ts_cb_t *cb;
 	void *priv;
 };
 
@@ -162,7 +162,7 @@
 	u32 bit_rate;
 	u32 comp_bit_rate;
 	u32 vbv_buffer_size;
-        s16 vbv_delay;
+	s16 vbv_delay;
 	u32 CSPF;
 	u32 off;
 };
@@ -173,60 +173,60 @@
 #define VIDEO_FRAME_PICTURE 0x03
 
 struct mpg_picture {
-        int       channel;
+	int       channel;
 	struct dvb_video_info vinfo;
-        u32      *sequence_gop_header;
-        u32      *picture_header;
-        s32       time_code;
-        int       low_delay;
-        int       closed_gop;
-        int       broken_link;
-        int       sequence_header_flag;
-        int       gop_flag;
-        int       sequence_end_flag;
-
-        u8        profile_and_level;
-        s32       picture_coding_parameter;
-        u32       matrix[32];
-        s8        matrix_change_flag;
+	u32      *sequence_gop_header;
+	u32      *picture_header;
+	s32       time_code;
+	int       low_delay;
+	int       closed_gop;
+	int       broken_link;
+	int       sequence_header_flag;
+	int       gop_flag;
+	int       sequence_end_flag;
+
+	u8        profile_and_level;
+	s32       picture_coding_parameter;
+	u32       matrix[32];
+	s8        matrix_change_flag;
 
-        u8        picture_header_parameter;
+	u8        picture_header_parameter;
   /* bit 0 - 2: bwd f code
      bit 3    : fpb vector
      bit 4 - 6: fwd f code
      bit 7    : fpf vector */
 
-        int       mpeg1_flag;
-        int       progressive_sequence;
-        int       sequence_display_extension_flag;
-        u32       sequence_header_data;
-        s16       last_frame_centre_horizontal_offset;
-        s16       last_frame_centre_vertical_offset;
-
-        u32       pts[2]; /* [0] 1st field, [1] 2nd field */
-        int       top_field_first;
-        int       repeat_first_field;
-        int       progressive_frame;
-        int       bank;
-        int       forward_bank;
-        int       backward_bank;
-        int       compress;
-        s16       frame_centre_horizontal_offset[OFF_SIZE];
-                  /* [0-2] 1st field, [3] 2nd field */
-        s16       frame_centre_vertical_offset[OFF_SIZE];
-                  /* [0-2] 1st field, [3] 2nd field */
-        s16       temporal_reference[2];
-                  /* [0] 1st field, [1] 2nd field */
-
-        s8        picture_coding_type[2];
-                  /* [0] 1st field, [1] 2nd field */
-        s8        picture_structure[2];
-                  /* [0] 1st field, [1] 2nd field */
-        s8        picture_display_extension_flag[2];
-                  /* [0] 1st field, [1] 2nd field */
-                  /* picture_display_extenion() 0:no 1:exit*/
-        s8        pts_flag[2];
-                  /* [0] 1st field, [1] 2nd field */
+	int       mpeg1_flag;
+	int       progressive_sequence;
+	int       sequence_display_extension_flag;
+	u32       sequence_header_data;
+	s16       last_frame_centre_horizontal_offset;
+	s16       last_frame_centre_vertical_offset;
+
+	u32       pts[2]; /* [0] 1st field, [1] 2nd field */
+	int       top_field_first;
+	int       repeat_first_field;
+	int       progressive_frame;
+	int       bank;
+	int       forward_bank;
+	int       backward_bank;
+	int       compress;
+	s16       frame_centre_horizontal_offset[OFF_SIZE];
+		  /* [0-2] 1st field, [3] 2nd field */
+	s16       frame_centre_vertical_offset[OFF_SIZE];
+		  /* [0-2] 1st field, [3] 2nd field */
+	s16       temporal_reference[2];
+		  /* [0] 1st field, [1] 2nd field */
+
+	s8        picture_coding_type[2];
+		  /* [0] 1st field, [1] 2nd field */
+	s8        picture_structure[2];
+		  /* [0] 1st field, [1] 2nd field */
+	s8        picture_display_extension_flag[2];
+		  /* [0] 1st field, [1] 2nd field */
+		  /* picture_display_extenion() 0:no 1:exit*/
+	s8        pts_flag[2];
+		  /* [0] 1st field, [1] 2nd field */
 };
 
 struct dvb_audio_info {
diff -urN linux-2.6.15-rc5/drivers/media/dvb/dvb-core/dvb_frontend.c linux-2.6.15-rc6/drivers/media/dvb/dvb-core/dvb_frontend.c
--- linux-2.6.15-rc5/drivers/media/dvb/dvb-core/dvb_frontend.c	2005-12-18 22:27:55.046628833 -0800
+++ linux-2.6.15-rc6/drivers/media/dvb/dvb-core/dvb_frontend.c	2005-12-18 22:28:03.897023164 -0800
@@ -372,10 +372,10 @@
 
 	snprintf (name, sizeof(name), "kdvb-fe-%i", fe->dvb->num);
 
-        lock_kernel();
-        daemonize(name);
-        sigfillset(&current->blocked);
-        unlock_kernel();
+	lock_kernel();
+	daemonize(name);
+	sigfillset(&current->blocked);
+	unlock_kernel();
 
 	fepriv->status = 0;
 	dvb_frontend_init(fe);
diff -urN linux-2.6.15-rc5/drivers/media/dvb/dvb-core/dvb_frontend.h linux-2.6.15-rc6/drivers/media/dvb/dvb-core/dvb_frontend.h
--- linux-2.6.15-rc5/drivers/media/dvb/dvb-core/dvb_frontend.h	2005-12-18 22:27:55.046628833 -0800
+++ linux-2.6.15-rc6/drivers/media/dvb/dvb-core/dvb_frontend.h	2005-12-18 22:28:03.898023209 -0800
@@ -41,10 +41,10 @@
 #include "dvbdev.h"
 
 struct dvb_frontend_tune_settings {
-        int min_delay_ms;
-        int step_size;
-        int max_drift;
-        struct dvb_frontend_parameters parameters;
+	int min_delay_ms;
+	int step_size;
+	int max_drift;
+	struct dvb_frontend_parameters parameters;
 };
 
 struct dvb_frontend;
diff -urN linux-2.6.15-rc5/drivers/media/dvb/dvb-core/dvb_net.c linux-2.6.15-rc6/drivers/media/dvb/dvb-core/dvb_net.c
--- linux-2.6.15-rc5/drivers/media/dvb/dvb-core/dvb_net.c	2005-12-18 22:27:55.047628877 -0800
+++ linux-2.6.15-rc6/drivers/media/dvb/dvb-core/dvb_net.c	2005-12-18 22:28:03.899023253 -0800
@@ -713,7 +713,7 @@
 	if (buffer1_len > 32768)
 		printk(KERN_WARNING "length > 32k: %zu.\n", buffer1_len);
 	/* printk("TS callback: %u bytes, %u TS cells @ %p.\n",
-	          buffer1_len, buffer1_len / TS_SZ, buffer1); */
+		  buffer1_len, buffer1_len / TS_SZ, buffer1); */
 	dvb_net_ule(dev, buffer1, buffer1_len);
 	return 0;
 }
@@ -721,8 +721,8 @@
 
 static void dvb_net_sec(struct net_device *dev, u8 *pkt, int pkt_len)
 {
-        u8 *eth;
-        struct sk_buff *skb;
+	u8 *eth;
+	struct sk_buff *skb;
 	struct net_device_stats *stats = &(((struct dvb_net_priv *) dev->priv)->stats);
 	int snap = 0;
 
@@ -754,7 +754,7 @@
 			return;
 		}
 		snap = 8;
-        }
+	}
 	if (pkt[7]) {
 		/* FIXME: assemble datagram from multiple sections */
 		stats->rx_errors++;
@@ -778,14 +778,14 @@
 	memcpy(eth + 14, pkt + 12 + snap, pkt_len - 12 - 4 - snap);
 
 	/* create ethernet header: */
-        eth[0]=pkt[0x0b];
-        eth[1]=pkt[0x0a];
-        eth[2]=pkt[0x09];
-        eth[3]=pkt[0x08];
-        eth[4]=pkt[0x04];
-        eth[5]=pkt[0x03];
+	eth[0]=pkt[0x0b];
+	eth[1]=pkt[0x0a];
+	eth[2]=pkt[0x09];
+	eth[3]=pkt[0x08];
+	eth[4]=pkt[0x04];
+	eth[5]=pkt[0x03];
 
-        eth[6]=eth[7]=eth[8]=eth[9]=eth[10]=eth[11]=0;
+	eth[6]=eth[7]=eth[8]=eth[9]=eth[10]=eth[11]=0;
 
 	if (snap) {
 		eth[12] = pkt[18];
@@ -807,7 +807,7 @@
 
 	stats->rx_packets++;
 	stats->rx_bytes+=skb->len;
-        netif_rx(skb);
+	netif_rx(skb);
 }
 
 static int dvb_net_sec_callback(const u8 *buffer1, size_t buffer1_len,
@@ -815,7 +815,7 @@
 		 struct dmx_section_filter *filter,
 		 enum dmx_success success)
 {
-        struct net_device *dev = filter->priv;
+	struct net_device *dev = filter->priv;
 
 	/**
 	 * we rely on the DVB API definition where exactly one complete
@@ -885,8 +885,8 @@
 {
 	int ret = 0, i;
 	struct dvb_net_priv *priv = dev->priv;
-        struct dmx_demux *demux = priv->demux;
-        unsigned char *mac = (unsigned char *) dev->dev_addr;
+	struct dmx_demux *demux = priv->demux;
+	unsigned char *mac = (unsigned char *) dev->dev_addr;
 
 	dprintk("%s: rx_mode %i\n", __FUNCTION__, priv->rx_mode);
 	down(&priv->mutex);
@@ -1129,12 +1129,12 @@
 	struct dvb_net_priv *priv = dev->priv;
 
 	priv->in_use--;
-        return dvb_net_feed_stop(dev);
+	return dvb_net_feed_stop(dev);
 }
 
 static struct net_device_stats * dvb_net_get_stats(struct net_device *dev)
 {
-        return &((struct dvb_net_priv*) dev->priv)->stats;
+	return &((struct dvb_net_priv*) dev->priv)->stats;
 }
 
 static void dvb_net_setup(struct net_device *dev)
@@ -1360,10 +1360,10 @@
 };
 
 static struct dvb_device dvbdev_net = {
-        .priv = NULL,
-        .users = 1,
-        .writers = 1,
-        .fops = &dvb_net_fops,
+	.priv = NULL,
+	.users = 1,
+	.writers = 1,
+	.fops = &dvb_net_fops,
 };
 
 
diff -urN linux-2.6.15-rc5/drivers/media/dvb/dvb-core/dvb_ringbuffer.c linux-2.6.15-rc6/drivers/media/dvb/dvb-core/dvb_ringbuffer.c
--- linux-2.6.15-rc5/drivers/media/dvb/dvb-core/dvb_ringbuffer.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/media/dvb/dvb-core/dvb_ringbuffer.c	2005-12-18 22:28:03.899023253 -0800
@@ -42,216 +42,216 @@
 
 void dvb_ringbuffer_init(struct dvb_ringbuffer *rbuf, void *data, size_t len)
 {
-        rbuf->pread=rbuf->pwrite=0;
-        rbuf->data=data;
-        rbuf->size=len;
+	rbuf->pread=rbuf->pwrite=0;
+	rbuf->data=data;
+	rbuf->size=len;
 
-        init_waitqueue_head(&rbuf->queue);
+	init_waitqueue_head(&rbuf->queue);
 
-        spin_lock_init(&(rbuf->lock));
+	spin_lock_init(&(rbuf->lock));
 }
 
 
 
 int dvb_ringbuffer_empty(struct dvb_ringbuffer *rbuf)
 {
-        return (rbuf->pread==rbuf->pwrite);
+	return (rbuf->pread==rbuf->pwrite);
 }
 
 
 
 ssize_t dvb_ringbuffer_free(struct dvb_ringbuffer *rbuf)
 {
-        ssize_t free;
+	ssize_t free;
 
-        free = rbuf->pread - rbuf->pwrite;
-        if (free <= 0)
-                free += rbuf->size;
-        return free-1;
+	free = rbuf->pread - rbuf->pwrite;
+	if (free <= 0)
+		free += rbuf->size;
+	return free-1;
 }
 
 
 
 ssize_t dvb_ringbuffer_avail(struct dvb_ringbuffer *rbuf)
 {
-        ssize_t avail;
+	ssize_t avail;
 
-        avail = rbuf->pwrite - rbuf->pread;
-        if (avail < 0)
-                avail += rbuf->size;
-        return avail;
+	avail = rbuf->pwrite - rbuf->pread;
+	if (avail < 0)
+		avail += rbuf->size;
+	return avail;
 }
 
 
 
 void dvb_ringbuffer_flush(struct dvb_ringbuffer *rbuf)
 {
-        rbuf->pread = rbuf->pwrite;
+	rbuf->pread = rbuf->pwrite;
 }
 
 
 
 void dvb_ringbuffer_flush_spinlock_wakeup(struct dvb_ringbuffer *rbuf)
 {
-        unsigned long flags;
+	unsigned long flags;
 
-        spin_lock_irqsave(&rbuf->lock, flags);
-        dvb_ringbuffer_flush(rbuf);
-        spin_unlock_irqrestore(&rbuf->lock, flags);
+	spin_lock_irqsave(&rbuf->lock, flags);
+	dvb_ringbuffer_flush(rbuf);
+	spin_unlock_irqrestore(&rbuf->lock, flags);
 
-        wake_up(&rbuf->queue);
+	wake_up(&rbuf->queue);
 }
 
 
 
 ssize_t dvb_ringbuffer_read(struct dvb_ringbuffer *rbuf, u8 *buf, size_t len, int usermem)
 {
-        size_t todo = len;
-        size_t split;
+	size_t todo = len;
+	size_t split;
 
-        split = (rbuf->pread + len > rbuf->size) ? rbuf->size - rbuf->pread : 0;
-        if (split > 0) {
-                if (!usermem)
-                        memcpy(buf, rbuf->data+rbuf->pread, split);
-                else
-                        if (copy_to_user(buf, rbuf->data+rbuf->pread, split))
-                                return -EFAULT;
-                buf += split;
-                todo -= split;
-                rbuf->pread = 0;
-        }
-        if (!usermem)
-                memcpy(buf, rbuf->data+rbuf->pread, todo);
-        else
-                if (copy_to_user(buf, rbuf->data+rbuf->pread, todo))
-                        return -EFAULT;
+	split = (rbuf->pread + len > rbuf->size) ? rbuf->size - rbuf->pread : 0;
+	if (split > 0) {
+		if (!usermem)
+		        memcpy(buf, rbuf->data+rbuf->pread, split);
+		else
+		        if (copy_to_user(buf, rbuf->data+rbuf->pread, split))
+		                return -EFAULT;
+		buf += split;
+		todo -= split;
+		rbuf->pread = 0;
+	}
+	if (!usermem)
+		memcpy(buf, rbuf->data+rbuf->pread, todo);
+	else
+		if (copy_to_user(buf, rbuf->data+rbuf->pread, todo))
+		        return -EFAULT;
 
-        rbuf->pread = (rbuf->pread + todo) % rbuf->size;
+	rbuf->pread = (rbuf->pread + todo) % rbuf->size;
 
-        return len;
+	return len;
 }
 
 
 
 ssize_t dvb_ringbuffer_write(struct dvb_ringbuffer *rbuf, const u8 *buf, size_t len)
 {
-        size_t todo = len;
-        size_t split;
+	size_t todo = len;
+	size_t split;
 
-        split = (rbuf->pwrite + len > rbuf->size) ? rbuf->size - rbuf->pwrite : 0;
+	split = (rbuf->pwrite + len > rbuf->size) ? rbuf->size - rbuf->pwrite : 0;
 
-        if (split > 0) {
-                memcpy(rbuf->data+rbuf->pwrite, buf, split);
-                buf += split;
-                todo -= split;
-                rbuf->pwrite = 0;
-        }
-        memcpy(rbuf->data+rbuf->pwrite, buf, todo);
-        rbuf->pwrite = (rbuf->pwrite + todo) % rbuf->size;
+	if (split > 0) {
+		memcpy(rbuf->data+rbuf->pwrite, buf, split);
+		buf += split;
+		todo -= split;
+		rbuf->pwrite = 0;
+	}
+	memcpy(rbuf->data+rbuf->pwrite, buf, todo);
+	rbuf->pwrite = (rbuf->pwrite + todo) % rbuf->size;
 
-        return len;
+	return len;
 }
 
 ssize_t dvb_ringbuffer_pkt_write(struct dvb_ringbuffer *rbuf, u8* buf, size_t len)
 {
-        int status;
-        ssize_t oldpwrite = rbuf->pwrite;
+	int status;
+	ssize_t oldpwrite = rbuf->pwrite;
 
-        DVB_RINGBUFFER_WRITE_BYTE(rbuf, len >> 8);
-        DVB_RINGBUFFER_WRITE_BYTE(rbuf, len & 0xff);
-        DVB_RINGBUFFER_WRITE_BYTE(rbuf, PKT_READY);
-        status = dvb_ringbuffer_write(rbuf, buf, len);
+	DVB_RINGBUFFER_WRITE_BYTE(rbuf, len >> 8);
+	DVB_RINGBUFFER_WRITE_BYTE(rbuf, len & 0xff);
+	DVB_RINGBUFFER_WRITE_BYTE(rbuf, PKT_READY);
+	status = dvb_ringbuffer_write(rbuf, buf, len);
 
-        if (status < 0) rbuf->pwrite = oldpwrite;
-        return status;
+	if (status < 0) rbuf->pwrite = oldpwrite;
+	return status;
 }
 
 ssize_t dvb_ringbuffer_pkt_read(struct dvb_ringbuffer *rbuf, size_t idx,
-                                int offset, u8* buf, size_t len, int usermem)
+		                int offset, u8* buf, size_t len, int usermem)
 {
-        size_t todo;
-        size_t split;
-        size_t pktlen;
-
-        pktlen = rbuf->data[idx] << 8;
-        pktlen |= rbuf->data[(idx + 1) % rbuf->size];
-        if (offset > pktlen) return -EINVAL;
-        if ((offset + len) > pktlen) len = pktlen - offset;
-
-        idx = (idx + DVB_RINGBUFFER_PKTHDRSIZE + offset) % rbuf->size;
-        todo = len;
-        split = ((idx + len) > rbuf->size) ? rbuf->size - idx : 0;
-        if (split > 0) {
-                if (!usermem)
-                        memcpy(buf, rbuf->data+idx, split);
-                else
-                        if (copy_to_user(buf, rbuf->data+idx, split))
-                                return -EFAULT;
-                buf += split;
-                todo -= split;
-                idx = 0;
-        }
-        if (!usermem)
-                memcpy(buf, rbuf->data+idx, todo);
-        else
-                if (copy_to_user(buf, rbuf->data+idx, todo))
-                        return -EFAULT;
+	size_t todo;
+	size_t split;
+	size_t pktlen;
+
+	pktlen = rbuf->data[idx] << 8;
+	pktlen |= rbuf->data[(idx + 1) % rbuf->size];
+	if (offset > pktlen) return -EINVAL;
+	if ((offset + len) > pktlen) len = pktlen - offset;
+
+	idx = (idx + DVB_RINGBUFFER_PKTHDRSIZE + offset) % rbuf->size;
+	todo = len;
+	split = ((idx + len) > rbuf->size) ? rbuf->size - idx : 0;
+	if (split > 0) {
+		if (!usermem)
+		        memcpy(buf, rbuf->data+idx, split);
+		else
+		        if (copy_to_user(buf, rbuf->data+idx, split))
+		                return -EFAULT;
+		buf += split;
+		todo -= split;
+		idx = 0;
+	}
+	if (!usermem)
+		memcpy(buf, rbuf->data+idx, todo);
+	else
+		if (copy_to_user(buf, rbuf->data+idx, todo))
+		        return -EFAULT;
 
-        return len;
+	return len;
 }
 
 void dvb_ringbuffer_pkt_dispose(struct dvb_ringbuffer *rbuf, size_t idx)
 {
-        size_t pktlen;
+	size_t pktlen;
 
-        rbuf->data[(idx + 2) % rbuf->size] = PKT_DISPOSED;
+	rbuf->data[(idx + 2) % rbuf->size] = PKT_DISPOSED;
 
-        // clean up disposed packets
-        while(dvb_ringbuffer_avail(rbuf) > DVB_RINGBUFFER_PKTHDRSIZE) {
-                if (DVB_RINGBUFFER_PEEK(rbuf, 2) == PKT_DISPOSED) {
-                        pktlen = DVB_RINGBUFFER_PEEK(rbuf, 0) << 8;
-                        pktlen |= DVB_RINGBUFFER_PEEK(rbuf, 1);
-                        DVB_RINGBUFFER_SKIP(rbuf, pktlen + DVB_RINGBUFFER_PKTHDRSIZE);
-                } else {
-                        // first packet is not disposed, so we stop cleaning now
-                        break;
-                }
-        }
+	// clean up disposed packets
+	while(dvb_ringbuffer_avail(rbuf) > DVB_RINGBUFFER_PKTHDRSIZE) {
+		if (DVB_RINGBUFFER_PEEK(rbuf, 2) == PKT_DISPOSED) {
+		        pktlen = DVB_RINGBUFFER_PEEK(rbuf, 0) << 8;
+		        pktlen |= DVB_RINGBUFFER_PEEK(rbuf, 1);
+		        DVB_RINGBUFFER_SKIP(rbuf, pktlen + DVB_RINGBUFFER_PKTHDRSIZE);
+		} else {
+		        // first packet is not disposed, so we stop cleaning now
+		        break;
+		}
+	}
 }
 
 ssize_t dvb_ringbuffer_pkt_next(struct dvb_ringbuffer *rbuf, size_t idx, size_t* pktlen)
 {
-        int consumed;
-        int curpktlen;
-        int curpktstatus;
+	int consumed;
+	int curpktlen;
+	int curpktstatus;
 
-        if (idx == -1) {
+	if (idx == -1) {
 	       idx = rbuf->pread;
 	} else {
-                curpktlen = rbuf->data[idx] << 8;
-                curpktlen |= rbuf->data[(idx + 1) % rbuf->size];
-	        idx = (idx + curpktlen + DVB_RINGBUFFER_PKTHDRSIZE) % rbuf->size;
+		curpktlen = rbuf->data[idx] << 8;
+		curpktlen |= rbuf->data[(idx + 1) % rbuf->size];
+		idx = (idx + curpktlen + DVB_RINGBUFFER_PKTHDRSIZE) % rbuf->size;
 	}
 
-        consumed = (idx - rbuf->pread) % rbuf->size;
+	consumed = (idx - rbuf->pread) % rbuf->size;
 
-        while((dvb_ringbuffer_avail(rbuf) - consumed) > DVB_RINGBUFFER_PKTHDRSIZE) {
+	while((dvb_ringbuffer_avail(rbuf) - consumed) > DVB_RINGBUFFER_PKTHDRSIZE) {
 
-                curpktlen = rbuf->data[idx] << 8;
-                curpktlen |= rbuf->data[(idx + 1) % rbuf->size];
-                curpktstatus = rbuf->data[(idx + 2) % rbuf->size];
+		curpktlen = rbuf->data[idx] << 8;
+		curpktlen |= rbuf->data[(idx + 1) % rbuf->size];
+		curpktstatus = rbuf->data[(idx + 2) % rbuf->size];
 
-                if (curpktstatus == PKT_READY) {
-                        *pktlen = curpktlen;
-                        return idx;
-                }
+		if (curpktstatus == PKT_READY) {
+		        *pktlen = curpktlen;
+		        return idx;
+		}
 
-                consumed += curpktlen + DVB_RINGBUFFER_PKTHDRSIZE;
-                idx = (idx + curpktlen + DVB_RINGBUFFER_PKTHDRSIZE) % rbuf->size;
-        }
+		consumed += curpktlen + DVB_RINGBUFFER_PKTHDRSIZE;
+		idx = (idx + curpktlen + DVB_RINGBUFFER_PKTHDRSIZE) % rbuf->size;
+	}
 
-        // no packets available
-        return -1;
+	// no packets available
+	return -1;
 }
 
 
diff -urN linux-2.6.15-rc5/drivers/media/dvb/dvb-core/dvb_ringbuffer.h linux-2.6.15-rc6/drivers/media/dvb/dvb-core/dvb_ringbuffer.h
--- linux-2.6.15-rc5/drivers/media/dvb/dvb-core/dvb_ringbuffer.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/media/dvb/dvb-core/dvb_ringbuffer.h	2005-12-18 22:28:03.900023298 -0800
@@ -31,13 +31,13 @@
 #include <linux/wait.h>
 
 struct dvb_ringbuffer {
-        u8               *data;
-        ssize_t           size;
-        ssize_t           pread;
-        ssize_t           pwrite;
+	u8               *data;
+	ssize_t           size;
+	ssize_t           pread;
+	ssize_t           pwrite;
 
-        wait_queue_head_t queue;
-        spinlock_t        lock;
+	wait_queue_head_t queue;
+	spinlock_t        lock;
 };
 
 #define DVB_RINGBUFFER_PKTHDRSIZE 3
@@ -106,7 +106,7 @@
 ** returns number of bytes transferred or -EFAULT
 */
 extern ssize_t dvb_ringbuffer_read(struct dvb_ringbuffer *rbuf, u8 *buf,
-                                   size_t len, int usermem);
+		                   size_t len, int usermem);
 
 
 /* write routines & macros */
@@ -121,7 +121,7 @@
 ** returns number of bytes transferred or -EFAULT
 */
 extern ssize_t dvb_ringbuffer_write(struct dvb_ringbuffer *rbuf, const u8 *buf,
-                                    size_t len);
+		                    size_t len);
 
 
 /**
@@ -133,7 +133,7 @@
  * returns Number of bytes written, or -EFAULT, -ENOMEM, -EVINAL.
  */
 extern ssize_t dvb_ringbuffer_pkt_write(struct dvb_ringbuffer *rbuf, u8* buf,
-                                        size_t len);
+		                        size_t len);
 
 /**
  * Read from a packet in the ringbuffer. Note: unlike dvb_ringbuffer_read(), this
@@ -149,7 +149,7 @@
  * returns Number of bytes read, or -EFAULT.
  */
 extern ssize_t dvb_ringbuffer_pkt_read(struct dvb_ringbuffer *rbuf, size_t idx,
-                                       int offset, u8* buf, size_t len, int usermem);
+		                       int offset, u8* buf, size_t len, int usermem);
 
 /**
  * Dispose of a packet in the ring buffer.
diff -urN linux-2.6.15-rc5/drivers/media/dvb/dvb-core/dvbdev.c linux-2.6.15-rc6/drivers/media/dvb/dvb-core/dvbdev.c
--- linux-2.6.15-rc5/drivers/media/dvb/dvb-core/dvbdev.c	2005-12-18 22:27:55.047628877 -0800
+++ linux-2.6.15-rc6/drivers/media/dvb/dvb-core/dvbdev.c	2005-12-18 22:28:03.900023298 -0800
@@ -47,7 +47,7 @@
 static DECLARE_MUTEX(dvbdev_register_lock);
 
 static const char * const dnames[] = {
-        "video", "audio", "sec", "frontend", "demux", "dvr", "ca",
+	"video", "audio", "sec", "frontend", "demux", "dvr", "ca",
 	"net", "osd"
 };
 
@@ -90,15 +90,15 @@
 
 		file->private_data = dvbdev;
 		old_fops = file->f_op;
-                file->f_op = fops_get(dvbdev->fops);
-                if(file->f_op->open)
-                        err = file->f_op->open(inode,file);
-                if (err) {
-                        fops_put(file->f_op);
-                        file->f_op = fops_get(old_fops);
-                }
-                fops_put(old_fops);
-                return err;
+		file->f_op = fops_get(dvbdev->fops);
+		if(file->f_op->open)
+		        err = file->f_op->open(inode,file);
+		if (err) {
+		        fops_put(file->f_op);
+		        file->f_op = fops_get(old_fops);
+		}
+		fops_put(old_fops);
+		return err;
 	}
 	return -ENODEV;
 }
@@ -117,21 +117,21 @@
 
 int dvb_generic_open(struct inode *inode, struct file *file)
 {
-        struct dvb_device *dvbdev = file->private_data;
+	struct dvb_device *dvbdev = file->private_data;
 
-        if (!dvbdev)
-                return -ENODEV;
+	if (!dvbdev)
+		return -ENODEV;
 
 	if (!dvbdev->users)
-                return -EBUSY;
+		return -EBUSY;
 
 	if ((file->f_flags & O_ACCMODE) == O_RDONLY) {
-                if (!dvbdev->readers)
-		        return -EBUSY;
+		if (!dvbdev->readers)
+			return -EBUSY;
 		dvbdev->readers--;
 	} else {
-                if (!dvbdev->writers)
-		        return -EBUSY;
+		if (!dvbdev->writers)
+			return -EBUSY;
 		dvbdev->writers--;
 	}
 
@@ -143,10 +143,10 @@
 
 int dvb_generic_release(struct inode *inode, struct file *file)
 {
-        struct dvb_device *dvbdev = file->private_data;
+	struct dvb_device *dvbdev = file->private_data;
 
 	if (!dvbdev)
-                return -ENODEV;
+		return -ENODEV;
 
 	if ((file->f_flags & O_ACCMODE) == O_RDONLY) {
 		dvbdev->readers++;
@@ -163,10 +163,10 @@
 int dvb_generic_ioctl(struct inode *inode, struct file *file,
 		      unsigned int cmd, unsigned long arg)
 {
-        struct dvb_device *dvbdev = file->private_data;
+	struct dvb_device *dvbdev = file->private_data;
 
-        if (!dvbdev)
-	        return -ENODEV;
+	if (!dvbdev)
+		return -ENODEV;
 
 	if (!dvbdev->kernel_ioctl)
 		return -EINVAL;
@@ -334,63 +334,63 @@
    to the v4l "videodev.o" module, which is unnecessary for some
    cards (ie. the budget dvb-cards don't need the v4l module...) */
 int dvb_usercopy(struct inode *inode, struct file *file,
-	             unsigned int cmd, unsigned long arg,
+		     unsigned int cmd, unsigned long arg,
 		     int (*func)(struct inode *inode, struct file *file,
 		     unsigned int cmd, void *arg))
 {
-        char    sbuf[128];
-        void    *mbuf = NULL;
-        void    *parg = NULL;
-        int     err  = -EINVAL;
-
-        /*  Copy arguments into temp kernel buffer  */
-        switch (_IOC_DIR(cmd)) {
-        case _IOC_NONE:
+	char    sbuf[128];
+	void    *mbuf = NULL;
+	void    *parg = NULL;
+	int     err  = -EINVAL;
+
+	/*  Copy arguments into temp kernel buffer  */
+	switch (_IOC_DIR(cmd)) {
+	case _IOC_NONE:
 		/*
 		 * For this command, the pointer is actually an integer
 		 * argument.
 		 */
 		parg = (void *) arg;
 		break;
-        case _IOC_READ: /* some v4l ioctls are marked wrong ... */
-        case _IOC_WRITE:
-        case (_IOC_WRITE | _IOC_READ):
-                if (_IOC_SIZE(cmd) <= sizeof(sbuf)) {
-                        parg = sbuf;
-                } else {
-                        /* too big to allocate from stack */
-                        mbuf = kmalloc(_IOC_SIZE(cmd),GFP_KERNEL);
-                        if (NULL == mbuf)
-                                return -ENOMEM;
-                        parg = mbuf;
-                }
-
-                err = -EFAULT;
-                if (copy_from_user(parg, (void __user *)arg, _IOC_SIZE(cmd)))
-                        goto out;
-                break;
-        }
-
-        /* call driver */
-        if ((err = func(inode, file, cmd, parg)) == -ENOIOCTLCMD)
-                err = -EINVAL;
-
-        if (err < 0)
-                goto out;
-
-        /*  Copy results into user buffer  */
-        switch (_IOC_DIR(cmd))
-        {
-        case _IOC_READ:
-        case (_IOC_WRITE | _IOC_READ):
-                if (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))
-                        err = -EFAULT;
-                break;
-        }
+	case _IOC_READ: /* some v4l ioctls are marked wrong ... */
+	case _IOC_WRITE:
+	case (_IOC_WRITE | _IOC_READ):
+		if (_IOC_SIZE(cmd) <= sizeof(sbuf)) {
+		        parg = sbuf;
+		} else {
+		        /* too big to allocate from stack */
+		        mbuf = kmalloc(_IOC_SIZE(cmd),GFP_KERNEL);
+		        if (NULL == mbuf)
+		                return -ENOMEM;
+		        parg = mbuf;
+		}
+
+		err = -EFAULT;
+		if (copy_from_user(parg, (void __user *)arg, _IOC_SIZE(cmd)))
+		        goto out;
+		break;
+	}
+
+	/* call driver */
+	if ((err = func(inode, file, cmd, parg)) == -ENOIOCTLCMD)
+		err = -EINVAL;
+
+	if (err < 0)
+		goto out;
+
+	/*  Copy results into user buffer  */
+	switch (_IOC_DIR(cmd))
+	{
+	case _IOC_READ:
+	case (_IOC_WRITE | _IOC_READ):
+		if (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))
+		        err = -EFAULT;
+		break;
+	}
 
 out:
-        kfree(mbuf);
-        return err;
+	kfree(mbuf);
+	return err;
 }
 
 static int __init init_dvbdev(void)
@@ -427,10 +427,10 @@
 
 static void __exit exit_dvbdev(void)
 {
-        devfs_remove("dvb");
+	devfs_remove("dvb");
 	class_destroy(dvb_class);
 	cdev_del(&dvb_device_cdev);
-        unregister_chrdev_region(MKDEV(DVB_MAJOR, 0), MAX_DVB_MINORS);
+	unregister_chrdev_region(MKDEV(DVB_MAJOR, 0), MAX_DVB_MINORS);
 }
 
 module_init(init_dvbdev);
diff -urN linux-2.6.15-rc5/drivers/media/dvb/dvb-core/dvbdev.h linux-2.6.15-rc6/drivers/media/dvb/dvb-core/dvbdev.h
--- linux-2.6.15-rc5/drivers/media/dvb/dvb-core/dvbdev.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/media/dvb/dvb-core/dvbdev.h	2005-12-18 22:28:03.901023342 -0800
@@ -68,8 +68,8 @@
 	int writers;
 	int users;
 
-        /* don't really need those !? -- FIXME: use video_usercopy  */
-        int (*kernel_ioctl)(struct inode *inode, struct file *file,
+	/* don't really need those !? -- FIXME: use video_usercopy  */
+	int (*kernel_ioctl)(struct inode *inode, struct file *file,
 			    unsigned int cmd, void *arg);
 
 	void *priv;
@@ -97,7 +97,7 @@
 generic_usercopy()  someday... */
 
 extern int dvb_usercopy(struct inode *inode, struct file *file,
-	                    unsigned int cmd, unsigned long arg,
+		            unsigned int cmd, unsigned long arg,
 			    int (*func)(struct inode *inode, struct file *file,
 			    unsigned int cmd, void *arg));
 
diff -urN linux-2.6.15-rc5/drivers/media/dvb/dvb-usb/vp702x-fe.c linux-2.6.15-rc6/drivers/media/dvb/dvb-usb/vp702x-fe.c
--- linux-2.6.15-rc5/drivers/media/dvb/dvb-usb/vp702x-fe.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/media/dvb/dvb-usb/vp702x-fe.c	2005-12-18 22:28:03.904023476 -0800
@@ -190,7 +190,7 @@
 }
 
 static int vp702x_fe_send_diseqc_msg (struct dvb_frontend* fe,
-		                    struct dvb_diseqc_master_cmd *m)
+			            struct dvb_diseqc_master_cmd *m)
 {
 	struct vp702x_fe_state *st = fe->demodulator_priv;
 	u8 cmd[8],ibuf[10];
diff -urN linux-2.6.15-rc5/drivers/media/dvb/dvb-usb/vp7045-fe.c linux-2.6.15-rc6/drivers/media/dvb/dvb-usb/vp7045-fe.c
--- linux-2.6.15-rc5/drivers/media/dvb/dvb-usb/vp7045-fe.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/media/dvb/dvb-usb/vp7045-fe.c	2005-12-18 22:28:03.904023476 -0800
@@ -58,7 +58,7 @@
 	struct vp7045_fe_state *state = fe->demodulator_priv;
 	*ber = (vp7045_read_reg(state->d, 0x0D) << 16) |
 	       (vp7045_read_reg(state->d, 0x0E) << 8) |
-	        vp7045_read_reg(state->d, 0x0F);
+		vp7045_read_reg(state->d, 0x0F);
 	return 0;
 }
 
diff -urN linux-2.6.15-rc5/drivers/media/dvb/frontends/at76c651.c linux-2.6.15-rc6/drivers/media/dvb/frontends/at76c651.c
--- linux-2.6.15-rc5/drivers/media/dvb/frontends/at76c651.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/media/dvb/frontends/at76c651.c	2005-12-18 22:28:03.905023520 -0800
@@ -361,9 +361,9 @@
 
 static int at76c651_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings *fesettings)
 {
-        fesettings->min_delay_ms = 50;
-        fesettings->step_size = 0;
-        fesettings->max_drift = 0;
+	fesettings->min_delay_ms = 50;
+	fesettings->step_size = 0;
+	fesettings->max_drift = 0;
 	return 0;
 }
 
diff -urN linux-2.6.15-rc5/drivers/media/dvb/frontends/bcm3510.c linux-2.6.15-rc6/drivers/media/dvb/frontends/bcm3510.c
--- linux-2.6.15-rc5/drivers/media/dvb/frontends/bcm3510.c	2005-12-18 22:27:55.052629100 -0800
+++ linux-2.6.15-rc6/drivers/media/dvb/frontends/bcm3510.c	2005-12-18 22:28:03.906023565 -0800
@@ -69,7 +69,7 @@
 #define dbufout(b,l,m) {\
 	    int i; \
 	    for (i = 0; i < l; i++) \
-	        m("%02x ",b[i]); \
+		m("%02x ",b[i]); \
 }
 #define deb_info(args...) dprintk(0x01,args)
 #define deb_i2c(args...)  dprintk(0x02,args)
@@ -827,7 +827,7 @@
 		.type = FE_ATSC,
 		.frequency_min =  54000000,
 		.frequency_max = 803000000,
-                /* stepsize is just a guess */
+		/* stepsize is just a guess */
 		.frequency_stepsize = 0,
 		.caps =
 			FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
diff -urN linux-2.6.15-rc5/drivers/media/dvb/frontends/cx22700.c linux-2.6.15-rc6/drivers/media/dvb/frontends/cx22700.c
--- linux-2.6.15-rc5/drivers/media/dvb/frontends/cx22700.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/media/dvb/frontends/cx22700.c	2005-12-18 22:28:03.906023565 -0800
@@ -355,10 +355,10 @@
 
 static int cx22700_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings* fesettings)
 {
-        fesettings->min_delay_ms = 150;
-        fesettings->step_size = 166667;
-        fesettings->max_drift = 166667*2;
-        return 0;
+	fesettings->min_delay_ms = 150;
+	fesettings->step_size = 166667;
+	fesettings->max_drift = 166667*2;
+	return 0;
 }
 
 static void cx22700_release(struct dvb_frontend* fe)
@@ -407,7 +407,7 @@
 		.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
 		      FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
 		      FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 |
-	              FE_CAN_RECOVER
+		      FE_CAN_RECOVER
 	},
 
 	.release = cx22700_release,
diff -urN linux-2.6.15-rc5/drivers/media/dvb/frontends/cx22702.c linux-2.6.15-rc6/drivers/media/dvb/frontends/cx22702.c
--- linux-2.6.15-rc5/drivers/media/dvb/frontends/cx22702.c	2005-12-18 22:27:55.052629100 -0800
+++ linux-2.6.15-rc6/drivers/media/dvb/frontends/cx22702.c	2005-12-18 22:28:03.907023610 -0800
@@ -2,7 +2,7 @@
     Conexant 22702 DVB OFDM demodulator driver
 
     based on:
-        Alps TDMB7 DVB OFDM demodulator driver
+	Alps TDMB7 DVB OFDM demodulator driver
 
     Copyright (C) 2001-2002 Convergence Integrated Media GmbH
 	  Holger Waechtler <holger@convergence.de>
diff -urN linux-2.6.15-rc5/drivers/media/dvb/frontends/cx22702.h linux-2.6.15-rc6/drivers/media/dvb/frontends/cx22702.h
--- linux-2.6.15-rc5/drivers/media/dvb/frontends/cx22702.h	2005-12-18 22:27:55.053629145 -0800
+++ linux-2.6.15-rc6/drivers/media/dvb/frontends/cx22702.h	2005-12-18 22:28:03.907023610 -0800
@@ -2,7 +2,7 @@
     Conexant 22702 DVB OFDM demodulator driver
 
     based on:
-        Alps TDMB7 DVB OFDM demodulator driver
+	Alps TDMB7 DVB OFDM demodulator driver
 
     Copyright (C) 2001-2002 Convergence Integrated Media GmbH
 	  Holger Waechtler <holger@convergence.de>
diff -urN linux-2.6.15-rc5/drivers/media/dvb/frontends/cx24110.c linux-2.6.15-rc6/drivers/media/dvb/frontends/cx24110.c
--- linux-2.6.15-rc5/drivers/media/dvb/frontends/cx24110.c	2005-12-18 22:27:55.053629145 -0800
+++ linux-2.6.15-rc6/drivers/media/dvb/frontends/cx24110.c	2005-12-18 22:28:03.908023654 -0800
@@ -55,81 +55,81 @@
 	} while (0)
 
 static struct {u8 reg; u8 data;} cx24110_regdata[]=
-                      /* Comments beginning with @ denote this value should
-                         be the default */
-        {{0x09,0x01}, /* SoftResetAll */
-         {0x09,0x00}, /* release reset */
-         {0x01,0xe8}, /* MSB of code rate 27.5MS/s */
-         {0x02,0x17}, /* middle byte " */
-         {0x03,0x29}, /* LSB         " */
-         {0x05,0x03}, /* @ DVB mode, standard code rate 3/4 */
-         {0x06,0xa5}, /* @ PLL 60MHz */
-         {0x07,0x01}, /* @ Fclk, i.e. sampling clock, 60MHz */
-         {0x0a,0x00}, /* @ partial chip disables, do not set */
-         {0x0b,0x01}, /* set output clock in gapped mode, start signal low
-                         active for first byte */
-         {0x0c,0x11}, /* no parity bytes, large hold time, serial data out */
-         {0x0d,0x6f}, /* @ RS Sync/Unsync thresholds */
-         {0x10,0x40}, /* chip doc is misleading here: write bit 6 as 1
-                         to avoid starting the BER counter. Reset the
-                         CRC test bit. Finite counting selected */
-         {0x15,0xff}, /* @ size of the limited time window for RS BER
-                         estimation. It is <value>*256 RS blocks, this
-                         gives approx. 2.6 sec at 27.5MS/s, rate 3/4 */
-         {0x16,0x00}, /* @ enable all RS output ports */
-         {0x17,0x04}, /* @ time window allowed for the RS to sync */
-         {0x18,0xae}, /* @ allow all standard DVB code rates to be scanned
-                         for automatically */
-                      /* leave the current code rate and normalization
-                         registers as they are after reset... */
-         {0x21,0x10}, /* @ during AutoAcq, search each viterbi setting
-                         only once */
-         {0x23,0x18}, /* @ size of the limited time window for Viterbi BER
-                         estimation. It is <value>*65536 channel bits, i.e.
-                         approx. 38ms at 27.5MS/s, rate 3/4 */
-         {0x24,0x24}, /* do not trigger Viterbi CRC test. Finite count window */
-                      /* leave front-end AGC parameters at default values */
-                      /* leave decimation AGC parameters at default values */
-         {0x35,0x40}, /* disable all interrupts. They are not connected anyway */
-         {0x36,0xff}, /* clear all interrupt pending flags */
-         {0x37,0x00}, /* @ fully enable AutoAcqq state machine */
-         {0x38,0x07}, /* @ enable fade recovery, but not autostart AutoAcq */
-                      /* leave the equalizer parameters on their default values */
-                      /* leave the final AGC parameters on their default values */
-         {0x41,0x00}, /* @ MSB of front-end derotator frequency */
-         {0x42,0x00}, /* @ middle bytes " */
-         {0x43,0x00}, /* @ LSB          " */
-                      /* leave the carrier tracking loop parameters on default */
-                      /* leave the bit timing loop parameters at gefault */
-         {0x56,0x4d}, /* set the filtune voltage to 2.7V, as recommended by */
-                      /* the cx24108 data sheet for symbol rates above 15MS/s */
-         {0x57,0x00}, /* @ Filter sigma delta enabled, positive */
-         {0x61,0x95}, /* GPIO pins 1-4 have special function */
-         {0x62,0x05}, /* GPIO pin 5 has special function, pin 6 is GPIO */
-         {0x63,0x00}, /* All GPIO pins use CMOS output characteristics */
-         {0x64,0x20}, /* GPIO 6 is input, all others are outputs */
-         {0x6d,0x30}, /* tuner auto mode clock freq 62kHz */
-         {0x70,0x15}, /* use auto mode, tuner word is 21 bits long */
-         {0x73,0x00}, /* @ disable several demod bypasses */
-         {0x74,0x00}, /* @  " */
-         {0x75,0x00}  /* @  " */
-                      /* the remaining registers are for SEC */
+		      /* Comments beginning with @ denote this value should
+		         be the default */
+	{{0x09,0x01}, /* SoftResetAll */
+	 {0x09,0x00}, /* release reset */
+	 {0x01,0xe8}, /* MSB of code rate 27.5MS/s */
+	 {0x02,0x17}, /* middle byte " */
+	 {0x03,0x29}, /* LSB         " */
+	 {0x05,0x03}, /* @ DVB mode, standard code rate 3/4 */
+	 {0x06,0xa5}, /* @ PLL 60MHz */
+	 {0x07,0x01}, /* @ Fclk, i.e. sampling clock, 60MHz */
+	 {0x0a,0x00}, /* @ partial chip disables, do not set */
+	 {0x0b,0x01}, /* set output clock in gapped mode, start signal low
+		         active for first byte */
+	 {0x0c,0x11}, /* no parity bytes, large hold time, serial data out */
+	 {0x0d,0x6f}, /* @ RS Sync/Unsync thresholds */
+	 {0x10,0x40}, /* chip doc is misleading here: write bit 6 as 1
+		         to avoid starting the BER counter. Reset the
+		         CRC test bit. Finite counting selected */
+	 {0x15,0xff}, /* @ size of the limited time window for RS BER
+		         estimation. It is <value>*256 RS blocks, this
+		         gives approx. 2.6 sec at 27.5MS/s, rate 3/4 */
+	 {0x16,0x00}, /* @ enable all RS output ports */
+	 {0x17,0x04}, /* @ time window allowed for the RS to sync */
+	 {0x18,0xae}, /* @ allow all standard DVB code rates to be scanned
+		         for automatically */
+		      /* leave the current code rate and normalization
+		         registers as they are after reset... */
+	 {0x21,0x10}, /* @ during AutoAcq, search each viterbi setting
+		         only once */
+	 {0x23,0x18}, /* @ size of the limited time window for Viterbi BER
+		         estimation. It is <value>*65536 channel bits, i.e.
+		         approx. 38ms at 27.5MS/s, rate 3/4 */
+	 {0x24,0x24}, /* do not trigger Viterbi CRC test. Finite count window */
+		      /* leave front-end AGC parameters at default values */
+		      /* leave decimation AGC parameters at default values */
+	 {0x35,0x40}, /* disable all interrupts. They are not connected anyway */
+	 {0x36,0xff}, /* clear all interrupt pending flags */
+	 {0x37,0x00}, /* @ fully enable AutoAcqq state machine */
+	 {0x38,0x07}, /* @ enable fade recovery, but not autostart AutoAcq */
+		      /* leave the equalizer parameters on their default values */
+		      /* leave the final AGC parameters on their default values */
+	 {0x41,0x00}, /* @ MSB of front-end derotator frequency */
+	 {0x42,0x00}, /* @ middle bytes " */
+	 {0x43,0x00}, /* @ LSB          " */
+		      /* leave the carrier tracking loop parameters on default */
+		      /* leave the bit timing loop parameters at gefault */
+	 {0x56,0x4d}, /* set the filtune voltage to 2.7V, as recommended by */
+		      /* the cx24108 data sheet for symbol rates above 15MS/s */
+	 {0x57,0x00}, /* @ Filter sigma delta enabled, positive */
+	 {0x61,0x95}, /* GPIO pins 1-4 have special function */
+	 {0x62,0x05}, /* GPIO pin 5 has special function, pin 6 is GPIO */
+	 {0x63,0x00}, /* All GPIO pins use CMOS output characteristics */
+	 {0x64,0x20}, /* GPIO 6 is input, all others are outputs */
+	 {0x6d,0x30}, /* tuner auto mode clock freq 62kHz */
+	 {0x70,0x15}, /* use auto mode, tuner word is 21 bits long */
+	 {0x73,0x00}, /* @ disable several demod bypasses */
+	 {0x74,0x00}, /* @  " */
+	 {0x75,0x00}  /* @  " */
+		      /* the remaining registers are for SEC */
 	};
 
 
 static int cx24110_writereg (struct cx24110_state* state, int reg, int data)
 {
-        u8 buf [] = { reg, data };
+	u8 buf [] = { reg, data };
 	struct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = buf, .len = 2 };
 	int err;
 
-        if ((err = i2c_transfer(state->i2c, &msg, 1)) != 1) {
+	if ((err = i2c_transfer(state->i2c, &msg, 1)) != 1) {
 		dprintk ("%s: writereg error (err == %i, reg == 0x%02x,"
 			 " data == 0x%02x)\n", __FUNCTION__, err, reg, data);
 		return -EREMOTEIO;
 	}
 
-        return 0;
+	return 0;
 }
 
 static int cx24110_readreg (struct cx24110_state* state, u8 reg)
@@ -153,27 +153,27 @@
 
 	switch (inversion) {
 	case INVERSION_OFF:
-                cx24110_writereg(state,0x37,cx24110_readreg(state,0x37)|0x1);
-                /* AcqSpectrInvDis on. No idea why someone should want this */
-                cx24110_writereg(state,0x5,cx24110_readreg(state,0x5)&0xf7);
-                /* Initial value 0 at start of acq */
-                cx24110_writereg(state,0x22,cx24110_readreg(state,0x22)&0xef);
-                /* current value 0 */
-                /* The cx24110 manual tells us this reg is read-only.
-                   But what the heck... set it ayways */
-                break;
+		cx24110_writereg(state,0x37,cx24110_readreg(state,0x37)|0x1);
+		/* AcqSpectrInvDis on. No idea why someone should want this */
+		cx24110_writereg(state,0x5,cx24110_readreg(state,0x5)&0xf7);
+		/* Initial value 0 at start of acq */
+		cx24110_writereg(state,0x22,cx24110_readreg(state,0x22)&0xef);
+		/* current value 0 */
+		/* The cx24110 manual tells us this reg is read-only.
+		   But what the heck... set it ayways */
+		break;
 	case INVERSION_ON:
-                cx24110_writereg(state,0x37,cx24110_readreg(state,0x37)|0x1);
-                /* AcqSpectrInvDis on. No idea why someone should want this */
-                cx24110_writereg(state,0x5,cx24110_readreg(state,0x5)|0x08);
-                /* Initial value 1 at start of acq */
-                cx24110_writereg(state,0x22,cx24110_readreg(state,0x22)|0x10);
-                /* current value 1 */
-                break;
+		cx24110_writereg(state,0x37,cx24110_readreg(state,0x37)|0x1);
+		/* AcqSpectrInvDis on. No idea why someone should want this */
+		cx24110_writereg(state,0x5,cx24110_readreg(state,0x5)|0x08);
+		/* Initial value 1 at start of acq */
+		cx24110_writereg(state,0x22,cx24110_readreg(state,0x22)|0x10);
+		/* current value 1 */
+		break;
 	case INVERSION_AUTO:
-                cx24110_writereg(state,0x37,cx24110_readreg(state,0x37)&0xfe);
-                /* AcqSpectrInvDis off. Leave initial & current states as is */
-                break;
+		cx24110_writereg(state,0x37,cx24110_readreg(state,0x37)&0xfe);
+		/* AcqSpectrInvDis off. Leave initial & current states as is */
+		break;
 	default:
 		return -EINVAL;
 	}
@@ -185,18 +185,18 @@
 {
 /* fixme (low): error handling */
 
-        static const int rate[]={-1,1,2,3,5,7,-1};
-        static const int g1[]={-1,0x01,0x02,0x05,0x15,0x45,-1};
-        static const int g2[]={-1,0x01,0x03,0x06,0x1a,0x7a,-1};
-
-        /* Well, the AutoAcq engine of the cx24106 and 24110 automatically
-           searches all enabled viterbi rates, and can handle non-standard
-           rates as well. */
+	static const int rate[]={-1,1,2,3,5,7,-1};
+	static const int g1[]={-1,0x01,0x02,0x05,0x15,0x45,-1};
+	static const int g2[]={-1,0x01,0x03,0x06,0x1a,0x7a,-1};
+
+	/* Well, the AutoAcq engine of the cx24106 and 24110 automatically
+	   searches all enabled viterbi rates, and can handle non-standard
+	   rates as well. */
 
-        if (fec>FEC_AUTO)
-                fec=FEC_AUTO;
+	if (fec>FEC_AUTO)
+		fec=FEC_AUTO;
 
-        if (fec==FEC_AUTO) { /* (re-)establish AutoAcq behaviour */
+	if (fec==FEC_AUTO) { /* (re-)establish AutoAcq behaviour */
 		cx24110_writereg(state,0x37,cx24110_readreg(state,0x37)&0xdf);
 		/* clear AcqVitDis bit */
 		cx24110_writereg(state,0x18,0xae);
@@ -208,7 +208,7 @@
 		cx24110_writereg(state,0x1a,0x05); cx24110_writereg(state,0x1b,0x06);
 		/* set the puncture registers for code rate 3/4 */
 		return 0;
-        } else {
+	} else {
 		cx24110_writereg(state,0x37,cx24110_readreg(state,0x37)|0x20);
 		/* set AcqVitDis bit */
 		if(rate[fec]>0) {
@@ -219,10 +219,10 @@
 			cx24110_writereg(state,0x1a,g1[fec]);
 			cx24110_writereg(state,0x1b,g2[fec]);
 			/* not sure if this is the right way: I always used AutoAcq mode */
-           } else
+	   } else
 		   return -EOPNOTSUPP;
 /* fixme (low): which is the correct return code? */
-        };
+	};
 	return 0;
 }
 
@@ -245,72 +245,72 @@
 static int cx24110_set_symbolrate (struct cx24110_state* state, u32 srate)
 {
 /* fixme (low): add error handling */
-        u32 ratio;
-        u32 tmp, fclk, BDRI;
+	u32 ratio;
+	u32 tmp, fclk, BDRI;
 
-        static const u32 bands[]={5000000UL,15000000UL,90999000UL/2};
-        int i;
+	static const u32 bands[]={5000000UL,15000000UL,90999000UL/2};
+	int i;
 
 dprintk("cx24110 debug: entering %s(%d)\n",__FUNCTION__,srate);
-        if (srate>90999000UL/2)
-                srate=90999000UL/2;
-        if (srate<500000)
-                srate=500000;
+	if (srate>90999000UL/2)
+		srate=90999000UL/2;
+	if (srate<500000)
+		srate=500000;
 
-        for(i=0;(i<sizeof(bands)/sizeof(bands[0]))&&(srate>bands[i]);i++)
+	for(i=0;(i<sizeof(bands)/sizeof(bands[0]))&&(srate>bands[i]);i++)
 		;
-        /* first, check which sample rate is appropriate: 45, 60 80 or 90 MHz,
-           and set the PLL accordingly (R07[1:0] Fclk, R06[7:4] PLLmult,
-           R06[3:0] PLLphaseDetGain */
-        tmp=cx24110_readreg(state,0x07)&0xfc;
-        if(srate<90999000UL/4) { /* sample rate 45MHz*/
+	/* first, check which sample rate is appropriate: 45, 60 80 or 90 MHz,
+	   and set the PLL accordingly (R07[1:0] Fclk, R06[7:4] PLLmult,
+	   R06[3:0] PLLphaseDetGain */
+	tmp=cx24110_readreg(state,0x07)&0xfc;
+	if(srate<90999000UL/4) { /* sample rate 45MHz*/
 		cx24110_writereg(state,0x07,tmp);
 		cx24110_writereg(state,0x06,0x78);
 		fclk=90999000UL/2;
-        } else if(srate<60666000UL/2) { /* sample rate 60MHz */
+	} else if(srate<60666000UL/2) { /* sample rate 60MHz */
 		cx24110_writereg(state,0x07,tmp|0x1);
 		cx24110_writereg(state,0x06,0xa5);
 		fclk=60666000UL;
-        } else if(srate<80888000UL/2) { /* sample rate 80MHz */
+	} else if(srate<80888000UL/2) { /* sample rate 80MHz */
 		cx24110_writereg(state,0x07,tmp|0x2);
 		cx24110_writereg(state,0x06,0x87);
 		fclk=80888000UL;
-        } else { /* sample rate 90MHz */
+	} else { /* sample rate 90MHz */
 		cx24110_writereg(state,0x07,tmp|0x3);
 		cx24110_writereg(state,0x06,0x78);
 		fclk=90999000UL;
-        };
-        dprintk("cx24110 debug: fclk %d Hz\n",fclk);
-        /* we need to divide two integers with approx. 27 bits in 32 bit
-           arithmetic giving a 25 bit result */
-        /* the maximum dividend is 90999000/2, 0x02b6446c, this number is
-           also the most complex divisor. Hence, the dividend has,
-           assuming 32bit unsigned arithmetic, 6 clear bits on top, the
-           divisor 2 unused bits at the bottom. Also, the quotient is
-           always less than 1/2. Borrowed from VES1893.c, of course */
-
-        tmp=srate<<6;
-        BDRI=fclk>>2;
-        ratio=(tmp/BDRI);
-
-        tmp=(tmp%BDRI)<<8;
-        ratio=(ratio<<8)+(tmp/BDRI);
-
-        tmp=(tmp%BDRI)<<8;
-        ratio=(ratio<<8)+(tmp/BDRI);
-
-        tmp=(tmp%BDRI)<<1;
-        ratio=(ratio<<1)+(tmp/BDRI);
-
-        dprintk("srate= %d (range %d, up to %d)\n", srate,i,bands[i]);
-        dprintk("fclk = %d\n", fclk);
-        dprintk("ratio= %08x\n", ratio);
-
-        cx24110_writereg(state, 0x1, (ratio>>16)&0xff);
-        cx24110_writereg(state, 0x2, (ratio>>8)&0xff);
-        cx24110_writereg(state, 0x3, (ratio)&0xff);
+	};
+	dprintk("cx24110 debug: fclk %d Hz\n",fclk);
+	/* we need to divide two integers with approx. 27 bits in 32 bit
+	   arithmetic giving a 25 bit result */
+	/* the maximum dividend is 90999000/2, 0x02b6446c, this number is
+	   also the most complex divisor. Hence, the dividend has,
+	   assuming 32bit unsigned arithmetic, 6 clear bits on top, the
+	   divisor 2 unused bits at the bottom. Also, the quotient is
+	   always less than 1/2. Borrowed from VES1893.c, of course */
+
+	tmp=srate<<6;
+	BDRI=fclk>>2;
+	ratio=(tmp/BDRI);
+
+	tmp=(tmp%BDRI)<<8;
+	ratio=(ratio<<8)+(tmp/BDRI);
+
+	tmp=(tmp%BDRI)<<8;
+	ratio=(ratio<<8)+(tmp/BDRI);
+
+	tmp=(tmp%BDRI)<<1;
+	ratio=(ratio<<1)+(tmp/BDRI);
+
+	dprintk("srate= %d (range %d, up to %d)\n", srate,i,bands[i]);
+	dprintk("fclk = %d\n", fclk);
+	dprintk("ratio= %08x\n", ratio);
+
+	cx24110_writereg(state, 0x1, (ratio>>16)&0xff);
+	cx24110_writereg(state, 0x2, (ratio>>8)&0xff);
+	cx24110_writereg(state, 0x3, (ratio)&0xff);
 
-        return 0;
+	return 0;
 
 }
 
@@ -324,48 +324,48 @@
 
 	dprintk("cx24110 debug: cx24108_write(%8.8x)\n",data);
 
-        cx24110_writereg(state,0x6d,0x30); /* auto mode at 62kHz */
-        cx24110_writereg(state,0x70,0x15); /* auto mode 21 bits */
+	cx24110_writereg(state,0x6d,0x30); /* auto mode at 62kHz */
+	cx24110_writereg(state,0x70,0x15); /* auto mode 21 bits */
 
-        /* if the auto tuner writer is still busy, clear it out */
-        while (cx24110_readreg(state,0x6d)&0x80)
+	/* if the auto tuner writer is still busy, clear it out */
+	while (cx24110_readreg(state,0x6d)&0x80)
 		cx24110_writereg(state,0x72,0);
 
-        /* write the topmost 8 bits */
-        cx24110_writereg(state,0x72,(data>>24)&0xff);
+	/* write the topmost 8 bits */
+	cx24110_writereg(state,0x72,(data>>24)&0xff);
 
-        /* wait for the send to be completed */
-        while ((cx24110_readreg(state,0x6d)&0xc0)==0x80)
+	/* wait for the send to be completed */
+	while ((cx24110_readreg(state,0x6d)&0xc0)==0x80)
 		;
 
-        /* send another 8 bytes */
-        cx24110_writereg(state,0x72,(data>>16)&0xff);
-        while ((cx24110_readreg(state,0x6d)&0xc0)==0x80)
+	/* send another 8 bytes */
+	cx24110_writereg(state,0x72,(data>>16)&0xff);
+	while ((cx24110_readreg(state,0x6d)&0xc0)==0x80)
 		;
 
-        /* and the topmost 5 bits of this byte */
-        cx24110_writereg(state,0x72,(data>>8)&0xff);
-        while ((cx24110_readreg(state,0x6d)&0xc0)==0x80)
+	/* and the topmost 5 bits of this byte */
+	cx24110_writereg(state,0x72,(data>>8)&0xff);
+	while ((cx24110_readreg(state,0x6d)&0xc0)==0x80)
 		;
 
-        /* now strobe the enable line once */
-        cx24110_writereg(state,0x6d,0x32);
-        cx24110_writereg(state,0x6d,0x30);
+	/* now strobe the enable line once */
+	cx24110_writereg(state,0x6d,0x32);
+	cx24110_writereg(state,0x6d,0x30);
 
-        return 0;
+	return 0;
 }
 
 static int cx24110_initfe(struct dvb_frontend* fe)
 {
 	struct cx24110_state *state = fe->demodulator_priv;
 /* fixme (low): error handling */
-        int i;
+	int i;
 
 	dprintk("%s: init chip\n", __FUNCTION__);
 
-        for(i=0;i<sizeof(cx24110_regdata)/sizeof(cx24110_regdata[0]);i++) {
+	for(i=0;i<sizeof(cx24110_regdata)/sizeof(cx24110_regdata[0]);i++) {
 		cx24110_writereg(state, cx24110_regdata[i].reg, cx24110_regdata[i].data);
-        };
+	};
 
 	if (state->config->pll_init) state->config->pll_init(fe);
 
diff -urN linux-2.6.15-rc5/drivers/media/dvb/frontends/l64781.c linux-2.6.15-rc6/drivers/media/dvb/frontends/l64781.c
--- linux-2.6.15-rc5/drivers/media/dvb/frontends/l64781.c	2005-12-18 22:27:55.055629234 -0800
+++ linux-2.6.15-rc6/drivers/media/dvb/frontends/l64781.c	2005-12-18 22:28:03.911023788 -0800
@@ -2,7 +2,7 @@
     driver for LSI L64781 COFDM demodulator
 
     Copyright (C) 2001 Holger Waechtler for Convergence Integrated Media GmbH
-                       Marko Kohtala <marko.kohtala@luukku.com>
+		       Marko Kohtala <marko.kohtala@luukku.com>
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
@@ -433,7 +433,7 @@
 {
 	struct l64781_state* state = fe->demodulator_priv;
 
-        reset_and_configure (state);
+	reset_and_configure (state);
 
 	/* Power up */
 	l64781_writereg (state, 0x3e, 0xa5);
@@ -456,9 +456,9 @@
 	l64781_writereg (state, 0x0d, 0x8c);
 
 	/* With ppm=8000, it seems the DTR_SENSITIVITY will result in
-           value of 2 with all possible bandwidths and guard
-           intervals, which is the initial value anyway. */
-        /*l64781_writereg (state, 0x19, 0x92);*/
+	   value of 2 with all possible bandwidths and guard
+	   intervals, which is the initial value anyway. */
+	/*l64781_writereg (state, 0x19, 0x92);*/
 
 	/* Everything is two's complement, soft bit and CSI_OUT too */
 	l64781_writereg (state, 0x1e, 0x09);
@@ -477,10 +477,10 @@
 static int l64781_get_tune_settings(struct dvb_frontend* fe,
 				    struct dvb_frontend_tune_settings* fesettings)
 {
-        fesettings->min_delay_ms = 4000;
-        fesettings->step_size = 0;
-        fesettings->max_drift = 0;
-        return 0;
+	fesettings->min_delay_ms = 4000;
+	fesettings->step_size = 0;
+	fesettings->max_drift = 0;
+	return 0;
 }
 
 static void l64781_release(struct dvb_frontend* fe)
@@ -522,7 +522,7 @@
 
 	/* The chip always responds to reads */
 	if (i2c_transfer(state->i2c, msg, 2) != 2) {
-	        dprintk("No response to read on I2C bus\n");
+		dprintk("No response to read on I2C bus\n");
 		goto error;
 	}
 
@@ -531,7 +531,7 @@
 
 	/* Reading the POWER_DOWN register always returns 0 */
 	if (reg0x3e != 0) {
-	        dprintk("Device doesn't look like L64781\n");
+		dprintk("Device doesn't look like L64781\n");
 		goto error;
 	}
 
@@ -540,7 +540,7 @@
 
 	/* Responds to all reads with 0 */
 	if (l64781_readreg(state, 0x1a) != 0) {
-	        dprintk("Read 1 returned unexpcted value\n");
+		dprintk("Read 1 returned unexpcted value\n");
 		goto error;
 	}
 
@@ -549,7 +549,7 @@
 
 	/* Responds with register default value */
 	if (l64781_readreg(state, 0x1a) != 0xa1) {
-	        dprintk("Read 2 returned unexpcted value\n");
+		dprintk("Read 2 returned unexpcted value\n");
 		goto error;
 	}
 
diff -urN linux-2.6.15-rc5/drivers/media/dvb/frontends/l64781.h linux-2.6.15-rc6/drivers/media/dvb/frontends/l64781.h
--- linux-2.6.15-rc5/drivers/media/dvb/frontends/l64781.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/media/dvb/frontends/l64781.h	2005-12-18 22:28:03.911023788 -0800
@@ -2,7 +2,7 @@
     driver for LSI L64781 COFDM demodulator
 
     Copyright (C) 2001 Holger Waechtler for Convergence Integrated Media GmbH
-                       Marko Kohtala <marko.kohtala@luukku.com>
+		       Marko Kohtala <marko.kohtala@luukku.com>
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
diff -urN linux-2.6.15-rc5/drivers/media/dvb/frontends/lgdt330x.c linux-2.6.15-rc6/drivers/media/dvb/frontends/lgdt330x.c
--- linux-2.6.15-rc5/drivers/media/dvb/frontends/lgdt330x.c	2005-12-18 22:27:55.056629278 -0800
+++ linux-2.6.15-rc6/drivers/media/dvb/frontends/lgdt330x.c	2005-12-18 22:28:03.911023788 -0800
@@ -301,10 +301,10 @@
 	static u8 lgdt3303_8vsb_44_data[] = {
 		0x04, 0x00,
 		0x0d, 0x40,
-        0x0e, 0x87,
-        0x0f, 0x8e,
-        0x10, 0x01,
-        0x47, 0x8b };
+	0x0e, 0x87,
+	0x0f, 0x8e,
+	0x10, 0x01,
+	0x47, 0x8b };
 
 	/*
 	 * Array of byte pairs <address, value>
diff -urN linux-2.6.15-rc5/drivers/media/dvb/frontends/mt312.c linux-2.6.15-rc6/drivers/media/dvb/frontends/mt312.c
--- linux-2.6.15-rc5/drivers/media/dvb/frontends/mt312.c	2005-12-18 22:27:55.057629323 -0800
+++ linux-2.6.15-rc6/drivers/media/dvb/frontends/mt312.c	2005-12-18 22:28:03.912023832 -0800
@@ -554,7 +554,7 @@
 	if ((ret = mt312_write(state, SYM_RATE_H, buf, sizeof(buf))) < 0)
 		return ret;
 
-        mt312_reset(state, 0);
+	mt312_reset(state, 0);
 
 	return 0;
 }
@@ -695,7 +695,7 @@
 		    FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 |
 		    FE_CAN_FEC_3_4 | FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 |
 		    FE_CAN_FEC_AUTO | FE_CAN_QPSK | FE_CAN_MUTE_TS |
-	            FE_CAN_RECOVER
+		    FE_CAN_RECOVER
 	},
 
 	.release = mt312_release,
diff -urN linux-2.6.15-rc5/drivers/media/dvb/frontends/nxt2002.c linux-2.6.15-rc6/drivers/media/dvb/frontends/nxt2002.c
--- linux-2.6.15-rc5/drivers/media/dvb/frontends/nxt2002.c	2005-12-18 22:27:55.057629323 -0800
+++ linux-2.6.15-rc6/drivers/media/dvb/frontends/nxt2002.c	2005-12-18 22:28:03.913023877 -0800
@@ -527,7 +527,7 @@
 	else
 		snrdb = 1000*0 + ( 1000*(12-0) * ( temp2 - 0 ) / ( 0x7C00 - 0 ) );
 
-        /* the value reported back from the frontend will be FFFF=32db 0000=0db */
+	/* the value reported back from the frontend will be FFFF=32db 0000=0db */
 
 	*snr = snrdb * (0xFFFF/32000);
 
@@ -646,7 +646,7 @@
 	memcpy(&state->ops, &nxt2002_ops, sizeof(struct dvb_frontend_ops));
 	state->initialised = 0;
 
-        /* Check the first 5 registers to ensure this a revision we can handle */
+	/* Check the first 5 registers to ensure this a revision we can handle */
 
 	i2c_readbytes(state, 0x00, buf, 5);
 	if (buf[0] != 0x04) goto error;		/* device id */
@@ -672,7 +672,7 @@
 		.type = FE_ATSC,
 		.frequency_min =  54000000,
 		.frequency_max = 860000000,
-                /* stepsize is just a guess */
+		/* stepsize is just a guess */
 		.frequency_stepsize = 166666,
 		.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
 			FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
diff -urN linux-2.6.15-rc5/drivers/media/dvb/frontends/nxt200x.c linux-2.6.15-rc6/drivers/media/dvb/frontends/nxt200x.c
--- linux-2.6.15-rc5/drivers/media/dvb/frontends/nxt200x.c	2005-12-18 22:27:55.059629412 -0800
+++ linux-2.6.15-rc6/drivers/media/dvb/frontends/nxt200x.c	2005-12-18 22:28:03.914023921 -0800
@@ -339,7 +339,7 @@
 	switch (state->demod_chip) {
 		case NXT2004:
 			if (i2c_writebytes(state, state->config->pll_address, data, 4))
-	        	        printk(KERN_WARNING "nxt200x: error writing to tuner\n");
+				printk(KERN_WARNING "nxt200x: error writing to tuner\n");
 			/* wait until we have a lock */
 			while (count < 20) {
 				i2c_readbytes(state, state->config->pll_address, &buf, 1);
@@ -497,7 +497,7 @@
 
 	/* calculate firmware CRC */
 	for (position = 0; position < fw->size; position++) {
-	        crc = nxt200x_crc(crc, fw->data[position]);
+		crc = nxt200x_crc(crc, fw->data[position]);
 	}
 
 	buf[0] = rambase >> 8;
diff -urN linux-2.6.15-rc5/drivers/media/dvb/frontends/nxt6000.c linux-2.6.15-rc6/drivers/media/dvb/frontends/nxt6000.c
--- linux-2.6.15-rc5/drivers/media/dvb/frontends/nxt6000.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/media/dvb/frontends/nxt6000.c	2005-12-18 22:28:03.915023966 -0800
@@ -574,11 +574,11 @@
 		.symbol_rate_max = 9360000,	/* FIXME */
 		.symbol_rate_tolerance = 4000,
 		.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
-	                FE_CAN_FEC_4_5 | FE_CAN_FEC_5_6 | FE_CAN_FEC_6_7 |
-	                FE_CAN_FEC_7_8 | FE_CAN_FEC_8_9 | FE_CAN_FEC_AUTO |
-	                FE_CAN_QAM_16 | FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |
-	                FE_CAN_TRANSMISSION_MODE_AUTO | FE_CAN_GUARD_INTERVAL_AUTO |
-	                FE_CAN_HIERARCHY_AUTO,
+		        FE_CAN_FEC_4_5 | FE_CAN_FEC_5_6 | FE_CAN_FEC_6_7 |
+		        FE_CAN_FEC_7_8 | FE_CAN_FEC_8_9 | FE_CAN_FEC_AUTO |
+		        FE_CAN_QAM_16 | FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |
+		        FE_CAN_TRANSMISSION_MODE_AUTO | FE_CAN_GUARD_INTERVAL_AUTO |
+		        FE_CAN_HIERARCHY_AUTO,
 	},
 
 	.release = nxt6000_release,
diff -urN linux-2.6.15-rc5/drivers/media/dvb/frontends/or51132.c linux-2.6.15-rc6/drivers/media/dvb/frontends/or51132.c
--- linux-2.6.15-rc5/drivers/media/dvb/frontends/or51132.c	2005-12-18 22:27:55.060629456 -0800
+++ linux-2.6.15-rc6/drivers/media/dvb/frontends/or51132.c	2005-12-18 22:28:03.916024011 -0800
@@ -503,7 +503,7 @@
 	rcvr_stat = rec_buf[1];
 	usK = (rcvr_stat & 0x10) ? 3 : 0;
 
-        /* The value reported back from the frontend will be FFFF=100% 0000=0% */
+	/* The value reported back from the frontend will be FFFF=100% 0000=0% */
 	signal_strength = (((8952 - i20Log10(snr_equ) - usK*100)/3+5)*65535)/1000;
 	if (signal_strength > 0xffff)
 		*strength = 0xffff;
diff -urN linux-2.6.15-rc5/drivers/media/dvb/frontends/s5h1420.c linux-2.6.15-rc6/drivers/media/dvb/frontends/s5h1420.c
--- linux-2.6.15-rc5/drivers/media/dvb/frontends/s5h1420.c	2005-12-18 22:27:55.061629501 -0800
+++ linux-2.6.15-rc6/drivers/media/dvb/frontends/s5h1420.c	2005-12-18 22:28:03.917024055 -0800
@@ -494,7 +494,7 @@
 }
 
 static void s5h1420_setfec_inversion(struct s5h1420_state* state,
-			   	     struct dvb_frontend_parameters *p)
+				     struct dvb_frontend_parameters *p)
 {
 	u8 inversion = 0;
 
@@ -521,8 +521,8 @@
 
 		case FEC_3_4:
 			s5h1420_writereg(state, 0x30, 0x04);
-                        s5h1420_writereg(state, 0x31, 0x12 | inversion);
-                        break;
+		        s5h1420_writereg(state, 0x31, 0x12 | inversion);
+		        break;
 
 		case FEC_5_6:
 			s5h1420_writereg(state, 0x30, 0x08);
diff -urN linux-2.6.15-rc5/drivers/media/dvb/frontends/s5h1420.h linux-2.6.15-rc6/drivers/media/dvb/frontends/s5h1420.h
--- linux-2.6.15-rc5/drivers/media/dvb/frontends/s5h1420.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/media/dvb/frontends/s5h1420.h	2005-12-18 22:28:03.917024055 -0800
@@ -39,6 +39,6 @@
 };
 
 extern struct dvb_frontend* s5h1420_attach(const struct s5h1420_config* config,
-             struct i2c_adapter* i2c);
+	     struct i2c_adapter* i2c);
 
 #endif // S5H1420_H
diff -urN linux-2.6.15-rc5/drivers/media/dvb/frontends/sp8870.c linux-2.6.15-rc6/drivers/media/dvb/frontends/sp8870.c
--- linux-2.6.15-rc5/drivers/media/dvb/frontends/sp8870.c	2005-12-18 22:27:55.061629501 -0800
+++ linux-2.6.15-rc6/drivers/media/dvb/frontends/sp8870.c	2005-12-18 22:28:03.917024055 -0800
@@ -67,16 +67,16 @@
 
 static int sp8870_writereg (struct sp8870_state* state, u16 reg, u16 data)
 {
-        u8 buf [] = { reg >> 8, reg & 0xff, data >> 8, data & 0xff };
+	u8 buf [] = { reg >> 8, reg & 0xff, data >> 8, data & 0xff };
 	struct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = buf, .len = 4 };
 	int err;
 
-        if ((err = i2c_transfer (state->i2c, &msg, 1)) != 1) {
+	if ((err = i2c_transfer (state->i2c, &msg, 1)) != 1) {
 		dprintk ("%s: writereg error (err == %i, reg == 0x%02x, data == 0x%02x)\n", __FUNCTION__, err, reg, data);
 		return -EREMOTEIO;
 	}
 
-        return 0;
+	return 0;
 }
 
 static int sp8870_readreg (struct sp8870_state* state, u16 reg)
@@ -305,7 +305,7 @@
 static int sp8870_init (struct dvb_frontend* fe)
 {
 	struct sp8870_state* state = fe->demodulator_priv;
-        const struct firmware *fw = NULL;
+	const struct firmware *fw = NULL;
 
 	sp8870_wake_up(state);
 	if (state->initialised) return 0;
@@ -534,10 +534,10 @@
 
 static int sp8870_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings* fesettings)
 {
-        fesettings->min_delay_ms = 350;
-        fesettings->step_size = 0;
-        fesettings->max_drift = 0;
-        return 0;
+	fesettings->min_delay_ms = 350;
+	fesettings->step_size = 0;
+	fesettings->max_drift = 0;
+	return 0;
 }
 
 static void sp8870_release(struct dvb_frontend* fe)
diff -urN linux-2.6.15-rc5/drivers/media/dvb/frontends/sp887x.c linux-2.6.15-rc6/drivers/media/dvb/frontends/sp887x.c
--- linux-2.6.15-rc5/drivers/media/dvb/frontends/sp887x.c	2005-12-18 22:27:55.062629546 -0800
+++ linux-2.6.15-rc6/drivers/media/dvb/frontends/sp887x.c	2005-12-18 22:28:03.918024100 -0800
@@ -80,7 +80,7 @@
 	u8 b1 [2];
 	int ret;
 	struct i2c_msg msg[] = {{ .addr = state->config->demod_address, .flags = 0, .buf = b0, .len = 2 },
-		         { .addr = state->config->demod_address, .flags = I2C_M_RD, .buf = b1, .len = 2 }};
+			 { .addr = state->config->demod_address, .flags = I2C_M_RD, .buf = b1, .len = 2 }};
 
 	if ((ret = i2c_transfer(state->i2c, msg, 2)) != 2) {
 		printk("%s: readreg error (ret == %i)\n", __FUNCTION__, ret);
@@ -498,7 +498,7 @@
 static int sp887x_init(struct dvb_frontend* fe)
 {
 	struct sp887x_state* state = fe->demodulator_priv;
-        const struct firmware *fw = NULL;
+	const struct firmware *fw = NULL;
 	int ret;
 
 	if (!state->initialised) {
@@ -528,10 +528,10 @@
 
 static int sp887x_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings* fesettings)
 {
-        fesettings->min_delay_ms = 350;
-        fesettings->step_size = 166666*2;
-        fesettings->max_drift = (166666*2)+1;
-        return 0;
+	fesettings->min_delay_ms = 350;
+	fesettings->step_size = 166666*2;
+	fesettings->max_drift = (166666*2)+1;
+	return 0;
 }
 
 static void sp887x_release(struct dvb_frontend* fe)
@@ -581,7 +581,7 @@
 		.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
 			FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
 			FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 |
-	                FE_CAN_RECOVER
+		        FE_CAN_RECOVER
 	},
 
 	.release = sp887x_release,
diff -urN linux-2.6.15-rc5/drivers/media/dvb/frontends/stv0299.c linux-2.6.15-rc6/drivers/media/dvb/frontends/stv0299.c
--- linux-2.6.15-rc5/drivers/media/dvb/frontends/stv0299.c	2005-12-18 22:27:55.063629590 -0800
+++ linux-2.6.15-rc6/drivers/media/dvb/frontends/stv0299.c	2005-12-18 22:28:03.919024144 -0800
@@ -95,7 +95,7 @@
 
 int stv0299_writereg (struct dvb_frontend* fe, u8 reg, u8 data)
 {
-        struct stv0299_state* state = fe->demodulator_priv;
+	struct stv0299_state* state = fe->demodulator_priv;
 
 	return stv0299_writeregI(state, reg, data);
 }
@@ -220,7 +220,7 @@
 
 static int stv0299_set_symbolrate (struct dvb_frontend* fe, u32 srate)
 {
-        struct stv0299_state* state = fe->demodulator_priv;
+	struct stv0299_state* state = fe->demodulator_priv;
 	u64 big = srate;
 	u32 ratio;
 
@@ -271,7 +271,7 @@
 static int stv0299_send_diseqc_msg (struct dvb_frontend* fe,
 				    struct dvb_diseqc_master_cmd *m)
 {
-        struct stv0299_state* state = fe->demodulator_priv;
+	struct stv0299_state* state = fe->demodulator_priv;
 	u8 val;
 	int i;
 
@@ -301,7 +301,7 @@
 
 static int stv0299_send_diseqc_burst (struct dvb_frontend* fe, fe_sec_mini_cmd_t burst)
 {
-        struct stv0299_state* state = fe->demodulator_priv;
+	struct stv0299_state* state = fe->demodulator_priv;
 	u8 val;
 
 	dprintk ("%s\n", __FUNCTION__);
@@ -328,7 +328,7 @@
 
 static int stv0299_set_tone (struct dvb_frontend* fe, fe_sec_tone_mode_t tone)
 {
-        struct stv0299_state* state = fe->demodulator_priv;
+	struct stv0299_state* state = fe->demodulator_priv;
 	u8 val;
 
 	if (stv0299_wait_diseqc_idle (state, 100) < 0)
@@ -350,7 +350,7 @@
 
 static int stv0299_set_voltage (struct dvb_frontend* fe, fe_sec_voltage_t voltage)
 {
-        struct stv0299_state* state = fe->demodulator_priv;
+	struct stv0299_state* state = fe->demodulator_priv;
 	u8 reg0x08;
 	u8 reg0x0c;
 
@@ -442,7 +442,7 @@
 
 static int stv0299_init (struct dvb_frontend* fe)
 {
-        struct stv0299_state* state = fe->demodulator_priv;
+	struct stv0299_state* state = fe->demodulator_priv;
 	int i;
 
 	dprintk("stv0299: init chip\n");
@@ -461,7 +461,7 @@
 
 static int stv0299_read_status(struct dvb_frontend* fe, fe_status_t* status)
 {
-        struct stv0299_state* state = fe->demodulator_priv;
+	struct stv0299_state* state = fe->demodulator_priv;
 
 	u8 signal = 0xff - stv0299_readreg (state, 0x18);
 	u8 sync = stv0299_readreg (state, 0x1b);
@@ -489,7 +489,7 @@
 
 static int stv0299_read_ber(struct dvb_frontend* fe, u32* ber)
 {
-        struct stv0299_state* state = fe->demodulator_priv;
+	struct stv0299_state* state = fe->demodulator_priv;
 
 	if (state->errmode != STATUS_BER) return 0;
 	*ber = (stv0299_readreg (state, 0x1d) << 8) | stv0299_readreg (state, 0x1e);
@@ -499,7 +499,7 @@
 
 static int stv0299_read_signal_strength(struct dvb_frontend* fe, u16* strength)
 {
-        struct stv0299_state* state = fe->demodulator_priv;
+	struct stv0299_state* state = fe->demodulator_priv;
 
 	s32 signal =  0xffff - ((stv0299_readreg (state, 0x18) << 8)
 			       | stv0299_readreg (state, 0x19));
@@ -516,7 +516,7 @@
 
 static int stv0299_read_snr(struct dvb_frontend* fe, u16* snr)
 {
-        struct stv0299_state* state = fe->demodulator_priv;
+	struct stv0299_state* state = fe->demodulator_priv;
 
 	s32 xsnr = 0xffff - ((stv0299_readreg (state, 0x24) << 8)
 			   | stv0299_readreg (state, 0x25));
@@ -528,7 +528,7 @@
 
 static int stv0299_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)
 {
-        struct stv0299_state* state = fe->demodulator_priv;
+	struct stv0299_state* state = fe->demodulator_priv;
 
 	if (state->errmode != STATUS_UCBLOCKS) *ucblocks = 0;
 	else *ucblocks = (stv0299_readreg (state, 0x1d) << 8) | stv0299_readreg (state, 0x1e);
@@ -538,7 +538,7 @@
 
 static int stv0299_set_frontend(struct dvb_frontend* fe, struct dvb_frontend_parameters * p)
 {
-        struct stv0299_state* state = fe->demodulator_priv;
+	struct stv0299_state* state = fe->demodulator_priv;
 	int invval = 0;
 
 	dprintk ("%s : FE_SET_FRONTEND\n", __FUNCTION__);
@@ -571,7 +571,7 @@
 
 static int stv0299_get_frontend(struct dvb_frontend* fe, struct dvb_frontend_parameters * p)
 {
-        struct stv0299_state* state = fe->demodulator_priv;
+	struct stv0299_state* state = fe->demodulator_priv;
 	s32 derot_freq;
 	int invval;
 
@@ -596,7 +596,7 @@
 
 static int stv0299_sleep(struct dvb_frontend* fe)
 {
-        struct stv0299_state* state = fe->demodulator_priv;
+	struct stv0299_state* state = fe->demodulator_priv;
 
 	stv0299_writeregI(state, 0x02, 0x80);
 	state->initialised = 0;
@@ -606,7 +606,7 @@
 
 static int stv0299_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings* fesettings)
 {
-        struct stv0299_state* state = fe->demodulator_priv;
+	struct stv0299_state* state = fe->demodulator_priv;
 
 	fesettings->min_delay_ms = state->config->min_delay_ms;
 	if (fesettings->parameters.u.qpsk.symbol_rate < 10000000) {
@@ -658,7 +658,7 @@
 
 	/* create dvb_frontend */
 	state->frontend.ops = &state->ops;
-        state->frontend.demodulator_priv = state;
+	state->frontend.demodulator_priv = state;
 	return &state->frontend;
 
 error:
@@ -714,7 +714,7 @@
 
 MODULE_DESCRIPTION("ST STV0299 DVB Demodulator driver");
 MODULE_AUTHOR("Ralph Metzler, Holger Waechtler, Peter Schildmann, Felix Domke, "
-              "Andreas Oberritter, Andrew de Quincey, Kenneth Aafly");
+	      "Andreas Oberritter, Andrew de Quincey, Kenneth Aafly");
 MODULE_LICENSE("GPL");
 
 EXPORT_SYMBOL(stv0299_writereg);
diff -urN linux-2.6.15-rc5/drivers/media/dvb/frontends/tda10021.c linux-2.6.15-rc6/drivers/media/dvb/frontends/tda10021.c
--- linux-2.6.15-rc5/drivers/media/dvb/frontends/tda10021.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/media/dvb/frontends/tda10021.c	2005-12-18 22:28:03.920024189 -0800
@@ -1,10 +1,10 @@
 /*
     TDA10021  - Single Chip Cable Channel Receiver driver module
-               used on the the Siemens DVB-C cards
+	       used on the the Siemens DVB-C cards
 
     Copyright (C) 1999 Convergence Integrated Media GmbH <ralph@convergence.de>
     Copyright (C) 2004 Markus Schulz <msc@antzsystem.de>
-                   Support for TDA10021
+		   Support for TDA10021
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
@@ -76,9 +76,9 @@
 
 static int tda10021_writereg (struct tda10021_state* state, u8 reg, u8 data)
 {
-        u8 buf[] = { reg, data };
+	u8 buf[] = { reg, data };
 	struct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = buf, .len = 2 };
-        int ret;
+	int ret;
 
 	ret = i2c_transfer (state->i2c, &msg, 1);
 	if (ret != 1)
@@ -95,7 +95,7 @@
 	u8 b0 [] = { reg };
 	u8 b1 [] = { 0 };
 	struct i2c_msg msg [] = { { .addr = state->config->demod_address, .flags = 0, .buf = b0, .len = 1 },
-	                          { .addr = state->config->demod_address, .flags = I2C_M_RD, .buf = b1, .len = 1 } };
+		                  { .addr = state->config->demod_address, .flags = I2C_M_RD, .buf = b1, .len = 1 } };
 	int ret;
 
 	ret = i2c_transfer (state->i2c, msg, 2);
diff -urN linux-2.6.15-rc5/drivers/media/dvb/frontends/tda10021.h linux-2.6.15-rc6/drivers/media/dvb/frontends/tda10021.h
--- linux-2.6.15-rc5/drivers/media/dvb/frontends/tda10021.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/media/dvb/frontends/tda10021.h	2005-12-18 22:28:03.920024189 -0800
@@ -1,10 +1,10 @@
 /*
     TDA10021  - Single Chip Cable Channel Receiver driver module
-               used on the the Siemens DVB-C cards
+	       used on the the Siemens DVB-C cards
 
     Copyright (C) 1999 Convergence Integrated Media GmbH <ralph@convergence.de>
     Copyright (C) 2004 Markus Schulz <msc@antzsystem.de>
-                   Support for TDA10021
+		   Support for TDA10021
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
diff -urN linux-2.6.15-rc5/drivers/media/dvb/frontends/tda1004x.c linux-2.6.15-rc6/drivers/media/dvb/frontends/tda1004x.c
--- linux-2.6.15-rc5/drivers/media/dvb/frontends/tda1004x.c	2005-12-18 22:27:55.064629635 -0800
+++ linux-2.6.15-rc6/drivers/media/dvb/frontends/tda1004x.c	2005-12-18 22:28:03.921024233 -0800
@@ -475,7 +475,7 @@
 		ret = state->config->request_firmware(fe, &fw, TDA10046_DEFAULT_FIRMWARE);
 		if (ret) {
 			printk(KERN_ERR "tda1004x: no firmware upload (timeout or file not found?)\n");
-   	   		return ret;
+			return ret;
 		}
 		tda1004x_write_mask(state, TDA1004X_CONFC4, 8, 8); // going to boot from HOST
 		ret = tda1004x_do_upload(state, fw->data, fw->size, TDA10046H_CODE_CPT, TDA10046H_CODE_IN);
diff -urN linux-2.6.15-rc5/drivers/media/dvb/frontends/tda8083.c linux-2.6.15-rc6/drivers/media/dvb/frontends/tda8083.c
--- linux-2.6.15-rc5/drivers/media/dvb/frontends/tda8083.c	2005-12-18 22:27:55.064629635 -0800
+++ linux-2.6.15-rc6/drivers/media/dvb/frontends/tda8083.c	2005-12-18 22:28:03.921024233 -0800
@@ -66,13 +66,13 @@
 	u8 buf [] = { reg, data };
 	struct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = buf, .len = 2 };
 
-        ret = i2c_transfer(state->i2c, &msg, 1);
+	ret = i2c_transfer(state->i2c, &msg, 1);
 
-        if (ret != 1)
-                dprintk ("%s: writereg error (reg %02x, ret == %i)\n",
+	if (ret != 1)
+		dprintk ("%s: writereg error (reg %02x, ret == %i)\n",
 			__FUNCTION__, reg, ret);
 
-        return (ret != 1) ? -1 : 0;
+	return (ret != 1) ? -1 : 0;
 }
 
 static int tda8083_readregs (struct tda8083_state* state, u8 reg1, u8 *b, u8 len)
@@ -87,7 +87,7 @@
 		dprintk ("%s: readreg error (reg %02x, ret == %i)\n",
 			__FUNCTION__, reg1, ret);
 
-        return ret == 2 ? 0 : -1;
+	return ret == 2 ? 0 : -1;
 }
 
 static inline u8 tda8083_readreg (struct tda8083_state* state, u8 reg)
@@ -132,14 +132,14 @@
 
 static int tda8083_set_symbolrate (struct tda8083_state* state, u32 srate)
 {
-        u32 ratio;
+	u32 ratio;
 	u32 tmp;
 	u8 filter;
 
 	if (srate > 32000000)
-                srate = 32000000;
-        if (srate < 500000)
-                srate = 500000;
+		srate = 32000000;
+	if (srate < 500000)
+		srate = 500000;
 
 	filter = 0;
 	if (srate < 24000000)
@@ -174,7 +174,7 @@
 	unsigned long start = jiffies;
 
 	while (jiffies - start < timeout &&
-               !(tda8083_readreg(state, 0x02) & 0x80))
+	       !(tda8083_readreg(state, 0x02) & 0x80))
 	{
 		msleep(50);
 	};
diff -urN linux-2.6.15-rc5/drivers/media/dvb/ttpci/av7110.c linux-2.6.15-rc6/drivers/media/dvb/ttpci/av7110.c
--- linux-2.6.15-rc5/drivers/media/dvb/ttpci/av7110.c	2005-12-18 22:27:55.066629724 -0800
+++ linux-2.6.15-rc6/drivers/media/dvb/ttpci/av7110.c	2005-12-18 22:28:03.924024367 -0800
@@ -217,10 +217,10 @@
 
 	dprintk(4, "%p\n",av7110);
 
-        lock_kernel();
-        daemonize("arm_mon");
-        sigfillset(&current->blocked);
-        unlock_kernel();
+	lock_kernel();
+	daemonize("arm_mon");
+	sigfillset(&current->blocked);
+	unlock_kernel();
 
 	av7110->arm_thread = current;
 
@@ -1535,7 +1535,7 @@
 	buf[2] = ((div & 0x18000) >> 10) | 0x95;
 	buf[3] = (pwr << 6) | 0x30;
 
-        // NOTE: since we're using a prescaler of 2, we set the
+	// NOTE: since we're using a prescaler of 2, we set the
 	// divisor frequency to 62.5kHz and divide by 125 above
 
 	if (i2c_transfer (&av7110->i2c_adap, &msg, 1) != 1)
@@ -1811,7 +1811,7 @@
 static int philips_cd1516_pll_set(struct dvb_frontend* fe,
 				  struct dvb_frontend_parameters* params)
 {
-        struct av7110* av7110 = fe->dvb->priv;
+	struct av7110* av7110 = fe->dvb->priv;
 	u32 div;
 	u32 f = params->frequency;
 	u8 data[4];
@@ -2202,7 +2202,7 @@
 	struct i2c_msg msg[] = { { .addr = 0x50,.flags = 0,.buf = &b,.len = 1 },
 				 { .addr = 0x50,.flags = I2C_M_RD,.buf = &pwm,.len = 1} };
 
-        if ((i2c_transfer(&av7110->i2c_adap, msg, 2) != 2) || (pwm == 0xff))
+	if ((i2c_transfer(&av7110->i2c_adap, msg, 2) != 2) || (pwm == 0xff))
 		pwm = 0x48;
 
 	return pwm;
@@ -2245,7 +2245,7 @@
 			}
 
 			// Try the grundig 29504-451
-                        av7110->fe = tda8083_attach(&grundig_29504_451_config, &av7110->i2c_adap);
+		        av7110->fe = tda8083_attach(&grundig_29504_451_config, &av7110->i2c_adap);
 			if (av7110->fe) {
 				av7110->fe->ops->diseqc_send_master_cmd = av7110_diseqc_send_master_cmd;
 				av7110->fe->ops->diseqc_send_burst = av7110_diseqc_send_burst;
@@ -2271,12 +2271,12 @@
 		case 0x0001: // Hauppauge/TT Nexus-T premium rev1.X
 
 			// ALPS TDLB7
-                        av7110->fe = sp8870_attach(&alps_tdlb7_config, &av7110->i2c_adap);
+		        av7110->fe = sp8870_attach(&alps_tdlb7_config, &av7110->i2c_adap);
 			break;
 
 		case 0x0002: // Hauppauge/TT DVB-C premium rev2.X
 
-                        av7110->fe = ves1820_attach(&alps_tdbe2_config, &av7110->i2c_adap, read_pwm(av7110));
+		        av7110->fe = ves1820_attach(&alps_tdbe2_config, &av7110->i2c_adap, read_pwm(av7110));
 			break;
 
 		case 0x0006: /* Fujitsu-Siemens DVB-S rev 1.6 */
@@ -2421,9 +2421,9 @@
 
 	dprintk(4, "dev: %p\n", dev);
 
-        /* Set RPS_IRQ to 1 to track rps1 activity.
-         * Enabling this won't send any interrupt to PC CPU.
-         */
+	/* Set RPS_IRQ to 1 to track rps1 activity.
+	 * Enabling this won't send any interrupt to PC CPU.
+	 */
 #define RPS_IRQ 0
 
 	if (budgetpatch == 1) {
diff -urN linux-2.6.15-rc5/drivers/media/dvb/ttpci/av7110_hw.c linux-2.6.15-rc6/drivers/media/dvb/ttpci/av7110_hw.c
--- linux-2.6.15-rc5/drivers/media/dvb/ttpci/av7110_hw.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/media/dvb/ttpci/av7110_hw.c	2005-12-18 22:28:03.925024412 -0800
@@ -1203,15 +1203,15 @@
 
 int av7110_osd_capability(struct av7110 *av7110, osd_cap_t *cap)
 {
-        switch (cap->cmd) {
-        case OSD_CAP_MEMSIZE:
-                if (FW_4M_SDRAM(av7110->arm_app))
-                        cap->val = 1000000;
-                else
-                        cap->val = 92000;
-                return 0;
-        default:
-                return -EINVAL;
-        }
+	switch (cap->cmd) {
+	case OSD_CAP_MEMSIZE:
+		if (FW_4M_SDRAM(av7110->arm_app))
+		        cap->val = 1000000;
+		else
+		        cap->val = 92000;
+		return 0;
+	default:
+		return -EINVAL;
+	}
 }
 #endif /* CONFIG_DVB_AV7110_OSD */
diff -urN linux-2.6.15-rc5/drivers/media/dvb/ttpci/av7110_v4l.c linux-2.6.15-rc6/drivers/media/dvb/ttpci/av7110_v4l.c
--- linux-2.6.15-rc5/drivers/media/dvb/ttpci/av7110_v4l.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/media/dvb/ttpci/av7110_v4l.c	2005-12-18 22:28:03.926024456 -0800
@@ -120,8 +120,8 @@
 
 static int stv0297_writereg(struct saa7146_dev *dev, u8 addr, u8 reg, u8 data)
 {
-        u8 buf [] = { reg, data };
-        struct i2c_msg msg = { .addr = addr, .flags = 0, .buf = buf, .len = 2 };
+	u8 buf [] = { reg, data };
+	struct i2c_msg msg = { .addr = addr, .flags = 0, .buf = buf, .len = 2 };
 
 	if (1 != saa7146_i2c_transfer(dev, &msg, 1, 1))
 		return -1;
diff -urN linux-2.6.15-rc5/drivers/media/dvb/ttpci/budget-core.c linux-2.6.15-rc6/drivers/media/dvb/ttpci/budget-core.c
--- linux-2.6.15-rc5/drivers/media/dvb/ttpci/budget-core.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/media/dvb/ttpci/budget-core.c	2005-12-18 22:28:03.928024545 -0800
@@ -87,7 +87,7 @@
 	 *      Pitch: 188, NumBytes3: 188, NumLines3: 1024
 	 */
 
-        switch(budget->card->type) {
+	switch(budget->card->type) {
 	case BUDGET_FS_ACTIVY:
 		saa7146_write(dev, DD1_INIT, 0x04000000);
 		saa7146_write(dev, MC2, (MASK_09 | MASK_25));
diff -urN linux-2.6.15-rc5/drivers/media/dvb/ttpci/budget-patch.c linux-2.6.15-rc6/drivers/media/dvb/ttpci/budget-patch.c
--- linux-2.6.15-rc5/drivers/media/dvb/ttpci/budget-patch.c	2005-12-18 22:27:55.069629857 -0800
+++ linux-2.6.15-rc6/drivers/media/dvb/ttpci/budget-patch.c	2005-12-18 22:28:03.929024590 -0800
@@ -45,11 +45,11 @@
 //MAKE_BUDGET_INFO(satel,"TT-Budget/Patch SATELCO PCI", BUDGET_TT_HW_DISEQC);
 
 static struct pci_device_id pci_tbl[] = {
-        MAKE_EXTENSION_PCI(ttbp,0x13c2, 0x0000),
+	MAKE_EXTENSION_PCI(ttbp,0x13c2, 0x0000),
 //        MAKE_EXTENSION_PCI(satel, 0x13c2, 0x1013),
-        {
-                .vendor    = 0,
-        }
+	{
+		.vendor    = 0,
+	}
 };
 
 /* those lines are for budget-patch to be tried
@@ -165,57 +165,57 @@
 
 static int budget_av7110_send_fw_cmd(struct budget_patch *budget, u16* buf, int length)
 {
-        int i;
+	int i;
 
-        dprintk(2, "budget: %p\n", budget);
+	dprintk(2, "budget: %p\n", budget);
 
-        for (i = 2; i < length; i++)
-        {
-                  ttpci_budget_debiwrite(budget, DEBINOSWAP, COMMAND + 2*i, 2, (u32) buf[i], 0,0);
-                  msleep(5);
-        }
-        if (length)
-                  ttpci_budget_debiwrite(budget, DEBINOSWAP, COMMAND + 2, 2, (u32) buf[1], 0,0);
-        else
-                  ttpci_budget_debiwrite(budget, DEBINOSWAP, COMMAND + 2, 2, 0, 0,0);
-        msleep(5);
-        ttpci_budget_debiwrite(budget, DEBINOSWAP, COMMAND, 2, (u32) buf[0], 0,0);
-        msleep(5);
-        return 0;
+	for (i = 2; i < length; i++)
+	{
+		  ttpci_budget_debiwrite(budget, DEBINOSWAP, COMMAND + 2*i, 2, (u32) buf[i], 0,0);
+		  msleep(5);
+	}
+	if (length)
+		  ttpci_budget_debiwrite(budget, DEBINOSWAP, COMMAND + 2, 2, (u32) buf[1], 0,0);
+	else
+		  ttpci_budget_debiwrite(budget, DEBINOSWAP, COMMAND + 2, 2, 0, 0,0);
+	msleep(5);
+	ttpci_budget_debiwrite(budget, DEBINOSWAP, COMMAND, 2, (u32) buf[0], 0,0);
+	msleep(5);
+	return 0;
 }
 
 static void av7110_set22k(struct budget_patch *budget, int state)
 {
-        u16 buf[2] = {( COMTYPE_AUDIODAC << 8) | (state ? ON22K : OFF22K), 0};
+	u16 buf[2] = {( COMTYPE_AUDIODAC << 8) | (state ? ON22K : OFF22K), 0};
 
-        dprintk(2, "budget: %p\n", budget);
-        budget_av7110_send_fw_cmd(budget, buf, 2);
+	dprintk(2, "budget: %p\n", budget);
+	budget_av7110_send_fw_cmd(budget, buf, 2);
 }
 
 static int av7110_send_diseqc_msg(struct budget_patch *budget, int len, u8 *msg, int burst)
 {
-        int i;
-        u16 buf[18] = { ((COMTYPE_AUDIODAC << 8) | SendDiSEqC),
-                16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+	int i;
+	u16 buf[18] = { ((COMTYPE_AUDIODAC << 8) | SendDiSEqC),
+		16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 
-        dprintk(2, "budget: %p\n", budget);
+	dprintk(2, "budget: %p\n", budget);
 
-        if (len>10)
-                len=10;
+	if (len>10)
+		len=10;
 
-        buf[1] = len+2;
-        buf[2] = len;
+	buf[1] = len+2;
+	buf[2] = len;
 
-        if (burst != -1)
-                buf[3]=burst ? 0x01 : 0x00;
-        else
-                buf[3]=0xffff;
+	if (burst != -1)
+		buf[3]=burst ? 0x01 : 0x00;
+	else
+		buf[3]=0xffff;
 
-        for (i=0; i<len; i++)
-                buf[i+4]=msg[i];
+	for (i=0; i<len; i++)
+		buf[i+4]=msg[i];
 
-        budget_av7110_send_fw_cmd(budget, buf, 18);
-        return 0;
+	budget_av7110_send_fw_cmd(budget, buf, 18);
+	return 0;
 }
 
 static int budget_patch_set_tone(struct dvb_frontend* fe, fe_sec_tone_mode_t tone)
@@ -276,7 +276,7 @@
 	buf[2] = ((div & 0x18000) >> 10) | 0x95;
 	buf[3] = (pwr << 6) | 0x30;
 
-        // NOTE: since we're using a prescaler of 2, we set the
+	// NOTE: since we're using a prescaler of 2, we set the
 	// divisor frequency to 62.5kHz and divide by 125 above
 
 	if (i2c_transfer (&budget->i2c_adap, &msg, 1) != 1) return -EIO;
@@ -294,7 +294,7 @@
 	0x01, 0x15,
 	0x02, 0x00,
 	0x03, 0x00,
-        0x04, 0x7d,   /* F22FR = 0x7d, F22 = f_VCO / 128 / 0x7d = 22 kHz */
+	0x04, 0x7d,   /* F22FR = 0x7d, F22 = f_VCO / 128 / 0x7d = 22 kHz */
 	0x05, 0x35,   /* I2CT = 0, SCLT = 1, SDAT = 1 */
 	0x06, 0x40,   /* DAC not used, set to high impendance mode */
 	0x07, 0x00,   /* DAC LSB */
@@ -413,7 +413,7 @@
 {
 	switch(budget->dev->pci->subsystem_device) {
 	case 0x0000: // Hauppauge/TT WinTV DVB-S rev1.X
-        case 0x1013: // SATELCO Multimedia PCI
+	case 0x1013: // SATELCO Multimedia PCI
 
 		// try the ALPS BSRV2 first of all
 		budget->dvb_frontend = ves1x93_attach(&alps_bsrv2_config, &budget->i2c_adap);
@@ -463,8 +463,8 @@
 /* written by Emard */
 static int budget_patch_attach (struct saa7146_dev* dev, struct saa7146_pci_extension_data *info)
 {
-        struct budget_patch *budget;
-        int err;
+	struct budget_patch *budget;
+	int err;
 	int count = 0;
 	int detected = 0;
 
@@ -472,12 +472,12 @@
 #define RPS_IRQ 0
 #define HPS_SETUP 0
 #if PATCH_RESET
-        saa7146_write(dev, MC1, MASK_31);
-        msleep(40);
+	saa7146_write(dev, MC1, MASK_31);
+	msleep(40);
 #endif
 #if HPS_SETUP
-        // initialize registers. Better to have it like this
-        // than leaving something unconfigured
+	// initialize registers. Better to have it like this
+	// than leaving something unconfigured
 	saa7146_write(dev, DD1_STREAM_B, 0);
 	// port B VSYNC at rising edge
 	saa7146_write(dev, DD1_INIT, 0x00000200);  // have this in budget-core too!
@@ -486,29 +486,29 @@
 	// debi config
 	// saa7146_write(dev, DEBI_CONFIG, MASK_30|MASK_28|MASK_18);
 
-        // zero all HPS registers
-        saa7146_write(dev, HPS_H_PRESCALE, 0);                  // r68
-        saa7146_write(dev, HPS_H_SCALE, 0);                     // r6c
-        saa7146_write(dev, BCS_CTRL, 0);                        // r70
-        saa7146_write(dev, HPS_V_SCALE, 0);                     // r60
-        saa7146_write(dev, HPS_V_GAIN, 0);                      // r64
-        saa7146_write(dev, CHROMA_KEY_RANGE, 0);                // r74
-        saa7146_write(dev, CLIP_FORMAT_CTRL, 0);                // r78
-        // Set HPS prescaler for port B input
-        saa7146_write(dev, HPS_CTRL, (1<<30) | (0<<29) | (1<<28) | (0<<12) );
-        saa7146_write(dev, MC2,
-          0 * (MASK_08 | MASK_24)  |   // BRS control
-          0 * (MASK_09 | MASK_25)  |   // a
-          0 * (MASK_10 | MASK_26)  |   // b
-          1 * (MASK_06 | MASK_22)  |   // HPS_CTRL1
-          1 * (MASK_05 | MASK_21)  |   // HPS_CTRL2
-          0 * (MASK_01 | MASK_15)      // DEBI
-           );
+	// zero all HPS registers
+	saa7146_write(dev, HPS_H_PRESCALE, 0);                  // r68
+	saa7146_write(dev, HPS_H_SCALE, 0);                     // r6c
+	saa7146_write(dev, BCS_CTRL, 0);                        // r70
+	saa7146_write(dev, HPS_V_SCALE, 0);                     // r60
+	saa7146_write(dev, HPS_V_GAIN, 0);                      // r64
+	saa7146_write(dev, CHROMA_KEY_RANGE, 0);                // r74
+	saa7146_write(dev, CLIP_FORMAT_CTRL, 0);                // r78
+	// Set HPS prescaler for port B input
+	saa7146_write(dev, HPS_CTRL, (1<<30) | (0<<29) | (1<<28) | (0<<12) );
+	saa7146_write(dev, MC2,
+	  0 * (MASK_08 | MASK_24)  |   // BRS control
+	  0 * (MASK_09 | MASK_25)  |   // a
+	  0 * (MASK_10 | MASK_26)  |   // b
+	  1 * (MASK_06 | MASK_22)  |   // HPS_CTRL1
+	  1 * (MASK_05 | MASK_21)  |   // HPS_CTRL2
+	  0 * (MASK_01 | MASK_15)      // DEBI
+	   );
 #endif
 	// Disable RPS1 and RPS0
-        saa7146_write(dev, MC1, ( MASK_29 | MASK_28));
-        // RPS1 timeout disable
-        saa7146_write(dev, RPS_TOV1, 0);
+	saa7146_write(dev, MC1, ( MASK_29 | MASK_28));
+	// RPS1 timeout disable
+	saa7146_write(dev, RPS_TOV1, 0);
 
 	// code for autodetection
 	// will wait for VBI_B event (vertical blank at port B)
@@ -521,38 +521,38 @@
 	WRITE_RPS1(cpu_to_le32(CMD_UPLOAD |
 	  MASK_10 | MASK_09 | MASK_08 | MASK_06 | MASK_05 | MASK_04 | MASK_03 | MASK_02 ));
 #endif
-        WRITE_RPS1(cpu_to_le32(CMD_PAUSE | EVT_VBI_B));
-        WRITE_RPS1(cpu_to_le32(CMD_WR_REG_MASK | (GPIO_CTRL>>2)));
-        WRITE_RPS1(cpu_to_le32(GPIO3_MSK));
-        WRITE_RPS1(cpu_to_le32(SAA7146_GPIO_OUTLO<<24));
+	WRITE_RPS1(cpu_to_le32(CMD_PAUSE | EVT_VBI_B));
+	WRITE_RPS1(cpu_to_le32(CMD_WR_REG_MASK | (GPIO_CTRL>>2)));
+	WRITE_RPS1(cpu_to_le32(GPIO3_MSK));
+	WRITE_RPS1(cpu_to_le32(SAA7146_GPIO_OUTLO<<24));
 #if RPS_IRQ
-        // issue RPS1 interrupt to increment counter
-        WRITE_RPS1(cpu_to_le32(CMD_INTERRUPT));
-        // at least a NOP is neede between two interrupts
-        WRITE_RPS1(cpu_to_le32(CMD_NOP));
-        // interrupt again
-        WRITE_RPS1(cpu_to_le32(CMD_INTERRUPT));
+	// issue RPS1 interrupt to increment counter
+	WRITE_RPS1(cpu_to_le32(CMD_INTERRUPT));
+	// at least a NOP is neede between two interrupts
+	WRITE_RPS1(cpu_to_le32(CMD_NOP));
+	// interrupt again
+	WRITE_RPS1(cpu_to_le32(CMD_INTERRUPT));
 #endif
-        WRITE_RPS1(cpu_to_le32(CMD_STOP));
+	WRITE_RPS1(cpu_to_le32(CMD_STOP));
 
 #if RPS_IRQ
-        // set event counter 1 source as RPS1 interrupt (0x03)          (rE4 p53)
-        // use 0x03 to track RPS1 interrupts - increase by 1 every gpio3 is toggled
-        // use 0x15 to track VPE  interrupts - increase by 1 every vpeirq() is called
-        saa7146_write(dev, EC1SSR, (0x03<<2) | 3 );
-        // set event counter 1 treshold to maximum allowed value        (rEC p55)
-        saa7146_write(dev, ECT1R,  0x3fff );
+	// set event counter 1 source as RPS1 interrupt (0x03)          (rE4 p53)
+	// use 0x03 to track RPS1 interrupts - increase by 1 every gpio3 is toggled
+	// use 0x15 to track VPE  interrupts - increase by 1 every vpeirq() is called
+	saa7146_write(dev, EC1SSR, (0x03<<2) | 3 );
+	// set event counter 1 treshold to maximum allowed value        (rEC p55)
+	saa7146_write(dev, ECT1R,  0x3fff );
 #endif
-        // Fix VSYNC level
-        saa7146_setgpio(dev, 3, SAA7146_GPIO_OUTLO);
-        // Set RPS1 Address register to point to RPS code               (r108 p42)
-        saa7146_write(dev, RPS_ADDR1, dev->d_rps1.dma_handle);
-        // Enable RPS1,                                                 (rFC p33)
-        saa7146_write(dev, MC1, (MASK_13 | MASK_29 ));
+	// Fix VSYNC level
+	saa7146_setgpio(dev, 3, SAA7146_GPIO_OUTLO);
+	// Set RPS1 Address register to point to RPS code               (r108 p42)
+	saa7146_write(dev, RPS_ADDR1, dev->d_rps1.dma_handle);
+	// Enable RPS1,                                                 (rFC p33)
+	saa7146_write(dev, MC1, (MASK_13 | MASK_29 ));
 
 
-        mdelay(50);
-        saa7146_setgpio(dev, 3, SAA7146_GPIO_OUTHI);
+	mdelay(50);
+	saa7146_setgpio(dev, 3, SAA7146_GPIO_OUTHI);
 	mdelay(150);
 
 
@@ -560,17 +560,17 @@
 		detected = 1;
 
 #if RPS_IRQ
-        printk("Event Counter 1 0x%04x\n", saa7146_read(dev, EC1R) & 0x3fff );
+	printk("Event Counter 1 0x%04x\n", saa7146_read(dev, EC1R) & 0x3fff );
 #endif
 	// Disable RPS1
-        saa7146_write(dev, MC1, ( MASK_29 ));
+	saa7146_write(dev, MC1, ( MASK_29 ));
 
 	if(detected == 0)
-                printk("budget-patch not detected or saa7146 in non-default state.\n"
-                       "try enabling ressetting of 7146 with MASK_31 in MC1 register\n");
+		printk("budget-patch not detected or saa7146 in non-default state.\n"
+		       "try enabling ressetting of 7146 with MASK_31 in MC1 register\n");
 
 	else
-                printk("BUDGET-PATCH DETECTED.\n");
+		printk("BUDGET-PATCH DETECTED.\n");
 
 
 /*      OLD (Original design by Roberto Deza):
@@ -641,83 +641,83 @@
 */
 
 	// Setup RPS1 "program" (p35)
-        count = 0;
+	count = 0;
 
 
-        // Wait Source Line Counter Threshold                           (p36)
-        WRITE_RPS1(cpu_to_le32(CMD_PAUSE | EVT_HS));
-        // Set GPIO3=1                                                  (p42)
-        WRITE_RPS1(cpu_to_le32(CMD_WR_REG_MASK | (GPIO_CTRL>>2)));
-        WRITE_RPS1(cpu_to_le32(GPIO3_MSK));
-        WRITE_RPS1(cpu_to_le32(SAA7146_GPIO_OUTHI<<24));
+	// Wait Source Line Counter Threshold                           (p36)
+	WRITE_RPS1(cpu_to_le32(CMD_PAUSE | EVT_HS));
+	// Set GPIO3=1                                                  (p42)
+	WRITE_RPS1(cpu_to_le32(CMD_WR_REG_MASK | (GPIO_CTRL>>2)));
+	WRITE_RPS1(cpu_to_le32(GPIO3_MSK));
+	WRITE_RPS1(cpu_to_le32(SAA7146_GPIO_OUTHI<<24));
 #if RPS_IRQ
-        // issue RPS1 interrupt
-        WRITE_RPS1(cpu_to_le32(CMD_INTERRUPT));
+	// issue RPS1 interrupt
+	WRITE_RPS1(cpu_to_le32(CMD_INTERRUPT));
 #endif
-        // Wait reset Source Line Counter Threshold                     (p36)
-        WRITE_RPS1(cpu_to_le32(CMD_PAUSE | RPS_INV | EVT_HS));
-        // Set GPIO3=0                                                  (p42)
-        WRITE_RPS1(cpu_to_le32(CMD_WR_REG_MASK | (GPIO_CTRL>>2)));
-        WRITE_RPS1(cpu_to_le32(GPIO3_MSK));
-        WRITE_RPS1(cpu_to_le32(SAA7146_GPIO_OUTLO<<24));
+	// Wait reset Source Line Counter Threshold                     (p36)
+	WRITE_RPS1(cpu_to_le32(CMD_PAUSE | RPS_INV | EVT_HS));
+	// Set GPIO3=0                                                  (p42)
+	WRITE_RPS1(cpu_to_le32(CMD_WR_REG_MASK | (GPIO_CTRL>>2)));
+	WRITE_RPS1(cpu_to_le32(GPIO3_MSK));
+	WRITE_RPS1(cpu_to_le32(SAA7146_GPIO_OUTLO<<24));
 #if RPS_IRQ
-        // issue RPS1 interrupt
-        WRITE_RPS1(cpu_to_le32(CMD_INTERRUPT));
+	// issue RPS1 interrupt
+	WRITE_RPS1(cpu_to_le32(CMD_INTERRUPT));
 #endif
-        // Jump to begin of RPS program                                 (p37)
-        WRITE_RPS1(cpu_to_le32(CMD_JUMP));
-        WRITE_RPS1(cpu_to_le32(dev->d_rps1.dma_handle));
-
-        // Fix VSYNC level
-        saa7146_setgpio(dev, 3, SAA7146_GPIO_OUTLO);
-        // Set RPS1 Address register to point to RPS code               (r108 p42)
-        saa7146_write(dev, RPS_ADDR1, dev->d_rps1.dma_handle);
-        // Set Source Line Counter Threshold, using BRS                 (rCC p43)
-        // It generates HS event every TS_HEIGHT lines
-        // this is related to TS_WIDTH set in register
-        // NUM_LINE_BYTE3 in budget-core.c. If NUM_LINE_BYTE
-        // low 16 bits are set to TS_WIDTH bytes (TS_WIDTH=2*188
-        //,then RPS_THRESH1
-        // should be set to trigger every TS_HEIGHT (512) lines.
-        //
-        saa7146_write(dev, RPS_THRESH1, (TS_HEIGHT*1) | MASK_12 );
-
-        // saa7146_write(dev, RPS_THRESH0, ((TS_HEIGHT/2)<<16) |MASK_28| (TS_HEIGHT/2) |MASK_12 );
-        // Enable RPS1                                                  (rFC p33)
-        saa7146_write(dev, MC1, (MASK_13 | MASK_29));
-
-
-        if (!(budget = kmalloc (sizeof(struct budget_patch), GFP_KERNEL)))
-                return -ENOMEM;
-
-        dprintk(2, "budget: %p\n", budget);
-
-        if ((err = ttpci_budget_init (budget, dev, info, THIS_MODULE))) {
-                kfree (budget);
-                return err;
-        }
+	// Jump to begin of RPS program                                 (p37)
+	WRITE_RPS1(cpu_to_le32(CMD_JUMP));
+	WRITE_RPS1(cpu_to_le32(dev->d_rps1.dma_handle));
+
+	// Fix VSYNC level
+	saa7146_setgpio(dev, 3, SAA7146_GPIO_OUTLO);
+	// Set RPS1 Address register to point to RPS code               (r108 p42)
+	saa7146_write(dev, RPS_ADDR1, dev->d_rps1.dma_handle);
+	// Set Source Line Counter Threshold, using BRS                 (rCC p43)
+	// It generates HS event every TS_HEIGHT lines
+	// this is related to TS_WIDTH set in register
+	// NUM_LINE_BYTE3 in budget-core.c. If NUM_LINE_BYTE
+	// low 16 bits are set to TS_WIDTH bytes (TS_WIDTH=2*188
+	//,then RPS_THRESH1
+	// should be set to trigger every TS_HEIGHT (512) lines.
+	//
+	saa7146_write(dev, RPS_THRESH1, (TS_HEIGHT*1) | MASK_12 );
+
+	// saa7146_write(dev, RPS_THRESH0, ((TS_HEIGHT/2)<<16) |MASK_28| (TS_HEIGHT/2) |MASK_12 );
+	// Enable RPS1                                                  (rFC p33)
+	saa7146_write(dev, MC1, (MASK_13 | MASK_29));
+
 
+	if (!(budget = kmalloc (sizeof(struct budget_patch), GFP_KERNEL)))
+		return -ENOMEM;
 
-        dev->ext_priv = budget;
+	dprintk(2, "budget: %p\n", budget);
+
+	if ((err = ttpci_budget_init (budget, dev, info, THIS_MODULE))) {
+		kfree (budget);
+		return err;
+	}
+
+
+	dev->ext_priv = budget;
 
 	budget->dvb_adapter.priv = budget;
 	frontend_init(budget);
 
-        return 0;
+	return 0;
 }
 
 static int budget_patch_detach (struct saa7146_dev* dev)
 {
-        struct budget_patch *budget = (struct budget_patch*) dev->ext_priv;
-        int err;
+	struct budget_patch *budget = (struct budget_patch*) dev->ext_priv;
+	int err;
 
 	if (budget->dvb_frontend) dvb_unregister_frontend(budget->dvb_frontend);
 
-        err = ttpci_budget_deinit (budget);
+	err = ttpci_budget_deinit (budget);
 
-        kfree (budget);
+	kfree (budget);
 
-        return err;
+	return err;
 }
 
 static int __init budget_patch_init(void)
@@ -727,20 +727,20 @@
 
 static void __exit budget_patch_exit(void)
 {
-        saa7146_unregister_extension(&budget_extension);
+	saa7146_unregister_extension(&budget_extension);
 }
 
 static struct saa7146_extension budget_extension = {
-        .name           = "budget_patch dvb\0",
-        .flags          = 0,
+	.name           = "budget_patch dvb\0",
+	.flags          = 0,
 
-        .module         = THIS_MODULE,
-        .pci_tbl        = pci_tbl,
-        .attach         = budget_patch_attach,
-        .detach         = budget_patch_detach,
+	.module         = THIS_MODULE,
+	.pci_tbl        = pci_tbl,
+	.attach         = budget_patch_attach,
+	.detach         = budget_patch_detach,
 
-        .irq_mask       = MASK_10,
-        .irq_func       = ttpci_budget_irq10_handler,
+	.irq_mask       = MASK_10,
+	.irq_func       = ttpci_budget_irq10_handler,
 };
 
 module_init(budget_patch_init);
@@ -749,4 +749,4 @@
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Emard, Roberto Deza, Holger Waechtler, Michael Hunold, others");
 MODULE_DESCRIPTION("Driver for full TS modified DVB-S SAA7146+AV7110 "
-                   "based so-called Budget Patch cards");
+		   "based so-called Budget Patch cards");
diff -urN linux-2.6.15-rc5/drivers/media/dvb/ttpci/budget.c linux-2.6.15-rc6/drivers/media/dvb/ttpci/budget.c
--- linux-2.6.15-rc5/drivers/media/dvb/ttpci/budget.c	2005-12-18 22:27:55.070629902 -0800
+++ linux-2.6.15-rc6/drivers/media/dvb/ttpci/budget.c	2005-12-18 22:28:03.930024634 -0800
@@ -256,7 +256,7 @@
 	buf[2] = ((div & 0x18000) >> 10) | 0x95;
 	buf[3] = (pwr << 6) | 0x30;
 
-        // NOTE: since we're using a prescaler of 2, we set the
+	// NOTE: since we're using a prescaler of 2, we set the
 	// divisor frequency to 62.5kHz and divide by 125 above
 
 	if (i2c_transfer (&budget->i2c_adap, &msg, 1) != 1) return -EIO;
@@ -565,7 +565,7 @@
 	struct i2c_msg msg[] = { { .addr = 0x50,.flags = 0,.buf = &b,.len = 1 },
 				 { .addr = 0x50,.flags = I2C_M_RD,.buf = &pwm,.len = 1} };
 
-        if ((i2c_transfer(&budget->i2c_adap, msg, 2) != 2) || (pwm == 0xff))
+	if ((i2c_transfer(&budget->i2c_adap, msg, 2) != 2) || (pwm == 0xff))
 		pwm = 0x48;
 
 	return pwm;
@@ -593,7 +593,7 @@
 		budget->dvb_frontend = ves1x93_attach(&alps_bsrv2_config, &budget->i2c_adap);
 		if (budget->dvb_frontend) {
 			budget->dvb_frontend->ops->diseqc_send_master_cmd = budget_diseqc_send_master_cmd;
-		        budget->dvb_frontend->ops->diseqc_send_burst = budget_diseqc_send_burst;
+			budget->dvb_frontend->ops->diseqc_send_burst = budget_diseqc_send_burst;
 			budget->dvb_frontend->ops->set_tone = budget_set_tone;
 			break;
 		}
diff -urN linux-2.6.15-rc5/drivers/media/dvb/ttpci/budget.h linux-2.6.15-rc6/drivers/media/dvb/ttpci/budget.h
--- linux-2.6.15-rc5/drivers/media/dvb/ttpci/budget.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/media/dvb/ttpci/budget.h	2005-12-18 22:28:03.930024634 -0800
@@ -19,7 +19,7 @@
 #endif
 
 #define dprintk(level,args...) \
-            do { if ((budget_debug & level)) { printk("%s: %s(): ",__stringify(KBUILD_MODNAME), __FUNCTION__); printk(args); } } while (0)
+	    do { if ((budget_debug & level)) { printk("%s: %s(): ",__stringify(KBUILD_MODNAME), __FUNCTION__); printk(args); } } while (0)
 
 struct budget_info {
 	char *name;
diff -urN linux-2.6.15-rc5/drivers/media/dvb/ttpci/fdump.c linux-2.6.15-rc6/drivers/media/dvb/ttpci/fdump.c
--- linux-2.6.15-rc5/drivers/media/dvb/ttpci/fdump.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/media/dvb/ttpci/fdump.c	2005-12-18 22:28:03.931024679 -0800
@@ -36,7 +36,7 @@
     }
 
     fprintf(fd_out, "\n};\n\n");
-    
+
     fclose(fd_in);
     fclose(fd_out);
 
diff -urN linux-2.6.15-rc5/drivers/media/dvb/ttpci/ttpci-eeprom.c linux-2.6.15-rc6/drivers/media/dvb/ttpci/ttpci-eeprom.c
--- linux-2.6.15-rc5/drivers/media/dvb/ttpci/ttpci-eeprom.c	2005-12-18 22:27:55.070629902 -0800
+++ linux-2.6.15-rc6/drivers/media/dvb/ttpci/ttpci-eeprom.c	2005-12-18 22:28:03.931024679 -0800
@@ -13,7 +13,7 @@
     Holger Waechtler	Convergence
 
     Copyright (C) 2002-2003 Ralph Metzler <rjkm@metzlerbros.de>
-                            Metzler Brothers Systementwicklung GbR
+		            Metzler Brothers Systementwicklung GbR
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
@@ -48,41 +48,41 @@
 
 static int check_mac_tt(u8 *buf)
 {
-        int i;
-        u16 tmp = 0xffff;
+	int i;
+	u16 tmp = 0xffff;
 
-        for (i = 0; i < 8; i++) {
-                tmp  = (tmp << 8) | ((tmp >> 8) ^ buf[i]);
-                tmp ^= (tmp >> 4) & 0x0f;
-                tmp ^= (tmp << 12) ^ ((tmp & 0xff) << 5);
-        }
-        tmp ^= 0xffff;
-        return (((tmp >> 8) ^ buf[8]) | ((tmp & 0xff) ^ buf[9]));
+	for (i = 0; i < 8; i++) {
+		tmp  = (tmp << 8) | ((tmp >> 8) ^ buf[i]);
+		tmp ^= (tmp >> 4) & 0x0f;
+		tmp ^= (tmp << 12) ^ ((tmp & 0xff) << 5);
+	}
+	tmp ^= 0xffff;
+	return (((tmp >> 8) ^ buf[8]) | ((tmp & 0xff) ^ buf[9]));
 }
 
 static int getmac_tt(u8 * decodedMAC, u8 * encodedMAC)
 {
-        u8 xor[20] = { 0x72, 0x23, 0x68, 0x19, 0x5c, 0xa8, 0x71, 0x2c,
+	u8 xor[20] = { 0x72, 0x23, 0x68, 0x19, 0x5c, 0xa8, 0x71, 0x2c,
 		       0x54, 0xd3, 0x7b, 0xf1, 0x9E, 0x23, 0x16, 0xf6,
 		       0x1d, 0x36, 0x64, 0x78};
-        u8 data[20];
-        int i;
+	u8 data[20];
+	int i;
 
 	/* In case there is a sig check failure have the orig contents available */
 	memcpy(data, encodedMAC, 20);
 
 	for (i = 0; i < 20; i++)
-                data[i] ^= xor[i];
-        for (i = 0; i < 10; i++)
-                data[i] = ((data[2 * i + 1] << 8) | data[2 * i])
+		data[i] ^= xor[i];
+	for (i = 0; i < 10; i++)
+		data[i] = ((data[2 * i + 1] << 8) | data[2 * i])
 			>> ((data[2 * i + 1] >> 6) & 3);
 
-        if (check_mac_tt(data))
-                return -ENODEV;
+	if (check_mac_tt(data))
+		return -ENODEV;
 
 	decodedMAC[0] = data[2]; decodedMAC[1] = data[1]; decodedMAC[2] = data[0];
 	decodedMAC[3] = data[6]; decodedMAC[4] = data[5]; decodedMAC[5] = data[4];
-        return 0;
+	return 0;
 }
 
 static int ttpci_eeprom_read_encodedMAC(struct i2c_adapter *adapter, u8 * encodedMAC)
diff -urN linux-2.6.15-rc5/drivers/media/dvb/ttusb-budget/dvb-ttusb-budget.c linux-2.6.15-rc6/drivers/media/dvb/ttusb-budget/dvb-ttusb-budget.c
--- linux-2.6.15-rc5/drivers/media/dvb/ttusb-budget/dvb-ttusb-budget.c	2005-12-18 22:27:55.071629947 -0800
+++ linux-2.6.15-rc6/drivers/media/dvb/ttusb-budget/dvb-ttusb-budget.c	2005-12-18 22:28:03.932024723 -0800
@@ -225,8 +225,8 @@
 
 	err = ttusb_result(ttusb, b, 0x20);
 
-        /* check if the i2c transaction was successful */
-        if ((snd_len != b[5]) || (rcv_len != b[6])) return -EREMOTEIO;
+	/* check if the i2c transaction was successful */
+	if ((snd_len != b[5]) || (rcv_len != b[6])) return -EREMOTEIO;
 
 	if (rcv_len > 0) {
 
@@ -489,27 +489,27 @@
 
 static int lnbp21_set_voltage(struct dvb_frontend* fe, fe_sec_voltage_t voltage)
 {
-        struct  ttusb* ttusb = (struct ttusb*)  fe->dvb->priv;
-        int ret;
-        u8 data[1];
-        struct i2c_msg msg = { .addr = 0x08, .flags = 0, .buf = data, .len = sizeof(data) };
-
-        switch(voltage) {
-        case SEC_VOLTAGE_OFF:
-                data[0] = 0x00;
-                break;
-        case SEC_VOLTAGE_13:
-                data[0] = 0x44;
-                break;
-        case SEC_VOLTAGE_18:
-                data[0] = 0x4c;
-                break;
-        default:
-                return -EINVAL;
-        };
+	struct  ttusb* ttusb = (struct ttusb*)  fe->dvb->priv;
+	int ret;
+	u8 data[1];
+	struct i2c_msg msg = { .addr = 0x08, .flags = 0, .buf = data, .len = sizeof(data) };
+
+	switch(voltage) {
+	case SEC_VOLTAGE_OFF:
+		data[0] = 0x00;
+		break;
+	case SEC_VOLTAGE_13:
+		data[0] = 0x44;
+		break;
+	case SEC_VOLTAGE_18:
+		data[0] = 0x4c;
+		break;
+	default:
+		return -EINVAL;
+	};
 
-        ret = i2c_transfer(&ttusb->i2c_adap, &msg, 1);
-        return (ret != 1) ? -EIO : 0;
+	ret = i2c_transfer(&ttusb->i2c_adap, &msg, 1);
+	return (ret != 1) ? -EIO : 0;
 }
 
 static int ttusb_update_lnb(struct ttusb *ttusb)
@@ -1184,45 +1184,45 @@
 };
 
 static u8 alps_bsbe1_inittab[] = {
-        0x01, 0x15,
-        0x02, 0x30,
-        0x03, 0x00,
-        0x04, 0x7d,             /* F22FR = 0x7d, F22 = f_VCO / 128 / 0x7d = 22 kHz */
-        0x05, 0x35,             /* I2CT = 0, SCLT = 1, SDAT = 1 */
-        0x06, 0x40,             /* DAC not used, set to high impendance mode */
-        0x07, 0x00,             /* DAC LSB */
-        0x08, 0x40,             /* DiSEqC off, LNB power on OP2/LOCK pin on */
-        0x09, 0x00,             /* FIFO */
-        0x0c, 0x51,             /* OP1 ctl = Normal, OP1 val = 1 (LNB Power ON) */
-        0x0d, 0x82,             /* DC offset compensation = ON, beta_agc1 = 2 */
-        0x0e, 0x23,             /* alpha_tmg = 2, beta_tmg = 3 */
-        0x10, 0x3f,             // AGC2  0x3d
-        0x11, 0x84,
-        0x12, 0xb9,
-        0x15, 0xc9,             // lock detector threshold
-        0x16, 0x00,
-        0x17, 0x00,
-        0x18, 0x00,
-        0x19, 0x00,
-        0x1a, 0x00,
-        0x1f, 0x50,
-        0x20, 0x00,
-        0x21, 0x00,
-        0x22, 0x00,
-        0x23, 0x00,
-        0x28, 0x00,             // out imp: normal  out type: parallel FEC mode:0
-        0x29, 0x1e,             // 1/2 threshold
-        0x2a, 0x14,             // 2/3 threshold
-        0x2b, 0x0f,             // 3/4 threshold
-        0x2c, 0x09,             // 5/6 threshold
-        0x2d, 0x05,             // 7/8 threshold
-        0x2e, 0x01,
-        0x31, 0x1f,             // test all FECs
-        0x32, 0x19,             // viterbi and synchro search
-        0x33, 0xfc,             // rs control
-        0x34, 0x93,             // error control
-        0x0f, 0x92,
-        0xff, 0xff
+	0x01, 0x15,
+	0x02, 0x30,
+	0x03, 0x00,
+	0x04, 0x7d,             /* F22FR = 0x7d, F22 = f_VCO / 128 / 0x7d = 22 kHz */
+	0x05, 0x35,             /* I2CT = 0, SCLT = 1, SDAT = 1 */
+	0x06, 0x40,             /* DAC not used, set to high impendance mode */
+	0x07, 0x00,             /* DAC LSB */
+	0x08, 0x40,             /* DiSEqC off, LNB power on OP2/LOCK pin on */
+	0x09, 0x00,             /* FIFO */
+	0x0c, 0x51,             /* OP1 ctl = Normal, OP1 val = 1 (LNB Power ON) */
+	0x0d, 0x82,             /* DC offset compensation = ON, beta_agc1 = 2 */
+	0x0e, 0x23,             /* alpha_tmg = 2, beta_tmg = 3 */
+	0x10, 0x3f,             // AGC2  0x3d
+	0x11, 0x84,
+	0x12, 0xb9,
+	0x15, 0xc9,             // lock detector threshold
+	0x16, 0x00,
+	0x17, 0x00,
+	0x18, 0x00,
+	0x19, 0x00,
+	0x1a, 0x00,
+	0x1f, 0x50,
+	0x20, 0x00,
+	0x21, 0x00,
+	0x22, 0x00,
+	0x23, 0x00,
+	0x28, 0x00,             // out imp: normal  out type: parallel FEC mode:0
+	0x29, 0x1e,             // 1/2 threshold
+	0x2a, 0x14,             // 2/3 threshold
+	0x2b, 0x0f,             // 3/4 threshold
+	0x2c, 0x09,             // 5/6 threshold
+	0x2d, 0x05,             // 7/8 threshold
+	0x2e, 0x01,
+	0x31, 0x1f,             // test all FECs
+	0x32, 0x19,             // viterbi and synchro search
+	0x33, 0xfc,             // rs control
+	0x34, 0x93,             // error control
+	0x0f, 0x92,
+	0xff, 0xff
 };
 
 static u8 alps_bsru6_inittab[] = {
@@ -1350,7 +1350,7 @@
 	u32 div;
 	struct i2c_msg msg = {.addr = 0x61,.flags = 0,.buf = buf,.len = sizeof(buf) };
 
-        div = params->frequency / 125;
+	div = params->frequency / 125;
 
 	buf[0] = (div >> 8) & 0x7f;
 	buf[1] = div & 0xff;
@@ -1487,7 +1487,7 @@
 
 	udev = interface_to_usbdev(intf);
 
-        if (intf->altsetting->desc.bInterfaceNumber != 1) return -ENODEV;
+	if (intf->altsetting->desc.bInterfaceNumber != 1) return -ENODEV;
 
 	if (!(ttusb = kmalloc(sizeof(struct ttusb), GFP_KERNEL)))
 		return -ENOMEM;
diff -urN linux-2.6.15-rc5/drivers/media/dvb/ttusb-budget/dvb-ttusb-dspbootcode.h linux-2.6.15-rc6/drivers/media/dvb/ttusb-budget/dvb-ttusb-dspbootcode.h
--- linux-2.6.15-rc5/drivers/media/dvb/ttusb-budget/dvb-ttusb-dspbootcode.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/media/dvb/ttusb-budget/dvb-ttusb-dspbootcode.h	2005-12-18 22:28:03.940025080 -0800
@@ -2,1643 +2,1643 @@
 #include <asm/types.h>
 
 static u8 dsp_bootcode [] = {
-	0x08, 0xaa, 0x00, 0x18, 0x00, 0x03, 0x08, 0x00, 
-	0x00, 0x10, 0x00, 0x00, 0x01, 0x80, 0x18, 0x5f, 
-	0x00, 0x00, 0x01, 0x80, 0x77, 0x18, 0x2a, 0xeb, 
-	0x6b, 0xf8, 0x00, 0x18, 0x03, 0xff, 0x68, 0xf8, 
-	0x00, 0x18, 0xff, 0xfe, 0xf7, 0xb8, 0xf7, 0xbe, 
-	0xf6, 0xb9, 0xf4, 0xa0, 0xf6, 0xb7, 0xf6, 0xb5, 
-	0xf6, 0xb6, 0xf0, 0x20, 0x19, 0xdf, 0xf1, 0x00, 
-	0x00, 0x01, 0xf8, 0x4d, 0x01, 0xab, 0xf6, 0xb8, 
-	0xf0, 0x20, 0x19, 0xdf, 0xf0, 0x73, 0x01, 0xa5, 
-	0x7e, 0xf8, 0x00, 0x12, 0xf0, 0x00, 0x00, 0x01, 
-	0x47, 0xf8, 0x00, 0x11, 0x7e, 0x92, 0x00, 0xf8, 
-	0x00, 0x11, 0xf0, 0x00, 0x00, 0x01, 0x7e, 0xf8, 
-	0x00, 0x11, 0xf0, 0x00, 0x00, 0x01, 0x6c, 0x89, 
-	0x01, 0x9a, 0xf7, 0xb8, 0xee, 0xfc, 0xf0, 0x20, 
-	0xff, 0xff, 0xf1, 0x00, 0x00, 0x01, 0xf8, 0x4d, 
-	0x01, 0xbf, 0xf2, 0x73, 0x01, 0xb9, 0x4e, 0x02, 
-	0xf4, 0x95, 0xf5, 0xe3, 0x56, 0x02, 0x7e, 0x00, 
-	0x11, 0x00, 0xfa, 0x4c, 0x01, 0xb7, 0x6b, 0x03, 
-	0x00, 0x01, 0xf6, 0xb8, 0xee, 0x04, 0xf0, 0x74, 
-	0x0d, 0xa7, 0xf0, 0x74, 0x01, 0xc5, 0x4a, 0x11, 
-	0x4a, 0x16, 0x72, 0x11, 0x2a, 0xe6, 0x10, 0xf8, 
-	0x00, 0x11, 0xfa, 0x45, 0x01, 0xdb, 0xf4, 0x95, 
-	0xee, 0xff, 0x48, 0x11, 0xf0, 0x00, 0x2a, 0xc6, 
-	0x88, 0x16, 0xf4, 0x95, 0xf4, 0x95, 0x10, 0xee, 
-	0xff, 0xff, 0xf4, 0xe3, 0x6c, 0xe9, 0xff, 0xff, 
-	0x01, 0xd5, 0x10, 0xf8, 0x2a, 0xe7, 0xf8, 0x45, 
-	0x01, 0xe2, 0x10, 0xf8, 0x2a, 0xe7, 0xf4, 0xe3, 
-	0xf0, 0x74, 0x01, 0xff, 0xee, 0x01, 0x8a, 0x16, 
-	0x8a, 0x11, 0xfc, 0x00, 0xf7, 0xb8, 0xe9, 0x20, 
-	0x4a, 0x11, 0x09, 0xf8, 0x2a, 0xe6, 0xf8, 0x4e, 
-	0x01, 0xf3, 0xf2, 0x73, 0x01, 0xfd, 0xf4, 0x95, 
-	0xe8, 0x01, 0x72, 0x11, 0x2a, 0xe6, 0x49, 0x11, 
-	0x80, 0xe1, 0x2a, 0xc6, 0xf3, 0x00, 0x00, 0x01, 
-	0xe8, 0x00, 0x81, 0xf8, 0x2a, 0xe6, 0x8a, 0x11, 
-	0xfc, 0x00, 0xf4, 0x95, 0xf0, 0x73, 0x02, 0x00, 
-	0x10, 0xf8, 0x2a, 0x0f, 0xfc, 0x00, 0x4a, 0x11, 
-	0xf0, 0x74, 0x02, 0x02, 0x80, 0xf8, 0x2a, 0x10, 
-	0x73, 0x08, 0x00, 0x09, 0x40, 0xf8, 0x2a, 0x15, 
-	0x82, 0xf8, 0x00, 0x11, 0xf4, 0x95, 0x77, 0x10, 
-	0x03, 0xe8, 0xf5, 0xa9, 0xf8, 0x30, 0x02, 0x21, 
-	0x71, 0xf8, 0x2a, 0x10, 0x2a, 0x15, 0x56, 0xf8, 
-	0x2a, 0x0c, 0xf0, 0xe3, 0x4e, 0xf8, 0x2a, 0x16, 
-	0xe8, 0x00, 0x4e, 0xf8, 0x2a, 0x0c, 0x8a, 0x11, 
-	0xfc, 0x00, 0x4a, 0x06, 0x4a, 0x07, 0x4a, 0x1d, 
-	0x68, 0xf8, 0x00, 0x07, 0x7d, 0x3f, 0x69, 0xf8, 
-	0x00, 0x07, 0x40, 0x00, 0x68, 0xf8, 0x00, 0x1d, 
-	0xff, 0xfc, 0x6b, 0xf8, 0x2a, 0x0f, 0x00, 0x01, 
-	0x8a, 0x1d, 0x8a, 0x07, 0x8a, 0x06, 0xf4, 0xeb, 
-	0xee, 0xfd, 0x76, 0xf8, 0x2a, 0x0f, 0x00, 0x00, 
-	0x76, 0x00, 0x00, 0x00, 0xfb, 0x80, 0x19, 0x4c, 
-	0xf4, 0x95, 0xe8, 0x00, 0x80, 0xf8, 0x2a, 0x11, 
-	0xf9, 0x80, 0x19, 0x07, 0x80, 0xf8, 0x2a, 0x0e, 
-	0xf9, 0x80, 0x16, 0x66, 0x76, 0x00, 0x2a, 0x12, 
-	0x10, 0xf8, 0x2a, 0x11, 0xf9, 0x80, 0x18, 0xe3, 
-	0x10, 0xf8, 0x2a, 0x0e, 0xf9, 0x80, 0x16, 0x66, 
-	0x10, 0xf8, 0x2a, 0x0e, 0xf9, 0x80, 0x16, 0x87, 
-	0xee, 0x03, 0xfc, 0x00, 0x4a, 0x11, 0xf6, 0xb8, 
-	0xf4, 0x95, 0xf0, 0x20, 0x80, 0x00, 0x11, 0xf8, 
-	0x2a, 0x5a, 0xf8, 0x4d, 0x02, 0x93, 0x11, 0xf8, 
-	0x2a, 0x9f, 0xf8, 0x4c, 0x02, 0x7c, 0x77, 0x12, 
-	0x2a, 0x39, 0x49, 0x12, 0x01, 0xf8, 0x2a, 0x9f, 
-	0x89, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x71, 0x81, 
-	0x00, 0x11, 0x6c, 0xe1, 0xff, 0xab, 0x02, 0x93, 
-	0x6b, 0xf8, 0x2a, 0x9f, 0x00, 0x01, 0xe9, 0x05, 
-	0x01, 0xe2, 0x00, 0x03, 0x81, 0xf8, 0x2a, 0xa0, 
-	0xf0, 0x73, 0x02, 0x95, 0x72, 0x11, 0x2a, 0x9f, 
-	0xf4, 0x95, 0x10, 0xe1, 0x2a, 0x39, 0x6b, 0xf8, 
-	0x2a, 0x9f, 0x00, 0x01, 0x11, 0xf8, 0x2a, 0x9f, 
-	0x09, 0xf8, 0x2a, 0xa0, 0xf8, 0x4c, 0x02, 0x93, 
-	0x76, 0xf8, 0x2a, 0x5a, 0x00, 0x00, 0x76, 0xf8, 
-	0x2a, 0x9f, 0x00, 0x00, 0x76, 0xf8, 0x2a, 0xa0, 
-	0x00, 0x00, 0x88, 0x11, 0xf4, 0x95, 0x48, 0x11, 
-	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0xee, 0xfe, 
-	0x10, 0xf8, 0x2a, 0x5a, 0xf8, 0x44, 0x02, 0xb2, 
-	0x76, 0xf8, 0x2a, 0x5a, 0x00, 0x01, 0xf0, 0x74, 
-	0x02, 0x58, 0x88, 0x11, 0xf4, 0x95, 0x77, 0x10, 
-	0x80, 0x00, 0xf4, 0xa9, 0xf8, 0x30, 0x02, 0xb2, 
-	0x48, 0x11, 0xf0, 0x30, 0x00, 0xff, 0x80, 0x00, 
-	0x10, 0xf8, 0x2a, 0x5b, 0xf9, 0x80, 0x18, 0xd6, 
-	0xee, 0x02, 0x8a, 0x11, 0xfc, 0x00, 0xf4, 0x95, 
-	0x4a, 0x08, 0x4a, 0x09, 0x4a, 0x0a, 0x4a, 0x0b, 
-	0x4a, 0x0c, 0x4a, 0x0d, 0x4a, 0x10, 0x4a, 0x11, 
-	0x4a, 0x12, 0x4a, 0x13, 0x4a, 0x14, 0x4a, 0x15, 
-	0x4a, 0x16, 0x4a, 0x17, 0x4a, 0x17, 0x4a, 0x19, 
-	0x4a, 0x0e, 0x4a, 0x06, 0x4a, 0x07, 0x4a, 0x1a, 
-	0x4a, 0x1d, 0x4a, 0x1b, 0x4a, 0x1c, 0x68, 0xf8, 
-	0x00, 0x07, 0x7d, 0x3f, 0x69, 0xf8, 0x00, 0x07, 
-	0x40, 0x00, 0x68, 0xf8, 0x00, 0x1d, 0xff, 0xfc, 
-	0x48, 0x18, 0x68, 0xf8, 0x00, 0x18, 0xff, 0xfe, 
-	0xf4, 0x95, 0xf4, 0x95, 0x4a, 0x08, 0xee, 0xfd, 
-	0xf0, 0x74, 0x02, 0x58, 0x88, 0x11, 0xf4, 0x95, 
-	0x77, 0x10, 0x80, 0x00, 0xf4, 0xa9, 0xf8, 0x30, 
-	0x02, 0xef, 0x48, 0x11, 0xf0, 0x30, 0x00, 0xff, 
-	0x80, 0x00, 0x10, 0xf8, 0x2a, 0x5b, 0xf9, 0x80, 
-	0x18, 0xd6, 0xee, 0x03, 0x8a, 0x18, 0xf4, 0x95, 
-	0x8a, 0x1c, 0x8a, 0x1b, 0x8a, 0x1d, 0x8a, 0x1a, 
-	0x8a, 0x07, 0x8a, 0x06, 0x8a, 0x0e, 0x8a, 0x19, 
-	0x8a, 0x17, 0x8a, 0x17, 0x8a, 0x16, 0x8a, 0x15, 
-	0x8a, 0x14, 0x8a, 0x13, 0x8a, 0x12, 0x8a, 0x11, 
-	0x8a, 0x10, 0x8a, 0x0d, 0x8a, 0x0c, 0x8a, 0x0b, 
-	0x8a, 0x0a, 0x8a, 0x09, 0x8a, 0x08, 0xf4, 0xeb, 
-	0x4a, 0x11, 0x77, 0x11, 0x2a, 0x39, 0x76, 0x81, 
-	0x00, 0x55, 0x77, 0x12, 0x2a, 0x18, 0x10, 0xe2, 
-	0x00, 0x01, 0x80, 0xe1, 0x00, 0x01, 0x10, 0xe2, 
-	0x00, 0x02, 0x80, 0xe1, 0x00, 0x02, 0x76, 0xe1, 
-	0x00, 0x03, 0x00, 0x00, 0x76, 0xe1, 0x00, 0x04, 
-	0x00, 0xaa, 0xf0, 0x74, 0x02, 0x98, 0x8a, 0x11, 
-	0xfc, 0x00, 0x4a, 0x11, 0x88, 0x11, 0xf4, 0x95, 
-	0xf4, 0x95, 0x10, 0x81, 0x6f, 0xf8, 0x2a, 0x9e, 
-	0x0c, 0x88, 0xe8, 0xff, 0x18, 0xe1, 0x00, 0x01, 
-	0x1a, 0xf8, 0x2a, 0x9e, 0xf0, 0x30, 0x1f, 0xff, 
-	0x80, 0xf8, 0x2a, 0x9e, 0x8a, 0x11, 0xfc, 0x00, 
-	0x4a, 0x11, 0x77, 0x11, 0x2a, 0x39, 0x76, 0x81, 
-	0x00, 0x55, 0x77, 0x12, 0x2a, 0x18, 0x11, 0xe2, 
-	0x00, 0x01, 0x81, 0xe1, 0x00, 0x01, 0x11, 0xe2, 
-	0x00, 0x02, 0x81, 0xe1, 0x00, 0x02, 0x76, 0xe1, 
-	0x00, 0x03, 0x00, 0x02, 0x48, 0x08, 0x6f, 0xe1, 
-	0x00, 0x04, 0x0c, 0x98, 0xf0, 0x30, 0x00, 0xff, 
-	0x80, 0xe1, 0x00, 0x05, 0x76, 0xe1, 0x00, 0x06, 
-	0x00, 0xaa, 0xf0, 0x74, 0x02, 0x98, 0x8a, 0x11, 
-	0xfc, 0x00, 0x4a, 0x11, 0x77, 0x11, 0x2a, 0x39, 
-	0x76, 0x81, 0x00, 0x55, 0x77, 0x12, 0x2a, 0x18, 
-	0x10, 0xe2, 0x00, 0x01, 0x80, 0xe1, 0x00, 0x01, 
-	0x10, 0xe2, 0x00, 0x02, 0x80, 0xe1, 0x00, 0x02, 
-	0x76, 0xe1, 0x00, 0x03, 0x00, 0x04, 0x48, 0x11, 
-	0xf0, 0x00, 0x00, 0x04, 0x88, 0x12, 0xf4, 0x95, 
-	0x77, 0x13, 0x2a, 0x76, 0xe9, 0x00, 0xe5, 0x98, 
-	0xf3, 0x00, 0x00, 0x01, 0xf6, 0xb8, 0x48, 0x0b, 
-	0x08, 0xf8, 0x2a, 0x3c, 0xf8, 0x43, 0x03, 0x71, 
-	0x76, 0x82, 0x00, 0xaa, 0xf0, 0x74, 0x02, 0x98, 
-	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0xee, 0xf0, 
-	0x88, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x71, 0x81, 
-	0x00, 0x14, 0x71, 0xe1, 0x00, 0x01, 0x00, 0x15, 
-	0x49, 0x11, 0xf3, 0x00, 0x00, 0x02, 0x89, 0x11, 
-	0xe7, 0x82, 0x6d, 0xea, 0x00, 0x04, 0xe7, 0x83, 
-	0x6d, 0xeb, 0x00, 0x0a, 0x77, 0x1a, 0x00, 0x05, 
-	0xf0, 0x72, 0x03, 0xaa, 0x11, 0x81, 0xf2, 0xe8, 
-	0x80, 0x82, 0xe9, 0xff, 0x19, 0xe1, 0x00, 0x01, 
-	0xf1, 0xa0, 0x81, 0x92, 0x11, 0xe1, 0x00, 0x0c, 
-	0xf2, 0xe8, 0x80, 0x83, 0xe9, 0xff, 0x19, 0xe1, 
-	0x00, 0x0d, 0xf1, 0xa0, 0x81, 0x93, 0x6d, 0xe9, 
-	0x00, 0x02, 0x48, 0x18, 0x49, 0x18, 0x70, 0x00, 
-	0x00, 0x15, 0xf0, 0x00, 0x00, 0x04, 0xf3, 0x00, 
-	0x00, 0x0a, 0x80, 0x01, 0x81, 0x02, 0xf2, 0x74, 
-	0x0e, 0x54, 0xf4, 0x95, 0x48, 0x14, 0xee, 0x10, 
-	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0xf0, 0x74, 
-	0x0c, 0x5e, 0x80, 0xf8, 0x2a, 0x5c, 0x77, 0x12, 
-	0x2a, 0x39, 0x76, 0x82, 0x00, 0x55, 0x77, 0x11, 
-	0x2a, 0x18, 0x10, 0xe1, 0x00, 0x01, 0x80, 0xe2, 
-	0x00, 0x01, 0x10, 0xe1, 0x00, 0x02, 0x80, 0xe2, 
-	0x00, 0x02, 0x76, 0xe2, 0x00, 0x03, 0x00, 0x1c, 
-	0xf6, 0xb8, 0x56, 0xf8, 0x2a, 0x16, 0xf0, 0xf0, 
-	0xf0, 0xf8, 0x80, 0xe2, 0x00, 0x07, 0x56, 0xf8, 
-	0x2a, 0x16, 0xf1, 0xf0, 0xe8, 0xff, 0xf2, 0x80, 
-	0x80, 0xe2, 0x00, 0x06, 0x56, 0xf8, 0x2a, 0x16, 
-	0xf1, 0xf8, 0xe8, 0xff, 0xf2, 0x80, 0x80, 0xe2, 
-	0x00, 0x05, 0x57, 0xf8, 0x2a, 0x16, 0xe8, 0xff, 
-	0xf2, 0x80, 0x80, 0xe2, 0x00, 0x04, 0x56, 0xf8, 
-	0x27, 0x6c, 0xf0, 0xf0, 0xf0, 0xf8, 0x80, 0xe2, 
-	0x00, 0x0b, 0x56, 0xf8, 0x27, 0x6c, 0xf1, 0xf0, 
-	0xe8, 0xff, 0xf2, 0x80, 0x80, 0xe2, 0x00, 0x0a, 
-	0x56, 0xf8, 0x27, 0x6c, 0xf1, 0xf8, 0xe8, 0xff, 
-	0xf2, 0x80, 0x80, 0xe2, 0x00, 0x09, 0xe8, 0xff, 
-	0x57, 0xf8, 0x27, 0x6c, 0xf2, 0x80, 0x80, 0xe2, 
-	0x00, 0x08, 0x56, 0xf8, 0x27, 0x6a, 0xf0, 0xf0, 
-	0xf0, 0xf8, 0x80, 0xe2, 0x00, 0x0f, 0x56, 0xf8, 
-	0x27, 0x6a, 0xf1, 0xf0, 0xe8, 0xff, 0xf2, 0x80, 
-	0x80, 0xe2, 0x00, 0x0e, 0x56, 0xf8, 0x27, 0x6a, 
-	0xf1, 0xf8, 0xe8, 0xff, 0xf2, 0x80, 0x80, 0xe2, 
-	0x00, 0x0d, 0x57, 0xf8, 0x27, 0x6a, 0xe8, 0xff, 
-	0xf2, 0x80, 0x80, 0xe2, 0x00, 0x0c, 0x76, 0xe2, 
-	0x00, 0x13, 0x00, 0x00, 0x76, 0xe2, 0x00, 0x12, 
-	0x00, 0x00, 0x6f, 0xf8, 0x2a, 0x5c, 0x0c, 0x58, 
-	0x80, 0xe2, 0x00, 0x11, 0xe8, 0xff, 0x18, 0xf8, 
-	0x2a, 0x5c, 0x80, 0xe2, 0x00, 0x10, 0x76, 0xe2, 
-	0x00, 0x17, 0x00, 0x00, 0x76, 0xe2, 0x00, 0x16, 
-	0x00, 0x00, 0x6f, 0xf8, 0x2a, 0x9e, 0x0c, 0x58, 
-	0x80, 0xe2, 0x00, 0x15, 0xe8, 0xff, 0x18, 0xf8, 
-	0x2a, 0x9e, 0x80, 0xe2, 0x00, 0x14, 0x76, 0xe2, 
-	0x00, 0x1b, 0x00, 0x00, 0x76, 0xe2, 0x00, 0x1a, 
-	0x00, 0x00, 0x76, 0xe2, 0x00, 0x19, 0x00, 0x00, 
-	0x70, 0xe2, 0x00, 0x18, 0x27, 0x6e, 0x76, 0xe2, 
-	0x00, 0x1f, 0x00, 0x00, 0x76, 0xe2, 0x00, 0x1e, 
-	0x00, 0x00, 0x76, 0xe2, 0x00, 0x1d, 0x00, 0x00, 
-	0x76, 0xe2, 0x00, 0x1c, 0x00, 0x00, 0x76, 0xe2, 
-	0x00, 0x20, 0x00, 0xaa, 0xf0, 0x74, 0x02, 0x98, 
-	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0xee, 0xfe, 
-	0x10, 0xf8, 0x2a, 0x38, 0xf8, 0x45, 0x04, 0xed, 
-	0x77, 0x12, 0x2a, 0x18, 0x10, 0xe2, 0x00, 0x02, 
-	0x88, 0x11, 0xf4, 0x95, 0x77, 0x10, 0x00, 0x08, 
-	0x6d, 0xe9, 0xff, 0xdf, 0xf6, 0xa9, 0xf8, 0x20, 
-	0x04, 0x75, 0xf0, 0x73, 0x04, 0x7d, 0xf0, 0x10, 
-	0x00, 0x21, 0xf0, 0x00, 0x1a, 0x83, 0x48, 0x08, 
-	0x7e, 0xf8, 0x00, 0x08, 0xf4, 0xe2, 0xf0, 0x74, 
-	0x03, 0x0a, 0xf0, 0x73, 0x04, 0xea, 0x48, 0x12, 
-	0xf2, 0x74, 0x03, 0x23, 0xf0, 0x00, 0x00, 0x04, 
-	0xf2, 0x74, 0x03, 0x36, 0xf4, 0x95, 0xe8, 0x00, 
-	0xf0, 0x73, 0x04, 0xea, 0x77, 0x11, 0x2a, 0x18, 
-	0xe8, 0xff, 0x6f, 0xe1, 0x00, 0x04, 0x0d, 0x48, 
-	0x18, 0xe1, 0x00, 0x05, 0xf2, 0x74, 0x09, 0x69, 
-	0xf4, 0x95, 0xf2, 0xa0, 0xf0, 0x74, 0x03, 0x36, 
-	0xf0, 0x73, 0x04, 0xea, 0x77, 0x11, 0x2a, 0x18, 
-	0xe8, 0xff, 0x6f, 0xe1, 0x00, 0x04, 0x0d, 0x48, 
-	0x18, 0xe1, 0x00, 0x05, 0xf2, 0x74, 0x09, 0x41, 
-	0xf4, 0x95, 0xf2, 0xa0, 0xf0, 0x74, 0x03, 0x36, 
-	0xf0, 0x73, 0x04, 0xea, 0xf0, 0x74, 0x03, 0x57, 
-	0xf0, 0x73, 0x04, 0xea, 0x10, 0xf8, 0x2a, 0x1c, 
-	0xf0, 0x74, 0x12, 0xa4, 0xf2, 0x74, 0x03, 0x36, 
-	0xf4, 0x95, 0xe8, 0x00, 0xf0, 0x73, 0x04, 0xea, 
-	0x48, 0x12, 0xf2, 0x74, 0x03, 0x80, 0xf0, 0x00, 
-	0x00, 0x04, 0xf2, 0x74, 0x03, 0x36, 0xf4, 0x95, 
-	0xe8, 0x00, 0xf0, 0x73, 0x04, 0xea, 0x10, 0xf8, 
-	0x2a, 0x1c, 0xf0, 0x74, 0x12, 0xc5, 0xf2, 0x74, 
-	0x03, 0x36, 0xf4, 0x95, 0xe8, 0x00, 0xf0, 0x73, 
-	0x04, 0xea, 0x77, 0x11, 0x2a, 0x18, 0xe8, 0xff, 
-	0x6f, 0xe1, 0x00, 0x06, 0x0d, 0x48, 0x18, 0xe1, 
-	0x00, 0x07, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 
-	0xf2, 0xa0, 0x70, 0x00, 0x00, 0x12, 0x80, 0x01, 
-	0x10, 0xe1, 0x00, 0x04, 0xf0, 0x74, 0x0e, 0x7a, 
-	0xf2, 0x74, 0x03, 0x36, 0xf4, 0x95, 0xe8, 0x00, 
-	0xf0, 0x73, 0x04, 0xea, 0xf0, 0x74, 0x03, 0xbc, 
-	0x76, 0xf8, 0x2a, 0x38, 0x00, 0x00, 0xee, 0x02, 
-	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0x77, 0x11, 
-	0x2a, 0x39, 0x76, 0x81, 0x00, 0x55, 0x77, 0x12, 
-	0x2a, 0x18, 0x10, 0xe2, 0x00, 0x01, 0x80, 0xe1, 
-	0x00, 0x01, 0x10, 0xe2, 0x00, 0x02, 0x80, 0xe1, 
-	0x00, 0x02, 0x76, 0xe1, 0x00, 0x03, 0x00, 0x09, 
-	0x48, 0x11, 0xf0, 0x00, 0x00, 0x04, 0x88, 0x12, 
-	0xf4, 0x95, 0x77, 0x13, 0x2a, 0x86, 0xe9, 0x00, 
-	0xe5, 0x98, 0xf3, 0x00, 0x00, 0x01, 0xf6, 0xb8, 
-	0x48, 0x0b, 0x08, 0xf8, 0x2a, 0x3c, 0xf8, 0x43, 
-	0x05, 0x0a, 0x76, 0x82, 0x00, 0xaa, 0xf0, 0x74, 
-	0x02, 0x98, 0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 
-	0x77, 0x11, 0x2a, 0x39, 0x76, 0x81, 0x00, 0x55, 
-	0x77, 0x13, 0x2a, 0x18, 0x10, 0xe3, 0x00, 0x01, 
-	0x80, 0xe1, 0x00, 0x01, 0x10, 0xe3, 0x00, 0x02, 
-	0x80, 0xe1, 0x00, 0x02, 0x13, 0xe3, 0x00, 0x03, 
-	0x81, 0xe1, 0x00, 0x03, 0x48, 0x11, 0x77, 0x11, 
-	0x00, 0x00, 0xf8, 0x4d, 0x05, 0x44, 0xf0, 0x00, 
-	0x00, 0x04, 0x88, 0x12, 0x48, 0x13, 0xf0, 0x00, 
-	0x00, 0x04, 0x88, 0x13, 0xf4, 0x95, 0xf4, 0x95, 
-	0xe5, 0x98, 0x6d, 0x91, 0xf6, 0xb8, 0x48, 0x11, 
-	0x08, 0xf8, 0x2a, 0x3c, 0xf8, 0x43, 0x05, 0x3a, 
-	0xf0, 0x20, 0x2a, 0x39, 0x49, 0x11, 0xf5, 0x00, 
-	0x89, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x76, 0xe1, 
-	0x00, 0x04, 0x00, 0xaa, 0xf0, 0x74, 0x02, 0x98, 
-	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0x77, 0x11, 
-	0x2a, 0x39, 0x76, 0x81, 0x00, 0x55, 0x77, 0x12, 
-	0x2a, 0x18, 0x10, 0xe2, 0x00, 0x01, 0x80, 0xe1, 
-	0x00, 0x01, 0x10, 0xe2, 0x00, 0x02, 0x80, 0xe1, 
-	0x00, 0x02, 0x76, 0xe1, 0x00, 0x03, 0x00, 0x0c, 
-	0x48, 0x11, 0xf0, 0x00, 0x00, 0x04, 0x88, 0x12, 
-	0xf4, 0x95, 0x77, 0x13, 0x2a, 0x7a, 0xe9, 0x00, 
-	0xe5, 0x98, 0xf3, 0x00, 0x00, 0x01, 0xf6, 0xb8, 
-	0x48, 0x0b, 0x08, 0xf8, 0x2a, 0x3c, 0xf8, 0x43, 
-	0x05, 0x6a, 0x76, 0x82, 0x00, 0xaa, 0xf0, 0x74, 
-	0x02, 0x98, 0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 
-	0x77, 0x11, 0x2a, 0x39, 0x76, 0x81, 0x00, 0x55, 
-	0x77, 0x12, 0x2a, 0x18, 0x10, 0xe2, 0x00, 0x01, 
-	0x80, 0xe1, 0x00, 0x01, 0x10, 0xe2, 0x00, 0x02, 
-	0x80, 0xe1, 0x00, 0x02, 0x76, 0xe1, 0x00, 0x03, 
-	0x00, 0x19, 0x48, 0x11, 0xf0, 0x00, 0x00, 0x04, 
-	0x88, 0x12, 0xf4, 0x95, 0x77, 0x13, 0x2a, 0x5d, 
-	0xe9, 0x00, 0xe5, 0x98, 0xf3, 0x00, 0x00, 0x01, 
-	0xf6, 0xb8, 0x48, 0x0b, 0x08, 0xf8, 0x2a, 0x3c, 
-	0xf8, 0x43, 0x05, 0x93, 0x76, 0x82, 0x00, 0xaa, 
-	0xf0, 0x74, 0x02, 0x98, 0x8a, 0x11, 0xfc, 0x00, 
-	0x4a, 0x11, 0x88, 0x11, 0x10, 0xf8, 0x2a, 0x38, 
-	0xf8, 0x44, 0x05, 0xe3, 0x10, 0xf8, 0x2a, 0xa1, 
-	0xf8, 0x44, 0x05, 0xba, 0x6c, 0xe1, 0xff, 0x56, 
-	0x05, 0xe3, 0x72, 0x12, 0x2a, 0xa1, 0xf4, 0x95, 
-	0x70, 0xe2, 0x2a, 0x18, 0x00, 0x11, 0x6b, 0xf8, 
-	0x2a, 0xa1, 0x00, 0x01, 0xf0, 0x73, 0x05, 0xe3, 
-	0x72, 0x12, 0x2a, 0xa1, 0xf4, 0x95, 0x70, 0xe2, 
-	0x2a, 0x18, 0x00, 0x11, 0x10, 0xf8, 0x2a, 0xa1, 
-	0xf0, 0x00, 0x00, 0x01, 0x88, 0x12, 0xf4, 0x95, 
-	0xf4, 0x95, 0x6e, 0xe2, 0xff, 0xfc, 0x05, 0xd1, 
-	0x73, 0x12, 0x2a, 0xa1, 0x48, 0x11, 0xf0, 0x00, 
-	0x00, 0x05, 0x80, 0xf8, 0x2a, 0xa2, 0x10, 0xf8, 
-	0x2a, 0xa1, 0x08, 0xf8, 0x2a, 0xa2, 0xf8, 0x44, 
-	0x05, 0xe3, 0x6c, 0xe1, 0xff, 0xab, 0x05, 0xdd, 
-	0x76, 0xf8, 0x2a, 0x38, 0x00, 0x01, 0x76, 0xf8, 
-	0x2a, 0xa1, 0x00, 0x00, 0x76, 0xf8, 0x2a, 0xa2, 
-	0x00, 0x00, 0x8a, 0x11, 0xfc, 0x00, 0xf4, 0x95, 
-	0x4a, 0x08, 0x4a, 0x09, 0x4a, 0x0a, 0x4a, 0x0b, 
-	0x4a, 0x0c, 0x4a, 0x0d, 0x4a, 0x10, 0x4a, 0x11, 
-	0x4a, 0x12, 0x4a, 0x13, 0x4a, 0x14, 0x4a, 0x15, 
-	0x4a, 0x16, 0x4a, 0x17, 0x4a, 0x17, 0x4a, 0x19, 
-	0x4a, 0x0e, 0x4a, 0x06, 0x4a, 0x07, 0x4a, 0x1a, 
-	0x4a, 0x1d, 0x4a, 0x1b, 0x4a, 0x1c, 0x68, 0xf8, 
-	0x00, 0x07, 0x7d, 0x3f, 0x69, 0xf8, 0x00, 0x07, 
-	0x40, 0x00, 0x68, 0xf8, 0x00, 0x1d, 0xff, 0xfc, 
-	0x48, 0x18, 0x68, 0xf8, 0x00, 0x18, 0xff, 0xfe, 
-	0xf4, 0x95, 0xf4, 0x95, 0x4a, 0x08, 0xee, 0xff, 
-	0x10, 0xf8, 0x2a, 0x5b, 0xf9, 0x80, 0x18, 0x04, 
-	0xf0, 0x74, 0x05, 0xa2, 0xee, 0x01, 0x8a, 0x18, 
-	0xf4, 0x95, 0x8a, 0x1c, 0x8a, 0x1b, 0x8a, 0x1d, 
-	0x8a, 0x1a, 0x8a, 0x07, 0x8a, 0x06, 0x8a, 0x0e, 
-	0x8a, 0x19, 0x8a, 0x17, 0x8a, 0x17, 0x8a, 0x16, 
-	0x8a, 0x15, 0x8a, 0x14, 0x8a, 0x13, 0x8a, 0x12, 
-	0x8a, 0x11, 0x8a, 0x10, 0x8a, 0x0d, 0x8a, 0x0c, 
-	0x8a, 0x0b, 0x8a, 0x0a, 0x8a, 0x09, 0x8a, 0x08, 
-	0xf4, 0xeb, 0xee, 0xfd, 0x76, 0xf8, 0x2a, 0x38, 
-	0x00, 0x00, 0x76, 0xf8, 0x2a, 0x5a, 0x00, 0x00, 
-	0xe8, 0x01, 0x4e, 0x00, 0xfb, 0x80, 0x17, 0xd6, 
-	0xf4, 0x95, 0xe8, 0x01, 0x80, 0xf8, 0x2a, 0x5b, 
-	0x76, 0x00, 0x2a, 0x8f, 0xf9, 0x80, 0x16, 0xaa, 
-	0x10, 0xf8, 0x2a, 0x5b, 0xf9, 0x80, 0x17, 0x5c, 
-	0x10, 0xf8, 0x2a, 0x5b, 0xf9, 0x80, 0x17, 0x6f, 
-	0xfb, 0x80, 0x16, 0x66, 0xf4, 0x95, 0xe8, 0x1a, 
-	0xfb, 0x80, 0x16, 0x87, 0xf4, 0x95, 0xe8, 0x1a, 
-	0xfb, 0x80, 0x16, 0x66, 0xf4, 0x95, 0xe8, 0x1b, 
-	0xfb, 0x80, 0x16, 0x87, 0xf4, 0x95, 0xe8, 0x1b, 
-	0xee, 0x03, 0xfc, 0x00, 0x4a, 0x11, 0xf4, 0x95, 
-	0x13, 0x02, 0x88, 0x11, 0xe8, 0x00, 0xf8, 0x4d, 
-	0x06, 0x6a, 0xf3, 0x10, 0x00, 0x01, 0x89, 0x1a, 
-	0xf4, 0x95, 0xf0, 0x72, 0x06, 0x69, 0x1c, 0x91, 
-	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0x88, 0x11, 
-	0x12, 0x03, 0x11, 0x02, 0xf8, 0x45, 0x06, 0x79, 
-	0xf0, 0x10, 0x00, 0x01, 0x88, 0x1a, 0xf4, 0x95, 
-	0xf0, 0x72, 0x06, 0x78, 0x81, 0x91, 0x8a, 0x11, 
-	0xfc, 0x00, 0x4a, 0x11, 0xf4, 0x95, 0x71, 0x02, 
-	0x00, 0x11, 0x11, 0x03, 0x61, 0xf8, 0x00, 0x11, 
-	0x00, 0x01, 0xf8, 0x30, 0x06, 0x91, 0xf6, 0xb8, 
-	0x6f, 0xf8, 0x00, 0x11, 0x0c, 0x1f, 0x88, 0x11, 
-	0xf3, 0xe8, 0xe8, 0xff, 0x18, 0x81, 0xf1, 0xa0, 
-	0x81, 0x81, 0xf0, 0x73, 0x06, 0x9d, 0xf6, 0xb8, 
-	0x6f, 0xf8, 0x00, 0x11, 0x0c, 0x1f, 0x88, 0x11, 
-	0xf3, 0x30, 0x00, 0xff, 0xf0, 0x20, 0xff, 0x00, 
-	0x18, 0x81, 0xf1, 0xa0, 0x81, 0x81, 0x8a, 0x11, 
-	0xfc, 0x00, 0x4a, 0x11, 0xf4, 0x95, 0x11, 0x02, 
-	0x61, 0xf8, 0x00, 0x0b, 0x00, 0x01, 0xf8, 0x20, 
-	0x06, 0xb1, 0x49, 0x0b, 0xf6, 0x1f, 0x88, 0x11, 
-	0xf4, 0x95, 0xf4, 0x95, 0x10, 0x81, 0xf2, 0x73, 
-	0x06, 0xb8, 0xf0, 0x30, 0x00, 0xff, 0x49, 0x0b, 
-	0xf6, 0x1f, 0x88, 0x11, 0xf4, 0x95, 0xf4, 0x95, 
-	0x12, 0x81, 0xf4, 0x78, 0x8a, 0x11, 0xfc, 0x00, 
-	0x4a, 0x11, 0xf4, 0x95, 0x71, 0x02, 0x00, 0x12, 
-	0x13, 0x03, 0x88, 0x11, 0xe8, 0x00, 0xf8, 0x4d, 
-	0x06, 0xcc, 0xf3, 0x10, 0x00, 0x01, 0x89, 0x1a, 
-	0xf4, 0x95, 0xf0, 0x72, 0x06, 0xcb, 0x11, 0x92, 
-	0xf2, 0xc0, 0x81, 0x91, 0x8a, 0x11, 0xfc, 0x00, 
-	0x88, 0x12, 0x12, 0x02, 0x71, 0x01, 0x00, 0x13, 
-	0xf8, 0x45, 0x06, 0xdb, 0xf0, 0x10, 0x00, 0x01, 
-	0x88, 0x1a, 0xf4, 0x95, 0xf0, 0x72, 0x06, 0xda, 
-	0xe5, 0x98, 0xfc, 0x00, 0x4a, 0x11, 0xee, 0xfe, 
-	0x88, 0x11, 0x11, 0x04, 0x10, 0x06, 0x71, 0x05, 
-	0x00, 0x12, 0x61, 0xf8, 0x00, 0x12, 0x00, 0x01, 
-	0xf8, 0x20, 0x06, 0xea, 0xf0, 0x00, 0x00, 0x01, 
-	0xf6, 0xb8, 0xf0, 0x00, 0x00, 0x01, 0x6f, 0xf8, 
-	0x00, 0x12, 0x0f, 0x1f, 0x48, 0x08, 0x81, 0x00, 
-	0xf4, 0x7f, 0x80, 0x01, 0xf2, 0x74, 0x06, 0xba, 
-	0xf4, 0x95, 0x48, 0x11, 0xee, 0x02, 0x8a, 0x11, 
-	0xfc, 0x00, 0x4a, 0x11, 0xee, 0xfe, 0x88, 0x12, 
-	0x11, 0x04, 0x10, 0x06, 0x71, 0x05, 0x00, 0x13, 
-	0x61, 0xf8, 0x00, 0x13, 0x00, 0x01, 0xf8, 0x20, 
-	0x07, 0x09, 0xf0, 0x00, 0x00, 0x01, 0xf0, 0x00, 
-	0x00, 0x01, 0x88, 0x11, 0xf6, 0xb8, 0x6f, 0xf8, 
-	0x00, 0x13, 0x0f, 0x1f, 0x81, 0x00, 0x48, 0x11, 
-	0xf4, 0x7f, 0x80, 0x01, 0xf2, 0x74, 0x06, 0xce, 
-	0xf4, 0x95, 0x48, 0x12, 0x48, 0x11, 0xf0, 0x30, 
-	0xff, 0xfe, 0xee, 0x02, 0x8a, 0x11, 0xfc, 0x00, 
-	0x4a, 0x11, 0x4a, 0x16, 0x4a, 0x17, 0xee, 0xfc, 
-	0xf4, 0x95, 0x80, 0x02, 0x71, 0x08, 0x00, 0x16, 
-	0x10, 0x09, 0x71, 0x0b, 0x00, 0x17, 0x80, 0x03, 
-	0x71, 0x0a, 0x00, 0x11, 0x48, 0x17, 0xf8, 0x45, 
-	0x07, 0x3f, 0x70, 0x00, 0x00, 0x11, 0x10, 0x03, 
-	0xf0, 0x74, 0x06, 0x9f, 0x80, 0x01, 0x70, 0x00, 
-	0x00, 0x16, 0x10, 0x02, 0xf0, 0x74, 0x06, 0x7b, 
-	0x6d, 0x91, 0x6d, 0x96, 0x6c, 0xef, 0xff, 0xff, 
-	0x07, 0x2f, 0xee, 0x04, 0x8a, 0x17, 0x8a, 0x16, 
-	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0xee, 0xfe, 
-	0x10, 0xf8, 0x2a, 0xe8, 0x08, 0xf8, 0x2a, 0xe9, 
-	0xf8, 0x45, 0x07, 0x64, 0x76, 0x00, 0x00, 0x01, 
-	0x62, 0xf8, 0x2a, 0xe9, 0x00, 0x5e, 0xf2, 0x74, 
-	0x12, 0x0b, 0xf0, 0x00, 0x30, 0x40, 0x72, 0x11, 
-	0x2a, 0xe9, 0x77, 0x10, 0x00, 0x0f, 0xf5, 0xa9, 
-	0xf8, 0x20, 0x07, 0x61, 0x6b, 0xf8, 0x2a, 0xe9, 
-	0x00, 0x01, 0xf0, 0x73, 0x07, 0x64, 0x76, 0xf8, 
-	0x2a, 0xe9, 0x00, 0x00, 0xee, 0x02, 0x8a, 0x11, 
-	0xfc, 0x00, 0x4a, 0x11, 0x88, 0x11, 0xe8, 0x00, 
-	0x75, 0xf8, 0x00, 0x08, 0x00, 0x08, 0xe8, 0x00, 
-	0x75, 0xf8, 0x00, 0x08, 0x00, 0x09, 0xf6, 0xb8, 
-	0xf4, 0x95, 0xf0, 0x20, 0xfc, 0x3f, 0x75, 0xf8, 
-	0x00, 0x08, 0x00, 0x0d, 0xf0, 0x20, 0x0c, 0x30, 
-	0x75, 0xf8, 0x00, 0x08, 0x00, 0x0c, 0x76, 0xf8, 
-	0x2a, 0xe8, 0x00, 0x00, 0x76, 0xf8, 0x2a, 0xe9, 
-	0x00, 0x00, 0x6c, 0x81, 0x07, 0x92, 0x76, 0xf8, 
-	0x2a, 0xea, 0x00, 0x00, 0xfb, 0x80, 0x16, 0x76, 
-	0xf4, 0x95, 0xe8, 0x10, 0xe8, 0x00, 0x75, 0xf8, 
-	0x00, 0x08, 0x00, 0x00, 0xf0, 0x73, 0x07, 0xa8, 
-	0x76, 0xf8, 0x2a, 0xea, 0x00, 0x01, 0xfb, 0x80, 
-	0x16, 0x66, 0xf4, 0x95, 0xe8, 0x10, 0xfb, 0x80, 
-	0x16, 0x87, 0xf4, 0x95, 0xe8, 0x10, 0xe8, 0x00, 
-	0x75, 0xf8, 0x00, 0x08, 0x00, 0x00, 0xf6, 0xb8, 
-	0xf4, 0x95, 0xf0, 0x20, 0xff, 0xff, 0x75, 0xf8, 
-	0x00, 0x08, 0x00, 0x00, 0x8a, 0x11, 0xfc, 0x00, 
-	0xf4, 0x95, 0x4a, 0x08, 0x4a, 0x09, 0x4a, 0x0a, 
-	0x4a, 0x06, 0x4a, 0x07, 0x4a, 0x1d, 0x68, 0xf8, 
-	0x00, 0x07, 0x7d, 0x3f, 0x69, 0xf8, 0x00, 0x07, 
-	0x40, 0x00, 0x68, 0xf8, 0x00, 0x1d, 0xff, 0xfc, 
-	0x10, 0xf8, 0x2a, 0xea, 0xf8, 0x45, 0x07, 0xe1, 
-	0x10, 0xf8, 0x2a, 0xe8, 0xf0, 0x00, 0x00, 0x01, 
-	0xf0, 0x30, 0x00, 0x0f, 0x80, 0xf8, 0x2a, 0xe8, 
-	0x10, 0xf8, 0x2a, 0xe8, 0xf8, 0x44, 0x07, 0xd6, 
-	0xf6, 0xb8, 0xf4, 0x95, 0xf0, 0x20, 0xfc, 0x3f, 
-	0x75, 0xf8, 0x00, 0x08, 0x00, 0x0d, 0xf0, 0x20, 
-	0x0c, 0x30, 0x75, 0xf8, 0x00, 0x08, 0x00, 0x0c, 
-	0xe8, 0x00, 0x75, 0xf8, 0x00, 0x08, 0x00, 0x00, 
-	0xf6, 0xb8, 0xf4, 0x95, 0xf0, 0x20, 0xff, 0xff, 
-	0x75, 0xf8, 0x00, 0x08, 0x00, 0x00, 0x8a, 0x1d, 
-	0x8a, 0x07, 0x8a, 0x06, 0x8a, 0x0a, 0x8a, 0x09, 
-	0x8a, 0x08, 0xf4, 0xeb, 0xee, 0xff, 0xf2, 0x74, 
-	0x07, 0x67, 0xf4, 0x95, 0xe8, 0x01, 0xee, 0x01, 
-	0xfc, 0x00, 0x4a, 0x07, 0x4a, 0x1d, 0x68, 0xf8, 
-	0x00, 0x07, 0x7d, 0x3f, 0x69, 0xf8, 0x00, 0x07, 
-	0x40, 0x00, 0x68, 0xf8, 0x00, 0x1d, 0xff, 0xfc, 
-	0x8a, 0x1d, 0x8a, 0x07, 0xf4, 0xeb, 0x4a, 0x11, 
-	0x77, 0x11, 0x00, 0x28, 0x76, 0x81, 0x24, 0x00, 
-	0xe8, 0x00, 0x75, 0xf8, 0x00, 0x08, 0x00, 0x01, 
-	0xf2, 0x74, 0x07, 0x67, 0xf4, 0x95, 0xe8, 0x00, 
-	0x77, 0x11, 0x00, 0x1d, 0x68, 0x81, 0x00, 0x7f, 
-	0xf6, 0xb8, 0xf4, 0x95, 0xf0, 0x20, 0xff, 0x80, 
-	0x77, 0x11, 0x00, 0x1d, 0xf0, 0x30, 0x01, 0x00, 
-	0x1a, 0x81, 0x80, 0x81, 0xf0, 0x74, 0x0a, 0x33, 
-	0xf0, 0x74, 0x11, 0xac, 0xf9, 0x80, 0x13, 0x25, 
-	0xf9, 0x80, 0x16, 0x53, 0xf9, 0x80, 0x17, 0x82, 
-	0xf0, 0x74, 0x06, 0x2f, 0xf9, 0x80, 0x14, 0xb2, 
-	0xf9, 0x80, 0x19, 0x10, 0xf0, 0x74, 0x0d, 0xe3, 
-	0xf0, 0x74, 0x07, 0xe8, 0xf0, 0x74, 0x02, 0x36, 
-	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0x60, 0xf8, 
-	0x27, 0x7b, 0xff, 0xff, 0xf8, 0x30, 0x08, 0x39, 
-	0x71, 0xf8, 0x27, 0x7b, 0x27, 0x79, 0x60, 0xf8, 
-	0x27, 0x79, 0xff, 0xff, 0xf8, 0x30, 0x08, 0xb2, 
-	0x10, 0xf8, 0x29, 0x86, 0x08, 0xf8, 0x27, 0x79, 
-	0xf0, 0x30, 0x7f, 0xff, 0x88, 0x11, 0xf4, 0x95, 
-	0x77, 0x10, 0x40, 0x00, 0xf6, 0xa9, 0xf8, 0x30, 
-	0x08, 0x58, 0x10, 0xf8, 0x27, 0x79, 0x08, 0xf8, 
-	0x27, 0x7a, 0xf0, 0x30, 0x7f, 0xff, 0x88, 0x11, 
-	0xf4, 0x95, 0x77, 0x10, 0x40, 0x00, 0xf6, 0xa9, 
-	0xf8, 0x20, 0x08, 0x63, 0x76, 0xf8, 0x27, 0x79, 
-	0xff, 0xff, 0x76, 0xf8, 0x27, 0x7b, 0xff, 0xff, 
-	0xf7, 0xb8, 0xf2, 0x73, 0x08, 0xd9, 0xf0, 0x20, 
-	0xff, 0xff, 0xf6, 0xb8, 0x56, 0xf8, 0x27, 0x74, 
-	0xf0, 0xf9, 0x88, 0x11, 0x56, 0xf8, 0x27, 0x72, 
-	0xf0, 0xf9, 0x88, 0x12, 0xf4, 0x95, 0xf4, 0x95, 
-	0xe7, 0x20, 0xf4, 0xa9, 0xf8, 0x30, 0x08, 0x8f, 
-	0xf1, 0x20, 0x27, 0x7c, 0x48, 0x11, 0xf6, 0x00, 
-	0x88, 0x13, 0xf4, 0x95, 0xf4, 0x95, 0x10, 0x83, 
-	0x08, 0xf8, 0x27, 0x79, 0xf0, 0x30, 0x7f, 0xff, 
-	0x88, 0x13, 0xf4, 0x95, 0x77, 0x10, 0x40, 0x00, 
-	0xf5, 0xab, 0xf8, 0x30, 0x08, 0x8f, 0x6d, 0x91, 
-	0x48, 0x11, 0xf0, 0x30, 0x01, 0xff, 0x88, 0x11, 
-	0xf4, 0x95, 0xe7, 0x20, 0xf7, 0xa9, 0xf8, 0x30, 
-	0x08, 0x74, 0x6d, 0x89, 0x48, 0x11, 0xf0, 0x30, 
-	0x01, 0xff, 0xf0, 0xe7, 0xf4, 0x95, 0x48, 0x08, 
-	0x4e, 0xf8, 0x27, 0x74, 0x48, 0x08, 0xf1, 0xf9, 
-	0x89, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x71, 0xe1, 
-	0x27, 0x7c, 0x27, 0x7a, 0x60, 0xf8, 0x27, 0x7b, 
-	0xff, 0xff, 0xf8, 0x30, 0x08, 0xab, 0x48, 0x08, 
-	0x4e, 0xf8, 0x27, 0x72, 0x76, 0xf8, 0x27, 0x7b, 
-	0xff, 0xff, 0x76, 0xf8, 0x27, 0x79, 0xff, 0xff, 
-	0xf2, 0x73, 0x08, 0xd9, 0xf4, 0x95, 0xe8, 0x00, 
-	0x44, 0xf8, 0x27, 0x73, 0x40, 0xf8, 0x27, 0x75, 
-	0x82, 0xf8, 0x00, 0x11, 0xf4, 0x95, 0x77, 0x10, 
-	0x80, 0x00, 0xf6, 0xa9, 0xf8, 0x20, 0x08, 0xd8, 
-	0xf6, 0xb8, 0x10, 0xf8, 0x27, 0x73, 0xf0, 0x00, 
-	0x80, 0x00, 0x48, 0x08, 0x4e, 0xf8, 0x27, 0x74, 
-	0x48, 0x08, 0xf0, 0xf9, 0x88, 0x11, 0xf4, 0x95, 
-	0xf4, 0x95, 0x71, 0xe1, 0x27, 0x7c, 0x27, 0x7a, 
-	0xf7, 0xb8, 0x57, 0xf8, 0x27, 0x74, 0xf0, 0x62, 
-	0xff, 0xff, 0xf0, 0x40, 0xff, 0x80, 0xf2, 0x80, 
-	0x4e, 0xf8, 0x27, 0x74, 0xe8, 0x00, 0x8a, 0x11, 
-	0xfc, 0x00, 0x4a, 0x11, 0x4a, 0x16, 0xee, 0xfb, 
-	0x11, 0xf8, 0x27, 0x71, 0x09, 0xf8, 0x27, 0x73, 
-	0x89, 0x11, 0x88, 0x10, 0xf4, 0x95, 0xf4, 0x95, 
-	0xf6, 0xa9, 0xf8, 0x20, 0x08, 0xed, 0xf2, 0x73, 
-	0x09, 0x0e, 0xf4, 0x95, 0xe8, 0x00, 0xf6, 0x20, 
-	0x76, 0x00, 0x00, 0x41, 0xf0, 0x74, 0x12, 0xee, 
-	0x88, 0x16, 0xf4, 0x95, 0xf7, 0xb8, 0x6d, 0x96, 
-	0x10, 0xf8, 0x00, 0x16, 0xf8, 0x47, 0x09, 0x0a, 
-	0xe7, 0x61, 0x76, 0x00, 0x00, 0x00, 0x76, 0x01, 
-	0x00, 0x80, 0x76, 0x02, 0x00, 0xff, 0x76, 0x03, 
-	0x00, 0x00, 0xf2, 0x74, 0x0c, 0xb9, 0xf4, 0x95, 
-	0xe8, 0x00, 0x6c, 0xe9, 0xff, 0xff, 0x08, 0xfb, 
-	0x73, 0x16, 0x00, 0x0e, 0xf0, 0x66, 0x00, 0x41, 
-	0xee, 0x05, 0x8a, 0x16, 0x8a, 0x11, 0xfc, 0x00, 
-	0x4a, 0x11, 0xf4, 0x95, 0x71, 0x02, 0x00, 0x13, 
-	0xf6, 0xb8, 0x77, 0x11, 0x7f, 0xff, 0x57, 0xf8, 
-	0x27, 0x72, 0x48, 0x11, 0xf2, 0x80, 0xf0, 0x00, 
-	0x80, 0x00, 0x88, 0x11, 0xf6, 0x40, 0xf0, 0xe0, 
-	0xf1, 0xf1, 0xe8, 0x01, 0xf2, 0x80, 0x80, 0xf8, 
-	0x27, 0x78, 0x77, 0x12, 0x80, 0x00, 0x57, 0xf8, 
-	0x27, 0x72, 0x48, 0x12, 0xf2, 0x80, 0x88, 0x12, 
-	0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x82, 0x09, 0x38, 
-	0xe8, 0x00, 0x75, 0xf8, 0x00, 0x08, 0x00, 0x01, 
-	0xf0, 0x73, 0x09, 0x3d, 0xf0, 0x20, 0x80, 0x01, 
-	0x75, 0xf8, 0x00, 0x08, 0x00, 0x01, 0x70, 0x81, 
-	0x00, 0x13, 0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 
-	0xf0, 0x30, 0x7f, 0xff, 0x11, 0xf8, 0x29, 0x86, 
-	0xf5, 0x20, 0xf3, 0x30, 0x7f, 0xff, 0x89, 0x11, 
-	0xf4, 0x95, 0x77, 0x10, 0x40, 0x00, 0xf6, 0xa9, 
-	0xf8, 0x20, 0x09, 0x54, 0xf2, 0x73, 0x09, 0x67, 
-	0xf4, 0x95, 0xe8, 0x02, 0x6f, 0xf8, 0x27, 0x7a, 
-	0x0d, 0x20, 0xf3, 0x30, 0x7f, 0xff, 0x89, 0x11, 
-	0xf4, 0x95, 0x77, 0x10, 0x40, 0x00, 0xf6, 0xa9, 
-	0xf8, 0x20, 0x09, 0x64, 0xf2, 0x73, 0x09, 0x67, 
-	0xf4, 0x95, 0xe8, 0x01, 0x80, 0xf8, 0x27, 0x7b, 
-	0xe8, 0x00, 0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 
-	0x11, 0xf8, 0x29, 0x86, 0xf5, 0x20, 0xf3, 0x30, 
-	0x7f, 0xff, 0x89, 0x11, 0xf4, 0x95, 0x77, 0x10, 
-	0x40, 0x00, 0xf6, 0xa9, 0xf8, 0x20, 0x09, 0x7a, 
-	0xf2, 0x73, 0x09, 0x8d, 0xf4, 0x95, 0xe8, 0x02, 
-	0x6f, 0xf8, 0x27, 0x7a, 0x0d, 0x20, 0xf3, 0x30, 
-	0x7f, 0xff, 0x89, 0x11, 0xf4, 0x95, 0x77, 0x10, 
-	0x40, 0x00, 0xf6, 0xa9, 0xf8, 0x20, 0x09, 0x8a, 
-	0xf2, 0x73, 0x09, 0x8d, 0xf4, 0x95, 0xe8, 0x01, 
-	0x80, 0xf8, 0x27, 0x79, 0xe8, 0x00, 0x8a, 0x11, 
-	0xfc, 0x00, 0x4a, 0x11, 0xf4, 0x95, 0x71, 0x02, 
-	0x00, 0x12, 0x88, 0x11, 0xf6, 0xb8, 0x57, 0xf8, 
-	0x27, 0x72, 0xf0, 0x20, 0x7f, 0xff, 0xf2, 0x80, 
-	0xf0, 0x00, 0x80, 0x00, 0x80, 0x81, 0x57, 0xf8, 
-	0x27, 0x72, 0xe8, 0x01, 0xf3, 0xf1, 0xf2, 0x80, 
-	0x80, 0xf8, 0x27, 0x78, 0x77, 0x11, 0x80, 0x00, 
-	0x48, 0x11, 0x57, 0xf8, 0x27, 0x72, 0xf2, 0x80, 
-	0x88, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x81, 
-	0x09, 0xb5, 0xe8, 0x00, 0x75, 0xf8, 0x00, 0x08, 
-	0x00, 0x01, 0xf0, 0x73, 0x09, 0xba, 0xf0, 0x20, 
-	0x80, 0x01, 0x75, 0xf8, 0x00, 0x08, 0x00, 0x01, 
-	0x45, 0xf8, 0x27, 0x71, 0x43, 0xf8, 0x27, 0x73, 
-	0x83, 0xf8, 0x00, 0x11, 0xf4, 0x95, 0xe7, 0x20, 
-	0xf6, 0xa9, 0xf8, 0x30, 0x09, 0xc9, 0xf2, 0x73, 
-	0x09, 0xe4, 0x77, 0x12, 0x00, 0x00, 0x57, 0xf8, 
-	0x27, 0x72, 0xf0, 0x20, 0x7f, 0xff, 0xf2, 0x80, 
-	0x49, 0x12, 0xf5, 0x00, 0xf3, 0x00, 0x80, 0x00, 
-	0x61, 0xf8, 0x00, 0x0b, 0x80, 0x00, 0xf8, 0x30, 
-	0x09, 0xdc, 0xf1, 0x20, 0x80, 0x00, 0xf5, 0x20, 
-	0x89, 0x12, 0xf4, 0x95, 0x48, 0x12, 0x6f, 0xf8, 
-	0x27, 0x73, 0x0d, 0x00, 0xf4, 0x95, 0x49, 0x0b, 
-	0x4f, 0xf8, 0x27, 0x72, 0x8a, 0x11, 0xfe, 0x00, 
-	0x48, 0x12, 0xf4, 0x95, 0x4a, 0x11, 0x4a, 0x16, 
-	0x4a, 0x17, 0xee, 0xfc, 0xf4, 0x95, 0x71, 0x08, 
-	0x00, 0x16, 0x88, 0x17, 0xf0, 0x74, 0x08, 0x30, 
-	0x48, 0x18, 0x70, 0x00, 0x00, 0x16, 0xf2, 0x74, 
-	0x09, 0x8f, 0xf0, 0x00, 0x00, 0x02, 0x88, 0x11, 
-	0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x81, 0x0a, 0x0a, 
-	0xf2, 0x74, 0x08, 0xdb, 0xf4, 0x95, 0x48, 0x16, 
-	0x48, 0x18, 0x70, 0x00, 0x00, 0x16, 0xf2, 0x74, 
-	0x09, 0x8f, 0xf0, 0x00, 0x00, 0x02, 0x88, 0x11, 
-	0x10, 0x02, 0x70, 0x01, 0x00, 0x11, 0x80, 0x00, 
-	0xf2, 0x74, 0x06, 0xce, 0xf4, 0x95, 0x48, 0x17, 
-	0x49, 0x11, 0x48, 0x17, 0xf6, 0x00, 0x88, 0x17, 
-	0xe7, 0x60, 0xf5, 0xa9, 0xf8, 0x20, 0x0a, 0x2d, 
-	0x48, 0x16, 0xf6, 0x20, 0x88, 0x11, 0x48, 0x18, 
-	0x70, 0x00, 0x00, 0x11, 0xf2, 0x74, 0x09, 0x8f, 
-	0xf0, 0x00, 0x00, 0x02, 0x88, 0x11, 0x70, 0x01, 
-	0x00, 0x11, 0x10, 0x02, 0x80, 0x00, 0xf2, 0x74, 
-	0x06, 0xce, 0xf4, 0x95, 0x48, 0x17, 0xee, 0x04, 
-	0x48, 0x16, 0x8a, 0x17, 0x8a, 0x16, 0x8a, 0x11, 
-	0xfc, 0x00, 0xee, 0xfd, 0xe8, 0x00, 0x4e, 0xf8, 
-	0x27, 0x70, 0xe8, 0x00, 0x4e, 0xf8, 0x27, 0x72, 
-	0xe8, 0x00, 0x4e, 0xf8, 0x27, 0x74, 0xe8, 0x00, 
-	0x4e, 0xf8, 0x27, 0x76, 0x76, 0xf8, 0x27, 0x79, 
-	0xff, 0xff, 0x76, 0xf8, 0x27, 0x7a, 0x00, 0x00, 
-	0x76, 0xf8, 0x27, 0x7b, 0xff, 0xff, 0x76, 0xf8, 
-	0x27, 0x78, 0x00, 0x00, 0xe8, 0x00, 0x75, 0xf8, 
-	0x00, 0x08, 0x00, 0x01, 0x76, 0x00, 0x00, 0x00, 
-	0x76, 0x01, 0x02, 0x00, 0xf2, 0x74, 0x12, 0xdc, 
-	0xf0, 0x20, 0x27, 0x7c, 0xee, 0x03, 0xfc, 0x00, 
-	0x4a, 0x11, 0xee, 0xfc, 0xf4, 0x95, 0x4e, 0x00, 
-	0x77, 0x12, 0x7f, 0xff, 0xf6, 0xb8, 0x49, 0x12, 
-	0xf1, 0x80, 0xf3, 0x00, 0x80, 0x00, 0x89, 0x12, 
-	0xf0, 0xe0, 0xf1, 0xf1, 0x4f, 0x02, 0xe9, 0x01, 
-	0xf4, 0x95, 0x48, 0x0b, 0xf5, 0x40, 0x56, 0x02, 
-	0xf1, 0x80, 0x81, 0xf8, 0x27, 0x78, 0x77, 0x11, 
-	0x80, 0x00, 0x56, 0x00, 0x49, 0x11, 0xf1, 0x80, 
-	0x89, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x81, 
-	0x0a, 0x81, 0xe8, 0x00, 0x75, 0xf8, 0x00, 0x08, 
-	0x00, 0x01, 0xf0, 0x73, 0x0a, 0x86, 0xf0, 0x20, 
-	0x80, 0x01, 0x75, 0xf8, 0x00, 0x08, 0x00, 0x01, 
-	0x10, 0x82, 0xee, 0x04, 0x8a, 0x11, 0xfc, 0x00, 
-	0x4a, 0x11, 0xee, 0xfe, 0xf4, 0x95, 0x4e, 0x00, 
-	0x77, 0x11, 0x7f, 0xff, 0xf6, 0xb8, 0x49, 0x11, 
-	0xf1, 0x80, 0xf3, 0x00, 0x80, 0x00, 0x89, 0x11, 
-	0xf0, 0xe0, 0xf1, 0xf1, 0xe8, 0x01, 0xf2, 0x80, 
-	0x80, 0xf8, 0x27, 0x78, 0x56, 0x00, 0xf1, 0x20, 
-	0x80, 0x00, 0xf1, 0x80, 0xf4, 0x95, 0x49, 0x0b, 
-	0xf8, 0x4d, 0x0a, 0xab, 0xf0, 0x20, 0x80, 0x01, 
-	0x75, 0xf8, 0x00, 0x08, 0x00, 0x01, 0xf0, 0x73, 
-	0x0a, 0xaf, 0xe8, 0x00, 0x75, 0xf8, 0x00, 0x08, 
-	0x00, 0x01, 0xee, 0x02, 0x48, 0x11, 0x8a, 0x11, 
-	0xfc, 0x00, 0x4a, 0x11, 0x88, 0x12, 0x13, 0x02, 
-	0x77, 0x11, 0x00, 0x00, 0xf8, 0x4d, 0x0a, 0xcb, 
-	0xf3, 0x10, 0x00, 0x01, 0x89, 0x1a, 0xf4, 0x95, 
-	0xf0, 0x72, 0x0a, 0xca, 0x48, 0x11, 0x1c, 0xf8, 
-	0x29, 0x7e, 0x88, 0x11, 0x11, 0xf8, 0x29, 0x7e, 
-	0xf2, 0x00, 0x00, 0x01, 0x80, 0xf8, 0x29, 0x7e, 
-	0x81, 0x92, 0x48, 0x11, 0x8a, 0x11, 0xfc, 0x00, 
-	0x4a, 0x11, 0xf4, 0x95, 0x71, 0x02, 0x00, 0x11, 
-	0x88, 0x12, 0xf6, 0xb8, 0xf0, 0x20, 0x7f, 0xff, 
-	0x57, 0xf8, 0x27, 0x70, 0xf2, 0x80, 0xf0, 0x00, 
-	0x80, 0x00, 0x80, 0x82, 0x57, 0xf8, 0x27, 0x70, 
-	0xe8, 0x01, 0xf3, 0xf1, 0xf2, 0x80, 0x80, 0xf8, 
-	0x27, 0x78, 0x77, 0x12, 0x80, 0x00, 0x48, 0x12, 
-	0x57, 0xf8, 0x27, 0x70, 0xf2, 0x80, 0x88, 0x12, 
-	0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x82, 0x0a, 0xf4, 
-	0xe8, 0x00, 0x75, 0xf8, 0x00, 0x08, 0x00, 0x01, 
-	0xf0, 0x73, 0x0a, 0xf9, 0xf0, 0x20, 0x80, 0x01, 
-	0x75, 0xf8, 0x00, 0x08, 0x00, 0x01, 0x45, 0xf8, 
-	0x27, 0x75, 0xe7, 0x10, 0x43, 0xf8, 0x27, 0x71, 
-	0x83, 0xf8, 0x00, 0x12, 0x6d, 0xe8, 0x00, 0x04, 
-	0x6d, 0x8a, 0xf6, 0xaa, 0xf8, 0x30, 0x0b, 0x0a, 
-	0xf2, 0x73, 0x0b, 0x25, 0x77, 0x11, 0x00, 0x00, 
-	0x57, 0xf8, 0x27, 0x70, 0xf0, 0x20, 0x7f, 0xff, 
-	0xf2, 0x80, 0x49, 0x11, 0xf5, 0x00, 0xf3, 0x00, 
-	0x80, 0x00, 0x61, 0xf8, 0x00, 0x0b, 0x80, 0x00, 
-	0xf8, 0x30, 0x0b, 0x1d, 0xf1, 0x20, 0x80, 0x00, 
-	0xf5, 0x20, 0x89, 0x11, 0xf4, 0x95, 0x48, 0x11, 
-	0x6f, 0xf8, 0x27, 0x71, 0x0d, 0x00, 0xf4, 0x95, 
-	0x49, 0x0b, 0x4f, 0xf8, 0x27, 0x70, 0x48, 0x11, 
-	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0x4a, 0x16, 
-	0x4a, 0x17, 0xee, 0xf0, 0x88, 0x17, 0x10, 0x17, 
-	0x80, 0x05, 0x10, 0x16, 0x80, 0x06, 0x10, 0x15, 
-	0x80, 0x07, 0x71, 0x14, 0x00, 0x11, 0x10, 0x05, 
-	0xf0, 0x30, 0x00, 0x01, 0x88, 0x10, 0x10, 0x06, 
-	0xf0, 0x30, 0x00, 0x01, 0x80, 0x08, 0x49, 0x11, 
-	0x10, 0x05, 0xf6, 0x01, 0x80, 0x09, 0x10, 0x06, 
-	0x61, 0xf8, 0x00, 0x08, 0x00, 0x01, 0xf8, 0x20, 
-	0x0b, 0x4b, 0x10, 0x09, 0xf0, 0x00, 0x00, 0x01, 
-	0x80, 0x09, 0x71, 0x08, 0x00, 0x12, 0xf4, 0xaa, 
-	0xf8, 0x30, 0x0b, 0x54, 0x10, 0x09, 0xf0, 0x00, 
-	0x00, 0x01, 0x80, 0x09, 0x12, 0x09, 0x49, 0x11, 
-	0xf4, 0x7f, 0x80, 0x09, 0xf6, 0x20, 0x80, 0x0a, 
-	0x56, 0xf8, 0x27, 0x70, 0x4e, 0x0c, 0x10, 0x09, 
-	0x80, 0x00, 0x48, 0x18, 0xf2, 0x74, 0x0a, 0xce, 
-	0xf0, 0x00, 0x00, 0x04, 0x88, 0x16, 0xf4, 0x95, 
-	0xf4, 0x95, 0x6c, 0x86, 0x0b, 0x6d, 0xf2, 0x73, 
-	0x0c, 0x59, 0xf4, 0x95, 0xe8, 0x00, 0xf6, 0xb8, 
-	0xf4, 0x95, 0x56, 0x0c, 0xf0, 0xf9, 0x88, 0x12, 
-	0xf4, 0x95, 0xf4, 0x95, 0x70, 0xe2, 0x27, 0x7c, 
-	0x29, 0x86, 0xe8, 0x00, 0x80, 0x0e, 0x48, 0x11, 
-	0xf8, 0x45, 0x0b, 0xcc, 0x77, 0x10, 0x00, 0x01, 
-	0xf4, 0xa9, 0xf8, 0x30, 0x0b, 0x89, 0x6c, 0xe1, 
-	0xff, 0xfd, 0x0b, 0x8b, 0x10, 0xe7, 0x00, 0x02, 
-	0x80, 0x0e, 0xf0, 0x73, 0x0b, 0x8b, 0x10, 0x87, 
-	0x80, 0x0e, 0xe7, 0x10, 0xf5, 0xae, 0xf8, 0x20, 
-	0x0b, 0xb2, 0x70, 0x00, 0x00, 0x17, 0x70, 0x01, 
-	0x00, 0x16, 0x10, 0x04, 0xf0, 0x74, 0x06, 0xce, 
-	0x48, 0x17, 0x49, 0x16, 0xf6, 0x00, 0x88, 0x17, 
-	0x48, 0x11, 0xf6, 0x20, 0x88, 0x11, 0x10, 0x09, 
-	0xf6, 0x20, 0x80, 0x00, 0x48, 0x18, 0xf2, 0x74, 
-	0x0a, 0xce, 0xf0, 0x00, 0x00, 0x04, 0x88, 0x16, 
-	0x10, 0x04, 0x70, 0x00, 0x00, 0x17, 0x70, 0x01, 
-	0x00, 0x11, 0xf0, 0x74, 0x06, 0xce, 0x48, 0x11, 
-	0x00, 0x04, 0x80, 0x04, 0xf0, 0x73, 0x0b, 0xbc, 
-	0x70, 0x00, 0x00, 0x17, 0x70, 0x01, 0x00, 0x11, 
-	0x10, 0x04, 0xf0, 0x74, 0x06, 0xce, 0x48, 0x11, 
-	0x00, 0x04, 0x80, 0x04, 0x49, 0x11, 0x48, 0x16, 
-	0xf6, 0x20, 0x88, 0x16, 0xf4, 0x95, 0xf4, 0x95, 
-	0x6c, 0x86, 0x0b, 0xcc, 0x10, 0x0a, 0x80, 0x00, 
-	0x48, 0x18, 0xf2, 0x74, 0x0a, 0xce, 0xf0, 0x00, 
-	0x00, 0x04, 0x88, 0x16, 0x12, 0x0a, 0xf8, 0x45, 
-	0x0c, 0x33, 0x71, 0x0a, 0x00, 0x10, 0xf4, 0xae, 
-	0xf8, 0x30, 0x0c, 0x1c, 0x48, 0x16, 0xf0, 0xe1, 
-	0x88, 0x11, 0x12, 0x08, 0xf8, 0x45, 0x0b, 0xdb, 
-	0x6d, 0x89, 0x12, 0x07, 0xf8, 0x45, 0x0b, 0xe9, 
-	0x10, 0x07, 0x80, 0x00, 0x70, 0x02, 0x00, 0x11, 
-	0x10, 0x06, 0x80, 0x01, 0x10, 0x04, 0xf0, 0x74, 
-	0x06, 0xdc, 0xf0, 0x73, 0x0b, 0xef, 0x48, 0x11, 
-	0x6f, 0x00, 0x0c, 0x9f, 0x10, 0x04, 0xf0, 0x74, 
-	0x0a, 0xb3, 0x11, 0x0e, 0xf1, 0xc0, 0x81, 0x0e, 
-	0x10, 0x06, 0x49, 0x11, 0xf6, 0x00, 0x80, 0x06, 
-	0x10, 0x05, 0xf6, 0x20, 0x88, 0x11, 0xf0, 0x00, 
-	0x00, 0x01, 0x48, 0x08, 0x6f, 0x00, 0x0c, 0x9f, 
-	0x48, 0x18, 0xf2, 0x74, 0x0a, 0xce, 0xf0, 0x00, 
-	0x00, 0x04, 0x12, 0x07, 0xf8, 0x45, 0x0c, 0x11, 
-	0x10, 0x07, 0x80, 0x00, 0x70, 0x02, 0x00, 0x11, 
-	0x10, 0x06, 0x80, 0x01, 0x10, 0x04, 0xf0, 0x74, 
-	0x06, 0xdc, 0xf0, 0x73, 0x0c, 0x17, 0x48, 0x11, 
-	0x6f, 0x00, 0x0c, 0x9f, 0x10, 0x04, 0xf0, 0x74, 
-	0x0a, 0xb3, 0x11, 0x0e, 0xf1, 0xc0, 0x81, 0x0e, 
-	0xf0, 0x73, 0x0c, 0x33, 0x12, 0x07, 0xf8, 0x45, 
-	0x0c, 0x2a, 0x10, 0x07, 0x80, 0x00, 0x10, 0x06, 
-	0x80, 0x01, 0x10, 0x05, 0x80, 0x02, 0x10, 0x04, 
-	0xf0, 0x74, 0x06, 0xdc, 0xf0, 0x73, 0x0c, 0x30, 
-	0x12, 0x05, 0x6f, 0x00, 0x0c, 0x9f, 0x10, 0x04, 
-	0xf0, 0x74, 0x0a, 0xb3, 0x11, 0x0e, 0xf1, 0xc0, 
-	0x81, 0x0e, 0x76, 0x00, 0x00, 0x01, 0x48, 0x18, 
-	0xf2, 0x74, 0x0a, 0xce, 0xf0, 0x00, 0x00, 0x04, 
-	0x71, 0x04, 0x00, 0x11, 0x70, 0x81, 0x29, 0x86, 
-	0x10, 0x0e, 0x1c, 0xf8, 0x29, 0x86, 0x80, 0x0e, 
-	0x76, 0x00, 0x00, 0x01, 0x48, 0x18, 0xf2, 0x74, 
-	0x0a, 0xce, 0xf0, 0x00, 0x00, 0x04, 0x10, 0x0e, 
-	0x71, 0x04, 0x00, 0x11, 0x80, 0x81, 0x10, 0xf8, 
-	0x29, 0x86, 0xf0, 0x00, 0x00, 0x01, 0xf0, 0x30, 
-	0x7f, 0xff, 0x80, 0xf8, 0x29, 0x86, 0x10, 0x09, 
-	0xf0, 0x00, 0x00, 0x02, 0x80, 0x09, 0xee, 0x10, 
-	0x8a, 0x17, 0x8a, 0x16, 0x8a, 0x11, 0xfc, 0x00, 
-	0x10, 0xf8, 0x27, 0x75, 0x08, 0xf8, 0x27, 0x71, 
-	0xf0, 0x10, 0x00, 0x01, 0x48, 0x08, 0xfc, 0x00, 
-	0x4a, 0x11, 0x4a, 0x16, 0xee, 0xff, 0xf4, 0x95, 
-	0x71, 0x04, 0x00, 0x16, 0xf0, 0x00, 0x00, 0x01, 
-	0x48, 0x08, 0x4e, 0xf8, 0x29, 0x7c, 0x6d, 0xee, 
-	0xff, 0xfd, 0x48, 0x16, 0xf8, 0x45, 0x0c, 0x99, 
-	0x56, 0xf8, 0x29, 0x7c, 0xf0, 0x74, 0x0a, 0x5a, 
-	0x88, 0x11, 0x10, 0xf8, 0x29, 0x7d, 0xf0, 0x00, 
-	0x00, 0x01, 0x48, 0x08, 0x4e, 0xf8, 0x29, 0x7c, 
-	0x10, 0xf8, 0x29, 0x82, 0xf0, 0x00, 0x00, 0x01, 
-	0x88, 0x10, 0xf4, 0x95, 0xf4, 0x95, 0xf4, 0xa9, 
-	0xfa, 0x30, 0x0c, 0x96, 0x80, 0xf8, 0x29, 0x82, 
-	0x56, 0xf8, 0x29, 0x80, 0xf0, 0x00, 0x00, 0x01, 
-	0x4e, 0xf8, 0x29, 0x80, 0x73, 0x11, 0x29, 0x82, 
-	0x6c, 0xee, 0xff, 0xff, 0x0c, 0x76, 0xee, 0x01, 
-	0x8a, 0x16, 0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 
-	0x76, 0xf8, 0x29, 0x84, 0x00, 0x00, 0x76, 0xf8, 
-	0x29, 0x85, 0x00, 0x01, 0xe8, 0x00, 0x4e, 0xf8, 
-	0x2a, 0x0c, 0x76, 0xf8, 0x29, 0x86, 0x00, 0x00, 
-	0x76, 0xf8, 0x29, 0x87, 0x00, 0x00, 0x77, 0x11, 
-	0x29, 0x88, 0x76, 0x81, 0xaa, 0xaa, 0x76, 0xe1, 
-	0x00, 0x01, 0xaa, 0xaa, 0x76, 0xe1, 0x00, 0x02, 
-	0x00, 0x00, 0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 
-	0xee, 0xfc, 0xf4, 0x95, 0x71, 0x06, 0x00, 0x14, 
-	0x71, 0x07, 0x00, 0x13, 0x71, 0x08, 0x00, 0x12, 
-	0x71, 0x09, 0x00, 0x15, 0x77, 0x10, 0x00, 0xff, 
-	0xf4, 0xaa, 0xf8, 0x30, 0x0d, 0x44, 0x49, 0x13, 
-	0x53, 0xf8, 0x2a, 0x0c, 0x4f, 0xf8, 0x2a, 0x0c, 
-	0x73, 0x12, 0x00, 0x0e, 0xf1, 0x66, 0x00, 0x0d, 
-	0x89, 0x11, 0xf4, 0x95, 0x77, 0x10, 0x00, 0x01, 
-	0x71, 0xe1, 0x24, 0x00, 0x00, 0x11, 0xf4, 0xa9, 
-	0xf8, 0x30, 0x0d, 0x17, 0x77, 0x10, 0x00, 0x02, 
-	0xf4, 0xa9, 0xf8, 0x30, 0x0c, 0xec, 0x77, 0x11, 
-	0x29, 0x8a, 0x76, 0x81, 0x00, 0x00, 0xe8, 0x00, 
-	0x77, 0x14, 0x00, 0x00, 0x77, 0x13, 0x00, 0x00, 
-	0xf0, 0x73, 0x0d, 0x48, 0x6c, 0x83, 0x0c, 0xfa, 
-	0x77, 0x11, 0x29, 0x8a, 0x48, 0x12, 0xf0, 0xe8, 
-	0xf0, 0x40, 0x80, 0x00, 0x80, 0x81, 0xe8, 0x00, 
-	0x77, 0x14, 0x00, 0x00, 0xf0, 0x73, 0x0d, 0x48, 
-	0x49, 0x13, 0xf3, 0x40, 0x80, 0x00, 0x81, 0xf8, 
-	0x29, 0x8a, 0x61, 0xf8, 0x00, 0x15, 0x00, 0x01, 
-	0xf8, 0x20, 0x0d, 0x07, 0x69, 0xf8, 0x29, 0x8a, 
-	0x40, 0x00, 0x61, 0xf8, 0x00, 0x14, 0x00, 0x01, 
-	0xf8, 0x20, 0x0d, 0x0f, 0x69, 0xf8, 0x29, 0x8a, 
-	0x20, 0x00, 0x77, 0x11, 0x29, 0x8a, 0x49, 0x12, 
-	0xf3, 0xe8, 0x1b, 0x81, 0x81, 0x81, 0xf0, 0x73, 
-	0x0d, 0x48, 0x11, 0xf8, 0x29, 0x84, 0xf8, 0x4c, 
-	0x0d, 0x37, 0x77, 0x11, 0x29, 0x88, 0x76, 0x81, 
-	0xaa, 0xaa, 0x11, 0xf8, 0x29, 0x85, 0xf3, 0x10, 
-	0x00, 0x01, 0xf3, 0x40, 0xaa, 0x00, 0x81, 0xe1, 
-	0x00, 0x01, 0x76, 0x00, 0x00, 0x02, 0x80, 0x01, 
-	0x70, 0x02, 0x00, 0x14, 0x70, 0x03, 0x00, 0x13, 
-	0xf2, 0x74, 0x0b, 0x28, 0xf4, 0x95, 0x48, 0x11, 
-	0x71, 0xf8, 0x29, 0x85, 0x29, 0x84, 0xf0, 0x73, 
-	0x0d, 0x73, 0x76, 0x00, 0x00, 0x00, 0x80, 0x01, 
-	0x76, 0x02, 0x00, 0x00, 0x70, 0x03, 0x00, 0x13, 
-	0xf2, 0x74, 0x0b, 0x28, 0xf4, 0x95, 0xe8, 0x00, 
-	0xf0, 0x73, 0x0d, 0x73, 0x77, 0x11, 0x29, 0x8a, 
-	0x70, 0x81, 0x00, 0x13, 0x11, 0xf8, 0x29, 0x84, 
-	0xf8, 0x4c, 0x0d, 0x68, 0x77, 0x11, 0x29, 0x88, 
-	0x76, 0x81, 0xaa, 0xaa, 0x11, 0xf8, 0x29, 0x85, 
-	0xf3, 0x10, 0x00, 0x01, 0xf3, 0x40, 0xaa, 0x00, 
-	0x81, 0xe1, 0x00, 0x01, 0x76, 0x00, 0x00, 0x03, 
-	0x80, 0x01, 0x70, 0x02, 0x00, 0x14, 0x70, 0x03, 
-	0x00, 0x13, 0xf2, 0x74, 0x0b, 0x28, 0xf4, 0x95, 
-	0x48, 0x11, 0x71, 0xf8, 0x29, 0x85, 0x29, 0x84, 
-	0xf0, 0x73, 0x0d, 0x73, 0x76, 0x00, 0x00, 0x01, 
-	0x80, 0x01, 0x70, 0x02, 0x00, 0x14, 0x70, 0x03, 
-	0x00, 0x13, 0xf2, 0x74, 0x0b, 0x28, 0xf4, 0x95, 
-	0x48, 0x11, 0x6b, 0xf8, 0x29, 0x84, 0xff, 0xff, 
-	0xee, 0x04, 0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 
-	0xf5, 0x40, 0xf4, 0x95, 0x48, 0x0b, 0xf4, 0x78, 
-	0x88, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x6c, 0xe1, 
-	0xff, 0xb9, 0x0d, 0x88, 0xf2, 0x73, 0x0d, 0xa5, 
-	0xf4, 0x95, 0xe8, 0x60, 0xf2, 0x00, 0x00, 0x06, 
-	0x61, 0xf8, 0x00, 0x11, 0x00, 0x20, 0xf8, 0x30, 
-	0x0d, 0x98, 0x61, 0xf8, 0x00, 0x0b, 0x00, 0x01, 
-	0xf8, 0x20, 0x0d, 0xa3, 0xf2, 0x00, 0x00, 0x07, 
-	0xf0, 0x73, 0x0d, 0xa3, 0x61, 0xf8, 0x00, 0x0b, 
-	0x00, 0x01, 0xf8, 0x20, 0x0d, 0xa1, 0xf2, 0x73, 
-	0x0d, 0xa3, 0xf0, 0x00, 0x00, 0x01, 0xf0, 0x00, 
-	0x00, 0x02, 0x48, 0x08, 0xf4, 0x7f, 0x8a, 0x11, 
-	0xfc, 0x00, 0xee, 0xff, 0xf0, 0x74, 0x07, 0xfd, 
-	0xf0, 0x74, 0x07, 0x44, 0xf0, 0x74, 0x0d, 0xb4, 
-	0xf0, 0x74, 0x02, 0x05, 0xf0, 0x74, 0x04, 0x60, 
-	0xf0, 0x73, 0x0d, 0xaa, 0xee, 0xfd, 0x10, 0xf8, 
-	0x2a, 0xa3, 0xf8, 0x44, 0x0d, 0xcb, 0x10, 0xf8, 
-	0x2a, 0xa4, 0xf8, 0x45, 0x0d, 0xd7, 0x76, 0x00, 
-	0x02, 0x00, 0xf2, 0x74, 0x09, 0xe8, 0xf0, 0x20, 
-	0x22, 0x00, 0x76, 0xf8, 0x2a, 0xa4, 0x00, 0x00, 
-	0x76, 0xf8, 0x2a, 0xa7, 0x00, 0x00, 0xf0, 0x73, 
-	0x0d, 0xd7, 0x76, 0x00, 0x02, 0x00, 0xf2, 0x74, 
-	0x09, 0xe8, 0xf0, 0x20, 0x20, 0x00, 0x76, 0xf8, 
-	0x2a, 0xa3, 0x00, 0x00, 0x76, 0xf8, 0x2a, 0xa7, 
-	0x00, 0x01, 0xf0, 0x74, 0x0c, 0x5e, 0xf0, 0xe0, 
-	0xf0, 0x10, 0x3a, 0x98, 0xf8, 0x47, 0x0d, 0xe1, 
-	0x76, 0xf8, 0x27, 0x6e, 0x00, 0x00, 0xee, 0x03, 
-	0xfc, 0x00, 0x4a, 0x11, 0xee, 0xfe, 0x77, 0x11, 
-	0x20, 0x00, 0x76, 0x00, 0xaa, 0xaa, 0x76, 0x01, 
-	0x02, 0x00, 0xf2, 0x74, 0x06, 0x6c, 0xf4, 0x95, 
-	0x48, 0x11, 0x76, 0x00, 0x55, 0x55, 0x76, 0x01, 
-	0x02, 0x00, 0x48, 0x11, 0xf2, 0x74, 0x06, 0x6c, 
-	0xf0, 0x00, 0x02, 0x00, 0x76, 0xf8, 0x2a, 0xa3, 
-	0x00, 0x00, 0x76, 0xf8, 0x2a, 0xa4, 0x00, 0x00, 
-	0xe8, 0x00, 0x4e, 0x00, 0xfb, 0x80, 0x15, 0x3e, 
-	0xf4, 0x95, 0xe8, 0x04, 0x80, 0xf8, 0x2a, 0xa5, 
-	0x76, 0x00, 0x2a, 0xa8, 0xf9, 0x80, 0x14, 0x87, 
-	0x76, 0x00, 0x2a, 0xad, 0xfb, 0x80, 0x13, 0x62, 
-	0xf4, 0x95, 0xe8, 0x02, 0x10, 0xf8, 0x2a, 0xa5, 
-	0xf9, 0x80, 0x14, 0x63, 0xfb, 0x80, 0x16, 0x66, 
-	0xf4, 0x95, 0xe8, 0x1c, 0xfb, 0x80, 0x16, 0x87, 
-	0xf4, 0x95, 0xe8, 0x1c, 0xe8, 0x01, 0x4e, 0x00, 
-	0xfb, 0x80, 0x17, 0xd6, 0xf4, 0x95, 0xe8, 0x00, 
-	0x80, 0xf8, 0x2a, 0xa6, 0x76, 0x00, 0x2a, 0xb7, 
-	0xf9, 0x80, 0x16, 0xaa, 0x10, 0xf8, 0x2a, 0xa6, 
-	0xf9, 0x80, 0x17, 0x5c, 0x10, 0xf8, 0x2a, 0xa6, 
-	0xf9, 0x80, 0x17, 0x6f, 0xee, 0x02, 0x8a, 0x11, 
-	0xfc, 0x00, 0xf4, 0x95, 0x4a, 0x08, 0x4a, 0x09, 
-	0x4a, 0x0a, 0x4a, 0x07, 0x4a, 0x1d, 0x68, 0xf8, 
-	0x00, 0x07, 0x7d, 0x3f, 0x69, 0xf8, 0x00, 0x07, 
-	0x40, 0x00, 0x68, 0xf8, 0x00, 0x1d, 0xff, 0xfc, 
-	0x10, 0xf8, 0x2a, 0xa7, 0xf8, 0x44, 0x0e, 0x4b, 
-	0x76, 0xf8, 0x2a, 0xa3, 0x00, 0x01, 0xf0, 0x73, 
-	0x0e, 0x4e, 0x76, 0xf8, 0x2a, 0xa4, 0x00, 0x01, 
-	0x8a, 0x1d, 0x8a, 0x07, 0x8a, 0x0a, 0x8a, 0x09, 
-	0x8a, 0x08, 0xf4, 0xeb, 0x4a, 0x11, 0x4a, 0x16, 
-	0x4a, 0x17, 0xee, 0xfe, 0x88, 0x0e, 0x71, 0x08, 
-	0x00, 0x16, 0x71, 0x06, 0x00, 0x17, 0x11, 0x07, 
-	0xf0, 0x66, 0x00, 0x0d, 0xf0, 0x00, 0x25, 0xa0, 
-	0x88, 0x11, 0x76, 0x01, 0x00, 0x06, 0x81, 0x00, 
-	0xf2, 0x74, 0x06, 0xce, 0xf0, 0x00, 0x00, 0x01, 
-	0x76, 0x01, 0x00, 0x06, 0x70, 0x00, 0x00, 0x16, 
-	0x48, 0x11, 0xf2, 0x74, 0x06, 0xce, 0xf0, 0x00, 
-	0x00, 0x07, 0x70, 0x81, 0x00, 0x17, 0xee, 0x02, 
-	0x8a, 0x17, 0x8a, 0x16, 0x8a, 0x11, 0xfc, 0x00, 
-	0x4a, 0x11, 0x88, 0x0e, 0x71, 0x02, 0x00, 0x12, 
-	0x11, 0x03, 0xf0, 0x66, 0x00, 0x0d, 0xf0, 0x00, 
-	0x24, 0x00, 0x88, 0x11, 0xf4, 0x95, 0x70, 0x81, 
-	0x00, 0x12, 0x6e, 0xe2, 0xff, 0xfe, 0x0e, 0x8d, 
-	0xf4, 0x95, 0xe8, 0x00, 0xe8, 0x01, 0x80, 0xe1, 
-	0x00, 0x02, 0x76, 0xe1, 0x00, 0x03, 0x00, 0xff, 
-	0x76, 0xe1, 0x00, 0x04, 0x00, 0x00, 0x76, 0xe1, 
-	0x00, 0x0b, 0x00, 0x00, 0x76, 0xe1, 0x00, 0x0c, 
-	0x00, 0x00, 0x81, 0xe1, 0x00, 0x01, 0x8a, 0x11, 
-	0xfc, 0x00, 0x4a, 0x11, 0xee, 0xfc, 0x88, 0x0e, 
-	0xf4, 0x95, 0xf1, 0x66, 0x00, 0x0d, 0xf3, 0x00, 
-	0x24, 0x00, 0x89, 0x11, 0xf4, 0x95, 0xf4, 0x95, 
-	0x76, 0xe1, 0x00, 0x0c, 0x00, 0x00, 0x76, 0xe1, 
-	0x00, 0x0b, 0x00, 0x00, 0x76, 0xe1, 0x00, 0x02, 
-	0x00, 0x01, 0x76, 0x00, 0x00, 0x00, 0x76, 0x01, 
-	0x00, 0x00, 0x80, 0x02, 0x76, 0x03, 0x00, 0x00, 
-	0xf2, 0x74, 0x0c, 0xb9, 0xf4, 0x95, 0xe8, 0x00, 
-	0xee, 0x04, 0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 
-	0x88, 0x19, 0xf4, 0x95, 0x73, 0x19, 0x00, 0x0e, 
-	0xf1, 0x66, 0x00, 0x0d, 0xf2, 0x00, 0x24, 0x00, 
-	0x77, 0x15, 0x25, 0xa0, 0x77, 0x14, 0x00, 0x00, 
-	0x77, 0x1a, 0x00, 0x1f, 0xf0, 0x72, 0x0f, 0x14, 
-	0xf6, 0xb8, 0x49, 0x19, 0x09, 0x85, 0xf8, 0x4c, 
-	0x0f, 0x13, 0xf1, 0x00, 0x00, 0x05, 0x89, 0x11, 
-	0x49, 0x15, 0xf3, 0x00, 0x00, 0x01, 0x89, 0x13, 
-	0x49, 0x15, 0xf3, 0x00, 0x00, 0x07, 0x89, 0x12, 
-	0x11, 0x93, 0x1d, 0x91, 0x19, 0x92, 0x89, 0x10, 
-	0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x80, 0x0f, 0x13, 
-	0x11, 0x93, 0x1d, 0x91, 0x19, 0x92, 0x89, 0x10, 
-	0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x80, 0x0f, 0x13, 
-	0x11, 0x93, 0x1d, 0x91, 0x19, 0x92, 0x89, 0x10, 
-	0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x80, 0x0f, 0x13, 
-	0x11, 0x93, 0x1d, 0x91, 0x19, 0x92, 0x89, 0x10, 
-	0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x80, 0x0f, 0x13, 
-	0x11, 0x93, 0x1d, 0x91, 0x19, 0x92, 0x89, 0x10, 
-	0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x80, 0x0f, 0x13, 
-	0x11, 0x93, 0x1d, 0x91, 0x19, 0x92, 0x89, 0x11, 
-	0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x81, 0x0f, 0x13, 
-	0x6d, 0x94, 0x6d, 0xed, 0x00, 0x0d, 0x48, 0x14, 
-	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0x4a, 0x16, 
-	0x4a, 0x17, 0xee, 0xf8, 0x88, 0x17, 0x10, 0x0d, 
-	0x80, 0x04, 0x10, 0x0c, 0x80, 0x05, 0x71, 0x0e, 
-	0x00, 0x16, 0x73, 0x17, 0x00, 0x0e, 0xf0, 0x66, 
-	0x00, 0x0d, 0xf0, 0x00, 0x24, 0x00, 0x88, 0x11, 
-	0x10, 0xf8, 0x27, 0x63, 0xf8, 0x45, 0x0f, 0x32, 
-	0xf2, 0x74, 0x0e, 0x9f, 0xf4, 0x95, 0x48, 0x17, 
-	0x10, 0xf8, 0x27, 0x60, 0xf8, 0x44, 0x0f, 0x3d, 
-	0x60, 0xe1, 0x00, 0x02, 0x00, 0x01, 0xf8, 0x20, 
-	0x0f, 0x6d, 0xf0, 0x73, 0x11, 0x33, 0x10, 0x04, 
-	0x80, 0x00, 0x10, 0x05, 0xf0, 0x74, 0x06, 0x9f, 
-	0x11, 0x04, 0xf3, 0x00, 0x00, 0x01, 0x81, 0x04, 
-	0x6d, 0x8e, 0x77, 0x10, 0x00, 0x01, 0x71, 0xe1, 
-	0x00, 0x02, 0x00, 0x12, 0xf4, 0xaa, 0xf8, 0x30, 
-	0x0f, 0x62, 0x77, 0x10, 0x00, 0x02, 0xf4, 0xaa, 
-	0xf8, 0x30, 0x0f, 0x6d, 0x45, 0xe1, 0x00, 0x0b, 
-	0x88, 0x10, 0x43, 0xe1, 0x00, 0x0c, 0x83, 0xf8, 
-	0x00, 0x12, 0xf4, 0x95, 0xf4, 0x95, 0xf4, 0xaa, 
-	0xf8, 0x30, 0x0f, 0x6d, 0xf0, 0x73, 0x0f, 0x96, 
-	0xf5, 0x00, 0x81, 0x04, 0x49, 0x16, 0xf5, 0x20, 
-	0x89, 0x16, 0x76, 0xe1, 0x00, 0x0c, 0x00, 0x00, 
-	0x76, 0xe1, 0x00, 0x04, 0x00, 0x00, 0x48, 0x16, 
-	0xf8, 0x45, 0x11, 0x33, 0xf7, 0xb8, 0x71, 0xe1, 
-	0x00, 0x02, 0x00, 0x12, 0x10, 0xf8, 0x00, 0x12, 
-	0xf0, 0x10, 0x00, 0x03, 0xf8, 0x46, 0x0f, 0x8c, 
-	0x10, 0xf8, 0x00, 0x12, 0xf0, 0x10, 0x00, 0x03, 
-	0xf8, 0x45, 0x10, 0x16, 0x77, 0x10, 0x00, 0x01, 
-	0xf4, 0xaa, 0xf8, 0x30, 0x0f, 0x9c, 0x77, 0x10, 
-	0x00, 0x02, 0xf4, 0xaa, 0xf8, 0x30, 0x0f, 0xa8, 
-	0xf0, 0x73, 0x0f, 0x96, 0x77, 0x10, 0x00, 0x04, 
-	0xf4, 0xaa, 0xf8, 0x30, 0x10, 0xb7, 0x77, 0x10, 
-	0x00, 0x05, 0xf4, 0xaa, 0xf8, 0x30, 0x10, 0xbc, 
-	0xf2, 0x74, 0x0e, 0x9f, 0xf4, 0x95, 0x48, 0x17, 
-	0xf0, 0x73, 0x11, 0x31, 0x76, 0xe1, 0x00, 0x0c, 
-	0x00, 0x00, 0x76, 0xe1, 0x00, 0x0b, 0x00, 0x00, 
-	0x76, 0xe1, 0x00, 0x04, 0x00, 0x00, 0x76, 0xe1, 
-	0x00, 0x02, 0x00, 0x02, 0x11, 0xe1, 0x00, 0x0c, 
-	0xe8, 0x03, 0xf6, 0x20, 0x89, 0x12, 0xf4, 0x95, 
-	0x77, 0x10, 0x00, 0x03, 0xf5, 0xaa, 0xf8, 0x30, 
-	0x0f, 0xb6, 0x6b, 0xf8, 0x27, 0x6f, 0x00, 0x01, 
-	0x88, 0x10, 0xf4, 0x95, 0xf4, 0x95, 0xf5, 0xae, 
-	0xf8, 0x20, 0x0f, 0xbd, 0x48, 0x16, 0x80, 0x06, 
-	0x88, 0x13, 0xf4, 0x95, 0x77, 0x10, 0x00, 0x03, 
-	0xf6, 0xab, 0xf8, 0x20, 0x0f, 0xc8, 0x6b, 0xf8, 
-	0x27, 0x6f, 0x00, 0x01, 0x12, 0x06, 0xf8, 0x45, 
-	0x10, 0x00, 0x10, 0xe1, 0x00, 0x04, 0x80, 0x00, 
-	0x10, 0x05, 0x80, 0x01, 0x10, 0x04, 0x80, 0x02, 
-	0x10, 0x06, 0x80, 0x03, 0x48, 0x11, 0xf2, 0x74, 
-	0x07, 0x1e, 0xf0, 0x00, 0x00, 0x05, 0x10, 0x06, 
-	0x00, 0xe1, 0x00, 0x04, 0x80, 0xe1, 0x00, 0x04, 
-	0x10, 0x06, 0x00, 0xe1, 0x00, 0x0c, 0x80, 0xe1, 
-	0x00, 0x0c, 0x88, 0x12, 0x11, 0x06, 0x10, 0x04, 
-	0xf6, 0x00, 0x80, 0x04, 0x48, 0x16, 0xf6, 0x20, 
-	0x88, 0x16, 0x89, 0x13, 0xf4, 0x95, 0x77, 0x10, 
-	0x00, 0x03, 0xf6, 0xab, 0xf8, 0x20, 0x0f, 0xf5, 
-	0x6b, 0xf8, 0x27, 0x6f, 0x00, 0x01, 0x77, 0x10, 
-	0x00, 0x0c, 0x71, 0xe1, 0x00, 0x04, 0x00, 0x13, 
-	0xf6, 0xab, 0xf8, 0x20, 0x10, 0x00, 0x6b, 0xf8, 
-	0x27, 0x6f, 0x00, 0x01, 0x6c, 0xe2, 0xff, 0xfd, 
-	0x11, 0x31, 0xf6, 0xb8, 0x6f, 0xe1, 0x00, 0x05, 
-	0x0c, 0x48, 0x6f, 0xe1, 0x00, 0x06, 0x0c, 0x18, 
-	0xf0, 0x30, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x03, 
-	0x80, 0xe1, 0x00, 0x0b, 0x76, 0xe1, 0x00, 0x02, 
-	0x00, 0x03, 0x48, 0x16, 0xf8, 0x45, 0x11, 0x33, 
-	0x71, 0xe1, 0x00, 0x0c, 0x00, 0x12, 0x10, 0xe1, 
-	0x00, 0x0b, 0x49, 0x12, 0xf6, 0x20, 0x88, 0x13, 
-	0xe8, 0x0c, 0xf6, 0x20, 0x88, 0x10, 0xf4, 0x95, 
-	0xf4, 0x95, 0xf5, 0xab, 0xf8, 0x20, 0x10, 0x27, 
-	0x48, 0x13, 0x80, 0x06, 0x88, 0x10, 0xf4, 0x95, 
-	0xf4, 0x95, 0xf5, 0xae, 0xf8, 0x20, 0x10, 0x30, 
-	0x70, 0x06, 0x00, 0x16, 0x12, 0x06, 0xf8, 0x45, 
-	0x10, 0x5f, 0x10, 0xe1, 0x00, 0x04, 0x80, 0x00, 
-	0x10, 0x05, 0x80, 0x01, 0x10, 0x04, 0x80, 0x02, 
-	0x10, 0x06, 0x80, 0x03, 0x48, 0x11, 0xf2, 0x74, 
-	0x07, 0x1e, 0xf0, 0x00, 0x00, 0x05, 0x10, 0x06, 
-	0x00, 0xe1, 0x00, 0x04, 0x80, 0xe1, 0x00, 0x04, 
-	0x10, 0x06, 0x00, 0xe1, 0x00, 0x0c, 0x80, 0xe1, 
-	0x00, 0x0c, 0x88, 0x12, 0x11, 0x06, 0x10, 0x04, 
-	0xf6, 0x00, 0x80, 0x04, 0x48, 0x16, 0xf6, 0x20, 
-	0x88, 0x16, 0xf4, 0x95, 0x77, 0x10, 0x00, 0x0c, 
-	0x71, 0xe1, 0x00, 0x04, 0x00, 0x13, 0xf6, 0xab, 
-	0xf8, 0x20, 0x10, 0x5f, 0x6b, 0xf8, 0x27, 0x6f, 
-	0x00, 0x01, 0x77, 0x10, 0x00, 0x0c, 0xf6, 0xaa, 
-	0xf8, 0x20, 0x10, 0x6b, 0xf2, 0x74, 0x0e, 0x9f, 
-	0xf4, 0x95, 0x48, 0x17, 0x71, 0xe1, 0x00, 0x0c, 
-	0x00, 0x12, 0x77, 0x10, 0x00, 0x0c, 0xf4, 0xaa, 
-	0xf8, 0x30, 0x10, 0x7c, 0x77, 0x10, 0x00, 0x0c, 
-	0x71, 0xe1, 0x00, 0x0b, 0x00, 0x13, 0xf6, 0xab, 
-	0xf8, 0x30, 0x10, 0xb4, 0xe7, 0x30, 0xf7, 0xaa, 
-	0xf8, 0x30, 0x10, 0xb4, 0xf2, 0x74, 0x0e, 0xc1, 
-	0xf4, 0x95, 0x48, 0x17, 0x88, 0x12, 0xf4, 0x95, 
-	0xf4, 0x95, 0x6c, 0x82, 0x10, 0x8d, 0x76, 0xe1, 
-	0x00, 0x04, 0x00, 0x00, 0x76, 0xe1, 0x00, 0x02, 
-	0x00, 0x05, 0xf0, 0x73, 0x10, 0xb4, 0x76, 0xe1, 
-	0x00, 0x02, 0x00, 0x04, 0x77, 0x10, 0x00, 0x0c, 
-	0x71, 0xe1, 0x00, 0x0b, 0x00, 0x12, 0xf5, 0xaa, 
-	0xf8, 0x20, 0x10, 0x9a, 0xf0, 0x73, 0x10, 0x9c, 
-	0x77, 0x12, 0x00, 0x0c, 0x76, 0x00, 0x00, 0x00, 
-	0x70, 0x01, 0x00, 0x12, 0x70, 0x02, 0x00, 0x17, 
-	0x76, 0x03, 0x00, 0x01, 0x48, 0x11, 0xf2, 0x74, 
-	0x0c, 0xb9, 0xf0, 0x00, 0x00, 0x05, 0x76, 0xe1, 
-	0x00, 0x04, 0x00, 0x00, 0x77, 0x10, 0x00, 0x0c, 
-	0x71, 0xe1, 0x00, 0x0b, 0x00, 0x12, 0xf6, 0xaa, 
-	0xf8, 0x20, 0x11, 0x1c, 0x48, 0x16, 0xf8, 0x45, 
-	0x11, 0x33, 0x60, 0xe1, 0x00, 0x02, 0x00, 0x05, 
-	0xf8, 0x20, 0x10, 0xdf, 0x10, 0xe1, 0x00, 0x0b, 
-	0x08, 0xe1, 0x00, 0x0c, 0x11, 0xe1, 0x00, 0x04, 
-	0xf8, 0x4d, 0x10, 0xc7, 0x6b, 0xf8, 0x27, 0x6f, 
-	0x00, 0x01, 0x88, 0x10, 0xf4, 0x95, 0xf4, 0x95, 
-	0xf5, 0xae, 0xf8, 0x20, 0x10, 0xcf, 0x48, 0x16, 
-	0xf4, 0x95, 0x48, 0x08, 0xf8, 0x45, 0x11, 0x16, 
-	0x6f, 0xe1, 0x00, 0x0c, 0x0d, 0x00, 0x81, 0xe1, 
-	0x00, 0x0c, 0x11, 0x04, 0xf5, 0x00, 0x81, 0x04, 
-	0x49, 0x16, 0xf5, 0x20, 0x89, 0x16, 0xf0, 0x73, 
-	0x11, 0x0e, 0x10, 0xe1, 0x00, 0x0b, 0x71, 0xe1, 
-	0x00, 0x0c, 0x00, 0x12, 0x88, 0x10, 0xf4, 0x95, 
-	0xf4, 0x95, 0xf6, 0xaa, 0xf8, 0x30, 0x11, 0x16, 
-	0x49, 0x12, 0xf6, 0x20, 0x88, 0x10, 0xf4, 0x95, 
-	0xf4, 0x95, 0xf5, 0xae, 0xf8, 0x20, 0x10, 0xf3, 
-	0x48, 0x16, 0x80, 0x06, 0x48, 0x08, 0xf8, 0x45, 
-	0x11, 0x16, 0x10, 0x04, 0x70, 0x02, 0x00, 0x17, 
-	0x80, 0x00, 0x76, 0x03, 0x00, 0x00, 0x10, 0x06, 
-	0x80, 0x01, 0x10, 0x05, 0xf0, 0x74, 0x0c, 0xb9, 
-	0x10, 0x06, 0x00, 0xe1, 0x00, 0x0c, 0x80, 0xe1, 
-	0x00, 0x0c, 0x11, 0x06, 0x10, 0x04, 0xf6, 0x00, 
-	0x80, 0x04, 0x48, 0x16, 0xf6, 0x20, 0x88, 0x16, 
-	0x10, 0xe1, 0x00, 0x0c, 0x08, 0xe1, 0x00, 0x0b, 
-	0xf8, 0x45, 0x11, 0x1c, 0xf0, 0x73, 0x11, 0x31, 
-	0xf2, 0x74, 0x0e, 0x9f, 0xf4, 0x95, 0x48, 0x17, 
-	0xf0, 0x73, 0x11, 0x33, 0x76, 0xe1, 0x00, 0x0c, 
-	0x00, 0x00, 0x76, 0xe1, 0x00, 0x0b, 0x00, 0x00, 
-	0x76, 0xe1, 0x00, 0x02, 0x00, 0x01, 0x10, 0x04, 
-	0x80, 0x00, 0x10, 0x05, 0xf0, 0x74, 0x06, 0x9f, 
-	0x88, 0x12, 0xf4, 0x95, 0x77, 0x10, 0x00, 0xff, 
-	0xf4, 0xaa, 0xf8, 0x30, 0x11, 0x33, 0x6c, 0x86, 
-	0x0f, 0x70, 0xee, 0x08, 0x8a, 0x17, 0x8a, 0x16, 
-	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0xee, 0xfc, 
-	0xf4, 0x95, 0x71, 0x06, 0x00, 0x12, 0x88, 0x11, 
-	0x73, 0x12, 0x00, 0x0e, 0xf1, 0x66, 0x00, 0x0d, 
-	0xf3, 0x00, 0x24, 0x00, 0x89, 0x14, 0x13, 0x81, 
-	0xf7, 0x7a, 0xf3, 0x30, 0x00, 0x01, 0x81, 0xf8, 
-	0x27, 0x60, 0x13, 0xe1, 0x00, 0x01, 0xf7, 0x7c, 
-	0xf3, 0x30, 0x00, 0x03, 0x81, 0xf8, 0x27, 0x61, 
-	0xe9, 0x0f, 0x19, 0xe1, 0x00, 0x01, 0x81, 0xf8, 
-	0x27, 0x62, 0x71, 0xe4, 0x00, 0x03, 0x00, 0x13, 
-	0xf6, 0xb8, 0x49, 0x13, 0xf3, 0x00, 0x00, 0x01, 
-	0xf3, 0x30, 0x00, 0x0f, 0x49, 0x0b, 0x09, 0xf8, 
-	0x27, 0x62, 0xf8, 0x4d, 0x11, 0x75, 0x77, 0x10, 
-	0x00, 0xff, 0xf4, 0xab, 0xf8, 0x30, 0x11, 0x75, 
-	0x57, 0xf8, 0x27, 0x6c, 0xf3, 0x00, 0x00, 0x01, 
-	0x4f, 0xf8, 0x27, 0x6c, 0x76, 0xf8, 0x27, 0x63, 
-	0x00, 0x01, 0xf0, 0x73, 0x11, 0x78, 0x76, 0xf8, 
-	0x27, 0x63, 0x00, 0x00, 0x70, 0xe4, 0x00, 0x03, 
-	0x27, 0x62, 0x76, 0xf8, 0x27, 0x64, 0x00, 0x00, 
-	0x11, 0xf8, 0x27, 0x61, 0x61, 0xf8, 0x00, 0x0b, 
-	0x00, 0x02, 0xf8, 0x20, 0x11, 0x8d, 0xe9, 0x01, 
-	0x6f, 0xe1, 0x00, 0x02, 0x0f, 0x18, 0x81, 0xf8, 
-	0x27, 0x64, 0x11, 0xf8, 0x27, 0x61, 0x61, 0xf8, 
-	0x00, 0x0b, 0x00, 0x01, 0xf8, 0x20, 0x11, 0xa9, 
-	0x10, 0xf8, 0x27, 0x64, 0xf1, 0x00, 0x00, 0x04, 
-	0x89, 0x13, 0xe9, 0xb8, 0xf5, 0x20, 0x81, 0xf8, 
-	0x27, 0x65, 0x60, 0x84, 0x00, 0x02, 0xf8, 0x20, 
-	0x11, 0xa9, 0x70, 0x00, 0x00, 0x11, 0x70, 0x01, 
-	0x00, 0x13, 0x70, 0x02, 0x27, 0x65, 0xf2, 0x74, 
-	0x0f, 0x18, 0xf4, 0x95, 0x48, 0x12, 0xee, 0x04, 
-	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0x4a, 0x16, 
-	0x4a, 0x17, 0xee, 0xfc, 0xe8, 0x00, 0x4e, 0xf8, 
-	0x27, 0x66, 0xe8, 0x00, 0x4e, 0xf8, 0x27, 0x68, 
-	0xe8, 0x00, 0x4e, 0xf8, 0x27, 0x6c, 0xe8, 0x00, 
-	0x4e, 0xf8, 0x27, 0x6a, 0x77, 0x12, 0x27, 0x40, 
-	0x77, 0x11, 0x24, 0x00, 0x77, 0x1a, 0x00, 0x1f, 
-	0xf0, 0x72, 0x11, 0xdb, 0x70, 0x92, 0x00, 0x11, 
-	0x76, 0xe1, 0x00, 0x01, 0xff, 0xff, 0x76, 0x81, 
-	0x00, 0x00, 0x76, 0xe1, 0x00, 0x02, 0x00, 0x00, 
-	0x76, 0xe1, 0x00, 0x03, 0x00, 0xff, 0x76, 0xe1, 
-	0x00, 0x0c, 0x00, 0x00, 0x76, 0xe1, 0x00, 0x0b, 
-	0x00, 0x00, 0x76, 0xe1, 0x00, 0x04, 0x00, 0x00, 
-	0x6d, 0xe9, 0x00, 0x0d, 0xf0, 0x20, 0x25, 0xa0, 
-	0xf1, 0x00, 0x00, 0x07, 0x89, 0x11, 0xf1, 0x00, 
-	0x00, 0x01, 0x81, 0x02, 0x88, 0x16, 0xf4, 0x95, 
-	0x77, 0x17, 0x00, 0x20, 0x76, 0x86, 0x00, 0xff, 
-	0x76, 0x00, 0x00, 0x00, 0x76, 0x01, 0x00, 0x06, 
-	0x10, 0x02, 0xf0, 0x74, 0x06, 0x6c, 0x76, 0x00, 
-	0x00, 0x00, 0x76, 0x01, 0x00, 0x06, 0xf2, 0x74, 
-	0x06, 0x6c, 0xf4, 0x95, 0x48, 0x11, 0x10, 0x02, 
-	0xf0, 0x00, 0x00, 0x0d, 0x80, 0x02, 0x6d, 0xe9, 
-	0x00, 0x0d, 0x6d, 0xee, 0x00, 0x0d, 0x6c, 0xef, 
-	0xff, 0xff, 0x11, 0xe8, 0xf0, 0x74, 0x0c, 0x9d, 
-	0xee, 0x04, 0x8a, 0x17, 0x8a, 0x16, 0x8a, 0x11, 
-	0xfc, 0x00, 0x4a, 0x11, 0x4a, 0x16, 0x4a, 0x17, 
-	0xee, 0xfa, 0x88, 0x11, 0x10, 0x0a, 0x49, 0x11, 
-	0xf8, 0x4d, 0x12, 0x9f, 0x48, 0x08, 0xf8, 0x45, 
-	0x12, 0x9f, 0x80, 0x04, 0x12, 0x81, 0xf5, 0x78, 
-	0x89, 0x12, 0xf4, 0x95, 0xf4, 0x95, 0x6c, 0xe2, 
-	0xff, 0xb9, 0x12, 0x8a, 0x61, 0xf8, 0x00, 0x08, 
-	0x00, 0x80, 0xf8, 0x30, 0x12, 0x8a, 0x13, 0xe1, 
-	0x00, 0x01, 0xf0, 0xe8, 0xf7, 0x78, 0xf1, 0xa0, 
-	0xf2, 0x30, 0x1f, 0xff, 0x88, 0x17, 0xf4, 0x95, 
-	0x77, 0x12, 0x24, 0x00, 0x77, 0x16, 0x00, 0x00, 
-	0x77, 0x13, 0x00, 0x20, 0xf6, 0xb8, 0x48, 0x17, 
-	0x08, 0xe2, 0x00, 0x01, 0xf8, 0x45, 0x12, 0x42, 
-	0x6d, 0xea, 0x00, 0x0d, 0x6d, 0x96, 0x6c, 0xeb, 
-	0xff, 0xff, 0x12, 0x34, 0xf0, 0x73, 0x12, 0x90, 
-	0x56, 0xf8, 0x27, 0x6a, 0xf0, 0x00, 0x00, 0x01, 
-	0x4e, 0xf8, 0x27, 0x6a, 0x60, 0x82, 0x00, 0x01, 
-	0xf8, 0x30, 0x12, 0x54, 0x70, 0x00, 0x00, 0x16, 
-	0xf2, 0x74, 0x11, 0x38, 0xf4, 0x95, 0x48, 0x11, 
-	0xf0, 0x73, 0x12, 0x90, 0x70, 0x00, 0x00, 0x16, 
-	0xf2, 0x74, 0x11, 0x38, 0xf4, 0x95, 0x48, 0x11, 
-	0x72, 0x10, 0x2a, 0x9e, 0xf4, 0x95, 0xf4, 0xaf, 
-	0xf8, 0x30, 0x12, 0x6e, 0x76, 0x00, 0x00, 0x00, 
-	0x76, 0x01, 0x00, 0xbc, 0x70, 0x02, 0x00, 0x16, 
-	0x76, 0x03, 0x00, 0x00, 0xf2, 0x74, 0x0c, 0xb9, 
-	0xf4, 0x95, 0x48, 0x11, 0xf0, 0x73, 0x12, 0x90, 
-	0x10, 0xf8, 0x27, 0x6e, 0xf8, 0x44, 0x12, 0x90, 
-	0x76, 0x00, 0x00, 0x00, 0x76, 0x01, 0x00, 0xbc, 
-	0x70, 0x02, 0x00, 0x16, 0x76, 0x03, 0x00, 0x00, 
-	0xf2, 0x74, 0x0c, 0xb9, 0xf4, 0x95, 0x48, 0x11, 
-	0xf0, 0x74, 0x0c, 0x5e, 0xf0, 0xe0, 0xf0, 0x10, 
-	0x13, 0x88, 0xf8, 0x42, 0x12, 0x90, 0x76, 0xf8, 
-	0x27, 0x6e, 0x00, 0x01, 0xf0, 0x73, 0x12, 0x90, 
-	0x56, 0xf8, 0x27, 0x66, 0xf0, 0x00, 0x00, 0x01, 
-	0x4e, 0xf8, 0x27, 0x66, 0x6d, 0xe9, 0x00, 0x5e, 
-	0x56, 0xf8, 0x27, 0x68, 0xf0, 0x00, 0x00, 0x01, 
-	0x4e, 0xf8, 0x27, 0x68, 0x71, 0x04, 0x00, 0x12, 
-	0x6e, 0xea, 0xff, 0xff, 0x12, 0x18, 0x70, 0x04, 
-	0x00, 0x12, 0xee, 0x06, 0x8a, 0x17, 0x8a, 0x16, 
-	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0xee, 0xfe, 
-	0x88, 0x0e, 0xf4, 0x95, 0xf0, 0x66, 0x00, 0x0d, 
-	0xf0, 0x00, 0x25, 0xa0, 0x88, 0x11, 0xf4, 0x95, 
-	0xf4, 0x95, 0x76, 0x81, 0x00, 0xff, 0x76, 0x00, 
-	0x00, 0x00, 0x76, 0x01, 0x00, 0x06, 0xf2, 0x74, 
-	0x06, 0x6c, 0xf0, 0x00, 0x00, 0x01, 0x76, 0x00, 
-	0x00, 0x00, 0x76, 0x01, 0x00, 0x06, 0x48, 0x11, 
-	0xf2, 0x74, 0x06, 0x6c, 0xf0, 0x00, 0x00, 0x07, 
-	0xee, 0x02, 0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 
-	0x88, 0x0e, 0xf4, 0x95, 0xf0, 0x66, 0x00, 0x0d, 
-	0xf0, 0x00, 0x24, 0x00, 0x88, 0x11, 0xf4, 0x95, 
-	0xf4, 0x95, 0x76, 0xe1, 0x00, 0x01, 0xff, 0xff, 
-	0x76, 0x81, 0x00, 0x00, 0x76, 0xe1, 0x00, 0x02, 
-	0x00, 0x00, 0x76, 0xe1, 0x00, 0x03, 0x00, 0xff, 
-	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0xf4, 0x95, 
-	0x13, 0x03, 0x88, 0x11, 0xfa, 0x4d, 0x12, 0xec, 
-	0x71, 0x02, 0x00, 0x12, 0xf3, 0x10, 0x00, 0x01, 
-	0x89, 0x1a, 0xf4, 0x95, 0xf0, 0x72, 0x12, 0xeb, 
-	0x70, 0x91, 0x00, 0x12, 0x8a, 0x11, 0xfc, 0x00, 
-	0xf4, 0x95, 0x4a, 0x0b, 0x4a, 0x0c, 0x4a, 0x0d, 
-	0xf7, 0xb8, 0xee, 0xfe, 0x10, 0xf8, 0x00, 0x08, 
-	0x11, 0x06, 0xf1, 0xc0, 0x83, 0x00, 0xf4, 0x85, 
-	0x11, 0x06, 0xf7, 0x85, 0x81, 0x06, 0xf6, 0xb8, 
-	0xec, 0x0f, 0x1e, 0x06, 0x61, 0x00, 0x80, 0x00, 
-	0xf8, 0x20, 0x13, 0x05, 0xf4, 0x84, 0xee, 0x02, 
-	0x8a, 0x0d, 0x8a, 0x0c, 0x8a, 0x0b, 0xfc, 0x00, 
-	0xf4, 0x95, 0x4a, 0x0b, 0x4a, 0x0c, 0x4a, 0x0d, 
-	0xee, 0xfe, 0xf7, 0xb8, 0x80, 0x00, 0x10, 0xf8, 
-	0x00, 0x08, 0xf4, 0x85, 0x11, 0x06, 0xf7, 0x85, 
-	0x81, 0x06, 0xf6, 0xb8, 0xec, 0x0f, 0x1e, 0x06, 
-	0xf0, 0xf0, 0x61, 0x00, 0x80, 0x00, 0xf8, 0x20, 
-	0x13, 0x20, 0xf4, 0x84, 0xee, 0x02, 0x8a, 0x0d, 
-	0x8a, 0x0c, 0x8a, 0x0b, 0xfc, 0x00, 0x4a, 0x11, 
-	0x77, 0x11, 0x00, 0x7b, 0x76, 0x81, 0x2e, 0xec, 
-	0x77, 0x11, 0x00, 0x7b, 0xee, 0xff, 0x71, 0x81, 
-	0x00, 0x11, 0xee, 0x01, 0x76, 0xe1, 0x00, 0x01, 
-	0x00, 0x00, 0x76, 0xe1, 0x00, 0x04, 0x00, 0x00, 
-	0x76, 0xe1, 0x00, 0x06, 0x00, 0x00, 0x76, 0xe1, 
-	0x00, 0x62, 0x00, 0x00, 0x76, 0xe1, 0x00, 0x76, 
-	0x00, 0x00, 0x76, 0xe1, 0x00, 0x92, 0x00, 0x00, 
-	0x76, 0xe1, 0x00, 0x94, 0x00, 0x00, 0x76, 0xe1, 
-	0x00, 0xb0, 0x00, 0x00, 0x76, 0xe1, 0x00, 0xb3, 
-	0x00, 0x00, 0x76, 0xe1, 0x00, 0xbe, 0x00, 0x00, 
-	0x76, 0xe1, 0x00, 0xbf, 0x00, 0x00, 0x76, 0xe1, 
-	0x00, 0xc1, 0x00, 0x00, 0x76, 0xe1, 0x00, 0xc3, 
-	0x00, 0x00, 0x76, 0xe1, 0x00, 0xc5, 0x00, 0x00, 
-	0x76, 0xe1, 0x00, 0xc7, 0x00, 0x00, 0x76, 0x81, 
-	0x00, 0x00, 0x8a, 0x11, 0xf4, 0x95, 0xf4, 0xe4, 
-	0x4a, 0x11, 0x4a, 0x16, 0x4a, 0x17, 0xee, 0xff, 
-	0xf4, 0x95, 0x71, 0x06, 0x00, 0x16, 0xfb, 0x80, 
-	0x16, 0xa2, 0x88, 0x17, 0xf4, 0x95, 0xf7, 0xb8, 
-	0x10, 0xf8, 0x00, 0x17, 0xf0, 0x10, 0x00, 0x02, 
-	0xfa, 0x46, 0x13, 0x88, 0x77, 0x11, 0x00, 0x00, 
-	0x10, 0xf8, 0x00, 0x17, 0xf0, 0x10, 0x00, 0x02, 
-	0xf8, 0x45, 0x13, 0xf9, 0x10, 0xf8, 0x00, 0x17, 
-	0xf8, 0x45, 0x14, 0x39, 0x10, 0xf8, 0x00, 0x17, 
-	0xf0, 0x10, 0x00, 0x01, 0xf8, 0x45, 0x14, 0x1f, 
-	0xf0, 0x73, 0x14, 0x52, 0x10, 0xf8, 0x00, 0x17, 
-	0xf0, 0x10, 0x00, 0x03, 0xf8, 0x45, 0x13, 0xd3, 
-	0x10, 0xf8, 0x00, 0x17, 0xf0, 0x10, 0x00, 0x06, 
-	0xf8, 0x44, 0x14, 0x52, 0x77, 0x12, 0x00, 0x7b, 
-	0x71, 0x82, 0x00, 0x14, 0x61, 0xe4, 0x00, 0x07, 
-	0x00, 0x40, 0xf8, 0x30, 0x14, 0x52, 0x49, 0x14, 
-	0x48, 0x17, 0xf6, 0x00, 0x88, 0x12, 0xf4, 0x95, 
-	0x77, 0x13, 0x00, 0x55, 0x77, 0x11, 0x00, 0x57, 
-	0x6d, 0xea, 0x00, 0x3b, 0xe5, 0x01, 0x10, 0xe6, 
-	0x00, 0x06, 0x80, 0x81, 0x48, 0x14, 0x00, 0xf8, 
-	0x00, 0x17, 0x88, 0x12, 0xf4, 0x95, 0x77, 0x11, 
-	0x00, 0x55, 0x10, 0xe2, 0x00, 0x40, 0x80, 0x81, 
-	0x77, 0x11, 0x00, 0x57, 0x10, 0xe6, 0x00, 0x07, 
-	0x80, 0x81, 0x77, 0x11, 0x00, 0x55, 0x10, 0xe2, 
-	0x00, 0x45, 0x80, 0x81, 0x10, 0xe6, 0x00, 0x08, 
-	0x77, 0x11, 0x00, 0x57, 0x80, 0x81, 0x77, 0x11, 
-	0x00, 0x55, 0x10, 0xe2, 0x00, 0x4a, 0x80, 0x81, 
-	0x77, 0x11, 0x00, 0x57, 0x10, 0xe6, 0x00, 0x09, 
-	0x80, 0x81, 0xf2, 0x73, 0x14, 0x52, 0x77, 0x11, 
-	0x03, 0xc0, 0x77, 0x12, 0x00, 0x7b, 0x10, 0x82, 
-	0xf0, 0x00, 0x00, 0x07, 0x88, 0x13, 0xf4, 0x95, 
-	0xf4, 0x95, 0x96, 0x1b, 0xf8, 0x30, 0x14, 0x52, 
-	0x10, 0xe3, 0x00, 0x35, 0x77, 0x12, 0x00, 0x55, 
-	0x80, 0x82, 0x77, 0x12, 0x00, 0x57, 0x10, 0xe6, 
-	0x00, 0x04, 0x80, 0x82, 0x77, 0x12, 0x00, 0x55, 
-	0x10, 0xe3, 0x00, 0x37, 0x80, 0x82, 0x77, 0x12, 
-	0x00, 0x57, 0x10, 0xe6, 0x00, 0x05, 0x80, 0x82, 
-	0x48, 0x11, 0xf0, 0x40, 0x00, 0x10, 0xf2, 0x73, 
-	0x14, 0x50, 0xf0, 0x40, 0x00, 0x20, 0x77, 0x12, 
-	0x00, 0x7b, 0x10, 0x82, 0xf0, 0x00, 0x00, 0x07, 
-	0x88, 0x12, 0xf4, 0x95, 0xf4, 0x95, 0x96, 0x0d, 
-	0xf8, 0x30, 0x14, 0x52, 0x10, 0xe2, 0x00, 0x34, 
-	0x77, 0x13, 0x00, 0x55, 0x80, 0x83, 0x77, 0x13, 
-	0x00, 0x57, 0x10, 0xe6, 0x00, 0x02, 0x80, 0x83, 
-	0x10, 0xe2, 0x00, 0x36, 0x77, 0x12, 0x00, 0x55, 
-	0x80, 0x82, 0x77, 0x12, 0x00, 0x57, 0x10, 0xe6, 
-	0x00, 0x03, 0x80, 0x82, 0x48, 0x11, 0xf0, 0x40, 
-	0x00, 0x04, 0xf2, 0x73, 0x14, 0x50, 0xf0, 0x40, 
-	0x00, 0x08, 0x77, 0x12, 0x00, 0x7b, 0x10, 0x82, 
-	0xf0, 0x00, 0x00, 0x07, 0x88, 0x12, 0xf4, 0x95, 
-	0xf4, 0x95, 0x96, 0x0e, 0xf8, 0x30, 0x14, 0x52, 
-	0x10, 0xe2, 0x00, 0x33, 0x77, 0x12, 0x00, 0x55, 
-	0x80, 0x82, 0x77, 0x12, 0x00, 0x57, 0x10, 0xe6, 
-	0x00, 0x01, 0x80, 0x82, 0x48, 0x11, 0xf2, 0x73, 
-	0x14, 0x50, 0xf0, 0x40, 0x00, 0x02, 0x77, 0x12, 
-	0x00, 0x7b, 0x10, 0x82, 0xf0, 0x00, 0x00, 0x07, 
-	0x88, 0x12, 0xf4, 0x95, 0xf4, 0x95, 0x96, 0x0f, 
-	0xf8, 0x30, 0x14, 0x52, 0x10, 0xe2, 0x00, 0x32, 
-	0x77, 0x12, 0x00, 0x55, 0x77, 0x13, 0x00, 0x57, 
-	0x80, 0x82, 0x48, 0x11, 0xe7, 0x62, 0xf0, 0x40, 
-	0x00, 0x01, 0xe5, 0x01, 0x88, 0x11, 0xf4, 0x95, 
-	0x77, 0x12, 0x00, 0x7b, 0x48, 0x11, 0x71, 0x82, 
-	0x00, 0x12, 0x1a, 0xe2, 0x00, 0x07, 0x80, 0xe2, 
-	0x00, 0x07, 0xf9, 0x80, 0x16, 0x9a, 0xee, 0x01, 
-	0x8a, 0x17, 0x48, 0x11, 0x8a, 0x16, 0x8a, 0x11, 
-	0xf4, 0xe4, 0x4a, 0x11, 0x88, 0x11, 0x77, 0x0e, 
-	0x00, 0x05, 0x77, 0x12, 0x00, 0x55, 0xe8, 0x04, 
-	0xf6, 0xb8, 0x28, 0xe1, 0x00, 0x02, 0xee, 0xff, 
-	0x80, 0x82, 0x77, 0x12, 0x00, 0x57, 0xf0, 0x20, 
-	0x80, 0x00, 0xee, 0x01, 0x1a, 0x82, 0x77, 0x12, 
-	0x00, 0x57, 0x80, 0x82, 0xe8, 0x01, 0x32, 0xe1, 
-	0x00, 0x02, 0xf5, 0x82, 0x77, 0x11, 0x00, 0x54, 
-	0xf6, 0x93, 0x18, 0x81, 0x77, 0x11, 0x00, 0x54, 
-	0xf2, 0xa0, 0x80, 0x81, 0x8a, 0x11, 0xf4, 0x95, 
-	0xf4, 0xe4, 0x4a, 0x11, 0x4a, 0x16, 0xf4, 0x95, 
-	0x71, 0x04, 0x00, 0x11, 0xfb, 0x80, 0x16, 0xa2, 
-	0x88, 0x16, 0xf4, 0x95, 0x77, 0x12, 0x00, 0x55, 
-	0x10, 0xe6, 0x00, 0x03, 0x80, 0x82, 0x77, 0x12, 
-	0x00, 0x56, 0x10, 0xe1, 0x00, 0x02, 0x77, 0x13, 
-	0x00, 0x56, 0x80, 0x82, 0x77, 0x12, 0x00, 0x56, 
-	0x10, 0xe1, 0x00, 0x03, 0x80, 0x82, 0x10, 0xe1, 
-	0x00, 0x04, 0x77, 0x12, 0x00, 0x56, 0x80, 0x82, 
-	0x77, 0x12, 0x00, 0x56, 0x10, 0xe1, 0x00, 0x01, 
-	0x80, 0x82, 0xe7, 0x12, 0xe5, 0x01, 0xf9, 0x80, 
-	0x16, 0x9a, 0x8a, 0x16, 0x8a, 0x11, 0xf4, 0xe4, 
-	0x4a, 0x11, 0x4a, 0x16, 0x4a, 0x17, 0xee, 0xf9, 
-	0x77, 0x11, 0x00, 0x7b, 0x76, 0x00, 0x00, 0x16, 
-	0x76, 0x01, 0x00, 0x17, 0x76, 0x02, 0x00, 0x1a, 
-	0x76, 0x03, 0x00, 0x1b, 0x76, 0x04, 0x00, 0x1c, 
-	0x76, 0x05, 0x00, 0x1d, 0x71, 0x81, 0x00, 0x17, 
-	0x71, 0xe7, 0x00, 0x06, 0x00, 0x11, 0x10, 0x81, 
-	0xf8, 0x44, 0x14, 0xdf, 0xf9, 0x80, 0x16, 0x53, 
-	0xf6, 0xb8, 0xfb, 0x80, 0x15, 0x85, 0xf0, 0x20, 
-	0xff, 0xff, 0xf6, 0xb8, 0xfb, 0x80, 0x16, 0x08, 
-	0xf0, 0x20, 0xff, 0xff, 0x77, 0x11, 0x00, 0x7b, 
-	0x71, 0x81, 0x00, 0x17, 0x76, 0xe7, 0x00, 0x06, 
-	0x00, 0x01, 0x48, 0x17, 0x77, 0x16, 0x00, 0x00, 
-	0x77, 0x10, 0x00, 0x04, 0x77, 0x15, 0x00, 0x03, 
-	0x77, 0x14, 0x00, 0x02, 0x77, 0x13, 0x00, 0x01, 
-	0xf0, 0x00, 0x00, 0x39, 0x76, 0xe7, 0x00, 0x08, 
-	0x00, 0x1f, 0x76, 0xe7, 0x00, 0x07, 0x00, 0x00, 
-	0x88, 0x0e, 0x77, 0x1a, 0x00, 0x05, 0x48, 0x17, 
-	0xf0, 0x00, 0x00, 0x09, 0x88, 0x12, 0x48, 0x18, 
-	0x88, 0x19, 0xe8, 0x00, 0xf0, 0x72, 0x15, 0x2c, 
-	0x73, 0x19, 0x00, 0x11, 0x76, 0x82, 0x00, 0x00, 
-	0x11, 0x91, 0x73, 0x11, 0x00, 0x19, 0x70, 0xe2, 
-	0x00, 0x03, 0x00, 0x16, 0x70, 0xe2, 0x00, 0x04, 
-	0x00, 0x13, 0x70, 0xe2, 0x00, 0x05, 0x00, 0x14, 
-	0x81, 0xe2, 0x00, 0x01, 0x70, 0xe2, 0x00, 0x06, 
-	0x00, 0x15, 0x70, 0xe2, 0x00, 0x07, 0x00, 0x10, 
-	0x80, 0xe2, 0x00, 0x02, 0x73, 0x0e, 0x00, 0x11, 
-	0xf1, 0x00, 0x00, 0x1e, 0x6d, 0xee, 0x00, 0x05, 
-	0x6d, 0xeb, 0x00, 0x05, 0x6d, 0xec, 0x00, 0x05, 
-	0x6d, 0xed, 0x00, 0x05, 0x6d, 0xe8, 0x00, 0x05, 
-	0xf0, 0x00, 0x00, 0x01, 0x81, 0x91, 0x6d, 0xea, 
-	0x00, 0x08, 0x73, 0x11, 0x00, 0x0e, 0xee, 0x07, 
-	0x76, 0xe7, 0x00, 0x41, 0x00, 0x24, 0x76, 0xe7, 
-	0x00, 0x46, 0x00, 0x25, 0x76, 0xe7, 0x00, 0x4b, 
-	0x00, 0x26, 0x76, 0xe7, 0x00, 0x50, 0x00, 0x27, 
-	0x8a, 0x17, 0x8a, 0x16, 0x8a, 0x11, 0xf4, 0xe4, 
-	0x4a, 0x11, 0x4a, 0x16, 0xee, 0xfe, 0x88, 0x11, 
-	0x56, 0x06, 0x4e, 0x00, 0xf9, 0x80, 0x16, 0xa2, 
-	0xf7, 0xb8, 0x10, 0xf8, 0x00, 0x11, 0xf0, 0x10, 
-	0xff, 0xff, 0xfa, 0x45, 0x15, 0x60, 0x77, 0x16, 
-	0xff, 0xff, 0x77, 0x12, 0x00, 0x7b, 0x49, 0x11, 
-	0x10, 0x82, 0xf6, 0x03, 0xf0, 0x00, 0x00, 0x09, 
-	0x88, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x10, 0x81, 
-	0xf8, 0x44, 0x15, 0x71, 0xf2, 0x73, 0x15, 0x71, 
-	0xf4, 0x95, 0xe7, 0x16, 0x77, 0x11, 0x00, 0x7b, 
-	0x10, 0x81, 0xf0, 0x00, 0x00, 0x09, 0x88, 0x11, 
-	0xf4, 0x95, 0x77, 0x12, 0x00, 0x06, 0x10, 0x81, 
-	0xf8, 0x45, 0x15, 0x5c, 0x6e, 0xea, 0xff, 0xff, 
-	0x15, 0x69, 0x6d, 0xe9, 0x00, 0x08, 0x76, 0x86, 
-	0x00, 0x01, 0xe9, 0x01, 0x56, 0x00, 0xf1, 0x80, 
-	0x10, 0xf8, 0x00, 0x0b, 0xf8, 0x45, 0x15, 0x7e, 
-	0xfb, 0x80, 0x15, 0x85, 0xf4, 0x95, 0x48, 0x16, 
-	0xf9, 0x80, 0x16, 0x9a, 0xee, 0x02, 0x48, 0x16, 
-	0x8a, 0x16, 0x8a, 0x11, 0xf4, 0xe4, 0x4a, 0x11, 
-	0xee, 0xff, 0xfb, 0x80, 0x16, 0xa2, 0x88, 0x11, 
-	0xf4, 0x95, 0x77, 0x10, 0xff, 0xff, 0xf4, 0xa9, 
-	0xf8, 0x30, 0x15, 0xc4, 0x10, 0xe1, 0x00, 0x03, 
-	0x77, 0x12, 0x00, 0x55, 0x80, 0x82, 0x77, 0x12, 
-	0x00, 0x56, 0x76, 0x82, 0x00, 0x00, 0x77, 0x12, 
-	0x00, 0x56, 0x76, 0x82, 0x00, 0x00, 0x77, 0x12, 
-	0x00, 0x56, 0x76, 0x82, 0x00, 0x00, 0x77, 0x12, 
-	0x00, 0x56, 0x76, 0x82, 0x00, 0x00, 0x77, 0x12, 
-	0x00, 0x56, 0x76, 0x82, 0x00, 0x00, 0x10, 0xe1, 
-	0x00, 0x02, 0xf0, 0x00, 0x00, 0x08, 0x32, 0xf8, 
-	0x00, 0x08, 0x77, 0x12, 0x00, 0x54, 0xe8, 0x01, 
-	0xf4, 0x82, 0xf4, 0x93, 0x18, 0x82, 0x77, 0x12, 
-	0x00, 0x54, 0xf0, 0x40, 0x00, 0x00, 0x80, 0x82, 
-	0x10, 0xe1, 0x00, 0x01, 0xf9, 0x80, 0x16, 0x76, 
-	0x10, 0xe1, 0x00, 0x01, 0xf9, 0x80, 0x16, 0x66, 
-	0xf0, 0x73, 0x16, 0x03, 0x77, 0x11, 0x00, 0x7b, 
-	0x71, 0x81, 0x00, 0x11, 0x71, 0xe1, 0x00, 0x07, 
-	0x00, 0x12, 0x76, 0x82, 0x00, 0x00, 0x10, 0xe1, 
-	0x00, 0x09, 0xf9, 0x80, 0x15, 0x85, 0x77, 0x11, 
-	0x00, 0x7b, 0x71, 0x81, 0x00, 0x11, 0x10, 0xe1, 
-	0x00, 0x09, 0xfb, 0x80, 0x15, 0x85, 0xf0, 0x00, 
-	0x00, 0x08, 0x77, 0x11, 0x00, 0x7b, 0x71, 0x81, 
-	0x00, 0x11, 0x10, 0xe1, 0x00, 0x09, 0xfb, 0x80, 
-	0x15, 0x85, 0xf0, 0x00, 0x00, 0x10, 0x77, 0x11, 
-	0x00, 0x7b, 0x71, 0x81, 0x00, 0x11, 0x10, 0xe1, 
-	0x00, 0x09, 0xfb, 0x80, 0x15, 0x85, 0xf0, 0x00, 
-	0x00, 0x18, 0x77, 0x11, 0x00, 0x7b, 0x71, 0x81, 
-	0x00, 0x11, 0x10, 0xe1, 0x00, 0x09, 0xfb, 0x80, 
-	0x15, 0x85, 0xf0, 0x00, 0x00, 0x20, 0x77, 0x11, 
-	0x00, 0x7b, 0x71, 0x81, 0x00, 0x11, 0x10, 0xe1, 
-	0x00, 0x09, 0xfb, 0x80, 0x15, 0x85, 0xf0, 0x00, 
-	0x00, 0x28, 0xf9, 0x80, 0x16, 0x9a, 0xee, 0x01, 
-	0x8a, 0x11, 0xf4, 0xe4, 0x4a, 0x11, 0xee, 0xff, 
-	0xfb, 0x80, 0x16, 0xa2, 0x88, 0x11, 0xf4, 0x95, 
-	0x77, 0x10, 0xff, 0xff, 0xf4, 0xa9, 0xf8, 0x30, 
-	0x16, 0x41, 0x77, 0x11, 0x00, 0x55, 0x76, 0x81, 
-	0x00, 0x1e, 0x77, 0x11, 0x00, 0x56, 0x76, 0x81, 
-	0x00, 0x00, 0x77, 0x11, 0x00, 0x56, 0x76, 0x81, 
-	0x00, 0x00, 0x77, 0x11, 0x00, 0x56, 0x76, 0x81, 
-	0x00, 0x00, 0x77, 0x11, 0x00, 0x56, 0x76, 0x81, 
-	0x00, 0x00, 0x77, 0x11, 0x00, 0x56, 0x76, 0x81, 
-	0x00, 0x00, 0x77, 0x11, 0x00, 0x56, 0x76, 0x81, 
-	0x00, 0x00, 0x77, 0x11, 0x00, 0x56, 0x76, 0x81, 
-	0x00, 0x00, 0x77, 0x11, 0x00, 0x56, 0x76, 0x81, 
-	0x00, 0x00, 0x77, 0x11, 0x00, 0x56, 0x76, 0x81, 
-	0x00, 0x00, 0x77, 0x11, 0x00, 0x56, 0xf2, 0x73, 
-	0x16, 0x4e, 0x76, 0x81, 0x00, 0x00, 0x77, 0x11, 
-	0x00, 0x7b, 0x71, 0x81, 0x00, 0x11, 0x71, 0xe1, 
-	0x00, 0x07, 0x00, 0x12, 0x76, 0x82, 0x00, 0x00, 
-	0x10, 0xe1, 0x00, 0x39, 0xf9, 0x80, 0x16, 0x08, 
-	0xf9, 0x80, 0x16, 0x9a, 0xee, 0x01, 0x8a, 0x11, 
-	0xf4, 0xe4, 0x4a, 0x11, 0x77, 0x11, 0x00, 0x7b, 
-	0x10, 0x81, 0xf0, 0x00, 0x00, 0x04, 0x88, 0x11, 
-	0xf4, 0x95, 0xf4, 0x95, 0x10, 0x81, 0xfa, 0x44, 
-	0x16, 0x63, 0xf4, 0x95, 0xee, 0xff, 0x76, 0x81, 
-	0x00, 0x01, 0xee, 0x01, 0x8a, 0x11, 0xf4, 0xe4, 
-	0xf0, 0x10, 0x00, 0x10, 0x4a, 0x11, 0x32, 0xf8, 
-	0x00, 0x08, 0xee, 0xff, 0x77, 0x11, 0x00, 0x01, 
-	0xe8, 0x01, 0xee, 0x01, 0xf4, 0x82, 0x1a, 0x81, 
-	0x80, 0x81, 0x8a, 0x11, 0xf4, 0x95, 0xf4, 0xe4, 
-	0xf0, 0x10, 0x00, 0x10, 0x4a, 0x11, 0x32, 0xf8, 
-	0x00, 0x08, 0xee, 0xff, 0xe8, 0x01, 0x77, 0x11, 
-	0x00, 0x00, 0xf4, 0x82, 0xee, 0x01, 0xf4, 0x93, 
-	0x18, 0x81, 0x80, 0x81, 0x8a, 0x11, 0xf4, 0x95, 
-	0xf4, 0xe4, 0x4a, 0x11, 0xf0, 0x10, 0x00, 0x10, 
-	0x77, 0x11, 0x00, 0x00, 0x32, 0xf8, 0x00, 0x08, 
-	0xee, 0xff, 0x11, 0x81, 0xe8, 0x01, 0xee, 0x01, 
-	0x77, 0x11, 0x00, 0x00, 0xf4, 0x82, 0xf2, 0xa0, 
-	0x80, 0x81, 0x8a, 0x11, 0xf4, 0x95, 0xf4, 0xe4, 
-	0xf2, 0x73, 0x16, 0x9e, 0xf6, 0xbb, 0xf4, 0x95, 
-	0xf4, 0x95, 0xf4, 0x95, 0xf4, 0x95, 0xf4, 0xe4, 
-	0xf2, 0x73, 0x16, 0xa6, 0xf7, 0xbb, 0xf4, 0x95, 
-	0xf4, 0x95, 0xf4, 0x95, 0xf4, 0x95, 0xf4, 0xe4, 
-	0x4a, 0x11, 0x4a, 0x16, 0xf4, 0x95, 0x71, 0x04, 
-	0x00, 0x16, 0xfb, 0x80, 0x16, 0xa2, 0x88, 0x11, 
-	0xf4, 0x95, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 
-	0x76, 0x82, 0x00, 0x0e, 0x10, 0xe6, 0x00, 0x0e, 
-	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x80, 0x82, 
-	0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 
-	0x00, 0x0d, 0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 
-	0x10, 0xe6, 0x00, 0x0d, 0x80, 0x82, 0x71, 0xe1, 
-	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x0c, 
-	0x10, 0xe6, 0x00, 0x0c, 0x71, 0xe1, 0x00, 0x06, 
-	0x00, 0x12, 0x80, 0x82, 0x71, 0xe1, 0x00, 0x05, 
-	0x00, 0x12, 0x76, 0x82, 0x00, 0x0b, 0x10, 0xe6, 
-	0x00, 0x0b, 0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 
-	0x80, 0x82, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 
-	0x76, 0x82, 0x00, 0x0a, 0x71, 0xe1, 0x00, 0x06, 
-	0x00, 0x12, 0x10, 0xe6, 0x00, 0x0a, 0x80, 0x82, 
-	0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 
-	0x00, 0x09, 0x10, 0xe6, 0x00, 0x09, 0x71, 0xe1, 
-	0x00, 0x06, 0x00, 0x12, 0x80, 0x82, 0x71, 0xe1, 
-	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x08, 
-	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x10, 0xe6, 
-	0x00, 0x08, 0x80, 0x82, 0x71, 0xe1, 0x00, 0x05, 
-	0x00, 0x12, 0x76, 0x82, 0x00, 0x07, 0x10, 0xe6, 
-	0x00, 0x07, 0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 
-	0x80, 0x82, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 
-	0x76, 0x82, 0x00, 0x06, 0x71, 0xe1, 0x00, 0x06, 
-	0x00, 0x12, 0x10, 0xe6, 0x00, 0x06, 0x80, 0x82, 
-	0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 
-	0x00, 0x05, 0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 
-	0x10, 0xe6, 0x00, 0x05, 0x80, 0x82, 0x71, 0xe1, 
-	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x04, 
-	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x10, 0xe6, 
-	0x00, 0x04, 0x80, 0x82, 0x71, 0xe1, 0x00, 0x05, 
-	0x00, 0x12, 0x76, 0x82, 0x00, 0x03, 0x71, 0xe1, 
-	0x00, 0x06, 0x00, 0x12, 0x10, 0xe6, 0x00, 0x03, 
-	0x80, 0x82, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 
-	0x76, 0x82, 0x00, 0x02, 0x10, 0xe6, 0x00, 0x02, 
-	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x80, 0x82, 
-	0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 
-	0x00, 0x01, 0x10, 0xe6, 0x00, 0x01, 0x71, 0xe1, 
-	0x00, 0x06, 0x00, 0x12, 0x80, 0x82, 0x71, 0xe1, 
-	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x00, 
-	0x71, 0xe1, 0x00, 0x06, 0x00, 0x13, 0xe7, 0x62, 
-	0xe5, 0x01, 0xf9, 0x80, 0x16, 0x9a, 0x8a, 0x16, 
-	0x8a, 0x11, 0xf4, 0xe4, 0x4a, 0x11, 0x88, 0x11, 
-	0xf4, 0x95, 0xf4, 0x95, 0x71, 0xe1, 0x00, 0x05, 
-	0x00, 0x12, 0xee, 0xff, 0x76, 0x82, 0x00, 0x00, 
-	0xee, 0x01, 0x71, 0xe1, 0x00, 0x06, 0x00, 0x11, 
-	0x69, 0x81, 0x00, 0x01, 0x8a, 0x11, 0xf4, 0x95, 
-	0xf4, 0xe4, 0x4a, 0x11, 0x88, 0x11, 0xf4, 0x95, 
-	0xf4, 0x95, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 
-	0xee, 0xff, 0x76, 0x82, 0x00, 0x01, 0xee, 0x01, 
-	0x71, 0xe1, 0x00, 0x06, 0x00, 0x11, 0x69, 0x81, 
-	0x00, 0x01, 0x8a, 0x11, 0xf4, 0x95, 0xf4, 0xe4, 
-	0x4a, 0x11, 0x77, 0x11, 0x00, 0x7b, 0x10, 0x81, 
-	0xf0, 0x00, 0x00, 0x94, 0x88, 0x11, 0xf4, 0x95, 
-	0xf4, 0x95, 0x10, 0x81, 0xfa, 0x44, 0x17, 0x9c, 
-	0xf4, 0x95, 0xee, 0xff, 0xf9, 0x80, 0x16, 0x53, 
-	0x77, 0x11, 0x00, 0x7b, 0x10, 0x81, 0xf0, 0x00, 
-	0x00, 0x94, 0x88, 0x11, 0xf4, 0x95, 0xf4, 0x95, 
-	0x76, 0x81, 0x00, 0x01, 0xee, 0x01, 0x76, 0xe1, 
-	0x00, 0x01, 0x00, 0x00, 0x76, 0xe1, 0x00, 0x02, 
-	0x00, 0x21, 0x76, 0xe1, 0x00, 0x03, 0x00, 0x20, 
-	0x76, 0xe1, 0x00, 0x04, 0x00, 0x23, 0x76, 0xe1, 
-	0x00, 0x05, 0x00, 0x22, 0x76, 0xe1, 0x00, 0x06, 
-	0x00, 0x38, 0x76, 0xe1, 0x00, 0x07, 0x00, 0x39, 
-	0x76, 0xe1, 0x00, 0x08, 0x00, 0x15, 0x76, 0xe1, 
-	0x00, 0x09, 0x00, 0x14, 0x76, 0xe1, 0x00, 0x0a, 
-	0x00, 0x00, 0x76, 0xe1, 0x00, 0x0b, 0x00, 0x41, 
-	0x76, 0xe1, 0x00, 0x0c, 0x00, 0x40, 0x76, 0xe1, 
-	0x00, 0x0d, 0x00, 0x43, 0x76, 0xe1, 0x00, 0x0e, 
-	0x00, 0x42, 0x76, 0xe1, 0x00, 0x0f, 0x00, 0x48, 
-	0x76, 0xe1, 0x00, 0x10, 0x00, 0x49, 0x76, 0xe1, 
-	0x00, 0x11, 0x00, 0x1b, 0x76, 0xe1, 0x00, 0x12, 
-	0x00, 0x1a, 0x8a, 0x11, 0xf4, 0x95, 0xf4, 0xe4, 
-	0x4a, 0x11, 0xee, 0xfd, 0x88, 0x11, 0x56, 0x06, 
-	0x4e, 0x00, 0xf9, 0x80, 0x16, 0xa2, 0x77, 0x12, 
-	0x00, 0x7b, 0x77, 0x0e, 0x00, 0x09, 0x10, 0x82, 
-	0x28, 0xf8, 0x00, 0x11, 0xf0, 0x00, 0x00, 0x95, 
-	0x88, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x10, 0x81, 
-	0xf8, 0x45, 0x17, 0xf0, 0xf2, 0x73, 0x17, 0xfd, 
-	0x77, 0x11, 0xff, 0xff, 0x76, 0x81, 0x00, 0x01, 
-	0xe9, 0x01, 0x56, 0x00, 0xf1, 0x80, 0x10, 0xf8, 
-	0x00, 0x0b, 0xf8, 0x45, 0x17, 0xfd, 0xfb, 0x80, 
-	0x18, 0x10, 0xf4, 0x95, 0x48, 0x11, 0xf9, 0x80, 
-	0x16, 0x9a, 0xee, 0x03, 0x48, 0x11, 0x8a, 0x11, 
-	0xf4, 0x95, 0xf4, 0xe4, 0x4a, 0x11, 0x88, 0x11, 
-	0xf4, 0x95, 0xee, 0xff, 0x71, 0xe1, 0x00, 0x01, 
-	0x00, 0x11, 0xee, 0x01, 0x10, 0x81, 0x8a, 0x11, 
-	0xf4, 0x95, 0xf4, 0xe4, 0x4a, 0x11, 0xee, 0xff, 
-	0xfb, 0x80, 0x16, 0xa2, 0x88, 0x11, 0xf4, 0x95, 
-	0x77, 0x10, 0xff, 0xff, 0xf4, 0xa9, 0xf8, 0x30, 
-	0x18, 0xc3, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 
-	0x76, 0x82, 0x00, 0x00, 0x71, 0xe1, 0x00, 0x06, 
-	0x00, 0x12, 0x76, 0x82, 0x00, 0x00, 0x71, 0xe1, 
-	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x01, 
-	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x76, 0x82, 
-	0x00, 0x00, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 
-	0x76, 0x82, 0x00, 0x02, 0x71, 0xe1, 0x00, 0x06, 
-	0x00, 0x12, 0x76, 0x82, 0x00, 0x00, 0x71, 0xe1, 
-	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x03, 
-	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x76, 0x82, 
-	0x00, 0x00, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 
-	0x76, 0x82, 0x00, 0x04, 0x71, 0xe1, 0x00, 0x06, 
-	0x00, 0x12, 0x76, 0x82, 0x00, 0x00, 0x71, 0xe1, 
-	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x05, 
-	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x76, 0x82, 
-	0x00, 0x00, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 
-	0x76, 0x82, 0x00, 0x06, 0x71, 0xe1, 0x00, 0x06, 
-	0x00, 0x12, 0x76, 0x82, 0x00, 0x01, 0x71, 0xe1, 
-	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x07, 
-	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x76, 0x82, 
-	0x20, 0x00, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 
-	0x76, 0x82, 0x00, 0x08, 0x71, 0xe1, 0x00, 0x06, 
-	0x00, 0x12, 0x76, 0x82, 0x00, 0x00, 0x71, 0xe1, 
-	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x09, 
-	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x76, 0x82, 
-	0x00, 0x00, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 
-	0x76, 0x82, 0x00, 0x0a, 0x71, 0xe1, 0x00, 0x06, 
-	0x00, 0x12, 0x76, 0x82, 0x00, 0x00, 0x71, 0xe1, 
-	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x0b, 
-	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x76, 0x82, 
-	0x00, 0x00, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 
-	0x76, 0x82, 0x00, 0x0c, 0x71, 0xe1, 0x00, 0x06, 
-	0x00, 0x12, 0x76, 0x82, 0x00, 0x00, 0x71, 0xe1, 
-	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x0d, 
-	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x76, 0x82, 
-	0x00, 0x00, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 
-	0x76, 0x82, 0x00, 0x0e, 0x71, 0xe1, 0x00, 0x06, 
-	0x00, 0x12, 0x76, 0x82, 0x00, 0x00, 0x10, 0xe1, 
-	0x00, 0x07, 0xf9, 0x80, 0x16, 0x76, 0x10, 0xe1, 
-	0x00, 0x08, 0xf9, 0x80, 0x16, 0x76, 0x10, 0xe1, 
-	0x00, 0x07, 0xf9, 0x80, 0x16, 0x66, 0x10, 0xe1, 
-	0x00, 0x08, 0xf9, 0x80, 0x16, 0x66, 0xf0, 0x73, 
-	0x18, 0xd1, 0x77, 0x11, 0x00, 0x7b, 0x10, 0x81, 
-	0xfb, 0x80, 0x18, 0x10, 0xf0, 0x00, 0x00, 0x95, 
-	0x77, 0x11, 0x00, 0x7b, 0x10, 0x81, 0xfb, 0x80, 
-	0x18, 0x10, 0xf0, 0x00, 0x00, 0x9e, 0xf9, 0x80, 
-	0x16, 0x9a, 0xee, 0x01, 0x8a, 0x11, 0xf4, 0xe4, 
-	0x4a, 0x11, 0x88, 0x11, 0xee, 0xff, 0xf4, 0x95, 
-	0x10, 0x04, 0x71, 0xe1, 0x00, 0x03, 0x00, 0x11, 
-	0xee, 0x01, 0x80, 0x81, 0x8a, 0x11, 0xf4, 0x95, 
-	0xf4, 0xe4, 0x4a, 0x11, 0x4a, 0x16, 0xf4, 0x95, 
-	0x71, 0x04, 0x00, 0x16, 0xfb, 0x80, 0x16, 0xa2, 
-	0x88, 0x11, 0xf4, 0x95, 0x71, 0xe1, 0x00, 0x02, 
-	0x00, 0x12, 0x76, 0x82, 0x00, 0x10, 0x10, 0xe6, 
-	0x00, 0x01, 0x71, 0xe1, 0x00, 0x03, 0x00, 0x12, 
-	0x80, 0x82, 0x71, 0xe1, 0x00, 0x04, 0x00, 0x12, 
-	0x10, 0xe6, 0x00, 0x02, 0x80, 0x82, 0xe7, 0x62, 
-	0x71, 0xe1, 0x00, 0x02, 0x00, 0x13, 0xe5, 0x01, 
-	0xf9, 0x80, 0x16, 0x9a, 0x8a, 0x16, 0x8a, 0x11, 
-	0xf4, 0xe4, 0x4a, 0x11, 0x88, 0x11, 0xee, 0xff, 
-	0xee, 0x01, 0x10, 0xe1, 0x00, 0x01, 0x8a, 0x11, 
-	0xf4, 0x95, 0xf4, 0xe4, 0x4a, 0x11, 0x77, 0x11, 
-	0x00, 0x7b, 0x10, 0x81, 0xf0, 0x00, 0x00, 0xb3, 
-	0x88, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x10, 0x81, 
-	0xfa, 0x44, 0x19, 0x2a, 0xf4, 0x95, 0xee, 0xff, 
-	0xf9, 0x80, 0x16, 0x53, 0x77, 0x11, 0x00, 0x7b, 
-	0x10, 0x81, 0xf0, 0x00, 0x00, 0xb3, 0x88, 0x11, 
-	0xf4, 0x95, 0xf4, 0x95, 0x76, 0x81, 0x00, 0x01, 
-	0xee, 0x01, 0x76, 0xe1, 0x00, 0x01, 0x00, 0x00, 
-	0x76, 0xe1, 0x00, 0x02, 0x00, 0x13, 0x76, 0xe1, 
-	0x00, 0x03, 0x00, 0x26, 0x76, 0xe1, 0x00, 0x04, 
-	0x00, 0x25, 0x76, 0xe1, 0x00, 0x05, 0x00, 0x24, 
-	0x76, 0xe1, 0x00, 0x06, 0x00, 0x00, 0x76, 0xe1, 
-	0x00, 0x07, 0x00, 0x17, 0x76, 0xe1, 0x00, 0x08, 
-	0x00, 0x32, 0x76, 0xe1, 0x00, 0x09, 0x00, 0x31, 
-	0x76, 0xe1, 0x00, 0x0a, 0x00, 0x30, 0x8a, 0x11, 
-	0xf4, 0x95, 0xf4, 0xe4, 0x4a, 0x11, 0x4a, 0x16, 
-	0x4a, 0x17, 0xee, 0xff, 0xf4, 0x95, 0x71, 0x06, 
-	0x00, 0x17, 0xfb, 0x80, 0x16, 0xa2, 0x88, 0x11, 
-	0xf4, 0x95, 0xf7, 0xb8, 0x10, 0xf8, 0x00, 0x11, 
-	0xf0, 0x10, 0xff, 0xff, 0xfa, 0x45, 0x19, 0x73, 
-	0x77, 0x16, 0xff, 0xff, 0x77, 0x12, 0x00, 0x7b, 
-	0x77, 0x0e, 0x00, 0x05, 0x10, 0x82, 0x28, 0xf8, 
-	0x00, 0x11, 0xf0, 0x00, 0x00, 0xb4, 0x88, 0x11, 
-	0xf4, 0x95, 0xf4, 0x95, 0x10, 0x81, 0xf8, 0x44, 
-	0x19, 0x84, 0xf2, 0x73, 0x19, 0x84, 0xf4, 0x95, 
-	0xe7, 0x16, 0x77, 0x11, 0x00, 0x7b, 0x10, 0x81, 
-	0xf0, 0x00, 0x00, 0xb4, 0x88, 0x11, 0xf4, 0x95, 
-	0x77, 0x12, 0x00, 0x02, 0x10, 0x81, 0xf8, 0x45, 
-	0x19, 0x6f, 0x6e, 0xea, 0xff, 0xff, 0x19, 0x7c, 
-	0x6d, 0xe9, 0x00, 0x05, 0x61, 0xf8, 0x00, 0x17, 
-	0x00, 0x01, 0xfa, 0x20, 0x19, 0x8f, 0x76, 0x86, 
-	0x00, 0x01, 0xfb, 0x80, 0x19, 0x97, 0xf4, 0x95, 
-	0x48, 0x16, 0xf9, 0x80, 0x16, 0x9a, 0xee, 0x01, 
-	0x8a, 0x17, 0x48, 0x16, 0x8a, 0x16, 0x8a, 0x11, 
-	0xf4, 0xe4, 0x4a, 0x11, 0xee, 0xff, 0xfb, 0x80, 
-	0x16, 0xa2, 0x88, 0x11, 0xf4, 0x95, 0x77, 0x10, 
-	0xff, 0xff, 0xf4, 0xa9, 0xf8, 0x30, 0x19, 0xcc, 
-	0x71, 0xe1, 0x00, 0x02, 0x00, 0x12, 0x69, 0x82, 
-	0x00, 0x10, 0x71, 0xe1, 0x00, 0x02, 0x00, 0x12, 
-	0x68, 0x82, 0xf7, 0xff, 0x71, 0xe1, 0x00, 0x02, 
-	0x00, 0x12, 0x68, 0x82, 0xfb, 0xff, 0x71, 0xe1, 
-	0x00, 0x02, 0x00, 0x12, 0x68, 0x82, 0xff, 0xf0, 
-	0x71, 0xe1, 0x00, 0x03, 0x00, 0x12, 0x76, 0x82, 
-	0xff, 0xff, 0x71, 0xe1, 0x00, 0x04, 0x00, 0x12, 
-	0x76, 0x82, 0xff, 0xff, 0x71, 0xe1, 0x00, 0x02, 
-	0x00, 0x12, 0x69, 0x82, 0x00, 0x20, 0x71, 0xe1, 
-	0x00, 0x02, 0x00, 0x11, 0xf2, 0x73, 0x19, 0xda, 
-	0x68, 0x81, 0xff, 0xef, 0x77, 0x11, 0x00, 0x7b, 
-	0x10, 0x81, 0xfb, 0x80, 0x19, 0x97, 0xf0, 0x00, 
-	0x00, 0xb4, 0x77, 0x11, 0x00, 0x7b, 0x10, 0x81, 
-	0xfb, 0x80, 0x19, 0x97, 0xf0, 0x00, 0x00, 0xb9, 
-	0xf9, 0x80, 0x16, 0x9a, 0xee, 0x01, 0x8a, 0x11, 
-	0xf4, 0xe4, 0x00, 0xa4, 0x00, 0x00, 0x19, 0xdf, 
-	0x00, 0x01, 0x2a, 0xe6, 0x00, 0x00, 0x00, 0x01, 
-	0x2a, 0xe7, 0x00, 0x00, 0x00, 0x03, 0x2a, 0x12, 
-	0x0c, 0x01, 0xc3, 0x4f, 0x00, 0x00, 0x00, 0x01, 
-	0x2a, 0x15, 0x00, 0x00, 0x00, 0x02, 0x2a, 0x16, 
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x2a, 0x5d, 
-	0x00, 0x43, 0x00, 0x6f, 0x00, 0x70, 0x00, 0x79, 
-	0x00, 0x72, 0x00, 0x69, 0x00, 0x67, 0x00, 0x68, 
-	0x00, 0x74, 0x00, 0x20, 0x00, 0x54, 0x00, 0x65, 
-	0x00, 0x63, 0x00, 0x68, 0x00, 0x6e, 0x00, 0x6f, 
-	0x00, 0x54, 0x00, 0x72, 0x00, 0x65, 0x00, 0x6e, 
-	0x00, 0x64, 0x00, 0x20, 0x00, 0x41, 0x00, 0x47, 
-	0x00, 0x00, 0x00, 0x04, 0x2a, 0x76, 0x00, 0x30, 
-	0x00, 0x2e, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0c, 
-	0x2a, 0x7a, 0x00, 0x46, 0x00, 0x65, 0x00, 0x62, 
-	0x00, 0x20, 0x00, 0x32, 0x00, 0x37, 0x00, 0x20, 
-	0x00, 0x32, 0x00, 0x30, 0x00, 0x30, 0x00, 0x31, 
-	0x00, 0x00, 0x00, 0x09, 0x2a, 0x86, 0x00, 0x31, 
-	0x00, 0x34, 0x00, 0x3a, 0x00, 0x33, 0x00, 0x35, 
-	0x00, 0x3a, 0x00, 0x33, 0x00, 0x33, 0x00, 0x00, 
-	0x00, 0x0f, 0x2a, 0x8f, 0x00, 0x00, 0x00, 0x00, 
-	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0x00, 0x00, 0x00, 0x01, 0x2a, 0x9e, 0x00, 0x00, 
-	0x00, 0x01, 0x2a, 0x9f, 0x00, 0x00, 0x00, 0x01, 
-	0x2a, 0xa0, 0x00, 0x00, 0x00, 0x01, 0x2a, 0xa1, 
-	0x00, 0x00, 0x00, 0x01, 0x2a, 0xa2, 0x00, 0x00, 
-	0x00, 0x01, 0x29, 0x7e, 0x00, 0x00, 0x00, 0x02, 
-	0x29, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
-	0x29, 0x82, 0xff, 0xff, 0x00, 0x01, 0x2a, 0xa7, 
-	0x00, 0x00, 0x00, 0x05, 0x2a, 0xa8, 0x71, 0x41, 
-	0x20, 0x00, 0x20, 0x00, 0x00, 0x23, 0x04, 0x00, 
-	0x00, 0x0a, 0x2a, 0xad, 0x00, 0x00, 0x00, 0x00, 
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0x00, 0x0f, 0x2a, 0xb7, 0x00, 0x00, 0x00, 0x00, 
-	0x00, 0x00, 0x00, 0x40, 0x00, 0xa0, 0x82, 0x40, 
-	0x00, 0x08, 0x30, 0x7f, 0x00, 0x80, 0x01, 0x80, 
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0x00, 0x00, 0x00, 0x01, 0x27, 0x6e, 0x00, 0x00, 
-	0x00, 0x01, 0x27, 0x6f, 0x00, 0x00, 0x00, 0x00, 
-	0x00, 0x09, 0x00, 0x00, 0x1a, 0x83, 0x04, 0xe8, 
-	0x04, 0xcf, 0x04, 0xc5, 0x04, 0xba, 0x04, 0xb0, 
-	0x04, 0xac, 0x04, 0x9c, 0x04, 0x8c, 0x04, 0x81, 
-	0x00, 0x78, 0x00, 0x00, 0x01, 0x00, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xaa, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x02, 0x23, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x05, 0xe5, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x02, 0xb5, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x0e, 0x33, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73, 
-	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0x00, 0x00, 
+	0x08, 0xaa, 0x00, 0x18, 0x00, 0x03, 0x08, 0x00,
+	0x00, 0x10, 0x00, 0x00, 0x01, 0x80, 0x18, 0x5f,
+	0x00, 0x00, 0x01, 0x80, 0x77, 0x18, 0x2a, 0xeb,
+	0x6b, 0xf8, 0x00, 0x18, 0x03, 0xff, 0x68, 0xf8,
+	0x00, 0x18, 0xff, 0xfe, 0xf7, 0xb8, 0xf7, 0xbe,
+	0xf6, 0xb9, 0xf4, 0xa0, 0xf6, 0xb7, 0xf6, 0xb5,
+	0xf6, 0xb6, 0xf0, 0x20, 0x19, 0xdf, 0xf1, 0x00,
+	0x00, 0x01, 0xf8, 0x4d, 0x01, 0xab, 0xf6, 0xb8,
+	0xf0, 0x20, 0x19, 0xdf, 0xf0, 0x73, 0x01, 0xa5,
+	0x7e, 0xf8, 0x00, 0x12, 0xf0, 0x00, 0x00, 0x01,
+	0x47, 0xf8, 0x00, 0x11, 0x7e, 0x92, 0x00, 0xf8,
+	0x00, 0x11, 0xf0, 0x00, 0x00, 0x01, 0x7e, 0xf8,
+	0x00, 0x11, 0xf0, 0x00, 0x00, 0x01, 0x6c, 0x89,
+	0x01, 0x9a, 0xf7, 0xb8, 0xee, 0xfc, 0xf0, 0x20,
+	0xff, 0xff, 0xf1, 0x00, 0x00, 0x01, 0xf8, 0x4d,
+	0x01, 0xbf, 0xf2, 0x73, 0x01, 0xb9, 0x4e, 0x02,
+	0xf4, 0x95, 0xf5, 0xe3, 0x56, 0x02, 0x7e, 0x00,
+	0x11, 0x00, 0xfa, 0x4c, 0x01, 0xb7, 0x6b, 0x03,
+	0x00, 0x01, 0xf6, 0xb8, 0xee, 0x04, 0xf0, 0x74,
+	0x0d, 0xa7, 0xf0, 0x74, 0x01, 0xc5, 0x4a, 0x11,
+	0x4a, 0x16, 0x72, 0x11, 0x2a, 0xe6, 0x10, 0xf8,
+	0x00, 0x11, 0xfa, 0x45, 0x01, 0xdb, 0xf4, 0x95,
+	0xee, 0xff, 0x48, 0x11, 0xf0, 0x00, 0x2a, 0xc6,
+	0x88, 0x16, 0xf4, 0x95, 0xf4, 0x95, 0x10, 0xee,
+	0xff, 0xff, 0xf4, 0xe3, 0x6c, 0xe9, 0xff, 0xff,
+	0x01, 0xd5, 0x10, 0xf8, 0x2a, 0xe7, 0xf8, 0x45,
+	0x01, 0xe2, 0x10, 0xf8, 0x2a, 0xe7, 0xf4, 0xe3,
+	0xf0, 0x74, 0x01, 0xff, 0xee, 0x01, 0x8a, 0x16,
+	0x8a, 0x11, 0xfc, 0x00, 0xf7, 0xb8, 0xe9, 0x20,
+	0x4a, 0x11, 0x09, 0xf8, 0x2a, 0xe6, 0xf8, 0x4e,
+	0x01, 0xf3, 0xf2, 0x73, 0x01, 0xfd, 0xf4, 0x95,
+	0xe8, 0x01, 0x72, 0x11, 0x2a, 0xe6, 0x49, 0x11,
+	0x80, 0xe1, 0x2a, 0xc6, 0xf3, 0x00, 0x00, 0x01,
+	0xe8, 0x00, 0x81, 0xf8, 0x2a, 0xe6, 0x8a, 0x11,
+	0xfc, 0x00, 0xf4, 0x95, 0xf0, 0x73, 0x02, 0x00,
+	0x10, 0xf8, 0x2a, 0x0f, 0xfc, 0x00, 0x4a, 0x11,
+	0xf0, 0x74, 0x02, 0x02, 0x80, 0xf8, 0x2a, 0x10,
+	0x73, 0x08, 0x00, 0x09, 0x40, 0xf8, 0x2a, 0x15,
+	0x82, 0xf8, 0x00, 0x11, 0xf4, 0x95, 0x77, 0x10,
+	0x03, 0xe8, 0xf5, 0xa9, 0xf8, 0x30, 0x02, 0x21,
+	0x71, 0xf8, 0x2a, 0x10, 0x2a, 0x15, 0x56, 0xf8,
+	0x2a, 0x0c, 0xf0, 0xe3, 0x4e, 0xf8, 0x2a, 0x16,
+	0xe8, 0x00, 0x4e, 0xf8, 0x2a, 0x0c, 0x8a, 0x11,
+	0xfc, 0x00, 0x4a, 0x06, 0x4a, 0x07, 0x4a, 0x1d,
+	0x68, 0xf8, 0x00, 0x07, 0x7d, 0x3f, 0x69, 0xf8,
+	0x00, 0x07, 0x40, 0x00, 0x68, 0xf8, 0x00, 0x1d,
+	0xff, 0xfc, 0x6b, 0xf8, 0x2a, 0x0f, 0x00, 0x01,
+	0x8a, 0x1d, 0x8a, 0x07, 0x8a, 0x06, 0xf4, 0xeb,
+	0xee, 0xfd, 0x76, 0xf8, 0x2a, 0x0f, 0x00, 0x00,
+	0x76, 0x00, 0x00, 0x00, 0xfb, 0x80, 0x19, 0x4c,
+	0xf4, 0x95, 0xe8, 0x00, 0x80, 0xf8, 0x2a, 0x11,
+	0xf9, 0x80, 0x19, 0x07, 0x80, 0xf8, 0x2a, 0x0e,
+	0xf9, 0x80, 0x16, 0x66, 0x76, 0x00, 0x2a, 0x12,
+	0x10, 0xf8, 0x2a, 0x11, 0xf9, 0x80, 0x18, 0xe3,
+	0x10, 0xf8, 0x2a, 0x0e, 0xf9, 0x80, 0x16, 0x66,
+	0x10, 0xf8, 0x2a, 0x0e, 0xf9, 0x80, 0x16, 0x87,
+	0xee, 0x03, 0xfc, 0x00, 0x4a, 0x11, 0xf6, 0xb8,
+	0xf4, 0x95, 0xf0, 0x20, 0x80, 0x00, 0x11, 0xf8,
+	0x2a, 0x5a, 0xf8, 0x4d, 0x02, 0x93, 0x11, 0xf8,
+	0x2a, 0x9f, 0xf8, 0x4c, 0x02, 0x7c, 0x77, 0x12,
+	0x2a, 0x39, 0x49, 0x12, 0x01, 0xf8, 0x2a, 0x9f,
+	0x89, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x71, 0x81,
+	0x00, 0x11, 0x6c, 0xe1, 0xff, 0xab, 0x02, 0x93,
+	0x6b, 0xf8, 0x2a, 0x9f, 0x00, 0x01, 0xe9, 0x05,
+	0x01, 0xe2, 0x00, 0x03, 0x81, 0xf8, 0x2a, 0xa0,
+	0xf0, 0x73, 0x02, 0x95, 0x72, 0x11, 0x2a, 0x9f,
+	0xf4, 0x95, 0x10, 0xe1, 0x2a, 0x39, 0x6b, 0xf8,
+	0x2a, 0x9f, 0x00, 0x01, 0x11, 0xf8, 0x2a, 0x9f,
+	0x09, 0xf8, 0x2a, 0xa0, 0xf8, 0x4c, 0x02, 0x93,
+	0x76, 0xf8, 0x2a, 0x5a, 0x00, 0x00, 0x76, 0xf8,
+	0x2a, 0x9f, 0x00, 0x00, 0x76, 0xf8, 0x2a, 0xa0,
+	0x00, 0x00, 0x88, 0x11, 0xf4, 0x95, 0x48, 0x11,
+	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0xee, 0xfe,
+	0x10, 0xf8, 0x2a, 0x5a, 0xf8, 0x44, 0x02, 0xb2,
+	0x76, 0xf8, 0x2a, 0x5a, 0x00, 0x01, 0xf0, 0x74,
+	0x02, 0x58, 0x88, 0x11, 0xf4, 0x95, 0x77, 0x10,
+	0x80, 0x00, 0xf4, 0xa9, 0xf8, 0x30, 0x02, 0xb2,
+	0x48, 0x11, 0xf0, 0x30, 0x00, 0xff, 0x80, 0x00,
+	0x10, 0xf8, 0x2a, 0x5b, 0xf9, 0x80, 0x18, 0xd6,
+	0xee, 0x02, 0x8a, 0x11, 0xfc, 0x00, 0xf4, 0x95,
+	0x4a, 0x08, 0x4a, 0x09, 0x4a, 0x0a, 0x4a, 0x0b,
+	0x4a, 0x0c, 0x4a, 0x0d, 0x4a, 0x10, 0x4a, 0x11,
+	0x4a, 0x12, 0x4a, 0x13, 0x4a, 0x14, 0x4a, 0x15,
+	0x4a, 0x16, 0x4a, 0x17, 0x4a, 0x17, 0x4a, 0x19,
+	0x4a, 0x0e, 0x4a, 0x06, 0x4a, 0x07, 0x4a, 0x1a,
+	0x4a, 0x1d, 0x4a, 0x1b, 0x4a, 0x1c, 0x68, 0xf8,
+	0x00, 0x07, 0x7d, 0x3f, 0x69, 0xf8, 0x00, 0x07,
+	0x40, 0x00, 0x68, 0xf8, 0x00, 0x1d, 0xff, 0xfc,
+	0x48, 0x18, 0x68, 0xf8, 0x00, 0x18, 0xff, 0xfe,
+	0xf4, 0x95, 0xf4, 0x95, 0x4a, 0x08, 0xee, 0xfd,
+	0xf0, 0x74, 0x02, 0x58, 0x88, 0x11, 0xf4, 0x95,
+	0x77, 0x10, 0x80, 0x00, 0xf4, 0xa9, 0xf8, 0x30,
+	0x02, 0xef, 0x48, 0x11, 0xf0, 0x30, 0x00, 0xff,
+	0x80, 0x00, 0x10, 0xf8, 0x2a, 0x5b, 0xf9, 0x80,
+	0x18, 0xd6, 0xee, 0x03, 0x8a, 0x18, 0xf4, 0x95,
+	0x8a, 0x1c, 0x8a, 0x1b, 0x8a, 0x1d, 0x8a, 0x1a,
+	0x8a, 0x07, 0x8a, 0x06, 0x8a, 0x0e, 0x8a, 0x19,
+	0x8a, 0x17, 0x8a, 0x17, 0x8a, 0x16, 0x8a, 0x15,
+	0x8a, 0x14, 0x8a, 0x13, 0x8a, 0x12, 0x8a, 0x11,
+	0x8a, 0x10, 0x8a, 0x0d, 0x8a, 0x0c, 0x8a, 0x0b,
+	0x8a, 0x0a, 0x8a, 0x09, 0x8a, 0x08, 0xf4, 0xeb,
+	0x4a, 0x11, 0x77, 0x11, 0x2a, 0x39, 0x76, 0x81,
+	0x00, 0x55, 0x77, 0x12, 0x2a, 0x18, 0x10, 0xe2,
+	0x00, 0x01, 0x80, 0xe1, 0x00, 0x01, 0x10, 0xe2,
+	0x00, 0x02, 0x80, 0xe1, 0x00, 0x02, 0x76, 0xe1,
+	0x00, 0x03, 0x00, 0x00, 0x76, 0xe1, 0x00, 0x04,
+	0x00, 0xaa, 0xf0, 0x74, 0x02, 0x98, 0x8a, 0x11,
+	0xfc, 0x00, 0x4a, 0x11, 0x88, 0x11, 0xf4, 0x95,
+	0xf4, 0x95, 0x10, 0x81, 0x6f, 0xf8, 0x2a, 0x9e,
+	0x0c, 0x88, 0xe8, 0xff, 0x18, 0xe1, 0x00, 0x01,
+	0x1a, 0xf8, 0x2a, 0x9e, 0xf0, 0x30, 0x1f, 0xff,
+	0x80, 0xf8, 0x2a, 0x9e, 0x8a, 0x11, 0xfc, 0x00,
+	0x4a, 0x11, 0x77, 0x11, 0x2a, 0x39, 0x76, 0x81,
+	0x00, 0x55, 0x77, 0x12, 0x2a, 0x18, 0x11, 0xe2,
+	0x00, 0x01, 0x81, 0xe1, 0x00, 0x01, 0x11, 0xe2,
+	0x00, 0x02, 0x81, 0xe1, 0x00, 0x02, 0x76, 0xe1,
+	0x00, 0x03, 0x00, 0x02, 0x48, 0x08, 0x6f, 0xe1,
+	0x00, 0x04, 0x0c, 0x98, 0xf0, 0x30, 0x00, 0xff,
+	0x80, 0xe1, 0x00, 0x05, 0x76, 0xe1, 0x00, 0x06,
+	0x00, 0xaa, 0xf0, 0x74, 0x02, 0x98, 0x8a, 0x11,
+	0xfc, 0x00, 0x4a, 0x11, 0x77, 0x11, 0x2a, 0x39,
+	0x76, 0x81, 0x00, 0x55, 0x77, 0x12, 0x2a, 0x18,
+	0x10, 0xe2, 0x00, 0x01, 0x80, 0xe1, 0x00, 0x01,
+	0x10, 0xe2, 0x00, 0x02, 0x80, 0xe1, 0x00, 0x02,
+	0x76, 0xe1, 0x00, 0x03, 0x00, 0x04, 0x48, 0x11,
+	0xf0, 0x00, 0x00, 0x04, 0x88, 0x12, 0xf4, 0x95,
+	0x77, 0x13, 0x2a, 0x76, 0xe9, 0x00, 0xe5, 0x98,
+	0xf3, 0x00, 0x00, 0x01, 0xf6, 0xb8, 0x48, 0x0b,
+	0x08, 0xf8, 0x2a, 0x3c, 0xf8, 0x43, 0x03, 0x71,
+	0x76, 0x82, 0x00, 0xaa, 0xf0, 0x74, 0x02, 0x98,
+	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0xee, 0xf0,
+	0x88, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x71, 0x81,
+	0x00, 0x14, 0x71, 0xe1, 0x00, 0x01, 0x00, 0x15,
+	0x49, 0x11, 0xf3, 0x00, 0x00, 0x02, 0x89, 0x11,
+	0xe7, 0x82, 0x6d, 0xea, 0x00, 0x04, 0xe7, 0x83,
+	0x6d, 0xeb, 0x00, 0x0a, 0x77, 0x1a, 0x00, 0x05,
+	0xf0, 0x72, 0x03, 0xaa, 0x11, 0x81, 0xf2, 0xe8,
+	0x80, 0x82, 0xe9, 0xff, 0x19, 0xe1, 0x00, 0x01,
+	0xf1, 0xa0, 0x81, 0x92, 0x11, 0xe1, 0x00, 0x0c,
+	0xf2, 0xe8, 0x80, 0x83, 0xe9, 0xff, 0x19, 0xe1,
+	0x00, 0x0d, 0xf1, 0xa0, 0x81, 0x93, 0x6d, 0xe9,
+	0x00, 0x02, 0x48, 0x18, 0x49, 0x18, 0x70, 0x00,
+	0x00, 0x15, 0xf0, 0x00, 0x00, 0x04, 0xf3, 0x00,
+	0x00, 0x0a, 0x80, 0x01, 0x81, 0x02, 0xf2, 0x74,
+	0x0e, 0x54, 0xf4, 0x95, 0x48, 0x14, 0xee, 0x10,
+	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0xf0, 0x74,
+	0x0c, 0x5e, 0x80, 0xf8, 0x2a, 0x5c, 0x77, 0x12,
+	0x2a, 0x39, 0x76, 0x82, 0x00, 0x55, 0x77, 0x11,
+	0x2a, 0x18, 0x10, 0xe1, 0x00, 0x01, 0x80, 0xe2,
+	0x00, 0x01, 0x10, 0xe1, 0x00, 0x02, 0x80, 0xe2,
+	0x00, 0x02, 0x76, 0xe2, 0x00, 0x03, 0x00, 0x1c,
+	0xf6, 0xb8, 0x56, 0xf8, 0x2a, 0x16, 0xf0, 0xf0,
+	0xf0, 0xf8, 0x80, 0xe2, 0x00, 0x07, 0x56, 0xf8,
+	0x2a, 0x16, 0xf1, 0xf0, 0xe8, 0xff, 0xf2, 0x80,
+	0x80, 0xe2, 0x00, 0x06, 0x56, 0xf8, 0x2a, 0x16,
+	0xf1, 0xf8, 0xe8, 0xff, 0xf2, 0x80, 0x80, 0xe2,
+	0x00, 0x05, 0x57, 0xf8, 0x2a, 0x16, 0xe8, 0xff,
+	0xf2, 0x80, 0x80, 0xe2, 0x00, 0x04, 0x56, 0xf8,
+	0x27, 0x6c, 0xf0, 0xf0, 0xf0, 0xf8, 0x80, 0xe2,
+	0x00, 0x0b, 0x56, 0xf8, 0x27, 0x6c, 0xf1, 0xf0,
+	0xe8, 0xff, 0xf2, 0x80, 0x80, 0xe2, 0x00, 0x0a,
+	0x56, 0xf8, 0x27, 0x6c, 0xf1, 0xf8, 0xe8, 0xff,
+	0xf2, 0x80, 0x80, 0xe2, 0x00, 0x09, 0xe8, 0xff,
+	0x57, 0xf8, 0x27, 0x6c, 0xf2, 0x80, 0x80, 0xe2,
+	0x00, 0x08, 0x56, 0xf8, 0x27, 0x6a, 0xf0, 0xf0,
+	0xf0, 0xf8, 0x80, 0xe2, 0x00, 0x0f, 0x56, 0xf8,
+	0x27, 0x6a, 0xf1, 0xf0, 0xe8, 0xff, 0xf2, 0x80,
+	0x80, 0xe2, 0x00, 0x0e, 0x56, 0xf8, 0x27, 0x6a,
+	0xf1, 0xf8, 0xe8, 0xff, 0xf2, 0x80, 0x80, 0xe2,
+	0x00, 0x0d, 0x57, 0xf8, 0x27, 0x6a, 0xe8, 0xff,
+	0xf2, 0x80, 0x80, 0xe2, 0x00, 0x0c, 0x76, 0xe2,
+	0x00, 0x13, 0x00, 0x00, 0x76, 0xe2, 0x00, 0x12,
+	0x00, 0x00, 0x6f, 0xf8, 0x2a, 0x5c, 0x0c, 0x58,
+	0x80, 0xe2, 0x00, 0x11, 0xe8, 0xff, 0x18, 0xf8,
+	0x2a, 0x5c, 0x80, 0xe2, 0x00, 0x10, 0x76, 0xe2,
+	0x00, 0x17, 0x00, 0x00, 0x76, 0xe2, 0x00, 0x16,
+	0x00, 0x00, 0x6f, 0xf8, 0x2a, 0x9e, 0x0c, 0x58,
+	0x80, 0xe2, 0x00, 0x15, 0xe8, 0xff, 0x18, 0xf8,
+	0x2a, 0x9e, 0x80, 0xe2, 0x00, 0x14, 0x76, 0xe2,
+	0x00, 0x1b, 0x00, 0x00, 0x76, 0xe2, 0x00, 0x1a,
+	0x00, 0x00, 0x76, 0xe2, 0x00, 0x19, 0x00, 0x00,
+	0x70, 0xe2, 0x00, 0x18, 0x27, 0x6e, 0x76, 0xe2,
+	0x00, 0x1f, 0x00, 0x00, 0x76, 0xe2, 0x00, 0x1e,
+	0x00, 0x00, 0x76, 0xe2, 0x00, 0x1d, 0x00, 0x00,
+	0x76, 0xe2, 0x00, 0x1c, 0x00, 0x00, 0x76, 0xe2,
+	0x00, 0x20, 0x00, 0xaa, 0xf0, 0x74, 0x02, 0x98,
+	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0xee, 0xfe,
+	0x10, 0xf8, 0x2a, 0x38, 0xf8, 0x45, 0x04, 0xed,
+	0x77, 0x12, 0x2a, 0x18, 0x10, 0xe2, 0x00, 0x02,
+	0x88, 0x11, 0xf4, 0x95, 0x77, 0x10, 0x00, 0x08,
+	0x6d, 0xe9, 0xff, 0xdf, 0xf6, 0xa9, 0xf8, 0x20,
+	0x04, 0x75, 0xf0, 0x73, 0x04, 0x7d, 0xf0, 0x10,
+	0x00, 0x21, 0xf0, 0x00, 0x1a, 0x83, 0x48, 0x08,
+	0x7e, 0xf8, 0x00, 0x08, 0xf4, 0xe2, 0xf0, 0x74,
+	0x03, 0x0a, 0xf0, 0x73, 0x04, 0xea, 0x48, 0x12,
+	0xf2, 0x74, 0x03, 0x23, 0xf0, 0x00, 0x00, 0x04,
+	0xf2, 0x74, 0x03, 0x36, 0xf4, 0x95, 0xe8, 0x00,
+	0xf0, 0x73, 0x04, 0xea, 0x77, 0x11, 0x2a, 0x18,
+	0xe8, 0xff, 0x6f, 0xe1, 0x00, 0x04, 0x0d, 0x48,
+	0x18, 0xe1, 0x00, 0x05, 0xf2, 0x74, 0x09, 0x69,
+	0xf4, 0x95, 0xf2, 0xa0, 0xf0, 0x74, 0x03, 0x36,
+	0xf0, 0x73, 0x04, 0xea, 0x77, 0x11, 0x2a, 0x18,
+	0xe8, 0xff, 0x6f, 0xe1, 0x00, 0x04, 0x0d, 0x48,
+	0x18, 0xe1, 0x00, 0x05, 0xf2, 0x74, 0x09, 0x41,
+	0xf4, 0x95, 0xf2, 0xa0, 0xf0, 0x74, 0x03, 0x36,
+	0xf0, 0x73, 0x04, 0xea, 0xf0, 0x74, 0x03, 0x57,
+	0xf0, 0x73, 0x04, 0xea, 0x10, 0xf8, 0x2a, 0x1c,
+	0xf0, 0x74, 0x12, 0xa4, 0xf2, 0x74, 0x03, 0x36,
+	0xf4, 0x95, 0xe8, 0x00, 0xf0, 0x73, 0x04, 0xea,
+	0x48, 0x12, 0xf2, 0x74, 0x03, 0x80, 0xf0, 0x00,
+	0x00, 0x04, 0xf2, 0x74, 0x03, 0x36, 0xf4, 0x95,
+	0xe8, 0x00, 0xf0, 0x73, 0x04, 0xea, 0x10, 0xf8,
+	0x2a, 0x1c, 0xf0, 0x74, 0x12, 0xc5, 0xf2, 0x74,
+	0x03, 0x36, 0xf4, 0x95, 0xe8, 0x00, 0xf0, 0x73,
+	0x04, 0xea, 0x77, 0x11, 0x2a, 0x18, 0xe8, 0xff,
+	0x6f, 0xe1, 0x00, 0x06, 0x0d, 0x48, 0x18, 0xe1,
+	0x00, 0x07, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12,
+	0xf2, 0xa0, 0x70, 0x00, 0x00, 0x12, 0x80, 0x01,
+	0x10, 0xe1, 0x00, 0x04, 0xf0, 0x74, 0x0e, 0x7a,
+	0xf2, 0x74, 0x03, 0x36, 0xf4, 0x95, 0xe8, 0x00,
+	0xf0, 0x73, 0x04, 0xea, 0xf0, 0x74, 0x03, 0xbc,
+	0x76, 0xf8, 0x2a, 0x38, 0x00, 0x00, 0xee, 0x02,
+	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0x77, 0x11,
+	0x2a, 0x39, 0x76, 0x81, 0x00, 0x55, 0x77, 0x12,
+	0x2a, 0x18, 0x10, 0xe2, 0x00, 0x01, 0x80, 0xe1,
+	0x00, 0x01, 0x10, 0xe2, 0x00, 0x02, 0x80, 0xe1,
+	0x00, 0x02, 0x76, 0xe1, 0x00, 0x03, 0x00, 0x09,
+	0x48, 0x11, 0xf0, 0x00, 0x00, 0x04, 0x88, 0x12,
+	0xf4, 0x95, 0x77, 0x13, 0x2a, 0x86, 0xe9, 0x00,
+	0xe5, 0x98, 0xf3, 0x00, 0x00, 0x01, 0xf6, 0xb8,
+	0x48, 0x0b, 0x08, 0xf8, 0x2a, 0x3c, 0xf8, 0x43,
+	0x05, 0x0a, 0x76, 0x82, 0x00, 0xaa, 0xf0, 0x74,
+	0x02, 0x98, 0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11,
+	0x77, 0x11, 0x2a, 0x39, 0x76, 0x81, 0x00, 0x55,
+	0x77, 0x13, 0x2a, 0x18, 0x10, 0xe3, 0x00, 0x01,
+	0x80, 0xe1, 0x00, 0x01, 0x10, 0xe3, 0x00, 0x02,
+	0x80, 0xe1, 0x00, 0x02, 0x13, 0xe3, 0x00, 0x03,
+	0x81, 0xe1, 0x00, 0x03, 0x48, 0x11, 0x77, 0x11,
+	0x00, 0x00, 0xf8, 0x4d, 0x05, 0x44, 0xf0, 0x00,
+	0x00, 0x04, 0x88, 0x12, 0x48, 0x13, 0xf0, 0x00,
+	0x00, 0x04, 0x88, 0x13, 0xf4, 0x95, 0xf4, 0x95,
+	0xe5, 0x98, 0x6d, 0x91, 0xf6, 0xb8, 0x48, 0x11,
+	0x08, 0xf8, 0x2a, 0x3c, 0xf8, 0x43, 0x05, 0x3a,
+	0xf0, 0x20, 0x2a, 0x39, 0x49, 0x11, 0xf5, 0x00,
+	0x89, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x76, 0xe1,
+	0x00, 0x04, 0x00, 0xaa, 0xf0, 0x74, 0x02, 0x98,
+	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0x77, 0x11,
+	0x2a, 0x39, 0x76, 0x81, 0x00, 0x55, 0x77, 0x12,
+	0x2a, 0x18, 0x10, 0xe2, 0x00, 0x01, 0x80, 0xe1,
+	0x00, 0x01, 0x10, 0xe2, 0x00, 0x02, 0x80, 0xe1,
+	0x00, 0x02, 0x76, 0xe1, 0x00, 0x03, 0x00, 0x0c,
+	0x48, 0x11, 0xf0, 0x00, 0x00, 0x04, 0x88, 0x12,
+	0xf4, 0x95, 0x77, 0x13, 0x2a, 0x7a, 0xe9, 0x00,
+	0xe5, 0x98, 0xf3, 0x00, 0x00, 0x01, 0xf6, 0xb8,
+	0x48, 0x0b, 0x08, 0xf8, 0x2a, 0x3c, 0xf8, 0x43,
+	0x05, 0x6a, 0x76, 0x82, 0x00, 0xaa, 0xf0, 0x74,
+	0x02, 0x98, 0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11,
+	0x77, 0x11, 0x2a, 0x39, 0x76, 0x81, 0x00, 0x55,
+	0x77, 0x12, 0x2a, 0x18, 0x10, 0xe2, 0x00, 0x01,
+	0x80, 0xe1, 0x00, 0x01, 0x10, 0xe2, 0x00, 0x02,
+	0x80, 0xe1, 0x00, 0x02, 0x76, 0xe1, 0x00, 0x03,
+	0x00, 0x19, 0x48, 0x11, 0xf0, 0x00, 0x00, 0x04,
+	0x88, 0x12, 0xf4, 0x95, 0x77, 0x13, 0x2a, 0x5d,
+	0xe9, 0x00, 0xe5, 0x98, 0xf3, 0x00, 0x00, 0x01,
+	0xf6, 0xb8, 0x48, 0x0b, 0x08, 0xf8, 0x2a, 0x3c,
+	0xf8, 0x43, 0x05, 0x93, 0x76, 0x82, 0x00, 0xaa,
+	0xf0, 0x74, 0x02, 0x98, 0x8a, 0x11, 0xfc, 0x00,
+	0x4a, 0x11, 0x88, 0x11, 0x10, 0xf8, 0x2a, 0x38,
+	0xf8, 0x44, 0x05, 0xe3, 0x10, 0xf8, 0x2a, 0xa1,
+	0xf8, 0x44, 0x05, 0xba, 0x6c, 0xe1, 0xff, 0x56,
+	0x05, 0xe3, 0x72, 0x12, 0x2a, 0xa1, 0xf4, 0x95,
+	0x70, 0xe2, 0x2a, 0x18, 0x00, 0x11, 0x6b, 0xf8,
+	0x2a, 0xa1, 0x00, 0x01, 0xf0, 0x73, 0x05, 0xe3,
+	0x72, 0x12, 0x2a, 0xa1, 0xf4, 0x95, 0x70, 0xe2,
+	0x2a, 0x18, 0x00, 0x11, 0x10, 0xf8, 0x2a, 0xa1,
+	0xf0, 0x00, 0x00, 0x01, 0x88, 0x12, 0xf4, 0x95,
+	0xf4, 0x95, 0x6e, 0xe2, 0xff, 0xfc, 0x05, 0xd1,
+	0x73, 0x12, 0x2a, 0xa1, 0x48, 0x11, 0xf0, 0x00,
+	0x00, 0x05, 0x80, 0xf8, 0x2a, 0xa2, 0x10, 0xf8,
+	0x2a, 0xa1, 0x08, 0xf8, 0x2a, 0xa2, 0xf8, 0x44,
+	0x05, 0xe3, 0x6c, 0xe1, 0xff, 0xab, 0x05, 0xdd,
+	0x76, 0xf8, 0x2a, 0x38, 0x00, 0x01, 0x76, 0xf8,
+	0x2a, 0xa1, 0x00, 0x00, 0x76, 0xf8, 0x2a, 0xa2,
+	0x00, 0x00, 0x8a, 0x11, 0xfc, 0x00, 0xf4, 0x95,
+	0x4a, 0x08, 0x4a, 0x09, 0x4a, 0x0a, 0x4a, 0x0b,
+	0x4a, 0x0c, 0x4a, 0x0d, 0x4a, 0x10, 0x4a, 0x11,
+	0x4a, 0x12, 0x4a, 0x13, 0x4a, 0x14, 0x4a, 0x15,
+	0x4a, 0x16, 0x4a, 0x17, 0x4a, 0x17, 0x4a, 0x19,
+	0x4a, 0x0e, 0x4a, 0x06, 0x4a, 0x07, 0x4a, 0x1a,
+	0x4a, 0x1d, 0x4a, 0x1b, 0x4a, 0x1c, 0x68, 0xf8,
+	0x00, 0x07, 0x7d, 0x3f, 0x69, 0xf8, 0x00, 0x07,
+	0x40, 0x00, 0x68, 0xf8, 0x00, 0x1d, 0xff, 0xfc,
+	0x48, 0x18, 0x68, 0xf8, 0x00, 0x18, 0xff, 0xfe,
+	0xf4, 0x95, 0xf4, 0x95, 0x4a, 0x08, 0xee, 0xff,
+	0x10, 0xf8, 0x2a, 0x5b, 0xf9, 0x80, 0x18, 0x04,
+	0xf0, 0x74, 0x05, 0xa2, 0xee, 0x01, 0x8a, 0x18,
+	0xf4, 0x95, 0x8a, 0x1c, 0x8a, 0x1b, 0x8a, 0x1d,
+	0x8a, 0x1a, 0x8a, 0x07, 0x8a, 0x06, 0x8a, 0x0e,
+	0x8a, 0x19, 0x8a, 0x17, 0x8a, 0x17, 0x8a, 0x16,
+	0x8a, 0x15, 0x8a, 0x14, 0x8a, 0x13, 0x8a, 0x12,
+	0x8a, 0x11, 0x8a, 0x10, 0x8a, 0x0d, 0x8a, 0x0c,
+	0x8a, 0x0b, 0x8a, 0x0a, 0x8a, 0x09, 0x8a, 0x08,
+	0xf4, 0xeb, 0xee, 0xfd, 0x76, 0xf8, 0x2a, 0x38,
+	0x00, 0x00, 0x76, 0xf8, 0x2a, 0x5a, 0x00, 0x00,
+	0xe8, 0x01, 0x4e, 0x00, 0xfb, 0x80, 0x17, 0xd6,
+	0xf4, 0x95, 0xe8, 0x01, 0x80, 0xf8, 0x2a, 0x5b,
+	0x76, 0x00, 0x2a, 0x8f, 0xf9, 0x80, 0x16, 0xaa,
+	0x10, 0xf8, 0x2a, 0x5b, 0xf9, 0x80, 0x17, 0x5c,
+	0x10, 0xf8, 0x2a, 0x5b, 0xf9, 0x80, 0x17, 0x6f,
+	0xfb, 0x80, 0x16, 0x66, 0xf4, 0x95, 0xe8, 0x1a,
+	0xfb, 0x80, 0x16, 0x87, 0xf4, 0x95, 0xe8, 0x1a,
+	0xfb, 0x80, 0x16, 0x66, 0xf4, 0x95, 0xe8, 0x1b,
+	0xfb, 0x80, 0x16, 0x87, 0xf4, 0x95, 0xe8, 0x1b,
+	0xee, 0x03, 0xfc, 0x00, 0x4a, 0x11, 0xf4, 0x95,
+	0x13, 0x02, 0x88, 0x11, 0xe8, 0x00, 0xf8, 0x4d,
+	0x06, 0x6a, 0xf3, 0x10, 0x00, 0x01, 0x89, 0x1a,
+	0xf4, 0x95, 0xf0, 0x72, 0x06, 0x69, 0x1c, 0x91,
+	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0x88, 0x11,
+	0x12, 0x03, 0x11, 0x02, 0xf8, 0x45, 0x06, 0x79,
+	0xf0, 0x10, 0x00, 0x01, 0x88, 0x1a, 0xf4, 0x95,
+	0xf0, 0x72, 0x06, 0x78, 0x81, 0x91, 0x8a, 0x11,
+	0xfc, 0x00, 0x4a, 0x11, 0xf4, 0x95, 0x71, 0x02,
+	0x00, 0x11, 0x11, 0x03, 0x61, 0xf8, 0x00, 0x11,
+	0x00, 0x01, 0xf8, 0x30, 0x06, 0x91, 0xf6, 0xb8,
+	0x6f, 0xf8, 0x00, 0x11, 0x0c, 0x1f, 0x88, 0x11,
+	0xf3, 0xe8, 0xe8, 0xff, 0x18, 0x81, 0xf1, 0xa0,
+	0x81, 0x81, 0xf0, 0x73, 0x06, 0x9d, 0xf6, 0xb8,
+	0x6f, 0xf8, 0x00, 0x11, 0x0c, 0x1f, 0x88, 0x11,
+	0xf3, 0x30, 0x00, 0xff, 0xf0, 0x20, 0xff, 0x00,
+	0x18, 0x81, 0xf1, 0xa0, 0x81, 0x81, 0x8a, 0x11,
+	0xfc, 0x00, 0x4a, 0x11, 0xf4, 0x95, 0x11, 0x02,
+	0x61, 0xf8, 0x00, 0x0b, 0x00, 0x01, 0xf8, 0x20,
+	0x06, 0xb1, 0x49, 0x0b, 0xf6, 0x1f, 0x88, 0x11,
+	0xf4, 0x95, 0xf4, 0x95, 0x10, 0x81, 0xf2, 0x73,
+	0x06, 0xb8, 0xf0, 0x30, 0x00, 0xff, 0x49, 0x0b,
+	0xf6, 0x1f, 0x88, 0x11, 0xf4, 0x95, 0xf4, 0x95,
+	0x12, 0x81, 0xf4, 0x78, 0x8a, 0x11, 0xfc, 0x00,
+	0x4a, 0x11, 0xf4, 0x95, 0x71, 0x02, 0x00, 0x12,
+	0x13, 0x03, 0x88, 0x11, 0xe8, 0x00, 0xf8, 0x4d,
+	0x06, 0xcc, 0xf3, 0x10, 0x00, 0x01, 0x89, 0x1a,
+	0xf4, 0x95, 0xf0, 0x72, 0x06, 0xcb, 0x11, 0x92,
+	0xf2, 0xc0, 0x81, 0x91, 0x8a, 0x11, 0xfc, 0x00,
+	0x88, 0x12, 0x12, 0x02, 0x71, 0x01, 0x00, 0x13,
+	0xf8, 0x45, 0x06, 0xdb, 0xf0, 0x10, 0x00, 0x01,
+	0x88, 0x1a, 0xf4, 0x95, 0xf0, 0x72, 0x06, 0xda,
+	0xe5, 0x98, 0xfc, 0x00, 0x4a, 0x11, 0xee, 0xfe,
+	0x88, 0x11, 0x11, 0x04, 0x10, 0x06, 0x71, 0x05,
+	0x00, 0x12, 0x61, 0xf8, 0x00, 0x12, 0x00, 0x01,
+	0xf8, 0x20, 0x06, 0xea, 0xf0, 0x00, 0x00, 0x01,
+	0xf6, 0xb8, 0xf0, 0x00, 0x00, 0x01, 0x6f, 0xf8,
+	0x00, 0x12, 0x0f, 0x1f, 0x48, 0x08, 0x81, 0x00,
+	0xf4, 0x7f, 0x80, 0x01, 0xf2, 0x74, 0x06, 0xba,
+	0xf4, 0x95, 0x48, 0x11, 0xee, 0x02, 0x8a, 0x11,
+	0xfc, 0x00, 0x4a, 0x11, 0xee, 0xfe, 0x88, 0x12,
+	0x11, 0x04, 0x10, 0x06, 0x71, 0x05, 0x00, 0x13,
+	0x61, 0xf8, 0x00, 0x13, 0x00, 0x01, 0xf8, 0x20,
+	0x07, 0x09, 0xf0, 0x00, 0x00, 0x01, 0xf0, 0x00,
+	0x00, 0x01, 0x88, 0x11, 0xf6, 0xb8, 0x6f, 0xf8,
+	0x00, 0x13, 0x0f, 0x1f, 0x81, 0x00, 0x48, 0x11,
+	0xf4, 0x7f, 0x80, 0x01, 0xf2, 0x74, 0x06, 0xce,
+	0xf4, 0x95, 0x48, 0x12, 0x48, 0x11, 0xf0, 0x30,
+	0xff, 0xfe, 0xee, 0x02, 0x8a, 0x11, 0xfc, 0x00,
+	0x4a, 0x11, 0x4a, 0x16, 0x4a, 0x17, 0xee, 0xfc,
+	0xf4, 0x95, 0x80, 0x02, 0x71, 0x08, 0x00, 0x16,
+	0x10, 0x09, 0x71, 0x0b, 0x00, 0x17, 0x80, 0x03,
+	0x71, 0x0a, 0x00, 0x11, 0x48, 0x17, 0xf8, 0x45,
+	0x07, 0x3f, 0x70, 0x00, 0x00, 0x11, 0x10, 0x03,
+	0xf0, 0x74, 0x06, 0x9f, 0x80, 0x01, 0x70, 0x00,
+	0x00, 0x16, 0x10, 0x02, 0xf0, 0x74, 0x06, 0x7b,
+	0x6d, 0x91, 0x6d, 0x96, 0x6c, 0xef, 0xff, 0xff,
+	0x07, 0x2f, 0xee, 0x04, 0x8a, 0x17, 0x8a, 0x16,
+	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0xee, 0xfe,
+	0x10, 0xf8, 0x2a, 0xe8, 0x08, 0xf8, 0x2a, 0xe9,
+	0xf8, 0x45, 0x07, 0x64, 0x76, 0x00, 0x00, 0x01,
+	0x62, 0xf8, 0x2a, 0xe9, 0x00, 0x5e, 0xf2, 0x74,
+	0x12, 0x0b, 0xf0, 0x00, 0x30, 0x40, 0x72, 0x11,
+	0x2a, 0xe9, 0x77, 0x10, 0x00, 0x0f, 0xf5, 0xa9,
+	0xf8, 0x20, 0x07, 0x61, 0x6b, 0xf8, 0x2a, 0xe9,
+	0x00, 0x01, 0xf0, 0x73, 0x07, 0x64, 0x76, 0xf8,
+	0x2a, 0xe9, 0x00, 0x00, 0xee, 0x02, 0x8a, 0x11,
+	0xfc, 0x00, 0x4a, 0x11, 0x88, 0x11, 0xe8, 0x00,
+	0x75, 0xf8, 0x00, 0x08, 0x00, 0x08, 0xe8, 0x00,
+	0x75, 0xf8, 0x00, 0x08, 0x00, 0x09, 0xf6, 0xb8,
+	0xf4, 0x95, 0xf0, 0x20, 0xfc, 0x3f, 0x75, 0xf8,
+	0x00, 0x08, 0x00, 0x0d, 0xf0, 0x20, 0x0c, 0x30,
+	0x75, 0xf8, 0x00, 0x08, 0x00, 0x0c, 0x76, 0xf8,
+	0x2a, 0xe8, 0x00, 0x00, 0x76, 0xf8, 0x2a, 0xe9,
+	0x00, 0x00, 0x6c, 0x81, 0x07, 0x92, 0x76, 0xf8,
+	0x2a, 0xea, 0x00, 0x00, 0xfb, 0x80, 0x16, 0x76,
+	0xf4, 0x95, 0xe8, 0x10, 0xe8, 0x00, 0x75, 0xf8,
+	0x00, 0x08, 0x00, 0x00, 0xf0, 0x73, 0x07, 0xa8,
+	0x76, 0xf8, 0x2a, 0xea, 0x00, 0x01, 0xfb, 0x80,
+	0x16, 0x66, 0xf4, 0x95, 0xe8, 0x10, 0xfb, 0x80,
+	0x16, 0x87, 0xf4, 0x95, 0xe8, 0x10, 0xe8, 0x00,
+	0x75, 0xf8, 0x00, 0x08, 0x00, 0x00, 0xf6, 0xb8,
+	0xf4, 0x95, 0xf0, 0x20, 0xff, 0xff, 0x75, 0xf8,
+	0x00, 0x08, 0x00, 0x00, 0x8a, 0x11, 0xfc, 0x00,
+	0xf4, 0x95, 0x4a, 0x08, 0x4a, 0x09, 0x4a, 0x0a,
+	0x4a, 0x06, 0x4a, 0x07, 0x4a, 0x1d, 0x68, 0xf8,
+	0x00, 0x07, 0x7d, 0x3f, 0x69, 0xf8, 0x00, 0x07,
+	0x40, 0x00, 0x68, 0xf8, 0x00, 0x1d, 0xff, 0xfc,
+	0x10, 0xf8, 0x2a, 0xea, 0xf8, 0x45, 0x07, 0xe1,
+	0x10, 0xf8, 0x2a, 0xe8, 0xf0, 0x00, 0x00, 0x01,
+	0xf0, 0x30, 0x00, 0x0f, 0x80, 0xf8, 0x2a, 0xe8,
+	0x10, 0xf8, 0x2a, 0xe8, 0xf8, 0x44, 0x07, 0xd6,
+	0xf6, 0xb8, 0xf4, 0x95, 0xf0, 0x20, 0xfc, 0x3f,
+	0x75, 0xf8, 0x00, 0x08, 0x00, 0x0d, 0xf0, 0x20,
+	0x0c, 0x30, 0x75, 0xf8, 0x00, 0x08, 0x00, 0x0c,
+	0xe8, 0x00, 0x75, 0xf8, 0x00, 0x08, 0x00, 0x00,
+	0xf6, 0xb8, 0xf4, 0x95, 0xf0, 0x20, 0xff, 0xff,
+	0x75, 0xf8, 0x00, 0x08, 0x00, 0x00, 0x8a, 0x1d,
+	0x8a, 0x07, 0x8a, 0x06, 0x8a, 0x0a, 0x8a, 0x09,
+	0x8a, 0x08, 0xf4, 0xeb, 0xee, 0xff, 0xf2, 0x74,
+	0x07, 0x67, 0xf4, 0x95, 0xe8, 0x01, 0xee, 0x01,
+	0xfc, 0x00, 0x4a, 0x07, 0x4a, 0x1d, 0x68, 0xf8,
+	0x00, 0x07, 0x7d, 0x3f, 0x69, 0xf8, 0x00, 0x07,
+	0x40, 0x00, 0x68, 0xf8, 0x00, 0x1d, 0xff, 0xfc,
+	0x8a, 0x1d, 0x8a, 0x07, 0xf4, 0xeb, 0x4a, 0x11,
+	0x77, 0x11, 0x00, 0x28, 0x76, 0x81, 0x24, 0x00,
+	0xe8, 0x00, 0x75, 0xf8, 0x00, 0x08, 0x00, 0x01,
+	0xf2, 0x74, 0x07, 0x67, 0xf4, 0x95, 0xe8, 0x00,
+	0x77, 0x11, 0x00, 0x1d, 0x68, 0x81, 0x00, 0x7f,
+	0xf6, 0xb8, 0xf4, 0x95, 0xf0, 0x20, 0xff, 0x80,
+	0x77, 0x11, 0x00, 0x1d, 0xf0, 0x30, 0x01, 0x00,
+	0x1a, 0x81, 0x80, 0x81, 0xf0, 0x74, 0x0a, 0x33,
+	0xf0, 0x74, 0x11, 0xac, 0xf9, 0x80, 0x13, 0x25,
+	0xf9, 0x80, 0x16, 0x53, 0xf9, 0x80, 0x17, 0x82,
+	0xf0, 0x74, 0x06, 0x2f, 0xf9, 0x80, 0x14, 0xb2,
+	0xf9, 0x80, 0x19, 0x10, 0xf0, 0x74, 0x0d, 0xe3,
+	0xf0, 0x74, 0x07, 0xe8, 0xf0, 0x74, 0x02, 0x36,
+	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0x60, 0xf8,
+	0x27, 0x7b, 0xff, 0xff, 0xf8, 0x30, 0x08, 0x39,
+	0x71, 0xf8, 0x27, 0x7b, 0x27, 0x79, 0x60, 0xf8,
+	0x27, 0x79, 0xff, 0xff, 0xf8, 0x30, 0x08, 0xb2,
+	0x10, 0xf8, 0x29, 0x86, 0x08, 0xf8, 0x27, 0x79,
+	0xf0, 0x30, 0x7f, 0xff, 0x88, 0x11, 0xf4, 0x95,
+	0x77, 0x10, 0x40, 0x00, 0xf6, 0xa9, 0xf8, 0x30,
+	0x08, 0x58, 0x10, 0xf8, 0x27, 0x79, 0x08, 0xf8,
+	0x27, 0x7a, 0xf0, 0x30, 0x7f, 0xff, 0x88, 0x11,
+	0xf4, 0x95, 0x77, 0x10, 0x40, 0x00, 0xf6, 0xa9,
+	0xf8, 0x20, 0x08, 0x63, 0x76, 0xf8, 0x27, 0x79,
+	0xff, 0xff, 0x76, 0xf8, 0x27, 0x7b, 0xff, 0xff,
+	0xf7, 0xb8, 0xf2, 0x73, 0x08, 0xd9, 0xf0, 0x20,
+	0xff, 0xff, 0xf6, 0xb8, 0x56, 0xf8, 0x27, 0x74,
+	0xf0, 0xf9, 0x88, 0x11, 0x56, 0xf8, 0x27, 0x72,
+	0xf0, 0xf9, 0x88, 0x12, 0xf4, 0x95, 0xf4, 0x95,
+	0xe7, 0x20, 0xf4, 0xa9, 0xf8, 0x30, 0x08, 0x8f,
+	0xf1, 0x20, 0x27, 0x7c, 0x48, 0x11, 0xf6, 0x00,
+	0x88, 0x13, 0xf4, 0x95, 0xf4, 0x95, 0x10, 0x83,
+	0x08, 0xf8, 0x27, 0x79, 0xf0, 0x30, 0x7f, 0xff,
+	0x88, 0x13, 0xf4, 0x95, 0x77, 0x10, 0x40, 0x00,
+	0xf5, 0xab, 0xf8, 0x30, 0x08, 0x8f, 0x6d, 0x91,
+	0x48, 0x11, 0xf0, 0x30, 0x01, 0xff, 0x88, 0x11,
+	0xf4, 0x95, 0xe7, 0x20, 0xf7, 0xa9, 0xf8, 0x30,
+	0x08, 0x74, 0x6d, 0x89, 0x48, 0x11, 0xf0, 0x30,
+	0x01, 0xff, 0xf0, 0xe7, 0xf4, 0x95, 0x48, 0x08,
+	0x4e, 0xf8, 0x27, 0x74, 0x48, 0x08, 0xf1, 0xf9,
+	0x89, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x71, 0xe1,
+	0x27, 0x7c, 0x27, 0x7a, 0x60, 0xf8, 0x27, 0x7b,
+	0xff, 0xff, 0xf8, 0x30, 0x08, 0xab, 0x48, 0x08,
+	0x4e, 0xf8, 0x27, 0x72, 0x76, 0xf8, 0x27, 0x7b,
+	0xff, 0xff, 0x76, 0xf8, 0x27, 0x79, 0xff, 0xff,
+	0xf2, 0x73, 0x08, 0xd9, 0xf4, 0x95, 0xe8, 0x00,
+	0x44, 0xf8, 0x27, 0x73, 0x40, 0xf8, 0x27, 0x75,
+	0x82, 0xf8, 0x00, 0x11, 0xf4, 0x95, 0x77, 0x10,
+	0x80, 0x00, 0xf6, 0xa9, 0xf8, 0x20, 0x08, 0xd8,
+	0xf6, 0xb8, 0x10, 0xf8, 0x27, 0x73, 0xf0, 0x00,
+	0x80, 0x00, 0x48, 0x08, 0x4e, 0xf8, 0x27, 0x74,
+	0x48, 0x08, 0xf0, 0xf9, 0x88, 0x11, 0xf4, 0x95,
+	0xf4, 0x95, 0x71, 0xe1, 0x27, 0x7c, 0x27, 0x7a,
+	0xf7, 0xb8, 0x57, 0xf8, 0x27, 0x74, 0xf0, 0x62,
+	0xff, 0xff, 0xf0, 0x40, 0xff, 0x80, 0xf2, 0x80,
+	0x4e, 0xf8, 0x27, 0x74, 0xe8, 0x00, 0x8a, 0x11,
+	0xfc, 0x00, 0x4a, 0x11, 0x4a, 0x16, 0xee, 0xfb,
+	0x11, 0xf8, 0x27, 0x71, 0x09, 0xf8, 0x27, 0x73,
+	0x89, 0x11, 0x88, 0x10, 0xf4, 0x95, 0xf4, 0x95,
+	0xf6, 0xa9, 0xf8, 0x20, 0x08, 0xed, 0xf2, 0x73,
+	0x09, 0x0e, 0xf4, 0x95, 0xe8, 0x00, 0xf6, 0x20,
+	0x76, 0x00, 0x00, 0x41, 0xf0, 0x74, 0x12, 0xee,
+	0x88, 0x16, 0xf4, 0x95, 0xf7, 0xb8, 0x6d, 0x96,
+	0x10, 0xf8, 0x00, 0x16, 0xf8, 0x47, 0x09, 0x0a,
+	0xe7, 0x61, 0x76, 0x00, 0x00, 0x00, 0x76, 0x01,
+	0x00, 0x80, 0x76, 0x02, 0x00, 0xff, 0x76, 0x03,
+	0x00, 0x00, 0xf2, 0x74, 0x0c, 0xb9, 0xf4, 0x95,
+	0xe8, 0x00, 0x6c, 0xe9, 0xff, 0xff, 0x08, 0xfb,
+	0x73, 0x16, 0x00, 0x0e, 0xf0, 0x66, 0x00, 0x41,
+	0xee, 0x05, 0x8a, 0x16, 0x8a, 0x11, 0xfc, 0x00,
+	0x4a, 0x11, 0xf4, 0x95, 0x71, 0x02, 0x00, 0x13,
+	0xf6, 0xb8, 0x77, 0x11, 0x7f, 0xff, 0x57, 0xf8,
+	0x27, 0x72, 0x48, 0x11, 0xf2, 0x80, 0xf0, 0x00,
+	0x80, 0x00, 0x88, 0x11, 0xf6, 0x40, 0xf0, 0xe0,
+	0xf1, 0xf1, 0xe8, 0x01, 0xf2, 0x80, 0x80, 0xf8,
+	0x27, 0x78, 0x77, 0x12, 0x80, 0x00, 0x57, 0xf8,
+	0x27, 0x72, 0x48, 0x12, 0xf2, 0x80, 0x88, 0x12,
+	0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x82, 0x09, 0x38,
+	0xe8, 0x00, 0x75, 0xf8, 0x00, 0x08, 0x00, 0x01,
+	0xf0, 0x73, 0x09, 0x3d, 0xf0, 0x20, 0x80, 0x01,
+	0x75, 0xf8, 0x00, 0x08, 0x00, 0x01, 0x70, 0x81,
+	0x00, 0x13, 0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11,
+	0xf0, 0x30, 0x7f, 0xff, 0x11, 0xf8, 0x29, 0x86,
+	0xf5, 0x20, 0xf3, 0x30, 0x7f, 0xff, 0x89, 0x11,
+	0xf4, 0x95, 0x77, 0x10, 0x40, 0x00, 0xf6, 0xa9,
+	0xf8, 0x20, 0x09, 0x54, 0xf2, 0x73, 0x09, 0x67,
+	0xf4, 0x95, 0xe8, 0x02, 0x6f, 0xf8, 0x27, 0x7a,
+	0x0d, 0x20, 0xf3, 0x30, 0x7f, 0xff, 0x89, 0x11,
+	0xf4, 0x95, 0x77, 0x10, 0x40, 0x00, 0xf6, 0xa9,
+	0xf8, 0x20, 0x09, 0x64, 0xf2, 0x73, 0x09, 0x67,
+	0xf4, 0x95, 0xe8, 0x01, 0x80, 0xf8, 0x27, 0x7b,
+	0xe8, 0x00, 0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11,
+	0x11, 0xf8, 0x29, 0x86, 0xf5, 0x20, 0xf3, 0x30,
+	0x7f, 0xff, 0x89, 0x11, 0xf4, 0x95, 0x77, 0x10,
+	0x40, 0x00, 0xf6, 0xa9, 0xf8, 0x20, 0x09, 0x7a,
+	0xf2, 0x73, 0x09, 0x8d, 0xf4, 0x95, 0xe8, 0x02,
+	0x6f, 0xf8, 0x27, 0x7a, 0x0d, 0x20, 0xf3, 0x30,
+	0x7f, 0xff, 0x89, 0x11, 0xf4, 0x95, 0x77, 0x10,
+	0x40, 0x00, 0xf6, 0xa9, 0xf8, 0x20, 0x09, 0x8a,
+	0xf2, 0x73, 0x09, 0x8d, 0xf4, 0x95, 0xe8, 0x01,
+	0x80, 0xf8, 0x27, 0x79, 0xe8, 0x00, 0x8a, 0x11,
+	0xfc, 0x00, 0x4a, 0x11, 0xf4, 0x95, 0x71, 0x02,
+	0x00, 0x12, 0x88, 0x11, 0xf6, 0xb8, 0x57, 0xf8,
+	0x27, 0x72, 0xf0, 0x20, 0x7f, 0xff, 0xf2, 0x80,
+	0xf0, 0x00, 0x80, 0x00, 0x80, 0x81, 0x57, 0xf8,
+	0x27, 0x72, 0xe8, 0x01, 0xf3, 0xf1, 0xf2, 0x80,
+	0x80, 0xf8, 0x27, 0x78, 0x77, 0x11, 0x80, 0x00,
+	0x48, 0x11, 0x57, 0xf8, 0x27, 0x72, 0xf2, 0x80,
+	0x88, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x81,
+	0x09, 0xb5, 0xe8, 0x00, 0x75, 0xf8, 0x00, 0x08,
+	0x00, 0x01, 0xf0, 0x73, 0x09, 0xba, 0xf0, 0x20,
+	0x80, 0x01, 0x75, 0xf8, 0x00, 0x08, 0x00, 0x01,
+	0x45, 0xf8, 0x27, 0x71, 0x43, 0xf8, 0x27, 0x73,
+	0x83, 0xf8, 0x00, 0x11, 0xf4, 0x95, 0xe7, 0x20,
+	0xf6, 0xa9, 0xf8, 0x30, 0x09, 0xc9, 0xf2, 0x73,
+	0x09, 0xe4, 0x77, 0x12, 0x00, 0x00, 0x57, 0xf8,
+	0x27, 0x72, 0xf0, 0x20, 0x7f, 0xff, 0xf2, 0x80,
+	0x49, 0x12, 0xf5, 0x00, 0xf3, 0x00, 0x80, 0x00,
+	0x61, 0xf8, 0x00, 0x0b, 0x80, 0x00, 0xf8, 0x30,
+	0x09, 0xdc, 0xf1, 0x20, 0x80, 0x00, 0xf5, 0x20,
+	0x89, 0x12, 0xf4, 0x95, 0x48, 0x12, 0x6f, 0xf8,
+	0x27, 0x73, 0x0d, 0x00, 0xf4, 0x95, 0x49, 0x0b,
+	0x4f, 0xf8, 0x27, 0x72, 0x8a, 0x11, 0xfe, 0x00,
+	0x48, 0x12, 0xf4, 0x95, 0x4a, 0x11, 0x4a, 0x16,
+	0x4a, 0x17, 0xee, 0xfc, 0xf4, 0x95, 0x71, 0x08,
+	0x00, 0x16, 0x88, 0x17, 0xf0, 0x74, 0x08, 0x30,
+	0x48, 0x18, 0x70, 0x00, 0x00, 0x16, 0xf2, 0x74,
+	0x09, 0x8f, 0xf0, 0x00, 0x00, 0x02, 0x88, 0x11,
+	0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x81, 0x0a, 0x0a,
+	0xf2, 0x74, 0x08, 0xdb, 0xf4, 0x95, 0x48, 0x16,
+	0x48, 0x18, 0x70, 0x00, 0x00, 0x16, 0xf2, 0x74,
+	0x09, 0x8f, 0xf0, 0x00, 0x00, 0x02, 0x88, 0x11,
+	0x10, 0x02, 0x70, 0x01, 0x00, 0x11, 0x80, 0x00,
+	0xf2, 0x74, 0x06, 0xce, 0xf4, 0x95, 0x48, 0x17,
+	0x49, 0x11, 0x48, 0x17, 0xf6, 0x00, 0x88, 0x17,
+	0xe7, 0x60, 0xf5, 0xa9, 0xf8, 0x20, 0x0a, 0x2d,
+	0x48, 0x16, 0xf6, 0x20, 0x88, 0x11, 0x48, 0x18,
+	0x70, 0x00, 0x00, 0x11, 0xf2, 0x74, 0x09, 0x8f,
+	0xf0, 0x00, 0x00, 0x02, 0x88, 0x11, 0x70, 0x01,
+	0x00, 0x11, 0x10, 0x02, 0x80, 0x00, 0xf2, 0x74,
+	0x06, 0xce, 0xf4, 0x95, 0x48, 0x17, 0xee, 0x04,
+	0x48, 0x16, 0x8a, 0x17, 0x8a, 0x16, 0x8a, 0x11,
+	0xfc, 0x00, 0xee, 0xfd, 0xe8, 0x00, 0x4e, 0xf8,
+	0x27, 0x70, 0xe8, 0x00, 0x4e, 0xf8, 0x27, 0x72,
+	0xe8, 0x00, 0x4e, 0xf8, 0x27, 0x74, 0xe8, 0x00,
+	0x4e, 0xf8, 0x27, 0x76, 0x76, 0xf8, 0x27, 0x79,
+	0xff, 0xff, 0x76, 0xf8, 0x27, 0x7a, 0x00, 0x00,
+	0x76, 0xf8, 0x27, 0x7b, 0xff, 0xff, 0x76, 0xf8,
+	0x27, 0x78, 0x00, 0x00, 0xe8, 0x00, 0x75, 0xf8,
+	0x00, 0x08, 0x00, 0x01, 0x76, 0x00, 0x00, 0x00,
+	0x76, 0x01, 0x02, 0x00, 0xf2, 0x74, 0x12, 0xdc,
+	0xf0, 0x20, 0x27, 0x7c, 0xee, 0x03, 0xfc, 0x00,
+	0x4a, 0x11, 0xee, 0xfc, 0xf4, 0x95, 0x4e, 0x00,
+	0x77, 0x12, 0x7f, 0xff, 0xf6, 0xb8, 0x49, 0x12,
+	0xf1, 0x80, 0xf3, 0x00, 0x80, 0x00, 0x89, 0x12,
+	0xf0, 0xe0, 0xf1, 0xf1, 0x4f, 0x02, 0xe9, 0x01,
+	0xf4, 0x95, 0x48, 0x0b, 0xf5, 0x40, 0x56, 0x02,
+	0xf1, 0x80, 0x81, 0xf8, 0x27, 0x78, 0x77, 0x11,
+	0x80, 0x00, 0x56, 0x00, 0x49, 0x11, 0xf1, 0x80,
+	0x89, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x81,
+	0x0a, 0x81, 0xe8, 0x00, 0x75, 0xf8, 0x00, 0x08,
+	0x00, 0x01, 0xf0, 0x73, 0x0a, 0x86, 0xf0, 0x20,
+	0x80, 0x01, 0x75, 0xf8, 0x00, 0x08, 0x00, 0x01,
+	0x10, 0x82, 0xee, 0x04, 0x8a, 0x11, 0xfc, 0x00,
+	0x4a, 0x11, 0xee, 0xfe, 0xf4, 0x95, 0x4e, 0x00,
+	0x77, 0x11, 0x7f, 0xff, 0xf6, 0xb8, 0x49, 0x11,
+	0xf1, 0x80, 0xf3, 0x00, 0x80, 0x00, 0x89, 0x11,
+	0xf0, 0xe0, 0xf1, 0xf1, 0xe8, 0x01, 0xf2, 0x80,
+	0x80, 0xf8, 0x27, 0x78, 0x56, 0x00, 0xf1, 0x20,
+	0x80, 0x00, 0xf1, 0x80, 0xf4, 0x95, 0x49, 0x0b,
+	0xf8, 0x4d, 0x0a, 0xab, 0xf0, 0x20, 0x80, 0x01,
+	0x75, 0xf8, 0x00, 0x08, 0x00, 0x01, 0xf0, 0x73,
+	0x0a, 0xaf, 0xe8, 0x00, 0x75, 0xf8, 0x00, 0x08,
+	0x00, 0x01, 0xee, 0x02, 0x48, 0x11, 0x8a, 0x11,
+	0xfc, 0x00, 0x4a, 0x11, 0x88, 0x12, 0x13, 0x02,
+	0x77, 0x11, 0x00, 0x00, 0xf8, 0x4d, 0x0a, 0xcb,
+	0xf3, 0x10, 0x00, 0x01, 0x89, 0x1a, 0xf4, 0x95,
+	0xf0, 0x72, 0x0a, 0xca, 0x48, 0x11, 0x1c, 0xf8,
+	0x29, 0x7e, 0x88, 0x11, 0x11, 0xf8, 0x29, 0x7e,
+	0xf2, 0x00, 0x00, 0x01, 0x80, 0xf8, 0x29, 0x7e,
+	0x81, 0x92, 0x48, 0x11, 0x8a, 0x11, 0xfc, 0x00,
+	0x4a, 0x11, 0xf4, 0x95, 0x71, 0x02, 0x00, 0x11,
+	0x88, 0x12, 0xf6, 0xb8, 0xf0, 0x20, 0x7f, 0xff,
+	0x57, 0xf8, 0x27, 0x70, 0xf2, 0x80, 0xf0, 0x00,
+	0x80, 0x00, 0x80, 0x82, 0x57, 0xf8, 0x27, 0x70,
+	0xe8, 0x01, 0xf3, 0xf1, 0xf2, 0x80, 0x80, 0xf8,
+	0x27, 0x78, 0x77, 0x12, 0x80, 0x00, 0x48, 0x12,
+	0x57, 0xf8, 0x27, 0x70, 0xf2, 0x80, 0x88, 0x12,
+	0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x82, 0x0a, 0xf4,
+	0xe8, 0x00, 0x75, 0xf8, 0x00, 0x08, 0x00, 0x01,
+	0xf0, 0x73, 0x0a, 0xf9, 0xf0, 0x20, 0x80, 0x01,
+	0x75, 0xf8, 0x00, 0x08, 0x00, 0x01, 0x45, 0xf8,
+	0x27, 0x75, 0xe7, 0x10, 0x43, 0xf8, 0x27, 0x71,
+	0x83, 0xf8, 0x00, 0x12, 0x6d, 0xe8, 0x00, 0x04,
+	0x6d, 0x8a, 0xf6, 0xaa, 0xf8, 0x30, 0x0b, 0x0a,
+	0xf2, 0x73, 0x0b, 0x25, 0x77, 0x11, 0x00, 0x00,
+	0x57, 0xf8, 0x27, 0x70, 0xf0, 0x20, 0x7f, 0xff,
+	0xf2, 0x80, 0x49, 0x11, 0xf5, 0x00, 0xf3, 0x00,
+	0x80, 0x00, 0x61, 0xf8, 0x00, 0x0b, 0x80, 0x00,
+	0xf8, 0x30, 0x0b, 0x1d, 0xf1, 0x20, 0x80, 0x00,
+	0xf5, 0x20, 0x89, 0x11, 0xf4, 0x95, 0x48, 0x11,
+	0x6f, 0xf8, 0x27, 0x71, 0x0d, 0x00, 0xf4, 0x95,
+	0x49, 0x0b, 0x4f, 0xf8, 0x27, 0x70, 0x48, 0x11,
+	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0x4a, 0x16,
+	0x4a, 0x17, 0xee, 0xf0, 0x88, 0x17, 0x10, 0x17,
+	0x80, 0x05, 0x10, 0x16, 0x80, 0x06, 0x10, 0x15,
+	0x80, 0x07, 0x71, 0x14, 0x00, 0x11, 0x10, 0x05,
+	0xf0, 0x30, 0x00, 0x01, 0x88, 0x10, 0x10, 0x06,
+	0xf0, 0x30, 0x00, 0x01, 0x80, 0x08, 0x49, 0x11,
+	0x10, 0x05, 0xf6, 0x01, 0x80, 0x09, 0x10, 0x06,
+	0x61, 0xf8, 0x00, 0x08, 0x00, 0x01, 0xf8, 0x20,
+	0x0b, 0x4b, 0x10, 0x09, 0xf0, 0x00, 0x00, 0x01,
+	0x80, 0x09, 0x71, 0x08, 0x00, 0x12, 0xf4, 0xaa,
+	0xf8, 0x30, 0x0b, 0x54, 0x10, 0x09, 0xf0, 0x00,
+	0x00, 0x01, 0x80, 0x09, 0x12, 0x09, 0x49, 0x11,
+	0xf4, 0x7f, 0x80, 0x09, 0xf6, 0x20, 0x80, 0x0a,
+	0x56, 0xf8, 0x27, 0x70, 0x4e, 0x0c, 0x10, 0x09,
+	0x80, 0x00, 0x48, 0x18, 0xf2, 0x74, 0x0a, 0xce,
+	0xf0, 0x00, 0x00, 0x04, 0x88, 0x16, 0xf4, 0x95,
+	0xf4, 0x95, 0x6c, 0x86, 0x0b, 0x6d, 0xf2, 0x73,
+	0x0c, 0x59, 0xf4, 0x95, 0xe8, 0x00, 0xf6, 0xb8,
+	0xf4, 0x95, 0x56, 0x0c, 0xf0, 0xf9, 0x88, 0x12,
+	0xf4, 0x95, 0xf4, 0x95, 0x70, 0xe2, 0x27, 0x7c,
+	0x29, 0x86, 0xe8, 0x00, 0x80, 0x0e, 0x48, 0x11,
+	0xf8, 0x45, 0x0b, 0xcc, 0x77, 0x10, 0x00, 0x01,
+	0xf4, 0xa9, 0xf8, 0x30, 0x0b, 0x89, 0x6c, 0xe1,
+	0xff, 0xfd, 0x0b, 0x8b, 0x10, 0xe7, 0x00, 0x02,
+	0x80, 0x0e, 0xf0, 0x73, 0x0b, 0x8b, 0x10, 0x87,
+	0x80, 0x0e, 0xe7, 0x10, 0xf5, 0xae, 0xf8, 0x20,
+	0x0b, 0xb2, 0x70, 0x00, 0x00, 0x17, 0x70, 0x01,
+	0x00, 0x16, 0x10, 0x04, 0xf0, 0x74, 0x06, 0xce,
+	0x48, 0x17, 0x49, 0x16, 0xf6, 0x00, 0x88, 0x17,
+	0x48, 0x11, 0xf6, 0x20, 0x88, 0x11, 0x10, 0x09,
+	0xf6, 0x20, 0x80, 0x00, 0x48, 0x18, 0xf2, 0x74,
+	0x0a, 0xce, 0xf0, 0x00, 0x00, 0x04, 0x88, 0x16,
+	0x10, 0x04, 0x70, 0x00, 0x00, 0x17, 0x70, 0x01,
+	0x00, 0x11, 0xf0, 0x74, 0x06, 0xce, 0x48, 0x11,
+	0x00, 0x04, 0x80, 0x04, 0xf0, 0x73, 0x0b, 0xbc,
+	0x70, 0x00, 0x00, 0x17, 0x70, 0x01, 0x00, 0x11,
+	0x10, 0x04, 0xf0, 0x74, 0x06, 0xce, 0x48, 0x11,
+	0x00, 0x04, 0x80, 0x04, 0x49, 0x11, 0x48, 0x16,
+	0xf6, 0x20, 0x88, 0x16, 0xf4, 0x95, 0xf4, 0x95,
+	0x6c, 0x86, 0x0b, 0xcc, 0x10, 0x0a, 0x80, 0x00,
+	0x48, 0x18, 0xf2, 0x74, 0x0a, 0xce, 0xf0, 0x00,
+	0x00, 0x04, 0x88, 0x16, 0x12, 0x0a, 0xf8, 0x45,
+	0x0c, 0x33, 0x71, 0x0a, 0x00, 0x10, 0xf4, 0xae,
+	0xf8, 0x30, 0x0c, 0x1c, 0x48, 0x16, 0xf0, 0xe1,
+	0x88, 0x11, 0x12, 0x08, 0xf8, 0x45, 0x0b, 0xdb,
+	0x6d, 0x89, 0x12, 0x07, 0xf8, 0x45, 0x0b, 0xe9,
+	0x10, 0x07, 0x80, 0x00, 0x70, 0x02, 0x00, 0x11,
+	0x10, 0x06, 0x80, 0x01, 0x10, 0x04, 0xf0, 0x74,
+	0x06, 0xdc, 0xf0, 0x73, 0x0b, 0xef, 0x48, 0x11,
+	0x6f, 0x00, 0x0c, 0x9f, 0x10, 0x04, 0xf0, 0x74,
+	0x0a, 0xb3, 0x11, 0x0e, 0xf1, 0xc0, 0x81, 0x0e,
+	0x10, 0x06, 0x49, 0x11, 0xf6, 0x00, 0x80, 0x06,
+	0x10, 0x05, 0xf6, 0x20, 0x88, 0x11, 0xf0, 0x00,
+	0x00, 0x01, 0x48, 0x08, 0x6f, 0x00, 0x0c, 0x9f,
+	0x48, 0x18, 0xf2, 0x74, 0x0a, 0xce, 0xf0, 0x00,
+	0x00, 0x04, 0x12, 0x07, 0xf8, 0x45, 0x0c, 0x11,
+	0x10, 0x07, 0x80, 0x00, 0x70, 0x02, 0x00, 0x11,
+	0x10, 0x06, 0x80, 0x01, 0x10, 0x04, 0xf0, 0x74,
+	0x06, 0xdc, 0xf0, 0x73, 0x0c, 0x17, 0x48, 0x11,
+	0x6f, 0x00, 0x0c, 0x9f, 0x10, 0x04, 0xf0, 0x74,
+	0x0a, 0xb3, 0x11, 0x0e, 0xf1, 0xc0, 0x81, 0x0e,
+	0xf0, 0x73, 0x0c, 0x33, 0x12, 0x07, 0xf8, 0x45,
+	0x0c, 0x2a, 0x10, 0x07, 0x80, 0x00, 0x10, 0x06,
+	0x80, 0x01, 0x10, 0x05, 0x80, 0x02, 0x10, 0x04,
+	0xf0, 0x74, 0x06, 0xdc, 0xf0, 0x73, 0x0c, 0x30,
+	0x12, 0x05, 0x6f, 0x00, 0x0c, 0x9f, 0x10, 0x04,
+	0xf0, 0x74, 0x0a, 0xb3, 0x11, 0x0e, 0xf1, 0xc0,
+	0x81, 0x0e, 0x76, 0x00, 0x00, 0x01, 0x48, 0x18,
+	0xf2, 0x74, 0x0a, 0xce, 0xf0, 0x00, 0x00, 0x04,
+	0x71, 0x04, 0x00, 0x11, 0x70, 0x81, 0x29, 0x86,
+	0x10, 0x0e, 0x1c, 0xf8, 0x29, 0x86, 0x80, 0x0e,
+	0x76, 0x00, 0x00, 0x01, 0x48, 0x18, 0xf2, 0x74,
+	0x0a, 0xce, 0xf0, 0x00, 0x00, 0x04, 0x10, 0x0e,
+	0x71, 0x04, 0x00, 0x11, 0x80, 0x81, 0x10, 0xf8,
+	0x29, 0x86, 0xf0, 0x00, 0x00, 0x01, 0xf0, 0x30,
+	0x7f, 0xff, 0x80, 0xf8, 0x29, 0x86, 0x10, 0x09,
+	0xf0, 0x00, 0x00, 0x02, 0x80, 0x09, 0xee, 0x10,
+	0x8a, 0x17, 0x8a, 0x16, 0x8a, 0x11, 0xfc, 0x00,
+	0x10, 0xf8, 0x27, 0x75, 0x08, 0xf8, 0x27, 0x71,
+	0xf0, 0x10, 0x00, 0x01, 0x48, 0x08, 0xfc, 0x00,
+	0x4a, 0x11, 0x4a, 0x16, 0xee, 0xff, 0xf4, 0x95,
+	0x71, 0x04, 0x00, 0x16, 0xf0, 0x00, 0x00, 0x01,
+	0x48, 0x08, 0x4e, 0xf8, 0x29, 0x7c, 0x6d, 0xee,
+	0xff, 0xfd, 0x48, 0x16, 0xf8, 0x45, 0x0c, 0x99,
+	0x56, 0xf8, 0x29, 0x7c, 0xf0, 0x74, 0x0a, 0x5a,
+	0x88, 0x11, 0x10, 0xf8, 0x29, 0x7d, 0xf0, 0x00,
+	0x00, 0x01, 0x48, 0x08, 0x4e, 0xf8, 0x29, 0x7c,
+	0x10, 0xf8, 0x29, 0x82, 0xf0, 0x00, 0x00, 0x01,
+	0x88, 0x10, 0xf4, 0x95, 0xf4, 0x95, 0xf4, 0xa9,
+	0xfa, 0x30, 0x0c, 0x96, 0x80, 0xf8, 0x29, 0x82,
+	0x56, 0xf8, 0x29, 0x80, 0xf0, 0x00, 0x00, 0x01,
+	0x4e, 0xf8, 0x29, 0x80, 0x73, 0x11, 0x29, 0x82,
+	0x6c, 0xee, 0xff, 0xff, 0x0c, 0x76, 0xee, 0x01,
+	0x8a, 0x16, 0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11,
+	0x76, 0xf8, 0x29, 0x84, 0x00, 0x00, 0x76, 0xf8,
+	0x29, 0x85, 0x00, 0x01, 0xe8, 0x00, 0x4e, 0xf8,
+	0x2a, 0x0c, 0x76, 0xf8, 0x29, 0x86, 0x00, 0x00,
+	0x76, 0xf8, 0x29, 0x87, 0x00, 0x00, 0x77, 0x11,
+	0x29, 0x88, 0x76, 0x81, 0xaa, 0xaa, 0x76, 0xe1,
+	0x00, 0x01, 0xaa, 0xaa, 0x76, 0xe1, 0x00, 0x02,
+	0x00, 0x00, 0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11,
+	0xee, 0xfc, 0xf4, 0x95, 0x71, 0x06, 0x00, 0x14,
+	0x71, 0x07, 0x00, 0x13, 0x71, 0x08, 0x00, 0x12,
+	0x71, 0x09, 0x00, 0x15, 0x77, 0x10, 0x00, 0xff,
+	0xf4, 0xaa, 0xf8, 0x30, 0x0d, 0x44, 0x49, 0x13,
+	0x53, 0xf8, 0x2a, 0x0c, 0x4f, 0xf8, 0x2a, 0x0c,
+	0x73, 0x12, 0x00, 0x0e, 0xf1, 0x66, 0x00, 0x0d,
+	0x89, 0x11, 0xf4, 0x95, 0x77, 0x10, 0x00, 0x01,
+	0x71, 0xe1, 0x24, 0x00, 0x00, 0x11, 0xf4, 0xa9,
+	0xf8, 0x30, 0x0d, 0x17, 0x77, 0x10, 0x00, 0x02,
+	0xf4, 0xa9, 0xf8, 0x30, 0x0c, 0xec, 0x77, 0x11,
+	0x29, 0x8a, 0x76, 0x81, 0x00, 0x00, 0xe8, 0x00,
+	0x77, 0x14, 0x00, 0x00, 0x77, 0x13, 0x00, 0x00,
+	0xf0, 0x73, 0x0d, 0x48, 0x6c, 0x83, 0x0c, 0xfa,
+	0x77, 0x11, 0x29, 0x8a, 0x48, 0x12, 0xf0, 0xe8,
+	0xf0, 0x40, 0x80, 0x00, 0x80, 0x81, 0xe8, 0x00,
+	0x77, 0x14, 0x00, 0x00, 0xf0, 0x73, 0x0d, 0x48,
+	0x49, 0x13, 0xf3, 0x40, 0x80, 0x00, 0x81, 0xf8,
+	0x29, 0x8a, 0x61, 0xf8, 0x00, 0x15, 0x00, 0x01,
+	0xf8, 0x20, 0x0d, 0x07, 0x69, 0xf8, 0x29, 0x8a,
+	0x40, 0x00, 0x61, 0xf8, 0x00, 0x14, 0x00, 0x01,
+	0xf8, 0x20, 0x0d, 0x0f, 0x69, 0xf8, 0x29, 0x8a,
+	0x20, 0x00, 0x77, 0x11, 0x29, 0x8a, 0x49, 0x12,
+	0xf3, 0xe8, 0x1b, 0x81, 0x81, 0x81, 0xf0, 0x73,
+	0x0d, 0x48, 0x11, 0xf8, 0x29, 0x84, 0xf8, 0x4c,
+	0x0d, 0x37, 0x77, 0x11, 0x29, 0x88, 0x76, 0x81,
+	0xaa, 0xaa, 0x11, 0xf8, 0x29, 0x85, 0xf3, 0x10,
+	0x00, 0x01, 0xf3, 0x40, 0xaa, 0x00, 0x81, 0xe1,
+	0x00, 0x01, 0x76, 0x00, 0x00, 0x02, 0x80, 0x01,
+	0x70, 0x02, 0x00, 0x14, 0x70, 0x03, 0x00, 0x13,
+	0xf2, 0x74, 0x0b, 0x28, 0xf4, 0x95, 0x48, 0x11,
+	0x71, 0xf8, 0x29, 0x85, 0x29, 0x84, 0xf0, 0x73,
+	0x0d, 0x73, 0x76, 0x00, 0x00, 0x00, 0x80, 0x01,
+	0x76, 0x02, 0x00, 0x00, 0x70, 0x03, 0x00, 0x13,
+	0xf2, 0x74, 0x0b, 0x28, 0xf4, 0x95, 0xe8, 0x00,
+	0xf0, 0x73, 0x0d, 0x73, 0x77, 0x11, 0x29, 0x8a,
+	0x70, 0x81, 0x00, 0x13, 0x11, 0xf8, 0x29, 0x84,
+	0xf8, 0x4c, 0x0d, 0x68, 0x77, 0x11, 0x29, 0x88,
+	0x76, 0x81, 0xaa, 0xaa, 0x11, 0xf8, 0x29, 0x85,
+	0xf3, 0x10, 0x00, 0x01, 0xf3, 0x40, 0xaa, 0x00,
+	0x81, 0xe1, 0x00, 0x01, 0x76, 0x00, 0x00, 0x03,
+	0x80, 0x01, 0x70, 0x02, 0x00, 0x14, 0x70, 0x03,
+	0x00, 0x13, 0xf2, 0x74, 0x0b, 0x28, 0xf4, 0x95,
+	0x48, 0x11, 0x71, 0xf8, 0x29, 0x85, 0x29, 0x84,
+	0xf0, 0x73, 0x0d, 0x73, 0x76, 0x00, 0x00, 0x01,
+	0x80, 0x01, 0x70, 0x02, 0x00, 0x14, 0x70, 0x03,
+	0x00, 0x13, 0xf2, 0x74, 0x0b, 0x28, 0xf4, 0x95,
+	0x48, 0x11, 0x6b, 0xf8, 0x29, 0x84, 0xff, 0xff,
+	0xee, 0x04, 0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11,
+	0xf5, 0x40, 0xf4, 0x95, 0x48, 0x0b, 0xf4, 0x78,
+	0x88, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x6c, 0xe1,
+	0xff, 0xb9, 0x0d, 0x88, 0xf2, 0x73, 0x0d, 0xa5,
+	0xf4, 0x95, 0xe8, 0x60, 0xf2, 0x00, 0x00, 0x06,
+	0x61, 0xf8, 0x00, 0x11, 0x00, 0x20, 0xf8, 0x30,
+	0x0d, 0x98, 0x61, 0xf8, 0x00, 0x0b, 0x00, 0x01,
+	0xf8, 0x20, 0x0d, 0xa3, 0xf2, 0x00, 0x00, 0x07,
+	0xf0, 0x73, 0x0d, 0xa3, 0x61, 0xf8, 0x00, 0x0b,
+	0x00, 0x01, 0xf8, 0x20, 0x0d, 0xa1, 0xf2, 0x73,
+	0x0d, 0xa3, 0xf0, 0x00, 0x00, 0x01, 0xf0, 0x00,
+	0x00, 0x02, 0x48, 0x08, 0xf4, 0x7f, 0x8a, 0x11,
+	0xfc, 0x00, 0xee, 0xff, 0xf0, 0x74, 0x07, 0xfd,
+	0xf0, 0x74, 0x07, 0x44, 0xf0, 0x74, 0x0d, 0xb4,
+	0xf0, 0x74, 0x02, 0x05, 0xf0, 0x74, 0x04, 0x60,
+	0xf0, 0x73, 0x0d, 0xaa, 0xee, 0xfd, 0x10, 0xf8,
+	0x2a, 0xa3, 0xf8, 0x44, 0x0d, 0xcb, 0x10, 0xf8,
+	0x2a, 0xa4, 0xf8, 0x45, 0x0d, 0xd7, 0x76, 0x00,
+	0x02, 0x00, 0xf2, 0x74, 0x09, 0xe8, 0xf0, 0x20,
+	0x22, 0x00, 0x76, 0xf8, 0x2a, 0xa4, 0x00, 0x00,
+	0x76, 0xf8, 0x2a, 0xa7, 0x00, 0x00, 0xf0, 0x73,
+	0x0d, 0xd7, 0x76, 0x00, 0x02, 0x00, 0xf2, 0x74,
+	0x09, 0xe8, 0xf0, 0x20, 0x20, 0x00, 0x76, 0xf8,
+	0x2a, 0xa3, 0x00, 0x00, 0x76, 0xf8, 0x2a, 0xa7,
+	0x00, 0x01, 0xf0, 0x74, 0x0c, 0x5e, 0xf0, 0xe0,
+	0xf0, 0x10, 0x3a, 0x98, 0xf8, 0x47, 0x0d, 0xe1,
+	0x76, 0xf8, 0x27, 0x6e, 0x00, 0x00, 0xee, 0x03,
+	0xfc, 0x00, 0x4a, 0x11, 0xee, 0xfe, 0x77, 0x11,
+	0x20, 0x00, 0x76, 0x00, 0xaa, 0xaa, 0x76, 0x01,
+	0x02, 0x00, 0xf2, 0x74, 0x06, 0x6c, 0xf4, 0x95,
+	0x48, 0x11, 0x76, 0x00, 0x55, 0x55, 0x76, 0x01,
+	0x02, 0x00, 0x48, 0x11, 0xf2, 0x74, 0x06, 0x6c,
+	0xf0, 0x00, 0x02, 0x00, 0x76, 0xf8, 0x2a, 0xa3,
+	0x00, 0x00, 0x76, 0xf8, 0x2a, 0xa4, 0x00, 0x00,
+	0xe8, 0x00, 0x4e, 0x00, 0xfb, 0x80, 0x15, 0x3e,
+	0xf4, 0x95, 0xe8, 0x04, 0x80, 0xf8, 0x2a, 0xa5,
+	0x76, 0x00, 0x2a, 0xa8, 0xf9, 0x80, 0x14, 0x87,
+	0x76, 0x00, 0x2a, 0xad, 0xfb, 0x80, 0x13, 0x62,
+	0xf4, 0x95, 0xe8, 0x02, 0x10, 0xf8, 0x2a, 0xa5,
+	0xf9, 0x80, 0x14, 0x63, 0xfb, 0x80, 0x16, 0x66,
+	0xf4, 0x95, 0xe8, 0x1c, 0xfb, 0x80, 0x16, 0x87,
+	0xf4, 0x95, 0xe8, 0x1c, 0xe8, 0x01, 0x4e, 0x00,
+	0xfb, 0x80, 0x17, 0xd6, 0xf4, 0x95, 0xe8, 0x00,
+	0x80, 0xf8, 0x2a, 0xa6, 0x76, 0x00, 0x2a, 0xb7,
+	0xf9, 0x80, 0x16, 0xaa, 0x10, 0xf8, 0x2a, 0xa6,
+	0xf9, 0x80, 0x17, 0x5c, 0x10, 0xf8, 0x2a, 0xa6,
+	0xf9, 0x80, 0x17, 0x6f, 0xee, 0x02, 0x8a, 0x11,
+	0xfc, 0x00, 0xf4, 0x95, 0x4a, 0x08, 0x4a, 0x09,
+	0x4a, 0x0a, 0x4a, 0x07, 0x4a, 0x1d, 0x68, 0xf8,
+	0x00, 0x07, 0x7d, 0x3f, 0x69, 0xf8, 0x00, 0x07,
+	0x40, 0x00, 0x68, 0xf8, 0x00, 0x1d, 0xff, 0xfc,
+	0x10, 0xf8, 0x2a, 0xa7, 0xf8, 0x44, 0x0e, 0x4b,
+	0x76, 0xf8, 0x2a, 0xa3, 0x00, 0x01, 0xf0, 0x73,
+	0x0e, 0x4e, 0x76, 0xf8, 0x2a, 0xa4, 0x00, 0x01,
+	0x8a, 0x1d, 0x8a, 0x07, 0x8a, 0x0a, 0x8a, 0x09,
+	0x8a, 0x08, 0xf4, 0xeb, 0x4a, 0x11, 0x4a, 0x16,
+	0x4a, 0x17, 0xee, 0xfe, 0x88, 0x0e, 0x71, 0x08,
+	0x00, 0x16, 0x71, 0x06, 0x00, 0x17, 0x11, 0x07,
+	0xf0, 0x66, 0x00, 0x0d, 0xf0, 0x00, 0x25, 0xa0,
+	0x88, 0x11, 0x76, 0x01, 0x00, 0x06, 0x81, 0x00,
+	0xf2, 0x74, 0x06, 0xce, 0xf0, 0x00, 0x00, 0x01,
+	0x76, 0x01, 0x00, 0x06, 0x70, 0x00, 0x00, 0x16,
+	0x48, 0x11, 0xf2, 0x74, 0x06, 0xce, 0xf0, 0x00,
+	0x00, 0x07, 0x70, 0x81, 0x00, 0x17, 0xee, 0x02,
+	0x8a, 0x17, 0x8a, 0x16, 0x8a, 0x11, 0xfc, 0x00,
+	0x4a, 0x11, 0x88, 0x0e, 0x71, 0x02, 0x00, 0x12,
+	0x11, 0x03, 0xf0, 0x66, 0x00, 0x0d, 0xf0, 0x00,
+	0x24, 0x00, 0x88, 0x11, 0xf4, 0x95, 0x70, 0x81,
+	0x00, 0x12, 0x6e, 0xe2, 0xff, 0xfe, 0x0e, 0x8d,
+	0xf4, 0x95, 0xe8, 0x00, 0xe8, 0x01, 0x80, 0xe1,
+	0x00, 0x02, 0x76, 0xe1, 0x00, 0x03, 0x00, 0xff,
+	0x76, 0xe1, 0x00, 0x04, 0x00, 0x00, 0x76, 0xe1,
+	0x00, 0x0b, 0x00, 0x00, 0x76, 0xe1, 0x00, 0x0c,
+	0x00, 0x00, 0x81, 0xe1, 0x00, 0x01, 0x8a, 0x11,
+	0xfc, 0x00, 0x4a, 0x11, 0xee, 0xfc, 0x88, 0x0e,
+	0xf4, 0x95, 0xf1, 0x66, 0x00, 0x0d, 0xf3, 0x00,
+	0x24, 0x00, 0x89, 0x11, 0xf4, 0x95, 0xf4, 0x95,
+	0x76, 0xe1, 0x00, 0x0c, 0x00, 0x00, 0x76, 0xe1,
+	0x00, 0x0b, 0x00, 0x00, 0x76, 0xe1, 0x00, 0x02,
+	0x00, 0x01, 0x76, 0x00, 0x00, 0x00, 0x76, 0x01,
+	0x00, 0x00, 0x80, 0x02, 0x76, 0x03, 0x00, 0x00,
+	0xf2, 0x74, 0x0c, 0xb9, 0xf4, 0x95, 0xe8, 0x00,
+	0xee, 0x04, 0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11,
+	0x88, 0x19, 0xf4, 0x95, 0x73, 0x19, 0x00, 0x0e,
+	0xf1, 0x66, 0x00, 0x0d, 0xf2, 0x00, 0x24, 0x00,
+	0x77, 0x15, 0x25, 0xa0, 0x77, 0x14, 0x00, 0x00,
+	0x77, 0x1a, 0x00, 0x1f, 0xf0, 0x72, 0x0f, 0x14,
+	0xf6, 0xb8, 0x49, 0x19, 0x09, 0x85, 0xf8, 0x4c,
+	0x0f, 0x13, 0xf1, 0x00, 0x00, 0x05, 0x89, 0x11,
+	0x49, 0x15, 0xf3, 0x00, 0x00, 0x01, 0x89, 0x13,
+	0x49, 0x15, 0xf3, 0x00, 0x00, 0x07, 0x89, 0x12,
+	0x11, 0x93, 0x1d, 0x91, 0x19, 0x92, 0x89, 0x10,
+	0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x80, 0x0f, 0x13,
+	0x11, 0x93, 0x1d, 0x91, 0x19, 0x92, 0x89, 0x10,
+	0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x80, 0x0f, 0x13,
+	0x11, 0x93, 0x1d, 0x91, 0x19, 0x92, 0x89, 0x10,
+	0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x80, 0x0f, 0x13,
+	0x11, 0x93, 0x1d, 0x91, 0x19, 0x92, 0x89, 0x10,
+	0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x80, 0x0f, 0x13,
+	0x11, 0x93, 0x1d, 0x91, 0x19, 0x92, 0x89, 0x10,
+	0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x80, 0x0f, 0x13,
+	0x11, 0x93, 0x1d, 0x91, 0x19, 0x92, 0x89, 0x11,
+	0xf4, 0x95, 0xf4, 0x95, 0x6c, 0x81, 0x0f, 0x13,
+	0x6d, 0x94, 0x6d, 0xed, 0x00, 0x0d, 0x48, 0x14,
+	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0x4a, 0x16,
+	0x4a, 0x17, 0xee, 0xf8, 0x88, 0x17, 0x10, 0x0d,
+	0x80, 0x04, 0x10, 0x0c, 0x80, 0x05, 0x71, 0x0e,
+	0x00, 0x16, 0x73, 0x17, 0x00, 0x0e, 0xf0, 0x66,
+	0x00, 0x0d, 0xf0, 0x00, 0x24, 0x00, 0x88, 0x11,
+	0x10, 0xf8, 0x27, 0x63, 0xf8, 0x45, 0x0f, 0x32,
+	0xf2, 0x74, 0x0e, 0x9f, 0xf4, 0x95, 0x48, 0x17,
+	0x10, 0xf8, 0x27, 0x60, 0xf8, 0x44, 0x0f, 0x3d,
+	0x60, 0xe1, 0x00, 0x02, 0x00, 0x01, 0xf8, 0x20,
+	0x0f, 0x6d, 0xf0, 0x73, 0x11, 0x33, 0x10, 0x04,
+	0x80, 0x00, 0x10, 0x05, 0xf0, 0x74, 0x06, 0x9f,
+	0x11, 0x04, 0xf3, 0x00, 0x00, 0x01, 0x81, 0x04,
+	0x6d, 0x8e, 0x77, 0x10, 0x00, 0x01, 0x71, 0xe1,
+	0x00, 0x02, 0x00, 0x12, 0xf4, 0xaa, 0xf8, 0x30,
+	0x0f, 0x62, 0x77, 0x10, 0x00, 0x02, 0xf4, 0xaa,
+	0xf8, 0x30, 0x0f, 0x6d, 0x45, 0xe1, 0x00, 0x0b,
+	0x88, 0x10, 0x43, 0xe1, 0x00, 0x0c, 0x83, 0xf8,
+	0x00, 0x12, 0xf4, 0x95, 0xf4, 0x95, 0xf4, 0xaa,
+	0xf8, 0x30, 0x0f, 0x6d, 0xf0, 0x73, 0x0f, 0x96,
+	0xf5, 0x00, 0x81, 0x04, 0x49, 0x16, 0xf5, 0x20,
+	0x89, 0x16, 0x76, 0xe1, 0x00, 0x0c, 0x00, 0x00,
+	0x76, 0xe1, 0x00, 0x04, 0x00, 0x00, 0x48, 0x16,
+	0xf8, 0x45, 0x11, 0x33, 0xf7, 0xb8, 0x71, 0xe1,
+	0x00, 0x02, 0x00, 0x12, 0x10, 0xf8, 0x00, 0x12,
+	0xf0, 0x10, 0x00, 0x03, 0xf8, 0x46, 0x0f, 0x8c,
+	0x10, 0xf8, 0x00, 0x12, 0xf0, 0x10, 0x00, 0x03,
+	0xf8, 0x45, 0x10, 0x16, 0x77, 0x10, 0x00, 0x01,
+	0xf4, 0xaa, 0xf8, 0x30, 0x0f, 0x9c, 0x77, 0x10,
+	0x00, 0x02, 0xf4, 0xaa, 0xf8, 0x30, 0x0f, 0xa8,
+	0xf0, 0x73, 0x0f, 0x96, 0x77, 0x10, 0x00, 0x04,
+	0xf4, 0xaa, 0xf8, 0x30, 0x10, 0xb7, 0x77, 0x10,
+	0x00, 0x05, 0xf4, 0xaa, 0xf8, 0x30, 0x10, 0xbc,
+	0xf2, 0x74, 0x0e, 0x9f, 0xf4, 0x95, 0x48, 0x17,
+	0xf0, 0x73, 0x11, 0x31, 0x76, 0xe1, 0x00, 0x0c,
+	0x00, 0x00, 0x76, 0xe1, 0x00, 0x0b, 0x00, 0x00,
+	0x76, 0xe1, 0x00, 0x04, 0x00, 0x00, 0x76, 0xe1,
+	0x00, 0x02, 0x00, 0x02, 0x11, 0xe1, 0x00, 0x0c,
+	0xe8, 0x03, 0xf6, 0x20, 0x89, 0x12, 0xf4, 0x95,
+	0x77, 0x10, 0x00, 0x03, 0xf5, 0xaa, 0xf8, 0x30,
+	0x0f, 0xb6, 0x6b, 0xf8, 0x27, 0x6f, 0x00, 0x01,
+	0x88, 0x10, 0xf4, 0x95, 0xf4, 0x95, 0xf5, 0xae,
+	0xf8, 0x20, 0x0f, 0xbd, 0x48, 0x16, 0x80, 0x06,
+	0x88, 0x13, 0xf4, 0x95, 0x77, 0x10, 0x00, 0x03,
+	0xf6, 0xab, 0xf8, 0x20, 0x0f, 0xc8, 0x6b, 0xf8,
+	0x27, 0x6f, 0x00, 0x01, 0x12, 0x06, 0xf8, 0x45,
+	0x10, 0x00, 0x10, 0xe1, 0x00, 0x04, 0x80, 0x00,
+	0x10, 0x05, 0x80, 0x01, 0x10, 0x04, 0x80, 0x02,
+	0x10, 0x06, 0x80, 0x03, 0x48, 0x11, 0xf2, 0x74,
+	0x07, 0x1e, 0xf0, 0x00, 0x00, 0x05, 0x10, 0x06,
+	0x00, 0xe1, 0x00, 0x04, 0x80, 0xe1, 0x00, 0x04,
+	0x10, 0x06, 0x00, 0xe1, 0x00, 0x0c, 0x80, 0xe1,
+	0x00, 0x0c, 0x88, 0x12, 0x11, 0x06, 0x10, 0x04,
+	0xf6, 0x00, 0x80, 0x04, 0x48, 0x16, 0xf6, 0x20,
+	0x88, 0x16, 0x89, 0x13, 0xf4, 0x95, 0x77, 0x10,
+	0x00, 0x03, 0xf6, 0xab, 0xf8, 0x20, 0x0f, 0xf5,
+	0x6b, 0xf8, 0x27, 0x6f, 0x00, 0x01, 0x77, 0x10,
+	0x00, 0x0c, 0x71, 0xe1, 0x00, 0x04, 0x00, 0x13,
+	0xf6, 0xab, 0xf8, 0x20, 0x10, 0x00, 0x6b, 0xf8,
+	0x27, 0x6f, 0x00, 0x01, 0x6c, 0xe2, 0xff, 0xfd,
+	0x11, 0x31, 0xf6, 0xb8, 0x6f, 0xe1, 0x00, 0x05,
+	0x0c, 0x48, 0x6f, 0xe1, 0x00, 0x06, 0x0c, 0x18,
+	0xf0, 0x30, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x03,
+	0x80, 0xe1, 0x00, 0x0b, 0x76, 0xe1, 0x00, 0x02,
+	0x00, 0x03, 0x48, 0x16, 0xf8, 0x45, 0x11, 0x33,
+	0x71, 0xe1, 0x00, 0x0c, 0x00, 0x12, 0x10, 0xe1,
+	0x00, 0x0b, 0x49, 0x12, 0xf6, 0x20, 0x88, 0x13,
+	0xe8, 0x0c, 0xf6, 0x20, 0x88, 0x10, 0xf4, 0x95,
+	0xf4, 0x95, 0xf5, 0xab, 0xf8, 0x20, 0x10, 0x27,
+	0x48, 0x13, 0x80, 0x06, 0x88, 0x10, 0xf4, 0x95,
+	0xf4, 0x95, 0xf5, 0xae, 0xf8, 0x20, 0x10, 0x30,
+	0x70, 0x06, 0x00, 0x16, 0x12, 0x06, 0xf8, 0x45,
+	0x10, 0x5f, 0x10, 0xe1, 0x00, 0x04, 0x80, 0x00,
+	0x10, 0x05, 0x80, 0x01, 0x10, 0x04, 0x80, 0x02,
+	0x10, 0x06, 0x80, 0x03, 0x48, 0x11, 0xf2, 0x74,
+	0x07, 0x1e, 0xf0, 0x00, 0x00, 0x05, 0x10, 0x06,
+	0x00, 0xe1, 0x00, 0x04, 0x80, 0xe1, 0x00, 0x04,
+	0x10, 0x06, 0x00, 0xe1, 0x00, 0x0c, 0x80, 0xe1,
+	0x00, 0x0c, 0x88, 0x12, 0x11, 0x06, 0x10, 0x04,
+	0xf6, 0x00, 0x80, 0x04, 0x48, 0x16, 0xf6, 0x20,
+	0x88, 0x16, 0xf4, 0x95, 0x77, 0x10, 0x00, 0x0c,
+	0x71, 0xe1, 0x00, 0x04, 0x00, 0x13, 0xf6, 0xab,
+	0xf8, 0x20, 0x10, 0x5f, 0x6b, 0xf8, 0x27, 0x6f,
+	0x00, 0x01, 0x77, 0x10, 0x00, 0x0c, 0xf6, 0xaa,
+	0xf8, 0x20, 0x10, 0x6b, 0xf2, 0x74, 0x0e, 0x9f,
+	0xf4, 0x95, 0x48, 0x17, 0x71, 0xe1, 0x00, 0x0c,
+	0x00, 0x12, 0x77, 0x10, 0x00, 0x0c, 0xf4, 0xaa,
+	0xf8, 0x30, 0x10, 0x7c, 0x77, 0x10, 0x00, 0x0c,
+	0x71, 0xe1, 0x00, 0x0b, 0x00, 0x13, 0xf6, 0xab,
+	0xf8, 0x30, 0x10, 0xb4, 0xe7, 0x30, 0xf7, 0xaa,
+	0xf8, 0x30, 0x10, 0xb4, 0xf2, 0x74, 0x0e, 0xc1,
+	0xf4, 0x95, 0x48, 0x17, 0x88, 0x12, 0xf4, 0x95,
+	0xf4, 0x95, 0x6c, 0x82, 0x10, 0x8d, 0x76, 0xe1,
+	0x00, 0x04, 0x00, 0x00, 0x76, 0xe1, 0x00, 0x02,
+	0x00, 0x05, 0xf0, 0x73, 0x10, 0xb4, 0x76, 0xe1,
+	0x00, 0x02, 0x00, 0x04, 0x77, 0x10, 0x00, 0x0c,
+	0x71, 0xe1, 0x00, 0x0b, 0x00, 0x12, 0xf5, 0xaa,
+	0xf8, 0x20, 0x10, 0x9a, 0xf0, 0x73, 0x10, 0x9c,
+	0x77, 0x12, 0x00, 0x0c, 0x76, 0x00, 0x00, 0x00,
+	0x70, 0x01, 0x00, 0x12, 0x70, 0x02, 0x00, 0x17,
+	0x76, 0x03, 0x00, 0x01, 0x48, 0x11, 0xf2, 0x74,
+	0x0c, 0xb9, 0xf0, 0x00, 0x00, 0x05, 0x76, 0xe1,
+	0x00, 0x04, 0x00, 0x00, 0x77, 0x10, 0x00, 0x0c,
+	0x71, 0xe1, 0x00, 0x0b, 0x00, 0x12, 0xf6, 0xaa,
+	0xf8, 0x20, 0x11, 0x1c, 0x48, 0x16, 0xf8, 0x45,
+	0x11, 0x33, 0x60, 0xe1, 0x00, 0x02, 0x00, 0x05,
+	0xf8, 0x20, 0x10, 0xdf, 0x10, 0xe1, 0x00, 0x0b,
+	0x08, 0xe1, 0x00, 0x0c, 0x11, 0xe1, 0x00, 0x04,
+	0xf8, 0x4d, 0x10, 0xc7, 0x6b, 0xf8, 0x27, 0x6f,
+	0x00, 0x01, 0x88, 0x10, 0xf4, 0x95, 0xf4, 0x95,
+	0xf5, 0xae, 0xf8, 0x20, 0x10, 0xcf, 0x48, 0x16,
+	0xf4, 0x95, 0x48, 0x08, 0xf8, 0x45, 0x11, 0x16,
+	0x6f, 0xe1, 0x00, 0x0c, 0x0d, 0x00, 0x81, 0xe1,
+	0x00, 0x0c, 0x11, 0x04, 0xf5, 0x00, 0x81, 0x04,
+	0x49, 0x16, 0xf5, 0x20, 0x89, 0x16, 0xf0, 0x73,
+	0x11, 0x0e, 0x10, 0xe1, 0x00, 0x0b, 0x71, 0xe1,
+	0x00, 0x0c, 0x00, 0x12, 0x88, 0x10, 0xf4, 0x95,
+	0xf4, 0x95, 0xf6, 0xaa, 0xf8, 0x30, 0x11, 0x16,
+	0x49, 0x12, 0xf6, 0x20, 0x88, 0x10, 0xf4, 0x95,
+	0xf4, 0x95, 0xf5, 0xae, 0xf8, 0x20, 0x10, 0xf3,
+	0x48, 0x16, 0x80, 0x06, 0x48, 0x08, 0xf8, 0x45,
+	0x11, 0x16, 0x10, 0x04, 0x70, 0x02, 0x00, 0x17,
+	0x80, 0x00, 0x76, 0x03, 0x00, 0x00, 0x10, 0x06,
+	0x80, 0x01, 0x10, 0x05, 0xf0, 0x74, 0x0c, 0xb9,
+	0x10, 0x06, 0x00, 0xe1, 0x00, 0x0c, 0x80, 0xe1,
+	0x00, 0x0c, 0x11, 0x06, 0x10, 0x04, 0xf6, 0x00,
+	0x80, 0x04, 0x48, 0x16, 0xf6, 0x20, 0x88, 0x16,
+	0x10, 0xe1, 0x00, 0x0c, 0x08, 0xe1, 0x00, 0x0b,
+	0xf8, 0x45, 0x11, 0x1c, 0xf0, 0x73, 0x11, 0x31,
+	0xf2, 0x74, 0x0e, 0x9f, 0xf4, 0x95, 0x48, 0x17,
+	0xf0, 0x73, 0x11, 0x33, 0x76, 0xe1, 0x00, 0x0c,
+	0x00, 0x00, 0x76, 0xe1, 0x00, 0x0b, 0x00, 0x00,
+	0x76, 0xe1, 0x00, 0x02, 0x00, 0x01, 0x10, 0x04,
+	0x80, 0x00, 0x10, 0x05, 0xf0, 0x74, 0x06, 0x9f,
+	0x88, 0x12, 0xf4, 0x95, 0x77, 0x10, 0x00, 0xff,
+	0xf4, 0xaa, 0xf8, 0x30, 0x11, 0x33, 0x6c, 0x86,
+	0x0f, 0x70, 0xee, 0x08, 0x8a, 0x17, 0x8a, 0x16,
+	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0xee, 0xfc,
+	0xf4, 0x95, 0x71, 0x06, 0x00, 0x12, 0x88, 0x11,
+	0x73, 0x12, 0x00, 0x0e, 0xf1, 0x66, 0x00, 0x0d,
+	0xf3, 0x00, 0x24, 0x00, 0x89, 0x14, 0x13, 0x81,
+	0xf7, 0x7a, 0xf3, 0x30, 0x00, 0x01, 0x81, 0xf8,
+	0x27, 0x60, 0x13, 0xe1, 0x00, 0x01, 0xf7, 0x7c,
+	0xf3, 0x30, 0x00, 0x03, 0x81, 0xf8, 0x27, 0x61,
+	0xe9, 0x0f, 0x19, 0xe1, 0x00, 0x01, 0x81, 0xf8,
+	0x27, 0x62, 0x71, 0xe4, 0x00, 0x03, 0x00, 0x13,
+	0xf6, 0xb8, 0x49, 0x13, 0xf3, 0x00, 0x00, 0x01,
+	0xf3, 0x30, 0x00, 0x0f, 0x49, 0x0b, 0x09, 0xf8,
+	0x27, 0x62, 0xf8, 0x4d, 0x11, 0x75, 0x77, 0x10,
+	0x00, 0xff, 0xf4, 0xab, 0xf8, 0x30, 0x11, 0x75,
+	0x57, 0xf8, 0x27, 0x6c, 0xf3, 0x00, 0x00, 0x01,
+	0x4f, 0xf8, 0x27, 0x6c, 0x76, 0xf8, 0x27, 0x63,
+	0x00, 0x01, 0xf0, 0x73, 0x11, 0x78, 0x76, 0xf8,
+	0x27, 0x63, 0x00, 0x00, 0x70, 0xe4, 0x00, 0x03,
+	0x27, 0x62, 0x76, 0xf8, 0x27, 0x64, 0x00, 0x00,
+	0x11, 0xf8, 0x27, 0x61, 0x61, 0xf8, 0x00, 0x0b,
+	0x00, 0x02, 0xf8, 0x20, 0x11, 0x8d, 0xe9, 0x01,
+	0x6f, 0xe1, 0x00, 0x02, 0x0f, 0x18, 0x81, 0xf8,
+	0x27, 0x64, 0x11, 0xf8, 0x27, 0x61, 0x61, 0xf8,
+	0x00, 0x0b, 0x00, 0x01, 0xf8, 0x20, 0x11, 0xa9,
+	0x10, 0xf8, 0x27, 0x64, 0xf1, 0x00, 0x00, 0x04,
+	0x89, 0x13, 0xe9, 0xb8, 0xf5, 0x20, 0x81, 0xf8,
+	0x27, 0x65, 0x60, 0x84, 0x00, 0x02, 0xf8, 0x20,
+	0x11, 0xa9, 0x70, 0x00, 0x00, 0x11, 0x70, 0x01,
+	0x00, 0x13, 0x70, 0x02, 0x27, 0x65, 0xf2, 0x74,
+	0x0f, 0x18, 0xf4, 0x95, 0x48, 0x12, 0xee, 0x04,
+	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0x4a, 0x16,
+	0x4a, 0x17, 0xee, 0xfc, 0xe8, 0x00, 0x4e, 0xf8,
+	0x27, 0x66, 0xe8, 0x00, 0x4e, 0xf8, 0x27, 0x68,
+	0xe8, 0x00, 0x4e, 0xf8, 0x27, 0x6c, 0xe8, 0x00,
+	0x4e, 0xf8, 0x27, 0x6a, 0x77, 0x12, 0x27, 0x40,
+	0x77, 0x11, 0x24, 0x00, 0x77, 0x1a, 0x00, 0x1f,
+	0xf0, 0x72, 0x11, 0xdb, 0x70, 0x92, 0x00, 0x11,
+	0x76, 0xe1, 0x00, 0x01, 0xff, 0xff, 0x76, 0x81,
+	0x00, 0x00, 0x76, 0xe1, 0x00, 0x02, 0x00, 0x00,
+	0x76, 0xe1, 0x00, 0x03, 0x00, 0xff, 0x76, 0xe1,
+	0x00, 0x0c, 0x00, 0x00, 0x76, 0xe1, 0x00, 0x0b,
+	0x00, 0x00, 0x76, 0xe1, 0x00, 0x04, 0x00, 0x00,
+	0x6d, 0xe9, 0x00, 0x0d, 0xf0, 0x20, 0x25, 0xa0,
+	0xf1, 0x00, 0x00, 0x07, 0x89, 0x11, 0xf1, 0x00,
+	0x00, 0x01, 0x81, 0x02, 0x88, 0x16, 0xf4, 0x95,
+	0x77, 0x17, 0x00, 0x20, 0x76, 0x86, 0x00, 0xff,
+	0x76, 0x00, 0x00, 0x00, 0x76, 0x01, 0x00, 0x06,
+	0x10, 0x02, 0xf0, 0x74, 0x06, 0x6c, 0x76, 0x00,
+	0x00, 0x00, 0x76, 0x01, 0x00, 0x06, 0xf2, 0x74,
+	0x06, 0x6c, 0xf4, 0x95, 0x48, 0x11, 0x10, 0x02,
+	0xf0, 0x00, 0x00, 0x0d, 0x80, 0x02, 0x6d, 0xe9,
+	0x00, 0x0d, 0x6d, 0xee, 0x00, 0x0d, 0x6c, 0xef,
+	0xff, 0xff, 0x11, 0xe8, 0xf0, 0x74, 0x0c, 0x9d,
+	0xee, 0x04, 0x8a, 0x17, 0x8a, 0x16, 0x8a, 0x11,
+	0xfc, 0x00, 0x4a, 0x11, 0x4a, 0x16, 0x4a, 0x17,
+	0xee, 0xfa, 0x88, 0x11, 0x10, 0x0a, 0x49, 0x11,
+	0xf8, 0x4d, 0x12, 0x9f, 0x48, 0x08, 0xf8, 0x45,
+	0x12, 0x9f, 0x80, 0x04, 0x12, 0x81, 0xf5, 0x78,
+	0x89, 0x12, 0xf4, 0x95, 0xf4, 0x95, 0x6c, 0xe2,
+	0xff, 0xb9, 0x12, 0x8a, 0x61, 0xf8, 0x00, 0x08,
+	0x00, 0x80, 0xf8, 0x30, 0x12, 0x8a, 0x13, 0xe1,
+	0x00, 0x01, 0xf0, 0xe8, 0xf7, 0x78, 0xf1, 0xa0,
+	0xf2, 0x30, 0x1f, 0xff, 0x88, 0x17, 0xf4, 0x95,
+	0x77, 0x12, 0x24, 0x00, 0x77, 0x16, 0x00, 0x00,
+	0x77, 0x13, 0x00, 0x20, 0xf6, 0xb8, 0x48, 0x17,
+	0x08, 0xe2, 0x00, 0x01, 0xf8, 0x45, 0x12, 0x42,
+	0x6d, 0xea, 0x00, 0x0d, 0x6d, 0x96, 0x6c, 0xeb,
+	0xff, 0xff, 0x12, 0x34, 0xf0, 0x73, 0x12, 0x90,
+	0x56, 0xf8, 0x27, 0x6a, 0xf0, 0x00, 0x00, 0x01,
+	0x4e, 0xf8, 0x27, 0x6a, 0x60, 0x82, 0x00, 0x01,
+	0xf8, 0x30, 0x12, 0x54, 0x70, 0x00, 0x00, 0x16,
+	0xf2, 0x74, 0x11, 0x38, 0xf4, 0x95, 0x48, 0x11,
+	0xf0, 0x73, 0x12, 0x90, 0x70, 0x00, 0x00, 0x16,
+	0xf2, 0x74, 0x11, 0x38, 0xf4, 0x95, 0x48, 0x11,
+	0x72, 0x10, 0x2a, 0x9e, 0xf4, 0x95, 0xf4, 0xaf,
+	0xf8, 0x30, 0x12, 0x6e, 0x76, 0x00, 0x00, 0x00,
+	0x76, 0x01, 0x00, 0xbc, 0x70, 0x02, 0x00, 0x16,
+	0x76, 0x03, 0x00, 0x00, 0xf2, 0x74, 0x0c, 0xb9,
+	0xf4, 0x95, 0x48, 0x11, 0xf0, 0x73, 0x12, 0x90,
+	0x10, 0xf8, 0x27, 0x6e, 0xf8, 0x44, 0x12, 0x90,
+	0x76, 0x00, 0x00, 0x00, 0x76, 0x01, 0x00, 0xbc,
+	0x70, 0x02, 0x00, 0x16, 0x76, 0x03, 0x00, 0x00,
+	0xf2, 0x74, 0x0c, 0xb9, 0xf4, 0x95, 0x48, 0x11,
+	0xf0, 0x74, 0x0c, 0x5e, 0xf0, 0xe0, 0xf0, 0x10,
+	0x13, 0x88, 0xf8, 0x42, 0x12, 0x90, 0x76, 0xf8,
+	0x27, 0x6e, 0x00, 0x01, 0xf0, 0x73, 0x12, 0x90,
+	0x56, 0xf8, 0x27, 0x66, 0xf0, 0x00, 0x00, 0x01,
+	0x4e, 0xf8, 0x27, 0x66, 0x6d, 0xe9, 0x00, 0x5e,
+	0x56, 0xf8, 0x27, 0x68, 0xf0, 0x00, 0x00, 0x01,
+	0x4e, 0xf8, 0x27, 0x68, 0x71, 0x04, 0x00, 0x12,
+	0x6e, 0xea, 0xff, 0xff, 0x12, 0x18, 0x70, 0x04,
+	0x00, 0x12, 0xee, 0x06, 0x8a, 0x17, 0x8a, 0x16,
+	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0xee, 0xfe,
+	0x88, 0x0e, 0xf4, 0x95, 0xf0, 0x66, 0x00, 0x0d,
+	0xf0, 0x00, 0x25, 0xa0, 0x88, 0x11, 0xf4, 0x95,
+	0xf4, 0x95, 0x76, 0x81, 0x00, 0xff, 0x76, 0x00,
+	0x00, 0x00, 0x76, 0x01, 0x00, 0x06, 0xf2, 0x74,
+	0x06, 0x6c, 0xf0, 0x00, 0x00, 0x01, 0x76, 0x00,
+	0x00, 0x00, 0x76, 0x01, 0x00, 0x06, 0x48, 0x11,
+	0xf2, 0x74, 0x06, 0x6c, 0xf0, 0x00, 0x00, 0x07,
+	0xee, 0x02, 0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11,
+	0x88, 0x0e, 0xf4, 0x95, 0xf0, 0x66, 0x00, 0x0d,
+	0xf0, 0x00, 0x24, 0x00, 0x88, 0x11, 0xf4, 0x95,
+	0xf4, 0x95, 0x76, 0xe1, 0x00, 0x01, 0xff, 0xff,
+	0x76, 0x81, 0x00, 0x00, 0x76, 0xe1, 0x00, 0x02,
+	0x00, 0x00, 0x76, 0xe1, 0x00, 0x03, 0x00, 0xff,
+	0x8a, 0x11, 0xfc, 0x00, 0x4a, 0x11, 0xf4, 0x95,
+	0x13, 0x03, 0x88, 0x11, 0xfa, 0x4d, 0x12, 0xec,
+	0x71, 0x02, 0x00, 0x12, 0xf3, 0x10, 0x00, 0x01,
+	0x89, 0x1a, 0xf4, 0x95, 0xf0, 0x72, 0x12, 0xeb,
+	0x70, 0x91, 0x00, 0x12, 0x8a, 0x11, 0xfc, 0x00,
+	0xf4, 0x95, 0x4a, 0x0b, 0x4a, 0x0c, 0x4a, 0x0d,
+	0xf7, 0xb8, 0xee, 0xfe, 0x10, 0xf8, 0x00, 0x08,
+	0x11, 0x06, 0xf1, 0xc0, 0x83, 0x00, 0xf4, 0x85,
+	0x11, 0x06, 0xf7, 0x85, 0x81, 0x06, 0xf6, 0xb8,
+	0xec, 0x0f, 0x1e, 0x06, 0x61, 0x00, 0x80, 0x00,
+	0xf8, 0x20, 0x13, 0x05, 0xf4, 0x84, 0xee, 0x02,
+	0x8a, 0x0d, 0x8a, 0x0c, 0x8a, 0x0b, 0xfc, 0x00,
+	0xf4, 0x95, 0x4a, 0x0b, 0x4a, 0x0c, 0x4a, 0x0d,
+	0xee, 0xfe, 0xf7, 0xb8, 0x80, 0x00, 0x10, 0xf8,
+	0x00, 0x08, 0xf4, 0x85, 0x11, 0x06, 0xf7, 0x85,
+	0x81, 0x06, 0xf6, 0xb8, 0xec, 0x0f, 0x1e, 0x06,
+	0xf0, 0xf0, 0x61, 0x00, 0x80, 0x00, 0xf8, 0x20,
+	0x13, 0x20, 0xf4, 0x84, 0xee, 0x02, 0x8a, 0x0d,
+	0x8a, 0x0c, 0x8a, 0x0b, 0xfc, 0x00, 0x4a, 0x11,
+	0x77, 0x11, 0x00, 0x7b, 0x76, 0x81, 0x2e, 0xec,
+	0x77, 0x11, 0x00, 0x7b, 0xee, 0xff, 0x71, 0x81,
+	0x00, 0x11, 0xee, 0x01, 0x76, 0xe1, 0x00, 0x01,
+	0x00, 0x00, 0x76, 0xe1, 0x00, 0x04, 0x00, 0x00,
+	0x76, 0xe1, 0x00, 0x06, 0x00, 0x00, 0x76, 0xe1,
+	0x00, 0x62, 0x00, 0x00, 0x76, 0xe1, 0x00, 0x76,
+	0x00, 0x00, 0x76, 0xe1, 0x00, 0x92, 0x00, 0x00,
+	0x76, 0xe1, 0x00, 0x94, 0x00, 0x00, 0x76, 0xe1,
+	0x00, 0xb0, 0x00, 0x00, 0x76, 0xe1, 0x00, 0xb3,
+	0x00, 0x00, 0x76, 0xe1, 0x00, 0xbe, 0x00, 0x00,
+	0x76, 0xe1, 0x00, 0xbf, 0x00, 0x00, 0x76, 0xe1,
+	0x00, 0xc1, 0x00, 0x00, 0x76, 0xe1, 0x00, 0xc3,
+	0x00, 0x00, 0x76, 0xe1, 0x00, 0xc5, 0x00, 0x00,
+	0x76, 0xe1, 0x00, 0xc7, 0x00, 0x00, 0x76, 0x81,
+	0x00, 0x00, 0x8a, 0x11, 0xf4, 0x95, 0xf4, 0xe4,
+	0x4a, 0x11, 0x4a, 0x16, 0x4a, 0x17, 0xee, 0xff,
+	0xf4, 0x95, 0x71, 0x06, 0x00, 0x16, 0xfb, 0x80,
+	0x16, 0xa2, 0x88, 0x17, 0xf4, 0x95, 0xf7, 0xb8,
+	0x10, 0xf8, 0x00, 0x17, 0xf0, 0x10, 0x00, 0x02,
+	0xfa, 0x46, 0x13, 0x88, 0x77, 0x11, 0x00, 0x00,
+	0x10, 0xf8, 0x00, 0x17, 0xf0, 0x10, 0x00, 0x02,
+	0xf8, 0x45, 0x13, 0xf9, 0x10, 0xf8, 0x00, 0x17,
+	0xf8, 0x45, 0x14, 0x39, 0x10, 0xf8, 0x00, 0x17,
+	0xf0, 0x10, 0x00, 0x01, 0xf8, 0x45, 0x14, 0x1f,
+	0xf0, 0x73, 0x14, 0x52, 0x10, 0xf8, 0x00, 0x17,
+	0xf0, 0x10, 0x00, 0x03, 0xf8, 0x45, 0x13, 0xd3,
+	0x10, 0xf8, 0x00, 0x17, 0xf0, 0x10, 0x00, 0x06,
+	0xf8, 0x44, 0x14, 0x52, 0x77, 0x12, 0x00, 0x7b,
+	0x71, 0x82, 0x00, 0x14, 0x61, 0xe4, 0x00, 0x07,
+	0x00, 0x40, 0xf8, 0x30, 0x14, 0x52, 0x49, 0x14,
+	0x48, 0x17, 0xf6, 0x00, 0x88, 0x12, 0xf4, 0x95,
+	0x77, 0x13, 0x00, 0x55, 0x77, 0x11, 0x00, 0x57,
+	0x6d, 0xea, 0x00, 0x3b, 0xe5, 0x01, 0x10, 0xe6,
+	0x00, 0x06, 0x80, 0x81, 0x48, 0x14, 0x00, 0xf8,
+	0x00, 0x17, 0x88, 0x12, 0xf4, 0x95, 0x77, 0x11,
+	0x00, 0x55, 0x10, 0xe2, 0x00, 0x40, 0x80, 0x81,
+	0x77, 0x11, 0x00, 0x57, 0x10, 0xe6, 0x00, 0x07,
+	0x80, 0x81, 0x77, 0x11, 0x00, 0x55, 0x10, 0xe2,
+	0x00, 0x45, 0x80, 0x81, 0x10, 0xe6, 0x00, 0x08,
+	0x77, 0x11, 0x00, 0x57, 0x80, 0x81, 0x77, 0x11,
+	0x00, 0x55, 0x10, 0xe2, 0x00, 0x4a, 0x80, 0x81,
+	0x77, 0x11, 0x00, 0x57, 0x10, 0xe6, 0x00, 0x09,
+	0x80, 0x81, 0xf2, 0x73, 0x14, 0x52, 0x77, 0x11,
+	0x03, 0xc0, 0x77, 0x12, 0x00, 0x7b, 0x10, 0x82,
+	0xf0, 0x00, 0x00, 0x07, 0x88, 0x13, 0xf4, 0x95,
+	0xf4, 0x95, 0x96, 0x1b, 0xf8, 0x30, 0x14, 0x52,
+	0x10, 0xe3, 0x00, 0x35, 0x77, 0x12, 0x00, 0x55,
+	0x80, 0x82, 0x77, 0x12, 0x00, 0x57, 0x10, 0xe6,
+	0x00, 0x04, 0x80, 0x82, 0x77, 0x12, 0x00, 0x55,
+	0x10, 0xe3, 0x00, 0x37, 0x80, 0x82, 0x77, 0x12,
+	0x00, 0x57, 0x10, 0xe6, 0x00, 0x05, 0x80, 0x82,
+	0x48, 0x11, 0xf0, 0x40, 0x00, 0x10, 0xf2, 0x73,
+	0x14, 0x50, 0xf0, 0x40, 0x00, 0x20, 0x77, 0x12,
+	0x00, 0x7b, 0x10, 0x82, 0xf0, 0x00, 0x00, 0x07,
+	0x88, 0x12, 0xf4, 0x95, 0xf4, 0x95, 0x96, 0x0d,
+	0xf8, 0x30, 0x14, 0x52, 0x10, 0xe2, 0x00, 0x34,
+	0x77, 0x13, 0x00, 0x55, 0x80, 0x83, 0x77, 0x13,
+	0x00, 0x57, 0x10, 0xe6, 0x00, 0x02, 0x80, 0x83,
+	0x10, 0xe2, 0x00, 0x36, 0x77, 0x12, 0x00, 0x55,
+	0x80, 0x82, 0x77, 0x12, 0x00, 0x57, 0x10, 0xe6,
+	0x00, 0x03, 0x80, 0x82, 0x48, 0x11, 0xf0, 0x40,
+	0x00, 0x04, 0xf2, 0x73, 0x14, 0x50, 0xf0, 0x40,
+	0x00, 0x08, 0x77, 0x12, 0x00, 0x7b, 0x10, 0x82,
+	0xf0, 0x00, 0x00, 0x07, 0x88, 0x12, 0xf4, 0x95,
+	0xf4, 0x95, 0x96, 0x0e, 0xf8, 0x30, 0x14, 0x52,
+	0x10, 0xe2, 0x00, 0x33, 0x77, 0x12, 0x00, 0x55,
+	0x80, 0x82, 0x77, 0x12, 0x00, 0x57, 0x10, 0xe6,
+	0x00, 0x01, 0x80, 0x82, 0x48, 0x11, 0xf2, 0x73,
+	0x14, 0x50, 0xf0, 0x40, 0x00, 0x02, 0x77, 0x12,
+	0x00, 0x7b, 0x10, 0x82, 0xf0, 0x00, 0x00, 0x07,
+	0x88, 0x12, 0xf4, 0x95, 0xf4, 0x95, 0x96, 0x0f,
+	0xf8, 0x30, 0x14, 0x52, 0x10, 0xe2, 0x00, 0x32,
+	0x77, 0x12, 0x00, 0x55, 0x77, 0x13, 0x00, 0x57,
+	0x80, 0x82, 0x48, 0x11, 0xe7, 0x62, 0xf0, 0x40,
+	0x00, 0x01, 0xe5, 0x01, 0x88, 0x11, 0xf4, 0x95,
+	0x77, 0x12, 0x00, 0x7b, 0x48, 0x11, 0x71, 0x82,
+	0x00, 0x12, 0x1a, 0xe2, 0x00, 0x07, 0x80, 0xe2,
+	0x00, 0x07, 0xf9, 0x80, 0x16, 0x9a, 0xee, 0x01,
+	0x8a, 0x17, 0x48, 0x11, 0x8a, 0x16, 0x8a, 0x11,
+	0xf4, 0xe4, 0x4a, 0x11, 0x88, 0x11, 0x77, 0x0e,
+	0x00, 0x05, 0x77, 0x12, 0x00, 0x55, 0xe8, 0x04,
+	0xf6, 0xb8, 0x28, 0xe1, 0x00, 0x02, 0xee, 0xff,
+	0x80, 0x82, 0x77, 0x12, 0x00, 0x57, 0xf0, 0x20,
+	0x80, 0x00, 0xee, 0x01, 0x1a, 0x82, 0x77, 0x12,
+	0x00, 0x57, 0x80, 0x82, 0xe8, 0x01, 0x32, 0xe1,
+	0x00, 0x02, 0xf5, 0x82, 0x77, 0x11, 0x00, 0x54,
+	0xf6, 0x93, 0x18, 0x81, 0x77, 0x11, 0x00, 0x54,
+	0xf2, 0xa0, 0x80, 0x81, 0x8a, 0x11, 0xf4, 0x95,
+	0xf4, 0xe4, 0x4a, 0x11, 0x4a, 0x16, 0xf4, 0x95,
+	0x71, 0x04, 0x00, 0x11, 0xfb, 0x80, 0x16, 0xa2,
+	0x88, 0x16, 0xf4, 0x95, 0x77, 0x12, 0x00, 0x55,
+	0x10, 0xe6, 0x00, 0x03, 0x80, 0x82, 0x77, 0x12,
+	0x00, 0x56, 0x10, 0xe1, 0x00, 0x02, 0x77, 0x13,
+	0x00, 0x56, 0x80, 0x82, 0x77, 0x12, 0x00, 0x56,
+	0x10, 0xe1, 0x00, 0x03, 0x80, 0x82, 0x10, 0xe1,
+	0x00, 0x04, 0x77, 0x12, 0x00, 0x56, 0x80, 0x82,
+	0x77, 0x12, 0x00, 0x56, 0x10, 0xe1, 0x00, 0x01,
+	0x80, 0x82, 0xe7, 0x12, 0xe5, 0x01, 0xf9, 0x80,
+	0x16, 0x9a, 0x8a, 0x16, 0x8a, 0x11, 0xf4, 0xe4,
+	0x4a, 0x11, 0x4a, 0x16, 0x4a, 0x17, 0xee, 0xf9,
+	0x77, 0x11, 0x00, 0x7b, 0x76, 0x00, 0x00, 0x16,
+	0x76, 0x01, 0x00, 0x17, 0x76, 0x02, 0x00, 0x1a,
+	0x76, 0x03, 0x00, 0x1b, 0x76, 0x04, 0x00, 0x1c,
+	0x76, 0x05, 0x00, 0x1d, 0x71, 0x81, 0x00, 0x17,
+	0x71, 0xe7, 0x00, 0x06, 0x00, 0x11, 0x10, 0x81,
+	0xf8, 0x44, 0x14, 0xdf, 0xf9, 0x80, 0x16, 0x53,
+	0xf6, 0xb8, 0xfb, 0x80, 0x15, 0x85, 0xf0, 0x20,
+	0xff, 0xff, 0xf6, 0xb8, 0xfb, 0x80, 0x16, 0x08,
+	0xf0, 0x20, 0xff, 0xff, 0x77, 0x11, 0x00, 0x7b,
+	0x71, 0x81, 0x00, 0x17, 0x76, 0xe7, 0x00, 0x06,
+	0x00, 0x01, 0x48, 0x17, 0x77, 0x16, 0x00, 0x00,
+	0x77, 0x10, 0x00, 0x04, 0x77, 0x15, 0x00, 0x03,
+	0x77, 0x14, 0x00, 0x02, 0x77, 0x13, 0x00, 0x01,
+	0xf0, 0x00, 0x00, 0x39, 0x76, 0xe7, 0x00, 0x08,
+	0x00, 0x1f, 0x76, 0xe7, 0x00, 0x07, 0x00, 0x00,
+	0x88, 0x0e, 0x77, 0x1a, 0x00, 0x05, 0x48, 0x17,
+	0xf0, 0x00, 0x00, 0x09, 0x88, 0x12, 0x48, 0x18,
+	0x88, 0x19, 0xe8, 0x00, 0xf0, 0x72, 0x15, 0x2c,
+	0x73, 0x19, 0x00, 0x11, 0x76, 0x82, 0x00, 0x00,
+	0x11, 0x91, 0x73, 0x11, 0x00, 0x19, 0x70, 0xe2,
+	0x00, 0x03, 0x00, 0x16, 0x70, 0xe2, 0x00, 0x04,
+	0x00, 0x13, 0x70, 0xe2, 0x00, 0x05, 0x00, 0x14,
+	0x81, 0xe2, 0x00, 0x01, 0x70, 0xe2, 0x00, 0x06,
+	0x00, 0x15, 0x70, 0xe2, 0x00, 0x07, 0x00, 0x10,
+	0x80, 0xe2, 0x00, 0x02, 0x73, 0x0e, 0x00, 0x11,
+	0xf1, 0x00, 0x00, 0x1e, 0x6d, 0xee, 0x00, 0x05,
+	0x6d, 0xeb, 0x00, 0x05, 0x6d, 0xec, 0x00, 0x05,
+	0x6d, 0xed, 0x00, 0x05, 0x6d, 0xe8, 0x00, 0x05,
+	0xf0, 0x00, 0x00, 0x01, 0x81, 0x91, 0x6d, 0xea,
+	0x00, 0x08, 0x73, 0x11, 0x00, 0x0e, 0xee, 0x07,
+	0x76, 0xe7, 0x00, 0x41, 0x00, 0x24, 0x76, 0xe7,
+	0x00, 0x46, 0x00, 0x25, 0x76, 0xe7, 0x00, 0x4b,
+	0x00, 0x26, 0x76, 0xe7, 0x00, 0x50, 0x00, 0x27,
+	0x8a, 0x17, 0x8a, 0x16, 0x8a, 0x11, 0xf4, 0xe4,
+	0x4a, 0x11, 0x4a, 0x16, 0xee, 0xfe, 0x88, 0x11,
+	0x56, 0x06, 0x4e, 0x00, 0xf9, 0x80, 0x16, 0xa2,
+	0xf7, 0xb8, 0x10, 0xf8, 0x00, 0x11, 0xf0, 0x10,
+	0xff, 0xff, 0xfa, 0x45, 0x15, 0x60, 0x77, 0x16,
+	0xff, 0xff, 0x77, 0x12, 0x00, 0x7b, 0x49, 0x11,
+	0x10, 0x82, 0xf6, 0x03, 0xf0, 0x00, 0x00, 0x09,
+	0x88, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x10, 0x81,
+	0xf8, 0x44, 0x15, 0x71, 0xf2, 0x73, 0x15, 0x71,
+	0xf4, 0x95, 0xe7, 0x16, 0x77, 0x11, 0x00, 0x7b,
+	0x10, 0x81, 0xf0, 0x00, 0x00, 0x09, 0x88, 0x11,
+	0xf4, 0x95, 0x77, 0x12, 0x00, 0x06, 0x10, 0x81,
+	0xf8, 0x45, 0x15, 0x5c, 0x6e, 0xea, 0xff, 0xff,
+	0x15, 0x69, 0x6d, 0xe9, 0x00, 0x08, 0x76, 0x86,
+	0x00, 0x01, 0xe9, 0x01, 0x56, 0x00, 0xf1, 0x80,
+	0x10, 0xf8, 0x00, 0x0b, 0xf8, 0x45, 0x15, 0x7e,
+	0xfb, 0x80, 0x15, 0x85, 0xf4, 0x95, 0x48, 0x16,
+	0xf9, 0x80, 0x16, 0x9a, 0xee, 0x02, 0x48, 0x16,
+	0x8a, 0x16, 0x8a, 0x11, 0xf4, 0xe4, 0x4a, 0x11,
+	0xee, 0xff, 0xfb, 0x80, 0x16, 0xa2, 0x88, 0x11,
+	0xf4, 0x95, 0x77, 0x10, 0xff, 0xff, 0xf4, 0xa9,
+	0xf8, 0x30, 0x15, 0xc4, 0x10, 0xe1, 0x00, 0x03,
+	0x77, 0x12, 0x00, 0x55, 0x80, 0x82, 0x77, 0x12,
+	0x00, 0x56, 0x76, 0x82, 0x00, 0x00, 0x77, 0x12,
+	0x00, 0x56, 0x76, 0x82, 0x00, 0x00, 0x77, 0x12,
+	0x00, 0x56, 0x76, 0x82, 0x00, 0x00, 0x77, 0x12,
+	0x00, 0x56, 0x76, 0x82, 0x00, 0x00, 0x77, 0x12,
+	0x00, 0x56, 0x76, 0x82, 0x00, 0x00, 0x10, 0xe1,
+	0x00, 0x02, 0xf0, 0x00, 0x00, 0x08, 0x32, 0xf8,
+	0x00, 0x08, 0x77, 0x12, 0x00, 0x54, 0xe8, 0x01,
+	0xf4, 0x82, 0xf4, 0x93, 0x18, 0x82, 0x77, 0x12,
+	0x00, 0x54, 0xf0, 0x40, 0x00, 0x00, 0x80, 0x82,
+	0x10, 0xe1, 0x00, 0x01, 0xf9, 0x80, 0x16, 0x76,
+	0x10, 0xe1, 0x00, 0x01, 0xf9, 0x80, 0x16, 0x66,
+	0xf0, 0x73, 0x16, 0x03, 0x77, 0x11, 0x00, 0x7b,
+	0x71, 0x81, 0x00, 0x11, 0x71, 0xe1, 0x00, 0x07,
+	0x00, 0x12, 0x76, 0x82, 0x00, 0x00, 0x10, 0xe1,
+	0x00, 0x09, 0xf9, 0x80, 0x15, 0x85, 0x77, 0x11,
+	0x00, 0x7b, 0x71, 0x81, 0x00, 0x11, 0x10, 0xe1,
+	0x00, 0x09, 0xfb, 0x80, 0x15, 0x85, 0xf0, 0x00,
+	0x00, 0x08, 0x77, 0x11, 0x00, 0x7b, 0x71, 0x81,
+	0x00, 0x11, 0x10, 0xe1, 0x00, 0x09, 0xfb, 0x80,
+	0x15, 0x85, 0xf0, 0x00, 0x00, 0x10, 0x77, 0x11,
+	0x00, 0x7b, 0x71, 0x81, 0x00, 0x11, 0x10, 0xe1,
+	0x00, 0x09, 0xfb, 0x80, 0x15, 0x85, 0xf0, 0x00,
+	0x00, 0x18, 0x77, 0x11, 0x00, 0x7b, 0x71, 0x81,
+	0x00, 0x11, 0x10, 0xe1, 0x00, 0x09, 0xfb, 0x80,
+	0x15, 0x85, 0xf0, 0x00, 0x00, 0x20, 0x77, 0x11,
+	0x00, 0x7b, 0x71, 0x81, 0x00, 0x11, 0x10, 0xe1,
+	0x00, 0x09, 0xfb, 0x80, 0x15, 0x85, 0xf0, 0x00,
+	0x00, 0x28, 0xf9, 0x80, 0x16, 0x9a, 0xee, 0x01,
+	0x8a, 0x11, 0xf4, 0xe4, 0x4a, 0x11, 0xee, 0xff,
+	0xfb, 0x80, 0x16, 0xa2, 0x88, 0x11, 0xf4, 0x95,
+	0x77, 0x10, 0xff, 0xff, 0xf4, 0xa9, 0xf8, 0x30,
+	0x16, 0x41, 0x77, 0x11, 0x00, 0x55, 0x76, 0x81,
+	0x00, 0x1e, 0x77, 0x11, 0x00, 0x56, 0x76, 0x81,
+	0x00, 0x00, 0x77, 0x11, 0x00, 0x56, 0x76, 0x81,
+	0x00, 0x00, 0x77, 0x11, 0x00, 0x56, 0x76, 0x81,
+	0x00, 0x00, 0x77, 0x11, 0x00, 0x56, 0x76, 0x81,
+	0x00, 0x00, 0x77, 0x11, 0x00, 0x56, 0x76, 0x81,
+	0x00, 0x00, 0x77, 0x11, 0x00, 0x56, 0x76, 0x81,
+	0x00, 0x00, 0x77, 0x11, 0x00, 0x56, 0x76, 0x81,
+	0x00, 0x00, 0x77, 0x11, 0x00, 0x56, 0x76, 0x81,
+	0x00, 0x00, 0x77, 0x11, 0x00, 0x56, 0x76, 0x81,
+	0x00, 0x00, 0x77, 0x11, 0x00, 0x56, 0xf2, 0x73,
+	0x16, 0x4e, 0x76, 0x81, 0x00, 0x00, 0x77, 0x11,
+	0x00, 0x7b, 0x71, 0x81, 0x00, 0x11, 0x71, 0xe1,
+	0x00, 0x07, 0x00, 0x12, 0x76, 0x82, 0x00, 0x00,
+	0x10, 0xe1, 0x00, 0x39, 0xf9, 0x80, 0x16, 0x08,
+	0xf9, 0x80, 0x16, 0x9a, 0xee, 0x01, 0x8a, 0x11,
+	0xf4, 0xe4, 0x4a, 0x11, 0x77, 0x11, 0x00, 0x7b,
+	0x10, 0x81, 0xf0, 0x00, 0x00, 0x04, 0x88, 0x11,
+	0xf4, 0x95, 0xf4, 0x95, 0x10, 0x81, 0xfa, 0x44,
+	0x16, 0x63, 0xf4, 0x95, 0xee, 0xff, 0x76, 0x81,
+	0x00, 0x01, 0xee, 0x01, 0x8a, 0x11, 0xf4, 0xe4,
+	0xf0, 0x10, 0x00, 0x10, 0x4a, 0x11, 0x32, 0xf8,
+	0x00, 0x08, 0xee, 0xff, 0x77, 0x11, 0x00, 0x01,
+	0xe8, 0x01, 0xee, 0x01, 0xf4, 0x82, 0x1a, 0x81,
+	0x80, 0x81, 0x8a, 0x11, 0xf4, 0x95, 0xf4, 0xe4,
+	0xf0, 0x10, 0x00, 0x10, 0x4a, 0x11, 0x32, 0xf8,
+	0x00, 0x08, 0xee, 0xff, 0xe8, 0x01, 0x77, 0x11,
+	0x00, 0x00, 0xf4, 0x82, 0xee, 0x01, 0xf4, 0x93,
+	0x18, 0x81, 0x80, 0x81, 0x8a, 0x11, 0xf4, 0x95,
+	0xf4, 0xe4, 0x4a, 0x11, 0xf0, 0x10, 0x00, 0x10,
+	0x77, 0x11, 0x00, 0x00, 0x32, 0xf8, 0x00, 0x08,
+	0xee, 0xff, 0x11, 0x81, 0xe8, 0x01, 0xee, 0x01,
+	0x77, 0x11, 0x00, 0x00, 0xf4, 0x82, 0xf2, 0xa0,
+	0x80, 0x81, 0x8a, 0x11, 0xf4, 0x95, 0xf4, 0xe4,
+	0xf2, 0x73, 0x16, 0x9e, 0xf6, 0xbb, 0xf4, 0x95,
+	0xf4, 0x95, 0xf4, 0x95, 0xf4, 0x95, 0xf4, 0xe4,
+	0xf2, 0x73, 0x16, 0xa6, 0xf7, 0xbb, 0xf4, 0x95,
+	0xf4, 0x95, 0xf4, 0x95, 0xf4, 0x95, 0xf4, 0xe4,
+	0x4a, 0x11, 0x4a, 0x16, 0xf4, 0x95, 0x71, 0x04,
+	0x00, 0x16, 0xfb, 0x80, 0x16, 0xa2, 0x88, 0x11,
+	0xf4, 0x95, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12,
+	0x76, 0x82, 0x00, 0x0e, 0x10, 0xe6, 0x00, 0x0e,
+	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x80, 0x82,
+	0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 0x76, 0x82,
+	0x00, 0x0d, 0x71, 0xe1, 0x00, 0x06, 0x00, 0x12,
+	0x10, 0xe6, 0x00, 0x0d, 0x80, 0x82, 0x71, 0xe1,
+	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x0c,
+	0x10, 0xe6, 0x00, 0x0c, 0x71, 0xe1, 0x00, 0x06,
+	0x00, 0x12, 0x80, 0x82, 0x71, 0xe1, 0x00, 0x05,
+	0x00, 0x12, 0x76, 0x82, 0x00, 0x0b, 0x10, 0xe6,
+	0x00, 0x0b, 0x71, 0xe1, 0x00, 0x06, 0x00, 0x12,
+	0x80, 0x82, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12,
+	0x76, 0x82, 0x00, 0x0a, 0x71, 0xe1, 0x00, 0x06,
+	0x00, 0x12, 0x10, 0xe6, 0x00, 0x0a, 0x80, 0x82,
+	0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 0x76, 0x82,
+	0x00, 0x09, 0x10, 0xe6, 0x00, 0x09, 0x71, 0xe1,
+	0x00, 0x06, 0x00, 0x12, 0x80, 0x82, 0x71, 0xe1,
+	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x08,
+	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x10, 0xe6,
+	0x00, 0x08, 0x80, 0x82, 0x71, 0xe1, 0x00, 0x05,
+	0x00, 0x12, 0x76, 0x82, 0x00, 0x07, 0x10, 0xe6,
+	0x00, 0x07, 0x71, 0xe1, 0x00, 0x06, 0x00, 0x12,
+	0x80, 0x82, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12,
+	0x76, 0x82, 0x00, 0x06, 0x71, 0xe1, 0x00, 0x06,
+	0x00, 0x12, 0x10, 0xe6, 0x00, 0x06, 0x80, 0x82,
+	0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 0x76, 0x82,
+	0x00, 0x05, 0x71, 0xe1, 0x00, 0x06, 0x00, 0x12,
+	0x10, 0xe6, 0x00, 0x05, 0x80, 0x82, 0x71, 0xe1,
+	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x04,
+	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x10, 0xe6,
+	0x00, 0x04, 0x80, 0x82, 0x71, 0xe1, 0x00, 0x05,
+	0x00, 0x12, 0x76, 0x82, 0x00, 0x03, 0x71, 0xe1,
+	0x00, 0x06, 0x00, 0x12, 0x10, 0xe6, 0x00, 0x03,
+	0x80, 0x82, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12,
+	0x76, 0x82, 0x00, 0x02, 0x10, 0xe6, 0x00, 0x02,
+	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x80, 0x82,
+	0x71, 0xe1, 0x00, 0x05, 0x00, 0x12, 0x76, 0x82,
+	0x00, 0x01, 0x10, 0xe6, 0x00, 0x01, 0x71, 0xe1,
+	0x00, 0x06, 0x00, 0x12, 0x80, 0x82, 0x71, 0xe1,
+	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x00,
+	0x71, 0xe1, 0x00, 0x06, 0x00, 0x13, 0xe7, 0x62,
+	0xe5, 0x01, 0xf9, 0x80, 0x16, 0x9a, 0x8a, 0x16,
+	0x8a, 0x11, 0xf4, 0xe4, 0x4a, 0x11, 0x88, 0x11,
+	0xf4, 0x95, 0xf4, 0x95, 0x71, 0xe1, 0x00, 0x05,
+	0x00, 0x12, 0xee, 0xff, 0x76, 0x82, 0x00, 0x00,
+	0xee, 0x01, 0x71, 0xe1, 0x00, 0x06, 0x00, 0x11,
+	0x69, 0x81, 0x00, 0x01, 0x8a, 0x11, 0xf4, 0x95,
+	0xf4, 0xe4, 0x4a, 0x11, 0x88, 0x11, 0xf4, 0x95,
+	0xf4, 0x95, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12,
+	0xee, 0xff, 0x76, 0x82, 0x00, 0x01, 0xee, 0x01,
+	0x71, 0xe1, 0x00, 0x06, 0x00, 0x11, 0x69, 0x81,
+	0x00, 0x01, 0x8a, 0x11, 0xf4, 0x95, 0xf4, 0xe4,
+	0x4a, 0x11, 0x77, 0x11, 0x00, 0x7b, 0x10, 0x81,
+	0xf0, 0x00, 0x00, 0x94, 0x88, 0x11, 0xf4, 0x95,
+	0xf4, 0x95, 0x10, 0x81, 0xfa, 0x44, 0x17, 0x9c,
+	0xf4, 0x95, 0xee, 0xff, 0xf9, 0x80, 0x16, 0x53,
+	0x77, 0x11, 0x00, 0x7b, 0x10, 0x81, 0xf0, 0x00,
+	0x00, 0x94, 0x88, 0x11, 0xf4, 0x95, 0xf4, 0x95,
+	0x76, 0x81, 0x00, 0x01, 0xee, 0x01, 0x76, 0xe1,
+	0x00, 0x01, 0x00, 0x00, 0x76, 0xe1, 0x00, 0x02,
+	0x00, 0x21, 0x76, 0xe1, 0x00, 0x03, 0x00, 0x20,
+	0x76, 0xe1, 0x00, 0x04, 0x00, 0x23, 0x76, 0xe1,
+	0x00, 0x05, 0x00, 0x22, 0x76, 0xe1, 0x00, 0x06,
+	0x00, 0x38, 0x76, 0xe1, 0x00, 0x07, 0x00, 0x39,
+	0x76, 0xe1, 0x00, 0x08, 0x00, 0x15, 0x76, 0xe1,
+	0x00, 0x09, 0x00, 0x14, 0x76, 0xe1, 0x00, 0x0a,
+	0x00, 0x00, 0x76, 0xe1, 0x00, 0x0b, 0x00, 0x41,
+	0x76, 0xe1, 0x00, 0x0c, 0x00, 0x40, 0x76, 0xe1,
+	0x00, 0x0d, 0x00, 0x43, 0x76, 0xe1, 0x00, 0x0e,
+	0x00, 0x42, 0x76, 0xe1, 0x00, 0x0f, 0x00, 0x48,
+	0x76, 0xe1, 0x00, 0x10, 0x00, 0x49, 0x76, 0xe1,
+	0x00, 0x11, 0x00, 0x1b, 0x76, 0xe1, 0x00, 0x12,
+	0x00, 0x1a, 0x8a, 0x11, 0xf4, 0x95, 0xf4, 0xe4,
+	0x4a, 0x11, 0xee, 0xfd, 0x88, 0x11, 0x56, 0x06,
+	0x4e, 0x00, 0xf9, 0x80, 0x16, 0xa2, 0x77, 0x12,
+	0x00, 0x7b, 0x77, 0x0e, 0x00, 0x09, 0x10, 0x82,
+	0x28, 0xf8, 0x00, 0x11, 0xf0, 0x00, 0x00, 0x95,
+	0x88, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x10, 0x81,
+	0xf8, 0x45, 0x17, 0xf0, 0xf2, 0x73, 0x17, 0xfd,
+	0x77, 0x11, 0xff, 0xff, 0x76, 0x81, 0x00, 0x01,
+	0xe9, 0x01, 0x56, 0x00, 0xf1, 0x80, 0x10, 0xf8,
+	0x00, 0x0b, 0xf8, 0x45, 0x17, 0xfd, 0xfb, 0x80,
+	0x18, 0x10, 0xf4, 0x95, 0x48, 0x11, 0xf9, 0x80,
+	0x16, 0x9a, 0xee, 0x03, 0x48, 0x11, 0x8a, 0x11,
+	0xf4, 0x95, 0xf4, 0xe4, 0x4a, 0x11, 0x88, 0x11,
+	0xf4, 0x95, 0xee, 0xff, 0x71, 0xe1, 0x00, 0x01,
+	0x00, 0x11, 0xee, 0x01, 0x10, 0x81, 0x8a, 0x11,
+	0xf4, 0x95, 0xf4, 0xe4, 0x4a, 0x11, 0xee, 0xff,
+	0xfb, 0x80, 0x16, 0xa2, 0x88, 0x11, 0xf4, 0x95,
+	0x77, 0x10, 0xff, 0xff, 0xf4, 0xa9, 0xf8, 0x30,
+	0x18, 0xc3, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12,
+	0x76, 0x82, 0x00, 0x00, 0x71, 0xe1, 0x00, 0x06,
+	0x00, 0x12, 0x76, 0x82, 0x00, 0x00, 0x71, 0xe1,
+	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x01,
+	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x76, 0x82,
+	0x00, 0x00, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12,
+	0x76, 0x82, 0x00, 0x02, 0x71, 0xe1, 0x00, 0x06,
+	0x00, 0x12, 0x76, 0x82, 0x00, 0x00, 0x71, 0xe1,
+	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x03,
+	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x76, 0x82,
+	0x00, 0x00, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12,
+	0x76, 0x82, 0x00, 0x04, 0x71, 0xe1, 0x00, 0x06,
+	0x00, 0x12, 0x76, 0x82, 0x00, 0x00, 0x71, 0xe1,
+	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x05,
+	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x76, 0x82,
+	0x00, 0x00, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12,
+	0x76, 0x82, 0x00, 0x06, 0x71, 0xe1, 0x00, 0x06,
+	0x00, 0x12, 0x76, 0x82, 0x00, 0x01, 0x71, 0xe1,
+	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x07,
+	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x76, 0x82,
+	0x20, 0x00, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12,
+	0x76, 0x82, 0x00, 0x08, 0x71, 0xe1, 0x00, 0x06,
+	0x00, 0x12, 0x76, 0x82, 0x00, 0x00, 0x71, 0xe1,
+	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x09,
+	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x76, 0x82,
+	0x00, 0x00, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12,
+	0x76, 0x82, 0x00, 0x0a, 0x71, 0xe1, 0x00, 0x06,
+	0x00, 0x12, 0x76, 0x82, 0x00, 0x00, 0x71, 0xe1,
+	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x0b,
+	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x76, 0x82,
+	0x00, 0x00, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12,
+	0x76, 0x82, 0x00, 0x0c, 0x71, 0xe1, 0x00, 0x06,
+	0x00, 0x12, 0x76, 0x82, 0x00, 0x00, 0x71, 0xe1,
+	0x00, 0x05, 0x00, 0x12, 0x76, 0x82, 0x00, 0x0d,
+	0x71, 0xe1, 0x00, 0x06, 0x00, 0x12, 0x76, 0x82,
+	0x00, 0x00, 0x71, 0xe1, 0x00, 0x05, 0x00, 0x12,
+	0x76, 0x82, 0x00, 0x0e, 0x71, 0xe1, 0x00, 0x06,
+	0x00, 0x12, 0x76, 0x82, 0x00, 0x00, 0x10, 0xe1,
+	0x00, 0x07, 0xf9, 0x80, 0x16, 0x76, 0x10, 0xe1,
+	0x00, 0x08, 0xf9, 0x80, 0x16, 0x76, 0x10, 0xe1,
+	0x00, 0x07, 0xf9, 0x80, 0x16, 0x66, 0x10, 0xe1,
+	0x00, 0x08, 0xf9, 0x80, 0x16, 0x66, 0xf0, 0x73,
+	0x18, 0xd1, 0x77, 0x11, 0x00, 0x7b, 0x10, 0x81,
+	0xfb, 0x80, 0x18, 0x10, 0xf0, 0x00, 0x00, 0x95,
+	0x77, 0x11, 0x00, 0x7b, 0x10, 0x81, 0xfb, 0x80,
+	0x18, 0x10, 0xf0, 0x00, 0x00, 0x9e, 0xf9, 0x80,
+	0x16, 0x9a, 0xee, 0x01, 0x8a, 0x11, 0xf4, 0xe4,
+	0x4a, 0x11, 0x88, 0x11, 0xee, 0xff, 0xf4, 0x95,
+	0x10, 0x04, 0x71, 0xe1, 0x00, 0x03, 0x00, 0x11,
+	0xee, 0x01, 0x80, 0x81, 0x8a, 0x11, 0xf4, 0x95,
+	0xf4, 0xe4, 0x4a, 0x11, 0x4a, 0x16, 0xf4, 0x95,
+	0x71, 0x04, 0x00, 0x16, 0xfb, 0x80, 0x16, 0xa2,
+	0x88, 0x11, 0xf4, 0x95, 0x71, 0xe1, 0x00, 0x02,
+	0x00, 0x12, 0x76, 0x82, 0x00, 0x10, 0x10, 0xe6,
+	0x00, 0x01, 0x71, 0xe1, 0x00, 0x03, 0x00, 0x12,
+	0x80, 0x82, 0x71, 0xe1, 0x00, 0x04, 0x00, 0x12,
+	0x10, 0xe6, 0x00, 0x02, 0x80, 0x82, 0xe7, 0x62,
+	0x71, 0xe1, 0x00, 0x02, 0x00, 0x13, 0xe5, 0x01,
+	0xf9, 0x80, 0x16, 0x9a, 0x8a, 0x16, 0x8a, 0x11,
+	0xf4, 0xe4, 0x4a, 0x11, 0x88, 0x11, 0xee, 0xff,
+	0xee, 0x01, 0x10, 0xe1, 0x00, 0x01, 0x8a, 0x11,
+	0xf4, 0x95, 0xf4, 0xe4, 0x4a, 0x11, 0x77, 0x11,
+	0x00, 0x7b, 0x10, 0x81, 0xf0, 0x00, 0x00, 0xb3,
+	0x88, 0x11, 0xf4, 0x95, 0xf4, 0x95, 0x10, 0x81,
+	0xfa, 0x44, 0x19, 0x2a, 0xf4, 0x95, 0xee, 0xff,
+	0xf9, 0x80, 0x16, 0x53, 0x77, 0x11, 0x00, 0x7b,
+	0x10, 0x81, 0xf0, 0x00, 0x00, 0xb3, 0x88, 0x11,
+	0xf4, 0x95, 0xf4, 0x95, 0x76, 0x81, 0x00, 0x01,
+	0xee, 0x01, 0x76, 0xe1, 0x00, 0x01, 0x00, 0x00,
+	0x76, 0xe1, 0x00, 0x02, 0x00, 0x13, 0x76, 0xe1,
+	0x00, 0x03, 0x00, 0x26, 0x76, 0xe1, 0x00, 0x04,
+	0x00, 0x25, 0x76, 0xe1, 0x00, 0x05, 0x00, 0x24,
+	0x76, 0xe1, 0x00, 0x06, 0x00, 0x00, 0x76, 0xe1,
+	0x00, 0x07, 0x00, 0x17, 0x76, 0xe1, 0x00, 0x08,
+	0x00, 0x32, 0x76, 0xe1, 0x00, 0x09, 0x00, 0x31,
+	0x76, 0xe1, 0x00, 0x0a, 0x00, 0x30, 0x8a, 0x11,
+	0xf4, 0x95, 0xf4, 0xe4, 0x4a, 0x11, 0x4a, 0x16,
+	0x4a, 0x17, 0xee, 0xff, 0xf4, 0x95, 0x71, 0x06,
+	0x00, 0x17, 0xfb, 0x80, 0x16, 0xa2, 0x88, 0x11,
+	0xf4, 0x95, 0xf7, 0xb8, 0x10, 0xf8, 0x00, 0x11,
+	0xf0, 0x10, 0xff, 0xff, 0xfa, 0x45, 0x19, 0x73,
+	0x77, 0x16, 0xff, 0xff, 0x77, 0x12, 0x00, 0x7b,
+	0x77, 0x0e, 0x00, 0x05, 0x10, 0x82, 0x28, 0xf8,
+	0x00, 0x11, 0xf0, 0x00, 0x00, 0xb4, 0x88, 0x11,
+	0xf4, 0x95, 0xf4, 0x95, 0x10, 0x81, 0xf8, 0x44,
+	0x19, 0x84, 0xf2, 0x73, 0x19, 0x84, 0xf4, 0x95,
+	0xe7, 0x16, 0x77, 0x11, 0x00, 0x7b, 0x10, 0x81,
+	0xf0, 0x00, 0x00, 0xb4, 0x88, 0x11, 0xf4, 0x95,
+	0x77, 0x12, 0x00, 0x02, 0x10, 0x81, 0xf8, 0x45,
+	0x19, 0x6f, 0x6e, 0xea, 0xff, 0xff, 0x19, 0x7c,
+	0x6d, 0xe9, 0x00, 0x05, 0x61, 0xf8, 0x00, 0x17,
+	0x00, 0x01, 0xfa, 0x20, 0x19, 0x8f, 0x76, 0x86,
+	0x00, 0x01, 0xfb, 0x80, 0x19, 0x97, 0xf4, 0x95,
+	0x48, 0x16, 0xf9, 0x80, 0x16, 0x9a, 0xee, 0x01,
+	0x8a, 0x17, 0x48, 0x16, 0x8a, 0x16, 0x8a, 0x11,
+	0xf4, 0xe4, 0x4a, 0x11, 0xee, 0xff, 0xfb, 0x80,
+	0x16, 0xa2, 0x88, 0x11, 0xf4, 0x95, 0x77, 0x10,
+	0xff, 0xff, 0xf4, 0xa9, 0xf8, 0x30, 0x19, 0xcc,
+	0x71, 0xe1, 0x00, 0x02, 0x00, 0x12, 0x69, 0x82,
+	0x00, 0x10, 0x71, 0xe1, 0x00, 0x02, 0x00, 0x12,
+	0x68, 0x82, 0xf7, 0xff, 0x71, 0xe1, 0x00, 0x02,
+	0x00, 0x12, 0x68, 0x82, 0xfb, 0xff, 0x71, 0xe1,
+	0x00, 0x02, 0x00, 0x12, 0x68, 0x82, 0xff, 0xf0,
+	0x71, 0xe1, 0x00, 0x03, 0x00, 0x12, 0x76, 0x82,
+	0xff, 0xff, 0x71, 0xe1, 0x00, 0x04, 0x00, 0x12,
+	0x76, 0x82, 0xff, 0xff, 0x71, 0xe1, 0x00, 0x02,
+	0x00, 0x12, 0x69, 0x82, 0x00, 0x20, 0x71, 0xe1,
+	0x00, 0x02, 0x00, 0x11, 0xf2, 0x73, 0x19, 0xda,
+	0x68, 0x81, 0xff, 0xef, 0x77, 0x11, 0x00, 0x7b,
+	0x10, 0x81, 0xfb, 0x80, 0x19, 0x97, 0xf0, 0x00,
+	0x00, 0xb4, 0x77, 0x11, 0x00, 0x7b, 0x10, 0x81,
+	0xfb, 0x80, 0x19, 0x97, 0xf0, 0x00, 0x00, 0xb9,
+	0xf9, 0x80, 0x16, 0x9a, 0xee, 0x01, 0x8a, 0x11,
+	0xf4, 0xe4, 0x00, 0xa4, 0x00, 0x00, 0x19, 0xdf,
+	0x00, 0x01, 0x2a, 0xe6, 0x00, 0x00, 0x00, 0x01,
+	0x2a, 0xe7, 0x00, 0x00, 0x00, 0x03, 0x2a, 0x12,
+	0x0c, 0x01, 0xc3, 0x4f, 0x00, 0x00, 0x00, 0x01,
+	0x2a, 0x15, 0x00, 0x00, 0x00, 0x02, 0x2a, 0x16,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x2a, 0x5d,
+	0x00, 0x43, 0x00, 0x6f, 0x00, 0x70, 0x00, 0x79,
+	0x00, 0x72, 0x00, 0x69, 0x00, 0x67, 0x00, 0x68,
+	0x00, 0x74, 0x00, 0x20, 0x00, 0x54, 0x00, 0x65,
+	0x00, 0x63, 0x00, 0x68, 0x00, 0x6e, 0x00, 0x6f,
+	0x00, 0x54, 0x00, 0x72, 0x00, 0x65, 0x00, 0x6e,
+	0x00, 0x64, 0x00, 0x20, 0x00, 0x41, 0x00, 0x47,
+	0x00, 0x00, 0x00, 0x04, 0x2a, 0x76, 0x00, 0x30,
+	0x00, 0x2e, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0c,
+	0x2a, 0x7a, 0x00, 0x46, 0x00, 0x65, 0x00, 0x62,
+	0x00, 0x20, 0x00, 0x32, 0x00, 0x37, 0x00, 0x20,
+	0x00, 0x32, 0x00, 0x30, 0x00, 0x30, 0x00, 0x31,
+	0x00, 0x00, 0x00, 0x09, 0x2a, 0x86, 0x00, 0x31,
+	0x00, 0x34, 0x00, 0x3a, 0x00, 0x33, 0x00, 0x35,
+	0x00, 0x3a, 0x00, 0x33, 0x00, 0x33, 0x00, 0x00,
+	0x00, 0x0f, 0x2a, 0x8f, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x01, 0x2a, 0x9e, 0x00, 0x00,
+	0x00, 0x01, 0x2a, 0x9f, 0x00, 0x00, 0x00, 0x01,
+	0x2a, 0xa0, 0x00, 0x00, 0x00, 0x01, 0x2a, 0xa1,
+	0x00, 0x00, 0x00, 0x01, 0x2a, 0xa2, 0x00, 0x00,
+	0x00, 0x01, 0x29, 0x7e, 0x00, 0x00, 0x00, 0x02,
+	0x29, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
+	0x29, 0x82, 0xff, 0xff, 0x00, 0x01, 0x2a, 0xa7,
+	0x00, 0x00, 0x00, 0x05, 0x2a, 0xa8, 0x71, 0x41,
+	0x20, 0x00, 0x20, 0x00, 0x00, 0x23, 0x04, 0x00,
+	0x00, 0x0a, 0x2a, 0xad, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x0f, 0x2a, 0xb7, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x40, 0x00, 0xa0, 0x82, 0x40,
+	0x00, 0x08, 0x30, 0x7f, 0x00, 0x80, 0x01, 0x80,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x01, 0x27, 0x6e, 0x00, 0x00,
+	0x00, 0x01, 0x27, 0x6f, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x09, 0x00, 0x00, 0x1a, 0x83, 0x04, 0xe8,
+	0x04, 0xcf, 0x04, 0xc5, 0x04, 0xba, 0x04, 0xb0,
+	0x04, 0xac, 0x04, 0x9c, 0x04, 0x8c, 0x04, 0x81,
+	0x00, 0x78, 0x00, 0x00, 0x01, 0x00, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xaa, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x02, 0x23, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x05, 0xe5, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x02, 0xb5, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x0e, 0x33, 0xf4, 0x95, 0xf4, 0x95, 0xf2, 0x73,
+	0x07, 0xef, 0xf4, 0x95, 0xf4, 0x95, 0x00, 0x00,
 };
 
diff -urN linux-2.6.15-rc5/drivers/media/dvb/ttusb-dec/ttusb_dec.c linux-2.6.15-rc6/drivers/media/dvb/ttusb-dec/ttusb_dec.c
--- linux-2.6.15-rc5/drivers/media/dvb/ttusb-dec/ttusb_dec.c	2005-12-18 22:27:55.072629991 -0800
+++ linux-2.6.15-rc6/drivers/media/dvb/ttusb-dec/ttusb_dec.c	2005-12-18 22:28:03.941025125 -0800
@@ -1203,7 +1203,7 @@
 	input_dev->keycode = rc_keys;
 
 	for (i = 0; i < ARRAY_SIZE(rc_keys); i++)
-                set_bit(rc_keys[i], input_dev->keybit);
+		set_bit(rc_keys[i], input_dev->keybit);
 
 	input_register_device(input_dev);
 
@@ -1529,7 +1529,7 @@
 	usb_free_urb(dec->irq_urb);
 
 	usb_buffer_free(dec->udev,IRQ_PACKET_SIZE,
-		           dec->irq_buffer, dec->irq_dma_handle);
+			   dec->irq_buffer, dec->irq_dma_handle);
 
 	if (dec->rc_input_dev) {
 		input_unregister_device(dec->rc_input_dev);
diff -urN linux-2.6.15-rc5/drivers/media/video/Kconfig linux-2.6.15-rc6/drivers/media/video/Kconfig
--- linux-2.6.15-rc5/drivers/media/video/Kconfig	2005-12-18 22:27:55.073630036 -0800
+++ linux-2.6.15-rc6/drivers/media/video/Kconfig	2005-12-18 22:28:03.942025169 -0800
@@ -188,7 +188,7 @@
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called zr36067.
- 
+
 config VIDEO_ZORAN_BUZ
 	tristate "Iomega Buz support"
 	depends on VIDEO_ZORAN
@@ -204,8 +204,8 @@
 
 config VIDEO_ZORAN_DC30
 	tristate "Pinnacle/Miro DC30(+) support"
- 	depends on VIDEO_ZORAN
- 	help
+	depends on VIDEO_ZORAN
+	help
 	  Support for the Pinnacle/Miro DC30(+) MJPEG capture/playback
 	  card. This also supports really old DC10 cards based on the
 	  zr36050 MJPEG codec and zr36016 VFE.
@@ -260,7 +260,7 @@
 	---help---
 	  This is a video4linux driver for the 'Multimedia eXtension Board'
 	  TV card by Siemens-Nixdorf.
-	  
+
 	  To compile this driver as a module, choose M here: the
 	  module will be called mxb.
 
@@ -274,7 +274,7 @@
 	  for SAA7146 bases boards, so if you have some unsupported
 	  saa7146 based, analog video card, chances are good that it
 	  will work with this skeleton driver.
-	  
+
 	  To compile this driver as a module, choose M here: the
 	  module will be called dpc7146.
 
@@ -285,7 +285,7 @@
 	---help---
 	  This is a video4linux driver for the Hexium HV-PCI6 and
 	  Orion frame grabber cards by Hexium.
-	  
+
 	  To compile this driver as a module, choose M here: the
 	  module will be called hexium_orion.
 
@@ -297,7 +297,7 @@
 	  This is a video4linux driver for the Hexium Gemini frame
 	  grabber card by Hexium. Please note that the Gemini Dual
 	  card is *not* fully supported.
-	  
+
 	  To compile this driver as a module, choose M here: the
 	  module will be called hexium_gemini.
 
diff -urN linux-2.6.15-rc5/drivers/media/video/bt832.c linux-2.6.15-rc6/drivers/media/video/bt832.c
--- linux-2.6.15-rc5/drivers/media/video/bt832.c	2005-12-18 22:27:55.074630080 -0800
+++ linux-2.6.15-rc6/drivers/media/video/bt832.c	2005-12-18 22:28:03.943025214 -0800
@@ -231,18 +231,18 @@
 
 static struct i2c_driver driver = {
 	.owner          = THIS_MODULE,
-        .name           = "i2c bt832 driver",
-        .id             = -1, /* FIXME */
-        .flags          = I2C_DF_NOTIFY,
-        .attach_adapter = bt832_probe,
-        .detach_client  = bt832_detach,
-        .command        = bt832_command,
+	.name           = "i2c bt832 driver",
+	.id             = -1, /* FIXME */
+	.flags          = I2C_DF_NOTIFY,
+	.attach_adapter = bt832_probe,
+	.detach_client  = bt832_detach,
+	.command        = bt832_command,
 };
 static struct i2c_client client_template =
 {
 	.name       = "bt832",
 	.flags      = I2C_CLIENT_ALLOW_USE,
-        .driver     = &driver,
+	.driver     = &driver,
 };
 
 
diff -urN linux-2.6.15-rc5/drivers/media/video/bttv-driver.c linux-2.6.15-rc6/drivers/media/video/bttv-driver.c
--- linux-2.6.15-rc5/drivers/media/video/bttv-driver.c	2005-12-18 22:27:55.089630749 -0800
+++ linux-2.6.15-rc6/drivers/media/video/bttv-driver.c	2005-12-18 22:28:03.958025882 -0800
@@ -727,71 +727,71 @@
 
 static void set_pll_freq(struct bttv *btv, unsigned int fin, unsigned int fout)
 {
-        unsigned char fl, fh, fi;
+	unsigned char fl, fh, fi;
 
-        /* prevent overflows */
-        fin/=4;
-        fout/=4;
+	/* prevent overflows */
+	fin/=4;
+	fout/=4;
 
-        fout*=12;
-        fi=fout/fin;
+	fout*=12;
+	fi=fout/fin;
 
-        fout=(fout%fin)*256;
-        fh=fout/fin;
+	fout=(fout%fin)*256;
+	fh=fout/fin;
 
-        fout=(fout%fin)*256;
-        fl=fout/fin;
+	fout=(fout%fin)*256;
+	fl=fout/fin;
 
-        btwrite(fl, BT848_PLL_F_LO);
-        btwrite(fh, BT848_PLL_F_HI);
-        btwrite(fi|BT848_PLL_X, BT848_PLL_XCI);
+	btwrite(fl, BT848_PLL_F_LO);
+	btwrite(fh, BT848_PLL_F_HI);
+	btwrite(fi|BT848_PLL_X, BT848_PLL_XCI);
 }
 
 static void set_pll(struct bttv *btv)
 {
-        int i;
+	int i;
 
-        if (!btv->pll.pll_crystal)
-                return;
+	if (!btv->pll.pll_crystal)
+		return;
 
 	if (btv->pll.pll_ofreq == btv->pll.pll_current) {
 		dprintk("bttv%d: PLL: no change required\n",btv->c.nr);
-                return;
-        }
+		return;
+	}
 
-        if (btv->pll.pll_ifreq == btv->pll.pll_ofreq) {
-                /* no PLL needed */
-                if (btv->pll.pll_current == 0)
-                        return;
+	if (btv->pll.pll_ifreq == btv->pll.pll_ofreq) {
+		/* no PLL needed */
+		if (btv->pll.pll_current == 0)
+			return;
 		bttv_printk(KERN_INFO "bttv%d: PLL can sleep, using XTAL (%d).\n",
-                           btv->c.nr,btv->pll.pll_ifreq);
-                btwrite(0x00,BT848_TGCTRL);
-                btwrite(0x00,BT848_PLL_XCI);
-                btv->pll.pll_current = 0;
-                return;
-        }
+			btv->c.nr,btv->pll.pll_ifreq);
+		btwrite(0x00,BT848_TGCTRL);
+		btwrite(0x00,BT848_PLL_XCI);
+		btv->pll.pll_current = 0;
+		return;
+	}
 
 	bttv_printk(KERN_INFO "bttv%d: PLL: %d => %d ",btv->c.nr,
-                   btv->pll.pll_ifreq, btv->pll.pll_ofreq);
+		btv->pll.pll_ifreq, btv->pll.pll_ofreq);
 	set_pll_freq(btv, btv->pll.pll_ifreq, btv->pll.pll_ofreq);
 
-        for (i=0; i<10; i++) {
+	for (i=0; i<10; i++) {
 		/*  Let other people run while the PLL stabilizes */
 		bttv_printk(".");
 		msleep(10);
 
-                if (btread(BT848_DSTATUS) & BT848_DSTATUS_PLOCK) {
+		if (btread(BT848_DSTATUS) & BT848_DSTATUS_PLOCK) {
 			btwrite(0,BT848_DSTATUS);
-                } else {
-                        btwrite(0x08,BT848_TGCTRL);
-                        btv->pll.pll_current = btv->pll.pll_ofreq;
+		} else {
+			btwrite(0x08,BT848_TGCTRL);
+			btv->pll.pll_current = btv->pll.pll_ofreq;
 			bttv_printk(" ok\n");
-                        return;
-                }
-        }
-        btv->pll.pll_current = -1;
+			return;
+		}
+	}
+	btv->pll.pll_current = -1;
 	bttv_printk("failed\n");
-        return;
+	return;
 }
 
 /* used to switch between the bt848's analog/digital video capture modes */
@@ -1964,7 +1964,7 @@
 	}
 
 	down(&fh->cap.lock);
-	kfree(fh->ov.clips);
+		kfree(fh->ov.clips);
 	fh->ov.clips    = clips;
 	fh->ov.nclips   = n;
 
@@ -2758,7 +2758,7 @@
 			fh->ov.w.height = fb->fmt.height;
 			btv->init.ov.w.width  = fb->fmt.width;
 			btv->init.ov.w.height = fb->fmt.height;
-			kfree(fh->ov.clips);
+				kfree(fh->ov.clips);
 			fh->ov.clips = NULL;
 			fh->ov.nclips = 0;
 
diff -urN linux-2.6.15-rc5/drivers/media/video/bttvp.h linux-2.6.15-rc6/drivers/media/video/bttvp.h
--- linux-2.6.15-rc5/drivers/media/video/bttvp.h	2005-12-18 22:27:55.092630882 -0800
+++ linux-2.6.15-rc6/drivers/media/video/bttvp.h	2005-12-18 22:28:03.961026016 -0800
@@ -45,6 +45,7 @@
 #include <media/tveeprom.h>
 #include <media/ir-common.h>
 
+
 #include "bt848.h"
 #include "bttv.h"
 #include "btcx-risc.h"
diff -urN linux-2.6.15-rc5/drivers/media/video/cx88/cx88-blackbird.c linux-2.6.15-rc6/drivers/media/video/cx88/cx88-blackbird.c
--- linux-2.6.15-rc5/drivers/media/video/cx88/cx88-blackbird.c	2005-12-18 22:27:55.099631194 -0800
+++ linux-2.6.15-rc6/drivers/media/video/cx88/cx88-blackbird.c	2005-12-18 22:28:03.968026328 -0800
@@ -616,6 +616,8 @@
 
 	retval = request_firmware(&firmware, BLACKBIRD_FIRM_ENC_FILENAME,
 				  &dev->pci->dev);
+
+
 	if (retval != 0) {
 		dprintk(0, "ERROR: Hotplug firmware request failed (%s).\n",
 			BLACKBIRD_FIRM_ENC_FILENAME);
diff -urN linux-2.6.15-rc5/drivers/media/video/cx88/cx88-cards.c linux-2.6.15-rc6/drivers/media/video/cx88/cx88-cards.c
--- linux-2.6.15-rc5/drivers/media/video/cx88/cx88-cards.c	2005-12-18 22:27:55.101631283 -0800
+++ linux-2.6.15-rc6/drivers/media/video/cx88/cx88-cards.c	2005-12-18 22:28:03.969026372 -0800
@@ -567,6 +567,7 @@
 		.radio_type     = UNSET,
 		.tuner_addr	= ADDR_UNSET,
 		.radio_addr	= ADDR_UNSET,
+		.tda9887_conf   = TDA9887_PRESENT,
 		.input          = {{
 			.type   = CX88_VMUX_TELEVISION,
 			.vmux   = 0,
@@ -711,6 +712,7 @@
 		.radio_type     = UNSET,
 		.tuner_addr	= ADDR_UNSET,
 		.radio_addr	= ADDR_UNSET,
+		.tda9887_conf   = TDA9887_PRESENT,
 		.input          = {{
 			.type   = CX88_VMUX_TELEVISION,
 			.vmux   = 0,
diff -urN linux-2.6.15-rc5/drivers/media/video/cx88/cx88-input.c linux-2.6.15-rc6/drivers/media/video/cx88/cx88-input.c
--- linux-2.6.15-rc5/drivers/media/video/cx88/cx88-input.c	2005-12-18 22:27:55.104631417 -0800
+++ linux-2.6.15-rc6/drivers/media/video/cx88/cx88-input.c	2005-12-18 22:28:03.972026506 -0800
@@ -453,7 +453,6 @@
 		input_dev->id.product = pci->device;
 	}
 	input_dev->cdev.dev = &pci->dev;
-
 	/* record handles to ourself */
 	ir->core = core;
 	core->ir = ir;
@@ -586,7 +585,6 @@
 MODULE_AUTHOR("Gerd Knorr, Pavel Machek, Chris Pascoe");
 MODULE_DESCRIPTION("input driver for cx88 GPIO-based IR remote controls");
 MODULE_LICENSE("GPL");
-
 /*
  * Local variables:
  * c-basic-offset: 8
diff -urN linux-2.6.15-rc5/drivers/media/video/cx88/cx88.h linux-2.6.15-rc6/drivers/media/video/cx88/cx88.h
--- linux-2.6.15-rc5/drivers/media/video/cx88/cx88.h	2005-12-18 22:27:55.109631640 -0800
+++ linux-2.6.15-rc6/drivers/media/video/cx88/cx88.h	2005-12-18 22:28:03.978026773 -0800
@@ -411,7 +411,6 @@
 	struct videobuf_dvb        dvb;
 	void*                      fe_handle;
 	int                        (*fe_release)(void *handle);
-
 	/* for switching modulation types */
 	unsigned char              ts_gen_cntrl;
 
diff -urN linux-2.6.15-rc5/drivers/media/video/em28xx/em28xx-core.c linux-2.6.15-rc6/drivers/media/video/em28xx/em28xx-core.c
--- linux-2.6.15-rc5/drivers/media/video/em28xx/em28xx-core.c	2005-12-18 22:27:55.111631729 -0800
+++ linux-2.6.15-rc6/drivers/media/video/em28xx/em28xx-core.c	2005-12-18 22:28:03.981026907 -0800
@@ -39,7 +39,7 @@
 #define em28xx_coredbg(fmt, arg...) do {\
 	if (core_debug) \
 		printk(KERN_INFO "%s %s :"fmt, \
-			 dev->name, __FUNCTION__ , ##arg); } while (0)
+			 dev->name, __FUNCTION__, ##arg); } while (0)
 
 static unsigned int reg_debug;
 module_param(reg_debug,int,0644);
@@ -48,7 +48,7 @@
 #define em28xx_regdbg(fmt, arg...) do {\
 	if (reg_debug) \
 		printk(KERN_INFO "%s %s :"fmt, \
-			 dev->name, __FUNCTION__ , ##arg); } while (0)
+			 dev->name, __FUNCTION__, ##arg); } while (0)
 
 static unsigned int isoc_debug;
 module_param(isoc_debug,int,0644);
@@ -57,7 +57,7 @@
 #define em28xx_isocdbg(fmt, arg...) do {\
 	if (isoc_debug) \
 		printk(KERN_INFO "%s %s :"fmt, \
-			 dev->name, __FUNCTION__ , ##arg); } while (0)
+			 dev->name, __FUNCTION__, ##arg); } while (0)
 
 static int alt = EM28XX_PINOUT;
 module_param(alt, int, 0644);
@@ -116,47 +116,6 @@
 	}
 }
 
-static void *rvmalloc(size_t size)
-{
-	void *mem;
-	unsigned long adr;
-
-	size = PAGE_ALIGN(size);
-
-	mem = vmalloc_32((unsigned long)size);
-	if (!mem)
-		return NULL;
-
-	memset(mem, 0, size);
-
-	adr = (unsigned long)mem;
-	while (size > 0) {
-		SetPageReserved(vmalloc_to_page((void *)adr));
-		adr += PAGE_SIZE;
-		size -= PAGE_SIZE;
-	}
-
-	return mem;
-}
-
-static void rvfree(void *mem, size_t size)
-{
-	unsigned long adr;
-
-	if (!mem)
-		return;
-
-	size = PAGE_ALIGN(size);
-
-	adr = (unsigned long)mem;
-	while (size > 0) {
-		ClearPageReserved(vmalloc_to_page((void *)adr));
-		adr += PAGE_SIZE;
-		size -= PAGE_SIZE;
-	}
-
-	vfree(mem);
-}
 
 /*
  * em28xx_request_buffers()
@@ -167,14 +126,16 @@
 	const size_t imagesize = PAGE_ALIGN(dev->frame_size);	/*needs to be page aligned cause the buffers can be mapped individually! */
 	void *buff = NULL;
 	u32 i;
-	em28xx_coredbg("requested %i buffers with size %i", count, imagesize);
+	em28xx_coredbg("requested %i buffers with size %zd", count, imagesize);
 	if (count > EM28XX_NUM_FRAMES)
 		count = EM28XX_NUM_FRAMES;
 
 	dev->num_frames = count;
 	while (dev->num_frames > 0) {
-		if ((buff = rvmalloc(dev->num_frames * imagesize)))
+		if ((buff = vmalloc_32(dev->num_frames * imagesize))) {
+			memset(buff, 0, dev->num_frames * imagesize);
 			break;
+		}
 		dev->num_frames--;
 	}
 
@@ -217,8 +178,7 @@
 void em28xx_release_buffers(struct em28xx *dev)
 {
 	if (dev->num_frames) {
-		rvfree(dev->frame[0].bufmem,
-		       dev->num_frames * PAGE_ALIGN(dev->frame[0].buf.length));
+		vfree(dev->frame[0].bufmem);
 		dev->num_frames = 0;
 	}
 }
diff -urN linux-2.6.15-rc5/drivers/media/video/em28xx/em28xx-i2c.c linux-2.6.15-rc6/drivers/media/video/em28xx/em28xx-i2c.c
--- linux-2.6.15-rc5/drivers/media/video/em28xx/em28xx-i2c.c	2005-12-18 22:27:55.112631773 -0800
+++ linux-2.6.15-rc6/drivers/media/video/em28xx/em28xx-i2c.c	2005-12-18 22:28:03.981026907 -0800
@@ -41,10 +41,10 @@
 MODULE_PARM_DESC(i2c_debug, "enable debug messages [i2c]");
 
 #define dprintk1(lvl,fmt, args...) if (i2c_debug>=lvl) do {\
-			printk(fmt , ##args); } while (0)
+			printk(fmt, ##args); } while (0)
 #define dprintk2(lvl,fmt, args...) if (i2c_debug>=lvl) do{ \
 			printk(KERN_DEBUG "%s at %s: " fmt, \
-			dev->name, __FUNCTION__ , ##args); } while (0)
+			dev->name, __FUNCTION__, ##args); } while (0)
 
 /*
  * em2800_i2c_send_max4()
diff -urN linux-2.6.15-rc5/drivers/media/video/em28xx/em28xx-video.c linux-2.6.15-rc6/drivers/media/video/em28xx/em28xx-video.c
--- linux-2.6.15-rc5/drivers/media/video/em28xx/em28xx-video.c	2005-12-18 22:27:55.115631907 -0800
+++ linux-2.6.15-rc6/drivers/media/video/em28xx/em28xx-video.c	2005-12-18 22:28:03.984027040 -0800
@@ -45,7 +45,7 @@
 #define em28xx_videodbg(fmt, arg...) do {\
 	if (video_debug) \
 		printk(KERN_INFO "%s %s :"fmt, \
-			 dev->name, __FUNCTION__ , ##arg); } while (0)
+			 dev->name, __FUNCTION__, ##arg); } while (0)
 
 MODULE_AUTHOR(DRIVER_AUTHOR);
 MODULE_DESCRIPTION(DRIVER_DESC);
@@ -189,16 +189,6 @@
 
 /*********************  v4l2 interface  ******************************************/
 
-static inline unsigned long kvirt_to_pa(unsigned long adr)
-{
-	unsigned long kva, ret;
-
-	kva = (unsigned long)page_address(vmalloc_to_page((void *)adr));
-	kva |= adr & (PAGE_SIZE - 1);
-	ret = __pa(kva);
-	return ret;
-}
-
 /*
  * em28xx_config()
  * inits registers with sane defaults
@@ -616,7 +606,8 @@
 static int em28xx_v4l2_mmap(struct file *filp, struct vm_area_struct *vma)
 {
 	unsigned long size = vma->vm_end - vma->vm_start,
-	    start = vma->vm_start, pos, page;
+	    start = vma->vm_start;
+	void *pos;
 	u32 i;
 
 	struct em28xx *dev = filp->private_data;
@@ -657,12 +648,10 @@
 	vma->vm_flags |= VM_IO;
 	vma->vm_flags |= VM_RESERVED;	/* avoid to swap out this VMA */
 
-	pos = (unsigned long)dev->frame[i].bufmem;
+	pos = dev->frame[i].bufmem;
 	while (size > 0) {	/* size is page-aligned */
-		page = vmalloc_to_pfn((void *)pos);
-		if (remap_pfn_range(vma, start, page, PAGE_SIZE,
-				    vma->vm_page_prot)) {
-			em28xx_videodbg("mmap: rename page map failed\n");
+		if (vm_insert_page(vma, start, vmalloc_to_page(pos))) {
+			em28xx_videodbg("mmap: vm_insert_page failed\n");
 			up(&dev->fileop_lock);
 			return -EAGAIN;
 		}
diff -urN linux-2.6.15-rc5/drivers/media/video/em28xx/em28xx.h linux-2.6.15-rc6/drivers/media/video/em28xx/em28xx.h
--- linux-2.6.15-rc5/drivers/media/video/em28xx/em28xx.h	2005-12-18 22:27:55.116631952 -0800
+++ linux-2.6.15-rc6/drivers/media/video/em28xx/em28xx.h	2005-12-18 22:28:03.985027085 -0800
@@ -392,18 +392,18 @@
 /* printk macros */
 
 #define em28xx_err(fmt, arg...) do {\
-	printk(KERN_ERR fmt , ##arg); } while (0)
+	printk(KERN_ERR fmt, ##arg); } while (0)
 
 #define em28xx_errdev(fmt, arg...) do {\
 	printk(KERN_ERR "%s: "fmt,\
-			dev->name , ##arg); } while (0)
+			dev->name, ##arg); } while (0)
 
 #define em28xx_info(fmt, arg...) do {\
 	printk(KERN_INFO "%s: "fmt,\
-			dev->name , ##arg); } while (0)
+			dev->name, ##arg); } while (0)
 #define em28xx_warn(fmt, arg...) do {\
 	printk(KERN_WARNING "%s: "fmt,\
-			dev->name , ##arg); } while (0)
+			dev->name, ##arg); } while (0)
 
 inline static int em28xx_audio_source(struct em28xx *dev, int input)
 {
diff -urN linux-2.6.15-rc5/drivers/media/video/ir-kbd-gpio.c linux-2.6.15-rc6/drivers/media/video/ir-kbd-gpio.c
--- linux-2.6.15-rc5/drivers/media/video/ir-kbd-gpio.c	2005-12-18 22:27:55.119632085 -0800
+++ linux-2.6.15-rc6/drivers/media/video/ir-kbd-gpio.c	2005-12-18 22:28:03.988027219 -0800
@@ -291,13 +291,12 @@
 	u32                     mask_keycode;
 	u32                     mask_keydown;
 	u32                     mask_keyup;
-	u32			polling;
+	u32                     polling;
 	u32                     last_gpio;
 	struct work_struct      work;
 	struct timer_list       timer;
 
 	/* RC5 gpio */
-
 	u32 rc5_gpio;
 	struct timer_list timer_end;	/* timer_end for code completion */
 	struct timer_list timer_keyup;	/* timer_end for key release */
@@ -647,7 +646,7 @@
 		driver.any_irq = ir_rc5_irq;
 		driver.gpio_irq = NULL;
 		ir->rc5_gpio = 1;
-		 break;
+		break;
 	}
 	if (NULL == ir_codes) {
 		kfree(ir);
@@ -657,7 +656,7 @@
 
 	if (ir->rc5_gpio) {
 		u32 gpio;
-		/* enable remote irq */
+	    	/* enable remote irq */
 		bttv_gpio_inout(sub->core, (1 << 4), 1 << 4);
 		gpio = bttv_gpio_read(sub->core);
 		bttv_gpio_write(sub->core, gpio & ~(1 << 4));
@@ -726,6 +725,7 @@
 		del_timer(&ir->timer);
 		flush_scheduled_work();
 	}
+
 	if (ir->rc5_gpio) {
 		u32 gpio;
 
diff -urN linux-2.6.15-rc5/drivers/media/video/ir-kbd-i2c.c linux-2.6.15-rc6/drivers/media/video/ir-kbd-i2c.c
--- linux-2.6.15-rc5/drivers/media/video/ir-kbd-i2c.c	2005-12-18 22:27:55.120632130 -0800
+++ linux-2.6.15-rc6/drivers/media/video/ir-kbd-i2c.c	2005-12-18 22:28:03.989027263 -0800
@@ -40,6 +40,7 @@
 #include <linux/i2c.h>
 #include <linux/workqueue.h>
 #include <asm/semaphore.h>
+
 #include <media/ir-common.h>
 #include <media/ir-kbd-i2c.h>
 
@@ -278,7 +279,7 @@
 
 static struct i2c_driver driver = {
 	.name           = "ir remote kbd driver",
-	.id             = I2C_DRIVERID_I2C_IR,
+	.id             = I2C_DRIVERID_INFRARED,
 	.flags          = I2C_DF_NOTIFY,
 	.attach_adapter = ir_probe,
 	.detach_client  = ir_detach,
@@ -296,15 +297,15 @@
 	IR_KEYTAB_TYPE *ir_codes = NULL;
 	char *name;
 	int ir_type;
-        struct IR_i2c *ir;
+	struct IR_i2c *ir;
 	struct input_dev *input_dev;
 
-	ir = kzalloc(sizeof(struct IR_i2c), GFP_KERNEL);
+	ir = kzalloc(sizeof(struct IR_i2c),GFP_KERNEL);
 	input_dev = input_allocate_device();
 	if (!ir || !input_dev) {
 		kfree(ir);
 		input_free_device(input_dev);
-                return -ENOMEM;
+		return -ENOMEM;
 	}
 
 	ir->c = client_template;
@@ -360,7 +361,7 @@
 	/* register i2c device
 	 * At device register, IR codes may be changed to be
 	 * board dependent.
-	*/
+	 */
 	i2c_attach_client(&ir->c);
 
 	/* If IR not supported or disabled, unregisters driver */
diff -urN linux-2.6.15-rc5/drivers/media/video/msp3400.c linux-2.6.15-rc6/drivers/media/video/msp3400.c
--- linux-2.6.15-rc5/drivers/media/video/msp3400.c	2005-12-18 22:27:55.124632308 -0800
+++ linux-2.6.15-rc6/drivers/media/video/msp3400.c	2005-12-18 22:28:03.993027441 -0800
@@ -134,7 +134,7 @@
 	int rxsubchans;
 
 	int muted;
-	int left, right;        /* volume */
+	int left, right;	/* volume */
 	int bass, treble;
 
 	/* shadow register set */
@@ -882,6 +882,7 @@
 		msp->watch_stereo = 0;
 }
 
+
 static int msp3400c_thread(void *data)
 {
 	struct i2c_client *client = data;
@@ -889,6 +890,7 @@
 	struct CARRIER_DETECT *cd;
 	int count, max1,max2,val1,val2, val,this;
 
+
 	msp3400_info("msp3400 daemon started\n");
 	for (;;) {
 		msp3400_dbg_mediumvol("msp3400 thread: sleep\n");
@@ -1162,6 +1164,7 @@
 	int mode,val,i,std;
 
 	msp3400_info("msp3410 daemon started\n");
+
 	for (;;) {
 		msp3400_dbg_mediumvol("msp3410 thread: sleep\n");
 		msp34xx_sleep(msp,-1);
@@ -1384,6 +1387,7 @@
 	int val, std, i;
 
 	msp3400_info("msp34xxg daemon started\n");
+
 	msp->source = 1; /* default */
 	for (;;) {
 		msp3400_dbg_mediumvol("msp34xxg thread: sleep\n");
@@ -1559,11 +1563,11 @@
 static struct i2c_driver driver = {
 	.owner          = THIS_MODULE,
 	.name           = "msp3400",
-        .id             = I2C_DRIVERID_MSP3400,
-        .flags          = I2C_DF_NOTIFY,
-        .attach_adapter = msp_probe,
-        .detach_client  = msp_detach,
-        .command        = msp_command,
+	.id             = I2C_DRIVERID_MSP3400,
+	.flags          = I2C_DF_NOTIFY,
+	.attach_adapter = msp_probe,
+	.detach_client  = msp_detach,
+	.command        = msp_command,
 	.driver = {
 		.suspend = msp_suspend,
 		.resume  = msp_resume,
@@ -1574,7 +1578,7 @@
 {
 	.name      = "(unset)",
 	.flags     = I2C_CLIENT_ALLOW_USE,
-        .driver    = &driver,
+	.driver    = &driver,
 };
 
 static int msp_attach(struct i2c_adapter *adap, int addr, int kind)
diff -urN linux-2.6.15-rc5/drivers/media/video/saa6588.c linux-2.6.15-rc6/drivers/media/video/saa6588.c
--- linux-2.6.15-rc5/drivers/media/video/saa6588.c	2005-12-18 22:27:55.125632353 -0800
+++ linux-2.6.15-rc6/drivers/media/video/saa6588.c	2005-12-18 22:28:03.994027486 -0800
@@ -422,7 +422,6 @@
 	s->timer.function = saa6588_timer;
 	s->timer.data = (unsigned long)s;
 	schedule_work(&s->work);
-
 	return 0;
 }
 
diff -urN linux-2.6.15-rc5/drivers/media/video/saa711x.c linux-2.6.15-rc6/drivers/media/video/saa711x.c
--- linux-2.6.15-rc5/drivers/media/video/saa711x.c	2005-12-18 22:27:55.128632486 -0800
+++ linux-2.6.15-rc6/drivers/media/video/saa711x.c	2005-12-18 22:28:03.997027620 -0800
@@ -59,7 +59,7 @@
 #define dprintk(num, format, args...) \
 	do { \
 		if (debug >= num) \
-			printk(format , ##args); \
+			printk(format, ##args); \
 	} while (0)
 
 /* ----------------------------------------------------------------------- */
diff -urN linux-2.6.15-rc5/drivers/media/video/saa7134/saa6752hs.c linux-2.6.15-rc6/drivers/media/video/saa7134/saa6752hs.c
--- linux-2.6.15-rc5/drivers/media/video/saa7134/saa6752hs.c	2005-12-18 22:27:55.131632620 -0800
+++ linux-2.6.15-rc6/drivers/media/video/saa7134/saa6752hs.c	2005-12-18 22:28:04.000027753 -0800
@@ -523,7 +523,8 @@
 	h->standard = 0;
 
 	i2c_set_clientdata(&h->client, h);
-        i2c_attach_client(&h->client);
+	i2c_attach_client(&h->client);
+
 	return 0;
 }
 
@@ -597,19 +598,19 @@
 
 static struct i2c_driver driver = {
 	.owner          = THIS_MODULE,
-        .name           = "i2c saa6752hs MPEG encoder",
-        .id             = I2C_DRIVERID_SAA6752HS,
-        .flags          = I2C_DF_NOTIFY,
-        .attach_adapter = saa6752hs_probe,
-        .detach_client  = saa6752hs_detach,
-        .command        = saa6752hs_command,
+	.name           = "i2c saa6752hs MPEG encoder",
+	.id             = I2C_DRIVERID_SAA6752HS,
+	.flags          = I2C_DF_NOTIFY,
+	.attach_adapter = saa6752hs_probe,
+	.detach_client  = saa6752hs_detach,
+	.command        = saa6752hs_command,
 };
 
 static struct i2c_client client_template =
 {
 	.name       = "saa6752hs",
 	.flags      = I2C_CLIENT_ALLOW_USE,
-        .driver     = &driver,
+	.driver     = &driver,
 };
 
 static int __init saa6752hs_init_module(void)
diff -urN linux-2.6.15-rc5/drivers/media/video/saa7134/saa7134-alsa.c linux-2.6.15-rc6/drivers/media/video/saa7134/saa7134-alsa.c
--- linux-2.6.15-rc5/drivers/media/video/saa7134/saa7134-alsa.c	2005-12-18 22:27:55.132632665 -0800
+++ linux-2.6.15-rc6/drivers/media/video/saa7134/saa7134-alsa.c	2005-12-18 22:28:04.001027798 -0800
@@ -51,6 +51,7 @@
 #define MIXER_ADDR_LINE2	2
 #define MIXER_ADDR_LAST		2
 
+
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
 static int enable[SNDRV_CARDS] = {1, [1 ... (SNDRV_CARDS - 1)] = 0};
@@ -59,11 +60,14 @@
 MODULE_PARM_DESC(index, "Index value for SAA7134 capture interface(s).");
 
 #define dprintk(fmt, arg...)    if (debug) \
-        printk(KERN_DEBUG "%s/alsa: " fmt, dev->name , ## arg)
+	printk(KERN_DEBUG "%s/alsa: " fmt, dev->name, ## arg)
+
+
 
 /*
  * Main chip structure
  */
+
 typedef struct snd_card_saa7134 {
 	snd_card_t *card;
 	spinlock_t mixer_lock;
@@ -208,8 +212,8 @@
 
 static irqreturn_t saa7134_alsa_irq(int irq, void *dev_id, struct pt_regs *regs)
 {
-        struct saa7134_dmasound *dmasound = dev_id;
-        struct saa7134_dev *dev = dmasound->priv_data;
+	struct saa7134_dmasound *dmasound = dev_id;
+	struct saa7134_dev *dev = dmasound->priv_data;
 
 	unsigned long report, status;
 	int loop, handled = 0;
@@ -985,7 +989,7 @@
 	struct saa7134_dev *dev = NULL;
 	struct list_head *list;
 
-        printk(KERN_INFO "saa7134 ALSA driver for DMA sound loaded\n");
+	printk(KERN_INFO "saa7134 ALSA driver for DMA sound loaded\n");
 
 	list_for_each(list,&saa7134_devlist) {
 		dev = list_entry(list, struct saa7134_dev, devlist);
@@ -1004,6 +1008,7 @@
 		printk(KERN_INFO "saa7134 ALSA: no saa7134 cards found\n");
 
 	return 0;
+
 }
 
 /*
@@ -1027,3 +1032,6 @@
 module_exit(saa7134_alsa_exit);
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Ricardo Cerqueira");
+
+
+
diff -urN linux-2.6.15-rc5/drivers/media/video/saa7134/saa7134-cards.c linux-2.6.15-rc6/drivers/media/video/saa7134/saa7134-cards.c
--- linux-2.6.15-rc5/drivers/media/video/saa7134/saa7134-cards.c	2005-12-18 22:27:55.135632798 -0800
+++ linux-2.6.15-rc6/drivers/media/video/saa7134/saa7134-cards.c	2005-12-18 22:28:04.004027932 -0800
@@ -976,7 +976,7 @@
 		.radio_type     = UNSET,
 		.tuner_addr	= ADDR_UNSET,
 		.radio_addr	= ADDR_UNSET,
-		.tda9887_conf   = TDA9887_PRESENT | TDA9887_INTERCARRIER,
+		.tda9887_conf   = TDA9887_PRESENT | TDA9887_INTERCARRIER | TDA9887_PORT2_ACTIVE,
 		.inputs         = {{
 			.name = name_tv,
 			.vmux = 3,
diff -urN linux-2.6.15-rc5/drivers/media/video/saa7134/saa7134-core.c linux-2.6.15-rc6/drivers/media/video/saa7134/saa7134-core.c
--- linux-2.6.15-rc5/drivers/media/video/saa7134/saa7134-core.c	2005-12-18 22:27:55.136632843 -0800
+++ linux-2.6.15-rc6/drivers/media/video/saa7134/saa7134-core.c	2005-12-18 22:28:04.005027976 -0800
@@ -71,6 +71,7 @@
 static unsigned int tuner[]    = {[0 ... (SAA7134_MAXBOARDS - 1)] = UNSET };
 static unsigned int card[]     = {[0 ... (SAA7134_MAXBOARDS - 1)] = UNSET };
 
+
 module_param_array(video_nr, int, NULL, 0444);
 module_param_array(vbi_nr,   int, NULL, 0444);
 module_param_array(radio_nr, int, NULL, 0444);
diff -urN linux-2.6.15-rc5/drivers/media/video/saa7134/saa7134-empress.c linux-2.6.15-rc6/drivers/media/video/saa7134/saa7134-empress.c
--- linux-2.6.15-rc5/drivers/media/video/saa7134/saa7134-empress.c	2005-12-18 22:27:55.138632932 -0800
+++ linux-2.6.15-rc6/drivers/media/video/saa7134/saa7134-empress.c	2005-12-18 22:28:04.007028065 -0800
@@ -36,6 +36,7 @@
 MODULE_LICENSE("GPL");
 
 static unsigned int empress_nr[] = {[0 ... (SAA7134_MAXBOARDS - 1)] = UNSET };
+
 module_param_array(empress_nr, int, NULL, 0444);
 MODULE_PARM_DESC(empress_nr,"ts device number");
 
diff -urN linux-2.6.15-rc5/drivers/media/video/saa7134/saa7134-i2c.c linux-2.6.15-rc6/drivers/media/video/saa7134/saa7134-i2c.c
--- linux-2.6.15-rc5/drivers/media/video/saa7134/saa7134-i2c.c	2005-12-18 22:27:55.138632932 -0800
+++ linux-2.6.15-rc6/drivers/media/video/saa7134/saa7134-i2c.c	2005-12-18 22:28:04.007028065 -0800
@@ -333,7 +333,7 @@
 	struct tuner_setup tun_setup;
 
 	d1printk( "%s i2c attach [addr=0x%x,client=%s]\n",
-		 client->driver->name, client->addr, client->name);
+		client->driver->name, client->addr, client->name);
 
 	/* Am I an i2c remote control? */
 
diff -urN linux-2.6.15-rc5/drivers/media/video/saa7134/saa7134-oss.c linux-2.6.15-rc6/drivers/media/video/saa7134/saa7134-oss.c
--- linux-2.6.15-rc5/drivers/media/video/saa7134/saa7134-oss.c	2005-12-18 22:27:55.141633066 -0800
+++ linux-2.6.15-rc6/drivers/media/video/saa7134/saa7134-oss.c	2005-12-18 22:28:04.010028199 -0800
@@ -782,36 +782,36 @@
 
 static irqreturn_t saa7134_oss_irq(int irq, void *dev_id, struct pt_regs *regs)
 {
-        struct saa7134_dmasound *dmasound = dev_id;
-        struct saa7134_dev *dev = dmasound->priv_data;
-        unsigned long report, status;
-        int loop, handled = 0;
-
-        for (loop = 0; loop < 10; loop++) {
-                report = saa_readl(SAA7134_IRQ_REPORT);
-                status = saa_readl(SAA7134_IRQ_STATUS);
-
-                if (report & SAA7134_IRQ_REPORT_DONE_RA3) {
-                        handled = 1;
-                        saa_writel(SAA7134_IRQ_REPORT,report);
-                        saa7134_irq_oss_done(dev, status);
-                } else {
-                        goto out;
-                }
-        }
-
-        if (loop == 10) {
-                dprintk("error! looping IRQ!");
-        }
+	struct saa7134_dmasound *dmasound = dev_id;
+	struct saa7134_dev *dev = dmasound->priv_data;
+	unsigned long report, status;
+	int loop, handled = 0;
+
+	for (loop = 0; loop < 10; loop++) {
+		report = saa_readl(SAA7134_IRQ_REPORT);
+		status = saa_readl(SAA7134_IRQ_STATUS);
+
+		if (report & SAA7134_IRQ_REPORT_DONE_RA3) {
+			handled = 1;
+			saa_writel(SAA7134_IRQ_REPORT,report);
+			saa7134_irq_oss_done(dev, status);
+		} else {
+			goto out;
+		}
+	}
+
+	if (loop == 10) {
+		dprintk("error! looping IRQ!");
+	}
 out:
-        return IRQ_RETVAL(handled);
+	return IRQ_RETVAL(handled);
 }
 
 int saa7134_oss_init1(struct saa7134_dev *dev)
 {
 
-        if ((request_irq(dev->pci->irq, saa7134_oss_irq,
-                         SA_SHIRQ | SA_INTERRUPT, dev->name,
+	if ((request_irq(dev->pci->irq, saa7134_oss_irq,
+			 SA_SHIRQ | SA_INTERRUPT, dev->name,
 			(void*) &dev->dmasound)) < 0)
 		return -1;
 
@@ -905,25 +905,25 @@
 
 	err = dev->dmasound.minor_dsp =
 		register_sound_dsp(&saa7134_dsp_fops,
-                			dsp_nr[dev->nr]);
+				   dsp_nr[dev->nr]);
 	if (err < 0) {
 		goto fail;
 	}
 	printk(KERN_INFO "%s: registered device dsp%d\n",
-		dev->name,dev->dmasound.minor_dsp >> 4);
+	       dev->name,dev->dmasound.minor_dsp >> 4);
 
 	err = dev->dmasound.minor_mixer =
 		register_sound_mixer(&saa7134_mixer_fops,
-					mixer_nr[dev->nr]);
+				     mixer_nr[dev->nr]);
 	if (err < 0)
 		goto fail;
 	printk(KERN_INFO "%s: registered device mixer%d\n",
-		dev->name,dev->dmasound.minor_mixer >> 4);
+	       dev->name,dev->dmasound.minor_mixer >> 4);
 
 	return 0;
 
 fail:
-        unregister_sound_dsp(dev->dmasound.minor_dsp);
+	unregister_sound_dsp(dev->dmasound.minor_dsp);
 	return 0;
 
 
@@ -956,49 +956,50 @@
 
 static int saa7134_oss_init(void)
 {
-        struct saa7134_dev *dev = NULL;
-        struct list_head *list;
+	struct saa7134_dev *dev = NULL;
+	struct list_head *list;
 
-        printk(KERN_INFO "saa7134 OSS driver for DMA sound loaded\n");
+	printk(KERN_INFO "saa7134 OSS driver for DMA sound loaded\n");
 
-        list_for_each(list,&saa7134_devlist) {
-                dev = list_entry(list, struct saa7134_dev, devlist);
+	list_for_each(list,&saa7134_devlist) {
+		dev = list_entry(list, struct saa7134_dev, devlist);
 		if (dev->dmasound.priv_data == NULL) {
 			oss_device_init(dev);
 		} else {
-                	printk(KERN_ERR "saa7134 OSS: DMA sound is being handled by ALSA, ignoring %s\n",dev->name);
+			printk(KERN_ERR "saa7134 OSS: DMA sound is being handled by ALSA, ignoring %s\n",dev->name);
 			return -EBUSY;
 		}
-        }
+	}
 
-        if (dev == NULL)
-                printk(KERN_INFO "saa7134 OSS: no saa7134 cards found\n");
+	if (dev == NULL)
+		printk(KERN_INFO "saa7134 OSS: no saa7134 cards found\n");
 
 	dmasound_init = oss_device_init;
 	dmasound_exit = oss_device_exit;
 
-        return 0;
+	return 0;
 
 }
 
 static void saa7134_oss_exit(void)
 {
-        struct saa7134_dev *dev = NULL;
-        struct list_head *list;
+	struct saa7134_dev *dev = NULL;
+	struct list_head *list;
 
-        list_for_each(list,&saa7134_devlist) {
-                dev = list_entry(list, struct saa7134_dev, devlist);
+	list_for_each(list,&saa7134_devlist) {
+		dev = list_entry(list, struct saa7134_dev, devlist);
 
 		/* Device isn't registered by OSS, probably ALSA's */
 		if (!dev->dmasound.minor_dsp)
 			continue;
 
 		oss_device_exit(dev);
-        }
 
-        printk(KERN_INFO "saa7134 OSS driver for DMA sound unloaded\n");
+	}
+
+	printk(KERN_INFO "saa7134 OSS driver for DMA sound unloaded\n");
 
-        return;
+	return;
 }
 
 module_init(saa7134_oss_init);
diff -urN linux-2.6.15-rc5/drivers/media/video/tda9887.c linux-2.6.15-rc6/drivers/media/video/tda9887.c
--- linux-2.6.15-rc5/drivers/media/video/tda9887.c	2005-12-18 22:27:55.151633511 -0800
+++ linux-2.6.15-rc6/drivers/media/video/tda9887.c	2005-12-18 22:28:04.019028600 -0800
@@ -12,6 +12,7 @@
 #include <media/audiochip.h>
 #include <media/tuner.h>
 
+
 /* Chips:
    TDA9885 (PAL, NTSC)
    TDA9886 (PAL, SECAM, NTSC)
@@ -819,12 +820,12 @@
 
 static struct i2c_driver driver = {
 	.owner          = THIS_MODULE,
-        .name           = "i2c tda9887 driver",
-        .id             = -1, /* FIXME */
-        .flags          = I2C_DF_NOTIFY,
-        .attach_adapter = tda9887_probe,
-        .detach_client  = tda9887_detach,
-        .command        = tda9887_command,
+	.name           = "i2c tda9887 driver",
+	.id             = -1, /* FIXME */
+	.flags          = I2C_DF_NOTIFY,
+	.attach_adapter = tda9887_probe,
+	.detach_client  = tda9887_detach,
+	.command        = tda9887_command,
 	.driver = {
 		.suspend = tda9887_suspend,
 		.resume  = tda9887_resume,
@@ -834,7 +835,7 @@
 {
 	.name      = "tda9887",
 	.flags     = I2C_CLIENT_ALLOW_USE,
-        .driver    = &driver,
+	.driver    = &driver,
 };
 
 static int __init tda9887_init_module(void)
diff -urN linux-2.6.15-rc5/drivers/media/video/tvaudio.c linux-2.6.15-rc6/drivers/media/video/tvaudio.c
--- linux-2.6.15-rc5/drivers/media/video/tvaudio.c	2005-12-18 22:27:55.154633645 -0800
+++ linux-2.6.15-rc6/drivers/media/video/tvaudio.c	2005-12-18 22:28:04.022028734 -0800
@@ -188,7 +188,7 @@
 		buffer[1] = val;
 		if (2 != i2c_master_send(&chip->c,buffer,2)) {
 			tvaudio_warn("%s: I/O error (write reg%d=0x%x)\n",
-						chip->c.name, subaddr, val);
+			chip->c.name, subaddr, val);
 			return -1;
 		}
 	}
@@ -216,7 +216,7 @@
 		chip->c.name);
 		return -1;
 	}
-	tvaudio_dbg("%s: chip_read: 0x%x\n",chip->c.name,buffer);
+	tvaudio_dbg("%s: chip_read: 0x%x\n",chip->c.name, buffer);
 	return buffer;
 }
 
@@ -235,7 +235,7 @@
 		return -1;
 	}
 	tvaudio_dbg("%s: chip_read2: reg%d=0x%x\n",
-			chip->c.name,subaddr,read[0]);
+		chip->c.name, subaddr,read[0]);
 	return read[0];
 }
 
@@ -248,7 +248,7 @@
 
 	/* update our shadow register set; print bytes if (debug > 0) */
 	tvaudio_dbg("%s: chip_cmd(%s): reg=%d, data:",
-		chip->c.name,name,cmd->bytes[0]);
+		chip->c.name, name,cmd->bytes[0]);
 	for (i = 1; i < cmd->count; i++) {
 		if (debug)
 			printk(" 0x%x",cmd->bytes[i]);
@@ -322,7 +322,7 @@
 	int mode = desc->getmode(chip);
 
 	if (mode == chip->prevmode)
-		return;
+	return;
 
 	tvaudio_dbg("%s: thread checkmode\n", chip->c.name);
 	chip->prevmode = mode;
@@ -1506,18 +1506,18 @@
 		return -EIO;
 	}
 	tvaudio_info("%s found @ 0x%x (%s)\n", desc->name, addr<<1, adap->name);
-        if (desc->flags) {
-                tvaudio_dbg("matches:%s%s%s.\n",
-                        (desc->flags & CHIP_HAS_VOLUME)     ? " volume"      : "",
-                        (desc->flags & CHIP_HAS_BASSTREBLE) ? " bass/treble" : "",
-                        (desc->flags & CHIP_HAS_INPUTSEL)   ? " audiomux"    : "");
-        }
+	if (desc->flags) {
+		tvaudio_dbg("matches:%s%s%s.\n",
+			(desc->flags & CHIP_HAS_VOLUME)     ? " volume"      : "",
+			(desc->flags & CHIP_HAS_BASSTREBLE) ? " bass/treble" : "",
+			(desc->flags & CHIP_HAS_INPUTSEL)   ? " audiomux"    : "");
+	}
 
 	/* fill required data structures */
-	strcpy(chip->c.name,desc->name);
+	strcpy(chip->c.name, desc->name);
 	chip->type = desc-chiplist;
 	chip->shadow.count = desc->registers+1;
-        chip->prevmode = -1;
+	chip->prevmode = -1;
 	/* register */
 	i2c_attach_client(&chip->c);
 
@@ -1604,7 +1604,7 @@
 	struct CHIPSTATE *chip = i2c_get_clientdata(client);
 	struct CHIPDESC  *desc = chiplist + chip->type;
 
-	tvaudio_dbg("%s: chip_command 0x%x\n",chip->c.name,cmd);
+	tvaudio_dbg("%s: chip_command 0x%x\n", chip->c.name, cmd);
 
 	switch (cmd) {
 	case AUDC_SET_INPUT:
@@ -1624,7 +1624,7 @@
 
 	/* --- v4l ioctls --- */
 	/* take care: bttv does userspace copying, we'll get a
-					kernel pointer here... */
+	kernel pointer here... */
 	case VIDIOCGAUDIO:
 	{
 		struct video_audio *va = arg;
diff -urN linux-2.6.15-rc5/drivers/media/video/tveeprom.c linux-2.6.15-rc6/drivers/media/video/tveeprom.c
--- linux-2.6.15-rc5/drivers/media/video/tveeprom.c	2005-12-18 22:27:55.155633689 -0800
+++ linux-2.6.15-rc6/drivers/media/video/tveeprom.c	2005-12-18 22:28:04.024028823 -0800
@@ -753,7 +753,8 @@
 	client->driver = &i2c_driver_tveeprom;
 	client->flags = I2C_CLIENT_ALLOW_USE;
 	snprintf(client->name, sizeof(client->name), "tveeprom");
-        i2c_attach_client(client);
+	i2c_attach_client(client);
+
 	return 0;
 }
 
diff -urN linux-2.6.15-rc5/drivers/media/video/tvp5150.c linux-2.6.15-rc6/drivers/media/video/tvp5150.c
--- linux-2.6.15-rc5/drivers/media/video/tvp5150.c	2005-12-18 22:27:55.157633778 -0800
+++ linux-2.6.15-rc6/drivers/media/video/tvp5150.c	2005-12-18 22:28:04.026028912 -0800
@@ -31,7 +31,7 @@
 #define dprintk(num, format, args...) \
 	do { \
 		if (debug >= num) \
-			printk(format , ##args); \
+			printk(format, ##args); \
 	} while (0)
 
 /* supported controls */
@@ -770,7 +770,6 @@
 
 	if (debug > 1)
 		dump_reg(client);
-
 	return 0;
 }
 
diff -urN linux-2.6.15-rc5/drivers/media/video/video-buf-dvb.c linux-2.6.15-rc6/drivers/media/video/video-buf-dvb.c
--- linux-2.6.15-rc5/drivers/media/video/video-buf-dvb.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/media/video/video-buf-dvb.c	2005-12-18 22:28:04.028029001 -0800
@@ -13,6 +13,7 @@
  * (at your option) any later version.
  */
 
+
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/device.h>
@@ -247,3 +248,4 @@
  * compile-command: "make DVB=1"
  * End:
  */
+
diff -urN linux-2.6.15-rc5/drivers/message/i2o/pci.c linux-2.6.15-rc6/drivers/message/i2o/pci.c
--- linux-2.6.15-rc5/drivers/message/i2o/pci.c	2005-12-18 22:27:55.187635115 -0800
+++ linux-2.6.15-rc6/drivers/message/i2o/pci.c	2005-12-18 22:28:04.055030204 -0800
@@ -303,6 +303,7 @@
 	struct i2o_controller *c;
 	int rc;
 	struct pci_dev *i960 = NULL;
+	int pci_dev_busy = 0;
 
 	printk(KERN_INFO "i2o: Checking for PCI I2O controllers...\n");
 
@@ -395,6 +396,8 @@
 	if ((rc = i2o_pci_alloc(c))) {
 		printk(KERN_ERR "%s: DMA / IO allocation for I2O controller "
 		       " failed\n", c->name);
+		if (rc == -ENODEV)
+			pci_dev_busy = 1;
 		goto free_controller;
 	}
 
@@ -425,7 +428,8 @@
 	i2o_iop_free(c);
 
       disable:
-	pci_disable_device(pdev);
+	if (!pci_dev_busy)
+		pci_disable_device(pdev);
 
 	return rc;
 }
diff -urN linux-2.6.15-rc5/drivers/mfd/ucb1x00-ts.c linux-2.6.15-rc6/drivers/mfd/ucb1x00-ts.c
--- linux-2.6.15-rc5/drivers/mfd/ucb1x00-ts.c	2005-12-18 22:27:55.188635160 -0800
+++ linux-2.6.15-rc6/drivers/mfd/ucb1x00-ts.c	2005-12-18 22:28:04.056030249 -0800
@@ -59,16 +59,18 @@
 
 static inline void ucb1x00_ts_evt_add(struct ucb1x00_ts *ts, u16 pressure, u16 x, u16 y)
 {
-	input_report_abs(ts->idev, ABS_X, x);
-	input_report_abs(ts->idev, ABS_Y, y);
-	input_report_abs(ts->idev, ABS_PRESSURE, pressure);
-	input_sync(ts->idev);
+	struct input_dev *idev = ts->idev;
+	input_report_abs(idev, ABS_X, x);
+	input_report_abs(idev, ABS_Y, y);
+	input_report_abs(idev, ABS_PRESSURE, pressure);
+	input_sync(idev);
 }
 
 static inline void ucb1x00_ts_event_release(struct ucb1x00_ts *ts)
 {
-	input_report_abs(ts->idev, ABS_PRESSURE, 0);
-	input_sync(ts->idev);
+	struct input_dev *idev = ts->idev;
+	input_report_abs(idev, ABS_PRESSURE, 0);
+	input_sync(idev);
 }
 
 /*
@@ -297,7 +299,7 @@
 
 static int ucb1x00_ts_open(struct input_dev *idev)
 {
-	struct ucb1x00_ts *ts = (struct ucb1x00_ts *)idev;
+	struct ucb1x00_ts *ts = idev->private;
 	int ret = 0;
 
 	BUG_ON(ts->rtask);
@@ -334,7 +336,7 @@
  */
 static void ucb1x00_ts_close(struct input_dev *idev)
 {
-	struct ucb1x00_ts *ts = (struct ucb1x00_ts *)idev;
+	struct ucb1x00_ts *ts = idev->private;
 
 	if (ts->rtask)
 		kthread_stop(ts->rtask);
@@ -386,6 +388,7 @@
 	ts->ucb = dev->ucb;
 	ts->adcsync = adcsync ? UCB_SYNC : UCB_NOSYNC;
 
+	ts->idev->private = ts;
 	ts->idev->name       = "Touchscreen panel";
 	ts->idev->id.product = ts->ucb->id;
 	ts->idev->open       = ucb1x00_ts_open;
diff -urN linux-2.6.15-rc5/drivers/mmc/mmc.c linux-2.6.15-rc6/drivers/mmc/mmc.c
--- linux-2.6.15-rc5/drivers/mmc/mmc.c	2005-12-18 22:27:55.191635293 -0800
+++ linux-2.6.15-rc6/drivers/mmc/mmc.c	2005-12-18 22:28:04.059030382 -0800
@@ -679,7 +679,15 @@
 }
 
 /*
- * Apply power to the MMC stack.
+ * Apply power to the MMC stack.  This is a two-stage process.
+ * First, we enable power to the card without the clock running.
+ * We then wait a bit for the power to stabilise.  Finally,
+ * enable the bus drivers and clock to the card.
+ *
+ * We must _NOT_ enable the clock prior to power stablising.
+ *
+ * If a host does all the power sequencing itself, ignore the
+ * initial MMC_POWER_UP stage.
  */
 static void mmc_power_up(struct mmc_host *host)
 {
@@ -932,8 +940,9 @@
 
 		sg_init_one(&sg, (u8*)card->raw_scr, 8);
 
-		err = mmc_wait_for_req(host, &mrq);
-		if (err != MMC_ERR_NONE) {
+		mmc_wait_for_req(host, &mrq);
+
+		if (cmd.error != MMC_ERR_NONE || data.error != MMC_ERR_NONE) {
 			mmc_card_set_dead(card);
 			continue;
 		}
diff -urN linux-2.6.15-rc5/drivers/mtd/devices/blkmtd.c linux-2.6.15-rc6/drivers/mtd/devices/blkmtd.c
--- linux-2.6.15-rc5/drivers/mtd/devices/blkmtd.c	2005-12-18 22:27:55.212636229 -0800
+++ linux-2.6.15-rc6/drivers/mtd/devices/blkmtd.c	2005-12-18 22:28:04.080031318 -0800
@@ -113,7 +113,7 @@
 			ClearPageUptodate(page);
 			SetPageError(page);
 		}
-		ClearPageDirty(page);
+		clear_page_dirty(page);
 		unlock_page(page);
 		page_cache_release(page);
 	} while (bvec >= bio->bi_io_vec);
@@ -289,7 +289,7 @@
 			BUG();
 		}
 		memcpy(page_address(page)+offset, buf, start_len);
-		SetPageDirty(page);
+		set_page_dirty(page);
 		SetPageUptodate(page);
 		buf += start_len;
 		thislen = start_len;
@@ -336,7 +336,7 @@
 			}
 			pagenr++;
 			pagecnt--;
-			SetPageDirty(page);
+			set_page_dirty(page);
 			SetPageUptodate(page);
 			pagesc--;
 			thislen += PAGE_SIZE;
@@ -357,7 +357,7 @@
 			BUG();
 		}
 		memcpy(page_address(page), buf, end_len);
-		SetPageDirty(page);
+		set_page_dirty(page);
 		SetPageUptodate(page);
 		DEBUG(3, "blkmtd: write: writing out partial end\n");
 		thislen += end_len;
diff -urN linux-2.6.15-rc5/drivers/mtd/onenand/generic.c linux-2.6.15-rc6/drivers/mtd/onenand/generic.c
--- linux-2.6.15-rc5/drivers/mtd/onenand/generic.c	2005-12-18 22:27:55.269638769 -0800
+++ linux-2.6.15-rc6/drivers/mtd/onenand/generic.c	2005-12-18 22:28:04.136033813 -0800
@@ -12,9 +12,9 @@
  *   This is a device driver for the OneNAND flash for generic boards.
  */
 
-#include <linux/device.h>
 #include <linux/module.h>
 #include <linux/init.h>
+#include <linux/platform_device.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/onenand.h>
 #include <linux/mtd/partitions.h>
@@ -39,7 +39,7 @@
 {
 	struct onenand_info *info;
 	struct platform_device *pdev = to_platform_device(dev);
-	struct onenand_platform_data *pdata = pdev->dev.platform_data;
+	struct flash_platform_data *pdata = pdev->dev.platform_data;
 	struct resource *res = pdev->resource;
 	unsigned long size = res->end - res->start + 1;
 	int err;
diff -urN linux-2.6.15-rc5/drivers/mtd/onenand/onenand_base.c linux-2.6.15-rc6/drivers/mtd/onenand/onenand_base.c
--- linux-2.6.15-rc5/drivers/mtd/onenand/onenand_base.c	2005-12-18 22:27:55.271638858 -0800
+++ linux-2.6.15-rc6/drivers/mtd/onenand/onenand_base.c	2005-12-18 22:28:04.138033902 -0800
@@ -940,7 +940,7 @@
 	u_char *eccbuf, struct nand_oobinfo *oobsel)
 {
 	struct onenand_chip *this = mtd->priv;
-	unsigned char buffer[MAX_ONENAND_PAGESIZE], *pbuf;
+	unsigned char *pbuf;
 	size_t total_len, len;
 	int i, written = 0;
 	int ret = 0;
@@ -975,7 +975,7 @@
 	/* Loop until all keve's data has been written */
 	len = 0;
 	while (count) {
-		pbuf = buffer;
+		pbuf = this->page_buf;
 		/*
 		 * If the given tuple is >= pagesize then
 		 * write it out from the iov
@@ -995,7 +995,7 @@
 			int cnt = 0, thislen;
 			while (cnt < mtd->oobblock) {
 				thislen = min_t(int, mtd->oobblock - cnt, vecs->iov_len - len);
-				memcpy(buffer + cnt, vecs->iov_base + len, thislen);
+				memcpy(this->page_buf + cnt, vecs->iov_base + len, thislen);
 				cnt += thislen;
 				len += thislen;
 
@@ -1296,6 +1296,12 @@
 
 	/* Block lock scheme */
 	for (block = start; block < end; block++) {
+		/* Set block address */
+		value = onenand_block_address(this, block);
+		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
+		/* Select DataRAM for DDP */
+		value = onenand_bufferram_address(this, block);
+		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
 		/* Set start block address */
 		this->write_word(block, this->base + ONENAND_REG_START_BLOCK_ADDRESS);
 		/* Write unlock command */
@@ -1309,10 +1315,6 @@
 		    & ONENAND_CTRL_ONGO)
 			continue;
 
-		/* Set block address for read block status */
-		value = onenand_block_address(this, block);
-		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
-
 		/* Check lock status */
 		status = this->read_word(this->base + ONENAND_REG_WP_STATUS);
 		if (!(status & ONENAND_WP_US))
@@ -1346,7 +1348,6 @@
 
 static const struct onenand_manufacturers onenand_manuf_ids[] = {
         {ONENAND_MFR_SAMSUNG, "Samsung"},
-        {ONENAND_MFR_UNKNOWN, "Unknown"}
 };
 
 /**
@@ -1357,17 +1358,22 @@
  */
 static int onenand_check_maf(int manuf)
 {
+	int size = ARRAY_SIZE(onenand_manuf_ids);
+	char *name;
         int i;
 
-        for (i = 0; onenand_manuf_ids[i].id; i++) {
+	for (i = 0; i < size; i++)
                 if (manuf == onenand_manuf_ids[i].id)
                         break;
-        }
 
-        printk(KERN_DEBUG "OneNAND Manufacturer: %s (0x%0x)\n",
-                onenand_manuf_ids[i].name, manuf);
+	if (i < size)
+		name = onenand_manuf_ids[i].name;
+	else
+		name = "Unknown";
+
+	printk(KERN_DEBUG "OneNAND Manufacturer: %s (0x%0x)\n", name, manuf);
 
-        return (i != ONENAND_MFR_UNKNOWN);
+	return (i == size);
 }
 
 /**
@@ -1513,6 +1519,18 @@
 		this->read_bufferram = onenand_sync_read_bufferram;
 	}
 
+	/* Allocate buffers, if necessary */
+	if (!this->page_buf) {
+		size_t len;
+		len = mtd->oobblock + mtd->oobsize;
+		this->page_buf = kmalloc(len, GFP_KERNEL);
+		if (!this->page_buf) {
+			printk(KERN_ERR "onenand_scan(): Can't allocate page_buf\n");
+			return -ENOMEM;
+		}
+		this->options |= ONENAND_PAGEBUF_ALLOC;
+	}
+
 	this->state = FL_READY;
 	init_waitqueue_head(&this->wq);
 	spin_lock_init(&this->chip_lock);
@@ -1574,12 +1592,21 @@
  */
 void onenand_release(struct mtd_info *mtd)
 {
+	struct onenand_chip *this = mtd->priv;
+
 #ifdef CONFIG_MTD_PARTITIONS
 	/* Deregister partitions */
 	del_mtd_partitions (mtd);
 #endif
 	/* Deregister the device */
 	del_mtd_device (mtd);
+
+	/* Free bad block table memory, if allocated */
+	if (this->bbm)
+		kfree(this->bbm);
+	/* Buffer allocated by onenand_scan */
+	if (this->options & ONENAND_PAGEBUF_ALLOC)
+		kfree(this->page_buf);
 }
 
 EXPORT_SYMBOL_GPL(onenand_scan);
diff -urN linux-2.6.15-rc5/drivers/mtd/onenand/onenand_bbt.c linux-2.6.15-rc6/drivers/mtd/onenand/onenand_bbt.c
--- linux-2.6.15-rc5/drivers/mtd/onenand/onenand_bbt.c	2005-12-18 22:27:55.272638903 -0800
+++ linux-2.6.15-rc6/drivers/mtd/onenand/onenand_bbt.c	2005-12-18 22:28:04.139033947 -0800
@@ -118,10 +118,10 @@
  */
 static inline int onenand_memory_bbt (struct mtd_info *mtd, struct nand_bbt_descr *bd)
 {
-	unsigned char data_buf[MAX_ONENAND_PAGESIZE];
+	struct onenand_chip *this = mtd->priv;
 
         bd->options &= ~NAND_BBT_SCANEMPTY;
-        return create_bbt(mtd, data_buf, bd, -1);
+	return create_bbt(mtd, this->page_buf, bd, -1);
 }
 
 /**
diff -urN linux-2.6.15-rc5/drivers/net/pcnet32.c linux-2.6.15-rc6/drivers/net/pcnet32.c
--- linux-2.6.15-rc5/drivers/net/pcnet32.c	2005-12-18 22:27:55.424645675 -0800
+++ linux-2.6.15-rc6/drivers/net/pcnet32.c	2005-12-18 22:28:04.287040541 -0800
@@ -1251,12 +1251,7 @@
 
     if (memcmp(promaddr, dev->dev_addr, 6)
 	|| !is_valid_ether_addr(dev->dev_addr)) {
-#ifndef __powerpc__
 	if (is_valid_ether_addr(promaddr)) {
-#else
-	if (!is_valid_ether_addr(dev->dev_addr)
-	    && is_valid_ether_addr(promaddr)) {
-#endif
 	    if (pcnet32_debug & NETIF_MSG_PROBE) {
 		printk(" warning: CSR address invalid,\n");
 		printk(KERN_INFO "    using instead PROM address of");
diff -urN linux-2.6.15-rc5/drivers/net/s2io.c linux-2.6.15-rc6/drivers/net/s2io.c
--- linux-2.6.15-rc5/drivers/net/s2io.c	2005-12-18 22:27:55.441646433 -0800
+++ linux-2.6.15-rc6/drivers/net/s2io.c	2005-12-18 22:28:04.304041299 -0800
@@ -3078,7 +3078,7 @@
 
 static int wait_for_msix_trans(nic_t *nic, int i)
 {
-	XENA_dev_config_t *bar0 = (XENA_dev_config_t *) nic->bar0;
+	XENA_dev_config_t __iomem *bar0 = nic->bar0;
 	u64 val64;
 	int ret = 0, cnt = 0;
 
@@ -3099,7 +3099,7 @@
 
 void restore_xmsi_data(nic_t *nic)
 {
-	XENA_dev_config_t *bar0 = (XENA_dev_config_t *) nic->bar0;
+	XENA_dev_config_t __iomem *bar0 = nic->bar0;
 	u64 val64;
 	int i;
 
@@ -3117,7 +3117,7 @@
 
 static void store_xmsi_data(nic_t *nic)
 {
-	XENA_dev_config_t *bar0 = (XENA_dev_config_t *) nic->bar0;
+	XENA_dev_config_t __iomem *bar0 = nic->bar0;
 	u64 val64, addr, data;
 	int i;
 
@@ -3140,7 +3140,7 @@
 
 int s2io_enable_msi(nic_t *nic)
 {
-	XENA_dev_config_t *bar0 = (XENA_dev_config_t *) nic->bar0;
+	XENA_dev_config_t __iomem *bar0 = nic->bar0;
 	u16 msi_ctrl, msg_val;
 	struct config_param *config = &nic->config;
 	struct net_device *dev = nic->dev;
@@ -3190,7 +3190,7 @@
 
 int s2io_enable_msi_x(nic_t *nic)
 {
-	XENA_dev_config_t *bar0 = (XENA_dev_config_t *) nic->bar0;
+	XENA_dev_config_t __iomem *bar0 = nic->bar0;
 	u64 tx_mat, rx_mat;
 	u16 msi_control; /* Temp variable */
 	int ret, i, j, msix_indx = 1;
diff -urN linux-2.6.15-rc5/drivers/net/sk98lin/skge.c linux-2.6.15-rc6/drivers/net/sk98lin/skge.c
--- linux-2.6.15-rc5/drivers/net/sk98lin/skge.c	2005-12-18 22:27:55.463647413 -0800
+++ linux-2.6.15-rc6/drivers/net/sk98lin/skge.c	2005-12-18 22:28:04.323042145 -0800
@@ -818,7 +818,7 @@
 		/* set the pointers right */
 		pDescr->VNextRxd = VNextDescr & 0xffffffffULL;
 		pDescr->pNextRxd = pNextDescr;
-		pDescr->TcpSumStarts = 0;
+		if (!IsTx) pDescr->TcpSumStarts = ETH_HLEN << 16 | ETH_HLEN;
 
 		/* advance one step */
 		pPrevDescr = pDescr;
@@ -2169,7 +2169,7 @@
 		} /* frame > SK_COPY_TRESHOLD */
 
 #ifdef USE_SK_RX_CHECKSUM
-		pMsg->csum = pRxd->TcpSums;
+		pMsg->csum = pRxd->TcpSums & 0xffff;
 		pMsg->ip_summed = CHECKSUM_HW;
 #else
 		pMsg->ip_summed = CHECKSUM_NONE;
diff -urN linux-2.6.15-rc5/drivers/net/skge.c linux-2.6.15-rc6/drivers/net/skge.c
--- linux-2.6.15-rc5/drivers/net/skge.c	2005-12-18 22:27:55.469647680 -0800
+++ linux-2.6.15-rc6/drivers/net/skge.c	2005-12-18 22:28:04.328042368 -0800
@@ -2280,11 +2280,13 @@
  	}
 
 	if (unlikely(skge->tx_avail < skb_shinfo(skb)->nr_frags +1)) {
-		netif_stop_queue(dev);
-		spin_unlock_irqrestore(&skge->tx_lock, flags);
+		if (!netif_queue_stopped(dev)) {
+			netif_stop_queue(dev);
 
-		printk(KERN_WARNING PFX "%s: ring full when queue awake!\n",
-		       dev->name);
+			printk(KERN_WARNING PFX "%s: ring full when queue awake!\n",
+			       dev->name);
+		}
+		spin_unlock_irqrestore(&skge->tx_lock, flags);
 		return NETDEV_TX_BUSY;
 	}
 
diff -urN linux-2.6.15-rc5/drivers/net/tg3.c linux-2.6.15-rc6/drivers/net/tg3.c
--- linux-2.6.15-rc5/drivers/net/tg3.c	2005-12-18 22:27:55.486648438 -0800
+++ linux-2.6.15-rc6/drivers/net/tg3.c	2005-12-18 22:28:04.346043170 -0800
@@ -68,8 +68,8 @@
 
 #define DRV_MODULE_NAME		"tg3"
 #define PFX DRV_MODULE_NAME	": "
-#define DRV_MODULE_VERSION	"3.43"
-#define DRV_MODULE_RELDATE	"Oct 24, 2005"
+#define DRV_MODULE_VERSION	"3.45"
+#define DRV_MODULE_RELDATE	"Dec 13, 2005"
 
 #define TG3_DEF_MAC_MODE	0
 #define TG3_DEF_RX_MODE		0
@@ -1025,7 +1025,9 @@
 
 
 	if ((tp->tg3_flags & TG3_FLAG_WOL_ENABLE) != 0 ||
-	    (tp_peer->tg3_flags & TG3_FLAG_WOL_ENABLE) != 0) {
+	    (tp->tg3_flags & TG3_FLAG_ENABLE_ASF) != 0 ||
+	    (tp_peer->tg3_flags & TG3_FLAG_WOL_ENABLE) != 0 ||
+	    (tp_peer->tg3_flags & TG3_FLAG_ENABLE_ASF) != 0) {
 		if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5700 ||
 		    GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5701) {
 			tw32_f(GRC_LOCAL_CTRL, tp->grc_local_ctrl |
@@ -1105,6 +1107,8 @@
 
 static void tg3_write_sig_post_reset(struct tg3 *, int);
 static int tg3_halt_cpu(struct tg3 *, u32);
+static int tg3_nvram_lock(struct tg3 *);
+static void tg3_nvram_unlock(struct tg3 *);
 
 static int tg3_set_power_state(struct tg3 *tp, int state)
 {
@@ -1179,6 +1183,21 @@
 		tg3_setup_phy(tp, 0);
 	}
 
+	if (!(tp->tg3_flags & TG3_FLAG_ENABLE_ASF)) {
+		int i;
+		u32 val;
+
+		for (i = 0; i < 200; i++) {
+			tg3_read_mem(tp, NIC_SRAM_FW_ASF_STATUS_MBOX, &val);
+			if (val == ~NIC_SRAM_FIRMWARE_MBOX_MAGIC1)
+				break;
+			msleep(1);
+		}
+	}
+	tg3_write_mem(tp, NIC_SRAM_WOL_MBOX, WOL_SIGNATURE |
+					     WOL_DRV_STATE_SHUTDOWN |
+					     WOL_DRV_WOL | WOL_SET_MAGIC_PKT);
+
 	pci_read_config_word(tp->pdev, pm + PCI_PM_PMC, &power_caps);
 
 	if (tp->tg3_flags & TG3_FLAG_WOL_ENABLE) {
@@ -1268,6 +1287,17 @@
 		}
 	}
 
+	if (!(tp->tg3_flags & TG3_FLAG_WOL_ENABLE) &&
+	    !(tp->tg3_flags & TG3_FLAG_ENABLE_ASF)) {
+		/* Turn off the PHY */
+		if (!(tp->tg3_flags2 & TG3_FLG2_PHY_SERDES)) {
+			tg3_writephy(tp, MII_TG3_EXT_CTRL,
+				     MII_TG3_EXT_CTRL_FORCE_LED_OFF);
+			tg3_writephy(tp, MII_TG3_AUX_CTRL, 0x01b2);
+			tg3_writephy(tp, MII_BMCR, BMCR_PDOWN);
+		}
+	}
+
 	tg3_frob_aux_power(tp);
 
 	/* Workaround for unstable PLL clock */
@@ -1277,8 +1307,12 @@
 
 		val &= ~((1 << 16) | (1 << 4) | (1 << 2) | (1 << 1) | 1);
 		tw32(0x7d00, val);
-		if (!(tp->tg3_flags & TG3_FLAG_ENABLE_ASF))
+		if (!(tp->tg3_flags & TG3_FLAG_ENABLE_ASF)) {
+			tg3_nvram_lock(tp);
 			tg3_halt_cpu(tp, RX_CPU_BASE);
+			tw32_f(NVRAM_SWARB, SWARB_REQ_CLR0);
+			tg3_nvram_unlock(tp);
+		}
 	}
 
 	/* Finally, set the new power state. */
@@ -1812,7 +1846,7 @@
 		}
 	}
 relink:
-	if (current_link_up == 0) {
+	if (current_link_up == 0 || tp->link_config.phy_is_low_power) {
 		u32 tmp;
 
 		tg3_phy_copper_begin(tp);
@@ -3565,12 +3599,15 @@
 	if (!spin_trylock(&tp->tx_lock))
 		return NETDEV_TX_LOCKED; 
 
-	/* This is a hard error, log it. */
 	if (unlikely(TX_BUFFS_AVAIL(tp) <= (skb_shinfo(skb)->nr_frags + 1))) {
-		netif_stop_queue(dev);
+		if (!netif_queue_stopped(dev)) {
+			netif_stop_queue(dev);
+
+			/* This is a hard error, log it. */
+			printk(KERN_ERR PFX "%s: BUG! Tx Ring full when "
+			       "queue awake!\n", dev->name);
+		}
 		spin_unlock(&tp->tx_lock);
-		printk(KERN_ERR PFX "%s: BUG! Tx Ring full when queue awake!\n",
-		       dev->name);
 		return NETDEV_TX_BUSY;
 	}
 
@@ -8530,6 +8567,7 @@
 	    GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5701) {
 		tp->tg3_flags |= TG3_FLAG_NVRAM;
 
+		tg3_nvram_lock(tp);
 		tg3_enable_nvram_access(tp);
 
 		if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5752)
@@ -8540,6 +8578,7 @@
 		tg3_get_nvram_size(tp);
 
 		tg3_disable_nvram_access(tp);
+		tg3_nvram_unlock(tp);
 
 	} else {
 		tp->tg3_flags &= ~(TG3_FLAG_NVRAM | TG3_FLAG_NVRAM_BUFFERED);
@@ -8637,10 +8676,10 @@
 	if (ret == 0)
 		*val = swab32(tr32(NVRAM_RDDATA));
 
-	tg3_nvram_unlock(tp);
-
 	tg3_disable_nvram_access(tp);
 
+	tg3_nvram_unlock(tp);
+
 	return ret;
 }
 
@@ -8725,6 +8764,10 @@
 
 		offset = offset + (pagesize - page_off);
 
+		/* Nvram lock released by tg3_nvram_read() above,
+		 * so need to get it again.
+		 */
+		tg3_nvram_lock(tp);
 		tg3_enable_nvram_access(tp);
 
 		/*
@@ -10434,8 +10477,13 @@
 			break;
 		pci_dev_put(peer);
 	}
-	if (!peer || peer == tp->pdev)
-		BUG();
+	/* 5704 can be configured in single-port mode, set peer to
+	 * tp->pdev in that case.
+	 */
+	if (!peer) {
+		peer = tp->pdev;
+		return peer;
+	}
 
 	/*
 	 * We don't need to keep the refcount elevated; there's no way
@@ -10817,12 +10865,14 @@
 
 	tg3_full_lock(tp, 0);
 	tg3_halt(tp, RESET_KIND_SHUTDOWN, 1);
+	tp->tg3_flags &= ~TG3_FLAG_INIT_COMPLETE;
 	tg3_full_unlock(tp);
 
 	err = tg3_set_power_state(tp, pci_choose_state(pdev, state));
 	if (err) {
 		tg3_full_lock(tp, 0);
 
+		tp->tg3_flags |= TG3_FLAG_INIT_COMPLETE;
 		tg3_init_hw(tp);
 
 		tp->timer.expires = jiffies + tp->timer_offset;
@@ -10856,6 +10906,7 @@
 
 	tg3_full_lock(tp, 0);
 
+	tp->tg3_flags |= TG3_FLAG_INIT_COMPLETE;
 	tg3_init_hw(tp);
 
 	tp->timer.expires = jiffies + tp->timer_offset;
diff -urN linux-2.6.15-rc5/drivers/net/tg3.h linux-2.6.15-rc6/drivers/net/tg3.h
--- linux-2.6.15-rc5/drivers/net/tg3.h	2005-12-18 22:27:55.488648527 -0800
+++ linux-2.6.15-rc6/drivers/net/tg3.h	2005-12-18 22:28:04.348043259 -0800
@@ -1529,6 +1529,12 @@
 #define NIC_SRAM_MAC_ADDR_HIGH_MBOX	0x00000c14
 #define NIC_SRAM_MAC_ADDR_LOW_MBOX	0x00000c18
 
+#define NIC_SRAM_WOL_MBOX		0x00000d30
+#define  WOL_SIGNATURE			 0x474c0000
+#define  WOL_DRV_STATE_SHUTDOWN		 0x00000001
+#define  WOL_DRV_WOL			 0x00000002
+#define  WOL_SET_MAGIC_PKT		 0x00000004
+
 #define NIC_SRAM_DATA_CFG_2		0x00000d38
 
 #define  SHASTA_EXT_LED_MODE_MASK	 0x00018000
@@ -1565,6 +1571,7 @@
 #define MII_TG3_EXT_CTRL		0x10 /* Extended control register */
 #define  MII_TG3_EXT_CTRL_FIFO_ELASTIC	0x0001
 #define  MII_TG3_EXT_CTRL_LNK3_LED_MODE	0x0002
+#define  MII_TG3_EXT_CTRL_FORCE_LED_OFF	0x0008
 #define  MII_TG3_EXT_CTRL_TBI		0x8000
 
 #define MII_TG3_EXT_STAT		0x11 /* Extended status register */
diff -urN linux-2.6.15-rc5/drivers/pci/Makefile linux-2.6.15-rc6/drivers/pci/Makefile
--- linux-2.6.15-rc5/drivers/pci/Makefile	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/pci/Makefile	2005-12-18 22:28:04.475048918 -0800
@@ -6,6 +6,9 @@
 			pci-driver.o search.o pci-sysfs.o rom.o setup-res.o
 obj-$(CONFIG_PROC_FS) += proc.o
 
+# Build PCI Express stuff if needed
+obj-$(CONFIG_PCIEPORTBUS) += pcie/
+
 obj-$(CONFIG_HOTPLUG) += hotplug.o
 
 # Build the PCI Hotplug drivers if we were asked to
@@ -40,7 +43,3 @@
 ifeq ($(CONFIG_PCI_DEBUG),y)
 EXTRA_CFLAGS += -DDEBUG
 endif
-
-# Build PCI Express stuff if needed
-obj-$(CONFIG_PCIEPORTBUS) += pcie/
-
diff -urN linux-2.6.15-rc5/drivers/sbus/char/jsflash.c linux-2.6.15-rc6/drivers/sbus/char/jsflash.c
--- linux-2.6.15-rc5/drivers/sbus/char/jsflash.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/sbus/char/jsflash.c	2005-12-18 22:28:04.585053820 -0800
@@ -249,11 +249,11 @@
 /*
  * OS SIMM Cannot be read in other size but a 32bits word.
  */
-static ssize_t jsf_read(struct file * file, char * buf, 
+static ssize_t jsf_read(struct file * file, char __user * buf, 
     size_t togo, loff_t *ppos)
 {
 	unsigned long p = *ppos;
-	char *tmp = buf;
+	char __user *tmp = buf;
 
 	union byte4 {
 		char s[4];
@@ -305,7 +305,7 @@
 	return tmp-buf;
 }
 
-static ssize_t jsf_write(struct file * file, const char * buf,
+static ssize_t jsf_write(struct file * file, const char __user * buf,
     size_t count, loff_t *ppos)
 {
 	return -ENOSPC;
@@ -356,10 +356,10 @@
  * Program a block of flash.
  * Very simple because we can do it byte by byte anyway.
  */
-static int jsf_ioctl_program(unsigned long arg)
+static int jsf_ioctl_program(void __user *arg)
 {
 	struct jsflash_program_arg abuf;
-	char *uptr;
+	char __user *uptr;
 	unsigned long p;
 	unsigned int togo;
 	union {
@@ -367,13 +367,13 @@
 		char s[4];
 	} b;
 
-	if (copy_from_user(&abuf, (char *)arg, JSFPRGSZ))
+	if (copy_from_user(&abuf, arg, JSFPRGSZ))
 		return -EFAULT; 
 	p = abuf.off;
 	togo = abuf.size;
 	if ((togo & 3) || (p & 3)) return -EINVAL;
 
-	uptr = (char *) (unsigned long) abuf.data;
+	uptr = (char __user *) (unsigned long) abuf.data;
 	while (togo != 0) {
 		togo -= 4;
 		if (copy_from_user(&b.s[0], uptr, 4))
@@ -390,19 +390,20 @@
     unsigned long arg)
 {
 	int error = -ENOTTY;
+	void __user *argp = (void __user *)arg;
 
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 	switch (cmd) {
 	case JSFLASH_IDENT:
-		if (copy_to_user((void *)arg, &jsf0.id, JSFIDSZ))
+		if (copy_to_user(argp, &jsf0.id, JSFIDSZ))
 			return -EFAULT;
 		break;
 	case JSFLASH_ERASE:
 		error = jsf_ioctl_erase(arg);
 		break;
 	case JSFLASH_PROGRAM:
-		error = jsf_ioctl_program(arg);
+		error = jsf_ioctl_program(argp);
 		break;
 	}
 
diff -urN linux-2.6.15-rc5/drivers/sbus/char/uctrl.c linux-2.6.15-rc6/drivers/sbus/char/uctrl.c
--- linux-2.6.15-rc5/drivers/sbus/char/uctrl.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/sbus/char/uctrl.c	2005-12-18 22:28:04.585053820 -0800
@@ -309,7 +309,7 @@
 	}
 }
 
-void uctrl_get_event_status()
+void uctrl_get_event_status(void)
 {
 	struct uctrl_driver *driver = &drv;
 	struct uctrl_txn txn;
@@ -318,7 +318,7 @@
 	txn.opcode = READ_EVENT_STATUS;
 	txn.inbits = 0;
 	txn.outbits = 2;
-	txn.inbuf = 0;
+	txn.inbuf = NULL;
 	txn.outbuf = outbits;
 
 	uctrl_do_txn(&txn);
@@ -329,7 +329,7 @@
 	dprintk(("ev is %x\n", driver->status.event_status));
 }
 
-void uctrl_get_external_status()
+void uctrl_get_external_status(void)
 {
 	struct uctrl_driver *driver = &drv;
 	struct uctrl_txn txn;
@@ -339,7 +339,7 @@
 	txn.opcode = READ_EXTERNAL_STATUS;
 	txn.inbits = 0;
 	txn.outbits = 2;
-	txn.inbuf = 0;
+	txn.inbuf = NULL;
 	txn.outbuf = outbits;
 
 	uctrl_do_txn(&txn);
@@ -414,7 +414,7 @@
 	if (driver->irq)
 		free_irq(driver->irq, driver);
 	if (driver->regs)
-		driver->regs = 0;
+		driver->regs = NULL;
 }
 
 module_init(ts102_uctrl_init);
diff -urN linux-2.6.15-rc5/drivers/sbus/char/vfc.h linux-2.6.15-rc6/drivers/sbus/char/vfc.h
--- linux-2.6.15-rc5/drivers/sbus/char/vfc.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/sbus/char/vfc.h	2005-12-18 22:28:04.586053864 -0800
@@ -125,7 +125,7 @@
 
 
 struct vfc_dev {
-	volatile struct vfc_regs *regs;
+	volatile struct vfc_regs __iomem *regs;
 	struct vfc_regs *phys_regs;
 	unsigned int control_reg;
 	struct semaphore device_lock_sem;
diff -urN linux-2.6.15-rc5/drivers/sbus/char/vfc_dev.c linux-2.6.15-rc6/drivers/sbus/char/vfc_dev.c
--- linux-2.6.15-rc5/drivers/sbus/char/vfc_dev.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/sbus/char/vfc_dev.c	2005-12-18 22:28:04.586053864 -0800
@@ -149,7 +149,7 @@
 	}
 	printk("Initializing vfc%d\n",instance);
 	dev->regs = NULL;
-	dev->regs = (volatile struct vfc_regs *)
+	dev->regs = (volatile struct vfc_regs __iomem *)
 		sbus_ioremap(&sdev->resource[0], 0,
 			     sizeof(struct vfc_regs), vfcstr);
 	dev->which_io = sdev->reg_addrs[0].which_io;
@@ -319,7 +319,7 @@
 	int timeout = 1000;
 
 	while (!timeout--) {
-		if (dev->regs->control & VFC_STATUS_CAPTURE)
+		if (sbus_readl(&dev->regs->control) & VFC_STATUS_CAPTURE)
 			break;
 		vfc_i2c_delay_no_busy(dev, 100);
 	}
@@ -718,7 +718,7 @@
 	if(dev == NULL)
 		return;
 	devfs_remove("vfc/%d", dev->instance);
-	sbus_iounmap((unsigned long)dev->regs, sizeof(struct vfc_regs));
+	sbus_iounmap(dev->regs, sizeof(struct vfc_regs));
 	kfree(dev);
 }
 
diff -urN linux-2.6.15-rc5/drivers/scsi/dpt_i2o.c linux-2.6.15-rc6/drivers/scsi/dpt_i2o.c
--- linux-2.6.15-rc5/drivers/scsi/dpt_i2o.c	2005-12-18 22:27:55.848664567 -0800
+++ linux-2.6.15-rc6/drivers/scsi/dpt_i2o.c	2005-12-18 22:28:04.705059167 -0800
@@ -660,7 +660,12 @@
 	msg[2] = 0;
 	msg[3]= 0; 
 	msg[4] = (u32)cmd;
-	if( (rcode = adpt_i2o_post_wait(pHba, msg, sizeof(msg), FOREVER)) != 0){
+	if (pHba->host)
+		spin_lock_irq(pHba->host->host_lock);
+	rcode = adpt_i2o_post_wait(pHba, msg, sizeof(msg), FOREVER);
+	if (pHba->host)
+		spin_unlock_irq(pHba->host->host_lock);
+	if (rcode != 0) {
 		if(rcode == -EOPNOTSUPP ){
 			printk(KERN_INFO"%s: Abort cmd not supported\n",pHba->name);
 			return FAILED;
@@ -697,10 +702,15 @@
 	msg[2] = 0;
 	msg[3] = 0;
 
+	if (pHba->host)
+		spin_lock_irq(pHba->host->host_lock);
 	old_state = d->state;
 	d->state |= DPTI_DEV_RESET;
-	if( (rcode = adpt_i2o_post_wait(pHba, msg,sizeof(msg), FOREVER)) ){
-		d->state = old_state;
+	rcode = adpt_i2o_post_wait(pHba, msg,sizeof(msg), FOREVER);
+	d->state = old_state;
+	if (pHba->host)
+		spin_unlock_irq(pHba->host->host_lock);
+	if (rcode != 0) {
 		if(rcode == -EOPNOTSUPP ){
 			printk(KERN_INFO"%s: Device reset not supported\n",pHba->name);
 			return FAILED;
@@ -708,7 +718,6 @@
 		printk(KERN_INFO"%s: Device reset failed\n",pHba->name);
 		return FAILED;
 	} else {
-		d->state = old_state;
 		printk(KERN_INFO"%s: Device reset successful\n",pHba->name);
 		return SUCCESS;
 	}
@@ -721,6 +730,7 @@
 {
 	adpt_hba* pHba;
 	u32 msg[4];
+	u32 rcode;
 
 	pHba = (adpt_hba*)cmd->device->host->hostdata[0];
 	memset(msg, 0, sizeof(msg));
@@ -729,7 +739,12 @@
 	msg[1] = (I2O_HBA_BUS_RESET<<24|HOST_TID<<12|pHba->channel[cmd->device->channel].tid);
 	msg[2] = 0;
 	msg[3] = 0;
-	if(adpt_i2o_post_wait(pHba, msg,sizeof(msg), FOREVER) ){
+	if (pHba->host)
+		spin_lock_irq(pHba->host->host_lock);
+	rcode = adpt_i2o_post_wait(pHba, msg,sizeof(msg), FOREVER);
+	if (pHba->host)
+		spin_unlock_irq(pHba->host->host_lock);
+	if (rcode != 0) {
 		printk(KERN_WARNING"%s: Bus reset failed.\n",pHba->name);
 		return FAILED;
 	} else {
diff -urN linux-2.6.15-rc5/drivers/scsi/ibmvscsi/ibmvscsi.h linux-2.6.15-rc6/drivers/scsi/ibmvscsi/ibmvscsi.h
--- linux-2.6.15-rc5/drivers/scsi/ibmvscsi/ibmvscsi.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/scsi/ibmvscsi/ibmvscsi.h	2005-12-18 22:28:04.721059879 -0800
@@ -100,7 +100,7 @@
 void ibmvscsi_release_crq_queue(struct crq_queue *queue,
 				struct ibmvscsi_host_data *hostdata,
 				int max_requests);
-void ibmvscsi_reset_crq_queue(struct crq_queue *queue,
+int ibmvscsi_reset_crq_queue(struct crq_queue *queue,
 			      struct ibmvscsi_host_data *hostdata);
 
 void ibmvscsi_handle_crq(struct viosrp_crq *crq,
diff -urN linux-2.6.15-rc5/drivers/scsi/ibmvscsi/iseries_vscsi.c linux-2.6.15-rc6/drivers/scsi/ibmvscsi/iseries_vscsi.c
--- linux-2.6.15-rc5/drivers/scsi/ibmvscsi/iseries_vscsi.c	2005-12-18 22:27:55.864665280 -0800
+++ linux-2.6.15-rc6/drivers/scsi/ibmvscsi/iseries_vscsi.c	2005-12-18 22:28:04.721059879 -0800
@@ -117,9 +117,10 @@
  *
  * no-op for iSeries
  */
-void ibmvscsi_reset_crq_queue(struct crq_queue *queue,
+int ibmvscsi_reset_crq_queue(struct crq_queue *queue,
 			      struct ibmvscsi_host_data *hostdata)
 {
+	return 0;
 }
 
 /**
diff -urN linux-2.6.15-rc5/drivers/scsi/ibmvscsi/rpa_vscsi.c linux-2.6.15-rc6/drivers/scsi/ibmvscsi/rpa_vscsi.c
--- linux-2.6.15-rc5/drivers/scsi/ibmvscsi/rpa_vscsi.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/drivers/scsi/ibmvscsi/rpa_vscsi.c	2005-12-18 22:28:04.722059924 -0800
@@ -230,6 +230,11 @@
 	rc = plpar_hcall_norets(H_REG_CRQ,
 				vdev->unit_address,
 				queue->msg_token, PAGE_SIZE);
+	if (rc == H_Resource) 
+		/* maybe kexecing and resource is busy. try a reset */
+		rc = ibmvscsi_reset_crq_queue(queue,
+					      hostdata);
+
 	if (rc == 2) {
 		/* Adapter is good, but other end is not ready */
 		printk(KERN_WARNING "ibmvscsi: Partner adapter not ready\n");
@@ -281,7 +286,7 @@
  * @hostdata:	ibmvscsi_host_data of host
  *
  */
-void ibmvscsi_reset_crq_queue(struct crq_queue *queue,
+int ibmvscsi_reset_crq_queue(struct crq_queue *queue,
 			      struct ibmvscsi_host_data *hostdata)
 {
 	int rc;
@@ -309,4 +314,5 @@
 		printk(KERN_WARNING
 		       "ibmvscsi: couldn't register crq--rc 0x%x\n", rc);
 	}
+	return rc;
 }
diff -urN linux-2.6.15-rc5/drivers/scsi/iscsi_tcp.c linux-2.6.15-rc6/drivers/scsi/iscsi_tcp.c
--- linux-2.6.15-rc5/drivers/scsi/iscsi_tcp.c	2005-12-18 22:27:55.887666305 -0800
+++ linux-2.6.15-rc6/drivers/scsi/iscsi_tcp.c	2005-12-18 22:28:04.743060860 -0800
@@ -3368,7 +3368,7 @@
 	switch(param) {
 	case ISCSI_PARAM_MAX_RECV_DLENGTH: {
 		char *saveptr = conn->data;
-		int flags = GFP_KERNEL;
+		gfp_t flags = GFP_KERNEL;
 
 		if (conn->data_size >= value) {
 			conn->max_recv_dlength = value;
diff -urN linux-2.6.15-rc5/drivers/scsi/libata-core.c linux-2.6.15-rc6/drivers/scsi/libata-core.c
--- linux-2.6.15-rc5/drivers/scsi/libata-core.c	2005-12-18 22:27:55.894666617 -0800
+++ linux-2.6.15-rc6/drivers/scsi/libata-core.c	2005-12-18 22:28:04.750061172 -0800
@@ -2443,7 +2443,7 @@
 			struct scatterlist *psg = &qc->pad_sgent;
 			void *addr = kmap_atomic(psg->page, KM_IRQ0);
 			memcpy(addr + psg->offset, pad_buf, qc->pad_len);
-			kunmap_atomic(psg->page, KM_IRQ0);
+			kunmap_atomic(addr, KM_IRQ0);
 		}
 	} else {
 		if (sg_dma_len(&sg[0]) > 0)
@@ -2717,7 +2717,7 @@
 		if (qc->tf.flags & ATA_TFLAG_WRITE) {
 			void *addr = kmap_atomic(psg->page, KM_IRQ0);
 			memcpy(pad_buf, addr + psg->offset, qc->pad_len);
-			kunmap_atomic(psg->page, KM_IRQ0);
+			kunmap_atomic(addr, KM_IRQ0);
 		}
 
 		sg_dma_address(psg) = ap->pad_dma + (qc->tag * ATA_DMA_PAD_SZ);
diff -urN linux-2.6.15-rc5/drivers/scsi/libata-scsi.c linux-2.6.15-rc6/drivers/scsi/libata-scsi.c
--- linux-2.6.15-rc5/drivers/scsi/libata-scsi.c	2005-12-18 22:27:55.898666795 -0800
+++ linux-2.6.15-rc6/drivers/scsi/libata-scsi.c	2005-12-18 22:28:04.753061305 -0800
@@ -2173,9 +2173,12 @@
 	if (unlikely(!ata_dev_present(dev)))
 		return NULL;
 
-	if (!atapi_enabled) {
-		if (unlikely(dev->class == ATA_DEV_ATAPI))
+	if (!atapi_enabled || (ap->flags & ATA_FLAG_NO_ATAPI)) {
+		if (unlikely(dev->class == ATA_DEV_ATAPI)) {
+			printk(KERN_WARNING "ata%u(%u): WARNING: ATAPI is %s, device ignored.\n",
+			       ap->id, dev->devno, atapi_enabled ? "not supported with this driver" : "disabled");
 			return NULL;
+		}
 	}
 
 	return dev;
diff -urN linux-2.6.15-rc5/drivers/scsi/megaraid.c linux-2.6.15-rc6/drivers/scsi/megaraid.c
--- linux-2.6.15-rc5/drivers/scsi/megaraid.c	2005-12-18 22:27:55.917667642 -0800
+++ linux-2.6.15-rc6/drivers/scsi/megaraid.c	2005-12-18 22:28:04.771062107 -0800
@@ -664,7 +664,7 @@
 					sg->offset;
 			} else
 				buf = cmd->request_buffer;
-			memset(cmd->request_buffer, 0, cmd->cmnd[4]);
+			memset(buf, 0, cmd->cmnd[4]);
 			if (cmd->use_sg) {
 				struct scatterlist *sg;
 
diff -urN linux-2.6.15-rc5/drivers/scsi/qla2xxx/qla_def.h linux-2.6.15-rc6/drivers/scsi/qla2xxx/qla_def.h
--- linux-2.6.15-rc5/drivers/scsi/qla2xxx/qla_def.h	2005-12-18 22:27:56.112676330 -0800
+++ linux-2.6.15-rc6/drivers/scsi/qla2xxx/qla_def.h	2005-12-18 22:28:04.961070573 -0800
@@ -2476,17 +2476,9 @@
  */
 #define LOOP_TRANSITION(ha) \
 	(test_bit(ISP_ABORT_NEEDED, &ha->dpc_flags) || \
-	 test_bit(LOOP_RESYNC_NEEDED, &ha->dpc_flags))
-
-#define LOOP_NOT_READY(ha) \
-	((test_bit(ISP_ABORT_NEEDED, &ha->dpc_flags) || \
-	  test_bit(ABORT_ISP_ACTIVE, &ha->dpc_flags) || \
-	  test_bit(LOOP_RESYNC_NEEDED, &ha->dpc_flags) || \
-	  test_bit(LOOP_RESYNC_ACTIVE, &ha->dpc_flags)) || \
+	 test_bit(LOOP_RESYNC_NEEDED, &ha->dpc_flags) || \
 	 atomic_read(&ha->loop_state) == LOOP_DOWN)
 
-#define LOOP_RDY(ha)	(!LOOP_NOT_READY(ha))
-
 #define TGT_Q(ha, t) (ha->otgt[t])
 
 #define to_qla_host(x)		((scsi_qla_host_t *) (x)->hostdata)
diff -urN linux-2.6.15-rc5/drivers/scsi/qla2xxx/qla_init.c linux-2.6.15-rc6/drivers/scsi/qla2xxx/qla_init.c
--- linux-2.6.15-rc5/drivers/scsi/qla2xxx/qla_init.c	2005-12-18 22:27:56.116676509 -0800
+++ linux-2.6.15-rc6/drivers/scsi/qla2xxx/qla_init.c	2005-12-18 22:28:04.965070751 -0800
@@ -1259,7 +1259,7 @@
 	rval = qla2x00_get_adapter_id(ha,
 	    &loop_id, &al_pa, &area, &domain, &topo);
 	if (rval != QLA_SUCCESS) {
-		if (LOOP_NOT_READY(ha) || atomic_read(&ha->loop_down_timer) ||
+		if (LOOP_TRANSITION(ha) || atomic_read(&ha->loop_down_timer) ||
 		    (rval == QLA_COMMAND_ERROR && loop_id == 0x7)) {
 			DEBUG2(printk("%s(%ld) Loop is in a transition state\n",
 			    __func__, ha->host_no));
@@ -1796,7 +1796,7 @@
 	}
 
 	if (rval == QLA_SUCCESS && test_bit(RSCN_UPDATE, &flags)) {
-		if (LOOP_NOT_READY(ha)) {
+		if (LOOP_TRANSITION(ha)) {
 			rval = QLA_FUNCTION_FAILED;
 		} else {
 			rval = qla2x00_configure_fabric(ha);
@@ -2369,7 +2369,7 @@
 		if (qla2x00_is_reserved_id(ha, loop_id))
 			continue;
 
-		if (atomic_read(&ha->loop_down_timer) || LOOP_NOT_READY(ha))
+		if (atomic_read(&ha->loop_down_timer) || LOOP_TRANSITION(ha))
 			break;
 
 		if (swl != NULL) {
diff -urN linux-2.6.15-rc5/drivers/scsi/qla2xxx/qla_isr.c linux-2.6.15-rc6/drivers/scsi/qla2xxx/qla_isr.c
--- linux-2.6.15-rc5/drivers/scsi/qla2xxx/qla_isr.c	2005-12-18 22:27:56.118676598 -0800
+++ linux-2.6.15-rc6/drivers/scsi/qla2xxx/qla_isr.c	2005-12-18 22:28:04.967070841 -0800
@@ -909,6 +909,21 @@
 			resid = resid_len;
 			cp->resid = resid;
 			CMD_RESID_LEN(cp) = resid;
+
+			if (!lscsi_status &&
+			    ((unsigned)(cp->request_bufflen - resid) <
+			     cp->underflow)) {
+				qla_printk(KERN_INFO, ha,
+				    "scsi(%ld:%d:%d:%d): Mid-layer underflow "
+				    "detected (%x of %x bytes)...returning "
+				    "error status.\n", ha->host_no,
+				    cp->device->channel, cp->device->id,
+				    cp->device->lun, resid,
+				    cp->request_bufflen);
+
+				cp->result = DID_ERROR << 16;
+				break;
+			}
 		}
 		cp->result = DID_OK << 16 | lscsi_status;
 
diff -urN linux-2.6.15-rc5/drivers/scsi/sata_mv.c linux-2.6.15-rc6/drivers/scsi/sata_mv.c
--- linux-2.6.15-rc5/drivers/scsi/sata_mv.c	2005-12-18 22:27:56.142677667 -0800
+++ linux-2.6.15-rc6/drivers/scsi/sata_mv.c	2005-12-18 22:28:04.990071865 -0800
@@ -86,7 +86,8 @@
 	MV_FLAG_DUAL_HC		= (1 << 30),  /* two SATA Host Controllers */
 	MV_FLAG_IRQ_COALESCE	= (1 << 29),  /* IRQ coalescing capability */
 	MV_COMMON_FLAGS		= (ATA_FLAG_SATA | ATA_FLAG_NO_LEGACY |
-				   ATA_FLAG_SATA_RESET | ATA_FLAG_MMIO),
+				   ATA_FLAG_SATA_RESET | ATA_FLAG_MMIO |
+				   ATA_FLAG_NO_ATAPI),
 	MV_6XXX_FLAGS		= MV_FLAG_IRQ_COALESCE,
 
 	CRQB_FLAG_READ		= (1 << 0),
diff -urN linux-2.6.15-rc5/drivers/scsi/sata_promise.c linux-2.6.15-rc6/drivers/scsi/sata_promise.c
--- linux-2.6.15-rc5/drivers/scsi/sata_promise.c	2005-12-18 22:27:56.143677712 -0800
+++ linux-2.6.15-rc6/drivers/scsi/sata_promise.c	2005-12-18 22:28:04.992071955 -0800
@@ -70,6 +70,9 @@
 	PDC_HAS_PATA		= (1 << 1), /* PDC20375 has PATA */
 
 	PDC_RESET		= (1 << 11), /* HDMA reset */
+
+	PDC_COMMON_FLAGS	= ATA_FLAG_NO_LEGACY | ATA_FLAG_SRST |
+				  ATA_FLAG_MMIO | ATA_FLAG_NO_ATAPI,
 };
 
 
@@ -162,8 +165,7 @@
 	/* board_2037x */
 	{
 		.sht		= &pdc_ata_sht,
-		.host_flags	= ATA_FLAG_SATA | ATA_FLAG_NO_LEGACY |
-				  ATA_FLAG_SRST | ATA_FLAG_MMIO,
+		.host_flags	= PDC_COMMON_FLAGS | ATA_FLAG_SATA,
 		.pio_mask	= 0x1f, /* pio0-4 */
 		.mwdma_mask	= 0x07, /* mwdma0-2 */
 		.udma_mask	= 0x7f, /* udma0-6 ; FIXME */
@@ -173,8 +175,7 @@
 	/* board_20319 */
 	{
 		.sht		= &pdc_ata_sht,
-		.host_flags	= ATA_FLAG_SATA | ATA_FLAG_NO_LEGACY |
-				  ATA_FLAG_SRST | ATA_FLAG_MMIO,
+		.host_flags	= PDC_COMMON_FLAGS | ATA_FLAG_SATA,
 		.pio_mask	= 0x1f, /* pio0-4 */
 		.mwdma_mask	= 0x07, /* mwdma0-2 */
 		.udma_mask	= 0x7f, /* udma0-6 ; FIXME */
@@ -184,8 +185,7 @@
 	/* board_20619 */
 	{
 		.sht		= &pdc_ata_sht,
-		.host_flags	= ATA_FLAG_NO_LEGACY | ATA_FLAG_SRST |
-				  ATA_FLAG_MMIO | ATA_FLAG_SLAVE_POSS,
+		.host_flags	= PDC_COMMON_FLAGS | ATA_FLAG_SLAVE_POSS,
 		.pio_mask	= 0x1f, /* pio0-4 */
 		.mwdma_mask	= 0x07, /* mwdma0-2 */
 		.udma_mask	= 0x7f, /* udma0-6 ; FIXME */
diff -urN linux-2.6.15-rc5/drivers/scsi/sata_sx4.c linux-2.6.15-rc6/drivers/scsi/sata_sx4.c
--- linux-2.6.15-rc5/drivers/scsi/sata_sx4.c	2005-12-18 22:27:56.149677979 -0800
+++ linux-2.6.15-rc6/drivers/scsi/sata_sx4.c	2005-12-18 22:28:04.997072177 -0800
@@ -220,7 +220,8 @@
 	{
 		.sht		= &pdc_sata_sht,
 		.host_flags	= ATA_FLAG_SATA | ATA_FLAG_NO_LEGACY |
-				  ATA_FLAG_SRST | ATA_FLAG_MMIO,
+				  ATA_FLAG_SRST | ATA_FLAG_MMIO |
+				  ATA_FLAG_NO_ATAPI,
 		.pio_mask	= 0x1f, /* pio0-4 */
 		.mwdma_mask	= 0x07, /* mwdma0-2 */
 		.udma_mask	= 0x7f, /* udma0-6 ; FIXME */
diff -urN linux-2.6.15-rc5/drivers/scsi/scsi_error.c linux-2.6.15-rc6/drivers/scsi/scsi_error.c
--- linux-2.6.15-rc5/drivers/scsi/scsi_error.c	2005-12-18 22:27:56.154678202 -0800
+++ linux-2.6.15-rc6/drivers/scsi/scsi_error.c	2005-12-18 22:28:05.002072400 -0800
@@ -422,10 +422,15 @@
  **/
 static void scsi_eh_done(struct scsi_cmnd *scmd)
 {
+	struct completion     *eh_action;
+
 	SCSI_LOG_ERROR_RECOVERY(3,
 		printk("%s scmd: %p result: %x\n",
 			__FUNCTION__, scmd, scmd->result));
-	complete(scmd->device->host->eh_action);
+
+	eh_action = scmd->device->host->eh_action;
+	if (eh_action)
+		complete(eh_action);
 }
 
 /**
diff -urN linux-2.6.15-rc5/drivers/scsi/scsi_lib.c linux-2.6.15-rc6/drivers/scsi/scsi_lib.c
--- linux-2.6.15-rc5/drivers/scsi/scsi_lib.c	2005-12-18 22:27:56.156678291 -0800
+++ linux-2.6.15-rc6/drivers/scsi/scsi_lib.c	2005-12-18 22:28:05.004072489 -0800
@@ -542,10 +542,17 @@
 
 void scsi_next_command(struct scsi_cmnd *cmd)
 {
-	struct request_queue *q = cmd->device->request_queue;
+	struct scsi_device *sdev = cmd->device;
+	struct request_queue *q = sdev->request_queue;
+
+	/* need to hold a reference on the device before we let go of the cmd */
+	get_device(&sdev->sdev_gendev);
 
 	scsi_put_command(cmd);
 	scsi_run_queue(q);
+
+	/* ok to remove device now */
+	put_device(&sdev->sdev_gendev);
 }
 
 void scsi_run_host_queues(struct Scsi_Host *shost)
@@ -1078,6 +1085,26 @@
 	scsi_io_completion(cmd, cmd->result == 0 ? cmd->bufflen : 0, 0);
 }
 
+void scsi_setup_blk_pc_cmnd(struct scsi_cmnd *cmd, int retries)
+{
+	struct request *req = cmd->request;
+
+	BUG_ON(sizeof(req->cmd) > sizeof(cmd->cmnd));
+	memcpy(cmd->cmnd, req->cmd, sizeof(cmd->cmnd));
+	cmd->cmd_len = req->cmd_len;
+	if (!req->data_len)
+		cmd->sc_data_direction = DMA_NONE;
+	else if (rq_data_dir(req) == WRITE)
+		cmd->sc_data_direction = DMA_TO_DEVICE;
+	else
+		cmd->sc_data_direction = DMA_FROM_DEVICE;
+	
+	cmd->transfersize = req->data_len;
+	cmd->allowed = retries;
+	cmd->timeout_per_command = req->timeout;
+}
+EXPORT_SYMBOL_GPL(scsi_setup_blk_pc_cmnd);
+
 static int scsi_prep_fn(struct request_queue *q, struct request *req)
 {
 	struct scsi_device *sdev = q->queuedata;
@@ -1213,18 +1240,7 @@
 				goto kill;
 			}
 		} else {
-			memcpy(cmd->cmnd, req->cmd, sizeof(cmd->cmnd));
-			cmd->cmd_len = req->cmd_len;
-			if (rq_data_dir(req) == WRITE)
-				cmd->sc_data_direction = DMA_TO_DEVICE;
-			else if (req->data_len)
-				cmd->sc_data_direction = DMA_FROM_DEVICE;
-			else
-				cmd->sc_data_direction = DMA_NONE;
-			
-			cmd->transfersize = req->data_len;
-			cmd->allowed = 3;
-			cmd->timeout_per_command = req->timeout;
+			scsi_setup_blk_pc_cmnd(cmd, 3);
 			cmd->done = scsi_generic_done;
 		}
 	}
diff -urN linux-2.6.15-rc5/drivers/scsi/scsi_scan.c linux-2.6.15-rc6/drivers/scsi/scsi_scan.c
--- linux-2.6.15-rc5/drivers/scsi/scsi_scan.c	2005-12-18 22:27:56.158678380 -0800
+++ linux-2.6.15-rc6/drivers/scsi/scsi_scan.c	2005-12-18 22:28:05.005072534 -0800
@@ -266,8 +266,6 @@
 			/*
 			 * if LLDD reports slave not present, don't clutter
 			 * console with alloc failure messages
-
-
 			 */
 			if (ret == -ENXIO)
 				display_failure_msg = 0;
@@ -279,7 +277,6 @@
 
 out_device_destroy:
 	transport_destroy_device(&sdev->sdev_gendev);
-	scsi_free_queue(sdev->request_queue);
 	put_device(&sdev->sdev_gendev);
 out:
 	if (display_failure_msg)
diff -urN linux-2.6.15-rc5/drivers/scsi/scsi_transport_iscsi.c linux-2.6.15-rc6/drivers/scsi/scsi_transport_iscsi.c
--- linux-2.6.15-rc5/drivers/scsi/scsi_transport_iscsi.c	2005-12-18 22:27:56.163678603 -0800
+++ linux-2.6.15-rc6/drivers/scsi/scsi_transport_iscsi.c	2005-12-18 22:28:05.010072757 -0800
@@ -249,7 +249,7 @@
 }
 
 static void*
-mempool_zone_alloc_skb(unsigned int gfp_mask, void *pool_data)
+mempool_zone_alloc_skb(gfp_t gfp_mask, void *pool_data)
 {
 	struct mempool_zone *zone = pool_data;
 
diff -urN linux-2.6.15-rc5/drivers/scsi/sd.c linux-2.6.15-rc6/drivers/scsi/sd.c
--- linux-2.6.15-rc5/drivers/scsi/sd.c	2005-12-18 22:27:56.166678736 -0800
+++ linux-2.6.15-rc6/drivers/scsi/sd.c	2005-12-18 22:28:05.013072890 -0800
@@ -245,24 +245,10 @@
 	 * SG_IO from block layer already setup, just copy cdb basically
 	 */
 	if (blk_pc_request(rq)) {
-		if (sizeof(rq->cmd) > sizeof(SCpnt->cmnd))
-			return 0;
-
-		memcpy(SCpnt->cmnd, rq->cmd, sizeof(SCpnt->cmnd));
-		SCpnt->cmd_len = rq->cmd_len;
-		if (rq_data_dir(rq) == WRITE)
-			SCpnt->sc_data_direction = DMA_TO_DEVICE;
-		else if (rq->data_len)
-			SCpnt->sc_data_direction = DMA_FROM_DEVICE;
-		else
-			SCpnt->sc_data_direction = DMA_NONE;
-
-		this_count = rq->data_len;
+		scsi_setup_blk_pc_cmnd(SCpnt, SD_PASSTHROUGH_RETRIES);
 		if (rq->timeout)
 			timeout = rq->timeout;
 
-		SCpnt->transfersize = rq->data_len;
-		SCpnt->allowed = SD_PASSTHROUGH_RETRIES;
 		goto queue;
 	}
 
diff -urN linux-2.6.15-rc5/drivers/scsi/sr.c linux-2.6.15-rc6/drivers/scsi/sr.c
--- linux-2.6.15-rc5/drivers/scsi/sr.c	2005-12-18 22:27:56.171678959 -0800
+++ linux-2.6.15-rc6/drivers/scsi/sr.c	2005-12-18 22:28:05.019073158 -0800
@@ -320,25 +320,11 @@
 	 * these are already setup, just copy cdb basically
 	 */
 	if (SCpnt->request->flags & REQ_BLOCK_PC) {
-		struct request *rq = SCpnt->request;
+		scsi_setup_blk_pc_cmnd(SCpnt, MAX_RETRIES);
 
-		if (sizeof(rq->cmd) > sizeof(SCpnt->cmnd))
-			return 0;
-
-		memcpy(SCpnt->cmnd, rq->cmd, sizeof(SCpnt->cmnd));
-		SCpnt->cmd_len = rq->cmd_len;
-		if (!rq->data_len)
-			SCpnt->sc_data_direction = DMA_NONE;
-		else if (rq_data_dir(rq) == WRITE)
-			SCpnt->sc_data_direction = DMA_TO_DEVICE;
-		else
-			SCpnt->sc_data_direction = DMA_FROM_DEVICE;
-
-		this_count = rq->data_len;
-		if (rq->timeout)
-			timeout = rq->timeout;
+		if (SCpnt->timeout_per_command)
+			timeout = SCpnt->timeout_per_command;
 
-		SCpnt->transfersize = rq->data_len;
 		goto queue;
 	}
 
diff -urN linux-2.6.15-rc5/drivers/scsi/st.c linux-2.6.15-rc6/drivers/scsi/st.c
--- linux-2.6.15-rc5/drivers/scsi/st.c	2005-12-18 22:27:56.174679093 -0800
+++ linux-2.6.15-rc6/drivers/scsi/st.c	2005-12-18 22:28:05.021073247 -0800
@@ -4194,27 +4194,10 @@
  */
 static int st_init_command(struct scsi_cmnd *SCpnt)
 {
-	struct request *rq;
-
 	if (!(SCpnt->request->flags & REQ_BLOCK_PC))
 		return 0;
 
-	rq = SCpnt->request;
-	if (sizeof(rq->cmd) > sizeof(SCpnt->cmnd))
-		return 0;
-
-	memcpy(SCpnt->cmnd, rq->cmd, sizeof(SCpnt->cmnd));
-	SCpnt->cmd_len = rq->cmd_len;
-
-	if (rq_data_dir(rq) == WRITE)
-		SCpnt->sc_data_direction = DMA_TO_DEVICE;
-	else if (rq->data_len)
-		SCpnt->sc_data_direction = DMA_FROM_DEVICE;
-	else
-		SCpnt->sc_data_direction = DMA_NONE;
-
-	SCpnt->timeout_per_command = rq->timeout;
-	SCpnt->transfersize = rq->data_len;
+	scsi_setup_blk_pc_cmnd(SCpnt, 0);
 	SCpnt->done = st_intr;
 	return 1;
 }
diff -urN linux-2.6.15-rc5/drivers/scsi/sym53c8xx_2/sym_hipd.c linux-2.6.15-rc6/drivers/scsi/sym53c8xx_2/sym_hipd.c
--- linux-2.6.15-rc5/drivers/scsi/sym53c8xx_2/sym_hipd.c	2005-12-18 22:27:56.182679449 -0800
+++ linux-2.6.15-rc6/drivers/scsi/sym53c8xx_2/sym_hipd.c	2005-12-18 22:28:05.029073603 -0800
@@ -1405,7 +1405,6 @@
 		goal->iu = 0;
 		goal->dt = 0;
 		goal->qas = 0;
-		goal->period = 0;
 		goal->offset = 0;
 		return;
 	}
@@ -1465,7 +1464,8 @@
 	 * Many devices implement PPR in a buggy way, so only use it if we
 	 * really want to.
 	 */
-	if (goal->iu || goal->dt || goal->qas || (goal->period < 0xa)) {
+	if (goal->offset &&
+	    (goal->iu || goal->dt || goal->qas || (goal->period < 0xa))) {
 		nego = NS_PPR;
 	} else if (spi_width(starget) != goal->width) {
 		nego = NS_WIDE;
diff -urN linux-2.6.15-rc5/drivers/serial/8250_pci.c linux-2.6.15-rc6/drivers/serial/8250_pci.c
--- linux-2.6.15-rc5/drivers/serial/8250_pci.c	2005-12-18 22:27:56.195680029 -0800
+++ linux-2.6.15-rc6/drivers/serial/8250_pci.c	2005-12-18 22:28:05.041074138 -0800
@@ -516,7 +516,7 @@
 		break;
 	case 3:
 		offset = board->uart_offset;
-		bar = 1;
+		/* FALLTHROUGH */
 	case 4: /* BAR 2 */
 	case 5: /* BAR 3 */
 	case 6: /* BAR 4 */
diff -urN linux-2.6.15-rc5/drivers/usb/host/uhci-hcd.c linux-2.6.15-rc6/drivers/usb/host/uhci-hcd.c
--- linux-2.6.15-rc5/drivers/usb/host/uhci-hcd.c	2005-12-18 22:27:56.276683638 -0800
+++ linux-2.6.15-rc6/drivers/usb/host/uhci-hcd.c	2005-12-18 22:28:05.122077747 -0800
@@ -717,6 +717,7 @@
 	 * at the source, so we must turn off PIRQ.
 	 */
 	pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP, 0);
+	mb();
 	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
 	uhci->hc_inaccessible = 1;
 	hcd->poll_rh = 0;
@@ -738,6 +739,7 @@
 	 * really don't want to keep a stale HCD_FLAG_HW_ACCESSIBLE=0
 	 */
 	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+	mb();
 
 	if (uhci->rh_state == UHCI_RH_RESET)	/* Dead */
 		return 0;
diff -urN linux-2.6.15-rc5/drivers/usb/input/hid-core.c linux-2.6.15-rc6/drivers/usb/input/hid-core.c
--- linux-2.6.15-rc5/drivers/usb/input/hid-core.c	2005-12-18 22:27:56.285684039 -0800
+++ linux-2.6.15-rc6/drivers/usb/input/hid-core.c	2005-12-18 22:28:05.131078148 -0800
@@ -893,8 +893,10 @@
 
 	size = ((report->size - 1) >> 3) + 1;
 
-	if (len < size)
+	if (len < size) {
 		dbg("report %d is too short, (%d < %d)", report->id, len, size);
+		memset(data + len, 0, size - len);
+	}
 
 	if (hid->claimed & HID_CLAIMED_HIDDEV)
 		hiddev_report_event(hid, report);
diff -urN linux-2.6.15-rc5/drivers/usb/input/hid-input.c linux-2.6.15-rc6/drivers/usb/input/hid-input.c
--- linux-2.6.15-rc5/drivers/usb/input/hid-input.c	2005-12-18 22:27:56.286684083 -0800
+++ linux-2.6.15-rc6/drivers/usb/input/hid-input.c	2005-12-18 22:28:05.132078193 -0800
@@ -137,6 +137,7 @@
 			switch (usage->hid & 0xffff) {
 				case 0xba: map_abs(ABS_RUDDER); break;
 				case 0xbb: map_abs(ABS_THROTTLE); break;
+				default:   goto ignore;
 			}
 			break;
 
diff -urN linux-2.6.15-rc5/drivers/usb/misc/auerswald.c linux-2.6.15-rc6/drivers/usb/misc/auerswald.c
--- linux-2.6.15-rc5/drivers/usb/misc/auerswald.c	2005-12-18 22:27:56.304684885 -0800
+++ linux-2.6.15-rc6/drivers/usb/misc/auerswald.c	2005-12-18 22:28:05.149078950 -0800
@@ -1696,7 +1696,7 @@
 	int ret;
 	wait_queue_t wait;
 
-        dbg ("auerchar_write %d bytes", len);
+        dbg ("auerchar_write %zd bytes", len);
 
 	/* Error checking */
 	if (!ccp)
diff -urN linux-2.6.15-rc5/drivers/video/arcfb.c linux-2.6.15-rc6/drivers/video/arcfb.c
--- linux-2.6.15-rc5/drivers/video/arcfb.c	2005-12-18 22:27:56.359687336 -0800
+++ linux-2.6.15-rc6/drivers/video/arcfb.c	2005-12-18 22:28:05.205081445 -0800
@@ -441,7 +441,7 @@
  * the fb. it's inefficient for them to do anything less than 64*8
  * writes since we update the lcd in each write() anyway.
  */
-static ssize_t arcfb_write(struct file *file, const char *buf, size_t count,
+static ssize_t arcfb_write(struct file *file, const char __user *buf, size_t count,
 				loff_t *ppos)
 {
 	/* modded from epson 1355 */
diff -urN linux-2.6.15-rc5/drivers/video/bw2.c linux-2.6.15-rc6/drivers/video/bw2.c
--- linux-2.6.15-rc5/drivers/video/bw2.c	2005-12-18 22:27:56.372687915 -0800
+++ linux-2.6.15-rc6/drivers/video/bw2.c	2005-12-18 22:28:05.215081891 -0800
@@ -121,7 +121,6 @@
 	unsigned long		fbsize;
 
 	struct sbus_dev		*sdev;
-	struct list_head	list;
 };
 
 /**
diff -urN linux-2.6.15-rc5/drivers/video/cfbcopyarea.c linux-2.6.15-rc6/drivers/video/cfbcopyarea.c
--- linux-2.6.15-rc5/drivers/video/cfbcopyarea.c	2005-12-18 22:27:56.373687960 -0800
+++ linux-2.6.15-rc6/drivers/video/cfbcopyarea.c	2005-12-18 22:28:05.216081935 -0800
@@ -64,8 +64,8 @@
 	int const shift = dst_idx-src_idx;
 	int left, right;
 
-	first = ~0UL >> dst_idx;
-	last = ~(~0UL >> ((dst_idx+n) % bits));
+	first = FB_SHIFT_HIGH(~0UL, dst_idx);
+	last = ~(FB_SHIFT_HIGH(~0UL, (dst_idx+n) % bits));
 
 	if (!shift) {
 		// Same alignment for source and dest
@@ -216,8 +216,8 @@
 
 	shift = dst_idx-src_idx;
 
-	first = ~0UL << (bits - 1 - dst_idx);
-	last = ~(~0UL << (bits - 1 - ((dst_idx-n) % bits)));
+	first = FB_SHIFT_LOW(~0UL, bits - 1 - dst_idx);
+	last = ~(FB_SHIFT_LOW(~0UL, bits - 1 - ((dst_idx-n) % bits)));
 
 	if (!shift) {
 		// Same alignment for source and dest
diff -urN linux-2.6.15-rc5/drivers/video/cfbfillrect.c linux-2.6.15-rc6/drivers/video/cfbfillrect.c
--- linux-2.6.15-rc5/drivers/video/cfbfillrect.c	2005-12-18 22:27:56.373687960 -0800
+++ linux-2.6.15-rc6/drivers/video/cfbfillrect.c	2005-12-18 22:28:05.216081935 -0800
@@ -110,8 +110,8 @@
 	if (!n)
 		return;
 
-	first = ~0UL >> dst_idx;
-	last = ~(~0UL >> ((dst_idx+n) % bits));
+	first = FB_SHIFT_HIGH(~0UL, dst_idx);
+	last = ~(FB_SHIFT_HIGH(~0UL, (dst_idx+n) % bits));
 
 	if (dst_idx+n <= bits) {
 		// Single word
@@ -167,8 +167,8 @@
 	if (!n)
 		return;
 
-	first = ~0UL >> dst_idx;
-	last = ~(~0UL >> ((dst_idx+n) % bits));
+	first = FB_SHIFT_HIGH(~0UL, dst_idx);
+	last = ~(FB_SHIFT_HIGH(~0UL, (dst_idx+n) % bits));
 
 	if (dst_idx+n <= bits) {
 		// Single word
@@ -221,8 +221,8 @@
 	if (!n)
 		return;
 
-	first = ~0UL >> dst_idx;
-	last = ~(~0UL >> ((dst_idx+n) % bits));
+	first = FB_SHIFT_HIGH(~0UL, dst_idx);
+	last = ~(FB_SHIFT_HIGH(~0UL, (dst_idx+n) % bits));
 
 	if (dst_idx+n <= bits) {
 		// Single word
@@ -290,8 +290,8 @@
 	if (!n)
 		return;
 
-	first = ~0UL >> dst_idx;
-	last = ~(~0UL >> ((dst_idx+n) % bits));
+	first = FB_SHIFT_HIGH(~0UL, dst_idx);
+	last = ~(FB_SHIFT_HIGH(~0UL, (dst_idx+n) % bits));
 
 	if (dst_idx+n <= bits) {
 		// Single word
diff -urN linux-2.6.15-rc5/drivers/video/cfbimgblt.c linux-2.6.15-rc6/drivers/video/cfbimgblt.c
--- linux-2.6.15-rc5/drivers/video/cfbimgblt.c	2005-12-18 22:27:56.373687960 -0800
+++ linux-2.6.15-rc6/drivers/video/cfbimgblt.c	2005-12-18 22:28:05.216081935 -0800
@@ -76,18 +76,6 @@
 #define FB_WRITEL fb_writel
 #define FB_READL  fb_readl
 
-#if defined (__BIG_ENDIAN)
-#define LEFT_POS(bpp)          (32 - bpp)
-#define SHIFT_HIGH(val, bits)  ((val) >> (bits))
-#define SHIFT_LOW(val, bits)   ((val) << (bits))
-#define BIT_NR(b)              (7 - (b))
-#else
-#define LEFT_POS(bpp)          (0)
-#define SHIFT_HIGH(val, bits)  ((val) << (bits))
-#define SHIFT_LOW(val, bits)   ((val) >> (bits))
-#define BIT_NR(b)              (b)
-#endif
-
 static inline void color_imageblit(const struct fb_image *image, 
 				   struct fb_info *p, u8 __iomem *dst1, 
 				   u32 start_index,
@@ -109,7 +97,7 @@
 		val = 0;
 		
 		if (start_index) {
-			u32 start_mask = ~(SHIFT_HIGH(~(u32)0, start_index));
+			u32 start_mask = ~(FB_SHIFT_HIGH(~(u32)0, start_index));
 			val = FB_READL(dst) & start_mask;
 			shift = start_index;
 		}
@@ -119,20 +107,20 @@
 				color = palette[*src];
 			else
 				color = *src;
-			color <<= LEFT_POS(bpp);
-			val |= SHIFT_HIGH(color, shift);
+			color <<= FB_LEFT_POS(bpp);
+			val |= FB_SHIFT_HIGH(color, shift);
 			if (shift >= null_bits) {
 				FB_WRITEL(val, dst++);
 	
 				val = (shift == null_bits) ? 0 : 
-					SHIFT_LOW(color, 32 - shift);
+					FB_SHIFT_LOW(color, 32 - shift);
 			}
 			shift += bpp;
 			shift &= (32 - 1);
 			src++;
 		}
 		if (shift) {
-			u32 end_mask = SHIFT_HIGH(~(u32)0, shift);
+			u32 end_mask = FB_SHIFT_HIGH(~(u32)0, shift);
 
 			FB_WRITEL((FB_READL(dst) & end_mask) | val, dst);
 		}
@@ -162,6 +150,8 @@
 	u32 i, j, l;
 	
 	dst2 = (u32 __iomem *) dst1;
+	fgcolor <<= FB_LEFT_POS(bpp);
+	bgcolor <<= FB_LEFT_POS(bpp);
 
 	for (i = image->height; i--; ) {
 		shift = val = 0;
@@ -172,22 +162,21 @@
 
 		/* write leading bits */
 		if (start_index) {
-			u32 start_mask = ~(SHIFT_HIGH(~(u32)0, start_index));
+			u32 start_mask = ~(FB_SHIFT_HIGH(~(u32)0,start_index));
 			val = FB_READL(dst) & start_mask;
 			shift = start_index;
 		}
 
 		while (j--) {
 			l--;
-			color = (*s & 1 << (BIT_NR(l))) ? fgcolor : bgcolor;
-			color <<= LEFT_POS(bpp);
-			val |= SHIFT_HIGH(color, shift);
+			color = (*s & 1 << (FB_BIT_NR(l))) ? fgcolor : bgcolor;
+			val |= FB_SHIFT_HIGH(color, shift);
 			
 			/* Did the bitshift spill bits to the next long? */
 			if (shift >= null_bits) {
 				FB_WRITEL(val, dst++);
 				val = (shift == null_bits) ? 0 :
-					 SHIFT_LOW(color,32 - shift);
+					FB_SHIFT_LOW(color,32 - shift);
 			}
 			shift += bpp;
 			shift &= (32 - 1);
@@ -196,7 +185,7 @@
 
 		/* write trailing bits */
  		if (shift) {
-			u32 end_mask = SHIFT_HIGH(~(u32)0, shift);
+			u32 end_mask = FB_SHIFT_HIGH(~(u32)0, shift);
 
 			FB_WRITEL((FB_READL(dst) & end_mask) | val, dst);
 		}
diff -urN linux-2.6.15-rc5/drivers/video/cg14.c linux-2.6.15-rc6/drivers/video/cg14.c
--- linux-2.6.15-rc5/drivers/video/cg14.c	2005-12-18 22:27:56.374688004 -0800
+++ linux-2.6.15-rc6/drivers/video/cg14.c	2005-12-18 22:28:05.217081980 -0800
@@ -206,7 +206,6 @@
 	int			mode;
 	int			ramsize;
 	struct sbus_dev		*sdev;
-	struct list_head	list;
 };
 
 static void __cg14_reset(struct cg14_par *par)
diff -urN linux-2.6.15-rc5/drivers/video/cg3.c linux-2.6.15-rc6/drivers/video/cg3.c
--- linux-2.6.15-rc5/drivers/video/cg3.c	2005-12-18 22:27:56.374688004 -0800
+++ linux-2.6.15-rc6/drivers/video/cg3.c	2005-12-18 22:28:05.217081980 -0800
@@ -124,7 +124,6 @@
 	unsigned long		fbsize;
 
 	struct sbus_dev		*sdev;
-	struct list_head	list;
 };
 
 /**
diff -urN linux-2.6.15-rc5/drivers/video/cg6.c linux-2.6.15-rc6/drivers/video/cg6.c
--- linux-2.6.15-rc5/drivers/video/cg6.c	2005-12-18 22:27:56.375688049 -0800
+++ linux-2.6.15-rc6/drivers/video/cg6.c	2005-12-18 22:28:05.218082025 -0800
@@ -265,7 +265,6 @@
 	unsigned long		fbsize;
 
 	struct sbus_dev		*sdev;
-	struct list_head	list;
 };
 
 static int cg6_sync(struct fb_info *info)
@@ -612,7 +611,7 @@
 	struct cg6_par *par = (struct cg6_par *) info->par;
 	struct cg6_tec __iomem *tec = par->tec;
 	struct cg6_fbc __iomem *fbc = par->fbc;
-	u32 rev, conf, mode, tmp;
+	u32 rev, conf, mode;
 	int i;
 	
 	/* Turn off stuff in the Transform Engine. */
diff -urN linux-2.6.15-rc5/drivers/video/console/fbcon.c linux-2.6.15-rc6/drivers/video/console/fbcon.c
--- linux-2.6.15-rc5/drivers/video/console/fbcon.c	2005-12-18 22:27:56.381688316 -0800
+++ linux-2.6.15-rc6/drivers/video/console/fbcon.c	2005-12-18 22:28:05.224082292 -0800
@@ -2048,7 +2048,7 @@
 	struct fbcon_ops *ops;
 	struct display *p = &fb_display[vc->vc_num];
 	struct fb_var_screeninfo var;
-	int i, prev_console;
+	int i, prev_console, charcnt = 256;
 
 	info = registered_fb[con2fb_map[vc->vc_num]];
 	ops = info->fbcon_par;
@@ -2103,7 +2103,8 @@
 	fb_set_var(info, &var);
 	ops->var = info->var;
 
-	if (old_info != NULL && old_info != info) {
+	if (old_info != NULL && (old_info != info ||
+				 info->flags & FBINFO_MISC_ALWAYS_SETPAR)) {
 		if (info->fbops->fb_set_par)
 			info->fbops->fb_set_par(info);
 		fbcon_del_cursor_timer(old_info);
@@ -2120,6 +2121,13 @@
 
 	vc->vc_can_do_color = (fb_get_color_depth(&info->var, &info->fix)!=1);
 	vc->vc_complement_mask = vc->vc_can_do_color ? 0x7700 : 0x0800;
+
+	if (p->userfont)
+		charcnt = FNTCHARCNT(vc->vc_font.data);
+
+	if (charcnt > 256)
+		vc->vc_complement_mask <<= 1;
+
 	updatescrollmode(p, info, vc);
 
 	switch (p->scrollmode) {
@@ -2139,8 +2147,12 @@
 
 	scrollback_max = 0;
 	scrollback_current = 0;
-	ops->var.xoffset = ops->var.yoffset = p->yscroll = 0;
-	ops->update_start(info);
+
+	if (!fbcon_is_inactive(vc, info)) {
+	    ops->var.xoffset = ops->var.yoffset = p->yscroll = 0;
+	    ops->update_start(info);
+	}
+
 	fbcon_set_palette(vc, color_table); 	
 	fbcon_clear_margins(vc, 0);
 
@@ -2184,11 +2196,14 @@
 		ops->graphics = 1;
 
 		if (!blank) {
+			if (info->fbops->fb_save_state)
+				info->fbops->fb_save_state(info);
 			var.activate = FB_ACTIVATE_NOW | FB_ACTIVATE_FORCE;
 			fb_set_var(info, &var);
 			ops->graphics = 0;
 			ops->var = info->var;
-		}
+		} else if (info->fbops->fb_restore_state)
+			info->fbops->fb_restore_state(info);
 	}
 
  	if (!fbcon_is_inactive(vc, info)) {
@@ -2736,8 +2751,12 @@
 		updatescrollmode(p, info, vc);
 		scrollback_max = 0;
 		scrollback_current = 0;
-		ops->var.xoffset = ops->var.yoffset = p->yscroll = 0;
-		ops->update_start(info);
+
+		if (!fbcon_is_inactive(vc, info)) {
+		    ops->var.xoffset = ops->var.yoffset = p->yscroll = 0;
+		    ops->update_start(info);
+		}
+
 		fbcon_set_palette(vc, color_table);
 		update_screen(vc);
 		if (softback_buf)
@@ -2774,8 +2793,13 @@
 			updatescrollmode(p, info, vc);
 			scrollback_max = 0;
 			scrollback_current = 0;
-			ops->var.xoffset = ops->var.yoffset = p->yscroll = 0;
-			ops->update_start(info);
+
+			if (!fbcon_is_inactive(vc, info)) {
+			    ops->var.xoffset = ops->var.yoffset =
+				p->yscroll = 0;
+			    ops->update_start(info);
+			}
+
 			fbcon_set_palette(vc, color_table);
 			update_screen(vc);
 			if (softback_buf)
diff -urN linux-2.6.15-rc5/drivers/video/cyber2000fb.c linux-2.6.15-rc6/drivers/video/cyber2000fb.c
--- linux-2.6.15-rc5/drivers/video/cyber2000fb.c	2005-12-18 22:27:56.389688673 -0800
+++ linux-2.6.15-rc6/drivers/video/cyber2000fb.c	2005-12-18 22:28:05.232082648 -0800
@@ -1512,7 +1512,7 @@
 	 * I/O cycles storing into a reserved memory space at
 	 * physical address 0x3000000
 	 */
-	unsigned char *iop;
+	unsigned char __iomem *iop;
 
 	iop = ioremap(0x3000000, 0x5000);
 	if (iop == NULL) {
@@ -1526,7 +1526,7 @@
 	writeb(EXT_BIU_MISC, iop + 0x3ce);
 	writeb(EXT_BIU_MISC_LIN_ENABLE, iop + 0x3cf);
 
-	iounmap((void *)iop);
+	iounmap(iop);
 #else
 	/*
 	 * Most other machine types are "normal", so
diff -urN linux-2.6.15-rc5/drivers/video/fbmem.c linux-2.6.15-rc6/drivers/video/fbmem.c
--- linux-2.6.15-rc5/drivers/video/fbmem.c	2005-12-18 22:27:56.391688762 -0800
+++ linux-2.6.15-rc6/drivers/video/fbmem.c	2005-12-18 22:28:05.235082782 -0800
@@ -722,14 +722,30 @@
 int
 fb_pan_display(struct fb_info *info, struct fb_var_screeninfo *var)
 {
+	struct fb_fix_screeninfo *fix = &info->fix;
         int xoffset = var->xoffset;
         int yoffset = var->yoffset;
-        int err;
+        int err = 0, yres = info->var.yres;
+
+	if (var->yoffset > 0) {
+		if (var->vmode & FB_VMODE_YWRAP) {
+			if (!fix->ywrapstep || (var->yoffset % fix->ywrapstep))
+				err = -EINVAL;
+			else
+				yres = 0;
+		} else if (!fix->ypanstep || (var->yoffset % fix->ypanstep))
+			err = -EINVAL;
+	}
+
+	if (var->xoffset > 0 && (!fix->xpanstep ||
+				 (var->xoffset % fix->xpanstep)))
+		err = -EINVAL;
+
+        if (err || !info->fbops->fb_pan_display || xoffset < 0 ||
+	    yoffset < 0 || var->yoffset + yres > info->var.yres_virtual ||
+	    var->xoffset + info->var.xres > info->var.xres_virtual)
+		return -EINVAL;
 
-        if (xoffset < 0 || yoffset < 0 || !info->fbops->fb_pan_display ||
-            xoffset + info->var.xres > info->var.xres_virtual ||
-            yoffset + info->var.yres > info->var.yres_virtual)
-                return -EINVAL;
 	if ((err = info->fbops->fb_pan_display(var, info)))
 		return err;
         info->var.xoffset = var->xoffset;
diff -urN linux-2.6.15-rc5/drivers/video/ffb.c linux-2.6.15-rc6/drivers/video/ffb.c
--- linux-2.6.15-rc5/drivers/video/ffb.c	2005-12-18 22:27:56.393688851 -0800
+++ linux-2.6.15-rc6/drivers/video/ffb.c	2005-12-18 22:28:05.237082871 -0800
@@ -359,7 +359,6 @@
 	int			prom_parent_node;
 	int			dac_rev;
 	int			board_type;
-	struct list_head	list;
 };
 
 static void FFBFifo(struct ffb_par *par, int n)
diff -urN linux-2.6.15-rc5/drivers/video/leo.c linux-2.6.15-rc6/drivers/video/leo.c
--- linux-2.6.15-rc5/drivers/video/leo.c	2005-12-18 22:27:56.403689296 -0800
+++ linux-2.6.15-rc6/drivers/video/leo.c	2005-12-18 22:28:05.246083272 -0800
@@ -197,7 +197,6 @@
 	unsigned long		fbsize;
 
 	struct sbus_dev		*sdev;
-	struct list_head	list;
 };
 
 static void leo_wait(struct leo_lx_krn __iomem *lx_krn)
diff -urN linux-2.6.15-rc5/drivers/video/p9100.c linux-2.6.15-rc6/drivers/video/p9100.c
--- linux-2.6.15-rc5/drivers/video/p9100.c	2005-12-18 22:27:56.414689787 -0800
+++ linux-2.6.15-rc6/drivers/video/p9100.c	2005-12-18 22:28:05.256083718 -0800
@@ -140,7 +140,6 @@
 	unsigned long		fbsize;
 
 	struct sbus_dev		*sdev;
-	struct list_head	list;
 };
 
 /**
diff -urN linux-2.6.15-rc5/drivers/video/pxafb.c linux-2.6.15-rc6/drivers/video/pxafb.c
--- linux-2.6.15-rc5/drivers/video/pxafb.c	2005-12-18 22:27:56.417689920 -0800
+++ linux-2.6.15-rc6/drivers/video/pxafb.c	2005-12-18 22:28:05.259083851 -0800
@@ -1396,7 +1396,8 @@
 int __devinit pxafb_setup(char *options)
 {
 # ifdef CONFIG_FB_PXA_PARAMETERS
-	strlcpy(g_options, options, sizeof(g_options));
+	if (options)
+		strlcpy(g_options, options, sizeof(g_options));
 # endif
 	return 0;
 }
diff -urN linux-2.6.15-rc5/drivers/video/tcx.c linux-2.6.15-rc6/drivers/video/tcx.c
--- linux-2.6.15-rc5/drivers/video/tcx.c	2005-12-18 22:27:56.435690722 -0800
+++ linux-2.6.15-rc6/drivers/video/tcx.c	2005-12-18 22:28:05.277084653 -0800
@@ -125,7 +125,6 @@
 	int			lowdepth;
 
 	struct sbus_dev		*sdev;
-	struct list_head	list;
 };
 
 /* Reset control plane so that WID is 8-bit plane. */
@@ -444,7 +443,7 @@
 
 	tcx_reset(&all->info);
 
-	tcx_blank(0, &all->info);
+	tcx_blank(FB_BLANK_UNBLANK, &all->info);
 
 	if (fb_alloc_cmap(&all->info.cmap, 256, 0)) {
 		printk(KERN_ERR "tcx: Could not allocate color map.\n");
diff -urN linux-2.6.15-rc5/fs/inotify.c linux-2.6.15-rc6/fs/inotify.c
--- linux-2.6.15-rc5/fs/inotify.c	2005-12-18 22:27:56.523694643 -0800
+++ linux-2.6.15-rc6/fs/inotify.c	2005-12-18 22:28:05.364088530 -0800
@@ -364,11 +364,12 @@
 /*
  * find_inode - resolve a user-given path to a specific inode and return a nd
  */
-static int find_inode(const char __user *dirname, struct nameidata *nd)
+static int find_inode(const char __user *dirname, struct nameidata *nd,
+		      unsigned flags)
 {
 	int error;
 
-	error = __user_walk(dirname, LOOKUP_FOLLOW, nd);
+	error = __user_walk(dirname, flags, nd);
 	if (error)
 		return error;
 	/* you can only watch an inode if you have read permissions on it */
@@ -933,6 +934,7 @@
 	struct file *filp;
 	int ret, fput_needed;
 	int mask_add = 0;
+	unsigned flags = 0;
 
 	filp = fget_light(fd, &fput_needed);
 	if (unlikely(!filp))
@@ -944,7 +946,12 @@
 		goto fput_and_out;
 	}
 
-	ret = find_inode(path, &nd);
+	if (!(mask & IN_DONT_FOLLOW))
+		flags |= LOOKUP_FOLLOW;
+	if (mask & IN_ONLYDIR)
+		flags |= LOOKUP_DIRECTORY;
+
+	ret = find_inode(path, &nd, flags);
 	if (unlikely(ret))
 		goto fput_and_out;
 
diff -urN linux-2.6.15-rc5/fs/reiserfs/inode.c linux-2.6.15-rc6/fs/reiserfs/inode.c
--- linux-2.6.15-rc5/fs/reiserfs/inode.c	2005-12-18 22:27:56.635699634 -0800
+++ linux-2.6.15-rc6/fs/reiserfs/inode.c	2005-12-18 22:28:05.474093431 -0800
@@ -32,6 +32,7 @@
 	    JOURNAL_PER_BALANCE_CNT * 2 +
 	    2 * REISERFS_QUOTA_INIT_BLOCKS(inode->i_sb);
 	struct reiserfs_transaction_handle th;
+	int err;
 
 	truncate_inode_pages(&inode->i_data, 0);
 
@@ -49,15 +50,13 @@
 		}
 		reiserfs_update_inode_transaction(inode);
 
-		if (reiserfs_delete_object(&th, inode)) {
-			up(&inode->i_sem);
-			goto out;
-		}
+		err = reiserfs_delete_object(&th, inode);
 
 		/* Do quota update inside a transaction for journaled quotas. We must do that
 		 * after delete_object so that quota updates go into the same transaction as
 		 * stat data deletion */
-		DQUOT_FREE_INODE(inode);
+		if (!err) 
+			DQUOT_FREE_INODE(inode);
 
 		if (journal_end(&th, inode->i_sb, jbegin_count)) {
 			up(&inode->i_sem);
@@ -66,6 +65,12 @@
 
 		up(&inode->i_sem);
 
+		/* check return value from reiserfs_delete_object after
+		 * ending the transaction
+		 */
+		if (err)
+		    goto out;
+
 		/* all items of file are deleted, so we can remove "save" link */
 		remove_save_link(inode, 0 /* not truncate */ );	/* we can't do anything
 								 * about an error here */
@@ -2099,6 +2104,7 @@
 	struct page *page = NULL;
 	int error;
 	struct buffer_head *bh = NULL;
+	int err2;
 
 	reiserfs_write_lock(p_s_inode->i_sb);
 
@@ -2136,14 +2142,18 @@
 		   transaction of truncating gets committed - on reboot the file
 		   either appears truncated properly or not truncated at all */
 		add_save_link(&th, p_s_inode, 1);
-	error = reiserfs_do_truncate(&th, p_s_inode, page, update_timestamps);
-	if (error)
-		goto out;
+	err2 = reiserfs_do_truncate(&th, p_s_inode, page, update_timestamps);
 	error =
 	    journal_end(&th, p_s_inode->i_sb, JOURNAL_PER_BALANCE_CNT * 2 + 1);
 	if (error)
 		goto out;
 
+	/* check reiserfs_do_truncate after ending the transaction */
+	if (err2) {
+		error = err2;
+  		goto out;
+	}
+	
 	if (update_timestamps) {
 		error = remove_save_link(p_s_inode, 1 /* truncate */ );
 		if (error)
diff -urN linux-2.6.15-rc5/fs/reiserfs/journal.c linux-2.6.15-rc6/fs/reiserfs/journal.c
--- linux-2.6.15-rc5/fs/reiserfs/journal.c	2005-12-18 22:27:56.637699723 -0800
+++ linux-2.6.15-rc6/fs/reiserfs/journal.c	2005-12-18 22:28:05.476093520 -0800
@@ -1039,6 +1039,10 @@
 	}
 	atomic_dec(&journal->j_async_throttle);
 
+	/* We're skipping the commit if there's an error */
+	if (retval || reiserfs_is_journal_aborted(journal))
+		barrier = 0;
+
 	/* wait on everything written so far before writing the commit
 	 * if we are in barrier mode, send the commit down now
 	 */
@@ -1077,10 +1081,16 @@
 	BUG_ON(atomic_read(&(jl->j_commit_left)) != 1);
 
 	if (!barrier) {
-		if (buffer_dirty(jl->j_commit_bh))
-			BUG();
-		mark_buffer_dirty(jl->j_commit_bh);
-		sync_dirty_buffer(jl->j_commit_bh);
+		/* If there was a write error in the journal - we can't commit
+		 * this transaction - it will be invalid and, if successful,
+		 * will just end up propogating the write error out to
+		 * the file system. */
+		if (likely(!retval && !reiserfs_is_journal_aborted (journal))) {
+			if (buffer_dirty(jl->j_commit_bh))
+				BUG();
+			mark_buffer_dirty(jl->j_commit_bh) ;
+			sync_dirty_buffer(jl->j_commit_bh) ;
+		}
 	} else
 		wait_on_buffer(jl->j_commit_bh);
 
diff -urN linux-2.6.15-rc5/fs/xattr.c linux-2.6.15-rc6/fs/xattr.c
--- linux-2.6.15-rc5/fs/xattr.c	2005-12-18 22:27:56.643699990 -0800
+++ linux-2.6.15-rc6/fs/xattr.c	2005-12-18 22:28:05.483093832 -0800
@@ -245,7 +245,7 @@
 		error = d->d_inode->i_op->listxattr(d, klist, size);
 	} else {
 		error = security_inode_listsecurity(d->d_inode, klist, size);
-		if (size && error >= size)
+		if (size && error > size)
 			error = -ERANGE;
 	}
 	if (error > 0) {
diff -urN linux-2.6.15-rc5/fs/xfs/quota/xfs_qm.c linux-2.6.15-rc6/fs/xfs/quota/xfs_qm.c
--- linux-2.6.15-rc5/fs/xfs/quota/xfs_qm.c	2005-12-18 22:27:56.667701060 -0800
+++ linux-2.6.15-rc6/fs/xfs/quota/xfs_qm.c	2005-12-18 22:28:05.506094857 -0800
@@ -78,7 +78,7 @@
 
 STATIC int	xfs_qm_init_quotainos(xfs_mount_t *);
 STATIC int	xfs_qm_init_quotainfo(xfs_mount_t *);
-STATIC int	xfs_qm_shake(int, unsigned int);
+STATIC int	xfs_qm_shake(int, gfp_t);
 
 #ifdef DEBUG
 extern mutex_t	qcheck_lock;
@@ -2197,7 +2197,7 @@
  */
 /* ARGSUSED */
 STATIC int
-xfs_qm_shake(int nr_to_scan, unsigned int gfp_mask)
+xfs_qm_shake(int nr_to_scan, gfp_t gfp_mask)
 {
 	int	ndqused, nfree, n;
 
diff -urN linux-2.6.15-rc5/include/asm-arm/arch-pxa/irq.h linux-2.6.15-rc6/include/asm-arm/arch-pxa/irq.h
--- linux-2.6.15-rc5/include/asm-arm/arch-pxa/irq.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/include/asm-arm/arch-pxa/irq.h	2005-12-18 22:28:05.637100694 -0800
@@ -12,8 +12,3 @@
 
 #define fixup_irq(x)	(x)
 
-/*
- * This prototype is required for cascading of multiplexed interrupts.
- * Since it doesn't exist elsewhere, we'll put it here for now.
- */
-extern void do_IRQ(int irq, struct pt_regs *regs);
diff -urN linux-2.6.15-rc5/include/asm-arm/elf.h linux-2.6.15-rc6/include/asm-arm/elf.h
--- linux-2.6.15-rc5/include/asm-arm/elf.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/include/asm-arm/elf.h	2005-12-18 22:28:05.651101318 -0800
@@ -22,6 +22,8 @@
 #define R_ARM_NONE	0
 #define R_ARM_PC24	1
 #define R_ARM_ABS32	2
+#define R_ARM_CALL	28
+#define R_ARM_JUMP24	29
 
 #define ELF_NGREG (sizeof (struct pt_regs) / sizeof(elf_greg_t))
 typedef elf_greg_t elf_gregset_t[ELF_NGREG];
diff -urN linux-2.6.15-rc5/include/asm-arm/io.h linux-2.6.15-rc6/include/asm-arm/io.h
--- linux-2.6.15-rc5/include/asm-arm/io.h	2005-12-18 22:27:56.808707342 -0800
+++ linux-2.6.15-rc6/include/asm-arm/io.h	2005-12-18 22:28:05.653101407 -0800
@@ -42,9 +42,9 @@
 extern void __raw_writesw(void __iomem *addr, const void *data, int wordlen);
 extern void __raw_writesl(void __iomem *addr, const void *data, int longlen);
 
-extern void __raw_readsb(void __iomem *addr, void *data, int bytelen);
-extern void __raw_readsw(void __iomem *addr, void *data, int wordlen);
-extern void __raw_readsl(void __iomem *addr, void *data, int longlen);
+extern void __raw_readsb(const void __iomem *addr, void *data, int bytelen);
+extern void __raw_readsw(const void __iomem *addr, void *data, int wordlen);
+extern void __raw_readsl(const void __iomem *addr, void *data, int longlen);
 
 #define __raw_writeb(v,a)	(__chk_io_ptr(a), *(volatile unsigned char __force  *)(a) = (v))
 #define __raw_writew(v,a)	(__chk_io_ptr(a), *(volatile unsigned short __force *)(a) = (v))
diff -urN linux-2.6.15-rc5/include/asm-arm/memory.h linux-2.6.15-rc6/include/asm-arm/memory.h
--- linux-2.6.15-rc5/include/asm-arm/memory.h	2005-12-18 22:27:56.809707387 -0800
+++ linux-2.6.15-rc6/include/asm-arm/memory.h	2005-12-18 22:28:05.654101452 -0800
@@ -122,6 +122,7 @@
  */
 #define __pa(x)			__virt_to_phys((unsigned long)(x))
 #define __va(x)			((void *)__phys_to_virt((unsigned long)(x)))
+#define pfn_to_kaddr(pfn)	__va((pfn) << PAGE_SHIFT)
 
 /*
  * Virtual <-> DMA view memory address translations
diff -urN linux-2.6.15-rc5/include/asm-ia64/delay.h linux-2.6.15-rc6/include/asm-ia64/delay.h
--- linux-2.6.15-rc5/include/asm-ia64/delay.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/include/asm-ia64/delay.h	2005-12-18 22:28:05.679102566 -0800
@@ -84,14 +84,6 @@
 	ia64_delay_loop (loops - 1);
 }
 
-static __inline__ void
-udelay (unsigned long usecs)
-{
-	unsigned long start = ia64_get_itc();
-	unsigned long cycles = usecs*local_cpu_data->cyc_per_usec;
-
-	while (ia64_get_itc() - start < cycles)
-		cpu_relax();
-}
+extern void udelay (unsigned long usecs);
 
 #endif /* _ASM_IA64_DELAY_H */
diff -urN linux-2.6.15-rc5/include/asm-ia64/ia32.h linux-2.6.15-rc6/include/asm-ia64/ia32.h
--- linux-2.6.15-rc5/include/asm-ia64/ia32.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/include/asm-ia64/ia32.h	2005-12-18 22:28:05.679102566 -0800
@@ -13,6 +13,8 @@
 
 # ifdef CONFIG_IA32_SUPPORT
 
+#define IA32_PAGE_OFFSET	0xc0000000
+
 extern void ia32_cpu_init (void);
 extern void ia32_mem_init (void);
 extern void ia32_gdt_init (void);
diff -urN linux-2.6.15-rc5/include/asm-ia64/local.h linux-2.6.15-rc6/include/asm-ia64/local.h
--- linux-2.6.15-rc5/include/asm-ia64/local.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/include/asm-ia64/local.h	2005-12-18 22:28:05.680102610 -0800
@@ -17,8 +17,8 @@
 #define local_set(l, i)	atomic64_set(&(l)->val, i)
 #define local_inc(l)	atomic64_inc(&(l)->val)
 #define local_dec(l)	atomic64_dec(&(l)->val)
-#define local_add(l)	atomic64_add(&(l)->val)
-#define local_sub(l)	atomic64_sub(&(l)->val)
+#define local_add(i, l)	atomic64_add((i), &(l)->val)
+#define local_sub(i, l)	atomic64_sub((i), &(l)->val)
 
 /* Non-atomic variants, i.e., preemption disabled and won't be touched in interrupt, etc.  */
 
diff -urN linux-2.6.15-rc5/include/asm-ia64/sal.h linux-2.6.15-rc6/include/asm-ia64/sal.h
--- linux-2.6.15-rc5/include/asm-ia64/sal.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/include/asm-ia64/sal.h	2005-12-18 22:28:05.684102788 -0800
@@ -320,7 +320,8 @@
 typedef struct sal_log_record_header {
 	u64 id;				/* Unique monotonically increasing ID */
 	sal_log_revision_t revision;	/* Major and Minor revision of header */
-	u16 severity;			/* Error Severity */
+	u8 severity;			/* Error Severity */
+	u8 validation_bits;		/* 0: platform_guid, 1: !timestamp */
 	u32 len;			/* Length of this error log in bytes */
 	sal_log_timestamp_t timestamp;	/* Timestamp */
 	efi_guid_t platform_guid;	/* Unique OEM Platform ID */
diff -urN linux-2.6.15-rc5/include/asm-ia64/sn/pcidev.h linux-2.6.15-rc6/include/asm-ia64/sn/pcidev.h
--- linux-2.6.15-rc5/include/asm-ia64/sn/pcidev.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/include/asm-ia64/sn/pcidev.h	2005-12-18 22:28:05.686102878 -0800
@@ -3,15 +3,27 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 1992 - 1997, 2000-2004 Silicon Graphics, Inc. All rights reserved.
+ * Copyright (C) 1992 - 1997, 2000-2005 Silicon Graphics, Inc. All rights reserved.
  */
 #ifndef _ASM_IA64_SN_PCI_PCIDEV_H
 #define _ASM_IA64_SN_PCI_PCIDEV_H
 
 #include <linux/pci.h>
 
-#define SN_PCIDEV_INFO(pci_dev) \
-        ((struct pcidev_info *)(pci_dev)->sysdata)
+/*
+ * In ia64, pci_dev->sysdata must be a *pci_controller. To provide access to
+ * the pcidev_info structs for all devices under a controller, we extend the
+ * definition of pci_controller, via sn_pci_controller, to include a list
+ * of pcidev_info.
+ */
+struct sn_pci_controller {
+	struct pci_controller pci_controller;
+	struct list_head pcidev_info;
+};
+
+#define SN_PCI_CONTROLLER(dev) ((struct sn_pci_controller *) dev->sysdata)
+
+#define SN_PCIDEV_INFO(dev)	sn_pcidev_info_get(dev)
 
 #define SN_PCIBUS_BUSSOFT_INFO(pci_bus) \
 	(struct pcibus_info *)((struct pcibus_bussoft *)(PCI_CONTROLLER((pci_bus))->platform_data))
@@ -53,11 +65,13 @@
 	struct sn_irq_info	*pdi_sn_irq_info;
 	struct sn_pcibus_provider *pdi_provider;	/* sn pci ops */
 	struct pci_dev 		*host_pci_dev;		/* host bus link */
+	struct list_head	pdi_list;		/* List of pcidev_info */
 };
 
 extern void sn_irq_fixup(struct pci_dev *pci_dev,
 			 struct sn_irq_info *sn_irq_info);
 extern void sn_irq_unfixup(struct pci_dev *pci_dev);
+extern struct pcidev_info * sn_pcidev_info_get(struct pci_dev *);
 extern void sn_pci_controller_fixup(int segment, int busnum,
  				    struct pci_bus *bus);
 extern void sn_bus_store_sysdata(struct pci_dev *dev);
diff -urN linux-2.6.15-rc5/include/asm-ia64/spinlock.h linux-2.6.15-rc6/include/asm-ia64/spinlock.h
--- linux-2.6.15-rc5/include/asm-ia64/spinlock.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/include/asm-ia64/spinlock.h	2005-12-18 22:28:05.690103056 -0800
@@ -201,6 +201,16 @@
 
 #endif /* !ASM_SUPPORTED */
 
-#define __raw_read_trylock(lock) generic__raw_read_trylock(lock)
+static inline int __raw_read_trylock(raw_rwlock_t *x)
+{
+	union {
+		raw_rwlock_t lock;
+		__u32 word;
+	} old, new;
+	old.lock = new.lock = *x;
+	old.lock.write_lock = new.lock.write_lock = 0;
+	++new.lock.read_counter;
+	return (u32)ia64_cmpxchg4_acq((__u32 *)(x), new.word, old.word) == old.word;
+}
 
 #endif /*  _ASM_IA64_SPINLOCK_H */
diff -urN linux-2.6.15-rc5/include/asm-mips/mach-au1x00/au1xxx_ide.h linux-2.6.15-rc6/include/asm-mips/mach-au1x00/au1xxx_ide.h
--- linux-2.6.15-rc5/include/asm-mips/mach-au1x00/au1xxx_ide.h	2005-12-18 22:27:56.881710595 -0800
+++ linux-2.6.15-rc6/include/asm-mips/mach-au1x00/au1xxx_ide.h	2005-12-18 22:28:05.731104883 -0800
@@ -74,9 +74,6 @@
         u8                      white_list, black_list;
         struct dbdma_cmd        *dma_table_cpu;
         dma_addr_t              dma_table_dma;
-        struct scatterlist      *sg_table;
-        int                     sg_nents;
-        int                     sg_dma_direction;
 #endif
         struct device           *dev;
 	int			irq;
@@ -87,11 +84,6 @@
 } _auide_hwif;
 
 #ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
-struct drive_list_entry {
-        const char * id_model;
-        const char * id_firmware;
-};
-
 /* HD white list */
 static const struct drive_list_entry dma_white_list [] = {
 /*
@@ -167,13 +159,9 @@
  * Multi-Word DMA + DbDMA functions
  */
 #ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
-
-        static int in_drive_list(struct hd_driveid *id,
-                                 const struct drive_list_entry *drive_table);
         static int auide_build_sglist(ide_drive_t *drive,  struct request *rq);
         static int auide_build_dmatable(ide_drive_t *drive);
         static int auide_dma_end(ide_drive_t *drive);
-        static void auide_dma_start(ide_drive_t *drive );
         ide_startstop_t auide_dma_intr (ide_drive_t *drive);
         static void auide_dma_exec_cmd(ide_drive_t *drive, u8 command);
         static int auide_dma_setup(ide_drive_t *drive);
@@ -188,8 +176,6 @@
         static void auide_ddma_rx_callback(int irq, void *param,
                                            struct pt_regs *regs);
         static int auide_dma_off_quietly(ide_drive_t *drive);
-        static int auide_dma_timeout(ide_drive_t *drive);
-
 #endif /* end CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA */
 
 /*******************************************************************************
@@ -299,3 +285,11 @@
 #define SBC_IDE_MDMA2_TPM     (0x00<<6)
 #define SBC_IDE_MDMA2_TA      (0x12<<0)
 
+#define SBC_IDE_TIMING(mode) \
+         SBC_IDE_##mode##_TWCS | \
+         SBC_IDE_##mode##_TCSH | \
+         SBC_IDE_##mode##_TCSOFF | \
+         SBC_IDE_##mode##_TWP | \
+         SBC_IDE_##mode##_TCSW | \
+         SBC_IDE_##mode##_TPM | \
+         SBC_IDE_##mode##_TA
diff -urN linux-2.6.15-rc5/include/asm-powerpc/mmu.h linux-2.6.15-rc6/include/asm-powerpc/mmu.h
--- linux-2.6.15-rc5/include/asm-powerpc/mmu.h	2005-12-18 22:27:56.962714204 -0800
+++ linux-2.6.15-rc6/include/asm-powerpc/mmu.h	2005-12-18 22:28:05.809108358 -0800
@@ -220,7 +220,8 @@
 			   unsigned int local);
 struct mm_struct;
 extern int hash_huge_page(struct mm_struct *mm, unsigned long access,
-			  unsigned long ea, unsigned long vsid, int local);
+			  unsigned long ea, unsigned long vsid, int local,
+			  unsigned long trap);
 
 extern void htab_finish_init(void);
 extern int htab_bolt_mapping(unsigned long vstart, unsigned long vend,
diff -urN linux-2.6.15-rc5/include/asm-ppc/ppc4xx_dma.h linux-2.6.15-rc6/include/asm-ppc/ppc4xx_dma.h
--- linux-2.6.15-rc5/include/asm-ppc/ppc4xx_dma.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/include/asm-ppc/ppc4xx_dma.h	2005-12-18 22:28:05.920113304 -0800
@@ -33,9 +33,6 @@
 
 #define MAX_PPC4xx_DMA_CHANNELS		4
 
-/* in arch/ppc/kernel/setup.c -- Cort */
-extern unsigned long DMA_MODE_WRITE, DMA_MODE_READ;
-
 /*
  * Function return status codes
  * These values are used to indicate whether or not the function
diff -urN linux-2.6.15-rc5/include/asm-sparc/memreg.h linux-2.6.15-rc6/include/asm-sparc/memreg.h
--- linux-2.6.15-rc5/include/asm-sparc/memreg.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/include/asm-sparc/memreg.h	2005-12-18 22:28:06.215126449 -0800
@@ -36,7 +36,7 @@
 
 /* Memory parity error register with associated bit constants. */
 #ifndef __ASSEMBLY__
-extern __volatile__ unsigned long *sun4c_memerr_reg;
+extern __volatile__ unsigned long __iomem *sun4c_memerr_reg;
 #endif
 
 #define	SUN4C_MPE_ERROR	0x80	/* Parity error detected. (ro) */
diff -urN linux-2.6.15-rc5/include/asm-sparc/pcic.h linux-2.6.15-rc6/include/asm-sparc/pcic.h
--- linux-2.6.15-rc5/include/asm-sparc/pcic.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/include/asm-sparc/pcic.h	2005-12-18 22:28:06.216126493 -0800
@@ -16,10 +16,10 @@
 #include <asm/pbm.h>
 
 struct linux_pcic {
-        void * __iomem          pcic_regs;
+        void __iomem            *pcic_regs;
         unsigned long           pcic_io;
-        void * __iomem          pcic_config_space_addr;
-        void * __iomem          pcic_config_space_data;
+        void __iomem            *pcic_config_space_addr;
+        void __iomem            *pcic_config_space_data;
 	struct resource		pcic_res_regs;
 	struct resource		pcic_res_io;
 	struct resource		pcic_res_cfg_addr;
diff -urN linux-2.6.15-rc5/include/linux/cache.h linux-2.6.15-rc6/include/linux/cache.h
--- linux-2.6.15-rc5/include/linux/cache.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/include/linux/cache.h	2005-12-18 22:28:06.249127963 -0800
@@ -13,7 +13,7 @@
 #define SMP_CACHE_BYTES L1_CACHE_BYTES
 #endif
 
-#if defined(CONFIG_X86) || defined(CONFIG_SPARC64)
+#if defined(CONFIG_X86) || defined(CONFIG_SPARC64) || defined(CONFIG_IA64)
 #define __read_mostly __attribute__((__section__(".data.read_mostly")))
 #else
 #define __read_mostly
diff -urN linux-2.6.15-rc5/include/linux/cn_proc.h linux-2.6.15-rc6/include/linux/cn_proc.h
--- linux-2.6.15-rc5/include/linux/cn_proc.h	2005-12-18 22:27:57.394733453 -0800
+++ linux-2.6.15-rc6/include/linux/cn_proc.h	2005-12-18 22:28:06.249127963 -0800
@@ -26,6 +26,7 @@
 #define CN_PROC_H
 
 #include <linux/types.h>
+#include <linux/time.h>
 #include <linux/connector.h>
 
 /*
@@ -65,6 +66,7 @@
 		PROC_EVENT_EXIT = 0x80000000
 	} what;
 	__u32 cpu;
+	struct timespec timestamp;
 	union { /* must be last field of proc_event struct */
 		struct {
 			__u32 err;
diff -urN linux-2.6.15-rc5/include/linux/dvb/audio.h linux-2.6.15-rc6/include/linux/dvb/audio.h
--- linux-2.6.15-rc5/include/linux/dvb/audio.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/include/linux/dvb/audio.h	2005-12-18 22:28:06.255128231 -0800
@@ -32,39 +32,39 @@
 
 
 typedef enum {
-        AUDIO_SOURCE_DEMUX, /* Select the demux as the main source */
+	AUDIO_SOURCE_DEMUX, /* Select the demux as the main source */
 	AUDIO_SOURCE_MEMORY /* Select internal memory as the main source */
 } audio_stream_source_t;
 
 
 typedef enum {
 	AUDIO_STOPPED,      /* Device is stopped */
-        AUDIO_PLAYING,      /* Device is currently playing */
+	AUDIO_PLAYING,      /* Device is currently playing */
 	AUDIO_PAUSED        /* Device is paused */
 } audio_play_state_t;
 
 
 typedef enum {
-        AUDIO_STEREO,
-        AUDIO_MONO_LEFT,
+	AUDIO_STEREO,
+	AUDIO_MONO_LEFT,
 	AUDIO_MONO_RIGHT
 } audio_channel_select_t;
 
 
 typedef struct audio_mixer {
-        unsigned int volume_left;
-        unsigned int volume_right;
+	unsigned int volume_left;
+	unsigned int volume_right;
   // what else do we need? bass, pass-through, ...
 } audio_mixer_t;
 
 
 typedef struct audio_status {
-        int                    AV_sync_state;  /* sync audio and video? */
-        int                    mute_state;     /* audio is muted */
-        audio_play_state_t     play_state;     /* current playback state */
-        audio_stream_source_t  stream_source;  /* current stream source */
-        audio_channel_select_t channel_select; /* currently selected channel */
-        int                    bypass_mode;    /* pass on audio data to */
+	int                    AV_sync_state;  /* sync audio and video? */
+	int                    mute_state;     /* audio is muted */
+	audio_play_state_t     play_state;     /* current playback state */
+	audio_stream_source_t  stream_source;  /* current stream source */
+	audio_channel_select_t channel_select; /* currently selected channel */
+	int                    bypass_mode;    /* pass on audio data to */
 	audio_mixer_t	       mixer_state;    /* current mixer state */
 } audio_status_t;                              /* separate decoder hardware */
 
@@ -74,8 +74,8 @@
 	int vocal1;    /* into left and right t at 70% each */
 	int vocal2;    /* if both, Vocal1 and Vocal2 are non-zero, Vocal1 gets*/
 	int melody;    /* mixed into the left channel and */
-                       /* Vocal2 into the right channel at 100% each. */
-                       /* if Melody is non-zero, the melody channel gets mixed*/
+		       /* Vocal2 into the right channel at 100% each. */
+		       /* if Melody is non-zero, the melody channel gets mixed*/
 } audio_karaoke_t;     /* into left and right  */
 
 
diff -urN linux-2.6.15-rc5/include/linux/dvb/ca.h linux-2.6.15-rc6/include/linux/dvb/ca.h
--- linux-2.6.15-rc5/include/linux/dvb/ca.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/include/linux/dvb/ca.h	2005-12-18 22:28:06.255128231 -0800
@@ -27,16 +27,16 @@
 /* slot interface types and info */
 
 typedef struct ca_slot_info {
-        int num;               /* slot number */
+	int num;               /* slot number */
 
-        int type;              /* CA interface this slot supports */
+	int type;              /* CA interface this slot supports */
 #define CA_CI            1     /* CI high level interface */
 #define CA_CI_LINK       2     /* CI link layer level interface */
 #define CA_CI_PHYS       4     /* CI physical layer level interface */
 #define CA_DESCR         8     /* built-in descrambler */
 #define CA_SC          128     /* simple smart card interface */
 
-        unsigned int flags;
+	unsigned int flags;
 #define CA_CI_MODULE_PRESENT 1 /* module (or card) inserted */
 #define CA_CI_MODULE_READY   2
 } ca_slot_info_t;
@@ -45,37 +45,37 @@
 /* descrambler types and info */
 
 typedef struct ca_descr_info {
-        unsigned int num;          /* number of available descramblers (keys) */
-        unsigned int type;         /* type of supported scrambling system */
+	unsigned int num;          /* number of available descramblers (keys) */
+	unsigned int type;         /* type of supported scrambling system */
 #define CA_ECD           1
 #define CA_NDS           2
 #define CA_DSS           4
 } ca_descr_info_t;
 
 typedef struct ca_caps {
-        unsigned int slot_num;     /* total number of CA card and module slots */
-        unsigned int slot_type;    /* OR of all supported types */
-        unsigned int descr_num;    /* total number of descrambler slots (keys) */
-        unsigned int descr_type;   /* OR of all supported types */
+	unsigned int slot_num;     /* total number of CA card and module slots */
+	unsigned int slot_type;    /* OR of all supported types */
+	unsigned int descr_num;    /* total number of descrambler slots (keys) */
+	unsigned int descr_type;   /* OR of all supported types */
 } ca_caps_t;
 
 /* a message to/from a CI-CAM */
 typedef struct ca_msg {
-        unsigned int index;
-        unsigned int type;
-        unsigned int length;
-        unsigned char msg[256];
+	unsigned int index;
+	unsigned int type;
+	unsigned int length;
+	unsigned char msg[256];
 } ca_msg_t;
 
 typedef struct ca_descr {
-        unsigned int index;
-        unsigned int parity;	/* 0 == even, 1 == odd */
-        unsigned char cw[8];
+	unsigned int index;
+	unsigned int parity;	/* 0 == even, 1 == odd */
+	unsigned char cw[8];
 } ca_descr_t;
 
 typedef struct ca_pid {
-        unsigned int pid;
-        int index;		/* -1 == disable*/
+	unsigned int pid;
+	int index;		/* -1 == disable*/
 } ca_pid_t;
 
 #define CA_RESET          _IO('o', 128)
diff -urN linux-2.6.15-rc5/include/linux/dvb/dmx.h linux-2.6.15-rc6/include/linux/dvb/dmx.h
--- linux-2.6.15-rc5/include/linux/dvb/dmx.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/include/linux/dvb/dmx.h	2005-12-18 22:28:06.255128231 -0800
@@ -1,4 +1,4 @@
-/* 
+/*
  * dmx.h
  *
  * Copyright (C) 2000 Marcus Metzler <marcus@convergence.de>
@@ -38,10 +38,10 @@
 {
 	DMX_OUT_DECODER, /* Streaming directly to decoder. */
 	DMX_OUT_TAP,     /* Output going to a memory buffer */
-	                 /* (to be retrieved via the read command).*/
+			 /* (to be retrieved via the read command).*/
 	DMX_OUT_TS_TAP   /* Output multiplexed into a new TS  */
-	                 /* (to be retrieved by reading from the */
-	                 /* logical DVR device).                 */
+			 /* (to be retrieved by reading from the */
+			 /* logical DVR device).                 */
 } dmx_output_t;
 
 
@@ -54,25 +54,25 @@
 
 typedef enum
 {
-        DMX_PES_AUDIO0,
+	DMX_PES_AUDIO0,
 	DMX_PES_VIDEO0,
 	DMX_PES_TELETEXT0,
 	DMX_PES_SUBTITLE0,
 	DMX_PES_PCR0,
 
-        DMX_PES_AUDIO1,
+	DMX_PES_AUDIO1,
 	DMX_PES_VIDEO1,
 	DMX_PES_TELETEXT1,
 	DMX_PES_SUBTITLE1,
 	DMX_PES_PCR1,
 
-        DMX_PES_AUDIO2,
+	DMX_PES_AUDIO2,
 	DMX_PES_VIDEO2,
 	DMX_PES_TELETEXT2,
 	DMX_PES_SUBTITLE2,
 	DMX_PES_PCR2,
 
-        DMX_PES_AUDIO3,
+	DMX_PES_AUDIO3,
 	DMX_PES_VIDEO3,
 	DMX_PES_TELETEXT3,
 	DMX_PES_SUBTITLE3,
@@ -90,8 +90,8 @@
 
 typedef enum
 {
-        DMX_SCRAMBLING_EV,
-        DMX_FRONTEND_EV
+	DMX_SCRAMBLING_EV,
+	DMX_FRONTEND_EV
 } dmx_event_t;
 
 
diff -urN linux-2.6.15-rc5/include/linux/dvb/osd.h linux-2.6.15-rc6/include/linux/dvb/osd.h
--- linux-2.6.15-rc5/include/linux/dvb/osd.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/include/linux/dvb/osd.h	2005-12-18 22:28:06.256128275 -0800
@@ -98,43 +98,43 @@
 } OSD_Command;
 
 typedef struct osd_cmd_s {
-        OSD_Command cmd;
-        int x0;
-        int y0;
-        int x1;
-        int y1;
-        int color;
-        void __user *data;
+	OSD_Command cmd;
+	int x0;
+	int y0;
+	int x1;
+	int y1;
+	int color;
+	void __user *data;
 } osd_cmd_t;
 
 /* OSD_OpenRaw: set 'color' to desired window type */
 typedef enum {
-        OSD_BITMAP1,           /* 1 bit bitmap */
-        OSD_BITMAP2,           /* 2 bit bitmap */
-        OSD_BITMAP4,           /* 4 bit bitmap */
-        OSD_BITMAP8,           /* 8 bit bitmap */
-        OSD_BITMAP1HR,         /* 1 Bit bitmap half resolution */
-        OSD_BITMAP2HR,         /* 2 bit bitmap half resolution */
-        OSD_BITMAP4HR,         /* 4 bit bitmap half resolution */
-        OSD_BITMAP8HR,         /* 8 bit bitmap half resolution */
-        OSD_YCRCB422,          /* 4:2:2 YCRCB Graphic Display */
-        OSD_YCRCB444,          /* 4:4:4 YCRCB Graphic Display */
-        OSD_YCRCB444HR,        /* 4:4:4 YCRCB graphic half resolution */
-        OSD_VIDEOTSIZE,        /* True Size Normal MPEG Video Display */
-        OSD_VIDEOHSIZE,        /* MPEG Video Display Half Resolution */
-        OSD_VIDEOQSIZE,        /* MPEG Video Display Quarter Resolution */
-        OSD_VIDEODSIZE,        /* MPEG Video Display Double Resolution */
-        OSD_VIDEOTHSIZE,       /* True Size MPEG Video Display Half Resolution */
-        OSD_VIDEOTQSIZE,       /* True Size MPEG Video Display Quarter Resolution*/
-        OSD_VIDEOTDSIZE,       /* True Size MPEG Video Display Double Resolution */
-        OSD_VIDEONSIZE,        /* Full Size MPEG Video Display */
-        OSD_CURSOR             /* Cursor */
+	OSD_BITMAP1,           /* 1 bit bitmap */
+	OSD_BITMAP2,           /* 2 bit bitmap */
+	OSD_BITMAP4,           /* 4 bit bitmap */
+	OSD_BITMAP8,           /* 8 bit bitmap */
+	OSD_BITMAP1HR,         /* 1 Bit bitmap half resolution */
+	OSD_BITMAP2HR,         /* 2 bit bitmap half resolution */
+	OSD_BITMAP4HR,         /* 4 bit bitmap half resolution */
+	OSD_BITMAP8HR,         /* 8 bit bitmap half resolution */
+	OSD_YCRCB422,          /* 4:2:2 YCRCB Graphic Display */
+	OSD_YCRCB444,          /* 4:4:4 YCRCB Graphic Display */
+	OSD_YCRCB444HR,        /* 4:4:4 YCRCB graphic half resolution */
+	OSD_VIDEOTSIZE,        /* True Size Normal MPEG Video Display */
+	OSD_VIDEOHSIZE,        /* MPEG Video Display Half Resolution */
+	OSD_VIDEOQSIZE,        /* MPEG Video Display Quarter Resolution */
+	OSD_VIDEODSIZE,        /* MPEG Video Display Double Resolution */
+	OSD_VIDEOTHSIZE,       /* True Size MPEG Video Display Half Resolution */
+	OSD_VIDEOTQSIZE,       /* True Size MPEG Video Display Quarter Resolution*/
+	OSD_VIDEOTDSIZE,       /* True Size MPEG Video Display Double Resolution */
+	OSD_VIDEONSIZE,        /* Full Size MPEG Video Display */
+	OSD_CURSOR             /* Cursor */
 } osd_raw_window_t;
 
 typedef struct osd_cap_s {
-        int  cmd;
+	int  cmd;
 #define OSD_CAP_MEMSIZE         1  /* memory size */
-        long val;
+	long val;
 } osd_cap_t;
 
 
diff -urN linux-2.6.15-rc5/include/linux/dvb/video.h linux-2.6.15-rc6/include/linux/dvb/video.h
--- linux-2.6.15-rc5/include/linux/dvb/video.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/include/linux/dvb/video.h	2005-12-18 22:28:06.256128275 -0800
@@ -36,7 +36,7 @@
 
 typedef enum {
 	VIDEO_FORMAT_4_3,     /* Select 4:3 format */
-        VIDEO_FORMAT_16_9,    /* Select 16:9 format. */
+	VIDEO_FORMAT_16_9,    /* Select 16:9 format. */
 	VIDEO_FORMAT_221_1    /* 2.21:1 */
 } video_format_t;
 
@@ -54,7 +54,7 @@
 
 
 typedef enum {
-        VIDEO_PAN_SCAN,       /* use pan and scan format */
+	VIDEO_PAN_SCAN,       /* use pan and scan format */
 	VIDEO_LETTER_BOX,     /* use letterbox format */
 	VIDEO_CENTER_CUT_OUT  /* use center cut out format */
 } video_displayformat_t;
@@ -66,7 +66,7 @@
 } video_size_t;
 
 typedef enum {
-        VIDEO_SOURCE_DEMUX, /* Select the demux as the main source */
+	VIDEO_SOURCE_DEMUX, /* Select the demux as the main source */
 	VIDEO_SOURCE_MEMORY /* If this source is selected, the stream
 			       comes from the user through the write
 			       system call */
@@ -75,35 +75,35 @@
 
 typedef enum {
 	VIDEO_STOPPED, /* Video is stopped */
-        VIDEO_PLAYING, /* Video is currently playing */
+	VIDEO_PLAYING, /* Video is currently playing */
 	VIDEO_FREEZED  /* Video is freezed */
 } video_play_state_t;
 
 
 struct video_event {
-        int32_t type;
+	int32_t type;
 #define VIDEO_EVENT_SIZE_CHANGED	1
 #define VIDEO_EVENT_FRAME_RATE_CHANGED	2
-        time_t timestamp;
+	time_t timestamp;
 	union {
-	        video_size_t size;
+		video_size_t size;
 		unsigned int frame_rate;	/* in frames per 1000sec */
 	} u;
 };
 
 
 struct video_status {
-        int                   video_blank;   /* blank video on freeze? */
-        video_play_state_t    play_state;    /* current state of playback */
-        video_stream_source_t stream_source; /* current source (demux/memory) */
-        video_format_t        video_format;  /* current aspect ratio of stream*/
-        video_displayformat_t display_format;/* selected cropping mode */
+	int                   video_blank;   /* blank video on freeze? */
+	video_play_state_t    play_state;    /* current state of playback */
+	video_stream_source_t stream_source; /* current source (demux/memory) */
+	video_format_t        video_format;  /* current aspect ratio of stream*/
+	video_displayformat_t display_format;/* selected cropping mode */
 };
 
 
 struct video_still_picture {
-        char __user *iFrame;        /* pointer to a single iframe in memory */
-        int32_t size;
+	char __user *iFrame;        /* pointer to a single iframe in memory */
+	int32_t size;
 };
 
 
@@ -111,19 +111,19 @@
 struct video_highlight {
 	int     active;      /*    1=show highlight, 0=hide highlight */
 	uint8_t contrast1;   /*    7- 4  Pattern pixel contrast */
-                             /*    3- 0  Background pixel contrast */
+			     /*    3- 0  Background pixel contrast */
 	uint8_t contrast2;   /*    7- 4  Emphasis pixel-2 contrast */
-                             /*    3- 0  Emphasis pixel-1 contrast */
+			     /*    3- 0  Emphasis pixel-1 contrast */
 	uint8_t color1;      /*    7- 4  Pattern pixel color */
-                             /*    3- 0  Background pixel color */
+			     /*    3- 0  Background pixel color */
 	uint8_t color2;      /*    7- 4  Emphasis pixel-2 color */
-                             /*    3- 0  Emphasis pixel-1 color */
+			     /*    3- 0  Emphasis pixel-1 color */
 	uint32_t ypos;       /*   23-22  auto action mode */
-                             /*   21-12  start y */
-                             /*    9- 0  end y */
+			     /*   21-12  start y */
+			     /*    9- 0  end y */
 	uint32_t xpos;       /*   23-22  button color number */
-                             /*   21-12  start x */
-                             /*    9- 0  end x */
+			     /*   21-12  start x */
+			     /*    9- 0  end x */
 } video_highlight_t;
 
 
diff -urN linux-2.6.15-rc5/include/linux/fb.h linux-2.6.15-rc6/include/linux/fb.h
--- linux-2.6.15-rc5/include/linux/fb.h	2005-12-18 22:27:57.403733854 -0800
+++ linux-2.6.15-rc6/include/linux/fb.h	2005-12-18 22:28:06.260128454 -0800
@@ -617,6 +617,12 @@
 
 	/* perform fb specific mmap */
 	int (*fb_mmap)(struct fb_info *info, struct file *file, struct vm_area_struct *vma);
+
+	/* save current hardware state */
+	void (*fb_save_state)(struct fb_info *info);
+
+	/* restore saved state */
+	void (*fb_restore_state)(struct fb_info *info);
 };
 
 #ifdef CONFIG_FB_TILEBLITTING
@@ -726,6 +732,18 @@
 						  from userspace */
 #define FBINFO_MISC_TILEBLITTING       0x20000 /* use tile blitting */
 
+/* A driver may set this flag to indicate that it does want a set_par to be
+ * called every time when fbcon_switch is executed. The advantage is that with
+ * this flag set you can really be shure that set_par is always called before
+ * any of the functions dependant on the correct hardware state or altering
+ * that state, even if you are using some broken X releases. The disadvantage
+ * is that it introduces unwanted delays to every console switch if set_par
+ * is slow. It is a good idea to try this flag in the drivers initialization
+ * code whenever there is a bug report related to switching between X and the
+ * framebuffer console.
+ */
+#define FBINFO_MISC_ALWAYS_SETPAR   0x40000
+
 struct fb_info {
 	int node;
 	int flags;
@@ -817,6 +835,18 @@
 
 #endif
 
+#if defined (__BIG_ENDIAN)
+#define FB_LEFT_POS(bpp)          (32 - bpp)
+#define FB_SHIFT_HIGH(val, bits)  ((val) >> (bits))
+#define FB_SHIFT_LOW(val, bits)   ((val) << (bits))
+#define FB_BIT_NR(b)              (7 - (b))
+#else
+#define FB_LEFT_POS(bpp)          (0)
+#define FB_SHIFT_HIGH(val, bits)  ((val) << (bits))
+#define FB_SHIFT_LOW(val, bits)   ((val) >> (bits))
+#define FB_BIT_NR(b)              (b)
+#endif
+
     /*
      *  `Generic' versions of the frame buffer device operations
      */
diff -urN linux-2.6.15-rc5/include/linux/i2c-id.h linux-2.6.15-rc6/include/linux/i2c-id.h
--- linux-2.6.15-rc5/include/linux/i2c-id.h	2005-12-18 22:27:57.411734210 -0800
+++ linux-2.6.15-rc6/include/linux/i2c-id.h	2005-12-18 22:28:06.268128810 -0800
@@ -108,7 +108,7 @@
 #define I2C_DRIVERID_SAA7127	72	/* saa7124 video encoder	*/
 #define I2C_DRIVERID_SAA711X	73	/* saa711x video encoders	*/
 #define I2C_DRIVERID_AKITAIOEXP	74	/* IO Expander on Sharp SL-C1000 */
-#define I2C_DRIVERID_I2C_IR	75	/* I2C InfraRed on Video boards */
+#define I2C_DRIVERID_INFRARED	75	/* I2C InfraRed on Video boards */
 
 #define I2C_DRIVERID_EXP0	0xF0	/* experimental use id's	*/
 #define I2C_DRIVERID_EXP1	0xF1
diff -urN linux-2.6.15-rc5/include/linux/ide.h linux-2.6.15-rc6/include/linux/ide.h
--- linux-2.6.15-rc5/include/linux/ide.h	2005-12-18 22:27:57.414734344 -0800
+++ linux-2.6.15-rc6/include/linux/ide.h	2005-12-18 22:28:06.271128944 -0800
@@ -23,17 +23,6 @@
 #include <asm/io.h>
 #include <asm/semaphore.h>
 
-/*
- * This is the multiple IDE interface driver, as evolved from hd.c.
- * It supports up to four IDE interfaces, on one or more IRQs (usually 14 & 15).
- * There can be up to two drives per interface, as per the ATA-2 spec.
- *
- * Primary i/f:    ide0: major=3;  (hda)         minor=0; (hdb)         minor=64
- * Secondary i/f:  ide1: major=22; (hdc or hd1a) minor=0; (hdd or hd1b) minor=64
- * Tertiary i/f:   ide2: major=33; (hde)         minor=0; (hdf)         minor=64
- * Quaternary i/f: ide3: major=34; (hdg)         minor=0; (hdh)         minor=64
- */
-
 /******************************************************************************
  * IDE driver configuration options (play with these as desired):
  *
@@ -193,11 +182,6 @@
 #define WAIT_CMD	(10*HZ)	/* 10sec  - maximum wait for an IRQ to happen */
 #define WAIT_MIN_SLEEP	(2*HZ/100)	/* 20msec - minimum sleep time */
 
-#define HOST(hwif,chipset)					\
-{								\
-	return ((hwif)->chipset == chipset) ? 1 : 0;		\
-}
-
 /*
  * Check for an interrupt and acknowledge the interrupt status
  */
@@ -391,45 +375,6 @@
 } ata_nsector_t, ata_data_t, atapi_bcount_t, ata_index_t;
 
 /*
- * ATA-IDE Error Register
- *
- * mark		: Bad address mark
- * tzero	: Couldn't find track 0
- * abrt		: Aborted Command
- * mcr		: Media Change Request
- * id		: ID field not found
- * mce		: Media Change Event
- * ecc		: Uncorrectable ECC error
- * bdd		: dual meaing
- */
-typedef union {
-	unsigned all			:8;
-	struct {
-#if defined(__LITTLE_ENDIAN_BITFIELD)
-		unsigned mark		:1;
-		unsigned tzero		:1;
-		unsigned abrt		:1;
-		unsigned mcr		:1;
-		unsigned id		:1;
-		unsigned mce		:1;
-		unsigned ecc		:1;
-		unsigned bdd		:1;
-#elif defined(__BIG_ENDIAN_BITFIELD)
-		unsigned bdd		:1;
-		unsigned ecc		:1;
-		unsigned mce		:1;
-		unsigned id		:1;
-		unsigned mcr		:1;
-		unsigned abrt		:1;
-		unsigned tzero		:1;
-		unsigned mark		:1;
-#else
-#error "Please fix <asm/byteorder.h>"
-#endif
-	} b;
-} ata_error_t;
-
-/*
  * ATA-IDE Select Register, aka Device-Head
  *
  * head		: always zeros here
@@ -504,39 +449,6 @@
 } ata_status_t, atapi_status_t;
 
 /*
- * ATA-IDE Control Register
- *
- * bit0		: Should be set to zero
- * nIEN		: device INTRQ to host
- * SRST		: host soft reset bit
- * bit3		: ATA-2 thingy, Should be set to 1
- * reserved456	: Reserved
- * HOB		: 48-bit address ordering, High Ordered Bit
- */
-typedef union {
-	unsigned all			: 8;
-	struct {
-#if defined(__LITTLE_ENDIAN_BITFIELD)
-		unsigned bit0		: 1;
-		unsigned nIEN		: 1;
-		unsigned SRST		: 1;
-		unsigned bit3		: 1;
-		unsigned reserved456	: 3;
-		unsigned HOB		: 1;
-#elif defined(__BIG_ENDIAN_BITFIELD)
-		unsigned HOB		: 1;
-		unsigned reserved456	: 3;
-		unsigned bit3		: 1;
-		unsigned SRST		: 1;
-		unsigned nIEN		: 1;
-		unsigned bit0		: 1;
-#else
-#error "Please fix <asm/byteorder.h>"
-#endif
-	} b;
-} ata_control_t;
-
-/*
  * ATAPI Feature Register
  *
  * dma		: Using DMA or PIO
@@ -618,39 +530,6 @@
 } atapi_error_t;
 
 /*
- * ATAPI floppy Drive Select Register
- *
- * sam_lun	: Logical unit number
- * reserved3	: Reserved
- * drv		: The responding drive will be drive 0 (0) or drive 1 (1)
- * one5		: Should be set to 1
- * reserved6	: Reserved
- * one7		: Should be set to 1
- */
-typedef union {
-	unsigned all			:8;
-	struct {
-#if defined(__LITTLE_ENDIAN_BITFIELD)
-		unsigned sam_lun	:3;
-		unsigned reserved3	:1;
-		unsigned drv		:1;
-		unsigned one5		:1;
-		unsigned reserved6	:1;
-		unsigned one7		:1;
-#elif defined(__BIG_ENDIAN_BITFIELD)
-		unsigned one7		:1;
-		unsigned reserved6	:1;
-		unsigned one5		:1;
-		unsigned drv		:1;
-		unsigned reserved3	:1;
-		unsigned sam_lun	:3;
-#else
-#error "Please fix <asm/byteorder.h>"
-#endif
-	} b;
-} atapi_select_t;
-
-/*
  * Status returned from various ide_ functions
  */
 typedef enum {
@@ -1101,10 +980,7 @@
 	int		(*end_request)(ide_drive_t *, int, int);
 	ide_startstop_t	(*error)(ide_drive_t *, struct request *rq, u8, u8);
 	ide_startstop_t	(*abort)(ide_drive_t *, struct request *rq);
-	int		(*ioctl)(ide_drive_t *, struct inode *, struct file *, unsigned int, unsigned long);
 	ide_proc_entry_t	*proc;
-	void		(*ata_prebuilder)(ide_drive_t *);
-	void		(*atapi_prebuilder)(ide_drive_t *);
 	struct device_driver	gen_driver;
 } ide_driver_t;
 
@@ -1298,7 +1174,6 @@
 extern void ide_timer_expiry(unsigned long);
 extern irqreturn_t ide_intr(int irq, void *dev_id, struct pt_regs *regs);
 extern void do_ide_request(request_queue_t *);
-extern void ide_init_subdrivers(void);
 
 void ide_init_disk(struct gendisk *, ide_drive_t *);
 
@@ -1371,6 +1246,12 @@
 #define GOOD_DMA_DRIVE		1
 
 #ifdef CONFIG_BLK_DEV_IDEDMA
+struct drive_list_entry {
+	const char *id_model;
+	const char *id_firmware;
+};
+
+int ide_in_drive_list(struct hd_driveid *, const struct drive_list_entry *);
 int __ide_dma_bad_drive(ide_drive_t *);
 int __ide_dma_good_drive(ide_drive_t *);
 int ide_use_dma(ide_drive_t *);
diff -urN linux-2.6.15-rc5/include/linux/inotify.h linux-2.6.15-rc6/include/linux/inotify.h
--- linux-2.6.15-rc5/include/linux/inotify.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/include/linux/inotify.h	2005-12-18 22:28:06.273129033 -0800
@@ -47,6 +47,8 @@
 #define IN_MOVE			(IN_MOVED_FROM | IN_MOVED_TO) /* moves */
 
 /* special flags */
+#define IN_ONLYDIR		0x01000000	/* only watch the path if it is a directory */
+#define IN_DONT_FOLLOW		0x02000000	/* don't follow a sym link */
 #define IN_MASK_ADD		0x20000000	/* add to the mask of an already existing watch */
 #define IN_ISDIR		0x40000000	/* event occurred against dir */
 #define IN_ONESHOT		0x80000000	/* only send event once */
diff -urN linux-2.6.15-rc5/include/linux/kprobes.h linux-2.6.15-rc6/include/linux/kprobes.h
--- linux-2.6.15-rc5/include/linux/kprobes.h	2005-12-18 22:27:57.421734656 -0800
+++ linux-2.6.15-rc6/include/linux/kprobes.h	2005-12-18 22:28:06.278129256 -0800
@@ -37,6 +37,7 @@
 #include <linux/spinlock.h>
 #include <linux/rcupdate.h>
 
+#ifdef CONFIG_KPROBES
 #include <asm/kprobes.h>
 
 /* kprobe_status settings */
@@ -147,7 +148,6 @@
 	struct task_struct *task;
 };
 
-#ifdef CONFIG_KPROBES
 extern spinlock_t kretprobe_lock;
 extern int arch_prepare_kprobe(struct kprobe *p);
 extern void arch_copy_kprobe(struct kprobe *p);
@@ -158,6 +158,7 @@
 extern void show_registers(struct pt_regs *regs);
 extern kprobe_opcode_t *get_insn_slot(void);
 extern void free_insn_slot(kprobe_opcode_t *slot);
+extern void kprobes_inc_nmissed_count(struct kprobe *p);
 
 /* Get the kprobe at this addr (if any) - called with preemption disabled */
 struct kprobe *get_kprobe(void *addr);
@@ -195,6 +196,11 @@
 void kprobe_flush_task(struct task_struct *tk);
 void recycle_rp_inst(struct kretprobe_instance *ri);
 #else /* CONFIG_KPROBES */
+
+#define __kprobes	/**/
+struct jprobe;
+struct kretprobe;
+
 static inline struct kprobe *kprobe_running(void)
 {
 	return NULL;
diff -urN linux-2.6.15-rc5/include/linux/libata.h linux-2.6.15-rc6/include/linux/libata.h
--- linux-2.6.15-rc5/include/linux/libata.h	2005-12-18 22:27:57.423734745 -0800
+++ linux-2.6.15-rc6/include/linux/libata.h	2005-12-18 22:28:06.280129345 -0800
@@ -122,6 +122,7 @@
 	ATA_FLAG_NOINTR		= (1 << 9), /* FIXME: Remove this once
 					     * proper HSM is in place. */
 	ATA_FLAG_DEBUGMSG	= (1 << 10),
+	ATA_FLAG_NO_ATAPI	= (1 << 11), /* No ATAPI support */
 
 	ATA_QCFLAG_ACTIVE	= (1 << 1), /* cmd not yet ack'd to scsi lyer */
 	ATA_QCFLAG_SG		= (1 << 3), /* have s/g table? */
diff -urN linux-2.6.15-rc5/include/linux/list.h linux-2.6.15-rc6/include/linux/list.h
--- linux-2.6.15-rc5/include/linux/list.h	2005-12-18 22:27:57.423734745 -0800
+++ linux-2.6.15-rc6/include/linux/list.h	2005-12-18 22:28:06.280129345 -0800
@@ -202,12 +202,15 @@
  *
  * The old entry will be replaced with the new entry atomically.
  */
-static inline void list_replace_rcu(struct list_head *old, struct list_head *new){
+static inline void list_replace_rcu(struct list_head *old,
+				struct list_head *new)
+{
 	new->next = old->next;
 	new->prev = old->prev;
 	smp_wmb();
 	new->next->prev = new;
 	new->prev->next = new;
+	old->prev = LIST_POISON2;
 }
 
 /**
@@ -578,6 +581,27 @@
 	}
 }
 
+/*
+ * hlist_replace_rcu - replace old entry by new one
+ * @old : the element to be replaced
+ * @new : the new element to insert
+ *
+ * The old entry will be replaced with the new entry atomically.
+ */
+static inline void hlist_replace_rcu(struct hlist_node *old,
+					struct hlist_node *new)
+{
+	struct hlist_node *next = old->next;
+
+	new->next = next;
+	new->pprev = old->pprev;
+	smp_wmb();
+	if (next)
+		new->next->pprev = &new->next;
+	*new->pprev = new;
+	old->pprev = LIST_POISON2;
+}
+
 static inline void hlist_add_head(struct hlist_node *n, struct hlist_head *h)
 {
 	struct hlist_node *first = h->first;
diff -urN linux-2.6.15-rc5/include/linux/mm.h linux-2.6.15-rc6/include/linux/mm.h
--- linux-2.6.15-rc5/include/linux/mm.h	2005-12-18 22:27:57.426734878 -0800
+++ linux-2.6.15-rc6/include/linux/mm.h	2005-12-18 22:28:06.283129478 -0800
@@ -163,7 +163,7 @@
 #define VM_HUGETLB	0x00400000	/* Huge TLB Page VM */
 #define VM_NONLINEAR	0x00800000	/* Is non-linear (remap_file_pages) */
 #define VM_MAPPED_COPY	0x01000000	/* T if mapped copy of data (nommu mmap) */
-#define VM_INCOMPLETE	0x02000000	/* Strange partial PFN mapping marker */
+#define VM_INSERTPAGE	0x02000000	/* The vma has had "vm_insert_page()" done on it */
 
 #ifndef VM_STACK_DEFAULT_FLAGS		/* arch can override this */
 #define VM_STACK_DEFAULT_FLAGS VM_DATA_DEFAULT_FLAGS
diff -urN linux-2.6.15-rc5/include/linux/mtd/onenand.h linux-2.6.15-rc6/include/linux/mtd/onenand.h
--- linux-2.6.15-rc5/include/linux/mtd/onenand.h	2005-12-18 22:27:57.433735190 -0800
+++ linux-2.6.15-rc6/include/linux/mtd/onenand.h	2005-12-18 22:28:06.291129835 -0800
@@ -17,7 +17,6 @@
 #include <linux/mtd/bbm.h>
 
 #define MAX_BUFFERRAM		2
-#define MAX_ONENAND_PAGESIZE	(2048 + 64)
 
 /* Scan and identify a OneNAND device */
 extern int onenand_scan(struct mtd_info *mtd, int max_chips);
@@ -110,6 +109,7 @@
 	spinlock_t		chip_lock;
 	wait_queue_head_t	wq;
 	onenand_state_t		state;
+	unsigned char		*page_buf;
 
 	struct nand_oobinfo	*autooob;
 
@@ -134,13 +134,12 @@
  * Options bits
  */
 #define ONENAND_CONT_LOCK		(0x0001)
-
+#define ONENAND_PAGEBUF_ALLOC		(0x1000)
 
 /*
  * OneNAND Flash Manufacturer ID Codes
  */
 #define ONENAND_MFR_SAMSUNG	0xec
-#define ONENAND_MFR_UNKNOWN	0x00
 
 /**
  * struct nand_manufacturers - NAND Flash Manufacturer ID Structure
diff -urN linux-2.6.15-rc5/include/linux/parport_pc.h linux-2.6.15-rc6/include/linux/parport_pc.h
--- linux-2.6.15-rc5/include/linux/parport_pc.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/include/linux/parport_pc.h	2005-12-18 22:28:06.302130325 -0800
@@ -86,7 +86,7 @@
 	unsigned char dcr = inb (CONTROL (p));
 	unsigned char dsr = inb (STATUS (p));
 	static char *ecr_modes[] = {"SPP", "PS2", "PPFIFO", "ECP", "xXx", "yYy", "TST", "CFG"};
-	const struct parport_pc_private *priv = (parport_pc_private *)p->physport->private_data;
+	const struct parport_pc_private *priv = p->physport->private_data;
 	int i;
 
 	printk (KERN_DEBUG "*** parport state (%s): ecr=[%s", str, ecr_modes[(ecr & 0xe0) >> 5]);
diff -urN linux-2.6.15-rc5/include/linux/pci_ids.h linux-2.6.15-rc6/include/linux/pci_ids.h
--- linux-2.6.15-rc5/include/linux/pci_ids.h	2005-12-18 22:27:57.450735948 -0800
+++ linux-2.6.15-rc6/include/linux/pci_ids.h	2005-12-18 22:28:06.307130548 -0800
@@ -1244,6 +1244,7 @@
 #define PCI_DEVICE_ID_VIA_8378_0	0x3205
 #define PCI_DEVICE_ID_VIA_8783_0	0x3208
 #define PCI_DEVICE_ID_VIA_8237		0x3227
+#define PCI_DEVICE_ID_VIA_8251		0x3287
 #define PCI_DEVICE_ID_VIA_3296_0	0x0296
 #define PCI_DEVICE_ID_VIA_8231		0x8231
 #define PCI_DEVICE_ID_VIA_8231_4	0x8235
diff -urN linux-2.6.15-rc5/include/linux/rcupdate.h linux-2.6.15-rc6/include/linux/rcupdate.h
--- linux-2.6.15-rc5/include/linux/rcupdate.h	2005-12-18 22:27:57.457736260 -0800
+++ linux-2.6.15-rc6/include/linux/rcupdate.h	2005-12-18 22:28:06.314130860 -0800
@@ -100,6 +100,7 @@
 	struct rcu_head *donelist;
 	struct rcu_head **donetail;
 	int cpu;
+	struct rcu_head barrier;
 };
 
 DECLARE_PER_CPU(struct rcu_data, rcu_data);
@@ -285,6 +286,7 @@
 extern __deprecated_for_modules void synchronize_kernel(void);
 extern void synchronize_rcu(void);
 void synchronize_idle(void);
+extern void rcu_barrier(void);
 
 #endif /* __KERNEL__ */
 #endif /* __LINUX_RCUPDATE_H */
diff -urN linux-2.6.15-rc5/include/linux/sysctl.h linux-2.6.15-rc6/include/linux/sysctl.h
--- linux-2.6.15-rc5/include/linux/sysctl.h	2005-12-18 22:27:57.474737017 -0800
+++ linux-2.6.15-rc6/include/linux/sysctl.h	2005-12-18 22:28:06.331131617 -0800
@@ -670,6 +670,9 @@
 	NET_DECNET_DST_GC_INTERVAL = 9,
 	NET_DECNET_CONF = 10,
 	NET_DECNET_NO_FC_MAX_CWND = 11,
+	NET_DECNET_MEM = 12,
+	NET_DECNET_RMEM = 13,
+	NET_DECNET_WMEM = 14,
 	NET_DECNET_DEBUG_LEVEL = 255
 };
 
diff -urN linux-2.6.15-rc5/include/linux/time.h linux-2.6.15-rc6/include/linux/time.h
--- linux-2.6.15-rc5/include/linux/time.h	2005-12-18 22:27:57.476737106 -0800
+++ linux-2.6.15-rc6/include/linux/time.h	2005-12-18 22:28:06.332131662 -0800
@@ -95,6 +95,7 @@
 extern int do_setitimer(int which, struct itimerval *value, struct itimerval *ovalue);
 extern int do_getitimer(int which, struct itimerval *value);
 extern void getnstimeofday (struct timespec *tv);
+extern void getnstimestamp(struct timespec *ts);
 
 extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
 
diff -urN linux-2.6.15-rc5/include/media/saa7146.h linux-2.6.15-rc6/include/media/saa7146.h
--- linux-2.6.15-rc5/include/media/saa7146.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/include/media/saa7146.h	2005-12-18 22:28:06.342132107 -0800
@@ -14,7 +14,7 @@
 #include <linux/vmalloc.h>	/* for vmalloc() */
 #include <linux/mm.h>		/* for vmalloc_to_page() */
 
-#define SAA7146_VERSION_CODE 0x000500   /* 0.5.0 */
+#define SAA7146_VERSION_CODE 0x000500	/* 0.5.0 */
 
 #define saa7146_write(sxy,adr,dat)    writel((dat),(sxy->mem+(adr)))
 #define saa7146_read(sxy,adr)         readl(sxy->mem+(adr))
@@ -112,7 +112,7 @@
 
 	/* different device locks */
 	spinlock_t			slock;
-        struct semaphore		lock;
+	struct semaphore		lock;
 
 	unsigned char			__iomem *mem;		/* pointer to mapped IO memory */
 	int				revision;	/* chip revision; needed for bug-workarounds*/
@@ -133,7 +133,7 @@
 	void (*vv_callback)(struct saa7146_dev *dev, unsigned long status);
 
 	/* i2c-stuff */
-        struct semaphore	i2c_lock;
+	struct semaphore	i2c_lock;
 	u32			i2c_bitrate;
 	struct saa7146_dma	d_i2c;	/* pointer to i2c memory */
 	wait_queue_head_t	i2c_wq;
diff -urN linux-2.6.15-rc5/include/media/saa7146_vv.h linux-2.6.15-rc6/include/media/saa7146_vv.h
--- linux-2.6.15-rc5/include/media/saa7146_vv.h	2005-12-18 22:27:57.486737552 -0800
+++ linux-2.6.15-rc6/include/media/saa7146_vv.h	2005-12-18 22:28:06.342132107 -0800
@@ -113,7 +113,7 @@
 	/* vbi capture */
 	struct saa7146_dmaqueue		vbi_q;
 	/* vbi workaround interrupt queue */
-        wait_queue_head_t		vbi_wq;
+	wait_queue_head_t		vbi_wq;
 	int				vbi_fieldcount;
 	struct saa7146_fh		*vbi_streaming;
 
@@ -181,10 +181,10 @@
 };
 
 struct saa7146_use_ops  {
-        void (*init)(struct saa7146_dev *, struct saa7146_vv *);
-        int(*open)(struct saa7146_dev *, struct file *);
-        void (*release)(struct saa7146_dev *, struct file *);
-        void (*irq_done)(struct saa7146_dev *, unsigned long status);
+	void (*init)(struct saa7146_dev *, struct saa7146_vv *);
+	int(*open)(struct saa7146_dev *, struct file *);
+	void (*release)(struct saa7146_dev *, struct file *);
+	void (*irq_done)(struct saa7146_dev *, unsigned long status);
 	ssize_t (*read)(struct file *, char __user *, size_t, loff_t *);
 };
 
diff -urN linux-2.6.15-rc5/include/net/dn.h linux-2.6.15-rc6/include/net/dn.h
--- linux-2.6.15-rc5/include/net/dn.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/include/net/dn.h	2005-12-18 22:28:06.347132330 -0800
@@ -234,4 +234,8 @@
 extern int decnet_dr_count;
 extern int decnet_no_fc_max_cwnd;
 
+extern int sysctl_decnet_mem[3];
+extern int sysctl_decnet_wmem[3];
+extern int sysctl_decnet_rmem[3];
+
 #endif /* _NET_DN_H */
diff -urN linux-2.6.15-rc5/include/scsi/scsi_cmnd.h linux-2.6.15-rc6/include/scsi/scsi_cmnd.h
--- linux-2.6.15-rc5/include/scsi/scsi_cmnd.h	2005-12-18 22:27:57.510738621 -0800
+++ linux-2.6.15-rc6/include/scsi/scsi_cmnd.h	2005-12-18 22:28:06.366133177 -0800
@@ -151,5 +151,6 @@
 extern void scsi_put_command(struct scsi_cmnd *);
 extern void scsi_io_completion(struct scsi_cmnd *, unsigned int, unsigned int);
 extern void scsi_finish_command(struct scsi_cmnd *cmd);
+extern void scsi_setup_blk_pc_cmnd(struct scsi_cmnd *cmd, int retries);
 
 #endif /* _SCSI_SCSI_CMND_H */
diff -urN linux-2.6.15-rc5/init/Kconfig linux-2.6.15-rc6/init/Kconfig
--- linux-2.6.15-rc5/init/Kconfig	2005-12-18 22:27:57.518738978 -0800
+++ linux-2.6.15-rc6/init/Kconfig	2005-12-18 22:28:06.374133533 -0800
@@ -206,7 +206,7 @@
 	  outside the kernel tree does. Such modules require Y here.
 
 config KOBJECT_UEVENT
-	bool "Kernel Userspace Events"
+	bool "Kernel Userspace Events" if EMBEDDED
 	depends on NET
 	default y
 	help
@@ -256,6 +256,20 @@
 
 source "usr/Kconfig"
 
+config CC_OPTIMIZE_FOR_SIZE
+	bool "Optimize for size (Look out for broken compilers!)"
+	default y
+	depends on ARM || H8300 || EXPERIMENTAL
+	depends on !SPARC64
+	help
+	  Enabling this option will pass "-Os" instead of "-O2" to gcc
+	  resulting in a smaller kernel.
+
+	  WARNING: some versions of gcc may generate incorrect code with this
+	  option.  If problems are observed, a gcc upgrade may be needed.
+
+	  If unsure, say N.
+
 menuconfig EMBEDDED
 	bool "Configure standard kernel features (for small systems)"
 	help
@@ -338,18 +352,6 @@
 	  Disabling this option will cause the kernel to be built without
 	  support for epoll family of system calls.
 
-config CC_OPTIMIZE_FOR_SIZE
-	bool "Optimize for size" if EMBEDDED
-	default y if ARM || H8300
-	help
-	  Enabling this option will pass "-Os" instead of "-O2" to gcc
-	  resulting in a smaller kernel.
-
-	  WARNING: some versions of gcc may generate incorrect code with this
-	  option.  If problems are observed, a gcc upgrade may be needed.
-
-	  If unsure, say N.
-
 config SHMEM
 	bool "Use full shmem filesystem" if EMBEDDED
 	default y
diff -urN linux-2.6.15-rc5/kernel/audit.c linux-2.6.15-rc6/kernel/audit.c
--- linux-2.6.15-rc5/kernel/audit.c	2005-12-18 22:27:57.521739111 -0800
+++ linux-2.6.15-rc6/kernel/audit.c	2005-12-18 22:28:06.377133667 -0800
@@ -291,8 +291,10 @@
 			set_current_state(TASK_INTERRUPTIBLE);
 			add_wait_queue(&kauditd_wait, &wait);
 
-			if (!skb_queue_len(&audit_skb_queue))
+			if (!skb_queue_len(&audit_skb_queue)) {
+				try_to_freeze();
 				schedule();
+			}
 
 			__set_current_state(TASK_RUNNING);
 			remove_wait_queue(&kauditd_wait, &wait);
diff -urN linux-2.6.15-rc5/kernel/kprobes.c linux-2.6.15-rc6/kernel/kprobes.c
--- linux-2.6.15-rc5/kernel/kprobes.c	2005-12-18 22:27:57.529739468 -0800
+++ linux-2.6.15-rc6/kernel/kprobes.c	2005-12-18 22:28:06.386134068 -0800
@@ -246,6 +246,19 @@
 	return ret;
 }
 
+/* Walks the list and increments nmissed count for multiprobe case */
+void __kprobes kprobes_inc_nmissed_count(struct kprobe *p)
+{
+	struct kprobe *kp;
+	if (p->pre_handler != aggr_pre_handler) {
+		p->nmissed++;
+	} else {
+		list_for_each_entry_rcu(kp, &p->list, list)
+			kp->nmissed++;
+	}
+	return;
+}
+
 /* Called with kretprobe_lock held */
 struct kretprobe_instance __kprobes *get_free_rp_inst(struct kretprobe *rp)
 {
@@ -399,10 +412,7 @@
 	INIT_LIST_HEAD(&ap->list);
 	list_add_rcu(&p->list, &ap->list);
 
-	INIT_HLIST_NODE(&ap->hlist);
-	hlist_del_rcu(&p->hlist);
-	hlist_add_head_rcu(&ap->hlist,
-		&kprobe_table[hash_ptr(ap->addr, KPROBE_HASH_BITS)]);
+	hlist_replace_rcu(&p->hlist, &ap->hlist);
 }
 
 /*
@@ -462,9 +472,16 @@
 	int ret = 0;
 	unsigned long flags = 0;
 	struct kprobe *old_p;
+	struct module *mod;
+
+	if ((!kernel_text_address((unsigned long) p->addr)) ||
+		in_kprobes_functions((unsigned long) p->addr))
+		return -EINVAL;
+
+	if ((mod = module_text_address((unsigned long) p->addr)) &&
+			(unlikely(!try_module_get(mod))))
+		return -EINVAL;
 
-	if ((ret = in_kprobes_functions((unsigned long) p->addr)) != 0)
-		return ret;
 	if ((ret = arch_prepare_kprobe(p)) != 0)
 		goto rm_kprobe;
 
@@ -488,6 +505,8 @@
 rm_kprobe:
 	if (ret == -EEXIST)
 		arch_remove_kprobe(p);
+	if (ret && mod)
+		module_put(mod);
 	return ret;
 }
 
@@ -495,6 +514,7 @@
 {
 	unsigned long flags;
 	struct kprobe *old_p;
+	struct module *mod;
 
 	spin_lock_irqsave(&kprobe_lock, flags);
 	old_p = get_kprobe(p->addr);
@@ -506,6 +526,10 @@
 			cleanup_kprobe(p, flags);
 
 		synchronize_sched();
+
+		if ((mod = module_text_address((unsigned long)p->addr)))
+			module_put(mod);
+
 		if (old_p->pre_handler == aggr_pre_handler &&
 				list_empty(&old_p->list))
 			kfree(old_p);
diff -urN linux-2.6.15-rc5/kernel/rcupdate.c linux-2.6.15-rc6/kernel/rcupdate.c
--- linux-2.6.15-rc5/kernel/rcupdate.c	2005-12-18 22:27:57.539739913 -0800
+++ linux-2.6.15-rc6/kernel/rcupdate.c	2005-12-18 22:28:06.396134513 -0800
@@ -116,6 +116,10 @@
 	local_irq_restore(flags);
 }
 
+static atomic_t rcu_barrier_cpu_count;
+static struct semaphore rcu_barrier_sema;
+static struct completion rcu_barrier_completion;
+
 /**
  * call_rcu_bh - Queue an RCU for invocation after a quicker grace period.
  * @head: structure to be used for queueing the RCU updates.
@@ -162,6 +166,42 @@
 	return rcu_ctrlblk.completed;
 }
 
+static void rcu_barrier_callback(struct rcu_head *notused)
+{
+	if (atomic_dec_and_test(&rcu_barrier_cpu_count))
+		complete(&rcu_barrier_completion);
+}
+
+/*
+ * Called with preemption disabled, and from cross-cpu IRQ context.
+ */
+static void rcu_barrier_func(void *notused)
+{
+	int cpu = smp_processor_id();
+	struct rcu_data *rdp = &per_cpu(rcu_data, cpu);
+	struct rcu_head *head;
+
+	head = &rdp->barrier;
+	atomic_inc(&rcu_barrier_cpu_count);
+	call_rcu(head, rcu_barrier_callback);
+}
+
+/**
+ * rcu_barrier - Wait until all the in-flight RCUs are complete.
+ */
+void rcu_barrier(void)
+{
+	BUG_ON(in_interrupt());
+	/* Take cpucontrol semaphore to protect against CPU hotplug */
+	down(&rcu_barrier_sema);
+	init_completion(&rcu_barrier_completion);
+	atomic_set(&rcu_barrier_cpu_count, 0);
+	on_each_cpu(rcu_barrier_func, NULL, 0, 1);
+	wait_for_completion(&rcu_barrier_completion);
+	up(&rcu_barrier_sema);
+}
+EXPORT_SYMBOL_GPL(rcu_barrier);
+
 /*
  * Invoke the completed RCU callbacks. They are expected to be in
  * a per-cpu list.
@@ -217,15 +257,23 @@
 
 	if (rcp->next_pending &&
 			rcp->completed == rcp->cur) {
-		/* Can't change, since spin lock held. */
-		cpus_andnot(rsp->cpumask, cpu_online_map, nohz_cpu_mask);
-
 		rcp->next_pending = 0;
-		/* next_pending == 0 must be visible in __rcu_process_callbacks()
-		 * before it can see new value of cur.
+		/*
+		 * next_pending == 0 must be visible in
+		 * __rcu_process_callbacks() before it can see new value of cur.
 		 */
 		smp_wmb();
 		rcp->cur++;
+
+		/*
+		 * Accessing nohz_cpu_mask before incrementing rcp->cur needs a
+		 * Barrier  Otherwise it can cause tickless idle CPUs to be
+		 * included in rsp->cpumask, which will extend graceperiods
+		 * unnecessarily.
+		 */
+		smp_mb();
+		cpus_andnot(rsp->cpumask, cpu_online_map, nohz_cpu_mask);
+
 	}
 }
 
@@ -457,6 +505,7 @@
  */
 void __init rcu_init(void)
 {
+	sema_init(&rcu_barrier_sema, 1);
 	rcu_cpu_notify(&rcu_nb, CPU_UP_PREPARE,
 			(void *)(long)smp_processor_id());
 	/* Register notifier for non-boot CPUs */
diff -urN linux-2.6.15-rc5/kernel/rcutorture.c linux-2.6.15-rc6/kernel/rcutorture.c
--- linux-2.6.15-rc5/kernel/rcutorture.c	2005-12-18 22:27:57.540739958 -0800
+++ linux-2.6.15-rc6/kernel/rcutorture.c	2005-12-18 22:28:06.397134558 -0800
@@ -409,9 +409,8 @@
 	stats_task = NULL;
 
 	/* Wait for all RCU callbacks to fire.  */
+	rcu_barrier();
 
-	for (i = 0; i < RCU_TORTURE_PIPE_LEN; i++)
-		synchronize_rcu();
 	rcu_torture_stats_print();  /* -After- the stats thread is stopped! */
 	printk(KERN_ALERT TORTURE_FLAG
 	       "--- End of test: %s\n",
diff -urN linux-2.6.15-rc5/kernel/sys.c linux-2.6.15-rc6/kernel/sys.c
--- linux-2.6.15-rc5/kernel/sys.c	2005-12-18 22:27:57.547740270 -0800
+++ linux-2.6.15-rc6/kernel/sys.c	2005-12-18 22:28:06.404134870 -0800
@@ -32,6 +32,7 @@
 
 #include <linux/compat.h>
 #include <linux/syscalls.h>
+#include <linux/kprobes.h>
 
 #include <asm/uaccess.h>
 #include <asm/io.h>
@@ -168,7 +169,7 @@
  *	of the last notifier function called.
  */
  
-int notifier_call_chain(struct notifier_block **n, unsigned long val, void *v)
+int __kprobes notifier_call_chain(struct notifier_block **n, unsigned long val, void *v)
 {
 	int ret=NOTIFY_DONE;
 	struct notifier_block *nb = *n;
diff -urN linux-2.6.15-rc5/kernel/time.c linux-2.6.15-rc6/kernel/time.c
--- linux-2.6.15-rc5/kernel/time.c	2005-12-18 22:27:57.549740359 -0800
+++ linux-2.6.15-rc6/kernel/time.c	2005-12-18 22:28:06.406134959 -0800
@@ -561,6 +561,28 @@
 EXPORT_SYMBOL_GPL(getnstimeofday);
 #endif
 
+void getnstimestamp(struct timespec *ts)
+{
+	unsigned int seq;
+	struct timespec wall2mono;
+
+	/* synchronize with settimeofday() changes */
+	do {
+		seq = read_seqbegin(&xtime_lock);
+		getnstimeofday(ts);
+		wall2mono = wall_to_monotonic;
+	} while(unlikely(read_seqretry(&xtime_lock, seq)));
+
+	/* adjust to monotonicaly-increasing values */
+	ts->tv_sec += wall2mono.tv_sec;
+	ts->tv_nsec += wall2mono.tv_nsec;
+	while (unlikely(ts->tv_nsec >= NSEC_PER_SEC)) {
+		ts->tv_nsec -= NSEC_PER_SEC;
+		ts->tv_sec++;
+	}
+}
+EXPORT_SYMBOL_GPL(getnstimestamp);
+
 #if (BITS_PER_LONG < 64)
 u64 get_jiffies_64(void)
 {
diff -urN linux-2.6.15-rc5/mm/bootmem.c linux-2.6.15-rc6/mm/bootmem.c
--- linux-2.6.15-rc5/mm/bootmem.c	2005-12-18 22:27:57.561740894 -0800
+++ linux-2.6.15-rc6/mm/bootmem.c	2005-12-18 22:28:06.418135494 -0800
@@ -204,6 +204,8 @@
 		unsigned long j;
 		i = find_next_zero_bit(bdata->node_bootmem_map, eidx, i);
 		i = ALIGN(i, incr);
+		if (i >= eidx)
+			break;
 		if (test_bit(i, bdata->node_bootmem_map))
 			continue;
 		for (j = i + 1; j < i + areasize; ++j) {
diff -urN linux-2.6.15-rc5/mm/memory.c linux-2.6.15-rc6/mm/memory.c
--- linux-2.6.15-rc5/mm/memory.c	2005-12-18 22:27:57.568741206 -0800
+++ linux-2.6.15-rc6/mm/memory.c	2005-12-18 22:28:06.425135806 -0800
@@ -349,6 +349,11 @@
 	dump_stack();
 }
 
+static inline int is_cow_mapping(unsigned int flags)
+{
+	return (flags & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;
+}
+
 /*
  * This function gets the "struct page" associated with a pte.
  *
@@ -377,6 +382,8 @@
 		unsigned long off = (addr - vma->vm_start) >> PAGE_SHIFT;
 		if (pfn == vma->vm_pgoff + off)
 			return NULL;
+		if (!is_cow_mapping(vma->vm_flags))
+			return NULL;
 	}
 
 	/*
@@ -437,7 +444,7 @@
 	 * If it's a COW mapping, write protect it both
 	 * in the parent and the child
 	 */
-	if ((vm_flags & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE) {
+	if (is_cow_mapping(vm_flags)) {
 		ptep_set_wrprotect(src_mm, addr, src_pte);
 		pte = *src_pte;
 	}
@@ -567,7 +574,7 @@
 	 * readonly mappings. The tradeoff is that copy_page_range is more
 	 * efficient than faulting.
 	 */
-	if (!(vma->vm_flags & (VM_HUGETLB|VM_NONLINEAR|VM_PFNMAP))) {
+	if (!(vma->vm_flags & (VM_HUGETLB|VM_NONLINEAR|VM_PFNMAP|VM_INSERTPAGE))) {
 		if (!vma->anon_vma)
 			return 0;
 	}
@@ -1002,7 +1009,7 @@
 			continue;
 		}
 
-		if (!vma || (vma->vm_flags & VM_IO)
+		if (!vma || (vma->vm_flags & (VM_IO | VM_PFNMAP))
 				|| !(vm_flags & vma->vm_flags))
 			return i ? : -EFAULT;
 
@@ -1221,55 +1228,12 @@
 		return -EFAULT;
 	if (!page_count(page))
 		return -EINVAL;
+	vma->vm_flags |= VM_INSERTPAGE;
 	return insert_page(vma->vm_mm, addr, page, vma->vm_page_prot);
 }
 EXPORT_SYMBOL(vm_insert_page);
 
 /*
- * Somebody does a pfn remapping that doesn't actually work as a vma.
- *
- * Do it as individual pages instead, and warn about it. It's bad form,
- * and very inefficient.
- */
-static int incomplete_pfn_remap(struct vm_area_struct *vma,
-		unsigned long start, unsigned long end,
-		unsigned long pfn, pgprot_t prot)
-{
-	static int warn = 10;
-	struct page *page;
-	int retval;
-
-	if (!(vma->vm_flags & VM_INCOMPLETE)) {
-		if (warn) {
-			warn--;
-			printk("%s does an incomplete pfn remapping", current->comm);
-			dump_stack();
-		}
-	}
-	vma->vm_flags |= VM_INCOMPLETE | VM_IO | VM_RESERVED;
-
-	if (start < vma->vm_start || end > vma->vm_end)
-		return -EINVAL;
-
-	if (!pfn_valid(pfn))
-		return -EINVAL;
-
-	page = pfn_to_page(pfn);
-	if (!PageReserved(page))
-		return -EINVAL;
-
-	retval = 0;
-	while (start < end) {
-		retval = insert_page(vma->vm_mm, start, page, prot);
-		if (retval < 0)
-			break;
-		start += PAGE_SIZE;
-		page++;
-	}
-	return retval;
-}
-
-/*
  * maps a range of physical memory into the requested pages. the old
  * mappings are removed. any references to nonexistent pages results
  * in null mappings (currently treated as "copy-on-access")
@@ -1343,9 +1307,6 @@
 	struct mm_struct *mm = vma->vm_mm;
 	int err;
 
-	if (addr != vma->vm_start || end != vma->vm_end)
-		return incomplete_pfn_remap(vma, addr, end, pfn, prot);
-
 	/*
 	 * Physically remapped pages are special. Tell the
 	 * rest of the world about it:
@@ -1359,9 +1320,18 @@
 	 *   VM_PFNMAP tells the core MM that the base pages are just
 	 *	raw PFN mappings, and do not have a "struct page" associated
 	 *	with them.
+	 *
+	 * There's a horrible special case to handle copy-on-write
+	 * behaviour that some programs depend on. We mark the "original"
+	 * un-COW'ed pages by matching them up with "vma->vm_pgoff".
 	 */
+	if (is_cow_mapping(vma->vm_flags)) {
+		if (addr != vma->vm_start || end != vma->vm_end)
+			return -EINVAL;
+		vma->vm_pgoff = pfn;
+	}
+
 	vma->vm_flags |= VM_IO | VM_RESERVED | VM_PFNMAP;
-	vma->vm_pgoff = pfn;
 
 	BUG_ON(addr >= end);
 	pfn -= addr >> PAGE_SHIFT;
diff -urN linux-2.6.15-rc5/mm/memory_hotplug.c linux-2.6.15-rc6/mm/memory_hotplug.c
--- linux-2.6.15-rc5/mm/memory_hotplug.c	2005-12-18 22:27:57.569741250 -0800
+++ linux-2.6.15-rc6/mm/memory_hotplug.c	2005-12-18 22:28:06.426135850 -0800
@@ -104,7 +104,7 @@
 		pgdat->node_start_pfn = start_pfn;
 
 	if (end_pfn > old_pgdat_end_pfn)
-		pgdat->node_spanned_pages = end_pfn - pgdat->node_spanned_pages;
+		pgdat->node_spanned_pages = end_pfn - pgdat->node_start_pfn;
 }
 
 int online_pages(unsigned long pfn, unsigned long nr_pages)
diff -urN linux-2.6.15-rc5/mm/mmap.c linux-2.6.15-rc6/mm/mmap.c
--- linux-2.6.15-rc5/mm/mmap.c	2005-12-18 22:27:57.572741384 -0800
+++ linux-2.6.15-rc6/mm/mmap.c	2005-12-18 22:28:06.429135984 -0800
@@ -611,7 +611,7 @@
  * If the vma has a ->close operation then the driver probably needs to release
  * per-vma resources, so we don't attempt to merge those.
  */
-#define VM_SPECIAL (VM_IO | VM_DONTCOPY | VM_DONTEXPAND | VM_RESERVED)
+#define VM_SPECIAL (VM_IO | VM_DONTCOPY | VM_DONTEXPAND | VM_RESERVED | VM_PFNMAP)
 
 static inline int is_mergeable_vma(struct vm_area_struct *vma,
 			struct file *file, unsigned long vm_flags)
diff -urN linux-2.6.15-rc5/mm/mremap.c linux-2.6.15-rc6/mm/mremap.c
--- linux-2.6.15-rc5/mm/mremap.c	2005-12-18 22:27:57.573741428 -0800
+++ linux-2.6.15-rc6/mm/mremap.c	2005-12-18 22:28:06.430136028 -0800
@@ -323,7 +323,7 @@
 	/* We can't remap across vm area boundaries */
 	if (old_len > vma->vm_end - addr)
 		goto out;
-	if (vma->vm_flags & VM_DONTEXPAND) {
+	if (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP)) {
 		if (new_len > old_len)
 			goto out;
 	}
diff -urN linux-2.6.15-rc5/mm/page_alloc.c linux-2.6.15-rc6/mm/page_alloc.c
--- linux-2.6.15-rc5/mm/page_alloc.c	2005-12-18 22:27:57.577741607 -0800
+++ linux-2.6.15-rc6/mm/page_alloc.c	2005-12-18 22:28:06.434136207 -0800
@@ -1896,7 +1896,7 @@
 static struct notifier_block pageset_notifier =
 	{ &pageset_cpuup_callback, NULL, 0 };
 
-void __init setup_per_cpu_pageset()
+void __init setup_per_cpu_pageset(void)
 {
 	int err;
 
diff -urN linux-2.6.15-rc5/net/8021q/vlan_dev.c linux-2.6.15-rc6/net/8021q/vlan_dev.c
--- linux-2.6.15-rc5/net/8021q/vlan_dev.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/net/8021q/vlan_dev.c	2005-12-18 22:28:06.446136741 -0800
@@ -165,6 +165,9 @@
 
 	skb_pull(skb, VLAN_HLEN); /* take off the VLAN header (4 bytes currently) */
 
+	/* Need to correct hardware checksum */
+	skb_postpull_rcsum(skb, vhdr, VLAN_HLEN);
+
 	/* Ok, lets check to make sure the device (dev) we
 	 * came in on is what this VLAN is attached to.
 	 */
diff -urN linux-2.6.15-rc5/net/core/dev.c linux-2.6.15-rc6/net/core/dev.c
--- linux-2.6.15-rc5/net/core/dev.c	2005-12-18 22:27:57.603742765 -0800
+++ linux-2.6.15-rc6/net/core/dev.c	2005-12-18 22:28:06.460137365 -0800
@@ -1113,7 +1113,8 @@
 void netdev_rx_csum_fault(struct net_device *dev)
 {
 	if (net_ratelimit()) {
-		printk(KERN_ERR "%s: hw csum failure.\n", dev->name);
+		printk(KERN_ERR "%s: hw csum failure.\n", 
+			dev ? dev->name : "<unknown>");
 		dump_stack();
 	}
 }
diff -urN linux-2.6.15-rc5/net/core/skbuff.c linux-2.6.15-rc6/net/core/skbuff.c
--- linux-2.6.15-rc5/net/core/skbuff.c	2005-12-18 22:27:57.611743121 -0800
+++ linux-2.6.15-rc6/net/core/skbuff.c	2005-12-18 22:28:06.468137722 -0800
@@ -1725,7 +1725,7 @@
  * of the skb if any page alloc fails user this procedure returns  -ENOMEM
  */
 int skb_append_datato_frags(struct sock *sk, struct sk_buff *skb,
-			int getfrag(void *from, char *to, int offset,
+			int (*getfrag)(void *from, char *to, int offset,
 					int len, int odd, struct sk_buff *skb),
 			void *from, int length)
 {
diff -urN linux-2.6.15-rc5/net/decnet/af_decnet.c linux-2.6.15-rc6/net/decnet/af_decnet.c
--- linux-2.6.15-rc5/net/decnet/af_decnet.c	2005-12-18 22:27:57.615743300 -0800
+++ linux-2.6.15-rc6/net/decnet/af_decnet.c	2005-12-18 22:28:06.472137900 -0800
@@ -153,6 +153,7 @@
 static DEFINE_RWLOCK(dn_hash_lock);
 static struct hlist_head dn_sk_hash[DN_SK_HASH_SIZE];
 static struct hlist_head dn_wild_sk;
+static atomic_t decnet_memory_allocated;
 
 static int __dn_setsockopt(struct socket *sock, int level, int optname, char __user *optval, int optlen, int flags);
 static int __dn_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen, int flags);
@@ -446,10 +447,26 @@
 	dst_release(xchg(&sk->sk_dst_cache, NULL));
 }
 
+static int dn_memory_pressure;
+
+static void dn_enter_memory_pressure(void)
+{
+	if (!dn_memory_pressure) {
+		dn_memory_pressure = 1;
+	}
+}
+
 static struct proto dn_proto = {
-	.name	  = "DECNET",
-	.owner	  = THIS_MODULE,
-	.obj_size = sizeof(struct dn_sock),
+	.name			= "NSP",
+	.owner			= THIS_MODULE,
+	.enter_memory_pressure	= dn_enter_memory_pressure,
+	.memory_pressure	= &dn_memory_pressure,
+	.memory_allocated	= &decnet_memory_allocated,
+	.sysctl_mem		= sysctl_decnet_mem,
+	.sysctl_wmem		= sysctl_decnet_wmem,
+	.sysctl_rmem		= sysctl_decnet_rmem,
+	.max_header		= DN_MAX_NSP_DATA_HEADER + 64,
+	.obj_size		= sizeof(struct dn_sock),
 };
 
 static struct sock *dn_alloc_sock(struct socket *sock, gfp_t gfp)
@@ -470,6 +487,8 @@
 	sk->sk_family      = PF_DECnet;
 	sk->sk_protocol    = 0;
 	sk->sk_allocation  = gfp;
+	sk->sk_sndbuf	   = sysctl_decnet_wmem[1];
+	sk->sk_rcvbuf	   = sysctl_decnet_rmem[1];
 
 	/* Initialization of DECnet Session Control Port		*/
 	scp = DN_SK(sk);
diff -urN linux-2.6.15-rc5/net/decnet/sysctl_net_decnet.c linux-2.6.15-rc6/net/decnet/sysctl_net_decnet.c
--- linux-2.6.15-rc5/net/decnet/sysctl_net_decnet.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/net/decnet/sysctl_net_decnet.c	2005-12-18 22:28:06.473137944 -0800
@@ -10,6 +10,7 @@
  *
  * Changes:
  * Steve Whitehouse - C99 changes and default device handling
+ * Steve Whitehouse - Memory buffer settings, like the tcp ones
  *
  */
 #include <linux/config.h>
@@ -37,6 +38,11 @@
 int decnet_log_martians = 1;
 int decnet_no_fc_max_cwnd = NSP_MIN_WINDOW;
 
+/* Reasonable defaults, I hope, based on tcp's defaults */
+int sysctl_decnet_mem[3] = { 768 << 3, 1024 << 3, 1536 << 3 };
+int sysctl_decnet_wmem[3] = { 4 * 1024, 16 * 1024, 128 * 1024 };
+int sysctl_decnet_rmem[3] = { 4 * 1024, 87380, 87380 * 2 };
+
 #ifdef CONFIG_SYSCTL
 extern int decnet_dst_gc_interval;
 static int min_decnet_time_wait[] = { 5 };
@@ -428,6 +434,33 @@
 		.extra1 = &min_decnet_no_fc_max_cwnd,
 		.extra2 = &max_decnet_no_fc_max_cwnd
 	},
+       {
+                .ctl_name = NET_DECNET_MEM,
+                .procname = "decnet_mem",
+                .data = &sysctl_decnet_mem,
+                .maxlen = sizeof(sysctl_decnet_mem),
+                .mode = 0644,
+                .proc_handler = &proc_dointvec,
+                .strategy = &sysctl_intvec,
+        },
+        {
+                .ctl_name = NET_DECNET_RMEM,
+                .procname = "decnet_rmem",
+                .data = &sysctl_decnet_rmem,
+                .maxlen = sizeof(sysctl_decnet_rmem),
+                .mode = 0644,
+                .proc_handler = &proc_dointvec,
+                .strategy = &sysctl_intvec,
+        },
+        {
+                .ctl_name = NET_DECNET_WMEM,
+                .procname = "decnet_wmem",
+                .data = &sysctl_decnet_wmem,
+                .maxlen = sizeof(sysctl_decnet_wmem),
+                .mode = 0644,
+                .proc_handler = &proc_dointvec,
+                .strategy = &sysctl_intvec,
+        },
 	{
 		.ctl_name = NET_DECNET_DEBUG_LEVEL,
 		.procname = "debug",
diff -urN linux-2.6.15-rc5/net/ieee80211/Kconfig linux-2.6.15-rc6/net/ieee80211/Kconfig
--- linux-2.6.15-rc5/net/ieee80211/Kconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/net/ieee80211/Kconfig	2005-12-18 22:28:06.474137989 -0800
@@ -55,7 +55,7 @@
 
 config IEEE80211_CRYPT_TKIP
 	tristate "IEEE 802.11i TKIP encryption"
-	depends on IEEE80211
+	depends on IEEE80211 && NET_RADIO
 	select CRYPTO
 	select CRYPTO_MICHAEL_MIC
 	---help---
diff -urN linux-2.6.15-rc5/net/ipv4/ip_gre.c linux-2.6.15-rc6/net/ipv4/ip_gre.c
--- linux-2.6.15-rc5/net/ipv4/ip_gre.c	2005-12-18 22:27:57.633744102 -0800
+++ linux-2.6.15-rc6/net/ipv4/ip_gre.c	2005-12-18 22:28:06.490138702 -0800
@@ -618,7 +618,7 @@
 
 		skb->mac.raw = skb->nh.raw;
 		skb->nh.raw = __pskb_pull(skb, offset);
-		skb_postpull_rcsum(skb, skb->mac.raw, offset);
+		skb_postpull_rcsum(skb, skb->h.raw, offset);
 		memset(&(IPCB(skb)->opt), 0, sizeof(struct ip_options));
 		skb->pkt_type = PACKET_HOST;
 #ifdef CONFIG_NET_IPGRE_BROADCAST
diff -urN linux-2.6.15-rc5/net/ipv4/netfilter/Kconfig linux-2.6.15-rc6/net/ipv4/netfilter/Kconfig
--- linux-2.6.15-rc5/net/ipv4/netfilter/Kconfig	2005-12-18 22:27:57.639744369 -0800
+++ linux-2.6.15-rc6/net/ipv4/netfilter/Kconfig	2005-12-18 22:28:06.496138969 -0800
@@ -56,8 +56,8 @@
 	  instead of the individual packets.
 	
 config IP_NF_CONNTRACK_EVENTS
-	bool "Connection tracking events"
-	depends on IP_NF_CONNTRACK
+	bool "Connection tracking events (EXPERIMENTAL)"
+	depends on EXPERIMENTAL && IP_NF_CONNTRACK
 	help
 	  If this option is enabled, the connection tracking code will
 	  provide a notifier chain that can be used by other kernel code
@@ -66,8 +66,8 @@
 	  IF unsure, say `N'.
 
 config IP_NF_CONNTRACK_NETLINK
-	tristate 'Connection tracking netlink interface'
-	depends on IP_NF_CONNTRACK && NETFILTER_NETLINK
+	tristate 'Connection tracking netlink interface (EXPERIMENTAL)'
+	depends on EXPERIMENTAL && IP_NF_CONNTRACK && NETFILTER_NETLINK
 	depends on IP_NF_CONNTRACK!=y || NETFILTER_NETLINK!=m
 	help
 	  This option enables support for a netlink-based userspace interface
diff -urN linux-2.6.15-rc5/net/ipv4/netfilter/ip_conntrack_core.c linux-2.6.15-rc6/net/ipv4/netfilter/ip_conntrack_core.c
--- linux-2.6.15-rc5/net/ipv4/netfilter/ip_conntrack_core.c	2005-12-18 22:27:57.641744458 -0800
+++ linux-2.6.15-rc6/net/ipv4/netfilter/ip_conntrack_core.c	2005-12-18 22:28:06.499139103 -0800
@@ -1345,6 +1345,11 @@
 	return 1;
 }
 
+void ip_conntrack_flush(void)
+{
+	ip_ct_iterate_cleanup(kill_all, NULL);
+}
+
 static void free_conntrack_hash(struct list_head *hash, int vmalloced,int size)
 {
 	if (vmalloced)
@@ -1354,8 +1359,12 @@
 			   get_order(sizeof(struct list_head) * size));
 }
 
-void ip_conntrack_flush(void)
+/* Mishearing the voices in his head, our hero wonders how he's
+   supposed to kill the mall. */
+void ip_conntrack_cleanup(void)
 {
+	ip_ct_attach = NULL;
+
 	/* This makes sure all current packets have passed through
            netfilter framework.  Roll on, two-stage module
            delete... */
@@ -1363,7 +1372,7 @@
 
 	ip_ct_event_cache_flush();
  i_see_dead_people:
-	ip_ct_iterate_cleanup(kill_all, NULL);
+	ip_conntrack_flush();
 	if (atomic_read(&ip_conntrack_count) != 0) {
 		schedule();
 		goto i_see_dead_people;
@@ -1371,14 +1380,7 @@
 	/* wait until all references to ip_conntrack_untracked are dropped */
 	while (atomic_read(&ip_conntrack_untracked.ct_general.use) > 1)
 		schedule();
-}
 
-/* Mishearing the voices in his head, our hero wonders how he's
-   supposed to kill the mall. */
-void ip_conntrack_cleanup(void)
-{
-	ip_ct_attach = NULL;
-	ip_conntrack_flush();
 	kmem_cache_destroy(ip_conntrack_cachep);
 	kmem_cache_destroy(ip_conntrack_expect_cachep);
 	free_conntrack_hash(ip_conntrack_hash, ip_conntrack_vmalloc,
diff -urN linux-2.6.15-rc5/net/ipv4/netfilter/ip_conntrack_netlink.c linux-2.6.15-rc6/net/ipv4/netfilter/ip_conntrack_netlink.c
--- linux-2.6.15-rc5/net/ipv4/netfilter/ip_conntrack_netlink.c	2005-12-18 22:27:57.644744592 -0800
+++ linux-2.6.15-rc6/net/ipv4/netfilter/ip_conntrack_netlink.c	2005-12-18 22:28:06.502139237 -0800
@@ -503,7 +503,7 @@
 }
 
 static const size_t cta_min_proto[CTA_PROTO_MAX] = {
-	[CTA_PROTO_NUM-1]	= sizeof(u_int16_t),
+	[CTA_PROTO_NUM-1]	= sizeof(u_int8_t),
 	[CTA_PROTO_SRC_PORT-1]	= sizeof(u_int16_t),
 	[CTA_PROTO_DST_PORT-1]	= sizeof(u_int16_t),
 	[CTA_PROTO_ICMP_TYPE-1]	= sizeof(u_int8_t),
@@ -528,7 +528,7 @@
 
 	if (!tb[CTA_PROTO_NUM-1])
 		return -EINVAL;
-	tuple->dst.protonum = *(u_int16_t *)NFA_DATA(tb[CTA_PROTO_NUM-1]);
+	tuple->dst.protonum = *(u_int8_t *)NFA_DATA(tb[CTA_PROTO_NUM-1]);
 
 	proto = ip_conntrack_proto_find_get(tuple->dst.protonum);
 
@@ -728,11 +728,9 @@
 			return -ENOENT;
 		}
 	}	
-	if (del_timer(&ct->timeout)) {
-		ip_conntrack_put(ct);
+	if (del_timer(&ct->timeout))
 		ct->timeout.function((unsigned long)ct);
-		return 0;
-	}
+
 	ip_conntrack_put(ct);
 	DEBUGP("leaving\n");
 
@@ -877,7 +875,7 @@
 		DEBUGP("NAT status: %lu\n", 
 		       status & (IPS_NAT_MASK | IPS_NAT_DONE_MASK));
 		
-		if (ip_nat_initialized(ct, hooknum))
+		if (ip_nat_initialized(ct, HOOK2MANIP(hooknum)))
 			return -EEXIST;
 		ip_nat_setup_info(ct, &range, hooknum);
 
diff -urN linux-2.6.15-rc5/net/ipv4/netfilter/ip_conntrack_proto_tcp.c linux-2.6.15-rc6/net/ipv4/netfilter/ip_conntrack_proto_tcp.c
--- linux-2.6.15-rc5/net/ipv4/netfilter/ip_conntrack_proto_tcp.c	2005-12-18 22:27:57.646744681 -0800
+++ linux-2.6.15-rc6/net/ipv4/netfilter/ip_conntrack_proto_tcp.c	2005-12-18 22:28:06.504139326 -0800
@@ -341,9 +341,10 @@
 static int tcp_to_nfattr(struct sk_buff *skb, struct nfattr *nfa,
 			 const struct ip_conntrack *ct)
 {
-	struct nfattr *nest_parms = NFA_NEST(skb, CTA_PROTOINFO_TCP);
+	struct nfattr *nest_parms;
 	
 	read_lock_bh(&tcp_lock);
+	nest_parms = NFA_NEST(skb, CTA_PROTOINFO_TCP);
 	NFA_PUT(skb, CTA_PROTOINFO_TCP_STATE, sizeof(u_int8_t),
 		&ct->proto.tcp.state);
 	read_unlock_bh(&tcp_lock);
diff -urN linux-2.6.15-rc5/net/ipv4/netfilter/ip_nat_tftp.c linux-2.6.15-rc6/net/ipv4/netfilter/ip_nat_tftp.c
--- linux-2.6.15-rc5/net/ipv4/netfilter/ip_nat_tftp.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/net/ipv4/netfilter/ip_nat_tftp.c	2005-12-18 22:28:06.506139415 -0800
@@ -42,7 +42,10 @@
 			 enum ip_conntrack_info ctinfo,
 			 struct ip_conntrack_expect *exp)
 {
-	exp->saved_proto.udp.port = exp->tuple.dst.u.tcp.port;
+	struct ip_conntrack *ct = exp->master;
+
+	exp->saved_proto.udp.port
+		= ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.udp.port;
 	exp->dir = IP_CT_DIR_REPLY;
 	exp->expectfn = ip_nat_follow_master;
 	if (ip_conntrack_expect_related(exp) != 0)
diff -urN linux-2.6.15-rc5/net/ipv4/tcp_output.c linux-2.6.15-rc6/net/ipv4/tcp_output.c
--- linux-2.6.15-rc5/net/ipv4/tcp_output.c	2005-12-18 22:27:57.666745572 -0800
+++ linux-2.6.15-rc6/net/ipv4/tcp_output.c	2005-12-18 22:28:06.524140217 -0800
@@ -262,122 +262,139 @@
  * We are working here with either a clone of the original
  * SKB, or a fresh unique copy made by the retransmit engine.
  */
-static int tcp_transmit_skb(struct sock *sk, struct sk_buff *skb)
+static int tcp_transmit_skb(struct sock *sk, struct sk_buff *skb, int clone_it, gfp_t gfp_mask)
 {
-	if (skb != NULL) {
-		const struct inet_connection_sock *icsk = inet_csk(sk);
-		struct inet_sock *inet = inet_sk(sk);
-		struct tcp_sock *tp = tcp_sk(sk);
-		struct tcp_skb_cb *tcb = TCP_SKB_CB(skb);
-		int tcp_header_size = tp->tcp_header_len;
-		struct tcphdr *th;
-		int sysctl_flags;
-		int err;
+	const struct inet_connection_sock *icsk = inet_csk(sk);
+	struct inet_sock *inet;
+	struct tcp_sock *tp;
+	struct tcp_skb_cb *tcb;
+	int tcp_header_size;
+	struct tcphdr *th;
+	int sysctl_flags;
+	int err;
+
+	BUG_ON(!skb || !tcp_skb_pcount(skb));
+
+	/* If congestion control is doing timestamping, we must
+	 * take such a timestamp before we potentially clone/copy.
+	 */
+	if (icsk->icsk_ca_ops->rtt_sample)
+		__net_timestamp(skb);
 
-		BUG_ON(!tcp_skb_pcount(skb));
+	if (likely(clone_it)) {
+		if (unlikely(skb_cloned(skb)))
+			skb = pskb_copy(skb, gfp_mask);
+		else
+			skb = skb_clone(skb, gfp_mask);
+		if (unlikely(!skb))
+			return -ENOBUFS;
+	}
+
+	inet = inet_sk(sk);
+	tp = tcp_sk(sk);
+	tcb = TCP_SKB_CB(skb);
+	tcp_header_size = tp->tcp_header_len;
 
 #define SYSCTL_FLAG_TSTAMPS	0x1
 #define SYSCTL_FLAG_WSCALE	0x2
 #define SYSCTL_FLAG_SACK	0x4
 
-		/* If congestion control is doing timestamping */
-		if (icsk->icsk_ca_ops->rtt_sample)
-			__net_timestamp(skb);
-
-		sysctl_flags = 0;
-		if (tcb->flags & TCPCB_FLAG_SYN) {
-			tcp_header_size = sizeof(struct tcphdr) + TCPOLEN_MSS;
-			if(sysctl_tcp_timestamps) {
-				tcp_header_size += TCPOLEN_TSTAMP_ALIGNED;
-				sysctl_flags |= SYSCTL_FLAG_TSTAMPS;
-			}
-			if(sysctl_tcp_window_scaling) {
-				tcp_header_size += TCPOLEN_WSCALE_ALIGNED;
-				sysctl_flags |= SYSCTL_FLAG_WSCALE;
-			}
-			if(sysctl_tcp_sack) {
-				sysctl_flags |= SYSCTL_FLAG_SACK;
-				if(!(sysctl_flags & SYSCTL_FLAG_TSTAMPS))
-					tcp_header_size += TCPOLEN_SACKPERM_ALIGNED;
-			}
-		} else if (tp->rx_opt.eff_sacks) {
-			/* A SACK is 2 pad bytes, a 2 byte header, plus
-			 * 2 32-bit sequence numbers for each SACK block.
-			 */
-			tcp_header_size += (TCPOLEN_SACK_BASE_ALIGNED +
-					    (tp->rx_opt.eff_sacks * TCPOLEN_SACK_PERBLOCK));
-		}
+	sysctl_flags = 0;
+	if (unlikely(tcb->flags & TCPCB_FLAG_SYN)) {
+		tcp_header_size = sizeof(struct tcphdr) + TCPOLEN_MSS;
+		if(sysctl_tcp_timestamps) {
+			tcp_header_size += TCPOLEN_TSTAMP_ALIGNED;
+			sysctl_flags |= SYSCTL_FLAG_TSTAMPS;
+		}
+		if (sysctl_tcp_window_scaling) {
+			tcp_header_size += TCPOLEN_WSCALE_ALIGNED;
+			sysctl_flags |= SYSCTL_FLAG_WSCALE;
+		}
+		if (sysctl_tcp_sack) {
+			sysctl_flags |= SYSCTL_FLAG_SACK;
+			if (!(sysctl_flags & SYSCTL_FLAG_TSTAMPS))
+				tcp_header_size += TCPOLEN_SACKPERM_ALIGNED;
+		}
+	} else if (unlikely(tp->rx_opt.eff_sacks)) {
+		/* A SACK is 2 pad bytes, a 2 byte header, plus
+		 * 2 32-bit sequence numbers for each SACK block.
+		 */
+		tcp_header_size += (TCPOLEN_SACK_BASE_ALIGNED +
+				    (tp->rx_opt.eff_sacks *
+				     TCPOLEN_SACK_PERBLOCK));
+	}
 		
-		if (tcp_packets_in_flight(tp) == 0)
-			tcp_ca_event(sk, CA_EVENT_TX_START);
+	if (tcp_packets_in_flight(tp) == 0)
+		tcp_ca_event(sk, CA_EVENT_TX_START);
 
-		th = (struct tcphdr *) skb_push(skb, tcp_header_size);
-		skb->h.th = th;
-		skb_set_owner_w(skb, sk);
-
-		/* Build TCP header and checksum it. */
-		th->source		= inet->sport;
-		th->dest		= inet->dport;
-		th->seq			= htonl(tcb->seq);
-		th->ack_seq		= htonl(tp->rcv_nxt);
-		*(((__u16 *)th) + 6)	= htons(((tcp_header_size >> 2) << 12) | tcb->flags);
-		if (tcb->flags & TCPCB_FLAG_SYN) {
-			/* RFC1323: The window in SYN & SYN/ACK segments
-			 * is never scaled.
-			 */
-			th->window	= htons(tp->rcv_wnd);
-		} else {
-			th->window	= htons(tcp_select_window(sk));
-		}
-		th->check		= 0;
-		th->urg_ptr		= 0;
-
-		if (tp->urg_mode &&
-		    between(tp->snd_up, tcb->seq+1, tcb->seq+0xFFFF)) {
-			th->urg_ptr		= htons(tp->snd_up-tcb->seq);
-			th->urg			= 1;
-		}
-
-		if (tcb->flags & TCPCB_FLAG_SYN) {
-			tcp_syn_build_options((__u32 *)(th + 1),
-					      tcp_advertise_mss(sk),
-					      (sysctl_flags & SYSCTL_FLAG_TSTAMPS),
-					      (sysctl_flags & SYSCTL_FLAG_SACK),
-					      (sysctl_flags & SYSCTL_FLAG_WSCALE),
-					      tp->rx_opt.rcv_wscale,
-					      tcb->when,
-		      			      tp->rx_opt.ts_recent);
-		} else {
-			tcp_build_and_update_options((__u32 *)(th + 1),
-						     tp, tcb->when);
+	th = (struct tcphdr *) skb_push(skb, tcp_header_size);
+	skb->h.th = th;
+	skb_set_owner_w(skb, sk);
+
+	/* Build TCP header and checksum it. */
+	th->source		= inet->sport;
+	th->dest		= inet->dport;
+	th->seq			= htonl(tcb->seq);
+	th->ack_seq		= htonl(tp->rcv_nxt);
+	*(((__u16 *)th) + 6)	= htons(((tcp_header_size >> 2) << 12) |
+					tcb->flags);
+
+	if (unlikely(tcb->flags & TCPCB_FLAG_SYN)) {
+		/* RFC1323: The window in SYN & SYN/ACK segments
+		 * is never scaled.
+		 */
+		th->window	= htons(tp->rcv_wnd);
+	} else {
+		th->window	= htons(tcp_select_window(sk));
+	}
+	th->check		= 0;
+	th->urg_ptr		= 0;
 
-			TCP_ECN_send(sk, tp, skb, tcp_header_size);
-		}
-		tp->af_specific->send_check(sk, th, skb->len, skb);
+	if (unlikely(tp->urg_mode &&
+		     between(tp->snd_up, tcb->seq+1, tcb->seq+0xFFFF))) {
+		th->urg_ptr		= htons(tp->snd_up-tcb->seq);
+		th->urg			= 1;
+	}
+
+	if (unlikely(tcb->flags & TCPCB_FLAG_SYN)) {
+		tcp_syn_build_options((__u32 *)(th + 1),
+				      tcp_advertise_mss(sk),
+				      (sysctl_flags & SYSCTL_FLAG_TSTAMPS),
+				      (sysctl_flags & SYSCTL_FLAG_SACK),
+				      (sysctl_flags & SYSCTL_FLAG_WSCALE),
+				      tp->rx_opt.rcv_wscale,
+				      tcb->when,
+				      tp->rx_opt.ts_recent);
+	} else {
+		tcp_build_and_update_options((__u32 *)(th + 1),
+					     tp, tcb->when);
+		TCP_ECN_send(sk, tp, skb, tcp_header_size);
+	}
 
-		if (tcb->flags & TCPCB_FLAG_ACK)
-			tcp_event_ack_sent(sk, tcp_skb_pcount(skb));
+	tp->af_specific->send_check(sk, th, skb->len, skb);
 
-		if (skb->len != tcp_header_size)
-			tcp_event_data_sent(tp, skb, sk);
+	if (likely(tcb->flags & TCPCB_FLAG_ACK))
+		tcp_event_ack_sent(sk, tcp_skb_pcount(skb));
 
-		TCP_INC_STATS(TCP_MIB_OUTSEGS);
+	if (skb->len != tcp_header_size)
+		tcp_event_data_sent(tp, skb, sk);
 
-		err = tp->af_specific->queue_xmit(skb, 0);
-		if (err <= 0)
-			return err;
+	TCP_INC_STATS(TCP_MIB_OUTSEGS);
 
-		tcp_enter_cwr(sk);
+	err = tp->af_specific->queue_xmit(skb, 0);
+	if (unlikely(err <= 0))
+		return err;
+
+	tcp_enter_cwr(sk);
+
+	/* NET_XMIT_CN is special. It does not guarantee,
+	 * that this packet is lost. It tells that device
+	 * is about to start to drop packets or already
+	 * drops some packets of the same priority and
+	 * invokes us to send less aggressively.
+	 */
+	return err == NET_XMIT_CN ? 0 : err;
 
-		/* NET_XMIT_CN is special. It does not guarantee,
-		 * that this packet is lost. It tells that device
-		 * is about to start to drop packets or already
-		 * drops some packets of the same priority and
-		 * invokes us to send less aggressively.
-		 */
-		return err == NET_XMIT_CN ? 0 : err;
-	}
-	return -ENOBUFS;
 #undef SYSCTL_FLAG_TSTAMPS
 #undef SYSCTL_FLAG_WSCALE
 #undef SYSCTL_FLAG_SACK
@@ -1036,7 +1053,7 @@
 
 		TCP_SKB_CB(skb)->when = tcp_time_stamp;
 
-		if (unlikely(tcp_transmit_skb(sk, skb_clone(skb, GFP_ATOMIC))))
+		if (unlikely(tcp_transmit_skb(sk, skb, 1, GFP_ATOMIC)))
 			break;
 
 		/* Advance the send_head.  This one is sent out.
@@ -1109,7 +1126,7 @@
 		/* Send it out now. */
 		TCP_SKB_CB(skb)->when = tcp_time_stamp;
 
-		if (likely(!tcp_transmit_skb(sk, skb_clone(skb, sk->sk_allocation)))) {
+		if (likely(!tcp_transmit_skb(sk, skb, 1, sk->sk_allocation))) {
 			update_send_head(sk, tp, skb);
 			tcp_cwnd_validate(sk, tp);
 			return;
@@ -1429,9 +1446,7 @@
 	 */
 	TCP_SKB_CB(skb)->when = tcp_time_stamp;
 
-	err = tcp_transmit_skb(sk, (skb_cloned(skb) ?
-				    pskb_copy(skb, GFP_ATOMIC):
-				    skb_clone(skb, GFP_ATOMIC)));
+	err = tcp_transmit_skb(sk, skb, 1, GFP_ATOMIC);
 
 	if (err == 0) {
 		/* Update global TCP statistics. */
@@ -1665,7 +1680,7 @@
 	TCP_SKB_CB(skb)->seq = tcp_acceptable_seq(sk, tp);
 	TCP_SKB_CB(skb)->end_seq = TCP_SKB_CB(skb)->seq;
 	TCP_SKB_CB(skb)->when = tcp_time_stamp;
-	if (tcp_transmit_skb(sk, skb))
+	if (tcp_transmit_skb(sk, skb, 0, priority))
 		NET_INC_STATS(LINUX_MIB_TCPABORTFAILED);
 }
 
@@ -1700,7 +1715,7 @@
 		TCP_ECN_send_synack(tcp_sk(sk), skb);
 	}
 	TCP_SKB_CB(skb)->when = tcp_time_stamp;
-	return tcp_transmit_skb(sk, skb_clone(skb, GFP_ATOMIC));
+	return tcp_transmit_skb(sk, skb, 1, GFP_ATOMIC);
 }
 
 /*
@@ -1861,7 +1876,7 @@
 	__skb_queue_tail(&sk->sk_write_queue, buff);
 	sk_charge_skb(sk, buff);
 	tp->packets_out += tcp_skb_pcount(buff);
-	tcp_transmit_skb(sk, skb_clone(buff, GFP_KERNEL));
+	tcp_transmit_skb(sk, buff, 1, GFP_KERNEL);
 	TCP_INC_STATS(TCP_MIB_ACTIVEOPENS);
 
 	/* Timer for repeating the SYN until an answer. */
@@ -1957,7 +1972,7 @@
 		/* Send it off, this clears delayed acks for us. */
 		TCP_SKB_CB(buff)->seq = TCP_SKB_CB(buff)->end_seq = tcp_acceptable_seq(sk, tp);
 		TCP_SKB_CB(buff)->when = tcp_time_stamp;
-		tcp_transmit_skb(sk, buff);
+		tcp_transmit_skb(sk, buff, 0, GFP_ATOMIC);
 	}
 }
 
@@ -1997,7 +2012,7 @@
 	TCP_SKB_CB(skb)->seq = urgent ? tp->snd_una : tp->snd_una - 1;
 	TCP_SKB_CB(skb)->end_seq = TCP_SKB_CB(skb)->seq;
 	TCP_SKB_CB(skb)->when = tcp_time_stamp;
-	return tcp_transmit_skb(sk, skb);
+	return tcp_transmit_skb(sk, skb, 0, GFP_ATOMIC);
 }
 
 int tcp_write_wakeup(struct sock *sk)
@@ -2030,7 +2045,7 @@
 
 			TCP_SKB_CB(skb)->flags |= TCPCB_FLAG_PSH;
 			TCP_SKB_CB(skb)->when = tcp_time_stamp;
-			err = tcp_transmit_skb(sk, skb_clone(skb, GFP_ATOMIC));
+			err = tcp_transmit_skb(sk, skb, 1, GFP_ATOMIC);
 			if (!err) {
 				update_send_head(sk, tp, skb);
 			}
diff -urN linux-2.6.15-rc5/net/ipv4/tcp_vegas.c linux-2.6.15-rc6/net/ipv4/tcp_vegas.c
--- linux-2.6.15-rc5/net/ipv4/tcp_vegas.c	2005-12-18 22:27:57.667745617 -0800
+++ linux-2.6.15-rc6/net/ipv4/tcp_vegas.c	2005-12-18 22:28:06.525140261 -0800
@@ -215,14 +215,6 @@
 		vegas->beg_snd_nxt  = tp->snd_nxt;
 		vegas->beg_snd_cwnd = tp->snd_cwnd;
 
-		/* Take into account the current RTT sample too, to
-		 * decrease the impact of delayed acks. This double counts
-		 * this sample since we count it for the next window as well,
-		 * but that's not too awful, since we're taking the min,
-		 * rather than averaging.
-		 */
-		tcp_vegas_rtt_calc(sk, seq_rtt * 1000);
-
 		/* We do the Vegas calculations only if we got enough RTT
 		 * samples that we can be reasonably sure that we got
 		 * at least one RTT sample that wasn't from a delayed ACK.
@@ -333,11 +325,11 @@
 			else if (tp->snd_cwnd > tp->snd_cwnd_clamp)
 				tp->snd_cwnd = tp->snd_cwnd_clamp;
 		}
-	}
 
-	/* Wipe the slate clean for the next RTT. */
-	vegas->cntRTT = 0;
-	vegas->minRTT = 0x7fffffff;
+		/* Wipe the slate clean for the next RTT. */
+		vegas->cntRTT = 0;
+		vegas->minRTT = 0x7fffffff;
+	}
 }
 
 /* Extract info for Tcp socket info provided via netlink. */
diff -urN linux-2.6.15-rc5/net/ipv6/addrconf.c linux-2.6.15-rc6/net/ipv6/addrconf.c
--- linux-2.6.15-rc5/net/ipv6/addrconf.c	2005-12-18 22:27:57.671745795 -0800
+++ linux-2.6.15-rc6/net/ipv6/addrconf.c	2005-12-18 22:28:06.529140440 -0800
@@ -379,8 +379,8 @@
 		    dev->type == ARPHRD_NONE ||
 		    dev->type == ARPHRD_SIT) {
 			printk(KERN_INFO
-				"Disabled Privacy Extensions on device %p(%s)\n",
-				dev, dev->name);
+			       "%s: Disabled Privacy Extensions\n",
+			       dev->name);
 			ndev->cnf.use_tempaddr = -1;
 		} else {
 			in6_dev_hold(ndev);
diff -urN linux-2.6.15-rc5/net/ipv6/esp6.c linux-2.6.15-rc6/net/ipv6/esp6.c
--- linux-2.6.15-rc5/net/ipv6/esp6.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/net/ipv6/esp6.c	2005-12-18 22:28:06.530140484 -0800
@@ -248,7 +248,7 @@
 	if (esp->conf.padlen)
 		mtu = ALIGN(mtu, esp->conf.padlen);
 
-	return mtu + x->props.header_len + esp->auth.icv_full_len;
+	return mtu + x->props.header_len + esp->auth.icv_trunc_len;
 }
 
 static void esp6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
diff -urN linux-2.6.15-rc5/net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c linux-2.6.15-rc6/net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
--- linux-2.6.15-rc5/net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c	2005-12-18 22:27:57.682746285 -0800
+++ linux-2.6.15-rc6/net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c	2005-12-18 22:28:06.540140930 -0800
@@ -68,8 +68,8 @@
 		[ICMPV6_NI_REPLY - 128]		= ICMPV6_NI_REPLY +1
 	};
 
-	__u8 type = orig->dst.u.icmp.type - 128;
-	if (type >= sizeof(invmap) || !invmap[type])
+	int type = orig->dst.u.icmp.type - 128;
+	if (type < 0 || type >= sizeof(invmap) || !invmap[type])
 		return 0;
 
 	tuple->src.u.icmp.id   = orig->src.u.icmp.id;
@@ -129,12 +129,12 @@
 		[ICMPV6_ECHO_REQUEST - 128] = 1,
 		[ICMPV6_NI_QUERY - 128] = 1
 	};
+	int type = conntrack->tuplehash[0].tuple.dst.u.icmp.type - 128;
 
-	if (conntrack->tuplehash[0].tuple.dst.u.icmp.type - 128 >= sizeof(valid_new)
-	    || !valid_new[conntrack->tuplehash[0].tuple.dst.u.icmp.type - 128]) {
+	if (type < 0 || type >= sizeof(valid_new) || !valid_new[type]) {
 		/* Can't create a new ICMPv6 `conn' with this. */
-		DEBUGP("icmp: can't create new conn with type %u\n",
-		       conntrack->tuplehash[0].tuple.dst.u.icmp.type);
+		DEBUGP("icmpv6: can't create new conn with type %u\n",
+		       type + 128);
 		NF_CT_DUMP_TUPLE(&conntrack->tuplehash[0].tuple);
 		return 0;
 	}
diff -urN linux-2.6.15-rc5/net/ipv6/tcp_ipv6.c linux-2.6.15-rc6/net/ipv6/tcp_ipv6.c
--- linux-2.6.15-rc5/net/ipv6/tcp_ipv6.c	2005-12-18 22:27:57.687746508 -0800
+++ linux-2.6.15-rc6/net/ipv6/tcp_ipv6.c	2005-12-18 22:28:06.545141153 -0800
@@ -992,13 +992,12 @@
 	/* sk = NULL, but it is safe for now. RST socket required. */
 	if (!ip6_dst_lookup(NULL, &buff->dst, &fl)) {
 
-		if ((xfrm_lookup(&buff->dst, &fl, NULL, 0)) < 0)
+		if (xfrm_lookup(&buff->dst, &fl, NULL, 0) >= 0) {
+			ip6_xmit(NULL, buff, &fl, NULL, 0);
+			TCP_INC_STATS_BH(TCP_MIB_OUTSEGS);
+			TCP_INC_STATS_BH(TCP_MIB_OUTRSTS);
 			return;
-
-		ip6_xmit(NULL, buff, &fl, NULL, 0);
-		TCP_INC_STATS_BH(TCP_MIB_OUTSEGS);
-		TCP_INC_STATS_BH(TCP_MIB_OUTRSTS);
-		return;
+		}
 	}
 
 	kfree_skb(buff);
@@ -1057,11 +1056,11 @@
 	fl.fl_ip_sport = t1->source;
 
 	if (!ip6_dst_lookup(NULL, &buff->dst, &fl)) {
-		if ((xfrm_lookup(&buff->dst, &fl, NULL, 0)) < 0)
+		if (xfrm_lookup(&buff->dst, &fl, NULL, 0) >= 0) {
+			ip6_xmit(NULL, buff, &fl, NULL, 0);
+			TCP_INC_STATS_BH(TCP_MIB_OUTSEGS);
 			return;
-		ip6_xmit(NULL, buff, &fl, NULL, 0);
-		TCP_INC_STATS_BH(TCP_MIB_OUTSEGS);
-		return;
+		}
 	}
 
 	kfree_skb(buff);
diff -urN linux-2.6.15-rc5/net/netfilter/Kconfig linux-2.6.15-rc6/net/netfilter/Kconfig
--- linux-2.6.15-rc5/net/netfilter/Kconfig	2005-12-18 22:27:57.691746686 -0800
+++ linux-2.6.15-rc6/net/netfilter/Kconfig	2005-12-18 22:28:06.548141286 -0800
@@ -61,8 +61,8 @@
 	  instead of the individual packets.
 
 config NF_CONNTRACK_EVENTS
-	bool "Connection tracking events"
-	depends on NF_CONNTRACK
+	bool "Connection tracking events (EXPERIMENTAL)"
+	depends on EXPERIMENTAL && NF_CONNTRACK
 	help
 	  If this option is enabled, the connection tracking code will
 	  provide a notifier chain that can be used by other kernel code
diff -urN linux-2.6.15-rc5/net/netfilter/nf_conntrack_core.c linux-2.6.15-rc6/net/netfilter/nf_conntrack_core.c
--- linux-2.6.15-rc5/net/netfilter/nf_conntrack_core.c	2005-12-18 22:27:57.693746775 -0800
+++ linux-2.6.15-rc6/net/netfilter/nf_conntrack_core.c	2005-12-18 22:28:06.551141420 -0800
@@ -1383,6 +1383,9 @@
 		schedule();
 		goto i_see_dead_people;
 	}
+	/* wait until all references to nf_conntrack_untracked are dropped */
+	while (atomic_read(&nf_conntrack_untracked.ct_general.use) > 1)
+		schedule();
 
 	for (i = 0; i < NF_CT_F_NUM; i++) {
 		if (nf_ct_cache[i].use == 0)
diff -urN linux-2.6.15-rc5/net/netfilter/nfnetlink.c linux-2.6.15-rc6/net/netfilter/nfnetlink.c
--- linux-2.6.15-rc5/net/netfilter/nfnetlink.c	2005-12-18 22:27:57.700747087 -0800
+++ linux-2.6.15-rc6/net/netfilter/nfnetlink.c	2005-12-18 22:28:06.558141732 -0800
@@ -162,7 +162,7 @@
 		return -EINVAL;
 	}
 
-	min_len = NLMSG_ALIGN(sizeof(struct nfgenmsg));
+	min_len = NLMSG_SPACE(sizeof(struct nfgenmsg));
 	if (unlikely(nlh->nlmsg_len < min_len))
 		return -EINVAL;
 
@@ -236,8 +236,7 @@
 	}
 
 	/* All the messages must at least contain nfgenmsg */
-	if (nlh->nlmsg_len < 
-			NLMSG_LENGTH(NLMSG_ALIGN(sizeof(struct nfgenmsg)))) {
+	if (nlh->nlmsg_len < NLMSG_SPACE(sizeof(struct nfgenmsg))) {
 		DEBUGP("received message was too short\n");
 		return 0;
 	}
diff -urN linux-2.6.15-rc5/net/packet/af_packet.c linux-2.6.15-rc6/net/packet/af_packet.c
--- linux-2.6.15-rc5/net/packet/af_packet.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/net/packet/af_packet.c	2005-12-18 22:28:06.562141910 -0800
@@ -1587,23 +1587,47 @@
 	return virt_to_page(one_pg_vec + (PAGE_SIZE << order) - 1);
 }
 
-static void free_pg_vec(char **pg_vec, unsigned order, unsigned len)
+static void free_pg_vec(char **pg_vec, unsigned int order, unsigned int len)
 {
 	int i;
 
-	for (i=0; i<len; i++) {
-		if (pg_vec[i]) {
-			struct page *page, *pend;
-
-			pend = pg_vec_endpage(pg_vec[i], order);
-			for (page = virt_to_page(pg_vec[i]); page <= pend; page++)
-				ClearPageReserved(page);
-			free_pages((unsigned long)pg_vec[i], order);
-		}
+	for (i = 0; i < len; i++) {
+		if (likely(pg_vec[i]))
+			free_pages((unsigned long) pg_vec[i], order);
 	}
 	kfree(pg_vec);
 }
 
+static inline char *alloc_one_pg_vec_page(unsigned long order)
+{
+	return (char *) __get_free_pages(GFP_KERNEL | __GFP_COMP | __GFP_ZERO,
+					 order);
+}
+
+static char **alloc_pg_vec(struct tpacket_req *req, int order)
+{
+	unsigned int block_nr = req->tp_block_nr;
+	char **pg_vec;
+	int i;
+
+	pg_vec = kzalloc(block_nr * sizeof(char *), GFP_KERNEL);
+	if (unlikely(!pg_vec))
+		goto out;
+
+	for (i = 0; i < block_nr; i++) {
+		pg_vec[i] = alloc_one_pg_vec_page(order);
+		if (unlikely(!pg_vec[i]))
+			goto out_free_pgvec;
+	}
+
+out:
+	return pg_vec;
+
+out_free_pgvec:
+	free_pg_vec(pg_vec, order, block_nr);
+	pg_vec = NULL;
+	goto out;
+}
 
 static int packet_set_ring(struct sock *sk, struct tpacket_req *req, int closing)
 {
@@ -1617,64 +1641,46 @@
 
 		/* Sanity tests and some calculations */
 
-		if (po->pg_vec)
+		if (unlikely(po->pg_vec))
 			return -EBUSY;
 
-		if ((int)req->tp_block_size <= 0)
+		if (unlikely((int)req->tp_block_size <= 0))
 			return -EINVAL;
-		if (req->tp_block_size&(PAGE_SIZE-1))
+		if (unlikely(req->tp_block_size & (PAGE_SIZE - 1)))
 			return -EINVAL;
-		if (req->tp_frame_size < TPACKET_HDRLEN)
+		if (unlikely(req->tp_frame_size < TPACKET_HDRLEN))
 			return -EINVAL;
-		if (req->tp_frame_size&(TPACKET_ALIGNMENT-1))
+		if (unlikely(req->tp_frame_size & (TPACKET_ALIGNMENT - 1)))
 			return -EINVAL;
 
 		po->frames_per_block = req->tp_block_size/req->tp_frame_size;
-		if (po->frames_per_block <= 0)
+		if (unlikely(po->frames_per_block <= 0))
 			return -EINVAL;
-		if (po->frames_per_block*req->tp_block_nr != req->tp_frame_nr)
+		if (unlikely((po->frames_per_block * req->tp_block_nr) !=
+			     req->tp_frame_nr))
 			return -EINVAL;
-		/* OK! */
-
-		/* Allocate page vector */
-		while ((PAGE_SIZE<<order) < req->tp_block_size)
-			order++;
 
 		err = -ENOMEM;
-
-		pg_vec = kmalloc(req->tp_block_nr*sizeof(char *), GFP_KERNEL);
-		if (pg_vec == NULL)
+		order = get_order(req->tp_block_size);
+		pg_vec = alloc_pg_vec(req, order);
+		if (unlikely(!pg_vec))
 			goto out;
-		memset(pg_vec, 0, req->tp_block_nr*sizeof(char **));
-
-		for (i=0; i<req->tp_block_nr; i++) {
-			struct page *page, *pend;
-			pg_vec[i] = (char *)__get_free_pages(GFP_KERNEL, order);
-			if (!pg_vec[i])
-				goto out_free_pgvec;
-
-			pend = pg_vec_endpage(pg_vec[i], order);
-			for (page = virt_to_page(pg_vec[i]); page <= pend; page++)
-				SetPageReserved(page);
-		}
-		/* Page vector is allocated */
 
 		l = 0;
-		for (i=0; i<req->tp_block_nr; i++) {
+		for (i = 0; i < req->tp_block_nr; i++) {
 			char *ptr = pg_vec[i];
 			struct tpacket_hdr *header;
 			int k;
 
-			for (k=0; k<po->frames_per_block; k++) {
-				
-				header = (struct tpacket_hdr*)ptr;
+			for (k = 0; k < po->frames_per_block; k++) {
+				header = (struct tpacket_hdr *) ptr;
 				header->tp_status = TP_STATUS_KERNEL;
 				ptr += req->tp_frame_size;
 			}
 		}
 		/* Done */
 	} else {
-		if (req->tp_frame_nr)
+		if (unlikely(req->tp_frame_nr))
 			return -EINVAL;
 	}
 
@@ -1701,7 +1707,7 @@
 
 		spin_lock_bh(&sk->sk_receive_queue.lock);
 		pg_vec = XC(po->pg_vec, pg_vec);
-		po->frame_max = req->tp_frame_nr-1;
+		po->frame_max = (req->tp_frame_nr - 1);
 		po->head = 0;
 		po->frame_size = req->tp_frame_size;
 		spin_unlock_bh(&sk->sk_receive_queue.lock);
@@ -1728,7 +1734,6 @@
 
 	release_sock(sk);
 
-out_free_pgvec:
 	if (pg_vec)
 		free_pg_vec(pg_vec, order, req->tp_block_nr);
 out:
@@ -1755,17 +1760,19 @@
 	if (size != po->pg_vec_len*po->pg_vec_pages*PAGE_SIZE)
 		goto out;
 
-	atomic_inc(&po->mapped);
 	start = vma->vm_start;
-	err = -EAGAIN;
-	for (i=0; i<po->pg_vec_len; i++) {
-		if (remap_pfn_range(vma, start,
-				     __pa(po->pg_vec[i]) >> PAGE_SHIFT,
-				     po->pg_vec_pages*PAGE_SIZE,
-				     vma->vm_page_prot))
-			goto out;
-		start += po->pg_vec_pages*PAGE_SIZE;
+	for (i = 0; i < po->pg_vec_len; i++) {
+		struct page *page = virt_to_page(po->pg_vec[i]);
+		int pg_num;
+
+		for (pg_num = 0; pg_num < po->pg_vec_pages; pg_num++, page++) {
+			err = vm_insert_page(vma, start, page);
+			if (unlikely(err))
+				goto out;
+			start += PAGE_SIZE;
+		}
 	}
+	atomic_inc(&po->mapped);
 	vma->vm_ops = &packet_mmap_ops;
 	err = 0;
 
diff -urN linux-2.6.15-rc5/net/sched/act_api.c linux-2.6.15-rc6/net/sched/act_api.c
--- linux-2.6.15-rc5/net/sched/act_api.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-2.6.15-rc6/net/sched/act_api.c	2005-12-18 22:28:06.566142088 -0800
@@ -34,7 +34,7 @@
 #include <net/sch_generic.h>
 #include <net/act_api.h>
 
-#if 1 /* control */
+#if 0 /* control */
 #define DPRINTK(format, args...) printk(KERN_DEBUG format, ##args)
 #else
 #define DPRINTK(format, args...)
diff -urN linux-2.6.15-rc5/net/sctp/socket.c linux-2.6.15-rc6/net/sctp/socket.c
--- linux-2.6.15-rc5/net/sctp/socket.c	2005-12-18 22:27:57.724748156 -0800
+++ linux-2.6.15-rc6/net/sctp/socket.c	2005-12-18 22:28:06.583142846 -0800
@@ -3425,7 +3425,7 @@
 }
 
 static int sctp_copy_laddrs_to_user(struct sock *sk, __u16 port,
-				    void * __user *to, size_t space_left)
+				    void __user **to, size_t space_left)
 {
 	struct list_head *pos;
 	struct sctp_sockaddr_entry *addr;
diff -urN linux-2.6.15-rc5/sound/oss/au1550_ac97.c linux-2.6.15-rc6/sound/oss/au1550_ac97.c
--- linux-2.6.15-rc5/sound/oss/au1550_ac97.c	2005-12-18 22:27:57.825752657 -0800
+++ linux-2.6.15-rc6/sound/oss/au1550_ac97.c	2005-12-18 22:28:06.688147524 -0800
@@ -578,17 +578,15 @@
 	} while ((stat & PSC_AC97STAT_DR) == 0);
 }
 
+/* Hold spinlock for both start_dac() and start_adc() calls */
 static void
 start_dac(struct au1550_state *s)
 {
 	struct dmabuf  *db = &s->dma_dac;
-	unsigned long   flags;
 
 	if (!db->stopped)
 		return;
 
-	spin_lock_irqsave(&s->lock, flags);
-
 	set_xmit_slots(db->num_channels);
 	au_writel(PSC_AC97PCR_TC, PSC_AC97PCR);
 	au_sync();
@@ -598,8 +596,6 @@
 	au1xxx_dbdma_start(db->dmanr);
 
 	db->stopped = 0;
-
-	spin_unlock_irqrestore(&s->lock, flags);
 }
 
 static void
@@ -718,7 +714,6 @@
 }
 
 
-/* hold spinlock for the following */
 static void
 dac_dma_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
@@ -726,6 +721,8 @@
 	struct dmabuf  *db = &s->dma_dac;
 	u32	ac97c_stat;
 
+	spin_lock(&s->lock);
+
 	ac97c_stat = au_readl(PSC_AC97STAT);
 	if (ac97c_stat & (AC97C_XU | AC97C_XO | AC97C_TE))
 		pr_debug("AC97C status = 0x%08x\n", ac97c_stat);
@@ -747,6 +744,8 @@
 	/* wake up anybody listening */
 	if (waitqueue_active(&db->wait))
 		wake_up(&db->wait);
+
+	spin_unlock(&s->lock);
 }
 
 
@@ -758,6 +757,8 @@
 	u32	obytes;
 	char	*obuf;
 
+	spin_lock(&s->lock);
+
 	/* Pull the buffer from the dma queue.
 	*/
 	au1xxx_dbdma_get_dest(dp->dmanr, (void *)(&obuf), &obytes);
@@ -765,6 +766,7 @@
 	if ((dp->count + obytes) > dp->dmasize) {
 		/* Overrun. Stop ADC and log the error
 		*/
+		spin_unlock(&s->lock);
 		stop_adc(s);
 		dp->error++;
 		err("adc overrun");
@@ -787,6 +789,7 @@
 	if (waitqueue_active(&dp->wait))
 		wake_up(&dp->wait);
 
+	spin_unlock(&s->lock);
 }
 
 static loff_t
@@ -1048,9 +1051,9 @@
 		/* wait for samples in ADC dma buffer
 		*/
 		do {
+			spin_lock_irqsave(&s->lock, flags);
 			if (db->stopped)
 				start_adc(s);
-			spin_lock_irqsave(&s->lock, flags);
 			avail = db->count;
 			if (avail <= 0)
 				__set_current_state(TASK_INTERRUPTIBLE);
@@ -1570,15 +1573,19 @@
 		if (get_user(val, (int *) arg))
 			return -EFAULT;
 		if (file->f_mode & FMODE_READ) {
-			if (val & PCM_ENABLE_INPUT)
+			if (val & PCM_ENABLE_INPUT) {
+				spin_lock_irqsave(&s->lock, flags);
 				start_adc(s);
-			else
+				spin_unlock_irqrestore(&s->lock, flags);
+			} else
 				stop_adc(s);
 		}
 		if (file->f_mode & FMODE_WRITE) {
-			if (val & PCM_ENABLE_OUTPUT)
+			if (val & PCM_ENABLE_OUTPUT) {
+				spin_lock_irqsave(&s->lock, flags);
 				start_dac(s);
-			else
+				spin_unlock_irqrestore(&s->lock, flags);
+			} else
 				stop_dac(s);
 		}
 		return 0;

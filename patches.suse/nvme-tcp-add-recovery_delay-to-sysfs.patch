From: Daniel Wagner <dwagner@suse.de>
Date: Fri, 8 Sep 2023 09:59:35 +0200
Subject: nvme-tcp: add recovery_delay to sysfs
Patch-mainline: Not yet, TP is not yet released
References: bsc#1201284

Allow userland to set the recovery delay value.

Signed-off-by: Daniel Wagner <dwagner@suse.de>
---
 drivers/nvme/host/fabrics.c |   13 +++++++++++++
 drivers/nvme/host/fabrics.h |    3 +++
 drivers/nvme/host/tcp.c     |    6 +++++-
 3 files changed, 21 insertions(+), 1 deletion(-)

--- a/drivers/nvme/host/fabrics.c
+++ b/drivers/nvme/host/fabrics.c
@@ -672,6 +672,7 @@ static const match_table_t opt_tokens =
 #ifdef CONFIG_NVME_TCP_TLS
 	{ NVMF_OPT_TLS,			"tls"			},
 #endif
+	{ NVMF_OPT_RECOVERY_DELAY,      "recovery_delay=%d"     },
 	{ NVMF_OPT_ERR,			NULL			}
 };
 
@@ -1017,6 +1018,18 @@ static int nvmf_parse_options(struct nvm
 				goto out;
 			}
 			opts->tls = true;
+			break;			
+		case NVMF_OPT_RECOVERY_DELAY:
+			if (match_int(args, &token)) {
+				ret = -EINVAL;
+				goto out;
+			}
+			if (token <= 0) {
+				pr_err("Invalid recovery_delay %d\n", token);
+				ret = -EINVAL;
+				goto out;
+			}
+			opts->recovery_delay = token;
 			break;
 		default:
 			pr_warn("unknown parameter or missing value '%s' in ctrl creation request\n",
--- a/drivers/nvme/host/fabrics.h
+++ b/drivers/nvme/host/fabrics.h
@@ -73,6 +73,7 @@ enum {
 	NVMF_OPT_TLS		= 1 << 25,
 	NVMF_OPT_KEYRING	= 1 << 26,
 	NVMF_OPT_TLS_KEY	= 1 << 27,
+	NVMF_OPT_RECOVERY_DELAY = 1 << 28,
 };
 
 /**
@@ -99,6 +100,7 @@ enum {
  * @queue_size: Number of IO queue elements.
  * @nr_io_queues: Number of controller IO queues that will be established.
  * @reconnect_delay: Time between two consecutive reconnect attempts.
+ * @recovery_delay: Time before error recovery starts after error detection.
  * @discovery_nqn: indicates if the subsysnqn is the well-known discovery NQN.
  * @kato:	Keep-alive timeout.
  * @host:	Virtual NVMe host, contains the NQN and Host ID.
@@ -128,6 +130,7 @@ struct nvmf_ctrl_options {
 	size_t			queue_size;
 	unsigned int		nr_io_queues;
 	unsigned int		reconnect_delay;
+	unsigned int		recovery_delay;
 	bool			discovery_nqn;
 	bool			duplicate_connect;
 	unsigned int		kato;
--- a/drivers/nvme/host/tcp.c
+++ b/drivers/nvme/host/tcp.c
@@ -558,11 +558,15 @@ static void nvme_tcp_init_recv_ctx(struc
  */
 static void nvme_tcp_error_recovery(struct nvme_ctrl *ctrl)
 {
-	unsigned long delay = nvme_keep_alive_work_period(ctrl);
+	unsigned long delay;
 
 	if (!nvme_change_ctrl_state(ctrl, NVME_CTRL_RESETTING))
 		return;
 
+	delay = ctrl->opts->recovery_delay * HZ;
+	if (!delay)
+		delay = nvme_keep_alive_work_period(ctrl);
+
 	dev_warn(ctrl->device, "starting error recovery in %lu seconds\n",
 		 delay / HZ);
 	queue_delayed_work(nvme_reset_wq, &to_tcp_ctrl(ctrl)->err_work, delay);

From a748e1dbb2df11fb55ee32a56270341195260b15 Mon Sep 17 00:00:00 2001
From: Dylan Robinson <dylan_robinson@motu.com>
Date: Mon, 24 Nov 2025 16:05:18 -0500
Subject: [PATCH] ALSA: usb-audio: Fix max bytes-per-interval calculation
Git-commit: a748e1dbb2df11fb55ee32a56270341195260b15
Patch-mainline: v6.19-rc1
References: jsc#PED-14430 jsc#PED-14297 jsc#PED-14024

The maxpacksize field in struct audioformat represents the maximum number
of bytes per isochronous interval. The current implementation only
special-cases high-speed endpoints and does not account for the different
computations required for SuperSpeed, SuperSpeedPlus, or eUSB2. As a
result, USB audio class devices operating at these speeds may fail to
stream correctly. The issue was observed on a MOTU 16A (2025) interface,
which requires more than 1024 bytes per interval at SuperSpeed.

This patch replaces the existing logic with a helper that computes the
correct maximum bytes-per-interval for all USB speeds, borrowing the logic
used in drivers/usb/core/urb.c.

Signed-off-by: Dylan Robinson <dylan_robinson@motu.com>
Link: https://patch.msgid.link/20251124210518.90054-1-dylan_robinson@motu.com
Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
 sound/usb/stream.c | 36 ++++++++++++++++++++++++++++++++----
 1 file changed, 32 insertions(+), 4 deletions(-)

diff --git a/sound/usb/stream.c b/sound/usb/stream.c
index 5c235a5ba7e1..074a61215de6 100644
--- a/sound/usb/stream.c
+++ b/sound/usb/stream.c
@@ -684,6 +684,37 @@ snd_usb_find_output_terminal_descriptor(struct usb_host_interface *ctrl_iface,
 	return NULL;
 }
 
+static unsigned int
+snd_usb_max_bytes_per_interval(struct snd_usb_audio *chip,
+					struct usb_host_interface *alts)
+{
+	struct usb_host_endpoint *ep = &alts->endpoint[0];
+	unsigned int max_bytes = usb_endpoint_maxp(&ep->desc);
+
+	/* SuperSpeed isoc endpoints have up to 16 bursts of up to 3 packets each */
+	if (snd_usb_get_speed(chip->dev) >= USB_SPEED_SUPER) {
+		int burst = 1 + ep->ss_ep_comp.bMaxBurst;
+		int mult = USB_SS_MULT(ep->ss_ep_comp.bmAttributes);
+		max_bytes *= burst;
+		max_bytes *= mult;
+	}
+
+	if (snd_usb_get_speed(chip->dev) == USB_SPEED_SUPER_PLUS &&
+		USB_SS_SSP_ISOC_COMP(ep->ss_ep_comp.bmAttributes)) {
+		max_bytes = le32_to_cpu(ep->ssp_isoc_ep_comp.dwBytesPerInterval);
+	}
+
+	/* High speed, 1-3 packets/uframe, max 6 for eUSB2 double bw */
+	if (snd_usb_get_speed(chip->dev) == USB_SPEED_HIGH) {
+		if (usb_endpoint_is_hs_isoc_double(chip->dev, ep))
+			max_bytes = le32_to_cpu(ep->eusb2_isoc_ep_comp.dwBytesPerInterval);
+		else
+			max_bytes *= usb_endpoint_maxp_mult(&ep->desc);
+	}
+
+	return max_bytes;
+}
+
 static struct audioformat *
 audio_format_alloc_init(struct snd_usb_audio *chip,
 		       struct usb_host_interface *alts,
@@ -703,11 +734,8 @@ audio_format_alloc_init(struct snd_usb_audio *chip,
 	fp->ep_attr = get_endpoint(alts, 0)->bmAttributes;
 	fp->datainterval = snd_usb_parse_datainterval(chip, alts);
 	fp->protocol = protocol;
-	fp->maxpacksize = le16_to_cpu(get_endpoint(alts, 0)->wMaxPacketSize);
+	fp->maxpacksize = snd_usb_max_bytes_per_interval(chip, alts);
 	fp->channels = num_channels;
-	if (snd_usb_get_speed(chip->dev) == USB_SPEED_HIGH)
-		fp->maxpacksize = (((fp->maxpacksize >> 11) & 3) + 1)
-				* (fp->maxpacksize & 0x7ff);
 	fp->clock = clock;
 	INIT_LIST_HEAD(&fp->list);
 
-- 
2.52.0


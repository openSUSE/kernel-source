From a85eff14da2c700ffcd68b3bf1a07f8a5deda624 Mon Sep 17 00:00:00 2001
From: Hawking Zhang <Hawking.Zhang@amd.com>
Date: Tue, 3 Sep 2019 05:24:35 +0800
Subject: drm/amdgpu/gmc: switch to amdgpu_gmc_ras_late_init helper function
Git-commit: a85eff14da2c700ffcd68b3bf1a07f8a5deda624
Patch-mainline: v5.5-rc1
References: bsc#1152489

amdgpu_gmc_ras_late_init is used to init gmc specfic
ras debugfs/sysfs node and gmc specific interrupt handler.
It can be shared among gmc generations.

Signed-off-by: Hawking Zhang <Hawking.Zhang@amd.com>
Reviewed-by: Tao Zhou <tao.zhou1@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Acked-by: Thomas Zimmermann <tzimmermann@suse.de>
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_gmc.c | 49 +++++++++++++++++++++++++
 drivers/gpu/drm/amd/amdgpu/amdgpu_gmc.h |  2 +
 drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c   | 36 +-----------------
 3 files changed, 53 insertions(+), 34 deletions(-)

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_gmc.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_gmc.c
index 5790db61fa2c..e7ab55d6934d 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_gmc.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_gmc.c
@@ -27,6 +27,7 @@
 #include <linux/io-64-nonatomic-lo-hi.h>
 
 #include "amdgpu.h"
+#include "amdgpu_ras.h"
 
 /**
  * amdgpu_gmc_get_pde_for_bo - get the PDE for a BO
@@ -305,3 +306,51 @@ bool amdgpu_gmc_filter_faults(struct amdgpu_device *adev, uint64_t addr,
 	gmc->fault_hash[hash].idx = gmc->last_fault++;
 	return false;
 }
+
+int amdgpu_gmc_ras_late_init(struct amdgpu_device *adev,
+			     void *ras_ih_info)
+{
+	int r;
+	struct ras_ih_if *ih_info = (struct ras_ih_if *)ras_ih_info;
+	struct ras_fs_if fs_info = {
+		.sysfs_name = "umc_err_count",
+		.debugfs_name = "umc_err_inject",
+	};
+
+	if (!ih_info)
+		return -EINVAL;
+
+	if (!adev->gmc.umc_ras_if) {
+		adev->gmc.umc_ras_if = kmalloc(sizeof(struct ras_common_if), GFP_KERNEL);
+		if (!adev->gmc.umc_ras_if)
+			return -ENOMEM;
+		adev->gmc.umc_ras_if->block = AMDGPU_RAS_BLOCK__UMC;
+		adev->gmc.umc_ras_if->type = AMDGPU_RAS_ERROR__MULTI_UNCORRECTABLE;
+		adev->gmc.umc_ras_if->sub_block_index = 0;
+		strcpy(adev->gmc.umc_ras_if->name, "umc");
+	}
+	ih_info->head = fs_info.head = *adev->gmc.umc_ras_if;
+
+	r = amdgpu_ras_late_init(adev, adev->gmc.umc_ras_if,
+				 &fs_info, ih_info);
+	if (r)
+		goto free;
+
+	if (amdgpu_ras_is_supported(adev, adev->gmc.umc_ras_if->block)) {
+		r = amdgpu_irq_get(adev, &adev->gmc.ecc_irq, 0);
+		if (r)
+			goto late_fini;
+	} else {
+		r = 0;
+		goto free;
+	}
+
+	return 0;
+
+late_fini:
+	amdgpu_ras_late_fini(adev, adev->gmc.umc_ras_if, ih_info);
+free:
+	kfree(adev->gmc.umc_ras_if);
+	adev->gmc.umc_ras_if = NULL;
+	return r;
+}
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_gmc.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_gmc.h
index b6e1d98ef01e..331ce50a3a9e 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_gmc.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_gmc.h
@@ -230,5 +230,7 @@ void amdgpu_gmc_agp_location(struct amdgpu_device *adev,
 			     struct amdgpu_gmc *mc);
 bool amdgpu_gmc_filter_faults(struct amdgpu_device *adev, uint64_t addr,
 			      uint16_t pasid, uint64_t timestamp);
+int amdgpu_gmc_ras_late_init(struct amdgpu_device *adev,
+			     void *ih_info);
 
 #endif
diff --git a/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c b/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
index ba149554b508..0899fc847ed9 100644
--- a/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
@@ -771,39 +771,13 @@ static int gmc_v9_0_ecc_late_init(void *handle)
 {
 	int r;
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
-	struct ras_fs_if umc_fs_info = {
-		.sysfs_name = "umc_err_count",
-		.debugfs_name = "umc_err_inject",
-	};
 	struct ras_ih_if umc_ih_info = {
 		.cb = gmc_v9_0_process_ras_data_cb,
 	};
 
-	if (!adev->gmc.umc_ras_if) {
-		adev->gmc.umc_ras_if = kmalloc(sizeof(struct ras_common_if), GFP_KERNEL);
-		if (!adev->gmc.umc_ras_if)
-			return -ENOMEM;
-		adev->gmc.umc_ras_if->block = AMDGPU_RAS_BLOCK__UMC;
-		adev->gmc.umc_ras_if->type = AMDGPU_RAS_ERROR__MULTI_UNCORRECTABLE;
-		adev->gmc.umc_ras_if->sub_block_index = 0;
-		strcpy(adev->gmc.umc_ras_if->name, "umc");
-	}
-	umc_ih_info.head = umc_fs_info.head = *adev->gmc.umc_ras_if;
-
-	r = amdgpu_ras_late_init(adev, adev->gmc.umc_ras_if,
-				 &umc_fs_info, &umc_ih_info);
+	r = amdgpu_gmc_ras_late_init(adev, &umc_ih_info);
 	if (r)
-		goto free;
-
-	if (amdgpu_ras_is_supported(adev, adev->gmc.umc_ras_if->block)) {
-		r = amdgpu_irq_get(adev, &adev->gmc.ecc_irq, 0);
-		if (r)
-			goto umc_late_fini;
-	} else {
-		/* free umc ras_if if umc ras is not supported */
-		r = 0;
-		goto free;
-	}
+		return r;
 
 	if (adev->mmhub_funcs && adev->mmhub_funcs->ras_late_init) {
 		r = adev->mmhub_funcs->ras_late_init(adev);
@@ -811,12 +785,6 @@ static int gmc_v9_0_ecc_late_init(void *handle)
 			return r;
 	}
 	return 0;
-umc_late_fini:
-	amdgpu_ras_late_fini(adev, adev->gmc.umc_ras_if, &umc_ih_info);
-free:
-	kfree(adev->gmc.umc_ras_if);
-	adev->gmc.umc_ras_if = NULL;
-	return r;
 }
 
 static int gmc_v9_0_late_init(void *handle)
-- 
2.28.0


From 290129c256179d5bbf822016e1729b8e9ed4875b Mon Sep 17 00:00:00 2001
From: Qingqing Zhuo <qingqing.zhuo@amd.com>
Date: Thu, 27 Jun 2019 19:17:23 -0400
Subject: drm/amd/display: Add CM_BYPASS via debug option
Git-commit: 290129c256179d5bbf822016e1729b8e9ed4875b
Patch-mainline: v5.4-rc1
References: bsc#1152489

[Why]
bypass CM block and MPC ogam for debug or triage use.

[How]
create a new flag cm_bypass_mode, which will set both CM_CONTROL
and MPCC_OGAM_MODE to bypass when set to 1.

Signed-off-by: Qingqing Zhuo <qingqing.zhuo@amd.com>
Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
Acked-by: Leo Li <sunpeng.li@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Acked-by: Thomas Zimmermann <tzimmermann@suse.de>
---
 drivers/gpu/drm/amd/display/dc/dc.h                 |  3 +++
 drivers/gpu/drm/amd/display/dc/dcn20/dcn20_dpp_cm.c |  7 ++++++-
 drivers/gpu/drm/amd/display/dc/dcn20/dcn20_mpc.c    | 11 +++++++++++
 drivers/gpu/drm/amd/display/dc/inc/hw/dpp.h         |  1 +
 drivers/gpu/drm/amd/display/dc/inc/hw/mpc.h         |  1 +
 5 files changed, 22 insertions(+), 1 deletion(-)

diff --git a/drivers/gpu/drm/amd/display/dc/dc.h b/drivers/gpu/drm/amd/display/dc/dc.h
index 421932ac3b26..27900297bdcf 100644
--- a/drivers/gpu/drm/amd/display/dc/dc.h
+++ b/drivers/gpu/drm/amd/display/dc/dc.h
@@ -379,6 +379,9 @@ struct dc_debug_options {
 	 */
 	unsigned int force_min_dcfclk_mhz;
 	bool disable_timing_sync;
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+	bool cm_in_bypass;
+#endif
 };
 
 struct dc_debug_data {
diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_dpp_cm.c
index e28b8e7bedf5..2d112c316424 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_dpp_cm.c
@@ -52,7 +52,12 @@ static void dpp2_enable_cm_block(
 {
 	struct dcn20_dpp *dpp = TO_DCN20_DPP(dpp_base);
 
-	REG_UPDATE(CM_CONTROL, CM_BYPASS, 0);
+	unsigned int cm_bypass_mode = 0;
+	//Temp, put CM in bypass mode
+	if (dpp_base->ctx->dc->debug.cm_in_bypass)
+		cm_bypass_mode = 1;
+
+	REG_UPDATE(CM_CONTROL, CM_BYPASS, cm_bypass_mode);
 }
 
 
diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_mpc.c
index 240749e4cf83..f4d3008e5efa 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_mpc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_mpc.c
@@ -368,6 +368,11 @@ void apply_DEDCN20_305_wa(
 {
 	struct dcn20_mpc *mpc20 = TO_DCN20_MPC(mpc);
 
+	if (mpc->ctx->dc->debug.cm_in_bypass) {
+		REG_SET(MPCC_OGAM_MODE[mpcc_id], 0, MPCC_OGAM_MODE, 0);
+		return;
+	}
+
 	if (mpc->ctx->dc->work_arounds.dedcn20_305_wa == false) {
 		/*hw fixed in new review*/
 		return;
@@ -390,10 +395,16 @@ void mpc2_set_output_gamma(
 	enum dc_lut_mode next_mode;
 	struct dcn20_mpc *mpc20 = TO_DCN20_MPC(mpc);
 
+	if (mpc->ctx->dc->debug.cm_in_bypass) {
+		REG_SET(MPCC_OGAM_MODE[mpcc_id], 0, MPCC_OGAM_MODE, 0);
+		return;
+	}
+
 	if (params == NULL) {
 		REG_SET(MPCC_OGAM_MODE[mpcc_id], 0, MPCC_OGAM_MODE, 0);
 		return;
 	}
+
 	current_mode = mpc20_get_ogam_current(mpc, mpcc_id);
 	if (current_mode == LUT_BYPASS || current_mode == LUT_RAM_A)
 		next_mode = LUT_RAM_B;
diff --git a/drivers/gpu/drm/amd/display/dc/inc/hw/dpp.h b/drivers/gpu/drm/amd/display/dc/inc/hw/dpp.h
index 60c671fcf186..9b69a06ab46f 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/hw/dpp.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw/dpp.h
@@ -42,6 +42,7 @@ struct dpp {
 
 #if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 	struct pwl_params shaper_params;
+	bool cm_bypass_mode;
 #endif
 };
 
diff --git a/drivers/gpu/drm/amd/display/dc/inc/hw/mpc.h b/drivers/gpu/drm/amd/display/dc/inc/hw/mpc.h
index 45b94e319cd4..9f00289bda78 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/hw/mpc.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw/mpc.h
@@ -128,6 +128,7 @@ struct mpc {
 	struct mpcc mpcc_array[MAX_MPCC];
 #if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 	struct pwl_params blender_params;
+	bool cm_bypass_mode;
 #endif
 };
 
-- 
2.28.0


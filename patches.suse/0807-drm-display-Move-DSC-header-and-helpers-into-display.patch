From aab519317c54fd14b704c52255b0631416064898 Mon Sep 17 00:00:00 2001
From: Thomas Zimmermann <tzimmermann@suse.de>
Date: Thu, 21 Apr 2022 09:31:05 +0200
Subject: drm/display: Move DSC header and helpers into display-helper module
Git-commit: 2a64b147350f5b28f6b41873fcb453aaebea01c3
Patch-mainline: v5.19-rc1
References: jsc#PED-1166 jsc#PED-1168 jsc#PED-1170 jsc#PED-1218 jsc#PED-1220 jsc#PED-1222 jsc#PED-1223 jsc#PED-1225

DSC is the Display Stream Compression standard for DisplayPort. Move
the DSC code into display/ and split the header into files for protocol
core and DRM helpers. Adapt all users of the code. No functional
changes.

To avoid the proliferation of Kconfig options, DSC is part of DRM's
support for DisplayPort. If necessary, a new option could make DSC an
independent feature.

Signed-off-by: Thomas Zimmermann <tzimmermann@suse.de>
Reviewed-by: Javier Martinez Canillas <javierm@redhat.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20220421073108.19226-6-tzimmermann@suse.de
Acked-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 Documentation/gpu/drm-kms-helpers.rst         |   6 +-
 drivers/gpu/drm/Makefile                      |   2 +-
 .../gpu/drm/amd/display/dc/dcn20/dcn20_dsc.c  |   2 +
 .../gpu/drm/amd/display/dc/dcn20/dcn20_dsc.h  |   2 +-
 .../drm/amd/display/dc/dml/dsc/rc_calc_fpu.h  |   2 +-
 drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c   |   4 +-
 .../gpu/drm/amd/display/dc/dsc/dscc_types.h   |   2 +-
 .../gpu/drm/amd/display/dc/dsc/rc_calc_dpi.c  |   2 +-
 drivers/gpu/drm/display/Makefile              |   3 +-
 drivers/gpu/drm/display/drm_dsc_helper.c      | 409 ++++++++++++
 drivers/gpu/drm/drm_dsc.c                     | 409 ------------
 drivers/gpu/drm/drm_mipi_dsi.c                |   6 +-
 drivers/gpu/drm/i915/display/icl_dsi.c        |   1 +
 drivers/gpu/drm/i915/display/intel_bios.c     |   1 +
 .../drm/i915/display/intel_display_types.h    |   2 +-
 drivers/gpu/drm/i915/display/intel_dp.c       |   1 +
 .../gpu/drm/i915/display/intel_qp_tables.c    |   2 +-
 drivers/gpu/drm/i915/display/intel_vdsc.c     |   2 +
 include/drm/display/drm_dsc.h                 | 605 +++++++++++++++++
 include/drm/display/drm_dsc_helper.h          |  20 +
 include/drm/drm_dsc.h                         | 611 ------------------
 21 files changed, 1058 insertions(+), 1036 deletions(-)
 create mode 100644 drivers/gpu/drm/display/drm_dsc_helper.c
 delete mode 100644 drivers/gpu/drm/drm_dsc.c
 create mode 100644 include/drm/display/drm_dsc.h
 create mode 100644 include/drm/display/drm_dsc_helper.h
 delete mode 100644 include/drm/drm_dsc.h

diff --git a/Documentation/gpu/drm-kms-helpers.rst b/Documentation/gpu/drm-kms-helpers.rst
index 09463ee99730..7af55fb4072c 100644
--- a/Documentation/gpu/drm-kms-helpers.rst
+++ b/Documentation/gpu/drm-kms-helpers.rst
@@ -326,13 +326,13 @@ MIPI DSI Helper Functions Reference
 Display Stream Compression Helper Functions Reference
 =====================================================
 
-.. kernel-doc:: drivers/gpu/drm/drm_dsc.c
+.. kernel-doc:: drivers/gpu/drm/display/drm_dsc_helper.c
    :doc: dsc helpers
 
-.. kernel-doc:: include/drm/drm_dsc.h
+.. kernel-doc:: include/drm/display/drm_dsc.h
    :internal:
 
-.. kernel-doc:: drivers/gpu/drm/drm_dsc.c
+.. kernel-doc:: drivers/gpu/drm/display/drm_dsc_helper.c
    :export:
 
 Output Probing Helper Functions Reference
diff --git a/drivers/gpu/drm/Makefile b/drivers/gpu/drm/Makefile
index 07f7a70a78ea..b8353af70152 100644
--- a/drivers/gpu/drm/Makefile
+++ b/drivers/gpu/drm/Makefile
@@ -58,7 +58,7 @@ obj-$(CONFIG_DRM_TTM_HELPER) += drm_ttm_helper.o
 #
 
 drm_kms_helper-y := drm_bridge_connector.o drm_crtc_helper.o \
-		drm_dsc.o drm_encoder_slave.o drm_flip_work.o drm_hdcp.o \
+		drm_encoder_slave.o drm_flip_work.o drm_hdcp.o \
 		drm_probe_helper.o \
 		drm_plane_helper.o drm_atomic_helper.o \
 		drm_kms_helper_common.o \
diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_dsc.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_dsc.c
index ef5c4c0f4d6c..6f24ceab97ad 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_dsc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_dsc.c
@@ -23,6 +23,8 @@
  *
  */
 
+#include <drm/display/drm_dsc_helper.h>
+
 #include "reg_helper.h"
 #include "dcn20_dsc.h"
 #include "dsc/dscc_types.h"
diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_dsc.h b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_dsc.h
index 1118e33aaa2c..c21ecedc4692 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_dsc.h
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_dsc.h
@@ -26,7 +26,7 @@
 
 #include "dsc.h"
 #include "dsc/dscc_types.h"
-#include <drm/drm_dsc.h>
+#include <drm/display/drm_dsc.h>
 
 #define TO_DCN20_DSC(dsc)\
 	container_of(dsc, struct dcn20_dsc, base)
diff --git a/drivers/gpu/drm/amd/display/dc/dml/dsc/rc_calc_fpu.h b/drivers/gpu/drm/amd/display/dc/dml/dsc/rc_calc_fpu.h
index cad244c023cd..d7cd8cc24758 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/dsc/rc_calc_fpu.h
+++ b/drivers/gpu/drm/amd/display/dc/dml/dsc/rc_calc_fpu.h
@@ -27,7 +27,7 @@
 #define __RC_CALC_FPU_H__
 
 #include "os_types.h"
-#include <drm/drm_dsc.h>
+#include <drm/display/drm_dsc.h>
 
 #define QP_SET_SIZE 15
 
diff --git a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
index dc82e04e36dc..fa39a06eed1d 100644
--- a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
+++ b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
@@ -22,10 +22,10 @@
  * Author: AMD
  */
 
-#include <drm/drm_dsc.h>
+#include <drm/display/drm_dp_helper.h>
+#include <drm/display/drm_dsc_helper.h>
 #include "dc_hw_types.h"
 #include "dsc.h"
-#include <drm/display/drm_dp_helper.h>
 #include "dc.h"
 #include "rc_calc.h"
 #include "fixed31_32.h"
diff --git a/drivers/gpu/drm/amd/display/dc/dsc/dscc_types.h b/drivers/gpu/drm/amd/display/dc/dsc/dscc_types.h
index 9f70e87b3ecb..ad80bde9bc0f 100644
--- a/drivers/gpu/drm/amd/display/dc/dsc/dscc_types.h
+++ b/drivers/gpu/drm/amd/display/dc/dsc/dscc_types.h
@@ -26,7 +26,7 @@
 #ifndef __DSCC_TYPES_H__
 #define __DSCC_TYPES_H__
 
-#include <drm/drm_dsc.h>
+#include <drm/display/drm_dsc.h>
 
 #ifndef NUM_BUF_RANGES
 #define NUM_BUF_RANGES 15
diff --git a/drivers/gpu/drm/amd/display/dc/dsc/rc_calc_dpi.c b/drivers/gpu/drm/amd/display/dc/dsc/rc_calc_dpi.c
index 7e306aa3e2b9..f0aea988fef0 100644
--- a/drivers/gpu/drm/amd/display/dc/dsc/rc_calc_dpi.c
+++ b/drivers/gpu/drm/amd/display/dc/dsc/rc_calc_dpi.c
@@ -22,7 +22,7 @@
  * Authors: AMD
  *
  */
-#include <drm/drm_dsc.h>
+#include <drm/display/drm_dsc_helper.h>
 #include "dscc_types.h"
 #include "rc_calc.h"
 
diff --git a/drivers/gpu/drm/display/Makefile b/drivers/gpu/drm/display/Makefile
index 99ba6750a315..4f4e35034960 100644
--- a/drivers/gpu/drm/display/Makefile
+++ b/drivers/gpu/drm/display/Makefile
@@ -5,7 +5,8 @@ obj-$(CONFIG_DRM_DP_AUX_BUS) += drm_dp_aux_bus.o
 drm_display_helper-y := drm_display_helper_mod.o
 drm_display_helper-$(CONFIG_DRM_DISPLAY_DP_HELPER) += drm_dp_dual_mode_helper.o \
 						      drm_dp_helper.o \
-						      drm_dp_mst_topology.o
+						      drm_dp_mst_topology.o \
+						      drm_dsc_helper.o
 drm_display_helper-$(CONFIG_DRM_DP_AUX_CHARDEV) += drm_dp_aux_dev.o
 drm_display_helper-$(CONFIG_DRM_DP_CEC) += drm_dp_cec.o
 
diff --git a/drivers/gpu/drm/display/drm_dsc_helper.c b/drivers/gpu/drm/display/drm_dsc_helper.c
new file mode 100644
index 000000000000..c869c6e51e2b
--- /dev/null
+++ b/drivers/gpu/drm/display/drm_dsc_helper.c
@@ -0,0 +1,409 @@
+// SPDX-License-Identifier: MIT
+/*
+ * Copyright © 2018 Intel Corp
+ *
+ * Author:
+ * Manasi Navare <manasi.d.navare@intel.com>
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/byteorder/generic.h>
+
+#include <drm/display/drm_dp_helper.h>
+#include <drm/display/drm_dsc_helper.h>
+#include <drm/drm_print.h>
+
+/**
+ * DOC: dsc helpers
+ *
+ * VESA specification for DP 1.4 adds a new feature called Display Stream
+ * Compression (DSC) used to compress the pixel bits before sending it on
+ * DP/eDP/MIPI DSI interface. DSC is required to be enabled so that the existing
+ * display interfaces can support high resolutions at higher frames rates uisng
+ * the maximum available link capacity of these interfaces.
+ *
+ * These functions contain some common logic and helpers to deal with VESA
+ * Display Stream Compression standard required for DSC on Display Port/eDP or
+ * MIPI display interfaces.
+ */
+
+/**
+ * drm_dsc_dp_pps_header_init() - Initializes the PPS Header
+ * for DisplayPort as per the DP 1.4 spec.
+ * @pps_header: Secondary data packet header for DSC Picture
+ *              Parameter Set as defined in &struct dp_sdp_header
+ *
+ * DP 1.4 spec defines the secondary data packet for sending the
+ * picture parameter infoframes from the source to the sink.
+ * This function populates the SDP header defined in
+ * &struct dp_sdp_header.
+ */
+void drm_dsc_dp_pps_header_init(struct dp_sdp_header *pps_header)
+{
+	memset(pps_header, 0, sizeof(*pps_header));
+
+	pps_header->HB1 = DP_SDP_PPS;
+	pps_header->HB2 = DP_SDP_PPS_HEADER_PAYLOAD_BYTES_MINUS_1;
+}
+EXPORT_SYMBOL(drm_dsc_dp_pps_header_init);
+
+/**
+ * drm_dsc_dp_rc_buffer_size - get rc buffer size in bytes
+ * @rc_buffer_block_size: block size code, according to DPCD offset 62h
+ * @rc_buffer_size: number of blocks - 1, according to DPCD offset 63h
+ *
+ * return:
+ * buffer size in bytes, or 0 on invalid input
+ */
+int drm_dsc_dp_rc_buffer_size(u8 rc_buffer_block_size, u8 rc_buffer_size)
+{
+	int size = 1024 * (rc_buffer_size + 1);
+
+	switch (rc_buffer_block_size) {
+	case DP_DSC_RC_BUF_BLK_SIZE_1:
+		return 1 * size;
+	case DP_DSC_RC_BUF_BLK_SIZE_4:
+		return 4 * size;
+	case DP_DSC_RC_BUF_BLK_SIZE_16:
+		return 16 * size;
+	case DP_DSC_RC_BUF_BLK_SIZE_64:
+		return 64 * size;
+	default:
+		return 0;
+	}
+}
+EXPORT_SYMBOL(drm_dsc_dp_rc_buffer_size);
+
+/**
+ * drm_dsc_pps_payload_pack() - Populates the DSC PPS
+ *
+ * @pps_payload:
+ * Bitwise struct for DSC Picture Parameter Set. This is defined
+ * by &struct drm_dsc_picture_parameter_set
+ * @dsc_cfg:
+ * DSC Configuration data filled by driver as defined by
+ * &struct drm_dsc_config
+ *
+ * DSC source device sends a picture parameter set (PPS) containing the
+ * information required by the sink to decode the compressed frame. Driver
+ * populates the DSC PPS struct using the DSC configuration parameters in
+ * the order expected by the DSC Display Sink device. For the DSC, the sink
+ * device expects the PPS payload in big endian format for fields
+ * that span more than 1 byte.
+ */
+void drm_dsc_pps_payload_pack(struct drm_dsc_picture_parameter_set *pps_payload,
+				const struct drm_dsc_config *dsc_cfg)
+{
+	int i;
+
+	/* Protect against someone accidentally changing struct size */
+	BUILD_BUG_ON(sizeof(*pps_payload) !=
+		     DP_SDP_PPS_HEADER_PAYLOAD_BYTES_MINUS_1 + 1);
+
+	memset(pps_payload, 0, sizeof(*pps_payload));
+
+	/* PPS 0 */
+	pps_payload->dsc_version =
+		dsc_cfg->dsc_version_minor |
+		dsc_cfg->dsc_version_major << DSC_PPS_VERSION_MAJOR_SHIFT;
+
+	/* PPS 1, 2 is 0 */
+
+	/* PPS 3 */
+	pps_payload->pps_3 =
+		dsc_cfg->line_buf_depth |
+		dsc_cfg->bits_per_component << DSC_PPS_BPC_SHIFT;
+
+	/* PPS 4 */
+	pps_payload->pps_4 =
+		((dsc_cfg->bits_per_pixel & DSC_PPS_BPP_HIGH_MASK) >>
+		 DSC_PPS_MSB_SHIFT) |
+		dsc_cfg->vbr_enable << DSC_PPS_VBR_EN_SHIFT |
+		dsc_cfg->simple_422 << DSC_PPS_SIMPLE422_SHIFT |
+		dsc_cfg->convert_rgb << DSC_PPS_CONVERT_RGB_SHIFT |
+		dsc_cfg->block_pred_enable << DSC_PPS_BLOCK_PRED_EN_SHIFT;
+
+	/* PPS 5 */
+	pps_payload->bits_per_pixel_low =
+		(dsc_cfg->bits_per_pixel & DSC_PPS_LSB_MASK);
+
+	/*
+	 * The DSC panel expects the PPS packet to have big endian format
+	 * for data spanning 2 bytes. Use a macro cpu_to_be16() to convert
+	 * to big endian format. If format is little endian, it will swap
+	 * bytes to convert to Big endian else keep it unchanged.
+	 */
+
+	/* PPS 6, 7 */
+	pps_payload->pic_height = cpu_to_be16(dsc_cfg->pic_height);
+
+	/* PPS 8, 9 */
+	pps_payload->pic_width = cpu_to_be16(dsc_cfg->pic_width);
+
+	/* PPS 10, 11 */
+	pps_payload->slice_height = cpu_to_be16(dsc_cfg->slice_height);
+
+	/* PPS 12, 13 */
+	pps_payload->slice_width = cpu_to_be16(dsc_cfg->slice_width);
+
+	/* PPS 14, 15 */
+	pps_payload->chunk_size = cpu_to_be16(dsc_cfg->slice_chunk_size);
+
+	/* PPS 16 */
+	pps_payload->initial_xmit_delay_high =
+		((dsc_cfg->initial_xmit_delay &
+		  DSC_PPS_INIT_XMIT_DELAY_HIGH_MASK) >>
+		 DSC_PPS_MSB_SHIFT);
+
+	/* PPS 17 */
+	pps_payload->initial_xmit_delay_low =
+		(dsc_cfg->initial_xmit_delay & DSC_PPS_LSB_MASK);
+
+	/* PPS 18, 19 */
+	pps_payload->initial_dec_delay =
+		cpu_to_be16(dsc_cfg->initial_dec_delay);
+
+	/* PPS 20 is 0 */
+
+	/* PPS 21 */
+	pps_payload->initial_scale_value =
+		dsc_cfg->initial_scale_value;
+
+	/* PPS 22, 23 */
+	pps_payload->scale_increment_interval =
+		cpu_to_be16(dsc_cfg->scale_increment_interval);
+
+	/* PPS 24 */
+	pps_payload->scale_decrement_interval_high =
+		((dsc_cfg->scale_decrement_interval &
+		  DSC_PPS_SCALE_DEC_INT_HIGH_MASK) >>
+		 DSC_PPS_MSB_SHIFT);
+
+	/* PPS 25 */
+	pps_payload->scale_decrement_interval_low =
+		(dsc_cfg->scale_decrement_interval & DSC_PPS_LSB_MASK);
+
+	/* PPS 26[7:0], PPS 27[7:5] RESERVED */
+
+	/* PPS 27 */
+	pps_payload->first_line_bpg_offset =
+		dsc_cfg->first_line_bpg_offset;
+
+	/* PPS 28, 29 */
+	pps_payload->nfl_bpg_offset =
+		cpu_to_be16(dsc_cfg->nfl_bpg_offset);
+
+	/* PPS 30, 31 */
+	pps_payload->slice_bpg_offset =
+		cpu_to_be16(dsc_cfg->slice_bpg_offset);
+
+	/* PPS 32, 33 */
+	pps_payload->initial_offset =
+		cpu_to_be16(dsc_cfg->initial_offset);
+
+	/* PPS 34, 35 */
+	pps_payload->final_offset = cpu_to_be16(dsc_cfg->final_offset);
+
+	/* PPS 36 */
+	pps_payload->flatness_min_qp = dsc_cfg->flatness_min_qp;
+
+	/* PPS 37 */
+	pps_payload->flatness_max_qp = dsc_cfg->flatness_max_qp;
+
+	/* PPS 38, 39 */
+	pps_payload->rc_model_size = cpu_to_be16(dsc_cfg->rc_model_size);
+
+	/* PPS 40 */
+	pps_payload->rc_edge_factor = DSC_RC_EDGE_FACTOR_CONST;
+
+	/* PPS 41 */
+	pps_payload->rc_quant_incr_limit0 =
+		dsc_cfg->rc_quant_incr_limit0;
+
+	/* PPS 42 */
+	pps_payload->rc_quant_incr_limit1 =
+		dsc_cfg->rc_quant_incr_limit1;
+
+	/* PPS 43 */
+	pps_payload->rc_tgt_offset = DSC_RC_TGT_OFFSET_LO_CONST |
+		DSC_RC_TGT_OFFSET_HI_CONST << DSC_PPS_RC_TGT_OFFSET_HI_SHIFT;
+
+	/* PPS 44 - 57 */
+	for (i = 0; i < DSC_NUM_BUF_RANGES - 1; i++)
+		pps_payload->rc_buf_thresh[i] =
+			dsc_cfg->rc_buf_thresh[i];
+
+	/* PPS 58 - 87 */
+	/*
+	 * For DSC sink programming the RC Range parameter fields
+	 * are as follows: Min_qp[15:11], max_qp[10:6], offset[5:0]
+	 */
+	for (i = 0; i < DSC_NUM_BUF_RANGES; i++) {
+		pps_payload->rc_range_parameters[i] =
+			cpu_to_be16((dsc_cfg->rc_range_params[i].range_min_qp <<
+				     DSC_PPS_RC_RANGE_MINQP_SHIFT) |
+				    (dsc_cfg->rc_range_params[i].range_max_qp <<
+				     DSC_PPS_RC_RANGE_MAXQP_SHIFT) |
+				    (dsc_cfg->rc_range_params[i].range_bpg_offset));
+	}
+
+	/* PPS 88 */
+	pps_payload->native_422_420 = dsc_cfg->native_422 |
+		dsc_cfg->native_420 << DSC_PPS_NATIVE_420_SHIFT;
+
+	/* PPS 89 */
+	pps_payload->second_line_bpg_offset =
+		dsc_cfg->second_line_bpg_offset;
+
+	/* PPS 90, 91 */
+	pps_payload->nsl_bpg_offset =
+		cpu_to_be16(dsc_cfg->nsl_bpg_offset);
+
+	/* PPS 92, 93 */
+	pps_payload->second_line_offset_adj =
+		cpu_to_be16(dsc_cfg->second_line_offset_adj);
+
+	/* PPS 94 - 127 are O */
+}
+EXPORT_SYMBOL(drm_dsc_pps_payload_pack);
+
+/**
+ * drm_dsc_compute_rc_parameters() - Write rate control
+ * parameters to the dsc configuration defined in
+ * &struct drm_dsc_config in accordance with the DSC 1.2
+ * specification. Some configuration fields must be present
+ * beforehand.
+ *
+ * @vdsc_cfg:
+ * DSC Configuration data partially filled by driver
+ */
+int drm_dsc_compute_rc_parameters(struct drm_dsc_config *vdsc_cfg)
+{
+	unsigned long groups_per_line = 0;
+	unsigned long groups_total = 0;
+	unsigned long num_extra_mux_bits = 0;
+	unsigned long slice_bits = 0;
+	unsigned long hrd_delay = 0;
+	unsigned long final_scale = 0;
+	unsigned long rbs_min = 0;
+
+	if (vdsc_cfg->native_420 || vdsc_cfg->native_422) {
+		/* Number of groups used to code each line of a slice */
+		groups_per_line = DIV_ROUND_UP(vdsc_cfg->slice_width / 2,
+					       DSC_RC_PIXELS_PER_GROUP);
+
+		/* chunksize in Bytes */
+		vdsc_cfg->slice_chunk_size = DIV_ROUND_UP(vdsc_cfg->slice_width / 2 *
+							  vdsc_cfg->bits_per_pixel,
+							  (8 * 16));
+	} else {
+		/* Number of groups used to code each line of a slice */
+		groups_per_line = DIV_ROUND_UP(vdsc_cfg->slice_width,
+					       DSC_RC_PIXELS_PER_GROUP);
+
+		/* chunksize in Bytes */
+		vdsc_cfg->slice_chunk_size = DIV_ROUND_UP(vdsc_cfg->slice_width *
+							  vdsc_cfg->bits_per_pixel,
+							  (8 * 16));
+	}
+
+	if (vdsc_cfg->convert_rgb)
+		num_extra_mux_bits = 3 * (vdsc_cfg->mux_word_size +
+					  (4 * vdsc_cfg->bits_per_component + 4)
+					  - 2);
+	else if (vdsc_cfg->native_422)
+		num_extra_mux_bits = 4 * vdsc_cfg->mux_word_size +
+			(4 * vdsc_cfg->bits_per_component + 4) +
+			3 * (4 * vdsc_cfg->bits_per_component) - 2;
+	else
+		num_extra_mux_bits = 3 * vdsc_cfg->mux_word_size +
+			(4 * vdsc_cfg->bits_per_component + 4) +
+			2 * (4 * vdsc_cfg->bits_per_component) - 2;
+	/* Number of bits in one Slice */
+	slice_bits = 8 * vdsc_cfg->slice_chunk_size * vdsc_cfg->slice_height;
+
+	while ((num_extra_mux_bits > 0) &&
+	       ((slice_bits - num_extra_mux_bits) % vdsc_cfg->mux_word_size))
+		num_extra_mux_bits--;
+
+	if (groups_per_line < vdsc_cfg->initial_scale_value - 8)
+		vdsc_cfg->initial_scale_value = groups_per_line + 8;
+
+	/* scale_decrement_interval calculation according to DSC spec 1.11 */
+	if (vdsc_cfg->initial_scale_value > 8)
+		vdsc_cfg->scale_decrement_interval = groups_per_line /
+			(vdsc_cfg->initial_scale_value - 8);
+	else
+		vdsc_cfg->scale_decrement_interval = DSC_SCALE_DECREMENT_INTERVAL_MAX;
+
+	vdsc_cfg->final_offset = vdsc_cfg->rc_model_size -
+		(vdsc_cfg->initial_xmit_delay *
+		 vdsc_cfg->bits_per_pixel + 8) / 16 + num_extra_mux_bits;
+
+	if (vdsc_cfg->final_offset >= vdsc_cfg->rc_model_size) {
+		DRM_DEBUG_KMS("FinalOfs < RcModelSze for this InitialXmitDelay\n");
+		return -ERANGE;
+	}
+
+	final_scale = (vdsc_cfg->rc_model_size * 8) /
+		(vdsc_cfg->rc_model_size - vdsc_cfg->final_offset);
+	if (vdsc_cfg->slice_height > 1)
+		/*
+		 * NflBpgOffset is 16 bit value with 11 fractional bits
+		 * hence we multiply by 2^11 for preserving the
+		 * fractional part
+		 */
+		vdsc_cfg->nfl_bpg_offset = DIV_ROUND_UP((vdsc_cfg->first_line_bpg_offset << 11),
+							(vdsc_cfg->slice_height - 1));
+	else
+		vdsc_cfg->nfl_bpg_offset = 0;
+
+	/* Number of groups used to code the entire slice */
+	groups_total = groups_per_line * vdsc_cfg->slice_height;
+
+	/* slice_bpg_offset is 16 bit value with 11 fractional bits */
+	vdsc_cfg->slice_bpg_offset = DIV_ROUND_UP(((vdsc_cfg->rc_model_size -
+						    vdsc_cfg->initial_offset +
+						    num_extra_mux_bits) << 11),
+						  groups_total);
+
+	if (final_scale > 9) {
+		/*
+		 * ScaleIncrementInterval =
+		 * finaloffset/((NflBpgOffset + SliceBpgOffset)*8(finalscale - 1.125))
+		 * as (NflBpgOffset + SliceBpgOffset) has 11 bit fractional value,
+		 * we need divide by 2^11 from pstDscCfg values
+		 */
+		vdsc_cfg->scale_increment_interval =
+				(vdsc_cfg->final_offset * (1 << 11)) /
+				((vdsc_cfg->nfl_bpg_offset +
+				vdsc_cfg->slice_bpg_offset) *
+				(final_scale - 9));
+	} else {
+		/*
+		 * If finalScaleValue is less than or equal to 9, a value of 0 should
+		 * be used to disable the scale increment at the end of the slice
+		 */
+		vdsc_cfg->scale_increment_interval = 0;
+	}
+
+	/*
+	 * DSC spec mentions that bits_per_pixel specifies the target
+	 * bits/pixel (bpp) rate that is used by the encoder,
+	 * in steps of 1/16 of a bit per pixel
+	 */
+	rbs_min = vdsc_cfg->rc_model_size - vdsc_cfg->initial_offset +
+		DIV_ROUND_UP(vdsc_cfg->initial_xmit_delay *
+			     vdsc_cfg->bits_per_pixel, 16) +
+		groups_per_line * vdsc_cfg->first_line_bpg_offset;
+
+	hrd_delay = DIV_ROUND_UP((rbs_min * 16), vdsc_cfg->bits_per_pixel);
+	vdsc_cfg->rc_bits = (hrd_delay * vdsc_cfg->bits_per_pixel) / 16;
+	vdsc_cfg->initial_dec_delay = hrd_delay - vdsc_cfg->initial_xmit_delay;
+
+	return 0;
+}
+EXPORT_SYMBOL(drm_dsc_compute_rc_parameters);
diff --git a/drivers/gpu/drm/drm_dsc.c b/drivers/gpu/drm/drm_dsc.c
deleted file mode 100644
index 2428bdfc4c8f..000000000000
--- a/drivers/gpu/drm/drm_dsc.c
+++ /dev/null
@@ -1,409 +0,0 @@
-// SPDX-License-Identifier: MIT
-/*
- * Copyright © 2018 Intel Corp
- *
- * Author:
- * Manasi Navare <manasi.d.navare@intel.com>
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/errno.h>
-#include <linux/byteorder/generic.h>
-
-#include <drm/display/drm_dp_helper.h>
-#include <drm/drm_print.h>
-#include <drm/drm_dsc.h>
-
-/**
- * DOC: dsc helpers
- *
- * VESA specification for DP 1.4 adds a new feature called Display Stream
- * Compression (DSC) used to compress the pixel bits before sending it on
- * DP/eDP/MIPI DSI interface. DSC is required to be enabled so that the existing
- * display interfaces can support high resolutions at higher frames rates uisng
- * the maximum available link capacity of these interfaces.
- *
- * These functions contain some common logic and helpers to deal with VESA
- * Display Stream Compression standard required for DSC on Display Port/eDP or
- * MIPI display interfaces.
- */
-
-/**
- * drm_dsc_dp_pps_header_init() - Initializes the PPS Header
- * for DisplayPort as per the DP 1.4 spec.
- * @pps_header: Secondary data packet header for DSC Picture
- *              Parameter Set as defined in &struct dp_sdp_header
- *
- * DP 1.4 spec defines the secondary data packet for sending the
- * picture parameter infoframes from the source to the sink.
- * This function populates the SDP header defined in
- * &struct dp_sdp_header.
- */
-void drm_dsc_dp_pps_header_init(struct dp_sdp_header *pps_header)
-{
-	memset(pps_header, 0, sizeof(*pps_header));
-
-	pps_header->HB1 = DP_SDP_PPS;
-	pps_header->HB2 = DP_SDP_PPS_HEADER_PAYLOAD_BYTES_MINUS_1;
-}
-EXPORT_SYMBOL(drm_dsc_dp_pps_header_init);
-
-/**
- * drm_dsc_dp_rc_buffer_size - get rc buffer size in bytes
- * @rc_buffer_block_size: block size code, according to DPCD offset 62h
- * @rc_buffer_size: number of blocks - 1, according to DPCD offset 63h
- *
- * return:
- * buffer size in bytes, or 0 on invalid input
- */
-int drm_dsc_dp_rc_buffer_size(u8 rc_buffer_block_size, u8 rc_buffer_size)
-{
-	int size = 1024 * (rc_buffer_size + 1);
-
-	switch (rc_buffer_block_size) {
-	case DP_DSC_RC_BUF_BLK_SIZE_1:
-		return 1 * size;
-	case DP_DSC_RC_BUF_BLK_SIZE_4:
-		return 4 * size;
-	case DP_DSC_RC_BUF_BLK_SIZE_16:
-		return 16 * size;
-	case DP_DSC_RC_BUF_BLK_SIZE_64:
-		return 64 * size;
-	default:
-		return 0;
-	}
-}
-EXPORT_SYMBOL(drm_dsc_dp_rc_buffer_size);
-
-/**
- * drm_dsc_pps_payload_pack() - Populates the DSC PPS
- *
- * @pps_payload:
- * Bitwise struct for DSC Picture Parameter Set. This is defined
- * by &struct drm_dsc_picture_parameter_set
- * @dsc_cfg:
- * DSC Configuration data filled by driver as defined by
- * &struct drm_dsc_config
- *
- * DSC source device sends a picture parameter set (PPS) containing the
- * information required by the sink to decode the compressed frame. Driver
- * populates the DSC PPS struct using the DSC configuration parameters in
- * the order expected by the DSC Display Sink device. For the DSC, the sink
- * device expects the PPS payload in big endian format for fields
- * that span more than 1 byte.
- */
-void drm_dsc_pps_payload_pack(struct drm_dsc_picture_parameter_set *pps_payload,
-				const struct drm_dsc_config *dsc_cfg)
-{
-	int i;
-
-	/* Protect against someone accidentally changing struct size */
-	BUILD_BUG_ON(sizeof(*pps_payload) !=
-		     DP_SDP_PPS_HEADER_PAYLOAD_BYTES_MINUS_1 + 1);
-
-	memset(pps_payload, 0, sizeof(*pps_payload));
-
-	/* PPS 0 */
-	pps_payload->dsc_version =
-		dsc_cfg->dsc_version_minor |
-		dsc_cfg->dsc_version_major << DSC_PPS_VERSION_MAJOR_SHIFT;
-
-	/* PPS 1, 2 is 0 */
-
-	/* PPS 3 */
-	pps_payload->pps_3 =
-		dsc_cfg->line_buf_depth |
-		dsc_cfg->bits_per_component << DSC_PPS_BPC_SHIFT;
-
-	/* PPS 4 */
-	pps_payload->pps_4 =
-		((dsc_cfg->bits_per_pixel & DSC_PPS_BPP_HIGH_MASK) >>
-		 DSC_PPS_MSB_SHIFT) |
-		dsc_cfg->vbr_enable << DSC_PPS_VBR_EN_SHIFT |
-		dsc_cfg->simple_422 << DSC_PPS_SIMPLE422_SHIFT |
-		dsc_cfg->convert_rgb << DSC_PPS_CONVERT_RGB_SHIFT |
-		dsc_cfg->block_pred_enable << DSC_PPS_BLOCK_PRED_EN_SHIFT;
-
-	/* PPS 5 */
-	pps_payload->bits_per_pixel_low =
-		(dsc_cfg->bits_per_pixel & DSC_PPS_LSB_MASK);
-
-	/*
-	 * The DSC panel expects the PPS packet to have big endian format
-	 * for data spanning 2 bytes. Use a macro cpu_to_be16() to convert
-	 * to big endian format. If format is little endian, it will swap
-	 * bytes to convert to Big endian else keep it unchanged.
-	 */
-
-	/* PPS 6, 7 */
-	pps_payload->pic_height = cpu_to_be16(dsc_cfg->pic_height);
-
-	/* PPS 8, 9 */
-	pps_payload->pic_width = cpu_to_be16(dsc_cfg->pic_width);
-
-	/* PPS 10, 11 */
-	pps_payload->slice_height = cpu_to_be16(dsc_cfg->slice_height);
-
-	/* PPS 12, 13 */
-	pps_payload->slice_width = cpu_to_be16(dsc_cfg->slice_width);
-
-	/* PPS 14, 15 */
-	pps_payload->chunk_size = cpu_to_be16(dsc_cfg->slice_chunk_size);
-
-	/* PPS 16 */
-	pps_payload->initial_xmit_delay_high =
-		((dsc_cfg->initial_xmit_delay &
-		  DSC_PPS_INIT_XMIT_DELAY_HIGH_MASK) >>
-		 DSC_PPS_MSB_SHIFT);
-
-	/* PPS 17 */
-	pps_payload->initial_xmit_delay_low =
-		(dsc_cfg->initial_xmit_delay & DSC_PPS_LSB_MASK);
-
-	/* PPS 18, 19 */
-	pps_payload->initial_dec_delay =
-		cpu_to_be16(dsc_cfg->initial_dec_delay);
-
-	/* PPS 20 is 0 */
-
-	/* PPS 21 */
-	pps_payload->initial_scale_value =
-		dsc_cfg->initial_scale_value;
-
-	/* PPS 22, 23 */
-	pps_payload->scale_increment_interval =
-		cpu_to_be16(dsc_cfg->scale_increment_interval);
-
-	/* PPS 24 */
-	pps_payload->scale_decrement_interval_high =
-		((dsc_cfg->scale_decrement_interval &
-		  DSC_PPS_SCALE_DEC_INT_HIGH_MASK) >>
-		 DSC_PPS_MSB_SHIFT);
-
-	/* PPS 25 */
-	pps_payload->scale_decrement_interval_low =
-		(dsc_cfg->scale_decrement_interval & DSC_PPS_LSB_MASK);
-
-	/* PPS 26[7:0], PPS 27[7:5] RESERVED */
-
-	/* PPS 27 */
-	pps_payload->first_line_bpg_offset =
-		dsc_cfg->first_line_bpg_offset;
-
-	/* PPS 28, 29 */
-	pps_payload->nfl_bpg_offset =
-		cpu_to_be16(dsc_cfg->nfl_bpg_offset);
-
-	/* PPS 30, 31 */
-	pps_payload->slice_bpg_offset =
-		cpu_to_be16(dsc_cfg->slice_bpg_offset);
-
-	/* PPS 32, 33 */
-	pps_payload->initial_offset =
-		cpu_to_be16(dsc_cfg->initial_offset);
-
-	/* PPS 34, 35 */
-	pps_payload->final_offset = cpu_to_be16(dsc_cfg->final_offset);
-
-	/* PPS 36 */
-	pps_payload->flatness_min_qp = dsc_cfg->flatness_min_qp;
-
-	/* PPS 37 */
-	pps_payload->flatness_max_qp = dsc_cfg->flatness_max_qp;
-
-	/* PPS 38, 39 */
-	pps_payload->rc_model_size = cpu_to_be16(dsc_cfg->rc_model_size);
-
-	/* PPS 40 */
-	pps_payload->rc_edge_factor = DSC_RC_EDGE_FACTOR_CONST;
-
-	/* PPS 41 */
-	pps_payload->rc_quant_incr_limit0 =
-		dsc_cfg->rc_quant_incr_limit0;
-
-	/* PPS 42 */
-	pps_payload->rc_quant_incr_limit1 =
-		dsc_cfg->rc_quant_incr_limit1;
-
-	/* PPS 43 */
-	pps_payload->rc_tgt_offset = DSC_RC_TGT_OFFSET_LO_CONST |
-		DSC_RC_TGT_OFFSET_HI_CONST << DSC_PPS_RC_TGT_OFFSET_HI_SHIFT;
-
-	/* PPS 44 - 57 */
-	for (i = 0; i < DSC_NUM_BUF_RANGES - 1; i++)
-		pps_payload->rc_buf_thresh[i] =
-			dsc_cfg->rc_buf_thresh[i];
-
-	/* PPS 58 - 87 */
-	/*
-	 * For DSC sink programming the RC Range parameter fields
-	 * are as follows: Min_qp[15:11], max_qp[10:6], offset[5:0]
-	 */
-	for (i = 0; i < DSC_NUM_BUF_RANGES; i++) {
-		pps_payload->rc_range_parameters[i] =
-			cpu_to_be16((dsc_cfg->rc_range_params[i].range_min_qp <<
-				     DSC_PPS_RC_RANGE_MINQP_SHIFT) |
-				    (dsc_cfg->rc_range_params[i].range_max_qp <<
-				     DSC_PPS_RC_RANGE_MAXQP_SHIFT) |
-				    (dsc_cfg->rc_range_params[i].range_bpg_offset));
-	}
-
-	/* PPS 88 */
-	pps_payload->native_422_420 = dsc_cfg->native_422 |
-		dsc_cfg->native_420 << DSC_PPS_NATIVE_420_SHIFT;
-
-	/* PPS 89 */
-	pps_payload->second_line_bpg_offset =
-		dsc_cfg->second_line_bpg_offset;
-
-	/* PPS 90, 91 */
-	pps_payload->nsl_bpg_offset =
-		cpu_to_be16(dsc_cfg->nsl_bpg_offset);
-
-	/* PPS 92, 93 */
-	pps_payload->second_line_offset_adj =
-		cpu_to_be16(dsc_cfg->second_line_offset_adj);
-
-	/* PPS 94 - 127 are O */
-}
-EXPORT_SYMBOL(drm_dsc_pps_payload_pack);
-
-/**
- * drm_dsc_compute_rc_parameters() - Write rate control
- * parameters to the dsc configuration defined in
- * &struct drm_dsc_config in accordance with the DSC 1.2
- * specification. Some configuration fields must be present
- * beforehand.
- *
- * @vdsc_cfg:
- * DSC Configuration data partially filled by driver
- */
-int drm_dsc_compute_rc_parameters(struct drm_dsc_config *vdsc_cfg)
-{
-	unsigned long groups_per_line = 0;
-	unsigned long groups_total = 0;
-	unsigned long num_extra_mux_bits = 0;
-	unsigned long slice_bits = 0;
-	unsigned long hrd_delay = 0;
-	unsigned long final_scale = 0;
-	unsigned long rbs_min = 0;
-
-	if (vdsc_cfg->native_420 || vdsc_cfg->native_422) {
-		/* Number of groups used to code each line of a slice */
-		groups_per_line = DIV_ROUND_UP(vdsc_cfg->slice_width / 2,
-					       DSC_RC_PIXELS_PER_GROUP);
-
-		/* chunksize in Bytes */
-		vdsc_cfg->slice_chunk_size = DIV_ROUND_UP(vdsc_cfg->slice_width / 2 *
-							  vdsc_cfg->bits_per_pixel,
-							  (8 * 16));
-	} else {
-		/* Number of groups used to code each line of a slice */
-		groups_per_line = DIV_ROUND_UP(vdsc_cfg->slice_width,
-					       DSC_RC_PIXELS_PER_GROUP);
-
-		/* chunksize in Bytes */
-		vdsc_cfg->slice_chunk_size = DIV_ROUND_UP(vdsc_cfg->slice_width *
-							  vdsc_cfg->bits_per_pixel,
-							  (8 * 16));
-	}
-
-	if (vdsc_cfg->convert_rgb)
-		num_extra_mux_bits = 3 * (vdsc_cfg->mux_word_size +
-					  (4 * vdsc_cfg->bits_per_component + 4)
-					  - 2);
-	else if (vdsc_cfg->native_422)
-		num_extra_mux_bits = 4 * vdsc_cfg->mux_word_size +
-			(4 * vdsc_cfg->bits_per_component + 4) +
-			3 * (4 * vdsc_cfg->bits_per_component) - 2;
-	else
-		num_extra_mux_bits = 3 * vdsc_cfg->mux_word_size +
-			(4 * vdsc_cfg->bits_per_component + 4) +
-			2 * (4 * vdsc_cfg->bits_per_component) - 2;
-	/* Number of bits in one Slice */
-	slice_bits = 8 * vdsc_cfg->slice_chunk_size * vdsc_cfg->slice_height;
-
-	while ((num_extra_mux_bits > 0) &&
-	       ((slice_bits - num_extra_mux_bits) % vdsc_cfg->mux_word_size))
-		num_extra_mux_bits--;
-
-	if (groups_per_line < vdsc_cfg->initial_scale_value - 8)
-		vdsc_cfg->initial_scale_value = groups_per_line + 8;
-
-	/* scale_decrement_interval calculation according to DSC spec 1.11 */
-	if (vdsc_cfg->initial_scale_value > 8)
-		vdsc_cfg->scale_decrement_interval = groups_per_line /
-			(vdsc_cfg->initial_scale_value - 8);
-	else
-		vdsc_cfg->scale_decrement_interval = DSC_SCALE_DECREMENT_INTERVAL_MAX;
-
-	vdsc_cfg->final_offset = vdsc_cfg->rc_model_size -
-		(vdsc_cfg->initial_xmit_delay *
-		 vdsc_cfg->bits_per_pixel + 8) / 16 + num_extra_mux_bits;
-
-	if (vdsc_cfg->final_offset >= vdsc_cfg->rc_model_size) {
-		DRM_DEBUG_KMS("FinalOfs < RcModelSze for this InitialXmitDelay\n");
-		return -ERANGE;
-	}
-
-	final_scale = (vdsc_cfg->rc_model_size * 8) /
-		(vdsc_cfg->rc_model_size - vdsc_cfg->final_offset);
-	if (vdsc_cfg->slice_height > 1)
-		/*
-		 * NflBpgOffset is 16 bit value with 11 fractional bits
-		 * hence we multiply by 2^11 for preserving the
-		 * fractional part
-		 */
-		vdsc_cfg->nfl_bpg_offset = DIV_ROUND_UP((vdsc_cfg->first_line_bpg_offset << 11),
-							(vdsc_cfg->slice_height - 1));
-	else
-		vdsc_cfg->nfl_bpg_offset = 0;
-
-	/* Number of groups used to code the entire slice */
-	groups_total = groups_per_line * vdsc_cfg->slice_height;
-
-	/* slice_bpg_offset is 16 bit value with 11 fractional bits */
-	vdsc_cfg->slice_bpg_offset = DIV_ROUND_UP(((vdsc_cfg->rc_model_size -
-						    vdsc_cfg->initial_offset +
-						    num_extra_mux_bits) << 11),
-						  groups_total);
-
-	if (final_scale > 9) {
-		/*
-		 * ScaleIncrementInterval =
-		 * finaloffset/((NflBpgOffset + SliceBpgOffset)*8(finalscale - 1.125))
-		 * as (NflBpgOffset + SliceBpgOffset) has 11 bit fractional value,
-		 * we need divide by 2^11 from pstDscCfg values
-		 */
-		vdsc_cfg->scale_increment_interval =
-				(vdsc_cfg->final_offset * (1 << 11)) /
-				((vdsc_cfg->nfl_bpg_offset +
-				vdsc_cfg->slice_bpg_offset) *
-				(final_scale - 9));
-	} else {
-		/*
-		 * If finalScaleValue is less than or equal to 9, a value of 0 should
-		 * be used to disable the scale increment at the end of the slice
-		 */
-		vdsc_cfg->scale_increment_interval = 0;
-	}
-
-	/*
-	 * DSC spec mentions that bits_per_pixel specifies the target
-	 * bits/pixel (bpp) rate that is used by the encoder,
-	 * in steps of 1/16 of a bit per pixel
-	 */
-	rbs_min = vdsc_cfg->rc_model_size - vdsc_cfg->initial_offset +
-		DIV_ROUND_UP(vdsc_cfg->initial_xmit_delay *
-			     vdsc_cfg->bits_per_pixel, 16) +
-		groups_per_line * vdsc_cfg->first_line_bpg_offset;
-
-	hrd_delay = DIV_ROUND_UP((rbs_min * 16), vdsc_cfg->bits_per_pixel);
-	vdsc_cfg->rc_bits = (hrd_delay * vdsc_cfg->bits_per_pixel) / 16;
-	vdsc_cfg->initial_dec_delay = hrd_delay - vdsc_cfg->initial_xmit_delay;
-
-	return 0;
-}
-EXPORT_SYMBOL(drm_dsc_compute_rc_parameters);
diff --git a/drivers/gpu/drm/drm_mipi_dsi.c b/drivers/gpu/drm/drm_mipi_dsi.c
index 18cef04df2f2..c40bde96cfdf 100644
--- a/drivers/gpu/drm/drm_mipi_dsi.c
+++ b/drivers/gpu/drm/drm_mipi_dsi.c
@@ -25,16 +25,16 @@
  * USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
-#include <drm/drm_mipi_dsi.h>
-
 #include <linux/device.h>
 #include <linux/module.h>
 #include <linux/of_device.h>
 #include <linux/pm_runtime.h>
 #include <linux/slab.h>
 
-#include <drm/drm_dsc.h>
+#include <drm/display/drm_dsc.h>
+#include <drm/drm_mipi_dsi.h>
 #include <drm/drm_print.h>
+
 #include <video/mipi_display.h>
 
 /**
diff --git a/drivers/gpu/drm/i915/display/icl_dsi.c b/drivers/gpu/drm/i915/display/icl_dsi.c
index 084cc51d1c41..d1abd00d4f4d 100644
--- a/drivers/gpu/drm/i915/display/icl_dsi.c
+++ b/drivers/gpu/drm/i915/display/icl_dsi.c
@@ -25,6 +25,7 @@
  *   Jani Nikula <jani.nikula@intel.com>
  */
 
+#include <drm/display/drm_dsc_helper.h>
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_mipi_dsi.h>
 
diff --git a/drivers/gpu/drm/i915/display/intel_bios.c b/drivers/gpu/drm/i915/display/intel_bios.c
index 287daa91fb91..af5dba43b5c5 100644
--- a/drivers/gpu/drm/i915/display/intel_bios.c
+++ b/drivers/gpu/drm/i915/display/intel_bios.c
@@ -26,6 +26,7 @@
  */
 
 #include <drm/display/drm_dp_helper.h>
+#include <drm/display/drm_dsc_helper.h>
 
 #include "display/intel_display.h"
 #include "display/intel_display_types.h"
diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index efc42af60440..408152f9f46a 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -33,9 +33,9 @@
 
 #include <drm/display/drm_dp_dual_mode_helper.h>
 #include <drm/display/drm_dp_mst_helper.h>
+#include <drm/display/drm_dsc.h>
 #include <drm/drm_atomic.h>
 #include <drm/drm_crtc.h>
-#include <drm/drm_dsc.h>
 #include <drm/drm_encoder.h>
 #include <drm/drm_fourcc.h>
 #include <drm/drm_probe_helper.h>
diff --git a/drivers/gpu/drm/i915/display/intel_dp.c b/drivers/gpu/drm/i915/display/intel_dp.c
index 9801e6f0ad3b..8c0fe4d53806 100644
--- a/drivers/gpu/drm/i915/display/intel_dp.c
+++ b/drivers/gpu/drm/i915/display/intel_dp.c
@@ -36,6 +36,7 @@
 #include <asm/byteorder.h>
 
 #include <drm/display/drm_dp_helper.h>
+#include <drm/display/drm_dsc_helper.h>
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_crtc.h>
 #include <drm/drm_edid.h>
diff --git a/drivers/gpu/drm/i915/display/intel_qp_tables.c b/drivers/gpu/drm/i915/display/intel_qp_tables.c
index c626a24fe98f..6f8e4ec5c0fb 100644
--- a/drivers/gpu/drm/i915/display/intel_qp_tables.c
+++ b/drivers/gpu/drm/i915/display/intel_qp_tables.c
@@ -3,7 +3,7 @@
  * Copyright © 2021 Intel Corporation
  */
 
-#include <drm/drm_dsc.h>
+#include <drm/display/drm_dsc.h>
 
 #include "i915_utils.h"
 #include "intel_qp_tables.h"
diff --git a/drivers/gpu/drm/i915/display/intel_vdsc.c b/drivers/gpu/drm/i915/display/intel_vdsc.c
index e59c29ab1300..43e1bbc1e303 100644
--- a/drivers/gpu/drm/i915/display/intel_vdsc.c
+++ b/drivers/gpu/drm/i915/display/intel_vdsc.c
@@ -7,6 +7,8 @@
  */
 #include <linux/limits.h>
 
+#include <drm/display/drm_dsc_helper.h>
+
 #include "i915_drv.h"
 #include "intel_crtc.h"
 #include "intel_de.h"
diff --git a/include/drm/display/drm_dsc.h b/include/drm/display/drm_dsc.h
new file mode 100644
index 000000000000..bc90273d06a6
--- /dev/null
+++ b/include/drm/display/drm_dsc.h
@@ -0,0 +1,605 @@
+/* SPDX-License-Identifier: MIT
+ * Copyright (C) 2018 Intel Corp.
+ *
+ * Authors:
+ * Manasi Navare <manasi.d.navare@intel.com>
+ */
+
+#ifndef DRM_DSC_H_
+#define DRM_DSC_H_
+
+#include <drm/display/drm_dp.h>
+
+/* VESA Display Stream Compression DSC 1.2 constants */
+#define DSC_NUM_BUF_RANGES			15
+#define DSC_MUX_WORD_SIZE_8_10_BPC		48
+#define DSC_MUX_WORD_SIZE_12_BPC		64
+#define DSC_RC_PIXELS_PER_GROUP			3
+#define DSC_SCALE_DECREMENT_INTERVAL_MAX	4095
+#define DSC_RANGE_BPG_OFFSET_MASK		0x3f
+
+/* DSC Rate Control Constants */
+#define DSC_RC_MODEL_SIZE_CONST		    8192
+#define DSC_RC_EDGE_FACTOR_CONST	    6
+#define DSC_RC_TGT_OFFSET_HI_CONST	    3
+#define DSC_RC_TGT_OFFSET_LO_CONST	    3
+
+/* DSC PPS constants and macros */
+#define DSC_PPS_VERSION_MAJOR_SHIFT		4
+#define DSC_PPS_BPC_SHIFT			4
+#define DSC_PPS_MSB_SHIFT			8
+#define DSC_PPS_LSB_MASK			(0xFF << 0)
+#define DSC_PPS_BPP_HIGH_MASK			(0x3 << 8)
+#define DSC_PPS_VBR_EN_SHIFT			2
+#define DSC_PPS_SIMPLE422_SHIFT			3
+#define DSC_PPS_CONVERT_RGB_SHIFT		4
+#define DSC_PPS_BLOCK_PRED_EN_SHIFT		5
+#define DSC_PPS_INIT_XMIT_DELAY_HIGH_MASK	(0x3 << 8)
+#define DSC_PPS_SCALE_DEC_INT_HIGH_MASK		(0xF << 8)
+#define DSC_PPS_RC_TGT_OFFSET_HI_SHIFT		4
+#define DSC_PPS_RC_RANGE_MINQP_SHIFT		11
+#define DSC_PPS_RC_RANGE_MAXQP_SHIFT		6
+#define DSC_PPS_NATIVE_420_SHIFT		1
+#define DSC_1_2_MAX_LINEBUF_DEPTH_BITS		16
+#define DSC_1_2_MAX_LINEBUF_DEPTH_VAL		0
+#define DSC_1_1_MAX_LINEBUF_DEPTH_BITS		13
+
+/**
+ * struct drm_dsc_rc_range_parameters - DSC Rate Control range parameters
+ *
+ * This defines different rate control parameters used by the DSC engine
+ * to compress the frame.
+ */
+struct drm_dsc_rc_range_parameters {
+	/**
+	 * @range_min_qp: Min Quantization Parameters allowed for this range
+	 */
+	u8 range_min_qp;
+	/**
+	 * @range_max_qp: Max Quantization Parameters allowed for this range
+	 */
+	u8 range_max_qp;
+	/**
+	 * @range_bpg_offset:
+	 * Bits/group offset to apply to target for this group
+	 */
+	u8 range_bpg_offset;
+};
+
+/**
+ * struct drm_dsc_config - Parameters required to configure DSC
+ *
+ * Driver populates this structure with all the parameters required
+ * to configure the display stream compression on the source.
+ */
+struct drm_dsc_config {
+	/**
+	 * @line_buf_depth:
+	 * Bits per component for previous reconstructed line buffer
+	 */
+	u8 line_buf_depth;
+	/**
+	 * @bits_per_component: Bits per component to code (8/10/12)
+	 */
+	u8 bits_per_component;
+	/**
+	 * @convert_rgb:
+	 * Flag to indicate if RGB - YCoCg conversion is needed
+	 * True if RGB input, False if YCoCg input
+	 */
+	bool convert_rgb;
+	/**
+	 * @slice_count: Number fo slices per line used by the DSC encoder
+	 */
+	u8 slice_count;
+	/**
+	 *  @slice_width: Width of each slice in pixels
+	 */
+	u16 slice_width;
+	/**
+	 * @slice_height: Slice height in pixels
+	 */
+	u16 slice_height;
+	/**
+	 * @simple_422: True if simple 4_2_2 mode is enabled else False
+	 */
+	bool simple_422;
+	/**
+	 * @pic_width: Width of the input display frame in pixels
+	 */
+	u16 pic_width;
+	/**
+	 * @pic_height: Vertical height of the input display frame
+	 */
+	u16 pic_height;
+	/**
+	 * @rc_tgt_offset_high:
+	 * Offset to bits/group used by RC to determine QP adjustment
+	 */
+	u8 rc_tgt_offset_high;
+	/**
+	 * @rc_tgt_offset_low:
+	 * Offset to bits/group used by RC to determine QP adjustment
+	 */
+	u8 rc_tgt_offset_low;
+	/**
+	 * @bits_per_pixel:
+	 * Target bits per pixel with 4 fractional bits, bits_per_pixel << 4
+	 */
+	u16 bits_per_pixel;
+	/**
+	 * @rc_edge_factor:
+	 * Factor to determine if an edge is present based on the bits produced
+	 */
+	u8 rc_edge_factor;
+	/**
+	 * @rc_quant_incr_limit1:
+	 * Slow down incrementing once the range reaches this value
+	 */
+	u8 rc_quant_incr_limit1;
+	/**
+	 * @rc_quant_incr_limit0:
+	 * Slow down incrementing once the range reaches this value
+	 */
+	u8 rc_quant_incr_limit0;
+	/**
+	 * @initial_xmit_delay:
+	 * Number of pixels to delay the initial transmission
+	 */
+	u16 initial_xmit_delay;
+	/**
+	 * @initial_dec_delay:
+	 * Initial decoder delay, number of pixel times that the decoder
+	 * accumulates data in its rate buffer before starting to decode
+	 * and output pixels.
+	 */
+	u16  initial_dec_delay;
+	/**
+	 * @block_pred_enable:
+	 * True if block prediction is used to code any groups within the
+	 * picture. False if BP not used
+	 */
+	bool block_pred_enable;
+	/**
+	 * @first_line_bpg_offset:
+	 * Number of additional bits allocated for each group on the first
+	 * line of slice.
+	 */
+	u8 first_line_bpg_offset;
+	/**
+	 * @initial_offset: Value to use for RC model offset at slice start
+	 */
+	u16 initial_offset;
+	/**
+	 * @rc_buf_thresh: Thresholds defining each of the buffer ranges
+	 */
+	u16 rc_buf_thresh[DSC_NUM_BUF_RANGES - 1];
+	/**
+	 * @rc_range_params:
+	 * Parameters for each of the RC ranges defined in
+	 * &struct drm_dsc_rc_range_parameters
+	 */
+	struct drm_dsc_rc_range_parameters rc_range_params[DSC_NUM_BUF_RANGES];
+	/**
+	 * @rc_model_size: Total size of RC model
+	 */
+	u16 rc_model_size;
+	/**
+	 * @flatness_min_qp: Minimum QP where flatness information is sent
+	 */
+	u8 flatness_min_qp;
+	/**
+	 * @flatness_max_qp: Maximum QP where flatness information is sent
+	 */
+	u8 flatness_max_qp;
+	/**
+	 * @initial_scale_value: Initial value for the scale factor
+	 */
+	u8 initial_scale_value;
+	/**
+	 * @scale_decrement_interval:
+	 * Specifies number of group times between decrementing the scale factor
+	 * at beginning of a slice.
+	 */
+	u16 scale_decrement_interval;
+	/**
+	 * @scale_increment_interval:
+	 * Number of group times between incrementing the scale factor value
+	 * used at the beginning of a slice.
+	 */
+	u16 scale_increment_interval;
+	/**
+	 * @nfl_bpg_offset: Non first line BPG offset to be used
+	 */
+	u16 nfl_bpg_offset;
+	/**
+	 * @slice_bpg_offset: BPG offset used to enforce slice bit
+	 */
+	u16 slice_bpg_offset;
+	/**
+	 * @final_offset: Final RC linear transformation offset value
+	 */
+	u16 final_offset;
+	/**
+	 * @vbr_enable: True if VBR mode is enabled, false if disabled
+	 */
+	bool vbr_enable;
+	/**
+	 * @mux_word_size: Mux word size (in bits) for SSM mode
+	 */
+	u8 mux_word_size;
+	/**
+	 * @slice_chunk_size:
+	 * The (max) size in bytes of the "chunks" that are used in slice
+	 * multiplexing.
+	 */
+	u16 slice_chunk_size;
+	/**
+	 * @rc_bits: Rate control buffer size in bits
+	 */
+	u16 rc_bits;
+	/**
+	 * @dsc_version_minor: DSC minor version
+	 */
+	u8 dsc_version_minor;
+	/**
+	 * @dsc_version_major: DSC major version
+	 */
+	u8 dsc_version_major;
+	/**
+	 * @native_422: True if Native 4:2:2 supported, else false
+	 */
+	bool native_422;
+	/**
+	 * @native_420: True if Native 4:2:0 supported else false.
+	 */
+	bool native_420;
+	/**
+	 * @second_line_bpg_offset:
+	 * Additional bits/grp for seconnd line of slice for native 4:2:0
+	 */
+	u8 second_line_bpg_offset;
+	/**
+	 * @nsl_bpg_offset:
+	 * Num of bits deallocated for each grp that is not in second line of
+	 * slice
+	 */
+	u16 nsl_bpg_offset;
+	/**
+	 * @second_line_offset_adj:
+	 * Offset adjustment for second line in Native 4:2:0 mode
+	 */
+	u16 second_line_offset_adj;
+};
+
+/**
+ * struct drm_dsc_picture_parameter_set - Represents 128 bytes of
+ * 	Picture Parameter Set
+ *
+ * The VESA DSC standard defines picture parameter set (PPS) which display
+ * stream compression encoders must communicate to decoders.
+ * The PPS is encapsulated in 128 bytes (PPS 0 through PPS 127). The fields in
+ * this structure are as per Table 4.1 in Vesa DSC specification v1.1/v1.2.
+ * The PPS fields that span over more than a byte should be stored in Big Endian
+ * format.
+ */
+struct drm_dsc_picture_parameter_set {
+	/**
+	 * @dsc_version:
+	 * PPS0[3:0] - dsc_version_minor: Contains Minor version of DSC
+	 * PPS0[7:4] - dsc_version_major: Contains major version of DSC
+	 */
+	u8 dsc_version;
+	/**
+	 * @pps_identifier:
+	 * PPS1[7:0] - Application specific identifier that can be
+	 * used to differentiate between different PPS tables.
+	 */
+	u8 pps_identifier;
+	/**
+	 * @pps_reserved:
+	 * PPS2[7:0]- RESERVED Byte
+	 */
+	u8 pps_reserved;
+	/**
+	 * @pps_3:
+	 * PPS3[3:0] - linebuf_depth: Contains linebuffer bit depth used to
+	 * generate the bitstream. (0x0 - 16 bits for DSC 1.2, 0x8 - 8 bits,
+	 * 0xA - 10 bits, 0xB - 11 bits, 0xC - 12 bits, 0xD - 13 bits,
+	 * 0xE - 14 bits for DSC1.2, 0xF - 14 bits for DSC 1.2.
+	 * PPS3[7:4] - bits_per_component: Bits per component for the original
+	 * pixels of the encoded picture.
+	 * 0x0 = 16bpc (allowed only when dsc_version_minor = 0x2)
+	 * 0x8 = 8bpc, 0xA = 10bpc, 0xC = 12bpc, 0xE = 14bpc (also
+	 * allowed only when dsc_minor_version = 0x2)
+	 */
+	u8 pps_3;
+	/**
+	 * @pps_4:
+	 * PPS4[1:0] -These are the most significant 2 bits of
+	 * compressed BPP bits_per_pixel[9:0] syntax element.
+	 * PPS4[2] - vbr_enable: 0 = VBR disabled, 1 = VBR enabled
+	 * PPS4[3] - simple_422: Indicates if decoder drops samples to
+	 * reconstruct the 4:2:2 picture.
+	 * PPS4[4] - Convert_rgb: Indicates if DSC color space conversion is
+	 * active.
+	 * PPS4[5] - blobk_pred_enable: Indicates if BP is used to code any
+	 * groups in picture
+	 * PPS4[7:6] - Reseved bits
+	 */
+	u8 pps_4;
+	/**
+	 * @bits_per_pixel_low:
+	 * PPS5[7:0] - This indicates the lower significant 8 bits of
+	 * the compressed BPP bits_per_pixel[9:0] element.
+	 */
+	u8 bits_per_pixel_low;
+	/**
+	 * @pic_height:
+	 * PPS6[7:0], PPS7[7:0] -pic_height: Specifies the number of pixel rows
+	 * within the raster.
+	 */
+	__be16 pic_height;
+	/**
+	 * @pic_width:
+	 * PPS8[7:0], PPS9[7:0] - pic_width: Number of pixel columns within
+	 * the raster.
+	 */
+	__be16 pic_width;
+	/**
+	 * @slice_height:
+	 * PPS10[7:0], PPS11[7:0] - Slice height in units of pixels.
+	 */
+	__be16 slice_height;
+	/**
+	 * @slice_width:
+	 * PPS12[7:0], PPS13[7:0] - Slice width in terms of pixels.
+	 */
+	__be16 slice_width;
+	/**
+	 * @chunk_size:
+	 * PPS14[7:0], PPS15[7:0] - Size in units of bytes of the chunks
+	 * that are used for slice multiplexing.
+	 */
+	__be16 chunk_size;
+	/**
+	 * @initial_xmit_delay_high:
+	 * PPS16[1:0] - Most Significant two bits of initial transmission delay.
+	 * It specifies the number of pixel times that the encoder waits before
+	 * transmitting data from its rate buffer.
+	 * PPS16[7:2] - Reserved
+	 */
+	u8 initial_xmit_delay_high;
+	/**
+	 * @initial_xmit_delay_low:
+	 * PPS17[7:0] - Least significant 8 bits of initial transmission delay.
+	 */
+	u8 initial_xmit_delay_low;
+	/**
+	 * @initial_dec_delay:
+	 *
+	 * PPS18[7:0], PPS19[7:0] - Initial decoding delay which is the number
+	 * of pixel times that the decoder accumulates data in its rate buffer
+	 * before starting to decode and output pixels.
+	 */
+	__be16 initial_dec_delay;
+	/**
+	 * @pps20_reserved:
+	 *
+	 * PPS20[7:0] - Reserved
+	 */
+	u8 pps20_reserved;
+	/**
+	 * @initial_scale_value:
+	 * PPS21[5:0] - Initial rcXformScale factor used at beginning
+	 * of a slice.
+	 * PPS21[7:6] - Reserved
+	 */
+	u8 initial_scale_value;
+	/**
+	 * @scale_increment_interval:
+	 * PPS22[7:0], PPS23[7:0] - Number of group times between incrementing
+	 * the rcXformScale factor at end of a slice.
+	 */
+	__be16 scale_increment_interval;
+	/**
+	 * @scale_decrement_interval_high:
+	 * PPS24[3:0] - Higher 4 bits indicating number of group times between
+	 * decrementing the rcXformScale factor at beginning of a slice.
+	 * PPS24[7:4] - Reserved
+	 */
+	u8 scale_decrement_interval_high;
+	/**
+	 * @scale_decrement_interval_low:
+	 * PPS25[7:0] - Lower 8 bits of scale decrement interval
+	 */
+	u8 scale_decrement_interval_low;
+	/**
+	 * @pps26_reserved:
+	 * PPS26[7:0]
+	 */
+	u8 pps26_reserved;
+	/**
+	 * @first_line_bpg_offset:
+	 * PPS27[4:0] - Number of additional bits that are allocated
+	 * for each group on first line of a slice.
+	 * PPS27[7:5] - Reserved
+	 */
+	u8 first_line_bpg_offset;
+	/**
+	 * @nfl_bpg_offset:
+	 * PPS28[7:0], PPS29[7:0] - Number of bits including frac bits
+	 * deallocated for each group for groups after the first line of slice.
+	 */
+	__be16 nfl_bpg_offset;
+	/**
+	 * @slice_bpg_offset:
+	 * PPS30, PPS31[7:0] - Number of bits that are deallocated for each
+	 * group to enforce the slice constraint.
+	 */
+	__be16 slice_bpg_offset;
+	/**
+	 * @initial_offset:
+	 * PPS32,33[7:0] - Initial value for rcXformOffset
+	 */
+	__be16 initial_offset;
+	/**
+	 * @final_offset:
+	 * PPS34,35[7:0] - Maximum end-of-slice value for rcXformOffset
+	 */
+	__be16 final_offset;
+	/**
+	 * @flatness_min_qp:
+	 * PPS36[4:0] - Minimum QP at which flatness is signaled and
+	 * flatness QP adjustment is made.
+	 * PPS36[7:5] - Reserved
+	 */
+	u8 flatness_min_qp;
+	/**
+	 * @flatness_max_qp:
+	 * PPS37[4:0] - Max QP at which flatness is signalled and
+	 * the flatness adjustment is made.
+	 * PPS37[7:5] - Reserved
+	 */
+	u8 flatness_max_qp;
+	/**
+	 * @rc_model_size:
+	 * PPS38,39[7:0] - Number of bits within RC Model.
+	 */
+	__be16 rc_model_size;
+	/**
+	 * @rc_edge_factor:
+	 * PPS40[3:0] - Ratio of current activity vs, previous
+	 * activity to determine presence of edge.
+	 * PPS40[7:4] - Reserved
+	 */
+	u8 rc_edge_factor;
+	/**
+	 * @rc_quant_incr_limit0:
+	 * PPS41[4:0] - QP threshold used in short term RC
+	 * PPS41[7:5] - Reserved
+	 */
+	u8 rc_quant_incr_limit0;
+	/**
+	 * @rc_quant_incr_limit1:
+	 * PPS42[4:0] - QP threshold used in short term RC
+	 * PPS42[7:5] - Reserved
+	 */
+	u8 rc_quant_incr_limit1;
+	/**
+	 * @rc_tgt_offset:
+	 * PPS43[3:0] - Lower end of the variability range around the target
+	 * bits per group that is allowed by short term RC.
+	 * PPS43[7:4]- Upper end of the variability range around the target
+	 * bits per group that i allowed by short term rc.
+	 */
+	u8 rc_tgt_offset;
+	/**
+	 * @rc_buf_thresh:
+	 * PPS44[7:0] - PPS57[7:0] - Specifies the thresholds in RC model for
+	 * the 15 ranges defined by 14 thresholds.
+	 */
+	u8 rc_buf_thresh[DSC_NUM_BUF_RANGES - 1];
+	/**
+	 * @rc_range_parameters:
+	 * PPS58[7:0] - PPS87[7:0]
+	 * Parameters that correspond to each of the 15 ranges.
+	 */
+	__be16 rc_range_parameters[DSC_NUM_BUF_RANGES];
+	/**
+	 * @native_422_420:
+	 * PPS88[0] - 0 = Native 4:2:2 not used
+	 * 1 = Native 4:2:2 used
+	 * PPS88[1] - 0 = Native 4:2:0 not use
+	 * 1 = Native 4:2:0 used
+	 * PPS88[7:2] - Reserved 6 bits
+	 */
+	u8 native_422_420;
+	/**
+	 * @second_line_bpg_offset:
+	 * PPS89[4:0] - Additional bits/group budget for the
+	 * second line of a slice in Native 4:2:0 mode.
+	 * Set to 0 if DSC minor version is 1 or native420 is 0.
+	 * PPS89[7:5] - Reserved
+	 */
+	u8 second_line_bpg_offset;
+	/**
+	 * @nsl_bpg_offset:
+	 * PPS90[7:0], PPS91[7:0] - Number of bits that are deallocated
+	 * for each group that is not in the second line of a slice.
+	 */
+	__be16 nsl_bpg_offset;
+	/**
+	 * @second_line_offset_adj:
+	 * PPS92[7:0], PPS93[7:0] - Used as offset adjustment for the second
+	 * line in Native 4:2:0 mode.
+	 */
+	__be16 second_line_offset_adj;
+	/**
+	 * @pps_long_94_reserved:
+	 * PPS 94, 95, 96, 97 - Reserved
+	 */
+	u32 pps_long_94_reserved;
+	/**
+	 * @pps_long_98_reserved:
+	 * PPS 98, 99, 100, 101 - Reserved
+	 */
+	u32 pps_long_98_reserved;
+	/**
+	 * @pps_long_102_reserved:
+	 * PPS 102, 103, 104, 105 - Reserved
+	 */
+	u32 pps_long_102_reserved;
+	/**
+	 * @pps_long_106_reserved:
+	 * PPS 106, 107, 108, 109 - reserved
+	 */
+	u32 pps_long_106_reserved;
+	/**
+	 * @pps_long_110_reserved:
+	 * PPS 110, 111, 112, 113 - reserved
+	 */
+	u32 pps_long_110_reserved;
+	/**
+	 * @pps_long_114_reserved:
+	 * PPS 114 - 117 - reserved
+	 */
+	u32 pps_long_114_reserved;
+	/**
+	 * @pps_long_118_reserved:
+	 * PPS 118 - 121 - reserved
+	 */
+	u32 pps_long_118_reserved;
+	/**
+	 * @pps_long_122_reserved:
+	 * PPS 122- 125 - reserved
+	 */
+	u32 pps_long_122_reserved;
+	/**
+	 * @pps_short_126_reserved:
+	 * PPS 126, 127 - reserved
+	 */
+	__be16 pps_short_126_reserved;
+} __packed;
+
+/**
+ * struct drm_dsc_pps_infoframe - DSC infoframe carrying the Picture Parameter
+ * Set Metadata
+ *
+ * This structure represents the DSC PPS infoframe required to send the Picture
+ * Parameter Set metadata required before enabling VESA Display Stream
+ * Compression. This is based on the DP Secondary Data Packet structure and
+ * comprises of SDP Header as defined &struct dp_sdp_header in drm_dp_helper.h
+ * and PPS payload defined in &struct drm_dsc_picture_parameter_set.
+ *
+ * @pps_header: Header for PPS as per DP SDP header format of type
+ *              &struct dp_sdp_header
+ * @pps_payload: PPS payload fields as per DSC specification Table 4-1
+ *               as represented in &struct drm_dsc_picture_parameter_set
+ */
+struct drm_dsc_pps_infoframe {
+	struct dp_sdp_header pps_header;
+	struct drm_dsc_picture_parameter_set pps_payload;
+} __packed;
+
+#endif /* _DRM_DSC_H_ */
diff --git a/include/drm/display/drm_dsc_helper.h b/include/drm/display/drm_dsc_helper.h
new file mode 100644
index 000000000000..8b41edbbabab
--- /dev/null
+++ b/include/drm/display/drm_dsc_helper.h
@@ -0,0 +1,20 @@
+/* SPDX-License-Identifier: MIT
+ * Copyright (C) 2018 Intel Corp.
+ *
+ * Authors:
+ * Manasi Navare <manasi.d.navare@intel.com>
+ */
+
+#ifndef DRM_DSC_HELPER_H_
+#define DRM_DSC_HELPER_H_
+
+#include <drm/display/drm_dsc.h>
+
+void drm_dsc_dp_pps_header_init(struct dp_sdp_header *pps_header);
+int drm_dsc_dp_rc_buffer_size(u8 rc_buffer_block_size, u8 rc_buffer_size);
+void drm_dsc_pps_payload_pack(struct drm_dsc_picture_parameter_set *pps_sdp,
+			      const struct drm_dsc_config *dsc_cfg);
+int drm_dsc_compute_rc_parameters(struct drm_dsc_config *vdsc_cfg);
+
+#endif /* _DRM_DSC_HELPER_H_ */
+
diff --git a/include/drm/drm_dsc.h b/include/drm/drm_dsc.h
deleted file mode 100644
index 84e3d11cc1bb..000000000000
--- a/include/drm/drm_dsc.h
+++ /dev/null
@@ -1,611 +0,0 @@
-/* SPDX-License-Identifier: MIT
- * Copyright (C) 2018 Intel Corp.
- *
- * Authors:
- * Manasi Navare <manasi.d.navare@intel.com>
- */
-
-#ifndef DRM_DSC_H_
-#define DRM_DSC_H_
-
-#include <drm/display/drm_dp_helper.h>
-
-/* VESA Display Stream Compression DSC 1.2 constants */
-#define DSC_NUM_BUF_RANGES			15
-#define DSC_MUX_WORD_SIZE_8_10_BPC		48
-#define DSC_MUX_WORD_SIZE_12_BPC		64
-#define DSC_RC_PIXELS_PER_GROUP			3
-#define DSC_SCALE_DECREMENT_INTERVAL_MAX	4095
-#define DSC_RANGE_BPG_OFFSET_MASK		0x3f
-
-/* DSC Rate Control Constants */
-#define DSC_RC_MODEL_SIZE_CONST		    8192
-#define DSC_RC_EDGE_FACTOR_CONST	    6
-#define DSC_RC_TGT_OFFSET_HI_CONST	    3
-#define DSC_RC_TGT_OFFSET_LO_CONST	    3
-
-/* DSC PPS constants and macros */
-#define DSC_PPS_VERSION_MAJOR_SHIFT		4
-#define DSC_PPS_BPC_SHIFT			4
-#define DSC_PPS_MSB_SHIFT			8
-#define DSC_PPS_LSB_MASK			(0xFF << 0)
-#define DSC_PPS_BPP_HIGH_MASK			(0x3 << 8)
-#define DSC_PPS_VBR_EN_SHIFT			2
-#define DSC_PPS_SIMPLE422_SHIFT			3
-#define DSC_PPS_CONVERT_RGB_SHIFT		4
-#define DSC_PPS_BLOCK_PRED_EN_SHIFT		5
-#define DSC_PPS_INIT_XMIT_DELAY_HIGH_MASK	(0x3 << 8)
-#define DSC_PPS_SCALE_DEC_INT_HIGH_MASK		(0xF << 8)
-#define DSC_PPS_RC_TGT_OFFSET_HI_SHIFT		4
-#define DSC_PPS_RC_RANGE_MINQP_SHIFT		11
-#define DSC_PPS_RC_RANGE_MAXQP_SHIFT		6
-#define DSC_PPS_NATIVE_420_SHIFT		1
-#define DSC_1_2_MAX_LINEBUF_DEPTH_BITS		16
-#define DSC_1_2_MAX_LINEBUF_DEPTH_VAL		0
-#define DSC_1_1_MAX_LINEBUF_DEPTH_BITS		13
-
-/**
- * struct drm_dsc_rc_range_parameters - DSC Rate Control range parameters
- *
- * This defines different rate control parameters used by the DSC engine
- * to compress the frame.
- */
-struct drm_dsc_rc_range_parameters {
-	/**
-	 * @range_min_qp: Min Quantization Parameters allowed for this range
-	 */
-	u8 range_min_qp;
-	/**
-	 * @range_max_qp: Max Quantization Parameters allowed for this range
-	 */
-	u8 range_max_qp;
-	/**
-	 * @range_bpg_offset:
-	 * Bits/group offset to apply to target for this group
-	 */
-	u8 range_bpg_offset;
-};
-
-/**
- * struct drm_dsc_config - Parameters required to configure DSC
- *
- * Driver populates this structure with all the parameters required
- * to configure the display stream compression on the source.
- */
-struct drm_dsc_config {
-	/**
-	 * @line_buf_depth:
-	 * Bits per component for previous reconstructed line buffer
-	 */
-	u8 line_buf_depth;
-	/**
-	 * @bits_per_component: Bits per component to code (8/10/12)
-	 */
-	u8 bits_per_component;
-	/**
-	 * @convert_rgb:
-	 * Flag to indicate if RGB - YCoCg conversion is needed
-	 * True if RGB input, False if YCoCg input
-	 */
-	bool convert_rgb;
-	/**
-	 * @slice_count: Number fo slices per line used by the DSC encoder
-	 */
-	u8 slice_count;
-	/**
-	 *  @slice_width: Width of each slice in pixels
-	 */
-	u16 slice_width;
-	/**
-	 * @slice_height: Slice height in pixels
-	 */
-	u16 slice_height;
-	/**
-	 * @simple_422: True if simple 4_2_2 mode is enabled else False
-	 */
-	bool simple_422;
-	/**
-	 * @pic_width: Width of the input display frame in pixels
-	 */
-	u16 pic_width;
-	/**
-	 * @pic_height: Vertical height of the input display frame
-	 */
-	u16 pic_height;
-	/**
-	 * @rc_tgt_offset_high:
-	 * Offset to bits/group used by RC to determine QP adjustment
-	 */
-	u8 rc_tgt_offset_high;
-	/**
-	 * @rc_tgt_offset_low:
-	 * Offset to bits/group used by RC to determine QP adjustment
-	 */
-	u8 rc_tgt_offset_low;
-	/**
-	 * @bits_per_pixel:
-	 * Target bits per pixel with 4 fractional bits, bits_per_pixel << 4
-	 */
-	u16 bits_per_pixel;
-	/**
-	 * @rc_edge_factor:
-	 * Factor to determine if an edge is present based on the bits produced
-	 */
-	u8 rc_edge_factor;
-	/**
-	 * @rc_quant_incr_limit1:
-	 * Slow down incrementing once the range reaches this value
-	 */
-	u8 rc_quant_incr_limit1;
-	/**
-	 * @rc_quant_incr_limit0:
-	 * Slow down incrementing once the range reaches this value
-	 */
-	u8 rc_quant_incr_limit0;
-	/**
-	 * @initial_xmit_delay:
-	 * Number of pixels to delay the initial transmission
-	 */
-	u16 initial_xmit_delay;
-	/**
-	 * @initial_dec_delay:
-	 * Initial decoder delay, number of pixel times that the decoder
-	 * accumulates data in its rate buffer before starting to decode
-	 * and output pixels.
-	 */
-	u16  initial_dec_delay;
-	/**
-	 * @block_pred_enable:
-	 * True if block prediction is used to code any groups within the
-	 * picture. False if BP not used
-	 */
-	bool block_pred_enable;
-	/**
-	 * @first_line_bpg_offset:
-	 * Number of additional bits allocated for each group on the first
-	 * line of slice.
-	 */
-	u8 first_line_bpg_offset;
-	/**
-	 * @initial_offset: Value to use for RC model offset at slice start
-	 */
-	u16 initial_offset;
-	/**
-	 * @rc_buf_thresh: Thresholds defining each of the buffer ranges
-	 */
-	u16 rc_buf_thresh[DSC_NUM_BUF_RANGES - 1];
-	/**
-	 * @rc_range_params:
-	 * Parameters for each of the RC ranges defined in
-	 * &struct drm_dsc_rc_range_parameters
-	 */
-	struct drm_dsc_rc_range_parameters rc_range_params[DSC_NUM_BUF_RANGES];
-	/**
-	 * @rc_model_size: Total size of RC model
-	 */
-	u16 rc_model_size;
-	/**
-	 * @flatness_min_qp: Minimum QP where flatness information is sent
-	 */
-	u8 flatness_min_qp;
-	/**
-	 * @flatness_max_qp: Maximum QP where flatness information is sent
-	 */
-	u8 flatness_max_qp;
-	/**
-	 * @initial_scale_value: Initial value for the scale factor
-	 */
-	u8 initial_scale_value;
-	/**
-	 * @scale_decrement_interval:
-	 * Specifies number of group times between decrementing the scale factor
-	 * at beginning of a slice.
-	 */
-	u16 scale_decrement_interval;
-	/**
-	 * @scale_increment_interval:
-	 * Number of group times between incrementing the scale factor value
-	 * used at the beginning of a slice.
-	 */
-	u16 scale_increment_interval;
-	/**
-	 * @nfl_bpg_offset: Non first line BPG offset to be used
-	 */
-	u16 nfl_bpg_offset;
-	/**
-	 * @slice_bpg_offset: BPG offset used to enforce slice bit
-	 */
-	u16 slice_bpg_offset;
-	/**
-	 * @final_offset: Final RC linear transformation offset value
-	 */
-	u16 final_offset;
-	/**
-	 * @vbr_enable: True if VBR mode is enabled, false if disabled
-	 */
-	bool vbr_enable;
-	/**
-	 * @mux_word_size: Mux word size (in bits) for SSM mode
-	 */
-	u8 mux_word_size;
-	/**
-	 * @slice_chunk_size:
-	 * The (max) size in bytes of the "chunks" that are used in slice
-	 * multiplexing.
-	 */
-	u16 slice_chunk_size;
-	/**
-	 * @rc_bits: Rate control buffer size in bits
-	 */
-	u16 rc_bits;
-	/**
-	 * @dsc_version_minor: DSC minor version
-	 */
-	u8 dsc_version_minor;
-	/**
-	 * @dsc_version_major: DSC major version
-	 */
-	u8 dsc_version_major;
-	/**
-	 * @native_422: True if Native 4:2:2 supported, else false
-	 */
-	bool native_422;
-	/**
-	 * @native_420: True if Native 4:2:0 supported else false.
-	 */
-	bool native_420;
-	/**
-	 * @second_line_bpg_offset:
-	 * Additional bits/grp for seconnd line of slice for native 4:2:0
-	 */
-	u8 second_line_bpg_offset;
-	/**
-	 * @nsl_bpg_offset:
-	 * Num of bits deallocated for each grp that is not in second line of
-	 * slice
-	 */
-	u16 nsl_bpg_offset;
-	/**
-	 * @second_line_offset_adj:
-	 * Offset adjustment for second line in Native 4:2:0 mode
-	 */
-	u16 second_line_offset_adj;
-};
-
-/**
- * struct drm_dsc_picture_parameter_set - Represents 128 bytes of
- * 	Picture Parameter Set
- *
- * The VESA DSC standard defines picture parameter set (PPS) which display
- * stream compression encoders must communicate to decoders.
- * The PPS is encapsulated in 128 bytes (PPS 0 through PPS 127). The fields in
- * this structure are as per Table 4.1 in Vesa DSC specification v1.1/v1.2.
- * The PPS fields that span over more than a byte should be stored in Big Endian
- * format.
- */
-struct drm_dsc_picture_parameter_set {
-	/**
-	 * @dsc_version:
-	 * PPS0[3:0] - dsc_version_minor: Contains Minor version of DSC
-	 * PPS0[7:4] - dsc_version_major: Contains major version of DSC
-	 */
-	u8 dsc_version;
-	/**
-	 * @pps_identifier:
-	 * PPS1[7:0] - Application specific identifier that can be
-	 * used to differentiate between different PPS tables.
-	 */
-	u8 pps_identifier;
-	/**
-	 * @pps_reserved:
-	 * PPS2[7:0]- RESERVED Byte
-	 */
-	u8 pps_reserved;
-	/**
-	 * @pps_3:
-	 * PPS3[3:0] - linebuf_depth: Contains linebuffer bit depth used to
-	 * generate the bitstream. (0x0 - 16 bits for DSC 1.2, 0x8 - 8 bits,
-	 * 0xA - 10 bits, 0xB - 11 bits, 0xC - 12 bits, 0xD - 13 bits,
-	 * 0xE - 14 bits for DSC1.2, 0xF - 14 bits for DSC 1.2.
-	 * PPS3[7:4] - bits_per_component: Bits per component for the original
-	 * pixels of the encoded picture.
-	 * 0x0 = 16bpc (allowed only when dsc_version_minor = 0x2)
-	 * 0x8 = 8bpc, 0xA = 10bpc, 0xC = 12bpc, 0xE = 14bpc (also
-	 * allowed only when dsc_minor_version = 0x2)
-	 */
-	u8 pps_3;
-	/**
-	 * @pps_4:
-	 * PPS4[1:0] -These are the most significant 2 bits of
-	 * compressed BPP bits_per_pixel[9:0] syntax element.
-	 * PPS4[2] - vbr_enable: 0 = VBR disabled, 1 = VBR enabled
-	 * PPS4[3] - simple_422: Indicates if decoder drops samples to
-	 * reconstruct the 4:2:2 picture.
-	 * PPS4[4] - Convert_rgb: Indicates if DSC color space conversion is
-	 * active.
-	 * PPS4[5] - blobk_pred_enable: Indicates if BP is used to code any
-	 * groups in picture
-	 * PPS4[7:6] - Reseved bits
-	 */
-	u8 pps_4;
-	/**
-	 * @bits_per_pixel_low:
-	 * PPS5[7:0] - This indicates the lower significant 8 bits of
-	 * the compressed BPP bits_per_pixel[9:0] element.
-	 */
-	u8 bits_per_pixel_low;
-	/**
-	 * @pic_height:
-	 * PPS6[7:0], PPS7[7:0] -pic_height: Specifies the number of pixel rows
-	 * within the raster.
-	 */
-	__be16 pic_height;
-	/**
-	 * @pic_width:
-	 * PPS8[7:0], PPS9[7:0] - pic_width: Number of pixel columns within
-	 * the raster.
-	 */
-	__be16 pic_width;
-	/**
-	 * @slice_height:
-	 * PPS10[7:0], PPS11[7:0] - Slice height in units of pixels.
-	 */
-	__be16 slice_height;
-	/**
-	 * @slice_width:
-	 * PPS12[7:0], PPS13[7:0] - Slice width in terms of pixels.
-	 */
-	__be16 slice_width;
-	/**
-	 * @chunk_size:
-	 * PPS14[7:0], PPS15[7:0] - Size in units of bytes of the chunks
-	 * that are used for slice multiplexing.
-	 */
-	__be16 chunk_size;
-	/**
-	 * @initial_xmit_delay_high:
-	 * PPS16[1:0] - Most Significant two bits of initial transmission delay.
-	 * It specifies the number of pixel times that the encoder waits before
-	 * transmitting data from its rate buffer.
-	 * PPS16[7:2] - Reserved
-	 */
-	u8 initial_xmit_delay_high;
-	/**
-	 * @initial_xmit_delay_low:
-	 * PPS17[7:0] - Least significant 8 bits of initial transmission delay.
-	 */
-	u8 initial_xmit_delay_low;
-	/**
-	 * @initial_dec_delay:
-	 *
-	 * PPS18[7:0], PPS19[7:0] - Initial decoding delay which is the number
-	 * of pixel times that the decoder accumulates data in its rate buffer
-	 * before starting to decode and output pixels.
-	 */
-	__be16 initial_dec_delay;
-	/**
-	 * @pps20_reserved:
-	 *
-	 * PPS20[7:0] - Reserved
-	 */
-	u8 pps20_reserved;
-	/**
-	 * @initial_scale_value:
-	 * PPS21[5:0] - Initial rcXformScale factor used at beginning
-	 * of a slice.
-	 * PPS21[7:6] - Reserved
-	 */
-	u8 initial_scale_value;
-	/**
-	 * @scale_increment_interval:
-	 * PPS22[7:0], PPS23[7:0] - Number of group times between incrementing
-	 * the rcXformScale factor at end of a slice.
-	 */
-	__be16 scale_increment_interval;
-	/**
-	 * @scale_decrement_interval_high:
-	 * PPS24[3:0] - Higher 4 bits indicating number of group times between
-	 * decrementing the rcXformScale factor at beginning of a slice.
-	 * PPS24[7:4] - Reserved
-	 */
-	u8 scale_decrement_interval_high;
-	/**
-	 * @scale_decrement_interval_low:
-	 * PPS25[7:0] - Lower 8 bits of scale decrement interval
-	 */
-	u8 scale_decrement_interval_low;
-	/**
-	 * @pps26_reserved:
-	 * PPS26[7:0]
-	 */
-	u8 pps26_reserved;
-	/**
-	 * @first_line_bpg_offset:
-	 * PPS27[4:0] - Number of additional bits that are allocated
-	 * for each group on first line of a slice.
-	 * PPS27[7:5] - Reserved
-	 */
-	u8 first_line_bpg_offset;
-	/**
-	 * @nfl_bpg_offset:
-	 * PPS28[7:0], PPS29[7:0] - Number of bits including frac bits
-	 * deallocated for each group for groups after the first line of slice.
-	 */
-	__be16 nfl_bpg_offset;
-	/**
-	 * @slice_bpg_offset:
-	 * PPS30, PPS31[7:0] - Number of bits that are deallocated for each
-	 * group to enforce the slice constraint.
-	 */
-	__be16 slice_bpg_offset;
-	/**
-	 * @initial_offset:
-	 * PPS32,33[7:0] - Initial value for rcXformOffset
-	 */
-	__be16 initial_offset;
-	/**
-	 * @final_offset:
-	 * PPS34,35[7:0] - Maximum end-of-slice value for rcXformOffset
-	 */
-	__be16 final_offset;
-	/**
-	 * @flatness_min_qp:
-	 * PPS36[4:0] - Minimum QP at which flatness is signaled and
-	 * flatness QP adjustment is made.
-	 * PPS36[7:5] - Reserved
-	 */
-	u8 flatness_min_qp;
-	/**
-	 * @flatness_max_qp:
-	 * PPS37[4:0] - Max QP at which flatness is signalled and
-	 * the flatness adjustment is made.
-	 * PPS37[7:5] - Reserved
-	 */
-	u8 flatness_max_qp;
-	/**
-	 * @rc_model_size:
-	 * PPS38,39[7:0] - Number of bits within RC Model.
-	 */
-	__be16 rc_model_size;
-	/**
-	 * @rc_edge_factor:
-	 * PPS40[3:0] - Ratio of current activity vs, previous
-	 * activity to determine presence of edge.
-	 * PPS40[7:4] - Reserved
-	 */
-	u8 rc_edge_factor;
-	/**
-	 * @rc_quant_incr_limit0:
-	 * PPS41[4:0] - QP threshold used in short term RC
-	 * PPS41[7:5] - Reserved
-	 */
-	u8 rc_quant_incr_limit0;
-	/**
-	 * @rc_quant_incr_limit1:
-	 * PPS42[4:0] - QP threshold used in short term RC
-	 * PPS42[7:5] - Reserved
-	 */
-	u8 rc_quant_incr_limit1;
-	/**
-	 * @rc_tgt_offset:
-	 * PPS43[3:0] - Lower end of the variability range around the target
-	 * bits per group that is allowed by short term RC.
-	 * PPS43[7:4]- Upper end of the variability range around the target
-	 * bits per group that i allowed by short term rc.
-	 */
-	u8 rc_tgt_offset;
-	/**
-	 * @rc_buf_thresh:
-	 * PPS44[7:0] - PPS57[7:0] - Specifies the thresholds in RC model for
-	 * the 15 ranges defined by 14 thresholds.
-	 */
-	u8 rc_buf_thresh[DSC_NUM_BUF_RANGES - 1];
-	/**
-	 * @rc_range_parameters:
-	 * PPS58[7:0] - PPS87[7:0]
-	 * Parameters that correspond to each of the 15 ranges.
-	 */
-	__be16 rc_range_parameters[DSC_NUM_BUF_RANGES];
-	/**
-	 * @native_422_420:
-	 * PPS88[0] - 0 = Native 4:2:2 not used
-	 * 1 = Native 4:2:2 used
-	 * PPS88[1] - 0 = Native 4:2:0 not use
-	 * 1 = Native 4:2:0 used
-	 * PPS88[7:2] - Reserved 6 bits
-	 */
-	u8 native_422_420;
-	/**
-	 * @second_line_bpg_offset:
-	 * PPS89[4:0] - Additional bits/group budget for the
-	 * second line of a slice in Native 4:2:0 mode.
-	 * Set to 0 if DSC minor version is 1 or native420 is 0.
-	 * PPS89[7:5] - Reserved
-	 */
-	u8 second_line_bpg_offset;
-	/**
-	 * @nsl_bpg_offset:
-	 * PPS90[7:0], PPS91[7:0] - Number of bits that are deallocated
-	 * for each group that is not in the second line of a slice.
-	 */
-	__be16 nsl_bpg_offset;
-	/**
-	 * @second_line_offset_adj:
-	 * PPS92[7:0], PPS93[7:0] - Used as offset adjustment for the second
-	 * line in Native 4:2:0 mode.
-	 */
-	__be16 second_line_offset_adj;
-	/**
-	 * @pps_long_94_reserved:
-	 * PPS 94, 95, 96, 97 - Reserved
-	 */
-	u32 pps_long_94_reserved;
-	/**
-	 * @pps_long_98_reserved:
-	 * PPS 98, 99, 100, 101 - Reserved
-	 */
-	u32 pps_long_98_reserved;
-	/**
-	 * @pps_long_102_reserved:
-	 * PPS 102, 103, 104, 105 - Reserved
-	 */
-	u32 pps_long_102_reserved;
-	/**
-	 * @pps_long_106_reserved:
-	 * PPS 106, 107, 108, 109 - reserved
-	 */
-	u32 pps_long_106_reserved;
-	/**
-	 * @pps_long_110_reserved:
-	 * PPS 110, 111, 112, 113 - reserved
-	 */
-	u32 pps_long_110_reserved;
-	/**
-	 * @pps_long_114_reserved:
-	 * PPS 114 - 117 - reserved
-	 */
-	u32 pps_long_114_reserved;
-	/**
-	 * @pps_long_118_reserved:
-	 * PPS 118 - 121 - reserved
-	 */
-	u32 pps_long_118_reserved;
-	/**
-	 * @pps_long_122_reserved:
-	 * PPS 122- 125 - reserved
-	 */
-	u32 pps_long_122_reserved;
-	/**
-	 * @pps_short_126_reserved:
-	 * PPS 126, 127 - reserved
-	 */
-	__be16 pps_short_126_reserved;
-} __packed;
-
-/**
- * struct drm_dsc_pps_infoframe - DSC infoframe carrying the Picture Parameter
- * Set Metadata
- *
- * This structure represents the DSC PPS infoframe required to send the Picture
- * Parameter Set metadata required before enabling VESA Display Stream
- * Compression. This is based on the DP Secondary Data Packet structure and
- * comprises of SDP Header as defined &struct dp_sdp_header in drm_dp_helper.h
- * and PPS payload defined in &struct drm_dsc_picture_parameter_set.
- *
- * @pps_header: Header for PPS as per DP SDP header format of type
- *              &struct dp_sdp_header
- * @pps_payload: PPS payload fields as per DSC specification Table 4-1
- *               as represented in &struct drm_dsc_picture_parameter_set
- */
-struct drm_dsc_pps_infoframe {
-	struct dp_sdp_header pps_header;
-	struct drm_dsc_picture_parameter_set pps_payload;
-} __packed;
-
-void drm_dsc_dp_pps_header_init(struct dp_sdp_header *pps_header);
-int drm_dsc_dp_rc_buffer_size(u8 rc_buffer_block_size, u8 rc_buffer_size);
-void drm_dsc_pps_payload_pack(struct drm_dsc_picture_parameter_set *pps_sdp,
-				const struct drm_dsc_config *dsc_cfg);
-int drm_dsc_compute_rc_parameters(struct drm_dsc_config *vdsc_cfg);
-
-#endif /* _DRM_DSC_H_ */
-- 
2.38.1


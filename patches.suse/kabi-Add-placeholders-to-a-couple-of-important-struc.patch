From 33b3ab6631ded858f811d6f5f6d7af4ac15dbc65 Mon Sep 17 00:00:00 2001
From: Michal Marek <mmarek@suse.cz>
Date: Fri, 16 Sep 2011 11:56:20 +0200
Subject: [PATCH 3/3] kabi: Add placeholders to a couple of important
 structures
Patch-mainline: Never, kabi
References: fate#312013

Add a void* suse_kabi_padding placeholder to the following structures:
struct smp_ops
struct vm_area_struct
struct mm_struct
struct zone
  - adding an explicit padding here is not strictly required, but can
    serve as documentation that there is some space
struct vfsmount
struct device
struct bus_type
struct class
struct device_driver
struct module
struct signal_struct
struct sched_rt_entity
struct sock
struct task_struct

The idea is that when a fix appears that requires a new member in any of
these structures, we use this padding:

  #ifdef __GENKSYMS__
          void *suse_kabi_padding;
  #else
          long foo;
  #endif

And we don't have to worry about changing size of the structure, as long
as the new member is a pointer or a long.

Signed-off-by: Michal Marek <mmarek@suse.cz>

---
 arch/x86/include/asm/mmu.h    |    1 +
 arch/x86/include/asm/smp.h    |    1 +
 include/linux/device.h        |    1 +
 include/linux/device/bus.h    |    2 ++
 include/linux/device/class.h  |    2 ++
 include/linux/device/driver.h |    2 ++
 include/linux/mm_types.h      |    2 ++
 include/linux/mmzone.h        |    2 ++
 include/linux/module.h        |    1 +
 include/linux/mount.h         |    1 +
 include/linux/sched.h         |    3 +++
 include/linux/sched/signal.h  |    1 +
 include/net/sock.h            |    1 +
 13 files changed, 20 insertions(+)

--- a/arch/x86/include/asm/mmu.h
+++ b/arch/x86/include/asm/mmu.h
@@ -67,6 +67,7 @@ typedef struct {
 	u16 pkey_allocation_map;
 	s16 execute_only_pkey;
 #endif
+	void *suse_kabi_padding;
 } mm_context_t;
 
 #define INIT_MM_CONTEXT(mm)						\
--- a/arch/x86/include/asm/smp.h
+++ b/arch/x86/include/asm/smp.h
@@ -45,6 +45,7 @@ struct smp_ops {
 
 	void (*send_call_func_ipi)(const struct cpumask *mask);
 	void (*send_call_func_single_ipi)(int cpu);
+	void *suse_kabi_padding;
 };
 
 /* Globals due to paravirt */
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@ -656,6 +656,7 @@ struct device {
 #ifdef CONFIG_DMA_OPS_BYPASS
 	bool			dma_ops_bypass : 1;
 #endif
+	void			*suse_kabi_padding;
 };
 
 /**
--- a/include/linux/device/bus.h
+++ b/include/linux/device/bus.h
@@ -107,6 +107,8 @@ struct bus_type {
 	const struct iommu_ops *iommu_ops;
 
 	bool need_parent_lock;
+
+	void *suse_kabi_padding;
 };
 
 int __must_check bus_register(const struct bus_type *bus);
--- a/include/linux/device/class.h
+++ b/include/linux/device/class.h
@@ -69,6 +69,8 @@ struct class {
 	void (*get_ownership)(const struct device *dev, kuid_t *uid, kgid_t *gid);
 
 	const struct dev_pm_ops *pm;
+
+	void *suse_kabi_padding;
 };
 
 struct class_dev_iter {
--- a/include/linux/device/driver.h
+++ b/include/linux/device/driver.h
@@ -119,6 +119,8 @@ struct device_driver {
 	void (*coredump) (struct device *dev);
 
 	struct driver_private *p;
+
+	void *suse_kabi_padding;
 };
 
 
--- a/include/linux/mm_types.h
+++ b/include/linux/mm_types.h
@@ -601,6 +601,7 @@ struct vm_area_struct {
 	struct vma_numab_state *numab_state;	/* NUMA Balancing state */
 #endif
 	struct vm_userfaultfd_ctx vm_userfaultfd_ctx;
+	void *suse_kabi_padding;
 } __randomize_layout;
 
 #ifdef CONFIG_SCHED_MM_CID
@@ -853,6 +854,7 @@ struct mm_struct {
 #endif
 		} lru_gen;
 #endif /* CONFIG_LRU_GEN */
+		void *suse_kabi_padding;
 	} __randomize_layout;
 
 	/*
--- a/include/linux/mmzone.h
+++ b/include/linux/mmzone.h
@@ -966,6 +966,7 @@ struct zone {
 	/* Zone statistics */
 	atomic_long_t		vm_stat[NR_VM_ZONE_STAT_ITEMS];
 	atomic_long_t		vm_numa_event[NR_VM_NUMA_EVENT_ITEMS];
+	void *suse_kabi_padding;
 } ____cacheline_internodealigned_in_smp;
 
 enum pgdat_flags {
@@ -1379,6 +1380,7 @@ typedef struct pglist_data {
 #ifdef CONFIG_MEMORY_FAILURE
 	struct memory_failure_stats mf_stats;
 #endif
+	void *suse_kabi_padding;
 } pg_data_t;
 
 #define node_present_pages(nid)	(NODE_DATA(nid)->node_present_pages)
--- a/include/linux/module.h
+++ b/include/linux/module.h
@@ -583,6 +583,7 @@ struct module {
 #ifdef CONFIG_DYNAMIC_DEBUG_CORE
 	struct _ddebug_info dyndbg_info;
 #endif
+	void *suse_kabi_padding;
 } ____cacheline_aligned __randomize_layout;
 #ifndef MODULE_ARCH_INIT
 #define MODULE_ARCH_INIT {}
--- a/include/linux/mount.h
+++ b/include/linux/mount.h
@@ -72,6 +72,7 @@ struct vfsmount {
 	struct super_block *mnt_sb;	/* pointer to superblock */
 	int mnt_flags;
 	struct mnt_idmap *mnt_idmap;
+	void *suse_kabi_padding;
 } __randomize_layout;
 
 static inline struct mnt_idmap *mnt_idmap(const struct vfsmount *mnt)
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -597,6 +597,7 @@ struct sched_rt_entity {
 	/* rq "owned" by this entity/group: */
 	struct rt_rq			*my_q;
 #endif
+	void *suse_kabi_padding;
 } __randomize_layout;
 
 struct sched_dl_entity {
@@ -1532,6 +1533,8 @@ struct task_struct {
 	struct user_event_mm		*user_event_mm;
 #endif
 
+	void				*suse_kabi_padding;
+
 	/*
 	 * New fields for task_struct should be added above here, so that
 	 * they are included in the randomized portion of task_struct.
--- a/include/linux/sched/signal.h
+++ b/include/linux/sched/signal.h
@@ -245,6 +245,7 @@ struct signal_struct {
 						 * and may have inconsistent
 						 * permissions.
 						 */
+	void *suse_kabi_padding;
 } __randomize_layout;
 
 /*
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@ -538,6 +538,7 @@ struct sock {
 							struct sk_buff *skb);
 #endif
 	void                    (*sk_destruct)(struct sock *sk);
+	void			*suse_kabi_padding;
 	struct sock_reuseport __rcu	*sk_reuseport_cb;
 #ifdef CONFIG_BPF_SYSCALL
 	struct bpf_local_storage __rcu	*sk_bpf_storage;

From 0b226322434c7786381d7a594efca9cc46f85211 Mon Sep 17 00:00:00 2001
From: David Galiffi <david.galiffi@amd.com>
Date: Mon, 24 Jun 2019 10:34:13 -0400
Subject: drm/amd/display: Synchronous DisplayPort Link Training
Git-commit: 0b226322434c7786381d7a594efca9cc46f85211
Patch-mainline: v5.4-rc1
References: bsc#1152489

[WHY]
We require a method to perform synchronous link training.

[HOW]
Sync LT is broken into 3 basic steps.
"Begin" starts the state machine, and resets "preferred" link settings.
"Attempt" will attempt to train the link with a given set of training
parameters.
"End" stops the state machine, and will optionally disable the link phy.
Between "Begin" and "End" DPCD:600h must not be set to "2"
(D3:Powered Down).
Between "Begin" and "End", there may be multiple "Attempts" with different
training parameters.

Signed-off-by: David Galiffi <david.galiffi@amd.com>
Reviewed-by: Jun Lei <Jun.Lei@amd.com>
Acked-by: Leo Li <sunpeng.li@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Acked-by: Thomas Zimmermann <tzimmermann@suse.de>
---
 drivers/gpu/drm/amd/display/dc/core/dc_link.c |  53 +---
 .../gpu/drm/amd/display/dc/core/dc_link_dp.c  | 293 ++++++++++++++++--
 .../drm/amd/display/dc/core/dc_link_hwss.c    |  43 +--
 drivers/gpu/drm/amd/display/dc/dc_dp_types.h  |   3 +
 drivers/gpu/drm/amd/display/dc/dc_link.h      |  10 +
 .../gpu/drm/amd/display/dc/inc/dc_link_dp.h   |   3 +
 .../gpu/drm/amd/display/dc/inc/link_hwss.h    |   2 -
 7 files changed, 282 insertions(+), 125 deletions(-)

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link.c b/drivers/gpu/drm/amd/display/dc/core/dc_link.c
index 193d6f14e684..0a66a6f21f58 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link.c
@@ -1387,57 +1387,6 @@ void link_destroy(struct dc_link **link)
 	*link = NULL;
 }
 
-static void dpcd_configure_panel_mode(
-	struct dc_link *link,
-	enum dp_panel_mode panel_mode)
-{
-	union dpcd_edp_config edp_config_set;
-	bool panel_mode_edp = false;
-	DC_LOGGER_INIT(link->ctx->logger);
-
-	memset(&edp_config_set, '\0', sizeof(union dpcd_edp_config));
-
-	if (DP_PANEL_MODE_DEFAULT != panel_mode) {
-
-		switch (panel_mode) {
-		case DP_PANEL_MODE_EDP:
-		case DP_PANEL_MODE_SPECIAL:
-			panel_mode_edp = true;
-			break;
-
-		default:
-			break;
-		}
-
-		/*set edp panel mode in receiver*/
-		core_link_read_dpcd(
-			link,
-			DP_EDP_CONFIGURATION_SET,
-			&edp_config_set.raw,
-			sizeof(edp_config_set.raw));
-
-		if (edp_config_set.bits.PANEL_MODE_EDP
-			!= panel_mode_edp) {
-			enum ddc_result result = DDC_RESULT_UNKNOWN;
-
-			edp_config_set.bits.PANEL_MODE_EDP =
-			panel_mode_edp;
-			result = core_link_write_dpcd(
-				link,
-				DP_EDP_CONFIGURATION_SET,
-				&edp_config_set.raw,
-				sizeof(edp_config_set.raw));
-
-			ASSERT(result == DDC_RESULT_SUCESSFULL);
-		}
-	}
-	DC_LOG_DETECTION_DP_CAPS("Link: %d eDP panel mode supported: %d "
-			"eDP panel mode enabled: %d \n",
-			link->link_index,
-			link->dpcd_caps.panel_mode_edp,
-			panel_mode_edp);
-}
-
 static void enable_stream_features(struct pipe_ctx *pipe_ctx)
 {
 	struct dc_stream_state *stream = pipe_ctx->stream;
@@ -1508,7 +1457,7 @@ static enum dc_status enable_link_dp(
 	}
 
 	panel_mode = dp_get_panel_mode(link);
-	dpcd_configure_panel_mode(link, panel_mode);
+	dp_set_panel_mode(link, panel_mode);
 
 	skip_video_pattern = true;
 
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
index 08bd9c96b9b0..8e66b2e9d6af 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
@@ -965,6 +965,7 @@ static inline enum link_training_result perform_link_training_int(
 static void initialize_training_settings(
 	 struct dc_link *link,
 	const struct dc_link_settings *link_setting,
+	const struct dc_link_training_overrides *overrides,
 	struct link_training_settings *lt_settings)
 {
 	uint32_t lane;
@@ -997,23 +998,23 @@ static void initialize_training_settings(
 	/* Initialize link spread */
 	if (link->dp_ss_off)
 		lt_settings->link_settings.link_spread = LINK_SPREAD_DISABLED;
-	else if (link->preferred_training_settings.downspread != NULL)
+	else if (overrides->downspread != NULL)
 		lt_settings->link_settings.link_spread
-			= *link->preferred_training_settings.downspread
+			= *overrides->downspread
 			? LINK_SPREAD_05_DOWNSPREAD_30KHZ
 			: LINK_SPREAD_DISABLED;
 	else
 		lt_settings->link_settings.link_spread = LINK_SPREAD_05_DOWNSPREAD_30KHZ;
 
 	/* Initialize lane settings overrides */
-	if (link->preferred_training_settings.voltage_swing != NULL)
-		lt_settings->voltage_swing = link->preferred_training_settings.voltage_swing;
+	if (overrides->voltage_swing != NULL)
+		lt_settings->voltage_swing = overrides->voltage_swing;
 
-	if (link->preferred_training_settings.pre_emphasis != NULL)
-		lt_settings->pre_emphasis = link->preferred_training_settings.pre_emphasis;
+	if (overrides->pre_emphasis != NULL)
+		lt_settings->pre_emphasis = overrides->pre_emphasis;
 
-	if (link->preferred_training_settings.post_cursor2 != NULL)
-		lt_settings->post_cursor2 = link->preferred_training_settings.post_cursor2;
+	if (overrides->post_cursor2 != NULL)
+		lt_settings->post_cursor2 = overrides->post_cursor2;
 
 	/* Initialize lane settings (VS/PE/PC2) */
 	for (lane = 0; lane < LANE_COUNT_DP_MAX; lane++) {
@@ -1032,23 +1033,23 @@ static void initialize_training_settings(
 	}
 
 	/* Initialize training timings */
-	if (link->preferred_training_settings.cr_pattern_time != NULL)
-		lt_settings->cr_pattern_time = *link->preferred_training_settings.cr_pattern_time;
+	if (overrides->cr_pattern_time != NULL)
+		lt_settings->cr_pattern_time = *overrides->cr_pattern_time;
 	else
-		lt_settings->cr_pattern_time = 100;
+		lt_settings->cr_pattern_time = get_training_aux_rd_interval(link, 100);
 
-	if (link->preferred_training_settings.eq_pattern_time != NULL)
-		lt_settings->eq_pattern_time = *link->preferred_training_settings.eq_pattern_time;
+	if (overrides->eq_pattern_time != NULL)
+		lt_settings->eq_pattern_time = *overrides->eq_pattern_time;
 	else
 		lt_settings->eq_pattern_time = get_training_aux_rd_interval(link, 400);
 
-	if (link->preferred_training_settings.pattern_for_eq != NULL)
-		lt_settings->pattern_for_eq = *link->preferred_training_settings.pattern_for_eq;
+	if (overrides->pattern_for_eq != NULL)
+		lt_settings->pattern_for_eq = *overrides->pattern_for_eq;
 	else
 		lt_settings->pattern_for_eq = get_supported_tp(link);
 
-	if (link->preferred_training_settings.enhanced_framing != NULL)
-		lt_settings->enhanced_framing = *link->preferred_training_settings.enhanced_framing;
+	if (overrides->enhanced_framing != NULL)
+		lt_settings->enhanced_framing = *overrides->enhanced_framing;
 	else
 		lt_settings->enhanced_framing = 1;
 }
@@ -1139,7 +1140,11 @@ bool dc_link_dp_perform_link_training_skip_aux(
 	struct link_training_settings lt_settings;
 	enum dc_dp_training_pattern pattern_for_cr = DP_TRAINING_PATTERN_SEQUENCE_1;
 
-	initialize_training_settings(link, link_setting, &lt_settings);
+	initialize_training_settings(
+			link,
+			link_setting,
+			&link->preferred_training_settings,
+			&lt_settings);
 
 	/* 1. Perform_clock_recovery_sequence. */
 
@@ -1184,7 +1189,11 @@ enum link_training_result dc_link_dp_perform_link_training(
 	bool fec_enable;
 #endif
 
-	initialize_training_settings(link, link_setting, &lt_settings);
+	initialize_training_settings(
+			link,
+			link_setting,
+			&link->preferred_training_settings,
+			&lt_settings);
 
 	/* 1. set link rate, lane count and spread. */
 	dpcd_set_link_settings(link, &lt_settings);
@@ -1247,6 +1256,146 @@ bool perform_link_training_with_retries(
 	return false;
 }
 
+static enum clock_source_id get_clock_source_id(struct dc_link *link)
+{
+	enum clock_source_id dp_cs_id = CLOCK_SOURCE_ID_UNDEFINED;
+	struct clock_source *dp_cs = link->dc->res_pool->dp_clock_source;
+
+	if (dp_cs != NULL) {
+		dp_cs_id = dp_cs->id;
+	} else {
+		/*
+		 * dp clock source is not initialized for some reason.
+		 * Should not happen, CLOCK_SOURCE_ID_EXTERNAL will be used
+		 */
+		ASSERT(dp_cs);
+	}
+
+	return dp_cs_id;
+}
+
+static void set_dp_mst_mode(struct dc_link *link, bool mst_enable)
+{
+	if (mst_enable == false &&
+		link->type == dc_connection_mst_branch) {
+		/* Disable MST on link. Use only local sink. */
+		dp_disable_link_phy_mst(link, link->connector_signal);
+
+		link->type = dc_connection_single;
+		link->local_sink = link->remote_sinks[0];
+		link->local_sink->sink_signal = SIGNAL_TYPE_DISPLAY_PORT;
+	} else if (mst_enable == true &&
+			link->type == dc_connection_single &&
+			link->remote_sinks[0] != NULL) {
+		/* Re-enable MST on link. */
+		dp_disable_link_phy(link, link->connector_signal);
+		dp_enable_mst_on_sink(link, true);
+
+		link->type = dc_connection_mst_branch;
+		link->local_sink->sink_signal = SIGNAL_TYPE_DISPLAY_PORT_MST;
+	}
+}
+
+bool dc_link_dp_sync_lt_begin(struct dc_link *link)
+{
+	/* Begin Sync LT. During this time,
+	 * DPCD:600h must not be powered down.
+	 */
+	link->sync_lt_in_progress = true;
+
+	/*Clear any existing preferred settings.*/
+	memset(&link->preferred_training_settings, 0,
+		sizeof(struct dc_link_training_overrides));
+	memset(&link->preferred_link_setting, 0,
+		sizeof(struct dc_link_settings));
+
+	return true;
+}
+
+enum link_training_result dc_link_dp_sync_lt_attempt(
+    struct dc_link *link,
+    struct dc_link_settings *link_settings,
+    struct dc_link_training_overrides *lt_overrides)
+{
+	struct link_training_settings lt_settings;
+	enum link_training_result lt_status = LINK_TRAINING_SUCCESS;
+	enum dp_panel_mode panel_mode = DP_PANEL_MODE_DEFAULT;
+	enum clock_source_id dp_cs_id = CLOCK_SOURCE_ID_EXTERNAL;
+#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
+	bool fec_enable = false;
+#endif
+
+	initialize_training_settings(
+		link,
+		link_settings,
+		lt_overrides,
+		&lt_settings);
+
+	/* Setup MST Mode */
+	if (lt_overrides->mst_enable)
+		set_dp_mst_mode(link, *lt_overrides->mst_enable);
+
+	/* Disable link */
+	dp_disable_link_phy(link, link->connector_signal);
+
+	/* Enable link */
+	dp_cs_id = get_clock_source_id(link);
+	dp_enable_link_phy(link, link->connector_signal,
+		dp_cs_id, link_settings);
+
+#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
+	/* Set FEC enable */
+	fec_enable = lt_overrides->fec_enable && *lt_overrides->fec_enable;
+	dp_set_fec_ready(link, fec_enable);
+#endif
+
+	if (lt_overrides->alternate_scrambler_reset) {
+		if (*lt_overrides->alternate_scrambler_reset)
+			panel_mode = DP_PANEL_MODE_EDP;
+		else
+			panel_mode = DP_PANEL_MODE_DEFAULT;
+	} else
+		panel_mode = dp_get_panel_mode(link);
+
+	dp_set_panel_mode(link, panel_mode);
+
+	/* Attempt to train with given link training settings */
+
+	/* Set link rate, lane count and spread. */
+	dpcd_set_link_settings(link, &lt_settings);
+
+	/* 2. perform link training (set link training done
+	 *  to false is done as well)
+	 */
+	lt_status = perform_clock_recovery_sequence(link, &lt_settings);
+	if (lt_status == LINK_TRAINING_SUCCESS) {
+		lt_status = perform_channel_equalization_sequence(link,
+						&lt_settings);
+	}
+
+	/* 3. Sync LT must skip TRAINING_PATTERN_SET:0 (video pattern)*/
+	/* 4. print status message*/
+	print_status_message(link, &lt_settings, lt_status);
+
+	return lt_status;
+}
+
+bool dc_link_dp_sync_lt_end(struct dc_link *link, bool link_down)
+{
+	/* If input parameter is set, shut down phy.
+	 * Still shouldn't turn off dp_receiver (DPCD:600h)
+	 */
+	if (link_down == true) {
+		dp_disable_link_phy(link, link->connector_signal);
+#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
+		dp_set_fec_ready(link, false);
+#endif
+	}
+
+	link->sync_lt_in_progress = false;
+	return true;
+}
+
 static struct dc_link_settings get_max_link_cap(struct dc_link *link)
 {
 	/* Set Default link settings */
@@ -1401,7 +1550,6 @@ bool dp_verify_link_cap(
 	bool success;
 	bool skip_link_training;
 	bool skip_video_pattern;
-	struct clock_source *dp_cs;
 	enum clock_source_id dp_cs_id = CLOCK_SOURCE_ID_EXTERNAL;
 	enum link_training_result status;
 	union hpd_irq_data irq_data;
@@ -1425,17 +1573,7 @@ bool dp_verify_link_cap(
 	/* disable PHY done possible by BIOS, will be done by driver itself */
 	dp_disable_link_phy(link, link->connector_signal);
 
-	dp_cs = link->dc->res_pool->dp_clock_source;
-
-	if (dp_cs)
-		dp_cs_id = dp_cs->id;
-	else {
-		/*
-		 * dp clock source is not initialized for some reason.
-		 * Should not happen, CLOCK_SOURCE_ID_EXTERNAL will be used
-		 */
-		ASSERT(dp_cs);
-	}
+	dp_cs_id = get_clock_source_id(link);
 
 	/* link training starts with the maximum common settings
 	 * supported by both sink and ASIC.
@@ -2307,6 +2445,11 @@ bool is_mst_supported(struct dc_link *link)
 	union dpcd_rev rev;
 	union mstm_cap cap;
 
+	if (link->preferred_training_settings.mst_enable &&
+		*link->preferred_training_settings.mst_enable == false) {
+		return false;
+	}
+
 	rev.raw  = 0;
 	cap.raw  = 0;
 
@@ -3158,6 +3301,94 @@ void dp_enable_mst_on_sink(struct dc_link *link, bool enable)
 	core_link_write_dpcd(link, DP_MSTM_CTRL, &mstmCntl, 1);
 }
 
+void dp_set_panel_mode(struct dc_link *link, enum dp_panel_mode panel_mode)
+{
+	union dpcd_edp_config edp_config_set;
+	bool panel_mode_edp = false;
+
+	memset(&edp_config_set, '\0', sizeof(union dpcd_edp_config));
+
+	if (panel_mode != DP_PANEL_MODE_DEFAULT) {
+
+		switch (panel_mode) {
+		case DP_PANEL_MODE_EDP:
+		case DP_PANEL_MODE_SPECIAL:
+			panel_mode_edp = true;
+			break;
+
+		default:
+				break;
+		}
+
+		/*set edp panel mode in receiver*/
+		core_link_read_dpcd(
+			link,
+			DP_EDP_CONFIGURATION_SET,
+			&edp_config_set.raw,
+			sizeof(edp_config_set.raw));
+
+		if (edp_config_set.bits.PANEL_MODE_EDP
+			!= panel_mode_edp) {
+			enum ddc_result result = DDC_RESULT_UNKNOWN;
+
+			edp_config_set.bits.PANEL_MODE_EDP =
+			panel_mode_edp;
+			result = core_link_write_dpcd(
+				link,
+				DP_EDP_CONFIGURATION_SET,
+				&edp_config_set.raw,
+				sizeof(edp_config_set.raw));
+
+			ASSERT(result == DDC_RESULT_SUCESSFULL);
+		}
+	}
+	DC_LOG_DETECTION_DP_CAPS("Link: %d eDP panel mode supported: %d "
+		 "eDP panel mode enabled: %d \n",
+		 link->link_index,
+		 link->dpcd_caps.panel_mode_edp,
+		 panel_mode_edp);
+}
+
+enum dp_panel_mode dp_get_panel_mode(struct dc_link *link)
+{
+	/* We need to explicitly check that connector
+	 * is not DP. Some Travis_VGA get reported
+	 * by video bios as DP.
+	 */
+	if (link->connector_signal != SIGNAL_TYPE_DISPLAY_PORT) {
+
+		switch (link->dpcd_caps.branch_dev_id) {
+		case DP_BRANCH_DEVICE_ID_2:
+			if (strncmp(
+				link->dpcd_caps.branch_dev_name,
+				DP_VGA_LVDS_CONVERTER_ID_2,
+				sizeof(
+				link->dpcd_caps.
+				branch_dev_name)) == 0) {
+					return DP_PANEL_MODE_SPECIAL;
+			}
+			break;
+		case DP_BRANCH_DEVICE_ID_3:
+			if (strncmp(link->dpcd_caps.branch_dev_name,
+				DP_VGA_LVDS_CONVERTER_ID_3,
+				sizeof(
+				link->dpcd_caps.
+				branch_dev_name)) == 0) {
+					return DP_PANEL_MODE_SPECIAL;
+			}
+			break;
+		default:
+			break;
+		}
+	}
+
+	if (link->dpcd_caps.panel_mode_edp) {
+		return DP_PANEL_MODE_EDP;
+	}
+
+	return DP_PANEL_MODE_DEFAULT;
+}
+
 #ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
 void dp_set_fec_ready(struct dc_link *link, bool ready)
 {
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 878f47b59d5a..daaff7319413 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -55,6 +55,9 @@ void dp_receiver_power_ctrl(struct dc_link *link, bool on)
 
 	state = on ? DP_POWER_STATE_D0 : DP_POWER_STATE_D3;
 
+	if (link->sync_lt_in_progress)
+		return;
+
 	core_link_write_dpcd(link, DP_SET_POWER, &state,
 			sizeof(state));
 }
@@ -245,46 +248,6 @@ void dp_set_hw_lane_settings(
 	encoder->funcs->dp_set_lane_settings(encoder, link_settings);
 }
 
-enum dp_panel_mode dp_get_panel_mode(struct dc_link *link)
-{
-	/* We need to explicitly check that connector
-	 * is not DP. Some Travis_VGA get reported
-	 * by video bios as DP.
-	 */
-	if (link->connector_signal != SIGNAL_TYPE_DISPLAY_PORT) {
-
-		switch (link->dpcd_caps.branch_dev_id) {
-		case DP_BRANCH_DEVICE_ID_2:
-			if (strncmp(
-				link->dpcd_caps.branch_dev_name,
-				DP_VGA_LVDS_CONVERTER_ID_2,
-				sizeof(
-				link->dpcd_caps.
-				branch_dev_name)) == 0) {
-				return DP_PANEL_MODE_SPECIAL;
-			}
-			break;
-		case DP_BRANCH_DEVICE_ID_3:
-			if (strncmp(link->dpcd_caps.branch_dev_name,
-				DP_VGA_LVDS_CONVERTER_ID_3,
-				sizeof(
-				link->dpcd_caps.
-				branch_dev_name)) == 0) {
-				return DP_PANEL_MODE_SPECIAL;
-			}
-			break;
-		default:
-			break;
-		}
-	}
-
-	if (link->dpcd_caps.panel_mode_edp) {
-		return DP_PANEL_MODE_EDP;
-	}
-
-	return DP_PANEL_MODE_DEFAULT;
-}
-
 void dp_set_hw_test_pattern(
 	struct dc_link *link,
 	enum dp_test_pattern test_pattern,
diff --git a/drivers/gpu/drm/amd/display/dc/dc_dp_types.h b/drivers/gpu/drm/amd/display/dc/dc_dp_types.h
index efa7a47f6b7e..ef79a686e4c2 100644
--- a/drivers/gpu/drm/amd/display/dc/dc_dp_types.h
+++ b/drivers/gpu/drm/amd/display/dc/dc_dp_types.h
@@ -128,7 +128,10 @@ struct dc_link_training_overrides {
 	enum dc_link_spread *downspread;
 	bool *alternate_scrambler_reset;
 	bool *enhanced_framing;
+	bool *mst_enable;
+#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
 	bool *fec_enable;
+#endif
 };
 
 union dpcd_rev {
diff --git a/drivers/gpu/drm/amd/display/dc/dc_link.h b/drivers/gpu/drm/amd/display/dc/dc_link.h
index d6ff5af70c71..9ea75db3484e 100644
--- a/drivers/gpu/drm/amd/display/dc/dc_link.h
+++ b/drivers/gpu/drm/amd/display/dc/dc_link.h
@@ -84,6 +84,7 @@ struct dc_link {
 	bool dp_ss_off;
 	bool link_state_valid;
 	bool aux_access_disabled;
+	bool sync_lt_in_progress;
 
 	/* caps is the same as reported_link_cap. link_traing use
 	 * reported_link_cap. Will clean up.  TODO
@@ -228,6 +229,15 @@ enum link_training_result dc_link_dp_perform_link_training(
 	const struct dc_link_settings *link_setting,
 	bool skip_video_pattern);
 
+bool dc_link_dp_sync_lt_begin(struct dc_link *link);
+
+enum link_training_result dc_link_dp_sync_lt_attempt(
+	struct dc_link *link,
+	struct dc_link_settings *link_setting,
+	struct dc_link_training_overrides *lt_settings);
+
+bool dc_link_dp_sync_lt_end(struct dc_link *link, bool link_down);
+
 void dc_link_dp_enable_hpd(const struct dc_link *link);
 
 void dc_link_dp_disable_hpd(const struct dc_link *link);
diff --git a/drivers/gpu/drm/amd/display/dc/inc/dc_link_dp.h b/drivers/gpu/drm/amd/display/dc/inc/dc_link_dp.h
index c5293f9508fa..2ef23963e1f7 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/dc_link_dp.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/dc_link_dp.h
@@ -62,6 +62,9 @@ bool is_dp_active_dongle(const struct dc_link *link);
 
 void dp_enable_mst_on_sink(struct dc_link *link, bool enable);
 
+enum dp_panel_mode dp_get_panel_mode(struct dc_link *link);
+void dp_set_panel_mode(struct dc_link *link, enum dp_panel_mode panel_mode);
+
 #ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
 void dp_set_fec_ready(struct dc_link *link, bool ready);
 void dp_set_fec_enable(struct dc_link *link, bool enable);
diff --git a/drivers/gpu/drm/amd/display/dc/inc/link_hwss.h b/drivers/gpu/drm/amd/display/dc/inc/link_hwss.h
index 3680846674e8..4eff5d38a2f9 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/link_hwss.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/link_hwss.h
@@ -72,8 +72,6 @@ void dp_set_hw_test_pattern(
 	uint8_t *custom_pattern,
 	uint32_t custom_pattern_size);
 
-enum dp_panel_mode dp_get_panel_mode(struct dc_link *link);
-
 void dp_retrain_link_dp_test(struct dc_link *link,
 		struct dc_link_settings *link_setting,
 		bool skip_video_pattern);
-- 
2.28.0


From 36b5057216236ae00ad8ab2f5232e02bbad6a00e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Noralf=20Tr=C3=B8nnes?= <noralf@tronnes.org>
Date: Mon, 22 Jul 2019 12:43:05 +0200
Subject: drm/tinydrm: Rename variable mipi -> dbi
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Git-commit: 36b5057216236ae00ad8ab2f5232e02bbad6a00e
Patch-mainline: v5.4-rc1
References: bsc#1152472

struct mipi_dbi is going to be split into an interface part and a display
pipeline part. The interface part can be used by drivers that need to
initialize the controller, but that won't upload the framebuffer over
this interface.

tinydrm uses the variable name 'mipi' but this is not a good name since
MIPI refers to a lot of standards. This patch changes the variable name
to 'dbi' where it refers to the interface part of struct mipi_dbi.

Functions that use both future parts will have both variables temporarily
pointing to the same structure.

Cc: Eric Anholt <eric@anholt.net>
Cc: David Lechner <david@lechnology.com>
Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
Signed-off-by: Noralf Tr√∏nnes <noralf@tronnes.org>
Acked-by: David Lechner <david@lechnology.com>
Acked-by: Eric Anholt <eric@anholt.net>
Link: https://patchwork.freedesktop.org/patch/msgid/20190722104312.16184-3-noralf@tronnes.org
Acked-by: Thomas Zimmermann <tzimmermann@suse.de>
---
 drivers/gpu/drm/tinydrm/hx8357d.c  |  31 +++---
 drivers/gpu/drm/tinydrm/ili9225.c  | 141 +++++++++++++-------------
 drivers/gpu/drm/tinydrm/ili9341.c  |  55 ++++++-----
 drivers/gpu/drm/tinydrm/mi0283qt.c |  55 ++++++-----
 drivers/gpu/drm/tinydrm/mipi-dbi.c | 153 +++++++++++++++--------------
 drivers/gpu/drm/tinydrm/st7586.c   |  62 ++++++------
 drivers/gpu/drm/tinydrm/st7735r.c  |  49 ++++-----
 include/drm/tinydrm/mipi-dbi.h     |  20 ++--
 8 files changed, 294 insertions(+), 272 deletions(-)

diff --git a/drivers/gpu/drm/tinydrm/hx8357d.c b/drivers/gpu/drm/tinydrm/hx8357d.c
index 7d2dfa92b661..f503d14aa36b 100644
--- a/drivers/gpu/drm/tinydrm/hx8357d.c
+++ b/drivers/gpu/drm/tinydrm/hx8357d.c
@@ -48,6 +48,7 @@ static void yx240qv29_enable(struct drm_simple_display_pipe *pipe,
 			     struct drm_plane_state *plane_state)
 {
 	struct mipi_dbi *mipi = drm_to_mipi_dbi(pipe->crtc.dev);
+	struct mipi_dbi *dbi = mipi;
 	u8 addr_mode;
 	int ret, idx;
 
@@ -63,22 +64,22 @@ static void yx240qv29_enable(struct drm_simple_display_pipe *pipe,
 		goto out_enable;
 
 	/* setextc */
-	mipi_dbi_command(mipi, HX8357D_SETEXTC, 0xFF, 0x83, 0x57);
+	mipi_dbi_command(dbi, HX8357D_SETEXTC, 0xFF, 0x83, 0x57);
 	msleep(150);
 
 	/* setRGB which also enables SDO */
-	mipi_dbi_command(mipi, HX8357D_SETRGB, 0x00, 0x00, 0x06, 0x06);
+	mipi_dbi_command(dbi, HX8357D_SETRGB, 0x00, 0x00, 0x06, 0x06);
 
 	/* -1.52V */
-	mipi_dbi_command(mipi, HX8357D_SETCOM, 0x25);
+	mipi_dbi_command(dbi, HX8357D_SETCOM, 0x25);
 
 	/* Normal mode 70Hz, Idle mode 55 Hz */
-	mipi_dbi_command(mipi, HX8357D_SETOSC, 0x68);
+	mipi_dbi_command(dbi, HX8357D_SETOSC, 0x68);
 
 	/* Set Panel - BGR, Gate direction swapped */
-	mipi_dbi_command(mipi, HX8357D_SETPANEL, 0x05);
+	mipi_dbi_command(dbi, HX8357D_SETPANEL, 0x05);
 
-	mipi_dbi_command(mipi, HX8357D_SETPOWER,
+	mipi_dbi_command(dbi, HX8357D_SETPOWER,
 			 0x00,  /* Not deep standby */
 			 0x15,  /* BT */
 			 0x1C,  /* VSPR */
@@ -86,7 +87,7 @@ static void yx240qv29_enable(struct drm_simple_display_pipe *pipe,
 			 0x83,  /* AP */
 			 0xAA);  /* FS */
 
-	mipi_dbi_command(mipi, HX8357D_SETSTBA,
+	mipi_dbi_command(dbi, HX8357D_SETSTBA,
 			 0x50,  /* OPON normal */
 			 0x50,  /* OPON idle */
 			 0x01,  /* STBA */
@@ -94,7 +95,7 @@ static void yx240qv29_enable(struct drm_simple_display_pipe *pipe,
 			 0x1E,  /* STBA */
 			 0x08);  /* GEN */
 
-	mipi_dbi_command(mipi, HX8357D_SETCYC,
+	mipi_dbi_command(dbi, HX8357D_SETCYC,
 			 0x02,  /* NW 0x02 */
 			 0x40,  /* RTN */
 			 0x00,  /* DIV */
@@ -103,7 +104,7 @@ static void yx240qv29_enable(struct drm_simple_display_pipe *pipe,
 			 0x0D,  /* GDON */
 			 0x78);  /* GDOFF */
 
-	mipi_dbi_command(mipi, HX8357D_SETGAMMA,
+	mipi_dbi_command(dbi, HX8357D_SETGAMMA,
 			 0x02,
 			 0x0A,
 			 0x11,
@@ -140,21 +141,21 @@ static void yx240qv29_enable(struct drm_simple_display_pipe *pipe,
 			 0x01);
 
 	/* 16 bit */
-	mipi_dbi_command(mipi, MIPI_DCS_SET_PIXEL_FORMAT,
+	mipi_dbi_command(dbi, MIPI_DCS_SET_PIXEL_FORMAT,
 			 MIPI_DCS_PIXEL_FMT_16BIT);
 
 	/* TE off */
-	mipi_dbi_command(mipi, MIPI_DCS_SET_TEAR_ON, 0x00);
+	mipi_dbi_command(dbi, MIPI_DCS_SET_TEAR_ON, 0x00);
 
 	/* tear line */
-	mipi_dbi_command(mipi, MIPI_DCS_SET_TEAR_SCANLINE, 0x00, 0x02);
+	mipi_dbi_command(dbi, MIPI_DCS_SET_TEAR_SCANLINE, 0x00, 0x02);
 
 	/* Exit Sleep */
-	mipi_dbi_command(mipi, MIPI_DCS_EXIT_SLEEP_MODE);
+	mipi_dbi_command(dbi, MIPI_DCS_EXIT_SLEEP_MODE);
 	msleep(150);
 
 	/* display on */
-	mipi_dbi_command(mipi, MIPI_DCS_SET_DISPLAY_ON);
+	mipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_ON);
 	usleep_range(5000, 7000);
 
 out_enable:
@@ -172,7 +173,7 @@ static void yx240qv29_enable(struct drm_simple_display_pipe *pipe,
 		addr_mode = HX8357D_MADCTL_MV | HX8357D_MADCTL_MX;
 		break;
 	}
-	mipi_dbi_command(mipi, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);
+	mipi_dbi_command(dbi, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);
 	mipi_dbi_enable_flush(mipi, crtc_state, plane_state);
 out_exit:
 	drm_dev_exit(idx);
diff --git a/drivers/gpu/drm/tinydrm/ili9225.c b/drivers/gpu/drm/tinydrm/ili9225.c
index 62f29b2faf74..c837d1423362 100644
--- a/drivers/gpu/drm/tinydrm/ili9225.c
+++ b/drivers/gpu/drm/tinydrm/ili9225.c
@@ -68,11 +68,11 @@
 #define ILI9225_GAMMA_CONTROL_9		0x58
 #define ILI9225_GAMMA_CONTROL_10	0x59
 
-static inline int ili9225_command(struct mipi_dbi *mipi, u8 cmd, u16 data)
+static inline int ili9225_command(struct mipi_dbi *dbi, u8 cmd, u16 data)
 {
 	u8 par[2] = { data >> 8, data & 0xff };
 
-	return mipi_dbi_command_buf(mipi, cmd, par, 2);
+	return mipi_dbi_command_buf(dbi, cmd, par, 2);
 }
 
 static void ili9225_fb_dirty(struct drm_framebuffer *fb, struct drm_rect *rect)
@@ -81,7 +81,8 @@ static void ili9225_fb_dirty(struct drm_framebuffer *fb, struct drm_rect *rect)
 	struct mipi_dbi *mipi = drm_to_mipi_dbi(fb->dev);
 	unsigned int height = rect->y2 - rect->y1;
 	unsigned int width = rect->x2 - rect->x1;
-	bool swap = mipi->swap_bytes;
+	struct mipi_dbi *dbi = mipi;
+	bool swap = dbi->swap_bytes;
 	u16 x_start, y_start;
 	u16 x1, x2, y1, y2;
 	int idx, ret = 0;
@@ -98,7 +99,7 @@ static void ili9225_fb_dirty(struct drm_framebuffer *fb, struct drm_rect *rect)
 
 	DRM_DEBUG_KMS("Flushing [FB:%d] " DRM_RECT_FMT "\n", fb->base.id, DRM_RECT_ARG(rect));
 
-	if (!mipi->dc || !full || swap ||
+	if (!dbi->dc || !full || swap ||
 	    fb->format->format == DRM_FORMAT_XRGB8888) {
 		tr = mipi->tx_buf;
 		ret = mipi_dbi_buf_copy(mipi->tx_buf, fb, rect, swap);
@@ -143,15 +144,15 @@ static void ili9225_fb_dirty(struct drm_framebuffer *fb, struct drm_rect *rect)
 		break;
 	}
 
-	ili9225_command(mipi, ILI9225_HORIZ_WINDOW_ADDR_1, x2);
-	ili9225_command(mipi, ILI9225_HORIZ_WINDOW_ADDR_2, x1);
-	ili9225_command(mipi, ILI9225_VERT_WINDOW_ADDR_1, y2);
-	ili9225_command(mipi, ILI9225_VERT_WINDOW_ADDR_2, y1);
+	ili9225_command(dbi, ILI9225_HORIZ_WINDOW_ADDR_1, x2);
+	ili9225_command(dbi, ILI9225_HORIZ_WINDOW_ADDR_2, x1);
+	ili9225_command(dbi, ILI9225_VERT_WINDOW_ADDR_1, y2);
+	ili9225_command(dbi, ILI9225_VERT_WINDOW_ADDR_2, y1);
 
-	ili9225_command(mipi, ILI9225_RAM_ADDRESS_SET_1, x_start);
-	ili9225_command(mipi, ILI9225_RAM_ADDRESS_SET_2, y_start);
+	ili9225_command(dbi, ILI9225_RAM_ADDRESS_SET_1, x_start);
+	ili9225_command(dbi, ILI9225_RAM_ADDRESS_SET_2, y_start);
 
-	ret = mipi_dbi_command_buf(mipi, ILI9225_WRITE_DATA_TO_GRAM, tr,
+	ret = mipi_dbi_command_buf(dbi, ILI9225_WRITE_DATA_TO_GRAM, tr,
 				   width * height * 2);
 err_msg:
 	if (ret)
@@ -185,6 +186,7 @@ static void ili9225_pipe_enable(struct drm_simple_display_pipe *pipe,
 	struct mipi_dbi *mipi = drm_to_mipi_dbi(pipe->crtc.dev);
 	struct drm_framebuffer *fb = plane_state->fb;
 	struct device *dev = pipe->crtc.dev->dev;
+	struct mipi_dbi *dbi = mipi;
 	struct drm_rect rect = {
 		.x1 = 0,
 		.x2 = fb->width,
@@ -199,7 +201,7 @@ static void ili9225_pipe_enable(struct drm_simple_display_pipe *pipe,
 
 	DRM_DEBUG_KMS("\n");
 
-	mipi_dbi_hw_reset(mipi);
+	mipi_dbi_hw_reset(dbi);
 
 	/*
 	 * There don't seem to be two example init sequences that match, so
@@ -207,27 +209,27 @@ static void ili9225_pipe_enable(struct drm_simple_display_pipe *pipe,
 	 * https://github.com/Nkawu/TFT_22_ILI9225/blob/master/src/TFT_22_ILI9225.cpp
 	 */
 
-	ret = ili9225_command(mipi, ILI9225_POWER_CONTROL_1, 0x0000);
+	ret = ili9225_command(dbi, ILI9225_POWER_CONTROL_1, 0x0000);
 	if (ret) {
 		DRM_DEV_ERROR(dev, "Error sending command %d\n", ret);
 		goto out_exit;
 	}
-	ili9225_command(mipi, ILI9225_POWER_CONTROL_2, 0x0000);
-	ili9225_command(mipi, ILI9225_POWER_CONTROL_3, 0x0000);
-	ili9225_command(mipi, ILI9225_POWER_CONTROL_4, 0x0000);
-	ili9225_command(mipi, ILI9225_POWER_CONTROL_5, 0x0000);
+	ili9225_command(dbi, ILI9225_POWER_CONTROL_2, 0x0000);
+	ili9225_command(dbi, ILI9225_POWER_CONTROL_3, 0x0000);
+	ili9225_command(dbi, ILI9225_POWER_CONTROL_4, 0x0000);
+	ili9225_command(dbi, ILI9225_POWER_CONTROL_5, 0x0000);
 
 	msleep(40);
 
-	ili9225_command(mipi, ILI9225_POWER_CONTROL_2, 0x0018);
-	ili9225_command(mipi, ILI9225_POWER_CONTROL_3, 0x6121);
-	ili9225_command(mipi, ILI9225_POWER_CONTROL_4, 0x006f);
-	ili9225_command(mipi, ILI9225_POWER_CONTROL_5, 0x495f);
-	ili9225_command(mipi, ILI9225_POWER_CONTROL_1, 0x0800);
+	ili9225_command(dbi, ILI9225_POWER_CONTROL_2, 0x0018);
+	ili9225_command(dbi, ILI9225_POWER_CONTROL_3, 0x6121);
+	ili9225_command(dbi, ILI9225_POWER_CONTROL_4, 0x006f);
+	ili9225_command(dbi, ILI9225_POWER_CONTROL_5, 0x495f);
+	ili9225_command(dbi, ILI9225_POWER_CONTROL_1, 0x0800);
 
 	msleep(10);
 
-	ili9225_command(mipi, ILI9225_POWER_CONTROL_2, 0x103b);
+	ili9225_command(dbi, ILI9225_POWER_CONTROL_2, 0x103b);
 
 	msleep(50);
 
@@ -245,41 +247,41 @@ static void ili9225_pipe_enable(struct drm_simple_display_pipe *pipe,
 		am_id = 0x28;
 		break;
 	}
-	ili9225_command(mipi, ILI9225_DRIVER_OUTPUT_CONTROL, 0x011c);
-	ili9225_command(mipi, ILI9225_LCD_AC_DRIVING_CONTROL, 0x0100);
-	ili9225_command(mipi, ILI9225_ENTRY_MODE, 0x1000 | am_id);
-	ili9225_command(mipi, ILI9225_DISPLAY_CONTROL_1, 0x0000);
-	ili9225_command(mipi, ILI9225_BLANK_PERIOD_CONTROL_1, 0x0808);
-	ili9225_command(mipi, ILI9225_FRAME_CYCLE_CONTROL, 0x1100);
-	ili9225_command(mipi, ILI9225_INTERFACE_CONTROL, 0x0000);
-	ili9225_command(mipi, ILI9225_OSCILLATION_CONTROL, 0x0d01);
-	ili9225_command(mipi, ILI9225_VCI_RECYCLING, 0x0020);
-	ili9225_command(mipi, ILI9225_RAM_ADDRESS_SET_1, 0x0000);
-	ili9225_command(mipi, ILI9225_RAM_ADDRESS_SET_2, 0x0000);
-
-	ili9225_command(mipi, ILI9225_GATE_SCAN_CONTROL, 0x0000);
-	ili9225_command(mipi, ILI9225_VERTICAL_SCROLL_1, 0x00db);
-	ili9225_command(mipi, ILI9225_VERTICAL_SCROLL_2, 0x0000);
-	ili9225_command(mipi, ILI9225_VERTICAL_SCROLL_3, 0x0000);
-	ili9225_command(mipi, ILI9225_PARTIAL_DRIVING_POS_1, 0x00db);
-	ili9225_command(mipi, ILI9225_PARTIAL_DRIVING_POS_2, 0x0000);
-
-	ili9225_command(mipi, ILI9225_GAMMA_CONTROL_1, 0x0000);
-	ili9225_command(mipi, ILI9225_GAMMA_CONTROL_2, 0x0808);
-	ili9225_command(mipi, ILI9225_GAMMA_CONTROL_3, 0x080a);
-	ili9225_command(mipi, ILI9225_GAMMA_CONTROL_4, 0x000a);
-	ili9225_command(mipi, ILI9225_GAMMA_CONTROL_5, 0x0a08);
-	ili9225_command(mipi, ILI9225_GAMMA_CONTROL_6, 0x0808);
-	ili9225_command(mipi, ILI9225_GAMMA_CONTROL_7, 0x0000);
-	ili9225_command(mipi, ILI9225_GAMMA_CONTROL_8, 0x0a00);
-	ili9225_command(mipi, ILI9225_GAMMA_CONTROL_9, 0x0710);
-	ili9225_command(mipi, ILI9225_GAMMA_CONTROL_10, 0x0710);
-
-	ili9225_command(mipi, ILI9225_DISPLAY_CONTROL_1, 0x0012);
+	ili9225_command(dbi, ILI9225_DRIVER_OUTPUT_CONTROL, 0x011c);
+	ili9225_command(dbi, ILI9225_LCD_AC_DRIVING_CONTROL, 0x0100);
+	ili9225_command(dbi, ILI9225_ENTRY_MODE, 0x1000 | am_id);
+	ili9225_command(dbi, ILI9225_DISPLAY_CONTROL_1, 0x0000);
+	ili9225_command(dbi, ILI9225_BLANK_PERIOD_CONTROL_1, 0x0808);
+	ili9225_command(dbi, ILI9225_FRAME_CYCLE_CONTROL, 0x1100);
+	ili9225_command(dbi, ILI9225_INTERFACE_CONTROL, 0x0000);
+	ili9225_command(dbi, ILI9225_OSCILLATION_CONTROL, 0x0d01);
+	ili9225_command(dbi, ILI9225_VCI_RECYCLING, 0x0020);
+	ili9225_command(dbi, ILI9225_RAM_ADDRESS_SET_1, 0x0000);
+	ili9225_command(dbi, ILI9225_RAM_ADDRESS_SET_2, 0x0000);
+
+	ili9225_command(dbi, ILI9225_GATE_SCAN_CONTROL, 0x0000);
+	ili9225_command(dbi, ILI9225_VERTICAL_SCROLL_1, 0x00db);
+	ili9225_command(dbi, ILI9225_VERTICAL_SCROLL_2, 0x0000);
+	ili9225_command(dbi, ILI9225_VERTICAL_SCROLL_3, 0x0000);
+	ili9225_command(dbi, ILI9225_PARTIAL_DRIVING_POS_1, 0x00db);
+	ili9225_command(dbi, ILI9225_PARTIAL_DRIVING_POS_2, 0x0000);
+
+	ili9225_command(dbi, ILI9225_GAMMA_CONTROL_1, 0x0000);
+	ili9225_command(dbi, ILI9225_GAMMA_CONTROL_2, 0x0808);
+	ili9225_command(dbi, ILI9225_GAMMA_CONTROL_3, 0x080a);
+	ili9225_command(dbi, ILI9225_GAMMA_CONTROL_4, 0x000a);
+	ili9225_command(dbi, ILI9225_GAMMA_CONTROL_5, 0x0a08);
+	ili9225_command(dbi, ILI9225_GAMMA_CONTROL_6, 0x0808);
+	ili9225_command(dbi, ILI9225_GAMMA_CONTROL_7, 0x0000);
+	ili9225_command(dbi, ILI9225_GAMMA_CONTROL_8, 0x0a00);
+	ili9225_command(dbi, ILI9225_GAMMA_CONTROL_9, 0x0710);
+	ili9225_command(dbi, ILI9225_GAMMA_CONTROL_10, 0x0710);
+
+	ili9225_command(dbi, ILI9225_DISPLAY_CONTROL_1, 0x0012);
 
 	msleep(50);
 
-	ili9225_command(mipi, ILI9225_DISPLAY_CONTROL_1, 0x1017);
+	ili9225_command(dbi, ILI9225_DISPLAY_CONTROL_1, 0x1017);
 
 	mipi->enabled = true;
 	ili9225_fb_dirty(fb, &rect);
@@ -290,6 +292,7 @@ static void ili9225_pipe_enable(struct drm_simple_display_pipe *pipe,
 static void ili9225_pipe_disable(struct drm_simple_display_pipe *pipe)
 {
 	struct mipi_dbi *mipi = drm_to_mipi_dbi(pipe->crtc.dev);
+	struct mipi_dbi *dbi = mipi;
 
 	DRM_DEBUG_KMS("\n");
 
@@ -303,33 +306,33 @@ static void ili9225_pipe_disable(struct drm_simple_display_pipe *pipe)
 	if (!mipi->enabled)
 		return;
 
-	ili9225_command(mipi, ILI9225_DISPLAY_CONTROL_1, 0x0000);
+	ili9225_command(dbi, ILI9225_DISPLAY_CONTROL_1, 0x0000);
 	msleep(50);
-	ili9225_command(mipi, ILI9225_POWER_CONTROL_2, 0x0007);
+	ili9225_command(dbi, ILI9225_POWER_CONTROL_2, 0x0007);
 	msleep(50);
-	ili9225_command(mipi, ILI9225_POWER_CONTROL_1, 0x0a02);
+	ili9225_command(dbi, ILI9225_POWER_CONTROL_1, 0x0a02);
 
 	mipi->enabled = false;
 }
 
-static int ili9225_dbi_command(struct mipi_dbi *mipi, u8 *cmd, u8 *par,
+static int ili9225_dbi_command(struct mipi_dbi *dbi, u8 *cmd, u8 *par,
 			       size_t num)
 {
-	struct spi_device *spi = mipi->spi;
+	struct spi_device *spi = dbi->spi;
 	unsigned int bpw = 8;
 	u32 speed_hz;
 	int ret;
 
-	gpiod_set_value_cansleep(mipi->dc, 0);
+	gpiod_set_value_cansleep(dbi->dc, 0);
 	speed_hz = mipi_dbi_spi_cmd_max_speed(spi, 1);
 	ret = mipi_dbi_spi_transfer(spi, speed_hz, 8, cmd, 1);
 	if (ret || !num)
 		return ret;
 
-	if (*cmd == ILI9225_WRITE_DATA_TO_GRAM && !mipi->swap_bytes)
+	if (*cmd == ILI9225_WRITE_DATA_TO_GRAM && !dbi->swap_bytes)
 		bpw = 16;
 
-	gpiod_set_value_cansleep(mipi->dc, 1);
+	gpiod_set_value_cansleep(dbi->dc, 1);
 	speed_hz = mipi_dbi_spi_cmd_max_speed(spi, num);
 
 	return mipi_dbi_spi_transfer(spi, speed_hz, bpw, par, num);
@@ -377,6 +380,7 @@ static int ili9225_probe(struct spi_device *spi)
 	struct device *dev = &spi->dev;
 	struct drm_device *drm;
 	struct mipi_dbi *mipi;
+	struct mipi_dbi *dbi;
 	struct gpio_desc *rs;
 	u32 rotation = 0;
 	int ret;
@@ -385,6 +389,7 @@ static int ili9225_probe(struct spi_device *spi)
 	if (!mipi)
 		return -ENOMEM;
 
+	dbi = mipi;
 	drm = &mipi->drm;
 	ret = devm_drm_dev_init(dev, drm, &ili9225_driver);
 	if (ret) {
@@ -394,10 +399,10 @@ static int ili9225_probe(struct spi_device *spi)
 
 	drm_mode_config_init(drm);
 
-	mipi->reset = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
-	if (IS_ERR(mipi->reset)) {
+	dbi->reset = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(dbi->reset)) {
 		DRM_DEV_ERROR(dev, "Failed to get gpio 'reset'\n");
-		return PTR_ERR(mipi->reset);
+		return PTR_ERR(dbi->reset);
 	}
 
 	rs = devm_gpiod_get(dev, "rs", GPIOD_OUT_LOW);
@@ -408,12 +413,12 @@ static int ili9225_probe(struct spi_device *spi)
 
 	device_property_read_u32(dev, "rotation", &rotation);
 
-	ret = mipi_dbi_spi_init(spi, mipi, rs);
+	ret = mipi_dbi_spi_init(spi, dbi, rs);
 	if (ret)
 		return ret;
 
 	/* override the command function set in  mipi_dbi_spi_init() */
-	mipi->command = ili9225_dbi_command;
+	dbi->command = ili9225_dbi_command;
 
 	ret = mipi_dbi_init(mipi, &ili9225_pipe_funcs, &ili9225_mode, rotation);
 	if (ret)
diff --git a/drivers/gpu/drm/tinydrm/ili9341.c b/drivers/gpu/drm/tinydrm/ili9341.c
index cb0a0ddbc090..05ba5ab17ec6 100644
--- a/drivers/gpu/drm/tinydrm/ili9341.c
+++ b/drivers/gpu/drm/tinydrm/ili9341.c
@@ -54,6 +54,7 @@ static void yx240qv29_enable(struct drm_simple_display_pipe *pipe,
 			     struct drm_plane_state *plane_state)
 {
 	struct mipi_dbi *mipi = drm_to_mipi_dbi(pipe->crtc.dev);
+	struct mipi_dbi *dbi = mipi;
 	u8 addr_mode;
 	int ret, idx;
 
@@ -68,47 +69,47 @@ static void yx240qv29_enable(struct drm_simple_display_pipe *pipe,
 	if (ret == 1)
 		goto out_enable;
 
-	mipi_dbi_command(mipi, MIPI_DCS_SET_DISPLAY_OFF);
+	mipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_OFF);
 
-	mipi_dbi_command(mipi, ILI9341_PWCTRLB, 0x00, 0xc1, 0x30);
-	mipi_dbi_command(mipi, ILI9341_PWRSEQ, 0x64, 0x03, 0x12, 0x81);
-	mipi_dbi_command(mipi, ILI9341_DTCTRLA, 0x85, 0x00, 0x78);
-	mipi_dbi_command(mipi, ILI9341_PWCTRLA, 0x39, 0x2c, 0x00, 0x34, 0x02);
-	mipi_dbi_command(mipi, ILI9341_PUMPCTRL, 0x20);
-	mipi_dbi_command(mipi, ILI9341_DTCTRLB, 0x00, 0x00);
+	mipi_dbi_command(dbi, ILI9341_PWCTRLB, 0x00, 0xc1, 0x30);
+	mipi_dbi_command(dbi, ILI9341_PWRSEQ, 0x64, 0x03, 0x12, 0x81);
+	mipi_dbi_command(dbi, ILI9341_DTCTRLA, 0x85, 0x00, 0x78);
+	mipi_dbi_command(dbi, ILI9341_PWCTRLA, 0x39, 0x2c, 0x00, 0x34, 0x02);
+	mipi_dbi_command(dbi, ILI9341_PUMPCTRL, 0x20);
+	mipi_dbi_command(dbi, ILI9341_DTCTRLB, 0x00, 0x00);
 
 	/* Power Control */
-	mipi_dbi_command(mipi, ILI9341_PWCTRL1, 0x23);
-	mipi_dbi_command(mipi, ILI9341_PWCTRL2, 0x10);
+	mipi_dbi_command(dbi, ILI9341_PWCTRL1, 0x23);
+	mipi_dbi_command(dbi, ILI9341_PWCTRL2, 0x10);
 	/* VCOM */
-	mipi_dbi_command(mipi, ILI9341_VMCTRL1, 0x3e, 0x28);
-	mipi_dbi_command(mipi, ILI9341_VMCTRL2, 0x86);
+	mipi_dbi_command(dbi, ILI9341_VMCTRL1, 0x3e, 0x28);
+	mipi_dbi_command(dbi, ILI9341_VMCTRL2, 0x86);
 
 	/* Memory Access Control */
-	mipi_dbi_command(mipi, MIPI_DCS_SET_PIXEL_FORMAT, MIPI_DCS_PIXEL_FMT_16BIT);
+	mipi_dbi_command(dbi, MIPI_DCS_SET_PIXEL_FORMAT, MIPI_DCS_PIXEL_FMT_16BIT);
 
 	/* Frame Rate */
-	mipi_dbi_command(mipi, ILI9341_FRMCTR1, 0x00, 0x1b);
+	mipi_dbi_command(dbi, ILI9341_FRMCTR1, 0x00, 0x1b);
 
 	/* Gamma */
-	mipi_dbi_command(mipi, ILI9341_EN3GAM, 0x00);
-	mipi_dbi_command(mipi, MIPI_DCS_SET_GAMMA_CURVE, 0x01);
-	mipi_dbi_command(mipi, ILI9341_PGAMCTRL,
+	mipi_dbi_command(dbi, ILI9341_EN3GAM, 0x00);
+	mipi_dbi_command(dbi, MIPI_DCS_SET_GAMMA_CURVE, 0x01);
+	mipi_dbi_command(dbi, ILI9341_PGAMCTRL,
 			 0x0f, 0x31, 0x2b, 0x0c, 0x0e, 0x08, 0x4e, 0xf1,
 			 0x37, 0x07, 0x10, 0x03, 0x0e, 0x09, 0x00);
-	mipi_dbi_command(mipi, ILI9341_NGAMCTRL,
+	mipi_dbi_command(dbi, ILI9341_NGAMCTRL,
 			 0x00, 0x0e, 0x14, 0x03, 0x11, 0x07, 0x31, 0xc1,
 			 0x48, 0x08, 0x0f, 0x0c, 0x31, 0x36, 0x0f);
 
 	/* DDRAM */
-	mipi_dbi_command(mipi, ILI9341_ETMOD, 0x07);
+	mipi_dbi_command(dbi, ILI9341_ETMOD, 0x07);
 
 	/* Display */
-	mipi_dbi_command(mipi, ILI9341_DISCTRL, 0x08, 0x82, 0x27, 0x00);
-	mipi_dbi_command(mipi, MIPI_DCS_EXIT_SLEEP_MODE);
+	mipi_dbi_command(dbi, ILI9341_DISCTRL, 0x08, 0x82, 0x27, 0x00);
+	mipi_dbi_command(dbi, MIPI_DCS_EXIT_SLEEP_MODE);
 	msleep(100);
 
-	mipi_dbi_command(mipi, MIPI_DCS_SET_DISPLAY_ON);
+	mipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_ON);
 	msleep(100);
 
 out_enable:
@@ -128,7 +129,7 @@ static void yx240qv29_enable(struct drm_simple_display_pipe *pipe,
 		break;
 	}
 	addr_mode |= ILI9341_MADCTL_BGR;
-	mipi_dbi_command(mipi, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);
+	mipi_dbi_command(dbi, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);
 	mipi_dbi_enable_flush(mipi, crtc_state, plane_state);
 out_exit:
 	drm_dev_exit(idx);
@@ -177,6 +178,7 @@ static int ili9341_probe(struct spi_device *spi)
 	struct device *dev = &spi->dev;
 	struct drm_device *drm;
 	struct mipi_dbi *mipi;
+	struct mipi_dbi *dbi;
 	struct gpio_desc *dc;
 	u32 rotation = 0;
 	int ret;
@@ -185,6 +187,7 @@ static int ili9341_probe(struct spi_device *spi)
 	if (!mipi)
 		return -ENOMEM;
 
+	dbi = mipi;
 	drm = &mipi->drm;
 	ret = devm_drm_dev_init(dev, drm, &ili9341_driver);
 	if (ret) {
@@ -194,10 +197,10 @@ static int ili9341_probe(struct spi_device *spi)
 
 	drm_mode_config_init(drm);
 
-	mipi->reset = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_HIGH);
-	if (IS_ERR(mipi->reset)) {
+	dbi->reset = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(dbi->reset)) {
 		DRM_DEV_ERROR(dev, "Failed to get gpio 'reset'\n");
-		return PTR_ERR(mipi->reset);
+		return PTR_ERR(dbi->reset);
 	}
 
 	dc = devm_gpiod_get_optional(dev, "dc", GPIOD_OUT_LOW);
@@ -212,7 +215,7 @@ static int ili9341_probe(struct spi_device *spi)
 
 	device_property_read_u32(dev, "rotation", &rotation);
 
-	ret = mipi_dbi_spi_init(spi, mipi, dc);
+	ret = mipi_dbi_spi_init(spi, dbi, dc);
 	if (ret)
 		return ret;
 
diff --git a/drivers/gpu/drm/tinydrm/mi0283qt.c b/drivers/gpu/drm/tinydrm/mi0283qt.c
index f21d58dcaa5a..adc8c4872d3f 100644
--- a/drivers/gpu/drm/tinydrm/mi0283qt.c
+++ b/drivers/gpu/drm/tinydrm/mi0283qt.c
@@ -52,6 +52,7 @@ static void mi0283qt_enable(struct drm_simple_display_pipe *pipe,
 			    struct drm_plane_state *plane_state)
 {
 	struct mipi_dbi *mipi = drm_to_mipi_dbi(pipe->crtc.dev);
+	struct mipi_dbi *dbi = mipi;
 	u8 addr_mode;
 	int ret, idx;
 
@@ -66,47 +67,47 @@ static void mi0283qt_enable(struct drm_simple_display_pipe *pipe,
 	if (ret == 1)
 		goto out_enable;
 
-	mipi_dbi_command(mipi, MIPI_DCS_SET_DISPLAY_OFF);
+	mipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_OFF);
 
-	mipi_dbi_command(mipi, ILI9341_PWCTRLB, 0x00, 0x83, 0x30);
-	mipi_dbi_command(mipi, ILI9341_PWRSEQ, 0x64, 0x03, 0x12, 0x81);
-	mipi_dbi_command(mipi, ILI9341_DTCTRLA, 0x85, 0x01, 0x79);
-	mipi_dbi_command(mipi, ILI9341_PWCTRLA, 0x39, 0x2c, 0x00, 0x34, 0x02);
-	mipi_dbi_command(mipi, ILI9341_PUMPCTRL, 0x20);
-	mipi_dbi_command(mipi, ILI9341_DTCTRLB, 0x00, 0x00);
+	mipi_dbi_command(dbi, ILI9341_PWCTRLB, 0x00, 0x83, 0x30);
+	mipi_dbi_command(dbi, ILI9341_PWRSEQ, 0x64, 0x03, 0x12, 0x81);
+	mipi_dbi_command(dbi, ILI9341_DTCTRLA, 0x85, 0x01, 0x79);
+	mipi_dbi_command(dbi, ILI9341_PWCTRLA, 0x39, 0x2c, 0x00, 0x34, 0x02);
+	mipi_dbi_command(dbi, ILI9341_PUMPCTRL, 0x20);
+	mipi_dbi_command(dbi, ILI9341_DTCTRLB, 0x00, 0x00);
 
 	/* Power Control */
-	mipi_dbi_command(mipi, ILI9341_PWCTRL1, 0x26);
-	mipi_dbi_command(mipi, ILI9341_PWCTRL2, 0x11);
+	mipi_dbi_command(dbi, ILI9341_PWCTRL1, 0x26);
+	mipi_dbi_command(dbi, ILI9341_PWCTRL2, 0x11);
 	/* VCOM */
-	mipi_dbi_command(mipi, ILI9341_VMCTRL1, 0x35, 0x3e);
-	mipi_dbi_command(mipi, ILI9341_VMCTRL2, 0xbe);
+	mipi_dbi_command(dbi, ILI9341_VMCTRL1, 0x35, 0x3e);
+	mipi_dbi_command(dbi, ILI9341_VMCTRL2, 0xbe);
 
 	/* Memory Access Control */
-	mipi_dbi_command(mipi, MIPI_DCS_SET_PIXEL_FORMAT, MIPI_DCS_PIXEL_FMT_16BIT);
+	mipi_dbi_command(dbi, MIPI_DCS_SET_PIXEL_FORMAT, MIPI_DCS_PIXEL_FMT_16BIT);
 
 	/* Frame Rate */
-	mipi_dbi_command(mipi, ILI9341_FRMCTR1, 0x00, 0x1b);
+	mipi_dbi_command(dbi, ILI9341_FRMCTR1, 0x00, 0x1b);
 
 	/* Gamma */
-	mipi_dbi_command(mipi, ILI9341_EN3GAM, 0x08);
-	mipi_dbi_command(mipi, MIPI_DCS_SET_GAMMA_CURVE, 0x01);
-	mipi_dbi_command(mipi, ILI9341_PGAMCTRL,
+	mipi_dbi_command(dbi, ILI9341_EN3GAM, 0x08);
+	mipi_dbi_command(dbi, MIPI_DCS_SET_GAMMA_CURVE, 0x01);
+	mipi_dbi_command(dbi, ILI9341_PGAMCTRL,
 		       0x1f, 0x1a, 0x18, 0x0a, 0x0f, 0x06, 0x45, 0x87,
 		       0x32, 0x0a, 0x07, 0x02, 0x07, 0x05, 0x00);
-	mipi_dbi_command(mipi, ILI9341_NGAMCTRL,
+	mipi_dbi_command(dbi, ILI9341_NGAMCTRL,
 		       0x00, 0x25, 0x27, 0x05, 0x10, 0x09, 0x3a, 0x78,
 		       0x4d, 0x05, 0x18, 0x0d, 0x38, 0x3a, 0x1f);
 
 	/* DDRAM */
-	mipi_dbi_command(mipi, ILI9341_ETMOD, 0x07);
+	mipi_dbi_command(dbi, ILI9341_ETMOD, 0x07);
 
 	/* Display */
-	mipi_dbi_command(mipi, ILI9341_DISCTRL, 0x0a, 0x82, 0x27, 0x00);
-	mipi_dbi_command(mipi, MIPI_DCS_EXIT_SLEEP_MODE);
+	mipi_dbi_command(dbi, ILI9341_DISCTRL, 0x0a, 0x82, 0x27, 0x00);
+	mipi_dbi_command(dbi, MIPI_DCS_EXIT_SLEEP_MODE);
 	msleep(100);
 
-	mipi_dbi_command(mipi, MIPI_DCS_SET_DISPLAY_ON);
+	mipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_ON);
 	msleep(100);
 
 out_enable:
@@ -132,7 +133,7 @@ static void mi0283qt_enable(struct drm_simple_display_pipe *pipe,
 		break;
 	}
 	addr_mode |= ILI9341_MADCTL_BGR;
-	mipi_dbi_command(mipi, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);
+	mipi_dbi_command(dbi, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);
 	mipi_dbi_enable_flush(mipi, crtc_state, plane_state);
 out_exit:
 	drm_dev_exit(idx);
@@ -181,6 +182,7 @@ static int mi0283qt_probe(struct spi_device *spi)
 	struct device *dev = &spi->dev;
 	struct drm_device *drm;
 	struct mipi_dbi *mipi;
+	struct mipi_dbi *dbi;
 	struct gpio_desc *dc;
 	u32 rotation = 0;
 	int ret;
@@ -189,6 +191,7 @@ static int mi0283qt_probe(struct spi_device *spi)
 	if (!mipi)
 		return -ENOMEM;
 
+	dbi = mipi;
 	drm = &mipi->drm;
 	ret = devm_drm_dev_init(dev, drm, &mi0283qt_driver);
 	if (ret) {
@@ -198,10 +201,10 @@ static int mi0283qt_probe(struct spi_device *spi)
 
 	drm_mode_config_init(drm);
 
-	mipi->reset = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_HIGH);
-	if (IS_ERR(mipi->reset)) {
+	dbi->reset = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(dbi->reset)) {
 		DRM_DEV_ERROR(dev, "Failed to get gpio 'reset'\n");
-		return PTR_ERR(mipi->reset);
+		return PTR_ERR(dbi->reset);
 	}
 
 	dc = devm_gpiod_get_optional(dev, "dc", GPIOD_OUT_LOW);
@@ -220,7 +223,7 @@ static int mi0283qt_probe(struct spi_device *spi)
 
 	device_property_read_u32(dev, "rotation", &rotation);
 
-	ret = mipi_dbi_spi_init(spi, mipi, dc);
+	ret = mipi_dbi_spi_init(spi, dbi, dc);
 	if (ret)
 		return ret;
 
diff --git a/drivers/gpu/drm/tinydrm/mipi-dbi.c b/drivers/gpu/drm/tinydrm/mipi-dbi.c
index 37a73b4c0f85..93b9b3ac5568 100644
--- a/drivers/gpu/drm/tinydrm/mipi-dbi.c
+++ b/drivers/gpu/drm/tinydrm/mipi-dbi.c
@@ -100,17 +100,17 @@ static const u8 mipi_dbi_dcs_read_commands[] = {
 	0, /* sentinel */
 };
 
-static bool mipi_dbi_command_is_read(struct mipi_dbi *mipi, u8 cmd)
+static bool mipi_dbi_command_is_read(struct mipi_dbi *dbi, u8 cmd)
 {
 	unsigned int i;
 
-	if (!mipi->read_commands)
+	if (!dbi->read_commands)
 		return false;
 
 	for (i = 0; i < 0xff; i++) {
-		if (!mipi->read_commands[i])
+		if (!dbi->read_commands[i])
 			return false;
-		if (cmd == mipi->read_commands[i])
+		if (cmd == dbi->read_commands[i])
 			return true;
 	}
 
@@ -119,7 +119,7 @@ static bool mipi_dbi_command_is_read(struct mipi_dbi *mipi, u8 cmd)
 
 /**
  * mipi_dbi_command_read - MIPI DCS read command
- * @mipi: MIPI structure
+ * @dbi: MIPI DBI structure
  * @cmd: Command
  * @val: Value read
  *
@@ -128,21 +128,21 @@ static bool mipi_dbi_command_is_read(struct mipi_dbi *mipi, u8 cmd)
  * Returns:
  * Zero on success, negative error code on failure.
  */
-int mipi_dbi_command_read(struct mipi_dbi *mipi, u8 cmd, u8 *val)
+int mipi_dbi_command_read(struct mipi_dbi *dbi, u8 cmd, u8 *val)
 {
-	if (!mipi->read_commands)
+	if (!dbi->read_commands)
 		return -EACCES;
 
-	if (!mipi_dbi_command_is_read(mipi, cmd))
+	if (!mipi_dbi_command_is_read(dbi, cmd))
 		return -EINVAL;
 
-	return mipi_dbi_command_buf(mipi, cmd, val, 1);
+	return mipi_dbi_command_buf(dbi, cmd, val, 1);
 }
 EXPORT_SYMBOL(mipi_dbi_command_read);
 
 /**
  * mipi_dbi_command_buf - MIPI DCS command with parameter(s) in an array
- * @mipi: MIPI structure
+ * @dbi: MIPI DBI structure
  * @cmd: Command
  * @data: Parameter buffer
  * @len: Buffer length
@@ -150,7 +150,7 @@ EXPORT_SYMBOL(mipi_dbi_command_read);
  * Returns:
  * Zero on success, negative error code on failure.
  */
-int mipi_dbi_command_buf(struct mipi_dbi *mipi, u8 cmd, u8 *data, size_t len)
+int mipi_dbi_command_buf(struct mipi_dbi *dbi, u8 cmd, u8 *data, size_t len)
 {
 	u8 *cmdbuf;
 	int ret;
@@ -160,9 +160,9 @@ int mipi_dbi_command_buf(struct mipi_dbi *mipi, u8 cmd, u8 *data, size_t len)
 	if (!cmdbuf)
 		return -ENOMEM;
 
-	mutex_lock(&mipi->cmdlock);
-	ret = mipi->command(mipi, cmdbuf, data, len);
-	mutex_unlock(&mipi->cmdlock);
+	mutex_lock(&dbi->cmdlock);
+	ret = dbi->command(dbi, cmdbuf, data, len);
+	mutex_unlock(&dbi->cmdlock);
 
 	kfree(cmdbuf);
 
@@ -171,7 +171,7 @@ int mipi_dbi_command_buf(struct mipi_dbi *mipi, u8 cmd, u8 *data, size_t len)
 EXPORT_SYMBOL(mipi_dbi_command_buf);
 
 /* This should only be used by mipi_dbi_command() */
-int mipi_dbi_command_stackbuf(struct mipi_dbi *mipi, u8 cmd, u8 *data, size_t len)
+int mipi_dbi_command_stackbuf(struct mipi_dbi *dbi, u8 cmd, u8 *data, size_t len)
 {
 	u8 *buf;
 	int ret;
@@ -180,7 +180,7 @@ int mipi_dbi_command_stackbuf(struct mipi_dbi *mipi, u8 cmd, u8 *data, size_t le
 	if (!buf)
 		return -ENOMEM;
 
-	ret = mipi_dbi_command_buf(mipi, cmd, buf, len);
+	ret = mipi_dbi_command_buf(dbi, cmd, buf, len);
 
 	kfree(buf);
 
@@ -244,7 +244,8 @@ static void mipi_dbi_fb_dirty(struct drm_framebuffer *fb, struct drm_rect *rect)
 	struct mipi_dbi *mipi = drm_to_mipi_dbi(fb->dev);
 	unsigned int height = rect->y2 - rect->y1;
 	unsigned int width = rect->x2 - rect->x1;
-	bool swap = mipi->swap_bytes;
+	struct mipi_dbi *dbi = mipi;
+	bool swap = dbi->swap_bytes;
 	int idx, ret = 0;
 	bool full;
 	void *tr;
@@ -259,7 +260,7 @@ static void mipi_dbi_fb_dirty(struct drm_framebuffer *fb, struct drm_rect *rect)
 
 	DRM_DEBUG_KMS("Flushing [FB:%d] " DRM_RECT_FMT "\n", fb->base.id, DRM_RECT_ARG(rect));
 
-	if (!mipi->dc || !full || swap ||
+	if (!dbi->dc || !full || swap ||
 	    fb->format->format == DRM_FORMAT_XRGB8888) {
 		tr = mipi->tx_buf;
 		ret = mipi_dbi_buf_copy(mipi->tx_buf, fb, rect, swap);
@@ -269,14 +270,14 @@ static void mipi_dbi_fb_dirty(struct drm_framebuffer *fb, struct drm_rect *rect)
 		tr = cma_obj->vaddr;
 	}
 
-	mipi_dbi_command(mipi, MIPI_DCS_SET_COLUMN_ADDRESS,
+	mipi_dbi_command(dbi, MIPI_DCS_SET_COLUMN_ADDRESS,
 			 (rect->x1 >> 8) & 0xff, rect->x1 & 0xff,
 			 ((rect->x2 - 1) >> 8) & 0xff, (rect->x2 - 1) & 0xff);
-	mipi_dbi_command(mipi, MIPI_DCS_SET_PAGE_ADDRESS,
+	mipi_dbi_command(dbi, MIPI_DCS_SET_PAGE_ADDRESS,
 			 (rect->y1 >> 8) & 0xff, rect->y1 & 0xff,
 			 ((rect->y2 - 1) >> 8) & 0xff, (rect->y2 - 1) & 0xff);
 
-	ret = mipi_dbi_command_buf(mipi, MIPI_DCS_WRITE_MEMORY_START, tr,
+	ret = mipi_dbi_command_buf(dbi, MIPI_DCS_WRITE_MEMORY_START, tr,
 				   width * height * 2);
 err_msg:
 	if (ret)
@@ -356,6 +357,7 @@ static void mipi_dbi_blank(struct mipi_dbi *mipi)
 	u16 height = drm->mode_config.min_height;
 	u16 width = drm->mode_config.min_width;
 	size_t len = width * height * 2;
+	struct mipi_dbi *dbi = mipi;
 	int idx;
 
 	if (!drm_dev_enter(drm, &idx))
@@ -363,11 +365,11 @@ static void mipi_dbi_blank(struct mipi_dbi *mipi)
 
 	memset(mipi->tx_buf, 0, len);
 
-	mipi_dbi_command(mipi, MIPI_DCS_SET_COLUMN_ADDRESS, 0, 0,
+	mipi_dbi_command(dbi, MIPI_DCS_SET_COLUMN_ADDRESS, 0, 0,
 			 (width >> 8) & 0xFF, (width - 1) & 0xFF);
-	mipi_dbi_command(mipi, MIPI_DCS_SET_PAGE_ADDRESS, 0, 0,
+	mipi_dbi_command(dbi, MIPI_DCS_SET_PAGE_ADDRESS, 0, 0,
 			 (height >> 8) & 0xFF, (height - 1) & 0xFF);
-	mipi_dbi_command_buf(mipi, MIPI_DCS_WRITE_MEMORY_START,
+	mipi_dbi_command_buf(dbi, MIPI_DCS_WRITE_MEMORY_START,
 			     (u8 *)mipi->tx_buf, len);
 
 	drm_dev_exit(idx);
@@ -596,25 +598,25 @@ EXPORT_SYMBOL(mipi_dbi_release);
 
 /**
  * mipi_dbi_hw_reset - Hardware reset of controller
- * @mipi: MIPI DBI structure
+ * @dbi: MIPI DBI structure
  *
  * Reset controller if the &mipi_dbi->reset gpio is set.
  */
-void mipi_dbi_hw_reset(struct mipi_dbi *mipi)
+void mipi_dbi_hw_reset(struct mipi_dbi *dbi)
 {
-	if (!mipi->reset)
+	if (!dbi->reset)
 		return;
 
-	gpiod_set_value_cansleep(mipi->reset, 0);
+	gpiod_set_value_cansleep(dbi->reset, 0);
 	usleep_range(20, 1000);
-	gpiod_set_value_cansleep(mipi->reset, 1);
+	gpiod_set_value_cansleep(dbi->reset, 1);
 	msleep(120);
 }
 EXPORT_SYMBOL(mipi_dbi_hw_reset);
 
 /**
  * mipi_dbi_display_is_on - Check if display is on
- * @mipi: MIPI DBI structure
+ * @dbi: MIPI DBI structure
  *
  * This function checks the Power Mode register (if readable) to see if
  * display output is turned on. This can be used to see if the bootloader
@@ -624,11 +626,11 @@ EXPORT_SYMBOL(mipi_dbi_hw_reset);
  * Returns:
  * true if the display can be verified to be on, false otherwise.
  */
-bool mipi_dbi_display_is_on(struct mipi_dbi *mipi)
+bool mipi_dbi_display_is_on(struct mipi_dbi *dbi)
 {
 	u8 val;
 
-	if (mipi_dbi_command_read(mipi, MIPI_DCS_GET_POWER_MODE, &val))
+	if (mipi_dbi_command_read(dbi, MIPI_DCS_GET_POWER_MODE, &val))
 		return false;
 
 	val &= ~DCS_POWER_MODE_RESERVED_MASK;
@@ -647,6 +649,7 @@ EXPORT_SYMBOL(mipi_dbi_display_is_on);
 static int mipi_dbi_poweron_reset_conditional(struct mipi_dbi *mipi, bool cond)
 {
 	struct device *dev = mipi->drm.dev;
+	struct mipi_dbi *dbi = mipi;
 	int ret;
 
 	if (mipi->regulator) {
@@ -657,11 +660,11 @@ static int mipi_dbi_poweron_reset_conditional(struct mipi_dbi *mipi, bool cond)
 		}
 	}
 
-	if (cond && mipi_dbi_display_is_on(mipi))
+	if (cond && mipi_dbi_display_is_on(dbi))
 		return 1;
 
-	mipi_dbi_hw_reset(mipi);
-	ret = mipi_dbi_command(mipi, MIPI_DCS_SOFT_RESET);
+	mipi_dbi_hw_reset(dbi);
+	ret = mipi_dbi_command(dbi, MIPI_DCS_SOFT_RESET);
 	if (ret) {
 		DRM_DEV_ERROR(dev, "Failed to send reset command (%d)\n", ret);
 		if (mipi->regulator)
@@ -674,7 +677,7 @@ static int mipi_dbi_poweron_reset_conditional(struct mipi_dbi *mipi, bool cond)
 	 * per MIPI DSC spec should wait 5ms after soft reset. If we didn't,
 	 * we assume worst case and wait 120ms.
 	 */
-	if (mipi->reset)
+	if (dbi->reset)
 		usleep_range(5000, 20000);
 	else
 		msleep(120);
@@ -763,15 +766,15 @@ static bool mipi_dbi_machine_little_endian(void)
  *     76543210
  */
 
-static int mipi_dbi_spi1e_transfer(struct mipi_dbi *mipi, int dc,
+static int mipi_dbi_spi1e_transfer(struct mipi_dbi *dbi, int dc,
 				   const void *buf, size_t len,
 				   unsigned int bpw)
 {
 	bool swap_bytes = (bpw == 16 && mipi_dbi_machine_little_endian());
-	size_t chunk, max_chunk = mipi->tx_buf9_len;
-	struct spi_device *spi = mipi->spi;
+	size_t chunk, max_chunk = dbi->tx_buf9_len;
+	struct spi_device *spi = dbi->spi;
 	struct spi_transfer tr = {
-		.tx_buf = mipi->tx_buf9,
+		.tx_buf = dbi->tx_buf9,
 		.bits_per_word = 8,
 	};
 	struct spi_message m;
@@ -791,7 +794,7 @@ static int mipi_dbi_spi1e_transfer(struct mipi_dbi *mipi, int dc,
 			return -EINVAL;
 
 		/* Command: pad no-op's (zeroes) at beginning of block */
-		dst = mipi->tx_buf9;
+		dst = dbi->tx_buf9;
 		memset(dst, 0, 9);
 		dst[8] = *src;
 		tr.len = 9;
@@ -811,7 +814,7 @@ static int mipi_dbi_spi1e_transfer(struct mipi_dbi *mipi, int dc,
 
 		chunk = min(len, max_chunk);
 		len -= chunk;
-		dst = mipi->tx_buf9;
+		dst = dbi->tx_buf9;
 
 		if (chunk < 8) {
 			u8 val, carry = 0;
@@ -881,11 +884,11 @@ static int mipi_dbi_spi1e_transfer(struct mipi_dbi *mipi, int dc,
 	return 0;
 }
 
-static int mipi_dbi_spi1_transfer(struct mipi_dbi *mipi, int dc,
+static int mipi_dbi_spi1_transfer(struct mipi_dbi *dbi, int dc,
 				  const void *buf, size_t len,
 				  unsigned int bpw)
 {
-	struct spi_device *spi = mipi->spi;
+	struct spi_device *spi = dbi->spi;
 	struct spi_transfer tr = {
 		.bits_per_word = 9,
 	};
@@ -897,11 +900,11 @@ static int mipi_dbi_spi1_transfer(struct mipi_dbi *mipi, int dc,
 	int ret;
 
 	if (!spi_is_bpw_supported(spi, 9))
-		return mipi_dbi_spi1e_transfer(mipi, dc, buf, len, bpw);
+		return mipi_dbi_spi1e_transfer(dbi, dc, buf, len, bpw);
 
 	tr.speed_hz = mipi_dbi_spi_cmd_max_speed(spi, len);
-	max_chunk = mipi->tx_buf9_len;
-	dst16 = mipi->tx_buf9;
+	max_chunk = dbi->tx_buf9_len;
+	dst16 = dbi->tx_buf9;
 
 	if (drm_debug & DRM_UT_DRIVER)
 		pr_debug("[drm:%s] dc=%d, max_chunk=%zu, transfers:\n",
@@ -944,30 +947,30 @@ static int mipi_dbi_spi1_transfer(struct mipi_dbi *mipi, int dc,
 	return 0;
 }
 
-static int mipi_dbi_typec1_command(struct mipi_dbi *mipi, u8 *cmd,
+static int mipi_dbi_typec1_command(struct mipi_dbi *dbi, u8 *cmd,
 				   u8 *parameters, size_t num)
 {
 	unsigned int bpw = (*cmd == MIPI_DCS_WRITE_MEMORY_START) ? 16 : 8;
 	int ret;
 
-	if (mipi_dbi_command_is_read(mipi, *cmd))
+	if (mipi_dbi_command_is_read(dbi, *cmd))
 		return -ENOTSUPP;
 
 	MIPI_DBI_DEBUG_COMMAND(*cmd, parameters, num);
 
-	ret = mipi_dbi_spi1_transfer(mipi, 0, cmd, 1, 8);
+	ret = mipi_dbi_spi1_transfer(dbi, 0, cmd, 1, 8);
 	if (ret || !num)
 		return ret;
 
-	return mipi_dbi_spi1_transfer(mipi, 1, parameters, num, bpw);
+	return mipi_dbi_spi1_transfer(dbi, 1, parameters, num, bpw);
 }
 
 /* MIPI DBI Type C Option 3 */
 
-static int mipi_dbi_typec3_command_read(struct mipi_dbi *mipi, u8 *cmd,
+static int mipi_dbi_typec3_command_read(struct mipi_dbi *dbi, u8 *cmd,
 					u8 *data, size_t len)
 {
-	struct spi_device *spi = mipi->spi;
+	struct spi_device *spi = dbi->spi;
 	u32 speed_hz = min_t(u32, MIPI_DBI_MAX_SPI_READ_SPEED,
 			     spi->max_speed_hz / 2);
 	struct spi_transfer tr[2] = {
@@ -1004,7 +1007,7 @@ static int mipi_dbi_typec3_command_read(struct mipi_dbi *mipi, u8 *cmd,
 		return -ENOMEM;
 
 	tr[1].rx_buf = buf;
-	gpiod_set_value_cansleep(mipi->dc, 0);
+	gpiod_set_value_cansleep(dbi->dc, 0);
 
 	spi_message_init_with_transfers(&m, tr, ARRAY_SIZE(tr));
 	ret = spi_sync(spi, &m);
@@ -1028,41 +1031,41 @@ static int mipi_dbi_typec3_command_read(struct mipi_dbi *mipi, u8 *cmd,
 	return ret;
 }
 
-static int mipi_dbi_typec3_command(struct mipi_dbi *mipi, u8 *cmd,
+static int mipi_dbi_typec3_command(struct mipi_dbi *dbi, u8 *cmd,
 				   u8 *par, size_t num)
 {
-	struct spi_device *spi = mipi->spi;
+	struct spi_device *spi = dbi->spi;
 	unsigned int bpw = 8;
 	u32 speed_hz;
 	int ret;
 
-	if (mipi_dbi_command_is_read(mipi, *cmd))
-		return mipi_dbi_typec3_command_read(mipi, cmd, par, num);
+	if (mipi_dbi_command_is_read(dbi, *cmd))
+		return mipi_dbi_typec3_command_read(dbi, cmd, par, num);
 
 	MIPI_DBI_DEBUG_COMMAND(*cmd, par, num);
 
-	gpiod_set_value_cansleep(mipi->dc, 0);
+	gpiod_set_value_cansleep(dbi->dc, 0);
 	speed_hz = mipi_dbi_spi_cmd_max_speed(spi, 1);
 	ret = mipi_dbi_spi_transfer(spi, speed_hz, 8, cmd, 1);
 	if (ret || !num)
 		return ret;
 
-	if (*cmd == MIPI_DCS_WRITE_MEMORY_START && !mipi->swap_bytes)
+	if (*cmd == MIPI_DCS_WRITE_MEMORY_START && !dbi->swap_bytes)
 		bpw = 16;
 
-	gpiod_set_value_cansleep(mipi->dc, 1);
+	gpiod_set_value_cansleep(dbi->dc, 1);
 	speed_hz = mipi_dbi_spi_cmd_max_speed(spi, num);
 
 	return mipi_dbi_spi_transfer(spi, speed_hz, bpw, par, num);
 }
 
 /**
- * mipi_dbi_spi_init - Initialize MIPI DBI SPI interfaced controller
+ * mipi_dbi_spi_init - Initialize MIPI DBI SPI interface
  * @spi: SPI device
- * @mipi: &mipi_dbi structure to initialize
+ * @dbi: MIPI DBI structure to initialize
  * @dc: D/C gpio (optional)
  *
- * This function sets &mipi_dbi->command, enables &mipi->read_commands for the
+ * This function sets &mipi_dbi->command, enables &mipi_dbi->read_commands for the
  * usual read commands. It should be followed by a call to mipi_dbi_init() or
  * a driver-specific init.
  *
@@ -1078,7 +1081,7 @@ static int mipi_dbi_typec3_command(struct mipi_dbi *mipi, u8 *cmd,
  * Returns:
  * Zero on success, negative error code on failure.
  */
-int mipi_dbi_spi_init(struct spi_device *spi, struct mipi_dbi *mipi,
+int mipi_dbi_spi_init(struct spi_device *spi, struct mipi_dbi *dbi,
 		      struct gpio_desc *dc)
 {
 	struct device *dev = &spi->dev;
@@ -1102,23 +1105,23 @@ int mipi_dbi_spi_init(struct spi_device *spi, struct mipi_dbi *mipi,
 		}
 	}
 
-	mipi->spi = spi;
-	mipi->read_commands = mipi_dbi_dcs_read_commands;
+	dbi->spi = spi;
+	dbi->read_commands = mipi_dbi_dcs_read_commands;
 
 	if (dc) {
-		mipi->command = mipi_dbi_typec3_command;
-		mipi->dc = dc;
+		dbi->command = mipi_dbi_typec3_command;
+		dbi->dc = dc;
 		if (mipi_dbi_machine_little_endian() && !spi_is_bpw_supported(spi, 16))
-			mipi->swap_bytes = true;
+			dbi->swap_bytes = true;
 	} else {
-		mipi->command = mipi_dbi_typec1_command;
-		mipi->tx_buf9_len = SZ_16K;
-		mipi->tx_buf9 = devm_kmalloc(dev, mipi->tx_buf9_len, GFP_KERNEL);
-		if (!mipi->tx_buf9)
+		dbi->command = mipi_dbi_typec1_command;
+		dbi->tx_buf9_len = SZ_16K;
+		dbi->tx_buf9 = devm_kmalloc(dev, dbi->tx_buf9_len, GFP_KERNEL);
+		if (!dbi->tx_buf9)
 			return -ENOMEM;
 	}
 
-	mutex_init(&mipi->cmdlock);
+	mutex_init(&dbi->cmdlock);
 
 	DRM_DEBUG_DRIVER("SPI speed: %uMHz\n", spi->max_speed_hz / 1000000);
 
diff --git a/drivers/gpu/drm/tinydrm/st7586.c b/drivers/gpu/drm/tinydrm/st7586.c
index 4046b0fc3f7a..8339e7dc5d92 100644
--- a/drivers/gpu/drm/tinydrm/st7586.c
+++ b/drivers/gpu/drm/tinydrm/st7586.c
@@ -115,6 +115,7 @@ static int st7586_buf_copy(void *dst, struct drm_framebuffer *fb,
 static void st7586_fb_dirty(struct drm_framebuffer *fb, struct drm_rect *rect)
 {
 	struct mipi_dbi *mipi = drm_to_mipi_dbi(fb->dev);
+	struct mipi_dbi *dbi = mipi;
 	int start, end, idx, ret = 0;
 
 	if (!mipi->enabled)
@@ -137,14 +138,14 @@ static void st7586_fb_dirty(struct drm_framebuffer *fb, struct drm_rect *rect)
 	start = rect->x1 / 3;
 	end = rect->x2 / 3;
 
-	mipi_dbi_command(mipi, MIPI_DCS_SET_COLUMN_ADDRESS,
+	mipi_dbi_command(dbi, MIPI_DCS_SET_COLUMN_ADDRESS,
 			 (start >> 8) & 0xFF, start & 0xFF,
 			 (end >> 8) & 0xFF, (end - 1) & 0xFF);
-	mipi_dbi_command(mipi, MIPI_DCS_SET_PAGE_ADDRESS,
+	mipi_dbi_command(dbi, MIPI_DCS_SET_PAGE_ADDRESS,
 			 (rect->y1 >> 8) & 0xFF, rect->y1 & 0xFF,
 			 (rect->y2 >> 8) & 0xFF, (rect->y2 - 1) & 0xFF);
 
-	ret = mipi_dbi_command_buf(mipi, MIPI_DCS_WRITE_MEMORY_START,
+	ret = mipi_dbi_command_buf(dbi, MIPI_DCS_WRITE_MEMORY_START,
 				   (u8 *)mipi->tx_buf,
 				   (end - start) * (rect->y2 - rect->y1));
 err_msg:
@@ -178,6 +179,7 @@ static void st7586_pipe_enable(struct drm_simple_display_pipe *pipe,
 {
 	struct mipi_dbi *mipi = drm_to_mipi_dbi(pipe->crtc.dev);
 	struct drm_framebuffer *fb = plane_state->fb;
+	struct mipi_dbi *dbi = mipi;
 	struct drm_rect rect = {
 		.x1 = 0,
 		.x2 = fb->width,
@@ -196,29 +198,29 @@ static void st7586_pipe_enable(struct drm_simple_display_pipe *pipe,
 	if (ret)
 		goto out_exit;
 
-	mipi_dbi_command(mipi, ST7586_AUTO_READ_CTRL, 0x9f);
-	mipi_dbi_command(mipi, ST7586_OTP_RW_CTRL, 0x00);
+	mipi_dbi_command(dbi, ST7586_AUTO_READ_CTRL, 0x9f);
+	mipi_dbi_command(dbi, ST7586_OTP_RW_CTRL, 0x00);
 
 	msleep(10);
 
-	mipi_dbi_command(mipi, ST7586_OTP_READ);
+	mipi_dbi_command(dbi, ST7586_OTP_READ);
 
 	msleep(20);
 
-	mipi_dbi_command(mipi, ST7586_OTP_CTRL_OUT);
-	mipi_dbi_command(mipi, MIPI_DCS_EXIT_SLEEP_MODE);
-	mipi_dbi_command(mipi, MIPI_DCS_SET_DISPLAY_OFF);
+	mipi_dbi_command(dbi, ST7586_OTP_CTRL_OUT);
+	mipi_dbi_command(dbi, MIPI_DCS_EXIT_SLEEP_MODE);
+	mipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_OFF);
 
 	msleep(50);
 
-	mipi_dbi_command(mipi, ST7586_SET_VOP_OFFSET, 0x00);
-	mipi_dbi_command(mipi, ST7586_SET_VOP, 0xe3, 0x00);
-	mipi_dbi_command(mipi, ST7586_SET_BIAS_SYSTEM, 0x02);
-	mipi_dbi_command(mipi, ST7586_SET_BOOST_LEVEL, 0x04);
-	mipi_dbi_command(mipi, ST7586_ENABLE_ANALOG, 0x1d);
-	mipi_dbi_command(mipi, ST7586_SET_NLINE_INV, 0x00);
-	mipi_dbi_command(mipi, ST7586_DISP_MODE_GRAY);
-	mipi_dbi_command(mipi, ST7586_ENABLE_DDRAM, 0x02);
+	mipi_dbi_command(dbi, ST7586_SET_VOP_OFFSET, 0x00);
+	mipi_dbi_command(dbi, ST7586_SET_VOP, 0xe3, 0x00);
+	mipi_dbi_command(dbi, ST7586_SET_BIAS_SYSTEM, 0x02);
+	mipi_dbi_command(dbi, ST7586_SET_BOOST_LEVEL, 0x04);
+	mipi_dbi_command(dbi, ST7586_ENABLE_ANALOG, 0x1d);
+	mipi_dbi_command(dbi, ST7586_SET_NLINE_INV, 0x00);
+	mipi_dbi_command(dbi, ST7586_DISP_MODE_GRAY);
+	mipi_dbi_command(dbi, ST7586_ENABLE_DDRAM, 0x02);
 
 	switch (mipi->rotation) {
 	default:
@@ -234,19 +236,19 @@ static void st7586_pipe_enable(struct drm_simple_display_pipe *pipe,
 		addr_mode = ST7586_DISP_CTRL_MX;
 		break;
 	}
-	mipi_dbi_command(mipi, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);
+	mipi_dbi_command(dbi, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);
 
-	mipi_dbi_command(mipi, ST7586_SET_DISP_DUTY, 0x7f);
-	mipi_dbi_command(mipi, ST7586_SET_PART_DISP, 0xa0);
-	mipi_dbi_command(mipi, MIPI_DCS_SET_PARTIAL_AREA, 0x00, 0x00, 0x00, 0x77);
-	mipi_dbi_command(mipi, MIPI_DCS_EXIT_INVERT_MODE);
+	mipi_dbi_command(dbi, ST7586_SET_DISP_DUTY, 0x7f);
+	mipi_dbi_command(dbi, ST7586_SET_PART_DISP, 0xa0);
+	mipi_dbi_command(dbi, MIPI_DCS_SET_PARTIAL_AREA, 0x00, 0x00, 0x00, 0x77);
+	mipi_dbi_command(dbi, MIPI_DCS_EXIT_INVERT_MODE);
 
 	msleep(100);
 
 	mipi->enabled = true;
 	st7586_fb_dirty(fb, &rect);
 
-	mipi_dbi_command(mipi, MIPI_DCS_SET_DISPLAY_ON);
+	mipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_ON);
 out_exit:
 	drm_dev_exit(idx);
 }
@@ -318,6 +320,7 @@ static int st7586_probe(struct spi_device *spi)
 	struct device *dev = &spi->dev;
 	struct drm_device *drm;
 	struct mipi_dbi *mipi;
+	struct mipi_dbi *dbi;
 	struct gpio_desc *a0;
 	u32 rotation = 0;
 	size_t bufsize;
@@ -327,6 +330,7 @@ static int st7586_probe(struct spi_device *spi)
 	if (!mipi)
 		return -ENOMEM;
 
+	dbi = mipi;
 	drm = &mipi->drm;
 	ret = devm_drm_dev_init(dev, drm, &st7586_driver);
 	if (ret) {
@@ -338,10 +342,10 @@ static int st7586_probe(struct spi_device *spi)
 
 	bufsize = (st7586_mode.vdisplay + 2) / 3 * st7586_mode.hdisplay;
 
-	mipi->reset = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
-	if (IS_ERR(mipi->reset)) {
+	dbi->reset = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(dbi->reset)) {
 		DRM_DEV_ERROR(dev, "Failed to get gpio 'reset'\n");
-		return PTR_ERR(mipi->reset);
+		return PTR_ERR(dbi->reset);
 	}
 
 	a0 = devm_gpiod_get(dev, "a0", GPIOD_OUT_LOW);
@@ -352,12 +356,12 @@ static int st7586_probe(struct spi_device *spi)
 
 	device_property_read_u32(dev, "rotation", &rotation);
 
-	ret = mipi_dbi_spi_init(spi, mipi, a0);
+	ret = mipi_dbi_spi_init(spi, dbi, a0);
 	if (ret)
 		return ret;
 
 	/* Cannot read from this controller via SPI */
-	mipi->read_commands = NULL;
+	dbi->read_commands = NULL;
 
 	ret = mipi_dbi_init_with_formats(mipi, &st7586_pipe_funcs,
 					 st7586_formats, ARRAY_SIZE(st7586_formats),
@@ -372,7 +376,7 @@ static int st7586_probe(struct spi_device *spi)
 	 * bytes on little-endian systems and causes out of order data to be
 	 * sent to the display).
 	 */
-	mipi->swap_bytes = true;
+	dbi->swap_bytes = true;
 
 	drm_mode_config_reset(drm);
 
diff --git a/drivers/gpu/drm/tinydrm/st7735r.c b/drivers/gpu/drm/tinydrm/st7735r.c
index 151749035a19..4309ae299766 100644
--- a/drivers/gpu/drm/tinydrm/st7735r.c
+++ b/drivers/gpu/drm/tinydrm/st7735r.c
@@ -43,6 +43,7 @@ static void jd_t18003_t01_pipe_enable(struct drm_simple_display_pipe *pipe,
 				      struct drm_plane_state *plane_state)
 {
 	struct mipi_dbi *mipi = drm_to_mipi_dbi(pipe->crtc.dev);
+	struct mipi_dbi *dbi = mipi;
 	int ret, idx;
 	u8 addr_mode;
 
@@ -57,21 +58,21 @@ static void jd_t18003_t01_pipe_enable(struct drm_simple_display_pipe *pipe,
 
 	msleep(150);
 
-	mipi_dbi_command(mipi, MIPI_DCS_EXIT_SLEEP_MODE);
+	mipi_dbi_command(dbi, MIPI_DCS_EXIT_SLEEP_MODE);
 	msleep(500);
 
-	mipi_dbi_command(mipi, ST7735R_FRMCTR1, 0x01, 0x2c, 0x2d);
-	mipi_dbi_command(mipi, ST7735R_FRMCTR2, 0x01, 0x2c, 0x2d);
-	mipi_dbi_command(mipi, ST7735R_FRMCTR3, 0x01, 0x2c, 0x2d, 0x01, 0x2c,
+	mipi_dbi_command(dbi, ST7735R_FRMCTR1, 0x01, 0x2c, 0x2d);
+	mipi_dbi_command(dbi, ST7735R_FRMCTR2, 0x01, 0x2c, 0x2d);
+	mipi_dbi_command(dbi, ST7735R_FRMCTR3, 0x01, 0x2c, 0x2d, 0x01, 0x2c,
 			 0x2d);
-	mipi_dbi_command(mipi, ST7735R_INVCTR, 0x07);
-	mipi_dbi_command(mipi, ST7735R_PWCTR1, 0xa2, 0x02, 0x84);
-	mipi_dbi_command(mipi, ST7735R_PWCTR2, 0xc5);
-	mipi_dbi_command(mipi, ST7735R_PWCTR3, 0x0a, 0x00);
-	mipi_dbi_command(mipi, ST7735R_PWCTR4, 0x8a, 0x2a);
-	mipi_dbi_command(mipi, ST7735R_PWCTR5, 0x8a, 0xee);
-	mipi_dbi_command(mipi, ST7735R_VMCTR1, 0x0e);
-	mipi_dbi_command(mipi, MIPI_DCS_EXIT_INVERT_MODE);
+	mipi_dbi_command(dbi, ST7735R_INVCTR, 0x07);
+	mipi_dbi_command(dbi, ST7735R_PWCTR1, 0xa2, 0x02, 0x84);
+	mipi_dbi_command(dbi, ST7735R_PWCTR2, 0xc5);
+	mipi_dbi_command(dbi, ST7735R_PWCTR3, 0x0a, 0x00);
+	mipi_dbi_command(dbi, ST7735R_PWCTR4, 0x8a, 0x2a);
+	mipi_dbi_command(dbi, ST7735R_PWCTR5, 0x8a, 0xee);
+	mipi_dbi_command(dbi, ST7735R_VMCTR1, 0x0e);
+	mipi_dbi_command(dbi, MIPI_DCS_EXIT_INVERT_MODE);
 	switch (mipi->rotation) {
 	default:
 		addr_mode = ST7735R_MX | ST7735R_MY;
@@ -86,20 +87,20 @@ static void jd_t18003_t01_pipe_enable(struct drm_simple_display_pipe *pipe,
 		addr_mode = ST7735R_MY | ST7735R_MV;
 		break;
 	}
-	mipi_dbi_command(mipi, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);
-	mipi_dbi_command(mipi, MIPI_DCS_SET_PIXEL_FORMAT,
+	mipi_dbi_command(dbi, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);
+	mipi_dbi_command(dbi, MIPI_DCS_SET_PIXEL_FORMAT,
 			 MIPI_DCS_PIXEL_FMT_16BIT);
-	mipi_dbi_command(mipi, ST7735R_GAMCTRP1, 0x02, 0x1c, 0x07, 0x12, 0x37,
+	mipi_dbi_command(dbi, ST7735R_GAMCTRP1, 0x02, 0x1c, 0x07, 0x12, 0x37,
 			 0x32, 0x29, 0x2d, 0x29, 0x25, 0x2b, 0x39, 0x00, 0x01,
 			 0x03, 0x10);
-	mipi_dbi_command(mipi, ST7735R_GAMCTRN1, 0x03, 0x1d, 0x07, 0x06, 0x2e,
+	mipi_dbi_command(dbi, ST7735R_GAMCTRN1, 0x03, 0x1d, 0x07, 0x06, 0x2e,
 			 0x2c, 0x29, 0x2d, 0x2e, 0x2e, 0x37, 0x3f, 0x00, 0x00,
 			 0x02, 0x10);
-	mipi_dbi_command(mipi, MIPI_DCS_SET_DISPLAY_ON);
+	mipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_ON);
 
 	msleep(100);
 
-	mipi_dbi_command(mipi, MIPI_DCS_ENTER_NORMAL_MODE);
+	mipi_dbi_command(dbi, MIPI_DCS_ENTER_NORMAL_MODE);
 
 	msleep(20);
 
@@ -151,6 +152,7 @@ static int st7735r_probe(struct spi_device *spi)
 	struct device *dev = &spi->dev;
 	struct drm_device *drm;
 	struct mipi_dbi *mipi;
+	struct mipi_dbi *dbi;
 	struct gpio_desc *dc;
 	u32 rotation = 0;
 	int ret;
@@ -159,6 +161,7 @@ static int st7735r_probe(struct spi_device *spi)
 	if (!mipi)
 		return -ENOMEM;
 
+	dbi = mipi;
 	drm = &mipi->drm;
 	ret = devm_drm_dev_init(dev, drm, &st7735r_driver);
 	if (ret) {
@@ -168,10 +171,10 @@ static int st7735r_probe(struct spi_device *spi)
 
 	drm_mode_config_init(drm);
 
-	mipi->reset = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
-	if (IS_ERR(mipi->reset)) {
+	dbi->reset = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(dbi->reset)) {
 		DRM_DEV_ERROR(dev, "Failed to get gpio 'reset'\n");
-		return PTR_ERR(mipi->reset);
+		return PTR_ERR(dbi->reset);
 	}
 
 	dc = devm_gpiod_get(dev, "dc", GPIOD_OUT_LOW);
@@ -186,12 +189,12 @@ static int st7735r_probe(struct spi_device *spi)
 
 	device_property_read_u32(dev, "rotation", &rotation);
 
-	ret = mipi_dbi_spi_init(spi, mipi, dc);
+	ret = mipi_dbi_spi_init(spi, dbi, dc);
 	if (ret)
 		return ret;
 
 	/* Cannot read from Adafruit 1.8" display via SPI */
-	mipi->read_commands = NULL;
+	dbi->read_commands = NULL;
 
 	ret = mipi_dbi_init(mipi, &jd_t18003_t01_pipe_funcs, &jd_t18003_t01_mode, rotation);
 	if (ret)
diff --git a/include/drm/tinydrm/mipi-dbi.h b/include/drm/tinydrm/mipi-dbi.h
index 393323f87e12..04b54ec61bc2 100644
--- a/include/drm/tinydrm/mipi-dbi.h
+++ b/include/drm/tinydrm/mipi-dbi.h
@@ -59,7 +59,7 @@ struct mipi_dbi {
 	struct spi_device *spi;
 	bool enabled;
 	struct mutex cmdlock;
-	int (*command)(struct mipi_dbi *mipi, u8 *cmd, u8 *param, size_t num);
+	int (*command)(struct mipi_dbi *dbi, u8 *cmd, u8 *param, size_t num);
 	const u8 *read_commands;
 	struct gpio_desc *dc;
 	u16 *tx_buf;
@@ -77,7 +77,7 @@ static inline struct mipi_dbi *drm_to_mipi_dbi(struct drm_device *drm)
 	return container_of(drm, struct mipi_dbi, drm);
 }
 
-int mipi_dbi_spi_init(struct spi_device *spi, struct mipi_dbi *mipi,
+int mipi_dbi_spi_init(struct spi_device *spi, struct mipi_dbi *dbi,
 		      struct gpio_desc *dc);
 int mipi_dbi_init_with_formats(struct mipi_dbi *mipi,
 			       const struct drm_simple_display_pipe_funcs *funcs,
@@ -94,8 +94,8 @@ void mipi_dbi_enable_flush(struct mipi_dbi *mipi,
 			   struct drm_crtc_state *crtc_state,
 			   struct drm_plane_state *plan_state);
 void mipi_dbi_pipe_disable(struct drm_simple_display_pipe *pipe);
-void mipi_dbi_hw_reset(struct mipi_dbi *mipi);
-bool mipi_dbi_display_is_on(struct mipi_dbi *mipi);
+void mipi_dbi_hw_reset(struct mipi_dbi *dbi);
+bool mipi_dbi_display_is_on(struct mipi_dbi *dbi);
 int mipi_dbi_poweron_reset(struct mipi_dbi *mipi);
 int mipi_dbi_poweron_conditional_reset(struct mipi_dbi *mipi);
 
@@ -103,14 +103,14 @@ u32 mipi_dbi_spi_cmd_max_speed(struct spi_device *spi, size_t len);
 int mipi_dbi_spi_transfer(struct spi_device *spi, u32 speed_hz,
 			  u8 bpw, const void *buf, size_t len);
 
-int mipi_dbi_command_read(struct mipi_dbi *mipi, u8 cmd, u8 *val);
-int mipi_dbi_command_buf(struct mipi_dbi *mipi, u8 cmd, u8 *data, size_t len);
-int mipi_dbi_command_stackbuf(struct mipi_dbi *mipi, u8 cmd, u8 *data, size_t len);
+int mipi_dbi_command_read(struct mipi_dbi *dbi, u8 cmd, u8 *val);
+int mipi_dbi_command_buf(struct mipi_dbi *dbi, u8 cmd, u8 *data, size_t len);
+int mipi_dbi_command_stackbuf(struct mipi_dbi *dbi, u8 cmd, u8 *data, size_t len);
 int mipi_dbi_buf_copy(void *dst, struct drm_framebuffer *fb,
 		      struct drm_rect *clip, bool swap);
 /**
  * mipi_dbi_command - MIPI DCS command with optional parameter(s)
- * @mipi: MIPI structure
+ * @dbi: MIPI DBI structure
  * @cmd: Command
  * @seq...: Optional parameter(s)
  *
@@ -120,10 +120,10 @@ int mipi_dbi_buf_copy(void *dst, struct drm_framebuffer *fb,
  * Returns:
  * Zero on success, negative error code on failure.
  */
-#define mipi_dbi_command(mipi, cmd, seq...) \
+#define mipi_dbi_command(dbi, cmd, seq...) \
 ({ \
 	u8 d[] = { seq }; \
-	mipi_dbi_command_stackbuf(mipi, cmd, d, ARRAY_SIZE(d)); \
+	mipi_dbi_command_stackbuf(dbi, cmd, d, ARRAY_SIZE(d)); \
 })
 
 #ifdef CONFIG_DEBUG_FS
-- 
2.28.0


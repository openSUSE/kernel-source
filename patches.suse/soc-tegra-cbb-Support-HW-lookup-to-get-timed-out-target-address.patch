From: Sumit Gupta <sumitg@nvidia.com>
Date: Thu, 3 Jul 2025 16:08:26 +0530
Subject: soc/tegra: cbb: Support HW lookup to get timed out target address
Git-commit: 5f2c2c439983ca3a208a0175f7793c355fab8566
Patch-mainline: v6.17-rc1
References: jsc#PED-13694

Add support for hardware based lookup to get the address of the timed
out target node. This features is added in upcoming SoCs and avoids the
need for creating per fabric target_map tables in the driver.

Signed-off-by: Sumit Gupta <sumitg@nvidia.com>
Signed-off-by: Thierry Reding <treding@nvidia.com>
Acked-by: Stanimir Varbanov <svarbanov@suse.de>
---
 drivers/soc/tegra/cbb/tegra234-cbb.c |   41 ++++++++++++++++++++++++++++++-----
 1 file changed, 36 insertions(+), 5 deletions(-)

--- a/drivers/soc/tegra/cbb/tegra234-cbb.c
+++ b/drivers/soc/tegra/cbb/tegra234-cbb.c
@@ -30,13 +30,17 @@
 #define FABRIC_EN_CFG_ADDR_LOW_0		0x80
 #define FABRIC_EN_CFG_ADDR_HI_0			0x84
 
+#define FABRIC_EN_CFG_TARGET_NODE_ADDR_INDEX_0_0 0x100
+#define FABRIC_EN_CFG_TARGET_NODE_ADDR_LOW_0    0x140
+#define FABRIC_EN_CFG_TARGET_NODE_ADDR_HI_0     0x144
+
 #define FABRIC_MN_INITIATOR_ERR_EN_0		0x200
 #define FABRIC_MN_INITIATOR_ERR_FORCE_0		0x204
-#define FABRIC_MN_INITIATOR_ERR_STATUS_0		0x208
-#define FABRIC_MN_INITIATOR_ERR_OVERFLOW_STATUS_0	0x20c
+#define FABRIC_MN_INITIATOR_ERR_STATUS_0	0x208
+#define FABRIC_MN_INITIATOR_ERR_OVERFLOW_STATUS_0 0x20c
 
 #define FABRIC_MN_INITIATOR_LOG_ERR_STATUS_0	0x300
-#define FABRIC_MN_INITIATOR_LOG_ADDR_LOW_0		0x304
+#define FABRIC_MN_INITIATOR_LOG_ADDR_LOW_0	0x304
 #define FABRIC_MN_INITIATOR_LOG_ADDR_HIGH_0	0x308
 #define FABRIC_MN_INITIATOR_LOG_ATTRIBUTES0_0	0x30c
 #define FABRIC_MN_INITIATOR_LOG_ATTRIBUTES1_0	0x310
@@ -320,6 +324,23 @@ static void tegra234_sw_lookup_target_ti
 	}
 }
 
+static void tegra234_hw_lookup_target_timeout(struct seq_file *file, struct tegra234_cbb *cbb,
+					      u8 target_id, u8 fab_id)
+{
+	unsigned int notifier = cbb->fabric->notifier_offset;
+	u32 hi, lo;
+	u64 addr;
+
+	writel(target_id, cbb->regs + notifier + FABRIC_EN_CFG_TARGET_NODE_ADDR_INDEX_0_0);
+
+	hi = readl(cbb->regs + notifier + FABRIC_EN_CFG_TARGET_NODE_ADDR_HI_0);
+	lo = readl(cbb->regs + notifier + FABRIC_EN_CFG_TARGET_NODE_ADDR_LOW_0);
+
+	addr = (u64)hi << 32 | lo;
+
+	tegra_cbb_print_err(file, "\t  Target Node Addr : %#llx\n", addr);
+}
+
 static void tegra234_cbb_print_error(struct seq_file *file, struct tegra234_cbb *cbb, u32 status,
 				     u32 overflow)
 {
@@ -445,8 +466,18 @@ static void print_errlog_err(struct seq_
 	if (!cbb->fabric->fab_list[fab_id].is_lookup)
 		return;
 
-	if (!strcmp(cbb->fabric->errors[cbb->type].code, "TIMEOUT_ERR"))
-		tegra234_sw_lookup_target_timeout(file, cbb, target_id, fab_id);
+	/*
+	 * If is_lookup field is set in fabric_lookup table of soc data, it
+	 * means that address lookup of target is supported for Timeout errors.
+	 * If is_lookup is set and the target_map is not populated making
+	 * max_targets as zero, then it means HW lookup is to be performed.
+	 */
+	if (!strcmp(cbb->fabric->errors[cbb->type].code, "TIMEOUT_ERR")) {
+		if (cbb->fabric->fab_list[fab_id].max_targets)
+			tegra234_sw_lookup_target_timeout(file, cbb, target_id, fab_id);
+		else
+			tegra234_hw_lookup_target_timeout(file, cbb, target_id, fab_id);
+	}
 
 	return;
 }

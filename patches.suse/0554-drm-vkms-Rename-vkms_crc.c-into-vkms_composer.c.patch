From a4e7e98e90ebd9a801d6a383e1edd10b09d155ba Mon Sep 17 00:00:00 2001
From: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
Date: Tue, 25 Jun 2019 22:37:05 -0300
Subject: drm/vkms: Rename vkms_crc.c into vkms_composer.c
Git-commit: a4e7e98e90ebd9a801d6a383e1edd10b09d155ba
Patch-mainline: v5.4-rc1
References: bsc#1152472

As a preparation work for introducing writeback to vkms, this patch
renames the file vkms_crc.c into vkms_composer.c. Accordingly, it also
adjusts the functions and data structures to match the changes.

No functional change.

Signed-off-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
Link: https://patchwork.freedesktop.org/patch/msgid/dea62063077ebf5cc1dfce8876e56788d15367e6.1561491964.git.rodrigosiqueiramelo@gmail.com
Acked-by: Thomas Zimmermann <tzimmermann@suse.de>
---
 drivers/gpu/drm/vkms/Makefile        |   2 +-
 drivers/gpu/drm/vkms/vkms_composer.c | 246 +++++++++++++++++++++++++++
 drivers/gpu/drm/vkms/vkms_crc.c      | 244 --------------------------
 drivers/gpu/drm/vkms/vkms_crtc.c     |  30 ++--
 drivers/gpu/drm/vkms/vkms_drv.c      |   4 +-
 drivers/gpu/drm/vkms/vkms_drv.h      |  28 +--
 drivers/gpu/drm/vkms/vkms_plane.c    |  36 ++--
 7 files changed, 297 insertions(+), 293 deletions(-)
 create mode 100644 drivers/gpu/drm/vkms/vkms_composer.c
 delete mode 100644 drivers/gpu/drm/vkms/vkms_crc.c

diff --git a/drivers/gpu/drm/vkms/Makefile b/drivers/gpu/drm/vkms/Makefile
index 89f09bec7b23..0b767d7efa24 100644
--- a/drivers/gpu/drm/vkms/Makefile
+++ b/drivers/gpu/drm/vkms/Makefile
@@ -1,4 +1,4 @@
 # SPDX-License-Identifier: GPL-2.0-only
-vkms-y := vkms_drv.o vkms_plane.o vkms_output.o vkms_crtc.o vkms_gem.o vkms_crc.o
+vkms-y := vkms_drv.o vkms_plane.o vkms_output.o vkms_crtc.o vkms_gem.o vkms_composer.o
 
 obj-$(CONFIG_DRM_VKMS) += vkms.o
diff --git a/drivers/gpu/drm/vkms/vkms_composer.c b/drivers/gpu/drm/vkms/vkms_composer.c
new file mode 100644
index 000000000000..eb7ea8be1f98
--- /dev/null
+++ b/drivers/gpu/drm/vkms/vkms_composer.c
@@ -0,0 +1,246 @@
+// SPDX-License-Identifier: GPL-2.0+
+
+#include "vkms_drv.h"
+#include <linux/crc32.h>
+#include <drm/drm_atomic.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_gem_framebuffer_helper.h>
+
+/**
+ * compute_crc - Compute CRC value on output frame
+ *
+ * @vaddr_out: address to final framebuffer
+ * @composer: framebuffer's metadata
+ *
+ * returns CRC value computed using crc32 on the visible portion of
+ * the final framebuffer at vaddr_out
+ */
+static uint32_t compute_crc(void *vaddr_out, struct vkms_composer *composer)
+{
+	int i, j, src_offset;
+	int x_src = composer->src.x1 >> 16;
+	int y_src = composer->src.y1 >> 16;
+	int h_src = drm_rect_height(&composer->src) >> 16;
+	int w_src = drm_rect_width(&composer->src) >> 16;
+	u32 crc = 0;
+
+	for (i = y_src; i < y_src + h_src; ++i) {
+		for (j = x_src; j < x_src + w_src; ++j) {
+			src_offset = composer->offset
+				     + (i * composer->pitch)
+				     + (j * composer->cpp);
+			/* XRGB format ignores Alpha channel */
+			memset(vaddr_out + src_offset + 24, 0,  8);
+			crc = crc32_le(crc, vaddr_out + src_offset,
+				       sizeof(u32));
+		}
+	}
+
+	return crc;
+}
+
+/**
+ * blend - belnd value at vaddr_src with value at vaddr_dst
+ * @vaddr_dst: destination address
+ * @vaddr_src: source address
+ * @dest_composer: destination framebuffer's metadata
+ * @src_composer: source framebuffer's metadata
+ *
+ * Blend value at vaddr_src with value at vaddr_dst.
+ * Currently, this function write value at vaddr_src on value
+ * at vaddr_dst using buffer's metadata to locate the new values
+ * from vaddr_src and their distenation at vaddr_dst.
+ *
+ * Todo: Use the alpha value to blend vaddr_src with vaddr_dst
+ *	 instead of overwriting it.
+ */
+static void blend(void *vaddr_dst, void *vaddr_src,
+		  struct vkms_composer *dest_composer,
+		  struct vkms_composer *src_composer)
+{
+	int i, j, j_dst, i_dst;
+	int offset_src, offset_dst;
+
+	int x_src = src_composer->src.x1 >> 16;
+	int y_src = src_composer->src.y1 >> 16;
+
+	int x_dst = src_composer->dst.x1;
+	int y_dst = src_composer->dst.y1;
+	int h_dst = drm_rect_height(&src_composer->dst);
+	int w_dst = drm_rect_width(&src_composer->dst);
+
+	int y_limit = y_src + h_dst;
+	int x_limit = x_src + w_dst;
+
+	for (i = y_src, i_dst = y_dst; i < y_limit; ++i) {
+		for (j = x_src, j_dst = x_dst; j < x_limit; ++j) {
+			offset_dst = dest_composer->offset
+				     + (i_dst * dest_composer->pitch)
+				     + (j_dst++ * dest_composer->cpp);
+			offset_src = src_composer->offset
+				     + (i * src_composer->pitch)
+				     + (j * src_composer->cpp);
+
+			memcpy(vaddr_dst + offset_dst,
+			       vaddr_src + offset_src, sizeof(u32));
+		}
+		i_dst++;
+	}
+}
+
+static void compose_cursor(struct vkms_composer *cursor_composer,
+			   struct vkms_composer *primary_composer,
+			   void *vaddr_out)
+{
+	struct drm_gem_object *cursor_obj;
+	struct vkms_gem_object *cursor_vkms_obj;
+
+	cursor_obj = drm_gem_fb_get_obj(&cursor_composer->fb, 0);
+	cursor_vkms_obj = drm_gem_to_vkms_gem(cursor_obj);
+
+	if (WARN_ON(!cursor_vkms_obj->vaddr))
+		return;
+
+	blend(vaddr_out, cursor_vkms_obj->vaddr,
+	      primary_composer, cursor_composer);
+}
+
+static uint32_t _vkms_get_crc(struct vkms_composer *primary_composer,
+			      struct vkms_composer *cursor_composer)
+{
+	struct drm_framebuffer *fb = &primary_composer->fb;
+	struct drm_gem_object *gem_obj = drm_gem_fb_get_obj(fb, 0);
+	struct vkms_gem_object *vkms_obj = drm_gem_to_vkms_gem(gem_obj);
+	void *vaddr_out = kzalloc(vkms_obj->gem.size, GFP_KERNEL);
+	u32 crc = 0;
+
+	if (!vaddr_out) {
+		DRM_ERROR("Failed to allocate memory for output frame.");
+		return 0;
+	}
+
+	if (WARN_ON(!vkms_obj->vaddr)) {
+		kfree(vaddr_out);
+		return crc;
+	}
+
+	memcpy(vaddr_out, vkms_obj->vaddr, vkms_obj->gem.size);
+
+	if (cursor_composer)
+		compose_cursor(cursor_composer, primary_composer, vaddr_out);
+
+	crc = compute_crc(vaddr_out, primary_composer);
+
+	kfree(vaddr_out);
+
+	return crc;
+}
+
+/**
+ * vkms_composer_worker - ordered work_struct to compute CRC
+ *
+ * @work: work_struct
+ *
+ * Work handler for composing and computing CRCs. work_struct scheduled in
+ * an ordered workqueue that's periodically scheduled to run by
+ * _vblank_handle() and flushed at vkms_atomic_crtc_destroy_state().
+ */
+void vkms_composer_worker(struct work_struct *work)
+{
+	struct vkms_crtc_state *crtc_state = container_of(work,
+						struct vkms_crtc_state,
+						composer_work);
+	struct drm_crtc *crtc = crtc_state->base.crtc;
+	struct vkms_output *out = drm_crtc_to_vkms_output(crtc);
+	struct vkms_composer *primary_composer = NULL;
+	struct vkms_composer *cursor_composer = NULL;
+	u32 crc32 = 0;
+	u64 frame_start, frame_end;
+	bool crc_pending;
+
+	spin_lock_irq(&out->composer_lock);
+	frame_start = crtc_state->frame_start;
+	frame_end = crtc_state->frame_end;
+	crc_pending = crtc_state->crc_pending;
+	crtc_state->frame_start = 0;
+	crtc_state->frame_end = 0;
+	crtc_state->crc_pending = false;
+	spin_unlock_irq(&out->composer_lock);
+
+	/*
+	 * We raced with the vblank hrtimer and previous work already computed
+	 * the crc, nothing to do.
+	 */
+	if (!crc_pending)
+		return;
+
+	if (crtc_state->num_active_planes >= 1)
+		primary_composer = crtc_state->active_planes[0]->composer;
+
+	if (crtc_state->num_active_planes == 2)
+		cursor_composer = crtc_state->active_planes[1]->composer;
+
+	if (primary_composer)
+		crc32 = _vkms_get_crc(primary_composer, cursor_composer);
+
+	/*
+	 * The worker can fall behind the vblank hrtimer, make sure we catch up.
+	 */
+	while (frame_start <= frame_end)
+		drm_crtc_add_crc_entry(crtc, true, frame_start++, &crc32);
+}
+
+static const char * const pipe_crc_sources[] = {"auto"};
+
+const char *const *vkms_get_crc_sources(struct drm_crtc *crtc,
+					size_t *count)
+{
+	*count = ARRAY_SIZE(pipe_crc_sources);
+	return pipe_crc_sources;
+}
+
+static int vkms_crc_parse_source(const char *src_name, bool *enabled)
+{
+	int ret = 0;
+
+	if (!src_name) {
+		*enabled = false;
+	} else if (strcmp(src_name, "auto") == 0) {
+		*enabled = true;
+	} else {
+		*enabled = false;
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+int vkms_verify_crc_source(struct drm_crtc *crtc, const char *src_name,
+			   size_t *values_cnt)
+{
+	bool enabled;
+
+	if (vkms_crc_parse_source(src_name, &enabled) < 0) {
+		DRM_DEBUG_DRIVER("unknown source %s\n", src_name);
+		return -EINVAL;
+	}
+
+	*values_cnt = 1;
+
+	return 0;
+}
+
+int vkms_set_crc_source(struct drm_crtc *crtc, const char *src_name)
+{
+	struct vkms_output *out = drm_crtc_to_vkms_output(crtc);
+	bool enabled = false;
+	int ret = 0;
+
+	ret = vkms_crc_parse_source(src_name, &enabled);
+
+	spin_lock_irq(&out->lock);
+	out->composer_enabled = enabled;
+	spin_unlock_irq(&out->lock);
+
+	return ret;
+}
diff --git a/drivers/gpu/drm/vkms/vkms_crc.c b/drivers/gpu/drm/vkms/vkms_crc.c
deleted file mode 100644
index 30b048b67a32..000000000000
--- a/drivers/gpu/drm/vkms/vkms_crc.c
+++ /dev/null
@@ -1,244 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-
-#include "vkms_drv.h"
-#include <linux/crc32.h>
-#include <drm/drm_atomic.h>
-#include <drm/drm_atomic_helper.h>
-#include <drm/drm_gem_framebuffer_helper.h>
-
-/**
- * compute_crc - Compute CRC value on output frame
- *
- * @vaddr_out: address to final framebuffer
- * @crc_out: framebuffer's metadata
- *
- * returns CRC value computed using crc32 on the visible portion of
- * the final framebuffer at vaddr_out
- */
-static uint32_t compute_crc(void *vaddr_out, struct vkms_crc_data *crc_out)
-{
-	int i, j, src_offset;
-	int x_src = crc_out->src.x1 >> 16;
-	int y_src = crc_out->src.y1 >> 16;
-	int h_src = drm_rect_height(&crc_out->src) >> 16;
-	int w_src = drm_rect_width(&crc_out->src) >> 16;
-	u32 crc = 0;
-
-	for (i = y_src; i < y_src + h_src; ++i) {
-		for (j = x_src; j < x_src + w_src; ++j) {
-			src_offset = crc_out->offset
-				     + (i * crc_out->pitch)
-				     + (j * crc_out->cpp);
-			/* XRGB format ignores Alpha channel */
-			memset(vaddr_out + src_offset + 24, 0,  8);
-			crc = crc32_le(crc, vaddr_out + src_offset,
-				       sizeof(u32));
-		}
-	}
-
-	return crc;
-}
-
-/**
- * blend - belnd value at vaddr_src with value at vaddr_dst
- * @vaddr_dst: destination address
- * @vaddr_src: source address
- * @crc_dst: destination framebuffer's metadata
- * @crc_src: source framebuffer's metadata
- *
- * Blend value at vaddr_src with value at vaddr_dst.
- * Currently, this function write value at vaddr_src on value
- * at vaddr_dst using buffer's metadata to locate the new values
- * from vaddr_src and their distenation at vaddr_dst.
- *
- * Todo: Use the alpha value to blend vaddr_src with vaddr_dst
- *	 instead of overwriting it.
- */
-static void blend(void *vaddr_dst, void *vaddr_src,
-		  struct vkms_crc_data *crc_dst,
-		  struct vkms_crc_data *crc_src)
-{
-	int i, j, j_dst, i_dst;
-	int offset_src, offset_dst;
-
-	int x_src = crc_src->src.x1 >> 16;
-	int y_src = crc_src->src.y1 >> 16;
-
-	int x_dst = crc_src->dst.x1;
-	int y_dst = crc_src->dst.y1;
-	int h_dst = drm_rect_height(&crc_src->dst);
-	int w_dst = drm_rect_width(&crc_src->dst);
-
-	int y_limit = y_src + h_dst;
-	int x_limit = x_src + w_dst;
-
-	for (i = y_src, i_dst = y_dst; i < y_limit; ++i) {
-		for (j = x_src, j_dst = x_dst; j < x_limit; ++j) {
-			offset_dst = crc_dst->offset
-				     + (i_dst * crc_dst->pitch)
-				     + (j_dst++ * crc_dst->cpp);
-			offset_src = crc_src->offset
-				     + (i * crc_src->pitch)
-				     + (j * crc_src->cpp);
-
-			memcpy(vaddr_dst + offset_dst,
-			       vaddr_src + offset_src, sizeof(u32));
-		}
-		i_dst++;
-	}
-}
-
-static void compose_cursor(struct vkms_crc_data *cursor_crc,
-			   struct vkms_crc_data *primary_crc, void *vaddr_out)
-{
-	struct drm_gem_object *cursor_obj;
-	struct vkms_gem_object *cursor_vkms_obj;
-
-	cursor_obj = drm_gem_fb_get_obj(&cursor_crc->fb, 0);
-	cursor_vkms_obj = drm_gem_to_vkms_gem(cursor_obj);
-
-	if (WARN_ON(!cursor_vkms_obj->vaddr))
-		return;
-
-	blend(vaddr_out, cursor_vkms_obj->vaddr, primary_crc, cursor_crc);
-}
-
-static uint32_t _vkms_get_crc(struct vkms_crc_data *primary_crc,
-			      struct vkms_crc_data *cursor_crc)
-{
-	struct drm_framebuffer *fb = &primary_crc->fb;
-	struct drm_gem_object *gem_obj = drm_gem_fb_get_obj(fb, 0);
-	struct vkms_gem_object *vkms_obj = drm_gem_to_vkms_gem(gem_obj);
-	void *vaddr_out = kzalloc(vkms_obj->gem.size, GFP_KERNEL);
-	u32 crc = 0;
-
-	if (!vaddr_out) {
-		DRM_ERROR("Failed to allocate memory for output frame.");
-		return 0;
-	}
-
-	if (WARN_ON(!vkms_obj->vaddr)) {
-		kfree(vaddr_out);
-		return crc;
-	}
-
-	memcpy(vaddr_out, vkms_obj->vaddr, vkms_obj->gem.size);
-
-	if (cursor_crc)
-		compose_cursor(cursor_crc, primary_crc, vaddr_out);
-
-	crc = compute_crc(vaddr_out, primary_crc);
-
-	kfree(vaddr_out);
-
-	return crc;
-}
-
-/**
- * vkms_crc_work_handle - ordered work_struct to compute CRC
- *
- * @work: work_struct
- *
- * Work handler for computing CRCs. work_struct scheduled in
- * an ordered workqueue that's periodically scheduled to run by
- * _vblank_handle() and flushed at vkms_atomic_crtc_destroy_state().
- */
-void vkms_crc_work_handle(struct work_struct *work)
-{
-	struct vkms_crtc_state *crtc_state = container_of(work,
-						struct vkms_crtc_state,
-						crc_work);
-	struct drm_crtc *crtc = crtc_state->base.crtc;
-	struct vkms_output *out = drm_crtc_to_vkms_output(crtc);
-	struct vkms_crc_data *primary_crc = NULL;
-	struct vkms_crc_data *cursor_crc = NULL;
-	u32 crc32 = 0;
-	u64 frame_start, frame_end;
-	bool crc_pending;
-
-	spin_lock_irq(&out->crc_lock);
-	frame_start = crtc_state->frame_start;
-	frame_end = crtc_state->frame_end;
-	crc_pending = crtc_state->crc_pending;
-	crtc_state->frame_start = 0;
-	crtc_state->frame_end = 0;
-	crtc_state->crc_pending = false;
-	spin_unlock_irq(&out->crc_lock);
-
-	/*
-	 * We raced with the vblank hrtimer and previous work already computed
-	 * the crc, nothing to do.
-	 */
-	if (!crc_pending)
-		return;
-
-	if (crtc_state->num_active_planes >= 1)
-		primary_crc = crtc_state->active_planes[0]->crc_data;
-
-	if (crtc_state->num_active_planes == 2)
-		cursor_crc = crtc_state->active_planes[1]->crc_data;
-
-	if (primary_crc)
-		crc32 = _vkms_get_crc(primary_crc, cursor_crc);
-
-	/*
-	 * The worker can fall behind the vblank hrtimer, make sure we catch up.
-	 */
-	while (frame_start <= frame_end)
-		drm_crtc_add_crc_entry(crtc, true, frame_start++, &crc32);
-}
-
-static const char * const pipe_crc_sources[] = {"auto"};
-
-const char *const *vkms_get_crc_sources(struct drm_crtc *crtc,
-					size_t *count)
-{
-	*count = ARRAY_SIZE(pipe_crc_sources);
-	return pipe_crc_sources;
-}
-
-static int vkms_crc_parse_source(const char *src_name, bool *enabled)
-{
-	int ret = 0;
-
-	if (!src_name) {
-		*enabled = false;
-	} else if (strcmp(src_name, "auto") == 0) {
-		*enabled = true;
-	} else {
-		*enabled = false;
-		ret = -EINVAL;
-	}
-
-	return ret;
-}
-
-int vkms_verify_crc_source(struct drm_crtc *crtc, const char *src_name,
-			   size_t *values_cnt)
-{
-	bool enabled;
-
-	if (vkms_crc_parse_source(src_name, &enabled) < 0) {
-		DRM_DEBUG_DRIVER("unknown source %s\n", src_name);
-		return -EINVAL;
-	}
-
-	*values_cnt = 1;
-
-	return 0;
-}
-
-int vkms_set_crc_source(struct drm_crtc *crtc, const char *src_name)
-{
-	struct vkms_output *out = drm_crtc_to_vkms_output(crtc);
-	bool enabled = false;
-	int ret = 0;
-
-	ret = vkms_crc_parse_source(src_name, &enabled);
-
-	spin_lock_irq(&out->lock);
-	out->crc_enabled = enabled;
-	spin_unlock_irq(&out->lock);
-
-	return ret;
-}
diff --git a/drivers/gpu/drm/vkms/vkms_crtc.c b/drivers/gpu/drm/vkms/vkms_crtc.c
index 7e2a081f3764..49a8ec2cb1c1 100644
--- a/drivers/gpu/drm/vkms/vkms_crtc.c
+++ b/drivers/gpu/drm/vkms/vkms_crtc.c
@@ -24,14 +24,14 @@ static enum hrtimer_restart vkms_vblank_simulate(struct hrtimer *timer)
 	if (!ret)
 		DRM_ERROR("vkms failure on handling vblank");
 
-	state = output->crc_state;
-	if (state && output->crc_enabled) {
+	state = output->composer_state;
+	if (state && output->composer_enabled) {
 		u64 frame = drm_crtc_accurate_vblank_count(crtc);
 
-		/* update frame_start only if a queued vkms_crc_work_handle()
+		/* update frame_start only if a queued vkms_composer_worker()
 		 * has read the data
 		 */
-		spin_lock(&output->crc_lock);
+		spin_lock(&output->composer_lock);
 		if (!state->crc_pending)
 			state->frame_start = frame;
 		else
@@ -39,11 +39,11 @@ static enum hrtimer_restart vkms_vblank_simulate(struct hrtimer *timer)
 					 state->frame_start, frame);
 		state->frame_end = frame;
 		state->crc_pending = true;
-		spin_unlock(&output->crc_lock);
+		spin_unlock(&output->composer_lock);
 
-		ret = queue_work(output->crc_workq, &state->crc_work);
+		ret = queue_work(output->composer_workq, &state->composer_work);
 		if (!ret)
-			DRM_DEBUG_DRIVER("vkms_crc_work_handle already queued\n");
+			DRM_DEBUG_DRIVER("Composer worker already queued\n");
 	}
 
 	spin_unlock(&output->lock);
@@ -114,7 +114,7 @@ vkms_atomic_crtc_duplicate_state(struct drm_crtc *crtc)
 
 	__drm_atomic_helper_crtc_duplicate_state(crtc, &vkms_state->base);
 
-	INIT_WORK(&vkms_state->crc_work, vkms_crc_work_handle);
+	INIT_WORK(&vkms_state->composer_work, vkms_composer_worker);
 
 	return &vkms_state->base;
 }
@@ -126,7 +126,7 @@ static void vkms_atomic_crtc_destroy_state(struct drm_crtc *crtc,
 
 	__drm_atomic_helper_crtc_destroy_state(state);
 
-	WARN_ON(work_pending(&vkms_state->crc_work));
+	WARN_ON(work_pending(&vkms_state->composer_work));
 	kfree(vkms_state->active_planes);
 	kfree(vkms_state);
 }
@@ -141,7 +141,7 @@ static void vkms_atomic_crtc_reset(struct drm_crtc *crtc)
 
 	__drm_atomic_helper_crtc_reset(crtc, &vkms_state->base);
 	if (vkms_state)
-		INIT_WORK(&vkms_state->crc_work, vkms_crc_work_handle);
+		INIT_WORK(&vkms_state->composer_work, vkms_composer_worker);
 }
 
 static const struct drm_crtc_funcs vkms_crtc_funcs = {
@@ -222,7 +222,7 @@ static void vkms_crtc_atomic_begin(struct drm_crtc *crtc,
 	struct vkms_output *vkms_output = drm_crtc_to_vkms_output(crtc);
 
 	/* This lock is held across the atomic commit to block vblank timer
-	 * from scheduling vkms_crc_work_handle until the crc_data is updated
+	 * from scheduling vkms_composer_worker until the composer is updated
 	 */
 	spin_lock_irq(&vkms_output->lock);
 }
@@ -245,7 +245,7 @@ static void vkms_crtc_atomic_flush(struct drm_crtc *crtc,
 		crtc->state->event = NULL;
 	}
 
-	vkms_output->crc_state = to_vkms_crtc_state(crtc->state);
+	vkms_output->composer_state = to_vkms_crtc_state(crtc->state);
 
 	spin_unlock_irq(&vkms_output->lock);
 }
@@ -274,10 +274,10 @@ int vkms_crtc_init(struct drm_device *dev, struct drm_crtc *crtc,
 	drm_crtc_helper_add(crtc, &vkms_crtc_helper_funcs);
 
 	spin_lock_init(&vkms_out->lock);
-	spin_lock_init(&vkms_out->crc_lock);
+	spin_lock_init(&vkms_out->composer_lock);
 
-	vkms_out->crc_workq = alloc_ordered_workqueue("vkms_crc_workq", 0);
-	if (!vkms_out->crc_workq)
+	vkms_out->composer_workq = alloc_ordered_workqueue("vkms_composer", 0);
+	if (!vkms_out->composer_workq)
 		return -ENOMEM;
 
 	return ret;
diff --git a/drivers/gpu/drm/vkms/vkms_drv.c b/drivers/gpu/drm/vkms/vkms_drv.c
index 966b3d653189..ac790b6527e4 100644
--- a/drivers/gpu/drm/vkms/vkms_drv.c
+++ b/drivers/gpu/drm/vkms/vkms_drv.c
@@ -56,7 +56,7 @@ static void vkms_release(struct drm_device *dev)
 	drm_atomic_helper_shutdown(&vkms->drm);
 	drm_mode_config_cleanup(&vkms->drm);
 	drm_dev_fini(&vkms->drm);
-	destroy_workqueue(vkms->output.crc_workq);
+	destroy_workqueue(vkms->output.composer_workq);
 }
 
 static void vkms_atomic_commit_tail(struct drm_atomic_state *old_state)
@@ -82,7 +82,7 @@ static void vkms_atomic_commit_tail(struct drm_atomic_state *old_state)
 		struct vkms_crtc_state *vkms_state =
 			to_vkms_crtc_state(old_crtc_state);
 
-		flush_work(&vkms_state->crc_work);
+		flush_work(&vkms_state->composer_work);
 	}
 
 	drm_atomic_helper_cleanup_planes(dev, old_state);
diff --git a/drivers/gpu/drm/vkms/vkms_drv.h b/drivers/gpu/drm/vkms/vkms_drv.h
index e2d1aa089dec..fc6cda164336 100644
--- a/drivers/gpu/drm/vkms/vkms_drv.h
+++ b/drivers/gpu/drm/vkms/vkms_drv.h
@@ -20,7 +20,7 @@
 
 extern bool enable_cursor;
 
-struct vkms_crc_data {
+struct vkms_composer {
 	struct drm_framebuffer fb;
 	struct drm_rect src, dst;
 	unsigned int offset;
@@ -31,29 +31,29 @@ struct vkms_crc_data {
 /**
  * vkms_plane_state - Driver specific plane state
  * @base: base plane state
- * @crc_data: data required for CRC computation
+ * @composer: data required for composing computation
  */
 struct vkms_plane_state {
 	struct drm_plane_state base;
-	struct vkms_crc_data *crc_data;
+	struct vkms_composer *composer;
 };
 
 /**
  * vkms_crtc_state - Driver specific CRTC state
  * @base: base CRTC state
- * @crc_work: work struct to compute and add CRC entries
+ * @composer_work: work struct to compose and add CRC entries
  * @n_frame_start: start frame number for computed CRC
  * @n_frame_end: end frame number for computed CRC
  */
 struct vkms_crtc_state {
 	struct drm_crtc_state base;
-	struct work_struct crc_work;
+	struct work_struct composer_work;
 
 	int num_active_planes;
 	/* stack of active planes for crc computation, should be in z order */
 	struct vkms_plane_state **active_planes;
 
-	/* below three are protected by vkms_output.crc_lock */
+	/* below three are protected by vkms_output.composer_lock */
 	bool crc_pending;
 	u64 frame_start;
 	u64 frame_end;
@@ -66,16 +66,16 @@ struct vkms_output {
 	struct hrtimer vblank_hrtimer;
 	ktime_t period_ns;
 	struct drm_pending_vblank_event *event;
-	/* ordered wq for crc_work */
-	struct workqueue_struct *crc_workq;
-	/* protects concurrent access to crc_data */
+	/* ordered wq for composer_work */
+	struct workqueue_struct *composer_workq;
+	/* protects concurrent access to composer */
 	spinlock_t lock;
 
 	/* protected by @lock */
-	bool crc_enabled;
-	struct vkms_crtc_state *crc_state;
+	bool composer_enabled;
+	struct vkms_crtc_state *composer_state;
 
-	spinlock_t crc_lock;
+	spinlock_t composer_lock;
 };
 
 struct vkms_device {
@@ -143,6 +143,8 @@ const char *const *vkms_get_crc_sources(struct drm_crtc *crtc,
 int vkms_set_crc_source(struct drm_crtc *crtc, const char *src_name);
 int vkms_verify_crc_source(struct drm_crtc *crtc, const char *source_name,
 			   size_t *values_cnt);
-void vkms_crc_work_handle(struct work_struct *work);
+
+/* Composer Support */
+void vkms_composer_worker(struct work_struct *work);
 
 #endif /* _VKMS_DRV_H_ */
diff --git a/drivers/gpu/drm/vkms/vkms_plane.c b/drivers/gpu/drm/vkms/vkms_plane.c
index 18c630cfc485..8b60d3434d75 100644
--- a/drivers/gpu/drm/vkms/vkms_plane.c
+++ b/drivers/gpu/drm/vkms/vkms_plane.c
@@ -18,20 +18,20 @@ static struct drm_plane_state *
 vkms_plane_duplicate_state(struct drm_plane *plane)
 {
 	struct vkms_plane_state *vkms_state;
-	struct vkms_crc_data *crc_data;
+	struct vkms_composer *composer;
 
 	vkms_state = kzalloc(sizeof(*vkms_state), GFP_KERNEL);
 	if (!vkms_state)
 		return NULL;
 
-	crc_data = kzalloc(sizeof(*crc_data), GFP_KERNEL);
-	if (!crc_data) {
-		DRM_DEBUG_KMS("Couldn't allocate crc_data\n");
+	composer = kzalloc(sizeof(*composer), GFP_KERNEL);
+	if (!composer) {
+		DRM_DEBUG_KMS("Couldn't allocate composer\n");
 		kfree(vkms_state);
 		return NULL;
 	}
 
-	vkms_state->crc_data = crc_data;
+	vkms_state->composer = composer;
 
 	__drm_atomic_helper_plane_duplicate_state(plane,
 						  &vkms_state->base);
@@ -49,12 +49,12 @@ static void vkms_plane_destroy_state(struct drm_plane *plane,
 		/* dropping the reference we acquired in
 		 * vkms_primary_plane_update()
 		 */
-		if (drm_framebuffer_read_refcount(&vkms_state->crc_data->fb))
-			drm_framebuffer_put(&vkms_state->crc_data->fb);
+		if (drm_framebuffer_read_refcount(&vkms_state->composer->fb))
+			drm_framebuffer_put(&vkms_state->composer->fb);
 	}
 
-	kfree(vkms_state->crc_data);
-	vkms_state->crc_data = NULL;
+	kfree(vkms_state->composer);
+	vkms_state->composer = NULL;
 
 	__drm_atomic_helper_plane_destroy_state(old_state);
 	kfree(vkms_state);
@@ -91,21 +91,21 @@ static void vkms_plane_atomic_update(struct drm_plane *plane,
 {
 	struct vkms_plane_state *vkms_plane_state;
 	struct drm_framebuffer *fb = plane->state->fb;
-	struct vkms_crc_data *crc_data;
+	struct vkms_composer *composer;
 
 	if (!plane->state->crtc || !fb)
 		return;
 
 	vkms_plane_state = to_vkms_plane_state(plane->state);
 
-	crc_data = vkms_plane_state->crc_data;
-	memcpy(&crc_data->src, &plane->state->src, sizeof(struct drm_rect));
-	memcpy(&crc_data->dst, &plane->state->dst, sizeof(struct drm_rect));
-	memcpy(&crc_data->fb, fb, sizeof(struct drm_framebuffer));
-	drm_framebuffer_get(&crc_data->fb);
-	crc_data->offset = fb->offsets[0];
-	crc_data->pitch = fb->pitches[0];
-	crc_data->cpp = fb->format->cpp[0];
+	composer = vkms_plane_state->composer;
+	memcpy(&composer->src, &plane->state->src, sizeof(struct drm_rect));
+	memcpy(&composer->dst, &plane->state->dst, sizeof(struct drm_rect));
+	memcpy(&composer->fb, fb, sizeof(struct drm_framebuffer));
+	drm_framebuffer_get(&composer->fb);
+	composer->offset = fb->offsets[0];
+	composer->pitch = fb->pitches[0];
+	composer->cpp = fb->format->cpp[0];
 }
 
 static int vkms_plane_atomic_check(struct drm_plane *plane,
-- 
2.28.0


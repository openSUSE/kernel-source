From 275351c1e85f9e343afa0ecdb543aa8ed90e734c Mon Sep 17 00:00:00 2001
From: Huang Rui <ray.huang@amd.com>
Date: Fri, 20 May 2022 11:04:05 +0800
Subject: drm/amdgpu: use the callback function for reset status polling on IMU
Git-commit: 16600b7d66367482dc8526f8bc3a30b32aaef329
Patch-mainline: v6.0-rc1
References: jsc#PED-1166 jsc#PED-1168 jsc#PED-1170 jsc#PED-1218 jsc#PED-1220 jsc#PED-1222 jsc#PED-1223 jsc#PED-1225 jsc#PED-2849

Switch to use the callback function to poll the reset status on IMU.
Because it will have different sequency on other ASICs.

v2: drop unused variable (Alex)

Acked-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Huang Rui <ray.huang@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Acked-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_imu.h |  1 +
 drivers/gpu/drm/amd/amdgpu/imu_v11_0.c  | 37 +++++++++++++++----------
 2 files changed, 24 insertions(+), 14 deletions(-)

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_imu.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_imu.h
index cfc4a92837f0..484e936812e4 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_imu.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_imu.h
@@ -35,6 +35,7 @@ struct amdgpu_imu_funcs {
     void (*setup_imu)(struct amdgpu_device *adev);
     int (*start_imu)(struct amdgpu_device *adev);
     void (*program_rlc_ram)(struct amdgpu_device *adev);
+    int (*wait_for_reset_status)(struct amdgpu_device *adev);
 };
 
 struct imu_rlc_ram_golden {
diff --git a/drivers/gpu/drm/amd/amdgpu/imu_v11_0.c b/drivers/gpu/drm/amd/amdgpu/imu_v11_0.c
index 05d2b93a534c..fd053158abbd 100644
--- a/drivers/gpu/drm/amd/amdgpu/imu_v11_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/imu_v11_0.c
@@ -117,6 +117,25 @@ static int imu_v11_0_load_microcode(struct amdgpu_device *adev)
 	return 0;
 }
 
+static int imu_v11_0_wait_for_reset_status(struct amdgpu_device *adev)
+{
+	int i, imu_reg_val = 0;
+
+	for (i = 0; i < adev->usec_timeout; i++) {
+		imu_reg_val = RREG32_SOC15(GC, 0, regGFX_IMU_GFX_RESET_CTRL);
+		if ((imu_reg_val & 0x1f) == 0x1f)
+			break;
+		udelay(1);
+	}
+
+	if (i >= adev->usec_timeout) {
+		dev_err(adev->dev, "init imu: IMU start timeout\n");
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
 static void imu_v11_0_setup(struct amdgpu_device *adev)
 {
 	int imu_reg_val;
@@ -139,26 +158,15 @@ static void imu_v11_0_setup(struct amdgpu_device *adev)
 
 static int imu_v11_0_start(struct amdgpu_device *adev)
 {
-	int imu_reg_val, i;
+	int imu_reg_val;
 
 	//Start IMU by set GFX_IMU_CORE_CTRL.CRESET = 0
 	imu_reg_val = RREG32_SOC15(GC, 0, regGFX_IMU_CORE_CTRL);
 	imu_reg_val &= 0xfffffffe;
 	WREG32_SOC15(GC, 0, regGFX_IMU_CORE_CTRL, imu_reg_val);
 
-	if (adev->gfx.imu.mode == DEBUG_MODE) {
-		for (i = 0; i < adev->usec_timeout; i++) {
-			imu_reg_val = RREG32_SOC15(GC, 0, regGFX_IMU_GFX_RESET_CTRL);
-			if ((imu_reg_val & 0x1f) == 0x1f)
-				break;
-			udelay(1);
-		}
-
-		if (i >= adev->usec_timeout) {
-			dev_err(adev->dev, "init imu: IMU start timeout\n");
-			return -ETIMEDOUT;
-		}
-	}
+	if (adev->gfx.imu.mode == DEBUG_MODE)
+		return imu_v11_0_wait_for_reset_status(adev);
 
 	return 0;
 }
@@ -368,4 +376,5 @@ const struct amdgpu_imu_funcs gfx_v11_0_imu_funcs = {
 	.setup_imu = imu_v11_0_setup,
 	.start_imu = imu_v11_0_start,
 	.program_rlc_ram = imu_v11_0_program_rlc_ram,
+	.wait_for_reset_status = imu_v11_0_wait_for_reset_status,
 };
-- 
2.38.1


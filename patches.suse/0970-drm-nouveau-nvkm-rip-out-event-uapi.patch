From 03a3f1ee0c70b54770186e3505ee05655954da87 Mon Sep 17 00:00:00 2001
From: Ben Skeggs <bskeggs@redhat.com>
Date: Wed, 1 Jun 2022 20:46:01 +1000
Subject: drm/nouveau/nvkm: rip out event uapi
Git-commit: c4feba47aad55aca90d9a2b104c0345ca6f93712
Patch-mainline: v6.0-rc1
References: jsc#PED-1166 jsc#PED-1168 jsc#PED-1170 jsc#PED-1218 jsc#PED-1220 jsc#PED-1222 jsc#PED-1223 jsc#PED-1225 jsc#PED-2849

Userspace never ended up using this to be clever about dealing with
channel death, and it won't be, not like this anyway.

Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
Reviewed-by: Lyude Paul <lyude@redhat.com>
Reviewed-by: Dave Airlie <airlied@redhat.com>
Signed-off-by: Dave Airlie <airlied@redhat.com>
Acked-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 drivers/gpu/drm/nouveau/nouveau_drv.h  |   1 -
 drivers/gpu/drm/nouveau/nouveau_nvif.c |  31 +---
 drivers/gpu/drm/nouveau/nouveau_usif.c | 231 +------------------------
 3 files changed, 2 insertions(+), 261 deletions(-)

diff --git a/drivers/gpu/drm/nouveau/nouveau_drv.h b/drivers/gpu/drm/nouveau/nouveau_drv.h
index b2a970aa9bf4..84df5ddae4d0 100644
--- a/drivers/gpu/drm/nouveau/nouveau_drv.h
+++ b/drivers/gpu/drm/nouveau/nouveau_drv.h
@@ -102,7 +102,6 @@ struct nouveau_cli {
 	struct list_head head;
 	void *abi16;
 	struct list_head objects;
-	struct list_head notifys;
 	char name[32];
 
 	struct work_struct work;
diff --git a/drivers/gpu/drm/nouveau/nouveau_nvif.c b/drivers/gpu/drm/nouveau/nouveau_nvif.c
index 52f5793b7274..df0fe58ca3ab 100644
--- a/drivers/gpu/drm/nouveau/nouveau_nvif.c
+++ b/drivers/gpu/drm/nouveau/nouveau_nvif.c
@@ -71,40 +71,11 @@ nvkm_client_suspend(void *priv)
 	return nvkm_object_fini(&client->object, true);
 }
 
-static int
-nvkm_client_ntfy(const void *header, u32 length, const void *data, u32 size)
-{
-	const union {
-		struct nvif_notify_req_v0 v0;
-	} *args = header;
-	u8 route;
-
-	if (length == sizeof(args->v0) && args->v0.version == 0) {
-		route = args->v0.route;
-	} else {
-		WARN_ON(1);
-		return NVKM_NOTIFY_DROP;
-	}
-
-	switch (route) {
-	case NVDRM_NOTIFY_NVIF:
-		return nvif_notify(header, length, data, size);
-	case NVDRM_NOTIFY_USIF:
-		return usif_notify(header, length, data, size);
-	default:
-		WARN_ON(1);
-		break;
-	}
-
-	return NVKM_NOTIFY_DROP;
-}
-
 static int
 nvkm_client_driver_init(const char *name, u64 device, const char *cfg,
 			const char *dbg, void **ppriv)
 {
-	return nvkm_client_new(name, device, cfg, dbg, nvkm_client_ntfy,
-			       (struct nvkm_client **)ppriv);
+	return nvkm_client_new(name, device, cfg, dbg, nvif_notify, (struct nvkm_client **)ppriv);
 }
 
 const struct nvif_driver
diff --git a/drivers/gpu/drm/nouveau/nouveau_usif.c b/drivers/gpu/drm/nouveau/nouveau_usif.c
index 5da1f4d223d7..36df6840c099 100644
--- a/drivers/gpu/drm/nouveau/nouveau_usif.c
+++ b/drivers/gpu/drm/nouveau/nouveau_usif.c
@@ -26,232 +26,15 @@
 #include "nouveau_usif.h"
 #include "nouveau_abi16.h"
 
-#include <nvif/notify.h>
 #include <nvif/unpack.h>
 #include <nvif/client.h>
-#include <nvif/event.h>
 #include <nvif/ioctl.h>
 
 #include <nvif/class.h>
 #include <nvif/cl0080.h>
 
-struct usif_notify_p {
-	struct drm_pending_event base;
-	struct {
-		struct drm_event base;
-		u8 data[];
-	} e;
-};
-
-struct usif_notify {
-	struct list_head head;
-	atomic_t enabled;
-	u32 handle;
-	u16 reply;
-	u8  route;
-	u64 token;
-	struct usif_notify_p *p;
-};
-
-static inline struct usif_notify *
-usif_notify_find(struct drm_file *filp, u32 handle)
-{
-	struct nouveau_cli *cli = nouveau_cli(filp);
-	struct usif_notify *ntfy;
-	list_for_each_entry(ntfy, &cli->notifys, head) {
-		if (ntfy->handle == handle)
-			return ntfy;
-	}
-	return NULL;
-}
-
-static inline void
-usif_notify_dtor(struct usif_notify *ntfy)
-{
-	list_del(&ntfy->head);
-	kfree(ntfy);
-}
-
-int
-usif_notify(const void *header, u32 length, const void *data, u32 size)
-{
-	struct usif_notify *ntfy = NULL;
-	const union {
-		struct nvif_notify_rep_v0 v0;
-	} *rep = header;
-	struct drm_device *dev;
-	struct drm_file *filp;
-	unsigned long flags;
-
-	if (length == sizeof(rep->v0) && rep->v0.version == 0) {
-		if (WARN_ON(!(ntfy = (void *)(unsigned long)rep->v0.token)))
-			return NVIF_NOTIFY_DROP;
-		BUG_ON(rep->v0.route != NVDRM_NOTIFY_USIF);
-	} else
-	if (WARN_ON(1))
-		return NVIF_NOTIFY_DROP;
-
-	if (WARN_ON(!ntfy->p || ntfy->reply != (length + size)))
-		return NVIF_NOTIFY_DROP;
-	filp = ntfy->p->base.file_priv;
-	dev = filp->minor->dev;
-
-	memcpy(&ntfy->p->e.data[0], header, length);
-	memcpy(&ntfy->p->e.data[length], data, size);
-	switch (rep->v0.version) {
-	case 0: {
-		struct nvif_notify_rep_v0 *rep = (void *)ntfy->p->e.data;
-		rep->route = ntfy->route;
-		rep->token = ntfy->token;
-	}
-		break;
-	default:
-		BUG();
-		break;
-	}
-
-	spin_lock_irqsave(&dev->event_lock, flags);
-	if (!WARN_ON(filp->event_space < ntfy->p->e.base.length)) {
-		list_add_tail(&ntfy->p->base.link, &filp->event_list);
-		filp->event_space -= ntfy->p->e.base.length;
-	}
-	wake_up_interruptible(&filp->event_wait);
-	spin_unlock_irqrestore(&dev->event_lock, flags);
-	atomic_set(&ntfy->enabled, 0);
-	return NVIF_NOTIFY_DROP;
-}
-
-static int
-usif_notify_new(struct drm_file *f, void *data, u32 size, void *argv, u32 argc)
-{
-	struct nouveau_cli *cli = nouveau_cli(f);
-	struct nvif_client *client = &cli->base;
-	union {
-		struct nvif_ioctl_ntfy_new_v0 v0;
-	} *args = data;
-	union {
-		struct nvif_notify_req_v0 v0;
-	} *req;
-	struct usif_notify *ntfy;
-	int ret = -ENOSYS;
-
-	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {
-		if (usif_notify_find(f, args->v0.index))
-			return -EEXIST;
-	} else
-		return ret;
-	req = data;
-	ret = -ENOSYS;
-
-	if (!(ntfy = kmalloc(sizeof(*ntfy), GFP_KERNEL)))
-		return -ENOMEM;
-	atomic_set(&ntfy->enabled, 0);
-
-	if (!(ret = nvif_unpack(ret, &data, &size, req->v0, 0, 0, true))) {
-		ntfy->reply = sizeof(struct nvif_notify_rep_v0) + req->v0.reply;
-		ntfy->route = req->v0.route;
-		ntfy->token = req->v0.token;
-		req->v0.route = NVDRM_NOTIFY_USIF;
-		req->v0.token = (unsigned long)(void *)ntfy;
-		ret = nvif_client_ioctl(client, argv, argc);
-		req->v0.token = ntfy->token;
-		req->v0.route = ntfy->route;
-		ntfy->handle = args->v0.index;
-	}
-
-	if (ret == 0)
-		list_add(&ntfy->head, &cli->notifys);
-	if (ret)
-		kfree(ntfy);
-	return ret;
-}
-
-static int
-usif_notify_del(struct drm_file *f, void *data, u32 size, void *argv, u32 argc)
-{
-	struct nouveau_cli *cli = nouveau_cli(f);
-	struct nvif_client *client = &cli->base;
-	union {
-		struct nvif_ioctl_ntfy_del_v0 v0;
-	} *args = data;
-	struct usif_notify *ntfy;
-	int ret = -ENOSYS;
-
-	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {
-		if (!(ntfy = usif_notify_find(f, args->v0.index)))
-			return -ENOENT;
-	} else
-		return ret;
-
-	ret = nvif_client_ioctl(client, argv, argc);
-	if (ret == 0)
-		usif_notify_dtor(ntfy);
-	return ret;
-}
-
-static int
-usif_notify_get(struct drm_file *f, void *data, u32 size, void *argv, u32 argc)
-{
-	struct nouveau_cli *cli = nouveau_cli(f);
-	struct nvif_client *client = &cli->base;
-	union {
-		struct nvif_ioctl_ntfy_del_v0 v0;
-	} *args = data;
-	struct usif_notify *ntfy;
-	int ret = -ENOSYS;
-
-	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {
-		if (!(ntfy = usif_notify_find(f, args->v0.index)))
-			return -ENOENT;
-	} else
-		return ret;
-
-	if (atomic_xchg(&ntfy->enabled, 1))
-		return 0;
-
-	ntfy->p = kmalloc(sizeof(*ntfy->p) + ntfy->reply, GFP_KERNEL);
-	if (ret = -ENOMEM, !ntfy->p)
-		goto done;
-	ntfy->p->base.event = &ntfy->p->e.base;
-	ntfy->p->base.file_priv = f;
-	ntfy->p->e.base.type = DRM_NOUVEAU_EVENT_NVIF;
-	ntfy->p->e.base.length = sizeof(ntfy->p->e.base) + ntfy->reply;
-
-	ret = nvif_client_ioctl(client, argv, argc);
-done:
-	if (ret) {
-		atomic_set(&ntfy->enabled, 0);
-		kfree(ntfy->p);
-	}
-	return ret;
-}
-
-static int
-usif_notify_put(struct drm_file *f, void *data, u32 size, void *argv, u32 argc)
-{
-	struct nouveau_cli *cli = nouveau_cli(f);
-	struct nvif_client *client = &cli->base;
-	union {
-		struct nvif_ioctl_ntfy_put_v0 v0;
-	} *args = data;
-	struct usif_notify *ntfy;
-	int ret = -ENOSYS;
-
-	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {
-		if (!(ntfy = usif_notify_find(f, args->v0.index)))
-			return -ENOENT;
-	} else
-		return ret;
-
-	ret = nvif_client_ioctl(client, argv, argc);
-	if (ret == 0 && atomic_xchg(&ntfy->enabled, 0))
-		kfree(ntfy->p);
-	return ret;
-}
-
 struct usif_object {
 	struct list_head head;
-	struct list_head ntfy;
 	u8  route;
 	u64 token;
 };
@@ -369,16 +152,10 @@ usif_ioctl(struct drm_file *filp, void __user *user, u32 argc)
 		ret = usif_object_new(filp, data, size, argv, argc, abi16);
 		break;
 	case NVIF_IOCTL_V0_NTFY_NEW:
-		ret = usif_notify_new(filp, data, size, argv, argc);
-		break;
 	case NVIF_IOCTL_V0_NTFY_DEL:
-		ret = usif_notify_del(filp, data, size, argv, argc);
-		break;
 	case NVIF_IOCTL_V0_NTFY_GET:
-		ret = usif_notify_get(filp, data, size, argv, argc);
-		break;
 	case NVIF_IOCTL_V0_NTFY_PUT:
-		ret = usif_notify_put(filp, data, size, argv, argc);
+		ret = -ENOSYS;
 		break;
 	default:
 		ret = nvif_client_ioctl(client, argv, argc);
@@ -410,11 +187,6 @@ void
 usif_client_fini(struct nouveau_cli *cli)
 {
 	struct usif_object *object, *otemp;
-	struct usif_notify *notify, *ntemp;
-
-	list_for_each_entry_safe(notify, ntemp, &cli->notifys, head) {
-		usif_notify_dtor(notify);
-	}
 
 	list_for_each_entry_safe(object, otemp, &cli->objects, head) {
 		usif_object_dtor(object);
@@ -425,5 +197,4 @@ void
 usif_client_init(struct nouveau_cli *cli)
 {
 	INIT_LIST_HEAD(&cli->objects);
-	INIT_LIST_HEAD(&cli->notifys);
 }
-- 
2.38.1


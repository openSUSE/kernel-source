From 0a27b2d7a224326fab543ca586d501fe1857b655 Mon Sep 17 00:00:00 2001
From: Vijendar Mukunda <Vijendar.Mukunda@amd.com>
Date: Fri, 7 Feb 2025 11:58:00 +0530
Subject: [PATCH] ASoC: amd: ps: add soundwire dma irq thread callback
Git-commit: 0a27b2d7a224326fab543ca586d501fe1857b655
Patch-mainline: v6.15-rc1
References: jsc#PED-14430 jsc#PED-14297 jsc#PED-14024

Add acp pci driver Soundwire DMA irq thread callaback
for ACP6.3 platform.

Signed-off-by: Vijendar Mukunda <Vijendar.Mukunda@amd.com>
Link: https://patch.msgid.link/20250207062819.1527184-7-Vijendar.Mukunda@amd.com
Signed-off-by: Mark Brown <broonie@kernel.org>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 sound/soc/amd/ps/acp63.h     |  8 ++++++++
 sound/soc/amd/ps/pci-ps.c    | 19 +------------------
 sound/soc/amd/ps/ps-common.c | 25 +++++++++++++++++++++++++
 3 files changed, 34 insertions(+), 18 deletions(-)

diff --git a/sound/soc/amd/ps/acp63.h b/sound/soc/amd/ps/acp63.h
index a918a988e4d8..9a20846d30ff 100644
--- a/sound/soc/amd/ps/acp63.h
+++ b/sound/soc/amd/ps/acp63.h
@@ -222,6 +222,7 @@ struct acp63_dev_data;
  * @acp_init: ACP initialization
  * @acp_deinit: ACP de-initialization
  * @acp_get_config: function to read the acp pin configuration
+ * @acp_sdw_dma_irq_thread: ACP SoundWire DMA interrupt thread
  * acp_suspend: ACP system level suspend callback
  * acp_resume: ACP system level resume callback
  * acp_suspend_runtime: ACP runtime suspend callback
@@ -231,6 +232,7 @@ struct acp_hw_ops {
 	int (*acp_init)(void __iomem *acp_base, struct device *dev);
 	int (*acp_deinit)(void __iomem *acp_base, struct device *dev);
 	void (*acp_get_config)(struct pci_dev *pci, struct acp63_dev_data *acp_data);
+	void (*acp_sdw_dma_irq_thread)(struct acp63_dev_data *acp_data);
 	int (*acp_suspend)(struct device *dev);
 	int (*acp_resume)(struct device *dev);
 	int (*acp_suspend_runtime)(struct device *dev);
@@ -311,6 +313,12 @@ static inline void acp_hw_get_config(struct pci_dev *pci, struct acp63_dev_data
 		ACP_HW_OPS(adata, acp_get_config)(pci, adata);
 }
 
+static inline void acp_hw_sdw_dma_irq_thread(struct acp63_dev_data *adata)
+{
+	if (adata && adata->hw_ops && adata->hw_ops->acp_sdw_dma_irq_thread)
+		ACP_HW_OPS(adata, acp_sdw_dma_irq_thread)(adata);
+}
+
 static inline int acp_hw_suspend(struct device *dev)
 {
 	struct acp63_dev_data *adata = dev_get_drvdata(dev);
diff --git a/sound/soc/amd/ps/pci-ps.c b/sound/soc/amd/ps/pci-ps.c
index 96399acf906c..5d9c230043a6 100644
--- a/sound/soc/amd/ps/pci-ps.c
+++ b/sound/soc/amd/ps/pci-ps.c
@@ -23,26 +23,9 @@
 
 static irqreturn_t acp63_irq_thread(int irq, void *context)
 {
-	struct sdw_dma_dev_data *sdw_data;
 	struct acp63_dev_data *adata = context;
-	u32 stream_id;
 
-	sdw_data = dev_get_drvdata(&adata->sdw_dma_dev->dev);
-
-	for (stream_id = 0; stream_id < ACP63_SDW0_DMA_MAX_STREAMS; stream_id++) {
-		if (adata->acp63_sdw0_dma_intr_stat[stream_id]) {
-			if (sdw_data->acp63_sdw0_dma_stream[stream_id])
-				snd_pcm_period_elapsed(sdw_data->acp63_sdw0_dma_stream[stream_id]);
-			adata->acp63_sdw0_dma_intr_stat[stream_id] = 0;
-		}
-	}
-	for (stream_id = 0; stream_id < ACP63_SDW1_DMA_MAX_STREAMS; stream_id++) {
-		if (adata->acp63_sdw1_dma_intr_stat[stream_id]) {
-			if (sdw_data->acp63_sdw1_dma_stream[stream_id])
-				snd_pcm_period_elapsed(sdw_data->acp63_sdw1_dma_stream[stream_id]);
-			adata->acp63_sdw1_dma_intr_stat[stream_id] = 0;
-		}
-	}
+	acp_hw_sdw_dma_irq_thread(adata);
 	return IRQ_HANDLED;
 }
 
diff --git a/sound/soc/amd/ps/ps-common.c b/sound/soc/amd/ps/ps-common.c
index 30e9e5fe034b..9098974b3608 100644
--- a/sound/soc/amd/ps/ps-common.c
+++ b/sound/soc/amd/ps/ps-common.c
@@ -15,6 +15,7 @@
 #include <linux/pci.h>
 #include <linux/platform_device.h>
 #include <linux/pm_runtime.h>
+#include <sound/pcm_params.h>
 
 #include "acp63.h"
 
@@ -211,11 +212,35 @@ static int __maybe_unused snd_acp63_resume(struct device *dev)
 	return ret;
 }
 
+static void acp63_sdw_dma_irq_thread(struct acp63_dev_data *adata)
+{
+	struct sdw_dma_dev_data *sdw_data;
+	u32 stream_id;
+
+	sdw_data = dev_get_drvdata(&adata->sdw_dma_dev->dev);
+
+	for (stream_id = 0; stream_id < ACP63_SDW0_DMA_MAX_STREAMS; stream_id++) {
+		if (adata->acp63_sdw0_dma_intr_stat[stream_id]) {
+			if (sdw_data->acp63_sdw0_dma_stream[stream_id])
+				snd_pcm_period_elapsed(sdw_data->acp63_sdw0_dma_stream[stream_id]);
+			adata->acp63_sdw0_dma_intr_stat[stream_id] = 0;
+		}
+	}
+	for (stream_id = 0; stream_id < ACP63_SDW1_DMA_MAX_STREAMS; stream_id++) {
+		if (adata->acp63_sdw1_dma_intr_stat[stream_id]) {
+			if (sdw_data->acp63_sdw1_dma_stream[stream_id])
+				snd_pcm_period_elapsed(sdw_data->acp63_sdw1_dma_stream[stream_id]);
+			adata->acp63_sdw1_dma_intr_stat[stream_id] = 0;
+		}
+	}
+}
+
 void acp63_hw_init_ops(struct acp_hw_ops *hw_ops)
 {
 	hw_ops->acp_init = acp63_init;
 	hw_ops->acp_deinit = acp63_deinit;
 	hw_ops->acp_get_config = acp63_get_config;
+	hw_ops->acp_sdw_dma_irq_thread = acp63_sdw_dma_irq_thread;
 	hw_ops->acp_suspend = snd_acp63_suspend;
 	hw_ops->acp_resume = snd_acp63_resume;
 	hw_ops->acp_suspend_runtime = snd_acp63_suspend;
-- 
2.52.0


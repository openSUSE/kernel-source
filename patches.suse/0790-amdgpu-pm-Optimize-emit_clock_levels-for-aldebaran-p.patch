From 6af64b2f5d7c1ad4ac606e0c033ddc1a93431a29 Mon Sep 17 00:00:00 2001
From: Darren Powell <darren.powell@amd.com>
Date: Mon, 3 Apr 2023 23:37:50 -0400
Subject: amdgpu/pm: Optimize emit_clock_levels for aldebaran - part 2
Git-commit: d62846f778f5dc4c521c4b1532ecf3f2d7fd78d9
Patch-mainline: v6.7-rc1
References: jsc#PED-3527 jsc#PED-5475 jsc#PED-6068 jsc#PED-6070 jsc#PED-6116 jsc#PED-6120 jsc#PED-5065 jsc#PED-5477 jsc#PED-5511 jsc#PED-6041 jsc#PED-6069 jsc#PED-6071

 Use variables to remove ternary expression in print statement
 and improve readability. This will help to optimize the code
 duplication in the switch statement
 Also Changed:
  replaced single_dpm_table->count as iterator in for loops
    with safer clocks_num_levels value
  replaced dpm_table.value usage with local var clocks_mhz

Signed-off-by: Darren Powell <darren.powell@amd.com>
Reviewed-by: Lijo Lazar <lijo.lazar@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Acked-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 .../drm/amd/pm/swsmu/smu13/aldebaran_ppt.c    | 27 +++++++++----------
 1 file changed, 13 insertions(+), 14 deletions(-)

diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu13/aldebaran_ppt.c b/drivers/gpu/drm/amd/pm/swsmu/smu13/aldebaran_ppt.c
index d34fdb4f56bf..5582caef834a 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu13/aldebaran_ppt.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu13/aldebaran_ppt.c
@@ -792,12 +792,11 @@ static int aldebaran_emit_clk_levels(struct smu_context *smu,
 		for (i = 0; i < display_levels; i++) {
 			clock_mhz = freq_values[i];
 			freq_match = aldebaran_freqs_in_same_level(clock_mhz, cur_value);
+			freq_match |= (display_levels == 1);
 
 			*offset += sysfs_emit_at(buf, *offset, "%d: %uMhz %s\n", i,
 				clock_mhz,
-				(display_levels == 1) ?
-					"*" :
-					(freq_match) ? "*" : "");
+				(freq_match) ? "*" : "");
 		}
 
 		break;
@@ -818,10 +817,10 @@ static int aldebaran_emit_clk_levels(struct smu_context *smu,
 		for (i = 0; i < clocks.num_levels; i++) {
 			clock_mhz = clocks.data[i].clocks_in_khz / 1000;
 			freq_match = aldebaran_freqs_in_same_level(clock_mhz, cur_value);
+			freq_match |= (clocks.num_levels == 1);
 
 			*offset += sysfs_emit_at(buf, *offset, "%d: %uMhz %s\n",
 					i, clock_mhz,
-					(clocks.num_levels == 1) ? "*" :
 					(freq_match) ? "*" : "");
 		}
 		break;
@@ -839,10 +838,10 @@ static int aldebaran_emit_clk_levels(struct smu_context *smu,
 		for (i = 0; i < clocks.num_levels; i++) {
 			clock_mhz = clocks.data[i].clocks_in_khz / 1000;
 			freq_match = aldebaran_freqs_in_same_level(clock_mhz, cur_value);
+			freq_match |= (clocks.num_levels == 1);
 
 			*offset += sysfs_emit_at(buf, *offset, "%d: %uMhz %s\n",
 					i, clock_mhz,
-					(clocks.num_levels == 1) ? "*" :
 					(freq_match) ? "*" : "");
 		}
 		break;
@@ -857,13 +856,13 @@ static int aldebaran_emit_clk_levels(struct smu_context *smu,
 		single_dpm_table = &(dpm_context->dpm_tables.fclk_table);
 		aldebaran_get_clk_table(smu, &clocks, single_dpm_table);
 
-		for (i = 0; i < single_dpm_table->count; i++) {
+		for (i = 0; i < clocks.num_levels; i++) {
 			clock_mhz = clocks.data[i].clocks_in_khz / 1000;
 			freq_match = aldebaran_freqs_in_same_level(clock_mhz, cur_value);
+			freq_match |= (clocks.num_levels == 1);
 
 			*offset += sysfs_emit_at(buf, *offset, "%d: %uMhz %s\n",
-					i, single_dpm_table->dpm_levels[i].value,
-					(clocks.num_levels == 1) ? "*" :
+					i, clock_mhz,
 					(freq_match) ? "*" : "");
 		}
 		break;
@@ -878,13 +877,13 @@ static int aldebaran_emit_clk_levels(struct smu_context *smu,
 		single_dpm_table = &(dpm_context->dpm_tables.vclk_table);
 		aldebaran_get_clk_table(smu, &clocks, single_dpm_table);
 
-		for (i = 0; i < single_dpm_table->count; i++) {
+		for (i = 0; i < clocks.num_levels; i++) {
 			clock_mhz = clocks.data[i].clocks_in_khz / 1000;
 			freq_match = aldebaran_freqs_in_same_level(clock_mhz, cur_value);
+			freq_match |= (clocks.num_levels == 1);
 
 			*offset += sysfs_emit_at(buf, *offset, "%d: %uMhz %s\n",
-					i, single_dpm_table->dpm_levels[i].value,
-					(clocks.num_levels == 1) ? "*" :
+					i, clock_mhz,
 					(freq_match) ? "*" : "");
 		}
 		break;
@@ -899,13 +898,13 @@ static int aldebaran_emit_clk_levels(struct smu_context *smu,
 		single_dpm_table = &(dpm_context->dpm_tables.dclk_table);
 		aldebaran_get_clk_table(smu, &clocks, single_dpm_table);
 
-		for (i = 0; i < single_dpm_table->count; i++) {
+		for (i = 0; i < clocks.num_levels; i++) {
 			clock_mhz = clocks.data[i].clocks_in_khz / 1000;
 			freq_match = aldebaran_freqs_in_same_level(clock_mhz, cur_value);
+			freq_match |= (clocks.num_levels == 1);
 
 			*offset += sysfs_emit_at(buf, *offset, "%d: %uMhz %s\n",
-					i, single_dpm_table->dpm_levels[i].value,
-					(clocks.num_levels == 1) ? "*" :
+					i, clock_mhz,
 					(freq_match) ? "*" : "");
 		}
 		break;
-- 
2.43.0


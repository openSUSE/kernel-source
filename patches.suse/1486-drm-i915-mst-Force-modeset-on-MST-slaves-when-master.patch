From 2020ad4219ad67ea93eab583f050c9c2bd936649 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jos=C3=A9=20Roberto=20de=20Souza?= <jose.souza@intel.com>
Date: Sun, 22 Dec 2019 17:06:53 -0800
Subject: drm/i915/mst: Force modeset on MST slaves when master needs a modeset
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Git-commit: 080d47bfae80bffd7dd130fd721e91d29c9c0d0a
Patch-mainline: v5.6-rc1
References: jsc#SLE-12680, jsc#SLE-12880, jsc#SLE-12882, jsc#SLE-12883, jsc#SLE-13496, jsc#SLE-15322

MST master can not be disabled while it have attached MST slaves, so
it is necessary force a modeset in all of its slaves.

v3:
- moved handling to intel_atomic_check() this way is guarantee that
all pipes will have its state computed

v4:
- added a function to return if MST master neeeds modeset to simply
code in intel_atomic_check()

v5:
- fixed and moved code to check if MST master needs a modeset

v6:
- previons version of this patch was split into two patches

Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
Cc: Lucas De Marchi <lucas.demarchi@intel.com>
Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
Signed-off-by: José Roberto de Souza <jose.souza@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20191223010654.67037-6-jose.souza@intel.com
Signed-off-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 drivers/gpu/drm/i915/display/intel_display.c | 36 ++++++++++++++++++++
 1 file changed, 36 insertions(+)

diff --git a/drivers/gpu/drm/i915/display/intel_display.c b/drivers/gpu/drm/i915/display/intel_display.c
index 71f97ab7632e..d704d642779b 100644
--- a/drivers/gpu/drm/i915/display/intel_display.c
+++ b/drivers/gpu/drm/i915/display/intel_display.c
@@ -14290,6 +14290,20 @@ static int intel_atomic_check_crtcs(struct intel_atomic_state *state)
 	return 0;
 }
 
+static bool intel_cpu_transcoder_needs_modeset(struct intel_atomic_state *state,
+					       enum transcoder transcoder)
+{
+	struct intel_crtc_state *new_crtc_state;
+	struct intel_crtc *crtc;
+	int i;
+
+	for_each_new_intel_crtc_in_state(state, crtc, new_crtc_state, i)
+		if (new_crtc_state->cpu_transcoder == transcoder)
+			return needs_modeset(new_crtc_state);
+
+	return false;
+}
+
 /**
  * intel_atomic_check - validate state object
  * @dev: drm device
@@ -14342,6 +14356,28 @@ static int intel_atomic_check(struct drm_device *dev,
 		intel_crtc_check_fastset(old_crtc_state, new_crtc_state);
 	}
 
+	/**
+	 * Check if fastset is allowed by external dependencies like other
+	 * pipes and transcoders.
+	 *
+	 * Right now it only forces a fullmodeset when the MST master
+	 * transcoder did not changed but the pipe of the master transcoder
+	 * needs a fullmodeset so all slaves also needs to do a fullmodeset.
+	 */
+	for_each_new_intel_crtc_in_state(state, crtc, new_crtc_state, i) {
+		enum transcoder master = new_crtc_state->mst_master_transcoder;
+
+		if (!new_crtc_state->hw.enable ||
+		    needs_modeset(new_crtc_state) ||
+		    !intel_dp_mst_is_slave_trans(new_crtc_state))
+			continue;
+
+		if (intel_cpu_transcoder_needs_modeset(state, master)) {
+			new_crtc_state->uapi.mode_changed = true;
+			new_crtc_state->update_pipe = false;
+		}
+	}
+
 	for_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,
 					    new_crtc_state, i) {
 		if (needs_modeset(new_crtc_state)) {
-- 
2.28.0


From a2fde5462650e27639b87f803cd43a8d5e5313c9 Mon Sep 17 00:00:00 2001
From: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date: Thu, 24 Oct 2019 16:07:58 -0400
Subject: drm/amd/display: split rxstatus for hdmi and dp
Git-commit: 302169003733f168f9de5c0d677c0cd82d1be107
Patch-mainline: v5.6-rc1
References: jsc#SLE-12680, jsc#SLE-12880, jsc#SLE-12882, jsc#SLE-12883, jsc#SLE-13496, jsc#SLE-15322

[Why]
Currently we share rxstatus between HDMI and DP, so we use 16bits
The drm defines work with 1bytes at a time. So we need to
split the HDMI rxstatus into 2bytes before we can use drm defines

[How]
-create rxstatus for dp and hdmi. rxstatus for hdmi is split into bytes
using arrays.
-use drm_hdcp defines for the remaining structs

Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Reviewed-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 .../gpu/drm/amd/display/modules/hdcp/hdcp.h   | 20 ++---------
 .../display/modules/hdcp/hdcp2_execution.c    | 35 +++++++++++--------
 .../drm/amd/display/modules/hdcp/hdcp_ddc.c   |  2 +-
 3 files changed, 24 insertions(+), 33 deletions(-)

diff --git a/drivers/gpu/drm/amd/display/modules/hdcp/hdcp.h b/drivers/gpu/drm/amd/display/modules/hdcp/hdcp.h
index f6bba487d1d4..f98d3d9ecb6d 100644
--- a/drivers/gpu/drm/amd/display/modules/hdcp/hdcp.h
+++ b/drivers/gpu/drm/amd/display/modules/hdcp/hdcp.h
@@ -32,22 +32,6 @@
 #include <drm/drm_hdcp.h>
 #include <drm/drm_dp_helper.h>
 
-/* TODO:
- * Replace below defines with these
- *
- * #define HDCP_2_2_HDMI_RXSTATUS_MSG_SZ_HI(x)     ((x) & 0x3)
- * #define HDCP_2_2_HDMI_RXSTATUS_READY(x)         ((x) & BIT(2))
- * #define HDCP_2_2_HDMI_RXSTATUS_REAUTH_REQ(x)    ((x) & BIT(3))
- *
- * Currently we share rx_status between HDMI and DP, so we use 16bits
- * The upstream defines work with 1bytes at a time. So we need to
- * split the HDMI rxstatus into 2bytes before we can use usptream defs
- */
-
-#define RXSTATUS_MSG_SIZE_MASK				0x03FF
-#define RXSTATUS_READY_MASK				0x0400
-#define RXSTATUS_REAUTH_REQUEST_MASK			0x0800
-
 enum mod_hdcp_trans_input_result {
 	UNKNOWN = 0,
 	PASS,
@@ -150,7 +134,7 @@ struct mod_hdcp_message_hdcp1 {
 struct mod_hdcp_message_hdcp2 {
 	uint8_t		hdcp2version_hdmi;
 	uint8_t		rxcaps_dp[3];
-	uint16_t	rxstatus;
+	uint8_t		rxstatus[2];
 
 	uint8_t		ake_init[12];
 	uint8_t		ake_cert[534];
@@ -167,7 +151,7 @@ struct mod_hdcp_message_hdcp2 {
 	uint8_t		repeater_auth_stream_manage[68]; // 6 + 2 * 31
 	uint16_t	stream_manage_size;
 	uint8_t		repeater_auth_stream_ready[33];
-
+	uint8_t		rxstatus_dp;
 	uint8_t		content_stream_type_dp[2];
 };
 
diff --git a/drivers/gpu/drm/amd/display/modules/hdcp/hdcp2_execution.c b/drivers/gpu/drm/amd/display/modules/hdcp/hdcp2_execution.c
index 7513b3b3c353..110c8620907b 100644
--- a/drivers/gpu/drm/amd/display/modules/hdcp/hdcp2_execution.c
+++ b/drivers/gpu/drm/amd/display/modules/hdcp/hdcp2_execution.c
@@ -30,10 +30,11 @@ static inline enum mod_hdcp_status check_receiver_id_list_ready(struct mod_hdcp
 	uint8_t is_ready = 0;
 
 	if (is_dp_hdcp(hdcp))
-		is_ready = HDCP_2_2_DP_RXSTATUS_READY(hdcp->auth.msg.hdcp2.rxstatus) ? 1 : 0;
+		is_ready = HDCP_2_2_DP_RXSTATUS_READY(hdcp->auth.msg.hdcp2.rxstatus_dp) ? 1 : 0;
 	else
-		is_ready = ((hdcp->auth.msg.hdcp2.rxstatus & RXSTATUS_READY_MASK) &&
-				(hdcp->auth.msg.hdcp2.rxstatus & RXSTATUS_MSG_SIZE_MASK)) ? 1 : 0;
+		is_ready = (HDCP_2_2_HDMI_RXSTATUS_READY(hdcp->auth.msg.hdcp2.rxstatus[0]) &&
+				(HDCP_2_2_HDMI_RXSTATUS_MSG_SZ_HI(hdcp->auth.msg.hdcp2.rxstatus[1]) << 8 |
+						hdcp->auth.msg.hdcp2.rxstatus[0])) ? 1 : 0;
 	return is_ready ? MOD_HDCP_STATUS_SUCCESS :
 			MOD_HDCP_STATUS_HDCP2_RX_ID_LIST_NOT_READY;
 }
@@ -60,11 +61,11 @@ static inline enum mod_hdcp_status check_reauthentication_request(
 	uint8_t ret = 0;
 
 	if (is_dp_hdcp(hdcp))
-		ret = HDCP_2_2_DP_RXSTATUS_REAUTH_REQ(hdcp->auth.msg.hdcp2.rxstatus) ?
+		ret = HDCP_2_2_DP_RXSTATUS_REAUTH_REQ(hdcp->auth.msg.hdcp2.rxstatus_dp) ?
 				MOD_HDCP_STATUS_HDCP2_REAUTH_REQUEST :
 				MOD_HDCP_STATUS_SUCCESS;
 	else
-		ret = (hdcp->auth.msg.hdcp2.rxstatus & RXSTATUS_REAUTH_REQUEST_MASK) ?
+		ret = HDCP_2_2_HDMI_RXSTATUS_REAUTH_REQ(hdcp->auth.msg.hdcp2.rxstatus[0]) ?
 				MOD_HDCP_STATUS_HDCP2_REAUTH_REQUEST :
 				MOD_HDCP_STATUS_SUCCESS;
 	return ret;
@@ -73,7 +74,7 @@ static inline enum mod_hdcp_status check_reauthentication_request(
 static inline enum mod_hdcp_status check_link_integrity_failure_dp(
 		struct mod_hdcp *hdcp)
 {
-	return HDCP_2_2_DP_RXSTATUS_LINK_FAILED(hdcp->auth.msg.hdcp2.rxstatus) ?
+	return HDCP_2_2_DP_RXSTATUS_LINK_FAILED(hdcp->auth.msg.hdcp2.rxstatus_dp) ?
 			MOD_HDCP_STATUS_HDCP2_REAUTH_LINK_INTEGRITY_FAILURE :
 			MOD_HDCP_STATUS_SUCCESS;
 }
@@ -88,7 +89,8 @@ static enum mod_hdcp_status check_ake_cert_available(struct mod_hdcp *hdcp)
 	} else {
 		status = mod_hdcp_read_rxstatus(hdcp);
 		if (status == MOD_HDCP_STATUS_SUCCESS) {
-			size = hdcp->auth.msg.hdcp2.rxstatus & RXSTATUS_MSG_SIZE_MASK;
+			size = HDCP_2_2_HDMI_RXSTATUS_MSG_SZ_HI(hdcp->auth.msg.hdcp2.rxstatus[1]) << 8 |
+			       hdcp->auth.msg.hdcp2.rxstatus[0];
 			status = (size == sizeof(hdcp->auth.msg.hdcp2.ake_cert)) ?
 					MOD_HDCP_STATUS_SUCCESS :
 					MOD_HDCP_STATUS_HDCP2_AKE_CERT_PENDING;
@@ -107,11 +109,12 @@ static enum mod_hdcp_status check_h_prime_available(struct mod_hdcp *hdcp)
 		goto out;
 
 	if (is_dp_hdcp(hdcp)) {
-		status = HDCP_2_2_DP_RXSTATUS_H_PRIME(hdcp->auth.msg.hdcp2.rxstatus) ?
+		status = HDCP_2_2_DP_RXSTATUS_H_PRIME(hdcp->auth.msg.hdcp2.rxstatus_dp) ?
 				MOD_HDCP_STATUS_SUCCESS :
 				MOD_HDCP_STATUS_HDCP2_H_PRIME_PENDING;
 	} else {
-		size = hdcp->auth.msg.hdcp2.rxstatus & RXSTATUS_MSG_SIZE_MASK;
+		size = HDCP_2_2_HDMI_RXSTATUS_MSG_SZ_HI(hdcp->auth.msg.hdcp2.rxstatus[1]) << 8 |
+		       hdcp->auth.msg.hdcp2.rxstatus[0];
 		status = (size == sizeof(hdcp->auth.msg.hdcp2.ake_h_prime)) ?
 				MOD_HDCP_STATUS_SUCCESS :
 				MOD_HDCP_STATUS_HDCP2_H_PRIME_PENDING;
@@ -130,11 +133,12 @@ static enum mod_hdcp_status check_pairing_info_available(struct mod_hdcp *hdcp)
 		goto out;
 
 	if (is_dp_hdcp(hdcp)) {
-		status = HDCP_2_2_DP_RXSTATUS_PAIRING(hdcp->auth.msg.hdcp2.rxstatus) ?
+		status = HDCP_2_2_DP_RXSTATUS_PAIRING(hdcp->auth.msg.hdcp2.rxstatus_dp) ?
 				MOD_HDCP_STATUS_SUCCESS :
 				MOD_HDCP_STATUS_HDCP2_PAIRING_INFO_PENDING;
 	} else {
-		size = hdcp->auth.msg.hdcp2.rxstatus & RXSTATUS_MSG_SIZE_MASK;
+		size = HDCP_2_2_HDMI_RXSTATUS_MSG_SZ_HI(hdcp->auth.msg.hdcp2.rxstatus[1]) << 8 |
+		       hdcp->auth.msg.hdcp2.rxstatus[0];
 		status = (size == sizeof(hdcp->auth.msg.hdcp2.ake_pairing_info)) ?
 				MOD_HDCP_STATUS_SUCCESS :
 				MOD_HDCP_STATUS_HDCP2_PAIRING_INFO_PENDING;
@@ -161,7 +165,8 @@ static enum mod_hdcp_status poll_l_prime_available(struct mod_hdcp *hdcp)
 			if (status != MOD_HDCP_STATUS_SUCCESS)
 				break;
 
-			size = hdcp->auth.msg.hdcp2.rxstatus & RXSTATUS_MSG_SIZE_MASK;
+			size = HDCP_2_2_HDMI_RXSTATUS_MSG_SZ_HI(hdcp->auth.msg.hdcp2.rxstatus[1]) << 8 |
+			       hdcp->auth.msg.hdcp2.rxstatus[0];
 			status = (size == sizeof(hdcp->auth.msg.hdcp2.lc_l_prime)) ?
 					MOD_HDCP_STATUS_SUCCESS :
 					MOD_HDCP_STATUS_HDCP2_L_PRIME_PENDING;
@@ -182,7 +187,8 @@ static enum mod_hdcp_status check_stream_ready_available(struct mod_hdcp *hdcp)
 		status = mod_hdcp_read_rxstatus(hdcp);
 		if (status != MOD_HDCP_STATUS_SUCCESS)
 			goto out;
-		size = hdcp->auth.msg.hdcp2.rxstatus & RXSTATUS_MSG_SIZE_MASK;
+		size = HDCP_2_2_HDMI_RXSTATUS_MSG_SZ_HI(hdcp->auth.msg.hdcp2.rxstatus[1]) << 8 |
+		       hdcp->auth.msg.hdcp2.rxstatus[0];
 		status = (size == sizeof(hdcp->auth.msg.hdcp2.repeater_auth_stream_ready)) ?
 				MOD_HDCP_STATUS_SUCCESS :
 				MOD_HDCP_STATUS_HDCP2_STREAM_READY_PENDING;
@@ -234,7 +240,8 @@ static uint8_t process_rxstatus(struct mod_hdcp *hdcp,
 						sizeof(hdcp->auth.msg.hdcp2.rx_id_list);
 			else
 				hdcp->auth.msg.hdcp2.rx_id_list_size =
-						hdcp->auth.msg.hdcp2.rxstatus & 0x3FF;
+					HDCP_2_2_HDMI_RXSTATUS_MSG_SZ_HI(hdcp->auth.msg.hdcp2.rxstatus[1]) << 8 |
+					hdcp->auth.msg.hdcp2.rxstatus[0];
 		}
 out:
 	return (*status == MOD_HDCP_STATUS_SUCCESS);
diff --git a/drivers/gpu/drm/amd/display/modules/hdcp/hdcp_ddc.c b/drivers/gpu/drm/amd/display/modules/hdcp/hdcp_ddc.c
index 8059aff9911f..ff9d54812e62 100644
--- a/drivers/gpu/drm/amd/display/modules/hdcp/hdcp_ddc.c
+++ b/drivers/gpu/drm/amd/display/modules/hdcp/hdcp_ddc.c
@@ -390,7 +390,7 @@ enum mod_hdcp_status mod_hdcp_read_rxstatus(struct mod_hdcp *hdcp)
 
 	if (is_dp_hdcp(hdcp)) {
 		status = read(hdcp, MOD_HDCP_MESSAGE_ID_READ_RXSTATUS,
-				(uint8_t *)&hdcp->auth.msg.hdcp2.rxstatus,
+				&hdcp->auth.msg.hdcp2.rxstatus_dp,
 				1);
 	} else {
 		status = read(hdcp, MOD_HDCP_MESSAGE_ID_READ_RXSTATUS,
-- 
2.28.0


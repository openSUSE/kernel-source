From: Jiri Slaby <jslaby@suse.cz>
Date: Fri, 1 Dec 2017 08:26:22 +0100
Subject: x86/stacktrace: remove unwind_state->error
Patch-mainline: submitted on 2017/12/5
References: bnc#1058115

Reorganize the unwinding in __save_stack_trace_reliable, so that we
don't need to set another variable -- unwind_state->error. In case,
unwinding fails, we fail after the for loop too. The only way to escape
the loop successfully is via the 'if (user_mode(regs))' check now.

Signed-off-by: Jiri Slaby <jslaby@suse.cz>
Cc: Thomas Gleixner <tglx@linutronix.de>
Cc: Ingo Molnar <mingo@redhat.com>
Cc: "H. Peter Anvin" <hpa@zytor.com>
Cc: x86@kernel.org
Cc: Josh Poimboeuf <jpoimboe@redhat.com>
---
 arch/x86/include/asm/unwind.h  |    6 ------
 arch/x86/kernel/stacktrace.c   |   15 ++++++---------
 arch/x86/kernel/unwind_frame.c |    2 --
 3 files changed, 6 insertions(+), 17 deletions(-)

--- a/arch/x86/include/asm/unwind.h
+++ b/arch/x86/include/asm/unwind.h
@@ -12,7 +12,6 @@ struct unwind_state {
 	unsigned long stack_mask;
 	struct task_struct *task;
 	int graph_idx;
-	bool error;
 #if defined(CONFIG_UNWINDER_ORC)
 	bool signal, full_regs;
 	unsigned long sp, bp, ip;
@@ -37,11 +36,6 @@ static inline bool unwind_done(struct un
 	return state->stack_info.type == STACK_TYPE_UNKNOWN;
 }
 
-static inline bool unwind_error(struct unwind_state *state)
-{
-	return state->error;
-}
-
 static inline
 void unwind_start(struct unwind_state *state, struct task_struct *task,
 		  struct pt_regs *regs, unsigned long *first_frame)
--- a/arch/x86/kernel/stacktrace.c
+++ b/arch/x86/kernel/stacktrace.c
@@ -104,16 +104,16 @@ __save_stack_trace_reliable(struct stack
 
 		regs = unwind_get_entry_regs(&state);
 		if (regs) {
+			if (user_mode(regs))
+				goto success;
+
 			/*
 			 * Kernel mode registers on the stack indicate an
 			 * in-kernel interrupt or exception (e.g., preemption
 			 * or a page fault), which can make frame pointers
 			 * unreliable.
 			 */
-			if (!user_mode(regs))
-				return -EINVAL;
-
-			break;
+			return -EINVAL;
 		}
 
 		addr = unwind_get_return_address(&state);
@@ -132,12 +132,9 @@ __save_stack_trace_reliable(struct stack
 			return -EINVAL;
 	}
 
-	/* Check for stack corruption */
-	if (unwind_error(&state)) {
-		STACKTRACE_DUMP_ONCE(task);
-		return -EINVAL;
-	}
+	return -EINVAL;
 
+success:
 	if (trace->nr_entries < trace->max_entries)
 		trace->entries[trace->nr_entries++] = ULONG_MAX;
 
--- a/arch/x86/kernel/unwind_frame.c
+++ b/arch/x86/kernel/unwind_frame.c
@@ -332,8 +332,6 @@ bool unwind_next_frame(struct unwind_sta
 	return true;
 
 bad_address:
-	state->error = true;
-
 	/*
 	 * When unwinding a non-current task, the task might actually be
 	 * running on another CPU, in which case it could be modifying its

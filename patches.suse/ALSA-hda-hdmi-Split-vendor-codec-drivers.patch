From 73cd0490819d2a693928c5977280dd31b756cb42 Mon Sep 17 00:00:00 2001
From: Takashi Iwai <tiwai@suse.de>
Date: Wed, 9 Jul 2025 18:04:11 +0200
Subject: [PATCH] ALSA: hda/hdmi: Split vendor codec drivers
Git-commit: 73cd0490819d2a693928c5977280dd31b756cb42
Patch-mainline: v6.17-rc1
References: jsc#PED-14430 jsc#PED-14297 jsc#PED-14024

In the past, we unified HD-audio HDMI codec driver once with a slight
hope that more vendors will follow the standard, but in reality, the
driver received more and more vendor-specific code.  In order to make
the messy code a bit more understandable, this patch splits the HDMI
codec driver into multiple drivers again.

Namely, the vendor-specific code for Intel, AMD and Nvidia are moved
into the own drivers, while we split the common HDMI code to two
drivers, the generic HDMI driver and the simple HDMI driver.
So, now we have:

- The generic HDMI driver (snd-hda-codec-hdmi):
  providing the common helpers, also supports Glenfly HDMI codecs and
  some other codecs that don't need vendor-specific stuff

- The simple HDMI driver (snd-hda-codec-simplehdmi):
  devices with no dynamic PCM assignment and with fixed channels,
  mostly used by some other drivers, but this driver alone suffices
  for VIA HDMI codec support, too

- Intel HDMI driver (snd-hda-codec-intelhdmi):
  bound with i915 / Xe DRM, based on the generic HDMI driver

- AMD/ATI HDMI driver (snd-hda-codec-atihdmi):
  optionally bound with radeon / amdgpu DRM, based on the generic HDMI
  driver

- Nvidia HDMI driver (snd-hda-codec-nvhdmi);
  optionally bound with nouveau DRM, based on the generic HDMI driver

- Legacy Nvidia HDMI driver (snd-hda-codec-nvhdmi-mcp):
  for 2ch or 8ch outputs, based on the simple HDMI driver

- Nvidia Tegra HDMI driver (snd-hda-codec-tegrahdmi):
  based on the generic HDMI driver

Along with the driver split, the enable_silent_stream module option is
moved to snd-hda-codec-intelhdmi, too, as it's an Intel-specific
feature.

Most of the changes here are just to split and move the code to
different files, as well as to rename/expose the functions that are
commonly used by drivers.

The silent stream handling code is slightly modified for putting the
stuff into Intel driver; now a new callback "silent_stream" is defined
in hdmi_ops, and it's called in silent_stream_enable() and *_disable()
functions.  The runtime-PM handling in silent_stream_enable() was
cleaned up, and rather taking the runtime PM refcount in the
silent_stream() callback appropriately, instead.

Other than that, there should be no functional changes.

Signed-off-by: Takashi Iwai <tiwai@suse.de>
Link: https://patch.msgid.link/20250709160434.1859-9-tiwai@suse.de

---
 sound/hda/codecs/Kconfig           |   31 
 sound/hda/codecs/hdmi/Kconfig      |   68 +
 sound/hda/codecs/hdmi/Makefile     |   12 
 sound/hda/codecs/hdmi/atihdmi.c    |  606 +++++++++
 sound/hda/codecs/hdmi/eld.c        |  172 --
 sound/hda/codecs/hdmi/hdmi.c       | 2465 +------------------------------------
 sound/hda/codecs/hdmi/hdmi_local.h |  302 ++++
 sound/hda/codecs/hdmi/intelhdmi.c  |  760 +++++++++++
 sound/hda/codecs/hdmi/nvhdmi-mcp.c |  382 +++++
 sound/hda/codecs/hdmi/nvhdmi.c     |  218 +++
 sound/hda/codecs/hdmi/simplehdmi.c |  241 +++
 sound/hda/codecs/hdmi/tegrahdmi.c  |  313 ++++
 sound/hda/common/hda_local.h       |    4 
 13 files changed, 2993 insertions(+), 2581 deletions(-)
 create mode 100644 sound/hda/codecs/hdmi/Kconfig
 create mode 100644 sound/hda/codecs/hdmi/atihdmi.c
 create mode 100644 sound/hda/codecs/hdmi/hdmi_local.h
 create mode 100644 sound/hda/codecs/hdmi/intelhdmi.c
 create mode 100644 sound/hda/codecs/hdmi/nvhdmi-mcp.c
 create mode 100644 sound/hda/codecs/hdmi/nvhdmi.c
 create mode 100644 sound/hda/codecs/hdmi/simplehdmi.c
 create mode 100644 sound/hda/codecs/hdmi/tegrahdmi.c

--- a/sound/hda/codecs/Kconfig
+++ b/sound/hda/codecs/Kconfig
@@ -35,21 +35,6 @@ config SND_HDA_CODEC_VIA
 comment "Set to Y if you want auto-loading the codec driver"
 	depends on SND_HDA=y && SND_HDA_CODEC_VIA=m
 
-config SND_HDA_CODEC_HDMI
-	tristate "Build HDMI/DisplayPort HD-audio codec support"
-	select SND_DYNAMIC_MINORS
-	select SND_PCM_ELD
-	help
-	  Say Y or M here to include HDMI and DisplayPort HD-audio codec
-	  support in snd-hda-intel driver.  This includes all AMD/ATI,
-	  Intel and Nvidia HDMI/DisplayPort codecs.
-
-	  Note that this option mandatorily enables CONFIG_SND_DYNAMIC_MINORS
-	  to assure the multiple streams for DP-MST support.
-
-comment "Set to Y if you want auto-loading the codec driver"
-	depends on SND_HDA=y && SND_HDA_CODEC_HDMI=m
-
 config SND_HDA_CODEC_CONEXANT
 	tristate "Build Conexant HD-audio codec support"
 	select SND_HDA_GENERIC
@@ -134,23 +119,9 @@ config SND_HDA_GENERIC
 comment "Set to Y if you want auto-loading the codec driver"
 	depends on SND_HDA=y && SND_HDA_GENERIC=m
 
-config SND_HDA_INTEL_HDMI_SILENT_STREAM
-	bool "Enable Silent Stream always for HDMI"
-	depends on SND_HDA_INTEL
-	help
-	  Say Y to enable HD-Audio Keep Alive (KAE) aka Silent Stream
-	  for HDMI on hardware that supports the feature.
-
-	  When enabled, the HDMI/DisplayPort codec will continue to provide
-	  a continuous clock and a valid but silent data stream to
-	  any connected external receiver. This allows to avoid gaps
-	  at start of playback. Many receivers require multiple seconds
-	  to start playing audio after the clock has been stopped.
-	  This feature can impact power consumption as resources
-	  are kept reserved both at transmitter and receiver.
-
 source "sound/hda/codecs/realtek/Kconfig"
 source "sound/hda/codecs/cirrus/Kconfig"
+source "sound/hda/codecs/hdmi/Kconfig"
 source "sound/hda/codecs/side-codecs/Kconfig"
 
 endif # SND_HDA
--- /dev/null
+++ b/sound/hda/codecs/hdmi/Kconfig
@@ -0,0 +1,68 @@
+# SPDX-License-Identifier: GPL-2.0-only
+
+config SND_HDA_CODEC_HDMI
+	tristate "Generic HDMI/DisplayPort HD-audio codec support"
+	select SND_DYNAMIC_MINORS
+	select SND_PCM_ELD
+	help
+	  Say Y or M here to include Generic HDMI and DisplayPort HD-audio
+	  codec support.
+
+	  Note that this option mandatorily enables CONFIG_SND_DYNAMIC_MINORS
+	  to assure the multiple streams for DP-MST support.
+
+config SND_HDA_CODEC_HDMI_SIMPLE
+	tristate "Simple HDMI/DisplayPort HD-audio codec support"
+	help
+	  Say Y or M here to include Simple HDMI and DisplayPort HD-audio
+	  codec support for VIA and other codecs.
+
+config SND_HDA_CODEC_HDMI_INTEL
+	tristate "Intel HDMI/DisplayPort HD-audio codec support"
+	select SND_HDA_CODEC_HDMI
+	help
+	  Say Y or M here to include Intel graphics HDMI and DisplayPort
+	  HD-audio codec support.
+
+config SND_HDA_INTEL_HDMI_SILENT_STREAM
+	bool "Enable Silent Stream always for HDMI"
+	depends on SND_HDA_CODEC_HDMI_INTEL
+	help
+	  Say Y to enable HD-Audio Keep Alive (KAE) aka Silent Stream
+	  for HDMI on hardware that supports the feature.
+
+	  When enabled, the HDMI/DisplayPort codec will continue to provide
+	  a continuous clock and a valid but silent data stream to
+	  any connected external receiver. This allows to avoid gaps
+	  at start of playback. Many receivers require multiple seconds
+	  to start playing audio after the clock has been stopped.
+	  This feature can impact power consumption as resources
+	  are kept reserved both at transmitter and receiver.
+
+config SND_HDA_CODEC_HDMI_ATI
+	tristate "AMD/ATI HDMI/DisplayPort HD-audio codec support"
+	select SND_HDA_CODEC_HDMI
+	help
+	  Say Y or M here to include AMD/ATI graphics HDMI and DisplayPort
+	  HD-audio codec support.
+
+config SND_HDA_CODEC_HDMI_NVIDIA
+	tristate "Nvidia HDMI/DisplayPort HD-audio codec support"
+	select SND_HDA_CODEC_HDMI
+	help
+	  Say Y or M here to include HDMI and DisplayPort HD-audio codec
+	  support for the recent Nvidia graphics cards.
+
+config SND_HDA_CODEC_HDMI_NVIDIA_MCP
+	tristate "Legacy Nvidia HDMI/DisplayPort HD-audio codec support"
+	select SND_HDA_CODEC_HDMI_SIMPLE
+	help
+	  Say Y or M here to include HDMI and DisplayPort HD-audio codec
+	  support for the legacy Nvidia graphics like MCP73, MCP67, MCP77/78.
+
+config SND_HDA_CODEC_HDMI_TEGRA
+	tristate "Nvidia Tegra HDMI/DisplayPort HD-audio codec support"
+	select SND_HDA_CODEC_HDMI
+	help
+	  Say Y or M here to include HDMI and DisplayPort HD-audio codec
+	  support for Nvidia Tegra.
--- a/sound/hda/codecs/hdmi/Makefile
+++ b/sound/hda/codecs/hdmi/Makefile
@@ -2,5 +2,17 @@
 subdir-ccflags-y += -I$(src)/../../common
 
 snd-hda-codec-hdmi-y :=		hdmi.o eld.o
+snd-hda-codec-simplehdmi-y :=	simplehdmi.o
+snd-hda-codec-intelhdmi-y :=	intelhdmi.o
+snd-hda-codec-atihdmi-y :=	atihdmi.o
+snd-hda-codec-nvhdmi-y :=	nvhdmi.o
+snd-hda-codec-nvhdmi-mcp-y :=	nvhdmi-mcp.o
+snd-hda-codec-tegrahdmi-y :=	tegrahdmi.o
 
 obj-$(CONFIG_SND_HDA_CODEC_HDMI) += snd-hda-codec-hdmi.o
+obj-$(CONFIG_SND_HDA_CODEC_HDMI_SIMPLE) += snd-hda-codec-simplehdmi.o
+obj-$(CONFIG_SND_HDA_CODEC_HDMI_INTEL) += snd-hda-codec-intelhdmi.o
+obj-$(CONFIG_SND_HDA_CODEC_HDMI_ATI) += snd-hda-codec-atihdmi.o
+obj-$(CONFIG_SND_HDA_CODEC_HDMI_NVIDIA) += snd-hda-codec-nvhdmi.o
+obj-$(CONFIG_SND_HDA_CODEC_HDMI_NVIDIA_MCP) += snd-hda-codec-nvhdmi-mcp.o
+obj-$(CONFIG_SND_HDA_CODEC_HDMI_TEGRA) += snd-hda-codec-tegrahdmi.o
--- /dev/null
+++ b/sound/hda/codecs/hdmi/atihdmi.c
@@ -0,0 +1,606 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * ATI/AMD codec support
+ */
+
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/unaligned.h>
+#include <sound/core.h>
+#include <sound/tlv.h>
+#include <sound/hdaudio.h>
+#include <sound/hda_codec.h>
+#include "hda_local.h"
+#include "hdmi_local.h"
+
+#define is_amdhdmi_rev3_or_later(codec) \
+	((codec)->core.vendor_id == 0x1002aa01 && \
+	 ((codec)->core.revision_id & 0xff00) >= 0x0300)
+#define has_amd_full_remap_support(codec) is_amdhdmi_rev3_or_later(codec)
+
+/* ATI/AMD specific HDA pin verbs, see the AMD HDA Verbs specification */
+#define ATI_VERB_SET_CHANNEL_ALLOCATION	0x771
+#define ATI_VERB_SET_DOWNMIX_INFO	0x772
+#define ATI_VERB_SET_MULTICHANNEL_01	0x777
+#define ATI_VERB_SET_MULTICHANNEL_23	0x778
+#define ATI_VERB_SET_MULTICHANNEL_45	0x779
+#define ATI_VERB_SET_MULTICHANNEL_67	0x77a
+#define ATI_VERB_SET_HBR_CONTROL	0x77c
+#define ATI_VERB_SET_MULTICHANNEL_1	0x785
+#define ATI_VERB_SET_MULTICHANNEL_3	0x786
+#define ATI_VERB_SET_MULTICHANNEL_5	0x787
+#define ATI_VERB_SET_MULTICHANNEL_7	0x788
+#define ATI_VERB_SET_MULTICHANNEL_MODE	0x789
+#define ATI_VERB_GET_CHANNEL_ALLOCATION	0xf71
+#define ATI_VERB_GET_DOWNMIX_INFO	0xf72
+#define ATI_VERB_GET_MULTICHANNEL_01	0xf77
+#define ATI_VERB_GET_MULTICHANNEL_23	0xf78
+#define ATI_VERB_GET_MULTICHANNEL_45	0xf79
+#define ATI_VERB_GET_MULTICHANNEL_67	0xf7a
+#define ATI_VERB_GET_HBR_CONTROL	0xf7c
+#define ATI_VERB_GET_MULTICHANNEL_1	0xf85
+#define ATI_VERB_GET_MULTICHANNEL_3	0xf86
+#define ATI_VERB_GET_MULTICHANNEL_5	0xf87
+#define ATI_VERB_GET_MULTICHANNEL_7	0xf88
+#define ATI_VERB_GET_MULTICHANNEL_MODE	0xf89
+
+/* AMD specific HDA cvt verbs */
+#define ATI_VERB_SET_RAMP_RATE		0x770
+#define ATI_VERB_GET_RAMP_RATE		0xf70
+
+#define ATI_OUT_ENABLE 0x1
+
+#define ATI_MULTICHANNEL_MODE_PAIRED	0
+#define ATI_MULTICHANNEL_MODE_SINGLE	1
+
+#define ATI_HBR_CAPABLE 0x01
+#define ATI_HBR_ENABLE 0x10
+
+/* ATI/AMD specific ELD emulation */
+
+#define ATI_VERB_SET_AUDIO_DESCRIPTOR	0x776
+#define ATI_VERB_SET_SINK_INFO_INDEX	0x780
+#define ATI_VERB_GET_SPEAKER_ALLOCATION	0xf70
+#define ATI_VERB_GET_AUDIO_DESCRIPTOR	0xf76
+#define ATI_VERB_GET_AUDIO_VIDEO_DELAY	0xf7b
+#define ATI_VERB_GET_SINK_INFO_INDEX	0xf80
+#define ATI_VERB_GET_SINK_INFO_DATA	0xf81
+
+#define ATI_SPKALLOC_SPKALLOC		0x007f
+#define ATI_SPKALLOC_TYPE_HDMI		0x0100
+#define ATI_SPKALLOC_TYPE_DISPLAYPORT	0x0200
+
+/* first three bytes are just standard SAD */
+#define ATI_AUDIODESC_CHANNELS		0x00000007
+#define ATI_AUDIODESC_RATES		0x0000ff00
+#define ATI_AUDIODESC_LPCM_STEREO_RATES	0xff000000
+
+/* in standard HDMI VSDB format */
+#define ATI_DELAY_VIDEO_LATENCY		0x000000ff
+#define ATI_DELAY_AUDIO_LATENCY		0x0000ff00
+
+enum ati_sink_info_idx {
+	ATI_INFO_IDX_MANUFACTURER_ID	= 0,
+	ATI_INFO_IDX_PRODUCT_ID		= 1,
+	ATI_INFO_IDX_SINK_DESC_LEN	= 2,
+	ATI_INFO_IDX_PORT_ID_LOW	= 3,
+	ATI_INFO_IDX_PORT_ID_HIGH	= 4,
+	ATI_INFO_IDX_SINK_DESC_FIRST	= 5,
+	ATI_INFO_IDX_SINK_DESC_LAST	= 22, /* max len 18 bytes */
+};
+
+static int get_eld_ati(struct hda_codec *codec, hda_nid_t nid,
+		       unsigned char *buf, int *eld_size, bool rev3_or_later)
+{
+	int spkalloc, ati_sad, aud_synch;
+	int sink_desc_len = 0;
+	int pos, i;
+
+	/* ATI/AMD does not have ELD, emulate it */
+
+	spkalloc = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_SPEAKER_ALLOCATION, 0);
+
+	if (spkalloc <= 0) {
+		codec_info(codec, "HDMI ATI/AMD: no speaker allocation for ELD\n");
+		return -EINVAL;
+	}
+
+	memset(buf, 0, ELD_FIXED_BYTES + ELD_MAX_MNL + ELD_MAX_SAD * 3);
+
+	/* version */
+	buf[0] = ELD_VER_CEA_861D << 3;
+
+	/* speaker allocation from EDID */
+	buf[7] = spkalloc & ATI_SPKALLOC_SPKALLOC;
+
+	/* is DisplayPort? */
+	if (spkalloc & ATI_SPKALLOC_TYPE_DISPLAYPORT)
+		buf[5] |= 0x04;
+
+	pos = ELD_FIXED_BYTES;
+
+	if (rev3_or_later) {
+		int sink_info;
+
+		snd_hda_codec_write(codec, nid, 0, ATI_VERB_SET_SINK_INFO_INDEX, ATI_INFO_IDX_PORT_ID_LOW);
+		sink_info = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_SINK_INFO_DATA, 0);
+		put_unaligned_le32(sink_info, buf + 8);
+
+		snd_hda_codec_write(codec, nid, 0, ATI_VERB_SET_SINK_INFO_INDEX, ATI_INFO_IDX_PORT_ID_HIGH);
+		sink_info = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_SINK_INFO_DATA, 0);
+		put_unaligned_le32(sink_info, buf + 12);
+
+		snd_hda_codec_write(codec, nid, 0, ATI_VERB_SET_SINK_INFO_INDEX, ATI_INFO_IDX_MANUFACTURER_ID);
+		sink_info = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_SINK_INFO_DATA, 0);
+		put_unaligned_le16(sink_info, buf + 16);
+
+		snd_hda_codec_write(codec, nid, 0, ATI_VERB_SET_SINK_INFO_INDEX, ATI_INFO_IDX_PRODUCT_ID);
+		sink_info = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_SINK_INFO_DATA, 0);
+		put_unaligned_le16(sink_info, buf + 18);
+
+		snd_hda_codec_write(codec, nid, 0, ATI_VERB_SET_SINK_INFO_INDEX, ATI_INFO_IDX_SINK_DESC_LEN);
+		sink_desc_len = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_SINK_INFO_DATA, 0);
+
+		if (sink_desc_len > ELD_MAX_MNL) {
+			codec_info(codec, "HDMI ATI/AMD: Truncating HDMI sink description with length %d\n",
+				   sink_desc_len);
+			sink_desc_len = ELD_MAX_MNL;
+		}
+
+		buf[4] |= sink_desc_len;
+
+		for (i = 0; i < sink_desc_len; i++) {
+			snd_hda_codec_write(codec, nid, 0, ATI_VERB_SET_SINK_INFO_INDEX, ATI_INFO_IDX_SINK_DESC_FIRST + i);
+			buf[pos++] = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_SINK_INFO_DATA, 0);
+		}
+	}
+
+	for (i = AUDIO_CODING_TYPE_LPCM; i <= AUDIO_CODING_TYPE_WMAPRO; i++) {
+		if (i == AUDIO_CODING_TYPE_SACD || i == AUDIO_CODING_TYPE_DST)
+			continue; /* not handled by ATI/AMD */
+
+		snd_hda_codec_write(codec, nid, 0, ATI_VERB_SET_AUDIO_DESCRIPTOR, i << 3);
+		ati_sad = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_AUDIO_DESCRIPTOR, 0);
+
+		if (ati_sad <= 0)
+			continue;
+
+		if (ati_sad & ATI_AUDIODESC_RATES) {
+			/* format is supported, copy SAD as-is */
+			buf[pos++] = (ati_sad & 0x0000ff) >> 0;
+			buf[pos++] = (ati_sad & 0x00ff00) >> 8;
+			buf[pos++] = (ati_sad & 0xff0000) >> 16;
+		}
+
+		if (i == AUDIO_CODING_TYPE_LPCM
+		    && (ati_sad & ATI_AUDIODESC_LPCM_STEREO_RATES)
+		    && (ati_sad & ATI_AUDIODESC_LPCM_STEREO_RATES) >> 16 != (ati_sad & ATI_AUDIODESC_RATES)) {
+			/* for PCM there is a separate stereo rate mask */
+			buf[pos++] = ((ati_sad & 0x000000ff) & ~ATI_AUDIODESC_CHANNELS) | 0x1;
+			/* rates from the extra byte */
+			buf[pos++] = (ati_sad & 0xff000000) >> 24;
+			buf[pos++] = (ati_sad & 0x00ff0000) >> 16;
+		}
+	}
+
+	if (pos == ELD_FIXED_BYTES + sink_desc_len) {
+		codec_info(codec, "HDMI ATI/AMD: no audio descriptors for ELD\n");
+		return -EINVAL;
+	}
+
+	/*
+	 * HDMI VSDB latency format:
+	 * separately for both audio and video:
+	 *  0          field not valid or unknown latency
+	 *  [1..251]   msecs = (x-1)*2  (max 500ms with x = 251 = 0xfb)
+	 *  255        audio/video not supported
+	 *
+	 * HDA latency format:
+	 * single value indicating video latency relative to audio:
+	 *  0          unknown or 0ms
+	 *  [1..250]   msecs = x*2  (max 500ms with x = 250 = 0xfa)
+	 *  [251..255] reserved
+	 */
+	aud_synch = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_AUDIO_VIDEO_DELAY, 0);
+	if ((aud_synch & ATI_DELAY_VIDEO_LATENCY) && (aud_synch & ATI_DELAY_AUDIO_LATENCY)) {
+		int video_latency_hdmi = (aud_synch & ATI_DELAY_VIDEO_LATENCY);
+		int audio_latency_hdmi = (aud_synch & ATI_DELAY_AUDIO_LATENCY) >> 8;
+
+		if (video_latency_hdmi <= 0xfb && audio_latency_hdmi <= 0xfb &&
+		    video_latency_hdmi > audio_latency_hdmi)
+			buf[6] = video_latency_hdmi - audio_latency_hdmi;
+		/* else unknown/invalid or 0ms or video ahead of audio, so use zero */
+	}
+
+	/* SAD count */
+	buf[5] |= ((pos - ELD_FIXED_BYTES - sink_desc_len) / 3) << 4;
+
+	/* Baseline ELD block length is 4-byte aligned */
+	pos = round_up(pos, 4);
+
+	/* Baseline ELD length (4-byte header is not counted in) */
+	buf[2] = (pos - 4) / 4;
+
+	*eld_size = pos;
+
+	return 0;
+}
+
+static int atihdmi_pin_get_eld(struct hda_codec *codec, hda_nid_t nid,
+			       int dev_id, unsigned char *buf, int *eld_size)
+{
+	WARN_ON(dev_id != 0);
+	/* call hda_eld.c ATI/AMD-specific function */
+	return get_eld_ati(codec, nid, buf, eld_size,
+			   is_amdhdmi_rev3_or_later(codec));
+}
+
+static void atihdmi_pin_setup_infoframe(struct hda_codec *codec,
+					hda_nid_t pin_nid, int dev_id, int ca,
+					int active_channels, int conn_type)
+{
+	WARN_ON(dev_id != 0);
+	snd_hda_codec_write(codec, pin_nid, 0, ATI_VERB_SET_CHANNEL_ALLOCATION, ca);
+}
+
+static int atihdmi_paired_swap_fc_lfe(int pos)
+{
+	/*
+	 * ATI/AMD have automatic FC/LFE swap built-in
+	 * when in pairwise mapping mode.
+	 */
+
+	switch (pos) {
+	/* see channel_allocations[].speakers[] */
+	case 2: return 3;
+	case 3: return 2;
+	default: return pos;
+	}
+}
+
+static int atihdmi_paired_chmap_validate(struct hdac_chmap *chmap,
+			int ca, int chs, unsigned char *map)
+{
+	struct hdac_cea_channel_speaker_allocation *cap;
+	int i, j;
+
+	/* check that only channel pairs need to be remapped on old pre-rev3 ATI/AMD */
+
+	cap = snd_hdac_get_ch_alloc_from_ca(ca);
+	for (i = 0; i < chs; ++i) {
+		int mask = snd_hdac_chmap_to_spk_mask(map[i]);
+		bool ok = false;
+		bool companion_ok = false;
+
+		if (!mask)
+			continue;
+
+		for (j = 0 + i % 2; j < 8; j += 2) {
+			int chan_idx = 7 - atihdmi_paired_swap_fc_lfe(j);
+
+			if (cap->speakers[chan_idx] == mask) {
+				/* channel is in a supported position */
+				ok = true;
+
+				if (i % 2 == 0 && i + 1 < chs) {
+					/* even channel, check the odd companion */
+					int comp_chan_idx = 7 - atihdmi_paired_swap_fc_lfe(j + 1);
+					int comp_mask_req = snd_hdac_chmap_to_spk_mask(map[i+1]);
+					int comp_mask_act = cap->speakers[comp_chan_idx];
+
+					if (comp_mask_req == comp_mask_act)
+						companion_ok = true;
+					else
+						return -EINVAL;
+				}
+				break;
+			}
+		}
+
+		if (!ok)
+			return -EINVAL;
+
+		if (companion_ok)
+			i++; /* companion channel already checked */
+	}
+
+	return 0;
+}
+
+static int atihdmi_pin_set_slot_channel(struct hdac_device *hdac,
+		hda_nid_t pin_nid, int hdmi_slot, int stream_channel)
+{
+	struct hda_codec *codec = hdac_to_hda_codec(hdac);
+	int verb;
+	int ati_channel_setup = 0;
+
+	if (hdmi_slot > 7)
+		return -EINVAL;
+
+	if (!has_amd_full_remap_support(codec)) {
+		hdmi_slot = atihdmi_paired_swap_fc_lfe(hdmi_slot);
+
+		/* In case this is an odd slot but without stream channel, do not
+		 * disable the slot since the corresponding even slot could have a
+		 * channel. In case neither have a channel, the slot pair will be
+		 * disabled when this function is called for the even slot.
+		 */
+		if (hdmi_slot % 2 != 0 && stream_channel == 0xf)
+			return 0;
+
+		hdmi_slot -= hdmi_slot % 2;
+
+		if (stream_channel != 0xf)
+			stream_channel -= stream_channel % 2;
+	}
+
+	verb = ATI_VERB_SET_MULTICHANNEL_01 + hdmi_slot/2 + (hdmi_slot % 2) * 0x00e;
+
+	/* ati_channel_setup format: [7..4] = stream_channel_id, [1] = mute, [0] = enable */
+
+	if (stream_channel != 0xf)
+		ati_channel_setup = (stream_channel << 4) | ATI_OUT_ENABLE;
+
+	return snd_hda_codec_write(codec, pin_nid, 0, verb, ati_channel_setup);
+}
+
+static int atihdmi_pin_get_slot_channel(struct hdac_device *hdac,
+				hda_nid_t pin_nid, int asp_slot)
+{
+	struct hda_codec *codec = hdac_to_hda_codec(hdac);
+	bool was_odd = false;
+	int ati_asp_slot = asp_slot;
+	int verb;
+	int ati_channel_setup;
+
+	if (asp_slot > 7)
+		return -EINVAL;
+
+	if (!has_amd_full_remap_support(codec)) {
+		ati_asp_slot = atihdmi_paired_swap_fc_lfe(asp_slot);
+		if (ati_asp_slot % 2 != 0) {
+			ati_asp_slot -= 1;
+			was_odd = true;
+		}
+	}
+
+	verb = ATI_VERB_GET_MULTICHANNEL_01 + ati_asp_slot/2 + (ati_asp_slot % 2) * 0x00e;
+
+	ati_channel_setup = snd_hda_codec_read(codec, pin_nid, 0, verb, 0);
+
+	if (!(ati_channel_setup & ATI_OUT_ENABLE))
+		return 0xf;
+
+	return ((ati_channel_setup & 0xf0) >> 4) + !!was_odd;
+}
+
+static int atihdmi_paired_chmap_cea_alloc_validate_get_type(
+		struct hdac_chmap *chmap,
+		struct hdac_cea_channel_speaker_allocation *cap,
+		int channels)
+{
+	int c;
+
+	/*
+	 * Pre-rev3 ATI/AMD codecs operate in a paired channel mode, so
+	 * we need to take that into account (a single channel may take 2
+	 * channel slots if we need to carry a silent channel next to it).
+	 * On Rev3+ AMD codecs this function is not used.
+	 */
+	int chanpairs = 0;
+
+	/* We only produce even-numbered channel count TLVs */
+	if ((channels % 2) != 0)
+		return -1;
+
+	for (c = 0; c < 7; c += 2) {
+		if (cap->speakers[c] || cap->speakers[c+1])
+			chanpairs++;
+	}
+
+	if (chanpairs * 2 != channels)
+		return -1;
+
+	return SNDRV_CTL_TLVT_CHMAP_PAIRED;
+}
+
+static void atihdmi_paired_cea_alloc_to_tlv_chmap(struct hdac_chmap *hchmap,
+		struct hdac_cea_channel_speaker_allocation *cap,
+		unsigned int *chmap, int channels)
+{
+	/* produce paired maps for pre-rev3 ATI/AMD codecs */
+	int count = 0;
+	int c;
+
+	for (c = 7; c >= 0; c--) {
+		int chan = 7 - atihdmi_paired_swap_fc_lfe(7 - c);
+		int spk = cap->speakers[chan];
+
+		if (!spk) {
+			/* add N/A channel if the companion channel is occupied */
+			if (cap->speakers[chan + (chan % 2 ? -1 : 1)])
+				chmap[count++] = SNDRV_CHMAP_NA;
+
+			continue;
+		}
+
+		chmap[count++] = snd_hdac_spk_to_chmap(spk);
+	}
+
+	WARN_ON(count != channels);
+}
+
+static int atihdmi_pin_hbr_setup(struct hda_codec *codec, hda_nid_t pin_nid,
+				 int dev_id, bool hbr)
+{
+	int hbr_ctl, hbr_ctl_new;
+
+	WARN_ON(dev_id != 0);
+
+	hbr_ctl = snd_hda_codec_read(codec, pin_nid, 0, ATI_VERB_GET_HBR_CONTROL, 0);
+	if (hbr_ctl >= 0 && (hbr_ctl & ATI_HBR_CAPABLE)) {
+		if (hbr)
+			hbr_ctl_new = hbr_ctl | ATI_HBR_ENABLE;
+		else
+			hbr_ctl_new = hbr_ctl & ~ATI_HBR_ENABLE;
+
+		codec_dbg(codec,
+			  "%s: NID=0x%x, %shbr-ctl=0x%x\n",
+			  __func__,
+			  pin_nid,
+			  hbr_ctl == hbr_ctl_new ? "" : "new-",
+			  hbr_ctl_new);
+
+		if (hbr_ctl != hbr_ctl_new)
+			snd_hda_codec_write(codec, pin_nid, 0,
+						ATI_VERB_SET_HBR_CONTROL,
+						hbr_ctl_new);
+
+	} else if (hbr)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int atihdmi_setup_stream(struct hda_codec *codec, hda_nid_t cvt_nid,
+				hda_nid_t pin_nid, int dev_id,
+				u32 stream_tag, int format)
+{
+	if (is_amdhdmi_rev3_or_later(codec)) {
+		int ramp_rate = 180; /* default as per AMD spec */
+		/* disable ramp-up/down for non-pcm as per AMD spec */
+		if (format & AC_FMT_TYPE_NON_PCM)
+			ramp_rate = 0;
+
+		snd_hda_codec_write(codec, cvt_nid, 0, ATI_VERB_SET_RAMP_RATE, ramp_rate);
+	}
+
+	return snd_hda_hdmi_setup_stream(codec, cvt_nid, pin_nid, dev_id,
+					 stream_tag, format);
+}
+
+
+static int atihdmi_init(struct hda_codec *codec)
+{
+	struct hdmi_spec *spec = codec->spec;
+	int pin_idx, err;
+
+	err = snd_hda_hdmi_generic_init(codec);
+
+	if (err)
+		return err;
+
+	for (pin_idx = 0; pin_idx < spec->num_pins; pin_idx++) {
+		struct hdmi_spec_per_pin *per_pin = get_pin(spec, pin_idx);
+
+		/* make sure downmix information in infoframe is zero */
+		snd_hda_codec_write(codec, per_pin->pin_nid, 0, ATI_VERB_SET_DOWNMIX_INFO, 0);
+
+		/* enable channel-wise remap mode if supported */
+		if (has_amd_full_remap_support(codec))
+			snd_hda_codec_write(codec, per_pin->pin_nid, 0,
+					    ATI_VERB_SET_MULTICHANNEL_MODE,
+					    ATI_MULTICHANNEL_MODE_SINGLE);
+	}
+	codec->auto_runtime_pm = 1;
+
+	return 0;
+}
+
+/* map from pin NID to port; port is 0-based */
+/* for AMD: assume widget NID starting from 3, with step 2 (3, 5, 7, ...) */
+static int atihdmi_pin2port(void *audio_ptr, int pin_nid)
+{
+	return pin_nid / 2 - 1;
+}
+
+/* reverse-map from port to pin NID: see above */
+static int atihdmi_port2pin(struct hda_codec *codec, int port)
+{
+	return port * 2 + 3;
+}
+
+static const struct drm_audio_component_audio_ops atihdmi_audio_ops = {
+	.pin2port = atihdmi_pin2port,
+	.pin_eld_notify = snd_hda_hdmi_acomp_pin_eld_notify,
+	.master_bind = snd_hda_hdmi_acomp_master_bind,
+	.master_unbind = snd_hda_hdmi_acomp_master_unbind,
+};
+
+static int patch_atihdmi(struct hda_codec *codec)
+{
+	struct hdmi_spec *spec;
+	struct hdmi_spec_per_cvt *per_cvt;
+	int err, cvt_idx;
+
+	err = patch_generic_hdmi(codec);
+
+	if (err)
+		return err;
+
+	codec->patch_ops.init = atihdmi_init;
+
+	spec = codec->spec;
+
+	spec->static_pcm_mapping = true;
+
+	spec->ops.pin_get_eld = atihdmi_pin_get_eld;
+	spec->ops.pin_setup_infoframe = atihdmi_pin_setup_infoframe;
+	spec->ops.pin_hbr_setup = atihdmi_pin_hbr_setup;
+	spec->ops.setup_stream = atihdmi_setup_stream;
+
+	spec->chmap.ops.pin_get_slot_channel = atihdmi_pin_get_slot_channel;
+	spec->chmap.ops.pin_set_slot_channel = atihdmi_pin_set_slot_channel;
+
+	if (!has_amd_full_remap_support(codec)) {
+		/* override to ATI/AMD-specific versions with pairwise mapping */
+		spec->chmap.ops.chmap_cea_alloc_validate_get_type =
+			atihdmi_paired_chmap_cea_alloc_validate_get_type;
+		spec->chmap.ops.cea_alloc_to_tlv_chmap =
+				atihdmi_paired_cea_alloc_to_tlv_chmap;
+		spec->chmap.ops.chmap_validate = atihdmi_paired_chmap_validate;
+	}
+
+	/* ATI/AMD converters do not advertise all of their capabilities */
+	for (cvt_idx = 0; cvt_idx < spec->num_cvts; cvt_idx++) {
+		per_cvt = get_cvt(spec, cvt_idx);
+		per_cvt->channels_max = max(per_cvt->channels_max, 8u);
+		per_cvt->rates |= SUPPORTED_RATES;
+		per_cvt->formats |= SUPPORTED_FORMATS;
+		per_cvt->maxbps = max(per_cvt->maxbps, 24u);
+	}
+
+	spec->chmap.channels_max = max(spec->chmap.channels_max, 8u);
+
+	/* AMD GPUs have neither EPSS nor CLKSTOP bits, hence preventing
+	 * the link-down as is.  Tell the core to allow it.
+	 */
+	codec->link_down_at_suspend = 1;
+
+	snd_hda_hdmi_acomp_init(codec, &atihdmi_audio_ops, atihdmi_port2pin);
+
+	return 0;
+}
+
+/*
+ * patch entries
+ */
+static const struct hda_device_id snd_hda_id_atihdmi[] = {
+HDA_CODEC_ENTRY(0x1002793c, "RS600 HDMI",	patch_atihdmi),
+HDA_CODEC_ENTRY(0x10027919, "RS600 HDMI",	patch_atihdmi),
+HDA_CODEC_ENTRY(0x1002791a, "RS690/780 HDMI",	patch_atihdmi),
+HDA_CODEC_ENTRY(0x1002aa01, "R6xx HDMI",	patch_atihdmi),
+{} /* terminator */
+};
+MODULE_DEVICE_TABLE(hdaudio, snd_hda_id_atihdmi);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("AMD/ATI HDMI HD-audio codec");
+MODULE_IMPORT_NS(SND_HDA_CODEC_HDMI);
+
+static struct hda_codec_driver atihdmi_driver = {
+	.id = snd_hda_id_atihdmi,
+};
+
+module_hda_codec_driver(atihdmi_driver);
--- a/sound/hda/codecs/hdmi/eld.c
+++ b/sound/hda/codecs/hdmi/eld.c
@@ -12,7 +12,6 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <sound/core.h>
-#include <linux/unaligned.h>
 #include <sound/hda_chmap.h>
 #include <sound/hda_codec.h>
 #include "hda_local.h"
@@ -229,174 +228,3 @@ void snd_hdmi_eld_update_pcm_info(struct
 	hinfo->maxbps = min(hinfo->maxbps, maxbps);
 	hinfo->channels_max = min(hinfo->channels_max, channels_max);
 }
-
-
-/* ATI/AMD specific stuff (ELD emulation) */
-
-#define ATI_VERB_SET_AUDIO_DESCRIPTOR	0x776
-#define ATI_VERB_SET_SINK_INFO_INDEX	0x780
-#define ATI_VERB_GET_SPEAKER_ALLOCATION	0xf70
-#define ATI_VERB_GET_AUDIO_DESCRIPTOR	0xf76
-#define ATI_VERB_GET_AUDIO_VIDEO_DELAY	0xf7b
-#define ATI_VERB_GET_SINK_INFO_INDEX	0xf80
-#define ATI_VERB_GET_SINK_INFO_DATA	0xf81
-
-#define ATI_SPKALLOC_SPKALLOC		0x007f
-#define ATI_SPKALLOC_TYPE_HDMI		0x0100
-#define ATI_SPKALLOC_TYPE_DISPLAYPORT	0x0200
-
-/* first three bytes are just standard SAD */
-#define ATI_AUDIODESC_CHANNELS		0x00000007
-#define ATI_AUDIODESC_RATES		0x0000ff00
-#define ATI_AUDIODESC_LPCM_STEREO_RATES	0xff000000
-
-/* in standard HDMI VSDB format */
-#define ATI_DELAY_VIDEO_LATENCY		0x000000ff
-#define ATI_DELAY_AUDIO_LATENCY		0x0000ff00
-
-enum ati_sink_info_idx {
-	ATI_INFO_IDX_MANUFACTURER_ID	= 0,
-	ATI_INFO_IDX_PRODUCT_ID		= 1,
-	ATI_INFO_IDX_SINK_DESC_LEN	= 2,
-	ATI_INFO_IDX_PORT_ID_LOW	= 3,
-	ATI_INFO_IDX_PORT_ID_HIGH	= 4,
-	ATI_INFO_IDX_SINK_DESC_FIRST	= 5,
-	ATI_INFO_IDX_SINK_DESC_LAST	= 22, /* max len 18 bytes */
-};
-
-int snd_hdmi_get_eld_ati(struct hda_codec *codec, hda_nid_t nid,
-			 unsigned char *buf, int *eld_size, bool rev3_or_later)
-{
-	int spkalloc, ati_sad, aud_synch;
-	int sink_desc_len = 0;
-	int pos, i;
-
-	/* ATI/AMD does not have ELD, emulate it */
-
-	spkalloc = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_SPEAKER_ALLOCATION, 0);
-
-	if (spkalloc <= 0) {
-		codec_info(codec, "HDMI ATI/AMD: no speaker allocation for ELD\n");
-		return -EINVAL;
-	}
-
-	memset(buf, 0, ELD_FIXED_BYTES + ELD_MAX_MNL + ELD_MAX_SAD * 3);
-
-	/* version */
-	buf[0] = ELD_VER_CEA_861D << 3;
-
-	/* speaker allocation from EDID */
-	buf[7] = spkalloc & ATI_SPKALLOC_SPKALLOC;
-
-	/* is DisplayPort? */
-	if (spkalloc & ATI_SPKALLOC_TYPE_DISPLAYPORT)
-		buf[5] |= 0x04;
-
-	pos = ELD_FIXED_BYTES;
-
-	if (rev3_or_later) {
-		int sink_info;
-
-		snd_hda_codec_write(codec, nid, 0, ATI_VERB_SET_SINK_INFO_INDEX, ATI_INFO_IDX_PORT_ID_LOW);
-		sink_info = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_SINK_INFO_DATA, 0);
-		put_unaligned_le32(sink_info, buf + 8);
-
-		snd_hda_codec_write(codec, nid, 0, ATI_VERB_SET_SINK_INFO_INDEX, ATI_INFO_IDX_PORT_ID_HIGH);
-		sink_info = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_SINK_INFO_DATA, 0);
-		put_unaligned_le32(sink_info, buf + 12);
-
-		snd_hda_codec_write(codec, nid, 0, ATI_VERB_SET_SINK_INFO_INDEX, ATI_INFO_IDX_MANUFACTURER_ID);
-		sink_info = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_SINK_INFO_DATA, 0);
-		put_unaligned_le16(sink_info, buf + 16);
-
-		snd_hda_codec_write(codec, nid, 0, ATI_VERB_SET_SINK_INFO_INDEX, ATI_INFO_IDX_PRODUCT_ID);
-		sink_info = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_SINK_INFO_DATA, 0);
-		put_unaligned_le16(sink_info, buf + 18);
-
-		snd_hda_codec_write(codec, nid, 0, ATI_VERB_SET_SINK_INFO_INDEX, ATI_INFO_IDX_SINK_DESC_LEN);
-		sink_desc_len = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_SINK_INFO_DATA, 0);
-
-		if (sink_desc_len > ELD_MAX_MNL) {
-			codec_info(codec, "HDMI ATI/AMD: Truncating HDMI sink description with length %d\n",
-				   sink_desc_len);
-			sink_desc_len = ELD_MAX_MNL;
-		}
-
-		buf[4] |= sink_desc_len;
-
-		for (i = 0; i < sink_desc_len; i++) {
-			snd_hda_codec_write(codec, nid, 0, ATI_VERB_SET_SINK_INFO_INDEX, ATI_INFO_IDX_SINK_DESC_FIRST + i);
-			buf[pos++] = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_SINK_INFO_DATA, 0);
-		}
-	}
-
-	for (i = AUDIO_CODING_TYPE_LPCM; i <= AUDIO_CODING_TYPE_WMAPRO; i++) {
-		if (i == AUDIO_CODING_TYPE_SACD || i == AUDIO_CODING_TYPE_DST)
-			continue; /* not handled by ATI/AMD */
-
-		snd_hda_codec_write(codec, nid, 0, ATI_VERB_SET_AUDIO_DESCRIPTOR, i << 3);
-		ati_sad = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_AUDIO_DESCRIPTOR, 0);
-
-		if (ati_sad <= 0)
-			continue;
-
-		if (ati_sad & ATI_AUDIODESC_RATES) {
-			/* format is supported, copy SAD as-is */
-			buf[pos++] = (ati_sad & 0x0000ff) >> 0;
-			buf[pos++] = (ati_sad & 0x00ff00) >> 8;
-			buf[pos++] = (ati_sad & 0xff0000) >> 16;
-		}
-
-		if (i == AUDIO_CODING_TYPE_LPCM
-		    && (ati_sad & ATI_AUDIODESC_LPCM_STEREO_RATES)
-		    && (ati_sad & ATI_AUDIODESC_LPCM_STEREO_RATES) >> 16 != (ati_sad & ATI_AUDIODESC_RATES)) {
-			/* for PCM there is a separate stereo rate mask */
-			buf[pos++] = ((ati_sad & 0x000000ff) & ~ATI_AUDIODESC_CHANNELS) | 0x1;
-			/* rates from the extra byte */
-			buf[pos++] = (ati_sad & 0xff000000) >> 24;
-			buf[pos++] = (ati_sad & 0x00ff0000) >> 16;
-		}
-	}
-
-	if (pos == ELD_FIXED_BYTES + sink_desc_len) {
-		codec_info(codec, "HDMI ATI/AMD: no audio descriptors for ELD\n");
-		return -EINVAL;
-	}
-
-	/*
-	 * HDMI VSDB latency format:
-	 * separately for both audio and video:
-	 *  0          field not valid or unknown latency
-	 *  [1..251]   msecs = (x-1)*2  (max 500ms with x = 251 = 0xfb)
-	 *  255        audio/video not supported
-	 *
-	 * HDA latency format:
-	 * single value indicating video latency relative to audio:
-	 *  0          unknown or 0ms
-	 *  [1..250]   msecs = x*2  (max 500ms with x = 250 = 0xfa)
-	 *  [251..255] reserved
-	 */
-	aud_synch = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_AUDIO_VIDEO_DELAY, 0);
-	if ((aud_synch & ATI_DELAY_VIDEO_LATENCY) && (aud_synch & ATI_DELAY_AUDIO_LATENCY)) {
-		int video_latency_hdmi = (aud_synch & ATI_DELAY_VIDEO_LATENCY);
-		int audio_latency_hdmi = (aud_synch & ATI_DELAY_AUDIO_LATENCY) >> 8;
-
-		if (video_latency_hdmi <= 0xfb && audio_latency_hdmi <= 0xfb &&
-		    video_latency_hdmi > audio_latency_hdmi)
-			buf[6] = video_latency_hdmi - audio_latency_hdmi;
-		/* else unknown/invalid or 0ms or video ahead of audio, so use zero */
-	}
-
-	/* SAD count */
-	buf[5] |= ((pos - ELD_FIXED_BYTES - sink_desc_len) / 3) << 4;
-
-	/* Baseline ELD block length is 4-byte aligned */
-	pos = round_up(pos, 4);
-
-	/* Baseline ELD length (4-byte header is not counted in) */
-	buf[2] = (pos - 4) / 4;
-
-	*eld_size = pos;
-
-	return 0;
-}
--- a/sound/hda/codecs/hdmi/hdmi.c
+++ b/sound/hda/codecs/hdmi/hdmi.c
@@ -33,6 +33,7 @@
 #include "hda_local.h"
 #include "hda_jack.h"
 #include "hda_controller.h"
+#include "hdmi_local.h"
 
 static bool static_hdmi_pcm;
 module_param(static_hdmi_pcm, bool, 0644);
@@ -42,214 +43,12 @@ static bool enable_acomp = true;
 module_param(enable_acomp, bool, 0444);
 MODULE_PARM_DESC(enable_acomp, "Enable audio component binding (default=yes)");
 
-static bool enable_silent_stream =
-IS_ENABLED(CONFIG_SND_HDA_INTEL_HDMI_SILENT_STREAM);
-module_param(enable_silent_stream, bool, 0644);
-MODULE_PARM_DESC(enable_silent_stream, "Enable Silent Stream for HDMI devices");
-
 static bool enable_all_pins;
 module_param(enable_all_pins, bool, 0444);
 MODULE_PARM_DESC(enable_all_pins, "Forcibly enable all pins");
 
-struct hdmi_spec_per_cvt {
-	hda_nid_t cvt_nid;
-	bool assigned;		/* the stream has been assigned */
-	bool silent_stream;	/* silent stream activated */
-	unsigned int channels_min;
-	unsigned int channels_max;
-	u32 rates;
-	u64 formats;
-	unsigned int maxbps;
-};
-
-/* max. connections to a widget */
-#define HDA_MAX_CONNECTIONS	32
-
-struct hdmi_spec_per_pin {
-	hda_nid_t pin_nid;
-	int dev_id;
-	/* pin idx, different device entries on the same pin use the same idx */
-	int pin_nid_idx;
-	int num_mux_nids;
-	hda_nid_t mux_nids[HDA_MAX_CONNECTIONS];
-	int mux_idx;
-	hda_nid_t cvt_nid;
-
-	struct hda_codec *codec;
-	struct hdmi_eld sink_eld;
-	struct mutex lock;
-	struct delayed_work work;
-	struct hdmi_pcm *pcm; /* pointer to spec->pcm_rec[n] dynamically*/
-	int pcm_idx; /* which pcm is attached. -1 means no pcm is attached */
-	int prev_pcm_idx; /* previously assigned pcm index */
-	int repoll_count;
-	bool setup; /* the stream has been set up by prepare callback */
-	bool silent_stream;
-	int channels; /* current number of channels */
-	bool non_pcm;
-	bool chmap_set;		/* channel-map override by ALSA API? */
-	unsigned char chmap[8]; /* ALSA API channel-map */
-#ifdef CONFIG_SND_PROC_FS
-	struct snd_info_entry *proc_entry;
-#endif
-};
-
-/* operations used by generic code that can be overridden by patches */
-struct hdmi_ops {
-	int (*pin_get_eld)(struct hda_codec *codec, hda_nid_t pin_nid,
-			   int dev_id, unsigned char *buf, int *eld_size);
-
-	void (*pin_setup_infoframe)(struct hda_codec *codec, hda_nid_t pin_nid,
-				    int dev_id,
-				    int ca, int active_channels, int conn_type);
-
-	/* enable/disable HBR (HD passthrough) */
-	int (*pin_hbr_setup)(struct hda_codec *codec, hda_nid_t pin_nid,
-			     int dev_id, bool hbr);
-
-	int (*setup_stream)(struct hda_codec *codec, hda_nid_t cvt_nid,
-			    hda_nid_t pin_nid, int dev_id, u32 stream_tag,
-			    int format);
-
-	void (*pin_cvt_fixup)(struct hda_codec *codec,
-			      struct hdmi_spec_per_pin *per_pin,
-			      hda_nid_t cvt_nid);
-};
-
-struct hdmi_pcm {
-	struct hda_pcm *pcm;
-	struct snd_jack *jack;
-	struct snd_kcontrol *eld_ctl;
-};
-
-enum {
-	SILENT_STREAM_OFF = 0,
-	SILENT_STREAM_KAE,	/* use standard HDA Keep-Alive */
-	SILENT_STREAM_I915,	/* Intel i915 extension */
-};
-
-struct hdmi_spec {
-	struct hda_codec *codec;
-	int num_cvts;
-	struct snd_array cvts; /* struct hdmi_spec_per_cvt */
-	hda_nid_t cvt_nids[4]; /* only for haswell fix */
-
-	/*
-	 * num_pins is the number of virtual pins
-	 * for example, there are 3 pins, and each pin
-	 * has 4 device entries, then the num_pins is 12
-	 */
-	int num_pins;
-	/*
-	 * num_nids is the number of real pins
-	 * In the above example, num_nids is 3
-	 */
-	int num_nids;
-	/*
-	 * dev_num is the number of device entries
-	 * on each pin.
-	 * In the above example, dev_num is 4
-	 */
-	int dev_num;
-	struct snd_array pins; /* struct hdmi_spec_per_pin */
-	struct hdmi_pcm pcm_rec[8];
-	struct mutex pcm_lock;
-	struct mutex bind_lock; /* for audio component binding */
-	/* pcm_bitmap means which pcms have been assigned to pins*/
-	unsigned long pcm_bitmap;
-	int pcm_used;	/* counter of pcm_rec[] */
-	/* bitmap shows whether the pcm is opened in user space
-	 * bit 0 means the first playback PCM (PCM3);
-	 * bit 1 means the second playback PCM, and so on.
-	 */
-	unsigned long pcm_in_use;
-
-	struct hdmi_eld temp_eld;
-	struct hdmi_ops ops;
-
-	bool dyn_pin_out;
-	bool static_pcm_mapping;
-	/* hdmi interrupt trigger control flag for Nvidia codec */
-	bool hdmi_intr_trig_ctrl;
-	bool nv_dp_workaround; /* workaround DP audio infoframe for Nvidia */
-
-	bool intel_hsw_fixup;	/* apply Intel platform-specific fixups */
-	/*
-	 * Non-generic VIA/NVIDIA specific
-	 */
-	struct hda_multi_out multiout;
-	struct hda_pcm_stream pcm_playback;
-
-	bool use_acomp_notifier; /* use eld_notify callback for hotplug */
-	bool acomp_registered; /* audio component registered in this driver */
-	bool force_connect; /* force connectivity */
-	struct drm_audio_component_audio_ops drm_audio_ops;
-	int (*port2pin)(struct hda_codec *, int); /* reverse port/pin mapping */
-
-	struct hdac_chmap chmap;
-	hda_nid_t vendor_nid;
-	const int *port_map;
-	int port_num;
-	int silent_stream_type;
-};
-
-#ifdef CONFIG_SND_HDA_COMPONENT
-static inline bool codec_has_acomp(struct hda_codec *codec)
-{
-	struct hdmi_spec *spec = codec->spec;
-	return spec->use_acomp_notifier;
-}
-#else
-#define codec_has_acomp(codec)	false
-#endif
-
-struct hdmi_audio_infoframe {
-	u8 type; /* 0x84 */
-	u8 ver;  /* 0x01 */
-	u8 len;  /* 0x0a */
-
-	u8 checksum;
-
-	u8 CC02_CT47;	/* CC in bits 0:2, CT in 4:7 */
-	u8 SS01_SF24;
-	u8 CXT04;
-	u8 CA;
-	u8 LFEPBL01_LSV36_DM_INH7;
-};
-
-struct dp_audio_infoframe {
-	u8 type; /* 0x84 */
-	u8 len;  /* 0x1b */
-	u8 ver;  /* 0x11 << 2 */
-
-	u8 CC02_CT47;	/* match with HDMI infoframe from this on */
-	u8 SS01_SF24;
-	u8 CXT04;
-	u8 CA;
-	u8 LFEPBL01_LSV36_DM_INH7;
-};
-
-union audio_infoframe {
-	struct hdmi_audio_infoframe hdmi;
-	struct dp_audio_infoframe dp;
-	DECLARE_FLEX_ARRAY(u8, bytes);
-};
-
-/*
- * HDMI routines
- */
-
-#define get_pin(spec, idx) \
-	((struct hdmi_spec_per_pin *)snd_array_elem(&spec->pins, idx))
-#define get_cvt(spec, idx) \
-	((struct hdmi_spec_per_cvt  *)snd_array_elem(&spec->cvts, idx))
-/* obtain hdmi_pcm object assigned to idx */
-#define get_hdmi_pcm(spec, idx)	(&(spec)->pcm_rec[idx])
-/* obtain hda_pcm object assigned to idx */
-#define get_pcm_rec(spec, idx)	(get_hdmi_pcm(spec, idx)->pcm)
-
-static int pin_id_to_pin_index(struct hda_codec *codec,
-			       hda_nid_t pin_nid, int dev_id)
+int snd_hda_hdmi_pin_id_to_pin_index(struct hda_codec *codec,
+				     hda_nid_t pin_nid, int dev_id)
 {
 	struct hdmi_spec *spec = codec->spec;
 	int pin_idx;
@@ -272,6 +71,7 @@ static int pin_id_to_pin_index(struct hd
 	codec_warn(codec, "HDMI: pin NID 0x%x not registered\n", pin_nid);
 	return -EINVAL;
 }
+EXPORT_SYMBOL_NS_GPL(snd_hda_hdmi_pin_id_to_pin_index, SND_HDA_CODEC_HDMI);
 
 static int hinfo_to_pcm_index(struct hda_codec *codec,
 			struct hda_pcm_stream *hinfo)
@@ -735,9 +535,9 @@ static void hdmi_pin_setup_infoframe(str
 	}
 }
 
-static void hdmi_setup_audio_infoframe(struct hda_codec *codec,
-				       struct hdmi_spec_per_pin *per_pin,
-				       bool non_pcm)
+void snd_hda_hdmi_setup_audio_infoframe(struct hda_codec *codec,
+					struct hdmi_spec_per_pin *per_pin,
+					bool non_pcm)
 {
 	struct hdmi_spec *spec = codec->spec;
 	struct hdac_chmap *chmap = &spec->chmap;
@@ -783,6 +583,7 @@ static void hdmi_setup_audio_infoframe(s
 
 	per_pin->non_pcm = non_pcm;
 }
+EXPORT_SYMBOL_NS_GPL(snd_hda_hdmi_setup_audio_infoframe, SND_HDA_CODEC_HDMI);
 
 /*
  * Unsolicited events
@@ -790,8 +591,8 @@ static void hdmi_setup_audio_infoframe(s
 
 static void hdmi_present_sense(struct hdmi_spec_per_pin *per_pin, int repoll);
 
-static void check_presence_and_report(struct hda_codec *codec, hda_nid_t nid,
-				      int dev_id)
+void snd_hda_hdmi_check_presence_and_report(struct hda_codec *codec,
+					    hda_nid_t nid, int dev_id)
 {
 	struct hdmi_spec *spec = codec->spec;
 	int pin_idx = pin_id_to_pin_index(codec, nid, dev_id);
@@ -802,6 +603,8 @@ static void check_presence_and_report(st
 	hdmi_present_sense(get_pin(spec, pin_idx), 1);
 	mutex_unlock(&spec->pcm_lock);
 }
+EXPORT_SYMBOL_NS_GPL(snd_hda_hdmi_check_presence_and_report,
+		     SND_HDA_CODEC_HDMI);
 
 static void jack_callback(struct hda_codec *codec,
 			  struct hda_jack_callback *jack)
@@ -810,7 +613,7 @@ static void jack_callback(struct hda_cod
 	if (codec_has_acomp(codec))
 		return;
 
-	check_presence_and_report(codec, jack->nid, jack->dev_id);
+	snd_hda_hdmi_check_presence_and_report(codec, jack->nid, jack->dev_id);
 }
 
 static void hdmi_intrinsic_event(struct hda_codec *codec, unsigned int res,
@@ -823,7 +626,7 @@ static void hdmi_intrinsic_event(struct
 		codec->addr, jack->nid, jack->dev_id, !!(res & AC_UNSOL_RES_IA),
 		!!(res & AC_UNSOL_RES_PD), !!(res & AC_UNSOL_RES_ELDV));
 
-	check_presence_and_report(codec, jack->nid, jack->dev_id);
+	snd_hda_hdmi_check_presence_and_report(codec, jack->nid, jack->dev_id);
 }
 
 static void hdmi_non_intrinsic_event(struct hda_codec *codec, unsigned int res)
@@ -850,8 +653,7 @@ static void hdmi_non_intrinsic_event(str
 	}
 }
 
-
-static void hdmi_unsol_event(struct hda_codec *codec, unsigned int res)
+void snd_hda_hdmi_generic_unsol_event(struct hda_codec *codec, unsigned int res)
 {
 	int tag = res >> AC_UNSOL_RES_TAG_SHIFT;
 	int subtag = (res & AC_UNSOL_RES_SUBTAG) >> AC_UNSOL_RES_SUBTAG_SHIFT;
@@ -879,27 +681,7 @@ static void hdmi_unsol_event(struct hda_
 	else
 		hdmi_non_intrinsic_event(codec, res);
 }
-
-static void haswell_verify_D0(struct hda_codec *codec,
-		hda_nid_t cvt_nid, hda_nid_t nid)
-{
-	int pwr;
-
-	/* For Haswell, the converter 1/2 may keep in D3 state after bootup,
-	 * thus pins could only choose converter 0 for use. Make sure the
-	 * converters are in correct power state */
-	if (!snd_hda_check_power_state(codec, cvt_nid, AC_PWRST_D0))
-		snd_hda_codec_write(codec, cvt_nid, 0, AC_VERB_SET_POWER_STATE, AC_PWRST_D0);
-
-	if (!snd_hda_check_power_state(codec, nid, AC_PWRST_D0)) {
-		snd_hda_codec_write(codec, nid, 0, AC_VERB_SET_POWER_STATE,
-				    AC_PWRST_D0);
-		msleep(40);
-		pwr = snd_hda_codec_read(codec, nid, 0, AC_VERB_GET_POWER_STATE, 0);
-		pwr = (pwr & AC_PWRST_ACTUAL) >> AC_PWRST_ACTUAL_SHIFT;
-		codec_dbg(codec, "Haswell HDMI audio: Power for NID 0x%x is now D%d\n", nid, pwr);
-	}
-}
+EXPORT_SYMBOL_NS_GPL(snd_hda_hdmi_generic_unsol_event, SND_HDA_CODEC_HDMI);
 
 /*
  * Callbacks
@@ -944,7 +726,8 @@ static int hdmi_pin_hbr_setup(struct hda
 	return 0;
 }
 
-static int hdmi_setup_stream(struct hda_codec *codec, hda_nid_t cvt_nid,
+int snd_hda_hdmi_setup_stream(struct hda_codec *codec,
+			      hda_nid_t cvt_nid,
 			      hda_nid_t pin_nid, int dev_id,
 			      u32 stream_tag, int format)
 {
@@ -983,6 +766,7 @@ static int hdmi_setup_stream(struct hda_
 	snd_hda_codec_setup_stream(codec, cvt_nid, stream_tag, 0, format);
 	return 0;
 }
+EXPORT_SYMBOL_NS_GPL(snd_hda_hdmi_setup_stream, SND_HDA_CODEC_HDMI);
 
 /* Try to find an available converter
  * If pin_idx is less then zero, just try to find an available converter.
@@ -1046,137 +830,6 @@ static int hdmi_choose_cvt(struct hda_co
 	return 0;
 }
 
-/* Assure the pin select the right convetor */
-static void intel_verify_pin_cvt_connect(struct hda_codec *codec,
-			struct hdmi_spec_per_pin *per_pin)
-{
-	hda_nid_t pin_nid = per_pin->pin_nid;
-	int mux_idx, curr;
-
-	mux_idx = per_pin->mux_idx;
-	curr = snd_hda_codec_read(codec, pin_nid, 0,
-					  AC_VERB_GET_CONNECT_SEL, 0);
-	if (curr != mux_idx)
-		snd_hda_codec_write_cache(codec, pin_nid, 0,
-					    AC_VERB_SET_CONNECT_SEL,
-					    mux_idx);
-}
-
-/* get the mux index for the converter of the pins
- * converter's mux index is the same for all pins on Intel platform
- */
-static int intel_cvt_id_to_mux_idx(struct hdmi_spec *spec,
-			hda_nid_t cvt_nid)
-{
-	int i;
-
-	for (i = 0; i < spec->num_cvts; i++)
-		if (spec->cvt_nids[i] == cvt_nid)
-			return i;
-	return -EINVAL;
-}
-
-/* Intel HDMI workaround to fix audio routing issue:
- * For some Intel display codecs, pins share the same connection list.
- * So a conveter can be selected by multiple pins and playback on any of these
- * pins will generate sound on the external display, because audio flows from
- * the same converter to the display pipeline. Also muting one pin may make
- * other pins have no sound output.
- * So this function assures that an assigned converter for a pin is not selected
- * by any other pins.
- */
-static void intel_not_share_assigned_cvt(struct hda_codec *codec,
-					 hda_nid_t pin_nid,
-					 int dev_id, int mux_idx)
-{
-	struct hdmi_spec *spec = codec->spec;
-	hda_nid_t nid;
-	int cvt_idx, curr;
-	struct hdmi_spec_per_cvt *per_cvt;
-	struct hdmi_spec_per_pin *per_pin;
-	int pin_idx;
-
-	/* configure the pins connections */
-	for (pin_idx = 0; pin_idx < spec->num_pins; pin_idx++) {
-		int dev_id_saved;
-		int dev_num;
-
-		per_pin = get_pin(spec, pin_idx);
-		/*
-		 * pin not connected to monitor
-		 * no need to operate on it
-		 */
-		if (!per_pin->pcm)
-			continue;
-
-		if ((per_pin->pin_nid == pin_nid) &&
-			(per_pin->dev_id == dev_id))
-			continue;
-
-		/*
-		 * if per_pin->dev_id >= dev_num,
-		 * snd_hda_get_dev_select() will fail,
-		 * and the following operation is unpredictable.
-		 * So skip this situation.
-		 */
-		dev_num = snd_hda_get_num_devices(codec, per_pin->pin_nid) + 1;
-		if (per_pin->dev_id >= dev_num)
-			continue;
-
-		nid = per_pin->pin_nid;
-
-		/*
-		 * Calling this function should not impact
-		 * on the device entry selection
-		 * So let's save the dev id for each pin,
-		 * and restore it when return
-		 */
-		dev_id_saved = snd_hda_get_dev_select(codec, nid);
-		snd_hda_set_dev_select(codec, nid, per_pin->dev_id);
-		curr = snd_hda_codec_read(codec, nid, 0,
-					  AC_VERB_GET_CONNECT_SEL, 0);
-		if (curr != mux_idx) {
-			snd_hda_set_dev_select(codec, nid, dev_id_saved);
-			continue;
-		}
-
-
-		/* choose an unassigned converter. The conveters in the
-		 * connection list are in the same order as in the codec.
-		 */
-		for (cvt_idx = 0; cvt_idx < spec->num_cvts; cvt_idx++) {
-			per_cvt = get_cvt(spec, cvt_idx);
-			if (!per_cvt->assigned) {
-				codec_dbg(codec,
-					  "choose cvt %d for pin NID 0x%x\n",
-					  cvt_idx, nid);
-				snd_hda_codec_write_cache(codec, nid, 0,
-					    AC_VERB_SET_CONNECT_SEL,
-					    cvt_idx);
-				break;
-			}
-		}
-		snd_hda_set_dev_select(codec, nid, dev_id_saved);
-	}
-}
-
-/* A wrapper of intel_not_share_asigned_cvt() */
-static void intel_not_share_assigned_cvt_nid(struct hda_codec *codec,
-			hda_nid_t pin_nid, int dev_id, hda_nid_t cvt_nid)
-{
-	int mux_idx;
-	struct hdmi_spec *spec = codec->spec;
-
-	/* On Intel platform, the mapping of converter nid to
-	 * mux index of the pins are always the same.
-	 * The pin nid may be 0, this means all pins will not
-	 * share the converter.
-	 */
-	mux_idx = intel_cvt_id_to_mux_idx(spec, cvt_nid);
-	if (mux_idx >= 0)
-		intel_not_share_assigned_cvt(codec, pin_nid, dev_id, mux_idx);
-}
-
 /* skeleton caller of pin_cvt_fixup ops */
 static void pin_cvt_fixup(struct hda_codec *codec,
 			  struct hdmi_spec_per_pin *per_pin,
@@ -1466,7 +1119,7 @@ static void hdmi_pcm_setup_pin(struct hd
 	per_pin->setup = true;
 	per_pin->mux_idx = mux_idx;
 
-	hdmi_setup_audio_infoframe(codec, per_pin, non_pcm);
+	snd_hda_hdmi_setup_audio_infoframe(codec, per_pin, non_pcm);
 }
 
 static void hdmi_pcm_reset_pin(struct hdmi_spec *spec,
@@ -1583,7 +1236,7 @@ static void update_eld(struct hda_codec
 	 */
 	if (eld->eld_valid && !old_eld_valid && per_pin->setup) {
 		pin_cvt_fixup(codec, per_pin, 0);
-		hdmi_setup_audio_infoframe(codec, per_pin, per_pin->non_pcm);
+		snd_hda_hdmi_setup_audio_infoframe(codec, per_pin, per_pin->non_pcm);
 	}
 
 	if (eld_changed && pcm_idx >= 0)
@@ -1653,57 +1306,12 @@ static void hdmi_present_sense_via_verbs
 	snd_hda_power_down_pm(codec);
 }
 
-#define I915_SILENT_RATE		48000
-#define I915_SILENT_CHANNELS		2
-#define I915_SILENT_FORMAT_BITS	16
-#define I915_SILENT_FMT_MASK		0xf
-
-static void silent_stream_enable_i915(struct hda_codec *codec,
-				      struct hdmi_spec_per_pin *per_pin)
-{
-	unsigned int format;
-
-	snd_hdac_sync_audio_rate(&codec->core, per_pin->pin_nid,
-				 per_pin->dev_id, I915_SILENT_RATE);
-
-	/* trigger silent stream generation in hw */
-	format = snd_hdac_stream_format(I915_SILENT_CHANNELS, I915_SILENT_FORMAT_BITS,
-					I915_SILENT_RATE);
-	snd_hda_codec_setup_stream(codec, per_pin->cvt_nid,
-				   I915_SILENT_FMT_MASK, I915_SILENT_FMT_MASK, format);
-	usleep_range(100, 200);
-	snd_hda_codec_setup_stream(codec, per_pin->cvt_nid, I915_SILENT_FMT_MASK, 0, format);
-
-	per_pin->channels = I915_SILENT_CHANNELS;
-	hdmi_setup_audio_infoframe(codec, per_pin, per_pin->non_pcm);
-}
-
-static void silent_stream_set_kae(struct hda_codec *codec,
-				  struct hdmi_spec_per_pin *per_pin,
-				  bool enable)
-{
-	unsigned int param;
-
-	codec_dbg(codec, "HDMI: KAE %d cvt-NID=0x%x\n", enable, per_pin->cvt_nid);
-
-	param = snd_hda_codec_read(codec, per_pin->cvt_nid, 0, AC_VERB_GET_DIGI_CONVERT_1, 0);
-	param = (param >> 16) & 0xff;
-
-	if (enable)
-		param |= AC_DIG3_KAE;
-	else
-		param &= ~AC_DIG3_KAE;
-
-	snd_hda_codec_write(codec, per_pin->cvt_nid, 0, AC_VERB_SET_DIGI_CONVERT_3, param);
-}
-
 static void silent_stream_enable(struct hda_codec *codec,
 				 struct hdmi_spec_per_pin *per_pin)
 {
 	struct hdmi_spec *spec = codec->spec;
 	struct hdmi_spec_per_cvt *per_cvt;
 	int cvt_idx, pin_idx, err;
-	int keep_power = 0;
 
 	/*
 	 * Power-up will call hdmi_present_sense, so the PM calls
@@ -1749,24 +1357,12 @@ static void silent_stream_enable(struct
 	/* configure unused pins to choose other converters */
 	pin_cvt_fixup(codec, per_pin, 0);
 
-	switch (spec->silent_stream_type) {
-	case SILENT_STREAM_KAE:
-		silent_stream_enable_i915(codec, per_pin);
-		silent_stream_set_kae(codec, per_pin, true);
-		break;
-	case SILENT_STREAM_I915:
-		silent_stream_enable_i915(codec, per_pin);
-		keep_power = 1;
-		break;
-	default:
-		break;
-	}
+	spec->ops.silent_stream(codec, per_pin, true);
 
  unlock_out:
 	mutex_unlock(&per_pin->lock);
 
-	if (err || !keep_power)
-		snd_hda_power_down_pm(codec);
+	snd_hda_power_down_pm(codec);
 }
 
 static void silent_stream_disable(struct hda_codec *codec,
@@ -1798,12 +1394,7 @@ static void silent_stream_disable(struct
 		per_cvt->silent_stream = false;
 	}
 
-	if (spec->silent_stream_type == SILENT_STREAM_I915) {
-		/* release ref taken in silent_stream_enable() */
-		snd_hda_power_down_pm(codec);
-	} else if (spec->silent_stream_type == SILENT_STREAM_KAE) {
-		silent_stream_set_kae(codec, per_pin, false);
-	}
+	spec->ops.silent_stream(codec, per_pin, false);
 
 	per_pin->cvt_nid = 0;
 	per_pin->silent_stream = false;
@@ -2003,7 +1594,7 @@ static const struct snd_pci_quirk force_
 	{}
 };
 
-static int hdmi_parse_codec(struct hda_codec *codec)
+int snd_hda_hdmi_parse_codec(struct hda_codec *codec)
 {
 	struct hdmi_spec *spec = codec->spec;
 	hda_nid_t start_nid;
@@ -2056,6 +1647,7 @@ static int hdmi_parse_codec(struct hda_c
 
 	return 0;
 }
+EXPORT_SYMBOL_NS_GPL(snd_hda_hdmi_parse_codec, SND_HDA_CODEC_HDMI);
 
 /*
  */
@@ -2082,11 +1674,11 @@ static bool check_non_pcm_per_cvt(struct
  * HDMI callbacks
  */
 
-static int generic_hdmi_playback_pcm_prepare(struct hda_pcm_stream *hinfo,
-					   struct hda_codec *codec,
-					   unsigned int stream_tag,
-					   unsigned int format,
-					   struct snd_pcm_substream *substream)
+int snd_hda_hdmi_generic_pcm_prepare(struct hda_pcm_stream *hinfo,
+				     struct hda_codec *codec,
+				     unsigned int stream_tag,
+				     unsigned int format,
+				     struct snd_pcm_substream *substream)
 {
 	hda_nid_t cvt_nid = hinfo->nid;
 	struct hdmi_spec *spec = codec->spec;
@@ -2140,7 +1732,7 @@ static int generic_hdmi_playback_pcm_pre
 				    stripe);
 	}
 
-	hdmi_setup_audio_infoframe(codec, per_pin, non_pcm);
+	snd_hda_hdmi_setup_audio_infoframe(codec, per_pin, non_pcm);
 	mutex_unlock(&per_pin->lock);
 	if (spec->dyn_pin_out) {
 		snd_hda_set_dev_select(codec, per_pin->pin_nid,
@@ -2159,14 +1751,16 @@ static int generic_hdmi_playback_pcm_pre
 	mutex_unlock(&spec->pcm_lock);
 	return err;
 }
+EXPORT_SYMBOL_NS_GPL(snd_hda_hdmi_generic_pcm_prepare, SND_HDA_CODEC_HDMI);
 
-static int generic_hdmi_playback_pcm_cleanup(struct hda_pcm_stream *hinfo,
-					     struct hda_codec *codec,
-					     struct snd_pcm_substream *substream)
+int snd_hda_hdmi_generic_pcm_cleanup(struct hda_pcm_stream *hinfo,
+				     struct hda_codec *codec,
+				     struct snd_pcm_substream *substream)
 {
 	snd_hda_codec_cleanup_stream(codec, hinfo->nid);
 	return 0;
 }
+EXPORT_SYMBOL_NS_GPL(snd_hda_hdmi_generic_pcm_cleanup, SND_HDA_CODEC_HDMI);
 
 static int hdmi_pcm_close(struct hda_pcm_stream *hinfo,
 			  struct hda_codec *codec,
@@ -2237,8 +1831,8 @@ unlock:
 static const struct hda_pcm_ops generic_ops = {
 	.open = hdmi_pcm_open,
 	.close = hdmi_pcm_close,
-	.prepare = generic_hdmi_playback_pcm_prepare,
-	.cleanup = generic_hdmi_playback_pcm_cleanup,
+	.prepare = snd_hda_hdmi_generic_pcm_prepare,
+	.cleanup = snd_hda_hdmi_generic_pcm_cleanup,
 };
 
 static int hdmi_get_spk_alloc(struct hdac_device *hdac, int pcm_idx)
@@ -2280,7 +1874,7 @@ static void hdmi_set_chmap(struct hdac_d
 	per_pin->chmap_set = true;
 	memcpy(per_pin->chmap, chmap, ARRAY_SIZE(per_pin->chmap));
 	if (prepared)
-		hdmi_setup_audio_infoframe(codec, per_pin, per_pin->non_pcm);
+		snd_hda_hdmi_setup_audio_infoframe(codec, per_pin, per_pin->non_pcm);
 	mutex_unlock(&per_pin->lock);
 }
 
@@ -2293,7 +1887,7 @@ static bool is_hdmi_pcm_attached(struct
 	return per_pin ? true:false;
 }
 
-static int generic_hdmi_build_pcms(struct hda_codec *codec)
+int snd_hda_hdmi_generic_build_pcms(struct hda_codec *codec)
 {
 	struct hdmi_spec *spec = codec->spec;
 	int idx, pcm_num;
@@ -2332,6 +1926,7 @@ static int generic_hdmi_build_pcms(struc
 
 	return 0;
 }
+EXPORT_SYMBOL_NS_GPL(snd_hda_hdmi_generic_build_pcms, SND_HDA_CODEC_HDMI);
 
 static void free_hdmi_jack_priv(struct snd_jack *jack)
 {
@@ -2362,7 +1957,7 @@ static int generic_hdmi_build_jack(struc
 	return 0;
 }
 
-static int generic_hdmi_build_controls(struct hda_codec *codec)
+int snd_hda_hdmi_generic_build_controls(struct hda_codec *codec)
 {
 	struct hdmi_spec *spec = codec->spec;
 	int dev, err;
@@ -2425,8 +2020,9 @@ static int generic_hdmi_build_controls(s
 
 	return 0;
 }
+EXPORT_SYMBOL_NS_GPL(snd_hda_hdmi_generic_build_controls, SND_HDA_CODEC_HDMI);
 
-static int generic_hdmi_init_per_pins(struct hda_codec *codec)
+int snd_hda_hdmi_generic_init_per_pins(struct hda_codec *codec)
 {
 	struct hdmi_spec *spec = codec->spec;
 	int pin_idx;
@@ -2441,8 +2037,9 @@ static int generic_hdmi_init_per_pins(st
 	}
 	return 0;
 }
+EXPORT_SYMBOL_NS_GPL(snd_hda_hdmi_generic_init_per_pins, SND_HDA_CODEC_HDMI);
 
-static int generic_hdmi_init(struct hda_codec *codec)
+int snd_hda_hdmi_generic_init(struct hda_codec *codec)
 {
 	struct hdmi_spec *spec = codec->spec;
 	int pin_idx;
@@ -2463,6 +2060,7 @@ static int generic_hdmi_init(struct hda_
 	mutex_unlock(&spec->bind_lock);
 	return 0;
 }
+EXPORT_SYMBOL_NS_GPL(snd_hda_hdmi_generic_init, SND_HDA_CODEC_HDMI);
 
 static void hdmi_array_init(struct hdmi_spec *spec, int nums)
 {
@@ -2476,7 +2074,7 @@ static void hdmi_array_free(struct hdmi_
 	snd_array_free(&spec->cvts);
 }
 
-static void generic_spec_free(struct hda_codec *codec)
+void snd_hda_hdmi_generic_spec_free(struct hda_codec *codec)
 {
 	struct hdmi_spec *spec = codec->spec;
 
@@ -2487,8 +2085,9 @@ static void generic_spec_free(struct hda
 	}
 	codec->dp_mst = false;
 }
+EXPORT_SYMBOL_NS_GPL(snd_hda_hdmi_generic_spec_free, SND_HDA_CODEC_HDMI);
 
-static void generic_hdmi_free(struct hda_codec *codec)
+void snd_hda_hdmi_generic_free(struct hda_codec *codec)
 {
 	struct hdmi_spec *spec = codec->spec;
 	int pin_idx, pcm_idx;
@@ -2512,10 +2111,11 @@ static void generic_hdmi_free(struct hda
 		snd_device_free(codec->card, spec->pcm_rec[pcm_idx].jack);
 	}
 
-	generic_spec_free(codec);
+	snd_hda_hdmi_generic_spec_free(codec);
 }
+EXPORT_SYMBOL_NS_GPL(snd_hda_hdmi_generic_free, SND_HDA_CODEC_HDMI);
 
-static int generic_hdmi_suspend(struct hda_codec *codec)
+int snd_hda_hdmi_generic_suspend(struct hda_codec *codec)
 {
 	struct hdmi_spec *spec = codec->spec;
 	int pin_idx;
@@ -2526,8 +2126,9 @@ static int generic_hdmi_suspend(struct h
 	}
 	return 0;
 }
+EXPORT_SYMBOL_NS_GPL(snd_hda_hdmi_generic_suspend, SND_HDA_CODEC_HDMI);
 
-static int generic_hdmi_resume(struct hda_codec *codec)
+int snd_hda_hdmi_generic_resume(struct hda_codec *codec)
 {
 	struct hdmi_spec *spec = codec->spec;
 	int pin_idx;
@@ -2541,26 +2142,27 @@ static int generic_hdmi_resume(struct hd
 	}
 	return 0;
 }
+EXPORT_SYMBOL_NS_GPL(snd_hda_hdmi_generic_resume, SND_HDA_CODEC_HDMI);
 
 static const struct hda_codec_ops generic_hdmi_patch_ops = {
-	.init			= generic_hdmi_init,
-	.free			= generic_hdmi_free,
-	.build_pcms		= generic_hdmi_build_pcms,
-	.build_controls		= generic_hdmi_build_controls,
-	.unsol_event		= hdmi_unsol_event,
-	.suspend		= generic_hdmi_suspend,
-	.resume			= generic_hdmi_resume,
+	.init			= snd_hda_hdmi_generic_init,
+	.free			= snd_hda_hdmi_generic_free,
+	.build_pcms		= snd_hda_hdmi_generic_build_pcms,
+	.build_controls		= snd_hda_hdmi_generic_build_controls,
+	.unsol_event		= snd_hda_hdmi_generic_unsol_event,
+	.suspend		= snd_hda_hdmi_generic_suspend,
+	.resume			= snd_hda_hdmi_generic_resume,
 };
 
 static const struct hdmi_ops generic_standard_hdmi_ops = {
 	.pin_get_eld				= hdmi_pin_get_eld,
 	.pin_setup_infoframe			= hdmi_pin_setup_infoframe,
 	.pin_hbr_setup				= hdmi_pin_hbr_setup,
-	.setup_stream				= hdmi_setup_stream,
+	.setup_stream				= snd_hda_hdmi_setup_stream,
 };
 
 /* allocate codec->spec and assign/initialize generic parser ops */
-static int alloc_generic_hdmi(struct hda_codec *codec)
+int snd_hda_hdmi_generic_alloc(struct hda_codec *codec)
 {
 	struct hdmi_spec *spec;
 
@@ -2587,25 +2189,27 @@ static int alloc_generic_hdmi(struct hda
 
 	return 0;
 }
+EXPORT_SYMBOL_NS_GPL(snd_hda_hdmi_generic_alloc, SND_HDA_CODEC_HDMI);
 
 /* generic HDMI parser */
-static int patch_generic_hdmi(struct hda_codec *codec)
+int patch_generic_hdmi(struct hda_codec *codec)
 {
 	int err;
 
-	err = alloc_generic_hdmi(codec);
+	err = snd_hda_hdmi_generic_alloc(codec);
 	if (err < 0)
 		return err;
 
-	err = hdmi_parse_codec(codec);
+	err = snd_hda_hdmi_parse_codec(codec);
 	if (err < 0) {
-		generic_spec_free(codec);
+		snd_hda_hdmi_generic_spec_free(codec);
 		return err;
 	}
 
-	generic_hdmi_init_per_pins(codec);
+	snd_hda_hdmi_generic_init_per_pins(codec);
 	return 0;
 }
+EXPORT_SYMBOL_NS_GPL(patch_generic_hdmi, SND_HDA_CODEC_HDMI);
 
 /*
  * generic audio component binding
@@ -2650,18 +2254,20 @@ static void generic_acomp_notifier_set(s
 }
 
 /* enable / disable the notifier via master bind / unbind */
-static int generic_acomp_master_bind(struct device *dev,
-				     struct drm_audio_component *acomp)
+int snd_hda_hdmi_acomp_master_bind(struct device *dev,
+				   struct drm_audio_component *acomp)
 {
 	generic_acomp_notifier_set(acomp, true);
 	return 0;
 }
+EXPORT_SYMBOL_NS_GPL(snd_hda_hdmi_acomp_master_bind, SND_HDA_CODEC_HDMI);
 
-static void generic_acomp_master_unbind(struct device *dev,
-					struct drm_audio_component *acomp)
+void snd_hda_hdmi_acomp_master_unbind(struct device *dev,
+				      struct drm_audio_component *acomp)
 {
 	generic_acomp_notifier_set(acomp, false);
 }
+EXPORT_SYMBOL_NS_GPL(snd_hda_hdmi_acomp_master_unbind, SND_HDA_CODEC_HDMI);
 
 /* check whether both HD-audio and DRM PCI devices belong to the same bus */
 static int match_bound_vga(struct device *dev, int subtype, void *data)
@@ -2677,7 +2283,7 @@ static int match_bound_vga(struct device
 }
 
 /* audio component notifier for AMD/Nvidia HDMI codecs */
-static void generic_acomp_pin_eld_notify(void *audio_ptr, int port, int dev_id)
+void snd_hda_hdmi_acomp_pin_eld_notify(void *audio_ptr, int port, int dev_id)
 {
 	struct hda_codec *codec = audio_ptr;
 	struct hdmi_spec *spec = codec->spec;
@@ -2693,12 +2299,13 @@ static void generic_acomp_pin_eld_notify
 	if (codec->core.dev.power.power_state.event == PM_EVENT_SUSPEND)
 		return;
 
-	check_presence_and_report(codec, pin_nid, dev_id);
+	snd_hda_hdmi_check_presence_and_report(codec, pin_nid, dev_id);
 }
+EXPORT_SYMBOL_NS_GPL(snd_hda_hdmi_acomp_pin_eld_notify, SND_HDA_CODEC_HDMI);
 
 /* set up the private drm_audio_ops from the template */
-static void setup_drm_audio_ops(struct hda_codec *codec,
-				const struct drm_audio_component_audio_ops *ops)
+void snd_hda_hdmi_setup_drm_audio_ops(struct hda_codec *codec,
+				      const struct drm_audio_component_audio_ops *ops)
 {
 	struct hdmi_spec *spec = codec->spec;
 
@@ -2713,11 +2320,12 @@ static void setup_drm_audio_ops(struct h
 	spec->drm_audio_ops.master_bind = ops->master_bind;
 	spec->drm_audio_ops.master_unbind = ops->master_unbind;
 }
+EXPORT_SYMBOL_NS_GPL(snd_hda_hdmi_setup_drm_audio_ops, SND_HDA_CODEC_HDMI);
 
 /* initialize the generic HDMI audio component */
-static void generic_acomp_init(struct hda_codec *codec,
-			       const struct drm_audio_component_audio_ops *ops,
-			       int (*port2pin)(struct hda_codec *, int))
+void snd_hda_hdmi_acomp_init(struct hda_codec *codec,
+			     const struct drm_audio_component_audio_ops *ops,
+			     int (*port2pin)(struct hda_codec *, int))
 {
 	struct hdmi_spec *spec = codec->spec;
 
@@ -2727,1766 +2335,16 @@ static void generic_acomp_init(struct hd
 	}
 
 	spec->port2pin = port2pin;
-	setup_drm_audio_ops(codec, ops);
+	snd_hda_hdmi_setup_drm_audio_ops(codec, ops);
 	if (!snd_hdac_acomp_init(&codec->bus->core, &spec->drm_audio_ops,
 				 match_bound_vga, 0)) {
 		spec->acomp_registered = true;
 	}
 }
+EXPORT_SYMBOL_NS_GPL(snd_hda_hdmi_acomp_init, SND_HDA_CODEC_HDMI);
 
 /*
- * Intel codec parsers and helpers
- */
-
-#define INTEL_GET_VENDOR_VERB	0xf81
-#define INTEL_SET_VENDOR_VERB	0x781
-#define INTEL_EN_DP12		0x02	/* enable DP 1.2 features */
-#define INTEL_EN_ALL_PIN_CVTS	0x01	/* enable 2nd & 3rd pins and convertors */
-
-static void intel_haswell_enable_all_pins(struct hda_codec *codec,
-					  bool update_tree)
-{
-	unsigned int vendor_param;
-	struct hdmi_spec *spec = codec->spec;
-
-	vendor_param = snd_hda_codec_read(codec, spec->vendor_nid, 0,
-				INTEL_GET_VENDOR_VERB, 0);
-	if (vendor_param == -1 || vendor_param & INTEL_EN_ALL_PIN_CVTS)
-		return;
-
-	vendor_param |= INTEL_EN_ALL_PIN_CVTS;
-	vendor_param = snd_hda_codec_read(codec, spec->vendor_nid, 0,
-				INTEL_SET_VENDOR_VERB, vendor_param);
-	if (vendor_param == -1)
-		return;
-
-	if (update_tree)
-		snd_hda_codec_update_widgets(codec);
-}
-
-static void intel_haswell_fixup_enable_dp12(struct hda_codec *codec)
-{
-	unsigned int vendor_param;
-	struct hdmi_spec *spec = codec->spec;
-
-	vendor_param = snd_hda_codec_read(codec, spec->vendor_nid, 0,
-				INTEL_GET_VENDOR_VERB, 0);
-	if (vendor_param == -1 || vendor_param & INTEL_EN_DP12)
-		return;
-
-	/* enable DP1.2 mode */
-	vendor_param |= INTEL_EN_DP12;
-	snd_hdac_regmap_add_vendor_verb(&codec->core, INTEL_SET_VENDOR_VERB);
-	snd_hda_codec_write_cache(codec, spec->vendor_nid, 0,
-				INTEL_SET_VENDOR_VERB, vendor_param);
-}
-
-/* Haswell needs to re-issue the vendor-specific verbs before turning to D0.
- * Otherwise you may get severe h/w communication errors.
- */
-static void haswell_set_power_state(struct hda_codec *codec, hda_nid_t fg,
-				unsigned int power_state)
-{
-	if (power_state == AC_PWRST_D0) {
-		intel_haswell_enable_all_pins(codec, false);
-		intel_haswell_fixup_enable_dp12(codec);
-	}
-
-	snd_hda_codec_read(codec, fg, 0, AC_VERB_SET_POWER_STATE, power_state);
-	snd_hda_codec_set_power_to_all(codec, fg, power_state);
-}
-
-/* There is a fixed mapping between audio pin node and display port.
- * on SNB, IVY, HSW, BSW, SKL, BXT, KBL:
- * Pin Widget 5 - PORT B (port = 1 in i915 driver)
- * Pin Widget 6 - PORT C (port = 2 in i915 driver)
- * Pin Widget 7 - PORT D (port = 3 in i915 driver)
- *
- * on VLV, ILK:
- * Pin Widget 4 - PORT B (port = 1 in i915 driver)
- * Pin Widget 5 - PORT C (port = 2 in i915 driver)
- * Pin Widget 6 - PORT D (port = 3 in i915 driver)
- */
-static int intel_base_nid(struct hda_codec *codec)
-{
-	switch (codec->core.vendor_id) {
-	case 0x80860054: /* ILK */
-	case 0x80862804: /* ILK */
-	case 0x80862882: /* VLV */
-		return 4;
-	default:
-		return 5;
-	}
-}
-
-static int intel_pin2port(void *audio_ptr, int pin_nid)
-{
-	struct hda_codec *codec = audio_ptr;
-	struct hdmi_spec *spec = codec->spec;
-	int base_nid, i;
-
-	if (!spec->port_num) {
-		base_nid = intel_base_nid(codec);
-		if (WARN_ON(pin_nid < base_nid || pin_nid >= base_nid + 3))
-			return -1;
-		return pin_nid - base_nid + 1;
-	}
-
-	/*
-	 * looking for the pin number in the mapping table and return
-	 * the index which indicate the port number
-	 */
-	for (i = 0; i < spec->port_num; i++) {
-		if (pin_nid == spec->port_map[i])
-			return i;
-	}
-
-	codec_info(codec, "Can't find the HDMI/DP port for pin NID 0x%x\n", pin_nid);
-	return -1;
-}
-
-static int intel_port2pin(struct hda_codec *codec, int port)
-{
-	struct hdmi_spec *spec = codec->spec;
-
-	if (!spec->port_num) {
-		/* we assume only from port-B to port-D */
-		if (port < 1 || port > 3)
-			return 0;
-		return port + intel_base_nid(codec) - 1;
-	}
-
-	if (port < 0 || port >= spec->port_num)
-		return 0;
-	return spec->port_map[port];
-}
-
-static void intel_pin_eld_notify(void *audio_ptr, int port, int pipe)
-{
-	struct hda_codec *codec = audio_ptr;
-	int pin_nid;
-	int dev_id = pipe;
-
-	pin_nid = intel_port2pin(codec, port);
-	if (!pin_nid)
-		return;
-	/* skip notification during system suspend (but not in runtime PM);
-	 * the state will be updated at resume
-	 */
-	if (codec->core.dev.power.power_state.event == PM_EVENT_SUSPEND)
-		return;
-
-	snd_hdac_i915_set_bclk(&codec->bus->core);
-	check_presence_and_report(codec, pin_nid, dev_id);
-}
-
-static const struct drm_audio_component_audio_ops intel_audio_ops = {
-	.pin2port = intel_pin2port,
-	.pin_eld_notify = intel_pin_eld_notify,
-};
-
-/* register i915 component pin_eld_notify callback */
-static void register_i915_notifier(struct hda_codec *codec)
-{
-	struct hdmi_spec *spec = codec->spec;
-
-	spec->use_acomp_notifier = true;
-	spec->port2pin = intel_port2pin;
-	setup_drm_audio_ops(codec, &intel_audio_ops);
-	snd_hdac_acomp_register_notifier(&codec->bus->core,
-					&spec->drm_audio_ops);
-	/* no need for forcible resume for jack check thanks to notifier */
-	codec->relaxed_resume = 1;
-}
-
-/* setup_stream ops override for HSW+ */
-static int i915_hsw_setup_stream(struct hda_codec *codec, hda_nid_t cvt_nid,
-				 hda_nid_t pin_nid, int dev_id, u32 stream_tag,
-				 int format)
-{
-	struct hdmi_spec *spec = codec->spec;
-	int pin_idx = pin_id_to_pin_index(codec, pin_nid, dev_id);
-	struct hdmi_spec_per_pin *per_pin;
-	int res;
-
-	if (pin_idx < 0)
-		per_pin = NULL;
-	else
-		per_pin = get_pin(spec, pin_idx);
-
-	haswell_verify_D0(codec, cvt_nid, pin_nid);
-
-	if (spec->silent_stream_type == SILENT_STREAM_KAE && per_pin && per_pin->silent_stream) {
-		silent_stream_set_kae(codec, per_pin, false);
-		/* wait for pending transfers in codec to clear */
-		usleep_range(100, 200);
-	}
-
-	res = hdmi_setup_stream(codec, cvt_nid, pin_nid, dev_id,
-				stream_tag, format);
-
-	if (spec->silent_stream_type == SILENT_STREAM_KAE && per_pin && per_pin->silent_stream) {
-		usleep_range(100, 200);
-		silent_stream_set_kae(codec, per_pin, true);
-	}
-
-	return res;
-}
-
-/* pin_cvt_fixup ops override for HSW+ and VLV+ */
-static void i915_pin_cvt_fixup(struct hda_codec *codec,
-			       struct hdmi_spec_per_pin *per_pin,
-			       hda_nid_t cvt_nid)
-{
-	if (per_pin) {
-		haswell_verify_D0(codec, per_pin->cvt_nid, per_pin->pin_nid);
-		snd_hda_set_dev_select(codec, per_pin->pin_nid,
-			       per_pin->dev_id);
-		intel_verify_pin_cvt_connect(codec, per_pin);
-		intel_not_share_assigned_cvt(codec, per_pin->pin_nid,
-				     per_pin->dev_id, per_pin->mux_idx);
-	} else {
-		intel_not_share_assigned_cvt_nid(codec, 0, 0, cvt_nid);
-	}
-}
-
-static int i915_adlp_hdmi_suspend(struct hda_codec *codec)
-{
-	struct hdmi_spec *spec = codec->spec;
-	bool silent_streams = false;
-	int pin_idx, res;
-
-	res = generic_hdmi_suspend(codec);
-
-	for (pin_idx = 0; pin_idx < spec->num_pins; pin_idx++) {
-		struct hdmi_spec_per_pin *per_pin = get_pin(spec, pin_idx);
-
-		if (per_pin->silent_stream) {
-			silent_streams = true;
-			break;
-		}
-	}
-
-	if (silent_streams && spec->silent_stream_type == SILENT_STREAM_KAE) {
-		/*
-		 * stream-id should remain programmed when codec goes
-		 * to runtime suspend
-		 */
-		codec->no_stream_clean_at_suspend = 1;
-
-		/*
-		 * the system might go to S3, in which case keep-alive
-		 * must be reprogrammed upon resume
-		 */
-		codec->forced_resume = 1;
-
-		codec_dbg(codec, "HDMI: KAE active at suspend\n");
-	} else {
-		codec->no_stream_clean_at_suspend = 0;
-		codec->forced_resume = 0;
-	}
-
-	return res;
-}
-
-static int i915_adlp_hdmi_resume(struct hda_codec *codec)
-{
-	struct hdmi_spec *spec = codec->spec;
-	int pin_idx, res;
-
-	res = generic_hdmi_resume(codec);
-
-	/* KAE not programmed at suspend, nothing to do here */
-	if (!codec->no_stream_clean_at_suspend)
-		return res;
-
-	for (pin_idx = 0; pin_idx < spec->num_pins; pin_idx++) {
-		struct hdmi_spec_per_pin *per_pin = get_pin(spec, pin_idx);
-
-		/*
-		 * If system was in suspend with monitor connected,
-		 * the codec setting may have been lost. Re-enable
-		 * keep-alive.
-		 */
-		if (per_pin->silent_stream) {
-			unsigned int param;
-
-			param = snd_hda_codec_read(codec, per_pin->cvt_nid, 0,
-						   AC_VERB_GET_CONV, 0);
-			if (!param) {
-				codec_dbg(codec, "HDMI: KAE: restore stream id\n");
-				silent_stream_enable_i915(codec, per_pin);
-			}
-
-			param = snd_hda_codec_read(codec, per_pin->cvt_nid, 0,
-						   AC_VERB_GET_DIGI_CONVERT_1, 0);
-			if (!(param & (AC_DIG3_KAE << 16))) {
-				codec_dbg(codec, "HDMI: KAE: restore DIG3_KAE\n");
-				silent_stream_set_kae(codec, per_pin, true);
-			}
-		}
-	}
-
-	return res;
-}
-
-/* precondition and allocation for Intel codecs */
-static int alloc_intel_hdmi(struct hda_codec *codec)
-{
-	int err;
-
-	/* requires i915 binding */
-	if (!codec->bus->core.audio_component) {
-		codec_info(codec, "No i915 binding for Intel HDMI/DP codec\n");
-		/* set probe_id here to prevent generic fallback binding */
-		codec->probe_id = HDA_CODEC_ID_SKIP_PROBE;
-		return -ENODEV;
-	}
-
-	err = alloc_generic_hdmi(codec);
-	if (err < 0)
-		return err;
-	/* no need to handle unsol events */
-	codec->patch_ops.unsol_event = NULL;
-	return 0;
-}
-
-/* parse and post-process for Intel codecs */
-static int parse_intel_hdmi(struct hda_codec *codec)
-{
-	int err, retries = 3;
-
-	do {
-		err = hdmi_parse_codec(codec);
-	} while (err < 0 && retries--);
-
-	if (err < 0) {
-		generic_spec_free(codec);
-		return err;
-	}
-
-	generic_hdmi_init_per_pins(codec);
-	register_i915_notifier(codec);
-	return 0;
-}
-
-/* Intel Haswell and onwards; audio component with eld notifier */
-static int intel_hsw_common_init(struct hda_codec *codec, hda_nid_t vendor_nid,
-				 const int *port_map, int port_num, int dev_num,
-				 bool send_silent_stream)
-{
-	struct hdmi_spec *spec;
-	int err;
-
-	err = alloc_intel_hdmi(codec);
-	if (err < 0)
-		return err;
-	spec = codec->spec;
-	codec->dp_mst = true;
-	spec->vendor_nid = vendor_nid;
-	spec->port_map = port_map;
-	spec->port_num = port_num;
-	spec->intel_hsw_fixup = true;
-	spec->dev_num = dev_num;
-
-	intel_haswell_enable_all_pins(codec, true);
-	intel_haswell_fixup_enable_dp12(codec);
-
-	codec->display_power_control = 1;
-
-	codec->patch_ops.set_power_state = haswell_set_power_state;
-	codec->depop_delay = 0;
-	codec->auto_runtime_pm = 1;
-
-	spec->ops.setup_stream = i915_hsw_setup_stream;
-	spec->ops.pin_cvt_fixup = i915_pin_cvt_fixup;
-
-	/*
-	 * Enable silent stream feature, if it is enabled via
-	 * module param or Kconfig option
-	 */
-	if (send_silent_stream)
-		spec->silent_stream_type = SILENT_STREAM_I915;
-
-	return parse_intel_hdmi(codec);
-}
-
-static int patch_i915_hsw_hdmi(struct hda_codec *codec)
-{
-	return intel_hsw_common_init(codec, 0x08, NULL, 0, 3,
-				     enable_silent_stream);
-}
-
-static int patch_i915_glk_hdmi(struct hda_codec *codec)
-{
-	/*
-	 * Silent stream calls audio component .get_power() from
-	 * .pin_eld_notify(). On GLK this will deadlock in i915 due
-	 * to the audio vs. CDCLK workaround.
-	 */
-	return intel_hsw_common_init(codec, 0x0b, NULL, 0, 3, false);
-}
-
-static int patch_i915_icl_hdmi(struct hda_codec *codec)
-{
-	/*
-	 * pin to port mapping table where the value indicate the pin number and
-	 * the index indicate the port number.
-	 */
-	static const int map[] = {0x0, 0x4, 0x6, 0x8, 0xa, 0xb};
-
-	return intel_hsw_common_init(codec, 0x02, map, ARRAY_SIZE(map), 3,
-				     enable_silent_stream);
-}
-
-static int patch_i915_tgl_hdmi(struct hda_codec *codec)
-{
-	/*
-	 * pin to port mapping table where the value indicate the pin number and
-	 * the index indicate the port number.
-	 */
-	static const int map[] = {0x4, 0x6, 0x8, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf};
-
-	return intel_hsw_common_init(codec, 0x02, map, ARRAY_SIZE(map), 4,
-				     enable_silent_stream);
-}
-
-static int patch_i915_adlp_hdmi(struct hda_codec *codec)
-{
-	struct hdmi_spec *spec;
-	int res;
-
-	res = patch_i915_tgl_hdmi(codec);
-	if (!res) {
-		spec = codec->spec;
-
-		if (spec->silent_stream_type) {
-			spec->silent_stream_type = SILENT_STREAM_KAE;
-
-			codec->patch_ops.resume = i915_adlp_hdmi_resume;
-			codec->patch_ops.suspend = i915_adlp_hdmi_suspend;
-		}
-	}
-
-	return res;
-}
-
-/* Intel Baytrail and Braswell; with eld notifier */
-static int patch_i915_byt_hdmi(struct hda_codec *codec)
-{
-	struct hdmi_spec *spec;
-	int err;
-
-	err = alloc_intel_hdmi(codec);
-	if (err < 0)
-		return err;
-	spec = codec->spec;
-
-	/* For Valleyview/Cherryview, only the display codec is in the display
-	 * power well and can use link_power ops to request/release the power.
-	 */
-	codec->display_power_control = 1;
-
-	codec->depop_delay = 0;
-	codec->auto_runtime_pm = 1;
-
-	spec->ops.pin_cvt_fixup = i915_pin_cvt_fixup;
-
-	return parse_intel_hdmi(codec);
-}
-
-/* Intel IronLake, SandyBridge and IvyBridge; with eld notifier */
-static int patch_i915_cpt_hdmi(struct hda_codec *codec)
-{
-	int err;
-
-	err = alloc_intel_hdmi(codec);
-	if (err < 0)
-		return err;
-	return parse_intel_hdmi(codec);
-}
-
-/*
- * Shared non-generic implementations
- */
-
-static int simple_playback_build_pcms(struct hda_codec *codec)
-{
-	struct hdmi_spec *spec = codec->spec;
-	struct hda_pcm *info;
-	unsigned int chans;
-	struct hda_pcm_stream *pstr;
-	struct hdmi_spec_per_cvt *per_cvt;
-
-	per_cvt = get_cvt(spec, 0);
-	chans = get_wcaps(codec, per_cvt->cvt_nid);
-	chans = get_wcaps_channels(chans);
-
-	info = snd_hda_codec_pcm_new(codec, "HDMI 0");
-	if (!info)
-		return -ENOMEM;
-	spec->pcm_rec[0].pcm = info;
-	info->pcm_type = HDA_PCM_TYPE_HDMI;
-	pstr = &info->stream[SNDRV_PCM_STREAM_PLAYBACK];
-	*pstr = spec->pcm_playback;
-	pstr->nid = per_cvt->cvt_nid;
-	if (pstr->channels_max <= 2 && chans && chans <= 16)
-		pstr->channels_max = chans;
-
-	return 0;
-}
-
-/* unsolicited event for jack sensing */
-static void simple_hdmi_unsol_event(struct hda_codec *codec,
-				    unsigned int res)
-{
-	snd_hda_jack_set_dirty_all(codec);
-	snd_hda_jack_report_sync(codec);
-}
-
-/* generic_hdmi_build_jack can be used for simple_hdmi, too,
- * as long as spec->pins[] is set correctly
- */
-#define simple_hdmi_build_jack	generic_hdmi_build_jack
-
-static int simple_playback_build_controls(struct hda_codec *codec)
-{
-	struct hdmi_spec *spec = codec->spec;
-	struct hdmi_spec_per_cvt *per_cvt;
-	int err;
-
-	per_cvt = get_cvt(spec, 0);
-	err = snd_hda_create_dig_out_ctls(codec, per_cvt->cvt_nid,
-					  per_cvt->cvt_nid,
-					  HDA_PCM_TYPE_HDMI);
-	if (err < 0)
-		return err;
-	return simple_hdmi_build_jack(codec, 0);
-}
-
-static int simple_playback_init(struct hda_codec *codec)
-{
-	struct hdmi_spec *spec = codec->spec;
-	struct hdmi_spec_per_pin *per_pin = get_pin(spec, 0);
-	hda_nid_t pin = per_pin->pin_nid;
-
-	snd_hda_codec_write(codec, pin, 0,
-			    AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT);
-	/* some codecs require to unmute the pin */
-	if (get_wcaps(codec, pin) & AC_WCAP_OUT_AMP)
-		snd_hda_codec_write(codec, pin, 0, AC_VERB_SET_AMP_GAIN_MUTE,
-				    AMP_OUT_UNMUTE);
-	snd_hda_jack_detect_enable(codec, pin, per_pin->dev_id);
-	return 0;
-}
-
-static void simple_playback_free(struct hda_codec *codec)
-{
-	struct hdmi_spec *spec = codec->spec;
-
-	hdmi_array_free(spec);
-	kfree(spec);
-}
-
-/*
- * Nvidia specific implementations
- */
-
-#define Nv_VERB_SET_Channel_Allocation          0xF79
-#define Nv_VERB_SET_Info_Frame_Checksum         0xF7A
-#define Nv_VERB_SET_Audio_Protection_On         0xF98
-#define Nv_VERB_SET_Audio_Protection_Off        0xF99
-
-#define nvhdmi_master_con_nid_7x	0x04
-#define nvhdmi_master_pin_nid_7x	0x05
-
-static const hda_nid_t nvhdmi_con_nids_7x[4] = {
-	/*front, rear, clfe, rear_surr */
-	0x6, 0x8, 0xa, 0xc,
-};
-
-static const struct hda_verb nvhdmi_basic_init_7x_2ch[] = {
-	/* set audio protect on */
-	{ 0x1, Nv_VERB_SET_Audio_Protection_On, 0x1},
-	/* enable digital output on pin widget */
-	{ 0x5, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT | 0x5 },
-	{} /* terminator */
-};
-
-static const struct hda_verb nvhdmi_basic_init_7x_8ch[] = {
-	/* set audio protect on */
-	{ 0x1, Nv_VERB_SET_Audio_Protection_On, 0x1},
-	/* enable digital output on pin widget */
-	{ 0x5, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT | 0x5 },
-	{ 0x7, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT | 0x5 },
-	{ 0x9, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT | 0x5 },
-	{ 0xb, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT | 0x5 },
-	{ 0xd, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT | 0x5 },
-	{} /* terminator */
-};
-
-#ifdef LIMITED_RATE_FMT_SUPPORT
-/* support only the safe format and rate */
-#define SUPPORTED_RATES		SNDRV_PCM_RATE_48000
-#define SUPPORTED_MAXBPS	16
-#define SUPPORTED_FORMATS	SNDRV_PCM_FMTBIT_S16_LE
-#else
-/* support all rates and formats */
-#define SUPPORTED_RATES \
-	(SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |\
-	SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 |\
-	 SNDRV_PCM_RATE_192000)
-#define SUPPORTED_MAXBPS	24
-#define SUPPORTED_FORMATS \
-	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE)
-#endif
-
-static int nvhdmi_7x_init_2ch(struct hda_codec *codec)
-{
-	snd_hda_sequence_write(codec, nvhdmi_basic_init_7x_2ch);
-	return 0;
-}
-
-static int nvhdmi_7x_init_8ch(struct hda_codec *codec)
-{
-	snd_hda_sequence_write(codec, nvhdmi_basic_init_7x_8ch);
-	return 0;
-}
-
-static const unsigned int channels_2_6_8[] = {
-	2, 6, 8
-};
-
-static const unsigned int channels_2_8[] = {
-	2, 8
-};
-
-static const struct snd_pcm_hw_constraint_list hw_constraints_2_6_8_channels = {
-	.count = ARRAY_SIZE(channels_2_6_8),
-	.list = channels_2_6_8,
-	.mask = 0,
-};
-
-static const struct snd_pcm_hw_constraint_list hw_constraints_2_8_channels = {
-	.count = ARRAY_SIZE(channels_2_8),
-	.list = channels_2_8,
-	.mask = 0,
-};
-
-static int simple_playback_pcm_open(struct hda_pcm_stream *hinfo,
-				    struct hda_codec *codec,
-				    struct snd_pcm_substream *substream)
-{
-	struct hdmi_spec *spec = codec->spec;
-	const struct snd_pcm_hw_constraint_list *hw_constraints_channels = NULL;
-
-	switch (codec->preset->vendor_id) {
-	case 0x10de0002:
-	case 0x10de0003:
-	case 0x10de0005:
-	case 0x10de0006:
-		hw_constraints_channels = &hw_constraints_2_8_channels;
-		break;
-	case 0x10de0007:
-		hw_constraints_channels = &hw_constraints_2_6_8_channels;
-		break;
-	default:
-		break;
-	}
-
-	if (hw_constraints_channels != NULL) {
-		snd_pcm_hw_constraint_list(substream->runtime, 0,
-				SNDRV_PCM_HW_PARAM_CHANNELS,
-				hw_constraints_channels);
-	} else {
-		snd_pcm_hw_constraint_step(substream->runtime, 0,
-					   SNDRV_PCM_HW_PARAM_CHANNELS, 2);
-	}
-
-	return snd_hda_multi_out_dig_open(codec, &spec->multiout);
-}
-
-static int simple_playback_pcm_close(struct hda_pcm_stream *hinfo,
-				     struct hda_codec *codec,
-				     struct snd_pcm_substream *substream)
-{
-	struct hdmi_spec *spec = codec->spec;
-	return snd_hda_multi_out_dig_close(codec, &spec->multiout);
-}
-
-static int simple_playback_pcm_prepare(struct hda_pcm_stream *hinfo,
-				       struct hda_codec *codec,
-				       unsigned int stream_tag,
-				       unsigned int format,
-				       struct snd_pcm_substream *substream)
-{
-	struct hdmi_spec *spec = codec->spec;
-	return snd_hda_multi_out_dig_prepare(codec, &spec->multiout,
-					     stream_tag, format, substream);
-}
-
-static const struct hda_pcm_stream simple_pcm_playback = {
-	.substreams = 1,
-	.channels_min = 2,
-	.channels_max = 2,
-	.ops = {
-		.open = simple_playback_pcm_open,
-		.close = simple_playback_pcm_close,
-		.prepare = simple_playback_pcm_prepare
-	},
-};
-
-static const struct hda_codec_ops simple_hdmi_patch_ops = {
-	.build_controls = simple_playback_build_controls,
-	.build_pcms = simple_playback_build_pcms,
-	.init = simple_playback_init,
-	.free = simple_playback_free,
-	.unsol_event = simple_hdmi_unsol_event,
-};
-
-static int patch_simple_hdmi(struct hda_codec *codec,
-			     hda_nid_t cvt_nid, hda_nid_t pin_nid)
-{
-	struct hdmi_spec *spec;
-	struct hdmi_spec_per_cvt *per_cvt;
-	struct hdmi_spec_per_pin *per_pin;
-
-	spec = kzalloc(sizeof(*spec), GFP_KERNEL);
-	if (!spec)
-		return -ENOMEM;
-
-	spec->codec = codec;
-	codec->spec = spec;
-	hdmi_array_init(spec, 1);
-
-	spec->multiout.num_dacs = 0;  /* no analog */
-	spec->multiout.max_channels = 2;
-	spec->multiout.dig_out_nid = cvt_nid;
-	spec->num_cvts = 1;
-	spec->num_pins = 1;
-	per_pin = snd_array_new(&spec->pins);
-	per_cvt = snd_array_new(&spec->cvts);
-	if (!per_pin || !per_cvt) {
-		simple_playback_free(codec);
-		return -ENOMEM;
-	}
-	per_cvt->cvt_nid = cvt_nid;
-	per_pin->pin_nid = pin_nid;
-	spec->pcm_playback = simple_pcm_playback;
-
-	codec->patch_ops = simple_hdmi_patch_ops;
-
-	return 0;
-}
-
-static void nvhdmi_8ch_7x_set_info_frame_parameters(struct hda_codec *codec,
-						    int channels)
-{
-	unsigned int chanmask;
-	int chan = channels ? (channels - 1) : 1;
-
-	switch (channels) {
-	default:
-	case 0:
-	case 2:
-		chanmask = 0x00;
-		break;
-	case 4:
-		chanmask = 0x08;
-		break;
-	case 6:
-		chanmask = 0x0b;
-		break;
-	case 8:
-		chanmask = 0x13;
-		break;
-	}
-
-	/* Set the audio infoframe channel allocation and checksum fields.  The
-	 * channel count is computed implicitly by the hardware. */
-	snd_hda_codec_write(codec, 0x1, 0,
-			Nv_VERB_SET_Channel_Allocation, chanmask);
-
-	snd_hda_codec_write(codec, 0x1, 0,
-			Nv_VERB_SET_Info_Frame_Checksum,
-			(0x71 - chan - chanmask));
-}
-
-static int nvhdmi_8ch_7x_pcm_close(struct hda_pcm_stream *hinfo,
-				   struct hda_codec *codec,
-				   struct snd_pcm_substream *substream)
-{
-	struct hdmi_spec *spec = codec->spec;
-	int i;
-
-	snd_hda_codec_write(codec, nvhdmi_master_con_nid_7x,
-			0, AC_VERB_SET_CHANNEL_STREAMID, 0);
-	for (i = 0; i < 4; i++) {
-		/* set the stream id */
-		snd_hda_codec_write(codec, nvhdmi_con_nids_7x[i], 0,
-				AC_VERB_SET_CHANNEL_STREAMID, 0);
-		/* set the stream format */
-		snd_hda_codec_write(codec, nvhdmi_con_nids_7x[i], 0,
-				AC_VERB_SET_STREAM_FORMAT, 0);
-	}
-
-	/* The audio hardware sends a channel count of 0x7 (8ch) when all the
-	 * streams are disabled. */
-	nvhdmi_8ch_7x_set_info_frame_parameters(codec, 8);
-
-	return snd_hda_multi_out_dig_close(codec, &spec->multiout);
-}
-
-static int nvhdmi_8ch_7x_pcm_prepare(struct hda_pcm_stream *hinfo,
-				     struct hda_codec *codec,
-				     unsigned int stream_tag,
-				     unsigned int format,
-				     struct snd_pcm_substream *substream)
-{
-	int chs;
-	unsigned int dataDCC2, channel_id;
-	int i;
-	struct hdmi_spec *spec = codec->spec;
-	struct hda_spdif_out *spdif;
-	struct hdmi_spec_per_cvt *per_cvt;
-
-	mutex_lock(&codec->spdif_mutex);
-	per_cvt = get_cvt(spec, 0);
-	spdif = snd_hda_spdif_out_of_nid(codec, per_cvt->cvt_nid);
-
-	chs = substream->runtime->channels;
-
-	dataDCC2 = 0x2;
-
-	/* turn off SPDIF once; otherwise the IEC958 bits won't be updated */
-	if (codec->spdif_status_reset && (spdif->ctls & AC_DIG1_ENABLE))
-		snd_hda_codec_write(codec,
-				nvhdmi_master_con_nid_7x,
-				0,
-				AC_VERB_SET_DIGI_CONVERT_1,
-				spdif->ctls & ~AC_DIG1_ENABLE & 0xff);
-
-	/* set the stream id */
-	snd_hda_codec_write(codec, nvhdmi_master_con_nid_7x, 0,
-			AC_VERB_SET_CHANNEL_STREAMID, (stream_tag << 4) | 0x0);
-
-	/* set the stream format */
-	snd_hda_codec_write(codec, nvhdmi_master_con_nid_7x, 0,
-			AC_VERB_SET_STREAM_FORMAT, format);
-
-	/* turn on again (if needed) */
-	/* enable and set the channel status audio/data flag */
-	if (codec->spdif_status_reset && (spdif->ctls & AC_DIG1_ENABLE)) {
-		snd_hda_codec_write(codec,
-				nvhdmi_master_con_nid_7x,
-				0,
-				AC_VERB_SET_DIGI_CONVERT_1,
-				spdif->ctls & 0xff);
-		snd_hda_codec_write(codec,
-				nvhdmi_master_con_nid_7x,
-				0,
-				AC_VERB_SET_DIGI_CONVERT_2, dataDCC2);
-	}
-
-	for (i = 0; i < 4; i++) {
-		if (chs == 2)
-			channel_id = 0;
-		else
-			channel_id = i * 2;
-
-		/* turn off SPDIF once;
-		 *otherwise the IEC958 bits won't be updated
-		 */
-		if (codec->spdif_status_reset &&
-		(spdif->ctls & AC_DIG1_ENABLE))
-			snd_hda_codec_write(codec,
-				nvhdmi_con_nids_7x[i],
-				0,
-				AC_VERB_SET_DIGI_CONVERT_1,
-				spdif->ctls & ~AC_DIG1_ENABLE & 0xff);
-		/* set the stream id */
-		snd_hda_codec_write(codec,
-				nvhdmi_con_nids_7x[i],
-				0,
-				AC_VERB_SET_CHANNEL_STREAMID,
-				(stream_tag << 4) | channel_id);
-		/* set the stream format */
-		snd_hda_codec_write(codec,
-				nvhdmi_con_nids_7x[i],
-				0,
-				AC_VERB_SET_STREAM_FORMAT,
-				format);
-		/* turn on again (if needed) */
-		/* enable and set the channel status audio/data flag */
-		if (codec->spdif_status_reset &&
-		(spdif->ctls & AC_DIG1_ENABLE)) {
-			snd_hda_codec_write(codec,
-					nvhdmi_con_nids_7x[i],
-					0,
-					AC_VERB_SET_DIGI_CONVERT_1,
-					spdif->ctls & 0xff);
-			snd_hda_codec_write(codec,
-					nvhdmi_con_nids_7x[i],
-					0,
-					AC_VERB_SET_DIGI_CONVERT_2, dataDCC2);
-		}
-	}
-
-	nvhdmi_8ch_7x_set_info_frame_parameters(codec, chs);
-
-	mutex_unlock(&codec->spdif_mutex);
-	return 0;
-}
-
-static const struct hda_pcm_stream nvhdmi_pcm_playback_8ch_7x = {
-	.substreams = 1,
-	.channels_min = 2,
-	.channels_max = 8,
-	.nid = nvhdmi_master_con_nid_7x,
-	.rates = SUPPORTED_RATES,
-	.maxbps = SUPPORTED_MAXBPS,
-	.formats = SUPPORTED_FORMATS,
-	.ops = {
-		.open = simple_playback_pcm_open,
-		.close = nvhdmi_8ch_7x_pcm_close,
-		.prepare = nvhdmi_8ch_7x_pcm_prepare
-	},
-};
-
-static int patch_nvhdmi_2ch(struct hda_codec *codec)
-{
-	struct hdmi_spec *spec;
-	int err = patch_simple_hdmi(codec, nvhdmi_master_con_nid_7x,
-				    nvhdmi_master_pin_nid_7x);
-	if (err < 0)
-		return err;
-
-	codec->patch_ops.init = nvhdmi_7x_init_2ch;
-	/* override the PCM rates, etc, as the codec doesn't give full list */
-	spec = codec->spec;
-	spec->pcm_playback.rates = SUPPORTED_RATES;
-	spec->pcm_playback.maxbps = SUPPORTED_MAXBPS;
-	spec->pcm_playback.formats = SUPPORTED_FORMATS;
-	spec->nv_dp_workaround = true;
-	return 0;
-}
-
-static int nvhdmi_7x_8ch_build_pcms(struct hda_codec *codec)
-{
-	struct hdmi_spec *spec = codec->spec;
-	int err = simple_playback_build_pcms(codec);
-	if (!err) {
-		struct hda_pcm *info = get_pcm_rec(spec, 0);
-		info->own_chmap = true;
-	}
-	return err;
-}
-
-static int nvhdmi_7x_8ch_build_controls(struct hda_codec *codec)
-{
-	struct hdmi_spec *spec = codec->spec;
-	struct hda_pcm *info;
-	struct snd_pcm_chmap *chmap;
-	int err;
-
-	err = simple_playback_build_controls(codec);
-	if (err < 0)
-		return err;
-
-	/* add channel maps */
-	info = get_pcm_rec(spec, 0);
-	err = snd_pcm_add_chmap_ctls(info->pcm,
-				     SNDRV_PCM_STREAM_PLAYBACK,
-				     snd_pcm_alt_chmaps, 8, 0, &chmap);
-	if (err < 0)
-		return err;
-	switch (codec->preset->vendor_id) {
-	case 0x10de0002:
-	case 0x10de0003:
-	case 0x10de0005:
-	case 0x10de0006:
-		chmap->channel_mask = (1U << 2) | (1U << 8);
-		break;
-	case 0x10de0007:
-		chmap->channel_mask = (1U << 2) | (1U << 6) | (1U << 8);
-	}
-	return 0;
-}
-
-static int patch_nvhdmi_8ch_7x(struct hda_codec *codec)
-{
-	struct hdmi_spec *spec;
-	int err = patch_nvhdmi_2ch(codec);
-	if (err < 0)
-		return err;
-	spec = codec->spec;
-	spec->multiout.max_channels = 8;
-	spec->pcm_playback = nvhdmi_pcm_playback_8ch_7x;
-	codec->patch_ops.init = nvhdmi_7x_init_8ch;
-	codec->patch_ops.build_pcms = nvhdmi_7x_8ch_build_pcms;
-	codec->patch_ops.build_controls = nvhdmi_7x_8ch_build_controls;
-
-	/* Initialize the audio infoframe channel mask and checksum to something
-	 * valid */
-	nvhdmi_8ch_7x_set_info_frame_parameters(codec, 8);
-
-	return 0;
-}
-
-/*
- * NVIDIA codecs ignore ASP mapping for 2ch - confirmed on:
- * - 0x10de0015
- * - 0x10de0040
  */
-static int nvhdmi_chmap_cea_alloc_validate_get_type(struct hdac_chmap *chmap,
-		struct hdac_cea_channel_speaker_allocation *cap, int channels)
-{
-	if (cap->ca_index == 0x00 && channels == 2)
-		return SNDRV_CTL_TLVT_CHMAP_FIXED;
-
-	/* If the speaker allocation matches the channel count, it is OK. */
-	if (cap->channels != channels)
-		return -1;
-
-	/* all channels are remappable freely */
-	return SNDRV_CTL_TLVT_CHMAP_VAR;
-}
-
-static int nvhdmi_chmap_validate(struct hdac_chmap *chmap,
-		int ca, int chs, unsigned char *map)
-{
-	if (ca == 0x00 && (map[0] != SNDRV_CHMAP_FL || map[1] != SNDRV_CHMAP_FR))
-		return -EINVAL;
-
-	return 0;
-}
-
-/* map from pin NID to port; port is 0-based */
-/* for Nvidia: assume widget NID starting from 4, with step 1 (4, 5, 6, ...) */
-static int nvhdmi_pin2port(void *audio_ptr, int pin_nid)
-{
-	return pin_nid - 4;
-}
-
-/* reverse-map from port to pin NID: see above */
-static int nvhdmi_port2pin(struct hda_codec *codec, int port)
-{
-	return port + 4;
-}
-
-static const struct drm_audio_component_audio_ops nvhdmi_audio_ops = {
-	.pin2port = nvhdmi_pin2port,
-	.pin_eld_notify = generic_acomp_pin_eld_notify,
-	.master_bind = generic_acomp_master_bind,
-	.master_unbind = generic_acomp_master_unbind,
-};
-
-static int patch_nvhdmi(struct hda_codec *codec)
-{
-	struct hdmi_spec *spec;
-	int err;
-
-	err = alloc_generic_hdmi(codec);
-	if (err < 0)
-		return err;
-	codec->dp_mst = true;
-
-	spec = codec->spec;
-
-	err = hdmi_parse_codec(codec);
-	if (err < 0) {
-		generic_spec_free(codec);
-		return err;
-	}
-
-	generic_hdmi_init_per_pins(codec);
-
-	spec->dyn_pin_out = true;
-
-	spec->chmap.ops.chmap_cea_alloc_validate_get_type =
-		nvhdmi_chmap_cea_alloc_validate_get_type;
-	spec->chmap.ops.chmap_validate = nvhdmi_chmap_validate;
-	spec->nv_dp_workaround = true;
-
-	codec->link_down_at_suspend = 1;
-
-	generic_acomp_init(codec, &nvhdmi_audio_ops, nvhdmi_port2pin);
-
-	return 0;
-}
-
-static int patch_nvhdmi_legacy(struct hda_codec *codec)
-{
-	struct hdmi_spec *spec;
-	int err;
-
-	err = patch_generic_hdmi(codec);
-	if (err)
-		return err;
-
-	spec = codec->spec;
-	spec->dyn_pin_out = true;
-
-	spec->chmap.ops.chmap_cea_alloc_validate_get_type =
-		nvhdmi_chmap_cea_alloc_validate_get_type;
-	spec->chmap.ops.chmap_validate = nvhdmi_chmap_validate;
-	spec->nv_dp_workaround = true;
-
-	codec->link_down_at_suspend = 1;
-
-	return 0;
-}
-
-/*
- * The HDA codec on NVIDIA Tegra contains two scratch registers that are
- * accessed using vendor-defined verbs. These registers can be used for
- * interoperability between the HDA and HDMI drivers.
- */
-
-/* Audio Function Group node */
-#define NVIDIA_AFG_NID 0x01
-
-/*
- * The SCRATCH0 register is used to notify the HDMI codec of changes in audio
- * format. On Tegra, bit 31 is used as a trigger that causes an interrupt to
- * be raised in the HDMI codec. The remainder of the bits is arbitrary. This
- * implementation stores the HDA format (see AC_FMT_*) in bits [15:0] and an
- * additional bit (at position 30) to signal the validity of the format.
- *
- * | 31      | 30    | 29  16 | 15   0 |
- * +---------+-------+--------+--------+
- * | TRIGGER | VALID | UNUSED | FORMAT |
- * +-----------------------------------|
- *
- * Note that for the trigger bit to take effect it needs to change value
- * (i.e. it needs to be toggled). The trigger bit is not applicable from
- * TEGRA234 chip onwards, as new verb id 0xf80 will be used for interrupt
- * trigger to hdmi.
- */
-#define NVIDIA_SET_HOST_INTR		0xf80
-#define NVIDIA_GET_SCRATCH0		0xfa6
-#define NVIDIA_SET_SCRATCH0_BYTE0	0xfa7
-#define NVIDIA_SET_SCRATCH0_BYTE1	0xfa8
-#define NVIDIA_SET_SCRATCH0_BYTE2	0xfa9
-#define NVIDIA_SET_SCRATCH0_BYTE3	0xfaa
-#define NVIDIA_SCRATCH_TRIGGER (1 << 7)
-#define NVIDIA_SCRATCH_VALID   (1 << 6)
-
-#define NVIDIA_GET_SCRATCH1		0xfab
-#define NVIDIA_SET_SCRATCH1_BYTE0	0xfac
-#define NVIDIA_SET_SCRATCH1_BYTE1	0xfad
-#define NVIDIA_SET_SCRATCH1_BYTE2	0xfae
-#define NVIDIA_SET_SCRATCH1_BYTE3	0xfaf
-
-/*
- * The format parameter is the HDA audio format (see AC_FMT_*). If set to 0,
- * the format is invalidated so that the HDMI codec can be disabled.
- */
-static void tegra_hdmi_set_format(struct hda_codec *codec,
-				  hda_nid_t cvt_nid,
-				  unsigned int format)
-{
-	unsigned int value;
-	unsigned int nid = NVIDIA_AFG_NID;
-	struct hdmi_spec *spec = codec->spec;
-
-	/*
-	 * Tegra HDA codec design from TEGRA234 chip onwards support DP MST.
-	 * This resulted in moving scratch registers from audio function
-	 * group to converter widget context. So CVT NID should be used for
-	 * scratch register read/write for DP MST supported Tegra HDA codec.
-	 */
-	if (codec->dp_mst)
-		nid = cvt_nid;
-
-	/* bits [31:30] contain the trigger and valid bits */
-	value = snd_hda_codec_read(codec, nid, 0,
-				   NVIDIA_GET_SCRATCH0, 0);
-	value = (value >> 24) & 0xff;
-
-	/* bits [15:0] are used to store the HDA format */
-	snd_hda_codec_write(codec, nid, 0,
-			    NVIDIA_SET_SCRATCH0_BYTE0,
-			    (format >> 0) & 0xff);
-	snd_hda_codec_write(codec, nid, 0,
-			    NVIDIA_SET_SCRATCH0_BYTE1,
-			    (format >> 8) & 0xff);
-
-	/* bits [16:24] are unused */
-	snd_hda_codec_write(codec, nid, 0,
-			    NVIDIA_SET_SCRATCH0_BYTE2, 0);
-
-	/*
-	 * Bit 30 signals that the data is valid and hence that HDMI audio can
-	 * be enabled.
-	 */
-	if (format == 0)
-		value &= ~NVIDIA_SCRATCH_VALID;
-	else
-		value |= NVIDIA_SCRATCH_VALID;
-
-	if (spec->hdmi_intr_trig_ctrl) {
-		/*
-		 * For Tegra HDA Codec design from TEGRA234 onwards, the
-		 * Interrupt to hdmi driver is triggered by writing
-		 * non-zero values to verb 0xF80 instead of 31st bit of
-		 * scratch register.
-		 */
-		snd_hda_codec_write(codec, nid, 0,
-				NVIDIA_SET_SCRATCH0_BYTE3, value);
-		snd_hda_codec_write(codec, nid, 0,
-				NVIDIA_SET_HOST_INTR, 0x1);
-	} else {
-		/*
-		 * Whenever the 31st trigger bit is toggled, an interrupt is raised
-		 * in the HDMI codec. The HDMI driver will use that as trigger
-		 * to update its configuration.
-		 */
-		value ^= NVIDIA_SCRATCH_TRIGGER;
-
-		snd_hda_codec_write(codec, nid, 0,
-				NVIDIA_SET_SCRATCH0_BYTE3, value);
-	}
-}
-
-static int tegra_hdmi_pcm_prepare(struct hda_pcm_stream *hinfo,
-				  struct hda_codec *codec,
-				  unsigned int stream_tag,
-				  unsigned int format,
-				  struct snd_pcm_substream *substream)
-{
-	int err;
-
-	err = generic_hdmi_playback_pcm_prepare(hinfo, codec, stream_tag,
-						format, substream);
-	if (err < 0)
-		return err;
-
-	/* notify the HDMI codec of the format change */
-	tegra_hdmi_set_format(codec, hinfo->nid, format);
-
-	return 0;
-}
-
-static int tegra_hdmi_pcm_cleanup(struct hda_pcm_stream *hinfo,
-				  struct hda_codec *codec,
-				  struct snd_pcm_substream *substream)
-{
-	/* invalidate the format in the HDMI codec */
-	tegra_hdmi_set_format(codec, hinfo->nid, 0);
-
-	return generic_hdmi_playback_pcm_cleanup(hinfo, codec, substream);
-}
-
-static struct hda_pcm *hda_find_pcm_by_type(struct hda_codec *codec, int type)
-{
-	struct hdmi_spec *spec = codec->spec;
-	unsigned int i;
-
-	for (i = 0; i < spec->num_pins; i++) {
-		struct hda_pcm *pcm = get_pcm_rec(spec, i);
-
-		if (pcm->pcm_type == type)
-			return pcm;
-	}
-
-	return NULL;
-}
-
-static int tegra_hdmi_build_pcms(struct hda_codec *codec)
-{
-	struct hda_pcm_stream *stream;
-	struct hda_pcm *pcm;
-	int err;
-
-	err = generic_hdmi_build_pcms(codec);
-	if (err < 0)
-		return err;
-
-	pcm = hda_find_pcm_by_type(codec, HDA_PCM_TYPE_HDMI);
-	if (!pcm)
-		return -ENODEV;
-
-	/*
-	 * Override ->prepare() and ->cleanup() operations to notify the HDMI
-	 * codec about format changes.
-	 */
-	stream = &pcm->stream[SNDRV_PCM_STREAM_PLAYBACK];
-	stream->ops.prepare = tegra_hdmi_pcm_prepare;
-	stream->ops.cleanup = tegra_hdmi_pcm_cleanup;
-
-	return 0;
-}
-
-static int tegra_hdmi_init(struct hda_codec *codec)
-{
-	struct hdmi_spec *spec = codec->spec;
-	int i, err;
-
-	err = hdmi_parse_codec(codec);
-	if (err < 0) {
-		generic_spec_free(codec);
-		return err;
-	}
-
-	for (i = 0; i < spec->num_cvts; i++)
-		snd_hda_codec_write(codec, spec->cvt_nids[i], 0,
-					AC_VERB_SET_DIGI_CONVERT_1,
-					AC_DIG1_ENABLE);
-
-	generic_hdmi_init_per_pins(codec);
-
-	codec->depop_delay = 10;
-	codec->patch_ops.build_pcms = tegra_hdmi_build_pcms;
-	spec->chmap.ops.chmap_cea_alloc_validate_get_type =
-		nvhdmi_chmap_cea_alloc_validate_get_type;
-	spec->chmap.ops.chmap_validate = nvhdmi_chmap_validate;
-
-	spec->chmap.ops.chmap_cea_alloc_validate_get_type =
-		nvhdmi_chmap_cea_alloc_validate_get_type;
-	spec->chmap.ops.chmap_validate = nvhdmi_chmap_validate;
-	spec->nv_dp_workaround = true;
-
-	return 0;
-}
-
-static int patch_tegra_hdmi(struct hda_codec *codec)
-{
-	int err;
-
-	err = alloc_generic_hdmi(codec);
-	if (err < 0)
-		return err;
-
-	return tegra_hdmi_init(codec);
-}
-
-static int patch_tegra234_hdmi(struct hda_codec *codec)
-{
-	struct hdmi_spec *spec;
-	int err;
-
-	err = alloc_generic_hdmi(codec);
-	if (err < 0)
-		return err;
-
-	codec->dp_mst = true;
-	spec = codec->spec;
-	spec->dyn_pin_out = true;
-	spec->hdmi_intr_trig_ctrl = true;
-
-	return tegra_hdmi_init(codec);
-}
-
-/*
- * ATI/AMD-specific implementations
- */
-
-#define is_amdhdmi_rev3_or_later(codec) \
-	((codec)->core.vendor_id == 0x1002aa01 && \
-	 ((codec)->core.revision_id & 0xff00) >= 0x0300)
-#define has_amd_full_remap_support(codec) is_amdhdmi_rev3_or_later(codec)
-
-/* ATI/AMD specific HDA pin verbs, see the AMD HDA Verbs specification */
-#define ATI_VERB_SET_CHANNEL_ALLOCATION	0x771
-#define ATI_VERB_SET_DOWNMIX_INFO	0x772
-#define ATI_VERB_SET_MULTICHANNEL_01	0x777
-#define ATI_VERB_SET_MULTICHANNEL_23	0x778
-#define ATI_VERB_SET_MULTICHANNEL_45	0x779
-#define ATI_VERB_SET_MULTICHANNEL_67	0x77a
-#define ATI_VERB_SET_HBR_CONTROL	0x77c
-#define ATI_VERB_SET_MULTICHANNEL_1	0x785
-#define ATI_VERB_SET_MULTICHANNEL_3	0x786
-#define ATI_VERB_SET_MULTICHANNEL_5	0x787
-#define ATI_VERB_SET_MULTICHANNEL_7	0x788
-#define ATI_VERB_SET_MULTICHANNEL_MODE	0x789
-#define ATI_VERB_GET_CHANNEL_ALLOCATION	0xf71
-#define ATI_VERB_GET_DOWNMIX_INFO	0xf72
-#define ATI_VERB_GET_MULTICHANNEL_01	0xf77
-#define ATI_VERB_GET_MULTICHANNEL_23	0xf78
-#define ATI_VERB_GET_MULTICHANNEL_45	0xf79
-#define ATI_VERB_GET_MULTICHANNEL_67	0xf7a
-#define ATI_VERB_GET_HBR_CONTROL	0xf7c
-#define ATI_VERB_GET_MULTICHANNEL_1	0xf85
-#define ATI_VERB_GET_MULTICHANNEL_3	0xf86
-#define ATI_VERB_GET_MULTICHANNEL_5	0xf87
-#define ATI_VERB_GET_MULTICHANNEL_7	0xf88
-#define ATI_VERB_GET_MULTICHANNEL_MODE	0xf89
-
-/* AMD specific HDA cvt verbs */
-#define ATI_VERB_SET_RAMP_RATE		0x770
-#define ATI_VERB_GET_RAMP_RATE		0xf70
-
-#define ATI_OUT_ENABLE 0x1
-
-#define ATI_MULTICHANNEL_MODE_PAIRED	0
-#define ATI_MULTICHANNEL_MODE_SINGLE	1
-
-#define ATI_HBR_CAPABLE 0x01
-#define ATI_HBR_ENABLE 0x10
-
-static int atihdmi_pin_get_eld(struct hda_codec *codec, hda_nid_t nid,
-			       int dev_id, unsigned char *buf, int *eld_size)
-{
-	WARN_ON(dev_id != 0);
-	/* call hda_eld.c ATI/AMD-specific function */
-	return snd_hdmi_get_eld_ati(codec, nid, buf, eld_size,
-				    is_amdhdmi_rev3_or_later(codec));
-}
-
-static void atihdmi_pin_setup_infoframe(struct hda_codec *codec,
-					hda_nid_t pin_nid, int dev_id, int ca,
-					int active_channels, int conn_type)
-{
-	WARN_ON(dev_id != 0);
-	snd_hda_codec_write(codec, pin_nid, 0, ATI_VERB_SET_CHANNEL_ALLOCATION, ca);
-}
-
-static int atihdmi_paired_swap_fc_lfe(int pos)
-{
-	/*
-	 * ATI/AMD have automatic FC/LFE swap built-in
-	 * when in pairwise mapping mode.
-	 */
-
-	switch (pos) {
-		/* see channel_allocations[].speakers[] */
-		case 2: return 3;
-		case 3: return 2;
-		default: break;
-	}
-
-	return pos;
-}
-
-static int atihdmi_paired_chmap_validate(struct hdac_chmap *chmap,
-			int ca, int chs, unsigned char *map)
-{
-	struct hdac_cea_channel_speaker_allocation *cap;
-	int i, j;
-
-	/* check that only channel pairs need to be remapped on old pre-rev3 ATI/AMD */
-
-	cap = snd_hdac_get_ch_alloc_from_ca(ca);
-	for (i = 0; i < chs; ++i) {
-		int mask = snd_hdac_chmap_to_spk_mask(map[i]);
-		bool ok = false;
-		bool companion_ok = false;
-
-		if (!mask)
-			continue;
-
-		for (j = 0 + i % 2; j < 8; j += 2) {
-			int chan_idx = 7 - atihdmi_paired_swap_fc_lfe(j);
-			if (cap->speakers[chan_idx] == mask) {
-				/* channel is in a supported position */
-				ok = true;
-
-				if (i % 2 == 0 && i + 1 < chs) {
-					/* even channel, check the odd companion */
-					int comp_chan_idx = 7 - atihdmi_paired_swap_fc_lfe(j + 1);
-					int comp_mask_req = snd_hdac_chmap_to_spk_mask(map[i+1]);
-					int comp_mask_act = cap->speakers[comp_chan_idx];
-
-					if (comp_mask_req == comp_mask_act)
-						companion_ok = true;
-					else
-						return -EINVAL;
-				}
-				break;
-			}
-		}
-
-		if (!ok)
-			return -EINVAL;
-
-		if (companion_ok)
-			i++; /* companion channel already checked */
-	}
-
-	return 0;
-}
-
-static int atihdmi_pin_set_slot_channel(struct hdac_device *hdac,
-		hda_nid_t pin_nid, int hdmi_slot, int stream_channel)
-{
-	struct hda_codec *codec = hdac_to_hda_codec(hdac);
-	int verb;
-	int ati_channel_setup = 0;
-
-	if (hdmi_slot > 7)
-		return -EINVAL;
-
-	if (!has_amd_full_remap_support(codec)) {
-		hdmi_slot = atihdmi_paired_swap_fc_lfe(hdmi_slot);
-
-		/* In case this is an odd slot but without stream channel, do not
-		 * disable the slot since the corresponding even slot could have a
-		 * channel. In case neither have a channel, the slot pair will be
-		 * disabled when this function is called for the even slot. */
-		if (hdmi_slot % 2 != 0 && stream_channel == 0xf)
-			return 0;
-
-		hdmi_slot -= hdmi_slot % 2;
-
-		if (stream_channel != 0xf)
-			stream_channel -= stream_channel % 2;
-	}
-
-	verb = ATI_VERB_SET_MULTICHANNEL_01 + hdmi_slot/2 + (hdmi_slot % 2) * 0x00e;
-
-	/* ati_channel_setup format: [7..4] = stream_channel_id, [1] = mute, [0] = enable */
-
-	if (stream_channel != 0xf)
-		ati_channel_setup = (stream_channel << 4) | ATI_OUT_ENABLE;
-
-	return snd_hda_codec_write(codec, pin_nid, 0, verb, ati_channel_setup);
-}
-
-static int atihdmi_pin_get_slot_channel(struct hdac_device *hdac,
-				hda_nid_t pin_nid, int asp_slot)
-{
-	struct hda_codec *codec = hdac_to_hda_codec(hdac);
-	bool was_odd = false;
-	int ati_asp_slot = asp_slot;
-	int verb;
-	int ati_channel_setup;
-
-	if (asp_slot > 7)
-		return -EINVAL;
-
-	if (!has_amd_full_remap_support(codec)) {
-		ati_asp_slot = atihdmi_paired_swap_fc_lfe(asp_slot);
-		if (ati_asp_slot % 2 != 0) {
-			ati_asp_slot -= 1;
-			was_odd = true;
-		}
-	}
-
-	verb = ATI_VERB_GET_MULTICHANNEL_01 + ati_asp_slot/2 + (ati_asp_slot % 2) * 0x00e;
-
-	ati_channel_setup = snd_hda_codec_read(codec, pin_nid, 0, verb, 0);
-
-	if (!(ati_channel_setup & ATI_OUT_ENABLE))
-		return 0xf;
-
-	return ((ati_channel_setup & 0xf0) >> 4) + !!was_odd;
-}
-
-static int atihdmi_paired_chmap_cea_alloc_validate_get_type(
-		struct hdac_chmap *chmap,
-		struct hdac_cea_channel_speaker_allocation *cap,
-		int channels)
-{
-	int c;
-
-	/*
-	 * Pre-rev3 ATI/AMD codecs operate in a paired channel mode, so
-	 * we need to take that into account (a single channel may take 2
-	 * channel slots if we need to carry a silent channel next to it).
-	 * On Rev3+ AMD codecs this function is not used.
-	 */
-	int chanpairs = 0;
-
-	/* We only produce even-numbered channel count TLVs */
-	if ((channels % 2) != 0)
-		return -1;
-
-	for (c = 0; c < 7; c += 2) {
-		if (cap->speakers[c] || cap->speakers[c+1])
-			chanpairs++;
-	}
-
-	if (chanpairs * 2 != channels)
-		return -1;
-
-	return SNDRV_CTL_TLVT_CHMAP_PAIRED;
-}
-
-static void atihdmi_paired_cea_alloc_to_tlv_chmap(struct hdac_chmap *hchmap,
-		struct hdac_cea_channel_speaker_allocation *cap,
-		unsigned int *chmap, int channels)
-{
-	/* produce paired maps for pre-rev3 ATI/AMD codecs */
-	int count = 0;
-	int c;
-
-	for (c = 7; c >= 0; c--) {
-		int chan = 7 - atihdmi_paired_swap_fc_lfe(7 - c);
-		int spk = cap->speakers[chan];
-		if (!spk) {
-			/* add N/A channel if the companion channel is occupied */
-			if (cap->speakers[chan + (chan % 2 ? -1 : 1)])
-				chmap[count++] = SNDRV_CHMAP_NA;
-
-			continue;
-		}
-
-		chmap[count++] = snd_hdac_spk_to_chmap(spk);
-	}
-
-	WARN_ON(count != channels);
-}
-
-static int atihdmi_pin_hbr_setup(struct hda_codec *codec, hda_nid_t pin_nid,
-				 int dev_id, bool hbr)
-{
-	int hbr_ctl, hbr_ctl_new;
-
-	WARN_ON(dev_id != 0);
-
-	hbr_ctl = snd_hda_codec_read(codec, pin_nid, 0, ATI_VERB_GET_HBR_CONTROL, 0);
-	if (hbr_ctl >= 0 && (hbr_ctl & ATI_HBR_CAPABLE)) {
-		if (hbr)
-			hbr_ctl_new = hbr_ctl | ATI_HBR_ENABLE;
-		else
-			hbr_ctl_new = hbr_ctl & ~ATI_HBR_ENABLE;
-
-		codec_dbg(codec,
-			  "atihdmi_pin_hbr_setup: NID=0x%x, %shbr-ctl=0x%x\n",
-				pin_nid,
-				hbr_ctl == hbr_ctl_new ? "" : "new-",
-				hbr_ctl_new);
-
-		if (hbr_ctl != hbr_ctl_new)
-			snd_hda_codec_write(codec, pin_nid, 0,
-						ATI_VERB_SET_HBR_CONTROL,
-						hbr_ctl_new);
-
-	} else if (hbr)
-		return -EINVAL;
-
-	return 0;
-}
-
-static int atihdmi_setup_stream(struct hda_codec *codec, hda_nid_t cvt_nid,
-				hda_nid_t pin_nid, int dev_id,
-				u32 stream_tag, int format)
-{
-	if (is_amdhdmi_rev3_or_later(codec)) {
-		int ramp_rate = 180; /* default as per AMD spec */
-		/* disable ramp-up/down for non-pcm as per AMD spec */
-		if (format & AC_FMT_TYPE_NON_PCM)
-			ramp_rate = 0;
-
-		snd_hda_codec_write(codec, cvt_nid, 0, ATI_VERB_SET_RAMP_RATE, ramp_rate);
-	}
-
-	return hdmi_setup_stream(codec, cvt_nid, pin_nid, dev_id,
-				 stream_tag, format);
-}
-
-
-static int atihdmi_init(struct hda_codec *codec)
-{
-	struct hdmi_spec *spec = codec->spec;
-	int pin_idx, err;
-
-	err = generic_hdmi_init(codec);
-
-	if (err)
-		return err;
-
-	for (pin_idx = 0; pin_idx < spec->num_pins; pin_idx++) {
-		struct hdmi_spec_per_pin *per_pin = get_pin(spec, pin_idx);
-
-		/* make sure downmix information in infoframe is zero */
-		snd_hda_codec_write(codec, per_pin->pin_nid, 0, ATI_VERB_SET_DOWNMIX_INFO, 0);
-
-		/* enable channel-wise remap mode if supported */
-		if (has_amd_full_remap_support(codec))
-			snd_hda_codec_write(codec, per_pin->pin_nid, 0,
-					    ATI_VERB_SET_MULTICHANNEL_MODE,
-					    ATI_MULTICHANNEL_MODE_SINGLE);
-	}
-	codec->auto_runtime_pm = 1;
-
-	return 0;
-}
-
-/* map from pin NID to port; port is 0-based */
-/* for AMD: assume widget NID starting from 3, with step 2 (3, 5, 7, ...) */
-static int atihdmi_pin2port(void *audio_ptr, int pin_nid)
-{
-	return pin_nid / 2 - 1;
-}
-
-/* reverse-map from port to pin NID: see above */
-static int atihdmi_port2pin(struct hda_codec *codec, int port)
-{
-	return port * 2 + 3;
-}
-
-static const struct drm_audio_component_audio_ops atihdmi_audio_ops = {
-	.pin2port = atihdmi_pin2port,
-	.pin_eld_notify = generic_acomp_pin_eld_notify,
-	.master_bind = generic_acomp_master_bind,
-	.master_unbind = generic_acomp_master_unbind,
-};
-
-static int patch_atihdmi(struct hda_codec *codec)
-{
-	struct hdmi_spec *spec;
-	struct hdmi_spec_per_cvt *per_cvt;
-	int err, cvt_idx;
-
-	err = patch_generic_hdmi(codec);
-
-	if (err)
-		return err;
-
-	codec->patch_ops.init = atihdmi_init;
-
-	spec = codec->spec;
-
-	spec->static_pcm_mapping = true;
-
-	spec->ops.pin_get_eld = atihdmi_pin_get_eld;
-	spec->ops.pin_setup_infoframe = atihdmi_pin_setup_infoframe;
-	spec->ops.pin_hbr_setup = atihdmi_pin_hbr_setup;
-	spec->ops.setup_stream = atihdmi_setup_stream;
-
-	spec->chmap.ops.pin_get_slot_channel = atihdmi_pin_get_slot_channel;
-	spec->chmap.ops.pin_set_slot_channel = atihdmi_pin_set_slot_channel;
-
-	if (!has_amd_full_remap_support(codec)) {
-		/* override to ATI/AMD-specific versions with pairwise mapping */
-		spec->chmap.ops.chmap_cea_alloc_validate_get_type =
-			atihdmi_paired_chmap_cea_alloc_validate_get_type;
-		spec->chmap.ops.cea_alloc_to_tlv_chmap =
-				atihdmi_paired_cea_alloc_to_tlv_chmap;
-		spec->chmap.ops.chmap_validate = atihdmi_paired_chmap_validate;
-	}
-
-	/* ATI/AMD converters do not advertise all of their capabilities */
-	for (cvt_idx = 0; cvt_idx < spec->num_cvts; cvt_idx++) {
-		per_cvt = get_cvt(spec, cvt_idx);
-		per_cvt->channels_max = max(per_cvt->channels_max, 8u);
-		per_cvt->rates |= SUPPORTED_RATES;
-		per_cvt->formats |= SUPPORTED_FORMATS;
-		per_cvt->maxbps = max(per_cvt->maxbps, 24u);
-	}
-
-	spec->chmap.channels_max = max(spec->chmap.channels_max, 8u);
-
-	/* AMD GPUs have neither EPSS nor CLKSTOP bits, hence preventing
-	 * the link-down as is.  Tell the core to allow it.
-	 */
-	codec->link_down_at_suspend = 1;
-
-	generic_acomp_init(codec, &atihdmi_audio_ops, atihdmi_port2pin);
-
-	return 0;
-}
-
-/* VIA HDMI Implementation */
-#define VIAHDMI_CVT_NID	0x02	/* audio converter1 */
-#define VIAHDMI_PIN_NID	0x03	/* HDMI output pin1 */
-
-static int patch_via_hdmi(struct hda_codec *codec)
-{
-	return patch_simple_hdmi(codec, VIAHDMI_CVT_NID, VIAHDMI_PIN_NID);
-}
 
 static int patch_gf_hdmi(struct hda_codec *codec)
 {
@@ -4509,125 +2367,15 @@ static int patch_gf_hdmi(struct hda_code
  */
 static const struct hda_device_id snd_hda_id_hdmi[] = {
 HDA_CODEC_ENTRY(0x00147a47, "Loongson HDMI",	patch_generic_hdmi),
-HDA_CODEC_ENTRY(0x1002793c, "RS600 HDMI",	patch_atihdmi),
-HDA_CODEC_ENTRY(0x10027919, "RS600 HDMI",	patch_atihdmi),
-HDA_CODEC_ENTRY(0x1002791a, "RS690/780 HDMI",	patch_atihdmi),
-HDA_CODEC_ENTRY(0x1002aa01, "R6xx HDMI",	patch_atihdmi),
 HDA_CODEC_ENTRY(0x10951390, "SiI1390 HDMI",	patch_generic_hdmi),
 HDA_CODEC_ENTRY(0x10951392, "SiI1392 HDMI",	patch_generic_hdmi),
 HDA_CODEC_ENTRY(0x17e80047, "Chrontel HDMI",	patch_generic_hdmi),
-HDA_CODEC_ENTRY(0x10de0001, "MCP73 HDMI",	patch_nvhdmi_2ch),
-HDA_CODEC_ENTRY(0x10de0002, "MCP77/78 HDMI",	patch_nvhdmi_8ch_7x),
-HDA_CODEC_ENTRY(0x10de0003, "MCP77/78 HDMI",	patch_nvhdmi_8ch_7x),
-HDA_CODEC_ENTRY(0x10de0004, "GPU 04 HDMI",	patch_nvhdmi_8ch_7x),
-HDA_CODEC_ENTRY(0x10de0005, "MCP77/78 HDMI",	patch_nvhdmi_8ch_7x),
-HDA_CODEC_ENTRY(0x10de0006, "MCP77/78 HDMI",	patch_nvhdmi_8ch_7x),
-HDA_CODEC_ENTRY(0x10de0007, "MCP79/7A HDMI",	patch_nvhdmi_8ch_7x),
-HDA_CODEC_ENTRY(0x10de0008, "GPU 08 HDMI/DP",	patch_nvhdmi_legacy),
-HDA_CODEC_ENTRY(0x10de0009, "GPU 09 HDMI/DP",	patch_nvhdmi_legacy),
-HDA_CODEC_ENTRY(0x10de000a, "GPU 0a HDMI/DP",	patch_nvhdmi_legacy),
-HDA_CODEC_ENTRY(0x10de000b, "GPU 0b HDMI/DP",	patch_nvhdmi_legacy),
-HDA_CODEC_ENTRY(0x10de000c, "MCP89 HDMI",	patch_nvhdmi_legacy),
-HDA_CODEC_ENTRY(0x10de000d, "GPU 0d HDMI/DP",	patch_nvhdmi_legacy),
-HDA_CODEC_ENTRY(0x10de0010, "GPU 10 HDMI/DP",	patch_nvhdmi_legacy),
-HDA_CODEC_ENTRY(0x10de0011, "GPU 11 HDMI/DP",	patch_nvhdmi_legacy),
-HDA_CODEC_ENTRY(0x10de0012, "GPU 12 HDMI/DP",	patch_nvhdmi_legacy),
-HDA_CODEC_ENTRY(0x10de0013, "GPU 13 HDMI/DP",	patch_nvhdmi_legacy),
-HDA_CODEC_ENTRY(0x10de0014, "GPU 14 HDMI/DP",	patch_nvhdmi_legacy),
-HDA_CODEC_ENTRY(0x10de0015, "GPU 15 HDMI/DP",	patch_nvhdmi_legacy),
-HDA_CODEC_ENTRY(0x10de0016, "GPU 16 HDMI/DP",	patch_nvhdmi_legacy),
-/* 17 is known to be absent */
-HDA_CODEC_ENTRY(0x10de0018, "GPU 18 HDMI/DP",	patch_nvhdmi_legacy),
-HDA_CODEC_ENTRY(0x10de0019, "GPU 19 HDMI/DP",	patch_nvhdmi_legacy),
-HDA_CODEC_ENTRY(0x10de001a, "GPU 1a HDMI/DP",	patch_nvhdmi_legacy),
-HDA_CODEC_ENTRY(0x10de001b, "GPU 1b HDMI/DP",	patch_nvhdmi_legacy),
-HDA_CODEC_ENTRY(0x10de001c, "GPU 1c HDMI/DP",	patch_nvhdmi_legacy),
-HDA_CODEC_ENTRY(0x10de0020, "Tegra30 HDMI",	patch_tegra_hdmi),
-HDA_CODEC_ENTRY(0x10de0022, "Tegra114 HDMI",	patch_tegra_hdmi),
-HDA_CODEC_ENTRY(0x10de0028, "Tegra124 HDMI",	patch_tegra_hdmi),
-HDA_CODEC_ENTRY(0x10de0029, "Tegra210 HDMI/DP",	patch_tegra_hdmi),
-HDA_CODEC_ENTRY(0x10de002d, "Tegra186 HDMI/DP0", patch_tegra_hdmi),
-HDA_CODEC_ENTRY(0x10de002e, "Tegra186 HDMI/DP1", patch_tegra_hdmi),
-HDA_CODEC_ENTRY(0x10de002f, "Tegra194 HDMI/DP2", patch_tegra_hdmi),
-HDA_CODEC_ENTRY(0x10de0030, "Tegra194 HDMI/DP3", patch_tegra_hdmi),
-HDA_CODEC_ENTRY(0x10de0031, "Tegra234 HDMI/DP", patch_tegra234_hdmi),
-HDA_CODEC_ENTRY(0x10de0033, "SoC 33 HDMI/DP",	patch_tegra234_hdmi),
-HDA_CODEC_ENTRY(0x10de0034, "Tegra264 HDMI/DP",	patch_tegra234_hdmi),
-HDA_CODEC_ENTRY(0x10de0035, "SoC 35 HDMI/DP",	patch_tegra234_hdmi),
-HDA_CODEC_ENTRY(0x10de0040, "GPU 40 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de0041, "GPU 41 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de0042, "GPU 42 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de0043, "GPU 43 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de0044, "GPU 44 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de0045, "GPU 45 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de0050, "GPU 50 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de0051, "GPU 51 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de0052, "GPU 52 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de0060, "GPU 60 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de0061, "GPU 61 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de0062, "GPU 62 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de0067, "MCP67 HDMI",	patch_nvhdmi_2ch),
-HDA_CODEC_ENTRY(0x10de0070, "GPU 70 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de0071, "GPU 71 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de0072, "GPU 72 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de0073, "GPU 73 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de0074, "GPU 74 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de0076, "GPU 76 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de007b, "GPU 7b HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de007c, "GPU 7c HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de007d, "GPU 7d HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de007e, "GPU 7e HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de0080, "GPU 80 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de0081, "GPU 81 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de0082, "GPU 82 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de0083, "GPU 83 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de0084, "GPU 84 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de0090, "GPU 90 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de0091, "GPU 91 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de0092, "GPU 92 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de0093, "GPU 93 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de0094, "GPU 94 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de0095, "GPU 95 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de0097, "GPU 97 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de0098, "GPU 98 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de0099, "GPU 99 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de009a, "GPU 9a HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de009b, "GPU 9b HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de009c, "GPU 9c HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de009d, "GPU 9d HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de009e, "GPU 9e HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de009f, "GPU 9f HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de00a0, "GPU a0 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de00a1, "GPU a1 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de00a3, "GPU a3 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de00a4, "GPU a4 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de00a5, "GPU a5 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de00a6, "GPU a6 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de00a7, "GPU a7 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de00a8, "GPU a8 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de00a9, "GPU a9 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de00aa, "GPU aa HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de00ab, "GPU ab HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de00ad, "GPU ad HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de00ae, "GPU ae HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de00af, "GPU af HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de00b0, "GPU b0 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de00b1, "GPU b1 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de00c0, "GPU c0 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de00c1, "GPU c1 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de00c3, "GPU c3 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de00c4, "GPU c4 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de00c5, "GPU c5 HDMI/DP",	patch_nvhdmi),
-HDA_CODEC_ENTRY(0x10de8001, "MCP73 HDMI",	patch_nvhdmi_2ch),
-HDA_CODEC_ENTRY(0x10de8067, "MCP67/68 HDMI",	patch_nvhdmi_2ch),
 HDA_CODEC_ENTRY(0x67663d82, "Arise 82 HDMI/DP",	patch_gf_hdmi),
 HDA_CODEC_ENTRY(0x67663d83, "Arise 83 HDMI/DP",	patch_gf_hdmi),
 HDA_CODEC_ENTRY(0x67663d84, "Arise 84 HDMI/DP",	patch_gf_hdmi),
 HDA_CODEC_ENTRY(0x67663d85, "Arise 85 HDMI/DP",	patch_gf_hdmi),
 HDA_CODEC_ENTRY(0x67663d86, "Arise 86 HDMI/DP",	patch_gf_hdmi),
 HDA_CODEC_ENTRY(0x67663d87, "Arise 87 HDMI/DP",	patch_gf_hdmi),
-HDA_CODEC_ENTRY(0x11069f80, "VX900 HDMI/DP",	patch_via_hdmi),
-HDA_CODEC_ENTRY(0x11069f81, "VX900 HDMI/DP",	patch_via_hdmi),
 HDA_CODEC_ENTRY(0x11069f84, "VX11 HDMI/DP",	patch_generic_hdmi),
 HDA_CODEC_ENTRY(0x11069f85, "VX11 HDMI/DP",	patch_generic_hdmi),
 HDA_CODEC_ENTRY(0x1d179f86, "ZX-100S HDMI/DP",	patch_gf_hdmi),
@@ -4641,40 +2389,10 @@ HDA_CODEC_ENTRY(0x1d179f8d, "KX-6000G HD
 HDA_CODEC_ENTRY(0x1d179f8e, "KX-7000 HDMI/DP",	patch_gf_hdmi),
 HDA_CODEC_ENTRY(0x1d179f8f, "KX-7000 HDMI/DP",	patch_gf_hdmi),
 HDA_CODEC_ENTRY(0x1d179f90, "KX-7000 HDMI/DP",	patch_gf_hdmi),
-HDA_CODEC_ENTRY(0x80860054, "IbexPeak HDMI",	patch_i915_cpt_hdmi),
-HDA_CODEC_ENTRY(0x80862800, "Geminilake HDMI",	patch_i915_glk_hdmi),
 HDA_CODEC_ENTRY(0x80862801, "Bearlake HDMI",	patch_generic_hdmi),
 HDA_CODEC_ENTRY(0x80862802, "Cantiga HDMI",	patch_generic_hdmi),
 HDA_CODEC_ENTRY(0x80862803, "Eaglelake HDMI",	patch_generic_hdmi),
-HDA_CODEC_ENTRY(0x80862804, "IbexPeak HDMI",	patch_i915_cpt_hdmi),
-HDA_CODEC_ENTRY(0x80862805, "CougarPoint HDMI",	patch_i915_cpt_hdmi),
-HDA_CODEC_ENTRY(0x80862806, "PantherPoint HDMI", patch_i915_cpt_hdmi),
-HDA_CODEC_ENTRY(0x80862807, "Haswell HDMI",	patch_i915_hsw_hdmi),
-HDA_CODEC_ENTRY(0x80862808, "Broadwell HDMI",	patch_i915_hsw_hdmi),
-HDA_CODEC_ENTRY(0x80862809, "Skylake HDMI",	patch_i915_hsw_hdmi),
-HDA_CODEC_ENTRY(0x8086280a, "Broxton HDMI",	patch_i915_hsw_hdmi),
-HDA_CODEC_ENTRY(0x8086280b, "Kabylake HDMI",	patch_i915_hsw_hdmi),
-HDA_CODEC_ENTRY(0x8086280c, "Cannonlake HDMI",	patch_i915_glk_hdmi),
-HDA_CODEC_ENTRY(0x8086280d, "Geminilake HDMI",	patch_i915_glk_hdmi),
-HDA_CODEC_ENTRY(0x8086280f, "Icelake HDMI",	patch_i915_icl_hdmi),
-HDA_CODEC_ENTRY(0x80862812, "Tigerlake HDMI",	patch_i915_tgl_hdmi),
-HDA_CODEC_ENTRY(0x80862814, "DG1 HDMI",	patch_i915_tgl_hdmi),
-HDA_CODEC_ENTRY(0x80862815, "Alderlake HDMI",	patch_i915_tgl_hdmi),
-HDA_CODEC_ENTRY(0x80862816, "Rocketlake HDMI",	patch_i915_tgl_hdmi),
-HDA_CODEC_ENTRY(0x80862818, "Raptorlake HDMI",	patch_i915_tgl_hdmi),
-HDA_CODEC_ENTRY(0x80862819, "DG2 HDMI",	patch_i915_tgl_hdmi),
-HDA_CODEC_ENTRY(0x8086281a, "Jasperlake HDMI",	patch_i915_icl_hdmi),
-HDA_CODEC_ENTRY(0x8086281b, "Elkhartlake HDMI",	patch_i915_icl_hdmi),
-HDA_CODEC_ENTRY(0x8086281c, "Alderlake-P HDMI", patch_i915_adlp_hdmi),
-HDA_CODEC_ENTRY(0x8086281d, "Meteor Lake HDMI",	patch_i915_adlp_hdmi),
-HDA_CODEC_ENTRY(0x8086281e, "Battlemage HDMI",	patch_i915_adlp_hdmi),
-HDA_CODEC_ENTRY(0x8086281f, "Raptor Lake P HDMI",	patch_i915_adlp_hdmi),
-HDA_CODEC_ENTRY(0x80862820, "Lunar Lake HDMI",	patch_i915_adlp_hdmi),
-HDA_CODEC_ENTRY(0x80862822, "Panther Lake HDMI",	patch_i915_adlp_hdmi),
-HDA_CODEC_ENTRY(0x80862823, "Wildcat Lake HDMI",	patch_i915_adlp_hdmi),
 HDA_CODEC_ENTRY(0x80862880, "CedarTrail HDMI",	patch_generic_hdmi),
-HDA_CODEC_ENTRY(0x80862882, "Valleyview2 HDMI",	patch_i915_byt_hdmi),
-HDA_CODEC_ENTRY(0x80862883, "Braswell HDMI",	patch_i915_byt_hdmi),
 HDA_CODEC_ENTRY(0x808629fb, "Crestline HDMI",	patch_generic_hdmi),
 /* special ID for generic HDMI */
 HDA_CODEC_ENTRY(HDA_CODEC_ID_GENERIC_HDMI, "Generic HDMI", patch_generic_hdmi),
@@ -4684,9 +2402,6 @@ MODULE_DEVICE_TABLE(hdaudio, snd_hda_id_
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("HDMI HD-audio codec");
-MODULE_ALIAS("snd-hda-codec-intelhdmi");
-MODULE_ALIAS("snd-hda-codec-nvhdmi");
-MODULE_ALIAS("snd-hda-codec-atihdmi");
 
 static struct hda_codec_driver hdmi_driver = {
 	.id = snd_hda_id_hdmi,
--- /dev/null
+++ b/sound/hda/codecs/hdmi/hdmi_local.h
@@ -0,0 +1,302 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * HD-audio HDMI codec driver
+ */
+
+#ifndef __HDA_HDMI_LOCAL_H
+#define __HDA_HDMI_LOCAL_H
+
+#include <sound/core.h>
+#include <sound/jack.h>
+#include <sound/hdaudio.h>
+#include <sound/hda_i915.h>
+#include <sound/hda_chmap.h>
+#include <sound/hda_codec.h>
+#include "hda_local.h"
+
+struct hdmi_spec_per_cvt {
+	hda_nid_t cvt_nid;
+	bool assigned;		/* the stream has been assigned */
+	bool silent_stream;	/* silent stream activated */
+	unsigned int channels_min;
+	unsigned int channels_max;
+	u32 rates;
+	u64 formats;
+	unsigned int maxbps;
+};
+
+/* max. connections to a widget */
+#define HDA_MAX_CONNECTIONS	32
+
+struct hdmi_spec_per_pin {
+	hda_nid_t pin_nid;
+	int dev_id;
+	/* pin idx, different device entries on the same pin use the same idx */
+	int pin_nid_idx;
+	int num_mux_nids;
+	hda_nid_t mux_nids[HDA_MAX_CONNECTIONS];
+	int mux_idx;
+	hda_nid_t cvt_nid;
+
+	struct hda_codec *codec;
+	struct hdmi_eld sink_eld;
+	struct mutex lock;
+	struct delayed_work work;
+	struct hdmi_pcm *pcm; /* pointer to spec->pcm_rec[n] dynamically*/
+	int pcm_idx; /* which pcm is attached. -1 means no pcm is attached */
+	int prev_pcm_idx; /* previously assigned pcm index */
+	int repoll_count;
+	bool setup; /* the stream has been set up by prepare callback */
+	bool silent_stream;
+	int channels; /* current number of channels */
+	bool non_pcm;
+	bool chmap_set;		/* channel-map override by ALSA API? */
+	unsigned char chmap[8]; /* ALSA API channel-map */
+#ifdef CONFIG_SND_PROC_FS
+	struct snd_info_entry *proc_entry;
+#endif
+};
+
+/* operations used by generic code that can be overridden by patches */
+struct hdmi_ops {
+	int (*pin_get_eld)(struct hda_codec *codec, hda_nid_t pin_nid,
+			   int dev_id, unsigned char *buf, int *eld_size);
+
+	void (*pin_setup_infoframe)(struct hda_codec *codec, hda_nid_t pin_nid,
+				    int dev_id,
+				    int ca, int active_channels, int conn_type);
+
+	/* enable/disable HBR (HD passthrough) */
+	int (*pin_hbr_setup)(struct hda_codec *codec, hda_nid_t pin_nid,
+			     int dev_id, bool hbr);
+
+	int (*setup_stream)(struct hda_codec *codec, hda_nid_t cvt_nid,
+			    hda_nid_t pin_nid, int dev_id, u32 stream_tag,
+			    int format);
+
+	void (*pin_cvt_fixup)(struct hda_codec *codec,
+			      struct hdmi_spec_per_pin *per_pin,
+			      hda_nid_t cvt_nid);
+
+	void (*silent_stream)(struct hda_codec *codec,
+			      struct hdmi_spec_per_pin *per_pin,
+			      bool enable);
+};
+
+struct hdmi_pcm {
+	struct hda_pcm *pcm;
+	struct snd_jack *jack;
+	struct snd_kcontrol *eld_ctl;
+};
+
+enum {
+	SILENT_STREAM_OFF = 0,
+	SILENT_STREAM_KAE,	/* use standard HDA Keep-Alive */
+	SILENT_STREAM_I915,	/* Intel i915 extension */
+};
+
+struct hdmi_spec {
+	struct hda_codec *codec;
+	int num_cvts;
+	struct snd_array cvts; /* struct hdmi_spec_per_cvt */
+	hda_nid_t cvt_nids[4]; /* only for haswell fix */
+
+	/*
+	 * num_pins is the number of virtual pins
+	 * for example, there are 3 pins, and each pin
+	 * has 4 device entries, then the num_pins is 12
+	 */
+	int num_pins;
+	/*
+	 * num_nids is the number of real pins
+	 * In the above example, num_nids is 3
+	 */
+	int num_nids;
+	/*
+	 * dev_num is the number of device entries
+	 * on each pin.
+	 * In the above example, dev_num is 4
+	 */
+	int dev_num;
+	struct snd_array pins; /* struct hdmi_spec_per_pin */
+	struct hdmi_pcm pcm_rec[8];
+	struct mutex pcm_lock;
+	struct mutex bind_lock; /* for audio component binding */
+	/* pcm_bitmap means which pcms have been assigned to pins*/
+	unsigned long pcm_bitmap;
+	int pcm_used;	/* counter of pcm_rec[] */
+	/* bitmap shows whether the pcm is opened in user space
+	 * bit 0 means the first playback PCM (PCM3);
+	 * bit 1 means the second playback PCM, and so on.
+	 */
+	unsigned long pcm_in_use;
+
+	struct hdmi_eld temp_eld;
+	struct hdmi_ops ops;
+
+	bool dyn_pin_out;
+	bool static_pcm_mapping;
+	/* hdmi interrupt trigger control flag for Nvidia codec */
+	bool hdmi_intr_trig_ctrl;
+	bool nv_dp_workaround; /* workaround DP audio infoframe for Nvidia */
+
+	bool intel_hsw_fixup;	/* apply Intel platform-specific fixups */
+	/*
+	 * Non-generic VIA/NVIDIA specific
+	 */
+	struct hda_multi_out multiout;
+	struct hda_pcm_stream pcm_playback;
+
+	bool use_acomp_notifier; /* use eld_notify callback for hotplug */
+	bool acomp_registered; /* audio component registered in this driver */
+	bool force_connect; /* force connectivity */
+	struct drm_audio_component_audio_ops drm_audio_ops;
+	int (*port2pin)(struct hda_codec *codec, int port); /* reverse port/pin mapping */
+
+	struct hdac_chmap chmap;
+	hda_nid_t vendor_nid;
+	const int *port_map;
+	int port_num;
+	int silent_stream_type;
+
+	const struct snd_pcm_hw_constraint_list *hw_constraints_channels;
+};
+
+#ifdef CONFIG_SND_HDA_COMPONENT
+static inline bool codec_has_acomp(struct hda_codec *codec)
+{
+	struct hdmi_spec *spec = codec->spec;
+
+	return spec->use_acomp_notifier;
+}
+#else
+#define codec_has_acomp(codec)	false
+#endif
+
+struct hdmi_audio_infoframe {
+	u8 type; /* 0x84 */
+	u8 ver;  /* 0x01 */
+	u8 len;  /* 0x0a */
+
+	u8 checksum;
+
+	u8 CC02_CT47;	/* CC in bits 0:2, CT in 4:7 */
+	u8 SS01_SF24;
+	u8 CXT04;
+	u8 CA;
+	u8 LFEPBL01_LSV36_DM_INH7;
+};
+
+struct dp_audio_infoframe {
+	u8 type; /* 0x84 */
+	u8 len;  /* 0x1b */
+	u8 ver;  /* 0x11 << 2 */
+
+	u8 CC02_CT47;	/* match with HDMI infoframe from this on */
+	u8 SS01_SF24;
+	u8 CXT04;
+	u8 CA;
+	u8 LFEPBL01_LSV36_DM_INH7;
+};
+
+union audio_infoframe {
+	struct hdmi_audio_infoframe hdmi;
+	struct dp_audio_infoframe dp;
+	DECLARE_FLEX_ARRAY(u8, bytes);
+};
+
+#ifdef LIMITED_RATE_FMT_SUPPORT
+/* support only the safe format and rate */
+#define SUPPORTED_RATES		SNDRV_PCM_RATE_48000
+#define SUPPORTED_MAXBPS	16
+#define SUPPORTED_FORMATS	SNDRV_PCM_FMTBIT_S16_LE
+#else
+/* support all rates and formats */
+#define SUPPORTED_RATES \
+	(SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |\
+	SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 |\
+	 SNDRV_PCM_RATE_192000)
+#define SUPPORTED_MAXBPS	24
+#define SUPPORTED_FORMATS \
+	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE)
+#endif
+
+/*
+ * HDMI routines
+ */
+
+#define get_pin(spec, idx) \
+	((struct hdmi_spec_per_pin *)snd_array_elem(&spec->pins, idx))
+#define get_cvt(spec, idx) \
+	((struct hdmi_spec_per_cvt  *)snd_array_elem(&spec->cvts, idx))
+/* obtain hdmi_pcm object assigned to idx */
+#define get_hdmi_pcm(spec, idx)	(&(spec)->pcm_rec[idx])
+/* obtain hda_pcm object assigned to idx */
+#define get_pcm_rec(spec, idx)	(get_hdmi_pcm(spec, idx)->pcm)
+
+/* Generic HDMI codec support */
+int snd_hda_hdmi_generic_alloc(struct hda_codec *codec);
+int snd_hda_hdmi_parse_codec(struct hda_codec *codec);
+int patch_generic_hdmi(struct hda_codec *codec);
+void snd_hda_hdmi_generic_free(struct hda_codec *codec);
+
+int snd_hda_hdmi_generic_build_pcms(struct hda_codec *codec);
+int snd_hda_hdmi_generic_build_controls(struct hda_codec *codec);
+int snd_hda_hdmi_generic_init(struct hda_codec *codec);
+int snd_hda_hdmi_generic_suspend(struct hda_codec *codec);
+int snd_hda_hdmi_generic_resume(struct hda_codec *codec);
+void snd_hda_hdmi_generic_unsol_event(struct hda_codec *codec, unsigned int res);
+
+int snd_hda_hdmi_pin_id_to_pin_index(struct hda_codec *codec,
+				     hda_nid_t pin_nid, int dev_id);
+#define pin_id_to_pin_index(codec, pin, dev) \
+	snd_hda_hdmi_pin_id_to_pin_index(codec, pin, dev)
+int snd_hda_hdmi_generic_init_per_pins(struct hda_codec *codec);
+void snd_hda_hdmi_generic_spec_free(struct hda_codec *codec);
+int snd_hda_hdmi_setup_stream(struct hda_codec *codec,
+			      hda_nid_t cvt_nid,
+			      hda_nid_t pin_nid, int dev_id,
+			      u32 stream_tag, int format);
+
+int snd_hda_hdmi_generic_pcm_prepare(struct hda_pcm_stream *hinfo,
+				     struct hda_codec *codec,
+				     unsigned int stream_tag,
+				     unsigned int format,
+				     struct snd_pcm_substream *substream);
+int snd_hda_hdmi_generic_pcm_cleanup(struct hda_pcm_stream *hinfo,
+				     struct hda_codec *codec,
+				     struct snd_pcm_substream *substream);
+
+void snd_hda_hdmi_check_presence_and_report(struct hda_codec *codec,
+					    hda_nid_t nid, int dev_id);
+void snd_hda_hdmi_setup_audio_infoframe(struct hda_codec *codec,
+					struct hdmi_spec_per_pin *per_pin,
+					bool non_pcm);
+
+/* Audio component support */
+void snd_hda_hdmi_setup_drm_audio_ops(struct hda_codec *codec,
+				      const struct drm_audio_component_audio_ops *ops);
+void snd_hda_hdmi_acomp_init(struct hda_codec *codec,
+			     const struct drm_audio_component_audio_ops *ops,
+			     int (*port2pin)(struct hda_codec *, int));
+void snd_hda_hdmi_acomp_pin_eld_notify(void *audio_ptr, int port, int dev_id);
+int snd_hda_hdmi_acomp_master_bind(struct device *dev,
+				   struct drm_audio_component *acomp);
+void snd_hda_hdmi_acomp_master_unbind(struct device *dev,
+				      struct drm_audio_component *acomp);
+
+/* Simple / legacy HDMI codec support */
+int patch_simple_hdmi(struct hda_codec *codec,
+		      hda_nid_t cvt_nid, hda_nid_t pin_nid);
+void snd_hda_hdmi_simple_free(struct hda_codec *codec);
+
+int snd_hda_hdmi_simple_build_pcms(struct hda_codec *codec);
+int snd_hda_hdmi_simple_build_controls(struct hda_codec *codec);
+int snd_hda_hdmi_simple_init(struct hda_codec *codec);
+void snd_hda_hdmi_simple_unsol_event(struct hda_codec *codec,
+				     unsigned int res);
+int snd_hda_hdmi_simple_pcm_open(struct hda_pcm_stream *hinfo,
+				 struct hda_codec *codec,
+				 struct snd_pcm_substream *substream);
+
+#endif /* __HDA_HDMI_LOCAL_H */
--- /dev/null
+++ b/sound/hda/codecs/hdmi/intelhdmi.c
@@ -0,0 +1,760 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Intel HDMI codec support
+ */
+
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <sound/core.h>
+#include <sound/hdaudio.h>
+#include <sound/hda_i915.h>
+#include <sound/hda_codec.h>
+#include "hda_local.h"
+#include "hdmi_local.h"
+
+static bool enable_silent_stream =
+IS_ENABLED(CONFIG_SND_HDA_INTEL_HDMI_SILENT_STREAM);
+module_param(enable_silent_stream, bool, 0644);
+MODULE_PARM_DESC(enable_silent_stream, "Enable Silent Stream for HDMI devices");
+
+#define INTEL_GET_VENDOR_VERB	0xf81
+#define INTEL_SET_VENDOR_VERB	0x781
+#define INTEL_EN_DP12		0x02	/* enable DP 1.2 features */
+#define INTEL_EN_ALL_PIN_CVTS	0x01	/* enable 2nd & 3rd pins and convertors */
+
+static void intel_haswell_enable_all_pins(struct hda_codec *codec,
+					  bool update_tree)
+{
+	unsigned int vendor_param;
+	struct hdmi_spec *spec = codec->spec;
+
+	vendor_param = snd_hda_codec_read(codec, spec->vendor_nid, 0,
+				INTEL_GET_VENDOR_VERB, 0);
+	if (vendor_param == -1 || vendor_param & INTEL_EN_ALL_PIN_CVTS)
+		return;
+
+	vendor_param |= INTEL_EN_ALL_PIN_CVTS;
+	vendor_param = snd_hda_codec_read(codec, spec->vendor_nid, 0,
+				INTEL_SET_VENDOR_VERB, vendor_param);
+	if (vendor_param == -1)
+		return;
+
+	if (update_tree)
+		snd_hda_codec_update_widgets(codec);
+}
+
+static void intel_haswell_fixup_enable_dp12(struct hda_codec *codec)
+{
+	unsigned int vendor_param;
+	struct hdmi_spec *spec = codec->spec;
+
+	vendor_param = snd_hda_codec_read(codec, spec->vendor_nid, 0,
+				INTEL_GET_VENDOR_VERB, 0);
+	if (vendor_param == -1 || vendor_param & INTEL_EN_DP12)
+		return;
+
+	/* enable DP1.2 mode */
+	vendor_param |= INTEL_EN_DP12;
+	snd_hdac_regmap_add_vendor_verb(&codec->core, INTEL_SET_VENDOR_VERB);
+	snd_hda_codec_write_cache(codec, spec->vendor_nid, 0,
+				INTEL_SET_VENDOR_VERB, vendor_param);
+}
+
+/* Haswell needs to re-issue the vendor-specific verbs before turning to D0.
+ * Otherwise you may get severe h/w communication errors.
+ */
+static void haswell_set_power_state(struct hda_codec *codec, hda_nid_t fg,
+				unsigned int power_state)
+{
+	if (power_state == AC_PWRST_D0) {
+		intel_haswell_enable_all_pins(codec, false);
+		intel_haswell_fixup_enable_dp12(codec);
+	}
+
+	snd_hda_codec_read(codec, fg, 0, AC_VERB_SET_POWER_STATE, power_state);
+	snd_hda_codec_set_power_to_all(codec, fg, power_state);
+}
+
+/* There is a fixed mapping between audio pin node and display port.
+ * on SNB, IVY, HSW, BSW, SKL, BXT, KBL:
+ * Pin Widget 5 - PORT B (port = 1 in i915 driver)
+ * Pin Widget 6 - PORT C (port = 2 in i915 driver)
+ * Pin Widget 7 - PORT D (port = 3 in i915 driver)
+ *
+ * on VLV, ILK:
+ * Pin Widget 4 - PORT B (port = 1 in i915 driver)
+ * Pin Widget 5 - PORT C (port = 2 in i915 driver)
+ * Pin Widget 6 - PORT D (port = 3 in i915 driver)
+ */
+static int intel_base_nid(struct hda_codec *codec)
+{
+	switch (codec->core.vendor_id) {
+	case 0x80860054: /* ILK */
+	case 0x80862804: /* ILK */
+	case 0x80862882: /* VLV */
+		return 4;
+	default:
+		return 5;
+	}
+}
+
+static int intel_pin2port(void *audio_ptr, int pin_nid)
+{
+	struct hda_codec *codec = audio_ptr;
+	struct hdmi_spec *spec = codec->spec;
+	int base_nid, i;
+
+	if (!spec->port_num) {
+		base_nid = intel_base_nid(codec);
+		if (WARN_ON(pin_nid < base_nid || pin_nid >= base_nid + 3))
+			return -1;
+		return pin_nid - base_nid + 1;
+	}
+
+	/*
+	 * looking for the pin number in the mapping table and return
+	 * the index which indicate the port number
+	 */
+	for (i = 0; i < spec->port_num; i++) {
+		if (pin_nid == spec->port_map[i])
+			return i;
+	}
+
+	codec_info(codec, "Can't find the HDMI/DP port for pin NID 0x%x\n", pin_nid);
+	return -1;
+}
+
+static int intel_port2pin(struct hda_codec *codec, int port)
+{
+	struct hdmi_spec *spec = codec->spec;
+
+	if (!spec->port_num) {
+		/* we assume only from port-B to port-D */
+		if (port < 1 || port > 3)
+			return 0;
+		return port + intel_base_nid(codec) - 1;
+	}
+
+	if (port < 0 || port >= spec->port_num)
+		return 0;
+	return spec->port_map[port];
+}
+
+static void intel_pin_eld_notify(void *audio_ptr, int port, int pipe)
+{
+	struct hda_codec *codec = audio_ptr;
+	int pin_nid;
+	int dev_id = pipe;
+
+	pin_nid = intel_port2pin(codec, port);
+	if (!pin_nid)
+		return;
+	/* skip notification during system suspend (but not in runtime PM);
+	 * the state will be updated at resume
+	 */
+	if (codec->core.dev.power.power_state.event == PM_EVENT_SUSPEND)
+		return;
+
+	snd_hdac_i915_set_bclk(&codec->bus->core);
+	snd_hda_hdmi_check_presence_and_report(codec, pin_nid, dev_id);
+}
+
+static const struct drm_audio_component_audio_ops intel_audio_ops = {
+	.pin2port = intel_pin2port,
+	.pin_eld_notify = intel_pin_eld_notify,
+};
+
+/* register i915 component pin_eld_notify callback */
+static void register_i915_notifier(struct hda_codec *codec)
+{
+	struct hdmi_spec *spec = codec->spec;
+
+	spec->use_acomp_notifier = true;
+	spec->port2pin = intel_port2pin;
+	snd_hda_hdmi_setup_drm_audio_ops(codec, &intel_audio_ops);
+	snd_hdac_acomp_register_notifier(&codec->bus->core,
+					&spec->drm_audio_ops);
+	/* no need for forcible resume for jack check thanks to notifier */
+	codec->relaxed_resume = 1;
+}
+
+#define I915_SILENT_RATE		48000
+#define I915_SILENT_CHANNELS		2
+#define I915_SILENT_FORMAT_BITS	16
+#define I915_SILENT_FMT_MASK		0xf
+
+static void silent_stream_enable_i915(struct hda_codec *codec,
+				      struct hdmi_spec_per_pin *per_pin)
+{
+	unsigned int format;
+
+	snd_hdac_sync_audio_rate(&codec->core, per_pin->pin_nid,
+				 per_pin->dev_id, I915_SILENT_RATE);
+
+	/* trigger silent stream generation in hw */
+	format = snd_hdac_stream_format(I915_SILENT_CHANNELS, I915_SILENT_FORMAT_BITS,
+					I915_SILENT_RATE);
+	snd_hda_codec_setup_stream(codec, per_pin->cvt_nid,
+				   I915_SILENT_FMT_MASK, I915_SILENT_FMT_MASK, format);
+	usleep_range(100, 200);
+	snd_hda_codec_setup_stream(codec, per_pin->cvt_nid, I915_SILENT_FMT_MASK, 0, format);
+
+	per_pin->channels = I915_SILENT_CHANNELS;
+	snd_hda_hdmi_setup_audio_infoframe(codec, per_pin, per_pin->non_pcm);
+}
+
+static void silent_stream_set_kae(struct hda_codec *codec,
+				  struct hdmi_spec_per_pin *per_pin,
+				  bool enable)
+{
+	unsigned int param;
+
+	codec_dbg(codec, "HDMI: KAE %d cvt-NID=0x%x\n", enable, per_pin->cvt_nid);
+
+	param = snd_hda_codec_read(codec, per_pin->cvt_nid, 0, AC_VERB_GET_DIGI_CONVERT_1, 0);
+	param = (param >> 16) & 0xff;
+
+	if (enable)
+		param |= AC_DIG3_KAE;
+	else
+		param &= ~AC_DIG3_KAE;
+
+	snd_hda_codec_write(codec, per_pin->cvt_nid, 0, AC_VERB_SET_DIGI_CONVERT_3, param);
+}
+
+static void i915_set_silent_stream(struct hda_codec *codec,
+				   struct hdmi_spec_per_pin *per_pin,
+				   bool enable)
+{
+	struct hdmi_spec *spec = codec->spec;
+
+	switch (spec->silent_stream_type) {
+	case SILENT_STREAM_KAE:
+		if (enable) {
+			silent_stream_enable_i915(codec, per_pin);
+			silent_stream_set_kae(codec, per_pin, true);
+		} else {
+			silent_stream_set_kae(codec, per_pin, false);
+		}
+		break;
+	case SILENT_STREAM_I915:
+		if (enable) {
+			silent_stream_enable_i915(codec, per_pin);
+			snd_hda_power_up_pm(codec);
+		} else {
+			/* release ref taken in silent_stream_enable() */
+			snd_hda_power_down_pm(codec);
+		}
+		break;
+	default:
+		break;
+	}
+}
+
+static void haswell_verify_D0(struct hda_codec *codec,
+			      hda_nid_t cvt_nid, hda_nid_t nid)
+{
+	int pwr;
+
+	/* For Haswell, the converter 1/2 may keep in D3 state after bootup,
+	 * thus pins could only choose converter 0 for use. Make sure the
+	 * converters are in correct power state
+	 */
+	if (!snd_hda_check_power_state(codec, cvt_nid, AC_PWRST_D0))
+		snd_hda_codec_write(codec, cvt_nid, 0, AC_VERB_SET_POWER_STATE, AC_PWRST_D0);
+
+	if (!snd_hda_check_power_state(codec, nid, AC_PWRST_D0)) {
+		snd_hda_codec_write(codec, nid, 0, AC_VERB_SET_POWER_STATE,
+				    AC_PWRST_D0);
+		msleep(40);
+		pwr = snd_hda_codec_read(codec, nid, 0, AC_VERB_GET_POWER_STATE, 0);
+		pwr = (pwr & AC_PWRST_ACTUAL) >> AC_PWRST_ACTUAL_SHIFT;
+		codec_dbg(codec, "Haswell HDMI audio: Power for NID 0x%x is now D%d\n", nid, pwr);
+	}
+}
+
+/* Assure the pin select the right convetor */
+static void intel_verify_pin_cvt_connect(struct hda_codec *codec,
+			struct hdmi_spec_per_pin *per_pin)
+{
+	hda_nid_t pin_nid = per_pin->pin_nid;
+	int mux_idx, curr;
+
+	mux_idx = per_pin->mux_idx;
+	curr = snd_hda_codec_read(codec, pin_nid, 0,
+					  AC_VERB_GET_CONNECT_SEL, 0);
+	if (curr != mux_idx)
+		snd_hda_codec_write_cache(codec, pin_nid, 0,
+					    AC_VERB_SET_CONNECT_SEL,
+					    mux_idx);
+}
+
+/* get the mux index for the converter of the pins
+ * converter's mux index is the same for all pins on Intel platform
+ */
+static int intel_cvt_id_to_mux_idx(struct hdmi_spec *spec,
+			hda_nid_t cvt_nid)
+{
+	int i;
+
+	for (i = 0; i < spec->num_cvts; i++)
+		if (spec->cvt_nids[i] == cvt_nid)
+			return i;
+	return -EINVAL;
+}
+
+/* Intel HDMI workaround to fix audio routing issue:
+ * For some Intel display codecs, pins share the same connection list.
+ * So a conveter can be selected by multiple pins and playback on any of these
+ * pins will generate sound on the external display, because audio flows from
+ * the same converter to the display pipeline. Also muting one pin may make
+ * other pins have no sound output.
+ * So this function assures that an assigned converter for a pin is not selected
+ * by any other pins.
+ */
+static void intel_not_share_assigned_cvt(struct hda_codec *codec,
+					 hda_nid_t pin_nid,
+					 int dev_id, int mux_idx)
+{
+	struct hdmi_spec *spec = codec->spec;
+	hda_nid_t nid;
+	int cvt_idx, curr;
+	struct hdmi_spec_per_cvt *per_cvt;
+	struct hdmi_spec_per_pin *per_pin;
+	int pin_idx;
+
+	/* configure the pins connections */
+	for (pin_idx = 0; pin_idx < spec->num_pins; pin_idx++) {
+		int dev_id_saved;
+		int dev_num;
+
+		per_pin = get_pin(spec, pin_idx);
+		/*
+		 * pin not connected to monitor
+		 * no need to operate on it
+		 */
+		if (!per_pin->pcm)
+			continue;
+
+		if ((per_pin->pin_nid == pin_nid) &&
+			(per_pin->dev_id == dev_id))
+			continue;
+
+		/*
+		 * if per_pin->dev_id >= dev_num,
+		 * snd_hda_get_dev_select() will fail,
+		 * and the following operation is unpredictable.
+		 * So skip this situation.
+		 */
+		dev_num = snd_hda_get_num_devices(codec, per_pin->pin_nid) + 1;
+		if (per_pin->dev_id >= dev_num)
+			continue;
+
+		nid = per_pin->pin_nid;
+
+		/*
+		 * Calling this function should not impact
+		 * on the device entry selection
+		 * So let's save the dev id for each pin,
+		 * and restore it when return
+		 */
+		dev_id_saved = snd_hda_get_dev_select(codec, nid);
+		snd_hda_set_dev_select(codec, nid, per_pin->dev_id);
+		curr = snd_hda_codec_read(codec, nid, 0,
+					  AC_VERB_GET_CONNECT_SEL, 0);
+		if (curr != mux_idx) {
+			snd_hda_set_dev_select(codec, nid, dev_id_saved);
+			continue;
+		}
+
+
+		/* choose an unassigned converter. The conveters in the
+		 * connection list are in the same order as in the codec.
+		 */
+		for (cvt_idx = 0; cvt_idx < spec->num_cvts; cvt_idx++) {
+			per_cvt = get_cvt(spec, cvt_idx);
+			if (!per_cvt->assigned) {
+				codec_dbg(codec,
+					  "choose cvt %d for pin NID 0x%x\n",
+					  cvt_idx, nid);
+				snd_hda_codec_write_cache(codec, nid, 0,
+					    AC_VERB_SET_CONNECT_SEL,
+					    cvt_idx);
+				break;
+			}
+		}
+		snd_hda_set_dev_select(codec, nid, dev_id_saved);
+	}
+}
+
+/* A wrapper of intel_not_share_asigned_cvt() */
+static void intel_not_share_assigned_cvt_nid(struct hda_codec *codec,
+			hda_nid_t pin_nid, int dev_id, hda_nid_t cvt_nid)
+{
+	int mux_idx;
+	struct hdmi_spec *spec = codec->spec;
+
+	/* On Intel platform, the mapping of converter nid to
+	 * mux index of the pins are always the same.
+	 * The pin nid may be 0, this means all pins will not
+	 * share the converter.
+	 */
+	mux_idx = intel_cvt_id_to_mux_idx(spec, cvt_nid);
+	if (mux_idx >= 0)
+		intel_not_share_assigned_cvt(codec, pin_nid, dev_id, mux_idx);
+}
+
+/* setup_stream ops override for HSW+ */
+static int i915_hsw_setup_stream(struct hda_codec *codec, hda_nid_t cvt_nid,
+				 hda_nid_t pin_nid, int dev_id, u32 stream_tag,
+				 int format)
+{
+	struct hdmi_spec *spec = codec->spec;
+	int pin_idx = pin_id_to_pin_index(codec, pin_nid, dev_id);
+	struct hdmi_spec_per_pin *per_pin;
+	int res;
+
+	if (pin_idx < 0)
+		per_pin = NULL;
+	else
+		per_pin = get_pin(spec, pin_idx);
+
+	haswell_verify_D0(codec, cvt_nid, pin_nid);
+
+	if (spec->silent_stream_type == SILENT_STREAM_KAE && per_pin && per_pin->silent_stream) {
+		silent_stream_set_kae(codec, per_pin, false);
+		/* wait for pending transfers in codec to clear */
+		usleep_range(100, 200);
+	}
+
+	res = snd_hda_hdmi_setup_stream(codec, cvt_nid, pin_nid, dev_id,
+					stream_tag, format);
+
+	if (spec->silent_stream_type == SILENT_STREAM_KAE && per_pin && per_pin->silent_stream) {
+		usleep_range(100, 200);
+		silent_stream_set_kae(codec, per_pin, true);
+	}
+
+	return res;
+}
+
+/* pin_cvt_fixup ops override for HSW+ and VLV+ */
+static void i915_pin_cvt_fixup(struct hda_codec *codec,
+			       struct hdmi_spec_per_pin *per_pin,
+			       hda_nid_t cvt_nid)
+{
+	if (per_pin) {
+		haswell_verify_D0(codec, per_pin->cvt_nid, per_pin->pin_nid);
+		snd_hda_set_dev_select(codec, per_pin->pin_nid,
+			       per_pin->dev_id);
+		intel_verify_pin_cvt_connect(codec, per_pin);
+		intel_not_share_assigned_cvt(codec, per_pin->pin_nid,
+				     per_pin->dev_id, per_pin->mux_idx);
+	} else {
+		intel_not_share_assigned_cvt_nid(codec, 0, 0, cvt_nid);
+	}
+}
+
+static int i915_adlp_hdmi_suspend(struct hda_codec *codec)
+{
+	struct hdmi_spec *spec = codec->spec;
+	bool silent_streams = false;
+	int pin_idx, res;
+
+	res = snd_hda_hdmi_generic_suspend(codec);
+
+	for (pin_idx = 0; pin_idx < spec->num_pins; pin_idx++) {
+		struct hdmi_spec_per_pin *per_pin = get_pin(spec, pin_idx);
+
+		if (per_pin->silent_stream) {
+			silent_streams = true;
+			break;
+		}
+	}
+
+	if (silent_streams) {
+		/*
+		 * stream-id should remain programmed when codec goes
+		 * to runtime suspend
+		 */
+		codec->no_stream_clean_at_suspend = 1;
+
+		/*
+		 * the system might go to S3, in which case keep-alive
+		 * must be reprogrammed upon resume
+		 */
+		codec->forced_resume = 1;
+
+		codec_dbg(codec, "HDMI: KAE active at suspend\n");
+	} else {
+		codec->no_stream_clean_at_suspend = 0;
+		codec->forced_resume = 0;
+	}
+
+	return res;
+}
+
+static int i915_adlp_hdmi_resume(struct hda_codec *codec)
+{
+	struct hdmi_spec *spec = codec->spec;
+	int pin_idx, res;
+
+	res = snd_hda_hdmi_generic_resume(codec);
+
+	/* KAE not programmed at suspend, nothing to do here */
+	if (!codec->no_stream_clean_at_suspend)
+		return res;
+
+	for (pin_idx = 0; pin_idx < spec->num_pins; pin_idx++) {
+		struct hdmi_spec_per_pin *per_pin = get_pin(spec, pin_idx);
+
+		/*
+		 * If system was in suspend with monitor connected,
+		 * the codec setting may have been lost. Re-enable
+		 * keep-alive.
+		 */
+		if (per_pin->silent_stream) {
+			unsigned int param;
+
+			param = snd_hda_codec_read(codec, per_pin->cvt_nid, 0,
+						   AC_VERB_GET_CONV, 0);
+			if (!param) {
+				codec_dbg(codec, "HDMI: KAE: restore stream id\n");
+				silent_stream_enable_i915(codec, per_pin);
+			}
+
+			param = snd_hda_codec_read(codec, per_pin->cvt_nid, 0,
+						   AC_VERB_GET_DIGI_CONVERT_1, 0);
+			if (!(param & (AC_DIG3_KAE << 16))) {
+				codec_dbg(codec, "HDMI: KAE: restore DIG3_KAE\n");
+				silent_stream_set_kae(codec, per_pin, true);
+			}
+		}
+	}
+
+	return res;
+}
+
+/* precondition and allocation for Intel codecs */
+static int alloc_intel_hdmi(struct hda_codec *codec)
+{
+	int err;
+
+	/* requires i915 binding */
+	if (!codec->bus->core.audio_component) {
+		codec_info(codec, "No i915 binding for Intel HDMI/DP codec\n");
+		/* set probe_id here to prevent generic fallback binding */
+		codec->probe_id = HDA_CODEC_ID_SKIP_PROBE;
+		return -ENODEV;
+	}
+
+	err = snd_hda_hdmi_generic_alloc(codec);
+	if (err < 0)
+		return err;
+	/* no need to handle unsol events */
+	codec->patch_ops.unsol_event = NULL;
+	return 0;
+}
+
+/* parse and post-process for Intel codecs */
+static int parse_intel_hdmi(struct hda_codec *codec)
+{
+	int err, retries = 3;
+
+	do {
+		err = snd_hda_hdmi_parse_codec(codec);
+	} while (err < 0 && retries--);
+
+	if (err < 0)
+		return err;
+
+	snd_hda_hdmi_generic_init_per_pins(codec);
+	register_i915_notifier(codec);
+	return 0;
+}
+
+/* Intel Haswell and onwards; audio component with eld notifier */
+static int intel_hsw_common_init(struct hda_codec *codec, hda_nid_t vendor_nid,
+				 const int *port_map, int port_num, int dev_num,
+				 bool send_silent_stream)
+{
+	struct hdmi_spec *spec;
+	int err;
+
+	err = alloc_intel_hdmi(codec);
+	if (err < 0)
+		return err;
+	spec = codec->spec;
+	codec->dp_mst = true;
+	spec->vendor_nid = vendor_nid;
+	spec->port_map = port_map;
+	spec->port_num = port_num;
+	spec->intel_hsw_fixup = true;
+	spec->dev_num = dev_num;
+
+	intel_haswell_enable_all_pins(codec, true);
+	intel_haswell_fixup_enable_dp12(codec);
+
+	codec->display_power_control = 1;
+
+	codec->patch_ops.set_power_state = haswell_set_power_state;
+	codec->depop_delay = 0;
+	codec->auto_runtime_pm = 1;
+
+	spec->ops.setup_stream = i915_hsw_setup_stream;
+	spec->ops.pin_cvt_fixup = i915_pin_cvt_fixup;
+	spec->ops.silent_stream = i915_set_silent_stream;
+
+	/*
+	 * Enable silent stream feature, if it is enabled via
+	 * module param or Kconfig option
+	 */
+	if (send_silent_stream)
+		spec->silent_stream_type = SILENT_STREAM_I915;
+
+	return parse_intel_hdmi(codec);
+}
+
+static int patch_i915_hsw_hdmi(struct hda_codec *codec)
+{
+	return intel_hsw_common_init(codec, 0x08, NULL, 0, 3,
+				     enable_silent_stream);
+}
+
+static int patch_i915_glk_hdmi(struct hda_codec *codec)
+{
+	/*
+	 * Silent stream calls audio component .get_power() from
+	 * .pin_eld_notify(). On GLK this will deadlock in i915 due
+	 * to the audio vs. CDCLK workaround.
+	 */
+	return intel_hsw_common_init(codec, 0x0b, NULL, 0, 3, false);
+}
+
+static int patch_i915_icl_hdmi(struct hda_codec *codec)
+{
+	/*
+	 * pin to port mapping table where the value indicate the pin number and
+	 * the index indicate the port number.
+	 */
+	static const int map[] = {0x0, 0x4, 0x6, 0x8, 0xa, 0xb};
+
+	return intel_hsw_common_init(codec, 0x02, map, ARRAY_SIZE(map), 3,
+				     enable_silent_stream);
+}
+
+static int patch_i915_tgl_hdmi(struct hda_codec *codec)
+{
+	/*
+	 * pin to port mapping table where the value indicate the pin number and
+	 * the index indicate the port number.
+	 */
+	static const int map[] = {0x4, 0x6, 0x8, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf};
+
+	return intel_hsw_common_init(codec, 0x02, map, ARRAY_SIZE(map), 4,
+				     enable_silent_stream);
+}
+
+static int patch_i915_adlp_hdmi(struct hda_codec *codec)
+{
+	struct hdmi_spec *spec;
+	int res;
+
+	res = patch_i915_tgl_hdmi(codec);
+	if (!res) {
+		spec = codec->spec;
+
+		if (spec->silent_stream_type) {
+			spec->silent_stream_type = SILENT_STREAM_KAE;
+
+			codec->patch_ops.resume = i915_adlp_hdmi_resume;
+			codec->patch_ops.suspend = i915_adlp_hdmi_suspend;
+		}
+	}
+
+	return res;
+}
+
+/* Intel Baytrail and Braswell; with eld notifier */
+static int patch_i915_byt_hdmi(struct hda_codec *codec)
+{
+	struct hdmi_spec *spec;
+	int err;
+
+	err = alloc_intel_hdmi(codec);
+	if (err < 0)
+		return err;
+	spec = codec->spec;
+
+	/* For Valleyview/Cherryview, only the display codec is in the display
+	 * power well and can use link_power ops to request/release the power.
+	 */
+	codec->display_power_control = 1;
+
+	codec->depop_delay = 0;
+	codec->auto_runtime_pm = 1;
+
+	spec->ops.pin_cvt_fixup = i915_pin_cvt_fixup;
+
+	return parse_intel_hdmi(codec);
+}
+
+/* Intel IronLake, SandyBridge and IvyBridge; with eld notifier */
+static int patch_i915_cpt_hdmi(struct hda_codec *codec)
+{
+	int err;
+
+	err = alloc_intel_hdmi(codec);
+	if (err < 0)
+		return err;
+	return parse_intel_hdmi(codec);
+}
+
+/*
+ * driver entries
+ */
+static const struct hda_device_id snd_hda_id_intelhdmi[] = {
+HDA_CODEC_ENTRY(0x80860054, "IbexPeak HDMI",	patch_i915_cpt_hdmi),
+HDA_CODEC_ENTRY(0x80862800, "Geminilake HDMI",	patch_i915_glk_hdmi),
+HDA_CODEC_ENTRY(0x80862804, "IbexPeak HDMI",	patch_i915_cpt_hdmi),
+HDA_CODEC_ENTRY(0x80862805, "CougarPoint HDMI",	patch_i915_cpt_hdmi),
+HDA_CODEC_ENTRY(0x80862806, "PantherPoint HDMI", patch_i915_cpt_hdmi),
+HDA_CODEC_ENTRY(0x80862807, "Haswell HDMI",	patch_i915_hsw_hdmi),
+HDA_CODEC_ENTRY(0x80862808, "Broadwell HDMI",	patch_i915_hsw_hdmi),
+HDA_CODEC_ENTRY(0x80862809, "Skylake HDMI",	patch_i915_hsw_hdmi),
+HDA_CODEC_ENTRY(0x8086280a, "Broxton HDMI",	patch_i915_hsw_hdmi),
+HDA_CODEC_ENTRY(0x8086280b, "Kabylake HDMI",	patch_i915_hsw_hdmi),
+HDA_CODEC_ENTRY(0x8086280c, "Cannonlake HDMI",	patch_i915_glk_hdmi),
+HDA_CODEC_ENTRY(0x8086280d, "Geminilake HDMI",	patch_i915_glk_hdmi),
+HDA_CODEC_ENTRY(0x8086280f, "Icelake HDMI",	patch_i915_icl_hdmi),
+HDA_CODEC_ENTRY(0x80862812, "Tigerlake HDMI",	patch_i915_tgl_hdmi),
+HDA_CODEC_ENTRY(0x80862814, "DG1 HDMI",	patch_i915_tgl_hdmi),
+HDA_CODEC_ENTRY(0x80862815, "Alderlake HDMI",	patch_i915_tgl_hdmi),
+HDA_CODEC_ENTRY(0x80862816, "Rocketlake HDMI",	patch_i915_tgl_hdmi),
+HDA_CODEC_ENTRY(0x80862818, "Raptorlake HDMI",	patch_i915_tgl_hdmi),
+HDA_CODEC_ENTRY(0x80862819, "DG2 HDMI",	patch_i915_tgl_hdmi),
+HDA_CODEC_ENTRY(0x8086281a, "Jasperlake HDMI",	patch_i915_icl_hdmi),
+HDA_CODEC_ENTRY(0x8086281b, "Elkhartlake HDMI",	patch_i915_icl_hdmi),
+HDA_CODEC_ENTRY(0x8086281c, "Alderlake-P HDMI", patch_i915_adlp_hdmi),
+HDA_CODEC_ENTRY(0x8086281d, "Meteor Lake HDMI",	patch_i915_adlp_hdmi),
+HDA_CODEC_ENTRY(0x8086281e, "Battlemage HDMI",	patch_i915_adlp_hdmi),
+HDA_CODEC_ENTRY(0x8086281f, "Raptor Lake P HDMI",	patch_i915_adlp_hdmi),
+HDA_CODEC_ENTRY(0x80862820, "Lunar Lake HDMI",	patch_i915_adlp_hdmi),
+HDA_CODEC_ENTRY(0x80862822, "Panther Lake HDMI",	patch_i915_adlp_hdmi),
+HDA_CODEC_ENTRY(0x80862823, "Wildcat Lake HDMI",	patch_i915_adlp_hdmi),
+HDA_CODEC_ENTRY(0x80862882, "Valleyview2 HDMI",	patch_i915_byt_hdmi),
+HDA_CODEC_ENTRY(0x80862883, "Braswell HDMI",	patch_i915_byt_hdmi),
+{} /* terminator */
+};
+MODULE_DEVICE_TABLE(hdaudio, snd_hda_id_intelhdmi);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Intel HDMI HD-audio codec");
+MODULE_IMPORT_NS(SND_HDA_CODEC_HDMI);
+
+static struct hda_codec_driver intelhdmi_driver = {
+	.id = snd_hda_id_intelhdmi,
+};
+
+module_hda_codec_driver(intelhdmi_driver);
--- /dev/null
+++ b/sound/hda/codecs/hdmi/nvhdmi-mcp.c
@@ -0,0 +1,382 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Legacy Nvidia HDMI codec support
+ */
+
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <sound/core.h>
+#include <sound/hdaudio.h>
+#include <sound/hda_codec.h>
+#include "hda_local.h"
+#include "hdmi_local.h"
+
+#define Nv_VERB_SET_Channel_Allocation          0xF79
+#define Nv_VERB_SET_Info_Frame_Checksum         0xF7A
+#define Nv_VERB_SET_Audio_Protection_On         0xF98
+#define Nv_VERB_SET_Audio_Protection_Off        0xF99
+
+#define nvhdmi_master_con_nid_7x	0x04
+#define nvhdmi_master_pin_nid_7x	0x05
+
+static const hda_nid_t nvhdmi_con_nids_7x[4] = {
+	/*front, rear, clfe, rear_surr */
+	0x6, 0x8, 0xa, 0xc,
+};
+
+static const struct hda_verb nvhdmi_basic_init_7x_2ch[] = {
+	/* set audio protect on */
+	{ 0x1, Nv_VERB_SET_Audio_Protection_On, 0x1},
+	/* enable digital output on pin widget */
+	{ 0x5, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT | 0x5 },
+	{} /* terminator */
+};
+
+static const struct hda_verb nvhdmi_basic_init_7x_8ch[] = {
+	/* set audio protect on */
+	{ 0x1, Nv_VERB_SET_Audio_Protection_On, 0x1},
+	/* enable digital output on pin widget */
+	{ 0x5, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT | 0x5 },
+	{ 0x7, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT | 0x5 },
+	{ 0x9, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT | 0x5 },
+	{ 0xb, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT | 0x5 },
+	{ 0xd, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT | 0x5 },
+	{} /* terminator */
+};
+
+static int nvhdmi_7x_init_2ch(struct hda_codec *codec)
+{
+	snd_hda_sequence_write(codec, nvhdmi_basic_init_7x_2ch);
+	return 0;
+}
+
+static int nvhdmi_7x_init_8ch(struct hda_codec *codec)
+{
+	snd_hda_sequence_write(codec, nvhdmi_basic_init_7x_8ch);
+	return 0;
+}
+
+static void nvhdmi_8ch_7x_set_info_frame_parameters(struct hda_codec *codec,
+						    int channels)
+{
+	unsigned int chanmask;
+	int chan = channels ? (channels - 1) : 1;
+
+	switch (channels) {
+	default:
+	case 0:
+	case 2:
+		chanmask = 0x00;
+		break;
+	case 4:
+		chanmask = 0x08;
+		break;
+	case 6:
+		chanmask = 0x0b;
+		break;
+	case 8:
+		chanmask = 0x13;
+		break;
+	}
+
+	/* Set the audio infoframe channel allocation and checksum fields.  The
+	 * channel count is computed implicitly by the hardware.
+	 */
+	snd_hda_codec_write(codec, 0x1, 0,
+			Nv_VERB_SET_Channel_Allocation, chanmask);
+
+	snd_hda_codec_write(codec, 0x1, 0,
+			Nv_VERB_SET_Info_Frame_Checksum,
+			(0x71 - chan - chanmask));
+}
+
+static int nvhdmi_8ch_7x_pcm_close(struct hda_pcm_stream *hinfo,
+				   struct hda_codec *codec,
+				   struct snd_pcm_substream *substream)
+{
+	struct hdmi_spec *spec = codec->spec;
+	int i;
+
+	snd_hda_codec_write(codec, nvhdmi_master_con_nid_7x,
+			0, AC_VERB_SET_CHANNEL_STREAMID, 0);
+	for (i = 0; i < 4; i++) {
+		/* set the stream id */
+		snd_hda_codec_write(codec, nvhdmi_con_nids_7x[i], 0,
+				AC_VERB_SET_CHANNEL_STREAMID, 0);
+		/* set the stream format */
+		snd_hda_codec_write(codec, nvhdmi_con_nids_7x[i], 0,
+				AC_VERB_SET_STREAM_FORMAT, 0);
+	}
+
+	/* The audio hardware sends a channel count of 0x7 (8ch) when all the
+	 * streams are disabled.
+	 */
+	nvhdmi_8ch_7x_set_info_frame_parameters(codec, 8);
+
+	return snd_hda_multi_out_dig_close(codec, &spec->multiout);
+}
+
+static int nvhdmi_8ch_7x_pcm_prepare(struct hda_pcm_stream *hinfo,
+				     struct hda_codec *codec,
+				     unsigned int stream_tag,
+				     unsigned int format,
+				     struct snd_pcm_substream *substream)
+{
+	int chs;
+	unsigned int dataDCC2, channel_id;
+	int i;
+	struct hdmi_spec *spec = codec->spec;
+	struct hda_spdif_out *spdif;
+	struct hdmi_spec_per_cvt *per_cvt;
+
+	mutex_lock(&codec->spdif_mutex);
+	per_cvt = get_cvt(spec, 0);
+	spdif = snd_hda_spdif_out_of_nid(codec, per_cvt->cvt_nid);
+
+	chs = substream->runtime->channels;
+
+	dataDCC2 = 0x2;
+
+	/* turn off SPDIF once; otherwise the IEC958 bits won't be updated */
+	if (codec->spdif_status_reset && (spdif->ctls & AC_DIG1_ENABLE))
+		snd_hda_codec_write(codec,
+				nvhdmi_master_con_nid_7x,
+				0,
+				AC_VERB_SET_DIGI_CONVERT_1,
+				spdif->ctls & ~AC_DIG1_ENABLE & 0xff);
+
+	/* set the stream id */
+	snd_hda_codec_write(codec, nvhdmi_master_con_nid_7x, 0,
+			AC_VERB_SET_CHANNEL_STREAMID, (stream_tag << 4) | 0x0);
+
+	/* set the stream format */
+	snd_hda_codec_write(codec, nvhdmi_master_con_nid_7x, 0,
+			AC_VERB_SET_STREAM_FORMAT, format);
+
+	/* turn on again (if needed) */
+	/* enable and set the channel status audio/data flag */
+	if (codec->spdif_status_reset && (spdif->ctls & AC_DIG1_ENABLE)) {
+		snd_hda_codec_write(codec,
+				nvhdmi_master_con_nid_7x,
+				0,
+				AC_VERB_SET_DIGI_CONVERT_1,
+				spdif->ctls & 0xff);
+		snd_hda_codec_write(codec,
+				nvhdmi_master_con_nid_7x,
+				0,
+				AC_VERB_SET_DIGI_CONVERT_2, dataDCC2);
+	}
+
+	for (i = 0; i < 4; i++) {
+		if (chs == 2)
+			channel_id = 0;
+		else
+			channel_id = i * 2;
+
+		/* turn off SPDIF once;
+		 *otherwise the IEC958 bits won't be updated
+		 */
+		if (codec->spdif_status_reset &&
+		(spdif->ctls & AC_DIG1_ENABLE))
+			snd_hda_codec_write(codec,
+				nvhdmi_con_nids_7x[i],
+				0,
+				AC_VERB_SET_DIGI_CONVERT_1,
+				spdif->ctls & ~AC_DIG1_ENABLE & 0xff);
+		/* set the stream id */
+		snd_hda_codec_write(codec,
+				nvhdmi_con_nids_7x[i],
+				0,
+				AC_VERB_SET_CHANNEL_STREAMID,
+				(stream_tag << 4) | channel_id);
+		/* set the stream format */
+		snd_hda_codec_write(codec,
+				nvhdmi_con_nids_7x[i],
+				0,
+				AC_VERB_SET_STREAM_FORMAT,
+				format);
+		/* turn on again (if needed) */
+		/* enable and set the channel status audio/data flag */
+		if (codec->spdif_status_reset &&
+		(spdif->ctls & AC_DIG1_ENABLE)) {
+			snd_hda_codec_write(codec,
+					nvhdmi_con_nids_7x[i],
+					0,
+					AC_VERB_SET_DIGI_CONVERT_1,
+					spdif->ctls & 0xff);
+			snd_hda_codec_write(codec,
+					nvhdmi_con_nids_7x[i],
+					0,
+					AC_VERB_SET_DIGI_CONVERT_2, dataDCC2);
+		}
+	}
+
+	nvhdmi_8ch_7x_set_info_frame_parameters(codec, chs);
+
+	mutex_unlock(&codec->spdif_mutex);
+	return 0;
+}
+
+static const struct hda_pcm_stream nvhdmi_pcm_playback_8ch_7x = {
+	.substreams = 1,
+	.channels_min = 2,
+	.channels_max = 8,
+	.nid = nvhdmi_master_con_nid_7x,
+	.rates = SUPPORTED_RATES,
+	.maxbps = SUPPORTED_MAXBPS,
+	.formats = SUPPORTED_FORMATS,
+	.ops = {
+		.open = snd_hda_hdmi_simple_pcm_open,
+		.close = nvhdmi_8ch_7x_pcm_close,
+		.prepare = nvhdmi_8ch_7x_pcm_prepare
+	},
+};
+
+static int patch_nvhdmi_2ch(struct hda_codec *codec)
+{
+	struct hdmi_spec *spec;
+	int err = patch_simple_hdmi(codec, nvhdmi_master_con_nid_7x,
+				    nvhdmi_master_pin_nid_7x);
+	if (err < 0)
+		return err;
+
+	codec->patch_ops.init = nvhdmi_7x_init_2ch;
+	/* override the PCM rates, etc, as the codec doesn't give full list */
+	spec = codec->spec;
+	spec->pcm_playback.rates = SUPPORTED_RATES;
+	spec->pcm_playback.maxbps = SUPPORTED_MAXBPS;
+	spec->pcm_playback.formats = SUPPORTED_FORMATS;
+	spec->nv_dp_workaround = true;
+	return 0;
+}
+
+static int nvhdmi_7x_8ch_build_pcms(struct hda_codec *codec)
+{
+	struct hdmi_spec *spec = codec->spec;
+	int err;
+
+	err = snd_hda_hdmi_simple_build_pcms(codec);
+	if (!err) {
+		struct hda_pcm *info = get_pcm_rec(spec, 0);
+
+		info->own_chmap = true;
+	}
+	return err;
+}
+
+static int nvhdmi_7x_8ch_build_controls(struct hda_codec *codec)
+{
+	struct hdmi_spec *spec = codec->spec;
+	struct hda_pcm *info;
+	struct snd_pcm_chmap *chmap;
+	int err;
+
+	err = snd_hda_hdmi_simple_build_controls(codec);
+	if (err < 0)
+		return err;
+
+	/* add channel maps */
+	info = get_pcm_rec(spec, 0);
+	err = snd_pcm_add_chmap_ctls(info->pcm,
+				     SNDRV_PCM_STREAM_PLAYBACK,
+				     snd_pcm_alt_chmaps, 8, 0, &chmap);
+	if (err < 0)
+		return err;
+	switch (codec->preset->vendor_id) {
+	case 0x10de0002:
+	case 0x10de0003:
+	case 0x10de0005:
+	case 0x10de0006:
+		chmap->channel_mask = (1U << 2) | (1U << 8);
+		break;
+	case 0x10de0007:
+		chmap->channel_mask = (1U << 2) | (1U << 6) | (1U << 8);
+	}
+	return 0;
+}
+
+static const unsigned int channels_2_6_8[] = {
+	2, 6, 8
+};
+
+static const unsigned int channels_2_8[] = {
+	2, 8
+};
+
+static const struct snd_pcm_hw_constraint_list hw_constraints_2_6_8_channels = {
+	.count = ARRAY_SIZE(channels_2_6_8),
+	.list = channels_2_6_8,
+	.mask = 0,
+};
+
+static const struct snd_pcm_hw_constraint_list hw_constraints_2_8_channels = {
+	.count = ARRAY_SIZE(channels_2_8),
+	.list = channels_2_8,
+	.mask = 0,
+};
+
+static int patch_nvhdmi_8ch_7x(struct hda_codec *codec)
+{
+	struct hdmi_spec *spec;
+	int err;
+
+	err = patch_nvhdmi_2ch(codec);
+	if (err < 0)
+		return err;
+	spec = codec->spec;
+	spec->multiout.max_channels = 8;
+	spec->pcm_playback = nvhdmi_pcm_playback_8ch_7x;
+	codec->patch_ops.init = nvhdmi_7x_init_8ch;
+	codec->patch_ops.build_pcms = nvhdmi_7x_8ch_build_pcms;
+	codec->patch_ops.build_controls = nvhdmi_7x_8ch_build_controls;
+
+	switch (codec->preset->vendor_id) {
+	case 0x10de0002:
+	case 0x10de0003:
+	case 0x10de0005:
+	case 0x10de0006:
+		spec->hw_constraints_channels = &hw_constraints_2_8_channels;
+		break;
+	case 0x10de0007:
+		spec->hw_constraints_channels = &hw_constraints_2_6_8_channels;
+		break;
+	default:
+		break;
+	}
+
+	/* Initialize the audio infoframe channel mask and checksum to something
+	 * valid
+	 */
+	nvhdmi_8ch_7x_set_info_frame_parameters(codec, 8);
+
+	return 0;
+}
+
+/*
+ * patch entries
+ */
+static const struct hda_device_id snd_hda_id_nvhdmi_mcp[] = {
+HDA_CODEC_ENTRY(0x10de0001, "MCP73 HDMI",	patch_nvhdmi_2ch),
+HDA_CODEC_ENTRY(0x10de0002, "MCP77/78 HDMI",	patch_nvhdmi_8ch_7x),
+HDA_CODEC_ENTRY(0x10de0003, "MCP77/78 HDMI",	patch_nvhdmi_8ch_7x),
+HDA_CODEC_ENTRY(0x10de0004, "GPU 04 HDMI",	patch_nvhdmi_8ch_7x),
+HDA_CODEC_ENTRY(0x10de0005, "MCP77/78 HDMI",	patch_nvhdmi_8ch_7x),
+HDA_CODEC_ENTRY(0x10de0006, "MCP77/78 HDMI",	patch_nvhdmi_8ch_7x),
+HDA_CODEC_ENTRY(0x10de0007, "MCP79/7A HDMI",	patch_nvhdmi_8ch_7x),
+HDA_CODEC_ENTRY(0x10de0067, "MCP67 HDMI",	patch_nvhdmi_2ch),
+HDA_CODEC_ENTRY(0x10de8001, "MCP73 HDMI",	patch_nvhdmi_2ch),
+HDA_CODEC_ENTRY(0x10de8067, "MCP67/68 HDMI",	patch_nvhdmi_2ch),
+{} /* terminator */
+};
+MODULE_DEVICE_TABLE(hdaudio, snd_hda_id_nvhdmi_mcp);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Legacy Nvidia HDMI HD-audio codec");
+MODULE_IMPORT_NS(SND_HDA_CODEC_HDMI);
+
+static struct hda_codec_driver nvhdmi_mcp_driver = {
+	.id = snd_hda_id_nvhdmi_mcp,
+};
+
+module_hda_codec_driver(nvhdmi_mcp_driver);
--- /dev/null
+++ b/sound/hda/codecs/hdmi/nvhdmi.c
@@ -0,0 +1,218 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Nvidia HDMI codec support
+ */
+
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <sound/core.h>
+#include <sound/tlv.h>
+#include <sound/hdaudio.h>
+#include <sound/hda_codec.h>
+#include "hda_local.h"
+#include "hdmi_local.h"
+
+/*
+ * NVIDIA codecs ignore ASP mapping for 2ch - confirmed on:
+ * - 0x10de0015
+ * - 0x10de0040
+ */
+static int nvhdmi_chmap_cea_alloc_validate_get_type(struct hdac_chmap *chmap,
+		struct hdac_cea_channel_speaker_allocation *cap, int channels)
+{
+	if (cap->ca_index == 0x00 && channels == 2)
+		return SNDRV_CTL_TLVT_CHMAP_FIXED;
+
+	/* If the speaker allocation matches the channel count, it is OK. */
+	if (cap->channels != channels)
+		return -1;
+
+	/* all channels are remappable freely */
+	return SNDRV_CTL_TLVT_CHMAP_VAR;
+}
+
+static int nvhdmi_chmap_validate(struct hdac_chmap *chmap,
+		int ca, int chs, unsigned char *map)
+{
+	if (ca == 0x00 && (map[0] != SNDRV_CHMAP_FL || map[1] != SNDRV_CHMAP_FR))
+		return -EINVAL;
+
+	return 0;
+}
+
+/* map from pin NID to port; port is 0-based */
+/* for Nvidia: assume widget NID starting from 4, with step 1 (4, 5, 6, ...) */
+static int nvhdmi_pin2port(void *audio_ptr, int pin_nid)
+{
+	return pin_nid - 4;
+}
+
+/* reverse-map from port to pin NID: see above */
+static int nvhdmi_port2pin(struct hda_codec *codec, int port)
+{
+	return port + 4;
+}
+
+static const struct drm_audio_component_audio_ops nvhdmi_audio_ops = {
+	.pin2port = nvhdmi_pin2port,
+	.pin_eld_notify = snd_hda_hdmi_acomp_pin_eld_notify,
+	.master_bind = snd_hda_hdmi_acomp_master_bind,
+	.master_unbind = snd_hda_hdmi_acomp_master_unbind,
+};
+
+static int patch_nvhdmi(struct hda_codec *codec)
+{
+	struct hdmi_spec *spec;
+	int err;
+
+	err = snd_hda_hdmi_generic_alloc(codec);
+	if (err < 0)
+		return err;
+	codec->dp_mst = true;
+
+	spec = codec->spec;
+
+	err = snd_hda_hdmi_parse_codec(codec);
+	if (err < 0) {
+		snd_hda_hdmi_generic_spec_free(codec);
+		return err;
+	}
+
+	snd_hda_hdmi_generic_init_per_pins(codec);
+
+	spec->dyn_pin_out = true;
+
+	spec->chmap.ops.chmap_cea_alloc_validate_get_type =
+		nvhdmi_chmap_cea_alloc_validate_get_type;
+	spec->chmap.ops.chmap_validate = nvhdmi_chmap_validate;
+	spec->nv_dp_workaround = true;
+
+	codec->link_down_at_suspend = 1;
+
+	snd_hda_hdmi_acomp_init(codec, &nvhdmi_audio_ops, nvhdmi_port2pin);
+
+	return 0;
+}
+
+static int patch_nvhdmi_legacy(struct hda_codec *codec)
+{
+	struct hdmi_spec *spec;
+	int err;
+
+	err = patch_generic_hdmi(codec);
+	if (err)
+		return err;
+
+	spec = codec->spec;
+	spec->dyn_pin_out = true;
+
+	spec->chmap.ops.chmap_cea_alloc_validate_get_type =
+		nvhdmi_chmap_cea_alloc_validate_get_type;
+	spec->chmap.ops.chmap_validate = nvhdmi_chmap_validate;
+	spec->nv_dp_workaround = true;
+
+	codec->link_down_at_suspend = 1;
+
+	return 0;
+}
+
+/*
+ * patch entries
+ */
+static const struct hda_device_id snd_hda_id_nvhdmi[] = {
+HDA_CODEC_ENTRY(0x10de0008, "GPU 08 HDMI/DP",	patch_nvhdmi_legacy),
+HDA_CODEC_ENTRY(0x10de0009, "GPU 09 HDMI/DP",	patch_nvhdmi_legacy),
+HDA_CODEC_ENTRY(0x10de000a, "GPU 0a HDMI/DP",	patch_nvhdmi_legacy),
+HDA_CODEC_ENTRY(0x10de000b, "GPU 0b HDMI/DP",	patch_nvhdmi_legacy),
+HDA_CODEC_ENTRY(0x10de000c, "MCP89 HDMI",	patch_nvhdmi_legacy),
+HDA_CODEC_ENTRY(0x10de000d, "GPU 0d HDMI/DP",	patch_nvhdmi_legacy),
+HDA_CODEC_ENTRY(0x10de0010, "GPU 10 HDMI/DP",	patch_nvhdmi_legacy),
+HDA_CODEC_ENTRY(0x10de0011, "GPU 11 HDMI/DP",	patch_nvhdmi_legacy),
+HDA_CODEC_ENTRY(0x10de0012, "GPU 12 HDMI/DP",	patch_nvhdmi_legacy),
+HDA_CODEC_ENTRY(0x10de0013, "GPU 13 HDMI/DP",	patch_nvhdmi_legacy),
+HDA_CODEC_ENTRY(0x10de0014, "GPU 14 HDMI/DP",	patch_nvhdmi_legacy),
+HDA_CODEC_ENTRY(0x10de0015, "GPU 15 HDMI/DP",	patch_nvhdmi_legacy),
+HDA_CODEC_ENTRY(0x10de0016, "GPU 16 HDMI/DP",	patch_nvhdmi_legacy),
+/* 17 is known to be absent */
+HDA_CODEC_ENTRY(0x10de0018, "GPU 18 HDMI/DP",	patch_nvhdmi_legacy),
+HDA_CODEC_ENTRY(0x10de0019, "GPU 19 HDMI/DP",	patch_nvhdmi_legacy),
+HDA_CODEC_ENTRY(0x10de001a, "GPU 1a HDMI/DP",	patch_nvhdmi_legacy),
+HDA_CODEC_ENTRY(0x10de001b, "GPU 1b HDMI/DP",	patch_nvhdmi_legacy),
+HDA_CODEC_ENTRY(0x10de001c, "GPU 1c HDMI/DP",	patch_nvhdmi_legacy),
+HDA_CODEC_ENTRY(0x10de0040, "GPU 40 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de0041, "GPU 41 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de0042, "GPU 42 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de0043, "GPU 43 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de0044, "GPU 44 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de0045, "GPU 45 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de0050, "GPU 50 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de0051, "GPU 51 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de0052, "GPU 52 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de0060, "GPU 60 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de0061, "GPU 61 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de0062, "GPU 62 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de0070, "GPU 70 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de0071, "GPU 71 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de0072, "GPU 72 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de0073, "GPU 73 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de0074, "GPU 74 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de0076, "GPU 76 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de007b, "GPU 7b HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de007c, "GPU 7c HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de007d, "GPU 7d HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de007e, "GPU 7e HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de0080, "GPU 80 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de0081, "GPU 81 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de0082, "GPU 82 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de0083, "GPU 83 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de0084, "GPU 84 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de0090, "GPU 90 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de0091, "GPU 91 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de0092, "GPU 92 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de0093, "GPU 93 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de0094, "GPU 94 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de0095, "GPU 95 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de0097, "GPU 97 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de0098, "GPU 98 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de0099, "GPU 99 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de009a, "GPU 9a HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de009b, "GPU 9b HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de009c, "GPU 9c HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de009d, "GPU 9d HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de009e, "GPU 9e HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de009f, "GPU 9f HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de00a0, "GPU a0 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de00a1, "GPU a1 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de00a3, "GPU a3 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de00a4, "GPU a4 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de00a5, "GPU a5 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de00a6, "GPU a6 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de00a7, "GPU a7 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de00a8, "GPU a8 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de00a9, "GPU a9 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de00aa, "GPU aa HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de00ab, "GPU ab HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de00ad, "GPU ad HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de00ae, "GPU ae HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de00af, "GPU af HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de00b0, "GPU b0 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de00b1, "GPU b1 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de00c0, "GPU c0 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de00c1, "GPU c1 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de00c3, "GPU c3 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de00c4, "GPU c4 HDMI/DP",	patch_nvhdmi),
+HDA_CODEC_ENTRY(0x10de00c5, "GPU c5 HDMI/DP",	patch_nvhdmi),
+{} /* terminator */
+};
+MODULE_DEVICE_TABLE(hdaudio, snd_hda_id_nvhdmi);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Nvidia HDMI HD-audio codec");
+MODULE_IMPORT_NS(SND_HDA_CODEC_HDMI);
+
+static struct hda_codec_driver nvhdmi_driver = {
+	.id = snd_hda_id_nvhdmi,
+};
+
+module_hda_codec_driver(nvhdmi_driver);
--- /dev/null
+++ b/sound/hda/codecs/hdmi/simplehdmi.c
@@ -0,0 +1,241 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Non-generic simple HDMI codec support
+ */
+
+#include <linux/slab.h>
+#include <linux/module.h>
+#include "hdmi_local.h"
+#include "hda_jack.h"
+
+int snd_hda_hdmi_simple_build_pcms(struct hda_codec *codec)
+{
+	struct hdmi_spec *spec = codec->spec;
+	struct hda_pcm *info;
+	unsigned int chans;
+	struct hda_pcm_stream *pstr;
+	struct hdmi_spec_per_cvt *per_cvt;
+
+	per_cvt = get_cvt(spec, 0);
+	chans = get_wcaps(codec, per_cvt->cvt_nid);
+	chans = get_wcaps_channels(chans);
+
+	info = snd_hda_codec_pcm_new(codec, "HDMI 0");
+	if (!info)
+		return -ENOMEM;
+	spec->pcm_rec[0].pcm = info;
+	info->pcm_type = HDA_PCM_TYPE_HDMI;
+	pstr = &info->stream[SNDRV_PCM_STREAM_PLAYBACK];
+	*pstr = spec->pcm_playback;
+	pstr->nid = per_cvt->cvt_nid;
+	if (pstr->channels_max <= 2 && chans && chans <= 16)
+		pstr->channels_max = chans;
+
+	return 0;
+}
+EXPORT_SYMBOL_NS_GPL(snd_hda_hdmi_simple_build_pcms, SND_HDA_CODEC_HDMI);
+
+/* unsolicited event for jack sensing */
+void snd_hda_hdmi_simple_unsol_event(struct hda_codec *codec,
+				     unsigned int res)
+{
+	snd_hda_jack_set_dirty_all(codec);
+	snd_hda_jack_report_sync(codec);
+}
+EXPORT_SYMBOL_NS_GPL(snd_hda_hdmi_simple_unsol_event, SND_HDA_CODEC_HDMI);
+
+static void free_hdmi_jack_priv(struct snd_jack *jack)
+{
+	struct hdmi_pcm *pcm = jack->private_data;
+
+	pcm->jack = NULL;
+}
+
+static int simple_hdmi_build_jack(struct hda_codec *codec)
+{
+	char hdmi_str[32] = "HDMI/DP";
+	struct hdmi_spec *spec = codec->spec;
+	struct snd_jack *jack;
+	struct hdmi_pcm *pcmp = get_hdmi_pcm(spec, 0);
+	int pcmdev = pcmp->pcm->device;
+	int err;
+
+	if (pcmdev > 0)
+		sprintf(hdmi_str + strlen(hdmi_str), ",pcm=%d", pcmdev);
+
+	err = snd_jack_new(codec->card, hdmi_str, SND_JACK_AVOUT, &jack,
+			   true, false);
+	if (err < 0)
+		return err;
+
+	pcmp->jack = jack;
+	jack->private_data = pcmp;
+	jack->private_free = free_hdmi_jack_priv;
+	return 0;
+}
+
+int snd_hda_hdmi_simple_build_controls(struct hda_codec *codec)
+{
+	struct hdmi_spec *spec = codec->spec;
+	struct hdmi_spec_per_cvt *per_cvt;
+	int err;
+
+	per_cvt = get_cvt(spec, 0);
+	err = snd_hda_create_dig_out_ctls(codec, per_cvt->cvt_nid,
+					  per_cvt->cvt_nid,
+					  HDA_PCM_TYPE_HDMI);
+	if (err < 0)
+		return err;
+	return simple_hdmi_build_jack(codec);
+}
+EXPORT_SYMBOL_NS_GPL(snd_hda_hdmi_simple_build_controls, SND_HDA_CODEC_HDMI);
+
+int snd_hda_hdmi_simple_init(struct hda_codec *codec)
+{
+	struct hdmi_spec *spec = codec->spec;
+	struct hdmi_spec_per_pin *per_pin = get_pin(spec, 0);
+	hda_nid_t pin = per_pin->pin_nid;
+
+	snd_hda_codec_write(codec, pin, 0,
+			    AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT);
+	/* some codecs require to unmute the pin */
+	if (get_wcaps(codec, pin) & AC_WCAP_OUT_AMP)
+		snd_hda_codec_write(codec, pin, 0, AC_VERB_SET_AMP_GAIN_MUTE,
+				    AMP_OUT_UNMUTE);
+	snd_hda_jack_detect_enable(codec, pin, per_pin->dev_id);
+	return 0;
+}
+EXPORT_SYMBOL_NS_GPL(snd_hda_hdmi_simple_init, SND_HDA_CODEC_HDMI);
+
+void snd_hda_hdmi_simple_free(struct hda_codec *codec)
+{
+	struct hdmi_spec *spec = codec->spec;
+
+	snd_array_free(&spec->pins);
+	snd_array_free(&spec->cvts);
+	kfree(spec);
+}
+EXPORT_SYMBOL_NS_GPL(snd_hda_hdmi_simple_free, SND_HDA_CODEC_HDMI);
+
+int snd_hda_hdmi_simple_pcm_open(struct hda_pcm_stream *hinfo,
+				 struct hda_codec *codec,
+				 struct snd_pcm_substream *substream)
+{
+	struct hdmi_spec *spec = codec->spec;
+
+	if (spec->hw_constraints_channels) {
+		snd_pcm_hw_constraint_list(substream->runtime, 0,
+				SNDRV_PCM_HW_PARAM_CHANNELS,
+				spec->hw_constraints_channels);
+	} else {
+		snd_pcm_hw_constraint_step(substream->runtime, 0,
+					   SNDRV_PCM_HW_PARAM_CHANNELS, 2);
+	}
+
+	return snd_hda_multi_out_dig_open(codec, &spec->multiout);
+}
+EXPORT_SYMBOL_NS_GPL(snd_hda_hdmi_simple_pcm_open, SND_HDA_CODEC_HDMI);
+
+static int simple_playback_pcm_close(struct hda_pcm_stream *hinfo,
+				     struct hda_codec *codec,
+				     struct snd_pcm_substream *substream)
+{
+	struct hdmi_spec *spec = codec->spec;
+
+	return snd_hda_multi_out_dig_close(codec, &spec->multiout);
+}
+
+static int simple_playback_pcm_prepare(struct hda_pcm_stream *hinfo,
+				       struct hda_codec *codec,
+				       unsigned int stream_tag,
+				       unsigned int format,
+				       struct snd_pcm_substream *substream)
+{
+	struct hdmi_spec *spec = codec->spec;
+
+	return snd_hda_multi_out_dig_prepare(codec, &spec->multiout,
+					     stream_tag, format, substream);
+}
+
+static const struct hda_pcm_stream simple_pcm_playback = {
+	.substreams = 1,
+	.channels_min = 2,
+	.channels_max = 2,
+	.ops = {
+		.open = snd_hda_hdmi_simple_pcm_open,
+		.close = simple_playback_pcm_close,
+		.prepare = simple_playback_pcm_prepare
+	},
+};
+
+static const struct hda_codec_ops simple_hdmi_patch_ops = {
+	.build_controls = snd_hda_hdmi_simple_build_controls,
+	.build_pcms = snd_hda_hdmi_simple_build_pcms,
+	.init = snd_hda_hdmi_simple_init,
+	.free = snd_hda_hdmi_simple_free,
+	.unsol_event = snd_hda_hdmi_simple_unsol_event,
+};
+
+int patch_simple_hdmi(struct hda_codec *codec,
+		      hda_nid_t cvt_nid, hda_nid_t pin_nid)
+{
+	struct hdmi_spec *spec;
+	struct hdmi_spec_per_cvt *per_cvt;
+	struct hdmi_spec_per_pin *per_pin;
+
+	spec = kzalloc(sizeof(*spec), GFP_KERNEL);
+	if (!spec)
+		return -ENOMEM;
+
+	spec->codec = codec;
+	codec->spec = spec;
+	snd_array_init(&spec->pins, sizeof(struct hdmi_spec_per_pin), 1);
+	snd_array_init(&spec->cvts, sizeof(struct hdmi_spec_per_cvt), 1);
+
+	spec->multiout.num_dacs = 0;  /* no analog */
+	spec->multiout.max_channels = 2;
+	spec->multiout.dig_out_nid = cvt_nid;
+	spec->num_cvts = 1;
+	spec->num_pins = 1;
+	per_pin = snd_array_new(&spec->pins);
+	per_cvt = snd_array_new(&spec->cvts);
+	if (!per_pin || !per_cvt) {
+		snd_hda_hdmi_simple_free(codec);
+		return -ENOMEM;
+	}
+	per_cvt->cvt_nid = cvt_nid;
+	per_pin->pin_nid = pin_nid;
+	spec->pcm_playback = simple_pcm_playback;
+
+	codec->patch_ops = simple_hdmi_patch_ops;
+
+	return 0;
+}
+EXPORT_SYMBOL_NS_GPL(patch_simple_hdmi, SND_HDA_CODEC_HDMI);
+
+/* VIA HDMI Implementation */
+#define VIAHDMI_CVT_NID	0x02	/* audio converter1 */
+#define VIAHDMI_PIN_NID	0x03	/* HDMI output pin1 */
+
+static int patch_via_hdmi(struct hda_codec *codec)
+{
+	return patch_simple_hdmi(codec, VIAHDMI_CVT_NID, VIAHDMI_PIN_NID);
+}
+
+/*
+ * patch entries
+ */
+static const struct hda_device_id snd_hda_id_simplehdmi[] = {
+HDA_CODEC_ENTRY(0x11069f80, "VX900 HDMI/DP",	patch_via_hdmi),
+HDA_CODEC_ENTRY(0x11069f81, "VX900 HDMI/DP",	patch_via_hdmi),
+{} /* terminator */
+};
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Simple HDMI HD-audio codec support");
+
+static struct hda_codec_driver simplehdmi_driver = {
+	.id = snd_hda_id_simplehdmi,
+};
+
+module_hda_codec_driver(simplehdmi_driver);
--- /dev/null
+++ b/sound/hda/codecs/hdmi/tegrahdmi.c
@@ -0,0 +1,313 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Nvidia Tegra HDMI codec support
+ */
+
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <sound/core.h>
+#include <sound/tlv.h>
+#include <sound/hdaudio.h>
+#include <sound/hda_codec.h>
+#include "hda_local.h"
+#include "hdmi_local.h"
+
+/*
+ * The HDA codec on NVIDIA Tegra contains two scratch registers that are
+ * accessed using vendor-defined verbs. These registers can be used for
+ * interoperability between the HDA and HDMI drivers.
+ */
+
+/* Audio Function Group node */
+#define NVIDIA_AFG_NID 0x01
+
+/*
+ * The SCRATCH0 register is used to notify the HDMI codec of changes in audio
+ * format. On Tegra, bit 31 is used as a trigger that causes an interrupt to
+ * be raised in the HDMI codec. The remainder of the bits is arbitrary. This
+ * implementation stores the HDA format (see AC_FMT_*) in bits [15:0] and an
+ * additional bit (at position 30) to signal the validity of the format.
+ *
+ * | 31      | 30    | 29  16 | 15   0 |
+ * +---------+-------+--------+--------+
+ * | TRIGGER | VALID | UNUSED | FORMAT |
+ * +-----------------------------------|
+ *
+ * Note that for the trigger bit to take effect it needs to change value
+ * (i.e. it needs to be toggled). The trigger bit is not applicable from
+ * TEGRA234 chip onwards, as new verb id 0xf80 will be used for interrupt
+ * trigger to hdmi.
+ */
+#define NVIDIA_SET_HOST_INTR		0xf80
+#define NVIDIA_GET_SCRATCH0		0xfa6
+#define NVIDIA_SET_SCRATCH0_BYTE0	0xfa7
+#define NVIDIA_SET_SCRATCH0_BYTE1	0xfa8
+#define NVIDIA_SET_SCRATCH0_BYTE2	0xfa9
+#define NVIDIA_SET_SCRATCH0_BYTE3	0xfaa
+#define NVIDIA_SCRATCH_TRIGGER (1 << 7)
+#define NVIDIA_SCRATCH_VALID   (1 << 6)
+
+#define NVIDIA_GET_SCRATCH1		0xfab
+#define NVIDIA_SET_SCRATCH1_BYTE0	0xfac
+#define NVIDIA_SET_SCRATCH1_BYTE1	0xfad
+#define NVIDIA_SET_SCRATCH1_BYTE2	0xfae
+#define NVIDIA_SET_SCRATCH1_BYTE3	0xfaf
+
+/*
+ * The format parameter is the HDA audio format (see AC_FMT_*). If set to 0,
+ * the format is invalidated so that the HDMI codec can be disabled.
+ */
+static void tegra_hdmi_set_format(struct hda_codec *codec,
+				  hda_nid_t cvt_nid,
+				  unsigned int format)
+{
+	unsigned int value;
+	unsigned int nid = NVIDIA_AFG_NID;
+	struct hdmi_spec *spec = codec->spec;
+
+	/*
+	 * Tegra HDA codec design from TEGRA234 chip onwards support DP MST.
+	 * This resulted in moving scratch registers from audio function
+	 * group to converter widget context. So CVT NID should be used for
+	 * scratch register read/write for DP MST supported Tegra HDA codec.
+	 */
+	if (codec->dp_mst)
+		nid = cvt_nid;
+
+	/* bits [31:30] contain the trigger and valid bits */
+	value = snd_hda_codec_read(codec, nid, 0,
+				   NVIDIA_GET_SCRATCH0, 0);
+	value = (value >> 24) & 0xff;
+
+	/* bits [15:0] are used to store the HDA format */
+	snd_hda_codec_write(codec, nid, 0,
+			    NVIDIA_SET_SCRATCH0_BYTE0,
+			    (format >> 0) & 0xff);
+	snd_hda_codec_write(codec, nid, 0,
+			    NVIDIA_SET_SCRATCH0_BYTE1,
+			    (format >> 8) & 0xff);
+
+	/* bits [16:24] are unused */
+	snd_hda_codec_write(codec, nid, 0,
+			    NVIDIA_SET_SCRATCH0_BYTE2, 0);
+
+	/*
+	 * Bit 30 signals that the data is valid and hence that HDMI audio can
+	 * be enabled.
+	 */
+	if (format == 0)
+		value &= ~NVIDIA_SCRATCH_VALID;
+	else
+		value |= NVIDIA_SCRATCH_VALID;
+
+	if (spec->hdmi_intr_trig_ctrl) {
+		/*
+		 * For Tegra HDA Codec design from TEGRA234 onwards, the
+		 * Interrupt to hdmi driver is triggered by writing
+		 * non-zero values to verb 0xF80 instead of 31st bit of
+		 * scratch register.
+		 */
+		snd_hda_codec_write(codec, nid, 0,
+				NVIDIA_SET_SCRATCH0_BYTE3, value);
+		snd_hda_codec_write(codec, nid, 0,
+				NVIDIA_SET_HOST_INTR, 0x1);
+	} else {
+		/*
+		 * Whenever the 31st trigger bit is toggled, an interrupt is raised
+		 * in the HDMI codec. The HDMI driver will use that as trigger
+		 * to update its configuration.
+		 */
+		value ^= NVIDIA_SCRATCH_TRIGGER;
+
+		snd_hda_codec_write(codec, nid, 0,
+				NVIDIA_SET_SCRATCH0_BYTE3, value);
+	}
+}
+
+static int tegra_hdmi_pcm_prepare(struct hda_pcm_stream *hinfo,
+				  struct hda_codec *codec,
+				  unsigned int stream_tag,
+				  unsigned int format,
+				  struct snd_pcm_substream *substream)
+{
+	int err;
+
+	err = snd_hda_hdmi_generic_pcm_prepare(hinfo, codec, stream_tag,
+					       format, substream);
+	if (err < 0)
+		return err;
+
+	/* notify the HDMI codec of the format change */
+	tegra_hdmi_set_format(codec, hinfo->nid, format);
+
+	return 0;
+}
+
+static int tegra_hdmi_pcm_cleanup(struct hda_pcm_stream *hinfo,
+				  struct hda_codec *codec,
+				  struct snd_pcm_substream *substream)
+{
+	/* invalidate the format in the HDMI codec */
+	tegra_hdmi_set_format(codec, hinfo->nid, 0);
+
+	return snd_hda_hdmi_generic_pcm_cleanup(hinfo, codec, substream);
+}
+
+static struct hda_pcm *hda_find_pcm_by_type(struct hda_codec *codec, int type)
+{
+	struct hdmi_spec *spec = codec->spec;
+	unsigned int i;
+
+	for (i = 0; i < spec->num_pins; i++) {
+		struct hda_pcm *pcm = get_pcm_rec(spec, i);
+
+		if (pcm->pcm_type == type)
+			return pcm;
+	}
+
+	return NULL;
+}
+
+static int tegra_hdmi_build_pcms(struct hda_codec *codec)
+{
+	struct hda_pcm_stream *stream;
+	struct hda_pcm *pcm;
+	int err;
+
+	err = snd_hda_hdmi_generic_build_pcms(codec);
+	if (err < 0)
+		return err;
+
+	pcm = hda_find_pcm_by_type(codec, HDA_PCM_TYPE_HDMI);
+	if (!pcm)
+		return -ENODEV;
+
+	/*
+	 * Override ->prepare() and ->cleanup() operations to notify the HDMI
+	 * codec about format changes.
+	 */
+	stream = &pcm->stream[SNDRV_PCM_STREAM_PLAYBACK];
+	stream->ops.prepare = tegra_hdmi_pcm_prepare;
+	stream->ops.cleanup = tegra_hdmi_pcm_cleanup;
+
+	return 0;
+}
+
+/*
+ * NVIDIA codecs ignore ASP mapping for 2ch - confirmed on:
+ * - 0x10de0015
+ * - 0x10de0040
+ */
+static int nvhdmi_chmap_cea_alloc_validate_get_type(struct hdac_chmap *chmap,
+		struct hdac_cea_channel_speaker_allocation *cap, int channels)
+{
+	if (cap->ca_index == 0x00 && channels == 2)
+		return SNDRV_CTL_TLVT_CHMAP_FIXED;
+
+	/* If the speaker allocation matches the channel count, it is OK. */
+	if (cap->channels != channels)
+		return -1;
+
+	/* all channels are remappable freely */
+	return SNDRV_CTL_TLVT_CHMAP_VAR;
+}
+
+static int nvhdmi_chmap_validate(struct hdac_chmap *chmap,
+		int ca, int chs, unsigned char *map)
+{
+	if (ca == 0x00 && (map[0] != SNDRV_CHMAP_FL || map[1] != SNDRV_CHMAP_FR))
+		return -EINVAL;
+
+	return 0;
+}
+
+static int tegra_hdmi_init(struct hda_codec *codec)
+{
+	struct hdmi_spec *spec = codec->spec;
+	int i, err;
+
+	err = snd_hda_hdmi_parse_codec(codec);
+	if (err < 0) {
+		snd_hda_hdmi_generic_spec_free(codec);
+		return err;
+	}
+
+	for (i = 0; i < spec->num_cvts; i++)
+		snd_hda_codec_write(codec, spec->cvt_nids[i], 0,
+					AC_VERB_SET_DIGI_CONVERT_1,
+					AC_DIG1_ENABLE);
+
+	snd_hda_hdmi_generic_init_per_pins(codec);
+
+	codec->depop_delay = 10;
+	codec->patch_ops.build_pcms = tegra_hdmi_build_pcms;
+	spec->chmap.ops.chmap_cea_alloc_validate_get_type =
+		nvhdmi_chmap_cea_alloc_validate_get_type;
+	spec->chmap.ops.chmap_validate = nvhdmi_chmap_validate;
+
+	spec->chmap.ops.chmap_cea_alloc_validate_get_type =
+		nvhdmi_chmap_cea_alloc_validate_get_type;
+	spec->chmap.ops.chmap_validate = nvhdmi_chmap_validate;
+	spec->nv_dp_workaround = true;
+
+	return 0;
+}
+
+static int patch_tegra_hdmi(struct hda_codec *codec)
+{
+	int err;
+
+	err = snd_hda_hdmi_generic_alloc(codec);
+	if (err < 0)
+		return err;
+
+	return tegra_hdmi_init(codec);
+}
+
+static int patch_tegra234_hdmi(struct hda_codec *codec)
+{
+	struct hdmi_spec *spec;
+	int err;
+
+	err = snd_hda_hdmi_generic_alloc(codec);
+	if (err < 0)
+		return err;
+
+	codec->dp_mst = true;
+	spec = codec->spec;
+	spec->dyn_pin_out = true;
+	spec->hdmi_intr_trig_ctrl = true;
+
+	return tegra_hdmi_init(codec);
+}
+
+/*
+ * patch entries
+ */
+static const struct hda_device_id snd_hda_id_tegrahdmi[] = {
+HDA_CODEC_ENTRY(0x10de0020, "Tegra30 HDMI",	patch_tegra_hdmi),
+HDA_CODEC_ENTRY(0x10de0022, "Tegra114 HDMI",	patch_tegra_hdmi),
+HDA_CODEC_ENTRY(0x10de0028, "Tegra124 HDMI",	patch_tegra_hdmi),
+HDA_CODEC_ENTRY(0x10de0029, "Tegra210 HDMI/DP",	patch_tegra_hdmi),
+HDA_CODEC_ENTRY(0x10de002d, "Tegra186 HDMI/DP0", patch_tegra_hdmi),
+HDA_CODEC_ENTRY(0x10de002e, "Tegra186 HDMI/DP1", patch_tegra_hdmi),
+HDA_CODEC_ENTRY(0x10de002f, "Tegra194 HDMI/DP2", patch_tegra_hdmi),
+HDA_CODEC_ENTRY(0x10de0030, "Tegra194 HDMI/DP3", patch_tegra_hdmi),
+HDA_CODEC_ENTRY(0x10de0031, "Tegra234 HDMI/DP", patch_tegra234_hdmi),
+HDA_CODEC_ENTRY(0x10de0033, "SoC 33 HDMI/DP",	patch_tegra234_hdmi),
+HDA_CODEC_ENTRY(0x10de0034, "Tegra264 HDMI/DP",	patch_tegra234_hdmi),
+HDA_CODEC_ENTRY(0x10de0035, "SoC 35 HDMI/DP",	patch_tegra234_hdmi),
+{} /* terminator */
+};
+MODULE_DEVICE_TABLE(hdaudio, snd_hda_id_tegrahdmi);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Nvidia Tegra HDMI HD-audio codec");
+MODULE_IMPORT_NS(SND_HDA_CODEC_HDMI);
+
+static struct hda_codec_driver tegrahdmi_driver = {
+	.id = snd_hda_id_tegrahdmi,
+};
+
+module_hda_codec_driver(tegrahdmi_driver);
--- a/sound/hda/common/hda_local.h
+++ b/sound/hda/common/hda_local.h
@@ -689,10 +689,6 @@ int snd_hdmi_get_eld(struct hda_codec *c
 void snd_hdmi_eld_update_pcm_info(struct snd_parsed_hdmi_eld *e,
 			      struct hda_pcm_stream *hinfo);
 
-int snd_hdmi_get_eld_ati(struct hda_codec *codec, hda_nid_t nid,
-			 unsigned char *buf, int *eld_size,
-			 bool rev3_or_later);
-
 #ifdef CONFIG_SND_PROC_FS
 void snd_hdmi_print_eld_info(struct hdmi_eld *eld,
 			     struct snd_info_buffer *buffer,

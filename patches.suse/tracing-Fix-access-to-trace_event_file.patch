From b3c2065361a7f768a52977ac953b905e3d64fb29 Mon Sep 17 00:00:00 2001
From: Petr Pavlu <petr.pavlu@suse.com>
Date: Tue, 16 Dec 2025 10:24:08 +0100
Subject: tracing: Fix access to trace_event_file
Patch-mainline: Never, SLE-specific fix
References: bsc#1254373

When a trace event directory is removed by remove_event_file_dir(), the
function sets inode->i_private to NULL for all child entries. This can lead
to a NULL pointer dereference in tracing_open_file_tr() and
tracing_release_file_tr() if they are invoked afterward.

To prevent this crash, check if inode->i_private is NULL in
tracing_open_file_tr(), and use filp->private_data in
tracing_release_file_tr() to obtain the actual trace_event_file. For the
hist and hist_debug files, which use seq_files, store the trace_event_file
pointer in seq_file->private, allowing it to be accessed in
tracing_single_release_file_tr().

The patch addresses the same race condition that was resolved upstream by
commit b63db58e2fa5 ("eventfs/tracing: Add callback for release of an
eventfs_inode"). However, that commit relies on the new eventfs code, which
is not suitable for backporting to SLE15. Therefore, this alternative fix
is provided.

Signed-off-by: Petr Pavlu <petr.pavlu@suse.com>
---
 kernel/trace/trace.c             | 44 ++++++++++++++++++++++----------
 kernel/trace/trace.h             |  1 +
 kernel/trace/trace_events_hist.c | 18 ++++++++-----
 3 files changed, 43 insertions(+), 20 deletions(-)

diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c
index aec996e6465c0..70cb7a091b3da 100644
--- a/kernel/trace/trace.c
+++ b/kernel/trace/trace.c
@@ -4962,45 +4962,61 @@ int tracing_open_generic_tr(struct inode *inode, struct file *filp)
  */
 int tracing_open_file_tr(struct inode *inode, struct file *filp)
 {
-	struct trace_event_file *file = inode->i_private;
+	struct trace_event_file *file;
 	int ret;
 
+	mutex_lock(&event_mutex);
+
+	file = inode->i_private;
+
+	/* Fail if the file was already removed by remove_event_file_dir(). */
+	if (file == NULL) {
+		ret = -ENODEV;
+		goto out;
+	}
+
 	ret = tracing_check_open_get_tr(file->tr);
 	if (ret)
-		return ret;
-
-	mutex_lock(&event_mutex);
+		goto out;
 
 	/* Fail if the file is marked for removal */
 	if (file->flags & EVENT_FILE_FL_FREED) {
 		trace_array_put(file->tr);
 		ret = -ENODEV;
-	} else {
-		event_file_get(file);
+		goto out;
 	}
 
+	event_file_get(file);
+	filp->private_data = file;
+
+out:
 	mutex_unlock(&event_mutex);
-	if (ret)
-		return ret;
 
-	filp->private_data = inode->i_private;
+	return ret;
+}
 
-	return 0;
+void tracing_release_event_file_tr(struct trace_event_file *file)
+{
+	trace_array_put(file->tr);
+	event_file_put(file);
 }
 
 int tracing_release_file_tr(struct inode *inode, struct file *filp)
 {
-	struct trace_event_file *file = inode->i_private;
+	struct trace_event_file *file = filp->private_data;
 
-	trace_array_put(file->tr);
-	event_file_put(file);
+	tracing_release_event_file_tr(file);
 
 	return 0;
 }
 
 int tracing_single_release_file_tr(struct inode *inode, struct file *filp)
 {
-	tracing_release_file_tr(inode, filp);
+	struct trace_event_file *file =
+		((struct seq_file *)filp->private_data)->private;
+
+	tracing_release_event_file_tr(file);
+
 	return single_release(inode, filp);
 }
 
diff --git a/kernel/trace/trace.h b/kernel/trace/trace.h
index 1a2b96a57ca5f..cc893f71a065b 100644
--- a/kernel/trace/trace.h
+++ b/kernel/trace/trace.h
@@ -596,6 +596,7 @@ void tracing_reset_all_online_cpus(void);
 void tracing_reset_all_online_cpus_unlocked(void);
 int tracing_open_generic(struct inode *inode, struct file *filp);
 int tracing_open_generic_tr(struct inode *inode, struct file *filp);
+void tracing_release_event_file_tr(struct trace_event_file *file);
 int tracing_open_file_tr(struct inode *inode, struct file *filp);
 int tracing_release_file_tr(struct inode *inode, struct file *filp);
 int tracing_single_release_file_tr(struct inode *inode, struct file *filp);
diff --git a/kernel/trace/trace_events_hist.c b/kernel/trace/trace_events_hist.c
index d1760afe85c3d..ac5df9c40f7f1 100644
--- a/kernel/trace/trace_events_hist.c
+++ b/kernel/trace/trace_events_hist.c
@@ -5609,7 +5609,7 @@ static int hist_show(struct seq_file *m, void *v)
 
 	mutex_lock(&event_mutex);
 
-	event_file = event_file_data(m->private);
+	event_file = m->private;
 	if (unlikely(!event_file)) {
 		ret = -ENODEV;
 		goto out_unlock;
@@ -5628,17 +5628,20 @@ static int hist_show(struct seq_file *m, void *v)
 
 static int event_hist_open(struct inode *inode, struct file *file)
 {
+	struct trace_event_file *event_file;
 	int ret;
 
 	ret = tracing_open_file_tr(inode, file);
 	if (ret)
 		return ret;
 
+	event_file = file->private_data;
+
 	/* Clear private_data to avoid warning in single_open() */
 	file->private_data = NULL;
-	ret = single_open(file, hist_show, file);
+	ret = single_open(file, hist_show, event_file);
 	if (ret)
-		tracing_release_file_tr(inode, file);
+		tracing_release_event_file_tr(event_file);
 	return ret;
 }
 
@@ -5891,7 +5894,7 @@ static int hist_debug_show(struct seq_file *m, void *v)
 
 	mutex_lock(&event_mutex);
 
-	event_file = event_file_data(m->private);
+	event_file = m->private;
 	if (unlikely(!event_file)) {
 		ret = -ENODEV;
 		goto out_unlock;
@@ -5910,17 +5913,20 @@ static int hist_debug_show(struct seq_file *m, void *v)
 
 static int event_hist_debug_open(struct inode *inode, struct file *file)
 {
+	struct trace_event_file *event_file;
 	int ret;
 
 	ret = tracing_open_file_tr(inode, file);
 	if (ret)
 		return ret;
 
+	event_file = file->private_data;
+
 	/* Clear private_data to avoid warning in single_open() */
 	file->private_data = NULL;
-	ret = single_open(file, hist_debug_show, file);
+	ret = single_open(file, hist_debug_show, event_file);
 	if (ret)
-		tracing_release_file_tr(inode, file);
+		tracing_release_event_file_tr(event_file);
 	return ret;
 }
 

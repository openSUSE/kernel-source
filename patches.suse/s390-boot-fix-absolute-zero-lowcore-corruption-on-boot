From: Alexander Gordeev <agordeev@linux.ibm.com>
Date: Sat, 13 Aug 2022 19:45:21 +0200
Subject: s390/boot: fix absolute zero lowcore corruption on boot
Git-commit: 12dd19c159659ec9050f45dc8a2ff3c3917f4be3
Patch-mainline: v6.0-rc5
References: git-fixes

Crash dump always starts on CPU0. In case CPU0 is offline the
prefix page is not installed and the absolute zero lowcore is
used. However, struct lowcore::mcesad is never assigned and
stays zero. That leads to __machine_kdump() -> save_vx_regs()
call silently stores vector registers to the absolute lowcore
at 0x11b0 offset.

Fixes: a62bc0739253 ("s390/kdump: add support for vector extension")
Reviewed-by: Heiko Carstens <hca@linux.ibm.com>
Signed-off-by: Alexander Gordeev <agordeev@linux.ibm.com>
Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
[ ptesarik: Reworked absolute lowcore accessors, because SLE15-SP3
  lacks upstream commit ed0192bc644f3553d64a5cb461bdd0b1fbae3fdf. ]
Signed-off-by: Petr Tesarik <ptesarik@suse.com>
---
 arch/s390/kernel/nmi.c   |    2 +-
 arch/s390/kernel/setup.c |    1 +
 2 files changed, 2 insertions(+), 1 deletion(-)

--- a/arch/s390/kernel/nmi.c
+++ b/arch/s390/kernel/nmi.c
@@ -62,7 +62,7 @@ static inline unsigned long nmi_get_mces
  * The structure is required for machine check happening early in
  * the boot process.
  */
-static struct mcesa boot_mcesa __initdata __aligned(MCESA_MAX_SIZE);
+static struct mcesa boot_mcesa __aligned(MCESA_MAX_SIZE);
 
 void __init nmi_alloc_boot_cpu(struct lowcore *lc)
 {
--- a/arch/s390/kernel/setup.c
+++ b/arch/s390/kernel/setup.c
@@ -452,6 +452,7 @@ static void __init setup_lowcore_dat_off
 	mem_assign_absolute(S390_lowcore.restart_data, lc->restart_data);
 	mem_assign_absolute(S390_lowcore.restart_source, lc->restart_source);
 	mem_assign_absolute(S390_lowcore.restart_psw, lc->restart_psw);
+	mem_assign_absolute(S390_lowcore.mcesad, lc->mcesad);
 
 	lc->spinlock_lockval = arch_spin_lockval(0);
 	lc->spinlock_index = 0;

From b3bfd0c98fcdc28bf28e3945c9d1176758fdd4a1 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ville=20Syrj=C3=A4l=C3=A4?= <ville.syrjala@linux.intel.com>
Date: Tue, 8 Jun 2021 10:35:47 +0300
Subject: drm/i915: s/intel/hsw/ for hsw/bdw/skl buf trans
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Git-commit: 266152ae61f762258706afa1046c931e5cf19d78
Patch-mainline: v5.15-rc1
References: jsc#PED-1166 jsc#PED-1168 jsc#PED-1170 jsc#PED-1218 jsc#PED-1220 jsc#PED-1222 jsc#PED-1223 jsc#PED-1225

Give the hsw/bdw/skl buf trans stuff a better namespace.

Reviewed-by: Jani Nikula <jani.nikula@intel.com>
Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20210608073603.2408-2-ville.syrjala@linux.intel.com
Acked-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 drivers/gpu/drm/i915/display/intel_ddi.c      | 39 +++++----
 drivers/gpu/drm/i915/display/intel_ddi.h      |  4 +-
 .../drm/i915/display/intel_ddi_buf_trans.c    | 79 +++++++++----------
 .../drm/i915/display/intel_ddi_buf_trans.h    | 20 +++--
 drivers/gpu/drm/i915/display/intel_fdi.c      |  4 +-
 5 files changed, 70 insertions(+), 76 deletions(-)

diff --git a/drivers/gpu/drm/i915/display/intel_ddi.c b/drivers/gpu/drm/i915/display/intel_ddi.c
index 5ee724b4c0b3..94983677214e 100644
--- a/drivers/gpu/drm/i915/display/intel_ddi.c
+++ b/drivers/gpu/drm/i915/display/intel_ddi.c
@@ -95,24 +95,21 @@ static int intel_ddi_hdmi_level(struct intel_encoder *encoder,
  * values in advance. This function programs the correct values for
  * DP/eDP/FDI use cases.
  */
-void intel_prepare_dp_ddi_buffers(struct intel_encoder *encoder,
-				  const struct intel_crtc_state *crtc_state)
+void hsw_prepare_dp_ddi_buffers(struct intel_encoder *encoder,
+				const struct intel_crtc_state *crtc_state)
 {
 	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
 	u32 iboost_bit = 0;
 	int i, n_entries;
 	enum port port = encoder->port;
-	const struct ddi_buf_trans *ddi_translations;
+	const struct hsw_ddi_buf_trans *ddi_translations;
 
 	if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_ANALOG))
-		ddi_translations = intel_ddi_get_buf_trans_fdi(dev_priv,
-							       &n_entries);
+		ddi_translations = hsw_ddi_get_buf_trans_fdi(dev_priv, &n_entries);
 	else if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_EDP))
-		ddi_translations = intel_ddi_get_buf_trans_edp(encoder,
-							       &n_entries);
+		ddi_translations = hsw_ddi_get_buf_trans_edp(encoder, &n_entries);
 	else
-		ddi_translations = intel_ddi_get_buf_trans_dp(encoder,
-							      &n_entries);
+		ddi_translations = hsw_ddi_get_buf_trans_dp(encoder, &n_entries);
 
 	/* If we're boosting the current, set bit 31 of trans1 */
 	if (DISPLAY_VER(dev_priv) == 9 && !IS_BROXTON(dev_priv) &&
@@ -132,16 +129,16 @@ void intel_prepare_dp_ddi_buffers(struct intel_encoder *encoder,
  * values in advance. This function programs the correct values for
  * HDMI/DVI use cases.
  */
-static void intel_prepare_hdmi_ddi_buffers(struct intel_encoder *encoder,
-					   int level)
+static void hsw_prepare_hdmi_ddi_buffers(struct intel_encoder *encoder,
+					 int level)
 {
 	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
 	u32 iboost_bit = 0;
 	int n_entries;
 	enum port port = encoder->port;
-	const struct ddi_buf_trans *ddi_translations;
+	const struct hsw_ddi_buf_trans *ddi_translations;
 
-	ddi_translations = intel_ddi_get_buf_trans_hdmi(encoder, &n_entries);
+	ddi_translations = hsw_ddi_get_buf_trans_hdmi(encoder, &n_entries);
 
 	if (drm_WARN_ON_ONCE(&dev_priv->drm, !ddi_translations))
 		return;
@@ -948,15 +945,15 @@ static void skl_ddi_set_iboost(struct intel_encoder *encoder,
 		iboost = intel_bios_encoder_dp_boost_level(encoder->devdata);
 
 	if (iboost == 0) {
-		const struct ddi_buf_trans *ddi_translations;
+		const struct hsw_ddi_buf_trans *ddi_translations;
 		int n_entries;
 
 		if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI))
-			ddi_translations = intel_ddi_get_buf_trans_hdmi(encoder, &n_entries);
+			ddi_translations = hsw_ddi_get_buf_trans_hdmi(encoder, &n_entries);
 		else if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_EDP))
-			ddi_translations = intel_ddi_get_buf_trans_edp(encoder, &n_entries);
+			ddi_translations = hsw_ddi_get_buf_trans_edp(encoder, &n_entries);
 		else
-			ddi_translations = intel_ddi_get_buf_trans_dp(encoder, &n_entries);
+			ddi_translations = hsw_ddi_get_buf_trans_dp(encoder, &n_entries);
 
 		if (drm_WARN_ON_ONCE(&dev_priv->drm, !ddi_translations))
 			return;
@@ -1031,9 +1028,9 @@ static u8 intel_ddi_dp_voltage_max(struct intel_dp *intel_dp,
 		bxt_get_buf_trans(encoder, crtc_state, &n_entries);
 	} else {
 		if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_EDP))
-			intel_ddi_get_buf_trans_edp(encoder, &n_entries);
+			hsw_ddi_get_buf_trans_edp(encoder, &n_entries);
 		else
-			intel_ddi_get_buf_trans_dp(encoder, &n_entries);
+			hsw_ddi_get_buf_trans_dp(encoder, &n_entries);
 	}
 
 	if (drm_WARN_ON(&dev_priv->drm, n_entries < 1))
@@ -2719,7 +2716,7 @@ static void hsw_ddi_pre_enable_dp(struct intel_atomic_state *state,
 	else if (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv))
 		bxt_ddi_vswing_sequence(encoder, crtc_state, level);
 	else
-		intel_prepare_dp_ddi_buffers(encoder, crtc_state);
+		hsw_prepare_dp_ddi_buffers(encoder, crtc_state);
 
 	intel_ddi_power_up_lanes(encoder, crtc_state);
 
@@ -3167,7 +3164,7 @@ static void intel_enable_ddi_hdmi(struct intel_atomic_state *state,
 	else if (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv))
 		bxt_ddi_vswing_sequence(encoder, crtc_state, level);
 	else
-		intel_prepare_hdmi_ddi_buffers(encoder, level);
+		hsw_prepare_hdmi_ddi_buffers(encoder, level);
 
 	if (DISPLAY_VER(dev_priv) == 9 && !IS_BROXTON(dev_priv))
 		skl_ddi_set_iboost(encoder, crtc_state, level);
diff --git a/drivers/gpu/drm/i915/display/intel_ddi.h b/drivers/gpu/drm/i915/display/intel_ddi.h
index 59c6b01d4199..7d448485d887 100644
--- a/drivers/gpu/drm/i915/display/intel_ddi.h
+++ b/drivers/gpu/drm/i915/display/intel_ddi.h
@@ -40,8 +40,8 @@ bool hsw_ddi_is_clock_enabled(struct intel_encoder *encoder);
 void hsw_ddi_get_config(struct intel_encoder *encoder,
 			struct intel_crtc_state *crtc_state);
 struct intel_shared_dpll *icl_ddi_combo_get_pll(struct intel_encoder *encoder);
-void intel_prepare_dp_ddi_buffers(struct intel_encoder *encoder,
-				  const struct intel_crtc_state *crtc_state);
+void hsw_prepare_dp_ddi_buffers(struct intel_encoder *encoder,
+				const struct intel_crtc_state *crtc_state);
 void intel_wait_ddi_buf_idle(struct drm_i915_private *dev_priv,
 			     enum port port);
 void intel_ddi_init(struct drm_i915_private *dev_priv, enum port port);
diff --git a/drivers/gpu/drm/i915/display/intel_ddi_buf_trans.c b/drivers/gpu/drm/i915/display/intel_ddi_buf_trans.c
index 8bfd00f49f2a..e8e46d7a6cef 100644
--- a/drivers/gpu/drm/i915/display/intel_ddi_buf_trans.c
+++ b/drivers/gpu/drm/i915/display/intel_ddi_buf_trans.c
@@ -13,7 +13,7 @@
  * them for both DP and FDI transports, allowing those ports to
  * automatically adapt to HDMI connections as well
  */
-static const struct ddi_buf_trans hsw_ddi_translations_dp[] = {
+static const struct hsw_ddi_buf_trans hsw_ddi_translations_dp[] = {
 	{ 0x00FFFFFF, 0x0006000E, 0x0 },
 	{ 0x00D75FFF, 0x0005000A, 0x0 },
 	{ 0x00C30FFF, 0x00040006, 0x0 },
@@ -25,7 +25,7 @@ static const struct ddi_buf_trans hsw_ddi_translations_dp[] = {
 	{ 0x80D75FFF, 0x000B0000, 0x0 },
 };
 
-static const struct ddi_buf_trans hsw_ddi_translations_fdi[] = {
+static const struct hsw_ddi_buf_trans hsw_ddi_translations_fdi[] = {
 	{ 0x00FFFFFF, 0x0007000E, 0x0 },
 	{ 0x00D75FFF, 0x000F000A, 0x0 },
 	{ 0x00C30FFF, 0x00060006, 0x0 },
@@ -37,7 +37,7 @@ static const struct ddi_buf_trans hsw_ddi_translations_fdi[] = {
 	{ 0x00D75FFF, 0x001E0000, 0x0 },
 };
 
-static const struct ddi_buf_trans hsw_ddi_translations_hdmi[] = {
+static const struct hsw_ddi_buf_trans hsw_ddi_translations_hdmi[] = {
 					/* Idx	NT mV d	T mV d	db	*/
 	{ 0x00FFFFFF, 0x0006000E, 0x0 },/* 0:	400	400	0	*/
 	{ 0x00E79FFF, 0x000E000C, 0x0 },/* 1:	400	500	2	*/
@@ -53,7 +53,7 @@ static const struct ddi_buf_trans hsw_ddi_translations_hdmi[] = {
 	{ 0x80FFFFFF, 0x00030002, 0x0 },/* 11:	1000	1000	0	*/
 };
 
-static const struct ddi_buf_trans bdw_ddi_translations_edp[] = {
+static const struct hsw_ddi_buf_trans bdw_ddi_translations_edp[] = {
 	{ 0x00FFFFFF, 0x00000012, 0x0 },
 	{ 0x00EBAFFF, 0x00020011, 0x0 },
 	{ 0x00C71FFF, 0x0006000F, 0x0 },
@@ -65,7 +65,7 @@ static const struct ddi_buf_trans bdw_ddi_translations_edp[] = {
 	{ 0x00DB6FFF, 0x000A000C, 0x0 },
 };
 
-static const struct ddi_buf_trans bdw_ddi_translations_dp[] = {
+static const struct hsw_ddi_buf_trans bdw_ddi_translations_dp[] = {
 	{ 0x00FFFFFF, 0x0007000E, 0x0 },
 	{ 0x00D75FFF, 0x000E000A, 0x0 },
 	{ 0x00BEFFFF, 0x00140006, 0x0 },
@@ -77,7 +77,7 @@ static const struct ddi_buf_trans bdw_ddi_translations_dp[] = {
 	{ 0x80D75FFF, 0x001B0002, 0x0 },
 };
 
-static const struct ddi_buf_trans bdw_ddi_translations_fdi[] = {
+static const struct hsw_ddi_buf_trans bdw_ddi_translations_fdi[] = {
 	{ 0x00FFFFFF, 0x0001000E, 0x0 },
 	{ 0x00D75FFF, 0x0004000A, 0x0 },
 	{ 0x00C30FFF, 0x00070006, 0x0 },
@@ -89,7 +89,7 @@ static const struct ddi_buf_trans bdw_ddi_translations_fdi[] = {
 	{ 0x00D75FFF, 0x000C0000, 0x0 },
 };
 
-static const struct ddi_buf_trans bdw_ddi_translations_hdmi[] = {
+static const struct hsw_ddi_buf_trans bdw_ddi_translations_hdmi[] = {
 					/* Idx	NT mV d	T mV df	db	*/
 	{ 0x00FFFFFF, 0x0007000E, 0x0 },/* 0:	400	400	0	*/
 	{ 0x00D75FFF, 0x000E000A, 0x0 },/* 1:	400	600	3.5	*/
@@ -104,7 +104,7 @@ static const struct ddi_buf_trans bdw_ddi_translations_hdmi[] = {
 };
 
 /* Skylake H and S */
-static const struct ddi_buf_trans skl_ddi_translations_dp[] = {
+static const struct hsw_ddi_buf_trans skl_ddi_translations_dp[] = {
 	{ 0x00002016, 0x000000A0, 0x0 },
 	{ 0x00005012, 0x0000009B, 0x0 },
 	{ 0x00007011, 0x00000088, 0x0 },
@@ -117,7 +117,7 @@ static const struct ddi_buf_trans skl_ddi_translations_dp[] = {
 };
 
 /* Skylake U */
-static const struct ddi_buf_trans skl_u_ddi_translations_dp[] = {
+static const struct hsw_ddi_buf_trans skl_u_ddi_translations_dp[] = {
 	{ 0x0000201B, 0x000000A2, 0x0 },
 	{ 0x00005012, 0x00000088, 0x0 },
 	{ 0x80007011, 0x000000CD, 0x1 },
@@ -130,7 +130,7 @@ static const struct ddi_buf_trans skl_u_ddi_translations_dp[] = {
 };
 
 /* Skylake Y */
-static const struct ddi_buf_trans skl_y_ddi_translations_dp[] = {
+static const struct hsw_ddi_buf_trans skl_y_ddi_translations_dp[] = {
 	{ 0x00000018, 0x000000A2, 0x0 },
 	{ 0x00005012, 0x00000088, 0x0 },
 	{ 0x80007011, 0x000000CD, 0x3 },
@@ -143,7 +143,7 @@ static const struct ddi_buf_trans skl_y_ddi_translations_dp[] = {
 };
 
 /* Kabylake H and S */
-static const struct ddi_buf_trans kbl_ddi_translations_dp[] = {
+static const struct hsw_ddi_buf_trans kbl_ddi_translations_dp[] = {
 	{ 0x00002016, 0x000000A0, 0x0 },
 	{ 0x00005012, 0x0000009B, 0x0 },
 	{ 0x00007011, 0x00000088, 0x0 },
@@ -156,7 +156,7 @@ static const struct ddi_buf_trans kbl_ddi_translations_dp[] = {
 };
 
 /* Kabylake U */
-static const struct ddi_buf_trans kbl_u_ddi_translations_dp[] = {
+static const struct hsw_ddi_buf_trans kbl_u_ddi_translations_dp[] = {
 	{ 0x0000201B, 0x000000A1, 0x0 },
 	{ 0x00005012, 0x00000088, 0x0 },
 	{ 0x80007011, 0x000000CD, 0x3 },
@@ -169,7 +169,7 @@ static const struct ddi_buf_trans kbl_u_ddi_translations_dp[] = {
 };
 
 /* Kabylake Y */
-static const struct ddi_buf_trans kbl_y_ddi_translations_dp[] = {
+static const struct hsw_ddi_buf_trans kbl_y_ddi_translations_dp[] = {
 	{ 0x00001017, 0x000000A1, 0x0 },
 	{ 0x00005012, 0x00000088, 0x0 },
 	{ 0x80007011, 0x000000CD, 0x3 },
@@ -185,7 +185,7 @@ static const struct ddi_buf_trans kbl_y_ddi_translations_dp[] = {
  * Skylake/Kabylake H and S
  * eDP 1.4 low vswing translation parameters
  */
-static const struct ddi_buf_trans skl_ddi_translations_edp[] = {
+static const struct hsw_ddi_buf_trans skl_ddi_translations_edp[] = {
 	{ 0x00000018, 0x000000A8, 0x0 },
 	{ 0x00004013, 0x000000A9, 0x0 },
 	{ 0x00007011, 0x000000A2, 0x0 },
@@ -202,7 +202,7 @@ static const struct ddi_buf_trans skl_ddi_translations_edp[] = {
  * Skylake/Kabylake U
  * eDP 1.4 low vswing translation parameters
  */
-static const struct ddi_buf_trans skl_u_ddi_translations_edp[] = {
+static const struct hsw_ddi_buf_trans skl_u_ddi_translations_edp[] = {
 	{ 0x00000018, 0x000000A8, 0x0 },
 	{ 0x00004013, 0x000000A9, 0x0 },
 	{ 0x00007011, 0x000000A2, 0x0 },
@@ -219,7 +219,7 @@ static const struct ddi_buf_trans skl_u_ddi_translations_edp[] = {
  * Skylake/Kabylake Y
  * eDP 1.4 low vswing translation parameters
  */
-static const struct ddi_buf_trans skl_y_ddi_translations_edp[] = {
+static const struct hsw_ddi_buf_trans skl_y_ddi_translations_edp[] = {
 	{ 0x00000018, 0x000000A8, 0x0 },
 	{ 0x00004013, 0x000000AB, 0x0 },
 	{ 0x00007011, 0x000000A4, 0x0 },
@@ -233,7 +233,7 @@ static const struct ddi_buf_trans skl_y_ddi_translations_edp[] = {
 };
 
 /* Skylake/Kabylake U, H and S */
-static const struct ddi_buf_trans skl_ddi_translations_hdmi[] = {
+static const struct hsw_ddi_buf_trans skl_ddi_translations_hdmi[] = {
 	{ 0x00000018, 0x000000AC, 0x0 },
 	{ 0x00005012, 0x0000009D, 0x0 },
 	{ 0x00007011, 0x00000088, 0x0 },
@@ -248,7 +248,7 @@ static const struct ddi_buf_trans skl_ddi_translations_hdmi[] = {
 };
 
 /* Skylake/Kabylake Y */
-static const struct ddi_buf_trans skl_y_ddi_translations_hdmi[] = {
+static const struct hsw_ddi_buf_trans skl_y_ddi_translations_hdmi[] = {
 	{ 0x00000018, 0x000000A1, 0x0 },
 	{ 0x00005012, 0x000000DF, 0x0 },
 	{ 0x80007011, 0x000000CB, 0x3 },
@@ -262,7 +262,6 @@ static const struct ddi_buf_trans skl_y_ddi_translations_hdmi[] = {
 	{ 0x80000018, 0x000000C0, 0x3 },
 };
 
-
 static const struct bxt_ddi_buf_trans bxt_ddi_translations_dp[] = {
 					/* Idx	NT mV diff	db  */
 	{ 52,  0x9A, 0, 128, },	/* 0:	400		0   */
@@ -768,7 +767,7 @@ bool is_hobl_buf_trans(const struct cnl_ddi_buf_trans *table)
 	return table == tgl_combo_phy_ddi_translations_edp_hbr2_hobl;
 }
 
-static const struct ddi_buf_trans *
+static const struct hsw_ddi_buf_trans *
 bdw_get_buf_trans_edp(struct intel_encoder *encoder, int *n_entries)
 {
 	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
@@ -782,7 +781,7 @@ bdw_get_buf_trans_edp(struct intel_encoder *encoder, int *n_entries)
 	}
 }
 
-static const struct ddi_buf_trans *
+static const struct hsw_ddi_buf_trans *
 skl_get_buf_trans_dp(struct intel_encoder *encoder, int *n_entries)
 {
 	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
@@ -799,7 +798,7 @@ skl_get_buf_trans_dp(struct intel_encoder *encoder, int *n_entries)
 	}
 }
 
-static const struct ddi_buf_trans *
+static const struct hsw_ddi_buf_trans *
 kbl_get_buf_trans_dp(struct intel_encoder *encoder, int *n_entries)
 {
 	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
@@ -820,7 +819,7 @@ kbl_get_buf_trans_dp(struct intel_encoder *encoder, int *n_entries)
 	}
 }
 
-static const struct ddi_buf_trans *
+static const struct hsw_ddi_buf_trans *
 skl_get_buf_trans_edp(struct intel_encoder *encoder, int *n_entries)
 {
 	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
@@ -852,7 +851,7 @@ skl_get_buf_trans_edp(struct intel_encoder *encoder, int *n_entries)
 		return skl_get_buf_trans_dp(encoder, n_entries);
 }
 
-static const struct ddi_buf_trans *
+static const struct hsw_ddi_buf_trans *
 skl_get_buf_trans_hdmi(struct drm_i915_private *dev_priv, int *n_entries)
 {
 	if (IS_SKL_ULX(dev_priv) ||
@@ -876,20 +875,20 @@ static int skl_buf_trans_num_entries(enum port port, int n_entries)
 		return min(n_entries, 9);
 }
 
-const struct ddi_buf_trans *
-intel_ddi_get_buf_trans_dp(struct intel_encoder *encoder, int *n_entries)
+const struct hsw_ddi_buf_trans *
+hsw_ddi_get_buf_trans_dp(struct intel_encoder *encoder, int *n_entries)
 {
 	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
 
 	if (IS_KABYLAKE(dev_priv) ||
 	    IS_COFFEELAKE(dev_priv) ||
 	    IS_COMETLAKE(dev_priv)) {
-		const struct ddi_buf_trans *ddi_translations =
+		const struct hsw_ddi_buf_trans *ddi_translations =
 			kbl_get_buf_trans_dp(encoder, n_entries);
 		*n_entries = skl_buf_trans_num_entries(encoder->port, *n_entries);
 		return ddi_translations;
 	} else if (IS_SKYLAKE(dev_priv)) {
-		const struct ddi_buf_trans *ddi_translations =
+		const struct hsw_ddi_buf_trans *ddi_translations =
 			skl_get_buf_trans_dp(encoder, n_entries);
 		*n_entries = skl_buf_trans_num_entries(encoder->port, *n_entries);
 		return ddi_translations;
@@ -905,13 +904,13 @@ intel_ddi_get_buf_trans_dp(struct intel_encoder *encoder, int *n_entries)
 	return NULL;
 }
 
-const struct ddi_buf_trans *
-intel_ddi_get_buf_trans_edp(struct intel_encoder *encoder, int *n_entries)
+const struct hsw_ddi_buf_trans *
+hsw_ddi_get_buf_trans_edp(struct intel_encoder *encoder, int *n_entries)
 {
 	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
 
 	if (DISPLAY_VER(dev_priv) == 9 && !IS_BROXTON(dev_priv)) {
-		const struct ddi_buf_trans *ddi_translations =
+		const struct hsw_ddi_buf_trans *ddi_translations =
 			skl_get_buf_trans_edp(encoder, n_entries);
 		*n_entries = skl_buf_trans_num_entries(encoder->port, *n_entries);
 		return ddi_translations;
@@ -926,9 +925,9 @@ intel_ddi_get_buf_trans_edp(struct intel_encoder *encoder, int *n_entries)
 	return NULL;
 }
 
-const struct ddi_buf_trans *
-intel_ddi_get_buf_trans_fdi(struct drm_i915_private *dev_priv,
-			    int *n_entries)
+const struct hsw_ddi_buf_trans *
+hsw_ddi_get_buf_trans_fdi(struct drm_i915_private *dev_priv,
+			  int *n_entries)
 {
 	if (IS_BROADWELL(dev_priv)) {
 		*n_entries = ARRAY_SIZE(bdw_ddi_translations_fdi);
@@ -942,9 +941,9 @@ intel_ddi_get_buf_trans_fdi(struct drm_i915_private *dev_priv,
 	return NULL;
 }
 
-const struct ddi_buf_trans *
-intel_ddi_get_buf_trans_hdmi(struct intel_encoder *encoder,
-			     int *n_entries)
+const struct hsw_ddi_buf_trans *
+hsw_ddi_get_buf_trans_hdmi(struct intel_encoder *encoder,
+			   int *n_entries)
 {
 	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
 
@@ -1428,13 +1427,13 @@ int intel_ddi_hdmi_num_entries(struct intel_encoder *encoder,
 		bxt_get_buf_trans_hdmi(encoder, &n_entries);
 		*default_entry = n_entries - 1;
 	} else if (DISPLAY_VER(dev_priv) == 9) {
-		intel_ddi_get_buf_trans_hdmi(encoder, &n_entries);
+		hsw_ddi_get_buf_trans_hdmi(encoder, &n_entries);
 		*default_entry = 8;
 	} else if (IS_BROADWELL(dev_priv)) {
-		intel_ddi_get_buf_trans_hdmi(encoder, &n_entries);
+		hsw_ddi_get_buf_trans_hdmi(encoder, &n_entries);
 		*default_entry = 7;
 	} else if (IS_HASWELL(dev_priv)) {
-		intel_ddi_get_buf_trans_hdmi(encoder, &n_entries);
+		hsw_ddi_get_buf_trans_hdmi(encoder, &n_entries);
 		*default_entry = 6;
 	} else {
 		drm_WARN(&dev_priv->drm, 1, "ddi translation table missing\n");
diff --git a/drivers/gpu/drm/i915/display/intel_ddi_buf_trans.h b/drivers/gpu/drm/i915/display/intel_ddi_buf_trans.h
index 4c2efab38642..1b8d3ef7f06f 100644
--- a/drivers/gpu/drm/i915/display/intel_ddi_buf_trans.h
+++ b/drivers/gpu/drm/i915/display/intel_ddi_buf_trans.h
@@ -12,7 +12,7 @@ struct drm_i915_private;
 struct intel_encoder;
 struct intel_crtc_state;
 
-struct ddi_buf_trans {
+struct hsw_ddi_buf_trans {
 	u32 trans1;	/* balance leg enable, de-emph level */
 	u32 trans2;	/* vref sel, vswing */
 	u8 i_boost;	/* SKL: I_boost; valid: 0x0, 0x1, 0x3, 0x7 */
@@ -51,16 +51,14 @@ int intel_ddi_hdmi_num_entries(struct intel_encoder *encoder,
 			       const struct intel_crtc_state *crtc_state,
 			       int *default_entry);
 
-const struct ddi_buf_trans *
-intel_ddi_get_buf_trans_edp(struct intel_encoder *encoder, int *n_entries);
-const struct ddi_buf_trans *
-intel_ddi_get_buf_trans_fdi(struct drm_i915_private *dev_priv,
-			    int *n_entries);
-const struct ddi_buf_trans *
-intel_ddi_get_buf_trans_hdmi(struct intel_encoder *encoder,
-			     int *n_entries);
-const struct ddi_buf_trans *
-intel_ddi_get_buf_trans_dp(struct intel_encoder *encoder, int *n_entries);
+const struct hsw_ddi_buf_trans *
+hsw_ddi_get_buf_trans_edp(struct intel_encoder *encoder, int *n_entries);
+const struct hsw_ddi_buf_trans *
+hsw_ddi_get_buf_trans_fdi(struct drm_i915_private *dev_priv, int *n_entries);
+const struct hsw_ddi_buf_trans *
+hsw_ddi_get_buf_trans_hdmi(struct intel_encoder *encoder, int *n_entries);
+const struct hsw_ddi_buf_trans *
+hsw_ddi_get_buf_trans_dp(struct intel_encoder *encoder, int *n_entries);
 
 const struct bxt_ddi_buf_trans *
 bxt_get_buf_trans(struct intel_encoder *encoder,
diff --git a/drivers/gpu/drm/i915/display/intel_fdi.c b/drivers/gpu/drm/i915/display/intel_fdi.c
index cef1061fd6cb..a806e1b83613 100644
--- a/drivers/gpu/drm/i915/display/intel_fdi.c
+++ b/drivers/gpu/drm/i915/display/intel_fdi.c
@@ -569,9 +569,9 @@ void hsw_fdi_link_train(struct intel_encoder *encoder,
 	u32 temp, i, rx_ctl_val;
 	int n_entries;
 
-	intel_ddi_get_buf_trans_fdi(dev_priv, &n_entries);
+	hsw_ddi_get_buf_trans_fdi(dev_priv, &n_entries);
 
-	intel_prepare_dp_ddi_buffers(encoder, crtc_state);
+	hsw_prepare_dp_ddi_buffers(encoder, crtc_state);
 
 	/* Set the FDI_RX_MISC pwrdn lanes and the 2 workarounds listed at the
 	 * mode set "sequence for CRT port" document:
-- 
2.38.1


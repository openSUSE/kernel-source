From e0324629bdfc0515bb14fe926b5d75c921d482ab Mon Sep 17 00:00:00 2001
From: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date: Wed, 5 Jun 2024 17:18:24 +0200
Subject: [PATCH] printk: Update the printk series.

References: bsc#1214683 (PREEMPT_RT prerequisite backports)
Git-commit: 2fb89df1004f974b9f299cf56377fdf2e23ad702
Patch-mainline: Queued in subsystem maintainer repository (v6.10-rc2-rt3)
Git-repo: git://git.kernel.org/pub/scm/linux/kernel/git/rt/linux-rt-devel.git

This is an all-in-one update to the printk series provided by John
Ogness. It updates the series to the current version of the series
currently under review:
- Flush legacy consoles directly (if safe) when exiting emergency sections.
- Wake nbcon printer threads on sysrq-R.
- Sync with latest series posted to LKML for review.

Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Signed-off-by: Mel Gorman <mgorman@suse.de>
---
 drivers/tty/sysrq.c         |   2 +-
 include/linux/console.h     |  17 +++----
 include/linux/printk.h      |  13 ++---
 include/linux/serial_core.h |   6 +--
 kernel/printk/internal.h    |   2 +
 kernel/printk/nbcon.c       | 120 ++++++++++++++++++++++++++++----------------
 kernel/printk/printk.c      |  37 ++++++++------
 kernel/printk/printk_safe.c |  11 +++-
 8 files changed, 131 insertions(+), 77 deletions(-)

diff --git a/drivers/tty/sysrq.c b/drivers/tty/sysrq.c
index 36b15f3d0dce..81b05265c7a5 100644
--- a/drivers/tty/sysrq.c
+++ b/drivers/tty/sysrq.c
@@ -453,7 +453,7 @@ static const struct sysrq_key_op sysrq_unrt_op = {
 
 static void sysrq_handle_replay_logs(u8 key)
 {
-	console_replay_all();
+	console_try_replay_all();
 }
 static struct sysrq_key_op sysrq_replay_logs_op = {
 	.handler        = sysrq_handle_replay_logs,
diff --git a/include/linux/console.h b/include/linux/console.h
index 2bf0f8f113a1..26e9b1bc4c3a 100644
--- a/include/linux/console.h
+++ b/include/linux/console.h
@@ -306,7 +306,7 @@ struct nbcon_write_context {
  *
  * @nbcon_state:	State for nbcon consoles
  * @nbcon_seq:		Sequence number of the next record for nbcon to print
- * @nbcon_driver_ctxt:	Context available for driver non-printing operations
+ * @nbcon_device_ctxt:	Context available for non-printing operations
  * @nbcon_prev_seq:	Seq num the previous nbcon owner was assigned to print
  * @pbufs:		Pointer to nbcon private buffer
  * @kthread:		Printer kthread for this console
@@ -354,7 +354,6 @@ struct console {
 	 *
 	 * The callback should allow the takeover whenever it is safe. It
 	 * increases the chance to see messages when the system is in trouble.
-	 *
 	 * If the driver must reacquire ownership in order to finalize or
 	 * revert hardware changes, nbcon_reacquire() can be used. However,
 	 * on reacquire the buffer content is no longer available. A
@@ -369,11 +368,11 @@ struct console {
 	/**
 	 * @write_thread:
 	 *
-	 * NBCON callback to write out text in task context. (Optional)
+	 * NBCON callback to write out text in task context.
 	 *
-	 * This callback is called with the console already acquired. Any
-	 * additional driver synchronization should have been performed by
-	 * device_lock().
+	 * This callback is called after device_lock() and with the nbcon
+	 * console acquired. Any necessary driver synchronization should have
+	 * been performed by the device_lock() callback.
 	 *
 	 * This callback is always called from task context but with migration
 	 * disabled.
@@ -382,8 +381,8 @@ struct console {
 	 * sections applies as with write_atomic(). The difference between
 	 * this callback and write_atomic() is that this callback is used
 	 * during normal operation and is always called from task context.
-	 * This provides drivers with a relatively relaxed locking context
-	 * for synchronizing output to the hardware.
+	 * This allows drivers to operate in their own locking context for
+	 * synchronizing output to the hardware.
 	 */
 	void (*write_thread)(struct console *con, struct nbcon_write_context *wctxt);
 
@@ -432,7 +431,7 @@ struct console {
 
 	atomic_t		__private nbcon_state;
 	atomic_long_t		__private nbcon_seq;
-	struct nbcon_context	__private nbcon_driver_ctxt;
+	struct nbcon_context	__private nbcon_device_ctxt;
 	atomic_long_t           __private nbcon_prev_seq;
 
 	struct printk_buffers	*pbufs;
diff --git a/include/linux/printk.h b/include/linux/printk.h
index 4353fcbfa919..6e756525e5a8 100644
--- a/include/linux/printk.h
+++ b/include/linux/printk.h
@@ -198,10 +198,10 @@ void show_regs_print_info(const char *log_lvl);
 extern asmlinkage void dump_stack_lvl(const char *log_lvl) __cold;
 extern asmlinkage void dump_stack(void) __cold;
 void printk_trigger_flush(void);
-void console_replay_all(void);
+void console_try_replay_all(void);
 void printk_legacy_allow_panic_sync(void);
-extern bool nbcon_driver_try_acquire(struct console *con);
-extern void nbcon_driver_release(struct console *con);
+extern bool nbcon_device_try_acquire(struct console *con);
+extern void nbcon_device_release(struct console *con);
 void nbcon_atomic_flush_unsafe(void);
 #else
 static inline __printf(1, 0)
@@ -282,7 +282,8 @@ static inline void dump_stack(void)
 static inline void printk_trigger_flush(void)
 {
 }
-static inline void console_replay_all(void)
+
+static inline void console_try_replay_all(void)
 {
 }
 
@@ -290,12 +291,12 @@ static inline void printk_legacy_allow_panic_sync(void)
 {
 }
 
-static inline bool nbcon_driver_try_acquire(struct console *con)
+static inline bool nbcon_device_try_acquire(struct console *con)
 {
 	return false;
 }
 
-static inline void nbcon_driver_release(struct console *con)
+static inline void nbcon_device_release(struct console *con)
 {
 }
 
diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index cab339bf45da..87da6387d19c 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -660,7 +660,7 @@ static inline bool __uart_port_nbcon_try_acquire(struct uart_port *up)
 	if (!__uart_port_using_nbcon(up))
 		return true;
 
-	return nbcon_driver_try_acquire(up->cons);
+	return nbcon_device_try_acquire(up->cons);
 }
 
 /* Only for internal port lock wrapper usage. */
@@ -669,7 +669,7 @@ static inline void __uart_port_nbcon_acquire(struct uart_port *up)
 	if (!__uart_port_using_nbcon(up))
 		return;
 
-	while (!nbcon_driver_try_acquire(up->cons))
+	while (!nbcon_device_try_acquire(up->cons))
 		cpu_relax();
 }
 
@@ -679,7 +679,7 @@ static inline void __uart_port_nbcon_release(struct uart_port *up)
 	if (!__uart_port_using_nbcon(up))
 		return;
 
-	nbcon_driver_release(up->cons);
+	nbcon_device_release(up->cons);
 }
 
 /**
diff --git a/kernel/printk/nbcon.c b/kernel/printk/nbcon.c
index 99818b819e41..bb9689f94d30 100644
--- a/kernel/printk/nbcon.c
+++ b/kernel/printk/nbcon.c
@@ -839,20 +839,20 @@ bool nbcon_exit_unsafe(struct nbcon_write_context *wctxt)
 EXPORT_SYMBOL_GPL(nbcon_exit_unsafe);
 
 /**
- * nbcon_reacquire - Reacquire a console after losing ownership
- * @wctxt:	The write context that was handed to the write function
+ * nbcon_reacquire - Reacquire a console after losing ownership while printing
+ * @wctxt:	The write context that was handed to the write callback
  *
  * Since ownership can be lost at any time due to handover or takeover, a
- * printing context _should_ be prepared to back out immediately and
- * carefully. However, there are many scenarios where the context _must_
+ * printing context _must_ be prepared to back out immediately and
+ * carefully. However, there are scenarios where the printing context must
  * reacquire ownership in order to finalize or revert hardware changes.
  *
- * This function allows a context to reacquire ownership using the same
- * priority as its previous ownership.
+ * This function allows a printing context to reacquire ownership using the
+ * same priority as its previous ownership.
  *
- * Note that for printing contexts, after a successful reacquire the
- * context will have no output buffer because that has been lost. This
- * function cannot be used to resume printing.
+ * Note that after a successful reacquire the printing context will have no
+ * output buffer because that has been lost. This function cannot be used to
+ * resume printing.
  */
 void nbcon_reacquire(struct nbcon_write_context *wctxt)
 {
@@ -873,7 +873,7 @@ EXPORT_SYMBOL_GPL(nbcon_reacquire);
 /**
  * nbcon_emit_next_record - Emit a record in the acquired context
  * @wctxt:	The write context that will be handed to the write function
- * @use_atomic:	True if the write_atomic callback is to be used
+ * @use_atomic:	True if the write_atomic() callback is to be used
  *
  * Return:	True if this context still owns the console. False if
  *		ownership was handed over or taken.
@@ -980,7 +980,7 @@ static bool nbcon_emit_next_record(struct nbcon_write_context *wctxt, bool use_a
 	if (!wctxt->outbuf) {
 		/*
 		 * Ownership was lost and reacquired by the driver.
-		 * Handle it as if ownership was lost and try to continue.
+		 * Handle it as if ownership was lost.
 		 */
 		nbcon_context_release(ctxt);
 		return false;
@@ -1014,8 +1014,7 @@ static bool nbcon_emit_next_record(struct nbcon_write_context *wctxt, bool use_a
 /**
  * nbcon_kthread_should_wakeup - Check whether a printer thread should wakeup
  * @con:	Console to operate on
- * @ctxt:	The acquire context that contains the state
- *		at console_acquire()
+ * @ctxt:	The nbcon context from nbcon_context_try_acquire()
  *
  * Return:	True if the thread should shutdown or if the console is
  *		allowed to print and a record is available. False otherwise.
@@ -1049,6 +1048,8 @@ static bool nbcon_kthread_should_wakeup(struct console *con, struct nbcon_contex
 /**
  * nbcon_kthread_func - The printer thread function
  * @__console:	Console to operate on
+ *
+ * Return:	0
  */
 static int nbcon_kthread_func(void *__console)
 {
@@ -1058,7 +1059,6 @@ static int nbcon_kthread_func(void *__console)
 		.ctxt.prio	= NBCON_PRIO_NORMAL,
 	};
 	struct nbcon_context *ctxt = &ACCESS_PRIVATE(&wctxt, ctxt);
-	unsigned long flags;
 	short con_flags;
 	bool backlog;
 	int cookie;
@@ -1094,7 +1094,9 @@ static int nbcon_kthread_func(void *__console)
 		con_flags = console_srcu_read_flags(con);
 
 		if (console_is_usable(con, con_flags, false)) {
-			con->device_lock(con, &flags);
+			unsigned long lock_flags;
+
+			con->device_lock(con, &lock_flags);
 
 			/*
 			 * Ensure this stays on the CPU to make handover and
@@ -1113,7 +1115,7 @@ static int nbcon_kthread_func(void *__console)
 				}
 			}
 
-			con->device_unlock(con, flags);
+			con->device_unlock(con, lock_flags);
 		}
 
 		console_srcu_read_unlock(cookie);
@@ -1227,7 +1229,7 @@ enum nbcon_prio nbcon_get_default_prio(void)
  * nbcon_emit_one - Print one record for an nbcon console using the
  *			specified callback
  * @wctxt:	An initialized write context struct to use for this context
- * @use_atomic:	True if the write_atomic callback is to be used
+ * @use_atomic:	True if the write_atomic() callback is to be used
  *
  * Return:	True, when a record has been printed and there are still
  *		pending records. The caller might want to continue flushing.
@@ -1272,7 +1274,7 @@ static bool nbcon_emit_one(struct nbcon_write_context *wctxt, bool use_atomic)
  *		both the console_lock and the SRCU read lock. Otherwise it
  *		is set to false.
  * @cookie:	The cookie from the SRCU read lock.
- * @use_atomic:	True if the write_atomic callback is to be used
+ * @use_atomic:	True if the write_atomic() callback is to be used
  *
  * Context:	Any context except NMI.
  * Return:	True, when a record has been printed and there are still
@@ -1373,6 +1375,7 @@ static int __nbcon_atomic_flush_pending_con(struct console *con, u64 stop_seq,
 			return -EAGAIN;
 
 		if (!ctxt->backlog) {
+			/* Are there reserved but not yet finalized records? */
 			if (nbcon_seq_read(con) < stop_seq)
 				err = -ENOENT;
 			break;
@@ -1415,19 +1418,26 @@ static void nbcon_atomic_flush_pending_con(struct console *con, u64 stop_seq,
 	local_irq_restore(flags);
 
 	/*
-	 * If flushing was successful but more records are available this
+	 * If there was a new owner (-EPERM, -EAGAIN), that context is
+	 * responsible for completing.
+	 *
+	 * Do not wait for records not yet finalized (-ENOENT) to avoid a
+	 * possible deadlock. They will either get flushed by the writer or
+	 * eventually skipped on panic CPU.
+	 */
+	if (err)
+		return;
+
+	/*
+	 * If flushing was successful but more records are available, this
 	 * context must flush those remaining records if the printer thread
-	 * is not available to do it.
+	 * is not available do it.
 	 */
-	if (!err && !con->kthread && prb_read_valid(prb, nbcon_seq_read(con), NULL)) {
+	if ((!con->kthread || (system_state > SYSTEM_RUNNING)) &&
+	    prb_read_valid(prb, nbcon_seq_read(con), NULL)) {
 		stop_seq = prb_next_reserve_seq(prb);
 		goto again;
 	}
-
-	/*
-	 * If there was a new owner, that context is responsible for
-	 * completing the flush.
-	 */
 }
 
 /**
@@ -1532,13 +1542,25 @@ void nbcon_cpu_emergency_exit(void)
 	 */
 	if (*cpu_emergency_nesting == 1) {
 		nbcon_atomic_flush_pending();
+
+		/*
+		 * Safely attempt to flush the legacy consoles in this
+		 * context. Otherwise an irq_work context is triggered
+		 * to handle it.
+		 */
 		do_trigger_flush = true;
+		if (!force_printkthreads() &&
+		    printing_via_unlock &&
+		    !is_printk_legacy_deferred()) {
+			if (console_trylock()) {
+				do_trigger_flush = false;
+				console_unlock();
+			}
+		}
 	}
 
-	(*cpu_emergency_nesting)--;
-
-	if (WARN_ON_ONCE(*cpu_emergency_nesting < 0))
-		*cpu_emergency_nesting = 0;
+	if (!WARN_ON_ONCE(*cpu_emergency_nesting == 0))
+		(*cpu_emergency_nesting)--;
 
 	preempt_enable();
 
@@ -1559,13 +1581,26 @@ void nbcon_cpu_emergency_exit(void)
  */
 void nbcon_cpu_emergency_flush(void)
 {
+	bool is_emergency;
+
+	/*
+	 * If this context is not an emergency context, preemption might be
+	 * enabled. To be sure, disable preemption when checking if this is
+	 * an emergency context.
+	 */
+	preempt_disable();
+	is_emergency = (*nbcon_get_cpu_emergency_nesting() != 0);
+	preempt_enable();
+
 	/* The explicit flush is needed only in the emergency context. */
-	if (*(nbcon_get_cpu_emergency_nesting()) == 0)
+	if (!is_emergency)
 		return;
 
 	nbcon_atomic_flush_pending();
 
-	if (printing_via_unlock && !in_nmi()) {
+	if (!force_printkthreads() &&
+	    printing_via_unlock &&
+	    !is_printk_legacy_deferred()) {
 		if (console_trylock())
 			console_unlock();
 	}
@@ -1715,12 +1750,13 @@ void nbcon_free(struct console *con)
 }
 
 /**
- * nbcon_driver_try_acquire - Try to acquire nbcon console and enter unsafe
+ * nbcon_device_try_acquire - Try to acquire nbcon console and enter unsafe
  *				section
  * @con:	The nbcon console to acquire
  *
  * Context:	Under the locking mechanism implemented in
  *		@con->device_lock() including disabling migration.
+ * Return:	True if the console was acquired. False otherwise.
  *
  * Console drivers will usually use their own internal synchronization
  * mechasism to synchronize between console printing and non-printing
@@ -1732,9 +1768,9 @@ void nbcon_free(struct console *con)
  * This function acquires the nbcon console using priority NBCON_PRIO_NORMAL
  * and marks it unsafe for handover/takeover.
  */
-bool nbcon_driver_try_acquire(struct console *con)
+bool nbcon_device_try_acquire(struct console *con)
 {
-	struct nbcon_context *ctxt = &ACCESS_PRIVATE(con, nbcon_driver_ctxt);
+	struct nbcon_context *ctxt = &ACCESS_PRIVATE(con, nbcon_device_ctxt);
 
 	cant_migrate();
 
@@ -1750,15 +1786,15 @@ bool nbcon_driver_try_acquire(struct console *con)
 
 	return true;
 }
-EXPORT_SYMBOL_GPL(nbcon_driver_try_acquire);
+EXPORT_SYMBOL_GPL(nbcon_device_try_acquire);
 
 /**
- * nbcon_driver_release - Exit unsafe section and release the nbcon console
- * @con:	The nbcon console acquired in nbcon_driver_try_acquire()
+ * nbcon_device_release - Exit unsafe section and release the nbcon console
+ * @con:	The nbcon console acquired in nbcon_device_try_acquire()
  */
-void nbcon_driver_release(struct console *con)
+void nbcon_device_release(struct console *con)
 {
-	struct nbcon_context *ctxt = &ACCESS_PRIVATE(con, nbcon_driver_ctxt);
+	struct nbcon_context *ctxt = &ACCESS_PRIVATE(con, nbcon_device_ctxt);
 	int cookie;
 
 	if (!nbcon_context_exit_unsafe(ctxt))
@@ -1773,13 +1809,13 @@ void nbcon_driver_release(struct console *con)
 	 */
 	cookie = console_srcu_read_lock();
 	if (console_is_usable(con, console_srcu_read_flags(con), true) &&
-	    !con->kthread &&
+	    (!con->kthread || (system_state > SYSTEM_RUNNING)) &&
 	    prb_read_valid(prb, nbcon_seq_read(con), NULL)) {
 		__nbcon_atomic_flush_pending_con(con, prb_next_reserve_seq(prb), false);
 	}
 	console_srcu_read_unlock(cookie);
 }
-EXPORT_SYMBOL_GPL(nbcon_driver_release);
+EXPORT_SYMBOL_GPL(nbcon_device_release);
 
 /**
  * printk_kthread_shutdown - shutdown all threaded printers
diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index ad9b7aad8d3c..978ce5c4318c 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2361,8 +2361,8 @@ asmlinkage int vprintk_emit(int facility, int level,
 			    const struct dev_printk_info *dev_info,
 			    const char *fmt, va_list args)
 {
-	bool do_trylock_unlock = printing_via_unlock &&
-				 !force_printkthreads();
+	bool do_trylock_unlock = !force_printkthreads() &&
+				 printing_via_unlock;
 	int printed_len;
 
 	/* Suppress unimportant messages after panic happens */
@@ -2787,8 +2787,9 @@ void resume_console(void)
  */
 static int console_cpu_notify(unsigned int cpu)
 {
-	if (!cpuhp_tasks_frozen && printing_via_unlock &&
-	    !force_printkthreads()) {
+	if (!force_printkthreads() &&
+	    !cpuhp_tasks_frozen &&
+	    printing_via_unlock) {
 		/* If trylock fails, someone else is doing the printing */
 		if (console_trylock())
 			console_unlock();
@@ -3498,10 +3499,10 @@ EXPORT_SYMBOL(console_stop);
 void console_start(struct console *console)
 {
 	short flags;
+	int cookie;
 
 	console_list_lock();
 	console_srcu_write_flags(console, console->flags | CON_ENABLED);
-	flags = console->flags;
 	console_list_unlock();
 
 	/*
@@ -3511,10 +3512,13 @@ void console_start(struct console *console)
 	 */
 	synchronize_srcu(&console_srcu);
 
+	cookie = console_srcu_read_lock();
+	flags = console_srcu_read_flags(console);
 	if (flags & CON_NBCON)
 		nbcon_kthread_wake(console);
 	else
 		wake_up_legacy_kthread();
+	console_srcu_read_unlock(cookie);
 
 	__pr_flush(console, 1000, true);
 }
@@ -3542,7 +3546,7 @@ static bool printer_should_wake(void)
 		if ((flags & CON_NBCON) && con->kthread)
 			continue;
 
-		if (!console_is_usable(con, flags, true))
+		if (!console_is_usable(con, flags, false))
 			continue;
 
 		if (flags & CON_NBCON) {
@@ -3811,9 +3815,10 @@ static int unregister_console_locked(struct console *console);
  */
 void register_console(struct console *newcon)
 {
-	struct console *con;
+	bool use_device_lock = (newcon->flags & CON_NBCON) && newcon->write_atomic;
 	bool bootcon_registered = false;
 	bool realcon_registered = false;
+	struct console *con;
 	unsigned long flags;
 	u64 init_seq;
 	int err;
@@ -3917,7 +3922,7 @@ void register_console(struct console *newcon)
 	 * Use the driver synchronization to ensure that the hardware is not
 	 * in use while this new console transitions to being registered.
 	 */
-	if ((newcon->flags & CON_NBCON) && newcon->write_atomic)
+	if (use_device_lock)
 		newcon->device_lock(newcon, &flags);
 
 	/*
@@ -3945,7 +3950,7 @@ void register_console(struct console *newcon)
 	 */
 
 	/* This new console is now registered. */
-	if ((newcon->flags & CON_NBCON) && newcon->write_atomic)
+	if (use_device_lock)
 		newcon->device_unlock(newcon, flags);
 
 	console_sysfs_notify();
@@ -3976,6 +3981,7 @@ EXPORT_SYMBOL(register_console);
 /* Must be called under console_list_lock(). */
 static int unregister_console_locked(struct console *console)
 {
+	bool use_device_lock = (console->flags & CON_NBCON) && console->write_atomic;
 	bool is_boot_con = (console->flags & CON_BOOT);
 	bool found_legacy_con = false;
 	bool found_nbcon_con = false;
@@ -4004,12 +4010,12 @@ static int unregister_console_locked(struct console *console)
 	 * Use the driver synchronization to ensure that the hardware is not
 	 * in use while this console transitions to being unregistered.
 	 */
-	if ((console->flags & CON_NBCON) && console->write_atomic)
+	if (use_device_lock)
 		console->device_lock(console, &flags);
 
 	hlist_del_init_rcu(&console->node);
 
-	if ((console->flags & CON_NBCON) && console->write_atomic)
+	if (use_device_lock)
 		console->device_unlock(console, flags);
 
 	/*
@@ -4238,7 +4244,7 @@ static bool __pr_flush(struct console *con, int timeout_ms, bool reset_on_progre
 	 * Otherwise this function will just wait for the threaded printers
 	 * to print up to @seq.
 	 */
-	if (printing_via_unlock && !force_printkthreads()) {
+	if (printing_via_unlock) {
 		console_lock();
 		console_unlock();
 	}
@@ -4770,18 +4776,19 @@ void kmsg_dump_rewind(struct kmsg_dump_iter *iter)
 EXPORT_SYMBOL_GPL(kmsg_dump_rewind);
 
 /**
- * console_replay_all - replay kernel log on consoles
+ * console_try_replay_all - try to replay kernel log on consoles
  *
  * Try to obtain lock on console subsystem and replay all
  * available records in printk buffer on the consoles.
  * Does nothing if lock is not obtained.
  *
- * Context: Any context.
+ * Context: Any, except for NMI.
  */
-void console_replay_all(void)
+void console_try_replay_all(void)
 {
 	if (console_trylock()) {
 		__console_rewind_all();
+		nbcon_wake_threads();
 		/* Consoles are flushed as part of console_unlock(). */
 		console_unlock();
 	}

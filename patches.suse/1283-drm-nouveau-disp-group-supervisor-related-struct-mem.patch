From c00e88a17a05b947f717faea3c7a06c3c132a857 Mon Sep 17 00:00:00 2001
From: Ben Skeggs <bskeggs@redhat.com>
Date: Wed, 1 Jun 2022 20:46:28 +1000
Subject: drm/nouveau/disp: group supervisor-related struct members
Git-commit: 3517e6b6fee05b6259ca21741cbe5d7bf68aa672
Patch-mainline: v6.0-rc1
References: jsc#PED-1166 jsc#PED-1168 jsc#PED-1170 jsc#PED-1218 jsc#PED-1220 jsc#PED-1222 jsc#PED-1223 jsc#PED-1225 jsc#PED-2849

Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
Reviewed-by: Lyude Paul <lyude@redhat.com>
Signed-off-by: Dave Airlie <airlied@redhat.com>
Acked-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 .../drm/nouveau/include/nvkm/engine/disp.h    |  8 +++---
 .../gpu/drm/nouveau/nvkm/engine/disp/gf119.c  | 16 ++++++------
 .../gpu/drm/nouveau/nvkm/engine/disp/gv100.c  | 16 ++++++------
 .../gpu/drm/nouveau/nvkm/engine/disp/nv50.c   | 26 +++++++++----------
 4 files changed, 34 insertions(+), 32 deletions(-)

diff --git a/drivers/gpu/drm/nouveau/include/nvkm/engine/disp.h b/drivers/gpu/drm/nouveau/include/nvkm/engine/disp.h
index 0eb10e166259..593a2395ce9c 100644
--- a/drivers/gpu/drm/nouveau/include/nvkm/engine/disp.h
+++ b/drivers/gpu/drm/nouveau/include/nvkm/engine/disp.h
@@ -18,9 +18,11 @@ struct nvkm_disp {
 	struct nvkm_event hpd;
 	struct nvkm_event vblank;
 
-	struct workqueue_struct *wq;
-	struct work_struct supervisor;
-	u32 super;
+	struct {
+		struct workqueue_struct *wq;
+		struct work_struct work;
+		u32 pending;
+	} super;
 
 	struct nvkm_event uevent;
 
diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/gf119.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/gf119.c
index de9bc351169d..492e2d23fd32 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/gf119.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/gf119.c
@@ -983,19 +983,19 @@ gf119_disp_core_new(const struct nvkm_oclass *oclass, void *argv, u32 argc,
 void
 gf119_disp_super(struct work_struct *work)
 {
-	struct nvkm_disp *disp = container_of(work, struct nvkm_disp, supervisor);
+	struct nvkm_disp *disp = container_of(work, struct nvkm_disp, super.work);
 	struct nvkm_subdev *subdev = &disp->engine.subdev;
 	struct nvkm_device *device = subdev->device;
 	struct nvkm_head *head;
 	u32 mask[4];
 
-	nvkm_debug(subdev, "supervisor %d\n", ffs(disp->super));
+	nvkm_debug(subdev, "supervisor %d\n", ffs(disp->super.pending));
 	list_for_each_entry(head, &disp->heads, head) {
 		mask[head->id] = nvkm_rd32(device, 0x6101d4 + (head->id * 0x800));
 		HEAD_DBG(head, "%08x", mask[head->id]);
 	}
 
-	if (disp->super & 0x00000001) {
+	if (disp->super.pending & 0x00000001) {
 		nv50_disp_chan_mthd(disp->chan[0], NV_DBG_DEBUG);
 		nv50_disp_super_1(disp);
 		list_for_each_entry(head, &disp->heads, head) {
@@ -1004,7 +1004,7 @@ gf119_disp_super(struct work_struct *work)
 			nv50_disp_super_1_0(disp, head);
 		}
 	} else
-	if (disp->super & 0x00000002) {
+	if (disp->super.pending & 0x00000002) {
 		list_for_each_entry(head, &disp->heads, head) {
 			if (!(mask[head->id] & 0x00001000))
 				continue;
@@ -1022,7 +1022,7 @@ gf119_disp_super(struct work_struct *work)
 			nv50_disp_super_2_2(disp, head);
 		}
 	} else
-	if (disp->super & 0x00000004) {
+	if (disp->super.pending & 0x00000004) {
 		list_for_each_entry(head, &disp->heads, head) {
 			if (!(mask[head->id] & 0x00001000))
 				continue;
@@ -1096,9 +1096,9 @@ gf119_disp_intr(struct nvkm_disp *disp)
 	if (intr & 0x00100000) {
 		u32 stat = nvkm_rd32(device, 0x6100ac);
 		if (stat & 0x00000007) {
-			disp->super = (stat & 0x00000007);
-			queue_work(disp->wq, &disp->supervisor);
-			nvkm_wr32(device, 0x6100ac, disp->super);
+			disp->super.pending = (stat & 0x00000007);
+			queue_work(disp->super.wq, &disp->super.work);
+			nvkm_wr32(device, 0x6100ac, disp->super.pending);
 			stat &= ~0x00000007;
 		}
 
diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/gv100.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/gv100.c
index 953ebc6af03f..bb61ba6a2a24 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/gv100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/gv100.c
@@ -897,20 +897,20 @@ gv100_disp_caps_new(const struct nvkm_oclass *oclass, void *argv, u32 argc,
 void
 gv100_disp_super(struct work_struct *work)
 {
-	struct nvkm_disp *disp = container_of(work, struct nvkm_disp, supervisor);
+	struct nvkm_disp *disp = container_of(work, struct nvkm_disp, super.work);
 	struct nvkm_subdev *subdev = &disp->engine.subdev;
 	struct nvkm_device *device = subdev->device;
 	struct nvkm_head *head;
 	u32 stat = nvkm_rd32(device, 0x6107a8);
 	u32 mask[4];
 
-	nvkm_debug(subdev, "supervisor %d: %08x\n", ffs(disp->super), stat);
+	nvkm_debug(subdev, "supervisor %d: %08x\n", ffs(disp->super.pending), stat);
 	list_for_each_entry(head, &disp->heads, head) {
 		mask[head->id] = nvkm_rd32(device, 0x6107ac + (head->id * 4));
 		HEAD_DBG(head, "%08x", mask[head->id]);
 	}
 
-	if (disp->super & 0x00000001) {
+	if (disp->super.pending & 0x00000001) {
 		nv50_disp_chan_mthd(disp->chan[0], NV_DBG_DEBUG);
 		nv50_disp_super_1(disp);
 		list_for_each_entry(head, &disp->heads, head) {
@@ -919,7 +919,7 @@ gv100_disp_super(struct work_struct *work)
 			nv50_disp_super_1_0(disp, head);
 		}
 	} else
-	if (disp->super & 0x00000002) {
+	if (disp->super.pending & 0x00000002) {
 		list_for_each_entry(head, &disp->heads, head) {
 			if (!(mask[head->id] & 0x00001000))
 				continue;
@@ -937,7 +937,7 @@ gv100_disp_super(struct work_struct *work)
 			nv50_disp_super_2_2(disp, head);
 		}
 	} else
-	if (disp->super & 0x00000004) {
+	if (disp->super.pending & 0x00000004) {
 		list_for_each_entry(head, &disp->heads, head) {
 			if (!(mask[head->id] & 0x00001000))
 				continue;
@@ -1000,9 +1000,9 @@ gv100_disp_intr_ctrl_disp(struct nvkm_disp *disp)
 	u32 stat = nvkm_rd32(device, 0x611c30);
 
 	if (stat & 0x00000007) {
-		disp->super = (stat & 0x00000007);
-		queue_work(disp->wq, &disp->supervisor);
-		nvkm_wr32(device, 0x611860, disp->super);
+		disp->super.pending = (stat & 0x00000007);
+		queue_work(disp->super.wq, &disp->super.work);
+		nvkm_wr32(device, 0x611860, disp->super.pending);
 		stat &= ~0x00000007;
 	}
 
diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index 130e1db95032..056daf34e62c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -1521,15 +1521,15 @@ nv50_disp_super_1(struct nvkm_disp *disp)
 void
 nv50_disp_super(struct work_struct *work)
 {
-	struct nvkm_disp *disp = container_of(work, struct nvkm_disp, supervisor);
+	struct nvkm_disp *disp = container_of(work, struct nvkm_disp, super.work);
 	struct nvkm_subdev *subdev = &disp->engine.subdev;
 	struct nvkm_device *device = subdev->device;
 	struct nvkm_head *head;
 	u32 super = nvkm_rd32(device, 0x610030);
 
-	nvkm_debug(subdev, "supervisor %08x %08x\n", disp->super, super);
+	nvkm_debug(subdev, "supervisor %08x %08x\n", disp->super.pending, super);
 
-	if (disp->super & 0x00000010) {
+	if (disp->super.pending & 0x00000010) {
 		nv50_disp_chan_mthd(disp->chan[0], NV_DBG_DEBUG);
 		nv50_disp_super_1(disp);
 		list_for_each_entry(head, &disp->heads, head) {
@@ -1540,7 +1540,7 @@ nv50_disp_super(struct work_struct *work)
 			nv50_disp_super_1_0(disp, head);
 		}
 	} else
-	if (disp->super & 0x00000020) {
+	if (disp->super.pending & 0x00000020) {
 		list_for_each_entry(head, &disp->heads, head) {
 			if (!(super & (0x00000080 << head->id)))
 				continue;
@@ -1558,7 +1558,7 @@ nv50_disp_super(struct work_struct *work)
 			nv50_disp_super_2_2(disp, head);
 		}
 	} else
-	if (disp->super & 0x00000040) {
+	if (disp->super.pending & 0x00000040) {
 		list_for_each_entry(head, &disp->heads, head) {
 			if (!(super & (0x00000080 << head->id)))
 				continue;
@@ -1651,9 +1651,9 @@ nv50_disp_intr(struct nvkm_disp *disp)
 	}
 
 	if (intr1 & 0x00000070) {
-		disp->super = (intr1 & 0x00000070);
-		queue_work(disp->wq, &disp->supervisor);
-		nvkm_wr32(device, 0x610024, disp->super);
+		disp->super.pending = (intr1 & 0x00000070);
+		queue_work(disp->super.wq, &disp->super.work);
+		nvkm_wr32(device, 0x610024, disp->super.pending);
 	}
 }
 
@@ -1795,8 +1795,8 @@ nv50_disp_dtor(struct nvkm_disp *disp)
 	nvkm_gpuobj_del(&disp->inst);
 
 	nvkm_event_fini(&disp->uevent);
-	if (disp->wq)
-		destroy_workqueue(disp->wq);
+	if (disp->super.wq)
+		destroy_workqueue(disp->super.wq);
 
 	return disp;
 }
@@ -1841,11 +1841,11 @@ nv50_disp_new_(const struct nvkm_disp_func *func, struct nvkm_device *device,
 	if (ret)
 		return ret;
 
-	disp->wq = create_singlethread_workqueue("nvkm-disp");
-	if (!disp->wq)
+	disp->super.wq = create_singlethread_workqueue("nvkm-disp");
+	if (!disp->super.wq)
 		return -ENOMEM;
 
-	INIT_WORK(&disp->supervisor, func->super);
+	INIT_WORK(&disp->super.work, func->super);
 
 	return nvkm_event_init(func->uevent, 1, ARRAY_SIZE(disp->chan),
 			       &disp->uevent);
-- 
2.38.1


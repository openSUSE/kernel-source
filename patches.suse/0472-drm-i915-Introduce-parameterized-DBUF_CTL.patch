From 1a8a96d07fcbf8015c1d34a862f23bfe8cb55b52 Mon Sep 17 00:00:00 2001
From: Stanislav Lisovskiy <stanislav.lisovskiy@intel.com>
Date: Mon, 3 Feb 2020 01:06:28 +0200
Subject: drm/i915: Introduce parameterized DBUF_CTL
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Git-commit: 2570b7e3c56197e42c51d2df1ade511c3ff18190
Patch-mainline: v5.7-rc1
References: jsc#SLE-12680, jsc#SLE-12880, jsc#SLE-12882, jsc#SLE-12883, jsc#SLE-13496, jsc#SLE-15322

Now start using parameterized DBUF_CTL instead
of hardcoded, this would allow shorter access
functions when reading or storing entire state.

Tried to implement it in a MMIO_PIPE manner, however
DBUF_CTL1 address is higher than DBUF_CTL2, which
implies that we have to now subtract from base
rather than add.

v2: - Removed unneeded DBUF_CTL_DIST and DBUF_CTL_ADDR
      macros. Started to use _PICK construct as suggested
      by Matt Roper.

v3: - _DBUF_CTL_S* to DBUF_CTL_S*, changed X to "slice"
      in macro(Ville Syrjälä)
    - Introduced enum for enumerating DBUF slices(Ville Syrjälä)

Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
Signed-off-by: Stanislav Lisovskiy <stanislav.lisovskiy@intel.com>
Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20200202230630.8975-5-stanislav.lisovskiy@intel.com
Signed-off-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 .../drm/i915/display/intel_display_power.c    | 40 ++++++++++---------
 .../drm/i915/display/intel_display_power.h    |  5 +++
 drivers/gpu/drm/i915/gvt/handlers.c           |  2 +-
 drivers/gpu/drm/i915/i915_reg.h               |  6 +--
 drivers/gpu/drm/i915/intel_pm.c               |  2 +-
 5 files changed, 31 insertions(+), 24 deletions(-)

diff --git a/drivers/gpu/drm/i915/display/intel_display_power.c b/drivers/gpu/drm/i915/display/intel_display_power.c
index d88d804068ed..f5313fd7c527 100644
--- a/drivers/gpu/drm/i915/display/intel_display_power.c
+++ b/drivers/gpu/drm/i915/display/intel_display_power.c
@@ -1041,7 +1041,7 @@ static bool gen9_dc_off_power_well_enabled(struct drm_i915_private *dev_priv,
 
 static void gen9_assert_dbuf_enabled(struct drm_i915_private *dev_priv)
 {
-	u32 tmp = intel_de_read(dev_priv, DBUF_CTL);
+	u32 tmp = intel_de_read(dev_priv, DBUF_CTL_S(0));
 
 	WARN((tmp & (DBUF_POWER_STATE | DBUF_POWER_REQUEST)) !=
 	     (DBUF_POWER_STATE | DBUF_POWER_REQUEST),
@@ -4425,12 +4425,12 @@ bool intel_dbuf_slice_set(struct drm_i915_private *dev_priv,
 
 static void gen9_dbuf_enable(struct drm_i915_private *dev_priv)
 {
-	intel_dbuf_slice_set(dev_priv, DBUF_CTL, true);
+	intel_dbuf_slice_set(dev_priv, DBUF_CTL_S(0), true);
 }
 
 static void gen9_dbuf_disable(struct drm_i915_private *dev_priv)
 {
-	intel_dbuf_slice_set(dev_priv, DBUF_CTL, false);
+	intel_dbuf_slice_set(dev_priv, DBUF_CTL_S(0), false);
 }
 
 static u8 intel_dbuf_max_slices(struct drm_i915_private *dev_priv)
@@ -4456,9 +4456,11 @@ void icl_dbuf_slices_update(struct drm_i915_private *dev_priv,
 		return;
 
 	if (req_slices > hw_enabled_slices)
-		ret = intel_dbuf_slice_set(dev_priv, DBUF_CTL_S2, true);
+		ret = intel_dbuf_slice_set(dev_priv,
+					   DBUF_CTL_S(DBUF_S2), true);
 	else
-		ret = intel_dbuf_slice_set(dev_priv, DBUF_CTL_S2, false);
+		ret = intel_dbuf_slice_set(dev_priv,
+					   DBUF_CTL_S(DBUF_S2), false);
 
 	if (ret)
 		dev_priv->enabled_dbuf_slices_num = req_slices;
@@ -4466,16 +4468,16 @@ void icl_dbuf_slices_update(struct drm_i915_private *dev_priv,
 
 static void icl_dbuf_enable(struct drm_i915_private *dev_priv)
 {
-	intel_de_write(dev_priv, DBUF_CTL_S1,
-		       intel_de_read(dev_priv, DBUF_CTL_S1) | DBUF_POWER_REQUEST);
-	intel_de_write(dev_priv, DBUF_CTL_S2,
-		       intel_de_read(dev_priv, DBUF_CTL_S2) | DBUF_POWER_REQUEST);
-	intel_de_posting_read(dev_priv, DBUF_CTL_S2);
+	intel_de_write(dev_priv, DBUF_CTL_S(0),
+		       intel_de_read(dev_priv, DBUF_CTL_S(0)) | DBUF_POWER_REQUEST);
+	intel_de_write(dev_priv, DBUF_CTL_S(1),
+		       intel_de_read(dev_priv, DBUF_CTL_S(1)) | DBUF_POWER_REQUEST);
+	intel_de_posting_read(dev_priv, DBUF_CTL_S(1));
 
 	udelay(10);
 
-	if (!(intel_de_read(dev_priv, DBUF_CTL_S1) & DBUF_POWER_STATE) ||
-	    !(intel_de_read(dev_priv, DBUF_CTL_S2) & DBUF_POWER_STATE))
+	if (!(intel_de_read(dev_priv, DBUF_CTL_S(0)) & DBUF_POWER_STATE) ||
+	    !(intel_de_read(dev_priv, DBUF_CTL_S(1)) & DBUF_POWER_STATE))
 		drm_err(&dev_priv->drm, "DBuf power enable timeout\n");
 	else
 		/*
@@ -4487,16 +4489,16 @@ static void icl_dbuf_enable(struct drm_i915_private *dev_priv)
 
 static void icl_dbuf_disable(struct drm_i915_private *dev_priv)
 {
-	intel_de_write(dev_priv, DBUF_CTL_S1,
-		       intel_de_read(dev_priv, DBUF_CTL_S1) & ~DBUF_POWER_REQUEST);
-	intel_de_write(dev_priv, DBUF_CTL_S2,
-		       intel_de_read(dev_priv, DBUF_CTL_S2) & ~DBUF_POWER_REQUEST);
-	intel_de_posting_read(dev_priv, DBUF_CTL_S2);
+	intel_de_write(dev_priv, DBUF_CTL_S(0),
+		       intel_de_read(dev_priv, DBUF_CTL_S(0)) & ~DBUF_POWER_REQUEST);
+	intel_de_write(dev_priv, DBUF_CTL_S(1),
+		       intel_de_read(dev_priv, DBUF_CTL_S(1)) & ~DBUF_POWER_REQUEST);
+	intel_de_posting_read(dev_priv, DBUF_CTL_S(1));
 
 	udelay(10);
 
-	if ((intel_de_read(dev_priv, DBUF_CTL_S1) & DBUF_POWER_STATE) ||
-	    (intel_de_read(dev_priv, DBUF_CTL_S2) & DBUF_POWER_STATE))
+	if ((intel_de_read(dev_priv, DBUF_CTL_S(0)) & DBUF_POWER_STATE) ||
+	    (intel_de_read(dev_priv, DBUF_CTL_S(1)) & DBUF_POWER_STATE))
 		drm_err(&dev_priv->drm, "DBuf power disable timeout!\n");
 	else
 		/*
diff --git a/drivers/gpu/drm/i915/display/intel_display_power.h b/drivers/gpu/drm/i915/display/intel_display_power.h
index 2608a65af7fa..601e000ffd0d 100644
--- a/drivers/gpu/drm/i915/display/intel_display_power.h
+++ b/drivers/gpu/drm/i915/display/intel_display_power.h
@@ -307,6 +307,11 @@ intel_display_power_put_async(struct drm_i915_private *i915,
 }
 #endif
 
+enum dbuf_slice {
+	DBUF_S1,
+	DBUF_S2,
+};
+
 #define with_intel_display_power(i915, domain, wf) \
 	for ((wf) = intel_display_power_get((i915), (domain)); (wf); \
 	     intel_display_power_put_async((i915), (domain), (wf)), (wf) = 0)
diff --git a/drivers/gpu/drm/i915/gvt/handlers.c b/drivers/gpu/drm/i915/gvt/handlers.c
index 18475dd377ed..ae6700dc9d73 100644
--- a/drivers/gpu/drm/i915/gvt/handlers.c
+++ b/drivers/gpu/drm/i915/gvt/handlers.c
@@ -2902,7 +2902,7 @@ static int init_skl_mmio_info(struct intel_gvt *gvt)
 	MMIO_D(HSW_PWR_WELL_CTL1, D_SKL_PLUS);
 	MMIO_DH(HSW_PWR_WELL_CTL2, D_SKL_PLUS, NULL, skl_power_well_ctl_write);
 
-	MMIO_DH(DBUF_CTL, D_SKL_PLUS, NULL, gen9_dbuf_ctl_mmio_write);
+	MMIO_DH(DBUF_CTL_S(0), D_SKL_PLUS, NULL, gen9_dbuf_ctl_mmio_write);
 
 	MMIO_D(GEN9_PG_ENABLE, D_SKL_PLUS);
 	MMIO_D(GEN9_MEDIA_PG_IDLE_HYSTERESIS, D_SKL_PLUS);
diff --git a/drivers/gpu/drm/i915/i915_reg.h b/drivers/gpu/drm/i915/i915_reg.h
index 364d7001f15c..3a0d0d74e6a2 100644
--- a/drivers/gpu/drm/i915/i915_reg.h
+++ b/drivers/gpu/drm/i915/i915_reg.h
@@ -7753,9 +7753,9 @@ enum {
 #define DISP_ARB_CTL2	_MMIO(0x45004)
 #define  DISP_DATA_PARTITION_5_6	(1 << 6)
 #define  DISP_IPC_ENABLE		(1 << 3)
-#define DBUF_CTL	_MMIO(0x45008)
-#define DBUF_CTL_S1	_MMIO(0x45008)
-#define DBUF_CTL_S2	_MMIO(0x44FE8)
+#define _DBUF_CTL_S1			0x45008
+#define _DBUF_CTL_S2			0x44FE8
+#define DBUF_CTL_S(slice)		_MMIO(_PICK_EVEN(slice, _DBUF_CTL_S1, _DBUF_CTL_S2))
 #define  DBUF_POWER_REQUEST		(1 << 31)
 #define  DBUF_POWER_STATE		(1 << 30)
 #define GEN7_MSG_CTL	_MMIO(0x45010)
diff --git a/drivers/gpu/drm/i915/intel_pm.c b/drivers/gpu/drm/i915/intel_pm.c
index 89aa188c8cf5..f9e00ca61302 100644
--- a/drivers/gpu/drm/i915/intel_pm.c
+++ b/drivers/gpu/drm/i915/intel_pm.c
@@ -3613,7 +3613,7 @@ u8 intel_enabled_dbuf_slices_num(struct drm_i915_private *dev_priv)
 	 * only that 1 slice enabled until we have a proper way for on-demand
 	 * toggling of the second slice.
 	 */
-	if (0 && I915_READ(DBUF_CTL_S2) & DBUF_POWER_STATE)
+	if (0 && I915_READ(DBUF_CTL_S(DBUF_S2)) & DBUF_POWER_STATE)
 		enabled_dbuf_slices_num++;
 
 	return enabled_dbuf_slices_num;
-- 
2.28.0


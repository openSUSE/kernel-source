From 0f1a14e0348eb48e93e139af569944349b725f3f Mon Sep 17 00:00:00 2001
From: Heiko Carstens <hca@linux.ibm.com>
Date: Thu, 12 Oct 2023 09:40:48 +0200
Subject: [PATCH] s390/mm,fault: simplify kfence fault handling
Git-commit: 0f1a14e0348eb48e93e139af569944349b725f3f
Patch-mainline: v6.7-rc1
References: bsc#1247076

do_no_context() can be simplified by removing its fault parameter,
which is only used to decide if kfence_handle_page_fault() should be
called.

If the fault happened within the kernel space it is ok to always check
if this happened on a page which was unmapped because of the kfence
feature. Limiting the check to the VM_FAULT_BADCONTEXT case doesn't
add any value.

Reviewed-by: Claudio Imbrenda <imbrenda@linux.ibm.com>
Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
Signed-off-by: Michal Hocko <mhockO@suse.com>

---
 arch/s390/mm/fault.c |   16 ++++++++--------
 1 file changed, 8 insertions(+), 8 deletions(-)

--- a/arch/s390/mm/fault.c
+++ b/arch/s390/mm/fault.c
@@ -246,7 +246,7 @@ static noinline void do_sigsegv(struct p
 			(void __user *)(regs->int_parm_long & __FAIL_ADDR_MASK));
 }
 
-static noinline void do_no_context(struct pt_regs *regs, vm_fault_t fault)
+static noinline void do_no_context(struct pt_regs *regs)
 {
 	enum fault_type fault_type;
 	unsigned long address;
@@ -255,7 +255,7 @@ static noinline void do_no_context(struc
 	if (fixup_exception(regs))
 		return;
 	fault_type = get_fault_type(regs);
-	if ((fault_type == KERNEL_FAULT) && (fault == VM_FAULT_BADCONTEXT)) {
+	if (fault_type == KERNEL_FAULT) {
 		address = get_fault_address(regs);
 		is_write = fault_is_write(regs);
 		if (kfence_handle_page_fault(address, is_write, regs))
@@ -284,7 +284,7 @@ static noinline void do_low_address(stru
 		die (regs, "Low-address protection");
 	}
 
-	do_no_context(regs, VM_FAULT_BADACCESS);
+	do_no_context(regs);
 }
 
 static noinline void do_sigbus(struct pt_regs *regs)
@@ -315,28 +315,28 @@ static noinline void do_fault_error(stru
 		fallthrough;
 	case VM_FAULT_BADCONTEXT:
 	case VM_FAULT_PFAULT:
-		do_no_context(regs, fault);
+		do_no_context(regs);
 		break;
 	case VM_FAULT_SIGNAL:
 		if (!user_mode(regs))
-			do_no_context(regs, fault);
+			do_no_context(regs);
 		break;
 	default: /* fault & VM_FAULT_ERROR */
 		if (fault & VM_FAULT_OOM) {
 			if (!user_mode(regs))
-				do_no_context(regs, fault);
+				do_no_context(regs);
 			else
 				pagefault_out_of_memory();
 		} else if (fault & VM_FAULT_SIGSEGV) {
 			/* Kernel mode? Handle exceptions or die */
 			if (!user_mode(regs))
-				do_no_context(regs, fault);
+				do_no_context(regs);
 			else
 				do_sigsegv(regs, SEGV_MAPERR);
 		} else if (fault & VM_FAULT_SIGBUS) {
 			/* Kernel mode? Handle exceptions or die */
 			if (!user_mode(regs))
-				do_no_context(regs, fault);
+				do_no_context(regs);
 			else
 				do_sigbus(regs);
 		} else

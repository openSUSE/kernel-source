From 440961d20959e8528a86e054b0a762d9ca9c7e91 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Noralf=20Tr=C3=B8nnes?= <noralf@tronnes.org>
Date: Mon, 22 Jul 2019 12:43:06 +0200
Subject: drm/tinydrm: Rename remaining variable mipi -> dbidev
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Git-commit: 440961d20959e8528a86e054b0a762d9ca9c7e91
Patch-mainline: v5.4-rc1
References: bsc#1152472

struct mipi_dbi is going to be split into an interface part and a display
pipeline part. The interface part can be used by drivers that need to
initialize the controller, but that won't upload the framebuffer over
this interface.

tinydrm uses the variable name 'mipi' but this is not a good name since
MIPI refers to a lot of standards. This patch changes the variable name
to 'dbidev' where it refers to the pipeline part of struct mipi_dbi.

Cc: Eric Anholt <eric@anholt.net>
Cc: David Lechner <david@lechnology.com>
Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
Signed-off-by: Noralf Tr√∏nnes <noralf@tronnes.org>
Acked-by: David Lechner <david@lechnology.com>
Acked-by: Eric Anholt <eric@anholt.net>
Link: https://patchwork.freedesktop.org/patch/msgid/20190722104312.16184-4-noralf@tronnes.org
Acked-by: Thomas Zimmermann <tzimmermann@suse.de>
---
 drivers/gpu/drm/tinydrm/hx8357d.c  |  30 ++++----
 drivers/gpu/drm/tinydrm/ili9225.c  |  42 +++++-----
 drivers/gpu/drm/tinydrm/ili9341.c  |  30 ++++----
 drivers/gpu/drm/tinydrm/mi0283qt.c |  36 ++++-----
 drivers/gpu/drm/tinydrm/mipi-dbi.c | 120 ++++++++++++++---------------
 drivers/gpu/drm/tinydrm/st7586.c   |  34 ++++----
 drivers/gpu/drm/tinydrm/st7735r.c  |  30 ++++----
 include/drm/tinydrm/mipi-dbi.h     |  10 +--
 8 files changed, 166 insertions(+), 166 deletions(-)

diff --git a/drivers/gpu/drm/tinydrm/hx8357d.c b/drivers/gpu/drm/tinydrm/hx8357d.c
index f503d14aa36b..e113c434ff55 100644
--- a/drivers/gpu/drm/tinydrm/hx8357d.c
+++ b/drivers/gpu/drm/tinydrm/hx8357d.c
@@ -47,8 +47,8 @@ static void yx240qv29_enable(struct drm_simple_display_pipe *pipe,
 			     struct drm_crtc_state *crtc_state,
 			     struct drm_plane_state *plane_state)
 {
-	struct mipi_dbi *mipi = drm_to_mipi_dbi(pipe->crtc.dev);
-	struct mipi_dbi *dbi = mipi;
+	struct mipi_dbi *dbidev = drm_to_mipi_dbi(pipe->crtc.dev);
+	struct mipi_dbi *dbi = dbidev;
 	u8 addr_mode;
 	int ret, idx;
 
@@ -57,7 +57,7 @@ static void yx240qv29_enable(struct drm_simple_display_pipe *pipe,
 
 	DRM_DEBUG_KMS("\n");
 
-	ret = mipi_dbi_poweron_conditional_reset(mipi);
+	ret = mipi_dbi_poweron_conditional_reset(dbidev);
 	if (ret < 0)
 		goto out_exit;
 	if (ret == 1)
@@ -159,7 +159,7 @@ static void yx240qv29_enable(struct drm_simple_display_pipe *pipe,
 	usleep_range(5000, 7000);
 
 out_enable:
-	switch (mipi->rotation) {
+	switch (dbidev->rotation) {
 	default:
 		addr_mode = HX8357D_MADCTL_MX | HX8357D_MADCTL_MY;
 		break;
@@ -174,7 +174,7 @@ static void yx240qv29_enable(struct drm_simple_display_pipe *pipe,
 		break;
 	}
 	mipi_dbi_command(dbi, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);
-	mipi_dbi_enable_flush(mipi, crtc_state, plane_state);
+	mipi_dbi_enable_flush(dbidev, crtc_state, plane_state);
 out_exit:
 	drm_dev_exit(idx);
 }
@@ -220,20 +220,20 @@ MODULE_DEVICE_TABLE(spi, hx8357d_id);
 static int hx8357d_probe(struct spi_device *spi)
 {
 	struct device *dev = &spi->dev;
+	struct mipi_dbi *dbidev;
 	struct drm_device *drm;
-	struct mipi_dbi *mipi;
 	struct gpio_desc *dc;
 	u32 rotation = 0;
 	int ret;
 
-	mipi = kzalloc(sizeof(*mipi), GFP_KERNEL);
-	if (!mipi)
+	dbidev = kzalloc(sizeof(*dbidev), GFP_KERNEL);
+	if (!dbidev)
 		return -ENOMEM;
 
-	drm = &mipi->drm;
+	drm = &dbidev->drm;
 	ret = devm_drm_dev_init(dev, drm, &hx8357d_driver);
 	if (ret) {
-		kfree(mipi);
+		kfree(dbidev);
 		return ret;
 	}
 
@@ -245,17 +245,17 @@ static int hx8357d_probe(struct spi_device *spi)
 		return PTR_ERR(dc);
 	}
 
-	mipi->backlight = devm_of_find_backlight(dev);
-	if (IS_ERR(mipi->backlight))
-		return PTR_ERR(mipi->backlight);
+	dbidev->backlight = devm_of_find_backlight(dev);
+	if (IS_ERR(dbidev->backlight))
+		return PTR_ERR(dbidev->backlight);
 
 	device_property_read_u32(dev, "rotation", &rotation);
 
-	ret = mipi_dbi_spi_init(spi, mipi, dc);
+	ret = mipi_dbi_spi_init(spi, dbidev, dc);
 	if (ret)
 		return ret;
 
-	ret = mipi_dbi_init(mipi, &hx8357d_pipe_funcs, &yx350hv15_mode, rotation);
+	ret = mipi_dbi_init(dbidev, &hx8357d_pipe_funcs, &yx350hv15_mode, rotation);
 	if (ret)
 		return ret;
 
diff --git a/drivers/gpu/drm/tinydrm/ili9225.c b/drivers/gpu/drm/tinydrm/ili9225.c
index c837d1423362..209a75dab7ce 100644
--- a/drivers/gpu/drm/tinydrm/ili9225.c
+++ b/drivers/gpu/drm/tinydrm/ili9225.c
@@ -78,10 +78,10 @@ static inline int ili9225_command(struct mipi_dbi *dbi, u8 cmd, u16 data)
 static void ili9225_fb_dirty(struct drm_framebuffer *fb, struct drm_rect *rect)
 {
 	struct drm_gem_cma_object *cma_obj = drm_fb_cma_get_gem_obj(fb, 0);
-	struct mipi_dbi *mipi = drm_to_mipi_dbi(fb->dev);
+	struct mipi_dbi *dbidev = drm_to_mipi_dbi(fb->dev);
 	unsigned int height = rect->y2 - rect->y1;
 	unsigned int width = rect->x2 - rect->x1;
-	struct mipi_dbi *dbi = mipi;
+	struct mipi_dbi *dbi = dbidev;
 	bool swap = dbi->swap_bytes;
 	u16 x_start, y_start;
 	u16 x1, x2, y1, y2;
@@ -89,7 +89,7 @@ static void ili9225_fb_dirty(struct drm_framebuffer *fb, struct drm_rect *rect)
 	bool full;
 	void *tr;
 
-	if (!mipi->enabled)
+	if (!dbidev->enabled)
 		return;
 
 	if (!drm_dev_enter(fb->dev, &idx))
@@ -101,15 +101,15 @@ static void ili9225_fb_dirty(struct drm_framebuffer *fb, struct drm_rect *rect)
 
 	if (!dbi->dc || !full || swap ||
 	    fb->format->format == DRM_FORMAT_XRGB8888) {
-		tr = mipi->tx_buf;
-		ret = mipi_dbi_buf_copy(mipi->tx_buf, fb, rect, swap);
+		tr = dbidev->tx_buf;
+		ret = mipi_dbi_buf_copy(dbidev->tx_buf, fb, rect, swap);
 		if (ret)
 			goto err_msg;
 	} else {
 		tr = cma_obj->vaddr;
 	}
 
-	switch (mipi->rotation) {
+	switch (dbidev->rotation) {
 	default:
 		x1 = rect->x1;
 		x2 = rect->x2 - 1;
@@ -183,10 +183,10 @@ static void ili9225_pipe_enable(struct drm_simple_display_pipe *pipe,
 				struct drm_crtc_state *crtc_state,
 				struct drm_plane_state *plane_state)
 {
-	struct mipi_dbi *mipi = drm_to_mipi_dbi(pipe->crtc.dev);
+	struct mipi_dbi *dbidev = drm_to_mipi_dbi(pipe->crtc.dev);
 	struct drm_framebuffer *fb = plane_state->fb;
 	struct device *dev = pipe->crtc.dev->dev;
-	struct mipi_dbi *dbi = mipi;
+	struct mipi_dbi *dbi = dbidev;
 	struct drm_rect rect = {
 		.x1 = 0,
 		.x2 = fb->width,
@@ -233,7 +233,7 @@ static void ili9225_pipe_enable(struct drm_simple_display_pipe *pipe,
 
 	msleep(50);
 
-	switch (mipi->rotation) {
+	switch (dbidev->rotation) {
 	default:
 		am_id = 0x30;
 		break;
@@ -283,7 +283,7 @@ static void ili9225_pipe_enable(struct drm_simple_display_pipe *pipe,
 
 	ili9225_command(dbi, ILI9225_DISPLAY_CONTROL_1, 0x1017);
 
-	mipi->enabled = true;
+	dbidev->enabled = true;
 	ili9225_fb_dirty(fb, &rect);
 out_exit:
 	drm_dev_exit(idx);
@@ -291,8 +291,8 @@ static void ili9225_pipe_enable(struct drm_simple_display_pipe *pipe,
 
 static void ili9225_pipe_disable(struct drm_simple_display_pipe *pipe)
 {
-	struct mipi_dbi *mipi = drm_to_mipi_dbi(pipe->crtc.dev);
-	struct mipi_dbi *dbi = mipi;
+	struct mipi_dbi *dbidev = drm_to_mipi_dbi(pipe->crtc.dev);
+	struct mipi_dbi *dbi = dbidev;
 
 	DRM_DEBUG_KMS("\n");
 
@@ -303,7 +303,7 @@ static void ili9225_pipe_disable(struct drm_simple_display_pipe *pipe)
 	 * unplug.
 	 */
 
-	if (!mipi->enabled)
+	if (!dbidev->enabled)
 		return;
 
 	ili9225_command(dbi, ILI9225_DISPLAY_CONTROL_1, 0x0000);
@@ -312,7 +312,7 @@ static void ili9225_pipe_disable(struct drm_simple_display_pipe *pipe)
 	msleep(50);
 	ili9225_command(dbi, ILI9225_POWER_CONTROL_1, 0x0a02);
 
-	mipi->enabled = false;
+	dbidev->enabled = false;
 }
 
 static int ili9225_dbi_command(struct mipi_dbi *dbi, u8 *cmd, u8 *par,
@@ -378,22 +378,22 @@ MODULE_DEVICE_TABLE(spi, ili9225_id);
 static int ili9225_probe(struct spi_device *spi)
 {
 	struct device *dev = &spi->dev;
+	struct mipi_dbi *dbidev;
 	struct drm_device *drm;
-	struct mipi_dbi *mipi;
 	struct mipi_dbi *dbi;
 	struct gpio_desc *rs;
 	u32 rotation = 0;
 	int ret;
 
-	mipi = kzalloc(sizeof(*mipi), GFP_KERNEL);
-	if (!mipi)
+	dbidev = kzalloc(sizeof(*dbidev), GFP_KERNEL);
+	if (!dbidev)
 		return -ENOMEM;
 
-	dbi = mipi;
-	drm = &mipi->drm;
+	dbi = dbidev;
+	drm = &dbidev->drm;
 	ret = devm_drm_dev_init(dev, drm, &ili9225_driver);
 	if (ret) {
-		kfree(mipi);
+		kfree(dbidev);
 		return ret;
 	}
 
@@ -420,7 +420,7 @@ static int ili9225_probe(struct spi_device *spi)
 	/* override the command function set in  mipi_dbi_spi_init() */
 	dbi->command = ili9225_dbi_command;
 
-	ret = mipi_dbi_init(mipi, &ili9225_pipe_funcs, &ili9225_mode, rotation);
+	ret = mipi_dbi_init(dbidev, &ili9225_pipe_funcs, &ili9225_mode, rotation);
 	if (ret)
 		return ret;
 
diff --git a/drivers/gpu/drm/tinydrm/ili9341.c b/drivers/gpu/drm/tinydrm/ili9341.c
index 05ba5ab17ec6..dfa8c6e952c8 100644
--- a/drivers/gpu/drm/tinydrm/ili9341.c
+++ b/drivers/gpu/drm/tinydrm/ili9341.c
@@ -53,8 +53,8 @@ static void yx240qv29_enable(struct drm_simple_display_pipe *pipe,
 			     struct drm_crtc_state *crtc_state,
 			     struct drm_plane_state *plane_state)
 {
-	struct mipi_dbi *mipi = drm_to_mipi_dbi(pipe->crtc.dev);
-	struct mipi_dbi *dbi = mipi;
+	struct mipi_dbi *dbidev = drm_to_mipi_dbi(pipe->crtc.dev);
+	struct mipi_dbi *dbi = dbidev;
 	u8 addr_mode;
 	int ret, idx;
 
@@ -63,7 +63,7 @@ static void yx240qv29_enable(struct drm_simple_display_pipe *pipe,
 
 	DRM_DEBUG_KMS("\n");
 
-	ret = mipi_dbi_poweron_conditional_reset(mipi);
+	ret = mipi_dbi_poweron_conditional_reset(dbidev);
 	if (ret < 0)
 		goto out_exit;
 	if (ret == 1)
@@ -113,7 +113,7 @@ static void yx240qv29_enable(struct drm_simple_display_pipe *pipe,
 	msleep(100);
 
 out_enable:
-	switch (mipi->rotation) {
+	switch (dbidev->rotation) {
 	default:
 		addr_mode = ILI9341_MADCTL_MX;
 		break;
@@ -130,7 +130,7 @@ static void yx240qv29_enable(struct drm_simple_display_pipe *pipe,
 	}
 	addr_mode |= ILI9341_MADCTL_BGR;
 	mipi_dbi_command(dbi, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);
-	mipi_dbi_enable_flush(mipi, crtc_state, plane_state);
+	mipi_dbi_enable_flush(dbidev, crtc_state, plane_state);
 out_exit:
 	drm_dev_exit(idx);
 }
@@ -176,22 +176,22 @@ MODULE_DEVICE_TABLE(spi, ili9341_id);
 static int ili9341_probe(struct spi_device *spi)
 {
 	struct device *dev = &spi->dev;
+	struct mipi_dbi *dbidev;
 	struct drm_device *drm;
-	struct mipi_dbi *mipi;
 	struct mipi_dbi *dbi;
 	struct gpio_desc *dc;
 	u32 rotation = 0;
 	int ret;
 
-	mipi = kzalloc(sizeof(*mipi), GFP_KERNEL);
-	if (!mipi)
+	dbidev = kzalloc(sizeof(*dbidev), GFP_KERNEL);
+	if (!dbidev)
 		return -ENOMEM;
 
-	dbi = mipi;
-	drm = &mipi->drm;
+	dbi = dbidev;
+	drm = &dbidev->drm;
 	ret = devm_drm_dev_init(dev, drm, &ili9341_driver);
 	if (ret) {
-		kfree(mipi);
+		kfree(dbidev);
 		return ret;
 	}
 
@@ -209,9 +209,9 @@ static int ili9341_probe(struct spi_device *spi)
 		return PTR_ERR(dc);
 	}
 
-	mipi->backlight = devm_of_find_backlight(dev);
-	if (IS_ERR(mipi->backlight))
-		return PTR_ERR(mipi->backlight);
+	dbidev->backlight = devm_of_find_backlight(dev);
+	if (IS_ERR(dbidev->backlight))
+		return PTR_ERR(dbidev->backlight);
 
 	device_property_read_u32(dev, "rotation", &rotation);
 
@@ -219,7 +219,7 @@ static int ili9341_probe(struct spi_device *spi)
 	if (ret)
 		return ret;
 
-	ret = mipi_dbi_init(mipi, &ili9341_pipe_funcs, &yx240qv29_mode, rotation);
+	ret = mipi_dbi_init(dbidev, &ili9341_pipe_funcs, &yx240qv29_mode, rotation);
 	if (ret)
 		return ret;
 
diff --git a/drivers/gpu/drm/tinydrm/mi0283qt.c b/drivers/gpu/drm/tinydrm/mi0283qt.c
index adc8c4872d3f..9d284fb24c36 100644
--- a/drivers/gpu/drm/tinydrm/mi0283qt.c
+++ b/drivers/gpu/drm/tinydrm/mi0283qt.c
@@ -51,8 +51,8 @@ static void mi0283qt_enable(struct drm_simple_display_pipe *pipe,
 			    struct drm_crtc_state *crtc_state,
 			    struct drm_plane_state *plane_state)
 {
-	struct mipi_dbi *mipi = drm_to_mipi_dbi(pipe->crtc.dev);
-	struct mipi_dbi *dbi = mipi;
+	struct mipi_dbi *dbidev = drm_to_mipi_dbi(pipe->crtc.dev);
+	struct mipi_dbi *dbi = dbidev;
 	u8 addr_mode;
 	int ret, idx;
 
@@ -61,7 +61,7 @@ static void mi0283qt_enable(struct drm_simple_display_pipe *pipe,
 
 	DRM_DEBUG_KMS("\n");
 
-	ret = mipi_dbi_poweron_conditional_reset(mipi);
+	ret = mipi_dbi_poweron_conditional_reset(dbidev);
 	if (ret < 0)
 		goto out_exit;
 	if (ret == 1)
@@ -117,7 +117,7 @@ static void mi0283qt_enable(struct drm_simple_display_pipe *pipe,
 	 * As a result, we need to always apply the rotation value
 	 * regardless of the display "on/off" state.
 	 */
-	switch (mipi->rotation) {
+	switch (dbidev->rotation) {
 	default:
 		addr_mode = ILI9341_MADCTL_MV | ILI9341_MADCTL_MY |
 			    ILI9341_MADCTL_MX;
@@ -134,7 +134,7 @@ static void mi0283qt_enable(struct drm_simple_display_pipe *pipe,
 	}
 	addr_mode |= ILI9341_MADCTL_BGR;
 	mipi_dbi_command(dbi, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);
-	mipi_dbi_enable_flush(mipi, crtc_state, plane_state);
+	mipi_dbi_enable_flush(dbidev, crtc_state, plane_state);
 out_exit:
 	drm_dev_exit(idx);
 }
@@ -180,22 +180,22 @@ MODULE_DEVICE_TABLE(spi, mi0283qt_id);
 static int mi0283qt_probe(struct spi_device *spi)
 {
 	struct device *dev = &spi->dev;
+	struct mipi_dbi *dbidev;
 	struct drm_device *drm;
-	struct mipi_dbi *mipi;
 	struct mipi_dbi *dbi;
 	struct gpio_desc *dc;
 	u32 rotation = 0;
 	int ret;
 
-	mipi = kzalloc(sizeof(*mipi), GFP_KERNEL);
-	if (!mipi)
+	dbidev = kzalloc(sizeof(*dbidev), GFP_KERNEL);
+	if (!dbidev)
 		return -ENOMEM;
 
-	dbi = mipi;
-	drm = &mipi->drm;
+	dbi = dbidev;
+	drm = &dbidev->drm;
 	ret = devm_drm_dev_init(dev, drm, &mi0283qt_driver);
 	if (ret) {
-		kfree(mipi);
+		kfree(dbidev);
 		return ret;
 	}
 
@@ -213,13 +213,13 @@ static int mi0283qt_probe(struct spi_device *spi)
 		return PTR_ERR(dc);
 	}
 
-	mipi->regulator = devm_regulator_get(dev, "power");
-	if (IS_ERR(mipi->regulator))
-		return PTR_ERR(mipi->regulator);
+	dbidev->regulator = devm_regulator_get(dev, "power");
+	if (IS_ERR(dbidev->regulator))
+		return PTR_ERR(dbidev->regulator);
 
-	mipi->backlight = devm_of_find_backlight(dev);
-	if (IS_ERR(mipi->backlight))
-		return PTR_ERR(mipi->backlight);
+	dbidev->backlight = devm_of_find_backlight(dev);
+	if (IS_ERR(dbidev->backlight))
+		return PTR_ERR(dbidev->backlight);
 
 	device_property_read_u32(dev, "rotation", &rotation);
 
@@ -227,7 +227,7 @@ static int mi0283qt_probe(struct spi_device *spi)
 	if (ret)
 		return ret;
 
-	ret = mipi_dbi_init(mipi, &mi0283qt_pipe_funcs, &mi0283qt_mode, rotation);
+	ret = mipi_dbi_init(dbidev, &mi0283qt_pipe_funcs, &mi0283qt_mode, rotation);
 	if (ret)
 		return ret;
 
diff --git a/drivers/gpu/drm/tinydrm/mipi-dbi.c b/drivers/gpu/drm/tinydrm/mipi-dbi.c
index 93b9b3ac5568..95b032a4b34b 100644
--- a/drivers/gpu/drm/tinydrm/mipi-dbi.c
+++ b/drivers/gpu/drm/tinydrm/mipi-dbi.c
@@ -241,16 +241,16 @@ EXPORT_SYMBOL(mipi_dbi_buf_copy);
 static void mipi_dbi_fb_dirty(struct drm_framebuffer *fb, struct drm_rect *rect)
 {
 	struct drm_gem_cma_object *cma_obj = drm_fb_cma_get_gem_obj(fb, 0);
-	struct mipi_dbi *mipi = drm_to_mipi_dbi(fb->dev);
+	struct mipi_dbi *dbidev = drm_to_mipi_dbi(fb->dev);
 	unsigned int height = rect->y2 - rect->y1;
 	unsigned int width = rect->x2 - rect->x1;
-	struct mipi_dbi *dbi = mipi;
+	struct mipi_dbi *dbi = dbidev;
 	bool swap = dbi->swap_bytes;
 	int idx, ret = 0;
 	bool full;
 	void *tr;
 
-	if (!mipi->enabled)
+	if (!dbidev->enabled)
 		return;
 
 	if (!drm_dev_enter(fb->dev, &idx))
@@ -262,8 +262,8 @@ static void mipi_dbi_fb_dirty(struct drm_framebuffer *fb, struct drm_rect *rect)
 
 	if (!dbi->dc || !full || swap ||
 	    fb->format->format == DRM_FORMAT_XRGB8888) {
-		tr = mipi->tx_buf;
-		ret = mipi_dbi_buf_copy(mipi->tx_buf, fb, rect, swap);
+		tr = dbidev->tx_buf;
+		ret = mipi_dbi_buf_copy(dbidev->tx_buf, fb, rect, swap);
 		if (ret)
 			goto err_msg;
 	} else {
@@ -315,7 +315,7 @@ EXPORT_SYMBOL(mipi_dbi_pipe_update);
 
 /**
  * mipi_dbi_enable_flush - MIPI DBI enable helper
- * @mipi: MIPI DBI structure
+ * @dbidev: MIPI DBI device structure
  * @crtc_state: CRTC state
  * @plane_state: Plane state
  *
@@ -327,7 +327,7 @@ EXPORT_SYMBOL(mipi_dbi_pipe_update);
  * framebuffer flushing, can't use this function since they both use the same
  * flushing code.
  */
-void mipi_dbi_enable_flush(struct mipi_dbi *mipi,
+void mipi_dbi_enable_flush(struct mipi_dbi *dbidev,
 			   struct drm_crtc_state *crtc_state,
 			   struct drm_plane_state *plane_state)
 {
@@ -340,37 +340,37 @@ void mipi_dbi_enable_flush(struct mipi_dbi *mipi,
 	};
 	int idx;
 
-	if (!drm_dev_enter(&mipi->drm, &idx))
+	if (!drm_dev_enter(&dbidev->drm, &idx))
 		return;
 
-	mipi->enabled = true;
+	dbidev->enabled = true;
 	mipi_dbi_fb_dirty(fb, &rect);
-	backlight_enable(mipi->backlight);
+	backlight_enable(dbidev->backlight);
 
 	drm_dev_exit(idx);
 }
 EXPORT_SYMBOL(mipi_dbi_enable_flush);
 
-static void mipi_dbi_blank(struct mipi_dbi *mipi)
+static void mipi_dbi_blank(struct mipi_dbi *dbidev)
 {
-	struct drm_device *drm = &mipi->drm;
+	struct drm_device *drm = &dbidev->drm;
 	u16 height = drm->mode_config.min_height;
 	u16 width = drm->mode_config.min_width;
 	size_t len = width * height * 2;
-	struct mipi_dbi *dbi = mipi;
+	struct mipi_dbi *dbi = dbidev;
 	int idx;
 
 	if (!drm_dev_enter(drm, &idx))
 		return;
 
-	memset(mipi->tx_buf, 0, len);
+	memset(dbidev->tx_buf, 0, len);
 
 	mipi_dbi_command(dbi, MIPI_DCS_SET_COLUMN_ADDRESS, 0, 0,
 			 (width >> 8) & 0xFF, (width - 1) & 0xFF);
 	mipi_dbi_command(dbi, MIPI_DCS_SET_PAGE_ADDRESS, 0, 0,
 			 (height >> 8) & 0xFF, (height - 1) & 0xFF);
 	mipi_dbi_command_buf(dbi, MIPI_DCS_WRITE_MEMORY_START,
-			     (u8 *)mipi->tx_buf, len);
+			     (u8 *)dbidev->tx_buf, len);
 
 	drm_dev_exit(idx);
 }
@@ -385,31 +385,31 @@ static void mipi_dbi_blank(struct mipi_dbi *mipi)
  */
 void mipi_dbi_pipe_disable(struct drm_simple_display_pipe *pipe)
 {
-	struct mipi_dbi *mipi = drm_to_mipi_dbi(pipe->crtc.dev);
+	struct mipi_dbi *dbidev = drm_to_mipi_dbi(pipe->crtc.dev);
 
-	if (!mipi->enabled)
+	if (!dbidev->enabled)
 		return;
 
 	DRM_DEBUG_KMS("\n");
 
-	mipi->enabled = false;
+	dbidev->enabled = false;
 
-	if (mipi->backlight)
-		backlight_disable(mipi->backlight);
+	if (dbidev->backlight)
+		backlight_disable(dbidev->backlight);
 	else
-		mipi_dbi_blank(mipi);
+		mipi_dbi_blank(dbidev);
 
-	if (mipi->regulator)
-		regulator_disable(mipi->regulator);
+	if (dbidev->regulator)
+		regulator_disable(dbidev->regulator);
 }
 EXPORT_SYMBOL(mipi_dbi_pipe_disable);
 
 static int mipi_dbi_connector_get_modes(struct drm_connector *connector)
 {
-	struct mipi_dbi *mipi = drm_to_mipi_dbi(connector->dev);
+	struct mipi_dbi *dbidev = drm_to_mipi_dbi(connector->dev);
 	struct drm_display_mode *mode;
 
-	mode = drm_mode_duplicate(connector->dev, &mipi->mode);
+	mode = drm_mode_duplicate(connector->dev, &dbidev->mode);
 	if (!mode) {
 		DRM_ERROR("Failed to duplicate mode\n");
 		return 0;
@@ -471,7 +471,7 @@ static const uint32_t mipi_dbi_formats[] = {
 
 /**
  * mipi_dbi_init_with_formats - MIPI DBI initialization with custom formats
- * @mipi: &mipi_dbi structure to initialize
+ * @dbidev: MIPI DBI device structure to initialize
  * @funcs: Display pipe functions
  * @formats: Array of supported formats (DRM_FORMAT\_\*).
  * @format_count: Number of elements in @formats
@@ -492,7 +492,7 @@ static const uint32_t mipi_dbi_formats[] = {
  * Returns:
  * Zero on success, negative error code on failure.
  */
-int mipi_dbi_init_with_formats(struct mipi_dbi *mipi,
+int mipi_dbi_init_with_formats(struct mipi_dbi *dbidev,
 			       const struct drm_simple_display_pipe_funcs *funcs,
 			       const uint32_t *formats, unsigned int format_count,
 			       const struct drm_display_mode *mode,
@@ -502,42 +502,42 @@ int mipi_dbi_init_with_formats(struct mipi_dbi *mipi,
 		DRM_FORMAT_MOD_LINEAR,
 		DRM_FORMAT_MOD_INVALID
 	};
-	struct drm_device *drm = &mipi->drm;
+	struct drm_device *drm = &dbidev->drm;
 	int ret;
 
-	if (!mipi->command)
+	if (!dbidev->command)
 		return -EINVAL;
 
-	mipi->tx_buf = devm_kmalloc(drm->dev, tx_buf_size, GFP_KERNEL);
-	if (!mipi->tx_buf)
+	dbidev->tx_buf = devm_kmalloc(drm->dev, tx_buf_size, GFP_KERNEL);
+	if (!dbidev->tx_buf)
 		return -ENOMEM;
 
-	drm_mode_copy(&mipi->mode, mode);
-	ret = mipi_dbi_rotate_mode(&mipi->mode, rotation);
+	drm_mode_copy(&dbidev->mode, mode);
+	ret = mipi_dbi_rotate_mode(&dbidev->mode, rotation);
 	if (ret) {
 		DRM_ERROR("Illegal rotation value %u\n", rotation);
 		return -EINVAL;
 	}
 
-	drm_connector_helper_add(&mipi->connector, &mipi_dbi_connector_hfuncs);
-	ret = drm_connector_init(drm, &mipi->connector, &mipi_dbi_connector_funcs,
+	drm_connector_helper_add(&dbidev->connector, &mipi_dbi_connector_hfuncs);
+	ret = drm_connector_init(drm, &dbidev->connector, &mipi_dbi_connector_funcs,
 				 DRM_MODE_CONNECTOR_SPI);
 	if (ret)
 		return ret;
 
-	ret = drm_simple_display_pipe_init(drm, &mipi->pipe, funcs, formats, format_count,
-					   modifiers, &mipi->connector);
+	ret = drm_simple_display_pipe_init(drm, &dbidev->pipe, funcs, formats, format_count,
+					   modifiers, &dbidev->connector);
 	if (ret)
 		return ret;
 
-	drm_plane_enable_fb_damage_clips(&mipi->pipe.plane);
+	drm_plane_enable_fb_damage_clips(&dbidev->pipe.plane);
 
 	drm->mode_config.funcs = &mipi_dbi_mode_config_funcs;
-	drm->mode_config.min_width = mipi->mode.hdisplay;
-	drm->mode_config.max_width = mipi->mode.hdisplay;
-	drm->mode_config.min_height = mipi->mode.vdisplay;
-	drm->mode_config.max_height = mipi->mode.vdisplay;
-	mipi->rotation = rotation;
+	drm->mode_config.min_width = dbidev->mode.hdisplay;
+	drm->mode_config.max_width = dbidev->mode.hdisplay;
+	drm->mode_config.min_height = dbidev->mode.vdisplay;
+	drm->mode_config.max_height = dbidev->mode.vdisplay;
+	dbidev->rotation = rotation;
 
 	DRM_DEBUG_KMS("rotation = %u\n", rotation);
 
@@ -547,7 +547,7 @@ EXPORT_SYMBOL(mipi_dbi_init_with_formats);
 
 /**
  * mipi_dbi_init - MIPI DBI initialization
- * @mipi: &mipi_dbi structure to initialize
+ * @dbidev: MIPI DBI device structure to initialize
  * @funcs: Display pipe functions
  * @mode: Display mode
  * @rotation: Initial rotation in degrees Counter Clock Wise
@@ -562,15 +562,15 @@ EXPORT_SYMBOL(mipi_dbi_init_with_formats);
  * Returns:
  * Zero on success, negative error code on failure.
  */
-int mipi_dbi_init(struct mipi_dbi *mipi,
+int mipi_dbi_init(struct mipi_dbi *dbidev,
 		  const struct drm_simple_display_pipe_funcs *funcs,
 		  const struct drm_display_mode *mode, unsigned int rotation)
 {
 	size_t bufsize = mode->vdisplay * mode->hdisplay * sizeof(u16);
 
-	mipi->drm.mode_config.preferred_depth = 16;
+	dbidev->drm.mode_config.preferred_depth = 16;
 
-	return mipi_dbi_init_with_formats(mipi, funcs, mipi_dbi_formats,
+	return mipi_dbi_init_with_formats(dbidev, funcs, mipi_dbi_formats,
 					  ARRAY_SIZE(mipi_dbi_formats), mode,
 					  rotation, bufsize);
 }
@@ -646,14 +646,14 @@ bool mipi_dbi_display_is_on(struct mipi_dbi *dbi)
 }
 EXPORT_SYMBOL(mipi_dbi_display_is_on);
 
-static int mipi_dbi_poweron_reset_conditional(struct mipi_dbi *mipi, bool cond)
+static int mipi_dbi_poweron_reset_conditional(struct mipi_dbi *dbidev, bool cond)
 {
-	struct device *dev = mipi->drm.dev;
-	struct mipi_dbi *dbi = mipi;
+	struct device *dev = dbidev->drm.dev;
+	struct mipi_dbi *dbi = dbidev;
 	int ret;
 
-	if (mipi->regulator) {
-		ret = regulator_enable(mipi->regulator);
+	if (dbidev->regulator) {
+		ret = regulator_enable(dbidev->regulator);
 		if (ret) {
 			DRM_DEV_ERROR(dev, "Failed to enable regulator (%d)\n", ret);
 			return ret;
@@ -667,8 +667,8 @@ static int mipi_dbi_poweron_reset_conditional(struct mipi_dbi *mipi, bool cond)
 	ret = mipi_dbi_command(dbi, MIPI_DCS_SOFT_RESET);
 	if (ret) {
 		DRM_DEV_ERROR(dev, "Failed to send reset command (%d)\n", ret);
-		if (mipi->regulator)
-			regulator_disable(mipi->regulator);
+		if (dbidev->regulator)
+			regulator_disable(dbidev->regulator);
 		return ret;
 	}
 
@@ -687,7 +687,7 @@ static int mipi_dbi_poweron_reset_conditional(struct mipi_dbi *mipi, bool cond)
 
 /**
  * mipi_dbi_poweron_reset - MIPI DBI poweron and reset
- * @mipi: MIPI DBI structure
+ * @dbidev: MIPI DBI device structure
  *
  * This function enables the regulator if used and does a hardware and software
  * reset.
@@ -695,15 +695,15 @@ static int mipi_dbi_poweron_reset_conditional(struct mipi_dbi *mipi, bool cond)
  * Returns:
  * Zero on success, or a negative error code.
  */
-int mipi_dbi_poweron_reset(struct mipi_dbi *mipi)
+int mipi_dbi_poweron_reset(struct mipi_dbi *dbidev)
 {
-	return mipi_dbi_poweron_reset_conditional(mipi, false);
+	return mipi_dbi_poweron_reset_conditional(dbidev, false);
 }
 EXPORT_SYMBOL(mipi_dbi_poweron_reset);
 
 /**
  * mipi_dbi_poweron_conditional_reset - MIPI DBI poweron and conditional reset
- * @mipi: MIPI DBI structure
+ * @dbidev: MIPI DBI device structure
  *
  * This function enables the regulator if used and if the display is off, it
  * does a hardware and software reset. If mipi_dbi_display_is_on() determines
@@ -713,9 +713,9 @@ EXPORT_SYMBOL(mipi_dbi_poweron_reset);
  * Zero if the controller was reset, 1 if the display was already on, or a
  * negative error code.
  */
-int mipi_dbi_poweron_conditional_reset(struct mipi_dbi *mipi)
+int mipi_dbi_poweron_conditional_reset(struct mipi_dbi *dbidev)
 {
-	return mipi_dbi_poweron_reset_conditional(mipi, true);
+	return mipi_dbi_poweron_reset_conditional(dbidev, true);
 }
 EXPORT_SYMBOL(mipi_dbi_poweron_conditional_reset);
 
diff --git a/drivers/gpu/drm/tinydrm/st7586.c b/drivers/gpu/drm/tinydrm/st7586.c
index 8339e7dc5d92..cf0d7a26009c 100644
--- a/drivers/gpu/drm/tinydrm/st7586.c
+++ b/drivers/gpu/drm/tinydrm/st7586.c
@@ -114,11 +114,11 @@ static int st7586_buf_copy(void *dst, struct drm_framebuffer *fb,
 
 static void st7586_fb_dirty(struct drm_framebuffer *fb, struct drm_rect *rect)
 {
-	struct mipi_dbi *mipi = drm_to_mipi_dbi(fb->dev);
-	struct mipi_dbi *dbi = mipi;
+	struct mipi_dbi *dbidev = drm_to_mipi_dbi(fb->dev);
+	struct mipi_dbi *dbi = dbidev;
 	int start, end, idx, ret = 0;
 
-	if (!mipi->enabled)
+	if (!dbidev->enabled)
 		return;
 
 	if (!drm_dev_enter(fb->dev, &idx))
@@ -130,7 +130,7 @@ static void st7586_fb_dirty(struct drm_framebuffer *fb, struct drm_rect *rect)
 
 	DRM_DEBUG_KMS("Flushing [FB:%d] " DRM_RECT_FMT "\n", fb->base.id, DRM_RECT_ARG(rect));
 
-	ret = st7586_buf_copy(mipi->tx_buf, fb, rect);
+	ret = st7586_buf_copy(dbidev->tx_buf, fb, rect);
 	if (ret)
 		goto err_msg;
 
@@ -146,7 +146,7 @@ static void st7586_fb_dirty(struct drm_framebuffer *fb, struct drm_rect *rect)
 			 (rect->y2 >> 8) & 0xFF, (rect->y2 - 1) & 0xFF);
 
 	ret = mipi_dbi_command_buf(dbi, MIPI_DCS_WRITE_MEMORY_START,
-				   (u8 *)mipi->tx_buf,
+				   (u8 *)dbidev->tx_buf,
 				   (end - start) * (rect->y2 - rect->y1));
 err_msg:
 	if (ret)
@@ -177,9 +177,9 @@ static void st7586_pipe_enable(struct drm_simple_display_pipe *pipe,
 			       struct drm_crtc_state *crtc_state,
 			       struct drm_plane_state *plane_state)
 {
-	struct mipi_dbi *mipi = drm_to_mipi_dbi(pipe->crtc.dev);
+	struct mipi_dbi *dbidev = drm_to_mipi_dbi(pipe->crtc.dev);
 	struct drm_framebuffer *fb = plane_state->fb;
-	struct mipi_dbi *dbi = mipi;
+	struct mipi_dbi *dbi = dbidev;
 	struct drm_rect rect = {
 		.x1 = 0,
 		.x2 = fb->width,
@@ -194,7 +194,7 @@ static void st7586_pipe_enable(struct drm_simple_display_pipe *pipe,
 
 	DRM_DEBUG_KMS("\n");
 
-	ret = mipi_dbi_poweron_reset(mipi);
+	ret = mipi_dbi_poweron_reset(dbidev);
 	if (ret)
 		goto out_exit;
 
@@ -222,7 +222,7 @@ static void st7586_pipe_enable(struct drm_simple_display_pipe *pipe,
 	mipi_dbi_command(dbi, ST7586_DISP_MODE_GRAY);
 	mipi_dbi_command(dbi, ST7586_ENABLE_DDRAM, 0x02);
 
-	switch (mipi->rotation) {
+	switch (dbidev->rotation) {
 	default:
 		addr_mode = 0x00;
 		break;
@@ -245,7 +245,7 @@ static void st7586_pipe_enable(struct drm_simple_display_pipe *pipe,
 
 	msleep(100);
 
-	mipi->enabled = true;
+	dbidev->enabled = true;
 	st7586_fb_dirty(fb, &rect);
 
 	mipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_ON);
@@ -318,23 +318,23 @@ MODULE_DEVICE_TABLE(spi, st7586_id);
 static int st7586_probe(struct spi_device *spi)
 {
 	struct device *dev = &spi->dev;
+	struct mipi_dbi *dbidev;
 	struct drm_device *drm;
-	struct mipi_dbi *mipi;
 	struct mipi_dbi *dbi;
 	struct gpio_desc *a0;
 	u32 rotation = 0;
 	size_t bufsize;
 	int ret;
 
-	mipi = kzalloc(sizeof(*mipi), GFP_KERNEL);
-	if (!mipi)
+	dbidev = kzalloc(sizeof(*dbidev), GFP_KERNEL);
+	if (!dbidev)
 		return -ENOMEM;
 
-	dbi = mipi;
-	drm = &mipi->drm;
+	dbi = dbidev;
+	drm = &dbidev->drm;
 	ret = devm_drm_dev_init(dev, drm, &st7586_driver);
 	if (ret) {
-		kfree(mipi);
+		kfree(dbidev);
 		return ret;
 	}
 
@@ -363,7 +363,7 @@ static int st7586_probe(struct spi_device *spi)
 	/* Cannot read from this controller via SPI */
 	dbi->read_commands = NULL;
 
-	ret = mipi_dbi_init_with_formats(mipi, &st7586_pipe_funcs,
+	ret = mipi_dbi_init_with_formats(dbidev, &st7586_pipe_funcs,
 					 st7586_formats, ARRAY_SIZE(st7586_formats),
 					 &st7586_mode, rotation, bufsize);
 	if (ret)
diff --git a/drivers/gpu/drm/tinydrm/st7735r.c b/drivers/gpu/drm/tinydrm/st7735r.c
index 4309ae299766..5b23657659c6 100644
--- a/drivers/gpu/drm/tinydrm/st7735r.c
+++ b/drivers/gpu/drm/tinydrm/st7735r.c
@@ -42,8 +42,8 @@ static void jd_t18003_t01_pipe_enable(struct drm_simple_display_pipe *pipe,
 				      struct drm_crtc_state *crtc_state,
 				      struct drm_plane_state *plane_state)
 {
-	struct mipi_dbi *mipi = drm_to_mipi_dbi(pipe->crtc.dev);
-	struct mipi_dbi *dbi = mipi;
+	struct mipi_dbi *dbidev = drm_to_mipi_dbi(pipe->crtc.dev);
+	struct mipi_dbi *dbi = dbidev;
 	int ret, idx;
 	u8 addr_mode;
 
@@ -52,7 +52,7 @@ static void jd_t18003_t01_pipe_enable(struct drm_simple_display_pipe *pipe,
 
 	DRM_DEBUG_KMS("\n");
 
-	ret = mipi_dbi_poweron_reset(mipi);
+	ret = mipi_dbi_poweron_reset(dbidev);
 	if (ret)
 		goto out_exit;
 
@@ -73,7 +73,7 @@ static void jd_t18003_t01_pipe_enable(struct drm_simple_display_pipe *pipe,
 	mipi_dbi_command(dbi, ST7735R_PWCTR5, 0x8a, 0xee);
 	mipi_dbi_command(dbi, ST7735R_VMCTR1, 0x0e);
 	mipi_dbi_command(dbi, MIPI_DCS_EXIT_INVERT_MODE);
-	switch (mipi->rotation) {
+	switch (dbidev->rotation) {
 	default:
 		addr_mode = ST7735R_MX | ST7735R_MY;
 		break;
@@ -104,7 +104,7 @@ static void jd_t18003_t01_pipe_enable(struct drm_simple_display_pipe *pipe,
 
 	msleep(20);
 
-	mipi_dbi_enable_flush(mipi, crtc_state, plane_state);
+	mipi_dbi_enable_flush(dbidev, crtc_state, plane_state);
 out_exit:
 	drm_dev_exit(idx);
 }
@@ -150,22 +150,22 @@ MODULE_DEVICE_TABLE(spi, st7735r_id);
 static int st7735r_probe(struct spi_device *spi)
 {
 	struct device *dev = &spi->dev;
+	struct mipi_dbi *dbidev;
 	struct drm_device *drm;
-	struct mipi_dbi *mipi;
 	struct mipi_dbi *dbi;
 	struct gpio_desc *dc;
 	u32 rotation = 0;
 	int ret;
 
-	mipi = kzalloc(sizeof(*mipi), GFP_KERNEL);
-	if (!mipi)
+	dbidev = kzalloc(sizeof(*dbidev), GFP_KERNEL);
+	if (!dbidev)
 		return -ENOMEM;
 
-	dbi = mipi;
-	drm = &mipi->drm;
+	dbi = dbidev;
+	drm = &dbidev->drm;
 	ret = devm_drm_dev_init(dev, drm, &st7735r_driver);
 	if (ret) {
-		kfree(mipi);
+		kfree(dbidev);
 		return ret;
 	}
 
@@ -183,9 +183,9 @@ static int st7735r_probe(struct spi_device *spi)
 		return PTR_ERR(dc);
 	}
 
-	mipi->backlight = devm_of_find_backlight(dev);
-	if (IS_ERR(mipi->backlight))
-		return PTR_ERR(mipi->backlight);
+	dbidev->backlight = devm_of_find_backlight(dev);
+	if (IS_ERR(dbidev->backlight))
+		return PTR_ERR(dbidev->backlight);
 
 	device_property_read_u32(dev, "rotation", &rotation);
 
@@ -196,7 +196,7 @@ static int st7735r_probe(struct spi_device *spi)
 	/* Cannot read from Adafruit 1.8" display via SPI */
 	dbi->read_commands = NULL;
 
-	ret = mipi_dbi_init(mipi, &jd_t18003_t01_pipe_funcs, &jd_t18003_t01_mode, rotation);
+	ret = mipi_dbi_init(dbidev, &jd_t18003_t01_pipe_funcs, &jd_t18003_t01_mode, rotation);
 	if (ret)
 		return ret;
 
diff --git a/include/drm/tinydrm/mipi-dbi.h b/include/drm/tinydrm/mipi-dbi.h
index 04b54ec61bc2..b7b301130af7 100644
--- a/include/drm/tinydrm/mipi-dbi.h
+++ b/include/drm/tinydrm/mipi-dbi.h
@@ -79,25 +79,25 @@ static inline struct mipi_dbi *drm_to_mipi_dbi(struct drm_device *drm)
 
 int mipi_dbi_spi_init(struct spi_device *spi, struct mipi_dbi *dbi,
 		      struct gpio_desc *dc);
-int mipi_dbi_init_with_formats(struct mipi_dbi *mipi,
+int mipi_dbi_init_with_formats(struct mipi_dbi *dbidev,
 			       const struct drm_simple_display_pipe_funcs *funcs,
 			       const uint32_t *formats, unsigned int format_count,
 			       const struct drm_display_mode *mode,
 			       unsigned int rotation, size_t tx_buf_size);
-int mipi_dbi_init(struct mipi_dbi *mipi,
+int mipi_dbi_init(struct mipi_dbi *dbidev,
 		  const struct drm_simple_display_pipe_funcs *funcs,
 		  const struct drm_display_mode *mode, unsigned int rotation);
 void mipi_dbi_release(struct drm_device *drm);
 void mipi_dbi_pipe_update(struct drm_simple_display_pipe *pipe,
 			  struct drm_plane_state *old_state);
-void mipi_dbi_enable_flush(struct mipi_dbi *mipi,
+void mipi_dbi_enable_flush(struct mipi_dbi *dbidev,
 			   struct drm_crtc_state *crtc_state,
 			   struct drm_plane_state *plan_state);
 void mipi_dbi_pipe_disable(struct drm_simple_display_pipe *pipe);
 void mipi_dbi_hw_reset(struct mipi_dbi *dbi);
 bool mipi_dbi_display_is_on(struct mipi_dbi *dbi);
-int mipi_dbi_poweron_reset(struct mipi_dbi *mipi);
-int mipi_dbi_poweron_conditional_reset(struct mipi_dbi *mipi);
+int mipi_dbi_poweron_reset(struct mipi_dbi *dbidev);
+int mipi_dbi_poweron_conditional_reset(struct mipi_dbi *dbidev);
 
 u32 mipi_dbi_spi_cmd_max_speed(struct spi_device *spi, size_t len);
 int mipi_dbi_spi_transfer(struct spi_device *spi, u32 speed_hz,
-- 
2.28.0


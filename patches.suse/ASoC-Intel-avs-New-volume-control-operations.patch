From c321a4d705a31a50d7580516422aaa5b853e7602 Mon Sep 17 00:00:00 2001
From: Cezary Rojewski <cezary.rojewski@intel.com>
Date: Mon, 17 Feb 2025 11:21:11 +0100
Subject: [PATCH] ASoC: Intel: avs: New volume control operations
Git-commit: c321a4d705a31a50d7580516422aaa5b853e7602
Patch-mainline: v6.15-rc1
References: jsc#PED-14430 jsc#PED-14297 jsc#PED-14024

To provide multi-channel - more than 2 - capability to volume controls
implement operations that honor the num_channels of a mixer control. As
mc->num_channels can be 0 and is in fact the default behavior, the new
functions decide between ALL_CHANNELS_MASK and individual channels based
on the field value.

To avoid hard-to-review delta when refactoring the code, first implement
the new behavior with follow up changes cleaning things up.

Signed-off-by: Cezary Rojewski <cezary.rojewski@intel.com>
Link: https://patch.msgid.link/20250217102115.3539427-7-cezary.rojewski@intel.com
Signed-off-by: Mark Brown <broonie@kernel.org>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 sound/soc/intel/avs/control.c | 84 +++++++++++++++++++++++++++++++++++
 sound/soc/intel/avs/control.h |  5 +++
 sound/soc/intel/avs/path.c    | 36 +++++++++++++++
 sound/soc/intel/avs/path.h    |  3 ++
 4 files changed, 128 insertions(+)

diff --git a/sound/soc/intel/avs/control.c b/sound/soc/intel/avs/control.c
index a55723289600..a1c7431cfe13 100644
--- a/sound/soc/intel/avs/control.c
+++ b/sound/soc/intel/avs/control.c
@@ -6,6 +6,7 @@
 //          Cezary Rojewski <cezary.rojewski@intel.com>
 //
 
+#include <linux/cleanup.h>
 #include <sound/soc.h>
 #include "avs.h"
 #include "control.h"
@@ -114,3 +115,86 @@ int avs_control_volume_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_va
 
 	return ret ? ret : changed;
 }
+
+int avs_control_volume_get2(struct snd_kcontrol *kctl, struct snd_ctl_elem_value *uctl)
+{
+	struct soc_mixer_control *mc = (struct soc_mixer_control *)kctl->private_value;
+	struct avs_control_data *ctl_data = mc->dobj.private;
+	struct avs_path_module *active_module;
+	struct avs_volume_cfg *dspvols;
+	struct avs_dev *adev;
+	size_t num_dspvols;
+	int ret, i;
+
+	adev = avs_get_kcontrol_adev(kctl);
+
+	/* Prevent access to modules while path is being constructed. */
+	guard(mutex)(&adev->path_mutex);
+
+	active_module = avs_get_volume_module(adev, ctl_data->id);
+	if (active_module) {
+		ret = avs_ipc_peakvol_get_volume(adev, active_module->module_id,
+						 active_module->instance_id, &dspvols,
+						 &num_dspvols);
+		if (ret)
+			return AVS_IPC_RET(ret);
+
+		/* Do not copy more than the control can store. */
+		num_dspvols = min_t(u32, num_dspvols, SND_SOC_TPLG_MAX_CHAN);
+		for (i = 0; i < num_dspvols; i++)
+			ctl_data->values[i] = dspvols[i].target_volume;
+		kfree(dspvols);
+	}
+
+	memcpy(uctl->value.integer.value, ctl_data->values, sizeof(ctl_data->values));
+	return 0;
+}
+
+int avs_control_volume_put2(struct snd_kcontrol *kctl, struct snd_ctl_elem_value *uctl)
+{
+	struct avs_path_module *active_module;
+	struct avs_control_data *ctl_data;
+	struct soc_mixer_control *mc;
+	struct avs_dev *adev;
+	long *input;
+	int ret, i;
+
+	mc = (struct soc_mixer_control *)kctl->private_value;
+	ctl_data = mc->dobj.private;
+	adev = avs_get_kcontrol_adev(kctl);
+	input = uctl->value.integer.value;
+	i = 0;
+
+	/* mc->num_channels can be 0. */
+	do {
+		if (input[i] < mc->min || input[i] > mc->max)
+			return -EINVAL;
+	} while (++i < mc->num_channels);
+
+	if (!memcmp(ctl_data->values, input, sizeof(ctl_data->values)))
+		return 0;
+
+	/* Prevent access to modules while path is being constructed. */
+	guard(mutex)(&adev->path_mutex);
+
+	active_module = avs_get_volume_module(adev, ctl_data->id);
+	if (active_module) {
+		ret = avs_peakvol_set_volume(adev, active_module, mc, input);
+		if (ret)
+			return ret;
+	}
+
+	memcpy(ctl_data->values, input, sizeof(ctl_data->values));
+	return 1;
+}
+
+int avs_control_volume_info(struct snd_kcontrol *kctl, struct snd_ctl_elem_info *uinfo)
+{
+	struct soc_mixer_control *mc = (struct soc_mixer_control *)kctl->private_value;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = max_t(u32, 1, mc->num_channels);
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = mc->max;
+	return 0;
+}
diff --git a/sound/soc/intel/avs/control.h b/sound/soc/intel/avs/control.h
index d9fac3569e8d..e16fa79962de 100644
--- a/sound/soc/intel/avs/control.h
+++ b/sound/soc/intel/avs/control.h
@@ -10,14 +10,19 @@
 #define __SOUND_SOC_INTEL_AVS_CTRL_H
 
 #include <sound/control.h>
+#include <uapi/sound/asoc.h>
 
 struct avs_control_data {
 	u32 id;
 
 	long volume;
+	long values[SND_SOC_TPLG_MAX_CHAN];
 };
 
 int avs_control_volume_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol);
 int avs_control_volume_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol);
+int avs_control_volume_get2(struct snd_kcontrol *kctl, struct snd_ctl_elem_value *uctl);
+int avs_control_volume_put2(struct snd_kcontrol *kctl, struct snd_ctl_elem_value *uctl);
+int avs_control_volume_info(struct snd_kcontrol *kctl, struct snd_ctl_elem_info *uinfo);
 
 #endif
diff --git a/sound/soc/intel/avs/path.c b/sound/soc/intel/avs/path.c
index 329838119015..a72ebde7d011 100644
--- a/sound/soc/intel/avs/path.c
+++ b/sound/soc/intel/avs/path.c
@@ -323,6 +323,42 @@ static struct avs_control_data *avs_get_module_control(struct avs_path_module *m
 	return NULL;
 }
 
+int avs_peakvol_set_volume(struct avs_dev *adev, struct avs_path_module *mod,
+			   struct soc_mixer_control *mc, long *input)
+{
+	struct avs_volume_cfg vols[SND_SOC_TPLG_MAX_CHAN] = {{0}};
+	struct avs_control_data *ctl_data;
+	struct avs_tplg_module *t;
+	int ret, i;
+
+	ctl_data = mc->dobj.private;
+	t = mod->template;
+	if (!input)
+		input = ctl_data->values;
+
+	if (mc->num_channels) {
+		for (i = 0; i < mc->num_channels; i++) {
+			vols[i].channel_id = i;
+			vols[i].target_volume = input[i];
+			vols[i].curve_type = t->cfg_ext->peakvol.curve_type;
+			vols[i].curve_duration = t->cfg_ext->peakvol.curve_duration;
+		}
+
+		ret = avs_ipc_peakvol_set_volumes(adev, mod->module_id, mod->instance_id, vols,
+						  mc->num_channels);
+		return AVS_IPC_RET(ret);
+	}
+
+	/* Target all channels if no individual selected. */
+	vols[0].channel_id = AVS_ALL_CHANNELS_MASK;
+	vols[0].target_volume = input[0];
+	vols[0].curve_type = t->cfg_ext->peakvol.curve_type;
+	vols[0].curve_duration = t->cfg_ext->peakvol.curve_duration;
+
+	ret = avs_ipc_peakvol_set_volume(adev, mod->module_id, mod->instance_id, &vols[0]);
+	return AVS_IPC_RET(ret);
+}
+
 static int avs_peakvol_create(struct avs_dev *adev, struct avs_path_module *mod)
 {
 	struct avs_tplg_module *t = mod->template;
diff --git a/sound/soc/intel/avs/path.h b/sound/soc/intel/avs/path.h
index bfd253c9fa95..e9317b64de86 100644
--- a/sound/soc/intel/avs/path.h
+++ b/sound/soc/intel/avs/path.h
@@ -69,4 +69,7 @@ int avs_path_reset(struct avs_path *path);
 int avs_path_pause(struct avs_path *path);
 int avs_path_run(struct avs_path *path, int trigger);
 
+int avs_peakvol_set_volume(struct avs_dev *adev, struct avs_path_module *mod,
+			   struct soc_mixer_control *mc, long *input);
+
 #endif
-- 
2.52.0


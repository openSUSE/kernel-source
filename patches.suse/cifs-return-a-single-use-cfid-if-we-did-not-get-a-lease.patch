From: Ronnie Sahlberg <lsahlber@redhat.com>
Date: Fri, 17 Feb 2023 13:35:01 +1000
Subject: [PATCH] cifs: return a single-use cfid if we did not get a lease
Git-commit: 8e843bf38f7be0766642a91523cfa65f2b021a8a
References: bsc#1228688
Patch-mainline: v6.3-rc1

[ematsumiya: core fix ported to smb2ops.c instead of the newer cached_dir.c ]

If we did not get a lease we can still return a single use cfid to the caller.
The cfid will not have has_lease set and will thus not be shared with any
other concurrent users and will be freed immediately when the caller
drops the handle.

This avoids extra roundtrips for servers that do not support directory leases
where they would first fail to get a cfid with a lease and then fallback
to try a normal SMB2_open()

Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
Cc: stable@vger.kernel.org
Reviewed-by: Bharath SM <bharathsm@microsoft.com>
Reviewed-by: Paulo Alcantara (SUSE) <pc@manguebit.com>
Signed-off-by: Steve French <stfrench@microsoft.com>
Acked-by: Enzo Matsumiya <ematsumiya@suse.de>
---
 fs/cifs/smb2ops.c |   12 ++++++++++++
 1 file changed, 12 insertions(+)

--- a/fs/cifs/smb2ops.c
+++ b/fs/cifs/smb2ops.c
@@ -26,6 +26,8 @@
 #include "smbdirect.h"
 #include "fs_context.h"
 
+static void smb2_close_cached_fid(struct kref *ref);
+
 /* Change credits for different ops and return the total number of credits */
 static int
 change_conf(struct TCP_Server_Info *server)
@@ -702,6 +704,7 @@
 		cifs_dbg(FYI, "clear cached root file handle\n");
 		SMB2_close(0, cfid->tcon, cfid->fid->persistent_fid,
 			   cfid->fid->volatile_fid);
+		atomic_dec(&cfid->tcon->num_remote_opens);
 	}
 
 	/*
@@ -957,6 +960,15 @@
 	free_rsp_buf(resp_buftype[1], rsp_iov[1].iov_base);
 	if (rc == 0) {
 		*cfid = &tcon->crfid;
+		if (!tcon->crfid.has_lease) {
+			/*
+			 * We are guaranteed to have two references at this point.
+			 * One for the caller and one for a potential lease.
+			 * Release the Lease-ref so that the directory will be closed
+			 * when the caller closes the cached handle.
+			 */
+			kref_put(&tcon->crfid.refcount, smb2_close_cached_fid);
+		}
 	} else {
 		if (is_open)
 			SMB2_close(0, tcon, tcon->crfid.fid->persistent_fid,

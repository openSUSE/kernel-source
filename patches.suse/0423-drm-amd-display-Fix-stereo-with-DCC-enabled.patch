From 08bcf590bad4515a221e216bfae20f5972e512de Mon Sep 17 00:00:00 2001
From: Samson Tam <Samson.Tam@amd.com>
Date: Wed, 23 Oct 2019 21:36:29 -0400
Subject: drm/amd/display: Fix stereo with DCC enabled
Git-commit: 8d8a6af71a75e09ce5796b4ae780818865832c50
Patch-mainline: v5.6-rc1
References: jsc#SLE-12680, jsc#SLE-12880, jsc#SLE-12882, jsc#SLE-12883, jsc#SLE-13496, jsc#SLE-15322

[Why]
When sending DCC with Stereo, DCC gets enabled but the meta addresses
are 0. This happens momentarily before the meta addresses are populated
with a valid address.

[How]
Add call validate_dcc_with_meta_address() in
copy_surface_update_to_plane() to check for surface address and DCC
change.
When DCC has changed, check if DCC enable is true but meta address is 0.
If so, we turn DCC enable to false. When surface address has changed, we
check if DCC enable is false but meta address is not 0. If so, we turn
DCC enable back to true.  This will restore DCC enable to the proper
setting once the meta address is valid.

Signed-off-by: Samson Tam <Samson.Tam@amd.com>
Reviewed-by: Jun Lei <Jun.Lei@amd.com>
Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 drivers/gpu/drm/amd/display/dc/core/dc.c | 27 ++++++++++++++++++++++++
 1 file changed, 27 insertions(+)

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 7f796a4c73d4..c3a315f1d5f8 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1747,12 +1747,37 @@ static struct dc_stream_status *stream_get_status(
 
 static const enum surface_update_type update_surface_trace_level = UPDATE_TYPE_FULL;
 
+static void validate_dcc_with_meta_address(
+	struct dc_plane_dcc_param *dcc,
+	struct dc_plane_address *address)
+{
+	if ((address->grph.meta_addr.quad_part == 0) &&
+		dcc->enable) {
+		ASSERT(!dcc->enable);
+		dcc->enable = false;
+	} else if ((address->grph.meta_addr.quad_part != 0) &&
+		!dcc->enable)
+		dcc->enable = true;
+
+	if (address->type != PLN_ADDR_TYPE_GRAPHICS) {
+		if ((address->grph_stereo.right_meta_addr.quad_part == 0) &&
+			dcc->enable) {
+			ASSERT(!dcc->enable);
+			dcc->enable = false;
+		} else if ((address->grph_stereo.right_meta_addr.quad_part != 0) &&
+			!dcc->enable)
+			dcc->enable = true;
+	}
+}
+
 static void copy_surface_update_to_plane(
 		struct dc_plane_state *surface,
 		struct dc_surface_update *srf_update)
 {
 	if (srf_update->flip_addr) {
 		surface->address = srf_update->flip_addr->address;
+		validate_dcc_with_meta_address(&surface->dcc, &surface->address);
+
 		surface->flip_immediate =
 			srf_update->flip_addr->flip_immediate;
 		surface->time.time_elapsed_in_us[surface->time.index] =
@@ -1801,6 +1826,8 @@ static void copy_surface_update_to_plane(
 				srf_update->plane_info->global_alpha_value;
 		surface->dcc =
 				srf_update->plane_info->dcc;
+		validate_dcc_with_meta_address(&surface->dcc, &surface->address);
+
 		surface->sdr_white_level =
 				srf_update->plane_info->sdr_white_level;
 		surface->layer_index =
-- 
2.28.0


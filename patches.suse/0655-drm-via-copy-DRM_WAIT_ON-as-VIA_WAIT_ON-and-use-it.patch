From 9154e60c4e057296983ef08d96ab5db76c1574c2 Mon Sep 17 00:00:00 2001
From: Sam Ravnborg <sam@ravnborg.org>
Date: Tue, 23 Jul 2019 22:09:42 +0200
Subject: drm/via: copy DRM_WAIT_ON as VIA_WAIT_ON and use it
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Git-commit: 9154e60c4e057296983ef08d96ab5db76c1574c2
Patch-mainline: v5.4-rc1
References: bsc#1152472

VIA_WAIT_ON() is a direct copy of DRM_WAIT_ON() from
drm_os_linux.h.
The copy is made so we can avoid the dependency on the legacy header.
A more involved approach had been to introduce wait_event_* but for this
legacy driver the simpler and more safe approach with a copy of the
macro was selected.
Added the relevant header files for the functions used in VIA_WAIT_ON.

v3:
- Updated users of DRM_WAIT_ON => VIA_WAIT_ON (Emil)
- Updated $subject (Emil)

Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
Reviewed-by: Emil Velikov <emil.velikov@collabora.com>
Cc: Kevin Brace <kevinbrace@gmx.com>
Cc: Thomas Hellstrom <thellstrom@vmware.com>
Cc: "Gustavo A. R. Silva" <gustavo@embeddedor.com>
Cc: Mike Marshall <hubcap@omnibond.com>
Cc: Ira Weiny <ira.weiny@intel.com>
Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
Cc: Michel DÃ¤nzer <michel@daenzer.net>
Link: https://patchwork.freedesktop.org/patch/msgid/20190723200944.17285-3-sam@ravnborg.org
Acked-by: Thomas Zimmermann <tzimmermann@suse.de>
---
 drivers/gpu/drm/via/via_dmablit.c |  4 +--
 drivers/gpu/drm/via/via_drv.h     | 42 ++++++++++++++++++++++++++++++-
 drivers/gpu/drm/via/via_irq.c     |  4 +--
 drivers/gpu/drm/via/via_video.c   |  2 +-
 4 files changed, 46 insertions(+), 6 deletions(-)

diff --git a/drivers/gpu/drm/via/via_dmablit.c b/drivers/gpu/drm/via/via_dmablit.c
index e1557dd67083..2ec93d976a43 100644
--- a/drivers/gpu/drm/via/via_dmablit.c
+++ b/drivers/gpu/drm/via/via_dmablit.c
@@ -436,7 +436,7 @@ via_dmablit_sync(struct drm_device *dev, uint32_t handle, int engine)
 	int ret = 0;
 
 	if (via_dmablit_active(blitq, engine, handle, &queue)) {
-		DRM_WAIT_ON(ret, *queue, 3 * HZ,
+		VIA_WAIT_ON(ret, *queue, 3 * HZ,
 			    !via_dmablit_active(blitq, engine, handle, NULL));
 	}
 	DRM_DEBUG("DMA blit sync handle 0x%x engine %d returned %d\n",
@@ -687,7 +687,7 @@ via_dmablit_grab_slot(drm_via_blitq_t *blitq, int engine)
 	while (blitq->num_free == 0) {
 		spin_unlock_irqrestore(&blitq->blit_lock, irqsave);
 
-		DRM_WAIT_ON(ret, blitq->busy_queue, HZ, blitq->num_free > 0);
+		VIA_WAIT_ON(ret, blitq->busy_queue, HZ, blitq->num_free > 0);
 		if (ret)
 			return (-EINTR == ret) ? -EAGAIN : ret;
 
diff --git a/drivers/gpu/drm/via/via_drv.h b/drivers/gpu/drm/via/via_drv.h
index 368185b80184..9e6a0c5f316c 100644
--- a/drivers/gpu/drm/via/via_drv.h
+++ b/drivers/gpu/drm/via/via_drv.h
@@ -24,8 +24,13 @@
 #ifndef _VIA_DRV_H_
 #define _VIA_DRV_H_
 
-#include <drm/drm_mm.h>
+#include <linux/jiffies.h>
+#include <linux/sched.h>
+#include <linux/sched/signal.h>
+#include <linux/wait.h>
+
 #include <drm/drm_legacy.h>
+#include <drm/drm_mm.h>
 
 #define DRIVER_AUTHOR	"Various"
 
@@ -140,6 +145,41 @@ static inline void via_write8_mask(struct drm_via_private *dev_priv,
 	writeb(tmp, (void __iomem *)(dev_priv->mmio->handle + reg));
 }
 
+/*
+ * Poll in a loop waiting for 'contidition' to be true.
+ * Note: A direct replacement with wait_event_interruptible_timeout()
+ *       will not work unless driver is updated to emit wake_up()
+ *       in relevant places that can impact the 'condition'
+ *
+ * Returns:
+ *   ret keeps current value if 'condition' becomes true
+ *   ret = -BUSY if timeout happens
+ *   ret = -EINTR if a signal interrupted the waiting period
+ */
+#define VIA_WAIT_ON( ret, queue, timeout, condition )		\
+do {								\
+	DECLARE_WAITQUEUE(entry, current);			\
+	unsigned long end = jiffies + (timeout);		\
+	add_wait_queue(&(queue), &entry);			\
+								\
+	for (;;) {						\
+		__set_current_state(TASK_INTERRUPTIBLE);	\
+		if (condition)					\
+			break;					\
+		if (time_after_eq(jiffies, end)) {		\
+			ret = -EBUSY;				\
+			break;					\
+		}						\
+		schedule_timeout((HZ/100 > 1) ? HZ/100 : 1);	\
+		if (signal_pending(current)) {			\
+			ret = -EINTR;				\
+			break;					\
+		}						\
+	}							\
+	__set_current_state(TASK_RUNNING);			\
+	remove_wait_queue(&(queue), &entry);			\
+} while (0)
+
 extern const struct drm_ioctl_desc via_ioctls[];
 extern int via_max_ioctl;
 
diff --git a/drivers/gpu/drm/via/via_irq.c b/drivers/gpu/drm/via/via_irq.c
index 08c87127f143..3e68cfa65b12 100644
--- a/drivers/gpu/drm/via/via_irq.c
+++ b/drivers/gpu/drm/via/via_irq.c
@@ -233,12 +233,12 @@ via_driver_irq_wait(struct drm_device *dev, unsigned int irq, int force_sequence
 	cur_irq = dev_priv->via_irqs + real_irq;
 
 	if (masks[real_irq][2] && !force_sequence) {
-		DRM_WAIT_ON(ret, cur_irq->irq_queue, 3 * HZ,
+		VIA_WAIT_ON(ret, cur_irq->irq_queue, 3 * HZ,
 			    ((via_read(dev_priv, masks[irq][2]) & masks[irq][3]) ==
 			     masks[irq][4]));
 		cur_irq_sequence = atomic_read(&cur_irq->irq_received);
 	} else {
-		DRM_WAIT_ON(ret, cur_irq->irq_queue, 3 * HZ,
+		VIA_WAIT_ON(ret, cur_irq->irq_queue, 3 * HZ,
 			    (((cur_irq_sequence =
 			       atomic_read(&cur_irq->irq_received)) -
 			      *sequence) <= (1 << 23)));
diff --git a/drivers/gpu/drm/via/via_video.c b/drivers/gpu/drm/via/via_video.c
index a9ffbad1cfdd..cf53612c945e 100644
--- a/drivers/gpu/drm/via/via_video.c
+++ b/drivers/gpu/drm/via/via_video.c
@@ -82,7 +82,7 @@ int via_decoder_futex(struct drm_device *dev, void *data, struct drm_file *file_
 
 	switch (fx->func) {
 	case VIA_FUTEX_WAIT:
-		DRM_WAIT_ON(ret, dev_priv->decoder_queue[fx->lock],
+		VIA_WAIT_ON(ret, dev_priv->decoder_queue[fx->lock],
 			    (fx->ms / 10) * (HZ / 100), *lock != fx->val);
 		return ret;
 	case VIA_FUTEX_WAKE:
-- 
2.28.0


From 977af3992966111e5424b2e0168a2b1944cbff31 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ville=20Syrj=C3=A4l=C3=A4?= <ville.syrjala@linux.intel.com>
Date: Mon, 20 Jan 2020 19:47:15 +0200
Subject: drm/i915: Collect more cdclk state under the same roof
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Git-commit: b4db3a8c689ba5f5ced764ab1377ad6411003b0b
Patch-mainline: v5.7-rc1
References: jsc#SLE-12680, jsc#SLE-12880, jsc#SLE-12882, jsc#SLE-12883, jsc#SLE-13496, jsc#SLE-15322

Move the min_cdclk[] and min_voltage_level[] arrays under the
rest of the cdclk state. And while at it provide a simple
helper (intel_cdclk_clear_state()) to clear the state during
the ww_mutex backoff dance.

Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20200120174728.21095-6-ville.syrjala@linux.intel.com
Reviewed-by: José Roberto de Souza <jose.souza@intel.com>
Signed-off-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 drivers/gpu/drm/i915/display/intel_atomic.c   |  9 ++---
 drivers/gpu/drm/i915/display/intel_cdclk.c    | 40 ++++++++++++-------
 drivers/gpu/drm/i915/display/intel_cdclk.h    |  1 +
 drivers/gpu/drm/i915/display/intel_display.c  |  8 ++--
 .../drm/i915/display/intel_display_types.h    | 10 +++--
 drivers/gpu/drm/i915/i915_drv.h               |  9 +++--
 6 files changed, 46 insertions(+), 31 deletions(-)

diff --git a/drivers/gpu/drm/i915/display/intel_atomic.c b/drivers/gpu/drm/i915/display/intel_atomic.c
index 9921b1fa4e70..014927edd5bc 100644
--- a/drivers/gpu/drm/i915/display/intel_atomic.c
+++ b/drivers/gpu/drm/i915/display/intel_atomic.c
@@ -35,6 +35,7 @@
 #include <drm/drm_plane_helper.h>
 
 #include "intel_atomic.h"
+#include "intel_cdclk.h"
 #include "intel_display_types.h"
 #include "intel_hdcp.h"
 #include "intel_psr.h"
@@ -499,15 +500,13 @@ intel_atomic_state_alloc(struct drm_device *dev)
 void intel_atomic_state_clear(struct drm_atomic_state *s)
 {
 	struct intel_atomic_state *state = to_intel_atomic_state(s);
+
 	drm_atomic_state_default_clear(&state->base);
+
 	state->dpll_set = state->modeset = false;
 	state->global_state_changed = false;
 	state->active_pipes = 0;
-	memset(&state->min_cdclk, 0, sizeof(state->min_cdclk));
-	memset(&state->min_voltage_level, 0, sizeof(state->min_voltage_level));
-	memset(&state->cdclk.logical, 0, sizeof(state->cdclk.logical));
-	memset(&state->cdclk.actual, 0, sizeof(state->cdclk.actual));
-	state->cdclk.pipe = INVALID_PIPE;
+	intel_cdclk_clear_state(state);
 }
 
 struct intel_crtc_state *
diff --git a/drivers/gpu/drm/i915/display/intel_cdclk.c b/drivers/gpu/drm/i915/display/intel_cdclk.c
index 389b35949901..49263f7e3c21 100644
--- a/drivers/gpu/drm/i915/display/intel_cdclk.c
+++ b/drivers/gpu/drm/i915/display/intel_cdclk.c
@@ -1819,6 +1819,18 @@ static bool intel_cdclk_changed(const struct intel_cdclk_state *a,
 		a->voltage_level != b->voltage_level;
 }
 
+/**
+ * intel_cdclk_clear_state - clear the cdclk state
+ * @state: atomic state
+ *
+ * Clear the cdclk state for ww_mutex backoff.
+ */
+void intel_cdclk_clear_state(struct intel_atomic_state *state)
+{
+	memset(&state->cdclk, 0, sizeof(state->cdclk));
+	state->cdclk.pipe = INVALID_PIPE;
+}
+
 /**
  * intel_cdclk_swap_state - make atomic CDCLK configuration effective
  * @state: atomic state
@@ -1836,10 +1848,10 @@ void intel_cdclk_swap_state(struct intel_atomic_state *state)
 	struct drm_i915_private *dev_priv = to_i915(state->base.dev);
 
 	/* FIXME maybe swap() these too */
-	memcpy(dev_priv->min_cdclk, state->min_cdclk,
-	       sizeof(state->min_cdclk));
-	memcpy(dev_priv->min_voltage_level, state->min_voltage_level,
-	       sizeof(state->min_voltage_level));
+	memcpy(dev_priv->cdclk.min_cdclk, state->cdclk.min_cdclk,
+	       sizeof(state->cdclk.min_cdclk));
+	memcpy(dev_priv->cdclk.min_voltage_level, state->cdclk.min_voltage_level,
+	       sizeof(state->cdclk.min_voltage_level));
 
 	dev_priv->cdclk.force_min_cdclk = state->cdclk.force_min_cdclk;
 
@@ -2065,10 +2077,10 @@ static int intel_compute_min_cdclk(struct intel_atomic_state *state)
 		if (min_cdclk < 0)
 			return min_cdclk;
 
-		if (state->min_cdclk[i] == min_cdclk)
+		if (state->cdclk.min_cdclk[i] == min_cdclk)
 			continue;
 
-		state->min_cdclk[i] = min_cdclk;
+		state->cdclk.min_cdclk[i] = min_cdclk;
 
 		ret = intel_atomic_lock_global_state(state);
 		if (ret)
@@ -2077,7 +2089,7 @@ static int intel_compute_min_cdclk(struct intel_atomic_state *state)
 
 	min_cdclk = state->cdclk.force_min_cdclk;
 	for_each_pipe(dev_priv, pipe)
-		min_cdclk = max(state->min_cdclk[pipe], min_cdclk);
+		min_cdclk = max(state->cdclk.min_cdclk[pipe], min_cdclk);
 
 	return min_cdclk;
 }
@@ -2112,10 +2124,10 @@ static int bxt_compute_min_voltage_level(struct intel_atomic_state *state)
 		else
 			min_voltage_level = 0;
 
-		if (state->min_voltage_level[i] == min_voltage_level)
+		if (state->cdclk.min_voltage_level[i] == min_voltage_level)
 			continue;
 
-		state->min_voltage_level[i] = min_voltage_level;
+		state->cdclk.min_voltage_level[i] = min_voltage_level;
 
 		ret = intel_atomic_lock_global_state(state);
 		if (ret)
@@ -2124,7 +2136,7 @@ static int bxt_compute_min_voltage_level(struct intel_atomic_state *state)
 
 	min_voltage_level = 0;
 	for_each_pipe(dev_priv, pipe)
-		min_voltage_level = max(state->min_voltage_level[pipe],
+		min_voltage_level = max(state->cdclk.min_voltage_level[pipe],
 					min_voltage_level);
 
 	return min_voltage_level;
@@ -2358,10 +2370,10 @@ int intel_modeset_calc_cdclk(struct intel_atomic_state *state)
 	enum pipe pipe;
 	int ret;
 
-	memcpy(state->min_cdclk, dev_priv->min_cdclk,
-	       sizeof(state->min_cdclk));
-	memcpy(state->min_voltage_level, dev_priv->min_voltage_level,
-	       sizeof(state->min_voltage_level));
+	memcpy(state->cdclk.min_cdclk, dev_priv->cdclk.min_cdclk,
+	       sizeof(state->cdclk.min_cdclk));
+	memcpy(state->cdclk.min_voltage_level, dev_priv->cdclk.min_voltage_level,
+	       sizeof(state->cdclk.min_voltage_level));
 
 	/* keep the current setting */
 	if (!state->cdclk.force_min_cdclk_changed)
diff --git a/drivers/gpu/drm/i915/display/intel_cdclk.h b/drivers/gpu/drm/i915/display/intel_cdclk.h
index cf71394cc79c..3f3773c582ae 100644
--- a/drivers/gpu/drm/i915/display/intel_cdclk.h
+++ b/drivers/gpu/drm/i915/display/intel_cdclk.h
@@ -31,6 +31,7 @@ void intel_update_cdclk(struct drm_i915_private *dev_priv);
 void intel_update_rawclk(struct drm_i915_private *dev_priv);
 bool intel_cdclk_needs_modeset(const struct intel_cdclk_state *a,
 			       const struct intel_cdclk_state *b);
+void intel_cdclk_clear_state(struct intel_atomic_state *state);
 void intel_cdclk_swap_state(struct intel_atomic_state *state);
 void
 intel_set_cdclk_pre_plane_update(struct drm_i915_private *dev_priv,
diff --git a/drivers/gpu/drm/i915/display/intel_display.c b/drivers/gpu/drm/i915/display/intel_display.c
index 0159f627d6e5..9be12423aee5 100644
--- a/drivers/gpu/drm/i915/display/intel_display.c
+++ b/drivers/gpu/drm/i915/display/intel_display.c
@@ -7599,8 +7599,8 @@ static void intel_crtc_disable_noatomic(struct intel_crtc *crtc,
 	crtc->enabled_power_domains = 0;
 
 	dev_priv->active_pipes &= ~BIT(pipe);
-	dev_priv->min_cdclk[pipe] = 0;
-	dev_priv->min_voltage_level[pipe] = 0;
+	dev_priv->cdclk.min_cdclk[pipe] = 0;
+	dev_priv->cdclk.min_voltage_level[pipe] = 0;
 
 	bw_state->data_rate[pipe] = 0;
 	bw_state->num_active_planes[pipe] = 0;
@@ -18528,8 +18528,8 @@ static void intel_modeset_readout_hw_state(struct drm_device *dev)
 				min_cdclk = 0;
 		}
 
-		dev_priv->min_cdclk[crtc->pipe] = min_cdclk;
-		dev_priv->min_voltage_level[crtc->pipe] =
+		dev_priv->cdclk.min_cdclk[crtc->pipe] = min_cdclk;
+		dev_priv->cdclk.min_voltage_level[crtc->pipe] =
 			crtc_state->min_voltage_level;
 
 		intel_bw_crtc_update(bw_state, crtc_state);
diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 9457735bf110..db857d711e4e 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -478,6 +478,12 @@ struct intel_atomic_state {
 
 		int force_min_cdclk;
 		bool force_min_cdclk_changed;
+
+		/* minimum acceptable cdclk for each pipe */
+		int min_cdclk[I915_MAX_PIPES];
+		/* minimum acceptable voltage level for each pipe */
+		u8 min_voltage_level[I915_MAX_PIPES];
+
 		/* pipe to which cd2x update is synchronized */
 		enum pipe pipe;
 	} cdclk;
@@ -495,10 +501,6 @@ struct intel_atomic_state {
 	u8 active_pipe_changes;
 
 	u8 active_pipes;
-	/* minimum acceptable cdclk for each pipe */
-	int min_cdclk[I915_MAX_PIPES];
-	/* minimum acceptable voltage level for each pipe */
-	u8 min_voltage_level[I915_MAX_PIPES];
 
 	struct intel_shared_dpll_state shared_dpll[I915_NUM_PLLS];
 
diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h
index 099539d61ac5..16c56f26925f 100644
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@ -1025,6 +1025,11 @@ struct drm_i915_private {
 		const struct intel_cdclk_vals *table;
 
 		int force_min_cdclk;
+
+		/* minimum acceptable cdclk for each pipe */
+		int min_cdclk[I915_MAX_PIPES];
+		/* minimum acceptable voltage level for each pipe */
+		u8 min_voltage_level[I915_MAX_PIPES];
 	} cdclk;
 
 	/**
@@ -1085,10 +1090,6 @@ struct drm_i915_private {
 	 * any crtc lock is sufficient, for writing must hold all of them.
 	 */
 	u8 active_pipes;
-	/* minimum acceptable cdclk for each pipe */
-	int min_cdclk[I915_MAX_PIPES];
-	/* minimum acceptable voltage level for each pipe */
-	u8 min_voltage_level[I915_MAX_PIPES];
 
 	int dpio_phy_iosf_port[I915_NUM_PHYS_VLV];
 
-- 
2.28.0


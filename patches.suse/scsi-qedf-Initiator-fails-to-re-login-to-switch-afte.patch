From: Saurav Kashyap <skashyap@marvell.com>
Date: Fri, 23 Aug 2019 02:52:39 -0700
Subject: scsi: qedf: Initiator fails to re-login to switch after link down
Patch-mainline: v5.4-rc1
Git-commit: b29a907f105cc659a303bb2657959c7d0d188620
References: jsc#SLE-9711

Problem Statement:

 - Driver has fc_id of 0xcc0200

 - Driver gets link down (due to test) and calls fcoe_ctlr_link_down().

 - At this point, the fc_id of the initiator port is zeroed out.

 - Driver gets a link up 14 seconds later.

 - Driver performs FIP VLAN request, gets a response from the switch.

 - No change in VLAN is detected.

 - Driver then notifies libfcoe via fcoe_ctlr_link_up().

 - Libfcoe then issues a multicast discovery solicitation as expected.

 - Cisco FCF responds to that correctly.

 - Libfcoe at this point starts a 3 sec count-down to allow any other FCFs
   to be discovered. However, at this point, it has been 20 seconds since
   the last FKA from the driver (which would have been sent prior to
   backlink toggle), which causes the CVL to be issued from Cisco CVL from
   the switch is dropped by the driver as the vx_port identification
   descriptor is present and has value of 0xcc0200, which does not match
   the driver's value of 0.  Libfcoe completes the 3 sec count down and
   proceeds to issue FLOGI as per protocol.  Switch rejects FLogi request.
   All subsequent FLOGI requests from libfc are rejected by the switch
   (possibly because it is now expecting a new solicitation).  This
   situation will continue until the next link toggle.

Solution:

The Vx_port descriptor in the CVL has three fields:

MAC address
Fabric ID
Port Name

Today, the code checks for both #1 and #2 above. In the case where we went
through a link down, both these will be zero until FLOGI succeeds.

We should change our code to check if any one of these 3 is valid and if
so, handle the CVL (basically switching from AND to OR). The port name
field is definitely expected to be valid always.

Signed-off-by: Saurav Kashyap <skashyap@marvell.com>
Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
Acked-by: Daniel Wagner <dwagner@suse.de>
---
 drivers/scsi/qedf/qedf_fip.c |   28 +++++++++++++++++-----------
 1 file changed, 17 insertions(+), 11 deletions(-)

--- a/drivers/scsi/qedf/qedf_fip.c
+++ b/drivers/scsi/qedf/qedf_fip.c
@@ -253,18 +253,24 @@ void qedf_fip_recv(struct qedf_ctx *qedf
 					fc_wwpn_valid = true;
 				break;
 			case FIP_DT_VN_ID:
+				fabric_id_valid = false;
 				vp = (struct fip_vn_desc *)desc;
-				QEDF_INFO(&qedf->dbg_ctx, QEDF_LOG_DISC,
-					  "vx_port fd_fc_id=%x fd_mac=%pM.\n",
-					  ntoh24(vp->fd_fc_id), vp->fd_mac);
-				/* Check vx_port fabric ID */
-				if (ntoh24(vp->fd_fc_id) !=
-				    qedf->lport->port_id)
-					fabric_id_valid = false;
-				/* Check vx_port MAC */
-				if (!ether_addr_equal(vp->fd_mac,
-						      qedf->data_src_addr))
-					fabric_id_valid = false;
+
+				QEDF_ERR(&qedf->dbg_ctx,
+					 "CVL vx_port fd_fc_id=0x%x fd_mac=%pM fd_wwpn=%016llx.\n",
+					 ntoh24(vp->fd_fc_id), vp->fd_mac,
+					 get_unaligned_be64(&vp->fd_wwpn));
+				/* Check for vx_port wwpn OR Check vx_port
+				 * fabric ID OR Check vx_port MAC
+				 */
+				if ((get_unaligned_be64(&vp->fd_wwpn) ==
+					qedf->wwpn) ||
+				   (ntoh24(vp->fd_fc_id) ==
+					qedf->lport->port_id) ||
+				   (ether_addr_equal(vp->fd_mac,
+					qedf->data_src_addr))) {
+					fabric_id_valid = true;
+				}
 				break;
 			default:
 				/* Ignore anything else */

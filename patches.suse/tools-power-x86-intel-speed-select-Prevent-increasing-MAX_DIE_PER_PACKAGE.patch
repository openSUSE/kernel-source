From: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Subject: tools/power/x86/intel-speed-select: Prevent increasing MAX_DIE_PER_PACKAGE
References: PED-14190
Patch-Mainline: v6.15-rc1
Git-commit: d74e6e29d2b29919253f625f0c560f4ca2606900


In the function for_each_online_power_domain_in_set() to pick one CPU
from each power domain a three-dimensional array is used, which assumes
that a package contains multiple dies, that means the die_id from
/sys/devices/system/cpu/cpu0/topology/die_id is only local to package.

If it is not unique, still there will be no functional issues in the
current generation of products, but the MAX_DIE_PER_PACKAGE will need to
be increased for future products with many packages.

After kernel version 6.9 die ID is unique system wide not per package.
Even if the CPU topology has no dies, the ID will still increment across
package. In this case the die_id in package 0 will be 0 and die_id in
package 1 will be 1 in a 2-package system.

Since the die count must be same for packages, just count the number of
dies in package 0 and calculate die index from
/sys/devices/system/cpu/cpu0/topology/die_id which is only unique within
a package.

In this way the array size
"int cpus[MAX_PACKAGE_COUNT][MAX_DIE_PER_PACKAGE][MAX_PUNIT_PER_DIE]"
doesn't have to increase with increasing package count.

No functional change is expected.

Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>


Signed-off-by:  <trenn@suse.de>
---
 tools/power/x86/intel-speed-select/isst-config.c |   13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)

--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -48,6 +48,7 @@
 static int cgroupv2;
 static int max_die_id;
 static int max_punit_id;
+static int max_die_id_package_0;
 
 /* clos related */
 static int current_clos = -1;
@@ -557,6 +558,8 @@
 		if (id.pkg < 0 || id.die < 0 || id.punit < 0)
 			continue;
 
+		id.die = id.die % (max_die_id_package_0 + 1);
+
 		valid_mask[id.pkg][id.die] = 1;
 
 		if (cpus[id.pkg][id.die][id.punit] == -1)
@@ -568,7 +571,7 @@
 			for (k = 0; k < MAX_PUNIT_PER_DIE && k < MAX_DIE_PER_PACKAGE; k++) {
 				id.cpu = cpus[i][k][k];
 				id.pkg = i;
-				id.die = k;
+				id.die = get_physical_die_id(id.cpu);
 				id.punit = k;
 				if (isst_is_punit_valid(&id))
 					callback(&id, arg1, arg2, arg3, arg4);
@@ -586,7 +589,10 @@
 			for (k = 0; k < MAX_PUNIT_PER_DIE; k++) {
 				id.cpu = cpus[i][j][k];
 				id.pkg = i;
-				id.die = j;
+				if (id.cpu >= 0)
+					id.die = get_physical_die_id(id.cpu);
+				else
+					id.die = id.pkg;
 				id.punit = k;
 				if (isst_is_punit_valid(&id))
 					callback(&id, arg1, arg2, arg3, arg4);
@@ -815,6 +821,9 @@
 		if (max_punit_id < cpu_map[i].punit_id)
 			max_punit_id = cpu_map[i].punit_id;
 
+		if (!pkg_id && max_die_id_package_0 < die_id)
+			max_die_id_package_0 = die_id;
+
 		debug_printf(
 			"map logical_cpu:%d core: %d die:%d pkg:%d punit:%d punit_cpu:%d punit_core:%d\n",
 			i, cpu_map[i].core_id, cpu_map[i].die_id,

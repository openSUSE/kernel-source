From c23f3a209ef527bfba695091bd30e970d0c7d504 Mon Sep 17 00:00:00 2001
From: Chun-Yi Lee <jlee@suse.com>
Date: Sat, 31 Aug 2024 17:57:14 +0800
Subject: [PATCH] PKCS#7: Check codeSigning EKU of certificates in PKCS#7
Patch-mainline: Never, SUSE-specific
References: bsc#1226666

The original solution of CodeSigning EKU only checks the direct signer
certificate in trusted keyring. But PKCS#7 may carries certificates
container which includes trusted certificate chain, and put a root
certificate in trusted keyring which does NOT have CodeSigning EKU.

This patch supports checking CodeSigning EKU of certificates in
PKCS#7.

Signed-off-by: Chun-Yi Lee <jlee@suse.com>
---
 crypto/asymmetric_keys/pkcs7_parser.h |    3 ++
 crypto/asymmetric_keys/pkcs7_trust.c  |   27 ++--------------------
 crypto/asymmetric_keys/pkcs7_verify.c |   40 ++++++++++++++++++++++++++++++++++
 3 files changed, 46 insertions(+), 24 deletions(-)

--- a/crypto/asymmetric_keys/pkcs7_parser.h
+++ b/crypto/asymmetric_keys/pkcs7_parser.h
@@ -63,3 +63,6 @@ struct pkcs7_message {
 	size_t		data_hdrlen;	/* Length of Data ASN.1 header */
 	const void	*data;		/* Content Data (or 0) */
 };
+
+extern bool check_codesign_eku_by_key(struct key *key,
+			       enum key_being_used_for usage);
--- a/crypto/asymmetric_keys/pkcs7_trust.c
+++ b/crypto/asymmetric_keys/pkcs7_trust.c
@@ -16,29 +16,6 @@
 #include <crypto/public_key.h>
 #include "pkcs7_parser.h"
 
-#ifdef CONFIG_CHECK_CODESIGN_EKU
-static bool check_codesign_eku(struct key *key,
-			     enum key_being_used_for usage)
-{
-	struct public_key *public_key = key->payload.data[asym_crypto];
-
-	switch (usage) {
-	case VERIFYING_MODULE_SIGNATURE:
-	case VERIFYING_KEXEC_PE_SIGNATURE:
-		return !!(public_key->eku & EKU_codeSigning);
-	default:
-		break;
-	}
-	return true;
-}
-#else
-static bool check_codesign_eku(struct key *key,
-			     enum key_being_used_for usage)
-{
-	return true;
-}
-#endif
-
 /**
  * Check the trust on one PKCS#7 SignedInfo block.
  */
@@ -136,7 +113,9 @@ static int pkcs7_validate_trust_one(stru
 	return -ENOKEY;
 
 matched:
-	if (!check_codesign_eku(key, usage)) {
+	/* when sig equals to sinfo->sig, means we are in the last resort
+	 * the CodeSigning should be checked */
+	if ((sig == sinfo->sig) && !check_codesign_eku_by_key(key, usage)) {
 		pr_warn("sinfo %u: The signer %x key is not CodeSigning\n",
 			sinfo->index, key_serial(key));
 		key_put(key);
--- a/crypto/asymmetric_keys/pkcs7_verify.c
+++ b/crypto/asymmetric_keys/pkcs7_verify.c
@@ -16,6 +16,41 @@
 #include <crypto/public_key.h>
 #include "pkcs7_parser.h"
 
+#ifdef CONFIG_CHECK_CODESIGN_EKU
+static bool check_codesign_eku(struct public_key *public_key,
+			     enum key_being_used_for usage)
+{
+	switch (usage) {
+	case VERIFYING_MODULE_SIGNATURE:
+	case VERIFYING_KEXEC_PE_SIGNATURE:
+		return !!(public_key->eku & EKU_codeSigning);
+	default:
+		break;
+	}
+	return true;
+}
+
+bool check_codesign_eku_by_key(struct key *key,
+			       enum key_being_used_for usage)
+{
+	struct public_key *public_key = key->payload.data[asym_crypto];
+
+	return check_codesign_eku(public_key, usage);
+}
+#else
+static bool check_codesign_eku(struct public_key *public_key,
+			     enum key_being_used_for usage)
+{
+	return true;
+}
+
+bool check_codesign_eku_by_key(struct key *key,
+			       enum key_being_used_for usage)
+{
+	return true;
+}
+#endif
+
 /*
  * Digest the relevant parts of the PKCS#7 data
  */
@@ -455,6 +490,11 @@ int pkcs7_verify(struct pkcs7_message *p
 				actual_ret = -EKEYREJECTED;
 			continue;
 		}
+		if (sinfo->signer &&
+		    !check_codesign_eku(sinfo->signer->pub, usage)) {
+			actual_ret = -EKEYREJECTED;
+			continue;
+		}
 		if (ret < 0) {
 			if (ret == -ENOPKG) {
 				sinfo->unsupported_crypto = true;

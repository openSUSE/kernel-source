From 9e794d4047052cd0101e4cc4844afcf7b683e2b9 Mon Sep 17 00:00:00 2001
From: David Disseldorp <ddiss@suse.de>
Date: Thu, 8 Jun 2017 17:05:12 +0200
Subject: [PATCH 07/11] rbd: do away with obj_request in getxattr
Patch-mainline: Not yet, clustered LIO/RBD
References: fate#321625

rbd_obj_request machinery is completely unnecessary for xattr
operations - no striping, cloning, etc. is performed.
More importantly, rbd_osd_req_create() grabs pool id from layout and
that is becoming a data pool id.

Signed-off-by: David Disseldorp <ddiss@suse.de>
Acked-by: Luis Henriques <lhenriques@suse.com>
Acked-by: Lee Duncan <lduncan@suse.com>
[luis: rebased atop 26f887e0a3c4 ("libceph, rbd, ceph: move
 ceph_osdc_alloc_messages() calls")]
---
 drivers/block/rbd.c |   71 +++++++++++++++++++++-------------------------------
 1 file changed, 30 insertions(+), 41 deletions(-)

--- a/drivers/block/rbd.c
+++ b/drivers/block/rbd.c
@@ -4641,7 +4641,7 @@ int rbd_dev_getxattr(struct rbd_device *
 		     void **_val, int *val_len)
 {
 	struct ceph_osd_client *osdc = &rbd_dev->rbd_client->client->osdc;
-	struct rbd_obj_request *obj_request;
+	struct ceph_osd_request *req;
 	int page_count;
 	struct page **pages = NULL;
 	void *val;
@@ -4650,67 +4650,56 @@ int rbd_dev_getxattr(struct rbd_device *
 	BUG_ON(!key);
 	BUG_ON(!_val || !val_len);
 
-	page_count = calc_pages_for(0, max_val_len);
-	pages = ceph_alloc_page_vector(page_count, GFP_KERNEL);
-	if (IS_ERR(pages))
-		return PTR_ERR(pages);
-
-	obj_request = rbd_obj_request_create(rbd_dev->header_name, 0,
-					     max_val_len, OBJ_REQUEST_PAGES);
-	if (!obj_request) {
-		ceph_release_page_vector(pages, page_count);
+	req = ceph_osdc_alloc_request(osdc, NULL, 1, false, GFP_KERNEL);
+	if (!req)
 		return -ENOMEM;
-	}
 
-	obj_request->pages = pages;
-	obj_request->page_count = page_count;
-
-	obj_request->osd_req = rbd_osd_req_create(rbd_dev, OBJ_OP_READ, 1,
-						  obj_request);
-	if (!obj_request->osd_req) {
-		ret = -ENOMEM;
-		goto out;
-	}
+	ceph_oid_copy(&req->r_base_oid, &rbd_dev->header_oid);
+	ceph_oloc_copy(&req->r_base_oloc, &rbd_dev->header_oloc);
+	req->r_flags = CEPH_OSD_FLAG_READ;
 
-	ret = osd_req_op_xattr_init(obj_request->osd_req, 0,
+	ret = osd_req_op_xattr_init(req, 0,
 				    CEPH_OSD_OP_GETXATTR,
 				    key, NULL, 0, 0, 0);
 	if (ret)
-		goto out;
+		goto out_req;
 
-	osd_req_op_xattr_response_data_pages(obj_request->osd_req, 0,
-					     obj_request->pages, max_val_len,
-					     0, false, false);
-	rbd_osd_req_format_read(obj_request);
+	page_count = calc_pages_for(0, max_val_len);
+	pages = ceph_alloc_page_vector(page_count, GFP_KERNEL);
+	if (IS_ERR(pages)) {
+		ret = PTR_ERR(pages);
+		goto out_req;
+	}
 
-	ret = rbd_obj_request_submit(osdc, obj_request);
-	if (ret)
-		goto out;
+	osd_req_op_xattr_response_data_pages(req, 0,
+					     pages, max_val_len,
+					     0, false, false);
 
-	ret = rbd_obj_request_wait(obj_request);
+	ret = ceph_osdc_alloc_messages(req, GFP_KERNEL);
 	if (ret)
-		goto out;
+		goto out_req;
 
-	ret = obj_request->result;
-	if (ret)
-		goto out;
+	ceph_osdc_start_request(osdc, req, false);
+	ret = ceph_osdc_wait_request(osdc, req);
+	if (ret < 0)
+		goto out_req;
 
-	rbd_assert(obj_request->xferred <= (u64)max_val_len);
+	rbd_assert(ret <= (u64)max_val_len);
 
-	val = kmalloc(obj_request->xferred, GFP_KERNEL);
+	val = kmalloc(ret, GFP_KERNEL);
 	if (!val) {
 		ret = -ENOMEM;
-		goto out;
+		goto out_req;
 	}
 
-	ceph_copy_from_page_vector(pages, val, 0, obj_request->xferred);
+	ceph_copy_from_page_vector(pages, val, 0, ret);
 	*_val = val;
-	*val_len = obj_request->xferred;
+	*val_len = ret;
 
 	ret = 0;
-out:
-	rbd_obj_request_put(obj_request);
 
+out_req:
+	ceph_osdc_put_request(req);
 	return ret;
 }
 EXPORT_SYMBOL(rbd_dev_getxattr);

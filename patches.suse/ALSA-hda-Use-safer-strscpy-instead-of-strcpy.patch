From 0bdbce25855f021187d16d4ffbb92102b9f13788 Mon Sep 17 00:00:00 2001
From: Takashi Iwai <tiwai@suse.de>
Date: Fri, 11 Jul 2025 10:30:50 +0200
Subject: [PATCH] ALSA: hda: Use safer strscpy() instead of strcpy()
Git-commit: 0bdbce25855f021187d16d4ffbb92102b9f13788
Patch-mainline: v6.17-rc1
References: jsc#PED-14430 jsc#PED-14297 jsc#PED-14024

Use a safer function strscpy() instead of strcpy() for copying to
arrays.

Only idiomatic code replacement, and no functional changes.

Link: https://patch.msgid.link/20250711083051.18759-1-tiwai@suse.de
Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
 sound/hda/codecs/ca0132.c          | 18 +++++++++---------
 sound/hda/codecs/generic.c         |  4 ++--
 sound/hda/codecs/realtek/realtek.c |  4 ++--
 sound/hda/common/codec.c           |  4 ++--
 sound/hda/controllers/intel.c      |  2 +-
 5 files changed, 16 insertions(+), 16 deletions(-)

diff --git a/sound/hda/codecs/ca0132.c b/sound/hda/codecs/ca0132.c
index 6ab59c336ed4..b716f721f25d 100644
--- a/sound/hda/codecs/ca0132.c
+++ b/sound/hda/codecs/ca0132.c
@@ -5796,7 +5796,7 @@ static int ca0132_alt_mic_boost_info(struct snd_kcontrol *kcontrol,
 	if (uinfo->value.enumerated.item >= MIC_BOOST_NUM_OF_STEPS)
 		uinfo->value.enumerated.item = MIC_BOOST_NUM_OF_STEPS - 1;
 	sprintf(namestr, "%d %s", (uinfo->value.enumerated.item * 10), sfx);
-	strcpy(uinfo->value.enumerated.name, namestr);
+	strscpy(uinfo->value.enumerated.name, namestr);
 	return 0;
 }
 
@@ -5850,7 +5850,7 @@ static int ae5_headphone_gain_info(struct snd_kcontrol *kcontrol,
 	sprintf(namestr, "%s %s",
 		ae5_headphone_gain_presets[uinfo->value.enumerated.item].name,
 		sfx);
-	strcpy(uinfo->value.enumerated.name, namestr);
+	strscpy(uinfo->value.enumerated.name, namestr);
 	return 0;
 }
 
@@ -5903,7 +5903,7 @@ static int ae5_sound_filter_info(struct snd_kcontrol *kcontrol,
 		uinfo->value.enumerated.item = AE5_SOUND_FILTER_MAX - 1;
 	sprintf(namestr, "%s",
 			ae5_filter_presets[uinfo->value.enumerated.item].name);
-	strcpy(uinfo->value.enumerated.name, namestr);
+	strscpy(uinfo->value.enumerated.name, namestr);
 	return 0;
 }
 
@@ -5952,7 +5952,7 @@ static int ca0132_alt_input_source_info(struct snd_kcontrol *kcontrol,
 	uinfo->value.enumerated.items = IN_SRC_NUM_OF_INPUTS;
 	if (uinfo->value.enumerated.item >= IN_SRC_NUM_OF_INPUTS)
 		uinfo->value.enumerated.item = IN_SRC_NUM_OF_INPUTS - 1;
-	strcpy(uinfo->value.enumerated.name,
+	strscpy(uinfo->value.enumerated.name,
 			in_src_str[uinfo->value.enumerated.item]);
 	return 0;
 }
@@ -6004,7 +6004,7 @@ static int ca0132_alt_output_select_get_info(struct snd_kcontrol *kcontrol,
 	uinfo->value.enumerated.items = NUM_OF_OUTPUTS;
 	if (uinfo->value.enumerated.item >= NUM_OF_OUTPUTS)
 		uinfo->value.enumerated.item = NUM_OF_OUTPUTS - 1;
-	strcpy(uinfo->value.enumerated.name,
+	strscpy(uinfo->value.enumerated.name,
 			out_type_str[uinfo->value.enumerated.item]);
 	return 0;
 }
@@ -6055,7 +6055,7 @@ static int ca0132_alt_speaker_channel_cfg_get_info(struct snd_kcontrol *kcontrol
 	uinfo->value.enumerated.items = items;
 	if (uinfo->value.enumerated.item >= items)
 		uinfo->value.enumerated.item = items - 1;
-	strcpy(uinfo->value.enumerated.name,
+	strscpy(uinfo->value.enumerated.name,
 			speaker_channel_cfgs[uinfo->value.enumerated.item].name);
 	return 0;
 }
@@ -6108,7 +6108,7 @@ static int ca0132_alt_svm_setting_info(struct snd_kcontrol *kcontrol,
 	uinfo->value.enumerated.items = NUM_OF_SVM_SETTINGS;
 	if (uinfo->value.enumerated.item >= NUM_OF_SVM_SETTINGS)
 		uinfo->value.enumerated.item = NUM_OF_SVM_SETTINGS - 1;
-	strcpy(uinfo->value.enumerated.name,
+	strscpy(uinfo->value.enumerated.name,
 			out_svm_set_enum_str[uinfo->value.enumerated.item]);
 	return 0;
 }
@@ -6172,7 +6172,7 @@ static int ca0132_alt_eq_preset_info(struct snd_kcontrol *kcontrol,
 	uinfo->value.enumerated.items = items;
 	if (uinfo->value.enumerated.item >= items)
 		uinfo->value.enumerated.item = items - 1;
-	strcpy(uinfo->value.enumerated.name,
+	strscpy(uinfo->value.enumerated.name,
 		ca0132_alt_eq_presets[uinfo->value.enumerated.item].name);
 	return 0;
 }
@@ -6229,7 +6229,7 @@ static int ca0132_voicefx_info(struct snd_kcontrol *kcontrol,
 	uinfo->value.enumerated.items = items;
 	if (uinfo->value.enumerated.item >= items)
 		uinfo->value.enumerated.item = items - 1;
-	strcpy(uinfo->value.enumerated.name,
+	strscpy(uinfo->value.enumerated.name,
 	       ca0132_voicefx_presets[uinfo->value.enumerated.item].name);
 	return 0;
 }
diff --git a/sound/hda/codecs/generic.c b/sound/hda/codecs/generic.c
index 044f1d0aeaea..a44beefe3e97 100644
--- a/sound/hda/codecs/generic.c
+++ b/sound/hda/codecs/generic.c
@@ -2828,7 +2828,7 @@ static int in_jack_mode_info(struct snd_kcontrol *kcontrol,
 	snd_hda_enum_helper_info(kcontrol, uinfo, hweight32(vref_caps),
 				 vref_texts);
 	/* set the right text */
-	strcpy(uinfo->value.enumerated.name,
+	strscpy(uinfo->value.enumerated.name,
 	       vref_texts[get_vref_idx(vref_caps, uinfo->value.enumerated.item)]);
 	return 0;
 }
@@ -2941,7 +2941,7 @@ static int hp_mic_jack_mode_info(struct snd_kcontrol *kcontrol,
 			text = "Mic In";
 	}
 
-	strcpy(uinfo->value.enumerated.name, text);
+	strscpy(uinfo->value.enumerated.name, text);
 	return 0;
 }
 
diff --git a/sound/hda/codecs/realtek/realtek.c b/sound/hda/codecs/realtek/realtek.c
index 66b2efb9acb3..b6feccfd45a9 100644
--- a/sound/hda/codecs/realtek/realtek.c
+++ b/sound/hda/codecs/realtek/realtek.c
@@ -1130,7 +1130,7 @@ void alc1220_fixup_gb_dual_codecs(struct hda_codec *codec,
 	switch (action) {
 	case HDA_FIXUP_ACT_PRE_PROBE:
 		/* override card longname to provide a unique UCM profile */
-		strcpy(codec->card->longname, "HDAudio-Gigabyte-ALC1220DualCodecs");
+		strscpy(codec->card->longname, "HDAudio-Gigabyte-ALC1220DualCodecs");
 		break;
 	case HDA_FIXUP_ACT_BUILD:
 		/* rename Capture controls depending on the codec */
@@ -1155,7 +1155,7 @@ void alc233_alc662_fixup_lenovo_dual_codecs(struct hda_codec *codec,
 	switch (action) {
 	case HDA_FIXUP_ACT_PRE_PROBE:
 		/* override card longname to provide a unique UCM profile */
-		strcpy(codec->card->longname, "HDAudio-Lenovo-DualCodecs");
+		strscpy(codec->card->longname, "HDAudio-Lenovo-DualCodecs");
 		break;
 	case HDA_FIXUP_ACT_BUILD:
 		/* rename Capture controls depending on the codec */
diff --git a/sound/hda/common/codec.c b/sound/hda/common/codec.c
index 8e47769ef0ce..eb268d442201 100644
--- a/sound/hda/common/codec.c
+++ b/sound/hda/common/codec.c
@@ -1638,7 +1638,7 @@ find_mixer_ctl(struct hda_codec *codec, const char *name, int dev, int idx)
 	id.index = idx;
 	if (snd_BUG_ON(strlen(name) >= sizeof(id.name)))
 		return NULL;
-	strcpy(id.name, name);
+	strscpy(id.name, name);
 	return snd_ctl_find_id(codec->card, &id);
 }
 
@@ -3508,7 +3508,7 @@ int snd_hda_input_mux_info(const struct hda_input_mux *imux,
 	index = uinfo->value.enumerated.item;
 	if (index >= imux->num_items)
 		index = imux->num_items - 1;
-	strcpy(uinfo->value.enumerated.name, imux->items[index].label);
+	strscpy(uinfo->value.enumerated.name, imux->items[index].label);
 	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_hda_input_mux_info);
diff --git a/sound/hda/controllers/intel.c b/sound/hda/controllers/intel.c
index ebfc999156f4..32bfd92d817f 100644
--- a/sound/hda/controllers/intel.c
+++ b/sound/hda/controllers/intel.c
@@ -2024,7 +2024,7 @@ static int azx_first_init(struct azx *chip)
 	if (azx_acquire_irq(chip, 0) < 0)
 		return -EBUSY;
 
-	strcpy(card->driver, "HDA-Intel");
+	strscpy(card->driver, "HDA-Intel");
 	strscpy(card->shortname, driver_short_names[chip->driver_type],
 		sizeof(card->shortname));
 	snprintf(card->longname, sizeof(card->longname),
-- 
2.52.0


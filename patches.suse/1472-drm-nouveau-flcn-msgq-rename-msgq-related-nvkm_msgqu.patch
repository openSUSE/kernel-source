From 712188b8d0faed249858f5fb38036fd6c9e08849 Mon Sep 17 00:00:00 2001
From: Ben Skeggs <bskeggs@redhat.com>
Date: Wed, 15 Jan 2020 06:34:22 +1000
Subject: drm/nouveau/flcn/msgq: rename msgq-related nvkm_msgqueue_queue to
Git-commit: 91a4e83a2d3e99af33a666508e86b96f4210fae6
Patch-mainline: v5.6-rc1
References: jsc#SLE-12680, jsc#SLE-12880, jsc#SLE-12882, jsc#SLE-12883, jsc#SLE-13496, jsc#SLE-15322
 nvkm_falcon_msgq

Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
Signed-off-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 .../drm/nouveau/include/nvkm/core/subdev.h    |  3 -
 drivers/gpu/drm/nouveau/nvkm/falcon/msgq.c    | 90 +++++++++----------
 .../gpu/drm/nouveau/nvkm/falcon/msgqueue.h    | 29 ------
 drivers/gpu/drm/nouveau/nvkm/falcon/qmgr.h    | 26 ++++++
 4 files changed, 71 insertions(+), 77 deletions(-)

diff --git a/drivers/gpu/drm/nouveau/include/nvkm/core/subdev.h b/drivers/gpu/drm/nouveau/include/nvkm/core/subdev.h
index b632a43c16ef..1218f28c14ba 100644
--- a/drivers/gpu/drm/nouveau/include/nvkm/core/subdev.h
+++ b/drivers/gpu/drm/nouveau/include/nvkm/core/subdev.h
@@ -3,9 +3,6 @@
 #define __NVKM_SUBDEV_H__
 #include <core/device.h>
 
-#define nvkm_falcon_cmdq nvkm_msgqueue_queue
-#define nvkm_falcon_msgq nvkm_msgqueue_queue
-
 struct nvkm_subdev {
 	const struct nvkm_subdev_func *func;
 	struct nvkm_device *device;
diff --git a/drivers/gpu/drm/nouveau/nvkm/falcon/msgq.c b/drivers/gpu/drm/nouveau/nvkm/falcon/msgq.c
index f3f2e333a10b..cbfe09a561a1 100644
--- a/drivers/gpu/drm/nouveau/nvkm/falcon/msgq.c
+++ b/drivers/gpu/drm/nouveau/nvkm/falcon/msgq.c
@@ -23,74 +23,74 @@
 #include "qmgr.h"
 
 static void
-msg_queue_open(struct nvkm_msgqueue_queue *queue)
+nvkm_falcon_msgq_open(struct nvkm_falcon_msgq *msgq)
 {
-	mutex_lock(&queue->mutex);
-	queue->position = nvkm_falcon_rd32(queue->qmgr->falcon, queue->tail_reg);
+	mutex_lock(&msgq->mutex);
+	msgq->position = nvkm_falcon_rd32(msgq->qmgr->falcon, msgq->tail_reg);
 }
 
 static void
-msg_queue_close(struct nvkm_msgqueue_queue *queue, bool commit)
+nvkm_falcon_msgq_close(struct nvkm_falcon_msgq *msgq, bool commit)
 {
-	struct nvkm_falcon *falcon = queue->qmgr->falcon;
+	struct nvkm_falcon *falcon = msgq->qmgr->falcon;
 
 	if (commit)
-		nvkm_falcon_wr32(falcon, queue->tail_reg, queue->position);
+		nvkm_falcon_wr32(falcon, msgq->tail_reg, msgq->position);
 
-	mutex_unlock(&queue->mutex);
+	mutex_unlock(&msgq->mutex);
 }
 
 static bool
-msg_queue_empty(struct nvkm_msgqueue_queue *queue)
+nvkm_falcon_msgq_empty(struct nvkm_falcon_msgq *msgq)
 {
-	u32 head = nvkm_falcon_rd32(queue->qmgr->falcon, queue->head_reg);
-	u32 tail = nvkm_falcon_rd32(queue->qmgr->falcon, queue->tail_reg);
+	u32 head = nvkm_falcon_rd32(msgq->qmgr->falcon, msgq->head_reg);
+	u32 tail = nvkm_falcon_rd32(msgq->qmgr->falcon, msgq->tail_reg);
 	return head == tail;
 }
 
 static int
-msg_queue_pop(struct nvkm_msgqueue_queue *queue, void *data, u32 size)
+nvkm_falcon_msgq_pop(struct nvkm_falcon_msgq *msgq, void *data, u32 size)
 {
-	struct nvkm_falcon *falcon = queue->qmgr->falcon;
+	struct nvkm_falcon *falcon = msgq->qmgr->falcon;
 	u32 head, tail, available;
 
-	head = nvkm_falcon_rd32(falcon, queue->head_reg);
+	head = nvkm_falcon_rd32(falcon, msgq->head_reg);
 	/* has the buffer looped? */
-	if (head < queue->position)
-		queue->position = queue->offset;
+	if (head < msgq->position)
+		msgq->position = msgq->offset;
 
-	tail = queue->position;
+	tail = msgq->position;
 
 	available = head - tail;
 	if (size > available) {
-		FLCNQ_ERR(queue, "requested %d bytes, but only %d available",
+		FLCNQ_ERR(msgq, "requested %d bytes, but only %d available",
 			  size, available);
 		return -EINVAL;
 	}
 
 	nvkm_falcon_read_dmem(falcon, tail, size, 0, data);
-	queue->position += ALIGN(size, QUEUE_ALIGNMENT);
+	msgq->position += ALIGN(size, QUEUE_ALIGNMENT);
 	return 0;
 }
 
 static int
-msg_queue_read(struct nvkm_msgqueue_queue *queue, struct nv_falcon_msg *hdr)
+nvkm_falcon_msgq_read(struct nvkm_falcon_msgq *msgq, struct nv_falcon_msg *hdr)
 {
 	int ret = 0;
 
-	msg_queue_open(queue);
+	nvkm_falcon_msgq_open(msgq);
 
-	if (msg_queue_empty(queue))
+	if (nvkm_falcon_msgq_empty(msgq))
 		goto close;
 
-	ret = msg_queue_pop(queue, hdr, HDR_SIZE);
+	ret = nvkm_falcon_msgq_pop(msgq, hdr, HDR_SIZE);
 	if (ret) {
-		FLCNQ_ERR(queue, "failed to read message header");
+		FLCNQ_ERR(msgq, "failed to read message header");
 		goto close;
 	}
 
 	if (hdr->size > MSG_BUF_SIZE) {
-		FLCNQ_ERR(queue, "message too big, %d bytes", hdr->size);
+		FLCNQ_ERR(msgq, "message too big, %d bytes", hdr->size);
 		ret = -ENOSPC;
 		goto close;
 	}
@@ -98,21 +98,21 @@ msg_queue_read(struct nvkm_msgqueue_queue *queue, struct nv_falcon_msg *hdr)
 	if (hdr->size > HDR_SIZE) {
 		u32 read_size = hdr->size - HDR_SIZE;
 
-		ret = msg_queue_pop(queue, (hdr + 1), read_size);
+		ret = nvkm_falcon_msgq_pop(msgq, (hdr + 1), read_size);
 		if (ret) {
-			FLCNQ_ERR(queue, "failed to read message data");
+			FLCNQ_ERR(msgq, "failed to read message data");
 			goto close;
 		}
 	}
 
 	ret = 1;
 close:
-	msg_queue_close(queue, (ret >= 0));
+	nvkm_falcon_msgq_close(msgq, (ret >= 0));
 	return ret;
 }
 
 static int
-msgqueue_msg_handle(struct nvkm_falcon_msgq *msgq, struct nv_falcon_msg *hdr)
+nvkm_falcon_msgq_exec(struct nvkm_falcon_msgq *msgq, struct nv_falcon_msg *hdr)
 {
 	struct nvkm_falcon_qmgr_seq *seq;
 
@@ -136,6 +136,20 @@ msgqueue_msg_handle(struct nvkm_falcon_msgq *msgq, struct nv_falcon_msg *hdr)
 	return 0;
 }
 
+void
+nvkm_falcon_msgq_recv(struct nvkm_falcon_msgq *msgq)
+{
+	/*
+	 * We are invoked from a worker thread, so normally we have plenty of
+	 * stack space to work with.
+	 */
+	u8 msg_buffer[MSG_BUF_SIZE];
+	struct nv_falcon_msg *hdr = (void *)msg_buffer;
+
+	while (nvkm_falcon_msgq_read(msgq, hdr) > 0)
+		nvkm_falcon_msgq_exec(msgq, hdr);
+}
+
 int
 nvkm_falcon_msgq_recv_initmsg(struct nvkm_falcon_msgq *msgq,
 			      void *data, u32 size)
@@ -148,31 +162,17 @@ nvkm_falcon_msgq_recv_initmsg(struct nvkm_falcon_msgq *msgq,
 	msgq->tail_reg = falcon->func->msgq.tail;
 	msgq->offset = nvkm_falcon_rd32(falcon, falcon->func->msgq.tail);
 
-	msg_queue_open(msgq);
-	ret = msg_queue_pop(msgq, data, size);
+	nvkm_falcon_msgq_open(msgq);
+	ret = nvkm_falcon_msgq_pop(msgq, data, size);
 	if (ret == 0 && hdr->size != size) {
 		FLCN_ERR(falcon, "unexpected init message size %d vs %d",
 			 hdr->size, size);
 		ret = -EINVAL;
 	}
-	msg_queue_close(msgq, ret == 0);
+	nvkm_falcon_msgq_close(msgq, ret == 0);
 	return ret;
 }
 
-void
-nvkm_falcon_msgq_recv(struct nvkm_falcon_msgq *queue)
-{
-	/*
-	 * We are invoked from a worker thread, so normally we have plenty of
-	 * stack space to work with.
-	 */
-	u8 msg_buffer[MSG_BUF_SIZE];
-	struct nv_falcon_msg *hdr = (void *)msg_buffer;
-
-	while (msg_queue_read(queue, hdr) > 0)
-		msgqueue_msg_handle(queue, hdr);
-}
-
 void
 nvkm_falcon_msgq_init(struct nvkm_falcon_msgq *msgq,
 		      u32 index, u32 offset, u32 size)
diff --git a/drivers/gpu/drm/nouveau/nvkm/falcon/msgqueue.h b/drivers/gpu/drm/nouveau/nvkm/falcon/msgqueue.h
index 750e4883cfcd..ec3baefa9004 100644
--- a/drivers/gpu/drm/nouveau/nvkm/falcon/msgqueue.h
+++ b/drivers/gpu/drm/nouveau/nvkm/falcon/msgqueue.h
@@ -69,35 +69,6 @@ struct nvkm_msgqueue_func {
 	void (*dtor)(struct nvkm_msgqueue *);
 };
 
-/**
- * struct nvkm_msgqueue_queue - information about a command or message queue
- *
- * The number of queues is firmware-dependent. All queues must have their
- * information filled by the init message handler.
- *
- * @mutex_lock:	to be acquired when the queue is being used
- * @index:	physical queue index
- * @offset:	DMEM offset where this queue begins
- * @size:	size allocated to this queue in DMEM (in bytes)
- * @position:	current write position
- * @head_reg:	address of the HEAD register for this queue
- * @tail_reg:	address of the TAIL register for this queue
- */
-struct nvkm_msgqueue_queue {
-	struct nvkm_falcon_qmgr *qmgr;
-	const char *name;
-	struct mutex mutex;
-	u32 index;
-	u32 offset;
-	u32 size;
-	u32 position;
-
-	u32 head_reg;
-	u32 tail_reg;
-
-	struct completion ready;
-};
-
 /**
  * struct nvkm_msgqueue - manage a command/message based FW on a falcon
  *
diff --git a/drivers/gpu/drm/nouveau/nvkm/falcon/qmgr.h b/drivers/gpu/drm/nouveau/nvkm/falcon/qmgr.h
index 935858c6a621..dca12efc25e8 100644
--- a/drivers/gpu/drm/nouveau/nvkm/falcon/qmgr.h
+++ b/drivers/gpu/drm/nouveau/nvkm/falcon/qmgr.h
@@ -57,6 +57,32 @@ nvkm_falcon_qmgr_seq_acquire(struct nvkm_falcon_qmgr *);
 void nvkm_falcon_qmgr_seq_release(struct nvkm_falcon_qmgr *,
 				  struct nvkm_falcon_qmgr_seq *);
 
+struct nvkm_falcon_cmdq {
+	struct nvkm_falcon_qmgr *qmgr;
+	const char *name;
+	struct mutex mutex;
+	struct completion ready;
+
+	u32 head_reg;
+	u32 tail_reg;
+	u32 offset;
+	u32 size;
+
+	u32 position;
+};
+
+struct nvkm_falcon_msgq {
+	struct nvkm_falcon_qmgr *qmgr;
+	const char *name;
+	struct mutex mutex;
+
+	u32 head_reg;
+	u32 tail_reg;
+	u32 offset;
+
+	u32 position;
+};
+
 #define FLCNQ_PRINTK(t,q,f,a...)                                               \
        FLCN_PRINTK(t, (q)->qmgr->falcon, "%s: "f, (q)->name, ##a)
 #define FLCNQ_DBG(q,f,a...) FLCNQ_PRINTK(debug, (q), f, ##a)
-- 
2.28.0


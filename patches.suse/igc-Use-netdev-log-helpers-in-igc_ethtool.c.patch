From: Andre Guedes <andre.guedes@intel.com>
Date: Tue, 24 Mar 2020 17:38:16 -0700
Subject: igc: Use netdev log helpers in igc_ethtool.c
Patch-mainline: v5.8-rc1
Git-commit: 95f96a9f2d04b20c26fca405f640acea07cf8b53
References: jsc#SLE-13533

In igc_ethtool.c we print log messages using dev_* helpers, generating
inconsistent output with the rest of the driver. Since this is a network
device driver, we should preferably use netdev_* helpers because they
append the interface name to the message, helping making sense the of
the logs.

This patch converts all dev_* calls to netdev_*.

Signed-off-by: Andre Guedes <andre.guedes@intel.com>
Tested-by: Aaron Brown <aaron.f.brown@intel.com>
Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/net/ethernet/intel/igc/igc_ethtool.c |   41 +++++++++++++--------------
 1 file changed, 21 insertions(+), 20 deletions(-)

--- a/drivers/net/ethernet/intel/igc/igc_ethtool.c
+++ b/drivers/net/ethernet/intel/igc/igc_ethtool.c
@@ -1155,8 +1155,8 @@ static int igc_set_rss_hash_opt(struct i
 
 		if ((flags & UDP_RSS_FLAGS) &&
 		    !(adapter->flags & UDP_RSS_FLAGS))
-			dev_err(&adapter->pdev->dev,
-				"enabling UDP RSS: fragmented packets may arrive out of order to the stack above\n");
+			netdev_err(adapter->netdev,
+				   "Enabling UDP RSS: fragmented packets may arrive out of order to the stack above\n");
 
 		adapter->flags = flags;
 
@@ -1195,7 +1195,8 @@ static int igc_rxnfc_write_etype_filter(
 			break;
 	}
 	if (i == MAX_ETYPE_FILTER) {
-		dev_err(&adapter->pdev->dev, "ethtool -N: etype filters are all used.\n");
+		netdev_err(adapter->netdev,
+			   "ethtool -N: etype filters are all used\n");
 		return -EINVAL;
 	}
 
@@ -1236,7 +1237,8 @@ static int igc_rxnfc_write_vlan_prio_fil
 	/* check whether this vlan prio is already set */
 	if (vlapqf & IGC_VLAPQF_P_VALID(vlan_priority) &&
 	    queue_index != input->action) {
-		dev_err(&adapter->pdev->dev, "ethtool rxnfc set vlan prio filter failed.\n");
+		netdev_err(adapter->netdev,
+			   "ethtool rxnfc set VLAN prio filter failed\n");
 		return -EEXIST;
 	}
 
@@ -1255,8 +1257,8 @@ int igc_add_filter(struct igc_adapter *a
 
 	if (hw->mac.type == igc_i225 &&
 	    !(input->filter.match_flags & ~IGC_FILTER_FLAG_SRC_MAC_ADDR)) {
-		dev_err(&adapter->pdev->dev,
-			"i225 doesn't support flow classification rules specifying only source addresses.\n");
+		netdev_err(adapter->netdev,
+			   "i225 doesn't support flow classification rules specifying only source addresses\n");
 		return -EOPNOTSUPP;
 	}
 
@@ -1404,13 +1406,14 @@ static int igc_add_ethtool_nfc_entry(str
 	 */
 	if (fsp->ring_cookie == RX_CLS_FLOW_DISC ||
 	    fsp->ring_cookie >= adapter->num_rx_queues) {
-		dev_err(&adapter->pdev->dev, "ethtool -N: The specified action is invalid\n");
+		netdev_err(netdev,
+			   "ethtool -N: The specified action is invalid\n");
 		return -EINVAL;
 	}
 
 	/* Don't allow indexes to exist outside of available space */
 	if (fsp->location >= IGC_MAX_RXNFC_FILTERS) {
-		dev_err(&adapter->pdev->dev, "Location out of range\n");
+		netdev_err(netdev, "Location out of range\n");
 		return -EINVAL;
 	}
 
@@ -1458,8 +1461,8 @@ static int igc_add_ethtool_nfc_entry(str
 		if (!memcmp(&input->filter, &rule->filter,
 			    sizeof(input->filter))) {
 			err = -EEXIST;
-			dev_err(&adapter->pdev->dev,
-				"ethtool: this filter is already set\n");
+			netdev_err(netdev,
+				   "ethtool: this filter is already set\n");
 			goto err_out_w_lock;
 		}
 	}
@@ -1832,6 +1835,7 @@ static int igc_set_link_ksettings(struct
 				  const struct ethtool_link_ksettings *cmd)
 {
 	struct igc_adapter *adapter = netdev_priv(netdev);
+	struct net_device *dev = adapter->netdev;
 	struct igc_hw *hw = &adapter->hw;
 	u32 advertising;
 
@@ -1839,8 +1843,7 @@ static int igc_set_link_ksettings(struct
 	 * cannot be changed
 	 */
 	if (igc_check_reset_block(hw)) {
-		dev_err(&adapter->pdev->dev,
-			"Cannot change link characteristics when reset is active.\n");
+		netdev_err(dev, "Cannot change link characteristics when reset is active\n");
 		return -EINVAL;
 	}
 
@@ -1851,7 +1854,7 @@ static int igc_set_link_ksettings(struct
 	if (cmd->base.eth_tp_mdix_ctrl) {
 		if (cmd->base.eth_tp_mdix_ctrl != ETH_TP_MDI_AUTO &&
 		    cmd->base.autoneg != AUTONEG_ENABLE) {
-			dev_err(&adapter->pdev->dev, "forcing MDI/MDI-X state is not supported when link speed and/or duplex are forced\n");
+			netdev_err(dev, "Forcing MDI/MDI-X state is not supported when link speed and/or duplex are forced\n");
 			return -EINVAL;
 		}
 	}
@@ -1868,9 +1871,7 @@ static int igc_set_link_ksettings(struct
 		if (adapter->fc_autoneg)
 			hw->fc.requested_mode = igc_fc_default;
 	} else {
-		/* calling this overrides forced MDI setting */
-		dev_info(&adapter->pdev->dev,
-			 "Force mode currently not supported\n");
+		netdev_info(dev, "Force mode currently not supported\n");
 	}
 
 	/* MDI-X => 2; MDI => 1; Auto => 3 */
@@ -1904,7 +1905,7 @@ static void igc_diag_test(struct net_dev
 	bool if_running = netif_running(netdev);
 
 	if (eth_test->flags == ETH_TEST_FL_OFFLINE) {
-		netdev_info(adapter->netdev, "offline testing starting");
+		netdev_info(adapter->netdev, "Offline testing starting");
 		set_bit(__IGC_TESTING, &adapter->state);
 
 		/* Link test performed before hardware reset so autoneg doesn't
@@ -1918,13 +1919,13 @@ static void igc_diag_test(struct net_dev
 		else
 			igc_reset(adapter);
 
-		netdev_info(adapter->netdev, "register testing starting");
+		netdev_info(adapter->netdev, "Register testing starting");
 		if (!igc_reg_test(adapter, &data[TEST_REG]))
 			eth_test->flags |= ETH_TEST_FL_FAILED;
 
 		igc_reset(adapter);
 
-		netdev_info(adapter->netdev, "eeprom testing starting");
+		netdev_info(adapter->netdev, "EEPROM testing starting");
 		if (!igc_eeprom_test(adapter, &data[TEST_EEP]))
 			eth_test->flags |= ETH_TEST_FL_FAILED;
 
@@ -1940,7 +1941,7 @@ static void igc_diag_test(struct net_dev
 		if (if_running)
 			igc_open(netdev);
 	} else {
-		netdev_info(adapter->netdev, "online testing starting");
+		netdev_info(adapter->netdev, "Online testing starting");
 
 		/* register, eeprom, intr and loopback tests not run online */
 		data[TEST_REG] = 0;

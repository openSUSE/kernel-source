From cb18cd26039f5cdecb0ac53fb447b6f0859f3d1c Mon Sep 17 00:00:00 2001
From: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date: Thu, 24 Oct 2024 01:29:52 +0000
Subject: [PATCH] ASoC: soc-core: do rtd->id trick at snd_soc_add_pcm_runtime()
Git-commit: cb18cd26039f5cdecb0ac53fb447b6f0859f3d1c
Patch-mainline: v6.13-rc1
References: jsc#PED-14430 jsc#PED-14297 jsc#PED-14024

qcom/qdsp6 want to use irregular rtd->id because of its topology.
Current code is calculating it at soc_init_pcm_runtime() which calls
soc_new_pcm(), and it doesn't save it to rtd->id.

Let's calculate and save it to rtd at snd_soc_add_pcm_runtime()
which create rtd and connect related components.

But, this feature should be implemented by using "dai_link" instead
of "component". Add FIXME as comment.

Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Link: https://patch.msgid.link/87r086b84w.wl-kuninori.morimoto.gx@renesas.com
Signed-off-by: Mark Brown <broonie@kernel.org>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 sound/soc/soc-core.c | 42 ++++++++++++++++++++++++------------------
 1 file changed, 24 insertions(+), 18 deletions(-)

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 233c91e60f0c..4f0bfe73fe15 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1166,7 +1166,7 @@ static int snd_soc_add_pcm_runtime(struct snd_soc_card *card,
 	struct snd_soc_pcm_runtime *rtd;
 	struct snd_soc_dai_link_component *codec, *platform, *cpu;
 	struct snd_soc_component *component;
-	int i, ret;
+	int i, id, ret;
 
 	lockdep_assert_held(&client_mutex);
 
@@ -1225,6 +1225,28 @@ static int snd_soc_add_pcm_runtime(struct snd_soc_card *card,
 		}
 	}
 
+	/*
+	 * Most drivers will register their PCMs using DAI link ordering but
+	 * topology based drivers can use the DAI link id field to set PCM
+	 * device number and then use rtd + a base offset of the BEs.
+	 *
+	 * FIXME
+	 *
+	 * This should be implemented by using "dai_link" feature instead of
+	 * "component" feature.
+	 */
+	id = rtd->id;
+	for_each_rtd_components(rtd, i, component) {
+		if (!component->driver->use_dai_pcm_id)
+			continue;
+
+		if (rtd->dai_link->no_pcm)
+			id += component->driver->be_pcm_base;
+		else
+			id = rtd->dai_link->id;
+	}
+	rtd->id = id;
+
 	return 0;
 
 _err_defer:
@@ -1457,8 +1479,7 @@ static int soc_init_pcm_runtime(struct snd_soc_card *card,
 {
 	struct snd_soc_dai_link *dai_link = rtd->dai_link;
 	struct snd_soc_dai *cpu_dai = snd_soc_rtd_to_cpu(rtd, 0);
-	struct snd_soc_component *component;
-	int ret, id, i;
+	int ret, id;
 
 	/* do machine specific initialization */
 	ret = snd_soc_link_init(rtd);
@@ -1475,21 +1496,6 @@ static int soc_init_pcm_runtime(struct snd_soc_card *card,
 
 	id = rtd->id;
 
-	/*
-	 * most drivers will register their PCMs using DAI link ordering but
-	 * topology based drivers can use the DAI link id field to set PCM
-	 * device number and then use rtd + a base offset of the BEs.
-	 */
-	for_each_rtd_components(rtd, i, component) {
-		if (!component->driver->use_dai_pcm_id)
-			continue;
-
-		if (rtd->dai_link->no_pcm)
-			id += component->driver->be_pcm_base;
-		else
-			id = rtd->dai_link->id;
-	}
-
 	/* create compress_device if possible */
 	ret = snd_soc_dai_compress_new(cpu_dai, rtd, id);
 	if (ret != -ENOTSUPP)
-- 
2.52.0


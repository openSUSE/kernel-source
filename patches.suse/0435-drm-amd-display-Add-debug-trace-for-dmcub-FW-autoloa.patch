From 2a8dc80c59cf700f9cb72801701dd423e9b7fc76 Mon Sep 17 00:00:00 2001
From: Yongqiang Sun <yongqiang.sun@amd.com>
Date: Sat, 26 Oct 2019 10:19:40 -0400
Subject: drm/amd/display: Add debug trace for dmcub FW autoload.
Git-commit: b9e9f11c9145a2f5ffb50adf450c649fadd54e02
Patch-mainline: v5.6-rc1
References: jsc#SLE-12680, jsc#SLE-12880, jsc#SLE-12882, jsc#SLE-12883, jsc#SLE-13496, jsc#SLE-15322

[Why & How]
1. Add trace code enum for easy debugging.
2. Add trace during uC boot up, including loading phy FW
   and dmcu FW.
3. Change cache memory type back to write back,
   since write through has issue when resume from S0i3 100% hang after
   3.2ms.
4. Change CW3 base address to hard code value to avoid memory overlap
   with cw1.
5. Change polling phy init done to infinite loop to avoid dcn hang when
   dmcub uC stalled.
6. Add dmcub FW dis-assembly file to repositatory for debug purpose.

Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 .../amd/display/dmub/inc/dmub_trace_buffer.h  | 21 +++++++++++++++++--
 .../gpu/drm/amd/display/dmub/src/dmub_dcn20.c |  2 +-
 .../gpu/drm/amd/display/dmub/src/dmub_srv.c   | 20 +++++++++++-------
 3 files changed, 33 insertions(+), 10 deletions(-)

diff --git a/drivers/gpu/drm/amd/display/dmub/inc/dmub_trace_buffer.h b/drivers/gpu/drm/amd/display/dmub/inc/dmub_trace_buffer.h
index 9707706ba8ce..b0ee099d8a6e 100644
--- a/drivers/gpu/drm/amd/display/dmub/inc/dmub_trace_buffer.h
+++ b/drivers/gpu/drm/amd/display/dmub/inc/dmub_trace_buffer.h
@@ -30,8 +30,25 @@
 #define LOAD_DMCU_FW	1
 #define LOAD_PHY_FW	2
 
+
+enum dmucb_trace_code {
+	DMCUB__UNKNOWN,
+	DMCUB__MAIN_BEGIN,
+	DMCUB__PHY_INIT_BEGIN,
+	DMCUB__PHY_FW_SRAM_LOAD_BEGIN,
+	DMCUB__PHY_FW_SRAM_LOAD_END,
+	DMCUB__PHY_INIT_POLL_DONE,
+	DMCUB__PHY_INIT_END,
+	DMCUB__DMCU_ERAM_LOAD_BEGIN,
+	DMCUB__DMCU_ERAM_LOAD_END,
+	DMCUB__DMCU_ISR_LOAD_BEGIN,
+	DMCUB__DMCU_ISR_LOAD_END,
+	DMCUB__MAIN_IDLE,
+	DMCUB__PERF_TRACE,
+};
+
 struct dmcub_trace_buf_entry {
-	uint32_t trace_code;
+	enum dmucb_trace_code trace_code;
 	uint32_t tick_count;
 	uint32_t param0;
 	uint32_t param1;
@@ -40,6 +57,7 @@ struct dmcub_trace_buf_entry {
 #define TRACE_BUF_SIZE (1024) //1 kB
 #define PERF_TRACE_MAX_ENTRY ((TRACE_BUF_SIZE - 8)/sizeof(struct dmcub_trace_buf_entry))
 
+
 struct dmcub_trace_buf {
 	uint32_t entry_count;
 	uint32_t clk_freq;
@@ -47,5 +65,4 @@ struct dmcub_trace_buf {
 };
 
 
-
 #endif /* _DMUB_TRACE_BUFFER_H_ */
diff --git a/drivers/gpu/drm/amd/display/dmub/src/dmub_dcn20.c b/drivers/gpu/drm/amd/display/dmub/src/dmub_dcn20.c
index 89fd27758dd5..e2b2cf2e01fd 100644
--- a/drivers/gpu/drm/amd/display/dmub/src/dmub_dcn20.c
+++ b/drivers/gpu/drm/amd/display/dmub/src/dmub_dcn20.c
@@ -138,5 +138,5 @@ bool dmub_dcn20_is_supported(struct dmub_srv *dmub)
 
 bool dmub_dcn20_is_phy_init(struct dmub_srv *dmub)
 {
-	return REG_READ(DMCUB_SCRATCH10) != 0;
+	return REG_READ(DMCUB_SCRATCH10) == 0;
 }
diff --git a/drivers/gpu/drm/amd/display/dmub/src/dmub_srv.c b/drivers/gpu/drm/amd/display/dmub/src/dmub_srv.c
index 0dd32edbbcb3..5ae1906ff1b1 100644
--- a/drivers/gpu/drm/amd/display/dmub/src/dmub_srv.c
+++ b/drivers/gpu/drm/amd/display/dmub/src/dmub_srv.c
@@ -26,6 +26,8 @@
 #include "../inc/dmub_srv.h"
 #include "dmub_dcn20.h"
 #include "dmub_dcn21.h"
+#include "dmub_trace_buffer.h"
+#include "os_types.h"
 /*
  * Note: the DMUB service is standalone. No additional headers should be
  * added below or above this line unless they reside within the DMUB
@@ -44,8 +46,6 @@
 /* Mailbox size */
 #define DMUB_MAILBOX_SIZE (DMUB_RB_SIZE)
 
-/* Tracebuffer size */
-#define DMUB_TRACEBUFF_SIZE (1024) //1kB buffer
 
 /* Number of windows in use. */
 #define DMUB_NUM_WINDOWS (DMUB_WINDOW_5_TRACEBUFF + 1)
@@ -53,6 +53,7 @@
 
 #define DMUB_CW0_BASE (0x60000000)
 #define DMUB_CW1_BASE (0x61000000)
+#define DMUB_CW3_BASE (0x63000000)
 #define DMUB_CW5_BASE (0x65000000)
 
 static inline uint32_t dmub_align(uint32_t val, uint32_t factor)
@@ -181,7 +182,7 @@ dmub_srv_calc_region_info(struct dmub_srv *dmub,
 	mail->top = mail->base + DMUB_MAILBOX_SIZE;
 
 	trace_buff->base = dmub_align(mail->top, 256);
-	trace_buff->top = trace_buff->base + DMUB_TRACEBUFF_SIZE;
+	trace_buff->top = trace_buff->base + TRACE_BUF_SIZE;
 
 	out->fb_size = dmub_align(trace_buff->top, 4096);
 
@@ -291,7 +292,7 @@ enum dmub_status dmub_srv_hw_init(struct dmub_srv *dmub,
 		cw2.region.top = cw2.region.base + data_fb->size;
 
 		cw3.offset.quad_part = bios_fb->gpu_addr;
-		cw3.region.base = DMUB_CW1_BASE + stack_fb->size;
+		cw3.region.base = DMUB_CW3_BASE;
 		cw3.region.top = cw3.region.base + bios_fb->size;
 
 		cw4.offset.quad_part = mail_fb->gpu_addr;
@@ -394,19 +395,24 @@ enum dmub_status dmub_srv_wait_for_auto_load(struct dmub_srv *dmub,
 enum dmub_status dmub_srv_wait_for_phy_init(struct dmub_srv *dmub,
 					    uint32_t timeout_us)
 {
-	uint32_t i;
+	uint32_t i = 0;
 
 	if (!dmub->hw_init || !dmub->hw_funcs.is_phy_init)
 		return DMUB_STATUS_INVALID;
 
-	for (i = 0; i <= timeout_us; i += 10) {
+/*	for (i = 0; i <= timeout_us; i += 10) {
 		if (dmub->hw_funcs.is_phy_init(dmub))
 			return DMUB_STATUS_OK;
 
 		udelay(10);
+	}*/
+	while (!dmub->hw_funcs.is_phy_init(dmub)) {
+		ASSERT(i <= timeout_us);
+		i += 10;
+		udelay(10);
 	}
 
-	return DMUB_STATUS_TIMEOUT;
+	return DMUB_STATUS_OK;
 }
 
 enum dmub_status dmub_srv_wait_for_idle(struct dmub_srv *dmub,
-- 
2.28.0


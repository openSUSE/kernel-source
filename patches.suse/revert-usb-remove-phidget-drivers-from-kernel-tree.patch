From c498af3f0c5406e135eeb8be2a49713f1fbe6595 Mon Sep 17 00:00:00 2001
From: Greg Kroah-Hartman <gregkh@suse.de>
Date: Fri, 4 Dec 2009 08:31:49 -0800
Subject: Revert "USB: remove phidget drivers from kernel tree."
Patch-mainline: never

Remove this patch for openSUSE 11.3

This reverts commit 77aa2b5878f48d6ab6e0c412cc9214c845483475 which removed
the phidget drivers from the kernel tree.

For SLE11 SP1, we need to put the driver back as we said we would
support it for the lifetime of SLE11, despite upstream dropping the
driver and using a userspace library instead.

The userspace library will still work if anyone wants to use it, and it
can be found at:
	http://www.phidgets.com/downloads.php?os_id=3
and full documentation at:
	http://www.phidgets.com/documentation/web/cdoc/index.html

Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/misc/Kconfig               |   39 +
 drivers/usb/misc/Makefile              |    4 
 drivers/usb/misc/phidget.c             |   43 +
 drivers/usb/misc/phidget.h             |   12 
 drivers/usb/misc/phidgetkit.c          |  740 +++++++++++++++++++++++++++++++++
 drivers/usb/misc/phidgetmotorcontrol.c |  465 ++++++++++++++++++++
 drivers/usb/misc/phidgetservo.c        |  375 ++++++++++++++++
 7 files changed, 1678 insertions(+)

--- a/drivers/usb/misc/Kconfig
+++ b/drivers/usb/misc/Kconfig
@@ -135,6 +135,45 @@ config USB_CYTHERM
 	  To compile this driver as a module, choose M here: the
 	  module will be called cytherm.
 
+config USB_PHIDGET
+	tristate "USB Phidgets drivers"
+	depends on USB
+	help
+	  Say Y here to enable the various drivers for devices from
+	  Phidgets inc.
+
+config USB_PHIDGETKIT
+	tristate "USB PhidgetInterfaceKit support"
+	depends on USB_PHIDGET
+	help
+	  Say Y here if you want to connect a PhidgetInterfaceKit USB device
+	  from Phidgets Inc.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called phidgetkit.
+
+config USB_PHIDGETMOTORCONTROL
+	tristate "USB PhidgetMotorControl support"
+	depends on USB_PHIDGET
+	help
+	  Say Y here if you want to connect a PhidgetMotorControl USB device
+	  from Phidgets Inc.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called phidgetmotorcontrol.
+
+config USB_PHIDGETSERVO
+	tristate "USB PhidgetServo support"
+	depends on USB_PHIDGET
+	help
+	  Say Y here if you want to connect an 1 or 4 Motor PhidgetServo
+	  servo controller version 2.0 or 3.0.
+
+	  Phidgets Inc. has a web page at <http://www.phidgets.com/>.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called phidgetservo.
+
 config USB_IDMOUSE
 	tristate "Siemens ID USB Mouse Fingerprint sensor support"
 	depends on USB
--- a/drivers/usb/misc/Makefile
+++ b/drivers/usb/misc/Makefile
@@ -18,6 +18,10 @@ obj-$(CONFIG_USB_LCD)		+= usblcd.o
 obj-$(CONFIG_USB_LD)		+= ldusb.o
 obj-$(CONFIG_USB_LED)		+= usbled.o
 obj-$(CONFIG_USB_LEGOTOWER)	+= legousbtower.o
+obj-$(CONFIG_USB_PHIDGET)	+= phidget.o
+obj-$(CONFIG_USB_PHIDGETKIT)	+= phidgetkit.o
+obj-$(CONFIG_USB_PHIDGETMOTORCONTROL)	+= phidgetmotorcontrol.o
+obj-$(CONFIG_USB_PHIDGETSERVO)	+= phidgetservo.o
 obj-$(CONFIG_USB_RIO500)	+= rio500.o
 obj-$(CONFIG_USB_TEST)		+= usbtest.o
 obj-$(CONFIG_USB_TRANCEVIBRATOR)	+= trancevibrator.o
--- /dev/null
+++ b/drivers/usb/misc/phidget.c
@@ -0,0 +1,43 @@
+/*
+ * USB Phidgets class
+ *
+ * Copyright (C) 2006  Sean Young <sean@mess.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/device.h>
+
+struct class *phidget_class;
+
+static int __init init_phidget(void)
+{
+	phidget_class = class_create(THIS_MODULE, "phidget");
+
+	if (IS_ERR(phidget_class))
+		return PTR_ERR(phidget_class);
+
+	return 0;
+}
+
+static void __exit cleanup_phidget(void)
+{
+	class_destroy(phidget_class);
+}
+
+EXPORT_SYMBOL_GPL(phidget_class);
+
+module_init(init_phidget);
+module_exit(cleanup_phidget);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Sean Young <sean@mess.org>");
+MODULE_DESCRIPTION("Container module for phidget class");
+
--- /dev/null
+++ b/drivers/usb/misc/phidget.h
@@ -0,0 +1,12 @@
+/*
+ * USB Phidgets class
+ *
+ * Copyright (C) 2006  Sean Young <sean@mess.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+extern struct class *phidget_class;
--- /dev/null
+++ b/drivers/usb/misc/phidgetkit.c
@@ -0,0 +1,740 @@
+/*
+ * USB PhidgetInterfaceKit driver 1.0
+ *
+ * Copyright (C) 2004, 2006 Sean Young <sean@mess.org>
+ * Copyright (C) 2005 Daniel Saakes <daniel@saakes.net>
+ * Copyright (C) 2004 Greg Kroah-Hartman <greg@kroah.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This is a driver for the USB PhidgetInterfaceKit.
+ */
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/usb.h>
+
+#include "phidget.h"
+
+#define DRIVER_AUTHOR "Sean Young <sean@mess.org>"
+#define DRIVER_DESC "USB PhidgetInterfaceKit Driver"
+
+#define USB_VENDOR_ID_GLAB		0x06c2
+#define USB_DEVICE_ID_INTERFACEKIT004	0x0040
+#define USB_DEVICE_ID_INTERFACEKIT01616	0x0044
+#define USB_DEVICE_ID_INTERFACEKIT888	0x0045
+#define USB_DEVICE_ID_INTERFACEKIT047	0x0051
+#define USB_DEVICE_ID_INTERFACEKIT088	0x0053
+
+#define USB_VENDOR_ID_WISEGROUP		0x0925
+#define USB_DEVICE_ID_INTERFACEKIT884	0x8201
+
+#define MAX_INTERFACES			16
+
+#define URB_INT_SIZE			8
+
+struct driver_interfacekit {
+	int sensors;
+	int inputs;
+	int outputs;
+	int has_lcd;
+	int amnesiac;
+};
+
+#define ifkit(_sensors, _inputs, _outputs, _lcd, _amnesiac)		\
+{									\
+	.sensors	= _sensors,					\
+	.inputs		= _inputs,					\
+	.outputs	= _outputs,					\
+	.has_lcd	= _lcd,						\
+	.amnesiac	= _amnesiac					\
+};
+
+static const struct driver_interfacekit ph_004 = ifkit(0, 0, 4, 0, 0);
+static const struct driver_interfacekit ph_888n = ifkit(8, 8, 8, 0, 1);
+static const struct driver_interfacekit ph_888o = ifkit(8, 8, 8, 0, 0);
+static const struct driver_interfacekit ph_047 = ifkit(0, 4, 7, 1, 0);
+static const struct driver_interfacekit ph_884 = ifkit(8, 8, 4, 0, 0);
+static const struct driver_interfacekit ph_088 = ifkit(0, 8, 8, 1, 0);
+static const struct driver_interfacekit ph_01616 = ifkit(0, 16, 16, 0, 0);
+
+static unsigned long device_no;
+
+struct interfacekit {
+	struct usb_device *udev;
+	struct usb_interface *intf;
+	struct driver_interfacekit *ifkit;
+	struct device *dev;
+	unsigned long outputs;
+	int dev_no;
+	u8 inputs[MAX_INTERFACES];
+	u16 sensors[MAX_INTERFACES];
+	u8 lcd_files_on;
+
+	struct urb *irq;
+	unsigned char *data;
+	dma_addr_t data_dma;
+
+	struct delayed_work do_notify;
+	struct delayed_work do_resubmit;
+	unsigned long input_events;
+	unsigned long sensor_events;
+};
+
+static struct usb_device_id id_table[] = {
+	{USB_DEVICE(USB_VENDOR_ID_GLAB, USB_DEVICE_ID_INTERFACEKIT004),
+		.driver_info = (kernel_ulong_t)&ph_004},
+	{USB_DEVICE_VER(USB_VENDOR_ID_GLAB, USB_DEVICE_ID_INTERFACEKIT888, 0, 0x814),
+		.driver_info = (kernel_ulong_t)&ph_888o},
+	{USB_DEVICE_VER(USB_VENDOR_ID_GLAB, USB_DEVICE_ID_INTERFACEKIT888, 0x0815, 0xffff),
+		.driver_info = (kernel_ulong_t)&ph_888n},
+	{USB_DEVICE(USB_VENDOR_ID_GLAB, USB_DEVICE_ID_INTERFACEKIT047),
+		.driver_info = (kernel_ulong_t)&ph_047},
+	{USB_DEVICE(USB_VENDOR_ID_GLAB, USB_DEVICE_ID_INTERFACEKIT088),
+		.driver_info = (kernel_ulong_t)&ph_088},
+	{USB_DEVICE(USB_VENDOR_ID_GLAB, USB_DEVICE_ID_INTERFACEKIT01616),
+		.driver_info = (kernel_ulong_t)&ph_01616},
+	{USB_DEVICE(USB_VENDOR_ID_WISEGROUP, USB_DEVICE_ID_INTERFACEKIT884),
+		.driver_info = (kernel_ulong_t)&ph_884},
+	{}
+};
+MODULE_DEVICE_TABLE(usb, id_table);
+
+static int set_outputs(struct interfacekit *kit)
+{
+	u8 *buffer;
+	int retval;
+
+	buffer = kzalloc(4, GFP_KERNEL);
+	if (!buffer) {
+		dev_err(&kit->udev->dev, "%s - out of memory\n", __func__);
+		return -ENOMEM;
+	}
+	buffer[0] = (u8)kit->outputs;
+	buffer[1] = (u8)(kit->outputs >> 8);
+
+	dev_dbg(&kit->udev->dev, "sending data: 0x%04x\n", (u16)kit->outputs);
+
+	retval = usb_control_msg(kit->udev,
+			 usb_sndctrlpipe(kit->udev, 0),
+			 0x09, 0x21, 0x0200, 0x0000, buffer, 4, 2000);
+
+	if (retval != 4)
+		dev_err(&kit->udev->dev, "usb_control_msg returned %d\n",
+				retval);
+	kfree(buffer);
+
+	if (kit->ifkit->amnesiac)
+		schedule_delayed_work(&kit->do_resubmit, HZ / 2);
+
+	return retval < 0 ? retval : 0;
+}
+
+static int change_string(struct interfacekit *kit, const char *display, unsigned char row)
+{
+	unsigned char *buffer;
+	unsigned char *form_buffer;
+	int retval = -ENOMEM;
+	int i,j, len, buf_ptr;
+
+	buffer = kmalloc(8, GFP_KERNEL);
+	form_buffer = kmalloc(30, GFP_KERNEL);
+	if ((!buffer) || (!form_buffer)) {
+		dev_err(&kit->udev->dev, "%s - out of memory\n", __func__);
+		goto exit;
+	}
+
+	len = strlen(display);
+	if (len > 20)
+		len = 20;
+
+	dev_dbg(&kit->udev->dev, "Setting LCD line %d to %s\n", row, display);
+
+	form_buffer[0] = row * 0x40 + 0x80;
+	form_buffer[1] = 0x02;
+	buf_ptr = 2;
+	for (i = 0; i<len; i++)
+		form_buffer[buf_ptr++] = display[i];
+
+	for (i = 0; i < (20 - len); i++)
+		form_buffer[buf_ptr++] = 0x20;
+	form_buffer[buf_ptr++] = 0x01;
+	form_buffer[buf_ptr++] = row * 0x40 + 0x80 + strlen(display);
+
+	for (i = 0; i < buf_ptr; i += 7) {
+		if ((buf_ptr - i) > 7)
+			len = 7;
+		else
+			len = (buf_ptr - i);
+		for (j = 0; j < len; j++)
+			buffer[j] = form_buffer[i + j];
+		buffer[7] = len;
+
+		retval = usb_control_msg(kit->udev,
+				 usb_sndctrlpipe(kit->udev, 0),
+				 0x09, 0x21, 0x0200, 0x0000, buffer, 8, 2000);
+		if (retval < 0)
+			goto exit;
+	}
+
+	retval = 0;
+exit:
+	kfree(buffer);
+	kfree(form_buffer);
+
+	return retval;
+}
+
+#define set_lcd_line(number)	\
+static ssize_t lcd_line_##number(struct device *dev,			\
+					struct device_attribute *attr,	\
+					const char *buf, size_t count)	\
+{									\
+	struct interfacekit *kit = dev_get_drvdata(dev);		\
+	change_string(kit, buf, number - 1);				\
+	return count;							\
+}
+
+#define lcd_line_attr(number)						\
+	__ATTR(lcd_line_##number, S_IWUGO, NULL, lcd_line_##number)
+
+set_lcd_line(1);
+set_lcd_line(2);
+
+static ssize_t set_backlight(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct interfacekit *kit = dev_get_drvdata(dev);
+	int enabled;
+	unsigned char *buffer;
+	int retval = -ENOMEM;
+
+	buffer = kzalloc(8, GFP_KERNEL);
+	if (!buffer) {
+		dev_err(&kit->udev->dev, "%s - out of memory\n", __func__);
+		goto exit;
+	}
+
+	if (sscanf(buf, "%d", &enabled) < 1) {
+		retval = -EINVAL;
+		goto exit;
+	}
+	if (enabled)
+		buffer[0] = 0x01;
+	buffer[7] = 0x11;
+
+	dev_dbg(&kit->udev->dev, "Setting backlight to %s\n", enabled ? "on" : "off");
+
+	retval = usb_control_msg(kit->udev,
+			 usb_sndctrlpipe(kit->udev, 0),
+			 0x09, 0x21, 0x0200, 0x0000, buffer, 8, 2000);
+	if (retval < 0)
+		goto exit;
+
+	retval = count;
+exit:
+	kfree(buffer);
+	return retval;
+}
+
+static struct device_attribute dev_lcd_line_attrs[] = {
+	lcd_line_attr(1),
+	lcd_line_attr(2),
+	__ATTR(backlight, S_IWUGO, NULL, set_backlight)
+};
+
+static void remove_lcd_files(struct interfacekit *kit)
+{
+	int i;
+
+	if (kit->lcd_files_on) {
+		dev_dbg(&kit->udev->dev, "Removing lcd files\n");
+
+		for (i=0; i<ARRAY_SIZE(dev_lcd_line_attrs); i++)
+			device_remove_file(kit->dev, &dev_lcd_line_attrs[i]);
+	}
+}
+
+static ssize_t enable_lcd_files(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct interfacekit *kit = dev_get_drvdata(dev);
+	int enable;
+	int i, rc;
+
+	if (kit->ifkit->has_lcd == 0)
+		return -ENODEV;
+
+	if (sscanf(buf, "%d", &enable) < 1)
+		return -EINVAL;
+
+	if (enable) {
+		if (!kit->lcd_files_on) {
+			dev_dbg(&kit->udev->dev, "Adding lcd files\n");
+			for (i=0; i<ARRAY_SIZE(dev_lcd_line_attrs); i++) {
+				rc = device_create_file(kit->dev,
+					&dev_lcd_line_attrs[i]);
+				if (rc)
+					goto out;
+			}
+			kit->lcd_files_on = 1;
+		}
+	} else {
+		if (kit->lcd_files_on) {
+			remove_lcd_files(kit);
+			kit->lcd_files_on = 0;
+		}
+	}
+
+	return count;
+out:
+	while (i-- > 0)
+		device_remove_file(kit->dev, &dev_lcd_line_attrs[i]);
+
+	return rc;
+}
+
+static DEVICE_ATTR(lcd, S_IWUGO, NULL, enable_lcd_files);
+
+static void interfacekit_irq(struct urb *urb)
+{
+	struct interfacekit *kit = urb->context;
+	unsigned char *buffer = kit->data;
+	int i, level, sensor;
+	int retval;
+	int status = urb->status;
+
+	switch (status) {
+	case 0:			/* success */
+		break;
+	case -ECONNRESET:	/* unlink */
+	case -ENOENT:
+	case -ESHUTDOWN:
+		return;
+	/* -EPIPE:  should clear the halt */
+	default:		/* error */
+		goto resubmit;
+	}
+
+	/* digital inputs */
+	if (kit->ifkit->inputs == 16) {
+		for (i=0; i < 8; i++) {
+			level = (buffer[0] >> i) & 1;
+			if (kit->inputs[i] != level) {
+				kit->inputs[i] = level;
+				set_bit(i, &kit->input_events);
+			}
+			level = (buffer[1] >> i) & 1;
+			if (kit->inputs[8 + i] != level) {
+				kit->inputs[8 + i] = level;
+				set_bit(8 + i, &kit->input_events);
+			}
+		}
+	}
+	else if (kit->ifkit->inputs == 8) {
+		for (i=0; i < 8; i++) {
+			level = (buffer[1] >> i) & 1;
+			if (kit->inputs[i] != level) {
+				kit->inputs[i] = level;
+				set_bit(i, &kit->input_events);
+			}
+		}
+	}
+
+	/* analog inputs */
+	if (kit->ifkit->sensors) {
+		sensor = (buffer[0] & 1) ? 4 : 0;
+
+		level = buffer[2] + (buffer[3] & 0x0f) * 256;
+		if (level != kit->sensors[sensor]) {
+			kit->sensors[sensor] = level;
+			set_bit(sensor, &kit->sensor_events);
+		}
+		sensor++;
+		level = buffer[4] + (buffer[3] & 0xf0) * 16;
+		if (level != kit->sensors[sensor]) {
+			kit->sensors[sensor] = level;
+			set_bit(sensor, &kit->sensor_events);
+		}
+		sensor++;
+		level = buffer[5] + (buffer[6] & 0x0f) * 256;
+		if (level != kit->sensors[sensor]) {
+			kit->sensors[sensor] = level;
+			set_bit(sensor, &kit->sensor_events);
+		}
+		sensor++;
+		level = buffer[7] + (buffer[6] & 0xf0) * 16;
+		if (level != kit->sensors[sensor]) {
+			kit->sensors[sensor] = level;
+			set_bit(sensor, &kit->sensor_events);
+		}
+	}
+
+	if (kit->input_events || kit->sensor_events)
+		schedule_delayed_work(&kit->do_notify, 0);
+
+resubmit:
+	retval = usb_submit_urb(urb, GFP_ATOMIC);
+	if (retval)
+		err("can't resubmit intr, %s-%s/interfacekit0, retval %d",
+			kit->udev->bus->bus_name,
+			kit->udev->devpath, retval);
+}
+
+static void do_notify(struct work_struct *work)
+{
+	struct interfacekit *kit =
+		container_of(work, struct interfacekit, do_notify.work);
+	int i;
+	char sysfs_file[8];
+
+	for (i=0; i<kit->ifkit->inputs; i++) {
+		if (test_and_clear_bit(i, &kit->input_events)) {
+			sprintf(sysfs_file, "input%d", i + 1);
+			sysfs_notify(&kit->dev->kobj, NULL, sysfs_file);
+		}
+	}
+
+	for (i=0; i<kit->ifkit->sensors; i++) {
+		if (test_and_clear_bit(i, &kit->sensor_events)) {
+			sprintf(sysfs_file, "sensor%d", i + 1);
+			sysfs_notify(&kit->dev->kobj, NULL, sysfs_file);
+		}
+	}
+}
+
+static void do_resubmit(struct work_struct *work)
+{
+	struct interfacekit *kit =
+		container_of(work, struct interfacekit, do_resubmit.work);
+	set_outputs(kit);
+}
+
+#define show_set_output(value)		\
+static ssize_t set_output##value(struct device *dev,			\
+					struct device_attribute *attr,	\
+					const char *buf, size_t count)	\
+{									\
+	struct interfacekit *kit = dev_get_drvdata(dev);		\
+	int enable;							\
+	int retval;							\
+									\
+	if (sscanf(buf, "%d", &enable) < 1)				\
+		return -EINVAL;						\
+									\
+	if (enable)							\
+		set_bit(value - 1, &kit->outputs);			\
+	else								\
+		clear_bit(value - 1, &kit->outputs); 			\
+									\
+	retval = set_outputs(kit);					\
+									\
+	return retval ? retval : count;					\
+}									\
+									\
+static ssize_t show_output##value(struct device *dev, 			\
+					struct device_attribute *attr,	\
+					char *buf)			\
+{									\
+	struct interfacekit *kit = dev_get_drvdata(dev);		\
+									\
+	return sprintf(buf, "%d\n", !!test_bit(value - 1, &kit->outputs));\
+}
+
+#define output_attr(value)						\
+	__ATTR(output##value, S_IWUGO | S_IRUGO,			\
+		show_output##value, set_output##value)
+
+show_set_output(1);
+show_set_output(2);
+show_set_output(3);
+show_set_output(4);
+show_set_output(5);
+show_set_output(6);
+show_set_output(7);
+show_set_output(8);
+show_set_output(9);
+show_set_output(10);
+show_set_output(11);
+show_set_output(12);
+show_set_output(13);
+show_set_output(14);
+show_set_output(15);
+show_set_output(16);
+
+static struct device_attribute dev_output_attrs[] = {
+	output_attr(1), output_attr(2), output_attr(3), output_attr(4),
+	output_attr(5), output_attr(6), output_attr(7), output_attr(8),
+	output_attr(9), output_attr(10), output_attr(11), output_attr(12),
+	output_attr(13), output_attr(14), output_attr(15), output_attr(16)
+};
+
+#define show_input(value)	\
+static ssize_t show_input##value(struct device *dev, 			\
+			struct device_attribute *attr, char *buf)	\
+{									\
+	struct interfacekit *kit = dev_get_drvdata(dev);		\
+									\
+	return sprintf(buf, "%d\n", (int)kit->inputs[value - 1]);	\
+}
+
+#define input_attr(value)						\
+	__ATTR(input##value, S_IRUGO, show_input##value, NULL)
+
+show_input(1);
+show_input(2);
+show_input(3);
+show_input(4);
+show_input(5);
+show_input(6);
+show_input(7);
+show_input(8);
+show_input(9);
+show_input(10);
+show_input(11);
+show_input(12);
+show_input(13);
+show_input(14);
+show_input(15);
+show_input(16);
+
+static struct device_attribute dev_input_attrs[] = {
+	input_attr(1), input_attr(2), input_attr(3), input_attr(4),
+	input_attr(5), input_attr(6), input_attr(7), input_attr(8),
+	input_attr(9), input_attr(10), input_attr(11), input_attr(12),
+	input_attr(13), input_attr(14), input_attr(15), input_attr(16)
+};
+
+#define show_sensor(value)	\
+static ssize_t show_sensor##value(struct device *dev,			\
+					struct device_attribute *attr,	\
+					char *buf)			\
+{									\
+	struct interfacekit *kit = dev_get_drvdata(dev);		\
+									\
+	return sprintf(buf, "%d\n", (int)kit->sensors[value - 1]);	\
+}
+
+#define sensor_attr(value)						\
+	__ATTR(sensor##value, S_IRUGO, show_sensor##value, NULL)
+
+show_sensor(1);
+show_sensor(2);
+show_sensor(3);
+show_sensor(4);
+show_sensor(5);
+show_sensor(6);
+show_sensor(7);
+show_sensor(8);
+
+static struct device_attribute dev_sensor_attrs[] = {
+	sensor_attr(1), sensor_attr(2), sensor_attr(3), sensor_attr(4),
+	sensor_attr(5), sensor_attr(6), sensor_attr(7), sensor_attr(8)
+};
+
+static int interfacekit_probe(struct usb_interface *intf, const struct usb_device_id *id)
+{
+	struct usb_device *dev = interface_to_usbdev(intf);
+	struct usb_host_interface *interface;
+	struct usb_endpoint_descriptor *endpoint;
+	struct interfacekit *kit;
+	struct driver_interfacekit *ifkit;
+	int pipe, maxp, rc = -ENOMEM;
+	int bit, value, i;
+
+	ifkit = (struct driver_interfacekit *)id->driver_info;
+	if (!ifkit)
+		return -ENODEV;
+
+	interface = intf->cur_altsetting;
+	if (interface->desc.bNumEndpoints != 1)
+		return -ENODEV;
+
+	endpoint = &interface->endpoint[0].desc;
+	if (!usb_endpoint_dir_in(endpoint))
+		return -ENODEV;
+	/*
+	 * bmAttributes
+	 */
+	pipe = usb_rcvintpipe(dev, endpoint->bEndpointAddress);
+	maxp = usb_maxpacket(dev, pipe, usb_pipeout(pipe));
+
+	kit = kzalloc(sizeof(*kit), GFP_KERNEL);
+	if (!kit)
+		goto out;
+
+	kit->dev_no = -1;
+	kit->ifkit = ifkit;
+	kit->data = usb_buffer_alloc(dev, URB_INT_SIZE, GFP_ATOMIC, &kit->data_dma);
+	if (!kit->data)
+		goto out;
+
+	kit->irq = usb_alloc_urb(0, GFP_KERNEL);
+	if (!kit->irq)
+		goto out;
+
+	kit->udev = usb_get_dev(dev);
+	kit->intf = intf;
+	INIT_DELAYED_WORK(&kit->do_notify, do_notify);
+	INIT_DELAYED_WORK(&kit->do_resubmit, do_resubmit);
+	usb_fill_int_urb(kit->irq, kit->udev, pipe, kit->data,
+			maxp > URB_INT_SIZE ? URB_INT_SIZE : maxp,
+			interfacekit_irq, kit, endpoint->bInterval);
+	kit->irq->transfer_dma = kit->data_dma;
+	kit->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
+
+	usb_set_intfdata(intf, kit);
+
+        do {
+                bit = find_first_zero_bit(&device_no, sizeof(device_no));
+                value = test_and_set_bit(bit, &device_no);
+        } while(value);
+        kit->dev_no = bit;
+
+	kit->dev = device_create(phidget_class, &kit->udev->dev, MKDEV(0, 0),
+				 kit, "interfacekit%d", kit->dev_no);
+        if (IS_ERR(kit->dev)) {
+                rc = PTR_ERR(kit->dev);
+                kit->dev = NULL;
+                goto out;
+        }
+
+	if (usb_submit_urb(kit->irq, GFP_KERNEL)) {
+		rc = -EIO;
+		goto out;
+	}
+
+	for (i=0; i<ifkit->outputs; i++ ) {
+		rc = device_create_file(kit->dev, &dev_output_attrs[i]);
+		if (rc)
+			goto out2;
+	}
+
+	for (i=0; i<ifkit->inputs; i++ ) {
+		rc = device_create_file(kit->dev, &dev_input_attrs[i]);
+		if (rc)
+			goto out3;
+	}
+
+	for (i=0; i<ifkit->sensors; i++ ) {
+		rc = device_create_file(kit->dev, &dev_sensor_attrs[i]);
+		if (rc)
+			goto out4;
+	}
+
+	if (ifkit->has_lcd) {
+		rc = device_create_file(kit->dev, &dev_attr_lcd);
+		if (rc)
+			goto out4;
+
+	}
+
+	dev_info(&intf->dev, "USB PhidgetInterfaceKit %d/%d/%d attached\n",
+			ifkit->sensors, ifkit->inputs, ifkit->outputs);
+
+	return 0;
+
+out4:
+	while (i-- > 0)
+		device_remove_file(kit->dev, &dev_sensor_attrs[i]);
+
+	i = ifkit->inputs;
+out3:
+	while (i-- > 0)
+		device_remove_file(kit->dev, &dev_input_attrs[i]);
+
+	i = ifkit->outputs;
+out2:
+	while (i-- > 0)
+		device_remove_file(kit->dev, &dev_output_attrs[i]);
+out:
+	if (kit) {
+		usb_free_urb(kit->irq);
+		if (kit->data)
+			usb_buffer_free(dev, URB_INT_SIZE, kit->data, kit->data_dma);
+		if (kit->dev)
+			device_unregister(kit->dev);
+		if (kit->dev_no >= 0)
+			clear_bit(kit->dev_no, &device_no);
+
+		kfree(kit);
+	}
+
+	return rc;
+}
+
+static void interfacekit_disconnect(struct usb_interface *interface)
+{
+	struct interfacekit *kit;
+	int i;
+
+	kit = usb_get_intfdata(interface);
+	usb_set_intfdata(interface, NULL);
+	if (!kit)
+		return;
+
+	usb_kill_urb(kit->irq);
+	usb_free_urb(kit->irq);
+	usb_buffer_free(kit->udev, URB_INT_SIZE, kit->data, kit->data_dma);
+
+	cancel_delayed_work(&kit->do_notify);
+	cancel_delayed_work(&kit->do_resubmit);
+
+	for (i=0; i<kit->ifkit->outputs; i++)
+		device_remove_file(kit->dev, &dev_output_attrs[i]);
+
+	for (i=0; i<kit->ifkit->inputs; i++)
+		device_remove_file(kit->dev, &dev_input_attrs[i]);
+
+	for (i=0; i<kit->ifkit->sensors; i++)
+		device_remove_file(kit->dev, &dev_sensor_attrs[i]);
+
+	if (kit->ifkit->has_lcd) {
+		device_remove_file(kit->dev, &dev_attr_lcd);
+		remove_lcd_files(kit);
+	}
+
+	device_unregister(kit->dev);
+
+	dev_info(&interface->dev, "USB PhidgetInterfaceKit %d/%d/%d detached\n",
+		kit->ifkit->sensors, kit->ifkit->inputs, kit->ifkit->outputs);
+
+	usb_put_dev(kit->udev);
+	clear_bit(kit->dev_no, &device_no);
+
+	kfree(kit);
+}
+
+static struct usb_driver interfacekit_driver = {
+	.name = "phidgetkit",
+	.probe = interfacekit_probe,
+	.disconnect = interfacekit_disconnect,
+	.id_table = id_table
+};
+
+static int __init interfacekit_init(void)
+{
+	int retval = 0;
+
+	retval = usb_register(&interfacekit_driver);
+	if (retval)
+		err("usb_register failed. Error number %d", retval);
+
+	return retval;
+}
+
+static void __exit interfacekit_exit(void)
+{
+	usb_deregister(&interfacekit_driver);
+}
+
+module_init(interfacekit_init);
+module_exit(interfacekit_exit);
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
--- /dev/null
+++ b/drivers/usb/misc/phidgetmotorcontrol.c
@@ -0,0 +1,465 @@
+/*
+ * USB Phidget MotorControl driver
+ *
+ * Copyright (C) 2006  Sean Young <sean@mess.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/usb.h>
+
+#include "phidget.h"
+
+#define DRIVER_AUTHOR "Sean Young <sean@mess.org>"
+#define DRIVER_DESC "USB PhidgetMotorControl Driver"
+
+#define USB_VENDOR_ID_GLAB		0x06c2
+#define USB_DEVICE_ID_MOTORCONTROL	0x0058
+
+#define URB_INT_SIZE			8
+
+static unsigned long device_no;
+
+struct motorcontrol {
+	struct usb_device *udev;
+	struct usb_interface *intf;
+	struct device *dev;
+	int dev_no;
+	u8 inputs[4];
+	s8 desired_speed[2];
+	s8 speed[2];
+	s16 _current[2];
+	s8 acceleration[2];
+	struct urb *irq;
+	unsigned char *data;
+	dma_addr_t data_dma;
+
+	struct delayed_work do_notify;
+	unsigned long input_events;
+	unsigned long speed_events;
+	unsigned long exceed_events;
+};
+
+static struct usb_device_id id_table[] = {
+	{ USB_DEVICE(USB_VENDOR_ID_GLAB, USB_DEVICE_ID_MOTORCONTROL) },
+	{}
+};
+MODULE_DEVICE_TABLE(usb, id_table);
+
+static int set_motor(struct motorcontrol *mc, int motor)
+{
+	u8 *buffer;
+	int speed, speed2, acceleration;
+	int retval;
+
+	buffer = kzalloc(8, GFP_KERNEL);
+	if (!buffer) {
+		dev_err(&mc->intf->dev, "%s - out of memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	acceleration = mc->acceleration[motor] * 10;
+	/* -127 <= speed <= 127 */
+	speed = (mc->desired_speed[motor] * 127) / 100;
+	/* -0x7300 <= speed2 <= 0x7300 */
+	speed2 = (mc->desired_speed[motor] * 230 * 128) / 100;
+
+	buffer[0] = motor;
+	buffer[1] = speed;
+	buffer[2] = acceleration >> 8;
+	buffer[3] = acceleration;
+	buffer[4] = speed2 >> 8;
+	buffer[5] = speed2;
+
+	retval = usb_control_msg(mc->udev,
+			 usb_sndctrlpipe(mc->udev, 0),
+			 0x09, 0x21, 0x0200, 0x0000, buffer, 8, 2000);
+
+	if (retval != 8)
+		dev_err(&mc->intf->dev, "usb_control_msg returned %d\n",
+				retval);
+	kfree(buffer);
+
+	return retval < 0 ? retval : 0;
+}
+
+static void motorcontrol_irq(struct urb *urb)
+{
+	struct motorcontrol *mc = urb->context;
+	unsigned char *buffer = mc->data;
+	int i, level;
+	int retval;
+	int status = urb->status;;
+
+	switch (status) {
+	case 0:			/* success */
+		break;
+	case -ECONNRESET:	/* unlink */
+	case -ENOENT:
+	case -ESHUTDOWN:
+		return;
+	/* -EPIPE:  should clear the halt */
+	default:		/* error */
+		goto resubmit;
+	}
+
+	/* digital inputs */
+	for (i=0; i<4; i++) {
+		level = (buffer[0] >> i) & 1;
+		if (mc->inputs[i] != level) {
+			mc->inputs[i] = level;
+			set_bit(i, &mc->input_events);
+		}
+	}
+
+	/* motor speed */
+	if (buffer[2] == 0) {
+		for (i=0; i<2; i++) {
+		level = ((s8)buffer[4+i]) * 100 / 127;
+			if (mc->speed[i] != level) {
+				mc->speed[i] = level;
+				set_bit(i, &mc->speed_events);
+			}
+		}
+	} else {
+		int index = buffer[3] & 1;
+
+		level = ((s8)buffer[4] << 8) | buffer[5];
+		level = level * 100 / 29440;
+		if (mc->speed[index] != level) {
+			mc->speed[index] = level;
+			set_bit(index, &mc->speed_events);
+		}
+
+		level = ((s8)buffer[6] << 8) | buffer[7];
+		mc->_current[index] = level * 100 / 1572;
+	}
+
+	if (buffer[1] & 1)
+		set_bit(0, &mc->exceed_events);
+
+	if (buffer[1] & 2)
+		set_bit(1, &mc->exceed_events);
+
+	if (mc->input_events || mc->exceed_events || mc->speed_events)
+		schedule_delayed_work(&mc->do_notify, 0);
+
+resubmit:
+	retval = usb_submit_urb(urb, GFP_ATOMIC);
+	if (retval)
+		dev_err(&mc->intf->dev,
+			"can't resubmit intr, %s-%s/motorcontrol0, retval %d\n",
+			mc->udev->bus->bus_name,
+			mc->udev->devpath, retval);
+}
+
+static void do_notify(struct work_struct *work)
+{
+	struct motorcontrol *mc =
+		container_of(work, struct motorcontrol, do_notify.work);
+	int i;
+	char sysfs_file[8];
+
+	for (i=0; i<4; i++) {
+		if (test_and_clear_bit(i, &mc->input_events)) {
+			sprintf(sysfs_file, "input%d", i);
+			sysfs_notify(&mc->dev->kobj, NULL, sysfs_file);
+		}
+	}
+
+	for (i=0; i<2; i++) {
+		if (test_and_clear_bit(i, &mc->speed_events)) {
+			sprintf(sysfs_file, "speed%d", i);
+			sysfs_notify(&mc->dev->kobj, NULL, sysfs_file);
+		}
+	}
+
+	for (i=0; i<2; i++) {
+		if (test_and_clear_bit(i, &mc->exceed_events))
+			dev_warn(&mc->intf->dev,
+				"motor #%d exceeds 1.5 Amp current limit\n", i);
+	}
+}
+
+#define show_set_speed(value)		\
+static ssize_t set_speed##value(struct device *dev,			\
+					struct device_attribute *attr,	\
+					const char *buf, size_t count)	\
+{									\
+	struct motorcontrol *mc = dev_get_drvdata(dev);			\
+	int speed;							\
+	int retval;							\
+									\
+	if (sscanf(buf, "%d", &speed) < 1)				\
+		return -EINVAL;						\
+									\
+	if (speed < -100 || speed > 100)				\
+		return -EINVAL;						\
+									\
+	mc->desired_speed[value] = speed;				\
+									\
+	retval = set_motor(mc, value);					\
+									\
+	return retval ? retval : count;					\
+}									\
+									\
+static ssize_t show_speed##value(struct device *dev,			\
+					struct device_attribute *attr,	\
+					char *buf)			\
+{									\
+	struct motorcontrol *mc = dev_get_drvdata(dev);			\
+									\
+	return sprintf(buf, "%d\n", mc->speed[value]);			\
+}
+
+#define speed_attr(value) 						\
+	__ATTR(speed##value, S_IWUGO | S_IRUGO, 			\
+		show_speed##value, set_speed##value)
+
+show_set_speed(0);
+show_set_speed(1);
+
+#define show_set_acceleration(value)		\
+static ssize_t set_acceleration##value(struct device *dev, 		\
+					struct device_attribute *attr,	\
+					const char *buf, size_t count)	\
+{									\
+	struct motorcontrol *mc = dev_get_drvdata(dev);			\
+	int acceleration;						\
+	int retval;							\
+									\
+	if (sscanf(buf, "%d", &acceleration) < 1)			\
+		return -EINVAL;						\
+									\
+	if (acceleration < 0 || acceleration > 100)			\
+		return -EINVAL;						\
+									\
+	mc->acceleration[value] = acceleration;				\
+									\
+	retval = set_motor(mc, value);					\
+									\
+	return retval ? retval : count;					\
+}									\
+									\
+static ssize_t show_acceleration##value(struct device *dev,	 	\
+					struct device_attribute *attr,	\
+							char *buf)	\
+{									\
+	struct motorcontrol *mc = dev_get_drvdata(dev);			\
+									\
+	return sprintf(buf, "%d\n", mc->acceleration[value]);		\
+}
+
+#define acceleration_attr(value)	\
+	__ATTR(acceleration##value, S_IWUGO | S_IRUGO,			\
+		show_acceleration##value, set_acceleration##value)
+
+show_set_acceleration(0);
+show_set_acceleration(1);
+
+#define show_current(value)	\
+static ssize_t show_current##value(struct device *dev,			\
+					struct device_attribute *attr,	\
+					char *buf)			\
+{									\
+	struct motorcontrol *mc = dev_get_drvdata(dev);			\
+									\
+	return sprintf(buf, "%dmA\n", (int)mc->_current[value]);	\
+}
+
+#define current_attr(value)	\
+	__ATTR(current##value, S_IRUGO, show_current##value, NULL)
+
+show_current(0);
+show_current(1);
+
+#define show_input(value)	\
+static ssize_t show_input##value(struct device *dev,			\
+					struct device_attribute *attr,	\
+					char *buf)			\
+{									\
+	struct motorcontrol *mc = dev_get_drvdata(dev);			\
+									\
+	return sprintf(buf, "%d\n", (int)mc->inputs[value]);		\
+}
+
+#define input_attr(value)	\
+	__ATTR(input##value, S_IRUGO, show_input##value, NULL)
+
+show_input(0);
+show_input(1);
+show_input(2);
+show_input(3);
+
+static struct device_attribute dev_attrs[] = {
+	input_attr(0),
+	input_attr(1),
+	input_attr(2),
+	input_attr(3),
+	speed_attr(0),
+	speed_attr(1),
+	acceleration_attr(0),
+	acceleration_attr(1),
+	current_attr(0),
+	current_attr(1)
+};
+
+static int motorcontrol_probe(struct usb_interface *intf, const struct usb_device_id *id)
+{
+	struct usb_device *dev = interface_to_usbdev(intf);
+	struct usb_host_interface *interface;
+	struct usb_endpoint_descriptor *endpoint;
+	struct motorcontrol *mc;
+	int pipe, maxp, rc = -ENOMEM;
+	int bit, value, i;
+
+	interface = intf->cur_altsetting;
+	if (interface->desc.bNumEndpoints != 1)
+		return -ENODEV;
+
+	endpoint = &interface->endpoint[0].desc;
+	if (!usb_endpoint_dir_in(endpoint))
+		return -ENODEV;
+
+	/*
+	 * bmAttributes
+	 */
+	pipe = usb_rcvintpipe(dev, endpoint->bEndpointAddress);
+	maxp = usb_maxpacket(dev, pipe, usb_pipeout(pipe));
+
+	mc = kzalloc(sizeof(*mc), GFP_KERNEL);
+	if (!mc)
+		goto out;
+
+	mc->dev_no = -1;
+	mc->data = usb_buffer_alloc(dev, URB_INT_SIZE, GFP_ATOMIC, &mc->data_dma);
+	if (!mc->data)
+		goto out;
+
+	mc->irq = usb_alloc_urb(0, GFP_KERNEL);
+	if (!mc->irq)
+		goto out;
+
+	mc->udev = usb_get_dev(dev);
+	mc->intf = intf;
+	mc->acceleration[0] = mc->acceleration[1] = 10;
+	INIT_DELAYED_WORK(&mc->do_notify, do_notify);
+	usb_fill_int_urb(mc->irq, mc->udev, pipe, mc->data,
+			maxp > URB_INT_SIZE ? URB_INT_SIZE : maxp,
+			motorcontrol_irq, mc, endpoint->bInterval);
+	mc->irq->transfer_dma = mc->data_dma;
+	mc->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
+
+	usb_set_intfdata(intf, mc);
+
+	do {
+		bit = find_first_zero_bit(&device_no, sizeof(device_no));
+		value = test_and_set_bit(bit, &device_no);
+	} while(value);
+	mc->dev_no = bit;
+
+	mc->dev = device_create(phidget_class, &mc->udev->dev, MKDEV(0, 0), mc,
+				"motorcontrol%d", mc->dev_no);
+	if (IS_ERR(mc->dev)) {
+		rc = PTR_ERR(mc->dev);
+		mc->dev = NULL;
+		goto out;
+	}
+
+	if (usb_submit_urb(mc->irq, GFP_KERNEL)) {
+		rc = -EIO;
+		goto out;
+	}
+
+	for (i=0; i<ARRAY_SIZE(dev_attrs); i++) {
+		rc = device_create_file(mc->dev, &dev_attrs[i]);
+		if (rc)
+			goto out2;
+	}
+
+	dev_info(&intf->dev, "USB PhidgetMotorControl attached\n");
+
+	return 0;
+out2:
+	while (i-- > 0)
+		device_remove_file(mc->dev, &dev_attrs[i]);
+out:
+	if (mc) {
+		usb_free_urb(mc->irq);
+		if (mc->data)
+			usb_buffer_free(dev, URB_INT_SIZE, mc->data, mc->data_dma);
+		if (mc->dev)
+			device_unregister(mc->dev);
+		if (mc->dev_no >= 0)
+			clear_bit(mc->dev_no, &device_no);
+
+		kfree(mc);
+	}
+
+	return rc;
+}
+
+static void motorcontrol_disconnect(struct usb_interface *interface)
+{
+	struct motorcontrol *mc;
+	int i;
+
+	mc = usb_get_intfdata(interface);
+	usb_set_intfdata(interface, NULL);
+	if (!mc)
+		return;
+
+	usb_kill_urb(mc->irq);
+	usb_free_urb(mc->irq);
+	usb_buffer_free(mc->udev, URB_INT_SIZE, mc->data, mc->data_dma);
+
+	cancel_delayed_work(&mc->do_notify);
+
+	for (i=0; i<ARRAY_SIZE(dev_attrs); i++)
+		device_remove_file(mc->dev, &dev_attrs[i]);
+
+	device_unregister(mc->dev);
+
+	usb_put_dev(mc->udev);
+	clear_bit(mc->dev_no, &device_no);
+	kfree(mc);
+
+	dev_info(&interface->dev, "USB PhidgetMotorControl detached\n");
+}
+
+static struct usb_driver motorcontrol_driver = {
+	.name = "phidgetmotorcontrol",
+	.probe = motorcontrol_probe,
+	.disconnect = motorcontrol_disconnect,
+	.id_table = id_table
+};
+
+static int __init motorcontrol_init(void)
+{
+	int retval = 0;
+
+	retval = usb_register(&motorcontrol_driver);
+	if (retval)
+		err("usb_register failed. Error number %d", retval);
+
+	return retval;
+}
+
+static void __exit motorcontrol_exit(void)
+{
+	usb_deregister(&motorcontrol_driver);
+}
+
+module_init(motorcontrol_init);
+module_exit(motorcontrol_exit);
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
--- /dev/null
+++ b/drivers/usb/misc/phidgetservo.c
@@ -0,0 +1,375 @@
+/*
+ * USB PhidgetServo driver 1.0
+ *
+ * Copyright (C) 2004, 2006 Sean Young <sean@mess.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This is a driver for the USB PhidgetServo version 2.0 and 3.0 servo
+ * controllers available at: http://www.phidgets.com/
+ *
+ * Note that the driver takes input as: degrees.minutes
+ *
+ * CAUTION: Generally you should use 0 < degrees < 180 as anything else
+ * is probably beyond the range of your servo and may damage it.
+ */
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/usb.h>
+
+#include "phidget.h"
+
+#define DRIVER_AUTHOR "Sean Young <sean@mess.org>"
+#define DRIVER_DESC "USB PhidgetServo Driver"
+
+#define VENDOR_ID_GLAB				0x06c2
+#define DEVICE_ID_GLAB_PHIDGETSERVO_QUAD	0x0038
+#define DEVICE_ID_GLAB_PHIDGETSERVO_UNI		0x0039
+
+#define VENDOR_ID_WISEGROUP			0x0925
+#define VENDOR_ID_WISEGROUP_PHIDGETSERVO_QUAD	0x8101
+#define VENDOR_ID_WISEGROUP_PHIDGETSERVO_UNI	0x8104
+
+#define SERVO_VERSION_30			0x01
+#define SERVO_COUNT_QUAD			0x02
+
+static struct usb_device_id id_table[] = {
+	{
+		USB_DEVICE(VENDOR_ID_GLAB, DEVICE_ID_GLAB_PHIDGETSERVO_QUAD),
+		.driver_info = SERVO_VERSION_30 | SERVO_COUNT_QUAD
+	},
+	{
+		USB_DEVICE(VENDOR_ID_GLAB, DEVICE_ID_GLAB_PHIDGETSERVO_UNI),
+		.driver_info = SERVO_VERSION_30
+	},
+	{
+		USB_DEVICE(VENDOR_ID_WISEGROUP,
+				VENDOR_ID_WISEGROUP_PHIDGETSERVO_QUAD),
+		.driver_info = SERVO_COUNT_QUAD
+	},
+	{
+		USB_DEVICE(VENDOR_ID_WISEGROUP,
+				VENDOR_ID_WISEGROUP_PHIDGETSERVO_UNI),
+		.driver_info = 0
+	},
+	{}
+};
+
+MODULE_DEVICE_TABLE(usb, id_table);
+
+static int unsigned long device_no;
+
+struct phidget_servo {
+	struct usb_device *udev;
+	struct device *dev;
+	int dev_no;
+	ulong type;
+	int pulse[4];
+	int degrees[4];
+	int minutes[4];
+};
+
+static int
+change_position_v30(struct phidget_servo *servo, int servo_no, int degrees,
+								int minutes)
+{
+	int retval;
+	unsigned char *buffer;
+
+	if (degrees < -23 || degrees > 362)
+		return -EINVAL;
+
+	buffer = kmalloc(6, GFP_KERNEL);
+	if (!buffer) {
+		dev_err(&servo->udev->dev, "%s - out of memory\n",
+			__func__);
+		return -ENOMEM;
+	}
+
+	/*
+	 * pulse = 0 - 4095
+	 * angle = 0 - 180 degrees
+	 *
+	 * pulse = angle * 10.6 + 243.8
+	 */
+	servo->pulse[servo_no] = ((degrees*60 + minutes)*106 + 2438*60)/600;
+	servo->degrees[servo_no]= degrees;
+	servo->minutes[servo_no]= minutes;
+
+	/*
+	 * The PhidgetServo v3.0 is controlled by sending 6 bytes,
+	 * 4 * 12 bits for each servo.
+	 *
+	 * low = lower 8 bits pulse
+	 * high = higher 4 bits pulse
+	 *
+	 * offset     bits
+	 * +---+-----------------+
+	 * | 0 |      low 0      |
+	 * +---+--------+--------+
+	 * | 1 | high 1 | high 0 |
+	 * +---+--------+--------+
+	 * | 2 |      low 1      |
+	 * +---+-----------------+
+	 * | 3 |      low 2      |
+	 * +---+--------+--------+
+	 * | 4 | high 3 | high 2 |
+	 * +---+--------+--------+
+	 * | 5 |      low 3      |
+	 * +---+-----------------+
+	 */
+
+	buffer[0] = servo->pulse[0] & 0xff;
+	buffer[1] = (servo->pulse[0] >> 8 & 0x0f)
+	    | (servo->pulse[1] >> 4 & 0xf0);
+	buffer[2] = servo->pulse[1] & 0xff;
+	buffer[3] = servo->pulse[2] & 0xff;
+	buffer[4] = (servo->pulse[2] >> 8 & 0x0f)
+	    | (servo->pulse[3] >> 4 & 0xf0);
+	buffer[5] = servo->pulse[3] & 0xff;
+
+	dev_dbg(&servo->udev->dev,
+		"data: %02x %02x %02x %02x %02x %02x\n",
+		buffer[0], buffer[1], buffer[2],
+		buffer[3], buffer[4], buffer[5]);
+
+	retval = usb_control_msg(servo->udev,
+				 usb_sndctrlpipe(servo->udev, 0),
+				 0x09, 0x21, 0x0200, 0x0000, buffer, 6, 2000);
+
+	kfree(buffer);
+
+	return retval;
+}
+
+static int
+change_position_v20(struct phidget_servo *servo, int servo_no, int degrees,
+								int minutes)
+{
+	int retval;
+	unsigned char *buffer;
+
+	if (degrees < -23 || degrees > 278)
+		return -EINVAL;
+
+	buffer = kmalloc(2, GFP_KERNEL);
+	if (!buffer) {
+		dev_err(&servo->udev->dev, "%s - out of memory\n",
+			__func__);
+		return -ENOMEM;
+	}
+
+	/*
+	 * angle = 0 - 180 degrees
+	 * pulse = angle + 23
+	 */
+	servo->pulse[servo_no]= degrees + 23;
+	servo->degrees[servo_no]= degrees;
+	servo->minutes[servo_no]= 0;
+
+	/*
+	 * The PhidgetServo v2.0 is controlled by sending two bytes. The
+	 * first byte is the servo number xor'ed with 2:
+	 *
+	 * servo 0 = 2
+	 * servo 1 = 3
+	 * servo 2 = 0
+	 * servo 3 = 1
+	 *
+	 * The second byte is the position.
+	 */
+
+	buffer[0] = servo_no ^ 2;
+	buffer[1] = servo->pulse[servo_no];
+
+	dev_dbg(&servo->udev->dev, "data: %02x %02x\n", buffer[0], buffer[1]);
+
+	retval = usb_control_msg(servo->udev,
+				 usb_sndctrlpipe(servo->udev, 0),
+				 0x09, 0x21, 0x0200, 0x0000, buffer, 2, 2000);
+
+	kfree(buffer);
+
+	return retval;
+}
+
+#define show_set(value)	\
+static ssize_t set_servo##value (struct device *dev, 			\
+					struct device_attribute *attr,	\
+					const char *buf, size_t count)	\
+{									\
+	int degrees, minutes, retval;					\
+	struct phidget_servo *servo = dev_get_drvdata(dev);		\
+									\
+	minutes = 0;							\
+	/* must at least convert degrees */				\
+	if (sscanf(buf, "%d.%d", &degrees, &minutes) < 1) {		\
+		return -EINVAL;						\
+	}								\
+									\
+	if (minutes < 0 || minutes > 59) 				\
+		return -EINVAL;						\
+									\
+	if (servo->type & SERVO_VERSION_30)				\
+		retval = change_position_v30(servo, value, degrees, 	\
+							minutes);	\
+	else 								\
+		retval = change_position_v20(servo, value, degrees, 	\
+							minutes);	\
+									\
+	return retval < 0 ? retval : count;				\
+}									\
+									\
+static ssize_t show_servo##value (struct device *dev,			\
+					struct device_attribute *attr,	\
+					char *buf) 			\
+{									\
+	struct phidget_servo *servo = dev_get_drvdata(dev);		\
+									\
+	return sprintf(buf, "%d.%02d\n", servo->degrees[value],		\
+				servo->minutes[value]);			\
+}
+
+#define servo_attr(value)						\
+	__ATTR(servo##value, S_IWUGO | S_IRUGO,				\
+		show_servo##value, set_servo##value)
+show_set(0);
+show_set(1);
+show_set(2);
+show_set(3);
+
+static struct device_attribute dev_attrs[] = {
+	servo_attr(0), servo_attr(1), servo_attr(2), servo_attr(3)
+};
+
+static int
+servo_probe(struct usb_interface *interface, const struct usb_device_id *id)
+{
+	struct usb_device *udev = interface_to_usbdev(interface);
+	struct phidget_servo *dev;
+	int bit, value, rc;
+	int servo_count, i;
+
+	dev = kzalloc(sizeof (struct phidget_servo), GFP_KERNEL);
+	if (dev == NULL) {
+		dev_err(&interface->dev, "%s - out of memory\n", __func__);
+		rc = -ENOMEM;
+		goto out;
+	}
+
+	dev->udev = usb_get_dev(udev);
+	dev->type = id->driver_info;
+	dev->dev_no = -1;
+	usb_set_intfdata(interface, dev);
+
+        do {
+                bit = find_first_zero_bit(&device_no, sizeof(device_no));
+                value = test_and_set_bit(bit, &device_no);
+        } while (value);
+	dev->dev_no = bit;
+
+	dev->dev = device_create(phidget_class, &dev->udev->dev, MKDEV(0, 0),
+				 dev, "servo%d", dev->dev_no);
+	if (IS_ERR(dev->dev)) {
+		rc = PTR_ERR(dev->dev);
+		dev->dev = NULL;
+		goto out;
+	}
+
+	servo_count = dev->type & SERVO_COUNT_QUAD ? 4 : 1;
+
+	for (i=0; i<servo_count; i++) {
+		rc = device_create_file(dev->dev, &dev_attrs[i]);
+		if (rc)
+			goto out2;
+	}
+
+	dev_info(&interface->dev, "USB %d-Motor PhidgetServo v%d.0 attached\n",
+		servo_count, dev->type & SERVO_VERSION_30 ? 3 : 2);
+
+	if (!(dev->type & SERVO_VERSION_30))
+		dev_info(&interface->dev,
+			 "WARNING: v2.0 not tested! Please report if it works.\n");
+
+	return 0;
+out2:
+	while (i-- > 0)
+		device_remove_file(dev->dev, &dev_attrs[i]);
+out:
+	if (dev) {
+		if (dev->dev)
+			device_unregister(dev->dev);
+		if (dev->dev_no >= 0)
+			clear_bit(dev->dev_no, &device_no);
+
+		kfree(dev);
+	}
+
+	return rc;
+}
+
+static void
+servo_disconnect(struct usb_interface *interface)
+{
+	struct phidget_servo *dev;
+	int servo_count, i;
+
+	dev = usb_get_intfdata(interface);
+	usb_set_intfdata(interface, NULL);
+
+	if (!dev)
+		return;
+
+	servo_count = dev->type & SERVO_COUNT_QUAD ? 4 : 1;
+
+	for (i=0; i<servo_count; i++)
+		device_remove_file(dev->dev, &dev_attrs[i]);
+
+	device_unregister(dev->dev);
+	usb_put_dev(dev->udev);
+
+	dev_info(&interface->dev, "USB %d-Motor PhidgetServo v%d.0 detached\n",
+		servo_count, dev->type & SERVO_VERSION_30 ? 3 : 2);
+
+	clear_bit(dev->dev_no, &device_no);
+	kfree(dev);
+}
+
+static struct usb_driver servo_driver = {
+	.name = "phidgetservo",
+	.probe = servo_probe,
+	.disconnect = servo_disconnect,
+	.id_table = id_table
+};
+
+static int __init
+phidget_servo_init(void)
+{
+	int retval;
+
+	retval = usb_register(&servo_driver);
+	if (retval)
+		err("usb_register failed. Error number %d", retval);
+
+	return retval;
+}
+
+static void __exit
+phidget_servo_exit(void)
+{
+	usb_deregister(&servo_driver);
+}
+
+module_init(phidget_servo_init);
+module_exit(phidget_servo_exit);
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");

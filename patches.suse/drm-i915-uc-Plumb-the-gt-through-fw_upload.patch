From 4ca8d2ef8dab4ad61347e52174b870c44f1508a3 Mon Sep 17 00:00:00 2001
From: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date: Wed, 24 Jul 2019 17:18:12 -0700
Subject: [PATCH] drm/i915/uc: Plumb the gt through fw_upload
Git-commit: 4ca8d2ef8dab4ad61347e52174b870c44f1508a3
Patch-mainline: v5.4-rc1
References: jsc#SLE-7953

The gt is our new central structure for uc-related code, so we can use
that instead of jumping back to i915 via the fw object. Since we have it
in the upload function it is easy to pass it through the lower levels of
the xfer process instead of continuosly jumping via uc_fw->uc->gt, which
will also make things a bit cleaner for the next patch.

Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
Cc: Chris Wilson <chris@chris-wilson.co.uk>
Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
Link: https://patchwork.freedesktop.org/patch/msgid/20190725001813.4740-8-daniele.ceraolospurio@intel.com
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/gpu/drm/i915/gt/uc/intel_guc_fw.c | 35 ++++++++++++++-----------------
 drivers/gpu/drm/i915/gt/uc/intel_huc_fw.c | 32 +++++++++++-----------------
 drivers/gpu/drm/i915/gt/uc/intel_uc_fw.c  | 29 ++++++++++++-------------
 drivers/gpu/drm/i915/gt/uc/intel_uc_fw.h  |  8 ++++---
 4 files changed, 48 insertions(+), 56 deletions(-)

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_guc_fw.c b/drivers/gpu/drm/i915/gt/uc/intel_guc_fw.c
index 385f6d38bf49..3ea0de6f4b73 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_guc_fw.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_guc_fw.c
@@ -42,10 +42,8 @@ void intel_guc_fw_init_early(struct intel_guc *guc)
 	intel_uc_fw_init_early(&guc->fw, INTEL_UC_FW_TYPE_GUC, guc_to_gt(guc)->i915);
 }
 
-static void guc_prepare_xfer(struct intel_guc *guc)
+static void guc_prepare_xfer(struct intel_uncore *uncore)
 {
-	struct intel_gt *gt = guc_to_gt(guc);
-	struct intel_uncore *uncore = gt->uncore;
 	u32 shim_flags = GUC_DISABLE_SRAM_INIT_TO_ZEROES |
 			 GUC_ENABLE_READ_CACHE_LOGIC |
 			 GUC_ENABLE_MIA_CACHING |
@@ -56,12 +54,12 @@ static void guc_prepare_xfer(struct intel_guc *guc)
 	/* Must program this register before loading the ucode with DMA */
 	intel_uncore_write(uncore, GUC_SHIM_CONTROL, shim_flags);
 
-	if (IS_GEN9_LP(gt->i915))
+	if (IS_GEN9_LP(uncore->i915))
 		intel_uncore_write(uncore, GEN9LP_GT_PM_CONFIG, GT_DOORBELL_ENABLE);
 	else
 		intel_uncore_write(uncore, GEN9_GT_PM_CONFIG, GT_DOORBELL_ENABLE);
 
-	if (IS_GEN(gt->i915, 9)) {
+	if (IS_GEN(uncore->i915, 9)) {
 		/* DOP Clock Gating Enable for GuC clocks */
 		intel_uncore_rmw(uncore, GEN7_MISCCPCTL,
 				 0, GEN8_DOP_CLOCK_GATE_GUC_ENABLE);
@@ -72,14 +70,14 @@ static void guc_prepare_xfer(struct intel_guc *guc)
 }
 
 /* Copy RSA signature from the fw image to HW for verification */
-static void guc_xfer_rsa(struct intel_guc *guc)
+static void guc_xfer_rsa(struct intel_uc_fw *guc_fw,
+			 struct intel_uncore *uncore)
 {
-	struct intel_uncore *uncore = guc_to_gt(guc)->uncore;
 	u32 rsa[UOS_RSA_SCRATCH_COUNT];
 	size_t copied;
 	int i;
 
-	copied = intel_uc_fw_copy_rsa(&guc->fw, rsa, sizeof(rsa));
+	copied = intel_uc_fw_copy_rsa(guc_fw, rsa, sizeof(rsa));
 	GEM_BUG_ON(copied < sizeof(rsa));
 
 	for (i = 0; i < UOS_RSA_SCRATCH_COUNT; i++)
@@ -155,10 +153,10 @@ static int guc_wait_ucode(struct intel_uncore *uncore)
  * transfer between GTT locations. This functionality is left out of the API
  * for now as there is no need for it.
  */
-static int guc_xfer_ucode(struct intel_guc *guc)
+static int guc_xfer_ucode(struct intel_uc_fw *guc_fw,
+			  struct intel_gt *gt)
 {
-	struct intel_uncore *uncore = guc_to_gt(guc)->uncore;
-	struct intel_uc_fw *guc_fw = &guc->fw;
+	struct intel_uncore *uncore = gt->uncore;
 	unsigned long offset;
 
 	/*
@@ -169,7 +167,7 @@ static int guc_xfer_ucode(struct intel_guc *guc)
 			   guc_fw->header_size + guc_fw->ucode_size);
 
 	/* Set the source address for the new blob */
-	offset = intel_uc_fw_ggtt_offset(guc_fw) + guc_fw->header_offset;
+	offset = intel_uc_fw_ggtt_offset(guc_fw, gt->ggtt) + guc_fw->header_offset;
 	intel_uncore_write(uncore, DMA_ADDR_0_LOW, lower_32_bits(offset));
 	intel_uncore_write(uncore, DMA_ADDR_0_HIGH, upper_32_bits(offset) & 0xFFFF);
 
@@ -189,26 +187,25 @@ static int guc_xfer_ucode(struct intel_guc *guc)
 /*
  * Load the GuC firmware blob into the MinuteIA.
  */
-static int guc_fw_xfer(struct intel_uc_fw *guc_fw)
+static int guc_fw_xfer(struct intel_uc_fw *guc_fw, struct intel_gt *gt)
 {
-	struct intel_guc *guc = container_of(guc_fw, struct intel_guc, fw);
-	struct intel_uncore *uncore = guc_to_gt(guc)->uncore;
+	struct intel_uncore *uncore = gt->uncore;
 	int ret;
 
 	GEM_BUG_ON(guc_fw->type != INTEL_UC_FW_TYPE_GUC);
 
 	intel_uncore_forcewake_get(uncore, FORCEWAKE_ALL);
 
-	guc_prepare_xfer(guc);
+	guc_prepare_xfer(uncore);
 
 	/*
 	 * Note that GuC needs the CSS header plus uKernel code to be copied
 	 * by the DMA engine in one operation, whereas the RSA signature is
 	 * loaded via MMIO.
 	 */
-	guc_xfer_rsa(guc);
+	guc_xfer_rsa(guc_fw, uncore);
 
-	ret = guc_xfer_ucode(guc);
+	ret = guc_xfer_ucode(guc_fw, gt);
 
 	intel_uncore_forcewake_put(uncore, FORCEWAKE_ALL);
 
@@ -229,7 +226,7 @@ static int guc_fw_xfer(struct intel_uc_fw *guc_fw)
  */
 int intel_guc_fw_upload(struct intel_guc *guc)
 {
-	int ret = intel_uc_fw_upload(&guc->fw, guc_fw_xfer);
+	int ret = intel_uc_fw_upload(&guc->fw, guc_to_gt(guc), guc_fw_xfer);
 	if (!ret)
 		guc->fw.status = INTEL_UC_FIRMWARE_RUNNING;
 
diff --git a/drivers/gpu/drm/i915/gt/uc/intel_huc_fw.c b/drivers/gpu/drm/i915/gt/uc/intel_huc_fw.c
index 7d2d2eb94d22..2e7ac8863728 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_huc_fw.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_huc_fw.c
@@ -34,10 +34,17 @@ void intel_huc_fw_init_early(struct intel_huc *huc)
 	intel_uc_fw_init_early(&huc->fw, INTEL_UC_FW_TYPE_HUC, huc_to_gt(huc)->i915);
 }
 
-static int huc_xfer_ucode(struct intel_huc *huc)
+/**
+ * huc_fw_xfer() - DMA's the firmware
+ * @huc_fw: the firmware descriptor
+ *
+ * Transfer the firmware image to RAM for execution by the microcontroller.
+ *
+ * Return: 0 on success, non-zero on failure
+ */
+static int huc_fw_xfer(struct intel_uc_fw *huc_fw, struct intel_gt *gt)
 {
-	struct intel_uc_fw *huc_fw = &huc->fw;
-	struct intel_uncore *uncore = huc_to_gt(huc)->uncore;
+	struct intel_uncore *uncore = gt->uncore;
 	unsigned long offset = 0;
 	u32 size;
 	int ret;
@@ -47,7 +54,7 @@ static int huc_xfer_ucode(struct intel_huc *huc)
 	intel_uncore_forcewake_get(uncore, FORCEWAKE_ALL);
 
 	/* Set the source address for the uCode */
-	offset = intel_uc_fw_ggtt_offset(huc_fw) +
+	offset = intel_uc_fw_ggtt_offset(huc_fw, gt->ggtt) +
 		 huc_fw->header_offset;
 	intel_uncore_write(uncore, DMA_ADDR_0_LOW,
 			   lower_32_bits(offset));
@@ -81,21 +88,6 @@ static int huc_xfer_ucode(struct intel_huc *huc)
 	return ret;
 }
 
-/**
- * huc_fw_xfer() - DMA's the firmware
- * @huc_fw: the firmware descriptor
- *
- * Transfer the firmware image to RAM for execution by the microcontroller.
- *
- * Return: 0 on success, non-zero on failure
- */
-static int huc_fw_xfer(struct intel_uc_fw *huc_fw)
-{
-	struct intel_huc *huc = container_of(huc_fw, struct intel_huc, fw);
-
-	return huc_xfer_ucode(huc);
-}
-
 /**
  * intel_huc_fw_upload() - load HuC uCode to device
  * @huc: intel_huc structure
@@ -110,5 +102,5 @@ static int huc_fw_xfer(struct intel_uc_fw *huc_fw)
  */
 int intel_huc_fw_upload(struct intel_huc *huc)
 {
-	return intel_uc_fw_upload(&huc->fw, huc_fw_xfer);
+	return intel_uc_fw_upload(&huc->fw, huc_to_gt(huc), huc_fw_xfer);
 }
diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc_fw.c b/drivers/gpu/drm/i915/gt/uc/intel_uc_fw.c
index f60129c17e40..8d099dac0224 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc_fw.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc_fw.c
@@ -321,12 +321,13 @@ void intel_uc_fw_fetch(struct drm_i915_private *dev_priv,
 	release_firmware(fw);		/* OK even if fw is NULL */
 }
 
-static void intel_uc_fw_ggtt_bind(struct intel_uc_fw *uc_fw)
+static void intel_uc_fw_ggtt_bind(struct intel_uc_fw *uc_fw,
+				  struct intel_gt *gt)
 {
 	struct drm_i915_gem_object *obj = uc_fw->obj;
-	struct i915_ggtt *ggtt = &to_i915(obj->base.dev)->ggtt;
+	struct i915_ggtt *ggtt = gt->ggtt;
 	struct i915_vma dummy = {
-		.node.start = intel_uc_fw_ggtt_offset(uc_fw),
+		.node.start = intel_uc_fw_ggtt_offset(uc_fw, ggtt),
 		.node.size = obj->base.size,
 		.pages = obj->mm.pages,
 		.vm = &ggtt->vm,
@@ -341,11 +342,12 @@ static void intel_uc_fw_ggtt_bind(struct intel_uc_fw *uc_fw)
 	ggtt->vm.insert_entries(&ggtt->vm, &dummy, I915_CACHE_NONE, 0);
 }
 
-static void intel_uc_fw_ggtt_unbind(struct intel_uc_fw *uc_fw)
+static void intel_uc_fw_ggtt_unbind(struct intel_uc_fw *uc_fw,
+				    struct intel_gt *gt)
 {
 	struct drm_i915_gem_object *obj = uc_fw->obj;
-	struct i915_ggtt *ggtt = &to_i915(obj->base.dev)->ggtt;
-	u64 start = intel_uc_fw_ggtt_offset(uc_fw);
+	struct i915_ggtt *ggtt = gt->ggtt;
+	u64 start = intel_uc_fw_ggtt_offset(uc_fw, ggtt);
 
 	ggtt->vm.clear_range(&ggtt->vm, start, obj->base.size);
 }
@@ -353,14 +355,15 @@ static void intel_uc_fw_ggtt_unbind(struct intel_uc_fw *uc_fw)
 /**
  * intel_uc_fw_upload - load uC firmware using custom loader
  * @uc_fw: uC firmware
+ * @gt: the intel_gt structure
  * @xfer: custom uC firmware loader function
  *
  * Loads uC firmware using custom loader and updates internal flags.
  *
  * Return: 0 on success, non-zero on failure.
  */
-int intel_uc_fw_upload(struct intel_uc_fw *uc_fw,
-		       int (*xfer)(struct intel_uc_fw *uc_fw))
+int intel_uc_fw_upload(struct intel_uc_fw *uc_fw, struct intel_gt *gt,
+		       int (*xfer)(struct intel_uc_fw *uc_fw, struct intel_gt *gt))
 {
 	int err;
 
@@ -373,9 +376,9 @@ int intel_uc_fw_upload(struct intel_uc_fw *uc_fw,
 	if (!intel_uc_fw_is_available(uc_fw))
 		return -ENOEXEC;
 	/* Call custom loader */
-	intel_uc_fw_ggtt_bind(uc_fw);
-	err = xfer(uc_fw);
-	intel_uc_fw_ggtt_unbind(uc_fw);
+	intel_uc_fw_ggtt_bind(uc_fw, gt);
+	err = xfer(uc_fw, gt);
+	intel_uc_fw_ggtt_unbind(uc_fw, gt);
 	if (err)
 		goto fail;
 
@@ -427,10 +430,8 @@ void intel_uc_fw_fini(struct intel_uc_fw *uc_fw)
 	i915_gem_object_unpin_pages(uc_fw->obj);
 }
 
-u32 intel_uc_fw_ggtt_offset(struct intel_uc_fw *uc_fw)
+u32 intel_uc_fw_ggtt_offset(struct intel_uc_fw *uc_fw, struct i915_ggtt *ggtt)
 {
-	struct drm_i915_private *i915 = to_i915(uc_fw->obj->base.dev);
-	struct i915_ggtt *ggtt = &i915->ggtt;
 	struct drm_mm_node *node = &ggtt->uc_fw;
 
 	GEM_BUG_ON(!node->allocated);
diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc_fw.h b/drivers/gpu/drm/i915/gt/uc/intel_uc_fw.h
index c843d00b1b75..a69b6f00fe16 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc_fw.h
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc_fw.h
@@ -30,6 +30,8 @@
 
 struct drm_printer;
 struct drm_i915_private;
+struct intel_gt;
+struct i915_ggtt;
 
 /* Home of GuC, HuC and DMC firmwares */
 #define INTEL_UC_FIRMWARE_URL "https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git/tree/i915"
@@ -171,11 +173,11 @@ void intel_uc_fw_init_early(struct intel_uc_fw *uc_fw,
 void intel_uc_fw_fetch(struct drm_i915_private *i915,
 		       struct intel_uc_fw *uc_fw);
 void intel_uc_fw_cleanup_fetch(struct intel_uc_fw *uc_fw);
-int intel_uc_fw_upload(struct intel_uc_fw *uc_fw,
-		       int (*xfer)(struct intel_uc_fw *uc_fw));
+int intel_uc_fw_upload(struct intel_uc_fw *uc_fw, struct intel_gt *gt,
+		       int (*xfer)(struct intel_uc_fw *uc_fw, struct intel_gt *gt));
 int intel_uc_fw_init(struct intel_uc_fw *uc_fw);
 void intel_uc_fw_fini(struct intel_uc_fw *uc_fw);
-u32 intel_uc_fw_ggtt_offset(struct intel_uc_fw *uc_fw);
+u32 intel_uc_fw_ggtt_offset(struct intel_uc_fw *uc_fw, struct i915_ggtt *ggtt);
 size_t intel_uc_fw_copy_rsa(struct intel_uc_fw *uc_fw, void *dst, u32 max_len);
 void intel_uc_fw_dump(const struct intel_uc_fw *uc_fw, struct drm_printer *p);
 
-- 
2.16.4


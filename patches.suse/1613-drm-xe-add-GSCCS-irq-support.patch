From 60e316105d9787523650a00e1726c0e791907ce6 Mon Sep 17 00:00:00 2001
From: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date: Thu, 17 Aug 2023 13:18:27 -0700
Subject: drm/xe: add GSCCS irq support
Git-commit: 3d2b5d4e28d9c58ea97704fe1eb663aee2556449
Patch-mainline: v6.8-rc1
References: drm-backport-placeholder

The GSCCS has its own enable and mask registers. The interrupt identity
for the GSCCS shows OTHER_CLASS instance 6.

Bspec: 54029, 54030
Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
Link: https://lore.kernel.org/r/20230817201831.1583172-4-daniele.ceraolospurio@intel.com
Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
Acked-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 drivers/gpu/drm/xe/regs/xe_gt_regs.h |  2 ++
 drivers/gpu/drm/xe/xe_irq.c          | 25 ++++++++++++++++++-------
 2 files changed, 20 insertions(+), 7 deletions(-)

diff --git a/drivers/gpu/drm/xe/regs/xe_gt_regs.h b/drivers/gpu/drm/xe/regs/xe_gt_regs.h
index 5f635682ce5a..b6e870302cc7 100644
--- a/drivers/gpu/drm/xe/regs/xe_gt_regs.h
+++ b/drivers/gpu/drm/xe/regs/xe_gt_regs.h
@@ -380,6 +380,7 @@
 
 #define RENDER_COPY_INTR_ENABLE			XE_REG(0x190030)
 #define VCS_VECS_INTR_ENABLE			XE_REG(0x190034)
+#define GUNIT_GSC_INTR_ENABLE			XE_REG(0x190044)
 #define CCS_RSVD_INTR_ENABLE			XE_REG(0x190048)
 #define IIR_REG_SELECTOR(x)			XE_REG(0x190070 + ((x) * 4))
 #define RCS0_RSVD_INTR_MASK			XE_REG(0x190090)
@@ -389,6 +390,7 @@
 #define VECS0_VECS1_INTR_MASK			XE_REG(0x1900d0)
 #define GUC_SG_INTR_MASK			XE_REG(0x1900e8)
 #define GPM_WGBOXPERF_INTR_MASK			XE_REG(0x1900ec)
+#define GUNIT_GSC_INTR_MASK			XE_REG(0x1900f4)
 #define CCS0_CCS1_INTR_MASK			XE_REG(0x190100)
 #define CCS2_CCS3_INTR_MASK			XE_REG(0x190104)
 #define XEHPC_BCS1_BCS2_INTR_MASK		XE_REG(0x190110)
diff --git a/drivers/gpu/drm/xe/xe_irq.c b/drivers/gpu/drm/xe/xe_irq.c
index 69629be07de2..ef434142bcd9 100644
--- a/drivers/gpu/drm/xe/xe_irq.c
+++ b/drivers/gpu/drm/xe/xe_irq.c
@@ -175,6 +175,11 @@ void xe_irq_enable_hwe(struct xe_gt *gt)
 		xe_mmio_write32(gt, VCS0_VCS1_INTR_MASK, ~dmask);
 		xe_mmio_write32(gt, VCS2_VCS3_INTR_MASK, ~dmask);
 		xe_mmio_write32(gt, VECS0_VECS1_INTR_MASK, ~dmask);
+
+		if (xe_hw_engine_mask_per_class(gt, XE_ENGINE_CLASS_OTHER)) {
+			xe_mmio_write32(gt, GUNIT_GSC_INTR_ENABLE, irqs);
+			xe_mmio_write32(gt, GUNIT_GSC_INTR_MASK, ~irqs);
+		}
 	}
 }
 
@@ -243,7 +248,7 @@ static struct xe_gt *pick_engine_gt(struct xe_tile *tile,
 		return tile->media_gt;
 
 	if (class == XE_ENGINE_CLASS_OTHER &&
-	    instance == OTHER_MEDIA_GUC_INSTANCE)
+	    (instance == OTHER_MEDIA_GUC_INSTANCE || instance == OTHER_GSC_INSTANCE))
 		return tile->media_gt;
 
 	return tile->primary_gt;
@@ -280,16 +285,16 @@ static void gt_irq_handler(struct xe_tile *tile,
 
 			engine_gt = pick_engine_gt(tile, class, instance);
 
-			if (class == XE_ENGINE_CLASS_OTHER) {
-				gt_other_irq_handler(engine_gt, instance, intr_vec);
+			hwe = xe_gt_hw_engine(engine_gt, class, instance, false);
+			if (hwe) {
+				xe_hw_engine_handle_irq(hwe, intr_vec);
 				continue;
 			}
 
-			hwe = xe_gt_hw_engine(engine_gt, class, instance, false);
-			if (!hwe)
+			if (class == XE_ENGINE_CLASS_OTHER) {
+				gt_other_irq_handler(engine_gt, instance, intr_vec);
 				continue;
-
-			xe_hw_engine_handle_irq(hwe, intr_vec);
+			}
 		}
 	}
 
@@ -457,6 +462,12 @@ static void gt_irq_reset(struct xe_tile *tile)
 	if (ccs_mask & (BIT(2)|BIT(3)))
 		xe_mmio_write32(mmio,  CCS2_CCS3_INTR_MASK, ~0);
 
+	if (tile->media_gt &&
+	    xe_hw_engine_mask_per_class(tile->media_gt, XE_ENGINE_CLASS_OTHER)) {
+		xe_mmio_write32(mmio, GUNIT_GSC_INTR_ENABLE, 0);
+		xe_mmio_write32(mmio, GUNIT_GSC_INTR_MASK, ~0);
+	}
+
 	xe_mmio_write32(mmio, GPM_WGBOXPERF_INTR_ENABLE, 0);
 	xe_mmio_write32(mmio, GPM_WGBOXPERF_INTR_MASK,  ~0);
 	xe_mmio_write32(mmio, GUC_SG_INTR_ENABLE,	 0);
-- 
2.46.1


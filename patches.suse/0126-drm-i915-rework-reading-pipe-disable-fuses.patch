From 501ec325f1ec4338c0b6d32001a6f4cdfc61a6b2 Mon Sep 17 00:00:00 2001
From: Lucas De Marchi <lucas.demarchi@intel.com>
Date: Tue, 25 Jun 2019 10:54:11 -0700
Subject: drm/i915: rework reading pipe disable fuses
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Git-commit: 501ec325f1ec4338c0b6d32001a6f4cdfc61a6b2
Patch-mainline: v5.4-rc1
References: bsc#1152489

This prepares to have possibly more than 3 pipes. I didn't want to
continue the previous approach since the check for "are the disabled
pipes the last ones" poses a combinatory explosion. We need that check
because in several places of the code we have that assumption. If that
ever becomes false in a new HW, other parts of the code would have to
change.

Now we start by considering we have info->num_pipes enabled and disable
each pipe that is marked as disabled. Then it's a simple matter of
checking if we have at least one pipe and that all the enabled ones are
the first pipes, i.e. there are no holes in the bitmask.

Cc: Jose Souza <jose.souza@intel.com>
Cc: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Signed-off-by: Lucas De Marchi <lucas.demarchi@intel.com>
Reviewed-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20190625175437.14840-3-lucas.demarchi@intel.com
Acked-by: Thomas Zimmermann <tzimmermann@suse.de>
---
 drivers/gpu/drm/i915/intel_device_info.c | 36 +++++++++---------------
 1 file changed, 13 insertions(+), 23 deletions(-)

diff --git a/drivers/gpu/drm/i915/intel_device_info.c b/drivers/gpu/drm/i915/intel_device_info.c
index 7135d8dc32a7..e64536e1fd1b 100644
--- a/drivers/gpu/drm/i915/intel_device_info.c
+++ b/drivers/gpu/drm/i915/intel_device_info.c
@@ -929,35 +929,25 @@ void intel_device_info_runtime_init(struct drm_i915_private *dev_priv)
 		}
 	} else if (HAS_DISPLAY(dev_priv) && INTEL_GEN(dev_priv) >= 9) {
 		u32 dfsm = I915_READ(SKL_DFSM);
-		u8 disabled_mask = 0;
-		bool invalid;
-		int num_bits;
+		u8 enabled_mask = BIT(info->num_pipes) - 1;
 
 		if (dfsm & SKL_DFSM_PIPE_A_DISABLE)
-			disabled_mask |= BIT(PIPE_A);
+			enabled_mask &= ~BIT(PIPE_A);
 		if (dfsm & SKL_DFSM_PIPE_B_DISABLE)
-			disabled_mask |= BIT(PIPE_B);
+			enabled_mask &= ~BIT(PIPE_B);
 		if (dfsm & SKL_DFSM_PIPE_C_DISABLE)
-			disabled_mask |= BIT(PIPE_C);
-
-		num_bits = hweight8(disabled_mask);
-
-		switch (disabled_mask) {
-		case BIT(PIPE_A):
-		case BIT(PIPE_B):
-		case BIT(PIPE_A) | BIT(PIPE_B):
-		case BIT(PIPE_A) | BIT(PIPE_C):
-			invalid = true;
-			break;
-		default:
-			invalid = false;
-		}
+			enabled_mask &= ~BIT(PIPE_C);
 
-		if (num_bits > info->num_pipes || invalid)
-			DRM_ERROR("invalid pipe fuse configuration: 0x%x\n",
-				  disabled_mask);
+		/*
+		 * At least one pipe should be enabled and if there are
+		 * disabled pipes, they should be the last ones, with no holes
+		 * in the mask.
+		 */
+		if (enabled_mask == 0 || !is_power_of_2(enabled_mask + 1))
+			DRM_ERROR("invalid pipe fuse configuration: enabled_mask=0x%x\n",
+				  enabled_mask);
 		else
-			info->num_pipes -= num_bits;
+			info->num_pipes = hweight8(enabled_mask);
 	}
 
 	/* Initialize slice/subslice/EU info */
-- 
2.28.0


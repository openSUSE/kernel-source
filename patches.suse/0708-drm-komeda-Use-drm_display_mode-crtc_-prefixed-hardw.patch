From ed22c6d9304d35fbdfe4818016ae57a9da5df9bc Mon Sep 17 00:00:00 2001
From: "james qian wang (Arm Technology China)" <james.qian.wang@arm.com>
Date: Tue, 18 Jun 2019 09:10:40 +0100
Subject: drm/komeda: Use drm_display_mode "crtc_" prefixed hardware timings
Git-commit: ed22c6d9304d35fbdfe4818016ae57a9da5df9bc
Patch-mainline: v5.4-rc1
References: bsc#1152472

struct drm_display_mode contains two copies of timings.
- plain timings.
- hardware timings, the ones with "crtc_" prefix.
According to the definition, update komeda to use the hardware timing.

Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20190618081013.13638-2-james.qian.wang@arm.com
Acked-by: Thomas Zimmermann <tzimmermann@suse.de>
---
 .../arm/display/komeda/d71/d71_component.c    | 36 ++++++++++++-------
 .../gpu/drm/arm/display/komeda/komeda_crtc.c  | 20 ++++++-----
 .../gpu/drm/arm/display/komeda/komeda_kms.h   |  2 --
 3 files changed, 35 insertions(+), 23 deletions(-)

diff --git a/drivers/gpu/drm/arm/display/komeda/d71/d71_component.c b/drivers/gpu/drm/arm/display/komeda/d71/d71_component.c
index 4073a452e24a..e9f340d4b41f 100644
--- a/drivers/gpu/drm/arm/display/komeda/d71/d71_component.c
+++ b/drivers/gpu/drm/arm/display/komeda/d71/d71_component.c
@@ -804,7 +804,7 @@ static int d71_downscaling_clk_check(struct komeda_pipeline *pipe,
 		denominator = (mode->htotal - 1) * v_out -  2 * v_in;
 	}
 
-	return aclk_rate * denominator >= mode->clock * 1000 * fraction ?
+	return aclk_rate * denominator >= mode->crtc_clock * 1000 * fraction ?
 	       0 : -EINVAL;
 }
 
@@ -1032,21 +1032,31 @@ static void d71_timing_ctrlr_update(struct komeda_component *c,
 				    struct komeda_component_state *state)
 {
 	struct drm_crtc_state *crtc_st = state->crtc->state;
+	struct drm_display_mode *mode = &crtc_st->adjusted_mode;
 	u32 __iomem *reg = c->reg;
-	struct videomode vm;
+	u32 hactive, hfront_porch, hback_porch, hsync_len;
+	u32 vactive, vfront_porch, vback_porch, vsync_len;
 	u32 value;
 
-	drm_display_mode_to_videomode(&crtc_st->adjusted_mode, &vm);
-
-	malidp_write32(reg, BS_ACTIVESIZE, HV_SIZE(vm.hactive, vm.vactive));
-	malidp_write32(reg, BS_HINTERVALS, BS_H_INTVALS(vm.hfront_porch,
-							vm.hback_porch));
-	malidp_write32(reg, BS_VINTERVALS, BS_V_INTVALS(vm.vfront_porch,
-							vm.vback_porch));
-
-	value = BS_SYNC_VSW(vm.vsync_len) | BS_SYNC_HSW(vm.hsync_len);
-	value |= vm.flags & DISPLAY_FLAGS_VSYNC_HIGH ? BS_SYNC_VSP : 0;
-	value |= vm.flags & DISPLAY_FLAGS_HSYNC_HIGH ? BS_SYNC_HSP : 0;
+	hactive = mode->crtc_hdisplay;
+	hfront_porch = mode->crtc_hsync_start - mode->crtc_hdisplay;
+	hsync_len = mode->crtc_hsync_end - mode->crtc_hsync_start;
+	hback_porch = mode->crtc_htotal - mode->crtc_hsync_end;
+
+	vactive = mode->crtc_vdisplay;
+	vfront_porch = mode->crtc_vsync_start - mode->crtc_vdisplay;
+	vsync_len = mode->crtc_vsync_end - mode->crtc_vsync_start;
+	vback_porch = mode->crtc_vtotal - mode->crtc_vsync_end;
+
+	malidp_write32(reg, BS_ACTIVESIZE, HV_SIZE(hactive, vactive));
+	malidp_write32(reg, BS_HINTERVALS, BS_H_INTVALS(hfront_porch,
+							hback_porch));
+	malidp_write32(reg, BS_VINTERVALS, BS_V_INTVALS(vfront_porch,
+							vback_porch));
+
+	value = BS_SYNC_VSW(vsync_len) | BS_SYNC_HSW(hsync_len);
+	value |= mode->flags & DRM_MODE_FLAG_PVSYNC ? BS_SYNC_VSP : 0;
+	value |= mode->flags & DRM_MODE_FLAG_PHSYNC ? BS_SYNC_HSP : 0;
 	malidp_write32(reg, BS_SYNC, value);
 
 	malidp_write32(reg, BS_PROG_LINE, D71_DEFAULT_PREPRETCH_LINE - 1);
diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
index f4400788ab94..c6a3808614dc 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
@@ -27,7 +27,7 @@ static void komeda_crtc_update_clock_ratio(struct komeda_crtc_state *kcrtc_st)
 		return;
 	}
 
-	pxlclk = kcrtc_st->base.adjusted_mode.clock * 1000;
+	pxlclk = kcrtc_st->base.adjusted_mode.crtc_clock * 1000;
 	aclk = komeda_calc_aclk(kcrtc_st);
 
 	kcrtc_st->clock_ratio = div64_u64(aclk << 32, pxlclk);
@@ -77,9 +77,9 @@ komeda_crtc_atomic_check(struct drm_crtc *crtc,
 unsigned long komeda_calc_aclk(struct komeda_crtc_state *kcrtc_st)
 {
 	struct komeda_dev *mdev = kcrtc_st->base.crtc->dev->dev_private;
-	unsigned long pxlclk = kcrtc_st->base.adjusted_mode.clock;
+	unsigned long aclk = kcrtc_st->base.adjusted_mode.crtc_clock;
 
-	return clk_round_rate(mdev->aclk, pxlclk * 1000);
+	return clk_round_rate(mdev->aclk, aclk * 1000);
 }
 
 /* For active a crtc, mainly need two parts of preparation
@@ -92,7 +92,7 @@ komeda_crtc_prepare(struct komeda_crtc *kcrtc)
 	struct komeda_dev *mdev = kcrtc->base.dev->dev_private;
 	struct komeda_pipeline *master = kcrtc->master;
 	struct komeda_crtc_state *kcrtc_st = to_kcrtc_st(kcrtc->base.state);
-	unsigned long pxlclk_rate = kcrtc_st->base.adjusted_mode.clock * 1000;
+	struct drm_display_mode *mode = &kcrtc_st->base.adjusted_mode;
 	u32 new_mode;
 	int err;
 
@@ -126,7 +126,7 @@ komeda_crtc_prepare(struct komeda_crtc *kcrtc)
 			DRM_ERROR("failed to enable aclk.\n");
 	}
 
-	err = clk_set_rate(master->pxlclk, pxlclk_rate);
+	err = clk_set_rate(master->pxlclk, mode->crtc_clock * 1000);
 	if (err)
 		DRM_ERROR("failed to set pxlclk for pipe%d\n", master->id);
 	err = clk_prepare_enable(master->pxlclk);
@@ -377,10 +377,14 @@ static bool komeda_crtc_mode_fixup(struct drm_crtc *crtc,
 				   struct drm_display_mode *adjusted_mode)
 {
 	struct komeda_crtc *kcrtc = to_kcrtc(crtc);
-	struct komeda_pipeline *master = kcrtc->master;
-	long mode_clk = m->clock * 1000;
+	unsigned long clk_rate;
+
+	drm_mode_set_crtcinfo(adjusted_mode, 0);
 
-	adjusted_mode->clock = clk_round_rate(master->pxlclk, mode_clk) / 1000;
+	clk_rate = adjusted_mode->crtc_clock * 1000;
+	/* crtc_clock will be used as the komeda output pixel clock */
+	adjusted_mode->crtc_clock = clk_round_rate(kcrtc->master->pxlclk,
+						   clk_rate) / 1000;
 
 	return true;
 }
diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
index 8c89fc245b83..2e2a68cc8c40 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
@@ -14,8 +14,6 @@
 #include <drm/drm_device.h>
 #include <drm/drm_writeback.h>
 #include <drm/drm_print.h>
-#include <video/videomode.h>
-#include <video/display_timing.h>
 
 /**
  * struct komeda_plane - komeda instance of drm_plane
-- 
2.28.0


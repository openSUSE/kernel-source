From 1a62780545c91dd298e3cf1ee9e5b865f6bc806f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ville=20Syrj=C3=A4l=C3=A4?= <ville.syrjala@linux.intel.com>
Date: Mon, 20 Jan 2020 19:47:19 +0200
Subject: drm/i915: Extract intel_cdclk_state
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Git-commit: 1965de63a93aecd788874e921f074b52fbea81a8
Patch-mainline: v5.7-rc1
References: jsc#SLE-12680, jsc#SLE-12880, jsc#SLE-12882, jsc#SLE-12883, jsc#SLE-13496, jsc#SLE-15322

Use the same structure to store the cdclk state in both
intel_atomic_state and dev_priv. First step towards proper
old vs. new cdclk states.

Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20200120174728.21095-10-ville.syrjala@linux.intel.com
Reviewed-by: José Roberto de Souza <jose.souza@intel.com>
Signed-off-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 .../gpu/drm/i915/display/intel_atomic_plane.c |   6 +-
 drivers/gpu/drm/i915/display/intel_audio.c    |   4 +-
 drivers/gpu/drm/i915/display/intel_cdclk.c    | 168 ++++++++++--------
 drivers/gpu/drm/i915/display/intel_display.c  |  29 ++-
 .../drm/i915/display/intel_display_types.h    |  30 +---
 drivers/gpu/drm/i915/i915_drv.h               |  51 ++++--
 6 files changed, 151 insertions(+), 137 deletions(-)

diff --git a/drivers/gpu/drm/i915/display/intel_atomic_plane.c b/drivers/gpu/drm/i915/display/intel_atomic_plane.c
index d1345a9ed040..7367ad0bf27c 100644
--- a/drivers/gpu/drm/i915/display/intel_atomic_plane.c
+++ b/drivers/gpu/drm/i915/display/intel_atomic_plane.c
@@ -159,6 +159,8 @@ bool intel_plane_calc_min_cdclk(struct intel_atomic_state *state,
 				struct intel_plane *plane)
 {
 	struct drm_i915_private *dev_priv = to_i915(plane->base.dev);
+	const struct intel_cdclk_state *cdclk_state =
+		&dev_priv->cdclk_state;
 	const struct intel_plane_state *plane_state =
 		intel_atomic_get_new_plane_state(state, plane);
 	struct intel_crtc *crtc = to_intel_crtc(plane_state->hw.crtc);
@@ -182,12 +184,12 @@ bool intel_plane_calc_min_cdclk(struct intel_atomic_state *state,
 	 * safe as long we hold at least one crtc mutex (which
 	 * must be true since we have crtc_state).
 	 */
-	if (crtc_state->min_cdclk[plane->id] > dev_priv->cdclk.logical.cdclk) {
+	if (crtc_state->min_cdclk[plane->id] > cdclk_state->logical.cdclk) {
 		drm_dbg_kms(&dev_priv->drm,
 			    "[PLANE:%d:%s] min_cdclk (%d kHz) > logical cdclk (%d kHz)\n",
 			    plane->base.base.id, plane->base.name,
 			    crtc_state->min_cdclk[plane->id],
-			    dev_priv->cdclk.logical.cdclk);
+			    cdclk_state->logical.cdclk);
 		return true;
 	}
 
diff --git a/drivers/gpu/drm/i915/display/intel_audio.c b/drivers/gpu/drm/i915/display/intel_audio.c
index 3926b9b9a09f..fef292c915d4 100644
--- a/drivers/gpu/drm/i915/display/intel_audio.c
+++ b/drivers/gpu/drm/i915/display/intel_audio.c
@@ -824,8 +824,8 @@ static void glk_force_audio_cdclk(struct drm_i915_private *dev_priv,
 	state->acquire_ctx = &ctx;
 
 retry:
-	to_intel_atomic_state(state)->cdclk.force_min_cdclk_changed = true;
-	to_intel_atomic_state(state)->cdclk.force_min_cdclk =
+	to_intel_atomic_state(state)->cdclk_state.force_min_cdclk_changed = true;
+	to_intel_atomic_state(state)->cdclk_state.force_min_cdclk =
 		enable ? 2 * 96000 : 0;
 
 	/* Protects dev_priv->cdclk.force_min_cdclk */
diff --git a/drivers/gpu/drm/i915/display/intel_cdclk.c b/drivers/gpu/drm/i915/display/intel_cdclk.c
index b045ad140c3a..ecf6664645b2 100644
--- a/drivers/gpu/drm/i915/display/intel_cdclk.c
+++ b/drivers/gpu/drm/i915/display/intel_cdclk.c
@@ -1831,8 +1831,8 @@ static bool intel_cdclk_changed(const struct intel_cdclk_config *a,
  */
 void intel_cdclk_clear_state(struct intel_atomic_state *state)
 {
-	memset(&state->cdclk, 0, sizeof(state->cdclk));
-	state->cdclk.pipe = INVALID_PIPE;
+	memset(&state->cdclk_state, 0, sizeof(state->cdclk_state));
+	state->cdclk_state.pipe = INVALID_PIPE;
 }
 
 /**
@@ -1852,15 +1852,18 @@ void intel_cdclk_swap_state(struct intel_atomic_state *state)
 	struct drm_i915_private *dev_priv = to_i915(state->base.dev);
 
 	/* FIXME maybe swap() these too */
-	memcpy(dev_priv->cdclk.min_cdclk, state->cdclk.min_cdclk,
-	       sizeof(state->cdclk.min_cdclk));
-	memcpy(dev_priv->cdclk.min_voltage_level, state->cdclk.min_voltage_level,
-	       sizeof(state->cdclk.min_voltage_level));
+	memcpy(dev_priv->cdclk_state.min_cdclk,
+	       state->cdclk_state.min_cdclk,
+	       sizeof(state->cdclk_state.min_cdclk));
+	memcpy(dev_priv->cdclk_state.min_voltage_level,
+	       state->cdclk_state.min_voltage_level,
+	       sizeof(state->cdclk_state.min_voltage_level));
 
-	dev_priv->cdclk.force_min_cdclk = state->cdclk.force_min_cdclk;
+	dev_priv->cdclk_state.force_min_cdclk =
+		state->cdclk_state.force_min_cdclk;
 
-	swap(state->cdclk.logical, dev_priv->cdclk.logical);
-	swap(state->cdclk.actual, dev_priv->cdclk.actual);
+	swap(state->cdclk_state.logical, dev_priv->cdclk_state.logical);
+	swap(state->cdclk_state.actual, dev_priv->cdclk_state.actual);
 }
 
 void intel_dump_cdclk_config(const struct intel_cdclk_config *cdclk_config,
@@ -1914,12 +1917,13 @@ intel_set_cdclk_pre_plane_update(struct intel_atomic_state *state)
 {
 	struct drm_i915_private *dev_priv = to_i915(state->base.dev);
 	/* called after intel_cdclk_swap_state()! */
-	const struct intel_cdclk_config *old_state = &state->cdclk.actual;
-	const struct intel_cdclk_config *new_state = &dev_priv->cdclk.actual;
-	enum pipe pipe = state->cdclk.pipe;
+	const struct intel_cdclk_state *old_cdclk_state = &state->cdclk_state;
+	const struct intel_cdclk_state *new_cdclk_state = &dev_priv->cdclk_state;
+	enum pipe pipe = old_cdclk_state->pipe; /* not swapped */
 
-	if (pipe == INVALID_PIPE || old_state->cdclk <= new_state->cdclk)
-		intel_set_cdclk(dev_priv, new_state, pipe);
+	if (pipe == INVALID_PIPE ||
+	    old_cdclk_state->actual.cdclk <= new_cdclk_state->actual.cdclk)
+		intel_set_cdclk(dev_priv, &new_cdclk_state->actual, pipe);
 }
 
 /**
@@ -1934,12 +1938,13 @@ intel_set_cdclk_post_plane_update(struct intel_atomic_state *state)
 {
 	struct drm_i915_private *dev_priv = to_i915(state->base.dev);
 	/* called after intel_cdclk_swap_state()! */
-	const struct intel_cdclk_config *old_state = &state->cdclk.actual;
-	const struct intel_cdclk_config *new_state = &dev_priv->cdclk.actual;
-	enum pipe pipe = state->cdclk.pipe;
+	const struct intel_cdclk_state *old_cdclk_state = &state->cdclk_state;
+	const struct intel_cdclk_state *new_cdclk_state = &dev_priv->cdclk_state;
+	enum pipe pipe = old_cdclk_state->pipe; /* not swapped */
 
-	if (pipe != INVALID_PIPE && old_state->cdclk > new_state->cdclk)
-		intel_set_cdclk(dev_priv, new_state, pipe);
+	if (pipe != INVALID_PIPE &&
+	    old_cdclk_state->actual.cdclk > new_cdclk_state->actual.cdclk)
+		intel_set_cdclk(dev_priv, &new_cdclk_state->actual, pipe);
 }
 
 static int intel_pixel_rate_to_cdclk(const struct intel_crtc_state *crtc_state)
@@ -2069,6 +2074,7 @@ int intel_crtc_compute_min_cdclk(const struct intel_crtc_state *crtc_state)
 static int intel_compute_min_cdclk(struct intel_atomic_state *state)
 {
 	struct drm_i915_private *dev_priv = to_i915(state->base.dev);
+	struct intel_cdclk_state *cdclk_state = &state->cdclk_state;
 	struct intel_crtc *crtc;
 	struct intel_crtc_state *crtc_state;
 	int min_cdclk, i;
@@ -2081,19 +2087,19 @@ static int intel_compute_min_cdclk(struct intel_atomic_state *state)
 		if (min_cdclk < 0)
 			return min_cdclk;
 
-		if (state->cdclk.min_cdclk[i] == min_cdclk)
+		if (cdclk_state->min_cdclk[i] == min_cdclk)
 			continue;
 
-		state->cdclk.min_cdclk[i] = min_cdclk;
+		cdclk_state->min_cdclk[i] = min_cdclk;
 
 		ret = intel_atomic_lock_global_state(state);
 		if (ret)
 			return ret;
 	}
 
-	min_cdclk = state->cdclk.force_min_cdclk;
+	min_cdclk = cdclk_state->force_min_cdclk;
 	for_each_pipe(dev_priv, pipe)
-		min_cdclk = max(state->cdclk.min_cdclk[pipe], min_cdclk);
+		min_cdclk = max(cdclk_state->min_cdclk[pipe], min_cdclk);
 
 	return min_cdclk;
 }
@@ -2114,6 +2120,7 @@ static int intel_compute_min_cdclk(struct intel_atomic_state *state)
 static int bxt_compute_min_voltage_level(struct intel_atomic_state *state)
 {
 	struct drm_i915_private *dev_priv = to_i915(state->base.dev);
+	struct intel_cdclk_state *cdclk_state = &state->cdclk_state;
 	struct intel_crtc *crtc;
 	struct intel_crtc_state *crtc_state;
 	u8 min_voltage_level;
@@ -2128,10 +2135,10 @@ static int bxt_compute_min_voltage_level(struct intel_atomic_state *state)
 		else
 			min_voltage_level = 0;
 
-		if (state->cdclk.min_voltage_level[i] == min_voltage_level)
+		if (cdclk_state->min_voltage_level[i] == min_voltage_level)
 			continue;
 
-		state->cdclk.min_voltage_level[i] = min_voltage_level;
+		cdclk_state->min_voltage_level[i] = min_voltage_level;
 
 		ret = intel_atomic_lock_global_state(state);
 		if (ret)
@@ -2140,7 +2147,7 @@ static int bxt_compute_min_voltage_level(struct intel_atomic_state *state)
 
 	min_voltage_level = 0;
 	for_each_pipe(dev_priv, pipe)
-		min_voltage_level = max(state->cdclk.min_voltage_level[pipe],
+		min_voltage_level = max(cdclk_state->min_voltage_level[pipe],
 					min_voltage_level);
 
 	return min_voltage_level;
@@ -2149,6 +2156,7 @@ static int bxt_compute_min_voltage_level(struct intel_atomic_state *state)
 static int vlv_modeset_calc_cdclk(struct intel_atomic_state *state)
 {
 	struct drm_i915_private *dev_priv = to_i915(state->base.dev);
+	struct intel_cdclk_state *cdclk_state = &state->cdclk_state;
 	int min_cdclk, cdclk;
 
 	min_cdclk = intel_compute_min_cdclk(state);
@@ -2157,18 +2165,18 @@ static int vlv_modeset_calc_cdclk(struct intel_atomic_state *state)
 
 	cdclk = vlv_calc_cdclk(dev_priv, min_cdclk);
 
-	state->cdclk.logical.cdclk = cdclk;
-	state->cdclk.logical.voltage_level =
+	cdclk_state->logical.cdclk = cdclk;
+	cdclk_state->logical.voltage_level =
 		vlv_calc_voltage_level(dev_priv, cdclk);
 
 	if (!state->active_pipes) {
-		cdclk = vlv_calc_cdclk(dev_priv, state->cdclk.force_min_cdclk);
+		cdclk = vlv_calc_cdclk(dev_priv, cdclk_state->force_min_cdclk);
 
-		state->cdclk.actual.cdclk = cdclk;
-		state->cdclk.actual.voltage_level =
+		cdclk_state->actual.cdclk = cdclk;
+		cdclk_state->actual.voltage_level =
 			vlv_calc_voltage_level(dev_priv, cdclk);
 	} else {
-		state->cdclk.actual = state->cdclk.logical;
+		cdclk_state->actual = cdclk_state->logical;
 	}
 
 	return 0;
@@ -2176,6 +2184,7 @@ static int vlv_modeset_calc_cdclk(struct intel_atomic_state *state)
 
 static int bdw_modeset_calc_cdclk(struct intel_atomic_state *state)
 {
+	struct intel_cdclk_state *cdclk_state = &state->cdclk_state;
 	int min_cdclk, cdclk;
 
 	min_cdclk = intel_compute_min_cdclk(state);
@@ -2188,18 +2197,18 @@ static int bdw_modeset_calc_cdclk(struct intel_atomic_state *state)
 	 */
 	cdclk = bdw_calc_cdclk(min_cdclk);
 
-	state->cdclk.logical.cdclk = cdclk;
-	state->cdclk.logical.voltage_level =
+	cdclk_state->logical.cdclk = cdclk;
+	cdclk_state->logical.voltage_level =
 		bdw_calc_voltage_level(cdclk);
 
 	if (!state->active_pipes) {
-		cdclk = bdw_calc_cdclk(state->cdclk.force_min_cdclk);
+		cdclk = bdw_calc_cdclk(cdclk_state->force_min_cdclk);
 
-		state->cdclk.actual.cdclk = cdclk;
-		state->cdclk.actual.voltage_level =
+		cdclk_state->actual.cdclk = cdclk;
+		cdclk_state->actual.voltage_level =
 			bdw_calc_voltage_level(cdclk);
 	} else {
-		state->cdclk.actual = state->cdclk.logical;
+		cdclk_state->actual = cdclk_state->logical;
 	}
 
 	return 0;
@@ -2208,11 +2217,12 @@ static int bdw_modeset_calc_cdclk(struct intel_atomic_state *state)
 static int skl_dpll0_vco(struct intel_atomic_state *state)
 {
 	struct drm_i915_private *dev_priv = to_i915(state->base.dev);
+	struct intel_cdclk_state *cdclk_state = &state->cdclk_state;
 	struct intel_crtc *crtc;
 	struct intel_crtc_state *crtc_state;
 	int vco, i;
 
-	vco = state->cdclk.logical.vco;
+	vco = cdclk_state->logical.vco;
 	if (!vco)
 		vco = dev_priv->skl_preferred_vco_freq;
 
@@ -2243,6 +2253,7 @@ static int skl_dpll0_vco(struct intel_atomic_state *state)
 
 static int skl_modeset_calc_cdclk(struct intel_atomic_state *state)
 {
+	struct intel_cdclk_state *cdclk_state = &state->cdclk_state;
 	int min_cdclk, cdclk, vco;
 
 	min_cdclk = intel_compute_min_cdclk(state);
@@ -2257,20 +2268,20 @@ static int skl_modeset_calc_cdclk(struct intel_atomic_state *state)
 	 */
 	cdclk = skl_calc_cdclk(min_cdclk, vco);
 
-	state->cdclk.logical.vco = vco;
-	state->cdclk.logical.cdclk = cdclk;
-	state->cdclk.logical.voltage_level =
+	cdclk_state->logical.vco = vco;
+	cdclk_state->logical.cdclk = cdclk;
+	cdclk_state->logical.voltage_level =
 		skl_calc_voltage_level(cdclk);
 
 	if (!state->active_pipes) {
-		cdclk = skl_calc_cdclk(state->cdclk.force_min_cdclk, vco);
+		cdclk = skl_calc_cdclk(cdclk_state->force_min_cdclk, vco);
 
-		state->cdclk.actual.vco = vco;
-		state->cdclk.actual.cdclk = cdclk;
-		state->cdclk.actual.voltage_level =
+		cdclk_state->actual.vco = vco;
+		cdclk_state->actual.cdclk = cdclk;
+		cdclk_state->actual.voltage_level =
 			skl_calc_voltage_level(cdclk);
 	} else {
-		state->cdclk.actual = state->cdclk.logical;
+		cdclk_state->actual = cdclk_state->logical;
 	}
 
 	return 0;
@@ -2279,6 +2290,7 @@ static int skl_modeset_calc_cdclk(struct intel_atomic_state *state)
 static int bxt_modeset_calc_cdclk(struct intel_atomic_state *state)
 {
 	struct drm_i915_private *dev_priv = to_i915(state->base.dev);
+	struct intel_cdclk_state *cdclk_state = &state->cdclk_state;
 	int min_cdclk, min_voltage_level, cdclk, vco;
 
 	min_cdclk = intel_compute_min_cdclk(state);
@@ -2292,22 +2304,22 @@ static int bxt_modeset_calc_cdclk(struct intel_atomic_state *state)
 	cdclk = bxt_calc_cdclk(dev_priv, min_cdclk);
 	vco = bxt_calc_cdclk_pll_vco(dev_priv, cdclk);
 
-	state->cdclk.logical.vco = vco;
-	state->cdclk.logical.cdclk = cdclk;
-	state->cdclk.logical.voltage_level =
+	cdclk_state->logical.vco = vco;
+	cdclk_state->logical.cdclk = cdclk;
+	cdclk_state->logical.voltage_level =
 		max_t(int, min_voltage_level,
 		      dev_priv->display.calc_voltage_level(cdclk));
 
 	if (!state->active_pipes) {
-		cdclk = bxt_calc_cdclk(dev_priv, state->cdclk.force_min_cdclk);
+		cdclk = bxt_calc_cdclk(dev_priv, cdclk_state->force_min_cdclk);
 		vco = bxt_calc_cdclk_pll_vco(dev_priv, cdclk);
 
-		state->cdclk.actual.vco = vco;
-		state->cdclk.actual.cdclk = cdclk;
-		state->cdclk.actual.voltage_level =
+		cdclk_state->actual.vco = vco;
+		cdclk_state->actual.cdclk = cdclk;
+		cdclk_state->actual.voltage_level =
 			dev_priv->display.calc_voltage_level(cdclk);
 	} else {
-		state->cdclk.actual = state->cdclk.logical;
+		cdclk_state->actual = cdclk_state->logical;
 	}
 
 	return 0;
@@ -2371,20 +2383,22 @@ static int fixed_modeset_calc_cdclk(struct intel_atomic_state *state)
 int intel_modeset_calc_cdclk(struct intel_atomic_state *state)
 {
 	struct drm_i915_private *dev_priv = to_i915(state->base.dev);
+	const struct intel_cdclk_state *old_cdclk_state = &dev_priv->cdclk_state;
+	struct intel_cdclk_state *new_cdclk_state = &state->cdclk_state;
 	enum pipe pipe;
 	int ret;
 
-	memcpy(state->cdclk.min_cdclk, dev_priv->cdclk.min_cdclk,
-	       sizeof(state->cdclk.min_cdclk));
-	memcpy(state->cdclk.min_voltage_level, dev_priv->cdclk.min_voltage_level,
-	       sizeof(state->cdclk.min_voltage_level));
+	memcpy(new_cdclk_state->min_cdclk, old_cdclk_state->min_cdclk,
+	       sizeof(new_cdclk_state->min_cdclk));
+	memcpy(new_cdclk_state->min_voltage_level, old_cdclk_state->min_voltage_level,
+	       sizeof(new_cdclk_state->min_voltage_level));
 
 	/* keep the current setting */
-	if (!state->cdclk.force_min_cdclk_changed)
-		state->cdclk.force_min_cdclk = dev_priv->cdclk.force_min_cdclk;
+	if (!new_cdclk_state->force_min_cdclk_changed)
+		new_cdclk_state->force_min_cdclk = old_cdclk_state->force_min_cdclk;
 
-	state->cdclk.logical = dev_priv->cdclk.logical;
-	state->cdclk.actual = dev_priv->cdclk.actual;
+	new_cdclk_state->logical = old_cdclk_state->logical;
+	new_cdclk_state->actual = old_cdclk_state->actual;
 
 	ret = dev_priv->display.modeset_calc_cdclk(state);
 	if (ret)
@@ -2395,8 +2409,8 @@ int intel_modeset_calc_cdclk(struct intel_atomic_state *state)
 	 * by holding all the crtc mutexes even if we don't end up
 	 * touching the hardware
 	 */
-	if (intel_cdclk_changed(&dev_priv->cdclk.actual,
-				&state->cdclk.actual)) {
+	if (intel_cdclk_changed(&old_cdclk_state->actual,
+				&new_cdclk_state->actual)) {
 		/*
 		 * Also serialize commits across all crtcs
 		 * if the actual hw needs to be poked.
@@ -2404,8 +2418,8 @@ int intel_modeset_calc_cdclk(struct intel_atomic_state *state)
 		ret = intel_atomic_serialize_global_state(state);
 		if (ret)
 			return ret;
-	} else if (intel_cdclk_changed(&dev_priv->cdclk.logical,
-				       &state->cdclk.logical)) {
+	} else if (intel_cdclk_changed(&old_cdclk_state->logical,
+				       &new_cdclk_state->logical)) {
 		ret = intel_atomic_lock_global_state(state);
 		if (ret)
 			return ret;
@@ -2415,8 +2429,8 @@ int intel_modeset_calc_cdclk(struct intel_atomic_state *state)
 
 	if (is_power_of_2(state->active_pipes) &&
 	    intel_cdclk_can_cd2x_update(dev_priv,
-					&dev_priv->cdclk.actual,
-					&state->cdclk.actual)) {
+					&old_cdclk_state->actual,
+					&new_cdclk_state->actual)) {
 		struct intel_crtc *crtc;
 		struct intel_crtc_state *crtc_state;
 
@@ -2434,19 +2448,19 @@ int intel_modeset_calc_cdclk(struct intel_atomic_state *state)
 	}
 
 	if (pipe != INVALID_PIPE) {
-		state->cdclk.pipe = pipe;
+		new_cdclk_state->pipe = pipe;
 
 		drm_dbg_kms(&dev_priv->drm,
 			    "Can change cdclk with pipe %c active\n",
 			    pipe_name(pipe));
-	} else if (intel_cdclk_needs_modeset(&dev_priv->cdclk.actual,
-					     &state->cdclk.actual)) {
+	} else if (intel_cdclk_needs_modeset(&old_cdclk_state->actual,
+					     &new_cdclk_state->actual)) {
 		/* All pipes must be switched off while we change the cdclk. */
 		ret = intel_modeset_all_pipes(state);
 		if (ret)
 			return ret;
 
-		state->cdclk.pipe = INVALID_PIPE;
+		new_cdclk_state->pipe = INVALID_PIPE;
 
 		drm_dbg_kms(&dev_priv->drm,
 			    "Modeset required for cdclk change\n");
@@ -2454,12 +2468,12 @@ int intel_modeset_calc_cdclk(struct intel_atomic_state *state)
 
 	drm_dbg_kms(&dev_priv->drm,
 		    "New cdclk calculated to be logical %u kHz, actual %u kHz\n",
-		    state->cdclk.logical.cdclk,
-		    state->cdclk.actual.cdclk);
+		    new_cdclk_state->logical.cdclk,
+		    new_cdclk_state->actual.cdclk);
 	drm_dbg_kms(&dev_priv->drm,
 		    "New voltage level calculated to be logical %u, actual %u\n",
-		    state->cdclk.logical.voltage_level,
-		    state->cdclk.actual.voltage_level);
+		    new_cdclk_state->logical.voltage_level,
+		    new_cdclk_state->actual.voltage_level);
 
 	return 0;
 }
diff --git a/drivers/gpu/drm/i915/display/intel_display.c b/drivers/gpu/drm/i915/display/intel_display.c
index 992eed00a809..fe5e6e6d34de 100644
--- a/drivers/gpu/drm/i915/display/intel_display.c
+++ b/drivers/gpu/drm/i915/display/intel_display.c
@@ -7531,6 +7531,8 @@ static void intel_crtc_disable_noatomic(struct intel_crtc *crtc,
 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
 	struct intel_bw_state *bw_state =
 		to_intel_bw_state(dev_priv->bw_obj.state);
+	struct intel_cdclk_state *cdclk_state =
+		&dev_priv->cdclk_state;
 	struct intel_crtc_state *crtc_state =
 		to_intel_crtc_state(crtc->base.state);
 	enum intel_display_power_domain domain;
@@ -7599,8 +7601,8 @@ static void intel_crtc_disable_noatomic(struct intel_crtc *crtc,
 	crtc->enabled_power_domains = 0;
 
 	dev_priv->active_pipes &= ~BIT(pipe);
-	dev_priv->cdclk.min_cdclk[pipe] = 0;
-	dev_priv->cdclk.min_voltage_level[pipe] = 0;
+	cdclk_state->min_cdclk[pipe] = 0;
+	cdclk_state->min_voltage_level[pipe] = 0;
 
 	bw_state->data_rate[pipe] = 0;
 	bw_state->num_active_planes[pipe] = 0;
@@ -7845,6 +7847,8 @@ static bool hsw_compute_ips_config(struct intel_crtc_state *crtc_state)
 		to_i915(crtc_state->uapi.crtc->dev);
 	struct intel_atomic_state *intel_state =
 		to_intel_atomic_state(crtc_state->uapi.state);
+	const struct intel_cdclk_state *cdclk_state =
+		&intel_state->cdclk_state;
 
 	if (!hsw_crtc_state_ips_capable(crtc_state))
 		return false;
@@ -7864,7 +7868,7 @@ static bool hsw_compute_ips_config(struct intel_crtc_state *crtc_state)
 
 	/* pixel rate mustn't exceed 95% of cdclk with IPS on BDW */
 	if (IS_BROADWELL(dev_priv) &&
-	    crtc_state->pixel_rate > intel_state->cdclk.logical.cdclk * 95 / 100)
+	    crtc_state->pixel_rate > cdclk_state->logical.cdclk * 95 / 100)
 		return false;
 
 	return true;
@@ -12688,12 +12692,14 @@ static u16 hsw_ips_linetime_wm(const struct intel_crtc_state *crtc_state)
 		to_intel_atomic_state(crtc_state->uapi.state);
 	const struct drm_display_mode *adjusted_mode =
 		&crtc_state->hw.adjusted_mode;
+	const struct intel_cdclk_state *cdclk_state =
+		&state->cdclk_state;
 
 	if (!crtc_state->hw.enable)
 		return 0;
 
 	return DIV_ROUND_CLOSEST(adjusted_mode->crtc_htotal * 1000 * 8,
-				 state->cdclk.logical.cdclk);
+				 cdclk_state->logical.cdclk);
 }
 
 static u16 skl_linetime_wm(const struct intel_crtc_state *crtc_state)
@@ -14941,7 +14947,7 @@ static int intel_atomic_check(struct drm_device *dev,
 	if (ret)
 		goto fail;
 
-	any_ms |= state->cdclk.force_min_cdclk_changed;
+	any_ms |= state->cdclk_state.force_min_cdclk_changed;
 
 	ret = intel_atomic_check_planes(state, &any_ms);
 	if (ret)
@@ -14952,7 +14958,7 @@ static int intel_atomic_check(struct drm_device *dev,
 		if (ret)
 			goto fail;
 	} else {
-		state->cdclk.logical = dev_priv->cdclk.logical;
+		state->cdclk_state.logical = dev_priv->cdclk_state.logical;
 	}
 
 	ret = intel_atomic_check_crtcs(state);
@@ -17576,9 +17582,12 @@ void intel_init_display_hooks(struct drm_i915_private *dev_priv)
 
 void intel_modeset_init_hw(struct drm_i915_private *i915)
 {
+	struct intel_cdclk_state *cdclk_state =
+		&i915->cdclk_state;
+
 	intel_update_cdclk(i915);
 	intel_dump_cdclk_config(&i915->cdclk.hw, "Current CDCLK");
-	i915->cdclk.logical = i915->cdclk.actual = i915->cdclk.hw;
+	cdclk_state->logical = cdclk_state->actual = i915->cdclk.hw;
 }
 
 static int sanitize_watermarks_add_affected(struct drm_atomic_state *state)
@@ -18453,6 +18462,8 @@ static void intel_modeset_readout_hw_state(struct drm_device *dev)
 	for_each_intel_crtc(dev, crtc) {
 		struct intel_bw_state *bw_state =
 			to_intel_bw_state(dev_priv->bw_obj.state);
+		struct intel_cdclk_state *cdclk_state =
+			&dev_priv->cdclk_state;
 		struct intel_crtc_state *crtc_state =
 			to_intel_crtc_state(crtc->base.state);
 		struct intel_plane *plane;
@@ -18522,8 +18533,8 @@ static void intel_modeset_readout_hw_state(struct drm_device *dev)
 				min_cdclk = 0;
 		}
 
-		dev_priv->cdclk.min_cdclk[crtc->pipe] = min_cdclk;
-		dev_priv->cdclk.min_voltage_level[crtc->pipe] =
+		cdclk_state->min_cdclk[crtc->pipe] = min_cdclk;
+		cdclk_state->min_voltage_level[crtc->pipe] =
 			crtc_state->min_voltage_level;
 
 		intel_bw_crtc_update(bw_state, crtc_state);
diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index a536d971fc9e..f59ba7105009 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -462,31 +462,7 @@ struct intel_atomic_state {
 
 	intel_wakeref_t wakeref;
 
-	struct {
-		/*
-		 * Logical configuration of cdclk (used for all scaling,
-		 * watermark, etc. calculations and checks). This is
-		 * computed as if all enabled crtcs were active.
-		 */
-		struct intel_cdclk_config logical;
-
-		/*
-		 * Actual configuration of cdclk, can be different from the
-		 * logical configuration only when all crtc's are DPMS off.
-		 */
-		struct intel_cdclk_config actual;
-
-		int force_min_cdclk;
-		bool force_min_cdclk_changed;
-
-		/* minimum acceptable cdclk for each pipe */
-		int min_cdclk[I915_MAX_PIPES];
-		/* minimum acceptable voltage level for each pipe */
-		u8 min_voltage_level[I915_MAX_PIPES];
-
-		/* pipe to which cd2x update is synchronized */
-		enum pipe pipe;
-	} cdclk;
+	struct intel_cdclk_state cdclk_state;
 
 	bool dpll_set, modeset;
 
@@ -514,9 +490,7 @@ struct intel_atomic_state {
 
 	/*
 	 * active_pipes
-	 * min_cdclk[]
-	 * min_voltage_level[]
-	 * cdclk.*
+	 * cdclk_state
 	 */
 	bool global_state_changed;
 
diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h
index 4a0883890598..d8512ac908c9 100644
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@ -65,6 +65,7 @@
 #include "i915_utils.h"
 
 #include "display/intel_bios.h"
+#include "display/intel_cdclk.h"
 #include "display/intel_display.h"
 #include "display/intel_display_power.h"
 #include "display/intel_dpll_mgr.h"
@@ -887,6 +888,33 @@ struct i915_selftest_stash {
 	atomic_t counter;
 };
 
+struct intel_cdclk_state {
+	/*
+	 * Logical configuration of cdclk (used for all scaling,
+	 * watermark, etc. calculations and checks). This is
+	 * computed as if all enabled crtcs were active.
+	 */
+	struct intel_cdclk_config logical;
+
+	/*
+	 * Actual configuration of cdclk, can be different from the
+	 * logical configuration only when all crtc's are DPMS off.
+	 */
+	struct intel_cdclk_config actual;
+
+	/* minimum acceptable cdclk for each pipe */
+	int min_cdclk[I915_MAX_PIPES];
+	/* minimum acceptable voltage level for each pipe */
+	u8 min_voltage_level[I915_MAX_PIPES];
+
+	/* pipe to which cd2x update is synchronized */
+	enum pipe pipe;
+
+	/* forced minimum cdclk for glk+ audio w/a */
+	int force_min_cdclk;
+	bool force_min_cdclk_changed;
+};
+
 struct drm_i915_private {
 	struct drm_device drm;
 
@@ -1007,29 +1035,14 @@ struct drm_i915_private {
 	 * For reading holding any crtc lock is sufficient,
 	 * for writing must hold all of them.
 	 */
+	struct intel_cdclk_state cdclk_state;
+
 	struct {
-		/*
-		 * The current logical cdclk configuration.
-		 * See intel_atomic_state.cdclk.logical
-		 */
-		struct intel_cdclk_config logical;
-		/*
-		 * The current actual cdclk configuration.
-		 * See intel_atomic_state.cdclk.actual
-		 */
-		struct intel_cdclk_config actual;
 		/* The current hardware cdclk configuration */
 		struct intel_cdclk_config hw;
 
 		/* cdclk, divider, and ratio table from bspec */
 		const struct intel_cdclk_vals *table;
-
-		int force_min_cdclk;
-
-		/* minimum acceptable cdclk for each pipe */
-		int min_cdclk[I915_MAX_PIPES];
-		/* minimum acceptable voltage level for each pipe */
-		u8 min_voltage_level[I915_MAX_PIPES];
 	} cdclk;
 
 	/**
@@ -1086,8 +1099,8 @@ struct drm_i915_private {
 	struct mutex dpll_lock;
 
 	/*
-	 * For reading active_pipes, min_cdclk, min_voltage_level holding
-	 * any crtc lock is sufficient, for writing must hold all of them.
+	 * For reading active_pipes, cdclk_state holding any crtc
+	 * lock is sufficient, for writing must hold all of them.
 	 */
 	u8 active_pipes;
 
-- 
2.28.0


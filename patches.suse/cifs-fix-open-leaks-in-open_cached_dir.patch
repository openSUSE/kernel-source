From: Paulo Alcantara <palcantara@suse.de>
Date: Thu, 16 Mar 2023 16:03:13 -0300
Subject: [PATCH] cifs: fix open leaks in open_cached_dir()
Patch-mainline: Never, fixed upstream by unrelated upstream commit ebe98f1447bb
References: bsc#1209342

[ematsumiya: remove atomic_inc(&tcon->num_remote_opens) for context adjustment]

When calling open_cached_dir(), we send a compounded
SMB2_CREATE+SMB2_QUERY_INFO request when we don't have a cached root
directory handle, but if a concurrent process was able to open and
cache it (e.g. tcon->crfid.is_valid was set after unblocking from
tcon->crfid.fid_mutex), we ended up

	(1) leaking open file handles as the fid assignment was done
	only after tcon->crfid.is_valid check

	(2) sending close requests to already-closed files due to
	uninitialised fid

Fix this by moving the fid assignment up and have it set prior to
checking for concurrent opens and close extra handle accordingly.

Signed-off-by: Paulo Alcantara <palcantara@suse.de>
Acked-by: Paulo Alcantara <palcantara@suse.de>
---
 fs/cifs/smb2ops.c |   40 ++++++++++++++++++----------------------
 1 file changed, 18 insertions(+), 22 deletions(-)

--- a/fs/cifs/smb2ops.c
+++ b/fs/cifs/smb2ops.c
@@ -860,6 +860,22 @@
 	rc = compound_send_recv(xid, ses, server,
 				flags, 2, rqst,
 				resp_buftype, rsp_iov);
+	if (rc) {
+		if (rc == -EREMCHG) {
+			tcon->need_reconnect = true;
+			printk_once(KERN_WARNING "server share %s deleted\n",
+				    tcon->treeName);
+		}
+		goto oshr_free;
+	}
+
+	o_rsp = (struct smb2_create_rsp *)rsp_iov[0].iov_base;
+	oparms.fid->persistent_fid = o_rsp->PersistentFileId;
+	oparms.fid->volatile_fid = o_rsp->VolatileFileId;
+#ifdef CONFIG_CIFS_DEBUG2
+	oparms.fid->mid = le64_to_cpu(o_rsp->hdr.MessageId);
+#endif /* CIFS_DEBUG2 */
+
 	mutex_lock(&tcon->crfid.fid_mutex);
 
 	/*
@@ -884,35 +900,15 @@
 
 		mutex_unlock(&tcon->crfid.fid_mutex);
 
-		if (rc == 0) {
-			/* close extra handle outside of crit sec */
-			SMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);
-		}
-		rc = 0;
+		/* close extra handle outside of crit sec */
+		SMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);
 		goto oshr_free;
 	}
 
 	/* Cached root is still invalid, continue normaly */
-
-	if (rc) {
-		if (rc == -EREMCHG) {
-			tcon->need_reconnect = true;
-			pr_warn_once("server share %s deleted\n",
-				     tcon->treeName);
-		}
-		goto oshr_exit;
-	}
-
 	atomic_inc(&tcon->num_remote_opens);
 	is_open = true;
 
-	o_rsp = (struct smb2_create_rsp *)rsp_iov[0].iov_base;
-	oparms.fid->persistent_fid = o_rsp->PersistentFileId;
-	oparms.fid->volatile_fid = o_rsp->VolatileFileId;
-#ifdef CONFIG_CIFS_DEBUG2
-	oparms.fid->mid = le64_to_cpu(o_rsp->hdr.MessageId);
-#endif /* CIFS_DEBUG2 */
-
 	tcon->crfid.tcon = tcon;
 	tcon->crfid.dentry = dentry;
 	tcon->crfid.is_valid = true;

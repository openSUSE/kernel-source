From 92aa2db0657caa8807f82e86b0378e5d8dfa5a7e Mon Sep 17 00:00:00 2001
From: Thomas Zimmermann <tzimmermann@suse.de>
Date: Thu, 14 Nov 2019 15:10:21 +0100
Subject: drm/udl: Unmap buffer object after damage update
Git-commit: 6c44e30ae130b740441ac0c65d5fa12dd6586942
Patch-mainline: v5.6-rc1
References: jsc#SLE-12680, jsc#SLE-12880, jsc#SLE-12882, jsc#SLE-12883, jsc#SLE-13496, jsc#SLE-15322

Udl keeps a BO mapped for its entire lifetime if it has been used in a
damage update at least once. The BO's free callback release the mapping
before it frees the BO.

Change this behaviour to unmap immediately after the damage update, so
SHMEM's implementation of free can be used.

Signed-off-by: Thomas Zimmermann <tzimmermann@suse.de>
Acked-by: Sam Ravnborg <sam@ravnborg.org>
Link: https://patchwork.freedesktop.org/patch/msgid/20191114141025.32198-2-tzimmermann@suse.de
Signed-off-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 drivers/gpu/drm/udl/udl_fb.c | 31 ++++++++++++++++++-------------
 1 file changed, 18 insertions(+), 13 deletions(-)

diff --git a/drivers/gpu/drm/udl/udl_fb.c b/drivers/gpu/drm/udl/udl_fb.c
index 8fe4d8cf3212..a9e6ec360b16 100644
--- a/drivers/gpu/drm/udl/udl_fb.c
+++ b/drivers/gpu/drm/udl/udl_fb.c
@@ -73,6 +73,7 @@ int udl_handle_damage(struct udl_framebuffer *fb, int x, int y,
 	struct urb *urb;
 	int aligned_x;
 	int log_bpp;
+	void *vaddr;
 
 	BUG_ON(!is_power_of_2(fb->base.format->cpp[0]));
 	log_bpp = __ffs(fb->base.format->cpp[0]);
@@ -80,14 +81,10 @@ int udl_handle_damage(struct udl_framebuffer *fb, int x, int y,
 	if (!fb->active_16)
 		return 0;
 
-	if (!fb->shmem->vaddr) {
-		void *vaddr;
-
-		vaddr = drm_gem_shmem_vmap(&fb->shmem->base);
-		if (IS_ERR(vaddr)) {
-			DRM_ERROR("failed to vmap fb\n");
-			return 0;
-		}
+	vaddr = drm_gem_shmem_vmap(&fb->shmem->base);
+	if (IS_ERR(vaddr)) {
+		DRM_ERROR("failed to vmap fb\n");
+		return 0;
 	}
 
 	aligned_x = DL_ALIGN_DOWN(x, sizeof(unsigned long));
@@ -96,22 +93,23 @@ int udl_handle_damage(struct udl_framebuffer *fb, int x, int y,
 
 	if ((width <= 0) ||
 	    (x + width > fb->base.width) ||
-	    (y + height > fb->base.height))
-		return -EINVAL;
+	    (y + height > fb->base.height)) {
+		ret = -EINVAL;
+		goto err_drm_gem_shmem_vunmap;
+	}
 
 	start_cycles = get_cycles();
 
 	urb = udl_get_urb(dev);
 	if (!urb)
-		return 0;
+		goto out;
 	cmd = urb->transfer_buffer;
 
 	for (i = y; i < y + height ; i++) {
 		const int line_offset = fb->base.pitches[0] * i;
 		const int byte_offset = line_offset + (x << log_bpp);
 		const int dev_byte_offset = (fb->base.width * i + x) << log_bpp;
-		if (udl_render_hline(dev, log_bpp, &urb,
-				     (char *) fb->shmem->vaddr,
+		if (udl_render_hline(dev, log_bpp, &urb, (char *)vaddr,
 				     &cmd, byte_offset, dev_byte_offset,
 				     width << log_bpp,
 				     &bytes_identical, &bytes_sent))
@@ -138,7 +136,14 @@ int udl_handle_damage(struct udl_framebuffer *fb, int x, int y,
 		    >> 10)), /* Kcycles */
 		   &udl->cpu_kcycles_used);
 
+out:
+	drm_gem_shmem_vunmap(&fb->shmem->base, vaddr);
+
 	return 0;
+
+err_drm_gem_shmem_vunmap:
+	drm_gem_shmem_vunmap(&fb->shmem->base, vaddr);
+	return ret;
 }
 
 static int udl_user_framebuffer_dirty(struct drm_framebuffer *fb,
-- 
2.28.0


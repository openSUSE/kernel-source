From 069e48943cf8c656b945bfb248681da30cc40b45 Mon Sep 17 00:00:00 2001
From: Jagan Teki <jagan@amarulasolutions.com>
Date: Wed, 12 Jan 2022 00:13:47 +0530
Subject: Revert "drm: exynos: dsi: Convert to bridge driver"
Git-commit: bd29823e05ac5ba81e9f6c8ca51f040c8b47a741
Patch-mainline: v5.18-rc1
References: jsc#PED-1166 jsc#PED-1168 jsc#PED-1170 jsc#PED-1218 jsc#PED-1220 jsc#PED-1222 jsc#PED-1223 jsc#PED-1225

This reverts commit 92e794fab87af0793403d5e4a547f0be94a0e656.

It is merged by accident, the actual patch series on this bridge
conversion is still under review.

Revert this as it breaks the exynos DSI.

Signed-off-by: Jagan Teki <jagan@amarulasolutions.com>
Signed-off-by: Robert Foss <robert.foss@linaro.org>
Link: https://patchwork.freedesktop.org/patch/msgid/20220111184347.502471-1-jagan@amarulasolutions.com
Reviewed-by: Robert Foss <robert.foss@linaro.org>
Acked-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 drivers/gpu/drm/exynos/exynos_drm_dsi.c | 93 +++++++++----------------
 1 file changed, 32 insertions(+), 61 deletions(-)

diff --git a/drivers/gpu/drm/exynos/exynos_drm_dsi.c b/drivers/gpu/drm/exynos/exynos_drm_dsi.c
index 338be06a4c4f..334862d422e2 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_dsi.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_dsi.c
@@ -256,7 +256,6 @@ struct exynos_dsi {
 	struct drm_connector connector;
 	struct drm_panel *panel;
 	struct list_head bridge_chain;
-	struct drm_bridge bridge;
 	struct drm_bridge *out_bridge;
 	struct device *dev;
 	struct drm_display_mode mode;
@@ -288,9 +287,9 @@ struct exynos_dsi {
 #define host_to_dsi(host) container_of(host, struct exynos_dsi, dsi_host)
 #define connector_to_dsi(c) container_of(c, struct exynos_dsi, connector)
 
-static inline struct exynos_dsi *bridge_to_dsi(struct drm_bridge *b)
+static inline struct exynos_dsi *encoder_to_dsi(struct drm_encoder *e)
 {
-	return container_of(b, struct exynos_dsi, bridge);
+	return container_of(e, struct exynos_dsi, encoder);
 }
 
 enum reg_idx {
@@ -1366,10 +1365,9 @@ static void exynos_dsi_unregister_te_irq(struct exynos_dsi *dsi)
 	}
 }
 
-static void exynos_dsi_atomic_enable(struct drm_bridge *bridge,
-				     struct drm_bridge_state *old_bridge_state)
+static void exynos_dsi_enable(struct drm_encoder *encoder)
 {
-	struct exynos_dsi *dsi = bridge_to_dsi(bridge);
+	struct exynos_dsi *dsi = encoder_to_dsi(encoder);
 	struct drm_bridge *iter;
 	int ret;
 
@@ -1392,8 +1390,7 @@ static void exynos_dsi_atomic_enable(struct drm_bridge *bridge,
 		list_for_each_entry_reverse(iter, &dsi->bridge_chain,
 					    chain_node) {
 			if (iter->funcs->pre_enable)
-				iter->funcs->atomic_pre_enable(iter,
-							       old_bridge_state);
+				iter->funcs->pre_enable(iter);
 		}
 	}
 
@@ -1407,7 +1404,7 @@ static void exynos_dsi_atomic_enable(struct drm_bridge *bridge,
 	} else {
 		list_for_each_entry(iter, &dsi->bridge_chain, chain_node) {
 			if (iter->funcs->enable)
-				iter->funcs->atomic_enable(iter, old_bridge_state);
+				iter->funcs->enable(iter);
 		}
 	}
 
@@ -1423,10 +1420,9 @@ static void exynos_dsi_atomic_enable(struct drm_bridge *bridge,
 	pm_runtime_put(dsi->dev);
 }
 
-static void exynos_dsi_atomic_disable(struct drm_bridge *bridge,
-				      struct drm_bridge_state *old_bridge_state)
+static void exynos_dsi_disable(struct drm_encoder *encoder)
 {
-	struct exynos_dsi *dsi = bridge_to_dsi(bridge);
+	struct exynos_dsi *dsi = encoder_to_dsi(encoder);
 	struct drm_bridge *iter;
 
 	if (!(dsi->state & DSIM_STATE_ENABLED))
@@ -1438,7 +1434,7 @@ static void exynos_dsi_atomic_disable(struct drm_bridge *bridge,
 
 	list_for_each_entry_reverse(iter, &dsi->bridge_chain, chain_node) {
 		if (iter->funcs->disable)
-			iter->funcs->atomic_disable(iter, old_bridge_state);
+			iter->funcs->disable(iter);
 	}
 
 	exynos_dsi_set_display_enable(dsi, false);
@@ -1446,13 +1442,22 @@ static void exynos_dsi_atomic_disable(struct drm_bridge *bridge,
 
 	list_for_each_entry(iter, &dsi->bridge_chain, chain_node) {
 		if (iter->funcs->post_disable)
-			iter->funcs->atomic_post_disable(iter, old_bridge_state);
+			iter->funcs->post_disable(iter);
 	}
 
 	dsi->state &= ~DSIM_STATE_ENABLED;
 	pm_runtime_put_sync(dsi->dev);
 }
 
+static void exynos_dsi_mode_set(struct drm_encoder *encoder,
+				struct drm_display_mode *mode,
+				struct drm_display_mode *adjusted_mode)
+{
+	struct exynos_dsi *dsi = encoder_to_dsi(encoder);
+
+	drm_mode_copy(&dsi->mode, adjusted_mode);
+}
+
 static enum drm_connector_status
 exynos_dsi_detect(struct drm_connector *connector, bool force)
 {
@@ -1489,9 +1494,9 @@ static const struct drm_connector_helper_funcs exynos_dsi_connector_helper_funcs
 	.get_modes = exynos_dsi_get_modes,
 };
 
-static int exynos_dsi_create_connector(struct exynos_dsi *dsi)
+static int exynos_dsi_create_connector(struct drm_encoder *encoder)
 {
-	struct drm_encoder *encoder = &dsi->encoder;
+	struct exynos_dsi *dsi = encoder_to_dsi(encoder);
 	struct drm_connector *connector = &dsi->connector;
 	struct drm_device *drm = encoder->dev;
 	int ret;
@@ -1517,31 +1522,10 @@ static int exynos_dsi_create_connector(struct exynos_dsi *dsi)
 	return 0;
 }
 
-static void exynos_dsi_mode_set(struct drm_bridge *bridge,
-				const struct drm_display_mode *mode,
-				const struct drm_display_mode *adjusted_mode)
-{
-	struct exynos_dsi *dsi = bridge_to_dsi(bridge);
-
-	drm_mode_copy(&dsi->mode, adjusted_mode);
-}
-
-static int exynos_dsi_attach(struct drm_bridge *bridge,
-			     enum drm_bridge_attach_flags flags)
-{
-	struct exynos_dsi *dsi = bridge_to_dsi(bridge);
-
-	return drm_bridge_attach(bridge->encoder, dsi->out_bridge, NULL, 0);
-}
-
-static const struct drm_bridge_funcs exynos_dsi_bridge_funcs = {
-	.atomic_duplicate_state	= drm_atomic_helper_bridge_duplicate_state,
-	.atomic_destroy_state	= drm_atomic_helper_bridge_destroy_state,
-	.atomic_reset		= drm_atomic_helper_bridge_reset,
-	.atomic_enable		= exynos_dsi_atomic_enable,
-	.atomic_disable		= exynos_dsi_atomic_disable,
-	.mode_set		= exynos_dsi_mode_set,
-	.attach			= exynos_dsi_attach,
+static const struct drm_encoder_helper_funcs exynos_dsi_encoder_helper_funcs = {
+	.enable = exynos_dsi_enable,
+	.disable = exynos_dsi_disable,
+	.mode_set = exynos_dsi_mode_set,
 };
 
 MODULE_DEVICE_TABLE(of, exynos_dsi_of_match);
@@ -1560,7 +1544,7 @@ static int exynos_dsi_host_attach(struct mipi_dsi_host *host,
 		dsi->out_bridge = out_bridge;
 		list_splice_init(&encoder->bridge_chain, &dsi->bridge_chain);
 	} else {
-		int ret = exynos_dsi_create_connector(dsi);
+		int ret = exynos_dsi_create_connector(encoder);
 
 		if (ret) {
 			DRM_DEV_ERROR(dsi->dev,
@@ -1613,7 +1597,7 @@ static int exynos_dsi_host_detach(struct mipi_dsi_host *host,
 
 	if (dsi->panel) {
 		mutex_lock(&drm->mode_config.mutex);
-		exynos_dsi_atomic_disable(&dsi->bridge, NULL);
+		exynos_dsi_disable(&dsi->encoder);
 		dsi->panel = NULL;
 		dsi->connector.status = connector_status_disconnected;
 		mutex_unlock(&drm->mode_config.mutex);
@@ -1719,16 +1703,12 @@ static int exynos_dsi_bind(struct device *dev, struct device *master,
 
 	drm_simple_encoder_init(drm_dev, encoder, DRM_MODE_ENCODER_TMDS);
 
+	drm_encoder_helper_add(encoder, &exynos_dsi_encoder_helper_funcs);
+
 	ret = exynos_drm_set_possible_crtcs(encoder, EXYNOS_DISPLAY_TYPE_LCD);
 	if (ret < 0)
 		return ret;
 
-	ret = drm_bridge_attach(&dsi->encoder, &dsi->bridge, NULL, 0);
-	if (ret) {
-		drm_encoder_cleanup(&dsi->encoder);
-		return ret;
-	}
-
 	in_bridge_node = of_graph_get_remote_node(dev->of_node, DSI_PORT_IN, 0);
 	if (in_bridge_node) {
 		in_bridge = of_drm_find_bridge(in_bridge_node);
@@ -1744,9 +1724,10 @@ static void exynos_dsi_unbind(struct device *dev, struct device *master,
 				void *data)
 {
 	struct exynos_dsi *dsi = dev_get_drvdata(dev);
+	struct drm_encoder *encoder = &dsi->encoder;
+
+	exynos_dsi_disable(encoder);
 
-	exynos_dsi_atomic_disable(&dsi->bridge, NULL);
-	drm_encoder_cleanup(&dsi->encoder);
 	mipi_dsi_host_unregister(&dsi->dsi_host);
 }
 
@@ -1836,12 +1817,6 @@ static int exynos_dsi_probe(struct platform_device *pdev)
 
 	pm_runtime_enable(dev);
 
-	dsi->bridge.funcs = &exynos_dsi_bridge_funcs;
-	dsi->bridge.of_node = dev->of_node;
-	dsi->bridge.type = DRM_MODE_CONNECTOR_DSI;
-
-	drm_bridge_add(&dsi->bridge);
-
 	ret = component_add(dev, &exynos_dsi_component_ops);
 	if (ret)
 		goto err_disable_runtime;
@@ -1856,10 +1831,6 @@ static int exynos_dsi_probe(struct platform_device *pdev)
 
 static int exynos_dsi_remove(struct platform_device *pdev)
 {
-	struct exynos_dsi *dsi = platform_get_drvdata(pdev);
-
-	drm_bridge_remove(&dsi->bridge);
-
 	pm_runtime_disable(&pdev->dev);
 
 	component_del(&pdev->dev, &exynos_dsi_component_ops);
-- 
2.38.1


From: Kurt Garloff <garloff@suse.de>
Subject: Reduce ide probe delays
Patch-mainline: 
References: 

IDE takes ~5s to initialize, most of which is spent in the msleep(50)
in ide-probe.c. This patch allows to pass idewait=XXX to make the
ide probe code wait XXX ms instead of the old 50ms.
I've not seen any PCI IDE chipset that breaks with 5ms, so we default
to it and save ~3s of kernel init time.
Pass idewait=50 to be failsafe.

Acked-by: 
Signed-off-by: 

--- linux-2.6.12/drivers/ide/ide.c~	2005-07-05 12:30:34.000000000 +0200
+++ linux-2.6.12/drivers/ide/ide.c	2005-07-05 12:32:17.000000000 +0200
@@ -199,6 +199,12 @@
 EXPORT_SYMBOL(ide_hwifs);
 
 /*
+ * The ide_probe_function takes too much time ...
+ */
+int ide_wait_ms = 5;
+EXPORT_SYMBOL(ide_wait_ms);
+
+/*
  * Do not even *think* about calling this!
  */
 static void init_hwif_data(ide_hwif_t *hwif, unsigned int index)
@@ -1561,6 +1567,13 @@
 		return 1;
 	}
 
+	if (!strncmp(s, "idewait=", 8)) {
+		char *dummy;
+		ide_wait_ms = simple_strtol(s+8, &dummy, 10);
+		printk(KERN_INFO " : Wait for %i ms\n", ide_wait_ms);
+		return 1;
+	}
+
 	/*
 	 * Look for drive options:  "hdx="
 	 */
--- linux-2.6.12/drivers/ide/ide-probe.c~	2005-07-05 12:30:39.000000000 +0200
+++ linux-2.6.12/drivers/ide/ide-probe.c	2005-07-05 12:32:49.000000000 +0200
@@ -57,6 +57,8 @@
 #include <asm/uaccess.h>
 #include <asm/io.h>
 
+extern int ide_wait_ms;
+
 /**
  *	generic_id		-	add a generic drive id
  *	@drive:	drive to make an ID block for
@@ -318,7 +320,7 @@
 	u8 s = 0, a = 0;
 
 	/* take a deep breath */
-	msleep(50);
+	msleep(ide_wait_ms);
 
 	if (IDE_CONTROL_REG) {
 		a = hwif->INB(IDE_ALTSTATUS_REG);
@@ -353,11 +355,11 @@
 			return 1;
 		}
 		/* give drive a breather */
-		msleep(50);
+		msleep(ide_wait_ms);
 	} while ((hwif->INB(hd_status)) & BUSY_STAT);
 
 	/* wait for IRQ and DRQ_STAT */
-	msleep(50);
+	msleep(ide_wait_ms);
 	if (OK_STAT((hwif->INB(IDE_STATUS_REG)), DRQ_STAT, BAD_R_STAT)) {
 		unsigned long flags;
 
@@ -477,15 +479,15 @@
 	/* needed for some systems
 	 * (e.g. crw9624 as drive0 with disk as slave)
 	 */
-	msleep(50);
+	msleep(ide_wait_ms);
 	SELECT_DRIVE(drive);
-	msleep(50);
+	msleep(ide_wait_ms);
 	if (hwif->INB(IDE_SELECT_REG) != drive->select.all && !drive->present) {
 		if (drive->select.b.unit != 0) {
 			/* exit with drive0 selected */
 			SELECT_DRIVE(&hwif->drives[0]);
 			/* allow BUSY_STAT to assert & clear */
-			msleep(50);
+			msleep(ide_wait_ms);
 		}
 		/* no i/f present: mmm.. this should be a 4 -ml */
 		return 3;
@@ -508,14 +510,14 @@
 			printk("%s: no response (status = 0x%02x), "
 				"resetting drive\n", drive->name,
 				hwif->INB(IDE_STATUS_REG));
-			msleep(50);
+			msleep(ide_wait_ms);
 			hwif->OUTB(drive->select.all, IDE_SELECT_REG);
-			msleep(50);
+			msleep(ide_wait_ms);
 			hwif->OUTB(WIN_SRST, IDE_COMMAND_REG);
 			timeout = jiffies;
 			while (((hwif->INB(IDE_STATUS_REG)) & BUSY_STAT) &&
 			       time_before(jiffies, timeout + WAIT_WORSTCASE))
-				msleep(50);
+				msleep(ide_wait_ms);
 			rc = try_to_identify(drive, cmd);
 		}
 		if (rc == 1)
@@ -530,7 +532,7 @@
 	if (drive->select.b.unit != 0) {
 		/* exit with drive0 selected */
 		SELECT_DRIVE(&hwif->drives[0]);
-		msleep(50);
+		msleep(ide_wait_ms);
 		/* ensure drive irq is clear */
 		(void) hwif->INB(IDE_STATUS_REG);
 	}
@@ -547,7 +549,7 @@
 
 	printk("%s: enabling %s -- ", hwif->name, drive->id->model);
 	SELECT_DRIVE(drive);
-	msleep(50);
+	msleep(ide_wait_ms);
 	hwif->OUTB(EXABYTE_ENABLE_NEST, IDE_COMMAND_REG);
 	timeout = jiffies + WAIT_WORSTCASE;
 	do {
@@ -555,10 +557,10 @@
 			printk("failed (timeout)\n");
 			return;
 		}
-		msleep(50);
+		msleep(ide_wait_ms);
 	} while ((hwif->INB(IDE_STATUS_REG)) & BUSY_STAT);
 
-	msleep(50);
+	msleep(ide_wait_ms);
 
 	if (!OK_STAT((hwif->INB(IDE_STATUS_REG)), 0, BAD_STAT)) {
 		printk("failed (status = 0x%02x)\n", hwif->INB(IDE_STATUS_REG));
@@ -837,7 +839,7 @@
 		udelay(10);
 		hwif->OUTB(8, hwif->io_ports[IDE_CONTROL_OFFSET]);
 		do {
-			msleep(50);
+			msleep(ide_wait_ms);
 			stat = hwif->INB(hwif->io_ports[IDE_STATUS_OFFSET]);
 		} while ((stat & BUSY_STAT) && time_after(timeout, jiffies));
 

From: Hannes Reinecke <hare@suse.de>
Subject: DM-MPIO fails to tresspass LUNs on CLARiiON arrays
Reference: bnc#484529

On Clariion arrays we fail to send the trespass command correctly.
We're trying to send the trespass command to via an disabled path,
causing the device handler to loop trying to send the command on
an invalid path.

Signed-off-by: Hannes Reinecke <hare@suse.de>

diff --git a/drivers/md/dm-mpath.c b/drivers/md/dm-mpath.c
index bef4c53..65152a9 100644
--- a/drivers/md/dm-mpath.c
+++ b/drivers/md/dm-mpath.c
@@ -462,6 +462,9 @@ static void process_queued_ios(struct work_struct *work)
 		m->pg_init_count++;
 		m->pg_init_required = 0;
 		list_for_each_entry(tmp, &pgpath->pg->pgpaths, list) {
+			/* Skip disabled paths or failed paths */
+			if (!tmp->path.dev || !tmp->is_active)
+				continue;
 			if (queue_work(kmpath_handlerd, &tmp->activate_path))
 				m->pg_init_in_progress++;
 		}
@@ -1184,8 +1187,8 @@ static void pg_init_done(void *data, int errors)
 			errors = 0;
 			break;
 		}
-		DMERR("Cannot failover device because scsi_dh_%s was not "
-		      "loaded.", m->hw_handler_name);
+		DMERR("Cannot failover device %s because scsi_dh_%s was not "
+		      "loaded.", pgpath->path.pdev, m->hw_handler_name);
 		/*
 		 * Fail path for now, so we do not ping pong
 		 */
@@ -1198,6 +1201,10 @@ static void pg_init_done(void *data, int errors)
 		 */
 		bypass_pg(m, pg, 1);
 		break;
+	case SCSI_DH_DEV_OFFLINED:
+		DMWARN("Device %s offlined.", pgpath->path.pdev);
+		errors = 0;
+		break;
 	/* TODO: For SCSI_DH_RETRY we should wait a couple seconds */
 	case SCSI_DH_RETRY:
 	case SCSI_DH_IMM_RETRY:
@@ -1218,7 +1225,8 @@ static void pg_init_done(void *data, int errors)
 	spin_lock_irqsave(&m->lock, flags);
 	if (errors) {
 		if (pgpath == m->current_pgpath) {
-			DMERR("Could not failover device. Error %d.", errors);
+			DMERR("Could not failover device %s, error %d.",
+			      pgpath->path.pdev, errors);
 			m->current_pgpath = NULL;
 			m->current_pg = NULL;
 		}
diff --git a/drivers/md/dm-table.c b/drivers/md/dm-table.c
index b4328f2..ff79a56 100644
--- a/drivers/md/dm-table.c
+++ b/drivers/md/dm-table.c
@@ -407,14 +407,18 @@ static int upgrade_mode(struct dm_dev_internal *dd, fmode_t new_mode,
 
 	dd_new = dd_old = *dd;
 
-	dd_new.dm_dev.mode |= new_mode;
+	dd_new.dm_dev.mode = new_mode;
 	dd_new.dm_dev.bdev = NULL;
 
 	r = open_dev(&dd_new, dd->dm_dev.bdev->bd_dev, md);
-	if (r)
+	if (r == -EROFS) {
+		dd_new.dm_dev.mode &= ~FMODE_WRITE;
+		r = open_dev(&dd_new, dd->dm_dev.bdev->bd_dev, md);
+	}
+	if (!r)
 		return r;
 
-	dd->dm_dev.mode |= new_mode;
+	dd->dm_dev.mode = new_mode;
 	close_dev(&dd_old, md);
 
 	return 0;
@@ -477,7 +481,7 @@ static int __table_get_device(struct dm_table *t, struct dm_target *ti,
 		atomic_set(&dd->count, 0);
 		list_add(&dd->list, &t->devices);
 
-	} else if (dd->dm_dev.mode != (mode | dd->dm_dev.mode)) {
+	} else if (dd->dm_dev.mode != mode) {
 		r = upgrade_mode(dd, mode, t->md);
 		if (r)
 			return r;

diff -ruN linux-2.6.5/fs/xip2fs/Makefile linux-2.6.5+xip/fs/xip2fs/Makefile
--- linux-2.6.5/fs/xip2fs/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5+xip/fs/xip2fs/Makefile	2004-04-29 14:04:10.000000000 +0200
@@ -0,0 +1,12 @@
+#
+# Makefile for the linux xip2-filesystem routines.
+#
+
+obj-$(CONFIG_XIP2_FS) += xip2.o
+
+xip2-y := balloc.o bitmap.o dir.o file.o  ialloc.o inode.o \
+	  ioctl.o namei.o super.o symlink.o
+
+xip2-$(CONFIG_XIP2_FS_XATTR)	 += xattr.o xattr_user.o xattr_trusted.o
+xip2-$(CONFIG_XIP2_FS_POSIX_ACL) += acl.o
+xip2-$(CONFIG_XIP2_FS_SECURITY)	 += xattr_security.o
diff -ruN linux-2.6.5/fs/xip2fs/acl.c linux-2.6.5+xip/fs/xip2fs/acl.c
--- linux-2.6.5/fs/xip2fs/acl.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5+xip/fs/xip2fs/acl.c	2004-04-29 14:04:09.000000000 +0200
@@ -0,0 +1,332 @@
+/*
+ *  linux/fs/xip2fs/acl.c, Version 1
+ *
+ * (C) Copyright IBM Corp. 2002,2004
+ * Author(s): Carsten Otte <cotte@de.ibm.com>
+ *            Gerald Schaefer <geraldsc@de.ibm.com>
+ * derived from second extended filesystem (ext2)
+ */
+
+
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include "xip2.h"
+#include "xattr.h"
+#include "acl.h"
+
+/*
+ * Convert from filesystem to in-memory representation.
+ */
+static struct posix_acl *
+xip2_acl_from_disk(const void *value, size_t size)
+{
+	const char *end = (char *)value + size;
+	int n, count;
+	struct posix_acl *acl;
+
+	if (!value)
+		return NULL;
+	if (size < sizeof(xip2_acl_header))
+		 return ERR_PTR(-EINVAL);
+	if (((xip2_acl_header *)value)->a_version !=
+	    cpu_to_le32(XIP2_ACL_VERSION))
+		return ERR_PTR(-EINVAL);
+	value = (char *)value + sizeof(xip2_acl_header);
+	count = xip2_acl_count(size);
+	if (count < 0)
+		return ERR_PTR(-EINVAL);
+	if (count == 0)
+		return NULL;
+	acl = posix_acl_alloc(count, GFP_KERNEL);
+	if (!acl)
+		return ERR_PTR(-ENOMEM);
+	for (n=0; n < count; n++) {
+		xip2_acl_entry *entry =
+			(xip2_acl_entry *)value;
+		if ((char *)value + sizeof(xip2_acl_entry_short) > end)
+			goto fail;
+		acl->a_entries[n].e_tag  = le16_to_cpu(entry->e_tag);
+		acl->a_entries[n].e_perm = le16_to_cpu(entry->e_perm);
+		switch(acl->a_entries[n].e_tag) {
+			case ACL_USER_OBJ:
+			case ACL_GROUP_OBJ:
+			case ACL_MASK:
+			case ACL_OTHER:
+				value = (char *)value +
+					sizeof(xip2_acl_entry_short);
+				acl->a_entries[n].e_id = ACL_UNDEFINED_ID;
+				break;
+
+			case ACL_USER:
+			case ACL_GROUP:
+				value = (char *)value + sizeof(xip2_acl_entry);
+				if ((char *)value > end)
+					goto fail;
+				acl->a_entries[n].e_id =
+					le32_to_cpu(entry->e_id);
+				break;
+
+			default:
+				goto fail;
+		}
+	}
+	if (value != end)
+		goto fail;
+	return acl;
+
+fail:
+	posix_acl_release(acl);
+	return ERR_PTR(-EINVAL);
+}
+
+static inline struct posix_acl *
+xip2_iget_acl(struct inode *inode, struct posix_acl **i_acl)
+{
+	struct posix_acl *acl = XIP2_ACL_NOT_CACHED;
+
+	spin_lock(&inode->i_lock);
+	if (*i_acl != XIP2_ACL_NOT_CACHED)
+		acl = posix_acl_dup(*i_acl);
+	spin_unlock(&inode->i_lock);
+
+	return acl;
+}
+
+static inline void
+xip2_iset_acl(struct inode *inode, struct posix_acl **i_acl,
+		   struct posix_acl *acl)
+{
+	spin_lock(&inode->i_lock);
+	if (*i_acl != XIP2_ACL_NOT_CACHED)
+		posix_acl_release(*i_acl);
+	*i_acl = posix_acl_dup(acl);
+	spin_unlock(&inode->i_lock);
+}
+
+/*
+ * inode->i_sem: don't care
+ */
+static struct posix_acl *
+xip2_get_acl(struct inode *inode, int type)
+{
+	struct xip2_inode_info *ei = XIP2_I(inode);
+	int name_index;
+	char *value = NULL;
+	struct posix_acl *acl;
+	int retval;
+
+	if (!test_opt(inode->i_sb, POSIX_ACL))
+		return 0;
+
+	switch(type) {
+		case ACL_TYPE_ACCESS:
+			acl = xip2_iget_acl(inode, &ei->i_acl);
+			if (acl != XIP2_ACL_NOT_CACHED)
+				return acl;
+			name_index = XIP2_XATTR_INDEX_POSIX_ACL_ACCESS;
+			break;
+
+		case ACL_TYPE_DEFAULT:
+			acl = xip2_iget_acl(inode, &ei->i_default_acl);
+			if (acl != XIP2_ACL_NOT_CACHED)
+				return acl;
+			name_index = XIP2_XATTR_INDEX_POSIX_ACL_DEFAULT;
+			break;
+
+		default:
+			return ERR_PTR(-EINVAL);
+	}
+	retval = xip2_xattr_get(inode, name_index, "", NULL, 0);
+	if (retval > 0) {
+		value = kmalloc(retval, GFP_KERNEL);
+		if (!value)
+			return ERR_PTR(-ENOMEM);
+		retval = xip2_xattr_get(inode, name_index, "", value, retval);
+	}
+	if (retval > 0)
+		acl = xip2_acl_from_disk(value, retval);
+	else if (retval == -ENODATA || retval == -ENOSYS)
+		acl = NULL;
+	else
+		acl = ERR_PTR(retval);
+	if (value)
+		kfree(value);
+
+	if (!IS_ERR(acl)) {
+		switch(type) {
+			case ACL_TYPE_ACCESS:
+				xip2_iset_acl(inode, &ei->i_acl, acl);
+				break;
+
+			case ACL_TYPE_DEFAULT:
+				xip2_iset_acl(inode, &ei->i_default_acl, acl);
+				break;
+		}
+	}
+	return acl;
+}
+/*
+ * Inode operation permission().
+ *
+ * inode->i_sem: don't care
+ */
+int
+xip2_permission(struct inode *inode, int mask, struct nameidata *nd)
+{
+	int mode = inode->i_mode;
+
+	/* Nobody gets write access to a read-only fs */
+	if ((mask & MAY_WRITE) && IS_RDONLY(inode) &&
+	    (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)))
+		return -EROFS;
+	/* Nobody gets write access to an immutable file */
+	if ((mask & MAY_WRITE) && IS_IMMUTABLE(inode))
+	    return -EACCES;
+	if (current->fsuid == inode->i_uid) {
+		mode >>= 6;
+	} else if (test_opt(inode->i_sb, POSIX_ACL)) {
+		struct posix_acl *acl;
+
+		/* The access ACL cannot grant access if the group class
+		   permission bits don't contain all requested permissions. */
+		if (((mode >> 3) & mask & S_IRWXO) != mask)
+			goto check_groups;
+		acl = xip2_get_acl(inode, ACL_TYPE_ACCESS);
+		if (acl) {
+			int error = posix_acl_permission(inode, acl, mask);
+			posix_acl_release(acl);
+			if (error == -EACCES)
+				goto check_capabilities;
+			return error;
+		} else
+			goto check_groups;
+	} else {
+check_groups:
+		if (in_group_p(inode->i_gid))
+			mode >>= 3;
+	}
+	if ((mode & mask & S_IRWXO) == mask)
+		return 0;
+
+check_capabilities:
+	/* Allowed to override Discretionary Access Control? */
+	if (!(mask & MAY_EXEC) ||
+	    (inode->i_mode & S_IXUGO) || S_ISDIR(inode->i_mode))
+		if (capable(CAP_DAC_OVERRIDE))
+			return 0;
+	/* Read and search granted if capable(CAP_DAC_READ_SEARCH) */
+	if (capable(CAP_DAC_READ_SEARCH) && ((mask == MAY_READ) ||
+	    (S_ISDIR(inode->i_mode) && !(mask & MAY_WRITE))))
+		return 0;
+	return -EACCES;
+}
+
+/*
+ * Extended attribut handlers
+ */
+static size_t
+xip2_xattr_list_acl_access(char *list, struct inode *inode,
+			   const char *name, int name_len)
+{
+	const size_t size = sizeof(XATTR_NAME_ACL_ACCESS);
+
+	if (!test_opt(inode->i_sb, POSIX_ACL))
+		return 0;
+	if (list)
+		memcpy(list, XATTR_NAME_ACL_ACCESS, size);
+	return size;
+}
+
+static size_t
+xip2_xattr_list_acl_default(char *list, struct inode *inode,
+			    const char *name, int name_len)
+{
+	const size_t size = sizeof(XATTR_NAME_ACL_DEFAULT);
+
+	if (!test_opt(inode->i_sb, POSIX_ACL))
+		return 0;
+	if (list)
+		memcpy(list, XATTR_NAME_ACL_DEFAULT, size);
+	return size;
+}
+
+static int
+xip2_xattr_get_acl(struct inode *inode, int type, void *buffer, size_t size)
+{
+	struct posix_acl *acl;
+	int error;
+
+	if (!test_opt(inode->i_sb, POSIX_ACL))
+		return -EOPNOTSUPP;
+
+	acl = xip2_get_acl(inode, type);
+	if (IS_ERR(acl))
+		return PTR_ERR(acl);
+	if (acl == NULL)
+		return -ENODATA;
+	error = posix_acl_to_xattr(acl, buffer, size);
+	posix_acl_release(acl);
+
+	return error;
+}
+
+static int
+xip2_xattr_get_acl_access(struct inode *inode, const char *name,
+			  void *buffer, size_t size)
+{
+	if (strcmp(name, "") != 0)
+		return -EINVAL;
+	return xip2_xattr_get_acl(inode, ACL_TYPE_ACCESS, buffer, size);
+}
+
+static int
+xip2_xattr_get_acl_default(struct inode *inode, const char *name,
+			   void *buffer, size_t size)
+{
+	if (strcmp(name, "") != 0)
+		return -EINVAL;
+	return xip2_xattr_get_acl(inode, ACL_TYPE_DEFAULT, buffer, size);
+}
+
+struct xip2_xattr_handler xip2_xattr_acl_access_handler = {
+	.prefix	= XATTR_NAME_ACL_ACCESS,
+	.list	= xip2_xattr_list_acl_access,
+	.get	= xip2_xattr_get_acl_access,
+};
+
+struct xip2_xattr_handler xip2_xattr_acl_default_handler = {
+	.prefix	= XATTR_NAME_ACL_DEFAULT,
+	.list	= xip2_xattr_list_acl_default,
+	.get	= xip2_xattr_get_acl_default,
+};
+
+void
+exit_xip2_acl(void)
+{
+	xip2_xattr_unregister(XIP2_XATTR_INDEX_POSIX_ACL_ACCESS,
+			      &xip2_xattr_acl_access_handler);
+	xip2_xattr_unregister(XIP2_XATTR_INDEX_POSIX_ACL_DEFAULT,
+			      &xip2_xattr_acl_default_handler);
+}
+
+int __init
+init_xip2_acl(void)
+{
+	int error;
+
+	error = xip2_xattr_register(XIP2_XATTR_INDEX_POSIX_ACL_ACCESS,
+				    &xip2_xattr_acl_access_handler);
+	if (error)
+		goto fail;
+	error = xip2_xattr_register(XIP2_XATTR_INDEX_POSIX_ACL_DEFAULT,
+				    &xip2_xattr_acl_default_handler);
+	if (error)
+		goto fail;
+	return 0;
+
+fail:
+	exit_xip2_acl();
+	return error;
+}
diff -ruN linux-2.6.5/fs/xip2fs/acl.h linux-2.6.5+xip/fs/xip2fs/acl.h
--- linux-2.6.5/fs/xip2fs/acl.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5+xip/fs/xip2fs/acl.h	2004-04-29 14:04:09.000000000 +0200
@@ -0,0 +1,64 @@
+/*
+ *  linux/fs/xip2fs/acl.h, Version 1
+ *
+ * (C) Copyright IBM Corp. 2002,2004
+ * Author(s): Carsten Otte <cotte@de.ibm.com>
+ *            Gerald Schaefer <geraldsc@de.ibm.com>
+ * derived from second extended filesystem (ext2)
+ */
+
+
+#include <linux/xattr_acl.h>
+
+#define XIP2_ACL_VERSION	0x0001
+#define XIP2_ACL_MAX_ENTRIES	32
+
+typedef struct {
+	__u16		e_tag;
+	__u16		e_perm;
+	__u32		e_id;
+} xip2_acl_entry;
+
+typedef struct {
+	__u16		e_tag;
+	__u16		e_perm;
+} xip2_acl_entry_short;
+
+typedef struct {
+	__u32		a_version;
+} xip2_acl_header;
+
+static inline int xip2_acl_count(size_t size)
+{
+	ssize_t s;
+	size -= sizeof(xip2_acl_header);
+	s = size - 4 * sizeof(xip2_acl_entry_short);
+	if (s < 0) {
+		if (size % sizeof(xip2_acl_entry_short))
+			return -1;
+		return size / sizeof(xip2_acl_entry_short);
+	} else {
+		if (s % sizeof(xip2_acl_entry))
+			return -1;
+		return s / sizeof(xip2_acl_entry) + 4;
+	}
+}
+
+#ifdef CONFIG_XIP2_FS_POSIX_ACL
+
+/* Value for inode->u.ext2_i.i_acl and inode->u.ext2_i.i_default_acl
+   if the ACL has not been cached */
+#define XIP2_ACL_NOT_CACHED ((void *)-1)
+
+/* acl.c */
+extern int xip2_permission (struct inode *, int, struct nameidata *);
+
+extern int init_xip2_acl(void);
+extern void exit_xip2_acl(void);
+
+#else
+#include <linux/sched.h>
+#define xip2_permission NULL
+#define xip2_get_acl	NULL
+#endif
+
diff -ruN linux-2.6.5/fs/xip2fs/balloc.c linux-2.6.5+xip/fs/xip2fs/balloc.c
--- linux-2.6.5/fs/xip2fs/balloc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5+xip/fs/xip2fs/balloc.c	2004-04-29 14:04:09.000000000 +0200
@@ -0,0 +1,268 @@
+/*
+ *  linux/fs/xip2fs/balloc.c, Version 1
+ *
+ * (C) Copyright IBM Corp. 2002,2004
+ * Author(s): Carsten Otte <cotte@de.ibm.com>
+ *            Gerald Schaefer <geraldsc@de.ibm.com>
+ * derived from second extended filesystem (ext2)
+ */
+
+#include <linux/config.h>
+#include "xip2.h"
+#include <linux/quotaops.h>
+#include <linux/sched.h>
+
+/*
+ * balloc.c contains the blocks allocation and deallocation routines
+ */
+
+/*
+ * The free blocks are managed by bitmaps.  A file system contains several
+ * blocks groups.  Each group contains 1 bitmap block for blocks, 1 bitmap
+ * block for inodes, N blocks for the inode table and data blocks.
+ *
+ * The file system contains group descriptors which are located after the
+ * super block.  Each descriptor contains the number of the bitmap block and
+ * the free blocks count in the block.  The descriptors are loaded in memory
+ * when a file system is mounted (see xip2_read_super).
+ */
+
+
+#define in_range(b, first, len)	((b) >= (first) && (b) <= (first) + (len) - 1)
+
+struct ext2_group_desc * xip2_get_group_desc(struct super_block * sb,
+					     unsigned int block_group,
+					     void ** block_ptr)
+{
+	unsigned long group_desc;
+	unsigned long offset;
+	struct ext2_group_desc * desc;
+	struct xip2_sb_info *sbi = XIP2_SB(sb);
+
+	if (block_group >= sbi->s_groups_count) {
+		xip2_error (sb, "xip2_get_group_desc",
+			    "block_group >= groups_count - "
+			    "block_group = %d, groups_count = %lu",
+			    block_group, sbi->s_groups_count);
+
+		return NULL;
+	}
+
+	group_desc = block_group / XIP2_DESC_PER_BLOCK(sb);
+	offset = block_group % XIP2_DESC_PER_BLOCK(sb);
+	if (!sbi->s_group_desc[group_desc]) {
+		xip2_error (sb, "xip2_get_group_desc",
+			    "Group descriptor not loaded - "
+			    "block_group = %d, group_desc = %lu, desc = %lu",
+			     block_group, group_desc, offset);
+		return NULL;
+	}
+
+	desc = (struct ext2_group_desc *) sbi->s_group_desc[group_desc];
+	if (block_ptr)
+		*block_ptr = sbi->s_group_desc[group_desc];
+	return desc + offset;
+}
+
+/*
+ * Read the bitmap for a given block_group, reading into the specified
+ * slot in the superblock's bitmap cache.
+ *
+ * Return buffer_head on success or NULL in case of failure.
+ */
+void *
+read_block_bitmap(struct super_block *sb, unsigned int block_group)
+{
+	struct ext2_group_desc * desc;
+	void *bitmap_data = NULL;
+
+	desc = xip2_get_group_desc (sb, block_group, NULL);
+	if (!desc)
+		goto error_out;
+	bitmap_data = xip2_sb_bread(sb, le32_to_cpu(desc->bg_block_bitmap));
+	if (!bitmap_data)
+		xip2_error (sb, "read_block_bitmap",
+			    "Cannot read block bitmap - "
+			    "block_group = %d, block_bitmap = %lu",
+			    block_group, (unsigned long) desc->bg_block_bitmap);
+error_out:
+	return bitmap_data;
+}
+
+
+unsigned long xip2_count_free_blocks (struct super_block * sb)
+{
+	struct ext2_group_desc * desc;
+	unsigned long desc_count = 0;
+	int i;
+#ifdef EXT2FS_DEBUG
+	unsigned long bitmap_count, x;
+	struct ext2_super_block *es;
+
+	lock_super (sb);
+	es = XIP2_SB(sb)->s_es;
+	desc_count = 0;
+	bitmap_count = 0;
+	desc = NULL;
+	for (i = 0; i < XIP2_SB(sb)->s_groups_count; i++) {
+		void *bitmap_data;
+		desc = xip2_get_group_desc (sb, i, NULL);
+		if (!desc)
+			continue;
+		desc_count += le16_to_cpu(desc->bg_free_blocks_count);
+		bitmap_data = read_block_bitmap(sb, i);
+		if (!bitmap_data)
+			continue;
+
+		x = xip2_count_free(bitmap_data, sb->s_blocksize);
+		printk ("group %d: stored = %d, counted = %lu\n",
+			i, le16_to_cpu(desc->bg_free_blocks_count), x);
+		bitmap_count += x;
+	}
+	printk("xip2_count_free_blocks: stored = %lu, computed = %lu, %lu\n",
+		(long)le32_to_cpu(es->s_free_blocks_count),
+		desc_count, bitmap_count);
+	unlock_super (sb);
+	return bitmap_count;
+#else
+	for (i = 0; i < XIP2_SB(sb)->s_groups_count; i++) {
+		desc = xip2_get_group_desc (sb, i, NULL);
+		if (!desc)
+			continue;
+		desc_count += le16_to_cpu(desc->bg_free_blocks_count);
+	}
+	return desc_count;
+#endif
+}
+
+static inline int
+block_in_use(unsigned long block, struct super_block *sb, unsigned char *map)
+{
+	return xip2_test_bit((block -
+			le32_to_cpu(XIP2_SB(sb)->s_es->s_first_data_block)) %
+			XIP2_BLOCKS_PER_GROUP(sb), map);
+}
+
+static inline int test_root(int a, int b)
+{
+	if (a == 0)
+		return 1;
+	while (1) {
+		if (a == 1)
+			return 1;
+		if (a % b)
+			return 0;
+		a = a / b;
+	}
+}
+
+static int xip2_group_sparse(int group)
+{
+	return (test_root(group, 3) || test_root(group, 5) ||
+		test_root(group, 7));
+}
+
+/**
+ *	xip2_bg_has_super - number of blocks used by the superblock in group
+ *	@sb: superblock for filesystem
+ *	@group: group number to check
+ *
+ *	Return the number of blocks used by the superblock (primary or backup)
+ *	in this group.  Currently this will be only 0 or 1.
+ */
+int xip2_bg_has_super(struct super_block *sb, int group)
+{
+	if (XIP2_HAS_RO_COMPAT_FEATURE(sb,EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER)&&
+	    !xip2_group_sparse(group))
+		return 0;
+	return 1;
+}
+
+/**
+ *	xip2_bg_num_gdb - number of blocks used by the group table in group
+ *	@sb: superblock for filesystem
+ *	@group: group number to check
+ *
+ *	Return the number of blocks used by the group descriptor table
+ *	(primary or backup) in this group.  In the future there may be a
+ *	different number of descriptor blocks in each group.
+ */
+unsigned long xip2_bg_num_gdb(struct super_block *sb, int group)
+{
+	if (XIP2_HAS_RO_COMPAT_FEATURE(sb,EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER)&&
+	    !xip2_group_sparse(group))
+		return 0;
+	return XIP2_SB(sb)->s_gdb_count;
+}
+
+#ifdef CONFIG_XIP2_CHECK
+/* Called at mount-time, super-block is locked */
+void xip2_check_blocks_bitmap (struct super_block * sb)
+{
+	void *bitmap_data = NULL;
+	struct ext2_super_block * es;
+	unsigned long desc_count, bitmap_count, x, j;
+	unsigned long desc_blocks;
+	struct ext2_group_desc * desc;
+	int i;
+
+	es = XIP2_SB(sb)->s_es;
+	desc_count = 0;
+	bitmap_count = 0;
+	desc = NULL;
+	for (i = 0; i < XIP2_SB(sb)->s_groups_count; i++) {
+		desc = xip2_get_group_desc (sb, i, NULL);
+		if (!desc)
+			continue;
+		desc_count += le16_to_cpu(desc->bg_free_blocks_count);
+		bitmap_data = read_block_bitmap(sb, i);
+		if (!bitmap_data)
+			continue;
+
+		if (xip2_bg_has_super(sb, i) &&
+				!xip2_test_bit(0, bitmap_data))
+			xip2_error(sb, __FUNCTION__,
+				   "Superblock in group %d is marked free", i);
+
+		desc_blocks = xip2_bg_num_gdb(sb, i);
+		for (j = 0; j < desc_blocks; j++)
+			if (!xip2_test_bit(j + 1, bitmap_data))
+				xip2_error(sb, __FUNCTION__,
+					   "Descriptor block #%ld in group "
+					   "%d is marked free", j, i);
+
+		if (!block_in_use(le32_to_cpu(desc->bg_block_bitmap),
+					sb, bitmap_data))
+			xip2_error(sb, "xip2_check_blocks_bitmap",
+				    "Block bitmap for group %d is marked free",
+				    i);
+
+		if (!block_in_use(le32_to_cpu(desc->bg_inode_bitmap),
+					sb, bitmap_data))
+			xip2_error(sb, "xip2_check_blocks_bitmap",
+				    "Inode bitmap for group %d is marked free",
+				    i);
+
+		for (j = 0; j < XIP2_SB(sb)->s_itb_per_group; j++)
+			if (!block_in_use(le32_to_cpu(desc->bg_inode_table) + j,
+						sb, bitmap_data))
+				xip2_error (sb, "xip2_check_blocks_bitmap",
+					    "Block #%ld of the inode table in "
+					    "group %d is marked free", j, i);
+
+		x = xip2_count_free(bitmap_data, sb->s_blocksize);
+		if (le16_to_cpu(desc->bg_free_blocks_count) != x)
+			xip2_error (sb, "xip2_check_blocks_bitmap",
+				    "Wrong free blocks count for group %d, "
+				    "stored = %d, counted = %lu", i,
+				    le16_to_cpu(desc->bg_free_blocks_count), x);
+		bitmap_count += x;
+	}
+	if (le32_to_cpu(es->s_free_blocks_count) != bitmap_count)
+		xip2_error (sb, "xip2_check_blocks_bitmap",
+			"Wrong free blocks count in super block, "
+			"stored = %lu, counted = %lu",
+			(unsigned long)le32_to_cpu(es->s_free_blocks_count),
+			bitmap_count);
+}
+#endif
diff -ruN linux-2.6.5/fs/xip2fs/bitmap.c linux-2.6.5+xip/fs/xip2fs/bitmap.c
--- linux-2.6.5/fs/xip2fs/bitmap.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5+xip/fs/xip2fs/bitmap.c	2004-04-29 14:04:09.000000000 +0200
@@ -0,0 +1,24 @@
+/*
+ *  linux/fs/xip2fs/bitmap.c, Version 1
+ *
+ * (C) Copyright IBM Corp. 2002,2004
+ * Author(s): Carsten Otte <cotte@de.ibm.com>
+ *            Gerald Schaefer <geraldsc@de.ibm.com>
+ * derived from second extended filesystem (ext2)
+ */
+
+
+static int nibblemap[] = {4, 3, 3, 2, 3, 2, 2, 1, 3, 2, 2, 1, 2, 1, 1, 0};
+
+unsigned long xip2_count_free (char* map, unsigned int numchars)
+{
+	unsigned int i;
+	unsigned long sum = 0;
+
+	if (!map)
+		return (0);
+	for (i = 0; i < numchars; i++)
+		sum += nibblemap[map[i] & 0xf] +
+			nibblemap[(map[i] >> 4) & 0xf];
+	return (sum);
+}
diff -ruN linux-2.6.5/fs/xip2fs/dir.c linux-2.6.5+xip/fs/xip2fs/dir.c
--- linux-2.6.5/fs/xip2fs/dir.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5+xip/fs/xip2fs/dir.c	2004-04-29 14:04:09.000000000 +0200
@@ -0,0 +1,324 @@
+/*
+ *  linux/fs/xip2fs/dir.c, Version 1
+ *
+ * (C) Copyright IBM Corp. 2002,2004
+ * Author(s): Carsten Otte <cotte@de.ibm.com>
+ *            Gerald Schaefer <geraldsc@de.ibm.com>
+ * derived from second extended filesystem (ext2)
+ */
+
+#include "xip2.h"
+#include <linux/pagemap.h>
+#include <linux/smp_lock.h>
+
+typedef struct ext2_dir_entry_2 ext2_dirent;
+
+/*
+ * ext2 uses block-sized chunks. Arguably, sector-sized ones would be
+ * more robust, but we have what we have
+ */
+static inline unsigned xip2_chunk_size(struct inode *inode)
+{
+	return inode->i_sb->s_blocksize;
+}
+
+static inline unsigned long dir_pages(struct inode *inode)
+{
+	return (inode->i_size+PAGE_CACHE_SIZE-1)>>PAGE_CACHE_SHIFT;
+}
+
+/*
+ * Return the offset into page `page_nr' of the last valid
+ * byte in that page, plus one.
+ */
+static unsigned
+xip2_last_byte(struct inode *inode, unsigned long page_nr)
+{
+	unsigned last_byte = inode->i_size;
+
+	last_byte -= page_nr << PAGE_CACHE_SHIFT;
+	if (last_byte > PAGE_CACHE_SIZE)
+		last_byte = PAGE_CACHE_SIZE;
+	return last_byte;
+}
+
+static int xip2_check_page(struct inode* dir, void *kaddr)
+{
+	struct super_block *sb = dir->i_sb;
+	unsigned chunk_size = xip2_chunk_size(dir);
+	u32 max_inumber = le32_to_cpu(XIP2_SB(sb)->s_es->s_inodes_count);
+	unsigned offs, rec_len;
+	unsigned limit = PAGE_CACHE_SIZE;
+	ext2_dirent *p;
+	char *error;
+
+	for (offs = 0; offs <= limit - EXT2_DIR_REC_LEN(1); offs += rec_len) {
+		p = (ext2_dirent *)(kaddr + offs);
+		rec_len = le16_to_cpu(p->rec_len);
+
+		if (rec_len < EXT2_DIR_REC_LEN(1))
+			goto Eshort;
+		if (rec_len & 3)
+			goto Ealign;
+		if (rec_len < EXT2_DIR_REC_LEN(p->name_len))
+			goto Enamelen;
+		if (((offs + rec_len - 1) ^ offs) & ~(chunk_size-1))
+			goto Espan;
+		if (le32_to_cpu(p->inode) > max_inumber)
+			goto Einumber;
+	}
+	if (offs != limit)
+		goto Eend;
+	return 0;
+
+	/* Too bad, we had an error */
+Eshort:
+	error = "rec_len is smaller than minimal";
+	goto bad_entry;
+Ealign:
+	error = "unaligned directory entry";
+	goto bad_entry;
+Enamelen:
+	error = "rec_len is too small for name_len";
+	goto bad_entry;
+Espan:
+	error = "directory entry across blocks";
+	goto bad_entry;
+Einumber:
+	error = "inode out of bounds";
+bad_entry:
+	xip2_error (sb, "xip2_check_page", "bad entry in directory #%lu: %s - "
+		"ptr=%p, inode=%lu, rec_len=%d, name_len=%d",
+		dir->i_ino, error, kaddr+offs,
+		(unsigned long) le32_to_cpu(p->inode),
+		rec_len, p->name_len);
+	goto fail;
+Eend:
+	p = (ext2_dirent *)(kaddr + offs);
+	xip2_error (sb, "xip2_check_page",
+		"entry in directory #%lu spans the page boundary"
+		"ptr=%p, inode=%lu",
+		dir->i_ino, kaddr+offs,
+		(unsigned long) le32_to_cpu(p->inode));
+fail:
+	return -EINVAL;
+}
+
+static void* xip2_dir_bread (struct inode *dir, unsigned long n)
+{
+	sector_t blockno;
+	void *result;
+	int rc;
+	rc = xip2_get_block (dir, n, &blockno, 0);
+	if (rc)
+		return NULL;
+	result = xip2_sb_bread (dir->i_sb, blockno);
+	if (xip2_check_page (dir, result))
+		return NULL;
+	return result;
+}
+
+/*
+ * NOTE! unlike strncmp, xip2_match returns 1 for success, 0 for failure.
+ *
+ * len <= EXT2_NAME_LEN and de != NULL are guaranteed by caller.
+ */
+static inline int xip2_match (int len, const char * const name,
+					struct ext2_dir_entry_2 * de)
+{
+	if (len != de->name_len)
+		return 0;
+	if (!de->inode)
+		return 0;
+	return !memcmp(name, de->name, len);
+}
+
+/*
+ * p is at least 6 bytes before the end of page
+ */
+static inline ext2_dirent *xip2_next_entry(ext2_dirent *p)
+{
+	return (ext2_dirent *)((char*)p + le16_to_cpu(p->rec_len));
+}
+
+static inline unsigned
+xip2_validate_entry(char *base, unsigned offset, unsigned mask)
+{
+	ext2_dirent *de = (ext2_dirent*)(base + offset);
+	ext2_dirent *p = (ext2_dirent*)(base + (offset&mask));
+	while ((char*)p < (char*)de) {
+		if (p->rec_len == 0)
+			break;
+		p = xip2_next_entry(p);
+	}
+	return (char *)p - base;
+}
+
+static unsigned char xip2_filetype_table[EXT2_FT_MAX] = {
+	[EXT2_FT_UNKNOWN]	= DT_UNKNOWN,
+	[EXT2_FT_REG_FILE]	= DT_REG,
+	[EXT2_FT_DIR]		= DT_DIR,
+	[EXT2_FT_CHRDEV]	= DT_CHR,
+	[EXT2_FT_BLKDEV]	= DT_BLK,
+	[EXT2_FT_FIFO]		= DT_FIFO,
+	[EXT2_FT_SOCK]		= DT_SOCK,
+	[EXT2_FT_SYMLINK]	= DT_LNK,
+};
+
+#define S_SHIFT 12
+static unsigned char xip2_type_by_mode[S_IFMT >> S_SHIFT] = {
+	[S_IFREG >> S_SHIFT]	= EXT2_FT_REG_FILE,
+	[S_IFDIR >> S_SHIFT]	= EXT2_FT_DIR,
+	[S_IFCHR >> S_SHIFT]	= EXT2_FT_CHRDEV,
+	[S_IFBLK >> S_SHIFT]	= EXT2_FT_BLKDEV,
+	[S_IFIFO >> S_SHIFT]	= EXT2_FT_FIFO,
+	[S_IFSOCK >> S_SHIFT]	= EXT2_FT_SOCK,
+	[S_IFLNK >> S_SHIFT]	= EXT2_FT_SYMLINK,
+};
+
+static inline void xip2_set_de_type(ext2_dirent *de, struct inode *inode)
+{
+	mode_t mode = inode->i_mode;
+	if (XIP2_HAS_INCOMPAT_FEATURE(inode->i_sb,
+				      EXT2_FEATURE_INCOMPAT_FILETYPE))
+		de->file_type = xip2_type_by_mode[(mode & S_IFMT)>>S_SHIFT];
+	else
+		de->file_type = 0;
+}
+
+static int
+xip2_readdir (struct file * filp, void * dirent, filldir_t filldir)
+{
+	loff_t pos = filp->f_pos;
+	struct inode *inode = filp->f_dentry->d_inode;
+	struct super_block *sb = inode->i_sb;
+	unsigned offset = pos & ~PAGE_CACHE_MASK;
+	unsigned long n = pos >> PAGE_CACHE_SHIFT;
+	unsigned long npages = dir_pages(inode);
+	unsigned chunk_mask = ~(xip2_chunk_size(inode)-1);
+	unsigned char *types = NULL;
+	int need_revalidate = (filp->f_version != inode->i_version);
+	int ret = 0;
+
+	if (pos > inode->i_size - EXT2_DIR_REC_LEN(1))
+		goto done;
+
+	if (XIP2_HAS_INCOMPAT_FEATURE(sb, EXT2_FEATURE_INCOMPAT_FILETYPE))
+		types = xip2_filetype_table;
+
+	for ( ; n < npages; n++, offset = 0) {
+		char *kaddr, *limit;
+		ext2_dirent *de;
+		kaddr = xip2_dir_bread (inode,n);
+
+		if (kaddr == NULL)
+			continue;
+		if (need_revalidate) {
+			offset = xip2_validate_entry(kaddr, offset, chunk_mask);
+			need_revalidate = 0;
+		}
+		de = (ext2_dirent *)(kaddr+offset);
+		limit = kaddr + xip2_last_byte(inode, n) - EXT2_DIR_REC_LEN(1);
+		for ( ;(char*)de <= limit; de = xip2_next_entry(de)) {
+			if (de->rec_len == 0) {
+				xip2_error(sb, __FUNCTION__,
+					"zero-length directory entry");
+				ret = -EIO;
+				goto done;
+			}
+			if (de->inode) {
+				int over;
+				unsigned char d_type = DT_UNKNOWN;
+
+				if (types && de->file_type < EXT2_FT_MAX)
+					d_type = types[de->file_type];
+
+				offset = (char *)de - kaddr;
+				over = filldir(dirent, de->name, de->name_len,
+						(n<<PAGE_CACHE_SHIFT) | offset,
+						le32_to_cpu(de->inode), d_type);
+				if (over) {
+					goto done;
+				}
+			}
+		}
+	}
+
+done:
+	filp->f_pos = (n << PAGE_CACHE_SHIFT) | offset;
+	filp->f_version = inode->i_version;
+	return 0;
+}
+
+/*
+ *	xip2_find_entry()
+ *
+ * finds an entry in the specified directory with the wanted name. It
+ * returns the page in which the entry was found, and the entry itself
+ * (as a parameter - res_dir). Page is returned mapped and unlocked.
+ * Entry is guaranteed to be valid.
+ */
+static struct ext2_dir_entry_2 * xip2_find_entry (struct inode * dir,
+			struct dentry *dentry)
+{
+	const char *name = dentry->d_name.name;
+	int namelen = dentry->d_name.len;
+	unsigned reclen = EXT2_DIR_REC_LEN(namelen);
+	unsigned long start, n;
+	unsigned long npages = dir_pages(dir);
+	struct xip2_inode_info *ei = XIP2_I(dir);
+	ext2_dirent * de;
+
+	if (npages == 0)
+		goto out;
+
+	start = ei->i_dir_start_lookup;
+	if (start >= npages)
+		start = 0;
+	n = start;
+	do {
+		char *kaddr;
+		kaddr = xip2_dir_bread(dir, n);
+		if (kaddr != NULL) {
+			de = (ext2_dirent *) kaddr;
+			kaddr += xip2_last_byte(dir, n) - reclen;
+			while ((char *) de <= kaddr) {
+				if (de->rec_len == 0) {
+					xip2_error(dir->i_sb, __FUNCTION__,
+						"zero-length directory entry");
+					goto out;
+				}
+				if (xip2_match (namelen, name, de))
+					goto found;
+				de = xip2_next_entry(de);
+			}
+		}
+		if (++n >= npages)
+			n = 0;
+	} while (n != start);
+out:
+	return NULL;
+
+found:
+	ei->i_dir_start_lookup = n;
+	return de;
+}
+
+ino_t xip2_inode_by_name(struct inode * dir, struct dentry *dentry)
+{
+	ino_t res = 0;
+	struct ext2_dir_entry_2 * de;
+
+	de = xip2_find_entry (dir, dentry);
+	if (de) {
+		res = le32_to_cpu(de->inode);
+	}
+	return res;
+}
+
+struct file_operations xip2_dir_operations = {
+	.llseek		= generic_file_llseek,
+	.read		= generic_read_dir,
+	.readdir	= xip2_readdir,
+	.ioctl		= xip2_ioctl,
+};
diff -ruN linux-2.6.5/fs/xip2fs/file.c linux-2.6.5+xip/fs/xip2fs/file.c
--- linux-2.6.5/fs/xip2fs/file.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5+xip/fs/xip2fs/file.c	2004-04-29 14:04:09.000000000 +0200
@@ -0,0 +1,330 @@
+/*
+ *  linux/fs/xip2fs/file.c, Version 1
+ *
+ * (C) Copyright IBM Corp. 2002,2004
+ * Author(s): Carsten Otte <cotte@de.ibm.com>
+ *            Gerald Schaefer <geraldsc@de.ibm.com>
+ * derived from second extended filesystem (ext2)
+ */
+
+
+#include <linux/time.h>
+#include "xip2.h"
+#include "xattr.h"
+#include "acl.h"
+#include <asm/pgtable.h>
+#include <asm/uaccess.h>
+#include <linux/uio.h>
+#include <linux/mm.h>
+#include <linux/pagemap.h>
+
+void xip2_do_file_read(struct file *filp, loff_t *ppos, read_descriptor_t *desc)
+{
+	struct address_space *mapping = filp->f_mapping;
+	struct inode *inode = mapping->host;
+	sector_t blockno;
+	unsigned long block,offset,rdlen,count, iblock, lblock;
+	void* block_ptr,* cpystart;
+	int error,cpycount;
+
+	if  (*ppos > inode->i_size)
+		return;
+	iblock = (*ppos)/PAGE_SIZE;
+	offset = (*ppos)%PAGE_SIZE;
+	rdlen = desc->count;
+	if ((*ppos)+desc->count > inode->i_size)
+		rdlen = inode->i_size - (*ppos);
+	lblock = (*ppos + rdlen) / PAGE_SIZE;
+	count = 0;
+	for (block = iblock; block <= lblock; block++) {
+		error=xip2_get_block(inode, block, &blockno, 0);
+		if (error) {
+			desc->error = error;
+			desc->written = count;
+			return;
+		}
+		block_ptr = xip2_sb_bread (inode->i_sb, blockno);
+		if (block_ptr) {
+			if (block == iblock) {
+				cpystart = block_ptr + offset;
+				cpycount = PAGE_SIZE - offset;
+			} else {
+				cpystart = block_ptr;
+				cpycount = PAGE_SIZE;
+			}
+		} else {
+			// there is no block assigned, copy zeros over
+			if (block == iblock) {
+				cpystart = empty_zero_page;
+				cpycount = PAGE_SIZE - offset;
+			} else {
+				cpystart = empty_zero_page;
+				cpycount = PAGE_SIZE;
+			}
+		}
+		if (cpycount > rdlen-count) {
+			cpycount = rdlen-count;
+			if (block!=lblock) BUG();
+		}
+		if (copy_to_user(desc->buf+count, cpystart, cpycount)) {
+			desc->error = -EFAULT;
+			desc->written = count;
+			return;
+		}
+		count += cpycount;
+	}
+	if (rdlen-count>0) BUG();
+	desc->error = 0;
+	desc->written = count;
+	*ppos+=count;
+	return;
+}
+
+
+ssize_t
+__xip2_file_aio_read(struct kiocb *iocb, const struct iovec *iov,
+		unsigned long nr_segs, loff_t *ppos)
+{
+	struct file *filp = iocb->ki_filp;
+	ssize_t retval;
+	unsigned long seg;
+	size_t count;
+
+	count = 0;
+	for (seg = 0; seg < nr_segs; seg++) {
+		const struct iovec *iv = &iov[seg];
+
+		/*
+		 * If any segment has a negative length, or the cumulative
+		 * length ever wraps negative then return -EINVAL.
+		 */
+		count += iv->iov_len;
+		if (unlikely((ssize_t)(count|iv->iov_len) < 0))
+			return -EINVAL;
+		if (access_ok(VERIFY_WRITE, iv->iov_base, iv->iov_len))
+			continue;
+		if (seg == 0)
+			return -EFAULT;
+		nr_segs = seg;
+		count -= iv->iov_len;	/* This segment is no good */
+		break;
+	}
+
+	retval = 0;
+	if (count) {
+		for (seg = 0; seg < nr_segs; seg++) {
+			read_descriptor_t desc;
+
+			desc.written = 0;
+			desc.buf = iov[seg].iov_base;
+			desc.count = iov[seg].iov_len;
+			if (desc.count == 0)
+				continue;
+			desc.error = 0;
+			xip2_do_file_read(filp,ppos,&desc);
+			retval += desc.written;
+			if (!retval) {
+				retval = desc.error;
+				break;
+			}
+		}
+	}
+	return retval;
+}
+
+ssize_t
+xip2_file_read(struct file *filp, char __user *buf, size_t count, loff_t *ppos)
+{
+	struct iovec local_iov = { .iov_base = buf, .iov_len = count };
+	struct kiocb kiocb;
+	ssize_t ret;
+
+	init_sync_kiocb(&kiocb, filp);
+	ret = __xip2_file_aio_read(&kiocb, &local_iov, 1, ppos);
+	if (-EIOCBQUEUED == ret)
+		ret = wait_on_sync_kiocb(&kiocb);
+	return ret;
+}
+
+
+ssize_t
+xip2_file_aio_read(struct kiocb *iocb, char __user *buf, size_t count,
+		   loff_t pos)
+{
+	struct iovec local_iov = { .iov_base = buf, .iov_len = count };
+
+	BUG_ON(iocb->ki_pos != pos);
+	return __xip2_file_aio_read(iocb, &local_iov, 1, &iocb->ki_pos);
+}
+
+ssize_t xip2_file_readv(struct file *filp, const struct iovec *iov,
+			unsigned long nr_segs, loff_t *ppos)
+{
+	struct kiocb kiocb;
+	ssize_t ret;
+
+	init_sync_kiocb(&kiocb, filp);
+	ret = __xip2_file_aio_read(&kiocb, iov, nr_segs, ppos);
+	if (-EIOCBQUEUED == ret)
+		ret = wait_on_sync_kiocb(&kiocb);
+	return ret;
+}
+
+struct page * xip2_nopage_in_place(struct vm_area_struct * area,
+				   unsigned long address, int* type)
+{
+	int error;
+#ifdef CONFIG_LBD
+	sector_t blockno = ~0ULL;
+#else
+	sector_t blockno = ~0UL;
+#endif
+	void* block_ptr;
+	struct file *file = area->vm_file;
+	struct address_space *mapping = file->f_mapping;
+	struct inode *inode = mapping->host;
+	unsigned long pgoff;
+
+	pgoff = ((address - area->vm_start) >> PAGE_CACHE_SHIFT) +
+		area->vm_pgoff;
+	error=xip2_get_block(inode, pgoff, &blockno, 0);
+	if (error) {
+		printk ("XIP2-FS: xip2_nopage_in_place could not fullfill "
+			"page request\n");
+		return NULL;
+	}
+	block_ptr = xip2_sb_bread(inode->i_sb, blockno);
+	if (!block_ptr)
+		return virt_to_page(empty_zero_page);
+	return virt_to_page(block_ptr);
+}
+
+static struct vm_operations_struct xip2_file_vm_ops = {
+	.nopage		= xip2_nopage_in_place,
+//	.populate	= filemap_populate,
+};
+
+
+int xip2_file_mmap(struct file * file, struct vm_area_struct * vma)
+{
+	struct address_space *mapping = file->f_mapping;
+
+	if (!mapping->a_ops->readpage)
+		return -ENOEXEC;
+	file_accessed(file);
+	vma->vm_ops = &xip2_file_vm_ops;
+	return 0;
+}
+
+void xip2_do_file_sendfile(struct file *filp, loff_t *ppos,
+			   read_descriptor_t *desc, read_actor_t actor)
+{
+	struct address_space *mapping = filp->f_mapping;
+	struct inode *inode = mapping->host;
+	sector_t blockno;
+	unsigned long block,offset,rdlen,count, iblock, lblock;
+	void* block_ptr;
+	struct page *cpypage;
+	int error,cpycount,cpyoffset,copied;
+	unsigned long actor_ret;
+
+	if  (*ppos > inode->i_size)
+		return;
+	iblock = (*ppos)/PAGE_SIZE;
+	offset = (*ppos)%PAGE_SIZE;
+	rdlen = desc->count;
+	if ((*ppos)+desc->count > inode->i_size)
+		rdlen = inode->i_size - (*ppos);
+	lblock = (*ppos + rdlen) / PAGE_SIZE;
+	count = 0;
+	for (block = iblock; block <= lblock; block++) {
+		error=xip2_get_block(inode, block, &blockno, 0);
+		if (error) {
+			desc->error = error;
+			desc->written = count;
+			return;
+		}
+		block_ptr = xip2_sb_bread (inode->i_sb, blockno);
+		if (block_ptr) {
+			if (block == iblock) {
+				cpypage  = virt_to_page (block_ptr);
+				cpyoffset= offset;
+				cpycount = PAGE_SIZE - offset;
+			} else {
+				cpypage  = virt_to_page (block_ptr);
+				cpyoffset= 0;
+				cpycount = PAGE_SIZE;
+			}
+		} else {
+			// there is no block assigned, copy zeros over
+			if (block == iblock) {
+				cpypage  = virt_to_page (empty_zero_page);
+				cpyoffset= 0;
+				cpycount = PAGE_SIZE - offset;
+			} else {
+				cpypage  = virt_to_page (empty_zero_page);
+				cpyoffset= 0;
+				cpycount = PAGE_SIZE;
+			}
+		}
+		if (cpycount > rdlen-count) {
+			cpycount = rdlen-count;
+			if (block!=lblock) BUG();
+		}
+		copied = 0;
+		while (copied < cpycount) {
+			actor_ret = actor(desc, cpypage, cpyoffset+copied,
+					  cpycount-copied);
+			if (desc->error)
+				return;
+			copied += actor_ret;
+		}
+		count += cpycount;
+	}
+	if (rdlen-count>0) BUG();
+	desc->error = 0;
+	desc->written = count;
+	*ppos+=count;
+	return;
+}
+
+
+ssize_t xip2_file_sendfile(struct file *in_file, loff_t *ppos,
+			 size_t count, read_actor_t actor, void __user *target)
+{
+	read_descriptor_t desc;
+
+	if (!count)
+		return 0;
+
+	desc.written = 0;
+	desc.count = count;
+	desc.buf = target;
+	desc.error = 0;
+
+	xip2_do_file_sendfile(in_file, ppos, &desc, actor);
+	if (desc.written)
+		return desc.written;
+	return desc.error;
+}
+
+/*
+ * We have mostly NULL's here: the current defaults are ok for
+ * the ext2 filesystem.
+ */
+struct file_operations xip2_file_operations = {
+	.llseek		= generic_file_llseek,
+	.read		= xip2_file_read,
+	.aio_read	= xip2_file_aio_read,
+	.ioctl		= xip2_ioctl,
+	.mmap		= xip2_file_mmap,
+	.open		= generic_file_open,
+	.readv		= xip2_file_readv,
+	.sendfile	= xip2_file_sendfile,
+};
+
+struct inode_operations xip2_file_inode_operations = {
+	.getxattr	= xip2_getxattr,
+	.listxattr	= xip2_listxattr,
+	.permission	= xip2_permission,
+};
diff -ruN linux-2.6.5/fs/xip2fs/ialloc.c linux-2.6.5+xip/fs/xip2fs/ialloc.c
--- linux-2.6.5/fs/xip2fs/ialloc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5+xip/fs/xip2fs/ialloc.c	2004-04-29 14:04:09.000000000 +0200
@@ -0,0 +1,174 @@
+/*
+ *  linux/fs/xip2fs/ialloc.c, Version 1
+ *
+ * (C) Copyright IBM Corp. 2002,2004
+ * Author(s): Carsten Otte <cotte@de.ibm.com>
+ *            Gerald Schaefer <geraldsc@de.ibm.com>
+ * derived from second extended filesystem (ext2)
+ */
+
+
+#include <linux/config.h>
+#include <linux/quotaops.h>
+#include <linux/sched.h>
+#include <linux/backing-dev.h>
+#include <linux/random.h>
+#include "xip2.h"
+#include "xattr.h"
+#include "acl.h"
+
+/*
+ * ialloc.c contains the inodes allocation and deallocation routines
+ */
+
+/*
+ * Orlov's allocator for directories.
+ *
+ * We always try to spread first-level directories.
+ *
+ * If there are blockgroups with both free inodes and free blocks counts
+ * not worse than average we return one with smallest directory count.
+ * Otherwise we simply return a random group.
+ *
+ * For the rest rules look so:
+ *
+ * It's OK to put directory into a group unless
+ * it has too many directories already (max_dirs) or
+ * it has too few free inodes left (min_inodes) or
+ * it has too few free blocks left (min_blocks) or
+ * it's already running too large debt (max_debt).
+ * Parent's group is prefered, if it doesn't satisfy these
+ * conditions we search cyclically through the rest. If none
+ * of the groups look good we just look for a group with more
+ * free inodes than average (starting at parent's group).
+ *
+ * Debt is incremented each time we allocate a directory and decremented
+ * when we allocate an inode, within 0--255.
+ */
+
+#ifdef EXT2FS_DEBUG
+/*
+ * Read the inode allocation bitmap for a given block_group, reading
+ * into the specified slot in the superblock's bitmap cache.
+ *
+ * Return buffer_head of bitmap on success or NULL.
+ */
+static void *
+read_inode_bitmap(struct super_block * sb, unsigned long block_group)
+{
+	struct ext2_group_desc *desc;
+	void *bitmap_data = NULL;
+
+	desc = xip2_get_group_desc(sb, block_group, NULL);
+	if (!desc)
+		goto error_out;
+
+	bitmap_data = xip2_sb_bread(sb, le32_to_cpu(desc->bg_inode_bitmap));
+	if (!bitmap_data)
+		xip2_error(sb, "read_inode_bitmap",
+			    "Cannot read inode bitmap - "
+			    "block_group = %lu, inode_bitmap = %lu",
+			    block_group, (unsigned long) desc->bg_inode_bitmap);
+error_out:
+	return bitmap_data;
+}
+#endif
+
+unsigned long xip2_count_free_inodes (struct super_block * sb)
+{
+	struct ext2_group_desc *desc;
+	unsigned long desc_count = 0;
+	int i;
+
+#ifdef EXT2FS_DEBUG
+	struct ext2_super_block *es;
+	unsigned long bitmap_count = 0;
+	void *bitmap_data = NULL;
+
+	lock_super (sb);
+	es = XIP2_SB(sb)->s_es;
+	for (i = 0; i < XIP2_SB(sb)->s_groups_count; i++) {
+		unsigned x;
+
+		desc = xip2_get_group_desc (sb, i, NULL);
+		if (!desc)
+			continue;
+		desc_count += le16_to_cpu(desc->bg_free_inodes_count);
+		bitmap_data = read_inode_bitmap(sb, i);
+		if (!bitmap_data)
+			continue;
+
+		x = xip2_count_free(bitmap_data, XIP2_INODES_PER_GROUP(sb) / 8);
+		printk("group %d: stored = %d, counted = %u\n",
+			i, le16_to_cpu(desc->bg_free_inodes_count), x);
+		bitmap_count += x;
+	}
+	printk("xip2_count_free_inodes: stored = %lu, computed = %lu, %lu\n",
+		percpu_counter_read(XIP2_SB(sb)->s_freeinodes_counter),
+		desc_count, bitmap_count);
+	unlock_super(sb);
+	return desc_count;
+#else
+	for (i = 0; i < XIP2_SB(sb)->s_groups_count; i++) {
+		desc = xip2_get_group_desc (sb, i, NULL);
+		if (!desc)
+			continue;
+		desc_count += le16_to_cpu(desc->bg_free_inodes_count);
+	}
+	return desc_count;
+#endif
+}
+
+/* Called at mount-time, super-block is locked */
+unsigned long xip2_count_dirs (struct super_block * sb)
+{
+	unsigned long count = 0;
+	int i;
+
+	for (i = 0; i < XIP2_SB(sb)->s_groups_count; i++) {
+		struct ext2_group_desc *gdp = xip2_get_group_desc (sb, i, NULL);
+		if (!gdp)
+			continue;
+		count += le16_to_cpu(gdp->bg_used_dirs_count);
+	}
+	return count;
+}
+
+#ifdef CONFIG_XIP2_CHECK
+/* Called at mount-time, super-block is locked */
+void xip2_check_inodes_bitmap (struct super_block * sb)
+{
+	struct ext2_super_block * es = XIP2_SB(sb)->s_es;
+	unsigned long desc_count = 0, bitmap_count = 0;
+	void *bitmap_data = NULL;
+	int i;
+
+	for (i = 0; i < XIP2_SB(sb)->s_groups_count; i++) {
+		struct ext2_group_desc *desc;
+		unsigned x;
+
+		desc = xip2_get_group_desc(sb, i, NULL);
+		if (!desc)
+			continue;
+		desc_count += le16_to_cpu(desc->bg_free_inodes_count);
+		bitmap_data = read_inode_bitmap(sb, i);
+		if (!bitmap_data)
+			continue;
+
+		x = xip2_count_free(bitmap_data, XIP2_INODES_PER_GROUP(sb) / 8);
+		if (le16_to_cpu(desc->bg_free_inodes_count) != x)
+			xip2_error (sb, "xip2_check_inodes_bitmap",
+				    "Wrong free inodes count in group %d, "
+				    "stored = %d, counted = %lu", i,
+				    le16_to_cpu(desc->bg_free_inodes_count), x);
+		bitmap_count += x;
+	}
+	if (percpu_counter_read(XIP2_SB(sb)->s_freeinodes_counter) !=
+				bitmap_count)
+		xip2_error(sb, "xip2_check_inodes_bitmap",
+			    "Wrong free inodes count in super block, "
+			    "stored = %lu, counted = %lu",
+			    (unsigned long)le32_to_cpu(es->s_free_inodes_count),
+			    bitmap_count);
+}
+#endif
diff -ruN linux-2.6.5/fs/xip2fs/inode.c linux-2.6.5+xip/fs/xip2fs/inode.c
--- linux-2.6.5/fs/xip2fs/inode.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5+xip/fs/xip2fs/inode.c	2004-04-29 14:04:09.000000000 +0200
@@ -0,0 +1,516 @@
+/*
+ *  linux/fs/xip2fs/inode.c, Version 1
+ *
+ * (C) Copyright IBM Corp. 2002,2004
+ * Author(s): Carsten Otte <cotte@de.ibm.com>
+ *            Gerald Schaefer <geraldsc@de.ibm.com>
+ * derived from second extended filesystem (ext2)
+ */
+
+
+#include <linux/smp_lock.h>
+#include <linux/time.h>
+#include <linux/highuid.h>
+#include <linux/pagemap.h>
+#include <linux/quotaops.h>
+#include <linux/module.h>
+#include <linux/mpage.h>
+#include <asm/processor.h>
+#include "xip2.h"
+#include "acl.h"
+
+#include <linux/pagevec.h>
+
+MODULE_AUTHOR("Remy Card and others");
+MODULE_DESCRIPTION("Second Extended Filesystem");
+MODULE_LICENSE("GPL");
+
+/*
+ * Test whether an inode is a fast symlink.
+ */
+static inline int xip2_inode_is_fast_symlink(struct inode *inode)
+{
+	int ea_blocks = XIP2_I(inode)->i_file_acl ?
+		(inode->i_sb->s_blocksize >> 9) : 0;
+
+	return (S_ISLNK(inode->i_mode) &&
+		inode->i_blocks - ea_blocks == 0);
+}
+
+typedef struct {
+	u32	*p;
+	u32	key;
+	void *block_ptr;
+} Indirect;
+
+static inline void add_chain(Indirect *p, void *block_ptr, u32 *v)
+{
+	p->key = *(p->p = v);
+	p->block_ptr = block_ptr;
+}
+
+static inline int verify_chain(Indirect *from, Indirect *to)
+{
+	while (from <= to && from->key == *from->p)
+		from++;
+	return (from > to);
+}
+
+/**
+ *	xip2_block_to_path - parse the block number into array of offsets
+ *	@inode: inode in question (we are only interested in its superblock)
+ *	@i_block: block number to be parsed
+ *	@offsets: array to store the offsets in
+ *      @boundary: set this non-zero if the referred-to block is likely to be
+ *             followed (on disk) by an indirect block.
+ *	To store the locations of file's data ext2 uses a data structure common
+ *	for UNIX filesystems - tree of pointers anchored in the inode, with
+ *	data blocks at leaves and indirect blocks in intermediate nodes.
+ *	This function translates the block number into path in that tree -
+ *	return value is the path length and @offsets[n] is the offset of
+ *	pointer to (n+1)th node in the nth one. If @block is out of range
+ *	(negative or too large) warning is printed and zero returned.
+ *
+ *	Note: function doesn't find node addresses, so no IO is needed. All
+ *	we need to know is the capacity of indirect blocks (taken from the
+ *	inode->i_sb).
+ */
+
+/*
+ * Portability note: the last comparison (check that we fit into triple
+ * indirect block) is spelled differently, because otherwise on an
+ * architecture with 32-bit longs and 8Kb pages we might get into trouble
+ * if our filesystem had 8Kb blocks. We might use long long, but that would
+ * kill us on x86. Oh, well, at least the sign propagation does not matter -
+ * i_block would have to be negative in the very beginning, so we would not
+ * get there at all.
+ */
+
+static int xip2_block_to_path(struct inode *inode,
+			long i_block, int offsets[4])
+{
+	int ptrs = EXT2_ADDR_PER_BLOCK(inode->i_sb);
+	int ptrs_bits = XIP2_ADDR_PER_BLOCK_BITS(inode->i_sb);
+	const long direct_blocks = EXT2_NDIR_BLOCKS,
+		indirect_blocks = ptrs,
+		double_blocks = (1 << (ptrs_bits * 2));
+	int n = 0;
+
+	if (i_block < 0) {
+		xip2_warning (inode->i_sb, "xip2_block_to_path", "block < 0");
+	} else if (i_block < direct_blocks) {
+		offsets[n++] = i_block;
+	} else if ( (i_block -= direct_blocks) < indirect_blocks) {
+		offsets[n++] = EXT2_IND_BLOCK;
+		offsets[n++] = i_block;
+	} else if ((i_block -= indirect_blocks) < double_blocks) {
+		offsets[n++] = EXT2_DIND_BLOCK;
+		offsets[n++] = i_block >> ptrs_bits;
+		offsets[n++] = i_block & (ptrs - 1);
+	} else if (((i_block -= double_blocks) >> (ptrs_bits * 2)) < ptrs) {
+		offsets[n++] = EXT2_TIND_BLOCK;
+		offsets[n++] = i_block >> (ptrs_bits * 2);
+		offsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);
+		offsets[n++] = i_block & (ptrs - 1);
+	} else {
+		xip2_warning (inode->i_sb, "xip2_block_to_path", "block > big");
+	}
+	return n;
+}
+
+/**
+ *	xip2_get_branch - read the chain of indirect blocks leading to data
+ *	@inode: inode in question
+ *	@depth: depth of the chain (1 - direct pointer, etc.)
+ *	@offsets: offsets of pointers in inode/indirect blocks
+ *	@chain: place to store the result
+ *	@err: here we store the error value
+ *
+ *	Function fills the array of triples <key, p, bh> and returns %NULL
+ *	if everything went OK or the pointer to the last filled triple
+ *	(incomplete one) otherwise. Upon the return chain[i].key contains
+ *	the number of (i+1)-th block in the chain (as it is stored in memory,
+ *	i.e. little-endian 32-bit), chain[i].p contains the address of that
+ *	number (it points into struct inode for i==0 and into the bh->b_data
+ *	for i>0) and chain[i].bh points to the buffer_head of i-th indirect
+ *	block for i>0 and NULL for i==0. In other words, it holds the block
+ *	numbers of the chain, addresses they were taken from (and where we can
+ *	verify that chain did not change) and buffer_heads hosting these
+ *	numbers.
+ *
+ *	Function stops when it stumbles upon zero pointer (absent block)
+ *		(pointer to last triple returned, *@err == 0)
+ *	or when it gets an IO error reading an indirect block
+ *		(ditto, *@err == -EIO)
+ *	or when it notices that chain had been changed while it was reading
+ *		(ditto, *@err == -EAGAIN)
+ *	or when it reads all @depth-1 indirect blocks successfully and finds
+ *	the whole chain, all way to the data (returns %NULL, *err == 0).
+ */
+static Indirect *xip2_get_branch(struct inode *inode,
+				 int depth,
+				 int *offsets,
+				 Indirect chain[4],
+				 int *err)
+{
+	struct super_block *sb = inode->i_sb;
+	Indirect *p = chain;
+	void *block_ptr;
+
+	*err = 0;
+	/* i_data is not going away, no lock needed */
+	add_chain (chain, NULL, XIP2_I(inode)->i_data + *offsets);
+	if (!p->key)
+		goto no_block;
+	while (--depth) {
+		block_ptr = xip2_sb_bread(sb, le32_to_cpu(p->key));
+		if (!block_ptr)
+			goto failure;
+		read_lock(&XIP2_I(inode)->i_meta_lock);
+		if (!verify_chain(chain, p))
+			goto changed;
+		add_chain(++p, block_ptr, (u32*)block_ptr + *++offsets);
+		read_unlock(&XIP2_I(inode)->i_meta_lock);
+		if (!p->key)
+			goto no_block;
+	}
+	return NULL;
+
+changed:
+	read_unlock(&XIP2_I(inode)->i_meta_lock);
+	*err = -EAGAIN;
+	goto no_block;
+failure:
+	*err = -EIO;
+no_block:
+	return p;
+}
+
+/*
+ * Allocation strategy is simple: if we have to allocate something, we will
+ * have to go the whole way to leaf. So let's do it before attaching anything
+ * to tree, set linkage between the newborn blocks, write them if sync is
+ * required, recheck the path, free and repeat if check fails, otherwise
+ * set the last missing link (that will protect us from any truncate-generated
+ * removals - all blocks on the path are immune now) and possibly force the
+ * write on the parent block.
+ * That has a nice additional property: no special recovery from the failed
+ * allocations is needed - we simply release blocks and do not touch anything
+ * reachable from inode.
+ */
+
+int xip2_get_block(struct inode *inode, unsigned long iblock,
+		   sector_t *blockno_result, int create)
+{
+	int err = -EIO;
+	int offsets[4];
+	Indirect chain[4];
+	Indirect *partial;
+	int depth = xip2_block_to_path(inode, iblock, offsets);
+
+	/* Initialize blockno_result to illegal value */
+#ifdef CONFIG_LBD
+	*blockno_result = (~0ULL);
+#else
+	*blockno_result = (~0UL);
+#endif
+
+	if (depth == 0)
+		goto out;
+
+	partial = xip2_get_branch(inode, depth, offsets, chain, &err);
+
+	/* Simplest case - block found, no allocation needed */
+	if (!partial) {
+		*blockno_result = le32_to_cpu(chain[depth-1].key);
+		/* Clean up and exit */
+		partial = chain+depth-1; /* the whole chain */
+		goto cleanup;
+	}
+
+	/* Next simple case - plain lookup or failed read of indirect block */
+	if (!create || err) {
+cleanup:
+		while (partial > chain) {
+			partial--;
+		}
+out:
+		return err;
+	}
+	xip2_warning (inode->i_sb, "xip2_get_block", "allocation of a block "
+			"would be needed");
+	return -EROFS;
+}
+
+static int xip2_readpage(struct file *file, struct page *page)
+{
+	struct inode *inode = page->mapping->host;
+	unsigned long iblock;
+	sector_t blockno;
+	void* block_ptr;
+	int err;
+
+	printk("XIP2-error: xip2_readpage was called, "
+		"stack trace will follow\n");
+	dump_stack();
+
+	if (!PageLocked(page))
+		PAGE_BUG(page);
+	iblock = page->index << (PAGE_CACHE_SHIFT - inode->i_blkbits);
+
+	err=xip2_get_block(inode, iblock, &blockno, 0);
+	if (err)
+		return err;
+	block_ptr = xip2_sb_bread(inode->i_sb, blockno);
+	if (!block_ptr)
+		return -EIO;
+	memcpy (page_address(page),block_ptr,PAGE_SIZE);
+	SetPageUptodate(page);
+	unlock_page(page);
+	return 0;
+}
+
+static int
+xip2_readpages(struct file *file, struct address_space *mapping,
+		struct list_head *pages, unsigned nr_pages)
+{
+	unsigned page_idx;
+	int rc;
+	struct pagevec lru_pvec;
+
+	printk("XIP2-error: xip2_readpages was called, "
+		"stack trace will follow\n");
+	dump_stack();
+
+
+	pagevec_init(&lru_pvec, 0);
+	for (page_idx = 0; page_idx < nr_pages; page_idx++) {
+		struct page *page = list_entry (pages->prev, struct page, list);
+
+		prefetchw(&page->flags);
+		list_del (&page->list);
+		if (!add_to_page_cache(page, mapping,
+					page->index, GFP_KERNEL)) {
+
+			page->mapping = mapping;
+			rc = xip2_readpage (file, page);
+			if (rc)
+				return rc;
+			if (!pagevec_add(&lru_pvec, page))
+				__pagevec_lru_add(&lru_pvec);
+		} else {
+			page_cache_release(page);
+		}
+	}
+	return 0;
+}
+
+static sector_t xip2_bmap(struct address_space *mapping, sector_t block)
+{
+	sector_t tmp;
+	struct inode *inode = mapping->host;
+	xip2_get_block(inode, block, &tmp, 0);
+#ifdef CONFIG_LBD
+	if (tmp == (~0ULL))
+#else
+	if (tmp == (~0UL))
+#endif
+		tmp = 0; //sparse block case
+	return tmp;
+}
+
+struct address_space_operations xip2_aops = {
+	.readpage	= xip2_readpage,
+	.readpages	= xip2_readpages,
+	.bmap		= xip2_bmap,
+};
+
+struct address_space_operations xip2_nobh_aops = {
+	.readpage	= xip2_readpage,
+	.readpages	= xip2_readpages,
+	.bmap		= xip2_bmap,
+};
+
+/*
+ * Probably it should be a library function... search for first non-zero word
+ * or memcmp with zero_page, whatever is better for particular architecture.
+ * Linus?
+ */
+static inline int all_zeroes(u32 *p, u32 *q)
+{
+	while (p < q)
+		if (*p++)
+			return 0;
+	return 1;
+}
+
+static struct ext2_inode *xip2_get_inode(struct super_block *sb, ino_t ino,
+					void **p)
+{
+	void * block_ptr;
+	unsigned long block_group;
+	unsigned long block;
+	unsigned long offset;
+	struct ext2_group_desc * gdp;
+
+	*p = NULL;
+	if ((ino != EXT2_ROOT_INO && ino < XIP2_FIRST_INO(sb)) ||
+	    ino > le32_to_cpu(XIP2_SB(sb)->s_es->s_inodes_count))
+		goto Einval;
+
+	block_group = (ino - 1) / XIP2_INODES_PER_GROUP(sb);
+	gdp = xip2_get_group_desc(sb, block_group, &block_ptr);
+	if (!gdp)
+		goto Egdp;
+	/*
+	 * Figure out the offset within the block group inode table
+	 */
+	offset = ((ino - 1) % XIP2_INODES_PER_GROUP(sb)) * XIP2_INODE_SIZE(sb);
+	block = le32_to_cpu(gdp->bg_inode_table) +
+		(offset >> EXT2_BLOCK_SIZE_BITS(sb));
+	if (!(block_ptr = xip2_sb_bread(sb, block)))
+		goto Eio;
+
+	*p = block_ptr;
+	offset &= (EXT2_BLOCK_SIZE(sb) - 1);
+	return (struct ext2_inode *) (block_ptr + offset);
+
+Einval:
+	xip2_error(sb, "xip2_get_inode", "bad inode number: %lu",
+		   (unsigned long) ino);
+	return ERR_PTR(-EINVAL);
+Eio:
+	xip2_error(sb, "xip2_get_inode",
+		   "unable to read inode block - inode=%lu, block=%lu",
+		   (unsigned long) ino, block);
+Egdp:
+	return ERR_PTR(-EIO);
+}
+
+void xip2_set_inode_flags(struct inode *inode)
+{
+	unsigned int flags = XIP2_I(inode)->i_flags;
+
+	inode->i_flags &= ~(S_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC);
+	if (flags & EXT2_SYNC_FL)
+		inode->i_flags |= S_SYNC;
+	if (flags & EXT2_APPEND_FL)
+		inode->i_flags |= S_APPEND;
+	if (flags & EXT2_IMMUTABLE_FL)
+		inode->i_flags |= S_IMMUTABLE;
+	if (flags & EXT2_NOATIME_FL)
+		inode->i_flags |= S_NOATIME;
+	if (flags & EXT2_DIRSYNC_FL)
+		inode->i_flags |= S_DIRSYNC;
+}
+
+void xip2_read_inode (struct inode * inode)
+{
+	struct xip2_inode_info *ei = XIP2_I(inode);
+	ino_t ino = inode->i_ino;
+	void *block_ptr;
+	struct ext2_inode *raw_inode = xip2_get_inode(inode->i_sb, ino,
+						      &block_ptr);
+	int n;
+
+#ifdef CONFIG_XIP2_FS_POSIX_ACL
+	ei->i_acl = XIP2_ACL_NOT_CACHED;
+	ei->i_default_acl = XIP2_ACL_NOT_CACHED;
+#endif
+	if (IS_ERR(raw_inode))
+		goto bad_inode;
+
+	inode->i_mode = le16_to_cpu(raw_inode->i_mode);
+	inode->i_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);
+	inode->i_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);
+	if (!(test_opt (inode->i_sb, NO_UID32))) {
+		inode->i_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;
+		inode->i_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;
+	}
+	inode->i_nlink = le16_to_cpu(raw_inode->i_links_count);
+	inode->i_size = le32_to_cpu(raw_inode->i_size);
+	inode->i_atime.tv_sec = le32_to_cpu(raw_inode->i_atime);
+	inode->i_ctime.tv_sec = le32_to_cpu(raw_inode->i_ctime);
+	inode->i_mtime.tv_sec = le32_to_cpu(raw_inode->i_mtime);
+	inode->i_atime.tv_nsec = inode->i_mtime.tv_nsec =
+				 inode->i_ctime.tv_nsec = 0;
+	ei->i_dtime = le32_to_cpu(raw_inode->i_dtime);
+	/* We now have enough fields to check if the inode was active or not.
+	 * This is needed because nfsd might try to access dead inodes
+	 * the test is that same one that e2fsck uses
+	 * NeilBrown 1999oct15
+	 */
+	if (inode->i_nlink == 0 && (inode->i_mode == 0 || ei->i_dtime)) {
+		/* this inode is deleted */
+		goto bad_inode;
+	}
+	/* This is the optimal IO size (for stat), not the fs block size */
+	inode->i_blksize = PAGE_SIZE;
+	inode->i_blocks = le32_to_cpu(raw_inode->i_blocks);
+	ei->i_flags = le32_to_cpu(raw_inode->i_flags);
+	ei->i_faddr = le32_to_cpu(raw_inode->i_faddr);
+	ei->i_frag_no = raw_inode->i_frag;
+	ei->i_frag_size = raw_inode->i_fsize;
+	ei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);
+	ei->i_dir_acl = 0;
+	if (S_ISREG(inode->i_mode))
+		inode->i_size |= ((__u64)le32_to_cpu(raw_inode->i_size_high))
+				 << 32;
+	else
+		ei->i_dir_acl = le32_to_cpu(raw_inode->i_dir_acl);
+	ei->i_dtime = 0;
+	inode->i_generation = le32_to_cpu(raw_inode->i_generation);
+	ei->i_state = 0;
+	ei->i_next_alloc_block = 0;
+	ei->i_next_alloc_goal = 0;
+	ei->i_prealloc_count = 0;
+	ei->i_block_group = (ino - 1) / XIP2_INODES_PER_GROUP(inode->i_sb);
+	ei->i_dir_start_lookup = 0;
+
+	/*
+	 * NOTE! The in-memory inode i_data array is in little-endian order
+	 * even on big-endian machines: we do NOT byteswap the block numbers!
+	 */
+	for (n = 0; n < EXT2_N_BLOCKS; n++)
+		ei->i_data[n] = raw_inode->i_block[n];
+
+	if (S_ISREG(inode->i_mode)) {
+		inode->i_op = &xip2_file_inode_operations;
+		inode->i_fop = &xip2_file_operations;
+		if (test_opt(inode->i_sb, NOBH))
+			inode->i_mapping->a_ops = &xip2_nobh_aops;
+		else
+			inode->i_mapping->a_ops = &xip2_aops;
+	} else if (S_ISDIR(inode->i_mode)) {
+		inode->i_op = &xip2_dir_inode_operations;
+		inode->i_fop = &xip2_dir_operations;
+		if (test_opt(inode->i_sb, NOBH))
+			inode->i_mapping->a_ops = &xip2_nobh_aops;
+		else
+			inode->i_mapping->a_ops = &xip2_aops;
+	} else if (S_ISLNK(inode->i_mode)) {
+		if (xip2_inode_is_fast_symlink(inode))
+			inode->i_op = &xip2_fast_symlink_inode_operations;
+		else {
+			inode->i_op = &xip2_symlink_inode_operations;
+			if (test_opt(inode->i_sb, NOBH))
+				inode->i_mapping->a_ops = &xip2_nobh_aops;
+			else
+				inode->i_mapping->a_ops = &xip2_aops;
+		}
+	} else {
+		inode->i_op = &xip2_special_inode_operations;
+		if (raw_inode->i_block[0])
+			init_special_inode(inode, inode->i_mode,
+			   old_decode_dev(le32_to_cpu(raw_inode->i_block[0])));
+		else
+			init_special_inode(inode, inode->i_mode,
+			   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));
+	}
+	xip2_set_inode_flags(inode);
+	return;
+
+bad_inode:
+	make_bad_inode(inode);
+	return;
+}
diff -ruN linux-2.6.5/fs/xip2fs/ioctl.c linux-2.6.5+xip/fs/xip2fs/ioctl.c
--- linux-2.6.5/fs/xip2fs/ioctl.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5+xip/fs/xip2fs/ioctl.c	2004-04-29 14:04:09.000000000 +0200
@@ -0,0 +1,35 @@
+/*
+ *  linux/fs/xip2fs/ioctl.c, Version 1
+ *
+ * (C) Copyright IBM Corp. 2002,2004
+ * Author(s): Carsten Otte <cotte@de.ibm.com>
+ *            Gerald Schaefer <geraldsc@de.ibm.com>
+ * derived from second extended filesystem (ext2)
+ */
+
+
+#include "xip2.h"
+#include <linux/time.h>
+#include <linux/sched.h>
+#include <asm/current.h>
+#include <asm/uaccess.h>
+
+
+int xip2_ioctl (struct inode * inode, struct file * filp, unsigned int cmd,
+		unsigned long arg)
+{
+	struct xip2_inode_info *ei = XIP2_I(inode);
+	unsigned int flags;
+
+	ext2_debug ("cmd = %u, arg = %lu\n", cmd, arg);
+
+	switch (cmd) {
+	case EXT2_IOC_GETFLAGS:
+		flags = ei->i_flags & EXT2_FL_USER_VISIBLE;
+		return put_user(flags, (int *) arg);
+	case EXT2_IOC_GETVERSION:
+		return put_user(inode->i_generation, (int *) arg);
+	default:
+		return -ENOTTY;
+	}
+}
diff -ruN linux-2.6.5/fs/xip2fs/namei.c linux-2.6.5+xip/fs/xip2fs/namei.c
--- linux-2.6.5/fs/xip2fs/namei.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5+xip/fs/xip2fs/namei.c	2004-04-29 14:04:09.000000000 +0200
@@ -0,0 +1,77 @@
+/*
+ *  linux/fs/xip2fs/namei.c, Version 1
+ *
+ * (C) Copyright IBM Corp. 2002,2004
+ * Author(s): Carsten Otte <cotte@de.ibm.com>
+ *            Gerald Schaefer <geraldsc@de.ibm.com>
+ * derived from second extended filesystem (ext2)
+ */
+
+#include <linux/pagemap.h>
+#include "xip2.h"
+#include "xattr.h"
+#include "acl.h"
+
+/*
+ * Methods themselves.
+ */
+
+static struct dentry
+*xip2_lookup(struct inode * dir, struct dentry *dentry, struct nameidata *nd)
+{
+	struct inode * inode;
+	ino_t ino;
+
+	if (dentry->d_name.len > EXT2_NAME_LEN)
+		return ERR_PTR(-ENAMETOOLONG);
+
+	ino = xip2_inode_by_name(dir, dentry);
+	inode = NULL;
+	if (ino) {
+		inode = iget(dir->i_sb, ino);
+		if (!inode)
+			return ERR_PTR(-EACCES);
+	}
+	if (inode)
+		return d_splice_alias(inode, dentry);
+	d_add(dentry, inode);
+	return NULL;
+}
+
+struct dentry *xip2_get_parent(struct dentry *child)
+{
+	unsigned long ino;
+	struct dentry *parent;
+	struct inode *inode;
+	struct dentry dotdot;
+
+	dotdot.d_name.name = "..";
+	dotdot.d_name.len = 2;
+
+	ino = xip2_inode_by_name(child->d_inode, &dotdot);
+	if (!ino)
+		return ERR_PTR(-ENOENT);
+	inode = iget(child->d_inode->i_sb, ino);
+
+	if (!inode)
+		return ERR_PTR(-EACCES);
+	parent = d_alloc_anon(inode);
+	if (!parent) {
+		iput(inode);
+		parent = ERR_PTR(-ENOMEM);
+	}
+	return parent;
+}
+
+struct inode_operations xip2_dir_inode_operations = {
+	.lookup		= xip2_lookup,
+	.getxattr	= xip2_getxattr,
+	.listxattr	= xip2_listxattr,
+	.permission	= xip2_permission,
+};
+
+struct inode_operations xip2_special_inode_operations = {
+	.getxattr	= xip2_getxattr,
+	.listxattr	= xip2_listxattr,
+	.permission	= xip2_permission,
+};
diff -ruN linux-2.6.5/fs/xip2fs/super.c linux-2.6.5+xip/fs/xip2fs/super.c
--- linux-2.6.5/fs/xip2fs/super.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5+xip/fs/xip2fs/super.c	2004-04-29 14:04:09.000000000 +0200
@@ -0,0 +1,920 @@
+/*
+ *  linux/fs/xip2fs/super.c, Version 1
+ *
+ * (C) Copyright IBM Corp. 2002,2004
+ * Author(s): Carsten Otte <cotte@de.ibm.com>
+ *            Gerald Schaefer <geraldsc@de.ibm.com>
+ * derived from second extended filesystem (ext2)
+ */
+
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/blkdev.h>
+#include <linux/parser.h>
+#include <linux/random.h>
+#include <linux/smp_lock.h>
+#include <linux/vfs.h>
+#include <asm/uaccess.h>
+#include "xip2.h"
+#include "xattr.h"
+#include "acl.h"
+#include <asm/extmem.h>
+
+static int xip2_remount (struct super_block * sb, int * flags, char * data);
+static int xip2_statfs (struct super_block * sb, struct kstatfs * buf);
+
+static char error_buf[1024];
+
+void xip2_error (struct super_block * sb, const char * function,
+		 const char * fmt, ...)
+{
+	va_list args;
+
+	va_start (args, fmt);
+	vsprintf (error_buf, fmt, args);
+	va_end (args);
+	if (test_opt (sb, ERRORS_PANIC))
+		panic ("XIP2-fs panic (device %s): %s: %s\n",
+		       sb->s_id, function, error_buf);
+	printk (KERN_CRIT "EXT2-fs error (device %s): %s: %s\n",
+		sb->s_id, function, error_buf);
+	if (test_opt (sb, ERRORS_RO)) {
+		printk ("Remounting filesystem read-only\n");
+		sb->s_flags |= MS_RDONLY;
+	}
+}
+
+NORET_TYPE void xip2_panic (struct super_block * sb, const char * function,
+			    const char * fmt, ...)
+{
+	va_list args;
+
+	va_start (args, fmt);
+	vsprintf (error_buf, fmt, args);
+	va_end (args);
+	sb->s_flags |= MS_RDONLY;
+	panic ("XIP2-fs panic (device %s): %s: %s\n",
+	       sb->s_id, function, error_buf);
+}
+
+void xip2_warning (struct super_block * sb, const char * function,
+		   const char * fmt, ...)
+{
+	va_list args;
+
+	va_start (args, fmt);
+	vsprintf (error_buf, fmt, args);
+	va_end (args);
+	printk (KERN_WARNING "EXT2-fs warning (device %s): %s: %s\n",
+		sb->s_id, function, error_buf);
+}
+
+void xip2_update_dynamic_rev(struct super_block *sb)
+{
+	struct ext2_super_block *es = XIP2_SB(sb)->s_es;
+
+	if (le32_to_cpu(es->s_rev_level) > EXT2_GOOD_OLD_REV)
+		return;
+
+	xip2_warning(sb, __FUNCTION__,
+		     "updating to rev %d because of new feature flag, "
+		     "running e2fsck is recommended",
+		     EXT2_DYNAMIC_REV);
+
+	es->s_first_ino = cpu_to_le32(EXT2_GOOD_OLD_FIRST_INO);
+	es->s_inode_size = cpu_to_le16(EXT2_GOOD_OLD_INODE_SIZE);
+	es->s_rev_level = cpu_to_le32(EXT2_DYNAMIC_REV);
+	/* leave es->s_feature_*compat flags alone */
+	/* es->s_uuid will be set by e2fsck if empty */
+
+	/*
+	 * The rest of the superblock fields should be zero, and if not it
+	 * means they are likely already in use, so leave them alone.  We
+	 * can leave it up to e2fsck to clean up any inconsistencies there.
+	 */
+}
+
+
+static inline int xip2_mem_area_get (struct xip2_sb_info * sbi, char* data)
+{
+	char *p;
+	char dcss_name[9];
+	int i,rc;
+	for (p=data; *p != '\0'; p++) {
+		if (strncmp (p, "memarea=", 8))
+			continue;
+		/* found 8) */
+		p+=8;
+		for (i=0; i<8; i++) {
+			if (*(p+i) == '\0')
+				break;
+			if (*(p+i) == ',')
+				break;
+			dcss_name[i]= *(p+i);
+		}
+		if ((i==8) && (*(p+i) != '\0') && (*(p+i) != ','))
+			continue;
+		dcss_name[i]='\0';
+		sbi->mem_area.name = kmalloc (strlen(dcss_name)+1, GFP_KERNEL);
+		if (sbi->mem_area.name == NULL)
+			return -ENOMEM;
+		memcpy (sbi->mem_area.name, dcss_name, strlen(dcss_name)+1);
+		rc = segment_load (sbi->mem_area.name, SEGMENT_SHARED_RO,
+				  (&sbi->mem_area.start), &(sbi->mem_area.end));
+		if (rc<0) {
+			printk (KERN_WARNING
+				"xip2: cannot load segment %s\n",dcss_name);
+			kfree (sbi->mem_area.name);
+			return rc;
+		}
+		printk (KERN_WARNING
+			"xip2: loaded segment %s successfully from %p to %p\n",
+			dcss_name, (void*) sbi->mem_area.start,
+			(void*) sbi->mem_area.end);
+		return 0;
+	}
+	return -EINVAL;
+}
+
+static inline void xip2_mem_area_put (struct xip2_sb_info * sbi)
+{
+	if (!sbi)
+		BUG();
+	if (!sbi->mem_area.name)
+		BUG();
+	segment_unload (sbi->mem_area.name);
+	kfree (sbi->mem_area.name);
+	sbi->mem_area.end = sbi->mem_area.start = 0;
+}
+
+
+static void xip2_put_super (struct super_block * sb)
+{
+	int db_count;
+	struct xip2_sb_info *sbi = XIP2_SB(sb);
+
+	db_count = sbi->s_gdb_count;
+	kfree(sbi->s_group_desc);
+	kfree(sbi->s_debts);
+	sb->s_fs_info = NULL;
+	xip2_mem_area_put (sbi);
+	kfree(sbi);
+
+	return;
+}
+
+static kmem_cache_t * xip2_inode_cachep;
+
+static struct inode *xip2_alloc_inode(struct super_block *sb)
+{
+	struct xip2_inode_info *ei;
+	ei = (struct xip2_inode_info *)kmem_cache_alloc(xip2_inode_cachep,
+							SLAB_KERNEL);
+	if (!ei)
+		return NULL;
+#ifdef CONFIG_XIP2_FS_POSIX_ACL
+	ei->i_acl = XIP2_ACL_NOT_CACHED;
+	ei->i_default_acl = XIP2_ACL_NOT_CACHED;
+#endif
+	ei->vfs_inode.i_version = 1;
+	return &ei->vfs_inode;
+}
+
+static void xip2_destroy_inode(struct inode *inode)
+{
+	kmem_cache_free(xip2_inode_cachep, XIP2_I(inode));
+}
+
+static void init_once(void * foo, kmem_cache_t * cachep, unsigned long flags)
+{
+	struct xip2_inode_info *ei = (struct xip2_inode_info *) foo;
+
+	if ((flags & (SLAB_CTOR_VERIFY|SLAB_CTOR_CONSTRUCTOR)) ==
+	    SLAB_CTOR_CONSTRUCTOR) {
+		rwlock_init(&ei->i_meta_lock);
+#ifdef CONFIG_XIP2_FS_XATTR
+		init_rwsem(&ei->xattr_sem);
+#endif
+		inode_init_once(&ei->vfs_inode);
+	}
+}
+
+static int init_inodecache(void)
+{
+	xip2_inode_cachep = kmem_cache_create("xip2_inode_cache",
+					     sizeof(struct xip2_inode_info), 0,
+					     SLAB_HWCACHE_ALIGN |
+					     SLAB_RECLAIM_ACCOUNT,
+					     init_once, NULL);
+	if (xip2_inode_cachep == NULL)
+		return -ENOMEM;
+	return 0;
+}
+
+static void destroy_inodecache(void)
+{
+	if (kmem_cache_destroy(xip2_inode_cachep))
+		printk(KERN_INFO "xip2_inode_cache: not all structures were freed\n");
+}
+
+#ifdef CONFIG_XIP2_FS_POSIX_ACL
+
+static void xip2_clear_inode(struct inode *inode)
+{
+	struct xip2_inode_info *ei = XIP2_I(inode);
+
+	if (ei->i_acl && ei->i_acl != XIP2_ACL_NOT_CACHED) {
+		posix_acl_release(ei->i_acl);
+		ei->i_acl = XIP2_ACL_NOT_CACHED;
+	}
+	if (ei->i_default_acl && ei->i_default_acl != XIP2_ACL_NOT_CACHED) {
+		posix_acl_release(ei->i_default_acl);
+		ei->i_default_acl = XIP2_ACL_NOT_CACHED;
+	}
+}
+
+#else
+# define xip2_clear_inode NULL
+#endif
+
+static struct super_operations xip2_sops = {
+	.alloc_inode	= xip2_alloc_inode,
+	.destroy_inode	= xip2_destroy_inode,
+	.read_inode	= xip2_read_inode,
+	.put_super	= xip2_put_super,
+	.statfs		= xip2_statfs,
+	.remount_fs	= xip2_remount,
+	.clear_inode	= xip2_clear_inode,
+};
+
+/* Yes, most of these are left as NULL!!
+ * A NULL value implies the default, which works with ext2-like file
+ * systems, but can be improved upon.
+ * Currently only get_parent is required.
+ */
+struct dentry *xip2_get_parent(struct dentry *child);
+static struct export_operations xip2_export_ops = {
+	.get_parent = xip2_get_parent,
+};
+
+static unsigned long get_sb_block(void **data)
+{
+	unsigned long 	sb_block;
+	char 		*options = (char *) *data;
+
+	if (!options || strncmp(options, "sb=", 3) != 0)
+		return 1;	/* Default location */
+	options += 3;
+	sb_block = simple_strtoul(options, &options, 0);
+	if (*options && *options != ',') {
+		printk("EXT2-fs: Invalid sb specification: %s\n",
+		       (char *) *data);
+		return 1;
+	}
+	if (*options == ',')
+		options++;
+	*data = (void *) options;
+	return sb_block;
+}
+
+enum {
+	Opt_bsd_df, Opt_minix_df, Opt_grpid, Opt_nogrpid,
+	Opt_resgid, Opt_resuid, Opt_sb, Opt_err_cont, Opt_err_panic, Opt_err_ro,
+	Opt_nouid32, Opt_check, Opt_nocheck, Opt_debug, Opt_oldalloc, Opt_orlov, Opt_nobh,
+	Opt_user_xattr, Opt_nouser_xattr, Opt_acl, Opt_noacl,
+	Opt_ignore, Opt_err,
+};
+
+static match_table_t tokens = {
+	{Opt_bsd_df, "bsddf"},
+	{Opt_minix_df, "minixdf"},
+	{Opt_grpid, "grpid"},
+	{Opt_grpid, "bsdgroups"},
+	{Opt_nogrpid, "nogrpid"},
+	{Opt_nogrpid, "sysvgroups"},
+	{Opt_resgid, "resgid=%u"},
+	{Opt_resuid, "resuid=%u"},
+	{Opt_sb, "sb=%u"},
+	{Opt_err_cont, "errors=continue"},
+	{Opt_err_panic, "errors=panic"},
+	{Opt_err_ro, "errors=remount-ro"},
+	{Opt_nouid32, "nouid32"},
+	{Opt_nocheck, "check=none"},
+	{Opt_nocheck, "nocheck"},
+	{Opt_check, "check"},
+	{Opt_debug, "debug"},
+	{Opt_oldalloc, "oldalloc"},
+	{Opt_orlov, "orlov"},
+	{Opt_nobh, "nobh"},
+	{Opt_user_xattr, "user_xattr"},
+	{Opt_nouser_xattr, "nouser_xattr"},
+	{Opt_acl, "acl"},
+	{Opt_noacl, "noacl"},
+	{Opt_ignore, "grpquota"},
+	{Opt_ignore, "noquota"},
+	{Opt_ignore, "quota"},
+	{Opt_ignore, "usrquota"},
+	{Opt_err, NULL}
+};
+
+static int parse_options (char * options,
+			  struct xip2_sb_info *sbi)
+{
+	char * p;
+	substring_t args[MAX_OPT_ARGS];
+	unsigned long kind = EXT2_MOUNT_ERRORS_CONT;
+	int option;
+
+	if (!options)
+		return 1;
+
+	while ((p = strsep (&options, ",")) != NULL) {
+		int token;
+		if (!*p)
+			continue;
+
+		// ignore memarea= parameter - has been parsed before
+		if (!strncmp (p, "memarea=", 8))
+			continue;
+
+		token = match_token(p, tokens, args);
+		switch (token) {
+		case Opt_bsd_df:
+			clear_opt (sbi->s_mount_opt, MINIX_DF);
+			break;
+		case Opt_minix_df:
+			set_opt (sbi->s_mount_opt, MINIX_DF);
+			break;
+		case Opt_grpid:
+			set_opt (sbi->s_mount_opt, GRPID);
+			break;
+		case Opt_nogrpid:
+			clear_opt (sbi->s_mount_opt, GRPID);
+			break;
+		case Opt_resuid:
+			if (match_int(&args[0], &option))
+				return 0;
+			sbi->s_resuid = option;
+			break;
+		case Opt_resgid:
+			if (match_int(&args[0], &option))
+				return 0;
+			sbi->s_resgid = option;
+			break;
+		case Opt_sb:
+			/* handled by get_sb_block() instead of here */
+			/* *sb_block = match_int(&args[0]); */
+			break;
+		case Opt_err_panic:
+			kind = EXT2_MOUNT_ERRORS_PANIC;
+			break;
+		case Opt_err_ro:
+			kind = EXT2_MOUNT_ERRORS_RO;
+			break;
+		case Opt_err_cont:
+			kind = EXT2_MOUNT_ERRORS_CONT;
+			break;
+		case Opt_nouid32:
+			set_opt (sbi->s_mount_opt, NO_UID32);
+			break;
+		case Opt_check:
+#ifdef CONFIG_XIP2_CHECK
+			set_opt (sbi->s_mount_opt, CHECK);
+#else
+			printk("EXT2 Check option not supported\n");
+#endif
+			break;
+		case Opt_nocheck:
+			clear_opt (sbi->s_mount_opt, CHECK);
+			break;
+		case Opt_debug:
+			set_opt (sbi->s_mount_opt, DEBUG);
+			break;
+		case Opt_oldalloc:
+			set_opt (sbi->s_mount_opt, OLDALLOC);
+			break;
+		case Opt_orlov:
+			clear_opt (sbi->s_mount_opt, OLDALLOC);
+			break;
+		case Opt_nobh:
+			set_opt (sbi->s_mount_opt, NOBH);
+			break;
+#ifdef CONFIG_XIP2_FS_XATTR
+		case Opt_user_xattr:
+			set_opt (sbi->s_mount_opt, XATTR_USER);
+			break;
+		case Opt_nouser_xattr:
+			clear_opt (sbi->s_mount_opt, XATTR_USER);
+			break;
+#else
+		case Opt_user_xattr:
+		case Opt_nouser_xattr:
+			printk("EXT2 (no)user_xattr options not supported\n");
+			break;
+#endif
+#ifdef CONFIG_XIP2_FS_POSIX_ACL
+		case Opt_acl:
+			set_opt(sbi->s_mount_opt, POSIX_ACL);
+			break;
+		case Opt_noacl:
+			clear_opt(sbi->s_mount_opt, POSIX_ACL);
+			break;
+#else
+		case Opt_acl:
+		case Opt_noacl:
+			printk("EXT2 (no)acl options not supported\n");
+			break;
+#endif
+		case Opt_ignore:
+			break;
+		default:
+			return 0;
+		}
+	}
+	sbi->s_mount_opt |= kind;
+	return 1;
+}
+
+static int xip2_setup_super (struct super_block * sb,
+			      struct ext2_super_block * es)
+{
+	if (le32_to_cpu(es->s_rev_level) > EXT2_MAX_SUPP_REV)
+		printk ("XIP2-fs warning: revision level too high\n" );
+	return MS_RDONLY;
+}
+
+static int xip2_check_descriptors (struct super_block * sb)
+{
+	int i;
+	int desc_block = 0;
+	struct xip2_sb_info *sbi = XIP2_SB(sb);
+	unsigned long block = le32_to_cpu(sbi->s_es->s_first_data_block);
+	struct ext2_group_desc * gdp = NULL;
+
+	ext2_debug ("Checking group descriptors");
+
+	for (i = 0; i < sbi->s_groups_count; i++)
+	{
+		if ((i % XIP2_DESC_PER_BLOCK(sb)) == 0)
+			gdp = (struct ext2_group_desc *) sbi->s_group_desc[desc_block++];
+		if (le32_to_cpu(gdp->bg_block_bitmap) < block ||
+		    le32_to_cpu(gdp->bg_block_bitmap) >= block + XIP2_BLOCKS_PER_GROUP(sb))
+		{
+			xip2_error (sb, "xip2_check_descriptors",
+				    "Block bitmap for group %d"
+				    " not in group (block %lu)!",
+				    i, (unsigned long) le32_to_cpu(gdp->bg_block_bitmap));
+			return 0;
+		}
+		if (le32_to_cpu(gdp->bg_inode_bitmap) < block ||
+		    le32_to_cpu(gdp->bg_inode_bitmap) >= block + XIP2_BLOCKS_PER_GROUP(sb))
+		{
+			xip2_error (sb, "xip2_check_descriptors",
+				    "Inode bitmap for group %d"
+				    " not in group (block %lu)!",
+				    i, (unsigned long) le32_to_cpu(gdp->bg_inode_bitmap));
+			return 0;
+		}
+		if (le32_to_cpu(gdp->bg_inode_table) < block ||
+		    le32_to_cpu(gdp->bg_inode_table) + sbi->s_itb_per_group >=
+		    block + XIP2_BLOCKS_PER_GROUP(sb))
+		{
+			xip2_error (sb, "xip2_check_descriptors",
+				    "Inode table for group %d"
+				    " not in group (block %lu)!",
+				    i, (unsigned long) le32_to_cpu(gdp->bg_inode_table));
+			return 0;
+		}
+		block += XIP2_BLOCKS_PER_GROUP(sb);
+		gdp++;
+	}
+	return 1;
+}
+
+#define log2(n) ffz(~(n))
+
+/*
+ * Maximal file size.  There is a direct, and {,double-,triple-}indirect
+ * block limit, and also a limit of (2^32 - 1) 512-byte sectors in i_blocks.
+ * We need to be 1 filesystem block less than the 2^32 sector limit.
+ */
+static loff_t xip2_max_size(int bits)
+{
+	loff_t res = EXT2_NDIR_BLOCKS;
+	res += 1LL << (bits-2);
+	res += 1LL << (2*(bits-2));
+	res += 1LL << (3*(bits-2));
+	res <<= bits;
+	if (res > (512LL << 32) - (1 << bits))
+		res = (512LL << 32) - (1 << bits);
+	return res;
+}
+
+static unsigned long descriptor_loc(struct super_block *sb,
+				    unsigned long logic_sb_block,
+				    int nr)
+{
+	struct xip2_sb_info *sbi = XIP2_SB(sb);
+	unsigned long bg, first_data_block, first_meta_bg;
+	int has_super = 0;
+
+	first_data_block = le32_to_cpu(sbi->s_es->s_first_data_block);
+	first_meta_bg = le32_to_cpu(sbi->s_es->s_first_meta_bg);
+
+	if (!XIP2_HAS_INCOMPAT_FEATURE(sb, EXT2_FEATURE_INCOMPAT_META_BG) ||
+	    nr < first_meta_bg)
+		return (logic_sb_block + nr + 1);
+	bg = sbi->s_desc_per_block * nr;
+	if (xip2_bg_has_super(sb, bg))
+		has_super = 1;
+	return (first_data_block + has_super + (bg * sbi->s_blocks_per_group));
+}
+
+void * xip2_sb_bread (struct super_block *sb, sector_t block)
+{
+       struct xip2_sb_info * sbi = XIP2_SB(sb);
+
+	if (sb->s_blocksize != PAGE_SIZE)
+		BUG();
+	if ((block+1)*PAGE_SIZE-1 > sbi->mem_area.end - sbi->mem_area.start)
+		return NULL;
+	return (void*) (unsigned long)(sbi->mem_area.start + block*PAGE_SIZE);
+}
+
+static void xip2_sb_set_blocksize (struct super_block *sb, int size)
+{
+	int bits;
+
+	sb->s_blocksize = size;
+	for (bits = 9, size >>= 9; size >>= 1; bits++)
+		;
+	sb->s_blocksize_bits = bits;
+}
+
+static int xip2_fill_super(struct super_block *sb, void *data, int silent)
+{
+	void* block_ptr;
+	struct xip2_sb_info * sbi;
+	struct ext2_super_block * es;
+	struct inode *root;
+	unsigned long block, sb_block = 1;
+	unsigned long logic_sb_block = get_sb_block(&data);
+	unsigned long offset = 0;
+	unsigned long def_mount_opts;
+	int blocksize = PAGE_SIZE;
+	int db_count;
+	int i;
+
+	if (!(sb->s_flags & MS_RDONLY))
+		return -EROFS;
+
+	sbi = kmalloc(sizeof(*sbi), GFP_KERNEL);
+	if (!sbi)
+		return -ENOMEM;
+	sb->s_fs_info = sbi;
+	memset(sbi, 0, sizeof(*sbi));
+
+	/* load corresponding extmem segment */
+	if (xip2_mem_area_get (sbi, data))
+		goto failed_sbi;
+
+	logic_sb_block = (sb_block*BLOCK_SIZE) / blocksize;
+	offset = (sb_block*BLOCK_SIZE) % blocksize;
+
+	sb->s_blocksize = blocksize;
+
+	if (!(block_ptr = xip2_sb_bread(sb, logic_sb_block))) {
+		printk ("XIP2-fs: unable to read superblock\n");
+		goto failed_mount;
+	}
+	/*
+	 * Note: s_es must be initialized as soon as possible because
+	 *       some ext2 macro-instructions depend on its value
+	 */
+	es = (struct ext2_super_block *) (((char *)block_ptr) + offset);
+	sbi->s_es = es;
+	sb->s_magic = le16_to_cpu(es->s_magic);
+	sb->s_flags |= MS_ONE_SECOND;
+	if (sb->s_magic != EXT2_SUPER_MAGIC) {
+		if (!silent)
+			printk ("VFS: Can't find xip2 filesystem on dev %s.\n",
+				sb->s_id);
+		goto failed_mount;
+	}
+
+	/* Set defaults before we parse the mount options */
+	def_mount_opts = le32_to_cpu(es->s_default_mount_opts);
+	if (def_mount_opts & EXT2_DEFM_DEBUG)
+		set_opt(sbi->s_mount_opt, DEBUG);
+	if (def_mount_opts & EXT2_DEFM_BSDGROUPS)
+		set_opt(sbi->s_mount_opt, GRPID);
+	if (def_mount_opts & EXT2_DEFM_UID16)
+		set_opt(sbi->s_mount_opt, NO_UID32);
+	if (def_mount_opts & EXT2_DEFM_XATTR_USER)
+		set_opt(sbi->s_mount_opt, XATTR_USER);
+	if (def_mount_opts & EXT2_DEFM_ACL)
+		set_opt(sbi->s_mount_opt, POSIX_ACL);
+
+	if (le16_to_cpu(sbi->s_es->s_errors) == EXT2_ERRORS_PANIC)
+		set_opt(sbi->s_mount_opt, ERRORS_PANIC);
+	else if (le16_to_cpu(sbi->s_es->s_errors) == EXT2_ERRORS_RO)
+		set_opt(sbi->s_mount_opt, ERRORS_RO);
+
+	sbi->s_resuid = le16_to_cpu(es->s_def_resuid);
+	sbi->s_resgid = le16_to_cpu(es->s_def_resgid);
+
+	if (!parse_options ((char *) data, sbi))
+		goto failed_mount;
+
+	sb->s_flags = (sb->s_flags & ~MS_POSIXACL) |
+		((XIP2_SB(sb)->s_mount_opt & EXT2_MOUNT_POSIX_ACL) ?
+		 MS_POSIXACL : 0);
+
+	if (le32_to_cpu(es->s_rev_level) == EXT2_GOOD_OLD_REV &&
+	    (XIP2_HAS_COMPAT_FEATURE(sb, ~0U) ||
+	     XIP2_HAS_RO_COMPAT_FEATURE(sb, ~0U) ||
+	     XIP2_HAS_INCOMPAT_FEATURE(sb, ~0U)))
+		printk("XIP2-fs warning: feature flags set on rev 0 fs, "
+		       "running e2fsck is recommended\n");
+	/*
+	 * Check feature flags regardless of the revision level, since we
+	 * previously didn't change the revision level when setting the flags,
+	 * so there is a chance incompat flags are set on a rev 0 filesystem.
+	 */
+	if ((i = XIP2_HAS_INCOMPAT_FEATURE(sb, ~EXT2_FEATURE_INCOMPAT_SUPP))) {
+		printk ("XIP2-fs: %s: couldn't mount because of "
+			"unsupported optional features (%x).\n",
+			sb->s_id, i);
+		goto failed_mount;
+	}
+	blocksize = BLOCK_SIZE << le32_to_cpu(sbi->s_es->s_log_block_size);
+
+	if ((blocksize != PAGE_SIZE) || (sb->s_blocksize != blocksize)) {
+		if (!silent)
+			printk ("XIP2FS: Unsupported blocksize on segment "
+				"%s.\n", sbi->mem_area.name);
+		goto failed_mount;
+	}
+
+	xip2_sb_set_blocksize (sb, blocksize);
+
+	sb->s_maxbytes = xip2_max_size(sb->s_blocksize_bits);
+
+	if (le32_to_cpu(es->s_rev_level) == EXT2_GOOD_OLD_REV) {
+		sbi->s_inode_size = EXT2_GOOD_OLD_INODE_SIZE;
+		sbi->s_first_ino = EXT2_GOOD_OLD_FIRST_INO;
+	} else {
+		sbi->s_inode_size = le16_to_cpu(es->s_inode_size);
+		sbi->s_first_ino = le32_to_cpu(es->s_first_ino);
+		if ((sbi->s_inode_size < EXT2_GOOD_OLD_INODE_SIZE) ||
+		    (sbi->s_inode_size & (sbi->s_inode_size - 1)) ||
+		    (sbi->s_inode_size > blocksize)) {
+			printk ("XIP2-fs: unsupported inode size: %d\n",
+				sbi->s_inode_size);
+			goto failed_mount;
+		}
+	}
+	sbi->s_frag_size = EXT2_MIN_FRAG_SIZE <<
+				   le32_to_cpu(es->s_log_frag_size);
+	if (sbi->s_frag_size)
+		sbi->s_frags_per_block = sb->s_blocksize /
+						  sbi->s_frag_size;
+	else
+		sb->s_magic = 0;
+	sbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);
+	sbi->s_frags_per_group = le32_to_cpu(es->s_frags_per_group);
+	sbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);
+	sbi->s_inodes_per_block = sb->s_blocksize /
+					   XIP2_INODE_SIZE(sb);
+	sbi->s_itb_per_group = sbi->s_inodes_per_group /
+				sbi->s_inodes_per_block;
+	sbi->s_desc_per_block = sb->s_blocksize /
+					 sizeof (struct ext2_group_desc);
+	sbi->s_mount_state = le16_to_cpu(es->s_state);
+	sbi->s_addr_per_block_bits =
+		log2 (EXT2_ADDR_PER_BLOCK(sb));
+	sbi->s_desc_per_block_bits =
+		log2 (XIP2_DESC_PER_BLOCK(sb));
+	if (sb->s_magic != EXT2_SUPER_MAGIC) {
+		if (!silent)
+			printk ("VFS: Can't find an xip2 filesystem on dev "
+				"%s.\n",
+				sb->s_id);
+		goto failed_mount;
+	}
+
+	if (sb->s_blocksize != sbi->s_frag_size) {
+		printk ("XIP2-fs: fragsize %lu != blocksize %lu (not supported yet)\n",
+			sbi->s_frag_size, sb->s_blocksize);
+		goto failed_mount;
+	}
+
+	if (sbi->s_blocks_per_group > sb->s_blocksize * 8) {
+		printk ("XIP2-fs: #blocks per group too big: %lu\n",
+			sbi->s_blocks_per_group);
+		goto failed_mount;
+	}
+	if (sbi->s_frags_per_group > sb->s_blocksize * 8) {
+		printk ("XIP2-fs: #fragments per group too big: %lu\n",
+			sbi->s_frags_per_group);
+		goto failed_mount;
+	}
+	if (sbi->s_inodes_per_group > sb->s_blocksize * 8) {
+		printk ("XIP2-fs: #inodes per group too big: %lu\n",
+			sbi->s_inodes_per_group);
+		goto failed_mount;
+	}
+	sbi->s_groups_count = (le32_to_cpu(es->s_blocks_count) -
+				le32_to_cpu(es->s_first_data_block) +
+				XIP2_BLOCKS_PER_GROUP(sb) - 1) /
+				XIP2_BLOCKS_PER_GROUP(sb);
+	db_count = (sbi->s_groups_count + XIP2_DESC_PER_BLOCK(sb) - 1) /
+		   XIP2_DESC_PER_BLOCK(sb);
+	sbi->s_group_desc = kmalloc (db_count * sizeof (void *), GFP_KERNEL);
+	if (sbi->s_group_desc == NULL) {
+		printk ("XIP2-fs: not enough memory\n");
+		goto failed_mount;
+	}
+	percpu_counter_init(&sbi->s_freeblocks_counter);
+	percpu_counter_init(&sbi->s_freeinodes_counter);
+	percpu_counter_init(&sbi->s_dirs_counter);
+	bgl_lock_init(&sbi->s_blockgroup_lock);
+	sbi->s_debts = kmalloc(sbi->s_groups_count * sizeof(*sbi->s_debts),
+			       GFP_KERNEL);
+	if (!sbi->s_debts) {
+		printk ("XIP2-fs: not enough memory\n");
+		goto failed_mount_group_desc;
+	}
+	memset(sbi->s_debts, 0, sbi->s_groups_count * sizeof(*sbi->s_debts));
+	for (i = 0; i < db_count; i++) {
+		block = descriptor_loc(sb, logic_sb_block, i);
+		sbi->s_group_desc[i] = xip2_sb_bread(sb, block);
+		if (!sbi->s_group_desc[i]) {
+			printk ("XIP2-fs: unable to read group descriptors\n");
+			goto failed_mount_group_desc;
+		}
+	}
+	if (!xip2_check_descriptors (sb)) {
+		printk ("EXT2-fs: group descriptors corrupted!\n");
+		db_count = i;
+		goto failed_mount;
+	}
+	sbi->s_gdb_count = db_count;
+	get_random_bytes(&sbi->s_next_generation, sizeof(u32));
+	spin_lock_init(&sbi->s_next_gen_lock);
+	/*
+	 * set up enough so that it can read an inode
+	 */
+	sb->s_op = &xip2_sops;
+	sb->s_export_op = &xip2_export_ops;
+	root = iget(sb, EXT2_ROOT_INO);
+	sb->s_root = d_alloc_root(root);
+	if (!sb->s_root) {
+		iput(root);
+		printk(KERN_ERR "XIP2-fs: get root inode failed\n");
+		goto failed_mount;
+	}
+	if (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {
+		dput(sb->s_root);
+		sb->s_root = NULL;
+		printk(KERN_ERR "XIP2-fs: corrupt root inode, run e2fsck\n");
+		goto failed_mount;
+	}
+	if (XIP2_HAS_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_HAS_JOURNAL))
+		xip2_warning(sb, __FUNCTION__,
+			"mounting ext3 filesystem as ext2\n");
+	xip2_setup_super (sb, es);
+	percpu_counter_mod(&sbi->s_freeblocks_counter,
+				xip2_count_free_blocks(sb));
+	percpu_counter_mod(&sbi->s_freeinodes_counter,
+				xip2_count_free_inodes(sb));
+	percpu_counter_mod(&sbi->s_dirs_counter,
+				xip2_count_dirs(sb));
+	return 0;
+failed_mount_group_desc:
+	kfree(sbi->s_group_desc);
+	if (sbi->s_debts)
+		kfree(sbi->s_debts);
+failed_mount:
+	xip2_mem_area_put (sbi);
+failed_sbi:
+	sb->s_fs_info = NULL;
+	kfree(sbi);
+	return -EINVAL;
+}
+
+static int xip2_remount (struct super_block * sb, int * flags, char * data)
+{
+	struct xip2_sb_info * sbi = XIP2_SB(sb);
+	struct ext2_super_block * es;
+
+	/*
+	 * Allow the "check" option to be passed as a remount option.
+	 */
+	if (!parse_options (data, sbi))
+		return -EINVAL;
+
+	sb->s_flags = (sb->s_flags & ~MS_POSIXACL) |
+		((sbi->s_mount_opt & EXT2_MOUNT_POSIX_ACL) ? MS_POSIXACL : 0);
+
+	es = sbi->s_es;
+	if (*flags & MS_RDONLY)
+		return 0;
+	else
+		return -EROFS;
+}
+
+static int xip2_statfs (struct super_block * sb, struct kstatfs * buf)
+{
+	struct xip2_sb_info *sbi = XIP2_SB(sb);
+	unsigned long overhead;
+	int i;
+
+	if (test_opt (sb, MINIX_DF))
+		overhead = 0;
+	else {
+		/*
+		 * Compute the overhead (FS structures)
+		 */
+
+		/*
+		 * All of the blocks before first_data_block are
+		 * overhead
+		 */
+		overhead = le32_to_cpu(sbi->s_es->s_first_data_block);
+
+		/*
+		 * Add the overhead attributed to the superblock and
+		 * block group descriptors.  If the sparse superblocks
+		 * feature is turned on, then not all groups have this.
+		 */
+		for (i = 0; i < sbi->s_groups_count; i++)
+			overhead += xip2_bg_has_super(sb, i) +
+				xip2_bg_num_gdb(sb, i);
+
+		/*
+		 * Every block group has an inode bitmap, a block
+		 * bitmap, and an inode table.
+		 */
+		overhead += (sbi->s_groups_count *
+			     (2 + sbi->s_itb_per_group));
+	}
+
+	buf->f_type = EXT2_SUPER_MAGIC;
+	buf->f_bsize = sb->s_blocksize;
+	buf->f_blocks = le32_to_cpu(sbi->s_es->s_blocks_count) - overhead;
+	buf->f_bfree = xip2_count_free_blocks(sb);
+	buf->f_bavail = buf->f_bfree - le32_to_cpu(sbi->s_es->s_r_blocks_count);
+	if (buf->f_bfree < le32_to_cpu(sbi->s_es->s_r_blocks_count))
+		buf->f_bavail = 0;
+	buf->f_files = le32_to_cpu(sbi->s_es->s_inodes_count);
+	buf->f_ffree = xip2_count_free_inodes (sb);
+	buf->f_namelen = EXT2_NAME_LEN;
+	return 0;
+}
+
+static struct super_block *xip2_get_sb(struct file_system_type *fs_type,
+	int flags, const char *dev_name, void *data)
+{
+	return get_sb_nodev(fs_type, flags, data, xip2_fill_super);
+}
+
+static struct file_system_type xip2_fs_type = {
+	.owner		= THIS_MODULE,
+	.name		= "xip2",
+	.get_sb		= xip2_get_sb,
+	.kill_sb	= kill_anon_super,
+};
+
+static int __init init_xip2_fs(void)
+{
+	int err = init_xip2_xattr();
+	if (err)
+		return err;
+	err = init_inodecache();
+	if (err)
+		goto out1;
+	err = register_filesystem(&xip2_fs_type);
+	if (err)
+		goto out;
+	return 0;
+out:
+	destroy_inodecache();
+out1:
+	exit_xip2_xattr();
+	return err;
+}
+
+static void __exit exit_xip2_fs(void)
+{
+	unregister_filesystem(&xip2_fs_type);
+	destroy_inodecache();
+	exit_xip2_xattr();
+}
+
+module_init(init_xip2_fs)
+module_exit(exit_xip2_fs)
diff -ruN linux-2.6.5/fs/xip2fs/symlink.c linux-2.6.5+xip/fs/xip2fs/symlink.c
--- linux-2.6.5/fs/xip2fs/symlink.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5+xip/fs/xip2fs/symlink.c	2004-04-29 14:04:09.000000000 +0200
@@ -0,0 +1,72 @@
+/*
+ *  linux/fs/xip2fs/symlink.c, Version 1
+ *
+ * (C) Copyright IBM Corp. 2002,2004
+ * Author(s): Carsten Otte <cotte@de.ibm.com>
+ *            Gerald Schaefer <geraldsc@de.ibm.com>
+ * derived from second extended filesystem (ext2)
+ */
+
+
+#include "xip2.h"
+#include "xattr.h"
+#include <linux/pagemap.h>
+
+static char *xip2_getlink(struct dentry * dentry)
+{
+	sector_t blockno;
+	char * res;
+
+	if (xip2_get_block (dentry->d_inode, 0, &blockno, 0)) {
+		xip2_error (dentry->d_inode->i_sb, "xip2_getlink",
+				"cannot resolve symbolic link");
+		return NULL;
+	}
+	res = (char*) xip2_sb_bread (dentry->d_inode->i_sb, blockno);
+	if (res)
+		return res;
+	return (char*) empty_zero_page;
+}
+
+
+static int xip2_readlink(struct dentry *dentry, char __user *buffer, int buflen)
+{
+	char *s = xip2_getlink(dentry);
+	int res = vfs_readlink(dentry,buffer,buflen,s);
+	return res;
+}
+
+static int xip2_follow_link(struct dentry *dentry, struct nameidata *nd)
+{
+	char *s = xip2_getlink(dentry);
+	int res = vfs_follow_link(nd, s);
+	return res;
+}
+
+
+static int
+xip2_fast_readlink(struct dentry *dentry, char __user *buffer, int buflen)
+{
+	struct xip2_inode_info *ei = XIP2_I(dentry->d_inode);
+	return vfs_readlink(dentry, buffer, buflen, (char *)ei->i_data);
+}
+
+static int xip2_fast_follow_link(struct dentry *dentry, struct nameidata *nd)
+{
+	struct xip2_inode_info *ei = XIP2_I(dentry->d_inode);
+	return vfs_follow_link(nd, (char *)ei->i_data);
+}
+
+struct inode_operations xip2_symlink_inode_operations = {
+	.readlink	= xip2_readlink,
+	.follow_link	= xip2_follow_link,
+	.getxattr	= xip2_getxattr,
+	.listxattr	= xip2_listxattr,
+};
+
+struct inode_operations xip2_fast_symlink_inode_operations = {
+	.readlink	= xip2_fast_readlink,
+	.follow_link	= xip2_fast_follow_link,
+	.getxattr	= xip2_getxattr,
+	.listxattr	= xip2_listxattr,
+};
diff -ruN linux-2.6.5/fs/xip2fs/xattr.c linux-2.6.5+xip/fs/xip2fs/xattr.c
--- linux-2.6.5/fs/xip2fs/xattr.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5+xip/fs/xip2fs/xattr.c	2004-04-29 14:04:09.000000000 +0200
@@ -0,0 +1,478 @@
+/*
+ *  linux/fs/xip2fs/xattr.c, Version 1
+ *
+ * (C) Copyright IBM Corp. 2002,2004
+ * Author(s): Carsten Otte <cotte@de.ibm.com>
+ *            Gerald Schaefer <geraldsc@de.ibm.com>
+ * derived from second extended filesystem (ext2)
+ */
+
+
+/*
+ * Extended attributes are stored on disk blocks allocated outside of
+ * any inode. The i_file_acl field is then made to point to this allocated
+ * block. If all extended attributes of an inode are identical, these
+ * inodes may share the same extended attribute block. Such situations
+ * are automatically detected by keeping a cache of recent attribute block
+ * numbers and hashes over the block's contents in memory.
+ *
+ *
+ * Extended attribute block layout:
+ *
+ *   +------------------+
+ *   | header           |
+ *    entry 1          | |
+ *   | entry 2          | | growing downwards
+ *   | entry 3          | v
+ *   | four null bytes  |
+ *   | . . .            |
+ *   | value 1          | ^
+ *   | value 3          | | growing upwards
+ *   | value 2          | |
+ *   +------------------+
+ *
+ * The block header is followed by multiple entry descriptors. These entry
+ * descriptors are variable in size, and alligned to EXT2_XATTR_PAD
+ * byte boundaries. The entry descriptors are sorted by attribute name,
+ * so that two extended attribute blocks can be compared efficiently.
+ *
+ * Attribute values are aligned to the end of the block, stored in
+ * no specific order. They are also padded to EXT2_XATTR_PAD byte
+ * boundaries. No additional gaps are left between them.
+ *
+ * Locking strategy
+ * ----------------
+ * XIP2_I(inode)->i_file_acl is protected by XIP2_I(inode)->xattr_sem.
+ * EA blocks are only changed if they are exclusive to an inode, so
+ * holding xattr_sem also means that nothing but the EA block's reference
+ * count will change. Multiple writers to an EA block are synchronized
+ * by the bh lock. No more than a single bh lock is held at any time
+ * to avoid deadlocks.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/mbcache.h>
+#include <linux/quotaops.h>
+#include <linux/rwsem.h>
+#include "xip2.h"
+#include "xattr.h"
+#include "acl.h"
+
+/* These symbols may be needed by a module. */
+EXPORT_SYMBOL(xip2_xattr_register);
+EXPORT_SYMBOL(xip2_xattr_unregister);
+EXPORT_SYMBOL(xip2_xattr_get);
+EXPORT_SYMBOL(xip2_xattr_list);
+
+#define HDR(buffer_ptr) ((struct xip2_xattr_header *)(buffer_ptr))
+#define ENTRY(ptr) ((struct xip2_xattr_entry *)(ptr))
+#define FIRST_ENTRY(buffer_ptr) ENTRY(HDR(buffer_ptr)+1)
+#define IS_LAST_ENTRY(entry) (*(__u32 *)(entry) == 0)
+
+#ifdef EXT2_XATTR_DEBUG
+# define ea_idebug(inode, f...) do { \
+		printk(KERN_DEBUG "inode %s:%ld: ", \
+			inode->i_sb->s_id, inode->i_ino); \
+		printk(f); \
+		printk("\n"); \
+	} while (0)
+# define ea_bdebug(block_ptr, inode, f...) do { \
+		char b[BDEVNAME_SIZE]; \
+		printk(KERN_DEBUG "block %s:%lu: ", \
+			XIP2_SB(inode->i_sb)->mem_area.name, \
+			(unsigned long) block_ptr); \
+		printk(f); \
+		printk("\n"); \
+	} while (0)
+#else
+# define ea_idebug(f...)
+# define ea_bdebug(f...)
+#endif
+
+static struct xip2_xattr_handler *xip2_xattr_handlers[XIP2_XATTR_INDEX_MAX];
+static rwlock_t xip2_handler_lock = RW_LOCK_UNLOCKED;
+
+int
+xip2_xattr_register(int name_index, struct xip2_xattr_handler *handler)
+{
+	int error = -EINVAL;
+
+	if (name_index > 0 && name_index <= XIP2_XATTR_INDEX_MAX) {
+		write_lock(&xip2_handler_lock);
+		if (!xip2_xattr_handlers[name_index-1]) {
+			xip2_xattr_handlers[name_index-1] = handler;
+			error = 0;
+		}
+		write_unlock(&xip2_handler_lock);
+	}
+	return error;
+}
+
+void
+xip2_xattr_unregister(int name_index, struct xip2_xattr_handler *handler)
+{
+	if (name_index > 0 || name_index <= XIP2_XATTR_INDEX_MAX) {
+		write_lock(&xip2_handler_lock);
+		xip2_xattr_handlers[name_index-1] = NULL;
+		write_unlock(&xip2_handler_lock);
+	}
+}
+
+static inline const char *
+strcmp_prefix(const char *a, const char *a_prefix)
+{
+	while (*a_prefix && *a == *a_prefix) {
+		a++;
+		a_prefix++;
+	}
+	return *a_prefix ? NULL : a;
+}
+
+/*
+ * Decode the extended attribute name, and translate it into
+ * the name_index and name suffix.
+ */
+static struct xip2_xattr_handler *
+xip2_xattr_resolve_name(const char **name)
+{
+	struct xip2_xattr_handler *handler = NULL;
+	int i;
+
+	if (!*name)
+		return NULL;
+	read_lock(&xip2_handler_lock);
+	for (i=0; i<XIP2_XATTR_INDEX_MAX; i++) {
+		if (xip2_xattr_handlers[i]) {
+			const char *n = strcmp_prefix(*name,
+				xip2_xattr_handlers[i]->prefix);
+			if (n) {
+				handler = xip2_xattr_handlers[i];
+				*name = n;
+				break;
+			}
+		}
+	}
+	read_unlock(&xip2_handler_lock);
+	return handler;
+}
+
+static inline struct xip2_xattr_handler *
+xip2_xattr_handler(int name_index)
+{
+	struct xip2_xattr_handler *handler = NULL;
+	if (name_index > 0 && name_index <= XIP2_XATTR_INDEX_MAX) {
+		read_lock(&xip2_handler_lock);
+		handler = xip2_xattr_handlers[name_index-1];
+		read_unlock(&xip2_handler_lock);
+	}
+	return handler;
+}
+
+/*
+ * Inode operation getxattr()
+ *
+ * dentry->d_inode->i_sem: don't care
+ */
+ssize_t
+xip2_getxattr(struct dentry *dentry, const char *name,
+	      void *buffer, size_t size)
+{
+	struct xip2_xattr_handler *handler;
+	struct inode *inode = dentry->d_inode;
+
+	handler = xip2_xattr_resolve_name(&name);
+	if (!handler)
+		return -EOPNOTSUPP;
+	return handler->get(inode, name, buffer, size);
+}
+
+/*
+ * Inode operation listxattr()
+ *
+ * dentry->d_inode->i_sem: don't care
+ */
+ssize_t
+xip2_listxattr(struct dentry *dentry, char *buffer, size_t size)
+{
+	return xip2_xattr_list(dentry->d_inode, buffer, size);
+}
+
+/*
+ * xip2_xattr_get()
+ *
+ * Copy an extended attribute into the buffer
+ * provided, or compute the buffer size required.
+ * Buffer is NULL to compute the size of the buffer required.
+ *
+ * Returns a negative error number on failure, or the number of bytes
+ * used / required on success.
+ */
+int
+xip2_xattr_get(struct inode *inode, int name_index, const char *name,
+	       void *buffer, size_t buffer_size)
+{
+	void *block_ptr = NULL;
+	struct xip2_xattr_entry *entry;
+	size_t name_len, size;
+	char *end;
+	int error;
+
+	ea_idebug(inode, "name=%d.%s, buffer=%p, buffer_size=%ld",
+		  name_index, name, buffer, (long)buffer_size);
+
+	if (name == NULL)
+		return -EINVAL;
+	down_read(&XIP2_I(inode)->xattr_sem);
+	error = -ENODATA;
+	if (!XIP2_I(inode)->i_file_acl)
+		goto cleanup;
+	ea_idebug(inode, "reading block %d", XIP2_I(inode)->i_file_acl);
+	block_ptr = xip2_sb_bread(inode->i_sb, XIP2_I(inode)->i_file_acl);
+	error = -EIO;
+	if (!block_ptr)
+		goto cleanup;
+	ea_bdebug(block_ptr, inode, "refcount=%d",
+		le32_to_cpu(HDR(block_ptr)->h_refcount));
+	end = block_ptr + PAGE_SIZE;
+	if (HDR(block_ptr)->h_magic != cpu_to_le32(XIP2_XATTR_MAGIC) ||
+	    HDR(block_ptr)->h_blocks != cpu_to_le32(1)) {
+bad_block:	xip2_error(inode->i_sb, "xip2_xattr_get",
+			"inode %ld: bad block %d", inode->i_ino,
+			XIP2_I(inode)->i_file_acl);
+		error = -EIO;
+		goto cleanup;
+	}
+	/* find named attribute */
+	name_len = strlen(name);
+
+	error = -ERANGE;
+	if (name_len > 255)
+		goto cleanup;
+	entry = FIRST_ENTRY(block_ptr);
+	while (!IS_LAST_ENTRY(entry)) {
+		struct xip2_xattr_entry *next =
+			XIP2_XATTR_NEXT(entry);
+		if ((char *)next >= end)
+			goto bad_block;
+		if (name_index == entry->e_name_index &&
+		    name_len == entry->e_name_len &&
+		    memcmp(name, entry->e_name, name_len) == 0)
+			goto found;
+		entry = next;
+	}
+	/* Check the remaining name entries */
+	while (!IS_LAST_ENTRY(entry)) {
+		struct xip2_xattr_entry *next =
+			XIP2_XATTR_NEXT(entry);
+		if ((char *)next >= end)
+			goto bad_block;
+		entry = next;
+	}
+	error = -ENODATA;
+	goto cleanup;
+found:
+	/* check the buffer size */
+	if (entry->e_value_block != 0)
+		goto bad_block;
+	size = le32_to_cpu(entry->e_value_size);
+	if (size > inode->i_sb->s_blocksize ||
+	    le16_to_cpu(entry->e_value_offs) + size > inode->i_sb->s_blocksize)
+		goto bad_block;
+
+	if (buffer) {
+		error = -ERANGE;
+		if (size > buffer_size)
+			goto cleanup;
+		/* return value of attribute */
+		memcpy(buffer, block_ptr + le16_to_cpu(entry->e_value_offs),
+			size);
+	}
+	error = size;
+
+cleanup:
+	up_read(&XIP2_I(inode)->xattr_sem);
+
+	return error;
+}
+
+/*
+ * xip2_xattr_list()
+ *
+ * Copy a list of attribute names into the buffer
+ * provided, or compute the buffer size required.
+ * Buffer is NULL to compute the size of the buffer required.
+ *
+ * Returns a negative error number on failure, or the number of bytes
+ * used / required on success.
+ */
+int
+xip2_xattr_list(struct inode *inode, char *buffer, size_t buffer_size)
+{
+	void *block_ptr = NULL;
+	struct xip2_xattr_entry *entry;
+	size_t size = 0;
+	char *buf, *end;
+	int error;
+
+	ea_idebug(inode, "buffer=%p, buffer_size=%ld",
+		  buffer, (long)buffer_size);
+
+	down_read(&XIP2_I(inode)->xattr_sem);
+	error = 0;
+	if (!XIP2_I(inode)->i_file_acl)
+		goto cleanup;
+	ea_idebug(inode, "reading block %d", XIP2_I(inode)->i_file_acl);
+	block_ptr = xip2_sb_bread(inode->i_sb, XIP2_I(inode)->i_file_acl);
+	error = -EIO;
+	if (!block_ptr)
+		goto cleanup;
+	ea_bdebug(block_ptr, inode, "refcount=%d",
+		le32_to_cpu(HDR(block_ptr)->h_refcount));
+	end = block_ptr + PAGE_SIZE;
+	if (HDR(block_ptr)->h_magic != cpu_to_le32(XIP2_XATTR_MAGIC) ||
+	    HDR(block_ptr)->h_blocks != cpu_to_le32(1)) {
+bad_block:	xip2_error(inode->i_sb, "xip2_xattr_list",
+			"inode %ld: bad block %d", inode->i_ino,
+			XIP2_I(inode)->i_file_acl);
+		error = -EIO;
+		goto cleanup;
+	}
+	/* compute the size required for the list of attribute names */
+	for (entry = FIRST_ENTRY(block_ptr); !IS_LAST_ENTRY(entry);
+	     entry = XIP2_XATTR_NEXT(entry)) {
+		struct xip2_xattr_handler *handler;
+		struct xip2_xattr_entry *next =
+			XIP2_XATTR_NEXT(entry);
+		if ((char *)next >= end)
+			goto bad_block;
+
+		handler = xip2_xattr_handler(entry->e_name_index);
+		if (handler)
+			size += handler->list(NULL, inode, entry->e_name,
+					      entry->e_name_len);
+	}
+
+	if (!buffer) {
+		error = size;
+		goto cleanup;
+	} else {
+		error = -ERANGE;
+		if (size > buffer_size)
+			goto cleanup;
+	}
+
+	/* list the attribute names */
+	buf = buffer;
+	for (entry = FIRST_ENTRY(block_ptr); !IS_LAST_ENTRY(entry);
+	     entry = XIP2_XATTR_NEXT(entry)) {
+		struct xip2_xattr_handler *handler;
+
+		handler = xip2_xattr_handler(entry->e_name_index);
+		if (handler)
+			buf += handler->list(buf, inode, entry->e_name,
+					     entry->e_name_len);
+	}
+	error = size;
+
+cleanup:
+	up_read(&XIP2_I(inode)->xattr_sem);
+
+	return error;
+}
+
+
+#define NAME_HASH_SHIFT 5
+#define VALUE_HASH_SHIFT 16
+
+/*
+ * xip2_xattr_hash_entry()
+ *
+ * Compute the hash of an extended attribute.
+ */
+static inline void xip2_xattr_hash_entry(struct xip2_xattr_header *header,
+					 struct xip2_xattr_entry *entry)
+{
+	__u32 hash = 0;
+	char *name = entry->e_name;
+	int n;
+
+	for (n=0; n < entry->e_name_len; n++) {
+		hash = (hash << NAME_HASH_SHIFT) ^
+		       (hash >> (8*sizeof(hash) - NAME_HASH_SHIFT)) ^
+		       *name++;
+	}
+
+	if (entry->e_value_block == 0 && entry->e_value_size != 0) {
+		__u32 *value = (__u32 *)((char *)header +
+			le16_to_cpu(entry->e_value_offs));
+		for (n = (le32_to_cpu(entry->e_value_size) +
+		     XIP2_XATTR_ROUND) >> XIP2_XATTR_PAD_BITS; n; n--) {
+			hash = (hash << VALUE_HASH_SHIFT) ^
+			       (hash >> (8*sizeof(hash) - VALUE_HASH_SHIFT)) ^
+			       le32_to_cpu(*value++);
+		}
+	}
+	entry->e_hash = cpu_to_le32(hash);
+}
+
+#undef NAME_HASH_SHIFT
+#undef VALUE_HASH_SHIFT
+
+int __init
+init_xip2_xattr(void)
+{
+	int	err;
+
+	err = xip2_xattr_register(XIP2_XATTR_INDEX_USER,
+				  &xip2_xattr_user_handler);
+	if (err)
+		return err;
+	err = xip2_xattr_register(XIP2_XATTR_INDEX_TRUSTED,
+				  &xip2_xattr_trusted_handler);
+	if (err)
+		goto out;
+#ifdef CONFIG_XIP2_FS_SECURITY
+	err = xip2_xattr_register(XIP2_XATTR_INDEX_SECURITY,
+				  &xip2_xattr_security_handler);
+	if (err)
+		goto out1;
+#endif
+#ifdef CONFIG_XIP2_FS_POSIX_ACL
+	err = init_xip2_acl();
+	if (err)
+		goto out2;
+#endif
+	return 0;
+#ifdef CONFIG_XIP2_FS_POSIX_ACL
+out2:
+#endif
+#ifdef CONFIG_XIP2_FS_SECURITY
+	xip2_xattr_unregister(XIP2_XATTR_INDEX_SECURITY,
+			      &xip2_xattr_security_handler);
+out1:
+#endif
+	xip2_xattr_unregister(XIP2_XATTR_INDEX_TRUSTED,
+			      &xip2_xattr_trusted_handler);
+out:
+	xip2_xattr_unregister(XIP2_XATTR_INDEX_USER,
+			      &xip2_xattr_user_handler);
+	return err;
+}
+
+void
+exit_xip2_xattr(void)
+{
+#ifdef CONFIG_XIP2_FS_POSIX_ACL
+	exit_xip2_acl();
+#endif
+#ifdef CONFIG_XIP2_FS_SECURITY
+	xip2_xattr_unregister(XIP2_XATTR_INDEX_SECURITY,
+			      &xip2_xattr_security_handler);
+#endif
+	xip2_xattr_unregister(XIP2_XATTR_INDEX_TRUSTED,
+			      &xip2_xattr_trusted_handler);
+	xip2_xattr_unregister(XIP2_XATTR_INDEX_USER,
+			      &xip2_xattr_user_handler);
+}
diff -ruN linux-2.6.5/fs/xip2fs/xattr.h linux-2.6.5+xip/fs/xip2fs/xattr.h
--- linux-2.6.5/fs/xip2fs/xattr.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5+xip/fs/xip2fs/xattr.h	2004-04-29 14:04:09.000000000 +0200
@@ -0,0 +1,116 @@
+/*
+ *  linux/fs/xip2fs/xattr.h, Version 1
+ *
+ * (C) Copyright IBM Corp. 2002,2004
+ * Author(s): Carsten Otte <cotte@de.ibm.com>
+ *            Gerald Schaefer <geraldsc@de.ibm.com>
+ * derived from second extended filesystem (ext2)
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/xattr.h>
+
+/* Magic value in attribute blocks */
+#define XIP2_XATTR_MAGIC		0xEA020000
+
+/* Maximum number of references to one attribute block */
+#define XIP2_XATTR_REFCOUNT_MAX		1024
+
+/* Name indexes */
+#define XIP2_XATTR_INDEX_MAX			10
+#define XIP2_XATTR_INDEX_USER			1
+#define XIP2_XATTR_INDEX_POSIX_ACL_ACCESS	2
+#define XIP2_XATTR_INDEX_POSIX_ACL_DEFAULT	3
+#define XIP2_XATTR_INDEX_TRUSTED		4
+#define XIP2_XATTR_INDEX_LUSTRE 		5
+#define XIP2_XATTR_INDEX_SECURITY		6
+
+struct xip2_xattr_header {
+	__u32	h_magic;	/* magic number for identification */
+	__u32	h_refcount;	/* reference count */
+	__u32	h_blocks;	/* number of disk blocks used */
+	__u32	h_hash;		/* hash value of all attributes */
+	__u32	h_reserved[4];	/* zero right now */
+};
+
+struct xip2_xattr_entry {
+	__u8	e_name_len;	/* length of name */
+	__u8	e_name_index;	/* attribute name index */
+	__u16	e_value_offs;	/* offset in disk block of value */
+	__u32	e_value_block;	/* disk block attribute is stored on (n/i) */
+	__u32	e_value_size;	/* size of attribute value */
+	__u32	e_hash;		/* hash value of name and value */
+	char	e_name[0];	/* attribute name */
+};
+
+#define XIP2_XATTR_PAD_BITS		2
+#define XIP2_XATTR_PAD		(1<<XIP2_XATTR_PAD_BITS)
+#define XIP2_XATTR_ROUND		(XIP2_XATTR_PAD-1)
+#define XIP2_XATTR_LEN(name_len) \
+	(((name_len) + XIP2_XATTR_ROUND + \
+	sizeof(struct xip2_xattr_entry)) & ~XIP2_XATTR_ROUND)
+#define XIP2_XATTR_NEXT(entry) \
+	( (struct xip2_xattr_entry *)( \
+	  (char *)(entry) + XIP2_XATTR_LEN((entry)->e_name_len)) )
+#define XIP2_XATTR_SIZE(size) \
+	(((size) + XIP2_XATTR_ROUND) & ~XIP2_XATTR_ROUND)
+
+# ifdef CONFIG_XIP2_FS_XATTR
+
+struct xip2_xattr_handler {
+	char *prefix;
+	size_t (*list)(char *list, struct inode *inode, const char *name,
+		       int name_len);
+	int (*get)(struct inode *inode, const char *name, void *buffer,
+		   size_t size);
+	int (*set)(struct inode *inode, const char *name, const void *buffer,
+		   size_t size, int flags);
+};
+
+extern int xip2_xattr_register(int, struct xip2_xattr_handler *);
+extern void xip2_xattr_unregister(int, struct xip2_xattr_handler *);
+
+extern ssize_t xip2_getxattr(struct dentry *, const char *, void *, size_t);
+extern ssize_t xip2_listxattr(struct dentry *, char *, size_t);
+
+extern int xip2_xattr_get(struct inode *, int, const char *, void *, size_t);
+extern int xip2_xattr_list(struct inode *, char *, size_t);
+
+extern int init_xip2_xattr(void);
+extern void exit_xip2_xattr(void);
+
+# else  /* CONFIG_XIP2_FS_XATTR */
+#  define xip2_getxattr		NULL
+#  define xip2_listxattr	NULL
+
+static inline int
+xip2_xattr_get(struct inode *inode, int name_index,
+	       const char *name, void *buffer, size_t size)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline int
+xip2_xattr_list(struct inode *inode, char *buffer, size_t size)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline int
+init_xip2_xattr(void)
+{
+	return 0;
+}
+
+static inline void
+exit_xip2_xattr(void)
+{
+}
+
+# endif  /* CONFIG_XIP2_FS_XATTR */
+
+extern struct xip2_xattr_handler xip2_xattr_user_handler;
+extern struct xip2_xattr_handler xip2_xattr_trusted_handler;
+extern struct xip2_xattr_handler xip2_xattr_security_handler;
+
diff -ruN linux-2.6.5/fs/xip2fs/xattr_security.c linux-2.6.5+xip/fs/xip2fs/xattr_security.c
--- linux-2.6.5/fs/xip2fs/xattr_security.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5+xip/fs/xip2fs/xattr_security.c	2004-04-29 14:04:09.000000000 +0200
@@ -0,0 +1,45 @@
+/*
+ *  linux/fs/xip2fs/xattr_security.c, Version 1
+ *
+ * (C) Copyright IBM Corp. 2002,2004
+ * Author(s): Carsten Otte <cotte@de.ibm.com>
+ *            Gerald Schaefer <geraldsc@de.ibm.com>
+ * derived from second extended filesystem (ext2)
+ */
+
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/fs.h>
+#include <linux/smp_lock.h>
+#include <linux/xip2_fs.h>
+#include "xattr.h"
+
+static size_t
+xip2_xattr_security_list(char *list, struct inode *inode,
+			const char *name, int name_len)
+{
+	const int prefix_len = sizeof(XATTR_SECURITY_PREFIX)-1;
+
+	if (list) {
+		memcpy(list, XATTR_SECURITY_PREFIX, prefix_len);
+		memcpy(list+prefix_len, name, name_len);
+		list[prefix_len + name_len] = '\0';
+	}
+	return prefix_len + name_len + 1;
+}
+
+static int
+xip2_xattr_security_get(struct inode *inode, const char *name,
+		       void *buffer, size_t size)
+{
+	if (strcmp(name, "") == 0)
+		return -EINVAL;
+	return xip2_xattr_get(inode, XIP2_XATTR_INDEX_SECURITY, name,
+			      buffer, size);
+}
+
+struct xip2_xattr_handler xip2_xattr_security_handler = {
+	.prefix	= XATTR_SECURITY_PREFIX,
+	.list	= xip2_xattr_security_list,
+	.get	= xip2_xattr_security_get,
+};
diff -ruN linux-2.6.5/fs/xip2fs/xattr_trusted.c linux-2.6.5+xip/fs/xip2fs/xattr_trusted.c
--- linux-2.6.5/fs/xip2fs/xattr_trusted.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5+xip/fs/xip2fs/xattr_trusted.c	2004-04-29 14:04:10.000000000 +0200
@@ -0,0 +1,53 @@
+/*
+ *  linux/fs/xip2fs/xattr_trusted.c, Version 1
+ *
+ * (C) Copyright IBM Corp. 2002,2004
+ * Author(s): Carsten Otte <cotte@de.ibm.com>
+ *            Gerald Schaefer <geraldsc@de.ibm.com>
+ * derived from second extended filesystem (ext2)
+ */
+
+
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/fs.h>
+#include <linux/smp_lock.h>
+#include <linux/xip2_fs.h>
+#include "xattr.h"
+
+#define XATTR_TRUSTED_PREFIX "trusted."
+
+static size_t
+xip2_xattr_trusted_list(char *list, struct inode *inode,
+			const char *name, int name_len)
+{
+	const int prefix_len = sizeof(XATTR_TRUSTED_PREFIX)-1;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return 0;
+
+	if (list) {
+		memcpy(list, XATTR_TRUSTED_PREFIX, prefix_len);
+		memcpy(list+prefix_len, name, name_len);
+		list[prefix_len + name_len] = '\0';
+	}
+	return prefix_len + name_len + 1;
+}
+
+static int
+xip2_xattr_trusted_get(struct inode *inode, const char *name,
+		       void *buffer, size_t size)
+{
+	if (strcmp(name, "") == 0)
+		return -EINVAL;
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+	return xip2_xattr_get(inode, XIP2_XATTR_INDEX_TRUSTED, name,
+			      buffer, size);
+}
+
+struct xip2_xattr_handler xip2_xattr_trusted_handler = {
+	.prefix	= XATTR_TRUSTED_PREFIX,
+	.list	= xip2_xattr_trusted_list,
+	.get	= xip2_xattr_trusted_get,
+};
diff -ruN linux-2.6.5/fs/xip2fs/xattr_user.c linux-2.6.5+xip/fs/xip2fs/xattr_user.c
--- linux-2.6.5/fs/xip2fs/xattr_user.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5+xip/fs/xip2fs/xattr_user.c	2004-04-29 14:04:10.000000000 +0200
@@ -0,0 +1,70 @@
+/*
+ *  linux/fs/xip2fs/xattr_user.c, Version 1
+ *
+ * (C) Copyright IBM Corp. 2002,2004
+ * Author(s): Carsten Otte <cotte@de.ibm.com>
+ *            Gerald Schaefer <geraldsc@de.ibm.com>
+ * derived from second extended filesystem (ext2)
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include "xip2.h"
+#include "xattr.h"
+
+#define XATTR_USER_PREFIX "user."
+
+static size_t
+xip2_xattr_user_list(char *list, struct inode *inode,
+		     const char *name, int name_len)
+{
+	const int prefix_len = sizeof(XATTR_USER_PREFIX)-1;
+
+	if (!test_opt(inode->i_sb, XATTR_USER))
+		return 0;
+
+	if (list) {
+		memcpy(list, XATTR_USER_PREFIX, prefix_len);
+		memcpy(list+prefix_len, name, name_len);
+		list[prefix_len + name_len] = '\0';
+	}
+	return prefix_len + name_len + 1;
+}
+
+static int
+xip2_xattr_user_get(struct inode *inode, const char *name,
+		    void *buffer, size_t size)
+{
+	int error;
+
+	if (strcmp(name, "") == 0)
+		return -EINVAL;
+	if (!test_opt(inode->i_sb, XATTR_USER))
+		return -EOPNOTSUPP;
+	error = permission(inode, MAY_READ, NULL);
+	if (error)
+		return error;
+
+	return xip2_xattr_get(inode, XIP2_XATTR_INDEX_USER, name, buffer, size);
+}
+
+struct xip2_xattr_handler xip2_xattr_user_handler = {
+	.prefix	= XATTR_USER_PREFIX,
+	.list	= xip2_xattr_user_list,
+	.get	= xip2_xattr_user_get,
+};
+
+int __init
+init_xip2_xattr_user(void)
+{
+	return xip2_xattr_register(XIP2_XATTR_INDEX_USER,
+				   &xip2_xattr_user_handler);
+}
+
+void
+exit_xip2_xattr_user(void)
+{
+	xip2_xattr_unregister(XIP2_XATTR_INDEX_USER,
+			      &xip2_xattr_user_handler);
+}
diff -ruN linux-2.6.5/fs/xip2fs/xip2.h linux-2.6.5+xip/fs/xip2fs/xip2.h
--- linux-2.6.5/fs/xip2fs/xip2.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5+xip/fs/xip2fs/xip2.h	2004-04-29 14:04:10.000000000 +0200
@@ -0,0 +1,146 @@
+/*
+ *  linux/fs/xip2fs/xip2.h      , Version 1
+ *
+ * (C) Copyright IBM Corp. 2002,2004
+ * Author(s): Carsten Otte <cotte@de.ibm.com>
+ *            Gerald Schaefer <geraldsc@de.ibm.com>
+ * derived from second extended filesystem (ext2)
+ */
+
+
+#include <linux/fs.h>
+#include <linux/xip2_fs.h>
+
+/*
+ * second extended file system inode data in memory
+ */
+struct xip2_inode_info {
+	__u32	i_data[15];
+	__u32	i_flags;
+	__u32	i_faddr;
+	__u8	i_frag_no;
+	__u8	i_frag_size;
+	__u16	i_state;
+	__u32	i_file_acl;
+	__u32	i_dir_acl;
+	__u32	i_dtime;
+
+	/*
+	 * i_block_group is the number of the block group which contains
+	 * this file's inode.  Constant across the lifetime of the inode,
+	 * it is ued for making block allocation decisions - we try to
+	 * place a file's data blocks near its inode block, and new inodes
+	 * near to their parent directory's inode.
+	 */
+	__u32	i_block_group;
+
+	/*
+	 * i_next_alloc_block is the logical (file-relative) number of the
+	 * most-recently-allocated block in this file.  Yes, it is misnamed.
+	 * We use this for detecting linearly ascending allocation requests.
+	 */
+	__u32	i_next_alloc_block;
+
+	/*
+	 * i_next_alloc_goal is the *physical* companion to i_next_alloc_block.
+	 * it the the physical block number of the block which was most-recently
+	 * allocated to this file.  This give us the goal (target) for the next
+	 * allocation when we detect linearly ascending requests.
+	 */
+	__u32	i_next_alloc_goal;
+	__u32	i_prealloc_block;
+	__u32	i_prealloc_count;
+	__u32	i_dir_start_lookup;
+#ifdef CONFIG_XIP2_FS_XATTR
+	/*
+	 * Extended attributes can be read independently of the main file
+	 * data. Taking i_sem even when reading would cause contention
+	 * between readers of EAs and writers of regular file data, so
+	 * instead we synchronize on xattr_sem when reading or changing
+	 * EAs.
+	 */
+	struct rw_semaphore xattr_sem;
+#endif
+#ifdef CONFIG_XIP2_FS_POSIX_ACL
+	struct posix_acl	*i_acl;
+	struct posix_acl	*i_default_acl;
+#endif
+	rwlock_t i_meta_lock;
+	struct inode	vfs_inode;
+};
+
+/*
+ * Function prototypes
+ */
+
+/*
+ * Ok, these declarations are also in <linux/kernel.h> but none of the
+ * ext2 source programs needs to include it so they are duplicated here.
+ */
+
+static inline struct xip2_inode_info *XIP2_I(struct inode *inode)
+{
+	return container_of(inode, struct xip2_inode_info, vfs_inode);
+}
+
+/* balloc.c */
+extern int xip2_bg_has_super(struct super_block *sb, int group);
+extern unsigned long xip2_bg_num_gdb(struct super_block *sb, int group);
+extern unsigned long xip2_count_free_blocks (struct super_block *);
+extern unsigned long xip2_count_dirs (struct super_block *);
+extern void xip2_check_blocks_bitmap (struct super_block *);
+extern struct ext2_group_desc * xip2_get_group_desc(struct super_block * sb,
+						    unsigned int block_group,
+						    void ** bh);
+
+/* dir.c */
+extern ino_t xip2_inode_by_name(struct inode *, struct dentry *);
+
+/* ialloc.c */
+extern unsigned long xip2_count_free_inodes (struct super_block *);
+extern void xip2_check_inodes_bitmap (struct super_block *);
+extern unsigned long xip2_count_free (void *, unsigned);
+
+/* inode.c */
+extern void xip2_read_inode (struct inode *);
+extern void xip2_set_inode_flags(struct inode *inode);
+extern int  xip2_get_block (struct inode *inode, unsigned long iblock,
+			    sector_t *blockno_result, int create);
+
+/* ioctl.c */
+extern int xip2_ioctl (struct inode *, struct file *, unsigned int,
+		       unsigned long);
+
+/* super.c */
+extern void xip2_error (struct super_block *, const char *, const char *, ...)
+	__attribute__ ((format (printf, 3, 4)));
+extern NORET_TYPE void xip2_panic (struct super_block *, const char *,
+				   const char *, ...)
+	__attribute__ ((NORET_AND format (printf, 3, 4)));
+extern void xip2_warning (struct super_block *, const char *, const char *, ...)
+	__attribute__ ((format (printf, 3, 4)));
+extern void xip2_update_dynamic_rev (struct super_block *sb);
+void *xip2_sb_bread (struct super_block *sb, sector_t block);
+
+/*
+ * Inodes and files operations
+ */
+
+/* dir.c */
+extern struct file_operations xip2_dir_operations;
+
+/* file.c */
+extern struct inode_operations xip2_file_inode_operations;
+extern struct file_operations xip2_file_operations;
+
+/* inode.c */
+extern struct address_space_operations xip2_aops;
+extern struct address_space_operations xip2_nobh_aops;
+
+/* namei.c */
+extern struct inode_operations xip2_dir_inode_operations;
+extern struct inode_operations xip2_special_inode_operations;
+
+/* symlink.c */
+extern struct inode_operations xip2_fast_symlink_inode_operations;
+extern struct inode_operations xip2_symlink_inode_operations;
diff -ruN linux-2.6.5/include/linux/xip2_fs.h linux-2.6.5+xip/include/linux/xip2_fs.h
--- linux-2.6.5/include/linux/xip2_fs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5+xip/include/linux/xip2_fs.h	2004-04-29 14:04:10.000000000 +0200
@@ -0,0 +1,42 @@
+/*
+ *  linux/include/linux/xip2_fs.h, Version 1
+ *
+ * (C) Copyright IBM Corp. 2002,2004
+ * Author(s): Carsten Otte <cotte@de.ibm.com>
+ *            Gerald Schaefer <geraldsc@de.ibm.com>
+ * derived from second extended filesystem (ext2)
+ */
+
+#ifndef __XIP2FS_H
+#define __XIP2FS_H
+#include <linux/ext2_fs.h>
+#include <linux/xip2_fs_sb.h>
+#ifdef __KERNEL__
+static inline struct xip2_sb_info * XIP2_SB (struct super_block *sb)
+{
+	return (struct xip2_sb_info *) sb->s_fs_info;
+}
+#else
+#define XIP2_SB(sb)	(sb)
+#endif
+#define XIP2_ADDR_PER_BLOCK_BITS(s)	(XIP2_SB(s)->s_addr_per_block_bits)
+#define XIP2_INODE_SIZE(s)		(XIP2_SB(s)->s_inode_size)
+#define XIP2_FIRST_INO(s)		(XIP2_SB(s)->s_first_ino)
+#define XIP2_BLOCKS_PER_GROUP(s)	(XIP2_SB(s)->s_blocks_per_group)
+#define XIP2_DESC_PER_BLOCK(s)		(XIP2_SB(s)->s_desc_per_block)
+#define XIP2_INODES_PER_GROUP(s)	(XIP2_SB(s)->s_inodes_per_group)
+#undef test_opt
+#define test_opt(sb, opt)		(XIP2_SB(sb)->s_mount_opt & \
+					 EXT2_MOUNT_##opt)
+#define XIP2_HAS_COMPAT_FEATURE(sb,mask)			\
+	( XIP2_SB(sb)->s_es->s_feature_compat & cpu_to_le32(mask) )
+#define XIP2_HAS_RO_COMPAT_FEATURE(sb,mask)			\
+	( XIP2_SB(sb)->s_es->s_feature_ro_compat & cpu_to_le32(mask) )
+#define XIP2_HAS_INCOMPAT_FEATURE(sb,mask)			\
+	( XIP2_SB(sb)->s_es->s_feature_incompat & cpu_to_le32(mask) )
+#define xip2_test_bit			ext2_test_bit
+#define xip2_clear_bit_atomic		ext2_clear_bit_atomic
+#define xip2_find_next_zero_bit		ext2_find_next_zero_bit
+#define xip2_find_first_zero_bit	ext2_find_first_zero_bit
+#define xip2_set_bit_atomic		ext2_set_bit_atomic
+#endif
diff -ruN linux-2.6.5/include/linux/xip2_fs_sb.h linux-2.6.5+xip/include/linux/xip2_fs_sb.h
--- linux-2.6.5/include/linux/xip2_fs_sb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5+xip/include/linux/xip2_fs_sb.h	2004-04-29 14:04:10.000000000 +0200
@@ -0,0 +1,59 @@
+/*
+ *  linux/include/linux/xip2_fs_sb.h, Version 1
+ *
+ * (C) Copyright IBM Corp. 2002,2004
+ * Author(s): Carsten Otte <cotte@de.ibm.com>
+ *            Gerald Schaefer <geraldsc@de.ibm.com>
+ * derived from second extended filesystem (ext2)
+ */
+#ifndef _LINUX_XIP2_FS_SB
+#define _LINUX_XIP2_FS_SB
+
+#ifndef _LINUX_EXT2_FS_SB
+#include <linux/blockgroup_lock.h>
+#include <linux/percpu_counter.h>
+#endif
+
+struct xip2_mem_area_t {
+	char 		*name;
+	unsigned long 	start;
+	unsigned long	end;
+};
+
+/*
+ * second extended-fs super-block data in memory
+ */
+struct xip2_sb_info {
+	unsigned long s_frag_size;	/* Size of a fragment in bytes */
+	unsigned long s_frags_per_block;/* Number of fragments per block */
+	unsigned long s_inodes_per_block;/* Number of inodes per block */
+	unsigned long s_frags_per_group;/* Number of fragments in a group */
+	unsigned long s_blocks_per_group;/* Number of blocks in a group */
+	unsigned long s_inodes_per_group;/* Number of inodes in a group */
+	unsigned long s_itb_per_group;	/* Number of inode table blocks per group */
+	unsigned long s_gdb_count;	/* Number of group descriptor blocks */
+	unsigned long s_desc_per_block;	/* Number of group descriptors per block */
+	unsigned long s_groups_count;	/* Number of groups in the fs */
+	struct ext2_super_block * s_es;	/* Pointer to the super block in the buffer */
+	void ** s_group_desc;
+	unsigned long  s_mount_opt;
+	uid_t s_resuid;
+	gid_t s_resgid;
+	unsigned short s_mount_state;
+	unsigned short s_pad;
+	int s_addr_per_block_bits;
+	int s_desc_per_block_bits;
+	int s_inode_size;
+	int s_first_ino;
+	spinlock_t s_next_gen_lock;
+	u32 s_next_generation;
+	unsigned long s_dir_count;
+	u8 *s_debts;
+	struct percpu_counter s_freeblocks_counter;
+	struct percpu_counter s_freeinodes_counter;
+	struct percpu_counter s_dirs_counter;
+	struct blockgroup_lock s_blockgroup_lock;
+	struct xip2_mem_area_t mem_area;
+};
+
+#endif	/* _LINUX_EXT2_FS_SB */

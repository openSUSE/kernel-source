Subject: Quickcam Express Webcam drivers
From: Olaf Hering <olh@suse.de>
References: SUSE32497

>From http://qce-ga.sourceforge.net/
qc-usb-0.6.2
This driver will never go into mainline in its current layout.
getting jpeg decoders into the kernel is a real challenge.

diff -purN linux-2.6.10.orig/drivers/usb/media/qc/Makefile linux-2.6.10-qc-usb/drivers/usb/media/qc/Makefile
--- linux-2.6.10.orig/drivers/usb/media/qc/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-qc-usb/drivers/usb/media/qc/Makefile	2005-01-07 14:43:01.613874995 +0100
@@ -0,0 +1,31 @@
+#
+# qc-usb, Logitech QuickCam video driver with V4L support
+# Derived from qce-ga, linux V4L driver for the QuickCam Express and Dexxa QuickCam
+#
+# Makefile - driver build system
+#
+# Copyright (C) 2003  Tuukka Toivonen
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#
+#
+
+# Called recursively by 2.6.x kernel build process
+
+EXTRA_CFLAGS += -DNOKERNEL
+
+quickcam-objs 	:= qc-driver.o qc-hdcs.o qc-pb0100.o qc-vv6410.o qc-formats.o qc-mjpeg.o qc-memory.o
+obj-$(CONFIG_USB_QC)		+= quickcam.o
+
diff -purN linux-2.6.10.orig/drivers/usb/media/qc/qc-driver.c linux-2.6.10-qc-usb/drivers/usb/media/qc/qc-driver.c
--- linux-2.6.10.orig/drivers/usb/media/qc/qc-driver.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-qc-usb/drivers/usb/media/qc/qc-driver.c	2005-01-07 14:55:46.297226559 +0100
@@ -0,0 +1,3389 @@
+/* Start of file */
+
+/* {{{ [fold] Comments  */
+
+/*
+ * qc-usb, Logitech QuickCam video driver with V4L support
+ * Derived from qce-ga, linux V4L driver for the QuickCam Express and Dexxa QuickCam
+ *
+ * qc-driver.c - main driver part
+ *
+ * Copyright (C) 2001  Jean-Fredric Clere, Nikolas Zimmermann, Georg Acher
+ * Mark Cave-Ayland, Carlo E Prelz, Dick Streefland
+ * Copyright (C) 2002,2003  Tuukka Toivonen
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+/* Cam variations of Logitech QuickCam:
+   P/N 861037:      Sensor HDCS1000        ASIC STV0600
+   P/N 861050-0010: Sensor HDCS1000        ASIC STV0600
+   P/N 861050-0020: Sensor Photobit PB100  ASIC STV0600-1 ("QuickCam Express")
+   P/N 861055:      Sensor ST VV6410       ASIC STV0610 ("LEGO cam")
+   P/N 861075-0040: Sensor HDCS1000        ASIC
+   P/N 961179-0700: Sensor ST VV6410       ASIC STV0602 (Dexxa WebCam USB)
+   P/N 861040-0000: Sensor ST VV6410       ASIC STV0610 ("QuickCam Web")
+
+   For any questions ask 
+   	qce-ga-devel@lists.sourceforge.net	- about code
+   	qce-ga-discussion@lists.sourceforge.net	- about usage
+*/
+/* }}} */
+/* {{{ [fold] Includes  */
+#ifdef NOKERNEL
+#include "quickcam.h"
+#else
+#include <linux/quickcam.h>
+#endif
+#include <linux/module.h>
+
+#include "qc-memory.h"
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+#include <linux/slab.h>
+#else
+#include <linux/malloc.h>
+#endif
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/list.h>
+#include <linux/mm.h>
+#include <linux/proc_fs.h>
+#include <linux/smp_lock.h>
+#include <linux/vmalloc.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/page.h>
+#include <linux/capability.h>
+#include <linux/poll.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#include <linux/moduleparam.h>
+#endif
+/* }}} */
+/* {{{ [fold] Module parameters  */
+MODULE_PARM_DESC(qcdebug, "Sets the debug output (bitfield)");
+MODULE_PARM(qcdebug, "i");
+int qcdebug = DEBUGLEVEL;
+
+MODULE_PARM_DESC(keepsettings, "Keep picture settings across one open to another (0-1)");
+MODULE_PARM(keepsettings, "i");
+static int keepsettings = 0;
+
+MODULE_PARM_DESC(settle, "Maximum number of frames to wait picture brightness to settle (0-255)");
+MODULE_PARM(settle, "i");
+static int settle = 0;
+
+/* Subsampling is used to allow higher scan rate with smaller images. */
+MODULE_PARM_DESC(subsample, "Sets subsampling (0-1)");
+MODULE_PARM(subsample, "i");
+static int subsample = 0;	/* normal or sub-sample (sub-sample to increase the speed) */
+
+MODULE_PARM_DESC(compress, "Enable compressed mode (0-1)");
+MODULE_PARM(compress, "i");
+static int compress = 0;	/* Enable compressed mode if available (higher framerate) */
+
+MODULE_PARM_DESC(frameskip, "How frequently capture frames (0-10)");
+MODULE_PARM(frameskip, "i");
+static int frameskip = 0;
+
+MODULE_PARM_DESC(quality, "Sets the picture quality (0-5)");
+MODULE_PARM(quality, "i");
+static int quality = 5;		/* 5 = generalized adjustable Pei-Tam method */
+
+MODULE_PARM_DESC(adaptive, "Automatic adaptive brightness control (0-1)");
+MODULE_PARM(adaptive, "i");
+static int adaptive = 1;
+
+MODULE_PARM_DESC(equalize, "Equalize image (0-1)");
+MODULE_PARM(equalize, "i");
+static int equalize = 0;	/* Disabled by default */
+
+MODULE_PARM_DESC(userlut, "Apply user-specified lookup-table (0-1)");
+MODULE_PARM(userlut, "i");
+static int userlut = 0;		/* Disabled by default */
+
+MODULE_PARM_DESC(retryerrors, "Retry if image capture fails, otherwise return error code (0-1)");
+MODULE_PARM(retryerrors, "i");
+static int retryerrors = 1;	/* Enabled by default */
+
+/* Bug in Xvideo(?): if the width is not divisible by 8 and Xvideo is used, the frame is shown wrongly */
+MODULE_PARM_DESC(compatible, "Enable workaround for bugs in application programs (bitfield)");
+MODULE_PARM(compatible, "i");
+static int compatible = 0;	/* Disabled by default */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,5)
+MODULE_PARM_DESC(video_nr, "Set videodevice number (/dev/videoX)");
+MODULE_PARM(video_nr,"i");
+/* video_nr option allows to specify a certain /dev/videoX device */
+/* (like /dev/video0 or /dev/video1 ...)                          */
+/* for autodetect first available use video_nr=-1 (defaultvalue)  */
+static int video_nr = -1;
+#endif
+/* }}} */
+/* {{{ [fold] Miscellaneous data  */
+#ifndef MODULE_LICENSE		/* Appeared in 2.4.10 */
+#ifdef MODULE
+#define MODULE_LICENSE(license) \
+static const char __module_license[] __attribute__((section(".modinfo"))) = \
+	"license=" license
+#else
+#define MODULE_LICENSE(license)
+#endif
+#endif
+
+MODULE_SUPPORTED_DEVICE("video");
+MODULE_DESCRIPTION("Logitech QuickCam USB driver");
+MODULE_AUTHOR("See README");
+MODULE_LICENSE("GPL");
+EXPORT_NO_SYMBOLS;
+
+static const int min_framewidth  = 32;	/* Minimum image size we allow delivering to user application */
+static const int min_frameheight = 32;
+
+static const char qc_proc_name[] = "video/quickcam";
+#define qc_name (&qc_proc_name[6])
+
+static struct usb_device_id qc_device_table[] = {
+	{ USB_DEVICE(0x046D, 0x0840) },		/* QuickCam Express */
+	{ USB_DEVICE(0x046D, 0x0850) },		/* LEGO cam / QuickCam Web */
+	{ USB_DEVICE(0x046D, 0x0870) },		/* Dexxa WebCam USB */
+	{ }
+};
+MODULE_DEVICE_TABLE(usb, qc_device_table);
+
+extern const struct qc_sensor qc_sensor_pb0100;
+extern const struct qc_sensor qc_sensor_hdcs1000;
+extern const struct qc_sensor qc_sensor_hdcs1020;
+extern const struct qc_sensor qc_sensor_vv6410;
+
+static const struct qc_sensor *sensors[] = {
+	&qc_sensor_hdcs1000,
+	&qc_sensor_hdcs1020,
+	&qc_sensor_pb0100,
+	&qc_sensor_vv6410,
+};
+
+static LIST_HEAD(quickcam_list);		/* Linked list containing all QuickCams */
+static DECLARE_MUTEX(quickcam_list_lock);	/* Always lock first quickcam_list_lock, then qc->lock */
+
+/* Default values for user-specified lookup-table; may be overwritten by user */
+static unsigned char userlut_contents[QC_LUT_SIZE] = {
+	/* Red */
+	0, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
+	18, 18, 18, 18, 18, 18, 18, 25, 30, 35, 38, 42,
+	44, 47, 50, 53, 54, 57, 59, 61, 63, 65, 67, 69,
+	71, 71, 73, 75, 77, 78, 80, 81, 82, 84, 85, 87,
+	88, 89, 90, 91, 93, 94, 95, 97, 98, 98, 99, 101,
+	102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113,
+	114, 115, 116, 116, 117, 118, 119, 120, 121, 122, 123, 124,
+	125, 125, 126, 127, 128, 129, 129, 130, 131, 132, 133, 134,
+	134, 135, 135, 136, 137, 138, 139, 140, 140, 141, 142, 143,
+	143, 143, 144, 145, 146, 147, 147, 148, 149, 150, 150, 151,
+	152, 152, 152, 153, 154, 154, 155, 156, 157, 157, 158, 159,
+	159, 160, 161, 161, 161, 162, 163, 163, 164, 165, 165, 166,
+	167, 167, 168, 168, 169, 170, 170, 170, 171, 171, 172, 173,
+	173, 174, 174, 175, 176, 176, 177, 178, 178, 179, 179, 179,
+	180, 180, 181, 181, 182, 183, 183, 184, 184, 185, 185, 186,
+	187, 187, 188, 188, 188, 188, 189, 190, 190, 191, 191, 192,
+	192, 193, 193, 194, 195, 195, 196, 196, 197, 197, 197, 197,
+	198, 198, 199, 199, 200, 201, 201, 202, 202, 203, 203, 204,
+	204, 205, 205, 206, 206, 206, 206, 207, 207, 208, 208, 209,
+	209, 210, 210, 211, 211, 212, 212, 213, 213, 214, 214, 215,
+	215, 215, 215, 216, 216, 217, 217, 218, 218, 218, 219, 219,
+	220, 220, 221, 221,
+
+	/* Green */
+	0, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
+	21, 21, 21, 21, 21, 21, 21, 28, 34, 39, 43, 47,
+	50, 53, 56, 59, 61, 64, 66, 68, 71, 73, 75, 77,
+	79, 80, 82, 84, 86, 87, 89, 91, 92, 94, 95, 97,
+	98, 100, 101, 102, 104, 105, 106, 108, 109, 110, 111, 113,
+	114, 115, 116, 117, 118, 120, 121, 122, 123, 124, 125, 126,
+	127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138,
+	139, 140, 141, 142, 143, 144, 144, 145, 146, 147, 148, 149,
+	150, 151, 151, 152, 153, 154, 155, 156, 156, 157, 158, 159,
+	160, 160, 161, 162, 163, 164, 164, 165, 166, 167, 167, 168,
+	169, 170, 170, 171, 172, 172, 173, 174, 175, 175, 176, 177,
+	177, 178, 179, 179, 180, 181, 182, 182, 183, 184, 184, 185,
+	186, 186, 187, 187, 188, 189, 189, 190, 191, 191, 192, 193,
+	193, 194, 194, 195, 196, 196, 197, 198, 198, 199, 199, 200,
+	201, 201, 202, 202, 203, 204, 204, 205, 205, 206, 206, 207,
+	208, 208, 209, 209, 210, 210, 211, 212, 212, 213, 213, 214,
+	214, 215, 215, 216, 217, 217, 218, 218, 219, 219, 220, 220,
+	221, 221, 222, 222, 223, 224, 224, 225, 225, 226, 226, 227,
+	227, 228, 228, 229, 229, 230, 230, 231, 231, 232, 232, 233,
+	233, 234, 234, 235, 235, 236, 236, 237, 237, 238, 238, 239,
+	239, 240, 240, 241, 241, 242, 242, 243, 243, 243, 244, 244,
+	245, 245, 246, 246,
+
+	/* Blue */
+	0, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
+	23, 23, 23, 23, 23, 23, 23, 30, 37, 42, 47, 51,
+	55, 58, 61, 64, 67, 70, 72, 74, 78, 80, 82, 84,
+	86, 88, 90, 92, 94, 95, 97, 100, 101, 103, 104, 106,
+	107, 110, 111, 112, 114, 115, 116, 118, 119, 121, 122, 124,
+	125, 126, 127, 128, 129, 132, 133, 134, 135, 136, 137, 138,
+	139, 140, 141, 143, 144, 145, 146, 147, 148, 149, 150, 151,
+	152, 154, 155, 156, 157, 158, 158, 159, 160, 161, 162, 163,
+	165, 166, 166, 167, 168, 169, 170, 171, 171, 172, 173, 174,
+	176, 176, 177, 178, 179, 180, 180, 181, 182, 183, 183, 184,
+	185, 187, 187, 188, 189, 189, 190, 191, 192, 192, 193, 194,
+	194, 195, 196, 196, 198, 199, 200, 200, 201, 202, 202, 203,
+	204, 204, 205, 205, 206, 207, 207, 209, 210, 210, 211, 212,
+	212, 213, 213, 214, 215, 215, 216, 217, 217, 218, 218, 220,
+	221, 221, 222, 222, 223, 224, 224, 225, 225, 226, 226, 227,
+	228, 228, 229, 229, 231, 231, 232, 233, 233, 234, 234, 235,
+	235, 236, 236, 237, 238, 238, 239, 239, 240, 240, 242, 242,
+	243, 243, 244, 244, 245, 246, 246, 247, 247, 248, 248, 249,
+	249, 250, 250, 251, 251, 253, 253, 254, 254, 255, 255, 255,
+	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+	255, 255, 255, 255
+};
+
+static void qc_usb_exit(struct quickcam *qc);
+static int qc_capt_init(struct quickcam *qc);
+static void qc_capt_exit(struct quickcam *qc);
+static int qc_capt_get(struct quickcam *qc, unsigned char **frame);
+static int qc_isoc_init(struct quickcam *qc);
+static void qc_isoc_exit(struct quickcam *qc);
+/* }}} */
+
+/* {{{ [fold] **** Miscellaneous functions ************************************** */
+
+/* {{{ [fold] qc_usleep(long usec) */
+void qc_usleep(unsigned long usec)
+{
+	wait_queue_head_t wq;
+	init_waitqueue_head(&wq);
+	interruptible_sleep_on_timeout(&wq, usec*HZ/1000000);
+}
+/* }}} */
+/* {{{ [fold] qc_unlink_urb_sync(struct urb *urb) */
+/* Unlink URB synchronously (usb_unlink_urb may not be synchronous).
+ * Note: at this moment the URB completion handler must not resubmit the same URB.
+ */
+static void qc_unlink_urb_sync(struct urb *urb) {
+	int r;
+	while ((r=usb_unlink_urb(urb)) == -EBUSY) {
+		/* The URB is not anymore linked (status!=-EINPROGRESS) but 
+		 * usb_unlink_urb() was asynchronous and URB's completion handler still will run */
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout( (HZ/100)==0 ? 1 : HZ/100);
+	}
+	/* if (r!=-EBUSY),
+	 * usb_unlink_urb() called synchronously the completion handler and
+	 * there's no need to wait or anything else */
+	if (r) PDEBUG("qc_unlink_urb_sync(%p): r=%i", urb, r);
+}
+/* }}} */
+/* {{{ [fold] int qc_get_i2c(struct quickcam *qc, const struct qc_sensor *sensor, int reg) */
+/* Read a sensor byte or word wide register value via STV0600 I2C bus
+ * qc_i2c_init() must be called first!
+ */
+int qc_get_i2c(struct quickcam *qc, const struct qc_sensor *sensor, int reg)
+{
+	struct usb_device *dev = qc->dev;
+	int ret;
+
+	if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGCAMERA) PDEBUG("qc_get_i2c(qc=%p,sensor=%p,reg=0x%04X)",qc,sensor,reg);
+	TEST_BUGR(dev==NULL);
+	if (sizeof(qc->dmabuf)<35) BUG();
+
+	/* We need here extra write to the STV register before reading the I2C register */
+	/* Also wait until there are no pending control URB requests */
+	if ((ret = qc_stv_set(qc, STV_REG23, sensor->reg23))<0) goto fail;
+
+	memset(qc->dmabuf, 0, 35);
+	qc->dmabuf[0]    = reg;
+	qc->dmabuf[0x20] = sensor->i2c_addr;
+	qc->dmabuf[0x21] = 0;			/* 0+1 = 1 value, one byte or word wide register */
+	qc->dmabuf[0x22] = 3;			/* Read I2C register */
+	ret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+		0x04,
+		0x40,
+		0x1400, 0,			/* Write I2C register address, 35 bytes */
+		qc->dmabuf, 0x23, 3*HZ);
+	if (ret < 0) goto fail;
+	ret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
+		0x04,
+		0xC0,
+		0x1410, 0, 			/* Read register contents from I2C, 1 or 2 bytes */
+		qc->dmabuf, sensor->length_id, 3*HZ);
+	if (ret < 0) goto fail;
+	ret = qc->dmabuf[0];
+	if (sensor->length_id>1) ret |= qc->dmabuf[1]<<8;	/* Assume LSB is always first from data received via USB */
+	if (qcdebug&QC_DEBUGCAMERA) PDEBUG("qc_get_i2c(reg=0x%04X) = %04X", reg, ret);
+	return ret;
+
+fail:	PDEBUG("qc_get_i2c failed, code=%i",ret);
+	return ret;
+}
+/* }}} */
+/* {{{ [fold] int qc_stv_set(struct quickcam *qc, unsigned short reg, unsigned char val) */
+/*
+ * Set one byte register in the STV-chip. qc_i2c_init() must be called first!
+ */
+int qc_stv_set(struct quickcam *qc, unsigned short reg, unsigned char val)
+{
+	int ret;
+	if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGCAMERA) PDEBUG("qc_stv_set(qc=%p,reg=0x%04X,val=%u)",qc,(int)reg,(int)val);
+	TEST_BUGR(qc==NULL);
+	if (sizeof(qc->dmabuf)<1) BUG();
+	qc_i2c_wait(qc);		/* Wait until no pending commands from qc_i2c_* */
+	qc->dmabuf[0] = val;
+	ret = usb_control_msg(qc->dev, usb_sndctrlpipe(qc->dev, 0),
+		0x04,			/* Request */
+		0x40,			/* RequestType */
+		reg, 0,			/* Value, Index */
+		qc->dmabuf, 1, 3*HZ);
+	if ((qcdebug&QC_DEBUGERRORS || qcdebug&QC_DEBUGLOGIC) && ret<0) PDEBUG("Failed qc_stv_set()=%i", ret);
+	if (ret<0) return ret;
+	return 0;
+}
+/* }}} */
+/* {{{ [fold] int qc_stv_get(struct quickcam *qc, unsigned short reg) */
+/*
+ * Read one byte register in the STV-chip. qc_i2c_init() must be called first!
+ * Return the unsigned register value or negative error code on error.
+ */
+int qc_stv_get(struct quickcam *qc, unsigned short reg)
+{
+	int ret;
+	if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGCAMERA) PDEBUG("qc_stv_get(qc=%p,reg=0x%04X)",qc,(int)reg);
+	TEST_BUGR(qc==NULL);
+	if (sizeof(qc->dmabuf)<1) BUG();
+	qc_i2c_wait(qc);		/* Wait until no pending commands from qc_i2c_* */
+	ret = usb_control_msg(qc->dev, usb_rcvctrlpipe(qc->dev, 0),
+		0x04,			/* Request */
+		0xC0,			/* RequestType */
+		reg, 0,			/* Value, Index */
+		qc->dmabuf, 1, 3*HZ);
+	if ((qcdebug&QC_DEBUGERRORS || qcdebug&QC_DEBUGLOGIC) && ret<0) PDEBUG("Failed qc_stv_get()=%i", ret);
+	if (ret<0) return ret;
+	if (qcdebug&QC_DEBUGCAMERA) PDEBUG("qc_stv_get(reg=0x%04X)=%02X", reg, qc->dmabuf[0]);
+	return qc->dmabuf[0];
+}
+/* }}} */
+/* {{{ [fold] int qc_stv_setw(struct quickcam *qc, unsigned short reg, unsigned short val) */
+/*
+ * Set two byte register in the STV-chip. qc_i2c_init() must be called first!
+ * "w" means either "word" or "wide", depending on your religion ;)
+ */
+int qc_stv_setw(struct quickcam *qc, unsigned short reg, unsigned short val)
+{
+	int ret;
+	if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGCAMERA) PDEBUG("qc_stv_setw(qc=%p,reg=0x%04X,val=%i)",qc,(int)reg,(int)val);
+	TEST_BUGR(qc==NULL);
+	if (sizeof(qc->dmabuf)<2) BUG();
+	qc_i2c_wait(qc);
+	qc->dmabuf[0] = val & 0xFF;
+	qc->dmabuf[1] = (val >> 8) & 0xFF;
+	ret = usb_control_msg(qc->dev, usb_sndctrlpipe(qc->dev, 0),
+		0x04,
+		0x40,
+		reg, 0,
+		qc->dmabuf, 2, 3*HZ);
+	if ((qcdebug&QC_DEBUGERRORS || qcdebug&QC_DEBUGLOGIC) && ret<0) PDEBUG("Failed qc_stv_setw()=%i", ret);
+	if (ret<0) return ret;
+	return 0;
+}
+/* }}} */
+/* {{{ [fold] void qc_hsv2rgb(s16 hue, u16 sat, u16 val, int *red, int *green, int *blue) */
+/* Convert HSI (hue, saturation, intensity) to RGB (red, green, blue).
+ * All input and output values are 0..65535.
+ * Hue is actually signed, so it is -32768..32767, but this is equivalent
+ * since it is the angle around full circle (0=Red, 21845=Green, 43690=Blue).
+ * Based on libgimp, converted to 16.16 fixed point by tuukkat.
+ */
+void qc_hsv2rgb(s16 hue, u16 sat, u16 val, int *red, int *green, int *blue)
+{
+	unsigned int segment, valsat;
+	signed int   h = (u16)hue;
+	unsigned int s = (sat<32768) ? 0 : (sat-32768)*2;	/* 32768 or less = no saturation */
+	unsigned int v = val;					/* value = intensity */
+	unsigned int p;
+
+#if 1	/* Make common case more efficient */
+	if (s == 0) {
+		*red   = v;
+		*green = v;
+		*blue  = v;
+		return;
+	}
+#endif
+	segment = (h + 10923) & 0xFFFF;		
+	segment = segment*3 >> 16;		/* 0..2: 0=R, 1=G, 2=B */
+	hue -= segment * 21845;			/* -10923..10923 */
+	h = hue;
+	h *= 3;
+	valsat = v*s >> 16;			/* 0..65534 */
+	p = v - valsat;
+	if (h>=0) {
+		unsigned int t = v - (valsat * (32769 - h) >> 15);
+		switch (segment) {
+		default:
+			PDEBUG("hsi2rgb: this can never happen!");
+		case 0:	/* R-> */
+			*red   = v;
+			*green = t;
+			*blue  = p;
+			break;
+		case 1:	/* G-> */
+			*red   = p;
+			*green = v;
+			*blue  = t;
+			break;
+		case 2:	/* B-> */
+			*red   = t;
+			*green = p;
+			*blue  = v;
+			break;
+		}
+	} else {
+		unsigned int q = v - (valsat * (32769 + h) >> 15);
+		switch (segment) {
+		default:
+			PDEBUG("hsi2rgb: this can never happen!");
+		case 0:	/* ->R */
+			*red   = v;
+			*green = p;
+			*blue  = q;
+			break;
+		case 1:	/* ->G */
+			*red   = q;
+			*green = v;
+			*blue  = p;
+			break;
+		case 2:	/* ->B */
+			*red   = p;
+			*green = q;
+			*blue  = v;
+			break;
+		}
+	}
+	//PDEBUG("hue=%i sat=%i val=%i  segment=%i h=%i  r=%i g=%i b=%i",hue,sat,val, segment,h, *red,*green,*blue);
+}
+
+/* }}} */
+/* {{{ [fold] int qc_lock(struct quickcam *qc) */
+/* Takes a lock on quickcam_list_lock and verifies that the given qc is available */
+/* Returns 0 on success in which case the lock must be freed later or negative error code */
+static int qc_lock(struct quickcam *qc)
+{
+	struct quickcam *q;
+
+	if (down_interruptible(&quickcam_list_lock)) return -ERESTARTSYS;
+
+	/* Search for the device in the list of plugged quickcams (this prevents a race condition) */
+	list_for_each_entry(q, &quickcam_list, list) {
+		if (q == qc) break;			/* Found it? */
+	}
+	if (q != qc) {
+		PDEBUG("can not find the device to open");
+		up(&quickcam_list_lock);
+		return -ENODEV;
+	}
+	return 0;
+}
+/* }}} */
+
+/* }}} */
+/* {{{ [fold] **** qc_i2c:    I2C URB messaging routines (qc_i2c_*) ************* */
+
+/* We have here a quite typical producer-consumer scheme:
+ * URB interrupt handler routine consumes i2c data, while
+ * kernel mode processes create more of it.
+ * Ref: Linux Device Drivers, Alessandro Rubini et al, 2nd edition, pg. 279
+ * "Using Circular Buffers"
+ */
+
+static const int qc_i2c_maxbufsize = 0x23;
+
+/* {{{ [fold] (private) qc_i2c_nextpacket(struct quickcam *qc) */
+/* Fill URB and submit it, if there are more data to send 
+ * Consume data from "commands" array. May be called from interrupt context.
+ * Return standard error code.
+ */
+static int qc_i2c_nextpacket(struct quickcam *qc)
+{
+	struct qc_i2c_data *id = &qc->i2c_data;
+	struct urb *urb = id->urb;
+	u8 *tb = urb->transfer_buffer, flags;
+	struct usb_ctrlrequest *cr = (struct usb_ctrlrequest *)urb->setup_packet;
+	unsigned int newtail, length, regnum, i, j;
+	signed int r;
+
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_i2c_nextpacket(quickcam=%p), tail=%i, head=%i, interrupt=%i",qc,id->tail,id->head,(int)in_interrupt());
+	IDEBUG_TEST(*id);
+
+	if (!qc->connected) {
+		/* Device was disconnected, cancel all pending packets and return */
+		id->tail = id->head = id->newhead = 0;
+		id->packets = 0;
+		return -ENODEV;
+	}
+
+	newtail = id->tail;					/* First data to fetch */
+	if (id->packets<=1 && newtail==id->head) {	/* packets==0 or 1: no extra URB need to be scheduled */
+		if (qcdebug&QC_DEBUGCONTROLURBS) PDEBUG("No more control URBs to send");
+		r = 0;
+		goto nourbs;
+	}
+	if (id->packets<=1) {
+		/* Collect data from circular buffer to URB transfer buffer */
+		/* Now id->tail!=id->head: there's at least one packet to send */
+		TEST_BUGR(newtail==id->head);
+		id->packets = 1;
+		if (GET_PRODUCTID(qc)==0x0850) id->packets = 2;
+		regnum = 0x0400;
+		length = qc_i2c_maxbufsize;
+
+		i = 0;							/* Transfer buffer position */
+		if (!(id->commands[newtail].flags & I2C_FLAG_WORD)) {
+			/* Normal byte-wide register write */
+			if (qcdebug&QC_DEBUGCONTROLURBS) PDEBUG("Setting byte-wide registers");
+			do {
+				tb[i]      = id->commands[newtail].regnum;
+				tb[i+0x10] = id->commands[newtail].loval;
+				flags      = id->commands[newtail].flags;
+				i++;
+				newtail    = (newtail + 1) % I2C_MAXCOMMANDS;	/* Next data to fetch */
+				if (flags & I2C_FLAG_BREAK) break;		/* Start new packet */
+				if (newtail == id->head) break;		/* No more data? */
+				if (i > 0x0F) break;			/* Transfer buffer full? */
+				if (id->commands[newtail].flags & I2C_FLAG_WORD) break;
+			} while (TRUE);
+/*if (flags&I2C_FLAG_BREAK) PDEBUG("breaking!!!!!!!!!!");
+{
+int mm;
+for(mm=0;mm<i;mm++) printk("%02X=%02X ",tb[mm],tb[mm+0x10]);
+printk("\n");
+}*/
+			for (j=i; j<0x10; j++) tb[j+0x10] = 0;	/* Zero out unused register values just to be sure */
+		} else {
+			/* Two-byte-wide register write (used in Photobit) */
+			if (qcdebug&QC_DEBUGCONTROLURBS) PDEBUG("Setting word-wide registers");
+			do {
+				tb[i]        = id->commands[newtail].regnum;
+				tb[i*2+0x10] = id->commands[newtail].loval;
+				tb[i*2+0x11] = id->commands[newtail].hival;
+				flags        = id->commands[newtail].flags;
+				i++;
+				newtail = (newtail + 1) % I2C_MAXCOMMANDS;	/* Next data to fetch */
+				if (flags & I2C_FLAG_BREAK) break;		/* Start new packet */
+				if (newtail == id->head) break;		/* No more data? */
+				if (i > 0x07) break;			/* Transfer buffer full? */
+				if (!(id->commands[newtail].flags & I2C_FLAG_WORD)) break;
+			} while (TRUE);
+			for (j=i*2; j<0x10; j++) tb[j+0x10] = 0;	/* Zero out unused register values just to be sure */
+		}
+		for (j=i; j<0x10; j++) tb[j] = 0;	/* Zero out unused register addresses just to be sure */
+		tb[0x20] = qc->sensor_data.sensor->i2c_addr;
+		tb[0x21] = i-1;			/* Number of commands to send - 1 */
+		tb[0x22] = 1;			/* Write cmd, 03 would be read. */
+		id->tail = newtail;
+		if (qcdebug&QC_DEBUGCONTROLURBS) PDEBUG("sending i2c packet, cmds=%i, reg0=%02X, val0=%02X",tb[0x21]+1,tb[0],tb[0x10]);
+	} else {
+		/* id->packets==2: send extra packet for QuickCam Web */
+		if (qcdebug&QC_DEBUGCONTROLURBS) PDEBUG("sending finalization packet");
+		id->packets = 1;
+		regnum = 0x1704;
+		length = 1;
+		tb[0] = 1;
+	}
+	urb->dev    = qc->dev;		/* 2.4.x zeroes urb->dev after submission */
+	urb->pipe   = usb_sndctrlpipe(qc->dev, 0);
+	urb->transfer_buffer_length = length;
+	cr->wValue  = cpu_to_le16(regnum);
+	cr->wLength = cpu_to_le16(length);
+	r = usb_submit_urb(urb,GFP_ATOMIC);
+	CHECK_ERROR(r<0, nourbs, "Failed qc_i2c_nextpacket()=%i", r);
+	return 0;
+
+nourbs:	id->packets = 0;	/* No more URBs are scheduled */
+	wake_up(&id->wq);	//FIXME: race condition: now packets=0, so id could be freed and wake_up do oops
+	return r;
+}
+/* }}} */
+/* {{{ [fold] (private) qc_i2c_handler(struct urb *urb) */
+/* This is URB completion handler and is called in interrupt context.
+ * For each submitted URB, this function is guaranteed to be called exactly once.
+ * This function may not be called reentrantly for the same qc (should be ok, IRQs don't nest).
+ * It will resubmit the same URB, if
+ * - The previous URB completed without error
+ * - Camera is still connected (qc->connected == TRUE)
+ * - There is still commands to be sent in commands buffer or pid=0x850 and finalization packet is not yet sent.
+ */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+static void qc_i2c_handler(struct urb *urb, struct pt_regs *ptregs)
+#else
+static void qc_i2c_handler(struct urb *urb)
+#endif
+{
+	struct quickcam *qc = urb->context;
+
+	if (qcdebug&QC_DEBUGINTERRUPTS) PDEBUG("[INTR] qc_i2c_handler(urb=%p)",urb);
+	TEST_BUG(urb==NULL);
+	TEST_BUG(qc==NULL);
+	IDEBUG_TEST(qc->i2c_data);
+	if (urb->status<0) {
+		switch (urb->status) {
+		default:
+			/* Seen here: ECONNABORTED    103     Software caused connection abort */
+			PRINTK(KERN_ERR,"Unhandled control URB error %i",urb->status);
+		case -EPROTO:		/* Bitstuff error or unknown USB error */
+		case -EILSEQ:		/* CRC mismatch */
+		case -ETIMEDOUT:	/* Transfer timed out */
+		case -EREMOTEIO:	/* Short packet detected */
+		case -EPIPE:		/* Babble detect or endpoint stalled */
+			/* We could try resubmitting the URB here */
+		case -ENOENT:		/* URB was unlinked */
+		case -ENODEV:		/* Device was removed */
+		case -ECONNRESET:	/* Asynchronous unlink, should not happen */
+			PRINTK(KERN_ERR,"Control URB error %i",urb->status);
+			qc->i2c_data.packets = 0;	/* Don't schedule more URBs */
+			wake_up(&qc->i2c_data.wq);
+			return;
+		}
+	}
+	qc_i2c_nextpacket(qc);
+}
+/* }}} */
+/* {{{ [fold] qc_i2c_flush(struct quickcam *qc) */
+/* Allow all register settings set earlier to be scheduled and sent to camera */
+static int qc_i2c_flush(struct quickcam *qc)
+{
+	struct qc_i2c_data *id = &qc->i2c_data;
+	int r = 0;
+
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_i2c_flush(quickcam=%p,regs=%i)",qc,
+			(id->newhead+I2C_MAXCOMMANDS-id->head)%I2C_MAXCOMMANDS);
+	IDEBUG_TEST(*id);
+	id->head = id->newhead;
+	if (id->packets==0)	/* Schedule URB if there aren't any in progress */
+		r = qc_i2c_nextpacket(qc);
+	return r;
+}
+/* }}} */
+/* {{{ [fold] qc_i2c_wait(struct quickcam *qc) */
+/* Wait until all previosly set registers are set or abort all transmissions
+ * and return error code.
+ * After this function returns, there will not be uncompleted I2C URBs.
+ */
+int qc_i2c_wait(struct quickcam *qc)
+{
+	struct qc_i2c_data *id = &qc->i2c_data;
+	int r;
+
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_i2c_wait(quickcam=%p)",qc);
+	TEST_BUGR(in_interrupt());
+	TEST_BUGR(qc==NULL);
+	IDEBUG_TEST(*id);
+
+	if (!qc->connected) goto cancel;
+	r = qc_i2c_flush(qc);
+	if (r>=0) r = wait_event_interruptible(id->wq, id->packets==0);
+	if (r<0) goto cancel;
+	return 0;
+
+cancel:	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("Canceling pending URB %p, packets=%i", id->urb, id->packets);
+	PDEBUG("i2c_cancel: qc=%p, id=%p",qc,id);
+	PDEBUG("i2c_cancel: id->urb=%p", id->urb);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+	if (qc->connected) {
+		PDEBUG("i2c_cancel: id->urb->dev=%p", id->urb->dev);
+		if (id->urb->dev!=NULL) {
+			PDEBUG("i2c_cancel: id->urb->dev->bus=%p", id->urb->dev->bus);
+			if (id->urb->dev->bus!=NULL) {
+				PDEBUG("i2c_cancel: id->urb->dev->bus->op=%p", id->urb->dev->bus->op);
+				//PDEBUG("id->urb->dev->bus->op->unlink=%p", id->urb->dev->bus->op->unlink);
+			}
+		}
+	}
+#endif
+	/* Cancel URB if it is in progress or in completion handler */
+	if (id->packets > 0) qc_unlink_urb_sync(id->urb);
+	TEST_BUGR_MSG(id->packets!=0, "i2c_wait: packets=%i", id->packets);
+	return 0;
+}
+/* }}} */
+/* {{{ [fold] (private) qc_i2c_set0(struct quickcam *qc, unsigned char regnum, unsigned char loval, unsigned char hival, int flags) */
+/* Called from qc_i2c_set and qc_i2c_setw, should not be called elsewhere */
+static int qc_i2c_set0(struct quickcam *qc, unsigned char regnum, unsigned char loval, unsigned char hival, int flags)
+{
+	struct qc_i2c_data *id = &qc->i2c_data;
+	unsigned int newhead;
+	signed int r;
+
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_i2c_set0(quickcam=%p,reg=%02X,val=%02X%02X)",qc,regnum,hival,loval);
+	TEST_BUGR(qc==NULL);
+	IDEBUG_TEST(*id);
+	newhead = id->newhead;
+	id->commands[newhead].loval  = loval;
+	id->commands[newhead].hival  = hival;
+	id->commands[newhead].regnum = regnum;
+	id->commands[newhead].flags  = flags;
+	newhead = (newhead + 1) % I2C_MAXCOMMANDS;
+	if (newhead == id->tail) {		/* If buffer is full, wait until it's empty */
+		if (qcdebug&QC_DEBUGCONTROLURBS) PDEBUG("i2c buffer is full, waiting");
+		r = qc_i2c_wait(qc);
+		if (r<0) return r;
+	}
+	TEST_BUGR(newhead==id->tail);	/* no i2c buffer space but nothing to send!!! */
+	id->newhead = newhead;
+	return 0;
+}
+/* }}} */
+/* {{{ [fold] qc_i2c_set(struct quickcam *qc, unsigned char reg, unsigned char val) */
+/* Set an I2C register to desired value */
+/* (queue setting to be sent later when qc_i2c_flush() is called) */
+inline int qc_i2c_set(struct quickcam *qc, unsigned char reg, unsigned char val)
+{
+	return qc_i2c_set0(qc, reg, val, 0, 0);
+}
+/* }}} */
+/* {{{ [fold] qc_i2c_setw(struct quickcam *qc, unsigned char reg, unsigned short val) */
+/* Set a two-byte (word length) I2C register to desired value (queue setting to be sent later) */
+/* (queue setting to be sent later when qc_i2c_flush() is called) */
+inline int qc_i2c_setw(struct quickcam *qc, unsigned char reg, unsigned short val)
+{
+	return qc_i2c_set0(qc, reg, val & 0xFF, (val >> 8) & 0xFF, I2C_FLAG_WORD);
+}
+/* }}} */
+/* {{{ [fold] qc_i2c_break(struct quickcam *qc)  */
+/* The next register written will be sent in another packet */
+int qc_i2c_break(struct quickcam *qc)
+{
+	struct qc_i2c_data *id = &qc->i2c_data;
+	unsigned int prevhead;
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_i2c_break(quickcam=%p)",qc);
+	TEST_BUGR(qc==NULL);
+	IDEBUG_TEST(*id);
+	/* We access an entry that may be already submitted and even finished */
+	/* But it should not harm */
+	prevhead = (id->newhead + I2C_MAXCOMMANDS - 1) % I2C_MAXCOMMANDS;
+	id->commands[prevhead].flags |= I2C_FLAG_BREAK;
+	barrier();
+	return qc_i2c_flush(qc);
+}
+/* }}} */
+/* {{{ [fold] qc_i2c_init(struct quickcam *qc) */
+/* Initialize structures and hardware for I2C communication */
+static int qc_i2c_init(struct quickcam *qc)
+{
+	struct qc_i2c_data *id = &qc->i2c_data;
+	struct urb *urb;
+	struct usb_ctrlrequest *cr;
+	int r = -ENOMEM;
+
+	if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGINIT) PDEBUG("qc_i2c_init(quickcam=%p)",qc);
+	TEST_BUGR(qc==NULL);
+
+	id->tail = id->head = id->newhead = 0;	/* Next position to be filled and sent is 0 */
+	id->packets = 0;
+	init_waitqueue_head(&id->wq);
+
+	/* Allocate an URB and associated buffers and fill them */
+	urb = id->urb = usb_alloc_urb(0,GFP_KERNEL);
+	if (!urb) goto fail1;
+	cr = kmalloc(sizeof(struct usb_ctrlrequest), GFP_KERNEL);
+	urb->setup_packet = (unsigned char *)cr;
+	if (!cr) goto fail2;
+	urb->transfer_buffer = kmalloc(qc_i2c_maxbufsize*sizeof(u8), GFP_KERNEL);	/* Allocate maximum ever needed */
+	if (!urb->transfer_buffer) goto fail3;
+	spin_lock_init(&urb->lock);
+	urb->complete = qc_i2c_handler;
+	urb->context  = qc;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,9)
+	urb->timeout  = 3*HZ;			/* 1 s */
+#endif
+	cr->bRequestType = 0x40;
+	cr->bRequest     = 0x04;
+	cr->wIndex       = 0;
+	IDEBUG_INIT(*id);
+	return 0;
+
+fail3:	kfree(cr);
+fail2:	usb_free_urb(urb);
+	POISON(id->urb);
+fail1:	return r;
+}
+/* }}} */
+/* {{{ [fold] qc_i2c_exit(struct quickcam *qc) */
+/* Close messaging, free up memory, stop messaging */
+static void qc_i2c_exit(struct quickcam *qc)
+{
+	struct qc_i2c_data *id = &qc->i2c_data;
+
+	if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGINIT) PDEBUG("qc_i2c_exit(qc=%p)",qc);
+	TEST_BUG(qc==NULL);
+	qc_i2c_wait(qc);
+	kfree(id->urb->setup_packet);
+	kfree(id->urb->transfer_buffer);
+	POISON(id->urb->setup_packet);
+	POISON(id->urb->transfer_buffer);
+	usb_free_urb(id->urb);
+	IDEBUG_EXIT(*id);
+}
+/* }}} */
+
+/* }}} */
+/* {{{ [fold] **** qc_proc:   /proc interface *********************************** */
+#if HAVE_PROCFS
+
+static struct proc_dir_entry *qc_proc_entry = NULL;	/* Initialization should not be necessary, but just in case... */
+
+/* {{{ [fold] qc_proc_read(char *page, char **start, off_t off, int count, int *eof, void *data) */
+static inline const char *qc_proc_yesno(Bool b)
+{
+	return b ? "Yes" : "No";
+}
+
+static int qc_proc_read(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+	struct quickcam *qc = data;
+	char *out = page;
+	int len;
+
+	if (qc_lock(qc) < 0) return 0;
+
+	out += sprintf(out, "\tGeneral driver status\n");
+	out += sprintf(out, "Driver version   : %s\n", VERSION);
+	out += sprintf(out, "Kernel version   : %s\n", UTS_RELEASE);
+	if (qc->dev!=NULL) {
+	out += sprintf(out, "Device Id        : %04X:%04X\n", (int)GET_VENDORID(qc), (int)GET_PRODUCTID(qc));
+	out += sprintf(out, "USB bus number   : %i\n", qc->dev->bus->busnum);
+	}
+	out += sprintf(out, "Users            : %i\n", qc->users);
+	out += sprintf(out, "Connected        : %s\n", qc_proc_yesno(qc->connected));
+
+	out += sprintf(out, "\n\tPicture settings set by user\n");
+	out += sprintf(out, "Brightness       : %d\n", (int)qc->vpic.brightness);
+	out += sprintf(out, "Hue              : %d\n", (int)qc->vpic.hue);
+	out += sprintf(out, "Color            : %d\n", (int)qc->vpic.colour);
+	out += sprintf(out, "Contrast         : %d\n", (int)qc->vpic.contrast);
+	out += sprintf(out, "Whiteness        : %d\n", (int)qc->vpic.whiteness);
+	if (qc->users > 0) {
+	out += sprintf(out, "Depth            : %d\n", (int)qc->vpic.depth);
+	out += sprintf(out, "Palette          : %s\n", qc_fmt_getname(qc->vpic.palette));
+	}
+
+	if (qc->users > 0) {
+	out += sprintf(out, "\n\tOutput window\n");
+	out += sprintf(out, "Width            : %d\n", (int)qc->vwin.width);
+	out += sprintf(out, "Height           : %d\n", (int)qc->vwin.height);
+	}
+
+	out += sprintf(out, "\n\tSensor\n");
+	out += sprintf(out, "Type             : %s\n", qc->sensor_data.sensor->name);
+	out += sprintf(out, "Manufacturer     : %s\n", qc->sensor_data.sensor->manufacturer);
+	if (qc->users > 0) {
+	out += sprintf(out, "Maximum width    : %d\n", qc->sensor_data.maxwidth);
+	out += sprintf(out, "Maximum height   : %d\n", qc->sensor_data.maxheight);
+	out += sprintf(out, "Current width    : %d\n", qc->sensor_data.width);
+	out += sprintf(out, "Current height   : %d\n", qc->sensor_data.height);
+	}
+
+	out += sprintf(out, "\n\tI2C command stream\n");
+	out += sprintf(out, "Scheduled packets: %d\n", qc->i2c_data.packets);
+	out += sprintf(out, "Packets on queue : %d\n", (I2C_MAXCOMMANDS + qc->i2c_data.head - qc->i2c_data.tail) % I2C_MAXCOMMANDS);
+
+	if (qc->users > 0) {
+	out += sprintf(out, "\n\tIsochronous data stream\n");
+	out += sprintf(out, "Stream enabled   : %s\n", qc_proc_yesno(qc->isoc_data.streaming));
+	out += sprintf(out, "Transfer errors  : %d\n", qc->isoc_data.errorcount);
+
+	out += sprintf(out, "\n\tFrame buffering\n");
+	out += sprintf(out, "Frames on queue  : %d\n", (FRAME_BUFFERS + qc->frame_data.head - qc->frame_data.tail) % FRAME_BUFFERS);
+	out += sprintf(out, "Capturing        : %s\n", qc_proc_yesno(qc->stream_data.capturing));
+	out += sprintf(out, "Waiting processes: %d\n", qc->frame_data.waiting);
+	}
+
+	out += sprintf(out, "\n\tAutomatic exposure control\n");
+	out += sprintf(out, "Picture intensity: %d\n", qc->adapt_data.oldmidvalue);
+	out += sprintf(out, "Exposure setting : %d\n", qc->adapt_data.exposure);
+	out += sprintf(out, "Gain setting     : %d\n", qc->adapt_data.gain);
+	out += sprintf(out, "Delta value      : %d\n", qc->adapt_data.olddelta);
+	out += sprintf(out, "Control algorithm: ");
+	switch (qc->adapt_data.controlalg) {
+		case EXPCONTROL_SATURATED: out += sprintf(out, "Saturated\n"); break;
+		case EXPCONTROL_NEWTON:    out += sprintf(out, "Newton\n"); break;
+		case EXPCONTROL_FLOAT:     out += sprintf(out, "Float\n"); break;
+		default: out += sprintf(out, "?\n"); break;
+	}
+
+	out += sprintf(out, "\n\tDefault settings\n");
+	out += sprintf(out, "Debug            : 0x%02X\n", qcdebug);
+	out += sprintf(out, "Keep settings    : %s\n", qc_proc_yesno(qc->settings.keepsettings));
+	out += sprintf(out, "Settle max frames: %i\n", qc->settings.settle);
+	out += sprintf(out, "Subsampling      : %s\n", qc_proc_yesno(qc->settings.subsample));
+	out += sprintf(out, "Compress         : %s\n", qc_proc_yesno(qc->settings.compress));
+	out += sprintf(out, "Frame skipping   : %i\n", qc->settings.frameskip);
+	out += sprintf(out, "Image quality    : %i\n", qc->settings.quality);
+	out += sprintf(out, "Adaptive         : %s\n", qc_proc_yesno(qc->settings.adaptive));
+	out += sprintf(out, "Equalize         : %s\n", qc_proc_yesno(qc->settings.equalize));
+	out += sprintf(out, "User lookup-table: %s\n", qc_proc_yesno(qc->settings.userlut));
+	out += sprintf(out, "Retryerrors      : %s\n", qc_proc_yesno(qc->settings.retryerrors));
+	out += sprintf(out, "Compatible 16x   : %s\n", qc_proc_yesno(qc->settings.compat_16x));
+	out += sprintf(out, "Compatible DblBuf: %s\n", qc_proc_yesno(qc->settings.compat_dblbuf));
+	out += sprintf(out, "Compatible ToRgb : %s\n", qc_proc_yesno(qc->settings.compat_torgb));
+
+	up(&quickcam_list_lock);
+
+	len = out - page;
+	len -= off;
+	if (len < count) {
+		*eof = 1;
+		if (len <= 0) return 0;
+	} else
+		len = count;
+	*start = page + off;
+	return len;
+}
+/* }}} */
+/* {{{ [fold] qc_proc_write(struct file *file, const char *buffer, unsigned long count, void *data) */
+static int qc_proc_write(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+	/* we don't support this....yet? Might replace qcset some day */
+	return -EINVAL;
+}
+/* }}} */
+/* {{{ [fold] qc_proc_create(struct quickcam *qc) */
+/* Called for each camera plugged in, create file containing information of the camera */
+static int qc_proc_create(struct quickcam *qc)
+{
+	char name[9];
+	struct proc_dir_entry *entry;
+	if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGINIT) PDEBUG("qc_proc_create(quickcam=%p)",qc);
+	TEST_BUGR(!qc);
+	qc->proc_entry = NULL;
+	if (qc_proc_entry==NULL) return -ENOTDIR;
+	sprintf(name, "video%d", qc->vdev.minor);
+	entry = create_proc_entry(name, S_IFREG | S_IRUGO | S_IWUSR, qc_proc_entry);
+	if (!entry) {
+		PRINTK(KERN_WARNING,"Could not register procfs file entry");
+		return -ENXIO;
+	}
+	entry->owner = THIS_MODULE;
+	entry->data = qc;
+	entry->read_proc = qc_proc_read;
+	entry->write_proc = qc_proc_write;
+	qc->proc_entry = entry;
+	return 0;
+}
+/* }}} */
+/* {{{ [fold] qc_proc_destroy(struct quickcam *qc) */
+/* qc_proc_destroy may be called after qc_proc_create for given quickcam even if it failed */
+static void qc_proc_destroy(struct quickcam *qc)
+{
+	char name[9];
+	if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGINIT) PDEBUG("qc_proc_destroy(quickcam=%p)",qc);
+	TEST_BUG(!qc);
+	if (!qc->proc_entry) return;
+	TEST_BUG(!qc_proc_entry);
+	sprintf(name, "video%d", qc->vdev.minor);
+	remove_proc_entry(name, qc_proc_entry);
+	POISON(qc->proc_entry);
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_proc_destroy() done");
+}
+/* }}} */
+/* {{{ [fold] qc_proc_init(void) */
+/* Called when the driver is initially loaded, creates "/proc/video/quickcam" subdirectory */
+static int qc_proc_init(void)
+{
+	if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGINIT) PDEBUG("qc_proc_init()");
+	proc_mkdir("video", NULL);			/* Might fail, if the directory already exists, but we don't care */
+	qc_proc_entry = create_proc_entry(qc_proc_name, S_IFDIR, NULL);
+	if (!qc_proc_entry) {
+		PRINTK(KERN_WARNING,"Could not register procfs dir entry");
+		return -ENXIO;
+	}
+	qc_proc_entry->owner = THIS_MODULE;
+	return 0;
+}
+/* }}} */
+/* {{{ [fold] qc_proc_exit(void) */
+/* Can be called after qc_proc_init() even if it has failed, in which case this does nothing */
+static void qc_proc_exit(void)
+{
+	if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGINIT) PDEBUG("qc_proc_exit()");
+	if (!qc_proc_entry) return;
+	remove_proc_entry(qc_proc_name, NULL);
+	POISON(qc_proc_entry);
+}
+/* }}} */
+
+#else
+static inline int qc_proc_create(struct quickcam *qc) { return 0; }
+static inline void qc_proc_destroy(struct quickcam *qc) { }
+static inline int qc_proc_init(void) { return 0; }
+static inline void qc_proc_exit(void) { }
+#endif /* HAVE_PROCFS */
+/* }}} */
+/* {{{ [fold] **** qc_adapt:  Automatic exposure control ************************ */
+
+#define MEASURE_ADAPT_DELAY 0		/* Measure adaptation delay, only for test purposes */
+
+/* {{{ [fold] qc_adapt_init(struct quickcam *qc) */
+/* Initialize automatic exposure control structure. */
+static int qc_adapt_init(struct quickcam *qc)
+{
+	struct qc_adapt_data *ctrl = &qc->adapt_data;
+	ctrl->gain         = 32768;
+	ctrl->olddelta     = 4*256;			/* best guess */
+	ctrl->exposure     = 32768;
+	ctrl->oldexposure  = ctrl->exposure + 1;	/* Slightly different for _issettled() */
+	ctrl->midvaluesum  = ctrl->oldmidvalue = 0;
+	ctrl->framecounter = 0;
+	ctrl->controlalg   = EXPCONTROL_SATURATED;
+	IDEBUG_INIT(*ctrl);
+	return 0;
+}
+/* }}} */
+/* {{{ [fold] qc_adapt_exit(struct quickcam *qc) */
+
+static inline void qc_adapt_exit(struct quickcam *qc)
+{
+#ifdef DEBUG
+	struct qc_adapt_data *ctrl = &qc->adapt_data;
+	if (qcdebug&QC_DEBUGINIT) PDEBUG("qc_adapt_exit(ctrl=%p)",ctrl);
+	IDEBUG_EXIT(*ctrl);
+#endif
+}
+
+/* }}} */
+/* {{{ [fold] qc_adapt_reset(struct quickcam *qc) */
+/* Must be called each time just before starting video adaptation */
+static inline void qc_adapt_reset(struct quickcam *qc)
+{
+	IDEBUG_TEST(qc->adapt_data);
+	if (!qc->settings.keepsettings) {
+		IDEBUG_EXIT(qc->adapt_data);
+		qc_adapt_init(qc);
+	}
+}
+/* }}} */
+/* {{{ [fold] qc_adapt_hassettled(struct quickcam *qc) */
+/* Return TRUE if the image brightness has settled */
+static inline Bool qc_adapt_hassettled(struct quickcam *qc)
+{
+	struct qc_adapt_data *ctrl = &qc->adapt_data;
+	IDEBUG_TEST(*ctrl);
+	if (ctrl->framecounter != 0) return FALSE;
+//PDEBUG("control=%i  oldexp=%i  exp=%i",ctrl->controlalg,ctrl->oldexposure,ctrl->exposure);
+	return ctrl->controlalg==EXPCONTROL_FLOAT || ctrl->oldexposure==ctrl->exposure;
+}
+/* }}} */
+/* {{{ [fold] qc_adapt(struct quickcam *qc, int midvalue, int target, int *ret_exposure, int *ret_gain) */
+
+/* Set image exposure and gain so that computed midvalue approaches the target value.
+ * midvalue = average pixel intensity on image 0..255
+ * target   = user settable preferable intensity 0..255
+ * *ret_exposure = the exposure value to use for the camera, 0..65535
+ * *ret_gain     = the gain to use for the camera, 0..65535.
+ */
+static void qc_adapt(struct quickcam *qc, int midvalue, int target, int *ret_exposure, int *ret_gain)
+{
+#if !MEASURE_ADAPT_DELAY
+	struct qc_adapt_data *ctrl = &qc->adapt_data;
+	/* Here are some constant for controlling the adaptation algorithm. You may play with them. */
+	static const int saturation_min = 32;			/* (0-127) If midvalue is out of this range, image is */
+	static const int saturation_max = 256 - 8;		/* (128-255) considered saturated and no Newton is used */
+
+	static const int adaptation_min = 5;			/* (0-128) For small variations, do not change exposure */
+
+	static const int delta_min      = 256/2;		/* (2-16*256) Minimum and maximum value for delta */
+	static const int delta_max      = 256*256;		/* (4*256-1024*256) */
+	
+	static const int dmidvalue_min  = 400;			/* (1-128) Minimum differences, under which delta estimation (FIXME:disabled by changing values very big) */
+	static const int dexposure_min  = 400;			/* (1-32000) will not be done due to inaccuracies */
+	
+	static const int delta_speed    = 256;			/* (0-256) How fast or slowly delta can change */
+	static const int small_adapt    = 4;			/* (0-1024) When very near optimal, exposure change size */
+	static const int underestimate  = 16;			/* (0-250) Underestimation, may prevent oscillation */
+	static const int bestguess      = 256/2;		/* (2-1024*256) If delta can not be computed, guess this */
+	static const int midvalueaccum  = 2;			/* (1-100) How many frames to use for midvalue averaging */
+	static const int framedelay     = 5;			/* (0-8) How many frames there are before a new exposure setting in effect */
+								/* With QuickCam Web: if set at frame #0, it will be in effect at frame #4; skip 3 frames #1,#2,#3 */
+								/* -> should be 3 with QuickCam Web, but it oscillates, FIXME:why? Setting to 4 fixes this */
+	static const int gainstep       = 256;			/* (0-32768) Amount to change gain at one step */
+	static const int gainneeded     = 10;			/* (0-255) How eagerly to change brightness with gain */
+	/* End of tunable constants */
+
+	int newexposure, delta=0;
+	int dexposure=0, dmidvalue=0;
+	int deviation=0;			/* Deviation of actual brightness from target brightness */
+	int smoothdelta=0;			/* Final, smoothed, value of delta */
+
+	TEST_BUG(ctrl==NULL || ret_gain==NULL || ret_exposure==NULL);
+	IDEBUG_TEST(*ctrl);
+
+	if (ctrl->framecounter >= framedelay)
+		ctrl->midvaluesum += midvalue;
+	ctrl->framecounter++;
+	if (ctrl->framecounter < framedelay+midvalueaccum) {
+		*ret_exposure = ctrl->exposure;
+		*ret_gain     = ctrl->gain;
+		return;
+	}
+
+	midvalue = ctrl->midvaluesum / midvalueaccum;
+	ctrl->framecounter = 0;
+	ctrl->midvaluesum  = 0;
+
+	if (ctrl->exposure >= qc->sensor_data.sensor->adapt_gainhigh && 
+	    ctrl->oldexposure >= qc->sensor_data.sensor->adapt_gainhigh &&
+	    target - ctrl->oldmidvalue > gainneeded &&
+	    target - midvalue > gainneeded)
+	{
+		/* Exposure is at maximum, but image is still too dark. Increase gain.*/
+		ctrl->gain = ctrl->gain + ctrl->gain/2 + gainstep;
+		if (ctrl->gain > 65535) ctrl->gain = 65535;
+		if (qcdebug&QC_DEBUGADAPTATION) PDEBUG("increasing gain to %i", ctrl->gain);
+	} else 
+	if (ctrl->exposure <= qc->sensor_data.sensor->adapt_gainlow &&
+	    ctrl->oldexposure <= qc->sensor_data.sensor->adapt_gainlow &&
+	    target - ctrl->oldmidvalue <= gainneeded &&
+	    target - midvalue <= gainneeded)
+	{
+		/* Decrease gain if unnecessarily high */
+		ctrl->gain = ctrl->gain - ctrl->gain/2 - gainstep;
+		if (ctrl->gain < 0) ctrl->gain = 0;
+		if (qcdebug&QC_DEBUGADAPTATION) PDEBUG("decreasing gain to %i", ctrl->gain);
+	}
+	
+	if (ctrl->oldmidvalue<saturation_min || midvalue<saturation_min) {
+		/* Image was undersaturated, Newton method would give inaccurate results */
+		if (qcdebug&QC_DEBUGADAPTATION) PDEBUG("Increasing exposure");
+		ctrl->controlalg = EXPCONTROL_SATURATED;
+		newexposure = ctrl->exposure * 2;
+	} else
+	if (ctrl->oldmidvalue>=saturation_max || midvalue>=saturation_max) {
+		/* Image is oversaturated, Newton method would give inaccurate results */
+		if (qcdebug&QC_DEBUGADAPTATION) PDEBUG("Decreasing exposure");
+		ctrl->controlalg = EXPCONTROL_SATURATED;
+		newexposure = ctrl->exposure / 2;
+	} else {
+		deviation = target - midvalue;
+		if (ABS(deviation) < adaptation_min) {
+			/* For small variations, adapt linearly */
+			if (qcdebug&QC_DEBUGADAPTATION) PDEBUG("Small deviation %i",deviation);
+			ctrl->controlalg = EXPCONTROL_FLOAT;
+			newexposure = small_adapt * SGN(deviation) + ctrl->exposure;
+		} else {
+			/* Try using Newton method for estimating correct exposure value */
+			ctrl->controlalg = EXPCONTROL_NEWTON;
+			dmidvalue = midvalue       - ctrl->oldmidvalue;
+			dexposure = ctrl->exposure - ctrl->oldexposure;
+			if (ABS(dmidvalue) <  dmidvalue_min || 
+			    ABS(dexposure) <  dexposure_min ||
+			    SGN(dmidvalue) != SGN(dexposure))
+			{
+				/* Can not estimate delta with Newton method, just guess */
+				if (ctrl->olddelta < 2) {
+					if (qcdebug&QC_DEBUGADAPTATION) PDEBUG("Best guessing");
+					smoothdelta = bestguess;
+				} else {
+					Bool cross = SGN(midvalue-target) != SGN(ctrl->oldmidvalue-target);
+					smoothdelta = cross ? (ctrl->olddelta / 2) : (ctrl->olddelta * 3 / 2);
+					if (qcdebug&QC_DEBUGADAPTATION) PDEBUG("Change more exposure, smoothdelta=%i",smoothdelta);
+				}
+			} else {
+				/* Everything is well, use here actual Newton method */
+				delta       = (256 - underestimate) * dexposure / dmidvalue;
+				smoothdelta = (delta_speed*delta + (256-delta_speed)*ctrl->olddelta) / 256;
+				if (qcdebug&QC_DEBUGADAPTATION) PDEBUG("Using Newton, delta=%i",delta);
+			}
+		}
+		/* Compute new exposure based on guessed/computed delta */
+		smoothdelta = CLIP(smoothdelta, delta_min,delta_max);
+		dexposure = deviation * smoothdelta / 256;
+		/* Newton works linearly, but exposure/brightness are not linearly related */
+		/* The following test fixes the worst deficiencies due to that (I hope) */
+		if (-dexposure > ctrl->exposure/2)
+			dexposure = -ctrl->exposure/2;
+		newexposure = dexposure + ctrl->exposure;
+		ctrl->olddelta = smoothdelta;
+	}
+
+	newexposure       = CLIP(newexposure, 2,65535);
+
+	if (qcdebug&QC_DEBUGADAPTATION) 
+		PDEBUG("midval=%i dev=%i dmidv=%i dexp=%i smdelta=%i olddelta=%i newexp=%i gain=%i",
+		midvalue,deviation,dmidvalue,dexposure,smoothdelta,ctrl->olddelta,newexposure,ctrl->gain);
+
+	ctrl->oldexposure = ctrl->exposure;
+	ctrl->exposure    = newexposure;
+	ctrl->oldmidvalue = midvalue;
+	*ret_exposure     = newexposure;
+	*ret_gain         = ctrl->gain;
+#else
+	/* This code is for measuring the delay between an exposure settings and until
+	 * it becomes in effect. Only useful for developing the adaptation algorithm. */
+	/* Some delays: when a setting is changed at frame number #0,
+	 * it becomes in effect in frame xx for	exposure	gain
+	 * QuickCam Web/0850/normal mode	4		4
+	 * QuickCam Web/0850/compressed mode	5		5
+	 * QuickCam Express/840			2		1-5
+	 *
+	 */
+	static int exp = 0;
+	static int gain = 0;
+	static const int changedel = 20;
+	static int state = 0;
+	static int framenum = 0;
+	PRINTK(KERN_CRIT,"Measuring: framenum=%i, midvalue=%i",framenum,midvalue);
+	if ((framenum%changedel)==0) {
+		switch (state) {
+		default:
+		case 0:
+			PRINTK(KERN_CRIT,"Measuring: set to black");
+			exp = 0;
+			gain = 0;
+			break;
+		case 1:
+			PRINTK(KERN_CRIT,"Measuring: changing exposure");
+			exp = 65535;
+			break;
+		case 2:
+			PRINTK(KERN_CRIT,"Measuring: changing gain");
+			gain = 32535;
+			break;
+		}
+		state = ((state+1) % 3);
+	}
+	*ret_exposure = exp;
+	*ret_gain = gain;
+	framenum++;
+#endif
+}
+
+/* }}} */
+
+/* }}} */
+/* {{{ [fold] **** qc_frame:  Frame capturing functions ************************* */
+
+/* From /usr/src/linux/Documentation/smp.tex:
+ * + Kernel mode process (e.g. system calls):
+ *   - No other kernel mode processes may run simultaneously/pre-empt
+ *     (kernel mode processes are atomic with respect to each other)
+ *     (Does not hold for 2.6.x)
+ *   - Exception is voluntary sleeping, in which case re-entry is allowed
+ *     (Does not hold for 2.6.x)
+ *   - Interrupts may pre-empt (but return to same process)
+ *     (interrupts can be disabled if necessary)
+ * + Interrupt mode execution
+ *   - Kernel mode process may not pre-empt/execute simultaneously
+ *   - Other interrupts may pre-empt, however same interrupt is not nested
+ */
+
+/* We have here a quite typical producer-consumer scheme:
+ * Interrupt routine produces more frame data, while
+ * kernel mode processes consume it
+ * Read: Linux Device Drivers, Alessandro Rubini et al, 2nd edition, pg. 279
+ * "Using Circular Buffers"
+ */
+
+/* Initialization and cleanup routines, called from kernel mode processes */
+/* {{{ [fold] qc_frame_init(struct quickcam *qc) */
+static int qc_frame_init(struct quickcam *qc)
+{
+	struct qc_frame_data *fd = &qc->frame_data;
+	int n;
+
+	if (qcdebug&QC_DEBUGFRAME || qcdebug&QC_DEBUGINIT) PDEBUG("qc_frame_init(qc=%p)",qc);
+	TEST_BUGR(qc==NULL || fd==NULL);
+	TEST_BUGR(in_interrupt());
+	fd->rawdatabuf = vmalloc(FRAME_DATASIZE * FRAME_BUFFERS);
+	if (!fd->rawdatabuf) return -ENOMEM;
+	memset(fd->rawdatabuf, 0, FRAME_DATASIZE * FRAME_BUFFERS);	/* Never let user access random kernel data */
+	fd->head       = 0;		/* First buffer to fill */
+	fd->tail       = 0;		/* First buffer to get */
+	spin_lock_init(&fd->tail_lock);
+	fd->tail_in_use= FALSE;
+	init_waitqueue_head(&fd->wq);
+	fd->waiting    = 0;
+	fd->exiting    = FALSE;
+	for (n=0; n<FRAME_BUFFERS; n++) fd->buffers[n].rawdatalen = 0;
+	fd->lost_frames = 0;
+	IDEBUG_INIT(*fd);
+	return 0;
+}
+/* }}} */
+/* {{{ [fold] qc_frame_exit(struct quickcam *qc) */
+/* This function must be called with qc->lock acquired 
+ * (it may release it temporarily and sleep) */
+static void qc_frame_exit(struct quickcam *qc)
+{
+	struct qc_frame_data *fd = &qc->frame_data;
+#if PARANOID
+	unsigned long startjiffy = jiffies;
+#endif
+	if (qcdebug&QC_DEBUGFRAME || qcdebug&QC_DEBUGINIT) PDEBUG("qc_frame_exit(qc=%p,tail=%i,head=%i)",qc,fd->tail,fd->head);
+	TEST_BUG(in_interrupt());
+	TEST_BUG(qc==NULL || fd==NULL);
+	fd->exiting = TRUE;
+	fd->maxrawdatalen = 0;		/* Hopefully stops all ongoing captures, might need locking though */
+	wake_up(&fd->wq);
+	if (qcdebug&QC_DEBUGFRAME) PDEBUG("waiting=%i",fd->waiting);
+	if (qcdebug&QC_DEBUGMUTEX) PDEBUG("up(%p) in qc_frame_exit() : %i", qc, sem_getcount(&qc->lock));
+	up(&qc->lock);			/* The lock was down when entering this function */
+	while (fd->waiting > 0) {
+		schedule();
+#if PARANOID
+		if (jiffies-startjiffy > 60*HZ) {
+			PRINTK(KERN_CRIT,"Wait queue never completing!! (waiting=%i)",fd->waiting);
+			break;
+		}
+#endif
+	}
+	if (qcdebug&QC_DEBUGMUTEX) PDEBUG("down(%p) in qc_frame_exit() : %i", qc, sem_getcount(&qc->lock));
+	down(&qc->lock);
+	vfree(fd->rawdatabuf);
+	POISON(fd->rawdatabuf);
+	IDEBUG_EXIT(*fd);
+}
+/* }}} */
+
+/* Consumer routines, called from kernel mode processes */
+/* {{{ [fold] qc_frame_get(struct quickcam *qc, unsigned char **buf) */
+/* Wait until next frame is ready and return the frame length
+ * and set buf to point to the frame. If error happens,
+ * return standard Linux negative error number.
+ * qc_frame_free() must be called after the frame is not needed anymore.
+ * qc->lock must be acquired when entering this routine
+ * (it may release it temporarily and sleep).
+ */
+static int qc_frame_get(struct quickcam *qc, unsigned char **buf)
+{
+	struct qc_frame_data *fd = &qc->frame_data;
+	int ret;
+
+	TEST_BUGR(qc==NULL || fd==NULL || fd->tail_in_use);
+	TEST_BUGR(in_interrupt());
+	IDEBUG_TEST(*fd);
+
+	/* Wait until the next frame is available */
+	if (qcdebug&QC_DEBUGFRAME) PDEBUG("qc_frame_get/consume(qc=%p,tail=%i,head=%i)",qc,fd->tail,fd->head);
+	fd->waiting++;
+	if (qcdebug&QC_DEBUGMUTEX) PDEBUG("up(%p) in qc_frame_get() : %i", qc, sem_getcount(&qc->lock));
+	up(&qc->lock);					/* Release lock while waiting */
+
+	ret = wait_event_interruptible(fd->wq, fd->head!=fd->tail || fd->exiting);	//FIXME:What if we get -ERESTARTSYS?
+	if (qcdebug&QC_DEBUGMUTEX) PDEBUG("down(%p) in qc_frame_get() : %i", qc, sem_getcount(&qc->lock));
+	down(&qc->lock);
+	if (!ret) {
+		if (!fd->exiting) {
+			unsigned int t;
+			spin_lock(&fd->tail_lock);
+			fd->tail_in_use = TRUE;
+			t = fd->tail;
+			spin_unlock(&fd->tail_lock);
+			if (qcdebug&QC_DEBUGFRAME) PDEBUG("qc_frame_get/consume(qc=%p,tail=%i,head=%i,tail->rawdatalen=%i), got frame",qc,t,fd->head,fd->buffers[t].rawdatalen);
+			*buf = fd->rawdatabuf + t*FRAME_DATASIZE;
+			ret  = fd->buffers[t].rawdatalen;
+		} else {
+			ret = -ENODATA;
+		}
+	}
+	fd->waiting--;
+	fd->lost_frames = 0;
+	if (ret<0 && (qcdebug&(QC_DEBUGERRORS|QC_DEBUGFRAME))) PDEBUG("failed qc_frame_get()=%i",ret);
+	return ret;
+}
+/* }}} */
+/* {{{ [fold] qc_frame_free(struct quickcam *qc) */
+/* Free up the last frame returned from qc_frame_get() (it must be called first) */
+static inline void qc_frame_free(struct quickcam *qc)
+{
+	struct qc_frame_data *fd = &qc->frame_data;
+	TEST_BUG(qc==NULL || fd==NULL);
+	TEST_BUG(in_interrupt());
+	TEST_BUG(fd->head==fd->tail);			/* The current fd->tail is not available to be freed! */
+	IDEBUG_TEST(*fd);
+	if (qcdebug&QC_DEBUGFRAME) PDEBUG("qc_frame_free/consume(qc=%p,tail=%i,head=%i)",qc,fd->tail,fd->head);
+	/* Free up previous frame and advance to next */
+	spin_lock(&fd->tail_lock);
+	fd->tail_in_use = FALSE;
+	fd->tail = (fd->tail + 1) % FRAME_BUFFERS;
+	spin_unlock(&fd->tail_lock);
+}
+/* }}} */
+/* {{{ [fold] qc_frame_test(struct quickcam *qc) */
+/* Return TRUE if next frame is immediately available, FALSE otherwise. */
+static inline Bool qc_frame_test(struct quickcam *qc)
+{
+	struct qc_frame_data *fd = &qc->frame_data;
+	IDEBUG_TEST(*fd);
+	if (qcdebug&QC_DEBUGFRAME) PDEBUG("qc_frame_test/consume(qc=%p,tail=%i,head=%i)",qc,fd->tail,fd->head);
+	return fd->head != fd->tail;
+}
+/* }}} */
+
+/* Producer routines, called from interrupt context */
+/* {{{ [fold] qc_frame_begin(struct quickcam *qc) */
+/* Begin capturing next frame from camera. If buffer is full, the frame will be lost */
+static void qc_frame_begin(struct quickcam *qc)
+{
+	struct qc_frame_data *fd = &qc->frame_data;
+	int framesize, h;
+	TEST_BUG(qc==NULL || fd==NULL);
+	IDEBUG_TEST(*fd);
+	if (qcdebug&QC_DEBUGFRAME) PDEBUG("qc_frame_begin/produce(qc=%p,tail=%i,head=%i)",qc,fd->tail,fd->head);
+	if (fd->exiting) return;
+	TEST_BUG(fd->rawdatabuf==NULL);
+	h = fd->head;
+	fd->buffers[h].rawdatalen = 0;
+
+	/* Use sensor information to get the framesize (i.e. how much we expect to receive bytes per image) */
+	/* FIXME: should compute data size differently in compressed mode */
+	framesize = qc->sensor_data.width * qc->sensor_data.height;
+	fd->maxrawdatalen = MIN(framesize, FRAME_DATASIZE);
+}
+/* }}} */
+/* {{{ [fold] qc_frame_add(struct quickcam *qc, unsigned char *data, int datalen) */
+/* Store more data for a frame, return nonzero if too much data or other error */
+static int qc_frame_add(struct quickcam *qc, unsigned char *data, int datalen)
+{
+	struct qc_frame_data *fd = &qc->frame_data;
+	int h = fd->head;
+	int bytes;
+
+	TEST_BUGR(qc==NULL || fd==NULL);
+	IDEBUG_TEST(*fd);
+	TEST_BUGR(fd->rawdatabuf==NULL);
+	if (fd->maxrawdatalen <= fd->buffers[h].rawdatalen) {
+		if (qcdebug&QC_DEBUGERRORS) PDEBUG("buffer disabled, maxrawdatalen=%i rawdatalen=%i datalen=%i",fd->maxrawdatalen,fd->buffers[h].rawdatalen, datalen);
+		return -EBUSY;
+	}
+	bytes = MIN(datalen, fd->maxrawdatalen - fd->buffers[h].rawdatalen);
+	memcpy(fd->rawdatabuf + h*FRAME_DATASIZE + fd->buffers[h].rawdatalen, data, bytes);
+	fd->buffers[h].rawdatalen += bytes;
+	if (bytes < datalen) {
+		if (qcdebug&QC_DEBUGERRORS) PRINTK(KERN_ERR,"out of buffer space by %i, maxrawdatalen=%i rawdatalen=%i datalen=%i", datalen-bytes,fd->maxrawdatalen,fd->buffers[h].rawdatalen, datalen);
+		return -ENOSPC;
+	}
+	return 0;
+}
+/* }}} */
+/* {{{ [fold] qc_frame_end(struct quickcam *qc) */
+/* Finished capturing most recent frame from camera */
+/* (may be premature end, in which case some data is missing) */
+static void qc_frame_end(struct quickcam *qc)
+{
+	static const int minrawdatalen = 32*32;	/* If frame length is less than this many bytes, discard it */
+	struct qc_frame_data *fd = &qc->frame_data;
+	unsigned int t, h;
+	Bool lost_frame;
+	TEST_BUG(qc==NULL || fd==NULL);
+	h = fd->head;
+	if (qcdebug&QC_DEBUGFRAME) PDEBUG("qc_frame_end/produce(qc=%p,tail=%i,head=%i), got %i bytes",qc,fd->tail,h,fd->buffers[h].rawdatalen);
+	IDEBUG_TEST(*fd);
+	fd->maxrawdatalen = 0;			/* Stop frame data capturing */
+#if DUMPDATA
+	PDEBUG("frame_end: got %i bytes", fd->buffers[h].rawdatalen);
+#endif
+	if (fd->buffers[h].rawdatalen < minrawdatalen) {
+		/* No enough data in buffer, don't advance index */
+		if (qcdebug&QC_DEBUGERRORS) PDEBUG("discarding frame with only %u bytes", fd->buffers[h].rawdatalen);
+		return;
+	}
+	h = (h + 1) % FRAME_BUFFERS;		/* Select next frame buffer to fill */
+
+	lost_frame = FALSE;
+	spin_lock(&fd->tail_lock);
+	t = fd->tail;
+	if (t == h) {
+		lost_frame = TRUE;
+		/* FIXME: the below should work fine for two buffers, but not so well for more. It should be possible
+		 * to drop oldest frame even when the current tail is in use. */
+		if (fd->tail_in_use) {
+			/* Can not drop the oldest frame, it is in use. Drop the newest frame */
+			h = (h + FRAME_BUFFERS - 1) % FRAME_BUFFERS;		/* Decrease head by one back to the original */
+			if (qcdebug&QC_DEBUGFRAME) PDEBUG("dropping newest frame");
+		} else {
+			/* Drop the oldest frame */
+			fd->tail = (t + 1) % FRAME_BUFFERS;			/* Drop the oldest frame away */
+			if (qcdebug&QC_DEBUGFRAME) PDEBUG("dropping oldest frame");
+		}
+	}
+	spin_unlock(&fd->tail_lock);
+	if (lost_frame) {
+		if (qcdebug&QC_DEBUGCOMMON || qcdebug&QC_DEBUGFRAME) PRINTK(KERN_NOTICE,"frame lost");
+		fd->lost_frames++;
+		if (fd->lost_frames > 10) {
+			/* Here we should call qc_isoc_stop() to stop isochronous
+			 * streaming since the application is clearly not reading frames at all.
+			 * However, we are now in interrupt context but qc_isoc_stop() has
+			 * to be in process context... so we can't do that.
+			 * FIXME: add tasklet/bottomhalf/whatever needed to do it.
+			 */
+			if (qcdebug&QC_DEBUGFRAME) PDEBUG("too many lost frames: %i", fd->lost_frames);
+		}
+	}
+	fd->head = h;
+	wake_up(&fd->wq);
+}
+/* }}} */
+/* {{{ [fold] qc_frame_flush(struct quickcam *qc)  */
+/* Reject the current data already captured into buffer and end frame */
+void qc_frame_flush(struct quickcam *qc)
+{
+	struct qc_frame_data *fd = &qc->frame_data;
+	unsigned int h = fd->head;
+	TEST_BUG(qc==NULL || fd==NULL);
+	IDEBUG_TEST(*fd);
+	if (qcdebug&QC_DEBUGFRAME) PDEBUG("qc_frame_flush/produce(qc=%p,tail=%i,head=%i), flush %i bytes",qc,fd->tail,h,fd->buffers[h].rawdatalen);
+	fd->buffers[h].rawdatalen = 0;		/* Empty buffer */
+	fd->maxrawdatalen = 0;			/* Stop frame data capturing */
+}
+/* }}} */
+
+/* }}} */
+/* {{{ [fold] **** qc_stream: USB datastream processing functions *************** */
+
+/* {{{ [fold] qc_stream_init(struct quickcam *qc) */
+/* Initialize datastream processing */
+static int qc_stream_init(struct quickcam *qc)
+{
+	if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGINIT) PDEBUG("qc_stream_init(quickcam=%p)",qc);
+	qc->stream_data.capturing = FALSE;
+	qc->stream_data.frameskip = qc->settings.frameskip;
+	IDEBUG_INIT(qc->stream_data);
+	return 0;
+}
+/* }}} */
+/* {{{ [fold] qc_stream_exit(struct quickcam *qc) */
+/* Stop datastream processing, after this qc_stream_add should not be called */
+static void qc_stream_exit(struct quickcam *qc)
+{
+	if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGINIT) PDEBUG("qc_stream_exit(quickcam=%p)",qc);
+	if (qc->stream_data.capturing)
+		qc_frame_end(qc);
+	IDEBUG_EXIT(qc->stream_data);
+}
+/* }}} */
+/* {{{ [fold] qc_stream_error(struct quickcam *qc) */
+/* This is called when there are data lost due to errors in the stream */
+static void qc_stream_error(struct quickcam *qc)
+{
+	/* Skip rest of data for this frame */
+	if (qcdebug&QC_DEBUGERRORS) PDEBUG("qc_stream_error(qc=%p)", qc);
+	if (qc->stream_data.capturing)
+		qc_frame_end(qc);
+	IDEBUG_EXIT(qc->stream_data);
+	qc_stream_init(qc);
+}
+/* }}} */
+/* {{{ [fold] qc_stream_add(struct quickcam *qc, unsigned char *data, int datalen) */
+/*
+ * Analyse an USB packet of the data stream and store it appropriately.
+ * Each packet contains an integral number of chunks. Each chunk has
+ * 2-bytes identification, followed by 2-bytes that describe the chunk
+ * length. Known/guessed chunk identifications are:
+ * 8001/8005/C001/C005 - Begin new frame
+ * 8002/8006/C002/C006 - End frame
+ * 0200/4200           - Contains actual image data, bayer or compressed
+ * 0005                - 11 bytes of unknown data
+ * 0100                - 2 bytes of unknown data
+ * The 0005 and 0100 chunks seem to appear only in compressed stream.
+ * Return the amount of image data received or negative value on error.
+ */
+static int qc_stream_add(struct quickcam *qc, unsigned char *data, int datalen)
+{
+	struct qc_stream_data *sd = &qc->stream_data;
+	int id, len, error, totaldata = 0;
+	
+	IDEBUG_TEST(*sd);
+	while (datalen) {
+		if (datalen < 4) {
+			if (qcdebug&QC_DEBUGBITSTREAM) PRINTK(KERN_ERR,"missing chunk header");
+			break;
+		}
+		id  = (data[0]<<8) | data[1];
+		len = (data[2]<<8) | data[3];
+		data    += 4;
+		datalen -= 4;
+		if (datalen < len) {
+			if (qcdebug&QC_DEBUGBITSTREAM) PRINTK(KERN_ERR,"missing chunk contents");
+			break;
+		}
+		switch (id) {
+		case 0x8001:
+		case 0x8005:
+		case 0xC001:
+		case 0xC005:
+			/* Begin new frame, len should be zero */
+			if (PARANOID && len!=0) PDEBUG("New frame: len!=0");
+			if (sd->capturing) {
+				if (qcdebug&QC_DEBUGBITSTREAM) PDEBUG("Missing frame end mark in stream");
+				qc_frame_end(qc);
+			}
+			sd->capturing = TRUE;
+			if (--sd->frameskip < 0) sd->frameskip = qc->settings.frameskip;
+			if (sd->frameskip==0) qc_frame_begin(qc);
+			break;
+		case 0x8002:
+		case 0x8006:
+		case 0xC002:
+		case 0xC006:
+			/* End frame, len should be zero */
+			if (PARANOID && len!=0) PDEBUG("End frame: len!=0");
+			if (sd->capturing) {
+				if (sd->frameskip==0) qc_frame_end(qc);
+			} else {
+				if (qcdebug&QC_DEBUGBITSTREAM) PDEBUG("Missing frame begin mark in stream");
+			}
+			sd->capturing = FALSE;
+			break;
+		case 0x0200:
+		case 0x4200:
+			/* Image data */
+			if (!sd->capturing && (qcdebug&QC_DEBUGBITSTREAM)) PDEBUG("Chunk of data outside frames!");
+			if (sd->capturing && sd->frameskip==0) {
+				error = qc_frame_add(qc, data, len);
+			} else {
+				error = 0;
+			}
+			if (error) {
+				/* If qc_frame_add returns error, there is more data than the frame may have,
+				 * in which case we assume stream is corrupted and skip rest packet */
+				if (qcdebug&QC_DEBUGERRORS) PDEBUG("qc_frame_add error %i",error);
+			} else {
+				totaldata += len;
+			}
+			break;
+		case 0x0005:
+			/* Unknown chunk with 11 bytes of data, occurs just before end of each frame in compressed mode */
+			if (len==11) break;
+		case 0x0100:
+			/* Unknown chunk with 2 bytes of data, occurs 2-3 times per USB interrupt */
+			if (len==2) break;
+		default:
+			/* Unknown chunk */
+			#ifdef DEBUG
+			if (qcdebug&QC_DEBUGBITSTREAM) {
+				static char dump[4*1024];
+				char *dump_p = dump;
+				int i;
+				for (i=0; i<len && (3*i+9)<sizeof(dump); i++) dump_p+=sprintf(dump_p, "%02X ", data[i]);
+				PDEBUG("Unknown chunk %04X: %s", id, dump);
+			}
+			#endif
+			break;
+		}
+		data    += len;
+		datalen -= len;
+	}
+	return totaldata;
+}
+/* }}} */
+
+/* }}} */
+/* {{{ [fold] **** qc_isoc:   Isochronous USB transfer related routines ********* */
+
+/*
+ * On my system (Acer Travelmate 332T, usb-ohci) there happens frequently
+ * errors. Most common are:
+ * -18	EXDEV	(even inside individual frames)
+ * -84	EILSEQ
+ * -71	EPROTO
+ * -110	ETIMEDOUT
+ * -75	EOVERFLOW ??
+ */
+/* {{{ [fold] qc_isoc_handler(struct urb *urb) */
+/* This is URB completion handler and is called in interrupt context.
+ * For each submitted URB, this function is guaranteed to be called exactly once.
+ * This function may not be called reentrantly for the same qc (should be ok, IRQs don't nest).
+ * It will resubmit the same urb, unless
+ * - Isochronous URB stream is disabled
+ * - Camera was disconnected
+ * - There are too many transfer errors
+ */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+static void qc_isoc_handler(struct urb *urb, struct pt_regs *ptregs)
+#else
+static void qc_isoc_handler(struct urb *urb)
+#endif
+{
+	struct quickcam *qc;
+	int payload = 0;	/* Amount of all data camera sent */
+	int totaldata = 0;	/* Amount of image data camera sent */
+	int i;
+#ifdef DEBUG
+	/* Check for nested interrupts, shouldn't happen */
+	volatile static Bool in_progress = FALSE;
+	TEST_BUG(in_progress);
+	in_progress = TRUE;
+#endif
+
+	if (qcdebug&QC_DEBUGINTERRUPTS) PDEBUG("[INTR] qc_isoc_handler(urb=%p)",urb);
+	TEST_BUG(urb==NULL);
+	qc = urb->context;
+	TEST_BUG(qc==NULL);
+	IDEBUG_TEST(qc->isoc_data);
+
+	if (!qc->connected || !qc->isoc_data.streaming) {
+		/* Camera was disconnected or isochronous stream just disabled--must not resubmit urb */
+		PDEBUG("Ignoring isoc interrupt, dev=%p streaming=%i status=%i", qc->dev, qc->isoc_data.streaming, urb->status);
+		goto out;
+	}
+
+	if (urb->status<0) {
+		qc->isoc_data.errorcount++;
+		switch (urb->status) {
+		case -EXDEV:		/* Partially completed, look at individual frame status */
+			break;
+		default:
+			/* Seen here: -EOVERFLOW (75): Value too large for defined data type */
+		case -EPROTO:		/* Bitstuff error or unknown USB error */
+		case -EILSEQ:		/* CRC mismatch */
+		case -ETIMEDOUT:	/* Transfer timed out */
+		case -EREMOTEIO:	/* Short packet detected */
+		case -EPIPE:		/* Babble detect or endpoint stalled */
+		case -ECONNRESET:	/* Asynchronous unlink, should not happen, but does with 2.6.x */
+			if (qcdebug&QC_DEBUGERRORS) PRINTK(KERN_ERR,"isoc URB error %i, resubmitting",urb->status);
+			goto resubmit;
+		case -ESHUTDOWN:
+		case -ENOENT:		/* URB was unlinked */
+		case -ENODEV:		/* Device was removed */
+			if (qcdebug&QC_DEBUGERRORS) PRINTK(KERN_ERR,"isoc URB error %i, returning",urb->status);
+			goto out;
+		}
+	}
+
+	for (i=0; i<urb->number_of_packets; i++) {
+		if ((int)urb->iso_frame_desc[i].status<0) {			/* Note that the cast to int MUST be here! */
+			if (qcdebug&QC_DEBUGERRORS) PDEBUG("USB transfer error %i", urb->iso_frame_desc[i].status);
+			qc->isoc_data.errorcount++;
+			qc_stream_error(qc);
+			continue;
+		}
+		qc->isoc_data.errorcount = 0;
+		payload += urb->iso_frame_desc[i].actual_length;
+#if PARANOID
+{
+int xx = urb->iso_frame_desc[i].actual_length;
+if (xx>2000) {
+PDEBUG("i=%i status=%i transfer_buffer=%p transfer_buffer_length=%i actual_length=%i number_of_packets=%i", 
+ i, urb->status, urb->transfer_buffer, urb->transfer_buffer_length, urb->actual_length, urb->number_of_packets);
+PDEBUG("offset=%i length=%i actual_length=%i pstatus=%i", 
+urb->iso_frame_desc[i].offset, urb->iso_frame_desc[i].length, urb->iso_frame_desc[i].actual_length, urb->iso_frame_desc[i].status);
+goto out;
+}
+}
+#endif
+		totaldata += qc_stream_add(qc, urb->transfer_buffer + urb->iso_frame_desc[i].offset,
+			urb->iso_frame_desc[i].actual_length);
+	}
+	if (qcdebug&QC_DEBUGBITSTREAM) PDEBUG("payload=%i  totaldata=%i",payload,totaldata);
+	if (qcdebug&(QC_DEBUGBITSTREAM|QC_DEBUGERRORS)) if (payload==0) PDEBUG("USB interrupt, but no data received!");
+resubmit:
+	/* Resubmit URB */
+	if (qc->isoc_data.errorcount < ISOC_PACKETS*ISOC_URBS*8) {
+		urb->dev = qc->dev;			/* Required for 2.4.x */
+		i = usb_submit_urb(urb,GFP_ATOMIC);
+		if (i) PDEBUG("failed to resubmit URB, code=%i, dev=%p",i,urb->dev);
+	} else {
+		PDEBUG("Too many errors, giving up");
+	}
+out:
+#ifdef DEBUG
+	in_progress = FALSE;
+#endif
+	return;
+}
+/* }}} */
+/* {{{ [fold] qc_isoc_start(struct quickcam *qc) */
+/*
+ * Start USB isochronous image transfer from camera to computer
+ * (Set USB camera interface and allocate URBs and submit them)
+ * Sensor must be initialized beforehand (qc_init_sensor)
+ */
+static int qc_isoc_start(struct quickcam *qc)
+{
+	struct qc_isoc_data *id = &qc->isoc_data;
+	int ret = -ENOMEM;		/* Return value on error */
+	struct urb *urb;
+	int i, b;
+
+	if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGINIT) PDEBUG("qc_isoc_start(qc=%p)",qc);
+	TEST_BUGR_MSG(qc==NULL || id==NULL, "qc||id==NULL");
+	IDEBUG_TEST(*id);
+
+	if (id->streaming) return 0;		/* Already started */
+	id->streaming = TRUE;
+	id->errorcount = 0;
+
+	/* Allocate transfer buffer */
+	id->buffer = kmalloc(ISOC_URBS * ISOC_PACKETS * ISOC_PACKET_SIZE, GFP_KERNEL);
+	CHECK_ERROR(!id->buffer, fail1, "Out of memory allocating id->buffer");
+
+	/* Allocate URBs, fill them, and put them in the URB array */
+	for (b=0; b<ISOC_URBS; b++) {
+		urb = id->urbs[b] = usb_alloc_urb(ISOC_PACKETS,GFP_KERNEL);	/* Zeroes the allocated data up to iso_frame_desc[], *not* including the last! */
+		CHECK_ERROR(!urb, fail2, "Out of memory allocating urbs");
+		urb->dev                    = qc->dev;
+		urb->context                = qc;
+		urb->pipe                   = usb_rcvisocpipe(qc->dev, QUICKCAM_ISOPIPE);
+		urb->transfer_flags         = URB_ISO_ASAP;
+		urb->complete               = qc_isoc_handler;
+		urb->number_of_packets      = ISOC_PACKETS;
+		urb->transfer_buffer        = id->buffer;
+		urb->transfer_buffer_length = ISOC_URBS * ISOC_PACKETS * ISOC_PACKET_SIZE;
+		urb->interval               = 1;			/* See Table 9-10 of the USB 1.1 specification */
+		for (i=0; i<ISOC_PACKETS; i++) {
+			urb->iso_frame_desc[i].offset = b*ISOC_PACKETS*ISOC_PACKET_SIZE + i*ISOC_PACKET_SIZE;
+			urb->iso_frame_desc[i].length = ISOC_PACKET_SIZE;
+		}
+	}
+
+	/* Alternate interface 3 is the biggest frame size */
+	/* JFC use 1: but do not know why */
+	/* QuickCam Web: Interface 0, alternate 1, endpoint 0x81 -tuukkat */
+	qc_i2c_wait(qc);			/* There must not be control URBs going when calling set_interface() */
+	ret = usb_set_interface(qc->dev, qc->iface, 1);
+	CHECK_ERROR(ret<0, fail3, "set_interface failed");
+
+	/* Submit URBs */
+	for (b=0; b<ISOC_URBS; b++) {
+		ret = usb_submit_urb(id->urbs[b],GFP_KERNEL);
+		CHECK_ERROR(ret<0, fail4, "submit urbs failed");
+	}
+
+	/* Tell camera to start sending data */
+	ret = qc->sensor_data.sensor->start(qc);	/* Start current frame */
+	CHECK_ERROR(ret<0, fail5, "sensor_data.start failed");
+	ret = qc_stv_set(qc, STV_ISO_ENABLE, 1);	/* Start isochronous streaming */
+	CHECK_ERROR(ret<0, fail6, "qc_stv_set() failed");
+	return 0;
+
+	/* Cleanup and return error code on failure */
+fail6:	qc->sensor_data.sensor->stop(qc);		/* stop current frame. */
+fail5:	b = ISOC_URBS;
+fail4:	while (--b >= 0) qc_unlink_urb_sync(id->urbs[b]);
+	usb_set_interface(qc->dev, qc->iface, 0);	/* Set packet size to 0 (Interface 0, alternate 0, endpoint 0x81 -tuukkat) */
+fail3:	b = ISOC_URBS;
+fail2:	while (--b >= 0) usb_free_urb(id->urbs[b]);
+	kfree(id->buffer);
+fail1:	if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGERRORS) PDEBUG("failed qc_isoc_init()=%i",ret);
+	return ret;
+}
+/* }}} */
+/* {{{ [fold] qc_isoc_stop(struct quickcam *qc) */
+/*
+ * Stop USB isochronous image transfer from camera to computer
+ * (Tell camera to stop sending images, set idle USB interface and free URBs)
+ * There must be no more isochronous transfer interrupts after this returns
+ * nor any running handlers anymore.
+ */
+static void qc_isoc_stop(struct quickcam *qc)
+{
+	struct qc_isoc_data *id = &qc->isoc_data;
+	int b, r;
+
+	if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGINIT) PDEBUG("qc_isoc_stop(quickcam=%p)",qc);
+	TEST_BUG_MSG(qc==NULL || id==NULL, "qc||id==NULL");
+	IDEBUG_TEST(*id);
+
+	if (!id->streaming) return;					/* Already stopped */
+	if (qc->connected) {
+		if ((r=qc_stv_set(qc, STV_ISO_ENABLE, 0))<0)		/* stop ISO-streaming. */
+			PRINTK(KERN_ERR,"qc_stv_set error %i",r);
+		if ((r=qc->sensor_data.sensor->stop(qc))<0)		/* stop current frame. */
+			PRINTK(KERN_ERR,"sensor_data.stop error %i",r);
+		qc_i2c_wait(qc);					/* When calling set_interface(), there must not be control URBs on way */
+		if (usb_set_interface(qc->dev, qc->iface, 0) < 0)	/* Set packet size to 0 (Interface 0, alternate 0, endpoint 0x81 -tuukkat) */
+			PRINTK(KERN_ERR,"usb_set_interface error");
+	}
+	id->streaming = FALSE;						/* Ensure that no more isochronous URBs will be submitted from the interrupt handler */
+	mb();
+	for (b=0; b<ISOC_URBS; b++) {					/* Unschedule all of the iso td's */
+		PDEBUG("isoc urb[%i]->status = %i", b, id->urbs[b]->status);
+		qc_unlink_urb_sync(id->urbs[b]);
+		usb_free_urb(id->urbs[b]);
+		POISON(id->urbs[b]);
+	}
+
+	kfree(id->buffer);
+	POISON(id->buffer);
+	return;
+}
+/* }}} */
+/* {{{ [fold] qc_isoc_init(struct quickcam *qc) */
+/*
+ * Initialize isochronous streaming functions
+ */
+static int qc_isoc_init(struct quickcam *qc)
+{
+	struct qc_isoc_data *id = &qc->isoc_data;
+	if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGINIT) PDEBUG("qc_isoc_init(quickcam=%p)",qc);
+	TEST_BUGR_MSG(qc==NULL || id==NULL, "qc||id==NULL");
+	IDEBUG_INIT(*id);
+	id->streaming = FALSE;
+	return 0;
+}
+/* }}} */
+/* {{{ [fold] qc_isoc_exit(struct quickcam *qc) */
+/*
+ * Uninitialize isochronous streaming functions
+ */
+static inline void qc_isoc_exit(struct quickcam *qc)
+{
+	if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGINIT) PDEBUG("qc_isoc_exit(quickcam=%p)",qc);
+	qc_isoc_stop(qc);
+	IDEBUG_EXIT(qc->isoc_data);
+}
+/* }}} */
+/* {{{ [fold] Bool qc_isoc_streaming(struct quickcam *qc) */
+static inline Bool qc_isoc_streaming(struct quickcam *qc)
+{
+	struct qc_isoc_data *id = &qc->isoc_data;
+
+	TEST_BUGR_MSG(qc==NULL || id==NULL, "qc||id==NULL");
+	IDEBUG_TEST(*id);
+	return id->streaming;
+}
+/* }}} */
+
+/* }}} */
+/* {{{ [fold] **** qc_sensor: Common routines for all sensors ******************* */
+
+/* {{{ [fold] qc_sensor_setsize0(struct quickcam *qc, unsigned int width, unsigned int height) */
+/* Called when the application requests a specific image size. Should set the
+ * actual delivered image size to as close to the requested as possible.
+ * The image size, as delivered from the camera, can be also set to reduce
+ * required bandwidth, if possible, but it is not necessary.
+ * This is a private function to qc_sensor_*, other modules should use qc_sensor_setsize()
+ * If capt is TRUE, then qc_capt_get may be called (and qc_capt_init must be called before).
+ */
+static int qc_sensor_setsize0(struct quickcam *qc, unsigned int width, unsigned int height, Bool capt)
+{
+	unsigned char *f;
+	int r;
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_sensor_setsize(qc=%p,width=%i,height=%i)",qc,width,height);
+	TEST_BUGR_MSG(qc==NULL, "qc==NULL!");
+
+	if (width < min_framewidth || width > qc->sensor_data.maxwidth) return -EINVAL;
+	if (height < min_frameheight || height > qc->sensor_data.maxheight) return -EINVAL;
+
+	/* Applications require, when using Xvideo extension, that the
+	 * frame size is multiple of 8. This is a bug in apps or Xvideo. -tuukkat */
+	if (qc->settings.compat_16x) {
+		width  = (width /16)*16;
+		height = (height/16)*16;
+	}
+	/* Set the size only if changed */
+	if (qc->vwin.width==width && qc->vwin.height==height) return 0;
+
+	/* For HDCS-1000 we must wait for frame before setting size */
+	if (capt) qc_capt_get(qc, &f);
+
+	qc->sensor_data.width = width;		/* The sensor-specific code may modify these if not suitable */
+	qc->sensor_data.height = height;
+	if ((r = qc->sensor_data.sensor->set_size(qc, width, height))<0) {
+		PDEBUG("set_size sensor failed");
+		return r;
+	}
+
+	/* Set the closest size we can actually deliver to application */
+	qc->vwin.width  = width;
+	qc->vwin.height = height;
+	if ((r = qc_i2c_wait(qc))<0) return r;
+	qc_frame_flush(qc);	
+	return 0;
+}
+/* }}} */
+/* {{{ [fold] qc_sensor_setsize(struct quickcam *qc, unsigned int width, unsigned int height) */
+/* Called when the application requests a specific image size. Should set the
+ * actual delivered image size to as close to the requested as possible.
+ * The image size, as delivered from the camera, can be also set to reduce
+ * required bandwidth, if possible, but it is not necessary.
+ * qc_isoc_init() and qc_capt_init() have to be called before this function.
+ */
+static inline int qc_sensor_setsize(struct quickcam *qc, unsigned int width, unsigned int height)
+{
+	int r;
+	r = qc_sensor_setsize0(qc, width, height, qc_isoc_streaming(qc));
+	return r;
+}
+/* }}} */
+/* {{{ [fold] qc_sensor_init(struct quickcam *qc) */
+/*
+ * Initialise sensor. Initializes all data in qc->sensor which is common to all
+ * types of sensors and calls the sensor-specific initialization routine.
+ * The Photobit starts the pixel integration immediately after the reset.
+ * Note: must call qc_i2c_init() and qc_frame_init() before this function!
+ */
+static int qc_sensor_init(struct quickcam *qc)
+{
+	int r;
+
+	if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGINIT) PDEBUG("qc_init_sensor(qc=%p)",qc);
+	TEST_BUGR_MSG(qc==NULL, "qc==NULL!");
+
+	qc->sensor_data.width     = -1;
+	qc->sensor_data.height    = -1;
+	qc->sensor_data.exposure  = -1;
+	qc->sensor_data.rgain     = -1;
+	qc->sensor_data.ggain     = -1;
+	qc->sensor_data.bgain     = -1;
+	qc->sensor_data.subsample = qc->settings.subsample;
+	qc->sensor_data.compress  = qc->settings.compress;
+
+	if ((r = qc->sensor_data.sensor->init(qc))<0) goto fail;
+	if ((r = qc_stv_set(qc, STV_ISO_ENABLE, 0))<0) goto fail;		/* Stop isochronous streaming */
+	if ((r = qc->sensor_data.sensor->stop(qc))<0) goto fail;		/* Stop current frame */
+
+	/* Set capture size */
+	qc->vwin.width  = 0;			/* Set to illegal value (ensures resetting) */
+	qc->vwin.height = 0;
+	if ((r = qc_sensor_setsize0(qc, qc->sensor_data.maxwidth, qc->sensor_data.maxheight, FALSE))<0) goto fail;
+
+	/* Set brightness settings */
+	if ((r = qc->sensor_data.sensor->set_levels(qc, qc->vpic.brightness, qc->vpic.contrast, qc->vpic.hue, qc->vpic.colour))<0) goto fail;
+	if (qc->sensor_data.sensor->set_target!=NULL)
+		if ((r = qc->sensor_data.sensor->set_target(qc, qc->vpic.brightness))<0) goto fail;
+	return 0;
+
+fail:	PRINTK(KERN_ERR,"sensor initialization failed: %i",r);
+	return r;
+}
+/* }}} */
+
+/* }}} */
+/* {{{ [fold] **** qc_capt:   User image capturing functions ******************** */
+
+/* {{{ [fold] qc_capt_get(struct quickcam *qc, unsigned char **frame) */
+/* Wait until next image is ready and return the image length in bytes
+ * and set "frame" to point to the image. If error happens,
+ * return standard Linux negative error number. The image will be in
+ * palette and size requested by the user (quickcam->vpic,vwin).
+ */
+static int qc_capt_get(struct quickcam *qc, unsigned char **frame)
+{
+	struct qc_capt_data *cd = &qc->capt_data;
+	unsigned char *rawdata;		/* Raw data from camera */
+	int rawdatalen;
+	int retrycount = qc->settings.retryerrors ? 8 : 0;
+	int settlecount = cd->settled ? 0 : qc->settings.settle;	/* If the picture has already settled, do not wait for it again */
+	int midvalue;
+	int r;
+
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_capt_get(quickcam=%p)",qc);
+	IDEBUG_TEST(*cd);
+	if ((r = qc_isoc_start(qc))<0) goto fail;		/* Start receiving data */
+
+	do {
+		r = qc_frame_get(qc, &rawdata);
+		if (r < 0) goto error;
+		rawdatalen = r;
+		r = qc_fmt_convert(qc, rawdata, rawdatalen, cd->frame, MAX_FRAME_SIZE, &midvalue);
+		if (r < 0) {
+			qc_frame_free(qc);
+			goto error;
+		}
+
+		if (qc->vpic_pending) {
+			qc->vpic_pending = FALSE;
+			if (!qc->settings.adaptive) {
+				/* Set new values now */
+				qc->sensor_data.sensor->set_levels(qc, qc->vpic.brightness, qc->vpic.contrast, qc->vpic.hue, qc->vpic.colour);
+			} else {
+				if (qc->sensor_data.sensor->set_target!=NULL)
+					qc->sensor_data.sensor->set_target(qc, qc->vpic.brightness);
+			}
+		}
+
+		if (qc->settings.adaptive && !qc->sensor_data.sensor->autoexposure && r>=0 && midvalue>=0) {
+			int ex, gn;
+			qc_adapt(qc, midvalue, qc->vpic.brightness>>8, &ex, &gn);
+			qc->sensor_data.sensor->set_levels(qc, ex, gn, qc->vpic.hue, qc->vpic.colour);
+		}
+		qc_frame_free(qc);
+
+		if (qc_adapt_hassettled(qc) || settlecount<=0) break;
+		settlecount--;
+
+error:		if (r < 0) {
+			if (qcdebug&QC_DEBUGERRORS) PDEBUG("retrying failed qc_frame_get... rounds=%i", retrycount);
+			if (r==-ERESTARTSYS || retrycount<=0) break;
+			retrycount--;
+		}
+		qc_i2c_flush(qc);				/* Send all pending I2C transfers */
+		schedule();
+	} while (TRUE);
+	if (r<0) goto fail;
+	qc_i2c_flush(qc);				/* Send all pending I2C transfers */
+	cd->settled = TRUE;
+	if (frame) *frame = cd->frame;
+	return r;
+
+fail:	if (qcdebug&(QC_DEBUGERRORS|QC_DEBUGLOGIC)) PDEBUG("failed qc_capt_get()=%i", r);
+	return r;
+}
+/* }}} */
+/* {{{ [fold] qc_capt_frameaddr(struct quickcam *qc, unsigned char **frame) */
+/* Return size and address of the capture buffer that is suitable for mmapping,
+ * Standard Linux errno on error */
+static inline int qc_capt_frameaddr(struct quickcam *qc, unsigned char **frame)
+{
+	IDEBUG_TEST(qc->capt_data);
+	if (frame!=NULL) *frame = qc->capt_data.frame;
+	return MAX_FRAME_SIZE;
+}
+/* }}} */
+/* {{{ [fold] qc_capt_test(struct quickcam *qc) */
+/* Return TRUE if next image is immediately available, FALSE otherwise.
+ * Also starts streaming video from camera if not already done so.
+ * Before calling this function, qc_isoc_init() must be called first. */
+static inline Bool qc_capt_test(struct quickcam *qc)
+{
+	int e;
+	IDEBUG_TEST(qc->capt_data);
+	e = qc_isoc_start(qc);
+	if (qcdebug&QC_DEBUGERRORS && e<0) PDEBUG("qc_capt_test: qc_isoc_start failed");
+	return qc_frame_test(qc);
+}
+/* }}} */
+/* {{{ [fold] qc_capt_init(struct quickcam *qc) */
+static int qc_capt_init(struct quickcam *qc)
+{
+	struct qc_capt_data *cd = &qc->capt_data;
+	int r;
+
+	if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGINIT) PDEBUG("qc_capt_init(quickcam=%p)",qc);
+
+	cd->settled = !(qc->settings.settle>0 && qc->settings.adaptive);
+
+	/* Allocate memory for the (mmappable) capture buffer */
+	cd->frame = qc_mm_rvmalloc(MAX_FRAME_SIZE);
+	if (!cd->frame) {
+		PRINTK(KERN_ERR, "unable to allocate frame");
+		r = -ENOMEM;
+		goto fail1;
+	}
+
+	/* Initialize submodules */
+	if ((r=qc_frame_init(qc))<0) goto fail2;	/* Must be before sensor_init() */
+	r = qc_sensor_init(qc);				/* Start the sensor (must be after qc_i2c_init but before qc_adapt_init) */
+	if (r<0 && qc->settings.compress) {
+		/* Sensor init failed with compression. Try again without compression */
+		PRINTK(KERN_NOTICE, "sensor init failed, disabling compression");
+		qc->settings.compress = 0;
+		r = qc_sensor_init(qc);
+	}
+	if (r<0) goto fail3;
+	if ((r=qc_stream_init(qc))<0) goto fail3;
+	if ((r=qc_fmt_init(qc))<0) goto fail4;
+	if ((r=qc_isoc_init(qc))<0) goto fail5;
+	IDEBUG_INIT(*cd);
+	return 0;
+
+fail5:	qc_fmt_exit(qc);
+fail4:	qc_stream_exit(qc);
+fail3:	qc_frame_exit(qc);
+fail2:	qc_mm_rvfree(cd->frame, MAX_FRAME_SIZE);
+fail1:	PDEBUG("failed qc_capt_init()=%i",r);
+	return r;
+}
+/* }}} */
+/* {{{ [fold] qc_capt_exit(struct quickcam *qc) */
+static void qc_capt_exit(struct quickcam *qc)
+{
+	struct qc_capt_data *cd = &qc->capt_data;
+	if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGINIT) PDEBUG("qc_capt_exit(quickcam=%p)",qc);
+	qc_isoc_exit(qc);
+	qc_fmt_exit(qc);
+	qc_stream_exit(qc);
+	qc_frame_exit(qc);
+	qc_mm_rvfree(cd->frame, MAX_FRAME_SIZE);
+	POISON(cd->frame);
+	IDEBUG_EXIT(*cd);
+}
+/* }}} */
+
+/* }}} */
+/* {{{ [fold] **** qc_v4l:    Start of Video 4 Linux API ************************ */
+
+/* {{{ [fold] qc_v4l_poll(struct video_device *dev, struct file *file, poll_table *wait) */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+static unsigned int qc_v4l_poll(struct file *file, poll_table *wait)
+#else
+static unsigned int qc_v4l_poll(struct video_device *dev, struct file *file, poll_table *wait)
+#endif
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+	struct video_device *dev = video_devdata(file);
+#endif
+	struct quickcam *qc = (struct quickcam *)dev->priv;
+	struct qc_frame_data *fd = &qc->frame_data;
+	int mask;
+
+	if (qcdebug&QC_DEBUGUSER) PDEBUG("qc_v4l_poll(dev=%p,file=%p,wait=%p)",dev,file,wait);
+	if (down_interruptible(&qc->lock)) return -ERESTARTSYS;
+	poll_wait(file, &fd->wq, wait);
+	mask = qc_capt_test(qc) ? (POLLIN | POLLRDNORM) : 0;
+	up(&qc->lock);
+	return mask;
+}
+/* }}} */
+/* {{{ [fold] qc_v4l_init(struct quickcam *qc) */
+/* Called when the device is opened */
+static int qc_v4l_init(struct quickcam *qc)
+{
+	int r, fps;
+
+	if (!qc->settings.keepsettings) {
+		/* Reset brightness settings */
+		qc->vpic.brightness = 32768;
+		qc->vpic.hue        = 32768;
+		qc->vpic.colour     = 32768;
+		qc->vpic.contrast   = 32768;
+		qc->vpic.whiteness  = 32768;
+		qc_adapt_reset(qc);				/* qc_adapt_init() is called from qc_usb_init() */
+	}
+	qc->vpic.palette = VIDEO_PALETTE_RGB24;
+	qc->vpic.depth   = qc_fmt_getdepth(qc->vpic.palette);
+	qc->vpic_pending = FALSE;
+
+	fps = qc->settings.subsample ? 30 : 8;	/* May actually vary depending on image size */
+	fps = qc->settings.compress ? 15 : fps;	/* Actually 7.5 fps, but we must round it */
+	qc->vwin.flags = fps << 16;		/* Bits 22..16 contain framerate in Philips driver. We do the same. */
+
+	if ((r = qc_capt_init(qc))<0) goto fail;
+	return 0;
+
+fail:	if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGERRORS) PDEBUG("failed qc_v4l_init()=%i",r);
+	return r;
+}
+/* }}} */
+/* {{{ [fold] qc_v4l_open(struct video_device *dev, int flags) */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+static int qc_v4l_open(struct inode *inode, struct file *file)
+#else
+static int qc_v4l_open(struct video_device *dev, int flags)
+#endif
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+	struct video_device *dev = video_devdata(file);
+#endif
+	struct quickcam *qc = dev->priv;
+	int r;
+
+	if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGUSER) PDEBUG("qc_v4l_open(qc=%p)", qc);
+//PDEBUG("sleeping 10 sec...");
+//qc_usleep(1000000*10);
+//PDEBUG("sleep done");
+	// FIXME: if the module is tried to be unloaded at this point,
+	// v4l_close() and MOD_DEC_USE_COUNT will never be called
+	// According to "Linux Device drivers" pg.70, it's ok if called before sleeping?
+	// 2.2 will crash, 2.4 will hang and show "quickcam 1 (deleted)" if sleeping
+	if (qcdebug&QC_DEBUGMUTEX) PDEBUG("MOD_INC_USE_COUNT in qc_v4l_open() : %i",GET_USE_COUNT(THIS_MODULE));
+	MOD_INC_USE_COUNT;
+
+	if (qcdebug&QC_DEBUGMUTEX) PDEBUG("down_intr(quickcam_list) in qc_v4l_open() : %i", sem_getcount(&quickcam_list_lock));
+
+	r = qc_lock(qc);
+	if (r<0) goto fail1;
+
+	if (qcdebug&QC_DEBUGMUTEX) PDEBUG("down_intr(%p) in qc_v4l_open() : %i", qc, sem_getcount(&qc->lock));
+	if (down_interruptible(&qc->lock)) {
+		r = -ERESTARTSYS;
+		goto fail2;
+	}
+	if (!qc->connected) {
+		r = -ENODEV;
+		goto fail3;
+	}
+	qc->users++;
+	PDEBUG("open users=%i", qc->users);
+	if (qc->users == 1) {
+		if (qcdebug&QC_DEBUGLOGIC) PDEBUG("First user, initializing");
+		if ((r = qc_v4l_init(qc))<0) goto fail4;
+	}
+	if (qcdebug&QC_DEBUGMUTEX) PDEBUG("up(%p) in qc_v4l_open() : %i",qc, sem_getcount(&qc->lock));
+	up(&qc->lock);
+	up(&quickcam_list_lock);
+	return 0;
+
+fail4:	qc->users--;
+fail3:	if (qcdebug&QC_DEBUGMUTEX) PDEBUG("up(%p) in qc_v4l_open()=failed : %i",qc, sem_getcount(&qc->lock));
+	up(&qc->lock);
+fail2:	if (qcdebug&QC_DEBUGMUTEX) PDEBUG("up(quickcam_list) in qc_v4l_open()=failed : %i", sem_getcount(&qc->lock));
+	up(&quickcam_list_lock);
+fail1:	if (qcdebug&QC_DEBUGMUTEX) PDEBUG("MOD_DEC_USE_COUNT in qc_v4l_open() : %i",GET_USE_COUNT(THIS_MODULE));
+	MOD_DEC_USE_COUNT;
+	if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGERRORS) PDEBUG("failed qc_v4l_open()=%i",r);
+	return r;
+}
+/* }}} */
+/* {{{ [fold] qc_v4l_exit(struct quickcam *qc) */
+/* Release all resources allocated at qc_v4l_init() */
+static inline void qc_v4l_exit(struct quickcam *qc)
+{
+	if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGINIT) PDEBUG("qc_v4l_cleanup(%p)", qc);
+	qc_capt_exit(qc);
+}
+/* }}} */
+/* {{{ [fold] qc_v4l_close(struct video_device *dev) */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+static int qc_v4l_close(struct inode *inode, struct file *file)
+#else
+static void qc_v4l_close(struct video_device *dev)
+#endif
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+	struct video_device *dev = video_devdata(file);
+#endif
+	struct quickcam *qc = (struct quickcam *)dev->priv;
+	if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGUSER) PDEBUG("qc_v4l_close(dev=%p,qc=%p)",dev,qc);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+	TEST_BUGR_MSG(qc==NULL, "qc==NULL");
+#else
+	TEST_BUG_MSG(qc==NULL, "qc==NULL");
+#endif
+	if (qcdebug&QC_DEBUGMUTEX) PDEBUG("down(quickcam_list) in qc_v4l_close() : %i", sem_getcount(&quickcam_list_lock));
+	down(&quickcam_list_lock);	/* Can not interrupt, we must success */
+	if (qcdebug&QC_DEBUGMUTEX) PDEBUG("down(%p) in qc_v4l_close() : %i", qc, sem_getcount(&qc->lock));
+	down(&qc->lock);		/* Can not interrupt, we must success */
+	qc->users--;
+	PDEBUG("close users=%i", qc->users);
+	if (qc->users == 0) {
+		/* No more users, device is deallocated */
+		qc_v4l_exit(qc);
+		if (qc->dev == NULL) {		/* Test qc->dev instead of qc->connected because disconnection routine sets the latter before locking camera */
+			/* Camera was unplugged and freeing was postponed: free resources now here */
+			if (qcdebug&QC_DEBUGLOGIC) PDEBUG("Performing postponed free");
+			qc_usb_exit(qc);
+			qc = NULL;
+		}
+	}
+	if (qc) {
+		if (qcdebug&QC_DEBUGMUTEX) PDEBUG("up(%p) in qc_v4l_close() : %i", qc, sem_getcount(&qc->lock));
+		up(&qc->lock);
+	}
+	if (qcdebug&QC_DEBUGMUTEX) PDEBUG("up(quickcam_list) in qc_v4l_close() : %i", sem_getcount(&quickcam_list_lock));
+	up(&quickcam_list_lock);
+	if (qcdebug&QC_DEBUGMUTEX) PDEBUG("MOD_DEC_USE_COUNT in qc_v4l_close() : %i", GET_USE_COUNT(THIS_MODULE));
+	MOD_DEC_USE_COUNT;
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("v4l_close() ok");
+#if LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,0)
+	return 0;
+#endif
+}
+/* }}} */
+/* {{{ [fold] qc_v4l_read(struct video_device *dev, char *buf, unsigned long count, int noblock) */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+static int qc_v4l_read(struct file *file, char *buf, size_t count, loff_t *ppos)
+#else
+static long qc_v4l_read(struct video_device *dev, char *buf, unsigned long count, int noblock)
+#endif
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+	struct video_device *dev = video_devdata(file);
+	int noblock = file->f_flags & O_NONBLOCK;
+#endif
+	struct quickcam *qc = (struct quickcam *)dev->priv;
+	int frame_len;
+	unsigned char *frame;
+	long r = 0;
+
+	if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGUSER)
+		PDEBUG("qc_v4l_read(dev=%p,buf=%p,count=%li,noblock=%i,qc=%p)",dev,buf,(long)count,noblock,qc);
+	if (!qc || !buf) {
+		PDEBUG("qc_read: no video_device available or no buffer attached :( EFAULT");
+		return -EFAULT;
+	}
+	if (qcdebug&QC_DEBUGMUTEX) PDEBUG("down_intr(%p) in qc_v4l_read() : %i", qc, sem_getcount(&qc->lock));
+	if (down_interruptible(&qc->lock)) return -ERESTARTSYS;
+	if (!qc->connected) {
+		r = -ENODEV;
+		goto fail;
+	}
+	if (noblock && !qc_capt_test(qc)) {
+		r = -EAGAIN;
+		goto fail;
+	}
+	frame_len = qc_capt_get(qc, &frame);
+	if (frame_len < 0) {
+		r = frame_len;
+		goto fail;
+	}
+	if (count > frame_len) count = frame_len;
+	if (copy_to_user(buf, frame, count)) {
+		r = -EFAULT;
+		goto fail;
+	}
+	r = count;
+
+fail:	if (qcdebug&QC_DEBUGMUTEX) PDEBUG("up(%p) in qc_v4l_read() : %i", qc, sem_getcount(&qc->lock));
+	up(&qc->lock);
+	if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGERRORS) if (r<0) PDEBUG("failed qc_v4l_read()=%i", (int)r);
+	return r;
+}
+/* }}} */
+/* {{{ [fold] qc_v4l_mmap(struct vm_area_struct *vma, struct video_device *dev, const char *adr, unsigned long size) */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+static int qc_v4l_mmap(struct file *file, struct vm_area_struct *vma)
+#else
+static int qc_v4l_mmap(
+#if HAVE_VMA
+	struct vm_area_struct *vma,
+#endif
+	struct video_device *dev, const char *start, unsigned long size)
+#endif /* 2.6.x */
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+	struct video_device *dev = video_devdata(file);
+	const void *start = (void *)vma->vm_start;
+	unsigned long size  = vma->vm_end - vma->vm_start;
+#endif
+	struct quickcam *qc = (struct quickcam *)dev->priv;
+	unsigned char *frame;
+	int ret = 0,  frame_size;
+#if !HAVE_VMA && LINUX_VERSION_CODE<KERNEL_VERSION(2,6,0)
+	struct vm_area_struct *vma = NULL;
+#endif
+	if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGUSER) PDEBUG("qc_v4l_mmap(dev=%p,size=%li,qc=%p)",dev,size,qc);
+	if (qcdebug&QC_DEBUGMUTEX) PDEBUG("down_intr(%p) in qc_v4l_mmap() : %i", qc, sem_getcount(&qc->lock));
+	if (down_interruptible(&qc->lock)) return -ERESTARTSYS;
+	if (!qc->connected) { ret = -ENODEV; goto fail; }
+	frame_size = qc_capt_frameaddr(qc, &frame);
+	if (frame_size<0) { ret = frame_size; goto fail; }		/* Should never happen */
+	ret = qc_mm_remap(vma, frame, frame_size, start, size);
+
+fail:	if (qcdebug&QC_DEBUGMUTEX) PDEBUG("up(%p) in qc_v4l_mmap() : %i", qc, sem_getcount(&qc->lock));
+	up(&qc->lock);
+	if (ret<0) if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGERRORS) PDEBUG("failed qc_v4l_mmap()=%i",ret);
+	return ret;
+}
+/* }}} */
+/* {{{ [fold] qc_v4l_ioctl(struct video_device *dev, unsigned int cmd, void *arg) */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+static int qc_v4l_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+#else
+static int qc_v4l_ioctl(struct video_device *dev, unsigned int cmd, void *argp)
+#endif
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+	struct video_device *dev = video_devdata(file);
+	void *argp = (void *)arg;
+#endif
+	struct quickcam *qc = (struct quickcam *)dev->priv;
+	int i, retval = 0;
+
+	if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGUSER) PDEBUG("qc_v4l_ioctl(dev=%p,cmd=%u,arg=%p,qc=%p)",dev,cmd,argp,qc);
+	if (qcdebug&QC_DEBUGMUTEX) PDEBUG("down_intr(%p) in qc_v4l_ioctl() : %i", qc, sem_getcount(&qc->lock));
+	if (down_interruptible(&qc->lock)) return -ERESTARTSYS;
+	if (!qc->connected) {
+		retval = -ENODEV;
+		goto fail;
+	}
+	switch (cmd) {
+/* {{{ [fold] VIDIOCGCAP:     Capability query */
+		case VIDIOCGCAP:	/* Capability query */
+		{
+			struct video_capability b;
+			if (qcdebug&QC_DEBUGUSER) PDEBUG("VIDIOCGCAP");
+			memset(&b, 0, sizeof(b));
+			strcpy(b.name, "Logitech QuickCam USB");	/* Max 31 characters */
+			b.type      = qc->vdev.type;
+			b.channels  = 1;
+			b.audios    = 0;
+			b.maxwidth  = qc->sensor_data.maxwidth;
+			b.maxheight = qc->sensor_data.maxheight;
+			if (qc->settings.compat_16x) {
+				b.maxwidth  = (b.maxwidth /16)*16;
+				b.maxheight = (b.maxheight/16)*16;
+			}
+			b.minwidth  = min_framewidth;
+			b.minheight = min_frameheight;
+			if (copy_to_user(argp, &b, sizeof(b))) retval = -EFAULT;
+			break;
+		}
+/* }}} */
+/* {{{ [fold] VIDIOCGCHAN:    Get properties of the specified channel */
+		case VIDIOCGCHAN:	/* Get properties of the specified channel */
+		{
+			struct video_channel v;
+			if (copy_from_user(&v, argp, sizeof(v))) {
+				retval = -EFAULT;
+				break;
+			}
+			if (qcdebug&QC_DEBUGUSER) PDEBUG("VIDIOCGCHAN channel:%i",v.channel);
+			if (v.channel != 0) {
+				retval = -EINVAL;
+				break;
+			}
+			v.flags = 0;
+			v.tuners = 0;
+			v.type = VIDEO_TYPE_CAMERA;
+			strcpy(v.name, "Camera");
+			if (copy_to_user(argp, &v, sizeof(v))) retval = -EFAULT;
+			break;
+		}
+/* }}} */
+/* {{{ [fold] VIDIOCSCHAN:    Select channel to capture */
+		case VIDIOCSCHAN:	/* Select channel to capture */
+		{
+			if (copy_from_user(&i, argp, sizeof(i))) {
+				retval = -EFAULT;
+				break;
+			}
+			if (qcdebug&QC_DEBUGUSER) PDEBUG("VIDIOCSCHAN channel:%i",i);
+			if (i != 0) retval = -EINVAL;
+			break;
+		}
+/* }}} */
+/* {{{ [fold] VIDIOCGPICT:    Get image properties (brightness, palette, etc.) */
+		case VIDIOCGPICT:	/* Get image properties */
+		{
+			if (qcdebug&QC_DEBUGUSER) PDEBUG("VIDIOCGPICT");
+			if (copy_to_user(argp, &qc->vpic, sizeof(qc->vpic))) retval = -EFAULT;
+			break;
+		}
+/* }}} */
+/* {{{ [fold] VIDIOCSPICT:    Set image properties */
+		case VIDIOCSPICT:	/* Set image properties */
+		{
+			struct video_picture p;
+			if (copy_from_user(&p, argp, sizeof(p))) {
+				retval = -EFAULT;
+				break;
+			}
+			if (qcdebug&QC_DEBUGUSER) PDEBUG("VIDIOCSPICT depth:%d palette:%s(%i) bright=%i",p.depth,qc_fmt_getname(p.palette),p.palette,p.brightness);
+
+			if (p.palette != 0) {		/* 0 = do not change palette */
+				retval = qc_fmt_issupported(p.palette);
+				if (retval<0) break;
+				qc->vpic.palette = p.palette;
+				qc->vpic.depth   = qc_fmt_getdepth(p.palette);
+				if (qc->vpic.depth != p.depth) PDEBUG("warning: palette depth mismatch");
+			}
+			qc->vpic.brightness = p.brightness;
+			qc->vpic.hue        = p.hue;
+			qc->vpic.colour     = p.colour;
+			qc->vpic.contrast   = p.contrast;
+			qc->vpic.whiteness  = p.whiteness;		/* Used for sharpness */
+			qc->vpic_pending    = TRUE;
+			break;
+		}
+/* }}} */
+/* {{{ [fold] VIDIOCSWIN:     Set capture area width and height */
+		case VIDIOCSWIN:	/* Set capture area width and height */
+		{
+			struct video_window vw;
+			int fps;
+			if (copy_from_user(&vw, argp, sizeof(vw))) {
+				retval = -EFAULT;
+				break;
+			}
+			fps = (vw.flags>>16) & 0x3F;		/* 6 bits for framerate */
+			if (fps && ((qc->vwin.flags>>16)&0x3F)!=fps) {
+				PDEBUG("Application tries to change framerate");
+			}
+			if (qcdebug&QC_DEBUGUSER) PDEBUG("VIDIOCSWIN width:%i height:%i flags:%d clipcount:%d",vw.width,vw.height,vw.flags,vw.clipcount);
+			retval = qc_sensor_setsize(qc, vw.width, vw.height);
+			break;
+		}
+/* }}} */
+/* {{{ [fold] VIDIOCGWIN:     Get current capture area */
+		case VIDIOCGWIN:	/* Get current capture area */
+		{
+			if (qcdebug&QC_DEBUGUSER) PDEBUG("VIDIOCGWIN");
+			if (copy_to_user(argp, &qc->vwin, sizeof(qc->vwin))) retval = -EFAULT;
+			break;
+		}
+/* }}} */
+/* {{{ [fold] VIDIOCGMBUF:    Get mmap buffer size and frame offsets */
+		case VIDIOCGMBUF:	/* Get mmap buffer size and frame offsets */
+		{
+			struct video_mbuf vm;
+			if (qcdebug&QC_DEBUGUSER) PDEBUG("VIDIOCGMBUF");
+			memset(&vm, 0, sizeof(vm));
+			vm.size = qc_capt_frameaddr(qc, NULL);
+			if (vm.size<0) {	/* Negative value denotes error */
+				retval = vm.size;
+				break;
+			}
+			vm.frames = 1;
+			vm.offsets[0] = 0;
+			if (qc->settings.compat_dblbuf) {
+				/* Really many applications are broken and don't work with a single buffer */
+				vm.frames = 2;
+				vm.offsets[1] = 0;
+			}
+			if (copy_to_user(argp, &vm, sizeof(vm))) retval = -EFAULT;
+			break;
+		}
+/* }}} */
+/* {{{ [fold] VIDIOCMCAPTURE: Start capturing specified frame in the mmap buffer with specified size */
+		case VIDIOCMCAPTURE:	/* Start capturing specified frame in the mmap buffer with specified size */
+		{
+			struct video_mmap vm;
+			if (copy_from_user(&vm, argp, sizeof(vm))) {
+				retval = -EFAULT;
+				break;
+			}
+			/* Bug in V4L: sometimes it's called palette, sometimes format. We'll stick with palette */
+			if (qcdebug&QC_DEBUGUSER) PDEBUG("VIDIOCMCAPTURE frame:%d size:%dx%d palette:%s", vm.frame, vm.width, vm.height, qc_fmt_getname(vm.format));
+			if (vm.frame!=0 && !(qc->settings.compat_dblbuf)) {
+				PRINTK(KERN_NOTICE,"Bug detected in user program, use qcset compat=dblbuf");
+				retval = -EINVAL;
+				break;
+			}
+			if (vm.format!=0 && qc->vpic.palette!=vm.format) {	/* 0 = do not change palette */
+				retval = qc_fmt_issupported(vm.format);
+				if (retval) {
+					if (qcdebug&QC_DEBUGERRORS) PDEBUG("unsupported image format");
+					break;
+				}
+				qc->vpic.palette = vm.format;
+				qc->vpic.depth   = qc_fmt_getdepth(vm.format);
+			}
+			retval = qc_sensor_setsize(qc, vm.width, vm.height);
+			break;
+		}
+/* }}} */
+/* {{{ [fold] VIDIOCSYNC:     Wait until specified frame in the mmap buffer has been captured */
+		case VIDIOCSYNC:	/* Wait until specified frame in the mmap buffer has been captured */
+		{
+			if (qcdebug&QC_DEBUGUSER) PDEBUG("VIDIOCSYNC");
+			retval = qc_capt_get(qc, NULL);
+			if (retval>0) retval = 0;
+			break;
+		}
+/* }}} */
+/* {{{ [fold] VIDIOCGFBUF:    Get currently used frame buffer parameters */
+		case VIDIOCGFBUF:	/* Get currently used frame buffer parameters */
+		{
+			struct video_buffer vb;
+			if (qcdebug&QC_DEBUGUSER) PDEBUG("VIDIOCGFBUF");
+			memset(&vb, 0, sizeof(vb));
+			if (copy_to_user(argp, &vb, sizeof(vb))) retval = -EFAULT;
+			break;
+		}
+/* }}} */
+/* {{{ [fold] VIDIOCKEY:      Undocumented? */
+		case VIDIOCKEY:		/* Undocumented? */
+			if (qcdebug&QC_DEBUGUSER) PDEBUG("VIDIOCKEY");
+			retval = -EINVAL;
+			break;
+/* }}} */
+/* {{{ [fold] VIDIOCCAPTURE:  Activate overlay capturing directly to framebuffer */
+		case VIDIOCCAPTURE:	/* Activate overlay capturing directly to framebuffer */
+			if (qcdebug&QC_DEBUGUSER) PDEBUG("VIDIOCCAPTURE");
+			retval = -EINVAL;
+			break;
+/* }}} */
+/* {{{ [fold] VIDIOCSFBUF:    Set frame buffer parameters for the capture card */
+		case VIDIOCSFBUF:	/* Set frame buffer parameters for the capture card */
+			if (qcdebug&QC_DEBUGUSER) PDEBUG("VIDIOCSFBUF");
+			retval = -EINVAL;
+			break;
+/* }}} */
+/* {{{ [fold] VIDIOCxTUNER:   Get properties of the specified tuner / Select tuner to use */
+		case VIDIOCGTUNER:	/* Get properties of the specified tuner */
+		case VIDIOCSTUNER:	/* Select tuner to use */
+			if (qcdebug&QC_DEBUGUSER) PDEBUG("VIDIOCxTUNER");
+			retval = -EINVAL;
+			break;
+/* }}} */
+/* {{{ [fold] VIDIOCxFREQ:    Get current tuner frequency / Set tuner frequency */
+		case VIDIOCGFREQ:	/* Get current tuner frequency */
+		case VIDIOCSFREQ:	/* Set tuner frequency */
+			if (qcdebug&QC_DEBUGUSER) PDEBUG("VIDIOCxFREQ");
+			retval = -EINVAL;
+			break;
+/* }}} */
+/* {{{ [fold] VIDIOCxAUDIO:   Get/Set audio properties */
+		case VIDIOCGAUDIO:	/* Get audio properties */
+		case VIDIOCSAUDIO:	/* Set audio properties */
+			if (qcdebug&QC_DEBUGUSER) PDEBUG("VIDIOCxAUDIO");
+			retval = -EINVAL;
+			break;
+/* }}} */
+		/********** Private IOCTLs ***********/
+/* {{{ [fold] VIDIOCQCxDEBUG:        Sets/gets the qcdebug output (1,2,4,8,16,32) */
+		case VIDIOCQCSDEBUG:		/* Sets the qcdebug output (1,2,4,8,16,32) */
+			if (get_user(qcdebug, (int *)argp)) { retval=-EFAULT; break; }
+		case VIDIOCQCGDEBUG:		/* Gets the qcdebug output (1,2,4,8,16,32) */
+			if (put_user(qcdebug, (int *)argp)) { retval=-EFAULT; break; }
+			if (qcdebug&QC_DEBUGUSER) PDEBUG("VIDIOCxDEBUG");
+			break;
+/* }}} */
+/* {{{ [fold] VIDIOCQCxKEEPSETTINGS: Set/get keep gain settings across one open to another (0-1) */
+		case VIDIOCQCSKEEPSETTINGS:	/* Set keep gain settings across one open to another (0-1) */
+			if (get_user(i, (int *)argp)) { retval=-EFAULT; break; }
+			qc->settings.keepsettings = i;
+		case VIDIOCQCGKEEPSETTINGS:	/* Get keep gain settings across one open to another (0-1) */
+			i = qc->settings.keepsettings;
+			if (put_user(i, (int *)argp)) { retval=-EFAULT; break; }
+			if (qcdebug&QC_DEBUGUSER) PDEBUG("VIDIOCxKEEPSETTINGS");
+			break;
+/* }}} */
+/* {{{ [fold] VIDIOCQCxSETTLE:       Set/get if we let image brightness to settle (0-1) */
+		case VIDIOCQCSSETTLE:		/* Set if we let image brightness to settle (0-1) */
+			if (get_user(i, (int *)argp)) { retval=-EFAULT; break; }
+			qc->settings.settle = i;
+		case VIDIOCQCGSETTLE:		/* Get if we let image brightness to settle (0-1) */
+			i = qc->settings.settle;
+			if (put_user(i, (int *)argp)) { retval=-EFAULT; break; }
+			if (qcdebug&QC_DEBUGUSER) PDEBUG("VIDIOCxSETTLE");
+			break;
+/* }}} */
+/* {{{ [fold] VIDIOCQCxSUBSAMPLE:    Sets/gets the speed (0-1) */
+		case VIDIOCQCSSUBSAMPLE:	/* Sets the speed (0-1) */
+			if (get_user(i, (int *)argp)) { retval=-EFAULT; break; }
+			qc->settings.subsample = i;
+		case VIDIOCQCGSUBSAMPLE:	/* Gets the speed (0-1) */
+			i = qc->settings.subsample;
+			if (put_user(i, (int *)argp)) { retval=-EFAULT; break; }
+			if (qcdebug&QC_DEBUGUSER) PDEBUG("VIDIOCxSUBSAMPLE");
+			break;
+/* }}} */
+/* {{{ [fold] VIDIOCQCxCOMPRESS:     Sets/gets the compression mode (0-1) */
+		case VIDIOCQCSCOMPRESS:		/* Sets the compression mode (0-1) */
+			if (get_user(i, (int *)argp)) { retval=-EFAULT; break; }
+			qc->settings.compress = i;
+		case VIDIOCQCGCOMPRESS:		/* Gets the compression mode (0-1) */
+			i = qc->settings.compress;
+			if (put_user(i, (int *)argp)) { retval=-EFAULT; break; }
+			if (qcdebug&QC_DEBUGUSER) PDEBUG("VIDIOCxCOMPRESS");
+			break;
+/* }}} */
+/* {{{ [fold] VIDIOCQCxFRAMESKIP:    Set/get frame capture frequency (0-10) */
+		case VIDIOCQCSFRAMESKIP:	/* Set frame capture frequency (0-10) */
+			if (get_user(i, (int *)argp)) { retval=-EFAULT; break; }
+			qc->settings.frameskip = i;
+		case VIDIOCQCGFRAMESKIP:	/* Get frame capture frequency (0-10) */
+			i = qc->settings.frameskip;
+			if (put_user(i, (int *)argp)) { retval=-EFAULT; break; }
+			if (qcdebug&QC_DEBUGUSER) PDEBUG("VIDIOCxFRAMESKIP");
+			break;
+/* }}} */
+/* {{{ [fold] VIDIOCQCxQUALITY:      Sets/gets the interpolation mode (0-2) */
+		case VIDIOCQCSQUALITY:		/* Sets the interpolation mode (0-5) */
+			if (get_user(i, (int *)argp)) { retval=-EFAULT; break; }
+			qc->settings.quality = i;
+		case VIDIOCQCGQUALITY:		/* Gets the interpolation mode (0-5) */
+			i = qc->settings.quality;
+			if (put_user(i, (int *)argp)) { retval=-EFAULT; break; }
+			if (qcdebug&QC_DEBUGUSER) PDEBUG("VIDIOCxQUALITY");
+			break;
+/* }}} */
+/* {{{ [fold] VIDIOCQCxADAPTIVE:     Set/get automatic adaptive brightness control (0-1) */
+		case VIDIOCQCSADAPTIVE:		/* Set automatic adaptive brightness control (0-1) */
+			if (get_user(i, (int *)argp)) { retval=-EFAULT; break; }
+			qc->settings.adaptive = i;
+		case VIDIOCQCGADAPTIVE:		/* Get automatic adaptive brightness control (0-1) */
+			i = qc->settings.adaptive;
+			if (put_user(i, (int *)argp)) { retval=-EFAULT; break; }
+			if (qcdebug&QC_DEBUGUSER) PDEBUG("VIDIOCxADAPTIVE");
+			break;
+/* }}} */
+/* {{{ [fold] VIDIOCQCxEQUALIZE:     Set/get equalize image (0-1) */
+		case VIDIOCQCSEQUALIZE:		/* Set equalize image (0-1) */
+			if (get_user(i, (int *)argp)) { retval=-EFAULT; break; }
+			qc->settings.equalize = i;
+		case VIDIOCQCGEQUALIZE:		/* Get equalize image (0-1) */
+			i = qc->settings.equalize;
+			if (put_user(i, (int *)argp)) { retval=-EFAULT; break; }
+			if (qcdebug&QC_DEBUGUSER) PDEBUG("VIDIOCxEQUALIZE");
+			break;
+/* }}} */
+/* {{{ [fold] VIDIOCQCxUSERLUT:      Set/get user-specified lookup-table */
+		case VIDIOCQCSUSERLUT:			/* Set user-specified lookup-table [struct qc_userlut] */
+		{
+			unsigned int flags;
+			retval = -EFAULT;
+			if (get_user(flags, &(((struct qc_userlut*)argp)->flags))) break;
+			if (flags & QC_USERLUT_DEFAULT) {
+				userlut = ((flags & QC_USERLUT_ENABLE) != 0);
+			} else {
+				qc->settings.userlut = ((flags & QC_USERLUT_ENABLE) != 0);
+			}
+			if (flags & QC_USERLUT_VALUES) {
+				for (i=0; i<QC_LUT_SIZE; i++) {
+					unsigned char p;
+					if (get_user(p, &(((struct qc_userlut*)argp)->lut[i]))) break;
+					if (flags & QC_USERLUT_DEFAULT) {
+						userlut_contents[i] = p;
+					} else {
+						qc->fmt_data.userlut[i] = p;
+					}
+				}
+				if (i < QC_LUT_SIZE) break;
+			}
+			retval = 0;
+			if (qcdebug&QC_DEBUGUSER) PDEBUG("VIDIOCSUSERLUT");
+			break;
+		}
+		case VIDIOCQCGUSERLUT:			/* Get user-specified lookup-table [struct qc_userlut] */
+		{
+			unsigned int flags;
+			retval = -EFAULT;
+			if (get_user(flags, &(((struct qc_userlut*)argp)->flags))) break;
+			flags &= (~QC_USERLUT_ENABLE);
+			if ((flags & QC_USERLUT_DEFAULT) ? userlut : qc->settings.userlut) flags |= QC_USERLUT_ENABLE;
+			if (put_user(flags,  &(((struct qc_userlut*)argp)->flags))) break;
+			if (flags & QC_USERLUT_VALUES) {
+				for (i=0; i<QC_LUT_SIZE; i++) {
+					unsigned char p;
+					if (flags & QC_USERLUT_DEFAULT) {
+						p = userlut_contents[i];
+					} else {
+						p = qc->fmt_data.userlut[i];
+					}
+					if (put_user(p, &(((struct qc_userlut*)argp)->lut[i]))) break;
+				}
+				if (i < QC_LUT_SIZE) break;
+			}
+			retval = 0;
+			if (qcdebug&QC_DEBUGUSER) PDEBUG("VIDIOCGUSERLUT");
+			break;
+		}
+/* }}} */
+/* {{{ [fold] VIDIOCQCxRETRYERRORS:  Set/get if we retry when error happen in capture (0-1) */
+		case VIDIOCQCSRETRYERRORS:	/* Set if we retry when error happen in capture (0-1) */
+			if (get_user(i, (int *)argp)) { retval=-EFAULT; break; }
+			qc->settings.retryerrors = i;
+		case VIDIOCQCGRETRYERRORS:	/* Get if we retry when error happen in capture (0-1) */
+			i = qc->settings.retryerrors;
+			if (put_user(i, (int *)argp)) { retval=-EFAULT; break; }
+			if (qcdebug&QC_DEBUGUSER) PDEBUG("VIDIOCxRETRYERRORS");
+			break;
+/* }}} */
+/* {{{ [fold] VIDIOCQCxCOMPATIBLE:   Set enable workaround for Xawtv/Motv bugs (0-1) */
+		case VIDIOCQCSCOMPATIBLE:	/* Set enable workaround for Xawtv/Motv bugs (0-1) */
+			if (get_user(i, (int *)argp)) { retval=-EFAULT; break; }
+			qc->settings.compat_16x    = (i & QC_COMPAT_16X)    != 0;
+			qc->settings.compat_dblbuf = (i & QC_COMPAT_DBLBUF) != 0;
+			qc->settings.compat_torgb  = (i & QC_COMPAT_TORGB)  != 0;
+		case VIDIOCQCGCOMPATIBLE:	/* Get enable workaround for Xawtv/Motv bugs (0-1) */
+			i  = ~(qc->settings.compat_16x   -1) & QC_COMPAT_16X;
+			i |= ~(qc->settings.compat_dblbuf-1) & QC_COMPAT_DBLBUF;
+			i |= ~(qc->settings.compat_torgb -1) & QC_COMPAT_TORGB;
+			if (put_user(i, (int *)argp)) { retval=-EFAULT; break; }
+			if (qcdebug&QC_DEBUGUSER) PDEBUG("VIDIOCxCOMPATIBLE");
+			break;
+/* }}} */
+/* {{{ [fold] VIDIOCQCxVIDEONR:      Set videodevice number (/dev/videoX) */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,5)
+		case VIDIOCQCSVIDEONR:		/* Set videodevice number (/dev/videoX) */
+			if (qcdebug&QC_DEBUGUSER) PDEBUG("VIDIOCSVIDEONR");
+			retval = -EINVAL;	/* Can not set after the module is loaded */
+			break;
+		case VIDIOCQCGVIDEONR:		/* Get videodevice number (/dev/videoX) */
+			if (qcdebug&QC_DEBUGUSER) PDEBUG("VIDIOCGVIDEONR");
+			if (put_user(video_nr, (int *)argp)) { retval=-EFAULT; break; }
+			break;
+#endif
+/* }}} */
+/* {{{ [fold] VIDIOCQCxSTV:          Read/write STV chip register value */
+		/* Encoding: bits 31..16 of the int argument contain register value, 15..0 the reg number */
+		case VIDIOCQCGSTV:		/* Read STV chip register value */
+		{
+			int reg, val;
+			if (qcdebug&QC_DEBUGUSER) PDEBUG("VIDIOCQCGSTV");
+			if (get_user(reg, (int *)argp)) { retval=-EFAULT; break; }
+			reg &= 0xFFFF;
+			val = qc_stv_get(qc, reg);
+			if (val<0) { retval=val; break; }
+			val = (val<<16) | reg;
+			if (put_user(val, (int *)argp)) { retval=-EFAULT; break; }
+			break;
+		}
+		case VIDIOCQCSSTV:		/* Write STV chip register value */
+		{
+			int regval;
+			if (qcdebug&QC_DEBUGUSER) PDEBUG("VIDIOCQCSSTV");
+			if (!capable(CAP_SYS_RAWIO)) { retval=-EPERM; break; }
+			if (get_user(regval, (int *)argp)) { retval=-EFAULT; break; }
+			retval = qc_stv_set(qc, regval & 0xFFFF, regval >> 16);
+			break;
+		}
+/* }}} */
+/* {{{ [fold] VIDIOCQCxI2C:          Read/write sensor chip register value via I2C */
+		case VIDIOCQCGI2C:		/* Read sensor chip register value via I2C */
+		{
+			int reg, val;
+			if (qcdebug&QC_DEBUGUSER) PDEBUG("VIDIOCQCGI2C");
+			if (get_user(reg, (int *)argp)) { retval=-EFAULT; break; }
+			reg &= 0xFFFF;
+			val = qc_get_i2c(qc, qc->sensor_data.sensor, reg);
+			if (val<0) { retval=val; break; }
+			val = (val<<16) | reg;
+			if (put_user(val, (int *)argp)) { retval=-EFAULT; break; }
+			break;
+		}
+		case VIDIOCQCSI2C:		/* Write sensor chip register value via I2C */
+		{
+			int regval;
+			if (qcdebug&QC_DEBUGUSER) PDEBUG("VIDIOCQCSI2C");
+			if (!capable(CAP_SYS_RAWIO)) { retval=-EPERM; break; }
+			if (get_user(regval, (int *)argp)) { retval=-EFAULT; break; }
+			retval = qc_i2c_set(qc, regval & 0xFFFF, regval >> 16);
+			if (retval<0) break;
+			retval = qc_i2c_wait(qc);
+			break;
+		}
+/* }}} */
+		default:
+			if (qcdebug&QC_DEBUGUSER) PDEBUG("Unknown IOCTL %08X",cmd);
+			retval = -ENOIOCTLCMD;
+			break;
+	}
+fail:	if (qcdebug&QC_DEBUGMUTEX) PDEBUG("up(%p) in qc_v4l_ioctl() : %i", qc, sem_getcount(&qc->lock));
+	up(&qc->lock);
+	if (retval<0) if (qcdebug&(QC_DEBUGLOGIC|QC_DEBUGUSER|QC_DEBUGERRORS)) PDEBUG("failed qc_v4l_ioctl()=%i",retval);
+	return retval;
+}
+/* }}} */
+/* {{{ [fold] qc_v4l_write(struct video_device *dev, const char *buf, unsigned long count, int noblock) */
+#if LINUX_VERSION_CODE<KERNEL_VERSION(2,6,0)
+static long qc_v4l_write(struct video_device *dev, const char *buf, unsigned long count, int noblock)
+{
+	if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGUSER) PDEBUG("qc_v4l_write()");
+	return -EINVAL;
+}
+#endif
+/* }}} */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+static void qc_v4l_release(struct video_device *vfd) { }
+static struct file_operations qc_v4l_fops = {
+	owner:		THIS_MODULE,
+	open:		qc_v4l_open,
+	release:	qc_v4l_close,
+	read:		qc_v4l_read,
+//	write:		qc_v4l_write,
+	ioctl:		qc_v4l_ioctl,
+	mmap:		qc_v4l_mmap,
+	poll:		qc_v4l_poll,
+};
+#endif
+
+static struct video_device qc_v4l_template = {
+	name:		"QuickCam USB",
+	type:		VID_TYPE_CAPTURE | VID_TYPE_SUBCAPTURE,
+	hardware:	VID_HARDWARE_QCAM_USB,
+	minor:		-1,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+	release:	qc_v4l_release,
+	fops:		&qc_v4l_fops,
+#else
+	initialize:	NULL,
+	open:		qc_v4l_open,
+	close:		qc_v4l_close,
+	read:		qc_v4l_read,
+	write:		qc_v4l_write,
+	ioctl:		qc_v4l_ioctl,
+	mmap:		qc_v4l_mmap,
+	poll:		qc_v4l_poll,
+#endif
+};
+/* }}} */
+/* {{{ [fold] **** qc_usb:    Start of USB API ********************************** */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+static int qc_usb_probe(struct usb_interface *intf, const struct usb_device_id *id);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+static void *qc_usb_probe(struct usb_device *dev, unsigned int iface, const struct usb_device_id *id);
+#else
+static void *qc_usb_probe(struct usb_device *dev, unsigned int iface);
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+static void qc_usb_disconnect(struct usb_interface *intf);
+#else
+static void qc_usb_disconnect(struct usb_device *dev, void *ptr);
+#endif
+
+static struct usb_driver qc_usb_driver = {
+	name:		qc_name,
+	probe:		qc_usb_probe,
+	disconnect:	qc_usb_disconnect,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+	owner:		THIS_MODULE,
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+	id_table:	qc_device_table,
+#endif
+};
+
+/* {{{ [fold] qc_usb_init(struct usb_device *dev, unsigned int ifacenum) */
+/* Detect sensor, initialize the quickcam structure, register V4L device, create /proc entry.
+ * Return pointer to the allocated quickcam structure or NULL on error.
+ * If there is some camera already open but disconnected, reuse the quickcam structure. */
+static struct quickcam *qc_usb_init(struct usb_device *usbdev, unsigned int ifacenum)
+{
+	struct quickcam *qc;
+	Bool reuse_qc;
+	int i, r = 0;
+
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_usb_init(usbdev=%p)", usbdev);
+	if (PARANOID && usbdev==NULL) { PRINTK(KERN_CRIT,"usbdev==NULL"); return NULL; }
+
+	/* Check if there is already a suitable quickcam struct that can be reused */
+	reuse_qc = FALSE;
+	if (qcdebug&QC_DEBUGMUTEX) PDEBUG("down_intr(quickcam_list_lock) in qc_usb_init() : %i", sem_getcount(&quickcam_list_lock));
+	if (down_interruptible(&quickcam_list_lock)) return NULL;
+	list_for_each_entry(qc, &quickcam_list, list) {
+		if (qc->dev!=NULL) continue;			/* quickcam_list_lock protects this test */
+		if (qcdebug&QC_DEBUGMUTEX) PDEBUG("down_intr(%p) in qc_usb_init() : %i",qc, sem_getcount(&qc->lock));
+		if (down_interruptible(&qc->lock)) {
+			/* Failed to lock the camera. Move on in the list, skipping this camera */
+			if (qcdebug&QC_DEBUGMUTEX) PDEBUG("failed locking the camera %p in qc_usb_init() : %i",qc,sem_getcount(&qc->lock));
+			continue;
+		}
+		if (qc->users<=0) {
+			PRINTK(KERN_NOTICE, "Unplugged unused camera detected!");
+			if (qcdebug&QC_DEBUGMUTEX) PDEBUG("up(%p) in qc_usb_init() : %i",qc, sem_getcount(&qc->lock));
+			up(&qc->lock);
+			continue;
+		}
+		/* Found and locked unplugged but used camera */
+		reuse_qc = TRUE;
+		break;
+	}
+
+	if (reuse_qc) {
+		/* Reuse existing quickcam (which is already opened) */
+		if (qcdebug&QC_DEBUGLOGIC) PDEBUG("Reusing existing quickcam");
+		if (PARANOID && qc->users<=0) PRINTK(KERN_CRIT, "Unplugged JUST closed camera detected!");
+		qc_isoc_stop(qc);
+		qc_i2c_wait(qc);
+		qc_frame_flush(qc);
+	} else {
+		/* Allocate and initialize some members of the new qc */
+		if (qcdebug&QC_DEBUGLOGIC) PDEBUG("Allocating new quickcam");
+		qc = kmalloc(sizeof(*qc), GFP_KERNEL);
+		CHECK_ERROR(qc==NULL, fail1, "couldn't kmalloc quickcam struct");
+		memset(qc, 0, sizeof(*qc));		/* No garbage to user */
+PDEBUG("poisoning qc in qc_usb_init");
+		POISON(*qc);
+		if (qcdebug&QC_DEBUGMUTEX) PDEBUG("init down(%p) in qc_usb_init()", qc);
+		init_MUTEX_LOCKED(&qc->lock);
+		qc->users = 0;
+		if ((r=qc_i2c_init(qc))<0) goto fail2;
+	}
+	qc->dev       = usbdev;
+	qc->iface     = ifacenum;
+	qc->connected = TRUE;
+
+	/* Probe for the sensor type */
+	qc_i2c_wait(qc);						/* Necessary before set_interface() */
+	if ((r=usb_set_interface(usbdev, qc->iface, 0))<0) goto fail3;	/* Set altsetting 0 */
+	if ((r=qc_stv_set(qc, STV_ISO_ENABLE, 0))<0) goto fail3;	/* Disable isochronous stream */
+	for (i=0; i<SIZE(sensors); i++) {
+		if ((r = qc_get_i2c(qc, sensors[i], sensors[i]->id_reg))<0) goto fail3;
+		r = (r >> (sensors[i]->length_id-1) * 8) & 0xFF;	/* Get MSB of received value */
+		if (qcdebug&QC_DEBUGCAMERA) PDEBUG("Probing %s: expecting %02X, got %02X", sensors[i]->name, sensors[i]->id, r);
+		if (r == sensors[i]->id) break;
+	}
+	if (i>=SIZE(sensors)) {
+		PRINTK(KERN_INFO,"unsupported sensor");
+		goto fail3;
+	}
+	qc->sensor_data.sensor = sensors[i];
+	PRINTK(KERN_INFO,"Sensor %s detected", sensors[i]->name);
+
+	if ((r=qc_stv_set(qc, STV_ISO_ENABLE, 0))<0) goto fail3;	/* Disable isochronous streaming */
+	if ((r=qc_stv_set(qc, STV_REG23, 1))<0) goto fail3;
+
+	if (!reuse_qc) {
+		/* Set default settings */
+		qc->vpic.brightness = 32768;
+		qc->vpic.hue        = 32768;
+		qc->vpic.colour     = 32768;
+		qc->vpic.contrast   = 32768;
+		qc->vpic.whiteness  = 32768;				/* Used for sharpness at quality=5 */
+		qc->settings.keepsettings  = keepsettings;
+		qc->settings.settle        = settle;
+		qc->settings.subsample     = subsample;
+		qc->settings.compress      = compress;
+		qc->settings.frameskip     = frameskip;
+		qc->settings.quality       = quality;
+		qc->settings.adaptive      = adaptive;
+		qc->settings.equalize      = equalize;
+		qc->settings.userlut       = userlut;
+		qc->settings.retryerrors   = retryerrors;
+		qc->settings.compat_16x    = compatible & QC_COMPAT_16X    ? 1 : 0;
+		qc->settings.compat_dblbuf = compatible & QC_COMPAT_DBLBUF ? 1 : 0;
+		qc->settings.compat_torgb  = compatible & QC_COMPAT_TORGB  ? 1 : 0;
+		memcpy(&qc->fmt_data.userlut, userlut_contents, sizeof(qc->fmt_data.userlut));
+
+		/* Register V4L video device */
+		memcpy(&qc->vdev, &qc_v4l_template, sizeof(qc_v4l_template));
+		qc->vdev.priv = qc;
+		r = video_register_device(&qc->vdev, VFL_TYPE_GRABBER, video_nr);
+		if (r<0) goto fail3;
+		PRINTK(KERN_INFO, "Registered device: /dev/video%i", qc->vdev.minor);
+		if ((r=qc_adapt_init(qc))<0) goto fail4;
+		qc_proc_create(qc);				/* Create /proc entry, ignore if it fails */
+		list_add(&qc->list, &quickcam_list);
+	}
+
+	if (reuse_qc && qc->frame_data.waiting>0) {
+		/* Restart capturing */
+		int width = qc->vwin.width;
+		int height = qc->vwin.height;
+//qc_usleep(1000000);
+		qc_isoc_stop(qc);
+		r = qc_sensor_init(qc);
+		r = qc_isoc_start(qc);
+		r = qc_sensor_setsize(qc, width, height);
+		/* Ignore return codes for now, if it fails, too bad, but shouldn't crash */
+		/* FIXME: proper error handling */
+
+/*qc_usleep(1000000);
+ qc_sensor_setsize(qc, width, height);
+qc_usleep(1000000);
+ qc_sensor_setsize(qc, 32, 32);
+qc_usleep(1000000);
+ qc_sensor_setsize(qc, width, height);
+qc_usleep(1000000);*/
+
+#if 0
+/* The following tries to initialize VV6410 really hard. still doesn't work */
+{
+int r,c;
+for(c=0;c<10;c++) {
+//r = qc_sensor_init(qc);
+//PDEBUG("c=%i  init=%i",c,r);
+//r = qc_sensor_setsize(qc, width, height);
+//PDEBUG("size=%i",r);
+//r = usb_set_interface(qc->dev, qc->iface, 1);
+//PDEBUG("set_interf=%i",r);
+//r = qc->sensor_data.sensor->start(qc);	/* Start current frame */
+//PDEBUG("start=%i",r);
+//r = qc_stv_set(qc, STV_ISO_ENABLE, 1);
+//PDEBUG("stv_set=%i",r);
+//qc_isoc_stop(qc);
+//qc_usleep(1000000);
+//qc_isoc_start(qc);
+//qc_usleep(1000000);
+}}
+#endif
+	}
+	if (qcdebug&QC_DEBUGMUTEX) PDEBUG("up(%p) in qc_usb_init() : %i",qc, sem_getcount(&qc->lock));
+	up(&qc->lock);
+	if (qcdebug&QC_DEBUGMUTEX) PDEBUG("up(quickcam_list) in qc_usb_init() : %i", sem_getcount(&quickcam_list_lock));
+	up(&quickcam_list_lock);
+	return qc;
+
+fail4:	video_unregister_device(&qc->vdev);
+fail3:	if (!reuse_qc) qc_i2c_exit(qc);
+	qc->dev = NULL;
+	qc->connected = FALSE;
+	if (qcdebug&QC_DEBUGMUTEX) PDEBUG("up(%p) in qc_usb_init()=failed : %i",qc, sem_getcount(&qc->lock));
+	up(&qc->lock);
+fail2:	if (!reuse_qc) kfree(qc);
+fail1:	if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGERRORS) PDEBUG("failed qc_usb_init()=%i",r);
+	if (qcdebug&QC_DEBUGMUTEX) PDEBUG("up(quickcam_list) in qc_usb_init()=failed : %i", sem_getcount(&quickcam_list_lock));
+	up(&quickcam_list_lock);
+	return NULL;
+}
+/* }}} */
+/* FIXME: can usb_disconnect and usb_probe pre-empt other kernel mode processes? Assume no */
+/* {{{ [fold] qc_usb_probe(...) */
+/* Called when any USB device is connected, check if it is a supported camera */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+static int qc_usb_probe(struct usb_interface *interface, const struct usb_device_id *id)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+static void *qc_usb_probe(struct usb_device *usbdev, unsigned int ifacenum, const struct usb_device_id *id)
+#else /* 2.2.x */
+static void *qc_usb_probe(struct usb_device *usbdev, unsigned int ifacenum)
+#endif
+{
+	struct quickcam *qc;
+	struct usb_interface_descriptor *ifacedesc;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+	unsigned int ifacenum;
+	struct usb_device *usbdev = interface_to_usbdev(interface);
+	static const int ERROR_CODE = -ENODEV;
+#else
+	static void * const ERROR_CODE = NULL;
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
+	/* Check if the device has a product number that we support */
+	struct usb_device_id *i;
+	for (i=qc_device_table; i->idVendor; i++) {
+		if (usbdev->descriptor.idVendor == i->idVendor &&
+		    usbdev->descriptor.idProduct == i->idProduct) break;
+	}
+	if (!i->idVendor) return ERROR_CODE;
+#endif
+	if (PARANOID && usbdev==NULL) { PRINTK(KERN_CRIT,"usbdev==NULL"); return ERROR_CODE; }
+
+	/* We don't handle multi-config cameras */
+	if (usbdev->descriptor.bNumConfigurations != 1) return ERROR_CODE;
+
+	/*
+	 * Checking vendor/product is not enough
+	 * In case on QuickCam Web the audio is at class 1 and subclass 1/2.
+	 * one /dev/dsp and one /dev/mixer
+	 */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+	ifacedesc = &interface->altsetting[0].desc;
+	ifacenum  = ifacedesc->bInterfaceNumber;
+#else
+	ifacedesc = &usbdev->actconfig->interface[ifacenum].altsetting[0];
+#endif
+	if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGCAMERA) PDEBUG("qc_usb_probe(usbdev=%p,ifacenum=%i)", usbdev, ifacenum);
+	if (PARANOID && ifacedesc->bInterfaceNumber!=ifacenum) PRINTK(KERN_CRIT,"bInterfaceNumber(%i)!=ifacenum(%i)!!",ifacedesc->bInterfaceNumber,ifacenum);
+	if (ifacedesc->bInterfaceClass != 0xFF) return ERROR_CODE;
+	if (ifacedesc->bInterfaceSubClass != 0xFF) return ERROR_CODE;
+
+	/* We found a QuickCam */
+	PRINTK(KERN_INFO,"QuickCam USB camera found (driver version %s)", VERSION);
+	PRINTK(KERN_INFO,"Kernel:%s bus:%i class:%02X subclass:%02X vendor:%04X product:%04X",
+		UTS_RELEASE, usbdev->bus->busnum, ifacedesc->bInterfaceClass, ifacedesc->bInterfaceSubClass,
+		usbdev->descriptor.idVendor, usbdev->descriptor.idProduct);
+
+	/* The interface is claimed (bound) automatically to us when we return from this function (without error code) */
+	if (qcdebug&QC_DEBUGMUTEX) PDEBUG("MOD_INC_USE_COUNT in qc_usb_probe() : %i",GET_USE_COUNT(THIS_MODULE));
+	MOD_INC_USE_COUNT;	/* Increase count to 1, which locks the module--it can't be removed */
+	qc = qc_usb_init(usbdev, ifacenum);
+	if (qcdebug&QC_DEBUGMUTEX) PDEBUG("MOD_DEC_USE_COUNT in qc_usb_probe() : %i",GET_USE_COUNT(THIS_MODULE));
+	MOD_DEC_USE_COUNT;	/* Release lock: module can be now removed again */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+	if (!qc) return ERROR_CODE;
+	usb_set_intfdata(interface, qc);	/* FIXME: why? */
+	return 0;
+#else
+	return qc;
+#endif
+}
+/* }}} */
+/* {{{ [fold] qc_usb_exit(struct quickcam *qc) */
+/* Free up resources allocated in qc_usb_init() when not needed anymore
+ * Note: quickcam_list_lock and qc->lock must be acquired before entering this function!
+ * qc may not be accessed after this function returns! 
+ */
+static void qc_usb_exit(struct quickcam *qc)
+{
+	if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGINIT) PDEBUG("qc_usb_exit(qc=%p)",qc);
+	TEST_BUG_MSG(qc==NULL, "qc==NULL");
+
+	qc_proc_destroy(qc);
+	qc_adapt_exit(qc);
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("video_unregister_device(%p)", &qc->vdev);
+	video_unregister_device(&qc->vdev);
+	qc_i2c_exit(qc);
+	list_del(&qc->list);
+PDEBUG("poisoning qc in qc_usb_exit");
+	POISON(*qc);
+	kfree(qc);
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_usb_exit() done");
+}
+/* }}} */
+/* {{{ [fold] qc_usb_disconnect(...) */
+/* Called when the camera is disconnected. We might not free struct quickcam here,
+ * because the camera might be in use (open() called). In that case, the freeing is
+ * postponed to the last close() call. However, all submitted URBs must be unlinked.
+ */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+static void qc_usb_disconnect(struct usb_interface *interface)
+#else
+static void qc_usb_disconnect(struct usb_device *usbdev, void *ptr)
+#endif
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+	struct quickcam *qc = usb_get_intfdata(interface);
+#ifdef DEBUG
+	struct usb_device *usbdev = interface_to_usbdev(interface);
+#endif
+#else
+	struct quickcam *qc = (struct quickcam *)ptr;
+#endif
+
+	if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGCAMERA) PDEBUG("qc_usb_disconnect(qc=%p)",qc);
+	TEST_BUG_MSG(qc==NULL, "qc==NULL in qc_usb_disconnect!");
+	TEST_BUG_MSG(qc->dev==NULL || qc->connected==FALSE, "disconnecting disconnected device!!");
+	TEST_BUG_MSG(usbdev!=qc->dev, "disconnecting not our device!!");
+
+	if (qcdebug&QC_DEBUGMUTEX) PDEBUG("MOD_INC_USE_COUNT in qc_usb_disconnect() : %i",GET_USE_COUNT(THIS_MODULE));
+	MOD_INC_USE_COUNT;			/* Increase count to 1, which locks the module--it can't be removed */
+
+	/*
+	 * When the camera is unplugged (maybe even when it is capturing), quickcam->connected is set to FALSE.
+	 * All functions called from user mode and all _exit functions must check for this.
+	 */
+	qc->connected = FALSE;
+
+	if (qcdebug&QC_DEBUGMUTEX) PDEBUG("down(quickcam_list) in qc_usb_disconnect() : %i", sem_getcount(&quickcam_list_lock));
+	down(&quickcam_list_lock);		/* Also avoids race condition with open() */
+	if (qcdebug&QC_DEBUGMUTEX) PDEBUG("down(%p) in qc_usb_disconnect() : %i", qc, sem_getcount(&qc->lock));
+	down(&qc->lock);			/* Can not interrupt, we must success */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+	usb_set_intfdata(interface, NULL);	/* FIXME: why? */
+#endif
+	if (qc->users <= 0) {
+		/* Free resources */
+		qc_usb_exit(qc);
+	} else {
+		/* Can not free resources if device is open: postpone to when it is closed */
+		if (qcdebug&QC_DEBUGLOGIC) PDEBUG("Disconnect while device open: postponing cleanup");
+		qc_isoc_stop(qc);		/* Unlink and free isochronous URBs */
+		qc_i2c_wait(qc);		/* Wait until there are no more I2C packets on way */
+		qc->dev = NULL;			/* Must be set to NULL only after interrupts are guaranteed to be disabled! */
+		if (qcdebug&QC_DEBUGMUTEX) PDEBUG("up(%p) in qc_usb_disconnect() : %i",qc, sem_getcount(&qc->lock));
+		up(&qc->lock);
+	}
+	if (qcdebug&QC_DEBUGMUTEX) PDEBUG("up(quickcam_list) in qc_usb_disconnect() : %i", sem_getcount(&quickcam_list_lock));
+	up(&quickcam_list_lock);
+	if (qcdebug&QC_DEBUGMUTEX) PDEBUG("MOD_DEC_USE_COUNT in qc_usb_disconnect() : %i",GET_USE_COUNT(THIS_MODULE));
+	MOD_DEC_USE_COUNT;	/* Release lock--if device is not open, module can be now freed */
+	/* The interface is released automatically when we return from this function */
+}
+/* }}} */
+
+/* }}} */
+/* {{{ [fold] **** qc:        Start of module API ******************************* */
+
+/* {{{ [fold] qc_init(void) */
+static int __init qc_init(void)
+{
+	int r;
+	if (qcdebug) PDEBUG("----------LOADING QUICKCAM MODULE------------");
+	if (qcdebug) PDEBUG("struct quickcam size: %i", (int)sizeof(struct quickcam));
+	if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGINIT) PDEBUG("qc_init()");
+	qc_proc_init();				/* Ignore if procfs entry creation fails */
+	r = usb_register(&qc_usb_driver);
+	if (r<0) qc_proc_exit();
+	if (r<0) if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGERRORS) PDEBUG("failed qc_init()=%i",r);
+	return r;
+}
+/* }}} */
+/* {{{ [fold] qc_exit(void) */
+static void __exit qc_exit(void)
+{
+	if (qcdebug&QC_DEBUGLOGIC || qcdebug&QC_DEBUGINIT) PDEBUG("qc_exit()");
+	usb_deregister(&qc_usb_driver);		/* Will also call qc_usb_disconnect() if necessary */
+	qc_proc_exit();
+}
+/* }}} */
+
+module_init(qc_init);
+module_exit(qc_exit);
+/* }}} */
+
+/* End of file */
diff -purN linux-2.6.10.orig/drivers/usb/media/qc/qc-formats.c linux-2.6.10-qc-usb/drivers/usb/media/qc/qc-formats.c
--- linux-2.6.10.orig/drivers/usb/media/qc/qc-formats.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-qc-usb/drivers/usb/media/qc/qc-formats.c	2004-07-29 20:12:38.000000000 +0200
@@ -0,0 +1,1549 @@
+/* Start of file */
+
+/* {{{ [fold] Comments */
+/*
+ * qc-usb, linux V4L driver for the Logitech QuickCam family
+ *
+ * qc-formats.c - converts color formats
+ *
+ * Copyright (c) 2001 Jean-Frederic Clere (RGB->YUV conversion)
+ *               2001 Aaron Holtzman <aholtzma@ess.engr.uvic.ca> (YUV->RGB conversion, from mpeg2dec)
+ *               2003 Tuukka Toivonen (Bayer->RGB conversion)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+/* }}} */
+
+#ifdef NOKERNEL
+#include "quickcam.h"
+#else
+#include <linux/quickcam.h>
+#endif
+#include <asm/byteorder.h>
+
+#ifndef v4l2_fourcc
+/*  Four-character-code (FOURCC) */
+#define v4l2_fourcc(a,b,c,d)\
+        (((__u32)(a)<<0)|((__u32)(b)<<8)|((__u32)(c)<<16)|((__u32)(d)<<24))
+#endif
+
+/* {{{ [fold] **** qc_yuv:  Start of RGB to YUV conversion functions  ******************** */
+
+/* {{{ [fold] qc_yuv_interp[256][8] */
+static signed short qc_yuv_interp[256][8] = {
+{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,1,0,0,0,1,0,0},{0,1,0,0,0,1,-1,0},
+{1,2,0,0,-1,2,-1,0},{1,2,0,0,-1,2,-2,0},{1,3,0,-1,-1,3,-2,0},{2,3,0,-1,-2,3,-2,0},
+{2,4,0,-1,-2,4,-3,0},{2,5,1,-1,-2,4,-3,0},{2,5,1,-1,-3,5,-4,0},{3,6,1,-1,-3,5,-4,0},
+{3,6,1,-2,-3,6,-5,0},{3,7,1,-2,-4,6,-5,-1},{4,7,1,-2,-4,7,-5,-1},{4,8,1,-2,-4,7,-6,-1},
+{4,9,1,-2,-5,8,-6,-1},{5,9,1,-2,-5,8,-7,-1},{5,10,2,-3,-5,9,-7,-1},{5,10,2,-3,-6,9,-7,-1},
+{5,11,2,-3,-6,10,-8,-1},{6,11,2,-3,-6,10,-8,-1},{6,12,2,-3,-7,11,-9,-1},{6,13,2,-3,-7,11,-9,-1},
+{7,13,2,-4,-7,12,-10,-1},{7,14,2,-4,-8,12,-10,-2},{7,14,2,-4,-8,13,-10,-2},{8,15,3,-4,-8,13,-11,-2},
+{8,15,3,-4,-9,14,-11,-2},{8,16,3,-4,-9,14,-12,-2},{8,17,3,-5,-9,15,-12,-2},{9,17,3,-5,-10,15,-12,-2},
+{9,18,3,-5,-10,16,-13,-2},{9,18,3,-5,-10,16,-13,-2},{10,19,3,-5,-11,17,-14,-2},{10,19,3,-5,-11,17,-14,-2},
+{10,20,4,-6,-11,18,-15,-2},{11,20,4,-6,-12,18,-15,-3},{11,21,4,-6,-12,19,-15,-3},{11,22,4,-6,-12,19,-16,-3},
+{11,22,4,-6,-13,20,-16,-3},{12,23,4,-6,-13,20,-17,-3},{12,23,4,-7,-13,21,-17,-3},{12,24,4,-7,-14,21,-18,-3},
+{13,24,5,-7,-14,22,-18,-3},{13,25,5,-7,-14,22,-18,-3},{13,26,5,-7,-15,23,-19,-3},{14,26,5,-7,-15,23,-19,-3},
+{14,27,5,-8,-15,24,-20,-3},{14,27,5,-8,-16,24,-20,-3},{14,28,5,-8,-16,25,-20,-4},{15,28,5,-8,-16,25,-21,-4},
+{15,29,5,-8,-17,26,-21,-4},{15,30,6,-8,-17,26,-22,-4},{16,30,6,-9,-17,27,-22,-4},{16,31,6,-9,-18,27,-23,-4},
+{16,31,6,-9,-18,28,-23,-4},{17,32,6,-9,-18,28,-23,-4},{17,32,6,-9,-19,29,-24,-4},{17,33,6,-9,-19,29,-24,-4},
+{17,34,6,-10,-19,30,-25,-4},{18,34,6,-10,-20,30,-25,-4},{18,35,7,-10,-20,31,-25,-5},{18,35,7,-10,-20,31,-26,-5},
+{19,36,7,-10,-21,32,-26,-5},{19,36,7,-10,-21,32,-27,-5},{19,37,7,-11,-21,33,-27,-5},{20,37,7,-11,-22,33,-28,-5},
+{20,38,7,-11,-22,34,-28,-5},{20,39,7,-11,-22,34,-28,-5},{20,39,7,-11,-23,35,-29,-5},{21,40,8,-11,-23,35,-29,-5},
+{21,40,8,-12,-23,36,-30,-5},{21,41,8,-12,-24,36,-30,-5},{22,41,8,-12,-24,37,-30,-6},{22,42,8,-12,-24,37,-31,-6},
+{22,43,8,-12,-25,38,-31,-6},{23,43,8,-12,-25,38,-32,-6},{23,44,8,-13,-25,39,-32,-6},{23,44,9,-13,-26,39,-33,-6},
+{23,45,9,-13,-26,40,-33,-6},{24,45,9,-13,-26,40,-33,-6},{24,46,9,-13,-27,41,-34,-6},{24,47,9,-14,-27,41,-34,-6},
+{25,47,9,-14,-27,42,-35,-6},{25,48,9,-14,-28,42,-35,-6},{25,48,9,-14,-28,43,-36,-6},{26,49,9,-14,-28,43,-36,-7},
+{26,49,10,-14,-29,44,-36,-7},{26,50,10,-15,-29,44,-37,-7},{26,51,10,-15,-29,45,-37,-7},{27,51,10,-15,-30,45,-38,-7},
+{27,52,10,-15,-30,46,-38,-7},{27,52,10,-15,-30,46,-38,-7},{28,53,10,-15,-31,47,-39,-7},{28,53,10,-16,-31,47,-39,-7},
+{28,54,10,-16,-31,48,-40,-7},{29,54,11,-16,-32,48,-40,-7},{29,55,11,-16,-32,49,-41,-7},{29,56,11,-16,-32,49,-41,-8},
+{29,56,11,-16,-33,50,-41,-8},{30,57,11,-17,-33,50,-42,-8},{30,57,11,-17,-33,51,-42,-8},{30,58,11,-17,-34,51,-43,-8},
+{31,58,11,-17,-34,52,-43,-8},{31,59,11,-17,-34,52,-43,-8},{31,60,12,-17,-35,53,-44,-8},{31,60,12,-18,-35,53,-44,-8},
+{32,61,12,-18,-35,54,-45,-8},{32,61,12,-18,-36,54,-45,-8},{32,62,12,-18,-36,55,-46,-8},{33,62,12,-18,-36,55,-46,-9},
+{33,63,12,-18,-37,56,-46,-9},{33,64,12,-19,-37,56,-47,-9},{34,64,12,-19,-37,57,-47,-9},{34,65,13,-19,-38,57,-48,-9},
+{34,65,13,-19,-38,58,-48,-9},{34,66,13,-19,-38,58,-48,-9},{35,66,13,-19,-39,59,-49,-9},{35,67,13,-20,-39,59,-49,-9},
+{35,68,13,-20,-39,60,-50,-9},{36,68,13,-20,-40,60,-50,-9},{36,69,13,-20,-40,61,-51,-9},{36,69,14,-20,-40,61,-51,-9},
+{37,70,14,-20,-41,62,-51,-10},{37,70,14,-21,-41,62,-52,-10},{37,71,14,-21,-41,63,-52,-10},{37,72,14,-21,-42,63,-53,-10},
+{38,72,14,-21,-42,64,-53,-10},{38,73,14,-21,-42,64,-54,-10},{38,73,14,-21,-43,65,-54,-10},{39,74,14,-22,-43,65,-54,-10},
+{39,74,15,-22,-43,66,-55,-10},{39,75,15,-22,-44,66,-55,-10},{40,75,15,-22,-44,67,-56,-10},{40,76,15,-22,-44,67,-56,-10},
+{40,77,15,-22,-45,68,-56,-11},{40,77,15,-23,-45,68,-57,-11},{41,78,15,-23,-45,69,-57,-11},{41,78,15,-23,-46,69,-58,-11},
+{41,79,15,-23,-46,70,-58,-11},{42,79,16,-23,-46,70,-59,-11},{42,80,16,-23,-47,71,-59,-11},{42,81,16,-24,-47,71,-59,-11},
+{43,81,16,-24,-47,72,-60,-11},{43,82,16,-24,-48,72,-60,-11},{43,82,16,-24,-48,73,-61,-11},{43,83,16,-24,-48,73,-61,-11},
+{44,83,16,-24,-49,74,-61,-12},{44,84,16,-25,-49,74,-62,-12},{44,85,17,-25,-49,75,-62,-12},{45,85,17,-25,-50,75,-63,-12},
+{45,86,17,-25,-50,76,-63,-12},{45,86,17,-25,-50,76,-64,-12},{46,87,17,-25,-51,77,-64,-12},{46,87,17,-26,-51,77,-64,-12},
+{46,88,17,-26,-51,78,-65,-12},{46,89,17,-26,-52,78,-65,-12},{47,89,18,-26,-52,79,-66,-12},{47,90,18,-26,-52,79,-66,-12},
+{47,90,18,-26,-53,80,-66,-13},{48,91,18,-27,-53,80,-67,-13},{48,91,18,-27,-53,81,-67,-13},{48,92,18,-27,-54,81,-68,-13},
+{49,92,18,-27,-54,82,-68,-13},{49,93,18,-27,-54,82,-69,-13},{49,94,18,-28,-54,83,-69,-13},{49,94,19,-28,-55,83,-69,-13},
+{50,95,19,-28,-55,84,-70,-13},{50,95,19,-28,-55,84,-70,-13},{50,96,19,-28,-56,85,-71,-13},{51,96,19,-28,-56,85,-71,-13},
+{51,97,19,-29,-56,86,-72,-13},{51,98,19,-29,-57,86,-72,-14},{52,98,19,-29,-57,87,-72,-14},{52,99,19,-29,-57,87,-73,-14},
+{52,99,20,-29,-58,88,-73,-14},{52,100,20,-29,-58,88,-74,-14},{53,100,20,-30,-58,89,-74,-14},{53,101,20,-30,-59,89,-74,-14},
+{53,102,20,-30,-59,90,-75,-14},{54,102,20,-30,-59,90,-75,-14},{54,103,20,-30,-60,91,-76,-14},{54,103,20,-30,-60,91,-76,-14},
+{55,104,20,-31,-60,92,-77,-14},{55,104,21,-31,-61,92,-77,-15},{55,105,21,-31,-61,93,-77,-15},{55,106,21,-31,-61,93,-78,-15},
+{56,106,21,-31,-62,94,-78,-15},{56,107,21,-31,-62,94,-79,-15},{56,107,21,-32,-62,95,-79,-15},{57,108,21,-32,-63,95,-79,-15},
+{57,108,21,-32,-63,96,-80,-15},{57,109,22,-32,-63,96,-80,-15},{58,109,22,-32,-64,97,-81,-15},{58,110,22,-32,-64,97,-81,-15},
+{58,111,22,-33,-64,98,-82,-15},{58,111,22,-33,-65,98,-82,-16},{59,112,22,-33,-65,99,-82,-16},{59,112,22,-33,-65,99,-83,-16},
+{59,113,22,-33,-66,100,-83,-16},{60,113,22,-33,-66,100,-84,-16},{60,114,23,-34,-66,101,-84,-16},{60,115,23,-34,-67,101,-84,-16},
+{60,115,23,-34,-67,102,-85,-16},{61,116,23,-34,-67,102,-85,-16},{61,116,23,-34,-68,103,-86,-16},{61,117,23,-34,-68,103,-86,-16},
+{62,117,23,-35,-68,104,-87,-16},{62,118,23,-35,-69,104,-87,-16},{62,119,23,-35,-69,105,-87,-17},{63,119,24,-35,-69,105,-88,-17},
+{63,120,24,-35,-70,106,-88,-17},{63,120,24,-35,-70,106,-89,-17},{63,121,24,-36,-70,107,-89,-17},{64,121,24,-36,-71,107,-90,-17},
+{64,122,24,-36,-71,108,-90,-17},{64,123,24,-36,-71,108,-90,-17},{65,123,24,-36,-72,109,-91,-17},{65,124,24,-36,-72,109,-91,-17},
+{65,124,25,-37,-72,110,-92,-17},{66,125,25,-37,-73,110,-92,-17},{66,125,25,-37,-73,111,-92,-18},{66,126,25,-37,-73,111,-93,-18},
+{66,127,25,-37,-74,112,-93,-18},{67,127,25,-37,-74,112,-94,-18},{67,128,25,-38,-74,113,-94,-18},{67,128,25,-38,-75,113,-95,-18},
+{68,129,25,-38,-75,114,-95,-18},{68,129,26,-38,-75,114,-95,-18},{68,130,26,-38,-76,115,-96,-18},{69,130,26,-38,-76,115,-96,-18},
+{69,131,26,-39,-76,116,-97,-18},{69,132,26,-39,-77,116,-97,-18},{69,132,26,-39,-77,117,-97,-19},{70,133,26,-39,-77,117,-98,-19},
+{70,133,26,-39,-78,118,-98,-19},{70,134,27,-39,-78,118,-99,-19},{71,134,27,-40,-78,119,-99,-19},{71,135,27,-40,-79,119,-100,-19},
+{71,136,27,-40,-79,120,-100,-19},{72,136,27,-40,-79,120,-100,-19},{72,137,27,-40,-80,121,-101,-19},{72,137,27,-40,-80,121,-101,-19},
+{72,138,27,-41,-80,122,-102,-19},{73,138,27,-41,-81,122,-102,-19},{73,139,28,-41,-81,123,-103,-19},{73,140,28,-41,-81,123,-103,-20},
+{74,140,28,-41,-82,124,-103,-20},{74,141,28,-42,-82,124,-104,-20},{74,141,28,-42,-82,125,-104,-20},{75,142,28,-42,-83,125,-105,-20},
+{75,142,28,-42,-83,126,-105,-20},{75,143,28,-42,-83,126,-105,-20},{75,144,28,-42,-84,127,-106,-20},{76,144,29,-43,-84,127,-106,-20}};
+/* }}} */
+
+/* {{{ [fold] qc_yuv_toplanar(unsigned char *rgb24frame, int length, int format) */
+/*
+ * Convert to planar formats
+ * The input is an YCbYCr format.
+ * Input: len : 2/3 maxi.
+ *  | YUYV          | free |
+ *  | 2/3           | 1/3  |
+ * 1th conversion:
+ *  | YY  | free    | U|V  |
+ *  | 1/3 | 1/3     | 1/3  |
+ * 2d conversion:
+ *  | YY  | U  | V  | free |
+ *  | 1/3 | 1/6|1/6 | 1/3  |
+ * That the Y422P conversion.
+ */
+static int qc_yuv_toplanar(unsigned char *rgb24frame, int length, int format)
+{
+	unsigned char *ptr;
+	int n = 0, l = 0, i;
+	unsigned char *cr;
+	unsigned char *cb;
+	unsigned char *crptr, *cbptr;
+	int mode = 0;
+	
+	l = length/2;
+	switch(format) {
+		case VIDEO_PALETTE_YUV411P:
+			n = length/8;
+			mode = 1;
+			break;
+		case VIDEO_PALETTE_YUV422P:
+			n = length/4;
+			break;
+	}
+
+	ptr = rgb24frame;
+	crptr = &rgb24frame[length];
+	cr = crptr;
+	cbptr = &rgb24frame[length+n];
+	cb = cbptr;
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_yuv_toplanar: %d (%d + 2 * %d)",length, l, n);
+
+	/* separate Y , U and V */
+	for (i=0; i<length; i+=2) {
+		*ptr++ = rgb24frame[i];
+		if (mode) {
+			if ((i/2)%4==3) {
+				*cbptr++ = rgb24frame[i+1];
+				*crptr++ = rgb24frame[i-1];
+			}
+		}
+		else {
+			if ((i/2)%2)
+				*cbptr++ = rgb24frame[i+1];
+			else
+				*crptr++ = rgb24frame[i+1];
+		}
+	}
+
+	/* copy the UV plans after the Y */
+	memcpy(&rgb24frame[l], cr, n);
+	memcpy(&rgb24frame[l+n], cb, n);
+	// That is useless! frame->scanlength = length/2+ (2 * n);
+	return length;
+}
+/* }}} */
+/* {{{ [fold] qc_yuv_rgb2yuv(unsigned char *rgb24frame, int length, int format) */
+/*
+ * Convert the RGB24 image to YUV422.
+ * return the size of the converted frame
+ */
+int qc_yuv_rgb2yuv(unsigned char *rgb24frame, int length, int format)
+{
+	int i;
+	int l;			/* Data length */
+	short Y;
+	short U;
+	short V;
+	unsigned char *ptr;
+	unsigned short w;
+
+	//if (qcdebug&QC_DEBUGLOGIC)PDEBUG("qc_yuv_rgb2yuv(frame=%p,length=%i,palette=%s)",rgb24frame,length,qc_fmt_getname(format));
+	ptr = rgb24frame;
+	l = 0;
+
+	if (format==VIDEO_PALETTE_RGB32) {
+		/* we need to convert in reverse so as to not overwrite ourselves */
+		for (ptr=ptr+length*4/3,i=length-3; i>=0; i-=3) {
+			*--ptr = 0;
+			*--ptr = (unsigned char) rgb24frame[i + 2];
+			*--ptr = (unsigned char) rgb24frame[i + 1];
+			*--ptr = (unsigned char) rgb24frame[i + 0];
+			l += 4;
+		}
+	} else
+	for (i=0; i<length; i+=3) {
+		Y = qc_yuv_interp[rgb24frame[i]][0] + qc_yuv_interp[rgb24frame[i+1]][1] + qc_yuv_interp[rgb24frame[i+2]][2];
+		U = qc_yuv_interp[rgb24frame[i]][3] + qc_yuv_interp[rgb24frame[i+1]][4] + qc_yuv_interp[rgb24frame[i+2]][5];
+		V = qc_yuv_interp[rgb24frame[i]][5] + qc_yuv_interp[rgb24frame[i+1]][6] + qc_yuv_interp[rgb24frame[i+2]][7];
+
+		/* color/brightness could be arranged here */
+
+		Y = CLIP(Y, 0,255);
+		U = CLIP(U, -127,127);
+		V = CLIP(V, -127,127);
+
+		switch(format) {
+		case VIDEO_PALETTE_GREY:
+			*ptr++ = (219 * Y)/255 + 16;
+			l++;
+			break;
+		case VIDEO_PALETTE_YUV411:
+			// Not yet supported.
+			break;
+		case VIDEO_PALETTE_YUV411P:
+		case VIDEO_PALETTE_YUV422:
+		case VIDEO_PALETTE_YUV422P:
+			*ptr++ = (219 * Y)/255 + 16;
+			l++;
+			if ((i/3)%2)
+				*ptr = (112 * U)/127 + 128; /* Cb */
+			else
+				*ptr = (112 * V)/127 + 128; /* Cr */
+			ptr++;
+			l++;
+			break;
+		case VIDEO_PALETTE_RGB565:
+			/* take top five bits and pack while switch RGB with BGR */
+			/* FIXME: do we need to take into account of non-x86 byte ordering? */
+			w = ((unsigned short)
+				((unsigned short) (rgb24frame[i + 2] & 0xF8) << (11 - 3)) |
+				((unsigned short) (rgb24frame[i + 1] & 0xFC) << (5 - 2)) |
+				((unsigned short) (rgb24frame[i + 0] >> 3)));
+			*ptr++ = (unsigned char) (w & 0xFF);
+			*ptr++ = (unsigned char) (w >> 8);
+			l += 2;
+			break;
+		case VIDEO_PALETTE_RGB555:
+			w = ((unsigned short)
+				((unsigned short) (rgb24frame[i + 2] & 0xf8) << (10 - 3)) |
+				((unsigned short) (rgb24frame[i + 1] & 0xf8) << (5 - 3)) |
+				((unsigned short) (rgb24frame[i + 0] >> 3)));
+			*ptr++ = (unsigned char) (w & 0xFF);
+			*ptr++ = (unsigned char) (w >> 8);
+			l += 2;
+			break;
+		default:
+			*ptr++ = (219 * Y)/255 + 16;
+			l++;
+			*ptr = (112 * U)/127 + 128; /* Cb */
+			ptr++;
+			l++;
+			*ptr = (112 * V)/127 + 128; /* Cr */
+			ptr++;
+			l++;
+		}
+	}
+	if (format >= VIDEO_PALETTE_PLANAR) {
+		length = qc_yuv_toplanar(rgb24frame, l, format);
+	} else {
+		length = l;
+	}
+	return length;
+}
+/* }}} */
+
+/* }}} */
+/* {{{ [fold] **** qc_imag: Start of image processing functions ************************** */
+
+/* {{{ [fold] qc_imag_bayer_midvalue(char *bay, int bay_line, int columns, int rows) */
+/* Compute and return the average pixel intensity from the bayer data. 
+ * The result can be used for automatic software exposure/gain control.
+ * bay = points to the bayer image data (upper left pixel is green)
+ * bay_line = bytes between the beginnings of two consecutive rows
+ * columns, rows = bayer image size (both must be even)
+ */
+static unsigned char qc_imag_bayer_midvalue(unsigned char *bay, int bay_line, 
+	unsigned int columns, unsigned int rows)
+{
+	static const unsigned int stepsize = 8;		/* Larger = faster and less accurate */
+	unsigned char *cur_bay;
+	unsigned int sum = 0;
+	int column_cnt;
+	int row_cnt;
+
+	/* Skip 1/4 of left, right, top, and bottom pixels (use only center pixels) */
+	columns /= 2;
+	rows    /= 2;
+	bay     += rows/4*2*bay_line + columns/4*2;
+
+	columns /= stepsize*2;
+	rows    /= stepsize*2;
+
+	row_cnt = rows;
+	do {
+		column_cnt = columns;
+		cur_bay = bay;
+		do {
+			sum += cur_bay[0] + cur_bay[1] + cur_bay[bay_line];	/* R + G + B */
+			cur_bay += 2*stepsize;
+		} while (--column_cnt > 0);
+		bay += 2*stepsize*bay_line;
+	} while (--row_cnt > 0);
+	sum /= 3 * columns * rows;
+	return sum;
+}
+/* }}} */
+#if COMPRESS
+/* {{{ [fold] qc_imag_rgb24_midvalue(char *rgb, int rgb_line, int columns, int rows) */
+/* Compute and return the average pixel intensity from the RGB/BGR24 data. 
+ * The result can be used for automatic software exposure/gain control.
+ * rgb = points to the RGB image data
+ * rgb_line = bytes between the beginnings of two consecutive rows
+ * columns, rows = RGB image size
+ */
+static unsigned char qc_imag_rgb24_midvalue(unsigned char *rgb, int rgb_line, 
+	unsigned int columns, unsigned int rows)
+{
+	static const unsigned int stepsize = 8;		/* Larger = faster and less accurate */
+	unsigned char *cur_rgb;
+	unsigned int sum = 0;
+	int column_cnt;
+	int row_cnt;
+
+	/* Skip 1/4 of left, right, top, and bottom pixels (use only center pixels) */
+	columns /= 2;
+	rows    /= 2;
+	rgb     += rows/2*rgb_line + columns/2*3;
+
+	columns /= stepsize;
+	rows    /= stepsize;
+
+	row_cnt = rows;
+	do {
+		column_cnt = columns;
+		cur_rgb = rgb;
+		do {
+			sum += cur_rgb[0] + cur_rgb[1] + cur_rgb[2];		/* R + G + B */
+			cur_rgb += 3*stepsize;
+		} while (--column_cnt > 0);
+		rgb += stepsize*rgb_line;
+	} while (--row_cnt > 0);
+	sum /= 3 * columns * rows;
+	return sum;
+}
+/* }}} */
+#endif
+/* {{{ [fold] qc_imag_userlut(unsigned char (*userlut)[QC_LUT_SIZE], unsigned char (*lut)[QC_LUT_SIZE]) */
+/* Apply user-defined lookup-table to the given preinitialized lut */
+static inline void qc_imag_userlut(unsigned char (*userlut)[QC_LUT_SIZE], unsigned char (*lut)[QC_LUT_SIZE])
+{
+	unsigned int i,p;
+	for (i=0; i<256; i++) {
+		p = (*lut)[QC_LUT_RED + i];
+		p = (*userlut)[QC_LUT_RED + p];
+		(*lut)[QC_LUT_RED + i] = p;
+	}
+	for (i=0; i<256; i++) {
+		p = (*lut)[QC_LUT_GREEN + i];
+		p = (*userlut)[QC_LUT_GREEN + p];
+		(*lut)[QC_LUT_GREEN + i] = p;
+	}
+	for (i=0; i<256; i++) {
+		p = (*lut)[QC_LUT_BLUE + i];
+		p = (*userlut)[QC_LUT_BLUE + p];
+		(*lut)[QC_LUT_BLUE + i] = p;
+	}
+}
+/* }}} */
+/* {{{ [fold] qc_imag_bayer_equalize(char *bay, int bay_line, int columns, int rows, char (*lut)[]) */
+/* Compute and fill a lookup table which will equalize the image. 
+ * bay = points to the bayer image data (upper left pixel is green)
+ * bay_line = bytes between the beginnings of two consecutive rows
+ * columns, rows = bayer image size (both must be even)
+ * lut = lookup table to be filled, 3*256 char array
+ */
+static void qc_imag_bayer_equalize(unsigned char *bay, int bay_line, 
+	unsigned int columns, unsigned int rows, unsigned char (*lut)[QC_LUT_SIZE])
+{
+	static const unsigned int stepsize = 4;		/* Larger = faster and less accurate */
+	unsigned short red_cnt[256], green_cnt[256], blue_cnt[256];	/* FIXME: how much we can use stack? */
+	unsigned int red_sum, green_sum, blue_sum;
+	unsigned int red_tot, green_tot, blue_tot;
+	unsigned char *cur_bay;
+	int i, column_cnt, row_cnt;
+	
+	memset(red_cnt,   0, sizeof(red_cnt));
+	memset(green_cnt, 0, sizeof(green_cnt));
+	memset(blue_cnt,  0, sizeof(blue_cnt));
+	
+	columns /= 2*stepsize;
+	rows    /= 2*stepsize;
+
+	/* Compute histogram */
+	row_cnt = rows;
+	do {
+		column_cnt = columns;
+		cur_bay = bay;
+		do {
+			green_cnt[cur_bay[0]]++;
+			red_cnt  [cur_bay[1]]++;
+			blue_cnt [cur_bay[bay_line]]++;
+			green_cnt[cur_bay[bay_line+1]]++;
+			cur_bay += 2*stepsize;
+		} while (--column_cnt > 0);
+		bay += 2*stepsize*bay_line;
+	} while (--row_cnt > 0);
+
+	/* Compute lookup table based on the histogram */
+	red_tot   = columns * rows;		/* Total number of pixels of each primary color */
+	green_tot = red_tot * 2;
+	blue_tot  = red_tot;
+	red_sum   = 0;
+	green_sum = 0;
+	blue_sum  = 0;
+	for (i=0; i<256; i++) {
+		(*lut)[QC_LUT_RED   + i] = 255 * red_sum   / red_tot;
+		(*lut)[QC_LUT_GREEN + i] = 255 * green_sum / green_tot;
+		(*lut)[QC_LUT_BLUE  + i] = 255 * blue_sum  / blue_tot;
+		red_sum   += red_cnt[i];
+		green_sum += green_cnt[i];
+		blue_sum  += blue_cnt[i];
+	}
+}
+/* }}} */
+/* {{{ [fold] qc_imag_bayer_lut(char *bay, int bay_line, int columns, int rows, char (*lut)[]) */
+/* Transform pixel values in a bayer image with a given lookup table.
+ * bay = points to the bayer image data (upper left pixel is green)
+ * bay_line = bytes between the beginnings of two consecutive rows
+ * columns, rows = bayer image size (both must be even)
+ * lut = lookup table to be used, 3*256 char array
+ */
+static void qc_imag_bayer_lut(unsigned char *bay, int bay_line, 
+	unsigned int columns, unsigned int rows, unsigned char (*lut)[QC_LUT_SIZE])
+{
+	unsigned char *cur_bay;
+	unsigned int total_columns;
+	
+	total_columns = columns / 2;	/* Number of 2x2 bayer blocks */
+	rows /= 2;
+	do {
+		columns = total_columns;
+		cur_bay = bay;
+		do {
+			cur_bay[0] = (*lut)[QC_LUT_GREEN + cur_bay[0]];
+			cur_bay[1] = (*lut)[QC_LUT_RED   + cur_bay[1]];
+			cur_bay += 2;
+		} while (--columns);
+		bay += bay_line;
+		columns = total_columns;
+		cur_bay = bay;
+		do {
+			cur_bay[0] = (*lut)[QC_LUT_BLUE  + cur_bay[0]];
+			cur_bay[1] = (*lut)[QC_LUT_GREEN + cur_bay[1]];
+			cur_bay += 2;
+		} while (--columns);
+		bay += bay_line;
+	} while (--rows);
+}
+/* }}} */
+/* {{{ [fold] qc_imag_writergb(void *addr, int bpp, unsigned char r, unsigned char g, unsigned char b) */
+/* Write RGB pixel value to the given address.
+ * addr = memory address, to which the pixel is written
+ * bpp = number of bytes in the pixel (should be 3 or 4)
+ * r, g, b = pixel component values to be written (red, green, blue)
+ * Looks horribly slow but the compiler should be able to inline optimize it.
+ */
+static inline void qc_imag_writergb(void *addr, int bpp,
+	unsigned char r, unsigned char g, unsigned char b)
+{
+	if (DEFAULT_BGR) {
+		/* Blue is first (in the lowest memory address */
+		if (bpp==4) {
+#if defined(__LITTLE_ENDIAN)
+			*(unsigned int *)addr =
+				(unsigned int)r << 16 |
+				(unsigned int)g << 8 |
+				(unsigned int)b;
+#elif defined(__BIG_ENDIAN)
+			*(unsigned int *)addr =
+				(unsigned int)r << 8 |
+				(unsigned int)g << 16 |
+				(unsigned int)b << 24;
+#else
+			unsigned char *addr2 = (unsigned char *)addr;
+			addr2[0] = b;
+			addr2[1] = g;
+			addr2[2] = r;
+			addr2[3] = 0;
+#endif
+		} else {
+			unsigned char *addr2 = (unsigned char *)addr;
+			addr2[0] = b;
+			addr2[1] = g;
+			addr2[2] = r;
+		}
+	} else {
+		/* Red is first (in the lowest memory address */
+		if (bpp==4) {
+#if defined(__LITTLE_ENDIAN)
+			*(unsigned int *)addr =
+				(unsigned int)b << 16 |
+				(unsigned int)g << 8 |
+				(unsigned int)r;
+#elif defined(__BIG_ENDIAN)
+			*(unsigned int *)addr =
+				(unsigned int)b << 8 |
+				(unsigned int)g << 16 |
+				(unsigned int)r << 24;
+#else
+			unsigned char *addr2 = (unsigned char *)addr;
+			addr2[0] = r;
+			addr2[1] = g;
+			addr2[2] = b;
+			addr2[3] = 0;
+#endif
+		} else {
+			unsigned char *addr2 = (unsigned char *)addr;
+			addr2[0] = r;
+			addr2[1] = g;
+			addr2[2] = b;
+		}
+	}
+}
+/* }}} */
+
+/*
+ * Raw image data for Bayer-RGB-matrix:
+ * G R for even rows
+ * B G for odd rows
+ */
+
+#if 0
+/* {{{ [fold] qc_imag_bay2rgb_noip(char *bay, int bay_line, char *rgb, int rgb_line, int columns, rows, bpp) */
+/* Convert bayer image to RGB image without using interpolation.
+ * bay = points to the bayer image data (upper left pixel is green)
+ * bay_line = bytes between the beginnings of two consecutive rows
+ * rgb = points to the rgb image data that is written
+ * rgb_line = bytes between the beginnings of two consecutive rows
+ * columns, rows = bayer image size (both must be even)
+ * bpp = number of bytes in each pixel in the RGB image (should be 3 or 4)
+ */
+/* Execution time: 2391747-2653574 clock cycles for CIF image (Pentium II) */
+/* Do NOT use this routine: cottnoip is faster with better image quality */
+static inline void qc_imag_bay2rgb_noip(unsigned char *bay, int bay_line,
+		unsigned char *rgb, int rgb_line,
+		int columns, int rows, int bpp)
+{
+	unsigned char *cur_bay, *cur_rgb;
+	int bay_line2, rgb_line2;
+	int total_columns;
+
+	/* Process 2 lines and rows per each iteration */
+	total_columns = columns >> 1;
+	rows >>= 1;
+	bay_line2 = 2*bay_line;
+	rgb_line2 = 2*rgb_line;
+	do {
+		cur_bay = bay;
+		cur_rgb = rgb;
+		columns = total_columns;
+		do {
+			qc_imag_writergb(cur_rgb+0,            bpp, cur_bay[1], cur_bay[0],          cur_bay[bay_line]);
+			qc_imag_writergb(cur_rgb+bpp,          bpp, cur_bay[1], cur_bay[0],          cur_bay[bay_line]);
+			qc_imag_writergb(cur_rgb+rgb_line,     bpp, cur_bay[1], cur_bay[bay_line+1], cur_bay[bay_line]);
+			qc_imag_writergb(cur_rgb+rgb_line+bpp, bpp, cur_bay[1], cur_bay[bay_line+1], cur_bay[bay_line]);
+			cur_bay += 2;
+			cur_rgb += 2*bpp;
+		} while (--columns);
+		bay += bay_line2;
+		rgb += rgb_line2;
+	} while (--rows);
+}		  
+/* }}} */
+#endif
+/* {{{ [fold] qc_imag_bay2rgb_horip(char *bay, int bay_line, char *rgb, int rgb_line, columns, rows, bpp) */
+/* Convert bayer image to RGB image using fast horizontal-only interpolation.
+ * bay = points to the bayer image data (upper left pixel is green)
+ * bay_line = bytes between the beginnings of two consecutive rows
+ * rgb = points to the rgb image data that is written
+ * rgb_line = bytes between the beginnings of two consecutive rows
+ * columns, rows = bayer image size (both must be even)
+ * bpp = number of bytes in each pixel in the RGB image (should be 3 or 4)
+ */
+/* Execution time: 2735776-3095322 clock cycles for CIF image (Pentium II) */
+/* Not recommended: ip seems to be somewhat faster, probably with better image quality.
+ * cott is quite much faster, but possibly with slightly worse image quality */
+static inline void qc_imag_bay2rgb_horip(unsigned char *bay, int bay_line,
+		unsigned char *rgb, int rgb_line,
+		unsigned int columns, unsigned int rows, int bpp) 
+{
+	unsigned char *cur_bay, *cur_rgb;
+	int bay_line2, rgb_line2;
+	int total_columns;
+	unsigned char red, green, blue;
+	unsigned int column_cnt, row_cnt;
+
+	/* Process 2 lines and rows per each iteration */
+	total_columns = (columns-2) / 2;
+	row_cnt = rows / 2;
+	bay_line2 = 2*bay_line;
+	rgb_line2 = 2*rgb_line;
+	
+	do {
+		qc_imag_writergb(rgb+0,        bpp, bay[1], bay[0], bay[bay_line]);
+		qc_imag_writergb(rgb+rgb_line, bpp, bay[1], bay[0], bay[bay_line]);
+		cur_bay = bay + 1;
+		cur_rgb = rgb + bpp;
+		column_cnt = total_columns;
+		do {
+			green = ((unsigned int)cur_bay[-1]+cur_bay[1]) / 2;
+			blue  = ((unsigned int)cur_bay[bay_line-1]+cur_bay[bay_line+1]) / 2;
+			qc_imag_writergb(cur_rgb+0, bpp, cur_bay[0], green, blue);
+			red   = ((unsigned int)cur_bay[0]+cur_bay[2]) / 2;
+			qc_imag_writergb(cur_rgb+bpp, bpp, red, cur_bay[1], cur_bay[bay_line+1]);
+			green = ((unsigned int)cur_bay[bay_line]+cur_bay[bay_line+2]) / 2;
+			qc_imag_writergb(cur_rgb+rgb_line, bpp, cur_bay[0], cur_bay[bay_line], blue);
+			qc_imag_writergb(cur_rgb+rgb_line+bpp, bpp, red, cur_bay[1], cur_bay[bay_line+1]);
+			cur_bay += 2;
+			cur_rgb += 2*bpp;
+		} while (--column_cnt);
+		qc_imag_writergb(cur_rgb+0,        bpp, cur_bay[0], cur_bay[-1],       cur_bay[bay_line-1]);
+		qc_imag_writergb(cur_rgb+rgb_line, bpp, cur_bay[0], cur_bay[bay_line], cur_bay[bay_line-1]);
+		bay += bay_line2;
+		rgb += rgb_line2;
+	} while (--row_cnt);
+}		  
+/* }}} */
+/* {{{ [fold] qc_imag_bay2rgb_ip(char *bay, int bay_line, char *rgb, int rgb_line, columns, rows, bpp) */
+/* Convert bayer image to RGB image using full (slow) linear interpolation.
+ * bay = points to the bayer image data (upper left pixel is green)
+ * bay_line = bytes between the beginnings of two consecutive rows
+ * rgb = points to the rgb image data that is written
+ * rgb_line = bytes between the beginnings of two consecutive rows
+ * columns, rows = bayer image size (both must be even)
+ * bpp = number of bytes in each pixel in the RGB image (should be 3 or 4)
+ */
+/* Execution time: 2714077-2827455 clock cycles for CIF image (Pentium II) */
+static inline void qc_imag_bay2rgb_ip(unsigned char *bay, int bay_line,
+		unsigned char *rgb, int rgb_line,
+		unsigned int columns, unsigned int rows, int bpp) 
+{
+	unsigned char *cur_bay, *cur_rgb;
+	int bay_line2, rgb_line2;
+	int total_columns;
+	unsigned char red, green, blue;
+	unsigned int column_cnt, row_cnt;
+
+	/* Process 2 rows and columns each iteration */
+	total_columns = (columns-2) / 2;
+	row_cnt = (rows-2) / 2;
+	bay_line2 = 2*bay_line;
+	rgb_line2 = 2*rgb_line;
+
+	/* First scanline is handled here as a special case */	
+	qc_imag_writergb(rgb, bpp, bay[1], bay[0], bay[bay_line]);
+	cur_bay = bay + 1;
+	cur_rgb = rgb + bpp;
+	column_cnt = total_columns;
+	do {
+		green  = ((unsigned int)cur_bay[-1] + cur_bay[1] + cur_bay[bay_line]) / 3;
+		blue   = ((unsigned int)cur_bay[bay_line-1] + cur_bay[bay_line+1]) / 2;
+		qc_imag_writergb(cur_rgb, bpp, cur_bay[0], green, blue);
+		red    = ((unsigned int)cur_bay[0] + cur_bay[2]) / 2;
+		qc_imag_writergb(cur_rgb+bpp, bpp, red, cur_bay[1], cur_bay[bay_line+1]);
+		cur_bay += 2;
+		cur_rgb += 2*bpp;
+	} while (--column_cnt);
+	green = ((unsigned int)cur_bay[-1] + cur_bay[bay_line]) / 2;
+	qc_imag_writergb(cur_rgb, bpp, cur_bay[0], green, cur_bay[bay_line-1]);
+
+	/* Process here all other scanlines except first and last */
+	bay += bay_line;
+	rgb += rgb_line;
+	do {
+		red = ((unsigned int)bay[-bay_line+1] + bay[bay_line+1]) / 2;
+		green = ((unsigned int)bay[-bay_line] + bay[1] + bay[bay_line]) / 3;
+		qc_imag_writergb(rgb+0, bpp, red, green, bay[0]);
+		blue = ((unsigned int)bay[0] + bay[bay_line2]) / 2;
+		qc_imag_writergb(rgb+rgb_line, bpp, bay[bay_line+1], bay[bay_line], blue);
+		cur_bay = bay + 1;
+		cur_rgb = rgb + bpp;
+		column_cnt = total_columns;
+		do {
+			red   = ((unsigned int)cur_bay[-bay_line]+cur_bay[bay_line]) / 2;
+			blue  = ((unsigned int)cur_bay[-1]+cur_bay[1]) / 2;
+			qc_imag_writergb(cur_rgb+0, bpp, red, cur_bay[0], blue);
+			red   = ((unsigned int)cur_bay[-bay_line]+cur_bay[-bay_line+2]+cur_bay[bay_line]+cur_bay[bay_line+2]) / 4;
+			green = ((unsigned int)cur_bay[0]+cur_bay[2]+cur_bay[-bay_line+1]+cur_bay[bay_line+1]) / 4;
+			qc_imag_writergb(cur_rgb+bpp, bpp, red, green, cur_bay[1]);
+			green = ((unsigned int)cur_bay[0]+cur_bay[bay_line2]+cur_bay[bay_line-1]+cur_bay[bay_line+1]) / 4;
+			blue  = ((unsigned int)cur_bay[-1]+cur_bay[1]+cur_bay[bay_line2-1]+cur_bay[bay_line2+1]) / 4;
+			qc_imag_writergb(cur_rgb+rgb_line, bpp, cur_bay[bay_line], green, blue);
+			red   = ((unsigned int)cur_bay[bay_line]+cur_bay[bay_line+2]) / 2;
+			blue  = ((unsigned int)cur_bay[1]+cur_bay[bay_line2+1]) / 2;
+			qc_imag_writergb(cur_rgb+rgb_line+bpp, bpp, red, cur_bay[bay_line+1], blue);
+			cur_bay += 2;
+			cur_rgb += 2*bpp;
+		} while (--column_cnt);
+		red = ((unsigned int)cur_bay[-bay_line] + cur_bay[bay_line]) / 2;
+		qc_imag_writergb(cur_rgb, bpp, red, cur_bay[0], cur_bay[-1]);
+		green = ((unsigned int)cur_bay[0] + cur_bay[bay_line-1] + cur_bay[bay_line2]) / 3;
+		blue = ((unsigned int)cur_bay[-1] + cur_bay[bay_line2-1]) / 2;
+		qc_imag_writergb(cur_rgb+rgb_line, bpp, cur_bay[bay_line], green, blue);
+		bay += bay_line2;
+		rgb += rgb_line2;
+	} while (--row_cnt);
+
+	/* Last scanline is handled here as a special case */	
+	green = ((unsigned int)bay[-bay_line] + bay[1]) / 2;
+	qc_imag_writergb(rgb, bpp, bay[-bay_line+1], green, bay[0]);
+	cur_bay = bay + 1;
+	cur_rgb = rgb + bpp;
+	column_cnt = total_columns;
+	do {
+		blue   = ((unsigned int)cur_bay[-1] + cur_bay[1]) / 2;
+		qc_imag_writergb(cur_rgb, bpp, cur_bay[-bay_line], cur_bay[0], blue);
+		red    = ((unsigned int)cur_bay[-bay_line] + cur_bay[-bay_line+2]) / 2;
+		green  = ((unsigned int)cur_bay[0] + cur_bay[-bay_line+1] + cur_bay[2]) / 3;
+		qc_imag_writergb(cur_rgb+bpp, bpp, red, green, cur_bay[1]);
+		cur_bay += 2;
+		cur_rgb += 2*bpp;
+	} while (--column_cnt);
+	qc_imag_writergb(cur_rgb, bpp, cur_bay[-bay_line], cur_bay[0], cur_bay[-1]);
+}
+/* }}} */
+/* {{{ [fold] qc_imag_bay2rgb_cott(unsigned char *bay, int bay_line, unsigned char *rgb, int rgb_line, int columns, int rows, int bpp) */
+/* Convert bayer image to RGB image using 0.5 displaced light linear interpolation.
+ * bay = points to the bayer image data (upper left pixel is green)
+ * bay_line = bytes between the beginnings of two consecutive rows
+ * rgb = points to the rgb image data that is written
+ * rgb_line = bytes between the beginnings of two consecutive rows
+ * columns, rows = bayer image size (both must be even)
+ * bpp = number of bytes in each pixel in the RGB image (should be 3 or 4)
+ */
+/* Execution time: 2167685 clock cycles for CIF image (Pentium II) */
+/* Original idea for this routine from Cagdas Ogut */
+static inline void qc_imag_bay2rgb_cott(unsigned char *bay, int bay_line,
+		unsigned char *rgb, int rgb_line,
+		int columns, int rows, int bpp)
+{
+	unsigned char *cur_bay, *cur_rgb;
+	int bay_line2, rgb_line2;
+	int total_columns;
+
+	/* Process 2 lines and rows per each iteration, but process the last row and column separately */
+	total_columns = (columns>>1) - 1;
+	rows = (rows>>1) - 1;
+	bay_line2 = 2*bay_line;
+	rgb_line2 = 2*rgb_line;
+	do {
+		cur_bay = bay;
+		cur_rgb = rgb;
+		columns = total_columns;
+		do {
+			qc_imag_writergb(cur_rgb+0,            bpp, cur_bay[1],           ((unsigned int)cur_bay[0] + cur_bay[bay_line+1])          /2, cur_bay[bay_line]);
+			qc_imag_writergb(cur_rgb+bpp,          bpp, cur_bay[1],           ((unsigned int)cur_bay[2] + cur_bay[bay_line+1])          /2, cur_bay[bay_line+2]);
+			qc_imag_writergb(cur_rgb+rgb_line,     bpp, cur_bay[bay_line2+1], ((unsigned int)cur_bay[bay_line2] + cur_bay[bay_line+1])  /2, cur_bay[bay_line]);
+			qc_imag_writergb(cur_rgb+rgb_line+bpp, bpp, cur_bay[bay_line2+1], ((unsigned int)cur_bay[bay_line2+2] + cur_bay[bay_line+1])/2, cur_bay[bay_line+2]);
+			cur_bay += 2;
+			cur_rgb += 2*bpp;
+		} while (--columns);
+		qc_imag_writergb(cur_rgb+0,            bpp, cur_bay[1], ((unsigned int)cur_bay[0] + cur_bay[bay_line+1])/2, cur_bay[bay_line]);
+		qc_imag_writergb(cur_rgb+bpp,          bpp, cur_bay[1], cur_bay[bay_line+1], cur_bay[bay_line]);
+		qc_imag_writergb(cur_rgb+rgb_line,     bpp, cur_bay[bay_line2+1], ((unsigned int)cur_bay[bay_line2] + cur_bay[bay_line+1])/2, cur_bay[bay_line]);
+		qc_imag_writergb(cur_rgb+rgb_line+bpp, bpp, cur_bay[bay_line2+1], cur_bay[bay_line+1], cur_bay[bay_line]);
+		bay += bay_line2;
+		rgb += rgb_line2;
+	} while (--rows);
+	/* Last scanline handled here as special case */
+	cur_bay = bay;
+	cur_rgb = rgb;
+	columns = total_columns;
+	do {
+		qc_imag_writergb(cur_rgb+0,            bpp, cur_bay[1], ((unsigned int)cur_bay[0] + cur_bay[bay_line+1])/2, cur_bay[bay_line]);
+		qc_imag_writergb(cur_rgb+bpp,          bpp, cur_bay[1], ((unsigned int)cur_bay[2] + cur_bay[bay_line+1])/2, cur_bay[bay_line+2]);
+		qc_imag_writergb(cur_rgb+rgb_line,     bpp, cur_bay[1], cur_bay[bay_line+1], cur_bay[bay_line]);
+		qc_imag_writergb(cur_rgb+rgb_line+bpp, bpp, cur_bay[1], cur_bay[bay_line+1], cur_bay[bay_line+2]);
+		cur_bay += 2;
+		cur_rgb += 2*bpp;
+	} while (--columns);
+	/* Last lower-right pixel is handled here as special case */
+	qc_imag_writergb(cur_rgb+0,            bpp, cur_bay[1], ((unsigned int)cur_bay[0] + cur_bay[bay_line+1])/2, cur_bay[bay_line]);
+	qc_imag_writergb(cur_rgb+bpp,          bpp, cur_bay[1], cur_bay[bay_line+1], cur_bay[bay_line]);
+	qc_imag_writergb(cur_rgb+rgb_line,     bpp, cur_bay[1], cur_bay[bay_line+1], cur_bay[bay_line]);
+	qc_imag_writergb(cur_rgb+rgb_line+bpp, bpp, cur_bay[1], cur_bay[bay_line+1], cur_bay[bay_line]);
+}
+/* }}} */
+/* {{{ [fold] qc_imag_bay2rgb_cottnoip(unsigned char *bay, int bay_line, unsigned char *rgb, int rgb_line, int columns, int rows, int bpp) */
+/* Convert bayer image to RGB image using 0.5 displaced nearest neighbor.
+ * bay = points to the bayer image data (upper left pixel is green)
+ * bay_line = bytes between the beginnings of two consecutive rows
+ * rgb = points to the rgb image data that is written
+ * rgb_line = bytes between the beginnings of two consecutive rows
+ * columns, rows = bayer image size (both must be even)
+ * bpp = number of bytes in each pixel in the RGB image (should be 3 or 4)
+ */
+/* Execution time: 2133302 clock cycles for CIF image (Pentium II), fastest */
+static inline void qc_imag_bay2rgb_cottnoip(unsigned char *bay, int bay_line,
+		unsigned char *rgb, int rgb_line,
+		int columns, int rows, int bpp)
+{
+	unsigned char *cur_bay, *cur_rgb;
+	int bay_line2, rgb_line2;
+	int total_columns;
+
+	/* Process 2 lines and rows per each iteration, but process the last row and column separately */
+	total_columns = (columns>>1) - 1;
+	rows = (rows>>1) - 1;
+	bay_line2 = 2*bay_line;
+	rgb_line2 = 2*rgb_line;
+	do {
+		cur_bay = bay;
+		cur_rgb = rgb;
+		columns = total_columns;
+		do {
+			qc_imag_writergb(cur_rgb+0,            bpp, cur_bay[1],           cur_bay[0], cur_bay[bay_line]);
+			qc_imag_writergb(cur_rgb+bpp,          bpp, cur_bay[1],           cur_bay[2], cur_bay[bay_line+2]);
+			qc_imag_writergb(cur_rgb+rgb_line,     bpp, cur_bay[bay_line2+1], cur_bay[bay_line+1], cur_bay[bay_line]);
+			qc_imag_writergb(cur_rgb+rgb_line+bpp, bpp, cur_bay[bay_line2+1], cur_bay[bay_line+1], cur_bay[bay_line+2]);
+			cur_bay += 2;
+			cur_rgb += 2*bpp;
+		} while (--columns);
+		qc_imag_writergb(cur_rgb+0,            bpp, cur_bay[1], cur_bay[0], cur_bay[bay_line]);
+		qc_imag_writergb(cur_rgb+bpp,          bpp, cur_bay[1], cur_bay[bay_line+1], cur_bay[bay_line]);
+		qc_imag_writergb(cur_rgb+rgb_line,     bpp, cur_bay[bay_line2+1], cur_bay[bay_line+1], cur_bay[bay_line]);
+		qc_imag_writergb(cur_rgb+rgb_line+bpp, bpp, cur_bay[bay_line2+1], cur_bay[bay_line+1], cur_bay[bay_line]);
+		bay += bay_line2;
+		rgb += rgb_line2;
+	} while (--rows);
+	/* Last scanline handled here as special case */
+	cur_bay = bay;
+	cur_rgb = rgb;
+	columns = total_columns;
+	do {
+		qc_imag_writergb(cur_rgb+0,            bpp, cur_bay[1], cur_bay[0], cur_bay[bay_line]);
+		qc_imag_writergb(cur_rgb+bpp,          bpp, cur_bay[1], cur_bay[2], cur_bay[bay_line+2]);
+		qc_imag_writergb(cur_rgb+rgb_line,     bpp, cur_bay[1], cur_bay[bay_line+1], cur_bay[bay_line]);
+		qc_imag_writergb(cur_rgb+rgb_line+bpp, bpp, cur_bay[1], cur_bay[bay_line+1], cur_bay[bay_line+2]);
+		cur_bay += 2;
+		cur_rgb += 2*bpp;
+	} while (--columns);
+	/* Last lower-right pixel is handled here as special case */
+	qc_imag_writergb(cur_rgb+0,            bpp, cur_bay[1], cur_bay[0], cur_bay[bay_line]);
+	qc_imag_writergb(cur_rgb+bpp,          bpp, cur_bay[1], cur_bay[bay_line+1], cur_bay[bay_line]);
+	qc_imag_writergb(cur_rgb+rgb_line,     bpp, cur_bay[1], cur_bay[bay_line+1], cur_bay[bay_line]);
+	qc_imag_writergb(cur_rgb+rgb_line+bpp, bpp, cur_bay[1], cur_bay[bay_line+1], cur_bay[bay_line]);
+}
+/* }}} */
+/* {{{ [fold] qc_imag_bay2rgb_gptm_fast(unsigned char *bay, int bay_line, unsigned char *rgb, int rgb_line, int columns, int rows, int bpp) */
+/* Convert Bayer image to RGB image using Generalized Pei-Tam method
+ * Uses fixed weights */
+/* Execution time: 3795517 clock cycles */
+static inline void qc_imag_bay2rgb_gptm_fast(unsigned char *bay, int bay_line,
+		   unsigned char *rgb, int rgb_line,
+		   int columns, int rows, int bpp)
+{
+	int r,g,b,w;
+	unsigned char *cur_bay, *cur_rgb;
+	int bay_line2, bay_line3, rgb_line2;
+	int total_columns;
+
+	/* Process 2 lines and rows per each iteration, but process the first and last two columns and rows separately */
+	total_columns = (columns>>1) - 2;
+	rows = (rows>>1) - 2;
+	bay_line2 = 2*bay_line;
+	bay_line3 = 3*bay_line;
+	rgb_line2 = 2*rgb_line;
+
+	/* Process first two pixel rows here */
+	cur_bay = bay;
+	cur_rgb = rgb;
+	columns = total_columns + 2;
+	do {
+		qc_imag_writergb(cur_rgb+0,            bpp, cur_bay[1], cur_bay[0],          cur_bay[bay_line]);
+		qc_imag_writergb(cur_rgb+bpp,          bpp, cur_bay[1], cur_bay[0],          cur_bay[bay_line]);
+		qc_imag_writergb(cur_rgb+rgb_line,     bpp, cur_bay[1], cur_bay[bay_line+1], cur_bay[bay_line]);
+		qc_imag_writergb(cur_rgb+rgb_line+bpp, bpp, cur_bay[1], cur_bay[bay_line+1], cur_bay[bay_line]);
+		cur_bay += 2;
+		cur_rgb += 2*bpp;
+	} while (--columns);
+	bay += bay_line2;
+	rgb += rgb_line2;
+
+	do {
+		cur_bay = bay;
+		cur_rgb = rgb;
+		columns = total_columns;
+		
+		/* Process first 2x2 pixel block in a row here */
+		qc_imag_writergb(cur_rgb+0,            bpp, cur_bay[1], cur_bay[0],          cur_bay[bay_line]);
+		qc_imag_writergb(cur_rgb+bpp,          bpp, cur_bay[1], cur_bay[0],          cur_bay[bay_line]);
+		qc_imag_writergb(cur_rgb+rgb_line,     bpp, cur_bay[1], cur_bay[bay_line+1], cur_bay[bay_line]);
+		qc_imag_writergb(cur_rgb+rgb_line+bpp, bpp, cur_bay[1], cur_bay[bay_line+1], cur_bay[bay_line]);
+		cur_bay += 2;
+		cur_rgb += 2*bpp;
+
+		do {
+			w = 4*cur_bay[0] - (cur_bay[-bay_line-1] + cur_bay[-bay_line+1] + cur_bay[bay_line-1] + cur_bay[bay_line+1]);
+			r = (2*(cur_bay[-1] + cur_bay[1]) + w) >> 2;
+			b = (2*(cur_bay[-bay_line] + cur_bay[bay_line]) + w) >> 2;
+			qc_imag_writergb(cur_rgb+0, bpp, CLIP(r,0,255), cur_bay[0], CLIP(b,0,255));
+
+			w = 4*cur_bay[1] - (cur_bay[-bay_line2+1] + cur_bay[-1] + cur_bay[3] + cur_bay[bay_line2+1]);
+			g = (2*(cur_bay[-bay_line+1] + cur_bay[0] + cur_bay[2] + cur_bay[bay_line+1]) + w) >> 3;
+			b = (2*(cur_bay[-bay_line] + cur_bay[-bay_line+2] + cur_bay[bay_line] + cur_bay[bay_line+2]) + w) >> 3;
+			qc_imag_writergb(cur_rgb+bpp, bpp, cur_bay[1], CLIP(g,0,255), CLIP(b,0,255));
+
+			w = 4*cur_bay[bay_line] - (cur_bay[-bay_line] + cur_bay[bay_line-2] + cur_bay[bay_line+2] + cur_bay[bay_line3]);
+			r = ((cur_bay[-1] + cur_bay[1] + cur_bay[bay_line2-1] + cur_bay[bay_line2+1]) + w) >> 2;
+			g = ((cur_bay[0] + cur_bay[bay_line-1] + cur_bay[bay_line+1] + cur_bay[bay_line2]) + w) >> 2;
+			qc_imag_writergb(cur_rgb+rgb_line, bpp, CLIP(r,0,255), CLIP(g,0,255), cur_bay[bay_line]);
+
+			w = 4*cur_bay[bay_line+1] - (cur_bay[0] + cur_bay[2] + cur_bay[bay_line2] + cur_bay[bay_line2+2]);
+			r = (2*(cur_bay[1] + cur_bay[bay_line2+1]) + w) >> 2;
+			b = (2*(cur_bay[bay_line] + cur_bay[bay_line+2]) + w) >> 2;
+			qc_imag_writergb(cur_rgb+rgb_line+bpp, bpp, CLIP(r,0,255), cur_bay[bay_line+1], CLIP(b,0,255));
+
+			cur_bay += 2;
+			cur_rgb += 2*bpp;
+		} while (--columns);
+
+		/* Process last 2x2 pixel block in a row here */
+		qc_imag_writergb(cur_rgb+0,            bpp, cur_bay[1], cur_bay[0],          cur_bay[bay_line]);
+		qc_imag_writergb(cur_rgb+bpp,          bpp, cur_bay[1], cur_bay[0],          cur_bay[bay_line]);
+		qc_imag_writergb(cur_rgb+rgb_line,     bpp, cur_bay[1], cur_bay[bay_line+1], cur_bay[bay_line]);
+		qc_imag_writergb(cur_rgb+rgb_line+bpp, bpp, cur_bay[1], cur_bay[bay_line+1], cur_bay[bay_line]);
+
+		bay += bay_line2;
+		rgb += rgb_line2;
+	} while (--rows);
+
+	/* Process last two pixel rows here */
+	cur_bay = bay;
+	cur_rgb = rgb;
+	columns = total_columns + 2;
+	do {
+		qc_imag_writergb(cur_rgb+0,            bpp, cur_bay[1], cur_bay[0],          cur_bay[bay_line]);
+		qc_imag_writergb(cur_rgb+bpp,          bpp, cur_bay[1], cur_bay[0],          cur_bay[bay_line]);
+		qc_imag_writergb(cur_rgb+rgb_line,     bpp, cur_bay[1], cur_bay[bay_line+1], cur_bay[bay_line]);
+		qc_imag_writergb(cur_rgb+rgb_line+bpp, bpp, cur_bay[1], cur_bay[bay_line+1], cur_bay[bay_line]);
+		cur_bay += 2;
+		cur_rgb += 2*bpp;
+	} while (--columns);
+}
+/* }}} */
+/* {{{ [fold] qc_imag_bay2rgb_gptm(unsigned char *bay, int bay_line, unsigned char *rgb, int rgb_line, int columns, int rows, int bpp, int sharpness) */
+/* Convert Bayer image to RGB image using Generalized Pei-Tam method (See:
+ * "Effective Color Interpolation in CCD Color Filter Arrays Using Signal Correlation"
+ * IEEE Transactions on Circuits and Systems for Video Technology, vol. 13, no. 6, June 2003.
+ * Note that this is much improved version of the algorithm described in the paper)
+ * bay = points to the bayer image data (upper left pixel is green)
+ * bay_line = bytes between the beginnings of two consecutive rows
+ * rgb = points to the rgb image data that is written
+ * rgb_line = bytes between the beginnings of two consecutive rows
+ * columns, rows = bayer image size (both must be even)
+ * bpp = number of bytes in each pixel in the RGB image (should be 3 or 4)
+ * sharpness = how sharp the image should be, between 0..65535 inclusive.
+ *             23170 gives in theory image that corresponds to the original
+ *             best, but human eye likes slightly sharper picture... 32768 is a good bet.
+ *             When sharpness = 0, this routine is same as bilinear interpolation.
+ */
+/* Execution time: 4344042 clock cycles for CIF image (Pentium II) */
+static inline void qc_imag_bay2rgb_gptm(unsigned char *bay, int bay_line,
+		   unsigned char *rgb, int rgb_line,
+		   int columns, int rows, int bpp, unsigned int sharpness)
+{
+
+	/* 0.8 fixed point weights, should be between 0-256. Larger value = sharper, zero corresponds to bilinear interpolation. */
+	/* Best PSNR with sharpness = 23170 */
+	static const int wrg0 = 144;		/* Weight for Red on Green */
+	static const int wbg0 = 160;
+	static const int wgr0 = 120;
+	static const int wbr0 = 192;
+	static const int wgb0 = 120;
+	static const int wrb0 = 168;
+
+	int wrg;
+	int wbg;
+	int wgr;
+	int wbr;
+	int wgb;
+	int wrb;
+
+	unsigned int wu;
+	int r,g,b,w;
+	unsigned char *cur_bay, *cur_rgb;
+	int bay_line2, bay_line3, rgb_line2;
+	int total_columns;
+
+	/* Compute weights */
+	wu = (sharpness * sharpness) >> 16;
+ 	wu = (wu * wu) >> 16;
+	wrg = (wrg0 * wu) >> 10;
+	wbg = (wbg0 * wu) >> 10;
+	wgr = (wgr0 * wu) >> 10;
+	wbr = (wbr0 * wu) >> 10;
+	wgb = (wgb0 * wu) >> 10;
+	wrb = (wrb0 * wu) >> 10;
+
+	/* Process 2 lines and rows per each iteration, but process the first and last two columns and rows separately */
+	total_columns = (columns>>1) - 2;
+	rows = (rows>>1) - 2;
+	bay_line2 = 2*bay_line;
+	bay_line3 = 3*bay_line;
+	rgb_line2 = 2*rgb_line;
+
+	/* Process first two pixel rows here */
+	cur_bay = bay;
+	cur_rgb = rgb;
+	columns = total_columns + 2;
+	do {
+		qc_imag_writergb(cur_rgb+0,            bpp, cur_bay[1], cur_bay[0],          cur_bay[bay_line]);
+		qc_imag_writergb(cur_rgb+bpp,          bpp, cur_bay[1], cur_bay[0],          cur_bay[bay_line]);
+		qc_imag_writergb(cur_rgb+rgb_line,     bpp, cur_bay[1], cur_bay[bay_line+1], cur_bay[bay_line]);
+		qc_imag_writergb(cur_rgb+rgb_line+bpp, bpp, cur_bay[1], cur_bay[bay_line+1], cur_bay[bay_line]);
+		cur_bay += 2;
+		cur_rgb += 2*bpp;
+	} while (--columns);
+	bay += bay_line2;
+	rgb += rgb_line2;
+
+	do {
+		cur_bay = bay;
+		cur_rgb = rgb;
+		columns = total_columns;
+		
+		/* Process first 2x2 pixel block in a row here */
+		qc_imag_writergb(cur_rgb+0,            bpp, cur_bay[1], cur_bay[0],          cur_bay[bay_line]);
+		qc_imag_writergb(cur_rgb+bpp,          bpp, cur_bay[1], cur_bay[0],          cur_bay[bay_line]);
+		qc_imag_writergb(cur_rgb+rgb_line,     bpp, cur_bay[1], cur_bay[bay_line+1], cur_bay[bay_line]);
+		qc_imag_writergb(cur_rgb+rgb_line+bpp, bpp, cur_bay[1], cur_bay[bay_line+1], cur_bay[bay_line]);
+		cur_bay += 2;
+		cur_rgb += 2*bpp;
+
+		do {
+			w = 4*cur_bay[0] - (cur_bay[-bay_line-1] + cur_bay[-bay_line+1] + cur_bay[bay_line-1] + cur_bay[bay_line+1]);
+			r = (512*(cur_bay[-1] + cur_bay[1]) + w*wrg) >> 10;
+			b = (512*(cur_bay[-bay_line] + cur_bay[bay_line]) + w*wbg) >> 10;
+			qc_imag_writergb(cur_rgb+0, bpp, CLIP(r,0,255), cur_bay[0], CLIP(b,0,255));
+
+			w = 4*cur_bay[1] - (cur_bay[-bay_line2+1] + cur_bay[-1] + cur_bay[3] + cur_bay[bay_line2+1]);
+			g = (256*(cur_bay[-bay_line+1] + cur_bay[0] + cur_bay[2] + cur_bay[bay_line+1]) + w*wgr) >> 10;
+			b = (256*(cur_bay[-bay_line] + cur_bay[-bay_line+2] + cur_bay[bay_line] + cur_bay[bay_line+2]) + w*wbr) >> 10;
+			qc_imag_writergb(cur_rgb+bpp, bpp, cur_bay[1], CLIP(g,0,255), CLIP(b,0,255));
+
+			w = 4*cur_bay[bay_line] - (cur_bay[-bay_line] + cur_bay[bay_line-2] + cur_bay[bay_line+2] + cur_bay[bay_line3]);
+			r = (256*(cur_bay[-1] + cur_bay[1] + cur_bay[bay_line2-1] + cur_bay[bay_line2+1]) + w*wrb) >> 10;
+			g = (256*(cur_bay[0] + cur_bay[bay_line-1] + cur_bay[bay_line+1] + cur_bay[bay_line2]) + w*wgb) >> 10;
+			qc_imag_writergb(cur_rgb+rgb_line, bpp, CLIP(r,0,255), CLIP(g,0,255), cur_bay[bay_line]);
+
+			w = 4*cur_bay[bay_line+1] - (cur_bay[0] + cur_bay[2] + cur_bay[bay_line2] + cur_bay[bay_line2+2]);
+			r = (512*(cur_bay[1] + cur_bay[bay_line2+1]) + w*wrg) >> 10;
+			b = (512*(cur_bay[bay_line] + cur_bay[bay_line+2]) + w*wbg) >> 10;
+			qc_imag_writergb(cur_rgb+rgb_line+bpp, bpp, CLIP(r,0,255), cur_bay[bay_line+1], CLIP(b,0,255));
+
+			cur_bay += 2;
+			cur_rgb += 2*bpp;
+		} while (--columns);
+
+		/* Process last 2x2 pixel block in a row here */
+		qc_imag_writergb(cur_rgb+0,            bpp, cur_bay[1], cur_bay[0],          cur_bay[bay_line]);
+		qc_imag_writergb(cur_rgb+bpp,          bpp, cur_bay[1], cur_bay[0],          cur_bay[bay_line]);
+		qc_imag_writergb(cur_rgb+rgb_line,     bpp, cur_bay[1], cur_bay[bay_line+1], cur_bay[bay_line]);
+		qc_imag_writergb(cur_rgb+rgb_line+bpp, bpp, cur_bay[1], cur_bay[bay_line+1], cur_bay[bay_line]);
+
+		bay += bay_line2;
+		rgb += rgb_line2;
+	} while (--rows);
+
+	/* Process last two pixel rows here */
+	cur_bay = bay;
+	cur_rgb = rgb;
+	columns = total_columns + 2;
+	do {
+		qc_imag_writergb(cur_rgb+0,            bpp, cur_bay[1], cur_bay[0],          cur_bay[bay_line]);
+		qc_imag_writergb(cur_rgb+bpp,          bpp, cur_bay[1], cur_bay[0],          cur_bay[bay_line]);
+		qc_imag_writergb(cur_rgb+rgb_line,     bpp, cur_bay[1], cur_bay[bay_line+1], cur_bay[bay_line]);
+		qc_imag_writergb(cur_rgb+rgb_line+bpp, bpp, cur_bay[1], cur_bay[bay_line+1], cur_bay[bay_line]);
+		cur_bay += 2;
+		cur_rgb += 2*bpp;
+	} while (--columns);
+}
+/* }}} */
+/* {{{ [fold] qc_imag_rgbbgr(unsigned char *dst, int pixels, int bpp) */
+/* Convert RGB image to BGR or vice versa with the given number of pixels and
+ * bytes per pixel
+ */
+static void inline qc_imag_rgbbgr(unsigned char *dst, int pixels, int bpp)
+{
+	unsigned char r,b;
+	do {
+		r = dst[0];
+		b = dst[2];
+		dst[0] = b;
+		dst[2] = r;
+		dst += bpp;
+	} while (--pixels);
+}
+/* }}} */
+
+/* }}} */
+/* {{{ [fold] **** qc_fmt:  Start of generic format query functions ********************** */
+
+/* {{{ [fold] struct qc_fmt_format: a format definition */
+struct qc_fmt_format {
+	u32 fcc;		/* M$ defined fourcc code, see http://www.fourcc.org */
+	signed char bpp;	/* 0=variable, -1=unknown (FIXME:what bpps do AVIs use here?) */
+	char order;		/* 'R' = RGB, 'B'=BGR, 0=not specified */
+	unsigned char nr, ng, nb;	/* Number of red, green, blue levels (0=256 levels) */
+	char *name;		/* Human-readable name */
+	Bool supported;		/* Can be converted to? */
+	/* Here we could add a pointer to list containing conversion routines to other fourcc's */
+	/* Then write code to create minimum spanning tree of format conversions */
+	/* Include estimated cost per pixel to apply a conversion routine to weight edges */
+};
+/* }}} */
+/* {{{ [fold] List of supported formats */
+#define BF_RGB(r,g,b)	'R', (b)&0xFF, (g)&0xFF, (r)&0xFF
+#define BF_BGR(r,g,b)	'B', (b)&0xFF, (g)&0xFF, (r)&0xFF
+#define NO_BF		0, 0, 0, 0
+#define FORMAT(ID,FCC1,FCC2,FCC3,FCC4,BPP,BF,NAME,SUPP) \
+static const struct qc_fmt_format qc_fmt_formats_##ID = { v4l2_fourcc(FCC1,FCC2,FCC3,FCC4), BPP, BF, NAME, SUPP }
+FORMAT(Y800,     'Y','8','0','0',   8, NO_BF,                 "GREY",   TRUE);
+FORMAT(RGB_HI,   'q','c','R','B',   8, BF_RGB(6, 6, 6),       "HI240",  FALSE);	/* Not sure: BF_RGB or BF_BGR? Same as BT20? Don't think so */
+FORMAT(RGB_332,  3,0,0,0,           8, BF_RGB(8, 8, 4),       "RGB332", FALSE);
+/* Little endian RGB formats (least significant byte at lowest address) */
+FORMAT(RGB_555L, 3,0,0,0,          16, BF_RGB(32, 32, 32),    "RGB555L",TRUE);	/* Should this be 15 or 16 bpp? Is this same as RGB2? */
+FORMAT(RGB_565L, 3,0,0,0,          16, BF_RGB(32, 64, 32),    "RGB565L",TRUE);	/* Is this same as RGB2? */
+FORMAT(RGB_24L,  'R','G','B','2',  24, BF_RGB(256, 256, 256), "RGB24L", TRUE);
+FORMAT(BGR_24L,  'R','G','B','2',  24, BF_BGR(256, 256, 256), "BGR24L", TRUE);
+FORMAT(RGB_32L,  'R','G','B','2',  32, BF_RGB(256, 256, 256), "RGB32L", TRUE);
+FORMAT(BGR_32L,  'R','G','B','2',  32, BF_BGR(256, 256, 256), "BGR32L", TRUE);
+/* Big endian RGB formats (most significant byte at lowest address) */
+FORMAT(RGB_555B, 'q','c','R','B',  16, BF_RGB(32, 32, 32),    "RGB555B",FALSE);
+FORMAT(RGB_565B, 'q','c','R','B',  16, BF_RGB(32, 64, 32),    "RGB565B",FALSE);
+/* Component YUV formats */
+FORMAT(YUY2,     'Y','U','Y','2',  16, NO_BF, "YUV422",    TRUE);		/* 4:2:2 packed pixel YUYV */
+FORMAT(UYVY,     'U','Y','V','Y',  16, NO_BF, "UYVY",      FALSE);
+FORMAT(IYUV,     'I','Y','U','V',  12, NO_BF, "YUV420",    FALSE);
+/* Planar YUV formats */
+FORMAT(YV12,     'Y','V','1','2',  12, NO_BF, "YV12",      FALSE);
+FORMAT(YVU9,     'Y','V','U','9',   9, NO_BF, "YVU9",      FALSE);
+FORMAT(Y41P,     'Y','4','1','P',  12, NO_BF, "Y41P",      FALSE);		/* 4:1:1 packed pixel UYVY UYVY YYYY */
+FORMAT(qcY1,     'q','c','Y','1',  12, NO_BF, "YUV411P",   FALSE);		/* Like Y41P but planar and Y, U and V planes are in this order */
+FORMAT(qcY2,     'q','c','Y','2',  16, NO_BF, "YUV422P",   TRUE);		/* Like YUY2 but planar */
+FORMAT(qcV1,     'q','c','V','1',  12, NO_BF, "YVU411P",   FALSE);		/* Like qcY1 but V and U planes are in this order */
+FORMAT(qcV2,     'q','c','V','2',  16, NO_BF, "YVU422P",   FALSE);		/* Like qcY2 but V and U planes are in this order */
+FORMAT(qcU9,     'q','c','U','9',   9, NO_BF, "YUV410P",   TRUE);		/* Like YVU9 but U and V planes are in this order */
+FORMAT(qcYY,     'q','c','Y','Y',  12, NO_BF, "YYUV",      FALSE);		/* Packed 4:2:2 sampling, Y, Y, U, V  */
+FORMAT(NV12,     'N','V','1','2',  12, NO_BF, "NV12",      FALSE);
+FORMAT(NV21,     'N','V','2','1',  12, NO_BF, "NV21",      FALSE);
+/* Special formats */
+FORMAT(qcBT,     'q','c','B','T',  -1, NO_BF, "BT848 RAW", FALSE);		/* RAW is raw scanline data sampled (before PAL decoding) */
+FORMAT(qcBR,     'q','c','B','R',   8, NO_BF, "BAYER",     TRUE);		/* Same as STVA? */
+FORMAT(qcMJ,     'q','c','M','J',   0, NO_BF, "MJPEG",     TRUE);		/* Same as MJPG? */
+FORMAT(qcWN,     'q','c','W','N',  -1, NO_BF, "Winnov hw", FALSE);		/* Same as WNV1 (or CHAM, WINX, YUV8)? */
+/* }}} */
+/* {{{ [fold] struct qc_fmt_alias: Alias fourcc codes for above formats */
+static struct qc_fmt_alias {
+	u32 fcc;
+	struct qc_fmt_format const *format;
+} const qc_fmt_aliases[] = {
+	{ v4l2_fourcc(0,0,0,0),         &qc_fmt_formats_RGB_24L },	/* Could be any format with fourcc 'RGB2' */
+	{ v4l2_fourcc('Y','8',' ',' '), &qc_fmt_formats_Y800 },
+	{ v4l2_fourcc('Y','U','N','V'), &qc_fmt_formats_YUY2 },
+	{ v4l2_fourcc('V','4','2','2'), &qc_fmt_formats_YUY2 },
+	{ v4l2_fourcc('Y','4','2','2'), &qc_fmt_formats_UYVY },
+	{ v4l2_fourcc('U','Y','N','V'), &qc_fmt_formats_UYVY },
+	{ v4l2_fourcc('I','4','2','0'), &qc_fmt_formats_IYUV },
+};
+/* }}} */
+/* {{{ [fold] struct qc_fmt_palette: table to convert V4L code into fourcc, supported formats */
+static struct qc_fmt_palette {
+	int palette;		/* V4L1 standard palette type */
+	struct qc_fmt_format const *format;
+} const qc_fmt_palettes[] = {
+ 	{ VIDEO_PALETTE_GREY,    &qc_fmt_formats_Y800 },
+	{ VIDEO_PALETTE_HI240,   &qc_fmt_formats_RGB_HI },
+	/* RGB formats */
+	{ VIDEO_PALETTE_RGB565,  &qc_fmt_formats_RGB_565L },
+	{ VIDEO_PALETTE_RGB24,   &qc_fmt_formats_BGR_24L },
+	{ VIDEO_PALETTE_RGB32,   &qc_fmt_formats_BGR_32L },
+	{ VIDEO_PALETTE_RGB555,  &qc_fmt_formats_RGB_555L },
+	/* Component YUV formats */
+	{ VIDEO_PALETTE_YUV422,  &qc_fmt_formats_YUY2 },	/* Assume this is YUY2, even though V4L1 docs say this is 8 bpp format */
+	{ VIDEO_PALETTE_YUYV,	 &qc_fmt_formats_YUY2 },	/* Benedict Bridgwater <bennyb@ntplx.net>: Bt848 maps this to Y41P, but it is simply wrong--we follow V4L2 v4l_compat.c */
+	{ VIDEO_PALETTE_UYVY,	 &qc_fmt_formats_UYVY },
+	{ VIDEO_PALETTE_YUV420,  &qc_fmt_formats_IYUV },	/* Assume this is planar, even though V4L1 header file indicates otherwise */
+	{ VIDEO_PALETTE_YUV411,  &qc_fmt_formats_qcY1 },	/* Assume this is planar, even though V4L1 header file indicates otherwise (could be also fourcc 'Y41P') -from benedict */
+	{ VIDEO_PALETTE_RAW,	 &qc_fmt_formats_qcBT },
+	/* Planar YUV formats */
+	{ VIDEO_PALETTE_YUV422P, &qc_fmt_formats_qcY2 },
+	{ VIDEO_PALETTE_YUV411P, &qc_fmt_formats_qcY1 },
+	{ VIDEO_PALETTE_YUV420P, &qc_fmt_formats_IYUV },
+	{ VIDEO_PALETTE_YUV410P, &qc_fmt_formats_qcU9 },
+	/* Special formats */
+	{ VIDEO_PALETTE_BAYER,   &qc_fmt_formats_qcBR },
+	{ VIDEO_PALETTE_MJPEG,   &qc_fmt_formats_qcMJ },
+};
+/* }}} */
+/* {{{ [fold] struct qc_fmt_v4l2: V4L2 defines its own conflicting format codes */
+static struct qc_fmt_v4l2 {
+	u32 v4l2code;
+	struct qc_fmt_format const *format;
+} const qc_fmt_v4l2s[] = {
+	{ v4l2_fourcc('R','G','B','1'), &qc_fmt_formats_RGB_332 },	/* V4L2_PIX_FMT_RGB332   8  RGB-3-3-2	  */
+	{ v4l2_fourcc('R','G','B','O'), &qc_fmt_formats_RGB_555L },	/* V4L2_PIX_FMT_RGB555  16  RGB-5-5-5	  */
+	{ v4l2_fourcc('R','G','B','P'), &qc_fmt_formats_RGB_565L },	/* V4L2_PIX_FMT_RGB565  16  RGB-5-6-5	  */
+	{ v4l2_fourcc('R','G','B','Q'), &qc_fmt_formats_RGB_555B },	/* V4L2_PIX_FMT_RGB555X 16  RGB-5-5-5 BE  */
+	{ v4l2_fourcc('R','G','B','R'), &qc_fmt_formats_RGB_565B },	/* V4L2_PIX_FMT_RGB565X 16  RGB-5-6-5 BE  */
+	{ v4l2_fourcc('B','G','R','3'), &qc_fmt_formats_BGR_24L },	/* V4L2_PIX_FMT_BGR24	24  BGR-8-8-8	  */
+	{ v4l2_fourcc('R','G','B','3'), &qc_fmt_formats_RGB_24L },	/* V4L2_PIX_FMT_RGB24	24  RGB-8-8-8	  */
+	{ v4l2_fourcc('B','G','R','4'), &qc_fmt_formats_BGR_32L },	/* V4L2_PIX_FMT_BGR32	32  BGR-8-8-8-8   */
+	{ v4l2_fourcc('R','G','B','4'), &qc_fmt_formats_RGB_32L },	/* V4L2_PIX_FMT_RGB32	32  RGB-8-8-8-8   */
+	{ v4l2_fourcc('G','R','E','Y'), &qc_fmt_formats_Y800 },		/* V4L2_PIX_FMT_GREY	 8  Greyscale	  */
+	{ v4l2_fourcc('Y','V','U','9'), &qc_fmt_formats_YVU9 },		/* V4L2_PIX_FMT_YVU410   9  YVU 4:1:0	  */
+	{ v4l2_fourcc('Y','V','1','2'), &qc_fmt_formats_YV12 },		/* V4L2_PIX_FMT_YVU420  12  YVU 4:2:0	  */
+	{ v4l2_fourcc('Y','U','Y','V'), &qc_fmt_formats_YUY2 },		/* V4L2_PIX_FMT_YUYV	16  YUV 4:2:2	  */
+	{ v4l2_fourcc('Y','U','Y','2'), &qc_fmt_formats_YUY2 },		/* V4L2_PIX_FMT_YUY2	16  YUV 4:2:2: undocumented, guess same as YUY2 */
+	{ v4l2_fourcc('U','Y','V','Y'), &qc_fmt_formats_UYVY },		/* V4L2_PIX_FMT_UYVY	16  YUV 4:2:2	  */
+	{ v4l2_fourcc('Y','4','1','P'), &qc_fmt_formats_Y41P },		/* V4L2_PIX_FMT_Y41P	12  YUV 4:1:1	  */
+	{ v4l2_fourcc('Y','U','V','9'), &qc_fmt_formats_qcU9 },		/* V4L2_PIX_FMT_YUV410   9  YUV 4:1:0	  */
+	{ v4l2_fourcc('Y','U','1','2'), &qc_fmt_formats_IYUV },		/* V4L2_PIX_FMT_YUV420  12  YUV 4:2:0	  */
+	{ v4l2_fourcc('P','4','2','2'), &qc_fmt_formats_qcY2 },		/* V4L2_PIX_FMT_YUV422P 16  YUV422 planar */
+	{ v4l2_fourcc('P','4','1','1'), &qc_fmt_formats_qcY1 },		/* V4L2_PIX_FMT_YUV411P 16  YUV411 planar: assume bpp should be 12  */
+	{ v4l2_fourcc('N','V','1','2'), &qc_fmt_formats_NV12 },		/* V4L2_PIX_FMT_NV12	12  Y/UV 4:2:0    */
+	{ v4l2_fourcc('4','2','2','P'), &qc_fmt_formats_qcV2 },		/* V4L2_PIX_FMT_YVU422P 16  YVU422 planar */
+	{ v4l2_fourcc('4','1','1','P'), &qc_fmt_formats_qcV1 },		/* V4L2_PIX_FMT_YVU411P 16  YVU411 planar: assume bpp should be 12 */
+	{ v4l2_fourcc('Y','Y','U','V'), &qc_fmt_formats_qcYY },		/* V4L2_PIX_FMT_YYUV	16  YUV 4:2:2: undocumented, guess this is qc YY */
+	{ v4l2_fourcc('H','I','2','4'), &qc_fmt_formats_RGB_HI },	/* V4L2_PIX_FMT_HI240	 8  8-bit color   */
+	{ v4l2_fourcc('N','V','2','1'), &qc_fmt_formats_NV21 },		/* V4L2_PIX_FMT_NV21	12  Y/UV 4:2:0    */
+	{ v4l2_fourcc('W','N','V','A'), &qc_fmt_formats_qcWN },		/* V4L2_PIX_FMT_WNVA	Winnov hw compres */
+};
+/* }}} */
+
+/* {{{ [fold] qc_fmt_issupported(int palette) */
+/* Check the format (can be called even before qc_fmt_init) */
+int qc_fmt_issupported(int palette)
+{
+	int i;
+	for (i=0; i<SIZE(qc_fmt_palettes); i++) {
+		if (qc_fmt_palettes[i].palette==palette && qc_fmt_palettes[i].format->supported)
+			return 0;
+	}
+	return -EINVAL;
+}
+/* }}} */
+/* {{{ [fold] qc_fmt_getname(int palette) */
+/* Return the format name (can be called even before qc_fmt_init) */
+const char *qc_fmt_getname(int palette)
+{
+	int i;
+	for (i=0; i<SIZE(qc_fmt_palettes); i++) {
+		if (qc_fmt_palettes[i].palette==palette)
+			return qc_fmt_palettes[i].format->name;
+	}
+	return "Unknown";
+}
+/* }}} */
+/* {{{ [fold] qc_fmt_getdepth(int palette) */
+/* Return bits per pixel for the format, or 
+ * 0=variable number (compressed formats), -1=unknown 
+ * (can be called even before qc_fmt_init) */
+int qc_fmt_getdepth(int palette)
+{
+	int i;
+	for (i=0; i<SIZE(qc_fmt_palettes); i++) {
+		if (qc_fmt_palettes[i].palette==palette)
+			return qc_fmt_palettes[i].format->bpp;
+	}
+	return -1;	/* Unknown bit depth */
+}
+/* }}} */
+/* {{{ [fold] qc_fmt_init(struct quickcam *qc) */
+int qc_fmt_init(struct quickcam *qc)
+{
+	int r = 0;
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_fmt_init(qc=%p/compr=%i)",qc,qc->settings.compress);
+#if COMPRESS
+	if (qc->settings.compress) {
+		qc->fmt_data.compress = TRUE;
+		r = qc_mjpeg_init(&qc->fmt_data.mjpeg_data, 24, DEFAULT_BGR);
+	} else {
+		qc->fmt_data.compress = FALSE;
+	}
+#endif
+	if (r>=0) IDEBUG_INIT(qc->fmt_data);
+	return r;
+}
+/* }}} */
+/* {{{ [fold] qc_fmt_exit(struct quickcam *qc) */
+void qc_fmt_exit(struct quickcam *qc)
+{
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_fmt_exit(qc=%p)",qc);
+#if COMPRESS
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_fmt_exit/compress=%i",qc->fmt_data.compress);
+	if (qc->fmt_data.compress) qc_mjpeg_exit(&qc->fmt_data.mjpeg_data);
+	POISON(qc->fmt_data.compress);
+	POISON(qc->fmt_data.mjpeg_data);
+#endif
+	POISON(qc->fmt_data.lut);
+	IDEBUG_EXIT_NOPOISON(qc->fmt_data);
+}
+/* }}} */
+/* {{{ [fold] qc_fmt_convert(struct quickcam *qc, unsigned char *src, unsigned int src_len, unsigned char *dst, unsigned int dst_len, int *midvalue) */
+/* Called after each full frame of bayer or compressed image obtained */
+/* Convert camera data in src to the application requested palette in dst */
+/* Return negative error code if failure, otherwise data length stored in dst */
+/* src_len is the length of actual data in src, dst_len is the maximum data size storable in dst */
+/* Also src buffer may be modified */
+/* Return image average brightness in midvalue (or -1 if not computed) */
+int qc_fmt_convert(struct quickcam *qc, unsigned char *src, unsigned int src_len, unsigned char *dst, unsigned int dst_len, int *midvalue)
+{
+	signed int originx, originy;	/* Upper-left corner coordinates of the capture window in the bayer image */
+	unsigned char *bayerwin;
+	int length;		/* Converted image data length in bytes */
+	int r = 0;
+
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_imag_convert(qc=%p,src=%p,src_len=%i,dst=%p,dst_len=%i)",qc,src,src_len,dst,dst_len);
+	if (PARANOID && (qc==NULL || src==NULL || dst==NULL)) { PRINTK(KERN_CRIT,"NULL"); return -EINVAL; }
+	if (PARANOID && midvalue==NULL) { PRINTK(KERN_CRIT,"NULL"); return -EINVAL; }
+	IDEBUG_TEST(qc->fmt_data);
+	*midvalue = -1;
+
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("sensor_width=%i sensor_height=%i vwin.width=%i vwin.height=%i",
+			qc->sensor_data.width,qc->sensor_data.height,qc->vwin.width,qc->vwin.height);
+
+	if (qc->sensor_data.width < qc->vwin.width || qc->sensor_data.height < qc->vwin.height) {
+		if (qcdebug&QC_DEBUGERRORS) PDEBUG("sensor window is smaller than requested");
+		r = -ENOMSG;
+		goto fail;
+	}
+
+#if DUMPDATA
+	if (midvalue) *midvalue = -1;
+	memset(dst, 0, dst_len);
+	memcpy(dst, src, src_len>dst_len ? dst_len : src_len);
+	length = (int)qc->vwin.width * (int)qc->vwin.height * 3;
+	return length;
+#endif
+
+#if COMPRESS
+	if (!qc->sensor_data.compress) {
+#endif
+		/* src buffer contains fixed length data in bayer format */
+		/* sensor_data.height/width = frame size that is captured from the camera */
+		/* vwin.height/width        = frame size that the application is expecting */
+
+		/* Check if src buffer contains enough data */
+		if (src_len < qc->sensor_data.width * qc->sensor_data.height) {
+			if (qcdebug&QC_DEBUGERRORS) PDEBUG("too little data by %i (expected %i)", qc->sensor_data.width*qc->sensor_data.height - src_len, qc->sensor_data.width * qc->sensor_data.height);
+			r = -EBADE;
+			goto fail;
+		}
+		/* calculate view window origin inside the whole frame */
+		originy = ((signed int)qc->sensor_data.height - (signed int)qc->vwin.height) / 2;
+		originx = ((signed int)qc->sensor_data.width - (signed int)qc->vwin.width) / 2;
+		originx &= ~1;		/* Set upper-left corner to a even coordinate */
+		originy &= ~1;		/* so that the first bayer pixel is green */
+		bayerwin = src + originy * qc->sensor_data.width + originx;
+		if (qcdebug&QC_DEBUGLOGIC) PDEBUG("originy=%i  originx=%i", originy,originx);
+
+		if (qc->settings.adaptive && midvalue!=NULL)
+			*midvalue = qc_imag_bayer_midvalue(bayerwin, qc->sensor_data.width, qc->vwin.width, qc->vwin.height);
+		if (qc->settings.equalize || qc->settings.userlut) {
+			if (qc->settings.equalize) {
+				qc_imag_bayer_equalize(bayerwin, qc->sensor_data.width, qc->vwin.width, qc->vwin.height, &qc->fmt_data.lut);
+			} else {
+				/* Initialize LUT */
+				int i;
+				for (i=0; i<256; i++) qc->fmt_data.lut[QC_LUT_RED+i]   = i;
+				for (i=0; i<256; i++) qc->fmt_data.lut[QC_LUT_GREEN+i] = i;
+				for (i=0; i<256; i++) qc->fmt_data.lut[QC_LUT_BLUE+i]  = i;
+			}
+			if (qc->settings.userlut) {
+				qc_imag_userlut(&qc->fmt_data.userlut, &qc->fmt_data.lut);
+			}
+			/* Could do here other effects to the lookup table */
+			qc_imag_bayer_lut(bayerwin, qc->sensor_data.width, qc->vwin.width, qc->vwin.height, &qc->fmt_data.lut);
+		}
+
+		if (qc->vpic.palette==VIDEO_PALETTE_BAYER) {
+			int i;
+			length = (int)qc->vwin.width * (int)qc->vwin.height;
+			if (length > dst_len) {
+				r = -ENOSPC;
+				goto fail;
+			}
+			/* It would be more efficient to capture data directly to the mmapped buffer,
+			 * but more complex and hardly any application will use bayer palette anyway */
+			for (i=0; i<qc->vwin.height; i++) {
+				memcpy(dst, bayerwin, qc->vwin.width);
+				bayerwin += qc->sensor_data.width;
+				dst += qc->vwin.width;
+			}
+		} else {
+			/* Convert the current frame to RGB */
+			length = (int)qc->vwin.width * (int)qc->vwin.height * 3;
+			if (length > dst_len) {
+				r = -ENOSPC;
+				goto fail;
+			}
+			switch (qc->settings.quality) {
+			case 0:
+				qc_imag_bay2rgb_cottnoip(bayerwin, qc->sensor_data.width,
+						dst, 3*qc->vwin.width, 
+						qc->vwin.width, qc->vwin.height, 3);
+				break;
+			case 1:
+				qc_imag_bay2rgb_cott(bayerwin, qc->sensor_data.width,
+						dst, 3*qc->vwin.width, 
+						qc->vwin.width, qc->vwin.height, 3);
+				break;
+			case 2:
+				qc_imag_bay2rgb_horip(bayerwin, qc->sensor_data.width,
+						dst, 3*qc->vwin.width, 
+						qc->vwin.width, qc->vwin.height, 3);
+				break;
+			case 3:
+				qc_imag_bay2rgb_ip(bayerwin, qc->sensor_data.width,
+						dst, 3*qc->vwin.width, 
+						qc->vwin.width, qc->vwin.height, 3);
+				break;
+			default:
+			case 4:
+				qc_imag_bay2rgb_gptm_fast(bayerwin, qc->sensor_data.width,
+						dst, 3*qc->vwin.width, 
+						qc->vwin.width, qc->vwin.height, 3);
+				break;
+			case 5:
+				qc_imag_bay2rgb_gptm(bayerwin, qc->sensor_data.width,
+						dst, 3*qc->vwin.width, 
+						qc->vwin.width, qc->vwin.height, 3, qc->vpic.whiteness);
+				break;
+			}
+			goto rgb24;
+		}
+
+#if COMPRESS
+	} else {
+		/* src buffer contains variable length data in mjpeg format */
+		if (qc->vpic.palette==VIDEO_PALETTE_MJPEG) {
+			/* Directly copy data from src to dst, can not resize */
+			length = src_len;
+			if (length > dst_len) {
+				r = -ENOSPC;
+				goto fail;
+			}
+			memcpy(dst, src, src_len);
+		} else {
+			/* Decode compressed images */
+			if (!qc->fmt_data.compress) {
+				r = -EINVAL;
+				goto fail;
+			}
+			length = qc->sensor_data.width * qc->sensor_data.height * 3;
+			if (length > dst_len) {
+				r = -ENOSPC;
+				goto fail;
+			}
+			r = qc_mjpeg_decode(&qc->fmt_data.mjpeg_data, src, src_len, dst);
+			if (r<0) goto fail;
+
+			if ((int)qc->vwin.width < qc->sensor_data.width || (int)qc->vwin.height < qc->sensor_data.height) {
+				/* User requested smaller image than camera sent, so crop the image */
+				unsigned char *s, *d = dst;
+				int i;
+				s = dst;
+				s += (qc->sensor_data.height - (int)qc->vwin.height)/2 * qc->sensor_data.width*3;
+				s += (qc->sensor_data.width - (int)qc->vwin.width)/2 * 3;
+				for (i=0; i<qc->vwin.height; i++) {
+					memcpy(d, s, (int)qc->vwin.width*3);
+					s += qc->sensor_data.width * 3;
+					d += (int)qc->vwin.width * 3;
+				}
+				/* vwin.width/height is always smaller or equal to sensor_data.width/height */
+				length = (int)qc->vwin.width * (int)qc->vwin.height * 3;
+			}
+			if (qc->settings.adaptive && midvalue!=NULL) *midvalue = qc_imag_rgb24_midvalue(dst, 3*qc->sensor_data.width, (int)qc->vwin.width, (int)qc->vwin.height);
+			goto rgb24;
+		}
+	}
+#endif
+	return length;
+
+rgb24:	/* We have now RGB (24 bpp) data in dst. If some other format is desired, */
+	/* convert the RGB image to it (e.g. YUV) */
+
+#ifdef DEBUG
+#if 1
+{
+/* Draw red rectangle around image (useful for debugging boundaries) */
+static const int R = 255;
+static const int G = 0;
+static const int B = 0;
+ int ty,tx;
+ for (tx=0; tx<qc->vwin.width; tx++) {
+  ty=0;
+  dst[ty*qc->vwin.width*3+tx*3] = B;
+  dst[ty*qc->vwin.width*3+tx*3+1] = G;
+  dst[ty*qc->vwin.width*3+tx*3+2] = R;
+  ty=qc->vwin.height-1;
+  dst[ty*qc->vwin.width*3+tx*3] = B;
+  dst[ty*qc->vwin.width*3+tx*3+1] = G;
+  dst[ty*qc->vwin.width*3+tx*3+2] = R;
+ }
+ for (ty=0; ty<qc->vwin.height; ty++) {
+  tx=0;
+  dst[ty*qc->vwin.width*3+tx*3] = B;
+  dst[ty*qc->vwin.width*3+tx*3+1] = G;
+  dst[ty*qc->vwin.width*3+tx*3+2] = R;
+  tx=qc->vwin.width-1;
+  dst[ty*qc->vwin.width*3+tx*3] = B;
+  dst[ty*qc->vwin.width*3+tx*3+1] = G;
+  dst[ty*qc->vwin.width*3+tx*3+2] = R;
+ }
+}
+#endif
+#endif
+
+	if (qc->vpic.palette != VIDEO_PALETTE_RGB24) {
+		// FIXME: should check here that dst_len <= resulted image length
+		length = qc_yuv_rgb2yuv(dst, length, qc->vpic.palette);
+	} else if (qc->settings.compat_torgb) {
+		qc_imag_rgbbgr(dst, length/3, 3);
+	}
+	return length;
+
+fail:	if (qcdebug&(QC_DEBUGERRORS|QC_DEBUGLOGIC)) PDEBUG("failed qc_imag_convert()=%i",r);
+	return r;
+}
+/* }}} */
+
+/* }}} */
+
+/* End of file */
diff -purN linux-2.6.10.orig/drivers/usb/media/qc/qc-hdcs.c linux-2.6.10-qc-usb/drivers/usb/media/qc/qc-hdcs.c
--- linux-2.6.10.orig/drivers/usb/media/qc/qc-hdcs.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-qc-usb/drivers/usb/media/qc/qc-hdcs.c	2005-01-07 14:55:46.300226092 +0100
@@ -0,0 +1,738 @@
+/* Start of file */
+
+/* {{{ [fold] Comments */
+/*
+ * qc-usb, linux V4L driver for the Logitech QuickCam USB camera family
+ *
+ * qc-hdcs.c - HDCS Sensor Implementation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+/* }}} */
+
+#ifdef NOKERNEL
+#include "quickcam.h"
+#else
+#include <linux/quickcam.h>
+#endif
+
+/* LSB bit of I2C or register address signifies write (0) or read (1) */
+
+/* I2C Address */
+#define HDCS_ADDR 	(0x55<<1)
+ 
+/* {{{ [fold] I2C registers */
+/* I2C Registers common for both HDCS-1000/1100 and HDCS-1020 */
+#define HDCS_IDENT	(0x00<<1)	/* Identifications Register */
+#define HDCS_STATUS	(0x01<<1)	/* Status Register */
+#define HDCS_IMASK	(0x02<<1)	/* Interrupt Mask Register */
+#define HDCS_PCTRL	(0x03<<1)	/* Pad Control Register */
+#define HDCS_PDRV	(0x04<<1)	/* Pad Drive Control Register */
+#define HDCS_ICTRL	(0x05<<1)	/* Interface Control Register */
+#define HDCS_ITMG	(0x06<<1)	/* Interface Timing Register */
+#define HDCS_BFRAC	(0x07<<1)	/* Baud Fraction Register */
+#define HDCS_BRATE	(0x08<<1)	/* Baud Rate Register */
+#define HDCS_ADCCTRL	(0x09<<1)	/* ADC Control Register */
+#define HDCS_FWROW	(0x0A<<1)	/* First Window Row Register */
+#define HDCS_FWCOL	(0x0B<<1)	/* First Window Column Register */
+#define HDCS_LWROW	(0x0C<<1)	/* Last Window Row Register */
+#define HDCS_LWCOL	(0x0D<<1)	/* Last Window Column Register */
+#define HDCS_TCTRL	(0x0E<<1)	/* Timing Control Register */
+#define HDCS_ERECPGA	(0x0F<<1)	/* PGA Gain Register: Even Row, Even Column */
+#define HDCS_EROCPGA	(0x10<<1)	/* PGA Gain Register: Even Row, Odd Column */
+#define HDCS_ORECPGA	(0x11<<1)	/* PGA Gain Register: Odd Row, Even Column */
+#define HDCS_OROCPGA	(0x12<<1)	/* PGA Gain Register: Odd Row, Odd Column */
+#define HDCS_ROWEXPL	(0x13<<1)	/* Row Exposure Low Register */
+#define HDCS_ROWEXPH	(0x14<<1)	/* Row Exposure High Register */
+
+/* I2C Registers only for HDCS-1000/1100 */
+#define HDCS00_SROWEXPL	(0x15<<1)	/* Sub-Row Exposure Low Register */
+#define HDCS00_SROWEXPH	(0x16<<1)	/* Sub-Row Exposure High Register */
+#define HDCS00_CONFIG	(0x17<<1)	/* Configuration Register */
+#define HDCS00_CONTROL	(0x18<<1)	/* Control Register */
+
+/* I2C Registers only for HDCS-1020 */
+#define HDCS20_SROWEXP	(0x15<<1)	/* Sub-Row Exposure Register	*/
+#define HDCS20_ERROR	(0x16<<1)	/* Error Control Register 	*/
+#define HDCS20_ITMG2	(0x17<<1)	/* Interface Timing 2 Register	*/
+#define HDCS20_ICTRL2	(0x18<<1)	/* Interface Control 2 Register	*/
+#define HDCS20_HBLANK	(0x19<<1)	/* Horizontal Blank Register	*/
+#define HDCS20_VBLANK	(0x1A<<1)	/* Vertical Blank Register	*/
+#define HDCS20_CONFIG	(0x1B<<1)	/* Configuration Register 	*/
+#define HDCS20_CONTROL	(0x1C<<1)	/* Control Register		*/
+/* }}} */
+
+#define IS_870(qc)	(GET_PRODUCTID(qc)==0x870)
+#define IS_1020(qc)	((qc)->sensor_data.sensor->flag != 0)
+#define GET_CONTROL	(IS_1020(qc) ? HDCS20_CONTROL : HDCS00_CONTROL)
+#define GET_CONFIG	(IS_1020(qc) ? HDCS20_CONFIG : HDCS00_CONFIG)
+
+#define I2C_SET_CHECK(reg,val)	if ((r = qc_i2c_set(qc,(reg),(val)))<0) goto fail
+#define STV_SET_CHECK(reg,val)	if ((r = qc_stv_set(qc,(reg),(val)))<0) goto fail
+#define STV_SETW_CHECK(reg,val)	if ((r = qc_stv_setw(qc,(reg),(val)))<0) goto fail
+
+/* Enables experimental compressed mode, works with HDCS-1000/0x840,
+   mode derived from USB logs obtained from HDCS-1020/0x870
+   (should give 640x480), not tested with HDCS-1020.
+   On HDCS-1000, gives 30 fps but data is in unknown format,
+   observed image width 163 bytes (how many pixels?).
+   Frame length appears to vary, typically 3300-4550 bytes.
+   (apparently quite simple, however).
+    Use this with DUMPDATA mode. */
+#define HDCS_COMPRESS 0
+
+#if HDCS_COMPRESS
+/* {{{ [fold] hdcs_compress_init(struct quickcam *qc, int flags) */
+static int hdcs_compress_init(struct quickcam *qc, int flags)
+{
+	int r;
+
+	if (flags & 1) {
+	/************************************** Plugin camera **************************************/
+
+	STV_SET_CHECK(0x1440, 0x00);							/* Turn on/off isochronous stream */
+	// if ((r = qc_stv_getw(qc, 0xE00A)) != 0x0870)					/* ProductId */
+	//	PDEBUG("Bad value 0x%02X in reg 0xE00A, should be 0x0870", r);
+
+	STV_SET_CHECK(0x0423, 0x05);							/* Unknown (sometimes 4, sometimes 5) */
+	// Warning: I2C address 0xBA is invalid
+	// if ((r = qc_get_i2c(qc, qc->sensor_data.sensor, HDCS_IDENT))<0)		/* Identifications Register */
+	//	PDEBUG("error reading sensor reg HDCS_IDENT");
+	// if ((r = qc_stv_get(qc, 0x0424)) != 0x0a)					/* Successfully transmitted I2C commands */
+	//	PDEBUG("Bad value 0x%02X in reg 0x0424, should be 0x0a", r);
+	STV_SET_CHECK(0x0423, 0x04);							/* Unknown (sometimes 4, sometimes 5) */
+
+	if ((r = qc_stv_get(qc, 0x1444)) != 0x10)					/* ? */
+		PDEBUG("Bad value 0x%02X in reg 0x1444, should be 0x10", r);
+	if ((r = qc_stv_get(qc, 0x1444)) != 0x10)					/* ? */
+		PDEBUG("Bad value 0x%02X in reg 0x1444, should be 0x10", r);
+	if ((r = qc_stv_get(qc, 0x1444)) != 0x10)					/* ? */
+		PDEBUG("Bad value 0x%02X in reg 0x1444, should be 0x10", r);
+
+	STV_SET_CHECK(0x0423, 0x05);							/* Unknown (sometimes 4, sometimes 5) */
+	// Warning: I2C address 0x20 is invalid
+	// if ((r = qc_get_i2c(qc, qc->sensor_data.sensor, HDCS_IDENT))<0)		/* Identifications Register */
+	//	PDEBUG("error reading sensor reg HDCS_IDENT");
+	// if ((r = qc_get_i2c(qc, qc->sensor_data.sensor, HDCS_IDENT))<0)		/* Identifications Register */
+	//	PDEBUG("error reading sensor reg HDCS_IDENT");
+	// if ((r = qc_stv_get(qc, 0x0424)) != 0x0a)					/* Successfully transmitted I2C commands */
+	//	PDEBUG("Bad value 0x%02X in reg 0x0424, should be 0x0a", r);
+	// Warning: I2C address 0x20 is invalid
+	// if ((r = qc_get_i2c(qc, qc->sensor_data.sensor, HDCS_IDENT))<0)		/* Identifications Register */
+	//	PDEBUG("error reading sensor reg HDCS_IDENT");
+	// if ((r = qc_get_i2c(qc, qc->sensor_data.sensor, HDCS_IDENT))<0)		/* Identifications Register */
+	//	PDEBUG("error reading sensor reg HDCS_IDENT");
+	// if ((r = qc_stv_get(qc, 0x0424)) != 0x0a)					/* Successfully transmitted I2C commands */
+	//	PDEBUG("Bad value 0x%02X in reg 0x0424, should be 0x0a", r);
+	// Warning: I2C address 0x20 is invalid
+	// if ((r = qc_get_i2c(qc, qc->sensor_data.sensor, HDCS_IDENT))<0)		/* Identifications Register */
+	//	PDEBUG("error reading sensor reg HDCS_IDENT");
+	// if ((r = qc_get_i2c(qc, qc->sensor_data.sensor, HDCS_IDENT))<0)		/* Identifications Register */
+	//	PDEBUG("error reading sensor reg HDCS_IDENT");
+	// if ((r = qc_stv_get(qc, 0x0424)) != 0x0a)					/* Successfully transmitted I2C commands */
+	//	PDEBUG("Bad value 0x%02X in reg 0x0424, should be 0x0a", r);
+	STV_SET_CHECK(0x0423, 0x04);							/* Unknown (sometimes 4, sometimes 5) */
+	STV_SET_CHECK(0x0423, 0x04);							/* Unknown (sometimes 4, sometimes 5) */
+
+	// if ((r = qc_get_i2c(qc, qc->sensor_data.sensor, HDCS_IDENT))<0)		/* Identifications Register */
+	//	PDEBUG("error reading sensor reg HDCS_IDENT");
+	// if ((r = qc_stv_get(qc, 0x0424)) != 0x02)					/* Successfully transmitted I2C commands */
+	//	PDEBUG("Bad value 0x%02X in reg 0x0424, should be 0x02", r);
+	// if ((r = qc_stv_get(qc, 0x1410)) != 0x10)					/* I2C area, first reg value */
+	//	PDEBUG("Bad value 0x%02X in reg 0x1410, should be 0x10", r);
+
+	// if ((r = qc_get_i2c(qc, qc->sensor_data.sensor, HDCS_IDENT))<0)		/* Identifications Register */
+	//	PDEBUG("error reading sensor reg HDCS_IDENT");
+	// if ((r = qc_stv_get(qc, 0x0424)) != 0x02)					/* Successfully transmitted I2C commands */
+	//	PDEBUG("Bad value 0x%02X in reg 0x0424, should be 0x02", r);
+	// if ((r = qc_stv_get(qc, 0x1410)) != 0x10)					/* I2C area, first reg value */
+	//	PDEBUG("Bad value 0x%02X in reg 0x1410, should be 0x10", r);
+
+	STV_SET_CHECK(0x0423, 0x04);							/* Unknown (sometimes 4, sometimes 5) */
+	if ((r = qc_stv_get(qc, 0x0424)) != 0x02)					/* Successfully transmitted I2C commands */
+		PDEBUG("Bad value 0x%02X in reg 0x0424, should be 0x02", r);
+	STV_SET_CHECK(0x0423, 0x04);							/* Unknown (sometimes 4, sometimes 5) */
+
+	// if ((r = qc_get_i2c(qc, qc->sensor_data.sensor, HDCS_IDENT))<0)		/* Identifications Register */
+	//	PDEBUG("error reading sensor reg HDCS_IDENT");
+	// if ((r = qc_stv_get(qc, 0x0424)) != 0x02)					/* Successfully transmitted I2C commands */
+	//	PDEBUG("Bad value 0x%02X in reg 0x0424, should be 0x02", r);
+	// if ((r = qc_stv_get(qc, 0x1410)) != 0x10)					/* I2C area, first reg value */
+	//	PDEBUG("Bad value 0x%02X in reg 0x1410, should be 0x10", r);
+
+	// if ((r = qc_get_i2c(qc, qc->sensor_data.sensor, HDCS_IDENT))<0)		/* Identifications Register */
+	//	PDEBUG("error reading sensor reg HDCS_IDENT");
+	// if ((r = qc_stv_get(qc, 0x0424)) != 0x02)					/* Successfully transmitted I2C commands */
+	//	PDEBUG("Bad value 0x%02X in reg 0x0424, should be 0x02", r);
+	// if ((r = qc_stv_get(qc, 0x1410)) != 0x10)					/* I2C area, first reg value */
+	//	PDEBUG("Bad value 0x%02X in reg 0x1410, should be 0x10", r);
+
+	STV_SET_CHECK(0x1500, 0x1D);							/* ? */
+	if ((r = qc_stv_get(qc, 0x1443)) != 0x00)					/* Scan rate? */
+		PDEBUG("Bad value 0x%02X in reg 0x1443, should be 0x00", r);
+	STV_SET_CHECK(0x1443, 0x01);							/* Scan rate? */
+	if ((r = qc_stv_get(qc, 0x1443)) != 0x01)					/* Scan rate? */
+		PDEBUG("Bad value 0x%02X in reg 0x1443, should be 0x01", r);
+	STV_SET_CHECK(0x1443, 0x00);							/* Scan rate? */
+
+	I2C_SET_CHECK(HDCS_PCTRL, 0x63);						/* Pad Control Register */
+	I2C_SET_CHECK(HDCS_PDRV, 0x00);							/* Pad Drive Control Register */
+	I2C_SET_CHECK(GET_CONFIG, 0x08);						/* Configuration Register */
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+	I2C_SET_CHECK(GET_CONTROL, 0x04);						/* Control Register */
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+	I2C_SET_CHECK(GET_CONTROL, 0x00);						/* Control Register */
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+	STV_SET_CHECK(0x1446, 0x00);							/* ? */
+	I2C_SET_CHECK(HDCS_PCTRL, 0x63);						/* Pad Control Register */
+	I2C_SET_CHECK(HDCS_PDRV, 0x00);							/* Pad Drive Control Register */
+	I2C_SET_CHECK(GET_CONFIG, 0x08);						/* Configuration Register */
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+	if ((r = qc_stv_get(qc, 0x1445)) != 0x04)					/* Turn LED on/off? */
+		PDEBUG("Bad value 0x%02X in reg 0x1445, should be 0x04", r);
+	I2C_SET_CHECK(HDCS_ERECPGA, 0x3B);						/* PGA Gain Register: Even Row, Even Column */
+	I2C_SET_CHECK(HDCS_EROCPGA, 0x3B);						/* PGA Gain Register: Even Row, Odd Column */
+	I2C_SET_CHECK(HDCS_ORECPGA, 0x3B);						/* PGA Gain Register: Odd Row, Even Column */
+	I2C_SET_CHECK(HDCS_OROCPGA, 0x3B);						/* PGA Gain Register: Odd Row, Odd Column */
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+	STV_SET_CHECK(0x1504, 0x07);							/* ? */
+	STV_SET_CHECK(0x1503, 0x45);							/* ? */
+	if ((r = qc_stv_get(qc, 0x1500)) != 0x1d)					/* ? */
+		PDEBUG("Bad value 0x%02X in reg 0x1500, should be 0x1d", r);
+	STV_SET_CHECK(0x1500, 0x1D);							/* ? */
+	// if ((r = qc_stv_getw(qc, 0xE00A)) != 0x0870)					/* ProductId */
+	//	PDEBUG("Bad value 0x%02X in reg 0xE00A, should be 0x0870", r);
+	}
+	
+	if (flags & 2) {
+	/************************************** Start grabbing **************************************/
+
+	// if ((r = qc_stv_getw(qc, 0xE00A)) != 0x0870)					/* ProductId */
+	//	PDEBUG("Bad value 0x%02X in reg 0xE00A, should be 0x0870", r);
+	STV_SET_CHECK(0x0423, 0x04);							/* Unknown (sometimes 4, sometimes 5) */
+	STV_SET_CHECK(0x1500, 0x1D);							/* ? */
+	I2C_SET_CHECK(HDCS_PCTRL, 0x63);						/* Pad Control Register */
+	I2C_SET_CHECK(HDCS_PDRV, 0x00);							/* Pad Drive Control Register */
+	I2C_SET_CHECK(GET_CONFIG, 0x08);						/* Configuration Register */
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+	STV_SET_CHECK(0x15C3, 0x02);							/* Y-Control, 1: 288 lines, 2: 144 lines */
+	STV_SETW_CHECK(0x15C1, 0x027B);							/* Max. ISO packet size */
+	I2C_SET_CHECK(HDCS_FWROW, 0x00);						/* First Window Row Register */
+	I2C_SET_CHECK(HDCS_FWCOL, 0x0B);						/* First Window Column Register */
+	I2C_SET_CHECK(HDCS_LWROW, 0x3D);						/* Last Window Row Register */
+	I2C_SET_CHECK(HDCS_LWCOL, 0x5A);						/* Last Window Column Register */
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+	STV_SET_CHECK(0x1680, 0x00);							/* X-Control, 0xa: 352 columns, 6: 176 columns */
+	I2C_SET_CHECK(HDCS_TCTRL, IS_1020(qc) ? 0xCB : 0x6B);				/* Timing Control Register */
+	I2C_SET_CHECK(HDCS_ICTRL, 0x00);						/* Interface Control Register */
+	I2C_SET_CHECK(HDCS_ITMG, 0x16);							/* Interface Timing Register */
+	if (IS_1020(qc)) I2C_SET_CHECK(HDCS20_HBLANK, 0xD6);				/* Horizontal Blank Register */
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+	STV_SET_CHECK(0x1446, 0x00);							/* ? */
+	if ((r = qc_stv_get(qc, 0x1446)) != 0x00)					/* ? */
+		PDEBUG("Bad value 0x%02X in reg 0x1446, should be 0x00", r);
+	STV_SET_CHECK(0x1446, 0x00);							/* ? */
+	I2C_SET_CHECK(HDCS_ROWEXPL, 0x7B);						/* Row Exposure Low Register */
+	I2C_SET_CHECK(HDCS_ROWEXPH, 0x00);						/* Row Exposure High Register */
+	if (IS_1020(qc)) {
+		I2C_SET_CHECK(HDCS20_SROWEXP, 0x01);					/* Sub-Row Exposure Register */
+	} else {
+		I2C_SET_CHECK(HDCS00_SROWEXPL, 0x01<<2);
+		I2C_SET_CHECK(HDCS00_SROWEXPH, 0x00);
+	}
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+	STV_SET_CHECK(0x1501, 0xC2);							/* ? */
+	STV_SET_CHECK(0x1502, 0xB0);							/* ? */
+	I2C_SET_CHECK(HDCS_PCTRL, 0x63);						/* Pad Control Register */
+	I2C_SET_CHECK(HDCS_PDRV, 0x00);							/* Pad Drive Control Register */
+	I2C_SET_CHECK(GET_CONFIG, 0x08);						/* Configuration Register */
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+
+	/* Start isochronous streaming */
+	I2C_SET_CHECK(GET_CONTROL, 0x04);						/* Control Register */
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+	STV_SET_CHECK(0x1440, 0x01);							/* Turn on/off isochronous stream */
+
+	if ((r = qc_stv_get(qc, 0x1445)) != 0x04)					/* Turn LED on/off? */
+		PDEBUG("Bad value 0x%02X in reg 0x1445, should be 0x04", r);
+	if ((r = qc_stv_get(qc, 0x1445)) != 0x04)					/* Turn LED on/off? */
+		PDEBUG("Bad value 0x%02X in reg 0x1445, should be 0x04", r);
+	if ((r = qc_stv_get(qc, 0x1445)) != 0x04)					/* Turn LED on/off? */
+		PDEBUG("Bad value 0x%02X in reg 0x1445, should be 0x04", r);
+
+	/* Stop isochronous streaming */
+	STV_SET_CHECK(0x1440, 0x00);							/* Turn on/off isochronous stream */
+	I2C_SET_CHECK(GET_CONTROL, 0x00);						/* Control Register */
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+
+	STV_SET_CHECK(0x0423, 0x04);							/* Unknown (sometimes 4, sometimes 5) */
+	STV_SET_CHECK(0x1500, 0x1D);							/* ? */
+	I2C_SET_CHECK(HDCS_PCTRL, 0x63);						/* Pad Control Register */
+	I2C_SET_CHECK(HDCS_PDRV, 0x00);							/* Pad Drive Control Register */
+	I2C_SET_CHECK(GET_CONFIG, 0x08);						/* Configuration Register */
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+	STV_SET_CHECK(0x15C3, 0x02);							/* Y-Control, 1: 288 lines, 2: 144 lines */
+	STV_SETW_CHECK(0x15C1, 0x027B);							/* Max. ISO packet size */
+	I2C_SET_CHECK(HDCS_FWROW, 0x00);						/* First Window Row Register */
+	I2C_SET_CHECK(HDCS_FWCOL, 0x0B);						/* First Window Column Register */
+	I2C_SET_CHECK(HDCS_LWROW, 0x3D);						/* Last Window Row Register */
+	I2C_SET_CHECK(HDCS_LWCOL, 0x5A);						/* Last Window Column Register */
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+	STV_SET_CHECK(0x1680, 0x00);							/* X-Control, 0xa: 352 columns, 6: 176 columns */
+	I2C_SET_CHECK(HDCS_TCTRL, IS_1020(qc) ? 0xCB : 0x6B);				/* Timing Control Register */
+	I2C_SET_CHECK(HDCS_ICTRL, 0x00);						/* Interface Control Register */
+	I2C_SET_CHECK(HDCS_ITMG, 0x16);							/* Interface Timing Register */
+	if (IS_1020(qc)) I2C_SET_CHECK(HDCS20_HBLANK, 0xD6);				/* Horizontal Blank Register */
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+	STV_SET_CHECK(0x1446, 0x00);							/* ? */
+	if ((r = qc_stv_get(qc, 0x1446)) != 0x00)					/* ? */
+		PDEBUG("Bad value 0x%02X in reg 0x1446, should be 0x00", r);
+	STV_SET_CHECK(0x1446, 0x00);							/* ? */
+	I2C_SET_CHECK(HDCS_ROWEXPL, 0x7B);						/* Row Exposure Low Register */
+	I2C_SET_CHECK(HDCS_ROWEXPH, 0x00);						/* Row Exposure High Register */
+	if (IS_1020(qc)) {
+		I2C_SET_CHECK(HDCS20_SROWEXP, 0x01);					/* Sub-Row Exposure Register */
+	} else {
+		I2C_SET_CHECK(HDCS00_SROWEXPL, 0x01<<2);
+		I2C_SET_CHECK(HDCS00_SROWEXPH, 0x00);
+	}
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+	STV_SET_CHECK(0x1501, 0xC2);							/* ? */
+	STV_SET_CHECK(0x1502, 0xB0);							/* ? */
+	I2C_SET_CHECK(HDCS_PCTRL, 0x63);						/* Pad Control Register */
+	I2C_SET_CHECK(HDCS_PDRV, 0x00);							/* Pad Drive Control Register */
+	I2C_SET_CHECK(GET_CONFIG, 0x08);						/* Configuration Register */
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+
+	/* Start isochronous streaming */
+	I2C_SET_CHECK(GET_CONTROL, 0x04);						/* Control Register */
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+	if ((r = qc_stv_get(qc, 0x1445)) != 0x04)					/* Turn LED on/off? */
+		PDEBUG("Bad value 0x%02X in reg 0x1445, should be 0x04", r);
+	STV_SET_CHECK(0x1440, 0x01);							/* Turn on/off isochronous stream */
+
+	/* Stop isochronous streaming */
+	STV_SET_CHECK(0x1440, 0x00);							/* Turn on/off isochronous stream */
+	I2C_SET_CHECK(GET_CONTROL, 0x00);						/* Control Register */
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+
+	STV_SET_CHECK(0x0423, 0x04);							/* Unknown (sometimes 4, sometimes 5) */
+	STV_SET_CHECK(0x1500, 0x1D);							/* ? */
+	I2C_SET_CHECK(HDCS_PCTRL, 0x63);						/* Pad Control Register */
+	I2C_SET_CHECK(HDCS_PDRV, 0x00);							/* Pad Drive Control Register */
+	I2C_SET_CHECK(GET_CONFIG, 0x08);						/* Configuration Register */
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+	STV_SET_CHECK(0x15C3, 0x02);							/* Y-Control, 1: 288 lines, 2: 144 lines */
+	STV_SETW_CHECK(0x15C1, 0x0230);							/* Max. ISO packet size */
+	I2C_SET_CHECK(HDCS_FWROW, 0x00);						/* First Window Row Register */
+	I2C_SET_CHECK(HDCS_FWCOL, 0x07);						/* First Window Column Register */
+	I2C_SET_CHECK(HDCS_LWROW, 0x49);						/* Last Window Row Register */
+	I2C_SET_CHECK(HDCS_LWCOL, 0x5E);						/* Last Window Column Register */
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+	STV_SET_CHECK(0x1680, 0x00);							/* X-Control, 0xa: 352 columns, 6: 176 columns */
+	I2C_SET_CHECK(HDCS_TCTRL, IS_1020(qc) ? 0xCE : 0x6E);				/* Timing Control Register */
+	I2C_SET_CHECK(HDCS_ICTRL, 0x00);						/* Interface Control Register */
+	I2C_SET_CHECK(HDCS_ITMG, 0x16);							/* Interface Timing Register */
+	if (IS_1020(qc)) I2C_SET_CHECK(HDCS20_HBLANK, 0xCF);				/* Horizontal Blank Register */
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+	STV_SET_CHECK(0x1446, 0x00);							/* ? */
+	if ((r = qc_stv_get(qc, 0x1446)) != 0x00)					/* ? */
+		PDEBUG("Bad value 0x%02X in reg 0x1446, should be 0x00", r);
+	STV_SET_CHECK(0x1446, 0x00);							/* ? */
+	I2C_SET_CHECK(HDCS_ROWEXPL, 0x62);						/* Row Exposure Low Register */
+	I2C_SET_CHECK(HDCS_ROWEXPH, 0x00);						/* Row Exposure High Register */
+	if (IS_1020(qc)) {
+		I2C_SET_CHECK(HDCS20_SROWEXP, 0x1A);					/* Sub-Row Exposure Register */
+	} else {
+		I2C_SET_CHECK(HDCS00_SROWEXPL, 0x1A<<2);
+		I2C_SET_CHECK(HDCS00_SROWEXPH, 0x00);
+	}
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+	STV_SET_CHECK(0x1501, 0xB6);							/* ? */
+	STV_SET_CHECK(0x1502, 0xA8);							/* ? */
+	I2C_SET_CHECK(HDCS_PCTRL, 0x63);						/* Pad Control Register */
+	I2C_SET_CHECK(HDCS_PDRV, 0x00);							/* Pad Drive Control Register */
+	I2C_SET_CHECK(GET_CONFIG, 0x08);						/* Configuration Register */
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+
+	/* Start isochronous streaming */
+	I2C_SET_CHECK(GET_CONTROL, 0x04);						/* Control Register */
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+	STV_SET_CHECK(0x1440, 0x01);							/* Turn on/off isochronous stream */
+
+	if ((r = qc_stv_get(qc, 0x1445)) != 0x04)					/* Turn LED on/off? */
+		PDEBUG("Bad value 0x%02X in reg 0x1445, should be 0x04", r);
+	}
+
+	return 0;
+fail:	return r;
+}
+/* }}} */
+#endif
+/* {{{ [fold] hdcs_init: Initialise parameters (from Georg Acher's user module for hdcs sensor) */
+static int hdcs_init(struct quickcam *qc)
+{
+	struct qc_sensor_data *sd = &qc->sensor_data;
+	unsigned char control = GET_CONTROL;
+	unsigned char config = GET_CONFIG;
+	int r,tctrl,astrt,psmp;
+
+	if (sd->compress) return -EINVAL;
+	sd->maxwidth  = IS_1020(qc) ? 352 : 360;	/* CIF */
+	sd->maxheight = IS_1020(qc) ? 292 : 296;
+	if (sd->subsample) {
+		sd->maxwidth  /= 2;		/* QCIF */
+		sd->maxheight /= 2;
+	}
+	if ((r = qc_i2c_break(qc))<0) goto fail;	/* The following setting must go into same I2C packet */
+#if HDCS_COMPRESS
+r = hdcs_compress_init(qc, 3);
+qc_i2c_wait(qc);
+qc_i2c_break(qc);
+qc_stv_set(qc, 0x1440, 0x00);		/* Turn on/off isochronous stream */
+qc_i2c_set(qc, GET_CONTROL, BIT(1));	/* Stop and enter sleep mode */
+qc_i2c_wait(qc);
+if (r) PDEBUG("hdcs_compress_init(1) = %i", r);
+return 0;
+#endif
+	STV_SET_CHECK(STV_REG23, 0);
+
+	/* Set the STV0602AA in STV0600 emulation mode */
+	if (IS_870(qc)) STV_SET_CHECK(0x1446, 1);
+
+	/* Reset the image sensor (keeping it to 1 is a problem) */
+	I2C_SET_CHECK(control, 1);
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+	I2C_SET_CHECK(control, 0);
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+	
+	I2C_SET_CHECK(HDCS_STATUS, BIT(6)|BIT(5)|BIT(4)|BIT(3)|BIT(2)|BIT(1));	/* Clear status (writing 1 will clear the corresponding status bit) */
+	
+	I2C_SET_CHECK(HDCS_IMASK, 0x00);	/* Disable all interrupts */
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+
+	STV_SET_CHECK(STV_REG00, 0x1D);
+	STV_SET_CHECK(STV_REG04, 0x07);
+	STV_SET_CHECK(STV_REG03, 0x95);
+
+	STV_SET_CHECK(STV_REG23, 0);
+
+	STV_SET_CHECK(STV_SCAN_RATE, 0x20);	/* Larger -> slower */
+
+	STV_SETW_CHECK(STV_ISO_SIZE, 847);	/* ISO-Size, 0x34F = 847 .. 0x284 = 644 */
+
+	/* Set mode */
+	STV_SET_CHECK(STV_Y_CTRL, 0x01);	/* 0x02: half, 0x01: full */
+	STV_SET_CHECK(STV_X_CTRL, 0x0A);	/* 0x06: half, 0x0A: full */
+ 
+	/* These are not good final values, which will be set in set_size */
+	/* However, it looks like it's best to set some values at this point nevertheless */
+	I2C_SET_CHECK(HDCS_FWROW, 0);		/* Start at row 0 */
+	I2C_SET_CHECK(HDCS_FWCOL, 0);		/* Start at column 0 */
+	I2C_SET_CHECK(HDCS_LWROW, 0x47);	/* End at row 288 */
+	I2C_SET_CHECK(HDCS_LWCOL, 0x57);	/* End at column 352 */
+
+	/* 0x07 - 0x50 */
+	astrt = 3;	/* 0..3, doesn't seem to have any effect... hmm.. smaller is slower with subsampling */
+	if (!IS_1020(qc)) {
+		/* HDCS-1000 (tctrl was 0x09, but caused some HDCS-1000 not to work) */
+		/* Frame rate on HDCS-1000 0x46D:0x840 depending on PSMP:
+		 *  4 = doesn't work at all
+		 *  5 = 7.8 fps,
+		 *  6 = 6.9 fps,
+		 *  8 = 6.3 fps,
+		 * 10 = 5.5 fps,
+		 * 15 = 4.4 fps,
+		 * 31 = 2.8 fps */
+		/* Frame rate on HDCS-1000 0x46D:0x870 depending on PSMP:
+		 * 15 = doesn't work at all
+		 * 18 = doesn't work at all
+		 * 19 = 7.3 fps
+		 * 20 = 7.4 fps
+		 * 21 = 7.4 fps
+		 * 22 = 7.4 fps
+		 * 24 = 6.3 fps
+		 * 30 = 5.4 fps */
+		psmp = IS_870(qc) ? 20 : 5;	/* 4..31 (was 30, changed to 20) */
+		tctrl = (astrt<<5) | psmp;
+	} else {
+		/* HDCS-1020 (tctrl was 0x7E, but causes slow frame rate on HDCS-1020) */
+		/* Changed to 6 which should give 8.1 fps */
+		psmp = 6;			/* 4..31 (was 9, changed to 6 to improve fps */
+		tctrl = (astrt<<6) | psmp;
+	}
+	I2C_SET_CHECK(HDCS_TCTRL, tctrl);	/* Set PGA sample duration (was 0x7E for IS_870, but caused slow framerate with HDCS-1020) */
+
+	I2C_SET_CHECK(control, 0);		/* FIXME:should not be anymore necessary (already done) */
+
+	I2C_SET_CHECK(HDCS_ROWEXPL, 0);
+	I2C_SET_CHECK(HDCS_ROWEXPH, 0);
+	if (IS_1020(qc)) {
+		I2C_SET_CHECK(HDCS20_SROWEXP, 0);
+		I2C_SET_CHECK(HDCS20_ERROR, BIT(0)|BIT(2));	/* Clear error conditions by writing 1 */
+	} else {
+		I2C_SET_CHECK(HDCS00_SROWEXPL, 0);
+		I2C_SET_CHECK(HDCS00_SROWEXPH, 0);
+	}
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+ 
+	STV_SET_CHECK(STV_REG01, 0xB5);
+	STV_SET_CHECK(STV_REG02, 0xA8);
+
+	I2C_SET_CHECK(HDCS_PCTRL, BIT(6)|BIT(5)|BIT(1)|BIT(0));
+	I2C_SET_CHECK(HDCS_PDRV,  0x00);
+	I2C_SET_CHECK(HDCS_ICTRL, (sd->subsample ? BIT(7) : 0) | BIT(5));
+	I2C_SET_CHECK(HDCS_ITMG,  BIT(4)|BIT(1));
+
+	/* CONFIG: Bit 3: continous frame capture, bit 2: stop when frame complete */
+	I2C_SET_CHECK(config, (sd->subsample ? BIT(5) : 0) | BIT(3));
+	I2C_SET_CHECK(HDCS_ADCCTRL, 10);	/* ADC output resolution to 10 bits */
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+fail:	return r;
+}
+/* }}} */
+/* {{{ [fold] hdcs_start: Start grabbing */
+static int hdcs_start(struct quickcam *qc)
+{
+	int r;
+#if HDCS_COMPRESS
+r = hdcs_compress_init(qc, 2);
+qc_i2c_wait(qc);
+if (r) PDEBUG("hdcs_compress_init(1) = %i", r);
+return 0;
+#endif
+	if ((r = qc_i2c_break(qc))<0) goto fail;
+	I2C_SET_CHECK(GET_CONTROL, BIT(2));	/* Run enable */
+	if ((r = qc_i2c_break(qc))<0) goto fail;
+fail:	return r;
+}
+/* }}} */
+/* {{{ [fold] hdcs_stop: Stop grabbing */
+static int hdcs_stop(struct quickcam *qc)
+{
+	int r;
+	if ((r = qc_i2c_break(qc))<0) goto fail;
+	I2C_SET_CHECK(GET_CONTROL, BIT(1));	/* Stop and enter sleep mode */
+	r = qc_i2c_wait(qc);
+fail:	return r;
+}
+/* }}} */
+/* {{{ [fold] hdcs_set_exposure: Set exposure time, val=0..65535 */
+static int hdcs_set_exposure(struct quickcam *qc, unsigned int val)
+{
+	struct qc_sensor_data *sd = &qc->sensor_data;
+	unsigned char control = GET_CONTROL;
+	unsigned int rowexp;		/* rowexp,srowexp = 15 bits (0..32767) */
+	unsigned int srowexp;		/* sub-row exposure (smaller is brighter) */
+	unsigned int max_srowexp;	/* Maximum srowexp value + 1 */
+	int r;
+
+	/* Absolute black at srowexp=2672,width=360; 2616, width=352; 1896, width=256 for hdcs1000 */
+
+	if (val==sd->exposure) return 0;
+	sd->exposure = val;
+	val *= 16;		/* 16 seems to be the smallest change that actually affects brightness */
+	max_srowexp = sd->width*15/2 - 104 + 1;
+	srowexp = max_srowexp - (val % max_srowexp) - 1;
+	rowexp  = val / max_srowexp;
+	if (qcdebug&QC_DEBUGCAMERA) PDEBUG("width=%i height=%i rowexp=%i srowexp=%i",sd->width,sd->height,rowexp,srowexp);
+	if ((r = qc_i2c_break(qc))<0) goto fail;		/* The following setting must go into same I2C packet */
+	I2C_SET_CHECK(control, 0);				/* Stop grabbing */
+	I2C_SET_CHECK(HDCS_ROWEXPL, rowexp & 0xFF);		/* Number of rows to expose */
+	I2C_SET_CHECK(HDCS_ROWEXPH, rowexp >> 8);
+	if (IS_1020(qc)) {
+		srowexp = 0;	//FIXME:need formula to compute srowexp for HDCS1020!
+		srowexp >>= 2;					/* Bits 0..1 are hardwired to 0 */
+		I2C_SET_CHECK(HDCS20_SROWEXP, srowexp & 0xFF);	/* Number of pixels to expose */
+	} else {
+		I2C_SET_CHECK(HDCS00_SROWEXPL, srowexp & 0xFF);	/* Number of pixels to expose */
+		I2C_SET_CHECK(HDCS00_SROWEXPH, srowexp >> 8);
+	}
+	if (IS_1020(qc)) {
+		I2C_SET_CHECK(HDCS20_ERROR, BIT(0));		/* Reset exposure error flag */
+	} else {
+		I2C_SET_CHECK(HDCS_STATUS, BIT(4));		/* Reset exposure error flag */
+	}
+	I2C_SET_CHECK(control, BIT(2));				/* Restart grabbing */
+	if ((r = qc_i2c_break(qc))<0) goto fail;
+#if 0
+	/* Warning: the code below will cause about 0.1 second delay and may cause lost frames */
+	if (PARANOID) {
+		/* Check if the new exposure setting is valid */
+		if ((r = qc_i2c_wait(qc))<0) goto fail;
+		if (IS_1020(qc)) {
+			if ((r = qc_get_i2c(qc,qc->sensor_data.sensor, HDCS20_ERROR))<0) goto fail;
+			if (r & BIT(0)) PDEBUG("exposure error (1020)");
+		} else {
+			if ((r = qc_get_i2c(qc,qc->sensor_data.sensor, HDCS_STATUS))<0) goto fail;
+			if (r & BIT(4)) PDEBUG("exposure error (1000)");
+		}
+	}
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+#endif
+	qc_frame_flush(qc);
+fail:	return (r<0) ? r : 0;
+}
+/* }}} */
+/* {{{ [fold] hdcs_set_gains: Set gains */
+static int hdcs_set_gains(struct quickcam *qc, unsigned int hue, unsigned int sat, unsigned int val)
+{
+	static const unsigned int min_gain = 8;
+	struct qc_sensor_data *sd = &qc->sensor_data;
+	unsigned int rgain, bgain, ggain;
+	int r;
+	qc_hsv2rgb(hue, sat, val, &rgain, &bgain, &ggain);
+	rgain >>= 8;					/* After this the values are 0..255 */
+	ggain >>= 8;
+	bgain >>= 8;
+	rgain = MAX(rgain, min_gain);			/* Do not allow very small values, they cause bad (low-contrast) image */
+	ggain = MAX(ggain, min_gain);
+	bgain = MAX(bgain, min_gain);
+	if (rgain==sd->rgain && ggain==sd->ggain && bgain==sd->bgain) return 0;
+	sd->rgain = rgain;			
+	sd->ggain = ggain;
+	sd->bgain = bgain;
+	if (rgain > 127) rgain = rgain/2 | BIT(7);	/* Bit 7 doubles the programmed values */
+	if (ggain > 127) ggain = ggain/2 | BIT(7);	/* Double programmed value if necessary */
+	if (bgain > 127) bgain = bgain/2 | BIT(7);
+	if ((r = qc_i2c_break(qc))<0) goto fail;
+	I2C_SET_CHECK(HDCS_ERECPGA, ggain);
+	I2C_SET_CHECK(HDCS_EROCPGA, rgain);
+	I2C_SET_CHECK(HDCS_ORECPGA, bgain);
+	I2C_SET_CHECK(HDCS_OROCPGA, ggain);
+fail:	return r;
+}
+/* }}} */
+/* {{{ [fold] hdcs_set_levels() */
+static int hdcs_set_levels(struct quickcam *qc, unsigned int exp, unsigned int gain, unsigned int hue, unsigned int sat)
+{
+	int r = 0;
+//#if !HDCS_COMPRESS
+	if ((r = hdcs_set_exposure(qc, gain))<0) goto fail;
+//#endif
+	hdcs_set_gains(qc, hue, sat, exp);
+fail:	return r;
+}
+/* }}} */
+/* {{{ [fold] hdcs_set_size: Sets the size of the capture window */
+/*
+ *  Sets the size (scaling) of the capture window.
+ *  If subsample could return the image size we use subsample.
+ */
+static int hdcs_set_size(struct quickcam *qc, unsigned int width, unsigned int height)
+{
+	/* The datasheet doesn't seem to say this, but HDCS-1000
+	 * has visible windows size of 360x296 pixels, the first upper-left
+	 * visible pixel is at 8,8.
+	 * From Andrey's test image: looks like HDCS-1020 upper-left
+	 * visible pixel is at 24,8 (y maybe even smaller?) and lower-right
+	 * visible pixel at 375,299 (x maybe even larger?)
+	 */
+	unsigned int originx   = IS_1020(qc) ? 24 : 8;		/* First visible pixel */
+	unsigned int maxwidth  = IS_1020(qc) ? 352 : 360;	/* Visible sensor size */
+	unsigned int originy   = 8;
+	unsigned int maxheight = IS_1020(qc) ? 292 : 296;
+
+	unsigned char control = GET_CONTROL;
+	struct qc_sensor_data *sd = &qc->sensor_data;
+	int r;
+	unsigned int x, y;
+
+#if HDCS_COMPRESS
+	return 0;
+#endif
+	if (sd->subsample) {
+		width *= 2;
+		height *= 2;
+		width  = (width + 3)/4*4;		/* Width must be multiple of 4 */
+		height = (height + 3)/4*4;		/* Height must be multiple of 4 */
+		sd->width = width / 2;
+		sd->height = height / 2;		/* The image sent will be subsampled by 2 */
+	} else {
+		sd->width  = width  = (width + 3)/4*4;	/* Width must be multiple of 4 */
+		sd->height = height = (height + 3)/4*4;	/* Height must be multiple of 4 */
+	}
+	x = (maxwidth - width)/2;			/* Center image by computing upper-left corner */
+	y = (maxheight - height)/2;
+	width /= 4;
+	height /= 4;
+	x = (x + originx)/4;				/* Must be multiple of 4 (low bits wired to 0) */
+	y = (y + originy)/4;
+
+	if ((r = qc_i2c_break(qc))<0) goto fail;
+	I2C_SET_CHECK(control, 0);			/* Stop grabbing */
+	I2C_SET_CHECK(HDCS_FWROW, y);
+	I2C_SET_CHECK(HDCS_FWCOL, x);
+	I2C_SET_CHECK(HDCS_LWROW, y+height-1);
+	I2C_SET_CHECK(HDCS_LWCOL, x+width-1);
+	I2C_SET_CHECK(control, BIT(2));			/* Restart grabbing */
+	
+	/* The exposure timings need to be recomputed when size is changed */
+	x = sd->exposure;
+	sd->exposure = -1;
+	if ((r = hdcs_set_exposure(qc, x))<0) goto fail;
+fail:	return r;
+}
+/* }}} */
+
+/* {{{ [fold] struct qc_sensor qc_sensor_hdcs1000 */
+const struct qc_sensor qc_sensor_hdcs1000 = {
+	name:		"HDCS-1000/1100",
+	manufacturer:	"Hewlett Packard",
+	init:		hdcs_init,
+	start:		hdcs_start,
+	stop:		hdcs_stop,
+	set_size:	hdcs_set_size,
+	set_levels:	hdcs_set_levels,
+	/* Exposure and gain control information */
+	autoexposure:	FALSE,
+	adapt_gainlow:	20,
+	adapt_gainhigh:	20000,
+	/* Information needed to access the sensor via I2C */
+	reg23: 		0,
+	i2c_addr: 	HDCS_ADDR,
+	/* Identification information used for auto-detection */
+	id_reg:		HDCS_IDENT | 1,
+	id:		0x08,
+	length_id:	1,
+	flag:		0,
+};
+/* }}} */
+/* {{{ [fold] struct qc_sensor qc_sensor_hdcs1020 */
+const struct qc_sensor qc_sensor_hdcs1020 = {
+	name:		"HDCS-1020",
+	manufacturer:	"Agilent Technologies",
+	init:		hdcs_init,
+	start:		hdcs_start,
+	stop:		hdcs_stop,
+	set_size:	hdcs_set_size,
+	set_levels:	hdcs_set_levels,
+	/* Exposure and gain control information */
+	autoexposure:	FALSE,
+	adapt_gainlow:	20,
+	adapt_gainhigh:	20000,
+	/* Information needed to access the sensor via I2C */
+	reg23: 		0,
+	i2c_addr: 	HDCS_ADDR,
+	/* Identification information used for auto-detection */
+	id_reg:		HDCS_IDENT | 1,
+	id:		0x10,
+	length_id:	1,
+	flag:		1,
+};
+/* }}} */
+
+/* End of file */
diff -purN linux-2.6.10.orig/drivers/usb/media/qc/qc-memory.c linux-2.6.10-qc-usb/drivers/usb/media/qc/qc-memory.c
--- linux-2.6.10.orig/drivers/usb/media/qc/qc-memory.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-qc-usb/drivers/usb/media/qc/qc-memory.c	2003-12-15 10:31:46.000000000 +0100
@@ -0,0 +1,243 @@
+/* Start of file */
+
+/* {{{ [fold] Comments */
+/*
+ * qce-ga, linux V4L driver for the QuickCam Express and Dexxa QuickCam
+ *
+ * memory.c - contains all needed memory management functions
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+ 
+/* These routines have been derived from the ov511 driver, into which they
+ * were derived from the bttv driver.
+ */
+/* }}} */
+/* {{{ [fold] Includes */
+#include <linux/config.h>
+#include <linux/version.h>
+
+#ifdef CONFIG_SMP
+#define __SMP__
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#if defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS)
+#define MODVERSIONS
+#endif
+#ifdef MODVERSIONS
+#include <linux/modversions.h>
+#endif
+#endif
+
+#include "qc-memory.h"
+#include <asm/io.h>
+#include <linux/mm.h>		/* Required on Alpha, from Bob McElrath <mcelrath@draal.physics.wisc.edu> */
+#include <asm/pgtable.h>	/* Required on Alpha */
+#include <linux/vmalloc.h>	/* Required on Alpha */
+#include <linux/pagemap.h>	/* pmd_offset requires this on SuSE supplied kernels */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
+#include <linux/wrapper.h>	/* For proper mem_map_(un)reserve define, the compatibility define below might not work */
+#endif
+/* }}} */
+/* {{{ [fold] Compatibility wrappers */
+#ifndef HAVE_VMA
+#if LINUX_VERSION_CODE>=KERNEL_VERSION(2,5,3) || (defined(RED_HAT_LINUX_KERNEL) && defined(pte_offset_map))
+#define HAVE_VMA 1
+#else
+#define HAVE_VMA 0
+#endif
+#endif
+
+#if !HAVE_VMA
+static inline int qc_remap_page_range(unsigned long from, unsigned long addr, unsigned long size, pgprot_t prot) { return remap_page_range(from, addr, size, prot); }
+#undef remap_page_range
+#define remap_page_range(vma, start, addr, size, prot)	qc_remap_page_range((start),(addr),(size),(prot))
+#endif
+
+#if LINUX_VERSION_CODE>=KERNEL_VERSION(2,5,3) || defined(pte_offset_map)
+#define pte_offset(pmd,adr)	pte_offset_map(pmd,adr)	/* Emulation for a kernel using the new rmap-vm */
+#endif							/* Fix by Michele Balistreri <brain87@gmx.net> */
+
+#ifndef SetPageReserved
+#define SetPageReserved(p)	mem_map_reserve(p)
+#endif
+#ifndef ClearPageReserved
+#define ClearPageReserved(p)	mem_map_unreserve(p)
+#endif
+/* }}} */
+
+/* {{{ [fold] kvirt_to_pa(): obtain physical address from virtual address obtained by vmalloc() */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+/* {{{ [fold] kvirt_to_pa(), 2.4.x and 2.6.x */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,19)
+static struct page *vmalloc_to_page(void * vmalloc_addr);
+#endif
+
+/* Here we want the physical address of the memory obtained by vmalloc().
+ */
+static inline unsigned long kvirt_to_pa(unsigned long adr)
+{
+	unsigned long kva, ret;
+
+	kva = (unsigned long) page_address(vmalloc_to_page((void *)adr));
+	kva |= adr & (PAGE_SIZE-1); /* restore the offset */
+	ret = __pa(kva);
+	return ret;
+}
+/* }}} */
+#else
+/* {{{ [fold] kvirt_to_pa() for 2.2.x */
+#define page_address(x)		(x | PAGE_OFFSET)	/* Damn ugly hack from kcomp.h; replaces original page_address() that made different thing! */
+
+/* Given PGD from the address space's page table, return the kernel
+ * virtual mapping of the physical memory mapped at ADR.
+ */
+static inline unsigned long uvirt_to_kva(pgd_t *pgd, unsigned long adr)
+{
+	unsigned long ret = 0UL;
+	pmd_t *pmd;
+	pte_t *ptep, pte;
+
+	if (!pgd_none(*pgd)) {
+		pmd = pmd_offset(pgd, adr);
+		if (!pmd_none(*pmd)) {
+			ptep = pte_offset(pmd, adr);
+			pte = *ptep;
+			if (pte_present(pte)) {
+				ret = (unsigned long) page_address(pte_page(pte));
+				ret |= (adr & (PAGE_SIZE - 1));
+			}
+		}
+	}
+
+	return ret;
+}
+
+/* Here we want the physical address of the memory obtained by vmalloc().
+ * This is used when initializing the contents of the
+ * area and marking the pages as reserved.
+ */
+static unsigned long kvirt_to_pa(unsigned long adr)
+{
+	unsigned long va, kva, ret;
+
+	va = VMALLOC_VMADDR(adr);
+	kva = uvirt_to_kva(pgd_offset_k(va), va);
+	ret = __pa(kva);
+	return ret;
+}
+/* }}} */
+#endif
+/* }}} */
+/* {{{ [fold] vmalloc_to_page(): obtain pointer to struct page from virtual address obtained by vmalloc() */
+#if LINUX_VERSION_CODE>=KERNEL_VERSION(2,4,0) && LINUX_VERSION_CODE<KERNEL_VERSION(2,4,19)
+/* {{{ [fold] vmalloc_to_page() for 2.4.x (returns pointer to page) */
+static struct page *vmalloc_to_page(void * vmalloc_addr)
+{
+	unsigned long addr = (unsigned long) vmalloc_addr;
+	struct page *page = NULL;
+	pmd_t *pmd;
+	pte_t *pte;
+	pgd_t *pgd;
+
+	pgd = pgd_offset_k(addr);
+	if (!pgd_none(*pgd)) {
+		pmd = pmd_offset(pgd, addr);
+		if (!pmd_none(*pmd)) {
+			pte = pte_offset(pmd, addr);
+			if (pte_present(*pte)) {
+				page = pte_page(*pte);
+			}
+		}
+	}
+	return page;
+}
+/* }}} */
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
+/* {{{ [fold] vmalloc_to_page() for 2.2.x (returns page index in mem_map[]) */
+static inline unsigned long vmalloc_to_page(void * vmalloc_addr)
+{
+	unsigned long pagenum;
+	unsigned long physaddr;
+	physaddr = kvirt_to_pa((unsigned long)vmalloc_addr);
+	pagenum = MAP_NR(__va(physaddr));
+	return pagenum;
+}
+/* }}} */
+#endif
+/* }}} */
+
+/* {{{ [fold] qc_mm_rvmalloc(size) */
+void *qc_mm_rvmalloc(unsigned long size)
+{
+	void *mem;
+	unsigned long adr;
+
+	size = PAGE_ALIGN(size);
+	mem = vmalloc_32(size);
+	if (!mem)
+		return NULL;
+
+	memset(mem, 0, size); /* Clear the ram out, no junk to the user */
+	adr = (unsigned long) mem;
+	while ((long)size > 0) {
+		SetPageReserved(vmalloc_to_page((void *)adr));
+		adr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+
+	return mem;
+}
+/* }}} */
+/* {{{ [fold] qc_mm_rvfree(mem, size) */
+void qc_mm_rvfree(void *mem, unsigned long size)
+{
+	unsigned long adr;
+
+	if (!mem)
+		return;
+
+	adr = (unsigned long) mem;
+	while ((long) size > 0) {
+		ClearPageReserved(vmalloc_to_page((void *)adr));
+		adr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+	vfree(mem);
+}
+/* }}} */
+/* {{{ [fold] qc_mm_remap(vma, src, src_size, dst, dst_size) */
+int qc_mm_remap(struct vm_area_struct *vma, void *src, unsigned long src_size, const void *dst, unsigned long dst_size)
+{
+	unsigned long start = (unsigned long)dst;
+	unsigned long size  = dst_size;
+	unsigned long physaddr, pos;
+
+	pos = (unsigned long)src;
+	while ((long)size > 0) {
+		physaddr = kvirt_to_pa(pos);
+		if (remap_page_range(vma, start, physaddr, PAGE_SIZE, PAGE_SHARED))
+			return -EAGAIN;
+		start += PAGE_SIZE;
+		pos += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+	return 0;
+}
+/* }}} */
+
+/* End of file */
diff -purN linux-2.6.10.orig/drivers/usb/media/qc/qc-memory.h linux-2.6.10-qc-usb/drivers/usb/media/qc/qc-memory.h
--- linux-2.6.10.orig/drivers/usb/media/qc/qc-memory.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-qc-usb/drivers/usb/media/qc/qc-memory.h	2003-06-30 12:04:40.000000000 +0200
@@ -0,0 +1,10 @@
+#ifndef _LINUX_QC_MEMORY_H
+#define _LINUX_QC_MEMORY_H
+
+#include <linux/mm.h>
+
+void *qc_mm_rvmalloc(unsigned long size);
+void qc_mm_rvfree(void *mem, unsigned long size);
+int qc_mm_remap(struct vm_area_struct *vma, void *src, unsigned long src_size, const void *dst, unsigned long dst_size);
+
+#endif
diff -purN linux-2.6.10.orig/drivers/usb/media/qc/qc-mjpeg.c linux-2.6.10-qc-usb/drivers/usb/media/qc/qc-mjpeg.c
--- linux-2.6.10.orig/drivers/usb/media/qc/qc-mjpeg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-qc-usb/drivers/usb/media/qc/qc-mjpeg.c	2004-07-29 20:12:38.000000000 +0200
@@ -0,0 +1,1940 @@
+/* Start of file */
+
+/* {{{ [fold] Comments */
+/*
+ * MJPEG decompression routines are from mpeg2dec,
+ * Copyright (C) 1999-2001 Aaron Holtzman <aholtzma@ess.engr.uvic.ca>
+ * Modified by Tuukka Toivonen and Jochen Hoenicke.
+ *
+ * Portions of this code are from the MPEG software simulation group
+ * idct implementation. This code will be replaced with a new
+ * implementation soon.
+ *
+ * The MJPEG routines are from mpeg2dec, a free MPEG-2 video stream decoder.
+ *
+ * mpeg2dec is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * mpeg2dec is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* }}} */
+
+#ifdef NOKERNEL
+#include "quickcam.h"
+#else
+#include <linux/quickcam.h>
+#endif
+
+#ifdef __KERNEL__	/* show.c will include this file directly into compilation for userspace */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+#include <linux/slab.h>
+#else
+#include <linux/malloc.h>
+#endif
+#endif /* __KERNEL__ */
+
+#if COMPRESS
+/* {{{ [fold] **** qc_mjpeg_yuv2rgb: MJPEG decoding: YUV to RGB conversion routines *************** */
+
+/* {{{ [fold] Macros */
+#define MODE_RGB  1
+#define MODE_BGR  2
+
+#define RGB(i)							\
+	U = pu[i];						\
+	V = pv[i];						\
+	r = md->table_rV[V];					\
+	g = (void *)(((u8 *)md->table_gU[U]) + md->table_gV[V]);\
+	b = md->table_bU[U];
+
+#define DST1(i)					\
+	Y = py_1[2*i];				\
+	dst_1[2*i] = r[Y] + g[Y] + b[Y];	\
+	Y = py_1[2*i+1];			\
+	dst_1[2*i+1] = r[Y] + g[Y] + b[Y];
+
+#define DST2(i)					\
+	Y = py_2[2*i];				\
+	dst_2[2*i] = r[Y] + g[Y] + b[Y];	\
+	Y = py_2[2*i+1];			\
+	dst_2[2*i+1] = r[Y] + g[Y] + b[Y];
+
+#define DST1RGB(i)							\
+	Y = py_1[2*i];							\
+	dst_1[6*i] = r[Y]; dst_1[6*i+1] = g[Y]; dst_1[6*i+2] = b[Y];	\
+	Y = py_1[2*i+1];						\
+	dst_1[6*i+3] = r[Y]; dst_1[6*i+4] = g[Y]; dst_1[6*i+5] = b[Y];
+
+#define DST2RGB(i)							\
+	Y = py_2[2*i];							\
+	dst_2[6*i] = r[Y]; dst_2[6*i+1] = g[Y]; dst_2[6*i+2] = b[Y];	\
+	Y = py_2[2*i+1];						\
+	dst_2[6*i+3] = r[Y]; dst_2[6*i+4] = g[Y]; dst_2[6*i+5] = b[Y];
+
+#define DST1BGR(i)							\
+	Y = py_1[2*i];							\
+	dst_1[6*i] = b[Y]; dst_1[6*i+1] = g[Y]; dst_1[6*i+2] = r[Y];	\
+	Y = py_1[2*i+1];						\
+	dst_1[6*i+3] = b[Y]; dst_1[6*i+4] = g[Y]; dst_1[6*i+5] = r[Y];
+
+#define DST2BGR(i)							\
+	Y = py_2[2*i];							\
+	dst_2[6*i] = b[Y]; dst_2[6*i+1] = g[Y]; dst_2[6*i+2] = r[Y];	\
+	Y = py_2[2*i+1];						\
+	dst_2[6*i+3] = b[Y]; dst_2[6*i+4] = g[Y]; dst_2[6*i+5] = r[Y];
+/* }}} */
+
+/* {{{ [fold] qc_mjpeg_yuv2rgb_32() */
+static void qc_mjpeg_yuv2rgb_32(struct qc_mjpeg_data *md, u8 *py_1, u8 *py_2, u8 *pu, u8 *pv,
+	void *_dst_1, void *_dst_2, int width)
+{
+	int U, V, Y;
+	u32 *r, *g, *b;
+	u32 *dst_1, *dst_2;
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_mjpeg_yuv2rgb_32(md=%p, py_1=%p, py_2=%p, pu=%p, pv=%p, _dst_1=%p, _dst_2=%p, width=%i",md,py_1,py_2,pu,pv,_dst_1,_dst_2,width);
+	width >>= 3;
+	dst_1 = _dst_1;
+	dst_2 = _dst_2;
+
+	do {
+		RGB(0);
+		DST1(0);
+		DST2(0);
+
+		RGB(1);
+		DST2(1);
+		DST1(1);
+
+		RGB(2);
+		DST1(2);
+		DST2(2);
+
+		RGB(3);
+		DST2(3);
+		DST1(3);
+
+		pu += 4;
+		pv += 4;
+		py_1 += 8;
+		py_2 += 8;
+		dst_1 += 8;
+		dst_2 += 8;
+	} while (--width);
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_mjpeg_yuv2rgb_32() done");
+}
+/* }}} */
+/* {{{ [fold] qc_mjpeg_yuv2rgb_24rgb() */
+/* This is very near from the yuv2rgb_32 code */
+static void qc_mjpeg_yuv2rgb_24rgb(struct qc_mjpeg_data *md, u8 *py_1, u8 *py_2, u8 *pu, u8 *pv, 
+	void *_dst_1, void *_dst_2, int width)
+{
+	int U, V, Y;
+	u8 *r, *g, *b;
+	u8 *dst_1, *dst_2;
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_mjpeg_yuv2rgb_24rgb(md=%p, py_1=%p, py_2=%p, pu=%p, pv=%p, _dst_1=%p, _dst_2=%p, width=%i",md,py_1,py_2,pu,pv,_dst_1,_dst_2,width);
+
+	width >>= 3;
+	dst_1 = _dst_1;
+	dst_2 = _dst_2;
+
+	do {
+		RGB(0);
+		DST1RGB(0);
+		DST2RGB(0);
+
+		RGB(1);
+		DST2RGB(1);
+		DST1RGB(1);
+
+		RGB(2);
+		DST1RGB(2);
+		DST2RGB(2);
+
+		RGB(3);
+		DST2RGB(3);
+		DST1RGB(3);
+
+		pu += 4;
+		pv += 4;
+		py_1 += 8;
+		py_2 += 8;
+		dst_1 += 24;
+		dst_2 += 24;
+	} while (--width);
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_mjpeg_yuv2rgb_24rgb() done");
+}
+/* }}} */
+/* {{{ [fold] qc_mjpeg_yuv2rgb_24bgr() */
+/* only trivial mods from yuv2rgb_24rgb */
+static void qc_mjpeg_yuv2rgb_24bgr(struct qc_mjpeg_data *md, u8 *py_1, u8 *py_2, u8 *pu, u8 *pv, 
+	void *_dst_1, void *_dst_2, int width)
+{
+	int U, V, Y;
+	u8 *r, *g, *b;
+	u8 *dst_1, *dst_2;
+
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_mjpeg_yuv2rgb_24bgr(md=%p, py_1=%p, py_2=%p, pu=%p, pv=%p, _dst_1=%p, _dst_2=%p, width=%i",md,py_1,py_2,pu,pv,_dst_1,_dst_2,width);
+	width >>= 3;
+	dst_1 = _dst_1;
+	dst_2 = _dst_2;
+
+	do {
+		RGB(0);
+		DST1BGR(0);
+		DST2BGR(0);
+
+		RGB(1);
+		DST2BGR(1);
+		DST1BGR(1);
+
+		RGB(2);
+		DST1BGR(2);
+		DST2BGR(2);
+
+		RGB(3);
+		DST2BGR(3);
+		DST1BGR(3);
+
+		pu += 4;
+		pv += 4;
+		py_1 += 8;
+		py_2 += 8;
+		dst_1 += 24;
+		dst_2 += 24;
+	} while (--width);
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_mjpeg_yuv2rgb_24bgr() done");
+}
+/* }}} */
+/* {{{ [fold] qc_mjpeg_yuv2rgb_16() */
+/* This is exactly the same code as yuv2rgb_32 except for the types of */
+/* r, g, b, dst_1, dst_2 */
+static void qc_mjpeg_yuv2rgb_16(struct qc_mjpeg_data *md, u8 *py_1, u8 *py_2, u8 *pu, u8 *pv, 
+	void *_dst_1, void *_dst_2, int width)
+{
+	int U, V, Y;
+	u16 *r, *g, *b;
+	u16 *dst_1, *dst_2;
+
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_mjpeg_yuv2rgb_16(md=%p, py_1=%p, py_2=%p, pu=%p, pv=%p, _dst_1=%p, _dst_2=%p, width=%i",md,py_1,py_2,pu,pv,_dst_1,_dst_2,width);
+	width >>= 3;
+	dst_1 = _dst_1;
+	dst_2 = _dst_2;
+
+	do {
+		RGB(0);
+		DST1(0);
+		DST2(0);
+
+		RGB(1);
+		DST2(1);
+		DST1(1);
+
+		RGB(2);
+		DST1(2);
+		DST2(2);
+
+		RGB(3);
+		DST2(3);
+		DST1(3);
+
+		pu += 4;
+		pv += 4;
+		py_1 += 8;
+		py_2 += 8;
+		dst_1 += 8;
+		dst_2 += 8;
+	} while (--width);
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_mjpeg_yuv2rgb_16() done");
+}
+/* }}} */
+/* {{{ [fold] qc_mjpeg_yuv2rgb() */
+/* Convert YUV image to RGB */
+static void qc_mjpeg_yuv2rgb(struct qc_mjpeg_data *md, void *dst, u8 *py, u8 *pu, u8 *pv, 
+	int width, int height, int rgb_stride, int y_stride, int uv_stride)
+{
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_mjpeg_yuv2rgb(md=%p, dst=%p, py=%p, pu=%p, pv=%p, width=%i, height=%i, rgb_stride=%i, y_stride=%i, uv_stride=%i",md,dst,py,pu,pv,width,height,rgb_stride,y_stride,uv_stride);
+	height >>= 1;
+	do {
+		md->yuv2rgb_func(md, py, py + y_stride, pu, pv, dst, ((u8 *)dst) + rgb_stride, width);
+		py += 2 * y_stride;
+		pu += uv_stride;
+		pv += uv_stride;
+		dst = ((u8 *)dst) + 2 * rgb_stride;
+	} while (--height);
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_mjpeg_yuv2rgb() done");
+}
+/* }}} */
+
+static const u32 matrix_coefficients = 6;
+static const s32 Inverse_Table_6_9[8][4] = {
+	{ 117504, 138453, 13954, 34903 },	/* 0: no sequence_display_extension */
+	{ 117504, 138453, 13954, 34903 },	/* 1: ITU-R Rec. 709 (1990) */
+	{ 104597, 132201, 25675, 53279 },	/* 2: unspecified */
+	{ 104597, 132201, 25675, 53279 },	/* 3: reserved */
+	{ 104448, 132798, 24759, 53109 },	/* 4: FCC */
+	{ 104597, 132201, 25675, 53279 },	/* 5: ITU-R Rec. 624-4 System B, G */
+	{ 104597, 132201, 25675, 53279 },	/* 6: SMPTE 170M */
+	{ 117579, 136230, 16907, 35559 } 	/* 7: SMPTE 240M (1987) */
+};
+
+/* {{{ [fold] div_round(int dividend, int divisor) */
+static int div_round(int dividend, int divisor)
+{
+	if (dividend > 0) 
+		return (dividend + (divisor>>1)) / divisor;
+	else
+		return -((-dividend + (divisor>>1)) / divisor);
+}
+/* }}} */
+/* {{{ [fold] qc_mjpeg_yuv2rgb_init(struct qc_mjpeg_data *md, int bpp, int mode) */
+/* Initialization of yuv2rgb routines. Return error code if failure */
+static inline int qc_mjpeg_yuv2rgb_init(struct qc_mjpeg_data *md, int bpp, int mode)
+{
+	static const int table_Y_size = 1024;
+	u8 *table_Y;
+	int i, ret = -ENOMEM;
+	int entry_size = 0;
+	void *table_r = NULL, *table_g = NULL, *table_b = NULL;
+	int crv = Inverse_Table_6_9[matrix_coefficients][0];
+	int cbu = Inverse_Table_6_9[matrix_coefficients][1];
+	int cgu = -Inverse_Table_6_9[matrix_coefficients][2];
+	int cgv = -Inverse_Table_6_9[matrix_coefficients][3];
+	u32 *table_32;
+	u16 *table_16;
+	u8 *table_8;
+
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_mjpeg_yuv2rgb_init(md=%p, bpp=%i, mode=%i)",md,bpp,mode);
+	table_Y = kmalloc(table_Y_size,GFP_KERNEL);	/* Allocate with kmalloc(), it might not fit into stack */
+	if (table_Y==NULL) return -ENOMEM;
+
+	for (i=0; i<1024; i++) {
+		int j;
+		j = (76309 * (i - 384 - 16) + 32768) >> 16;
+		j = (j < 0) ? 0 : ((j > 255) ? 255 : j);
+		table_Y[i] = j;
+	}
+
+	switch (bpp) {
+	case 32:
+		md->yuv2rgb_func = qc_mjpeg_yuv2rgb_32;
+		table_32 = md->table = kmalloc((197 + 2*682 + 256 + 132) * sizeof(u32), GFP_KERNEL);	/* 0..1948 x 4 */
+		if (!md->table) goto fail;
+		entry_size = sizeof(u32);
+		table_r = table_32 + 197;		/* R: -197..1751 */
+		table_b = table_32 + 197 + 685;		/* B: -882..1066 */
+		table_g = table_32 + 197 + 2*682;	/* G: -1561..387 */
+		for (i=-197; i<256+197; i++)		/* Ri = -197...452 */
+			((u32 *) table_r)[i] = table_Y[i+384] << ((mode==MODE_RGB) ? 16 : 0);
+		for (i=-132; i<256+132; i++)		/* Gi = -132...387 */
+			((u32 *) table_g)[i] = table_Y[i+384] << 8;
+		for (i=-232; i<256+232; i++)		/* Bi = -232...487 */
+			((u32 *) table_b)[i] = table_Y[i+384] << ((mode==MODE_RGB) ? 0 : 16);
+		break;
+	case 24:
+		md->yuv2rgb_func = (mode==MODE_RGB) ? qc_mjpeg_yuv2rgb_24rgb : qc_mjpeg_yuv2rgb_24bgr;
+		table_8 = md->table = kmalloc((256 + 2*232) * sizeof(u8), GFP_KERNEL);			/* 0..719 x 1 */
+		if (!md->table) goto fail;
+		entry_size = sizeof(u8);
+		table_r = table_g = table_b = table_8 + 232;	/* -232..487 */
+		for (i=-232; i<256+232; i++)			/* i = -232..487 */
+			((u8 *)table_b)[i] = table_Y[i+384];
+		break;
+	case 15:
+	case 16:
+		md->yuv2rgb_func = qc_mjpeg_yuv2rgb_16;
+		table_16 = md->table = kmalloc((197 + 2*682 + 256 + 132) * sizeof(u16), GFP_KERNEL);	/* 0..1948 x 2 */
+		if (!md->table) goto fail;
+		entry_size = sizeof(u16);
+		table_r = table_16 + 197;		/* R: -197..1751 */
+		table_b = table_16 + 197 + 685;		/* B: -882..1066 */
+		table_g = table_16 + 197 + 2*682;	/* G: -1561..387 */
+		for (i=-197; i<256+197; i++) {		/* Ri = -197..452 */
+			int j = table_Y[i+384] >> 3;
+			if (mode == MODE_RGB) j <<= ((bpp==16) ? 11 : 10);
+			((u16 *)table_r)[i] = j;
+		}
+		for (i=-132; i<256+132; i++) {		/* Gi = -132..387 */
+			int j = table_Y[i+384] >> ((bpp==16) ? 2 : 3);
+			((u16 *)table_g)[i] = j << 5;
+		}
+		for (i=-232; i<256+232; i++) {		/* Bi = -232..487 */
+			int j = table_Y[i+384] >> 3;
+			if (mode == MODE_BGR) j <<= ((bpp==16) ? 11 : 10);
+			((u16 *)table_b)[i] = j;
+		}
+		break;
+	default:
+		PDEBUG("%i bpp not supported by yuv2rgb", bpp);
+		ret = -EINVAL;
+		goto fail;
+	}
+	for (i=0; i<256; i++) {
+		md->table_rV[i] = (((u8 *)table_r) + entry_size * div_round(crv * (i-128), 76309));
+		md->table_gU[i] = (((u8 *)table_g) + entry_size * div_round(cgu * (i-128), 76309));
+		md->table_gV[i] = entry_size * div_round(cgv * (i-128), 76309);
+		md->table_bU[i] = (((u8 *)table_b) + entry_size * div_round(cbu * (i-128), 76309));
+	}
+	ret = 0;
+fail:	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_mjpeg_yuv2rgb_init()=%i done", ret);
+	if (PARANOID) memset(table_Y, POISON_VAL, table_Y_size);
+	kfree(table_Y);
+	return ret;
+}
+/* }}} */
+/* {{{ [fold] qc_mjpeg_yuv2rgb_exit(struct qc_mjpeg_data *md) */
+static inline void qc_mjpeg_yuv2rgb_exit(struct qc_mjpeg_data *md)
+{
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_mjpeg_yuv2rgb_exit(md=%p)",md);
+	kfree(md->table);
+	POISON(md->table);
+	POISON(md->yuv2rgb_func);
+	POISON(md->table_rV);
+	POISON(md->table_gU);
+	POISON(md->table_bU);
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_mjpeg_yuv2rgb_exit() done");
+}
+/* }}} */
+
+/* }}} */
+/* {{{ [fold] **** qc_mjpeg_idct:    MJPEG decoding: Inverse DCT routines ************************* */
+/**********************************************************/
+/* inverse two dimensional DCT, Chen-Wang algorithm */
+/* (cf. IEEE ASSP-32, pp. 803-816, Aug. 1984) */
+/* 32-bit integer arithmetic (8 bit coefficients) */
+/* 11 mults, 29 adds per DCT */
+/* sE, 18.8.91 */
+/**********************************************************/
+/* coefficients extended to 12 bit for IEEE1180-1990 */
+/* compliance sE, 2.1.94 */
+/**********************************************************/
+
+/* this code assumes >> to be a two's-complement arithmetic */
+/* right shift: (-2)>>1 == -1 , (-3)>>1 == -2 */
+
+#define W1 2841		/* 2048*sqrt (2)*cos (1*pi/16) */
+#define W2 2676		/* 2048*sqrt (2)*cos (2*pi/16) */
+#define W3 2408		/* 2048*sqrt (2)*cos (3*pi/16) */
+#define W5 1609		/* 2048*sqrt (2)*cos (5*pi/16) */
+#define W6 1108		/* 2048*sqrt (2)*cos (6*pi/16) */
+#define W7 565		/* 2048*sqrt (2)*cos (7*pi/16) */
+
+/* {{{ [fold] qc_mjpeg_idct_row(s16 *block) */
+/* row (horizontal) IDCT
+ *
+ * 7 pi 1
+ * dst[k] = sum c[l] * src[l] * cos ( -- * ( k + - ) * l )
+ * l=0 8 2
+ *
+ * where: c[0] = 128
+ * c[1..7] = 128*sqrt (2)
+ */
+static void inline qc_mjpeg_idct_row(s16 *block)
+{
+	int x0, x1, x2, x3, x4, x5, x6, x7, x8;
+
+	x1 = block[4] << 11;
+	x2 = block[6];
+	x3 = block[2];
+	x4 = block[1];
+	x5 = block[7];
+	x6 = block[5];
+	x7 = block[3];
+
+	/* shortcut */
+	if (! (x1 | x2 | x3 | x4 | x5 | x6 | x7)) {
+		block[0] = block[1] = block[2] = block[3] = block[4] =
+			block[5] = block[6] = block[7] = block[0]<<3;
+		return;
+	}
+
+	x0 = (block[0] << 11) + 128; /* for proper rounding in the fourth stage */
+
+	/* first stage */
+	x8 = W7 * (x4 + x5);
+	x4 = x8 + (W1 - W7) * x4;
+	x5 = x8 - (W1 + W7) * x5;
+	x8 = W3 * (x6 + x7);
+	x6 = x8 - (W3 - W5) * x6;
+	x7 = x8 - (W3 + W5) * x7;
+
+	/* second stage */
+	x8 = x0 + x1;
+	x0 -= x1;
+	x1 = W6 * (x3 + x2);
+	x2 = x1 - (W2 + W6) * x2;
+	x3 = x1 + (W2 - W6) * x3;
+	x1 = x4 + x6;
+	x4 -= x6;
+	x6 = x5 + x7;
+	x5 -= x7;
+
+	/* third stage */
+	x7 = x8 + x3;
+	x8 -= x3;
+	x3 = x0 + x2;
+	x0 -= x2;
+	x2 = (181 * (x4 + x5) + 128) >> 8;
+	x4 = (181 * (x4 - x5) + 128) >> 8;
+
+	/* fourth stage */
+	block[0] = (x7 + x1) >> 8;
+	block[1] = (x3 + x2) >> 8;
+	block[2] = (x0 + x4) >> 8;
+	block[3] = (x8 + x6) >> 8;
+	block[4] = (x8 - x6) >> 8;
+	block[5] = (x0 - x4) >> 8;
+	block[6] = (x3 - x2) >> 8;
+	block[7] = (x7 - x1) >> 8;
+}
+/* }}} */
+/* {{{ [fold] qc_mjpeg_idct_col(s16 *block) */
+/* column (vertical) IDCT
+ *
+ * 7 pi 1
+ * dst[8*k] = sum c[l] * src[8*l] * cos ( -- * ( k + - ) * l )
+ * l=0 8 2
+ *
+ * where: c[0] = 1/1024
+ * c[1..7] = (1/1024)*sqrt (2)
+ */
+static void inline qc_mjpeg_idct_col(s16 *block)
+{
+	int x0, x1, x2, x3, x4, x5, x6, x7, x8;
+
+	/* shortcut */
+	x1 = block [8*4] << 8;
+	x2 = block [8*6];
+	x3 = block [8*2];
+	x4 = block [8*1];
+	x5 = block [8*7];
+	x6 = block [8*5];
+	x7 = block [8*3];
+#if 0
+	if (! (x1 | x2 | x3 | x4 | x5 | x6 | x7 )) {
+		block[8*0] = block[8*1] = block[8*2] = block[8*3] = block[8*4] =
+			block[8*5] = block[8*6] = block[8*7] = (block[8*0] + 32) >> 6;
+		return;
+	}
+#endif
+	x0 = (block[8*0] << 8) + 8192;
+
+	/* first stage */
+	x8 = W7 * (x4 + x5) + 4;
+	x4 = (x8 + (W1 - W7) * x4) >> 3;
+	x5 = (x8 - (W1 + W7) * x5) >> 3;
+	x8 = W3 * (x6 + x7) + 4;
+	x6 = (x8 - (W3 - W5) * x6) >> 3;
+	x7 = (x8 - (W3 + W5) * x7) >> 3;
+
+	/* second stage */
+	x8 = x0 + x1;
+	x0 -= x1;
+	x1 = W6 * (x3 + x2) + 4;
+	x2 = (x1 - (W2 + W6) * x2) >> 3;
+	x3 = (x1 + (W2 - W6) * x3) >> 3;
+	x1 = x4 + x6;
+	x4 -= x6;
+	x6 = x5 + x7;
+	x5 -= x7;
+
+	/* third stage */
+	x7 = x8 + x3;
+	x8 -= x3;
+	x3 = x0 + x2;
+	x0 -= x2;
+	x2 = (181 * (x4 + x5) + 128) >> 8;
+	x4 = (181 * (x4 - x5) + 128) >> 8;
+
+	/* fourth stage */
+	block[8*0] = (x7 + x1) >> 14;
+	block[8*1] = (x3 + x2) >> 14;
+	block[8*2] = (x0 + x4) >> 14;
+	block[8*3] = (x8 + x6) >> 14;
+	block[8*4] = (x8 - x6) >> 14;
+	block[8*5] = (x0 - x4) >> 14;
+	block[8*6] = (x3 - x2) >> 14;
+	block[8*7] = (x7 - x1) >> 14;
+}
+/* }}} */
+/* {{{ [fold] qc_mjpeg_idct(s16 *block, u8 *dest, int stride) */
+/* Inverse discrete cosine transform block, store result to dest */
+static void qc_mjpeg_idct(s16 *block, u8 *dest, int stride)
+{
+	int i;
+
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_mjpeg_idct(block=%p,dest=%p,stride=%i)",block,dest,stride);
+	for (i=0; i<8; i++) qc_mjpeg_idct_row(block + 8*i);
+	for (i=0; i<8; i++) qc_mjpeg_idct_col(block + i);
+	i = 8;
+	do {
+		/* The original code used lookup-tables instead of explicit
+		 * comparisons (as CLIP is doing here). However, sometimes
+		 * the values pointed outside the LUT which caused problems
+		 * in the kernel driver. Thus, the LUTs are removed here. */
+		dest[0] = CLIP(block[0],0,255);
+		dest[1] = CLIP(block[1],0,255);
+		dest[2] = CLIP(block[2],0,255);
+		dest[3] = CLIP(block[3],0,255);
+		dest[4] = CLIP(block[4],0,255);
+		dest[5] = CLIP(block[5],0,255);
+		dest[6] = CLIP(block[6],0,255);
+		dest[7] = CLIP(block[7],0,255);
+		dest += stride;
+		block += 8;
+	} while (--i);
+}
+/* }}} */
+
+/* }}} */
+/* {{{ [fold] **** MJPEG decoding: bitstream processing (structures and macros) * */
+/* the idea is taken from zlib, but the bits are ordered the other way, so
+ * I modified the code.
+ * Variables:
+ * p points to next unread byte in stream.
+ * k number of bits read but not processed.
+ * b contains the read but not processed bits in the k most significant bits.
+ */
+struct bitstream {
+	u32 b;
+	u8 *p;
+	u8 *end;
+	int k;
+};
+
+#define GETWORD(p) ((p)[0] << 8 | (p)[1])
+#define NEEDBITS(b,k,p) \
+  do { \
+    if ((k) > 0) { \
+      (b) |= GETWORD(p) << (k); \
+      (p) += 2; \
+      (k) -= 16; \
+    } \
+  } while(0)
+#define DUMPBITS(b,k,j) do { (k) += (j); (b) <<= (j); } while (0)
+#define BITVALUE(b,j) ((b)>>(32-(j)))
+/* }}} */
+/* {{{ [fold] **** qc_mjpeg_lvc:     MJPEG decoding: variable length code decoding **************** */
+
+/* {{{ [fold] u8 shiftTables[18][64] */
+static const u8 shiftTables[18][64] = {
+	{2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+	 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 },
+	{2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+	 1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2 },
+	{2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,
+	 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2 },
+	{2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
+	 2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3 },
+	{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,
+	 3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3 },
+	{2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
+	 3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4 },
+	{2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,
+	 4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4 },
+	{2,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
+	 4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5 },
+	{2,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,
+	 6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6 },
+	{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
+	 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2 },
+	{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
+	 2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3 },
+	{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,
+	 3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3 },
+	{2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
+	 3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4 },
+	{2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,
+	 4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4 },
+	{2,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
+	 4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5 },
+	{2,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,
+	 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5 },
+	{2,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+	 5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6 },
+	{2,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,
+	 7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7 },
+};
+/* }}} */
+/* {{{ [fold] u8 shiftTblIndex[] */
+static const u8 shiftTblIndex[] = {
+	8, 17, 8, 16, 7, 16, 7, 15, 
+	6, 15, 6, 14, 5, 14, 5, 13,
+	4, 13, 4, 12, 3, 12, 3, 11,
+	2, 11, 2, 10, 1,  9, 0,  9
+};
+/* }}} */
+/* {{{ [fold] s16 scaleTable[64] */
+static const s16 scaleTable[64] = {
+	 8192, 16704, 16704, 17733, 17032, 17733, 18204, 18081,
+	18081, 18204, 18724, 18561, 19195, 18561, 18724, 19265,
+	19091, 19704, 19704, 19091, 19265, 21406, 19642, 20267,
+	20228, 20267, 19642, 21406, 22725, 21826, 20852, 20805,
+	20805, 20852, 21826, 22725, 23170, 23170, 21406, 21399,
+	21406, 23170, 23170, 24597, 23785, 22017, 22017, 23785,
+	24597, 25250, 24464, 22653, 24464, 25250, 25971, 25171,
+	25171, 25971, 26722, 27969, 26722, 29691, 29691, 31520
+};
+/* }}} */
+/* {{{ [fold] u8 scan_norm[64] */
+static const u8 scan_norm[64] = {	/* Octals */
+	000, 001, 010, 020, 011, 002, 003, 012, 
+	021, 030, 040, 031, 022, 013, 004, 005, 
+	014, 023, 032, 041, 050, 060, 051, 042,
+	033, 024, 015, 006, 007, 016, 025, 034, 
+	043, 052, 061, 070, 071, 062, 053, 044,
+	035, 026, 017, 027, 036, 045, 054, 063, 
+	072, 073, 064, 055, 046, 037, 047, 056, 
+	065, 074, 075, 066, 057, 067, 076, 077
+};
+/* }}} */
+/* {{{ [fold] hufftable[960] */
+struct hufftable_entry {
+	s16 value;
+	u8  bits;
+	u8  skip;
+};
+static const struct hufftable_entry hufftable[960] = {
+	/* first level entries */
+	{     1,  3,   1 },
+	{     1,  3,   1 },
+	{     1,  3,   1 },
+	{     1,  3,   1 },
+	{     1,  3,   1 },
+	{     1,  3,   1 },
+	{     1,  3,   1 },
+	{     1,  3,   1 },
+	{     1,  3,   1 },
+	{     1,  3,   1 },
+	{     1,  3,   1 },
+	{     1,  3,   1 },
+	{     1,  3,   1 },
+	{     1,  3,   1 },
+	{     1,  3,   1 },
+	{     1,  3,   1 },
+	{     1,  3,   1 },
+	{     1,  3,   1 },
+	{     1,  3,   1 },
+	{     1,  3,   1 },
+	{     1,  3,   1 },
+	{     1,  3,   1 },
+	{     1,  3,   1 },
+	{     1,  3,   1 },
+	{     1,  3,   1 },
+	{     1,  3,   1 },
+	{     1,  3,   1 },
+	{     1,  3,   1 },
+	{     1,  3,   1 },
+	{     1,  3,   1 },
+	{     1,  3,   1 },
+	{     1,  3,   1 },
+	{    -1,  3,   1 },
+	{    -1,  3,   1 },
+	{    -1,  3,   1 },
+	{    -1,  3,   1 },
+	{    -1,  3,   1 },
+	{    -1,  3,   1 },
+	{    -1,  3,   1 },
+	{    -1,  3,   1 },
+	{    -1,  3,   1 },
+	{    -1,  3,   1 },
+	{    -1,  3,   1 },
+	{    -1,  3,   1 },
+	{    -1,  3,   1 },
+	{    -1,  3,   1 },
+	{    -1,  3,   1 },
+	{    -1,  3,   1 },
+	{    -1,  3,   1 },
+	{    -1,  3,   1 },
+	{    -1,  3,   1 },
+	{    -1,  3,   1 },
+	{    -1,  3,   1 },
+	{    -1,  3,   1 },
+	{    -1,  3,   1 },
+	{    -1,  3,   1 },
+	{    -1,  3,   1 },
+	{    -1,  3,   1 },
+	{    -1,  3,   1 },
+	{    -1,  3,   1 },
+	{    -1,  3,   1 },
+	{    -1,  3,   1 },
+	{    -1,  3,   1 },
+	{    -1,  3,   1 },
+	{     2,  4,   1 },
+	{     2,  4,   1 },
+	{     2,  4,   1 },
+	{     2,  4,   1 },
+	{     2,  4,   1 },
+	{     2,  4,   1 },
+	{     2,  4,   1 },
+	{     2,  4,   1 },
+	{     2,  4,   1 },
+	{     2,  4,   1 },
+	{     2,  4,   1 },
+	{     2,  4,   1 },
+	{     2,  4,   1 },
+	{     2,  4,   1 },
+	{     2,  4,   1 },
+	{     2,  4,   1 },
+	{    -2,  4,   1 },
+	{    -2,  4,   1 },
+	{    -2,  4,   1 },
+	{    -2,  4,   1 },
+	{    -2,  4,   1 },
+	{    -2,  4,   1 },
+	{    -2,  4,   1 },
+	{    -2,  4,   1 },
+	{    -2,  4,   1 },
+	{    -2,  4,   1 },
+	{    -2,  4,   1 },
+	{    -2,  4,   1 },
+	{    -2,  4,   1 },
+	{    -2,  4,   1 },
+	{    -2,  4,   1 },
+	{    -2,  4,   1 },
+	{ 32767,  4, 255 },
+	{ 32767,  4, 255 },
+	{ 32767,  4, 255 },
+	{ 32767,  4, 255 },
+	{ 32767,  4, 255 },
+	{ 32767,  4, 255 },
+	{ 32767,  4, 255 },
+	{ 32767,  4, 255 },
+	{ 32767,  4, 255 },
+	{ 32767,  4, 255 },
+	{ 32767,  4, 255 },
+	{ 32767,  4, 255 },
+	{ 32767,  4, 255 },
+	{ 32767,  4, 255 },
+	{ 32767,  4, 255 },
+	{ 32767,  4, 255 },
+	{     1,  5,   2 },
+	{     1,  5,   2 },
+	{     1,  5,   2 },
+	{     1,  5,   2 },
+	{     1,  5,   2 },
+	{     1,  5,   2 },
+	{     1,  5,   2 },
+	{     1,  5,   2 },
+	{    -1,  5,   2 },
+	{    -1,  5,   2 },
+	{    -1,  5,   2 },
+	{    -1,  5,   2 },
+	{    -1,  5,   2 },
+	{    -1,  5,   2 },
+	{    -1,  5,   2 },
+	{    -1,  5,   2 },
+	{     3,  5,   1 },
+	{     3,  5,   1 },
+	{     3,  5,   1 },
+	{     3,  5,   1 },
+	{     3,  5,   1 },
+	{     3,  5,   1 },
+	{     3,  5,   1 },
+	{     3,  5,   1 },
+	{    -3,  5,   1 },
+	{    -3,  5,   1 },
+	{    -3,  5,   1 },
+	{    -3,  5,   1 },
+	{    -3,  5,   1 },
+	{    -3,  5,   1 },
+	{    -3,  5,   1 },
+	{    -3,  5,   1 },
+	{     4,  5,   1 },
+	{     4,  5,   1 },
+	{     4,  5,   1 },
+	{     4,  5,   1 },
+	{     4,  5,   1 },
+	{     4,  5,   1 },
+	{     4,  5,   1 },
+	{     4,  5,   1 },
+	{    -4,  5,   1 },
+	{    -4,  5,   1 },
+	{    -4,  5,   1 },
+	{    -4,  5,   1 },
+	{    -4,  5,   1 },
+	{    -4,  5,   1 },
+	{    -4,  5,   1 },
+	{    -4,  5,   1 },
+	{     1,  6,   3 },
+	{     1,  6,   3 },
+	{     1,  6,   3 },
+	{     1,  6,   3 },
+	{    -1,  6,   3 },
+	{    -1,  6,   3 },
+	{    -1,  6,   3 },
+	{    -1,  6,   3 },
+	{     2,  6,   2 },
+	{     2,  6,   2 },
+	{     2,  6,   2 },
+	{     2,  6,   2 },
+	{    -2,  6,   2 },
+	{    -2,  6,   2 },
+	{    -2,  6,   2 },
+	{    -2,  6,   2 },
+	{     5,  6,   1 },
+	{     5,  6,   1 },
+	{     5,  6,   1 },
+	{     5,  6,   1 },
+	{    -5,  6,   1 },
+	{    -5,  6,   1 },
+	{    -5,  6,   1 },
+	{    -5,  6,   1 },
+	{     6,  6,   1 },
+	{     6,  6,   1 },
+	{     6,  6,   1 },
+	{     6,  6,   1 },
+	{    -6,  6,   1 },
+	{    -6,  6,   1 },
+	{    -6,  6,   1 },
+	{    -6,  6,   1 },
+	{     1,  7,   4 },
+	{     1,  7,   4 },
+	{    -1,  7,   4 },
+	{    -1,  7,   4 },
+	{     1,  7,   5 },
+	{     1,  7,   5 },
+	{    -1,  7,   5 },
+	{    -1,  7,   5 },
+	{     7,  7,   1 },
+	{     7,  7,   1 },
+	{    -7,  7,   1 },
+	{    -7,  7,   1 },
+	{     8,  7,   1 },
+	{     8,  7,   1 },
+	{    -8,  7,   1 },
+	{    -8,  7,   1 },
+	{     1,  8,   6 },
+	{    -1,  8,   6 },
+	{     1,  8,   7 },
+	{    -1,  8,   7 },
+	{     2,  8,   3 },
+	{    -2,  8,   3 },
+	{     3,  8,   2 },
+	{    -3,  8,   2 },
+	{     4,  8,   2 },
+	{    -4,  8,   2 },
+	{     9,  8,   1 },
+	{    -9,  8,   1 },
+	{    10,  8,   1 },
+	{   -10,  8,   1 },
+	{    11,  8,   1 },
+	{   -11,  8,   1 },
+	{   256,  9,  99 },
+	{   258,  9,  99 },
+	{   260,  9,  99 },
+	{   262,  9,  99 },
+	{   264,  9,  99 },
+	{   266,  9,  99 },
+	{   268,  9,  99 },
+	{   270,  9,  99 },
+	{   272,  9,  99 },
+	{   274,  9,  99 },
+	{   276,  9,  99 },
+	{   278,  9,  99 },
+	{   280,  9,  99 },
+	{   282,  9,  99 },
+	{   284,  9,  99 },
+	{   286,  9,  99 },
+	{   288, 10,  99 },
+	{   292, 10,  99 },
+	{   296, 10,  99 },
+	{   300, 10,  99 },
+	{   304, 10,  99 },
+	{   308, 10,  99 },
+	{   312, 10,  99 },
+	{   316, 10,  99 },
+	{   320, 11,  99 },
+	{   328, 11,  99 },
+	{   336, 12,  99 },
+	{   352, 13,  99 },
+	{   384, 13,  99 },
+	{   416, 13,  99 },
+	{   448, 16,  99 },
+	{   704, 16,  99 },
+	/* indirect entries */
+	{     1,  9,   8 },
+	{    -1,  9,   8 },
+	{     1,  9,   9 },
+	{    -1,  9,   9 },
+	{     1,  9,  10 },
+	{    -1,  9,  10 },
+	{     1,  9,  11 },
+	{    -1,  9,  11 },
+	{     2,  9,   4 },
+	{    -2,  9,   4 },
+	{     2,  9,   5 },
+	{    -2,  9,   5 },
+	{     3,  9,   3 },
+	{    -3,  9,   3 },
+	{     5,  9,   2 },
+	{    -5,  9,   2 },
+	{     6,  9,   2 },
+	{    -6,  9,   2 },
+	{     7,  9,   2 },
+	{    -7,  9,   2 },
+	{    12,  9,   1 },
+	{   -12,  9,   1 },
+	{    13,  9,   1 },
+	{   -13,  9,   1 },
+	{    14,  9,   1 },
+	{   -14,  9,   1 },
+	{    15,  9,   1 },
+	{   -15,  9,   1 },
+	{    16,  9,   1 },
+	{   -16,  9,   1 },
+	{    17,  9,   1 },
+	{   -17,  9,   1 },
+	{     1, 10,  12 },
+	{    -1, 10,  12 },
+	{     1, 10,  13 },
+	{    -1, 10,  13 },
+	{     1, 10,  14 },
+	{    -1, 10,  14 },
+	{     1, 10,  15 },
+	{    -1, 10,  15 },
+	{     2, 10,   6 },
+	{    -2, 10,   6 },
+	{     2, 10,   7 },
+	{    -2, 10,   7 },
+	{     3, 10,   4 },
+	{    -3, 10,   4 },
+	{     3, 10,   5 },
+	{    -3, 10,   5 },
+	{     4, 10,   3 },
+	{    -4, 10,   3 },
+	{     5, 10,   3 },
+	{    -5, 10,   3 },
+	{     8, 10,   2 },
+	{    -8, 10,   2 },
+	{    18, 10,   1 },
+	{   -18, 10,   1 },
+	{    19, 10,   1 },
+	{   -19, 10,   1 },
+	{    20, 10,   1 },
+	{   -20, 10,   1 },
+	{    21, 10,   1 },
+	{   -21, 10,   1 },
+	{    22, 10,   1 },
+	{   -22, 10,   1 },
+	{     3, 11,   6 },
+	{    -3, 11,   6 },
+	{     4, 11,   4 },
+	{    -4, 11,   4 },
+	{     5, 11,   4 },
+	{    -5, 11,   4 },
+	{     6, 11,   3 },
+	{    -6, 11,   3 },
+	{     9, 11,   2 },
+	{    -9, 11,   2 },
+	{    10, 11,   2 },
+	{   -10, 11,   2 },
+	{    11, 11,   2 },
+	{   -11, 11,   2 },
+	{     0, 11,   1 },
+	{     0, 11,   2 },
+	{     3, 12,   7 },
+	{    -3, 12,   7 },
+	{     4, 12,   5 },
+	{    -4, 12,   5 },
+	{     6, 12,   4 },
+	{    -6, 12,   4 },
+	{    12, 12,   2 },
+	{   -12, 12,   2 },
+	{    13, 12,   2 },
+	{   -13, 12,   2 },
+	{    14, 12,   2 },
+	{   -14, 12,   2 },
+	{     0, 12,   3 },
+	{     0, 12,   4 },
+	{     0, 12,   5 },
+	{     0, 12,   6 },
+	{     2, 13,   8 },
+	{    -2, 13,   8 },
+	{     2, 13,   9 },
+	{    -2, 13,   9 },
+	{     2, 13,  10 },
+	{    -2, 13,  10 },
+	{     2, 13,  11 },
+	{    -2, 13,  11 },
+	{     3, 13,   8 },
+	{    -3, 13,   8 },
+	{     3, 13,   9 },
+	{    -3, 13,   9 },
+	{     5, 13,   5 },
+	{    -5, 13,   5 },
+	{     7, 13,   4 },
+	{    -7, 13,   4 },
+	{     7, 13,   3 },
+	{    -7, 13,   3 },
+	{     8, 13,   3 },
+	{    -8, 13,   3 },
+	{     9, 13,   3 },
+	{    -9, 13,   3 },
+	{    10, 13,   3 },
+	{   -10, 13,   3 },
+	{    11, 13,   3 },
+	{   -11, 13,   3 },
+	{    15, 13,   2 },
+	{   -15, 13,   2 },
+	{    16, 13,   2 },
+	{   -16, 13,   2 },
+	{    17, 13,   2 },
+	{   -17, 13,   2 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{     0, 13,   7 },
+	{     0, 13,   8 },
+	{     0, 13,   9 },
+	{     0, 13,  10 },
+	{     0, 13,  11 },
+	{     0, 13,  12 },
+	{     0, 13,  13 },
+	{     0, 13,  14 },
+	{     0, 13,  15 },
+	{     0, 13,  16 },
+	{     0, 13,  17 },
+	{     0, 13,  18 },
+	{     0, 13,  19 },
+	{     0, 13,  20 },
+	{     0, 13,  21 },
+	{     0, 13,  22 },
+	{     0, 13,  23 },
+	{     0, 13,  24 },
+	{     0, 13,  25 },
+	{     0, 13,  26 },
+	{     0, 13,  27 },
+	{     0, 13,  28 },
+	{     0, 13,  29 },
+	{     0, 13,  30 },
+	{     0, 13,  31 },
+	{     0, 13,  32 },
+	{     0, 13,  33 },
+	{     0, 13,  34 },
+	{     0, 13,  35 },
+	{     0, 13,  36 },
+	{     0, 13,  37 },
+	{     0, 13,  38 },
+	{     0, 13,  39 },
+	{     0, 13,  40 },
+	{     0, 13,  41 },
+	{     0, 13,  42 },
+	{     0, 13,  43 },
+	{     0, 13,  44 },
+	{     0, 13,  45 },
+	{     0, 13,  46 },
+	{     0, 13,  47 },
+	{     0, 13,  48 },
+	{     0, 13,  49 },
+	{     0, 13,  50 },
+	{     0, 13,  51 },
+	{     0, 13,  52 },
+	{     0, 13,  53 },
+	{     0, 13,  54 },
+	{     0, 13,  55 },
+	{     0, 13,  56 },
+	{     0, 13,  57 },
+	{     0, 13,  58 },
+	{     0, 13,  59 },
+	{     0, 13,  60 },
+	{     0, 13,  61 },
+	{     0, 13,  62 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{ 32767,  0, 255 },
+	{    23, 16,   1 },
+	{   -23, 16,   1 },
+	{    24, 16,   1 },
+	{   -24, 16,   1 },
+	{    25, 16,   1 },
+	{   -25, 16,   1 },
+	{    26, 16,   1 },
+	{   -26, 16,   1 },
+	{    27, 16,   1 },
+	{   -27, 16,   1 },
+	{    28, 16,   1 },
+	{   -28, 16,   1 },
+	{    29, 16,   1 },
+	{   -29, 16,   1 },
+	{    30, 16,   1 },
+	{   -30, 16,   1 },
+	{    31, 16,   1 },
+	{   -31, 16,   1 },
+	{    32, 16,   1 },
+	{   -32, 16,   1 },
+	{    33, 16,   1 },
+	{   -33, 16,   1 },
+	{    34, 16,   1 },
+	{   -34, 16,   1 },
+	{    35, 16,   1 },
+	{   -35, 16,   1 },
+	{    36, 16,   1 },
+	{   -36, 16,   1 },
+	{    37, 16,   1 },
+	{   -37, 16,   1 },
+	{    38, 16,   1 },
+	{   -38, 16,   1 },
+	{    39, 16,   1 },
+	{   -39, 16,   1 },
+	{    40, 16,   1 },
+	{   -40, 16,   1 },
+	{    41, 16,   1 },
+	{   -41, 16,   1 },
+	{    42, 16,   1 },
+	{   -42, 16,   1 },
+	{    43, 16,   1 },
+	{   -43, 16,   1 },
+	{    44, 16,   1 },
+	{   -44, 16,   1 },
+	{    45, 16,   1 },
+	{   -45, 16,   1 },
+	{    46, 16,   1 },
+	{   -46, 16,   1 },
+	{    47, 16,   1 },
+	{   -47, 16,   1 },
+	{    48, 16,   1 },
+	{   -48, 16,   1 },
+	{    49, 16,   1 },
+	{   -49, 16,   1 },
+	{    50, 16,   1 },
+	{   -50, 16,   1 },
+	{    51, 16,   1 },
+	{   -51, 16,   1 },
+	{    52, 16,   1 },
+	{   -52, 16,   1 },
+	{    53, 16,   1 },
+	{   -53, 16,   1 },
+	{    54, 16,   1 },
+	{   -54, 16,   1 },
+	{    55, 16,   1 },
+	{   -55, 16,   1 },
+	{    56, 16,   1 },
+	{   -56, 16,   1 },
+	{    57, 16,   1 },
+	{   -57, 16,   1 },
+	{    58, 16,   1 },
+	{   -58, 16,   1 },
+	{    59, 16,   1 },
+	{   -59, 16,   1 },
+	{    60, 16,   1 },
+	{   -60, 16,   1 },
+	{    61, 16,   1 },
+	{   -61, 16,   1 },
+	{    62, 16,   1 },
+	{   -62, 16,   1 },
+	{    63, 16,   1 },
+	{   -63, 16,   1 },
+	{    64, 16,   1 },
+	{   -64, 16,   1 },
+	{    65, 16,   1 },
+	{   -65, 16,   1 },
+	{    66, 16,   1 },
+	{   -66, 16,   1 },
+	{    67, 16,   1 },
+	{   -67, 16,   1 },
+	{    68, 16,   1 },
+	{   -68, 16,   1 },
+	{    69, 16,   1 },
+	{   -69, 16,   1 },
+	{    70, 16,   1 },
+	{   -70, 16,   1 },
+	{    71, 16,   1 },
+	{   -71, 16,   1 },
+	{    72, 16,   1 },
+	{   -72, 16,   1 },
+	{    73, 16,   1 },
+	{   -73, 16,   1 },
+	{    74, 16,   1 },
+	{   -74, 16,   1 },
+	{    75, 16,   1 },
+	{   -75, 16,   1 },
+	{    76, 16,   1 },
+	{   -76, 16,   1 },
+	{    77, 16,   1 },
+	{   -77, 16,   1 },
+	{    78, 16,   1 },
+	{   -78, 16,   1 },
+	{    79, 16,   1 },
+	{   -79, 16,   1 },
+	{    80, 16,   1 },
+	{   -80, 16,   1 },
+	{    81, 16,   1 },
+	{   -81, 16,   1 },
+	{    82, 16,   1 },
+	{   -82, 16,   1 },
+	{    83, 16,   1 },
+	{   -83, 16,   1 },
+	{    84, 16,   1 },
+	{   -84, 16,   1 },
+	{    85, 16,   1 },
+	{   -85, 16,   1 },
+	{    86, 16,   1 },
+	{   -86, 16,   1 },
+	{    87, 16,   1 },
+	{   -87, 16,   1 },
+	{    88, 16,   1 },
+	{   -88, 16,   1 },
+	{    89, 16,   1 },
+	{   -89, 16,   1 },
+	{    90, 16,   1 },
+	{   -90, 16,   1 },
+	{    91, 16,   1 },
+	{   -91, 16,   1 },
+	{    92, 16,   1 },
+	{   -92, 16,   1 },
+	{    93, 16,   1 },
+	{   -93, 16,   1 },
+	{    94, 16,   1 },
+	{   -94, 16,   1 },
+	{    95, 16,   1 },
+	{   -95, 16,   1 },
+	{    96, 16,   1 },
+	{   -96, 16,   1 },
+	{    97, 16,   1 },
+	{   -97, 16,   1 },
+	{    98, 16,   1 },
+	{   -98, 16,   1 },
+	{    99, 16,   1 },
+	{   -99, 16,   1 },
+	{   100, 16,   1 },
+	{  -100, 16,   1 },
+	{   101, 16,   1 },
+	{  -101, 16,   1 },
+	{   102, 16,   1 },
+	{  -102, 16,   1 },
+	{   103, 16,   1 },
+	{  -103, 16,   1 },
+	{   104, 16,   1 },
+	{  -104, 16,   1 },
+	{   105, 16,   1 },
+	{  -105, 16,   1 },
+	{   106, 16,   1 },
+	{  -106, 16,   1 },
+	{   107, 16,   1 },
+	{  -107, 16,   1 },
+	{   108, 16,   1 },
+	{  -108, 16,   1 },
+	{   109, 16,   1 },
+	{  -109, 16,   1 },
+	{   110, 16,   1 },
+	{  -110, 16,   1 },
+	{   111, 16,   1 },
+	{  -111, 16,   1 },
+	{   112, 16,   1 },
+	{  -112, 16,   1 },
+	{   113, 16,   1 },
+	{  -113, 16,   1 },
+	{   114, 16,   1 },
+	{  -114, 16,   1 },
+	{   115, 16,   1 },
+	{  -115, 16,   1 },
+	{   116, 16,   1 },
+	{  -116, 16,   1 },
+	{   117, 16,   1 },
+	{  -117, 16,   1 },
+	{   118, 16,   1 },
+	{  -118, 16,   1 },
+	{   119, 16,   1 },
+	{  -119, 16,   1 },
+	{   120, 16,   1 },
+	{  -120, 16,   1 },
+	{   121, 16,   1 },
+	{  -121, 16,   1 },
+	{   122, 16,   1 },
+	{  -122, 16,   1 },
+	{   123, 16,   1 },
+	{  -123, 16,   1 },
+	{   124, 16,   1 },
+	{  -124, 16,   1 },
+	{   125, 16,   1 },
+	{  -125, 16,   1 },
+	{   126, 16,   1 },
+	{  -126, 16,   1 },
+	{   127, 16,   1 },
+	{  -127, 16,   1 },
+	{   128, 16,   1 },
+	{  -128, 16,   1 },
+	{   129, 16,   1 },
+	{  -129, 16,   1 },
+	{   130, 16,   1 },
+	{  -130, 16,   1 },
+	{   131, 16,   1 },
+	{  -131, 16,   1 },
+	{   132, 16,   1 },
+	{  -132, 16,   1 },
+	{   133, 16,   1 },
+	{  -133, 16,   1 },
+	{   134, 16,   1 },
+	{  -134, 16,   1 },
+	{   135, 16,   1 },
+	{  -135, 16,   1 },
+	{   136, 16,   1 },
+	{  -136, 16,   1 },
+	{   137, 16,   1 },
+	{  -137, 16,   1 },
+	{   138, 16,   1 },
+	{  -138, 16,   1 },
+	{   139, 16,   1 },
+	{  -139, 16,   1 },
+	{   140, 16,   1 },
+	{  -140, 16,   1 },
+	{   141, 16,   1 },
+	{  -141, 16,   1 },
+	{   142, 16,   1 },
+	{  -142, 16,   1 },
+	{   143, 16,   1 },
+	{  -143, 16,   1 },
+	{   144, 16,   1 },
+	{  -144, 16,   1 },
+	{   145, 16,   1 },
+	{  -145, 16,   1 },
+	{   146, 16,   1 },
+	{  -146, 16,   1 },
+	{   147, 16,   1 },
+	{  -147, 16,   1 },
+	{   148, 16,   1 },
+	{  -148, 16,   1 },
+	{   149, 16,   1 },
+	{  -149, 16,   1 },
+	{   150, 16,   1 },
+	{  -150, 16,   1 },
+	{   151, 16,   1 },
+	{  -151, 16,   1 },
+	{   152, 16,   1 },
+	{  -152, 16,   1 },
+	{   153, 16,   1 },
+	{  -153, 16,   1 },
+	{   154, 16,   1 },
+	{  -154, 16,   1 },
+	{   155, 16,   1 },
+	{  -155, 16,   1 },
+	{   156, 16,   1 },
+	{  -156, 16,   1 },
+	{   157, 16,   1 },
+	{  -157, 16,   1 },
+	{   158, 16,   1 },
+	{  -158, 16,   1 },
+	{   159, 16,   1 },
+	{  -159, 16,   1 },
+	{   160, 16,   1 },
+	{  -160, 16,   1 },
+	{   161, 16,   1 },
+	{  -161, 16,   1 },
+	{   162, 16,   1 },
+	{  -162, 16,   1 },
+	{   163, 16,   1 },
+	{  -163, 16,   1 },
+	{   164, 16,   1 },
+	{  -164, 16,   1 },
+	{   165, 16,   1 },
+	{  -165, 16,   1 },
+	{   166, 16,   1 },
+	{  -166, 16,   1 },
+	{   167, 16,   1 },
+	{  -167, 16,   1 },
+	{   168, 16,   1 },
+	{  -168, 16,   1 },
+	{   169, 16,   1 },
+	{  -169, 16,   1 },
+	{   170, 16,   1 },
+	{  -170, 16,   1 },
+	{   171, 16,   1 },
+	{  -171, 16,   1 },
+	{   172, 16,   1 },
+	{  -172, 16,   1 },
+	{   173, 16,   1 },
+	{  -173, 16,   1 },
+	{   174, 16,   1 },
+	{  -174, 16,   1 },
+	{   175, 16,   1 },
+	{  -175, 16,   1 },
+	{   176, 16,   1 },
+	{  -176, 16,   1 },
+	{   177, 16,   1 },
+	{  -177, 16,   1 },
+	{   178, 16,   1 },
+	{  -178, 16,   1 },
+	{   179, 16,   1 },
+	{  -179, 16,   1 },
+	{   180, 16,   1 },
+	{  -180, 16,   1 },
+	{   181, 16,   1 },
+	{  -181, 16,   1 },
+	{   182, 16,   1 },
+	{  -182, 16,   1 },
+	{   183, 16,   1 },
+	{  -183, 16,   1 },
+	{   184, 16,   1 },
+	{  -184, 16,   1 },
+	{   185, 16,   1 },
+	{  -185, 16,   1 },
+	{   186, 16,   1 },
+	{  -186, 16,   1 },
+	{   187, 16,   1 },
+	{  -187, 16,   1 },
+	{   188, 16,   1 },
+	{  -188, 16,   1 },
+	{   189, 16,   1 },
+	{  -189, 16,   1 },
+	{   190, 16,   1 },
+	{  -190, 16,   1 },
+	{   191, 16,   1 },
+	{  -191, 16,   1 },
+	{   192, 16,   1 },
+	{  -192, 16,   1 },
+	{   193, 16,   1 },
+	{  -193, 16,   1 },
+	{   194, 16,   1 },
+	{  -194, 16,   1 },
+	{   195, 16,   1 },
+	{  -195, 16,   1 },
+	{   196, 16,   1 },
+	{  -196, 16,   1 },
+	{   197, 16,   1 },
+	{  -197, 16,   1 },
+	{   198, 16,   1 },
+	{  -198, 16,   1 },
+	{   199, 16,   1 },
+	{  -199, 16,   1 },
+	{   200, 16,   1 },
+	{  -200, 16,   1 },
+	{   201, 16,   1 },
+	{  -201, 16,   1 },
+	{   202, 16,   1 },
+	{  -202, 16,   1 },
+	{   203, 16,   1 },
+	{  -203, 16,   1 },
+	{   204, 16,   1 },
+	{  -204, 16,   1 },
+	{   205, 16,   1 },
+	{  -205, 16,   1 },
+	{   206, 16,   1 },
+	{  -206, 16,   1 },
+	{   207, 16,   1 },
+	{  -207, 16,   1 },
+	{   208, 16,   1 },
+	{  -208, 16,   1 },
+	{   209, 16,   1 },
+	{  -209, 16,   1 },
+	{   210, 16,   1 },
+	{  -210, 16,   1 },
+	{   211, 16,   1 },
+	{  -211, 16,   1 },
+	{   212, 16,   1 },
+	{  -212, 16,   1 },
+	{   213, 16,   1 },
+	{  -213, 16,   1 },
+	{   214, 16,   1 },
+	{  -214, 16,   1 },
+	{   215, 16,   1 },
+	{  -215, 16,   1 },
+	{   216, 16,   1 },
+	{  -216, 16,   1 },
+	{   217, 16,   1 },
+	{  -217, 16,   1 },
+	{   218, 16,   1 },
+	{  -218, 16,   1 },
+	{   219, 16,   1 },
+	{  -219, 16,   1 },
+	{   220, 16,   1 },
+	{  -220, 16,   1 },
+	{   221, 16,   1 },
+	{  -221, 16,   1 },
+	{   222, 16,   1 },
+	{  -222, 16,   1 },
+	{   223, 16,   1 },
+	{  -223, 16,   1 },
+	{   224, 16,   1 },
+	{  -224, 16,   1 },
+	{   225, 16,   1 },
+	{  -225, 16,   1 },
+	{   226, 16,   1 },
+	{  -226, 16,   1 },
+	{   227, 16,   1 },
+	{  -227, 16,   1 },
+	{   228, 16,   1 },
+	{  -228, 16,   1 },
+	{   229, 16,   1 },
+	{  -229, 16,   1 },
+	{   230, 16,   1 },
+	{  -230, 16,   1 },
+	{   231, 16,   1 },
+	{  -231, 16,   1 },
+	{   232, 16,   1 },
+	{  -232, 16,   1 },
+	{   233, 16,   1 },
+	{  -233, 16,   1 },
+	{   234, 16,   1 },
+	{  -234, 16,   1 },
+	{   235, 16,   1 },
+	{  -235, 16,   1 },
+	{   236, 16,   1 },
+	{  -236, 16,   1 },
+	{   237, 16,   1 },
+	{  -237, 16,   1 },
+	{   238, 16,   1 },
+	{  -238, 16,   1 },
+	{   239, 16,   1 },
+	{  -239, 16,   1 },
+	{   240, 16,   1 },
+	{  -240, 16,   1 },
+	{   241, 16,   1 },
+	{  -241, 16,   1 },
+	{   242, 16,   1 },
+	{  -242, 16,   1 },
+	{   243, 16,   1 },
+	{  -243, 16,   1 },
+	{   244, 16,   1 },
+	{  -244, 16,   1 },
+	{   245, 16,   1 },
+	{  -245, 16,   1 },
+	{   246, 16,   1 },
+	{  -246, 16,   1 },
+	{   247, 16,   1 },
+	{  -247, 16,   1 },
+	{   248, 16,   1 },
+	{  -248, 16,   1 },
+	{   249, 16,   1 },
+	{  -249, 16,   1 },
+	{   250, 16,   1 },
+	{  -250, 16,   1 },
+	{   251, 16,   1 },
+	{  -251, 16,   1 },
+	{   252, 16,   1 },
+	{  -252, 16,   1 },
+	{   253, 16,   1 },
+	{  -253, 16,   1 },
+	{   254, 16,   1 },
+	{  -254, 16,   1 },
+	{   255, 16,   1 },
+	{  -255, 16,   1 }
+};
+/* }}} */
+/* {{{ [fold] qc_mjpeg_lvc_decode_block(struct bitstream *bitsrc, s16 *output, int blockval) */
+static inline void qc_mjpeg_lvc_decode_block(struct bitstream *bitsrc, s16 *output, int blockval)
+{
+	u32 b;
+	u8 *p;
+	int k;
+	int value, skip, bits;
+	struct hufftable_entry entry;
+	int offset = 0;
+	const u8 *shiftPtr;
+
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_mjpeg_lvc_decode_block(bitsrc=%p, output=%p, blockval=%i)", bitsrc, output, blockval);
+	b = bitsrc->b;
+	k = bitsrc->k;
+	p = bitsrc->p;
+	memset(output, 0, 64 * sizeof(s16));
+	if (blockval!=7) PDEBUG("blockval=%i",blockval);
+	NEEDBITS(b,k,p);
+	shiftPtr = shiftTables[shiftTblIndex[2*blockval+BITVALUE(b,1)]];
+	DUMPBITS(b,k,1);
+	value = BITVALUE(((signed)b),10);
+	DUMPBITS(b,k,10);
+	do {
+		value = ((value << shiftPtr[offset]) * scaleTable[offset]) >> 14;
+		output[scan_norm[offset]] = value;
+		NEEDBITS(b,k,p);
+		entry = hufftable[BITVALUE(b,8)];
+		bits = entry.bits;
+		if (bits > 8) {
+			entry = hufftable[entry.value + ((b & 0x00ffffff) >> (32 - bits))];
+			if (PARANOID && entry.bits!=bits) {
+				PDEBUG("entry.bits!=bits shouldn't happen");
+				bits = entry.bits;
+			}
+		}
+		DUMPBITS(b,k,bits);
+		skip = entry.skip;
+		value = entry.value;
+		offset += skip;
+	} while (offset < 64);
+	bitsrc->b = b;
+	bitsrc->k = k;
+	bitsrc->p = p;
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_mjpeg_lvc_decode_block() exit");
+}
+/* }}} */
+
+/* {{{ [fold] struct blockorder */
+struct blockorder {
+	char widthPad;		/* pad width to multiple of this */
+	char heightPad;		/* pad height to multiple of this */
+	char uvWshift;		/* shift width by this to get width of U/V image */
+	char uvHshift;		/* dito for height */
+	char blockWidth[2];	/* width of a block for each pass*/
+	char subblockCount[2];	/* number of sub block in a block for each pass */
+	u32 subblockMap[2];
+};
+static const struct blockorder order_I420 = {
+	32, 16, 1, 1,
+	{ 32, 16 }, { 4, 4 },
+	{ 0x00, 0x90 }
+};
+#if 0
+static const struct blockorder order_L422 = {
+	16, 16, 1, 0, 
+	{ 16, 16 }, { 4, 4 },
+	{ 0x90, 0x90 }
+};
+
+static const struct blockorder order_L410 = {
+	64, 16, 2, 1,
+	{ 32, 64 }, { 4, 12 },
+	{ 0x00, 0x909000 }
+};
+#endif
+/* }}} */
+/* {{{ [fold] qc_mjpeg_lvc_decode() */
+/* Decode given compressed image to YUV image. Return error code if bad data */
+static int qc_mjpeg_lvc_decode(u8 *outY, u8 *outU, u8 *outV,
+	u8 *input, u32 length, unsigned int width, unsigned int height)
+{
+	struct bitstream stream;
+	const struct blockorder *blkorder;
+
+	unsigned int blockx, blocky;
+	unsigned int pass, subblock, blockval = 0;
+	unsigned int blocknr = 0;
+	unsigned int uvWidth;
+
+	s16 blockbuffer[64];
+
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_mjpeg_lvc_decode(outY=%p, outU=%p, outV=%p)", outY, outU, outV);
+	stream.b   = 0;
+	stream.k   = 16;
+	stream.p   = input;
+	stream.end = input+length;
+
+	blkorder = &order_I420;		/* Select compression type */
+
+	uvWidth = (width >> blkorder->uvWshift);
+
+	if ((width & (blkorder->widthPad - 1)) || (height & (blkorder->heightPad - 1))) {
+		PDEBUG("something's wrong");
+		return -EILSEQ;
+	}
+
+	for (blocky=0; blocky<height; blocky+=blkorder->heightPad) {
+		for (pass = 0; pass < 2; pass++) {
+			int blockwidth    = blkorder->blockWidth[pass];
+			int subblockcount = blkorder->subblockCount[pass];
+			u32 map = blkorder->subblockMap[pass];
+			for (blockx=0; blockx<width; blockx+=blockwidth) {
+				u32 subblkmap = map;
+				for (subblock=0; subblock<subblockcount; subblock++) {
+					if ((blocknr++ & 3) == 0) {
+						u32 b = stream.b;
+						int k = stream.k;
+						u8 *p = stream.p;
+
+						NEEDBITS(b, k, p);
+
+						/* Make sure from time to time that we don't read
+						 * far too much.  I hope it is okay to read a bit
+						 * beyond the end
+						 */
+						if (p > stream.end) {
+							PDEBUG("p>stream.end");
+							return -EILSEQ;
+						}
+
+						blockval = BITVALUE(b, 4);
+						DUMPBITS(b,k,4);
+						stream.b = b;
+						stream.k = k;
+						stream.p = p;
+					}
+					qc_mjpeg_lvc_decode_block(&stream, blockbuffer, blockval);
+					blockbuffer[0] += 1024;
+					switch (subblkmap & 3) {
+					case 0:
+						qc_mjpeg_idct(blockbuffer, outY, width);
+						outY += 8;
+						break;
+					case 1:
+						qc_mjpeg_idct(blockbuffer, outU, uvWidth);
+						outU += 8;
+						break;
+					case 2:
+						qc_mjpeg_idct(blockbuffer, outV, uvWidth);
+						outV += 8;
+						break;
+					}
+					subblkmap >>= 2;
+				} /* for (subblock = 0; subblock < subblockcount; subblock++) */
+			} /* for (blockx = 0; blockx < width; blockx += blockwidth) */
+			outY += 7 * width;
+			if (map) {
+				outU += 7 * uvWidth;
+				outV += 7 * uvWidth;
+			}
+		} /* for (pass = 0; pass < 2; pass++) */
+
+		/* next block starts at next 4 byte boundary */
+		stream.p -= (16 - stream.k) >> 3;  /* push back unread bits */
+		stream.p += (input - stream.p) & 3;
+		stream.k = 16;
+		stream.b = 0;
+	} /* for (blocky=0; blocky<height; blocky+=blkorder->heightPad) */
+
+	if (stream.p != stream.end) {
+		PDEBUG("stream.p != stream.end");
+		return -EILSEQ;
+	}
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_mjpeg_lvc_decode() done");
+	return 0;
+}
+/* }}} */
+
+/* }}} */
+/* {{{ [fold] **** qc_mjpeg:         Motion JPEG decoding main routines *************************** */
+
+static const int qc_mjpeg_width  = 320;		/* Size of the compressed image */
+static const int qc_mjpeg_height = 240;
+
+/* {{{ [fold] qc_mjpeg_decode() */
+/* Decode and uncompress given data, return error code if failure
+ * src = points to compressed bitstream data
+ * src_len = compressed data length in bytes
+ * dst = decompressed image will be stored here, size 320x240 x bytes per pixel (2-4)
+ */
+int qc_mjpeg_decode(struct qc_mjpeg_data *md, unsigned char *src, int src_len, unsigned char *dst)
+{
+	int r;
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_mjpeg_decode(src_len=%i,W=%i,H=%i,depth=%i)",src_len,qc_mjpeg_width,qc_mjpeg_height,md->depth);
+	IDEBUG_TEST(*md);
+	if (src_len >= 100000) {
+		PDEBUG("long frame, length=%i", src_len);
+		return -EILSEQ;
+	}
+	r = qc_mjpeg_lvc_decode(md->encY, md->encU, md->encV, src, src_len, qc_mjpeg_width, qc_mjpeg_height);
+	if (r<0) {
+		PRINTK(KERN_ERR,"frame corrupted, len=%i",src_len);
+		return r;
+	}
+	qc_mjpeg_yuv2rgb(md, dst, md->encY, md->encU, md->encV, 
+		qc_mjpeg_width, qc_mjpeg_height, 		/* Image size */
+		qc_mjpeg_width * ((md->depth+1)/8),		/* RGB stride */
+		qc_mjpeg_width,					/* Y stride */
+		qc_mjpeg_width/2);				/* U and V stride */
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_mjpeg_decode() done");
+	return 0;
+}
+/* }}} */
+/* {{{ [fold] qc_mjpeg_init(struct qc_mjpeg_data *md, int depth, Bool tobgr) */
+/* Initialize Motion JPEG decompression.
+ * depth = bit depth of the decoded image, either 15=16,24 or 32
+ * tobgr = use blue in the lowest address (red otherwise)
+ */
+int qc_mjpeg_init(struct qc_mjpeg_data *md, int depth, Bool tobgr)
+{
+	int r = -ENOMEM;
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_mjpeg_init(depth=%i)",depth);
+	md->depth = depth;
+	/* Temporary buffers used for decoding the image (FIXME:too big for stack?) */
+	/* Note: originally this allocated one extra byte for encY/U/V. I removed that. */
+	md->encY = kmalloc(qc_mjpeg_width*qc_mjpeg_height, GFP_KERNEL);	
+	if (!md->encY) goto fail1;
+	md->encU = kmalloc(qc_mjpeg_width*qc_mjpeg_height/4, GFP_KERNEL);
+	if (!md->encU) goto fail2;
+	md->encV = kmalloc(qc_mjpeg_width*qc_mjpeg_height/4, GFP_KERNEL);
+	if (!md->encV) goto fail3;
+	if ((r=qc_mjpeg_yuv2rgb_init(md, depth, tobgr ? MODE_BGR : MODE_RGB))<0) goto fail4;
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_mjpeg_init() done");
+	IDEBUG_INIT(*md);
+	return 0;
+
+fail4:	kfree(md->encV);
+fail3:	kfree(md->encU);
+fail2:	kfree(md->encY);
+fail1:	PDEBUG("failed qc_mjpeg_init() = %i", r);
+	POISON(*md);
+	return r;
+}
+/* }}} */
+/* {{{ [fold] qc_mjpeg_exit(struct qc_mjpeg_data *md) */
+/* Free up resources allocated for image decompression */
+void qc_mjpeg_exit(struct qc_mjpeg_data *md)
+{
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_mjpeg_exit()");
+	IDEBUG_TEST(*md);
+	qc_mjpeg_yuv2rgb_exit(md);
+	kfree(md->encV);
+	kfree(md->encU);
+	kfree(md->encY);
+	POISON(md->encV);
+	POISON(md->encU);
+	POISON(md->encY);
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("qc_mjpeg_exit() done");
+	IDEBUG_EXIT(*md);
+}
+/* }}} */
+
+/* }}} */
+
+#else /* COMPRESS=0 */
+int qc_mjpeg_decode(struct qc_mjpeg_data *md, unsigned char *src, int src_len, unsigned char *dst) { return -ENXIO; }
+int qc_mjpeg_init(struct qc_mjpeg_data *md, int depth, Bool tobgr) { return -ENXIO; }
+void qc_mjpeg_exit(struct qc_mjpeg_data *md) { }
+#endif
+
+/* End of file */
diff -purN linux-2.6.10.orig/drivers/usb/media/qc/qc-pb0100.c linux-2.6.10-qc-usb/drivers/usb/media/qc/qc-pb0100.c
--- linux-2.6.10.orig/drivers/usb/media/qc/qc-pb0100.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-qc-usb/drivers/usb/media/qc/qc-pb0100.c	2005-01-07 14:55:46.302225781 +0100
@@ -0,0 +1,381 @@
+/* Start of file */
+
+/* {{{ [fold] Comments */
+/*
+ * qce-ga, linux V4L driver for the QuickCam Express and Dexxa QuickCam
+ *
+ * pb0100.c - PB0100 Sensor Implementation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+/* }}} */
+
+#ifdef NOKERNEL
+#include "quickcam.h"
+#else
+#include <linux/quickcam.h>
+#endif
+
+/* I2C Address */
+#define PB_ADDR 		0xBA
+ 
+/* {{{ [fold] I2C Registers */
+#define PB_IDENT		0x00	/* R0   Chip Version */
+#define PB_RSTART		0x01	/* R1   Row Window Start */
+#define PB_CSTART		0x02	/* R2   Column Window Start */
+#define PB_RWSIZE		0x03	/* R3   Row Window Size */
+#define PB_CWSIZE		0x04	/* R4   Column  Window Size */
+#define PB_CFILLIN		0x05	/* R5   Column Fill-In */
+#define PB_VBL			0x06	/* R6   Vertical Blank Count */
+#define PB_CONTROL		0x07	/* R7   Control Mode */
+#define PB_FINTTIME		0x08	/* R8   Integration Time/Frame Unit Count */
+#define PB_RINTTIME		0x09	/* R9   Integration Time/Row Unit Count */
+#define PB_ROWSPEED		0x0A	/* R10  Row Speed Control */
+#define PB_ABORTFRAME		0x0B	/* R11  Abort Frame */
+/* #define PB_R12		0x0C	   R12  Reserved */
+#define PB_RESET		0x0D	/* R13  Reset */
+#define PB_EXPGAIN		0x0E	/* R14  Exposure Gain Command */
+#define PB_R15			0x0F	/* R15  Expose0 */
+#define PB_R16			0x10	/* R16  Expose1 */
+#define PB_R17			0x11	/* R17  Expose2 */
+#define PB_R18			0x12	/* R18  Low0_DAC */
+#define PB_R19			0x13	/* R19  Low1_DAC */
+#define PB_R20			0x14	/* R20  Low2_DAC */
+#define PB_R21			0x15	/* R21  Threshold11 */
+#define PB_R22			0x16	/* R22  Threshold0x */
+#define PB_UPDATEINT		0x17	/* R23  Update Interval */
+#define PB_R24			0x18	/* R24  High_DAC */
+#define PB_R25			0x19	/* R25  Trans0H */
+#define PB_R26			0x1A	/* R26  Trans1L */
+#define PB_R27			0x1B	/* R27  Trans1H */
+#define PB_R28			0x1C	/* R28  Trans2L */
+/* #define PB_R29		0x1D	   R29  Reserved */
+/* #define PB_R30		0x1E	   R30  Reserved */
+#define PB_R31			0x1F	/* R31  Wait to Read */
+#define PB_PREADCTRL		0x20	/* R32  Pixel Read Control Mode */
+#define PB_R33			0x21	/* R33  IREF_VLN */
+#define PB_R34			0x22	/* R34  IREF_VLP */
+#define PB_R35			0x23	/* R35  IREF_VLN_INTEG */
+#define PB_R36			0x24	/* R36  IREF_MASTER */
+#define PB_R37			0x25	/* R37  IDACP */
+#define PB_R38			0x26	/* R38  IDACN */
+#define PB_R39			0x27	/* R39  DAC_Control_Reg */
+#define PB_R40			0x28	/* R40  VCL */
+#define PB_R41			0x29	/* R41  IREF_VLN_ADCIN */
+/* #define PB_R42		0x2A	   R42  Reserved */
+#define PB_G1GAIN		0x2B	/* R43  Green 1 Gain */
+#define PB_BGAIN		0x2C	/* R44  Blue Gain */
+#define PB_RGAIN		0x2D	/* R45  Red Gain */
+#define PB_G2GAIN		0x2E	/* R46  Green 2 Gain */
+#define PB_R47			0x2F	/* R47  Dark Row Address */
+#define PB_R48			0x30	/* R48  Dark Row Options */
+/* #define PB_R49		0x31	   R49  Reserved */
+#define PB_R50			0x32	/* R50  Image Test Data */
+#define PB_ADCMAXGAIN		0x33	/* R51  Maximum Gain */
+#define PB_ADCMINGAIN		0x34	/* R52  Minimum Gain */
+#define PB_ADCGLOBALGAIN	0x35	/* R53  Global Gain */
+#define PB_R54			0x36	/* R54  Maximum Frame */
+#define PB_R55			0x37	/* R55  Minimum Frame */
+/* #define PB_R56		0x38	   R56  Reserved */
+#define PB_VOFFSET		0x39	/* R57  VOFFSET */
+#define PB_R58			0x3A	/* R58  Snap-Shot Sequence Trigger */
+#define PB_ADCGAINH		0x3B	/* R59  VREF_HI */
+#define PB_ADCGAINL		0x3C	/* R60  VREF_LO */
+/* #define PB_R61		0x3D	   R61  Reserved */
+/* #define PB_R62		0x3E	   R62  Reserved */
+/* #define PB_R63		0x3F	   R63  Reserved */
+#define PB_R64			0x40	/* R64  Red/Blue Gain */
+#define PB_R65			0x41	/* R65  Green 2/Green 1 Gain */
+#define PB_R66			0x42	/* R66  VREF_HI/LO */
+#define PB_R67			0x43	/* R67  Integration Time/Row Unit Count */
+#define PB_R240			0xF0	/* R240 ADC Test */
+#define PB_R241			0xF1    /* R241 Chip Enable */
+/* #define PB_R242		0xF2	   R242 Reserved */
+/* }}} */
+
+#define I2C_SETW_CHECK(reg,val)	if ((r = qc_i2c_setw(qc,(reg),(val)))<0) goto fail
+#define STV_SET_CHECK(reg,val)	if ((r = qc_stv_set(qc,(reg),(val)))<0) goto fail
+#define STV_SETW_CHECK(reg,val)	if ((r = qc_stv_setw(qc,(reg),(val)))<0) goto fail
+
+/*
+ * The spec file for the PB-0100 suggests the following for best quality
+ * images after the sensor has been reset :
+ *
+ * PB_ADCGAINL      = R60 = 0x03 (3 dec)      : sets low reference of ADC to produce good black level
+ * PB_PREADCTRL     = R32 = 0x1400 (5120 dec) : Enables global gain changes through R53
+ * PB_ADCMINGAIN    = R52 = 0x10 (16 dec)     : Sets the minimum gain for auto-exposure
+ * PB_ADCGLOBALGAIN = R53 = 0x10 (16 dec)     : Sets the global gain
+ * PB_EXPGAIN       = R14 = 0x11 (17 dec)     : Sets the auto-exposure value
+ * PB_UPDATEINT     = R23 = 0x02 (2 dec)      : Sets the speed on auto-exposure routine
+ * PB_CFILLIN       = R5  = 0x0E (14 dec)     : Sets the frame rate
+ */
+
+/* {{{ [fold] pb0100_init: Initialise parameters of PB100 sensor */
+static int pb0100_init(struct quickcam *qc)
+{
+	static const Bool natural = TRUE;	/* Disable flicker control for natural lighting? */
+	struct qc_sensor_data *sd = &qc->sensor_data;
+	int r;
+
+	if (sd->compress) return -EINVAL;
+	sd->maxwidth  = 360;
+	sd->maxheight = 288;		/* Sensor has 296 rows but top 8 are opaque */
+	if (sd->subsample) {
+		sd->maxwidth  /= 2;
+		sd->maxheight /= 2;
+	}
+	sd->exposure = 0;
+
+	STV_SET_CHECK(STV_REG00, 1);
+	STV_SET_CHECK(STV_SCAN_RATE, 0);
+
+	/* Reset sensor */
+	I2C_SETW_CHECK(PB_RESET, 1);
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+	I2C_SETW_CHECK(PB_RESET, 0);
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+
+	/* Disable chip */
+	I2C_SETW_CHECK(PB_CONTROL, BIT(5)|BIT(3));
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+
+	/* Gain stuff...*/
+	I2C_SETW_CHECK(PB_PREADCTRL, BIT(12)|BIT(10)|BIT(6));
+	I2C_SETW_CHECK(PB_ADCGLOBALGAIN, 12);
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+
+	/* Set up auto-exposure */
+	I2C_SETW_CHECK(PB_R28, 12);			/* ADC VREF_HI new setting for a transition from the Expose1 to the Expose2 setting */
+	I2C_SETW_CHECK(PB_ADCMAXGAIN, 180);		/* gain max for autoexposure */
+	I2C_SETW_CHECK(PB_ADCMINGAIN, 12);		/* gain min for autoexposure  */
+	I2C_SETW_CHECK(PB_R54, 3);			/* Maximum frame integration time (programmed into R8) allowed for auto-exposure routine */
+	I2C_SETW_CHECK(PB_R55, 0);			/* Minimum frame integration time (programmed into R8) allowed for auto-exposure routine */
+	I2C_SETW_CHECK(PB_UPDATEINT, 1);
+	I2C_SETW_CHECK(PB_R15, 800);			/* R15  Expose0 (maximum that auto-exposure may use) */
+	I2C_SETW_CHECK(PB_R17, 10);			/* R17  Expose2 (minimum that auto-exposure may use) */
+
+	if (qc->settings.adaptive) {
+		I2C_SETW_CHECK(PB_EXPGAIN, (natural?BIT(6):0)|BIT(4)|BIT(0));
+	} else {
+		I2C_SETW_CHECK(PB_EXPGAIN, 0);
+	}
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+
+	I2C_SETW_CHECK(PB_VOFFSET, 0);			/* 0x14 */
+	I2C_SETW_CHECK(PB_ADCGAINH, 11);		/* 0x0D */
+	I2C_SETW_CHECK(PB_ADCGAINL, 0);			/* Set black level (important!) */
+
+	/* ??? */
+	STV_SET_CHECK(STV_REG04, 0x07);
+	STV_SET_CHECK(STV_REG03, 0x45);
+	STV_SET_CHECK(STV_REG00, 0x11);
+
+	/* Set mode */
+	STV_SET_CHECK(STV_Y_CTRL, sd->subsample ? 2 : 1);	/* 0x02: half, 0x01: full FIXME: this doesn't work! */
+	STV_SET_CHECK(STV_X_CTRL, sd->subsample ? 6 : 0x0A);	/* 0x06: Half, 0x0A: Full */
+
+	/* ISO-Size (0x27b: 635... why? - HDCS uses 847) */
+	STV_SETW_CHECK(STV_ISO_SIZE, 847);
+
+	/* Setup sensor window */
+	I2C_SETW_CHECK(PB_RSTART, 0);
+	I2C_SETW_CHECK(PB_CSTART, 0);
+	I2C_SETW_CHECK(PB_RWSIZE, 240-1);			/* 0xF7: 240 */
+	I2C_SETW_CHECK(PB_CWSIZE, 320-1);			/* 0x13F: 320 */
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+
+	/* Scan rate? */
+	STV_SET_CHECK(STV_SCAN_RATE, sd->subsample ? 0x10 : 0x20);	/* larger -> slower */
+
+	/* Scan/timing for the sensor */
+	I2C_SETW_CHECK(PB_ROWSPEED, BIT(4)|BIT(3)|BIT(1));
+	I2C_SETW_CHECK(PB_CFILLIN, 14);
+	I2C_SETW_CHECK(PB_VBL, 0);
+	I2C_SETW_CHECK(PB_FINTTIME, 0);
+	I2C_SETW_CHECK(PB_RINTTIME, 123);
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+
+	STV_SET_CHECK(STV_REG01, 0xC2);
+	STV_SET_CHECK(STV_REG02, 0xB0);
+
+fail:	return r;
+}
+/* }}} */
+/* {{{ [fold] pb0100_set_exposure() */
+static int pb0100_set_exposure(struct quickcam *qc, unsigned int val)
+{
+	int r;
+	struct qc_sensor_data *sd = &qc->sensor_data;
+	val >>= 7;
+	if (val==sd->exposure) return 0;
+	sd->exposure = val;
+	I2C_SETW_CHECK(PB_RINTTIME, val);	/* R9 */
+fail:	return r;
+}
+/* }}} */
+/* {{{ [fold] pb0100_set_gains() */
+static int pb0100_set_gains(struct quickcam *qc, u16 hue, u16 sat, u16 val)
+{
+	struct qc_sensor_data *sd = &qc->sensor_data;
+	unsigned int rgain, bgain, ggain;
+	int r;
+	qc_hsv2rgb(hue, sat, val, &rgain, &bgain, &ggain);
+	rgain >>= 8;		/* After this the values are 0..255 */
+	ggain >>= 8;
+	bgain >>= 8;
+	if (rgain==sd->rgain && ggain==sd->ggain && bgain==sd->bgain) return 0;
+	sd->rgain = rgain;
+	sd->ggain = ggain;
+	sd->bgain = bgain;
+	I2C_SETW_CHECK(PB_RGAIN,  rgain);	/* R43 */
+	I2C_SETW_CHECK(PB_G1GAIN, ggain);	/* R44 */
+	I2C_SETW_CHECK(PB_G2GAIN, ggain);	/* R45 */
+	I2C_SETW_CHECK(PB_BGAIN,  bgain);	/* R46 */
+fail:	return r;
+}
+/* }}} */
+/* {{{ [fold] pb0100_set_levels() */
+static int pb0100_set_levels(struct quickcam *qc, unsigned int exp, unsigned int gain, unsigned int hue, unsigned int sat)
+{
+	int r;
+	/* When automatic exposure control in Photobit is used, the exposure/gain
+	 * registers shouldn't be touched. The sensor may update them only rarely
+	 * and if they're changed they may be incorrect until the sensor updates
+	 * the registers next time.
+	 * FIXME: shouldn't qc-driver.c ensure this function isnt called when adaptive is used?
+	 */
+	if (qc->settings.adaptive) return 0;
+	if ((r = pb0100_set_exposure(qc, exp))<0) goto fail;
+	pb0100_set_gains(qc, hue, sat, gain);
+fail:	return r;
+}
+/* }}} */
+/* {{{ [fold] pb0100_set_target: Set target brightness for sensor autoexposure, val=0..65535 */
+static int pb0100_set_target(struct quickcam *qc, unsigned int val)
+{
+	struct qc_sensor_data *sd = &qc->sensor_data;
+	unsigned int totalpixels, brightpixels, darkpixels;
+	int r;
+
+	val >>= 8;			/* val = 0..255 (0-50% of bright pixels) */
+	if (val==sd->exposure) return 0;
+	sd->exposure = val;
+
+	/* Number of pixels counted by the sensor when subsampling the pixels.
+	 * Slightly larger than the real value to avoid oscillation */
+	totalpixels = sd->width * sd->height;
+	totalpixels = totalpixels/(8*8) + totalpixels/(64*64);
+
+	brightpixels = (totalpixels * val) >> 8;
+	darkpixels   = totalpixels - brightpixels;
+	I2C_SETW_CHECK(PB_R21, brightpixels);	/* R21 */
+	I2C_SETW_CHECK(PB_R22, darkpixels);	/* R22 */
+fail:	return r;
+}
+/* }}} */
+/* {{{ [fold] pb0100_set_size: Set window size */
+/* Window location and size are controlled by R1, R2, R3 and R4.
+ * The default size is CIF (352x288) with to right at (4,12)
+ * and bottom left at (355, 299)
+ *
+ * We try to ensure that the captured area is in the center of
+ * the camera purely because that's nicer.  It would be better
+ * if the PB0100 sensor supported capture scaling!
+ *
+ * We do it in on step otherwise size change may take more
+ * than one frame (like xawtv who tests 64x48 and uses 352x288)
+ * 3072 = 64x48, 16896 = 352x48, 101376 = 352x288.
+ */
+static int pb0100_set_size(struct quickcam *qc, unsigned int w, unsigned int h)
+{
+	static const unsigned int originx   = 0;	/* First visible pixel */
+	static const unsigned int originy   = 8;
+	static const unsigned int maxwidth  = 360;	/* Visible sensor size */
+	static const unsigned int maxheight = 288;
+	struct qc_sensor_data *sd = &qc->sensor_data;
+	int x, y;
+	int r;
+
+	sd->width = w;
+	sd->height = h;
+	if (sd->subsample) {
+		w *= 2;
+		h *= 2;
+	}
+	x = (maxwidth - w)/2;			/* Center image by computing upper-left corner */
+	y = (maxheight - h)/2;
+	x = (x + originx) & ~1;			/* Must be even to align to the Bayer pattern */
+	y = (y + originy) & ~1;
+	I2C_SETW_CHECK(PB_RSTART, y);		/* PB_RSTART = 12 + y */
+	I2C_SETW_CHECK(PB_CSTART, x);		/* PB_CSTART = 4 + x */
+	I2C_SETW_CHECK(PB_RWSIZE, h - 1);	/* PB_RWSIZE = h - 1 */
+	I2C_SETW_CHECK(PB_CWSIZE, w - 1);	/* PB_CWSIZE = w - 1 */
+
+	if (qc->settings.adaptive) {
+		/* The automatic exposure counts need to be recomputed when size is changed */
+		x = sd->exposure << 8;
+		sd->exposure = -1;
+		if ((r = pb0100_set_target(qc, x))<0) goto fail;
+	}
+
+	r = qc_i2c_wait(qc);
+fail:	return r;
+}
+/* }}} */
+/* {{{ [fold] pb0100_start: Start grabbing */
+static int pb0100_start(struct quickcam *qc)
+{
+	int r;
+	I2C_SETW_CHECK(PB_CONTROL, BIT(5)|BIT(3)|BIT(1));
+	r = qc_i2c_wait(qc);
+fail:	return r;
+}
+/* }}} */
+/* {{{ [fold] pb0100_stop: Stop grabbing */
+static int pb0100_stop(struct quickcam *qc)
+{
+	int r;
+	I2C_SETW_CHECK(PB_ABORTFRAME, 1);
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+	I2C_SETW_CHECK(PB_CONTROL, BIT(5)|BIT(3));	/* Set bit 1 to zero */
+	r = qc_i2c_wait(qc);
+fail:	return r;
+}
+/* }}} */
+
+/* {{{ [fold] struct qc_sensor qc_sensor_pb0100 */
+const struct qc_sensor qc_sensor_pb0100 = {
+	name:		"PB-0100/0101",
+	manufacturer:	"Photobit",
+	init:		pb0100_init,
+	start:		pb0100_start,
+	stop:		pb0100_stop,
+	set_size:	pb0100_set_size,
+	set_levels:	pb0100_set_levels,
+	set_target:	pb0100_set_target,
+	/* Exposure and gain control information */
+	autoexposure:	TRUE,
+	/* Information needed to access the sensor via I2C */
+	reg23: 		1,
+	i2c_addr: 	PB_ADDR,
+	/* Identification information used for auto-detection */
+	id_reg:		PB_IDENT,
+	id:		0x64,
+	length_id:	2,
+};
+/* }}} */
+
+/* End of file */
diff -purN linux-2.6.10.orig/drivers/usb/media/qc/qc-vv6410.c linux-2.6.10-qc-usb/drivers/usb/media/qc/qc-vv6410.c
--- linux-2.6.10.orig/drivers/usb/media/qc/qc-vv6410.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-qc-usb/drivers/usb/media/qc/qc-vv6410.c	2005-01-07 14:55:46.304225470 +0100
@@ -0,0 +1,654 @@
+/* Start of file */
+
+/* {{{ [fold] Comments */
+/*
+ * qce-ga, linux V4L driver for the QuickCam Express and Dexxa QuickCam
+ *
+ * vv6410.c - VV6410 Sensor Implementation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+/* }}} */
+
+#ifdef NOKERNEL
+#include "quickcam.h"
+#else
+#include <linux/quickcam.h>
+#endif
+
+#ifndef QCEGA_MODE
+#define QCEGA_MODE 0		/* If the driver doesn't work for you, try changing this to "1" */
+#endif
+
+/* LSB bit of I2C address signifies write (0) or read (1) */
+
+/* I2C Address */
+#define VV6410_ADDR		(0x10<<1)
+
+/* {{{ [fold] I2C Registers */
+/* Status registers */
+#define VV6410_DEVICEH		0x00	/* Chip identification number including revision indicator */
+#define VV6410_DEVICEL		0x01
+#define VV6410_STATUS0		0x02	/* User can determine whether timed I2C data has been consumed by interrogating flag states */
+#define VV6410_LINECOUNTH	0x03	/* Current line counter value */
+#define VV6410_LINECOUNTL	0x04
+#define VV6410_XENDH		0x05	/* End x coordinate of image size */
+#define VV6410_XENDL		0x06
+#define VV6410_YENDH		0x07	/* End y coordinate of image size */
+#define VV6410_YENDL		0x08
+#define VV6410_DARKAVGH		0x09	/* This is the average pixel value returned from the dark line offset cancellation algorithm */
+#define VV6410_DARKAVGL		0x0A
+#define VV6410_BLACKAVGH	0x0B	/* This is the average pixel value returned from the black line offset cancellation algorithm  */
+#define VV6410_BLACKAVGL	0x0C
+#define VV6410_STATUS1		0x0D	/* Flags to indicate whether the x or y image coordinates have been clipped */
+
+/* Setup registers */
+#define VV6410_SETUP0		0x10	/* Low-power/sleep modes & video timing */
+#define VV6410_SETUP1		0x11	/* Various parameters */
+#define VV6410_SYNCVALUE	0x12	/* Contains pixel counter reset value used by external sync */
+#define VV6410_FGMODES		0x14	/* Frame grabbing modes (FST, LST and QCK) */
+#define VV6410_PINMAPPING	0x15	/* FST and QCK mapping modes. */
+#define VV6410_DATAFORMAT	0x16	/* Data resolution */
+#define VV6410_OPFORMAT		0x17	/* Output coding formats */
+#define VV6410_MODESELECT	0x18	/* Various mode select bits */
+
+/* Exposure registers */
+#define VV6410_FINEH		0x20	/* Fine exposure. */
+#define VV6410_FINEL		0x21
+#define VV6410_COARSEH		0x22	/* Coarse exposure */
+#define VV6410_COARSEL		0x23
+#define VV6410_ANALOGGAIN	0x24	/* Analog gain setting */
+#define VV6410_CLKDIV		0x25	/* Clock division */
+#define VV6410_DARKOFFSETH	0x2C	/* Dark line offset cancellation value */
+#define VV6410_DARKOFFSETL	0x2D
+#define VV6410_DARKOFFSETSETUP	0x2E	/* Dark line offset cancellation enable */
+
+/* Colour registers (none on this camera!) */
+
+/* Video timing registers */
+#define VV6410_LINELENGTHH	0x52	/* Line Length (Pixel Clocks) */
+#define VV6410_LINELENGTHL	0x53
+#define VV6410_XOFFSETH		0x57	/* X-co-ordinate of top left corner of region of interest (x-offset) */
+#define VV6410_XOFFSETL		0x58
+#define VV6410_YOFFSETH		0x59	/* Y-co-ordinate of top left corner of region of interest (y-offset) */
+#define VV6410_YOFFSETL		0x5A
+#define VV6410_FIELDLENGTHH	0x61	/* Field length (Lines) */
+#define VV6410_FIELDLENGTHL	0x62
+
+/* Text overlay registers (none on this camera!) */
+
+/* I2C autoload registers (none on this camera!) */
+
+/* System registers */
+#define VV6410_BLACKOFFSETH	0x70	/* Black offset cancellation default value */
+#define VV6410_BLACKOFFSETL	0x71
+#define VV6410_BLACKOFFSETSETUP	0x72	/* Black offset cancellation setup */
+#define VV6410_CR0		0x75	/* Analog Control Register 0 */
+#define VV6410_CR1		0x76	/* Analog Control Register 1 */
+#define VV6410_AS0		0x77	/* ADC Setup Register */
+#define VV6410_AT0		0x78	/* Analog Test Register */
+#define VV6410_AT1		0x79	/* Audio Amplifier Setup Register */
+/* }}} */
+
+#define I2C_SET_CHECK(reg,val)	if ((r = qc_i2c_set(qc,(reg),(val)))<0) goto fail
+#define STV_SET_CHECK(reg,val)	if ((r = qc_stv_set(qc,(reg),(val)))<0) goto fail
+#define STV_SETW_CHECK(reg,val)	if ((r = qc_stv_setw(qc,(reg),(val)))<0) goto fail
+#define IS_850(qc)		(GET_PRODUCTID(qc)==0x850)	/* Is it QuickCam Web/Legocam? */
+
+#if QCEGA_MODE
+#warning "Using old compatible code (QCEGA_MODE=1)"
+#warning "If this works but otherwise it doesn't work, let me know!"
+static int mode = 0;
+#define VV6410_CONTROL 		0x10	// Setup0
+#define VV6410_GAIN  		0x24
+/* {{{ [fold] vv6410_set_window() */
+static int vv6410_set_window(struct quickcam *qc, int x, int y,int width, int height)
+{
+	int r = 0;
+
+	// x offset
+        x = MAX(1,x);
+	I2C_SET_CHECK(0x57,x >> 8);
+	I2C_SET_CHECK(0x58,x & 0xff);
+
+	// y offset
+        y = MAX(1,y);
+	I2C_SET_CHECK(0x59,y >> 8);
+	I2C_SET_CHECK(0x5a,y & 0xff);
+
+        // Set the real
+        if (qc->sensor_data.subsample) {
+            qc->sensor_data.width=180;
+            qc->sensor_data.height=148;
+        } else {
+            qc->sensor_data.width=356;
+            qc->sensor_data.height=292;
+        }
+
+	// line length
+        if (qc->sensor_data.subsample) {
+            if (IS_850(qc))
+                width=250;
+            else
+                width=360; /* 180 * 2 (CLK-DIV is 2) */
+        }
+        else {
+          if (IS_850(qc))
+                width=416;
+          else
+                width=712; /* 356 * 2 */
+	}
+
+	I2C_SET_CHECK(0x52, width >> 8);
+	I2C_SET_CHECK(0x53, width & 0xff);
+
+	// field length (num lines)
+        if (qc->sensor_data.subsample)
+          height=160; /* nearest of 148 = 10 * 16 */
+        else
+          height=320; // 304; /* nearest of 292 = 19 * 16 */ 
+
+	I2C_SET_CHECK(0x61,height >> 8);
+	I2C_SET_CHECK(0x62,height & 0xff);
+
+        // usb_quickcam_i2c_add(&i2cbuff,0x25,0x02);
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+
+        return 0;
+fail:
+	return -ENAMETOOLONG;	//some silly code just for testing
+}
+/* }}} */
+#endif
+
+/* {{{ [fold] vv6410_set_size: Set window size */
+static int vv6410_set_size(struct quickcam *qc, unsigned int width, unsigned int height)
+{
+	struct qc_sensor_data *sd = &qc->sensor_data;
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("vv6410_set_size(qc=%p,width=%i,height=%i)",qc,width,height);
+	/* VV6410 appears to always give fixed 356*292 pixels */
+	sd->width = sd->maxwidth;
+	sd->height = sd->maxheight;
+	return 0;
+}
+/* }}} */
+/* {{{ [fold] vv6410_start: Start grabbing */
+static int vv6410_start(struct quickcam *qc)
+{
+	struct qc_sensor_data *sd = &qc->sensor_data;
+	int r;
+
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("vv6410_start(qc=%p)",qc);
+	if (PARANOID && !qc)  { PDEBUG("qc==NULL"); return -EINVAL; }
+	I2C_SET_CHECK(VV6410_SETUP0, sd->subsample ? (BIT(7)|BIT(6)) : 0x00);
+	if (IS_850(qc)) qc_stv_set(qc, 0x1445, 1);		/* Turn on LED */
+	r = qc_i2c_wait(qc);
+fail:	return r;
+}
+/* }}} */
+/* {{{ [fold] vv6410_stop: Stop grabbing */
+static int vv6410_stop(struct quickcam *qc)
+{
+	static const int low_power_mode = 0; //1;
+	static const int sleep_mode     = 1;
+	struct qc_sensor_data *sd = &qc->sensor_data;
+	unsigned char cmd;
+	int r;
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("vv6410_stop(qc=%p)",qc);
+	if (IS_850(qc)) qc_stv_set(qc, 0x1445, 0);		/* Turn off LED */
+	cmd = (sleep_mode << 1) | low_power_mode;
+	if (sd->subsample) cmd |= BIT(7)|BIT(6);		/* sub-sampled QCIF mode */
+	I2C_SET_CHECK(VV6410_SETUP0, cmd);
+	r = qc_i2c_wait(qc);
+fail:	return r;
+}
+/* }}} */
+#if COMPRESS
+struct stv_init {
+	const u8 *data;	/* If NULL, only single value to write, stored in len */
+	u16 start;
+	u8 len;
+};
+#endif
+/* {{{ [fold] vv6410_init: Initialise parameters for vv6410 sensor. */
+/* Just try to send the same commands as Windoze QuickCam soft */
+static int vv6410_init(struct quickcam *qc)
+{
+	struct qc_sensor_data *sd = &qc->sensor_data;
+	int r;
+
+#if COMPRESS
+	if (IS_850(qc)) {
+/* {{{ [fold] Initialization with compression support */
+
+/* {{{ [fold] [fold] stv_init[] */
+	static const u8 x0540[] = {			/* 0x0540 - 0x0551 */
+		0x97,0x0B,0x4C,0xFC,0x36,0x00,0x75,0x00,0x59,0x02,0x32,0x01,0x56,0xFD,0xEE,0xFF,
+		0xB8,0x05 };
+	static const u8 x0560[] = {			/* 0x0560 - 0x0563 */
+		0x40,0xFF,0xBF,0xBF };
+	static const u8 x1500[] = {			/* 0x1500 - 0x150F */
+		0x0B,0xA7,0xB7,0x00,0x00,0x00,0x14,0x14,0x14,0x14,0x2B,0x02,0x2B,0x02,0x2B,0x02 };
+	static const u8 x1520[] = {			/* 0x1520 - 0x152A */
+		0x05,0x14,0x0F,0x0F,0x98,0x98,0x98,0x98,0x2D,0x00,0x01 };
+	static const u8 x1530[] = {			/* 0x1530 - 0x153B */
+		0x08,0x02,0x00,0x00,0x02,0x00,0x02,0x00,0x60,0x01,0x20,0x01 };
+	static const u8 x1552[] = {			/* 0x1552 - 0x1558 */
+		0x72,0x90,0x00,0xB0,0xF0,0x77,0x72 };
+	static const u8 x1564[] = {			/* 0x1564 - 0x1567 */
+		0x00,0xFF,0x0C,0x00 };
+	static const u8 x1580[] = {			/* 0x1580 - 0x158F */
+		0x02,0x40,0x01,0xF0,0x00,0xD1,0x01,0xAC,0x01,0x07,0x00,0x00,0x00,0x00,0x00,0x00 };
+	static const u8 x1590[] = {			/* 0x1590 - 0x15A5 */
+		0xA8,0x05,0x64,0x07,0x0F,0x03,0xD8,0x07,0xA6,0x06,0x71,0x04,0x8F,0x01,0xFF,0xFB,
+		0xEC,0xE6,0xE0,0xD9,0xC4,0xB8 };
+	static const u8 x15C1[] = {			/* 0x15C1 - 0x15C2 */
+		0x4B, 0x02 };			/* Output word 0x024B=587 (ISO size) */
+	static const struct stv_init stv_init[] = {
+		{ NULL,  0x1620, 0x80 },	/* This reg is written twice. Some kind of reset? */
+		{ NULL,  0x1620, 0x00 },
+		{ x0540, 0x0540, SIZE(x0540) },
+		{ x0560, 0x0560, SIZE(x0560) },
+		{ NULL,  0x1423, 0x04 },
+		{ NULL,  0x1440, 0x00 },
+		{ NULL,  0x1443, 0x00 },
+		{ NULL,  0x1445, 0x01 },
+		{ x1500, 0x1500, SIZE(x1500) },
+		{ x1520, 0x1520, SIZE(x1520) },
+		{ x1530, 0x1530, SIZE(x1530) },
+		{ x1552, 0x1552, SIZE(x1552) },
+		{ x1564, 0x1564, SIZE(x1564) },
+		{ x1580, 0x1580, SIZE(x1580) },
+		{ x1590, 0x1590, SIZE(x1590) },
+		{ x15C1, 0x15C1, SIZE(x15C1) },
+		{ NULL,  0x15C3, 0x00 },
+		{ NULL,  0x15C9, 0x01 },
+		{ NULL,  0x1704, 0x00 },
+	};
+/* }}} */
+/* {{{ [fold] vv_init[][2] */
+	static const u8 vv_init[][2] = {
+		/* Setup registers */
+		{ VV6410_SETUP0,	BIT(2) },	/* Soft reset */
+		{ VV6410_SETUP0,	BIT(1)|BIT(0) },	/* 25 fps PAL (30 fps NTSC doesn't work!), sleep mode */
+		{ VV6410_SETUP1,	BIT(6) },	/* Use unsuffled read-out mode */
+		{ VV6410_FGMODES,	BIT(6)|BIT(4)|BIT(2)|BIT(0) },	/* All modes to 1 */
+		{ VV6410_PINMAPPING,	0x00 },
+		{ VV6410_DATAFORMAT,	BIT(7)|BIT(0) },	/* Pre-clock generator divide off */
+		{ VV6410_OPFORMAT,	BIT(3)|BIT(4) },
+		/* Exposure registers */
+		{ VV6410_FINEH,		320 >> 8 },		/* Initial exposure */
+		{ VV6410_FINEL,		320 & 0xFF },
+		{ VV6410_COARSEH,	192 >> 8 },
+		{ VV6410_COARSEL,	192 & 0xFF },
+		{ VV6410_ANALOGGAIN,	0xF0 | 11 },		/* Gain to 11 */
+		{ VV6410_CLKDIV,	0x01 },			/* Pixel clock divisor 2 */
+		/* Video timing registers */
+		{ VV6410_LINELENGTHH,	(416-1) >> 8 },		/* Set line length (columns) to 417 */
+		{ VV6410_LINELENGTHL,	(416-1) & 0xFF },
+		{ VV6410_FIELDLENGTHH,	(320-1) >> 8 },		/* Set field length (rows) to 320 */
+		{ VV6410_FIELDLENGTHL,	(320-1) & 0xFF },
+		/* System registers */
+		{ VV6410_AS0,		BIT(6)|BIT(4)|BIT(3)|BIT(2)|BIT(1) },	/* Enable voltage doubler */
+		{ VV6410_AT0,		0x00 },
+		{ VV6410_AT1,		BIT(4)|BIT(0) },	/* Power up audio, differential */
+	};
+/* }}} */
+
+	unsigned int cols = 416;
+	unsigned int rows = 320;
+	unsigned int x = 1;
+	unsigned int y = 1;
+	int i,j;
+
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("vv6410_init(qc=%p)",qc);
+	if (PARANOID && !qc) { PDEBUG("qc==NULL"); return -EINVAL; }
+
+	sd->width  = 320;	/* Default to compressed mode */
+	sd->height = 240;
+
+	for (i=0; i<SIZE(stv_init); i++) {
+		if (stv_init[i].data==NULL) {
+			STV_SET_CHECK(stv_init[i].start, stv_init[i].len);
+		} else {
+			for (j=0; j<stv_init[i].len; j++) {
+				STV_SET_CHECK(stv_init[i].start+j, stv_init[i].data[j]);
+			}
+		}
+	}
+	if (!IS_850(qc)) {
+		STV_SET_CHECK(0x1443, sd->subsample ? 0x10 : 0x20);	/* Scan rate */
+		STV_SET_CHECK(0x1446,1);
+		STV_SETW_CHECK(0x15C1,600);			/* ISO size, 0x380|orig:600 */
+		STV_SET_CHECK(0x1680,0x14);			/* X ctrl */
+	}
+
+	for (i=0; i<SIZE(vv_init); i++) {
+		I2C_SET_CHECK(vv_init[i][0], vv_init[i][1]);
+		if (i<2) if ((r = qc_i2c_wait(qc))<0) goto fail;
+	}
+
+	if (!sd->compress) {
+		/* Disable compression */
+		STV_SET_CHECK(0x1443, sd->subsample ? 0x00 : 0x10);	/* Scan rate: Larger -> slower */
+		STV_SETW_CHECK(0x15C1, 1023);				/* ISO-Size */
+		STV_SET_CHECK(0x15C3, 1);				/* Y control */
+		sd->width  = 356;
+		sd->height = 292;
+		if (qc->settings.subsample) {
+			//FIXME:subsampling (still) doesn't work yet
+			cols=250;
+			rows=160;
+			sd->width  = 180;
+			sd->height = 148;
+			I2C_SET_CHECK(VV6410_SETUP0, BIT(7)|BIT(6)|BIT(1)|BIT(0));	/* Subsampled timing mode */
+		}
+	}
+	I2C_SET_CHECK(VV6410_XOFFSETH,     x >> 8);
+	I2C_SET_CHECK(VV6410_XOFFSETL,     x & 0xFF);
+	I2C_SET_CHECK(VV6410_YOFFSETH,     y >> 8);
+	I2C_SET_CHECK(VV6410_YOFFSETL,     y & 0xFF);
+	I2C_SET_CHECK(VV6410_LINELENGTHH,  (cols-1) >> 8);
+	I2C_SET_CHECK(VV6410_LINELENGTHL,  (cols-1) & 0xFF);
+	I2C_SET_CHECK(VV6410_FIELDLENGTHH, (rows-1) >> 8);
+	I2C_SET_CHECK(VV6410_FIELDLENGTHL, (rows-1) & 0xFF);
+	sd->maxwidth  = sd->width;
+	sd->maxheight = sd->height;
+	return 0;
+/* }}} */
+	} else {
+#endif
+/* {{{ [fold] Initialization without compression support */
+	if (sd->compress) return -EINVAL;
+	if (sd->subsample) {
+		sd->maxwidth  = 180;
+		sd->maxheight = 148;
+	} else {
+		sd->maxwidth  = 356;
+		sd->maxheight = 292;
+	}
+
+
+#if QCEGA_MODE
+{
+int line_length = mode?250:416;//415;
+ 
+        if (mode) {
+           sd->subsample=1; // quater.
+           sd->width      = 180;
+           sd->height     = 148;
+        } else {
+           sd->subsample=0;
+           sd->width      = 356;
+           sd->height     = 292;
+        }
+
+        STV_SET_CHECK(STV_REG23, 5); // was 5.
+
+
+	if (!IS_850(qc)) {
+	     /* logitech quickcam web has 0x850 as idProduct */
+	     STV_SET_CHECK(0x1446, 1);
+        }
+
+
+	STV_SET_CHECK(STV_SCAN_RATE, 0x00);
+
+
+	STV_SET_CHECK(0x1423, 0x04);
+
+
+	STV_SET_CHECK(STV_REG00, 0x1b); // 0x0b
+
+
+
+	I2C_SET_CHECK(VV6410_CONTROL,0x04); // reset to defaults
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+
+
+        
+	
+	// CIF or QCIF and sleep.
+	if (IS_850(qc)) {
+		I2C_SET_CHECK(VV6410_CONTROL,(mode?0xa2:0x02));
+	} else {
+	        I2C_SET_CHECK(VV6410_CONTROL,(mode?0xc2:0x02));
+	}
+
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+
+
+
+	I2C_SET_CHECK(VV6410_GAIN,0xfb);
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+
+
+
+
+	
+	STV_SET_CHECK(STV_REG04, 0x07);
+
+	
+	STV_SET_CHECK(STV_REG03, 0x45);
+
+
+        /* set window size */
+        if ((r=vv6410_set_window(qc,0,0,48,64)) < 0) {
+                PRINTK(KERN_ERR, "vv6410_set_window failed");
+                goto fail;
+        }
+
+
+	/* EXPERIMENTAL */
+        /*
+	 * line length default is 415 so it's the value we use to 
+	 * calculate values for  registers 0x20-0x21
+	 * Ref. DS Pag. 67
+         */   
+	I2C_SET_CHECK(0x20,mode? ((line_length-23)>>8):((line_length-51)>>8));
+
+	I2C_SET_CHECK(0x21,mode?((line_length-23)&0xff):((line_length-51)&0xff));
+
+	I2C_SET_CHECK(0x22,mode?0x00:0x01);
+         //usb_quickcam_i2c_add(&i2cbuff,0x23,mode?0x9e:0x3e);
+	I2C_SET_CHECK(0x23,mode?158:318&0xff);
+	I2C_SET_CHECK(0x24,0xfa);
+         // clock divisor.
+	I2C_SET_CHECK(0x25,0x01);
+
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+
+
+	/*
+	if (isaweb(dev))
+	  {
+	    //EXPERIMENTAL: dark/black pixel cancellation
+	    usb_quickcam_i2c_add(&i2cbuff,0x3e,0x01);
+	    usb_quickcam_i2c_add(&i2cbuff,0x72,0x01);
+	    if (usb_quickcam_i2c_send(dev,&i2cbuff,VV6410_ADDR) < 0) {
+      	      printk(KERN_ERR "usb_control_msg dark/black pixel failed");
+	      goto error;
+	    }
+	  }
+	 */
+	STV_SET_CHECK(STV_REG01, 0xb7);
+
+	STV_SET_CHECK(STV_REG02, 0xa7);
+
+
+
+	// setup
+	I2C_SET_CHECK(0x11,0x18); // 0x18 or Jochen 0x40
+	I2C_SET_CHECK(0x14,0x55); // was 0x55
+	I2C_SET_CHECK(0x15,0x10); // 0x10 or Jochen:0x00
+	I2C_SET_CHECK(0x16,0x81); // Pre clock dividor.
+	I2C_SET_CHECK(0x17,0x18); // they are reserved.
+	I2C_SET_CHECK(0x18,0x00);
+	I2C_SET_CHECK(0x77,0x5e);
+	I2C_SET_CHECK(0x78,0x04);// 0x04 or Jochen:0x00
+	if (IS_850(qc)) {
+	  I2C_SET_CHECK(0x79,0x11);//audio init
+	}
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+
+
+	
+	
+	STV_SETW_CHECK(STV_ISO_SIZE, IS_850(qc)?1023:600);	  // 0x380|orig:600
+
+
+
+
+	STV_SET_CHECK(STV_Y_CTRL, 1);
+
+
+	STV_SET_CHECK(STV_SCAN_RATE, mode?0x00:0x10);
+
+
+
+	if (!IS_850(qc)) {
+	    /* logitech quickam web has 0x0850 as idProduct */
+		STV_SET_CHECK(STV_X_CTRL, 0x14);
+	}
+}
+
+#else
+	STV_SET_CHECK(0x0423,0x05);			/* Unknown register, 0x04 or 0x05 */
+	STV_SET_CHECK(0x1423,0x04);			/* Unknown register, 0x04 or 0x05 */
+	STV_SET_CHECK(0x1443,0x00);			/* Scan rate */
+	STV_SET_CHECK(0x1500,0x1B);			/* 0x0B */
+	STV_SET_CHECK(0x1501,0xB7);
+	STV_SET_CHECK(0x1502,0xA7);
+	STV_SET_CHECK(0x1503,0x45);
+	STV_SET_CHECK(0x1504,0x07);
+	STV_SET_CHECK(0x15C3,1);			/* Y ctrl */
+	if (IS_850(qc)) {
+		STV_SET_CHECK(0x1443, sd->subsample ? 0x20 : 0x10);	/* Scan rate */
+		STV_SETW_CHECK(0x15C1,1023);				/* ISO size, 0x380|orig:600 */
+	} else {
+		STV_SET_CHECK(0x1443, sd->subsample ? 0x10 : 0x20);	/* Scan rate */
+		STV_SET_CHECK(0x1446,1);
+		STV_SETW_CHECK(0x15C1,600);				/* ISO size, 0x380|orig:600 */
+		STV_SET_CHECK(0x1680,0x14);				/* X ctrl */
+	}
+
+	I2C_SET_CHECK(0x10,0x04);			/*  Control register: reset to defaults */
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+	I2C_SET_CHECK(0x10,sd->subsample ? 0xC2 : 0x02);/*  Control register: CIF or QCIF and sleep */
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+	I2C_SET_CHECK(0x11,0x18);			/* 0x18 or Jochen 0x40 */
+	I2C_SET_CHECK(0x14,0x55);
+	I2C_SET_CHECK(0x15,0x10);			/* 0x10 or Jochen:0x00 */
+	I2C_SET_CHECK(0x16,0x81);			/* Pre clock dividor. */
+	I2C_SET_CHECK(0x17,0x18);			/* they are reserved. */
+	I2C_SET_CHECK(0x18,0x00);
+	I2C_SET_CHECK(0x24,0xFB);			/* Set gain value */
+	I2C_SET_CHECK(0x25,0x01);			/* Clock divisor value */
+	I2C_SET_CHECK(0x77,0x5E);
+	I2C_SET_CHECK(0x78,0x04);			/* 0x04 or Jochen:0x00 */
+	if (IS_850(qc)) {
+		I2C_SET_CHECK(0x3E,0x01);		/* EXPERIMENTAL: dark/black pixel cancellation */
+		I2C_SET_CHECK(0x72,0x01);
+	}
+
+	if ((r = qc_i2c_wait(qc))<0) goto fail;
+#endif
+
+	return 0;
+/* }}} */
+#if COMPRESS
+	}
+#endif
+
+fail:	return r;
+}
+/* }}} */
+/* {{{ [fold] vv6410_set_exposure() */
+static int vv6410_set_exposure(struct quickcam *qc, unsigned int val)
+{
+	struct qc_sensor_data *sd = &qc->sensor_data;
+	static const unsigned int linelength = 415;	/* For CIF */
+	unsigned int fine;
+	unsigned int coarse;
+	int r;
+	
+	val = (val*val >> 14) + val/4;
+	if (sd->exposure==val) return 0;
+	sd->exposure = val;
+	fine = val % linelength;
+	coarse = val / linelength;
+	if (coarse>=512) coarse = 512;
+
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("vv6410_set_exposure %d (%i,%i)",val,coarse,fine);
+	I2C_SET_CHECK(VV6410_FINEH,   fine >> 8);
+	I2C_SET_CHECK(VV6410_FINEL,   fine & 0xFF);
+	I2C_SET_CHECK(VV6410_COARSEH, coarse >> 8);
+	I2C_SET_CHECK(VV6410_COARSEL, coarse & 0xFF);
+fail:	return r;
+}
+/* }}} */
+/* {{{ [fold] vv6410_set_gains() */
+static int vv6410_set_gains(struct quickcam *qc, unsigned int hue, unsigned int sat, unsigned int val)
+{
+	static const int maxgain = 13;			/* Absolute maximum is 14, recommended is 12 */
+	struct qc_sensor_data *sd = &qc->sensor_data;
+	unsigned int gain;
+	int r;
+
+	if (qcdebug&QC_DEBUGLOGIC) PDEBUG("vv6410_set_gains %d %d %d", hue, sat, val);
+	gain = val / 256;
+	gain >>= 4;
+	if (gain > maxgain) gain = maxgain;
+	if (sd->rgain==gain) return 0;
+	sd->rgain = gain;
+	r = qc_i2c_set(qc, VV6410_ANALOGGAIN, 0xF0 | gain);
+	return r;
+}
+/* }}} */
+/* {{{ [fold] vv6410_set_levels() */
+static int vv6410_set_levels(struct quickcam *qc, unsigned int exp, unsigned int gain, unsigned int hue, unsigned int sat)
+{
+	int r;
+	if ((r = vv6410_set_exposure(qc, exp))<0) goto fail;
+	vv6410_set_gains(qc, hue, sat, gain);
+fail:	return r;
+}
+/* }}} */
+
+/* {{{ [fold] struct qc_sensor qc_sensor_vv6410 */
+const struct qc_sensor qc_sensor_vv6410 = {
+	name:		"VV6410",
+	manufacturer:	"ST Microelectronics",
+	init:		vv6410_init,
+	start:		vv6410_start,
+	stop:		vv6410_stop,
+	set_size:	vv6410_set_size,
+	set_levels:	vv6410_set_levels,
+	/* Exposure and gain control information */
+	autoexposure:	FALSE,
+	adapt_gainlow:	40000,
+	adapt_gainhigh:	65535,
+	/* Information needed to access the sensor via I2C */
+	reg23: 		5,
+	i2c_addr: 	VV6410_ADDR,
+	/* Identification information used for auto-detection */
+	id_reg:		VV6410_DEVICEH,
+	id:		0x19,
+	length_id:	1,
+};
+/* }}} */
+
+/* End of file */
diff -purN linux-2.6.10.orig/drivers/usb/media/qc/quickcam.h linux-2.6.10-qc-usb/drivers/usb/media/qc/quickcam.h
--- linux-2.6.10.orig/drivers/usb/media/qc/quickcam.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.10-qc-usb/drivers/usb/media/qc/quickcam.h	2004-07-29 20:12:39.000000000 +0200
@@ -0,0 +1,582 @@
+#ifndef _LINUX_QUICKCAM_H
+#define _LINUX_QUICKCAM_H
+
+/* {{{ [fold] SECTION: common definitions with userspace applications */
+#define QC_LUT_SIZE	(3*256)		/* Lookup table definition for equalization */
+#define QC_LUT_RED	0
+#define QC_LUT_GREEN	256
+#define QC_LUT_BLUE	512
+
+struct qc_userlut {
+	unsigned int flags;
+#define QC_USERLUT_DEFAULT 1		/* If set, change default settings or the current camera otherwise */
+#define QC_USERLUT_ENABLE  2		/* If set, enable user-specified LUT, or otherwise disable it */
+#define QC_USERLUT_VALUES  4		/* Load new (or store old) values into the lookup-table */
+	unsigned char lut[QC_LUT_SIZE];	/* Lookup table to set or read */
+};
+
+#define VIDEO_PALETTE_BAYER	(('q'<<8) | 1)	/* Grab video in raw Bayer format */
+#define VIDEO_PALETTE_MJPEG	(('q'<<8) | 2)	/* Grab video in compressed MJPEG format */
+#define VID_HARDWARE_QCAM_USB	(('q'<<8) | 50)	/* Device type */
+
+/* Private IOCTL calls */
+#define QC_IOCTLBASE		220				/* Don't use same numbers as Philips driver */
+#define VIDIOCQCGDEBUG		_IOR ('v',QC_IOCTLBASE+0, int)	/* Gets the debug output, bitfield */
+#define VIDIOCQCSDEBUG		_IOWR('v',QC_IOCTLBASE+0, int)	/* Sets the debug output, bitfield */
+#define VIDIOCQCGKEEPSETTINGS	_IOR ('v',QC_IOCTLBASE+1, int)	/* Get keep picture settings across one open to another (0-1) */
+#define VIDIOCQCSKEEPSETTINGS	_IOWR('v',QC_IOCTLBASE+1, int)	/* Set keep picture settings across one open to another (0-1) */
+#define VIDIOCQCGSETTLE		_IOR ('v',QC_IOCTLBASE+2, int)	/* Get if we let image brightness settle (0-1) */
+#define VIDIOCQCSSETTLE		_IOWR('v',QC_IOCTLBASE+2, int)	/* Set if we let image brightness settle (0-1) */
+#define VIDIOCQCGSUBSAMPLE	_IOR ('v',QC_IOCTLBASE+3, int)	/* Gets the speed (0-1) */
+#define VIDIOCQCSSUBSAMPLE	_IOWR('v',QC_IOCTLBASE+3, int)	/* Sets the speed (0-1) */
+#define VIDIOCQCGCOMPRESS	_IOR ('v',QC_IOCTLBASE+4, int)	/* Gets the compression mode (0-1) */
+#define VIDIOCQCSCOMPRESS	_IOWR('v',QC_IOCTLBASE+4, int)	/* Sets the compression mode (0-1) */
+#define VIDIOCQCGFRAMESKIP	_IOR ('v',QC_IOCTLBASE+5, int)	/* Get frame capture frequency (0-10) */
+#define VIDIOCQCSFRAMESKIP	_IOWR('v',QC_IOCTLBASE+5, int)	/* Set frame capture frequency (0-10) */
+#define VIDIOCQCGQUALITY	_IOR ('v',QC_IOCTLBASE+6, int)	/* Gets the interpolation mode (0-2) */
+#define VIDIOCQCSQUALITY	_IOWR('v',QC_IOCTLBASE+6, int)	/* Sets the interpolation mode (0-2) */
+#define VIDIOCQCGADAPTIVE	_IOR ('v',QC_IOCTLBASE+7, int)	/* Get automatic adaptive brightness control (0-1) */
+#define VIDIOCQCSADAPTIVE	_IOWR('v',QC_IOCTLBASE+7, int)	/* Set automatic adaptive brightness control (0-1) */
+#define VIDIOCQCGEQUALIZE	_IOR ('v',QC_IOCTLBASE+8, int)	/* Get equalize image (0-1) */
+#define VIDIOCQCSEQUALIZE	_IOWR('v',QC_IOCTLBASE+8, int)	/* Set equalize image (0-1) */
+#define VIDIOCQCGRETRYERRORS	_IOR ('v',QC_IOCTLBASE+9, int)	/* Get if we retry when capture fails (0-1) */
+#define VIDIOCQCSRETRYERRORS	_IOWR('v',QC_IOCTLBASE+9, int)	/* Set if we retry when capture fails (0-1) */
+#define VIDIOCQCGCOMPATIBLE	_IOR ('v',QC_IOCTLBASE+10,int)	/* Get enable workaround for bugs, bitfield */
+#define VIDIOCQCSCOMPATIBLE	_IOWR('v',QC_IOCTLBASE+10,int)	/* Set enable workaround for bugs, bitfield */
+#define VIDIOCQCGVIDEONR	_IOR ('v',QC_IOCTLBASE+11,int)	/* Get videodevice number (/dev/videoX) */
+#define VIDIOCQCSVIDEONR	_IOWR('v',QC_IOCTLBASE+11,int)	/* Set videodevice number (/dev/videoX) */
+#define VIDIOCQCGUSERLUT	_IOR ('v',QC_IOCTLBASE+12,struct qc_userlut)	/* Get user-specified lookup-table correction */
+#define VIDIOCQCSUSERLUT	_IOWR('v',QC_IOCTLBASE+12,struct qc_userlut)	/* Set user-specified lookup-table correction */
+
+#define VIDIOCQCGSTV		_IOWR('v',QC_IOCTLBASE+20,int)	/* Read STV chip register */
+#define VIDIOCQCSSTV		_IOW ('v',QC_IOCTLBASE+20,int)	/* Write STV chip register */
+#define VIDIOCQCGI2C		_IOWR('v',QC_IOCTLBASE+21,int)	/* Read I2C chip register */
+#define VIDIOCQCSI2C		_IOW ('v',QC_IOCTLBASE+21,int)	/* Write I2C chip register */
+
+/* Debugging message choices */
+#define QC_DEBUGUSER		(1<<0)	/* Messages for interaction with user space (system calls) */
+#define QC_DEBUGCAMERA		(1<<1)	/* Messages for interaction with the camera */
+#define QC_DEBUGINIT		(1<<2)	/* Messages for each submodule initialization/deinit */
+#define QC_DEBUGLOGIC		(1<<3)	/* Messages for entering and failing important functions */
+#define QC_DEBUGERRORS		(1<<4)	/* Messages for all error conditions */
+#define QC_DEBUGADAPTATION	(1<<5)	/* Messages for automatic exposure control workings */
+#define QC_DEBUGCONTROLURBS	(1<<6)	/* Messages for sending I2C control messages via USB */
+#define QC_DEBUGBITSTREAM	(1<<7)	/* Messages for finding chunk codes from camera bitstream */
+#define QC_DEBUGINTERRUPTS	(1<<8)	/* Messages for each interrupt */
+#define QC_DEBUGMUTEX		(1<<9)	/* Messages for acquiring/releasing the mutex */
+#define QC_DEBUGCOMMON		(1<<10)	/* Messages for some common warnings */
+#define QC_DEBUGFRAME		(1<<11)	/* Messages related to producer-consumer in qc_frame_* functions */
+#define QC_DEBUGALL		(~0)	/* Messages for everything */
+
+/* Compatibility choices */
+#define QC_COMPAT_16X		(1<<0)
+#define QC_COMPAT_DBLBUF	(1<<1)
+#define QC_COMPAT_TORGB		(1<<2)	/* Video4Linux API is buggy and doesn't specify byte order for RGB images */
+/* }}} */
+
+#ifdef __KERNEL__
+
+#include <linux/config.h>
+#include <linux/version.h>
+
+#ifdef CONFIG_SMP
+#define __SMP__
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#if defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS)
+#define MODVERSIONS
+#endif
+#ifdef MODVERSIONS
+#include <linux/modversions.h>
+#endif
+#endif
+
+#include <linux/videodev.h>
+#include <linux/usb.h>
+#include <asm/pgtable.h>		/* This is required for testing pte_offset_map */
+#include <linux/spinlock.h>
+
+/* {{{ [fold] SECTION: user configuration */
+#define VERSION		"QuickCam USB $Date: 2004/07/29 18:12:39 $"
+#ifndef COMPRESS
+#define COMPRESS	1		/* 1=include compression support, 0=otherwise */
+#endif
+#ifndef DEBUGLEVEL
+#define DEBUGLEVEL	QC_DEBUGCOMMON
+#endif
+#ifdef NDEBUG				/* Enable debugging if DEBUG is defined; if (also) NDEBUG is defined, disable debugging */
+#undef DEBUG
+#endif
+//#define DEBUG				/* Enable debug code */
+#ifdef DEBUG
+#define PARANOID	1		/* Check consistency of driver state */
+#else
+#define PARANOID	0
+#endif
+/* Default (initial) values */
+#define DEFAULT_BGR	TRUE		/* Use BGR byte order by default (and torgb converts to RGB)? */
+
+#define DUMPDATA	0		/* Dump data from camera to user, no conversion nor length checks (see show.c) */
+/* }}} */
+/* {{{ [fold] SECTION: general utility definitions and macros */
+#define FALSE			0
+#define TRUE			(!FALSE)
+typedef unsigned char Bool;
+#define BIT(x)		(1<<(x))
+#define SIZE(a)		(sizeof(a)/sizeof((a)[0]))
+#define MAX(a,b)	((a)>(b)?(a):(b))
+#define MIN(a,b)	((a)<(b)?(a):(b))
+#define MAX3(a,b,c)	(MAX(a,MAX(b,c)))
+#define MIN3(a,b,c)	(MIN(a,MIN(b,c)))
+#define CLIP(a,low,high) MAX((low),MIN((high),(a)))
+#define ABS(a)		((a)>0?(a):-(a))
+#define SGN(a)		((a)<0 ? -1 : ((a)>0 ? 1 : 0))
+#define CHECK_ERROR(cond,jump,msg,args...)	if (cond) { PDEBUG(msg, ## args); goto jump; }
+#define GET_VENDORID(qc)			((qc)->dev->descriptor.idVendor)
+#define GET_PRODUCTID(qc)			((qc)->dev->descriptor.idProduct)
+/* }}} */
+/* {{{ [fold] SECTION: compatibility */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,2,18)
+#error "Too old kernel. At least Linux 2.2.18 is required."
+#endif
+
+#if LINUX_VERSION_CODE==KERNEL_VERSION(2,4,19) || LINUX_VERSION_CODE==KERNEL_VERSION(2,4,20)
+#warning "Kernels 2.4.19 and 2.4.20 are buggy! Be sure to install patch from:"
+#warning "http://www.ee.oulu.fi/~tuukkat/quickcam/linux-2.4.20-videodevfix.patch"
+#endif
+
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,5,0) && LINUX_VERSION_CODE<KERNEL_VERSION(2,6,0)) || LINUX_VERSION_CODE>=KERNEL_VERSION(2,7,0)
+#warning "Unsupported kernel, may or may not work. Good luck!"
+#endif
+
+#if LINUX_VERSION_CODE>=KERNEL_VERSION(2,4,0) && defined(CONFIG_PROC_FS)
+#define HAVE_PROCFS 1		/* FIXME: I don't think there's any reason to disable procfs with 2.2.x */
+#else
+#define HAVE_PROCFS 0
+#warning "procfs support disabled"
+#endif
+
+#ifndef HAVE_VMA
+#if LINUX_VERSION_CODE>=KERNEL_VERSION(2,5,3) || (defined(RED_HAT_LINUX_KERNEL) && defined(pte_offset_map))
+/* Some RedHat 9 2.4.x patched-to-death kernels need this too */
+#define HAVE_VMA 1
+#else
+#define HAVE_VMA 0
+#endif
+#endif
+
+#if HAVE_VMA && LINUX_VERSION_CODE<KERNEL_VERSION(2,6,0)
+#warning "VMA/RMAP compatibility enabled"
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)	/* 2.4.x emulation for 2.2.x kernels */
+#define MODULE_DEVICE_TABLE(a,b)
+#define USB_DEVICE(vend,prod) idVendor: (vend), idProduct: (prod)
+struct usb_device_id {
+	u16 idVendor;
+	u16 idProduct;
+};
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,5)
+/* This is rather tricky emulation since if versioning is used,
+ * video_register_device is already #defined. */
+static inline int qc_video_register_device(struct video_device *dev, int type) { return video_register_device(dev, type); }
+#undef video_register_device
+#define video_register_device(vdev,type,nr)	qc_video_register_device((vdev), (type))
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,20)
+/* In 2.4.19 and earlier kernels this was called "devrequest*".
+ * Its fields were differently named, but since the structure was same,
+ * we support the older kernels via this uglyish hack. */
+struct usb_ctrlrequest {
+	u8 bRequestType;
+	u8 bRequest;
+	u16 wValue;
+	u16 wIndex;
+	u16 wLength;
+} __attribute__ ((packed));
+#endif
+
+#if LINUX_VERSION_CODE<KERNEL_VERSION(2,4,20) || LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,0)
+/* Things come and go... */
+/* Used only for debugging, so this could be actually removed if needed */
+#define sem_getcount(sem)	atomic_read(&(sem)->count)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static inline int qc_usb_submit_urb(struct urb *urb) { return usb_submit_urb(urb); }
+static inline struct urb *qc_usb_alloc_urb(int packets) { return usb_alloc_urb(packets); }
+#undef usb_submit_urb
+#undef usb_alloc_urb
+#define usb_submit_urb(u,f)	qc_usb_submit_urb(u)
+#define usb_alloc_urb(u,f)	qc_usb_alloc_urb(u)
+#define URB_ISO_ASAP		USB_ISO_ASAP
+#endif
+
+#ifndef list_for_each_entry
+#define list_for_each_entry(pos, head, member)				\
+	for (pos = list_entry((head)->next, typeof(*pos), member);	\
+	     &pos->member != (head); 					\
+	     pos = list_entry(pos->member.next, typeof(*pos), member))
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#undef MOD_INC_USE_COUNT
+#undef MOD_DEC_USE_COUNT
+#define MOD_INC_USE_COUNT
+#define MOD_DEC_USE_COUNT
+#define GET_USE_COUNT(module)	1
+#define EXPORT_NO_SYMBOLS
+#endif
+
+/* }}} */
+/* {{{ [fold] SECTION: debugging */
+#undef PDEBUG			/* undef it, just in case */
+#define POISON_VAL	0x5B
+
+#ifdef DEBUG
+
+#include <linux/time.h>
+/* PDEBUG is rather heavyweight macro and should be used only for debugging--not for general messages */
+/* Based on timestamp by Roger Wolff */
+#define PDEBUG(fmt, args...)				\
+	do {						\
+		struct timeval __tv_val;		\
+		do_gettimeofday(&__tv_val);		\
+		printk(KERN_DEBUG "quickcam [%2ld.%06ld]: ", __tv_val.tv_sec%60, __tv_val.tv_usec);	\
+		printk(fmt, ## args); 			\
+		printk("\n"); 				\
+	} while(0)
+#define IDEBUG_VAR	char *idebug_var;
+#define IDEBUG_INIT(x)	do { \
+	if ((x).idebug_var==((char*)&((x).idebug_var)) + 0xB967E57D) printk(KERN_CRIT __FILE__ ":%i: Init already done\n",__LINE__); \
+	(x).idebug_var = ((char*)&((x).idebug_var)) + 0xB967E57D; \
+} while(0)
+#define IDEBUG_TEST(x)	do { \
+	if ((x).idebug_var!=((char*)&((x).idebug_var)) + 0xB967E57D) printk(KERN_CRIT __FILE__ ":%i: Init missing\n",__LINE__); \
+} while(0)
+#define IDEBUG_EXIT(x)	do { \
+	IDEBUG_TEST(x); \
+	(x).idebug_var = NULL; \
+	POISON(x); \
+} while(0)
+#define IDEBUG_EXIT_NOPOISON(x)	do { \
+	IDEBUG_TEST(x); \
+	(x).idebug_var = NULL; \
+} while(0)
+#define TEST_BUG(condition) \
+	do { \
+		if ((condition)!=0) { \
+			PDEBUG("Badness in %s at %s:%d", __FUNCTION__, __FILE__, __LINE__); \
+			return; \
+		} \
+	} while (0)
+#define TEST_BUGR(condition) \
+	do { \
+		if ((condition)!=0) { \
+			PDEBUG("Badness in %s at %s:%d", __FUNCTION__, __FILE__, __LINE__); \
+			return -EFAULT; \
+		} \
+	} while (0)
+#define TEST_BUG_MSG(cond, fmt, args...) \
+	do { \
+		if ((cond)!=0) { \
+			PDEBUG(fmt, ## args); \
+			PDEBUG("Badness in %s at %s:%d", __FUNCTION__, __FILE__, __LINE__); \
+			return; \
+		} \
+	} while (0)
+#define TEST_BUGR_MSG(cond, fmt, args...) \
+	do { \
+		if ((cond)!=0) { \
+			PDEBUG(fmt, ## args); \
+			PDEBUG("Badness in %s at %s:%d", __FUNCTION__, __FILE__, __LINE__); \
+			return -EFAULT; \
+		} \
+	} while (0)
+#define POISON(obj)	do { memset(&(obj),POISON_VAL,sizeof(obj)); } while(0)
+
+#else
+
+#define PDEBUG(fmt, args...)
+#define IDEBUG_VAR
+#define IDEBUG_INIT(x)
+#define IDEBUG_TEST(x)
+#define IDEBUG_EXIT(x)
+#define IDEBUG_EXIT_NOPOISON(x)
+#define TEST_BUG(x)
+#define TEST_BUGR(x)
+#define TEST_BUG_MSG(cond, fmt, args...)
+#define TEST_BUGR_MSG(cond, fmt, args...)
+#define POISON(obj)
+
+#endif /* DEBUG */
+
+//gcc is buggy? This doesn't work
+//#define PRINTK(lvl, fmt, args...)	printk(lvl "quickcam: " fmt "\n", ## args)
+#define PRINTK(lvl, fmt, args...)	do { printk(lvl "quickcam: " fmt, ## args); printk("\n"); } while (0)
+/* }}} */
+/* {{{ [fold] SECTION: hardware related stuff */
+#define QUICKCAM_ISOPIPE 	0x81
+
+/* Control register of the STV0600 ASIC */
+#define STV_ISO_ENABLE 		0x1440
+#define STV_SCAN_RATE  		0x1443
+#define STV_ISO_SIZE 		0x15C1
+#define STV_Y_CTRL   		0x15C3
+#define STV_X_CTRL   		0x1680
+#define STV_REG00 		0x1500
+#define STV_REG01 		0x1501
+#define STV_REG02 		0x1502
+#define STV_REG03 		0x1503
+#define STV_REG04 		0x1504
+#define STV_REG23 		0x0423
+
+/* Maximum frame size that any sensor can deliver */
+#define MAX_FRAME_WIDTH		360
+#define MAX_FRAME_HEIGHT	296
+/* }}} */
+/* {{{ [fold] SECTION: struct quickcam datatype and related values */
+
+/* {{{ [fold] qc_sensor_data: Sensor related data (unique to each camera) */
+struct qc_sensor_data {
+	const struct qc_sensor *sensor;	/* Autodetected when camera is plugged in */
+	int maxwidth;			/* Maximum size the sensor can deliver */
+	int maxheight;
+	int width;			/* Size delivered by the sensor (-1=unknown) */
+	int height;
+	int exposure;			/* Current exposure in effect (sensor-specific value, -1=unknown) */
+	int rgain, ggain, bgain;	/* Current gains in effect (sensor-specific values, -1=unknown) */
+	unsigned int subsample : 1;	/* Set into subsampling mode? */
+	unsigned int compress : 1;	/* Set into compressed mode? */
+};
+/* }}} */
+/* {{{ [fold] qc_i2c_data: I2C command queue for writing commands to camera */
+#define I2C_MAXCOMMANDS 	16	/* Should be about 1-2 times the size of transfer buffer (=16) for maximum performance */
+#define I2C_FLAG_WORD 		BIT(0)	/* Set if a 16-bit value is sent, otherwise 8-bit value */
+#define I2C_FLAG_BREAK 		BIT(1)	/* Set if this is the last command in a packet */
+struct qc_i2c_data {
+	struct urb *urb;
+	struct {
+		u8 loval;
+		u8 hival;
+		u8 regnum;
+		u8 flags;
+	} commands[I2C_MAXCOMMANDS];
+	/* 2=URB scheduled, need to schedule extra packet for QuickCam Web at completion */
+	volatile int packets;		/* 0=no URBs scheduled, 1=URB scheduled */
+	volatile unsigned int newhead;	/* Points to first free buffer position */
+	volatile unsigned int head;	/* Points to oldest command which was not yet flushed */
+	volatile unsigned int tail;	/* Points to next position which needs to be send, modified from interrupt */
+	wait_queue_head_t wq;		/* Woken up when all pending data is sent */
+	IDEBUG_VAR
+};
+/* }}} */
+/* {{{ [fold] qc_isoc_data: Isochronous transfer queue control data for reading from camera */
+#define ISOC_URBS		2	/* Number of URBs to use */
+#define ISOC_PACKETS		10	/* How many isochronous data packets per URB */
+#define ISOC_PACKET_SIZE	1023	/* Max size of one packet (shouldn't be hardcoded JFC was 960) */
+struct qc_isoc_data {
+	struct urb *urbs[ISOC_URBS];
+	unsigned char *buffer;		/* Isochronous data transfer buffers */
+	int errorcount;
+	Bool streaming;			/* TRUE if URBs are allocated and submitted */
+	IDEBUG_VAR
+};
+/* }}} */
+/* {{{ [fold] qc_stream_data: Camera data stream control data */
+struct qc_stream_data {
+	Bool capturing;			/* Are we capturing data for a frame? */
+	int frameskip;			/* How frequently to capture frames? 0=each frame, 1=every other */
+	IDEBUG_VAR
+};
+/* }}} */
+/* {{{ [fold] qc_frame_data: Raw frame (bayer/mjpeg) buffers */
+#define FRAME_BUFFERS	2		/* We are double buffering */
+#define FRAME_DATASIZE	(MAX_FRAME_WIDTH*MAX_FRAME_HEIGHT)	/* About 101 kilobytes (assume that compressed frame is always smaller) */
+struct qc_frame_data {
+	struct {
+		int rawdatalen;		/* Number of used bytes of this frame buffer */
+	} buffers[FRAME_BUFFERS];
+	unsigned char *rawdatabuf;	/* vmalloc'd chunk containing the all raw frame data buffers concatenated */
+	int maxrawdatalen;		/* Maximum amount of data we are willing to accept in bytes, */
+					/* zero indicates that we are not grabbing current frame (but just throwing data away) */
+	volatile unsigned int head;	/* The buffer to be captured next (empty or grabbing, if full, then whole buffer is full) */
+	volatile unsigned int tail;	/* The buffer to be consumed next (full, unless equals head, then it is empty/grabbing) */
+	spinlock_t tail_lock;		/* Protects tail changes */
+	volatile Bool tail_in_use;	/* TRUE, when consumer is processing the frame pointed to by tail */
+
+	wait_queue_head_t wq;		/* Processes waiting for more data in the buffer */
+	volatile int waiting;		/* Number of processes waiting in the wait queues */
+	volatile Bool exiting;		/* Set to TRUE when we want to quit */
+	volatile int lost_frames;	/* Increased by one for every lost (non-captured by applications) frame, reset when a frame is captured */
+	IDEBUG_VAR
+};
+/* }}} */
+/* {{{ [fold] qc_mjpeg_data: MJPEG decoding data */
+struct qc_mjpeg_data {
+	int depth;			/* Bits per pixel in the final RGB image: 16 or 24 */
+	u8 *encV;			/* Temporary buffers for holding YUV image data */
+	u8 *encU;
+	u8 *encY;
+	/* yuv2rgb private data */
+	void *table;
+	void *table_rV[256];
+	void *table_gU[256];
+	int table_gV[256];
+	void *table_bU[256];
+	void (*yuv2rgb_func)(struct qc_mjpeg_data *, u8 *, u8 *, u8 *, u8 *, void *, void *, int);
+	IDEBUG_VAR
+};
+/* }}} */
+/* {{{ [fold] qc_fmt_data: Format conversion routines private data */
+struct qc_fmt_data {
+	unsigned char userlut[QC_LUT_SIZE];	/* User specified fixed look-up table, initialized when camera is plugged in */
+	unsigned char lut[QC_LUT_SIZE];		/* Dynamically calculated LUT, for which userlut is applied to */
+#if COMPRESS
+	struct qc_mjpeg_data mjpeg_data;
+	Bool compress;			/* Was compression subsystem initialized? */
+#endif
+	IDEBUG_VAR
+};
+/* }}} */
+/* {{{ [fold] qc_capt_data: Formatted image capturing control data */
+/* qc_capt_data: Formatted image capturing control data. */
+#define MAX_FRAME_SIZE (MAX_FRAME_WIDTH*MAX_FRAME_HEIGHT*4)	/* Video Size 356x292x4 bytes for 0RGB 32 bpp mode */
+struct qc_capt_data {
+	unsigned char *frame;		/* Final image data buffer given to application, size MAX_FRAME_SIZE (mmappable) */
+	Bool settled;			/* Has the picture settled after last open? */
+	IDEBUG_VAR
+};
+/* }}} */
+/* {{{ [fold] qc_adapt_data: Automatic exposure control data */
+/* There are three different exposure control algorithms for different cases */
+struct qc_adapt_data {
+	int olddelta;
+	int oldmidvalue, midvaluesum;
+	int oldexposure, exposure;
+	int gain;
+	int framecounter;
+	enum {
+		EXPCONTROL_SATURATED,	/* Picture is over/undersaturated, halve/double brightness */
+		EXPCONTROL_NEWTON,	/* Using Newton linear estimation */
+		EXPCONTROL_FLOAT,	/* Very near correct brightness, float exposure slightly */
+	} controlalg;
+	IDEBUG_VAR
+};
+/* }}} */
+/* {{{ [fold] qc_settings_data: User settings given by qcset or module parameters, initialized when camera is plugged in */
+struct qc_settings_data {
+	unsigned int keepsettings  : 1;	/* Keep all settings at each camera open (or reset most of them) */
+	unsigned int subsample     : 1;	/* Normal or sub-sample (sub-sample to increase the speed) */
+	unsigned int compress      : 1;	/* Enable compressed mode if available (higher framerate) */
+	unsigned int frameskip     : 4;	/* How many frames to skip (higher=lower framerate) */
+	unsigned int quality       : 3;	/* Quality of format conversion (higher=better but slower) */
+	unsigned int adaptive      : 1;	/* Use automatic exposure control */
+	unsigned int equalize      : 1;	/* Equalize images */
+	unsigned int userlut       : 1;	/* Apply user-specified lookup-table */
+	unsigned int retryerrors   : 1;	/* If errors happen when capturing an image, retry a few times? */
+	unsigned int compat_16x    : 1;	/* Compatibility: force image size to multiple of 16 */
+	unsigned int compat_dblbuf : 1;	/* Compatibility: fake doublebuffering for applications */
+	unsigned int compat_torgb  : 1;	/* Compatibility: use RGB data order, not BGR */
+	unsigned int settle        : 8;	/* Maximum number of frames to wait image brightness to settle */
+	/* Total: 25 bits */
+};
+/* }}} */
+
+/* Main per-camera data structure, most important thing in whole driver */
+struct quickcam {
+	/* The following entries are initialized in qc_usb_init() when camera is plugged in */
+	struct semaphore lock;			/* Allow only one process to access quickcam at a time */
+	struct list_head list;			/* All cameras are in a doubly linked list */
+	int users;				/* User count (simultaneous open count) */
+	struct usb_device *dev;			/* USB device, set to NULL when camera disconnected and interrupts disabled */
+	unsigned char iface;			/* The interface number in the camera device we are bound to */
+	Bool connected;				/* Set to FALSE immediately when the camera is disconnected (even before interrupts are disabled) */
+	struct video_device vdev;		/* Used for registering the camera driver for Video4Linux */
+	struct qc_settings_data settings;	/* General user settings set with e.g. qcset */
+#if HAVE_PROCFS
+	struct proc_dir_entry *proc_entry;
+#endif
+	/* The following entries are initialized in qc_v4l_init() when the camera device is opened */
+	struct video_picture vpic;		/* Contains the last values set by user (which is reported to user) */
+	Bool vpic_pending;			/* Settings in vpic were changed but are not yet in effect */
+	struct video_window vwin;		/* Contains the image size and position the user is expecting */
+
+	/* Private structures for each module, initialized in corresponding init-function */
+	struct qc_i2c_data i2c_data;		/* Filled when the camera is plugged in or driver loaded */
+	struct qc_adapt_data adapt_data;	/* Filled when the camera is plugged in or driver loaded */
+	struct qc_sensor_data sensor_data;	/* Mostly filled when the device is opened */
+	struct qc_stream_data stream_data;	/* Filled when the device is opened */
+	struct qc_frame_data frame_data;	/* Filled when the device is opened */
+	struct qc_capt_data capt_data;		/* Filled when the device is opened */
+	struct qc_isoc_data isoc_data;		/* Filled when the device is opened */
+	struct qc_fmt_data fmt_data;		/* Mostly filled when the device is opened, except for userlut */
+
+	u8 dmabuf[35];				/* Temporary buffer which may be used for DMA transfer */
+};
+/* }}} */
+/* {{{ [fold] SECTION: miscelleneous */
+/* Constant information related to a sensor type */
+struct qc_sensor {
+	char *name;
+	char *manufacturer;
+	int (*init)(struct quickcam *qc);					/* Initialize sensor */
+	int (*start)(struct quickcam *qc);					/* Start sending image data */
+	int (*stop)(struct quickcam *qc);					/* Stop sending image data */
+	int (*set_size)(struct quickcam *qc, unsigned int w, unsigned int h);	/* Request camera to send the given image size */
+			/* Set primary brightness value exp (usually exposure time) and HSV 0-65535 (usually gains) */
+	int (*set_levels)(struct quickcam *qc, unsigned int exp, unsigned int gain, unsigned int hue, unsigned int sat);
+	int (*set_target)(struct quickcam *qc, unsigned int val);		/* Set target brightness for sensor autoexposure 0-65535 */
+	/* Exposure and gain control information */
+	Bool autoexposure;							/* Sensor has automatic exposure control */
+	int adapt_gainlow;							/* (0-65535) How eagerly to decrease gain when necessary */
+	int adapt_gainhigh;							/* (0-65535) How eagerly to increase gain when necessary */
+	/* Information needed to access the sensor via I2C */
+	int reg23;
+	unsigned char i2c_addr;
+	/* Identification information used for auto-detection */
+	int id_reg;
+	unsigned char id;
+	int length_id;
+	int flag;			/* May be used by sensor driver for private purposes */
+};
+/* }}} */
+/* {{{ [fold] SECTION: function prototypes */
+/* USB interface chip control */
+int qc_i2c_break(struct quickcam *qc);
+int qc_i2c_wait(struct quickcam *qc);
+int qc_i2c_set(struct quickcam *qc, unsigned char reg, unsigned char val);
+int qc_i2c_setw(struct quickcam *qc, unsigned char reg, unsigned short val);
+
+int qc_stv_set(struct quickcam *qc, unsigned short reg, unsigned char val);
+int qc_stv_setw(struct quickcam *qc, unsigned short reg, unsigned short val);
+int qc_stv_get(struct quickcam *qc, unsigned short reg);
+
+/* Image format conversion routines */
+int qc_fmt_convert(struct quickcam *qc, unsigned char *src, unsigned int src_len, unsigned char *dst, unsigned int dst_len, int *midvalue);
+int qc_fmt_issupported(int format);
+const char *qc_fmt_getname(int format);
+int qc_fmt_getdepth(int format);
+int qc_fmt_init(struct quickcam *qc);
+void qc_fmt_exit(struct quickcam *qc);
+
+int qc_mjpeg_decode(struct qc_mjpeg_data *md, unsigned char *src, int src_len, unsigned char *dst);
+int qc_mjpeg_init(struct qc_mjpeg_data *md, int depth, Bool tobgr);
+void qc_mjpeg_exit(struct qc_mjpeg_data *md);
+
+void qc_hsv2rgb(s16 hue, u16 sat, u16 val, int *red, int *green, int *blue);
+int qc_get_i2c(struct quickcam *qc, const struct qc_sensor *sensor, int reg);
+void qc_frame_flush(struct quickcam *qc);
+
+void qc_usleep(unsigned long usec);
+extern int qcdebug;				/* Driver debuglevel */
+/* }}} */
+
+#endif /* __KERNEL__ */
+
+#endif /* __LINUX_QUICKCAM_H */


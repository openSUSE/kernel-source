From: Hannes Reinecke <hare@suse.de>
Subject: drm driver update

Repsitory location: dri.freedesktop.org:/cvs/dri
Snapshot from 05 July 2005.

 drivers/char/drm/Kconfig            |   38 
 drivers/char/drm/Makefile           |   37 
 drivers/char/drm/ati_pcigart.c      |  154 
 drivers/char/drm/drm.h              |  369 
 drivers/char/drm/drmP.h             | 1047 +-
 drivers/char/drm/drm_agpsupport.c   |  284 
 drivers/char/drm/drm_auth.c         |   69 
 drivers/char/drm/drm_bufs.c         | 1385 +--
 drivers/char/drm/drm_compat.h       |  199 
 drivers/char/drm/drm_context.c      |  305 
 drivers/char/drm/drm_core.h         |    3 
 drivers/char/drm/drm_dma.c          |   84 
 drivers/char/drm/drm_drawable.c     |    8 
 drivers/char/drm/drm_drv.c          |  531 -
 drivers/char/drm/drm_fops.c         |  496 -
 drivers/char/drm/drm_init.c         |   52 
 drivers/char/drm/drm_ioctl.c        |  168 
 drivers/char/drm/drm_irq.c          |  170 
 drivers/char/drm/drm_lock.c         |  204 
 drivers/char/drm/drm_memory.c       |   67 
 drivers/char/drm/drm_memory.h       |  104 
 drivers/char/drm/drm_memory_debug.c |  481 +
 drivers/char/drm/drm_memory_debug.h |  365 
 drivers/char/drm/drm_os_linux.h     |   62 
 drivers/char/drm/drm_pci.c          |   70 
 drivers/char/drm/drm_pciids.h       |  459 -
 drivers/char/drm/drm_pciids.txt     |  216 
 drivers/char/drm/drm_proc.c         |  277 
 drivers/char/drm/drm_sarea.h        |   32 
 drivers/char/drm/drm_scatter.c      |  178 
 drivers/char/drm/drm_stub.c         |  239 
 drivers/char/drm/drm_sysfs.c        |   65 
 drivers/char/drm/drm_vm.c           |  418 
 drivers/char/drm/ffb_context.c      |  325 
 drivers/char/drm/ffb_drv.c          |  172 
 drivers/char/drm/ffb_drv.h          |   16 
 drivers/char/drm/gamma_context.h    |  492 -
 drivers/char/drm/gamma_dma.c        |  946 --
 drivers/char/drm/gamma_drm.h        |   90 
 drivers/char/drm/gamma_drv.c        |   59 
 drivers/char/drm/gamma_drv.h        |  147 
 drivers/char/drm/gamma_lists.h      |  215 
 drivers/char/drm/gamma_lock.h       |  140 
 drivers/char/drm/gamma_old_dma.h    |  313 
 drivers/char/drm/i810_dma.c         | 1163 +-
 drivers/char/drm/i810_drm.h         |   80 
 drivers/char/drm/i810_drv.c         |   62 
 drivers/char/drm/i810_drv.h         |   38 
 drivers/char/drm/i830_dma.c         | 1362 +--
 drivers/char/drm/i830_drm.h         |  120 
 drivers/char/drm/i830_drv.c         |   57 
 drivers/char/drm/i830_drv.h         |   68 
 drivers/char/drm/i830_irq.c         |  149 
 drivers/char/drm/i915_dma.c         |  131 
 drivers/char/drm/i915_drm.h         |   10 
 drivers/char/drm/i915_drv.c         |   68 
 drivers/char/drm/i915_drv.h         |   65 
 drivers/char/drm/i915_ioc32.c       |  221 
 drivers/char/drm/i915_irq.c         |   14 
 drivers/char/drm/i915_mem.c         |   18 
 drivers/char/drm/i915_pm.c          |  167 
 drivers/char/drm/imagine_drv.c      |  102 
 drivers/char/drm/imagine_drv.h      |   43 
 drivers/char/drm/mach64_dma.c       | 1527 +++
 drivers/char/drm/mach64_drm.h       |  255 
 drivers/char/drm/mach64_drv.c       |  127 
 drivers/char/drm/mach64_drv.h       | 1043 ++
 drivers/char/drm/mach64_irq.c       |  135 
 drivers/char/drm/mach64_state.c     |  916 ++
 drivers/char/drm/mga_dma.c          |  974 +-
 drivers/char/drm/mga_drm.h          |  212 
 drivers/char/drm/mga_drv.c          |   97 
 drivers/char/drm/mga_drv.h          |  126 
 drivers/char/drm/mga_ioc32.c        |  167 
 drivers/char/drm/mga_irq.c          |  103 
 drivers/char/drm/mga_state.c        | 1108 +-
 drivers/char/drm/mga_ucode.h        |16070 ++++++++++++++++++------------------
 drivers/char/drm/mga_warp.c         |  208 
 drivers/char/drm/r128_cce.c         |  594 -
 drivers/char/drm/r128_drm.h         |   32 
 drivers/char/drm/r128_drv.c         |   56 
 drivers/char/drm/r128_drv.h         |   80 
 drivers/char/drm/r128_ioc32.c       |  219 
 drivers/char/drm/r128_irq.c         |   53 
 drivers/char/drm/r128_state.c       | 1400 +--
 drivers/char/drm/radeon_cp.c        | 1937 ++--
 drivers/char/drm/radeon_drm.h       |  268 
 drivers/char/drm/radeon_drv.c       |   69 
 drivers/char/drm/radeon_drv.h       |  213 
 drivers/char/drm/radeon_irq.c       |  126 
 drivers/char/drm/radeon_mem.c       |  144 
 drivers/char/drm/radeon_state.c     | 2104 ++--
 drivers/char/drm/savage_bci.c       | 1086 ++
 drivers/char/drm/savage_drm.h       |  209 
 drivers/char/drm/savage_drv.c       |  124 
 drivers/char/drm/savage_drv.h       |  582 +
 drivers/char/drm/savage_state.c     | 1146 ++
 drivers/char/drm/sis_drm.h          |    2 
 drivers/char/drm/sis_drv.c          |   54 
 drivers/char/drm/sis_drv.h          |   10 
 drivers/char/drm/sis_ds.c           |   82 
 drivers/char/drm/sis_ds.h           |   42 
 drivers/char/drm/sis_mm.c           |  149 
 drivers/char/drm/tdfx_drv.c         |   47 
 drivers/char/drm/tdfx_drv.h         |    4 
 drivers/char/drm/via_3d_reg.h       | 1651 +++
 drivers/char/drm/via_dma.c          |  741 +
 drivers/char/drm/via_drm.h          |  243 
 drivers/char/drm/via_drv.c          |  140 
 drivers/char/drm/via_drv.h          |  118 
 drivers/char/drm/via_ds.c           |  280 
 drivers/char/drm/via_ds.h           |  104 
 drivers/char/drm/via_irq.c          |  339 
 drivers/char/drm/via_map.c          |  110 
 drivers/char/drm/via_mm.c           |  358 
 drivers/char/drm/via_mm.h           |   40 
 drivers/char/drm/via_verifier.c     | 1061 ++
 drivers/char/drm/via_verifier.h     |   61 
 drivers/char/drm/via_video.c        |   97 
 119 files changed, 33945 insertions(+), 20787 deletions(-)

diff -purN linux-2.6.12.orig/drivers/char/drm/ati_pcigart.c linux-2.6.12/drivers/char/drm/ati_pcigart.c
--- linux-2.6.12.orig/drivers/char/drm/ati_pcigart.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/ati_pcigart.c	2005-07-05 08:37:27.000000000 +0200
@@ -1,5 +1,5 @@
 /**
- * \file ati_pcigart.h 
+ * \file ati_pcigart.h
  * ATI PCI GART support
  *
  * \author Gareth Hughes <gareth@valinux.com>
@@ -52,85 +52,47 @@
 # define ATI_MAX_PCIGART_PAGES		8192	/**< 32 MB aperture, 4K pages */
 # define ATI_PCIGART_PAGE_SIZE		4096	/**< PCI GART page size */
 
-unsigned long drm_ati_alloc_pcigart_table( void )
+static unsigned long drm_ati_alloc_pcigart_table(void)
 {
 	unsigned long address;
 	struct page *page;
 	int i;
-	DRM_DEBUG( "%s\n", __FUNCTION__ );
+	DRM_DEBUG("%s\n", __FUNCTION__);
 
-	address = __get_free_pages( GFP_KERNEL, ATI_PCIGART_TABLE_ORDER );
-	if ( address == 0UL ) {
+	address = __get_free_pages(GFP_KERNEL, ATI_PCIGART_TABLE_ORDER);
+	if (address == 0UL) {
 		return 0;
 	}
 
-	page = virt_to_page( address );
+	page = virt_to_page(address);
 
-	for ( i = 0 ; i < ATI_PCIGART_TABLE_PAGES ; i++, page++ ) {
+	for (i = 0; i < ATI_PCIGART_TABLE_PAGES; i++, page++) {
 		get_page(page);
-		SetPageReserved( page );
+		SetPageReserved(page);
 	}
 
-	DRM_DEBUG( "%s: returning 0x%08lx\n", __FUNCTION__, address );
+	DRM_DEBUG("%s: returning 0x%08lx\n", __FUNCTION__, address);
 	return address;
 }
 
-static void drm_ati_free_pcigart_table( unsigned long address )
+static void drm_ati_free_pcigart_table(unsigned long address)
 {
 	struct page *page;
 	int i;
-	DRM_DEBUG( "%s\n", __FUNCTION__ );
+	DRM_DEBUG("%s\n", __FUNCTION__);
 
-	page = virt_to_page( address );
+	page = virt_to_page(address);
 
-	for ( i = 0 ; i < ATI_PCIGART_TABLE_PAGES ; i++, page++ ) {
+	for (i = 0; i < ATI_PCIGART_TABLE_PAGES; i++, page++) {
 		__put_page(page);
-		ClearPageReserved( page );
+		ClearPageReserved(page);
 	}
 
-	free_pages( address, ATI_PCIGART_TABLE_ORDER );
+	free_pages(address, ATI_PCIGART_TABLE_ORDER);
 }
 
-int drm_ati_pcigart_cleanup( drm_device_t *dev,
-			      unsigned long addr,
-			      dma_addr_t bus_addr)
-{
-	drm_sg_mem_t *entry = dev->sg;
-	unsigned long pages;
-	int i;
-
-	/* we need to support large memory configurations */
-	if ( !entry ) {
-		DRM_ERROR( "no scatter/gather memory!\n" );
-		return 0;
-	}
-
-	if ( bus_addr ) {
-		pci_unmap_single(dev->pdev, bus_addr,
-				 ATI_PCIGART_TABLE_PAGES * PAGE_SIZE,
-				 PCI_DMA_TODEVICE);
-
-		pages = ( entry->pages <= ATI_MAX_PCIGART_PAGES )
-		        ? entry->pages : ATI_MAX_PCIGART_PAGES;
-
-		for ( i = 0 ; i < pages ; i++ ) {
-			if ( !entry->busaddr[i] ) break;
-			pci_unmap_single(dev->pdev, entry->busaddr[i],
-					 PAGE_SIZE, PCI_DMA_TODEVICE);
-		}
-	}
-
-	if ( addr ) {
-		drm_ati_free_pcigart_table( addr );
-	}
-
-	return 1;
-}
-EXPORT_SYMBOL(drm_ati_pcigart_cleanup);
-
-int drm_ati_pcigart_init( drm_device_t *dev,
-			   unsigned long *addr,
-			   dma_addr_t *bus_addr)
+int drm_ati_pcigart_init(drm_device_t * dev,
+			 unsigned long *addr, dma_addr_t * bus_addr)
 {
 	drm_sg_mem_t *entry = dev->sg;
 	unsigned long address = 0;
@@ -138,48 +100,48 @@ int drm_ati_pcigart_init( drm_device_t *
 	u32 *pci_gart, page_base, bus_address = 0;
 	int i, j, ret = 0;
 
-	if ( !entry ) {
-		DRM_ERROR( "no scatter/gather memory!\n" );
+	if (!entry) {
+		DRM_ERROR("no scatter/gather memory!\n");
 		goto done;
 	}
 
 	address = drm_ati_alloc_pcigart_table();
-	if ( !address ) {
-		DRM_ERROR( "cannot allocate PCI GART page!\n" );
+	if (!address) {
+		DRM_ERROR("cannot allocate PCI GART page!\n");
 		goto done;
 	}
 
-	if ( !dev->pdev ) {
-		DRM_ERROR( "PCI device unknown!\n" );
+	if (!dev->pdev) {
+		DRM_ERROR("PCI device unknown!\n");
 		goto done;
 	}
 
 	bus_address = pci_map_single(dev->pdev, (void *)address,
-				  ATI_PCIGART_TABLE_PAGES * PAGE_SIZE,
-				  PCI_DMA_TODEVICE);
+				     ATI_PCIGART_TABLE_PAGES * PAGE_SIZE,
+				     PCI_DMA_TODEVICE);
 	if (bus_address == 0) {
-		DRM_ERROR( "unable to map PCIGART pages!\n" );
-		drm_ati_free_pcigart_table( address );
+		DRM_ERROR("unable to map PCIGART pages!\n");
+		drm_ati_free_pcigart_table(address);
 		address = 0;
 		goto done;
 	}
 
-	pci_gart = (u32 *)address;
+	pci_gart = (u32 *) address;
 
-	pages = ( entry->pages <= ATI_MAX_PCIGART_PAGES )
-		? entry->pages : ATI_MAX_PCIGART_PAGES;
+	pages = (entry->pages <= ATI_MAX_PCIGART_PAGES)
+	    ? entry->pages : ATI_MAX_PCIGART_PAGES;
 
-	memset( pci_gart, 0, ATI_MAX_PCIGART_PAGES * sizeof(u32) );
+	memset(pci_gart, 0, ATI_MAX_PCIGART_PAGES * sizeof(u32));
 
-	for ( i = 0 ; i < pages ; i++ ) {
+	for (i = 0; i < pages; i++) {
 		/* we need to support large memory configurations */
 		entry->busaddr[i] = pci_map_single(dev->pdev,
-					   page_address( entry->pagelist[i] ),
-					   PAGE_SIZE,
-					   PCI_DMA_TODEVICE);
+						   page_address(entry->
+								pagelist[i]),
+						   PAGE_SIZE, PCI_DMA_TODEVICE);
 		if (entry->busaddr[i] == 0) {
-			DRM_ERROR( "unable to map PCIGART pages!\n" );
-			drm_ati_pcigart_cleanup( dev, address, bus_address );
+			DRM_ERROR("unable to map PCIGART pages!\n");
+			drm_ati_pcigart_cleanup(dev, address, bus_address);
 			address = 0;
 			bus_address = 0;
 			goto done;
@@ -187,7 +149,7 @@ int drm_ati_pcigart_init( drm_device_t *
 		page_base = (u32) entry->busaddr[i];
 
 		for (j = 0; j < (PAGE_SIZE / ATI_PCIGART_PAGE_SIZE); j++) {
-			*pci_gart++ = cpu_to_le32( page_base );
+			*pci_gart++ = cpu_to_le32(page_base);
 			page_base += ATI_PCIGART_PAGE_SIZE;
 		}
 	}
@@ -200,9 +162,47 @@ int drm_ati_pcigart_init( drm_device_t *
 	mb();
 #endif
 
-done:
+      done:
 	*addr = address;
 	*bus_addr = bus_address;
 	return ret;
 }
 EXPORT_SYMBOL(drm_ati_pcigart_init);
+
+int drm_ati_pcigart_cleanup(drm_device_t * dev,
+			    unsigned long addr, dma_addr_t bus_addr)
+{
+	drm_sg_mem_t *entry = dev->sg;
+	unsigned long pages;
+	int i;
+
+	/* we need to support large memory configurations */
+	if (!entry) {
+		DRM_ERROR("no scatter/gather memory!\n");
+		return 0;
+	}
+
+	if (bus_addr) {
+		pci_unmap_single(dev->pdev, bus_addr,
+				 ATI_PCIGART_TABLE_PAGES * PAGE_SIZE,
+				 PCI_DMA_TODEVICE);
+
+		pages = (entry->pages <= ATI_MAX_PCIGART_PAGES)
+		    ? entry->pages : ATI_MAX_PCIGART_PAGES;
+
+		for (i = 0; i < pages; i++) {
+			if (!entry->busaddr[i])
+				break;
+			pci_unmap_single(dev->pdev, entry->busaddr[i],
+					 PAGE_SIZE, PCI_DMA_TODEVICE);
+		}
+	}
+
+	if (addr) {
+		drm_ati_free_pcigart_table(addr);
+	}
+
+	return 1;
+}
+EXPORT_SYMBOL(drm_ati_pcigart_cleanup);
+
diff -purN linux-2.6.12.orig/drivers/char/drm/drm_agpsupport.c linux-2.6.12/drivers/char/drm/drm_agpsupport.c
--- linux-2.6.12.orig/drivers/char/drm/drm_agpsupport.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/drm_agpsupport.c	2005-07-05 08:37:27.000000000 +0200
@@ -1,7 +1,7 @@
 /**
- * \file drm_agpsupport.h 
+ * \file drm_agpsupport.c
  * DRM support for AGP/GART backend
- *    
+ *
  * \author Rickard E. (Rik) Faith <faith@valinux.com>
  * \author Gareth Hughes <gareth@valinux.com>
  */
@@ -37,7 +37,7 @@
 #if __OS_HAS_AGP
 
 /**
- * AGP information ioctl.
+ * Get AGP information.
  *
  * \param inode device inode.
  * \param filp file pointer.
@@ -48,63 +48,83 @@
  * Verifies the AGP device has been initialized and acquired and fills in the
  * drm_agp_info structure with the information in drm_agp_head::agp_info.
  */
-int drm_agp_info(struct inode *inode, struct file *filp,
-		  unsigned int cmd, unsigned long arg)
+int drm_agp_info(drm_device_t * dev, drm_agp_info_t *info)
 {
-	drm_file_t	 *priv	 = filp->private_data;
-	drm_device_t	 *dev	 = priv->head->dev;
-	DRM_AGP_KERN     *kern;
-	drm_agp_info_t   info;
+	DRM_AGP_KERN *kern;
 
 	if (!dev->agp || !dev->agp->acquired)
 		return -EINVAL;
 
-	kern                   = &dev->agp->agp_info;
-	info.agp_version_major = kern->version.major;
-	info.agp_version_minor = kern->version.minor;
-	info.mode              = kern->mode;
-	info.aperture_base     = kern->aper_base;
-	info.aperture_size     = kern->aper_size * 1024 * 1024;
-	info.memory_allowed    = kern->max_memory << PAGE_SHIFT;
-	info.memory_used       = kern->current_memory << PAGE_SHIFT;
-	info.id_vendor         = kern->device->vendor;
-	info.id_device         = kern->device->device;
+	kern = &dev->agp->agp_info;
+	info->agp_version_major = kern->version.major;
+	info->agp_version_minor = kern->version.minor;
+	info->mode = kern->mode;
+	info->aperture_base = kern->aper_base;
+	info->aperture_size = kern->aper_size * 1024 * 1024;
+	info->memory_allowed = kern->max_memory << PAGE_SHIFT;
+	info->memory_used = kern->current_memory << PAGE_SHIFT;
+	info->id_vendor = kern->device->vendor;
+	info->id_device = kern->device->device;
+
+	return 0;
+}
+EXPORT_SYMBOL(drm_agp_info);
 
-	if (copy_to_user((drm_agp_info_t __user *)arg, &info, sizeof(info)))
+int drm_agp_info_ioctl(struct inode *inode, struct file *filp,
+		 unsigned int cmd, unsigned long arg)
+{
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
+	drm_agp_info_t info;
+	int err;
+
+	err = drm_agp_info(dev, &info);
+	if (err)
+		return err;
+	
+	if (copy_to_user((drm_agp_info_t __user *) arg, &info, sizeof(info)))
 		return -EFAULT;
 	return 0;
 }
 
 /**
- * Acquire the AGP device (ioctl).
+ * Acquire the AGP device
  *
- * \param inode device inode.
- * \param filp file pointer.
- * \param cmd command.
- * \param arg user argument.
- * \return zero on success or a negative number on failure. 
+ * \param dev DRM device that is to acquire AGP.
+ * \return zero on success or a negative number on failure.
  *
  * Verifies the AGP device hasn't been acquired before and calls
- * agp_acquire().
+ * \c agp_backend_acquire.
  */
-int drm_agp_acquire(struct inode *inode, struct file *filp,
-		     unsigned int cmd, unsigned long arg)
+int drm_agp_acquire(drm_device_t * dev)
 {
-	drm_file_t	 *priv	 = filp->private_data;
-	drm_device_t	 *dev	 = priv->head->dev;
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,11)
+	int retcode;
+#endif
 
 	if (!dev->agp)
 		return -ENODEV;
 	if (dev->agp->acquired)
 		return -EBUSY;
+#ifndef VMAP_4_ARGS
+	if (dev->agp->cant_use_aperture)
+		return -EINVAL;
+#endif
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,11)
+	if ((retcode = agp_backend_acquire()))
+		return retcode;
+#else
 	if (!(dev->agp->bridge = agp_backend_acquire(dev->pdev)))
 		return -ENODEV;
+#endif
+
 	dev->agp->acquired = 1;
 	return 0;
 }
+EXPORT_SYMBOL(drm_agp_acquire);
 
 /**
- * Release the AGP device (ioctl).
+ * Acquire the AGP device (ioctl).
  *
  * \param inode device inode.
  * \param filp file pointer.
@@ -112,63 +132,89 @@ int drm_agp_acquire(struct inode *inode,
  * \param arg user argument.
  * \return zero on success or a negative number on failure.
  *
- * Verifies the AGP device has been acquired and calls agp_backend_release().
+ * Verifies the AGP device hasn't been acquired before and calls
+ * \c agp_backend_acquire.
  */
-int drm_agp_release(struct inode *inode, struct file *filp,
-		     unsigned int cmd, unsigned long arg)
+int drm_agp_acquire_ioctl(struct inode *inode, struct file *filp,
+			  unsigned int cmd, unsigned long arg)
 {
-	drm_file_t	 *priv	 = filp->private_data;
-	drm_device_t	 *dev	 = priv->head->dev;
+	drm_file_t *priv = filp->private_data;
+	
+	return drm_agp_acquire( (drm_device_t *) priv->head->dev );
+}
 
+/**
+ * Release the AGP device
+ *
+ * \param dev DRM device that is to release AGP.
+ * \return zero on success or a negative number on failure.
+ *
+ * Verifies the AGP device has been acquired and calls \c agp_backend_release.
+ */
+int drm_agp_release(drm_device_t *dev)
+{
 	if (!dev->agp || !dev->agp->acquired)
 		return -EINVAL;
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,11)
+	agp_backend_release();
+#else
 	agp_backend_release(dev->agp->bridge);
+#endif
 	dev->agp->acquired = 0;
 	return 0;
 
 }
+EXPORT_SYMBOL(drm_agp_release);
 
-/**
- * Release the AGP device.
- *
- * Calls agp_backend_release().
- */
-void drm_agp_do_release(drm_device_t *dev)
+int drm_agp_release_ioctl(struct inode *inode, struct file *filp,
+			  unsigned int cmd, unsigned long arg)
 {
-  agp_backend_release(dev->agp->bridge);
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
+	
+	return drm_agp_release(dev);
 }
 
 /**
  * Enable the AGP bus.
- * 
- * \param inode device inode.
- * \param filp file pointer.
- * \param cmd command.
- * \param arg pointer to a drm_agp_mode structure.
+ *
+ * \param dev DRM device that has previously acquired AGP.
+ * \param mode Requested AGP mode.
  * \return zero on success or a negative number on failure.
  *
  * Verifies the AGP device has been acquired but not enabled, and calls
- * agp_enable().
+ * \c agp_enable.
  */
-int drm_agp_enable(struct inode *inode, struct file *filp,
-		    unsigned int cmd, unsigned long arg)
+int drm_agp_enable(drm_device_t *dev, drm_agp_mode_t mode)
 {
-	drm_file_t	 *priv	 = filp->private_data;
-	drm_device_t	 *dev	 = priv->head->dev;
-	drm_agp_mode_t   mode;
-
 	if (!dev->agp || !dev->agp->acquired)
 		return -EINVAL;
 
-	if (copy_from_user(&mode, (drm_agp_mode_t __user *)arg, sizeof(mode)))
-		return -EFAULT;
-
-	dev->agp->mode    = mode.mode;
+	dev->agp->mode = mode.mode;
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,11)
+	agp_enable(mode.mode);
+#else
 	agp_enable(dev->agp->bridge, mode.mode);
-	dev->agp->base    = dev->agp->agp_info.aper_base;
+#endif
+	dev->agp->base = dev->agp->agp_info.aper_base;
 	dev->agp->enabled = 1;
 	return 0;
 }
+EXPORT_SYMBOL(drm_agp_enable);
+
+int drm_agp_enable_ioctl(struct inode *inode, struct file *filp,
+		   unsigned int cmd, unsigned long arg)
+{
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
+	drm_agp_mode_t mode;
+
+
+	if (copy_from_user(&mode, (drm_agp_mode_t __user *) arg, sizeof(mode)))
+		return -EFAULT;
+
+	return drm_agp_enable(dev, mode);
+}
 
 /**
  * Allocate AGP memory.
@@ -178,20 +224,20 @@ int drm_agp_enable(struct inode *inode, 
  * \param cmd command.
  * \param arg pointer to a drm_agp_buffer structure.
  * \return zero on success or a negative number on failure.
- * 
+ *
  * Verifies the AGP device is present and has been acquired, allocates the
  * memory via alloc_agp() and creates a drm_agp_mem entry for it.
  */
 int drm_agp_alloc(struct inode *inode, struct file *filp,
-		   unsigned int cmd, unsigned long arg)
+		  unsigned int cmd, unsigned long arg)
 {
-	drm_file_t	 *priv	 = filp->private_data;
-	drm_device_t	 *dev	 = priv->head->dev;
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
 	drm_agp_buffer_t request;
-	drm_agp_mem_t    *entry;
-	DRM_AGP_MEM      *memory;
-	unsigned long    pages;
-	u32 		 type;
+	drm_agp_mem_t *entry;
+	DRM_AGP_MEM *memory;
+	unsigned long pages;
+	u32 type;
 	drm_agp_buffer_t __user *argp = (void __user *)arg;
 
 	if (!dev->agp || !dev->agp->acquired)
@@ -201,31 +247,30 @@ int drm_agp_alloc(struct inode *inode, s
 	if (!(entry = drm_alloc(sizeof(*entry), DRM_MEM_AGPLISTS)))
 		return -ENOMEM;
 
-   	memset(entry, 0, sizeof(*entry));
+	memset(entry, 0, sizeof(*entry));
 
 	pages = (request.size + PAGE_SIZE - 1) / PAGE_SIZE;
 	type = (u32) request.type;
-
-	if (!(memory = drm_alloc_agp(dev->agp->bridge, pages, type))) {
+	if (!(memory = drm_alloc_agp(dev, pages, type))) {
 		drm_free(entry, sizeof(*entry), DRM_MEM_AGPLISTS);
 		return -ENOMEM;
 	}
 
-	entry->handle    = (unsigned long)memory->key + 1;
-	entry->memory    = memory;
-	entry->bound     = 0;
-	entry->pages     = pages;
-	entry->prev      = NULL;
-	entry->next      = dev->agp->memory;
+	entry->handle = (unsigned long)memory->key + 1;
+	entry->memory = memory;
+	entry->bound = 0;
+	entry->pages = pages;
+	entry->prev = NULL;
+	entry->next = dev->agp->memory;
 	if (dev->agp->memory)
 		dev->agp->memory->prev = entry;
 	dev->agp->memory = entry;
 
-	request.handle   = entry->handle;
+	request.handle = entry->handle;
 	request.physical = memory->physical;
 
 	if (copy_to_user(argp, &request, sizeof(request))) {
-		dev->agp->memory       = entry->next;
+		dev->agp->memory = entry->next;
 		dev->agp->memory->prev = NULL;
 		drm_free_agp(memory, pages);
 		drm_free(entry, sizeof(*entry), DRM_MEM_AGPLISTS);
@@ -240,11 +285,11 @@ int drm_agp_alloc(struct inode *inode, s
  * \param dev DRM device structure.
  * \param handle AGP memory handle.
  * \return pointer to the drm_agp_mem structure associated with \p handle.
- * 
+ *
  * Walks through drm_agp_head::memory until finding a matching handle.
  */
-static drm_agp_mem_t *drm_agp_lookup_entry(drm_device_t *dev,
-					    unsigned long handle)
+static drm_agp_mem_t *drm_agp_lookup_entry(drm_device_t * dev,
+					   unsigned long handle)
 {
 	drm_agp_mem_t *entry;
 
@@ -268,17 +313,18 @@ static drm_agp_mem_t *drm_agp_lookup_ent
  * entry and passes it to the unbind_agp() function.
  */
 int drm_agp_unbind(struct inode *inode, struct file *filp,
-		    unsigned int cmd, unsigned long arg)
+		   unsigned int cmd, unsigned long arg)
 {
-	drm_file_t	  *priv	 = filp->private_data;
-	drm_device_t	  *dev	 = priv->head->dev;
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
 	drm_agp_binding_t request;
-	drm_agp_mem_t     *entry;
+	drm_agp_mem_t *entry;
 	int ret;
 
 	if (!dev->agp || !dev->agp->acquired)
 		return -EINVAL;
-	if (copy_from_user(&request, (drm_agp_binding_t __user *)arg, sizeof(request)))
+	if (copy_from_user
+	    (&request, (drm_agp_binding_t __user *) arg, sizeof(request)))
 		return -EFAULT;
 	if (!(entry = drm_agp_lookup_entry(dev, request.handle)))
 		return -EINVAL;
@@ -286,7 +332,7 @@ int drm_agp_unbind(struct inode *inode, 
 		return -EINVAL;
 	ret = drm_unbind_agp(entry->memory);
 	if (ret == 0)
-	    entry->bound = 0;
+		entry->bound = 0;
 	return ret;
 }
 
@@ -304,18 +350,19 @@ int drm_agp_unbind(struct inode *inode, 
  * it to bind_agp() function.
  */
 int drm_agp_bind(struct inode *inode, struct file *filp,
-		  unsigned int cmd, unsigned long arg)
+		 unsigned int cmd, unsigned long arg)
 {
-	drm_file_t	  *priv	 = filp->private_data;
-	drm_device_t	  *dev	 = priv->head->dev;
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
 	drm_agp_binding_t request;
-	drm_agp_mem_t     *entry;
-	int               retcode;
-	int               page;
+	drm_agp_mem_t *entry;
+	int retcode;
+	int page;
 
 	if (!dev->agp || !dev->agp->acquired)
 		return -EINVAL;
-	if (copy_from_user(&request, (drm_agp_binding_t __user *)arg, sizeof(request)))
+	if (copy_from_user
+	    (&request, (drm_agp_binding_t __user *) arg, sizeof(request)))
 		return -EFAULT;
 	if (!(entry = drm_agp_lookup_entry(dev, request.handle)))
 		return -EINVAL;
@@ -345,16 +392,17 @@ int drm_agp_bind(struct inode *inode, st
  * and unlinks from the doubly linked list it's inserted in.
  */
 int drm_agp_free(struct inode *inode, struct file *filp,
-		  unsigned int cmd, unsigned long arg)
+		 unsigned int cmd, unsigned long arg)
 {
-	drm_file_t	 *priv	 = filp->private_data;
-	drm_device_t	 *dev	 = priv->head->dev;
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
 	drm_agp_buffer_t request;
-	drm_agp_mem_t    *entry;
+	drm_agp_mem_t *entry;
 
 	if (!dev->agp || !dev->agp->acquired)
 		return -EINVAL;
-	if (copy_from_user(&request, (drm_agp_buffer_t __user *)arg, sizeof(request)))
+	if (copy_from_user
+	    (&request, (drm_agp_buffer_t __user *) arg, sizeof(request)))
 		return -EFAULT;
 	if (!(entry = drm_agp_lookup_entry(dev, request.handle)))
 		return -EINVAL;
@@ -379,49 +427,58 @@ int drm_agp_free(struct inode *inode, st
  *
  * \return pointer to a drm_agp_head structure.
  *
+ * Gets the drm_agp_t structure which is made available by the agpgart module
+ * via the inter_module_* functions. Creates and initializes a drm_agp_head
+ * structure.
  */
 drm_agp_head_t *drm_agp_init(drm_device_t *dev)
 {
-	drm_agp_head_t *head         = NULL;
+	drm_agp_head_t *head = NULL;
 
 	if (!(head = drm_alloc(sizeof(*head), DRM_MEM_AGPLISTS)))
 		return NULL;
 	memset((void *)head, 0, sizeof(*head));
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,11)
+	agp_copy_info(&head->agp_info);
+#else
 	head->bridge = agp_find_bridge(dev->pdev);
 	if (!head->bridge) {
 		if (!(head->bridge = agp_backend_acquire(dev->pdev))) {
 			drm_free(head, sizeof(*head), DRM_MEM_AGPLISTS);
 			return NULL;
-		}
+	}
 		agp_copy_info(head->bridge, &head->agp_info);
 		agp_backend_release(head->bridge);
 	} else {
 		agp_copy_info(head->bridge, &head->agp_info);
 	}
+#endif
 	if (head->agp_info.chipset == NOT_SUPPORTED) {
 		drm_free(head, sizeof(*head), DRM_MEM_AGPLISTS);
 		return NULL;
 	}
 	head->memory = NULL;
-#if LINUX_VERSION_CODE <= 0x020408
-	head->cant_use_aperture = 0;
-	head->page_mask = ~(0xfff);
-#else
 	head->cant_use_aperture = head->agp_info.cant_use_aperture;
 	head->page_mask = head->agp_info.page_mask;
-#endif
-
 	return head;
 }
 
 /** Calls agp_allocate_memory() */
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,11)
+DRM_AGP_MEM *drm_agp_allocate_memory(size_t pages, u32 type)
+{
+	return agp_allocate_memory(pages, type);
+}
+#else
 DRM_AGP_MEM *drm_agp_allocate_memory(struct agp_bridge_data *bridge, size_t pages, u32 type)
 {
 	return agp_allocate_memory(bridge, pages, type);
 }
+#endif
 
 /** Calls agp_free_memory() */
-int drm_agp_free_memory(DRM_AGP_MEM *handle)
+int drm_agp_free_memory(DRM_AGP_MEM * handle)
 {
 	if (!handle)
 		return 0;
@@ -430,19 +487,20 @@ int drm_agp_free_memory(DRM_AGP_MEM *han
 }
 
 /** Calls agp_bind_memory() */
-int drm_agp_bind_memory(DRM_AGP_MEM *handle, off_t start)
+int drm_agp_bind_memory(DRM_AGP_MEM * handle, off_t start)
 {
 	if (!handle)
 		return -EINVAL;
 	return agp_bind_memory(handle, start);
 }
+EXPORT_SYMBOL(drm_agp_bind_memory);
 
 /** Calls agp_unbind_memory() */
-int drm_agp_unbind_memory(DRM_AGP_MEM *handle)
+int drm_agp_unbind_memory(DRM_AGP_MEM * handle)
 {
 	if (!handle)
 		return -EINVAL;
 	return agp_unbind_memory(handle);
 }
 
-#endif /* __OS_HAS_AGP */
+#endif				/* __OS_HAS_AGP */
diff -purN linux-2.6.12.orig/drivers/char/drm/drm_auth.c linux-2.6.12/drivers/char/drm/drm_auth.c
--- linux-2.6.12.orig/drivers/char/drm/drm_auth.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/drm_auth.c	2005-07-05 08:37:27.000000000 +0200
@@ -1,5 +1,5 @@
 /**
- * \file drm_auth.h 
+ * \file drm_auth.c
  * IOCTLs for authentication
  *
  * \author Rickard E. (Rik) Faith <faith@valinux.com>
@@ -46,7 +46,7 @@
  */
 static int drm_hash_magic(drm_magic_t magic)
 {
-	return magic & (DRM_HASH_SIZE-1);
+	return magic & (DRM_HASH_SIZE - 1);
 }
 
 /**
@@ -59,11 +59,11 @@ static int drm_hash_magic(drm_magic_t ma
  * the one with matching magic number, while holding the drm_device::struct_sem
  * lock.
  */
-static drm_file_t *drm_find_file(drm_device_t *dev, drm_magic_t magic)
+static drm_file_t *drm_find_file(drm_device_t * dev, drm_magic_t magic)
 {
-	drm_file_t	  *retval = NULL;
+	drm_file_t *retval = NULL;
 	drm_magic_entry_t *pt;
-	int		  hash	  = drm_hash_magic(magic);
+	int hash = drm_hash_magic(magic);
 
 	down(&dev->struct_sem);
 	for (pt = dev->magiclist[hash].head; pt; pt = pt->next) {
@@ -78,7 +78,7 @@ static drm_file_t *drm_find_file(drm_dev
 
 /**
  * Adds a magic number.
- * 
+ *
  * \param dev DRM device.
  * \param priv file private data.
  * \param magic magic number.
@@ -87,28 +87,29 @@ static drm_file_t *drm_find_file(drm_dev
  * associated the magic number hash key in drm_device::magiclist, while holding
  * the drm_device::struct_sem lock.
  */
-int drm_add_magic(drm_device_t *dev, drm_file_t *priv, drm_magic_t magic)
+static int drm_add_magic(drm_device_t * dev, drm_file_t * priv, drm_magic_t magic)
 {
-	int		  hash;
+	int hash;
 	drm_magic_entry_t *entry;
 
 	DRM_DEBUG("%d\n", magic);
 
-	hash	     = drm_hash_magic(magic);
-	entry	     = drm_alloc(sizeof(*entry), DRM_MEM_MAGIC);
-	if (!entry) return -ENOMEM;
+	hash = drm_hash_magic(magic);
+	entry = drm_alloc(sizeof(*entry), DRM_MEM_MAGIC);
+	if (!entry)
+		return -ENOMEM;
 	memset(entry, 0, sizeof(*entry));
 	entry->magic = magic;
-	entry->priv  = priv;
-	entry->next  = NULL;
+	entry->priv = priv;
+	entry->next = NULL;
 
 	down(&dev->struct_sem);
 	if (dev->magiclist[hash].tail) {
 		dev->magiclist[hash].tail->next = entry;
-		dev->magiclist[hash].tail	= entry;
+		dev->magiclist[hash].tail = entry;
 	} else {
-		dev->magiclist[hash].head	= entry;
-		dev->magiclist[hash].tail	= entry;
+		dev->magiclist[hash].head = entry;
+		dev->magiclist[hash].tail = entry;
 	}
 	up(&dev->struct_sem);
 
@@ -117,19 +118,18 @@ int drm_add_magic(drm_device_t *dev, drm
 
 /**
  * Remove a magic number.
- * 
+ *
  * \param dev DRM device.
  * \param magic magic number.
  *
  * Searches and unlinks the entry in drm_device::magiclist with the magic
  * number hash key, while holding the drm_device::struct_sem lock.
  */
-int drm_remove_magic(drm_device_t *dev, drm_magic_t magic)
+static int drm_remove_magic(drm_device_t * dev, drm_magic_t magic)
 {
 	drm_magic_entry_t *prev = NULL;
 	drm_magic_entry_t *pt;
-	int		  hash;
-
+	int hash;
 
 	DRM_DEBUG("%d\n", magic);
 	hash = drm_hash_magic(magic);
@@ -171,21 +171,22 @@ int drm_remove_magic(drm_device_t *dev, 
  * filp.
  */
 int drm_getmagic(struct inode *inode, struct file *filp,
-		  unsigned int cmd, unsigned long arg)
+		 unsigned int cmd, unsigned long arg)
 {
 	static drm_magic_t sequence = 0;
-	static DEFINE_SPINLOCK(lock);
-	drm_file_t	   *priv    = filp->private_data;
-	drm_device_t	   *dev	    = priv->head->dev;
-	drm_auth_t	   auth;
+	static spinlock_t lock = SPIN_LOCK_UNLOCKED;
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
+	drm_auth_t auth;
 
-				/* Find unique magic */
+	/* Find unique magic */
 	if (priv->magic) {
 		auth.magic = priv->magic;
 	} else {
 		do {
 			spin_lock(&lock);
-			if (!sequence) ++sequence; /* reserve 0 */
+			if (!sequence)
+				++sequence;	/* reserve 0 */
 			auth.magic = sequence++;
 			spin_unlock(&lock);
 		} while (drm_find_file(dev, auth.magic));
@@ -194,7 +195,7 @@ int drm_getmagic(struct inode *inode, st
 	}
 
 	DRM_DEBUG("%u\n", auth.magic);
-	if (copy_to_user((drm_auth_t __user *)arg, &auth, sizeof(auth)))
+	if (copy_to_user((drm_auth_t __user *) arg, &auth, sizeof(auth)))
 		return -EFAULT;
 	return 0;
 }
@@ -211,14 +212,14 @@ int drm_getmagic(struct inode *inode, st
  * Checks if \p filp is associated with the magic number passed in \arg.
  */
 int drm_authmagic(struct inode *inode, struct file *filp,
-		   unsigned int cmd, unsigned long arg)
+		  unsigned int cmd, unsigned long arg)
 {
-	drm_file_t	   *priv    = filp->private_data;
-	drm_device_t	   *dev	    = priv->head->dev;
-	drm_auth_t	   auth;
-	drm_file_t	   *file;
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
+	drm_auth_t auth;
+	drm_file_t *file;
 
-	if (copy_from_user(&auth, (drm_auth_t __user *)arg, sizeof(auth)))
+	if (copy_from_user(&auth, (drm_auth_t __user *) arg, sizeof(auth)))
 		return -EFAULT;
 	DRM_DEBUG("%u\n", auth.magic);
 	if ((file = drm_find_file(dev, auth.magic))) {
diff -purN linux-2.6.12.orig/drivers/char/drm/drm_bufs.c linux-2.6.12/drivers/char/drm/drm_bufs.c
--- linux-2.6.12.orig/drivers/char/drm/drm_bufs.c	2005-07-05 08:36:22.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/drm_bufs.c	2005-07-05 08:37:27.000000000 +0200
@@ -1,7 +1,7 @@
 /**
- * \file drm_bufs.h 
+ * \file drm_bufs.c
  * Generic buffer template
- * 
+ *
  * \author Rickard E. (Rik) Faith <faith@valinux.com>
  * \author Gareth Hughes <gareth@valinux.com>
  */
@@ -36,29 +36,33 @@
 #include <linux/vmalloc.h>
 #include "drmP.h"
 
-/**
- * Compute size order.  Returns the exponent of the smaller power of two which
- * is greater or equal to given number.
- * 
- * \param size size.
- * \return order.
- *
- * \todo Can be made faster.
- */
-int drm_order( unsigned long size )
+unsigned long drm_get_resource_start(drm_device_t *dev, unsigned int resource)
 {
-	int order;
-	unsigned long tmp;
+	return pci_resource_start(dev->pdev, resource);
+}
+EXPORT_SYMBOL(drm_get_resource_start);
 
-	for (order = 0, tmp = size >> 1; tmp; tmp >>= 1, order++)
-		;
+unsigned long drm_get_resource_len(drm_device_t *dev, unsigned int resource)
+{
+	return pci_resource_len(dev->pdev, resource);
+}
+EXPORT_SYMBOL(drm_get_resource_len);
 
-	if (size & (size - 1))
-		++order;
+static drm_local_map_t *drm_find_matching_map(drm_device_t *dev,
+					      drm_local_map_t *map)
+{
+	struct list_head *list;
 
-	return order;
+	list_for_each(list, &dev->maplist->head) {
+		drm_map_list_t *entry = list_entry(list, drm_map_list_t, head);
+		if (entry->map && map->type == entry->map->type &&
+		    entry->map->offset == map->offset) {
+			return entry->map;
+		}
+	}
+
+	return NULL;
 }
-EXPORT_SYMBOL(drm_order);
 
 #ifdef CONFIG_COMPAT
 /*
@@ -82,86 +86,99 @@ static unsigned int map32_handle = 0x100
  * type.  Adds the map to the map list drm_device::maplist. Adds MTRR's where
  * applicable and if supported by the kernel.
  */
-int drm_addmap( struct inode *inode, struct file *filp,
-		 unsigned int cmd, unsigned long arg )
+int drm_addmap(drm_device_t * dev, unsigned int offset,
+	       unsigned int size, drm_map_type_t type,
+	       drm_map_flags_t flags, drm_local_map_t ** map_ptr)
 {
-	drm_file_t *priv = filp->private_data;
-	drm_device_t *dev = priv->head->dev;
 	drm_map_t *map;
-	drm_map_t __user *argp = (void __user *)arg;
 	drm_map_list_t *list;
+	drm_dma_handle_t *dmah;
+	drm_local_map_t *found_map;
 
-	if ( !(filp->f_mode & 3) ) return -EACCES; /* Require read/write */
-
-	map = drm_alloc( sizeof(*map), DRM_MEM_MAPS );
-	if ( !map )
+	map = drm_alloc(sizeof(*map), DRM_MEM_MAPS);
+	if (!map)
 		return -ENOMEM;
 
-	if ( copy_from_user( map, argp, sizeof(*map) ) ) {
-		drm_free( map, sizeof(*map), DRM_MEM_MAPS );
-		return -EFAULT;
-	}
+	map->offset = offset;
+	map->size = size;
+	map->flags = flags;
+	map->type = type;
 
 	/* Only allow shared memory to be removable since we only keep enough
 	 * book keeping information about shared memory to allow for removal
 	 * when processes fork.
 	 */
-	if ( (map->flags & _DRM_REMOVABLE) && map->type != _DRM_SHM ) {
-		drm_free( map, sizeof(*map), DRM_MEM_MAPS );
+	if ((map->flags & _DRM_REMOVABLE) && map->type != _DRM_SHM) {
+		drm_free(map, sizeof(*map), DRM_MEM_MAPS);
 		return -EINVAL;
 	}
-	DRM_DEBUG( "offset = 0x%08lx, size = 0x%08lx, type = %d\n",
-		   map->offset, map->size, map->type );
-	if ( (map->offset & (~PAGE_MASK)) || (map->size & (~PAGE_MASK)) ) {
-		drm_free( map, sizeof(*map), DRM_MEM_MAPS );
+	DRM_DEBUG("offset = 0x%08lx, size = 0x%08lx, type = %d\n",
+		  map->offset, map->size, map->type);
+	if ((map->offset & (~PAGE_MASK)) || (map->size & (~PAGE_MASK))) {
+		drm_free(map, sizeof(*map), DRM_MEM_MAPS);
 		return -EINVAL;
 	}
-	map->mtrr   = -1;
+	map->mtrr = -1;
 	map->handle = NULL;
 
-	switch ( map->type ) {
+	switch (map->type) {
 	case _DRM_REGISTERS:
 	case _DRM_FRAME_BUFFER:
 #if !defined(__sparc__) && !defined(__alpha__) && !defined(__ia64__)
-		if ( map->offset + map->size < map->offset ||
-		     map->offset < virt_to_phys(high_memory) ) {
-			drm_free( map, sizeof(*map), DRM_MEM_MAPS );
+		if (map->offset + map->size < map->offset ||
+		    map->offset < virt_to_phys(high_memory)) {
+			drm_free(map, sizeof(*map), DRM_MEM_MAPS);
 			return -EINVAL;
 		}
 #endif
 #ifdef __alpha__
 		map->offset += dev->hose->mem_space->start;
 #endif
+		/* Some drivers preinitialize some maps, without the X Server
+		 * needing to be aware of it.  Therefore, we just return success
+		 * when the server tries to create a duplicate map.
+		 */
+		found_map = drm_find_matching_map(dev, map);
+		if (found_map != NULL) {
+			if (found_map->size != map->size) {
+				DRM_DEBUG("Matching maps of type %d with "
+				   "mismatched sizes, (%ld vs %ld)\n",
+				    map->type, map->size, found_map->size);
+				found_map->size = map->size;
+			}
+
+			drm_free(map, sizeof(*map), DRM_MEM_MAPS);
+			*map_ptr = found_map;
+			return 0;
+		}
+
 		if (drm_core_has_MTRR(dev)) {
-			if ( map->type == _DRM_FRAME_BUFFER ||
-			     (map->flags & _DRM_WRITE_COMBINING) ) {
-				map->mtrr = mtrr_add( map->offset, map->size,
-						      MTRR_TYPE_WRCOMB, 1 );
+			if (map->type == _DRM_FRAME_BUFFER ||
+			    (map->flags & _DRM_WRITE_COMBINING)) {
+				map->mtrr =  mtrr_add(map->offset, map->size,
+						      MTRR_TYPE_WRCOMB, 1);
 			}
 		}
 		if (map->type == _DRM_REGISTERS)
-			map->handle = drm_ioremap( map->offset, map->size,
-						    dev );
+			map->handle = drm_ioremap(map->offset, map->size, dev);
 		break;
-
 	case _DRM_SHM:
 		map->handle = vmalloc_32(map->size);
-		DRM_DEBUG( "%lu %d %p\n",
-			   map->size, drm_order( map->size ), map->handle );
-		if ( !map->handle ) {
-			drm_free( map, sizeof(*map), DRM_MEM_MAPS );
+		DRM_DEBUG("%lu %d %p\n",
+			  map->size, drm_order(map->size), map->handle);
+		if (!map->handle) {
+			drm_free(map, sizeof(*map), DRM_MEM_MAPS);
 			return -ENOMEM;
 		}
 		map->offset = (unsigned long)map->handle;
-		if ( map->flags & _DRM_CONTAINS_LOCK ) {
+		if (map->flags & _DRM_CONTAINS_LOCK) {
 			/* Prevent a 2nd X Server from creating a 2nd lock */
 			if (dev->lock.hw_lock != NULL) {
-				vfree( map->handle );
-				drm_free( map, sizeof(*map), DRM_MEM_MAPS );
+				vfree(map->handle);
+				drm_free(map, sizeof(*map), DRM_MEM_MAPS);
 				return -EBUSY;
 			}
-			dev->sigdata.lock =
-			dev->lock.hw_lock = map->handle; /* Pointer to lock */
+			dev->sigdata.lock = dev->lock.hw_lock = map->handle;	/* Pointer to lock */
 		}
 		break;
 	case _DRM_AGP:
@@ -170,7 +187,7 @@ int drm_addmap( struct inode *inode, str
 			map->offset += dev->hose->mem_space->start;
 #endif
 			map->offset += dev->agp->base;
-			map->mtrr   = dev->agp->agp_mtrr; /* for getmap */
+			map->mtrr = dev->agp->agp_mtrr;	/* for getmap */
 		}
 		break;
 	case _DRM_SCATTER_GATHER:
@@ -180,14 +197,28 @@ int drm_addmap( struct inode *inode, str
 		}
 		map->offset += dev->sg->handle;
 		break;
-
+	case _DRM_CONSISTENT: {
+		/* dma_addr_t is 64bit on i386 with CONFIG_HIGHMEM64G.
+		 * As we're limiting the address to 2^32-1 (or less),
+		 * casting it down to 32 bits is no problem, but we
+		 * need to point to a 64bit variable first. */
+		dmah = drm_pci_alloc(dev, map->size, map->size, 0xffffffffUL);
+		if (!dmah) {
+			drm_free(map, sizeof(*map), DRM_MEM_MAPS);
+			return -ENOMEM;
+		}
+		map->handle = dmah->vaddr;
+		map->offset = (unsigned long)dmah->busaddr;
+		kfree(dmah);
+		break;
+	}
 	default:
-		drm_free( map, sizeof(*map), DRM_MEM_MAPS );
+		drm_free(map, sizeof(*map), DRM_MEM_MAPS);
 		return -EINVAL;
 	}
 
 	list = drm_alloc(sizeof(*list), DRM_MEM_MAPS);
-	if(!list) {
+	if (!list) {
 		drm_free(map, sizeof(*map), DRM_MEM_MAPS);
 		return -EINVAL;
 	}
@@ -202,16 +233,48 @@ int drm_addmap( struct inode *inode, str
 	if (map->type == _DRM_SHM)
 		map->offset = map32_handle += PAGE_SIZE;
 #endif
- 	up(&dev->struct_sem);
 
-	if ( copy_to_user( argp, map, sizeof(*map) ) )
+	up(&dev->struct_sem);
+
+	*map_ptr = map;
+	return 0;
+}
+EXPORT_SYMBOL(drm_addmap);
+
+int drm_addmap_ioctl(struct inode *inode, struct file *filp,
+		     unsigned int cmd, unsigned long arg)
+{
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
+	drm_map_t map;
+	drm_map_t *map_ptr;
+	drm_map_t __user *argp = (void __user *)arg;
+	int err;
+
+	if (!(filp->f_mode & 3))
+		return -EACCES;	/* Require read/write */
+
+	if (copy_from_user(& map, argp, sizeof(map))) {
 		return -EFAULT;
-	if (copy_to_user(&argp->handle, &map->offset, sizeof(map->offset)))
+	}
+
+	err = drm_addmap( dev, map.offset, map.size, map.type, map.flags,
+			  & map_ptr );
+
+	if (err) {
+		return err;
+	}
+
+	if (copy_to_user(argp, map_ptr, sizeof(*map_ptr)))
 		return -EFAULT;
+	if (map_ptr->type != _DRM_SHM) {
+		if (copy_to_user(&argp->handle,
+				 &map_ptr->offset, sizeof(map_ptr->offset)))
+			return -EFAULT;
+	}
 	return 0;
 }
 
-
 /**
  * Remove a map private from list and deallocate resources if the mapping
  * isn't in use.
@@ -226,86 +289,143 @@ int drm_addmap( struct inode *inode, str
  * its being used, and free any associate resource (such as MTRR's) if it's not
  * being on use.
  *
- * \sa addmap().
+ * \sa drm_addmap
  */
-int drm_rmmap(struct inode *inode, struct file *filp,
-	       unsigned int cmd, unsigned long arg)
+int drm_rmmap_locked(drm_device_t *dev, drm_local_map_t *map)
 {
-	drm_file_t	*priv	= filp->private_data;
-	drm_device_t	*dev	= priv->head->dev;
 	struct list_head *list;
 	drm_map_list_t *r_list = NULL;
-	drm_vma_entry_t *pt, *prev;
-	drm_map_t *map;
+	drm_dma_handle_t dmah;
+
+	/* Find the list entry for the map and remove it */
+	list_for_each(list, &dev->maplist->head) {
+		r_list = list_entry(list, drm_map_list_t, head);
+
+		if (r_list->map == map) {
+			list_del(list);
+			drm_free(list, sizeof(*list), DRM_MEM_MAPS);
+			break;
+		}
+	}
+
+	/* List has wrapped around to the head pointer, or it's empty and we
+	 * didn't find anything.
+	 */
+	if (list == (&dev->maplist->head)) {
+		return -EINVAL;
+	}
+
+	switch (map->type) {
+	case _DRM_REGISTERS:
+		drm_ioremapfree(map->handle, map->size, dev);
+		/* FALLTHROUGH */
+	case _DRM_FRAME_BUFFER:
+		if (drm_core_has_MTRR(dev) && map->mtrr >= 0) {
+			int retcode;
+			retcode = mtrr_del(map->mtrr, map->offset,
+					   map->size);
+			DRM_DEBUG ("mtrr_del=%d\n", retcode);
+		}
+		break;
+	case _DRM_SHM:
+		vfree(map->handle);
+		break;
+	case _DRM_AGP:
+	case _DRM_SCATTER_GATHER:
+		break;
+	case _DRM_CONSISTENT:
+		dmah.vaddr = map->handle;
+		dmah.busaddr = map->offset;
+		dmah.size = map->size;
+		__drm_pci_free(dev, &dmah);
+		break;
+	}
+	drm_free(map, sizeof(*map), DRM_MEM_MAPS);
+
+	return 0;
+}
+EXPORT_SYMBOL(drm_rmmap_locked);
+
+int drm_rmmap(drm_device_t *dev, drm_local_map_t *map)
+{
+	int ret;
+
+	down(&dev->struct_sem);
+	ret = drm_rmmap_locked(dev, map);
+	up(&dev->struct_sem);
+
+	return ret;
+}
+EXPORT_SYMBOL(drm_rmmap);
+
+/* The rmmap ioctl appears to be unnecessary.  All mappings are torn down on
+ * the last close of the device, and this is necessary for cleanup when things
+ * exit uncleanly.  Therefore, having userland manually remove mappings seems
+ * like a pointless exercise since they're going away anyway.
+ *
+ * One use case might be after addmap is allowed for normal users for SHM and
+ * gets used by drivers that the server doesn't need to care about.  This seems
+ * unlikely.
+ */
+int drm_rmmap_ioctl(struct inode *inode, struct file *filp,
+		    unsigned int cmd, unsigned long arg)
+{
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
 	drm_map_t request;
-	int found_maps = 0;
+	drm_local_map_t *map = NULL;
+	struct list_head *list;
+	int ret;
 
-	if (copy_from_user(&request, (drm_map_t __user *)arg,
-			   sizeof(request))) {
+	if (copy_from_user(&request, (drm_map_t __user *) arg, sizeof(request))) {
 		return -EFAULT;
 	}
 
 	down(&dev->struct_sem);
-	list = &dev->maplist->head;
 	list_for_each(list, &dev->maplist->head) {
-		r_list = list_entry(list, drm_map_list_t, head);
+		drm_map_list_t *r_list = list_entry(list, drm_map_list_t, head);
 
-		if(r_list->map &&
-		   r_list->map->offset == (unsigned long) request.handle &&
-		   r_list->map->flags & _DRM_REMOVABLE) break;
+		if (r_list->map &&
+		    r_list->map->handle == request.handle &&
+		    r_list->map->flags & _DRM_REMOVABLE) {
+			map = r_list->map;
+			break;
+		}
 	}
 
 	/* List has wrapped around to the head pointer, or its empty we didn't
 	 * find anything.
 	 */
-	if(list == (&dev->maplist->head)) {
+	if (list == (&dev->maplist->head)) {
 		up(&dev->struct_sem);
 		return -EINVAL;
 	}
-	map = r_list->map;
-	list_del(list);
-	drm_free(list, sizeof(*list), DRM_MEM_MAPS);
-
-	for (pt = dev->vmalist, prev = NULL; pt; prev = pt, pt = pt->next) {
-		if (pt->vma->vm_private_data == map) found_maps++;
-	}
-
-	if(!found_maps) {
-		switch (map->type) {
-		case _DRM_REGISTERS:
-		case _DRM_FRAME_BUFFER:
-		  if (drm_core_has_MTRR(dev)) {
-				if (map->mtrr >= 0) {
-					int retcode;
-					retcode = mtrr_del(map->mtrr,
-							   map->offset,
-							   map->size);
-					DRM_DEBUG("mtrr_del = %d\n", retcode);
-				}
-			}
-			drm_ioremapfree(map->handle, map->size, dev);
-			break;
-		case _DRM_SHM:
-			vfree(map->handle);
-			break;
-		case _DRM_AGP:
-		case _DRM_SCATTER_GATHER:
-			break;
-		}
-		drm_free(map, sizeof(*map), DRM_MEM_MAPS);
+
+	if (!map)
+		return -EINVAL;
+
+	/* Register and framebuffer maps are permanent */
+	if ((map->type == _DRM_REGISTERS) || (map->type == _DRM_FRAME_BUFFER)) {
+		up(&dev->struct_sem);
+		return 0;
 	}
+
+	ret = drm_rmmap_locked(dev, map);
+
 	up(&dev->struct_sem);
-	return 0;
+
+	return ret;
 }
 
 /**
  * Cleanup after an error on one of the addbufs() functions.
  *
+ * \param dev DRM device.
  * \param entry buffer entry where the error occurred.
  *
  * Frees any pages and buffers associated with the given entry.
  */
-static void drm_cleanup_buf_error(drm_device_t *dev, drm_buf_entry_t *entry)
+static void drm_cleanup_buf_error(drm_device_t * dev, drm_buf_entry_t * entry)
 {
 	int i;
 
@@ -313,30 +433,27 @@ static void drm_cleanup_buf_error(drm_de
 		for (i = 0; i < entry->seg_count; i++) {
 			if (entry->seglist[i]) {
 				drm_free_pages(entry->seglist[i],
-					        entry->page_order,
-					        DRM_MEM_DMA);
+					       entry->page_order, DRM_MEM_DMA);
 			}
 		}
 		drm_free(entry->seglist,
-			  entry->seg_count *
-			  sizeof(*entry->seglist),
-			  DRM_MEM_SEGS);
+			 entry->seg_count *
+			 sizeof(*entry->seglist), DRM_MEM_SEGS);
 
 		entry->seg_count = 0;
 	}
 
-   	if (entry->buf_count) {
-	   	for (i = 0; i < entry->buf_count; i++) {
+	if (entry->buf_count) {
+		for (i = 0; i < entry->buf_count; i++) {
 			if (entry->buflist[i].dev_private) {
 				drm_free(entry->buflist[i].dev_private,
-					  entry->buflist[i].dev_priv_size,
-					  DRM_MEM_BUFS);
+					 entry->buflist[i].dev_priv_size,
+					 DRM_MEM_BUFS);
 			}
 		}
 		drm_free(entry->buflist,
-			  entry->buf_count *
-			  sizeof(*entry->buflist),
-			  DRM_MEM_BUFS);
+			 entry->buf_count *
+			 sizeof(*entry->buflist), DRM_MEM_BUFS);
 
 		entry->buf_count = 0;
 	}
@@ -344,25 +461,19 @@ static void drm_cleanup_buf_error(drm_de
 
 #if __OS_HAS_AGP
 /**
- * Add AGP buffers for DMA transfers (ioctl).
+ * Add AGP buffers for DMA transfers
  *
- * \param inode device inode.
- * \param filp file pointer.
- * \param cmd command.
- * \param arg pointer to a drm_buf_desc_t request.
+ * \param dev drm_device_t to which the buffers are to be added.
+ * \param request pointer to a drm_buf_desc_t describing the request.
  * \return zero on success or a negative number on failure.
- * 
+ *
  * After some sanity checks creates a drm_buf structure for each buffer and
  * reallocates the buffer list of the same size order to accommodate the new
  * buffers.
  */
-int drm_addbufs_agp( struct inode *inode, struct file *filp,
-		      unsigned int cmd, unsigned long arg )
+int drm_addbufs_agp(drm_device_t * dev, drm_buf_desc_t * request)
 {
-	drm_file_t *priv = filp->private_data;
-	drm_device_t *dev = priv->head->dev;
 	drm_device_dma_t *dma = dev->dma;
-	drm_buf_desc_t request;
 	drm_buf_entry_t *entry;
 	drm_buf_t *buf;
 	unsigned long offset;
@@ -376,158 +487,148 @@ int drm_addbufs_agp( struct inode *inode
 	int byte_count;
 	int i;
 	drm_buf_t **temp_buflist;
-	drm_buf_desc_t __user *argp = (void __user *)arg;
 
-	if ( !dma ) return -EINVAL;
 
-	if ( copy_from_user( &request, argp,
-			     sizeof(request) ) )
-		return -EFAULT;
+	if (!dma)
+		return -EINVAL;
 
-	count = request.count;
-	order = drm_order( request.size );
+	count = request->count;
+	order = drm_order(request->size);
 	size = 1 << order;
 
-	alignment  = (request.flags & _DRM_PAGE_ALIGN)
-		? PAGE_ALIGN(size) : size;
+	alignment = (request->flags & _DRM_PAGE_ALIGN)
+	    ? PAGE_ALIGN(size) : size;
 	page_order = order - PAGE_SHIFT > 0 ? order - PAGE_SHIFT : 0;
 	total = PAGE_SIZE << page_order;
 
 	byte_count = 0;
-	agp_offset = dev->agp->base + request.agp_start;
+	agp_offset = dev->agp->base + request->agp_start;
+
+	DRM_DEBUG("count:      %d\n", count);
+	DRM_DEBUG("order:      %d\n", order);
+	DRM_DEBUG("size:       %d\n", size);
+	DRM_DEBUG("agp_offset: %lu\n", agp_offset);
+	DRM_DEBUG("alignment:  %d\n", alignment);
+	DRM_DEBUG("page_order: %d\n", page_order);
+	DRM_DEBUG("total:      %d\n", total);
+
+	if (order < DRM_MIN_ORDER || order > DRM_MAX_ORDER)
+		return -EINVAL;
+	if (dev->queue_count)
+		return -EBUSY;	/* Not while in use */
 
-	DRM_DEBUG( "count:      %d\n",  count );
-	DRM_DEBUG( "order:      %d\n",  order );
-	DRM_DEBUG( "size:       %d\n",  size );
-	DRM_DEBUG( "agp_offset: %lu\n", agp_offset );
-	DRM_DEBUG( "alignment:  %d\n",  alignment );
-	DRM_DEBUG( "page_order: %d\n",  page_order );
-	DRM_DEBUG( "total:      %d\n",  total );
-
-	if ( order < DRM_MIN_ORDER || order > DRM_MAX_ORDER ) return -EINVAL;
-	if ( dev->queue_count ) return -EBUSY; /* Not while in use */
-
-	spin_lock( &dev->count_lock );
-	if ( dev->buf_use ) {
-		spin_unlock( &dev->count_lock );
+	spin_lock(&dev->count_lock);
+	if (dev->buf_use) {
+		spin_unlock(&dev->count_lock);
 		return -EBUSY;
 	}
-	atomic_inc( &dev->buf_alloc );
-	spin_unlock( &dev->count_lock );
+	atomic_inc(&dev->buf_alloc);
+	spin_unlock(&dev->count_lock);
 
-	down( &dev->struct_sem );
+	down(&dev->struct_sem);
 	entry = &dma->bufs[order];
-	if ( entry->buf_count ) {
-		up( &dev->struct_sem );
-		atomic_dec( &dev->buf_alloc );
-		return -ENOMEM; /* May only call once for each order */
+	if (entry->buf_count) {
+		up(&dev->struct_sem);
+		atomic_dec(&dev->buf_alloc);
+		return -ENOMEM;	/* May only call once for each order */
 	}
 
 	if (count < 0 || count > 4096) {
-		up( &dev->struct_sem );
-		atomic_dec( &dev->buf_alloc );
+		up(&dev->struct_sem);
+		atomic_dec(&dev->buf_alloc);
 		return -EINVAL;
 	}
 
-	entry->buflist = drm_alloc( count * sizeof(*entry->buflist),
-				    DRM_MEM_BUFS );
-	if ( !entry->buflist ) {
-		up( &dev->struct_sem );
-		atomic_dec( &dev->buf_alloc );
+	entry->buflist = drm_alloc(count * sizeof(*entry->buflist),
+				   DRM_MEM_BUFS);
+	if (!entry->buflist) {
+		up(&dev->struct_sem);
+		atomic_dec(&dev->buf_alloc);
 		return -ENOMEM;
 	}
-	memset( entry->buflist, 0, count * sizeof(*entry->buflist) );
+	memset(entry->buflist, 0, count * sizeof(*entry->buflist));
 
 	entry->buf_size = size;
 	entry->page_order = page_order;
 
 	offset = 0;
 
-	while ( entry->buf_count < count ) {
-		buf          = &entry->buflist[entry->buf_count];
-		buf->idx     = dma->buf_count + entry->buf_count;
-		buf->total   = alignment;
-		buf->order   = order;
-		buf->used    = 0;
+	while (entry->buf_count < count) {
+		buf = &entry->buflist[entry->buf_count];
+		buf->idx = dma->buf_count + entry->buf_count;
+		buf->total = alignment;
+		buf->order = order;
+		buf->used = 0;
 
-		buf->offset  = (dma->byte_count + offset);
+		buf->offset = (dma->byte_count + offset);
 		buf->bus_address = agp_offset + offset;
 		buf->address = (void *)(agp_offset + offset);
-		buf->next    = NULL;
+		buf->next = NULL;
 		buf->waiting = 0;
 		buf->pending = 0;
-		init_waitqueue_head( &buf->dma_wait );
-		buf->filp    = NULL;
+		init_waitqueue_head(&buf->dma_wait);
+		buf->filp = NULL;
 
 		buf->dev_priv_size = dev->driver->dev_priv_size;
-		buf->dev_private = drm_alloc( buf->dev_priv_size,
-					       DRM_MEM_BUFS );
-		if(!buf->dev_private) {
+		buf->dev_private = drm_alloc(buf->dev_priv_size, DRM_MEM_BUFS);
+		if (!buf->dev_private) {
 			/* Set count correctly so we free the proper amount. */
 			entry->buf_count = count;
-			drm_cleanup_buf_error(dev,entry);
-			up( &dev->struct_sem );
-			atomic_dec( &dev->buf_alloc );
+			drm_cleanup_buf_error(dev, entry);
+			up(&dev->struct_sem);
+			atomic_dec(&dev->buf_alloc);
 			return -ENOMEM;
 		}
-		memset( buf->dev_private, 0, buf->dev_priv_size );
+		memset(buf->dev_private, 0, buf->dev_priv_size);
 
-		DRM_DEBUG( "buffer %d @ %p\n",
-			   entry->buf_count, buf->address );
+		DRM_DEBUG("buffer %d @ %p\n", entry->buf_count, buf->address);
 
 		offset += alignment;
 		entry->buf_count++;
 		byte_count += PAGE_SIZE << page_order;
 	}
 
-	DRM_DEBUG( "byte_count: %d\n", byte_count );
+	DRM_DEBUG("byte_count: %d\n", byte_count);
 
-	temp_buflist = drm_realloc( dma->buflist,
-				     dma->buf_count * sizeof(*dma->buflist),
-				     (dma->buf_count + entry->buf_count)
-				     * sizeof(*dma->buflist),
-				     DRM_MEM_BUFS );
-	if(!temp_buflist) {
+	temp_buflist = drm_realloc(dma->buflist,
+				   dma->buf_count * sizeof(*dma->buflist),
+				   (dma->buf_count + entry->buf_count)
+				   * sizeof(*dma->buflist), DRM_MEM_BUFS);
+	if (!temp_buflist) {
 		/* Free the entry because it isn't valid */
-		drm_cleanup_buf_error(dev,entry);
-		up( &dev->struct_sem );
-		atomic_dec( &dev->buf_alloc );
+		drm_cleanup_buf_error(dev, entry);
+		up(&dev->struct_sem);
+		atomic_dec(&dev->buf_alloc);
 		return -ENOMEM;
 	}
 	dma->buflist = temp_buflist;
 
-	for ( i = 0 ; i < entry->buf_count ; i++ ) {
+	for (i = 0; i < entry->buf_count; i++) {
 		dma->buflist[i + dma->buf_count] = &entry->buflist[i];
 	}
 
 	dma->buf_count += entry->buf_count;
 	dma->byte_count += byte_count;
 
-	DRM_DEBUG( "dma->buf_count : %d\n", dma->buf_count );
-	DRM_DEBUG( "entry->buf_count : %d\n", entry->buf_count );
-
-	up( &dev->struct_sem );
+	DRM_DEBUG("dma->buf_count : %d\n", dma->buf_count);
+	DRM_DEBUG("entry->buf_count : %d\n", entry->buf_count);
 
-	request.count = entry->buf_count;
-	request.size = size;
+	up(&dev->struct_sem);
 
-	if ( copy_to_user( argp, &request, sizeof(request) ) )
-		return -EFAULT;
+	request->count = entry->buf_count;
+	request->size = size;
 
 	dma->flags = _DRM_DMA_USE_AGP;
 
-	atomic_dec( &dev->buf_alloc );
+	atomic_dec(&dev->buf_alloc);
 	return 0;
 }
-#endif /* __OS_HAS_AGP */
+EXPORT_SYMBOL(drm_addbufs_agp);
+#endif				/* __OS_HAS_AGP */
 
-int drm_addbufs_pci( struct inode *inode, struct file *filp,
-		      unsigned int cmd, unsigned long arg )
+int drm_addbufs_pci(drm_device_t * dev, drm_buf_desc_t * request)
 {
-   	drm_file_t *priv = filp->private_data;
-	drm_device_t *dev = priv->head->dev;
 	drm_device_dma_t *dma = dev->dma;
-	drm_buf_desc_t request;
 	int count;
 	int order;
 	int size;
@@ -543,183 +644,177 @@ int drm_addbufs_pci( struct inode *inode
 	int page_count;
 	unsigned long *temp_pagelist;
 	drm_buf_t **temp_buflist;
-	drm_buf_desc_t __user *argp = (void __user *)arg;
 
-	if (!drm_core_check_feature(dev, DRIVER_PCI_DMA)) return -EINVAL;
-	if ( !dma ) return -EINVAL;
+	if (!drm_core_check_feature(dev, DRIVER_PCI_DMA))
+		return -EINVAL;
 
-	if ( copy_from_user( &request, argp, sizeof(request) ) )
-		return -EFAULT;
+	if (!dma)
+		return -EINVAL;
 
-	count = request.count;
-	order = drm_order( request.size );
+	count = request->count;
+	order = drm_order(request->size);
 	size = 1 << order;
 
-	DRM_DEBUG( "count=%d, size=%d (%d), order=%d, queue_count=%d\n",
-		   request.count, request.size, size,
-		   order, dev->queue_count );
+	DRM_DEBUG("count=%d, size=%d (%d), order=%d, queue_count=%d\n",
+		  request->count, request->size, size, order, dev->queue_count);
 
-	if ( order < DRM_MIN_ORDER || order > DRM_MAX_ORDER ) return -EINVAL;
-	if ( dev->queue_count ) return -EBUSY; /* Not while in use */
+	if (order < DRM_MIN_ORDER || order > DRM_MAX_ORDER)
+		return -EINVAL;
+	if (dev->queue_count)
+		return -EBUSY;	/* Not while in use */
 
-	alignment = (request.flags & _DRM_PAGE_ALIGN)
-		? PAGE_ALIGN(size) : size;
+	alignment = (request->flags & _DRM_PAGE_ALIGN)
+	    ? PAGE_ALIGN(size) : size;
 	page_order = order - PAGE_SHIFT > 0 ? order - PAGE_SHIFT : 0;
 	total = PAGE_SIZE << page_order;
 
-	spin_lock( &dev->count_lock );
-	if ( dev->buf_use ) {
-		spin_unlock( &dev->count_lock );
+	spin_lock(&dev->count_lock);
+	if (dev->buf_use) {
+		spin_unlock(&dev->count_lock);
 		return -EBUSY;
 	}
-	atomic_inc( &dev->buf_alloc );
-	spin_unlock( &dev->count_lock );
+	atomic_inc(&dev->buf_alloc);
+	spin_unlock(&dev->count_lock);
 
-	down( &dev->struct_sem );
+	down(&dev->struct_sem);
 	entry = &dma->bufs[order];
-	if ( entry->buf_count ) {
-		up( &dev->struct_sem );
-		atomic_dec( &dev->buf_alloc );
+	if (entry->buf_count) {
+		up(&dev->struct_sem);
+		atomic_dec(&dev->buf_alloc);
 		return -ENOMEM;	/* May only call once for each order */
 	}
 
 	if (count < 0 || count > 4096) {
-		up( &dev->struct_sem );
-		atomic_dec( &dev->buf_alloc );
+		up(&dev->struct_sem);
+		atomic_dec(&dev->buf_alloc);
 		return -EINVAL;
 	}
 
-	entry->buflist = drm_alloc( count * sizeof(*entry->buflist),
-				    DRM_MEM_BUFS );
-	if ( !entry->buflist ) {
-		up( &dev->struct_sem );
-		atomic_dec( &dev->buf_alloc );
+	entry->buflist = drm_alloc(count * sizeof(*entry->buflist),
+				   DRM_MEM_BUFS);
+	if (!entry->buflist) {
+		up(&dev->struct_sem);
+		atomic_dec(&dev->buf_alloc);
 		return -ENOMEM;
 	}
-	memset( entry->buflist, 0, count * sizeof(*entry->buflist) );
+	memset(entry->buflist, 0, count * sizeof(*entry->buflist));
 
-	entry->seglist = drm_alloc( count * sizeof(*entry->seglist),
-				    DRM_MEM_SEGS );
-	if ( !entry->seglist ) {
-		drm_free( entry->buflist,
-			  count * sizeof(*entry->buflist),
-			  DRM_MEM_BUFS );
-		up( &dev->struct_sem );
-		atomic_dec( &dev->buf_alloc );
+	entry->seglist = drm_alloc(count * sizeof(*entry->seglist),
+				   DRM_MEM_SEGS);
+	if (!entry->seglist) {
+		drm_free(entry->buflist,
+			 count * sizeof(*entry->buflist), DRM_MEM_BUFS);
+		up(&dev->struct_sem);
+		atomic_dec(&dev->buf_alloc);
 		return -ENOMEM;
 	}
-	memset( entry->seglist, 0, count * sizeof(*entry->seglist) );
+	memset(entry->seglist, 0, count * sizeof(*entry->seglist));
 
 	/* Keep the original pagelist until we know all the allocations
 	 * have succeeded
 	 */
-	temp_pagelist = drm_alloc( (dma->page_count + (count << page_order))
-				    * sizeof(*dma->pagelist),
-				    DRM_MEM_PAGES );
+	temp_pagelist = drm_alloc((dma->page_count + (count << page_order))
+				  * sizeof(*dma->pagelist), DRM_MEM_PAGES);
 	if (!temp_pagelist) {
-		drm_free( entry->buflist,
-			   count * sizeof(*entry->buflist),
-			   DRM_MEM_BUFS );
-		drm_free( entry->seglist,
-			   count * sizeof(*entry->seglist),
-			   DRM_MEM_SEGS );
-		up( &dev->struct_sem );
-		atomic_dec( &dev->buf_alloc );
+		drm_free(entry->buflist,
+			 count * sizeof(*entry->buflist), DRM_MEM_BUFS);
+		drm_free(entry->seglist,
+			 count * sizeof(*entry->seglist), DRM_MEM_SEGS);
+		up(&dev->struct_sem);
+		atomic_dec(&dev->buf_alloc);
 		return -ENOMEM;
 	}
 	memcpy(temp_pagelist,
-	       dma->pagelist,
-	       dma->page_count * sizeof(*dma->pagelist));
-	DRM_DEBUG( "pagelist: %d entries\n",
-		   dma->page_count + (count << page_order) );
+	       dma->pagelist, dma->page_count * sizeof(*dma->pagelist));
+	DRM_DEBUG("pagelist: %d entries\n",
+		  dma->page_count + (count << page_order));
 
-	entry->buf_size	= size;
+	entry->buf_size = size;
 	entry->page_order = page_order;
 	byte_count = 0;
 	page_count = 0;
 
-	while ( entry->buf_count < count ) {
-		page = drm_alloc_pages( page_order, DRM_MEM_DMA );
-		if ( !page ) {
+	while (entry->buf_count < count) {
+		page = drm_alloc_pages(page_order, DRM_MEM_DMA);
+		if (!page) {
 			/* Set count correctly so we free the proper amount. */
 			entry->buf_count = count;
 			entry->seg_count = count;
 			drm_cleanup_buf_error(dev, entry);
-			drm_free( temp_pagelist,
-				   (dma->page_count + (count << page_order))
-				   * sizeof(*dma->pagelist),
-				   DRM_MEM_PAGES );
-			up( &dev->struct_sem );
-			atomic_dec( &dev->buf_alloc );
+			drm_free(temp_pagelist,
+				 (dma->page_count + (count << page_order))
+				 * sizeof(*dma->pagelist), DRM_MEM_PAGES);
+			up(&dev->struct_sem);
+			atomic_dec(&dev->buf_alloc);
 			return -ENOMEM;
 		}
 		entry->seglist[entry->seg_count++] = page;
-		for ( i = 0 ; i < (1 << page_order) ; i++ ) {
-			DRM_DEBUG( "page %d @ 0x%08lx\n",
-				   dma->page_count + page_count,
-				   page + PAGE_SIZE * i );
+		for (i = 0; i < (1 << page_order); i++) {
+			DRM_DEBUG("page %d @ 0x%08lx\n",
+				  dma->page_count + page_count,
+				  page + PAGE_SIZE * i);
 			temp_pagelist[dma->page_count + page_count++]
-				= page + PAGE_SIZE * i;
+			    = page + PAGE_SIZE * i;
 		}
-		for ( offset = 0 ;
-		      offset + size <= total && entry->buf_count < count ;
-		      offset += alignment, ++entry->buf_count ) {
-			buf	     = &entry->buflist[entry->buf_count];
-			buf->idx     = dma->buf_count + entry->buf_count;
-			buf->total   = alignment;
-			buf->order   = order;
-			buf->used    = 0;
-			buf->offset  = (dma->byte_count + byte_count + offset);
+		for (offset = 0;
+		     offset + size <= total && entry->buf_count < count;
+		     offset += alignment, ++entry->buf_count) {
+			buf = &entry->buflist[entry->buf_count];
+			buf->idx = dma->buf_count + entry->buf_count;
+			buf->total = alignment;
+			buf->order = order;
+			buf->used = 0;
+			buf->offset = (dma->byte_count + byte_count + offset);
 			buf->address = (void *)(page + offset);
-			buf->next    = NULL;
+			buf->bus_address = virt_to_bus(buf->address);
+			buf->next = NULL;
 			buf->waiting = 0;
 			buf->pending = 0;
-			init_waitqueue_head( &buf->dma_wait );
-			buf->filp    = NULL;
+			init_waitqueue_head(&buf->dma_wait);
+			buf->filp = NULL;
 
 			buf->dev_priv_size = dev->driver->dev_priv_size;
-			buf->dev_private = drm_alloc( buf->dev_priv_size,
-						       DRM_MEM_BUFS );
-			if(!buf->dev_private) {
+			buf->dev_private = drm_alloc(dev->driver->dev_priv_size,
+						     DRM_MEM_BUFS);
+			if (!buf->dev_private) {
 				/* Set count correctly so we free the proper amount. */
 				entry->buf_count = count;
 				entry->seg_count = count;
-				drm_cleanup_buf_error(dev,entry);
-				drm_free( temp_pagelist,
-					   (dma->page_count + (count << page_order))
-					   * sizeof(*dma->pagelist),
-					   DRM_MEM_PAGES );
-				up( &dev->struct_sem );
-				atomic_dec( &dev->buf_alloc );
+				drm_cleanup_buf_error(dev, entry);
+				drm_free(temp_pagelist,
+					 (dma->page_count +
+					  (count << page_order))
+					 * sizeof(*dma->pagelist),
+					 DRM_MEM_PAGES);
+				up(&dev->struct_sem);
+				atomic_dec(&dev->buf_alloc);
 				return -ENOMEM;
 			}
-			memset( buf->dev_private, 0, buf->dev_priv_size );
+			memset(buf->dev_private, 0, buf->dev_priv_size);
 
-			DRM_DEBUG( "buffer %d @ %p\n",
-				   entry->buf_count, buf->address );
+			DRM_DEBUG("buffer %d @ %p\n",
+				  entry->buf_count, buf->address);
 		}
 		byte_count += PAGE_SIZE << page_order;
 	}
 
-	temp_buflist = drm_realloc( dma->buflist,
-				     dma->buf_count * sizeof(*dma->buflist),
-				     (dma->buf_count + entry->buf_count)
-				     * sizeof(*dma->buflist),
-				     DRM_MEM_BUFS );
+	temp_buflist = drm_realloc(dma->buflist,
+				   dma->buf_count * sizeof(*dma->buflist),
+				   (dma->buf_count + entry->buf_count)
+				   * sizeof(*dma->buflist), DRM_MEM_BUFS);
 	if (!temp_buflist) {
 		/* Free the entry because it isn't valid */
-		drm_cleanup_buf_error(dev,entry);
-		drm_free( temp_pagelist,
-			   (dma->page_count + (count << page_order))
-			   * sizeof(*dma->pagelist),
-			   DRM_MEM_PAGES );
-		up( &dev->struct_sem );
-		atomic_dec( &dev->buf_alloc );
+		drm_cleanup_buf_error(dev, entry);
+		drm_free(temp_pagelist,
+			 (dma->page_count + (count << page_order))
+			 * sizeof(*dma->pagelist), DRM_MEM_PAGES);
+		up(&dev->struct_sem);
+		atomic_dec(&dev->buf_alloc);
 		return -ENOMEM;
 	}
 	dma->buflist = temp_buflist;
 
-	for ( i = 0 ; i < entry->buf_count ; i++ ) {
+	for (i = 0; i < entry->buf_count; i++) {
 		dma->buflist[i + dma->buf_count] = &entry->buflist[i];
 	}
 
@@ -728,8 +823,8 @@ int drm_addbufs_pci( struct inode *inode
 	 */
 	if (dma->page_count) {
 		drm_free(dma->pagelist,
-			  dma->page_count * sizeof(*dma->pagelist),
-			  DRM_MEM_PAGES);
+			 dma->page_count * sizeof(*dma->pagelist),
+			 DRM_MEM_PAGES);
 	}
 	dma->pagelist = temp_pagelist;
 
@@ -738,27 +833,20 @@ int drm_addbufs_pci( struct inode *inode
 	dma->page_count += entry->seg_count << page_order;
 	dma->byte_count += PAGE_SIZE * (entry->seg_count << page_order);
 
-	up( &dev->struct_sem );
+	up(&dev->struct_sem);
 
-	request.count = entry->buf_count;
-	request.size = size;
+	request->count = entry->buf_count;
+	request->size = size;
 
-	if ( copy_to_user( argp, &request, sizeof(request) ) )
-		return -EFAULT;
-
-	atomic_dec( &dev->buf_alloc );
+	atomic_dec(&dev->buf_alloc);
 	return 0;
 
 }
+EXPORT_SYMBOL(drm_addbufs_pci);
 
-int drm_addbufs_sg( struct inode *inode, struct file *filp,
-                     unsigned int cmd, unsigned long arg )
+static int drm_addbufs_sg(drm_device_t * dev, drm_buf_desc_t * request)
 {
-	drm_file_t *priv = filp->private_data;
-	drm_device_t *dev = priv->head->dev;
 	drm_device_dma_t *dma = dev->dma;
-	drm_buf_desc_t __user *argp = (void __user *)arg;
-	drm_buf_desc_t request;
 	drm_buf_entry_t *entry;
 	drm_buf_t *buf;
 	unsigned long offset;
@@ -773,150 +861,304 @@ int drm_addbufs_sg( struct inode *inode,
 	int i;
 	drm_buf_t **temp_buflist;
 
-	if (!drm_core_check_feature(dev, DRIVER_SG)) return -EINVAL;
-	
-	if ( !dma ) return -EINVAL;
+	if (!drm_core_check_feature(dev, DRIVER_SG))
+		return -EINVAL;
 
-	if ( copy_from_user( &request, argp, sizeof(request) ) )
-		return -EFAULT;
+	if (!dma)
+		return -EINVAL;
 
-	count = request.count;
-	order = drm_order( request.size );
+	count = request->count;
+	order = drm_order(request->size);
 	size = 1 << order;
 
-	alignment  = (request.flags & _DRM_PAGE_ALIGN)
-			? PAGE_ALIGN(size) : size;
+	alignment = (request->flags & _DRM_PAGE_ALIGN)
+	    ? PAGE_ALIGN(size) : size;
 	page_order = order - PAGE_SHIFT > 0 ? order - PAGE_SHIFT : 0;
 	total = PAGE_SIZE << page_order;
 
 	byte_count = 0;
-	agp_offset = request.agp_start;
+	agp_offset = request->agp_start;
+
+	DRM_DEBUG("count:      %d\n", count);
+	DRM_DEBUG("order:      %d\n", order);
+	DRM_DEBUG("size:       %d\n", size);
+	DRM_DEBUG("agp_offset: %lu\n", agp_offset);
+	DRM_DEBUG("alignment:  %d\n", alignment);
+	DRM_DEBUG("page_order: %d\n", page_order);
+	DRM_DEBUG("total:      %d\n", total);
+
+	if (order < DRM_MIN_ORDER || order > DRM_MAX_ORDER)
+		return -EINVAL;
+	if (dev->queue_count)
+		return -EBUSY;	/* Not while in use */
 
-	DRM_DEBUG( "count:      %d\n",  count );
-	DRM_DEBUG( "order:      %d\n",  order );
-	DRM_DEBUG( "size:       %d\n",  size );
-	DRM_DEBUG( "agp_offset: %lu\n", agp_offset );
-	DRM_DEBUG( "alignment:  %d\n",  alignment );
-	DRM_DEBUG( "page_order: %d\n",  page_order );
-	DRM_DEBUG( "total:      %d\n",  total );
-
-	if ( order < DRM_MIN_ORDER || order > DRM_MAX_ORDER ) return -EINVAL;
-	if ( dev->queue_count ) return -EBUSY; /* Not while in use */
-
-	spin_lock( &dev->count_lock );
-	if ( dev->buf_use ) {
-		spin_unlock( &dev->count_lock );
+	spin_lock(&dev->count_lock);
+	if (dev->buf_use) {
+		spin_unlock(&dev->count_lock);
 		return -EBUSY;
 	}
-	atomic_inc( &dev->buf_alloc );
-	spin_unlock( &dev->count_lock );
+	atomic_inc(&dev->buf_alloc);
+	spin_unlock(&dev->count_lock);
 
-	down( &dev->struct_sem );
+	down(&dev->struct_sem);
 	entry = &dma->bufs[order];
-	if ( entry->buf_count ) {
-		up( &dev->struct_sem );
-		atomic_dec( &dev->buf_alloc );
-		return -ENOMEM; /* May only call once for each order */
+	if (entry->buf_count) {
+		up(&dev->struct_sem);
+		atomic_dec(&dev->buf_alloc);
+		return -ENOMEM;	/* May only call once for each order */
 	}
 
 	if (count < 0 || count > 4096) {
-		up( &dev->struct_sem );
-		atomic_dec( &dev->buf_alloc );
+		up(&dev->struct_sem);
+		atomic_dec(&dev->buf_alloc);
 		return -EINVAL;
 	}
 
-	entry->buflist = drm_alloc( count * sizeof(*entry->buflist),
-				     DRM_MEM_BUFS );
-	if ( !entry->buflist ) {
-		up( &dev->struct_sem );
-		atomic_dec( &dev->buf_alloc );
+	entry->buflist = drm_alloc(count * sizeof(*entry->buflist),
+				   DRM_MEM_BUFS);
+	if (!entry->buflist) {
+		up(&dev->struct_sem);
+		atomic_dec(&dev->buf_alloc);
 		return -ENOMEM;
 	}
-	memset( entry->buflist, 0, count * sizeof(*entry->buflist) );
+	memset(entry->buflist, 0, count * sizeof(*entry->buflist));
 
 	entry->buf_size = size;
 	entry->page_order = page_order;
 
 	offset = 0;
 
-	while ( entry->buf_count < count ) {
-		buf          = &entry->buflist[entry->buf_count];
-		buf->idx     = dma->buf_count + entry->buf_count;
-		buf->total   = alignment;
-		buf->order   = order;
-		buf->used    = 0;
+	while (entry->buf_count < count) {
+		buf = &entry->buflist[entry->buf_count];
+		buf->idx = dma->buf_count + entry->buf_count;
+		buf->total = alignment;
+		buf->order = order;
+		buf->used = 0;
 
-		buf->offset  = (dma->byte_count + offset);
+		buf->offset = (dma->byte_count + offset);
 		buf->bus_address = agp_offset + offset;
 		buf->address = (void *)(agp_offset + offset + dev->sg->handle);
-		buf->next    = NULL;
+		buf->next = NULL;
 		buf->waiting = 0;
 		buf->pending = 0;
-		init_waitqueue_head( &buf->dma_wait );
-		buf->filp    = NULL;
+		init_waitqueue_head(&buf->dma_wait);
+		buf->filp = NULL;
 
 		buf->dev_priv_size = dev->driver->dev_priv_size;
-		buf->dev_private = drm_alloc( buf->dev_priv_size,
-					       DRM_MEM_BUFS );
-		if(!buf->dev_private) {
+		buf->dev_private = drm_alloc(dev->driver->dev_priv_size,
+					     DRM_MEM_BUFS);
+		if (!buf->dev_private) {
 			/* Set count correctly so we free the proper amount. */
 			entry->buf_count = count;
-			drm_cleanup_buf_error(dev,entry);
-			up( &dev->struct_sem );
-			atomic_dec( &dev->buf_alloc );
+			drm_cleanup_buf_error(dev, entry);
+			up(&dev->struct_sem);
+			atomic_dec(&dev->buf_alloc);
 			return -ENOMEM;
 		}
 
-		memset( buf->dev_private, 0, buf->dev_priv_size );
+		memset(buf->dev_private, 0, buf->dev_priv_size);
 
-		DRM_DEBUG( "buffer %d @ %p\n",
-			   entry->buf_count, buf->address );
+		DRM_DEBUG("buffer %d @ %p\n", entry->buf_count, buf->address);
 
 		offset += alignment;
 		entry->buf_count++;
 		byte_count += PAGE_SIZE << page_order;
 	}
 
-	DRM_DEBUG( "byte_count: %d\n", byte_count );
+	DRM_DEBUG("byte_count: %d\n", byte_count);
 
-	temp_buflist = drm_realloc( dma->buflist,
-				     dma->buf_count * sizeof(*dma->buflist),
-				     (dma->buf_count + entry->buf_count)
-				     * sizeof(*dma->buflist),
-				     DRM_MEM_BUFS );
-	if(!temp_buflist) {
+	temp_buflist = drm_realloc(dma->buflist,
+				   dma->buf_count * sizeof(*dma->buflist),
+				   (dma->buf_count + entry->buf_count)
+				   * sizeof(*dma->buflist), DRM_MEM_BUFS);
+	if (!temp_buflist) {
 		/* Free the entry because it isn't valid */
-		drm_cleanup_buf_error(dev,entry);
-		up( &dev->struct_sem );
-		atomic_dec( &dev->buf_alloc );
+		drm_cleanup_buf_error(dev, entry);
+		up(&dev->struct_sem);
+		atomic_dec(&dev->buf_alloc);
 		return -ENOMEM;
 	}
 	dma->buflist = temp_buflist;
 
-	for ( i = 0 ; i < entry->buf_count ; i++ ) {
+	for (i = 0; i < entry->buf_count; i++) {
 		dma->buflist[i + dma->buf_count] = &entry->buflist[i];
 	}
 
 	dma->buf_count += entry->buf_count;
 	dma->byte_count += byte_count;
 
-	DRM_DEBUG( "dma->buf_count : %d\n", dma->buf_count );
-	DRM_DEBUG( "entry->buf_count : %d\n", entry->buf_count );
+	DRM_DEBUG("dma->buf_count : %d\n", dma->buf_count);
+	DRM_DEBUG("entry->buf_count : %d\n", entry->buf_count);
 
-	up( &dev->struct_sem );
-
-	request.count = entry->buf_count;
-	request.size = size;
+	up(&dev->struct_sem);
 
-	if ( copy_to_user( argp, &request, sizeof(request) ) )
-		return -EFAULT;
+	request->count = entry->buf_count;
+	request->size = size;
 
 	dma->flags = _DRM_DMA_USE_SG;
 
-	atomic_dec( &dev->buf_alloc );
+	atomic_dec(&dev->buf_alloc);
 	return 0;
 }
 
+
+int drm_addbufs_fb(drm_device_t * dev, drm_buf_desc_t * request)
+{
+	drm_device_dma_t *dma = dev->dma;
+	drm_buf_entry_t *entry;
+	drm_buf_t *buf;
+	unsigned long offset;
+	unsigned long agp_offset;
+	int count;
+	int order;
+	int size;
+	int alignment;
+	int page_order;
+	int total;
+	int byte_count;
+	int i;
+	drm_buf_t **temp_buflist;
+
+	if (!drm_core_check_feature(dev, DRIVER_FB_DMA))
+		return -EINVAL;
+    
+	if (!dma)
+		return -EINVAL;
+
+	count = request->count;
+	order = drm_order(request->size);
+	size = 1 << order;
+
+	alignment = (request->flags & _DRM_PAGE_ALIGN)
+	    ? PAGE_ALIGN(size) : size;
+	page_order = order - PAGE_SHIFT > 0 ? order - PAGE_SHIFT : 0;
+	total = PAGE_SIZE << page_order;
+
+	byte_count = 0;
+	agp_offset = request->agp_start;
+
+	DRM_DEBUG("count:      %d\n", count);
+	DRM_DEBUG("order:      %d\n", order);
+	DRM_DEBUG("size:       %d\n", size);
+	DRM_DEBUG("agp_offset: %lu\n", agp_offset);
+	DRM_DEBUG("alignment:  %d\n", alignment);
+	DRM_DEBUG("page_order: %d\n", page_order);
+	DRM_DEBUG("total:      %d\n", total);
+
+	if (order < DRM_MIN_ORDER || order > DRM_MAX_ORDER)
+		return -EINVAL;
+	if (dev->queue_count)
+		return -EBUSY;	/* Not while in use */
+
+	spin_lock(&dev->count_lock);
+	if (dev->buf_use) {
+		spin_unlock(&dev->count_lock);
+		return -EBUSY;
+	}
+	atomic_inc(&dev->buf_alloc);
+	spin_unlock(&dev->count_lock);
+
+	down(&dev->struct_sem);
+	entry = &dma->bufs[order];
+	if (entry->buf_count) {
+		up(&dev->struct_sem);
+		atomic_dec(&dev->buf_alloc);
+		return -ENOMEM;	/* May only call once for each order */
+	}
+
+	if (count < 0 || count > 4096) {
+		up(&dev->struct_sem);
+		atomic_dec(&dev->buf_alloc);
+		return -EINVAL;
+	}
+
+	entry->buflist = drm_alloc(count * sizeof(*entry->buflist),
+				   DRM_MEM_BUFS);
+	if (!entry->buflist) {
+		up(&dev->struct_sem);
+		atomic_dec(&dev->buf_alloc);
+		return -ENOMEM;
+	}
+	memset(entry->buflist, 0, count * sizeof(*entry->buflist));
+
+	entry->buf_size = size;
+	entry->page_order = page_order;
+
+	offset = 0;
+
+	while (entry->buf_count < count) {
+		buf = &entry->buflist[entry->buf_count];
+		buf->idx = dma->buf_count + entry->buf_count;
+		buf->total = alignment;
+		buf->order = order;
+		buf->used = 0;
+
+		buf->offset = (dma->byte_count + offset);
+		buf->bus_address = agp_offset + offset;
+		buf->address = (void *)(agp_offset + offset);
+		buf->next = NULL;
+		buf->waiting = 0;
+		buf->pending = 0;
+		init_waitqueue_head(&buf->dma_wait);
+		buf->filp = NULL;
+
+		buf->dev_priv_size = dev->driver->dev_priv_size;
+		buf->dev_private = drm_alloc(buf->dev_priv_size, DRM_MEM_BUFS);
+		if (!buf->dev_private) {
+			/* Set count correctly so we free the proper amount. */
+			entry->buf_count = count;
+			drm_cleanup_buf_error(dev, entry);
+			up(&dev->struct_sem);
+			atomic_dec(&dev->buf_alloc);
+			return -ENOMEM;
+		}
+		memset(buf->dev_private, 0, buf->dev_priv_size);
+
+		DRM_DEBUG("buffer %d @ %p\n", entry->buf_count, buf->address);
+
+		offset += alignment;
+		entry->buf_count++;
+		byte_count += PAGE_SIZE << page_order;
+	}
+
+	DRM_DEBUG("byte_count: %d\n", byte_count);
+
+	temp_buflist = drm_realloc(dma->buflist,
+				   dma->buf_count * sizeof(*dma->buflist),
+				   (dma->buf_count + entry->buf_count)
+				   * sizeof(*dma->buflist), DRM_MEM_BUFS);
+	if (!temp_buflist) {
+		/* Free the entry because it isn't valid */
+		drm_cleanup_buf_error(dev, entry);
+		up(&dev->struct_sem);
+		atomic_dec(&dev->buf_alloc);
+		return -ENOMEM;
+	}
+	dma->buflist = temp_buflist;
+
+	for (i = 0; i < entry->buf_count; i++) {
+		dma->buflist[i + dma->buf_count] = &entry->buflist[i];
+	}
+
+	dma->buf_count += entry->buf_count;
+	dma->byte_count += byte_count;
+
+	DRM_DEBUG("dma->buf_count : %d\n", dma->buf_count);
+	DRM_DEBUG("entry->buf_count : %d\n", entry->buf_count);
+
+	up(&dev->struct_sem);
+
+	request->count = entry->buf_count;
+	request->size = size;
+
+	dma->flags = _DRM_DMA_USE_FB;
+
+	atomic_dec(&dev->buf_alloc);
+	return 0;
+}
+EXPORT_SYMBOL(drm_addbufs_fb);
+
+
 /**
  * Add buffers for DMA transfers (ioctl).
  *
@@ -931,31 +1173,44 @@ int drm_addbufs_sg( struct inode *inode,
  * addbufs_sg() or addbufs_pci() for AGP, scatter-gather or consistent
  * PCI memory respectively.
  */
-int drm_addbufs( struct inode *inode, struct file *filp,
-		  unsigned int cmd, unsigned long arg )
+int drm_addbufs(struct inode *inode, struct file *filp,
+		unsigned int cmd, unsigned long arg)
 {
 	drm_buf_desc_t request;
 	drm_file_t *priv = filp->private_data;
 	drm_device_t *dev = priv->head->dev;
-	
+	int ret;
+
+
 	if (!drm_core_check_feature(dev, DRIVER_HAVE_DMA))
 		return -EINVAL;
 
-	if ( copy_from_user( &request, (drm_buf_desc_t __user *)arg,
-			     sizeof(request) ) )
+	if (copy_from_user(&request, (drm_buf_desc_t __user *) arg,
+			   sizeof(request)))
 		return -EFAULT;
 
 #if __OS_HAS_AGP
-	if ( request.flags & _DRM_AGP_BUFFER )
-		return drm_addbufs_agp( inode, filp, cmd, arg );
+	if (request.flags & _DRM_AGP_BUFFER) {
+		ret = drm_addbufs_agp(dev, & request);
+	}
 	else
 #endif
-	if ( request.flags & _DRM_SG_BUFFER )
-		return drm_addbufs_sg( inode, filp, cmd, arg );
-	else
-		return drm_addbufs_pci( inode, filp, cmd, arg );
-}
+	if (request.flags & _DRM_SG_BUFFER)
+		ret = drm_addbufs_sg(dev, & request);
+        else if (request.flags & _DRM_FB_BUFFER)
+                ret = drm_addbufs_fb(dev, & request);
+        else
+		ret = drm_addbufs_pci(dev, & request);
+
+	if (ret == 0) {
+		if (copy_to_user( (void __user *) arg, &request, 
+				  sizeof(request))) {
+			ret = -EFAULT;
+		}
+	}
 
+	return ret;
+}
 
 /**
  * Get information about the buffer mappings.
@@ -974,8 +1229,8 @@ int drm_addbufs( struct inode *inode, st
  * lock, preventing of allocating more buffers after this call. Information
  * about each requested buffer is then copied into user space.
  */
-int drm_infobufs( struct inode *inode, struct file *filp,
-		   unsigned int cmd, unsigned long arg )
+int drm_infobufs(struct inode *inode, struct file *filp,
+		 unsigned int cmd, unsigned long arg)
 {
 	drm_file_t *priv = filp->private_data;
 	drm_device_t *dev = priv->head->dev;
@@ -988,58 +1243,61 @@ int drm_infobufs( struct inode *inode, s
 	if (!drm_core_check_feature(dev, DRIVER_HAVE_DMA))
 		return -EINVAL;
 
-	if ( !dma ) return -EINVAL;
+	if (!dma)
+		return -EINVAL;
 
-	spin_lock( &dev->count_lock );
-	if ( atomic_read( &dev->buf_alloc ) ) {
-		spin_unlock( &dev->count_lock );
+	spin_lock(&dev->count_lock);
+	if (atomic_read(&dev->buf_alloc)) {
+		spin_unlock(&dev->count_lock);
 		return -EBUSY;
 	}
 	++dev->buf_use;		/* Can't allocate more after this call */
-	spin_unlock( &dev->count_lock );
+	spin_unlock(&dev->count_lock);
 
-	if ( copy_from_user( &request, argp, sizeof(request) ) )
+	if (copy_from_user(&request, argp, sizeof(request)))
 		return -EFAULT;
 
-	for ( i = 0, count = 0 ; i < DRM_MAX_ORDER + 1 ; i++ ) {
-		if ( dma->bufs[i].buf_count ) ++count;
+	for (i = 0, count = 0; i < DRM_MAX_ORDER + 1; i++) {
+		if (dma->bufs[i].buf_count)
+			++count;
 	}
 
-	DRM_DEBUG( "count = %d\n", count );
-
-	if ( request.count >= count ) {
-		for ( i = 0, count = 0 ; i < DRM_MAX_ORDER + 1 ; i++ ) {
-			if ( dma->bufs[i].buf_count ) {
-				drm_buf_desc_t __user *to = &request.list[count];
+	DRM_DEBUG("count = %d\n", count);
+
+	if (request.count >= count) {
+		for (i = 0, count = 0; i < DRM_MAX_ORDER + 1; i++) {
+			if (dma->bufs[i].buf_count) {
+				drm_buf_desc_t __user *to =
+				    &request.list[count];
 				drm_buf_entry_t *from = &dma->bufs[i];
 				drm_freelist_t *list = &dma->bufs[i].freelist;
-				if ( copy_to_user( &to->count,
-						   &from->buf_count,
-						   sizeof(from->buf_count) ) ||
-				     copy_to_user( &to->size,
-						   &from->buf_size,
-						   sizeof(from->buf_size) ) ||
-				     copy_to_user( &to->low_mark,
-						   &list->low_mark,
-						   sizeof(list->low_mark) ) ||
-				     copy_to_user( &to->high_mark,
-						   &list->high_mark,
-						   sizeof(list->high_mark) ) )
+				if (copy_to_user(&to->count,
+						 &from->buf_count,
+						 sizeof(from->buf_count)) ||
+				    copy_to_user(&to->size,
+						 &from->buf_size,
+						 sizeof(from->buf_size)) ||
+				    copy_to_user(&to->low_mark,
+						 &list->low_mark,
+						 sizeof(list->low_mark)) ||
+				    copy_to_user(&to->high_mark,
+						 &list->high_mark,
+						 sizeof(list->high_mark)))
 					return -EFAULT;
 
-				DRM_DEBUG( "%d %d %d %d %d\n",
-					   i,
-					   dma->bufs[i].buf_count,
-					   dma->bufs[i].buf_size,
-					   dma->bufs[i].freelist.low_mark,
-					   dma->bufs[i].freelist.high_mark );
+				DRM_DEBUG("%d %d %d %d %d\n",
+					  i,
+					  dma->bufs[i].buf_count,
+					  dma->bufs[i].buf_size,
+					  dma->bufs[i].freelist.low_mark,
+					  dma->bufs[i].freelist.high_mark);
 				++count;
 			}
 		}
 	}
 	request.count = count;
 
-	if ( copy_to_user( argp, &request, sizeof(request) ) )
+	if (copy_to_user(argp, &request, sizeof(request)))
 		return -EFAULT;
 
 	return 0;
@@ -1059,8 +1317,8 @@ int drm_infobufs( struct inode *inode, s
  *
  * \note This ioctl is deprecated and mostly never used.
  */
-int drm_markbufs( struct inode *inode, struct file *filp,
-		   unsigned int cmd, unsigned long arg )
+int drm_markbufs(struct inode *inode, struct file *filp,
+		 unsigned int cmd, unsigned long arg)
 {
 	drm_file_t *priv = filp->private_data;
 	drm_device_t *dev = priv->head->dev;
@@ -1072,44 +1330,45 @@ int drm_markbufs( struct inode *inode, s
 	if (!drm_core_check_feature(dev, DRIVER_HAVE_DMA))
 		return -EINVAL;
 
-	if ( !dma ) return -EINVAL;
+	if (!dma)
+		return -EINVAL;
 
-	if ( copy_from_user( &request,
-			     (drm_buf_desc_t __user *)arg,
-			     sizeof(request) ) )
+	if (copy_from_user(&request,
+			   (drm_buf_desc_t __user *) arg, sizeof(request)))
 		return -EFAULT;
 
-	DRM_DEBUG( "%d, %d, %d\n",
-		   request.size, request.low_mark, request.high_mark );
-	order = drm_order( request.size );
-	if ( order < DRM_MIN_ORDER || order > DRM_MAX_ORDER ) return -EINVAL;
+	DRM_DEBUG("%d, %d, %d\n",
+		  request.size, request.low_mark, request.high_mark);
+	order = drm_order(request.size);
+	if (order < DRM_MIN_ORDER || order > DRM_MAX_ORDER)
+		return -EINVAL;
 	entry = &dma->bufs[order];
 
-	if ( request.low_mark < 0 || request.low_mark > entry->buf_count )
+	if (request.low_mark < 0 || request.low_mark > entry->buf_count)
 		return -EINVAL;
-	if ( request.high_mark < 0 || request.high_mark > entry->buf_count )
+	if (request.high_mark < 0 || request.high_mark > entry->buf_count)
 		return -EINVAL;
 
-	entry->freelist.low_mark  = request.low_mark;
+	entry->freelist.low_mark = request.low_mark;
 	entry->freelist.high_mark = request.high_mark;
 
 	return 0;
 }
 
 /**
- * Unreserve the buffers in list, previously reserved using drmDMA. 
+ * Unreserve the buffers in list, previously reserved using drmDMA.
  *
  * \param inode device inode.
  * \param filp file pointer.
  * \param cmd command.
  * \param arg pointer to a drm_buf_free structure.
  * \return zero on success or a negative number on failure.
- * 
+ *
  * Calls free_buffer() for each used buffer.
  * This function is primarily used for debugging.
  */
-int drm_freebufs( struct inode *inode, struct file *filp,
-		   unsigned int cmd, unsigned long arg )
+int drm_freebufs(struct inode *inode, struct file *filp,
+		 unsigned int cmd, unsigned long arg)
 {
 	drm_file_t *priv = filp->private_data;
 	drm_device_t *dev = priv->head->dev;
@@ -1122,31 +1381,29 @@ int drm_freebufs( struct inode *inode, s
 	if (!drm_core_check_feature(dev, DRIVER_HAVE_DMA))
 		return -EINVAL;
 
-	if ( !dma ) return -EINVAL;
+	if (!dma)
+		return -EINVAL;
 
-	if ( copy_from_user( &request,
-			     (drm_buf_free_t __user *)arg,
-			     sizeof(request) ) )
+	if (copy_from_user(&request,
+			   (drm_buf_free_t __user *) arg, sizeof(request)))
 		return -EFAULT;
 
-	DRM_DEBUG( "%d\n", request.count );
-	for ( i = 0 ; i < request.count ; i++ ) {
-		if ( copy_from_user( &idx,
-				     &request.list[i],
-				     sizeof(idx) ) )
+	DRM_DEBUG("%d\n", request.count);
+	for (i = 0; i < request.count; i++) {
+		if (copy_from_user(&idx, &request.list[i], sizeof(idx)))
 			return -EFAULT;
-		if ( idx < 0 || idx >= dma->buf_count ) {
-			DRM_ERROR( "Index %d (of %d max)\n",
-				   idx, dma->buf_count - 1 );
+		if (idx < 0 || idx >= dma->buf_count) {
+			DRM_ERROR("Index %d (of %d max)\n",
+				  idx, dma->buf_count - 1);
 			return -EINVAL;
 		}
 		buf = dma->buflist[idx];
-		if ( buf->filp != filp ) {
-			DRM_ERROR( "Process %d freeing buffer not owned\n",
-				   current->pid );
+		if (buf->filp != filp) {
+			DRM_ERROR("Process %d freeing buffer not owned\n",
+				  current->pid);
 			return -EINVAL;
 		}
-		drm_free_buffer( dev, buf );
+		drm_free_buffer(dev, buf);
 	}
 
 	return 0;
@@ -1165,8 +1422,8 @@ int drm_freebufs( struct inode *inode, s
  * about each buffer into user space. The PCI buffers are already mapped on the
  * addbufs_pci() call.
  */
-int drm_mapbufs( struct inode *inode, struct file *filp,
-		  unsigned int cmd, unsigned long arg )
+int drm_mapbufs(struct inode *inode, struct file *filp,
+		unsigned int cmd, unsigned long arg)
 {
 	drm_file_t *priv = filp->private_data;
 	drm_device_t *dev = priv->head->dev;
@@ -1182,100 +1439,126 @@ int drm_mapbufs( struct inode *inode, st
 	if (!drm_core_check_feature(dev, DRIVER_HAVE_DMA))
 		return -EINVAL;
 
-	if ( !dma ) return -EINVAL;
+	if (!dma)
+		return -EINVAL;
 
-	spin_lock( &dev->count_lock );
-	if ( atomic_read( &dev->buf_alloc ) ) {
-		spin_unlock( &dev->count_lock );
+	spin_lock(&dev->count_lock);
+	if (atomic_read(&dev->buf_alloc)) {
+		spin_unlock(&dev->count_lock);
 		return -EBUSY;
 	}
 	dev->buf_use++;		/* Can't allocate more after this call */
-	spin_unlock( &dev->count_lock );
+	spin_unlock(&dev->count_lock);
 
-	if ( copy_from_user( &request, argp, sizeof(request) ) )
+	if (copy_from_user(&request, argp, sizeof(request)))
 		return -EFAULT;
 
-	if ( request.count >= dma->buf_count ) {
-		if ((drm_core_has_AGP(dev) && (dma->flags & _DRM_DMA_USE_AGP)) ||
-		    (drm_core_check_feature(dev, DRIVER_SG) && (dma->flags & _DRM_DMA_USE_SG)) ) {
+	if (request.count >= dma->buf_count) {
+		if ((drm_core_has_AGP(dev) && (dma->flags & _DRM_DMA_USE_AGP))
+                    || (drm_core_check_feature(dev, DRIVER_SG)
+                    && (dma->flags & _DRM_DMA_USE_SG))
+                    || (drm_core_check_feature(dev, DRIVER_FB_DMA)
+                    && (dma->flags & _DRM_DMA_USE_FB))) {
 			drm_map_t *map = dev->agp_buffer_map;
 
-			if ( !map ) {
+			if (!map) {
 				retcode = -EINVAL;
 				goto done;
 			}
-
 #if LINUX_VERSION_CODE <= 0x020402
-			down( &current->mm->mmap_sem );
+			down(&current->mm->mmap_sem);
 #else
-			down_write( &current->mm->mmap_sem );
+			down_write(&current->mm->mmap_sem);
 #endif
-			virtual = do_mmap( filp, 0, map->size,
-					   PROT_READ | PROT_WRITE,
-					   MAP_SHARED,
-					   (unsigned long)map->offset );
+			virtual = do_mmap(filp, 0, map->size,
+					  PROT_READ | PROT_WRITE,
+					  MAP_SHARED,
+					  (unsigned long)map->offset);
 #if LINUX_VERSION_CODE <= 0x020402
-			up( &current->mm->mmap_sem );
+			up(&current->mm->mmap_sem);
 #else
-			up_write( &current->mm->mmap_sem );
+			up_write(&current->mm->mmap_sem);
 #endif
 		} else {
 #if LINUX_VERSION_CODE <= 0x020402
-			down( &current->mm->mmap_sem );
+			down(&current->mm->mmap_sem);
 #else
-			down_write( &current->mm->mmap_sem );
+			down_write(&current->mm->mmap_sem);
 #endif
-			virtual = do_mmap( filp, 0, dma->byte_count,
-					   PROT_READ | PROT_WRITE,
-					   MAP_SHARED, 0 );
+			virtual = do_mmap(filp, 0, dma->byte_count,
+					  PROT_READ | PROT_WRITE,
+					  MAP_SHARED, 0);
 #if LINUX_VERSION_CODE <= 0x020402
-			up( &current->mm->mmap_sem );
+			up(&current->mm->mmap_sem);
 #else
-			up_write( &current->mm->mmap_sem );
+			up_write(&current->mm->mmap_sem);
 #endif
 		}
-		if ( virtual > -1024UL ) {
+		if (virtual > -1024UL) {
 			/* Real error */
 			retcode = (signed long)virtual;
 			goto done;
 		}
 		request.virtual = (void __user *)virtual;
 
-		for ( i = 0 ; i < dma->buf_count ; i++ ) {
-			if ( copy_to_user( &request.list[i].idx,
-					   &dma->buflist[i]->idx,
-					   sizeof(request.list[0].idx) ) ) {
+		for (i = 0; i < dma->buf_count; i++) {
+			if (copy_to_user(&request.list[i].idx,
+					 &dma->buflist[i]->idx,
+					 sizeof(request.list[0].idx))) {
 				retcode = -EFAULT;
 				goto done;
 			}
-			if ( copy_to_user( &request.list[i].total,
-					   &dma->buflist[i]->total,
-					   sizeof(request.list[0].total) ) ) {
+			if (copy_to_user(&request.list[i].total,
+					 &dma->buflist[i]->total,
+					 sizeof(request.list[0].total))) {
 				retcode = -EFAULT;
 				goto done;
 			}
-			if ( copy_to_user( &request.list[i].used,
-					   &zero,
-					   sizeof(zero) ) ) {
+			if (copy_to_user(&request.list[i].used,
+					 &zero, sizeof(zero))) {
 				retcode = -EFAULT;
 				goto done;
 			}
-			address = virtual + dma->buflist[i]->offset; /* *** */
-			if ( copy_to_user( &request.list[i].address,
-					   &address,
-					   sizeof(address) ) ) {
+			address = virtual + dma->buflist[i]->offset;	/* *** */
+			if (copy_to_user(&request.list[i].address,
+					 &address, sizeof(address))) {
 				retcode = -EFAULT;
 				goto done;
 			}
 		}
 	}
- done:
+      done:
 	request.count = dma->buf_count;
-	DRM_DEBUG( "%d buffers, retcode = %d\n", request.count, retcode );
+	DRM_DEBUG("%d buffers, retcode = %d\n", request.count, retcode);
 
-	if ( copy_to_user( argp, &request, sizeof(request) ) )
+	if (copy_to_user(argp, &request, sizeof(request)))
 		return -EFAULT;
 
 	return retcode;
 }
 
+/**
+ * Compute size order.  Returns the exponent of the smaller power of two which
+ * is greater or equal to given number.
+ *
+ * \param size size.
+ * \return order.
+ *
+ * \todo Can be made faster.
+ */
+int drm_order( unsigned long size )
+{
+	int order;
+	unsigned long tmp;
+
+	for (order = 0, tmp = size >> 1; tmp; tmp >>= 1, order++)
+		;
+
+	if (size & (size - 1))
+		++order;
+
+	return order;
+}
+EXPORT_SYMBOL(drm_order);
+
+
diff -purN linux-2.6.12.orig/drivers/char/drm/drm_compat.h linux-2.6.12/drivers/char/drm/drm_compat.h
--- linux-2.6.12.orig/drivers/char/drm/drm_compat.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/drm/drm_compat.h	2005-07-05 08:37:30.000000000 +0200
@@ -0,0 +1,199 @@
+/**
+ * \file drm_compat.h
+ * Backward compatability definitions for Direct Rendering Manager
+ *
+ * \author Rickard E. (Rik) Faith <faith@valinux.com>
+ * \author Gareth Hughes <gareth@valinux.com>
+ */
+
+/*
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _DRM_COMPAT_H_
+#define _DRM_COMPAT_H_
+
+#ifndef minor
+#define minor(x) MINOR((x))
+#endif
+
+#ifndef MODULE_LICENSE
+#define MODULE_LICENSE(x)
+#endif
+
+#ifndef preempt_disable
+#define preempt_disable()
+#define preempt_enable()
+#endif
+
+#ifndef pte_offset_map
+#define pte_offset_map pte_offset
+#define pte_unmap(pte)
+#endif
+
+#ifndef module_param
+#define module_param(name, type, perm)
+#endif
+
+#ifndef list_for_each_safe
+#define list_for_each_safe(pos, n, head)				\
+	for (pos = (head)->next, n = pos->next; pos != (head);		\
+		pos = n, n = pos->next)
+#endif
+
+#ifndef list_for_each_entry
+#define list_for_each_entry(pos, head, member)				\
+       for (pos = list_entry((head)->next, typeof(*pos), member),	\
+                    prefetch(pos->member.next);				\
+            &pos->member != (head);					\
+            pos = list_entry(pos->member.next, typeof(*pos), member),	\
+                    prefetch(pos->member.next))
+#endif
+
+#ifndef list_for_each_entry_safe
+#define list_for_each_entry_safe(pos, n, head, member)                  \
+        for (pos = list_entry((head)->next, typeof(*pos), member),      \
+                n = list_entry(pos->member.next, typeof(*pos), member); \
+             &pos->member != (head);                                    \
+             pos = n, n = list_entry(n->member.next, typeof(*n), member))
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,19)
+static inline struct page *vmalloc_to_page(void *vmalloc_addr)
+{
+	unsigned long addr = (unsigned long)vmalloc_addr;
+	struct page *page = NULL;
+	pgd_t *pgd = pgd_offset_k(addr);
+	pmd_t *pmd;
+	pte_t *ptep, pte;
+
+	if (!pgd_none(*pgd)) {
+		pmd = pmd_offset(pgd, addr);
+		if (!pmd_none(*pmd)) {
+			preempt_disable();
+			ptep = pte_offset_map(pmd, addr);
+			pte = *ptep;
+			if (pte_present(pte))
+				page = pte_page(pte);
+			pte_unmap(ptep);
+			preempt_enable();
+		}
+	}
+	return page;
+}
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,4,2)
+#define down_write down
+#define up_write up
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#define DRM_PCI_DEV(pdev) &pdev->dev
+#else
+#define DRM_PCI_DEV(pdev) NULL
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static inline unsigned iminor(struct inode *inode)
+{
+	return MINOR(inode->i_rdev);
+}
+
+#define old_encode_dev(x) (x)
+
+struct drm_sysfs_class;
+struct class_simple;
+struct device;
+
+#define pci_dev_put(x) do {} while (0)
+#define pci_get_subsys pci_find_subsys
+
+static inline struct class_device *DRM(sysfs_device_add) (struct drm_sysfs_class
+							  * cs, dev_t dev,
+							  struct device *
+							  device,
+							  const char *fmt,
+							  ...) {
+	return NULL;
+}
+
+static inline void DRM(sysfs_device_remove) (dev_t dev) {
+}
+
+static inline void DRM(sysfs_destroy) (struct drm_sysfs_class * cs) {
+}
+
+static inline struct drm_sysfs_class *DRM(sysfs_create) (struct module * owner,
+							 char *name) {
+	return NULL;
+}
+
+#ifndef pci_pretty_name
+#define pci_pretty_name(x) x->name
+#endif
+
+struct drm_device;
+static inline int radeon_create_i2c_busses(struct drm_device *dev)
+{
+	return 0;
+};
+static inline void radeon_delete_i2c_busses(struct drm_device *dev)
+{
+};
+
+#endif
+
+#ifndef __user
+#define __user
+#endif
+
+#ifndef __put_page
+#define __put_page(p)           atomic_dec(&(p)->count)
+#endif
+
+#ifndef REMAP_PAGE_RANGE_5_ARGS
+#define DRM_RPR_ARG(vma)
+#else
+#define DRM_RPR_ARG(vma) vma,
+#endif
+
+#define VM_OFFSET(vma) ((vma)->vm_pgoff << PAGE_SHIFT)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
+static inline int remap_pfn_range(struct vm_area_struct *vma, unsigned long from, unsigned long pfn, unsigned long size, pgprot_t pgprot)
+{
+  return remap_page_range(DRM_RPR_ARG(vma) from, 
+			  pfn << PAGE_SHIFT,
+			  size,
+			  pgprot);
+}
+#endif
+
+/* old architectures */
+#ifdef __AMD64__
+#define __x86_64__
+#endif
+
+#endif
diff -purN linux-2.6.12.orig/drivers/char/drm/drm_context.c linux-2.6.12/drivers/char/drm/drm_context.c
--- linux-2.6.12.orig/drivers/char/drm/drm_context.c	2005-07-05 08:36:22.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/drm_context.c	2005-07-05 08:37:27.000000000 +0200
@@ -1,7 +1,7 @@
 /**
- * \file drm_context.h 
+ * \file drm_context.c
  * IOCTLs for generic contexts
- * 
+ *
  * \author Rickard E. (Rik) Faith <faith@valinux.com>
  * \author Gareth Hughes <gareth@valinux.com>
  */
@@ -56,25 +56,26 @@
  * in drm_device::context_sareas, while holding the drm_device::struct_sem
  * lock.
  */
-void drm_ctxbitmap_free( drm_device_t *dev, int ctx_handle )
+void drm_ctxbitmap_free(drm_device_t * dev, int ctx_handle)
 {
-	if ( ctx_handle < 0 ) goto failed;
-	if ( !dev->ctx_bitmap ) goto failed;
+	if (ctx_handle < 0)
+		goto failed;
+	if (!dev->ctx_bitmap)
+		goto failed;
 
-	if ( ctx_handle < DRM_MAX_CTXBITMAP ) {
+	if (ctx_handle < DRM_MAX_CTXBITMAP) {
 		down(&dev->struct_sem);
-		clear_bit( ctx_handle, dev->ctx_bitmap );
+		clear_bit(ctx_handle, dev->ctx_bitmap);
 		dev->context_sareas[ctx_handle] = NULL;
 		up(&dev->struct_sem);
 		return;
 	}
-failed:
-       	DRM_ERROR( "Attempt to free invalid context handle: %d\n",
-		   ctx_handle );
-       	return;
+      failed:
+	DRM_ERROR("Attempt to free invalid context handle: %d\n", ctx_handle);
+	return;
 }
 
-/** 
+/**
  * Context bitmap allocation.
  *
  * \param dev DRM device.
@@ -84,29 +85,33 @@ failed:
  * drm_device::context_sareas to accommodate the new entry while holding the
  * drm_device::struct_sem lock.
  */
-int drm_ctxbitmap_next( drm_device_t *dev )
+static int drm_ctxbitmap_next(drm_device_t * dev)
 {
 	int bit;
 
-	if(!dev->ctx_bitmap) return -1;
+	if (!dev->ctx_bitmap)
+		return -1;
 
 	down(&dev->struct_sem);
-	bit = find_first_zero_bit( dev->ctx_bitmap, DRM_MAX_CTXBITMAP );
-	if ( bit < DRM_MAX_CTXBITMAP ) {
-		set_bit( bit, dev->ctx_bitmap );
-	   	DRM_DEBUG( "drm_ctxbitmap_next bit : %d\n", bit );
-		if((bit+1) > dev->max_context) {
-			dev->max_context = (bit+1);
-			if(dev->context_sareas) {
+	bit = find_first_zero_bit(dev->ctx_bitmap, DRM_MAX_CTXBITMAP);
+	if (bit < DRM_MAX_CTXBITMAP) {
+		set_bit(bit, dev->ctx_bitmap);
+		DRM_DEBUG("drm_ctxbitmap_next bit : %d\n", bit);
+		if ((bit + 1) > dev->max_context) {
+			dev->max_context = (bit + 1);
+			if (dev->context_sareas) {
 				drm_map_t **ctx_sareas;
 
 				ctx_sareas = drm_realloc(dev->context_sareas,
-						(dev->max_context - 1) * 
-						sizeof(*dev->context_sareas),
-						dev->max_context * 
-						sizeof(*dev->context_sareas),
-						DRM_MEM_MAPS);
-				if(!ctx_sareas) {
+							 (dev->max_context -
+							  1) *
+							 sizeof(*dev->
+								context_sareas),
+							 dev->max_context *
+							 sizeof(*dev->
+								context_sareas),
+							 DRM_MEM_MAPS);
+				if (!ctx_sareas) {
 					clear_bit(bit, dev->ctx_bitmap);
 					up(&dev->struct_sem);
 					return -1;
@@ -115,11 +120,11 @@ int drm_ctxbitmap_next( drm_device_t *de
 				dev->context_sareas[bit] = NULL;
 			} else {
 				/* max_context == 1 at this point */
-				dev->context_sareas = drm_alloc(
-						dev->max_context * 
-						sizeof(*dev->context_sareas),
-						DRM_MEM_MAPS);
-				if(!dev->context_sareas) {
+				dev->context_sareas =
+				    drm_alloc(dev->max_context *
+					      sizeof(*dev->context_sareas),
+					      DRM_MEM_MAPS);
+				if (!dev->context_sareas) {
 					clear_bit(bit, dev->ctx_bitmap);
 					up(&dev->struct_sem);
 					return -1;
@@ -142,26 +147,26 @@ int drm_ctxbitmap_next( drm_device_t *de
  * Allocates and initialize drm_device::ctx_bitmap and drm_device::context_sareas, while holding
  * the drm_device::struct_sem lock.
  */
-int drm_ctxbitmap_init( drm_device_t *dev )
+int drm_ctxbitmap_init(drm_device_t * dev)
 {
 	int i;
-   	int temp;
+	int temp;
 
 	down(&dev->struct_sem);
-	dev->ctx_bitmap = (unsigned long *) drm_alloc( PAGE_SIZE,
-							DRM_MEM_CTXBITMAP );
-	if ( dev->ctx_bitmap == NULL ) {
+	dev->ctx_bitmap = (unsigned long *)drm_alloc(PAGE_SIZE,
+						     DRM_MEM_CTXBITMAP);
+	if (dev->ctx_bitmap == NULL) {
 		up(&dev->struct_sem);
 		return -ENOMEM;
 	}
-	memset( (void *)dev->ctx_bitmap, 0, PAGE_SIZE );
+	memset((void *)dev->ctx_bitmap, 0, PAGE_SIZE);
 	dev->context_sareas = NULL;
 	dev->max_context = -1;
 	up(&dev->struct_sem);
 
-	for ( i = 0 ; i < DRM_RESERVED_CONTEXTS ; i++ ) {
-		temp = drm_ctxbitmap_next( dev );
-	   	DRM_DEBUG( "drm_ctxbitmap_init : %d\n", temp );
+	for (i = 0; i < DRM_RESERVED_CONTEXTS; i++) {
+		temp = drm_ctxbitmap_next(dev);
+		DRM_DEBUG("drm_ctxbitmap_init : %d\n", temp);
 	}
 
 	return 0;
@@ -175,14 +180,14 @@ int drm_ctxbitmap_init( drm_device_t *de
  * Frees drm_device::ctx_bitmap and drm_device::context_sareas, while holding
  * the drm_device::struct_sem lock.
  */
-void drm_ctxbitmap_cleanup( drm_device_t *dev )
+void drm_ctxbitmap_cleanup(drm_device_t * dev)
 {
 	down(&dev->struct_sem);
-	if( dev->context_sareas ) drm_free( dev->context_sareas,
-					     sizeof(*dev->context_sareas) * 
-					     dev->max_context,
-					     DRM_MEM_MAPS );
-	drm_free( (void *)dev->ctx_bitmap, PAGE_SIZE, DRM_MEM_CTXBITMAP );
+	if (dev->context_sareas)
+		drm_free(dev->context_sareas,
+			 sizeof(*dev->context_sareas) *
+			 dev->max_context, DRM_MEM_MAPS);
+	drm_free((void *)dev->ctx_bitmap, PAGE_SIZE, DRM_MEM_CTXBITMAP);
 	up(&dev->struct_sem);
 }
 
@@ -194,7 +199,7 @@ void drm_ctxbitmap_cleanup( drm_device_t
 
 /**
  * Get per-context SAREA.
- * 
+ *
  * \param inode device inode.
  * \param filp file pointer.
  * \param cmd command.
@@ -205,10 +210,10 @@ void drm_ctxbitmap_cleanup( drm_device_t
  * returns its handle.
  */
 int drm_getsareactx(struct inode *inode, struct file *filp,
-		     unsigned int cmd, unsigned long arg)
+		    unsigned int cmd, unsigned long arg)
 {
-	drm_file_t	*priv	= filp->private_data;
-	drm_device_t	*dev	= priv->head->dev;
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
 	drm_ctx_priv_map_t __user *argp = (void __user *)arg;
 	drm_ctx_priv_map_t request;
 	drm_map_t *map;
@@ -217,7 +222,8 @@ int drm_getsareactx(struct inode *inode,
 		return -EFAULT;
 
 	down(&dev->struct_sem);
-	if (dev->max_context < 0 || request.ctx_id >= (unsigned) dev->max_context) {
+	if (dev->max_context < 0
+	    || request.ctx_id >= (unsigned)dev->max_context) {
 		up(&dev->struct_sem);
 		return -EINVAL;
 	}
@@ -225,7 +231,7 @@ int drm_getsareactx(struct inode *inode,
 	map = dev->context_sareas[request.ctx_id];
 	up(&dev->struct_sem);
 
-	request.handle = (void *) map->offset;
+	request.handle = map->handle;
 	if (copy_to_user(argp, &request, sizeof(request)))
 		return -EFAULT;
 	return 0;
@@ -233,7 +239,7 @@ int drm_getsareactx(struct inode *inode,
 
 /**
  * Set per-context SAREA.
- * 
+ *
  * \param inode device inode.
  * \param filp file pointer.
  * \param cmd command.
@@ -244,37 +250,36 @@ int drm_getsareactx(struct inode *inode,
  * drm_device::context_sareas with it.
  */
 int drm_setsareactx(struct inode *inode, struct file *filp,
-		     unsigned int cmd, unsigned long arg)
+		    unsigned int cmd, unsigned long arg)
 {
-	drm_file_t	*priv	= filp->private_data;
-	drm_device_t	*dev	= priv->head->dev;
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
 	drm_ctx_priv_map_t request;
 	drm_map_t *map = NULL;
 	drm_map_list_t *r_list = NULL;
 	struct list_head *list;
 
 	if (copy_from_user(&request,
-			   (drm_ctx_priv_map_t __user *)arg,
-			   sizeof(request)))
+			   (drm_ctx_priv_map_t __user *) arg, sizeof(request)))
 		return -EFAULT;
 
 	down(&dev->struct_sem);
 	list_for_each(list, &dev->maplist->head) {
 		r_list = list_entry(list, drm_map_list_t, head);
-		if (r_list->map
-		    && r_list->map->offset == (unsigned long) request.handle)
+		if (r_list->map && r_list->map->handle == request.handle)
 			goto found;
 	}
-bad:
+      bad:
 	up(&dev->struct_sem);
 	return -EINVAL;
 
-found:
+      found:
 	map = r_list->map;
-	if (!map) goto bad;
+	if (!map)
+		goto bad;
 	if (dev->max_context < 0)
 		goto bad;
-	if (request.ctx_id >= (unsigned) dev->max_context)
+	if (request.ctx_id >= (unsigned)dev->max_context)
 		goto bad;
 	dev->context_sareas[request.ctx_id] = map;
 	up(&dev->struct_sem);
@@ -297,22 +302,21 @@ found:
  *
  * Attempt to set drm_device::context_flag.
  */
-int drm_context_switch( drm_device_t *dev, int old, int new )
+static int drm_context_switch(drm_device_t * dev, int old, int new)
 {
-        if ( test_and_set_bit( 0, &dev->context_flag ) ) {
-                DRM_ERROR( "Reentering -- FIXME\n" );
-                return -EBUSY;
-        }
-
+	if (test_and_set_bit(0, &dev->context_flag)) {
+		DRM_ERROR("Reentering -- FIXME\n");
+		return -EBUSY;
+	}
 
-        DRM_DEBUG( "Context switch from %d to %d\n", old, new );
+	DRM_DEBUG("Context switch from %d to %d\n", old, new);
 
-        if ( new == dev->last_context ) {
-                clear_bit( 0, &dev->context_flag );
-                return 0;
-        }
+	if (new == dev->last_context) {
+		clear_bit(0, &dev->context_flag);
+		return 0;
+	}
 
-        return 0;
+	return 0;
 }
 
 /**
@@ -326,22 +330,22 @@ int drm_context_switch( drm_device_t *de
  * hardware lock is held, clears the drm_device::context_flag and wakes up
  * drm_device::context_wait.
  */
-int drm_context_switch_complete( drm_device_t *dev, int new )
+int drm_context_switch_complete(drm_device_t * dev, int new)
 {
-        dev->last_context = new;  /* PRE/POST: This is the _only_ writer. */
-        dev->last_switch  = jiffies;
+	dev->last_context = new;	/* PRE/POST: This is the _only_ writer. */
+	dev->last_switch = jiffies;
 
-        if ( !_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock) ) {
-                DRM_ERROR( "Lock isn't held after context switch\n" );
-        }
-
-				/* If a context switch is ever initiated
-                                   when the kernel holds the lock, release
-                                   that lock here. */
-        clear_bit( 0, &dev->context_flag );
-        wake_up( &dev->context_wait );
+	if (!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
+		DRM_ERROR("Lock isn't held after context switch\n");
+	}
+
+	/* If a context switch is ever initiated
+	   when the kernel holds the lock, release
+	   that lock here. */
+	clear_bit(0, &dev->context_flag);
+	wake_up(&dev->context_wait);
 
-        return 0;
+	return 0;
 }
 
 /**
@@ -353,29 +357,28 @@ int drm_context_switch_complete( drm_dev
  * \param arg user argument pointing to a drm_ctx_res structure.
  * \return zero on success or a negative number on failure.
  */
-int drm_resctx( struct inode *inode, struct file *filp,
-		 unsigned int cmd, unsigned long arg )
+int drm_resctx(struct inode *inode, struct file *filp,
+	       unsigned int cmd, unsigned long arg)
 {
 	drm_ctx_res_t res;
 	drm_ctx_t __user *argp = (void __user *)arg;
 	drm_ctx_t ctx;
 	int i;
 
-	if ( copy_from_user( &res, argp, sizeof(res) ) )
+	if (copy_from_user(&res, argp, sizeof(res)))
 		return -EFAULT;
 
-	if ( res.count >= DRM_RESERVED_CONTEXTS ) {
-		memset( &ctx, 0, sizeof(ctx) );
-		for ( i = 0 ; i < DRM_RESERVED_CONTEXTS ; i++ ) {
+	if (res.count >= DRM_RESERVED_CONTEXTS) {
+		memset(&ctx, 0, sizeof(ctx));
+		for (i = 0; i < DRM_RESERVED_CONTEXTS; i++) {
 			ctx.handle = i;
-			if ( copy_to_user( &res.contexts[i],
-					   &i, sizeof(i) ) )
+			if (copy_to_user(&res.contexts[i], &i, sizeof(i)))
 				return -EFAULT;
 		}
 	}
 	res.count = DRM_RESERVED_CONTEXTS;
 
-	if ( copy_to_user( argp, &res, sizeof(res) ) )
+	if (copy_to_user(argp, &res, sizeof(res)))
 		return -EFAULT;
 	return 0;
 }
@@ -391,58 +394,57 @@ int drm_resctx( struct inode *inode, str
  *
  * Get a new handle for the context and copy to userspace.
  */
-int drm_addctx( struct inode *inode, struct file *filp,
-		 unsigned int cmd, unsigned long arg )
+int drm_addctx(struct inode *inode, struct file *filp,
+	       unsigned int cmd, unsigned long arg)
 {
 	drm_file_t *priv = filp->private_data;
 	drm_device_t *dev = priv->head->dev;
-	drm_ctx_list_t * ctx_entry;
+	drm_ctx_list_t *ctx_entry;
 	drm_ctx_t __user *argp = (void __user *)arg;
 	drm_ctx_t ctx;
 
-	if ( copy_from_user( &ctx, argp, sizeof(ctx) ) )
+	if (copy_from_user(&ctx, argp, sizeof(ctx)))
 		return -EFAULT;
 
-	ctx.handle = drm_ctxbitmap_next( dev );
-	if ( ctx.handle == DRM_KERNEL_CONTEXT ) {
-				/* Skip kernel's context and get a new one. */
-		ctx.handle = drm_ctxbitmap_next( dev );
-	}
-	DRM_DEBUG( "%d\n", ctx.handle );
-	if ( ctx.handle == -1 ) {
-		DRM_DEBUG( "Not enough free contexts.\n" );
-				/* Should this return -EBUSY instead? */
+	ctx.handle = drm_ctxbitmap_next(dev);
+	if (ctx.handle == DRM_KERNEL_CONTEXT) {
+		/* Skip kernel's context and get a new one. */
+		ctx.handle = drm_ctxbitmap_next(dev);
+	}
+	DRM_DEBUG("%d\n", ctx.handle);
+	if (ctx.handle == -1) {
+		DRM_DEBUG("Not enough free contexts.\n");
+		/* Should this return -EBUSY instead? */
 		return -ENOMEM;
 	}
 
-	if ( ctx.handle != DRM_KERNEL_CONTEXT )
-	{
+	if (ctx.handle != DRM_KERNEL_CONTEXT) {
 		if (dev->driver->context_ctor)
 			dev->driver->context_ctor(dev, ctx.handle);
 	}
 
-	ctx_entry = drm_alloc( sizeof(*ctx_entry), DRM_MEM_CTXLIST );
-	if ( !ctx_entry ) {
+	ctx_entry = drm_alloc(sizeof(*ctx_entry), DRM_MEM_CTXLIST);
+	if (!ctx_entry) {
 		DRM_DEBUG("out of memory\n");
 		return -ENOMEM;
 	}
 
-	INIT_LIST_HEAD( &ctx_entry->head );
+	INIT_LIST_HEAD(&ctx_entry->head);
 	ctx_entry->handle = ctx.handle;
 	ctx_entry->tag = priv;
 
-	down( &dev->ctxlist_sem );
-	list_add( &ctx_entry->head, &dev->ctxlist->head );
+	down(&dev->ctxlist_sem);
+	list_add(&ctx_entry->head, &dev->ctxlist->head);
 	++dev->ctx_count;
-	up( &dev->ctxlist_sem );
+	up(&dev->ctxlist_sem);
 
-	if ( copy_to_user( argp, &ctx, sizeof(ctx) ) )
+	if (copy_to_user(argp, &ctx, sizeof(ctx)))
 		return -EFAULT;
 	return 0;
 }
 
-int drm_modctx( struct inode *inode, struct file *filp,
-		 unsigned int cmd, unsigned long arg )
+int drm_modctx(struct inode *inode, struct file *filp,
+	       unsigned int cmd, unsigned long arg)
 {
 	/* This does nothing */
 	return 0;
@@ -457,19 +459,19 @@ int drm_modctx( struct inode *inode, str
  * \param arg user argument pointing to a drm_ctx structure.
  * \return zero on success or a negative number on failure.
  */
-int drm_getctx( struct inode *inode, struct file *filp,
-		 unsigned int cmd, unsigned long arg )
+int drm_getctx(struct inode *inode, struct file *filp,
+	       unsigned int cmd, unsigned long arg)
 {
 	drm_ctx_t __user *argp = (void __user *)arg;
 	drm_ctx_t ctx;
 
-	if ( copy_from_user( &ctx, argp, sizeof(ctx) ) )
+	if (copy_from_user(&ctx, argp, sizeof(ctx)))
 		return -EFAULT;
 
 	/* This is 0, because we don't handle any context flags */
 	ctx.flags = 0;
 
-	if ( copy_to_user( argp, &ctx, sizeof(ctx) ) )
+	if (copy_to_user(argp, &ctx, sizeof(ctx)))
 		return -EFAULT;
 	return 0;
 }
@@ -485,18 +487,18 @@ int drm_getctx( struct inode *inode, str
  *
  * Calls context_switch().
  */
-int drm_switchctx( struct inode *inode, struct file *filp,
-		    unsigned int cmd, unsigned long arg )
+int drm_switchctx(struct inode *inode, struct file *filp,
+		  unsigned int cmd, unsigned long arg)
 {
 	drm_file_t *priv = filp->private_data;
 	drm_device_t *dev = priv->head->dev;
 	drm_ctx_t ctx;
 
-	if ( copy_from_user( &ctx, (drm_ctx_t __user *)arg, sizeof(ctx) ) )
+	if (copy_from_user(&ctx, (drm_ctx_t __user *) arg, sizeof(ctx)))
 		return -EFAULT;
 
-	DRM_DEBUG( "%d\n", ctx.handle );
-	return drm_context_switch( dev, dev->last_context, ctx.handle );
+	DRM_DEBUG("%d\n", ctx.handle);
+	return drm_context_switch(dev, dev->last_context, ctx.handle);
 }
 
 /**
@@ -510,18 +512,18 @@ int drm_switchctx( struct inode *inode, 
  *
  * Calls context_switch_complete().
  */
-int drm_newctx( struct inode *inode, struct file *filp,
-		 unsigned int cmd, unsigned long arg )
+int drm_newctx(struct inode *inode, struct file *filp,
+	       unsigned int cmd, unsigned long arg)
 {
 	drm_file_t *priv = filp->private_data;
 	drm_device_t *dev = priv->head->dev;
 	drm_ctx_t ctx;
 
-	if ( copy_from_user( &ctx, (drm_ctx_t __user *)arg, sizeof(ctx) ) )
+	if (copy_from_user(&ctx, (drm_ctx_t __user *) arg, sizeof(ctx)))
 		return -EFAULT;
 
-	DRM_DEBUG( "%d\n", ctx.handle );
-	drm_context_switch_complete( dev, ctx.handle );
+	DRM_DEBUG("%d\n", ctx.handle);
+	drm_context_switch_complete(dev, ctx.handle);
 
 	return 0;
 }
@@ -537,42 +539,41 @@ int drm_newctx( struct inode *inode, str
  *
  * If not the special kernel context, calls ctxbitmap_free() to free the specified context.
  */
-int drm_rmctx( struct inode *inode, struct file *filp,
-		unsigned int cmd, unsigned long arg )
+int drm_rmctx(struct inode *inode, struct file *filp,
+	      unsigned int cmd, unsigned long arg)
 {
 	drm_file_t *priv = filp->private_data;
 	drm_device_t *dev = priv->head->dev;
 	drm_ctx_t ctx;
 
-	if ( copy_from_user( &ctx, (drm_ctx_t __user *)arg, sizeof(ctx) ) )
+	if (copy_from_user(&ctx, (drm_ctx_t __user *) arg, sizeof(ctx)))
 		return -EFAULT;
 
-	DRM_DEBUG( "%d\n", ctx.handle );
-	if ( ctx.handle == DRM_KERNEL_CONTEXT + 1 ) {
+	DRM_DEBUG("%d\n", ctx.handle);
+	if (ctx.handle == DRM_KERNEL_CONTEXT + 1) {
 		priv->remove_auth_on_close = 1;
 	}
-	if ( ctx.handle != DRM_KERNEL_CONTEXT ) {
+	if (ctx.handle != DRM_KERNEL_CONTEXT) {
 		if (dev->driver->context_dtor)
 			dev->driver->context_dtor(dev, ctx.handle);
-		drm_ctxbitmap_free( dev, ctx.handle );
+		drm_ctxbitmap_free(dev, ctx.handle);
 	}
 
-	down( &dev->ctxlist_sem );
-	if ( !list_empty( &dev->ctxlist->head ) ) {
+	down(&dev->ctxlist_sem);
+	if (!list_empty(&dev->ctxlist->head)) {
 		drm_ctx_list_t *pos, *n;
 
-		list_for_each_entry_safe( pos, n, &dev->ctxlist->head, head ) {
-			if ( pos->handle == ctx.handle ) {
-				list_del( &pos->head );
-				drm_free( pos, sizeof(*pos), DRM_MEM_CTXLIST );
+		list_for_each_entry_safe(pos, n, &dev->ctxlist->head, head) {
+			if (pos->handle == ctx.handle) {
+				list_del(&pos->head);
+				drm_free(pos, sizeof(*pos), DRM_MEM_CTXLIST);
 				--dev->ctx_count;
 			}
 		}
 	}
-	up( &dev->ctxlist_sem );
+	up(&dev->ctxlist_sem);
 
 	return 0;
 }
 
 /*@}*/
-
diff -purN linux-2.6.12.orig/drivers/char/drm/drm_core.h linux-2.6.12/drivers/char/drm/drm_core.h
--- linux-2.6.12.orig/drivers/char/drm/drm_core.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/drm_core.h	2005-07-05 08:37:30.000000000 +0200
@@ -1,5 +1,7 @@
 /*
  * Copyright 2004 Jon Smirl <jonsmirl@gmail.com>
+ * Copyright 1998-2003 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2003 S3 Graphics, Inc. All Rights Reserved.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -20,6 +22,7 @@
  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  * DEALINGS IN THE SOFTWARE.
  */
+
 #define CORE_AUTHOR		"Gareth Hughes, Leif Delgass, Jos Fonseca, Jon Smirl"
 
 #define CORE_NAME		"drm"
diff -purN linux-2.6.12.orig/drivers/char/drm/drm_dma.c linux-2.6.12/drivers/char/drm/drm_dma.c
--- linux-2.6.12.orig/drivers/char/drm/drm_dma.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/drm_dma.c	2005-07-05 08:37:27.000000000 +0200
@@ -1,5 +1,5 @@
 /**
- * \file drm_dma.h 
+ * \file drm_dma.c
  * DMA IOCTL and function support
  *
  * \author Rickard E. (Rik) Faith <faith@valinux.com>
@@ -37,23 +37,23 @@
 
 /**
  * Initialize the DMA data.
- * 
+ *
  * \param dev DRM device.
  * \return zero on success or a negative value on failure.
  *
  * Allocate and initialize a drm_device_dma structure.
  */
-int drm_dma_setup( drm_device_t *dev )
+int drm_dma_setup(drm_device_t * dev)
 {
 	int i;
 
-	dev->dma = drm_alloc( sizeof(*dev->dma), DRM_MEM_DRIVER );
-	if ( !dev->dma )
+	dev->dma = drm_alloc(sizeof(*dev->dma), DRM_MEM_DRIVER);
+	if (!dev->dma)
 		return -ENOMEM;
 
-	memset( dev->dma, 0, sizeof(*dev->dma) );
+	memset(dev->dma, 0, sizeof(*dev->dma));
 
-	for ( i = 0 ; i <= DRM_MAX_ORDER ; i++ )
+	for (i = 0; i <= DRM_MAX_ORDER; i++)
 		memset(&dev->dma->bufs[i], 0, sizeof(dev->dma->bufs[0]));
 
 	return 0;
@@ -67,14 +67,15 @@ int drm_dma_setup( drm_device_t *dev )
  * Free all pages associated with DMA buffers, the buffers and pages lists, and
  * finally the the drm_device::dma structure itself.
  */
-void drm_dma_takedown(drm_device_t *dev)
+void drm_dma_takedown(drm_device_t * dev)
 {
-	drm_device_dma_t  *dma = dev->dma;
-	int		  i, j;
+	drm_device_dma_t *dma = dev->dma;
+	int i, j;
 
-	if (!dma) return;
+	if (!dma)
+		return;
 
-				/* Clear dma buffers */
+	/* Clear dma buffers */
 	for (i = 0; i <= DRM_MAX_ORDER; i++) {
 		if (dma->bufs[i].seg_count) {
 			DRM_DEBUG("order %d: buf_count = %d,"
@@ -85,64 +86,63 @@ void drm_dma_takedown(drm_device_t *dev)
 			for (j = 0; j < dma->bufs[i].seg_count; j++) {
 				if (dma->bufs[i].seglist[j]) {
 					drm_free_pages(dma->bufs[i].seglist[j],
-							dma->bufs[i].page_order,
-							DRM_MEM_DMA);
+						       dma->bufs[i].page_order,
+						       DRM_MEM_DMA);
 				}
 			}
 			drm_free(dma->bufs[i].seglist,
-				  dma->bufs[i].seg_count
-				  * sizeof(*dma->bufs[0].seglist),
-				  DRM_MEM_SEGS);
+				 dma->bufs[i].seg_count
+				 * sizeof(*dma->bufs[0].seglist), DRM_MEM_SEGS);
 		}
-	   	if (dma->bufs[i].buf_count) {
-		   	for (j = 0; j < dma->bufs[i].buf_count; j++) {
+		if (dma->bufs[i].buf_count) {
+			for (j = 0; j < dma->bufs[i].buf_count; j++) {
 				if (dma->bufs[i].buflist[j].dev_private) {
-					drm_free(dma->bufs[i].buflist[j].dev_private,
-						  dma->bufs[i].buflist[j].dev_priv_size,
-						  DRM_MEM_BUFS);
+					drm_free(dma->bufs[i].buflist[j].
+						 dev_private,
+						 dma->bufs[i].buflist[j].
+						 dev_priv_size, DRM_MEM_BUFS);
 				}
 			}
-		   	drm_free(dma->bufs[i].buflist,
-				  dma->bufs[i].buf_count *
-				  sizeof(*dma->bufs[0].buflist),
-				  DRM_MEM_BUFS);
+			drm_free(dma->bufs[i].buflist,
+				 dma->bufs[i].buf_count *
+				 sizeof(*dma->bufs[0].buflist), DRM_MEM_BUFS);
 		}
 	}
 
 	if (dma->buflist) {
 		drm_free(dma->buflist,
-			  dma->buf_count * sizeof(*dma->buflist),
-			  DRM_MEM_BUFS);
+			 dma->buf_count * sizeof(*dma->buflist), DRM_MEM_BUFS);
 	}
 
 	if (dma->pagelist) {
 		drm_free(dma->pagelist,
-			  dma->page_count * sizeof(*dma->pagelist),
-			  DRM_MEM_PAGES);
+			 dma->page_count * sizeof(*dma->pagelist),
+			 DRM_MEM_PAGES);
 	}
 	drm_free(dev->dma, sizeof(*dev->dma), DRM_MEM_DRIVER);
 	dev->dma = NULL;
 }
 
-
 /**
  * Free a buffer.
  *
  * \param dev DRM device.
  * \param buf buffer to free.
- * 
+ *
  * Resets the fields of \p buf.
  */
-void drm_free_buffer(drm_device_t *dev, drm_buf_t *buf)
+void drm_free_buffer(drm_device_t * dev, drm_buf_t * buf)
 {
-	if (!buf) return;
+	if (!buf)
+		return;
 
-	buf->waiting  = 0;
-	buf->pending  = 0;
-	buf->filp     = NULL;
-	buf->used     = 0;
+	buf->waiting = 0;
+	buf->pending = 0;
+	buf->filp = NULL;
+	buf->used = 0;
 
-	if (drm_core_check_feature(dev, DRIVER_DMA_QUEUE) && waitqueue_active(&buf->dma_wait)) {
+	if (drm_core_check_feature(dev, DRIVER_DMA_QUEUE)
+	    && waitqueue_active(&buf->dma_wait)) {
 		wake_up_interruptible(&buf->dma_wait);
 	}
 }
@@ -157,9 +157,10 @@ void drm_free_buffer(drm_device_t *dev, 
 void drm_core_reclaim_buffers(drm_device_t *dev, struct file *filp)
 {
 	drm_device_dma_t *dma = dev->dma;
-	int		 i;
+	int i;
 
-	if (!dma) return;
+	if (!dma)
+		return;
 	for (i = 0; i < dma->buf_count; i++) {
 		if (dma->buflist[i]->filp == filp) {
 			switch (dma->buflist[i]->list) {
@@ -177,4 +178,3 @@ void drm_core_reclaim_buffers(drm_device
 	}
 }
 EXPORT_SYMBOL(drm_core_reclaim_buffers);
-
diff -purN linux-2.6.12.orig/drivers/char/drm/drm_drawable.c linux-2.6.12/drivers/char/drm/drm_drawable.c
--- linux-2.6.12.orig/drivers/char/drm/drm_drawable.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/drm_drawable.c	2005-07-05 08:37:27.000000000 +0200
@@ -1,5 +1,5 @@
 /**
- * \file drm_drawable.h 
+ * \file drm_drawable.c
  * IOCTLs for drawables
  *
  * \author Rickard E. (Rik) Faith <faith@valinux.com>
@@ -37,20 +37,20 @@
 
 /** No-op. */
 int drm_adddraw(struct inode *inode, struct file *filp,
-		 unsigned int cmd, unsigned long arg)
+		unsigned int cmd, unsigned long arg)
 {
 	drm_draw_t draw;
 
 	draw.handle = 0;	/* NOOP */
 	DRM_DEBUG("%d\n", draw.handle);
-	if (copy_to_user((drm_draw_t __user *)arg, &draw, sizeof(draw)))
+	if (copy_to_user((drm_draw_t __user *) arg, &draw, sizeof(draw)))
 		return -EFAULT;
 	return 0;
 }
 
 /** No-op. */
 int drm_rmdraw(struct inode *inode, struct file *filp,
-		unsigned int cmd, unsigned long arg)
+	       unsigned int cmd, unsigned long arg)
 {
 	return 0;		/* NOOP */
 }
diff -purN linux-2.6.12.orig/drivers/char/drm/drm_drv.c linux-2.6.12/drivers/char/drm/drm_drv.c
--- linux-2.6.12.orig/drivers/char/drm/drm_drv.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/drm_drv.c	2005-07-05 08:37:27.000000000 +0200
@@ -1,5 +1,5 @@
 /**
- * \file drm_drv.h 
+ * \file drm_drv.c
  * Generic driver template
  *
  * \author Rickard E. (Rik) Faith <faith@valinux.com>
@@ -47,72 +47,78 @@
  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  * OTHER DEALINGS IN THE SOFTWARE.
  */
-
 #include "drmP.h"
 #include "drm_core.h"
 
+static void __exit drm_cleanup(drm_device_t * dev);
+int drm_fb_loaded = 0;
+
+static int drm_version(struct inode *inode, struct file *filp,
+		unsigned int cmd, unsigned long arg);
+
 /** Ioctl table */
-drm_ioctl_desc_t		  drm_ioctls[] = {
-	[DRM_IOCTL_NR(DRM_IOCTL_VERSION)]       = { drm_version,     0, 0 },
-	[DRM_IOCTL_NR(DRM_IOCTL_GET_UNIQUE)]    = { drm_getunique,   0, 0 },
-	[DRM_IOCTL_NR(DRM_IOCTL_GET_MAGIC)]     = { drm_getmagic,    0, 0 },
-	[DRM_IOCTL_NR(DRM_IOCTL_IRQ_BUSID)]     = { drm_irq_by_busid, 0, 1 },
-	[DRM_IOCTL_NR(DRM_IOCTL_GET_MAP)]       = { drm_getmap,      0, 0 },
-	[DRM_IOCTL_NR(DRM_IOCTL_GET_CLIENT)]    = { drm_getclient,   0, 0 },
-	[DRM_IOCTL_NR(DRM_IOCTL_GET_STATS)]     = { drm_getstats,    0, 0 },
-	[DRM_IOCTL_NR(DRM_IOCTL_SET_VERSION)]   = { drm_setversion,  0, 1 },
-
-	[DRM_IOCTL_NR(DRM_IOCTL_SET_UNIQUE)]    = { drm_setunique,   1, 1 },
-	[DRM_IOCTL_NR(DRM_IOCTL_BLOCK)]         = { drm_noop,        1, 1 },
-	[DRM_IOCTL_NR(DRM_IOCTL_UNBLOCK)]       = { drm_noop,        1, 1 },
-	[DRM_IOCTL_NR(DRM_IOCTL_AUTH_MAGIC)]    = { drm_authmagic,   1, 1 },
-
-	[DRM_IOCTL_NR(DRM_IOCTL_ADD_MAP)]       = { drm_addmap,      1, 1 },
-	[DRM_IOCTL_NR(DRM_IOCTL_RM_MAP)]        = { drm_rmmap,       1, 0 },
-
-	[DRM_IOCTL_NR(DRM_IOCTL_SET_SAREA_CTX)] = { drm_setsareactx, 1, 1 },
-	[DRM_IOCTL_NR(DRM_IOCTL_GET_SAREA_CTX)] = { drm_getsareactx, 1, 0 },
-
-	[DRM_IOCTL_NR(DRM_IOCTL_ADD_CTX)]       = { drm_addctx,      1, 1 },
-	[DRM_IOCTL_NR(DRM_IOCTL_RM_CTX)]        = { drm_rmctx,       1, 1 },
-	[DRM_IOCTL_NR(DRM_IOCTL_MOD_CTX)]       = { drm_modctx,      1, 1 },
-	[DRM_IOCTL_NR(DRM_IOCTL_GET_CTX)]       = { drm_getctx,      1, 0 },
-	[DRM_IOCTL_NR(DRM_IOCTL_SWITCH_CTX)]    = { drm_switchctx,   1, 1 },
-	[DRM_IOCTL_NR(DRM_IOCTL_NEW_CTX)]       = { drm_newctx,      1, 1 },
-	[DRM_IOCTL_NR(DRM_IOCTL_RES_CTX)]       = { drm_resctx,      1, 0 },
-
-	[DRM_IOCTL_NR(DRM_IOCTL_ADD_DRAW)]      = { drm_adddraw,     1, 1 },
-	[DRM_IOCTL_NR(DRM_IOCTL_RM_DRAW)]       = { drm_rmdraw,      1, 1 },
-
-	[DRM_IOCTL_NR(DRM_IOCTL_LOCK)]	        = { drm_lock,        1, 0 },
-	[DRM_IOCTL_NR(DRM_IOCTL_UNLOCK)]        = { drm_unlock,      1, 0 },
-
-	[DRM_IOCTL_NR(DRM_IOCTL_FINISH)]        = { drm_noop,      1, 0 },
-
-	[DRM_IOCTL_NR(DRM_IOCTL_ADD_BUFS)]      = { drm_addbufs,     1, 1 },
-	[DRM_IOCTL_NR(DRM_IOCTL_MARK_BUFS)]     = { drm_markbufs,    1, 1 },
-	[DRM_IOCTL_NR(DRM_IOCTL_INFO_BUFS)]     = { drm_infobufs,    1, 0 },
-	[DRM_IOCTL_NR(DRM_IOCTL_MAP_BUFS)]      = { drm_mapbufs,     1, 0 },
-	[DRM_IOCTL_NR(DRM_IOCTL_FREE_BUFS)]     = { drm_freebufs,    1, 0 },
+drm_ioctl_desc_t drm_ioctls[] = {
+	[DRM_IOCTL_NR(DRM_IOCTL_VERSION)] = {drm_version, 0, 0},
+	[DRM_IOCTL_NR(DRM_IOCTL_GET_UNIQUE)] = {drm_getunique, 0, 0},
+	[DRM_IOCTL_NR(DRM_IOCTL_GET_MAGIC)] = {drm_getmagic, 0, 0},
+	[DRM_IOCTL_NR(DRM_IOCTL_IRQ_BUSID)] = {drm_irq_by_busid, 0, 1},
+	[DRM_IOCTL_NR(DRM_IOCTL_GET_MAP)] = {drm_getmap, 0, 0},
+	[DRM_IOCTL_NR(DRM_IOCTL_GET_CLIENT)] = {drm_getclient, 0, 0},
+	[DRM_IOCTL_NR(DRM_IOCTL_GET_STATS)] = {drm_getstats, 0, 0},
+	[DRM_IOCTL_NR(DRM_IOCTL_SET_VERSION)] = {drm_setversion, 0, 1},
+
+	[DRM_IOCTL_NR(DRM_IOCTL_SET_UNIQUE)] = {drm_setunique, 1, 1},
+	[DRM_IOCTL_NR(DRM_IOCTL_BLOCK)] = {drm_noop, 1, 1},
+	[DRM_IOCTL_NR(DRM_IOCTL_UNBLOCK)] = {drm_noop, 1, 1},
+	[DRM_IOCTL_NR(DRM_IOCTL_AUTH_MAGIC)] = {drm_authmagic, 1, 1},
+
+	[DRM_IOCTL_NR(DRM_IOCTL_ADD_MAP)] = {drm_addmap_ioctl, 1, 1},
+	[DRM_IOCTL_NR(DRM_IOCTL_RM_MAP)] = {drm_rmmap_ioctl, 1, 0},
+
+	[DRM_IOCTL_NR(DRM_IOCTL_SET_SAREA_CTX)] = {drm_setsareactx, 1, 1},
+	[DRM_IOCTL_NR(DRM_IOCTL_GET_SAREA_CTX)] = {drm_getsareactx, 1, 0},
+
+	[DRM_IOCTL_NR(DRM_IOCTL_ADD_CTX)] = {drm_addctx, 1, 1},
+	[DRM_IOCTL_NR(DRM_IOCTL_RM_CTX)] = {drm_rmctx, 1, 1},
+	[DRM_IOCTL_NR(DRM_IOCTL_MOD_CTX)] = {drm_modctx, 1, 1},
+	[DRM_IOCTL_NR(DRM_IOCTL_GET_CTX)] = {drm_getctx, 1, 0},
+	[DRM_IOCTL_NR(DRM_IOCTL_SWITCH_CTX)] = {drm_switchctx, 1, 1},
+	[DRM_IOCTL_NR(DRM_IOCTL_NEW_CTX)] = {drm_newctx, 1, 1},
+	[DRM_IOCTL_NR(DRM_IOCTL_RES_CTX)] = {drm_resctx, 1, 0},
+
+	[DRM_IOCTL_NR(DRM_IOCTL_ADD_DRAW)] = {drm_adddraw, 1, 1},
+	[DRM_IOCTL_NR(DRM_IOCTL_RM_DRAW)] = {drm_rmdraw, 1, 1},
+
+	[DRM_IOCTL_NR(DRM_IOCTL_LOCK)] = {drm_lock, 1, 0},
+	[DRM_IOCTL_NR(DRM_IOCTL_UNLOCK)] = {drm_unlock, 1, 0},
+
+	[DRM_IOCTL_NR(DRM_IOCTL_FINISH)] = {drm_noop, 1, 0},
+
+	[DRM_IOCTL_NR(DRM_IOCTL_ADD_BUFS)] = {drm_addbufs, 1, 1},
+	[DRM_IOCTL_NR(DRM_IOCTL_MARK_BUFS)] = {drm_markbufs, 1, 1},
+	[DRM_IOCTL_NR(DRM_IOCTL_INFO_BUFS)] = {drm_infobufs, 1, 0},
+	[DRM_IOCTL_NR(DRM_IOCTL_MAP_BUFS)] = {drm_mapbufs, 1, 0},
+	[DRM_IOCTL_NR(DRM_IOCTL_FREE_BUFS)] = {drm_freebufs, 1, 0},
 	/* The DRM_IOCTL_DMA ioctl should be defined by the driver. */
+	[DRM_IOCTL_NR(DRM_IOCTL_DMA)] = {NULL, 1, 0},
 
-	[DRM_IOCTL_NR(DRM_IOCTL_CONTROL)]       = { drm_control,     1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_CONTROL)] = {drm_control, 1, 1},
 
 #if __OS_HAS_AGP
-	[DRM_IOCTL_NR(DRM_IOCTL_AGP_ACQUIRE)]   = { drm_agp_acquire, 1, 1 },
-	[DRM_IOCTL_NR(DRM_IOCTL_AGP_RELEASE)]   = { drm_agp_release, 1, 1 },
-	[DRM_IOCTL_NR(DRM_IOCTL_AGP_ENABLE)]    = { drm_agp_enable,  1, 1 },
-	[DRM_IOCTL_NR(DRM_IOCTL_AGP_INFO)]      = { drm_agp_info,    1, 0 },
-	[DRM_IOCTL_NR(DRM_IOCTL_AGP_ALLOC)]     = { drm_agp_alloc,   1, 1 },
-	[DRM_IOCTL_NR(DRM_IOCTL_AGP_FREE)]      = { drm_agp_free,    1, 1 },
-	[DRM_IOCTL_NR(DRM_IOCTL_AGP_BIND)]      = { drm_agp_bind,    1, 1 },
-	[DRM_IOCTL_NR(DRM_IOCTL_AGP_UNBIND)]    = { drm_agp_unbind,  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_ACQUIRE)] = {drm_agp_acquire_ioctl, 1, 1},
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_RELEASE)] = {drm_agp_release_ioctl, 1, 1},
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_ENABLE)] = {drm_agp_enable_ioctl, 1, 1},
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_INFO)] = {drm_agp_info_ioctl, 1, 0},
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_ALLOC)] = {drm_agp_alloc, 1, 1},
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_FREE)] = {drm_agp_free, 1, 1},
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_BIND)] = {drm_agp_bind, 1, 1},
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_UNBIND)] = {drm_agp_unbind, 1, 1},
 #endif
 
-	[DRM_IOCTL_NR(DRM_IOCTL_SG_ALLOC)]      = { drm_sg_alloc,    1, 1 },
-	[DRM_IOCTL_NR(DRM_IOCTL_SG_FREE)]       = { drm_sg_free,     1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_SG_ALLOC)] = {drm_sg_alloc, 1, 1},
+	[DRM_IOCTL_NR(DRM_IOCTL_SG_FREE)] = {drm_sg_free, 1, 1},
 
-	[DRM_IOCTL_NR(DRM_IOCTL_WAIT_VBLANK)]   = { drm_wait_vblank, 0, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_WAIT_VBLANK)] = {drm_wait_vblank, 0, 0},
 };
 
 #define DRIVER_IOCTL_COUNT	DRM_ARRAY_SIZE( drm_ioctls )
@@ -124,147 +130,133 @@ drm_ioctl_desc_t		  drm_ioctls[] = {
  *
  * Frees every resource in \p dev.
  *
- * \sa drm_device and setup().
+ * \sa drm_device
  */
-int drm_takedown( drm_device_t *dev )
+int drm_takedown(drm_device_t * dev)
 {
 	drm_magic_entry_t *pt, *next;
-	drm_map_t *map;
 	drm_map_list_t *r_list;
-	struct list_head *list, *list_next;
 	drm_vma_entry_t *vma, *vma_next;
 	int i;
 
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
 	if (dev->driver->pretakedown)
-	  dev->driver->pretakedown(dev);
+		dev->driver->pretakedown(dev);
+	DRM_DEBUG("driver pretakedown completed\n");
 
 	if (dev->unique) {
 		drm_free(dev->unique, strlen(dev->unique) + 1, DRM_MEM_DRIVER);
-		dev->unique = NULL;
-		dev->unique_len = 0;
+		dev->unique=NULL;
+		dev->unique_len=0;
 	}
 
-	if ( dev->irq_enabled ) drm_irq_uninstall( dev );
+	if (dev->irq_enabled)
+		drm_irq_uninstall(dev);
+
+	down(&dev->struct_sem);
+	del_timer(&dev->timer);
 
-	down( &dev->struct_sem );
-	del_timer( &dev->timer );
+	if (dev->unique) {
+		drm_free(dev->unique, strlen(dev->unique) + 1, DRM_MEM_DRIVER);
+		dev->unique = NULL;
+		dev->unique_len = 0;
+	}
 
-				/* Clear pid list */
-	for ( i = 0 ; i < DRM_HASH_SIZE ; i++ ) {
-		for ( pt = dev->magiclist[i].head ; pt ; pt = next ) {
+	/* Clear pid list */
+	for (i = 0; i < DRM_HASH_SIZE; i++) {
+		for (pt = dev->magiclist[i].head; pt; pt = next) {
 			next = pt->next;
-			drm_free( pt, sizeof(*pt), DRM_MEM_MAGIC );
+			drm_free(pt, sizeof(*pt), DRM_MEM_MAGIC);
 		}
 		dev->magiclist[i].head = dev->magiclist[i].tail = NULL;
 	}
 
-				/* Clear AGP information */
+	/* Clear AGP information */
 	if (drm_core_has_AGP(dev) && dev->agp) {
 		drm_agp_mem_t *entry;
 		drm_agp_mem_t *nexte;
 
-				/* Remove AGP resources, but leave dev->agp
-                                   intact until drv_cleanup is called. */
-		for ( entry = dev->agp->memory ; entry ; entry = nexte ) {
+		/* Remove AGP resources, but leave dev->agp
+		   intact until drv_cleanup is called. */
+		for (entry = dev->agp->memory; entry; entry = nexte) {
 			nexte = entry->next;
-			if ( entry->bound ) drm_unbind_agp( entry->memory );
-			drm_free_agp( entry->memory, entry->pages );
-			drm_free( entry, sizeof(*entry), DRM_MEM_AGPLISTS );
+			if (entry->bound)
+				drm_unbind_agp(entry->memory);
+			drm_free_agp(entry->memory, entry->pages);
+			drm_free(entry, sizeof(*entry), DRM_MEM_AGPLISTS);
 		}
 		dev->agp->memory = NULL;
 
-		if ( dev->agp->acquired ) drm_agp_do_release(dev);
+		if (dev->agp->acquired)
+			drm_agp_release(dev);
 
 		dev->agp->acquired = 0;
-		dev->agp->enabled  = 0;
+		dev->agp->enabled = 0;
+	}
+	if (drm_core_check_feature(dev, DRIVER_SG) && dev->sg) {
+		drm_sg_cleanup(dev->sg);
+		dev->sg = NULL;
 	}
 
-				/* Clear vma list (only built for debugging) */
-	if ( dev->vmalist ) {
-		for ( vma = dev->vmalist ; vma ; vma = vma_next ) {
+	/* Clear vma list (only built for debugging) */
+	if (dev->vmalist) {
+		for (vma = dev->vmalist; vma; vma = vma_next) {
 			vma_next = vma->next;
-			drm_free( vma, sizeof(*vma), DRM_MEM_VMAS );
+			drm_free(vma, sizeof(*vma), DRM_MEM_VMAS);
 		}
 		dev->vmalist = NULL;
 	}
 
-	if( dev->maplist ) {
-		list_for_each_safe( list, list_next, &dev->maplist->head ) {
-			r_list = (drm_map_list_t *)list;
-
-			if ( ( map = r_list->map ) ) {
-				switch ( map->type ) {
-				case _DRM_REGISTERS:
-				case _DRM_FRAME_BUFFER:
-					if (drm_core_has_MTRR(dev)) {
-						if ( map->mtrr >= 0 ) {
-							int retcode;
-							retcode = mtrr_del( map->mtrr,
-									    map->offset,
-									    map->size );
-							DRM_DEBUG( "mtrr_del=%d\n", retcode );
-						}
-					}
-					drm_ioremapfree( map->handle, map->size, dev );
-					break;
-				case _DRM_SHM:
-					vfree(map->handle);
-					break;
-
-				case _DRM_AGP:
-					/* Do nothing here, because this is all
-					 * handled in the AGP/GART driver.
-					 */
-					break;
-				case _DRM_SCATTER_GATHER:
-					/* Handle it */
-					if (drm_core_check_feature(dev, DRIVER_SG) && dev->sg) {
-						drm_sg_cleanup(dev->sg);
-						dev->sg = NULL;
-					}
-					break;
-				}
-				drm_free(map, sizeof(*map), DRM_MEM_MAPS);
-			}
-			list_del( list );
-			drm_free(r_list, sizeof(*r_list), DRM_MEM_MAPS);
- 		}
-		drm_free(dev->maplist, sizeof(*dev->maplist), DRM_MEM_MAPS);
-		dev->maplist = NULL;
- 	}
+	if (dev->maplist) {
+		while (!list_empty(&dev->maplist->head)) {
+			struct list_head *list = dev->maplist->head.next;
+			r_list = list_entry(list, drm_map_list_t, head);
+			drm_rmmap_locked(dev, r_list->map);
+		}
+	}
 
-	if (drm_core_check_feature(dev, DRIVER_DMA_QUEUE) && dev->queuelist ) {
-		for ( i = 0 ; i < dev->queue_count ; i++ ) {
-			if ( dev->queuelist[i] ) {
-				drm_free( dev->queuelist[i],
-					  sizeof(*dev->queuelist[0]),
-					  DRM_MEM_QUEUES );
+	if (drm_core_check_feature(dev, DRIVER_DMA_QUEUE) && dev->queuelist) {
+		for (i = 0; i < dev->queue_count; i++) {
+
+			if (dev->queuelist[i]) {
+				drm_free(dev->queuelist[i],
+					 sizeof(*dev->queuelist[0]),
+					 DRM_MEM_QUEUES);
 				dev->queuelist[i] = NULL;
 			}
 		}
-		drm_free( dev->queuelist,
-			  dev->queue_slots * sizeof(*dev->queuelist),
-			  DRM_MEM_QUEUES );
+		drm_free(dev->queuelist,
+			 dev->queue_slots * sizeof(*dev->queuelist),
+			 DRM_MEM_QUEUES);
 		dev->queuelist = NULL;
 	}
 	dev->queue_count = 0;
 
 	if (drm_core_check_feature(dev, DRIVER_HAVE_DMA))
-		drm_dma_takedown( dev );
+		drm_dma_takedown(dev);
 
-	if ( dev->lock.hw_lock ) {
-		dev->sigdata.lock = dev->lock.hw_lock = NULL; /* SHM removed */
+	if (dev->lock.hw_lock) {
+		dev->sigdata.lock = dev->lock.hw_lock = NULL;	/* SHM removed */
 		dev->lock.filp = NULL;
-		wake_up_interruptible( &dev->lock.lock_queue );
+		wake_up_interruptible(&dev->lock.lock_queue);
 	}
-	up( &dev->struct_sem );
+	up(&dev->struct_sem);
 
+	DRM_DEBUG("takedown completed\n");
 	return 0;
 }
 
+void __exit drm_cleanup_pci(struct pci_dev *pdev)
+{
+	drm_device_t *dev = pci_get_drvdata(pdev);
 
+	pci_set_drvdata(pdev, NULL);
+	pci_release_regions(pdev);
+	if (dev)
+		drm_cleanup(dev);
+}
+EXPORT_SYMBOL(drm_cleanup_pci);
 
 /**
  * Module initialization. Called via init_module at module load time, or via
@@ -275,30 +267,62 @@ int drm_takedown( drm_device_t *dev )
  * Initializes an array of drm_device structures, and attempts to
  * initialize all available devices, using consecutive minors, registering the
  * stubs and initializing the AGP device.
- * 
+ *
  * Expands the \c DRIVER_PREINIT and \c DRIVER_POST_INIT macros before and
  * after the initialization for driver customization.
  */
-int drm_init( struct drm_driver *driver )
+int drm_init(struct drm_driver *driver,
+		       struct pci_device_id *pciidlist)
 {
-	struct pci_dev *pdev = NULL;
+	struct pci_dev *pdev;
 	struct pci_device_id *pid;
-	int i;
+	int rc, i;
 
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
-	drm_mem_init();
+	for (i = 0; (pciidlist[i].vendor != 0) && !drm_fb_loaded; i++) {
+		pid = &pciidlist[i];
+
+		pdev = NULL;
+		/* pass back in pdev to account for multiple identical cards */
+		while ((pdev =
+			pci_get_subsys(pid->vendor, pid->device, pid->subvendor,
+				       pid->subdevice, pdev))) {
+			/* is there already a driver loaded, or (short circuit saves work) */
+			/* does something like VesaFB have control of the memory region? */
+			if (pci_dev_driver(pdev)
+			    || pci_request_regions(pdev, "DRM scan")) {
+				/* go into stealth mode */
+				drm_fb_loaded = 1;
+				pci_dev_put(pdev);
+				break;
+			}
+			/* no fbdev or vesadev, put things back and wait for normal probe */
+			pci_release_regions(pdev);
+		}
+	}
 
-	for (i=0; driver->pci_driver.id_table[i].vendor != 0; i++) {
-		pid = (struct pci_device_id *)&driver->pci_driver.id_table[i];
-		
-		pdev=NULL;
-		/* pass back in pdev to account for multiple identical cards */		
-		while ((pdev = pci_get_subsys(pid->vendor, pid->device, pid->subvendor, pid->subdevice, pdev)) != NULL) {
-			/* stealth mode requires a manual probe */
-			pci_dev_get(pdev);
-			drm_get_dev(pdev, pid, driver);
+	if (!drm_fb_loaded)
+		pci_register_driver(&driver->pci_driver);
+	else {
+		for (i = 0; pciidlist[i].vendor != 0; i++) {
+			pid = &pciidlist[i];
+
+			pdev = NULL;
+			/* pass back in pdev to account for multiple identical cards */
+			while ((pdev =
+				pci_get_subsys(pid->vendor, pid->device,
+					       pid->subvendor, pid->subdevice,
+					       pdev))) {
+				/* stealth mode requires a manual probe */
+				pci_dev_get(pdev);
+				if ((rc = drm_get_dev(pdev, &pciidlist[i], driver))) {
+					pci_dev_put(pdev);
+					return rc;
+				}
+			}
 		}
+		DRM_INFO("Used old pci detect: framebuffer loaded\n");
 	}
 	return 0;
 }
@@ -308,94 +332,103 @@ EXPORT_SYMBOL(drm_init);
  * Called via cleanup_module() at module unload time.
  *
  * Cleans up all DRM device, calling takedown().
- * 
- * \sa drm_init().
+ *
+ * \sa drm_init
  */
-static void drm_cleanup( drm_device_t *dev )
+static void __exit drm_cleanup(drm_device_t * dev)
 {
-	DRM_DEBUG( "\n" );
 
+	DRM_DEBUG("\n");
 	if (!dev) {
 		DRM_ERROR("cleanup called no dev\n");
 		return;
 	}
 
-	drm_takedown( dev );	
+	drm_takedown(dev);
 
-	drm_ctxbitmap_cleanup( dev );
-	
-	if (drm_core_has_MTRR(dev) && drm_core_has_AGP(dev) &&
-	    dev->agp && dev->agp->agp_mtrr >= 0) {
+	if (dev->maplist) {
+		drm_free(dev->maplist, sizeof(*dev->maplist), DRM_MEM_MAPS);
+		dev->maplist = NULL;
+	}
+
+	if (!drm_fb_loaded)
+		pci_disable_device(dev->pdev);
+
+	drm_ctxbitmap_cleanup(dev);
+
+	if (drm_core_has_MTRR(dev) && drm_core_has_AGP(dev) && dev->agp
+	    && dev->agp->agp_mtrr >= 0) {
 		int retval;
-		retval = mtrr_del( dev->agp->agp_mtrr,
-				   dev->agp->agp_info.aper_base,
-				   dev->agp->agp_info.aper_size*1024*1024 );
-		DRM_DEBUG( "mtrr_del=%d\n", retval );
-	}
-	
-	if (drm_core_has_AGP(dev) && dev->agp ) {
-		drm_free( dev->agp, sizeof(*dev->agp), DRM_MEM_AGPLISTS );
-		dev->agp = NULL;
+		retval = mtrr_del(dev->agp->agp_mtrr,
+				  dev->agp->agp_info.aper_base,
+				  dev->agp->agp_info.aper_size * 1024 * 1024);
+		DRM_DEBUG("mtrr_del=%d\n", retval);
 	}
 
+	if (drm_core_has_AGP(dev) && dev->agp) {
+		drm_free(dev->agp, sizeof(*dev->agp), DRM_MEM_AGPLISTS);
+		dev->agp = NULL;
+	}
 	if (dev->driver->postcleanup)
 		dev->driver->postcleanup(dev);
-	
+
 	drm_put_head(&dev->primary);
-	if ( drm_put_dev(dev) )
-		DRM_ERROR( "Cannot unload module\n" );
+	if (drm_put_dev(dev))
+		DRM_ERROR("Cannot unload module\n");
 }
 
-void drm_exit (struct drm_driver *driver)
+void __exit drm_exit(struct drm_driver *driver)
 {
 	int i;
 	drm_device_t *dev = NULL;
 	drm_head_t *head;
-	
-	DRM_DEBUG( "\n" );
 
-	for (i = 0; i < drm_cards_limit; i++) {
-		head = drm_heads[i];
-		if (!head)
-			continue;
-		if (!head->dev)
-			continue;
-		if (head->dev->driver!=driver)
-			continue;
-		dev=head->dev;
-	}
-	if (dev) {
-		/* release the pci driver */
-		if (dev->pdev)
-			pci_dev_put(dev->pdev);
-		drm_cleanup(dev);
-	}
-	DRM_INFO( "Module unloaded\n" );
+	DRM_DEBUG("\n");
+	if (drm_fb_loaded) {
+		for (i = 0; i < cards_limit; i++) {
+			head = drm_heads[i];
+			if (!head)
+				continue;
+			if (!head->dev)
+				continue;
+			if (head->dev->driver != driver)
+				continue;
+			dev = head->dev;
+		}
+		if (dev) {
+			/* release the pci driver */
+			if (dev->pdev)
+				pci_dev_put(dev->pdev);
+			drm_cleanup(dev);
+		}
+	} else
+		pci_unregister_driver(&driver->pci_driver);
+	DRM_INFO("Module unloaded\n");
 }
 EXPORT_SYMBOL(drm_exit);
 
 /** File operations structure */
 static struct file_operations drm_stub_fops = {
 	.owner = THIS_MODULE,
-	.open  = drm_stub_open
+	.open = drm_stub_open
 };
 
 static int __init drm_core_init(void)
 {
 	int ret = -ENOMEM;
-	
-	drm_cards_limit = (drm_cards_limit < DRM_MAX_MINOR + 1 ? drm_cards_limit : DRM_MAX_MINOR + 1);
-	drm_heads = drm_calloc(drm_cards_limit,
-				sizeof(*drm_heads), DRM_MEM_STUB);
-	if(!drm_heads) 
+
+	cards_limit =
+	    (cards_limit < DRM_MAX_MINOR + 1 ? cards_limit : DRM_MAX_MINOR + 1);
+	drm_heads = drm_calloc(cards_limit, sizeof(*drm_heads), DRM_MEM_STUB);
+	if (!drm_heads)
 		goto err_p1;
-	
+
 	if (register_chrdev(DRM_MAJOR, "drm", &drm_stub_fops))
 		goto err_p1;
-	
+
 	drm_class = drm_sysfs_create(THIS_MODULE, "drm");
 	if (IS_ERR(drm_class)) {
-		printk (KERN_ERR "DRM: Error creating drm class.\n");
+		printk(KERN_ERR "DRM: Error creating drm class.\n");
 		ret = PTR_ERR(drm_class);
 		goto err_p2;
 	}
@@ -406,35 +439,34 @@ static int __init drm_core_init(void)
 		ret = -1;
 		goto err_p3;
 	}
-		
-	DRM_INFO( "Initialized %s %d.%d.%d %s\n",
-		CORE_NAME, CORE_MAJOR, CORE_MINOR, CORE_PATCHLEVEL,
-		CORE_DATE);
+
+	drm_mem_init();
+
+	DRM_INFO("Initialized %s %d.%d.%d %s\n",
+		 CORE_NAME,
+		 CORE_MAJOR, CORE_MINOR, CORE_PATCHLEVEL, CORE_DATE);
 	return 0;
 err_p3:
 	drm_sysfs_destroy(drm_class);
 err_p2:
 	unregister_chrdev(DRM_MAJOR, "drm");
-	drm_free(drm_heads, sizeof(*drm_heads) * drm_cards_limit, DRM_MEM_STUB);
-err_p1:	
+	drm_free(drm_heads, sizeof(*drm_heads) * cards_limit, DRM_MEM_STUB);
+err_p1:
 	return ret;
 }
 
-static void __exit drm_core_exit (void)
+static void __exit drm_core_exit(void)
 {
 	remove_proc_entry("dri", NULL);
 	drm_sysfs_destroy(drm_class);
 
 	unregister_chrdev(DRM_MAJOR, "drm");
 
-	drm_free(drm_heads, sizeof(*drm_heads) *
-				drm_cards_limit, DRM_MEM_STUB);
+	drm_free(drm_heads, sizeof(*drm_heads) * cards_limit, DRM_MEM_STUB);
 }
 
-
-module_init( drm_core_init );
-module_exit( drm_core_exit );
-
+module_init(drm_core_init);
+module_exit(drm_core_exit);
 
 /**
  * Get version information
@@ -447,8 +479,8 @@ module_exit( drm_core_exit );
  *
  * Fills in the version information in \p arg.
  */
-int drm_version( struct inode *inode, struct file *filp,
-		  unsigned int cmd, unsigned long arg )
+static int drm_version(struct inode *inode, struct file *filp,
+		unsigned int cmd, unsigned long arg)
 {
 	drm_file_t *priv = filp->private_data;
 	drm_device_t *dev = priv->head->dev;
@@ -456,21 +488,19 @@ int drm_version( struct inode *inode, st
 	drm_version_t version;
 	int ret;
 
-	if ( copy_from_user( &version, argp, sizeof(version) ) )
+	if (copy_from_user(&version, argp, sizeof(version)))
 		return -EFAULT;
 
 	/* version is a required function to return the personality module version */
 	if ((ret = dev->driver->version(&version)))
 		return ret;
-		
-	if ( copy_to_user( argp, &version, sizeof(version) ) )
+
+	if (copy_to_user(argp, &version, sizeof(version)))
 		return -EFAULT;
 	return 0;
 }
 
-
-
-/** 
+/**
  * Called whenever a process performs an ioctl on /dev/drm.
  *
  * \param inode device inode.
@@ -482,8 +512,8 @@ int drm_version( struct inode *inode, st
  * Looks up the ioctl function in the ::ioctls table, checking for root
  * previleges if so required, and dispatches to the respective function.
  */
-int drm_ioctl( struct inode *inode, struct file *filp,
-		unsigned int cmd, unsigned long arg )
+int drm_ioctl(struct inode *inode, struct file *filp,
+	      unsigned int cmd, unsigned long arg)
 {
 	drm_file_t *priv = filp->private_data;
 	drm_device_t *dev = priv->head->dev;
@@ -492,40 +522,39 @@ int drm_ioctl( struct inode *inode, stru
 	unsigned int nr = DRM_IOCTL_NR(cmd);
 	int retcode = -EINVAL;
 
-	atomic_inc( &dev->ioctl_count );
-	atomic_inc( &dev->counts[_DRM_STAT_IOCTLS] );
+	atomic_inc(&dev->ioctl_count);
+	atomic_inc(&dev->counts[_DRM_STAT_IOCTLS]);
 	++priv->ioctl_count;
 
-	DRM_DEBUG( "pid=%d, cmd=0x%02x, nr=0x%02x, dev 0x%lx, auth=%d\n",
-		   current->pid, cmd, nr, (long)old_encode_dev(priv->head->device), 
-		   priv->authenticated );
-	
+	DRM_DEBUG("pid=%d, cmd=0x%02x, nr=0x%02x, dev 0x%lx, auth=%d\n",
+		  current->pid, cmd, nr, (long)old_encode_dev(priv->head->device),
+		  priv->authenticated);
+
 	if (nr < DRIVER_IOCTL_COUNT)
 		ioctl = &drm_ioctls[nr];
-	else if ((nr >= DRM_COMMAND_BASE) && (nr < DRM_COMMAND_BASE + dev->driver->num_ioctls))
+	else if ((nr >= DRM_COMMAND_BASE)
+		 && (nr < DRM_COMMAND_BASE + dev->driver->num_ioctls))
 		ioctl = &dev->driver->ioctls[nr - DRM_COMMAND_BASE];
 	else
 		goto err_i1;
-	
+
 	func = ioctl->func;
-	/* is there a local override? */
-	if ((nr == DRM_IOCTL_NR(DRM_IOCTL_DMA)) && dev->driver->dma_ioctl)
+	if ((nr == DRM_IOCTL_NR(DRM_IOCTL_DMA)) && dev->driver->dma_ioctl)	/* Local override? */
 		func = dev->driver->dma_ioctl;
-	
-	if ( !func ) {
-		DRM_DEBUG( "no function\n" );
+
+	if (!func) {
+		DRM_DEBUG("no function\n");
 		retcode = -EINVAL;
-	} else if ( ( ioctl->root_only && !capable( CAP_SYS_ADMIN ) )||
-		    ( ioctl->auth_needed && !priv->authenticated ) ) {
+	} else if ((ioctl->root_only && !capable(CAP_SYS_ADMIN)) ||
+		   (ioctl->auth_needed && !priv->authenticated)) {
 		retcode = -EACCES;
 	} else {
-		retcode = func( inode, filp, cmd, arg );
+		retcode = func(inode, filp, cmd, arg);
 	}
-	
-err_i1:
-	atomic_dec( &dev->ioctl_count );
-	if (retcode) DRM_DEBUG( "ret = %x\n", retcode);
+      err_i1:
+	atomic_dec(&dev->ioctl_count);
+	if (retcode)
+		DRM_DEBUG("ret = %x\n", retcode);
 	return retcode;
 }
 EXPORT_SYMBOL(drm_ioctl);
-
diff -purN linux-2.6.12.orig/drivers/char/drm/drm_fops.c linux-2.6.12/drivers/char/drm/drm_fops.c
--- linux-2.6.12.orig/drivers/char/drm/drm_fops.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/drm_fops.c	2005-07-05 08:37:27.000000000 +0200
@@ -1,7 +1,7 @@
 /**
- * \file drm_fops.h 
+ * \file drm_fops.c
  * File operations for DRM
- * 
+ *
  * \author Rickard E. (Rik) Faith <faith@valinux.com>
  * \author Daryll Strauss <daryll@valinux.com>
  * \author Gareth Hughes <gareth@valinux.com>
@@ -37,53 +37,43 @@
 #include "drmP.h"
 #include <linux/poll.h>
 
-static int drm_setup( drm_device_t *dev )
+static int drm_open_helper(struct inode *inode, struct file *filp, drm_device_t * dev);
+
+static int drm_setup(drm_device_t * dev)
 {
 	int i;
-	int ret;
 
 	if (dev->driver->presetup)
-	{
-		ret=dev->driver->presetup(dev);
-		if (ret!=0) 
-			return ret;
-	}
+		dev->driver->presetup(dev);
 
-	atomic_set( &dev->ioctl_count, 0 );
-	atomic_set( &dev->vma_count, 0 );
+	atomic_set(&dev->ioctl_count, 0);
+	atomic_set(&dev->vma_count, 0);
 	dev->buf_use = 0;
-	atomic_set( &dev->buf_alloc, 0 );
+	atomic_set(&dev->buf_alloc, 0);
 
-	if (drm_core_check_feature(dev, DRIVER_HAVE_DMA))
-	{
-		i = drm_dma_setup( dev );
-		if ( i < 0 )
+	if (drm_core_check_feature(dev, DRIVER_HAVE_DMA)) {
+		i = drm_dma_setup(dev);
+		if (i < 0)
 			return i;
 	}
 
-	for ( i = 0 ; i < DRM_ARRAY_SIZE(dev->counts) ; i++ )
-		atomic_set( &dev->counts[i], 0 );
+	for (i = 0; i < DRM_ARRAY_SIZE(dev->counts); i++)
+		atomic_set(&dev->counts[i], 0);
 
-	for ( i = 0 ; i < DRM_HASH_SIZE ; i++ ) {
+	for (i = 0; i < DRM_HASH_SIZE; i++) {
 		dev->magiclist[i].head = NULL;
 		dev->magiclist[i].tail = NULL;
 	}
 
-	dev->maplist = drm_alloc(sizeof(*dev->maplist),
-				  DRM_MEM_MAPS);
-	if(dev->maplist == NULL) return -ENOMEM;
-	memset(dev->maplist, 0, sizeof(*dev->maplist));
-	INIT_LIST_HEAD(&dev->maplist->head);
-
-	dev->ctxlist = drm_alloc(sizeof(*dev->ctxlist),
-				  DRM_MEM_CTXLIST);
-	if(dev->ctxlist == NULL) return -ENOMEM;
+	dev->ctxlist = drm_alloc(sizeof(*dev->ctxlist), DRM_MEM_CTXLIST);
+	if (dev->ctxlist == NULL)
+		return -ENOMEM;
 	memset(dev->ctxlist, 0, sizeof(*dev->ctxlist));
 	INIT_LIST_HEAD(&dev->ctxlist->head);
 
 	dev->vmalist = NULL;
 	dev->sigdata.lock = dev->lock.hw_lock = NULL;
-	init_waitqueue_head( &dev->lock.lock_queue );
+	init_waitqueue_head(&dev->lock.lock_queue);
 	dev->queue_count = 0;
 	dev->queue_reserved = 0;
 	dev->queue_slots = 0;
@@ -95,7 +85,7 @@ static int drm_setup( drm_device_t *dev 
 	dev->last_context = 0;
 	dev->last_switch = 0;
 	dev->last_checked = 0;
-	init_waitqueue_head( &dev->context_wait );
+	init_waitqueue_head(&dev->context_wait);
 	dev->if_version = 0;
 
 	dev->ctx_start = 0;
@@ -105,14 +95,14 @@ static int drm_setup( drm_device_t *dev 
 	dev->buf_wp = dev->buf;
 	dev->buf_end = dev->buf + DRM_BSZ;
 	dev->buf_async = NULL;
-	init_waitqueue_head( &dev->buf_readers );
-	init_waitqueue_head( &dev->buf_writers );
+	init_waitqueue_head(&dev->buf_readers);
+	init_waitqueue_head(&dev->buf_writers);
 
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
 	/*
 	 * The kernel's context could be created here, but is now created
-	 * in drm_dma_enqueue.	This is more resource-efficient for
+	 * in drm_dma_enqueue.  This is more resource-efficient for
 	 * hardware that does not do DMA, but may mean that
 	 * drm_select_queue fails between the time the interrupt is
 	 * initialized and the time the queues are initialized.
@@ -125,7 +115,7 @@ static int drm_setup( drm_device_t *dev 
 
 /**
  * Open file.
- * 
+ *
  * \param inode device inode
  * \param filp file pointer.
  * \return zero on success or a negative number on failure.
@@ -134,30 +124,30 @@ static int drm_setup( drm_device_t *dev 
  * increments the device open count. If the open count was previous at zero,
  * i.e., it's the first that the device is open, then calls setup().
  */
-int drm_open( struct inode *inode, struct file *filp )
+int drm_open(struct inode *inode, struct file *filp)
 {
 	drm_device_t *dev = NULL;
 	int minor = iminor(inode);
 	int retcode = 0;
 
-	if (!((minor >= 0) && (minor < drm_cards_limit)))
+	if (!((minor >= 0) && (minor < cards_limit)))
 		return -ENODEV;
-		
+
 	if (!drm_heads[minor])
 		return -ENODEV;
 
 	if (!(dev = drm_heads[minor]->dev))
 		return -ENODEV;
-	
-	retcode = drm_open_helper( inode, filp, dev );
-	if ( !retcode ) {
-		atomic_inc( &dev->counts[_DRM_STAT_OPENS] );
-		spin_lock( &dev->count_lock );
-		if ( !dev->open_count++ ) {
-			spin_unlock( &dev->count_lock );
-			return drm_setup( dev );
+
+	retcode = drm_open_helper(inode, filp, dev);
+	if (!retcode) {
+		atomic_inc(&dev->counts[_DRM_STAT_OPENS]);
+		spin_lock(&dev->count_lock);
+		if (!dev->open_count++) {
+			spin_unlock(&dev->count_lock);
+			return drm_setup(dev);
 		}
-		spin_unlock( &dev->count_lock );
+		spin_unlock(&dev->count_lock);
 	}
 
 	return retcode;
@@ -165,6 +155,159 @@ int drm_open( struct inode *inode, struc
 EXPORT_SYMBOL(drm_open);
 
 /**
+ * File \c open operation.
+ *
+ * \param inode device inode.
+ * \param filp file pointer.
+ *
+ * Puts the dev->fops corresponding to the device minor number into
+ * \p filp, call the \c open method, and restore the file operations.
+ */
+int drm_stub_open(struct inode *inode, struct file *filp)
+{
+	drm_device_t *dev = NULL;
+	int minor = iminor(inode);
+	int err = -ENODEV;
+	struct file_operations *old_fops;
+
+	DRM_DEBUG("\n");
+
+	if (!((minor >= 0) && (minor < cards_limit)))
+		return -ENODEV;
+
+	if (!drm_heads[minor])
+		return -ENODEV;
+
+	if (!(dev = drm_heads[minor]->dev))
+		return -ENODEV;
+
+	old_fops = filp->f_op;
+	filp->f_op = fops_get(&dev->driver->fops);
+	if (filp->f_op->open && (err = filp->f_op->open(inode, filp))) {
+		fops_put(filp->f_op);
+		filp->f_op = fops_get(old_fops);
+	}
+	fops_put(old_fops);
+
+	return err;
+}
+
+/**
+ * Check whether DRI will run on this CPU.
+ *
+ * \return non-zero if the DRI will run on this CPU, or zero otherwise.
+ */
+static int drm_cpu_valid(void)
+{
+#if defined(__i386__)
+	if (boot_cpu_data.x86 == 3)
+		return 0;	/* No cmpxchg on a 386 */
+#endif
+#if defined(__sparc__) && !defined(__sparc_v9__)
+	return 0;		/* No cmpxchg before v9 sparc. */
+#endif
+	return 1;
+}
+
+/**
+ * Called whenever a process opens /dev/drm.
+ *
+ * \param inode device inode.
+ * \param filp file pointer.
+ * \param dev device.
+ * \return zero on success or a negative number on failure.
+ *
+ * Creates and initializes a drm_file structure for the file private data in \p
+ * filp and add it into the double linked list in \p dev.
+ */
+static int drm_open_helper(struct inode *inode, struct file *filp, drm_device_t * dev)
+{
+	int minor = iminor(inode);
+	drm_file_t *priv;
+	int ret;
+
+	if (filp->f_flags & O_EXCL)
+		return -EBUSY;	/* No exclusive opens */
+	if (!drm_cpu_valid())
+		return -EINVAL;
+
+	DRM_DEBUG("pid = %d, minor = %d\n", current->pid, minor);
+
+	priv = drm_alloc(sizeof(*priv), DRM_MEM_FILES);
+	if (!priv)
+		return -ENOMEM;
+
+	memset(priv, 0, sizeof(*priv));
+	filp->private_data = priv;
+	priv->uid = current->euid;
+	priv->pid = current->pid;
+	priv->minor = minor;
+	priv->head = drm_heads[minor];
+	priv->ioctl_count = 0;
+	priv->authenticated = capable(CAP_SYS_ADMIN);
+	priv->lock_count = 0;
+
+	if (dev->driver->open_helper) {
+		ret = dev->driver->open_helper(dev, priv);
+		if (ret < 0)
+			goto out_free;
+	}
+
+	down(&dev->struct_sem);
+	if (!dev->file_last) {
+		priv->next = NULL;
+		priv->prev = NULL;
+		dev->file_first = priv;
+		dev->file_last = priv;
+	} else {
+		priv->next = NULL;
+		priv->prev = dev->file_last;
+		dev->file_last->next = priv;
+		dev->file_last = priv;
+	}
+	up(&dev->struct_sem);
+
+#ifdef __alpha__
+	/*
+	 * Default the hose
+	 */
+	if (!dev->hose) {
+		struct pci_dev *pci_dev;
+		pci_dev = pci_find_class(PCI_CLASS_DISPLAY_VGA << 8, NULL);
+		if (pci_dev)
+			dev->hose = pci_dev->sysdata;
+		if (!dev->hose) {
+			struct pci_bus *b = pci_bus_b(pci_root_buses.next);
+			if (b)
+				dev->hose = b->sysdata;
+		}
+	}
+#endif
+
+	return 0;
+      out_free:
+	drm_free(priv, sizeof(*priv), DRM_MEM_FILES);
+	filp->private_data = NULL;
+	return ret;
+}
+
+/** No-op. */
+int drm_fasync(int fd, struct file *filp, int on)
+{
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
+	int retcode;
+
+	DRM_DEBUG("fd = %d, device = 0x%lx\n", fd,
+		  (long)old_encode_dev(priv->head->device));
+	retcode = fasync_helper(fd, filp, on, &dev->buf_async);
+	if (retcode < 0)
+		return retcode;
+	return 0;
+}
+EXPORT_SYMBOL(drm_fasync);
+
+/**
  * Release file.
  *
  * \param inode device inode
@@ -176,7 +319,7 @@ EXPORT_SYMBOL(drm_open);
  * data from its list and free it. Decreases the open count and if it reaches
  * zero calls takedown().
  */
-int drm_release( struct inode *inode, struct file *filp )
+int drm_release(struct inode *inode, struct file *filp)
 {
 	drm_file_t *priv = filp->private_data;
 	drm_device_t *dev;
@@ -185,7 +328,7 @@ int drm_release( struct inode *inode, st
 	lock_kernel();
 	dev = priv->head->dev;
 
-	DRM_DEBUG( "open_count = %d\n", dev->open_count );
+	DRM_DEBUG("open_count = %d\n", dev->open_count);
 
 	if (dev->driver->prerelease)
 		dev->driver->prerelease(dev, filp);
@@ -194,135 +337,133 @@ int drm_release( struct inode *inode, st
 	 * Begin inline drm_release
 	 */
 
-	DRM_DEBUG( "pid = %d, device = 0x%lx, open_count = %d\n",
-		   current->pid, (long)old_encode_dev(priv->head->device), dev->open_count );
+	DRM_DEBUG("pid = %d, device = 0x%lx, open_count = %d\n",
+		  current->pid, (long)old_encode_dev(priv->head->device),
+		  dev->open_count);
+
+	if (priv->lock_count && dev->lock.hw_lock &&
+	    _DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock) &&
+	    dev->lock.filp == filp) {
+		DRM_DEBUG("File %p released, freeing lock for context %d\n",
+			  filp, _DRM_LOCKING_CONTEXT(dev->lock.hw_lock->lock));
 
-	if ( priv->lock_count && dev->lock.hw_lock &&
-	     _DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock) &&
-	     dev->lock.filp == filp ) {
-		DRM_DEBUG( "File %p released, freeing lock for context %d\n",
-			filp,
-			_DRM_LOCKING_CONTEXT(dev->lock.hw_lock->lock) );
-		
 		if (dev->driver->release)
 			dev->driver->release(dev, filp);
 
-		drm_lock_free( dev, &dev->lock.hw_lock->lock,
-				_DRM_LOCKING_CONTEXT(dev->lock.hw_lock->lock) );
+		drm_lock_free(dev, &dev->lock.hw_lock->lock,
+			      _DRM_LOCKING_CONTEXT(dev->lock.hw_lock->lock));
 
-				/* FIXME: may require heavy-handed reset of
-                                   hardware at this point, possibly
-                                   processed via a callback to the X
-                                   server. */
-	}
-	else if ( dev->driver->release && priv->lock_count && dev->lock.hw_lock ) {
+		/* FIXME: may require heavy-handed reset of
+		   hardware at this point, possibly
+		   processed via a callback to the X
+		   server. */
+	} else if (dev->driver->release && priv->lock_count
+		   && dev->lock.hw_lock) {
 		/* The lock is required to reclaim buffers */
-		DECLARE_WAITQUEUE( entry, current );
+		DECLARE_WAITQUEUE(entry, current);
 
-		add_wait_queue( &dev->lock.lock_queue, &entry );
+		add_wait_queue(&dev->lock.lock_queue, &entry);
 		for (;;) {
-			__set_current_state(TASK_INTERRUPTIBLE);
-			if ( !dev->lock.hw_lock ) {
+			current->state = TASK_INTERRUPTIBLE;
+			if (!dev->lock.hw_lock) {
 				/* Device has been unregistered */
 				retcode = -EINTR;
 				break;
 			}
-			if ( drm_lock_take( &dev->lock.hw_lock->lock,
-					     DRM_KERNEL_CONTEXT ) ) {
-				dev->lock.filp	    = filp;
+			if (drm_lock_take(&dev->lock.hw_lock->lock,
+					  DRM_KERNEL_CONTEXT)) {
+				dev->lock.filp = filp;
 				dev->lock.lock_time = jiffies;
-                                atomic_inc( &dev->counts[_DRM_STAT_LOCKS] );
+				atomic_inc(&dev->counts[_DRM_STAT_LOCKS]);
 				break;	/* Got lock */
 			}
-				/* Contention */
+			/* Contention */
 			schedule();
-			if ( signal_pending( current ) ) {
+			if (signal_pending(current)) {
 				retcode = -ERESTARTSYS;
 				break;
 			}
 		}
-		__set_current_state(TASK_RUNNING);
-		remove_wait_queue( &dev->lock.lock_queue, &entry );
-		if( !retcode ) {
+		current->state = TASK_RUNNING;
+		remove_wait_queue(&dev->lock.lock_queue, &entry);
+		if (!retcode) {
 			if (dev->driver->release)
 				dev->driver->release(dev, filp);
-			drm_lock_free( dev, &dev->lock.hw_lock->lock,
-					DRM_KERNEL_CONTEXT );
+			drm_lock_free(dev, &dev->lock.hw_lock->lock,
+				      DRM_KERNEL_CONTEXT);
 		}
 	}
-	
-	if (drm_core_check_feature(dev, DRIVER_HAVE_DMA))
-	{
+
+	if (drm_core_check_feature(dev, DRIVER_HAVE_DMA) && !dev->driver->release) {
 		dev->driver->reclaim_buffers(dev, filp);
 	}
 
-	drm_fasync( -1, filp, 0 );
+	drm_fasync(-1, filp, 0);
 
-	down( &dev->ctxlist_sem );
-	if ( !list_empty( &dev->ctxlist->head ) ) {
+	down(&dev->ctxlist_sem);
+	if (dev->ctxlist && (!list_empty(&dev->ctxlist->head))) {
 		drm_ctx_list_t *pos, *n;
 
-		list_for_each_entry_safe( pos, n, &dev->ctxlist->head, head ) {
-			if ( pos->tag == priv &&
-			     pos->handle != DRM_KERNEL_CONTEXT ) {
+		list_for_each_entry_safe(pos, n, &dev->ctxlist->head, head) {
+			if (pos->tag == priv &&
+			    pos->handle != DRM_KERNEL_CONTEXT) {
 				if (dev->driver->context_dtor)
-					dev->driver->context_dtor(dev, pos->handle);
+					dev->driver->context_dtor(dev,
+								  pos->handle);
 
-				drm_ctxbitmap_free( dev, pos->handle );
+				drm_ctxbitmap_free(dev, pos->handle);
 
-				list_del( &pos->head );
-				drm_free( pos, sizeof(*pos), DRM_MEM_CTXLIST );
+				list_del(&pos->head);
+				drm_free(pos, sizeof(*pos), DRM_MEM_CTXLIST);
 				--dev->ctx_count;
 			}
 		}
 	}
-	up( &dev->ctxlist_sem );
+	up(&dev->ctxlist_sem);
 
-	down( &dev->struct_sem );
-	if ( priv->remove_auth_on_close == 1 ) {
+	down(&dev->struct_sem);
+	if (priv->remove_auth_on_close == 1) {
 		drm_file_t *temp = dev->file_first;
-		while ( temp ) {
+		while (temp) {
 			temp->authenticated = 0;
 			temp = temp->next;
 		}
 	}
-	if ( priv->prev ) {
+	if (priv->prev) {
 		priv->prev->next = priv->next;
 	} else {
-		dev->file_first	 = priv->next;
+		dev->file_first = priv->next;
 	}
-	if ( priv->next ) {
+	if (priv->next) {
 		priv->next->prev = priv->prev;
 	} else {
-		dev->file_last	 = priv->prev;
+		dev->file_last = priv->prev;
 	}
-	up( &dev->struct_sem );
-	
+	up(&dev->struct_sem);
+
 	if (dev->driver->free_filp_priv)
 		dev->driver->free_filp_priv(dev, priv);
-
-	drm_free( priv, sizeof(*priv), DRM_MEM_FILES );
+	drm_free(priv, sizeof(*priv), DRM_MEM_FILES);
 
 	/* ========================================================
 	 * End inline drm_release
 	 */
 
-	atomic_inc( &dev->counts[_DRM_STAT_CLOSES] );
-	spin_lock( &dev->count_lock );
-	if ( !--dev->open_count ) {
-		if ( atomic_read( &dev->ioctl_count ) || dev->blocked ) {
-			DRM_ERROR( "Device busy: %d %d\n",
-				   atomic_read( &dev->ioctl_count ),
-				   dev->blocked );
-			spin_unlock( &dev->count_lock );
+	atomic_inc(&dev->counts[_DRM_STAT_CLOSES]);
+	spin_lock(&dev->count_lock);
+	if (!--dev->open_count) {
+		if (atomic_read(&dev->ioctl_count) || dev->blocked) {
+			DRM_ERROR("Device busy: %d %d\n",
+				  atomic_read(&dev->ioctl_count), dev->blocked);
+			spin_unlock(&dev->count_lock);
 			unlock_kernel();
 			return -EBUSY;
 		}
-		spin_unlock( &dev->count_lock );
+		spin_unlock(&dev->count_lock);
 		unlock_kernel();
-		return drm_takedown( dev );
+		return drm_takedown(dev);
 	}
-	spin_unlock( &dev->count_lock );
+	spin_unlock(&dev->count_lock);
 
 	unlock_kernel();
 
@@ -330,122 +471,19 @@ int drm_release( struct inode *inode, st
 }
 EXPORT_SYMBOL(drm_release);
 
-/**
- * Called whenever a process opens /dev/drm. 
- *
- * \param inode device inode.
- * \param filp file pointer.
- * \param dev device.
- * \return zero on success or a negative number on failure.
- * 
- * Creates and initializes a drm_file structure for the file private data in \p
- * filp and add it into the double linked list in \p dev.
- */
-int drm_open_helper(struct inode *inode, struct file *filp, drm_device_t *dev)
-{
-	int	     minor = iminor(inode);
-	drm_file_t   *priv;
-	int ret;
-
-	if (filp->f_flags & O_EXCL)   return -EBUSY; /* No exclusive opens */
-	if (!drm_cpu_valid())        return -EINVAL;
-
-	DRM_DEBUG("pid = %d, minor = %d\n", current->pid, minor);
-
-	priv		    = drm_alloc(sizeof(*priv), DRM_MEM_FILES);
-	if(!priv) return -ENOMEM;
-
-	memset(priv, 0, sizeof(*priv));
-	filp->private_data  = priv;
-	priv->uid	    = current->euid;
-	priv->pid	    = current->pid;
-	priv->minor	    = minor;
-	priv->head          = drm_heads[minor];
-	priv->ioctl_count   = 0;
-	priv->authenticated = capable(CAP_SYS_ADMIN);
-	priv->lock_count    = 0;
-
-	if (dev->driver->open_helper) {
-		ret=dev->driver->open_helper(dev, priv);
-		if (ret < 0)
-			goto out_free;
-	}
-
-	down(&dev->struct_sem);
-	if (!dev->file_last) {
-		priv->next	= NULL;
-		priv->prev	= NULL;
-		dev->file_first = priv;
-		dev->file_last	= priv;
-	} else {
-		priv->next	     = NULL;
-		priv->prev	     = dev->file_last;
-		dev->file_last->next = priv;
-		dev->file_last	     = priv;
-	}
-	up(&dev->struct_sem);
-
-#ifdef __alpha__
-	/*
-	 * Default the hose
-	 */
-	if (!dev->hose) {
-		struct pci_dev *pci_dev;
-		pci_dev = pci_get_class(PCI_CLASS_DISPLAY_VGA << 8, NULL);
-		if (pci_dev) {
-			dev->hose = pci_dev->sysdata;
-			pci_dev_put(pci_dev);
-		}
-		if (!dev->hose) {
-			struct pci_bus *b = pci_bus_b(pci_root_buses.next);
-			if (b) dev->hose = b->sysdata;
-		}
-	}
-#endif
-
-	return 0;
-out_free:
-	drm_free(priv, sizeof(*priv), DRM_MEM_FILES);
-	filp->private_data=NULL;
-	return ret;
-}
-
-/** No-op. */
-int drm_flush(struct file *filp)
-{
-	drm_file_t    *priv   = filp->private_data;
-	drm_device_t  *dev    = priv->head->dev;
-
-	DRM_DEBUG("pid = %d, device = 0x%lx, open_count = %d\n",
-		  current->pid, (long)old_encode_dev(priv->head->device), dev->open_count);
-	return 0;
-}
-EXPORT_SYMBOL(drm_flush);
-
-/** No-op. */
-int drm_fasync(int fd, struct file *filp, int on)
-{
-	drm_file_t    *priv   = filp->private_data;
-	drm_device_t  *dev    = priv->head->dev;
-	int	      retcode;
-
-	DRM_DEBUG("fd = %d, device = 0x%lx\n", fd, (long)old_encode_dev(priv->head->device));
-	retcode = fasync_helper(fd, filp, on, &dev->buf_async);
-	if (retcode < 0) return retcode;
-	return 0;
-}
-EXPORT_SYMBOL(drm_fasync);
-
 /** No-op. */
+/* This is to deal with older X servers that believe 0 means data is
+ * available which is not the correct return for a poll function.
+ * This cannot be fixed until the Xserver is fixed. Xserver will need
+ * to set a newer interface version to avoid breaking older Xservers.
+ * Without fixing the Xserver you get: "WaitForSomething(): select: errno=22"
+ * http://freedesktop.org/bugzilla/show_bug.cgi?id=1505 if you try
+ * to return the correct response. 
+ */
 unsigned int drm_poll(struct file *filp, struct poll_table_struct *wait)
 {
+	/* return (POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM); */
 	return 0;
 }
 EXPORT_SYMBOL(drm_poll);
 
-
-/** No-op. */
-ssize_t drm_read(struct file *filp, char __user *buf, size_t count, loff_t *off)
-{
-	return 0;
-}
diff -purN linux-2.6.12.orig/drivers/char/drm/drm.h linux-2.6.12/drivers/char/drm/drm.h
--- linux-2.6.12.orig/drivers/char/drm/drm.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/drm.h	2005-07-05 08:37:49.000000000 +0200
@@ -1,7 +1,7 @@
 /**
- * \file drm.h 
+ * \file drm.h
  * Header for the Direct Rendering Manager
- * 
+ *
  * \author Rickard E. (Rik) Faith <faith@valinux.com>
  *
  * \par Acknowledgments:
@@ -33,12 +33,39 @@
  * OTHER DEALINGS IN THE SOFTWARE.
  */
 
+/**
+ * \mainpage
+ *
+ * The Direct Rendering Manager (DRM) is a device-independent kernel-level
+ * device driver that provides support for the XFree86 Direct Rendering
+ * Infrastructure (DRI).
+ *
+ * The DRM supports the Direct Rendering Infrastructure (DRI) in four major
+ * ways:
+ *     -# The DRM provides synchronized access to the graphics hardware via
+ *        the use of an optimized two-tiered lock.
+ *     -# The DRM enforces the DRI security policy for access to the graphics
+ *        hardware by only allowing authenticated X11 clients access to
+ *        restricted regions of memory.
+ *     -# The DRM provides a generic DMA engine, complete with multiple
+ *        queues and the ability to detect the need for an OpenGL context
+ *        switch.
+ *     -# The DRM is extensible via the use of small device-specific modules
+ *        that rely extensively on the API exported by the DRM module.
+ *
+ */
 
 #ifndef _DRM_H_
 #define _DRM_H_
 
+#ifndef __user
+#define __user
+#endif
+
 #if defined(__linux__)
+#if defined(__KERNEL__)
 #include <linux/config.h>
+#endif
 #include <asm/ioctl.h>		/* For _IO* macros */
 #define DRM_IOCTL_NR(n)		_IOC_NR(n)
 #define DRM_IOC_VOID		_IOC_NONE
@@ -46,7 +73,7 @@
 #define DRM_IOC_WRITE		_IOC_WRITE
 #define DRM_IOC_READWRITE	_IOC_READ|_IOC_WRITE
 #define DRM_IOC(dir, group, nr, size) _IOC(dir, group, nr, size)
-#elif defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
+#elif defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__DragonFly__)
 #if defined(__FreeBSD__) && defined(IN_MODULE)
 /* Prevent name collision when including sys/ioccom.h */
 #undef ioctl
@@ -54,7 +81,7 @@
 #define ioctl(a,b,c)		xf86ioctl(a,b,c)
 #else
 #include <sys/ioccom.h>
-#endif /* __FreeBSD__ && xf86ioctl */
+#endif				/* __FreeBSD__ && xf86ioctl */
 #define DRM_IOCTL_NR(n)		((n) & 0xff)
 #define DRM_IOC_VOID		IOC_VOID
 #define DRM_IOC_READ		IOC_OUT
@@ -81,53 +108,55 @@
 #endif
 
 #if CONFIG_XFREE86_VERSION >= XFREE86_VERSION(4,1,0,0)
+#ifdef __OpenBSD__
+#define DRM_MAJOR       81
+#endif
+#if defined(__linux__) || defined(__NetBSD__)
 #define DRM_MAJOR       226
-#define DRM_MAX_MINOR   15
+#endif
+#define DRM_MAX_MINOR   255
 #endif
 #define DRM_NAME	"drm"	  /**< Name in kernel, /dev, and /proc */
 #define DRM_MIN_ORDER	5	  /**< At least 2^5 bytes = 32 bytes */
 #define DRM_MAX_ORDER	22	  /**< Up to 2^22 bytes = 4MB */
 #define DRM_RAM_PERCENT 10	  /**< How much system ram can we lock? */
 
-#define _DRM_LOCK_HELD	0x80000000 /**< Hardware lock is held */
-#define _DRM_LOCK_CONT	0x40000000 /**< Hardware lock is contended */
+#define _DRM_LOCK_HELD	0x80000000U /**< Hardware lock is held */
+#define _DRM_LOCK_CONT	0x40000000U /**< Hardware lock is contended */
 #define _DRM_LOCK_IS_HELD(lock)	   ((lock) & _DRM_LOCK_HELD)
 #define _DRM_LOCK_IS_CONT(lock)	   ((lock) & _DRM_LOCK_CONT)
 #define _DRM_LOCKING_CONTEXT(lock) ((lock) & ~(_DRM_LOCK_HELD|_DRM_LOCK_CONT))
 
-
-typedef unsigned long drm_handle_t;
-typedef unsigned int  drm_context_t;
-typedef unsigned int  drm_drawable_t;
-typedef unsigned int  drm_magic_t;
-
+typedef unsigned long drm_handle_t;	/**< To mapped regions */
+typedef unsigned int drm_context_t;	/**< GLXContext handle */
+typedef unsigned int drm_drawable_t;
+typedef unsigned int drm_magic_t;	/**< Magic for authentication */
 
 /**
  * Cliprect.
- * 
- * \warning: If you change this structure, make sure you change
+ *
+ * \warning If you change this structure, make sure you change
  * XF86DRIClipRectRec in the server as well
  *
  * \note KW: Actually it's illegal to change either for
  * backwards-compatibility reasons.
  */
 typedef struct drm_clip_rect {
-	unsigned short	x1;
-	unsigned short	y1;
-	unsigned short	x2;
-	unsigned short	y2;
+	unsigned short x1;
+	unsigned short y1;
+	unsigned short x2;
+	unsigned short y2;
 } drm_clip_rect_t;
 
-
 /**
  * Texture region,
  */
 typedef struct drm_tex_region {
-	unsigned char	next;
-	unsigned char	prev;
-	unsigned char	in_use;
-	unsigned char	padding;
-	unsigned int	age;
+	unsigned char next;
+	unsigned char prev;
+	unsigned char in_use;
+	unsigned char padding;
+	unsigned int age;
 } drm_tex_region_t;
 
 /**
@@ -139,50 +168,63 @@ typedef struct drm_tex_region {
  */
 typedef struct drm_hw_lock {
 	__volatile__ unsigned int lock;		/**< lock variable */
-	char			  padding[60];	/**< Pad to cache line */
+	char padding[60];			/**< Pad to cache line */
 } drm_hw_lock_t;
 
+/* This is beyond ugly, and only works on GCC.  However, it allows me to use
+ * drm.h in places (i.e., in the X-server) where I can't use size_t.  The real
+ * fix is to use uint32_t instead of size_t, but that fix will break existing
+ * LP64 (i.e., PowerPC64, SPARC64, IA-64, Alpha, etc.) systems.  That *will*
+ * eventually happen, though.  I chose 'unsigned long' to be the fallback type
+ * because that works on all the platforms I know about.  Hopefully, the
+ * real fix will happen before that bites us.
+ */
+
+#ifdef __SIZE_TYPE__
+# define DRM_SIZE_T __SIZE_TYPE__
+#else
+# warning "__SIZE_TYPE__ not defined.  Assuming sizeof(size_t) == sizeof(unsigned long)!"
+# define DRM_SIZE_T unsigned long
+#endif
 
 /**
  * DRM_IOCTL_VERSION ioctl argument type.
- * 
+ *
  * \sa drmGetVersion().
  */
 typedef struct drm_version {
-	int    version_major;	  /**< Major version */
-	int    version_minor;	  /**< Minor version */
-	int    version_patchlevel;/**< Patch level */
-	size_t name_len;	  /**< Length of name buffer */
-	char   __user *name;	  /**< Name of driver */
-	size_t date_len;	  /**< Length of date buffer */
-	char   __user *date;	  /**< User-space buffer to hold date */
-	size_t desc_len;	  /**< Length of desc buffer */
-	char   __user *desc;	  /**< User-space buffer to hold desc */
+	int version_major;	  /**< Major version */
+	int version_minor;	  /**< Minor version */
+	int version_patchlevel;	  /**< Patch level */
+	DRM_SIZE_T name_len;	  /**< Length of name buffer */
+	char __user *name;		  /**< Name of driver */
+	DRM_SIZE_T date_len;	  /**< Length of date buffer */
+	char __user *date;		  /**< User-space buffer to hold date */
+	DRM_SIZE_T desc_len;	  /**< Length of desc buffer */
+	char __user *desc;		  /**< User-space buffer to hold desc */
 } drm_version_t;
 
-
 /**
  * DRM_IOCTL_GET_UNIQUE ioctl argument type.
  *
  * \sa drmGetBusid() and drmSetBusId().
  */
 typedef struct drm_unique {
-	size_t unique_len;	  /**< Length of unique */
-	char   __user *unique;	  /**< Unique name for driver instantiation */
+	DRM_SIZE_T unique_len;	  /**< Length of unique */
+	char __user *unique;		  /**< Unique name for driver instantiation */
 } drm_unique_t;
 
+#undef DRM_SIZE_T
 
 typedef struct drm_list {
-	int		 count;	  /**< Length of user-space structures */
-	drm_version_t	 __user *version;
+	int count;		  /**< Length of user-space structures */
+	drm_version_t __user *version;
 } drm_list_t;
 
-
 typedef struct drm_block {
-	int		 unused;
+	int unused;
 } drm_block_t;
 
-
 /**
  * DRM_IOCTL_CONTROL ioctl argument type.
  *
@@ -194,43 +236,40 @@ typedef struct drm_control {
 		DRM_RM_COMMAND,
 		DRM_INST_HANDLER,
 		DRM_UNINST_HANDLER
-	}		 func;
-	int		 irq;
+	} func;
+	int irq;
 } drm_control_t;
 
-
 /**
  * Type of memory to map.
  */
 typedef enum drm_map_type {
-	_DRM_FRAME_BUFFER   = 0,  /**< WC (no caching), no core dump */
-	_DRM_REGISTERS	    = 1,  /**< no caching, no core dump */
-	_DRM_SHM	    = 2,  /**< shared, cached */
-	_DRM_AGP            = 3,  /**< AGP/GART */
-	_DRM_SCATTER_GATHER = 4	  /**< Scatter/gather memory for PCI DMA */
+	_DRM_FRAME_BUFFER = 0,	  /**< WC (no caching), no core dump */
+	_DRM_REGISTERS = 1,	  /**< no caching, no core dump */
+	_DRM_SHM = 2,		  /**< shared, cached */
+	_DRM_AGP = 3,		  /**< AGP/GART */
+	_DRM_SCATTER_GATHER = 4,  /**< Scatter/gather memory for PCI DMA */
+	_DRM_CONSISTENT = 5	  /**< Consistent memory for PCI DMA */
 } drm_map_type_t;
 
-
 /**
  * Memory mapping flags.
  */
 typedef enum drm_map_flags {
-	_DRM_RESTRICTED	     = 0x01, /**< Cannot be mapped to user-virtual */
-	_DRM_READ_ONLY	     = 0x02,
-	_DRM_LOCKED	     = 0x04, /**< shared, cached, locked */
-	_DRM_KERNEL	     = 0x08, /**< kernel requires access */
+	_DRM_RESTRICTED = 0x01,	     /**< Cannot be mapped to user-virtual */
+	_DRM_READ_ONLY = 0x02,
+	_DRM_LOCKED = 0x04,	     /**< shared, cached, locked */
+	_DRM_KERNEL = 0x08,	     /**< kernel requires access */
 	_DRM_WRITE_COMBINING = 0x10, /**< use write-combining if available */
-	_DRM_CONTAINS_LOCK   = 0x20, /**< SHM page that contains lock */
-	_DRM_REMOVABLE	     = 0x40  /**< Removable mapping */
+	_DRM_CONTAINS_LOCK = 0x20,   /**< SHM page that contains lock */
+	_DRM_REMOVABLE = 0x40	     /**< Removable mapping */
 } drm_map_flags_t;
 
-
 typedef struct drm_ctx_priv_map {
-	unsigned int	ctx_id;  /**< Context requesting private mapping */
-	void		*handle; /**< Handle of map */
+	unsigned int ctx_id;	 /**< Context requesting private mapping */
+	void *handle;		 /**< Handle of map */
 } drm_ctx_priv_map_t;
 
-
 /**
  * DRM_IOCTL_GET_MAP, DRM_IOCTL_ADD_MAP and DRM_IOCTL_RM_MAP ioctls
  * argument type.
@@ -238,30 +277,28 @@ typedef struct drm_ctx_priv_map {
  * \sa drmAddMap().
  */
 typedef struct drm_map {
-	unsigned long	offset;	 /**< Requested physical address (0 for SAREA)*/
-	unsigned long	size;	 /**< Requested physical size (bytes) */
-	drm_map_type_t	type;	 /**< Type of memory to map */
+	unsigned long offset;	 /**< Requested physical address (0 for SAREA)*/
+	unsigned long size;	 /**< Requested physical size (bytes) */
+	drm_map_type_t type;	 /**< Type of memory to map */
 	drm_map_flags_t flags;	 /**< Flags */
-	void		*handle; /**< User-space: "Handle" to pass to mmap() */
+	void *handle;		 /**< User-space: "Handle" to pass to mmap() */
 				 /**< Kernel-space: kernel-virtual address */
-	int		mtrr;	 /**< MTRR slot used */
-				 /*   Private data */
+	int mtrr;		 /**< MTRR slot used */
+	/*   Private data */
 } drm_map_t;
 
-
 /**
  * DRM_IOCTL_GET_CLIENT ioctl argument type.
  */
 typedef struct drm_client {
-	int		idx;	/**< Which client desired? */
-	int		auth;	/**< Is client authenticated? */
-	unsigned long	pid;	/**< Process ID */
-	unsigned long	uid;	/**< User ID */
-	unsigned long	magic;	/**< Magic */
-	unsigned long	iocs;	/**< Ioctl count */
+	int idx;		/**< Which client desired? */
+	int auth;		/**< Is client authenticated? */
+	unsigned long pid;	/**< Process ID */
+	unsigned long uid;	/**< User ID */
+	unsigned long magic;	/**< Magic */
+	unsigned long iocs;	/**< Ioctl count */
 } drm_client_t;
 
-
 typedef enum {
 	_DRM_STAT_LOCK,
 	_DRM_STAT_OPENS,
@@ -279,63 +316,58 @@ typedef enum {
 	_DRM_STAT_DMA,		/**< DMA */
 	_DRM_STAT_SPECIAL,	/**< Special DMA (e.g., priority or polled) */
 	_DRM_STAT_MISSED	/**< Missed DMA opportunity */
-
-				/* Add to the *END* of the list */
+	    /* Add to the *END* of the list */
 } drm_stat_type_t;
 
-
 /**
  * DRM_IOCTL_GET_STATS ioctl argument type.
  */
 typedef struct drm_stats {
 	unsigned long count;
 	struct {
-		unsigned long   value;
+		unsigned long value;
 		drm_stat_type_t type;
 	} data[15];
 } drm_stats_t;
 
-
 /**
  * Hardware locking flags.
  */
 typedef enum drm_lock_flags {
-	_DRM_LOCK_READY	     = 0x01, /**< Wait until hardware is ready for DMA */
-	_DRM_LOCK_QUIESCENT  = 0x02, /**< Wait until hardware quiescent */
-	_DRM_LOCK_FLUSH	     = 0x04, /**< Flush this context's DMA queue first */
-	_DRM_LOCK_FLUSH_ALL  = 0x08, /**< Flush all DMA queues first */
-				/* These *HALT* flags aren't supported yet
-				   -- they will be used to support the
-				   full-screen DGA-like mode. */
+	_DRM_LOCK_READY = 0x01,	     /**< Wait until hardware is ready for DMA */
+	_DRM_LOCK_QUIESCENT = 0x02,  /**< Wait until hardware quiescent */
+	_DRM_LOCK_FLUSH = 0x04,	     /**< Flush this context's DMA queue first */
+	_DRM_LOCK_FLUSH_ALL = 0x08,  /**< Flush all DMA queues first */
+	/* These *HALT* flags aren't supported yet
+	   -- they will be used to support the
+	   full-screen DGA-like mode. */
 	_DRM_HALT_ALL_QUEUES = 0x10, /**< Halt all current and future queues */
 	_DRM_HALT_CUR_QUEUES = 0x20  /**< Halt all current queues */
 } drm_lock_flags_t;
 
-
 /**
  * DRM_IOCTL_LOCK, DRM_IOCTL_UNLOCK and DRM_IOCTL_FINISH ioctl argument type.
- * 
+ *
  * \sa drmGetLock() and drmUnlock().
  */
 typedef struct drm_lock {
-	int		 context;
+	int context;
 	drm_lock_flags_t flags;
 } drm_lock_t;
 
-
 /**
  * DMA flags
  *
- * \warning 
+ * \warning
  * These values \e must match xf86drm.h.
  *
  * \sa drm_dma.
  */
-typedef enum drm_dma_flags {	      
-				      /* Flags for DMA buffer dispatch */
-	_DRM_DMA_BLOCK	      = 0x01, /**<
+typedef enum drm_dma_flags {
+	/* Flags for DMA buffer dispatch */
+	_DRM_DMA_BLOCK = 0x01,	      /**<
 				       * Block until buffer dispatched.
-				       * 
+				       *
 				       * \note The buffer may not yet have
 				       * been processed by the hardware --
 				       * getting a hardware lock with the
@@ -344,78 +376,77 @@ typedef enum drm_dma_flags {	      
 				       * processed.
 				       */
 	_DRM_DMA_WHILE_LOCKED = 0x02, /**< Dispatch while lock held */
-	_DRM_DMA_PRIORITY     = 0x04, /**< High priority dispatch */
+	_DRM_DMA_PRIORITY = 0x04,     /**< High priority dispatch */
 
-				      /* Flags for DMA buffer request */
-	_DRM_DMA_WAIT	      = 0x10, /**< Wait for free buffers */
-	_DRM_DMA_SMALLER_OK   = 0x20, /**< Smaller-than-requested buffers OK */
-	_DRM_DMA_LARGER_OK    = 0x40  /**< Larger-than-requested buffers OK */
+	/* Flags for DMA buffer request */
+	_DRM_DMA_WAIT = 0x10,	      /**< Wait for free buffers */
+	_DRM_DMA_SMALLER_OK = 0x20,   /**< Smaller-than-requested buffers OK */
+	_DRM_DMA_LARGER_OK = 0x40     /**< Larger-than-requested buffers OK */
 } drm_dma_flags_t;
 
-
 /**
  * DRM_IOCTL_ADD_BUFS and DRM_IOCTL_MARK_BUFS ioctl argument type.
  *
  * \sa drmAddBufs().
  */
 typedef struct drm_buf_desc {
-	int	      count;	 /**< Number of buffers of this size */
-	int	      size;	 /**< Size in bytes */
-	int	      low_mark;	 /**< Low water mark */
-	int	      high_mark; /**< High water mark */
+	int count;		 /**< Number of buffers of this size */
+	int size;		 /**< Size in bytes */
+	int low_mark;		 /**< Low water mark */
+	int high_mark;		 /**< High water mark */
 	enum {
-		_DRM_PAGE_ALIGN = 0x01, /**< Align on page boundaries for DMA */
-		_DRM_AGP_BUFFER = 0x02, /**< Buffer is in AGP space */
-		_DRM_SG_BUFFER  = 0x04  /**< Scatter/gather memory buffer */
-	}	      flags;
-	unsigned long agp_start; /**< 
+		_DRM_PAGE_ALIGN = 0x01,	/**< Align on page boundaries for DMA */
+		_DRM_AGP_BUFFER = 0x02,	/**< Buffer is in AGP space */
+		_DRM_SG_BUFFER  = 0x04,	/**< Scatter/gather memory buffer */
+		_DRM_FB_BUFFER  = 0x08  /**< Buffer is in frame buffer */
+	} flags;
+	unsigned long agp_start; /**<
 				  * Start address of where the AGP buffers are
 				  * in the AGP aperture
 				  */
 } drm_buf_desc_t;
 
-
 /**
  * DRM_IOCTL_INFO_BUFS ioctl argument type.
  */
 typedef struct drm_buf_info {
-	int	       count;	/**< Entries in list */
-	drm_buf_desc_t __user *list;
+	int count;		  /**< Number of buffers described in list */
+	drm_buf_desc_t __user *list;	  /**< List of buffer descriptions */
 } drm_buf_info_t;
 
-
 /**
  * DRM_IOCTL_FREE_BUFS ioctl argument type.
  */
 typedef struct drm_buf_free {
-	int	       count;
-	int	       __user *list;
+	int count;
+	int __user *list;
 } drm_buf_free_t;
 
-
 /**
  * Buffer information
  *
  * \sa drm_buf_map.
  */
 typedef struct drm_buf_pub {
-	int		  idx;	       /**< Index into the master buffer list */
-	int		  total;       /**< Buffer size */
-	int		  used;	       /**< Amount of buffer in use (for DMA) */
-	void	  __user *address;     /**< Address of buffer */
+	int idx;		       /**< Index into the master buffer list */
+	int total;		       /**< Buffer size */
+	int used;		       /**< Amount of buffer in use (for DMA) */
+	void __user *address;	       /**< Address of buffer */
 } drm_buf_pub_t;
 
-
 /**
  * DRM_IOCTL_MAP_BUFS ioctl argument type.
  */
 typedef struct drm_buf_map {
-	int	      count;	/**< Length of the buffer list */
-	void	      __user *virtual;	/**< Mmap'd area in user-virtual */
+	int count;		/**< Length of the buffer list */
+#if defined(__cplusplus)
+	void __user *c_virtual;
+#else
+	void __user *virtual;		/**< Mmap'd area in user-virtual */
+#endif
 	drm_buf_pub_t __user *list;	/**< Buffer information */
 } drm_buf_map_t;
 
-
 /**
  * DRM_IOCTL_DMA ioctl argument type.
  *
@@ -424,61 +455,55 @@ typedef struct drm_buf_map {
  * \sa drmDMA().
  */
 typedef struct drm_dma {
-	int		context;	  /**< Context handle */
-	int		send_count;	  /**< Number of buffers to send */
-	int	__user *send_indices;	  /**< List of handles to buffers */
-	int	__user *send_sizes;	  /**< Lengths of data to send */
+	int context;			  /**< Context handle */
+	int send_count;			  /**< Number of buffers to send */
+	int __user *send_indices;	  /**< List of handles to buffers */
+	int __user *send_sizes;		  /**< Lengths of data to send */
 	drm_dma_flags_t flags;		  /**< Flags */
-	int		request_count;	  /**< Number of buffers requested */
-	int		request_size;	  /**< Desired size for buffers */
-	int	__user *request_indices;  /**< Buffer information */
-	int	__user *request_sizes;
-	int		granted_count;	  /**< Number of buffers granted */
+	int request_count;		  /**< Number of buffers requested */
+	int request_size;		  /**< Desired size for buffers */
+	int __user *request_indices;	 /**< Buffer information */
+	int __user *request_sizes;
+	int granted_count;		  /**< Number of buffers granted */
 } drm_dma_t;
 
-
 typedef enum {
 	_DRM_CONTEXT_PRESERVED = 0x01,
-	_DRM_CONTEXT_2DONLY    = 0x02
+	_DRM_CONTEXT_2DONLY = 0x02
 } drm_ctx_flags_t;
 
-
 /**
  * DRM_IOCTL_ADD_CTX ioctl argument type.
  *
  * \sa drmCreateContext() and drmDestroyContext().
  */
 typedef struct drm_ctx {
-	drm_context_t	handle;
+	drm_context_t handle;
 	drm_ctx_flags_t flags;
 } drm_ctx_t;
 
-
 /**
  * DRM_IOCTL_RES_CTX ioctl argument type.
  */
 typedef struct drm_ctx_res {
-	int		count;
-	drm_ctx_t	__user *contexts;
+	int count;
+	drm_ctx_t __user *contexts;
 } drm_ctx_res_t;
 
-
 /**
  * DRM_IOCTL_ADD_DRAW and DRM_IOCTL_RM_DRAW ioctl argument type.
  */
 typedef struct drm_draw {
-	drm_drawable_t	handle;
+	drm_drawable_t handle;
 } drm_draw_t;
 
-
 /**
  * DRM_IOCTL_GET_MAGIC and DRM_IOCTL_AUTH_MAGIC ioctl argument type.
  */
 typedef struct drm_auth {
-	drm_magic_t	magic;
+	drm_magic_t magic;
 } drm_auth_t;
 
-
 /**
  * DRM_IOCTL_IRQ_BUSID ioctl argument type.
  *
@@ -491,24 +516,20 @@ typedef struct drm_irq_busid {
 	int funcnum;	/**< function number */
 } drm_irq_busid_t;
 
-
 typedef enum {
-    _DRM_VBLANK_ABSOLUTE = 0x0,		/**< Wait for specific vblank sequence number */
-    _DRM_VBLANK_RELATIVE = 0x1,		/**< Wait for given number of vblanks */
-    _DRM_VBLANK_SIGNAL   = 0x40000000	/**< Send signal instead of blocking */
+	_DRM_VBLANK_ABSOLUTE = 0x0,	/**< Wait for specific vblank sequence number */
+	_DRM_VBLANK_RELATIVE = 0x1,	/**< Wait for given number of vblanks */
+	_DRM_VBLANK_SIGNAL = 0x40000000	/**< Send signal instead of blocking */
 } drm_vblank_seq_type_t;
 
-
 #define _DRM_VBLANK_FLAGS_MASK _DRM_VBLANK_SIGNAL
 
-
 struct drm_wait_vblank_request {
 	drm_vblank_seq_type_t type;
 	unsigned int sequence;
 	unsigned long signal;
 };
 
-
 struct drm_wait_vblank_reply {
 	drm_vblank_seq_type_t type;
 	unsigned int sequence;
@@ -516,7 +537,6 @@ struct drm_wait_vblank_reply {
 	long tval_usec;
 };
 
-
 /**
  * DRM_IOCTL_WAIT_VBLANK ioctl argument type.
  *
@@ -527,7 +547,6 @@ typedef union drm_wait_vblank {
 	struct drm_wait_vblank_reply reply;
 } drm_wait_vblank_t;
 
-
 /**
  * DRM_IOCTL_AGP_ENABLE ioctl argument type.
  *
@@ -537,7 +556,6 @@ typedef struct drm_agp_mode {
 	unsigned long mode;	/**< AGP mode */
 } drm_agp_mode_t;
 
-
 /**
  * DRM_IOCTL_AGP_ALLOC and DRM_IOCTL_AGP_FREE ioctls argument type.
  *
@@ -546,22 +564,20 @@ typedef struct drm_agp_mode {
 typedef struct drm_agp_buffer {
 	unsigned long size;	/**< In bytes -- will round to page boundary */
 	unsigned long handle;	/**< Used for binding / unbinding */
-	unsigned long type;     /**< Type of memory to allocate */
-        unsigned long physical; /**< Physical used by i810 */
+	unsigned long type;	/**< Type of memory to allocate */
+	unsigned long physical;	/**< Physical used by i810 */
 } drm_agp_buffer_t;
 
-
 /**
  * DRM_IOCTL_AGP_BIND and DRM_IOCTL_AGP_UNBIND ioctls argument type.
  *
  * \sa drmAgpBind() and drmAgpUnbind().
  */
 typedef struct drm_agp_binding {
-	unsigned long handle;   /**< From drm_agp_buffer */
+	unsigned long handle;	/**< From drm_agp_buffer */
 	unsigned long offset;	/**< In bytes -- will round to page boundary */
 } drm_agp_binding_t;
 
-
 /**
  * DRM_IOCTL_AGP_INFO ioctl argument type.
  *
@@ -570,20 +586,21 @@ typedef struct drm_agp_binding {
  * drmAgpVendorId() and drmAgpDeviceId().
  */
 typedef struct drm_agp_info {
-	int            agp_version_major;
-	int            agp_version_minor;
-	unsigned long  mode;
-	unsigned long  aperture_base;  /* physical address */
-	unsigned long  aperture_size;  /* bytes */
-	unsigned long  memory_allowed; /* bytes */
-	unsigned long  memory_used;
+	int agp_version_major;
+	int agp_version_minor;
+	unsigned long mode;
+	unsigned long aperture_base;   /**< physical address */
+	unsigned long aperture_size;   /**< bytes */
+	unsigned long memory_allowed;  /**< bytes */
+	unsigned long memory_used;
 
-				/* PCI information */
+	/** \name PCI information */
+	/*@{ */
 	unsigned short id_vendor;
 	unsigned short id_device;
+	/*@} */
 } drm_agp_info_t;
 
-
 /**
  * DRM_IOCTL_SG_ALLOC ioctl argument type.
  */
@@ -602,6 +619,10 @@ typedef struct drm_set_version {
 	int drm_dd_minor;
 } drm_set_version_t;
 
+/**
+ * \name Ioctls Definitions
+ */
+/*@{*/
 
 #define DRM_IOCTL_BASE			'd'
 #define DRM_IO(nr)			_IO(DRM_IOCTL_BASE,nr)
@@ -663,6 +684,8 @@ typedef struct drm_set_version {
 
 #define DRM_IOCTL_WAIT_VBLANK		DRM_IOWR(0x3a, drm_wait_vblank_t)
 
+/*@}*/
+
 /**
  * Device specific ioctls should only be in their respective headers
  * The device specific ioctl range is from 0x40 to 0x79.
diff -purN linux-2.6.12.orig/drivers/char/drm/drm_init.c linux-2.6.12/drivers/char/drm/drm_init.c
--- linux-2.6.12.orig/drivers/char/drm/drm_init.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/drm_init.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,52 +0,0 @@
-/**
- * \file drm_init.h 
- * Setup/Cleanup for DRM
- *
- * \author Rickard E. (Rik) Faith <faith@valinux.com>
- * \author Gareth Hughes <gareth@valinux.com>
- */
-
-/*
- * Created: Mon Jan  4 08:58:31 1999 by faith@valinux.com
- *
- * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
- * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "drmP.h"
-
-/**
- * Check whether DRI will run on this CPU.
- *
- * \return non-zero if the DRI will run on this CPU, or zero otherwise.
- */
-int drm_cpu_valid(void)
-{
-#if defined(__i386__)
-	if (boot_cpu_data.x86 == 3) return 0; /* No cmpxchg on a 386 */
-#endif
-#if defined(__sparc__) && !defined(__sparc_v9__)
-	return 0; /* No cmpxchg before v9 sparc. */
-#endif
-	return 1;
-}
diff -purN linux-2.6.12.orig/drivers/char/drm/drm_ioctl.c linux-2.6.12/drivers/char/drm/drm_ioctl.c
--- linux-2.6.12.orig/drivers/char/drm/drm_ioctl.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/drm_ioctl.c	2005-07-05 08:37:27.000000000 +0200
@@ -1,5 +1,5 @@
 /**
- * \file drm_ioctl.h 
+ * \file drm_ioctl.c
  * IOCTL processing for DRM
  *
  * \author Rickard E. (Rik) Faith <faith@valinux.com>
@@ -40,7 +40,7 @@
 
 /**
  * Get the bus id.
- * 
+ *
  * \param inode device inode.
  * \param filp file pointer.
  * \param cmd command.
@@ -50,12 +50,12 @@
  * Copies the bus id from drm_device::unique into user space.
  */
 int drm_getunique(struct inode *inode, struct file *filp,
-		   unsigned int cmd, unsigned long arg)
+		  unsigned int cmd, unsigned long arg)
 {
-	drm_file_t	 *priv	 = filp->private_data;
-	drm_device_t	 *dev	 = priv->head->dev;
-	drm_unique_t	 __user *argp = (void __user *)arg;
-	drm_unique_t	 u;
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
+	drm_unique_t __user *argp = (void __user *)arg;
+	drm_unique_t u;
 
 	if (copy_from_user(&u, argp, sizeof(u)))
 		return -EFAULT;
@@ -71,7 +71,7 @@ int drm_getunique(struct inode *inode, s
 
 /**
  * Set the bus id.
- * 
+ *
  * \param inode device inode.
  * \param filp file pointer.
  * \param cmd command.
@@ -84,30 +84,33 @@ int drm_getunique(struct inode *inode, s
  * version 1.1 or greater.
  */
 int drm_setunique(struct inode *inode, struct file *filp,
-		   unsigned int cmd, unsigned long arg)
+		  unsigned int cmd, unsigned long arg)
 {
-	drm_file_t	 *priv	 = filp->private_data;
-	drm_device_t	 *dev	 = priv->head->dev;
-	drm_unique_t	 u;
-	int		 domain, bus, slot, func, ret;
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
+	drm_unique_t u;
+	int domain, bus, slot, func, ret;
 
-	if (dev->unique_len || dev->unique) return -EBUSY;
+	if (dev->unique_len || dev->unique)
+		return -EBUSY;
 
-	if (copy_from_user(&u, (drm_unique_t __user *)arg, sizeof(u)))
+	if (copy_from_user(&u, (drm_unique_t __user *) arg, sizeof(u)))
 		return -EFAULT;
 
-	if (!u.unique_len || u.unique_len > 1024) return -EINVAL;
+	if (!u.unique_len || u.unique_len > 1024)
+		return -EINVAL;
 
 	dev->unique_len = u.unique_len;
-	dev->unique	= drm_alloc(u.unique_len + 1, DRM_MEM_DRIVER);
-	if(!dev->unique) return -ENOMEM;
+	dev->unique = drm_alloc(u.unique_len + 1, DRM_MEM_DRIVER);
+	if (!dev->unique)
+		return -ENOMEM;
 	if (copy_from_user(dev->unique, u.unique, dev->unique_len))
 		return -EFAULT;
 
 	dev->unique[dev->unique_len] = '\0';
 
 	dev->devname = drm_alloc(strlen(dev->driver->pci_driver.name) + strlen(dev->unique) + 2,
-				  DRM_MEM_DRIVER);
+				 DRM_MEM_DRIVER);
 	if (!dev->devname)
 		return -ENOMEM;
 
@@ -121,32 +124,33 @@ int drm_setunique(struct inode *inode, s
 		return DRM_ERR(EINVAL);
 	domain = bus >> 8;
 	bus &= 0xff;
-	
+
 	if ((domain != dev->pci_domain) ||
 	    (bus != dev->pci_bus) ||
-	    (slot != dev->pci_slot) ||
-	    (func != dev->pci_func))
+	    (slot != dev->pci_slot) || (func != dev->pci_func))
 		return -EINVAL;
 
 	return 0;
 }
 
-static int
-drm_set_busid(drm_device_t *dev)
+static int drm_set_busid(drm_device_t * dev)
 {
+	int len;
 	if (dev->unique != NULL)
 		return EBUSY;
 
-	dev->unique_len = 20;
+	dev->unique_len = 40;
 	dev->unique = drm_alloc(dev->unique_len + 1, DRM_MEM_DRIVER);
 	if (dev->unique == NULL)
 		return ENOMEM;
 
-	snprintf(dev->unique, dev->unique_len, "pci:%04x:%02x:%02x.%d",
-		dev->pci_domain, dev->pci_bus, dev->pci_slot, dev->pci_func);
+	len = snprintf(dev->unique, dev->unique_len, "pci:%04x:%02x:%02x.%d",
+		 dev->pci_domain, dev->pci_bus, dev->pci_slot, dev->pci_func);
+	if (len > dev->unique_len)
+		DRM_ERROR("buffer overflow");
 
 	dev->devname = drm_alloc(strlen(dev->driver->pci_driver.name) + dev->unique_len + 2,
-				DRM_MEM_DRIVER);
+				 DRM_MEM_DRIVER);
 	if (dev->devname == NULL)
 		return ENOMEM;
 
@@ -155,7 +159,6 @@ drm_set_busid(drm_device_t *dev)
 	return 0;
 }
 
-
 /**
  * Get a mapping information.
  *
@@ -163,23 +166,23 @@ drm_set_busid(drm_device_t *dev)
  * \param filp file pointer.
  * \param cmd command.
  * \param arg user argument, pointing to a drm_map structure.
- * 
+ *
  * \return zero on success or a negative number on failure.
  *
  * Searches for the mapping with the specified offset and copies its information
  * into userspace
  */
-int drm_getmap( struct inode *inode, struct file *filp,
-		 unsigned int cmd, unsigned long arg )
+int drm_getmap(struct inode *inode, struct file *filp,
+	       unsigned int cmd, unsigned long arg)
 {
-	drm_file_t   *priv = filp->private_data;
-	drm_device_t *dev  = priv->head->dev;
-	drm_map_t    __user *argp = (void __user *)arg;
-	drm_map_t    map;
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
+	drm_map_t __user *argp = (void __user *)arg;
+	drm_map_t map;
 	drm_map_list_t *r_list = NULL;
 	struct list_head *list;
-	int          idx;
-	int	     i;
+	int idx;
+	int i;
 
 	if (copy_from_user(&map, argp, sizeof(map)))
 		return -EFAULT;
@@ -193,26 +196,27 @@ int drm_getmap( struct inode *inode, str
 
 	i = 0;
 	list_for_each(list, &dev->maplist->head) {
-		if(i == idx) {
+		if (i == idx) {
 			r_list = list_entry(list, drm_map_list_t, head);
 			break;
 		}
 		i++;
 	}
-	if(!r_list || !r_list->map) {
+	if (!r_list || !r_list->map) {
 		up(&dev->struct_sem);
 		return -EINVAL;
 	}
 
 	map.offset = r_list->map->offset;
-	map.size   = r_list->map->size;
-	map.type   = r_list->map->type;
-	map.flags  = r_list->map->flags;
+	map.size = r_list->map->size;
+	map.type = r_list->map->type;
+	map.flags = r_list->map->flags;
 	map.handle = r_list->map->handle;
-	map.mtrr   = r_list->map->mtrr;
+	map.mtrr = r_list->map->mtrr;
 	up(&dev->struct_sem);
 
-	if (copy_to_user(argp, &map, sizeof(map))) return -EFAULT;
+	if (copy_to_user(argp, &map, sizeof(map)))
+		return -EFAULT;
 	return 0;
 }
 
@@ -223,83 +227,81 @@ int drm_getmap( struct inode *inode, str
  * \param filp file pointer.
  * \param cmd command.
  * \param arg user argument, pointing to a drm_client structure.
- * 
+ *
  * \return zero on success or a negative number on failure.
  *
  * Searches for the client with the specified index and copies its information
  * into userspace
  */
-int drm_getclient( struct inode *inode, struct file *filp,
-		    unsigned int cmd, unsigned long arg )
+int drm_getclient(struct inode *inode, struct file *filp,
+		  unsigned int cmd, unsigned long arg)
 {
-	drm_file_t   *priv = filp->private_data;
-	drm_device_t *dev  = priv->head->dev;
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
 	drm_client_t __user *argp = (void __user *)arg;
 	drm_client_t client;
-	drm_file_t   *pt;
-	int          idx;
-	int          i;
+	drm_file_t *pt;
+	int idx;
+	int i;
 
 	if (copy_from_user(&client, argp, sizeof(client)))
 		return -EFAULT;
 	idx = client.idx;
 	down(&dev->struct_sem);
-	for (i = 0, pt = dev->file_first; i < idx && pt; i++, pt = pt->next)
-		;
+	for (i = 0, pt = dev->file_first; i < idx && pt; i++, pt = pt->next) ;
 
 	if (!pt) {
 		up(&dev->struct_sem);
 		return -EINVAL;
 	}
-	client.auth  = pt->authenticated;
-	client.pid   = pt->pid;
-	client.uid   = pt->uid;
+	client.auth = pt->authenticated;
+	client.pid = pt->pid;
+	client.uid = pt->uid;
 	client.magic = pt->magic;
-	client.iocs  = pt->ioctl_count;
+	client.iocs = pt->ioctl_count;
 	up(&dev->struct_sem);
 
-	if (copy_to_user((drm_client_t __user *)arg, &client, sizeof(client)))
+	if (copy_to_user(argp, &client, sizeof(client)))
 		return -EFAULT;
 	return 0;
 }
 
-/** 
- * Get statistics information. 
- * 
+/**
+ * Get statistics information.
+ *
  * \param inode device inode.
  * \param filp file pointer.
  * \param cmd command.
  * \param arg user argument, pointing to a drm_stats structure.
- * 
+ *
  * \return zero on success or a negative number on failure.
  */
-int drm_getstats( struct inode *inode, struct file *filp,
-		   unsigned int cmd, unsigned long arg )
+int drm_getstats(struct inode *inode, struct file *filp,
+		 unsigned int cmd, unsigned long arg)
 {
-	drm_file_t   *priv = filp->private_data;
-	drm_device_t *dev  = priv->head->dev;
-	drm_stats_t  stats;
-	int          i;
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
+	drm_stats_t stats;
+	int i;
 
 	memset(&stats, 0, sizeof(stats));
-	
+
 	down(&dev->struct_sem);
 
 	for (i = 0; i < dev->counters; i++) {
 		if (dev->types[i] == _DRM_STAT_LOCK)
 			stats.data[i].value
-				= (dev->lock.hw_lock
-				   ? dev->lock.hw_lock->lock : 0);
-		else 
+			    = (dev->lock.hw_lock ? dev->lock.hw_lock->lock : 0);
+		else
 			stats.data[i].value = atomic_read(&dev->counts[i]);
-		stats.data[i].type  = dev->types[i];
+		stats.data[i].type = dev->types[i];
 	}
-	
+
 	stats.count = dev->counters;
 
 	up(&dev->struct_sem);
 
-	if (copy_to_user((drm_stats_t __user *)arg, &stats, sizeof(stats)))
+	if (copy_to_user((drm_stats_t __user *) arg, &stats, sizeof(stats)))
 		return -EFAULT;
 	return 0;
 }
@@ -323,9 +325,15 @@ int drm_setversion(DRM_IOCTL_ARGS)
 	int if_version;
 	drm_set_version_t __user *argp = (void __user *)data;
 	drm_version_t version;
-
+ 
 	DRM_COPY_FROM_USER_IOCTL(sv, argp, sizeof(sv));
 
+	/*
+	 * version.name etc need to be initialized to zero.
+	 * If we don't, driver->version() will poke random strings to
+	 * random locations in user space, causing X server segfaults
+	 * that are interesting to debug.   --eich
+	 */
 	memset(&version, 0, sizeof(version));
 
 	dev->driver->version(&version);
@@ -340,7 +348,7 @@ int drm_setversion(DRM_IOCTL_ARGS)
 		if (sv.drm_di_major != DRM_IF_MAJOR ||
 		    sv.drm_di_minor < 0 || sv.drm_di_minor > DRM_IF_MINOR)
 			return EINVAL;
-		if_version = DRM_IF_VERSION(sv.drm_di_major, sv.drm_dd_minor);
+		if_version = DRM_IF_VERSION(sv.drm_di_major, sv.drm_di_minor);
 		dev->if_version = DRM_MAX(if_version, dev->if_version);
 		if (sv.drm_di_minor >= 1) {
 			/*
@@ -363,7 +371,7 @@ int drm_setversion(DRM_IOCTL_ARGS)
 
 /** No-op ioctl. */
 int drm_noop(struct inode *inode, struct file *filp, unsigned int cmd,
-	       unsigned long arg)
+	     unsigned long arg)
 {
 	DRM_DEBUG("\n");
 	return 0;
diff -purN linux-2.6.12.orig/drivers/char/drm/drm_irq.c linux-2.6.12/drivers/char/drm/drm_irq.c
--- linux-2.6.12.orig/drivers/char/drm/drm_irq.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/drm_irq.c	2005-07-05 08:37:27.000000000 +0200
@@ -1,5 +1,5 @@
 /**
- * \file drm_irq.h 
+ * \file drm_irq.c
  * IRQ support
  *
  * \author Rickard E. (Rik) Faith <faith@valinux.com>
@@ -39,19 +39,19 @@
 
 /**
  * Get interrupt from bus id.
- * 
+ *
  * \param inode device inode.
  * \param filp file pointer.
  * \param cmd command.
  * \param arg user argument, pointing to a drm_irq_busid structure.
  * \return zero on success or a negative number on failure.
- * 
+ *
  * Finds the PCI device with the specified bus id and gets its IRQ number.
  * This IOCTL is deprecated, and will now return EINVAL for any busid not equal
  * to that of the device that this DRM instance attached to.
  */
 int drm_irq_by_busid(struct inode *inode, struct file *filp,
-		   unsigned int cmd, unsigned long arg)
+		     unsigned int cmd, unsigned long arg)
 {
 	drm_file_t *priv = filp->private_data;
 	drm_device_t *dev = priv->head->dev;
@@ -66,14 +66,12 @@ int drm_irq_by_busid(struct inode *inode
 
 	if ((p.busnum >> 8) != dev->pci_domain ||
 	    (p.busnum & 0xff) != dev->pci_bus ||
-	    p.devnum != dev->pci_slot ||
-	    p.funcnum != dev->pci_func)
+	    p.devnum != dev->pci_slot || p.funcnum != dev->pci_func)
 		return -EINVAL;
 
 	p.irq = dev->irq;
 
-	DRM_DEBUG("%d:%d:%d => IRQ %d\n",
-		  p.busnum, p.devnum, p.funcnum, p.irq);
+	DRM_DEBUG("%d:%d:%d => IRQ %d\n", p.busnum, p.devnum, p.funcnum, p.irq);
 	if (copy_to_user(argp, &p, sizeof(p)))
 		return -EFAULT;
 	return 0;
@@ -83,67 +81,66 @@ int drm_irq_by_busid(struct inode *inode
  * Install IRQ handler.
  *
  * \param dev DRM device.
- * \param irq IRQ number.
  *
  * Initializes the IRQ related data, and setups drm_device::vbl_queue. Installs the handler, calling the driver
  * \c drm_driver_irq_preinstall() and \c drm_driver_irq_postinstall() functions
  * before and after the installation.
  */
-int drm_irq_install( drm_device_t *dev )
+static int drm_irq_install(drm_device_t * dev)
 {
 	int ret;
-	unsigned long sh_flags=0;
+	unsigned long sh_flags = 0;
 
 	if (!drm_core_check_feature(dev, DRIVER_HAVE_IRQ))
 		return -EINVAL;
 
-	if ( dev->irq == 0 )
+	if (dev->irq == 0)
 		return -EINVAL;
 
-	down( &dev->struct_sem );
+	down(&dev->struct_sem);
 
 	/* Driver must have been initialized */
-	if ( !dev->dev_private ) {
-		up( &dev->struct_sem );
+	if (!dev->dev_private) {
+		up(&dev->struct_sem);
 		return -EINVAL;
 	}
 
-	if ( dev->irq_enabled ) {
-		up( &dev->struct_sem );
+	if (dev->irq_enabled) {
+		up(&dev->struct_sem);
 		return -EBUSY;
 	}
 	dev->irq_enabled = 1;
-	up( &dev->struct_sem );
+	up(&dev->struct_sem);
 
-	DRM_DEBUG( "%s: irq=%d\n", __FUNCTION__, dev->irq );
+	DRM_DEBUG("%s: irq=%d\n", __FUNCTION__, dev->irq);
 
 	if (drm_core_check_feature(dev, DRIVER_IRQ_VBL)) {
 		init_waitqueue_head(&dev->vbl_queue);
-		
-		spin_lock_init( &dev->vbl_lock );
-		
-		INIT_LIST_HEAD( &dev->vbl_sigs.head );
-		
+
+		spin_lock_init(&dev->vbl_lock);
+
+		INIT_LIST_HEAD(&dev->vbl_sigs.head);
+
 		dev->vbl_pending = 0;
 	}
 
-				/* Before installing handler */
+	/* Before installing handler */
 	dev->driver->irq_preinstall(dev);
 
-				/* Install handler */
+	/* Install handler */
 	if (drm_core_check_feature(dev, DRIVER_IRQ_SHARED))
 		sh_flags = SA_SHIRQ;
-	
-	ret = request_irq( dev->irq, dev->driver->irq_handler,
-			   sh_flags, dev->devname, dev );
-	if ( ret < 0 ) {
-		down( &dev->struct_sem );
+
+	ret = request_irq(dev->irq, dev->driver->irq_handler,
+			  sh_flags, dev->devname, dev);
+	if (ret < 0) {
+		down(&dev->struct_sem);
 		dev->irq_enabled = 0;
-		up( &dev->struct_sem );
+		up(&dev->struct_sem);
 		return ret;
 	}
 
-				/* After installing handler */
+	/* After installing handler */
 	dev->driver->irq_postinstall(dev);
 
 	return 0;
@@ -156,26 +153,26 @@ int drm_irq_install( drm_device_t *dev )
  *
  * Calls the driver's \c drm_driver_irq_uninstall() function, and stops the irq.
  */
-int drm_irq_uninstall( drm_device_t *dev )
+int drm_irq_uninstall(drm_device_t * dev)
 {
 	int irq_enabled;
 
 	if (!drm_core_check_feature(dev, DRIVER_HAVE_IRQ))
 		return -EINVAL;
 
-	down( &dev->struct_sem );
+	down(&dev->struct_sem);
 	irq_enabled = dev->irq_enabled;
 	dev->irq_enabled = 0;
-	up( &dev->struct_sem );
+	up(&dev->struct_sem);
 
-	if ( !irq_enabled )
+	if (!irq_enabled)
 		return -EINVAL;
 
-	DRM_DEBUG( "%s: irq=%d\n", __FUNCTION__, dev->irq );
+	DRM_DEBUG("%s: irq=%d\n", __FUNCTION__, dev->irq);
 
 	dev->driver->irq_uninstall(dev);
 
-	free_irq( dev->irq, dev );
+	free_irq(dev->irq, dev);
 
 	return 0;
 }
@@ -192,30 +189,30 @@ EXPORT_SYMBOL(drm_irq_uninstall);
  *
  * Calls irq_install() or irq_uninstall() according to \p arg.
  */
-int drm_control( struct inode *inode, struct file *filp,
-		  unsigned int cmd, unsigned long arg )
+int drm_control(struct inode *inode, struct file *filp,
+		unsigned int cmd, unsigned long arg)
 {
 	drm_file_t *priv = filp->private_data;
 	drm_device_t *dev = priv->head->dev;
 	drm_control_t ctl;
-	
+
 	/* if we haven't irq we fallback for compatibility reasons - this used to be a separate function in drm_dma.h */
 
-	if ( copy_from_user( &ctl, (drm_control_t __user *)arg, sizeof(ctl) ) )
+	if (copy_from_user(&ctl, (drm_control_t __user *) arg, sizeof(ctl)))
 		return -EFAULT;
 
-	switch ( ctl.func ) {
+	switch (ctl.func) {
 	case DRM_INST_HANDLER:
 		if (!drm_core_check_feature(dev, DRIVER_HAVE_IRQ))
 			return 0;
 		if (dev->if_version < DRM_IF_VERSION(1, 2) &&
 		    ctl.irq != dev->irq)
 			return -EINVAL;
-		return drm_irq_install( dev );
+		return drm_irq_install(dev);
 	case DRM_UNINST_HANDLER:
 		if (!drm_core_check_feature(dev, DRIVER_HAVE_IRQ))
 			return 0;
-		return drm_irq_uninstall( dev );
+		return drm_irq_uninstall(dev);
 	default:
 		return -EINVAL;
 	}
@@ -225,12 +222,12 @@ int drm_control( struct inode *inode, st
  * Wait for VBLANK.
  *
  * \param inode device inode.
- * \param filp file pointer.
+ * \param filp file pointer.rm.
  * \param cmd command.
  * \param data user argument, pointing to a drm_wait_vblank structure.
  * \return zero on success or a negative number on failure.
  *
- * Verifies the IRQ is installed. 
+ * Verifies the IRQ is installed
  *
  * If a signal is requested checks if this task has already scheduled the same signal
  * for the same vblank sequence number - nothing to be done in
@@ -240,7 +237,7 @@ int drm_control( struct inode *inode, st
  *
  * If a signal is not requested, then calls vblank_wait().
  */
-int drm_wait_vblank( DRM_IOCTL_ARGS )
+int drm_wait_vblank(DRM_IOCTL_ARGS)
 {
 	drm_file_t *priv = filp->private_data;
 	drm_device_t *dev = priv->head->dev;
@@ -256,11 +253,11 @@ int drm_wait_vblank( DRM_IOCTL_ARGS )
 	if (!dev->irq)
 		return -EINVAL;
 
-	DRM_COPY_FROM_USER_IOCTL( vblwait, argp, sizeof(vblwait) );
+	DRM_COPY_FROM_USER_IOCTL(vblwait, argp, sizeof(vblwait));
 
-	switch ( vblwait.request.type & ~_DRM_VBLANK_FLAGS_MASK ) {
+	switch (vblwait.request.type & ~_DRM_VBLANK_FLAGS_MASK) {
 	case _DRM_VBLANK_RELATIVE:
-		vblwait.request.sequence += atomic_read( &dev->vbl_received );
+		vblwait.request.sequence += atomic_read(&dev->vbl_received);
 		vblwait.request.type &= ~_DRM_VBLANK_RELATIVE;
 	case _DRM_VBLANK_ABSOLUTE:
 		break;
@@ -269,64 +266,68 @@ int drm_wait_vblank( DRM_IOCTL_ARGS )
 	}
 
 	flags = vblwait.request.type & _DRM_VBLANK_FLAGS_MASK;
-	
-	if ( flags & _DRM_VBLANK_SIGNAL ) {
+
+	if (flags & _DRM_VBLANK_SIGNAL) {
 		unsigned long irqflags;
 		drm_vbl_sig_t *vbl_sig;
-		
-		vblwait.reply.sequence = atomic_read( &dev->vbl_received );
 
-		spin_lock_irqsave( &dev->vbl_lock, irqflags );
+		vblwait.reply.sequence = atomic_read(&dev->vbl_received);
+
+		spin_lock_irqsave(&dev->vbl_lock, irqflags);
 
 		/* Check if this task has already scheduled the same signal
 		 * for the same vblank sequence number; nothing to be done in
 		 * that case
 		 */
-		list_for_each_entry( vbl_sig, &dev->vbl_sigs.head, head ) {
+		list_for_each_entry(vbl_sig, &dev->vbl_sigs.head, head) {
 			if (vbl_sig->sequence == vblwait.request.sequence
 			    && vbl_sig->info.si_signo == vblwait.request.signal
-			    && vbl_sig->task == current)
-			{
-				spin_unlock_irqrestore( &dev->vbl_lock, irqflags );
+			    && vbl_sig->task == current) {
+				spin_unlock_irqrestore(&dev->vbl_lock,
+						       irqflags);
 				goto done;
 			}
 		}
 
-		if ( dev->vbl_pending >= 100 ) {
-			spin_unlock_irqrestore( &dev->vbl_lock, irqflags );
+		if (dev->vbl_pending >= 100) {
+			spin_unlock_irqrestore(&dev->vbl_lock, irqflags);
 			return -EBUSY;
 		}
 
 		dev->vbl_pending++;
 
-		spin_unlock_irqrestore( &dev->vbl_lock, irqflags );
+		spin_unlock_irqrestore(&dev->vbl_lock, irqflags);
 
-		if ( !( vbl_sig = drm_alloc( sizeof( drm_vbl_sig_t ), DRM_MEM_DRIVER ) ) ) {
+		if (!
+		    (vbl_sig =
+		     drm_alloc(sizeof(drm_vbl_sig_t), DRM_MEM_DRIVER))) {
 			return -ENOMEM;
 		}
 
-		memset( (void *)vbl_sig, 0, sizeof(*vbl_sig) );
+		memset((void *)vbl_sig, 0, sizeof(*vbl_sig));
 
 		vbl_sig->sequence = vblwait.request.sequence;
 		vbl_sig->info.si_signo = vblwait.request.signal;
 		vbl_sig->task = current;
 
-		spin_lock_irqsave( &dev->vbl_lock, irqflags );
+		spin_lock_irqsave(&dev->vbl_lock, irqflags);
 
-		list_add_tail( (struct list_head *) vbl_sig, &dev->vbl_sigs.head );
+		list_add_tail((struct list_head *)vbl_sig, &dev->vbl_sigs.head);
 
-		spin_unlock_irqrestore( &dev->vbl_lock, irqflags );
+		spin_unlock_irqrestore(&dev->vbl_lock, irqflags);
 	} else {
 		if (dev->driver->vblank_wait)
-			ret = dev->driver->vblank_wait( dev, &vblwait.request.sequence );
+			ret =
+			    dev->driver->vblank_wait(dev,
+						     &vblwait.request.sequence);
 
-		do_gettimeofday( &now );
+		do_gettimeofday(&now);
 		vblwait.reply.tval_sec = now.tv_sec;
 		vblwait.reply.tval_usec = now.tv_usec;
 	}
 
-done:
-	DRM_COPY_TO_USER_IOCTL( argp, vblwait, sizeof(vblwait) );
+      done:
+	DRM_COPY_TO_USER_IOCTL(argp, vblwait, sizeof(vblwait));
 
 	return ret;
 }
@@ -340,31 +341,30 @@ done:
  *
  * If a signal is not requested, then calls vblank_wait().
  */
-void drm_vbl_send_signals( drm_device_t *dev )
+void drm_vbl_send_signals(drm_device_t * dev)
 {
 	struct list_head *list, *tmp;
 	drm_vbl_sig_t *vbl_sig;
-	unsigned int vbl_seq = atomic_read( &dev->vbl_received );
+	unsigned int vbl_seq = atomic_read(&dev->vbl_received);
 	unsigned long flags;
 
-	spin_lock_irqsave( &dev->vbl_lock, flags );
+	spin_lock_irqsave(&dev->vbl_lock, flags);
 
-	list_for_each_safe( list, tmp, &dev->vbl_sigs.head ) {
-		vbl_sig = list_entry( list, drm_vbl_sig_t, head );
-		if ( ( vbl_seq - vbl_sig->sequence ) <= (1<<23) ) {
+	list_for_each_safe(list, tmp, &dev->vbl_sigs.head) {
+		vbl_sig = list_entry(list, drm_vbl_sig_t, head);
+		if ((vbl_seq - vbl_sig->sequence) <= (1 << 23)) {
 			vbl_sig->info.si_code = vbl_seq;
-			send_sig_info( vbl_sig->info.si_signo, &vbl_sig->info, vbl_sig->task );
+			send_sig_info(vbl_sig->info.si_signo, &vbl_sig->info,
+				      vbl_sig->task);
 
-			list_del( list );
+			list_del(list);
 
-			drm_free( vbl_sig, sizeof(*vbl_sig), DRM_MEM_DRIVER );
+			drm_free(vbl_sig, sizeof(*vbl_sig), DRM_MEM_DRIVER);
 
 			dev->vbl_pending--;
 		}
 	}
 
-	spin_unlock_irqrestore( &dev->vbl_lock, flags );
+	spin_unlock_irqrestore(&dev->vbl_lock, flags);
 }
 EXPORT_SYMBOL(drm_vbl_send_signals);
-
-
diff -purN linux-2.6.12.orig/drivers/char/drm/drm_lock.c linux-2.6.12/drivers/char/drm/drm_lock.c
--- linux-2.6.12.orig/drivers/char/drm/drm_lock.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/drm_lock.c	2005-07-05 08:37:27.000000000 +0200
@@ -1,7 +1,7 @@
 /**
- * \file drm_lock.h 
+ * \file drm_lock.c
  * IOCTLs for locking
- * 
+ *
  * \author Rickard E. (Rik) Faith <faith@valinux.com>
  * \author Gareth Hughes <gareth@valinux.com>
  */
@@ -35,7 +35,11 @@
 
 #include "drmP.h"
 
-/** 
+static int drm_lock_transfer(drm_device_t * dev,
+		      __volatile__ unsigned int *lock, unsigned int context);
+static int drm_notifier(void *priv);
+
+/**
  * Lock ioctl.
  *
  * \param inode device inode.
@@ -46,91 +50,91 @@
  *
  * Add the current task to the lock wait queue, and attempt to take to lock.
  */
-int drm_lock( struct inode *inode, struct file *filp,
-	       unsigned int cmd, unsigned long arg )
+int drm_lock(struct inode *inode, struct file *filp,
+	     unsigned int cmd, unsigned long arg)
 {
-        drm_file_t *priv = filp->private_data;
-        drm_device_t *dev = priv->head->dev;
-        DECLARE_WAITQUEUE( entry, current );
-        drm_lock_t lock;
-        int ret = 0;
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
+	DECLARE_WAITQUEUE(entry, current);
+	drm_lock_t lock;
+	int ret = 0;
 
 	++priv->lock_count;
 
-        if ( copy_from_user( &lock, (drm_lock_t __user *)arg, sizeof(lock) ) )
+	if (copy_from_user(&lock, (drm_lock_t __user *) arg, sizeof(lock)))
 		return -EFAULT;
 
-        if ( lock.context == DRM_KERNEL_CONTEXT ) {
-                DRM_ERROR( "Process %d using kernel context %d\n",
-			   current->pid, lock.context );
-                return -EINVAL;
-        }
-
-        DRM_DEBUG( "%d (pid %d) requests lock (0x%08x), flags = 0x%08x\n",
-		   lock.context, current->pid,
-		   dev->lock.hw_lock->lock, lock.flags );
+	if (lock.context == DRM_KERNEL_CONTEXT) {
+		DRM_ERROR("Process %d using kernel context %d\n",
+			  current->pid, lock.context);
+		return -EINVAL;
+	}
+
+	DRM_DEBUG("%d (pid %d) requests lock (0x%08x), flags = 0x%08x\n",
+		  lock.context, current->pid,
+		  dev->lock.hw_lock->lock, lock.flags);
 
 	if (drm_core_check_feature(dev, DRIVER_DMA_QUEUE))
-		if ( lock.context < 0 )
+		if (lock.context < 0)
 			return -EINVAL;
 
-	add_wait_queue( &dev->lock.lock_queue, &entry );
+	add_wait_queue(&dev->lock.lock_queue, &entry);
 	for (;;) {
-		__set_current_state(TASK_INTERRUPTIBLE);
-		if ( !dev->lock.hw_lock ) {
+		current->state = TASK_INTERRUPTIBLE;
+		if (!dev->lock.hw_lock) {
 			/* Device has been unregistered */
 			ret = -EINTR;
 			break;
 		}
-		if ( drm_lock_take( &dev->lock.hw_lock->lock,
-				     lock.context ) ) {
-			dev->lock.filp      = filp;
+		if (drm_lock_take(&dev->lock.hw_lock->lock, lock.context)) {
+			dev->lock.filp = filp;
 			dev->lock.lock_time = jiffies;
-			atomic_inc( &dev->counts[_DRM_STAT_LOCKS] );
-			break;  /* Got lock */
+			atomic_inc(&dev->counts[_DRM_STAT_LOCKS]);
+			break;	/* Got lock */
 		}
-		
+
 		/* Contention */
 		schedule();
-		if ( signal_pending( current ) ) {
+		if (signal_pending(current)) {
 			ret = -ERESTARTSYS;
 			break;
 		}
 	}
-	__set_current_state(TASK_RUNNING);
-	remove_wait_queue( &dev->lock.lock_queue, &entry );
+	current->state = TASK_RUNNING;
+	remove_wait_queue(&dev->lock.lock_queue, &entry);
+
+        DRM_DEBUG( "%d %s\n", lock.context, ret ? "interrupted" : "has lock" );
+	if (ret) return ret;
 
-	sigemptyset( &dev->sigmask );
-	sigaddset( &dev->sigmask, SIGSTOP );
-	sigaddset( &dev->sigmask, SIGTSTP );
-	sigaddset( &dev->sigmask, SIGTTIN );
-	sigaddset( &dev->sigmask, SIGTTOU );
+	sigemptyset(&dev->sigmask);
+	sigaddset(&dev->sigmask, SIGSTOP);
+	sigaddset(&dev->sigmask, SIGTSTP);
+	sigaddset(&dev->sigmask, SIGTTIN);
+	sigaddset(&dev->sigmask, SIGTTOU);
 	dev->sigdata.context = lock.context;
-	dev->sigdata.lock    = dev->lock.hw_lock;
-	block_all_signals( drm_notifier,
-			   &dev->sigdata, &dev->sigmask );
-	
+	dev->sigdata.lock = dev->lock.hw_lock;
+	block_all_signals(drm_notifier, &dev->sigdata, &dev->sigmask);
+
 	if (dev->driver->dma_ready && (lock.flags & _DRM_LOCK_READY))
 		dev->driver->dma_ready(dev);
-	
-	if ( dev->driver->dma_quiescent && (lock.flags & _DRM_LOCK_QUIESCENT ))
-		return dev->driver->dma_quiescent(dev);
-	
-	/* dev->driver->kernel_context_switch isn't used by any of the x86 
-	 *  drivers but is used by the Sparc driver.
-	 */
-	
-	if (dev->driver->kernel_context_switch && 
-	    dev->last_context != lock.context) {
-	  dev->driver->kernel_context_switch(dev, dev->last_context, 
-					    lock.context);
+
+	if (dev->driver->dma_quiescent && (lock.flags & _DRM_LOCK_QUIESCENT)) {
+		if (dev->driver->dma_quiescent(dev)) {
+			DRM_DEBUG( "%d waiting for DMA quiescent\n", lock.context);
+			return DRM_ERR(EBUSY);
+		}
+	}
+
+	if (dev->driver->kernel_context_switch
+	    && dev->last_context != lock.context) {
+		dev->driver->kernel_context_switch(dev, dev->last_context,
+						   lock.context);
 	}
-        DRM_DEBUG( "%d %s\n", lock.context, ret ? "interrupted" : "has lock" );
 
-        return ret;
+	return 0;
 }
 
-/** 
+/**
  * Unlock ioctl.
  *
  * \param inode device inode.
@@ -141,36 +145,33 @@ int drm_lock( struct inode *inode, struc
  *
  * Transfer and free the lock.
  */
-int drm_unlock( struct inode *inode, struct file *filp,
-		 unsigned int cmd, unsigned long arg )
+int drm_unlock(struct inode *inode, struct file *filp,
+	       unsigned int cmd, unsigned long arg)
 {
 	drm_file_t *priv = filp->private_data;
 	drm_device_t *dev = priv->head->dev;
 	drm_lock_t lock;
 
-	if ( copy_from_user( &lock, (drm_lock_t __user *)arg, sizeof(lock) ) )
+	if (copy_from_user(&lock, (drm_lock_t __user *) arg, sizeof(lock)))
 		return -EFAULT;
 
-	if ( lock.context == DRM_KERNEL_CONTEXT ) {
-		DRM_ERROR( "Process %d using kernel context %d\n",
-			   current->pid, lock.context );
+	if (lock.context == DRM_KERNEL_CONTEXT) {
+		DRM_ERROR("Process %d using kernel context %d\n",
+			  current->pid, lock.context);
 		return -EINVAL;
 	}
 
-	atomic_inc( &dev->counts[_DRM_STAT_UNLOCKS] );
+	atomic_inc(&dev->counts[_DRM_STAT_UNLOCKS]);
 
-	/* kernel_context_switch isn't used by any of the x86 drm
-	 * modules but is required by the Sparc driver.
-	 */
 	if (dev->driver->kernel_context_switch_unlock)
-		dev->driver->kernel_context_switch_unlock(dev, &lock);
+		dev->driver->kernel_context_switch_unlock(dev);
 	else {
-		drm_lock_transfer( dev, &dev->lock.hw_lock->lock, 
-				    DRM_KERNEL_CONTEXT );
-		
-		if ( drm_lock_free( dev, &dev->lock.hw_lock->lock,
-				     DRM_KERNEL_CONTEXT ) ) {
-			DRM_ERROR( "\n" );
+		drm_lock_transfer(dev, &dev->lock.hw_lock->lock,
+				  DRM_KERNEL_CONTEXT);
+
+		if (drm_lock_free(dev, &dev->lock.hw_lock->lock,
+				  DRM_KERNEL_CONTEXT)) {
+			DRM_ERROR("\n");
 		}
 	}
 
@@ -193,8 +194,10 @@ int drm_lock_take(__volatile__ unsigned 
 
 	do {
 		old = *lock;
-		if (old & _DRM_LOCK_HELD) new = old | _DRM_LOCK_CONT;
-		else			  new = context | _DRM_LOCK_HELD;
+		if (old & _DRM_LOCK_HELD)
+			new = old | _DRM_LOCK_CONT;
+		else
+			new = context | _DRM_LOCK_HELD;
 		prev = cmpxchg(lock, old, new);
 	} while (prev != old);
 	if (_DRM_LOCKING_CONTEXT(old) == context) {
@@ -207,7 +210,7 @@ int drm_lock_take(__volatile__ unsigned 
 		}
 	}
 	if (new == (context | _DRM_LOCK_HELD)) {
-				/* Have lock */
+		/* Have lock */
 		return 1;
 	}
 	return 0;
@@ -215,8 +218,8 @@ int drm_lock_take(__volatile__ unsigned 
 
 /**
  * This takes a lock forcibly and hands it to context.	Should ONLY be used
- * inside *_unlock to give lock to kernel before calling *_dma_schedule. 
- * 
+ * inside *_unlock to give lock to kernel before calling *_dma_schedule.
+ *
  * \param dev DRM device.
  * \param lock lock pointer.
  * \param context locking context.
@@ -225,15 +228,15 @@ int drm_lock_take(__volatile__ unsigned 
  * Resets the lock file pointer.
  * Marks the lock as held by the given context, via the \p cmpxchg instruction.
  */
-int drm_lock_transfer(drm_device_t *dev,
-		       __volatile__ unsigned int *lock, unsigned int context)
+static int drm_lock_transfer(drm_device_t * dev,
+		      __volatile__ unsigned int *lock, unsigned int context)
 {
 	unsigned int old, new, prev;
 
 	dev->lock.filp = NULL;
 	do {
-		old  = *lock;
-		new  = context | _DRM_LOCK_HELD;
+		old = *lock;
+		new = context | _DRM_LOCK_HELD;
 		prev = cmpxchg(lock, old, new);
 	} while (prev != old);
 	return 1;
@@ -241,30 +244,29 @@ int drm_lock_transfer(drm_device_t *dev,
 
 /**
  * Free lock.
- * 
+ *
  * \param dev DRM device.
  * \param lock lock.
  * \param context context.
- * 
+ *
  * Resets the lock file pointer.
  * Marks the lock as not held, via the \p cmpxchg instruction. Wakes any task
  * waiting on the lock queue.
  */
-int drm_lock_free(drm_device_t *dev,
-		   __volatile__ unsigned int *lock, unsigned int context)
+int drm_lock_free(drm_device_t * dev,
+		  __volatile__ unsigned int *lock, unsigned int context)
 {
 	unsigned int old, new, prev;
 
 	dev->lock.filp = NULL;
 	do {
-		old  = *lock;
-		new  = 0;
+		old = *lock;
+		new = 0;
 		prev = cmpxchg(lock, old, new);
 	} while (prev != old);
 	if (_DRM_LOCK_IS_HELD(old) && _DRM_LOCKING_CONTEXT(old) != context) {
 		DRM_ERROR("%d freed heavyweight lock held by %d\n",
-			  context,
-			  _DRM_LOCKING_CONTEXT(old));
+			  context, _DRM_LOCKING_CONTEXT(old));
 		return 1;
 	}
 	wake_up_interruptible(&dev->lock.lock_queue);
@@ -282,21 +284,21 @@ int drm_lock_free(drm_device_t *dev,
  * \return one if the signal should be delivered normally, or zero if the
  * signal should be blocked.
  */
-int drm_notifier(void *priv)
+static int drm_notifier(void *priv)
 {
-	drm_sigdata_t *s = (drm_sigdata_t *)priv;
-	unsigned int  old, new, prev;
-
+	drm_sigdata_t *s = (drm_sigdata_t *) priv;
+	unsigned int old, new, prev;
 
-				/* Allow signal delivery if lock isn't held */
+	/* Allow signal delivery if lock isn't held */
 	if (!s->lock || !_DRM_LOCK_IS_HELD(s->lock->lock)
-	    || _DRM_LOCKING_CONTEXT(s->lock->lock) != s->context) return 1;
+	    || _DRM_LOCKING_CONTEXT(s->lock->lock) != s->context)
+		return 1;
 
-				/* Otherwise, set flag to force call to
-                                   drmUnlock */
+	/* Otherwise, set flag to force call to
+	   drmUnlock */
 	do {
-		old  = s->lock->lock;
-		new  = old | _DRM_LOCK_CONT;
+		old = s->lock->lock;
+		new = old | _DRM_LOCK_CONT;
 		prev = cmpxchg(&s->lock->lock, old, new);
 	} while (prev != old);
 	return 0;
diff -purN linux-2.6.12.orig/drivers/char/drm/drm_memory.c linux-2.6.12/drivers/char/drm/drm_memory.c
--- linux-2.6.12.orig/drivers/char/drm/drm_memory.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/drm_memory.c	2005-07-05 08:37:27.000000000 +0200
@@ -1,12 +1,12 @@
-/** 
- * \file drm_memory.h 
+/**
+ * \file drm_memory.c
  * Memory management wrappers for DRM
  *
  * \author Rickard E. (Rik) Faith <faith@valinux.com>
  * \author Gareth Hughes <gareth@valinux.com>
  */
 
-/* 
+/*
  * Created: Thu Feb  4 14:00:34 1999 by faith@valinux.com
  *
  * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
@@ -37,9 +37,7 @@
 #include <linux/highmem.h>
 #include "drmP.h"
 
-#ifdef DEBUG_MEMORY
-#include "drm_memory_debug.h"
-#else
+#ifndef DEBUG_MEMORY
 
 /** No-op. */
 void drm_mem_init(void)
@@ -48,7 +46,7 @@ void drm_mem_init(void)
 
 /**
  * Called when "/proc/dri/%dev%/mem" is read.
- * 
+ *
  * \param buf output buffer.
  * \param start start of output data.
  * \param offset requested start offset.
@@ -57,10 +55,10 @@ void drm_mem_init(void)
  * \param data private data.
  * \return number of written bytes.
  *
- * No-op. 
+ * No-op.
  */
 int drm_mem_info(char *buf, char **start, off_t offset,
-		  int len, int *eof, void *data)
+		 int len, int *eof, void *data)
 {
 	return 0;
 }
@@ -83,7 +81,8 @@ void *drm_realloc(void *oldpt, size_t ol
 {
 	void *pt;
 
-	if (!(pt = kmalloc(size, GFP_KERNEL))) return NULL;
+	if (!(pt = kmalloc(size, GFP_KERNEL)))
+		return NULL;
 	if (oldpt && oldsize) {
 		memcpy(pt, oldpt, oldsize);
 		kfree(oldpt);
@@ -103,21 +102,20 @@ void *drm_realloc(void *oldpt, size_t ol
 unsigned long drm_alloc_pages(int order, int area)
 {
 	unsigned long address;
-	unsigned long bytes	  = PAGE_SIZE << order;
+	unsigned long bytes = PAGE_SIZE << order;
 	unsigned long addr;
-	unsigned int  sz;
+	unsigned int sz;
 
 	address = __get_free_pages(GFP_KERNEL, order);
-	if (!address) 
+	if (!address)
 		return 0;
 
-				/* Zero */
+	/* Zero */
 	memset((void *)address, 0, bytes);
 
-				/* Reserve */
+	/* Reserve */
 	for (addr = address, sz = bytes;
-	     sz > 0;
-	     addr += PAGE_SIZE, sz -= PAGE_SIZE) {
+	     sz > 0; addr += PAGE_SIZE, sz -= PAGE_SIZE) {
 		SetPageReserved(virt_to_page(addr));
 	}
 
@@ -126,7 +124,7 @@ unsigned long drm_alloc_pages(int order,
 
 /**
  * Free pages.
- * 
+ *
  * \param address address of the pages to free.
  * \param order size order.
  * \param area memory area. (Not used.)
@@ -137,45 +135,54 @@ void drm_free_pages(unsigned long addres
 {
 	unsigned long bytes = PAGE_SIZE << order;
 	unsigned long addr;
-	unsigned int  sz;
+	unsigned int sz;
 
-	if (!address) 
+	if (!address)
 		return;
 
 	/* Unreserve */
 	for (addr = address, sz = bytes;
-	     sz > 0;
-	     addr += PAGE_SIZE, sz -= PAGE_SIZE) {
+	     sz > 0; addr += PAGE_SIZE, sz -= PAGE_SIZE) {
 		ClearPageReserved(virt_to_page(addr));
 	}
 
 	free_pages(address, order);
 }
 
-
 #if __OS_HAS_AGP
 /** Wrapper around agp_allocate_memory() */
-DRM_AGP_MEM *drm_alloc_agp(struct agp_bridge_data *bridge, int pages, u32 type)
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,11)
+DRM_AGP_MEM *drm_alloc_agp(drm_device_t *dev, int pages, u32 type)
+{
+	return drm_agp_allocate_memory(pages, type);
+}
+#else
+DRM_AGP_MEM *drm_alloc_agp(drm_device_t *dev, int pages, u32 type)
 {
-	return drm_agp_allocate_memory(bridge, pages, type);
+	return drm_agp_allocate_memory(dev->agp->bridge, pages, type);
 }
+#endif
+EXPORT_SYMBOL(drm_alloc_agp);
 
 /** Wrapper around agp_free_memory() */
-int drm_free_agp(DRM_AGP_MEM *handle, int pages)
+int drm_free_agp(DRM_AGP_MEM * handle, int pages)
 {
 	return drm_agp_free_memory(handle) ? 0 : -EINVAL;
 }
+EXPORT_SYMBOL(drm_free_agp);
 
 /** Wrapper around agp_bind_memory() */
-int drm_bind_agp(DRM_AGP_MEM *handle, unsigned int start)
+int drm_bind_agp(DRM_AGP_MEM * handle, unsigned int start)
 {
 	return drm_agp_bind_memory(handle, start);
 }
+EXPORT_SYMBOL(drm_bind_agp);
 
 /** Wrapper around agp_unbind_memory() */
-int drm_unbind_agp(DRM_AGP_MEM *handle)
+int drm_unbind_agp(DRM_AGP_MEM * handle)
 {
 	return drm_agp_unbind_memory(handle);
 }
-#endif /* agp */
-#endif /* debug_memory */
+EXPORT_SYMBOL(drm_unbind_agp);
+#endif				/* agp */
+#endif				/* debug_memory */
diff -purN linux-2.6.12.orig/drivers/char/drm/drm_memory_debug.c linux-2.6.12/drivers/char/drm/drm_memory_debug.c
--- linux-2.6.12.orig/drivers/char/drm/drm_memory_debug.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/drm/drm_memory_debug.c	2005-07-05 08:37:27.000000000 +0200
@@ -0,0 +1,481 @@
+/**
+ * \file drm_memory_debug.c
+ * Memory management wrappers for DRM.
+ *
+ * \author Rickard E. (Rik) Faith <faith@valinux.com>
+ * \author Gareth Hughes <gareth@valinux.com>
+ */
+
+/*
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <linux/config.h>
+#include "drmP.h"
+
+#ifdef DEBUG_MEMORY
+
+typedef struct drm_mem_stats {
+	const char *name;
+	int succeed_count;
+	int free_count;
+	int fail_count;
+	unsigned long bytes_allocated;
+	unsigned long bytes_freed;
+} drm_mem_stats_t;
+
+static spinlock_t drm_mem_lock = SPIN_LOCK_UNLOCKED;
+static unsigned long drm_ram_available = 0;	/* In pages */
+static unsigned long drm_ram_used = 0;
+static drm_mem_stats_t drm_mem_stats[] = {
+	[DRM_MEM_DMA] = {"dmabufs"},
+	[DRM_MEM_SAREA] = {"sareas"},
+	[DRM_MEM_DRIVER] = {"driver"},
+	[DRM_MEM_MAGIC] = {"magic"},
+	[DRM_MEM_IOCTLS] = {"ioctltab"},
+	[DRM_MEM_MAPS] = {"maplist"},
+	[DRM_MEM_VMAS] = {"vmalist"},
+	[DRM_MEM_BUFS] = {"buflist"},
+	[DRM_MEM_SEGS] = {"seglist"},
+	[DRM_MEM_PAGES] = {"pagelist"},
+	[DRM_MEM_FILES] = {"files"},
+	[DRM_MEM_QUEUES] = {"queues"},
+	[DRM_MEM_CMDS] = {"commands"},
+	[DRM_MEM_MAPPINGS] = {"mappings"},
+	[DRM_MEM_BUFLISTS] = {"buflists"},
+	[DRM_MEM_AGPLISTS] = {"agplist"},
+	[DRM_MEM_SGLISTS] = {"sglist"},
+	[DRM_MEM_TOTALAGP] = {"totalagp"},
+	[DRM_MEM_BOUNDAGP] = {"boundagp"},
+	[DRM_MEM_CTXBITMAP] = {"ctxbitmap"},
+	[DRM_MEM_CTXLIST] = {"ctxlist"},
+	[DRM_MEM_STUB] = {"stub"},
+	{NULL, 0,}		/* Last entry must be null */
+};
+
+void drm_mem_init(void)
+{
+	drm_mem_stats_t *mem;
+	struct sysinfo si;
+
+	for (mem = drm_mem_stats; mem->name; ++mem) {
+		mem->succeed_count = 0;
+		mem->free_count = 0;
+		mem->fail_count = 0;
+		mem->bytes_allocated = 0;
+		mem->bytes_freed = 0;
+	}
+
+	si_meminfo(&si);
+	drm_ram_available = si.totalram;
+	drm_ram_used = 0;
+}
+
+/* drm_mem_info is called whenever a process reads /dev/drm/mem. */
+
+static int drm__mem_info(char *buf, char **start, off_t offset,
+			 int request, int *eof, void *data)
+{
+	drm_mem_stats_t *pt;
+	int len = 0;
+
+	if (offset > DRM_PROC_LIMIT) {
+		*eof = 1;
+		return 0;
+	}
+
+	*eof = 0;
+	*start = &buf[offset];
+
+	DRM_PROC_PRINT("		  total counts			"
+		       " |    outstanding  \n");
+	DRM_PROC_PRINT("type	   alloc freed fail	bytes	   freed"
+		       " | allocs      bytes\n\n");
+	DRM_PROC_PRINT("%-9.9s %5d %5d %4d %10lu kB         |\n",
+		       "system", 0, 0, 0,
+		       drm_ram_available << (PAGE_SHIFT - 10));
+	DRM_PROC_PRINT("%-9.9s %5d %5d %4d %10lu kB         |\n",
+		       "locked", 0, 0, 0, drm_ram_used >> 10);
+	DRM_PROC_PRINT("\n");
+	for (pt = drm_mem_stats; pt->name; pt++) {
+		DRM_PROC_PRINT("%-9.9s %5d %5d %4d %10lu %10lu | %6d %10ld\n",
+			       pt->name,
+			       pt->succeed_count,
+			       pt->free_count,
+			       pt->fail_count,
+			       pt->bytes_allocated,
+			       pt->bytes_freed,
+			       pt->succeed_count - pt->free_count,
+			       (long)pt->bytes_allocated
+			       - (long)pt->bytes_freed);
+	}
+
+	if (len > request + offset)
+		return request;
+	*eof = 1;
+	return len - offset;
+}
+
+int drm_mem_info(char *buf, char **start, off_t offset,
+		 int len, int *eof, void *data)
+{
+	int ret;
+
+	spin_lock(&drm_mem_lock);
+	ret = drm__mem_info(buf, start, offset, len, eof, data);
+	spin_unlock(&drm_mem_lock);
+	return ret;
+}
+
+void *drm_alloc(size_t size, int area)
+{
+	void *pt;
+
+	if (!size) {
+		DRM_MEM_ERROR(area, "Allocating 0 bytes\n");
+		return NULL;
+	}
+
+	if (!(pt = kmalloc(size, GFP_KERNEL))) {
+		spin_lock(&drm_mem_lock);
+		++drm_mem_stats[area].fail_count;
+		spin_unlock(&drm_mem_lock);
+		return NULL;
+	}
+	spin_lock(&drm_mem_lock);
+	++drm_mem_stats[area].succeed_count;
+	drm_mem_stats[area].bytes_allocated += size;
+	spin_unlock(&drm_mem_lock);
+	return pt;
+}
+EXPORT_SYMBOL(drm_alloc);
+
+void *drm_calloc(size_t nmemb, size_t size, int area)
+{
+	void *addr;
+
+	addr = drm_alloc(nmemb * size, area);
+	if (addr != NULL)
+		memset((void *)addr, 0, size * nmemb);
+
+	return addr;
+}
+EXPORT_SYMBOL(drm_calloc);
+
+void *drm_realloc(void *oldpt, size_t oldsize, size_t size, int area)
+{
+	void *pt;
+
+	if (!(pt = drm_alloc(size, area)))
+		return NULL;
+	if (oldpt && oldsize) {
+		memcpy(pt, oldpt, oldsize);
+		drm_free(oldpt, oldsize, area);
+	}
+	return pt;
+}
+EXPORT_SYMBOL(drm_realloc);
+
+void drm_free(void *pt, size_t size, int area)
+{
+	int alloc_count;
+	int free_count;
+
+	if (!pt)
+		DRM_MEM_ERROR(area, "Attempt to free NULL pointer\n");
+	else
+		kfree(pt);
+	spin_lock(&drm_mem_lock);
+	drm_mem_stats[area].bytes_freed += size;
+	free_count = ++drm_mem_stats[area].free_count;
+	alloc_count = drm_mem_stats[area].succeed_count;
+	spin_unlock(&drm_mem_lock);
+	if (free_count > alloc_count) {
+		DRM_MEM_ERROR(area, "Excess frees: %d frees, %d allocs\n",
+			      free_count, alloc_count);
+	}
+}
+EXPORT_SYMBOL(drm_free);
+
+unsigned long drm_alloc_pages(int order, int area)
+{
+	unsigned long address;
+	unsigned long bytes = PAGE_SIZE << order;
+	unsigned long addr;
+	unsigned int sz;
+
+	spin_lock(&drm_mem_lock);
+	if ((drm_ram_used >> PAGE_SHIFT)
+	    > (DRM_RAM_PERCENT * drm_ram_available) / 100) {
+		spin_unlock(&drm_mem_lock);
+		return 0;
+	}
+	spin_unlock(&drm_mem_lock);
+
+	address = __get_free_pages(GFP_KERNEL, order);
+	if (!address) {
+		spin_lock(&drm_mem_lock);
+		++drm_mem_stats[area].fail_count;
+		spin_unlock(&drm_mem_lock);
+		return 0;
+	}
+	spin_lock(&drm_mem_lock);
+	++drm_mem_stats[area].succeed_count;
+	drm_mem_stats[area].bytes_allocated += bytes;
+	drm_ram_used += bytes;
+	spin_unlock(&drm_mem_lock);
+
+	/* Zero outside the lock */
+	memset((void *)address, 0, bytes);
+
+	/* Reserve */
+	for (addr = address, sz = bytes;
+	     sz > 0; addr += PAGE_SIZE, sz -= PAGE_SIZE) {
+		SetPageReserved(virt_to_page(addr));
+	}
+
+	return address;
+}
+
+void drm_free_pages(unsigned long address, int order, int area)
+{
+	unsigned long bytes = PAGE_SIZE << order;
+	int alloc_count;
+	int free_count;
+	unsigned long addr;
+	unsigned int sz;
+
+	if (!address) {
+		DRM_MEM_ERROR(area, "Attempt to free address 0\n");
+	} else {
+		/* Unreserve */
+		for (addr = address, sz = bytes;
+		     sz > 0; addr += PAGE_SIZE, sz -= PAGE_SIZE) {
+			ClearPageReserved(virt_to_page(addr));
+		}
+		free_pages(address, order);
+	}
+
+	spin_lock(&drm_mem_lock);
+	free_count = ++drm_mem_stats[area].free_count;
+	alloc_count = drm_mem_stats[area].succeed_count;
+	drm_mem_stats[area].bytes_freed += bytes;
+	drm_ram_used -= bytes;
+	spin_unlock(&drm_mem_lock);
+	if (free_count > alloc_count) {
+		DRM_MEM_ERROR(area,
+			      "Excess frees: %d frees, %d allocs\n",
+			      free_count, alloc_count);
+	}
+}
+
+void *drm_ioremap(unsigned long offset, unsigned long size, drm_device_t * dev)
+{
+	void *pt;
+
+	if (!size) {
+		DRM_MEM_ERROR(DRM_MEM_MAPPINGS,
+			      "Mapping 0 bytes at 0x%08lx\n", offset);
+		return NULL;
+	}
+
+	if (!(pt = drm_ioremap(offset, size, dev))) {
+		spin_lock(&drm_mem_lock);
+		++drm_mem_stats[DRM_MEM_MAPPINGS].fail_count;
+		spin_unlock(&drm_mem_lock);
+		return NULL;
+	}
+	spin_lock(&drm_mem_lock);
+	++drm_mem_stats[DRM_MEM_MAPPINGS].succeed_count;
+	drm_mem_stats[DRM_MEM_MAPPINGS].bytes_allocated += size;
+	spin_unlock(&drm_mem_lock);
+	return pt;
+}
+EXPORT_SYMBOL(drm_ioremap);
+
+void *drm_ioremap_nocache(unsigned long offset, unsigned long size,
+			  drm_device_t * dev)
+{
+	void *pt;
+
+	if (!size) {
+		DRM_MEM_ERROR(DRM_MEM_MAPPINGS,
+			      "Mapping 0 bytes at 0x%08lx\n", offset);
+		return NULL;
+	}
+
+	if (!(pt = drm_ioremap_nocache(offset, size, dev))) {
+		spin_lock(&drm_mem_lock);
+		++drm_mem_stats[DRM_MEM_MAPPINGS].fail_count;
+		spin_unlock(&drm_mem_lock);
+		return NULL;
+	}
+	spin_lock(&drm_mem_lock);
+	++drm_mem_stats[DRM_MEM_MAPPINGS].succeed_count;
+	drm_mem_stats[DRM_MEM_MAPPINGS].bytes_allocated += size;
+	spin_unlock(&drm_mem_lock);
+	return pt;
+}
+EXPORT_SYMBOL(drm_ioremap_nocache);
+
+void drm_ioremapfree(void *pt, unsigned long size, drm_device_t * dev)
+{
+	int alloc_count;
+	int free_count;
+
+	if (!pt)
+		DRM_MEM_ERROR(DRM_MEM_MAPPINGS,
+			      "Attempt to free NULL pointer\n");
+	else
+		drm_ioremapfree(pt, size, dev);
+
+	spin_lock(&drm_mem_lock);
+	drm_mem_stats[DRM_MEM_MAPPINGS].bytes_freed += size;
+	free_count = ++drm_mem_stats[DRM_MEM_MAPPINGS].free_count;
+	alloc_count = drm_mem_stats[DRM_MEM_MAPPINGS].succeed_count;
+	spin_unlock(&drm_mem_lock);
+	if (free_count > alloc_count) {
+		DRM_MEM_ERROR(DRM_MEM_MAPPINGS,
+			      "Excess frees: %d frees, %d allocs\n",
+			      free_count, alloc_count);
+	}
+}
+EXPORT_SYMBOL(drm_ioremapfree);
+
+#if __OS_HAS_AGP
+
+DRM_AGP_MEM *drm_alloc_agp(drm_device_t *dev, int pages, u32 type)
+{
+	DRM_AGP_MEM *handle;
+
+	if (!pages) {
+		DRM_MEM_ERROR(DRM_MEM_TOTALAGP, "Allocating 0 pages\n");
+		return NULL;
+	}
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,11)
+	if ((handle = drm_agp_allocate_memory(pages, type))) {
+#else
+	if ((handle = drm_agp_allocate_memory(dev->agp->bridge, pages, type))) {
+#endif
+		spin_lock(&drm_mem_lock);
+		++drm_mem_stats[DRM_MEM_TOTALAGP].succeed_count;
+		drm_mem_stats[DRM_MEM_TOTALAGP].bytes_allocated
+		    += pages << PAGE_SHIFT;
+		spin_unlock(&drm_mem_lock);
+		return handle;
+	}
+	spin_lock(&drm_mem_lock);
+	++drm_mem_stats[DRM_MEM_TOTALAGP].fail_count;
+	spin_unlock(&drm_mem_lock);
+	return NULL;
+}
+EXPORT_SYMBOL(drm_alloc_agp);
+
+int drm_free_agp(DRM_AGP_MEM * handle, int pages)
+{
+	int alloc_count;
+	int free_count;
+	int retval = -EINVAL;
+
+	if (!handle) {
+		DRM_MEM_ERROR(DRM_MEM_TOTALAGP,
+			      "Attempt to free NULL AGP handle\n");
+		return retval;
+	}
+
+	if (drm_agp_free_memory(handle)) {
+		spin_lock(&drm_mem_lock);
+		free_count = ++drm_mem_stats[DRM_MEM_TOTALAGP].free_count;
+		alloc_count = drm_mem_stats[DRM_MEM_TOTALAGP].succeed_count;
+		drm_mem_stats[DRM_MEM_TOTALAGP].bytes_freed
+		    += pages << PAGE_SHIFT;
+		spin_unlock(&drm_mem_lock);
+		if (free_count > alloc_count) {
+			DRM_MEM_ERROR(DRM_MEM_TOTALAGP,
+				      "Excess frees: %d frees, %d allocs\n",
+				      free_count, alloc_count);
+		}
+		return 0;
+	}
+	return retval;
+}
+EXPORT_SYMBOL(drm_free_agp);
+
+int drm_bind_agp(DRM_AGP_MEM * handle, unsigned int start)
+{
+	int retcode = -EINVAL;
+
+	if (!handle) {
+		DRM_MEM_ERROR(DRM_MEM_BOUNDAGP,
+			      "Attempt to bind NULL AGP handle\n");
+		return retcode;
+	}
+
+	if (!(retcode = drm_agp_bind_memory(handle, start))) {
+		spin_lock(&drm_mem_lock);
+		++drm_mem_stats[DRM_MEM_BOUNDAGP].succeed_count;
+		drm_mem_stats[DRM_MEM_BOUNDAGP].bytes_allocated
+		    += handle->page_count << PAGE_SHIFT;
+		spin_unlock(&drm_mem_lock);
+		return retcode;
+	}
+	spin_lock(&drm_mem_lock);
+	++drm_mem_stats[DRM_MEM_BOUNDAGP].fail_count;
+	spin_unlock(&drm_mem_lock);
+	return retcode;
+}
+EXPORT_SYMBOL(drm_bind_agp);
+
+int drm_unbind_agp(DRM_AGP_MEM * handle)
+{
+	int alloc_count;
+	int free_count;
+	int retcode = -EINVAL;
+
+	if (!handle) {
+		DRM_MEM_ERROR(DRM_MEM_BOUNDAGP,
+			      "Attempt to unbind NULL AGP handle\n");
+		return retcode;
+	}
+
+	if ((retcode = drm_agp_unbind_memory(handle)))
+		return retcode;
+	spin_lock(&drm_mem_lock);
+	free_count = ++drm_mem_stats[DRM_MEM_BOUNDAGP].free_count;
+	alloc_count = drm_mem_stats[DRM_MEM_BOUNDAGP].succeed_count;
+	drm_mem_stats[DRM_MEM_BOUNDAGP].bytes_freed
+	    += handle->page_count << PAGE_SHIFT;
+	spin_unlock(&drm_mem_lock);
+	if (free_count > alloc_count) {
+		DRM_MEM_ERROR(DRM_MEM_BOUNDAGP,
+			      "Excess frees: %d frees, %d allocs\n",
+			      free_count, alloc_count);
+	}
+	return retcode;
+}
+EXPORT_SYMBOL(drm_unbind_agp);
+
+#endif
+#endif
diff -purN linux-2.6.12.orig/drivers/char/drm/drm_memory_debug.h linux-2.6.12/drivers/char/drm/drm_memory_debug.h
--- linux-2.6.12.orig/drivers/char/drm/drm_memory_debug.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/drm_memory_debug.h	2005-07-05 08:37:30.000000000 +0200
@@ -1,5 +1,5 @@
 /**
- * \file drm_memory.h 
+ * \file drm_memory_debug.h
  * Memory management wrappers for DRM.
  *
  * \author Rickard E. (Rik) Faith <faith@valinux.com>
@@ -35,75 +35,74 @@
 #include "drmP.h"
 
 typedef struct drm_mem_stats {
-	const char	  *name;
-	int		  succeed_count;
-	int		  free_count;
-	int		  fail_count;
-	unsigned long	  bytes_allocated;
-	unsigned long	  bytes_freed;
+	const char *name;
+	int succeed_count;
+	int free_count;
+	int fail_count;
+	unsigned long bytes_allocated;
+	unsigned long bytes_freed;
 } drm_mem_stats_t;
 
-static DEFINE_SPINLOCK(DRM(mem_lock));
-static unsigned long	  DRM(ram_available) = 0; /* In pages */
-static unsigned long	  DRM(ram_used)      = 0;
-static drm_mem_stats_t	  DRM(mem_stats)[]   = {
-	[DRM_MEM_DMA]	    = { "dmabufs"  },
-	[DRM_MEM_SAREA]	    = { "sareas"   },
-	[DRM_MEM_DRIVER]    = { "driver"   },
-	[DRM_MEM_MAGIC]	    = { "magic"	   },
-	[DRM_MEM_IOCTLS]    = { "ioctltab" },
-	[DRM_MEM_MAPS]	    = { "maplist"  },
-	[DRM_MEM_VMAS]	    = { "vmalist"  },
-	[DRM_MEM_BUFS]	    = { "buflist"  },
-	[DRM_MEM_SEGS]	    = { "seglist"  },
-	[DRM_MEM_PAGES]	    = { "pagelist" },
-	[DRM_MEM_FILES]	    = { "files"	   },
-	[DRM_MEM_QUEUES]    = { "queues"   },
-	[DRM_MEM_CMDS]	    = { "commands" },
-	[DRM_MEM_MAPPINGS]  = { "mappings" },
-	[DRM_MEM_BUFLISTS]  = { "buflists" },
-	[DRM_MEM_AGPLISTS]  = { "agplist"  },
-	[DRM_MEM_SGLISTS]   = { "sglist"   },
-	[DRM_MEM_TOTALAGP]  = { "totalagp" },
-	[DRM_MEM_BOUNDAGP]  = { "boundagp" },
-	[DRM_MEM_CTXBITMAP] = { "ctxbitmap"},
-	[DRM_MEM_CTXLIST]   = { "ctxlist"  },
-	[DRM_MEM_STUB]      = { "stub"     },
-	{ NULL, 0, }		/* Last entry must be null */
+static spinlock_t drm_mem_lock = SPIN_LOCK_UNLOCKED;
+static unsigned long drm_ram_available = 0;	/* In pages */
+static unsigned long drm_ram_used = 0;
+static drm_mem_stats_t drm_mem_stats[] =
+{
+	[DRM_MEM_DMA] = {"dmabufs"},
+	[DRM_MEM_SAREA] = {"sareas"},
+	[DRM_MEM_DRIVER] = {"driver"},
+	[DRM_MEM_MAGIC] = {"magic"},
+	[DRM_MEM_IOCTLS] = {"ioctltab"},
+	[DRM_MEM_MAPS] = {"maplist"},
+	[DRM_MEM_VMAS] = {"vmalist"},
+	[DRM_MEM_BUFS] = {"buflist"},
+	[DRM_MEM_SEGS] = {"seglist"},
+	[DRM_MEM_PAGES] = {"pagelist"},
+	[DRM_MEM_FILES] = {"files"},
+	[DRM_MEM_QUEUES] = {"queues"},
+	[DRM_MEM_CMDS] = {"commands"},
+	[DRM_MEM_MAPPINGS] = {"mappings"},
+	[DRM_MEM_BUFLISTS] = {"buflists"},
+	[DRM_MEM_AGPLISTS] = {"agplist"},
+	[DRM_MEM_SGLISTS] = {"sglist"},
+	[DRM_MEM_TOTALAGP] = {"totalagp"},
+	[DRM_MEM_BOUNDAGP] = {"boundagp"},
+	[DRM_MEM_CTXBITMAP] = {"ctxbitmap"},
+	[DRM_MEM_CTXLIST] = {"ctxlist"},
+	[DRM_MEM_STUB] = {"stub"},
+	{NULL, 0,}		/* Last entry must be null */
 };
 
-void DRM(mem_init)(void)
-{
+void drm_mem_init (void) {
 	drm_mem_stats_t *mem;
-	struct sysinfo	si;
+	struct sysinfo si;
 
-	for (mem = DRM(mem_stats); mem->name; ++mem) {
-		mem->succeed_count   = 0;
-		mem->free_count	     = 0;
-		mem->fail_count	     = 0;
+	for (mem = drm_mem_stats; mem->name; ++mem) {
+		mem->succeed_count = 0;
+		mem->free_count = 0;
+		mem->fail_count = 0;
 		mem->bytes_allocated = 0;
-		mem->bytes_freed     = 0;
+		mem->bytes_freed = 0;
 	}
 
 	si_meminfo(&si);
-	DRM(ram_available) = si.totalram;
-	DRM(ram_used)	   = 0;
+	drm_ram_available = si.totalram;
+	drm_ram_used = 0;
 }
 
 /* drm_mem_info is called whenever a process reads /dev/drm/mem. */
 
-static int DRM(_mem_info)(char *buf, char **start, off_t offset,
-			  int request, int *eof, void *data)
-{
+static int drm__mem_info (char *buf, char **start, off_t offset,
+			   int request, int *eof, void *data) {
 	drm_mem_stats_t *pt;
-	int             len = 0;
+	int len = 0;
 
 	if (offset > DRM_PROC_LIMIT) {
 		*eof = 1;
 		return 0;
 	}
 
-	*eof   = 0;
+	*eof = 0;
 	*start = &buf[offset];
 
 	DRM_PROC_PRINT("		  total counts			"
@@ -112,11 +111,11 @@ static int DRM(_mem_info)(char *buf, cha
 		       " | allocs      bytes\n\n");
 	DRM_PROC_PRINT("%-9.9s %5d %5d %4d %10lu kB         |\n",
 		       "system", 0, 0, 0,
-		       DRM(ram_available) << (PAGE_SHIFT - 10));
+		       drm_ram_available << (PAGE_SHIFT - 10));
 	DRM_PROC_PRINT("%-9.9s %5d %5d %4d %10lu kB         |\n",
-		       "locked", 0, 0, 0, DRM(ram_used) >> 10);
+		       "locked", 0, 0, 0, drm_ram_used >> 10);
 	DRM_PROC_PRINT("\n");
-	for (pt = DRM(mem_stats); pt->name; pt++) {
+	for (pt = drm_mem_stats; pt->name; pt++) {
 		DRM_PROC_PRINT("%-9.9s %5d %5d %4d %10lu %10lu | %6d %10ld\n",
 			       pt->name,
 			       pt->succeed_count,
@@ -129,24 +128,23 @@ static int DRM(_mem_info)(char *buf, cha
 			       - (long)pt->bytes_freed);
 	}
 
-	if (len > request + offset) return request;
+	if (len > request + offset)
+		return request;
 	*eof = 1;
 	return len - offset;
 }
 
-int DRM(mem_info)(char *buf, char **start, off_t offset,
-		  int len, int *eof, void *data)
-{
+int drm_mem_info (char *buf, char **start, off_t offset,
+		   int len, int *eof, void *data) {
 	int ret;
 
-	spin_lock(&DRM(mem_lock));
-	ret = DRM(_mem_info)(buf, start, offset, len, eof, data);
-	spin_unlock(&DRM(mem_lock));
+	spin_lock(&drm_mem_lock);
+	ret = drm__mem_info (buf, start, offset, len, eof, data);
+	spin_unlock(&drm_mem_lock);
 	return ret;
 }
 
-void *DRM(alloc)(size_t size, int area)
-{
+void *drm_alloc (size_t size, int area) {
 	void *pt;
 
 	if (!size) {
@@ -155,127 +153,122 @@ void *DRM(alloc)(size_t size, int area)
 	}
 
 	if (!(pt = kmalloc(size, GFP_KERNEL))) {
-		spin_lock(&DRM(mem_lock));
-		++DRM(mem_stats)[area].fail_count;
-		spin_unlock(&DRM(mem_lock));
+		spin_lock(&drm_mem_lock);
+		++drm_mem_stats[area].fail_count;
+		spin_unlock(&drm_mem_lock);
 		return NULL;
 	}
-	spin_lock(&DRM(mem_lock));
-	++DRM(mem_stats)[area].succeed_count;
-	DRM(mem_stats)[area].bytes_allocated += size;
-	spin_unlock(&DRM(mem_lock));
+	spin_lock(&drm_mem_lock);
+	++drm_mem_stats[area].succeed_count;
+	drm_mem_stats[area].bytes_allocated += size;
+	spin_unlock(&drm_mem_lock);
 	return pt;
 }
 
-void *DRM(calloc)(size_t nmemb, size_t size, int area)
-{
+void *drm_calloc (size_t nmemb, size_t size, int area) {
 	void *addr;
 
-	addr = DRM(alloc)(nmemb * size, area);
+	addr = drm_alloc (nmemb * size, area);
 	if (addr != NULL)
 		memset((void *)addr, 0, size * nmemb);
 
 	return addr;
 }
 
-void *DRM(realloc)(void *oldpt, size_t oldsize, size_t size, int area)
-{
+void *drm_realloc (void *oldpt, size_t oldsize, size_t size, int area) {
 	void *pt;
 
-	if (!(pt = DRM(alloc)(size, area))) return NULL;
+	if (!(pt = drm_alloc (size, area)))
+		return NULL;
 	if (oldpt && oldsize) {
 		memcpy(pt, oldpt, oldsize);
-		DRM(free)(oldpt, oldsize, area);
+		drm_free (oldpt, oldsize, area);
 	}
 	return pt;
 }
 
-void DRM(free)(void *pt, size_t size, int area)
-{
+void drm_free (void *pt, size_t size, int area) {
 	int alloc_count;
 	int free_count;
 
-	if (!pt) DRM_MEM_ERROR(area, "Attempt to free NULL pointer\n");
-	else	 kfree(pt);
-	spin_lock(&DRM(mem_lock));
-	DRM(mem_stats)[area].bytes_freed += size;
-	free_count  = ++DRM(mem_stats)[area].free_count;
-	alloc_count =	DRM(mem_stats)[area].succeed_count;
-	spin_unlock(&DRM(mem_lock));
+	if (!pt)
+		DRM_MEM_ERROR(area, "Attempt to free NULL pointer\n");
+	else
+		kfree(pt);
+	spin_lock(&drm_mem_lock);
+	drm_mem_stats[area].bytes_freed += size;
+	free_count = ++drm_mem_stats[area].free_count;
+	alloc_count = drm_mem_stats[area].succeed_count;
+	spin_unlock(&drm_mem_lock);
 	if (free_count > alloc_count) {
 		DRM_MEM_ERROR(area, "Excess frees: %d frees, %d allocs\n",
 			      free_count, alloc_count);
 	}
 }
 
-unsigned long DRM(alloc_pages)(int order, int area)
-{
+unsigned long drm_alloc_pages (int order, int area) {
 	unsigned long address;
-	unsigned long bytes	  = PAGE_SIZE << order;
+	unsigned long bytes = PAGE_SIZE << order;
 	unsigned long addr;
-	unsigned int  sz;
+	unsigned int sz;
 
-	spin_lock(&DRM(mem_lock));
-	if ((DRM(ram_used) >> PAGE_SHIFT)
-	    > (DRM_RAM_PERCENT * DRM(ram_available)) / 100) {
-		spin_unlock(&DRM(mem_lock));
+	spin_lock(&drm_mem_lock);
+	if ((drm_ram_used >> PAGE_SHIFT)
+	    > (DRM_RAM_PERCENT * drm_ram_available) / 100) {
+		spin_unlock(&drm_mem_lock);
 		return 0;
 	}
-	spin_unlock(&DRM(mem_lock));
+	spin_unlock(&drm_mem_lock);
 
 	address = __get_free_pages(GFP_KERNEL, order);
 	if (!address) {
-		spin_lock(&DRM(mem_lock));
-		++DRM(mem_stats)[area].fail_count;
-		spin_unlock(&DRM(mem_lock));
+		spin_lock(&drm_mem_lock);
+		++drm_mem_stats[area].fail_count;
+		spin_unlock(&drm_mem_lock);
 		return 0;
 	}
-	spin_lock(&DRM(mem_lock));
-	++DRM(mem_stats)[area].succeed_count;
-	DRM(mem_stats)[area].bytes_allocated += bytes;
-	DRM(ram_used)		             += bytes;
-	spin_unlock(&DRM(mem_lock));
-
+	spin_lock(&drm_mem_lock);
+	++drm_mem_stats[area].succeed_count;
+	drm_mem_stats[area].bytes_allocated += bytes;
+	drm_ram_used += bytes;
+	spin_unlock(&drm_mem_lock);
 
-				/* Zero outside the lock */
+	/* Zero outside the lock */
 	memset((void *)address, 0, bytes);
 
-				/* Reserve */
+	/* Reserve */
 	for (addr = address, sz = bytes;
-	     sz > 0;
-	     addr += PAGE_SIZE, sz -= PAGE_SIZE) {
+	     sz > 0; addr += PAGE_SIZE, sz -= PAGE_SIZE) {
 		SetPageReserved(virt_to_page(addr));
 	}
 
 	return address;
 }
 
-void DRM(free_pages)(unsigned long address, int order, int area)
-{
+void drm_free_pages (unsigned long address, int order, int area) {
 	unsigned long bytes = PAGE_SIZE << order;
-	int		  alloc_count;
-	int		  free_count;
+	int alloc_count;
+	int free_count;
 	unsigned long addr;
-	unsigned int  sz;
+	unsigned int sz;
 
 	if (!address) {
 		DRM_MEM_ERROR(area, "Attempt to free address 0\n");
 	} else {
-				/* Unreserve */
+		/* Unreserve */
 		for (addr = address, sz = bytes;
-		     sz > 0;
-		     addr += PAGE_SIZE, sz -= PAGE_SIZE) {
+		     sz > 0; addr += PAGE_SIZE, sz -= PAGE_SIZE) {
 			ClearPageReserved(virt_to_page(addr));
 		}
 		free_pages(address, order);
 	}
 
-	spin_lock(&DRM(mem_lock));
-	free_count  = ++DRM(mem_stats)[area].free_count;
-	alloc_count =	DRM(mem_stats)[area].succeed_count;
-	DRM(mem_stats)[area].bytes_freed += bytes;
-	DRM(ram_used)			 -= bytes;
-	spin_unlock(&DRM(mem_lock));
+	spin_lock(&drm_mem_lock);
+	free_count = ++drm_mem_stats[area].free_count;
+	alloc_count = drm_mem_stats[area].succeed_count;
+	drm_mem_stats[area].bytes_freed += bytes;
+	drm_ram_used -= bytes;
+	spin_unlock(&drm_mem_lock);
 	if (free_count > alloc_count) {
 		DRM_MEM_ERROR(area,
 			      "Excess frees: %d frees, %d allocs\n",
@@ -283,8 +276,8 @@ void DRM(free_pages)(unsigned long addre
 	}
 }
 
-void *DRM(ioremap)(unsigned long offset, unsigned long size, drm_device_t *dev)
-{
+void *drm_ioremap (unsigned long offset, unsigned long size,
+		    drm_device_t * dev) {
 	void *pt;
 
 	if (!size) {
@@ -294,20 +287,20 @@ void *DRM(ioremap)(unsigned long offset,
 	}
 
 	if (!(pt = drm_ioremap(offset, size, dev))) {
-		spin_lock(&DRM(mem_lock));
-		++DRM(mem_stats)[DRM_MEM_MAPPINGS].fail_count;
-		spin_unlock(&DRM(mem_lock));
+		spin_lock(&drm_mem_lock);
+		++drm_mem_stats[DRM_MEM_MAPPINGS].fail_count;
+		spin_unlock(&drm_mem_lock);
 		return NULL;
 	}
-	spin_lock(&DRM(mem_lock));
-	++DRM(mem_stats)[DRM_MEM_MAPPINGS].succeed_count;
-	DRM(mem_stats)[DRM_MEM_MAPPINGS].bytes_allocated += size;
-	spin_unlock(&DRM(mem_lock));
+	spin_lock(&drm_mem_lock);
+	++drm_mem_stats[DRM_MEM_MAPPINGS].succeed_count;
+	drm_mem_stats[DRM_MEM_MAPPINGS].bytes_allocated += size;
+	spin_unlock(&drm_mem_lock);
 	return pt;
 }
 
-void *DRM(ioremap_nocache)(unsigned long offset, unsigned long size, drm_device_t *dev)
-{
+void *drm_ioremap_nocache (unsigned long offset, unsigned long size,
+			    drm_device_t * dev) {
 	void *pt;
 
 	if (!size) {
@@ -317,20 +310,19 @@ void *DRM(ioremap_nocache)(unsigned long
 	}
 
 	if (!(pt = drm_ioremap_nocache(offset, size, dev))) {
-		spin_lock(&DRM(mem_lock));
-		++DRM(mem_stats)[DRM_MEM_MAPPINGS].fail_count;
-		spin_unlock(&DRM(mem_lock));
+		spin_lock(&drm_mem_lock);
+		++drm_mem_stats[DRM_MEM_MAPPINGS].fail_count;
+		spin_unlock(&drm_mem_lock);
 		return NULL;
 	}
-	spin_lock(&DRM(mem_lock));
-	++DRM(mem_stats)[DRM_MEM_MAPPINGS].succeed_count;
-	DRM(mem_stats)[DRM_MEM_MAPPINGS].bytes_allocated += size;
-	spin_unlock(&DRM(mem_lock));
+	spin_lock(&drm_mem_lock);
+	++drm_mem_stats[DRM_MEM_MAPPINGS].succeed_count;
+	drm_mem_stats[DRM_MEM_MAPPINGS].bytes_allocated += size;
+	spin_unlock(&drm_mem_lock);
 	return pt;
 }
 
-void DRM(ioremapfree)(void *pt, unsigned long size, drm_device_t *dev)
-{
+void drm_ioremapfree (void *pt, unsigned long size, drm_device_t * dev) {
 	int alloc_count;
 	int free_count;
 
@@ -340,11 +332,11 @@ void DRM(ioremapfree)(void *pt, unsigned
 	else
 		drm_ioremapfree(pt, size, dev);
 
-	spin_lock(&DRM(mem_lock));
-	DRM(mem_stats)[DRM_MEM_MAPPINGS].bytes_freed += size;
-	free_count  = ++DRM(mem_stats)[DRM_MEM_MAPPINGS].free_count;
-	alloc_count =	DRM(mem_stats)[DRM_MEM_MAPPINGS].succeed_count;
-	spin_unlock(&DRM(mem_lock));
+	spin_lock(&drm_mem_lock);
+	drm_mem_stats[DRM_MEM_MAPPINGS].bytes_freed += size;
+	free_count = ++drm_mem_stats[DRM_MEM_MAPPINGS].free_count;
+	alloc_count = drm_mem_stats[DRM_MEM_MAPPINGS].succeed_count;
+	spin_unlock(&drm_mem_lock);
 	if (free_count > alloc_count) {
 		DRM_MEM_ERROR(DRM_MEM_MAPPINGS,
 			      "Excess frees: %d frees, %d allocs\n",
@@ -354,8 +346,7 @@ void DRM(ioremapfree)(void *pt, unsigned
 
 #if __OS_HAS_AGP
 
-DRM_AGP_MEM *DRM(alloc_agp)(int pages, u32 type)
-{
+DRM_AGP_MEM *drm_alloc_agp (drm_device_t *dev, int pages, u32 type) {
 	DRM_AGP_MEM *handle;
 
 	if (!pages) {
@@ -363,25 +354,24 @@ DRM_AGP_MEM *DRM(alloc_agp)(int pages, u
 		return NULL;
 	}
 
-	if ((handle = DRM(agp_allocate_memory)(pages, type))) {
-		spin_lock(&DRM(mem_lock));
-		++DRM(mem_stats)[DRM_MEM_TOTALAGP].succeed_count;
-		DRM(mem_stats)[DRM_MEM_TOTALAGP].bytes_allocated
-			+= pages << PAGE_SHIFT;
-		spin_unlock(&DRM(mem_lock));
+	if ((handle = drm_agp_allocate_memory (pages, type))) {
+		spin_lock(&drm_mem_lock);
+		++drm_mem_stats[DRM_MEM_TOTALAGP].succeed_count;
+		drm_mem_stats[DRM_MEM_TOTALAGP].bytes_allocated
+		    += pages << PAGE_SHIFT;
+		spin_unlock(&drm_mem_lock);
 		return handle;
 	}
-	spin_lock(&DRM(mem_lock));
-	++DRM(mem_stats)[DRM_MEM_TOTALAGP].fail_count;
-	spin_unlock(&DRM(mem_lock));
+	spin_lock(&drm_mem_lock);
+	++drm_mem_stats[DRM_MEM_TOTALAGP].fail_count;
+	spin_unlock(&drm_mem_lock);
 	return NULL;
 }
 
-int DRM(free_agp)(DRM_AGP_MEM *handle, int pages)
-{
-	int           alloc_count;
-	int           free_count;
-	int           retval = -EINVAL;
+int drm_free_agp (DRM_AGP_MEM * handle, int pages) {
+	int alloc_count;
+	int free_count;
+	int retval = -EINVAL;
 
 	if (!handle) {
 		DRM_MEM_ERROR(DRM_MEM_TOTALAGP,
@@ -389,13 +379,13 @@ int DRM(free_agp)(DRM_AGP_MEM *handle, i
 		return retval;
 	}
 
-	if (DRM(agp_free_memory)(handle)) {
-		spin_lock(&DRM(mem_lock));
-		free_count  = ++DRM(mem_stats)[DRM_MEM_TOTALAGP].free_count;
-		alloc_count =   DRM(mem_stats)[DRM_MEM_TOTALAGP].succeed_count;
-		DRM(mem_stats)[DRM_MEM_TOTALAGP].bytes_freed
-			+= pages << PAGE_SHIFT;
-		spin_unlock(&DRM(mem_lock));
+	if (drm_agp_free_memory (handle)) {
+		spin_lock(&drm_mem_lock);
+		free_count = ++drm_mem_stats[DRM_MEM_TOTALAGP].free_count;
+		alloc_count = drm_mem_stats[DRM_MEM_TOTALAGP].succeed_count;
+		drm_mem_stats[DRM_MEM_TOTALAGP].bytes_freed
+		    += pages << PAGE_SHIFT;
+		spin_unlock(&drm_mem_lock);
 		if (free_count > alloc_count) {
 			DRM_MEM_ERROR(DRM_MEM_TOTALAGP,
 				      "Excess frees: %d frees, %d allocs\n",
@@ -406,8 +396,7 @@ int DRM(free_agp)(DRM_AGP_MEM *handle, i
 	return retval;
 }
 
-int DRM(bind_agp)(DRM_AGP_MEM *handle, unsigned int start)
-{
+int drm_bind_agp (DRM_AGP_MEM * handle, unsigned int start) {
 	int retcode = -EINVAL;
 
 	if (!handle) {
@@ -416,22 +405,21 @@ int DRM(bind_agp)(DRM_AGP_MEM *handle, u
 		return retcode;
 	}
 
-	if (!(retcode = DRM(agp_bind_memory)(handle, start))) {
-		spin_lock(&DRM(mem_lock));
-		++DRM(mem_stats)[DRM_MEM_BOUNDAGP].succeed_count;
-		DRM(mem_stats)[DRM_MEM_BOUNDAGP].bytes_allocated
-			+= handle->page_count << PAGE_SHIFT;
-		spin_unlock(&DRM(mem_lock));
+	if (!(retcode = drm_agp_bind_memory (handle, start))) {
+		spin_lock(&drm_mem_lock);
+		++drm_mem_stats[DRM_MEM_BOUNDAGP].succeed_count;
+		drm_mem_stats[DRM_MEM_BOUNDAGP].bytes_allocated
+		    += handle->page_count << PAGE_SHIFT;
+		spin_unlock(&drm_mem_lock);
 		return retcode;
 	}
-	spin_lock(&DRM(mem_lock));
-	++DRM(mem_stats)[DRM_MEM_BOUNDAGP].fail_count;
-	spin_unlock(&DRM(mem_lock));
+	spin_lock(&drm_mem_lock);
+	++drm_mem_stats[DRM_MEM_BOUNDAGP].fail_count;
+	spin_unlock(&drm_mem_lock);
 	return retcode;
 }
 
-int DRM(unbind_agp)(DRM_AGP_MEM *handle)
-{
+int drm_unbind_agp (DRM_AGP_MEM * handle) {
 	int alloc_count;
 	int free_count;
 	int retcode = -EINVAL;
@@ -442,13 +430,14 @@ int DRM(unbind_agp)(DRM_AGP_MEM *handle)
 		return retcode;
 	}
 
-	if ((retcode = DRM(agp_unbind_memory)(handle))) return retcode;
-	spin_lock(&DRM(mem_lock));
-	free_count  = ++DRM(mem_stats)[DRM_MEM_BOUNDAGP].free_count;
-	alloc_count = DRM(mem_stats)[DRM_MEM_BOUNDAGP].succeed_count;
-	DRM(mem_stats)[DRM_MEM_BOUNDAGP].bytes_freed
-		+= handle->page_count << PAGE_SHIFT;
-	spin_unlock(&DRM(mem_lock));
+	if ((retcode = drm_agp_unbind_memory (handle)))
+		return retcode;
+	spin_lock(&drm_mem_lock);
+	free_count = ++drm_mem_stats[DRM_MEM_BOUNDAGP].free_count;
+	alloc_count = drm_mem_stats[DRM_MEM_BOUNDAGP].succeed_count;
+	drm_mem_stats[DRM_MEM_BOUNDAGP].bytes_freed
+	    += handle->page_count << PAGE_SHIFT;
+	spin_unlock(&drm_mem_lock);
 	if (free_count > alloc_count) {
 		DRM_MEM_ERROR(DRM_MEM_BOUNDAGP,
 			      "Excess frees: %d frees, %d allocs\n",
diff -purN linux-2.6.12.orig/drivers/char/drm/drm_memory.h linux-2.6.12/drivers/char/drm/drm_memory.h
--- linux-2.6.12.orig/drivers/char/drm/drm_memory.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/drm_memory.h	2005-07-05 08:37:30.000000000 +0200
@@ -1,12 +1,12 @@
-/** 
- * \file drm_memory.h 
+/**
+ * \file drm_memory.h
  * Memory management wrappers for DRM
  *
  * \author Rickard E. (Rik) Faith <faith@valinux.com>
  * \author Gareth Hughes <gareth@valinux.com>
  */
 
-/* 
+/*
  * Created: Thu Feb  4 14:00:34 1999 by faith@valinux.com
  *
  * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
@@ -35,15 +35,15 @@
 
 #include <linux/config.h>
 #include <linux/highmem.h>
-#include <linux/vmalloc.h>
 #include "drmP.h"
 
 /**
  * Cut down version of drm_memory_debug.h, which used to be called
- * drm_memory.h.  
+ * drm_memory.h.
  */
 
-#if __OS_HAS_AGP
+/* Need the 4-argument version of vmap().  */
+#if __OS_HAS_AGP && defined(VMAP_4_ARGS)
 
 #include <linux/vmalloc.h>
 
@@ -57,11 +57,23 @@
 # endif
 #endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#ifndef pte_offset_kernel
+# define pte_offset_kernel(dir, address)	pte_offset(dir, address)
+#endif
+#ifndef pte_pfn
+# define pte_pfn(pte)				(pte_page(pte) - mem_map)
+#endif
+#ifndef pfn_to_page
+# define pfn_to_page(pfn)			(mem_map + (pfn))
+#endif
+#endif
+
 /*
  * Find the drm_map that covers the range [offset, offset+size).
  */
-static inline drm_map_t *
-drm_lookup_map (unsigned long offset, unsigned long size, drm_device_t *dev)
+static inline drm_map_t *drm_lookup_map(unsigned long offset,
+					unsigned long size, drm_device_t * dev)
 {
 	struct list_head *list;
 	drm_map_list_t *r_list;
@@ -72,16 +84,18 @@ drm_lookup_map (unsigned long offset, un
 		map = r_list->map;
 		if (!map)
 			continue;
-		if (map->offset <= offset && (offset + size) <= (map->offset + map->size))
+		if (map->offset <= offset
+		    && (offset + size) <= (map->offset + map->size))
 			return map;
 	}
 	return NULL;
 }
 
-static inline void *
-agp_remap (unsigned long offset, unsigned long size, drm_device_t *dev)
+static inline void *agp_remap(unsigned long offset, unsigned long size,
+			      drm_device_t * dev)
 {
-	unsigned long *phys_addr_map, i, num_pages = PAGE_ALIGN(size) / PAGE_SIZE;
+	unsigned long *phys_addr_map, i, num_pages =
+	    PAGE_ALIGN(size) / PAGE_SIZE;
 	struct drm_agp_mem *agpmem;
 	struct page **page_map;
 	void *addr;
@@ -94,7 +108,8 @@ agp_remap (unsigned long offset, unsigne
 
 	for (agpmem = dev->agp->memory; agpmem; agpmem = agpmem->next)
 		if (agpmem->bound <= offset
-		    && (agpmem->bound + (agpmem->pages << PAGE_SHIFT)) >= (offset + size))
+		    && (agpmem->bound + (agpmem->pages << PAGE_SHIFT)) >=
+		    (offset + size))
 			break;
 	if (!agpmem)
 		return NULL;
@@ -109,7 +124,8 @@ agp_remap (unsigned long offset, unsigne
 	if (!page_map)
 		return NULL;
 
-	phys_addr_map = agpmem->memory->memory + (offset - agpmem->bound) / PAGE_SIZE;
+	phys_addr_map =
+	    agpmem->memory->memory + (offset - agpmem->bound) / PAGE_SIZE;
 	for (i = 0; i < num_pages; ++i)
 		page_map[i] = pfn_to_page(phys_addr_map[i] >> PAGE_SHIFT);
 	addr = vmap(page_map, num_pages, VM_IOREMAP, PAGE_AGP);
@@ -118,80 +134,100 @@ agp_remap (unsigned long offset, unsigne
 	return addr;
 }
 
-static inline unsigned long
-drm_follow_page (void *vaddr)
+static inline unsigned long drm_follow_page(void *vaddr)
 {
 	pgd_t *pgd = pgd_offset_k((unsigned long) vaddr);
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,10)
+	pmd_t *pmd = pmd_offset(pgd, (unsigned long)vaddr);
+#else
 	pud_t *pud = pud_offset(pgd, (unsigned long) vaddr);
 	pmd_t *pmd = pmd_offset(pud, (unsigned long) vaddr);
+#endif
 	pte_t *ptep = pte_offset_kernel(pmd, (unsigned long) vaddr);
 	return pte_pfn(*ptep) << PAGE_SHIFT;
 }
 
-#else /* __OS_HAS_AGP */
+#else				/* __OS_HAS_AGP */
 
-static inline drm_map_t *drm_lookup_map(unsigned long offset, unsigned long size, drm_device_t *dev)
+static inline drm_map_t *drm_lookup_map(unsigned long offset,
+					unsigned long size, drm_device_t * dev)
 {
-  return NULL;
+	return NULL;
 }
 
-static inline void *agp_remap(unsigned long offset, unsigned long size, drm_device_t *dev)
+static inline void *agp_remap(unsigned long offset, unsigned long size,
+			      drm_device_t * dev)
 {
-  return NULL;
+	return NULL;
 }
 
-static inline unsigned long drm_follow_page (void *vaddr)
+static inline unsigned long drm_follow_page(void *vaddr)
 {
-  return 0;
+	return 0;
 }
-
 #endif
 
-static inline void *drm_ioremap(unsigned long offset, unsigned long size, drm_device_t *dev)
+#ifndef DEBUG_MEMORY
+static inline void *drm_ioremap(unsigned long offset, unsigned long size,
+				drm_device_t * dev)
 {
+#if defined(VMAP_4_ARGS)
 	if (drm_core_has_AGP(dev) && dev->agp && dev->agp->cant_use_aperture) {
 		drm_map_t *map = drm_lookup_map(offset, size, dev);
 
 		if (map && map->type == _DRM_AGP)
 			return agp_remap(offset, size, dev);
 	}
+#endif
+
 	return ioremap(offset, size);
 }
 
-static inline void *drm_ioremap_nocache(unsigned long offset, unsigned long size,
-					drm_device_t *dev)
+static inline void *drm_ioremap_nocache(unsigned long offset,
+					unsigned long size, drm_device_t * dev)
 {
+#if defined(VMAP_4_ARGS)
 	if (drm_core_has_AGP(dev) && dev->agp && dev->agp->cant_use_aperture) {
 		drm_map_t *map = drm_lookup_map(offset, size, dev);
 
 		if (map && map->type == _DRM_AGP)
 			return agp_remap(offset, size, dev);
 	}
+#endif
+
 	return ioremap_nocache(offset, size);
 }
 
-static inline void drm_ioremapfree(void *pt, unsigned long size, drm_device_t *dev)
+static inline void drm_ioremapfree(void *pt, unsigned long size,
+				   drm_device_t * dev)
 {
+#if defined(VMAP_4_ARGS)
 	/*
 	 * This is a bit ugly.  It would be much cleaner if the DRM API would use separate
 	 * routines for handling mappings in the AGP space.  Hopefully this can be done in
 	 * a future revision of the interface...
 	 */
 	if (drm_core_has_AGP(dev) && dev->agp && dev->agp->cant_use_aperture
-	    && ((unsigned long) pt >= VMALLOC_START && (unsigned long) pt < VMALLOC_END))
-	{
+	    && ((unsigned long)pt >= VMALLOC_START
+		&& (unsigned long)pt < VMALLOC_END)) {
 		unsigned long offset;
 		drm_map_t *map;
 
-		offset = drm_follow_page(pt) | ((unsigned long) pt & ~PAGE_MASK);
+		offset = drm_follow_page(pt) | ((unsigned long)pt & ~PAGE_MASK);
 		map = drm_lookup_map(offset, size, dev);
 		if (map && map->type == _DRM_AGP) {
 			vunmap(pt);
 			return;
 		}
 	}
-
+#endif
 	iounmap(pt);
 }
-
-
+#else
+extern void *drm_ioremap(unsigned long offset, unsigned long size,
+				drm_device_t * dev);
+extern void *drm_ioremap_nocache(unsigned long offset,
+					unsigned long size, drm_device_t * dev);
+extern void drm_ioremapfree(void *pt, unsigned long size,
+				   drm_device_t * dev);
+#endif
diff -purN linux-2.6.12.orig/drivers/char/drm/drm_os_linux.h linux-2.6.12/drivers/char/drm/drm_os_linux.h
--- linux-2.6.12.orig/drivers/char/drm/drm_os_linux.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/drm_os_linux.h	2005-07-05 08:37:30.000000000 +0200
@@ -3,7 +3,6 @@
  * OS abstraction macros.
  */
 
-
 #include <linux/interrupt.h>	/* For task queue support */
 #include <linux/delay.h>
 
@@ -15,18 +14,33 @@
 /** Current process ID */
 #define DRM_CURRENTPID			current->pid
 #define DRM_UDELAY(d)			udelay(d)
+#if LINUX_VERSION_CODE <= 0x020608	/* KERNEL_VERSION(2,6,8) */
+/** Read a byte from a MMIO region */
+#define DRM_READ8(map, offset)		readb(((unsigned long)(map)->handle) + (offset))
+/** Read a word from a MMIO region */
+#define DRM_READ16(map, offset)		readw(((unsigned long)(map)->handle) + (offset))
+/** Read a dword from a MMIO region */
+#define DRM_READ32(map, offset)		readl(((unsigned long)(map)->handle) + (offset))
+/** Write a byte into a MMIO region */
+#define DRM_WRITE8(map, offset, val)	writeb(val, ((unsigned long)(map)->handle) + (offset))
+/** Write a word into a MMIO region */
+#define DRM_WRITE16(map, offset, val)	writew(val, ((unsigned long)(map)->handle) + (offset))
+/** Write a dword into a MMIO region */
+#define DRM_WRITE32(map, offset, val)	writel(val, ((unsigned long)(map)->handle) + (offset))
+#else
 /** Read a byte from a MMIO region */
-#define DRM_READ8(map, offset)		readb(((void __iomem *)(map)->handle) + (offset))
+#define DRM_READ8(map, offset)		readb((map)->handle + (offset))
 /** Read a word from a MMIO region */
-#define DRM_READ16(map, offset)         readw(((void __iomem *)(map)->handle) + (offset))
+#define DRM_READ16(map, offset)		readw((map)->handle + (offset))
 /** Read a dword from a MMIO region */
-#define DRM_READ32(map, offset)		readl(((void __iomem *)(map)->handle) + (offset))
+#define DRM_READ32(map, offset)		readl((map)->handle + (offset))
 /** Write a byte into a MMIO region */
-#define DRM_WRITE8(map, offset, val)	writeb(val, ((void __iomem *)(map)->handle) + (offset))
+#define DRM_WRITE8(map, offset, val)	writeb(val, (map)->handle + (offset))
 /** Write a word into a MMIO region */
-#define DRM_WRITE16(map, offset, val)   writew(val, ((void __iomem *)(map)->handle) + (offset))
+#define DRM_WRITE16(map, offset, val)	writew(val, (map)->handle + (offset))
 /** Write a dword into a MMIO region */
-#define DRM_WRITE32(map, offset, val)	writel(val, ((void __iomem *)(map)->handle) + (offset))
+#define DRM_WRITE32(map, offset, val)	writel(val, (map)->handle + (offset))
+#endif
 /** Read memory barrier */
 #define DRM_READMEMORYBARRIER()		rmb()
 /** Write memory barrier */
@@ -39,35 +53,45 @@
 
 /** IRQ handler arguments and return type and values */
 #define DRM_IRQ_ARGS		int irq, void *arg, struct pt_regs *regs
+/** backwards compatibility with old irq return values */
+#ifndef IRQ_HANDLED
+typedef void irqreturn_t;
+#define IRQ_HANDLED		/* nothing */
+#define IRQ_NONE		/* nothing */
+#endif
 
 /** AGP types */
 #if __OS_HAS_AGP
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,70)
+#define DRM_AGP_MEM		agp_memory
+#define DRM_AGP_KERN		agp_kern_info
+#else
 #define DRM_AGP_MEM		struct agp_memory
 #define DRM_AGP_KERN		struct agp_kern_info
+#endif
 #else
 /* define some dummy types for non AGP supporting kernels */
 struct no_agp_kern {
-  unsigned long aper_base;
-  unsigned long aper_size;
+	unsigned long aper_base;
+	unsigned long aper_size;
 };
-#define DRM_AGP_MEM             int
-#define DRM_AGP_KERN            struct no_agp_kern
+#define DRM_AGP_MEM		int
+#define DRM_AGP_KERN		struct no_agp_kern
 #endif
 
 #if !(__OS_HAS_MTRR)
-static __inline__ int mtrr_add (unsigned long base, unsigned long size,
-                                unsigned int type, char increment)
+static __inline__ int mtrr_add(unsigned long base, unsigned long size,
+			       unsigned int type, char increment)
 {
 	return -ENODEV;
 }
 
-static __inline__ int mtrr_del (int reg, unsigned long base,
-                                unsigned long size)
+static __inline__ int mtrr_del(int reg, unsigned long base, unsigned long size)
 {
 	return -ENODEV;
 }
-#define MTRR_TYPE_WRCOMB     1
 
+#define MTRR_TYPE_WRCOMB     1
 #endif
 
 /** Task queue handler arguments */
@@ -89,7 +113,7 @@ static __inline__ int mtrr_del (int reg,
 	copy_to_user(arg1, arg2, arg3)
 /* Macros for copyfrom user, but checking readability only once */
 #define DRM_VERIFYAREA_READ( uaddr, size ) 		\
-	(access_ok( VERIFY_READ, uaddr, size ) ? 0 : -EFAULT)
+	(access_ok( VERIFY_READ, uaddr, size) ? 0 : -EFAULT)
 #define DRM_COPY_FROM_USER_UNCHECKED(arg1, arg2, arg3) 	\
 	__copy_from_user(arg1, arg2, arg3)
 #define DRM_COPY_TO_USER_UNCHECKED(arg1, arg2, arg3)	\
@@ -99,7 +123,7 @@ static __inline__ int mtrr_del (int reg,
 
 #define DRM_GET_PRIV_WITH_RETURN(_priv, _filp) _priv = _filp->private_data
 
-/** 
+/**
  * Get the pointer to the SAREA.
  *
  * Searches the SAREA on the mapping lists and points drm_device::sarea to it.
@@ -143,7 +167,5 @@ do {								\
 	remove_wait_queue(&(queue), &entry);			\
 } while (0)
 
-
 #define DRM_WAKEUP( queue ) wake_up_interruptible( queue )
 #define DRM_INIT_WAITQUEUE( queue ) init_waitqueue_head( queue )
- 
diff -purN linux-2.6.12.orig/drivers/char/drm/drm_pci.c linux-2.6.12/drivers/char/drm/drm_pci.c
--- linux-2.6.12.orig/drivers/char/drm/drm_pci.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/drm_pci.c	2005-07-05 08:37:27.000000000 +0200
@@ -46,10 +46,14 @@
 /**
  * \brief Allocate a PCI consistent memory block, for DMA.
  */
-void *drm_pci_alloc(drm_device_t * dev, size_t size, size_t align,
-		    dma_addr_t maxaddr, dma_addr_t * busaddr)
+drm_dma_handle_t *drm_pci_alloc(drm_device_t * dev, size_t size, size_t align,
+				dma_addr_t maxaddr)
 {
-	void *address;
+	drm_dma_handle_t *dmah;
+#if 0
+	unsigned long addr;
+	size_t sz;
+#endif
 #if DRM_DEBUG_MEMORY
 	int area = DRM_MEM_DMA;
 
@@ -74,13 +78,19 @@ void *drm_pci_alloc(drm_device_t * dev, 
 		return NULL;
 	}
 
-	address = pci_alloc_consistent(dev->pdev, size, busaddr);
+	dmah = kmalloc(sizeof(drm_dma_handle_t), GFP_KERNEL);
+	if (!dmah)
+		return NULL;
+
+	dmah->size = size;
+	dmah->vaddr = pci_alloc_consistent(dev->pdev, size, &dmah->busaddr);
 
 #if DRM_DEBUG_MEMORY
-	if (address == NULL) {
+	if (dmah->vaddr == NULL) {
 		spin_lock(&drm_mem_lock);
 		++drm_mem_stats[area].fail_count;
 		spin_unlock(&drm_mem_lock);
+		kfree(dmah);
 		return NULL;
 	}
 
@@ -90,34 +100,60 @@ void *drm_pci_alloc(drm_device_t * dev, 
 	drm_ram_used += size;
 	spin_unlock(&drm_mem_lock);
 #else
-	if (address == NULL)
+	if (dmah->vaddr == NULL) {
+		kfree(dmah);
 		return NULL;
+	}
 #endif
 
-	memset(address, 0, size);
+	memset(dmah->vaddr, 0, size);
 
-	return address;
+#if 0
+	/* XXX - Is virt_to_page() legal for consistent mem? */
+	/* Reserve */
+	for (addr = (unsigned long)dmah->vaddr, sz = size;
+	     sz > 0; addr += PAGE_SIZE, sz -= PAGE_SIZE) {
+		SetPageReserved(virt_to_page(addr));
+	}
+#endif
+
+	return dmah;
 }
 EXPORT_SYMBOL(drm_pci_alloc);
 
 /**
- * \brief Free a PCI consistent memory block.
+ * \brief Free a PCI consistent memory block without freeing its descriptor.
+ *
+ * This function is for internal use in the Linux-specific DRM core code.
  */
 void
-drm_pci_free(drm_device_t * dev, size_t size, void *vaddr, dma_addr_t busaddr)
+__drm_pci_free(drm_device_t * dev, drm_dma_handle_t *dmah)
 {
+#if 0
+	unsigned long addr;
+	size_t sz;
+#endif
 #if DRM_DEBUG_MEMORY
 	int area = DRM_MEM_DMA;
 	int alloc_count;
 	int free_count;
 #endif
 
-	if (!vaddr) {
+	if (!dmah->vaddr) {
 #if DRM_DEBUG_MEMORY
 		DRM_MEM_ERROR(area, "Attempt to free address 0\n");
 #endif
 	} else {
-		pci_free_consistent(dev->pdev, size, vaddr, busaddr);
+#if 0
+		/* XXX - Is virt_to_page() legal for consistent mem? */
+		/* Unreserve */
+		for (addr = (unsigned long)dmah->vaddr, sz = size;
+		     sz > 0; addr += PAGE_SIZE, sz -= PAGE_SIZE) {
+			ClearPageReserved(virt_to_page(addr));
+		}
+#endif
+		pci_free_consistent(dev->pdev, dmah->size, dmah->vaddr,
+				    dmah->busaddr);
 	}
 
 #if DRM_DEBUG_MEMORY
@@ -135,6 +171,16 @@ drm_pci_free(drm_device_t * dev, size_t 
 #endif
 
 }
+
+/**
+ * \brief Free a PCI consistent memory block.
+ */
+void
+drm_pci_free(drm_device_t * dev, drm_dma_handle_t *dmah)
+{
+	__drm_pci_free(dev, dmah);
+	kfree(dmah);
+}
 EXPORT_SYMBOL(drm_pci_free);
 
 /*@}*/
diff -purN linux-2.6.12.orig/drivers/char/drm/drm_pciids.h linux-2.6.12/drivers/char/drm/drm_pciids.h
--- linux-2.6.12.orig/drivers/char/drm/drm_pciids.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/drm_pciids.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,225 +0,0 @@
-/*
-   This file is auto-generated from the drm_pciids.txt in the DRM CVS
-   Please contact dri-devel@lists.sf.net to add new cards to this list
-*/
-#define radeon_PCI_IDS \
-	{0x1002, 0x4136, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS100|CHIP_IS_IGP}, \
-	{0x1002, 0x4137, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS200|CHIP_IS_IGP}, \
-	{0x1002, 0x4144, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R300}, \
-	{0x1002, 0x4145, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R300}, \
-	{0x1002, 0x4146, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R300}, \
-	{0x1002, 0x4147, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R300}, \
-	{0x1002, 0x4150, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350}, \
-	{0x1002, 0x4151, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350}, \
-	{0x1002, 0x4152, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350}, \
-	{0x1002, 0x4153, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350}, \
-	{0x1002, 0x4154, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350}, \
-	{0x1002, 0x4156, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350}, \
-	{0x1002, 0x4237, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS250|CHIP_IS_IGP}, \
-	{0x1002, 0x4242, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
-	{0x1002, 0x4243, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
-	{0x1002, 0x4336, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS100|CHIP_IS_IGP|CHIP_IS_MOBILITY}, \
-	{0x1002, 0x4337, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS200|CHIP_IS_IGP|CHIP_IS_MOBILITY}, \
-	{0x1002, 0x4437, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS250|CHIP_IS_IGP|CHIP_IS_MOBILITY}, \
-	{0x1002, 0x4964, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R250}, \
-	{0x1002, 0x4965, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R250}, \
-	{0x1002, 0x4966, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R250}, \
-	{0x1002, 0x4967, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R250}, \
-	{0x1002, 0x4C57, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV200|CHIP_IS_MOBILITY}, \
-	{0x1002, 0x4C58, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV200|CHIP_IS_MOBILITY}, \
-	{0x1002, 0x4C59, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV100|CHIP_IS_MOBILITY}, \
-	{0x1002, 0x4C5A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV100|CHIP_IS_MOBILITY}, \
-	{0x1002, 0x4C64, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R250|CHIP_IS_MOBILITY}, \
-	{0x1002, 0x4C65, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R250|CHIP_IS_MOBILITY}, \
-	{0x1002, 0x4C66, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R250|CHIP_IS_MOBILITY}, \
-	{0x1002, 0x4C67, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R250|CHIP_IS_MOBILITY}, \
-	{0x1002, 0x4E50, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350|CHIP_IS_MOBILITY}, \
-	{0x1002, 0x5144, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R100|CHIP_SINGLE_CRTC}, \
-	{0x1002, 0x5145, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R100|CHIP_SINGLE_CRTC}, \
-	{0x1002, 0x5146, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R100|CHIP_SINGLE_CRTC}, \
-	{0x1002, 0x5147, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R100|CHIP_SINGLE_CRTC}, \
-	{0x1002, 0x5148, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
-	{0x1002, 0x5149, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
-	{0x1002, 0x514A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
-	{0x1002, 0x514B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
-	{0x1002, 0x514C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
-	{0x1002, 0x514D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
-	{0x1002, 0x514E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
-	{0x1002, 0x514F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
-	{0x1002, 0x5157, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV200}, \
-	{0x1002, 0x5158, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV200}, \
-	{0x1002, 0x5159, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV100}, \
-	{0x1002, 0x515A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV100}, \
-	{0x1002, 0x515E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV100}, \
-	{0x1002, 0x5168, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
-	{0x1002, 0x5169, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
-	{0x1002, 0x516A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
-	{0x1002, 0x516B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
-	{0x1002, 0x516C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
-	{0x1002, 0x5834, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS300|CHIP_IS_IGP}, \
-	{0x1002, 0x5835, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS300|CHIP_IS_IGP|CHIP_IS_MOBILITY}, \
-	{0x1002, 0x5836, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS300|CHIP_IS_IGP}, \
-	{0x1002, 0x5837, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS300|CHIP_IS_IGP}, \
-	{0x1002, 0x5960, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
-	{0x1002, 0x5961, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
-	{0x1002, 0x5962, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
-	{0x1002, 0x5963, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
-	{0x1002, 0x5964, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
-	{0x1002, 0x5968, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
-	{0x1002, 0x5969, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV100}, \
-	{0x1002, 0x596A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
-	{0x1002, 0x596B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
-	{0x1002, 0x5c61, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280|CHIP_IS_MOBILITY}, \
-	{0x1002, 0x5c62, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
-	{0x1002, 0x5c63, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280|CHIP_IS_MOBILITY}, \
-	{0x1002, 0x5c64, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
-	{0, 0, 0}
-
-#define r128_PCI_IDS \
-	{0x1002, 0x4c45, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x4c46, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x4d46, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x4d4c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5041, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5042, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5043, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5044, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5045, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5046, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5047, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5048, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5049, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x504A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x504B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x504C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x504D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x504E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x504F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5050, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5051, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5052, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5053, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5054, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5055, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5056, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5057, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5058, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5245, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5246, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5247, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x524b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x524c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x534d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5446, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x544C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5452, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0, 0, 0}
-
-#define mga_PCI_IDS \
-	{0x102b, 0x0521, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x102b, 0x0525, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x102b, 0x2527, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0, 0, 0}
-
-#define mach64_PCI_IDS \
-	{0x1002, 0x4749, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x4750, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x4751, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x4742, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x4744, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x4c49, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x4c50, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x4c51, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x4c42, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x4c44, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x474c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x474f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x4752, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x4753, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x474d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x474e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x4c52, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x4c53, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x4c4d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x4c4e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0, 0, 0}
-
-#define sisdrv_PCI_IDS \
-	{0x1039, 0x0300, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1039, 0x5300, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1039, 0x6300, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1039, 0x7300, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0, 0, 0}
-
-#define tdfx_PCI_IDS \
-	{0x121a, 0x0003, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x121a, 0x0004, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x121a, 0x0005, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x121a, 0x0007, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x121a, 0x0009, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x121a, 0x000b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0, 0, 0}
-
-#define viadrv_PCI_IDS \
-	{0x1106, 0x3022, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1106, 0x3122, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1106, 0x7205, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1106, 0x7204, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0, 0, 0}
-
-#define i810_PCI_IDS \
-	{0x8086, 0x7121, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x8086, 0x7123, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x8086, 0x7125, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x8086, 0x1132, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0, 0, 0}
-
-#define i830_PCI_IDS \
-	{0x8086, 0x3577, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x8086, 0x2562, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x8086, 0x3582, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x8086, 0x2572, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0, 0, 0}
-
-#define gamma_PCI_IDS \
-	{0x3d3d, 0x0008, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0, 0, 0}
-
-#define savage_PCI_IDS \
-	{0x5333, 0x8a22, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x5333, 0x8a23, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x5333, 0x8c10, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x5333, 0x8c11, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x5333, 0x8c12, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x5333, 0x8c13, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x5333, 0x8c20, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x5333, 0x8c21, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x5333, 0x8c22, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x5333, 0x8c24, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x5333, 0x8c26, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x5333, 0x8c2a, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x5333, 0x8c2b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x5333, 0x8c2c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x5333, 0x8c2d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x5333, 0x8c2e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x5333, 0x8c2f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x5333, 0x8a25, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x5333, 0x8a26, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x5333, 0x8d01, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x5333, 0x8d02, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x5333, 0x8d04, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0, 0, 0}
-
-#define ffb_PCI_IDS \
-	{0, 0, 0}
-
-#define i915_PCI_IDS \
-	{0x8086, 0x3577, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x8086, 0x2562, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x8086, 0x3582, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x8086, 0x2572, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x8086, 0x2582, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x8086, 0x2592, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x8086, 0x2772, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0, 0, 0}
-
diff -purN linux-2.6.12.orig/drivers/char/drm/drm_pciids.txt linux-2.6.12/drivers/char/drm/drm_pciids.txt
--- linux-2.6.12.orig/drivers/char/drm/drm_pciids.txt	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/drm/drm_pciids.txt	2005-07-05 08:37:51.000000000 +0200
@@ -0,0 +1,216 @@
+[radeon]
+0x1002 0x4136 CHIP_RS100|CHIP_IS_IGP "ATI Radeon RS100 IGP 320M"
+0x1002 0x4137 CHIP_RS200|CHIP_IS_IGP "ATI Radeon RS200 IGP"
+0x1002 0x4144 CHIP_R300 "ATI Radeon AD 9500 Pro"
+0x1002 0x4145 CHIP_R300 "ATI Radeon AE 9700 Pro"
+0x1002 0x4146 CHIP_R300 "ATI Radeon AF 9700 Pro"
+0x1002 0x4147 CHIP_R300 "ATI FireGL AG Z1/X1"
+0x1002 0x4150 CHIP_RV350 "ATI Radeon AP 9600"
+0x1002 0x4151 CHIP_RV350 "ATI Radeon AQ 9600"
+0x1002 0x4152 CHIP_RV350 "ATI Radeon AR 9600"
+0x1002 0x4153 CHIP_RV350 "ATI Radeon AS 9600 AS"
+0x1002 0x4154 CHIP_RV350 "ATI FireGL AT T2"
+0x1002 0x4156 CHIP_RV350 "ATI FireGL AV T2"
+0x1002 0x4237 CHIP_RS250|CHIP_IS_IGP "ATI Radeon RS250 IGP"
+0x1002 0x4242 CHIP_R200 "ATI Radeon BB R200 AIW 8500DV"
+0x1002 0x4243 CHIP_R200 "ATI Radeon BC R200"
+0x1002 0x4336 CHIP_RS100|CHIP_IS_IGP|CHIP_IS_MOBILITY "ATI Radeon RS100 Mobility U1"
+0x1002 0x4337 CHIP_RS200|CHIP_IS_IGP|CHIP_IS_MOBILITY "ATI Radeon RS200 Mobility IGP 340M"
+0x1002 0x4437 CHIP_RS250|CHIP_IS_IGP|CHIP_IS_MOBILITY "ATI Radeon RS250 Mobility IGP"
+0x1002 0x4964 CHIP_R250 "ATI Radeon Id R250 9000"
+0x1002 0x4965 CHIP_R250 "ATI Radeon Ie R250 9000"
+0x1002 0x4966 CHIP_R250 "ATI Radeon If R250 9000"
+0x1002 0x4967 CHIP_R250 "ATI Radeon Ig R250 9000"
+0x1002 0x4C57 CHIP_RV200|CHIP_IS_MOBILITY "ATI Radeon LW RV200 Mobility 7500 M7"
+0x1002 0x4C58 CHIP_RV200|CHIP_IS_MOBILITY "ATI Radeon LX RV200 Mobility FireGL 7800 M7"
+0x1002 0x4C59 CHIP_RV100|CHIP_IS_MOBILITY "ATI Radeon LY RV100 Mobility M6"
+0x1002 0x4C5A CHIP_RV100|CHIP_IS_MOBILITY "ATI Radeon LZ RV100 Mobility M6"
+0x1002 0x4C64 CHIP_R250|CHIP_IS_MOBILITY "ATI Radeon Ld R250 Mobility 9000 M9"
+0x1002 0x4C65 CHIP_R250|CHIP_IS_MOBILITY "ATI Radeon Le R250 Mobility 9000 M9"
+0x1002 0x4C66 CHIP_R250|CHIP_IS_MOBILITY "ATI Radeon Lf R250 Mobility 9000 M9"
+0x1002 0x4C67 CHIP_R250|CHIP_IS_MOBILITY "ATI Radeon Lg R250 Mobility 9000 M9"
+0x1002 0x4E50 CHIP_RV350|CHIP_IS_MOBILITY "ATI Radeon RV300 Mobility 9600 M10"
+0x1002 0x5144 CHIP_R100|CHIP_SINGLE_CRTC "ATI Radeon QD R100"
+0x1002 0x5145 CHIP_R100|CHIP_SINGLE_CRTC "ATI Radeon QE R100"
+0x1002 0x5146 CHIP_R100|CHIP_SINGLE_CRTC "ATI Radeon QF R100"
+0x1002 0x5147 CHIP_R100|CHIP_SINGLE_CRTC "ATI Radeon QG R100"
+0x1002 0x5148 CHIP_R200 "ATI Radeon QH R200 8500"
+0x1002 0x5149 CHIP_R200 "ATI Radeon QI R200"
+0x1002 0x514A CHIP_R200 "ATI Radeon QJ R200"
+0x1002 0x514B CHIP_R200 "ATI Radeon QK R200"
+0x1002 0x514C CHIP_R200 "ATI Radeon QL R200 8500 LE"
+0x1002 0x514D CHIP_R200 "ATI Radeon QM R200 9100"
+0x1002 0x514E CHIP_R200 "ATI Radeon QN R200 8500 LE"
+0x1002 0x514F CHIP_R200 "ATI Radeon QO R200 8500 LE"
+0x1002 0x5157 CHIP_RV200 "ATI Radeon QW RV200 7500"
+0x1002 0x5158 CHIP_RV200 "ATI Radeon QX RV200 7500"
+0x1002 0x5159 CHIP_RV100 "ATI Radeon QY RV100 7000/VE"
+0x1002 0x515A CHIP_RV100 "ATI Radeon QZ RV100 7000/VE"
+0x1002 0x515E CHIP_RV100 "ATI ES1000 RN50"
+0x1002 0x5168 CHIP_R200 "ATI Radeon Qh R200"
+0x1002 0x5169 CHIP_R200 "ATI Radeon Qi R200"
+0x1002 0x516A CHIP_R200 "ATI Radeon Qj R200"
+0x1002 0x516B CHIP_R200 "ATI Radeon Qk R200"
+0x1002 0x516C CHIP_R200 "ATI Radeon Ql R200"
+0x1002 0x5834 CHIP_RS300|CHIP_IS_IGP "ATI Radeon RS300 IGP"
+0x1002 0x5835 CHIP_RS300|CHIP_IS_IGP|CHIP_IS_MOBILITY "ATI Radeon RS300 Mobility IGP"
+0x1002 0x5836 CHIP_RS300|CHIP_IS_IGP "ATI Radeon RS300 IGP"
+0x1002 0x5837 CHIP_RS300|CHIP_IS_IGP "ATI Radeon RS300 IGP"
+0x1002 0x5960 CHIP_RV280 "ATI Radeon RV280 9200"
+0x1002 0x5961 CHIP_RV280 "ATI Radeon RV280 9200 SE"
+0x1002 0x5962 CHIP_RV280 "ATI Radeon RV280 9200"
+0x1002 0x5963 CHIP_RV280 "ATI Radeon RV280 9200"
+0x1002 0x5964 CHIP_RV280 "ATI Radeon RV280 9200 SE"
+0x1002 0x5968 CHIP_RV280 "ATI Radeon RV280 9200"
+0x1002 0x5969 CHIP_RV100 "ATI ES1000 RN50"
+0x1002 0x596A CHIP_RV280 "ATI Radeon RV280 9200"
+0x1002 0x596B CHIP_RV280 "ATI Radeon RV280 9200"
+0x1002 0x5c61 CHIP_RV280|CHIP_IS_MOBILITY "ATI Radeon RV280 Mobility"
+0x1002 0x5c62 CHIP_RV280 "ATI Radeon RV280"
+0x1002 0x5c63 CHIP_RV280|CHIP_IS_MOBILITY "ATI Radeon RV280 Mobility"
+0x1002 0x5c64 CHIP_RV280 "ATI Radeon RV280"
+
+[r128]
+0x1002 0x4c45 0 "ATI Rage 128 Mobility LE (PCI)"
+0x1002 0x4c46 0 "ATI Rage 128 Mobility LF (AGP)"
+0x1002 0x4d46 0 "ATI Rage 128 Mobility MF (AGP)"
+0x1002 0x4d4c 0 "ATI Rage 128 Mobility ML (AGP)"
+0x1002 0x5041 0 "ATI Rage 128 Pro PA (PCI)"
+0x1002 0x5042 0 "ATI Rage 128 Pro PB (AGP)"
+0x1002 0x5043 0 "ATI Rage 128 Pro PC (AGP)"
+0x1002 0x5044 0 "ATI Rage 128 Pro PD (PCI)"
+0x1002 0x5045 0 "ATI Rage 128 Pro PE (AGP)"
+0x1002 0x5046 0 "ATI Rage 128 Pro PF (AGP)"
+0x1002 0x5047 0 "ATI Rage 128 Pro PG (PCI)"
+0x1002 0x5048 0 "ATI Rage 128 Pro PH (AGP)"
+0x1002 0x5049 0 "ATI Rage 128 Pro PI (AGP)"
+0x1002 0x504A 0 "ATI Rage 128 Pro PJ (PCI)"
+0x1002 0x504B 0 "ATI Rage 128 Pro PK (AGP)"
+0x1002 0x504C 0 "ATI Rage 128 Pro PL (AGP)"
+0x1002 0x504D 0 "ATI Rage 128 Pro PM (PCI)"
+0x1002 0x504E 0 "ATI Rage 128 Pro PN (AGP)"
+0x1002 0x504F 0 "ATI Rage 128 Pro PO (AGP)"
+0x1002 0x5050 0 "ATI Rage 128 Pro PP (PCI)"
+0x1002 0x5051 0 "ATI Rage 128 Pro PQ (AGP)"
+0x1002 0x5052 0 "ATI Rage 128 Pro PR (PCI)"
+0x1002 0x5053 0 "ATI Rage 128 Pro PS (PCI)"
+0x1002 0x5054 0 "ATI Rage 128 Pro PT (AGP)"
+0x1002 0x5055 0 "ATI Rage 128 Pro PU (AGP)"
+0x1002 0x5056 0 "ATI Rage 128 Pro PV (PCI)"
+0x1002 0x5057 0 "ATI Rage 128 Pro PW (AGP)"
+0x1002 0x5058 0 "ATI Rage 128 Pro PX (AGP)"
+0x1002 0x5245 0 "ATI Rage 128 RE (PCI)"
+0x1002 0x5246 0 "ATI Rage 128 RF (AGP)"
+0x1002 0x5247 0 "ATI Rage 128 RG (AGP)"
+0x1002 0x524b 0 "ATI Rage 128 RK (PCI)"
+0x1002 0x524c 0 "ATI Rage 128 RL (AGP)"
+0x1002 0x534d 0 "ATI Rage 128 SM (AGP)"
+0x1002 0x5446 0 "ATI Rage 128 Pro Ultra TF (AGP)"
+0x1002 0x544C 0 "ATI Rage 128 Pro Ultra TL (AGP)"
+0x1002 0x5452 0 "ATI Rage 128 Pro Ultra TR (AGP)"
+
+[mga]
+0x102b 0x0520 MGA_CARD_TYPE_G200 "Matrox G200 (PCI)"
+0x102b 0x0521 MGA_CARD_TYPE_G200 "Matrox G200 (AGP)"
+0x102b 0x0525 MGA_CARD_TYPE_G400 "Matrox G400/G450 (AGP)"
+0x102b 0x2527 MGA_CARD_TYPE_G550 "Matrox G550 (AGP)"
+
+[mach64]
+0x1002 0x4749 0 "3D Rage Pro"
+0x1002 0x4750 0 "3D Rage Pro 215GP"
+0x1002 0x4751 0 "3D Rage Pro 215GQ"
+0x1002 0x4742 0 "3D Rage Pro AGP 1X/2X"
+0x1002 0x4744 0 "3D Rage Pro AGP 1X"
+0x1002 0x4c49 0 "3D Rage LT Pro"
+0x1002 0x4c50 0 "3D Rage LT Pro"
+0x1002 0x4c51 0 "3D Rage LT Pro"
+0x1002 0x4c42 0 "3D Rage LT Pro AGP-133"
+0x1002 0x4c44 0 "3D Rage LT Pro AGP-66"
+0x1002 0x474c 0 "Rage XC"
+0x1002 0x474f 0 "Rage XL"
+0x1002 0x4752 0 "Rage XL"
+0x1002 0x4753 0 "Rage XC"
+0x1002 0x474d 0 "Rage XL AGP 2X"
+0x1002 0x474e 0 "Rage XC AGP"
+0x1002 0x4c52 0 "Rage Mobility P/M"
+0x1002 0x4c53 0 "Rage Mobility L"
+0x1002 0x4c4d 0 "Rage Mobility P/M AGP 2X"
+0x1002 0x4c4e 0 "Rage Mobility L AGP 2X"
+
+[sis]
+0x1039 0x0300 0 "SiS 300/305"
+0x1039 0x5300 0 "SiS 540"
+0x1039 0x6300 0 "SiS 630"
+0x1039 0x7300 0 "SiS 730"
+
+[tdfx]
+0x121a 0x0003 0 "3dfx Voodoo Banshee"
+0x121a 0x0004 0 "3dfx Voodoo3 2000"
+0x121a 0x0005 0 "3dfx Voodoo3 3000"
+0x121a 0x0007 0 "3dfx Voodoo4 4500"
+0x121a 0x0009 0 "3dfx Voodoo5 5500"
+0x121a 0x000b 0 "3dfx Voodoo4 4200"
+
+[viadrv]
+0x1106 0x3022 0 "VIA CLE266 3022"
+0x1106 0x3118 0 "VIA CN400 / PM8X0"
+0x1106 0x3122 0 "VIA CLE266"
+0x1106 0x7205 0 "VIA KM400"
+0x1106 0x3108 0 "VIA K8M800"
+
+[i810]
+0x8086 0x7121 0 "Intel i810 GMCH"
+0x8086 0x7123 0 "Intel i810-DC100 GMCH"
+0x8086 0x7125 0 "Intel i810E GMCH"
+0x8086 0x1132 0 "Intel i815 GMCH"
+
+[i830]
+0x8086 0x3577 0 "Intel i830M GMCH"
+0x8086 0x2562 0 "Intel i845G GMCH"
+0x8086 0x3582 0 "Intel i852GM/i855GM GMCH"
+0x8086 0x2572 0 "Intel i865G GMCH"
+
+[gamma]
+0x3d3d 0x0008 0 "3DLabs GLINT Gamma G1"
+
+[savage]
+0x5333 0x8a20 S3_SAVAGE3D "Savage 3D"
+0x5333 0x8a21 S3_SAVAGE3D "Savage 3D/MV"
+0x5333 0x8a22 S3_SAVAGE4 "Savage4"
+0x5333 0x8a23 S3_SAVAGE4 "Savage4"
+0x5333 0x8c10 S3_SAVAGE_MX "Savage/MX-MV"
+0x5333 0x8c11 S3_SAVAGE_MX "Savage/MX"
+0x5333 0x8c12 S3_SAVAGE_MX "Savage/IX-MV"
+0x5333 0x8c13 S3_SAVAGE_MX "Savage/IX"
+0x5333 0x8c22 S3_SUPERSAVAGE "SuperSavage MX/128"
+0x5333 0x8c24 S3_SUPERSAVAGE "SuperSavage MX/64"
+0x5333 0x8c26 S3_SUPERSAVAGE "SuperSavage MX/64C"
+0x5333 0x8c2a S3_SUPERSAVAGE "SuperSavage IX/128 SDR"
+0x5333 0x8c2b S3_SUPERSAVAGE "SuperSavage IX/128 DDR"
+0x5333 0x8c2c S3_SUPERSAVAGE "SuperSavage IX/64 SDR"
+0x5333 0x8c2d S3_SUPERSAVAGE "SuperSavage IX/64 DDR"
+0x5333 0x8c2e S3_SUPERSAVAGE "SuperSavage IX/C SDR"
+0x5333 0x8c2f S3_SUPERSAVAGE "SuperSavage IX/C DDR"
+0x5333 0x8a25 S3_PROSAVAGE "ProSavage PM133"
+0x5333 0x8a26 S3_PROSAVAGE "ProSavage KM133"
+0x5333 0x8d01 S3_TWISTER "ProSavage Twister PN133"
+0x5333 0x8d02 S3_TWISTER "ProSavage Twister KN133"
+0x5333 0x8d03 S3_PROSAVAGEDDR "ProSavage DDR"
+0x5333 0x8d04 S3_PROSAVAGEDDR "ProSavage DDR-K"
+
+[ffb]
+
+[i915]
+0x8086 0x3577 0 "Intel i830M GMCH"
+0x8086 0x2562 0 "Intel i845G GMCH"
+0x8086 0x3582 0 "Intel i852GM/i855GM GMCH"
+0x8086 0x2572 0 "Intel i865G GMCH"
+0x8086 0x2582 0 "Intel i915G"
+0x8086 0x2592 0 "Intel i915GM"
+0x8086 0x2772 0 "Intel i945G"
+
+[imagine]
+0x105d 0x2309 IMAGINE_128 "Imagine 128"
+0x105d 0x2339 IMAGINE_128_2 "Imagine 128-II"
+0x105d 0x493d IMAGINE_T2R "Ticket to Ride"
+0x105d 0x5348 IMAGINE_REV4 "Revolution IV"
diff -purN linux-2.6.12.orig/drivers/char/drm/drmP.h linux-2.6.12/drivers/char/drm/drmP.h
--- linux-2.6.12.orig/drivers/char/drm/drmP.h	2005-07-05 08:36:22.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/drmP.h	2005-07-05 08:37:30.000000000 +0200
@@ -1,7 +1,7 @@
 /**
- * \file drmP.h 
+ * \file drmP.h
  * Private header for Direct Rendering Manager
- * 
+ *
  * \author Rickard E. (Rik) Faith <faith@valinux.com>
  * \author Gareth Hughes <gareth@valinux.com>
  */
@@ -34,16 +34,13 @@
 #ifndef _DRM_P_H_
 #define _DRM_P_H_
 
-/* If you want the memory alloc debug functionality, change define below */
-/* #define DEBUG_MEMORY */
-
 #ifdef __KERNEL__
 #ifdef __alpha__
 /* add include of current.h so that "current" is defined
  * before static inline funcs in wait.h. Doing this so we
  * can build the DRM (part of PI DRI). 4/21/2000 S + B */
 #include <asm/current.h>
-#endif /* __alpha__ */
+#endif				/* __alpha__ */
 #include <linux/config.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
@@ -54,12 +51,12 @@
 #include <linux/file.h>
 #include <linux/pci.h>
 #include <linux/version.h>
-#include <linux/jiffies.h>
+#include <linux/sched.h>
 #include <linux/smp_lock.h>	/* For (un)lock_kernel */
 #include <linux/mm.h>
-#include <linux/cdev.h>
+#include <linux/pagemap.h>
 #if defined(__alpha__) || defined(__powerpc__)
-#include <asm/pgtable.h> /* For pte_wrprotect */
+#include <asm/pgtable.h>	/* For pte_wrprotect */
 #endif
 #include <asm/io.h>
 #include <asm/mman.h>
@@ -71,7 +68,16 @@
 #include <linux/types.h>
 #include <linux/agp_backend.h>
 #endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,41)
+#define HAS_WORKQUEUE 0
+#else
+#define HAS_WORKQUEUE 1
+#endif
+#if !HAS_WORKQUEUE
+#include <linux/tqueue.h>
+#else
 #include <linux/workqueue.h>
+#endif
 #include <linux/poll.h>
 #include <asm/pgalloc.h>
 #include "drm.h"
@@ -81,6 +87,9 @@
 
 #include "drm_os_linux.h"
 
+/* If you want the memory alloc debug functionality, change define below */
+/* #define DEBUG_MEMORY */
+
 /***********************************************************************/
 /** \name DRM template customization defaults */
 /*@{*/
@@ -91,11 +100,14 @@
 #define DRIVER_USE_MTRR    0x4
 #define DRIVER_PCI_DMA     0x8
 #define DRIVER_SG          0x10
-#define DRIVER_HAVE_DMA    0x20
-#define DRIVER_HAVE_IRQ    0x40
-#define DRIVER_IRQ_SHARED  0x80
-#define DRIVER_IRQ_VBL     0x100
-#define DRIVER_DMA_QUEUE   0x200
+#define DRIVER_FB_DMA      0x20
+#define DRIVER_HAVE_DMA    0x40
+#define DRIVER_HAVE_IRQ    0x80
+#define DRIVER_IRQ_SHARED  0x100
+#define DRIVER_IRQ_VBL     0x200
+#define DRIVER_DMA_QUEUE   0x400
+
+/*@}*/
 
 /***********************************************************************/
 /** \name Begin the DRM... */
@@ -138,63 +150,10 @@
 #define DRM_MEM_CTXLIST  21
 
 #define DRM_MAX_CTXBITMAP (PAGE_SIZE * 8)
-	
-/*@}*/
-
-
-/***********************************************************************/
-/** \name Backward compatibility section */
-/*@{*/
-
-#ifndef MODULE_LICENSE
-#define MODULE_LICENSE(x) 
-#endif
-
-#ifndef preempt_disable
-#define preempt_disable()
-#define preempt_enable()
-#endif
-
-#ifndef pte_offset_map 
-#define pte_offset_map pte_offset
-#define pte_unmap(pte)
-#endif
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,19)
-static inline struct page * vmalloc_to_page(void * vmalloc_addr)
-{
-	unsigned long addr = (unsigned long) vmalloc_addr;
-	struct page *page = NULL;
-	pgd_t *pgd = pgd_offset_k(addr);
-	pmd_t *pmd;
-	pte_t *ptep, pte;
-  
-	if (!pgd_none(*pgd)) {
-		pmd = pmd_offset(pgd, addr);
-		if (!pmd_none(*pmd)) {
-			preempt_disable();
-			ptep = pte_offset_map(pmd, addr);
-			pte = *ptep;
-			if (pte_present(pte))
-				page = pte_page(pte);
-			pte_unmap(ptep);
-			preempt_enable();
-		}
-	}
-	return page;
-}
-#endif
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-#define DRM_RPR_ARG(vma)
-#else
-#define DRM_RPR_ARG(vma) vma,
-#endif
-
-#define VM_OFFSET(vma) ((vma)->vm_pgoff << PAGE_SHIFT)
 
 /*@}*/
 
+#include "drm_compat.h"
 
 /***********************************************************************/
 /** \name Macros to make printk easier */
@@ -219,21 +178,20 @@ static inline struct page * vmalloc_to_p
 #define DRM_MEM_ERROR(area, fmt, arg...) \
 	printk(KERN_ERR "[" DRM_NAME ":%s:%s] *ERROR* " fmt , __FUNCTION__, \
 	       drm_mem_stats[area].name , ##arg)
-
 #define DRM_INFO(fmt, arg...)  printk(KERN_INFO "[" DRM_NAME "] " fmt , ##arg)
 
 /**
  * Debug output.
- * 
+ *
  * \param fmt printf() like format string.
  * \param arg arguments
  */
 #if DRM_DEBUG_CODE
 #define DRM_DEBUG(fmt, arg...)						\
 	do {								\
-		if ( drm_debug )			\
+		if ( drm_debug )						\
 			printk(KERN_DEBUG				\
-			       "[" DRM_NAME ":%s] " fmt ,	\
+			       "[" DRM_NAME ":%s] " fmt ,		\
 			       __FUNCTION__ , ##arg);			\
 	} while (0)
 #else
@@ -252,7 +210,6 @@ static inline struct page * vmalloc_to_p
 
 /*@}*/
 
-
 /***********************************************************************/
 /** \name Internal types and structures */
 /*@{*/
@@ -286,9 +243,10 @@ static inline struct page * vmalloc_to_p
 #define LOCK_TEST_WITH_RETURN( dev, filp )				\
 do {									\
 	if ( !_DRM_LOCK_IS_HELD( dev->lock.hw_lock->lock ) ||		\
-	     dev->lock.filp != filp ) {				\
-		DRM_ERROR( "%s called without lock held\n",		\
-			   __FUNCTION__ );				\
+	     dev->lock.filp != filp ) 	{				\
+		DRM_ERROR( "%s called without lock held, held  %d owner %p %p\n",\
+			   __FUNCTION__, _DRM_LOCK_IS_HELD( dev->lock.hw_lock->lock ),\
+			   dev->lock.filp, filp );			\
 		return -EINVAL;						\
 	}								\
 } while (0)
@@ -304,7 +262,7 @@ do {									\
 		if ( copy_to_user( name, value, len ) )			\
 			return -EFAULT;					\
 	}
-	
+
 /**
  * Ioctl function type.
  *
@@ -313,25 +271,25 @@ do {									\
  * \param cmd command.
  * \param arg argument.
  */
-typedef int drm_ioctl_t( struct inode *inode, struct file *filp,
-			 unsigned int cmd, unsigned long arg );
+typedef int drm_ioctl_t(struct inode *inode, struct file *filp,
+			unsigned int cmd, unsigned long arg);
 
 typedef int drm_ioctl_compat_t(struct file *filp, unsigned int cmd,
 			       unsigned long arg);
 
 typedef struct drm_ioctl_desc {
-	drm_ioctl_t	     *func;
-	int		     auth_needed;
-	int		     root_only;
+	drm_ioctl_t *func;
+	int auth_needed;
+	int root_only;
 } drm_ioctl_desc_t;
 
 typedef struct drm_devstate {
-	pid_t		  owner;	/**< X server pid holding x_lock */
+	pid_t owner;			/**< X server pid holding x_lock */
 } drm_devstate_t;
 
 typedef struct drm_magic_entry {
-	drm_magic_t	       magic;
-	struct drm_file	       *priv;
+	drm_magic_t magic;
+	struct drm_file *priv;
 	struct drm_magic_entry *next;
 } drm_magic_entry_t;
 
@@ -342,111 +300,110 @@ typedef struct drm_magic_head {
 
 typedef struct drm_vma_entry {
 	struct vm_area_struct *vma;
-	struct drm_vma_entry  *next;
-	pid_t		      pid;
+	struct drm_vma_entry *next;
+	pid_t pid;
 } drm_vma_entry_t;
 
 /**
  * DMA buffer.
  */
 typedef struct drm_buf {
-	int		  idx;	       /**< Index into master buflist */
-	int		  total;       /**< Buffer size */
-	int		  order;       /**< log-base-2(total) */
-	int		  used;	       /**< Amount of buffer in use (for DMA) */
-	unsigned long	  offset;      /**< Byte offset (used internally) */
-	void		  *address;    /**< Address of buffer */
-	unsigned long	  bus_address; /**< Bus address of buffer */
-	struct drm_buf	  *next;       /**< Kernel-only: used for free list */
-	__volatile__ int  waiting;     /**< On kernel DMA queue */
-	__volatile__ int  pending;     /**< On hardware DMA queue */
+	int idx;		       /**< Index into master buflist */
+	int total;		       /**< Buffer size */
+	int order;		       /**< log-base-2(total) */
+	int used;		       /**< Amount of buffer in use (for DMA) */
+	unsigned long offset;	       /**< Byte offset (used internally) */
+	void *address;		       /**< Address of buffer */
+	unsigned long bus_address;     /**< Bus address of buffer */
+	struct drm_buf *next;	       /**< Kernel-only: used for free list */
+	__volatile__ int waiting;      /**< On kernel DMA queue */
+	__volatile__ int pending;      /**< On hardware DMA queue */
 	wait_queue_head_t dma_wait;    /**< Processes waiting */
-	struct file       *filp;       /**< Pointer to holding file descr */
-	int		  context;     /**< Kernel queue for this buffer */
-	int		  while_locked;/**< Dispatch this buffer while locked */
+	struct file *filp;	       /**< Pointer to holding file descr */
+	int context;		       /**< Kernel queue for this buffer */
+	int while_locked;	       /**< Dispatch this buffer while locked */
 	enum {
-		DRM_LIST_NONE	 = 0,
-		DRM_LIST_FREE	 = 1,
-		DRM_LIST_WAIT	 = 2,
-		DRM_LIST_PEND	 = 3,
-		DRM_LIST_PRIO	 = 4,
+		DRM_LIST_NONE = 0,
+		DRM_LIST_FREE = 1,
+		DRM_LIST_WAIT = 2,
+		DRM_LIST_PEND = 3,
+		DRM_LIST_PRIO = 4,
 		DRM_LIST_RECLAIM = 5
-	}		  list;	       /**< Which list we're on */
+	} list;			       /**< Which list we're on */
 
-	int		  dev_priv_size; /**< Size of buffer private storage */
-	void		  *dev_private;  /**< Per-buffer private storage */
+	int dev_priv_size;		/**< Size of buffer private storage */
+	void *dev_private;		/**< Per-buffer private storage */
 } drm_buf_t;
 
-
 /** bufs is one longer than it has to be */
 typedef struct drm_waitlist {
-	int		  count;	/**< Number of possible buffers */
-	drm_buf_t	  **bufs;	/**< List of pointers to buffers */
-	drm_buf_t	  **rp;		/**< Read pointer */
-	drm_buf_t	  **wp;		/**< Write pointer */
-	drm_buf_t	  **end;	/**< End pointer */
-	spinlock_t	  read_lock;
-	spinlock_t	  write_lock;
+	int count;			/**< Number of possible buffers */
+	drm_buf_t **bufs;		/**< List of pointers to buffers */
+	drm_buf_t **rp;			/**< Read pointer */
+	drm_buf_t **wp;			/**< Write pointer */
+	drm_buf_t **end;		/**< End pointer */
+	spinlock_t read_lock;
+	spinlock_t write_lock;
 } drm_waitlist_t;
 
 typedef struct drm_freelist {
-	int		  initialized; /**< Freelist in use */
-	atomic_t	  count;       /**< Number of free buffers */
-	drm_buf_t	  *next;       /**< End pointer */
+	int initialized;	       /**< Freelist in use */
+	atomic_t count;		       /**< Number of free buffers */
+	drm_buf_t *next;	       /**< End pointer */
 
 	wait_queue_head_t waiting;     /**< Processes waiting on free bufs */
-	int		  low_mark;    /**< Low water mark */
-	int		  high_mark;   /**< High water mark */
-	atomic_t	  wfh;	       /**< If waiting for high mark */
-	spinlock_t        lock;
+	int low_mark;		       /**< Low water mark */
+	int high_mark;		       /**< High water mark */
+	atomic_t wfh;		       /**< If waiting for high mark */
+	spinlock_t lock;
 } drm_freelist_t;
 
 /**
  * Buffer entry.  There is one of this for each buffer size order.
  */
 typedef struct drm_buf_entry {
-	int		  buf_size;	/**< size */
-	int		  buf_count;	/**< number of buffers */
-	drm_buf_t	  *buflist;	/**< buffer list */
-	int		  seg_count;
-	int		  page_order;
-	unsigned long	  *seglist;
+	int buf_size;			/**< size */
+	int buf_count;			/**< number of buffers */
+	drm_buf_t *buflist;		/**< buffer list */
+	int seg_count;
+	int page_order;
+	unsigned long *seglist;
 
-	drm_freelist_t	  freelist;
+	drm_freelist_t freelist;
 } drm_buf_entry_t;
 
 /** File private data */
 typedef struct drm_file {
-	int		  authenticated;
-	int		  minor;
-	pid_t		  pid;
-	uid_t		  uid;
-	drm_magic_t	  magic;
-	unsigned long	  ioctl_count;
-	struct drm_file	  *next;
-	struct drm_file	  *prev;
-	struct drm_head   *head;
-	int 		  remove_auth_on_close;
-	unsigned long     lock_count;
-	void              *driver_priv;
+	int authenticated;
+	int minor;
+	pid_t pid;
+	uid_t uid;
+	drm_magic_t magic;
+	unsigned long ioctl_count;
+	struct drm_file *next;
+	struct drm_file *prev;
+	struct drm_head *head;
+	int remove_auth_on_close;
+	unsigned long lock_count;
+	void *driver_priv;
 } drm_file_t;
 
 /** Wait queue */
 typedef struct drm_queue {
-	atomic_t	  use_count;	/**< Outstanding uses (+1) */
-	atomic_t	  finalization;	/**< Finalization in progress */
-	atomic_t	  block_count;	/**< Count of processes waiting */
-	atomic_t	  block_read;	/**< Queue blocked for reads */
+	atomic_t use_count;		/**< Outstanding uses (+1) */
+	atomic_t finalization;		/**< Finalization in progress */
+	atomic_t block_count;		/**< Count of processes waiting */
+	atomic_t block_read;		/**< Queue blocked for reads */
 	wait_queue_head_t read_queue;	/**< Processes waiting on block_read */
-	atomic_t	  block_write;	/**< Queue blocked for writes */
+	atomic_t block_write;		/**< Queue blocked for writes */
 	wait_queue_head_t write_queue;	/**< Processes waiting on block_write */
 #if 1
-	atomic_t	  total_queued;	/**< Total queued statistic */
-	atomic_t	  total_flushed;/**< Total flushes statistic */
-	atomic_t	  total_locks;	/**< Total locks statistics */
+	atomic_t total_queued;		/**< Total queued statistic */
+	atomic_t total_flushed;		/**< Total flushes statistic */
+	atomic_t total_locks;		/**< Total locks statistics */
 #endif
-	drm_ctx_flags_t	  flags;	/**< Context preserving and 2D-only */
-	drm_waitlist_t	  waitlist;	/**< Pending buffers */
+	drm_ctx_flags_t flags;		/**< Context preserving and 2D-only */
+	drm_waitlist_t waitlist;	/**< Pending buffers */
 	wait_queue_head_t flush_queue;	/**< Processes waiting until flush */
 } drm_queue_t;
 
@@ -454,10 +411,10 @@ typedef struct drm_queue {
  * Lock data.
  */
 typedef struct drm_lock_data {
-	drm_hw_lock_t	  *hw_lock;	/**< Hardware lock */
-	struct file       *filp;	/**< File descr of lock holder (0=kernel) */
+	drm_hw_lock_t *hw_lock;		/**< Hardware lock */
+	struct file *filp;		/**< File descr of lock holder (0=kernel) */
 	wait_queue_head_t lock_queue;	/**< Queue of blocked processes */
-	unsigned long	  lock_time;	/**< Time of last lock in jiffies */
+	unsigned long lock_time;	/**< Time of last lock in jiffies */
 } drm_lock_data_t;
 
 /**
@@ -465,28 +422,29 @@ typedef struct drm_lock_data {
  */
 typedef struct drm_device_dma {
 
-	drm_buf_entry_t	  bufs[DRM_MAX_ORDER+1];	/**< buffers, grouped by their size order */
-	int		  buf_count;	/**< total number of buffers */
-	drm_buf_t	  **buflist;	/**< Vector of pointers into drm_device_dma::bufs */
-	int		  seg_count;
-	int		  page_count;	/**< number of pages */
-	unsigned long	  *pagelist;	/**< page list */
-	unsigned long	  byte_count;
+	drm_buf_entry_t bufs[DRM_MAX_ORDER + 1]; /**< buffers, grouped by their size order */
+	int buf_count;			/**< total number of buffers */
+	drm_buf_t **buflist;		/**< Vector of pointers into drm_device_dma::bufs */
+	int seg_count;
+	int page_count;			/**< number of pages */
+	unsigned long *pagelist;	/**< page list */
+	unsigned long byte_count;
 	enum {
 		_DRM_DMA_USE_AGP = 0x01,
-		_DRM_DMA_USE_SG  = 0x02
+		_DRM_DMA_USE_SG = 0x02,
+		_DRM_DMA_USE_FB = 0x04
 	} flags;
 
 } drm_device_dma_t;
 
-/** 
+/**
  * AGP memory entry.  Stored as a doubly linked list.
  */
 typedef struct drm_agp_mem {
-	unsigned long      handle;	/**< handle */
-	DRM_AGP_MEM        *memory;	
-	unsigned long      bound;	/**< address */
-	int                pages;
+	unsigned long handle;		/**< handle */
+	DRM_AGP_MEM *memory;
+	unsigned long bound;		/**< address */
+	int pages;
 	struct drm_agp_mem *prev;	/**< previous entry */
 	struct drm_agp_mem *next;	/**< next entry */
 } drm_agp_mem_t;
@@ -494,43 +452,51 @@ typedef struct drm_agp_mem {
 /**
  * AGP data.
  *
- * \sa drm_agp_init() and drm_device::agp.
+ * \sa drm_agp_init)() and drm_device::agp.
  */
 typedef struct drm_agp_head {
-	DRM_AGP_KERN       agp_info;	/**< AGP device information */
-	drm_agp_mem_t      *memory;	/**< memory entries */
-	unsigned long      mode;	/**< AGP mode */
+	DRM_AGP_KERN agp_info;		/**< AGP device information */
+	drm_agp_mem_t *memory;		/**< memory entries */
+	unsigned long mode;		/**< AGP mode */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,11)
 	struct agp_bridge_data  *bridge;
-	int                enabled;	/**< whether the AGP bus as been enabled */
-	int                acquired;	/**< whether the AGP device has been acquired */
-	unsigned long      base;
-   	int 		   agp_mtrr;
-	int		   cant_use_aperture;
-	unsigned long	   page_mask;
+#endif
+	int enabled;			/**< whether the AGP bus as been enabled */
+	int acquired;			/**< whether the AGP device has been acquired */
+	unsigned long base;
+	int agp_mtrr;
+	int cant_use_aperture;
+	unsigned long page_mask;
 } drm_agp_head_t;
 
 /**
  * Scatter-gather memory.
  */
 typedef struct drm_sg_mem {
-	unsigned long   handle;
-	void            *virtual;
-	int             pages;
-	struct page     **pagelist;
-	dma_addr_t	*busaddr;
+	unsigned long handle;
+	void *virtual;
+	int pages;
+	struct page **pagelist;
+	dma_addr_t *busaddr;
 } drm_sg_mem_t;
 
 typedef struct drm_sigdata {
-	int           context;
+	int context;
 	drm_hw_lock_t *lock;
 } drm_sigdata_t;
 
+typedef struct drm_dma_handle {
+	dma_addr_t busaddr;
+	void *vaddr;
+	size_t size;
+} drm_dma_handle_t;
+
 /**
  * Mappings list
  */
 typedef struct drm_map_list {
-	struct list_head	head;	/**< list head */
-	drm_map_t		*map;	/**< mapping */
+	struct list_head head;		/**< list head */
+	drm_map_t *map;			/**< mapping */
 } drm_map_list_t;
 
 typedef drm_map_t drm_local_map_t;
@@ -539,56 +505,72 @@ typedef drm_map_t drm_local_map_t;
  * Context handle list
  */
 typedef struct drm_ctx_list {
-	struct list_head	head;   /**< list head */
-	drm_context_t		handle; /**< context handle */
-	drm_file_t		*tag;   /**< associated fd private data */
+	struct list_head head;		/**< list head */
+	drm_context_t handle;		/**< context handle */
+	drm_file_t *tag;		/**< associated fd private data */
 } drm_ctx_list_t;
 
-
 typedef struct drm_vbl_sig {
-	struct list_head	head;
-	unsigned int		sequence;
-	struct siginfo		info;
-	struct task_struct	*task;
+	struct list_head head;
+	unsigned int sequence;
+	struct siginfo info;
+	struct task_struct *task;
 } drm_vbl_sig_t;
 
-
 /**
  * DRM driver structure. This structure represent the common code for
  * a family of cards. There will one drm_device for each card present
  * in this family
  */
 struct drm_device;
-
 struct drm_driver {
-	int (*preinit)(struct drm_device *, unsigned long flags);
-	void (*prerelease)(struct drm_device *, struct file *filp);
-	void (*pretakedown)(struct drm_device *);
-	int (*postcleanup)(struct drm_device *);
-	int (*presetup)(struct drm_device *);
-	int (*postsetup)(struct drm_device *);
- 	int (*dma_ioctl)( DRM_IOCTL_ARGS );
-	int (*open_helper)(struct drm_device *, drm_file_t *);
-	void (*free_filp_priv)(struct drm_device *, drm_file_t *);
-	void (*release)(struct drm_device *, struct file *filp);
-	void (*dma_ready)(struct drm_device *);
-	int (*dma_quiescent)(struct drm_device *);
-	int (*context_ctor)(struct drm_device *dev, int context);
- 	int (*context_dtor)(struct drm_device *dev, int context);
- 	int (*kernel_context_switch)(struct drm_device *dev, int old, int new);
-	void (*kernel_context_switch_unlock)(struct drm_device *dev, drm_lock_t *lock);
-	int (*vblank_wait)(struct drm_device *dev, unsigned int *sequence);
-	/* these have to be filled in */
- 	int (*postinit)(struct drm_device *, unsigned long flags);
-	irqreturn_t (*irq_handler)( DRM_IRQ_ARGS );
- 	void (*irq_preinstall)(struct drm_device *dev);
- 	void (*irq_postinstall)(struct drm_device *dev);
- 	void (*irq_uninstall)(struct drm_device *dev);
-	void (*reclaim_buffers)(struct drm_device *dev, struct file *filp);
-	unsigned long (*get_map_ofs)(drm_map_t *map);
-	unsigned long (*get_reg_ofs)(struct drm_device *dev);
-	void (*set_version)(struct drm_device *dev, drm_set_version_t *sv);
- 	int (*version)(drm_version_t *version);
+	int (*preinit) (struct drm_device *, unsigned long flags);
+	void (*prerelease) (struct drm_device *, struct file * filp);
+	void (*pretakedown) (struct drm_device *);
+	int (*postcleanup) (struct drm_device *);
+	int (*presetup) (struct drm_device *);
+	int (*postsetup) (struct drm_device *);
+	int (*dma_ioctl) (DRM_IOCTL_ARGS);
+	/* these are opposites at the moment */
+	int (*open_helper) (struct drm_device *, drm_file_t *);
+	void (*free_filp_priv) (struct drm_device *, drm_file_t *);
+
+	void (*release) (struct drm_device *, struct file * filp);
+	void (*dma_ready) (struct drm_device *);
+	int (*dma_quiescent) (struct drm_device *);
+	int (*context_ctor) (struct drm_device * dev, int context);
+	int (*context_dtor) (struct drm_device * dev, int context);
+	int (*kernel_context_switch) (struct drm_device * dev, int old,
+				      int new);
+	int (*kernel_context_switch_unlock) (struct drm_device * dev);
+	int (*vblank_wait) (struct drm_device * dev, unsigned int *sequence);
+	int (*dri_library_name) (struct drm_device * dev, char * buf);
+
+	/**
+	 * Called by \c drm_device_is_agp.  Typically used to determine if a
+	 * card is really attached to AGP or not.
+	 *
+	 * \param dev  DRM device handle
+	 *
+	 * \returns
+	 * One of three values is returned depending on whether or not the
+	 * card is absolutely \b not AGP (return of 0), absolutely \b is AGP
+	 * (return of 1), or may or may not be AGP (return of 2).
+	 */
+	int (*device_is_agp) (struct drm_device * dev);
+
+/* these have to be filled in */
+	int (*postinit) (struct drm_device *, unsigned long flags);
+	 irqreturn_t(*irq_handler) (DRM_IRQ_ARGS);
+	void (*irq_preinstall) (struct drm_device * dev);
+	void (*irq_postinstall) (struct drm_device * dev);
+	void (*irq_uninstall) (struct drm_device * dev);
+	void (*reclaim_buffers) (struct drm_device *dev, struct file * filp);
+	unsigned long (*get_map_ofs) (drm_map_t * map);
+	unsigned long (*get_reg_ofs) (struct drm_device * dev);
+	void (*set_version) (struct drm_device * dev, drm_set_version_t * sv);
+	int (*version) (drm_version_t * version);
+/* variables */
 	u32 driver_features;
 	int dev_priv_size;
 	drm_ioctl_desc_t *ioctls;
@@ -615,112 +597,116 @@ typedef struct drm_head {
  * may contain multiple heads.
  */
 typedef struct drm_device {
-	char		  *unique;	/**< Unique identifier: e.g., busid */
-	int		  unique_len;	/**< Length of unique field */
-	char		  *devname;	/**< For /proc/interrupts */
-	int		  if_version;	/**< Highest interface version set */
+	char *unique;			/**< Unique identifier: e.g., busid */
+	int unique_len;			/**< Length of unique field */
+	char *devname;			/**< For /proc/interrupts */
+	int if_version;			/**< Highest interface version set */
 
-	int		  blocked;	/**< Blocked due to VC switch? */
+	int blocked;			/**< Blocked due to VC switch? */
 
 	/** \name Locks */
-	/*@{*/
-	spinlock_t	  count_lock;	/**< For inuse, drm_device::open_count, drm_device::buf_use */
-	struct semaphore  struct_sem;	/**< For others */
-	/*@}*/
+	/*@{ */
+	spinlock_t count_lock;		/**< For inuse, drm_device::open_count, drm_device::buf_use */
+	struct semaphore struct_sem;	/**< For others */
+	/*@} */
 
 	/** \name Usage Counters */
-	/*@{*/
-	int		  open_count;	/**< Outstanding files open */
-	atomic_t	  ioctl_count;	/**< Outstanding IOCTLs pending */
-	atomic_t	  vma_count;	/**< Outstanding vma areas open */
-	int		  buf_use;	/**< Buffers in use -- cannot alloc */
-	atomic_t	  buf_alloc;	/**< Buffer allocation in progress */
-	/*@}*/
+	/*@{ */
+	int open_count;			/**< Outstanding files open */
+	atomic_t ioctl_count;		/**< Outstanding IOCTLs pending */
+	atomic_t vma_count;		/**< Outstanding vma areas open */
+	int buf_use;			/**< Buffers in use -- cannot alloc */
+	atomic_t buf_alloc;		/**< Buffer allocation in progress */
+	/*@} */
 
 	/** \name Performance counters */
-	/*@{*/
-	unsigned long     counters;
-	drm_stat_type_t   types[15];
-	atomic_t          counts[15];
-	/*@}*/
+	/*@{ */
+	unsigned long counters;
+	drm_stat_type_t types[15];
+	atomic_t counts[15];
+	/*@} */
 
 	/** \name Authentication */
-	/*@{*/
-	drm_file_t	  *file_first;	/**< file list head */
-	drm_file_t	  *file_last;	/**< file list tail */
-	drm_magic_head_t  magiclist[DRM_HASH_SIZE];	/**< magic hash table */
-	/*@}*/
+	/*@{ */
+	drm_file_t *file_first;		/**< file list head */
+	drm_file_t *file_last;		/**< file list tail */
+	drm_magic_head_t magiclist[DRM_HASH_SIZE]; /**< magic hash table */
+	/*@} */
 
 	/** \name Memory management */
-	/*@{*/
-	drm_map_list_t	  *maplist;	/**< Linked list of regions */
-	int		  map_count;	/**< Number of mappable regions */
+	/*@{ */
+	drm_map_list_t *maplist;	/**< Linked list of regions */
+	int map_count;			/**< Number of mappable regions */
 
 	/** \name Context handle management */
-	/*@{*/
-	drm_ctx_list_t	  *ctxlist;	/**< Linked list of context handles */
-	int		  ctx_count;	/**< Number of context handles */
-	struct semaphore  ctxlist_sem;	/**< For ctxlist */
-
-	drm_map_t	  **context_sareas; /**< per-context SAREA's */
-	int		  max_context;
-
-	drm_vma_entry_t	  *vmalist;	/**< List of vmas (for debugging) */
-	drm_lock_data_t	  lock;		/**< Information on hardware lock */
-	/*@}*/
+	/*@{ */
+	drm_ctx_list_t *ctxlist;	/**< Linked list of context handles */
+	int ctx_count;			/**< Number of context handles */
+	struct semaphore ctxlist_sem;	/**< For ctxlist */
+
+	drm_map_t **context_sareas;	/**< per-context SAREA's */
+	int max_context;
+
+	drm_vma_entry_t *vmalist;	/**< List of vmas (for debugging) */
+	drm_lock_data_t lock;		/**< Information on hardware lock */
+	/*@} */
 
 	/** \name DMA queues (contexts) */
-	/*@{*/
-	int		  queue_count;	/**< Number of active DMA queues */
-	int		  queue_reserved; /**< Number of reserved DMA queues */
-	int		  queue_slots;	/**< Actual length of queuelist */
-	drm_queue_t	  **queuelist;	/**< Vector of pointers to DMA queues */
-	drm_device_dma_t  *dma;		/**< Optional pointer for DMA support */
-	/*@}*/
+	/*@{ */
+	int queue_count;		/**< Number of active DMA queues */
+	int queue_reserved;		/**< Number of reserved DMA queues */
+	int queue_slots;		/**< Actual length of queuelist */
+	drm_queue_t **queuelist;	/**< Vector of pointers to DMA queues */
+	drm_device_dma_t *dma;		/**< Optional pointer for DMA support */
+	/*@} */
 
 	/** \name Context support */
-	/*@{*/
-	int		  irq;		/**< Interrupt used by board */
-	int		  irq_enabled;	/**< True if irq handler is enabled */
+	/*@{ */
+	int irq;			/**< Interrupt used by board */
+	int irq_enabled;		/**< True if irq handler is enabled */
 	__volatile__ long context_flag;	/**< Context swapping flag */
 	__volatile__ long interrupt_flag; /**< Interruption handler flag */
 	__volatile__ long dma_flag;	/**< DMA dispatch flag */
 	struct timer_list timer;	/**< Timer for delaying ctx switch */
-	wait_queue_head_t context_wait; /**< Processes waiting on ctx switch */
-	int		  last_checked;	/**< Last context checked for DMA */
-	int		  last_context;	/**< Last current context */
-	unsigned long	  last_switch;	/**< jiffies at last context switch */
-	/*@}*/
-	
-	struct work_struct	work;
+	wait_queue_head_t context_wait;	/**< Processes waiting on ctx switch */
+	int last_checked;		/**< Last context checked for DMA */
+	int last_context;		/**< Last current context */
+	unsigned long last_switch;	/**< jiffies at last context switch */
+	/*@} */
+
+#if !HAS_WORKQUEUE
+	struct tq_struct tq;
+#else
+	struct work_struct work;
+#endif
 	/** \name VBLANK IRQ support */
-	/*@{*/
+	/*@{ */
 
-   	wait_queue_head_t vbl_queue;	/**< VBLANK wait queue */
-   	atomic_t          vbl_received;
-	spinlock_t        vbl_lock;
-	drm_vbl_sig_t     vbl_sigs;	/**< signal list to send on VBLANK */
-	unsigned int      vbl_pending;
-
-	/*@}*/
-	cycles_t	  ctx_start;
-	cycles_t	  lck_start;
-
-	char		  buf[DRM_BSZ]; /**< Output buffer */
-	char		  *buf_rp;	/**< Read pointer */
-	char		  *buf_wp;	/**< Write pointer */
-	char		  *buf_end;	/**< End pointer */
+	wait_queue_head_t vbl_queue;	/**< VBLANK wait queue */
+	atomic_t vbl_received;
+	spinlock_t vbl_lock;
+	drm_vbl_sig_t vbl_sigs;		/**< signal list to send on VBLANK */
+	unsigned int vbl_pending;
+
+	/*@} */
+	cycles_t ctx_start;
+	cycles_t lck_start;
+
+	char buf[DRM_BSZ];		/**< Output buffer */
+	char *buf_rp;			/**< Read pointer */
+	char *buf_wp;			/**< Write pointer */
+	char *buf_end;			/**< End pointer */
 	struct fasync_struct *buf_async;/**< Processes waiting for SIGIO */
 	wait_queue_head_t buf_readers;	/**< Processes waiting to read */
 	wait_queue_head_t buf_writers;	/**< Processes waiting to ctx switch */
 
-	drm_agp_head_t    *agp;	/**< AGP data */
+	drm_agp_head_t *agp;		/**< AGP data */
 
-	struct pci_dev    *pdev;	/**< PCI device structure */
-	int               pci_domain;	/**< PCI bus domain number */
-	int               pci_bus;	/**< PCI bus number */
-	int               pci_slot;	/**< PCI slot number */
-	int               pci_func;	/**< PCI function number */
+	struct pci_dev *pdev;		/**< PCI device structure */
+	int pci_domain;			/**< PCI bus domain number */
+	int pci_bus;			/**< PCI bus number */
+	int pci_slot;			/**< PCI slot number */
+	int pci_func;			/**< PCI function number */
 #ifdef __alpha__
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,3)
 	struct pci_controler *hose;
@@ -728,18 +714,19 @@ typedef struct drm_device {
 	struct pci_controller *hose;
 #endif
 #endif
-	drm_sg_mem_t      *sg;  /**< Scatter gather memory */
-	unsigned long     *ctx_bitmap;	/**< context bitmap */
-	void		  *dev_private; /**< device private data */
-	drm_sigdata_t     sigdata; /**< For block_all_signals */
-	sigset_t          sigmask;
+	drm_sg_mem_t *sg;		/**< Scatter gather memory */
+	unsigned long *ctx_bitmap;	/**< context bitmap */
+	void *dev_private;		/**< device private data */
+	drm_sigdata_t sigdata;		/**< For block_all_signals */
+	sigset_t sigmask;
 
-	struct            drm_driver *driver;
-	drm_local_map_t   *agp_buffer_map;
+	struct drm_driver *driver;
+	drm_local_map_t *agp_buffer_map;
 	drm_head_t primary;		/**< primary screen head */
 } drm_device_t;
 
-static __inline__ int drm_core_check_feature(struct drm_device *dev, int feature)
+static __inline__ int drm_core_check_feature(struct drm_device *dev,
+					     int feature)
 {
 	return ((dev->driver->driver_features & feature) ? 1 : 0);
 }
@@ -747,7 +734,7 @@ static __inline__ int drm_core_check_fea
 #if __OS_HAS_AGP
 static inline int drm_core_has_AGP(struct drm_device *dev)
 {
-  return drm_core_check_feature(dev, DRIVER_USE_AGP);
+	return drm_core_check_feature(dev, DRIVER_USE_AGP);
 }
 #else
 #define drm_core_has_AGP(dev) (0)
@@ -756,7 +743,7 @@ static inline int drm_core_has_AGP(struc
 #if __OS_HAS_MTRR
 static inline int drm_core_has_MTRR(struct drm_device *dev)
 {
-  return drm_core_check_feature(dev, DRIVER_USE_MTRR);
+	return drm_core_check_feature(dev, DRIVER_USE_MTRR);
 }
 #else
 #define drm_core_has_MTRR(dev) (0)
@@ -766,245 +753,234 @@ static inline int drm_core_has_MTRR(stru
 /** \name Internal function definitions */
 /*@{*/
 
-				/* Misc. support (drm_init.h) */
-extern int	     drm_flags;
-extern void	     drm_parse_options( char *s );
-extern int           drm_cpu_valid( void );
-
 				/* Driver support (drm_drv.h) */
-extern int           drm_init(struct drm_driver *driver);
-extern void          drm_exit(struct drm_driver *driver);
-extern int           drm_version(struct inode *inode, struct file *filp,
-				  unsigned int cmd, unsigned long arg);
-extern int           drm_ioctl(struct inode *inode, struct file *filp,
-				unsigned int cmd, unsigned long arg);
-extern long	     drm_compat_ioctl(struct file *filp,
-				unsigned int cmd, unsigned long arg);
-extern int           drm_takedown(drm_device_t * dev);
+extern int drm_fb_loaded;
+extern int __devinit drm_init(struct drm_driver *driver,
+			      struct pci_device_id *pciidlist);
+extern void __exit drm_exit(struct drm_driver *driver);
+extern void __exit drm_cleanup_pci(struct pci_dev *pdev);
+extern int drm_ioctl(struct inode *inode, struct file *filp,
+		     unsigned int cmd, unsigned long arg);
+extern long drm_compat_ioctl(struct file *filp,
+			     unsigned int cmd, unsigned long arg);
+
+extern int drm_takedown(drm_device_t * dev);
 
 				/* Device support (drm_fops.h) */
-extern int           drm_open(struct inode *inode, struct file *filp);
-extern int           drm_stub_open(struct inode *inode, struct file *filp);
-extern int	     drm_open_helper(struct inode *inode, struct file *filp,
-				      drm_device_t *dev);
-extern int	     drm_flush(struct file *filp);
-extern int	     drm_fasync(int fd, struct file *filp, int on);
-extern int           drm_release(struct inode *inode, struct file *filp);
+extern int drm_open(struct inode *inode, struct file *filp);
+extern int drm_stub_open(struct inode *inode, struct file *filp);
+extern int drm_fasync(int fd, struct file *filp, int on);
+extern int drm_release(struct inode *inode, struct file *filp);
+unsigned int drm_poll(struct file *filp, struct poll_table_struct *wait);
 
 				/* Mapping support (drm_vm.h) */
-extern void	     drm_vm_open(struct vm_area_struct *vma);
-extern void	     drm_vm_close(struct vm_area_struct *vma);
-extern void	     drm_vm_shm_close(struct vm_area_struct *vma);
-extern int	     drm_mmap_dma(struct file *filp,
-				   struct vm_area_struct *vma);
-extern int	     drm_mmap(struct file *filp, struct vm_area_struct *vma);
-extern unsigned int  drm_poll(struct file *filp, struct poll_table_struct *wait);
-extern ssize_t       drm_read(struct file *filp, char __user *buf, size_t count, loff_t *off);
+extern int drm_mmap(struct file *filp, struct vm_area_struct *vma);
+extern unsigned long drm_core_get_map_ofs(drm_map_t * map);
+extern unsigned long drm_core_get_reg_ofs(struct drm_device *dev);
 
 				/* Memory management support (drm_memory.h) */
 #include "drm_memory.h"
-extern void	     drm_mem_init(void);
-extern int	     drm_mem_info(char *buf, char **start, off_t offset,
-				   int request, int *eof, void *data);
-extern void	     *drm_calloc(size_t nmemb, size_t size, int area);
-extern void	     *drm_realloc(void *oldpt, size_t oldsize, size_t size,
-				   int area);
+extern void drm_mem_init(void);
+extern int drm_mem_info(char *buf, char **start, off_t offset,
+			int request, int *eof, void *data);
+extern void *drm_calloc(size_t nmemb, size_t size, int area);
+extern void *drm_realloc(void *oldpt, size_t oldsize, size_t size, int area);
 extern unsigned long drm_alloc_pages(int order, int area);
-extern void	     drm_free_pages(unsigned long address, int order,
-				     int area);
-extern void	     *drm_ioremap(unsigned long offset, unsigned long size, drm_device_t *dev);
-extern void	     *drm_ioremap_nocache(unsigned long offset, unsigned long size,
-					   drm_device_t *dev);
-extern void	     drm_ioremapfree(void *pt, unsigned long size, drm_device_t *dev);
-
-extern DRM_AGP_MEM   *drm_alloc_agp(struct agp_bridge_data *bridge, int pages, u32 type);
-extern int           drm_free_agp(DRM_AGP_MEM *handle, int pages);
-extern int           drm_bind_agp(DRM_AGP_MEM *handle, unsigned int start);
-extern int           drm_unbind_agp(DRM_AGP_MEM *handle);
+extern void drm_free_pages(unsigned long address, int order, int area);
+extern DRM_AGP_MEM *drm_alloc_agp(drm_device_t *dev, int pages, u32 type);
+extern int drm_free_agp(DRM_AGP_MEM * handle, int pages);
+extern int drm_bind_agp(DRM_AGP_MEM * handle, unsigned int start);
+extern int drm_unbind_agp(DRM_AGP_MEM * handle);
 
 				/* Misc. IOCTL support (drm_ioctl.h) */
-extern int	     drm_irq_by_busid(struct inode *inode, struct file *filp,
-				       unsigned int cmd, unsigned long arg);
-extern int	     drm_getunique(struct inode *inode, struct file *filp,
-				    unsigned int cmd, unsigned long arg);
-extern int	     drm_setunique(struct inode *inode, struct file *filp,
-				    unsigned int cmd, unsigned long arg);
-extern int	     drm_getmap(struct inode *inode, struct file *filp,
-				 unsigned int cmd, unsigned long arg);
-extern int	     drm_getclient(struct inode *inode, struct file *filp,
-				    unsigned int cmd, unsigned long arg);
-extern int	     drm_getstats(struct inode *inode, struct file *filp,
-				   unsigned int cmd, unsigned long arg);
-extern int	     drm_setversion(struct inode *inode, struct file *filp,
-				     unsigned int cmd, unsigned long arg);
+extern int drm_irq_by_busid(struct inode *inode, struct file *filp,
+			    unsigned int cmd, unsigned long arg);
+extern int drm_getunique(struct inode *inode, struct file *filp,
+			 unsigned int cmd, unsigned long arg);
+extern int drm_setunique(struct inode *inode, struct file *filp,
+			 unsigned int cmd, unsigned long arg);
+extern int drm_getmap(struct inode *inode, struct file *filp,
+		      unsigned int cmd, unsigned long arg);
+extern int drm_getclient(struct inode *inode, struct file *filp,
+			 unsigned int cmd, unsigned long arg);
+extern int drm_getstats(struct inode *inode, struct file *filp,
+			unsigned int cmd, unsigned long arg);
+extern int drm_setversion(struct inode *inode, struct file *filp,
+			  unsigned int cmd, unsigned long arg);
+extern int drm_noop(struct inode *inode, struct file *filp,
+		    unsigned int cmd, unsigned long arg);
 
 				/* Context IOCTL support (drm_context.h) */
-extern int	     drm_resctx( struct inode *inode, struct file *filp,
-				  unsigned int cmd, unsigned long arg );
-extern int	     drm_addctx( struct inode *inode, struct file *filp,
-				  unsigned int cmd, unsigned long arg );
-extern int	     drm_modctx( struct inode *inode, struct file *filp,
-				  unsigned int cmd, unsigned long arg );
-extern int	     drm_getctx( struct inode *inode, struct file *filp,
-				  unsigned int cmd, unsigned long arg );
-extern int	     drm_switchctx( struct inode *inode, struct file *filp,
-				     unsigned int cmd, unsigned long arg );
-extern int	     drm_newctx( struct inode *inode, struct file *filp,
-				  unsigned int cmd, unsigned long arg );
-extern int	     drm_rmctx( struct inode *inode, struct file *filp,
-				 unsigned int cmd, unsigned long arg );
-
-extern int	     drm_context_switch(drm_device_t *dev, int old, int new);
-extern int	     drm_context_switch_complete(drm_device_t *dev, int new);
-
-extern int	     drm_ctxbitmap_init( drm_device_t *dev );
-extern void	     drm_ctxbitmap_cleanup( drm_device_t *dev );
-extern void          drm_ctxbitmap_free( drm_device_t *dev, int ctx_handle );
-
-extern int	     drm_setsareactx( struct inode *inode, struct file *filp,
-				       unsigned int cmd, unsigned long arg );
-extern int	     drm_getsareactx( struct inode *inode, struct file *filp,
-				       unsigned int cmd, unsigned long arg );
+extern int drm_resctx(struct inode *inode, struct file *filp,
+		      unsigned int cmd, unsigned long arg);
+extern int drm_addctx(struct inode *inode, struct file *filp,
+		      unsigned int cmd, unsigned long arg);
+extern int drm_modctx(struct inode *inode, struct file *filp,
+		      unsigned int cmd, unsigned long arg);
+extern int drm_getctx(struct inode *inode, struct file *filp,
+		      unsigned int cmd, unsigned long arg);
+extern int drm_switchctx(struct inode *inode, struct file *filp,
+			 unsigned int cmd, unsigned long arg);
+extern int drm_newctx(struct inode *inode, struct file *filp,
+		      unsigned int cmd, unsigned long arg);
+extern int drm_rmctx(struct inode *inode, struct file *filp,
+		     unsigned int cmd, unsigned long arg);
+
+extern int drm_context_switch_complete(drm_device_t * dev, int new);
+
+extern int drm_ctxbitmap_init(drm_device_t * dev);
+extern void drm_ctxbitmap_cleanup(drm_device_t * dev);
+extern void drm_ctxbitmap_free(drm_device_t * dev, int ctx_handle);
+
+extern int drm_setsareactx(struct inode *inode, struct file *filp,
+			   unsigned int cmd, unsigned long arg);
+extern int drm_getsareactx(struct inode *inode, struct file *filp,
+			   unsigned int cmd, unsigned long arg);
 
 				/* Drawable IOCTL support (drm_drawable.h) */
-extern int	     drm_adddraw(struct inode *inode, struct file *filp,
-				  unsigned int cmd, unsigned long arg);
-extern int	     drm_rmdraw(struct inode *inode, struct file *filp,
-				 unsigned int cmd, unsigned long arg);
-
+extern int drm_adddraw(struct inode *inode, struct file *filp,
+		       unsigned int cmd, unsigned long arg);
+extern int drm_rmdraw(struct inode *inode, struct file *filp,
+		      unsigned int cmd, unsigned long arg);
 
 				/* Authentication IOCTL support (drm_auth.h) */
-extern int	     drm_add_magic(drm_device_t *dev, drm_file_t *priv,
-				    drm_magic_t magic);
-extern int	     drm_remove_magic(drm_device_t *dev, drm_magic_t magic);
-extern int	     drm_getmagic(struct inode *inode, struct file *filp,
-				   unsigned int cmd, unsigned long arg);
-extern int	     drm_authmagic(struct inode *inode, struct file *filp,
-				    unsigned int cmd, unsigned long arg);
-
-                                /* Placeholder for ioctls past */
-extern int	     drm_noop(struct inode *inode, struct file *filp,
-				  unsigned int cmd, unsigned long arg);
+extern int drm_getmagic(struct inode *inode, struct file *filp,
+			unsigned int cmd, unsigned long arg);
+extern int drm_authmagic(struct inode *inode, struct file *filp,
+			 unsigned int cmd, unsigned long arg);
 
 				/* Locking IOCTL support (drm_lock.h) */
-extern int           drm_lock(struct inode *inode, struct file *filp,
-			       unsigned int cmd, unsigned long arg);
-extern int           drm_unlock(struct inode *inode, struct file *filp,
-				 unsigned int cmd, unsigned long arg);
-extern int	     drm_lock_take(__volatile__ unsigned int *lock,
-				    unsigned int context);
-extern int	     drm_lock_transfer(drm_device_t *dev,
-					__volatile__ unsigned int *lock,
-					unsigned int context);
-extern int	     drm_lock_free(drm_device_t *dev,
-				    __volatile__ unsigned int *lock,
-				    unsigned int context);
-extern int           drm_notifier(void *priv);
+extern int drm_lock(struct inode *inode, struct file *filp,
+		    unsigned int cmd, unsigned long arg);
+extern int drm_unlock(struct inode *inode, struct file *filp,
+		      unsigned int cmd, unsigned long arg);
+extern int drm_lock_take(__volatile__ unsigned int *lock, unsigned int context);
+extern int drm_lock_free(drm_device_t * dev,
+			 __volatile__ unsigned int *lock, unsigned int context);
 
 				/* Buffer management support (drm_bufs.h) */
-extern int	     drm_order( unsigned long size );
-extern int	     drm_addmap( struct inode *inode, struct file *filp,
-				  unsigned int cmd, unsigned long arg );
-extern int	     drm_rmmap( struct inode *inode, struct file *filp,
-				 unsigned int cmd, unsigned long arg );
-extern int	     drm_addbufs( struct inode *inode, struct file *filp,
-				   unsigned int cmd, unsigned long arg );
-extern int	     drm_infobufs( struct inode *inode, struct file *filp,
-				    unsigned int cmd, unsigned long arg );
-extern int	     drm_markbufs( struct inode *inode, struct file *filp,
-				    unsigned int cmd, unsigned long arg );
-extern int	     drm_freebufs( struct inode *inode, struct file *filp,
-				    unsigned int cmd, unsigned long arg );
-extern int	     drm_mapbufs( struct inode *inode, struct file *filp,
-				   unsigned int cmd, unsigned long arg );
+extern int drm_addbufs_agp(drm_device_t * dev, drm_buf_desc_t * request);
+extern int drm_addbufs_pci(drm_device_t * dev, drm_buf_desc_t * request);
+extern int drm_addbufs_fb (drm_device_t * dev, drm_buf_desc_t * request);
+extern int drm_addmap(drm_device_t * dev, unsigned int offset,
+		      unsigned int size, drm_map_type_t type,
+		      drm_map_flags_t flags, drm_local_map_t ** map_ptr);
+extern int drm_addmap_ioctl(struct inode *inode, struct file *filp,
+			    unsigned int cmd, unsigned long arg);
+extern int drm_rmmap(drm_device_t *dev, drm_local_map_t *map);
+extern int drm_rmmap_locked(drm_device_t *dev, drm_local_map_t *map);
+extern int drm_rmmap_ioctl(struct inode *inode, struct file *filp,
+			   unsigned int cmd, unsigned long arg);
+extern int drm_addbufs(struct inode *inode, struct file *filp,
+		       unsigned int cmd, unsigned long arg);
+extern int drm_infobufs(struct inode *inode, struct file *filp,
+			unsigned int cmd, unsigned long arg);
+extern int drm_markbufs(struct inode *inode, struct file *filp,
+			unsigned int cmd, unsigned long arg);
+extern int drm_freebufs(struct inode *inode, struct file *filp,
+			unsigned int cmd, unsigned long arg);
+extern int drm_mapbufs(struct inode *inode, struct file *filp,
+		       unsigned int cmd, unsigned long arg);
+extern int drm_order(unsigned long size);
+extern unsigned long drm_get_resource_start(drm_device_t *dev,
+					    unsigned int resource);
+extern unsigned long drm_get_resource_len(drm_device_t *dev,
+					  unsigned int resource);
+
+				/* Power Management (drm_pm.h) */
+extern int drm_pm_setup(drm_device_t *dev);
+extern void drm_pm_takedown(drm_device_t *dev);
+extern int drm_pm_init(void);
+extern void drm_pm_exit(void);
 
 				/* DMA support (drm_dma.h) */
-extern int	     drm_dma_setup(drm_device_t *dev);
-extern void	     drm_dma_takedown(drm_device_t *dev);
-extern void	     drm_free_buffer(drm_device_t *dev, drm_buf_t *buf);
-extern void	     drm_core_reclaim_buffers(drm_device_t *dev, struct file *filp);
+extern int drm_dma_setup(drm_device_t * dev);
+extern void drm_dma_takedown(drm_device_t * dev);
+extern void drm_free_buffer(drm_device_t * dev, drm_buf_t * buf);
+extern void drm_core_reclaim_buffers(drm_device_t *dev, struct file *filp);
 
 				/* IRQ support (drm_irq.h) */
-extern int           drm_control( struct inode *inode, struct file *filp,
-				   unsigned int cmd, unsigned long arg );
-extern int           drm_irq_install( drm_device_t *dev );
-extern int           drm_irq_uninstall( drm_device_t *dev );
-extern irqreturn_t   drm_irq_handler( DRM_IRQ_ARGS );
-extern void          drm_driver_irq_preinstall( drm_device_t *dev );
-extern void          drm_driver_irq_postinstall( drm_device_t *dev );
-extern void          drm_driver_irq_uninstall( drm_device_t *dev );
-
-extern int           drm_wait_vblank(struct inode *inode, struct file *filp,
-				      unsigned int cmd, unsigned long arg);
-extern int           drm_vblank_wait(drm_device_t *dev, unsigned int *vbl_seq);
-extern void          drm_vbl_send_signals( drm_device_t *dev );
+extern int drm_control(struct inode *inode, struct file *filp,
+		       unsigned int cmd, unsigned long arg);
+extern irqreturn_t drm_irq_handler(DRM_IRQ_ARGS);
+extern int drm_irq_uninstall(drm_device_t *dev);
+extern void drm_driver_irq_preinstall(drm_device_t * dev);
+extern void drm_driver_irq_postinstall(drm_device_t * dev);
+extern void drm_driver_irq_uninstall(drm_device_t * dev);
+
+extern int drm_wait_vblank(struct inode *inode, struct file *filp,
+			   unsigned int cmd, unsigned long arg);
+extern int drm_vblank_wait(drm_device_t * dev, unsigned int *vbl_seq);
+extern void drm_vbl_send_signals(drm_device_t * dev);
 
 				/* AGP/GART support (drm_agpsupport.h) */
 extern drm_agp_head_t *drm_agp_init(drm_device_t *dev);
-extern int            drm_agp_acquire(struct inode *inode, struct file *filp,
-				       unsigned int cmd, unsigned long arg);
-extern void           drm_agp_do_release(drm_device_t *dev);
-extern int            drm_agp_release(struct inode *inode, struct file *filp,
-				       unsigned int cmd, unsigned long arg);
-extern int            drm_agp_enable(struct inode *inode, struct file *filp,
-				      unsigned int cmd, unsigned long arg);
-extern int            drm_agp_info(struct inode *inode, struct file *filp,
-				    unsigned int cmd, unsigned long arg);
-extern int            drm_agp_alloc(struct inode *inode, struct file *filp,
-				     unsigned int cmd, unsigned long arg);
-extern int            drm_agp_free(struct inode *inode, struct file *filp,
-				    unsigned int cmd, unsigned long arg);
-extern int            drm_agp_unbind(struct inode *inode, struct file *filp,
-				      unsigned int cmd, unsigned long arg);
-extern int            drm_agp_bind(struct inode *inode, struct file *filp,
-				    unsigned int cmd, unsigned long arg);
-extern DRM_AGP_MEM    *drm_agp_allocate_memory(struct agp_bridge_data *bridge, size_t pages, u32 type);
-extern int            drm_agp_free_memory(DRM_AGP_MEM *handle);
-extern int            drm_agp_bind_memory(DRM_AGP_MEM *handle, off_t start);
-extern int            drm_agp_unbind_memory(DRM_AGP_MEM *handle);
+extern int drm_agp_acquire(drm_device_t * dev);
+extern int drm_agp_acquire_ioctl(struct inode *inode, struct file *filp,
+			   unsigned int cmd, unsigned long arg);
+extern int drm_agp_release(drm_device_t *dev);
+extern int drm_agp_release_ioctl(struct inode *inode, struct file *filp,
+			   unsigned int cmd, unsigned long arg);
+extern int drm_agp_enable(drm_device_t *dev, drm_agp_mode_t mode);
+extern int drm_agp_enable_ioctl(struct inode *inode, struct file *filp,
+			  unsigned int cmd, unsigned long arg);
+extern int drm_agp_info(drm_device_t * dev, drm_agp_info_t *info);
+extern int drm_agp_info_ioctl(struct inode *inode, struct file *filp,
+			unsigned int cmd, unsigned long arg);
+extern int drm_agp_alloc(struct inode *inode, struct file *filp,
+			 unsigned int cmd, unsigned long arg);
+extern int drm_agp_free(struct inode *inode, struct file *filp,
+			unsigned int cmd, unsigned long arg);
+extern int drm_agp_unbind(struct inode *inode, struct file *filp,
+			  unsigned int cmd, unsigned long arg);
+extern int drm_agp_bind(struct inode *inode, struct file *filp,
+			unsigned int cmd, unsigned long arg);
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,11)
+extern DRM_AGP_MEM *drm_agp_allocate_memory(size_t pages, u32 type);
+#else
+extern DRM_AGP_MEM *drm_agp_allocate_memory(struct agp_bridge_data *bridge, size_t pages, u32 type);
+#endif
+extern int drm_agp_free_memory(DRM_AGP_MEM * handle);
+extern int drm_agp_bind_memory(DRM_AGP_MEM * handle, off_t start);
+extern int drm_agp_unbind_memory(DRM_AGP_MEM * handle);
 
 				/* Stub support (drm_stub.h) */
 extern int drm_get_dev(struct pci_dev *pdev, const struct pci_device_id *ent,
 		     struct drm_driver *driver);
 extern int drm_put_dev(drm_device_t * dev);
-extern int drm_get_head(drm_device_t * dev, drm_head_t *head);
 extern int drm_put_head(drm_head_t * head);
-extern unsigned int   drm_debug;
-extern unsigned int   drm_cards_limit;
+extern unsigned int drm_debug; /* 1 to enable debug output */
+extern unsigned int cards_limit;
 extern drm_head_t **drm_heads;
 extern struct drm_sysfs_class *drm_class;
 extern struct proc_dir_entry *drm_proc_root;
 
 				/* Proc support (drm_proc.h) */
-extern int            drm_proc_init(drm_device_t *dev,
-					     int minor,
-					     struct proc_dir_entry *root,
-					     struct proc_dir_entry **dev_root);
-extern int            drm_proc_cleanup(int minor,
-					struct proc_dir_entry *root,
-					struct proc_dir_entry *dev_root);
+extern int drm_proc_init(drm_device_t * dev,
+			 int minor,
+			 struct proc_dir_entry *root,
+			 struct proc_dir_entry **dev_root);
+extern int drm_proc_cleanup(int minor,
+			    struct proc_dir_entry *root,
+			    struct proc_dir_entry *dev_root);
 
 				/* Scatter Gather Support (drm_scatter.h) */
-extern void           drm_sg_cleanup(drm_sg_mem_t *entry);
-extern int            drm_sg_alloc(struct inode *inode, struct file *filp,
-				    unsigned int cmd, unsigned long arg);
-extern int            drm_sg_free(struct inode *inode, struct file *filp,
-				   unsigned int cmd, unsigned long arg);
-
-                               /* ATI PCIGART support (ati_pcigart.h) */
-extern int            drm_ati_pcigart_init(drm_device_t *dev,
-					    unsigned long *addr,
-					    dma_addr_t *bus_addr);
-extern int            drm_ati_pcigart_cleanup(drm_device_t *dev,
-					       unsigned long addr,
-					       dma_addr_t bus_addr);
-
-extern void *drm_pci_alloc(drm_device_t * dev, size_t size,
-			   size_t align, dma_addr_t maxaddr,
-			   dma_addr_t * busaddr);
-
-extern void drm_pci_free(drm_device_t * dev, size_t size,
-			 void *vaddr, dma_addr_t busaddr);
+extern void drm_sg_cleanup(drm_sg_mem_t * entry);
+extern int drm_sg_alloc(struct inode *inode, struct file *filp,
+			unsigned int cmd, unsigned long arg);
+extern int drm_sg_free(struct inode *inode, struct file *filp,
+		       unsigned int cmd, unsigned long arg);
+
+			       /* ATI PCIGART support (ati_pcigart.h) */
+extern int drm_ati_pcigart_init(drm_device_t * dev,
+				unsigned long *addr, dma_addr_t * bus_addr);
+extern int drm_ati_pcigart_cleanup(drm_device_t * dev,
+				   unsigned long addr, dma_addr_t bus_addr);
+
+extern drm_dma_handle_t *drm_pci_alloc(drm_device_t * dev, size_t size,
+			   size_t align, dma_addr_t maxaddr);
+extern void __drm_pci_free(drm_device_t * dev, drm_dma_handle_t *dmah);
+extern void drm_pci_free(drm_device_t * dev, drm_dma_handle_t *dmah);
 
 			       /* sysfs support (drm_sysfs.c) */
 struct drm_sysfs_class;
@@ -1012,42 +988,56 @@ extern struct drm_sysfs_class *drm_sysfs
 						char *name);
 extern void drm_sysfs_destroy(struct drm_sysfs_class *cs);
 extern struct class_device *drm_sysfs_device_add(struct drm_sysfs_class *cs,
-						 dev_t dev,
-						 struct device *device,
-						 const char *fmt, ...);
-extern void drm_sysfs_device_remove(dev_t dev);
-
+						 drm_head_t * head);
+extern void drm_sysfs_device_remove(struct class_device *class_dev);
 
 /* Inline replacements for DRM_IOREMAP macros */
-static __inline__ void drm_core_ioremap(struct drm_map *map, struct drm_device *dev)
+static __inline__ void drm_core_ioremap(struct drm_map *map,
+					struct drm_device *dev)
 {
-	map->handle = drm_ioremap( map->offset, map->size, dev );
+	map->handle = drm_ioremap(map->offset, map->size, dev);
 }
 
-static __inline__ void drm_core_ioremap_nocache(struct drm_map *map, struct drm_device *dev)
+static __inline__ void drm_core_ioremap_nocache(struct drm_map *map,
+						struct drm_device *dev)
 {
 	map->handle = drm_ioremap_nocache(map->offset, map->size, dev);
 }
 
-static __inline__ void drm_core_ioremapfree(struct drm_map *map, struct drm_device *dev)
+static __inline__ void drm_core_ioremapfree(struct drm_map *map,
+					    struct drm_device *dev)
 {
-	if ( map->handle && map->size )
-		drm_ioremapfree( map->handle, map->size, dev );
+	if (map->handle && map->size)
+		drm_ioremapfree(map->handle, map->size, dev);
 }
 
-static __inline__ struct drm_map *drm_core_findmap(struct drm_device *dev, unsigned long offset)
+static __inline__ struct drm_map *drm_core_findmap(struct drm_device *dev,
+						   unsigned long offset)
 {
 	struct list_head *_list;
-	list_for_each( _list, &dev->maplist->head ) {
-		drm_map_list_t *_entry = list_entry( _list, drm_map_list_t, head );
-		if ( _entry->map &&
-		     _entry->map->offset == offset ) {
+	list_for_each(_list, &dev->maplist->head) {
+		drm_map_list_t *_entry =
+		    list_entry(_list, drm_map_list_t, head);
+		if (_entry->map && _entry->map->offset == offset) {
 			return _entry->map;
 		}
 	}
 	return NULL;
 }
 
+static __inline__ int drm_device_is_agp(drm_device_t *dev)
+{
+	if ( dev->driver->device_is_agp != NULL ) {
+		int err = (*dev->driver->device_is_agp)( dev );
+	
+		if (err != 2) {
+			return err;
+		}
+	}
+
+	return pci_find_capability(dev->pdev, PCI_CAP_ID_AGP);
+}
+
 static __inline__ void drm_core_dropmap(struct drm_map *map)
 {
 }
@@ -1071,8 +1061,5 @@ extern void drm_free(void *pt, size_t si
 
 /*@}*/
 
-extern unsigned long drm_core_get_map_ofs(drm_map_t *map);
-extern unsigned long drm_core_get_reg_ofs(struct drm_device *dev);
-
-#endif /* __KERNEL__ */
+#endif				/* __KERNEL__ */
 #endif
diff -purN linux-2.6.12.orig/drivers/char/drm/drm_proc.c linux-2.6.12/drivers/char/drm/drm_proc.c
--- linux-2.6.12.orig/drivers/char/drm/drm_proc.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/drm_proc.c	2005-07-05 08:37:27.000000000 +0200
@@ -1,5 +1,5 @@
 /**
- * \file drm_proc.h 
+ * \file drm_proc.c
  * /proc support for DRM
  *
  * \author Rickard E. (Rik) Faith <faith@valinux.com>
@@ -39,38 +39,39 @@
 
 #include "drmP.h"
 
-static int	   drm_name_info(char *buf, char **start, off_t offset,
-				  int request, int *eof, void *data);
-static int	   drm_vm_info(char *buf, char **start, off_t offset,
-				int request, int *eof, void *data);
-static int	   drm_clients_info(char *buf, char **start, off_t offset,
-				     int request, int *eof, void *data);
-static int	   drm_queues_info(char *buf, char **start, off_t offset,
-				    int request, int *eof, void *data);
-static int	   drm_bufs_info(char *buf, char **start, off_t offset,
-				  int request, int *eof, void *data);
+static int drm_name_info(char *buf, char **start, off_t offset,
+			 int request, int *eof, void *data);
+static int drm_vm_info(char *buf, char **start, off_t offset,
+		       int request, int *eof, void *data);
+static int drm_clients_info(char *buf, char **start, off_t offset,
+			    int request, int *eof, void *data);
+static int drm_queues_info(char *buf, char **start, off_t offset,
+			   int request, int *eof, void *data);
+static int drm_bufs_info(char *buf, char **start, off_t offset,
+			 int request, int *eof, void *data);
 #if DRM_DEBUG_CODE
-static int	   drm_vma_info(char *buf, char **start, off_t offset,
-				 int request, int *eof, void *data);
+static int drm_vma_info(char *buf, char **start, off_t offset,
+			int request, int *eof, void *data);
 #endif
 
 /**
  * Proc file list.
  */
-struct drm_proc_list {
+static struct drm_proc_list {
 	const char *name;	/**< file name */
-	int	   (*f)(char *, char **, off_t, int, int *, void *);	/**< proc callback*/
+	int (*f) (char *, char **, off_t, int, int *, void *);		/**< proc callback*/
 } drm_proc_list[] = {
-	{ "name",    drm_name_info    },
-	{ "mem",     drm_mem_info     },
-	{ "vm",	     drm_vm_info      },
-	{ "clients", drm_clients_info },
-	{ "queues",  drm_queues_info  },
-	{ "bufs",    drm_bufs_info    },
+	{"name", drm_name_info},
+	{"mem", drm_mem_info},
+	{"vm", drm_vm_info},
+	{"clients", drm_clients_info},
+	{"queues", drm_queues_info},
+	{"bufs", drm_bufs_info},
 #if DRM_DEBUG_CODE
-	{ "vma",     drm_vma_info     },
+	{"vma", drm_vma_info},
 #endif
 };
+
 #define DRM_PROC_ENTRIES (sizeof(drm_proc_list)/sizeof(drm_proc_list[0]))
 
 /**
@@ -81,18 +82,17 @@ struct drm_proc_list {
  * \param root DRI proc dir entry.
  * \param dev_root resulting DRI device proc dir entry.
  * \return root entry pointer on success, or NULL on failure.
- * 
+ *
  * Create the DRI proc root entry "/proc/dri", the device proc root entry
  * "/proc/dri/%minor%/", and each entry in proc_list as
  * "/proc/dri/%minor%/%name%".
  */
-int drm_proc_init(drm_device_t *dev, int minor,
-		    struct proc_dir_entry *root,
-		    struct proc_dir_entry **dev_root)
+int drm_proc_init(drm_device_t * dev, int minor,
+		  struct proc_dir_entry *root, struct proc_dir_entry **dev_root)
 {
 	struct proc_dir_entry *ent;
-	int		      i, j;
-	char                  name[64];
+	int i, j;
+	char name[64];
 
 	sprintf(name, "%d", minor);
 	*dev_root = create_proc_entry(name, S_IFDIR, root);
@@ -103,7 +103,7 @@ int drm_proc_init(drm_device_t *dev, int
 
 	for (i = 0; i < DRM_PROC_ENTRIES; i++) {
 		ent = create_proc_entry(drm_proc_list[i].name,
-					S_IFREG|S_IRUGO, *dev_root);
+					S_IFREG | S_IRUGO, *dev_root);
 		if (!ent) {
 			DRM_ERROR("Cannot create /proc/dri/%s/%s\n",
 				  name, drm_proc_list[i].name);
@@ -114,13 +114,11 @@ int drm_proc_init(drm_device_t *dev, int
 			return -1;
 		}
 		ent->read_proc = drm_proc_list[i].f;
-		ent->data      = dev;
+		ent->data = dev;
 	}
-
 	return 0;
 }
 
-
 /**
  * Cleanup the proc filesystem resources.
  *
@@ -132,12 +130,13 @@ int drm_proc_init(drm_device_t *dev, int
  * Remove all proc entries created by proc_init().
  */
 int drm_proc_cleanup(int minor, struct proc_dir_entry *root,
-		      struct proc_dir_entry *dev_root)
+		     struct proc_dir_entry *dev_root)
 {
-	int  i;
+	int i;
 	char name[64];
 
-	if (!root || !dev_root) return 0;
+	if (!root || !dev_root)
+		return 0;
 
 	for (i = 0; i < DRM_PROC_ENTRIES; i++)
 		remove_proc_entry(drm_proc_list[i].name, dev_root);
@@ -149,7 +148,7 @@ int drm_proc_cleanup(int minor, struct p
 
 /**
  * Called when "/proc/dri/.../name" is read.
- * 
+ *
  * \param buf output buffer.
  * \param start start of output data.
  * \param offset requested start offset.
@@ -157,14 +156,14 @@ int drm_proc_cleanup(int minor, struct p
  * \param eof whether there is no more data to return.
  * \param data private data.
  * \return number of written bytes.
- * 
+ *
  * Prints the device name together with the bus id if available.
  */
 static int drm_name_info(char *buf, char **start, off_t offset, int request,
-			  int *eof, void *data)
+			 int *eof, void *data)
 {
-	drm_device_t *dev = (drm_device_t *)data;
-	int          len  = 0;
+	drm_device_t *dev = (drm_device_t *) data;
+	int len = 0;
 
 	if (offset > DRM_PROC_LIMIT) {
 		*eof = 1;
@@ -172,23 +171,26 @@ static int drm_name_info(char *buf, char
 	}
 
 	*start = &buf[offset];
-	*eof   = 0;
+	*eof = 0;
 
 	if (dev->unique) {
 		DRM_PROC_PRINT("%s %s %s\n",
-			       dev->driver->pci_driver.name, pci_name(dev->pdev), dev->unique);
+			       dev->driver->pci_driver.name, pci_name(dev->pdev),
+			       dev->unique);
 	} else {
-		DRM_PROC_PRINT("%s %s\n", dev->driver->pci_driver.name, pci_name(dev->pdev));
+		DRM_PROC_PRINT("%s %s\n", dev->driver->pci_driver.name,
+			       pci_name(dev->pdev));
 	}
 
-	if (len > request + offset) return request;
+	if (len > request + offset)
+		return request;
 	*eof = 1;
 	return len - offset;
 }
 
 /**
  * Called when "/proc/dri/.../vm" is read.
- * 
+ *
  * \param buf output buffer.
  * \param start start of output data.
  * \param offset requested start offset.
@@ -196,24 +198,24 @@ static int drm_name_info(char *buf, char
  * \param eof whether there is no more data to return.
  * \param data private data.
  * \return number of written bytes.
- * 
+ *
  * Prints information about all mappings in drm_device::maplist.
  */
 static int drm__vm_info(char *buf, char **start, off_t offset, int request,
-			 int *eof, void *data)
+			int *eof, void *data)
 {
-	drm_device_t *dev = (drm_device_t *)data;
-	int          len  = 0;
-	drm_map_t    *map;
+	drm_device_t *dev = (drm_device_t *) data;
+	int len = 0;
+	drm_map_t *map;
 	drm_map_list_t *r_list;
 	struct list_head *list;
 
-				/* Hardcoded from _DRM_FRAME_BUFFER,
-                                   _DRM_REGISTERS, _DRM_SHM, _DRM_AGP, and
-                                   _DRM_SCATTER_GATHER. */
-	const char   *types[] = { "FB", "REG", "SHM", "AGP", "SG" };
-	const char   *type;
-	int	     i;
+	/* Hardcoded from _DRM_FRAME_BUFFER,
+	   _DRM_REGISTERS, _DRM_SHM, _DRM_AGP,
+	   _DRM_SCATTER_GATHER, and _DRM_CONSISTENT. */
+	const char *types[] = { "FB", "REG", "SHM", "AGP", "SG", "PCI" };
+	const char *type;
+	int i;
 
 	if (offset > DRM_PROC_LIMIT) {
 		*eof = 1;
@@ -221,33 +223,36 @@ static int drm__vm_info(char *buf, char 
 	}
 
 	*start = &buf[offset];
-	*eof   = 0;
+	*eof = 0;
 
 	DRM_PROC_PRINT("slot	 offset	      size type flags	 "
 		       "address mtrr\n\n");
 	i = 0;
-	if (dev->maplist != NULL) list_for_each(list, &dev->maplist->head) {
+	if (dev->maplist != NULL)
+		list_for_each(list, &dev->maplist->head) {
 		r_list = list_entry(list, drm_map_list_t, head);
 		map = r_list->map;
-		if(!map) continue;
-		if (map->type < 0 || map->type > 4) type = "??";
-		else				    type = types[map->type];
+		if (!map)
+			continue;
+		if (map->type < 0 || map->type > 5)
+			type = "??";
+		else
+			type = types[map->type];
 		DRM_PROC_PRINT("%4d 0x%08lx 0x%08lx %4.4s  0x%02x 0x%08lx ",
 			       i,
 			       map->offset,
 			       map->size,
-			       type,
-			       map->flags,
-			       (unsigned long)map->handle);
+			       type, map->flags, (unsigned long)map->handle);
 		if (map->mtrr < 0) {
 			DRM_PROC_PRINT("none\n");
 		} else {
 			DRM_PROC_PRINT("%4d\n", map->mtrr);
 		}
 		i++;
-	}
+		}
 
-	if (len > request + offset) return request;
+	if (len > request + offset)
+		return request;
 	*eof = 1;
 	return len - offset;
 }
@@ -256,10 +261,10 @@ static int drm__vm_info(char *buf, char 
  * Simply calls _vm_info() while holding the drm_device::struct_sem lock.
  */
 static int drm_vm_info(char *buf, char **start, off_t offset, int request,
-			int *eof, void *data)
+		       int *eof, void *data)
 {
-	drm_device_t *dev = (drm_device_t *)data;
-	int	     ret;
+	drm_device_t *dev = (drm_device_t *) data;
+	int ret;
 
 	down(&dev->struct_sem);
 	ret = drm__vm_info(buf, start, offset, request, eof, data);
@@ -269,7 +274,7 @@ static int drm_vm_info(char *buf, char *
 
 /**
  * Called when "/proc/dri/.../queues" is read.
- * 
+ *
  * \param buf output buffer.
  * \param start start of output data.
  * \param offset requested start offset.
@@ -279,12 +284,12 @@ static int drm_vm_info(char *buf, char *
  * \return number of written bytes.
  */
 static int drm__queues_info(char *buf, char **start, off_t offset,
-			     int request, int *eof, void *data)
+			    int request, int *eof, void *data)
 {
-	drm_device_t *dev = (drm_device_t *)data;
-	int          len  = 0;
-	int	     i;
-	drm_queue_t  *q;
+	drm_device_t *dev = (drm_device_t *) data;
+	int len = 0;
+	int i;
+	drm_queue_t *q;
 
 	if (offset > DRM_PROC_LIMIT) {
 		*eof = 1;
@@ -292,7 +297,7 @@ static int drm__queues_info(char *buf, c
 	}
 
 	*start = &buf[offset];
-	*eof   = 0;
+	*eof = 0;
 
 	DRM_PROC_PRINT("  ctx/flags   use   fin"
 		       "   blk/rw/rwf  wait    flushed	   queued"
@@ -310,14 +315,17 @@ static int drm__queues_info(char *buf, c
 				   atomic_read(&q->block_count),
 				   atomic_read(&q->block_read) ? 'r' : '-',
 				   atomic_read(&q->block_write) ? 'w' : '-',
-				   waitqueue_active(&q->read_queue) ? 'r':'-',
-				   waitqueue_active(&q->write_queue) ? 'w':'-',
-				   waitqueue_active(&q->flush_queue) ? 'f':'-',
+				   waitqueue_active(&q->read_queue) ? 'r' : '-',
+				   waitqueue_active(&q->
+						    write_queue) ? 'w' : '-',
+				   waitqueue_active(&q->
+						    flush_queue) ? 'f' : '-',
 				   DRM_BUFCOUNT(&q->waitlist));
 		atomic_dec(&q->use_count);
 	}
 
-	if (len > request + offset) return request;
+	if (len > request + offset)
+		return request;
 	*eof = 1;
 	return len - offset;
 }
@@ -326,10 +334,10 @@ static int drm__queues_info(char *buf, c
  * Simply calls _queues_info() while holding the drm_device::struct_sem lock.
  */
 static int drm_queues_info(char *buf, char **start, off_t offset, int request,
-			    int *eof, void *data)
+			   int *eof, void *data)
 {
-	drm_device_t *dev = (drm_device_t *)data;
-	int	     ret;
+	drm_device_t *dev = (drm_device_t *) data;
+	int ret;
 
 	down(&dev->struct_sem);
 	ret = drm__queues_info(buf, start, offset, request, eof, data);
@@ -339,7 +347,7 @@ static int drm_queues_info(char *buf, ch
 
 /**
  * Called when "/proc/dri/.../bufs" is read.
- * 
+ *
  * \param buf output buffer.
  * \param start start of output data.
  * \param offset requested start offset.
@@ -349,12 +357,12 @@ static int drm_queues_info(char *buf, ch
  * \return number of written bytes.
  */
 static int drm__bufs_info(char *buf, char **start, off_t offset, int request,
-			   int *eof, void *data)
+			  int *eof, void *data)
 {
-	drm_device_t	 *dev = (drm_device_t *)data;
-	int              len  = 0;
+	drm_device_t *dev = (drm_device_t *) data;
+	int len = 0;
 	drm_device_dma_t *dma = dev->dma;
-	int		 i;
+	int i;
 
 	if (!dma || offset > DRM_PROC_LIMIT) {
 		*eof = 1;
@@ -362,7 +370,7 @@ static int drm__bufs_info(char *buf, cha
 	}
 
 	*start = &buf[offset];
-	*eof   = 0;
+	*eof = 0;
 
 	DRM_PROC_PRINT(" o     size count  free	 segs pages    kB\n\n");
 	for (i = 0; i <= DRM_MAX_ORDER; i++) {
@@ -375,19 +383,21 @@ static int drm__bufs_info(char *buf, cha
 						   .freelist.count),
 				       dma->bufs[i].seg_count,
 				       dma->bufs[i].seg_count
-				       *(1 << dma->bufs[i].page_order),
+				       * (1 << dma->bufs[i].page_order),
 				       (dma->bufs[i].seg_count
 					* (1 << dma->bufs[i].page_order))
 				       * PAGE_SIZE / 1024);
 	}
 	DRM_PROC_PRINT("\n");
 	for (i = 0; i < dma->buf_count; i++) {
-		if (i && !(i%32)) DRM_PROC_PRINT("\n");
+		if (i && !(i % 32))
+			DRM_PROC_PRINT("\n");
 		DRM_PROC_PRINT(" %d", dma->buflist[i]->list);
 	}
 	DRM_PROC_PRINT("\n");
 
-	if (len > request + offset) return request;
+	if (len > request + offset)
+		return request;
 	*eof = 1;
 	return len - offset;
 }
@@ -396,10 +406,10 @@ static int drm__bufs_info(char *buf, cha
  * Simply calls _bufs_info() while holding the drm_device::struct_sem lock.
  */
 static int drm_bufs_info(char *buf, char **start, off_t offset, int request,
-			  int *eof, void *data)
+			 int *eof, void *data)
 {
-	drm_device_t *dev = (drm_device_t *)data;
-	int	     ret;
+	drm_device_t *dev = (drm_device_t *) data;
+	int ret;
 
 	down(&dev->struct_sem);
 	ret = drm__bufs_info(buf, start, offset, request, eof, data);
@@ -409,7 +419,7 @@ static int drm_bufs_info(char *buf, char
 
 /**
  * Called when "/proc/dri/.../clients" is read.
- * 
+ *
  * \param buf output buffer.
  * \param start start of output data.
  * \param offset requested start offset.
@@ -419,11 +429,11 @@ static int drm_bufs_info(char *buf, char
  * \return number of written bytes.
  */
 static int drm__clients_info(char *buf, char **start, off_t offset,
-			      int request, int *eof, void *data)
+			     int request, int *eof, void *data)
 {
-	drm_device_t *dev = (drm_device_t *)data;
-	int          len  = 0;
-	drm_file_t   *priv;
+	drm_device_t *dev = (drm_device_t *) data;
+	int len = 0;
+	drm_file_t *priv;
 
 	if (offset > DRM_PROC_LIMIT) {
 		*eof = 1;
@@ -431,7 +441,7 @@ static int drm__clients_info(char *buf, 
 	}
 
 	*start = &buf[offset];
-	*eof   = 0;
+	*eof = 0;
 
 	DRM_PROC_PRINT("a dev	pid    uid	magic	  ioctls\n\n");
 	for (priv = dev->file_first; priv; priv = priv->next) {
@@ -439,12 +449,11 @@ static int drm__clients_info(char *buf, 
 			       priv->authenticated ? 'y' : 'n',
 			       priv->minor,
 			       priv->pid,
-			       priv->uid,
-			       priv->magic,
-			       priv->ioctl_count);
+			       priv->uid, priv->magic, priv->ioctl_count);
 	}
 
-	if (len > request + offset) return request;
+	if (len > request + offset)
+		return request;
 	*eof = 1;
 	return len - offset;
 }
@@ -453,10 +462,10 @@ static int drm__clients_info(char *buf, 
  * Simply calls _clients_info() while holding the drm_device::struct_sem lock.
  */
 static int drm_clients_info(char *buf, char **start, off_t offset,
-			     int request, int *eof, void *data)
+			    int request, int *eof, void *data)
 {
-	drm_device_t *dev = (drm_device_t *)data;
-	int	     ret;
+	drm_device_t *dev = (drm_device_t *) data;
+	int ret;
 
 	down(&dev->struct_sem);
 	ret = drm__clients_info(buf, start, offset, request, eof, data);
@@ -467,14 +476,14 @@ static int drm_clients_info(char *buf, c
 #if DRM_DEBUG_CODE
 
 static int drm__vma_info(char *buf, char **start, off_t offset, int request,
-			  int *eof, void *data)
+			 int *eof, void *data)
 {
-	drm_device_t	      *dev = (drm_device_t *)data;
-	int                   len  = 0;
-	drm_vma_entry_t	      *pt;
+	drm_device_t *dev = (drm_device_t *) data;
+	int len = 0;
+	drm_vma_entry_t *pt;
 	struct vm_area_struct *vma;
 #if defined(__i386__)
-	unsigned int	      pgprot;
+	unsigned int pgprot;
 #endif
 
 	if (offset > DRM_PROC_LIMIT) {
@@ -483,51 +492,53 @@ static int drm__vma_info(char *buf, char
 	}
 
 	*start = &buf[offset];
-	*eof   = 0;
+	*eof = 0;
 
 	DRM_PROC_PRINT("vma use count: %d, high_memory = %p, 0x%08lx\n",
 		       atomic_read(&dev->vma_count),
 		       high_memory, virt_to_phys(high_memory));
 	for (pt = dev->vmalist; pt; pt = pt->next) {
-		if (!(vma = pt->vma)) continue;
+		if (!(vma = pt->vma))
+			continue;
 		DRM_PROC_PRINT("\n%5d 0x%08lx-0x%08lx %c%c%c%c%c%c 0x%08lx",
 			       pt->pid,
 			       vma->vm_start,
 			       vma->vm_end,
-			       vma->vm_flags & VM_READ	   ? 'r' : '-',
-			       vma->vm_flags & VM_WRITE	   ? 'w' : '-',
-			       vma->vm_flags & VM_EXEC	   ? 'x' : '-',
+			       vma->vm_flags & VM_READ ? 'r' : '-',
+			       vma->vm_flags & VM_WRITE ? 'w' : '-',
+			       vma->vm_flags & VM_EXEC ? 'x' : '-',
 			       vma->vm_flags & VM_MAYSHARE ? 's' : 'p',
-			       vma->vm_flags & VM_LOCKED   ? 'l' : '-',
-			       vma->vm_flags & VM_IO	   ? 'i' : '-',
+			       vma->vm_flags & VM_LOCKED ? 'l' : '-',
+			       vma->vm_flags & VM_IO ? 'i' : '-',
 			       VM_OFFSET(vma));
 
 #if defined(__i386__)
 		pgprot = pgprot_val(vma->vm_page_prot);
 		DRM_PROC_PRINT(" %c%c%c%c%c%c%c%c%c",
-			       pgprot & _PAGE_PRESENT  ? 'p' : '-',
-			       pgprot & _PAGE_RW       ? 'w' : 'r',
-			       pgprot & _PAGE_USER     ? 'u' : 's',
-			       pgprot & _PAGE_PWT      ? 't' : 'b',
-			       pgprot & _PAGE_PCD      ? 'u' : 'c',
+			       pgprot & _PAGE_PRESENT ? 'p' : '-',
+			       pgprot & _PAGE_RW ? 'w' : 'r',
+			       pgprot & _PAGE_USER ? 'u' : 's',
+			       pgprot & _PAGE_PWT ? 't' : 'b',
+			       pgprot & _PAGE_PCD ? 'u' : 'c',
 			       pgprot & _PAGE_ACCESSED ? 'a' : '-',
-			       pgprot & _PAGE_DIRTY    ? 'd' : '-',
-			       pgprot & _PAGE_PSE      ? 'm' : 'k',
-			       pgprot & _PAGE_GLOBAL   ? 'g' : 'l' );
+			       pgprot & _PAGE_DIRTY ? 'd' : '-',
+			       pgprot & _PAGE_PSE ? 'm' : 'k',
+			       pgprot & _PAGE_GLOBAL ? 'g' : 'l');
 #endif
 		DRM_PROC_PRINT("\n");
 	}
 
-	if (len > request + offset) return request;
+	if (len > request + offset)
+		return request;
 	*eof = 1;
 	return len - offset;
 }
 
 static int drm_vma_info(char *buf, char **start, off_t offset, int request,
-			 int *eof, void *data)
+			int *eof, void *data)
 {
-	drm_device_t *dev = (drm_device_t *)data;
-	int	     ret;
+	drm_device_t *dev = (drm_device_t *) data;
+	int ret;
 
 	down(&dev->struct_sem);
 	ret = drm__vma_info(buf, start, offset, request, eof, data);
@@ -535,5 +546,3 @@ static int drm_vma_info(char *buf, char 
 	return ret;
 }
 #endif
-
-
diff -purN linux-2.6.12.orig/drivers/char/drm/drm_sarea.h linux-2.6.12/drivers/char/drm/drm_sarea.h
--- linux-2.6.12.orig/drivers/char/drm/drm_sarea.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/drm_sarea.h	2005-07-05 08:37:49.000000000 +0200
@@ -1,8 +1,8 @@
 /**
- * \file drm_sarea.h 
+ * \file drm_sarea.h
  * \brief SAREA definitions
  *
- * \author Michel Dnzer <michel@daenzer.net>
+ * \author Michel Dzer <michel@daenzer.net>
  */
 
 /*
@@ -38,7 +38,7 @@
 #if defined(__alpha__)
 #define SAREA_MAX                       0x2000
 #elif defined(__ia64__)
-#define SAREA_MAX                       0x10000         /* 64kB */
+#define SAREA_MAX                       0x10000	/* 64kB */
 #else
 /* Intel 830M driver needs at least 8k SAREA */
 #define SAREA_MAX                       0x2000
@@ -51,28 +51,28 @@
 
 /** SAREA drawable */
 typedef struct drm_sarea_drawable {
-    unsigned int	stamp;
-    unsigned int	flags;
+	unsigned int stamp;
+	unsigned int flags;
 } drm_sarea_drawable_t;
 
 /** SAREA frame */
 typedef struct drm_sarea_frame {
-    unsigned int        x;
-    unsigned int        y;
-    unsigned int        width;
-    unsigned int        height;
-    unsigned int        fullscreen;
+	unsigned int x;
+	unsigned int y;
+	unsigned int width;
+	unsigned int height;
+	unsigned int fullscreen;
 } drm_sarea_frame_t;
 
 /** SAREA */
 typedef struct drm_sarea {
     /** first thing is always the DRM locking structure */
-    drm_hw_lock_t		lock;
+	drm_hw_lock_t lock;
     /** \todo Use readers/writer lock for drm_sarea::drawable_lock */
-    drm_hw_lock_t		drawable_lock;
-    drm_sarea_drawable_t	drawableTable[SAREA_MAX_DRAWABLES];	/**< drawables */
-    drm_sarea_frame_t		frame;	/**< frame */
-    drm_context_t		dummy_context;
+	drm_hw_lock_t drawable_lock;
+	drm_sarea_drawable_t drawableTable[SAREA_MAX_DRAWABLES];	/**< drawables */
+	drm_sarea_frame_t frame;	/**< frame */
+	drm_context_t dummy_context;
 } drm_sarea_t;
 
-#endif	/* _DRM_SAREA_H_ */
+#endif				/* _DRM_SAREA_H_ */
diff -purN linux-2.6.12.orig/drivers/char/drm/drm_scatter.c linux-2.6.12/drivers/char/drm/drm_scatter.c
--- linux-2.6.12.orig/drivers/char/drm/drm_scatter.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/drm_scatter.c	2005-07-05 08:37:27.000000000 +0200
@@ -1,5 +1,5 @@
 /**
- * \file drm_scatter.h 
+ * \file drm_scatter.c
  * IOCTLs to manage scatter/gather memory
  *
  * \author Gareth Hughes <gareth@valinux.com>
@@ -33,36 +33,33 @@
 
 #include <linux/config.h>
 #include <linux/vmalloc.h>
+
 #include "drmP.h"
 
 #define DEBUG_SCATTER 0
 
-void drm_sg_cleanup( drm_sg_mem_t *entry )
+void drm_sg_cleanup(drm_sg_mem_t * entry)
 {
 	struct page *page;
 	int i;
 
-	for ( i = 0 ; i < entry->pages ; i++ ) {
+	for (i = 0; i < entry->pages; i++) {
 		page = entry->pagelist[i];
-		if ( page )
-			ClearPageReserved( page );
+		if (page)
+			ClearPageReserved(page);
 	}
 
-	vfree( entry->virtual );
+	vfree(entry->virtual);
 
-	drm_free( entry->busaddr,
-		   entry->pages * sizeof(*entry->busaddr),
-		   DRM_MEM_PAGES );
-	drm_free( entry->pagelist,
-		   entry->pages * sizeof(*entry->pagelist),
-		   DRM_MEM_PAGES );
-	drm_free( entry,
-		   sizeof(*entry),
-		   DRM_MEM_SGLISTS );
+	drm_free(entry->busaddr,
+		 entry->pages * sizeof(*entry->busaddr), DRM_MEM_PAGES);
+	drm_free(entry->pagelist,
+		 entry->pages * sizeof(*entry->pagelist), DRM_MEM_PAGES);
+	drm_free(entry, sizeof(*entry), DRM_MEM_SGLISTS);
 }
 
-int drm_sg_alloc( struct inode *inode, struct file *filp,
-		   unsigned int cmd, unsigned long arg )
+int drm_sg_alloc(struct inode *inode, struct file *filp,
+		 unsigned int cmd, unsigned long arg)
 {
 	drm_file_t *priv = filp->private_data;
 	drm_device_t *dev = priv->head->dev;
@@ -71,74 +68,69 @@ int drm_sg_alloc( struct inode *inode, s
 	drm_sg_mem_t *entry;
 	unsigned long pages, i, j;
 
-	DRM_DEBUG( "%s\n", __FUNCTION__ );
+	DRM_DEBUG("%s\n", __FUNCTION__);
 
 	if (!drm_core_check_feature(dev, DRIVER_SG))
 		return -EINVAL;
 
-	if ( dev->sg )
+	if (dev->sg)
 		return -EINVAL;
 
-	if ( copy_from_user( &request, argp, sizeof(request) ) )
+	if (copy_from_user(&request, argp, sizeof(request)))
 		return -EFAULT;
 
-	entry = drm_alloc( sizeof(*entry), DRM_MEM_SGLISTS );
-	if ( !entry )
+	entry = drm_alloc(sizeof(*entry), DRM_MEM_SGLISTS);
+	if (!entry)
 		return -ENOMEM;
 
-   	memset( entry, 0, sizeof(*entry) );
+	memset(entry, 0, sizeof(*entry));
 
 	pages = (request.size + PAGE_SIZE - 1) / PAGE_SIZE;
-	DRM_DEBUG( "sg size=%ld pages=%ld\n", request.size, pages );
+	DRM_DEBUG("sg size=%ld pages=%ld\n", request.size, pages);
 
 	entry->pages = pages;
-	entry->pagelist = drm_alloc( pages * sizeof(*entry->pagelist),
-				     DRM_MEM_PAGES );
-	if ( !entry->pagelist ) {
-		drm_free( entry, sizeof(*entry), DRM_MEM_SGLISTS );
+	entry->pagelist = drm_alloc(pages * sizeof(*entry->pagelist),
+				    DRM_MEM_PAGES);
+	if (!entry->pagelist) {
+		drm_free(entry, sizeof(*entry), DRM_MEM_SGLISTS);
 		return -ENOMEM;
 	}
 
 	memset(entry->pagelist, 0, pages * sizeof(*entry->pagelist));
 
-	entry->busaddr = drm_alloc( pages * sizeof(*entry->busaddr),
-				     DRM_MEM_PAGES );
-	if ( !entry->busaddr ) {
-		drm_free( entry->pagelist,
-			   entry->pages * sizeof(*entry->pagelist),
-			   DRM_MEM_PAGES );
-		drm_free( entry,
-			   sizeof(*entry),
-			   DRM_MEM_SGLISTS );
+	entry->busaddr = drm_alloc(pages * sizeof(*entry->busaddr),
+				   DRM_MEM_PAGES);
+	if (!entry->busaddr) {
+		drm_free(entry->pagelist,
+			 entry->pages * sizeof(*entry->pagelist),
+			 DRM_MEM_PAGES);
+		drm_free(entry, sizeof(*entry), DRM_MEM_SGLISTS);
 		return -ENOMEM;
 	}
-	memset( (void *)entry->busaddr, 0, pages * sizeof(*entry->busaddr) );
+	memset((void *)entry->busaddr, 0, pages * sizeof(*entry->busaddr));
 
-	entry->virtual = vmalloc_32( pages << PAGE_SHIFT );
-	if ( !entry->virtual ) {
-		drm_free( entry->busaddr,
-			   entry->pages * sizeof(*entry->busaddr),
-			   DRM_MEM_PAGES );
-		drm_free( entry->pagelist,
-			   entry->pages * sizeof(*entry->pagelist),
-			   DRM_MEM_PAGES );
-		drm_free( entry,
-			   sizeof(*entry),
-			   DRM_MEM_SGLISTS );
+	entry->virtual = vmalloc_32(pages << PAGE_SHIFT);
+	if (!entry->virtual) {
+		drm_free(entry->busaddr,
+			 entry->pages * sizeof(*entry->busaddr), DRM_MEM_PAGES);
+		drm_free(entry->pagelist,
+			 entry->pages * sizeof(*entry->pagelist),
+			 DRM_MEM_PAGES);
+		drm_free(entry, sizeof(*entry), DRM_MEM_SGLISTS);
 		return -ENOMEM;
 	}
 
 	/* This also forces the mapping of COW pages, so our page list
 	 * will be valid.  Please don't remove it...
 	 */
-	memset( entry->virtual, 0, pages << PAGE_SHIFT );
+	memset(entry->virtual, 0, pages << PAGE_SHIFT);
 
 	entry->handle = (unsigned long)entry->virtual;
 
-	DRM_DEBUG( "sg alloc handle  = %08lx\n", entry->handle );
-	DRM_DEBUG( "sg alloc virtual = %p\n", entry->virtual );
+	DRM_DEBUG("sg alloc handle  = %08lx\n", entry->handle);
+	DRM_DEBUG("sg alloc virtual = %p\n", entry->virtual);
 
-	for ( i = entry->handle, j = 0 ; j < pages ; i += PAGE_SIZE, j++ ) {
+	for (i = entry->handle, j = 0; j < pages; i += PAGE_SIZE, j++) {
 		entry->pagelist[j] = vmalloc_to_page((void *)i);
 		if (!entry->pagelist[j])
 			goto failed;
@@ -147,8 +139,8 @@ int drm_sg_alloc( struct inode *inode, s
 
 	request.handle = entry->handle;
 
-	if ( copy_to_user( argp, &request, sizeof(request) ) ) {
-		drm_sg_cleanup( entry );
+	if (copy_to_user(argp, &request, sizeof(request))) {
+		drm_sg_cleanup(entry);
 		return -EFAULT;
 	}
 
@@ -159,50 +151,50 @@ int drm_sg_alloc( struct inode *inode, s
 	 * versa.
 	 */
 	{
-	int error = 0;
+		int error = 0;
 
-	for ( i = 0 ; i < pages ; i++ ) {
-		unsigned long *tmp;
+		for (i = 0; i < pages; i++) {
+			unsigned long *tmp;
 
-		tmp = page_address( entry->pagelist[i] );
-		for ( j = 0 ;
-		      j < PAGE_SIZE / sizeof(unsigned long) ;
-		      j++, tmp++ ) {
-			*tmp = 0xcafebabe;
-		}
-		tmp = (unsigned long *)((u8 *)entry->virtual +
-					(PAGE_SIZE * i));
-		for( j = 0 ;
-		     j < PAGE_SIZE / sizeof(unsigned long) ;
-		     j++, tmp++ ) {
-			if ( *tmp != 0xcafebabe && error == 0 ) {
-				error = 1;
-				DRM_ERROR( "Scatter allocation error, "
-					   "pagelist does not match "
-					   "virtual mapping\n" );
+			tmp = page_address(entry->pagelist[i]);
+			for (j = 0;
+			     j < PAGE_SIZE / sizeof(unsigned long);
+			     j++, tmp++) {
+				*tmp = 0xcafebabe;
+			}
+			tmp = (unsigned long *)((u8 *) entry->virtual +
+						(PAGE_SIZE * i));
+			for (j = 0;
+			     j < PAGE_SIZE / sizeof(unsigned long);
+			     j++, tmp++) {
+				if (*tmp != 0xcafebabe && error == 0) {
+					error = 1;
+					DRM_ERROR("Scatter allocation error, "
+						  "pagelist does not match "
+						  "virtual mapping\n");
+				}
+			}
+			tmp = page_address(entry->pagelist[i]);
+			for (j = 0;
+			     j < PAGE_SIZE / sizeof(unsigned long);
+			     j++, tmp++) {
+				*tmp = 0;
 			}
 		}
-		tmp = page_address( entry->pagelist[i] );
-		for(j = 0 ;
-		    j < PAGE_SIZE / sizeof(unsigned long) ;
-		    j++, tmp++) {
-			*tmp = 0;
-		}
-	}
-	if (error == 0)
-		DRM_ERROR( "Scatter allocation matches pagelist\n" );
+		if (error == 0)
+			DRM_ERROR("Scatter allocation matches pagelist\n");
 	}
 #endif
 
 	return 0;
 
- failed:
-	drm_sg_cleanup( entry );
+      failed:
+	drm_sg_cleanup(entry);
 	return -ENOMEM;
 }
 
-int drm_sg_free( struct inode *inode, struct file *filp,
-		 unsigned int cmd, unsigned long arg )
+int drm_sg_free(struct inode *inode, struct file *filp,
+		unsigned int cmd, unsigned long arg)
 {
 	drm_file_t *priv = filp->private_data;
 	drm_device_t *dev = priv->head->dev;
@@ -212,20 +204,20 @@ int drm_sg_free( struct inode *inode, st
 	if (!drm_core_check_feature(dev, DRIVER_SG))
 		return -EINVAL;
 
-	if ( copy_from_user( &request,
-			     (drm_scatter_gather_t __user *)arg,
-			     sizeof(request) ) )
+	if (copy_from_user(&request,
+			   (drm_scatter_gather_t __user *) arg,
+			   sizeof(request)))
 		return -EFAULT;
 
 	entry = dev->sg;
 	dev->sg = NULL;
 
-	if ( !entry || entry->handle != request.handle )
+	if (!entry || entry->handle != request.handle)
 		return -EINVAL;
 
-	DRM_DEBUG( "sg free virtual  = %p\n", entry->virtual );
+	DRM_DEBUG("sg free virtual  = %p\n", entry->virtual);
 
-	drm_sg_cleanup( entry );
+	drm_sg_cleanup(entry);
 
 	return 0;
 }
diff -purN linux-2.6.12.orig/drivers/char/drm/drm_stub.c linux-2.6.12/drivers/char/drm/drm_stub.c
--- linux-2.6.12.orig/drivers/char/drm/drm_stub.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/drm_stub.c	2005-07-05 08:37:27.000000000 +0200
@@ -1,5 +1,5 @@
 /**
- * \file drm_stub.h
+ * \file drm_stub.c
  * Stub support
  *
  * \author Rickard E. (Rik) Faith <faith@valinux.com>
@@ -33,39 +33,42 @@
 
 #include <linux/module.h>
 #include <linux/moduleparam.h>
+
 #include "drmP.h"
 #include "drm_core.h"
 
-unsigned int drm_cards_limit = 16;	/* Enough for one machine */
+unsigned int cards_limit = 16;	/* Enough for one machine */
 unsigned int drm_debug = 0;		/* 1 to enable debug output */
 EXPORT_SYMBOL(drm_debug);
 
-MODULE_AUTHOR( CORE_AUTHOR );
-MODULE_DESCRIPTION( CORE_DESC );
+MODULE_AUTHOR(CORE_AUTHOR);
+MODULE_DESCRIPTION(CORE_DESC);
 MODULE_LICENSE("GPL and additional rights");
 MODULE_PARM_DESC(cards_limit, "Maximum number of graphics cards");
 MODULE_PARM_DESC(debug, "Enable debug output");
 
-module_param_named(cards_limit, drm_cards_limit, int, 0444);
-module_param_named(debug, drm_debug, int, 0666);
+module_param(cards_limit, int, S_IRUGO);
+module_param_named(debug, drm_debug, int, S_IRUGO|S_IWUGO);
 
 drm_head_t **drm_heads;
 struct drm_sysfs_class *drm_class;
 struct proc_dir_entry *drm_proc_root;
 
-static int drm_fill_in_dev(drm_device_t *dev, struct pci_dev *pdev, const struct pci_device_id *ent, struct drm_driver *driver)
+static int fill_in_dev(drm_device_t * dev, struct pci_dev *pdev,
+		       const struct pci_device_id *ent,
+		       struct drm_driver *driver)
 {
 	int retcode;
 
 	spin_lock_init(&dev->count_lock);
-	init_timer( &dev->timer );
-	sema_init( &dev->struct_sem, 1 );
-	sema_init( &dev->ctxlist_sem, 1 );
+	init_timer(&dev->timer);
+	sema_init(&dev->struct_sem, 1);
+	sema_init(&dev->ctxlist_sem, 1);
 
-	dev->pdev   = pdev;
+	dev->pdev = pdev;
 
 #ifdef __alpha__
-	dev->hose   = pdev->sysdata;
+	dev->hose = pdev->sysdata;
 	dev->pci_domain = dev->hose->bus->number;
 #else
 	dev->pci_domain = 0;
@@ -75,88 +78,115 @@ static int drm_fill_in_dev(drm_device_t 
 	dev->pci_func = PCI_FUNC(pdev->devfn);
 	dev->irq = pdev->irq;
 
-	/* the DRM has 6 basic counters */
+	dev->maplist = drm_calloc(1, sizeof(*dev->maplist), DRM_MEM_MAPS);
+	if (dev->maplist == NULL)
+		return -ENOMEM;
+	INIT_LIST_HEAD(&dev->maplist->head);
+
+	/* the DRM has 6 counters */
 	dev->counters = 6;
-	dev->types[0]  = _DRM_STAT_LOCK;
-	dev->types[1]  = _DRM_STAT_OPENS;
-	dev->types[2]  = _DRM_STAT_CLOSES;
-	dev->types[3]  = _DRM_STAT_IOCTLS;
-	dev->types[4]  = _DRM_STAT_LOCKS;
-	dev->types[5]  = _DRM_STAT_UNLOCKS;
+	dev->types[0] = _DRM_STAT_LOCK;
+	dev->types[1] = _DRM_STAT_OPENS;
+	dev->types[2] = _DRM_STAT_CLOSES;
+	dev->types[3] = _DRM_STAT_IOCTLS;
+	dev->types[4] = _DRM_STAT_LOCKS;
+	dev->types[5] = _DRM_STAT_UNLOCKS;
 
 	dev->driver = driver;
-	
+
 	if (dev->driver->preinit)
 		if ((retcode = dev->driver->preinit(dev, ent->driver_data)))
 			goto error_out_unreg;
 
 	if (drm_core_has_AGP(dev)) {
-		dev->agp = drm_agp_init(dev);
-		if (drm_core_check_feature(dev, DRIVER_REQUIRE_AGP) && (dev->agp == NULL)) {
-			DRM_ERROR( "Cannot initialize the agpgart module.\n" );
+		if (drm_device_is_agp(dev))
+			dev->agp = drm_agp_init(dev);
+		if (drm_core_check_feature(dev, DRIVER_REQUIRE_AGP)
+		    && (dev->agp == NULL)) {
+			DRM_ERROR("Cannot initialize the agpgart module.\n");
 			retcode = -EINVAL;
 			goto error_out_unreg;
 		}
+
 		if (drm_core_has_MTRR(dev)) {
 			if (dev->agp)
-				dev->agp->agp_mtrr = mtrr_add( dev->agp->agp_info.aper_base,
-							       dev->agp->agp_info.aper_size*1024*1024,
-							       MTRR_TYPE_WRCOMB,
-							       1 );
+				dev->agp->agp_mtrr =
+				    mtrr_add(dev->agp->agp_info.aper_base,
+					     dev->agp->agp_info.aper_size *
+					     1024 * 1024, MTRR_TYPE_WRCOMB, 1);
 		}
 	}
 
-	retcode = drm_ctxbitmap_init( dev );
-	if( retcode ) {
-		DRM_ERROR( "Cannot allocate memory for context bitmap.\n" );
+	retcode = drm_ctxbitmap_init(dev);
+	if (retcode) {
+		DRM_ERROR("Cannot allocate memory for context bitmap.\n");
 		goto error_out_unreg;
 	}
 
 	return 0;
-	
+
 error_out_unreg:
 	drm_takedown(dev);
 	return retcode;
 }
 
 /**
- * File \c open operation.
+ * Get a secondary minor number.
  *
- * \param inode device inode.
- * \param filp file pointer.
+ * \param dev device data structure
+ * \param sec-minor structure to hold the assigned minor
+ * \return negative number on failure.
  *
- * Puts the dev->fops corresponding to the device minor number into
- * \p filp, call the \c open method, and restore the file operations.
+ * Search an empty entry and initialize it to the given parameters, and
+ * create the proc init entry via proc_init(). This routines assigns
+ * minor numbers to secondary heads of multi-headed cards
  */
-int drm_stub_open(struct inode *inode, struct file *filp)
+static int drm_get_head(drm_device_t * dev, drm_head_t * head)
 {
-	drm_device_t *dev = NULL;
-	int minor = iminor(inode);
-	int err = -ENODEV;
-	struct file_operations *old_fops;
-	
+	drm_head_t **heads = drm_heads;
+	int ret;
+	int minor;
+
 	DRM_DEBUG("\n");
 
-	if (!((minor >= 0) && (minor < drm_cards_limit)))
-		return -ENODEV;
+	for (minor = 0; minor < cards_limit; minor++, heads++) {
+		if (!*heads) {
 
-	if (!drm_heads[minor])
-		return -ENODEV;
-	
-	if (!(dev = drm_heads[minor]->dev))
-		return -ENODEV;
-
-	old_fops = filp->f_op;
-	filp->f_op = fops_get(&dev->driver->fops);
-	if (filp->f_op->open && (err = filp->f_op->open(inode, filp))) {
-		fops_put(filp->f_op);
-		filp->f_op = fops_get(old_fops);
-	}
-	fops_put(old_fops);
+			*head = (drm_head_t) {
+				.dev = dev,
+				.device = MKDEV(DRM_MAJOR, minor),
+				.minor = minor,
+			};
+			if ((ret =
+			     drm_proc_init(dev, minor, drm_proc_root,
+					   &head->dev_root))) {
+				printk(KERN_ERR
+				       "DRM: Failed to initialize /proc/dri.\n");
+				goto err_g1;
+			}
 
-	return err;
-}
+			head->dev_class = drm_sysfs_device_add(drm_class, head);
+			if (IS_ERR(head->dev_class)) {
+				printk(KERN_ERR
+				       "DRM: Error sysfs_device_add.\n");
+				ret = PTR_ERR(head->dev_class);
+				goto err_g2;
+			}
+			*heads = head;
 
+			DRM_DEBUG("new minor assigned %d\n", minor);
+			return 0;
+		}
+	}
+	DRM_ERROR("out of minors\n");
+	return -ENOMEM;
+err_g2:
+	drm_proc_cleanup(minor, drm_proc_root, head->dev_root);
+err_g1:
+	*head = (drm_head_t) {
+		.dev = NULL};
+	return ret;
+}
 
 /**
  * Register.
@@ -181,10 +211,12 @@ int drm_get_dev(struct pci_dev *pdev, co
 	if (!dev)
 		return -ENOMEM;
 
-	pci_enable_device(pdev);
-
-	if ((ret = drm_fill_in_dev(dev, pdev, ent, driver))) {
-		printk(KERN_ERR "DRM: Fill_in_dev failed.\n");
+	if (!drm_fb_loaded) {
+		pci_set_drvdata(pdev, dev);
+		pci_request_regions(pdev, driver->pci_driver.name);
+		pci_enable_device(pdev);
+	}
+	if ((ret = fill_in_dev(dev, pdev, ent, driver))) {
 		goto err_g1;
 	}
 	if ((ret = drm_get_head(dev, &dev->primary)))
@@ -193,75 +225,24 @@ int drm_get_dev(struct pci_dev *pdev, co
 	/* postinit is a required function to display the signon banner */
 	/* drivers add secondary heads here if needed */
 	if ((ret = dev->driver->postinit(dev, ent->driver_data)))
-		goto err_g1;
+		goto err_g2;
 
 	return 0;
 
+err_g2:
+	drm_put_head(&dev->primary);
 err_g1:
+	if (!drm_fb_loaded) {
+		pci_set_drvdata(pdev, NULL);
+		pci_release_regions(pdev);
+		pci_disable_device(pdev);
+	}
 	drm_free(dev, sizeof(*dev), DRM_MEM_STUB);
+	printk(KERN_ERR "DRM: drm_get_dev failed.\n");
 	return ret;
 }
 EXPORT_SYMBOL(drm_get_dev);
 
-/**
- * Get a secondary minor number.
- *
- * \param dev device data structure
- * \param sec-minor structure to hold the assigned minor
- * \return negative number on failure.
- *
- * Search an empty entry and initialize it to the given parameters, and
- * create the proc init entry via proc_init(). This routines assigns
- * minor numbers to secondary heads of multi-headed cards
- */
-int drm_get_head(drm_device_t *dev, drm_head_t *head)
-{
-	drm_head_t **heads = drm_heads;
-	int ret;
-	int minor;
-
-	DRM_DEBUG("\n");
-
-	for (minor = 0; minor < drm_cards_limit; minor++, heads++) {
-		if (!*heads) {
-			
-			*head = (drm_head_t) {
-				.dev = dev,
-				.device = MKDEV(DRM_MAJOR, minor),
-				.minor = minor,
-			};
-			
-			if ((ret = drm_proc_init(dev, minor, drm_proc_root, &head->dev_root))) {
-				printk (KERN_ERR "DRM: Failed to initialize /proc/dri.\n");
-				goto err_g1;
-			}
-
-			
-			head->dev_class = drm_sysfs_device_add(drm_class,
-							       MKDEV(DRM_MAJOR,
-								     minor),
-							       &dev->pdev->dev,
-							       "card%d", minor);
-			if (IS_ERR(head->dev_class)) {
-				printk(KERN_ERR "DRM: Error sysfs_device_add.\n");
-				ret = PTR_ERR(head->dev_class);
-				goto err_g2;
-			}
-			*heads = head;
-
-			DRM_DEBUG("new minor assigned %d\n", minor);
-			return 0;
-		}
-	}
-	DRM_ERROR("out of minors\n");
-	return -ENOMEM;
-err_g2:
-	drm_proc_cleanup(minor, drm_proc_root, head->dev_root);
-err_g1:
-	*head = (drm_head_t) {.dev = NULL};
-	return ret;
-}
-		
 
 /**
  * Put a device minor number.
@@ -301,19 +282,17 @@ int drm_put_dev(drm_device_t * dev)
  * last minor released.
  *
  */
-int drm_put_head(drm_head_t *head)
+int drm_put_head(drm_head_t * head)
 {
 	int minor = head->minor;
-	
+
 	DRM_DEBUG("release secondary minor %d\n", minor);
-	
+
 	drm_proc_cleanup(minor, drm_proc_root, head->dev_root);
-	drm_sysfs_device_remove(MKDEV(DRM_MAJOR, head->minor));
-	
+	drm_sysfs_device_remove(head->dev_class);
+
 	*head = (drm_head_t){.dev = NULL};
 
 	drm_heads[minor] = NULL;
-	
 	return 0;
 }
-
diff -purN linux-2.6.12.orig/drivers/char/drm/drm_sysfs.c linux-2.6.12/drivers/char/drm/drm_sysfs.c
--- linux-2.6.12.orig/drivers/char/drm/drm_sysfs.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/drm_sysfs.c	2005-07-05 08:37:27.000000000 +0200
@@ -16,6 +16,7 @@
 #include <linux/kdev_t.h>
 #include <linux/err.h>
 
+#include "drmP.h"
 #include "drm_core.h"
 
 struct drm_sysfs_class {
@@ -25,15 +26,11 @@ struct drm_sysfs_class {
 #define to_drm_sysfs_class(d) container_of(d, struct drm_sysfs_class, class)
 
 struct simple_dev {
-	struct list_head node;
 	dev_t dev;
 	struct class_device class_dev;
 };
 #define to_simple_dev(d) container_of(d, struct simple_dev, class_dev)
 
-static LIST_HEAD(simple_dev_list);
-static DEFINE_SPINLOCK(simple_dev_list_lock);
-
 static void release_simple_dev(struct class_device *class_dev)
 {
 	struct simple_dev *s_dev = to_simple_dev(class_dev);
@@ -121,6 +118,18 @@ void drm_sysfs_destroy(struct drm_sysfs_
 	class_unregister(&cs->class);
 }
 
+static ssize_t show_dri(struct class_device *class_device, char *buf)
+{
+	drm_device_t * dev = ((drm_head_t *)class_get_devdata(class_device))->dev;
+	if (dev->driver->dri_library_name)
+		return dev->driver->dri_library_name(dev, buf);
+	return snprintf(buf, PAGE_SIZE, "%s\n", dev->driver->pci_driver.name);
+}
+
+static struct class_device_attribute class_device_attrs[] = {
+	__ATTR(dri_library_name, S_IRUGO, show_dri, NULL),
+};
+
 /**
  * drm_sysfs_device_add - adds a class device to sysfs for a character driver
  * @cs: pointer to the struct drm_sysfs_class that this device should be registered to.
@@ -135,13 +144,11 @@ void drm_sysfs_destroy(struct drm_sysfs_
  * Note: the struct drm_sysfs_class passed to this function must have previously been
  * created with a call to drm_sysfs_create().
  */
-struct class_device *drm_sysfs_device_add(struct drm_sysfs_class *cs, dev_t dev,
-					  struct device *device,
-					  const char *fmt, ...)
+struct class_device *drm_sysfs_device_add(
+			struct drm_sysfs_class *cs, drm_head_t * head)
 {
-	va_list args;
 	struct simple_dev *s_dev = NULL;
-	int retval;
+	int i, retval;
 
 	if ((cs == NULL) || (IS_ERR(cs))) {
 		retval = -ENODEV;
@@ -155,26 +162,24 @@ struct class_device *drm_sysfs_device_ad
 	}
 	memset(s_dev, 0x00, sizeof(*s_dev));
 
-	s_dev->dev = dev;
-	s_dev->class_dev.dev = device;
+	s_dev->dev = MKDEV(DRM_MAJOR, head->minor);
+	s_dev->class_dev.dev = DRM_PCI_DEV(head->dev->pdev);
 	s_dev->class_dev.class = &cs->class;
 
-	va_start(args, fmt);
-	vsnprintf(s_dev->class_dev.class_id, BUS_ID_SIZE, fmt, args);
-	va_end(args);
+	snprintf(s_dev->class_dev.class_id, BUS_ID_SIZE, "card%d", head->minor);
 	retval = class_device_register(&s_dev->class_dev);
 	if (retval)
 		goto error;
 
 	class_device_create_file(&s_dev->class_dev, &cs->attr);
+	class_set_devdata(&s_dev->class_dev, head);
 
-	spin_lock(&simple_dev_list_lock);
-	list_add(&s_dev->node, &simple_dev_list);
-	spin_unlock(&simple_dev_list_lock);
+	for (i = 0; i < ARRAY_SIZE(class_device_attrs); i++)
+		class_device_create_file(&s_dev->class_dev, &class_device_attrs[i]);
 
 	return &s_dev->class_dev;
 
-      error:
+error:
 	kfree(s_dev);
 	return ERR_PTR(retval);
 }
@@ -186,23 +191,13 @@ struct class_device *drm_sysfs_device_ad
  * This call unregisters and cleans up a class device that was created with a
  * call to drm_sysfs_device_add()
  */
-void drm_sysfs_device_remove(dev_t dev)
+void drm_sysfs_device_remove(struct class_device *class_dev)
 {
-	struct simple_dev *s_dev = NULL;
-	int found = 0;
+	struct simple_dev *s_dev = to_simple_dev(class_dev);
+	int i;
 
-	spin_lock(&simple_dev_list_lock);
-	list_for_each_entry(s_dev, &simple_dev_list, node) {
-		if (s_dev->dev == dev) {
-			found = 1;
-			break;
-		}
-	}
-	if (found) {
-		list_del(&s_dev->node);
-		spin_unlock(&simple_dev_list_lock);
-		class_device_unregister(&s_dev->class_dev);
-	} else {
-		spin_unlock(&simple_dev_list_lock);
-	}
+	for (i = 0; i < ARRAY_SIZE(class_device_attrs); i++)
+		class_device_remove_file(&s_dev->class_dev, &class_device_attrs[i]);
+
+	class_device_unregister(&s_dev->class_dev);
 }
diff -purN linux-2.6.12.orig/drivers/char/drm/drm_vm.c linux-2.6.12/drivers/char/drm/drm_vm.c
--- linux-2.6.12.orig/drivers/char/drm/drm_vm.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/drm_vm.c	2005-07-05 08:37:27.000000000 +0200
@@ -1,7 +1,7 @@
 /**
- * \file drm_vm.h
+ * \file drm_vm.c
  * Memory mapping for DRM
- * 
+ *
  * \author Rickard E. (Rik) Faith <faith@valinux.com>
  * \author Gareth Hughes <gareth@valinux.com>
  */
@@ -38,6 +38,8 @@
 #include <linux/efi.h>
 #endif
 
+static void drm_vm_close(struct vm_area_struct *vma);
+static void drm_vm_open(struct vm_area_struct *vma);
 
 /**
  * \c nopage method for AGP virtual memory.
@@ -45,33 +47,36 @@
  * \param vma virtual memory area.
  * \param address access address.
  * \return pointer to the page structure.
- * 
+ *
  * Find the right map and if it's AGP memory find the real physical page to
  * map, get the page, increment the use count and return it.
  */
 #if __OS_HAS_AGP
 static __inline__ struct page *drm_do_vm_nopage(struct vm_area_struct *vma,
-						 unsigned long address)
+						unsigned long address)
 {
-	drm_file_t *priv  = vma->vm_file->private_data;
+	drm_file_t *priv = vma->vm_file->private_data;
 	drm_device_t *dev = priv->head->dev;
-	drm_map_t *map    = NULL;
-	drm_map_list_t  *r_list;
+	drm_map_t *map = NULL;
+	drm_map_list_t *r_list;
 	struct list_head *list;
 
 	/*
-         * Find the right map
-         */
+	 * Find the right map
+	 */
 	if (!drm_core_has_AGP(dev))
 		goto vm_nopage_error;
 
-	if(!dev->agp || !dev->agp->cant_use_aperture) goto vm_nopage_error;
+	if (!dev->agp || !dev->agp->cant_use_aperture)
+		goto vm_nopage_error;
 
 	list_for_each(list, &dev->maplist->head) {
 		r_list = list_entry(list, drm_map_list_t, head);
 		map = r_list->map;
-		if (!map) continue;
-		if (map->offset == VM_OFFSET(vma)) break;
+		if (!map)
+			continue;
+		if (map->offset == VM_OFFSET(vma))
+			break;
 	}
 
 	if (map && map->type == _DRM_AGP) {
@@ -82,45 +87,50 @@ static __inline__ struct page *drm_do_vm
 
 #ifdef __alpha__
 		/*
-                 * Adjust to a bus-relative address
-                 */
+		 * Adjust to a bus-relative address
+		 */
 		baddr -= dev->hose->mem_space->start;
 #endif
 
 		/*
-                 * It's AGP memory - find the real physical page to map
-                 */
-		for(agpmem = dev->agp->memory; agpmem; agpmem = agpmem->next) {
+		 * It's AGP memory - find the real physical page to map
+		 */
+		for (agpmem = dev->agp->memory; agpmem; agpmem = agpmem->next) {
 			if (agpmem->bound <= baddr &&
-			    agpmem->bound + agpmem->pages * PAGE_SIZE > baddr) 
+			    agpmem->bound + agpmem->pages * PAGE_SIZE > baddr)
 				break;
 		}
 
-		if (!agpmem) goto vm_nopage_error;
+		if (!agpmem)
+			goto vm_nopage_error;
 
 		/*
-                 * Get the page, inc the use count, and return it
-                 */
+		 * Get the page, inc the use count, and return it
+		 */
 		offset = (baddr - agpmem->bound) >> PAGE_SHIFT;
 		page = virt_to_page(__va(agpmem->memory->memory[offset]));
 		get_page(page);
 
-		DRM_DEBUG("baddr = 0x%lx page = 0x%p, offset = 0x%lx, count=%d\n",
-			  baddr, __va(agpmem->memory->memory[offset]), offset,
-			  page_count(page));
+#if 0
+		/* page_count() not defined everywhere */
+		DRM_DEBUG
+		    ("baddr = 0x%lx page = 0x%p, offset = 0x%lx, count=%d\n",
+		     baddr, __va(agpmem->memory->memory[offset]), offset,
+		     page_count(page));
+#endif
 
 		return page;
-        }
-vm_nopage_error:
-	return NOPAGE_SIGBUS;		/* Disallow mremap */
+	}
+      vm_nopage_error:
+	return NOPAGE_SIGBUS;	/* Disallow mremap */
 }
-#else /* __OS_HAS_AGP */
+#else				/* __OS_HAS_AGP */
 static __inline__ struct page *drm_do_vm_nopage(struct vm_area_struct *vma,
-						 unsigned long address)
+						unsigned long address)
 {
 	return NOPAGE_SIGBUS;
 }
-#endif /* __OS_HAS_AGP */
+#endif				/* __OS_HAS_AGP */
 
 /**
  * \c nopage method for shared virtual memory.
@@ -128,24 +138,27 @@ static __inline__ struct page *drm_do_vm
  * \param vma virtual memory area.
  * \param address access address.
  * \return pointer to the page structure.
- * 
+ *
  * Get the the mapping, find the real physical page to map, get the page, and
  * return it.
  */
 static __inline__ struct page *drm_do_vm_shm_nopage(struct vm_area_struct *vma,
-						     unsigned long address)
+						    unsigned long address)
 {
-	drm_map_t	 *map	 = (drm_map_t *)vma->vm_private_data;
-	unsigned long	 offset;
-	unsigned long	 i;
-	struct page	 *page;
+	drm_map_t *map = (drm_map_t *) vma->vm_private_data;
+	unsigned long offset;
+	unsigned long i;
+	struct page *page;
 
-	if (address > vma->vm_end) return NOPAGE_SIGBUS; /* Disallow mremap */
-	if (!map)    		   return NOPAGE_OOM;  /* Nothing allocated */
+	if (address > vma->vm_end)
+		return NOPAGE_SIGBUS;	/* Disallow mremap */
+	if (!map)
+		return NOPAGE_OOM;	/* Nothing allocated */
 
-	offset	 = address - vma->vm_start;
+	offset = address - vma->vm_start;
 	i = (unsigned long)map->handle + offset;
-	page = vmalloc_to_page((void *)i);
+	page = (map->type == _DRM_CONSISTENT) ?
+		virt_to_page((void *)i) : vmalloc_to_page((void *)i);
 	if (!page)
 		return NOPAGE_OOM;
 	get_page(page);
@@ -154,19 +167,18 @@ static __inline__ struct page *drm_do_vm
 	return page;
 }
 
-
 /**
  * \c close method for shared virtual memory.
- * 
+ *
  * \param vma virtual memory area.
- * 
+ *
  * Deletes map information if we are the last
  * person to close a mapping and it's not in the global maplist.
  */
-void drm_vm_shm_close(struct vm_area_struct *vma)
+static void drm_vm_shm_close(struct vm_area_struct *vma)
 {
-	drm_file_t	*priv	= vma->vm_file->private_data;
-	drm_device_t	*dev	= priv->head->dev;
+	drm_file_t *priv = vma->vm_file->private_data;
+	drm_device_t *dev = priv->head->dev;
 	drm_vma_entry_t *pt, *prev, *next;
 	drm_map_t *map;
 	drm_map_list_t *r_list;
@@ -182,7 +194,8 @@ void drm_vm_shm_close(struct vm_area_str
 	down(&dev->struct_sem);
 	for (pt = dev->vmalist, prev = NULL; pt; pt = next) {
 		next = pt->next;
-		if (pt->vma->vm_private_data == map) found_maps++;
+		if (pt->vma->vm_private_data == map)
+			found_maps++;
 		if (pt->vma == vma) {
 			if (prev) {
 				prev->next = pt->next;
@@ -195,8 +208,7 @@ void drm_vm_shm_close(struct vm_area_str
 		}
 	}
 	/* We were the only map that was found */
-	if(found_maps == 1 &&
-	   map->flags & _DRM_REMOVABLE) {
+	if (found_maps == 1 && map->flags & _DRM_REMOVABLE) {
 		/* Check to see if we are in the maplist, if we are not, then
 		 * we delete this mappings information.
 		 */
@@ -204,10 +216,13 @@ void drm_vm_shm_close(struct vm_area_str
 		list = &dev->maplist->head;
 		list_for_each(list, &dev->maplist->head) {
 			r_list = list_entry(list, drm_map_list_t, head);
-			if (r_list->map == map) found_maps++;
+			if (r_list->map == map)
+				found_maps++;
 		}
 
-		if(!found_maps) {
+		if (!found_maps) {
+			drm_dma_handle_t dmah;
+
 			switch (map->type) {
 			case _DRM_REGISTERS:
 			case _DRM_FRAME_BUFFER:
@@ -226,6 +241,12 @@ void drm_vm_shm_close(struct vm_area_str
 			case _DRM_AGP:
 			case _DRM_SCATTER_GATHER:
 				break;
+			case _DRM_CONSISTENT:
+				dmah.vaddr = map->handle;
+				dmah.busaddr = map->offset;
+				dmah.size = map->size;
+				__drm_pci_free(dev, &dmah);
+				break;
 			}
 			drm_free(map, sizeof(*map), DRM_MEM_MAPS);
 		}
@@ -239,27 +260,29 @@ void drm_vm_shm_close(struct vm_area_str
  * \param vma virtual memory area.
  * \param address access address.
  * \return pointer to the page structure.
- * 
+ *
  * Determine the page number from the page offset and get it from drm_device_dma::pagelist.
  */
 static __inline__ struct page *drm_do_vm_dma_nopage(struct vm_area_struct *vma,
-						     unsigned long address)
+						    unsigned long address)
 {
-	drm_file_t	 *priv	 = vma->vm_file->private_data;
-	drm_device_t	 *dev	 = priv->head->dev;
-	drm_device_dma_t *dma	 = dev->dma;
-	unsigned long	 offset;
-	unsigned long	 page_nr;
-	struct page	 *page;
-
-	if (!dma)		   return NOPAGE_SIGBUS; /* Error */
-	if (address > vma->vm_end) return NOPAGE_SIGBUS; /* Disallow mremap */
-	if (!dma->pagelist)	   return NOPAGE_OOM ; /* Nothing allocated */
-
-	offset	 = address - vma->vm_start; /* vm_[pg]off[set] should be 0 */
-	page_nr  = offset >> PAGE_SHIFT;
-	page = virt_to_page((dma->pagelist[page_nr] + 
-			     (offset & (~PAGE_MASK))));
+	drm_file_t *priv = vma->vm_file->private_data;
+	drm_device_t *dev = priv->head->dev;
+	drm_device_dma_t *dma = dev->dma;
+	unsigned long offset;
+	unsigned long page_nr;
+	struct page *page;
+
+	if (!dma)
+		return NOPAGE_SIGBUS;	/* Error */
+	if (address > vma->vm_end)
+		return NOPAGE_SIGBUS;	/* Disallow mremap */
+	if (!dma->pagelist)
+		return NOPAGE_OOM;	/* Nothing allocated */
+
+	offset = address - vma->vm_start;	/* vm_[pg]off[set] should be 0 */
+	page_nr = offset >> PAGE_SHIFT;
+	page = virt_to_page((dma->pagelist[page_nr] + (offset & (~PAGE_MASK))));
 
 	get_page(page);
 
@@ -273,13 +296,13 @@ static __inline__ struct page *drm_do_vm
  * \param vma virtual memory area.
  * \param address access address.
  * \return pointer to the page structure.
- * 
+ *
  * Determine the map offset from the page offset and get it from drm_sg_mem::pagelist.
  */
 static __inline__ struct page *drm_do_vm_sg_nopage(struct vm_area_struct *vma,
-						    unsigned long address)
+						   unsigned long address)
 {
-	drm_map_t        *map    = (drm_map_t *)vma->vm_private_data;
+	drm_map_t *map = (drm_map_t *) vma->vm_private_data;
 	drm_file_t *priv = vma->vm_file->private_data;
 	drm_device_t *dev = priv->head->dev;
 	drm_sg_mem_t *entry = dev->sg;
@@ -288,10 +311,12 @@ static __inline__ struct page *drm_do_vm
 	unsigned long page_offset;
 	struct page *page;
 
-	if (!entry)                return NOPAGE_SIGBUS; /* Error */
-	if (address > vma->vm_end) return NOPAGE_SIGBUS; /* Disallow mremap */
-	if (!entry->pagelist)      return NOPAGE_OOM ;  /* Nothing allocated */
-
+	if (!entry)
+		return NOPAGE_SIGBUS;	/* Error */
+	if (address > vma->vm_end)
+		return NOPAGE_SIGBUS;	/* Disallow mremap */
+	if (!entry->pagelist)
+		return NOPAGE_OOM;	/* Nothing allocated */
 
 	offset = address - vma->vm_start;
 	map_offset = map->offset - dev->sg->handle;
@@ -302,107 +327,108 @@ static __inline__ struct page *drm_do_vm
 	return page;
 }
 
-
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
 
 static struct page *drm_vm_nopage(struct vm_area_struct *vma,
-				   unsigned long address,
-				   int *type) {
-	if (type) *type = VM_FAULT_MINOR;
+				  unsigned long address, int *type)
+{
+	if (type)
+		*type = VM_FAULT_MINOR;
 	return drm_do_vm_nopage(vma, address);
 }
 
 static struct page *drm_vm_shm_nopage(struct vm_area_struct *vma,
-				       unsigned long address,
-				       int *type) {
-	if (type) *type = VM_FAULT_MINOR;
+				      unsigned long address, int *type)
+{
+	if (type)
+		*type = VM_FAULT_MINOR;
 	return drm_do_vm_shm_nopage(vma, address);
 }
 
 static struct page *drm_vm_dma_nopage(struct vm_area_struct *vma,
-				       unsigned long address,
-				       int *type) {
-	if (type) *type = VM_FAULT_MINOR;
+				      unsigned long address, int *type)
+{
+	if (type)
+		*type = VM_FAULT_MINOR;
 	return drm_do_vm_dma_nopage(vma, address);
 }
 
 static struct page *drm_vm_sg_nopage(struct vm_area_struct *vma,
-				      unsigned long address,
-				      int *type) {
-	if (type) *type = VM_FAULT_MINOR;
+				     unsigned long address, int *type)
+{
+	if (type)
+		*type = VM_FAULT_MINOR;
 	return drm_do_vm_sg_nopage(vma, address);
 }
 
-#else	/* LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,0) */
+#else				/* LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,0) */
 
 static struct page *drm_vm_nopage(struct vm_area_struct *vma,
-				   unsigned long address,
-				   int unused) {
+				  unsigned long address, int unused)
+{
 	return drm_do_vm_nopage(vma, address);
 }
 
 static struct page *drm_vm_shm_nopage(struct vm_area_struct *vma,
-				       unsigned long address,
-				       int unused) {
+				      unsigned long address, int unused)
+{
 	return drm_do_vm_shm_nopage(vma, address);
 }
 
 static struct page *drm_vm_dma_nopage(struct vm_area_struct *vma,
-				       unsigned long address,
-				       int unused) {
+				      unsigned long address, int unused)
+{
 	return drm_do_vm_dma_nopage(vma, address);
 }
 
 static struct page *drm_vm_sg_nopage(struct vm_area_struct *vma,
-				      unsigned long address,
-				      int unused) {
+				     unsigned long address, int unused)
+{
 	return drm_do_vm_sg_nopage(vma, address);
 }
 
 #endif
 
-
 /** AGP virtual memory operations */
-static struct vm_operations_struct   drm_vm_ops = {
+static struct vm_operations_struct drm_vm_ops = {
 	.nopage = drm_vm_nopage,
-	.open	= drm_vm_open,
-	.close	= drm_vm_close,
+	.open = drm_vm_open,
+	.close = drm_vm_close,
 };
 
 /** Shared virtual memory operations */
-static struct vm_operations_struct   drm_vm_shm_ops = {
+static struct vm_operations_struct drm_vm_shm_ops = {
 	.nopage = drm_vm_shm_nopage,
-	.open	= drm_vm_open,
-	.close	= drm_vm_shm_close,
+	.open = drm_vm_open,
+	.close = drm_vm_shm_close,
 };
 
 /** DMA virtual memory operations */
-static struct vm_operations_struct   drm_vm_dma_ops = {
+static struct vm_operations_struct drm_vm_dma_ops = {
 	.nopage = drm_vm_dma_nopage,
-	.open	= drm_vm_open,
-	.close	= drm_vm_close,
+	.open = drm_vm_open,
+	.close = drm_vm_close,
 };
 
 /** Scatter-gather virtual memory operations */
-static struct vm_operations_struct   drm_vm_sg_ops = {
+static struct vm_operations_struct drm_vm_sg_ops = {
 	.nopage = drm_vm_sg_nopage,
-	.open   = drm_vm_open,
-	.close  = drm_vm_close,
+	.open = drm_vm_open,
+	.close = drm_vm_close,
 };
 
-
 /**
  * \c open method for shared virtual memory.
- * 
+ *
  * \param vma virtual memory area.
- * 
+ *
  * Create a new drm_vma_entry structure as the \p vma private data entry and
  * add it to drm_device::vmalist.
  */
-void drm_vm_open(struct vm_area_struct *vma)
+static void drm_vm_open(struct vm_area_struct *vma)
 {
-	drm_file_t	*priv	= vma->vm_file->private_data;
-	drm_device_t	*dev	= priv->head->dev;
+	drm_file_t *priv = vma->vm_file->private_data;
+	drm_device_t *dev = priv->head->dev;
 	drm_vma_entry_t *vma_entry;
 
 	DRM_DEBUG("0x%08lx,0x%08lx\n",
@@ -412,26 +438,26 @@ void drm_vm_open(struct vm_area_struct *
 	vma_entry = drm_alloc(sizeof(*vma_entry), DRM_MEM_VMAS);
 	if (vma_entry) {
 		down(&dev->struct_sem);
-		vma_entry->vma	= vma;
+		vma_entry->vma = vma;
 		vma_entry->next = dev->vmalist;
-		vma_entry->pid	= current->pid;
-		dev->vmalist	= vma_entry;
+		vma_entry->pid = current->pid;
+		dev->vmalist = vma_entry;
 		up(&dev->struct_sem);
 	}
 }
 
 /**
  * \c close method for all virtual memory types.
- * 
+ *
  * \param vma virtual memory area.
- * 
+ *
  * Search the \p vma private data entry in drm_device::vmalist, unlink it, and
  * free it.
  */
-void drm_vm_close(struct vm_area_struct *vma)
+static void drm_vm_close(struct vm_area_struct *vma)
 {
-	drm_file_t	*priv	= vma->vm_file->private_data;
-	drm_device_t	*dev	= priv->head->dev;
+	drm_file_t *priv = vma->vm_file->private_data;
+	drm_device_t *dev = priv->head->dev;
 	drm_vma_entry_t *pt, *prev;
 
 	DRM_DEBUG("0x%08lx,0x%08lx\n",
@@ -459,44 +485,44 @@ void drm_vm_close(struct vm_area_struct 
  * \param filp file pointer.
  * \param vma virtual memory area.
  * \return zero on success or a negative number on failure.
- * 
+ *
  * Sets the virtual memory area operations structure to vm_dma_ops, the file
  * pointer, and calls vm_open().
  */
-int drm_mmap_dma(struct file *filp, struct vm_area_struct *vma)
+static int drm_mmap_dma(struct file *filp, struct vm_area_struct *vma)
 {
-	drm_file_t	 *priv	 = filp->private_data;
-	drm_device_t	 *dev;
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev;
 	drm_device_dma_t *dma;
-	unsigned long	 length	 = vma->vm_end - vma->vm_start;
+	unsigned long length = vma->vm_end - vma->vm_start;
 
 	lock_kernel();
-	dev	 = priv->head->dev;
-	dma	 = dev->dma;
+	dev = priv->head->dev;
+	dma = dev->dma;
 	DRM_DEBUG("start = 0x%lx, end = 0x%lx, offset = 0x%lx\n",
 		  vma->vm_start, vma->vm_end, VM_OFFSET(vma));
 
-				/* Length must match exact page count */
+	/* Length must match exact page count */
 	if (!dma || (length >> PAGE_SHIFT) != dma->page_count) {
 		unlock_kernel();
 		return -EINVAL;
 	}
 	unlock_kernel();
 
-	vma->vm_ops   = &drm_vm_dma_ops;
+	vma->vm_ops = &drm_vm_dma_ops;
 
-#if LINUX_VERSION_CODE <= 0x02040e /* KERNEL_VERSION(2,4,14) */
-	vma->vm_flags |= VM_LOCKED | VM_SHM; /* Don't swap */
+#if LINUX_VERSION_CODE <= 0x02040e	/* KERNEL_VERSION(2,4,14) */
+	vma->vm_flags |= VM_LOCKED | VM_SHM;	/* Don't swap */
 #else
-	vma->vm_flags |= VM_RESERVED; /* Don't swap */
+	vma->vm_flags |= VM_RESERVED;	/* Don't swap */
 #endif
 
-	vma->vm_file  =	 filp;	/* Needed for drm_vm_open() */
+	vma->vm_file = filp;	/* Needed for drm_vm_open() */
 	drm_vm_open(vma);
 	return 0;
 }
 
-unsigned long drm_core_get_map_ofs(drm_map_t *map)
+unsigned long drm_core_get_map_ofs(drm_map_t * map)
 {
 	return map->offset;
 }
@@ -518,7 +544,7 @@ EXPORT_SYMBOL(drm_core_get_reg_ofs);
  * \param filp file pointer.
  * \param vma virtual memory area.
  * \return zero on success or a negative number on failure.
- * 
+ *
  * If the virtual memory area has no offset associated with it then it's a DMA
  * area, so calls mmap_dma(). Otherwise searches the map in drm_device::maplist,
  * checks that the restricted flag is not set, sets the virtual memory operations
@@ -527,17 +553,18 @@ EXPORT_SYMBOL(drm_core_get_reg_ofs);
  */
 int drm_mmap(struct file *filp, struct vm_area_struct *vma)
 {
-	drm_file_t	*priv	= filp->private_data;
-	drm_device_t	*dev	= priv->head->dev;
-	drm_map_t	*map	= NULL;
-	drm_map_list_t  *r_list;
-	unsigned long   offset  = 0;
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
+	drm_map_t *map = NULL;
+	drm_map_list_t *r_list;
+	unsigned long offset = 0;
 	struct list_head *list;
 
 	DRM_DEBUG("start = 0x%lx, end = 0x%lx, offset = 0x%lx\n",
 		  vma->vm_start, vma->vm_end, VM_OFFSET(vma));
 
-	if ( !priv->authenticated ) return -EACCES;
+	if (!priv->authenticated)
+		return -EACCES;
 
 	/* We check for "dma". On Apple's UniNorth, it's valid to have
 	 * the AGP mapped at physical address 0
@@ -545,62 +572,68 @@ int drm_mmap(struct file *filp, struct v
 	 */
 	if (!VM_OFFSET(vma)
 #if __OS_HAS_AGP
-	    && (!dev->agp || dev->agp->agp_info.device->vendor != PCI_VENDOR_ID_APPLE)
+	    && (!dev->agp
+		|| dev->agp->agp_info.device->vendor != PCI_VENDOR_ID_APPLE)
 #endif
 	    )
 		return drm_mmap_dma(filp, vma);
 
-				/* A sequential search of a linked list is
-				   fine here because: 1) there will only be
-				   about 5-10 entries in the list and, 2) a
-				   DRI client only has to do this mapping
-				   once, so it doesn't have to be optimized
-				   for performance, even if the list was a
-				   bit longer. */
+	/* A sequential search of a linked list is
+	   fine here because: 1) there will only be
+	   about 5-10 entries in the list and, 2) a
+	   DRI client only has to do this mapping
+	   once, so it doesn't have to be optimized
+	   for performance, even if the list was a
+	   bit longer. */
 	list_for_each(list, &dev->maplist->head) {
 		unsigned long off;
 
 		r_list = list_entry(list, drm_map_list_t, head);
 		map = r_list->map;
-		if (!map) continue;
+		if (!map)
+			continue;
 		off = dev->driver->get_map_ofs(map);
-		if (off == VM_OFFSET(vma)) break;
+		if (off == VM_OFFSET(vma))
+			break;
 	}
 
-	if (!map || ((map->flags&_DRM_RESTRICTED) && !capable(CAP_SYS_ADMIN)))
+	if (!map || ((map->flags & _DRM_RESTRICTED) && !capable(CAP_SYS_ADMIN)))
 		return -EPERM;
 
-				/* Check for valid size. */
-	if (map->size != vma->vm_end - vma->vm_start) return -EINVAL;
+	/* Check for valid size. */
+	if (map->size < vma->vm_end - vma->vm_start)
+		return -EINVAL;
 
 	if (!capable(CAP_SYS_ADMIN) && (map->flags & _DRM_READ_ONLY)) {
 		vma->vm_flags &= ~(VM_WRITE | VM_MAYWRITE);
 #if defined(__i386__) || defined(__x86_64__)
 		pgprot_val(vma->vm_page_prot) &= ~_PAGE_RW;
 #else
-				/* Ye gads this is ugly.  With more thought
-                                   we could move this up higher and use
-                                   `protection_map' instead.  */
-		vma->vm_page_prot = __pgprot(pte_val(pte_wrprotect(
-			__pte(pgprot_val(vma->vm_page_prot)))));
+		/* Ye gads this is ugly.  With more thought
+		   we could move this up higher and use
+		   `protection_map' instead.  */
+		vma->vm_page_prot =
+		    __pgprot(pte_val
+			     (pte_wrprotect
+			      (__pte(pgprot_val(vma->vm_page_prot)))));
 #endif
 	}
 
 	switch (map->type) {
-        case _DRM_AGP:
-	  if (drm_core_has_AGP(dev) && dev->agp->cant_use_aperture) {
-                /*
-                 * On some platforms we can't talk to bus dma address from the CPU, so for
-                 * memory of type DRM_AGP, we'll deal with sorting out the real physical
-                 * pages and mappings in nopage()
-                 */
+	case _DRM_AGP:
+		if (drm_core_has_AGP(dev) && dev->agp->cant_use_aperture) {
+			/*
+			 * On some platforms we can't talk to bus dma address from the CPU, so for
+			 * memory of type DRM_AGP, we'll deal with sorting out the real physical
+			 * pages and mappings in nopage()
+			 */
 #if defined(__powerpc__)
-		pgprot_val(vma->vm_page_prot) |= _PAGE_NO_CACHE;
+			pgprot_val(vma->vm_page_prot) |= _PAGE_NO_CACHE;
 #endif
-                vma->vm_ops = &drm_vm_ops;
-                break;
-	  }
-                /* fall through to _DRM_FRAME_BUFFER... */        
+			vma->vm_ops = &drm_vm_ops;
+			break;
+		}
+		/* fall through to _DRM_FRAME_BUFFER... */
 	case _DRM_FRAME_BUFFER:
 	case _DRM_REGISTERS:
 		if (VM_OFFSET(vma) >= __pa(high_memory)) {
@@ -610,7 +643,8 @@ int drm_mmap(struct file *filp, struct v
 				pgprot_val(vma->vm_page_prot) &= ~_PAGE_PWT;
 			}
 #elif defined(__powerpc__)
-			pgprot_val(vma->vm_page_prot) |= _PAGE_NO_CACHE | _PAGE_GUARDED;
+			pgprot_val(vma->vm_page_prot) |=
+			    _PAGE_NO_CACHE | _PAGE_GUARDED;
 #endif
 			vma->vm_flags |= VM_IO;	/* not in core dump */
 		}
@@ -625,17 +659,17 @@ int drm_mmap(struct file *filp, struct v
 #endif
 		offset = dev->driver->get_reg_ofs(dev);
 #ifdef __sparc__
-		if (io_remap_pfn_range(DRM_RPR_ARG(vma) vma->vm_start,
-					(VM_OFFSET(vma) + offset) >> PAGE_SHIFT,
+		if (io_remap_page_range(DRM_RPR_ARG(vma) vma->vm_start,
+					VM_OFFSET(vma) + offset,
 					vma->vm_end - vma->vm_start,
-					vma->vm_page_prot))
+					vma->vm_page_prot, 0))
 #else
-		if (io_remap_pfn_range(vma, vma->vm_start,
+		if (remap_pfn_range(vma, vma->vm_start,
 				     (VM_OFFSET(vma) + offset) >> PAGE_SHIFT,
 				     vma->vm_end - vma->vm_start,
 				     vma->vm_page_prot))
 #endif
-				return -EAGAIN;
+			return -EAGAIN;
 		DRM_DEBUG("   Type = %d; start = 0x%lx, end = 0x%lx,"
 			  " offset = 0x%lx\n",
 			  map->type,
@@ -643,11 +677,15 @@ int drm_mmap(struct file *filp, struct v
 		vma->vm_ops = &drm_vm_ops;
 		break;
 	case _DRM_SHM:
+	case _DRM_CONSISTENT:
+		/* Consistent memory is much like shared memory. The
+		 * only difference is that drm_vm_shm_nopage must use
+		 * virt_to_page instead of vmalloc_to_page. */
 		vma->vm_ops = &drm_vm_shm_ops;
 		vma->vm_private_data = (void *)map;
-				/* Don't let this area swap.  Change when
-				   DRM_KERNEL advisory is supported. */
-#if LINUX_VERSION_CODE <= 0x02040e /* KERNEL_VERSION(2,4,14) */
+		/* Don't let this area swap.  Change when
+		   DRM_KERNEL advisory is supported. */
+#if LINUX_VERSION_CODE <= 0x02040e	/* KERNEL_VERSION(2,4,14) */
 		vma->vm_flags |= VM_LOCKED;
 #else
 		vma->vm_flags |= VM_RESERVED;
@@ -656,22 +694,22 @@ int drm_mmap(struct file *filp, struct v
 	case _DRM_SCATTER_GATHER:
 		vma->vm_ops = &drm_vm_sg_ops;
 		vma->vm_private_data = (void *)map;
-#if LINUX_VERSION_CODE <= 0x02040e /* KERNEL_VERSION(2,4,14) */
+#if LINUX_VERSION_CODE <= 0x02040e	/* KERNEL_VERSION(2,4,14) */
 		vma->vm_flags |= VM_LOCKED;
 #else
 		vma->vm_flags |= VM_RESERVED;
 #endif
-                break;
+		break;
 	default:
 		return -EINVAL;	/* This should never happen. */
 	}
-#if LINUX_VERSION_CODE <= 0x02040e /* KERNEL_VERSION(2,4,14) */
-	vma->vm_flags |= VM_LOCKED | VM_SHM; /* Don't swap */
+#if LINUX_VERSION_CODE <= 0x02040e	/* KERNEL_VERSION(2,4,14) */
+	vma->vm_flags |= VM_LOCKED | VM_SHM;	/* Don't swap */
 #else
-	vma->vm_flags |= VM_RESERVED; /* Don't swap */
+	vma->vm_flags |= VM_RESERVED;	/* Don't swap */
 #endif
 
-	vma->vm_file  =	 filp;	/* Needed for drm_vm_open() */
+	vma->vm_file = filp;	/* Needed for drm_vm_open() */
 	drm_vm_open(vma);
 	return 0;
 }
diff -purN linux-2.6.12.orig/drivers/char/drm/ffb_context.c linux-2.6.12/drivers/char/drm/ffb_context.c
--- linux-2.6.12.orig/drivers/char/drm/ffb_context.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/ffb_context.c	2005-07-05 08:37:27.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id: ffb_context.c,v 1.5 2001/08/09 17:47:51 davem Exp $
+/* $Id: ffb_context.c,v 1.7 2004/09/30 21:27:59 jonsmirl Exp $
  * ffb_context.c: Creator/Creator3D DRI/DRM context switching.
  *
  * Copyright (C) 2000 David S. Miller (davem@redhat.com)
@@ -10,13 +10,10 @@
 #include <linux/sched.h>
 #include <asm/upa.h>
 
-#include "ffb.h"
 #include "drmP.h"
-
 #include "ffb_drv.h"
 
-static int DRM(alloc_queue)(drm_device_t *dev, int is_2d_only)
-{
+static int ffb_alloc_queue(drm_device_t * dev, int is_2d_only) {
 	ffb_dev_priv_t *fpriv = (ffb_dev_priv_t *) dev->dev_private;
 	int i;
 
@@ -37,7 +34,7 @@ static int DRM(alloc_queue)(drm_device_t
 	return i + 1;
 }
 
-static void ffb_save_context(ffb_dev_priv_t *fpriv, int idx)
+static void ffb_save_context(ffb_dev_priv_t * fpriv, int idx)
 {
 	ffb_fbcPtr ffb = fpriv->regs;
 	struct ffb_hw_context *ctx;
@@ -94,36 +91,36 @@ static void ffb_save_context(ffb_dev_pri
 
 	/* Capture rendering attributes. */
 
-	ctx->ppc = upa_readl(&ffb->ppc);		/* Pixel Processor Control */
-	ctx->wid = upa_readl(&ffb->wid);		/* Current WID */
-	ctx->fg = upa_readl(&ffb->fg);			/* Constant FG color */
-	ctx->bg = upa_readl(&ffb->bg);			/* Constant BG color */
-	ctx->consty = upa_readl(&ffb->consty);		/* Constant Y */
-	ctx->constz = upa_readl(&ffb->constz);		/* Constant Z */
-	ctx->xclip = upa_readl(&ffb->xclip);		/* X plane clip */
-	ctx->dcss = upa_readl(&ffb->dcss);		/* Depth Cue Scale Slope */
+	ctx->ppc = upa_readl(&ffb->ppc);	/* Pixel Processor Control */
+	ctx->wid = upa_readl(&ffb->wid);	/* Current WID */
+	ctx->fg = upa_readl(&ffb->fg);	/* Constant FG color */
+	ctx->bg = upa_readl(&ffb->bg);	/* Constant BG color */
+	ctx->consty = upa_readl(&ffb->consty);	/* Constant Y */
+	ctx->constz = upa_readl(&ffb->constz);	/* Constant Z */
+	ctx->xclip = upa_readl(&ffb->xclip);	/* X plane clip */
+	ctx->dcss = upa_readl(&ffb->dcss);	/* Depth Cue Scale Slope */
 	ctx->vclipmin = upa_readl(&ffb->vclipmin);	/* Primary XY clip, minimum */
 	ctx->vclipmax = upa_readl(&ffb->vclipmax);	/* Primary XY clip, maximum */
 	ctx->vclipzmin = upa_readl(&ffb->vclipzmin);	/* Primary Z clip, minimum */
 	ctx->vclipzmax = upa_readl(&ffb->vclipzmax);	/* Primary Z clip, maximum */
-	ctx->dcsf = upa_readl(&ffb->dcsf);		/* Depth Cue Scale Front Bound */
-	ctx->dcsb = upa_readl(&ffb->dcsb);		/* Depth Cue Scale Back Bound */
-	ctx->dczf = upa_readl(&ffb->dczf);		/* Depth Cue Scale Z Front */
-	ctx->dczb = upa_readl(&ffb->dczb);		/* Depth Cue Scale Z Back */
-	ctx->blendc = upa_readl(&ffb->blendc);		/* Alpha Blend Control */
+	ctx->dcsf = upa_readl(&ffb->dcsf);	/* Depth Cue Scale Front Bound */
+	ctx->dcsb = upa_readl(&ffb->dcsb);	/* Depth Cue Scale Back Bound */
+	ctx->dczf = upa_readl(&ffb->dczf);	/* Depth Cue Scale Z Front */
+	ctx->dczb = upa_readl(&ffb->dczb);	/* Depth Cue Scale Z Back */
+	ctx->blendc = upa_readl(&ffb->blendc);	/* Alpha Blend Control */
 	ctx->blendc1 = upa_readl(&ffb->blendc1);	/* Alpha Blend Color 1 */
 	ctx->blendc2 = upa_readl(&ffb->blendc2);	/* Alpha Blend Color 2 */
-	ctx->fbc = upa_readl(&ffb->fbc);		/* Frame Buffer Control */
-	ctx->rop = upa_readl(&ffb->rop);		/* Raster Operation */
-	ctx->cmp = upa_readl(&ffb->cmp);		/* Compare Controls */
+	ctx->fbc = upa_readl(&ffb->fbc);	/* Frame Buffer Control */
+	ctx->rop = upa_readl(&ffb->rop);	/* Raster Operation */
+	ctx->cmp = upa_readl(&ffb->cmp);	/* Compare Controls */
 	ctx->matchab = upa_readl(&ffb->matchab);	/* Buffer A/B Match Ops */
-	ctx->matchc = upa_readl(&ffb->matchc);		/* Buffer C Match Ops */
-	ctx->magnab = upa_readl(&ffb->magnab);		/* Buffer A/B Magnitude Ops */
-	ctx->magnc = upa_readl(&ffb->magnc);		/* Buffer C Magnitude Ops */
-	ctx->pmask = upa_readl(&ffb->pmask);		/* RGB Plane Mask */
-	ctx->xpmask = upa_readl(&ffb->xpmask);		/* X Plane Mask */
-	ctx->ypmask = upa_readl(&ffb->ypmask);		/* Y Plane Mask */
-	ctx->zpmask = upa_readl(&ffb->zpmask);		/* Z Plane Mask */
+	ctx->matchc = upa_readl(&ffb->matchc);	/* Buffer C Match Ops */
+	ctx->magnab = upa_readl(&ffb->magnab);	/* Buffer A/B Magnitude Ops */
+	ctx->magnc = upa_readl(&ffb->magnc);	/* Buffer C Magnitude Ops */
+	ctx->pmask = upa_readl(&ffb->pmask);	/* RGB Plane Mask */
+	ctx->xpmask = upa_readl(&ffb->xpmask);	/* X Plane Mask */
+	ctx->ypmask = upa_readl(&ffb->ypmask);	/* Y Plane Mask */
+	ctx->zpmask = upa_readl(&ffb->zpmask);	/* Z Plane Mask */
 
 	/* Auxiliary Clips. */
 	ctx->auxclip0min = upa_readl(&ffb->auxclip[0].min);
@@ -135,9 +132,9 @@ static void ffb_save_context(ffb_dev_pri
 	ctx->auxclip3min = upa_readl(&ffb->auxclip[3].min);
 	ctx->auxclip3max = upa_readl(&ffb->auxclip[3].max);
 
-	ctx->lpat = upa_readl(&ffb->lpat);		/* Line Pattern */
-	ctx->fontxy = upa_readl(&ffb->fontxy);		/* XY Font Coordinate */
-	ctx->fontw = upa_readl(&ffb->fontw);		/* Font Width */
+	ctx->lpat = upa_readl(&ffb->lpat);	/* Line Pattern */
+	ctx->fontxy = upa_readl(&ffb->fontxy);	/* XY Font Coordinate */
+	ctx->fontw = upa_readl(&ffb->fontw);	/* Font Width */
 	ctx->fontinc = upa_readl(&ffb->fontinc);	/* Font X/Y Increment */
 
 	/* These registers/features only exist on FFB2 and later chips. */
@@ -145,12 +142,12 @@ static void ffb_save_context(ffb_dev_pri
 		ctx->dcss1 = upa_readl(&ffb->dcss1);	/* Depth Cue Scale Slope 1 */
 		ctx->dcss2 = upa_readl(&ffb->dcss2);	/* Depth Cue Scale Slope 2 */
 		ctx->dcss2 = upa_readl(&ffb->dcss3);	/* Depth Cue Scale Slope 3 */
-		ctx->dcs2  = upa_readl(&ffb->dcs2);	/* Depth Cue Scale 2 */
-		ctx->dcs3  = upa_readl(&ffb->dcs3);	/* Depth Cue Scale 3 */
-		ctx->dcs4  = upa_readl(&ffb->dcs4);	/* Depth Cue Scale 4 */
-		ctx->dcd2  = upa_readl(&ffb->dcd2);	/* Depth Cue Depth 2 */
-		ctx->dcd3  = upa_readl(&ffb->dcd3);	/* Depth Cue Depth 3 */
-		ctx->dcd4  = upa_readl(&ffb->dcd4);	/* Depth Cue Depth 4 */
+		ctx->dcs2 = upa_readl(&ffb->dcs2);	/* Depth Cue Scale 2 */
+		ctx->dcs3 = upa_readl(&ffb->dcs3);	/* Depth Cue Scale 3 */
+		ctx->dcs4 = upa_readl(&ffb->dcs4);	/* Depth Cue Scale 4 */
+		ctx->dcd2 = upa_readl(&ffb->dcd2);	/* Depth Cue Depth 2 */
+		ctx->dcd3 = upa_readl(&ffb->dcd3);	/* Depth Cue Depth 3 */
+		ctx->dcd4 = upa_readl(&ffb->dcd4);	/* Depth Cue Depth 4 */
 
 		/* And stencil/stencilctl only exists on FFB2+ and later
 		 * due to the introduction of 3DRAM-III.
@@ -170,7 +167,7 @@ static void ffb_save_context(ffb_dev_pri
 	ctx->ucsr = upa_readl(&ffb->ucsr);
 }
 
-static void ffb_restore_context(ffb_dev_priv_t *fpriv, int old, int idx)
+static void ffb_restore_context(ffb_dev_priv_t * fpriv, int old, int idx)
 {
 	ffb_fbcPtr ffb = fpriv->regs;
 	struct ffb_hw_context *ctx;
@@ -193,7 +190,7 @@ static void ffb_restore_context(ffb_dev_
 
 		upa_writel(ctx->ppc, &ffb->ppc);
 		upa_writel(ctx->wid, &ffb->wid);
-		upa_writel(ctx->fg,  &ffb->fg);
+		upa_writel(ctx->fg, &ffb->fg);
 		upa_writel(ctx->bg, &ffb->bg);
 		upa_writel(ctx->xclip, &ffb->xclip);
 		upa_writel(ctx->fbc, &ffb->fbc);
@@ -237,36 +234,36 @@ static void ffb_restore_context(ffb_dev_
 
 	/* Restore rendering attributes. */
 
-	upa_writel(ctx->ppc, &ffb->ppc);		/* Pixel Processor Control */
-	upa_writel(ctx->wid, &ffb->wid);		/* Current WID */
-	upa_writel(ctx->fg, &ffb->fg);			/* Constant FG color */
-	upa_writel(ctx->bg, &ffb->bg);			/* Constant BG color */
-	upa_writel(ctx->consty, &ffb->consty);		/* Constant Y */
-	upa_writel(ctx->constz, &ffb->constz);		/* Constant Z */
-	upa_writel(ctx->xclip, &ffb->xclip);		/* X plane clip */
-	upa_writel(ctx->dcss, &ffb->dcss);		/* Depth Cue Scale Slope */
+	upa_writel(ctx->ppc, &ffb->ppc);	/* Pixel Processor Control */
+	upa_writel(ctx->wid, &ffb->wid);	/* Current WID */
+	upa_writel(ctx->fg, &ffb->fg);	/* Constant FG color */
+	upa_writel(ctx->bg, &ffb->bg);	/* Constant BG color */
+	upa_writel(ctx->consty, &ffb->consty);	/* Constant Y */
+	upa_writel(ctx->constz, &ffb->constz);	/* Constant Z */
+	upa_writel(ctx->xclip, &ffb->xclip);	/* X plane clip */
+	upa_writel(ctx->dcss, &ffb->dcss);	/* Depth Cue Scale Slope */
 	upa_writel(ctx->vclipmin, &ffb->vclipmin);	/* Primary XY clip, minimum */
 	upa_writel(ctx->vclipmax, &ffb->vclipmax);	/* Primary XY clip, maximum */
 	upa_writel(ctx->vclipzmin, &ffb->vclipzmin);	/* Primary Z clip, minimum */
 	upa_writel(ctx->vclipzmax, &ffb->vclipzmax);	/* Primary Z clip, maximum */
-	upa_writel(ctx->dcsf, &ffb->dcsf);		/* Depth Cue Scale Front Bound */
-	upa_writel(ctx->dcsb, &ffb->dcsb);		/* Depth Cue Scale Back Bound */
-	upa_writel(ctx->dczf, &ffb->dczf);		/* Depth Cue Scale Z Front */
-	upa_writel(ctx->dczb, &ffb->dczb);		/* Depth Cue Scale Z Back */
-	upa_writel(ctx->blendc, &ffb->blendc);		/* Alpha Blend Control */
+	upa_writel(ctx->dcsf, &ffb->dcsf);	/* Depth Cue Scale Front Bound */
+	upa_writel(ctx->dcsb, &ffb->dcsb);	/* Depth Cue Scale Back Bound */
+	upa_writel(ctx->dczf, &ffb->dczf);	/* Depth Cue Scale Z Front */
+	upa_writel(ctx->dczb, &ffb->dczb);	/* Depth Cue Scale Z Back */
+	upa_writel(ctx->blendc, &ffb->blendc);	/* Alpha Blend Control */
 	upa_writel(ctx->blendc1, &ffb->blendc1);	/* Alpha Blend Color 1 */
 	upa_writel(ctx->blendc2, &ffb->blendc2);	/* Alpha Blend Color 2 */
-	upa_writel(ctx->fbc, &ffb->fbc);		/* Frame Buffer Control */
-	upa_writel(ctx->rop, &ffb->rop);		/* Raster Operation */
-	upa_writel(ctx->cmp, &ffb->cmp);		/* Compare Controls */
+	upa_writel(ctx->fbc, &ffb->fbc);	/* Frame Buffer Control */
+	upa_writel(ctx->rop, &ffb->rop);	/* Raster Operation */
+	upa_writel(ctx->cmp, &ffb->cmp);	/* Compare Controls */
 	upa_writel(ctx->matchab, &ffb->matchab);	/* Buffer A/B Match Ops */
-	upa_writel(ctx->matchc, &ffb->matchc);		/* Buffer C Match Ops */
-	upa_writel(ctx->magnab, &ffb->magnab);		/* Buffer A/B Magnitude Ops */
-	upa_writel(ctx->magnc, &ffb->magnc);		/* Buffer C Magnitude Ops */
-	upa_writel(ctx->pmask, &ffb->pmask);		/* RGB Plane Mask */
-	upa_writel(ctx->xpmask, &ffb->xpmask);		/* X Plane Mask */
-	upa_writel(ctx->ypmask, &ffb->ypmask);		/* Y Plane Mask */
-	upa_writel(ctx->zpmask, &ffb->zpmask);		/* Z Plane Mask */
+	upa_writel(ctx->matchc, &ffb->matchc);	/* Buffer C Match Ops */
+	upa_writel(ctx->magnab, &ffb->magnab);	/* Buffer A/B Magnitude Ops */
+	upa_writel(ctx->magnc, &ffb->magnc);	/* Buffer C Magnitude Ops */
+	upa_writel(ctx->pmask, &ffb->pmask);	/* RGB Plane Mask */
+	upa_writel(ctx->xpmask, &ffb->xpmask);	/* X Plane Mask */
+	upa_writel(ctx->ypmask, &ffb->ypmask);	/* Y Plane Mask */
+	upa_writel(ctx->zpmask, &ffb->zpmask);	/* Z Plane Mask */
 
 	/* Auxiliary Clips. */
 	upa_writel(ctx->auxclip0min, &ffb->auxclip[0].min);
@@ -278,9 +275,9 @@ static void ffb_restore_context(ffb_dev_
 	upa_writel(ctx->auxclip3min, &ffb->auxclip[3].min);
 	upa_writel(ctx->auxclip3max, &ffb->auxclip[3].max);
 
-	upa_writel(ctx->lpat, &ffb->lpat);		/* Line Pattern */
-	upa_writel(ctx->fontxy, &ffb->fontxy);		/* XY Font Coordinate */
-	upa_writel(ctx->fontw, &ffb->fontw);		/* Font Width */
+	upa_writel(ctx->lpat, &ffb->lpat);	/* Line Pattern */
+	upa_writel(ctx->fontxy, &ffb->fontxy);	/* XY Font Coordinate */
+	upa_writel(ctx->fontw, &ffb->fontw);	/* Font Width */
 	upa_writel(ctx->fontinc, &ffb->fontinc);	/* Font X/Y Increment */
 
 	/* These registers/features only exist on FFB2 and later chips. */
@@ -354,91 +351,83 @@ static void FFBWait(ffb_fbcPtr ffb)
 	} while (--limit);
 }
 
-int ffb_driver_context_switch(drm_device_t *dev, int old, int new)
-{
+int ffb_context_switch(drm_device_t * dev, int old, int new) {
 	ffb_dev_priv_t *fpriv = (ffb_dev_priv_t *) dev->dev_private;
 
-#ifdef DRM_DMA_HISTOGRAM
-        dev->ctx_start = get_cycles();
+#if DRM_DMA_HISTOGRAM
+	dev->ctx_start = get_cycles();
 #endif
-        
-        DRM_DEBUG("Context switch from %d to %d\n", old, new);
 
-        if (new == dev->last_context ||
-	    dev->last_context == 0) {
+	DRM_DEBUG("Context switch from %d to %d\n", old, new);
+
+	if (new == dev->last_context || dev->last_context == 0) {
 		dev->last_context = new;
-                return 0;
+		return 0;
 	}
-        
+
 	FFBWait(fpriv->regs);
 	ffb_save_context(fpriv, old);
 	ffb_restore_context(fpriv, old, new);
 	FFBWait(fpriv->regs);
-        
+
 	dev->last_context = new;
 
-        return 0;
+	return 0;
 }
 
-int ffb_driver_resctx(struct inode *inode, struct file *filp, unsigned int cmd,
-		unsigned long arg)
-{
-	drm_ctx_res_t	res;
-	drm_ctx_t	ctx;
-	int		i;
+int ffb_resctx(struct inode * inode, struct file * filp, unsigned int cmd,
+		 unsigned long arg) {
+	drm_ctx_res_t res;
+	drm_ctx_t ctx;
+	int i;
 
 	DRM_DEBUG("%d\n", DRM_RESERVED_CONTEXTS);
-	if (copy_from_user(&res, (drm_ctx_res_t __user *)arg, sizeof(res)))
+	if (copy_from_user(&res, (drm_ctx_res_t __user *) arg, sizeof(res)))
 		return -EFAULT;
 	if (res.count >= DRM_RESERVED_CONTEXTS) {
 		memset(&ctx, 0, sizeof(ctx));
 		for (i = 0; i < DRM_RESERVED_CONTEXTS; i++) {
 			ctx.handle = i;
-			if (copy_to_user(&res.contexts[i],
-					 &i,
-					 sizeof(i)))
+			if (copy_to_user(&res.contexts[i], &i, sizeof(i)))
 				return -EFAULT;
 		}
 	}
 	res.count = DRM_RESERVED_CONTEXTS;
-	if (copy_to_user((drm_ctx_res_t __user *)arg, &res, sizeof(res)))
+	if (copy_to_user((drm_ctx_res_t __user *) arg, &res, sizeof(res)))
 		return -EFAULT;
 	return 0;
 }
 
-
-int ffb_driver_addctx(struct inode *inode, struct file *filp, unsigned int cmd,
-		unsigned long arg)
-{
-	drm_file_t	*priv	= filp->private_data;
-	drm_device_t	*dev	= priv->dev;
-	drm_ctx_t	ctx;
+int ffb_addctx(struct inode * inode, struct file * filp, unsigned int cmd,
+		 unsigned long arg) {
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->dev;
+	drm_ctx_t ctx;
 	int idx;
 
-	if (copy_from_user(&ctx, (drm_ctx_t __user *)arg, sizeof(ctx)))
+	if (copy_from_user(&ctx, (drm_ctx_t __user *) arg, sizeof(ctx)))
 		return -EFAULT;
-	idx = DRM(alloc_queue)(dev, (ctx.flags & _DRM_CONTEXT_2DONLY));
+	idx = ffb_alloc_queue(dev, (ctx.flags & _DRM_CONTEXT_2DONLY));
 	if (idx < 0)
 		return -ENFILE;
 
 	DRM_DEBUG("%d\n", ctx.handle);
 	ctx.handle = idx;
-	if (copy_to_user((drm_ctx_t __user *)arg, &ctx, sizeof(ctx)))
+	if (copy_to_user((drm_ctx_t __user *) arg, &ctx, sizeof(ctx)))
 		return -EFAULT;
 	return 0;
 }
 
-int ffb_driver_modctx(struct inode *inode, struct file *filp, unsigned int cmd,
-		unsigned long arg)
-{
-	drm_file_t	*priv	= filp->private_data;
-	drm_device_t	*dev	= priv->dev;
-	ffb_dev_priv_t	*fpriv	= (ffb_dev_priv_t *) dev->dev_private;
+int ffb_modctx(struct inode * inode, struct file * filp, unsigned int cmd,
+		 unsigned long arg) {
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->dev;
+	ffb_dev_priv_t *fpriv = (ffb_dev_priv_t *) dev->dev_private;
 	struct ffb_hw_context *hwctx;
 	drm_ctx_t ctx;
 	int idx;
 
-	if (copy_from_user(&ctx, (drm_ctx_t __user *)arg, sizeof(ctx)))
+	if (copy_from_user(&ctx, (drm_ctx_t __user *) arg, sizeof(ctx)))
 		return -EFAULT;
 
 	idx = ctx.handle;
@@ -457,17 +446,16 @@ int ffb_driver_modctx(struct inode *inod
 	return 0;
 }
 
-int ffb_driver_getctx(struct inode *inode, struct file *filp, unsigned int cmd,
-		unsigned long arg)
-{
-	drm_file_t	*priv	= filp->private_data;
-	drm_device_t	*dev	= priv->dev;
-	ffb_dev_priv_t	*fpriv	= (ffb_dev_priv_t *) dev->dev_private;
+int ffb_getctx(struct inode * inode, struct file * filp, unsigned int cmd,
+		 unsigned long arg) {
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->dev;
+	ffb_dev_priv_t *fpriv = (ffb_dev_priv_t *) dev->dev_private;
 	struct ffb_hw_context *hwctx;
 	drm_ctx_t ctx;
 	int idx;
 
-	if (copy_from_user(&ctx, (drm_ctx_t __user *)arg, sizeof(ctx)))
+	if (copy_from_user(&ctx, (drm_ctx_t __user *) arg, sizeof(ctx)))
 		return -EFAULT;
 
 	idx = ctx.handle;
@@ -483,47 +471,44 @@ int ffb_driver_getctx(struct inode *inod
 	else
 		ctx.flags = 0;
 
-	if (copy_to_user((drm_ctx_t __user *)arg, &ctx, sizeof(ctx)))
+	if (copy_to_user((drm_ctx_t __user *) arg, &ctx, sizeof(ctx)))
 		return -EFAULT;
 
 	return 0;
 }
 
-int ffb_driver_switchctx(struct inode *inode, struct file *filp, unsigned int cmd,
-		   unsigned long arg)
-{
-	drm_file_t	*priv	= filp->private_data;
-	drm_device_t	*dev	= priv->dev;
-	drm_ctx_t	ctx;
+int ffb_switchctx(struct inode * inode, struct file * filp, unsigned int cmd,
+		    unsigned long arg) {
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->dev;
+	drm_ctx_t ctx;
 
-	if (copy_from_user(&ctx, (drm_ctx_t  __user *)arg, sizeof(ctx)))
+	if (copy_from_user(&ctx, (drm_ctx_t __user *) arg, sizeof(ctx)))
 		return -EFAULT;
 	DRM_DEBUG("%d\n", ctx.handle);
-	return ffb_driver_context_switch(dev, dev->last_context, ctx.handle);
+	return ffb_context_switch(dev, dev->last_context, ctx.handle);
 }
 
-int ffb_driver_newctx(struct inode *inode, struct file *filp, unsigned int cmd,
-		unsigned long arg)
-{
-	drm_ctx_t	ctx;
+int ffb_newctx(struct inode * inode, struct file * filp, unsigned int cmd,
+		 unsigned long arg) {
+	drm_ctx_t ctx;
 
-	if (copy_from_user(&ctx, (drm_ctx_t  __user *)arg, sizeof(ctx)))
+	if (copy_from_user(&ctx, (drm_ctx_t __user *) arg, sizeof(ctx)))
 		return -EFAULT;
 	DRM_DEBUG("%d\n", ctx.handle);
 
 	return 0;
 }
 
-int ffb_driver_rmctx(struct inode *inode, struct file *filp, unsigned int cmd,
-	       unsigned long arg)
-{
-	drm_ctx_t	ctx;
-	drm_file_t	*priv	= filp->private_data;
-	drm_device_t	*dev	= priv->dev;
-	ffb_dev_priv_t	*fpriv	= (ffb_dev_priv_t *) dev->dev_private;
+int ffb_rmctx(struct inode * inode, struct file * filp, unsigned int cmd,
+		unsigned long arg) {
+	drm_ctx_t ctx;
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->dev;
+	ffb_dev_priv_t *fpriv = (ffb_dev_priv_t *) dev->dev_private;
 	int idx;
 
-	if (copy_from_user(&ctx, (drm_ctx_t __user *)arg, sizeof(ctx)))
+	if (copy_from_user(&ctx, (drm_ctx_t __user *) arg, sizeof(ctx)))
 		return -EFAULT;
 	DRM_DEBUG("%d\n", ctx.handle);
 
@@ -538,14 +523,68 @@ int ffb_driver_rmctx(struct inode *inode
 	return 0;
 }
 
-void ffb_set_context_ioctls(void)
+static void ffb_driver_release(drm_device_t * dev)
+{
+	ffb_dev_priv_t *fpriv = (ffb_dev_priv_t *) dev->dev_private;
+	int context = _DRM_LOCKING_CONTEXT(dev->lock.hw_lock->lock);
+	int idx;
+
+	idx = context - 1;
+	if (fpriv &&
+	    context != DRM_KERNEL_CONTEXT && fpriv->hw_state[idx] != NULL) {
+		kfree(fpriv->hw_state[idx]);
+		fpriv->hw_state[idx] = NULL;
+	}
+}
+
+static int ffb_driver_presetup(drm_device_t * dev)
+{
+	int ret;
+	ret = ffb_presetup(dev);
+	if (_ret != 0)
+		return ret;
+}
+
+static void ffb_driver_pretakedown(drm_device_t * dev)
+{
+	if (dev->dev_private)
+		kfree(dev->dev_private);
+}
+
+static void ffb_driver_postcleanup(drm_device_t * dev)
 {
-	DRM(ioctls)[DRM_IOCTL_NR(DRM_IOCTL_ADD_CTX)].func = ffb_driver_addctx;
-	DRM(ioctls)[DRM_IOCTL_NR(DRM_IOCTL_RM_CTX)].func = ffb_driver_rmctx;
-	DRM(ioctls)[DRM_IOCTL_NR(DRM_IOCTL_MOD_CTX)].func = ffb_driver_modctx;
-	DRM(ioctls)[DRM_IOCTL_NR(DRM_IOCTL_GET_CTX)].func = ffb_driver_getctx;
-	DRM(ioctls)[DRM_IOCTL_NR(DRM_IOCTL_SWITCH_CTX)].func = ffb_driver_switchctx;
-	DRM(ioctls)[DRM_IOCTL_NR(DRM_IOCTL_NEW_CTX)].func = ffb_driver_newctx;
-	DRM(ioctls)[DRM_IOCTL_NR(DRM_IOCTL_RES_CTX)].func = ffb_driver_resctx;
+	if (ffb_position != NULL)
+		kfree(ffb_position);
+}
+
+static int ffb_driver_kernel_context_switch_unlock(struct drm_device *dev)
+{
+	dev->lock.filp = 0;
+	{
+		__volatile__ unsigned int *plock = &dev->lock.hw_lock->lock;
+		unsigned int old, new, prev, ctx;
 
+		ctx = lock.context;
+		do {
+			old = *plock;
+			new = ctx;
+			prev = cmpxchg(plock, old, new);
+		} while (prev != old);
+	}
+	wake_up_interruptible(&dev->lock.lock_queue);
+}
+
+unsigned long ffb_driver_get_map_ofs(drm_map_t * map)
+{
+	return (map->offset & 0xffffffff);
+}
+
+unsigned long ffb_driver_get_reg_ofs(drm_device_t * dev)
+{
+	ffb_dev_priv_t *ffb_priv = (ffb_dev_priv_t *) dev->dev_private;
+
+	if (ffb_priv)
+		return ffb_priv->card_phys_base;
+
+	return 0;
 }
diff -purN linux-2.6.12.orig/drivers/char/drm/ffb_drv.c linux-2.6.12/drivers/char/drm/ffb_drv.c
--- linux-2.6.12.orig/drivers/char/drm/ffb_drv.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/ffb_drv.c	2005-07-05 08:37:27.000000000 +0200
@@ -1,21 +1,19 @@
-/* $Id: ffb_drv.c,v 1.16 2001/10/18 16:00:24 davem Exp $
+/* $Id: ffb_drv.c,v 1.13 2004/10/13 16:40:53 jonsmirl Exp $
  * ffb_drv.c: Creator/Creator3D direct rendering driver.
  *
  * Copyright (C) 2000 David S. Miller (davem@redhat.com)
  */
 
 #include <linux/config.h>
-#include "ffb.h"
-#include "drmP.h"
-
-#include "ffb_drv.h"
-
 #include <linux/sched.h>
 #include <linux/smp_lock.h>
 #include <asm/shmparam.h>
 #include <asm/oplib.h>
 #include <asm/upa.h>
 
+#include "drmP.h"
+#include "ffb_drv.h"
+
 #define DRIVER_AUTHOR		"David S. Miller"
 
 #define DRIVER_NAME		"ffb"
@@ -86,7 +84,7 @@ static void get_ffb_type(ffb_dev_priv_t 
 	};
 }
 
-static void ffb_apply_upa_parent_ranges(int parent, 
+static void ffb_apply_upa_parent_ranges(int parent,
 					struct linux_prom64_registers *regs)
 {
 	struct linux_prom64_ranges ranges[PROMREG_MAX];
@@ -136,10 +134,37 @@ static int ffb_init_one(drm_device_t *de
 	get_ffb_type(ffb_priv, instance);
 	for (i = 0; i < FFB_MAX_CTXS; i++)
 		ffb_priv->hw_state[i] = NULL;
-	
+
 	return 0;
 }
 
+static int __init ffb_count_siblings(int root)
+{
+	int node, child, count = 0;
+
+	child = prom_getchild(root);
+	for (node = prom_searchsiblings(child, "SUNW,ffb"); node;
+	     node = prom_searchsiblings(prom_getsibling(node), "SUNW,ffb"))
+		count++;
+
+	return count;
+}
+
+static int __init ffb_scan_siblings(int root, int instance)
+{
+	int node, child;
+
+	child = prom_getchild(root);
+	for (node = prom_searchsiblings(child, "SUNW,ffb"); node;
+	     node = prom_searchsiblings(prom_getsibling(node), "SUNW,ffb")) {
+		ffb_position[instance].node = node;
+		ffb_position[instance].root = root;
+		instance++;
+	}
+
+	return instance;
+}
+
 static drm_map_t *ffb_find_map(struct file *filp, unsigned long off)
 {
 	drm_file_t	*priv	= filp->private_data;
@@ -210,17 +235,30 @@ unsigned long ffb_get_unmapped_area(stru
 	return addr;
 }
 
-static int ffb_presetup(drm_device_t *dev)
+/* This functions must be here since it references drm_numdevs)
+ * which drm_drv.h declares.
+ */
+int ffb_presetup(drm_device_t *dev)
 {
 	ffb_dev_priv_t	*ffb_priv;
+	drm_device_t *temp_dev;
 	int ret = 0;
-	int i = 0;
+	int i;
 
 	/* Check for the case where no device was found. */
 	if (ffb_position == NULL)
 		return -ENODEV;
 
-	/* code used to use numdevs no numdevs anymore */
+	/* Find our instance number by finding our device in dev structure */
+	for (i = 0; i < drm_numdevs; i++) {
+		temp_dev = &(drm_device[i]);
+		if(temp_dev == dev)
+			break;
+	}
+
+	if (i == drm_numdevs)
+		return -ENODEV;
+
 	ffb_priv = kmalloc(sizeof(ffb_dev_priv_t), GFP_KERNEL);
 	if (!ffb_priv)
 		return -ENOMEM;
@@ -234,73 +272,18 @@ static int ffb_presetup(drm_device_t *de
 	return ret;
 }
 
-static void ffb_driver_release(drm_device_t *dev, struct file *filp)
-{
-	ffb_dev_priv_t *fpriv = (ffb_dev_priv_t *) dev->dev_private;
-	int context = _DRM_LOCKING_CONTEXT(dev->lock.hw_lock->lock);
-	int idx;
-
-	idx = context - 1;
-	if (fpriv &&
-	    context != DRM_KERNEL_CONTEXT &&
-	    fpriv->hw_state[idx] != NULL) {
-		kfree(fpriv->hw_state[idx]);
-		fpriv->hw_state[idx] = NULL;
-	}	
-}
+#include "drm_pciids.h"
 
-static void ffb_driver_pretakedown(drm_device_t *dev)
+static int postinit( struct drm_device *dev, unsigned long flags )
 {
-	if (dev->dev_private) kfree(dev->dev_private);
-}
-
-static int ffb_driver_postcleanup(drm_device_t *dev)
-{
-	if (ffb_position != NULL) kfree(ffb_position);
-	return 0;
-}
-
-static void ffb_driver_kernel_context_switch_unlock(struct drm_device *dev, drm_lock_t *lock)
-{
-	dev->lock.filp = 0;
-	{
-		__volatile__ unsigned int *plock = &dev->lock.hw_lock->lock;
-		unsigned int old, new, prev, ctx;
-		
-		ctx = lock->context;
-		do {
-			old  = *plock;
-			new  = ctx;
-			prev = cmpxchg(plock, old, new);
-		} while (prev != old);
-	}
-	wake_up_interruptible(&dev->lock.lock_queue);
-}
-
-static unsigned long ffb_driver_get_map_ofs(drm_map_t *map)
-{
-	return (map->offset & 0xffffffff);
-}
-
-static unsigned long ffb_driver_get_reg_ofs(drm_device_t *dev)
-{
-       ffb_dev_priv_t *ffb_priv = (ffb_dev_priv_t *)dev->dev_private;
-       
-       if (ffb_priv)
-               return ffb_priv->card_phys_base;
-       
-       return 0;
-}
-
-static int postinit( struct drm_device *dev, unsigned long flags ) 
-{
-	DRM_INFO( "Initialized %s %d.%d.%d %s on minor %d\n",
+	DRM_INFO( "Initialized %s %d.%d.%d %s on minor %d: %s\n",
 		DRIVER_NAME,
 		DRIVER_MAJOR,
 		DRIVER_MINOR,
 		DRIVER_PATCHLEVEL,
 		DRIVER_DATE,
-		dev->minor
+		dev->minor,
+		pci_pretty_name(pdev)
 		);
 	return 0;
 }
@@ -318,47 +301,58 @@ static int version( drm_version_t *versi
 	return 0;
 }
 
-static drm_ioctl_desc_t ioctls[] = {
-	
+static struct pci_device_id pciidlist[] = {
+	ffb_PCI_IDS
 };
 
-static struct drm_driver driver = {
-	.driver_features = 0,
-	.dev_priv_size = sizeof(u32),
+static struct drm_driver ffb_driver = {
 	.release = ffb_driver_release,
-	.presetup = ffb_presetup,
+	.presetup = ffb_driver_presetup,
 	.pretakedown = ffb_driver_pretakedown,
 	.postcleanup = ffb_driver_postcleanup,
-	.kernel_context_switch = ffb_driver_context_switch,
+	.kernel_context_switch = ffb_context_switch,
 	.kernel_context_switch_unlock = ffb_driver_kernel_context_switch_unlock,
 	.get_map_ofs = ffb_driver_get_map_ofs,
 	.get_reg_ofs = ffb_driver_get_reg_ofs,
+	.reclaim_buffers = drm_core_reclaim_buffers,
 	.postinit = postinit,
 	.version = version,
-	.ioctls = ioctls,
-	.num_ioctls = DRM_ARRAY_SIZE(ioctls),
-	.fops = {
-		.owner = THIS_MODULE,
-		.open = drm_open,
+	fops = {
+		.owner   = THIS_MODULE,
+		.open	 = drm_open,
 		.release = drm_release,
-		.ioctl = drm_ioctl,
-		.mmap = drm_mmap,
-		.poll = drm_poll,
-		.fasync = drm_fasync,
+		.ioctl	 = drm_ioctl,
+		.mmap	 = drm_mmap,
+		.fasync  = drm_fasync,
+		.poll    = drm_poll,
+		.get_unmapped_area = ffb_get_unmapped_area,
 	},
 };
 
+static int probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	return drm_probe(pdev, ent, &driver);
+}
+
+static struct pci_driver pci_driver = {
+	.name          = DRIVER_NAME,
+	.id_table      = pciidlist,
+	.probe         = probe,
+	.remove        = __devexit_p(drm_cleanup_pci),
+};
+
 static int __init ffb_init(void)
 {
-	return -ENODEV;
+	return drm_init(&pci_driver, pciidlist, &driver);
 }
 
 static void __exit ffb_exit(void)
 {
+	drm_exit(&pci_driver);
 }
 
 module_init(ffb_init);
-module_exit(ffb_exit);
+module_exit(ffb_exit));
 
 MODULE_AUTHOR( DRIVER_AUTHOR );
 MODULE_DESCRIPTION( DRIVER_DESC );
diff -purN linux-2.6.12.orig/drivers/char/drm/ffb_drv.h linux-2.6.12/drivers/char/drm/ffb_drv.h
--- linux-2.6.12.orig/drivers/char/drm/ffb_drv.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/ffb_drv.h	2005-07-05 08:37:30.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id: ffb_drv.h,v 1.1 2000/06/01 04:24:39 davem Exp $
+/* $Id: ffb_drv.h,v 1.5 2004/09/30 21:27:59 jonsmirl Exp $
  * ffb_drv.h: Creator/Creator3D direct rendering driver.
  *
  * Copyright (C) 2000 David S. Miller (davem@redhat.com)
@@ -78,11 +78,11 @@ typedef struct _ffb_fbc {
 						/*			fastfill(NX)	*/
 /*0x78*/unsigned int		pad6[2];	/* Reserved				*/
 /*0x80*/unsigned int		pad7[32];	/* Reserved				*/
-	
+
 	/* Setup Unit's vertex state register */
 /*100*/	volatile unsigned int	suvtx;
 /*104*/	unsigned int		pad8[63];	/* Reserved				*/
-	
+
 	/* Frame Buffer Control Registers */
 /*200*/	volatile unsigned int	ppc;		/* Pixel Processor Control		*/
 /*204*/	volatile unsigned int	wid;		/* Current WID				*/
@@ -125,7 +125,7 @@ typedef struct _ffb_fbc {
 /*298*/	volatile unsigned int	ypmask;		/* Y PlaneMask				*/
 /*29c*/	volatile unsigned int	zpmask;		/* Z PlaneMask				*/
 /*2a0*/	ffb_auxclip		auxclip[4]; 	/* Auxilliary Viewport Clip		*/
-	
+
 	/* New 3dRAM III support regs */
 /*2c0*/	volatile unsigned int	rawblend2;
 /*2c4*/	volatile unsigned int	rawpreblend;
@@ -143,7 +143,7 @@ typedef struct _ffb_fbc {
 /*2f4*/	volatile unsigned int	rawcmp;
 /*2f8*/	volatile unsigned int	rawwac;
 /*2fc*/	volatile unsigned int	fbramid;
-	
+
 /*300*/	volatile unsigned int	drawop;		/* Draw OPeration			*/
 /*304*/	unsigned int		pad10[2];	/* Reserved				*/
 /*30c*/	volatile unsigned int	lpat;		/* Line Pattern control			*/
@@ -280,7 +280,5 @@ extern unsigned long ffb_get_unmapped_ar
 					   unsigned long len,
 					   unsigned long pgoff,
 					   unsigned long flags);
-extern void ffb_set_context_ioctls(void);
-extern drm_ioctl_desc_t DRM(ioctls)[];
-
-extern int ffb_driver_context_switch(drm_device_t *dev, int old, int new);
+extern unsigned long ffb_driver_get_map_ofs(drm_map_t *map)
+extern unsigned long ffb_driver_get_reg_ofs(drm_device_t *dev)
diff -purN linux-2.6.12.orig/drivers/char/drm/gamma_context.h linux-2.6.12/drivers/char/drm/gamma_context.h
--- linux-2.6.12.orig/drivers/char/drm/gamma_context.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/gamma_context.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,492 +0,0 @@
-/* drm_context.h -- IOCTLs for generic contexts -*- linux-c -*-
- * Created: Fri Nov 24 18:31:37 2000 by gareth@valinux.com
- *
- * Copyright 1999, 2000 Precision Insight, Inc., Cedar Park, Texas.
- * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors:
- *    Rickard E. (Rik) Faith <faith@valinux.com>
- *    Gareth Hughes <gareth@valinux.com>
- * ChangeLog:
- *  2001-11-16	Torsten Duwe <duwe@caldera.de>
- *		added context constructor/destructor hooks,
- *		needed by SiS driver's memory management.
- */
-
-/* ================================================================
- * Old-style context support -- only used by gamma.  
- */
-
-
-/* The drm_read and drm_write_string code (especially that which manages
-   the circular buffer), is based on Alessandro Rubini's LINUX DEVICE
-   DRIVERS (Cambridge: O'Reilly, 1998), pages 111-113. */
-
-ssize_t gamma_fops_read(struct file *filp, char __user *buf, size_t count, loff_t *off)
-{
-	drm_file_t    *priv   = filp->private_data;
-	drm_device_t  *dev    = priv->dev;
-	int	      left;
-	int	      avail;
-	int	      send;
-	int	      cur;
-
-	DRM_DEBUG("%p, %p\n", dev->buf_rp, dev->buf_wp);
-
-	while (dev->buf_rp == dev->buf_wp) {
-		DRM_DEBUG("  sleeping\n");
-		if (filp->f_flags & O_NONBLOCK) {
-			return -EAGAIN;
-		}
-		interruptible_sleep_on(&dev->buf_readers);
-		if (signal_pending(current)) {
-			DRM_DEBUG("  interrupted\n");
-			return -ERESTARTSYS;
-		}
-		DRM_DEBUG("  awake\n");
-	}
-
-	left  = (dev->buf_rp + DRM_BSZ - dev->buf_wp) % DRM_BSZ;
-	avail = DRM_BSZ - left;
-	send  = DRM_MIN(avail, count);
-
-	while (send) {
-		if (dev->buf_wp > dev->buf_rp) {
-			cur = DRM_MIN(send, dev->buf_wp - dev->buf_rp);
-		} else {
-			cur = DRM_MIN(send, dev->buf_end - dev->buf_rp);
-		}
-		if (copy_to_user(buf, dev->buf_rp, cur))
-			return -EFAULT;
-		dev->buf_rp += cur;
-		if (dev->buf_rp == dev->buf_end) dev->buf_rp = dev->buf;
-		send -= cur;
-	}
-
-	wake_up_interruptible(&dev->buf_writers);
-	return DRM_MIN(avail, count);
-}
-
-
-/* In an incredibly convoluted setup, the kernel module actually calls
- * back into the X server to perform context switches on behalf of the
- * 3d clients.
- */
-int DRM(write_string)(drm_device_t *dev, const char *s)
-{
-	int left   = (dev->buf_rp + DRM_BSZ - dev->buf_wp) % DRM_BSZ;
-	int send   = strlen(s);
-	int count;
-
-	DRM_DEBUG("%d left, %d to send (%p, %p)\n",
-		  left, send, dev->buf_rp, dev->buf_wp);
-
-	if (left == 1 || dev->buf_wp != dev->buf_rp) {
-		DRM_ERROR("Buffer not empty (%d left, wp = %p, rp = %p)\n",
-			  left,
-			  dev->buf_wp,
-			  dev->buf_rp);
-	}
-
-	while (send) {
-		if (dev->buf_wp >= dev->buf_rp) {
-			count = DRM_MIN(send, dev->buf_end - dev->buf_wp);
-			if (count == left) --count; /* Leave a hole */
-		} else {
-			count = DRM_MIN(send, dev->buf_rp - dev->buf_wp - 1);
-		}
-		strncpy(dev->buf_wp, s, count);
-		dev->buf_wp += count;
-		if (dev->buf_wp == dev->buf_end) dev->buf_wp = dev->buf;
-		send -= count;
-	}
-
-	if (dev->buf_async) kill_fasync(&dev->buf_async, SIGIO, POLL_IN);
-
-	DRM_DEBUG("waking\n");
-	wake_up_interruptible(&dev->buf_readers);
-	return 0;
-}
-
-unsigned int gamma_fops_poll(struct file *filp, struct poll_table_struct *wait)
-{
-	drm_file_t   *priv = filp->private_data;
-	drm_device_t *dev  = priv->dev;
-
-	poll_wait(filp, &dev->buf_readers, wait);
-	if (dev->buf_wp != dev->buf_rp) return POLLIN | POLLRDNORM;
-	return 0;
-}
-
-int DRM(context_switch)(drm_device_t *dev, int old, int new)
-{
-	char	    buf[64];
-	drm_queue_t *q;
-
-	if (test_and_set_bit(0, &dev->context_flag)) {
-		DRM_ERROR("Reentering -- FIXME\n");
-		return -EBUSY;
-	}
-
-	DRM_DEBUG("Context switch from %d to %d\n", old, new);
-
-	if (new >= dev->queue_count) {
-		clear_bit(0, &dev->context_flag);
-		return -EINVAL;
-	}
-
-	if (new == dev->last_context) {
-		clear_bit(0, &dev->context_flag);
-		return 0;
-	}
-
-	q = dev->queuelist[new];
-	atomic_inc(&q->use_count);
-	if (atomic_read(&q->use_count) == 1) {
-		atomic_dec(&q->use_count);
-		clear_bit(0, &dev->context_flag);
-		return -EINVAL;
-	}
-
-	/* This causes the X server to wake up & do a bunch of hardware
-	 * interaction to actually effect the context switch.
-	 */
-	sprintf(buf, "C %d %d\n", old, new);
-	DRM(write_string)(dev, buf);
-
-	atomic_dec(&q->use_count);
-
-	return 0;
-}
-
-int DRM(context_switch_complete)(drm_device_t *dev, int new)
-{
-	drm_device_dma_t *dma = dev->dma;
-
-	dev->last_context = new;  /* PRE/POST: This is the _only_ writer. */
-	dev->last_switch  = jiffies;
-
-	if (!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
-		DRM_ERROR("Lock isn't held after context switch\n");
-	}
-
-	if (!dma || !(dma->next_buffer && dma->next_buffer->while_locked)) {
-		if (DRM(lock_free)(dev, &dev->lock.hw_lock->lock,
-				  DRM_KERNEL_CONTEXT)) {
-			DRM_ERROR("Cannot free lock\n");
-		}
-	}
-
-	clear_bit(0, &dev->context_flag);
-	wake_up_interruptible(&dev->context_wait);
-
-	return 0;
-}
-
-static int DRM(init_queue)(drm_device_t *dev, drm_queue_t *q, drm_ctx_t *ctx)
-{
-	DRM_DEBUG("\n");
-
-	if (atomic_read(&q->use_count) != 1
-	    || atomic_read(&q->finalization)
-	    || atomic_read(&q->block_count)) {
-		DRM_ERROR("New queue is already in use: u%d f%d b%d\n",
-			  atomic_read(&q->use_count),
-			  atomic_read(&q->finalization),
-			  atomic_read(&q->block_count));
-	}
-
-	atomic_set(&q->finalization,  0);
-	atomic_set(&q->block_count,   0);
-	atomic_set(&q->block_read,    0);
-	atomic_set(&q->block_write,   0);
-	atomic_set(&q->total_queued,  0);
-	atomic_set(&q->total_flushed, 0);
-	atomic_set(&q->total_locks,   0);
-
-	init_waitqueue_head(&q->write_queue);
-	init_waitqueue_head(&q->read_queue);
-	init_waitqueue_head(&q->flush_queue);
-
-	q->flags = ctx->flags;
-
-	DRM(waitlist_create)(&q->waitlist, dev->dma->buf_count);
-
-	return 0;
-}
-
-
-/* drm_alloc_queue:
-PRE: 1) dev->queuelist[0..dev->queue_count] is allocated and will not
-	disappear (so all deallocation must be done after IOCTLs are off)
-     2) dev->queue_count < dev->queue_slots
-     3) dev->queuelist[i].use_count == 0 and
-	dev->queuelist[i].finalization == 0 if i not in use
-POST: 1) dev->queuelist[i].use_count == 1
-      2) dev->queue_count < dev->queue_slots */
-
-static int DRM(alloc_queue)(drm_device_t *dev)
-{
-	int	    i;
-	drm_queue_t *queue;
-	int	    oldslots;
-	int	    newslots;
-				/* Check for a free queue */
-	for (i = 0; i < dev->queue_count; i++) {
-		atomic_inc(&dev->queuelist[i]->use_count);
-		if (atomic_read(&dev->queuelist[i]->use_count) == 1
-		    && !atomic_read(&dev->queuelist[i]->finalization)) {
-			DRM_DEBUG("%d (free)\n", i);
-			return i;
-		}
-		atomic_dec(&dev->queuelist[i]->use_count);
-	}
-				/* Allocate a new queue */
-	down(&dev->struct_sem);
-
-	queue = DRM(alloc)(sizeof(*queue), DRM_MEM_QUEUES);
-	memset(queue, 0, sizeof(*queue));
-	atomic_set(&queue->use_count, 1);
-
-	++dev->queue_count;
-	if (dev->queue_count >= dev->queue_slots) {
-		oldslots = dev->queue_slots * sizeof(*dev->queuelist);
-		if (!dev->queue_slots) dev->queue_slots = 1;
-		dev->queue_slots *= 2;
-		newslots = dev->queue_slots * sizeof(*dev->queuelist);
-
-		dev->queuelist = DRM(realloc)(dev->queuelist,
-					      oldslots,
-					      newslots,
-					      DRM_MEM_QUEUES);
-		if (!dev->queuelist) {
-			up(&dev->struct_sem);
-			DRM_DEBUG("out of memory\n");
-			return -ENOMEM;
-		}
-	}
-	dev->queuelist[dev->queue_count-1] = queue;
-
-	up(&dev->struct_sem);
-	DRM_DEBUG("%d (new)\n", dev->queue_count - 1);
-	return dev->queue_count - 1;
-}
-
-int DRM(resctx)(struct inode *inode, struct file *filp,
-		unsigned int cmd, unsigned long arg)
-{
-	drm_ctx_res_t __user *argp = (void __user *)arg;
-	drm_ctx_res_t	res;
-	drm_ctx_t	ctx;
-	int		i;
-
-	DRM_DEBUG("%d\n", DRM_RESERVED_CONTEXTS);
-	if (copy_from_user(&res, argp, sizeof(res)))
-		return -EFAULT;
-	if (res.count >= DRM_RESERVED_CONTEXTS) {
-		memset(&ctx, 0, sizeof(ctx));
-		for (i = 0; i < DRM_RESERVED_CONTEXTS; i++) {
-			ctx.handle = i;
-			if (copy_to_user(&res.contexts[i],
-					 &i,
-					 sizeof(i)))
-				return -EFAULT;
-		}
-	}
-	res.count = DRM_RESERVED_CONTEXTS;
-	if (copy_to_user(argp, &res, sizeof(res)))
-		return -EFAULT;
-	return 0;
-}
-
-int DRM(addctx)(struct inode *inode, struct file *filp,
-		unsigned int cmd, unsigned long arg)
-{
-	drm_file_t	*priv	= filp->private_data;
-	drm_device_t	*dev	= priv->dev;
-	drm_ctx_t	ctx;
-	drm_ctx_t	__user *argp = (void __user *)arg;
-
-	if (copy_from_user(&ctx, argp, sizeof(ctx)))
-		return -EFAULT;
-	if ((ctx.handle = DRM(alloc_queue)(dev)) == DRM_KERNEL_CONTEXT) {
-				/* Init kernel's context and get a new one. */
-		DRM(init_queue)(dev, dev->queuelist[ctx.handle], &ctx);
-		ctx.handle = DRM(alloc_queue)(dev);
-	}
-	DRM(init_queue)(dev, dev->queuelist[ctx.handle], &ctx);
-	DRM_DEBUG("%d\n", ctx.handle);
-	if (copy_to_user(argp, &ctx, sizeof(ctx)))
-		return -EFAULT;
-	return 0;
-}
-
-int DRM(modctx)(struct inode *inode, struct file *filp,
-		unsigned int cmd, unsigned long arg)
-{
-	drm_file_t	*priv	= filp->private_data;
-	drm_device_t	*dev	= priv->dev;
-	drm_ctx_t	ctx;
-	drm_queue_t	*q;
-
-	if (copy_from_user(&ctx, (drm_ctx_t __user *)arg, sizeof(ctx)))
-		return -EFAULT;
-
-	DRM_DEBUG("%d\n", ctx.handle);
-
-	if (ctx.handle < 0 || ctx.handle >= dev->queue_count) return -EINVAL;
-	q = dev->queuelist[ctx.handle];
-
-	atomic_inc(&q->use_count);
-	if (atomic_read(&q->use_count) == 1) {
-				/* No longer in use */
-		atomic_dec(&q->use_count);
-		return -EINVAL;
-	}
-
-	if (DRM_BUFCOUNT(&q->waitlist)) {
-		atomic_dec(&q->use_count);
-		return -EBUSY;
-	}
-
-	q->flags = ctx.flags;
-
-	atomic_dec(&q->use_count);
-	return 0;
-}
-
-int DRM(getctx)(struct inode *inode, struct file *filp,
-		unsigned int cmd, unsigned long arg)
-{
-	drm_file_t	*priv	= filp->private_data;
-	drm_device_t	*dev	= priv->dev;
-	drm_ctx_t	__user *argp = (void __user *)arg;
-	drm_ctx_t	ctx;
-	drm_queue_t	*q;
-
-	if (copy_from_user(&ctx, argp, sizeof(ctx)))
-		return -EFAULT;
-
-	DRM_DEBUG("%d\n", ctx.handle);
-
-	if (ctx.handle >= dev->queue_count) return -EINVAL;
-	q = dev->queuelist[ctx.handle];
-
-	atomic_inc(&q->use_count);
-	if (atomic_read(&q->use_count) == 1) {
-				/* No longer in use */
-		atomic_dec(&q->use_count);
-		return -EINVAL;
-	}
-
-	ctx.flags = q->flags;
-	atomic_dec(&q->use_count);
-
-	if (copy_to_user(argp, &ctx, sizeof(ctx)))
-		return -EFAULT;
-
-	return 0;
-}
-
-int DRM(switchctx)(struct inode *inode, struct file *filp,
-		   unsigned int cmd, unsigned long arg)
-{
-	drm_file_t	*priv	= filp->private_data;
-	drm_device_t	*dev	= priv->dev;
-	drm_ctx_t	ctx;
-
-	if (copy_from_user(&ctx, (drm_ctx_t __user *)arg, sizeof(ctx)))
-		return -EFAULT;
-	DRM_DEBUG("%d\n", ctx.handle);
-	return DRM(context_switch)(dev, dev->last_context, ctx.handle);
-}
-
-int DRM(newctx)(struct inode *inode, struct file *filp,
-		unsigned int cmd, unsigned long arg)
-{
-	drm_file_t	*priv	= filp->private_data;
-	drm_device_t	*dev	= priv->dev;
-	drm_ctx_t	ctx;
-
-	if (copy_from_user(&ctx, (drm_ctx_t __user *)arg, sizeof(ctx)))
-		return -EFAULT;
-	DRM_DEBUG("%d\n", ctx.handle);
-	DRM(context_switch_complete)(dev, ctx.handle);
-
-	return 0;
-}
-
-int DRM(rmctx)(struct inode *inode, struct file *filp,
-	       unsigned int cmd, unsigned long arg)
-{
-	drm_file_t	*priv	= filp->private_data;
-	drm_device_t	*dev	= priv->dev;
-	drm_ctx_t	ctx;
-	drm_queue_t	*q;
-	drm_buf_t	*buf;
-
-	if (copy_from_user(&ctx, (drm_ctx_t __user *)arg, sizeof(ctx)))
-		return -EFAULT;
-	DRM_DEBUG("%d\n", ctx.handle);
-
-	if (ctx.handle >= dev->queue_count) return -EINVAL;
-	q = dev->queuelist[ctx.handle];
-
-	atomic_inc(&q->use_count);
-	if (atomic_read(&q->use_count) == 1) {
-				/* No longer in use */
-		atomic_dec(&q->use_count);
-		return -EINVAL;
-	}
-
-	atomic_inc(&q->finalization); /* Mark queue in finalization state */
-	atomic_sub(2, &q->use_count); /* Mark queue as unused (pending
-					 finalization) */
-
-	while (test_and_set_bit(0, &dev->interrupt_flag)) {
-		schedule();
-		if (signal_pending(current)) {
-			clear_bit(0, &dev->interrupt_flag);
-			return -EINTR;
-		}
-	}
-				/* Remove queued buffers */
-	while ((buf = DRM(waitlist_get)(&q->waitlist))) {
-		DRM(free_buffer)(dev, buf);
-	}
-	clear_bit(0, &dev->interrupt_flag);
-
-				/* Wakeup blocked processes */
-	wake_up_interruptible(&q->read_queue);
-	wake_up_interruptible(&q->write_queue);
-	wake_up_interruptible(&q->flush_queue);
-
-				/* Finalization over.  Queue is made
-				   available when both use_count and
-				   finalization become 0, which won't
-				   happen until all the waiting processes
-				   stop waiting. */
-	atomic_dec(&q->finalization);
-	return 0;
-}
-
diff -purN linux-2.6.12.orig/drivers/char/drm/gamma_dma.c linux-2.6.12/drivers/char/drm/gamma_dma.c
--- linux-2.6.12.orig/drivers/char/drm/gamma_dma.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/gamma_dma.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,946 +0,0 @@
-/* gamma_dma.c -- DMA support for GMX 2000 -*- linux-c -*-
- * Created: Fri Mar 19 14:30:16 1999 by faith@precisioninsight.com
- *
- * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
- * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Authors:
- *    Rickard E. (Rik) Faith <faith@valinux.com>
- *
- */
-
-#include "gamma.h"
-#include "drmP.h"
-#include "drm.h"
-#include "gamma_drm.h"
-#include "gamma_drv.h"
-
-#include <linux/interrupt.h>	/* For task queue support */
-#include <linux/delay.h>
-
-static inline void gamma_dma_dispatch(drm_device_t *dev, unsigned long address,
-				      unsigned long length)
-{
-	drm_gamma_private_t *dev_priv =
-				(drm_gamma_private_t *)dev->dev_private;
-	mb();
-	while ( GAMMA_READ(GAMMA_INFIFOSPACE) < 2)
-		cpu_relax();
-
-	GAMMA_WRITE(GAMMA_DMAADDRESS, address);
-
-	while (GAMMA_READ(GAMMA_GCOMMANDSTATUS) != 4)
-		cpu_relax();
-
-	GAMMA_WRITE(GAMMA_DMACOUNT, length / 4);
-}
-
-void gamma_dma_quiescent_single(drm_device_t *dev)
-{
-	drm_gamma_private_t *dev_priv =
-				(drm_gamma_private_t *)dev->dev_private;
-	while (GAMMA_READ(GAMMA_DMACOUNT))
-		cpu_relax();
-
-	while (GAMMA_READ(GAMMA_INFIFOSPACE) < 2)
-		cpu_relax();
-
-	GAMMA_WRITE(GAMMA_FILTERMODE, 1 << 10);
-	GAMMA_WRITE(GAMMA_SYNC, 0);
-
-	do {
-		while (!GAMMA_READ(GAMMA_OUTFIFOWORDS))
-			cpu_relax();
-	} while (GAMMA_READ(GAMMA_OUTPUTFIFO) != GAMMA_SYNC_TAG);
-}
-
-void gamma_dma_quiescent_dual(drm_device_t *dev)
-{
-	drm_gamma_private_t *dev_priv =
-				(drm_gamma_private_t *)dev->dev_private;
-	while (GAMMA_READ(GAMMA_DMACOUNT))
-		cpu_relax();
-
-	while (GAMMA_READ(GAMMA_INFIFOSPACE) < 3)
-		cpu_relax();
-
-	GAMMA_WRITE(GAMMA_BROADCASTMASK, 3);
-	GAMMA_WRITE(GAMMA_FILTERMODE, 1 << 10);
-	GAMMA_WRITE(GAMMA_SYNC, 0);
-
-	/* Read from first MX */
-	do {
-		while (!GAMMA_READ(GAMMA_OUTFIFOWORDS))
-			cpu_relax();
-	} while (GAMMA_READ(GAMMA_OUTPUTFIFO) != GAMMA_SYNC_TAG);
-
-	/* Read from second MX */
-	do {
-		while (!GAMMA_READ(GAMMA_OUTFIFOWORDS + 0x10000))
-			cpu_relax();
-	} while (GAMMA_READ(GAMMA_OUTPUTFIFO + 0x10000) != GAMMA_SYNC_TAG);
-}
-
-void gamma_dma_ready(drm_device_t *dev)
-{
-	drm_gamma_private_t *dev_priv =
-				(drm_gamma_private_t *)dev->dev_private;
-	while (GAMMA_READ(GAMMA_DMACOUNT))
-		cpu_relax();
-}
-
-static inline int gamma_dma_is_ready(drm_device_t *dev)
-{
-	drm_gamma_private_t *dev_priv =
-				(drm_gamma_private_t *)dev->dev_private;
-	return (!GAMMA_READ(GAMMA_DMACOUNT));
-}
-
-irqreturn_t gamma_driver_irq_handler( DRM_IRQ_ARGS )
-{
-	drm_device_t	 *dev = (drm_device_t *)arg;
-	drm_device_dma_t *dma = dev->dma;
-	drm_gamma_private_t *dev_priv =
-				(drm_gamma_private_t *)dev->dev_private;
-
-	/* FIXME: should check whether we're actually interested in the interrupt? */
-	atomic_inc(&dev->counts[6]); /* _DRM_STAT_IRQ */
-
-	while (GAMMA_READ(GAMMA_INFIFOSPACE) < 3)
-		cpu_relax();
-
-	GAMMA_WRITE(GAMMA_GDELAYTIMER, 0xc350/2); /* 0x05S */
-	GAMMA_WRITE(GAMMA_GCOMMANDINTFLAGS, 8);
-	GAMMA_WRITE(GAMMA_GINTFLAGS, 0x2001);
-	if (gamma_dma_is_ready(dev)) {
-				/* Free previous buffer */
-		if (test_and_set_bit(0, &dev->dma_flag))
-			return IRQ_HANDLED;
-		if (dma->this_buffer) {
-			gamma_free_buffer(dev, dma->this_buffer);
-			dma->this_buffer = NULL;
-		}
-		clear_bit(0, &dev->dma_flag);
-
-		/* Dispatch new buffer */
-		schedule_work(&dev->work);
-	}
-	return IRQ_HANDLED;
-}
-
-/* Only called by gamma_dma_schedule. */
-static int gamma_do_dma(drm_device_t *dev, int locked)
-{
-	unsigned long	 address;
-	unsigned long	 length;
-	drm_buf_t	 *buf;
-	int		 retcode = 0;
-	drm_device_dma_t *dma = dev->dma;
-
-	if (test_and_set_bit(0, &dev->dma_flag)) return -EBUSY;
-
-
-	if (!dma->next_buffer) {
-		DRM_ERROR("No next_buffer\n");
-		clear_bit(0, &dev->dma_flag);
-		return -EINVAL;
-	}
-
-	buf	= dma->next_buffer;
-	/* WE NOW ARE ON LOGICAL PAGES!! - using page table setup in dma_init */
-	/* So we pass the buffer index value into the physical page offset */
-	address = buf->idx << 12;
-	length	= buf->used;
-
-	DRM_DEBUG("context %d, buffer %d (%ld bytes)\n",
-		  buf->context, buf->idx, length);
-
-	if (buf->list == DRM_LIST_RECLAIM) {
-		gamma_clear_next_buffer(dev);
-		gamma_free_buffer(dev, buf);
-		clear_bit(0, &dev->dma_flag);
-		return -EINVAL;
-	}
-
-	if (!length) {
-		DRM_ERROR("0 length buffer\n");
-		gamma_clear_next_buffer(dev);
-		gamma_free_buffer(dev, buf);
-		clear_bit(0, &dev->dma_flag);
-		return 0;
-	}
-
-	if (!gamma_dma_is_ready(dev)) {
-		clear_bit(0, &dev->dma_flag);
-		return -EBUSY;
-	}
-
-	if (buf->while_locked) {
-		if (!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
-			DRM_ERROR("Dispatching buffer %d from pid %d"
-				  " \"while locked\", but no lock held\n",
-				  buf->idx, current->pid);
-		}
-	} else {
-		if (!locked && !gamma_lock_take(&dev->lock.hw_lock->lock,
-					      DRM_KERNEL_CONTEXT)) {
-			clear_bit(0, &dev->dma_flag);
-			return -EBUSY;
-		}
-	}
-
-	if (dev->last_context != buf->context
-	    && !(dev->queuelist[buf->context]->flags
-		 & _DRM_CONTEXT_PRESERVED)) {
-				/* PRE: dev->last_context != buf->context */
-		if (DRM(context_switch)(dev, dev->last_context,
-					buf->context)) {
-			DRM(clear_next_buffer)(dev);
-			DRM(free_buffer)(dev, buf);
-		}
-		retcode = -EBUSY;
-		goto cleanup;
-
-				/* POST: we will wait for the context
-				   switch and will dispatch on a later call
-				   when dev->last_context == buf->context.
-				   NOTE WE HOLD THE LOCK THROUGHOUT THIS
-				   TIME! */
-	}
-
-	gamma_clear_next_buffer(dev);
-	buf->pending	 = 1;
-	buf->waiting	 = 0;
-	buf->list	 = DRM_LIST_PEND;
-
-	/* WE NOW ARE ON LOGICAL PAGES!!! - overriding address */
-	address = buf->idx << 12;
-
-	gamma_dma_dispatch(dev, address, length);
-	gamma_free_buffer(dev, dma->this_buffer);
-	dma->this_buffer = buf;
-
-	atomic_inc(&dev->counts[7]); /* _DRM_STAT_DMA */
-	atomic_add(length, &dev->counts[8]); /* _DRM_STAT_PRIMARY */
-
-	if (!buf->while_locked && !dev->context_flag && !locked) {
-		if (gamma_lock_free(dev, &dev->lock.hw_lock->lock,
-				  DRM_KERNEL_CONTEXT)) {
-			DRM_ERROR("\n");
-		}
-	}
-cleanup:
-
-	clear_bit(0, &dev->dma_flag);
-
-
-	return retcode;
-}
-
-static void gamma_dma_timer_bh(unsigned long dev)
-{
-	gamma_dma_schedule((drm_device_t *)dev, 0);
-}
-
-void gamma_irq_immediate_bh(void *dev)
-{
-	gamma_dma_schedule(dev, 0);
-}
-
-int gamma_dma_schedule(drm_device_t *dev, int locked)
-{
-	int		 next;
-	drm_queue_t	 *q;
-	drm_buf_t	 *buf;
-	int		 retcode   = 0;
-	int		 processed = 0;
-	int		 missed;
-	int		 expire	   = 20;
-	drm_device_dma_t *dma	   = dev->dma;
-
-	if (test_and_set_bit(0, &dev->interrupt_flag)) {
-				/* Not reentrant */
-		atomic_inc(&dev->counts[10]); /* _DRM_STAT_MISSED */
-		return -EBUSY;
-	}
-	missed = atomic_read(&dev->counts[10]);
-
-
-again:
-	if (dev->context_flag) {
-		clear_bit(0, &dev->interrupt_flag);
-		return -EBUSY;
-	}
-	if (dma->next_buffer) {
-				/* Unsent buffer that was previously
-				   selected, but that couldn't be sent
-				   because the lock could not be obtained
-				   or the DMA engine wasn't ready.  Try
-				   again. */
-		if (!(retcode = gamma_do_dma(dev, locked))) ++processed;
-	} else {
-		do {
-			next = gamma_select_queue(dev, gamma_dma_timer_bh);
-			if (next >= 0) {
-				q   = dev->queuelist[next];
-				buf = gamma_waitlist_get(&q->waitlist);
-				dma->next_buffer = buf;
-				dma->next_queue	 = q;
-				if (buf && buf->list == DRM_LIST_RECLAIM) {
-					gamma_clear_next_buffer(dev);
-					gamma_free_buffer(dev, buf);
-				}
-			}
-		} while (next >= 0 && !dma->next_buffer);
-		if (dma->next_buffer) {
-			if (!(retcode = gamma_do_dma(dev, locked))) {
-				++processed;
-			}
-		}
-	}
-
-	if (--expire) {
-		if (missed != atomic_read(&dev->counts[10])) {
-			if (gamma_dma_is_ready(dev)) goto again;
-		}
-		if (processed && gamma_dma_is_ready(dev)) {
-			processed = 0;
-			goto again;
-		}
-	}
-
-	clear_bit(0, &dev->interrupt_flag);
-
-	return retcode;
-}
-
-static int gamma_dma_priority(struct file *filp, 
-			      drm_device_t *dev, drm_dma_t *d)
-{
-	unsigned long	  address;
-	unsigned long	  length;
-	int		  must_free = 0;
-	int		  retcode   = 0;
-	int		  i;
-	int		  idx;
-	drm_buf_t	  *buf;
-	drm_buf_t	  *last_buf = NULL;
-	drm_device_dma_t  *dma	    = dev->dma;
-	int		  *send_indices = NULL;
-	int		  *send_sizes = NULL;
-
-	DECLARE_WAITQUEUE(entry, current);
-
-				/* Turn off interrupt handling */
-	while (test_and_set_bit(0, &dev->interrupt_flag)) {
-		schedule();
-		if (signal_pending(current)) return -EINTR;
-	}
-	if (!(d->flags & _DRM_DMA_WHILE_LOCKED)) {
-		while (!gamma_lock_take(&dev->lock.hw_lock->lock,
-				      DRM_KERNEL_CONTEXT)) {
-			schedule();
-			if (signal_pending(current)) {
-				clear_bit(0, &dev->interrupt_flag);
-				return -EINTR;
-			}
-		}
-		++must_free;
-	}
-
-	send_indices = DRM(alloc)(d->send_count * sizeof(*send_indices),
-				  DRM_MEM_DRIVER);
-	if (send_indices == NULL)
-		return -ENOMEM;
-	if (copy_from_user(send_indices, d->send_indices, 
-			   d->send_count * sizeof(*send_indices))) {
-		retcode = -EFAULT;
-                goto cleanup;
-	}
-	
-	send_sizes = DRM(alloc)(d->send_count * sizeof(*send_sizes),
-				DRM_MEM_DRIVER);
-	if (send_sizes == NULL)
-		return -ENOMEM;
-	if (copy_from_user(send_sizes, d->send_sizes, 
-			   d->send_count * sizeof(*send_sizes))) {
-		retcode = -EFAULT;
-                goto cleanup;
-	}
-
-	for (i = 0; i < d->send_count; i++) {
-		idx = send_indices[i];
-		if (idx < 0 || idx >= dma->buf_count) {
-			DRM_ERROR("Index %d (of %d max)\n",
-				  send_indices[i], dma->buf_count - 1);
-			continue;
-		}
-		buf = dma->buflist[ idx ];
-		if (buf->filp != filp) {
-			DRM_ERROR("Process %d using buffer not owned\n",
-				  current->pid);
-			retcode = -EINVAL;
-			goto cleanup;
-		}
-		if (buf->list != DRM_LIST_NONE) {
-			DRM_ERROR("Process %d using buffer on list %d\n",
-				  current->pid, buf->list);
-			retcode = -EINVAL;
-			goto cleanup;
-		}
-				/* This isn't a race condition on
-				   buf->list, since our concern is the
-				   buffer reclaim during the time the
-				   process closes the /dev/drm? handle, so
-				   it can't also be doing DMA. */
-		buf->list	  = DRM_LIST_PRIO;
-		buf->used	  = send_sizes[i];
-		buf->context	  = d->context;
-		buf->while_locked = d->flags & _DRM_DMA_WHILE_LOCKED;
-		address		  = (unsigned long)buf->address;
-		length		  = buf->used;
-		if (!length) {
-			DRM_ERROR("0 length buffer\n");
-		}
-		if (buf->pending) {
-			DRM_ERROR("Sending pending buffer:"
-				  " buffer %d, offset %d\n",
-				  send_indices[i], i);
-			retcode = -EINVAL;
-			goto cleanup;
-		}
-		if (buf->waiting) {
-			DRM_ERROR("Sending waiting buffer:"
-				  " buffer %d, offset %d\n",
-				  send_indices[i], i);
-			retcode = -EINVAL;
-			goto cleanup;
-		}
-		buf->pending = 1;
-
-		if (dev->last_context != buf->context
-		    && !(dev->queuelist[buf->context]->flags
-			 & _DRM_CONTEXT_PRESERVED)) {
-			add_wait_queue(&dev->context_wait, &entry);
-			current->state = TASK_INTERRUPTIBLE;
-				/* PRE: dev->last_context != buf->context */
-			DRM(context_switch)(dev, dev->last_context,
-					    buf->context);
-				/* POST: we will wait for the context
-				   switch and will dispatch on a later call
-				   when dev->last_context == buf->context.
-				   NOTE WE HOLD THE LOCK THROUGHOUT THIS
-				   TIME! */
-			schedule();
-			current->state = TASK_RUNNING;
-			remove_wait_queue(&dev->context_wait, &entry);
-			if (signal_pending(current)) {
-				retcode = -EINTR;
-				goto cleanup;
-			}
-			if (dev->last_context != buf->context) {
-				DRM_ERROR("Context mismatch: %d %d\n",
-					  dev->last_context,
-					  buf->context);
-			}
-		}
-
-		gamma_dma_dispatch(dev, address, length);
-		atomic_inc(&dev->counts[9]); /* _DRM_STAT_SPECIAL */
-		atomic_add(length, &dev->counts[8]); /* _DRM_STAT_PRIMARY */
-
-		if (last_buf) {
-			gamma_free_buffer(dev, last_buf);
-		}
-		last_buf = buf;
-	}
-
-
-cleanup:
-	if (last_buf) {
-		gamma_dma_ready(dev);
-		gamma_free_buffer(dev, last_buf);
-	}
-	if (send_indices)
-		DRM(free)(send_indices, d->send_count * sizeof(*send_indices), 
-			  DRM_MEM_DRIVER);
-	if (send_sizes)
-		DRM(free)(send_sizes, d->send_count * sizeof(*send_sizes), 
-			  DRM_MEM_DRIVER);
-
-	if (must_free && !dev->context_flag) {
-		if (gamma_lock_free(dev, &dev->lock.hw_lock->lock,
-				  DRM_KERNEL_CONTEXT)) {
-			DRM_ERROR("\n");
-		}
-	}
-	clear_bit(0, &dev->interrupt_flag);
-	return retcode;
-}
-
-static int gamma_dma_send_buffers(struct file *filp,
-				  drm_device_t *dev, drm_dma_t *d)
-{
-	DECLARE_WAITQUEUE(entry, current);
-	drm_buf_t	  *last_buf = NULL;
-	int		  retcode   = 0;
-	drm_device_dma_t  *dma	    = dev->dma;
-	int               send_index;
-
-	if (get_user(send_index, &d->send_indices[d->send_count-1]))
-		return -EFAULT;
-
-	if (d->flags & _DRM_DMA_BLOCK) {
-		last_buf = dma->buflist[send_index];
-		add_wait_queue(&last_buf->dma_wait, &entry);
-	}
-
-	if ((retcode = gamma_dma_enqueue(filp, d))) {
-		if (d->flags & _DRM_DMA_BLOCK)
-			remove_wait_queue(&last_buf->dma_wait, &entry);
-		return retcode;
-	}
-
-	gamma_dma_schedule(dev, 0);
-
-	if (d->flags & _DRM_DMA_BLOCK) {
-		DRM_DEBUG("%d waiting\n", current->pid);
-		for (;;) {
-			current->state = TASK_INTERRUPTIBLE;
-			if (!last_buf->waiting && !last_buf->pending)
-				break; /* finished */
-			schedule();
-			if (signal_pending(current)) {
-				retcode = -EINTR; /* Can't restart */
-				break;
-			}
-		}
-		current->state = TASK_RUNNING;
-		DRM_DEBUG("%d running\n", current->pid);
-		remove_wait_queue(&last_buf->dma_wait, &entry);
-		if (!retcode
-		    || (last_buf->list==DRM_LIST_PEND && !last_buf->pending)) {
-			if (!waitqueue_active(&last_buf->dma_wait)) {
-				gamma_free_buffer(dev, last_buf);
-			}
-		}
-		if (retcode) {
-			DRM_ERROR("ctx%d w%d p%d c%ld i%d l%d pid:%d\n",
-				  d->context,
-				  last_buf->waiting,
-				  last_buf->pending,
-				  (long)DRM_WAITCOUNT(dev, d->context),
-				  last_buf->idx,
-				  last_buf->list,
-				  current->pid);
-		}
-	}
-	return retcode;
-}
-
-int gamma_dma(struct inode *inode, struct file *filp, unsigned int cmd,
-	      unsigned long arg)
-{
-	drm_file_t	  *priv	    = filp->private_data;
-	drm_device_t	  *dev	    = priv->dev;
-	drm_device_dma_t  *dma	    = dev->dma;
-	int		  retcode   = 0;
-	drm_dma_t	  __user *argp = (void __user *)arg;
-	drm_dma_t	  d;
-
-	if (copy_from_user(&d, argp, sizeof(d)))
-		return -EFAULT;
-
-	if (d.send_count < 0 || d.send_count > dma->buf_count) {
-		DRM_ERROR("Process %d trying to send %d buffers (of %d max)\n",
-			  current->pid, d.send_count, dma->buf_count);
-		return -EINVAL;
-	}
-
-	if (d.request_count < 0 || d.request_count > dma->buf_count) {
-		DRM_ERROR("Process %d trying to get %d buffers (of %d max)\n",
-			  current->pid, d.request_count, dma->buf_count);
-		return -EINVAL;
-	}
-
-	if (d.send_count) {
-		if (d.flags & _DRM_DMA_PRIORITY)
-			retcode = gamma_dma_priority(filp, dev, &d);
-		else
-			retcode = gamma_dma_send_buffers(filp, dev, &d);
-	}
-
-	d.granted_count = 0;
-
-	if (!retcode && d.request_count) {
-		retcode = gamma_dma_get_buffers(filp, &d);
-	}
-
-	DRM_DEBUG("%d returning, granted = %d\n",
-		  current->pid, d.granted_count);
-	if (copy_to_user(argp, &d, sizeof(d)))
-		return -EFAULT;
-
-	return retcode;
-}
-
-/* =============================================================
- * DMA initialization, cleanup
- */
-
-static int gamma_do_init_dma( drm_device_t *dev, drm_gamma_init_t *init )
-{
-	drm_gamma_private_t *dev_priv;
-	drm_device_dma_t    *dma = dev->dma;
-	drm_buf_t	    *buf;
-	int i;
-	struct list_head    *list;
-	unsigned long	    *pgt;
-
-	DRM_DEBUG( "%s\n", __FUNCTION__ );
-
-	dev_priv = DRM(alloc)( sizeof(drm_gamma_private_t),
-							DRM_MEM_DRIVER );
-	if ( !dev_priv )
-		return -ENOMEM;
-
-	dev->dev_private = (void *)dev_priv;
-
-	memset( dev_priv, 0, sizeof(drm_gamma_private_t) );
-
-	dev_priv->num_rast = init->num_rast;
-
-	list_for_each(list, &dev->maplist->head) {
-		drm_map_list_t *r_list = list_entry(list, drm_map_list_t, head);
-		if( r_list->map &&
-		    r_list->map->type == _DRM_SHM &&
-		    r_list->map->flags & _DRM_CONTAINS_LOCK ) {
-			dev_priv->sarea = r_list->map;
- 			break;
- 		}
- 	}
-	
-	dev_priv->mmio0 = drm_core_findmap(dev, init->mmio0);
-	dev_priv->mmio1 = drm_core_findmap(dev, init->mmio1);
-	dev_priv->mmio2 = drm_core_findmap(dev, init->mmio2);
-	dev_priv->mmio3 = drm_core_findmap(dev, init->mmio3);
-	
-	dev_priv->sarea_priv = (drm_gamma_sarea_t *)
-		((u8 *)dev_priv->sarea->handle +
-		 init->sarea_priv_offset);
-
-	if (init->pcimode) {
-		buf = dma->buflist[GLINT_DRI_BUF_COUNT];
-		pgt = buf->address;
-
- 		for (i = 0; i < GLINT_DRI_BUF_COUNT; i++) {
-			buf = dma->buflist[i];
-			*pgt = virt_to_phys((void*)buf->address) | 0x07;
-			pgt++;
-		}
-
-		buf = dma->buflist[GLINT_DRI_BUF_COUNT];
-	} else {
-		dev->agp_buffer_map = drm_core_findmap(dev, init->buffers_offset);
-		drm_core_ioremap( dev->agp_buffer_map, dev);
-
-		buf = dma->buflist[GLINT_DRI_BUF_COUNT];
-		pgt = buf->address;
-
- 		for (i = 0; i < GLINT_DRI_BUF_COUNT; i++) {
-			buf = dma->buflist[i];
-			*pgt = (unsigned long)buf->address + 0x07;
-			pgt++;
-		}
-
-		buf = dma->buflist[GLINT_DRI_BUF_COUNT];
-
-		while (GAMMA_READ(GAMMA_INFIFOSPACE) < 1);
-		GAMMA_WRITE( GAMMA_GDMACONTROL, 0xe);
-	}
-	while (GAMMA_READ(GAMMA_INFIFOSPACE) < 2);
-	GAMMA_WRITE( GAMMA_PAGETABLEADDR, virt_to_phys((void*)buf->address) );
-	GAMMA_WRITE( GAMMA_PAGETABLELENGTH, 2 );
-
-	return 0;
-}
-
-int gamma_do_cleanup_dma( drm_device_t *dev )
-{
-	DRM_DEBUG( "%s\n", __FUNCTION__ );
-
-	/* Make sure interrupts are disabled here because the uninstall ioctl
-	 * may not have been called from userspace and after dev_private
-	 * is freed, it's too late.
-	 */
-	if (drm_core_check_feature(dev, DRIVER_HAVE_IRQ))
-		if ( dev->irq_enabled ) 
-			DRM(irq_uninstall)(dev);
-
-	if ( dev->dev_private ) {
-
-		if ( dev->agp_buffer_map != NULL )
-			drm_core_ioremapfree( dev->agp_buffer_map, dev );
-
-		DRM(free)( dev->dev_private, sizeof(drm_gamma_private_t),
-			   DRM_MEM_DRIVER );
-		dev->dev_private = NULL;
-	}
-
-	return 0;
-}
-
-int gamma_dma_init( struct inode *inode, struct file *filp,
-		  unsigned int cmd, unsigned long arg )
-{
-	drm_file_t *priv = filp->private_data;
-	drm_device_t *dev = priv->dev;
-	drm_gamma_init_t init;
-
-	LOCK_TEST_WITH_RETURN( dev, filp );
-
-	if ( copy_from_user( &init, (drm_gamma_init_t __user *)arg, sizeof(init) ) )
-		return -EFAULT;
-
-	switch ( init.func ) {
-	case GAMMA_INIT_DMA:
-		return gamma_do_init_dma( dev, &init );
-	case GAMMA_CLEANUP_DMA:
-		return gamma_do_cleanup_dma( dev );
-	}
-
-	return -EINVAL;
-}
-
-static int gamma_do_copy_dma( drm_device_t *dev, drm_gamma_copy_t *copy )
-{
-	drm_device_dma_t    *dma = dev->dma;
-	unsigned int        *screenbuf;
-
-	DRM_DEBUG( "%s\n", __FUNCTION__ );
-
-	/* We've DRM_RESTRICTED this DMA buffer */
-
-	screenbuf = dma->buflist[ GLINT_DRI_BUF_COUNT + 1 ]->address;
-
-#if 0
-	*buffer++ = 0x180;	/* Tag (FilterMode) */
-	*buffer++ = 0x200;	/* Allow FBColor through */
-	*buffer++ = 0x53B;	/* Tag */
-	*buffer++ = copy->Pitch;
-	*buffer++ = 0x53A;	/* Tag */
-	*buffer++ = copy->SrcAddress;
-	*buffer++ = 0x539;	/* Tag */
-	*buffer++ = copy->WidthHeight; /* Initiates transfer */
-	*buffer++ = 0x53C;	/* Tag - DMAOutputAddress */
-	*buffer++ = virt_to_phys((void*)screenbuf);
-	*buffer++ = 0x53D;	/* Tag - DMAOutputCount */
-	*buffer++ = copy->Count; /* Reads HostOutFifo BLOCKS until ..*/
-
-	/* Data now sitting in dma->buflist[ GLINT_DRI_BUF_COUNT + 1 ] */
-	/* Now put it back to the screen */
-
-	*buffer++ = 0x180;	/* Tag (FilterMode) */
-	*buffer++ = 0x400;	/* Allow Sync through */
-	*buffer++ = 0x538;	/* Tag - DMARectangleReadTarget */
-	*buffer++ = 0x155;	/* FBSourceData | count */
-	*buffer++ = 0x537;	/* Tag */
-	*buffer++ = copy->Pitch;
-	*buffer++ = 0x536;	/* Tag */
-	*buffer++ = copy->DstAddress;
-	*buffer++ = 0x535;	/* Tag */
-	*buffer++ = copy->WidthHeight; /* Initiates transfer */
-	*buffer++ = 0x530;	/* Tag - DMAAddr */
-	*buffer++ = virt_to_phys((void*)screenbuf);
-	*buffer++ = 0x531;
-	*buffer++ = copy->Count; /* initiates DMA transfer of color data */
-#endif
-
-	/* need to dispatch it now */
-
-	return 0;
-}
-
-int gamma_dma_copy( struct inode *inode, struct file *filp,
-		  unsigned int cmd, unsigned long arg )
-{
-	drm_file_t *priv = filp->private_data;
-	drm_device_t *dev = priv->dev;
-	drm_gamma_copy_t copy;
-
-	if ( copy_from_user( &copy, (drm_gamma_copy_t __user *)arg, sizeof(copy) ) )
-		return -EFAULT;
-
-	return gamma_do_copy_dma( dev, &copy );
-}
-
-/* =============================================================
- * Per Context SAREA Support
- */
-
-int gamma_getsareactx(struct inode *inode, struct file *filp,
-		     unsigned int cmd, unsigned long arg)
-{
-	drm_file_t	*priv	= filp->private_data;
-	drm_device_t	*dev	= priv->dev;
-	drm_ctx_priv_map_t __user *argp = (void __user *)arg;
-	drm_ctx_priv_map_t request;
-	drm_map_t *map;
-
-	if (copy_from_user(&request, argp, sizeof(request)))
-		return -EFAULT;
-
-	down(&dev->struct_sem);
-	if ((int)request.ctx_id >= dev->max_context) {
-		up(&dev->struct_sem);
-		return -EINVAL;
-	}
-
-	map = dev->context_sareas[request.ctx_id];
-	up(&dev->struct_sem);
-
-	request.handle = map->handle;
-	if (copy_to_user(argp, &request, sizeof(request)))
-		return -EFAULT;
-	return 0;
-}
-
-int gamma_setsareactx(struct inode *inode, struct file *filp,
-		     unsigned int cmd, unsigned long arg)
-{
-	drm_file_t	*priv	= filp->private_data;
-	drm_device_t	*dev	= priv->dev;
-	drm_ctx_priv_map_t request;
-	drm_map_t *map = NULL;
-	drm_map_list_t *r_list;
-	struct list_head *list;
-
-	if (copy_from_user(&request,
-			   (drm_ctx_priv_map_t __user *)arg,
-			   sizeof(request)))
-		return -EFAULT;
-
-	down(&dev->struct_sem);
-	r_list = NULL;
-	list_for_each(list, &dev->maplist->head) {
-		r_list = list_entry(list, drm_map_list_t, head);
-		if(r_list->map &&
-		   r_list->map->handle == request.handle) break;
-	}
-	if (list == &(dev->maplist->head)) {
-		up(&dev->struct_sem);
-		return -EINVAL;
-	}
-	map = r_list->map;
-	up(&dev->struct_sem);
-
-	if (!map) return -EINVAL;
-
-	down(&dev->struct_sem);
-	if ((int)request.ctx_id >= dev->max_context) {
-		up(&dev->struct_sem);
-		return -EINVAL;
-	}
-	dev->context_sareas[request.ctx_id] = map;
-	up(&dev->struct_sem);
-	return 0;
-}
-
-void gamma_driver_irq_preinstall( drm_device_t *dev ) {
-	drm_gamma_private_t *dev_priv =
-				(drm_gamma_private_t *)dev->dev_private;
-
-	while(GAMMA_READ(GAMMA_INFIFOSPACE) < 2)
-		cpu_relax();
-
-	GAMMA_WRITE( GAMMA_GCOMMANDMODE,	0x00000004 );
-	GAMMA_WRITE( GAMMA_GDMACONTROL,		0x00000000 );
-}
-
-void gamma_driver_irq_postinstall( drm_device_t *dev ) {
-	drm_gamma_private_t *dev_priv =
-				(drm_gamma_private_t *)dev->dev_private;
-
-	while(GAMMA_READ(GAMMA_INFIFOSPACE) < 3)
-		cpu_relax();
-
-	GAMMA_WRITE( GAMMA_GINTENABLE,		0x00002001 );
-	GAMMA_WRITE( GAMMA_COMMANDINTENABLE,	0x00000008 );
-	GAMMA_WRITE( GAMMA_GDELAYTIMER,		0x00039090 );
-}
-
-void gamma_driver_irq_uninstall( drm_device_t *dev ) {
-	drm_gamma_private_t *dev_priv =
-				(drm_gamma_private_t *)dev->dev_private;
-	if (!dev_priv)
-		return;
-
-	while(GAMMA_READ(GAMMA_INFIFOSPACE) < 3)
-		cpu_relax();
-
-	GAMMA_WRITE( GAMMA_GDELAYTIMER,		0x00000000 );
-	GAMMA_WRITE( GAMMA_COMMANDINTENABLE,	0x00000000 );
-	GAMMA_WRITE( GAMMA_GINTENABLE,		0x00000000 );
-}
-
-extern drm_ioctl_desc_t DRM(ioctls)[];
-
-static int gamma_driver_preinit(drm_device_t *dev)
-{
-	/* reset the finish ioctl */
-	DRM(ioctls)[DRM_IOCTL_NR(DRM_IOCTL_FINISH)].func = DRM(finish);
-	return 0;
-}
-
-static void gamma_driver_pretakedown(drm_device_t *dev)
-{
-	gamma_do_cleanup_dma(dev);
-}
-
-static void gamma_driver_dma_ready(drm_device_t *dev)
-{
-	gamma_dma_ready(dev);
-}
-
-static int gamma_driver_dma_quiescent(drm_device_t *dev)
-{
-	drm_gamma_private_t *dev_priv =	(
-		drm_gamma_private_t *)dev->dev_private;
-	if (dev_priv->num_rast == 2)
-		gamma_dma_quiescent_dual(dev);
-	else gamma_dma_quiescent_single(dev);
-	return 0;
-}
-
-void gamma_driver_register_fns(drm_device_t *dev)
-{
-	dev->driver_features = DRIVER_USE_AGP | DRIVER_USE_MTRR | DRIVER_PCI_DMA | DRIVER_HAVE_DMA | DRIVER_HAVE_IRQ;
-	DRM(fops).read = gamma_fops_read;
-	DRM(fops).poll = gamma_fops_poll;
-	dev->driver.preinit = gamma_driver_preinit;
-	dev->driver.pretakedown = gamma_driver_pretakedown;
-	dev->driver.dma_ready = gamma_driver_dma_ready;
-	dev->driver.dma_quiescent = gamma_driver_dma_quiescent;
-	dev->driver.dma_flush_block_and_flush = gamma_flush_block_and_flush;
-	dev->driver.dma_flush_unblock = gamma_flush_unblock;
-}
diff -purN linux-2.6.12.orig/drivers/char/drm/gamma_drm.h linux-2.6.12/drivers/char/drm/gamma_drm.h
--- linux-2.6.12.orig/drivers/char/drm/gamma_drm.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/gamma_drm.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,90 +0,0 @@
-#ifndef _GAMMA_DRM_H_
-#define _GAMMA_DRM_H_
-
-typedef struct _drm_gamma_tex_region {
-	unsigned char next, prev; /* indices to form a circular LRU  */
-	unsigned char in_use;	/* owned by a client, or free? */
-	int age;		/* tracked by clients to update local LRU's */
-} drm_gamma_tex_region_t;
-
-typedef struct {
-	unsigned int	GDeltaMode;
-	unsigned int	GDepthMode;
-	unsigned int	GGeometryMode;
-	unsigned int	GTransformMode;
-} drm_gamma_context_regs_t;
-
-typedef struct _drm_gamma_sarea {
-   	drm_gamma_context_regs_t context_state;
-
-	unsigned int dirty;
-
-
-	/* Maintain an LRU of contiguous regions of texture space.  If
-	 * you think you own a region of texture memory, and it has an
-	 * age different to the one you set, then you are mistaken and
-	 * it has been stolen by another client.  If global texAge
-	 * hasn't changed, there is no need to walk the list.
-	 *
-	 * These regions can be used as a proxy for the fine-grained
-	 * texture information of other clients - by maintaining them
-	 * in the same lru which is used to age their own textures,
-	 * clients have an approximate lru for the whole of global
-	 * texture space, and can make informed decisions as to which
-	 * areas to kick out.  There is no need to choose whether to
-	 * kick out your own texture or someone else's - simply eject
-	 * them all in LRU order.  
-	 */
-   
-#define GAMMA_NR_TEX_REGIONS 64
-	drm_gamma_tex_region_t texList[GAMMA_NR_TEX_REGIONS+1]; 
-				/* Last elt is sentinal */
-        int texAge;		/* last time texture was uploaded */
-        int last_enqueue;	/* last time a buffer was enqueued */
-	int last_dispatch;	/* age of the most recently dispatched buffer */
-	int last_quiescent;     /*  */
-	int ctxOwner;		/* last context to upload state */
-
-	int vertex_prim;
-} drm_gamma_sarea_t;
-
-/* WARNING: If you change any of these defines, make sure to change the
- * defines in the Xserver file (xf86drmGamma.h)
- */
-
-/* Gamma specific ioctls
- * The device specific ioctl range is 0x40 to 0x79.
- */
-#define DRM_IOCTL_GAMMA_INIT		DRM_IOW( 0x40, drm_gamma_init_t)
-#define DRM_IOCTL_GAMMA_COPY		DRM_IOW( 0x41, drm_gamma_copy_t)
-
-typedef struct drm_gamma_copy {
-	unsigned int	DMAOutputAddress;
-	unsigned int	DMAOutputCount;
-	unsigned int	DMAReadGLINTSource;
-	unsigned int	DMARectangleWriteAddress;
-	unsigned int	DMARectangleWriteLinePitch;
-	unsigned int	DMARectangleWrite;
-	unsigned int	DMARectangleReadAddress;
-	unsigned int	DMARectangleReadLinePitch;
-	unsigned int	DMARectangleRead;
-	unsigned int	DMARectangleReadTarget;
-} drm_gamma_copy_t;
-
-typedef struct drm_gamma_init {
-   	enum {
-	   	GAMMA_INIT_DMA    = 0x01,
-	       	GAMMA_CLEANUP_DMA = 0x02
-	} func;
-
-   	int sarea_priv_offset;
-	int pcimode;
-	unsigned int mmio0;
-	unsigned int mmio1;
-	unsigned int mmio2;
-	unsigned int mmio3;
-	unsigned int buffers_offset;
-	int num_rast;
-} drm_gamma_init_t;
-
-#endif /* _GAMMA_DRM_H_ */
diff -purN linux-2.6.12.orig/drivers/char/drm/gamma_drv.c linux-2.6.12/drivers/char/drm/gamma_drv.c
--- linux-2.6.12.orig/drivers/char/drm/gamma_drv.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/gamma_drv.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,59 +0,0 @@
-/* gamma.c -- 3dlabs GMX 2000 driver -*- linux-c -*-
- * Created: Mon Jan  4 08:58:31 1999 by faith@precisioninsight.com
- *
- * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
- * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Authors:
- *    Rickard E. (Rik) Faith <faith@valinux.com>
- *    Gareth Hughes <gareth@valinux.com>
- */
-
-#include <linux/config.h>
-#include "gamma.h"
-#include "drmP.h"
-#include "drm.h"
-#include "gamma_drm.h"
-#include "gamma_drv.h"
-
-#include "drm_auth.h"
-#include "drm_agpsupport.h"
-#include "drm_bufs.h"
-#include "gamma_context.h"	/* NOTE! */
-#include "drm_dma.h"
-#include "gamma_old_dma.h"	/* NOTE */
-#include "drm_drawable.h"
-#include "drm_drv.h"
-
-#include "drm_fops.h"
-#include "drm_init.h"
-#include "drm_ioctl.h"
-#include "drm_irq.h"
-#include "gamma_lists.h"        /* NOTE */
-#include "drm_lock.h"
-#include "gamma_lock.h"		/* NOTE */
-#include "drm_memory.h"
-#include "drm_proc.h"
-#include "drm_vm.h"
-#include "drm_stub.h"
-#include "drm_scatter.h"
diff -purN linux-2.6.12.orig/drivers/char/drm/gamma_drv.h linux-2.6.12/drivers/char/drm/gamma_drv.h
--- linux-2.6.12.orig/drivers/char/drm/gamma_drv.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/gamma_drv.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,147 +0,0 @@
-/* gamma_drv.h -- Private header for 3dlabs GMX 2000 driver -*- linux-c -*-
- * Created: Mon Jan  4 10:05:05 1999 by faith@precisioninsight.com
- *
- * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
- * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
- * All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Authors:
- *    Rickard E. (Rik) Faith <faith@valinux.com>
- *
- */
-
-#ifndef _GAMMA_DRV_H_
-#define _GAMMA_DRV_H_
-
-typedef struct drm_gamma_private {
-	drm_gamma_sarea_t *sarea_priv;
-	drm_map_t *sarea;
-	drm_map_t *mmio0;
-	drm_map_t *mmio1;
-	drm_map_t *mmio2;
-	drm_map_t *mmio3;
-	int num_rast;
-} drm_gamma_private_t;
-
-				/* gamma_dma.c */
-extern int gamma_dma_init( struct inode *inode, struct file *filp,
-			 unsigned int cmd, unsigned long arg );
-extern int gamma_dma_copy( struct inode *inode, struct file *filp,
-			 unsigned int cmd, unsigned long arg );
-
-extern int gamma_do_cleanup_dma( drm_device_t *dev );
-extern void gamma_dma_ready(drm_device_t *dev);
-extern void gamma_dma_quiescent_single(drm_device_t *dev);
-extern void gamma_dma_quiescent_dual(drm_device_t *dev);
-
-				/* gamma_dma.c */
-extern int  gamma_dma_schedule(drm_device_t *dev, int locked);
-extern int  gamma_dma(struct inode *inode, struct file *filp,
-		      unsigned int cmd, unsigned long arg);
-extern int  gamma_find_devices(void);
-extern int  gamma_found(void);
-
-/* Gamma-specific code pulled from drm_fops.h:
- */
-extern int	     DRM(finish)(struct inode *inode, struct file *filp,
-				 unsigned int cmd, unsigned long arg);
-extern int	     DRM(flush_unblock)(drm_device_t *dev, int context,
-					drm_lock_flags_t flags);
-extern int	     DRM(flush_block_and_flush)(drm_device_t *dev, int context,
-						drm_lock_flags_t flags);
-
-/* Gamma-specific code pulled from drm_dma.h:
- */
-extern void	     DRM(clear_next_buffer)(drm_device_t *dev);
-extern int	     DRM(select_queue)(drm_device_t *dev,
-				       void (*wrapper)(unsigned long));
-extern int	     DRM(dma_enqueue)(struct file *filp, drm_dma_t *dma);
-extern int	     DRM(dma_get_buffers)(struct file *filp, drm_dma_t *dma);
-
-
-/* Gamma-specific code pulled from drm_lists.h (now renamed gamma_lists.h):
- */
-extern int	     DRM(waitlist_create)(drm_waitlist_t *bl, int count);
-extern int	     DRM(waitlist_destroy)(drm_waitlist_t *bl);
-extern int	     DRM(waitlist_put)(drm_waitlist_t *bl, drm_buf_t *buf);
-extern drm_buf_t     *DRM(waitlist_get)(drm_waitlist_t *bl);
-extern int	     DRM(freelist_create)(drm_freelist_t *bl, int count);
-extern int	     DRM(freelist_destroy)(drm_freelist_t *bl);
-extern int	     DRM(freelist_put)(drm_device_t *dev, drm_freelist_t *bl,
-				       drm_buf_t *buf);
-extern drm_buf_t     *DRM(freelist_get)(drm_freelist_t *bl, int block);
-
-/* externs for gamma changes to the ops */
-extern struct file_operations DRM(fops);
-extern unsigned int gamma_fops_poll(struct file *filp, struct poll_table_struct *wait);
-extern ssize_t gamma_fops_read(struct file *filp, char __user *buf, size_t count, loff_t *off);
-
-
-#define GLINT_DRI_BUF_COUNT 256
-
-#define GAMMA_OFF(reg)						   \
-	((reg < 0x1000)						   \
-	 ? reg							   \
-	 : ((reg < 0x10000)					   \
-	    ? (reg - 0x1000)					   \
-	    : ((reg < 0x11000)					   \
-	       ? (reg - 0x10000)				   \
-	       : (reg - 0x11000))))
-
-#define GAMMA_BASE(reg)	 ((unsigned long)				     \
-			  ((reg < 0x1000)    ? dev_priv->mmio0->handle :     \
-			   ((reg < 0x10000)  ? dev_priv->mmio1->handle :     \
-			    ((reg < 0x11000) ? dev_priv->mmio2->handle :     \
-					       dev_priv->mmio3->handle))))
-#define GAMMA_ADDR(reg)	 (GAMMA_BASE(reg) + GAMMA_OFF(reg))
-#define GAMMA_DEREF(reg) *(__volatile__ int *)GAMMA_ADDR(reg)
-#define GAMMA_READ(reg)	 GAMMA_DEREF(reg)
-#define GAMMA_WRITE(reg,val) do { GAMMA_DEREF(reg) = val; } while (0)
-
-#define GAMMA_BROADCASTMASK    0x9378
-#define GAMMA_COMMANDINTENABLE 0x0c48
-#define GAMMA_DMAADDRESS       0x0028
-#define GAMMA_DMACOUNT	       0x0030
-#define GAMMA_FILTERMODE       0x8c00
-#define GAMMA_GCOMMANDINTFLAGS 0x0c50
-#define GAMMA_GCOMMANDMODE     0x0c40
-#define		GAMMA_QUEUED_DMA_MODE		1<<1
-#define GAMMA_GCOMMANDSTATUS   0x0c60
-#define GAMMA_GDELAYTIMER      0x0c38
-#define GAMMA_GDMACONTROL      0x0060
-#define 	GAMMA_USE_AGP			1<<1
-#define GAMMA_GINTENABLE       0x0808
-#define GAMMA_GINTFLAGS	       0x0810
-#define GAMMA_INFIFOSPACE      0x0018
-#define GAMMA_OUTFIFOWORDS     0x0020
-#define GAMMA_OUTPUTFIFO       0x2000
-#define GAMMA_SYNC	       0x8c40
-#define GAMMA_SYNC_TAG	       0x0188
-#define GAMMA_PAGETABLEADDR    0x0C00
-#define GAMMA_PAGETABLELENGTH  0x0C08
-
-#define GAMMA_PASSTHROUGH	0x1FE
-#define GAMMA_DMAADDRTAG	0x530
-#define GAMMA_DMACOUNTTAG	0x531
-#define GAMMA_COMMANDINTTAG	0x532
-
-#endif
diff -purN linux-2.6.12.orig/drivers/char/drm/gamma_lists.h linux-2.6.12/drivers/char/drm/gamma_lists.h
--- linux-2.6.12.orig/drivers/char/drm/gamma_lists.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/gamma_lists.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,215 +0,0 @@
-/* drm_lists.h -- Buffer list handling routines -*- linux-c -*-
- * Created: Mon Apr 19 20:54:22 1999 by faith@valinux.com
- *
- * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
- * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors:
- *    Rickard E. (Rik) Faith <faith@valinux.com>
- *    Gareth Hughes <gareth@valinux.com>
- */
-
-#include "drmP.h"
-
-
-int DRM(waitlist_create)(drm_waitlist_t *bl, int count)
-{
-	if (bl->count) return -EINVAL;
-
-	bl->bufs       = DRM(alloc)((bl->count + 2) * sizeof(*bl->bufs),
-				    DRM_MEM_BUFLISTS);
-
-	if(!bl->bufs) return -ENOMEM;
-	memset(bl->bufs, 0, sizeof(*bl->bufs));
-	bl->count      = count;
-	bl->rp	       = bl->bufs;
-	bl->wp	       = bl->bufs;
-	bl->end	       = &bl->bufs[bl->count+1];
-	spin_lock_init(&bl->write_lock);
-	spin_lock_init(&bl->read_lock);
-	return 0;
-}
-
-int DRM(waitlist_destroy)(drm_waitlist_t *bl)
-{
-	if (bl->rp != bl->wp) return -EINVAL;
-	if (bl->bufs) DRM(free)(bl->bufs,
-				(bl->count + 2) * sizeof(*bl->bufs),
-				DRM_MEM_BUFLISTS);
-	bl->count = 0;
-	bl->bufs  = NULL;
-	bl->rp	  = NULL;
-	bl->wp	  = NULL;
-	bl->end	  = NULL;
-	return 0;
-}
-
-int DRM(waitlist_put)(drm_waitlist_t *bl, drm_buf_t *buf)
-{
-	int	      left;
-	unsigned long flags;
-
-	left = DRM_LEFTCOUNT(bl);
-	if (!left) {
-		DRM_ERROR("Overflow while adding buffer %d from filp %p\n",
-			  buf->idx, buf->filp);
-		return -EINVAL;
-	}
-	buf->list	 = DRM_LIST_WAIT;
-
-	spin_lock_irqsave(&bl->write_lock, flags);
-	*bl->wp = buf;
-	if (++bl->wp >= bl->end) bl->wp = bl->bufs;
-	spin_unlock_irqrestore(&bl->write_lock, flags);
-
-	return 0;
-}
-
-drm_buf_t *DRM(waitlist_get)(drm_waitlist_t *bl)
-{
-	drm_buf_t     *buf;
-	unsigned long flags;
-
-	spin_lock_irqsave(&bl->read_lock, flags);
-	buf = *bl->rp;
-	if (bl->rp == bl->wp) {
-		spin_unlock_irqrestore(&bl->read_lock, flags);
-		return NULL;
-	}
-	if (++bl->rp >= bl->end) bl->rp = bl->bufs;
-	spin_unlock_irqrestore(&bl->read_lock, flags);
-
-	return buf;
-}
-
-int DRM(freelist_create)(drm_freelist_t *bl, int count)
-{
-	atomic_set(&bl->count, 0);
-	bl->next      = NULL;
-	init_waitqueue_head(&bl->waiting);
-	bl->low_mark  = 0;
-	bl->high_mark = 0;
-	atomic_set(&bl->wfh,   0);
-	spin_lock_init(&bl->lock);
-	++bl->initialized;
-	return 0;
-}
-
-int DRM(freelist_destroy)(drm_freelist_t *bl)
-{
-	atomic_set(&bl->count, 0);
-	bl->next = NULL;
-	return 0;
-}
-
-int DRM(freelist_put)(drm_device_t *dev, drm_freelist_t *bl, drm_buf_t *buf)
-{
-	drm_device_dma_t *dma  = dev->dma;
-
-	if (!dma) {
-		DRM_ERROR("No DMA support\n");
-		return 1;
-	}
-
-	if (buf->waiting || buf->pending || buf->list == DRM_LIST_FREE) {
-		DRM_ERROR("Freed buffer %d: w%d, p%d, l%d\n",
-			  buf->idx, buf->waiting, buf->pending, buf->list);
-	}
-	if (!bl) return 1;
-	buf->list	= DRM_LIST_FREE;
-
-	spin_lock(&bl->lock);
-	buf->next	= bl->next;
-	bl->next	= buf;
-	spin_unlock(&bl->lock);
-
-	atomic_inc(&bl->count);
-	if (atomic_read(&bl->count) > dma->buf_count) {
-		DRM_ERROR("%d of %d buffers free after addition of %d\n",
-			  atomic_read(&bl->count), dma->buf_count, buf->idx);
-		return 1;
-	}
-				/* Check for high water mark */
-	if (atomic_read(&bl->wfh) && atomic_read(&bl->count)>=bl->high_mark) {
-		atomic_set(&bl->wfh, 0);
-		wake_up_interruptible(&bl->waiting);
-	}
-	return 0;
-}
-
-static drm_buf_t *DRM(freelist_try)(drm_freelist_t *bl)
-{
-	drm_buf_t	  *buf;
-
-	if (!bl) return NULL;
-
-				/* Get buffer */
-	spin_lock(&bl->lock);
-	if (!bl->next) {
-		spin_unlock(&bl->lock);
-		return NULL;
-	}
-	buf	  = bl->next;
-	bl->next  = bl->next->next;
-	spin_unlock(&bl->lock);
-
-	atomic_dec(&bl->count);
-	buf->next = NULL;
-	buf->list = DRM_LIST_NONE;
-	if (buf->waiting || buf->pending) {
-		DRM_ERROR("Free buffer %d: w%d, p%d, l%d\n",
-			  buf->idx, buf->waiting, buf->pending, buf->list);
-	}
-
-	return buf;
-}
-
-drm_buf_t *DRM(freelist_get)(drm_freelist_t *bl, int block)
-{
-	drm_buf_t	  *buf	= NULL;
-	DECLARE_WAITQUEUE(entry, current);
-
-	if (!bl || !bl->initialized) return NULL;
-
-				/* Check for low water mark */
-	if (atomic_read(&bl->count) <= bl->low_mark) /* Became low */
-		atomic_set(&bl->wfh, 1);
-	if (atomic_read(&bl->wfh)) {
-		if (block) {
-			add_wait_queue(&bl->waiting, &entry);
-			for (;;) {
-				current->state = TASK_INTERRUPTIBLE;
-				if (!atomic_read(&bl->wfh)
-				    && (buf = DRM(freelist_try)(bl))) break;
-				schedule();
-				if (signal_pending(current)) break;
-			}
-			current->state = TASK_RUNNING;
-			remove_wait_queue(&bl->waiting, &entry);
-		}
-		return buf;
-	}
-
-	return DRM(freelist_try)(bl);
-}
-
diff -purN linux-2.6.12.orig/drivers/char/drm/gamma_lock.h linux-2.6.12/drivers/char/drm/gamma_lock.h
--- linux-2.6.12.orig/drivers/char/drm/gamma_lock.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/gamma_lock.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,140 +0,0 @@
-/* lock.c -- IOCTLs for locking -*- linux-c -*-
- * Created: Tue Feb  2 08:37:54 1999 by faith@valinux.com
- *
- * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
- * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors:
- *    Rickard E. (Rik) Faith <faith@valinux.com>
- *    Gareth Hughes <gareth@valinux.com>
- */
-
-
-/* Gamma-specific code extracted from drm_lock.h:
- */
-static int DRM(flush_queue)(drm_device_t *dev, int context)
-{
-	DECLARE_WAITQUEUE(entry, current);
-	int		  ret	= 0;
-	drm_queue_t	  *q	= dev->queuelist[context];
-
-	DRM_DEBUG("\n");
-
-	atomic_inc(&q->use_count);
-	if (atomic_read(&q->use_count) > 1) {
-		atomic_inc(&q->block_write);
-		add_wait_queue(&q->flush_queue, &entry);
-		atomic_inc(&q->block_count);
-		for (;;) {
-			current->state = TASK_INTERRUPTIBLE;
-			if (!DRM_BUFCOUNT(&q->waitlist)) break;
-			schedule();
-			if (signal_pending(current)) {
-				ret = -EINTR; /* Can't restart */
-				break;
-			}
-		}
-		atomic_dec(&q->block_count);
-		current->state = TASK_RUNNING;
-		remove_wait_queue(&q->flush_queue, &entry);
-	}
-	atomic_dec(&q->use_count);
-
-				/* NOTE: block_write is still incremented!
-				   Use drm_flush_unlock_queue to decrement. */
-	return ret;
-}
-
-static int DRM(flush_unblock_queue)(drm_device_t *dev, int context)
-{
-	drm_queue_t	  *q	= dev->queuelist[context];
-
-	DRM_DEBUG("\n");
-
-	atomic_inc(&q->use_count);
-	if (atomic_read(&q->use_count) > 1) {
-		if (atomic_read(&q->block_write)) {
-			atomic_dec(&q->block_write);
-			wake_up_interruptible(&q->write_queue);
-		}
-	}
-	atomic_dec(&q->use_count);
-	return 0;
-}
-
-int DRM(flush_block_and_flush)(drm_device_t *dev, int context,
-			       drm_lock_flags_t flags)
-{
-	int ret = 0;
-	int i;
-
-	DRM_DEBUG("\n");
-
-	if (flags & _DRM_LOCK_FLUSH) {
-		ret = DRM(flush_queue)(dev, DRM_KERNEL_CONTEXT);
-		if (!ret) ret = DRM(flush_queue)(dev, context);
-	}
-	if (flags & _DRM_LOCK_FLUSH_ALL) {
-		for (i = 0; !ret && i < dev->queue_count; i++) {
-			ret = DRM(flush_queue)(dev, i);
-		}
-	}
-	return ret;
-}
-
-int DRM(flush_unblock)(drm_device_t *dev, int context, drm_lock_flags_t flags)
-{
-	int ret = 0;
-	int i;
-
-	DRM_DEBUG("\n");
-
-	if (flags & _DRM_LOCK_FLUSH) {
-		ret = DRM(flush_unblock_queue)(dev, DRM_KERNEL_CONTEXT);
-		if (!ret) ret = DRM(flush_unblock_queue)(dev, context);
-	}
-	if (flags & _DRM_LOCK_FLUSH_ALL) {
-		for (i = 0; !ret && i < dev->queue_count; i++) {
-			ret = DRM(flush_unblock_queue)(dev, i);
-		}
-	}
-
-	return ret;
-}
-
-int DRM(finish)(struct inode *inode, struct file *filp, unsigned int cmd,
-		unsigned long arg)
-{
-	drm_file_t	  *priv	  = filp->private_data;
-	drm_device_t	  *dev	  = priv->dev;
-	int		  ret	  = 0;
-	drm_lock_t	  lock;
-
-	DRM_DEBUG("\n");
-
-	if (copy_from_user(&lock, (drm_lock_t __user *)arg, sizeof(lock)))
-		return -EFAULT;
-	ret = DRM(flush_block_and_flush)(dev, lock.context, lock.flags);
-	DRM(flush_unblock)(dev, lock.context, lock.flags);
-	return ret;
-}
diff -purN linux-2.6.12.orig/drivers/char/drm/gamma_old_dma.h linux-2.6.12/drivers/char/drm/gamma_old_dma.h
--- linux-2.6.12.orig/drivers/char/drm/gamma_old_dma.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/gamma_old_dma.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,313 +0,0 @@
-/* drm_dma.c -- DMA IOCTL and function support -*- linux-c -*-
- * Created: Fri Mar 19 14:30:16 1999 by faith@valinux.com
- *
- * Copyright 1999, 2000 Precision Insight, Inc., Cedar Park, Texas.
- * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors:
- *    Rickard E. (Rik) Faith <faith@valinux.com>
- *    Gareth Hughes <gareth@valinux.com>
- */
-
-
-/* Gamma-specific code pulled from drm_dma.h:
- */
-
-void DRM(clear_next_buffer)(drm_device_t *dev)
-{
-	drm_device_dma_t *dma = dev->dma;
-
-	dma->next_buffer = NULL;
-	if (dma->next_queue && !DRM_BUFCOUNT(&dma->next_queue->waitlist)) {
-		wake_up_interruptible(&dma->next_queue->flush_queue);
-	}
-	dma->next_queue	 = NULL;
-}
-
-int DRM(select_queue)(drm_device_t *dev, void (*wrapper)(unsigned long))
-{
-	int	   i;
-	int	   candidate = -1;
-	int	   j	     = jiffies;
-
-	if (!dev) {
-		DRM_ERROR("No device\n");
-		return -1;
-	}
-	if (!dev->queuelist || !dev->queuelist[DRM_KERNEL_CONTEXT]) {
-				/* This only happens between the time the
-				   interrupt is initialized and the time
-				   the queues are initialized. */
-		return -1;
-	}
-
-				/* Doing "while locked" DMA? */
-	if (DRM_WAITCOUNT(dev, DRM_KERNEL_CONTEXT)) {
-		return DRM_KERNEL_CONTEXT;
-	}
-
-				/* If there are buffers on the last_context
-				   queue, and we have not been executing
-				   this context very long, continue to
-				   execute this context. */
-	if (dev->last_switch <= j
-	    && dev->last_switch + DRM_TIME_SLICE > j
-	    && DRM_WAITCOUNT(dev, dev->last_context)) {
-		return dev->last_context;
-	}
-
-				/* Otherwise, find a candidate */
-	for (i = dev->last_checked + 1; i < dev->queue_count; i++) {
-		if (DRM_WAITCOUNT(dev, i)) {
-			candidate = dev->last_checked = i;
-			break;
-		}
-	}
-
-	if (candidate < 0) {
-		for (i = 0; i < dev->queue_count; i++) {
-			if (DRM_WAITCOUNT(dev, i)) {
-				candidate = dev->last_checked = i;
-				break;
-			}
-		}
-	}
-
-	if (wrapper
-	    && candidate >= 0
-	    && candidate != dev->last_context
-	    && dev->last_switch <= j
-	    && dev->last_switch + DRM_TIME_SLICE > j) {
-		if (dev->timer.expires != dev->last_switch + DRM_TIME_SLICE) {
-			del_timer(&dev->timer);
-			dev->timer.function = wrapper;
-			dev->timer.data	    = (unsigned long)dev;
-			dev->timer.expires  = dev->last_switch+DRM_TIME_SLICE;
-			add_timer(&dev->timer);
-		}
-		return -1;
-	}
-
-	return candidate;
-}
-
-
-int DRM(dma_enqueue)(struct file *filp, drm_dma_t *d)
-{
-	drm_file_t    *priv   = filp->private_data;
-	drm_device_t  *dev    = priv->dev;
-	int		  i;
-	drm_queue_t	  *q;
-	drm_buf_t	  *buf;
-	int		  idx;
-	int		  while_locked = 0;
-	drm_device_dma_t  *dma = dev->dma;
-	int		  *ind;
-	int		  err;
-	DECLARE_WAITQUEUE(entry, current);
-
-	DRM_DEBUG("%d\n", d->send_count);
-
-	if (d->flags & _DRM_DMA_WHILE_LOCKED) {
-		int context = dev->lock.hw_lock->lock;
-
-		if (!_DRM_LOCK_IS_HELD(context)) {
-			DRM_ERROR("No lock held during \"while locked\""
-				  " request\n");
-			return -EINVAL;
-		}
-		if (d->context != _DRM_LOCKING_CONTEXT(context)
-		    && _DRM_LOCKING_CONTEXT(context) != DRM_KERNEL_CONTEXT) {
-			DRM_ERROR("Lock held by %d while %d makes"
-				  " \"while locked\" request\n",
-				  _DRM_LOCKING_CONTEXT(context),
-				  d->context);
-			return -EINVAL;
-		}
-		q = dev->queuelist[DRM_KERNEL_CONTEXT];
-		while_locked = 1;
-	} else {
-		q = dev->queuelist[d->context];
-	}
-
-
-	atomic_inc(&q->use_count);
-	if (atomic_read(&q->block_write)) {
-		add_wait_queue(&q->write_queue, &entry);
-		atomic_inc(&q->block_count);
-		for (;;) {
-			current->state = TASK_INTERRUPTIBLE;
-			if (!atomic_read(&q->block_write)) break;
-			schedule();
-			if (signal_pending(current)) {
-				atomic_dec(&q->use_count);
-				remove_wait_queue(&q->write_queue, &entry);
-				return -EINTR;
-			}
-		}
-		atomic_dec(&q->block_count);
-		current->state = TASK_RUNNING;
-		remove_wait_queue(&q->write_queue, &entry);
-	}
-
-	ind = DRM(alloc)(d->send_count * sizeof(int), DRM_MEM_DRIVER);
-	if (!ind)
-		return -ENOMEM;
-
-	if (copy_from_user(ind, d->send_indices, d->send_count * sizeof(int))) {
-		err = -EFAULT;
-                goto out;
-	}
-
-	err = -EINVAL;
-	for (i = 0; i < d->send_count; i++) {
-		idx = ind[i];
-		if (idx < 0 || idx >= dma->buf_count) {
-			DRM_ERROR("Index %d (of %d max)\n",
-				  ind[i], dma->buf_count - 1);
-			goto out;
-		}
-		buf = dma->buflist[ idx ];
-		if (buf->filp != filp) {
-			DRM_ERROR("Process %d using buffer not owned\n",
-				  current->pid);
-			goto out;
-		}
-		if (buf->list != DRM_LIST_NONE) {
-			DRM_ERROR("Process %d using buffer %d on list %d\n",
-				  current->pid, buf->idx, buf->list);
-			goto out;
-		}
-		buf->used	  = ind[i];
-		buf->while_locked = while_locked;
-		buf->context	  = d->context;
-		if (!buf->used) {
-			DRM_ERROR("Queueing 0 length buffer\n");
-		}
-		if (buf->pending) {
-			DRM_ERROR("Queueing pending buffer:"
-				  " buffer %d, offset %d\n",
-				  ind[i], i);
-			goto out;
-		}
-		if (buf->waiting) {
-			DRM_ERROR("Queueing waiting buffer:"
-				  " buffer %d, offset %d\n",
-				  ind[i], i);
-			goto out;
-		}
-		buf->waiting = 1;
-		if (atomic_read(&q->use_count) == 1
-		    || atomic_read(&q->finalization)) {
-			DRM(free_buffer)(dev, buf);
-		} else {
-			DRM(waitlist_put)(&q->waitlist, buf);
-			atomic_inc(&q->total_queued);
-		}
-	}
-	atomic_dec(&q->use_count);
-
-	return 0;
-
-out:
-	DRM(free)(ind, d->send_count * sizeof(int), DRM_MEM_DRIVER);
-	atomic_dec(&q->use_count);
-	return err;
-}
-
-static int DRM(dma_get_buffers_of_order)(struct file *filp, drm_dma_t *d,
-					 int order)
-{
-	drm_file_t    *priv   = filp->private_data;
-	drm_device_t  *dev    = priv->dev;
-	int		  i;
-	drm_buf_t	  *buf;
-	drm_device_dma_t  *dma = dev->dma;
-
-	for (i = d->granted_count; i < d->request_count; i++) {
-		buf = DRM(freelist_get)(&dma->bufs[order].freelist,
-					d->flags & _DRM_DMA_WAIT);
-		if (!buf) break;
-		if (buf->pending || buf->waiting) {
-			DRM_ERROR("Free buffer %d in use: filp %p (w%d, p%d)\n",
-				  buf->idx,
-				  buf->filp,
-				  buf->waiting,
-				  buf->pending);
-		}
-		buf->filp     = filp;
-		if (copy_to_user(&d->request_indices[i],
-				 &buf->idx,
-				 sizeof(buf->idx)))
-			return -EFAULT;
-
-		if (copy_to_user(&d->request_sizes[i],
-				 &buf->total,
-				 sizeof(buf->total)))
-			return -EFAULT;
-
-		++d->granted_count;
-	}
-	return 0;
-}
-
-
-int DRM(dma_get_buffers)(struct file *filp, drm_dma_t *dma)
-{
-	int		  order;
-	int		  retcode = 0;
-	int		  tmp_order;
-
-	order = DRM(order)(dma->request_size);
-
-	dma->granted_count = 0;
-	retcode		   = DRM(dma_get_buffers_of_order)(filp, dma, order);
-
-	if (dma->granted_count < dma->request_count
-	    && (dma->flags & _DRM_DMA_SMALLER_OK)) {
-		for (tmp_order = order - 1;
-		     !retcode
-			     && dma->granted_count < dma->request_count
-			     && tmp_order >= DRM_MIN_ORDER;
-		     --tmp_order) {
-
-			retcode = DRM(dma_get_buffers_of_order)(filp, dma,
-								tmp_order);
-		}
-	}
-
-	if (dma->granted_count < dma->request_count
-	    && (dma->flags & _DRM_DMA_LARGER_OK)) {
-		for (tmp_order = order + 1;
-		     !retcode
-			     && dma->granted_count < dma->request_count
-			     && tmp_order <= DRM_MAX_ORDER;
-		     ++tmp_order) {
-
-			retcode = DRM(dma_get_buffers_of_order)(filp, dma,
-								tmp_order);
-		}
-	}
-	return 0;
-}
-
diff -purN linux-2.6.12.orig/drivers/char/drm/i810_dma.c linux-2.6.12/drivers/char/drm/i810_dma.c
--- linux-2.6.12.orig/drivers/char/drm/i810_dma.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/i810_dma.c	2005-07-05 08:37:27.000000000 +0200
@@ -30,13 +30,20 @@
  *
  */
 
+#include <linux/interrupt.h>	/* For task queue support */
+#include <linux/delay.h>
+#include <linux/pagemap.h>
+
 #include "drmP.h"
 #include "drm.h"
 #include "i810_drm.h"
 #include "i810_drv.h"
-#include <linux/interrupt.h>	/* For task queue support */
-#include <linux/delay.h>
-#include <linux/pagemap.h>
+
+#ifdef DO_MUNMAP_4_ARGS
+#define DO_MUNMAP(m, a, l)	do_munmap(m, a, l, 1)
+#else
+#define DO_MUNMAP(m, a, l)	do_munmap(m, a, l)
+#endif
 
 #define I810_BUF_FREE		2
 #define I810_BUF_CLIENT		1
@@ -45,107 +52,119 @@
 #define I810_BUF_UNMAPPED 0
 #define I810_BUF_MAPPED   1
 
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,4,2)
-#define down_write down
-#define up_write up
-#endif
+static inline void i810_print_status_page(drm_device_t * dev)
+{
+	drm_device_dma_t *dma = dev->dma;
+	drm_i810_private_t *dev_priv = dev->dev_private;
+	u32 *temp = dev_priv->hw_status_page;
+	int i;
+
+	DRM_DEBUG("hw_status: Interrupt Status : %x\n", temp[0]);
+	DRM_DEBUG("hw_status: LpRing Head ptr : %x\n", temp[1]);
+	DRM_DEBUG("hw_status: IRing Head ptr : %x\n", temp[2]);
+	DRM_DEBUG("hw_status: Reserved : %x\n", temp[3]);
+	DRM_DEBUG("hw_status: Last Render: %x\n", temp[4]);
+	DRM_DEBUG("hw_status: Driver Counter : %d\n", temp[5]);
+	for (i = 6; i < dma->buf_count + 6; i++) {
+		DRM_DEBUG("buffer status idx : %d used: %d\n", i - 6, temp[i]);
+	}
+}
 
-static drm_buf_t *i810_freelist_get(drm_device_t *dev)
+static drm_buf_t *i810_freelist_get(drm_device_t * dev)
 {
-   	drm_device_dma_t *dma = dev->dma;
-	int		 i;
-   	int 		 used;
+	drm_device_dma_t *dma = dev->dma;
+	int i;
+	int used;
 
 	/* Linear search might not be the best solution */
 
-   	for (i = 0; i < dma->buf_count; i++) {
-	   	drm_buf_t *buf = dma->buflist[ i ];
-	   	drm_i810_buf_priv_t *buf_priv = buf->dev_private;
+	for (i = 0; i < dma->buf_count; i++) {
+		drm_buf_t *buf = dma->buflist[i];
+		drm_i810_buf_priv_t *buf_priv = buf->dev_private;
 		/* In use is already a pointer */
-	   	used = cmpxchg(buf_priv->in_use, I810_BUF_FREE,
+		used = cmpxchg(buf_priv->in_use, I810_BUF_FREE,
 			       I810_BUF_CLIENT);
 		if (used == I810_BUF_FREE) {
 			return buf;
 		}
 	}
-   	return NULL;
+	return NULL;
 }
 
 /* This should only be called if the buffer is not sent to the hardware
  * yet, the hardware updates in use for us once its on the ring buffer.
  */
 
-static int i810_freelist_put(drm_device_t *dev, drm_buf_t *buf)
+static int i810_freelist_put(drm_device_t * dev, drm_buf_t * buf)
 {
-   	drm_i810_buf_priv_t *buf_priv = buf->dev_private;
-   	int used;
+	drm_i810_buf_priv_t *buf_priv = buf->dev_private;
+	int used;
 
-   	/* In use is already a pointer */
-   	used = cmpxchg(buf_priv->in_use, I810_BUF_CLIENT, I810_BUF_FREE);
+	/* In use is already a pointer */
+	used = cmpxchg(buf_priv->in_use, I810_BUF_CLIENT, I810_BUF_FREE);
 	if (used != I810_BUF_CLIENT) {
-	   	DRM_ERROR("Freeing buffer thats not in use : %d\n", buf->idx);
-	   	return -EINVAL;
+		DRM_ERROR("Freeing buffer thats not in use : %d\n", buf->idx);
+		return -EINVAL;
 	}
 
-   	return 0;
+	return 0;
 }
 
-static struct file_operations i810_buffer_fops = {
-	.open	 = drm_open,
-	.flush	 = drm_flush,
-	.release = drm_release,
-	.ioctl	 = drm_ioctl,
-	.mmap	 = i810_mmap_buffers,
-	.fasync  = drm_fasync,
-};
-
-int i810_mmap_buffers(struct file *filp, struct vm_area_struct *vma)
+static int i810_mmap_buffers(struct file *filp, struct vm_area_struct *vma)
 {
-	drm_file_t	    *priv	  = filp->private_data;
-	drm_device_t	    *dev;
-	drm_i810_private_t  *dev_priv;
-	drm_buf_t           *buf;
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev;
+	drm_i810_private_t *dev_priv;
+	drm_buf_t *buf;
 	drm_i810_buf_priv_t *buf_priv;
 
 	lock_kernel();
-	dev	 = priv->head->dev;
+	dev = priv->head->dev;
 	dev_priv = dev->dev_private;
-	buf      = dev_priv->mmap_buffer;
+	buf = dev_priv->mmap_buffer;
 	buf_priv = buf->dev_private;
 
 	vma->vm_flags |= (VM_IO | VM_DONTCOPY);
 	vma->vm_file = filp;
 
-   	buf_priv->currently_mapped = I810_BUF_MAPPED;
+	buf_priv->currently_mapped = I810_BUF_MAPPED;
 	unlock_kernel();
 
-	if (io_remap_pfn_range(vma, vma->vm_start,
-			     VM_OFFSET(vma) >> PAGE_SHIFT,
-			     vma->vm_end - vma->vm_start,
-			     vma->vm_page_prot)) return -EAGAIN;
+	if (remap_pfn_range(vma, vma->vm_start,
+			    VM_OFFSET(vma) >> PAGE_SHIFT,
+			    vma->vm_end - vma->vm_start,
+			    vma->vm_page_prot))
+		return -EAGAIN;
 	return 0;
 }
 
-static int i810_map_buffer(drm_buf_t *buf, struct file *filp)
+static struct file_operations i810_buffer_fops = {
+	.open = drm_open,
+	.release = drm_release,
+	.ioctl = drm_ioctl,
+	.mmap = i810_mmap_buffers,
+	.fasync = drm_fasync,
+};
+
+static int i810_map_buffer(drm_buf_t * buf, struct file *filp)
 {
-	drm_file_t	  *priv	  = filp->private_data;
-	drm_device_t	  *dev	  = priv->head->dev;
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
 	drm_i810_buf_priv_t *buf_priv = buf->dev_private;
-      	drm_i810_private_t *dev_priv = dev->dev_private;
-   	struct file_operations *old_fops;
+	drm_i810_private_t *dev_priv = dev->dev_private;
+	struct file_operations *old_fops;
 	int retcode = 0;
 
-	if (buf_priv->currently_mapped == I810_BUF_MAPPED) 
+	if (buf_priv->currently_mapped == I810_BUF_MAPPED)
 		return -EINVAL;
 
-	down_write( &current->mm->mmap_sem );
+	down_write(&current->mm->mmap_sem);
 	old_fops = filp->f_op;
 	filp->f_op = &i810_buffer_fops;
 	dev_priv->mmap_buffer = buf;
 	buf_priv->virtual = (void *)do_mmap(filp, 0, buf->total,
-					    PROT_READ|PROT_WRITE,
-					    MAP_SHARED,
-					    buf->bus_address);
+					    PROT_READ | PROT_WRITE,
+					    MAP_SHARED, buf->bus_address);
 	dev_priv->mmap_buffer = NULL;
 	filp->f_op = old_fops;
 	if ((unsigned long)buf_priv->virtual > -1024UL) {
@@ -154,12 +173,12 @@ static int i810_map_buffer(drm_buf_t *bu
 		retcode = (signed int)buf_priv->virtual;
 		buf_priv->virtual = NULL;
 	}
-	up_write( &current->mm->mmap_sem );
+	up_write(&current->mm->mmap_sem);
 
 	return retcode;
 }
 
-static int i810_unmap_buffer(drm_buf_t *buf)
+static int i810_unmap_buffer(drm_buf_t * buf)
 {
 	drm_i810_buf_priv_t *buf_priv = buf->dev_private;
 	int retcode = 0;
@@ -168,48 +187,48 @@ static int i810_unmap_buffer(drm_buf_t *
 		return -EINVAL;
 
 	down_write(&current->mm->mmap_sem);
-	retcode = do_munmap(current->mm,
+	retcode = DO_MUNMAP(current->mm,
 			    (unsigned long)buf_priv->virtual,
 			    (size_t) buf->total);
 	up_write(&current->mm->mmap_sem);
 
-   	buf_priv->currently_mapped = I810_BUF_UNMAPPED;
-   	buf_priv->virtual = NULL;
+	buf_priv->currently_mapped = I810_BUF_UNMAPPED;
+	buf_priv->virtual = NULL;
 
 	return retcode;
 }
 
-static int i810_dma_get_buffer(drm_device_t *dev, drm_i810_dma_t *d,
+static int i810_dma_get_buffer(drm_device_t * dev, drm_i810_dma_t * d,
 			       struct file *filp)
 {
-	drm_buf_t	  *buf;
+	drm_buf_t *buf;
 	drm_i810_buf_priv_t *buf_priv;
 	int retcode = 0;
 
 	buf = i810_freelist_get(dev);
 	if (!buf) {
 		retcode = -ENOMEM;
-	   	DRM_DEBUG("retcode=%d\n", retcode);
+		DRM_DEBUG("retcode=%d\n", retcode);
 		return retcode;
 	}
 
 	retcode = i810_map_buffer(buf, filp);
 	if (retcode) {
 		i810_freelist_put(dev, buf);
-	   	DRM_ERROR("mapbuf failed, retcode %d\n", retcode);
+		DRM_ERROR("mapbuf failed, retcode %d\n", retcode);
 		return retcode;
 	}
 	buf->filp = filp;
 	buf_priv = buf->dev_private;
 	d->granted = 1;
-   	d->request_idx = buf->idx;
-   	d->request_size = buf->total;
-   	d->virtual = buf_priv->virtual;
+	d->request_idx = buf->idx;
+	d->request_size = buf->total;
+	d->virtual = buf_priv->virtual;
 
 	return retcode;
 }
 
-static int i810_dma_cleanup(drm_device_t *dev)
+static int i810_dma_cleanup(drm_device_t * dev)
 {
 	drm_device_dma_t *dma = dev->dma;
 
@@ -222,164 +241,166 @@ static int i810_dma_cleanup(drm_device_t
 
 	if (dev->dev_private) {
 		int i;
-	   	drm_i810_private_t *dev_priv =
-	     		(drm_i810_private_t *) dev->dev_private;
+		drm_i810_private_t *dev_priv =
+		    (drm_i810_private_t *) dev->dev_private;
 
 		if (dev_priv->ring.virtual_start) {
-		   	drm_ioremapfree((void *) dev_priv->ring.virtual_start,
-					 dev_priv->ring.Size, dev);
+			drm_ioremapfree((void *)dev_priv->ring.virtual_start,
+					dev_priv->ring.Size, dev);
 		}
-	   	if (dev_priv->hw_status_page) {
-		   	pci_free_consistent(dev->pdev, PAGE_SIZE,
+		if (dev_priv->hw_status_page) {
+			pci_free_consistent(dev->pdev, PAGE_SIZE,
 					    dev_priv->hw_status_page,
 					    dev_priv->dma_status_page);
-		   	/* Need to rewrite hardware status page */
-		   	I810_WRITE(0x02080, 0x1ffff000);
+			/* Need to rewrite hardware status page */
+			I810_WRITE(0x02080, 0x1ffff000);
 		}
-	   	drm_free(dev->dev_private, sizeof(drm_i810_private_t),
+		drm_free(dev->dev_private, sizeof(drm_i810_private_t),
 			 DRM_MEM_DRIVER);
-	   	dev->dev_private = NULL;
+		dev->dev_private = NULL;
 
 		for (i = 0; i < dma->buf_count; i++) {
-			drm_buf_t *buf = dma->buflist[ i ];
+			drm_buf_t *buf = dma->buflist[i];
 			drm_i810_buf_priv_t *buf_priv = buf->dev_private;
-			if ( buf_priv->kernel_virtual && buf->total )
-				drm_ioremapfree(buf_priv->kernel_virtual, buf->total, dev);
+			if (buf_priv->kernel_virtual && buf->total)
+				drm_ioremapfree(buf_priv->kernel_virtual,
+						buf->total, dev);
 		}
 	}
-   	return 0;
+	return 0;
 }
 
-static int i810_wait_ring(drm_device_t *dev, int n)
+static int i810_wait_ring(drm_device_t * dev, int n)
 {
-   	drm_i810_private_t *dev_priv = dev->dev_private;
-   	drm_i810_ring_buffer_t *ring = &(dev_priv->ring);
-   	int iters = 0;
-   	unsigned long end;
+	drm_i810_private_t *dev_priv = dev->dev_private;
+	drm_i810_ring_buffer_t *ring = &(dev_priv->ring);
+	int iters = 0;
+	unsigned long end;
 	unsigned int last_head = I810_READ(LP_RING + RING_HEAD) & HEAD_ADDR;
 
-	end = jiffies + (HZ*3);
-   	while (ring->space < n) {
-	   	ring->head = I810_READ(LP_RING + RING_HEAD) & HEAD_ADDR;
-	   	ring->space = ring->head - (ring->tail+8);
-		if (ring->space < 0) ring->space += ring->Size;
-	   
+	end = jiffies + (HZ * 3);
+	while (ring->space < n) {
+		ring->head = I810_READ(LP_RING + RING_HEAD) & HEAD_ADDR;
+		ring->space = ring->head - (ring->tail + 8);
+		if (ring->space < 0)
+			ring->space += ring->Size;
+
 		if (ring->head != last_head) {
-			end = jiffies + (HZ*3);
+			end = jiffies + (HZ * 3);
 			last_head = ring->head;
 		}
-	  
-	   	iters++;
+
+		iters++;
 		if (time_before(end, jiffies)) {
-		   	DRM_ERROR("space: %d wanted %d\n", ring->space, n);
-		   	DRM_ERROR("lockup\n");
-		   	goto out_wait_ring;
+			DRM_ERROR("space: %d wanted %d\n", ring->space, n);
+			DRM_ERROR("lockup\n");
+			goto out_wait_ring;
 		}
 		udelay(1);
 	}
 
-out_wait_ring:
-   	return iters;
+      out_wait_ring:
+	return iters;
 }
 
-static void i810_kernel_lost_context(drm_device_t *dev)
+static void i810_kernel_lost_context(drm_device_t * dev)
 {
-      	drm_i810_private_t *dev_priv = dev->dev_private;
-   	drm_i810_ring_buffer_t *ring = &(dev_priv->ring);
+	drm_i810_private_t *dev_priv = dev->dev_private;
+	drm_i810_ring_buffer_t *ring = &(dev_priv->ring);
 
-   	ring->head = I810_READ(LP_RING + RING_HEAD) & HEAD_ADDR;
-     	ring->tail = I810_READ(LP_RING + RING_TAIL);
-     	ring->space = ring->head - (ring->tail+8);
-     	if (ring->space < 0) ring->space += ring->Size;
+	ring->head = I810_READ(LP_RING + RING_HEAD) & HEAD_ADDR;
+	ring->tail = I810_READ(LP_RING + RING_TAIL);
+	ring->space = ring->head - (ring->tail + 8);
+	if (ring->space < 0)
+		ring->space += ring->Size;
 }
 
-static int i810_freelist_init(drm_device_t *dev, drm_i810_private_t *dev_priv)
+static int i810_freelist_init(drm_device_t * dev, drm_i810_private_t * dev_priv)
 {
-      	drm_device_dma_t *dma = dev->dma;
-   	int my_idx = 24;
-   	u32 *hw_status = (u32 *)(dev_priv->hw_status_page + my_idx);
-   	int i;
+	drm_device_dma_t *dma = dev->dma;
+	int my_idx = 24;
+	u32 *hw_status = (u32 *) (dev_priv->hw_status_page + my_idx);
+	int i;
 
 	if (dma->buf_count > 1019) {
-	   	/* Not enough space in the status page for the freelist */
-	   	return -EINVAL;
+		/* Not enough space in the status page for the freelist */
+		return -EINVAL;
 	}
 
-   	for (i = 0; i < dma->buf_count; i++) {
-	   	drm_buf_t *buf = dma->buflist[ i ];
-	   	drm_i810_buf_priv_t *buf_priv = buf->dev_private;
+	for (i = 0; i < dma->buf_count; i++) {
+		drm_buf_t *buf = dma->buflist[i];
+		drm_i810_buf_priv_t *buf_priv = buf->dev_private;
 
-	   	buf_priv->in_use = hw_status++;
-	   	buf_priv->my_use_idx = my_idx;
-	   	my_idx += 4;
+		buf_priv->in_use = hw_status++;
+		buf_priv->my_use_idx = my_idx;
+		my_idx += 4;
 
-	   	*buf_priv->in_use = I810_BUF_FREE;
+		*buf_priv->in_use = I810_BUF_FREE;
 
 		buf_priv->kernel_virtual = drm_ioremap(buf->bus_address,
-							buf->total, dev);
+						       buf->total, dev);
 	}
 	return 0;
 }
 
-static int i810_dma_initialize(drm_device_t *dev,
-			       drm_i810_private_t *dev_priv,
-			       drm_i810_init_t *init)
+static int i810_dma_initialize(drm_device_t * dev,
+			       drm_i810_private_t * dev_priv,
+			       drm_i810_init_t * init)
 {
 	struct list_head *list;
 
-   	memset(dev_priv, 0, sizeof(drm_i810_private_t));
+	memset(dev_priv, 0, sizeof(drm_i810_private_t));
 
 	list_for_each(list, &dev->maplist->head) {
 		drm_map_list_t *r_list = list_entry(list, drm_map_list_t, head);
 		if (r_list->map &&
 		    r_list->map->type == _DRM_SHM &&
-		    r_list->map->flags & _DRM_CONTAINS_LOCK ) {
+		    r_list->map->flags & _DRM_CONTAINS_LOCK) {
 			dev_priv->sarea_map = r_list->map;
- 			break;
- 		}
- 	}
+			break;
+		}
+	}
 	if (!dev_priv->sarea_map) {
 		dev->dev_private = (void *)dev_priv;
-	   	i810_dma_cleanup(dev);
-	   	DRM_ERROR("can not find sarea!\n");
-	   	return -EINVAL;
+		i810_dma_cleanup(dev);
+		DRM_ERROR("can not find sarea!\n");
+		return -EINVAL;
 	}
 	dev_priv->mmio_map = drm_core_findmap(dev, init->mmio_offset);
 	if (!dev_priv->mmio_map) {
 		dev->dev_private = (void *)dev_priv;
-	   	i810_dma_cleanup(dev);
-	   	DRM_ERROR("can not find mmio map!\n");
-	   	return -EINVAL;
+		i810_dma_cleanup(dev);
+		DRM_ERROR("can not find mmio map!\n");
+		return -EINVAL;
 	}
 	dev->agp_buffer_map = drm_core_findmap(dev, init->buffers_offset);
 	if (!dev->agp_buffer_map) {
 		dev->dev_private = (void *)dev_priv;
-	   	i810_dma_cleanup(dev);
-	   	DRM_ERROR("can not find dma buffer map!\n");
-	   	return -EINVAL;
+		i810_dma_cleanup(dev);
+		DRM_ERROR("can not find dma buffer map!\n");
+		return -EINVAL;
 	}
 
 	dev_priv->sarea_priv = (drm_i810_sarea_t *)
-		((u8 *)dev_priv->sarea_map->handle +
-		 init->sarea_priv_offset);
+	    ((u8 *) dev_priv->sarea_map->handle + init->sarea_priv_offset);
+
+	dev_priv->ring.Start = init->ring_start;
+	dev_priv->ring.End = init->ring_end;
+	dev_priv->ring.Size = init->ring_size;
 
-   	dev_priv->ring.Start = init->ring_start;
-   	dev_priv->ring.End = init->ring_end;
-   	dev_priv->ring.Size = init->ring_size;
-
-   	dev_priv->ring.virtual_start = drm_ioremap(dev->agp->base +
-						    init->ring_start,
-						    init->ring_size, dev);
-
-   	if (dev_priv->ring.virtual_start == NULL) {
-		dev->dev_private = (void *) dev_priv;
-	   	i810_dma_cleanup(dev);
-	   	DRM_ERROR("can not ioremap virtual address for"
+	dev_priv->ring.virtual_start = drm_ioremap(dev->agp->base +
+						   init->ring_start,
+						   init->ring_size, dev);
+
+	if (dev_priv->ring.virtual_start == NULL) {
+		dev->dev_private = (void *)dev_priv;
+		i810_dma_cleanup(dev);
+		DRM_ERROR("can not ioremap virtual address for"
 			  " ring buffer\n");
-	   	return -ENOMEM;
+		return -ENOMEM;
 	}
 
-   	dev_priv->ring.tail_mask = dev_priv->ring.Size - 1;
+	dev_priv->ring.tail_mask = dev_priv->ring.Size - 1;
 
 	dev_priv->w = init->w;
 	dev_priv->h = init->h;
@@ -395,33 +416,33 @@ static int i810_dma_initialize(drm_devic
 	dev_priv->back_di1 = init->back_offset | init->pitch_bits;
 	dev_priv->zi1 = init->depth_offset | init->pitch_bits;
 
-   	/* Program Hardware Status Page */
-   	dev_priv->hw_status_page =
-		pci_alloc_consistent(dev->pdev, PAGE_SIZE,
-						&dev_priv->dma_status_page);
-   	if (!dev_priv->hw_status_page) {
+	/* Program Hardware Status Page */
+	dev_priv->hw_status_page =
+	    pci_alloc_consistent(dev->pdev, PAGE_SIZE,
+				 &dev_priv->dma_status_page);
+	if (!dev_priv->hw_status_page) {
 		dev->dev_private = (void *)dev_priv;
 		i810_dma_cleanup(dev);
 		DRM_ERROR("Can not allocate hardware status page\n");
 		return -ENOMEM;
 	}
-   	memset(dev_priv->hw_status_page, 0, PAGE_SIZE);
-   	DRM_DEBUG("hw status page @ %p\n", dev_priv->hw_status_page);
+	memset(dev_priv->hw_status_page, 0, PAGE_SIZE);
+	DRM_DEBUG("hw status page @ %p\n", dev_priv->hw_status_page);
 
 	I810_WRITE(0x02080, dev_priv->dma_status_page);
-   	DRM_DEBUG("Enabled hardware status page\n");
+	DRM_DEBUG("Enabled hardware status page\n");
 
-   	/* Now we need to init our freelist */
+	/* Now we need to init our freelist */
 	if (i810_freelist_init(dev, dev_priv) != 0) {
 		dev->dev_private = (void *)dev_priv;
-	   	i810_dma_cleanup(dev);
-	   	DRM_ERROR("Not enough space in the status page for"
+		i810_dma_cleanup(dev);
+		DRM_ERROR("Not enough space in the status page for"
 			  " the freelist\n");
-	   	return -ENOMEM;
+		return -ENOMEM;
 	}
 	dev->dev_private = (void *)dev_priv;
 
-   	return 0;
+	return 0;
 }
 
 /* i810 DRM version 1.1 used a smaller init structure with different
@@ -435,12 +456,12 @@ static int i810_dma_initialize(drm_devic
  *    If it isn't then we have a v1.1 client. Fix up params.
  *    If it is, then we have a 1.2 client... get the rest of the data.
  */
-static int i810_dma_init_compat(drm_i810_init_t *init, unsigned long arg)
+static int i810_dma_init_compat(drm_i810_init_t * init, unsigned long arg)
 {
 
 	/* Get v1.1 init data */
-	if (copy_from_user(init, (drm_i810_pre12_init_t __user *)arg,
-			  sizeof(drm_i810_pre12_init_t))) {
+	if (copy_from_user(init, (drm_i810_pre12_init_t __user *) arg,
+			   sizeof(drm_i810_pre12_init_t))) {
 		return -EFAULT;
 	}
 
@@ -448,7 +469,7 @@ static int i810_dma_init_compat(drm_i810
 
 		/* This is a v1.2 client, just get the v1.2 init data */
 		DRM_INFO("Using POST v1.2 init.\n");
-		if (copy_from_user(init, (drm_i810_init_t __user *)arg,
+		if (copy_from_user(init, (drm_i810_init_t __user *) arg,
 				   sizeof(drm_i810_init_t))) {
 			return -EFAULT;
 		}
@@ -456,12 +477,12 @@ static int i810_dma_init_compat(drm_i810
 
 		/* This is a v1.1 client, fix the params */
 		DRM_INFO("Using PRE v1.2 init.\n");
-	 	init->pitch_bits = init->h;
-	 	init->pitch = init->w;
-	 	init->h = init->overlay_physical;
-	 	init->w = init->overlay_offset;
-	 	init->overlay_physical = 0;
-	 	init->overlay_offset = 0;
+		init->pitch_bits = init->h;
+		init->pitch = init->w;
+		init->h = init->overlay_physical;
+		init->w = init->overlay_offset;
+		init->overlay_physical = 0;
+		init->overlay_offset = 0;
 	}
 
 	return 0;
@@ -470,232 +491,225 @@ static int i810_dma_init_compat(drm_i810
 static int i810_dma_init(struct inode *inode, struct file *filp,
 		  unsigned int cmd, unsigned long arg)
 {
-   	drm_file_t *priv = filp->private_data;
-   	drm_device_t *dev = priv->head->dev;
-   	drm_i810_private_t *dev_priv;
-   	drm_i810_init_t init;
-   	int retcode = 0;
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
+	drm_i810_private_t *dev_priv;
+	drm_i810_init_t init;
+	int retcode = 0;
 
 	/* Get only the init func */
-	if (copy_from_user(&init, (void __user *)arg, sizeof(drm_i810_init_func_t))) 
+	if (copy_from_user
+	    (&init, (void __user *)arg, sizeof(drm_i810_init_func_t)))
 		return -EFAULT;
 
-   	switch(init.func) {
-	 	case I810_INIT_DMA:
-	 	       	/* This case is for backward compatibility. It
-			 * handles XFree 4.1.0 and 4.2.0, and has to
-			 * do some parameter checking as described below.
-			 * It will someday go away.
-			 */
-			retcode = i810_dma_init_compat(&init, arg);
-			if (retcode)
-				return retcode;
-
-	   		dev_priv = drm_alloc(sizeof(drm_i810_private_t),
-					     DRM_MEM_DRIVER);
-	   		if (dev_priv == NULL)
-				return -ENOMEM;
-	   		retcode = i810_dma_initialize(dev, dev_priv, &init);
-			break;
-
-		default:
-	 	case I810_INIT_DMA_1_4:
-			DRM_INFO("Using v1.4 init.\n");
-  			if (copy_from_user(&init, (drm_i810_init_t __user *)arg,
-					  sizeof(drm_i810_init_t))) {
-				return -EFAULT;
-			}
-	   		dev_priv = drm_alloc(sizeof(drm_i810_private_t),
-					     DRM_MEM_DRIVER);
-			if (dev_priv == NULL) 
-				return -ENOMEM;
-	   		retcode = i810_dma_initialize(dev, dev_priv, &init);
-			break;
-
-	 	case I810_CLEANUP_DMA:
-		        DRM_INFO("DMA Cleanup\n");
-	   		retcode = i810_dma_cleanup(dev);
-              	   	break;
+	switch (init.func) {
+	case I810_INIT_DMA:
+		/* This case is for backward compatibility. It
+		 * handles XFree 4.1.0 and 4.2.0, and has to
+		 * do some parameter checking as described below.
+		 * It will someday go away.
+		 */
+		retcode = i810_dma_init_compat(&init, arg);
+		if (retcode)
+			return retcode;
+
+		dev_priv = drm_alloc(sizeof(drm_i810_private_t),
+				     DRM_MEM_DRIVER);
+		if (dev_priv == NULL)
+			return -ENOMEM;
+		retcode = i810_dma_initialize(dev, dev_priv, &init);
+		break;
+
+	default:
+	case I810_INIT_DMA_1_4:
+		DRM_INFO("Using v1.4 init.\n");
+		if (copy_from_user(&init, (drm_i810_init_t __user *) arg,
+				   sizeof(drm_i810_init_t))) {
+			return -EFAULT;
+		}
+		dev_priv = drm_alloc(sizeof(drm_i810_private_t),
+				     DRM_MEM_DRIVER);
+		if (dev_priv == NULL)
+			return -ENOMEM;
+		retcode = i810_dma_initialize(dev, dev_priv, &init);
+		break;
+
+	case I810_CLEANUP_DMA:
+		DRM_INFO("DMA Cleanup\n");
+		retcode = i810_dma_cleanup(dev);
+		break;
 	}
 
-   	return retcode;
+	return retcode;
 }
 
-
-
 /* Most efficient way to verify state for the i810 is as it is
  * emitted.  Non-conformant state is silently dropped.
  *
  * Use 'volatile' & local var tmp to force the emitted values to be
  * identical to the verified ones.
  */
-static void i810EmitContextVerified( drm_device_t *dev,
-				     volatile unsigned int *code )
+static void i810EmitContextVerified(drm_device_t * dev,
+				    volatile unsigned int *code)
 {
-   	drm_i810_private_t *dev_priv = dev->dev_private;
+	drm_i810_private_t *dev_priv = dev->dev_private;
 	int i, j = 0;
 	unsigned int tmp;
 	RING_LOCALS;
 
-	BEGIN_LP_RING( I810_CTX_SETUP_SIZE );
+	BEGIN_LP_RING(I810_CTX_SETUP_SIZE);
 
-	OUT_RING( GFX_OP_COLOR_FACTOR );
-	OUT_RING( code[I810_CTXREG_CF1] );
+	OUT_RING(GFX_OP_COLOR_FACTOR);
+	OUT_RING(code[I810_CTXREG_CF1]);
 
-	OUT_RING( GFX_OP_STIPPLE );
-	OUT_RING( code[I810_CTXREG_ST1] );
+	OUT_RING(GFX_OP_STIPPLE);
+	OUT_RING(code[I810_CTXREG_ST1]);
 
-	for ( i = 4 ; i < I810_CTX_SETUP_SIZE ; i++ ) {
+	for (i = 4; i < I810_CTX_SETUP_SIZE; i++) {
 		tmp = code[i];
 
-		if ((tmp & (7<<29)) == (3<<29) &&
-		    (tmp & (0x1f<<24)) < (0x1d<<24))
-		{
-			OUT_RING( tmp );
+		if ((tmp & (7 << 29)) == (3 << 29) &&
+		    (tmp & (0x1f << 24)) < (0x1d << 24)) {
+			OUT_RING(tmp);
 			j++;
-		}
-		else printk("constext state dropped!!!\n");
+		} else
+			printk("constext state dropped!!!\n");
 	}
 
 	if (j & 1)
-		OUT_RING( 0 );
+		OUT_RING(0);
 
 	ADVANCE_LP_RING();
 }
 
-static void i810EmitTexVerified( drm_device_t *dev,
-				 volatile unsigned int *code )
+static void i810EmitTexVerified(drm_device_t * dev, volatile unsigned int *code)
 {
-   	drm_i810_private_t *dev_priv = dev->dev_private;
+	drm_i810_private_t *dev_priv = dev->dev_private;
 	int i, j = 0;
 	unsigned int tmp;
 	RING_LOCALS;
 
-	BEGIN_LP_RING( I810_TEX_SETUP_SIZE );
+	BEGIN_LP_RING(I810_TEX_SETUP_SIZE);
 
-	OUT_RING( GFX_OP_MAP_INFO );
-	OUT_RING( code[I810_TEXREG_MI1] );
-	OUT_RING( code[I810_TEXREG_MI2] );
-	OUT_RING( code[I810_TEXREG_MI3] );
+	OUT_RING(GFX_OP_MAP_INFO);
+	OUT_RING(code[I810_TEXREG_MI1]);
+	OUT_RING(code[I810_TEXREG_MI2]);
+	OUT_RING(code[I810_TEXREG_MI3]);
 
-	for ( i = 4 ; i < I810_TEX_SETUP_SIZE ; i++ ) {
+	for (i = 4; i < I810_TEX_SETUP_SIZE; i++) {
 		tmp = code[i];
 
-		if ((tmp & (7<<29)) == (3<<29) &&
-		    (tmp & (0x1f<<24)) < (0x1d<<24))
-		{
-			OUT_RING( tmp );
+		if ((tmp & (7 << 29)) == (3 << 29) &&
+		    (tmp & (0x1f << 24)) < (0x1d << 24)) {
+			OUT_RING(tmp);
 			j++;
-		}
-		else printk("texture state dropped!!!\n");
+		} else
+			printk("texture state dropped!!!\n");
 	}
 
 	if (j & 1)
-		OUT_RING( 0 );
+		OUT_RING(0);
 
 	ADVANCE_LP_RING();
 }
 
-
 /* Need to do some additional checking when setting the dest buffer.
  */
-static void i810EmitDestVerified( drm_device_t *dev,
-				  volatile unsigned int *code )
+static void i810EmitDestVerified(drm_device_t * dev,
+				 volatile unsigned int *code)
 {
-   	drm_i810_private_t *dev_priv = dev->dev_private;
+	drm_i810_private_t *dev_priv = dev->dev_private;
 	unsigned int tmp;
 	RING_LOCALS;
 
-	BEGIN_LP_RING( I810_DEST_SETUP_SIZE + 2 );
+	BEGIN_LP_RING(I810_DEST_SETUP_SIZE + 2);
 
 	tmp = code[I810_DESTREG_DI1];
 	if (tmp == dev_priv->front_di1 || tmp == dev_priv->back_di1) {
-		OUT_RING( CMD_OP_DESTBUFFER_INFO );
-		OUT_RING( tmp );
+		OUT_RING(CMD_OP_DESTBUFFER_INFO);
+		OUT_RING(tmp);
 	} else
-	   DRM_DEBUG("bad di1 %x (allow %x or %x)\n",
-		     tmp, dev_priv->front_di1, dev_priv->back_di1);
+		DRM_DEBUG("bad di1 %x (allow %x or %x)\n",
+			  tmp, dev_priv->front_di1, dev_priv->back_di1);
 
 	/* invarient:
 	 */
-	OUT_RING( CMD_OP_Z_BUFFER_INFO );
-	OUT_RING( dev_priv->zi1 );
+	OUT_RING(CMD_OP_Z_BUFFER_INFO);
+	OUT_RING(dev_priv->zi1);
 
-	OUT_RING( GFX_OP_DESTBUFFER_VARS );
-	OUT_RING( code[I810_DESTREG_DV1] );
+	OUT_RING(GFX_OP_DESTBUFFER_VARS);
+	OUT_RING(code[I810_DESTREG_DV1]);
 
-	OUT_RING( GFX_OP_DRAWRECT_INFO );
-	OUT_RING( code[I810_DESTREG_DR1] );
-	OUT_RING( code[I810_DESTREG_DR2] );
-	OUT_RING( code[I810_DESTREG_DR3] );
-	OUT_RING( code[I810_DESTREG_DR4] );
-	OUT_RING( 0 );
+	OUT_RING(GFX_OP_DRAWRECT_INFO);
+	OUT_RING(code[I810_DESTREG_DR1]);
+	OUT_RING(code[I810_DESTREG_DR2]);
+	OUT_RING(code[I810_DESTREG_DR3]);
+	OUT_RING(code[I810_DESTREG_DR4]);
+	OUT_RING(0);
 
 	ADVANCE_LP_RING();
 }
 
-
-
-static void i810EmitState( drm_device_t *dev )
+static void i810EmitState(drm_device_t * dev)
 {
-   	drm_i810_private_t *dev_priv = dev->dev_private;
-      	drm_i810_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_i810_private_t *dev_priv = dev->dev_private;
+	drm_i810_sarea_t *sarea_priv = dev_priv->sarea_priv;
 	unsigned int dirty = sarea_priv->dirty;
-	
+
 	DRM_DEBUG("%s %x\n", __FUNCTION__, dirty);
 
 	if (dirty & I810_UPLOAD_BUFFERS) {
-		i810EmitDestVerified( dev, sarea_priv->BufferState );
+		i810EmitDestVerified(dev, sarea_priv->BufferState);
 		sarea_priv->dirty &= ~I810_UPLOAD_BUFFERS;
 	}
 
 	if (dirty & I810_UPLOAD_CTX) {
-		i810EmitContextVerified( dev, sarea_priv->ContextState );
+		i810EmitContextVerified(dev, sarea_priv->ContextState);
 		sarea_priv->dirty &= ~I810_UPLOAD_CTX;
 	}
 
 	if (dirty & I810_UPLOAD_TEX0) {
-		i810EmitTexVerified( dev, sarea_priv->TexState[0] );
+		i810EmitTexVerified(dev, sarea_priv->TexState[0]);
 		sarea_priv->dirty &= ~I810_UPLOAD_TEX0;
 	}
 
 	if (dirty & I810_UPLOAD_TEX1) {
-		i810EmitTexVerified( dev, sarea_priv->TexState[1] );
+		i810EmitTexVerified(dev, sarea_priv->TexState[1]);
 		sarea_priv->dirty &= ~I810_UPLOAD_TEX1;
 	}
 }
 
-
-
 /* need to verify
  */
-static void i810_dma_dispatch_clear( drm_device_t *dev, int flags,
-				     unsigned int clear_color,
-				     unsigned int clear_zval )
+static void i810_dma_dispatch_clear(drm_device_t * dev, int flags,
+				    unsigned int clear_color,
+				    unsigned int clear_zval)
 {
-   	drm_i810_private_t *dev_priv = dev->dev_private;
-      	drm_i810_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_i810_private_t *dev_priv = dev->dev_private;
+	drm_i810_sarea_t *sarea_priv = dev_priv->sarea_priv;
 	int nbox = sarea_priv->nbox;
 	drm_clip_rect_t *pbox = sarea_priv->boxes;
 	int pitch = dev_priv->pitch;
 	int cpp = 2;
 	int i;
 	RING_LOCALS;
-	
-	if ( dev_priv->current_page == 1 ) {
-	        unsigned int tmp = flags;
-	       
+
+	if (dev_priv->current_page == 1) {
+		unsigned int tmp = flags;
+
 		flags &= ~(I810_FRONT | I810_BACK);
-		if (tmp & I810_FRONT) flags |= I810_BACK;
-		if (tmp & I810_BACK) flags |= I810_FRONT;
+		if (tmp & I810_FRONT)
+			flags |= I810_BACK;
+		if (tmp & I810_BACK)
+			flags |= I810_FRONT;
 	}
 
-  	i810_kernel_lost_context(dev);
+	i810_kernel_lost_context(dev);
 
-      	if (nbox > I810_NR_SAREA_CLIPRECTS)
-     		nbox = I810_NR_SAREA_CLIPRECTS;
+	if (nbox > I810_NR_SAREA_CLIPRECTS)
+		nbox = I810_NR_SAREA_CLIPRECTS;
 
-	for (i = 0 ; i < nbox ; i++, pbox++) {
+	for (i = 0; i < nbox; i++, pbox++) {
 		unsigned int x = pbox->x1;
 		unsigned int y = pbox->y1;
 		unsigned int width = (pbox->x2 - x) * cpp;
@@ -704,52 +718,48 @@ static void i810_dma_dispatch_clear( drm
 
 		if (pbox->x1 > pbox->x2 ||
 		    pbox->y1 > pbox->y2 ||
-		    pbox->x2 > dev_priv->w ||
-		    pbox->y2 > dev_priv->h)
+		    pbox->x2 > dev_priv->w || pbox->y2 > dev_priv->h)
 			continue;
 
-	   	if ( flags & I810_FRONT ) {
-			BEGIN_LP_RING( 6 );
-			OUT_RING( BR00_BITBLT_CLIENT |
-				  BR00_OP_COLOR_BLT | 0x3 );
-			OUT_RING( BR13_SOLID_PATTERN | (0xF0 << 16) | pitch );
-			OUT_RING( (height << 16) | width );
-			OUT_RING( start );
-			OUT_RING( clear_color );
-			OUT_RING( 0 );
+		if (flags & I810_FRONT) {
+			BEGIN_LP_RING(6);
+			OUT_RING(BR00_BITBLT_CLIENT | BR00_OP_COLOR_BLT | 0x3);
+			OUT_RING(BR13_SOLID_PATTERN | (0xF0 << 16) | pitch);
+			OUT_RING((height << 16) | width);
+			OUT_RING(start);
+			OUT_RING(clear_color);
+			OUT_RING(0);
 			ADVANCE_LP_RING();
 		}
 
-		if ( flags & I810_BACK ) {
-			BEGIN_LP_RING( 6 );
-			OUT_RING( BR00_BITBLT_CLIENT |
-				  BR00_OP_COLOR_BLT | 0x3 );
-			OUT_RING( BR13_SOLID_PATTERN | (0xF0 << 16) | pitch );
-			OUT_RING( (height << 16) | width );
-			OUT_RING( dev_priv->back_offset + start );
-			OUT_RING( clear_color );
-			OUT_RING( 0 );
+		if (flags & I810_BACK) {
+			BEGIN_LP_RING(6);
+			OUT_RING(BR00_BITBLT_CLIENT | BR00_OP_COLOR_BLT | 0x3);
+			OUT_RING(BR13_SOLID_PATTERN | (0xF0 << 16) | pitch);
+			OUT_RING((height << 16) | width);
+			OUT_RING(dev_priv->back_offset + start);
+			OUT_RING(clear_color);
+			OUT_RING(0);
 			ADVANCE_LP_RING();
 		}
 
-		if ( flags & I810_DEPTH ) {
-			BEGIN_LP_RING( 6 );
-			OUT_RING( BR00_BITBLT_CLIENT |
-				  BR00_OP_COLOR_BLT | 0x3 );
-			OUT_RING( BR13_SOLID_PATTERN | (0xF0 << 16) | pitch );
-			OUT_RING( (height << 16) | width );
-			OUT_RING( dev_priv->depth_offset + start );
-			OUT_RING( clear_zval );
-			OUT_RING( 0 );
+		if (flags & I810_DEPTH) {
+			BEGIN_LP_RING(6);
+			OUT_RING(BR00_BITBLT_CLIENT | BR00_OP_COLOR_BLT | 0x3);
+			OUT_RING(BR13_SOLID_PATTERN | (0xF0 << 16) | pitch);
+			OUT_RING((height << 16) | width);
+			OUT_RING(dev_priv->depth_offset + start);
+			OUT_RING(clear_zval);
+			OUT_RING(0);
 			ADVANCE_LP_RING();
 		}
 	}
 }
 
-static void i810_dma_dispatch_swap( drm_device_t *dev )
+static void i810_dma_dispatch_swap(drm_device_t * dev)
 {
-   	drm_i810_private_t *dev_priv = dev->dev_private;
-      	drm_i810_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_i810_private_t *dev_priv = dev->dev_private;
+	drm_i810_sarea_t *sarea_priv = dev_priv->sarea_priv;
 	int nbox = sarea_priv->nbox;
 	drm_clip_rect_t *pbox = sarea_priv->boxes;
 	int pitch = dev_priv->pitch;
@@ -759,75 +769,71 @@ static void i810_dma_dispatch_swap( drm_
 
 	DRM_DEBUG("swapbuffers\n");
 
-  	i810_kernel_lost_context(dev);
+	i810_kernel_lost_context(dev);
 
-      	if (nbox > I810_NR_SAREA_CLIPRECTS)
-     		nbox = I810_NR_SAREA_CLIPRECTS;
+	if (nbox > I810_NR_SAREA_CLIPRECTS)
+		nbox = I810_NR_SAREA_CLIPRECTS;
 
-	for (i = 0 ; i < nbox; i++, pbox++)
-	{
+	for (i = 0; i < nbox; i++, pbox++) {
 		unsigned int w = pbox->x2 - pbox->x1;
 		unsigned int h = pbox->y2 - pbox->y1;
-		unsigned int dst = pbox->x1*cpp + pbox->y1*pitch;
+		unsigned int dst = pbox->x1 * cpp + pbox->y1 * pitch;
 		unsigned int start = dst;
 
 		if (pbox->x1 > pbox->x2 ||
 		    pbox->y1 > pbox->y2 ||
-		    pbox->x2 > dev_priv->w ||
-		    pbox->y2 > dev_priv->h)
+		    pbox->x2 > dev_priv->w || pbox->y2 > dev_priv->h)
 			continue;
 
-		BEGIN_LP_RING( 6 );
-		OUT_RING( BR00_BITBLT_CLIENT | BR00_OP_SRC_COPY_BLT | 0x4 );
-		OUT_RING( pitch | (0xCC << 16));
-		OUT_RING( (h << 16) | (w * cpp));
+		BEGIN_LP_RING(6);
+		OUT_RING(BR00_BITBLT_CLIENT | BR00_OP_SRC_COPY_BLT | 0x4);
+		OUT_RING(pitch | (0xCC << 16));
+		OUT_RING((h << 16) | (w * cpp));
 		if (dev_priv->current_page == 0)
-		  OUT_RING(dev_priv->front_offset + start);
+			OUT_RING(dev_priv->front_offset + start);
 		else
-		  OUT_RING(dev_priv->back_offset + start);
-		OUT_RING( pitch );
+			OUT_RING(dev_priv->back_offset + start);
+		OUT_RING(pitch);
 		if (dev_priv->current_page == 0)
-		  OUT_RING(dev_priv->back_offset + start);
+			OUT_RING(dev_priv->back_offset + start);
 		else
-		  OUT_RING(dev_priv->front_offset + start);
+			OUT_RING(dev_priv->front_offset + start);
 		ADVANCE_LP_RING();
 	}
 }
 
-
-static void i810_dma_dispatch_vertex(drm_device_t *dev,
-				     drm_buf_t *buf,
-				     int discard,
-				     int used)
+static void i810_dma_dispatch_vertex(drm_device_t * dev,
+				     drm_buf_t * buf, int discard, int used)
 {
-   	drm_i810_private_t *dev_priv = dev->dev_private;
+	drm_i810_private_t *dev_priv = dev->dev_private;
 	drm_i810_buf_priv_t *buf_priv = buf->dev_private;
-   	drm_i810_sarea_t *sarea_priv = dev_priv->sarea_priv;
-   	drm_clip_rect_t *box = sarea_priv->boxes;
-   	int nbox = sarea_priv->nbox;
+	drm_i810_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_clip_rect_t *box = sarea_priv->boxes;
+	int nbox = sarea_priv->nbox;
 	unsigned long address = (unsigned long)buf->bus_address;
 	unsigned long start = address - dev->agp->base;
 	int i = 0;
-   	RING_LOCALS;
+	RING_LOCALS;
 
-   	i810_kernel_lost_context(dev);
+	i810_kernel_lost_context(dev);
 
-   	if (nbox > I810_NR_SAREA_CLIPRECTS)
+	if (nbox > I810_NR_SAREA_CLIPRECTS)
 		nbox = I810_NR_SAREA_CLIPRECTS;
 
-	if (used > 4*1024)
+	if (used > 4 * 1024)
 		used = 0;
 
 	if (sarea_priv->dirty)
-	   i810EmitState( dev );
+		i810EmitState(dev);
 
 	if (buf_priv->currently_mapped == I810_BUF_MAPPED) {
 		unsigned int prim = (sarea_priv->vertex_prim & PR_MASK);
 
-		*(u32 *)buf_priv->kernel_virtual = ((GFX_OP_PRIMITIVE | prim | ((used/4)-2)));
+		*(u32 *) buf_priv->kernel_virtual =
+		    ((GFX_OP_PRIMITIVE | prim | ((used / 4) - 2)));
 
 		if (used & 4) {
-			*(u32 *)((u32)buf_priv->kernel_virtual + used) = 0;
+			*(u32 *) ((u32) buf_priv->kernel_virtual + used) = 0;
 			used += 4;
 		}
 
@@ -838,19 +844,20 @@ static void i810_dma_dispatch_vertex(drm
 		do {
 			if (i < nbox) {
 				BEGIN_LP_RING(4);
-				OUT_RING( GFX_OP_SCISSOR | SC_UPDATE_SCISSOR |
-					  SC_ENABLE );
-				OUT_RING( GFX_OP_SCISSOR_INFO );
-				OUT_RING( box[i].x1 | (box[i].y1<<16) );
-				OUT_RING( (box[i].x2-1) | ((box[i].y2-1)<<16) );
+				OUT_RING(GFX_OP_SCISSOR | SC_UPDATE_SCISSOR |
+					 SC_ENABLE);
+				OUT_RING(GFX_OP_SCISSOR_INFO);
+				OUT_RING(box[i].x1 | (box[i].y1 << 16));
+				OUT_RING((box[i].x2 -
+					  1) | ((box[i].y2 - 1) << 16));
 				ADVANCE_LP_RING();
 			}
 
 			BEGIN_LP_RING(4);
-			OUT_RING( CMD_OP_BATCH_BUFFER );
-			OUT_RING( start | BB1_PROTECTED );
-			OUT_RING( start + used - 4 );
-			OUT_RING( 0 );
+			OUT_RING(CMD_OP_BATCH_BUFFER);
+			OUT_RING(start | BB1_PROTECTED);
+			OUT_RING(start + used - 4);
+			OUT_RING(0);
 			ADVANCE_LP_RING();
 
 		} while (++i < nbox);
@@ -859,59 +866,59 @@ static void i810_dma_dispatch_vertex(drm
 	if (discard) {
 		dev_priv->counter++;
 
-		(void) cmpxchg(buf_priv->in_use, I810_BUF_CLIENT,
-			       I810_BUF_HARDWARE);
+		(void)cmpxchg(buf_priv->in_use, I810_BUF_CLIENT,
+			      I810_BUF_HARDWARE);
 
 		BEGIN_LP_RING(8);
-		OUT_RING( CMD_STORE_DWORD_IDX );
-		OUT_RING( 20 );
-		OUT_RING( dev_priv->counter );
-		OUT_RING( CMD_STORE_DWORD_IDX );
-		OUT_RING( buf_priv->my_use_idx );
-		OUT_RING( I810_BUF_FREE );
-		OUT_RING( CMD_REPORT_HEAD );
-		OUT_RING( 0 );
+		OUT_RING(CMD_STORE_DWORD_IDX);
+		OUT_RING(20);
+		OUT_RING(dev_priv->counter);
+		OUT_RING(CMD_STORE_DWORD_IDX);
+		OUT_RING(buf_priv->my_use_idx);
+		OUT_RING(I810_BUF_FREE);
+		OUT_RING(CMD_REPORT_HEAD);
+		OUT_RING(0);
 		ADVANCE_LP_RING();
 	}
 }
 
-static void i810_dma_dispatch_flip( drm_device_t *dev )
+static void i810_dma_dispatch_flip(drm_device_t * dev)
 {
-        drm_i810_private_t *dev_priv = dev->dev_private;
+	drm_i810_private_t *dev_priv = dev->dev_private;
 	int pitch = dev_priv->pitch;
 	RING_LOCALS;
 
-	DRM_DEBUG( "%s: page=%d pfCurrentPage=%d\n", 
-		__FUNCTION__, 
-		dev_priv->current_page,
-		dev_priv->sarea_priv->pf_current_page);
-	
-        i810_kernel_lost_context(dev);
-
-	BEGIN_LP_RING( 2 );
-   	OUT_RING( INST_PARSER_CLIENT | INST_OP_FLUSH | INST_FLUSH_MAP_CACHE ); 
-	OUT_RING( 0 );
+	DRM_DEBUG("%s: page=%d pfCurrentPage=%d\n",
+		  __FUNCTION__,
+		  dev_priv->current_page,
+		  dev_priv->sarea_priv->pf_current_page);
+
+	i810_kernel_lost_context(dev);
+
+	BEGIN_LP_RING(2);
+	OUT_RING(INST_PARSER_CLIENT | INST_OP_FLUSH | INST_FLUSH_MAP_CACHE);
+	OUT_RING(0);
 	ADVANCE_LP_RING();
 
-	BEGIN_LP_RING( I810_DEST_SETUP_SIZE + 2 );
+	BEGIN_LP_RING(I810_DEST_SETUP_SIZE + 2);
 	/* On i815 at least ASYNC is buggy */
 	/* pitch<<5 is from 11.2.8 p158,
 	   its the pitch / 8 then left shifted 8,
 	   so (pitch >> 3) << 8 */
-	OUT_RING( CMD_OP_FRONTBUFFER_INFO | (pitch<<5) /*| ASYNC_FLIP */ );
-	if ( dev_priv->current_page == 0 ) {
-		OUT_RING( dev_priv->back_offset );
+	OUT_RING(CMD_OP_FRONTBUFFER_INFO | (pitch << 5) /*| ASYNC_FLIP */ );
+	if (dev_priv->current_page == 0) {
+		OUT_RING(dev_priv->back_offset);
 		dev_priv->current_page = 1;
 	} else {
-		OUT_RING( dev_priv->front_offset );
+		OUT_RING(dev_priv->front_offset);
 		dev_priv->current_page = 0;
 	}
 	OUT_RING(0);
 	ADVANCE_LP_RING();
 
 	BEGIN_LP_RING(2);
-	OUT_RING( CMD_OP_WAIT_FOR_EVENT | WAIT_FOR_PLANE_A_FLIP );
-	OUT_RING( 0 );
+	OUT_RING(CMD_OP_WAIT_FOR_EVENT | WAIT_FOR_PLANE_A_FLIP);
+	OUT_RING(0);
 	ADVANCE_LP_RING();
 
 	/* Increment the frame counter.  The client-side 3D driver must
@@ -922,46 +929,46 @@ static void i810_dma_dispatch_flip( drm_
 
 }
 
-static void i810_dma_quiescent(drm_device_t *dev)
+static void i810_dma_quiescent(drm_device_t * dev)
 {
-      	drm_i810_private_t *dev_priv = dev->dev_private;
-   	RING_LOCALS;
+	drm_i810_private_t *dev_priv = dev->dev_private;
+	RING_LOCALS;
 
 /*  	printk("%s\n", __FUNCTION__); */
 
-  	i810_kernel_lost_context(dev);
+	i810_kernel_lost_context(dev);
 
-   	BEGIN_LP_RING(4);
-   	OUT_RING( INST_PARSER_CLIENT | INST_OP_FLUSH | INST_FLUSH_MAP_CACHE );
-   	OUT_RING( CMD_REPORT_HEAD );
-      	OUT_RING( 0 );
-      	OUT_RING( 0 );
-   	ADVANCE_LP_RING();
+	BEGIN_LP_RING(4);
+	OUT_RING(INST_PARSER_CLIENT | INST_OP_FLUSH | INST_FLUSH_MAP_CACHE);
+	OUT_RING(CMD_REPORT_HEAD);
+	OUT_RING(0);
+	OUT_RING(0);
+	ADVANCE_LP_RING();
 
-	i810_wait_ring( dev, dev_priv->ring.Size - 8 );
+	i810_wait_ring(dev, dev_priv->ring.Size - 8);
 }
 
-static int i810_flush_queue(drm_device_t *dev)
+static int i810_flush_queue(drm_device_t * dev)
 {
-   	drm_i810_private_t *dev_priv = dev->dev_private;
+	drm_i810_private_t *dev_priv = dev->dev_private;
 	drm_device_dma_t *dma = dev->dma;
-   	int i, ret = 0;
-   	RING_LOCALS;
-	
+	int i, ret = 0;
+	RING_LOCALS;
+
 /*  	printk("%s\n", __FUNCTION__); */
 
-   	i810_kernel_lost_context(dev);
+	i810_kernel_lost_context(dev);
 
-   	BEGIN_LP_RING(2);
-      	OUT_RING( CMD_REPORT_HEAD );
-      	OUT_RING( 0 );
-      	ADVANCE_LP_RING();
-
-	i810_wait_ring( dev, dev_priv->ring.Size - 8 );
-
-   	for (i = 0; i < dma->buf_count; i++) {
-	   	drm_buf_t *buf = dma->buflist[ i ];
-	   	drm_i810_buf_priv_t *buf_priv = buf->dev_private;
+	BEGIN_LP_RING(2);
+	OUT_RING(CMD_REPORT_HEAD);
+	OUT_RING(0);
+	ADVANCE_LP_RING();
+
+	i810_wait_ring(dev, dev_priv->ring.Size - 8);
+
+	for (i = 0; i < dma->buf_count; i++) {
+		drm_buf_t *buf = dma->buflist[i];
+		drm_i810_buf_priv_t *buf_priv = buf->dev_private;
 
 		int used = cmpxchg(buf_priv->in_use, I810_BUF_HARDWARE,
 				   I810_BUF_FREE);
@@ -972,24 +979,27 @@ static int i810_flush_queue(drm_device_t
 			DRM_DEBUG("still on client\n");
 	}
 
-   	return ret;
+	return ret;
 }
 
 /* Must be called with the lock held */
 void i810_reclaim_buffers(drm_device_t *dev, struct file *filp)
 {
 	drm_device_dma_t *dma = dev->dma;
-	int		 i;
+	int i;
 
-	if (!dma) return;
-      	if (!dev->dev_private) return;
-	if (!dma->buflist) return;
+	if (!dma)
+		return;
+	if (!dev->dev_private)
+		return;
+	if (!dma->buflist)
+		return;
 
-        i810_flush_queue(dev);
+	i810_flush_queue(dev);
 
 	for (i = 0; i < dma->buf_count; i++) {
-	   	drm_buf_t *buf = dma->buflist[ i ];
-	   	drm_i810_buf_priv_t *buf_priv = buf->dev_private;
+		drm_buf_t *buf = dma->buflist[i];
+		drm_i810_buf_priv_t *buf_priv = buf->dev_private;
 
 		if (buf->filp == filp && buf_priv) {
 			int used = cmpxchg(buf_priv->in_use, I810_BUF_CLIENT,
@@ -998,37 +1008,37 @@ void i810_reclaim_buffers(drm_device_t *
 			if (used == I810_BUF_CLIENT)
 				DRM_DEBUG("reclaimed from client\n");
 			if (buf_priv->currently_mapped == I810_BUF_MAPPED)
-		     		buf_priv->currently_mapped = I810_BUF_UNMAPPED;
+				buf_priv->currently_mapped = I810_BUF_UNMAPPED;
 		}
 	}
 }
 
-int i810_flush_ioctl(struct inode *inode, struct file *filp,
-		     unsigned int cmd, unsigned long arg)
+static int i810_flush_ioctl(struct inode *inode, struct file *filp,
+			    unsigned int cmd, unsigned long arg)
 {
-   	drm_file_t	  *priv	  = filp->private_data;
-   	drm_device_t	  *dev	  = priv->head->dev;
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
 
 	LOCK_TEST_WITH_RETURN(dev, filp);
 
-   	i810_flush_queue(dev);
-   	return 0;
+	i810_flush_queue(dev);
+	return 0;
 }
 
-
 static int i810_dma_vertex(struct inode *inode, struct file *filp,
-	       unsigned int cmd, unsigned long arg)
+			   unsigned int cmd, unsigned long arg)
 {
 	drm_file_t *priv = filp->private_data;
 	drm_device_t *dev = priv->head->dev;
 	drm_device_dma_t *dma = dev->dma;
-   	drm_i810_private_t *dev_priv = (drm_i810_private_t *)dev->dev_private;
-      	u32 *hw_status = dev_priv->hw_status_page;
-   	drm_i810_sarea_t *sarea_priv = (drm_i810_sarea_t *)
-     					dev_priv->sarea_priv;
+	drm_i810_private_t *dev_priv = (drm_i810_private_t *) dev->dev_private;
+	u32 *hw_status = dev_priv->hw_status_page;
+	drm_i810_sarea_t *sarea_priv = (drm_i810_sarea_t *)
+	    dev_priv->sarea_priv;
 	drm_i810_vertex_t vertex;
 
-	if (copy_from_user(&vertex, (drm_i810_vertex_t __user *)arg, sizeof(vertex)))
+	if (copy_from_user
+	    (&vertex, (drm_i810_vertex_t __user *) arg, sizeof(vertex)))
 		return -EFAULT;
 
 	LOCK_TEST_WITH_RETURN(dev, filp);
@@ -1036,48 +1046,46 @@ static int i810_dma_vertex(struct inode 
 	DRM_DEBUG("i810 dma vertex, idx %d used %d discard %d\n",
 		  vertex.idx, vertex.used, vertex.discard);
 
-	if (vertex.idx < 0 || vertex.idx > dma->buf_count) 
+	if (vertex.idx < 0 || vertex.idx > dma->buf_count)
 		return -EINVAL;
 
-	i810_dma_dispatch_vertex( dev,
-				  dma->buflist[ vertex.idx ],
-				  vertex.discard, vertex.used );
+	i810_dma_dispatch_vertex(dev,
+				 dma->buflist[vertex.idx],
+				 vertex.discard, vertex.used);
 
-   	atomic_add(vertex.used, &dev->counts[_DRM_STAT_SECONDARY]);
+	atomic_add(vertex.used, &dev->counts[_DRM_STAT_SECONDARY]);
 	atomic_inc(&dev->counts[_DRM_STAT_DMA]);
-	sarea_priv->last_enqueue = dev_priv->counter-1;
-   	sarea_priv->last_dispatch = (int) hw_status[5];
+	sarea_priv->last_enqueue = dev_priv->counter - 1;
+	sarea_priv->last_dispatch = (int)hw_status[5];
 
 	return 0;
 }
 
-
-
 static int i810_clear_bufs(struct inode *inode, struct file *filp,
-		   unsigned int cmd, unsigned long arg)
+			   unsigned int cmd, unsigned long arg)
 {
 	drm_file_t *priv = filp->private_data;
 	drm_device_t *dev = priv->head->dev;
 	drm_i810_clear_t clear;
 
-   	if (copy_from_user(&clear, (drm_i810_clear_t __user *)arg, sizeof(clear)))
+	if (copy_from_user
+	    (&clear, (drm_i810_clear_t __user *) arg, sizeof(clear)))
 		return -EFAULT;
 
 	LOCK_TEST_WITH_RETURN(dev, filp);
 
- 	/* GH: Someone's doing nasty things... */
- 	if (!dev->dev_private) {
- 		return -EINVAL;
- 	}
-
-	i810_dma_dispatch_clear( dev, clear.flags,
-				 clear.clear_color,
-				 clear.clear_depth );
-   	return 0;
+	/* GH: Someone's doing nasty things... */
+	if (!dev->dev_private) {
+		return -EINVAL;
+	}
+
+	i810_dma_dispatch_clear(dev, clear.flags,
+				clear.clear_color, clear.clear_depth);
+	return 0;
 }
 
 static int i810_swap_bufs(struct inode *inode, struct file *filp,
-		  unsigned int cmd, unsigned long arg)
+			  unsigned int cmd, unsigned long arg)
 {
 	drm_file_t *priv = filp->private_data;
 	drm_device_t *dev = priv->head->dev;
@@ -1086,37 +1094,37 @@ static int i810_swap_bufs(struct inode *
 
 	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	i810_dma_dispatch_swap( dev );
-   	return 0;
+	i810_dma_dispatch_swap(dev);
+	return 0;
 }
 
 static int i810_getage(struct inode *inode, struct file *filp, unsigned int cmd,
-		unsigned long arg)
+		       unsigned long arg)
 {
-   	drm_file_t	  *priv	    = filp->private_data;
-	drm_device_t	  *dev	    = priv->head->dev;
-   	drm_i810_private_t *dev_priv = (drm_i810_private_t *)dev->dev_private;
-      	u32 *hw_status = dev_priv->hw_status_page;
-   	drm_i810_sarea_t *sarea_priv = (drm_i810_sarea_t *)
-     					dev_priv->sarea_priv;
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
+	drm_i810_private_t *dev_priv = (drm_i810_private_t *) dev->dev_private;
+	u32 *hw_status = dev_priv->hw_status_page;
+	drm_i810_sarea_t *sarea_priv = (drm_i810_sarea_t *)
+	    dev_priv->sarea_priv;
 
-      	sarea_priv->last_dispatch = (int) hw_status[5];
+	sarea_priv->last_dispatch = (int)hw_status[5];
 	return 0;
 }
 
 static int i810_getbuf(struct inode *inode, struct file *filp, unsigned int cmd,
-		unsigned long arg)
+		       unsigned long arg)
 {
-	drm_file_t	  *priv	    = filp->private_data;
-	drm_device_t	  *dev	    = priv->head->dev;
-	int		  retcode   = 0;
-	drm_i810_dma_t	  d;
-   	drm_i810_private_t *dev_priv = (drm_i810_private_t *)dev->dev_private;
-   	u32 *hw_status = dev_priv->hw_status_page;
-   	drm_i810_sarea_t *sarea_priv = (drm_i810_sarea_t *)
-     					dev_priv->sarea_priv;
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
+	int retcode = 0;
+	drm_i810_dma_t d;
+	drm_i810_private_t *dev_priv = (drm_i810_private_t *) dev->dev_private;
+	u32 *hw_status = dev_priv->hw_status_page;
+	drm_i810_sarea_t *sarea_priv = (drm_i810_sarea_t *)
+	    dev_priv->sarea_priv;
 
-   	if (copy_from_user(&d, (drm_i810_dma_t __user *)arg, sizeof(d)))
+	if (copy_from_user(&d, (drm_i810_dma_t __user *) arg, sizeof(d)))
 		return -EFAULT;
 
 	LOCK_TEST_WITH_RETURN(dev, filp);
@@ -1128,29 +1136,29 @@ static int i810_getbuf(struct inode *ino
 	DRM_DEBUG("i810_dma: %d returning %d, granted = %d\n",
 		  current->pid, retcode, d.granted);
 
-	if (copy_to_user((drm_dma_t __user *)arg, &d, sizeof(d)))
+	if (copy_to_user((drm_dma_t __user *) arg, &d, sizeof(d)))
 		return -EFAULT;
-   	sarea_priv->last_dispatch = (int) hw_status[5];
+	sarea_priv->last_dispatch = (int)hw_status[5];
 
 	return retcode;
 }
 
-static int i810_copybuf(struct inode *inode,
-			 struct file *filp, unsigned int cmd, unsigned long arg)
+static int i810_copybuf(struct inode *inode, struct file *filp, 
+			unsigned int cmd, unsigned long arg)
 {
 	/* Never copy - 2.4.x doesn't need it */
 	return 0;
 }
 
 static int i810_docopy(struct inode *inode, struct file *filp, unsigned int cmd,
-			unsigned long arg)
+		       unsigned long arg)
 {
 	/* Never copy - 2.4.x doesn't need it */
 	return 0;
 }
 
-static void i810_dma_dispatch_mc(drm_device_t *dev, drm_buf_t *buf, int used,
-		unsigned int last_render)
+static void i810_dma_dispatch_mc(drm_device_t * dev, drm_buf_t * buf, int used,
+				 unsigned int last_render)
 {
 	drm_i810_private_t *dev_priv = dev->dev_private;
 	drm_i810_buf_priv_t *buf_priv = buf->dev_private;
@@ -1162,19 +1170,17 @@ static void i810_dma_dispatch_mc(drm_dev
 
 	i810_kernel_lost_context(dev);
 
-	u = cmpxchg(buf_priv->in_use, I810_BUF_CLIENT,
-		I810_BUF_HARDWARE);
+	u = cmpxchg(buf_priv->in_use, I810_BUF_CLIENT, I810_BUF_HARDWARE);
 	if (u != I810_BUF_CLIENT) {
 		DRM_DEBUG("MC found buffer that isn't mine!\n");
 	}
 
-	if (used > 4*1024)
+	if (used > 4 * 1024)
 		used = 0;
 
 	sarea_priv->dirty = 0x7f;
 
-	DRM_DEBUG("dispatch mc addr 0x%lx, used 0x%x\n",
-		address, used);
+	DRM_DEBUG("dispatch mc addr 0x%lx, used 0x%x\n", address, used);
 
 	dev_priv->counter++;
 	DRM_DEBUG("dispatch counter : %ld\n", dev_priv->counter);
@@ -1185,46 +1191,45 @@ static void i810_dma_dispatch_mc(drm_dev
 
 	if (buf_priv->currently_mapped == I810_BUF_MAPPED) {
 		if (used & 4) {
-			*(u32 *)((u32)buf_priv->virtual + used) = 0;
+			*(u32 *) ((u32) buf_priv->virtual + used) = 0;
 			used += 4;
 		}
 
 		i810_unmap_buffer(buf);
 	}
 	BEGIN_LP_RING(4);
-	OUT_RING( CMD_OP_BATCH_BUFFER );
-	OUT_RING( start | BB1_PROTECTED );
-	OUT_RING( start + used - 4 );
-	OUT_RING( 0 );
+	OUT_RING(CMD_OP_BATCH_BUFFER);
+	OUT_RING(start | BB1_PROTECTED);
+	OUT_RING(start + used - 4);
+	OUT_RING(0);
 	ADVANCE_LP_RING();
 
-
 	BEGIN_LP_RING(8);
-	OUT_RING( CMD_STORE_DWORD_IDX );
-	OUT_RING( buf_priv->my_use_idx );
-	OUT_RING( I810_BUF_FREE );
-	OUT_RING( 0 );
-
-	OUT_RING( CMD_STORE_DWORD_IDX );
-	OUT_RING( 16 );
-	OUT_RING( last_render );
-	OUT_RING( 0 );
+	OUT_RING(CMD_STORE_DWORD_IDX);
+	OUT_RING(buf_priv->my_use_idx);
+	OUT_RING(I810_BUF_FREE);
+	OUT_RING(0);
+
+	OUT_RING(CMD_STORE_DWORD_IDX);
+	OUT_RING(16);
+	OUT_RING(last_render);
+	OUT_RING(0);
 	ADVANCE_LP_RING();
 }
 
 static int i810_dma_mc(struct inode *inode, struct file *filp,
-	unsigned int cmd, unsigned long arg)
+		       unsigned int cmd, unsigned long arg)
 {
 	drm_file_t *priv = filp->private_data;
 	drm_device_t *dev = priv->head->dev;
 	drm_device_dma_t *dma = dev->dma;
-	drm_i810_private_t *dev_priv = (drm_i810_private_t *)dev->dev_private;
+	drm_i810_private_t *dev_priv = (drm_i810_private_t *) dev->dev_private;
 	u32 *hw_status = dev_priv->hw_status_page;
 	drm_i810_sarea_t *sarea_priv = (drm_i810_sarea_t *)
-		dev_priv->sarea_priv;
+	    dev_priv->sarea_priv;
 	drm_i810_mc_t mc;
 
-	if (copy_from_user(&mc, (drm_i810_mc_t __user *)arg, sizeof(mc)))
+	if (copy_from_user(&mc, (drm_i810_mc_t __user *) arg, sizeof(mc)))
 		return -EFAULT;
 
 	LOCK_TEST_WITH_RETURN(dev, filp);
@@ -1233,12 +1238,12 @@ static int i810_dma_mc(struct inode *ino
 		return -EINVAL;
 
 	i810_dma_dispatch_mc(dev, dma->buflist[mc.idx], mc.used,
-		mc.last_render );
+			     mc.last_render);
 
 	atomic_add(mc.used, &dev->counts[_DRM_STAT_SECONDARY]);
 	atomic_inc(&dev->counts[_DRM_STAT_DMA]);
-	sarea_priv->last_enqueue = dev_priv->counter-1;
-	sarea_priv->last_dispatch = (int) hw_status[5];
+	sarea_priv->last_enqueue = dev_priv->counter - 1;
+	sarea_priv->last_dispatch = (int)hw_status[5];
 
 	return 0;
 }
@@ -1248,22 +1253,23 @@ static int i810_rstatus(struct inode *in
 {
 	drm_file_t *priv = filp->private_data;
 	drm_device_t *dev = priv->head->dev;
-	drm_i810_private_t *dev_priv = (drm_i810_private_t *)dev->dev_private;
+	drm_i810_private_t *dev_priv = (drm_i810_private_t *) dev->dev_private;
 
-	return (int)(((u32 *)(dev_priv->hw_status_page))[4]);
+	return (int)(((u32 *) (dev_priv->hw_status_page))[4]);
 }
 
 static int i810_ov0_info(struct inode *inode, struct file *filp,
-			unsigned int cmd, unsigned long arg)
+			 unsigned int cmd, unsigned long arg)
 {
 	drm_file_t *priv = filp->private_data;
 	drm_device_t *dev = priv->head->dev;
-	drm_i810_private_t *dev_priv = (drm_i810_private_t *)dev->dev_private;
+	drm_i810_private_t *dev_priv = (drm_i810_private_t *) dev->dev_private;
 	drm_i810_overlay_t data;
 
 	data.offset = dev_priv->overlay_offset;
 	data.physical = dev_priv->overlay_physical;
-	if (copy_to_user((drm_i810_overlay_t __user *)arg,&data,sizeof(data)))
+	if (copy_to_user
+	    ((drm_i810_overlay_t __user *) arg, &data, sizeof(data)))
 		return -EFAULT;
 	return 0;
 }
@@ -1273,55 +1279,52 @@ static int i810_fstatus(struct inode *in
 {
 	drm_file_t *priv = filp->private_data;
 	drm_device_t *dev = priv->head->dev;
-	drm_i810_private_t *dev_priv = (drm_i810_private_t *)dev->dev_private;
+	drm_i810_private_t *dev_priv = (drm_i810_private_t *) dev->dev_private;
 
 	LOCK_TEST_WITH_RETURN(dev, filp);
-
 	return I810_READ(0x30008);
 }
 
 static int i810_ov0_flip(struct inode *inode, struct file *filp,
-			unsigned int cmd, unsigned long arg)
+			 unsigned int cmd, unsigned long arg)
 {
 	drm_file_t *priv = filp->private_data;
 	drm_device_t *dev = priv->head->dev;
-	drm_i810_private_t *dev_priv = (drm_i810_private_t *)dev->dev_private;
+	drm_i810_private_t *dev_priv = (drm_i810_private_t *) dev->dev_private;
 
 	LOCK_TEST_WITH_RETURN(dev, filp);
-
 	//Tell the overlay to update
-	I810_WRITE(0x30000,dev_priv->overlay_physical | 0x80000000);
+	I810_WRITE(0x30000, dev_priv->overlay_physical | 0x80000000);
 
 	return 0;
 }
 
-
 /* Not sure why this isn't set all the time:
- */ 
-static void i810_do_init_pageflip( drm_device_t *dev )
+ */
+static void i810_do_init_pageflip(drm_device_t * dev)
 {
 	drm_i810_private_t *dev_priv = dev->dev_private;
-	
+
 	DRM_DEBUG("%s\n", __FUNCTION__);
 	dev_priv->page_flipping = 1;
 	dev_priv->current_page = 0;
 	dev_priv->sarea_priv->pf_current_page = dev_priv->current_page;
 }
 
-static int i810_do_cleanup_pageflip( drm_device_t *dev )
+static int i810_do_cleanup_pageflip(drm_device_t * dev)
 {
 	drm_i810_private_t *dev_priv = dev->dev_private;
 
 	DRM_DEBUG("%s\n", __FUNCTION__);
 	if (dev_priv->current_page != 0)
-		i810_dma_dispatch_flip( dev );
+		i810_dma_dispatch_flip(dev);
 
 	dev_priv->page_flipping = 0;
 	return 0;
 }
 
 static int i810_flip_bufs(struct inode *inode, struct file *filp,
-			unsigned int cmd, unsigned long arg)
+			  unsigned int cmd, unsigned long arg)
 {
 	drm_file_t *priv = filp->private_data;
 	drm_device_t *dev = priv->head->dev;
@@ -1331,19 +1334,19 @@ static int i810_flip_bufs(struct inode *
 
 	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	if (!dev_priv->page_flipping) 
-		i810_do_init_pageflip( dev );
+	if (!dev_priv->page_flipping)
+		i810_do_init_pageflip(dev);
 
-	i810_dma_dispatch_flip( dev );
-   	return 0;
+	i810_dma_dispatch_flip(dev);
+	return 0;
 }
 
-void i810_driver_pretakedown(drm_device_t *dev)
+void i810_driver_pretakedown(drm_device_t * dev)
 {
-	i810_dma_cleanup( dev );
+	i810_dma_cleanup(dev);
 }
 
-void i810_driver_prerelease(drm_device_t *dev, DRMFILE filp)
+void i810_driver_prerelease(drm_device_t * dev, DRMFILE filp)
 {
 	if (dev->dev_private) {
 		drm_i810_private_t *dev_priv = dev->dev_private;
@@ -1353,33 +1356,49 @@ void i810_driver_prerelease(drm_device_t
 	}
 }
 
-void i810_driver_release(drm_device_t *dev, struct file *filp)
+void i810_driver_release(drm_device_t * dev, struct file *filp)
 {
 	i810_reclaim_buffers(dev, filp);
 }
 
-int i810_driver_dma_quiescent(drm_device_t *dev)
+int i810_driver_dma_quiescent(drm_device_t * dev)
 {
-	i810_dma_quiescent( dev );
+	i810_dma_quiescent(dev);
 	return 0;
 }
 
 drm_ioctl_desc_t i810_ioctls[] = {
-	[DRM_IOCTL_NR(DRM_I810_INIT)]    = { i810_dma_init,    1, 1 },
-	[DRM_IOCTL_NR(DRM_I810_VERTEX)]  = { i810_dma_vertex,  1, 0 },
-	[DRM_IOCTL_NR(DRM_I810_CLEAR)]   = { i810_clear_bufs,  1, 0 },
-	[DRM_IOCTL_NR(DRM_I810_FLUSH)]   = { i810_flush_ioctl, 1, 0 },
-	[DRM_IOCTL_NR(DRM_I810_GETAGE)]  = { i810_getage,      1, 0 },
-	[DRM_IOCTL_NR(DRM_I810_GETBUF)]  = { i810_getbuf,      1, 0 },
-	[DRM_IOCTL_NR(DRM_I810_SWAP)]    = { i810_swap_bufs,   1, 0 },
-	[DRM_IOCTL_NR(DRM_I810_COPY)]    = { i810_copybuf,     1, 0 },
-	[DRM_IOCTL_NR(DRM_I810_DOCOPY)]  = { i810_docopy,      1, 0 },
-	[DRM_IOCTL_NR(DRM_I810_OV0INFO)] = { i810_ov0_info,    1, 0 },
-	[DRM_IOCTL_NR(DRM_I810_FSTATUS)] = { i810_fstatus,     1, 0 },
-	[DRM_IOCTL_NR(DRM_I810_OV0FLIP)] = { i810_ov0_flip,    1, 0 },
-	[DRM_IOCTL_NR(DRM_I810_MC)]      = { i810_dma_mc,      1, 1 },
-	[DRM_IOCTL_NR(DRM_I810_RSTATUS)] = { i810_rstatus,     1, 0 },
-	[DRM_IOCTL_NR(DRM_I810_FLIP)]    = { i810_flip_bufs,   1, 0 }
+	[DRM_IOCTL_NR(DRM_I810_INIT)] = {i810_dma_init, 1, 1},
+	[DRM_IOCTL_NR(DRM_I810_VERTEX)] = {i810_dma_vertex, 1, 0},
+	[DRM_IOCTL_NR(DRM_I810_CLEAR)] = {i810_clear_bufs, 1, 0},
+	[DRM_IOCTL_NR(DRM_I810_FLUSH)] = {i810_flush_ioctl, 1, 0},
+	[DRM_IOCTL_NR(DRM_I810_GETAGE)] = {i810_getage, 1, 0},
+	[DRM_IOCTL_NR(DRM_I810_GETBUF)] = {i810_getbuf, 1, 0},
+	[DRM_IOCTL_NR(DRM_I810_SWAP)] = {i810_swap_bufs, 1, 0},
+	[DRM_IOCTL_NR(DRM_I810_COPY)] = {i810_copybuf, 1, 0},
+	[DRM_IOCTL_NR(DRM_I810_DOCOPY)] = {i810_docopy, 1, 0},
+	[DRM_IOCTL_NR(DRM_I810_OV0INFO)] = {i810_ov0_info, 1, 0},
+	[DRM_IOCTL_NR(DRM_I810_FSTATUS)] = {i810_fstatus, 1, 0},
+	[DRM_IOCTL_NR(DRM_I810_OV0FLIP)] = {i810_ov0_flip, 1, 0},
+	[DRM_IOCTL_NR(DRM_I810_MC)] = {i810_dma_mc, 1, 1},
+	[DRM_IOCTL_NR(DRM_I810_RSTATUS)] = {i810_rstatus, 1, 0},
+	[DRM_IOCTL_NR(DRM_I810_FLIP)] = {i810_flip_bufs, 1, 0}
 };
 
 int i810_max_ioctl = DRM_ARRAY_SIZE(i810_ioctls);
+
+/**
+ * Determine if the device really is AGP or not.
+ *
+ * All Intel graphics chipsets are treated as AGP, even if they are really
+ * PCI-e.
+ *
+ * \param dev   The device to be tested.
+ *
+ * \returns
+ * A value of 1 is always retured to indictate every i810 is AGP.
+ */
+int i810_driver_device_is_agp(drm_device_t * dev)
+{
+	return 1;
+}
diff -purN linux-2.6.12.orig/drivers/char/drm/i810_drm.h linux-2.6.12/drivers/char/drm/i810_drm.h
--- linux-2.6.12.orig/drivers/char/drm/i810_drm.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/i810_drm.h	2005-07-05 08:37:30.000000000 +0200
@@ -19,21 +19,20 @@
 #define I810_LOG_MIN_TEX_REGION_SIZE 16
 #endif
 
-#define I810_UPLOAD_TEX0IMAGE  0x1 /* handled clientside */
-#define I810_UPLOAD_TEX1IMAGE  0x2 /* handled clientside */
+#define I810_UPLOAD_TEX0IMAGE  0x1	/* handled clientside */
+#define I810_UPLOAD_TEX1IMAGE  0x2	/* handled clientside */
 #define I810_UPLOAD_CTX        0x4
 #define I810_UPLOAD_BUFFERS    0x8
 #define I810_UPLOAD_TEX0       0x10
 #define I810_UPLOAD_TEX1       0x20
 #define I810_UPLOAD_CLIPRECTS  0x40
 
-
 /* Indices into buf.Setup where various bits of state are mirrored per
  * context and per buffer.  These can be fired at the card as a unit,
  * or in a piecewise fashion as required.
  */
 
-/* Destbuffer state 
+/* Destbuffer state
  *    - backbuffer linear offset and pitch -- invarient in the current dri
  *    - zbuffer linear offset and pitch -- also invarient
  *    - drawing origin in back and depth buffers.
@@ -55,13 +54,13 @@
 /* Context state
  */
 #define I810_CTXREG_CF0   0	/* GFX_OP_COLOR_FACTOR */
-#define I810_CTXREG_CF1   1	
-#define I810_CTXREG_ST0   2     /* GFX_OP_STIPPLE */
+#define I810_CTXREG_CF1   1
+#define I810_CTXREG_ST0   2	/* GFX_OP_STIPPLE */
 #define I810_CTXREG_ST1   3
 #define I810_CTXREG_VF    4	/* GFX_OP_VERTEX_FMT */
 #define I810_CTXREG_MT    5	/* GFX_OP_MAP_TEXELS */
 #define I810_CTXREG_MC0   6	/* GFX_OP_MAP_COLOR_STAGES - stage 0 */
-#define I810_CTXREG_MC1   7     /* GFX_OP_MAP_COLOR_STAGES - stage 1 */
+#define I810_CTXREG_MC1   7	/* GFX_OP_MAP_COLOR_STAGES - stage 1 */
 #define I810_CTXREG_MC2   8	/* GFX_OP_MAP_COLOR_STAGES - stage 2 */
 #define I810_CTXREG_MA0   9	/* GFX_OP_MAP_ALPHA_STAGES - stage 0 */
 #define I810_CTXREG_MA1   10	/* GFX_OP_MAP_ALPHA_STAGES - stage 1 */
@@ -74,14 +73,14 @@
 #define I810_CTXREG_PV    17	/* GFX_OP_PV_RULE -- Invarient! */
 #define I810_CTXREG_ZA    18	/* GFX_OP_ZBIAS_ALPHAFUNC */
 #define I810_CTXREG_AA    19	/* GFX_OP_ANTIALIAS */
-#define I810_CTX_SETUP_SIZE 20 
+#define I810_CTX_SETUP_SIZE 20
 
 /* Texture state (per tex unit)
  */
 #define I810_TEXREG_MI0  0	/* GFX_OP_MAP_INFO (4 dwords) */
-#define I810_TEXREG_MI1  1	
-#define I810_TEXREG_MI2  2	
-#define I810_TEXREG_MI3  3	
+#define I810_TEXREG_MI1  1
+#define I810_TEXREG_MI2  2
+#define I810_TEXREG_MI3  3
 #define I810_TEXREG_MF   4	/* GFX_OP_MAP_FILTER */
 #define I810_TEXREG_MLC  5	/* GFX_OP_MAP_LOD_CTL */
 #define I810_TEXREG_MLL  6	/* GFX_OP_MAP_LOD_LIMITS */
@@ -98,7 +97,7 @@ typedef enum _drm_i810_init_func {
 	I810_INIT_DMA = 0x01,
 	I810_CLEANUP_DMA = 0x02,
 	I810_INIT_DMA_1_4 = 0x03
- } drm_i810_init_func_t;
+} drm_i810_init_func_t;
 
 /* This is the init structure after v1.2 */
 typedef struct _drm_i810_init {
@@ -122,14 +121,19 @@ typedef struct _drm_i810_init {
 	unsigned int w;
 	unsigned int h;
 	unsigned int pitch;
-	unsigned int pitch_bits; 
+	unsigned int pitch_bits;
 } drm_i810_init_t;
 
 /* This is the init structure prior to v1.2 */
 typedef struct _drm_i810_pre12_init {
 	drm_i810_init_func_t func;
+#if CONFIG_XFREE86_VERSION < XFREE86_VERSION(4,1,0,0)
+	int ring_map_idx;
+	int buffer_map_idx;
+#else
 	unsigned int mmio_offset;
 	unsigned int buffers_offset;
+#endif
 	int sarea_priv_offset;
 	unsigned int ring_start;
 	unsigned int ring_end;
@@ -140,23 +144,23 @@ typedef struct _drm_i810_pre12_init {
 	unsigned int w;
 	unsigned int h;
 	unsigned int pitch;
-	unsigned int pitch_bits; 
+	unsigned int pitch_bits;
 } drm_i810_pre12_init_t;
 
 /* Warning: If you change the SAREA structure you must change the Xserver
  * structure as well */
 
 typedef struct _drm_i810_tex_region {
-	unsigned char next, prev; /* indices to form a circular LRU  */
+	unsigned char next, prev;	/* indices to form a circular LRU  */
 	unsigned char in_use;	/* owned by a client, or free? */
 	int age;		/* tracked by clients to update local LRU's */
 } drm_i810_tex_region_t;
 
 typedef struct _drm_i810_sarea {
-   	unsigned int ContextState[I810_CTX_SETUP_SIZE];
-   	unsigned int BufferState[I810_DEST_SETUP_SIZE];
-   	unsigned int TexState[2][I810_TEX_SETUP_SIZE];
-   	unsigned int dirty;
+	unsigned int ContextState[I810_CTX_SETUP_SIZE];
+	unsigned int BufferState[I810_DEST_SETUP_SIZE];
+	unsigned int TexState[2][I810_TEX_SETUP_SIZE];
+	unsigned int dirty;
 
 	unsigned int nbox;
 	drm_clip_rect_t boxes[I810_NR_SAREA_CLIPRECTS];
@@ -174,22 +178,22 @@ typedef struct _drm_i810_sarea {
 	 * texture space, and can make informed decisions as to which
 	 * areas to kick out.  There is no need to choose whether to
 	 * kick out your own texture or someone else's - simply eject
-	 * them all in LRU order.  
+	 * them all in LRU order.
 	 */
-   
-	drm_i810_tex_region_t texList[I810_NR_TEX_REGIONS+1]; 
-				/* Last elt is sentinal */
-        int texAge;		/* last time texture was uploaded */
-        int last_enqueue;	/* last time a buffer was enqueued */
+
+	drm_i810_tex_region_t texList[I810_NR_TEX_REGIONS + 1];
+	/* Last elt is sentinal */
+	int texAge;		/* last time texture was uploaded */
+	int last_enqueue;	/* last time a buffer was enqueued */
 	int last_dispatch;	/* age of the most recently dispatched buffer */
-	int last_quiescent;     /*  */
+	int last_quiescent;	/*  */
 	int ctxOwner;		/* last context to upload state */
 
 	int vertex_prim;
 
-	int pf_enabled;               /* is pageflipping allowed? */
+	int pf_enabled;		/* is pageflipping allowed? */
 	int pf_active;
-	int pf_current_page;	    /* which buffer is being displayed? */
+	int pf_current_page;	/* which buffer is being displayed? */
 } drm_i810_sarea_t;
 
 /* WARNING: If you change any of these defines, make sure to change the
@@ -243,13 +247,13 @@ typedef struct _drm_i810_clear {
  * new set of cliprects.
  */
 typedef struct _drm_i810_vertex {
-   	int idx;		/* buffer index */
+	int idx;		/* buffer index */
 	int used;		/* nr bytes in use */
 	int discard;		/* client is finished with the buffer? */
 } drm_i810_vertex_t;
 
 typedef struct _drm_i810_copy_t {
-   	int idx;		/* buffer index */
+	int idx;		/* buffer index */
 	int used;		/* nr bytes in use */
 	void *address;		/* Address to copy from */
 } drm_i810_copy_t;
@@ -264,7 +268,6 @@ typedef struct _drm_i810_copy_t {
 #define PR_RECTS             (0x7<<18)
 #define PR_MASK              (0x7<<18)
 
-
 typedef struct drm_i810_dma {
 	void *virtual;
 	int request_idx;
@@ -273,17 +276,16 @@ typedef struct drm_i810_dma {
 } drm_i810_dma_t;
 
 typedef struct _drm_i810_overlay_t {
-	unsigned int offset;    /* Address of the Overlay Regs */
+	unsigned int offset;	/* Address of the Overlay Regs */
 	unsigned int physical;
 } drm_i810_overlay_t;
 
 typedef struct _drm_i810_mc {
-	int idx;                /* buffer index */
-	int used;               /* nr bytes in use */
-	int num_blocks;         /* number of GFXBlocks */
-	int *length;            /* List of lengths for GFXBlocks (FUTURE)*/
-	unsigned int last_render; /* Last Render Request */
+	int idx;		/* buffer index */
+	int used;		/* nr bytes in use */
+	int num_blocks;		/* number of GFXBlocks */
+	int *length;		/* List of lengths for GFXBlocks (FUTURE) */
+	unsigned int last_render;	/* Last Render Request */
 } drm_i810_mc_t;
 
-
-#endif /* _I810_DRM_H_ */
+#endif				/* _I810_DRM_H_ */
diff -purN linux-2.6.12.orig/drivers/char/drm/i810_drv.c linux-2.6.12/drivers/char/drm/i810_drv.c
--- linux-2.6.12.orig/drivers/char/drm/i810_drv.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/i810_drv.c	2005-07-05 08:37:27.000000000 +0200
@@ -38,7 +38,7 @@
 
 #include "drm_pciids.h"
 
-static int postinit( struct drm_device *dev, unsigned long flags )
+static int postinit(struct drm_device *dev, unsigned long flags)
 {
 	/* i810 has 4 more counters */
 	dev->counters += 4;
@@ -46,32 +46,35 @@ static int postinit( struct drm_device *
 	dev->types[7] = _DRM_STAT_PRIMARY;
 	dev->types[8] = _DRM_STAT_SECONDARY;
 	dev->types[9] = _DRM_STAT_DMA;
-	
-	DRM_INFO( "Initialized %s %d.%d.%d %s on minor %d: %s\n",
-		DRIVER_NAME,
-		DRIVER_MAJOR,
-		DRIVER_MINOR,
-		DRIVER_PATCHLEVEL,
-		DRIVER_DATE,
-		dev->primary.minor,
-		pci_pretty_name(dev->pdev)
-		);
+
+	DRM_INFO("Initialized %s %d.%d.%d %s on minor %d: %s\n",
+		 DRIVER_NAME,
+		 DRIVER_MAJOR,
+		 DRIVER_MINOR,
+		 DRIVER_PATCHLEVEL,
+		 DRIVER_DATE, dev->primary.minor, pci_pretty_name(dev->pdev)
+	    );
 	return 0;
 }
 
-static int version( drm_version_t *version )
+static int version(drm_version_t * version)
 {
 	int len;
 
 	version->version_major = DRIVER_MAJOR;
 	version->version_minor = DRIVER_MINOR;
 	version->version_patchlevel = DRIVER_PATCHLEVEL;
-	DRM_COPY( version->name, DRIVER_NAME );
-	DRM_COPY( version->date, DRIVER_DATE );
-	DRM_COPY( version->desc, DRIVER_DESC );
+	DRM_COPY(version->name, DRIVER_NAME);
+	DRM_COPY(version->date, DRIVER_DATE);
+	DRM_COPY(version->desc, DRIVER_DESC);
 	return 0;
 }
 
+static int dri_library_name(struct drm_device * dev, char * buf)
+{
+	return snprintf(buf, PAGE_SIZE, "i830\n");
+}
+
 static struct pci_device_id pciidlist[] = {
 	i810_PCI_IDS
 };
@@ -79,16 +82,20 @@ static struct pci_device_id pciidlist[] 
 extern drm_ioctl_desc_t i810_ioctls[];
 extern int i810_max_ioctl;
 
+static int probe(struct pci_dev *pdev, const struct pci_device_id *ent);
 static struct drm_driver driver = {
-	.driver_features = DRIVER_USE_AGP | DRIVER_REQUIRE_AGP | DRIVER_USE_MTRR | DRIVER_HAVE_DMA | DRIVER_DMA_QUEUE,
+	.driver_features =
+	    DRIVER_USE_AGP | DRIVER_REQUIRE_AGP | DRIVER_USE_MTRR |
+	    DRIVER_HAVE_DMA | DRIVER_DMA_QUEUE,
 	.dev_priv_size = sizeof(drm_i810_buf_priv_t),
 	.pretakedown = i810_driver_pretakedown,
 	.prerelease = i810_driver_prerelease,
+	.device_is_agp = i810_driver_device_is_agp,
 	.release = i810_driver_release,
 	.dma_quiescent = i810_driver_dma_quiescent,
-	.reclaim_buffers = i810_reclaim_buffers,
 	.get_map_ofs = drm_core_get_map_ofs,
 	.get_reg_ofs = drm_core_get_reg_ofs,
+	.dri_library_name = dri_library_name,
 	.postinit = postinit,
 	.version = version,
 	.ioctls = i810_ioctls,
@@ -100,17 +107,24 @@ static struct drm_driver driver = {
 		.mmap = drm_mmap,
 		.poll = drm_poll,
 		.fasync = drm_fasync,
-	},
+		},
 	.pci_driver = {
-		.name          = DRIVER_NAME,
-		.id_table      = pciidlist,
-	},
+		.name = DRIVER_NAME,
+		.id_table = pciidlist,
+		.probe = probe,
+		.remove = __devexit_p(drm_cleanup_pci),
+		}
 };
 
+static int probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	return drm_get_dev(pdev, ent, &driver);
+}
+
 static int __init i810_init(void)
 {
 	driver.num_ioctls = i810_max_ioctl;
-	return drm_init(&driver);
+	return drm_init(&driver, pciidlist);
 }
 
 static void __exit i810_exit(void)
@@ -121,6 +135,6 @@ static void __exit i810_exit(void)
 module_init(i810_init);
 module_exit(i810_exit);
 
-MODULE_AUTHOR( DRIVER_AUTHOR );
-MODULE_DESCRIPTION( DRIVER_DESC );
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL and additional rights");
diff -purN linux-2.6.12.orig/drivers/char/drm/i810_drv.h linux-2.6.12/drivers/char/drm/i810_drv.h
--- linux-2.6.12.orig/drivers/char/drm/i810_drv.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/i810_drv.h	2005-07-05 08:37:30.000000000 +0200
@@ -56,14 +56,14 @@
 #define DRIVER_PATCHLEVEL	0
 
 typedef struct drm_i810_buf_priv {
-   	u32 *in_use;
-   	int my_use_idx;
+	u32 *in_use;
+	int my_use_idx;
 	int currently_mapped;
 	void *virtual;
 	void *kernel_virtual;
 } drm_i810_buf_priv_t;
 
-typedef struct _drm_i810_ring_buffer{
+typedef struct _drm_i810_ring_buffer {
 	int tail_mask;
 	unsigned long Start;
 	unsigned long End;
@@ -79,16 +79,15 @@ typedef struct drm_i810_private {
 	drm_map_t *mmio_map;
 
 	drm_i810_sarea_t *sarea_priv;
-   	drm_i810_ring_buffer_t ring;
+	drm_i810_ring_buffer_t ring;
 
-      	void *hw_status_page;
-   	unsigned long counter;
+	void *hw_status_page;
+	unsigned long counter;
 
 	dma_addr_t dma_status_page;
 
 	drm_buf_t *mmap_buffer;
 
-
 	u32 front_di1, back_di1, zi1;
 
 	int back_offset;
@@ -97,7 +96,7 @@ typedef struct drm_i810_private {
 	int overlay_physical;
 	int w, h;
 	int pitch;
-  	int back_pitch;
+	int back_pitch;
 	int depth_pitch;
 
 	int do_boxes;
@@ -107,20 +106,20 @@ typedef struct drm_i810_private {
 	int page_flipping;
 
 	wait_queue_head_t irq_queue;
-   	atomic_t irq_received;
-   	atomic_t irq_emitted;
-  
-        int front_offset;
+	atomic_t irq_received;
+	atomic_t irq_emitted;
+
+	int front_offset;
 } drm_i810_private_t;
 
 				/* i810_dma.c */
 extern void i810_reclaim_buffers(drm_device_t *dev, struct file *filp);
-extern int i810_mmap_buffers(struct file *filp, struct vm_area_struct *vma);
 
-extern int i810_driver_dma_quiescent(drm_device_t *dev);
-extern void i810_driver_release(drm_device_t *dev, struct file *filp);
-extern void i810_driver_pretakedown(drm_device_t *dev);
-extern void i810_driver_prerelease(drm_device_t *dev, DRMFILE filp);
+extern int i810_driver_dma_quiescent(drm_device_t * dev);
+extern void i810_driver_release(drm_device_t * dev, struct file *filp);
+extern void i810_driver_pretakedown(drm_device_t * dev);
+extern void i810_driver_prerelease(drm_device_t * dev, DRMFILE filp);
+extern int i810_driver_device_is_agp(drm_device_t * dev);
 
 #define I810_BASE(reg)		((unsigned long) \
 				dev_priv->mmio_map->handle)
@@ -170,7 +169,6 @@ extern void i810_driver_prerelease(drm_d
 #define INST_OP_FLUSH        0x02000000
 #define INST_FLUSH_MAP_CACHE 0x00000001
 
-
 #define BB1_START_ADDR_MASK   (~0x7)
 #define BB1_PROTECTED         (1<<0)
 #define BB1_UNPROTECTED       (0<<0)
@@ -229,8 +227,8 @@ extern void i810_driver_prerelease(drm_d
 #define BR00_OP_SRC_COPY_BLT 0x10C00000
 #define BR13_SOLID_PATTERN   0x80000000
 
-#define WAIT_FOR_PLANE_A_SCANLINES (1<<1) 
-#define WAIT_FOR_PLANE_A_FLIP      (1<<2) 
+#define WAIT_FOR_PLANE_A_SCANLINES (1<<1)
+#define WAIT_FOR_PLANE_A_FLIP      (1<<2)
 #define WAIT_FOR_VBLANK (1<<3)
 
 #endif
diff -purN linux-2.6.12.orig/drivers/char/drm/i830_dma.c linux-2.6.12/drivers/char/drm/i830_dma.c
--- linux-2.6.12.orig/drivers/char/drm/i830_dma.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/i830_dma.c	2005-07-05 08:37:27.000000000 +0200
@@ -11,11 +11,11 @@
  * the rights to use, copy, modify, merge, publish, distribute, sublicense,
  * and/or sell copies of the Software, and to permit persons to whom the
  * Software is furnished to do so, subject to the following conditions:
- * 
+ *
  * The above copyright notice and this permission notice (including the next
  * paragraph) shall be included in all copies or substantial portions of the
  * Software.
- * 
+ *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
@@ -31,15 +31,22 @@
  *
  */
 
-#include "drmP.h"
-#include "drm.h"
-#include "i830_drm.h"
-#include "i830_drv.h"
 #include <linux/interrupt.h>	/* For task queue support */
 #include <linux/pagemap.h>	/* For FASTCALL on unlock_page() */
 #include <linux/delay.h>
 #include <asm/uaccess.h>
 
+#include "drmP.h"
+#include "drm.h"
+#include "i830_drm.h"
+#include "i830_drv.h"
+
+#ifdef DO_MUNMAP_4_ARGS
+#define DO_MUNMAP(m, a, l)	do_munmap(m, a, l, 1)
+#else
+#define DO_MUNMAP(m, a, l)	do_munmap(m, a, l)
+#endif
+
 #define I830_BUF_FREE		2
 #define I830_BUF_CLIENT		1
 #define I830_BUF_HARDWARE      	0
@@ -47,108 +54,105 @@
 #define I830_BUF_UNMAPPED 0
 #define I830_BUF_MAPPED   1
 
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,4,2)
-#define down_write down
-#define up_write up
-#endif
-
-static drm_buf_t *i830_freelist_get(drm_device_t *dev)
+static drm_buf_t *i830_freelist_get(drm_device_t * dev)
 {
-   	drm_device_dma_t *dma = dev->dma;
-	int		 i;
-   	int 		 used;
-   
+	drm_device_dma_t *dma = dev->dma;
+	int i;
+	int used;
+
 	/* Linear search might not be the best solution */
 
-   	for (i = 0; i < dma->buf_count; i++) {
-	   	drm_buf_t *buf = dma->buflist[ i ];
-	   	drm_i830_buf_priv_t *buf_priv = buf->dev_private;
+	for (i = 0; i < dma->buf_count; i++) {
+		drm_buf_t *buf = dma->buflist[i];
+		drm_i830_buf_priv_t *buf_priv = buf->dev_private;
 		/* In use is already a pointer */
-	   	used = cmpxchg(buf_priv->in_use, I830_BUF_FREE, 
+		used = cmpxchg(buf_priv->in_use, I830_BUF_FREE,
 			       I830_BUF_CLIENT);
-	   	if(used == I830_BUF_FREE) {
+		if (used == I830_BUF_FREE) {
 			return buf;
 		}
 	}
-   	return NULL;
+	return NULL;
 }
 
 /* This should only be called if the buffer is not sent to the hardware
  * yet, the hardware updates in use for us once its on the ring buffer.
  */
 
-static int i830_freelist_put(drm_device_t *dev, drm_buf_t *buf)
+static int i830_freelist_put(drm_device_t * dev, drm_buf_t * buf)
 {
-   	drm_i830_buf_priv_t *buf_priv = buf->dev_private;
-   	int used;
-   
-   	/* In use is already a pointer */
-   	used = cmpxchg(buf_priv->in_use, I830_BUF_CLIENT, I830_BUF_FREE);
-   	if(used != I830_BUF_CLIENT) {
-	   	DRM_ERROR("Freeing buffer thats not in use : %d\n", buf->idx);
-	   	return -EINVAL;
+	drm_i830_buf_priv_t *buf_priv = buf->dev_private;
+	int used;
+
+	/* In use is already a pointer */
+	used = cmpxchg(buf_priv->in_use, I830_BUF_CLIENT, I830_BUF_FREE);
+	if (used != I830_BUF_CLIENT) {
+		DRM_ERROR("Freeing buffer thats not in use : %d\n", buf->idx);
+		return -EINVAL;
 	}
-   
-   	return 0;
+
+	return 0;
 }
 
-static struct file_operations i830_buffer_fops = {
-	.open	 = drm_open,
-	.flush	 = drm_flush,
-	.release = drm_release,
-	.ioctl	 = drm_ioctl,
-	.mmap	 = i830_mmap_buffers,
-	.fasync  = drm_fasync,
-};
 
-int i830_mmap_buffers(struct file *filp, struct vm_area_struct *vma)
+static int i830_mmap_buffers(struct file *filp, struct vm_area_struct *vma)
 {
-	drm_file_t	    *priv	  = filp->private_data;
-	drm_device_t	    *dev;
-	drm_i830_private_t  *dev_priv;
-	drm_buf_t           *buf;
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev;
+	drm_i830_private_t *dev_priv;
+	drm_buf_t *buf;
 	drm_i830_buf_priv_t *buf_priv;
 
 	lock_kernel();
-	dev	 = priv->head->dev;
+	dev = priv->head->dev;
 	dev_priv = dev->dev_private;
-	buf      = dev_priv->mmap_buffer;
+	buf = dev_priv->mmap_buffer;
 	buf_priv = buf->dev_private;
-   
+
 	vma->vm_flags |= (VM_IO | VM_DONTCOPY);
 	vma->vm_file = filp;
-   
-   	buf_priv->currently_mapped = I830_BUF_MAPPED;
+
+	buf_priv->currently_mapped = I830_BUF_MAPPED;
 	unlock_kernel();
 
-	if (io_remap_pfn_range(vma, vma->vm_start,
-			     VM_OFFSET(vma) >> PAGE_SHIFT,
-			     vma->vm_end - vma->vm_start,
-			     vma->vm_page_prot)) return -EAGAIN;
+	if (remap_pfn_range(vma, vma->vm_start,
+			    VM_OFFSET(vma) >> PAGE_SHIFT,
+			    vma->vm_end - vma->vm_start,
+			    vma->vm_page_prot))
+		return -EAGAIN;
 	return 0;
 }
 
-static int i830_map_buffer(drm_buf_t *buf, struct file *filp)
+static struct file_operations i830_buffer_fops = {
+	.open = drm_open,
+	.release = drm_release,
+	.ioctl = drm_ioctl,
+	.mmap = i830_mmap_buffers,
+	.fasync = drm_fasync,
+};
+
+static int i830_map_buffer(drm_buf_t * buf, struct file *filp)
 {
-	drm_file_t	  *priv	  = filp->private_data;
-	drm_device_t	  *dev	  = priv->head->dev;
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
 	drm_i830_buf_priv_t *buf_priv = buf->dev_private;
-      	drm_i830_private_t *dev_priv = dev->dev_private;
-   	struct file_operations *old_fops;
+	drm_i830_private_t *dev_priv = dev->dev_private;
+	struct file_operations *old_fops;
 	unsigned long virtual;
 	int retcode = 0;
 
-	if(buf_priv->currently_mapped == I830_BUF_MAPPED) return -EINVAL;
+	if (buf_priv->currently_mapped == I830_BUF_MAPPED)
+		return -EINVAL;
 
-	down_write( &current->mm->mmap_sem );
+	down_write(&current->mm->mmap_sem);
 	old_fops = filp->f_op;
 	filp->f_op = &i830_buffer_fops;
 	dev_priv->mmap_buffer = buf;
-	virtual = do_mmap(filp, 0, buf->total, PROT_READ|PROT_WRITE,
-			    MAP_SHARED, buf->bus_address);
+	virtual = do_mmap(filp, 0, buf->total, PROT_READ | PROT_WRITE,
+			  MAP_SHARED, buf->bus_address);
 	dev_priv->mmap_buffer = NULL;
 	filp->f_op = old_fops;
-	if (IS_ERR((void *)virtual)) {		/* ugh */
+	if (IS_ERR((void *)virtual)) {	/* ugh */
 		/* Real error */
 		DRM_ERROR("mmap error\n");
 		retcode = virtual;
@@ -156,62 +160,62 @@ static int i830_map_buffer(drm_buf_t *bu
 	} else {
 		buf_priv->virtual = (void __user *)virtual;
 	}
-	up_write( &current->mm->mmap_sem );
+	up_write(&current->mm->mmap_sem);
 
 	return retcode;
 }
 
-static int i830_unmap_buffer(drm_buf_t *buf)
+static int i830_unmap_buffer(drm_buf_t * buf)
 {
 	drm_i830_buf_priv_t *buf_priv = buf->dev_private;
 	int retcode = 0;
 
-	if(buf_priv->currently_mapped != I830_BUF_MAPPED) 
+	if (buf_priv->currently_mapped != I830_BUF_MAPPED)
 		return -EINVAL;
 
 	down_write(&current->mm->mmap_sem);
-	retcode = do_munmap(current->mm,
+	retcode = DO_MUNMAP(current->mm,
 			    (unsigned long)buf_priv->virtual,
 			    (size_t) buf->total);
 	up_write(&current->mm->mmap_sem);
 
-   	buf_priv->currently_mapped = I830_BUF_UNMAPPED;
-   	buf_priv->virtual = NULL;
+	buf_priv->currently_mapped = I830_BUF_UNMAPPED;
+	buf_priv->virtual = NULL;
 
 	return retcode;
 }
 
-static int i830_dma_get_buffer(drm_device_t *dev, drm_i830_dma_t *d, 
+static int i830_dma_get_buffer(drm_device_t * dev, drm_i830_dma_t * d,
 			       struct file *filp)
 {
-	drm_buf_t	  *buf;
+	drm_buf_t *buf;
 	drm_i830_buf_priv_t *buf_priv;
 	int retcode = 0;
 
 	buf = i830_freelist_get(dev);
 	if (!buf) {
 		retcode = -ENOMEM;
-	   	DRM_DEBUG("retcode=%d\n", retcode);
+		DRM_DEBUG("retcode=%d\n", retcode);
 		return retcode;
 	}
-   
+
 	retcode = i830_map_buffer(buf, filp);
-	if(retcode) {
+	if (retcode) {
 		i830_freelist_put(dev, buf);
-	   	DRM_ERROR("mapbuf failed, retcode %d\n", retcode);
+		DRM_ERROR("mapbuf failed, retcode %d\n", retcode);
 		return retcode;
 	}
 	buf->filp = filp;
-	buf_priv = buf->dev_private;	
+	buf_priv = buf->dev_private;
 	d->granted = 1;
-   	d->request_idx = buf->idx;
-   	d->request_size = buf->total;
-   	d->virtual = buf_priv->virtual;
+	d->request_idx = buf->idx;
+	d->request_size = buf->total;
+	d->virtual = buf_priv->virtual;
 
 	return retcode;
 }
 
-static int i830_dma_cleanup(drm_device_t *dev)
+static int i830_dma_cleanup(drm_device_t * dev)
 {
 	drm_device_dma_t *dma = dev->dma;
 
@@ -219,147 +223,151 @@ static int i830_dma_cleanup(drm_device_t
 	 * may not have been called from userspace and after dev_private
 	 * is freed, it's too late.
 	 */
-	if ( dev->irq_enabled ) drm_irq_uninstall(dev);
+	if (dev->irq_enabled)
+		drm_irq_uninstall(dev);
 
 	if (dev->dev_private) {
 		int i;
-	   	drm_i830_private_t *dev_priv = 
-	     		(drm_i830_private_t *) dev->dev_private;
-	   
-	   	if (dev_priv->ring.virtual_start) {
-		   	drm_ioremapfree((void *) dev_priv->ring.virtual_start,
-					 dev_priv->ring.Size, dev);
+		drm_i830_private_t *dev_priv =
+		    (drm_i830_private_t *) dev->dev_private;
+
+		if (dev_priv->ring.virtual_start) {
+			drm_ioremapfree((void *)dev_priv->ring.virtual_start,
+					dev_priv->ring.Size, dev);
 		}
-	   	if (dev_priv->hw_status_page) {
+		if (dev_priv->hw_status_page) {
 			pci_free_consistent(dev->pdev, PAGE_SIZE,
 					    dev_priv->hw_status_page,
 					    dev_priv->dma_status_page);
-		   	/* Need to rewrite hardware status page */
-		   	I830_WRITE(0x02080, 0x1ffff000);
+			/* Need to rewrite hardware status page */
+			I830_WRITE(0x02080, 0x1ffff000);
 		}
 
-	   	drm_free(dev->dev_private, sizeof(drm_i830_private_t), 
+		drm_free(dev->dev_private, sizeof(drm_i830_private_t),
 			 DRM_MEM_DRIVER);
-	   	dev->dev_private = NULL;
+		dev->dev_private = NULL;
 
 		for (i = 0; i < dma->buf_count; i++) {
-			drm_buf_t *buf = dma->buflist[ i ];
+			drm_buf_t *buf = dma->buflist[i];
 			drm_i830_buf_priv_t *buf_priv = buf->dev_private;
-			if ( buf_priv->kernel_virtual && buf->total )
-				drm_ioremapfree(buf_priv->kernel_virtual, buf->total, dev);
+			if (buf_priv->kernel_virtual && buf->total)
+				drm_ioremapfree(buf_priv->kernel_virtual,
+						buf->total, dev);
 		}
 	}
-   	return 0;
+	return 0;
 }
 
-int i830_wait_ring(drm_device_t *dev, int n, const char *caller)
+int i830_wait_ring(drm_device_t * dev, int n, const char *caller)
 {
-   	drm_i830_private_t *dev_priv = dev->dev_private;
-   	drm_i830_ring_buffer_t *ring = &(dev_priv->ring);
-   	int iters = 0;
-   	unsigned long end;
+	drm_i830_private_t *dev_priv = dev->dev_private;
+	drm_i830_ring_buffer_t *ring = &(dev_priv->ring);
+	int iters = 0;
+	unsigned long end;
 	unsigned int last_head = I830_READ(LP_RING + RING_HEAD) & HEAD_ADDR;
 
-	end = jiffies + (HZ*3);
-   	while (ring->space < n) {	
-	   	ring->head = I830_READ(LP_RING + RING_HEAD) & HEAD_ADDR;
-	   	ring->space = ring->head - (ring->tail+8);
-		if (ring->space < 0) ring->space += ring->Size;
-	   
+	end = jiffies + (HZ * 3);
+	while (ring->space < n) {
+		ring->head = I830_READ(LP_RING + RING_HEAD) & HEAD_ADDR;
+		ring->space = ring->head - (ring->tail + 8);
+		if (ring->space < 0)
+			ring->space += ring->Size;
+
 		if (ring->head != last_head) {
-			end = jiffies + (HZ*3);
+			end = jiffies + (HZ * 3);
 			last_head = ring->head;
 		}
-	  
-	   	iters++;
-		if(time_before(end, jiffies)) {
-		   	DRM_ERROR("space: %d wanted %d\n", ring->space, n);
-		   	DRM_ERROR("lockup\n");
-		   	goto out_wait_ring;
+
+		iters++;
+		if (time_before(end, jiffies)) {
+			DRM_ERROR("space: %d wanted %d\n", ring->space, n);
+			DRM_ERROR("lockup\n");
+			goto out_wait_ring;
 		}
 		udelay(1);
 		dev_priv->sarea_priv->perf_boxes |= I830_BOX_WAIT;
 	}
 
-out_wait_ring:   
-   	return iters;
+      out_wait_ring:
+	return iters;
 }
 
-static void i830_kernel_lost_context(drm_device_t *dev)
+static void i830_kernel_lost_context(drm_device_t * dev)
 {
-      	drm_i830_private_t *dev_priv = dev->dev_private;
-   	drm_i830_ring_buffer_t *ring = &(dev_priv->ring);
-      
-   	ring->head = I830_READ(LP_RING + RING_HEAD) & HEAD_ADDR;
-     	ring->tail = I830_READ(LP_RING + RING_TAIL) & TAIL_ADDR;
-     	ring->space = ring->head - (ring->tail+8);
-     	if (ring->space < 0) ring->space += ring->Size;
+	drm_i830_private_t *dev_priv = dev->dev_private;
+	drm_i830_ring_buffer_t *ring = &(dev_priv->ring);
+
+	ring->head = I830_READ(LP_RING + RING_HEAD) & HEAD_ADDR;
+	ring->tail = I830_READ(LP_RING + RING_TAIL) & TAIL_ADDR;
+	ring->space = ring->head - (ring->tail + 8);
+	if (ring->space < 0)
+		ring->space += ring->Size;
 
 	if (ring->head == ring->tail)
 		dev_priv->sarea_priv->perf_boxes |= I830_BOX_RING_EMPTY;
 }
 
-static int i830_freelist_init(drm_device_t *dev, drm_i830_private_t *dev_priv)
+static int i830_freelist_init(drm_device_t * dev, drm_i830_private_t * dev_priv)
 {
-      	drm_device_dma_t *dma = dev->dma;
-   	int my_idx = 36;
-   	u32 *hw_status = (u32 *)(dev_priv->hw_status_page + my_idx);
-   	int i;
+	drm_device_dma_t *dma = dev->dma;
+	int my_idx = 36;
+	u32 *hw_status = (u32 *) (dev_priv->hw_status_page + my_idx);
+	int i;
 
-   	if(dma->buf_count > 1019) {
-	   	/* Not enough space in the status page for the freelist */
-	   	return -EINVAL;
+	if (dma->buf_count > 1019) {
+		/* Not enough space in the status page for the freelist */
+		return -EINVAL;
 	}
 
-   	for (i = 0; i < dma->buf_count; i++) {
-	   	drm_buf_t *buf = dma->buflist[ i ];
-	   	drm_i830_buf_priv_t *buf_priv = buf->dev_private;
+	for (i = 0; i < dma->buf_count; i++) {
+		drm_buf_t *buf = dma->buflist[i];
+		drm_i830_buf_priv_t *buf_priv = buf->dev_private;
 
-	   	buf_priv->in_use = hw_status++;
-	   	buf_priv->my_use_idx = my_idx;
-	   	my_idx += 4;
+		buf_priv->in_use = hw_status++;
+		buf_priv->my_use_idx = my_idx;
+		my_idx += 4;
 
-	   	*buf_priv->in_use = I830_BUF_FREE;
+		*buf_priv->in_use = I830_BUF_FREE;
 
-		buf_priv->kernel_virtual = drm_ioremap(buf->bus_address, 
-							buf->total, dev);
+		buf_priv->kernel_virtual = drm_ioremap(buf->bus_address,
+						       buf->total, dev);
 	}
 	return 0;
 }
 
-static int i830_dma_initialize(drm_device_t *dev, 
-			       drm_i830_private_t *dev_priv,
-			       drm_i830_init_t *init)
+static int i830_dma_initialize(drm_device_t * dev,
+			       drm_i830_private_t * dev_priv,
+			       drm_i830_init_t * init)
 {
 	struct list_head *list;
 
-   	memset(dev_priv, 0, sizeof(drm_i830_private_t));
+	memset(dev_priv, 0, sizeof(drm_i830_private_t));
 
 	list_for_each(list, &dev->maplist->head) {
 		drm_map_list_t *r_list = list_entry(list, drm_map_list_t, head);
-		if( r_list->map &&
+		if (r_list->map &&
 		    r_list->map->type == _DRM_SHM &&
-		    r_list->map->flags & _DRM_CONTAINS_LOCK ) {
+		    r_list->map->flags & _DRM_CONTAINS_LOCK) {
 			dev_priv->sarea_map = r_list->map;
- 			break;
- 		}
- 	}
+			break;
+		}
+	}
 
-	if(!dev_priv->sarea_map) {
+	if (!dev_priv->sarea_map) {
 		dev->dev_private = (void *)dev_priv;
 		i830_dma_cleanup(dev);
 		DRM_ERROR("can not find sarea!\n");
 		return -EINVAL;
 	}
 	dev_priv->mmio_map = drm_core_findmap(dev, init->mmio_offset);
-	if(!dev_priv->mmio_map) {
+	if (!dev_priv->mmio_map) {
 		dev->dev_private = (void *)dev_priv;
 		i830_dma_cleanup(dev);
 		DRM_ERROR("can not find mmio map!\n");
 		return -EINVAL;
 	}
 	dev->agp_buffer_map = drm_core_findmap(dev, init->buffers_offset);
-	if(!dev->agp_buffer_map) {
+	if (!dev->agp_buffer_map) {
 		dev->dev_private = (void *)dev_priv;
 		i830_dma_cleanup(dev);
 		DRM_ERROR("can not find dma buffer map!\n");
@@ -367,27 +375,26 @@ static int i830_dma_initialize(drm_devic
 	}
 
 	dev_priv->sarea_priv = (drm_i830_sarea_t *)
-		((u8 *)dev_priv->sarea_map->handle +
-		 init->sarea_priv_offset);
+	    ((u8 *) dev_priv->sarea_map->handle + init->sarea_priv_offset);
 
-   	dev_priv->ring.Start = init->ring_start;
-   	dev_priv->ring.End = init->ring_end;
-   	dev_priv->ring.Size = init->ring_size;
-
-   	dev_priv->ring.virtual_start = drm_ioremap(dev->agp->base + 
-						    init->ring_start, 
-						    init->ring_size, dev);
-
-   	if (dev_priv->ring.virtual_start == NULL) {
-		dev->dev_private = (void *) dev_priv;
-	   	i830_dma_cleanup(dev);
-	   	DRM_ERROR("can not ioremap virtual address for"
+	dev_priv->ring.Start = init->ring_start;
+	dev_priv->ring.End = init->ring_end;
+	dev_priv->ring.Size = init->ring_size;
+
+	dev_priv->ring.virtual_start = drm_ioremap(dev->agp->base +
+						   init->ring_start,
+						   init->ring_size, dev);
+
+	if (dev_priv->ring.virtual_start == NULL) {
+		dev->dev_private = (void *)dev_priv;
+		i830_dma_cleanup(dev);
+		DRM_ERROR("can not ioremap virtual address for"
 			  " ring buffer\n");
-	   	return -ENOMEM;
+		return -ENOMEM;
 	}
 
-   	dev_priv->ring.tail_mask = dev_priv->ring.Size - 1;
-   
+	dev_priv->ring.tail_mask = dev_priv->ring.Size - 1;
+
 	dev_priv->w = init->w;
 	dev_priv->h = init->h;
 	dev_priv->pitch = init->pitch;
@@ -399,10 +406,10 @@ static int i830_dma_initialize(drm_devic
 	dev_priv->back_di1 = init->back_offset | init->pitch_bits;
 	dev_priv->zi1 = init->depth_offset | init->pitch_bits;
 
-	DRM_DEBUG("front_di1 %x\n",    dev_priv->front_di1);
+	DRM_DEBUG("front_di1 %x\n", dev_priv->front_di1);
 	DRM_DEBUG("back_offset %x\n", dev_priv->back_offset);
-	DRM_DEBUG("back_di1 %x\n",    dev_priv->back_di1);
-	DRM_DEBUG("pitch_bits %x\n",    init->pitch_bits);
+	DRM_DEBUG("back_di1 %x\n", dev_priv->back_di1);
+	DRM_DEBUG("pitch_bits %x\n", init->pitch_bits);
 
 	dev_priv->cpp = init->cpp;
 	/* We are using separate values as placeholders for mechanisms for
@@ -414,63 +421,64 @@ static int i830_dma_initialize(drm_devic
 	dev_priv->do_boxes = 0;
 	dev_priv->use_mi_batchbuffer_start = 0;
 
-   	/* Program Hardware Status Page */
-   	dev_priv->hw_status_page =
-		pci_alloc_consistent(dev->pdev, PAGE_SIZE,
-						&dev_priv->dma_status_page);
-   	if (!dev_priv->hw_status_page) {
+	/* Program Hardware Status Page */
+	dev_priv->hw_status_page =
+	    pci_alloc_consistent(dev->pdev, PAGE_SIZE,
+				 &dev_priv->dma_status_page);
+	if (!dev_priv->hw_status_page) {
 		dev->dev_private = (void *)dev_priv;
 		i830_dma_cleanup(dev);
 		DRM_ERROR("Can not allocate hardware status page\n");
 		return -ENOMEM;
 	}
-   	memset(dev_priv->hw_status_page, 0, PAGE_SIZE);
+	memset(dev_priv->hw_status_page, 0, PAGE_SIZE);
 	DRM_DEBUG("hw status page @ %p\n", dev_priv->hw_status_page);
-   
-   	I830_WRITE(0x02080, dev_priv->dma_status_page);
+
+	I830_WRITE(0x02080, dev_priv->dma_status_page);
 	DRM_DEBUG("Enabled hardware status page\n");
-   
-   	/* Now we need to init our freelist */
-   	if(i830_freelist_init(dev, dev_priv) != 0) {
+
+	/* Now we need to init our freelist */
+	if (i830_freelist_init(dev, dev_priv) != 0) {
 		dev->dev_private = (void *)dev_priv;
-	   	i830_dma_cleanup(dev);
-	   	DRM_ERROR("Not enough space in the status page for"
+		i830_dma_cleanup(dev);
+		DRM_ERROR("Not enough space in the status page for"
 			  " the freelist\n");
-	   	return -ENOMEM;
+		return -ENOMEM;
 	}
 	dev->dev_private = (void *)dev_priv;
 
-   	return 0;
+	return 0;
 }
 
 static int i830_dma_init(struct inode *inode, struct file *filp,
-		  unsigned int cmd, unsigned long arg)
+			 unsigned int cmd, unsigned long arg)
 {
-   	drm_file_t *priv = filp->private_data;
-   	drm_device_t *dev = priv->head->dev;
-   	drm_i830_private_t *dev_priv;
-   	drm_i830_init_t init;
-   	int retcode = 0;
-	
-  	if (copy_from_user(&init, (void * __user) arg, sizeof(init)))
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
+	drm_i830_private_t *dev_priv;
+	drm_i830_init_t init;
+	int retcode = 0;
+
+	if (copy_from_user(&init, (void *__user)arg, sizeof(init)))
 		return -EFAULT;
-	
-   	switch(init.func) {
-	 	case I830_INIT_DMA:
-			dev_priv = drm_alloc(sizeof(drm_i830_private_t), 
-					      DRM_MEM_DRIVER);
-	   		if(dev_priv == NULL) return -ENOMEM;
-	   		retcode = i830_dma_initialize(dev, dev_priv, &init);
-	   	break;
-	 	case I830_CLEANUP_DMA:
-	   		retcode = i830_dma_cleanup(dev);
-	   	break;
-	 	default:
-	   		retcode = -EINVAL;
-	   	break;
+
+	switch (init.func) {
+	case I830_INIT_DMA:
+		dev_priv = drm_alloc(sizeof(drm_i830_private_t),
+				     DRM_MEM_DRIVER);
+		if (dev_priv == NULL)
+			return -ENOMEM;
+		retcode = i830_dma_initialize(dev, dev_priv, &init);
+		break;
+	case I830_CLEANUP_DMA:
+		retcode = i830_dma_cleanup(dev);
+		break;
+	default:
+		retcode = -EINVAL;
+		break;
 	}
-   
-   	return retcode;
+
+	return retcode;
 }
 
 #define GFX_OP_STIPPLE           ((0x3<<29)|(0x1d<<24)|(0x83<<16))
@@ -480,92 +488,89 @@ static int i830_dma_init(struct inode *i
 /* Most efficient way to verify state for the i830 is as it is
  * emitted.  Non-conformant state is silently dropped.
  */
-static void i830EmitContextVerified( drm_device_t *dev,
-				     unsigned int *code )
+static void i830EmitContextVerified(drm_device_t * dev, unsigned int *code)
 {
-   	drm_i830_private_t *dev_priv = dev->dev_private;
+	drm_i830_private_t *dev_priv = dev->dev_private;
 	int i, j = 0;
 	unsigned int tmp;
 	RING_LOCALS;
 
-	BEGIN_LP_RING( I830_CTX_SETUP_SIZE + 4 );
+	BEGIN_LP_RING(I830_CTX_SETUP_SIZE + 4);
 
-	for ( i = 0 ; i < I830_CTXREG_BLENDCOLR0 ; i++ ) {
+	for (i = 0; i < I830_CTXREG_BLENDCOLR0; i++) {
 		tmp = code[i];
-		if ((tmp & (7<<29)) == CMD_3D &&
-		    (tmp & (0x1f<<24)) < (0x1d<<24)) {
-			OUT_RING( tmp ); 
+		if ((tmp & (7 << 29)) == CMD_3D &&
+		    (tmp & (0x1f << 24)) < (0x1d << 24)) {
+			OUT_RING(tmp);
 			j++;
 		} else {
 			DRM_ERROR("Skipping %d\n", i);
 		}
 	}
 
-	OUT_RING( STATE3D_CONST_BLEND_COLOR_CMD ); 
-	OUT_RING( code[I830_CTXREG_BLENDCOLR] ); 
+	OUT_RING(STATE3D_CONST_BLEND_COLOR_CMD);
+	OUT_RING(code[I830_CTXREG_BLENDCOLR]);
 	j += 2;
 
-	for ( i = I830_CTXREG_VF ; i < I830_CTXREG_MCSB0 ; i++ ) {
+	for (i = I830_CTXREG_VF; i < I830_CTXREG_MCSB0; i++) {
 		tmp = code[i];
-		if ((tmp & (7<<29)) == CMD_3D &&
-		    (tmp & (0x1f<<24)) < (0x1d<<24)) {
-			OUT_RING( tmp ); 
+		if ((tmp & (7 << 29)) == CMD_3D &&
+		    (tmp & (0x1f << 24)) < (0x1d << 24)) {
+			OUT_RING(tmp);
 			j++;
 		} else {
 			DRM_ERROR("Skipping %d\n", i);
 		}
 	}
 
-	OUT_RING( STATE3D_MAP_COORD_SETBIND_CMD ); 
-	OUT_RING( code[I830_CTXREG_MCSB1] ); 
+	OUT_RING(STATE3D_MAP_COORD_SETBIND_CMD);
+	OUT_RING(code[I830_CTXREG_MCSB1]);
 	j += 2;
 
-	if (j & 1) 
-		OUT_RING( 0 ); 
+	if (j & 1)
+		OUT_RING(0);
 
 	ADVANCE_LP_RING();
 }
 
-static void i830EmitTexVerified( drm_device_t *dev, unsigned int *code ) 
+static void i830EmitTexVerified(drm_device_t * dev, unsigned int *code)
 {
-   	drm_i830_private_t *dev_priv = dev->dev_private;
+	drm_i830_private_t *dev_priv = dev->dev_private;
 	int i, j = 0;
 	unsigned int tmp;
 	RING_LOCALS;
 
 	if (code[I830_TEXREG_MI0] == GFX_OP_MAP_INFO ||
-	    (code[I830_TEXREG_MI0] & ~(0xf*LOAD_TEXTURE_MAP0)) == 
-	    (STATE3D_LOAD_STATE_IMMEDIATE_2|4)) {
+	    (code[I830_TEXREG_MI0] & ~(0xf * LOAD_TEXTURE_MAP0)) ==
+	    (STATE3D_LOAD_STATE_IMMEDIATE_2 | 4)) {
+
+		BEGIN_LP_RING(I830_TEX_SETUP_SIZE);
 
-		BEGIN_LP_RING( I830_TEX_SETUP_SIZE );
+		OUT_RING(code[I830_TEXREG_MI0]);	/* TM0LI */
+		OUT_RING(code[I830_TEXREG_MI1]);	/* TM0S0 */
+		OUT_RING(code[I830_TEXREG_MI2]);	/* TM0S1 */
+		OUT_RING(code[I830_TEXREG_MI3]);	/* TM0S2 */
+		OUT_RING(code[I830_TEXREG_MI4]);	/* TM0S3 */
+		OUT_RING(code[I830_TEXREG_MI5]);	/* TM0S4 */
 
-		OUT_RING( code[I830_TEXREG_MI0] ); /* TM0LI */
-		OUT_RING( code[I830_TEXREG_MI1] ); /* TM0S0 */
-		OUT_RING( code[I830_TEXREG_MI2] ); /* TM0S1 */
-		OUT_RING( code[I830_TEXREG_MI3] ); /* TM0S2 */
-		OUT_RING( code[I830_TEXREG_MI4] ); /* TM0S3 */
-		OUT_RING( code[I830_TEXREG_MI5] ); /* TM0S4 */
-		
-		for ( i = 6 ; i < I830_TEX_SETUP_SIZE ; i++ ) {
+		for (i = 6; i < I830_TEX_SETUP_SIZE; i++) {
 			tmp = code[i];
-			OUT_RING( tmp ); 
+			OUT_RING(tmp);
 			j++;
-		} 
+		}
 
-		if (j & 1) 
-			OUT_RING( 0 ); 
+		if (j & 1)
+			OUT_RING(0);
 
 		ADVANCE_LP_RING();
-	}
-	else
+	} else
 		printk("rejected packet %x\n", code[0]);
 }
 
-static void i830EmitTexBlendVerified( drm_device_t *dev, 
-				      unsigned int *code,
-				      unsigned int num)
+static void i830EmitTexBlendVerified(drm_device_t * dev,
+				     unsigned int *code, unsigned int num)
 {
-   	drm_i830_private_t *dev_priv = dev->dev_private;
+	drm_i830_private_t *dev_priv = dev->dev_private;
 	int i, j = 0;
 	unsigned int tmp;
 	RING_LOCALS;
@@ -573,59 +578,54 @@ static void i830EmitTexBlendVerified( dr
 	if (!num)
 		return;
 
-	BEGIN_LP_RING( num + 1 );
+	BEGIN_LP_RING(num + 1);
 
-	for ( i = 0 ; i < num ; i++ ) {
+	for (i = 0; i < num; i++) {
 		tmp = code[i];
-		OUT_RING( tmp );
+		OUT_RING(tmp);
 		j++;
 	}
 
-	if (j & 1) 
-		OUT_RING( 0 ); 
+	if (j & 1)
+		OUT_RING(0);
 
 	ADVANCE_LP_RING();
 }
 
-static void i830EmitTexPalette( drm_device_t *dev,
-			        unsigned int *palette,
-			        int number,
-			        int is_shared )
+static void i830EmitTexPalette(drm_device_t * dev,
+			       unsigned int *palette, int number, int is_shared)
 {
-   	drm_i830_private_t *dev_priv = dev->dev_private;
+	drm_i830_private_t *dev_priv = dev->dev_private;
 	int i;
 	RING_LOCALS;
 
 	return;
 
-	BEGIN_LP_RING( 258 );
+	BEGIN_LP_RING(258);
 
-	if(is_shared == 1) {
+	if (is_shared == 1) {
 		OUT_RING(CMD_OP_MAP_PALETTE_LOAD |
-			 MAP_PALETTE_NUM(0) |
-			 MAP_PALETTE_BOTH);
+			 MAP_PALETTE_NUM(0) | MAP_PALETTE_BOTH);
 	} else {
 		OUT_RING(CMD_OP_MAP_PALETTE_LOAD | MAP_PALETTE_NUM(number));
 	}
-	for(i = 0; i < 256; i++) {
+	for (i = 0; i < 256; i++) {
 		OUT_RING(palette[i]);
 	}
 	OUT_RING(0);
-	/* KW:  WHERE IS THE ADVANCE_LP_RING?  This is effectively a noop! 
+	/* KW:  WHERE IS THE ADVANCE_LP_RING?  This is effectively a noop!
 	 */
 }
 
 /* Need to do some additional checking when setting the dest buffer.
  */
-static void i830EmitDestVerified( drm_device_t *dev, 
-				  unsigned int *code ) 
-{	
-   	drm_i830_private_t *dev_priv = dev->dev_private;
+static void i830EmitDestVerified(drm_device_t * dev, unsigned int *code)
+{
+	drm_i830_private_t *dev_priv = dev->dev_private;
 	unsigned int tmp;
 	RING_LOCALS;
 
-	BEGIN_LP_RING( I830_DEST_SETUP_SIZE + 10 );
-
+	BEGIN_LP_RING(I830_DEST_SETUP_SIZE + 10);
 
 	tmp = code[I830_DESTREG_CBUFADDR];
 	if (tmp == dev_priv->front_di1 || tmp == dev_priv->back_di1) {
@@ -634,18 +634,18 @@ static void i830EmitDestVerified( drm_de
 			OUT_RING(0);
 		}
 
-		OUT_RING( CMD_OP_DESTBUFFER_INFO );
-		OUT_RING( BUF_3D_ID_COLOR_BACK | 
-			  BUF_3D_PITCH(dev_priv->back_pitch * dev_priv->cpp) |
-			  BUF_3D_USE_FENCE);
-		OUT_RING( tmp );
-		OUT_RING( 0 );
-
-		OUT_RING( CMD_OP_DESTBUFFER_INFO );
-		OUT_RING( BUF_3D_ID_DEPTH | BUF_3D_USE_FENCE | 
-			  BUF_3D_PITCH(dev_priv->depth_pitch * dev_priv->cpp));
-		OUT_RING( dev_priv->zi1 );
-		OUT_RING( 0 );
+		OUT_RING(CMD_OP_DESTBUFFER_INFO);
+		OUT_RING(BUF_3D_ID_COLOR_BACK |
+			 BUF_3D_PITCH(dev_priv->back_pitch * dev_priv->cpp) |
+			 BUF_3D_USE_FENCE);
+		OUT_RING(tmp);
+		OUT_RING(0);
+
+		OUT_RING(CMD_OP_DESTBUFFER_INFO);
+		OUT_RING(BUF_3D_ID_DEPTH | BUF_3D_USE_FENCE |
+			 BUF_3D_PITCH(dev_priv->depth_pitch * dev_priv->cpp));
+		OUT_RING(dev_priv->zi1);
+		OUT_RING(0);
 	} else {
 		DRM_ERROR("bad di1 %x (allow %x or %x)\n",
 			  tmp, dev_priv->front_di1, dev_priv->back_di1);
@@ -654,83 +654,80 @@ static void i830EmitDestVerified( drm_de
 	/* invarient:
 	 */
 
+	OUT_RING(GFX_OP_DESTBUFFER_VARS);
+	OUT_RING(code[I830_DESTREG_DV1]);
 
-	OUT_RING( GFX_OP_DESTBUFFER_VARS );
-	OUT_RING( code[I830_DESTREG_DV1] );
-
-	OUT_RING( GFX_OP_DRAWRECT_INFO );
-	OUT_RING( code[I830_DESTREG_DR1] );
-	OUT_RING( code[I830_DESTREG_DR2] );
-	OUT_RING( code[I830_DESTREG_DR3] );
-	OUT_RING( code[I830_DESTREG_DR4] );
+	OUT_RING(GFX_OP_DRAWRECT_INFO);
+	OUT_RING(code[I830_DESTREG_DR1]);
+	OUT_RING(code[I830_DESTREG_DR2]);
+	OUT_RING(code[I830_DESTREG_DR3]);
+	OUT_RING(code[I830_DESTREG_DR4]);
 
 	/* Need to verify this */
 	tmp = code[I830_DESTREG_SENABLE];
-	if((tmp & ~0x3) == GFX_OP_SCISSOR_ENABLE) {
-		OUT_RING( tmp );
+	if ((tmp & ~0x3) == GFX_OP_SCISSOR_ENABLE) {
+		OUT_RING(tmp);
 	} else {
 		DRM_ERROR("bad scissor enable\n");
-		OUT_RING( 0 );
+		OUT_RING(0);
 	}
 
-	OUT_RING( GFX_OP_SCISSOR_RECT );
-	OUT_RING( code[I830_DESTREG_SR1] );
-	OUT_RING( code[I830_DESTREG_SR2] );
-	OUT_RING( 0 );
+	OUT_RING(GFX_OP_SCISSOR_RECT);
+	OUT_RING(code[I830_DESTREG_SR1]);
+	OUT_RING(code[I830_DESTREG_SR2]);
+	OUT_RING(0);
 
 	ADVANCE_LP_RING();
 }
 
-static void i830EmitStippleVerified( drm_device_t *dev, 
-				     unsigned int *code ) 
+static void i830EmitStippleVerified(drm_device_t * dev, unsigned int *code)
 {
-   	drm_i830_private_t *dev_priv = dev->dev_private;
+	drm_i830_private_t *dev_priv = dev->dev_private;
 	RING_LOCALS;
 
-	BEGIN_LP_RING( 2 );
-	OUT_RING( GFX_OP_STIPPLE );
-	OUT_RING( code[1] );
-	ADVANCE_LP_RING();	
+	BEGIN_LP_RING(2);
+	OUT_RING(GFX_OP_STIPPLE);
+	OUT_RING(code[1]);
+	ADVANCE_LP_RING();
 }
 
-
-static void i830EmitState( drm_device_t *dev )
+static void i830EmitState(drm_device_t * dev)
 {
-   	drm_i830_private_t *dev_priv = dev->dev_private;
-      	drm_i830_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_i830_private_t *dev_priv = dev->dev_private;
+	drm_i830_sarea_t *sarea_priv = dev_priv->sarea_priv;
 	unsigned int dirty = sarea_priv->dirty;
 
 	DRM_DEBUG("%s %x\n", __FUNCTION__, dirty);
 
 	if (dirty & I830_UPLOAD_BUFFERS) {
-		i830EmitDestVerified( dev, sarea_priv->BufferState );
+		i830EmitDestVerified(dev, sarea_priv->BufferState);
 		sarea_priv->dirty &= ~I830_UPLOAD_BUFFERS;
 	}
 
 	if (dirty & I830_UPLOAD_CTX) {
-		i830EmitContextVerified( dev, sarea_priv->ContextState );
+		i830EmitContextVerified(dev, sarea_priv->ContextState);
 		sarea_priv->dirty &= ~I830_UPLOAD_CTX;
 	}
 
 	if (dirty & I830_UPLOAD_TEX0) {
-		i830EmitTexVerified( dev, sarea_priv->TexState[0] );
+		i830EmitTexVerified(dev, sarea_priv->TexState[0]);
 		sarea_priv->dirty &= ~I830_UPLOAD_TEX0;
 	}
 
 	if (dirty & I830_UPLOAD_TEX1) {
-		i830EmitTexVerified( dev, sarea_priv->TexState[1] );
+		i830EmitTexVerified(dev, sarea_priv->TexState[1]);
 		sarea_priv->dirty &= ~I830_UPLOAD_TEX1;
 	}
 
 	if (dirty & I830_UPLOAD_TEXBLEND0) {
-		i830EmitTexBlendVerified( dev, sarea_priv->TexBlendState[0],
-				sarea_priv->TexBlendStateWordsUsed[0]);
+		i830EmitTexBlendVerified(dev, sarea_priv->TexBlendState[0],
+					 sarea_priv->TexBlendStateWordsUsed[0]);
 		sarea_priv->dirty &= ~I830_UPLOAD_TEXBLEND0;
 	}
 
 	if (dirty & I830_UPLOAD_TEXBLEND1) {
-		i830EmitTexBlendVerified( dev, sarea_priv->TexBlendState[1],
-				sarea_priv->TexBlendStateWordsUsed[1]);
+		i830EmitTexBlendVerified(dev, sarea_priv->TexBlendState[1],
+					 sarea_priv->TexBlendStateWordsUsed[1]);
 		sarea_priv->dirty &= ~I830_UPLOAD_TEXBLEND1;
 	}
 
@@ -763,36 +760,32 @@ static void i830EmitState( drm_device_t 
 	/* 1.3:
 	 */
 	if (dirty & I830_UPLOAD_STIPPLE) {
-		i830EmitStippleVerified( dev, 
-					 sarea_priv->StippleState);
+		i830EmitStippleVerified(dev, sarea_priv->StippleState);
 		sarea_priv->dirty &= ~I830_UPLOAD_STIPPLE;
 	}
 
 	if (dirty & I830_UPLOAD_TEX2) {
-		i830EmitTexVerified( dev, sarea_priv->TexState2 );
+		i830EmitTexVerified(dev, sarea_priv->TexState2);
 		sarea_priv->dirty &= ~I830_UPLOAD_TEX2;
 	}
 
 	if (dirty & I830_UPLOAD_TEX3) {
-		i830EmitTexVerified( dev, sarea_priv->TexState3 );
+		i830EmitTexVerified(dev, sarea_priv->TexState3);
 		sarea_priv->dirty &= ~I830_UPLOAD_TEX3;
 	}
 
-
 	if (dirty & I830_UPLOAD_TEXBLEND2) {
-		i830EmitTexBlendVerified( 
-			dev, 
-			sarea_priv->TexBlendState2,
-			sarea_priv->TexBlendStateWordsUsed2);
+		i830EmitTexBlendVerified(dev,
+					 sarea_priv->TexBlendState2,
+					 sarea_priv->TexBlendStateWordsUsed2);
 
 		sarea_priv->dirty &= ~I830_UPLOAD_TEXBLEND2;
 	}
 
 	if (dirty & I830_UPLOAD_TEXBLEND3) {
-		i830EmitTexBlendVerified( 
-			dev, 
-			sarea_priv->TexBlendState3,
-			sarea_priv->TexBlendStateWordsUsed3);
+		i830EmitTexBlendVerified(dev,
+					 sarea_priv->TexBlendState3,
+					 sarea_priv->TexBlendStateWordsUsed3);
 		sarea_priv->dirty &= ~I830_UPLOAD_TEXBLEND3;
 	}
 }
@@ -801,97 +794,96 @@ static void i830EmitState( drm_device_t 
  * Performance monitoring functions
  */
 
-static void i830_fill_box( drm_device_t *dev,
-			   int x, int y, int w, int h,
-			   int r, int g, int b )
+static void i830_fill_box(drm_device_t * dev,
+			  int x, int y, int w, int h, int r, int g, int b)
 {
-   	drm_i830_private_t *dev_priv = dev->dev_private;
+	drm_i830_private_t *dev_priv = dev->dev_private;
 	u32 color;
 	unsigned int BR13, CMD;
 	RING_LOCALS;
 
-	BR13 = (0xF0 << 16) | (dev_priv->pitch * dev_priv->cpp) | (1<<24);
+	BR13 = (0xF0 << 16) | (dev_priv->pitch * dev_priv->cpp) | (1 << 24);
 	CMD = XY_COLOR_BLT_CMD;
 	x += dev_priv->sarea_priv->boxes[0].x1;
 	y += dev_priv->sarea_priv->boxes[0].y1;
 
 	if (dev_priv->cpp == 4) {
-		BR13 |= (1<<25);
+		BR13 |= (1 << 25);
 		CMD |= (XY_COLOR_BLT_WRITE_ALPHA | XY_COLOR_BLT_WRITE_RGB);
-		color = (((0xff) << 24) | (r << 16) | (g <<  8) | b);	
+		color = (((0xff) << 24) | (r << 16) | (g << 8) | b);
 	} else {
 		color = (((r & 0xf8) << 8) |
-			 ((g & 0xfc) << 3) |
-			 ((b & 0xf8) >> 3));
+			 ((g & 0xfc) << 3) | ((b & 0xf8) >> 3));
 	}
 
-	BEGIN_LP_RING( 6 );	    
-	OUT_RING( CMD );
-	OUT_RING( BR13 );
-	OUT_RING( (y << 16) | x );
-	OUT_RING( ((y+h) << 16) | (x+w) );
-
- 	if ( dev_priv->current_page == 1 ) { 
-		OUT_RING( dev_priv->front_offset );
- 	} else {	 
-		OUT_RING( dev_priv->back_offset );
- 	} 
+	BEGIN_LP_RING(6);
+	OUT_RING(CMD);
+	OUT_RING(BR13);
+	OUT_RING((y << 16) | x);
+	OUT_RING(((y + h) << 16) | (x + w));
+
+	if (dev_priv->current_page == 1) {
+		OUT_RING(dev_priv->front_offset);
+	} else {
+		OUT_RING(dev_priv->back_offset);
+	}
 
-	OUT_RING( color );
+	OUT_RING(color);
 	ADVANCE_LP_RING();
 }
 
-static void i830_cp_performance_boxes( drm_device_t *dev )
+static void i830_cp_performance_boxes(drm_device_t * dev)
 {
-   	drm_i830_private_t *dev_priv = dev->dev_private;
+	drm_i830_private_t *dev_priv = dev->dev_private;
 
 	/* Purple box for page flipping
 	 */
-	if ( dev_priv->sarea_priv->perf_boxes & I830_BOX_FLIP ) 
-		i830_fill_box( dev, 4, 4, 8, 8, 255, 0, 255 );
+	if (dev_priv->sarea_priv->perf_boxes & I830_BOX_FLIP)
+		i830_fill_box(dev, 4, 4, 8, 8, 255, 0, 255);
 
 	/* Red box if we have to wait for idle at any point
 	 */
-	if ( dev_priv->sarea_priv->perf_boxes & I830_BOX_WAIT ) 
-		i830_fill_box( dev, 16, 4, 8, 8, 255, 0, 0 );
+	if (dev_priv->sarea_priv->perf_boxes & I830_BOX_WAIT)
+		i830_fill_box(dev, 16, 4, 8, 8, 255, 0, 0);
 
 	/* Blue box: lost context?
 	 */
-	if ( dev_priv->sarea_priv->perf_boxes & I830_BOX_LOST_CONTEXT ) 
-		i830_fill_box( dev, 28, 4, 8, 8, 0, 0, 255 );
+	if (dev_priv->sarea_priv->perf_boxes & I830_BOX_LOST_CONTEXT)
+		i830_fill_box(dev, 28, 4, 8, 8, 0, 0, 255);
 
 	/* Yellow box for texture swaps
 	 */
-	if ( dev_priv->sarea_priv->perf_boxes & I830_BOX_TEXTURE_LOAD ) 
-		i830_fill_box( dev, 40, 4, 8, 8, 255, 255, 0 );
+	if (dev_priv->sarea_priv->perf_boxes & I830_BOX_TEXTURE_LOAD)
+		i830_fill_box(dev, 40, 4, 8, 8, 255, 255, 0);
 
 	/* Green box if hardware never idles (as far as we can tell)
 	 */
-	if ( !(dev_priv->sarea_priv->perf_boxes & I830_BOX_RING_EMPTY) ) 
-		i830_fill_box( dev, 64, 4, 8, 8, 0, 255, 0 );
+	if (!(dev_priv->sarea_priv->perf_boxes & I830_BOX_RING_EMPTY))
+		i830_fill_box(dev, 64, 4, 8, 8, 0, 255, 0);
 
-
-	/* Draw bars indicating number of buffers allocated 
+	/* Draw bars indicating number of buffers allocated
 	 * (not a great measure, easily confused)
 	 */
 	if (dev_priv->dma_used) {
 		int bar = dev_priv->dma_used / 10240;
-		if (bar > 100) bar = 100;
-		if (bar < 1) bar = 1;
-		i830_fill_box( dev, 4, 16, bar, 4, 196, 128, 128 );
+		if (bar > 100)
+			bar = 100;
+		if (bar < 1)
+			bar = 1;
+		i830_fill_box(dev, 4, 16, bar, 4, 196, 128, 128);
 		dev_priv->dma_used = 0;
 	}
 
 	dev_priv->sarea_priv->perf_boxes = 0;
 }
 
-static void i830_dma_dispatch_clear( drm_device_t *dev, int flags, 
+static void i830_dma_dispatch_clear(drm_device_t * dev, int flags,
 				    unsigned int clear_color,
 				    unsigned int clear_zval,
 				    unsigned int clear_depthmask)
 {
-   	drm_i830_private_t *dev_priv = dev->dev_private;
-      	drm_i830_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_i830_private_t *dev_priv = dev->dev_private;
+	drm_i830_sarea_t *sarea_priv = dev_priv->sarea_priv;
 	int nbox = sarea_priv->nbox;
 	drm_clip_rect_t *pbox = sarea_priv->boxes;
 	int pitch = dev_priv->pitch;
@@ -900,90 +892,90 @@ static void i830_dma_dispatch_clear( drm
 	unsigned int BR13, CMD, D_CMD;
 	RING_LOCALS;
 
-
-	if ( dev_priv->current_page == 1 ) {
+	if (dev_priv->current_page == 1) {
 		unsigned int tmp = flags;
 
 		flags &= ~(I830_FRONT | I830_BACK);
-		if ( tmp & I830_FRONT ) flags |= I830_BACK;
-		if ( tmp & I830_BACK )  flags |= I830_FRONT;
+		if (tmp & I830_FRONT)
+			flags |= I830_BACK;
+		if (tmp & I830_BACK)
+			flags |= I830_FRONT;
 	}
 
-  	i830_kernel_lost_context(dev);
+	i830_kernel_lost_context(dev);
 
-	switch(cpp) {
-	case 2: 
-		BR13 = (0xF0 << 16) | (pitch * cpp) | (1<<24);
+	switch (cpp) {
+	case 2:
+		BR13 = (0xF0 << 16) | (pitch * cpp) | (1 << 24);
 		D_CMD = CMD = XY_COLOR_BLT_CMD;
 		break;
 	case 4:
-		BR13 = (0xF0 << 16) | (pitch * cpp) | (1<<24) | (1<<25);
-		CMD = (XY_COLOR_BLT_CMD | XY_COLOR_BLT_WRITE_ALPHA | 
+		BR13 = (0xF0 << 16) | (pitch * cpp) | (1 << 24) | (1 << 25);
+		CMD = (XY_COLOR_BLT_CMD | XY_COLOR_BLT_WRITE_ALPHA |
 		       XY_COLOR_BLT_WRITE_RGB);
 		D_CMD = XY_COLOR_BLT_CMD;
-		if(clear_depthmask & 0x00ffffff)
+		if (clear_depthmask & 0x00ffffff)
 			D_CMD |= XY_COLOR_BLT_WRITE_RGB;
-		if(clear_depthmask & 0xff000000)
+		if (clear_depthmask & 0xff000000)
 			D_CMD |= XY_COLOR_BLT_WRITE_ALPHA;
 		break;
 	default:
-		BR13 = (0xF0 << 16) | (pitch * cpp) | (1<<24);
+		BR13 = (0xF0 << 16) | (pitch * cpp) | (1 << 24);
 		D_CMD = CMD = XY_COLOR_BLT_CMD;
 		break;
 	}
 
-      	if (nbox > I830_NR_SAREA_CLIPRECTS)
-     		nbox = I830_NR_SAREA_CLIPRECTS;
+	if (nbox > I830_NR_SAREA_CLIPRECTS)
+		nbox = I830_NR_SAREA_CLIPRECTS;
 
-	for (i = 0 ; i < nbox ; i++, pbox++) {
+	for (i = 0; i < nbox; i++, pbox++) {
 		if (pbox->x1 > pbox->x2 ||
 		    pbox->y1 > pbox->y2 ||
-		    pbox->x2 > dev_priv->w ||
-		    pbox->y2 > dev_priv->h)
+		    pbox->x2 > dev_priv->w || pbox->y2 > dev_priv->h)
 			continue;
 
-	   	if ( flags & I830_FRONT ) {	    
-		   	DRM_DEBUG("clear front\n");
-			BEGIN_LP_RING( 6 );	    
-			OUT_RING( CMD );
-			OUT_RING( BR13 );
-			OUT_RING( (pbox->y1 << 16) | pbox->x1 );
-			OUT_RING( (pbox->y2 << 16) | pbox->x2 );
-			OUT_RING( dev_priv->front_offset );
-			OUT_RING( clear_color );
+		if (flags & I830_FRONT) {
+			DRM_DEBUG("clear front\n");
+			BEGIN_LP_RING(6);
+			OUT_RING(CMD);
+			OUT_RING(BR13);
+			OUT_RING((pbox->y1 << 16) | pbox->x1);
+			OUT_RING((pbox->y2 << 16) | pbox->x2);
+			OUT_RING(dev_priv->front_offset);
+			OUT_RING(clear_color);
 			ADVANCE_LP_RING();
 		}
 
-		if ( flags & I830_BACK ) {
+		if (flags & I830_BACK) {
 			DRM_DEBUG("clear back\n");
-			BEGIN_LP_RING( 6 );	    
-			OUT_RING( CMD );
-			OUT_RING( BR13 );
-			OUT_RING( (pbox->y1 << 16) | pbox->x1 );
-			OUT_RING( (pbox->y2 << 16) | pbox->x2 );
-			OUT_RING( dev_priv->back_offset );
-			OUT_RING( clear_color );
+			BEGIN_LP_RING(6);
+			OUT_RING(CMD);
+			OUT_RING(BR13);
+			OUT_RING((pbox->y1 << 16) | pbox->x1);
+			OUT_RING((pbox->y2 << 16) | pbox->x2);
+			OUT_RING(dev_priv->back_offset);
+			OUT_RING(clear_color);
 			ADVANCE_LP_RING();
 		}
 
-		if ( flags & I830_DEPTH ) {
+		if (flags & I830_DEPTH) {
 			DRM_DEBUG("clear depth\n");
-			BEGIN_LP_RING( 6 );
-			OUT_RING( D_CMD );
-			OUT_RING( BR13 );
-			OUT_RING( (pbox->y1 << 16) | pbox->x1 );
-			OUT_RING( (pbox->y2 << 16) | pbox->x2 );
-			OUT_RING( dev_priv->depth_offset );
-			OUT_RING( clear_zval );
+			BEGIN_LP_RING(6);
+			OUT_RING(D_CMD);
+			OUT_RING(BR13);
+			OUT_RING((pbox->y1 << 16) | pbox->x1);
+			OUT_RING((pbox->y2 << 16) | pbox->x2);
+			OUT_RING(dev_priv->depth_offset);
+			OUT_RING(clear_zval);
 			ADVANCE_LP_RING();
 		}
 	}
 }
 
-static void i830_dma_dispatch_swap( drm_device_t *dev )
+static void i830_dma_dispatch_swap(drm_device_t * dev)
 {
-   	drm_i830_private_t *dev_priv = dev->dev_private;
-      	drm_i830_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_i830_private_t *dev_priv = dev->dev_private;
+	drm_i830_sarea_t *sarea_priv = dev_priv->sarea_priv;
 	int nbox = sarea_priv->nbox;
 	drm_clip_rect_t *pbox = sarea_priv->boxes;
 	int pitch = dev_priv->pitch;
@@ -994,202 +986,192 @@ static void i830_dma_dispatch_swap( drm_
 
 	DRM_DEBUG("swapbuffers\n");
 
-  	i830_kernel_lost_context(dev);
+	i830_kernel_lost_context(dev);
 
 	if (dev_priv->do_boxes)
-		i830_cp_performance_boxes( dev );
+		i830_cp_performance_boxes(dev);
 
-	switch(cpp) {
-	case 2: 
-		BR13 = (pitch * cpp) | (0xCC << 16) | (1<<24);
+	switch (cpp) {
+	case 2:
+		BR13 = (pitch * cpp) | (0xCC << 16) | (1 << 24);
 		CMD = XY_SRC_COPY_BLT_CMD;
 		break;
 	case 4:
-		BR13 = (pitch * cpp) | (0xCC << 16) | (1<<24) | (1<<25);
+		BR13 = (pitch * cpp) | (0xCC << 16) | (1 << 24) | (1 << 25);
 		CMD = (XY_SRC_COPY_BLT_CMD | XY_SRC_COPY_BLT_WRITE_ALPHA |
 		       XY_SRC_COPY_BLT_WRITE_RGB);
 		break;
 	default:
-		BR13 = (pitch * cpp) | (0xCC << 16) | (1<<24);
+		BR13 = (pitch * cpp) | (0xCC << 16) | (1 << 24);
 		CMD = XY_SRC_COPY_BLT_CMD;
 		break;
 	}
 
+	if (nbox > I830_NR_SAREA_CLIPRECTS)
+		nbox = I830_NR_SAREA_CLIPRECTS;
 
-      	if (nbox > I830_NR_SAREA_CLIPRECTS)
-     		nbox = I830_NR_SAREA_CLIPRECTS;
-
-	for (i = 0 ; i < nbox; i++, pbox++) 
-	{
+	for (i = 0; i < nbox; i++, pbox++) {
 		if (pbox->x1 > pbox->x2 ||
 		    pbox->y1 > pbox->y2 ||
-		    pbox->x2 > dev_priv->w ||
-		    pbox->y2 > dev_priv->h)
+		    pbox->x2 > dev_priv->w || pbox->y2 > dev_priv->h)
 			continue;
- 
+
 		DRM_DEBUG("dispatch swap %d,%d-%d,%d!\n",
-			  pbox->x1, pbox->y1,
-			  pbox->x2, pbox->y2);
+			  pbox->x1, pbox->y1, pbox->x2, pbox->y2);
 
-		BEGIN_LP_RING( 8 );
-		OUT_RING( CMD );
-		OUT_RING( BR13 );
-		OUT_RING( (pbox->y1 << 16) | pbox->x1 );
-		OUT_RING( (pbox->y2 << 16) | pbox->x2 );
+		BEGIN_LP_RING(8);
+		OUT_RING(CMD);
+		OUT_RING(BR13);
+		OUT_RING((pbox->y1 << 16) | pbox->x1);
+		OUT_RING((pbox->y2 << 16) | pbox->x2);
 
-		if (dev_priv->current_page == 0) 
-			OUT_RING( dev_priv->front_offset );
+		if (dev_priv->current_page == 0)
+			OUT_RING(dev_priv->front_offset);
 		else
-			OUT_RING( dev_priv->back_offset );			
+			OUT_RING(dev_priv->back_offset);
 
-		OUT_RING( (pbox->y1 << 16) | pbox->x1 );
-		OUT_RING( BR13 & 0xffff );
+		OUT_RING((pbox->y1 << 16) | pbox->x1);
+		OUT_RING(BR13 & 0xffff);
 
-		if (dev_priv->current_page == 0) 
-			OUT_RING( dev_priv->back_offset );			
+		if (dev_priv->current_page == 0)
+			OUT_RING(dev_priv->back_offset);
 		else
-			OUT_RING( dev_priv->front_offset );
+			OUT_RING(dev_priv->front_offset);
 
 		ADVANCE_LP_RING();
 	}
 }
 
-static void i830_dma_dispatch_flip( drm_device_t *dev )
+static void i830_dma_dispatch_flip(drm_device_t * dev)
 {
-   	drm_i830_private_t *dev_priv = dev->dev_private;
+	drm_i830_private_t *dev_priv = dev->dev_private;
 	RING_LOCALS;
 
-	DRM_DEBUG( "%s: page=%d pfCurrentPage=%d\n", 
-		   __FUNCTION__, 
-		   dev_priv->current_page,
-		   dev_priv->sarea_priv->pf_current_page);
+	DRM_DEBUG("%s: page=%d pfCurrentPage=%d\n",
+		  __FUNCTION__,
+		  dev_priv->current_page,
+		  dev_priv->sarea_priv->pf_current_page);
 
-  	i830_kernel_lost_context(dev);
+	i830_kernel_lost_context(dev);
 
 	if (dev_priv->do_boxes) {
 		dev_priv->sarea_priv->perf_boxes |= I830_BOX_FLIP;
-		i830_cp_performance_boxes( dev );
+		i830_cp_performance_boxes(dev);
 	}
 
-
-	BEGIN_LP_RING( 2 );
-    	OUT_RING( INST_PARSER_CLIENT | INST_OP_FLUSH | INST_FLUSH_MAP_CACHE ); 
-	OUT_RING( 0 );
+	BEGIN_LP_RING(2);
+	OUT_RING(INST_PARSER_CLIENT | INST_OP_FLUSH | INST_FLUSH_MAP_CACHE);
+	OUT_RING(0);
 	ADVANCE_LP_RING();
 
-	BEGIN_LP_RING( 6 );
-	OUT_RING( CMD_OP_DISPLAYBUFFER_INFO | ASYNC_FLIP );	
-	OUT_RING( 0 );
-	if ( dev_priv->current_page == 0 ) {
-		OUT_RING( dev_priv->back_offset );
+	BEGIN_LP_RING(6);
+	OUT_RING(CMD_OP_DISPLAYBUFFER_INFO | ASYNC_FLIP);
+	OUT_RING(0);
+	if (dev_priv->current_page == 0) {
+		OUT_RING(dev_priv->back_offset);
 		dev_priv->current_page = 1;
 	} else {
-		OUT_RING( dev_priv->front_offset );
+		OUT_RING(dev_priv->front_offset);
 		dev_priv->current_page = 0;
 	}
 	OUT_RING(0);
 	ADVANCE_LP_RING();
 
-
-	BEGIN_LP_RING( 2 );
-	OUT_RING( MI_WAIT_FOR_EVENT |
-		  MI_WAIT_FOR_PLANE_A_FLIP );
-	OUT_RING( 0 );
+	BEGIN_LP_RING(2);
+	OUT_RING(MI_WAIT_FOR_EVENT | MI_WAIT_FOR_PLANE_A_FLIP);
+	OUT_RING(0);
 	ADVANCE_LP_RING();
-	
 
 	dev_priv->sarea_priv->pf_current_page = dev_priv->current_page;
 }
 
-static void i830_dma_dispatch_vertex(drm_device_t *dev, 
-				     drm_buf_t *buf,
-				     int discard,
-				     int used)
+static void i830_dma_dispatch_vertex(drm_device_t * dev,
+				     drm_buf_t * buf, int discard, int used)
 {
-   	drm_i830_private_t *dev_priv = dev->dev_private;
+	drm_i830_private_t *dev_priv = dev->dev_private;
 	drm_i830_buf_priv_t *buf_priv = buf->dev_private;
-   	drm_i830_sarea_t *sarea_priv = dev_priv->sarea_priv;
-   	drm_clip_rect_t *box = sarea_priv->boxes;
-   	int nbox = sarea_priv->nbox;
+	drm_i830_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_clip_rect_t *box = sarea_priv->boxes;
+	int nbox = sarea_priv->nbox;
 	unsigned long address = (unsigned long)buf->bus_address;
-	unsigned long start = address - dev->agp->base;     
+	unsigned long start = address - dev->agp->base;
 	int i = 0, u;
-   	RING_LOCALS;
+	RING_LOCALS;
 
-   	i830_kernel_lost_context(dev);
+	i830_kernel_lost_context(dev);
 
-   	if (nbox > I830_NR_SAREA_CLIPRECTS) 
+	if (nbox > I830_NR_SAREA_CLIPRECTS)
 		nbox = I830_NR_SAREA_CLIPRECTS;
 
 	if (discard) {
-		u = cmpxchg(buf_priv->in_use, I830_BUF_CLIENT, 
+		u = cmpxchg(buf_priv->in_use, I830_BUF_CLIENT,
 			    I830_BUF_HARDWARE);
-		if(u != I830_BUF_CLIENT) {
+		if (u != I830_BUF_CLIENT) {
 			DRM_DEBUG("xxxx 2\n");
 		}
 	}
 
-	if (used > 4*1023) 
+	if (used > 4 * 1023)
 		used = 0;
 
 	if (sarea_priv->dirty)
-	   i830EmitState( dev );
+		i830EmitState(dev);
 
-  	DRM_DEBUG("dispatch vertex addr 0x%lx, used 0x%x nbox %d\n", 
+	DRM_DEBUG("dispatch vertex addr 0x%lx, used 0x%x nbox %d\n",
 		  address, used, nbox);
 
-   	dev_priv->counter++;
-   	DRM_DEBUG(  "dispatch counter : %ld\n", dev_priv->counter);
-   	DRM_DEBUG(  "i830_dma_dispatch\n");
-   	DRM_DEBUG(  "start : %lx\n", start);
-	DRM_DEBUG(  "used : %d\n", used);
-   	DRM_DEBUG(  "start + used - 4 : %ld\n", start + used - 4);
+	dev_priv->counter++;
+	DRM_DEBUG("dispatch counter : %ld\n", dev_priv->counter);
+	DRM_DEBUG("i830_dma_dispatch\n");
+	DRM_DEBUG("start : %lx\n", start);
+	DRM_DEBUG("used : %d\n", used);
+	DRM_DEBUG("start + used - 4 : %ld\n", start + used - 4);
 
 	if (buf_priv->currently_mapped == I830_BUF_MAPPED) {
 		u32 *vp = buf_priv->kernel_virtual;
 
 		vp[0] = (GFX_OP_PRIMITIVE |
-			sarea_priv->vertex_prim |
-			((used/4)-2));
+			 sarea_priv->vertex_prim | ((used / 4) - 2));
 
 		if (dev_priv->use_mi_batchbuffer_start) {
-			vp[used/4] = MI_BATCH_BUFFER_END;
-			used += 4; 
+			vp[used / 4] = MI_BATCH_BUFFER_END;
+			used += 4;
 		}
-		
+
 		if (used & 4) {
-			vp[used/4] = 0;
+			vp[used / 4] = 0;
 			used += 4;
 		}
 
 		i830_unmap_buffer(buf);
 	}
-		   
+
 	if (used) {
 		do {
 			if (i < nbox) {
 				BEGIN_LP_RING(6);
-				OUT_RING( GFX_OP_DRAWRECT_INFO );
-				OUT_RING( sarea_priv->BufferState[I830_DESTREG_DR1] );
-				OUT_RING( box[i].x1 | (box[i].y1<<16) );
-				OUT_RING( box[i].x2 | (box[i].y2<<16) );
-				OUT_RING( sarea_priv->BufferState[I830_DESTREG_DR4] );
-				OUT_RING( 0 );
+				OUT_RING(GFX_OP_DRAWRECT_INFO);
+				OUT_RING(sarea_priv->
+					 BufferState[I830_DESTREG_DR1]);
+				OUT_RING(box[i].x1 | (box[i].y1 << 16));
+				OUT_RING(box[i].x2 | (box[i].y2 << 16));
+				OUT_RING(sarea_priv->
+					 BufferState[I830_DESTREG_DR4]);
+				OUT_RING(0);
 				ADVANCE_LP_RING();
 			}
 
 			if (dev_priv->use_mi_batchbuffer_start) {
 				BEGIN_LP_RING(2);
-				OUT_RING( MI_BATCH_BUFFER_START | (2<<6) );
-				OUT_RING( start | MI_BATCH_NON_SECURE );
+				OUT_RING(MI_BATCH_BUFFER_START | (2 << 6));
+				OUT_RING(start | MI_BATCH_NON_SECURE);
 				ADVANCE_LP_RING();
-			} 
-			else {
+			} else {
 				BEGIN_LP_RING(4);
-				OUT_RING( MI_BATCH_BUFFER );
-				OUT_RING( start | MI_BATCH_NON_SECURE );
-				OUT_RING( start + used - 4 );
-				OUT_RING( 0 );
+				OUT_RING(MI_BATCH_BUFFER);
+				OUT_RING(start | MI_BATCH_NON_SECURE);
+				OUT_RING(start + used - 4);
+				OUT_RING(0);
 				ADVANCE_LP_RING();
 			}
 
@@ -1199,61 +1181,60 @@ static void i830_dma_dispatch_vertex(drm
 	if (discard) {
 		dev_priv->counter++;
 
-		(void) cmpxchg(buf_priv->in_use, I830_BUF_CLIENT,
-			       I830_BUF_HARDWARE);
+		(void)cmpxchg(buf_priv->in_use, I830_BUF_CLIENT,
+			      I830_BUF_HARDWARE);
 
 		BEGIN_LP_RING(8);
-		OUT_RING( CMD_STORE_DWORD_IDX );
-		OUT_RING( 20 );
-		OUT_RING( dev_priv->counter );
-		OUT_RING( CMD_STORE_DWORD_IDX );
-		OUT_RING( buf_priv->my_use_idx );
-		OUT_RING( I830_BUF_FREE );
-		OUT_RING( CMD_REPORT_HEAD );
-		OUT_RING( 0 );
+		OUT_RING(CMD_STORE_DWORD_IDX);
+		OUT_RING(20);
+		OUT_RING(dev_priv->counter);
+		OUT_RING(CMD_STORE_DWORD_IDX);
+		OUT_RING(buf_priv->my_use_idx);
+		OUT_RING(I830_BUF_FREE);
+		OUT_RING(CMD_REPORT_HEAD);
+		OUT_RING(0);
 		ADVANCE_LP_RING();
 	}
 }
 
-
-static void i830_dma_quiescent(drm_device_t *dev)
+static void i830_dma_quiescent(drm_device_t * dev)
 {
-      	drm_i830_private_t *dev_priv = dev->dev_private;
-   	RING_LOCALS;
+	drm_i830_private_t *dev_priv = dev->dev_private;
+	RING_LOCALS;
 
-  	i830_kernel_lost_context(dev);
+	i830_kernel_lost_context(dev);
 
-   	BEGIN_LP_RING(4);
-   	OUT_RING( INST_PARSER_CLIENT | INST_OP_FLUSH | INST_FLUSH_MAP_CACHE );
-   	OUT_RING( CMD_REPORT_HEAD );
-      	OUT_RING( 0 );
-      	OUT_RING( 0 );
-   	ADVANCE_LP_RING();
+	BEGIN_LP_RING(4);
+	OUT_RING(INST_PARSER_CLIENT | INST_OP_FLUSH | INST_FLUSH_MAP_CACHE);
+	OUT_RING(CMD_REPORT_HEAD);
+	OUT_RING(0);
+	OUT_RING(0);
+	ADVANCE_LP_RING();
 
-	i830_wait_ring( dev, dev_priv->ring.Size - 8, __FUNCTION__ );
+	i830_wait_ring(dev, dev_priv->ring.Size - 8, __FUNCTION__);
 }
 
-static int i830_flush_queue(drm_device_t *dev)
+static int i830_flush_queue(drm_device_t * dev)
 {
-   	drm_i830_private_t *dev_priv = dev->dev_private;
+	drm_i830_private_t *dev_priv = dev->dev_private;
 	drm_device_dma_t *dma = dev->dma;
-   	int i, ret = 0;
-   	RING_LOCALS;
-	
-   	i830_kernel_lost_context(dev);
-
-   	BEGIN_LP_RING(2);
-      	OUT_RING( CMD_REPORT_HEAD );
-      	OUT_RING( 0 );
-      	ADVANCE_LP_RING();
-
-	i830_wait_ring( dev, dev_priv->ring.Size - 8, __FUNCTION__ );
-
-   	for (i = 0; i < dma->buf_count; i++) {
-	   	drm_buf_t *buf = dma->buflist[ i ];
-	   	drm_i830_buf_priv_t *buf_priv = buf->dev_private;
-	   
-		int used = cmpxchg(buf_priv->in_use, I830_BUF_HARDWARE, 
+	int i, ret = 0;
+	RING_LOCALS;
+
+	i830_kernel_lost_context(dev);
+
+	BEGIN_LP_RING(2);
+	OUT_RING(CMD_REPORT_HEAD);
+	OUT_RING(0);
+	ADVANCE_LP_RING();
+
+	i830_wait_ring(dev, dev_priv->ring.Size - 8, __FUNCTION__);
+
+	for (i = 0; i < dma->buf_count; i++) {
+		drm_buf_t *buf = dma->buflist[i];
+		drm_i830_buf_priv_t *buf_priv = buf->dev_private;
+
+		int used = cmpxchg(buf_priv->in_use, I830_BUF_HARDWARE,
 				   I830_BUF_FREE);
 
 		if (used == I830_BUF_HARDWARE)
@@ -1262,62 +1243,66 @@ static int i830_flush_queue(drm_device_t
 			DRM_DEBUG("still on client\n");
 	}
 
-   	return ret;
+	return ret;
 }
 
 /* Must be called with the lock held */
 void i830_reclaim_buffers(drm_device_t *dev, struct file *filp)
 {
 	drm_device_dma_t *dma = dev->dma;
-	int		 i;
+	int i;
 
-	if (!dma) return;
-      	if (!dev->dev_private) return;
-	if (!dma->buflist) return;
+	if (!dma)
+		return;
+	if (!dev->dev_private)
+		return;
+	if (!dma->buflist)
+		return;
 
-        i830_flush_queue(dev);
+	i830_flush_queue(dev);
 
 	for (i = 0; i < dma->buf_count; i++) {
-	   	drm_buf_t *buf = dma->buflist[ i ];
-	   	drm_i830_buf_priv_t *buf_priv = buf->dev_private;
-	   
+		drm_buf_t *buf = dma->buflist[i];
+		drm_i830_buf_priv_t *buf_priv = buf->dev_private;
+
 		if (buf->filp == filp && buf_priv) {
-			int used = cmpxchg(buf_priv->in_use, I830_BUF_CLIENT, 
+			int used = cmpxchg(buf_priv->in_use, I830_BUF_CLIENT,
 					   I830_BUF_FREE);
 
 			if (used == I830_BUF_CLIENT)
 				DRM_DEBUG("reclaimed from client\n");
-		   	if(buf_priv->currently_mapped == I830_BUF_MAPPED)
-		     		buf_priv->currently_mapped = I830_BUF_UNMAPPED;
+			if (buf_priv->currently_mapped == I830_BUF_MAPPED)
+				buf_priv->currently_mapped = I830_BUF_UNMAPPED;
 		}
 	}
 }
 
-static int i830_flush_ioctl(struct inode *inode, struct file *filp, 
-			     unsigned int cmd, unsigned long arg)
+static int i830_flush_ioctl(struct inode *inode, struct file *filp,
+			    unsigned int cmd, unsigned long arg)
 {
-   	drm_file_t	  *priv	  = filp->private_data;
-   	drm_device_t	  *dev	  = priv->head->dev;
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
 
 	LOCK_TEST_WITH_RETURN(dev, filp);
 
-   	i830_flush_queue(dev);
-   	return 0;
+	i830_flush_queue(dev);
+	return 0;
 }
 
 static int i830_dma_vertex(struct inode *inode, struct file *filp,
-		       unsigned int cmd, unsigned long arg)
+			   unsigned int cmd, unsigned long arg)
 {
 	drm_file_t *priv = filp->private_data;
 	drm_device_t *dev = priv->head->dev;
 	drm_device_dma_t *dma = dev->dma;
-   	drm_i830_private_t *dev_priv = (drm_i830_private_t *)dev->dev_private;
-      	u32 *hw_status = dev_priv->hw_status_page;
-   	drm_i830_sarea_t *sarea_priv = (drm_i830_sarea_t *) 
-     					dev_priv->sarea_priv; 
+	drm_i830_private_t *dev_priv = (drm_i830_private_t *) dev->dev_private;
+	u32 *hw_status = dev_priv->hw_status_page;
+	drm_i830_sarea_t *sarea_priv = (drm_i830_sarea_t *)
+	    dev_priv->sarea_priv;
 	drm_i830_vertex_t vertex;
 
-	if (copy_from_user(&vertex, (drm_i830_vertex_t __user *)arg, sizeof(vertex)))
+	if (copy_from_user
+	    (&vertex, (drm_i830_vertex_t __user *) arg, sizeof(vertex)))
 		return -EFAULT;
 
 	LOCK_TEST_WITH_RETURN(dev, filp);
@@ -1325,15 +1310,16 @@ static int i830_dma_vertex(struct inode 
 	DRM_DEBUG("i830 dma vertex, idx %d used %d discard %d\n",
 		  vertex.idx, vertex.used, vertex.discard);
 
-	if(vertex.idx < 0 || vertex.idx > dma->buf_count) return -EINVAL;
+	if (vertex.idx < 0 || vertex.idx > dma->buf_count)
+		return -EINVAL;
+
+	i830_dma_dispatch_vertex(dev,
+				 dma->buflist[vertex.idx],
+				 vertex.discard, vertex.used);
+
+	sarea_priv->last_enqueue = dev_priv->counter - 1;
+	sarea_priv->last_dispatch = (int)hw_status[5];
 
-	i830_dma_dispatch_vertex( dev, 
-				  dma->buflist[ vertex.idx ], 
-				  vertex.discard, vertex.used );
-
-	sarea_priv->last_enqueue = dev_priv->counter-1;
-   	sarea_priv->last_dispatch = (int) hw_status[5];
-   
 	return 0;
 }
 
@@ -1344,9 +1330,10 @@ static int i830_clear_bufs(struct inode 
 	drm_device_t *dev = priv->head->dev;
 	drm_i830_clear_t clear;
 
-   	if (copy_from_user(&clear, (drm_i830_clear_t __user *)arg, sizeof(clear)))
+	if (copy_from_user
+	    (&clear, (drm_i830_clear_t __user *) arg, sizeof(clear)))
 		return -EFAULT;
-   
+
 	LOCK_TEST_WITH_RETURN(dev, filp);
 
 	/* GH: Someone's doing nasty things... */
@@ -1354,11 +1341,10 @@ static int i830_clear_bufs(struct inode 
 		return -EINVAL;
 	}
 
-	i830_dma_dispatch_clear( dev, clear.flags, 
-				 clear.clear_color, 
-				 clear.clear_depth,
-			         clear.clear_depthmask);
-   	return 0;
+	i830_dma_dispatch_clear(dev, clear.flags,
+				clear.clear_color,
+				clear.clear_depth, clear.clear_depthmask);
+	return 0;
 }
 
 static int i830_swap_bufs(struct inode *inode, struct file *filp,
@@ -1366,20 +1352,18 @@ static int i830_swap_bufs(struct inode *
 {
 	drm_file_t *priv = filp->private_data;
 	drm_device_t *dev = priv->head->dev;
-   
+
 	DRM_DEBUG("i830_swap_bufs\n");
 
 	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	i830_dma_dispatch_swap( dev );
-   	return 0;
+	i830_dma_dispatch_swap(dev);
+	return 0;
 }
 
-
-
 /* Not sure why this isn't set all the time:
- */ 
-static void i830_do_init_pageflip( drm_device_t *dev )
+ */
+static void i830_do_init_pageflip(drm_device_t * dev)
 {
 	drm_i830_private_t *dev_priv = dev->dev_private;
 
@@ -1389,20 +1373,20 @@ static void i830_do_init_pageflip( drm_d
 	dev_priv->sarea_priv->pf_current_page = dev_priv->current_page;
 }
 
-static int i830_do_cleanup_pageflip( drm_device_t *dev )
+static int i830_do_cleanup_pageflip(drm_device_t * dev)
 {
 	drm_i830_private_t *dev_priv = dev->dev_private;
 
 	DRM_DEBUG("%s\n", __FUNCTION__);
 	if (dev_priv->current_page != 0)
-		i830_dma_dispatch_flip( dev );
+		i830_dma_dispatch_flip(dev);
 
 	dev_priv->page_flipping = 0;
 	return 0;
 }
 
 static int i830_flip_bufs(struct inode *inode, struct file *filp,
-			   unsigned int cmd, unsigned long arg)
+			  unsigned int cmd, unsigned long arg)
 {
 	drm_file_t *priv = filp->private_data;
 	drm_device_t *dev = priv->head->dev;
@@ -1412,45 +1396,45 @@ static int i830_flip_bufs(struct inode *
 
 	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	if (!dev_priv->page_flipping) 
-		i830_do_init_pageflip( dev );
+	if (!dev_priv->page_flipping)
+		i830_do_init_pageflip(dev);
 
-	i830_dma_dispatch_flip( dev );
-   	return 0;
+	i830_dma_dispatch_flip(dev);
+	return 0;
 }
 
 static int i830_getage(struct inode *inode, struct file *filp, unsigned int cmd,
-			unsigned long arg)
+		       unsigned long arg)
 {
-   	drm_file_t	  *priv	    = filp->private_data;
-	drm_device_t	  *dev	    = priv->head->dev;
-   	drm_i830_private_t *dev_priv = (drm_i830_private_t *)dev->dev_private;
-      	u32 *hw_status = dev_priv->hw_status_page;
-   	drm_i830_sarea_t *sarea_priv = (drm_i830_sarea_t *) 
-     					dev_priv->sarea_priv; 
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
+	drm_i830_private_t *dev_priv = (drm_i830_private_t *) dev->dev_private;
+	u32 *hw_status = dev_priv->hw_status_page;
+	drm_i830_sarea_t *sarea_priv = (drm_i830_sarea_t *)
+	    dev_priv->sarea_priv;
 
-      	sarea_priv->last_dispatch = (int) hw_status[5];
+	sarea_priv->last_dispatch = (int)hw_status[5];
 	return 0;
 }
 
 static int i830_getbuf(struct inode *inode, struct file *filp, unsigned int cmd,
-			unsigned long arg)
+		       unsigned long arg)
 {
-	drm_file_t	  *priv	    = filp->private_data;
-	drm_device_t	  *dev	    = priv->head->dev;
-	int		  retcode   = 0;
-	drm_i830_dma_t	  d;
-   	drm_i830_private_t *dev_priv = (drm_i830_private_t *)dev->dev_private;
-   	u32 *hw_status = dev_priv->hw_status_page;
-   	drm_i830_sarea_t *sarea_priv = (drm_i830_sarea_t *) 
-     					dev_priv->sarea_priv; 
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
+	int retcode = 0;
+	drm_i830_dma_t d;
+	drm_i830_private_t *dev_priv = (drm_i830_private_t *) dev->dev_private;
+	u32 *hw_status = dev_priv->hw_status_page;
+	drm_i830_sarea_t *sarea_priv = (drm_i830_sarea_t *)
+	    dev_priv->sarea_priv;
 
 	DRM_DEBUG("getbuf\n");
-   	if (copy_from_user(&d, (drm_i830_dma_t __user *)arg, sizeof(d)))
+	if (copy_from_user(&d, (drm_i830_dma_t __user *) arg, sizeof(d)))
 		return -EFAULT;
-   
+
 	LOCK_TEST_WITH_RETURN(dev, filp);
-	
+
 	d.granted = 0;
 
 	retcode = i830_dma_get_buffer(dev, &d, filp);
@@ -1458,46 +1442,45 @@ static int i830_getbuf(struct inode *ino
 	DRM_DEBUG("i830_dma: %d returning %d, granted = %d\n",
 		  current->pid, retcode, d.granted);
 
-	if (copy_to_user((drm_dma_t __user *)arg, &d, sizeof(d)))
+	if (copy_to_user((drm_dma_t __user *) arg, &d, sizeof(d)))
 		return -EFAULT;
-   	sarea_priv->last_dispatch = (int) hw_status[5];
+	sarea_priv->last_dispatch = (int)hw_status[5];
 
 	return retcode;
 }
 
 static int i830_copybuf(struct inode *inode,
-			 struct file *filp, unsigned int cmd, unsigned long arg)
+			struct file *filp, unsigned int cmd, unsigned long arg)
 {
 	/* Never copy - 2.4.x doesn't need it */
 	return 0;
 }
 
 static int i830_docopy(struct inode *inode, struct file *filp, unsigned int cmd,
-			unsigned long arg)
+		unsigned long arg)
 {
 	return 0;
 }
 
-
-
-static int i830_getparam( struct inode *inode, struct file *filp, 
-			unsigned int cmd, unsigned long arg )
+static int i830_getparam(struct inode *inode, struct file *filp, 
+			 unsigned int cmd, unsigned long arg)
 {
-	drm_file_t	  *priv	    = filp->private_data;
-	drm_device_t	  *dev	    = priv->head->dev;
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
 	drm_i830_private_t *dev_priv = dev->dev_private;
 	drm_i830_getparam_t param;
 	int value;
 
-	if ( !dev_priv ) {
-		DRM_ERROR( "%s called with no initialization\n", __FUNCTION__ );
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
 		return -EINVAL;
 	}
 
-	if (copy_from_user(&param, (drm_i830_getparam_t __user *)arg, sizeof(param) ))
+	if (copy_from_user
+	    (&param, (drm_i830_getparam_t __user *) arg, sizeof(param)))
 		return -EFAULT;
 
-	switch( param.param ) {
+	switch (param.param) {
 	case I830_PARAM_IRQ_ACTIVE:
 		value = dev->irq_enabled;
 		break;
@@ -1505,32 +1488,32 @@ static int i830_getparam( struct inode *
 		return -EINVAL;
 	}
 
-	if ( copy_to_user( param.value, &value, sizeof(int) ) ) {
-		DRM_ERROR( "copy_to_user\n" );
+	if (copy_to_user(param.value, &value, sizeof(int))) {
+		DRM_ERROR("copy_to_user\n");
 		return -EFAULT;
 	}
-	
+
 	return 0;
 }
 
-
-static int i830_setparam( struct inode *inode, struct file *filp,
-			unsigned int cmd, unsigned long arg )
+static int i830_setparam(struct inode *inode, struct file *filp,
+			 unsigned int cmd, unsigned long arg)
 {
-	drm_file_t	  *priv	    = filp->private_data;
-	drm_device_t	  *dev	    = priv->head->dev;
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
 	drm_i830_private_t *dev_priv = dev->dev_private;
 	drm_i830_setparam_t param;
 
-	if ( !dev_priv ) {
-		DRM_ERROR( "%s called with no initialization\n", __FUNCTION__ );
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
 		return -EINVAL;
 	}
 
-	if (copy_from_user(&param, (drm_i830_setparam_t __user *)arg, sizeof(param) ))
+	if (copy_from_user
+	    (&param, (drm_i830_setparam_t __user *) arg, sizeof(param)))
 		return -EFAULT;
 
-	switch( param.param ) {
+	switch (param.param) {
 	case I830_SETPARAM_USE_MI_BATCHBUFFER_START:
 		dev_priv->use_mi_batchbuffer_start = param.value;
 		break;
@@ -1541,13 +1524,12 @@ static int i830_setparam( struct inode *
 	return 0;
 }
 
-
-void i830_driver_pretakedown(drm_device_t *dev)
+void i830_driver_pretakedown(drm_device_t * dev)
 {
-	i830_dma_cleanup( dev );
+	i830_dma_cleanup(dev);
 }
 
-void i830_driver_prerelease(drm_device_t *dev, DRMFILE filp)
+void i830_driver_prerelease(drm_device_t * dev, DRMFILE filp)
 {
 	if (dev->dev_private) {
 		drm_i830_private_t *dev_priv = dev->dev_private;
@@ -1557,32 +1539,48 @@ void i830_driver_prerelease(drm_device_t
 	}
 }
 
-void i830_driver_release(drm_device_t *dev, struct file *filp)
+void i830_driver_release(drm_device_t * dev, struct file *filp)
 {
 	i830_reclaim_buffers(dev, filp);
 }
 
-int i830_driver_dma_quiescent(drm_device_t *dev)
+int i830_driver_dma_quiescent(drm_device_t * dev)
 {
-	i830_dma_quiescent( dev );
+	i830_dma_quiescent(dev);
 	return 0;
 }
 
 drm_ioctl_desc_t i830_ioctls[] = {
-	[DRM_IOCTL_NR(DRM_I830_INIT)]     = { i830_dma_init,    1, 1 },
-	[DRM_IOCTL_NR(DRM_I830_VERTEX)]   = { i830_dma_vertex,  1, 0 },
-	[DRM_IOCTL_NR(DRM_I830_CLEAR)]    = { i830_clear_bufs,  1, 0 },
-	[DRM_IOCTL_NR(DRM_I830_FLUSH)]    = { i830_flush_ioctl, 1, 0 },
-	[DRM_IOCTL_NR(DRM_I830_GETAGE)]   = { i830_getage,      1, 0 },
-	[DRM_IOCTL_NR(DRM_I830_GETBUF)]   = { i830_getbuf,      1, 0 },
-	[DRM_IOCTL_NR(DRM_I830_SWAP)]     = { i830_swap_bufs,   1, 0 },
-	[DRM_IOCTL_NR(DRM_I830_COPY)]     = { i830_copybuf,     1, 0 },
-	[DRM_IOCTL_NR(DRM_I830_DOCOPY)]   = { i830_docopy,      1, 0 },
-	[DRM_IOCTL_NR(DRM_I830_FLIP)]     = { i830_flip_bufs,   1, 0 },
-	[DRM_IOCTL_NR(DRM_I830_IRQ_EMIT)] = { i830_irq_emit,    1, 0 },
-	[DRM_IOCTL_NR(DRM_I830_IRQ_WAIT)] = { i830_irq_wait,    1, 0 },
-	[DRM_IOCTL_NR(DRM_I830_GETPARAM)] = { i830_getparam,    1, 0 },
-	[DRM_IOCTL_NR(DRM_I830_SETPARAM)] = { i830_setparam,    1, 0 } 
+	[DRM_IOCTL_NR(DRM_I830_INIT)] = {i830_dma_init, 1, 1},
+	[DRM_IOCTL_NR(DRM_I830_VERTEX)] = {i830_dma_vertex, 1, 0},
+	[DRM_IOCTL_NR(DRM_I830_CLEAR)] = {i830_clear_bufs, 1, 0},
+	[DRM_IOCTL_NR(DRM_I830_FLUSH)] = {i830_flush_ioctl, 1, 0},
+	[DRM_IOCTL_NR(DRM_I830_GETAGE)] = {i830_getage, 1, 0},
+	[DRM_IOCTL_NR(DRM_I830_GETBUF)] = {i830_getbuf, 1, 0},
+	[DRM_IOCTL_NR(DRM_I830_SWAP)] = {i830_swap_bufs, 1, 0},
+	[DRM_IOCTL_NR(DRM_I830_COPY)] = {i830_copybuf, 1, 0},
+	[DRM_IOCTL_NR(DRM_I830_DOCOPY)] = {i830_docopy, 1, 0},
+	[DRM_IOCTL_NR(DRM_I830_FLIP)] = {i830_flip_bufs, 1, 0},
+	[DRM_IOCTL_NR(DRM_I830_IRQ_EMIT)] = {i830_irq_emit, 1, 0},
+	[DRM_IOCTL_NR(DRM_I830_IRQ_WAIT)] = {i830_irq_wait, 1, 0},
+	[DRM_IOCTL_NR(DRM_I830_GETPARAM)] = {i830_getparam, 1, 0},
+	[DRM_IOCTL_NR(DRM_I830_SETPARAM)] = {i830_setparam, 1, 0}
 };
 
 int i830_max_ioctl = DRM_ARRAY_SIZE(i830_ioctls);
+
+/**
+ * Determine if the device really is AGP or not.
+ *
+ * All Intel graphics chipsets are treated as AGP, even if they are really
+ * PCI-e.
+ *
+ * \param dev   The device to be tested.
+ *
+ * \returns
+ * A value of 1 is always retured to indictate every i8xx is AGP.
+ */
+int i830_driver_device_is_agp(drm_device_t * dev)
+{
+	return 1;
+}
diff -purN linux-2.6.12.orig/drivers/char/drm/i830_drm.h linux-2.6.12/drivers/char/drm/i830_drm.h
--- linux-2.6.12.orig/drivers/char/drm/i830_drm.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/i830_drm.h	2005-07-05 08:37:30.000000000 +0200
@@ -33,21 +33,21 @@
 #define I830_UPLOAD_CTX			0x1
 #define I830_UPLOAD_BUFFERS		0x2
 #define I830_UPLOAD_CLIPRECTS		0x4
-#define I830_UPLOAD_TEX0_IMAGE		0x100 /* handled clientside */
-#define I830_UPLOAD_TEX0_CUBE		0x200 /* handled clientside */
-#define I830_UPLOAD_TEX1_IMAGE		0x400 /* handled clientside */
-#define I830_UPLOAD_TEX1_CUBE		0x800 /* handled clientside */
-#define I830_UPLOAD_TEX2_IMAGE		0x1000 /* handled clientside */
-#define I830_UPLOAD_TEX2_CUBE		0x2000 /* handled clientside */
-#define I830_UPLOAD_TEX3_IMAGE		0x4000 /* handled clientside */
-#define I830_UPLOAD_TEX3_CUBE		0x8000 /* handled clientside */
+#define I830_UPLOAD_TEX0_IMAGE		0x100	/* handled clientside */
+#define I830_UPLOAD_TEX0_CUBE		0x200	/* handled clientside */
+#define I830_UPLOAD_TEX1_IMAGE		0x400	/* handled clientside */
+#define I830_UPLOAD_TEX1_CUBE		0x800	/* handled clientside */
+#define I830_UPLOAD_TEX2_IMAGE		0x1000	/* handled clientside */
+#define I830_UPLOAD_TEX2_CUBE		0x2000	/* handled clientside */
+#define I830_UPLOAD_TEX3_IMAGE		0x4000	/* handled clientside */
+#define I830_UPLOAD_TEX3_CUBE		0x8000	/* handled clientside */
 #define I830_UPLOAD_TEX_N_IMAGE(n)	(0x100 << (n * 2))
 #define I830_UPLOAD_TEX_N_CUBE(n)	(0x200 << (n * 2))
 #define I830_UPLOAD_TEXIMAGE_MASK	0xff00
-#define I830_UPLOAD_TEX0			0x10000
-#define I830_UPLOAD_TEX1			0x20000
-#define I830_UPLOAD_TEX2			0x40000
-#define I830_UPLOAD_TEX3			0x80000
+#define I830_UPLOAD_TEX0		0x10000
+#define I830_UPLOAD_TEX1		0x20000
+#define I830_UPLOAD_TEX2		0x40000
+#define I830_UPLOAD_TEX3		0x80000
 #define I830_UPLOAD_TEX_N(n)		(0x10000 << (n))
 #define I830_UPLOAD_TEX_MASK		0xf0000
 #define I830_UPLOAD_TEXBLEND0		0x100000
@@ -65,7 +65,7 @@
  * or in a piecewise fashion as required.
  */
 
-/* Destbuffer state 
+/* Destbuffer state
  *    - backbuffer linear offset and pitch -- invarient in the current dri
  *    - zbuffer linear offset and pitch -- also invarient
  *    - drawing origin in back and depth buffers.
@@ -103,7 +103,7 @@
 #define I830_CTXREG_AA			9
 #define I830_CTXREG_FOGCOLOR		10
 #define I830_CTXREG_BLENDCOLR0		11
-#define I830_CTXREG_BLENDCOLR		12 /* Dword 1 of 2 dword command */
+#define I830_CTXREG_BLENDCOLR		12	/* Dword 1 of 2 dword command */
 #define I830_CTXREG_VF			13
 #define I830_CTXREG_VF2			14
 #define I830_CTXREG_MCSB0		15
@@ -111,12 +111,11 @@
 #define I830_CTX_SETUP_SIZE		17
 
 /* 1.3: Stipple state
- */ 
+ */
 #define I830_STPREG_ST0 0
 #define I830_STPREG_ST1 1
 #define I830_STP_SETUP_SIZE 2
 
-
 /* Texture state (per tex unit)
  */
 
@@ -132,23 +131,23 @@
 #define I830_TEXREG_MCS	9	/* GFX_OP_MAP_COORD_SETS */
 #define I830_TEX_SETUP_SIZE 10
 
-#define I830_TEXREG_TM0LI      0 /* load immediate 2 texture map n */
+#define I830_TEXREG_TM0LI      0	/* load immediate 2 texture map n */
 #define I830_TEXREG_TM0S0      1
 #define I830_TEXREG_TM0S1      2
 #define I830_TEXREG_TM0S2      3
 #define I830_TEXREG_TM0S3      4
 #define I830_TEXREG_TM0S4      5
-#define I830_TEXREG_NOP0       6       /* noop */
-#define I830_TEXREG_NOP1       7       /* noop */
-#define I830_TEXREG_NOP2       8       /* noop */
-#define __I830_TEXREG_MCS      9       /* GFX_OP_MAP_COORD_SETS -- shared */
+#define I830_TEXREG_NOP0       6	/* noop */
+#define I830_TEXREG_NOP1       7	/* noop */
+#define I830_TEXREG_NOP2       8	/* noop */
+#define __I830_TEXREG_MCS      9	/* GFX_OP_MAP_COORD_SETS -- shared */
 #define __I830_TEX_SETUP_SIZE   10
 
 #define I830_FRONT   0x1
 #define I830_BACK    0x2
 #define I830_DEPTH   0x4
 
-#endif /* _I830_DEFINES_ */
+#endif				/* _I830_DEFINES_ */
 
 typedef struct _drm_i830_init {
 	enum {
@@ -177,19 +176,19 @@ typedef struct _drm_i830_init {
  * structure as well */
 
 typedef struct _drm_i830_tex_region {
-	unsigned char next, prev; /* indices to form a circular LRU  */
+	unsigned char next, prev;	/* indices to form a circular LRU  */
 	unsigned char in_use;	/* owned by a client, or free? */
 	int age;		/* tracked by clients to update local LRU's */
 } drm_i830_tex_region_t;
 
 typedef struct _drm_i830_sarea {
 	unsigned int ContextState[I830_CTX_SETUP_SIZE];
-   	unsigned int BufferState[I830_DEST_SETUP_SIZE];
+	unsigned int BufferState[I830_DEST_SETUP_SIZE];
 	unsigned int TexState[I830_TEXTURE_COUNT][I830_TEX_SETUP_SIZE];
 	unsigned int TexBlendState[I830_TEXBLEND_COUNT][I830_TEXBLEND_SIZE];
 	unsigned int TexBlendStateWordsUsed[I830_TEXBLEND_COUNT];
 	unsigned int Palette[2][256];
-   	unsigned int dirty;
+	unsigned int dirty;
 
 	unsigned int nbox;
 	drm_clip_rect_t boxes[I830_NR_SAREA_CLIPRECTS];
@@ -207,26 +206,26 @@ typedef struct _drm_i830_sarea {
 	 * texture space, and can make informed decisions as to which
 	 * areas to kick out.  There is no need to choose whether to
 	 * kick out your own texture or someone else's - simply eject
-	 * them all in LRU order.  
+	 * them all in LRU order.
 	 */
 
-	drm_i830_tex_region_t texList[I830_NR_TEX_REGIONS+1]; 
-				/* Last elt is sentinal */
-        int texAge;		/* last time texture was uploaded */
-        int last_enqueue;	/* last time a buffer was enqueued */
+	drm_i830_tex_region_t texList[I830_NR_TEX_REGIONS + 1];
+	/* Last elt is sentinal */
+	int texAge;		/* last time texture was uploaded */
+	int last_enqueue;	/* last time a buffer was enqueued */
 	int last_dispatch;	/* age of the most recently dispatched buffer */
-	int last_quiescent;     /*  */
+	int last_quiescent;	/*  */
 	int ctxOwner;		/* last context to upload state */
 
 	int vertex_prim;
 
-        int pf_enabled;               /* is pageflipping allowed? */
-        int pf_active;               
-        int pf_current_page;	    /* which buffer is being displayed? */
-
-        int perf_boxes;             /* performance boxes to be displayed */
-   
-        /* Here's the state for texunits 2,3:
+	int pf_enabled;		/* is pageflipping allowed? */
+	int pf_active;
+	int pf_current_page;	/* which buffer is being displayed? */
+
+	int perf_boxes;		/* performance boxes to be displayed */
+
+	/* Here's the state for texunits 2,3:
 	 */
 	unsigned int TexState2[I830_TEX_SETUP_SIZE];
 	unsigned int TexBlendState2[I830_TEXBLEND_SIZE];
@@ -241,26 +240,25 @@ typedef struct _drm_i830_sarea {
 
 /* Flags for perf_boxes
  */
-#define I830_BOX_RING_EMPTY    0x1 /* populated by kernel */
-#define I830_BOX_FLIP          0x2 /* populated by kernel */
-#define I830_BOX_WAIT          0x4 /* populated by kernel & client */
-#define I830_BOX_TEXTURE_LOAD  0x8 /* populated by kernel */
-#define I830_BOX_LOST_CONTEXT  0x10 /* populated by client */
-
+#define I830_BOX_RING_EMPTY    0x1	/* populated by kernel */
+#define I830_BOX_FLIP          0x2	/* populated by kernel */
+#define I830_BOX_WAIT          0x4	/* populated by kernel & client */
+#define I830_BOX_TEXTURE_LOAD  0x8	/* populated by kernel */
+#define I830_BOX_LOST_CONTEXT  0x10	/* populated by client */
 
 /* I830 specific ioctls
  * The device specific ioctl range is 0x40 to 0x79.
  */
-#define DRM_I830_INIT	0x00
-#define DRM_I830_VERTEX	0x01
-#define DRM_I830_CLEAR	0x02
-#define DRM_I830_FLUSH	0x03
-#define DRM_I830_GETAGE	0x04
-#define DRM_I830_GETBUF	0x05
-#define DRM_I830_SWAP	0x06
-#define DRM_I830_COPY	0x07
-#define DRM_I830_DOCOPY	0x08
-#define DRM_I830_FLIP	0x09
+#define DRM_I830_INIT		0x00
+#define DRM_I830_VERTEX		0x01
+#define DRM_I830_CLEAR		0x02
+#define DRM_I830_FLUSH		0x03
+#define DRM_I830_GETAGE		0x04
+#define DRM_I830_GETBUF		0x05
+#define DRM_I830_SWAP		0x06
+#define DRM_I830_COPY		0x07
+#define DRM_I830_DOCOPY		0x08
+#define DRM_I830_FLIP		0x09
 #define DRM_I830_IRQ_EMIT	0x0a
 #define DRM_I830_IRQ_WAIT	0x0b
 #define DRM_I830_GETPARAM	0x0c
@@ -289,23 +287,21 @@ typedef struct _drm_i830_clear {
 	unsigned int clear_depthmask;
 } drm_i830_clear_t;
 
-
-
 /* These may be placeholders if we have more cliprects than
  * I830_NR_SAREA_CLIPRECTS.  In that case, the client sets discard to
  * false, indicating that the buffer will be dispatched again with a
  * new set of cliprects.
  */
 typedef struct _drm_i830_vertex {
-   	int idx;		/* buffer index */
+	int idx;		/* buffer index */
 	int used;		/* nr bytes in use */
 	int discard;		/* client is finished with the buffer? */
 } drm_i830_vertex_t;
 
 typedef struct _drm_i830_copy_t {
-   	int idx;		/* buffer index */
+	int idx;		/* buffer index */
 	int used;		/* nr bytes in use */
-	void __user *address;		/* Address to copy from */
+	void __user *address;	/* Address to copy from */
 } drm_i830_copy_t;
 
 typedef struct drm_i830_dma {
@@ -315,7 +311,6 @@ typedef struct drm_i830_dma {
 	int granted;
 } drm_i830_dma_t;
 
-
 /* 1.3: Userspace can request & wait on irq's:
  */
 typedef struct drm_i830_irq_emit {
@@ -326,7 +321,6 @@ typedef struct drm_i830_irq_wait {
 	int irq_seq;
 } drm_i830_irq_wait_t;
 
-
 /* 1.3: New ioctl to query kernel params:
  */
 #define I830_PARAM_IRQ_ACTIVE            1
@@ -336,7 +330,6 @@ typedef struct drm_i830_getparam {
 	int __user *value;
 } drm_i830_getparam_t;
 
-
 /* 1.3: New ioctl to set kernel params:
  */
 #define I830_SETPARAM_USE_MI_BATCHBUFFER_START            1
@@ -346,5 +339,4 @@ typedef struct drm_i830_setparam {
 	int value;
 } drm_i830_setparam_t;
 
-
-#endif /* _I830_DRM_H_ */
+#endif				/* _I830_DRM_H_ */
diff -purN linux-2.6.12.orig/drivers/char/drm/i830_drv.c linux-2.6.12/drivers/char/drm/i830_drv.c
--- linux-2.6.12.orig/drivers/char/drm/i830_drv.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/i830_drv.c	2005-07-05 08:37:27.000000000 +0200
@@ -33,6 +33,7 @@
  */
 
 #include <linux/config.h>
+
 #include "drmP.h"
 #include "drm.h"
 #include "i830_drm.h"
@@ -40,36 +41,34 @@
 
 #include "drm_pciids.h"
 
-int postinit( struct drm_device *dev, unsigned long flags )
+int postinit(struct drm_device *dev, unsigned long flags)
 {
 	dev->counters += 4;
 	dev->types[6] = _DRM_STAT_IRQ;
 	dev->types[7] = _DRM_STAT_PRIMARY;
 	dev->types[8] = _DRM_STAT_SECONDARY;
 	dev->types[9] = _DRM_STAT_DMA;
-	
-	DRM_INFO( "Initialized %s %d.%d.%d %s on minor %d: %s\n",
-		DRIVER_NAME,
-		DRIVER_MAJOR,
-		DRIVER_MINOR,
-		DRIVER_PATCHLEVEL,
-		DRIVER_DATE,
-		dev->primary.minor,
-		pci_pretty_name(dev->pdev)
-		);
+
+	DRM_INFO("Initialized %s %d.%d.%d %s on minor %d: %s\n",
+		 DRIVER_NAME,
+		 DRIVER_MAJOR,
+		 DRIVER_MINOR,
+		 DRIVER_PATCHLEVEL,
+		 DRIVER_DATE, dev->primary.minor, pci_pretty_name(dev->pdev)
+	    );
 	return 0;
 }
 
-static int version( drm_version_t *version )
+static int version(drm_version_t * version)
 {
 	int len;
 
 	version->version_major = DRIVER_MAJOR;
 	version->version_minor = DRIVER_MINOR;
 	version->version_patchlevel = DRIVER_PATCHLEVEL;
-	DRM_COPY( version->name, DRIVER_NAME );
-	DRM_COPY( version->date, DRIVER_DATE );
-	DRM_COPY( version->desc, DRIVER_DESC );
+	DRM_COPY(version->name, DRIVER_NAME);
+	DRM_COPY(version->date, DRIVER_DATE);
+	DRM_COPY(version->desc, DRIVER_DESC);
 	return 0;
 }
 
@@ -80,17 +79,20 @@ static struct pci_device_id pciidlist[] 
 extern drm_ioctl_desc_t i830_ioctls[];
 extern int i830_max_ioctl;
 
+static int probe(struct pci_dev *pdev, const struct pci_device_id *ent);
 static struct drm_driver driver = {
-	.driver_features = DRIVER_USE_AGP | DRIVER_REQUIRE_AGP | DRIVER_USE_MTRR | DRIVER_HAVE_DMA | DRIVER_DMA_QUEUE,
+	.driver_features =
+	    DRIVER_USE_AGP | DRIVER_REQUIRE_AGP | DRIVER_USE_MTRR |
+	    DRIVER_HAVE_DMA | DRIVER_DMA_QUEUE,
 #if USE_IRQS
 	.driver_features |= DRIVER_HAVE_IRQ | DRIVER_SHARED_IRQ,
 #endif
 	.dev_priv_size = sizeof(drm_i830_buf_priv_t),
 	.pretakedown = i830_driver_pretakedown,
 	.prerelease = i830_driver_prerelease,
+	.device_is_agp = i830_driver_device_is_agp,
 	.release = i830_driver_release,
 	.dma_quiescent = i830_driver_dma_quiescent,
-	.reclaim_buffers = i830_reclaim_buffers,
 	.get_map_ofs = drm_core_get_map_ofs,
 	.get_reg_ofs = drm_core_get_reg_ofs,
 #if USE_IRQS
@@ -110,18 +112,25 @@ static struct drm_driver driver = {
 		.mmap = drm_mmap,
 		.poll = drm_poll,
 		.fasync = drm_fasync,
-	},
+		},
 	.pci_driver = {
-		.name          = DRIVER_NAME,
-		.id_table      = pciidlist,
+		.name = DRIVER_NAME,
+		.id_table = pciidlist,
+		.probe = probe,
+		.remove = __devexit_p(drm_cleanup_pci),
 	}
-
 };
 
+static int probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	return drm_get_dev(pdev, ent, &driver);
+}
+
+
 static int __init i830_init(void)
 {
 	driver.num_ioctls = i830_max_ioctl;
-	return drm_init(&driver);
+	return drm_init(&driver, pciidlist);
 }
 
 static void __exit i830_exit(void)
@@ -132,6 +141,6 @@ static void __exit i830_exit(void)
 module_init(i830_init);
 module_exit(i830_exit);
 
-MODULE_AUTHOR( DRIVER_AUTHOR );
-MODULE_DESCRIPTION( DRIVER_DESC );
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL and additional rights");
diff -purN linux-2.6.12.orig/drivers/char/drm/i830_drv.h linux-2.6.12/drivers/char/drm/i830_drv.h
--- linux-2.6.12.orig/drivers/char/drm/i830_drv.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/i830_drv.h	2005-07-05 08:37:30.000000000 +0200
@@ -11,11 +11,11 @@
  * the rights to use, copy, modify, merge, publish, distribute, sublicense,
  * and/or sell copies of the Software, and to permit persons to whom the
  * Software is furnished to do so, subject to the following conditions:
- * 
+ *
  * The above copyright notice and this permission notice (including the next
  * paragraph) shall be included in all copies or substantial portions of the
  * Software.
- * 
+ *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
@@ -63,14 +63,14 @@
 #define USE_IRQS 0
 
 typedef struct drm_i830_buf_priv {
-   	u32 *in_use;
-   	int my_use_idx;
+	u32 *in_use;
+	int my_use_idx;
 	int currently_mapped;
 	void __user *virtual;
 	void *kernel_virtual;
 } drm_i830_buf_priv_t;
 
-typedef struct _drm_i830_ring_buffer{
+typedef struct _drm_i830_ring_buffer {
 	int tail_mask;
 	unsigned long Start;
 	unsigned long End;
@@ -86,17 +86,17 @@ typedef struct drm_i830_private {
 	drm_map_t *mmio_map;
 
 	drm_i830_sarea_t *sarea_priv;
-   	drm_i830_ring_buffer_t ring;
+	drm_i830_ring_buffer_t ring;
 
-      	void * hw_status_page;
-   	unsigned long counter;
+	void *hw_status_page;
+	unsigned long counter;
 
 	dma_addr_t dma_status_page;
 
 	drm_buf_t *mmap_buffer;
-	
+
 	u32 front_di1, back_di1, zi1;
-	
+
 	int back_offset;
 	int depth_offset;
 	int front_offset;
@@ -113,8 +113,8 @@ typedef struct drm_i830_private {
 	int page_flipping;
 
 	wait_queue_head_t irq_queue;
-   	atomic_t irq_received;
-   	atomic_t irq_emitted;
+	atomic_t irq_received;
+	atomic_t irq_emitted;
 
 	int use_mi_batchbuffer_start;
 
@@ -123,22 +123,21 @@ typedef struct drm_i830_private {
 /* i830_dma.c */
 extern void i830_reclaim_buffers(drm_device_t *dev, struct file *filp);
 
-extern int i830_mmap_buffers(struct file *filp, struct vm_area_struct *vma);
-
 /* i830_irq.c */
-extern int i830_irq_emit( struct inode *inode, struct file *filp, 
-			  unsigned int cmd, unsigned long arg );
-extern int i830_irq_wait( struct inode *inode, struct file *filp,
-			  unsigned int cmd, unsigned long arg );
-
-extern irqreturn_t i830_driver_irq_handler( DRM_IRQ_ARGS );
-extern void i830_driver_irq_preinstall( drm_device_t *dev );
-extern void i830_driver_irq_postinstall( drm_device_t *dev );
-extern void i830_driver_irq_uninstall( drm_device_t *dev );
-extern void i830_driver_pretakedown(drm_device_t *dev);
-extern void i830_driver_release(drm_device_t *dev, struct file *filp);
-extern int i830_driver_dma_quiescent(drm_device_t *dev);
-extern void i830_driver_prerelease(drm_device_t *dev, DRMFILE filp);
+extern int i830_irq_emit(struct inode *inode, struct file *filp,
+			 unsigned int cmd, unsigned long arg);
+extern int i830_irq_wait(struct inode *inode, struct file *filp,
+			 unsigned int cmd, unsigned long arg);
+
+extern irqreturn_t i830_driver_irq_handler(DRM_IRQ_ARGS);
+extern void i830_driver_irq_preinstall(drm_device_t * dev);
+extern void i830_driver_irq_postinstall(drm_device_t * dev);
+extern void i830_driver_irq_uninstall(drm_device_t * dev);
+extern void i830_driver_pretakedown(drm_device_t * dev);
+extern void i830_driver_release(drm_device_t * dev, struct file *filp);
+extern int i830_driver_dma_quiescent(drm_device_t * dev);
+extern void i830_driver_prerelease(drm_device_t * dev, DRMFILE filp);
+extern int i830_driver_device_is_agp(drm_device_t * dev);
 
 #define I830_BASE(reg)		((unsigned long) \
 				dev_priv->mmio_map->handle)
@@ -150,8 +149,6 @@ extern void i830_driver_prerelease(drm_d
 #define I830_READ16(reg) 	I830_DEREF16(reg)
 #define I830_WRITE16(reg,val)	do { I830_DEREF16(reg) = val; } while (0)
 
-
-
 #define I830_VERBOSE 0
 
 #define RING_LOCALS	unsigned int outring, ringmask, outcount; \
@@ -169,7 +166,6 @@ extern void i830_driver_prerelease(drm_d
 	virt = dev_priv->ring.virtual_start;		\
 } while (0)
 
-
 #define OUT_RING(n) do {					\
 	if (I830_VERBOSE) printk("   OUT_RING %x\n", (int)(n));	\
 	*(volatile unsigned int *)(virt + outring) = n;		\
@@ -185,8 +181,7 @@ extern void i830_driver_prerelease(drm_d
 	I830_WRITE(LP_RING + RING_TAIL, outring);			\
 } while(0)
 
-extern int i830_wait_ring(drm_device_t *dev, int n, const char *caller);
-
+extern int i830_wait_ring(drm_device_t * dev, int n, const char *caller);
 
 #define GFX_OP_USER_INTERRUPT 		((0<<29)|(2<<23))
 #define GFX_OP_BREAKPOINT_INTERRUPT	((0<<29)|(1<<23))
@@ -201,7 +196,6 @@ extern int i830_wait_ring(drm_device_t *
 #define INST_OP_FLUSH        0x02000000
 #define INST_FLUSH_MAP_CACHE 0x00000001
 
-
 #define BB1_START_ADDR_MASK   (~0x7)
 #define BB1_PROTECTED         (1<<0)
 #define BB1_UNPROTECTED       (0<<0)
@@ -214,7 +208,6 @@ extern int i830_wait_ring(drm_device_t *
 
 #define I830_IRQ_RESERVED ((1<<13)|(3<<2))
 
-
 #define LP_RING     		0x2030
 #define HP_RING     		0x2040
 #define RING_TAIL      		0x00
@@ -226,7 +219,7 @@ extern int i830_wait_ring(drm_device_t *
 #define RING_START     		0x08
 #define START_ADDR          	0x0xFFFFF000
 #define RING_LEN       		0x0C
-#define RING_NR_PAGES       	0x001FF000 
+#define RING_NR_PAGES       	0x001FF000
 #define RING_REPORT_MASK    	0x00000006
 #define RING_REPORT_64K     	0x00000002
 #define RING_REPORT_128K    	0x00000004
@@ -292,10 +285,9 @@ extern int i830_wait_ring(drm_device_t *
 #define MI_BATCH_NON_SECURE	(1)
 
 #define MI_WAIT_FOR_EVENT       ((0x3<<23))
-#define MI_WAIT_FOR_PLANE_A_FLIP      (1<<2) 
-#define MI_WAIT_FOR_PLANE_A_SCANLINES (1<<1) 
+#define MI_WAIT_FOR_PLANE_A_FLIP      (1<<2)
+#define MI_WAIT_FOR_PLANE_A_SCANLINES (1<<1)
 
 #define MI_LOAD_SCAN_LINES_INCL  ((0x12<<23))
 
 #endif
-
diff -purN linux-2.6.12.orig/drivers/char/drm/i830_irq.c linux-2.6.12/drivers/char/drm/i830_irq.c
--- linux-2.6.12.orig/drivers/char/drm/i830_irq.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/i830_irq.c	2005-07-05 08:37:27.000000000 +0200
@@ -9,11 +9,11 @@
  * the rights to use, copy, modify, merge, publish, distribute, sublicense,
  * and/or sell copies of the Software, and to permit persons to whom the
  * Software is furnished to do so, subject to the following conditions:
- * 
+ *
  * The above copyright notice and this permission notice (including the next
  * paragraph) shall be included in all copies or substantial portions of the
  * Software.
- * 
+ *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
@@ -26,36 +26,35 @@
  *
  */
 
+#include <linux/interrupt.h>	/* For task queue support */
+#include <linux/delay.h>
+
 #include "drmP.h"
 #include "drm.h"
 #include "i830_drm.h"
 #include "i830_drv.h"
-#include <linux/interrupt.h>	/* For task queue support */
-#include <linux/delay.h>
 
-
-irqreturn_t i830_driver_irq_handler( DRM_IRQ_ARGS )
+irqreturn_t i830_driver_irq_handler(DRM_IRQ_ARGS)
 {
-	drm_device_t	 *dev = (drm_device_t *)arg;
-      	drm_i830_private_t *dev_priv = (drm_i830_private_t *)dev->dev_private;
-   	u16 temp;
+	drm_device_t *dev = (drm_device_t *) arg;
+	drm_i830_private_t *dev_priv = (drm_i830_private_t *) dev->dev_private;
+	u16 temp;
 
-      	temp = I830_READ16(I830REG_INT_IDENTITY_R);
+	temp = I830_READ16(I830REG_INT_IDENTITY_R);
 	DRM_DEBUG("%x\n", temp);
 
-   	if ( !( temp & 2 ) ) 
+	if (!(temp & 2))
 		return IRQ_NONE;
 
-	I830_WRITE16(I830REG_INT_IDENTITY_R, temp); 
+	I830_WRITE16(I830REG_INT_IDENTITY_R, temp);
 
 	atomic_inc(&dev_priv->irq_received);
-	wake_up_interruptible(&dev_priv->irq_queue); 
+	wake_up_interruptible(&dev_priv->irq_queue);
 
 	return IRQ_HANDLED;
 }
 
-
-int i830_emit_irq(drm_device_t *dev)
+static int i830_emit_irq(drm_device_t * dev)
 {
 	drm_i830_private_t *dev_priv = dev->dev_private;
 	RING_LOCALS;
@@ -64,141 +63,137 @@ int i830_emit_irq(drm_device_t *dev)
 
 	atomic_inc(&dev_priv->irq_emitted);
 
-   	BEGIN_LP_RING(2);
-      	OUT_RING( 0 );
-      	OUT_RING( GFX_OP_USER_INTERRUPT );
-      	ADVANCE_LP_RING();
+	BEGIN_LP_RING(2);
+	OUT_RING(0);
+	OUT_RING(GFX_OP_USER_INTERRUPT);
+	ADVANCE_LP_RING();
 
 	return atomic_read(&dev_priv->irq_emitted);
 }
 
-
-int i830_wait_irq(drm_device_t *dev, int irq_nr)
+static int i830_wait_irq(drm_device_t * dev, int irq_nr)
 {
-  	drm_i830_private_t *dev_priv = 
-	   (drm_i830_private_t *)dev->dev_private;
+	drm_i830_private_t *dev_priv = (drm_i830_private_t *) dev->dev_private;
 	DECLARE_WAITQUEUE(entry, current);
-	unsigned long end = jiffies + HZ*3;
+	unsigned long end = jiffies + HZ * 3;
 	int ret = 0;
 
 	DRM_DEBUG("%s\n", __FUNCTION__);
 
- 	if (atomic_read(&dev_priv->irq_received) >= irq_nr)  
- 		return 0; 
+	if (atomic_read(&dev_priv->irq_received) >= irq_nr)
+		return 0;
 
 	dev_priv->sarea_priv->perf_boxes |= I830_BOX_WAIT;
 
 	add_wait_queue(&dev_priv->irq_queue, &entry);
 
 	for (;;) {
-		__set_current_state(TASK_INTERRUPTIBLE);
-	   	if (atomic_read(&dev_priv->irq_received) >= irq_nr) 
-		   break;
-		if((signed)(end - jiffies) <= 0) {
+		current->state = TASK_INTERRUPTIBLE;
+		if (atomic_read(&dev_priv->irq_received) >= irq_nr)
+			break;
+		if ((signed)(end - jiffies) <= 0) {
 			DRM_ERROR("timeout iir %x imr %x ier %x hwstam %x\n",
-				  I830_READ16( I830REG_INT_IDENTITY_R ),
-				  I830_READ16( I830REG_INT_MASK_R ),
-				  I830_READ16( I830REG_INT_ENABLE_R ),
-				  I830_READ16( I830REG_HWSTAM ));
+				  I830_READ16(I830REG_INT_IDENTITY_R),
+				  I830_READ16(I830REG_INT_MASK_R),
+				  I830_READ16(I830REG_INT_ENABLE_R),
+				  I830_READ16(I830REG_HWSTAM));
 
-		   	ret = -EBUSY;	/* Lockup?  Missed irq? */
+			ret = -EBUSY;	/* Lockup?  Missed irq? */
 			break;
 		}
-	      	schedule_timeout(HZ*3);
-	      	if (signal_pending(current)) {
-		   	ret = -EINTR;
+		schedule_timeout(HZ * 3);
+		if (signal_pending(current)) {
+			ret = -EINTR;
 			break;
 		}
 	}
 
-	__set_current_state(TASK_RUNNING);
+	current->state = TASK_RUNNING;
 	remove_wait_queue(&dev_priv->irq_queue, &entry);
 	return ret;
 }
 
-
 /* Needs the lock as it touches the ring.
  */
-int i830_irq_emit( struct inode *inode, struct file *filp, unsigned int cmd,
-		   unsigned long arg )
+int i830_irq_emit(struct inode *inode, struct file *filp, unsigned int cmd,
+		  unsigned long arg)
 {
-	drm_file_t	  *priv	    = filp->private_data;
-	drm_device_t	  *dev	    = priv->head->dev;
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
 	drm_i830_private_t *dev_priv = dev->dev_private;
 	drm_i830_irq_emit_t emit;
 	int result;
 
 	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	if ( !dev_priv ) {
-		DRM_ERROR( "%s called with no initialization\n", __FUNCTION__ );
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
 		return -EINVAL;
 	}
 
-	if (copy_from_user( &emit, (drm_i830_irq_emit_t __user *)arg, sizeof(emit) ))
+	if (copy_from_user
+	    (&emit, (drm_i830_irq_emit_t __user *) arg, sizeof(emit)))
 		return -EFAULT;
 
-	result = i830_emit_irq( dev );
+	result = i830_emit_irq(dev);
 
-	if ( copy_to_user( emit.irq_seq, &result, sizeof(int) ) ) {
-		DRM_ERROR( "copy_to_user\n" );
+	if (copy_to_user(emit.irq_seq, &result, sizeof(int))) {
+		DRM_ERROR("copy_to_user\n");
 		return -EFAULT;
 	}
 
 	return 0;
 }
 
-
 /* Doesn't need the hardware lock.
  */
-int i830_irq_wait( struct inode *inode, struct file *filp, unsigned int cmd,
-		   unsigned long arg )
+int i830_irq_wait(struct inode *inode, struct file *filp, unsigned int cmd,
+		  unsigned long arg)
 {
-	drm_file_t	  *priv	    = filp->private_data;
-	drm_device_t	  *dev	    = priv->head->dev;
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
 	drm_i830_private_t *dev_priv = dev->dev_private;
 	drm_i830_irq_wait_t irqwait;
 
-	if ( !dev_priv ) {
-		DRM_ERROR( "%s called with no initialization\n", __FUNCTION__ );
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
 		return -EINVAL;
 	}
 
-	if (copy_from_user( &irqwait, (drm_i830_irq_wait_t __user *)arg, 
-			    sizeof(irqwait) ))
+	if (copy_from_user(&irqwait, (drm_i830_irq_wait_t __user *) arg,
+			   sizeof(irqwait)))
 		return -EFAULT;
 
-	return i830_wait_irq( dev, irqwait.irq_seq );
+	return i830_wait_irq(dev, irqwait.irq_seq);
 }
 
-
 /* drm_dma.h hooks
 */
-void i830_driver_irq_preinstall( drm_device_t *dev ) {
-	drm_i830_private_t *dev_priv =
-		(drm_i830_private_t *)dev->dev_private;
-
-	I830_WRITE16( I830REG_HWSTAM, 0xffff );
-	I830_WRITE16( I830REG_INT_MASK_R, 0x0 );
-	I830_WRITE16( I830REG_INT_ENABLE_R, 0x0 );
+void i830_driver_irq_preinstall(drm_device_t * dev)
+{
+	drm_i830_private_t *dev_priv = (drm_i830_private_t *) dev->dev_private;
+
+	I830_WRITE16(I830REG_HWSTAM, 0xffff);
+	I830_WRITE16(I830REG_INT_MASK_R, 0x0);
+	I830_WRITE16(I830REG_INT_ENABLE_R, 0x0);
 	atomic_set(&dev_priv->irq_received, 0);
 	atomic_set(&dev_priv->irq_emitted, 0);
 	init_waitqueue_head(&dev_priv->irq_queue);
 }
 
-void i830_driver_irq_postinstall( drm_device_t *dev ) {
-	drm_i830_private_t *dev_priv =
-		(drm_i830_private_t *)dev->dev_private;
+void i830_driver_irq_postinstall(drm_device_t * dev)
+{
+	drm_i830_private_t *dev_priv = (drm_i830_private_t *) dev->dev_private;
 
-	I830_WRITE16( I830REG_INT_ENABLE_R, 0x2 );
+	I830_WRITE16(I830REG_INT_ENABLE_R, 0x2);
 }
 
-void i830_driver_irq_uninstall( drm_device_t *dev ) {
-	drm_i830_private_t *dev_priv =
-		(drm_i830_private_t *)dev->dev_private;
+void i830_driver_irq_uninstall(drm_device_t * dev)
+{
+	drm_i830_private_t *dev_priv = (drm_i830_private_t *) dev->dev_private;
 	if (!dev_priv)
 		return;
 
-	I830_WRITE16( I830REG_INT_MASK_R, 0xffff );
-	I830_WRITE16( I830REG_INT_ENABLE_R, 0x0 );
+	I830_WRITE16(I830REG_INT_MASK_R, 0xffff);
+	I830_WRITE16(I830REG_INT_ENABLE_R, 0x0);
 }
diff -purN linux-2.6.12.orig/drivers/char/drm/i915_dma.c linux-2.6.12/drivers/char/drm/i915_dma.c
--- linux-2.6.12.orig/drivers/char/drm/i915_dma.c	2005-07-05 08:36:22.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/i915_dma.c	2005-07-05 08:37:47.000000000 +0200
@@ -1,10 +1,10 @@
 /* i915_dma.c -- DMA support for the I915 -*- linux-c -*-
  */
 /**************************************************************************
- *
+ * 
  * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
  * All Rights Reserved.
- *
+ * 
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the
  * "Software"), to deal in the Software without restriction, including
@@ -12,11 +12,11 @@
  * distribute, sub license, and/or sell copies of the Software, and to
  * permit persons to whom the Software is furnished to do so, subject to
  * the following conditions:
- *
+ * 
  * The above copyright notice and this permission notice (including the
  * next paragraph) shall be included in all copies or substantial portions
  * of the Software.
- *
+ * 
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
@@ -24,7 +24,7 @@
  * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
+ * 
  **************************************************************************/
 
 #include "drmP.h"
@@ -32,23 +32,6 @@
 #include "i915_drm.h"
 #include "i915_drv.h"
 
-drm_ioctl_desc_t i915_ioctls[] = {
-	[DRM_IOCTL_NR(DRM_I915_INIT)] = {i915_dma_init, 1, 1},
-	[DRM_IOCTL_NR(DRM_I915_FLUSH)] = {i915_flush_ioctl, 1, 0},
-	[DRM_IOCTL_NR(DRM_I915_FLIP)] = {i915_flip_bufs, 1, 0},
-	[DRM_IOCTL_NR(DRM_I915_BATCHBUFFER)] = {i915_batchbuffer, 1, 0},
-	[DRM_IOCTL_NR(DRM_I915_IRQ_EMIT)] = {i915_irq_emit, 1, 0},
-	[DRM_IOCTL_NR(DRM_I915_IRQ_WAIT)] = {i915_irq_wait, 1, 0},
-	[DRM_IOCTL_NR(DRM_I915_GETPARAM)] = {i915_getparam, 1, 0},
-	[DRM_IOCTL_NR(DRM_I915_SETPARAM)] = {i915_setparam, 1, 1},
-	[DRM_IOCTL_NR(DRM_I915_ALLOC)] = {i915_mem_alloc, 1, 0},
-	[DRM_IOCTL_NR(DRM_I915_FREE)] = {i915_mem_free, 1, 0},
-	[DRM_IOCTL_NR(DRM_I915_INIT_HEAP)] = {i915_mem_init_heap, 1, 1},
-	[DRM_IOCTL_NR(DRM_I915_CMDBUFFER)] = {i915_cmdbuffer, 1, 0}
-};
-
-int i915_max_ioctl = DRM_ARRAY_SIZE(i915_ioctls);
-
 /* Really want an OS-independent resettable timer.  Would like to have
  * this loop run for (eg) 3 sec, but have the timer reset every time
  * the head pointer changes, so that EBUSY only happens if the ring
@@ -95,32 +78,31 @@ void i915_kernel_lost_context(drm_device
 		dev_priv->sarea_priv->perf_boxes |= I915_BOX_RING_EMPTY;
 }
 
-int i915_dma_cleanup(drm_device_t * dev)
+static int i915_dma_cleanup(drm_device_t * dev)
 {
 	/* Make sure interrupts are disabled here because the uninstall ioctl
 	 * may not have been called from userspace and after dev_private
 	 * is freed, it's too late.
 	 */
 	if (dev->irq)
-		drm_irq_uninstall (dev);
+		drm_irq_uninstall(dev);
 
 	if (dev->dev_private) {
 		drm_i915_private_t *dev_priv =
 		    (drm_i915_private_t *) dev->dev_private;
 
 		if (dev_priv->ring.virtual_start) {
-			drm_core_ioremapfree( &dev_priv->ring.map, dev);
+			drm_core_ioremapfree(&dev_priv->ring.map, dev);
 		}
 
-		if (dev_priv->hw_status_page) {
-			drm_pci_free(dev, PAGE_SIZE, dev_priv->hw_status_page,
-				     dev_priv->dma_status_page);
+		if (dev_priv->status_page_dmah) {
+			drm_pci_free(dev, dev_priv->status_page_dmah);
 			/* Need to rewrite hardware status page */
 			I915_WRITE(0x02080, 0x1ffff000);
 		}
 
-		drm_free (dev->dev_private, sizeof(drm_i915_private_t),
-			   DRM_MEM_DRIVER);
+		drm_free(dev->dev_private, sizeof(drm_i915_private_t),
+			 DRM_MEM_DRIVER);
 
 		dev->dev_private = NULL;
 	}
@@ -164,7 +146,7 @@ static int i915_initialize(drm_device_t 
 	dev_priv->ring.map.flags = 0;
 	dev_priv->ring.map.mtrr = 0;
 
-	drm_core_ioremap( &dev_priv->ring.map, dev );
+	drm_core_ioremap(&dev_priv->ring.map, dev);
 
 	if (dev_priv->ring.map.handle == NULL) {
 		dev->dev_private = (void *)dev_priv;
@@ -191,16 +173,18 @@ static int i915_initialize(drm_device_t 
 	dev_priv->allow_batchbuffer = 1;
 
 	/* Program Hardware Status Page */
-	dev_priv->hw_status_page = drm_pci_alloc(dev, PAGE_SIZE, PAGE_SIZE,
-						 0xffffffff, 
-						 &dev_priv->dma_status_page);
+	dev_priv->status_page_dmah = drm_pci_alloc(dev, PAGE_SIZE, PAGE_SIZE, 
+	    0xffffffff);
 
-	if (!dev_priv->hw_status_page) {
+	if (!dev_priv->status_page_dmah) {
 		dev->dev_private = (void *)dev_priv;
 		i915_dma_cleanup(dev);
 		DRM_ERROR("Can not allocate hardware status page\n");
 		return DRM_ERR(ENOMEM);
 	}
+	dev_priv->hw_status_page = dev_priv->status_page_dmah->vaddr;
+	dev_priv->dma_status_page = dev_priv->status_page_dmah->busaddr;
+	
 	memset(dev_priv->hw_status_page, 0, PAGE_SIZE);
 	DRM_DEBUG("hw status page @ %p\n", dev_priv->hw_status_page);
 
@@ -212,7 +196,7 @@ static int i915_initialize(drm_device_t 
 	return 0;
 }
 
-static int i915_resume(drm_device_t * dev)
+static int i915_dma_resume(drm_device_t * dev)
 {
 	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
 
@@ -247,7 +231,7 @@ static int i915_resume(drm_device_t * de
 	return 0;
 }
 
-int i915_dma_init(DRM_IOCTL_ARGS)
+static int i915_dma_init(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_i915_private_t *dev_priv;
@@ -259,8 +243,8 @@ int i915_dma_init(DRM_IOCTL_ARGS)
 
 	switch (init.func) {
 	case I915_INIT_DMA:
-		dev_priv = drm_alloc (sizeof(drm_i915_private_t),
-				       DRM_MEM_DRIVER);
+		dev_priv = drm_alloc(sizeof(drm_i915_private_t),
+				     DRM_MEM_DRIVER);
 		if (dev_priv == NULL)
 			return DRM_ERR(ENOMEM);
 		retcode = i915_initialize(dev, dev_priv, &init);
@@ -269,7 +253,7 @@ int i915_dma_init(DRM_IOCTL_ARGS)
 		retcode = i915_dma_cleanup(dev);
 		break;
 	case I915_RESUME_DMA:
-		retcode = i915_resume(dev);
+		retcode = i915_dma_resume(dev);
 		break;
 	default:
 		retcode = -EINVAL;
@@ -313,7 +297,7 @@ static int do_validate_cmd(int cmd)
 		case 0x1c:
 			return 1;
 		case 0x1d:
-			switch ((cmd>>16)&0xff) {
+			switch ((cmd >> 16) & 0xff) {
 			case 0x3:
 				return (cmd & 0x1f) + 2;
 			case 0x4:
@@ -558,7 +542,7 @@ static int i915_quiescent(drm_device_t *
 	return i915_wait_ring(dev, dev_priv->ring.Size - 8, __FUNCTION__);
 }
 
-int i915_flush_ioctl(DRM_IOCTL_ARGS)
+static int i915_flush_ioctl(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 
@@ -567,7 +551,7 @@ int i915_flush_ioctl(DRM_IOCTL_ARGS)
 	return i915_quiescent(dev);
 }
 
-int i915_batchbuffer(DRM_IOCTL_ARGS)
+static int i915_batchbuffer(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
@@ -601,7 +585,7 @@ int i915_batchbuffer(DRM_IOCTL_ARGS)
 	return ret;
 }
 
-int i915_cmdbuffer(DRM_IOCTL_ARGS)
+static int i915_cmdbuffer(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
@@ -637,7 +621,7 @@ int i915_cmdbuffer(DRM_IOCTL_ARGS)
 	return 0;
 }
 
-int i915_do_cleanup_pageflip(drm_device_t * dev)
+static int i915_do_cleanup_pageflip(drm_device_t * dev)
 {
 	drm_i915_private_t *dev_priv = dev->dev_private;
 
@@ -648,7 +632,7 @@ int i915_do_cleanup_pageflip(drm_device_
 	return 0;
 }
 
-int i915_flip_bufs(DRM_IOCTL_ARGS)
+static int i915_flip_bufs(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 
@@ -659,7 +643,7 @@ int i915_flip_bufs(DRM_IOCTL_ARGS)
 	return i915_dispatch_flip(dev);
 }
 
-int i915_getparam(DRM_IOCTL_ARGS)
+static int i915_getparam(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_i915_private_t *dev_priv = dev->dev_private;
@@ -694,7 +678,7 @@ int i915_getparam(DRM_IOCTL_ARGS)
 	return 0;
 }
 
-int i915_setparam(DRM_IOCTL_ARGS)
+static int i915_setparam(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_i915_private_t *dev_priv = dev->dev_private;
@@ -726,20 +710,55 @@ int i915_setparam(DRM_IOCTL_ARGS)
 	return 0;
 }
 
-void i915_driver_pretakedown(drm_device_t *dev)
+void i915_driver_pretakedown(drm_device_t * dev)
 {
-	if ( dev->dev_private ) {
+	if (dev->dev_private) {
 		drm_i915_private_t *dev_priv = dev->dev_private;
-	        i915_mem_takedown( &(dev_priv->agp_heap) );
- 	}
-	i915_dma_cleanup( dev );
+		i915_mem_takedown(&(dev_priv->agp_heap));
+	}
+	i915_dma_cleanup(dev);
 }
 
-void i915_driver_prerelease(drm_device_t *dev, DRMFILE filp)
+void i915_driver_prerelease(drm_device_t * dev, DRMFILE filp)
 {
-	if ( dev->dev_private ) {
+	if (dev->dev_private) {
 		drm_i915_private_t *dev_priv = dev->dev_private;
-                i915_mem_release( dev, filp, dev_priv->agp_heap );
+		if (dev_priv->page_flipping) {
+			i915_do_cleanup_pageflip(dev);
+		}
+		i915_mem_release(dev, filp, dev_priv->agp_heap);
 	}
 }
 
+drm_ioctl_desc_t i915_ioctls[] = {
+	[DRM_IOCTL_NR(DRM_I915_INIT)] = {i915_dma_init, 1, 1},
+	[DRM_IOCTL_NR(DRM_I915_FLUSH)] = {i915_flush_ioctl, 1, 0},
+	[DRM_IOCTL_NR(DRM_I915_FLIP)] = {i915_flip_bufs, 1, 0},
+	[DRM_IOCTL_NR(DRM_I915_BATCHBUFFER)] = {i915_batchbuffer, 1, 0},
+	[DRM_IOCTL_NR(DRM_I915_IRQ_EMIT)] = {i915_irq_emit, 1, 0},
+	[DRM_IOCTL_NR(DRM_I915_IRQ_WAIT)] = {i915_irq_wait, 1, 0},
+	[DRM_IOCTL_NR(DRM_I915_GETPARAM)] = {i915_getparam, 1, 0},
+	[DRM_IOCTL_NR(DRM_I915_SETPARAM)] = {i915_setparam, 1, 1},
+	[DRM_IOCTL_NR(DRM_I915_ALLOC)] = {i915_mem_alloc, 1, 0},
+	[DRM_IOCTL_NR(DRM_I915_FREE)] = {i915_mem_free, 1, 0},
+	[DRM_IOCTL_NR(DRM_I915_INIT_HEAP)] = {i915_mem_init_heap, 1, 1},
+	[DRM_IOCTL_NR(DRM_I915_CMDBUFFER)] = {i915_cmdbuffer, 1, 0}
+};
+
+int i915_max_ioctl = DRM_ARRAY_SIZE(i915_ioctls);
+
+/**
+ * Determine if the device really is AGP or not.
+ *
+ * All Intel graphics chipsets are treated as AGP, even if they are really
+ * PCI-e.
+ *
+ * \param dev   The device to be tested.
+ *
+ * \returns
+ * A value of 1 is always retured to indictate every i9x5 is AGP.
+ */
+int i915_driver_device_is_agp(drm_device_t * dev)
+{
+	return 1;
+}
diff -purN linux-2.6.12.orig/drivers/char/drm/i915_drm.h linux-2.6.12/drivers/char/drm/i915_drm.h
--- linux-2.6.12.orig/drivers/char/drm/i915_drm.h	2005-07-05 08:36:22.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/i915_drm.h	2005-07-05 08:37:49.000000000 +0200
@@ -1,8 +1,8 @@
 /**************************************************************************
- *
+ * 
  * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
  * All Rights Reserved.
- *
+ * 
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the
  * "Software"), to deal in the Software without restriction, including
@@ -10,11 +10,11 @@
  * distribute, sub license, and/or sell copies of the Software, and to
  * permit persons to whom the Software is furnished to do so, subject to
  * the following conditions:
- *
+ * 
  * The above copyright notice and this permission notice (including the
  * next paragraph) shall be included in all copies or substantial portions
  * of the Software.
- *
+ * 
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
@@ -22,7 +22,7 @@
  * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
+ * 
  **************************************************************************/
 
 #ifndef _I915_DRM_H_
diff -purN linux-2.6.12.orig/drivers/char/drm/i915_drv.c linux-2.6.12/drivers/char/drm/i915_drv.c
--- linux-2.6.12.orig/drivers/char/drm/i915_drv.c	2005-07-05 08:36:22.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/i915_drv.c	2005-07-05 08:37:27.000000000 +0200
@@ -1,10 +1,10 @@
 /* i915_drv.c -- i830,i845,i855,i865,i915 driver -*- linux-c -*-
  */
 /**************************************************************************
- *
+ * 
  * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
  * All Rights Reserved.
- *
+ * 
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the
  * "Software"), to deal in the Software without restriction, including
@@ -12,11 +12,11 @@
  * distribute, sub license, and/or sell copies of the Software, and to
  * permit persons to whom the Software is furnished to do so, subject to
  * the following conditions:
- *
+ * 
  * The above copyright notice and this permission notice (including the
  * next paragraph) shall be included in all copies or substantial portions
  * of the Software.
- *
+ * 
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
@@ -24,7 +24,7 @@
  * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
+ * 
  **************************************************************************/
 
 #include "drmP.h"
@@ -34,36 +34,34 @@
 
 #include "drm_pciids.h"
 
-int postinit( struct drm_device *dev, unsigned long flags )
+static int postinit(struct drm_device *dev, unsigned long flags)
 {
 	dev->counters += 4;
 	dev->types[6] = _DRM_STAT_IRQ;
 	dev->types[7] = _DRM_STAT_PRIMARY;
 	dev->types[8] = _DRM_STAT_SECONDARY;
 	dev->types[9] = _DRM_STAT_DMA;
-	
-	DRM_INFO( "Initialized %s %d.%d.%d %s on minor %d: %s\n",
-		DRIVER_NAME,
-		DRIVER_MAJOR,
-		DRIVER_MINOR,
-		DRIVER_PATCHLEVEL,
-		DRIVER_DATE,
-		dev->primary.minor,
-		pci_pretty_name(dev->pdev)
-		);
+
+	DRM_INFO("Initialized %s %d.%d.%d %s on minor %d: %s\n",
+		 DRIVER_NAME,
+		 DRIVER_MAJOR,
+		 DRIVER_MINOR,
+		 DRIVER_PATCHLEVEL,
+		 DRIVER_DATE, dev->primary.minor, pci_pretty_name(dev->pdev)
+	    );
 	return 0;
 }
 
-static int version( drm_version_t *version )
+static int version(drm_version_t * version)
 {
 	int len;
 
 	version->version_major = DRIVER_MAJOR;
 	version->version_minor = DRIVER_MINOR;
 	version->version_patchlevel = DRIVER_PATCHLEVEL;
-	DRM_COPY( version->name, DRIVER_NAME );
-	DRM_COPY( version->date, DRIVER_DATE );
-	DRM_COPY( version->desc, DRIVER_DESC );
+	DRM_COPY(version->name, DRIVER_NAME);
+	DRM_COPY(version->date, DRIVER_DATE);
+	DRM_COPY(version->desc, DRIVER_DESC);
 	return 0;
 }
 
@@ -74,11 +72,14 @@ static struct pci_device_id pciidlist[] 
 extern drm_ioctl_desc_t i915_ioctls[];
 extern int i915_max_ioctl;
 
+static int probe(struct pci_dev *pdev, const struct pci_device_id *ent);
 static struct drm_driver driver = {
-	.driver_features = DRIVER_USE_AGP | DRIVER_REQUIRE_AGP | DRIVER_USE_MTRR |
-				DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED,
+	.driver_features =
+	    DRIVER_USE_AGP | DRIVER_REQUIRE_AGP | DRIVER_USE_MTRR |
+	    DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED,
 	.pretakedown = i915_driver_pretakedown,
 	.prerelease = i915_driver_prerelease,
+	.device_is_agp = i915_driver_device_is_agp,
 	.irq_preinstall = i915_driver_irq_preinstall,
 	.irq_postinstall = i915_driver_irq_postinstall,
 	.irq_uninstall = i915_driver_irq_uninstall,
@@ -97,17 +98,26 @@ static struct drm_driver driver = {
 		.mmap = drm_mmap,
 		.poll = drm_poll,
 		.fasync = drm_fasync,
-	},
+		},
 	.pci_driver = {
-		.name          = DRIVER_NAME,
-		.id_table      = pciidlist,
-	}
+		.name = DRIVER_NAME,
+		.id_table = pciidlist,
+		.probe = probe,
+		/* .resume = i915_resume, - need BIOS to re-init */
+		.suspend = i915_suspend,
+		.remove = __devexit_p(drm_cleanup_pci),
+		}
 };
 
+static int probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	return drm_get_dev(pdev, ent, &driver);
+}
+
 static int __init i915_init(void)
 {
 	driver.num_ioctls = i915_max_ioctl;
-	return drm_init(&driver);
+	return drm_init(&driver, pciidlist);
 }
 
 static void __exit i915_exit(void)
@@ -118,6 +128,6 @@ static void __exit i915_exit(void)
 module_init(i915_init);
 module_exit(i915_exit);
 
-MODULE_AUTHOR( DRIVER_AUTHOR );
-MODULE_DESCRIPTION( DRIVER_DESC );
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL and additional rights");
diff -purN linux-2.6.12.orig/drivers/char/drm/i915_drv.h linux-2.6.12/drivers/char/drm/i915_drv.h
--- linux-2.6.12.orig/drivers/char/drm/i915_drv.h	2005-07-05 08:36:22.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/i915_drv.h	2005-07-05 08:37:49.000000000 +0200
@@ -1,10 +1,10 @@
 /* i915_drv.h -- Private header for the I915 driver -*- linux-c -*-
  */
 /**************************************************************************
- *
+ * 
  * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
  * All Rights Reserved.
- *
+ * 
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the
  * "Software"), to deal in the Software without restriction, including
@@ -12,11 +12,11 @@
  * distribute, sub license, and/or sell copies of the Software, and to
  * permit persons to whom the Software is furnished to do so, subject to
  * the following conditions:
- *
+ * 
  * The above copyright notice and this permission notice (including the
  * next paragraph) shall be included in all copies or substantial portions
  * of the Software.
- *
+ * 
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
@@ -24,7 +24,7 @@
  * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
+ * 
  **************************************************************************/
 
 #ifndef _I915_DRV_H_
@@ -37,21 +37,17 @@
 
 #define DRIVER_NAME		"i915"
 #define DRIVER_DESC		"Intel Graphics"
-#define DRIVER_DATE		"20040405"
+#define DRIVER_DATE		"20041217"
 
 /* Interface history:
  *
  * 1.1: Original.
+ * 1.2: Add Power Management
  */
 #define DRIVER_MAJOR		1
-#define DRIVER_MINOR		1
+#define DRIVER_MINOR		2
 #define DRIVER_PATCHLEVEL	0
 
-/* We use our own dma mechanisms, not the drm template code.  However,
- * the shared IRQ code is useful to us:
- */
-#define __HAVE_PM		1
-
 typedef struct _drm_i915_ring_buffer {
 	int tail_mask;
 	unsigned long Start;
@@ -79,9 +75,10 @@ typedef struct drm_i915_private {
 	drm_i915_sarea_t *sarea_priv;
 	drm_i915_ring_buffer_t ring;
 
+	drm_dma_handle_t *status_page_dmah;
 	void *hw_status_page;
-	unsigned long counter;
 	dma_addr_t dma_status_page;
+	unsigned long counter;
 
 	int back_offset;
 	int front_offset;
@@ -96,31 +93,28 @@ typedef struct drm_i915_private {
 	int tex_lru_log_granularity;
 	int allow_batchbuffer;
 	struct mem_block *agp_heap;
+	unsigned int sr01, adpa, ppcr, dvob, dvoc, lvds;
 } drm_i915_private_t;
 
 				/* i915_dma.c */
-extern int i915_dma_init(DRM_IOCTL_ARGS);
-extern int i915_dma_cleanup(drm_device_t * dev);
-extern int i915_flush_ioctl(DRM_IOCTL_ARGS);
-extern int i915_batchbuffer(DRM_IOCTL_ARGS);
-extern int i915_flip_bufs(DRM_IOCTL_ARGS);
-extern int i915_getparam(DRM_IOCTL_ARGS);
-extern int i915_setparam(DRM_IOCTL_ARGS);
-extern int i915_cmdbuffer(DRM_IOCTL_ARGS);
 extern void i915_kernel_lost_context(drm_device_t * dev);
-extern void i915_driver_pretakedown(drm_device_t *dev);
-extern void i915_driver_prerelease(drm_device_t *dev, DRMFILE filp);
+extern void i915_driver_pretakedown(drm_device_t * dev);
+extern void i915_driver_prerelease(drm_device_t * dev, DRMFILE filp);
+extern int i915_driver_device_is_agp(drm_device_t * dev);
 
 /* i915_irq.c */
 extern int i915_irq_emit(DRM_IOCTL_ARGS);
 extern int i915_irq_wait(DRM_IOCTL_ARGS);
-extern int i915_wait_irq(drm_device_t * dev, int irq_nr);
-extern int i915_emit_irq(drm_device_t * dev);
 
 extern irqreturn_t i915_driver_irq_handler(DRM_IRQ_ARGS);
-extern void i915_driver_irq_preinstall(drm_device_t *dev);
-extern void i915_driver_irq_postinstall(drm_device_t *dev);
-extern void i915_driver_irq_uninstall(drm_device_t *dev);
+extern void i915_driver_irq_preinstall(drm_device_t * dev);
+extern void i915_driver_irq_postinstall(drm_device_t * dev);
+extern void i915_driver_irq_uninstall(drm_device_t * dev);
+
+/* i915_pm.c */
+extern int i915_suspend(struct pci_dev *pdev, u32 state);
+extern int i915_resume(struct pci_dev *pdev);
+extern int i915_power(drm_device_t *dev, unsigned int state);
 
 /* i915_mem.c */
 extern int i915_mem_alloc(DRM_IOCTL_ARGS);
@@ -130,10 +124,10 @@ extern void i915_mem_takedown(struct mem
 extern void i915_mem_release(drm_device_t * dev,
 			     DRMFILE filp, struct mem_block *heap);
 
-#define I915_READ(reg)          DRM_READ32(dev_priv->mmio_map, reg)
-#define I915_WRITE(reg,val)     DRM_WRITE32(dev_priv->mmio_map, reg, val)
-#define I915_READ16(reg) 	DRM_READ16(dev_priv->mmio_map, reg)
-#define I915_WRITE16(reg,val)	DRM_WRITE16(dev_priv->mmio_map, reg, val)
+#define I915_READ(reg)          DRM_READ32(dev_priv->mmio_map, (reg))
+#define I915_WRITE(reg,val)     DRM_WRITE32(dev_priv->mmio_map, (reg), (val))
+#define I915_READ16(reg) 	DRM_READ16(dev_priv->mmio_map, (reg))
+#define I915_WRITE16(reg,val)	DRM_WRITE16(dev_priv->mmio_map, (reg), (val))
 
 #define I915_VERBOSE 0
 
@@ -197,6 +191,13 @@ extern int i915_wait_ring(drm_device_t *
 #define PPCR			0x61204
 #define PPCR_ON			(1<<0)
 
+#define DVOB			0x61140
+#define DVOB_ON			(1<<31)
+#define DVOC			0x61160
+#define DVOC_ON			(1<<31)
+#define LVDS			0x61180
+#define LVDS_ON			(1<<31)
+
 #define ADPA			0x61100
 #define ADPA_DPMS_MASK		(~(3<<10))
 #define ADPA_DPMS_ON		(0<<10)
diff -purN linux-2.6.12.orig/drivers/char/drm/i915_ioc32.c linux-2.6.12/drivers/char/drm/i915_ioc32.c
--- linux-2.6.12.orig/drivers/char/drm/i915_ioc32.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/drm/i915_ioc32.c	2005-07-05 08:37:27.000000000 +0200
@@ -0,0 +1,221 @@
+/**
+ * \file i915_ioc32.c
+ *
+ * 32-bit ioctl compatibility routines for the i915 DRM.
+ *
+ * \author Alan Hourihane <alanh@fairlite.demon.co.uk> 
+ *
+ *
+ * Copyright (C) Paul Mackerras 2005
+ * Copyright (C) Alan Hourihane 2005
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+#include <linux/compat.h>
+#include <linux/ioctl32.h>
+
+#include "drmP.h"
+#include "drm.h"
+#include "i915_drm.h"
+
+typedef struct _drm_i915_batchbuffer32 {
+	int start;		/* agp offset */
+	int used;		/* nr bytes in use */
+	int DR1;		/* hw flags for GFX_OP_DRAWRECT_INFO */
+	int DR4;		/* window origin for GFX_OP_DRAWRECT_INFO */
+	int num_cliprects;	/* mulitpass with multiple cliprects? */
+	u32 cliprects;	/* pointer to userspace cliprects */
+} drm_i915_batchbuffer32_t;
+
+static int compat_i915_batchbuffer(struct file *file, unsigned int cmd,
+			   unsigned long arg)
+{
+	drm_i915_batchbuffer32_t batchbuffer32;
+	drm_i915_batchbuffer_t __user *batchbuffer;
+	
+	if (copy_from_user(&batchbuffer32, (void __user *)arg, sizeof(batchbuffer32)))
+		return -EFAULT;
+	
+	batchbuffer = compat_alloc_user_space(sizeof(*batchbuffer));
+	if (!access_ok(VERIFY_WRITE, batchbuffer, sizeof(*batchbuffer))
+	    || __put_user(batchbuffer32.start, &batchbuffer->start)
+	    || __put_user(batchbuffer32.used, &batchbuffer->used)
+	    || __put_user(batchbuffer32.DR1, &batchbuffer->DR1)
+	    || __put_user(batchbuffer32.DR4, &batchbuffer->DR4)
+	    || __put_user(batchbuffer32.num_cliprects, &batchbuffer->num_cliprects)
+	    || __put_user((int __user *)(unsigned long)batchbuffer32.cliprects,
+			  &batchbuffer->cliprects))
+		return -EFAULT;
+	
+	return drm_ioctl(file->f_dentry->d_inode, file,
+			 DRM_IOCTL_I915_BATCHBUFFER, (unsigned long) batchbuffer);
+}
+
+typedef struct _drm_i915_cmdbuffer32 {
+	u32 buf;	/* pointer to userspace command buffer */
+	int sz;			/* nr bytes in buf */
+	int DR1;		/* hw flags for GFX_OP_DRAWRECT_INFO */
+	int DR4;		/* window origin for GFX_OP_DRAWRECT_INFO */
+	int num_cliprects;	/* mulitpass with multiple cliprects? */
+	u32 cliprects;	/* pointer to userspace cliprects */
+} drm_i915_cmdbuffer32_t;
+
+static int compat_i915_cmdbuffer(struct file *file, unsigned int cmd,
+			   unsigned long arg)
+{
+	drm_i915_cmdbuffer32_t cmdbuffer32;
+	drm_i915_cmdbuffer_t __user *cmdbuffer;
+	
+	if (copy_from_user(&cmdbuffer32, (void __user *)arg, sizeof(cmdbuffer32)))
+		return -EFAULT;
+	
+	cmdbuffer = compat_alloc_user_space(sizeof(*cmdbuffer));
+	if (!access_ok(VERIFY_WRITE, cmdbuffer, sizeof(*cmdbuffer))
+	    || __put_user((int __user *)(unsigned long)cmdbuffer32.buf,
+			  &cmdbuffer->buf)
+	    || __put_user(cmdbuffer32.sz, &cmdbuffer->sz)
+	    || __put_user(cmdbuffer32.DR1, &cmdbuffer->DR1)
+	    || __put_user(cmdbuffer32.DR4, &cmdbuffer->DR4)
+	    || __put_user(cmdbuffer32.num_cliprects, &cmdbuffer->num_cliprects)
+	    || __put_user((int __user *)(unsigned long)cmdbuffer32.cliprects,
+			  &cmdbuffer->cliprects))
+		return -EFAULT;
+	
+	return drm_ioctl(file->f_dentry->d_inode, file,
+			 DRM_IOCTL_I915_CMDBUFFER, (unsigned long) cmdbuffer);
+}
+
+typedef struct drm_i915_irq_emit32 {
+	u32 irq_seq;
+} drm_i915_irq_emit32_t;
+
+static int compat_i915_irq_emit(struct file *file, unsigned int cmd,
+				  unsigned long arg)
+{
+	drm_i915_irq_emit32_t req32;
+	drm_i915_irq_emit_t __user *request;
+
+	if (copy_from_user(&req32, (void __user *) arg, sizeof(req32)))
+		return -EFAULT;
+
+	request = compat_alloc_user_space(sizeof(*request));
+	if (!access_ok(VERIFY_WRITE, request, sizeof(*request))
+	    || __put_user((int __user *)(unsigned long)req32.irq_seq,
+			  &request->irq_seq))
+		return -EFAULT;
+
+	return drm_ioctl(file->f_dentry->d_inode, file,
+			 DRM_IOCTL_I915_IRQ_EMIT, (unsigned long) request);
+}
+typedef struct drm_i915_getparam32 {
+	int param;
+	u32 value;
+} drm_i915_getparam32_t;
+
+static int compat_i915_getparam(struct file *file, unsigned int cmd,
+				     unsigned long arg)
+{
+	drm_i915_getparam32_t req32;
+	drm_i915_getparam_t __user *request;
+
+	if (copy_from_user(&req32, (void __user *) arg, sizeof(req32)))
+		return -EFAULT;
+
+	request = compat_alloc_user_space(sizeof(*request));
+	if (!access_ok(VERIFY_WRITE, request, sizeof(*request))
+	    || __put_user(req32.param, &request->param)
+	    || __put_user((void __user *)(unsigned long)req32.value,
+			  &request->value))
+		return -EFAULT;
+
+	return drm_ioctl(file->f_dentry->d_inode, file,
+			 DRM_IOCTL_I915_GETPARAM, (unsigned long) request);
+}
+
+typedef struct drm_i915_mem_alloc32 {
+	int region;
+	int alignment;
+	int size;
+	u32 region_offset;	/* offset from start of fb or agp */
+} drm_i915_mem_alloc32_t;
+
+static int compat_i915_alloc(struct file *file, unsigned int cmd,
+				     unsigned long arg)
+{
+	drm_i915_mem_alloc32_t req32;
+	drm_i915_mem_alloc_t __user *request;
+
+	if (copy_from_user(&req32, (void __user *) arg, sizeof(req32)))
+		return -EFAULT;
+
+	request = compat_alloc_user_space(sizeof(*request));
+	if (!access_ok(VERIFY_WRITE, request, sizeof(*request))
+	    || __put_user(req32.region, &request->region)
+	    || __put_user(req32.alignment, &request->alignment)
+	    || __put_user(req32.size, &request->size)
+	    || __put_user((void __user *)(unsigned long)req32.region_offset,
+			  &request->region_offset))
+		return -EFAULT;
+
+	return drm_ioctl(file->f_dentry->d_inode, file,
+			 DRM_IOCTL_I915_ALLOC, (unsigned long) request);
+}
+
+
+drm_ioctl_compat_t *i915_compat_ioctls[] = {
+	[DRM_I915_BATCHBUFFER] = compat_i915_batchbuffer,
+	[DRM_I915_CMDBUFFER] = compat_i915_cmdbuffer,
+	[DRM_I915_GETPARAM] = compat_i915_getparam,
+	[DRM_I915_IRQ_EMIT] = compat_i915_irq_emit,
+	[DRM_I915_ALLOC] = compat_i915_alloc
+};
+
+/**
+ * Called whenever a 32-bit process running under a 64-bit kernel
+ * performs an ioctl on /dev/dri/card<n>.
+ *
+ * \param filp file pointer.
+ * \param cmd command.
+ * \param arg user argument.
+ * \return zero on success or negative number on failure.
+ */
+long i915_compat_ioctl(struct file *filp, unsigned int cmd,
+			 unsigned long arg)
+{
+	unsigned int nr = DRM_IOCTL_NR(cmd);
+	drm_ioctl_compat_t *fn = NULL;
+	int ret;
+
+	if (nr < DRM_COMMAND_BASE)
+		return drm_compat_ioctl(filp, cmd, arg);
+	
+	if (nr < DRM_COMMAND_BASE + DRM_ARRAY_SIZE(i915_compat_ioctls))
+		fn = i915_compat_ioctls[nr - DRM_COMMAND_BASE];
+
+	lock_kernel();		/* XXX for now */
+	if (fn != NULL)
+		ret = (*fn)(filp, cmd, arg);
+	else
+		ret = drm_ioctl(filp->f_dentry->d_inode, filp, cmd, arg);
+	unlock_kernel();
+
+	return ret;
+}
diff -purN linux-2.6.12.orig/drivers/char/drm/i915_irq.c linux-2.6.12/drivers/char/drm/i915_irq.c
--- linux-2.6.12.orig/drivers/char/drm/i915_irq.c	2005-07-05 08:36:22.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/i915_irq.c	2005-07-05 08:37:47.000000000 +0200
@@ -1,10 +1,10 @@
 /* i915_dma.c -- DMA support for the I915 -*- linux-c -*-
  */
 /**************************************************************************
- *
+ * 
  * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
  * All Rights Reserved.
- *
+ * 
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the
  * "Software"), to deal in the Software without restriction, including
@@ -12,11 +12,11 @@
  * distribute, sub license, and/or sell copies of the Software, and to
  * permit persons to whom the Software is furnished to do so, subject to
  * the following conditions:
- *
+ * 
  * The above copyright notice and this permission notice (including the
  * next paragraph) shall be included in all copies or substantial portions
  * of the Software.
- *
+ * 
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
@@ -24,7 +24,7 @@
  * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
+ * 
  **************************************************************************/
 
 #include "drmP.h"
@@ -56,7 +56,7 @@ irqreturn_t i915_driver_irq_handler(DRM_
 	return IRQ_HANDLED;
 }
 
-int i915_emit_irq(drm_device_t * dev)
+static int i915_emit_irq(drm_device_t * dev)
 {
 	drm_i915_private_t *dev_priv = dev->dev_private;
 	u32 ret;
@@ -76,7 +76,7 @@ int i915_emit_irq(drm_device_t * dev)
 	return ret;
 }
 
-int i915_wait_irq(drm_device_t * dev, int irq_nr)
+static int i915_wait_irq(drm_device_t * dev, int irq_nr)
 {
 	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
 	int ret = 0;
diff -purN linux-2.6.12.orig/drivers/char/drm/i915_mem.c linux-2.6.12/drivers/char/drm/i915_mem.c
--- linux-2.6.12.orig/drivers/char/drm/i915_mem.c	2005-07-05 08:36:22.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/i915_mem.c	2005-07-05 08:37:47.000000000 +0200
@@ -1,10 +1,10 @@
 /* i915_mem.c -- Simple agp/fb memory manager for i915 -*- linux-c -*-
  */
 /**************************************************************************
- *
+ * 
  * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
  * All Rights Reserved.
- *
+ * 
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the
  * "Software"), to deal in the Software without restriction, including
@@ -12,11 +12,11 @@
  * distribute, sub license, and/or sell copies of the Software, and to
  * permit persons to whom the Software is furnished to do so, subject to
  * the following conditions:
- *
+ * 
  * The above copyright notice and this permission notice (including the
  * next paragraph) shall be included in all copies or substantial portions
  * of the Software.
- *
+ * 
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
@@ -24,7 +24,7 @@
  * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
+ * 
  **************************************************************************/
 
 #include "drmP.h"
@@ -86,7 +86,7 @@ static void mark_block(drm_device_t * de
 }
 
 /* Very simple allocator for agp memory, working on a static range
- * already mapped into each client's address space.  
+ * already mapped into each client's address space.
  */
 
 static struct mem_block *split_block(struct mem_block *p, int start, int size,
@@ -94,7 +94,8 @@ static struct mem_block *split_block(str
 {
 	/* Maybe cut off the start of an existing block */
 	if (start > p->start) {
-		struct mem_block *newblock = drm_alloc(sizeof(*newblock), DRM_MEM_BUFLISTS);
+		struct mem_block *newblock =
+		    drm_alloc(sizeof(*newblock), DRM_MEM_BUFLISTS);
 		if (!newblock)
 			goto out;
 		newblock->start = start;
@@ -110,7 +111,8 @@ static struct mem_block *split_block(str
 
 	/* Maybe cut off the end of an existing block */
 	if (size < p->size) {
-		struct mem_block *newblock = drm_alloc(sizeof(*newblock), DRM_MEM_BUFLISTS);
+		struct mem_block *newblock =
+		    drm_alloc(sizeof(*newblock), DRM_MEM_BUFLISTS);
 		if (!newblock)
 			goto out;
 		newblock->start = start + size;
diff -purN linux-2.6.12.orig/drivers/char/drm/i915_pm.c linux-2.6.12/drivers/char/drm/i915_pm.c
--- linux-2.6.12.orig/drivers/char/drm/i915_pm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/drm/i915_pm.c	2005-07-05 08:37:27.000000000 +0200
@@ -0,0 +1,167 @@
+/* i915_pm.c -- Power management support for the i915 -*- linux-c -*-
+ */
+/**************************************************************************
+ * 
+ * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ * 
+ **************************************************************************/
+
+#define __NO_VERSION__
+#include "drmP.h"
+#include "drm.h"
+#include "i915_drm.h"
+#include "i915_drv.h"
+
+
+/** 
+ * Set DPMS mode. 
+ */
+static int i915_set_dpms(drm_device_t *dev, int mode)
+{
+	drm_i915_private_t *dev_priv =
+		(drm_i915_private_t *)dev->dev_private;
+	unsigned sr01, adpa, ppcr, dvob, dvoc, lvds;
+	
+	DRM_DEBUG("%s mode=%d\n", __FUNCTION__, mode);
+
+	if (!dev_priv) return 0;
+
+	I915_WRITE( SRX_INDEX, SR01 );
+	sr01 = I915_READ( SRX_DATA );
+
+	adpa = I915_READ( ADPA );
+	ppcr = I915_READ( PPCR );
+	dvoc = I915_READ( DVOC );
+	dvob = I915_READ( DVOB );
+	lvds = I915_READ( LVDS );
+
+	switch(mode) {
+		case 0:
+			/* On */
+			sr01 = dev_priv->sr01;
+			adpa = dev_priv->adpa;
+#if 0
+			I915_WRITE( LVDS, lvds | LVDS_ON ); /* Power on LVDS */
+#endif
+			I915_WRITE( PPCR, dev_priv->ppcr ); /* Power up panel */
+			I915_WRITE( DVOC, dev_priv->dvoc );
+			I915_WRITE( DVOB, dev_priv->dvob );
+			break;
+
+		case 1:
+			/* Standby */
+			sr01 |= SR01_SCREEN_OFF; 
+			adpa = (adpa & ADPA_DPMS_MASK) | ADPA_DPMS_STANDBY;
+			I915_WRITE( PPCR, ppcr & ~PPCR_ON ); /* Power off panel*/
+#if 0
+			I915_WRITE( LVDS, lvds & ~LVDS_ON ); /* Power off LVDS */
+#endif
+			I915_WRITE( DVOC, dvoc & ~DVOC_ON );
+			I915_WRITE( DVOB, dvob & ~DVOB_ON );
+			break;
+
+		case 2:
+			/* Suspend */
+			sr01 |= SR01_SCREEN_OFF; 
+			adpa = (adpa & ADPA_DPMS_MASK) | ADPA_DPMS_SUSPEND;
+			I915_WRITE( PPCR, ppcr & ~PPCR_ON ); /* Power off panel*/
+#if 0
+			I915_WRITE( LVDS, lvds & ~LVDS_ON ); /* Power off LVDS */
+#endif
+			I915_WRITE( DVOC, dvoc & ~DVOC_ON );
+			I915_WRITE( DVOB, dvob & ~DVOB_ON );
+			break;
+
+		case 3:
+			/* Off */
+			sr01 |= SR01_SCREEN_OFF; 
+			adpa = (adpa & ADPA_DPMS_MASK) | ADPA_DPMS_OFF;
+			I915_WRITE( PPCR, ppcr & ~PPCR_ON ); /* Power off panel*/
+#if 0
+			I915_WRITE( LVDS, lvds & ~LVDS_ON ); /* Power off LVDS */
+#endif
+			I915_WRITE( DVOC, dvoc & ~DVOC_ON );
+			I915_WRITE( DVOB, dvob & ~DVOB_ON );
+			break;
+	}
+	
+	I915_WRITE( SRX_DATA, sr01 );
+ 	
+	I915_WRITE( ADPA, adpa );
+
+	return 0;
+}
+
+int i915_suspend( struct pci_dev *pdev, unsigned state ) 
+{
+	drm_device_t *dev = (drm_device_t *)pci_get_drvdata(pdev);
+	drm_i915_private_t *dev_priv =
+		(drm_i915_private_t *)dev->dev_private;
+
+	DRM_DEBUG("%s state=%d\n", __FUNCTION__, state);
+
+	if (!dev_priv) return 0;
+
+	/* Save state for power up later */
+	if (state != 0) {
+		I915_WRITE( SRX_INDEX, SR01 );
+		dev_priv->sr01 = I915_READ( SRX_DATA );
+		dev_priv->dvoc = I915_READ( DVOC );
+		dev_priv->dvob = I915_READ( DVOB );
+		dev_priv->lvds = I915_READ( LVDS );
+		dev_priv->adpa = I915_READ( ADPA );
+		dev_priv->ppcr = I915_READ( PPCR );
+	}
+
+	switch(state) {
+		case 0:
+			/* D0: set DPMS mode on */
+			i915_set_dpms(dev, 0);
+			break;
+		case 1:
+			/* D1: set DPMS mode standby */
+			i915_set_dpms(dev, 1);
+			break;
+		case 2:
+			/* D2: set DPMS mode suspend */
+			i915_set_dpms(dev, 2);
+			break;
+		case 3:
+			/* D3: set DPMS mode off */
+			i915_set_dpms(dev, 3);
+			break;
+	}
+
+	return 0;
+}
+
+int i915_resume( struct pci_dev *pdev ) 
+{
+	drm_device_t *dev = (drm_device_t *)pci_get_drvdata(pdev);
+
+	/* D0: set DPMS mode on */
+	i915_set_dpms(dev, 0);
+
+	return 0;
+}
diff -purN linux-2.6.12.orig/drivers/char/drm/imagine_drv.c linux-2.6.12/drivers/char/drm/imagine_drv.c
--- linux-2.6.12.orig/drivers/char/drm/imagine_drv.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/drm/imagine_drv.c	2005-07-05 08:37:27.000000000 +0200
@@ -0,0 +1,102 @@
+/*
+ * Copyright 2005 Adam Jackson.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * on the rights to use, copy, modify, merge, publish, distribute, sub
+ * license, and/or sell copies of the Software, and to permit persons to whom
+ * the Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
+ * ADAM JACKSON BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/* derived from tdfx_drv.c */
+
+#include <linux/config.h>
+#include "drmP.h"
+#include "imagine_drv.h"
+
+#include "drm_pciids.h"
+
+static struct drm_driver driver;
+
+static int postinit(struct drm_device *dev, unsigned long flags)
+{
+    DRM_INFO("Initialized %s %d.%d.%d %s on minor %d: %s\n",
+             DRIVER_NAME, DRIVER_MAJOR, DRIVER_MINOR, DRIVER_PATCHLEVEL,
+             DRIVER_DATE, dev->primary.minor, pci_pretty_name(dev->pdev));
+    return 0;
+}
+
+static int version(drm_version_t *version)
+{
+    int len;
+
+    version->version_major = DRIVER_MAJOR;
+    version->version_minor = DRIVER_MINOR;
+    version->version_patchlevel = DRIVER_PATCHLEVEL;
+    DRM_COPY(version->name, DRIVER_NAME);
+    DRM_COPY(version->date, DRIVER_DATE);
+    DRM_COPY(version->desc, DRIVER_DESC);
+    return 0;
+}
+
+static struct pci_device_id pciidlist[] = {
+    imagine_PCI_IDS
+};
+
+static int probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+    return drm_get_dev(pdev, ent, &driver);
+}
+
+static struct drm_driver driver = {
+    .driver_features = DRIVER_USE_MTRR,
+    .reclaim_buffers = drm_core_reclaim_buffers,
+    .get_map_ofs = drm_core_get_map_ofs,
+    .get_reg_ofs = drm_core_get_reg_ofs,
+    .postinit = postinit,
+    .version = version,
+    .fops = {
+        .owner = THIS_MODULE,
+        .open = drm_open,
+        .release = drm_release,
+        .ioctl = drm_ioctl,
+        .mmap = drm_mmap,
+        .poll = drm_poll,
+        .fasync = drm_fasync,
+    },
+    .pci_driver = {
+        .name = DRIVER_NAME,
+        .id_table = pciidlist,
+        .probe = probe,
+        .remove = __devexit_p(drm_cleanup_pci),
+    },
+};
+
+static int __init imagine_init(void)
+{
+    return drm_init(&driver, pciidlist);
+}
+
+static void __exit imagine_exit(void)
+{
+    drm_exit(&driver);
+}
+
+module_init(imagine_init);
+module_exit(imagine_exit);
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL and additional rights");
diff -purN linux-2.6.12.orig/drivers/char/drm/imagine_drv.h linux-2.6.12/drivers/char/drm/imagine_drv.h
--- linux-2.6.12.orig/drivers/char/drm/imagine_drv.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/drm/imagine_drv.h	2005-07-05 08:37:49.000000000 +0200
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2005 Adam Jackson.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * on the rights to use, copy, modify, merge, publish, distribute, sub
+ * license, and/or sell copies of the Software, and to permit persons to whom
+ * the Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
+ * ADAM JACKSON BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/* derived from tdfx_drv.h */
+
+#ifndef __IMAGINE_DRV_H__
+#define __IMAGINE_DRV_H__
+
+#define DRIVER_AUTHOR       "Adam Jackson"
+#define DRIVER_NAME         "imagine"
+#define DRIVER_DESC         "#9 Imagine128 and Ticket 2 Ride"
+#define DRIVER_DATE         "20050328"
+#define DRIVER_MAJOR        0
+#define DRIVER_MINOR        0
+#define DRIVER_PATCHLEVEL   1
+
+enum imagine_family {
+    IMAGINE_128,
+    IMAGINE_128_2,
+    IMAGINE_T2R,
+    IMAGINE_REV4
+};
+
+#endif /* __IMAGINE_DRV_H__ */
diff -purN linux-2.6.12.orig/drivers/char/drm/Kconfig linux-2.6.12/drivers/char/drm/Kconfig
--- linux-2.6.12.orig/drivers/char/drm/Kconfig	2005-07-05 08:36:22.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/Kconfig	2005-07-05 08:37:40.000000000 +0200
@@ -23,13 +22,6 @@ config DRM_TDFX
 	  Choose this option if you have a 3dfx Banshee or Voodoo3 (or later),
 	  graphics card.  If M is selected, the module will be called tdfx.
 
-config DRM_GAMMA
-	tristate "3dlabs GMX 2000"
-	depends on DRM && BROKEN
-	help
-	  This is the old gamma driver, please tell me if it might actually
-	  work.
-
 config DRM_R128
 	tristate "ATI Rage 128"
 	depends on DRM && PCI
@@ -82,17 +74,34 @@ endchoice
 
 config DRM_MGA
 	tristate "Matrox g200/g400"
-	depends on DRM && AGP
+	depends on DRM && (!X86_64 || BROKEN) && (!PPC || BROKEN)
 	help
-	  Choose this option if you have a Matrox G200, G400 or G450 graphics
-	  card.  If M is selected, the module will be called mga.  AGP
-	  support is required for this driver to work.
+	  Choose this option if you have a Matrox G200, G400, G450 or G550
+	  graphics card.  If M is selected, the module will be called mga.
 
 config DRM_SIS
 	tristate "SiS video cards"
-	depends on DRM && AGP
+	depends on DRM
 	help
 	  Choose this option if you have a SiS 630 or compatible video 
-          chipset. If M is selected the module will be called sis. AGP
-          support is required for this driver to work.
+	  chipset. If M is selected the module will be called sis.
+
+config DRM_VIA
+	tristate "Via unichrome video cards"
+	depends on DRM 
+	help
+	  Choose this option if you have a Via unichrome or compatible video 
+	  chipset. If M is selected the module will be called via.
+
+config DRM_MACH64
+	tristate "ATI Rage Pro (Mach64)"
+	depends on DRM && PCI
+	help
+	  Choose this option if you have an ATI Rage Pro (mach64 chipset)
+	  graphics card.  Example cards include:  3D Rage Pro, Xpert 98,
+	  3D Rage LT Pro, 3D Rage XL/XC, and 3D Rage Mobility (P/M, M1).
+	  Cards earlier than ATI Rage Pro (e.g. Rage II) are not supported.
+	  If M is selected, the module will be called mach64.  AGP support for
+	  this card is strongly suggested (unless you have a PCI version).
+
 
diff -purN linux-2.6.12.orig/drivers/char/drm/mach64_dma.c linux-2.6.12/drivers/char/drm/mach64_dma.c
--- linux-2.6.12.orig/drivers/char/drm/mach64_dma.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/drm/mach64_dma.c	2005-07-05 08:37:47.000000000 +0200
@@ -0,0 +1,1527 @@
+/* mach64_dma.c -- DMA support for mach64 (Rage Pro) driver -*- linux-c -*- */
+/**
+ * \file mach64_dma.c
+ * DMA support for mach64 (Rage Pro) driver
+ *
+ * \author Gareth Hughes <gareth@valinux.com>
+ * \author Frank C. Earl <fearl@airmail.net>
+ * \author Leif Delgass <ldelgass@retinalburn.net>
+ * \author Jose Fonseca <j_r_fonseca@yahoo.co.uk>
+ */
+
+/*
+ * Copyright 2000 Gareth Hughes
+ * Copyright 2002 Frank C. Earl
+ * Copyright 2002-2003 Leif Delgass
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT OWNER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "mach64_drm.h"
+#include "mach64_drv.h"
+
+/*******************************************************************/
+/** \name Engine, FIFO control */
+/*@{*/
+
+/**
+ * Waits for free entries in the FIFO.
+ *
+ * \note Most writes to Mach64 registers are automatically routed through
+ * command FIFO which is 16 entry deep. Prior to writing to any draw engine
+ * register one has to ensure that enough FIFO entries are available by calling
+ * this function.  Failure to do so may cause the engine to lock.
+ *
+ * \param dev_priv pointer to device private data structure.
+ * \param entries number of free entries in the FIFO to wait for.
+ * 
+ * \returns zero on success, or -EBUSY if the timeout (specificed by
+ * drm_mach64_private::usec_timeout) occurs.
+ */
+int mach64_do_wait_for_fifo(drm_mach64_private_t * dev_priv, int entries)
+{
+	int slots = 0, i;
+
+	for (i = 0; i < dev_priv->usec_timeout; i++) {
+		slots = (MACH64_READ(MACH64_FIFO_STAT) & MACH64_FIFO_SLOT_MASK);
+		if (slots <= (0x8000 >> entries))
+			return 0;
+		DRM_UDELAY(1);
+	}
+
+	DRM_INFO("%s failed! slots=%d entries=%d\n", __FUNCTION__, slots,
+		 entries);
+	return DRM_ERR(EBUSY);
+}
+
+/**
+ * Wait for the draw engine to be idle.
+ */
+int mach64_do_wait_for_idle(drm_mach64_private_t * dev_priv)
+{
+	int i, ret;
+
+	ret = mach64_do_wait_for_fifo(dev_priv, 16);
+	if (ret < 0)
+		return ret;
+
+	for (i = 0; i < dev_priv->usec_timeout; i++) {
+		if (!(MACH64_READ(MACH64_GUI_STAT) & MACH64_GUI_ACTIVE)) {
+			return 0;
+		}
+		DRM_UDELAY(1);
+	}
+
+	DRM_INFO("%s failed! GUI_STAT=0x%08x\n", __FUNCTION__,
+		 MACH64_READ(MACH64_GUI_STAT));
+	mach64_dump_ring_info(dev_priv);
+	return DRM_ERR(EBUSY);
+}
+
+/**
+ * Wait for free entries in the ring buffer.
+ *
+ * The Mach64 bus master can be configured to act as a virtual FIFO, using a
+ * circular buffer (commonly referred as "ring buffer" in other drivers) with
+ * pointers to engine commands. This allows the CPU to do other things while
+ * the graphics engine is busy, i.e., DMA mode.
+ *
+ * This function should be called before writing new entries to the ring
+ * buffer.
+ * 
+ * \param dev_priv pointer to device private data structure.
+ * \param n number of free entries in the ring buffer to wait for.
+ * 
+ * \returns zero on success, or -EBUSY if the timeout (specificed by
+ * drm_mach64_private_t::usec_timeout) occurs.
+ *
+ * \sa mach64_dump_ring_info()
+ */
+int mach64_wait_ring(drm_mach64_private_t * dev_priv, int n)
+{
+	drm_mach64_descriptor_ring_t *ring = &dev_priv->ring;
+	int i;
+
+	for (i = 0; i < dev_priv->usec_timeout; i++) {
+		mach64_update_ring_snapshot(dev_priv);
+		if (ring->space >= n) {
+			if (i > 0) {
+				DRM_DEBUG("%s: %d usecs\n", __FUNCTION__, i);
+			}
+			return 0;
+		}
+		DRM_UDELAY(1);
+	}
+
+	/* FIXME: This is being ignored... */
+	DRM_ERROR("failed!\n");
+	mach64_dump_ring_info(dev_priv);
+	return DRM_ERR(EBUSY);
+}
+
+/**
+ * Wait until all DMA requests have been processed... 
+ *
+ * \sa mach64_wait_ring()
+ */
+static int mach64_ring_idle(drm_mach64_private_t * dev_priv)
+{
+	drm_mach64_descriptor_ring_t *ring = &dev_priv->ring;
+	u32 head;
+	int i;
+
+	head = ring->head;
+	i = 0;
+	while (i < dev_priv->usec_timeout) {
+		mach64_update_ring_snapshot(dev_priv);
+		if (ring->head == ring->tail &&
+		    !(MACH64_READ(MACH64_GUI_STAT) & MACH64_GUI_ACTIVE)) {
+			if (i > 0) {
+				DRM_DEBUG("%s: %d usecs\n", __FUNCTION__, i);
+			}
+			return 0;
+		}
+		if (ring->head == head) {
+			++i;
+		} else {
+			head = ring->head;
+			i = 0;
+		}
+		DRM_UDELAY(1);
+	}
+
+	DRM_INFO("%s failed! GUI_STAT=0x%08x\n", __FUNCTION__,
+		 MACH64_READ(MACH64_GUI_STAT));
+	mach64_dump_ring_info(dev_priv);
+	return DRM_ERR(EBUSY);
+}
+
+/**
+ * Reset the the ring buffer descriptors.
+ *
+ * \sa mach64_do_engine_reset()
+ */
+static void mach64_ring_reset(drm_mach64_private_t * dev_priv)
+{
+	drm_mach64_descriptor_ring_t *ring = &dev_priv->ring;
+
+	mach64_do_release_used_buffers(dev_priv);
+	ring->head_addr = ring->start_addr;
+	ring->head = ring->tail = 0;
+	ring->space = ring->size;
+
+	MACH64_WRITE(MACH64_BM_GUI_TABLE_CMD,
+		     ring->head_addr | MACH64_CIRCULAR_BUF_SIZE_16KB);
+
+	dev_priv->ring_running = 0;
+}
+
+/**
+ * Ensure the all the queued commands will be processed.
+ */
+int mach64_do_dma_flush(drm_mach64_private_t * dev_priv)
+{
+	/* FIXME: It's not necessary to wait for idle when flushing
+	 * we just need to ensure the ring will be completely processed
+	 * in finite time without another ioctl
+	 */
+	return mach64_ring_idle(dev_priv);
+}
+
+/**
+ * Stop all DMA activity.
+ */
+int mach64_do_dma_idle(drm_mach64_private_t * dev_priv)
+{
+	int ret;
+
+	/* wait for completion */
+	if ((ret = mach64_ring_idle(dev_priv)) < 0) {
+		DRM_ERROR("%s failed BM_GUI_TABLE=0x%08x tail: %u\n",
+			  __FUNCTION__, MACH64_READ(MACH64_BM_GUI_TABLE),
+			  dev_priv->ring.tail);
+		return ret;
+	}
+
+	mach64_ring_stop(dev_priv);
+
+	/* clean up after pass */
+	mach64_do_release_used_buffers(dev_priv);
+	return 0;
+}
+
+/**
+ * Reset the engine.  This will stop the DMA if it is running.
+ */
+int mach64_do_engine_reset(drm_mach64_private_t * dev_priv)
+{
+	u32 tmp;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	/* Kill off any outstanding DMA transfers.
+	 */
+	tmp = MACH64_READ(MACH64_BUS_CNTL);
+	MACH64_WRITE(MACH64_BUS_CNTL, tmp | MACH64_BUS_MASTER_DIS);
+
+	/* Reset the GUI engine (high to low transition).
+	 */
+	tmp = MACH64_READ(MACH64_GEN_TEST_CNTL);
+	MACH64_WRITE(MACH64_GEN_TEST_CNTL, tmp & ~MACH64_GUI_ENGINE_ENABLE);
+	/* Enable the GUI engine
+	 */
+	tmp = MACH64_READ(MACH64_GEN_TEST_CNTL);
+	MACH64_WRITE(MACH64_GEN_TEST_CNTL, tmp | MACH64_GUI_ENGINE_ENABLE);
+
+	/* ensure engine is not locked up by clearing any FIFO or HOST errors
+	 */
+	tmp = MACH64_READ(MACH64_BUS_CNTL);
+	MACH64_WRITE(MACH64_BUS_CNTL, tmp | 0x00a00000);
+
+	/* Once GUI engine is restored, disable bus mastering */
+	MACH64_WRITE(MACH64_SRC_CNTL, 0);
+
+	/* Reset descriptor ring */
+	mach64_ring_reset(dev_priv);
+
+	return 0;
+}
+
+/*@}*/
+
+
+/*******************************************************************/
+/** \name Debugging output */
+/*@{*/
+
+/**
+ * Dump engine registers values.
+ */
+void mach64_dump_engine_info(drm_mach64_private_t * dev_priv)
+{
+	DRM_INFO("\n");
+	if (!dev_priv->is_pci) {
+		DRM_INFO("           AGP_BASE = 0x%08x\n",
+			 MACH64_READ(MACH64_AGP_BASE));
+		DRM_INFO("           AGP_CNTL = 0x%08x\n",
+			 MACH64_READ(MACH64_AGP_CNTL));
+	}
+	DRM_INFO("     ALPHA_TST_CNTL = 0x%08x\n",
+		 MACH64_READ(MACH64_ALPHA_TST_CNTL));
+	DRM_INFO("\n");
+	DRM_INFO("         BM_COMMAND = 0x%08x\n",
+		 MACH64_READ(MACH64_BM_COMMAND));
+	DRM_INFO("BM_FRAME_BUF_OFFSET = 0x%08x\n",
+		 MACH64_READ(MACH64_BM_FRAME_BUF_OFFSET));
+	DRM_INFO("       BM_GUI_TABLE = 0x%08x\n",
+		 MACH64_READ(MACH64_BM_GUI_TABLE));
+	DRM_INFO("          BM_STATUS = 0x%08x\n",
+		 MACH64_READ(MACH64_BM_STATUS));
+	DRM_INFO(" BM_SYSTEM_MEM_ADDR = 0x%08x\n",
+		 MACH64_READ(MACH64_BM_SYSTEM_MEM_ADDR));
+	DRM_INFO("    BM_SYSTEM_TABLE = 0x%08x\n",
+		 MACH64_READ(MACH64_BM_SYSTEM_TABLE));
+	DRM_INFO("           BUS_CNTL = 0x%08x\n",
+		 MACH64_READ(MACH64_BUS_CNTL));
+	DRM_INFO("\n");
+	/* DRM_INFO( "         CLOCK_CNTL = 0x%08x\n", MACH64_READ( MACH64_CLOCK_CNTL ) ); */
+	DRM_INFO("        CLR_CMP_CLR = 0x%08x\n",
+		 MACH64_READ(MACH64_CLR_CMP_CLR));
+	DRM_INFO("       CLR_CMP_CNTL = 0x%08x\n",
+		 MACH64_READ(MACH64_CLR_CMP_CNTL));
+	/* DRM_INFO( "        CLR_CMP_MSK = 0x%08x\n", MACH64_READ( MACH64_CLR_CMP_MSK ) ); */
+	DRM_INFO("     CONFIG_CHIP_ID = 0x%08x\n",
+		 MACH64_READ(MACH64_CONFIG_CHIP_ID));
+	DRM_INFO("        CONFIG_CNTL = 0x%08x\n",
+		 MACH64_READ(MACH64_CONFIG_CNTL));
+	DRM_INFO("       CONFIG_STAT0 = 0x%08x\n",
+		 MACH64_READ(MACH64_CONFIG_STAT0));
+	DRM_INFO("       CONFIG_STAT1 = 0x%08x\n",
+		 MACH64_READ(MACH64_CONFIG_STAT1));
+	DRM_INFO("       CONFIG_STAT2 = 0x%08x\n",
+		 MACH64_READ(MACH64_CONFIG_STAT2));
+	DRM_INFO("            CRC_SIG = 0x%08x\n", MACH64_READ(MACH64_CRC_SIG));
+	DRM_INFO("  CUSTOM_MACRO_CNTL = 0x%08x\n",
+		 MACH64_READ(MACH64_CUSTOM_MACRO_CNTL));
+	DRM_INFO("\n");
+	/* DRM_INFO( "           DAC_CNTL = 0x%08x\n", MACH64_READ( MACH64_DAC_CNTL ) ); */
+	/* DRM_INFO( "           DAC_REGS = 0x%08x\n", MACH64_READ( MACH64_DAC_REGS ) ); */
+	DRM_INFO("        DP_BKGD_CLR = 0x%08x\n",
+		 MACH64_READ(MACH64_DP_BKGD_CLR));
+	DRM_INFO("        DP_FRGD_CLR = 0x%08x\n",
+		 MACH64_READ(MACH64_DP_FRGD_CLR));
+	DRM_INFO("             DP_MIX = 0x%08x\n", MACH64_READ(MACH64_DP_MIX));
+	DRM_INFO("       DP_PIX_WIDTH = 0x%08x\n",
+		 MACH64_READ(MACH64_DP_PIX_WIDTH));
+	DRM_INFO("             DP_SRC = 0x%08x\n", MACH64_READ(MACH64_DP_SRC));
+	DRM_INFO("      DP_WRITE_MASK = 0x%08x\n",
+		 MACH64_READ(MACH64_DP_WRITE_MASK));
+	DRM_INFO("         DSP_CONFIG = 0x%08x\n",
+		 MACH64_READ(MACH64_DSP_CONFIG));
+	DRM_INFO("         DSP_ON_OFF = 0x%08x\n",
+		 MACH64_READ(MACH64_DSP_ON_OFF));
+	DRM_INFO("           DST_CNTL = 0x%08x\n",
+		 MACH64_READ(MACH64_DST_CNTL));
+	DRM_INFO("      DST_OFF_PITCH = 0x%08x\n",
+		 MACH64_READ(MACH64_DST_OFF_PITCH));
+	DRM_INFO("\n");
+	/* DRM_INFO( "       EXT_DAC_REGS = 0x%08x\n", MACH64_READ( MACH64_EXT_DAC_REGS ) ); */
+	DRM_INFO("       EXT_MEM_CNTL = 0x%08x\n",
+		 MACH64_READ(MACH64_EXT_MEM_CNTL));
+	DRM_INFO("\n");
+	DRM_INFO("          FIFO_STAT = 0x%08x\n",
+		 MACH64_READ(MACH64_FIFO_STAT));
+	DRM_INFO("\n");
+	DRM_INFO("      GEN_TEST_CNTL = 0x%08x\n",
+		 MACH64_READ(MACH64_GEN_TEST_CNTL));
+	/* DRM_INFO( "              GP_IO = 0x%08x\n", MACH64_READ( MACH64_GP_IO ) ); */
+	DRM_INFO("   GUI_CMDFIFO_DATA = 0x%08x\n",
+		 MACH64_READ(MACH64_GUI_CMDFIFO_DATA));
+	DRM_INFO("  GUI_CMDFIFO_DEBUG = 0x%08x\n",
+		 MACH64_READ(MACH64_GUI_CMDFIFO_DEBUG));
+	DRM_INFO("           GUI_CNTL = 0x%08x\n",
+		 MACH64_READ(MACH64_GUI_CNTL));
+	DRM_INFO("           GUI_STAT = 0x%08x\n",
+		 MACH64_READ(MACH64_GUI_STAT));
+	DRM_INFO("      GUI_TRAJ_CNTL = 0x%08x\n",
+		 MACH64_READ(MACH64_GUI_TRAJ_CNTL));
+	DRM_INFO("\n");
+	DRM_INFO("          HOST_CNTL = 0x%08x\n",
+		 MACH64_READ(MACH64_HOST_CNTL));
+	DRM_INFO("           HW_DEBUG = 0x%08x\n",
+		 MACH64_READ(MACH64_HW_DEBUG));
+	DRM_INFO("\n");
+	DRM_INFO("    MEM_ADDR_CONFIG = 0x%08x\n",
+		 MACH64_READ(MACH64_MEM_ADDR_CONFIG));
+	DRM_INFO("       MEM_BUF_CNTL = 0x%08x\n",
+		 MACH64_READ(MACH64_MEM_BUF_CNTL));
+	DRM_INFO("\n");
+	DRM_INFO("           PAT_REG0 = 0x%08x\n",
+		 MACH64_READ(MACH64_PAT_REG0));
+	DRM_INFO("           PAT_REG1 = 0x%08x\n",
+		 MACH64_READ(MACH64_PAT_REG1));
+	DRM_INFO("\n");
+	DRM_INFO("            SC_LEFT = 0x%08x\n", MACH64_READ(MACH64_SC_LEFT));
+	DRM_INFO("           SC_RIGHT = 0x%08x\n",
+		 MACH64_READ(MACH64_SC_RIGHT));
+	DRM_INFO("             SC_TOP = 0x%08x\n", MACH64_READ(MACH64_SC_TOP));
+	DRM_INFO("          SC_BOTTOM = 0x%08x\n",
+		 MACH64_READ(MACH64_SC_BOTTOM));
+	DRM_INFO("\n");
+	DRM_INFO("      SCALE_3D_CNTL = 0x%08x\n",
+		 MACH64_READ(MACH64_SCALE_3D_CNTL));
+	DRM_INFO("       SCRATCH_REG0 = 0x%08x\n",
+		 MACH64_READ(MACH64_SCRATCH_REG0));
+	DRM_INFO("       SCRATCH_REG1 = 0x%08x\n",
+		 MACH64_READ(MACH64_SCRATCH_REG1));
+	DRM_INFO("         SETUP_CNTL = 0x%08x\n",
+		 MACH64_READ(MACH64_SETUP_CNTL));
+	DRM_INFO("           SRC_CNTL = 0x%08x\n",
+		 MACH64_READ(MACH64_SRC_CNTL));
+	DRM_INFO("\n");
+	DRM_INFO("           TEX_CNTL = 0x%08x\n",
+		 MACH64_READ(MACH64_TEX_CNTL));
+	DRM_INFO("     TEX_SIZE_PITCH = 0x%08x\n",
+		 MACH64_READ(MACH64_TEX_SIZE_PITCH));
+	DRM_INFO("       TIMER_CONFIG = 0x%08x\n",
+		 MACH64_READ(MACH64_TIMER_CONFIG));
+	DRM_INFO("\n");
+	DRM_INFO("             Z_CNTL = 0x%08x\n", MACH64_READ(MACH64_Z_CNTL));
+	DRM_INFO("        Z_OFF_PITCH = 0x%08x\n",
+		 MACH64_READ(MACH64_Z_OFF_PITCH));
+	DRM_INFO("\n");
+}
+
+#define MACH64_DUMP_CONTEXT	3
+
+/**
+ * Used by mach64_dump_ring_info() to dump the contents of the current buffer
+ * pointed by the ring head.
+ */
+static void mach64_dump_buf_info(drm_mach64_private_t * dev_priv,
+				 drm_buf_t * buf)
+{
+	u32 addr = GETBUFADDR(buf);
+	u32 used = buf->used >> 2;
+	u32 sys_addr = MACH64_READ(MACH64_BM_SYSTEM_MEM_ADDR);
+	u32 *p = GETBUFPTR(buf);
+	int skipped = 0;
+
+	DRM_INFO("buffer contents:\n");
+
+	while (used) {
+		u32 reg, count;
+
+		reg = le32_to_cpu(*p++);
+		if (addr <= GETBUFADDR(buf) + MACH64_DUMP_CONTEXT * 4 ||
+		    (addr >= sys_addr - MACH64_DUMP_CONTEXT * 4 &&
+		     addr <= sys_addr + MACH64_DUMP_CONTEXT * 4) ||
+		    addr >=
+		    GETBUFADDR(buf) + buf->used - MACH64_DUMP_CONTEXT * 4) {
+			DRM_INFO("%08x:  0x%08x\n", addr, reg);
+		}
+		addr += 4;
+		used--;
+
+		count = (reg >> 16) + 1;
+		reg = reg & 0xffff;
+		reg = MMSELECT(reg);
+		while (count && used) {
+			if (addr <= GETBUFADDR(buf) + MACH64_DUMP_CONTEXT * 4 ||
+			    (addr >= sys_addr - MACH64_DUMP_CONTEXT * 4 &&
+			     addr <= sys_addr + MACH64_DUMP_CONTEXT * 4) ||
+			    addr >=
+			    GETBUFADDR(buf) + buf->used -
+			    MACH64_DUMP_CONTEXT * 4) {
+				DRM_INFO("%08x:    0x%04x = 0x%08x\n", addr,
+					 reg, le32_to_cpu(*p));
+				skipped = 0;
+			} else {
+				if (!skipped) {
+					DRM_INFO("  ...\n");
+					skipped = 1;
+				}
+			}
+			p++;
+			addr += 4;
+			used--;
+
+			reg += 4;
+			count--;
+		}
+	}
+
+	DRM_INFO("\n");
+}
+
+/**
+ * Dump the ring state and contents, including the contents of the buffer being
+ * processed by the graphics engine.
+ */
+void mach64_dump_ring_info(drm_mach64_private_t * dev_priv)
+{
+	drm_mach64_descriptor_ring_t *ring = &dev_priv->ring;
+	int i, skipped;
+
+	DRM_INFO("\n");
+
+	DRM_INFO("ring contents:\n");
+	DRM_INFO("  head_addr: 0x%08x head: %u tail: %u\n\n",
+		 ring->head_addr, ring->head, ring->tail);
+
+	skipped = 0;
+	for (i = 0; i < ring->size / sizeof(u32); i += 4) {
+		if (i <= MACH64_DUMP_CONTEXT * 4 ||
+		    i >= ring->size / sizeof(u32) - MACH64_DUMP_CONTEXT * 4 ||
+		    (i >= ring->tail - MACH64_DUMP_CONTEXT * 4 &&
+		     i <= ring->tail + MACH64_DUMP_CONTEXT * 4) ||
+		    (i >= ring->head - MACH64_DUMP_CONTEXT * 4 &&
+		     i <= ring->head + MACH64_DUMP_CONTEXT * 4)) {
+			DRM_INFO("  0x%08x:  0x%08x 0x%08x 0x%08x 0x%08x%s%s\n",
+				 (u32)(ring->start_addr + i * sizeof(u32)),
+				 le32_to_cpu(((u32 *) ring->start)[i + 0]),
+				 le32_to_cpu(((u32 *) ring->start)[i + 1]),
+				 le32_to_cpu(((u32 *) ring->start)[i + 2]),
+				 le32_to_cpu(((u32 *) ring->start)[i + 3]),
+				 i == ring->head ? " (head)" : "",
+				 i == ring->tail ? " (tail)" : "");
+			skipped = 0;
+		} else {
+			if (!skipped) {
+				DRM_INFO("  ...\n");
+				skipped = 1;
+			}
+		}
+	}
+
+	DRM_INFO("\n");
+
+	if (ring->head >= 0 && ring->head < ring->size / sizeof(u32)) {
+		struct list_head *ptr;
+		u32 addr = le32_to_cpu(((u32 *) ring->start)[ring->head + 1]);
+
+		list_for_each(ptr, &dev_priv->pending) {
+			drm_mach64_freelist_t *entry =
+			    list_entry(ptr, drm_mach64_freelist_t, list);
+			drm_buf_t *buf = entry->buf;
+
+			u32 buf_addr = GETBUFADDR(buf);
+
+			if (buf_addr <= addr && addr < buf_addr + buf->used) {
+				mach64_dump_buf_info(dev_priv, buf);
+			}
+		}
+	}
+
+	DRM_INFO("\n");
+	DRM_INFO("       BM_GUI_TABLE = 0x%08x\n",
+		 MACH64_READ(MACH64_BM_GUI_TABLE));
+	DRM_INFO("\n");
+	DRM_INFO("BM_FRAME_BUF_OFFSET = 0x%08x\n",
+		 MACH64_READ(MACH64_BM_FRAME_BUF_OFFSET));
+	DRM_INFO(" BM_SYSTEM_MEM_ADDR = 0x%08x\n",
+		 MACH64_READ(MACH64_BM_SYSTEM_MEM_ADDR));
+	DRM_INFO("         BM_COMMAND = 0x%08x\n",
+		 MACH64_READ(MACH64_BM_COMMAND));
+	DRM_INFO("\n");
+	DRM_INFO("          BM_STATUS = 0x%08x\n",
+		 MACH64_READ(MACH64_BM_STATUS));
+	DRM_INFO("           BUS_CNTL = 0x%08x\n",
+		 MACH64_READ(MACH64_BUS_CNTL));
+	DRM_INFO("          FIFO_STAT = 0x%08x\n",
+		 MACH64_READ(MACH64_FIFO_STAT));
+	DRM_INFO("           GUI_STAT = 0x%08x\n",
+		 MACH64_READ(MACH64_GUI_STAT));
+	DRM_INFO("           SRC_CNTL = 0x%08x\n",
+		 MACH64_READ(MACH64_SRC_CNTL));
+}
+
+/*@}*/
+
+
+/*******************************************************************/
+/** \name DMA test and initialization */
+/*@{*/
+
+/**
+ * Perform a simple DMA operation using the pattern registers to test whether
+ * DMA works.
+ *
+ * \return zero if successful.
+ *
+ * \note This function was the testbed for many experiences regarding Mach64
+ * DMA operation. It is left here since it so tricky to get DMA operating
+ * properly in some architectures and hardware.
+ */
+static int mach64_bm_dma_test(drm_device_t * dev)
+{
+	drm_mach64_private_t *dev_priv = dev->dev_private;
+	drm_dma_handle_t *cpu_addr_dmah;
+	u32 data_addr;
+	u32 *table, *data;
+	u32 expected[2];
+	u32 src_cntl, pat_reg0, pat_reg1;
+	int i, count, failed;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	table = (u32 *) dev_priv->ring.start;
+
+	/* FIXME: get a dma buffer from the freelist here */
+	DRM_DEBUG("Allocating data memory ...\n");
+	cpu_addr_dmah =
+	    drm_pci_alloc(dev, 0x1000, 0x1000, 0xfffffffful);
+	if (!cpu_addr_dmah) {
+		DRM_INFO("data-memory allocation failed!\n");
+		return DRM_ERR(ENOMEM);
+	} else {
+		data = (u32 *) cpu_addr_dmah->vaddr;
+		data_addr = (u32) cpu_addr_dmah->busaddr;
+	}
+
+	/* Save the X server's value for SRC_CNTL and restore it
+	 * in case our test fails.  This prevents the X server
+	 * from disabling it's cache for this register
+	 */
+	src_cntl = MACH64_READ(MACH64_SRC_CNTL);
+	pat_reg0 = MACH64_READ(MACH64_PAT_REG0);
+	pat_reg1 = MACH64_READ(MACH64_PAT_REG1);
+
+	mach64_do_wait_for_fifo(dev_priv, 3);
+
+	MACH64_WRITE(MACH64_SRC_CNTL, 0);
+	MACH64_WRITE(MACH64_PAT_REG0, 0x11111111);
+	MACH64_WRITE(MACH64_PAT_REG1, 0x11111111);
+
+	mach64_do_wait_for_idle(dev_priv);
+
+	for (i = 0; i < 2; i++) {
+		u32 reg;
+		reg = MACH64_READ((MACH64_PAT_REG0 + i * 4));
+		DRM_DEBUG("(Before DMA Transfer) reg %d = 0x%08x\n", i, reg);
+		if (reg != 0x11111111) {
+			DRM_INFO("Error initializing test registers\n");
+			DRM_INFO("resetting engine ...\n");
+			mach64_do_engine_reset(dev_priv);
+			DRM_INFO("freeing data buffer memory.\n");
+			drm_pci_free(dev, cpu_addr_dmah);
+			return DRM_ERR(EIO);
+		}
+	}
+
+	/* fill up a buffer with sets of 2 consecutive writes starting with PAT_REG0 */
+	count = 0;
+
+	data[count++] = cpu_to_le32(DMAREG(MACH64_PAT_REG0) | (1 << 16));
+	data[count++] = expected[0] = 0x22222222;
+	data[count++] = expected[1] = 0xaaaaaaaa;
+
+	while (count < 1020) {
+		data[count++] =
+		    cpu_to_le32(DMAREG(MACH64_PAT_REG0) | (1 << 16));
+		data[count++] = 0x22222222;
+		data[count++] = 0xaaaaaaaa;
+	}
+	data[count++] = cpu_to_le32(DMAREG(MACH64_SRC_CNTL) | (0 << 16));
+	data[count++] = 0;
+
+	DRM_DEBUG("Preparing table ...\n");
+	table[MACH64_DMA_FRAME_BUF_OFFSET] = cpu_to_le32(MACH64_BM_ADDR +
+							 MACH64_APERTURE_OFFSET);
+	table[MACH64_DMA_SYS_MEM_ADDR] = cpu_to_le32(data_addr);
+	table[MACH64_DMA_COMMAND] = cpu_to_le32(count * sizeof(u32)
+						| MACH64_DMA_HOLD_OFFSET
+						| MACH64_DMA_EOL);
+	table[MACH64_DMA_RESERVED] = 0;
+
+	DRM_DEBUG("table[0] = 0x%08x\n", table[0]);
+	DRM_DEBUG("table[1] = 0x%08x\n", table[1]);
+	DRM_DEBUG("table[2] = 0x%08x\n", table[2]);
+	DRM_DEBUG("table[3] = 0x%08x\n", table[3]);
+
+	for (i = 0; i < 6; i++) {
+		DRM_DEBUG(" data[%d] = 0x%08x\n", i, data[i]);
+	}
+	DRM_DEBUG(" ...\n");
+	for (i = count - 5; i < count; i++) {
+		DRM_DEBUG(" data[%d] = 0x%08x\n", i, data[i]);
+	}
+
+	DRM_MEMORYBARRIER();
+
+	DRM_DEBUG("waiting for idle...\n");
+	if ((i = mach64_do_wait_for_idle(dev_priv))) {
+		DRM_INFO("mach64_do_wait_for_idle failed (result=%d)\n", i);
+		DRM_INFO("resetting engine ...\n");
+		mach64_do_engine_reset(dev_priv);
+		mach64_do_wait_for_fifo(dev_priv, 3);
+		MACH64_WRITE(MACH64_SRC_CNTL, src_cntl);
+		MACH64_WRITE(MACH64_PAT_REG0, pat_reg0);
+		MACH64_WRITE(MACH64_PAT_REG1, pat_reg1);
+		DRM_INFO("freeing data buffer memory.\n");
+		drm_pci_free(dev, cpu_addr_dmah);
+		return i;
+	}
+	DRM_DEBUG("waiting for idle...done\n");
+
+	DRM_DEBUG("BUS_CNTL = 0x%08x\n", MACH64_READ(MACH64_BUS_CNTL));
+	DRM_DEBUG("SRC_CNTL = 0x%08x\n", MACH64_READ(MACH64_SRC_CNTL));
+	DRM_DEBUG("\n");
+	DRM_DEBUG("data bus addr = 0x%08x\n", data_addr);
+	DRM_DEBUG("table bus addr = 0x%08x\n", dev_priv->ring.start_addr);
+
+	DRM_DEBUG("starting DMA transfer...\n");
+	MACH64_WRITE(MACH64_BM_GUI_TABLE_CMD,
+		     dev_priv->ring.start_addr | MACH64_CIRCULAR_BUF_SIZE_16KB);
+
+	MACH64_WRITE(MACH64_SRC_CNTL,
+		     MACH64_SRC_BM_ENABLE | MACH64_SRC_BM_SYNC |
+		     MACH64_SRC_BM_OP_SYSTEM_TO_REG);
+
+	/* Kick off the transfer */
+	DRM_DEBUG("starting DMA transfer... done.\n");
+	MACH64_WRITE(MACH64_DST_HEIGHT_WIDTH, 0);
+
+	DRM_DEBUG("waiting for idle...\n");
+
+	if ((i = mach64_do_wait_for_idle(dev_priv))) {
+		/* engine locked up, dump register state and reset */
+		DRM_INFO("mach64_do_wait_for_idle failed (result=%d)\n", i);
+		mach64_dump_engine_info(dev_priv);
+		DRM_INFO("resetting engine ...\n");
+		mach64_do_engine_reset(dev_priv);
+		mach64_do_wait_for_fifo(dev_priv, 3);
+		MACH64_WRITE(MACH64_SRC_CNTL, src_cntl);
+		MACH64_WRITE(MACH64_PAT_REG0, pat_reg0);
+		MACH64_WRITE(MACH64_PAT_REG1, pat_reg1);
+		DRM_INFO("freeing data buffer memory.\n");
+		drm_pci_free(dev, cpu_addr_dmah);
+		return i;
+	}
+
+	DRM_DEBUG("waiting for idle...done\n");
+
+	/* restore SRC_CNTL */
+	mach64_do_wait_for_fifo(dev_priv, 1);
+	MACH64_WRITE(MACH64_SRC_CNTL, src_cntl);
+
+	failed = 0;
+
+	/* Check register values to see if the GUI master operation succeeded */
+	for (i = 0; i < 2; i++) {
+		u32 reg;
+		reg = MACH64_READ((MACH64_PAT_REG0 + i * 4));
+		DRM_DEBUG("(After DMA Transfer) reg %d = 0x%08x\n", i, reg);
+		if (reg != expected[i]) {
+			failed = -1;
+		}
+	}
+
+	/* restore pattern registers */
+	mach64_do_wait_for_fifo(dev_priv, 2);
+	MACH64_WRITE(MACH64_PAT_REG0, pat_reg0);
+	MACH64_WRITE(MACH64_PAT_REG1, pat_reg1);
+
+	DRM_DEBUG("freeing data buffer memory.\n");
+	drm_pci_free(dev, cpu_addr_dmah);
+	DRM_DEBUG("returning ...\n");
+
+	return failed;
+}
+
+/**
+ * Called during the DMA initialization ioctl to initialize all the necessary
+ * software and hardware state for DMA operation.
+ */
+static int mach64_do_dma_init(drm_device_t * dev, drm_mach64_init_t * init)
+{
+	drm_mach64_private_t *dev_priv;
+	u32 tmp;
+	int i, ret;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	dev_priv = drm_alloc(sizeof(drm_mach64_private_t), DRM_MEM_DRIVER);
+	if (dev_priv == NULL)
+		return DRM_ERR(ENOMEM);
+
+	memset(dev_priv, 0, sizeof(drm_mach64_private_t));
+
+	dev_priv->is_pci = init->is_pci;
+
+	dev_priv->fb_bpp = init->fb_bpp;
+	dev_priv->front_offset = init->front_offset;
+	dev_priv->front_pitch = init->front_pitch;
+	dev_priv->back_offset = init->back_offset;
+	dev_priv->back_pitch = init->back_pitch;
+
+	dev_priv->depth_bpp = init->depth_bpp;
+	dev_priv->depth_offset = init->depth_offset;
+	dev_priv->depth_pitch = init->depth_pitch;
+
+	dev_priv->front_offset_pitch = (((dev_priv->front_pitch / 8) << 22) |
+					(dev_priv->front_offset >> 3));
+	dev_priv->back_offset_pitch = (((dev_priv->back_pitch / 8) << 22) |
+				       (dev_priv->back_offset >> 3));
+	dev_priv->depth_offset_pitch = (((dev_priv->depth_pitch / 8) << 22) |
+					(dev_priv->depth_offset >> 3));
+
+	dev_priv->usec_timeout = 1000000;
+
+	/* Set up the freelist, placeholder list and pending list */
+	INIT_LIST_HEAD(&dev_priv->free_list);
+	INIT_LIST_HEAD(&dev_priv->placeholders);
+	INIT_LIST_HEAD(&dev_priv->pending);
+
+	DRM_GETSAREA();
+
+	if (!dev_priv->sarea) {
+		DRM_ERROR("can not find sarea!\n");
+		dev->dev_private = (void *)dev_priv;
+		mach64_do_cleanup_dma(dev);
+		return DRM_ERR(EINVAL);
+	}
+	dev_priv->fb = drm_core_findmap(dev, init->fb_offset);
+	if (!dev_priv->fb) {
+		DRM_ERROR("can not find frame buffer map!\n");
+		dev->dev_private = (void *)dev_priv;
+		mach64_do_cleanup_dma(dev);
+		return DRM_ERR(EINVAL);
+	}
+	dev_priv->mmio = drm_core_findmap(dev, init->mmio_offset);
+	if (!dev_priv->mmio) {
+		DRM_ERROR("can not find mmio map!\n");
+		dev->dev_private = (void *)dev_priv;
+		mach64_do_cleanup_dma(dev);
+		return DRM_ERR(EINVAL);
+	}
+
+	dev_priv->sarea_priv = (drm_mach64_sarea_t *)
+	    ((u8 *) dev_priv->sarea->handle + init->sarea_priv_offset);
+
+	if (!dev_priv->is_pci) {
+		dev_priv->ring_map = drm_core_findmap(dev, init->ring_offset);
+		if (!dev_priv->ring_map) {
+			DRM_ERROR("can not find ring map!\n");
+			dev->dev_private = (void *)dev_priv;
+			mach64_do_cleanup_dma(dev);
+			return DRM_ERR(EINVAL);
+		}
+		drm_core_ioremap(dev_priv->ring_map, dev);
+		if (!dev_priv->ring_map->handle) {
+			DRM_ERROR("can not ioremap virtual address for"
+				  " descriptor ring\n");
+			dev->dev_private = (void *)dev_priv;
+			mach64_do_cleanup_dma(dev);
+			return DRM_ERR(ENOMEM);
+		}
+		dev->agp_buffer_map =
+		    drm_core_findmap(dev, init->buffers_offset);
+		if (!dev->agp_buffer_map) {
+			DRM_ERROR("can not find dma buffer map!\n");
+			dev->dev_private = (void *)dev_priv;
+			mach64_do_cleanup_dma(dev);
+			return DRM_ERR(EINVAL);
+		}
+		/* there might be a nicer way to do this -
+		   dev isn't passed all the way though the mach64 - DA */
+		dev_priv->dev_buffers = dev->agp_buffer_map;
+
+		drm_core_ioremap(dev->agp_buffer_map, dev);
+		if (!dev->agp_buffer_map->handle) {
+			DRM_ERROR("can not ioremap virtual address for"
+				  " dma buffer\n");
+			dev->dev_private = (void *)dev_priv;
+			mach64_do_cleanup_dma(dev);
+			return DRM_ERR(ENOMEM);
+		}
+		dev_priv->agp_textures =
+		    drm_core_findmap(dev, init->agp_textures_offset);
+		if (!dev_priv->agp_textures) {
+			DRM_ERROR("can not find agp texture region!\n");
+			dev->dev_private = (void *)dev_priv;
+			mach64_do_cleanup_dma(dev);
+			return DRM_ERR(EINVAL);
+		}
+	}
+
+	dev->dev_private = (void *)dev_priv;
+
+	dev_priv->driver_mode = init->dma_mode;
+
+	/* changing the FIFO size from the default causes problems with DMA */
+	tmp = MACH64_READ(MACH64_GUI_CNTL);
+	if ((tmp & MACH64_CMDFIFO_SIZE_MASK) != MACH64_CMDFIFO_SIZE_128) {
+		DRM_INFO("Setting FIFO size to 128 entries\n");
+		/* FIFO must be empty to change the FIFO depth */
+		if ((ret = mach64_do_wait_for_idle(dev_priv))) {
+			DRM_ERROR
+			    ("wait for idle failed before changing FIFO depth!\n");
+			mach64_do_cleanup_dma(dev);
+			return ret;
+		}
+		MACH64_WRITE(MACH64_GUI_CNTL, ((tmp & ~MACH64_CMDFIFO_SIZE_MASK)
+					       | MACH64_CMDFIFO_SIZE_128));
+		/* need to read GUI_STAT for proper sync according to docs */
+		if ((ret = mach64_do_wait_for_idle(dev_priv))) {
+			DRM_ERROR
+			    ("wait for idle failed when changing FIFO depth!\n");
+			mach64_do_cleanup_dma(dev);
+			return ret;
+		}
+	}
+
+	/* allocate descriptor memory from pci pool */
+	DRM_DEBUG("Allocating dma descriptor ring\n");
+	dev_priv->ring.size = 0x4000;	/* 16KB */
+
+	if (dev_priv->is_pci) {
+		dev_priv->ring.dmah = drm_pci_alloc(dev, dev_priv->ring.size,
+						     dev_priv->ring.size,
+						     0xfffffffful);
+
+		if (!dev_priv->ring.dmah) {
+			DRM_ERROR("Allocating dma descriptor ring failed\n");
+			return DRM_ERR(ENOMEM);
+		} else {
+			dev_priv->ring.start = dev_priv->ring.dmah->vaddr;
+			dev_priv->ring.start_addr =
+			    (u32) dev_priv->ring.dmah->busaddr;
+		}
+	} else {
+		dev_priv->ring.start = dev_priv->ring_map->handle;
+		dev_priv->ring.start_addr = (u32) dev_priv->ring_map->offset;
+	}
+
+	memset(dev_priv->ring.start, 0, dev_priv->ring.size);
+	DRM_INFO("descriptor ring: cpu addr %p, bus addr: 0x%08x\n",
+		 dev_priv->ring.start, dev_priv->ring.start_addr);
+
+	ret = 0;
+	if (dev_priv->driver_mode != MACH64_MODE_MMIO) {
+
+		/* enable block 1 registers and bus mastering */
+		MACH64_WRITE(MACH64_BUS_CNTL, ((MACH64_READ(MACH64_BUS_CNTL)
+						| MACH64_BUS_EXT_REG_EN)
+					       & ~MACH64_BUS_MASTER_DIS));
+
+		/* try a DMA GUI-mastering pass and fall back to MMIO if it fails */
+		DRM_DEBUG("Starting DMA test...\n");
+		if ((ret = mach64_bm_dma_test(dev))) {
+			dev_priv->driver_mode = MACH64_MODE_MMIO;
+		}
+	}
+
+	switch (dev_priv->driver_mode) {
+	case MACH64_MODE_MMIO:
+		MACH64_WRITE(MACH64_BUS_CNTL, (MACH64_READ(MACH64_BUS_CNTL)
+					       | MACH64_BUS_EXT_REG_EN
+					       | MACH64_BUS_MASTER_DIS));
+		if (init->dma_mode == MACH64_MODE_MMIO)
+			DRM_INFO("Forcing pseudo-DMA mode\n");
+		else
+			DRM_INFO
+			    ("DMA test failed (ret=%d), using pseudo-DMA mode\n",
+			     ret);
+		break;
+	case MACH64_MODE_DMA_SYNC:
+		DRM_INFO("DMA test succeeded, using synchronous DMA mode\n");
+		break;
+	case MACH64_MODE_DMA_ASYNC:
+	default:
+		DRM_INFO("DMA test succeeded, using asynchronous DMA mode\n");
+	}
+
+	dev_priv->ring_running = 0;
+
+	/* setup offsets for physical address of table start and end */
+	dev_priv->ring.head_addr = dev_priv->ring.start_addr;
+	dev_priv->ring.head = dev_priv->ring.tail = 0;
+	dev_priv->ring.tail_mask = (dev_priv->ring.size / sizeof(u32)) - 1;
+	dev_priv->ring.space = dev_priv->ring.size;
+
+	/* setup physical address and size of descriptor table */
+	mach64_do_wait_for_fifo(dev_priv, 1);
+	MACH64_WRITE(MACH64_BM_GUI_TABLE_CMD,
+		     (dev_priv->ring.
+		      head_addr | MACH64_CIRCULAR_BUF_SIZE_16KB));
+
+	/* init frame counter */
+	dev_priv->sarea_priv->frames_queued = 0;
+	for (i = 0; i < MACH64_MAX_QUEUED_FRAMES; i++) {
+		dev_priv->frame_ofs[i] = ~0;	/* All ones indicates placeholder */
+	}
+
+	/* Allocate the DMA buffer freelist */
+	if ((ret = mach64_init_freelist(dev))) {
+		DRM_ERROR("Freelist allocation failed\n");
+		mach64_do_cleanup_dma(dev);
+		return ret;
+	}
+
+	return 0;
+}
+
+/*******************************************************************/
+/** MMIO Pseudo-DMA (intended primarily for debugging, not performance)
+ */
+
+int mach64_do_dispatch_pseudo_dma(drm_mach64_private_t * dev_priv)
+{
+	drm_mach64_descriptor_ring_t *ring = &dev_priv->ring;
+	volatile u32 *ring_read;
+	struct list_head *ptr;
+	drm_mach64_freelist_t *entry;
+	drm_buf_t *buf = NULL;
+	u32 *buf_ptr;
+	u32 used, reg, target;
+	int fifo, count, found, ret, no_idle_wait;
+
+	fifo = count = reg = no_idle_wait = 0;
+	target = MACH64_BM_ADDR;
+
+	if ((ret = mach64_do_wait_for_idle(dev_priv)) < 0) {
+		DRM_INFO
+		    ("%s: idle failed before pseudo-dma dispatch, resetting engine\n",
+		     __FUNCTION__);
+		mach64_dump_engine_info(dev_priv);
+		mach64_do_engine_reset(dev_priv);
+		return ret;
+	}
+
+	ring_read = (u32 *) ring->start;
+
+	while (ring->tail != ring->head) {
+		u32 buf_addr, new_target, offset;
+		u32 bytes, remaining, head, eol;
+
+		head = ring->head;
+
+		new_target =
+		    le32_to_cpu(ring_read[head++]) - MACH64_APERTURE_OFFSET;
+		buf_addr = le32_to_cpu(ring_read[head++]);
+		eol = le32_to_cpu(ring_read[head]) & MACH64_DMA_EOL;
+		bytes = le32_to_cpu(ring_read[head++])
+		    & ~(MACH64_DMA_HOLD_OFFSET | MACH64_DMA_EOL);
+		head++;
+		head &= ring->tail_mask;
+
+		/* can't wait for idle between a blit setup descriptor
+		 * and a HOSTDATA descriptor or the engine will lock
+		 */
+		if (new_target == MACH64_BM_HOSTDATA
+		    && target == MACH64_BM_ADDR)
+			no_idle_wait = 1;
+
+		target = new_target;
+
+		found = 0;
+		offset = 0;
+		list_for_each(ptr, &dev_priv->pending) {
+			entry = list_entry(ptr, drm_mach64_freelist_t, list);
+			buf = entry->buf;
+			offset = buf_addr - GETBUFADDR(buf);
+			if (offset >= 0 && offset < MACH64_BUFFER_SIZE) {
+				found = 1;
+				break;
+			}
+		}
+
+		if (!found || buf == NULL) {
+			DRM_ERROR
+			    ("Couldn't find pending buffer: head: %u tail: %u buf_addr: 0x%08x %s\n",
+			     head, ring->tail, buf_addr, (eol ? "eol" : ""));
+			mach64_dump_ring_info(dev_priv);
+			mach64_do_engine_reset(dev_priv);
+			return DRM_ERR(EINVAL);
+		}
+
+		/* Hand feed the buffer to the card via MMIO, waiting for the fifo
+		 * every 16 writes
+		 */
+		DRM_DEBUG("target: (0x%08x) %s\n", target,
+			  (target ==
+			   MACH64_BM_HOSTDATA ? "BM_HOSTDATA" : "BM_ADDR"));
+		DRM_DEBUG("offset: %u bytes: %u used: %u\n", offset, bytes,
+			  buf->used);
+
+		remaining = (buf->used - offset) >> 2;	/* dwords remaining in buffer */
+		used = bytes >> 2;	/* dwords in buffer for this descriptor */
+		buf_ptr = (u32 *) ((char *)GETBUFPTR(buf) + offset);
+
+		while (used) {
+
+			if (count == 0) {
+				if (target == MACH64_BM_HOSTDATA) {
+					reg = DMAREG(MACH64_HOST_DATA0);
+					count =
+					    (remaining > 16) ? 16 : remaining;
+					fifo = 0;
+				} else {
+					reg = le32_to_cpu(*buf_ptr++);
+					used--;
+					count = (reg >> 16) + 1;
+				}
+
+				reg = reg & 0xffff;
+				reg = MMSELECT(reg);
+			}
+			while (count && used) {
+				if (!fifo) {
+					if (no_idle_wait) {
+						if ((ret =
+						     mach64_do_wait_for_fifo
+						     (dev_priv, 16)) < 0) {
+							no_idle_wait = 0;
+							return ret;
+						}
+					} else {
+						if ((ret =
+						     mach64_do_wait_for_idle
+						     (dev_priv)) < 0) {
+							return ret;
+						}
+					}
+					fifo = 16;
+				}
+				--fifo;
+				MACH64_WRITE(reg, le32_to_cpu(*buf_ptr++));
+				used--;
+				remaining--;
+
+				reg += 4;
+				count--;
+			}
+		}
+		ring->head = head;
+		ring->head_addr = ring->start_addr + (ring->head * sizeof(u32));
+		ring->space += (4 * sizeof(u32));
+	}
+
+	if ((ret = mach64_do_wait_for_idle(dev_priv)) < 0) {
+		return ret;
+	}
+	MACH64_WRITE(MACH64_BM_GUI_TABLE_CMD,
+		     ring->head_addr | MACH64_CIRCULAR_BUF_SIZE_16KB);
+
+	DRM_DEBUG("%s completed\n", __FUNCTION__);
+	return 0;
+}
+
+/*@}*/
+
+
+/*******************************************************************/
+/** \name DMA cleanup */
+/*@{*/
+
+int mach64_do_cleanup_dma(drm_device_t * dev)
+{
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	/* Make sure interrupts are disabled here because the uninstall ioctl
+	 * may not have been called from userspace and after dev_private
+	 * is freed, it's too late.
+	 */
+	if (dev->irq)
+		drm_irq_uninstall(dev);
+
+	if (dev->dev_private) {
+		drm_mach64_private_t *dev_priv = dev->dev_private;
+
+		if (dev_priv->is_pci) {
+			if (dev_priv->ring.dmah) {
+				drm_pci_free(dev, dev_priv->ring.dmah);
+			}
+		} else {
+			if (dev_priv->ring_map)
+				drm_core_ioremapfree(dev_priv->ring_map, dev);
+		}
+
+		if (dev->agp_buffer_map) {
+			drm_core_ioremapfree(dev->agp_buffer_map, dev);
+			dev->agp_buffer_map = NULL;
+		}
+
+		mach64_destroy_freelist(dev);
+
+		drm_free(dev_priv, sizeof(drm_mach64_private_t),
+			 DRM_MEM_DRIVER);
+		dev->dev_private = NULL;
+	}
+
+	return 0;
+}
+
+/*@}*/
+
+
+/*******************************************************************/
+/** \name IOCTL handlers */
+/*@{*/
+
+int mach64_dma_init(DRM_IOCTL_ARGS)
+{
+	DRM_DEVICE;
+	drm_mach64_init_t init;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	LOCK_TEST_WITH_RETURN(dev, filp);
+
+	DRM_COPY_FROM_USER_IOCTL(init, (drm_mach64_init_t *) data,
+				 sizeof(init));
+
+	switch (init.func) {
+	case DRM_MACH64_INIT_DMA:
+		return mach64_do_dma_init(dev, &init);
+	case DRM_MACH64_CLEANUP_DMA:
+		return mach64_do_cleanup_dma(dev);
+	}
+
+	return DRM_ERR(EINVAL);
+}
+
+int mach64_dma_idle(DRM_IOCTL_ARGS)
+{
+	DRM_DEVICE;
+	drm_mach64_private_t *dev_priv = dev->dev_private;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	LOCK_TEST_WITH_RETURN(dev, filp);
+
+	return mach64_do_dma_idle(dev_priv);
+}
+
+int mach64_dma_flush(DRM_IOCTL_ARGS)
+{
+	DRM_DEVICE;
+	drm_mach64_private_t *dev_priv = dev->dev_private;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	LOCK_TEST_WITH_RETURN(dev, filp);
+
+	return mach64_do_dma_flush(dev_priv);
+}
+
+int mach64_engine_reset(DRM_IOCTL_ARGS)
+{
+	DRM_DEVICE;
+	drm_mach64_private_t *dev_priv = dev->dev_private;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	LOCK_TEST_WITH_RETURN(dev, filp);
+
+	return mach64_do_engine_reset(dev_priv);
+}
+
+/*@}*/
+
+
+/*******************************************************************/
+/** \name Freelist management */
+/*@{*/
+
+int mach64_init_freelist(drm_device_t * dev)
+{
+	drm_device_dma_t *dma = dev->dma;
+	drm_mach64_private_t *dev_priv = dev->dev_private;
+	drm_mach64_freelist_t *entry;
+	struct list_head *ptr;
+	int i;
+
+	DRM_DEBUG("%s: adding %d buffers to freelist\n", __FUNCTION__,
+		  dma->buf_count);
+
+	for (i = 0; i < dma->buf_count; i++) {
+		if ((entry =
+		     (drm_mach64_freelist_t *)
+		     drm_alloc(sizeof(drm_mach64_freelist_t),
+			       DRM_MEM_BUFLISTS)) == NULL)
+			return DRM_ERR(ENOMEM);
+		memset(entry, 0, sizeof(drm_mach64_freelist_t));
+		entry->buf = dma->buflist[i];
+		ptr = &entry->list;
+		list_add_tail(ptr, &dev_priv->free_list);
+	}
+
+	return 0;
+}
+
+void mach64_destroy_freelist(drm_device_t * dev)
+{
+	drm_mach64_private_t *dev_priv = dev->dev_private;
+	drm_mach64_freelist_t *entry;
+	struct list_head *ptr;
+	struct list_head *tmp;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	list_for_each_safe(ptr, tmp, &dev_priv->pending) {
+		list_del(ptr);
+		entry = list_entry(ptr, drm_mach64_freelist_t, list);
+		drm_free(entry, sizeof(*entry), DRM_MEM_BUFLISTS);
+	}
+	list_for_each_safe(ptr, tmp, &dev_priv->placeholders) {
+		list_del(ptr);
+		entry = list_entry(ptr, drm_mach64_freelist_t, list);
+		drm_free(entry, sizeof(*entry), DRM_MEM_BUFLISTS);
+	}
+
+	list_for_each_safe(ptr, tmp, &dev_priv->free_list) {
+		list_del(ptr);
+		entry = list_entry(ptr, drm_mach64_freelist_t, list);
+		drm_free(entry, sizeof(*entry), DRM_MEM_BUFLISTS);
+	}
+}
+
+/* IMPORTANT: This function should only be called when the engine is idle or locked up,
+ * as it assumes all buffers in the pending list have been completed by the hardware.
+ */
+int mach64_do_release_used_buffers(drm_mach64_private_t * dev_priv)
+{
+	struct list_head *ptr;
+	struct list_head *tmp;
+	drm_mach64_freelist_t *entry;
+	int i;
+
+	if (list_empty(&dev_priv->pending))
+		return 0;
+
+	/* Iterate the pending list and move all buffers into the freelist... */
+	i = 0;
+	list_for_each_safe(ptr, tmp, &dev_priv->pending) {
+		entry = list_entry(ptr, drm_mach64_freelist_t, list);
+		if (entry->discard) {
+			entry->buf->pending = 0;
+			list_del(ptr);
+			list_add_tail(ptr, &dev_priv->free_list);
+			i++;
+		}
+	}
+
+	DRM_DEBUG("%s: released %d buffers from pending list\n", __FUNCTION__,
+		  i);
+
+	return 0;
+}
+
+drm_buf_t *mach64_freelist_get(drm_mach64_private_t * dev_priv)
+{
+	drm_mach64_descriptor_ring_t *ring = &dev_priv->ring;
+	drm_mach64_freelist_t *entry;
+	struct list_head *ptr;
+	struct list_head *tmp;
+	int t;
+
+	if (list_empty(&dev_priv->free_list)) {
+		u32 head, tail, ofs;
+
+		if (list_empty(&dev_priv->pending)) {
+			DRM_ERROR
+			    ("Couldn't get buffer - pending and free lists empty\n");
+			t = 0;
+			list_for_each(ptr, &dev_priv->placeholders) {
+				t++;
+			}
+			DRM_INFO("Placeholders: %d\n", t);
+			return NULL;
+		}
+
+		tail = ring->tail;
+		for (t = 0; t < dev_priv->usec_timeout; t++) {
+			mach64_ring_tick(dev_priv, ring);
+			head = ring->head;
+
+			if (head == tail) {
+#if MACH64_EXTRA_CHECKING
+				if (MACH64_READ(MACH64_GUI_STAT) &
+				    MACH64_GUI_ACTIVE) {
+					DRM_ERROR
+					    ("Empty ring with non-idle engine!\n");
+					mach64_dump_ring_info(dev_priv);
+					return NULL;
+				}
+#endif
+				/* last pass is complete, so release everything */
+				mach64_do_release_used_buffers(dev_priv);
+				DRM_DEBUG
+				    ("%s: idle engine, freed all buffers.\n",
+				     __FUNCTION__);
+				if (list_empty(&dev_priv->free_list)) {
+					DRM_ERROR
+					    ("Freelist empty with idle engine\n");
+					return NULL;
+				}
+				goto _freelist_entry_found;
+			}
+			/* Look for a completed buffer and bail out of the loop
+			 * as soon as we find one -- don't waste time trying
+			 * to free extra bufs here, leave that to do_release_used_buffers
+			 */
+			list_for_each_safe(ptr, tmp, &dev_priv->pending) {
+				entry =
+				    list_entry(ptr, drm_mach64_freelist_t,
+					       list);
+				ofs = entry->ring_ofs;
+				if (entry->discard &&
+				    ((head < tail
+				      && (ofs < head || ofs >= tail))
+				     || (head > tail
+					 && (ofs < head && ofs >= tail)))) {
+#if MACH64_EXTRA_CHECKING
+					int i;
+
+					for (i = head; i != tail;
+					     i = (i + 4) & ring->tail_mask) {
+						u32 o1 =
+						    le32_to_cpu(((u32 *) ring->
+								 start)[i + 1]);
+						u32 o2 = GETBUFADDR(entry->buf);
+
+						if (o1 == o2) {
+							DRM_ERROR
+							    ("Attempting to free used buffer: "
+							     "i=%d  buf=0x%08x\n",
+							     i, o1);
+							mach64_dump_ring_info
+							    (dev_priv);
+							return NULL;
+						}
+					}
+#endif
+					/* found a processed buffer */
+					entry->buf->pending = 0;
+					list_del(ptr);
+					entry->buf->used = 0;
+					list_add_tail(ptr,
+						      &dev_priv->placeholders);
+					DRM_DEBUG
+					    ("%s: freed processed buffer (head=%d tail=%d "
+					     "buf ring ofs=%d).\n",
+					     __FUNCTION__, head, tail, ofs);
+					return entry->buf;
+				}
+			}
+			DRM_UDELAY(1);
+		}
+		mach64_dump_ring_info(dev_priv);
+		DRM_ERROR
+		    ("timeout waiting for buffers: ring head_addr: 0x%08x head: %d tail: %d\n",
+		     ring->head_addr, ring->head, ring->tail);
+		return NULL;
+	}
+
+      _freelist_entry_found:
+	ptr = dev_priv->free_list.next;
+	list_del(ptr);
+	entry = list_entry(ptr, drm_mach64_freelist_t, list);
+	entry->buf->used = 0;
+	list_add_tail(ptr, &dev_priv->placeholders);
+	return entry->buf;
+}
+
+/*@}*/
+
+
+/*******************************************************************/
+/** \name DMA buffer request and submission IOCTL handler */
+/*@{*/
+
+static int mach64_dma_get_buffers(DRMFILE filp, drm_device_t * dev,
+				  drm_dma_t * d)
+{
+	int i;
+	drm_buf_t *buf;
+	drm_mach64_private_t *dev_priv = dev->dev_private;
+
+	for (i = d->granted_count; i < d->request_count; i++) {
+		buf = mach64_freelist_get(dev_priv);
+#if MACH64_EXTRA_CHECKING
+		if (!buf)
+			return DRM_ERR(EFAULT);
+#else
+		if (!buf)
+			return DRM_ERR(EAGAIN);
+#endif
+
+		buf->filp = filp;
+
+		if (DRM_COPY_TO_USER(&d->request_indices[i], &buf->idx,
+				     sizeof(buf->idx)))
+			return DRM_ERR(EFAULT);
+		if (DRM_COPY_TO_USER(&d->request_sizes[i], &buf->total,
+				     sizeof(buf->total)))
+			return DRM_ERR(EFAULT);
+
+		d->granted_count++;
+	}
+	return 0;
+}
+
+int mach64_dma_buffers(DRM_IOCTL_ARGS)
+{
+	DRM_DEVICE;
+	drm_device_dma_t *dma = dev->dma;
+	drm_dma_t d;
+	int ret = 0;
+
+	LOCK_TEST_WITH_RETURN(dev, filp);
+
+	DRM_COPY_FROM_USER_IOCTL(d, (drm_dma_t *) data, sizeof(d));
+
+	/* Please don't send us buffers.
+	 */
+	if (d.send_count != 0) {
+		DRM_ERROR("Process %d trying to send %d buffers via drmDMA\n",
+			  DRM_CURRENTPID, d.send_count);
+		return DRM_ERR(EINVAL);
+	}
+
+	/* We'll send you buffers.
+	 */
+	if (d.request_count < 0 || d.request_count > dma->buf_count) {
+		DRM_ERROR("Process %d trying to get %d buffers (of %d max)\n",
+			  DRM_CURRENTPID, d.request_count, dma->buf_count);
+		ret = DRM_ERR(EINVAL);
+	}
+
+	d.granted_count = 0;
+
+	if (d.request_count) {
+		ret = mach64_dma_get_buffers(filp, dev, &d);
+	}
+
+	DRM_COPY_TO_USER_IOCTL((drm_dma_t *) data, d, sizeof(d));
+
+	return ret;
+}
+
+void mach64_driver_pretakedown(drm_device_t * dev)
+{
+	mach64_do_cleanup_dma(dev);
+}
+
+/*@}*/
diff -purN linux-2.6.12.orig/drivers/char/drm/mach64_drm.h linux-2.6.12/drivers/char/drm/mach64_drm.h
--- linux-2.6.12.orig/drivers/char/drm/mach64_drm.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/drm/mach64_drm.h	2005-07-05 08:37:49.000000000 +0200
@@ -0,0 +1,255 @@
+/* mach64_drm.h -- Public header for the mach64 driver -*- linux-c -*-
+ * Created: Thu Nov 30 20:04:32 2000 by gareth@valinux.com
+ *
+ * Copyright 2000 Gareth Hughes
+ * Copyright 2002 Frank C. Earl
+ * Copyright 2002-2003 Leif Delgass
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT OWNER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Gareth Hughes <gareth@valinux.com>
+ *    Frank C. Earl <fearl@airmail.net>
+ *    Leif Delgass <ldelgass@retinalburn.net>
+ */
+
+#ifndef __MACH64_DRM_H__
+#define __MACH64_DRM_H__
+
+/* WARNING: If you change any of these defines, make sure to change the
+ * defines in the Xserver file (mach64_sarea.h)
+ */
+#ifndef __MACH64_SAREA_DEFINES__
+#define __MACH64_SAREA_DEFINES__
+
+/* What needs to be changed for the current vertex buffer?
+ * GH: We're going to be pedantic about this.  We want the card to do as
+ * little as possible, so let's avoid having it fetch a whole bunch of
+ * register values that don't change all that often, if at all.
+ */
+#define MACH64_UPLOAD_DST_OFF_PITCH	0x0001
+#define MACH64_UPLOAD_Z_OFF_PITCH	0x0002
+#define MACH64_UPLOAD_Z_ALPHA_CNTL	0x0004
+#define MACH64_UPLOAD_SCALE_3D_CNTL	0x0008
+#define MACH64_UPLOAD_DP_FOG_CLR	0x0010
+#define MACH64_UPLOAD_DP_WRITE_MASK	0x0020
+#define MACH64_UPLOAD_DP_PIX_WIDTH	0x0040
+#define MACH64_UPLOAD_SETUP_CNTL	0x0080
+#define MACH64_UPLOAD_MISC		0x0100
+#define MACH64_UPLOAD_TEXTURE		0x0200
+#define MACH64_UPLOAD_TEX0IMAGE		0x0400
+#define MACH64_UPLOAD_TEX1IMAGE		0x0800
+#define MACH64_UPLOAD_CLIPRECTS		0x1000	/* handled client-side */
+#define MACH64_UPLOAD_CONTEXT		0x00ff
+#define MACH64_UPLOAD_ALL		0x1fff
+
+/* DMA buffer size
+ */
+#define MACH64_BUFFER_SIZE		16384
+
+/* Max number of swaps allowed on the ring
+ * before the client must wait
+ */
+#define MACH64_MAX_QUEUED_FRAMES        3
+
+/* Byte offsets for host blit buffer data
+ */
+#define MACH64_HOSTDATA_BLIT_OFFSET	104
+
+/* Keep these small for testing.
+ */
+#define MACH64_NR_SAREA_CLIPRECTS	8
+
+#define MACH64_CARD_HEAP		0
+#define MACH64_AGP_HEAP			1
+#define MACH64_NR_TEX_HEAPS		2
+#define MACH64_NR_TEX_REGIONS		64
+#define MACH64_LOG_TEX_GRANULARITY	16
+
+#define MACH64_TEX_MAXLEVELS		1
+
+#define MACH64_NR_CONTEXT_REGS		15
+#define MACH64_NR_TEXTURE_REGS		4
+
+#endif				/* __MACH64_SAREA_DEFINES__ */
+
+typedef struct {
+	unsigned int dst_off_pitch;
+
+	unsigned int z_off_pitch;
+	unsigned int z_cntl;
+	unsigned int alpha_tst_cntl;
+
+	unsigned int scale_3d_cntl;
+
+	unsigned int sc_left_right;
+	unsigned int sc_top_bottom;
+
+	unsigned int dp_fog_clr;
+	unsigned int dp_write_mask;
+	unsigned int dp_pix_width;
+	unsigned int dp_mix;
+	unsigned int dp_src;
+
+	unsigned int clr_cmp_cntl;
+	unsigned int gui_traj_cntl;
+
+	unsigned int setup_cntl;
+
+	unsigned int tex_size_pitch;
+	unsigned int tex_cntl;
+	unsigned int secondary_tex_off;
+	unsigned int tex_offset;
+} drm_mach64_context_regs_t;
+
+typedef struct drm_mach64_sarea {
+	/* The channel for communication of state information to the kernel
+	 * on firing a vertex dma buffer.
+	 */
+	drm_mach64_context_regs_t context_state;
+	unsigned int dirty;
+	unsigned int vertsize;
+
+	/* The current cliprects, or a subset thereof.
+	 */
+	drm_clip_rect_t boxes[MACH64_NR_SAREA_CLIPRECTS];
+	unsigned int nbox;
+
+	/* Counters for client-side throttling of rendering clients.
+	 */
+	unsigned int frames_queued;
+
+	/* Texture memory LRU.
+	 */
+	drm_tex_region_t tex_list[MACH64_NR_TEX_HEAPS][MACH64_NR_TEX_REGIONS +
+						       1];
+	unsigned int tex_age[MACH64_NR_TEX_HEAPS];
+	int ctx_owner;
+} drm_mach64_sarea_t;
+
+/* WARNING: If you change any of these defines, make sure to change the
+ * defines in the Xserver file (mach64_common.h)
+ */
+
+/* Mach64 specific ioctls
+ * The device specific ioctl range is 0x40 to 0x79.
+ */
+
+#define DRM_MACH64_INIT           0x00
+#define DRM_MACH64_IDLE           0x01
+#define DRM_MACH64_RESET          0x02
+#define DRM_MACH64_SWAP           0x03
+#define DRM_MACH64_CLEAR          0x04
+#define DRM_MACH64_VERTEX         0x05
+#define DRM_MACH64_BLIT           0x06
+#define DRM_MACH64_FLUSH          0x07
+#define DRM_MACH64_GETPARAM       0x08
+
+#define DRM_IOCTL_MACH64_INIT           DRM_IOW( DRM_COMMAND_BASE + DRM_MACH64_INIT, drm_mach64_init_t)
+#define DRM_IOCTL_MACH64_IDLE           DRM_IO(  DRM_COMMAND_BASE + DRM_MACH64_IDLE )
+#define DRM_IOCTL_MACH64_RESET          DRM_IO(  DRM_COMMAND_BASE + DRM_MACH64_RESET )
+#define DRM_IOCTL_MACH64_SWAP           DRM_IO(  DRM_COMMAND_BASE + DRM_MACH64_SWAP )
+#define DRM_IOCTL_MACH64_CLEAR          DRM_IOW( DRM_COMMAND_BASE + DRM_MACH64_CLEAR, drm_mach64_clear_t)
+#define DRM_IOCTL_MACH64_VERTEX         DRM_IOW( DRM_COMMAND_BASE + DRM_MACH64_VERTEX, drm_mach64_vertex_t)
+#define DRM_IOCTL_MACH64_BLIT           DRM_IOW( DRM_COMMAND_BASE + DRM_MACH64_BLIT, drm_mach64_blit_t)
+#define DRM_IOCTL_MACH64_FLUSH          DRM_IO(  DRM_COMMAND_BASE + DRM_MACH64_FLUSH )
+#define DRM_IOCTL_MACH64_GETPARAM       DRM_IOWR( DRM_COMMAND_BASE + DRM_MACH64_GETPARAM, drm_mach64_getparam_t)
+
+/* Buffer flags for clears
+ */
+#define MACH64_FRONT			0x1
+#define MACH64_BACK			0x2
+#define MACH64_DEPTH			0x4
+
+/* Primitive types for vertex buffers
+ */
+#define MACH64_PRIM_POINTS		0x00000000
+#define MACH64_PRIM_LINES		0x00000001
+#define MACH64_PRIM_LINE_LOOP		0x00000002
+#define MACH64_PRIM_LINE_STRIP		0x00000003
+#define MACH64_PRIM_TRIANGLES		0x00000004
+#define MACH64_PRIM_TRIANGLE_STRIP	0x00000005
+#define MACH64_PRIM_TRIANGLE_FAN	0x00000006
+#define MACH64_PRIM_QUADS		0x00000007
+#define MACH64_PRIM_QUAD_STRIP		0x00000008
+#define MACH64_PRIM_POLYGON		0x00000009
+
+typedef enum _drm_mach64_dma_mode_t {
+	MACH64_MODE_DMA_ASYNC,
+	MACH64_MODE_DMA_SYNC,
+	MACH64_MODE_MMIO
+} drm_mach64_dma_mode_t;
+
+typedef struct drm_mach64_init {
+	enum {
+		DRM_MACH64_INIT_DMA = 0x01,
+		DRM_MACH64_CLEANUP_DMA = 0x02
+	} func;
+
+	unsigned long sarea_priv_offset;
+	int is_pci;
+	drm_mach64_dma_mode_t dma_mode;
+
+	unsigned int fb_bpp;
+	unsigned int front_offset, front_pitch;
+	unsigned int back_offset, back_pitch;
+
+	unsigned int depth_bpp;
+	unsigned int depth_offset, depth_pitch;
+
+	unsigned long fb_offset;
+	unsigned long mmio_offset;
+	unsigned long ring_offset;
+	unsigned long buffers_offset;
+	unsigned long agp_textures_offset;
+} drm_mach64_init_t;
+
+typedef struct drm_mach64_clear {
+	unsigned int flags;
+	int x, y, w, h;
+	unsigned int clear_color;
+	unsigned int clear_depth;
+} drm_mach64_clear_t;
+
+typedef struct drm_mach64_vertex {
+	int prim;
+	void *buf;		/* Address of vertex buffer */
+	unsigned long used;	/* Number of bytes in buffer */
+	int discard;		/* Client finished with buffer? */
+} drm_mach64_vertex_t;
+
+typedef struct drm_mach64_blit {
+	int idx;
+	int pitch;
+	int offset;
+	int format;
+	unsigned short x, y;
+	unsigned short width, height;
+} drm_mach64_blit_t;
+
+typedef struct drm_mach64_getparam {
+	enum {
+		MACH64_PARAM_FRAMES_QUEUED = 0x01,
+		MACH64_PARAM_IRQ_NR = 0x02
+	} param;
+	void *value;
+} drm_mach64_getparam_t;
+
+#endif
diff -purN linux-2.6.12.orig/drivers/char/drm/mach64_drv.c linux-2.6.12/drivers/char/drm/mach64_drv.c
--- linux-2.6.12.orig/drivers/char/drm/mach64_drv.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/drm/mach64_drv.c	2005-07-05 08:37:27.000000000 +0200
@@ -0,0 +1,127 @@
+/* mach64_drv.c -- mach64 (Rage Pro) driver -*- linux-c -*-
+ * Created: Fri Nov 24 18:34:32 2000 by gareth@valinux.com
+ *
+ * Copyright 2000 Gareth Hughes
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * GARETH HUGHES BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Gareth Hughes <gareth@valinux.com>
+ *    Leif Delgass <ldelgass@retinalburn.net>
+ */
+
+#include <linux/config.h>
+#include "drmP.h"
+#include "drm.h"
+#include "mach64_drm.h"
+#include "mach64_drv.h"
+
+#include "drm_pciids.h"
+
+static int postinit(struct drm_device *dev, unsigned long flags)
+{
+	DRM_INFO("Initialized %s %d.%d.%d %s on minor %d: %s\n",
+		 DRIVER_NAME,
+		 DRIVER_MAJOR,
+		 DRIVER_MINOR,
+		 DRIVER_PATCHLEVEL,
+		 DRIVER_DATE, dev->primary.minor, pci_pretty_name(dev->pdev)
+	    );
+	return 0;
+}
+
+static int version(drm_version_t * version)
+{
+	int len;
+
+	version->version_major = DRIVER_MAJOR;
+	version->version_minor = DRIVER_MINOR;
+	version->version_patchlevel = DRIVER_PATCHLEVEL;
+	DRM_COPY(version->name, DRIVER_NAME);
+	DRM_COPY(version->date, DRIVER_DATE);
+	DRM_COPY(version->desc, DRIVER_DESC);
+	return 0;
+}
+
+static struct pci_device_id pciidlist[] = {
+	mach64_PCI_IDS
+};
+
+extern drm_ioctl_desc_t mach64_ioctls[];
+extern int mach64_max_ioctl;
+
+static int probe(struct pci_dev *pdev, const struct pci_device_id *ent);
+static struct drm_driver driver = {
+	.driver_features =
+	    DRIVER_USE_AGP | DRIVER_USE_MTRR | DRIVER_PCI_DMA | DRIVER_HAVE_DMA
+	    | DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED | DRIVER_IRQ_VBL,
+	.pretakedown = mach64_driver_pretakedown,
+	.vblank_wait = mach64_driver_vblank_wait,
+	.irq_preinstall = mach64_driver_irq_preinstall,
+	.irq_postinstall = mach64_driver_irq_postinstall,
+	.irq_uninstall = mach64_driver_irq_uninstall,
+	.irq_handler = mach64_driver_irq_handler,
+	.reclaim_buffers = drm_core_reclaim_buffers,
+	.get_map_ofs = drm_core_get_map_ofs,
+	.get_reg_ofs = drm_core_get_reg_ofs,
+	.postinit = postinit,
+	.version = version,
+	.ioctls = mach64_ioctls,
+	.dma_ioctl = mach64_dma_buffers,
+	.fops = {
+		.owner = THIS_MODULE,
+		.open = drm_open,
+		.release = drm_release,
+		.ioctl = drm_ioctl,
+		.mmap = drm_mmap,
+		.poll = drm_poll,
+		.fasync = drm_fasync,
+		},
+	.pci_driver = {
+		.name = DRIVER_NAME,
+		.id_table = pciidlist,
+		.probe = probe,
+		.remove = __devexit_p(drm_cleanup_pci),
+	}
+};
+
+static int probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	return drm_get_dev(pdev, ent, &driver);
+}
+
+
+static int __init mach64_init(void)
+{
+	driver.num_ioctls = mach64_max_ioctl;
+	return drm_init(&driver, pciidlist);
+}
+
+static void __exit mach64_exit(void)
+{
+	drm_exit(&driver);
+}
+
+module_init(mach64_init);
+module_exit(mach64_exit);
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL and additional rights");
diff -purN linux-2.6.12.orig/drivers/char/drm/mach64_drv.h linux-2.6.12/drivers/char/drm/mach64_drv.h
--- linux-2.6.12.orig/drivers/char/drm/mach64_drv.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/drm/mach64_drv.h	2005-07-05 08:37:49.000000000 +0200
@@ -0,0 +1,1043 @@
+/* mach64_drv.h -- Private header for mach64 driver -*- linux-c -*-
+ * Created: Fri Nov 24 22:07:58 2000 by gareth@valinux.com
+ *
+ * Copyright 2000 Gareth Hughes
+ * Copyright 2002 Frank C. Earl
+ * Copyright 2002-2003 Leif Delgass
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT OWNER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Gareth Hughes <gareth@valinux.com>
+ *    Frank C. Earl <fearl@airmail.net>
+ *    Leif Delgass <ldelgass@retinalburn.net>
+ *    JosFonseca <j_r_fonseca@yahoo.co.uk>
+ */
+
+#ifndef __MACH64_DRV_H__
+#define __MACH64_DRV_H__
+
+/* General customization:
+ */
+
+#define DRIVER_AUTHOR		"Gareth Hughes, Leif Delgass, Jos Fonseca"
+
+#define DRIVER_NAME		"mach64"
+#define DRIVER_DESC		"DRM module for the ATI Rage Pro"
+#define DRIVER_DATE		"20020904"
+
+#define DRIVER_MAJOR		1
+#define DRIVER_MINOR		0
+#define DRIVER_PATCHLEVEL	0
+
+/* FIXME: remove these when not needed */
+/* Development driver options */
+#define MACH64_EXTRA_CHECKING     0	/* Extra sanity checks for DMA/freelist management */
+#define MACH64_VERBOSE		  0	/* Verbose debugging output */
+
+typedef struct drm_mach64_freelist {
+	struct list_head list;	/* List pointers for free_list, placeholders, or pending list */
+	drm_buf_t *buf;		/* Pointer to the buffer */
+	int discard;		/* This flag is set when we're done (re)using a buffer */
+	u32 ring_ofs;		/* dword offset in ring of last descriptor for this buffer */
+} drm_mach64_freelist_t;
+
+typedef struct drm_mach64_descriptor_ring {
+	drm_dma_handle_t *dmah;	/* Handle to pci dma memory */
+	void *start;		/* write pointer (cpu address) to start of descriptor ring */
+	u32 start_addr;		/* bus address of beginning of descriptor ring */
+	int size;		/* size of ring in bytes */
+
+	u32 head_addr;		/* bus address of descriptor ring head */
+	u32 head;		/* dword offset of descriptor ring head */
+	u32 tail;		/* dword offset of descriptor ring tail */
+	u32 tail_mask;		/* mask used to wrap ring */
+	int space;		/* number of free bytes in ring */
+} drm_mach64_descriptor_ring_t;
+
+typedef struct drm_mach64_private {
+	drm_mach64_sarea_t *sarea_priv;
+
+	int is_pci;
+	drm_mach64_dma_mode_t driver_mode;	/* Async DMA, sync DMA, or MMIO */
+
+	int usec_timeout;	/* Timeout for the wait functions */
+
+	drm_mach64_descriptor_ring_t ring;	/* DMA descriptor table (ring buffer) */
+	int ring_running;	/* Is bus mastering is enabled */
+
+	struct list_head free_list;	/* Free-list head */
+	struct list_head placeholders;	/* Placeholder list for buffers held by clients */
+	struct list_head pending;	/* Buffers pending completion */
+
+	u32 frame_ofs[MACH64_MAX_QUEUED_FRAMES];	/* dword ring offsets of most recent frame swaps */
+
+	unsigned int fb_bpp;
+	unsigned int front_offset, front_pitch;
+	unsigned int back_offset, back_pitch;
+
+	unsigned int depth_bpp;
+	unsigned int depth_offset, depth_pitch;
+
+	u32 front_offset_pitch;
+	u32 back_offset_pitch;
+	u32 depth_offset_pitch;
+
+	drm_local_map_t *sarea;
+	drm_local_map_t *fb;
+	drm_local_map_t *mmio;
+	drm_local_map_t *ring_map;
+	drm_local_map_t *dev_buffers;	/* this is a pointer to a structure in dev */
+	drm_local_map_t *agp_textures;
+} drm_mach64_private_t;
+
+				/* mach64_dma.c */
+extern int mach64_dma_init(DRM_IOCTL_ARGS);
+extern int mach64_dma_idle(DRM_IOCTL_ARGS);
+extern int mach64_dma_flush(DRM_IOCTL_ARGS);
+extern int mach64_engine_reset(DRM_IOCTL_ARGS);
+extern int mach64_dma_buffers(DRM_IOCTL_ARGS);
+extern void mach64_driver_pretakedown(drm_device_t * dev);
+
+extern int mach64_init_freelist(drm_device_t * dev);
+extern void mach64_destroy_freelist(drm_device_t * dev);
+extern drm_buf_t *mach64_freelist_get(drm_mach64_private_t * dev_priv);
+
+extern int mach64_do_wait_for_fifo(drm_mach64_private_t * dev_priv,
+				   int entries);
+extern int mach64_do_wait_for_idle(drm_mach64_private_t * dev_priv);
+extern int mach64_wait_ring(drm_mach64_private_t * dev_priv, int n);
+extern int mach64_do_dispatch_pseudo_dma(drm_mach64_private_t * dev_priv);
+extern int mach64_do_release_used_buffers(drm_mach64_private_t * dev_priv);
+extern void mach64_dump_engine_info(drm_mach64_private_t * dev_priv);
+extern void mach64_dump_ring_info(drm_mach64_private_t * dev_priv);
+extern int mach64_do_engine_reset(drm_mach64_private_t * dev_priv);
+
+extern int mach64_do_dma_idle(drm_mach64_private_t * dev_priv);
+extern int mach64_do_dma_flush(drm_mach64_private_t * dev_priv);
+extern int mach64_do_cleanup_dma(drm_device_t * dev);
+
+				/* mach64_state.c */
+extern int mach64_dma_clear(DRM_IOCTL_ARGS);
+extern int mach64_dma_swap(DRM_IOCTL_ARGS);
+extern int mach64_dma_vertex(DRM_IOCTL_ARGS);
+extern int mach64_dma_blit(DRM_IOCTL_ARGS);
+extern int mach64_get_param(DRM_IOCTL_ARGS);
+extern int mach64_driver_vblank_wait(drm_device_t * dev,
+				     unsigned int *sequence);
+
+extern irqreturn_t mach64_driver_irq_handler(DRM_IRQ_ARGS);
+extern void mach64_driver_irq_preinstall(drm_device_t * dev);
+extern void mach64_driver_irq_postinstall(drm_device_t * dev);
+extern void mach64_driver_irq_uninstall(drm_device_t * dev);
+
+/* ================================================================
+ * Registers
+ */
+
+#define MACH64_AGP_BASE				0x0148
+#define MACH64_AGP_CNTL				0x014c
+#define MACH64_ALPHA_TST_CNTL			0x0550
+
+#define MACH64_DSP_CONFIG 			0x0420
+#define MACH64_DSP_ON_OFF 			0x0424
+#define MACH64_EXT_MEM_CNTL 			0x04ac
+#define MACH64_GEN_TEST_CNTL 			0x04d0
+#define MACH64_HW_DEBUG 			0x047c
+#define MACH64_MEM_ADDR_CONFIG 			0x0434
+#define MACH64_MEM_BUF_CNTL 			0x042c
+#define MACH64_MEM_CNTL 			0x04b0
+
+#define MACH64_BM_ADDR				0x0648
+#define MACH64_BM_COMMAND			0x0188
+#define MACH64_BM_DATA				0x0648
+#define MACH64_BM_FRAME_BUF_OFFSET		0x0180
+#define MACH64_BM_GUI_TABLE			0x01b8
+#define MACH64_BM_GUI_TABLE_CMD			0x064c
+#	define MACH64_CIRCULAR_BUF_SIZE_16KB		(0 << 0)
+#	define MACH64_CIRCULAR_BUF_SIZE_32KB		(1 << 0)
+#	define MACH64_CIRCULAR_BUF_SIZE_64KB		(2 << 0)
+#	define MACH64_CIRCULAR_BUF_SIZE_128KB		(3 << 0)
+#	define MACH64_LAST_DESCRIPTOR			(1 << 31)
+#define MACH64_BM_HOSTDATA			0x0644
+#define MACH64_BM_STATUS			0x018c
+#define MACH64_BM_SYSTEM_MEM_ADDR		0x0184
+#define MACH64_BM_SYSTEM_TABLE			0x01bc
+#define MACH64_BUS_CNTL				0x04a0
+#	define MACH64_BUS_MSTR_RESET			(1 << 1)
+#	define MACH64_BUS_APER_REG_DIS			(1 << 4)
+#	define MACH64_BUS_FLUSH_BUF			(1 << 2)
+#	define MACH64_BUS_MASTER_DIS			(1 << 6)
+#	define MACH64_BUS_EXT_REG_EN			(1 << 27)
+
+#define MACH64_CLR_CMP_CLR			0x0700
+#define MACH64_CLR_CMP_CNTL			0x0708
+#define MACH64_CLR_CMP_MASK			0x0704
+#define MACH64_CONFIG_CHIP_ID 			0x04e0
+#define MACH64_CONFIG_CNTL 			0x04dc
+#define MACH64_CONFIG_STAT0 			0x04e4
+#define MACH64_CONFIG_STAT1 			0x0494
+#define MACH64_CONFIG_STAT2 			0x0498
+#define MACH64_CONTEXT_LOAD_CNTL		0x072c
+#define MACH64_CONTEXT_MASK			0x0720
+#define MACH64_COMPOSITE_SHADOW_ID		0x0798
+#define MACH64_CRC_SIG 				0x04e8
+#define MACH64_CUSTOM_MACRO_CNTL 		0x04d4
+
+#define MACH64_DP_BKGD_CLR			0x06c0
+#define MACH64_DP_FOG_CLR			0x06c4
+#define MACH64_DP_FGRD_BKGD_CLR			0x06e0
+#define MACH64_DP_FRGD_CLR			0x06c4
+#define MACH64_DP_FGRD_CLR_MIX			0x06dc
+
+#define MACH64_DP_MIX				0x06d4
+#	define BKGD_MIX_NOT_D				(0 << 0)
+#	define BKGD_MIX_ZERO				(1 << 0)
+#	define BKGD_MIX_ONE				(2 << 0)
+#	define MACH64_BKGD_MIX_D			(3 << 0)
+#	define BKGD_MIX_NOT_S				(4 << 0)
+#	define BKGD_MIX_D_XOR_S				(5 << 0)
+#	define BKGD_MIX_NOT_D_XOR_S			(6 << 0)
+#	define MACH64_BKGD_MIX_S			(7 << 0)
+#	define BKGD_MIX_NOT_D_OR_NOT_S			(8 << 0)
+#	define BKGD_MIX_D_OR_NOT_S			(9 << 0)
+#	define BKGD_MIX_NOT_D_OR_S			(10 << 0)
+#	define BKGD_MIX_D_OR_S				(11 << 0)
+#	define BKGD_MIX_D_AND_S				(12 << 0)
+#	define BKGD_MIX_NOT_D_AND_S			(13 << 0)
+#	define BKGD_MIX_D_AND_NOT_S			(14 << 0)
+#	define BKGD_MIX_NOT_D_AND_NOT_S			(15 << 0)
+#	define BKGD_MIX_D_PLUS_S_DIV2			(23 << 0)
+#	define FRGD_MIX_NOT_D				(0 << 16)
+#	define FRGD_MIX_ZERO				(1 << 16)
+#	define FRGD_MIX_ONE				(2 << 16)
+#	define FRGD_MIX_D				(3 << 16)
+#	define FRGD_MIX_NOT_S				(4 << 16)
+#	define FRGD_MIX_D_XOR_S				(5 << 16)
+#	define FRGD_MIX_NOT_D_XOR_S			(6 << 16)
+#	define MACH64_FRGD_MIX_S			(7 << 16)
+#	define FRGD_MIX_NOT_D_OR_NOT_S			(8 << 16)
+#	define FRGD_MIX_D_OR_NOT_S			(9 << 16)
+#	define FRGD_MIX_NOT_D_OR_S			(10 << 16)
+#	define FRGD_MIX_D_OR_S				(11 << 16)
+#	define FRGD_MIX_D_AND_S				(12 << 16)
+#	define FRGD_MIX_NOT_D_AND_S			(13 << 16)
+#	define FRGD_MIX_D_AND_NOT_S			(14 << 16)
+#	define FRGD_MIX_NOT_D_AND_NOT_S			(15 << 16)
+#	define FRGD_MIX_D_PLUS_S_DIV2			(23 << 16)
+
+#define MACH64_DP_PIX_WIDTH			0x06d0
+#	define MACH64_HOST_TRIPLE_ENABLE		(1 << 13)
+#	define MACH64_BYTE_ORDER_MSB_TO_LSB		(0 << 24)
+#	define MACH64_BYTE_ORDER_LSB_TO_MSB		(1 << 24)
+
+#define MACH64_DP_SRC				0x06d8
+#	define MACH64_BKGD_SRC_BKGD_CLR			(0 << 0)
+#	define MACH64_BKGD_SRC_FRGD_CLR			(1 << 0)
+#	define MACH64_BKGD_SRC_HOST			(2 << 0)
+#	define MACH64_BKGD_SRC_BLIT			(3 << 0)
+#	define MACH64_BKGD_SRC_PATTERN			(4 << 0)
+#	define MACH64_BKGD_SRC_3D			(5 << 0)
+#	define MACH64_FRGD_SRC_BKGD_CLR			(0 << 8)
+#	define MACH64_FRGD_SRC_FRGD_CLR			(1 << 8)
+#	define MACH64_FRGD_SRC_HOST			(2 << 8)
+#	define MACH64_FRGD_SRC_BLIT			(3 << 8)
+#	define MACH64_FRGD_SRC_PATTERN			(4 << 8)
+#	define MACH64_FRGD_SRC_3D			(5 << 8)
+#	define MACH64_MONO_SRC_ONE			(0 << 16)
+#	define MACH64_MONO_SRC_PATTERN			(1 << 16)
+#	define MACH64_MONO_SRC_HOST			(2 << 16)
+#	define MACH64_MONO_SRC_BLIT			(3 << 16)
+
+#define MACH64_DP_WRITE_MASK			0x06c8
+
+#define MACH64_DST_CNTL				0x0530
+#	define MACH64_DST_X_RIGHT_TO_LEFT		(0 << 0)
+#	define MACH64_DST_X_LEFT_TO_RIGHT		(1 << 0)
+#	define MACH64_DST_Y_BOTTOM_TO_TOP		(0 << 1)
+#	define MACH64_DST_Y_TOP_TO_BOTTOM		(1 << 1)
+#	define MACH64_DST_X_MAJOR			(0 << 2)
+#	define MACH64_DST_Y_MAJOR			(1 << 2)
+#	define MACH64_DST_X_TILE			(1 << 3)
+#	define MACH64_DST_Y_TILE			(1 << 4)
+#	define MACH64_DST_LAST_PEL			(1 << 5)
+#	define MACH64_DST_POLYGON_ENABLE		(1 << 6)
+#	define MACH64_DST_24_ROTATION_ENABLE		(1 << 7)
+
+#define MACH64_DST_HEIGHT_WIDTH			0x0518
+#define MACH64_DST_OFF_PITCH			0x0500
+#define MACH64_DST_WIDTH_HEIGHT			0x06ec
+#define MACH64_DST_X_Y				0x06e8
+#define MACH64_DST_Y_X				0x050c
+
+#define MACH64_FIFO_STAT			0x0710
+#	define MACH64_FIFO_SLOT_MASK			0x0000ffff
+#	define MACH64_FIFO_ERR				(1 << 31)
+
+#define MACH64_GEN_TEST_CNTL			0x04d0
+#	define MACH64_GUI_ENGINE_ENABLE			(1 << 8)
+#define MACH64_GUI_CMDFIFO_DEBUG		0x0170
+#define MACH64_GUI_CMDFIFO_DATA			0x0174
+#define MACH64_GUI_CNTL				0x0178
+#       define MACH64_CMDFIFO_SIZE_MASK                 0x00000003ul
+#       define MACH64_CMDFIFO_SIZE_192                  0x00000000ul
+#       define MACH64_CMDFIFO_SIZE_128                  0x00000001ul
+#       define MACH64_CMDFIFO_SIZE_64                   0x00000002ul
+#define MACH64_GUI_STAT				0x0738
+#	define MACH64_GUI_ACTIVE			(1 << 0)
+#define MACH64_GUI_TRAJ_CNTL			0x0730
+
+#define MACH64_HOST_CNTL			0x0640
+#define MACH64_HOST_DATA0			0x0600
+
+#define MACH64_ONE_OVER_AREA			0x029c
+#define MACH64_ONE_OVER_AREA_UC			0x0300
+
+#define MACH64_PAT_REG0				0x0680
+#define MACH64_PAT_REG1				0x0684
+
+#define MACH64_SC_LEFT                          0x06a0
+#define MACH64_SC_RIGHT                         0x06a4
+#define MACH64_SC_LEFT_RIGHT                    0x06a8
+#define MACH64_SC_TOP                           0x06ac
+#define MACH64_SC_BOTTOM                        0x06b0
+#define MACH64_SC_TOP_BOTTOM                    0x06b4
+
+#define MACH64_SCALE_3D_CNTL			0x05fc
+#define MACH64_SCRATCH_REG0			0x0480
+#define MACH64_SCRATCH_REG1			0x0484
+#define MACH64_SECONDARY_TEX_OFF		0x0778
+#define MACH64_SETUP_CNTL			0x0304
+#define MACH64_SRC_CNTL				0x05b4
+#	define MACH64_SRC_BM_ENABLE			(1 << 8)
+#	define MACH64_SRC_BM_SYNC			(1 << 9)
+#	define MACH64_SRC_BM_OP_FRAME_TO_SYSTEM		(0 << 10)
+#	define MACH64_SRC_BM_OP_SYSTEM_TO_FRAME		(1 << 10)
+#	define MACH64_SRC_BM_OP_REG_TO_SYSTEM		(2 << 10)
+#	define MACH64_SRC_BM_OP_SYSTEM_TO_REG		(3 << 10)
+#define MACH64_SRC_HEIGHT1			0x0594
+#define MACH64_SRC_HEIGHT2			0x05ac
+#define MACH64_SRC_HEIGHT1_WIDTH1		0x0598
+#define MACH64_SRC_HEIGHT2_WIDTH2		0x05b0
+#define MACH64_SRC_OFF_PITCH			0x0580
+#define MACH64_SRC_WIDTH1			0x0590
+#define MACH64_SRC_Y_X				0x058c
+
+#define MACH64_TEX_0_OFF			0x05c0
+#define MACH64_TEX_CNTL				0x0774
+#define MACH64_TEX_SIZE_PITCH			0x0770
+#define MACH64_TIMER_CONFIG 			0x0428
+
+#define MACH64_VERTEX_1_ARGB			0x0254
+#define MACH64_VERTEX_1_S			0x0240
+#define MACH64_VERTEX_1_SECONDARY_S		0x0328
+#define MACH64_VERTEX_1_SECONDARY_T		0x032c
+#define MACH64_VERTEX_1_SECONDARY_W		0x0330
+#define MACH64_VERTEX_1_SPEC_ARGB		0x024c
+#define MACH64_VERTEX_1_T			0x0244
+#define MACH64_VERTEX_1_W			0x0248
+#define MACH64_VERTEX_1_X_Y			0x0258
+#define MACH64_VERTEX_1_Z			0x0250
+#define MACH64_VERTEX_2_ARGB			0x0274
+#define MACH64_VERTEX_2_S			0x0260
+#define MACH64_VERTEX_2_SECONDARY_S		0x0334
+#define MACH64_VERTEX_2_SECONDARY_T		0x0338
+#define MACH64_VERTEX_2_SECONDARY_W		0x033c
+#define MACH64_VERTEX_2_SPEC_ARGB		0x026c
+#define MACH64_VERTEX_2_T			0x0264
+#define MACH64_VERTEX_2_W			0x0268
+#define MACH64_VERTEX_2_X_Y			0x0278
+#define MACH64_VERTEX_2_Z			0x0270
+#define MACH64_VERTEX_3_ARGB			0x0294
+#define MACH64_VERTEX_3_S			0x0280
+#define MACH64_VERTEX_3_SECONDARY_S		0x02a0
+#define MACH64_VERTEX_3_SECONDARY_T		0x02a4
+#define MACH64_VERTEX_3_SECONDARY_W		0x02a8
+#define MACH64_VERTEX_3_SPEC_ARGB		0x028c
+#define MACH64_VERTEX_3_T			0x0284
+#define MACH64_VERTEX_3_W			0x0288
+#define MACH64_VERTEX_3_X_Y			0x0298
+#define MACH64_VERTEX_3_Z			0x0290
+
+#define MACH64_Z_CNTL				0x054c
+#define MACH64_Z_OFF_PITCH			0x0548
+
+#define MACH64_CRTC_VLINE_CRNT_VLINE		0x0410
+#	define MACH64_CRTC_VLINE_MASK		        0x000007ff
+#	define MACH64_CRTC_CRNT_VLINE_MASK		0x07ff0000
+#define MACH64_CRTC_OFF_PITCH			0x0414
+#define MACH64_CRTC_INT_CNTL			0x0418
+#	define MACH64_CRTC_VBLANK			(1 << 0)
+#	define MACH64_CRTC_VBLANK_INT_EN		(1 << 1)
+#	define MACH64_CRTC_VBLANK_INT			(1 << 2)
+#	define MACH64_CRTC_VLINE_INT_EN			(1 << 3)
+#	define MACH64_CRTC_VLINE_INT			(1 << 4)
+#	define MACH64_CRTC_VLINE_SYNC			(1 << 5)	/* 0=even, 1=odd */
+#	define MACH64_CRTC_FRAME			(1 << 6)	/* 0=even, 1=odd */
+#	define MACH64_CRTC_SNAPSHOT_INT_EN		(1 << 7)
+#	define MACH64_CRTC_SNAPSHOT_INT			(1 << 8)
+#	define MACH64_CRTC_I2C_INT_EN			(1 << 9)
+#	define MACH64_CRTC_I2C_INT			(1 << 10)
+#	define MACH64_CRTC2_VBLANK			(1 << 11)	/* LT Pro */
+#	define MACH64_CRTC2_VBLANK_INT_EN		(1 << 12)	/* LT Pro */
+#	define MACH64_CRTC2_VBLANK_INT			(1 << 13)	/* LT Pro */
+#	define MACH64_CRTC2_VLINE_INT_EN		(1 << 14)	/* LT Pro */
+#	define MACH64_CRTC2_VLINE_INT			(1 << 15)	/* LT Pro */
+#	define MACH64_CRTC_CAPBUF0_INT_EN		(1 << 16)
+#	define MACH64_CRTC_CAPBUF0_INT			(1 << 17)
+#	define MACH64_CRTC_CAPBUF1_INT_EN		(1 << 18)
+#	define MACH64_CRTC_CAPBUF1_INT			(1 << 19)
+#	define MACH64_CRTC_OVERLAY_EOF_INT_EN		(1 << 20)
+#	define MACH64_CRTC_OVERLAY_EOF_INT		(1 << 21)
+#	define MACH64_CRTC_ONESHOT_CAP_INT_EN		(1 << 22)
+#	define MACH64_CRTC_ONESHOT_CAP_INT		(1 << 23)
+#	define MACH64_CRTC_BUSMASTER_EOL_INT_EN		(1 << 24)
+#	define MACH64_CRTC_BUSMASTER_EOL_INT		(1 << 25)
+#	define MACH64_CRTC_GP_INT_EN			(1 << 26)
+#	define MACH64_CRTC_GP_INT			(1 << 27)
+#	define MACH64_CRTC2_VLINE_SYNC			(1 << 28) /* LT Pro */	/* 0=even, 1=odd */
+#	define MACH64_CRTC_SNAPSHOT2_INT_EN		(1 << 29)	/* LT Pro */
+#	define MACH64_CRTC_SNAPSHOT2_INT		(1 << 30)	/* LT Pro */
+#	define MACH64_CRTC_VBLANK2_INT			(1 << 31)
+#	define MACH64_CRTC_INT_ENS				\
+		(						\
+			MACH64_CRTC_VBLANK_INT_EN |		\
+			MACH64_CRTC_VLINE_INT_EN |		\
+			MACH64_CRTC_SNAPSHOT_INT_EN |		\
+			MACH64_CRTC_I2C_INT_EN |		\
+			MACH64_CRTC2_VBLANK_INT_EN |		\
+			MACH64_CRTC2_VLINE_INT_EN |		\
+			MACH64_CRTC_CAPBUF0_INT_EN |		\
+			MACH64_CRTC_CAPBUF1_INT_EN |		\
+			MACH64_CRTC_OVERLAY_EOF_INT_EN |	\
+			MACH64_CRTC_ONESHOT_CAP_INT_EN |	\
+			MACH64_CRTC_BUSMASTER_EOL_INT_EN |	\
+			MACH64_CRTC_GP_INT_EN |			\
+			MACH64_CRTC_SNAPSHOT2_INT_EN |		\
+			0					\
+		)
+#	define MACH64_CRTC_INT_ACKS			\
+		(					\
+			MACH64_CRTC_VBLANK_INT |	\
+			MACH64_CRTC_VLINE_INT |		\
+			MACH64_CRTC_SNAPSHOT_INT |	\
+			MACH64_CRTC_I2C_INT |		\
+			MACH64_CRTC2_VBLANK_INT |	\
+			MACH64_CRTC2_VLINE_INT |	\
+			MACH64_CRTC_CAPBUF0_INT |	\
+			MACH64_CRTC_CAPBUF1_INT |	\
+			MACH64_CRTC_OVERLAY_EOF_INT |	\
+			MACH64_CRTC_ONESHOT_CAP_INT |	\
+			MACH64_CRTC_BUSMASTER_EOL_INT |	\
+			MACH64_CRTC_GP_INT |		\
+			MACH64_CRTC_SNAPSHOT2_INT |	\
+			MACH64_CRTC_VBLANK2_INT |	\
+			0				\
+		)
+
+#define MACH64_DATATYPE_CI8				2
+#define MACH64_DATATYPE_ARGB1555			3
+#define MACH64_DATATYPE_RGB565				4
+#define MACH64_DATATYPE_ARGB8888			6
+#define MACH64_DATATYPE_RGB332				7
+#define MACH64_DATATYPE_Y8				8
+#define MACH64_DATATYPE_RGB8				9
+#define MACH64_DATATYPE_VYUY422				11
+#define MACH64_DATATYPE_YVYU422				12
+#define MACH64_DATATYPE_AYUV444				14
+#define MACH64_DATATYPE_ARGB4444			15
+
+#define MACH64_READ(reg)	DRM_READ32(dev_priv->mmio, (reg) )
+#define MACH64_WRITE(reg,val)	DRM_WRITE32(dev_priv->mmio, (reg), (val) )
+
+#define DWMREG0		0x0400
+#define DWMREG0_END	0x07ff
+#define DWMREG1		0x0000
+#define DWMREG1_END	0x03ff
+
+#define ISREG0(r)	(((r) >= DWMREG0) && ((r) <= DWMREG0_END))
+#define DMAREG0(r)	(((r) - DWMREG0) >> 2)
+#define DMAREG1(r)	((((r) - DWMREG1) >> 2 ) | 0x0100)
+#define DMAREG(r)	(ISREG0(r) ? DMAREG0(r) : DMAREG1(r))
+
+#define MMREG0		0x0000
+#define MMREG0_END	0x00ff
+
+#define ISMMREG0(r)	(((r) >= MMREG0) && ((r) <= MMREG0_END))
+#define MMSELECT0(r)	(((r) << 2) + DWMREG0)
+#define MMSELECT1(r)	(((((r) & 0xff) << 2) + DWMREG1))
+#define MMSELECT(r)	(ISMMREG0(r) ? MMSELECT0(r) : MMSELECT1(r))
+
+/* ================================================================
+ * DMA constants
+ */
+
+/* DMA descriptor field indices:
+ * The descriptor fields are loaded into the read-only
+ * BM_* system bus master registers during a bus-master operation
+ */
+#define MACH64_DMA_FRAME_BUF_OFFSET	0	/* BM_FRAME_BUF_OFFSET */
+#define MACH64_DMA_SYS_MEM_ADDR		1	/* BM_SYSTEM_MEM_ADDR */
+#define MACH64_DMA_COMMAND		2	/* BM_COMMAND */
+#define MACH64_DMA_RESERVED		3	/* BM_STATUS */
+
+/* BM_COMMAND descriptor field flags */
+#define MACH64_DMA_HOLD_OFFSET		(1<<30)	/* Don't increment DMA_FRAME_BUF_OFFSET */
+#define MACH64_DMA_EOL			(1<<31)	/* End of descriptor list flag */
+
+#define MACH64_DMA_CHUNKSIZE	        0x1000	/* 4kB per DMA descriptor */
+#define MACH64_APERTURE_OFFSET	        0x7ff800	/* frame-buffer offset for gui-masters */
+
+/* ================================================================
+ * Misc helper macros
+ */
+
+static __inline__ void mach64_set_dma_eol(volatile u32 * addr)
+{
+#if defined(__i386__)
+	int nr = 31;
+
+	/* Taken from include/asm-i386/bitops.h linux header */
+	__asm__ __volatile__("lock;" "btsl %1,%0":"=m"(*addr)
+			     :"Ir"(nr));
+#elif defined(__powerpc__)
+	u32 old;
+	u32 mask = cpu_to_le32(MACH64_DMA_EOL);
+
+	/* Taken from the include/asm-ppc/bitops.h linux header */
+	__asm__ __volatile__("\n\
+1:	lwarx	%0,0,%3 \n\
+	or	%0,%0,%2 \n\
+	stwcx.	%0,0,%3 \n\
+	bne-	1b":"=&r"(old), "=m"(*addr)
+			     :"r"(mask), "r"(addr), "m"(*addr)
+			     :"cc");
+#elif defined(__alpha__)
+	u32 temp;
+	u32 mask = MACH64_DMA_EOL;
+
+	/* Taken from the include/asm-alpha/bitops.h linux header */
+	__asm__ __volatile__("1:	ldl_l %0,%3\n"
+			     "	bis %0,%2,%0\n"
+			     "	stl_c %0,%1\n"
+			     "	beq %0,2f\n"
+			     ".subsection 2\n"
+			     "2:	br 1b\n"
+			     ".previous":"=&r"(temp), "=m"(*addr)
+			     :"Ir"(mask), "m"(*addr));
+#else
+	u32 mask = cpu_to_le32(MACH64_DMA_EOL);
+
+	*addr |= mask;
+#endif
+}
+
+static __inline__ void mach64_clear_dma_eol(volatile u32 * addr)
+{
+#if defined(__i386__)
+	int nr = 31;
+
+	/* Taken from include/asm-i386/bitops.h linux header */
+	__asm__ __volatile__("lock;" "btrl %1,%0":"=m"(*addr)
+			     :"Ir"(nr));
+#elif defined(__powerpc__)
+	u32 old;
+	u32 mask = cpu_to_le32(MACH64_DMA_EOL);
+
+	/* Taken from the include/asm-ppc/bitops.h linux header */
+	__asm__ __volatile__("\n\
+1:	lwarx	%0,0,%3 \n\
+	andc	%0,%0,%2 \n\
+	stwcx.	%0,0,%3 \n\
+	bne-	1b":"=&r"(old), "=m"(*addr)
+			     :"r"(mask), "r"(addr), "m"(*addr)
+			     :"cc");
+#elif defined(__alpha__)
+	u32 temp;
+	u32 mask = ~MACH64_DMA_EOL;
+
+	/* Taken from the include/asm-alpha/bitops.h linux header */
+	__asm__ __volatile__("1:	ldl_l %0,%3\n"
+			     "	and %0,%2,%0\n"
+			     "	stl_c %0,%1\n"
+			     "	beq %0,2f\n"
+			     ".subsection 2\n"
+			     "2:	br 1b\n"
+			     ".previous":"=&r"(temp), "=m"(*addr)
+			     :"Ir"(mask), "m"(*addr));
+#else
+	u32 mask = cpu_to_le32(~MACH64_DMA_EOL);
+
+	*addr &= mask;
+#endif
+}
+
+static __inline__ void mach64_ring_start(drm_mach64_private_t * dev_priv)
+{
+	drm_mach64_descriptor_ring_t *ring = &dev_priv->ring;
+
+	DRM_DEBUG("%s: head_addr: 0x%08x head: %d tail: %d space: %d\n",
+		  __FUNCTION__,
+		  ring->head_addr, ring->head, ring->tail, ring->space);
+
+	if (mach64_do_wait_for_idle(dev_priv) < 0) {
+		mach64_do_engine_reset(dev_priv);
+	}
+
+	if (dev_priv->driver_mode != MACH64_MODE_MMIO) {
+		/* enable bus mastering and block 1 registers */
+		MACH64_WRITE(MACH64_BUS_CNTL,
+			     (MACH64_READ(MACH64_BUS_CNTL) &
+			      ~MACH64_BUS_MASTER_DIS)
+			     | MACH64_BUS_EXT_REG_EN);
+		mach64_do_wait_for_idle(dev_priv);
+	}
+
+	/* reset descriptor table ring head */
+	MACH64_WRITE(MACH64_BM_GUI_TABLE_CMD,
+		     ring->head_addr | MACH64_CIRCULAR_BUF_SIZE_16KB);
+
+	dev_priv->ring_running = 1;
+}
+
+static __inline__ void mach64_ring_resume(drm_mach64_private_t * dev_priv,
+					  drm_mach64_descriptor_ring_t * ring)
+{
+	DRM_DEBUG("%s: head_addr: 0x%08x head: %d tail: %d space: %d\n",
+		  __FUNCTION__,
+		  ring->head_addr, ring->head, ring->tail, ring->space);
+
+	/* reset descriptor table ring head */
+	MACH64_WRITE(MACH64_BM_GUI_TABLE_CMD,
+		     ring->head_addr | MACH64_CIRCULAR_BUF_SIZE_16KB);
+
+	if (dev_priv->driver_mode == MACH64_MODE_MMIO) {
+		mach64_do_dispatch_pseudo_dma(dev_priv);
+	} else {
+		/* enable GUI bus mastering, and sync the bus master to the GUI */
+		MACH64_WRITE(MACH64_SRC_CNTL,
+			     MACH64_SRC_BM_ENABLE | MACH64_SRC_BM_SYNC |
+			     MACH64_SRC_BM_OP_SYSTEM_TO_REG);
+
+		/* kick off the transfer */
+		MACH64_WRITE(MACH64_DST_HEIGHT_WIDTH, 0);
+		if (dev_priv->driver_mode == MACH64_MODE_DMA_SYNC) {
+			if ((mach64_do_wait_for_idle(dev_priv)) < 0) {
+				DRM_ERROR("%s: idle failed, resetting engine\n",
+					  __FUNCTION__);
+				mach64_dump_engine_info(dev_priv);
+				mach64_do_engine_reset(dev_priv);
+				return;
+			}
+			mach64_do_release_used_buffers(dev_priv);
+		}
+	}
+}
+
+static __inline__ void mach64_ring_tick(drm_mach64_private_t * dev_priv,
+					drm_mach64_descriptor_ring_t * ring)
+{
+	DRM_DEBUG("%s: head_addr: 0x%08x head: %d tail: %d space: %d\n",
+		  __FUNCTION__,
+		  ring->head_addr, ring->head, ring->tail, ring->space);
+
+	if (!dev_priv->ring_running) {
+		mach64_ring_start(dev_priv);
+
+		if (ring->head != ring->tail) {
+			mach64_ring_resume(dev_priv, ring);
+		}
+	} else {
+		/* GUI_ACTIVE must be read before BM_GUI_TABLE to
+		 * correctly determine the ring head
+		 */
+		int gui_active =
+		    MACH64_READ(MACH64_GUI_STAT) & MACH64_GUI_ACTIVE;
+
+		ring->head_addr = MACH64_READ(MACH64_BM_GUI_TABLE) & 0xfffffff0;
+
+		if (gui_active) {
+			/* If not idle, BM_GUI_TABLE points one descriptor
+			 * past the current head
+			 */
+			if (ring->head_addr == ring->start_addr) {
+				ring->head_addr += ring->size;
+			}
+			ring->head_addr -= 4 * sizeof(u32);
+		}
+
+		if (ring->head_addr < ring->start_addr ||
+		    ring->head_addr >= ring->start_addr + ring->size) {
+			DRM_ERROR("bad ring head address: 0x%08x\n",
+				  ring->head_addr);
+			mach64_dump_ring_info(dev_priv);
+			mach64_do_engine_reset(dev_priv);
+			return;
+		}
+
+		ring->head = (ring->head_addr - ring->start_addr) / sizeof(u32);
+
+		if (!gui_active && ring->head != ring->tail) {
+			mach64_ring_resume(dev_priv, ring);
+		}
+	}
+}
+
+static __inline__ void mach64_ring_stop(drm_mach64_private_t * dev_priv)
+{
+	DRM_DEBUG("%s: head_addr: 0x%08x head: %d tail: %d space: %d\n",
+		  __FUNCTION__,
+		  dev_priv->ring.head_addr, dev_priv->ring.head,
+		  dev_priv->ring.tail, dev_priv->ring.space);
+
+	/* restore previous SRC_CNTL to disable busmastering */
+	mach64_do_wait_for_fifo(dev_priv, 1);
+	MACH64_WRITE(MACH64_SRC_CNTL, 0);
+
+	/* disable busmastering but keep the block 1 registers enabled */
+	mach64_do_wait_for_idle(dev_priv);
+	MACH64_WRITE(MACH64_BUS_CNTL, MACH64_READ(MACH64_BUS_CNTL)
+		     | MACH64_BUS_MASTER_DIS | MACH64_BUS_EXT_REG_EN);
+
+	dev_priv->ring_running = 0;
+}
+
+static __inline__ void
+mach64_update_ring_snapshot(drm_mach64_private_t * dev_priv)
+{
+	drm_mach64_descriptor_ring_t *ring = &dev_priv->ring;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	mach64_ring_tick(dev_priv, ring);
+
+	ring->space = (ring->head - ring->tail) * sizeof(u32);
+	if (ring->space <= 0) {
+		ring->space += ring->size;
+	}
+}
+
+/* ================================================================
+ * DMA descriptor ring macros
+ */
+
+#define RING_LOCALS									\
+	int _ring_tail, _ring_write; unsigned int _ring_mask; volatile u32 *_ring
+
+#define RING_WRITE_OFS  _ring_write
+
+#define BEGIN_RING( n ) 								\
+do {											\
+	if ( MACH64_VERBOSE ) {								\
+		DRM_INFO( "BEGIN_RING( %d ) in %s\n",					\
+			   (n), __FUNCTION__ );						\
+	}										\
+	if ( dev_priv->ring.space <= (n) * sizeof(u32) ) {				\
+		int ret;								\
+		if ((ret=mach64_wait_ring( dev_priv, (n) * sizeof(u32))) < 0 ) {	\
+			DRM_ERROR( "wait_ring failed, resetting engine\n");		\
+			mach64_dump_engine_info( dev_priv );				\
+			mach64_do_engine_reset( dev_priv );				\
+			return ret;							\
+		}									\
+	}										\
+	dev_priv->ring.space -= (n) * sizeof(u32);					\
+	_ring = (u32 *) dev_priv->ring.start;						\
+	_ring_tail = _ring_write = dev_priv->ring.tail;					\
+	_ring_mask = dev_priv->ring.tail_mask;						\
+} while (0)
+
+#define OUT_RING( x )						\
+do {								\
+	if ( MACH64_VERBOSE ) {					\
+		DRM_INFO( "   OUT_RING( 0x%08x ) at 0x%x\n",	\
+			   (unsigned int)(x), _ring_write );	\
+	}							\
+	_ring[_ring_write++] = cpu_to_le32( x );		\
+	_ring_write &= _ring_mask;				\
+} while (0)
+
+#define ADVANCE_RING() 							\
+do {									\
+	if ( MACH64_VERBOSE ) {						\
+		DRM_INFO( "ADVANCE_RING() wr=0x%06x tail=0x%06x\n",	\
+			  _ring_write, _ring_tail );			\
+	}								\
+	DRM_MEMORYBARRIER();						\
+	mach64_clear_dma_eol( &_ring[(_ring_tail - 2) & _ring_mask] );	\
+	DRM_MEMORYBARRIER();						\
+	dev_priv->ring.tail = _ring_write;				\
+	mach64_ring_tick( dev_priv, &(dev_priv)->ring );		\
+} while (0)
+
+/* ================================================================
+ * DMA macros
+ */
+
+#define DMALOCALS				\
+	drm_mach64_freelist_t *_entry = NULL;	\
+	drm_buf_t *_buf = NULL; 		\
+	u32 *_buf_wptr; int _outcount
+
+#define GETBUFPTR( __buf )						\
+((dev_priv->is_pci) ? 							\
+	((u32 *)(__buf)->address) : 					\
+	((u32 *)((char *)dev_priv->dev_buffers->handle + (__buf)->offset)))
+
+#define GETBUFADDR( __buf ) ((u32)(__buf)->bus_address)
+
+#define GETRINGOFFSET() (_entry->ring_ofs)
+
+static __inline__ int mach64_find_pending_buf_entry(drm_mach64_private_t *
+						    dev_priv,
+						    drm_mach64_freelist_t **
+						    entry, drm_buf_t * buf)
+{
+	struct list_head *ptr;
+#if MACH64_EXTRA_CHECKING
+	if (list_empty(&dev_priv->pending)) {
+		DRM_ERROR("Empty pending list in %s\n", __FUNCTION__);
+		return DRM_ERR(EINVAL);
+	}
+#endif
+	ptr = dev_priv->pending.prev;
+	*entry = list_entry(ptr, drm_mach64_freelist_t, list);
+	while ((*entry)->buf != buf) {
+		if (ptr == &dev_priv->pending) {
+			return DRM_ERR(EFAULT);
+		}
+		ptr = ptr->prev;
+		*entry = list_entry(ptr, drm_mach64_freelist_t, list);
+	}
+	return 0;
+}
+
+#define DMASETPTR( _p ) 			\
+do {						\
+	_buf = (_p);				\
+	_outcount = 0;				\
+	_buf_wptr = GETBUFPTR( _buf );		\
+} while(0)
+
+/* FIXME: use a private set of smaller buffers for state emits, clears, and swaps? */
+#define DMAGETPTR( filp, dev_priv, n )					\
+do {									\
+	if ( MACH64_VERBOSE ) {						\
+		DRM_INFO( "DMAGETPTR( %d ) in %s\n",			\
+			  n, __FUNCTION__ );				\
+	}								\
+	_buf = mach64_freelist_get( dev_priv );				\
+	if (_buf == NULL) {						\
+		DRM_ERROR("%s: couldn't get buffer in DMAGETPTR\n",	\
+			   __FUNCTION__ );				\
+		return DRM_ERR(EAGAIN);					\
+	}								\
+	if (_buf->pending) {						\
+	        DRM_ERROR("%s: pending buf in DMAGETPTR\n",		\
+			   __FUNCTION__ );				\
+		return DRM_ERR(EFAULT);					\
+	}								\
+	_buf->filp = filp;						\
+	_outcount = 0;							\
+									\
+        _buf_wptr = GETBUFPTR( _buf );					\
+} while (0)
+
+#define DMAOUTREG( reg, val )					\
+do {								\
+	if ( MACH64_VERBOSE ) {					\
+		DRM_INFO( "   DMAOUTREG( 0x%x = 0x%08x )\n",	\
+			  reg, val );				\
+	}							\
+	_buf_wptr[_outcount++] = cpu_to_le32(DMAREG(reg));	\
+	_buf_wptr[_outcount++] = cpu_to_le32((val));		\
+	_buf->used += 8;					\
+} while (0)
+
+#define DMAADVANCE( dev_priv, _discard )						     \
+do {											     \
+	struct list_head *ptr;								     \
+	RING_LOCALS;									     \
+											     \
+	if ( MACH64_VERBOSE ) {								     \
+		DRM_INFO( "DMAADVANCE() in %s\n", __FUNCTION__ );			     \
+	}										     \
+											     \
+	if (_buf->used <= 0) {								     \
+		DRM_ERROR( "DMAADVANCE() in %s: sending empty buf %d\n",		     \
+				   __FUNCTION__, _buf->idx );				     \
+		return DRM_ERR(EFAULT);							     \
+	}										     \
+	if (_buf->pending) {								     \
+                /* This is a resued buffer, so we need to find it in the pending list */     \
+		int ret;								     \
+		if ( (ret=mach64_find_pending_buf_entry(dev_priv, &_entry, _buf)) ) {	     \
+			DRM_ERROR( "DMAADVANCE() in %s: couldn't find pending buf %d\n",     \
+				   __FUNCTION__, _buf->idx );				     \
+			return ret;							     \
+		}									     \
+		if (_entry->discard) {							     \
+			DRM_ERROR( "DMAADVANCE() in %s: sending discarded pending buf %d\n", \
+				   __FUNCTION__, _buf->idx );				     \
+			return DRM_ERR(EFAULT);						     \
+		}									     \
+     	} else {									     \
+		if (list_empty(&dev_priv->placeholders)) {				     \
+			DRM_ERROR( "DMAADVANCE() in %s: empty placeholder list\n",	     \
+			   	__FUNCTION__ );						     \
+			return DRM_ERR(EFAULT);						     \
+		}									     \
+		ptr = dev_priv->placeholders.next;					     \
+		list_del(ptr);								     \
+		_entry = list_entry(ptr, drm_mach64_freelist_t, list);			     \
+		_buf->pending = 1;							     \
+		_entry->buf = _buf;							     \
+		list_add_tail(ptr, &dev_priv->pending);					     \
+	}										     \
+	_entry->discard = (_discard);							     \
+	ADD_BUF_TO_RING( dev_priv );							     \
+} while (0)
+
+#define DMADISCARDBUF()									\
+do {											\
+	if (_entry == NULL) {								\
+		int ret;								\
+		if ( (ret=mach64_find_pending_buf_entry(dev_priv, &_entry, _buf)) ) {	\
+			DRM_ERROR( "%s: couldn't find pending buf %d\n",		\
+				   __FUNCTION__, _buf->idx );				\
+			return ret;							\
+		}									\
+	}										\
+	_entry->discard = 1;								\
+} while(0)
+
+#define ADD_BUF_TO_RING( dev_priv )							\
+do {											\
+	int bytes, pages, remainder;							\
+	u32 address, page;								\
+	int i;										\
+											\
+	bytes = _buf->used;								\
+	address = GETBUFADDR( _buf );							\
+											\
+	pages = (bytes + MACH64_DMA_CHUNKSIZE - 1) / MACH64_DMA_CHUNKSIZE;		\
+											\
+	BEGIN_RING( pages * 4 );							\
+											\
+	for ( i = 0 ; i < pages-1 ; i++ ) {						\
+		page = address + i * MACH64_DMA_CHUNKSIZE;				\
+		OUT_RING( MACH64_APERTURE_OFFSET + MACH64_BM_ADDR );			\
+		OUT_RING( page );							\
+		OUT_RING( MACH64_DMA_CHUNKSIZE | MACH64_DMA_HOLD_OFFSET );		\
+		OUT_RING( 0 );								\
+	}										\
+											\
+	/* generate the final descriptor for any remaining commands in this buffer */	\
+	page = address + i * MACH64_DMA_CHUNKSIZE;					\
+	remainder = bytes - i * MACH64_DMA_CHUNKSIZE;					\
+											\
+	/* Save dword offset of last descriptor for this buffer.			\
+	 * This is needed to check for completion of the buffer in freelist_get		\
+	 */										\
+	_entry->ring_ofs = RING_WRITE_OFS;						\
+											\
+	OUT_RING( MACH64_APERTURE_OFFSET + MACH64_BM_ADDR );				\
+	OUT_RING( page );								\
+	OUT_RING( remainder | MACH64_DMA_HOLD_OFFSET | MACH64_DMA_EOL );		\
+	OUT_RING( 0 );									\
+											\
+	ADVANCE_RING();									\
+} while(0)
+
+#define DMAADVANCEHOSTDATA( dev_priv )							\
+do {											\
+	struct list_head *ptr;								\
+	RING_LOCALS;									\
+											\
+	if ( MACH64_VERBOSE ) {								\
+		DRM_INFO( "DMAADVANCEHOSTDATA() in %s\n", __FUNCTION__ );		\
+	}										\
+											\
+	if (_buf->used <= 0) {								\
+		DRM_ERROR( "DMAADVANCEHOSTDATA() in %s: sending empty buf %d\n",	\
+				   __FUNCTION__, _buf->idx );				\
+		return DRM_ERR(EFAULT);							\
+	}										\
+	if (list_empty(&dev_priv->placeholders)) {					\
+		DRM_ERROR( "%s: empty placeholder list in DMAADVANCEHOSTDATA()\n",	\
+			   __FUNCTION__ );						\
+		return DRM_ERR(EFAULT);							\
+	}										\
+											\
+        ptr = dev_priv->placeholders.next;						\
+	list_del(ptr);									\
+	_entry = list_entry(ptr, drm_mach64_freelist_t, list);				\
+	_entry->buf = _buf;								\
+	_entry->buf->pending = 1;							\
+	list_add_tail(ptr, &dev_priv->pending);						\
+	_entry->discard = 1;								\
+	ADD_HOSTDATA_BUF_TO_RING( dev_priv );						\
+} while (0)
+
+#define ADD_HOSTDATA_BUF_TO_RING( dev_priv )						 \
+do {											 \
+	int bytes, pages, remainder;							 \
+	u32 address, page;								 \
+	int i;										 \
+											 \
+	bytes = _buf->used - MACH64_HOSTDATA_BLIT_OFFSET;				 \
+	pages = (bytes + MACH64_DMA_CHUNKSIZE - 1) / MACH64_DMA_CHUNKSIZE;		 \
+	address = GETBUFADDR( _buf );							 \
+											 \
+	BEGIN_RING( 4 + pages * 4 );							 \
+											 \
+	OUT_RING( MACH64_APERTURE_OFFSET + MACH64_BM_ADDR );				 \
+	OUT_RING( address );								 \
+	OUT_RING( MACH64_HOSTDATA_BLIT_OFFSET | MACH64_DMA_HOLD_OFFSET );		 \
+	OUT_RING( 0 );									 \
+											 \
+	address += MACH64_HOSTDATA_BLIT_OFFSET;						 \
+											 \
+	for ( i = 0 ; i < pages-1 ; i++ ) {						 \
+		page = address + i * MACH64_DMA_CHUNKSIZE;				 \
+		OUT_RING( MACH64_APERTURE_OFFSET + MACH64_BM_HOSTDATA );		 \
+		OUT_RING( page );							 \
+		OUT_RING( MACH64_DMA_CHUNKSIZE | MACH64_DMA_HOLD_OFFSET );		 \
+		OUT_RING( 0 );								 \
+	}										 \
+											 \
+	/* generate the final descriptor for any remaining commands in this buffer */	 \
+	page = address + i * MACH64_DMA_CHUNKSIZE;					 \
+	remainder = bytes - i * MACH64_DMA_CHUNKSIZE;					 \
+											 \
+	/* Save dword offset of last descriptor for this buffer.			 \
+	 * This is needed to check for completion of the buffer in freelist_get		 \
+	 */										 \
+	_entry->ring_ofs = RING_WRITE_OFS;						 \
+											 \
+	OUT_RING( MACH64_APERTURE_OFFSET + MACH64_BM_HOSTDATA );			 \
+	OUT_RING( page );								 \
+	OUT_RING( remainder | MACH64_DMA_HOLD_OFFSET | MACH64_DMA_EOL );		 \
+	OUT_RING( 0 );									 \
+											 \
+	ADVANCE_RING();									 \
+} while(0)
+
+#endif				/* __MACH64_DRV_H__ */
diff -purN linux-2.6.12.orig/drivers/char/drm/mach64_irq.c linux-2.6.12/drivers/char/drm/mach64_irq.c
--- linux-2.6.12.orig/drivers/char/drm/mach64_irq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/drm/mach64_irq.c	2005-07-05 08:37:47.000000000 +0200
@@ -0,0 +1,135 @@
+/* mach64_irq.c -- IRQ handling for ATI Mach64 -*- linux-c -*-
+ * Created: Tue Feb 25, 2003 by Leif Delgass, based on radeon_irq.c/r128_irq.c
+ *
+ * Copyright (C) The Weather Channel, Inc.  2002.
+ * Copyright 2003 Leif Delgass
+ * All Rights Reserved.
+ *
+ * The Weather Channel (TM) funded Tungsten Graphics to develop the
+ * initial release of the Radeon 8500 driver under the XFree86 license.
+ * This notice must be preserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Keith Whitwell <keith@tungstengraphics.com>
+ *    Eric Anholt <anholt@FreeBSD.org>
+ *    Leif Delgass <ldelgass@retinalburn.net>
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "mach64_drm.h"
+#include "mach64_drv.h"
+
+irqreturn_t mach64_driver_irq_handler(DRM_IRQ_ARGS)
+{
+	drm_device_t *dev = (drm_device_t *) arg;
+	drm_mach64_private_t *dev_priv =
+	    (drm_mach64_private_t *) dev->dev_private;
+	int status;
+
+	status = MACH64_READ(MACH64_CRTC_INT_CNTL);
+
+	/* VBLANK interrupt */
+	if (status & MACH64_CRTC_VBLANK_INT) {
+		/* Mask off all interrupt ack bits before setting the ack bit, since
+		 * there may be other handlers outside the DRM.
+		 *
+		 * NOTE: On mach64, you need to keep the enable bits set when doing
+		 * the ack, despite what the docs say about not acking and enabling
+		 * in a single write.
+		 */
+		MACH64_WRITE(MACH64_CRTC_INT_CNTL,
+			     (status & ~MACH64_CRTC_INT_ACKS)
+			     | MACH64_CRTC_VBLANK_INT);
+
+		atomic_inc(&dev->vbl_received);
+		DRM_WAKEUP(&dev->vbl_queue);
+		drm_vbl_send_signals(dev);
+		return IRQ_HANDLED;
+	}
+	return IRQ_NONE;
+}
+
+int mach64_driver_vblank_wait(drm_device_t * dev, unsigned int *sequence)
+{
+	unsigned int cur_vblank;
+	int ret = 0;
+
+	/* Assume that the user has missed the current sequence number
+	 * by about a day rather than she wants to wait for years
+	 * using vertical blanks...
+	 */
+	DRM_WAIT_ON(ret, dev->vbl_queue, 3 * DRM_HZ,
+		    (((cur_vblank = atomic_read(&dev->vbl_received))
+		      - *sequence) <= (1 << 23)));
+
+	*sequence = cur_vblank;
+
+	return ret;
+}
+
+/* drm_dma.h hooks
+*/
+void mach64_driver_irq_preinstall(drm_device_t * dev)
+{
+	drm_mach64_private_t *dev_priv =
+	    (drm_mach64_private_t *) dev->dev_private;
+
+	u32 status = MACH64_READ(MACH64_CRTC_INT_CNTL);
+
+	DRM_DEBUG("before install CRTC_INT_CTNL: 0x%08x\n", status);
+
+	/* Disable and clear VBLANK interrupt */
+	MACH64_WRITE(MACH64_CRTC_INT_CNTL, (status & ~MACH64_CRTC_VBLANK_INT_EN)
+		     | MACH64_CRTC_VBLANK_INT);
+}
+
+void mach64_driver_irq_postinstall(drm_device_t * dev)
+{
+	drm_mach64_private_t *dev_priv =
+	    (drm_mach64_private_t *) dev->dev_private;
+
+	/* Turn on VBLANK interrupt */
+	MACH64_WRITE(MACH64_CRTC_INT_CNTL, MACH64_READ(MACH64_CRTC_INT_CNTL)
+		     | MACH64_CRTC_VBLANK_INT_EN);
+
+	DRM_DEBUG("after install CRTC_INT_CTNL: 0x%08x\n",
+		  MACH64_READ(MACH64_CRTC_INT_CNTL));
+
+}
+
+void mach64_driver_irq_uninstall(drm_device_t * dev)
+{
+	drm_mach64_private_t *dev_priv =
+	    (drm_mach64_private_t *) dev->dev_private;
+	if (!dev_priv)
+		return;
+
+	/* Disable and clear VBLANK interrupt */
+	MACH64_WRITE(MACH64_CRTC_INT_CNTL,
+		     (MACH64_READ(MACH64_CRTC_INT_CNTL) &
+		      ~MACH64_CRTC_VBLANK_INT_EN)
+		     | MACH64_CRTC_VBLANK_INT);
+
+	DRM_DEBUG("after uninstall CRTC_INT_CTNL: 0x%08x\n",
+		  MACH64_READ(MACH64_CRTC_INT_CNTL));
+}
diff -purN linux-2.6.12.orig/drivers/char/drm/mach64_state.c linux-2.6.12/drivers/char/drm/mach64_state.c
--- linux-2.6.12.orig/drivers/char/drm/mach64_state.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/drm/mach64_state.c	2005-07-05 08:37:47.000000000 +0200
@@ -0,0 +1,916 @@
+/* mach64_state.c -- State support for mach64 (Rage Pro) driver -*- linux-c -*-
+ * Created: Sun Dec 03 19:20:26 2000 by gareth@valinux.com
+ *
+ * Copyright 2000 Gareth Hughes
+ * Copyright 2002-2003 Leif Delgass
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT OWNER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Gareth Hughes <gareth@valinux.com>
+ *    Leif Delgass <ldelgass@retinalburn.net>
+ *    JosFonseca <j_r_fonseca@yahoo.co.uk>
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "mach64_drm.h"
+#include "mach64_drv.h"
+
+/* Interface history:
+ *
+ * 1.0 - Initial mach64 DRM
+ *
+ */
+drm_ioctl_desc_t mach64_ioctls[] = {
+	[DRM_IOCTL_NR(DRM_MACH64_INIT)] = {mach64_dma_init, 1, 1},
+	[DRM_IOCTL_NR(DRM_MACH64_CLEAR)] = {mach64_dma_clear, 1, 0},
+	[DRM_IOCTL_NR(DRM_MACH64_SWAP)] = {mach64_dma_swap, 1, 0},
+	[DRM_IOCTL_NR(DRM_MACH64_IDLE)] = {mach64_dma_idle, 1, 0},
+	[DRM_IOCTL_NR(DRM_MACH64_RESET)] = {mach64_engine_reset, 1, 0},
+	[DRM_IOCTL_NR(DRM_MACH64_VERTEX)] = {mach64_dma_vertex, 1, 0},
+	[DRM_IOCTL_NR(DRM_MACH64_BLIT)] = {mach64_dma_blit, 1, 0},
+	[DRM_IOCTL_NR(DRM_MACH64_FLUSH)] = {mach64_dma_flush, 1, 0},
+	[DRM_IOCTL_NR(DRM_MACH64_GETPARAM)] = {mach64_get_param, 1, 0},
+};
+
+int mach64_max_ioctl = DRM_ARRAY_SIZE(mach64_ioctls);
+
+/* ================================================================
+ * DMA hardware state programming functions
+ */
+
+static void mach64_print_dirty(const char *msg, unsigned int flags)
+{
+	DRM_DEBUG("%s: (0x%x) %s%s%s%s%s%s%s%s%s%s%s%s\n",
+		  msg,
+		  flags,
+		  (flags & MACH64_UPLOAD_DST_OFF_PITCH) ? "dst_off_pitch, " :
+		  "",
+		  (flags & MACH64_UPLOAD_Z_ALPHA_CNTL) ? "z_alpha_cntl, " : "",
+		  (flags & MACH64_UPLOAD_SCALE_3D_CNTL) ? "scale_3d_cntl, " :
+		  "", (flags & MACH64_UPLOAD_DP_FOG_CLR) ? "dp_fog_clr, " : "",
+		  (flags & MACH64_UPLOAD_DP_WRITE_MASK) ? "dp_write_mask, " :
+		  "",
+		  (flags & MACH64_UPLOAD_DP_PIX_WIDTH) ? "dp_pix_width, " : "",
+		  (flags & MACH64_UPLOAD_SETUP_CNTL) ? "setup_cntl, " : "",
+		  (flags & MACH64_UPLOAD_MISC) ? "misc, " : "",
+		  (flags & MACH64_UPLOAD_TEXTURE) ? "texture, " : "",
+		  (flags & MACH64_UPLOAD_TEX0IMAGE) ? "tex0 image, " : "",
+		  (flags & MACH64_UPLOAD_TEX1IMAGE) ? "tex1 image, " : "",
+		  (flags & MACH64_UPLOAD_CLIPRECTS) ? "cliprects, " : "");
+}
+
+/* Mach64 doesn't have hardware cliprects, just one hardware scissor,
+ * so the GL scissor is intersected with each cliprect here
+ */
+/* This function returns 0 on success, 1 for no intersection, and
+ * negative for an error
+ */
+static int mach64_emit_cliprect(DRMFILE filp, drm_mach64_private_t * dev_priv,
+				drm_clip_rect_t * box)
+{
+	u32 sc_left_right, sc_top_bottom;
+	drm_clip_rect_t scissor;
+	drm_mach64_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_mach64_context_regs_t *regs = &sarea_priv->context_state;
+	DMALOCALS;
+
+	DRM_DEBUG("%s: box=%p\n", __FUNCTION__, box);
+
+	/* Get GL scissor */
+	/* FIXME: store scissor in SAREA as a cliprect instead of in
+	 * hardware format, or do intersection client-side
+	 */
+	scissor.x1 = regs->sc_left_right & 0xffff;
+	scissor.x2 = (regs->sc_left_right & 0xffff0000) >> 16;
+	scissor.y1 = regs->sc_top_bottom & 0xffff;
+	scissor.y2 = (regs->sc_top_bottom & 0xffff0000) >> 16;
+
+	/* Intersect GL scissor with cliprect */
+	if (box->x1 > scissor.x1)
+		scissor.x1 = box->x1;
+	if (box->y1 > scissor.y1)
+		scissor.y1 = box->y1;
+	if (box->x2 < scissor.x2)
+		scissor.x2 = box->x2;
+	if (box->y2 < scissor.y2)
+		scissor.y2 = box->y2;
+	/* positive return means skip */
+	if (scissor.x1 >= scissor.x2)
+		return 1;
+	if (scissor.y1 >= scissor.y2)
+		return 1;
+
+	DMAGETPTR(filp, dev_priv, 2);	/* returns on failure to get buffer */
+
+	sc_left_right = ((scissor.x1 << 0) | (scissor.x2 << 16));
+	sc_top_bottom = ((scissor.y1 << 0) | (scissor.y2 << 16));
+
+	DMAOUTREG(MACH64_SC_LEFT_RIGHT, sc_left_right);
+	DMAOUTREG(MACH64_SC_TOP_BOTTOM, sc_top_bottom);
+
+	DMAADVANCE(dev_priv, 1);
+
+	return 0;
+}
+
+static __inline__ int mach64_emit_state(DRMFILE filp,
+					drm_mach64_private_t * dev_priv)
+{
+	drm_mach64_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_mach64_context_regs_t *regs = &sarea_priv->context_state;
+	unsigned int dirty = sarea_priv->dirty;
+	u32 offset = ((regs->tex_size_pitch & 0xf0) >> 2);
+	DMALOCALS;
+
+	if (MACH64_VERBOSE) {
+		mach64_print_dirty(__FUNCTION__, dirty);
+	} else {
+		DRM_DEBUG("%s: dirty=0x%08x\n", __FUNCTION__, dirty);
+	}
+
+	DMAGETPTR(filp, dev_priv, 17);	/* returns on failure to get buffer */
+
+	if (dirty & MACH64_UPLOAD_MISC) {
+		DMAOUTREG(MACH64_DP_MIX, regs->dp_mix);
+		DMAOUTREG(MACH64_DP_SRC, regs->dp_src);
+		DMAOUTREG(MACH64_CLR_CMP_CNTL, regs->clr_cmp_cntl);
+		DMAOUTREG(MACH64_GUI_TRAJ_CNTL, regs->gui_traj_cntl);
+		sarea_priv->dirty &= ~MACH64_UPLOAD_MISC;
+	}
+
+	if (dirty & MACH64_UPLOAD_DST_OFF_PITCH) {
+		DMAOUTREG(MACH64_DST_OFF_PITCH, regs->dst_off_pitch);
+		sarea_priv->dirty &= ~MACH64_UPLOAD_DST_OFF_PITCH;
+	}
+	if (dirty & MACH64_UPLOAD_Z_OFF_PITCH) {
+		DMAOUTREG(MACH64_Z_OFF_PITCH, regs->z_off_pitch);
+		sarea_priv->dirty &= ~MACH64_UPLOAD_Z_OFF_PITCH;
+	}
+	if (dirty & MACH64_UPLOAD_Z_ALPHA_CNTL) {
+		DMAOUTREG(MACH64_Z_CNTL, regs->z_cntl);
+		DMAOUTREG(MACH64_ALPHA_TST_CNTL, regs->alpha_tst_cntl);
+		sarea_priv->dirty &= ~MACH64_UPLOAD_Z_ALPHA_CNTL;
+	}
+	if (dirty & MACH64_UPLOAD_SCALE_3D_CNTL) {
+		DMAOUTREG(MACH64_SCALE_3D_CNTL, regs->scale_3d_cntl);
+		sarea_priv->dirty &= ~MACH64_UPLOAD_SCALE_3D_CNTL;
+	}
+	if (dirty & MACH64_UPLOAD_DP_FOG_CLR) {
+		DMAOUTREG(MACH64_DP_FOG_CLR, regs->dp_fog_clr);
+		sarea_priv->dirty &= ~MACH64_UPLOAD_DP_FOG_CLR;
+	}
+	if (dirty & MACH64_UPLOAD_DP_WRITE_MASK) {
+		DMAOUTREG(MACH64_DP_WRITE_MASK, regs->dp_write_mask);
+		sarea_priv->dirty &= ~MACH64_UPLOAD_DP_WRITE_MASK;
+	}
+	if (dirty & MACH64_UPLOAD_DP_PIX_WIDTH) {
+		DMAOUTREG(MACH64_DP_PIX_WIDTH, regs->dp_pix_width);
+		sarea_priv->dirty &= ~MACH64_UPLOAD_DP_PIX_WIDTH;
+	}
+	if (dirty & MACH64_UPLOAD_SETUP_CNTL) {
+		DMAOUTREG(MACH64_SETUP_CNTL, regs->setup_cntl);
+		sarea_priv->dirty &= ~MACH64_UPLOAD_SETUP_CNTL;
+	}
+
+	if (dirty & MACH64_UPLOAD_TEXTURE) {
+		DMAOUTREG(MACH64_TEX_SIZE_PITCH, regs->tex_size_pitch);
+		DMAOUTREG(MACH64_TEX_CNTL, regs->tex_cntl);
+		DMAOUTREG(MACH64_SECONDARY_TEX_OFF, regs->secondary_tex_off);
+		DMAOUTREG(MACH64_TEX_0_OFF + offset, regs->tex_offset);
+		sarea_priv->dirty &= ~MACH64_UPLOAD_TEXTURE;
+	}
+
+	DMAADVANCE(dev_priv, 1);
+
+	sarea_priv->dirty &= MACH64_UPLOAD_CLIPRECTS;
+
+	return 0;
+
+}
+
+/* ================================================================
+ * DMA command dispatch functions
+ */
+
+static int mach64_dma_dispatch_clear(DRMFILE filp, drm_device_t * dev,
+				     unsigned int flags,
+				     int cx, int cy, int cw, int ch,
+				     unsigned int clear_color,
+				     unsigned int clear_depth)
+{
+	drm_mach64_private_t *dev_priv = dev->dev_private;
+	drm_mach64_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_mach64_context_regs_t *ctx = &sarea_priv->context_state;
+	int nbox = sarea_priv->nbox;
+	drm_clip_rect_t *pbox = sarea_priv->boxes;
+	u32 fb_bpp, depth_bpp;
+	int i;
+	DMALOCALS;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	switch (dev_priv->fb_bpp) {
+	case 16:
+		fb_bpp = MACH64_DATATYPE_RGB565;
+		break;
+	case 32:
+		fb_bpp = MACH64_DATATYPE_ARGB8888;
+		break;
+	default:
+		return DRM_ERR(EINVAL);
+	}
+	switch (dev_priv->depth_bpp) {
+	case 16:
+		depth_bpp = MACH64_DATATYPE_RGB565;
+		break;
+	case 24:
+	case 32:
+		depth_bpp = MACH64_DATATYPE_ARGB8888;
+		break;
+	default:
+		return DRM_ERR(EINVAL);
+	}
+
+	if (!nbox)
+		return 0;
+
+	DMAGETPTR(filp, dev_priv, nbox * 31);	/* returns on failure to get buffer */
+
+	for (i = 0; i < nbox; i++) {
+		int x = pbox[i].x1;
+		int y = pbox[i].y1;
+		int w = pbox[i].x2 - x;
+		int h = pbox[i].y2 - y;
+
+		DRM_DEBUG("dispatch clear %d,%d-%d,%d flags 0x%x\n",
+			  pbox[i].x1, pbox[i].y1,
+			  pbox[i].x2, pbox[i].y2, flags);
+
+		if (flags & (MACH64_FRONT | MACH64_BACK)) {
+			/* Setup for color buffer clears
+			 */
+
+			DMAOUTREG(MACH64_Z_CNTL, 0);
+			DMAOUTREG(MACH64_SCALE_3D_CNTL, 0);
+
+			DMAOUTREG(MACH64_SC_LEFT_RIGHT, ctx->sc_left_right);
+			DMAOUTREG(MACH64_SC_TOP_BOTTOM, ctx->sc_top_bottom);
+
+			DMAOUTREG(MACH64_CLR_CMP_CNTL, 0);
+			DMAOUTREG(MACH64_GUI_TRAJ_CNTL,
+				  (MACH64_DST_X_LEFT_TO_RIGHT |
+				   MACH64_DST_Y_TOP_TO_BOTTOM));
+
+			DMAOUTREG(MACH64_DP_PIX_WIDTH, ((fb_bpp << 0) |
+							(fb_bpp << 4) |
+							(fb_bpp << 8) |
+							(fb_bpp << 16) |
+							(fb_bpp << 28)));
+
+			DMAOUTREG(MACH64_DP_FRGD_CLR, clear_color);
+			DMAOUTREG(MACH64_DP_WRITE_MASK, ctx->dp_write_mask);
+			DMAOUTREG(MACH64_DP_MIX, (MACH64_BKGD_MIX_D |
+						  MACH64_FRGD_MIX_S));
+			DMAOUTREG(MACH64_DP_SRC, (MACH64_BKGD_SRC_FRGD_CLR |
+						  MACH64_FRGD_SRC_FRGD_CLR |
+						  MACH64_MONO_SRC_ONE));
+
+		}
+
+		if (flags & MACH64_FRONT) {
+
+			DMAOUTREG(MACH64_DST_OFF_PITCH,
+				  dev_priv->front_offset_pitch);
+			DMAOUTREG(MACH64_DST_X_Y, (y << 16) | x);
+			DMAOUTREG(MACH64_DST_WIDTH_HEIGHT, (h << 16) | w);
+
+		}
+
+		if (flags & MACH64_BACK) {
+
+			DMAOUTREG(MACH64_DST_OFF_PITCH,
+				  dev_priv->back_offset_pitch);
+			DMAOUTREG(MACH64_DST_X_Y, (y << 16) | x);
+			DMAOUTREG(MACH64_DST_WIDTH_HEIGHT, (h << 16) | w);
+
+		}
+
+		if (flags & MACH64_DEPTH) {
+			/* Setup for depth buffer clear
+			 */
+			DMAOUTREG(MACH64_Z_CNTL, 0);
+			DMAOUTREG(MACH64_SCALE_3D_CNTL, 0);
+
+			DMAOUTREG(MACH64_SC_LEFT_RIGHT, ctx->sc_left_right);
+			DMAOUTREG(MACH64_SC_TOP_BOTTOM, ctx->sc_top_bottom);
+
+			DMAOUTREG(MACH64_CLR_CMP_CNTL, 0);
+			DMAOUTREG(MACH64_GUI_TRAJ_CNTL,
+				  (MACH64_DST_X_LEFT_TO_RIGHT |
+				   MACH64_DST_Y_TOP_TO_BOTTOM));
+
+			DMAOUTREG(MACH64_DP_PIX_WIDTH, ((depth_bpp << 0) |
+							(depth_bpp << 4) |
+							(depth_bpp << 8) |
+							(depth_bpp << 16) |
+							(depth_bpp << 28)));
+
+			DMAOUTREG(MACH64_DP_FRGD_CLR, clear_depth);
+			DMAOUTREG(MACH64_DP_WRITE_MASK, 0xffffffff);
+			DMAOUTREG(MACH64_DP_MIX, (MACH64_BKGD_MIX_D |
+						  MACH64_FRGD_MIX_S));
+			DMAOUTREG(MACH64_DP_SRC, (MACH64_BKGD_SRC_FRGD_CLR |
+						  MACH64_FRGD_SRC_FRGD_CLR |
+						  MACH64_MONO_SRC_ONE));
+
+			DMAOUTREG(MACH64_DST_OFF_PITCH,
+				  dev_priv->depth_offset_pitch);
+			DMAOUTREG(MACH64_DST_X_Y, (y << 16) | x);
+			DMAOUTREG(MACH64_DST_WIDTH_HEIGHT, (h << 16) | w);
+		}
+	}
+
+	DMAADVANCE(dev_priv, 1);
+
+	return 0;
+}
+
+static int mach64_dma_dispatch_swap(DRMFILE filp, drm_device_t * dev)
+{
+	drm_mach64_private_t *dev_priv = dev->dev_private;
+	drm_mach64_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	int nbox = sarea_priv->nbox;
+	drm_clip_rect_t *pbox = sarea_priv->boxes;
+	u32 fb_bpp;
+	int i;
+	DMALOCALS;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	switch (dev_priv->fb_bpp) {
+	case 16:
+		fb_bpp = MACH64_DATATYPE_RGB565;
+		break;
+	case 32:
+	default:
+		fb_bpp = MACH64_DATATYPE_ARGB8888;
+		break;
+	}
+
+	if (!nbox)
+		return 0;
+
+	DMAGETPTR(filp, dev_priv, 13 + nbox * 4);	/* returns on failure to get buffer */
+
+	DMAOUTREG(MACH64_Z_CNTL, 0);
+	DMAOUTREG(MACH64_SCALE_3D_CNTL, 0);
+
+	DMAOUTREG(MACH64_SC_LEFT_RIGHT, 0 | (8191 << 16));	/* no scissor */
+	DMAOUTREG(MACH64_SC_TOP_BOTTOM, 0 | (16383 << 16));
+
+	DMAOUTREG(MACH64_CLR_CMP_CNTL, 0);
+	DMAOUTREG(MACH64_GUI_TRAJ_CNTL, (MACH64_DST_X_LEFT_TO_RIGHT |
+					 MACH64_DST_Y_TOP_TO_BOTTOM));
+
+	DMAOUTREG(MACH64_DP_PIX_WIDTH, ((fb_bpp << 0) |
+					(fb_bpp << 4) |
+					(fb_bpp << 8) |
+					(fb_bpp << 16) | (fb_bpp << 28)));
+
+	DMAOUTREG(MACH64_DP_WRITE_MASK, 0xffffffff);
+	DMAOUTREG(MACH64_DP_MIX, (MACH64_BKGD_MIX_D | MACH64_FRGD_MIX_S));
+	DMAOUTREG(MACH64_DP_SRC, (MACH64_BKGD_SRC_BKGD_CLR |
+				  MACH64_FRGD_SRC_BLIT | MACH64_MONO_SRC_ONE));
+
+	DMAOUTREG(MACH64_SRC_OFF_PITCH, dev_priv->back_offset_pitch);
+	DMAOUTREG(MACH64_DST_OFF_PITCH, dev_priv->front_offset_pitch);
+
+	for (i = 0; i < nbox; i++) {
+		int x = pbox[i].x1;
+		int y = pbox[i].y1;
+		int w = pbox[i].x2 - x;
+		int h = pbox[i].y2 - y;
+
+		DRM_DEBUG("dispatch swap %d,%d-%d,%d\n",
+			  pbox[i].x1, pbox[i].y1, pbox[i].x2, pbox[i].y2);
+
+		DMAOUTREG(MACH64_SRC_WIDTH1, w);
+		DMAOUTREG(MACH64_SRC_Y_X, (x << 16) | y);
+		DMAOUTREG(MACH64_DST_Y_X, (x << 16) | y);
+		DMAOUTREG(MACH64_DST_WIDTH_HEIGHT, (h << 16) | w);
+
+	}
+
+	DMAADVANCE(dev_priv, 1);
+
+	if (dev_priv->driver_mode == MACH64_MODE_DMA_ASYNC) {
+		for (i = 0; i < MACH64_MAX_QUEUED_FRAMES - 1; i++) {
+			dev_priv->frame_ofs[i] = dev_priv->frame_ofs[i + 1];
+		}
+		dev_priv->frame_ofs[i] = GETRINGOFFSET();
+
+		dev_priv->sarea_priv->frames_queued++;
+	}
+
+	return 0;
+}
+
+static int mach64_do_get_frames_queued(drm_mach64_private_t * dev_priv)
+{
+	drm_mach64_descriptor_ring_t *ring = &dev_priv->ring;
+	drm_mach64_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	int i, start;
+	u32 head, tail, ofs;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	if (sarea_priv->frames_queued == 0)
+		return 0;
+
+	tail = ring->tail;
+	mach64_ring_tick(dev_priv, ring);
+	head = ring->head;
+
+	start = (MACH64_MAX_QUEUED_FRAMES -
+		 DRM_MIN(MACH64_MAX_QUEUED_FRAMES, sarea_priv->frames_queued));
+
+	if (head == tail) {
+		sarea_priv->frames_queued = 0;
+		for (i = start; i < MACH64_MAX_QUEUED_FRAMES; i++) {
+			dev_priv->frame_ofs[i] = ~0;
+		}
+		return 0;
+	}
+
+	for (i = start; i < MACH64_MAX_QUEUED_FRAMES; i++) {
+		ofs = dev_priv->frame_ofs[i];
+		DRM_DEBUG("frame_ofs[%d] ofs: %d\n", i, ofs);
+		if (ofs == ~0 ||
+		    (head < tail && (ofs < head || ofs >= tail)) ||
+		    (head > tail && (ofs < head && ofs >= tail))) {
+			sarea_priv->frames_queued =
+			    (MACH64_MAX_QUEUED_FRAMES - 1) - i;
+			dev_priv->frame_ofs[i] = ~0;
+		}
+	}
+
+	return sarea_priv->frames_queued;
+}
+
+/* Copy and verify a client submited buffer.
+ * FIXME: Make an assembly optimized version
+ */
+static __inline__ int copy_and_verify_from_user(u32 * to, const u32 * from,
+						unsigned long bytes)
+{
+	unsigned long n = bytes;	/* dwords remaining in buffer */
+
+	if (DRM_VERIFYAREA_READ(from, n)) {
+		DRM_ERROR("%s: verify_area\n", __FUNCTION__);
+		return DRM_ERR(EFAULT);
+	}
+
+	n >>= 2;
+
+	while (n > 1) {
+		u32 data, reg, count;
+
+		if (DRM_GET_USER_UNCHECKED(data, from++)) {
+			DRM_ERROR("%s: get_user\n", __FUNCTION__);
+			return DRM_ERR(EFAULT);
+		}
+
+		n--;
+
+		reg = le32_to_cpu(data);
+		count = (reg >> 16) + 1;
+		if (count <= n) {
+			n -= count;
+			reg &= 0xffff;
+
+			/* This is an exact match of Mach64's Setup Engine registers,
+			 * excluding SETUP_CNTL (1_C1).
+			 */
+			if ((reg >= 0x0190 && reg < 0x01c1) ||
+			    (reg >= 0x01ca && reg <= 0x01cf)) {
+				*to++ = data;
+				if (DRM_COPY_FROM_USER_UNCHECKED
+				    (to, from, count << 2)) {
+					DRM_ERROR("%s: copy_from_user\n",
+						  __FUNCTION__);
+					return DRM_ERR(EFAULT);
+				}
+				to += count;
+			} else {
+				DRM_ERROR("%s: Got bad command: 0x%04x\n",
+					  __FUNCTION__, reg);
+				return DRM_ERR(EACCES);
+			}
+
+			from += count;
+		} else {
+			DRM_ERROR
+			    ("%s: Got bad command count(=%u) dwords remaining=%lu\n",
+			     __FUNCTION__, count, n);
+			return DRM_ERR(EINVAL);
+		}
+	}
+
+	if (n == 0)
+		return 0;
+	else {
+		DRM_ERROR("%s: Bad buf->used(=%lu)\n", __FUNCTION__, bytes);
+		return DRM_ERR(EINVAL);
+	}
+}
+
+static int mach64_dma_dispatch_vertex(DRMFILE filp, drm_device_t * dev,
+				      int prim, void *buf, unsigned long used,
+				      int discard)
+{
+	drm_mach64_private_t *dev_priv = dev->dev_private;
+	drm_mach64_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_buf_t *copy_buf;
+	int done = 0;
+	int verify_ret = 0;
+	DMALOCALS;
+
+	DRM_DEBUG("%s: buf=%p used=%lu nbox=%d\n",
+		  __FUNCTION__, buf, used, sarea_priv->nbox);
+
+	if (used) {
+		int ret = 0;
+		int i = 0;
+
+		copy_buf = mach64_freelist_get(dev_priv);
+		if (copy_buf == NULL) {
+			DRM_ERROR("%s: couldn't get buffer in DMAGETPTR\n",
+				  __FUNCTION__);
+			return DRM_ERR(EAGAIN);
+		}
+
+		if ((verify_ret =
+		     copy_and_verify_from_user(GETBUFPTR(copy_buf), buf,
+					       used)) == 0) {
+
+			copy_buf->used = used;
+
+			DMASETPTR(copy_buf);
+
+			if (sarea_priv->dirty & ~MACH64_UPLOAD_CLIPRECTS) {
+				ret = mach64_emit_state(filp, dev_priv);
+				if (ret < 0)
+					return ret;
+			}
+
+			do {
+				/* Emit the next cliprect */
+				if (i < sarea_priv->nbox) {
+					ret =
+					    mach64_emit_cliprect(filp, dev_priv,
+								 &sarea_priv->
+								 boxes[i]);
+					if (ret < 0) {
+						/* failed to get buffer */
+						return ret;
+					} else if (ret != 0) {
+						/* null intersection with scissor */
+						continue;
+					}
+				}
+				if ((i >= sarea_priv->nbox - 1))
+					done = 1;
+
+				/* Add the buffer to the DMA queue */
+				DMAADVANCE(dev_priv, done);
+
+			} while (++i < sarea_priv->nbox);
+		}
+
+		if (copy_buf->pending && !done) {
+			DMADISCARDBUF();
+		} else if (!done) {
+			/* This buffer wasn't used (no cliprects or verify failed), so place it back
+			 * on the free list
+			 */
+			struct list_head *ptr;
+			drm_mach64_freelist_t *entry;
+#if MACH64_EXTRA_CHECKING
+			list_for_each(ptr, &dev_priv->pending) {
+				entry =
+				    list_entry(ptr, drm_mach64_freelist_t,
+					       list);
+				if (copy_buf == entry->buf) {
+					DRM_ERROR
+					    ("%s: Trying to release a pending buf\n",
+					     __FUNCTION__);
+					return DRM_ERR(EFAULT);
+				}
+			}
+#endif
+			ptr = dev_priv->placeholders.next;
+			entry = list_entry(ptr, drm_mach64_freelist_t, list);
+			copy_buf->pending = 0;
+			copy_buf->used = 0;
+			entry->buf = copy_buf;
+			entry->discard = 1;
+			list_del(ptr);
+			list_add_tail(ptr, &dev_priv->free_list);
+		}
+	}
+
+	sarea_priv->dirty &= ~MACH64_UPLOAD_CLIPRECTS;
+	sarea_priv->nbox = 0;
+
+	return verify_ret;
+}
+
+static int mach64_dma_dispatch_blit(DRMFILE filp, drm_device_t * dev,
+				    drm_mach64_blit_t * blit)
+{
+	drm_mach64_private_t *dev_priv = dev->dev_private;
+	drm_device_dma_t *dma = dev->dma;
+	int dword_shift, dwords;
+	drm_buf_t *buf;
+	DMALOCALS;
+
+	/* The compiler won't optimize away a division by a variable,
+	 * even if the only legal values are powers of two.  Thus, we'll
+	 * use a shift instead.
+	 */
+	switch (blit->format) {
+	case MACH64_DATATYPE_ARGB8888:
+		dword_shift = 0;
+		break;
+	case MACH64_DATATYPE_ARGB1555:
+	case MACH64_DATATYPE_RGB565:
+	case MACH64_DATATYPE_VYUY422:
+	case MACH64_DATATYPE_YVYU422:
+	case MACH64_DATATYPE_ARGB4444:
+		dword_shift = 1;
+		break;
+	case MACH64_DATATYPE_CI8:
+	case MACH64_DATATYPE_RGB8:
+		dword_shift = 2;
+		break;
+	default:
+		DRM_ERROR("invalid blit format %d\n", blit->format);
+		return DRM_ERR(EINVAL);
+	}
+
+	/* Dispatch the blit buffer.
+	 */
+	buf = dma->buflist[blit->idx];
+
+	if (buf->filp != filp) {
+		DRM_ERROR("process %d (filp %p) using buffer with filp %p\n",
+			  DRM_CURRENTPID, filp, buf->filp);
+		return DRM_ERR(EINVAL);
+	}
+
+	if (buf->pending) {
+		DRM_ERROR("sending pending buffer %d\n", blit->idx);
+		return DRM_ERR(EINVAL);
+	}
+
+	/* Set buf->used to the bytes of blit data based on the blit dimensions
+	 * and verify the size.  When the setup is emitted to the buffer with
+	 * the DMA* macros below, buf->used is incremented to include the bytes
+	 * used for setup as well as the blit data.
+	 */
+	dwords = (blit->width * blit->height) >> dword_shift;
+	buf->used = dwords << 2;
+	if (buf->used <= 0 ||
+	    buf->used > MACH64_BUFFER_SIZE - MACH64_HOSTDATA_BLIT_OFFSET) {
+		DRM_ERROR("Invalid blit size: %d bytes\n", buf->used);
+		return DRM_ERR(EINVAL);
+	}
+
+	/* FIXME: Use a last buffer flag and reduce the state emitted for subsequent,
+	 * continuation buffers?
+	 */
+
+	/* Blit via BM_HOSTDATA (gui-master) - like HOST_DATA[0-15], but doesn't require
+	 * a register command every 16 dwords.  State setup is added at the start of the
+	 * buffer -- the client leaves space for this based on MACH64_HOSTDATA_BLIT_OFFSET
+	 */
+	DMASETPTR(buf);
+
+	DMAOUTREG(MACH64_Z_CNTL, 0);
+	DMAOUTREG(MACH64_SCALE_3D_CNTL, 0);
+
+	DMAOUTREG(MACH64_SC_LEFT_RIGHT, 0 | (8191 << 16));	/* no scissor */
+	DMAOUTREG(MACH64_SC_TOP_BOTTOM, 0 | (16383 << 16));
+
+	DMAOUTREG(MACH64_CLR_CMP_CNTL, 0);	/* disable */
+	DMAOUTREG(MACH64_GUI_TRAJ_CNTL,
+		  MACH64_DST_X_LEFT_TO_RIGHT | MACH64_DST_Y_TOP_TO_BOTTOM);
+
+	DMAOUTREG(MACH64_DP_PIX_WIDTH, (blit->format << 0)	/* dst pix width */
+		  |(blit->format << 4)	/* composite pix width */
+		  |(blit->format << 8)	/* src pix width */
+		  |(blit->format << 16)	/* host data pix width */
+		  |(blit->format << 28)	/* scaler/3D pix width */
+	    );
+
+	DMAOUTREG(MACH64_DP_WRITE_MASK, 0xffffffff);	/* enable all planes */
+	DMAOUTREG(MACH64_DP_MIX, MACH64_BKGD_MIX_D | MACH64_FRGD_MIX_S);
+	DMAOUTREG(MACH64_DP_SRC,
+		  MACH64_BKGD_SRC_BKGD_CLR
+		  | MACH64_FRGD_SRC_HOST | MACH64_MONO_SRC_ONE);
+
+	DMAOUTREG(MACH64_DST_OFF_PITCH,
+		  (blit->pitch << 22) | (blit->offset >> 3));
+	DMAOUTREG(MACH64_DST_X_Y, (blit->y << 16) | blit->x);
+	DMAOUTREG(MACH64_DST_WIDTH_HEIGHT, (blit->height << 16) | blit->width);
+
+	DRM_DEBUG("%s: %d bytes\n", __FUNCTION__, buf->used);
+
+	/* Add the buffer to the queue */
+	DMAADVANCEHOSTDATA(dev_priv);
+
+	return 0;
+}
+
+/* ================================================================
+ * IOCTL functions
+ */
+
+int mach64_dma_clear(DRM_IOCTL_ARGS)
+{
+	DRM_DEVICE;
+	drm_mach64_private_t *dev_priv = dev->dev_private;
+	drm_mach64_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_mach64_clear_t clear;
+	int ret;
+
+	DRM_DEBUG("%s: pid=%d\n", __FUNCTION__, DRM_CURRENTPID);
+
+	LOCK_TEST_WITH_RETURN(dev, filp);
+
+	DRM_COPY_FROM_USER_IOCTL(clear, (drm_mach64_clear_t *) data,
+				 sizeof(clear));
+
+	if (sarea_priv->nbox > MACH64_NR_SAREA_CLIPRECTS)
+		sarea_priv->nbox = MACH64_NR_SAREA_CLIPRECTS;
+
+	ret = mach64_dma_dispatch_clear(filp, dev, clear.flags,
+					clear.x, clear.y, clear.w, clear.h,
+					clear.clear_color, clear.clear_depth);
+
+	/* Make sure we restore the 3D state next time.
+	 */
+	sarea_priv->dirty |= (MACH64_UPLOAD_CONTEXT | MACH64_UPLOAD_MISC);
+	return ret;
+}
+
+int mach64_dma_swap(DRM_IOCTL_ARGS)
+{
+	DRM_DEVICE;
+	drm_mach64_private_t *dev_priv = dev->dev_private;
+	drm_mach64_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	int ret;
+
+	DRM_DEBUG("%s: pid=%d\n", __FUNCTION__, DRM_CURRENTPID);
+
+	LOCK_TEST_WITH_RETURN(dev, filp);
+
+	if (sarea_priv->nbox > MACH64_NR_SAREA_CLIPRECTS)
+		sarea_priv->nbox = MACH64_NR_SAREA_CLIPRECTS;
+
+	ret = mach64_dma_dispatch_swap(filp, dev);
+
+	/* Make sure we restore the 3D state next time.
+	 */
+	sarea_priv->dirty |= (MACH64_UPLOAD_CONTEXT | MACH64_UPLOAD_MISC);
+	return ret;
+}
+
+int mach64_dma_vertex(DRM_IOCTL_ARGS)
+{
+	DRM_DEVICE;
+	drm_mach64_private_t *dev_priv = dev->dev_private;
+	drm_mach64_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_mach64_vertex_t vertex;
+
+	LOCK_TEST_WITH_RETURN(dev, filp);
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return DRM_ERR(EINVAL);
+	}
+
+	DRM_COPY_FROM_USER_IOCTL(vertex, (drm_mach64_vertex_t *) data,
+				 sizeof(vertex));
+
+	DRM_DEBUG("%s: pid=%d buf=%p used=%lu discard=%d\n",
+		  __FUNCTION__, DRM_CURRENTPID,
+		  vertex.buf, vertex.used, vertex.discard);
+
+	if (vertex.prim < 0 || vertex.prim > MACH64_PRIM_POLYGON) {
+		DRM_ERROR("buffer prim %d\n", vertex.prim);
+		return DRM_ERR(EINVAL);
+	}
+
+	if (vertex.used > MACH64_BUFFER_SIZE || (vertex.used & 3) != 0) {
+		DRM_ERROR("Invalid vertex buffer size: %lu bytes\n",
+			  vertex.used);
+		return DRM_ERR(EINVAL);
+	}
+
+	if (sarea_priv->nbox > MACH64_NR_SAREA_CLIPRECTS)
+		sarea_priv->nbox = MACH64_NR_SAREA_CLIPRECTS;
+
+	return mach64_dma_dispatch_vertex(filp, dev, vertex.prim, vertex.buf,
+					  vertex.used, vertex.discard);
+}
+
+int mach64_dma_blit(DRM_IOCTL_ARGS)
+{
+	DRM_DEVICE;
+	drm_device_dma_t *dma = dev->dma;
+	drm_mach64_private_t *dev_priv = dev->dev_private;
+	drm_mach64_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_mach64_blit_t blit;
+	int ret;
+
+	LOCK_TEST_WITH_RETURN(dev, filp);
+
+	DRM_COPY_FROM_USER_IOCTL(blit, (drm_mach64_blit_t *) data,
+				 sizeof(blit));
+
+	DRM_DEBUG("%s: pid=%d index=%d\n",
+		  __FUNCTION__, DRM_CURRENTPID, blit.idx);
+
+	if (blit.idx < 0 || blit.idx >= dma->buf_count) {
+		DRM_ERROR("buffer index %d (of %d max)\n",
+			  blit.idx, dma->buf_count - 1);
+		return DRM_ERR(EINVAL);
+	}
+
+	ret = mach64_dma_dispatch_blit(filp, dev, &blit);
+
+	/* Make sure we restore the 3D state next time.
+	 */
+	sarea_priv->dirty |= (MACH64_UPLOAD_CONTEXT |
+			      MACH64_UPLOAD_MISC | MACH64_UPLOAD_CLIPRECTS);
+
+	return ret;
+}
+
+int mach64_get_param(DRM_IOCTL_ARGS)
+{
+	DRM_DEVICE;
+	drm_mach64_private_t *dev_priv = dev->dev_private;
+	drm_mach64_getparam_t param;
+	int value;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return DRM_ERR(EINVAL);
+	}
+
+	DRM_COPY_FROM_USER_IOCTL(param, (drm_mach64_getparam_t *) data,
+				 sizeof(param));
+
+	switch (param.param) {
+	case MACH64_PARAM_FRAMES_QUEUED:
+		/* Needs lock since it calls mach64_ring_tick() */
+		LOCK_TEST_WITH_RETURN(dev, filp);
+		value = mach64_do_get_frames_queued(dev_priv);
+		break;
+	case MACH64_PARAM_IRQ_NR:
+		value = dev->irq;
+		break;
+	default:
+		return DRM_ERR(EINVAL);
+	}
+
+	if (DRM_COPY_TO_USER(param.value, &value, sizeof(int))) {
+		DRM_ERROR("copy_to_user\n");
+		return DRM_ERR(EFAULT);
+	}
+
+	return 0;
+}
diff -purN linux-2.6.12.orig/drivers/char/drm/Makefile linux-2.6.12/drivers/char/drm/Makefile
--- linux-2.6.12.orig/drivers/char/drm/Makefile	2005-07-05 08:36:22.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/Makefile	2005-07-05 08:37:36.000000000 +0200
@@ -1,38 +1,49 @@
 #
 # Makefile for the drm device driver.  This driver provides support for the
 # Direct Rendering Infrastructure (DRI) in XFree86 4.1.0 and higher.
+#
+# Based on David Woodhouse's mtd build.
+#
+# $XFree86: xc/programs/Xserver/hw/xfree86/os-support/linux/drm/kernel/Makefile.kernel,v 1.18 2003/08/16 17:59:17 dawes Exp $
+#
 
-drm-objs    :=	drm_auth.o drm_bufs.o drm_context.o drm_dma.o drm_drawable.o \
-		drm_drv.o drm_fops.o drm_init.o drm_ioctl.o drm_irq.o \
+drm-objs    := drm_auth.o drm_bufs.o drm_context.o drm_dma.o drm_drawable.o \
+		drm_drv.o drm_fops.o drm_ioctl.o drm_irq.o \
 		drm_lock.o drm_memory.o drm_proc.o drm_stub.o drm_vm.o \
-		drm_agpsupport.o drm_scatter.o ati_pcigart.o drm_pci.o \
-		drm_sysfs.o
-
-gamma-objs  := gamma_drv.o gamma_dma.o
+		drm_sysfs.o drm_pci.o drm_agpsupport.o drm_scatter.o \
+		drm_memory_debug.o ati_pcigart.o
 tdfx-objs   := tdfx_drv.o
 r128-objs   := r128_drv.o r128_cce.o r128_state.o r128_irq.o
 mga-objs    := mga_drv.o mga_dma.o mga_state.o mga_warp.o mga_irq.o
 i810-objs   := i810_drv.o i810_dma.o
 i830-objs   := i830_drv.o i830_dma.o i830_irq.o
-i915-objs   := i915_drv.o i915_dma.o i915_irq.o i915_mem.o
+i915-objs   := i915_drv.o i915_dma.o i915_irq.o i915_mem.o i915_pm.o
 radeon-objs := radeon_drv.o radeon_cp.o radeon_state.o radeon_mem.o radeon_irq.o
-ffb-objs    := ffb_drv.o ffb_context.o
 sis-objs    := sis_drv.o sis_ds.o sis_mm.o
+ffb-objs    := ffb_drv.o ffb_context.o
+savage-objs := savage_drv.o savage_bci.o savage_state.o
+via-objs    := via_irq.o via_drv.o via_ds.o via_map.o via_mm.o via_dma.o via_verifier.o \
+		via_video.o
+mach64-objs := mach64_drv.o mach64_dma.o mach64_irq.o mach64_state.o 
 
 ifeq ($(CONFIG_COMPAT),y)
 drm-objs    += drm_ioc32.o
 radeon-objs += radeon_ioc32.o
+mga-objs    += mga_ioc32.o
+r128-objs   += r128_ioc32.o
+i915-objs   += i915_ioc32.o
 endif
 
-obj-$(CONFIG_DRM)	+= drm.o
-obj-$(CONFIG_DRM_GAMMA) += gamma.o
+obj-m			+= drm.o
 obj-$(CONFIG_DRM_TDFX)	+= tdfx.o
 obj-$(CONFIG_DRM_R128)	+= r128.o
 obj-$(CONFIG_DRM_RADEON)+= radeon.o
 obj-$(CONFIG_DRM_MGA)	+= mga.o
 obj-$(CONFIG_DRM_I810)	+= i810.o
 obj-$(CONFIG_DRM_I830)	+= i830.o
-obj-$(CONFIG_DRM_I915)  += i915.o
-obj-$(CONFIG_DRM_FFB)   += ffb.o
+obj-$(CONFIG_DRM_I915)	+= i915.o
 obj-$(CONFIG_DRM_SIS)   += sis.o
-
+obj-$(CONFIG_DRM_FFB)   += ffb.o
+obj-$(CONFIG_DRM_SAVAGE)+= savage.o
+obj-$(CONFIG_DRM_VIA)   += via.o
+obj-$(CONFIG_DRM_MACH64)+= mach64.o
diff -purN linux-2.6.12.orig/drivers/char/drm/mga_dma.c linux-2.6.12/drivers/char/drm/mga_dma.c
--- linux-2.6.12.orig/drivers/char/drm/mga_dma.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/mga_dma.c	2005-07-05 08:37:47.000000000 +0200
@@ -23,58 +23,61 @@
  * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  * DEALINGS IN THE SOFTWARE.
- *
- * Authors:
- *    Rickard E. (Rik) Faith <faith@valinux.com>
- *    Jeff Hartmann <jhartmann@valinux.com>
- *    Keith Whitwell <keith@tungstengraphics.com>
- *
- * Rewritten by:
- *    Gareth Hughes <gareth@valinux.com>
+ */
+
+/**
+ * \file mga_dma.c
+ * DMA support for MGA G200 / G400.
+ * 
+ * \author Rickard E. (Rik) Faith <faith@valinux.com>
+ * \author Jeff Hartmann <jhartmann@valinux.com>
+ * \author Keith Whitwell <keith@tungstengraphics.com>
+ * \author Gareth Hughes <gareth@valinux.com>
  */
 
 #include "drmP.h"
 #include "drm.h"
+#include "drm_sarea.h"
 #include "mga_drm.h"
 #include "mga_drv.h"
 
 #define MGA_DEFAULT_USEC_TIMEOUT	10000
 #define MGA_FREELIST_DEBUG		0
 
-static int mga_do_cleanup_dma( drm_device_t *dev );
+static int mga_do_cleanup_dma(drm_device_t * dev);
 
 /* ================================================================
  * Engine control
  */
 
-int mga_do_wait_for_idle( drm_mga_private_t *dev_priv )
+int mga_do_wait_for_idle(drm_mga_private_t * dev_priv)
 {
 	u32 status = 0;
 	int i;
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
-	for ( i = 0 ; i < dev_priv->usec_timeout ; i++ ) {
-		status = MGA_READ( MGA_STATUS ) & MGA_ENGINE_IDLE_MASK;
-		if ( status == MGA_ENDPRDMASTS ) {
-			MGA_WRITE8( MGA_CRTC_INDEX, 0 );
+	for (i = 0; i < dev_priv->usec_timeout; i++) {
+		status = MGA_READ(MGA_STATUS) & MGA_ENGINE_IDLE_MASK;
+		if (status == MGA_ENDPRDMASTS) {
+			MGA_WRITE8(MGA_CRTC_INDEX, 0);
 			return 0;
 		}
-		DRM_UDELAY( 1 );
+		DRM_UDELAY(1);
 	}
 
 #if MGA_DMA_DEBUG
-	DRM_ERROR( "failed!\n" );
-	DRM_INFO( "   status=0x%08x\n", status );
+	DRM_ERROR("failed!\n");
+	DRM_INFO("   status=0x%08x\n", status);
 #endif
 	return DRM_ERR(EBUSY);
 }
 
-static int mga_do_dma_reset( drm_mga_private_t *dev_priv )
+static int mga_do_dma_reset(drm_mga_private_t * dev_priv)
 {
 	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
 	drm_mga_primary_buffer_t *primary = &dev_priv->prim;
 
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
 	/* The primary DMA stream should look like new right about now.
 	 */
@@ -97,24 +100,25 @@ static int mga_do_dma_reset( drm_mga_pri
  * Primary DMA stream
  */
 
-void mga_do_dma_flush( drm_mga_private_t *dev_priv )
+void mga_do_dma_flush(drm_mga_private_t * dev_priv)
 {
 	drm_mga_primary_buffer_t *primary = &dev_priv->prim;
 	u32 head, tail;
 	u32 status = 0;
 	int i;
- 	DMA_LOCALS;
-	DRM_DEBUG( "\n" );
+	DMA_LOCALS;
+	DRM_DEBUG("\n");
 
-        /* We need to wait so that we can do an safe flush */
-	for ( i = 0 ; i < dev_priv->usec_timeout ; i++ ) {
-		status = MGA_READ( MGA_STATUS ) & MGA_ENGINE_IDLE_MASK;
-		if ( status == MGA_ENDPRDMASTS ) break;
-		DRM_UDELAY( 1 );
+	/* We need to wait so that we can do an safe flush */
+	for (i = 0; i < dev_priv->usec_timeout; i++) {
+		status = MGA_READ(MGA_STATUS) & MGA_ENGINE_IDLE_MASK;
+		if (status == MGA_ENDPRDMASTS)
+			break;
+		DRM_UDELAY(1);
 	}
 
-	if ( primary->tail == primary->last_flush ) {
-		DRM_DEBUG( "   bailing out...\n" );
+	if (primary->tail == primary->last_flush) {
+		DRM_DEBUG("   bailing out...\n");
 		return;
 	}
 
@@ -124,48 +128,46 @@ void mga_do_dma_flush( drm_mga_private_t
 	 * actually (partially?) reads the first of these commands.
 	 * See page 4-16 in the G400 manual, middle of the page or so.
 	 */
-	BEGIN_DMA( 1 );
+	BEGIN_DMA(1);
 
-	DMA_BLOCK( MGA_DMAPAD,  0x00000000,
-		   MGA_DMAPAD,  0x00000000,
-		   MGA_DMAPAD,  0x00000000,
-		   MGA_DMAPAD,	0x00000000 );
+	DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+		  MGA_DMAPAD, 0x00000000,
+		  MGA_DMAPAD, 0x00000000, MGA_DMAPAD, 0x00000000);
 
 	ADVANCE_DMA();
 
 	primary->last_flush = primary->tail;
 
-	head = MGA_READ( MGA_PRIMADDRESS );
+	head = MGA_READ(MGA_PRIMADDRESS);
 
-	if ( head <= tail ) {
+	if (head <= tail) {
 		primary->space = primary->size - primary->tail;
 	} else {
 		primary->space = head - tail;
 	}
 
-	DRM_DEBUG( "   head = 0x%06lx\n", head - dev_priv->primary->offset );
-	DRM_DEBUG( "   tail = 0x%06lx\n", tail - dev_priv->primary->offset );
-	DRM_DEBUG( "  space = 0x%06x\n", primary->space );
+	DRM_DEBUG("   head = 0x%06lx\n", head - dev_priv->primary->offset);
+	DRM_DEBUG("   tail = 0x%06lx\n", tail - dev_priv->primary->offset);
+	DRM_DEBUG("  space = 0x%06x\n", primary->space);
 
 	mga_flush_write_combine();
-	MGA_WRITE( MGA_PRIMEND, tail | MGA_PAGPXFER );
+	MGA_WRITE(MGA_PRIMEND, tail | dev_priv->dma_access);
 
-	DRM_DEBUG( "done.\n" );
+	DRM_DEBUG("done.\n");
 }
 
-void mga_do_dma_wrap_start( drm_mga_private_t *dev_priv )
+void mga_do_dma_wrap_start(drm_mga_private_t * dev_priv)
 {
 	drm_mga_primary_buffer_t *primary = &dev_priv->prim;
 	u32 head, tail;
 	DMA_LOCALS;
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
 	BEGIN_DMA_WRAP();
 
-	DMA_BLOCK( MGA_DMAPAD,	0x00000000,
-		   MGA_DMAPAD,	0x00000000,
-		   MGA_DMAPAD,	0x00000000,
-		   MGA_DMAPAD,	0x00000000 );
+	DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+		  MGA_DMAPAD, 0x00000000,
+		  MGA_DMAPAD, 0x00000000, MGA_DMAPAD, 0x00000000);
 
 	ADVANCE_DMA();
 
@@ -175,45 +177,43 @@ void mga_do_dma_wrap_start( drm_mga_priv
 	primary->last_flush = 0;
 	primary->last_wrap++;
 
-	head = MGA_READ( MGA_PRIMADDRESS );
+	head = MGA_READ(MGA_PRIMADDRESS);
 
-	if ( head == dev_priv->primary->offset ) {
+	if (head == dev_priv->primary->offset) {
 		primary->space = primary->size;
 	} else {
 		primary->space = head - dev_priv->primary->offset;
 	}
 
-	DRM_DEBUG( "   head = 0x%06lx\n",
-		  head - dev_priv->primary->offset );
-	DRM_DEBUG( "   tail = 0x%06x\n", primary->tail );
-	DRM_DEBUG( "   wrap = %d\n", primary->last_wrap );
-	DRM_DEBUG( "  space = 0x%06x\n", primary->space );
+	DRM_DEBUG("   head = 0x%06lx\n", head - dev_priv->primary->offset);
+	DRM_DEBUG("   tail = 0x%06x\n", primary->tail);
+	DRM_DEBUG("   wrap = %d\n", primary->last_wrap);
+	DRM_DEBUG("  space = 0x%06x\n", primary->space);
 
 	mga_flush_write_combine();
-	MGA_WRITE( MGA_PRIMEND, tail | MGA_PAGPXFER );
+	MGA_WRITE(MGA_PRIMEND, tail | dev_priv->dma_access);
 
-	set_bit( 0, &primary->wrapped );
-	DRM_DEBUG( "done.\n" );
+	set_bit(0, &primary->wrapped);
+	DRM_DEBUG("done.\n");
 }
 
-void mga_do_dma_wrap_end( drm_mga_private_t *dev_priv )
+void mga_do_dma_wrap_end(drm_mga_private_t * dev_priv)
 {
 	drm_mga_primary_buffer_t *primary = &dev_priv->prim;
 	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
 	u32 head = dev_priv->primary->offset;
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
 	sarea_priv->last_wrap++;
-	DRM_DEBUG( "   wrap = %d\n", sarea_priv->last_wrap );
+	DRM_DEBUG("   wrap = %d\n", sarea_priv->last_wrap);
 
 	mga_flush_write_combine();
-	MGA_WRITE( MGA_PRIMADDRESS, head | MGA_DMA_GENERAL );
+	MGA_WRITE(MGA_PRIMADDRESS, head | MGA_DMA_GENERAL);
 
-	clear_bit( 0, &primary->wrapped );
-	DRM_DEBUG( "done.\n" );
+	clear_bit(0, &primary->wrapped);
+	DRM_DEBUG("done.\n");
 }
 
-
 /* ================================================================
  * Freelist management
  */
@@ -222,63 +222,61 @@ void mga_do_dma_wrap_end( drm_mga_privat
 #define MGA_BUFFER_FREE		0
 
 #if MGA_FREELIST_DEBUG
-static void mga_freelist_print( drm_device_t *dev )
+static void mga_freelist_print(drm_device_t * dev)
 {
 	drm_mga_private_t *dev_priv = dev->dev_private;
 	drm_mga_freelist_t *entry;
 
-	DRM_INFO( "\n" );
-	DRM_INFO( "current dispatch: last=0x%x done=0x%x\n",
-		  dev_priv->sarea_priv->last_dispatch,
-		  (unsigned int)(MGA_READ( MGA_PRIMADDRESS ) -
-				 dev_priv->primary->offset) );
-	DRM_INFO( "current freelist:\n" );
-
-	for ( entry = dev_priv->head->next ; entry ; entry = entry->next ) {
-		DRM_INFO( "   %p   idx=%2d  age=0x%x 0x%06lx\n",
-			  entry, entry->buf->idx, entry->age.head,
-			  entry->age.head - dev_priv->primary->offset );
+	DRM_INFO("\n");
+	DRM_INFO("current dispatch: last=0x%x done=0x%x\n",
+		 dev_priv->sarea_priv->last_dispatch,
+		 (unsigned int)(MGA_READ(MGA_PRIMADDRESS) -
+				dev_priv->primary->offset));
+	DRM_INFO("current freelist:\n");
+
+	for (entry = dev_priv->head->next; entry; entry = entry->next) {
+		DRM_INFO("   %p   idx=%2d  age=0x%x 0x%06lx\n",
+			 entry, entry->buf->idx, entry->age.head,
+			 entry->age.head - dev_priv->primary->offset);
 	}
-	DRM_INFO( "\n" );
+	DRM_INFO("\n");
 }
 #endif
 
-static int mga_freelist_init( drm_device_t *dev, drm_mga_private_t *dev_priv )
+static int mga_freelist_init(drm_device_t * dev, drm_mga_private_t * dev_priv)
 {
 	drm_device_dma_t *dma = dev->dma;
 	drm_buf_t *buf;
 	drm_mga_buf_priv_t *buf_priv;
 	drm_mga_freelist_t *entry;
 	int i;
-	DRM_DEBUG( "count=%d\n", dma->buf_count );
+	DRM_DEBUG("count=%d\n", dma->buf_count);
 
-	dev_priv->head = drm_alloc( sizeof(drm_mga_freelist_t),
-				     DRM_MEM_DRIVER );
-	if ( dev_priv->head == NULL )
+	dev_priv->head = drm_alloc(sizeof(drm_mga_freelist_t), DRM_MEM_DRIVER);
+	if (dev_priv->head == NULL)
 		return DRM_ERR(ENOMEM);
 
-	memset( dev_priv->head, 0, sizeof(drm_mga_freelist_t) );
-	SET_AGE( &dev_priv->head->age, MGA_BUFFER_USED, 0 );
+	memset(dev_priv->head, 0, sizeof(drm_mga_freelist_t));
+	SET_AGE(&dev_priv->head->age, MGA_BUFFER_USED, 0);
 
-	for ( i = 0 ; i < dma->buf_count ; i++ ) {
+	for (i = 0; i < dma->buf_count; i++) {
 		buf = dma->buflist[i];
-	        buf_priv = buf->dev_private;
+		buf_priv = buf->dev_private;
 
-		entry = drm_alloc( sizeof(drm_mga_freelist_t),
-				    DRM_MEM_DRIVER );
-		if ( entry == NULL )
+		entry = drm_alloc(sizeof(drm_mga_freelist_t), DRM_MEM_DRIVER);
+		if (entry == NULL)
 			return DRM_ERR(ENOMEM);
 
-		memset( entry, 0, sizeof(drm_mga_freelist_t) );
+		memset(entry, 0, sizeof(drm_mga_freelist_t));
 
 		entry->next = dev_priv->head->next;
 		entry->prev = dev_priv->head;
-		SET_AGE( &entry->age, MGA_BUFFER_FREE, 0 );
+		SET_AGE(&entry->age, MGA_BUFFER_FREE, 0);
 		entry->buf = buf;
 
-		if ( dev_priv->head->next != NULL )
+		if (dev_priv->head->next != NULL)
 			dev_priv->head->next->prev = entry;
-		if ( entry->next == NULL )
+		if (entry->next == NULL)
 			dev_priv->tail = entry;
 
 		buf_priv->list_entry = entry;
@@ -291,17 +289,17 @@ static int mga_freelist_init( drm_device
 	return 0;
 }
 
-static void mga_freelist_cleanup( drm_device_t *dev )
+static void mga_freelist_cleanup(drm_device_t * dev)
 {
 	drm_mga_private_t *dev_priv = dev->dev_private;
 	drm_mga_freelist_t *entry;
 	drm_mga_freelist_t *next;
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
 	entry = dev_priv->head;
-	while ( entry ) {
+	while (entry) {
 		next = entry->next;
-		drm_free( entry, sizeof(drm_mga_freelist_t), DRM_MEM_DRIVER );
+		drm_free(entry, sizeof(drm_mga_freelist_t), DRM_MEM_DRIVER);
 		entry = next;
 	}
 
@@ -311,71 +309,69 @@ static void mga_freelist_cleanup( drm_de
 #if 0
 /* FIXME: Still needed?
  */
-static void mga_freelist_reset( drm_device_t *dev )
+static void mga_freelist_reset(drm_device_t * dev)
 {
 	drm_device_dma_t *dma = dev->dma;
 	drm_buf_t *buf;
 	drm_mga_buf_priv_t *buf_priv;
 	int i;
 
-	for ( i = 0 ; i < dma->buf_count ; i++ ) {
+	for (i = 0; i < dma->buf_count; i++) {
 		buf = dma->buflist[i];
-	        buf_priv = buf->dev_private;
-		SET_AGE( &buf_priv->list_entry->age,
-			 MGA_BUFFER_FREE, 0 );
+		buf_priv = buf->dev_private;
+		SET_AGE(&buf_priv->list_entry->age, MGA_BUFFER_FREE, 0);
 	}
 }
 #endif
 
-static drm_buf_t *mga_freelist_get( drm_device_t *dev )
+static drm_buf_t *mga_freelist_get(drm_device_t * dev)
 {
 	drm_mga_private_t *dev_priv = dev->dev_private;
 	drm_mga_freelist_t *next;
 	drm_mga_freelist_t *prev;
 	drm_mga_freelist_t *tail = dev_priv->tail;
 	u32 head, wrap;
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
-	head = MGA_READ( MGA_PRIMADDRESS );
+	head = MGA_READ(MGA_PRIMADDRESS);
 	wrap = dev_priv->sarea_priv->last_wrap;
 
-	DRM_DEBUG( "   tail=0x%06lx %d\n",
-		   tail->age.head ?
-		   tail->age.head - dev_priv->primary->offset : 0,
-		   tail->age.wrap );
-	DRM_DEBUG( "   head=0x%06lx %d\n",
-		   head - dev_priv->primary->offset, wrap );
+	DRM_DEBUG("   tail=0x%06lx %d\n",
+		  tail->age.head ?
+		  tail->age.head - dev_priv->primary->offset : 0,
+		  tail->age.wrap);
+	DRM_DEBUG("   head=0x%06lx %d\n",
+		  head - dev_priv->primary->offset, wrap);
 
-	if ( TEST_AGE( &tail->age, head, wrap ) ) {
+	if (TEST_AGE(&tail->age, head, wrap)) {
 		prev = dev_priv->tail->prev;
 		next = dev_priv->tail;
 		prev->next = NULL;
 		next->prev = next->next = NULL;
 		dev_priv->tail = prev;
-		SET_AGE( &next->age, MGA_BUFFER_USED, 0 );
+		SET_AGE(&next->age, MGA_BUFFER_USED, 0);
 		return next->buf;
 	}
 
-	DRM_DEBUG( "returning NULL!\n" );
+	DRM_DEBUG("returning NULL!\n");
 	return NULL;
 }
 
-int mga_freelist_put( drm_device_t *dev, drm_buf_t *buf )
+int mga_freelist_put(drm_device_t * dev, drm_buf_t * buf)
 {
 	drm_mga_private_t *dev_priv = dev->dev_private;
 	drm_mga_buf_priv_t *buf_priv = buf->dev_private;
 	drm_mga_freelist_t *head, *entry, *prev;
 
-	DRM_DEBUG( "age=0x%06lx wrap=%d\n",
-		   buf_priv->list_entry->age.head -
-		   dev_priv->primary->offset,
-		   buf_priv->list_entry->age.wrap );
+	DRM_DEBUG("age=0x%06lx wrap=%d\n",
+		  buf_priv->list_entry->age.head -
+		  dev_priv->primary->offset, buf_priv->list_entry->age.wrap);
 
 	entry = buf_priv->list_entry;
 	head = dev_priv->head;
 
-	if ( buf_priv->list_entry->age.head == MGA_BUFFER_USED ) {
-		SET_AGE( &entry->age, MGA_BUFFER_FREE, 0 );
+	if (buf_priv->list_entry->age.head == MGA_BUFFER_USED) {
+		SET_AGE(&entry->age, MGA_BUFFER_FREE, 0);
 		prev = dev_priv->tail;
 		prev->next = entry;
 		entry->prev = prev;
@@ -391,43 +387,402 @@ int mga_freelist_put( drm_device_t *dev,
 	return 0;
 }
 
-
 /* ================================================================
  * DMA initialization, cleanup
  */
 
-static int mga_do_init_dma( drm_device_t *dev, drm_mga_init_t *init )
+int mga_driver_preinit(drm_device_t *dev, unsigned long flags)
 {
-	drm_mga_private_t *dev_priv;
-	int ret;
-	DRM_DEBUG( "\n" );
+	drm_mga_private_t * dev_priv;
 
-	dev_priv = drm_alloc( sizeof(drm_mga_private_t), DRM_MEM_DRIVER );
-	if ( !dev_priv )
+	dev_priv = drm_alloc(sizeof(drm_mga_private_t), DRM_MEM_DRIVER);
+	if (!dev_priv)
 		return DRM_ERR(ENOMEM);
 
-	memset( dev_priv, 0, sizeof(drm_mga_private_t) );
-
-	dev_priv->chipset = init->chipset;
+	dev->dev_private = (void *)dev_priv;
+	memset(dev_priv, 0, sizeof(drm_mga_private_t));
 
 	dev_priv->usec_timeout = MGA_DEFAULT_USEC_TIMEOUT;
+	dev_priv->chipset = flags;
+
+	return 0;
+}
+
+/**
+ * Bootstrap the driver for AGP DMA.
+ * 
+ * \todo
+ * Investigate whether there is any benifit to storing the WARP microcode in
+ * AGP memory.  If not, the microcode may as well always be put in PCI
+ * memory.
+ *
+ * \todo
+ * This routine needs to set dma_bs->agp_mode to the mode actually configured
+ * in the hardware.  Looking just at the Linux AGP driver code, I don't see
+ * an easy way to determine this.
+ *
+ * \sa mga_do_dma_bootstrap, mga_do_pci_dma_bootstrap
+ */
+static int mga_do_agp_dma_bootstrap(drm_device_t * dev,
+				    drm_mga_dma_bootstrap_t * dma_bs)
+{
+	drm_mga_private_t * const dev_priv = (drm_mga_private_t *) dev->dev_private;
+	const unsigned int warp_size = mga_warp_microcode_size(dev_priv);
+	int err;
+	unsigned  offset;
+	const unsigned secondary_size = dma_bs->secondary_bin_count
+		* dma_bs->secondary_bin_size;
+	const unsigned agp_size = (dma_bs->agp_size << 20);
+	drm_buf_desc_t req;
+	drm_agp_mode_t mode;
+	drm_agp_info_t info;
+
+	
+	/* Acquire AGP. */
+	err = drm_agp_acquire(dev);
+	if (err) {
+		DRM_ERROR("Unable to acquire AGP\n");
+		return err;
+	}
+
+	err = drm_agp_info(dev, &info);
+	if (err) {
+		DRM_ERROR("Unable to get AGP info\n");
+		return err;
+	}
+
+	mode.mode = (info.mode & ~0x07) | dma_bs->agp_mode;
+	err = drm_agp_enable(dev, mode);
+	if (err) {
+		DRM_ERROR("Unable to enable AGP (mode = 0x%lx)\n", mode.mode);
+		return err;
+	}
+
+
+	/* In addition to the usual AGP mode configuration, the G200 AGP cards
+	 * need to have the AGP mode "manually" set.
+	 */
+
+	if (dev_priv->chipset == MGA_CARD_TYPE_G200) {
+		if (mode.mode & 0x02) {
+			MGA_WRITE(MGA_AGP_PLL, MGA_AGP2XPLL_ENABLE);
+		}
+		else {
+			MGA_WRITE(MGA_AGP_PLL, MGA_AGP2XPLL_DISABLE);
+		}
+	}
+
+
+	/* Allocate and bind AGP memory. */
+	dev_priv->agp_pages = agp_size / PAGE_SIZE;
+	dev_priv->agp_mem = drm_alloc_agp( dev, dev_priv->agp_pages, 0 );
+	if (dev_priv->agp_mem == NULL) {
+		dev_priv->agp_pages = 0;
+		DRM_ERROR("Unable to allocate %uMB AGP memory\n",
+			  dma_bs->agp_size);
+		return DRM_ERR(ENOMEM);
+	}
+		
+	err = drm_bind_agp( dev_priv->agp_mem, 0 );
+	if (err) {
+		DRM_ERROR("Unable to bind AGP memory\n");
+		return err;
+	}
+
+	offset = 0;
+	err = drm_addmap( dev, offset, warp_size,
+			  _DRM_AGP, _DRM_READ_ONLY, & dev_priv->warp );
+	if (err) {
+		DRM_ERROR("Unable to map WARP microcode\n");
+		return err;
+	}
+
+	offset += warp_size;
+	err = drm_addmap( dev, offset, dma_bs->primary_size,
+			  _DRM_AGP, _DRM_READ_ONLY, & dev_priv->primary );
+	if (err) {
+		DRM_ERROR("Unable to map primary DMA region\n");
+		return err;
+	}
+
+	offset += dma_bs->primary_size;
+	err = drm_addmap( dev, offset, secondary_size,
+			  _DRM_AGP, 0, & dev->agp_buffer_map );
+	if (err) {
+		DRM_ERROR("Unable to map secondary DMA region\n");
+		return err;
+	}
+
+	(void) memset( &req, 0, sizeof(req) );
+	req.count = dma_bs->secondary_bin_count;
+	req.size = dma_bs->secondary_bin_size;
+	req.flags = _DRM_AGP_BUFFER;
+	req.agp_start = offset;
+
+	err = drm_addbufs_agp( dev, & req );
+	if (err) {
+		DRM_ERROR("Unable to add secondary DMA buffers\n");
+		return err;
+	}
+
+	offset += secondary_size;
+	err = drm_addmap( dev, offset, agp_size - offset,
+			  _DRM_AGP, 0, & dev_priv->agp_textures );
+	if (err) {
+		DRM_ERROR("Unable to map AGP texture region\n");
+		return err;
+	}
+
+	drm_core_ioremap(dev_priv->warp, dev);
+	drm_core_ioremap(dev_priv->primary, dev);
+	drm_core_ioremap(dev->agp_buffer_map, dev);
+
+	if (!dev_priv->warp->handle ||
+	    !dev_priv->primary->handle || !dev->agp_buffer_map->handle) {
+		DRM_ERROR("failed to ioremap agp regions! (%p, %p, %p)\n",
+			  dev_priv->warp->handle, dev_priv->primary->handle,
+			  dev->agp_buffer_map->handle);
+		return DRM_ERR(ENOMEM);
+	}
+
+	dev_priv->dma_access = MGA_PAGPXFER;
+	dev_priv->wagp_enable = MGA_WAGP_ENABLE;
+
+	DRM_INFO("Initialized card for AGP DMA.\n");
+	return 0;
+}
+
+/**
+ * Bootstrap the driver for PCI DMA.
+ * 
+ * \todo
+ * The algorithm for decreasing the size of the primary DMA buffer could be
+ * better.  The size should be rounded up to the nearest page size, then
+ * decrease the request size by a single page each pass through the loop.
+ *
+ * \todo
+ * Determine whether the maximum address passed to drm_pci_alloc is correct.
+ * The same goes for drm_addbufs_pci.
+ * 
+ * \sa mga_do_dma_bootstrap, mga_do_agp_dma_bootstrap
+ */
+static int mga_do_pci_dma_bootstrap(drm_device_t * dev,
+				    drm_mga_dma_bootstrap_t * dma_bs)
+{
+	drm_mga_private_t * const dev_priv = (drm_mga_private_t *) dev->dev_private;
+	const unsigned int warp_size = mga_warp_microcode_size(dev_priv);
+	unsigned int primary_size;
+	unsigned int bin_count;
+	int err;
+	drm_buf_desc_t req;
+
+	
+	if (dev->dma == NULL) {
+		DRM_ERROR("dev->dma is NULL\n");
+		return DRM_ERR(EFAULT);
+	}
+
+	/* The proper alignment is 0x100 for this mapping */
+	err = drm_addmap(dev, 0, warp_size, _DRM_CONSISTENT,
+			 _DRM_READ_ONLY, &dev_priv->warp);
+	if (err != 0) {
+		DRM_ERROR("Unable to create mapping for WARP microcode\n");
+		return err;
+	}
+
+	/* Other than the bottom two bits being used to encode other
+	 * information, there don't appear to be any restrictions on the
+	 * alignment of the primary or secondary DMA buffers.
+	 */
+
+	for ( primary_size = dma_bs->primary_size
+	      ; primary_size != 0
+	      ; primary_size >>= 1 ) {
+		/* The proper alignment for this mapping is 0x04 */
+		err = drm_addmap(dev, 0, primary_size, _DRM_CONSISTENT,
+				 _DRM_READ_ONLY, &dev_priv->primary);
+		if (!err)
+			break;
+	}
+
+	if (err != 0) {
+		DRM_ERROR("Unable to allocate primary DMA region\n");
+		return DRM_ERR(ENOMEM);
+	}
+
+	if (dev_priv->primary->size != dma_bs->primary_size) {
+		DRM_INFO("Primary DMA buffer size reduced from %u to %u.\n",
+			 dma_bs->primary_size, 
+			 (unsigned) dev_priv->primary->size);
+		dma_bs->primary_size = dev_priv->primary->size;
+	}
+
+	for ( bin_count = dma_bs->secondary_bin_count
+	      ; bin_count > 0 
+	      ; bin_count-- ) {
+		(void) memset( &req, 0, sizeof(req) );
+		req.count = bin_count;
+		req.size = dma_bs->secondary_bin_size;
+
+		err = drm_addbufs_pci( dev, & req );
+		if (!err) {
+			break;
+		}
+	}
+	
+	if (bin_count == 0) {
+		DRM_ERROR("Unable to add secondary DMA buffers\n");
+		return err;
+	}
+
+	if (bin_count != dma_bs->secondary_bin_count) {
+		DRM_INFO("Secondary PCI DMA buffer bin count reduced from %u "
+			 "to %u.\n", dma_bs->secondary_bin_count, bin_count);
+
+		dma_bs->secondary_bin_count = bin_count;
+	}
+
+	dev_priv->dma_access = 0;
+	dev_priv->wagp_enable = 0;
+
+	dma_bs->agp_mode = 0;
+
+	DRM_INFO("Initialized card for PCI DMA.\n");
+	return 0;
+}
+
+
+static int mga_do_dma_bootstrap(drm_device_t * dev,
+				drm_mga_dma_bootstrap_t * dma_bs)
+{
+	const int is_agp = (dma_bs->agp_mode != 0) && drm_device_is_agp(dev);
+	int err;
+	drm_mga_private_t * const dev_priv =
+		(drm_mga_private_t *) dev->dev_private;
+
+
+	dev_priv->used_new_dma_init = 1;
+
+	/* The first steps are the same for both PCI and AGP based DMA.  Map
+	 * the cards MMIO registers and map a status page.
+	 */
+	err = drm_addmap( dev, dev_priv->mmio_base, dev_priv->mmio_size,
+			  _DRM_REGISTERS, _DRM_READ_ONLY, & dev_priv->mmio );
+	if (err) {
+		DRM_ERROR("Unable to map MMIO region\n");
+		return err;
+	}
+
 
-	if ( init->sgram ) {
+	err = drm_addmap( dev, 0, SAREA_MAX, _DRM_SHM,
+			  _DRM_READ_ONLY | _DRM_LOCKED | _DRM_KERNEL,
+			  & dev_priv->status );
+	if (err) {
+		DRM_ERROR("Unable to map status region\n");
+		return err;
+	}
+
+
+	/* The DMA initialization procedure is slightly different for PCI and
+	 * AGP cards.  AGP cards just allocate a large block of AGP memory and
+	 * carve off portions of it for internal uses.  The remaining memory
+	 * is returned to user-mode to be used for AGP textures.
+	 */
+
+	if (is_agp) {
+		err = mga_do_agp_dma_bootstrap(dev, dma_bs);
+	}
+	
+	/* If we attempted to initialize the card for AGP DMA but failed,
+	 * clean-up any mess that may have been created.
+	 */
+
+	if (err) {
+		mga_do_cleanup_dma(dev);
+	}
+
+
+	/* Not only do we want to try and initialized PCI cards for PCI DMA,
+	 * but we also try to initialized AGP cards that could not be
+	 * initialized for AGP DMA.  This covers the case where we have an AGP
+	 * card in a system with an unsupported AGP chipset.  In that case the
+	 * card will be detected as AGP, but we won't be able to allocate any
+	 * AGP memory, etc.
+	 */
+
+	if (!is_agp || err) {
+		err = mga_do_pci_dma_bootstrap(dev, dma_bs);
+	}
+
+
+	return err;
+}
+
+int mga_dma_bootstrap(DRM_IOCTL_ARGS)
+{
+	DRM_DEVICE;
+	drm_mga_dma_bootstrap_t bootstrap;
+	int err;
+
+
+	DRM_COPY_FROM_USER_IOCTL(bootstrap,
+				 (drm_mga_dma_bootstrap_t __user *) data,
+				 sizeof(bootstrap));
+
+	err = mga_do_dma_bootstrap(dev, & bootstrap);
+	if (! err) {
+		static const int modes[] = { 0, 1, 2, 2, 4, 4, 4, 4 };
+		const drm_mga_private_t * const dev_priv = 
+			(drm_mga_private_t *) dev->dev_private;
+
+		if (dev_priv->agp_textures != NULL) {
+			bootstrap.texture_handle = dev_priv->agp_textures->offset;
+			bootstrap.texture_size = dev_priv->agp_textures->size;
+		}
+		else {
+			bootstrap.texture_handle = 0;
+			bootstrap.texture_size = 0;
+		}
+
+		bootstrap.agp_mode = modes[ bootstrap.agp_mode & 0x07 ];
+		if (DRM_COPY_TO_USER( (void __user *) data, & bootstrap,
+				     sizeof(bootstrap))) {
+			err = DRM_ERR(EFAULT);
+		}
+	}
+	else {
+		mga_do_cleanup_dma(dev);
+	}
+
+	return err;
+}
+
+
+static int mga_do_init_dma(drm_device_t * dev, drm_mga_init_t * init)
+{
+	drm_mga_private_t *dev_priv;
+	int ret;
+	DRM_DEBUG("\n");
+
+
+	dev_priv = dev->dev_private;
+
+	if (init->sgram) {
 		dev_priv->clear_cmd = MGA_DWGCTL_CLEAR | MGA_ATYPE_BLK;
 	} else {
 		dev_priv->clear_cmd = MGA_DWGCTL_CLEAR | MGA_ATYPE_RSTR;
 	}
-	dev_priv->maccess	= init->maccess;
+	dev_priv->maccess = init->maccess;
 
-	dev_priv->fb_cpp	= init->fb_cpp;
-	dev_priv->front_offset	= init->front_offset;
-	dev_priv->front_pitch	= init->front_pitch;
-	dev_priv->back_offset	= init->back_offset;
-	dev_priv->back_pitch	= init->back_pitch;
-
-	dev_priv->depth_cpp	= init->depth_cpp;
-	dev_priv->depth_offset	= init->depth_offset;
-	dev_priv->depth_pitch	= init->depth_pitch;
+	dev_priv->fb_cpp = init->fb_cpp;
+	dev_priv->front_offset = init->front_offset;
+	dev_priv->front_pitch = init->front_pitch;
+	dev_priv->back_offset = init->back_offset;
+	dev_priv->back_pitch = init->back_pitch;
+
+	dev_priv->depth_cpp = init->depth_cpp;
+	dev_priv->depth_offset = init->depth_offset;
+	dev_priv->depth_pitch = init->depth_pitch;
 
 	/* FIXME: Need to support AGP textures...
 	 */
@@ -436,108 +791,82 @@ static int mga_do_init_dma( drm_device_t
 
 	DRM_GETSAREA();
 
-	if(!dev_priv->sarea) {
-		DRM_ERROR( "failed to find sarea!\n" );
-		/* Assign dev_private so we can do cleanup. */
-		dev->dev_private = (void *)dev_priv;
-		mga_do_cleanup_dma( dev );
+	if (!dev_priv->sarea) {
+		DRM_ERROR("failed to find sarea!\n");
 		return DRM_ERR(EINVAL);
 	}
 
-	dev_priv->mmio = drm_core_findmap(dev, init->mmio_offset);
-	if(!dev_priv->mmio) {
-		DRM_ERROR( "failed to find mmio region!\n" );
-		/* Assign dev_private so we can do cleanup. */
-		dev->dev_private = (void *)dev_priv;
-		mga_do_cleanup_dma( dev );
-		return DRM_ERR(EINVAL);
-	}
-	dev_priv->status = drm_core_findmap(dev, init->status_offset);
-	if(!dev_priv->status) {
-		DRM_ERROR( "failed to find status page!\n" );
-		/* Assign dev_private so we can do cleanup. */
-		dev->dev_private = (void *)dev_priv;
-		mga_do_cleanup_dma( dev );
-		return DRM_ERR(EINVAL);
-	}
-	dev_priv->warp = drm_core_findmap(dev, init->warp_offset);
-	if(!dev_priv->warp) {
-		DRM_ERROR( "failed to find warp microcode region!\n" );
-		/* Assign dev_private so we can do cleanup. */
-		dev->dev_private = (void *)dev_priv;
-		mga_do_cleanup_dma( dev );
-		return DRM_ERR(EINVAL);
-	}
-	dev_priv->primary = drm_core_findmap(dev, init->primary_offset);
-	if(!dev_priv->primary) {
-		DRM_ERROR( "failed to find primary dma region!\n" );
-		/* Assign dev_private so we can do cleanup. */
-		dev->dev_private = (void *)dev_priv;
-		mga_do_cleanup_dma( dev );
-		return DRM_ERR(EINVAL);
-	}
-	dev->agp_buffer_map = drm_core_findmap(dev, init->buffers_offset);
-	if(!dev->agp_buffer_map) {
-		DRM_ERROR( "failed to find dma buffer region!\n" );
-		/* Assign dev_private so we can do cleanup. */
-		dev->dev_private = (void *)dev_priv;
-		mga_do_cleanup_dma( dev );
-		return DRM_ERR(EINVAL);
+	if (! dev_priv->used_new_dma_init) {
+		dev_priv->status = drm_core_findmap(dev, init->status_offset);
+		if (!dev_priv->status) {
+			DRM_ERROR("failed to find status page!\n");
+			return DRM_ERR(EINVAL);
+		}
+		dev_priv->mmio = drm_core_findmap(dev, init->mmio_offset);
+		if (!dev_priv->mmio) {
+			DRM_ERROR("failed to find mmio region!\n");
+			return DRM_ERR(EINVAL);
+		}
+		dev_priv->warp = drm_core_findmap(dev, init->warp_offset);
+		if (!dev_priv->warp) {
+			DRM_ERROR("failed to find warp microcode region!\n");
+			return DRM_ERR(EINVAL);
+		}
+		dev_priv->primary = drm_core_findmap(dev, init->primary_offset);
+		if (!dev_priv->primary) {
+			DRM_ERROR("failed to find primary dma region!\n");
+			return DRM_ERR(EINVAL);
+		}
+		dev->agp_buffer_map = drm_core_findmap(dev, init->buffers_offset);
+		if (!dev->agp_buffer_map) {
+			DRM_ERROR("failed to find dma buffer region!\n");
+			return DRM_ERR(EINVAL);
+		}
+
+		drm_core_ioremap(dev_priv->warp, dev);
+		drm_core_ioremap(dev_priv->primary, dev);
+		drm_core_ioremap(dev->agp_buffer_map, dev);
 	}
 
 	dev_priv->sarea_priv =
-		(drm_mga_sarea_t *)((u8 *)dev_priv->sarea->handle +
-				    init->sarea_priv_offset);
+	    (drm_mga_sarea_t *) ((u8 *) dev_priv->sarea->handle +
+				 init->sarea_priv_offset);
 
-	drm_core_ioremap( dev_priv->warp, dev );
-	drm_core_ioremap( dev_priv->primary, dev );
-	drm_core_ioremap( dev->agp_buffer_map, dev );
-
-	if(!dev_priv->warp->handle ||
-	   !dev_priv->primary->handle ||
-	   !dev->agp_buffer_map->handle ) {
-		DRM_ERROR( "failed to ioremap agp regions!\n" );
-		/* Assign dev_private so we can do cleanup. */
-		dev->dev_private = (void *)dev_priv;
-		mga_do_cleanup_dma( dev );
+	if (!dev_priv->warp->handle ||
+	    !dev_priv->primary->handle ||
+	    ((dev_priv->dma_access != 0) &&
+	     ((dev->agp_buffer_map == NULL) ||
+	      (dev->agp_buffer_map->handle == NULL)))) {
+		DRM_ERROR("failed to ioremap agp regions!\n");
 		return DRM_ERR(ENOMEM);
 	}
 
-	ret = mga_warp_install_microcode( dev_priv );
-	if ( ret < 0 ) {
-		DRM_ERROR( "failed to install WARP ucode!\n" );
-		/* Assign dev_private so we can do cleanup. */
-		dev->dev_private = (void *)dev_priv;
-		mga_do_cleanup_dma( dev );
+	ret = mga_warp_install_microcode(dev_priv);
+	if (ret < 0) {
+		DRM_ERROR("failed to install WARP ucode!\n");
 		return ret;
 	}
 
-	ret = mga_warp_init( dev_priv );
-	if ( ret < 0 ) {
-		DRM_ERROR( "failed to init WARP engine!\n" );
-		/* Assign dev_private so we can do cleanup. */
-		dev->dev_private = (void *)dev_priv;
-		mga_do_cleanup_dma( dev );
+	ret = mga_warp_init(dev_priv);
+	if (ret < 0) {
+		DRM_ERROR("failed to init WARP engine!\n");
 		return ret;
 	}
 
-	dev_priv->prim.status = (u32 *)dev_priv->status->handle;
+	dev_priv->prim.status = (u32 *) dev_priv->status->handle;
 
-	mga_do_wait_for_idle( dev_priv );
+	mga_do_wait_for_idle(dev_priv);
 
 	/* Init the primary DMA registers.
 	 */
-	MGA_WRITE( MGA_PRIMADDRESS,
-		   dev_priv->primary->offset | MGA_DMA_GENERAL );
+	MGA_WRITE(MGA_PRIMADDRESS, dev_priv->primary->offset | MGA_DMA_GENERAL);
 #if 0
-	MGA_WRITE( MGA_PRIMPTR,
-		   virt_to_bus((void *)dev_priv->prim.status) |
-		   MGA_PRIMPTREN0 |	/* Soft trap, SECEND, SETUPEND */
-		   MGA_PRIMPTREN1 );	/* DWGSYNC */
+	MGA_WRITE(MGA_PRIMPTR, virt_to_bus((void *)dev_priv->prim.status) | MGA_PRIMPTREN0 |	/* Soft trap, SECEND, SETUPEND */
+		  MGA_PRIMPTREN1);	/* DWGSYNC */
 #endif
 
-	dev_priv->prim.start = (u8 *)dev_priv->primary->handle;
-	dev_priv->prim.end = ((u8 *)dev_priv->primary->handle
+	dev_priv->prim.start = (u8 *) dev_priv->primary->handle;
+	dev_priv->prim.end = ((u8 *) dev_priv->primary->handle
 			      + dev_priv->primary->size);
 	dev_priv->prim.size = dev_priv->primary->size;
 
@@ -557,142 +886,173 @@ static int mga_do_init_dma( drm_device_t
 	dev_priv->sarea_priv->last_frame.head = 0;
 	dev_priv->sarea_priv->last_frame.wrap = 0;
 
-	if ( mga_freelist_init( dev, dev_priv ) < 0 ) {
-		DRM_ERROR( "could not initialize freelist\n" );
-		/* Assign dev_private so we can do cleanup. */
-		dev->dev_private = (void *)dev_priv;
-		mga_do_cleanup_dma( dev );
+	if (mga_freelist_init(dev, dev_priv) < 0) {
+		DRM_ERROR("could not initialize freelist\n");
 		return DRM_ERR(ENOMEM);
 	}
 
-	/* Make dev_private visable to others. */
-	dev->dev_private = (void *)dev_priv;
 	return 0;
 }
 
-static int mga_do_cleanup_dma( drm_device_t *dev )
+static int mga_do_cleanup_dma(drm_device_t * dev)
 {
-	DRM_DEBUG( "\n" );
+	int err = 0;
+	DRM_DEBUG("\n");
 
 	/* Make sure interrupts are disabled here because the uninstall ioctl
 	 * may not have been called from userspace and after dev_private
 	 * is freed, it's too late.
 	 */
-	if ( dev->irq_enabled ) drm_irq_uninstall(dev);
+	if (dev->irq_enabled)
+		drm_irq_uninstall(dev);
 
-	if ( dev->dev_private ) {
+	if (dev->dev_private) {
 		drm_mga_private_t *dev_priv = dev->dev_private;
 
-		if ( dev_priv->warp != NULL )
-			drm_core_ioremapfree( dev_priv->warp, dev );
-		if ( dev_priv->primary != NULL )
-			drm_core_ioremapfree( dev_priv->primary, dev );
-		if ( dev->agp_buffer_map != NULL )
-			drm_core_ioremapfree( dev->agp_buffer_map, dev );
-
-		if ( dev_priv->head != NULL ) {
-			mga_freelist_cleanup( dev );
+		if ((dev_priv->warp != NULL) 
+		    && (dev_priv->mmio->type != _DRM_CONSISTENT))
+			drm_core_ioremapfree(dev_priv->warp, dev);
+
+		if ((dev_priv->primary != NULL) 
+		    && (dev_priv->primary->type != _DRM_CONSISTENT))
+			drm_core_ioremapfree(dev_priv->primary, dev);
+
+		if (dev->agp_buffer_map != NULL)
+			drm_core_ioremapfree(dev->agp_buffer_map, dev);
+
+		if (dev_priv->used_new_dma_init) {
+			if (dev_priv->agp_mem != NULL) {
+				dev_priv->agp_textures = NULL;
+				drm_unbind_agp(dev_priv->agp_mem);
+
+				drm_free_agp(dev_priv->agp_mem, dev_priv->agp_pages);
+				dev_priv->agp_pages = 0;
+				dev_priv->agp_mem = NULL;
+			}
+
+			if ((dev->agp != NULL) && dev->agp->acquired) {
+				err = drm_agp_release(dev);
+			}
+
+			dev_priv->used_new_dma_init = 0;
 		}
 
-		drm_free( dev->dev_private, sizeof(drm_mga_private_t),
-			   DRM_MEM_DRIVER );
-		dev->dev_private = NULL;
+		dev_priv->warp = NULL;
+		dev_priv->primary = NULL;
+		dev_priv->mmio = NULL;
+		dev_priv->status = NULL;
+		dev_priv->sarea = NULL;
+		dev_priv->sarea_priv = NULL;
+		dev->agp_buffer_map = NULL;
+
+		memset(&dev_priv->prim, 0, sizeof(dev_priv->prim));
+		dev_priv->warp_pipe = 0;
+		memset(dev_priv->warp_pipe_phys, 0, sizeof(dev_priv->warp_pipe_phys));
+
+		if (dev_priv->head != NULL) {
+			mga_freelist_cleanup(dev);
+		}
 	}
 
 	return 0;
 }
 
-int mga_dma_init( DRM_IOCTL_ARGS )
+int mga_dma_init(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_mga_init_t init;
+	int err;
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	DRM_COPY_FROM_USER_IOCTL( init, (drm_mga_init_t __user *)data, sizeof(init) );
+	DRM_COPY_FROM_USER_IOCTL(init, (drm_mga_init_t __user *) data,
+				 sizeof(init));
 
-	switch ( init.func ) {
+	switch (init.func) {
 	case MGA_INIT_DMA:
-		return mga_do_init_dma( dev, &init );
+		err = mga_do_init_dma(dev, &init);
+		if (err) {
+			(void) mga_do_cleanup_dma(dev);
+		}
+		return err;
 	case MGA_CLEANUP_DMA:
-		return mga_do_cleanup_dma( dev );
+		return mga_do_cleanup_dma(dev);
 	}
 
 	return DRM_ERR(EINVAL);
 }
 
-
 /* ================================================================
  * Primary DMA stream management
  */
 
-int mga_dma_flush( DRM_IOCTL_ARGS )
+int mga_dma_flush(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
-	drm_mga_private_t *dev_priv = (drm_mga_private_t *)dev->dev_private;
+	drm_mga_private_t *dev_priv = (drm_mga_private_t *) dev->dev_private;
 	drm_lock_t lock;
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	DRM_COPY_FROM_USER_IOCTL( lock, (drm_lock_t __user *)data, sizeof(lock) );
+	DRM_COPY_FROM_USER_IOCTL(lock, (drm_lock_t __user *) data,
+				 sizeof(lock));
 
-	DRM_DEBUG( "%s%s%s\n",
-		   (lock.flags & _DRM_LOCK_FLUSH) ?	"flush, " : "",
-		   (lock.flags & _DRM_LOCK_FLUSH_ALL) ?	"flush all, " : "",
-		   (lock.flags & _DRM_LOCK_QUIESCENT) ?	"idle, " : "" );
+	DRM_DEBUG("%s%s%s\n",
+		  (lock.flags & _DRM_LOCK_FLUSH) ? "flush, " : "",
+		  (lock.flags & _DRM_LOCK_FLUSH_ALL) ? "flush all, " : "",
+		  (lock.flags & _DRM_LOCK_QUIESCENT) ? "idle, " : "");
 
-	WRAP_WAIT_WITH_RETURN( dev_priv );
+	WRAP_WAIT_WITH_RETURN(dev_priv);
 
-	if ( lock.flags & (_DRM_LOCK_FLUSH | _DRM_LOCK_FLUSH_ALL) ) {
-		mga_do_dma_flush( dev_priv );
+	if (lock.flags & (_DRM_LOCK_FLUSH | _DRM_LOCK_FLUSH_ALL)) {
+		mga_do_dma_flush(dev_priv);
 	}
 
-	if ( lock.flags & _DRM_LOCK_QUIESCENT ) {
+	if (lock.flags & _DRM_LOCK_QUIESCENT) {
 #if MGA_DMA_DEBUG
-		int ret = mga_do_wait_for_idle( dev_priv );
-		if ( ret < 0 )
-			DRM_INFO( "%s: -EBUSY\n", __FUNCTION__ );
+		int ret = mga_do_wait_for_idle(dev_priv);
+		if (ret < 0)
+			DRM_INFO("%s: -EBUSY\n", __FUNCTION__);
 		return ret;
 #else
-		return mga_do_wait_for_idle( dev_priv );
+		return mga_do_wait_for_idle(dev_priv);
 #endif
 	} else {
 		return 0;
 	}
 }
 
-int mga_dma_reset( DRM_IOCTL_ARGS )
+int mga_dma_reset(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
-	drm_mga_private_t *dev_priv = (drm_mga_private_t *)dev->dev_private;
+	drm_mga_private_t *dev_priv = (drm_mga_private_t *) dev->dev_private;
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	return mga_do_dma_reset( dev_priv );
+	return mga_do_dma_reset(dev_priv);
 }
 
-
 /* ================================================================
  * DMA buffer management
  */
 
-static int mga_dma_get_buffers( DRMFILE filp,
-				drm_device_t *dev, drm_dma_t *d )
+static int mga_dma_get_buffers(DRMFILE filp, drm_device_t * dev, drm_dma_t * d)
 {
 	drm_buf_t *buf;
 	int i;
 
-	for ( i = d->granted_count ; i < d->request_count ; i++ ) {
-		buf = mga_freelist_get( dev );
-		if ( !buf ) return DRM_ERR(EAGAIN);
+	for (i = d->granted_count; i < d->request_count; i++) {
+		buf = mga_freelist_get(dev);
+		if (!buf)
+			return DRM_ERR(EAGAIN);
 
 		buf->filp = filp;
 
-		if ( DRM_COPY_TO_USER( &d->request_indices[i],
-				   &buf->idx, sizeof(buf->idx) ) )
+		if (DRM_COPY_TO_USER(&d->request_indices[i],
+				     &buf->idx, sizeof(buf->idx)))
 			return DRM_ERR(EFAULT);
-		if ( DRM_COPY_TO_USER( &d->request_sizes[i],
-				   &buf->total, sizeof(buf->total) ) )
+		if (DRM_COPY_TO_USER(&d->request_sizes[i],
+				     &buf->total, sizeof(buf->total)))
 			return DRM_ERR(EFAULT);
 
 		d->granted_count++;
@@ -700,55 +1060,69 @@ static int mga_dma_get_buffers( DRMFILE 
 	return 0;
 }
 
-int mga_dma_buffers( DRM_IOCTL_ARGS )
+int mga_dma_buffers(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_device_dma_t *dma = dev->dma;
-	drm_mga_private_t *dev_priv = (drm_mga_private_t *)dev->dev_private;
+	drm_mga_private_t *dev_priv = (drm_mga_private_t *) dev->dev_private;
 	drm_dma_t __user *argp = (void __user *)data;
 	drm_dma_t d;
 	int ret = 0;
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	DRM_COPY_FROM_USER_IOCTL( d, argp, sizeof(d) );
+	DRM_COPY_FROM_USER_IOCTL(d, argp, sizeof(d));
 
 	/* Please don't send us buffers.
 	 */
-	if ( d.send_count != 0 ) {
-		DRM_ERROR( "Process %d trying to send %d buffers via drmDMA\n",
-			   DRM_CURRENTPID, d.send_count );
+	if (d.send_count != 0) {
+		DRM_ERROR("Process %d trying to send %d buffers via drmDMA\n",
+			  DRM_CURRENTPID, d.send_count);
 		return DRM_ERR(EINVAL);
 	}
 
 	/* We'll send you buffers.
 	 */
-	if ( d.request_count < 0 || d.request_count > dma->buf_count ) {
-		DRM_ERROR( "Process %d trying to get %d buffers (of %d max)\n",
-			   DRM_CURRENTPID, d.request_count, dma->buf_count );
+	if (d.request_count < 0 || d.request_count > dma->buf_count) {
+		DRM_ERROR("Process %d trying to get %d buffers (of %d max)\n",
+			  DRM_CURRENTPID, d.request_count, dma->buf_count);
 		return DRM_ERR(EINVAL);
 	}
 
-	WRAP_TEST_WITH_RETURN( dev_priv );
+	WRAP_TEST_WITH_RETURN(dev_priv);
 
 	d.granted_count = 0;
 
-	if ( d.request_count ) {
-		ret = mga_dma_get_buffers( filp, dev, &d );
+	if (d.request_count) {
+		ret = mga_dma_get_buffers(filp, dev, &d);
 	}
 
-	DRM_COPY_TO_USER_IOCTL( argp, d, sizeof(d) );
+	DRM_COPY_TO_USER_IOCTL(argp, d, sizeof(d));
 
 	return ret;
 }
 
-void mga_driver_pretakedown(drm_device_t *dev)
+/**
+ * Called just before the module is unloaded.
+ */
+int mga_driver_postcleanup(drm_device_t * dev)
+{
+	drm_free(dev->dev_private, sizeof(drm_mga_private_t), DRM_MEM_DRIVER);
+	dev->dev_private = NULL;
+
+	return 0;
+}
+
+/**
+ * Called when the last opener of the device is closed.
+ */
+void mga_driver_pretakedown(drm_device_t * dev)
 {
-	mga_do_cleanup_dma( dev );
+	mga_do_cleanup_dma(dev);
 }
 
-int mga_driver_dma_quiescent(drm_device_t *dev)
+int mga_driver_dma_quiescent(drm_device_t * dev)
 {
 	drm_mga_private_t *dev_priv = dev->dev_private;
-	return mga_do_wait_for_idle( dev_priv );
+	return mga_do_wait_for_idle(dev_priv);
 }
diff -purN linux-2.6.12.orig/drivers/char/drm/mga_drm.h linux-2.6.12/drivers/char/drm/mga_drm.h
--- linux-2.6.12.orig/drivers/char/drm/mga_drm.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/mga_drm.h	2005-07-05 08:37:49.000000000 +0200
@@ -44,10 +44,10 @@
 
 /* WARP pipe flags
  */
-#define MGA_F			0x1		/* fog */
-#define MGA_A			0x2		/* alpha */
-#define MGA_S			0x4		/* specular */
-#define MGA_T2			0x8		/* multitexture */
+#define MGA_F			0x1	/* fog */
+#define MGA_A			0x2	/* alpha */
+#define MGA_S			0x4	/* specular */
+#define MGA_T2			0x8	/* multitexture */
 
 #define MGA_WARP_TGZ		0
 #define MGA_WARP_TGZF		(MGA_F)
@@ -66,14 +66,15 @@
 #define MGA_WARP_T2GZSA		(MGA_T2|MGA_S|MGA_A)
 #define MGA_WARP_T2GZSAF	(MGA_T2|MGA_S|MGA_F|MGA_A)
 
-#define MGA_MAX_G200_PIPES	8		/* no multitex */
+#define MGA_MAX_G200_PIPES	8	/* no multitex */
 #define MGA_MAX_G400_PIPES	16
 #define MGA_MAX_WARP_PIPES	MGA_MAX_G400_PIPES
-#define MGA_WARP_UCODE_SIZE	32768		/* in bytes */
+#define MGA_WARP_UCODE_SIZE	32768	/* in bytes */
 
 #define MGA_CARD_TYPE_G200	1
 #define MGA_CARD_TYPE_G400	2
-
+#define MGA_CARD_TYPE_G450	3       /* not currently used */
+#define MGA_CARD_TYPE_G550	4
 
 #define MGA_FRONT		0x1
 #define MGA_BACK		0x2
@@ -85,14 +86,14 @@
 #define MGA_UPLOAD_TEX0		0x2
 #define MGA_UPLOAD_TEX1		0x4
 #define MGA_UPLOAD_PIPE		0x8
-#define MGA_UPLOAD_TEX0IMAGE	0x10 /* handled client-side */
-#define MGA_UPLOAD_TEX1IMAGE	0x20 /* handled client-side */
+#define MGA_UPLOAD_TEX0IMAGE	0x10	/* handled client-side */
+#define MGA_UPLOAD_TEX1IMAGE	0x20	/* handled client-side */
 #define MGA_UPLOAD_2D		0x40
-#define MGA_WAIT_AGE		0x80 /* handled client-side */
-#define MGA_UPLOAD_CLIPRECTS	0x100 /* handled client-side */
+#define MGA_WAIT_AGE		0x80	/* handled client-side */
+#define MGA_UPLOAD_CLIPRECTS	0x100	/* handled client-side */
 #if 0
-#define MGA_DMA_FLUSH		0x200 /* set when someone gets the lock
-					 quiescent */
+#define MGA_DMA_FLUSH		0x200	/* set when someone gets the lock
+					   quiescent */
 #endif
 
 /* 32 buffers of 64k each, total 2 meg.
@@ -119,8 +120,7 @@
 
 #define  DRM_MGA_IDLE_RETRY          2048
 
-#endif /* __MGA_SAREA_DEFINES__ */
-
+#endif				/* __MGA_SAREA_DEFINES__ */
 
 /* Setup registers for 3D context
  */
@@ -164,25 +164,25 @@ typedef struct {
 /* General aging mechanism
  */
 typedef struct {
-	unsigned int head;		/* Position of head pointer          */
-	unsigned int wrap;		/* Primary DMA wrap count            */
+	unsigned int head;	/* Position of head pointer          */
+	unsigned int wrap;	/* Primary DMA wrap count            */
 } drm_mga_age_t;
 
 typedef struct _drm_mga_sarea {
 	/* The channel for communication of state information to the kernel
 	 * on firing a vertex dma buffer.
 	 */
-   	drm_mga_context_regs_t context_state;
-   	drm_mga_server_regs_t server_state;
-   	drm_mga_texture_regs_t tex_state[2];
-   	unsigned int warp_pipe;
-   	unsigned int dirty;
-   	unsigned int vertsize;
+	drm_mga_context_regs_t context_state;
+	drm_mga_server_regs_t server_state;
+	drm_mga_texture_regs_t tex_state[2];
+	unsigned int warp_pipe;
+	unsigned int dirty;
+	unsigned int vertsize;
 
 	/* The current cliprects, or a subset thereof.
 	 */
-   	drm_clip_rect_t boxes[MGA_NR_SAREA_CLIPRECTS];
-   	unsigned int nbox;
+	drm_clip_rect_t boxes[MGA_NR_SAREA_CLIPRECTS];
+	unsigned int nbox;
 
 	/* Information about the most recently used 3d drawable.  The
 	 * client fills in the req_* fields, the server fills in the
@@ -191,18 +191,18 @@ typedef struct _drm_mga_sarea {
 	 * The client clears the exported_drawable field before
 	 * clobbering the boxes data.
 	 */
-        unsigned int req_drawable;	 /* the X drawable id */
-	unsigned int req_draw_buffer;	 /* MGA_FRONT or MGA_BACK */
+	unsigned int req_drawable;	/* the X drawable id */
+	unsigned int req_draw_buffer;	/* MGA_FRONT or MGA_BACK */
 
-        unsigned int exported_drawable;
+	unsigned int exported_drawable;
 	unsigned int exported_index;
-        unsigned int exported_stamp;
-        unsigned int exported_buffers;
-        unsigned int exported_nfront;
-        unsigned int exported_nback;
+	unsigned int exported_stamp;
+	unsigned int exported_buffers;
+	unsigned int exported_nfront;
+	unsigned int exported_nback;
 	int exported_back_x, exported_front_x, exported_w;
 	int exported_back_y, exported_front_y, exported_h;
-   	drm_clip_rect_t exported_boxes[MGA_NR_SAREA_CLIPRECTS];
+	drm_clip_rect_t exported_boxes[MGA_NR_SAREA_CLIPRECTS];
 
 	/* Counters for aging textures and for client-side throttling.
 	 */
@@ -210,25 +210,21 @@ typedef struct _drm_mga_sarea {
 	unsigned int last_wrap;
 
 	drm_mga_age_t last_frame;
-        unsigned int last_enqueue;	/* last time a buffer was enqueued */
+	unsigned int last_enqueue;	/* last time a buffer was enqueued */
 	unsigned int last_dispatch;	/* age of the most recently dispatched buffer */
-	unsigned int last_quiescent;     /*  */
+	unsigned int last_quiescent;	/*  */
 
 	/* LRU lists for texture memory in agp space and on the card.
 	 */
-	drm_tex_region_t texList[MGA_NR_TEX_HEAPS][MGA_NR_TEX_REGIONS+1];
+	drm_tex_region_t texList[MGA_NR_TEX_HEAPS][MGA_NR_TEX_REGIONS + 1];
 	unsigned int texAge[MGA_NR_TEX_HEAPS];
 
 	/* Mechanism to validate card state.
 	 */
-   	int ctxOwner;
+	int ctxOwner;
 } drm_mga_sarea_t;
 
 
-/* WARNING: If you change any of these defines, make sure to change the
- * defines in the Xserver file (xf86drmMga.h)
- */
-
 /* MGA specific ioctls
  * The device specific ioctl range is 0x40 to 0x79.
  */
@@ -243,6 +239,14 @@ typedef struct _drm_mga_sarea {
 #define DRM_MGA_BLIT     0x08
 #define DRM_MGA_GETPARAM 0x09
 
+/* 3.2:
+ * ioctls for operating on fences.
+ */
+#define DRM_MGA_SET_FENCE      0x0a
+#define DRM_MGA_WAIT_FENCE     0x0b
+#define DRM_MGA_DMA_BOOTSTRAP  0x0c
+
+
 #define DRM_IOCTL_MGA_INIT     DRM_IOW( DRM_COMMAND_BASE + DRM_MGA_INIT, drm_mga_init_t)
 #define DRM_IOCTL_MGA_FLUSH    DRM_IOW( DRM_COMMAND_BASE + DRM_MGA_FLUSH, drm_lock_t)
 #define DRM_IOCTL_MGA_RESET    DRM_IO(  DRM_COMMAND_BASE + DRM_MGA_RESET)
@@ -253,35 +257,38 @@ typedef struct _drm_mga_sarea {
 #define DRM_IOCTL_MGA_ILOAD    DRM_IOW( DRM_COMMAND_BASE + DRM_MGA_ILOAD, drm_mga_iload_t)
 #define DRM_IOCTL_MGA_BLIT     DRM_IOW( DRM_COMMAND_BASE + DRM_MGA_BLIT, drm_mga_blit_t)
 #define DRM_IOCTL_MGA_GETPARAM DRM_IOWR(DRM_COMMAND_BASE + DRM_MGA_GETPARAM, drm_mga_getparam_t)
+#define DRM_IOCTL_MGA_SET_FENCE     DRM_IOW( DRM_COMMAND_BASE + DRM_MGA_SET_FENCE, uint32_t)
+#define DRM_IOCTL_MGA_WAIT_FENCE    DRM_IOWR(DRM_COMMAND_BASE + DRM_MGA_WAIT_FENCE, uint32_t)
+#define DRM_IOCTL_MGA_DMA_BOOTSTRAP DRM_IOWR(DRM_COMMAND_BASE + DRM_MGA_DMA_BOOTSTRAP, drm_mga_dma_bootstrap_t)
 
 typedef struct _drm_mga_warp_index {
-   	int installed;
-   	unsigned long phys_addr;
-   	int size;
+	int installed;
+	unsigned long phys_addr;
+	int size;
 } drm_mga_warp_index_t;
 
 typedef struct drm_mga_init {
-   	enum {
-	   	MGA_INIT_DMA    = 0x01,
-	       	MGA_CLEANUP_DMA = 0x02
+	enum {
+		MGA_INIT_DMA = 0x01,
+		MGA_CLEANUP_DMA = 0x02
 	} func;
 
-   	unsigned long sarea_priv_offset;
+	unsigned long sarea_priv_offset;
 
 	int chipset;
-   	int sgram;
+	int sgram;
 
 	unsigned int maccess;
 
-   	unsigned int fb_cpp;
+	unsigned int fb_cpp;
 	unsigned int front_offset, front_pitch;
-   	unsigned int back_offset, back_pitch;
+	unsigned int back_offset, back_pitch;
 
-   	unsigned int depth_cpp;
-   	unsigned int depth_offset, depth_pitch;
+	unsigned int depth_cpp;
+	unsigned int depth_offset, depth_pitch;
 
-   	unsigned int texture_offset[MGA_NR_TEX_HEAPS];
-   	unsigned int texture_size[MGA_NR_TEX_HEAPS];
+	unsigned int texture_offset[MGA_NR_TEX_HEAPS];
+	unsigned int texture_size[MGA_NR_TEX_HEAPS];
 
 	unsigned long fb_offset;
 	unsigned long mmio_offset;
@@ -291,12 +298,73 @@ typedef struct drm_mga_init {
 	unsigned long buffers_offset;
 } drm_mga_init_t;
 
-typedef struct drm_mga_fullscreen {
-	enum {
-		MGA_INIT_FULLSCREEN    = 0x01,
-		MGA_CLEANUP_FULLSCREEN = 0x02
-	} func;
-} drm_mga_fullscreen_t;
+
+typedef struct drm_mga_dma_bootstrap {
+	/**
+	 * \name AGP texture region
+	 * 
+	 * On return from the DRM_MGA_DMA_BOOTSTRAP ioctl, these fields will
+	 * be filled in with the actual AGP texture settings.
+	 * 
+	 * \warning
+	 * If these fields are non-zero, but dma_mga_dma_bootstrap::agp_mode
+	 * is zero, it means that PCI memory (most likely through the use of
+	 * an IOMMU) is being used for "AGP" textures.
+	 */
+	/*@{*/
+	drm_handle_t texture_handle;  /**< Handle used to map AGP textures. */
+	uint32_t     texture_size;    /**< Size of the AGP texture region. */
+	/*@}*/
+
+
+	/**
+	 * Requested size of the primary DMA region.
+	 * 
+	 * On return from the DRM_MGA_DMA_BOOTSTRAP ioctl, this field will be
+	 * filled in with the actual AGP mode.  If AGP was not available
+	 */
+	uint32_t primary_size;
+
+
+	/**
+	 * Requested number of secondary DMA buffers.
+	 * 
+	 * On return from the DRM_MGA_DMA_BOOTSTRAP ioctl, this field will be
+	 * filled in with the actual number of secondary DMA buffers
+	 * allocated.  Particularly when PCI DMA is used, this may be
+	 * (subtantially) less than the number requested.
+	 */
+	uint32_t secondary_bin_count;
+	
+	
+	/**
+	 * Requested size of each secondary DMA buffer.
+	 * 
+	 * While the kernel \b is free to reduce
+	 * dma_mga_dma_bootstrap::secondary_bin_count, it is \b not allowed
+	 * to reduce dma_mga_dma_bootstrap::secondary_bin_size.
+	 */
+	uint32_t secondary_bin_size;
+
+
+	/**
+	 * Bit-wise mask of AGPSTAT2_* values.  Currently only \c AGPSTAT2_1X,
+	 * \c AGPSTAT2_2X, and \c AGPSTAT2_4X are supported.  If this value is
+	 * zero, it means that PCI DMA should be used, even if AGP is
+	 * possible.
+	 * 
+	 * On return from the DRM_MGA_DMA_BOOTSTRAP ioctl, this field will be
+	 * filled in with the actual AGP mode.  If AGP was not available
+	 * (i.e., PCI DMA was used), this value will be zero.
+	 */
+	uint32_t agp_mode;
+
+
+	/**
+	 * Desired AGP GART size, measured in megabytes.
+	 */
+	uint8_t agp_size;
+} drm_mga_dma_bootstrap_t;
 
 typedef struct drm_mga_clear {
 	unsigned int flags;
@@ -307,16 +375,16 @@ typedef struct drm_mga_clear {
 } drm_mga_clear_t;
 
 typedef struct drm_mga_vertex {
-   	int idx;			/* buffer to queue */
-	int used;			/* bytes in use */
-	int discard;			/* client finished with buffer?  */
+	int idx;		/* buffer to queue */
+	int used;		/* bytes in use */
+	int discard;		/* client finished with buffer?  */
 } drm_mga_vertex_t;
 
 typedef struct drm_mga_indices {
-   	int idx;			/* buffer to queue */
+	int idx;		/* buffer to queue */
 	unsigned int start;
 	unsigned int end;
-	int discard;			/* client finished with buffer?  */
+	int discard;		/* client finished with buffer?  */
 } drm_mga_indices_t;
 
 typedef struct drm_mga_iload {
@@ -332,15 +400,23 @@ typedef struct _drm_mga_blit {
 	int src_pitch, dst_pitch;
 	int delta_sx, delta_sy;
 	int delta_dx, delta_dy;
-	int height, ydir;		/* flip image vertically */
+	int height, ydir;	/* flip image vertically */
 	int source_pitch, dest_pitch;
 } drm_mga_blit_t;
 
 /* 3.1: An ioctl to get parameters that aren't available to the 3d
- * client any other way.  
+ * client any other way.
  */
 #define MGA_PARAM_IRQ_NR            1
 
+/* 3.2: Query the actual card type.  The DDX only distinguishes between
+ * G200 chips and non-G200 chips, which it calls G400.  It turns out that
+ * there are some very sublte differences between the G4x0 chips and the G550
+ * chips.  Using this parameter query, a client-side driver can detect the
+ * difference between a G4x0 and a G550.
+ */
+#define MGA_PARAM_CARD_TYPE         2
+
 typedef struct drm_mga_getparam {
 	int param;
 	void __user *value;
diff -purN linux-2.6.12.orig/drivers/char/drm/mga_drv.c linux-2.6.12/drivers/char/drm/mga_drv.c
--- linux-2.6.12.orig/drivers/char/drm/mga_drv.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/mga_drv.c	2005-07-05 08:37:27.000000000 +0200
@@ -35,38 +35,42 @@
 #include "mga_drm.h"
 #include "mga_drv.h"
 
-  
 #include "drm_pciids.h"
 
-static int postinit( struct drm_device *dev, unsigned long flags )
+static int mga_driver_device_is_agp(drm_device_t * dev);
+static int postinit(struct drm_device *dev, unsigned long flags)
 {
+	drm_mga_private_t * const dev_priv =
+		(drm_mga_private_t *) dev->dev_private;
+
+	dev_priv->mmio_base = pci_resource_start(dev->pdev, 1);
+	dev_priv->mmio_size = pci_resource_len(dev->pdev, 1);
+
 	dev->counters += 3;
 	dev->types[6] = _DRM_STAT_IRQ;
 	dev->types[7] = _DRM_STAT_PRIMARY;
 	dev->types[8] = _DRM_STAT_SECONDARY;
 
-	DRM_INFO( "Initialized %s %d.%d.%d %s on minor %d: %s\n",
-		DRIVER_NAME,
-		DRIVER_MAJOR,
-		DRIVER_MINOR,
-		DRIVER_PATCHLEVEL,
-		DRIVER_DATE,
-		dev->primary.minor,
-		pci_pretty_name(dev->pdev)
-		);
+	DRM_INFO("Initialized %s %d.%d.%d %s on minor %d: %s\n",
+		 DRIVER_NAME,
+		 DRIVER_MAJOR,
+		 DRIVER_MINOR,
+		 DRIVER_PATCHLEVEL,
+		 DRIVER_DATE, dev->primary.minor, pci_pretty_name(dev->pdev)
+	    );
 	return 0;
 }
 
-static int version( drm_version_t *version )
+static int version(drm_version_t * version)
 {
 	int len;
 
 	version->version_major = DRIVER_MAJOR;
 	version->version_minor = DRIVER_MINOR;
 	version->version_patchlevel = DRIVER_PATCHLEVEL;
-	DRM_COPY( version->name, DRIVER_NAME );
-	DRM_COPY( version->date, DRIVER_DATE );
-	DRM_COPY( version->desc, DRIVER_DESC );
+	DRM_COPY(version->name, DRIVER_NAME);
+	DRM_COPY(version->date, DRIVER_DATE);
+	DRM_COPY(version->desc, DRIVER_DESC);
 	return 0;
 }
 
@@ -77,10 +81,17 @@ static struct pci_device_id pciidlist[] 
 extern drm_ioctl_desc_t mga_ioctls[];
 extern int mga_max_ioctl;
 
+static int probe(struct pci_dev *pdev, const struct pci_device_id *ent);
 static struct drm_driver driver = {
-	.driver_features = DRIVER_USE_AGP | DRIVER_REQUIRE_AGP | DRIVER_USE_MTRR | DRIVER_HAVE_DMA | DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED | DRIVER_IRQ_VBL,
+	.driver_features =
+	    DRIVER_USE_AGP | DRIVER_USE_MTRR | DRIVER_PCI_DMA |
+	    DRIVER_HAVE_DMA | DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED |
+	    DRIVER_IRQ_VBL,
+	.preinit = mga_driver_preinit,
+	.postcleanup = mga_driver_postcleanup,
 	.pretakedown = mga_driver_pretakedown,
 	.dma_quiescent = mga_driver_dma_quiescent,
+	.device_is_agp = mga_driver_device_is_agp,
 	.vblank_wait = mga_driver_vblank_wait,
 	.irq_preinstall = mga_driver_irq_preinstall,
 	.irq_postinstall = mga_driver_irq_postinstall,
@@ -101,17 +112,28 @@ static struct drm_driver driver = {
 		.mmap = drm_mmap,
 		.poll = drm_poll,
 		.fasync = drm_fasync,
-	},
+#ifdef CONFIG_COMPAT
+		.compat_ioctl = mga_compat_ioctl,
+#endif
+		},
 	.pci_driver = {
 		.name = DRIVER_NAME,
 		.id_table = pciidlist,
+		.probe = probe,
+		.remove = __devexit_p(drm_cleanup_pci),
 	}
 };
 
+static int probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	return drm_get_dev(pdev, ent, &driver);
+}
+
+
 static int __init mga_init(void)
 {
 	driver.num_ioctls = mga_max_ioctl;
-	return drm_init(&driver);
+	return drm_init(&driver, pciidlist);
 }
 
 static void __exit mga_exit(void)
@@ -122,6 +144,41 @@ static void __exit mga_exit(void)
 module_init(mga_init);
 module_exit(mga_exit);
 
-MODULE_AUTHOR( DRIVER_AUTHOR );
-MODULE_DESCRIPTION( DRIVER_DESC );
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL and additional rights");
+
+/**
+ * Determine if the device really is AGP or not.
+ *
+ * In addition to the usual tests performed by \c drm_device_is_agp, this
+ * function detects PCI G450 cards that appear to the system exactly like
+ * AGP G450 cards.
+ *
+ * \param dev   The device to be tested.
+ *
+ * \returns
+ * If the device is a PCI G450, zero is returned.  Otherwise 2 is returned.
+ */
+int mga_driver_device_is_agp(drm_device_t * dev)
+{
+	const struct pci_dev * const pdev = dev->pdev;
+
+
+	/* There are PCI versions of the G450.  These cards have the
+	 * same PCI ID as the AGP G450, but have an additional PCI-to-PCI
+	 * bridge chip.  We detect these cards, which are not currently
+	 * supported by this driver, by looking at the device ID of the
+	 * bus the "card" is on.  If vendor is 0x3388 (Hint Corp) and the
+	 * device is 0x0021 (HB6 Universal PCI-PCI bridge), we reject the
+	 * device.
+	 */
+	
+	if ( (pdev->device == 0x0525)
+	     && (pdev->bus->self->vendor == 0x3388)
+	     && (pdev->bus->self->device == 0x0021) ) {
+		return 0;
+	}
+
+	return 2;
+}
diff -purN linux-2.6.12.orig/drivers/char/drm/mga_drv.h linux-2.6.12/drivers/char/drm/mga_drv.h
--- linux-2.6.12.orig/drivers/char/drm/mga_drv.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/mga_drv.h	2005-07-05 08:37:49.000000000 +0200
@@ -38,10 +38,10 @@
 
 #define DRIVER_NAME		"mga"
 #define DRIVER_DESC		"Matrox G200/G400"
-#define DRIVER_DATE		"20021029"
+#define DRIVER_DATE		"20050607"
 
 #define DRIVER_MAJOR		3
-#define DRIVER_MINOR		1
+#define DRIVER_MINOR		2
 #define DRIVER_PATCHLEVEL	0
 
 typedef struct drm_mga_primary_buffer {
@@ -62,14 +62,14 @@ typedef struct drm_mga_primary_buffer {
 } drm_mga_primary_buffer_t;
 
 typedef struct drm_mga_freelist {
-   	struct drm_mga_freelist *next;
-   	struct drm_mga_freelist *prev;
+	struct drm_mga_freelist *next;
+	struct drm_mga_freelist *prev;
 	drm_mga_age_t age;
-   	drm_buf_t *buf;
+	drm_buf_t *buf;
 } drm_mga_freelist_t;
 
 typedef struct {
-   	drm_mga_freelist_t *list_entry;
+	drm_mga_freelist_t *list_entry;
 	int discard;
 	int dispatched;
 } drm_mga_buf_priv_t;
@@ -78,8 +78,8 @@ typedef struct drm_mga_private {
 	drm_mga_primary_buffer_t prim;
 	drm_mga_sarea_t *sarea_priv;
 
-   	drm_mga_freelist_t *head;
-   	drm_mga_freelist_t *tail;
+	drm_mga_freelist_t *head;
+	drm_mga_freelist_t *tail;
 
 	unsigned int warp_pipe;
 	unsigned long warp_pipe_phys[MGA_MAX_WARP_PIPES];
@@ -87,9 +87,43 @@ typedef struct drm_mga_private {
 	int chipset;
 	int usec_timeout;
 
+	/**
+	 * If set, the new DMA initialization sequence was used.  This is
+	 * primarilly used to select how the driver should uninitialized its
+	 * internal DMA structures.
+	 */
+	int used_new_dma_init;
+
+	/**
+	 * If AGP memory is used for DMA buffers, this will be the value
+	 * \c MGA_PAGPXFER.  Otherwise, it will be zero (for a PCI transfer).
+	 */
+	u32 dma_access;
+
+	/**
+	 * If AGP memory is used for DMA buffers, this will be the value
+	 * \c MGA_WAGP_ENABLE.  Otherwise, it will be zero (for a PCI
+	 * transfer).
+	 */
+	u32 wagp_enable;
+
+	/**
+	 * \name MMIO region parameters.
+	 * 
+	 * \sa drm_mga_private_t::mmio
+	 */
+	/*@{*/
+	u32 mmio_base;             /**< Bus address of base of MMIO. */
+	u32 mmio_size;             /**< Size of the MMIO region. */
+	/*@}*/
+
 	u32 clear_cmd;
 	u32 maccess;
 
+	wait_queue_head_t fence_queue;
+	atomic_t last_fence_retired;
+	u32 next_fence_to_post;
+
 	unsigned int fb_cpp;
 	unsigned int front_offset;
 	unsigned int front_pitch;
@@ -108,35 +142,45 @@ typedef struct drm_mga_private {
 	drm_local_map_t *status;
 	drm_local_map_t *warp;
 	drm_local_map_t *primary;
-	drm_local_map_t *buffers;
 	drm_local_map_t *agp_textures;
+	
+	DRM_AGP_MEM *agp_mem;
+	unsigned int agp_pages;
 } drm_mga_private_t;
 
 				/* mga_dma.c */
-extern int mga_dma_init( DRM_IOCTL_ARGS );
-extern int mga_dma_flush( DRM_IOCTL_ARGS );
-extern int mga_dma_reset( DRM_IOCTL_ARGS );
-extern int mga_dma_buffers( DRM_IOCTL_ARGS );
-extern void mga_driver_pretakedown(drm_device_t *dev);
-extern int mga_driver_dma_quiescent(drm_device_t *dev);
-
-extern int mga_do_wait_for_idle( drm_mga_private_t *dev_priv );
-
-extern void mga_do_dma_flush( drm_mga_private_t *dev_priv );
-extern void mga_do_dma_wrap_start( drm_mga_private_t *dev_priv );
-extern void mga_do_dma_wrap_end( drm_mga_private_t *dev_priv );
+extern int mga_driver_preinit(drm_device_t * dev, unsigned long flags);
+extern int mga_dma_bootstrap(DRM_IOCTL_ARGS);
+extern int mga_dma_init(DRM_IOCTL_ARGS);
+extern int mga_dma_flush(DRM_IOCTL_ARGS);
+extern int mga_dma_reset(DRM_IOCTL_ARGS);
+extern int mga_dma_buffers(DRM_IOCTL_ARGS);
+extern int mga_driver_postcleanup(drm_device_t * dev);
+extern void mga_driver_pretakedown(drm_device_t * dev);
+extern int mga_driver_dma_quiescent(drm_device_t * dev);
+
+extern int mga_do_wait_for_idle(drm_mga_private_t * dev_priv);
+
+extern void mga_do_dma_flush(drm_mga_private_t * dev_priv);
+extern void mga_do_dma_wrap_start(drm_mga_private_t * dev_priv);
+extern void mga_do_dma_wrap_end(drm_mga_private_t * dev_priv);
 
-extern int mga_freelist_put( drm_device_t *dev, drm_buf_t *buf );
+extern int mga_freelist_put(drm_device_t * dev, drm_buf_t * buf);
 
 				/* mga_warp.c */
-extern int mga_warp_install_microcode( drm_mga_private_t *dev_priv );
-extern int mga_warp_init( drm_mga_private_t *dev_priv );
-
-extern int mga_driver_vblank_wait(drm_device_t *dev, unsigned int *sequence);
-extern irqreturn_t mga_driver_irq_handler( DRM_IRQ_ARGS );
-extern void mga_driver_irq_preinstall( drm_device_t *dev );
-extern void mga_driver_irq_postinstall( drm_device_t *dev );
-extern void mga_driver_irq_uninstall( drm_device_t *dev );
+extern unsigned int mga_warp_microcode_size(const drm_mga_private_t * dev_priv);
+extern int mga_warp_install_microcode(drm_mga_private_t * dev_priv);
+extern int mga_warp_init(drm_mga_private_t * dev_priv);
+
+				/* mga_irq.c */
+extern int mga_driver_fence_wait(drm_device_t * dev, unsigned int *sequence);
+extern int mga_driver_vblank_wait(drm_device_t * dev, unsigned int *sequence);
+extern irqreturn_t mga_driver_irq_handler(DRM_IRQ_ARGS);
+extern void mga_driver_irq_preinstall(drm_device_t * dev);
+extern void mga_driver_irq_postinstall(drm_device_t * dev);
+extern void mga_driver_irq_uninstall(drm_device_t * dev);
+extern long mga_compat_ioctl(struct file *filp, unsigned int cmd,
+			     unsigned long arg);
 
 #define mga_flush_write_combine()	DRM_WRITEMEMORYBARRIER()
 
@@ -152,7 +196,7 @@ extern void mga_driver_irq_uninstall( dr
 #define MGA_WRITE( reg, val )	do { DRM_WRITEMEMORYBARRIER(); MGA_DEREF( reg ) = val; } while (0)
 #define MGA_WRITE8( reg, val )  do { DRM_WRITEMEMORYBARRIER(); MGA_DEREF8( reg ) = val; } while (0)
 
-static inline u32 _MGA_READ(u32 *addr)
+static inline u32 _MGA_READ(u32 * addr)
 {
 	DRM_MEMORYBARRIER();
 	return *(volatile u32 *)addr;
@@ -174,8 +218,6 @@ static inline u32 _MGA_READ(u32 *addr)
 #define DMAREG1(r)	(u8)(((r - DWGREG1) >> 2) | 0x80)
 #define DMAREG(r)	(ISREG0(r) ? DMAREG0(r) : DMAREG1(r))
 
-
-
 /* ================================================================
  * Helper macross...
  */
@@ -217,7 +259,6 @@ do {									\
 	}								\
 } while (0)
 
-
 /* ================================================================
  * Primary DMA command stream
  */
@@ -302,7 +343,6 @@ do {									\
 	write += DMA_BLOCK_SIZE;					\
 } while (0)
 
-
 /* Buffer aging via primary DMA stream head pointer.
  */
 
@@ -329,7 +369,6 @@ do {									\
 	}								\
 } while (0)
 
-
 #define MGA_ENGINE_IDLE_MASK		(MGA_SOFTRAPEN |		\
 					 MGA_DWGENGSTS |		\
 					 MGA_ENDPRDMASTS)
@@ -338,8 +377,6 @@ do {									\
 
 #define MGA_DMA_DEBUG			0
 
-
-
 /* A reduced set of the mga registers.
  */
 #define MGA_CRTC_INDEX			0x1fd4
@@ -525,6 +562,12 @@ do {									\
  */
 #define MGA_EXEC 			0x0100
 
+/* AGP PLL encoding (for G200 only).
+ */
+#define MGA_AGP_PLL 			0x1e4c
+#	define MGA_AGP2XPLL_DISABLE		(0 << 0)
+#	define MGA_AGP2XPLL_ENABLE		(1 << 0)
+
 /* Warp registers
  */
 #define MGA_WR0				0x2d00
@@ -594,7 +637,6 @@ do {									\
 #	define MGA_G400_WR_MAGIC		(1 << 6)
 #	define MGA_G400_WR56_MAGIC		0x46480000	/* 12800.0f */
 
-
 #define MGA_ILOAD_ALIGN		64
 #define MGA_ILOAD_MASK		(MGA_ILOAD_ALIGN - 1)
 
@@ -629,10 +671,10 @@ do {									\
 
 /* Simple idle test.
  */
-static __inline__ int mga_is_idle( drm_mga_private_t *dev_priv )
+static __inline__ int mga_is_idle(drm_mga_private_t * dev_priv)
 {
-	u32 status = MGA_READ( MGA_STATUS ) & MGA_ENGINE_IDLE_MASK;
-	return ( status == MGA_ENDPRDMASTS );
+	u32 status = MGA_READ(MGA_STATUS) & MGA_ENGINE_IDLE_MASK;
+	return (status == MGA_ENDPRDMASTS);
 }
 
 #endif
diff -purN linux-2.6.12.orig/drivers/char/drm/mga_ioc32.c linux-2.6.12/drivers/char/drm/mga_ioc32.c
--- linux-2.6.12.orig/drivers/char/drm/mga_ioc32.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/drm/mga_ioc32.c	2005-07-05 08:37:27.000000000 +0200
@@ -0,0 +1,167 @@
+/**
+ * \file mga_ioc32.c
+ *
+ * 32-bit ioctl compatibility routines for the MGA DRM.
+ *
+ * \author Dave Airlie <airlied@linux.ie> with code from patches by Egbert Eich
+ *
+ *
+ * Copyright (C) Paul Mackerras 2005
+ * Copyright (C) Egbert Eich 2003,2004
+ * Copyright (C) Dave Airlie 2005
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+#include <linux/compat.h>
+#include <linux/ioctl32.h>
+
+#include "drmP.h"
+#include "drm.h"
+#include "mga_drm.h"
+
+typedef struct drm32_mga_init {
+	int func;
+   	u32 sarea_priv_offset;
+	int chipset;
+   	int sgram;
+	unsigned int maccess;
+   	unsigned int fb_cpp;
+	unsigned int front_offset, front_pitch;
+   	unsigned int back_offset, back_pitch;
+   	unsigned int depth_cpp;
+   	unsigned int depth_offset, depth_pitch;
+   	unsigned int texture_offset[MGA_NR_TEX_HEAPS];
+   	unsigned int texture_size[MGA_NR_TEX_HEAPS];
+	u32 fb_offset;
+	u32 mmio_offset;
+	u32 status_offset;
+	u32 warp_offset;
+	u32 primary_offset;
+	u32 buffers_offset;
+} drm_mga_init32_t;
+
+static int compat_mga_init(struct file *file, unsigned int cmd,
+			   unsigned long arg)
+{
+	drm_mga_init32_t init32;
+	drm_mga_init_t __user *init;
+	int err = 0, i;
+	
+	if (copy_from_user(&init32, (void __user *)arg, sizeof(init32)))
+		return -EFAULT;
+	
+	init = compat_alloc_user_space(sizeof(*init));
+	if (!access_ok(VERIFY_WRITE, init, sizeof(*init))
+	    || __put_user(init32.func, &init->func)
+	    || __put_user(init32.sarea_priv_offset, &init->sarea_priv_offset)
+	    || __put_user(init32.chipset, &init->chipset)
+	    || __put_user(init32.sgram, &init->sgram)
+	    || __put_user(init32.maccess, &init->maccess)
+	    || __put_user(init32.fb_cpp, &init->fb_cpp)
+	    || __put_user(init32.front_offset, &init->front_offset)
+	    || __put_user(init32.front_pitch, &init->front_pitch)
+	    || __put_user(init32.back_offset, &init->back_offset)
+	    || __put_user(init32.back_pitch, &init->back_pitch)
+	    || __put_user(init32.depth_cpp, &init->depth_cpp)
+	    || __put_user(init32.depth_offset, &init->depth_offset)
+	    || __put_user(init32.depth_pitch, &init->depth_pitch)
+	    || __put_user(init32.fb_offset, &init->fb_offset)
+	    || __put_user(init32.mmio_offset, &init->mmio_offset)
+	    || __put_user(init32.status_offset, &init->status_offset)
+	    || __put_user(init32.warp_offset, &init->warp_offset)
+	    || __put_user(init32.primary_offset, &init->primary_offset)
+	    || __put_user(init32.buffers_offset, &init->buffers_offset))
+		return -EFAULT;
+	
+	for (i=0; i<MGA_NR_TEX_HEAPS; i++)
+	{
+		err |= __put_user(init32.texture_offset[i], &init->texture_offset[i]);
+		err |= __put_user(init32.texture_size[i], &init->texture_size[i]);
+	}
+	if (err)
+		return -EFAULT;
+	
+	return drm_ioctl(file->f_dentry->d_inode, file,
+			 DRM_IOCTL_MGA_INIT, (unsigned long) init);
+}
+
+
+typedef struct drm_mga_getparam32 {
+	int param;
+	u32 value;
+} drm_mga_getparam32_t;
+
+
+static int compat_mga_getparam(struct file *file, unsigned int cmd,
+			       unsigned long arg)
+{
+	drm_mga_getparam32_t getparam32;
+	drm_mga_getparam_t __user *getparam;
+	
+	if (copy_from_user(&getparam32, (void __user *)arg, sizeof(getparam32)))
+		return -EFAULT;
+
+	getparam = compat_alloc_user_space(sizeof(*getparam));
+	if (!access_ok(VERIFY_WRITE, getparam, sizeof(*getparam))
+	    || __put_user(getparam32.param, &getparam->param)
+	    || __put_user((void __user *)(unsigned long)getparam32.value, &getparam->value))
+		return -EFAULT;
+
+	return drm_ioctl(file->f_dentry->d_inode, file, 
+			 DRM_IOCTL_MGA_GETPARAM, (unsigned long)getparam);
+}
+
+drm_ioctl_compat_t *mga_compat_ioctls[] = {
+	[DRM_MGA_INIT] = compat_mga_init,
+	[DRM_MGA_GETPARAM] = compat_mga_getparam,
+};
+
+/**
+ * Called whenever a 32-bit process running under a 64-bit kernel
+ * performs an ioctl on /dev/dri/card<n>.
+ *
+ * \param filp file pointer.
+ * \param cmd command.
+ * \param arg user argument.
+ * \return zero on success or negative number on failure.
+ */
+long mga_compat_ioctl(struct file *filp, unsigned int cmd,
+			 unsigned long arg)
+{
+	unsigned int nr = DRM_IOCTL_NR(cmd);
+	drm_ioctl_compat_t *fn = NULL;
+	int ret;
+
+	if (nr < DRM_COMMAND_BASE)
+		return drm_compat_ioctl(filp, cmd, arg);
+	
+	if (nr < DRM_COMMAND_BASE + DRM_ARRAY_SIZE(mga_compat_ioctls))
+		fn = mga_compat_ioctls[nr - DRM_COMMAND_BASE];
+
+	lock_kernel();		/* XXX for now */
+	if (fn != NULL)
+		ret = (*fn)(filp, cmd, arg);
+	else
+		ret = drm_ioctl(filp->f_dentry->d_inode, filp, cmd, arg);
+	unlock_kernel();
+
+	return ret;
+}
diff -purN linux-2.6.12.orig/drivers/char/drm/mga_irq.c linux-2.6.12/drivers/char/drm/mga_irq.c
--- linux-2.6.12.orig/drivers/char/drm/mga_irq.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/mga_irq.c	2005-07-05 08:37:47.000000000 +0200
@@ -1,7 +1,7 @@
 /* mga_irq.c -- IRQ handling for radeon -*- linux-c -*-
  *
  * Copyright (C) The Weather Channel, Inc.  2002.  All Rights Reserved.
- * 
+ *
  * The Weather Channel (TM) funded Tungsten Graphics to develop the
  * initial release of the Radeon 8500 driver under the XFree86 license.
  * This notice must be preserved.
@@ -35,68 +35,115 @@
 #include "mga_drm.h"
 #include "mga_drv.h"
 
-irqreturn_t mga_driver_irq_handler( DRM_IRQ_ARGS )
+irqreturn_t mga_driver_irq_handler(DRM_IRQ_ARGS)
 {
 	drm_device_t *dev = (drm_device_t *) arg;
-	drm_mga_private_t *dev_priv = 
-	   (drm_mga_private_t *)dev->dev_private;
+	drm_mga_private_t *dev_priv = (drm_mga_private_t *) dev->dev_private;
 	int status;
+	int handled = 0;
+
+	status = MGA_READ(MGA_STATUS);
 
-	status = MGA_READ( MGA_STATUS );
-	
 	/* VBLANK interrupt */
-	if ( status & MGA_VLINEPEN ) {
-		MGA_WRITE( MGA_ICLEAR, MGA_VLINEICLR );
+	if (status & MGA_VLINEPEN) {
+		MGA_WRITE(MGA_ICLEAR, MGA_VLINEICLR);
 		atomic_inc(&dev->vbl_received);
 		DRM_WAKEUP(&dev->vbl_queue);
-		drm_vbl_send_signals( dev );
+		drm_vbl_send_signals(dev);
+		handled = 1;
+	}
+
+	/* SOFTRAP interrupt */
+	if (status & MGA_SOFTRAPEN) {
+		const u32 prim_start = MGA_READ(MGA_PRIMADDRESS);
+		const u32 prim_end   = MGA_READ(MGA_PRIMEND);
+
+
+		MGA_WRITE(MGA_ICLEAR, MGA_SOFTRAPICLR);
+
+		/* In addition to clearing the interrupt-pending bit, we
+		 * have to write to MGA_PRIMEND to re-start the DMA operation.
+		 */
+		if ( (prim_start & ~0x03) != (prim_end & ~0x03) ) {
+			MGA_WRITE(MGA_PRIMEND, prim_end);
+		}
+
+		atomic_inc(&dev_priv->last_fence_retired);
+		DRM_WAKEUP(&dev_priv->fence_queue);
+		handled = 1;
+	}
+
+	if ( handled ) {
 		return IRQ_HANDLED;
 	}
 	return IRQ_NONE;
 }
 
-int mga_driver_vblank_wait(drm_device_t *dev, unsigned int *sequence)
+int mga_driver_vblank_wait(drm_device_t * dev, unsigned int *sequence)
 {
 	unsigned int cur_vblank;
 	int ret = 0;
 
 	/* Assume that the user has missed the current sequence number
 	 * by about a day rather than she wants to wait for years
-	 * using vertical blanks... 
+	 * using vertical blanks...
 	 */
-	DRM_WAIT_ON( ret, dev->vbl_queue, 3*DRM_HZ, 
-		     ( ( ( cur_vblank = atomic_read(&dev->vbl_received ) )
-			 - *sequence ) <= (1<<23) ) );
+	DRM_WAIT_ON(ret, dev->vbl_queue, 3 * DRM_HZ,
+		    (((cur_vblank = atomic_read(&dev->vbl_received))
+		      - *sequence) <= (1 << 23)));
 
 	*sequence = cur_vblank;
 
 	return ret;
 }
 
-void mga_driver_irq_preinstall( drm_device_t *dev ) {
-  	drm_mga_private_t *dev_priv = 
-	   (drm_mga_private_t *)dev->dev_private;
+int mga_driver_fence_wait(drm_device_t * dev, unsigned int *sequence)
+{
+	drm_mga_private_t *dev_priv = (drm_mga_private_t *) dev->dev_private;
+	unsigned int cur_fence;
+	int ret = 0;
+
+	/* Assume that the user has missed the current sequence number
+	 * by about a day rather than she wants to wait for years
+	 * using fences.
+	 */
+	DRM_WAIT_ON(ret, dev_priv->fence_queue, 3 * DRM_HZ,
+		    (((cur_fence = atomic_read(&dev_priv->last_fence_retired))
+		      - *sequence) <= (1 << 23)));
+
+	*sequence = cur_fence;
+
+	return ret;
+}
+
+void mga_driver_irq_preinstall(drm_device_t * dev)
+{
+	drm_mga_private_t *dev_priv = (drm_mga_private_t *) dev->dev_private;
 
 	/* Disable *all* interrupts */
-      	MGA_WRITE( MGA_IEN, 0 );
+	MGA_WRITE(MGA_IEN, 0);
 	/* Clear bits if they're already high */
-   	MGA_WRITE( MGA_ICLEAR, ~0 );
+	MGA_WRITE(MGA_ICLEAR, ~0);
 }
 
-void mga_driver_irq_postinstall( drm_device_t *dev ) {
-  	drm_mga_private_t *dev_priv = 
-	   (drm_mga_private_t *)dev->dev_private;
+void mga_driver_irq_postinstall(drm_device_t * dev)
+{
+	drm_mga_private_t *dev_priv = (drm_mga_private_t *) dev->dev_private;
+
+	DRM_INIT_WAITQUEUE( &dev_priv->fence_queue );
 
-	/* Turn on VBL interrupt */
-   	MGA_WRITE( MGA_IEN, MGA_VLINEIEN );
+	/* Turn on vertical blank interrupt and soft trap interrupt. */
+	MGA_WRITE(MGA_IEN, MGA_VLINEIEN | MGA_SOFTRAPEN);
 }
 
-void mga_driver_irq_uninstall( drm_device_t *dev ) {
-  	drm_mga_private_t *dev_priv = 
-	   (drm_mga_private_t *)dev->dev_private;
+void mga_driver_irq_uninstall(drm_device_t * dev)
+{
+	drm_mga_private_t *dev_priv = (drm_mga_private_t *) dev->dev_private;
 	if (!dev_priv)
 		return;
 
 	/* Disable *all* interrupts */
-	MGA_WRITE( MGA_IEN, 0 );
+	MGA_WRITE(MGA_IEN, 0);
+	
+	dev->irq_enabled = 0;
 }
diff -purN linux-2.6.12.orig/drivers/char/drm/mga_state.c linux-2.6.12/drivers/char/drm/mga_state.c
--- linux-2.6.12.orig/drivers/char/drm/mga_state.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/mga_state.c	2005-07-05 08:37:47.000000000 +0200
@@ -41,121 +41,121 @@
  * DMA hardware state programming functions
  */
 
-static void mga_emit_clip_rect( drm_mga_private_t *dev_priv,
-				drm_clip_rect_t *box )
+static void mga_emit_clip_rect(drm_mga_private_t * dev_priv,
+			       drm_clip_rect_t * box)
 {
 	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
 	drm_mga_context_regs_t *ctx = &sarea_priv->context_state;
 	unsigned int pitch = dev_priv->front_pitch;
 	DMA_LOCALS;
 
-	BEGIN_DMA( 2 );
+	BEGIN_DMA(2);
 
 	/* Force reset of DWGCTL on G400 (eliminates clip disable bit).
 	 */
-	if ( dev_priv->chipset == MGA_CARD_TYPE_G400 ) {
-		DMA_BLOCK( MGA_DWGCTL,		ctx->dwgctl,
-			   MGA_LEN + MGA_EXEC,	0x80000000,
-			   MGA_DWGCTL,		ctx->dwgctl,
-			   MGA_LEN + MGA_EXEC,	0x80000000 );
-	}
-	DMA_BLOCK( MGA_DMAPAD,	0x00000000,
-		   MGA_CXBNDRY,	(box->x2 << 16) | box->x1,
-		   MGA_YTOP,	box->y1 * pitch,
-		   MGA_YBOT,	box->y2 * pitch );
+	if (dev_priv->chipset == MGA_CARD_TYPE_G400) {
+		DMA_BLOCK(MGA_DWGCTL, ctx->dwgctl,
+			  MGA_LEN + MGA_EXEC, 0x80000000,
+			  MGA_DWGCTL, ctx->dwgctl,
+			  MGA_LEN + MGA_EXEC, 0x80000000);
+	}
+	DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+		  MGA_CXBNDRY, ((box->x2 - 1) << 16) | box->x1,
+		  MGA_YTOP, box->y1 * pitch,
+		  MGA_YBOT, (box->y2 - 1) * pitch);
 
 	ADVANCE_DMA();
 }
 
-static __inline__ void mga_g200_emit_context( drm_mga_private_t *dev_priv )
+static __inline__ void mga_g200_emit_context(drm_mga_private_t * dev_priv)
 {
 	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
 	drm_mga_context_regs_t *ctx = &sarea_priv->context_state;
 	DMA_LOCALS;
 
-	BEGIN_DMA( 3 );
+	BEGIN_DMA(3);
 
-	DMA_BLOCK( MGA_DSTORG,		ctx->dstorg,
-		   MGA_MACCESS,		ctx->maccess,
-		   MGA_PLNWT,		ctx->plnwt,
-		   MGA_DWGCTL,		ctx->dwgctl );
-
-	DMA_BLOCK( MGA_ALPHACTRL,	ctx->alphactrl,
-		   MGA_FOGCOL,		ctx->fogcolor,
-		   MGA_WFLAG,		ctx->wflag,
-		   MGA_ZORG,		dev_priv->depth_offset );
-
-	DMA_BLOCK( MGA_FCOL,		ctx->fcol,
-		   MGA_DMAPAD,		0x00000000,
-		   MGA_DMAPAD,		0x00000000,
-		   MGA_DMAPAD,		0x00000000 );
+	DMA_BLOCK(MGA_DSTORG, ctx->dstorg,
+		  MGA_MACCESS, ctx->maccess,
+		  MGA_PLNWT, ctx->plnwt,
+		  MGA_DWGCTL, ctx->dwgctl);
+
+	DMA_BLOCK(MGA_ALPHACTRL, ctx->alphactrl,
+		  MGA_FOGCOL, ctx->fogcolor,
+		  MGA_WFLAG, ctx->wflag,
+		  MGA_ZORG, dev_priv->depth_offset);
+
+	DMA_BLOCK(MGA_FCOL, ctx->fcol,
+		  MGA_DMAPAD, 0x00000000,
+		  MGA_DMAPAD, 0x00000000,
+		  MGA_DMAPAD, 0x00000000);
 
 	ADVANCE_DMA();
 }
 
-static __inline__ void mga_g400_emit_context( drm_mga_private_t *dev_priv )
+static __inline__ void mga_g400_emit_context(drm_mga_private_t * dev_priv)
 {
 	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
 	drm_mga_context_regs_t *ctx = &sarea_priv->context_state;
 	DMA_LOCALS;
 
-	BEGIN_DMA( 4 );
+	BEGIN_DMA(4);
 
-	DMA_BLOCK( MGA_DSTORG,		ctx->dstorg,
-		   MGA_MACCESS,		ctx->maccess,
-		   MGA_PLNWT,		ctx->plnwt,
-		   MGA_DWGCTL,		ctx->dwgctl );
-
-	DMA_BLOCK( MGA_ALPHACTRL,	ctx->alphactrl,
-		   MGA_FOGCOL,		ctx->fogcolor,
-		   MGA_WFLAG,		ctx->wflag,
-		   MGA_ZORG,		dev_priv->depth_offset );
-
-	DMA_BLOCK( MGA_WFLAG1,		ctx->wflag,
-		   MGA_TDUALSTAGE0,	ctx->tdualstage0,
-		   MGA_TDUALSTAGE1,	ctx->tdualstage1,
-		   MGA_FCOL,		ctx->fcol );
-
-	DMA_BLOCK( MGA_STENCIL,		ctx->stencil,
-		   MGA_STENCILCTL,	ctx->stencilctl,
-		   MGA_DMAPAD,		0x00000000,
-		   MGA_DMAPAD,		0x00000000 );
+	DMA_BLOCK(MGA_DSTORG, ctx->dstorg,
+		  MGA_MACCESS, ctx->maccess,
+		  MGA_PLNWT, ctx->plnwt,
+		  MGA_DWGCTL, ctx->dwgctl);
+
+	DMA_BLOCK(MGA_ALPHACTRL, ctx->alphactrl,
+		  MGA_FOGCOL, ctx->fogcolor,
+		  MGA_WFLAG, ctx->wflag,
+		  MGA_ZORG, dev_priv->depth_offset);
+
+	DMA_BLOCK(MGA_WFLAG1, ctx->wflag,
+		  MGA_TDUALSTAGE0, ctx->tdualstage0,
+		  MGA_TDUALSTAGE1, ctx->tdualstage1,
+		  MGA_FCOL, ctx->fcol);
+
+	DMA_BLOCK(MGA_STENCIL, ctx->stencil,
+		  MGA_STENCILCTL, ctx->stencilctl,
+		  MGA_DMAPAD, 0x00000000,
+		  MGA_DMAPAD, 0x00000000);
 
 	ADVANCE_DMA();
 }
 
-static __inline__ void mga_g200_emit_tex0( drm_mga_private_t *dev_priv )
+static __inline__ void mga_g200_emit_tex0(drm_mga_private_t * dev_priv)
 {
 	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
 	drm_mga_texture_regs_t *tex = &sarea_priv->tex_state[0];
 	DMA_LOCALS;
 
-	BEGIN_DMA( 4 );
+	BEGIN_DMA(4);
 
-	DMA_BLOCK( MGA_TEXCTL2,		tex->texctl2,
-		   MGA_TEXCTL,		tex->texctl,
-		   MGA_TEXFILTER,	tex->texfilter,
-		   MGA_TEXBORDERCOL,	tex->texbordercol );
-
-	DMA_BLOCK( MGA_TEXORG,		tex->texorg,
-		   MGA_TEXORG1,		tex->texorg1,
-		   MGA_TEXORG2,		tex->texorg2,
-		   MGA_TEXORG3,		tex->texorg3 );
-
-	DMA_BLOCK( MGA_TEXORG4,		tex->texorg4,
-		   MGA_TEXWIDTH,	tex->texwidth,
-		   MGA_TEXHEIGHT,	tex->texheight,
-		   MGA_WR24,		tex->texwidth );
-
-	DMA_BLOCK( MGA_WR34,		tex->texheight,
-		   MGA_TEXTRANS,	0x0000ffff,
-		   MGA_TEXTRANSHIGH,	0x0000ffff,
-		   MGA_DMAPAD,		0x00000000 );
+	DMA_BLOCK(MGA_TEXCTL2, tex->texctl2,
+		  MGA_TEXCTL, tex->texctl,
+		  MGA_TEXFILTER, tex->texfilter,
+		  MGA_TEXBORDERCOL, tex->texbordercol);
+
+	DMA_BLOCK(MGA_TEXORG, tex->texorg,
+		  MGA_TEXORG1, tex->texorg1,
+		  MGA_TEXORG2, tex->texorg2,
+		  MGA_TEXORG3, tex->texorg3);
+
+	DMA_BLOCK(MGA_TEXORG4, tex->texorg4,
+		  MGA_TEXWIDTH, tex->texwidth,
+		  MGA_TEXHEIGHT, tex->texheight,
+		  MGA_WR24, tex->texwidth);
+
+	DMA_BLOCK(MGA_WR34, tex->texheight,
+		  MGA_TEXTRANS, 0x0000ffff,
+		  MGA_TEXTRANSHIGH, 0x0000ffff,
+		  MGA_DMAPAD, 0x00000000);
 
 	ADVANCE_DMA();
 }
 
-static __inline__ void mga_g400_emit_tex0( drm_mga_private_t *dev_priv )
+static __inline__ void mga_g400_emit_tex0(drm_mga_private_t * dev_priv)
 {
 	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
 	drm_mga_texture_regs_t *tex = &sarea_priv->tex_state[0];
@@ -164,42 +164,42 @@ static __inline__ void mga_g400_emit_tex
 /*  	printk("mga_g400_emit_tex0 %x %x %x\n", tex->texorg, */
 /*  	       tex->texctl, tex->texctl2); */
 
-	BEGIN_DMA( 6 );
+	BEGIN_DMA(6);
 
-	DMA_BLOCK( MGA_TEXCTL2,		tex->texctl2 | MGA_G400_TC2_MAGIC,
-		   MGA_TEXCTL,		tex->texctl,
-		   MGA_TEXFILTER,	tex->texfilter,
-		   MGA_TEXBORDERCOL,	tex->texbordercol );
-
-	DMA_BLOCK( MGA_TEXORG,		tex->texorg,
-		   MGA_TEXORG1,		tex->texorg1,
-		   MGA_TEXORG2,		tex->texorg2,
-		   MGA_TEXORG3,		tex->texorg3 );
-
-	DMA_BLOCK( MGA_TEXORG4,		tex->texorg4,
-		   MGA_TEXWIDTH,	tex->texwidth,
-		   MGA_TEXHEIGHT,	tex->texheight,
-		   MGA_WR49,		0x00000000 );
-
-	DMA_BLOCK( MGA_WR57,		0x00000000,
-		   MGA_WR53,		0x00000000,
-		   MGA_WR61,		0x00000000,
-		   MGA_WR52,		MGA_G400_WR_MAGIC );
-
-	DMA_BLOCK( MGA_WR60,		MGA_G400_WR_MAGIC,
-		   MGA_WR54,		tex->texwidth | MGA_G400_WR_MAGIC,
-		   MGA_WR62,		tex->texheight | MGA_G400_WR_MAGIC,
-		   MGA_DMAPAD,		0x00000000 );
-
-	DMA_BLOCK( MGA_DMAPAD,		0x00000000,
-		   MGA_DMAPAD,		0x00000000,
-		   MGA_TEXTRANS,	0x0000ffff,
-		   MGA_TEXTRANSHIGH,	0x0000ffff );
+	DMA_BLOCK(MGA_TEXCTL2, tex->texctl2 | MGA_G400_TC2_MAGIC,
+		  MGA_TEXCTL, tex->texctl,
+		  MGA_TEXFILTER, tex->texfilter,
+		  MGA_TEXBORDERCOL, tex->texbordercol);
+
+	DMA_BLOCK(MGA_TEXORG, tex->texorg,
+		  MGA_TEXORG1, tex->texorg1,
+		  MGA_TEXORG2, tex->texorg2,
+		  MGA_TEXORG3, tex->texorg3);
+
+	DMA_BLOCK(MGA_TEXORG4, tex->texorg4,
+		  MGA_TEXWIDTH, tex->texwidth,
+		  MGA_TEXHEIGHT, tex->texheight,
+		  MGA_WR49, 0x00000000);
+
+	DMA_BLOCK(MGA_WR57, 0x00000000,
+		  MGA_WR53, 0x00000000,
+		  MGA_WR61, 0x00000000,
+		  MGA_WR52, MGA_G400_WR_MAGIC);
+
+	DMA_BLOCK(MGA_WR60, MGA_G400_WR_MAGIC,
+		  MGA_WR54, tex->texwidth | MGA_G400_WR_MAGIC,
+		  MGA_WR62, tex->texheight | MGA_G400_WR_MAGIC,
+		  MGA_DMAPAD, 0x00000000);
+
+	DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+		  MGA_DMAPAD, 0x00000000,
+		  MGA_TEXTRANS, 0x0000ffff,
+		  MGA_TEXTRANSHIGH, 0x0000ffff);
 
 	ADVANCE_DMA();
 }
 
-static __inline__ void mga_g400_emit_tex1( drm_mga_private_t *dev_priv )
+static __inline__ void mga_g400_emit_tex1(drm_mga_private_t * dev_priv)
 {
 	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
 	drm_mga_texture_regs_t *tex = &sarea_priv->tex_state[1];
@@ -208,69 +208,68 @@ static __inline__ void mga_g400_emit_tex
 /*  	printk("mga_g400_emit_tex1 %x %x %x\n", tex->texorg,  */
 /*  	       tex->texctl, tex->texctl2); */
 
-	BEGIN_DMA( 5 );
+	BEGIN_DMA(5);
 
-	DMA_BLOCK( MGA_TEXCTL2,		(tex->texctl2 |
-					 MGA_MAP1_ENABLE |
-					 MGA_G400_TC2_MAGIC),
-		   MGA_TEXCTL,		tex->texctl,
-		   MGA_TEXFILTER,	tex->texfilter,
-		   MGA_TEXBORDERCOL,	tex->texbordercol );
-
-	DMA_BLOCK( MGA_TEXORG,		tex->texorg,
-		   MGA_TEXORG1,		tex->texorg1,
-		   MGA_TEXORG2,		tex->texorg2,
-		   MGA_TEXORG3,		tex->texorg3 );
-
-	DMA_BLOCK( MGA_TEXORG4,		tex->texorg4,
-		   MGA_TEXWIDTH,	tex->texwidth,
-		   MGA_TEXHEIGHT,	tex->texheight,
-		   MGA_WR49,		0x00000000 );
-
-	DMA_BLOCK( MGA_WR57,		0x00000000,
-		   MGA_WR53,		0x00000000,
-		   MGA_WR61,		0x00000000,
-		   MGA_WR52,		tex->texwidth | MGA_G400_WR_MAGIC );
-
-	DMA_BLOCK( MGA_WR60,		tex->texheight | MGA_G400_WR_MAGIC,
-		   MGA_TEXTRANS,	0x0000ffff,
-		   MGA_TEXTRANSHIGH,	0x0000ffff,
-		   MGA_TEXCTL2,		tex->texctl2 | MGA_G400_TC2_MAGIC );
+	DMA_BLOCK(MGA_TEXCTL2, (tex->texctl2 |
+				MGA_MAP1_ENABLE |
+				MGA_G400_TC2_MAGIC),
+		  MGA_TEXCTL, tex->texctl,
+		  MGA_TEXFILTER, tex->texfilter,
+		  MGA_TEXBORDERCOL, tex->texbordercol);
+
+	DMA_BLOCK(MGA_TEXORG, tex->texorg,
+		  MGA_TEXORG1, tex->texorg1,
+		  MGA_TEXORG2, tex->texorg2,
+		  MGA_TEXORG3, tex->texorg3);
+
+	DMA_BLOCK(MGA_TEXORG4, tex->texorg4,
+		  MGA_TEXWIDTH, tex->texwidth,
+		  MGA_TEXHEIGHT, tex->texheight,
+		  MGA_WR49, 0x00000000);
+
+	DMA_BLOCK(MGA_WR57, 0x00000000,
+		  MGA_WR53, 0x00000000,
+		  MGA_WR61, 0x00000000,
+		  MGA_WR52, tex->texwidth | MGA_G400_WR_MAGIC);
+
+	DMA_BLOCK(MGA_WR60, tex->texheight | MGA_G400_WR_MAGIC,
+		  MGA_TEXTRANS, 0x0000ffff,
+		  MGA_TEXTRANSHIGH, 0x0000ffff,
+		  MGA_TEXCTL2, tex->texctl2 | MGA_G400_TC2_MAGIC);
 
 	ADVANCE_DMA();
 }
 
-static __inline__ void mga_g200_emit_pipe( drm_mga_private_t *dev_priv )
+static __inline__ void mga_g200_emit_pipe(drm_mga_private_t * dev_priv)
 {
 	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
 	unsigned int pipe = sarea_priv->warp_pipe;
 	DMA_LOCALS;
 
-	BEGIN_DMA( 3 );
+	BEGIN_DMA(3);
 
-	DMA_BLOCK( MGA_WIADDR,	MGA_WMODE_SUSPEND,
-		   MGA_WVRTXSZ,	0x00000007,
-		   MGA_WFLAG,	0x00000000,
-		   MGA_WR24,	0x00000000 );
-
-	DMA_BLOCK( MGA_WR25,	0x00000100,
-		   MGA_WR34,	0x00000000,
-		   MGA_WR42,	0x0000ffff,
-		   MGA_WR60,	0x0000ffff );
+	DMA_BLOCK(MGA_WIADDR, MGA_WMODE_SUSPEND,
+		  MGA_WVRTXSZ, 0x00000007,
+		  MGA_WFLAG, 0x00000000,
+		  MGA_WR24, 0x00000000);
+
+	DMA_BLOCK(MGA_WR25, 0x00000100,
+		  MGA_WR34, 0x00000000,
+		  MGA_WR42, 0x0000ffff,
+		  MGA_WR60, 0x0000ffff);
 
 	/* Padding required to to hardware bug.
 	 */
-	DMA_BLOCK( MGA_DMAPAD,	0xffffffff,
-		   MGA_DMAPAD,	0xffffffff,
-		   MGA_DMAPAD,	0xffffffff,
-		   MGA_WIADDR,	(dev_priv->warp_pipe_phys[pipe] |
-				 MGA_WMODE_START |
-				 MGA_WAGP_ENABLE) );
+	DMA_BLOCK(MGA_DMAPAD, 0xffffffff,
+		  MGA_DMAPAD, 0xffffffff,
+		  MGA_DMAPAD, 0xffffffff,
+		  MGA_WIADDR, (dev_priv->warp_pipe_phys[pipe] |
+			       MGA_WMODE_START | dev_priv->wagp_enable));
 
 	ADVANCE_DMA();
 }
 
-static __inline__ void mga_g400_emit_pipe( drm_mga_private_t *dev_priv )
+static __inline__ void mga_g400_emit_pipe(drm_mga_private_t * dev_priv)
 {
 	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
 	unsigned int pipe = sarea_priv->warp_pipe;
@@ -278,145 +277,143 @@ static __inline__ void mga_g400_emit_pip
 
 /*  	printk("mga_g400_emit_pipe %x\n", pipe); */
 
-	BEGIN_DMA( 10 );
+	BEGIN_DMA(10);
 
-	DMA_BLOCK( MGA_WIADDR2,	MGA_WMODE_SUSPEND,
-		   MGA_DMAPAD,	0x00000000,
-		   MGA_DMAPAD,	0x00000000,
-		   MGA_DMAPAD,	0x00000000 );
-
-	if ( pipe & MGA_T2 ) {
-		DMA_BLOCK( MGA_WVRTXSZ,		0x00001e09,
-			   MGA_DMAPAD,		0x00000000,
-			   MGA_DMAPAD,		0x00000000,
-			   MGA_DMAPAD,		0x00000000 );
-
-		DMA_BLOCK( MGA_WACCEPTSEQ,	0x00000000,
-			   MGA_WACCEPTSEQ,	0x00000000,
-			   MGA_WACCEPTSEQ,	0x00000000,
-			   MGA_WACCEPTSEQ,	0x1e000000 );
+	DMA_BLOCK(MGA_WIADDR2, MGA_WMODE_SUSPEND,
+		  MGA_DMAPAD, 0x00000000,
+		  MGA_DMAPAD, 0x00000000,
+		  MGA_DMAPAD, 0x00000000);
+
+	if (pipe & MGA_T2) {
+		DMA_BLOCK(MGA_WVRTXSZ, 0x00001e09,
+			  MGA_DMAPAD, 0x00000000,
+			  MGA_DMAPAD, 0x00000000,
+			  MGA_DMAPAD, 0x00000000);
+
+		DMA_BLOCK(MGA_WACCEPTSEQ, 0x00000000,
+			  MGA_WACCEPTSEQ, 0x00000000,
+			  MGA_WACCEPTSEQ, 0x00000000,
+			  MGA_WACCEPTSEQ, 0x1e000000);
 	} else {
-		if ( dev_priv->warp_pipe & MGA_T2 ) {
+		if (dev_priv->warp_pipe & MGA_T2) {
 			/* Flush the WARP pipe */
-			DMA_BLOCK( MGA_YDST,		0x00000000,
-				   MGA_FXLEFT,		0x00000000,
-				   MGA_FXRIGHT,		0x00000001,
-				   MGA_DWGCTL,		MGA_DWGCTL_FLUSH );
-
-			DMA_BLOCK( MGA_LEN + MGA_EXEC,	0x00000001,
-				   MGA_DWGSYNC,		0x00007000,
-				   MGA_TEXCTL2,		MGA_G400_TC2_MAGIC,
-				   MGA_LEN + MGA_EXEC,	0x00000000 );
-
-			DMA_BLOCK( MGA_TEXCTL2,		(MGA_DUALTEX |
-							 MGA_G400_TC2_MAGIC),
-				   MGA_LEN + MGA_EXEC,	0x00000000,
-				   MGA_TEXCTL2,		MGA_G400_TC2_MAGIC,
-				   MGA_DMAPAD,		0x00000000 );
+			DMA_BLOCK(MGA_YDST, 0x00000000,
+				  MGA_FXLEFT, 0x00000000,
+				  MGA_FXRIGHT, 0x00000001,
+				  MGA_DWGCTL, MGA_DWGCTL_FLUSH);
+
+			DMA_BLOCK(MGA_LEN + MGA_EXEC, 0x00000001,
+				  MGA_DWGSYNC, 0x00007000,
+				  MGA_TEXCTL2, MGA_G400_TC2_MAGIC,
+				  MGA_LEN + MGA_EXEC, 0x00000000);
+
+			DMA_BLOCK(MGA_TEXCTL2, (MGA_DUALTEX |
+						MGA_G400_TC2_MAGIC),
+				  MGA_LEN + MGA_EXEC, 0x00000000,
+				  MGA_TEXCTL2, MGA_G400_TC2_MAGIC,
+				  MGA_DMAPAD, 0x00000000);
 		}
 
-		DMA_BLOCK( MGA_WVRTXSZ,		0x00001807,
-			   MGA_DMAPAD,		0x00000000,
-			   MGA_DMAPAD,		0x00000000,
-			   MGA_DMAPAD,		0x00000000 );
-
-		DMA_BLOCK( MGA_WACCEPTSEQ,	0x00000000,
-			   MGA_WACCEPTSEQ,	0x00000000,
-			   MGA_WACCEPTSEQ,	0x00000000,
-			   MGA_WACCEPTSEQ,	0x18000000 );
-	}
-
-	DMA_BLOCK( MGA_WFLAG,	0x00000000,
-		   MGA_WFLAG1,	0x00000000,
-		   MGA_WR56,	MGA_G400_WR56_MAGIC,
-		   MGA_DMAPAD,	0x00000000 );
-
-	DMA_BLOCK( MGA_WR49,	0x00000000,		/* tex0              */
-		   MGA_WR57,	0x00000000,		/* tex0              */
-		   MGA_WR53,	0x00000000,		/* tex1              */
-		   MGA_WR61,	0x00000000 );		/* tex1              */
-
-	DMA_BLOCK( MGA_WR54,	MGA_G400_WR_MAGIC,	/* tex0 width        */
-		   MGA_WR62,	MGA_G400_WR_MAGIC,	/* tex0 height       */
-		   MGA_WR52,	MGA_G400_WR_MAGIC,	/* tex1 width        */
-		   MGA_WR60,	MGA_G400_WR_MAGIC );	/* tex1 height       */
+		DMA_BLOCK(MGA_WVRTXSZ, 0x00001807,
+			  MGA_DMAPAD, 0x00000000,
+			  MGA_DMAPAD, 0x00000000,
+			  MGA_DMAPAD, 0x00000000);
+
+		DMA_BLOCK(MGA_WACCEPTSEQ, 0x00000000,
+			  MGA_WACCEPTSEQ, 0x00000000,
+			  MGA_WACCEPTSEQ, 0x00000000,
+			  MGA_WACCEPTSEQ, 0x18000000);
+	}
+
+	DMA_BLOCK(MGA_WFLAG, 0x00000000,
+		  MGA_WFLAG1, 0x00000000,
+		  MGA_WR56, MGA_G400_WR56_MAGIC,
+		  MGA_DMAPAD, 0x00000000);
+
+	DMA_BLOCK(MGA_WR49, 0x00000000,	/* tex0              */
+		  MGA_WR57, 0x00000000,	/* tex0              */
+		  MGA_WR53, 0x00000000,	/* tex1              */
+		  MGA_WR61, 0x00000000);	/* tex1              */
+
+	DMA_BLOCK(MGA_WR54, MGA_G400_WR_MAGIC,	/* tex0 width        */
+		  MGA_WR62, MGA_G400_WR_MAGIC,	/* tex0 height       */
+		  MGA_WR52, MGA_G400_WR_MAGIC,	/* tex1 width        */
+		  MGA_WR60, MGA_G400_WR_MAGIC);	/* tex1 height       */
 
 	/* Padding required to to hardware bug */
-	DMA_BLOCK( MGA_DMAPAD,	0xffffffff,
-		   MGA_DMAPAD,	0xffffffff,
-		   MGA_DMAPAD,	0xffffffff,
-		   MGA_WIADDR2,	(dev_priv->warp_pipe_phys[pipe] |
-				 MGA_WMODE_START |
-				 MGA_WAGP_ENABLE) );
+	DMA_BLOCK(MGA_DMAPAD, 0xffffffff,
+		  MGA_DMAPAD, 0xffffffff,
+		  MGA_DMAPAD, 0xffffffff,
+		  MGA_WIADDR2, (dev_priv->warp_pipe_phys[pipe] |
+				MGA_WMODE_START | dev_priv->wagp_enable));
 
 	ADVANCE_DMA();
 }
 
-static void mga_g200_emit_state( drm_mga_private_t *dev_priv )
+static void mga_g200_emit_state(drm_mga_private_t * dev_priv)
 {
 	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
 	unsigned int dirty = sarea_priv->dirty;
 
-	if ( sarea_priv->warp_pipe != dev_priv->warp_pipe ) {
-		mga_g200_emit_pipe( dev_priv );
+	if (sarea_priv->warp_pipe != dev_priv->warp_pipe) {
+		mga_g200_emit_pipe(dev_priv);
 		dev_priv->warp_pipe = sarea_priv->warp_pipe;
 	}
 
-	if ( dirty & MGA_UPLOAD_CONTEXT ) {
-		mga_g200_emit_context( dev_priv );
+	if (dirty & MGA_UPLOAD_CONTEXT) {
+		mga_g200_emit_context(dev_priv);
 		sarea_priv->dirty &= ~MGA_UPLOAD_CONTEXT;
 	}
 
-	if ( dirty & MGA_UPLOAD_TEX0 ) {
-		mga_g200_emit_tex0( dev_priv );
+	if (dirty & MGA_UPLOAD_TEX0) {
+		mga_g200_emit_tex0(dev_priv);
 		sarea_priv->dirty &= ~MGA_UPLOAD_TEX0;
 	}
 }
 
-static void mga_g400_emit_state( drm_mga_private_t *dev_priv )
+static void mga_g400_emit_state(drm_mga_private_t * dev_priv)
 {
 	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
 	unsigned int dirty = sarea_priv->dirty;
 	int multitex = sarea_priv->warp_pipe & MGA_T2;
 
-	if ( sarea_priv->warp_pipe != dev_priv->warp_pipe ) {
-		mga_g400_emit_pipe( dev_priv );
+	if (sarea_priv->warp_pipe != dev_priv->warp_pipe) {
+		mga_g400_emit_pipe(dev_priv);
 		dev_priv->warp_pipe = sarea_priv->warp_pipe;
 	}
 
-	if ( dirty & MGA_UPLOAD_CONTEXT ) {
-		mga_g400_emit_context( dev_priv );
+	if (dirty & MGA_UPLOAD_CONTEXT) {
+		mga_g400_emit_context(dev_priv);
 		sarea_priv->dirty &= ~MGA_UPLOAD_CONTEXT;
 	}
 
-	if ( dirty & MGA_UPLOAD_TEX0 ) {
-		mga_g400_emit_tex0( dev_priv );
+	if (dirty & MGA_UPLOAD_TEX0) {
+		mga_g400_emit_tex0(dev_priv);
 		sarea_priv->dirty &= ~MGA_UPLOAD_TEX0;
 	}
 
-	if ( (dirty & MGA_UPLOAD_TEX1) && multitex ) {
-		mga_g400_emit_tex1( dev_priv );
+	if ((dirty & MGA_UPLOAD_TEX1) && multitex) {
+		mga_g400_emit_tex1(dev_priv);
 		sarea_priv->dirty &= ~MGA_UPLOAD_TEX1;
 	}
 }
 
-
 /* ================================================================
  * SAREA state verification
  */
 
 /* Disallow all write destinations except the front and backbuffer.
  */
-static int mga_verify_context( drm_mga_private_t *dev_priv )
+static int mga_verify_context(drm_mga_private_t * dev_priv)
 {
 	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
 	drm_mga_context_regs_t *ctx = &sarea_priv->context_state;
 
-	if ( ctx->dstorg != dev_priv->front_offset &&
-	     ctx->dstorg != dev_priv->back_offset ) {
-		DRM_ERROR( "*** bad DSTORG: %x (front %x, back %x)\n\n",
-			   ctx->dstorg, dev_priv->front_offset,
-			   dev_priv->back_offset );
+	if (ctx->dstorg != dev_priv->front_offset &&
+	    ctx->dstorg != dev_priv->back_offset) {
+		DRM_ERROR("*** bad DSTORG: %x (front %x, back %x)\n\n",
+			  ctx->dstorg, dev_priv->front_offset,
+			  dev_priv->back_offset);
 		ctx->dstorg = 0;
 		return DRM_ERR(EINVAL);
 	}
@@ -426,7 +423,7 @@ static int mga_verify_context( drm_mga_p
 
 /* Disallow texture reads from PCI space.
  */
-static int mga_verify_tex( drm_mga_private_t *dev_priv, int unit )
+static int mga_verify_tex(drm_mga_private_t * dev_priv, int unit)
 {
 	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
 	drm_mga_texture_regs_t *tex = &sarea_priv->tex_state[unit];
@@ -434,9 +431,8 @@ static int mga_verify_tex( drm_mga_priva
 
 	org = tex->texorg & (MGA_TEXORGMAP_MASK | MGA_TEXORGACC_MASK);
 
-	if ( org == (MGA_TEXORGMAP_SYSMEM | MGA_TEXORGACC_PCI) ) {
-		DRM_ERROR( "*** bad TEXORG: 0x%x, unit %d\n",
-			   tex->texorg, unit );
+	if (org == (MGA_TEXORGMAP_SYSMEM | MGA_TEXORGACC_PCI)) {
+		DRM_ERROR("*** bad TEXORG: 0x%x, unit %d\n", tex->texorg, unit);
 		tex->texorg = 0;
 		return DRM_ERR(EINVAL);
 	}
@@ -444,73 +440,70 @@ static int mga_verify_tex( drm_mga_priva
 	return 0;
 }
 
-static int mga_verify_state( drm_mga_private_t *dev_priv )
+static int mga_verify_state(drm_mga_private_t * dev_priv)
 {
 	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
 	unsigned int dirty = sarea_priv->dirty;
 	int ret = 0;
 
-	if ( sarea_priv->nbox > MGA_NR_SAREA_CLIPRECTS )
+	if (sarea_priv->nbox > MGA_NR_SAREA_CLIPRECTS)
 		sarea_priv->nbox = MGA_NR_SAREA_CLIPRECTS;
 
-	if ( dirty & MGA_UPLOAD_CONTEXT )
-		ret |= mga_verify_context( dev_priv );
+	if (dirty & MGA_UPLOAD_CONTEXT)
+		ret |= mga_verify_context(dev_priv);
 
-	if ( dirty & MGA_UPLOAD_TEX0 )
-		ret |= mga_verify_tex( dev_priv, 0 );
+	if (dirty & MGA_UPLOAD_TEX0)
+		ret |= mga_verify_tex(dev_priv, 0);
 
-	if ( dev_priv->chipset == MGA_CARD_TYPE_G400 ) {
-		if ( dirty & MGA_UPLOAD_TEX1 )
-			ret |= mga_verify_tex( dev_priv, 1 );
+	if (dev_priv->chipset >= MGA_CARD_TYPE_G400) {
+		if (dirty & MGA_UPLOAD_TEX1)
+			ret |= mga_verify_tex(dev_priv, 1);
 
-		if ( dirty & MGA_UPLOAD_PIPE )
-			ret |= ( sarea_priv->warp_pipe > MGA_MAX_G400_PIPES );
+		if (dirty & MGA_UPLOAD_PIPE)
+			ret |= (sarea_priv->warp_pipe > MGA_MAX_G400_PIPES);
 	} else {
-		if ( dirty & MGA_UPLOAD_PIPE )
-			ret |= ( sarea_priv->warp_pipe > MGA_MAX_G200_PIPES );
+		if (dirty & MGA_UPLOAD_PIPE)
+			ret |= (sarea_priv->warp_pipe > MGA_MAX_G200_PIPES);
 	}
 
-	return ( ret == 0 );
+	return (ret == 0);
 }
 
-static int mga_verify_iload( drm_mga_private_t *dev_priv,
-			     unsigned int dstorg, unsigned int length )
+static int mga_verify_iload(drm_mga_private_t * dev_priv,
+			    unsigned int dstorg, unsigned int length)
 {
-	if ( dstorg < dev_priv->texture_offset ||
-	     dstorg + length > (dev_priv->texture_offset +
-				dev_priv->texture_size) ) {
-		DRM_ERROR( "*** bad iload DSTORG: 0x%x\n", dstorg );
+	if (dstorg < dev_priv->texture_offset ||
+	    dstorg + length > (dev_priv->texture_offset +
+			       dev_priv->texture_size)) {
+		DRM_ERROR("*** bad iload DSTORG: 0x%x\n", dstorg);
 		return DRM_ERR(EINVAL);
 	}
 
-	if ( length & MGA_ILOAD_MASK ) {
-		DRM_ERROR( "*** bad iload length: 0x%x\n",
-			   length & MGA_ILOAD_MASK );
+	if (length & MGA_ILOAD_MASK) {
+		DRM_ERROR("*** bad iload length: 0x%x\n",
+			  length & MGA_ILOAD_MASK);
 		return DRM_ERR(EINVAL);
 	}
 
 	return 0;
 }
 
-static int mga_verify_blit( drm_mga_private_t *dev_priv,
-			    unsigned int srcorg, unsigned int dstorg )
+static int mga_verify_blit(drm_mga_private_t * dev_priv,
+			   unsigned int srcorg, unsigned int dstorg)
 {
-	if ( (srcorg & 0x3) == (MGA_SRCACC_PCI | MGA_SRCMAP_SYSMEM) ||
-	     (dstorg & 0x3) == (MGA_SRCACC_PCI | MGA_SRCMAP_SYSMEM) ) {
-		DRM_ERROR( "*** bad blit: src=0x%x dst=0x%x\n",
-			   srcorg, dstorg );
+	if ((srcorg & 0x3) == (MGA_SRCACC_PCI | MGA_SRCMAP_SYSMEM) ||
+	    (dstorg & 0x3) == (MGA_SRCACC_PCI | MGA_SRCMAP_SYSMEM)) {
+		DRM_ERROR("*** bad blit: src=0x%x dst=0x%x\n", srcorg, dstorg);
 		return DRM_ERR(EINVAL);
 	}
 	return 0;
 }
 
-
 /* ================================================================
  *
  */
 
-static void mga_dma_dispatch_clear( drm_device_t *dev,
-				    drm_mga_clear_t *clear )
+static void mga_dma_dispatch_clear(drm_device_t * dev, drm_mga_clear_t * clear)
 {
 	drm_mga_private_t *dev_priv = dev->dev_private;
 	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
@@ -519,92 +512,88 @@ static void mga_dma_dispatch_clear( drm_
 	int nbox = sarea_priv->nbox;
 	int i;
 	DMA_LOCALS;
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
-	BEGIN_DMA( 1 );
+	BEGIN_DMA(1);
 
-	DMA_BLOCK( MGA_DMAPAD,	0x00000000,
-		   MGA_DMAPAD,	0x00000000,
-		   MGA_DWGSYNC,	0x00007100,
-		   MGA_DWGSYNC,	0x00007000 );
+	DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+		  MGA_DMAPAD, 0x00000000,
+		  MGA_DWGSYNC, 0x00007100,
+		  MGA_DWGSYNC, 0x00007000);
 
 	ADVANCE_DMA();
 
-	for ( i = 0 ; i < nbox ; i++ ) {
+	for (i = 0; i < nbox; i++) {
 		drm_clip_rect_t *box = &pbox[i];
 		u32 height = box->y2 - box->y1;
 
-		DRM_DEBUG( "   from=%d,%d to=%d,%d\n",
-			   box->x1, box->y1, box->x2, box->y2 );
+		DRM_DEBUG("   from=%d,%d to=%d,%d\n",
+			  box->x1, box->y1, box->x2, box->y2);
 
-		if ( clear->flags & MGA_FRONT ) {
-			BEGIN_DMA( 2 );
+		if (clear->flags & MGA_FRONT) {
+			BEGIN_DMA(2);
 
-			DMA_BLOCK( MGA_DMAPAD,	0x00000000,
-				   MGA_PLNWT,	clear->color_mask,
-				   MGA_YDSTLEN, (box->y1 << 16) | height,
-				   MGA_FXBNDRY, (box->x2 << 16) | box->x1 );
-
-			DMA_BLOCK( MGA_DMAPAD,	0x00000000,
-				   MGA_FCOL,	clear->clear_color,
-				   MGA_DSTORG,	dev_priv->front_offset,
-				   MGA_DWGCTL + MGA_EXEC,
-						dev_priv->clear_cmd );
+			DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+				  MGA_PLNWT, clear->color_mask,
+				  MGA_YDSTLEN, (box->y1 << 16) | height,
+				  MGA_FXBNDRY, (box->x2 << 16) | box->x1);
+
+			DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+				  MGA_FCOL, clear->clear_color,
+				  MGA_DSTORG, dev_priv->front_offset,
+				  MGA_DWGCTL + MGA_EXEC, dev_priv->clear_cmd);
 
 			ADVANCE_DMA();
 		}
 
+		if (clear->flags & MGA_BACK) {
+			BEGIN_DMA(2);
 
-		if ( clear->flags & MGA_BACK ) {
-			BEGIN_DMA( 2 );
-
-			DMA_BLOCK( MGA_DMAPAD,	0x00000000,
-				   MGA_PLNWT,	clear->color_mask,
-				   MGA_YDSTLEN, (box->y1 << 16) | height,
-				   MGA_FXBNDRY, (box->x2 << 16) | box->x1 );
-
-			DMA_BLOCK( MGA_DMAPAD,	0x00000000,
-				   MGA_FCOL,	clear->clear_color,
-				   MGA_DSTORG,	dev_priv->back_offset,
-				   MGA_DWGCTL + MGA_EXEC,
-						dev_priv->clear_cmd );
+			DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+				  MGA_PLNWT, clear->color_mask,
+				  MGA_YDSTLEN, (box->y1 << 16) | height,
+				  MGA_FXBNDRY, (box->x2 << 16) | box->x1);
+
+			DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+				  MGA_FCOL, clear->clear_color,
+				  MGA_DSTORG, dev_priv->back_offset,
+				  MGA_DWGCTL + MGA_EXEC, dev_priv->clear_cmd);
 
 			ADVANCE_DMA();
 		}
 
-		if ( clear->flags & MGA_DEPTH ) {
-			BEGIN_DMA( 2 );
+		if (clear->flags & MGA_DEPTH) {
+			BEGIN_DMA(2);
 
-			DMA_BLOCK( MGA_DMAPAD,	0x00000000,
-				   MGA_PLNWT,	clear->depth_mask,
-				   MGA_YDSTLEN, (box->y1 << 16) | height,
-				   MGA_FXBNDRY, (box->x2 << 16) | box->x1 );
-
-			DMA_BLOCK( MGA_DMAPAD,	0x00000000,
-				   MGA_FCOL,	clear->clear_depth,
-				   MGA_DSTORG,	dev_priv->depth_offset,
-				   MGA_DWGCTL + MGA_EXEC,
-						dev_priv->clear_cmd );
+			DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+				  MGA_PLNWT, clear->depth_mask,
+				  MGA_YDSTLEN, (box->y1 << 16) | height,
+				  MGA_FXBNDRY, (box->x2 << 16) | box->x1);
+
+			DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+				  MGA_FCOL, clear->clear_depth,
+				  MGA_DSTORG, dev_priv->depth_offset,
+				  MGA_DWGCTL + MGA_EXEC, dev_priv->clear_cmd);
 
 			ADVANCE_DMA();
 		}
 
 	}
 
-	BEGIN_DMA( 1 );
+	BEGIN_DMA(1);
 
 	/* Force reset of DWGCTL */
-	DMA_BLOCK( MGA_DMAPAD,	0x00000000,
-		   MGA_DMAPAD,	0x00000000,
-		   MGA_PLNWT,	ctx->plnwt,
-		   MGA_DWGCTL,	ctx->dwgctl );
+	DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+		  MGA_DMAPAD, 0x00000000,
+		  MGA_PLNWT, ctx->plnwt,
+		  MGA_DWGCTL, ctx->dwgctl);
 
 	ADVANCE_DMA();
 
 	FLUSH_DMA();
 }
 
-static void mga_dma_dispatch_swap( drm_device_t *dev )
+static void mga_dma_dispatch_swap(drm_device_t * dev)
 {
 	drm_mga_private_t *dev_priv = dev->dev_private;
 	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
@@ -613,56 +602,55 @@ static void mga_dma_dispatch_swap( drm_d
 	int nbox = sarea_priv->nbox;
 	int i;
 	DMA_LOCALS;
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
 	sarea_priv->last_frame.head = dev_priv->prim.tail;
 	sarea_priv->last_frame.wrap = dev_priv->prim.last_wrap;
 
-	BEGIN_DMA( 4 + nbox );
+	BEGIN_DMA(4 + nbox);
 
-	DMA_BLOCK( MGA_DMAPAD,	0x00000000,
-		   MGA_DMAPAD,	0x00000000,
-		   MGA_DWGSYNC,	0x00007100,
-		   MGA_DWGSYNC,	0x00007000 );
-
-	DMA_BLOCK( MGA_DSTORG,	dev_priv->front_offset,
-		   MGA_MACCESS,	dev_priv->maccess,
-		   MGA_SRCORG,	dev_priv->back_offset,
-		   MGA_AR5,	dev_priv->front_pitch );
-
-	DMA_BLOCK( MGA_DMAPAD,	0x00000000,
-		   MGA_DMAPAD,	0x00000000,
-		   MGA_PLNWT,	0xffffffff,
-		   MGA_DWGCTL,	MGA_DWGCTL_COPY );
+	DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+		  MGA_DMAPAD, 0x00000000,
+		  MGA_DWGSYNC, 0x00007100,
+		  MGA_DWGSYNC, 0x00007000);
+
+	DMA_BLOCK(MGA_DSTORG, dev_priv->front_offset,
+		  MGA_MACCESS, dev_priv->maccess,
+		  MGA_SRCORG, dev_priv->back_offset,
+		  MGA_AR5, dev_priv->front_pitch);
+
+	DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+		  MGA_DMAPAD, 0x00000000,
+		  MGA_PLNWT, 0xffffffff,
+		  MGA_DWGCTL, MGA_DWGCTL_COPY);
 
-	for ( i = 0 ; i < nbox ; i++ ) {
+	for (i = 0; i < nbox; i++) {
 		drm_clip_rect_t *box = &pbox[i];
 		u32 height = box->y2 - box->y1;
 		u32 start = box->y1 * dev_priv->front_pitch;
 
-		DRM_DEBUG( "   from=%d,%d to=%d,%d\n",
-			   box->x1, box->y1, box->x2, box->y2 );
+		DRM_DEBUG("   from=%d,%d to=%d,%d\n",
+			  box->x1, box->y1, box->x2, box->y2);
 
-		DMA_BLOCK( MGA_AR0,	start + box->x2 - 1,
-			   MGA_AR3,	start + box->x1,
-			   MGA_FXBNDRY,	((box->x2 - 1) << 16) | box->x1,
-			   MGA_YDSTLEN + MGA_EXEC,
-					(box->y1 << 16) | height );
+		DMA_BLOCK(MGA_AR0, start + box->x2 - 1,
+			  MGA_AR3, start + box->x1,
+			  MGA_FXBNDRY, ((box->x2 - 1) << 16) | box->x1,
+			  MGA_YDSTLEN + MGA_EXEC, (box->y1 << 16) | height);
 	}
 
-	DMA_BLOCK( MGA_DMAPAD,	0x00000000,
-		   MGA_PLNWT,	ctx->plnwt,
-		   MGA_SRCORG,	dev_priv->front_offset,
-		   MGA_DWGCTL,	ctx->dwgctl );
+	DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+		  MGA_PLNWT, ctx->plnwt,
+		  MGA_SRCORG, dev_priv->front_offset,
+		  MGA_DWGCTL, ctx->dwgctl);
 
 	ADVANCE_DMA();
 
 	FLUSH_DMA();
 
-	DRM_DEBUG( "%s... done.\n", __FUNCTION__ );
+	DRM_DEBUG("%s... done.\n", __FUNCTION__);
 }
 
-static void mga_dma_dispatch_vertex( drm_device_t *dev, drm_buf_t *buf )
+static void mga_dma_dispatch_vertex(drm_device_t * dev, drm_buf_t * buf)
 {
 	drm_mga_private_t *dev_priv = dev->dev_private;
 	drm_mga_buf_priv_t *buf_priv = buf->dev_private;
@@ -671,46 +659,46 @@ static void mga_dma_dispatch_vertex( drm
 	u32 length = (u32) buf->used;
 	int i = 0;
 	DMA_LOCALS;
-	DRM_DEBUG( "vertex: buf=%d used=%d\n", buf->idx, buf->used );
+	DRM_DEBUG("vertex: buf=%d used=%d\n", buf->idx, buf->used);
 
-	if ( buf->used ) {
+	if (buf->used) {
 		buf_priv->dispatched = 1;
 
-		MGA_EMIT_STATE( dev_priv, sarea_priv->dirty );
+		MGA_EMIT_STATE(dev_priv, sarea_priv->dirty);
 
 		do {
-			if ( i < sarea_priv->nbox ) {
-				mga_emit_clip_rect( dev_priv,
-						    &sarea_priv->boxes[i] );
+			if (i < sarea_priv->nbox) {
+				mga_emit_clip_rect(dev_priv,
+						   &sarea_priv->boxes[i]);
 			}
 
-			BEGIN_DMA( 1 );
+			BEGIN_DMA(1);
 
-			DMA_BLOCK( MGA_DMAPAD,		0x00000000,
-				   MGA_DMAPAD,		0x00000000,
-				   MGA_SECADDRESS,	(address |
-							 MGA_DMA_VERTEX),
-				   MGA_SECEND,		((address + length) |
-							 MGA_PAGPXFER) );
+			DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+				  MGA_DMAPAD, 0x00000000,
+				  MGA_SECADDRESS, (address |
+						   MGA_DMA_VERTEX),
+				  MGA_SECEND, ((address + length) |
+					       dev_priv->dma_access));
 
 			ADVANCE_DMA();
-		} while ( ++i < sarea_priv->nbox );
+		} while (++i < sarea_priv->nbox);
 	}
 
-	if ( buf_priv->discard ) {
-		AGE_BUFFER( buf_priv );
+	if (buf_priv->discard) {
+		AGE_BUFFER(buf_priv);
 		buf->pending = 0;
 		buf->used = 0;
 		buf_priv->dispatched = 0;
 
-		mga_freelist_put( dev, buf );
+		mga_freelist_put(dev, buf);
 	}
 
 	FLUSH_DMA();
 }
 
-static void mga_dma_dispatch_indices( drm_device_t *dev, drm_buf_t *buf,
-				      unsigned int start, unsigned int end )
+static void mga_dma_dispatch_indices(drm_device_t * dev, drm_buf_t * buf,
+				     unsigned int start, unsigned int end)
 {
 	drm_mga_private_t *dev_priv = dev->dev_private;
 	drm_mga_buf_priv_t *buf_priv = buf->dev_private;
@@ -718,38 +706,38 @@ static void mga_dma_dispatch_indices( dr
 	u32 address = (u32) buf->bus_address;
 	int i = 0;
 	DMA_LOCALS;
-	DRM_DEBUG( "indices: buf=%d start=%d end=%d\n", buf->idx, start, end );
+	DRM_DEBUG("indices: buf=%d start=%d end=%d\n", buf->idx, start, end);
 
-	if ( start != end ) {
+	if (start != end) {
 		buf_priv->dispatched = 1;
 
-		MGA_EMIT_STATE( dev_priv, sarea_priv->dirty );
+		MGA_EMIT_STATE(dev_priv, sarea_priv->dirty);
 
 		do {
-			if ( i < sarea_priv->nbox ) {
-				mga_emit_clip_rect( dev_priv,
-						    &sarea_priv->boxes[i] );
+			if (i < sarea_priv->nbox) {
+				mga_emit_clip_rect(dev_priv,
+						   &sarea_priv->boxes[i]);
 			}
 
-			BEGIN_DMA( 1 );
+			BEGIN_DMA(1);
 
-			DMA_BLOCK( MGA_DMAPAD,		0x00000000,
-				   MGA_DMAPAD,		0x00000000,
-				   MGA_SETUPADDRESS,	address + start,
-				   MGA_SETUPEND,	((address + end) |
-							 MGA_PAGPXFER) );
+			DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+				  MGA_DMAPAD, 0x00000000,
+				  MGA_SETUPADDRESS, address + start,
+				  MGA_SETUPEND, ((address + end) |
+						 dev_priv->dma_access));
 
 			ADVANCE_DMA();
-		} while ( ++i < sarea_priv->nbox );
+		} while (++i < sarea_priv->nbox);
 	}
 
-	if ( buf_priv->discard ) {
-		AGE_BUFFER( buf_priv );
+	if (buf_priv->discard) {
+		AGE_BUFFER(buf_priv);
 		buf->pending = 0;
 		buf->used = 0;
 		buf_priv->dispatched = 0;
 
-		mga_freelist_put( dev, buf );
+		mga_freelist_put(dev, buf);
 	}
 
 	FLUSH_DMA();
@@ -758,61 +746,60 @@ static void mga_dma_dispatch_indices( dr
 /* This copies a 64 byte aligned agp region to the frambuffer with a
  * standard blit, the ioctl needs to do checking.
  */
-static void mga_dma_dispatch_iload( drm_device_t *dev, drm_buf_t *buf,
-				    unsigned int dstorg, unsigned int length )
+static void mga_dma_dispatch_iload(drm_device_t * dev, drm_buf_t * buf,
+				   unsigned int dstorg, unsigned int length)
 {
 	drm_mga_private_t *dev_priv = dev->dev_private;
 	drm_mga_buf_priv_t *buf_priv = buf->dev_private;
 	drm_mga_context_regs_t *ctx = &dev_priv->sarea_priv->context_state;
-	u32 srcorg = buf->bus_address | MGA_SRCACC_AGP | MGA_SRCMAP_SYSMEM;
+	u32 srcorg = buf->bus_address | dev_priv->dma_access | MGA_SRCMAP_SYSMEM;
 	u32 y2;
 	DMA_LOCALS;
-	DRM_DEBUG( "buf=%d used=%d\n", buf->idx, buf->used );
+	DRM_DEBUG("buf=%d used=%d\n", buf->idx, buf->used);
 
 	y2 = length / 64;
 
-	BEGIN_DMA( 5 );
+	BEGIN_DMA(5);
 
-	DMA_BLOCK( MGA_DMAPAD,	0x00000000,
-		   MGA_DMAPAD,	0x00000000,
-		   MGA_DWGSYNC,	0x00007100,
-		   MGA_DWGSYNC,	0x00007000 );
-
-	DMA_BLOCK( MGA_DSTORG,	dstorg,
-		   MGA_MACCESS,	0x00000000,
-		   MGA_SRCORG,	srcorg,
-		   MGA_AR5,	64 );
-
-	DMA_BLOCK( MGA_PITCH,	64,
-		   MGA_PLNWT,	0xffffffff,
-		   MGA_DMAPAD,	0x00000000,
-		   MGA_DWGCTL,	MGA_DWGCTL_COPY );
-
-	DMA_BLOCK( MGA_AR0,	63,
-		   MGA_AR3,	0,
-		   MGA_FXBNDRY,	(63 << 16) | 0,
-		   MGA_YDSTLEN + MGA_EXEC, y2 );
-
-	DMA_BLOCK( MGA_PLNWT,	ctx->plnwt,
-		   MGA_SRCORG,	dev_priv->front_offset,
-		   MGA_PITCH,	dev_priv->front_pitch,
-		   MGA_DWGSYNC,	0x00007000 );
+	DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+		  MGA_DMAPAD, 0x00000000,
+		  MGA_DWGSYNC, 0x00007100,
+		  MGA_DWGSYNC, 0x00007000);
+
+	DMA_BLOCK(MGA_DSTORG, dstorg,
+		  MGA_MACCESS, 0x00000000,
+		  MGA_SRCORG, srcorg,
+		  MGA_AR5, 64);
+
+	DMA_BLOCK(MGA_PITCH, 64,
+		  MGA_PLNWT, 0xffffffff,
+		  MGA_DMAPAD, 0x00000000,
+		  MGA_DWGCTL, MGA_DWGCTL_COPY);
+
+	DMA_BLOCK(MGA_AR0, 63,
+		  MGA_AR3, 0,
+		  MGA_FXBNDRY, (63 << 16) | 0,
+		  MGA_YDSTLEN + MGA_EXEC, y2);
+
+	DMA_BLOCK(MGA_PLNWT, ctx->plnwt,
+		  MGA_SRCORG, dev_priv->front_offset,
+		  MGA_PITCH, dev_priv->front_pitch,
+		  MGA_DWGSYNC, 0x00007000);
 
 	ADVANCE_DMA();
 
-	AGE_BUFFER( buf_priv );
+	AGE_BUFFER(buf_priv);
 
 	buf->pending = 0;
 	buf->used = 0;
 	buf_priv->dispatched = 0;
 
-	mga_freelist_put( dev, buf );
+	mga_freelist_put(dev, buf);
 
 	FLUSH_DMA();
 }
 
-static void mga_dma_dispatch_blit( drm_device_t *dev,
-				   drm_mga_blit_t *blit )
+static void mga_dma_dispatch_blit(drm_device_t * dev, drm_mga_blit_t * blit)
 {
 	drm_mga_private_t *dev_priv = dev->dev_private;
 	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
@@ -821,26 +808,26 @@ static void mga_dma_dispatch_blit( drm_d
 	int nbox = sarea_priv->nbox;
 	u32 scandir = 0, i;
 	DMA_LOCALS;
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
-	BEGIN_DMA( 4 + nbox );
+	BEGIN_DMA(4 + nbox);
 
-	DMA_BLOCK( MGA_DMAPAD,	0x00000000,
-		   MGA_DMAPAD,	0x00000000,
-		   MGA_DWGSYNC,	0x00007100,
-		   MGA_DWGSYNC,	0x00007000 );
-
-	DMA_BLOCK( MGA_DWGCTL,	MGA_DWGCTL_COPY,
-		   MGA_PLNWT,	blit->planemask,
-		   MGA_SRCORG,	blit->srcorg,
-		   MGA_DSTORG,	blit->dstorg );
-
-	DMA_BLOCK( MGA_SGN,	scandir,
-		   MGA_MACCESS,	dev_priv->maccess,
-		   MGA_AR5,	blit->ydir * blit->src_pitch,
-		   MGA_PITCH,	blit->dst_pitch );
+	DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+		  MGA_DMAPAD, 0x00000000,
+		  MGA_DWGSYNC, 0x00007100,
+		  MGA_DWGSYNC, 0x00007000);
+
+	DMA_BLOCK(MGA_DWGCTL, MGA_DWGCTL_COPY,
+		  MGA_PLNWT, blit->planemask,
+		  MGA_SRCORG, blit->srcorg,
+		  MGA_DSTORG, blit->dstorg);
+
+	DMA_BLOCK(MGA_SGN, scandir,
+		  MGA_MACCESS, dev_priv->maccess,
+		  MGA_AR5, blit->ydir * blit->src_pitch,
+		  MGA_PITCH, blit->dst_pitch);
 
-	for ( i = 0 ; i < nbox ; i++ ) {
+	for (i = 0; i < nbox; i++) {
 		int srcx = pbox[i].x1 + blit->delta_sx;
 		int srcy = pbox[i].y1 + blit->delta_sy;
 		int dstx = pbox[i].x1 + blit->delta_dx;
@@ -849,52 +836,52 @@ static void mga_dma_dispatch_blit( drm_d
 		int w = pbox[i].x2 - pbox[i].x1 - 1;
 		int start;
 
-		if ( blit->ydir == -1 ) {
+		if (blit->ydir == -1) {
 			srcy = blit->height - srcy - 1;
 		}
 
 		start = srcy * blit->src_pitch + srcx;
 
-		DMA_BLOCK( MGA_AR0,	start + w,
-			   MGA_AR3,	start,
-			   MGA_FXBNDRY,	((dstx + w) << 16) | (dstx & 0xffff),
-			   MGA_YDSTLEN + MGA_EXEC, (dsty << 16) | h );
+		DMA_BLOCK(MGA_AR0, start + w,
+			  MGA_AR3, start,
+			  MGA_FXBNDRY, ((dstx + w) << 16) | (dstx & 0xffff),
+			  MGA_YDSTLEN + MGA_EXEC, (dsty << 16) | h);
 	}
 
 	/* Do something to flush AGP?
 	 */
 
 	/* Force reset of DWGCTL */
-	DMA_BLOCK( MGA_DMAPAD,	0x00000000,
-		   MGA_PLNWT,	ctx->plnwt,
-		   MGA_PITCH,	dev_priv->front_pitch,
-		   MGA_DWGCTL,	ctx->dwgctl );
+	DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+		  MGA_PLNWT, ctx->plnwt,
+		  MGA_PITCH, dev_priv->front_pitch,
+		  MGA_DWGCTL, ctx->dwgctl);
 
 	ADVANCE_DMA();
 }
 
-
 /* ================================================================
  *
  */
 
-static int mga_dma_clear( DRM_IOCTL_ARGS )
+static int mga_dma_clear(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_mga_private_t *dev_priv = dev->dev_private;
 	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
 	drm_mga_clear_t clear;
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	DRM_COPY_FROM_USER_IOCTL( clear, (drm_mga_clear_t __user *)data, sizeof(clear) );
+	DRM_COPY_FROM_USER_IOCTL(clear, (drm_mga_clear_t __user *) data,
+				 sizeof(clear));
 
-	if ( sarea_priv->nbox > MGA_NR_SAREA_CLIPRECTS )
+	if (sarea_priv->nbox > MGA_NR_SAREA_CLIPRECTS)
 		sarea_priv->nbox = MGA_NR_SAREA_CLIPRECTS;
 
-	WRAP_TEST_WITH_RETURN( dev_priv );
+	WRAP_TEST_WITH_RETURN(dev_priv);
 
-	mga_dma_dispatch_clear( dev, &clear );
+	mga_dma_dispatch_clear(dev, &clear);
 
 	/* Make sure we restore the 3D state next time.
 	 */
@@ -903,20 +890,20 @@ static int mga_dma_clear( DRM_IOCTL_ARGS
 	return 0;
 }
 
-static int mga_dma_swap( DRM_IOCTL_ARGS )
+static int mga_dma_swap(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_mga_private_t *dev_priv = dev->dev_private;
 	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	if ( sarea_priv->nbox > MGA_NR_SAREA_CLIPRECTS )
+	if (sarea_priv->nbox > MGA_NR_SAREA_CLIPRECTS)
 		sarea_priv->nbox = MGA_NR_SAREA_CLIPRECTS;
 
-	WRAP_TEST_WITH_RETURN( dev_priv );
+	WRAP_TEST_WITH_RETURN(dev_priv);
 
-	mga_dma_dispatch_swap( dev );
+	mga_dma_dispatch_swap(dev);
 
 	/* Make sure we restore the 3D state next time.
 	 */
@@ -925,7 +912,7 @@ static int mga_dma_swap( DRM_IOCTL_ARGS 
 	return 0;
 }
 
-static int mga_dma_vertex( DRM_IOCTL_ARGS )
+static int mga_dma_vertex(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_mga_private_t *dev_priv = dev->dev_private;
@@ -934,37 +921,38 @@ static int mga_dma_vertex( DRM_IOCTL_ARG
 	drm_mga_buf_priv_t *buf_priv;
 	drm_mga_vertex_t vertex;
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	DRM_COPY_FROM_USER_IOCTL( vertex,
-			     (drm_mga_vertex_t __user *)data,
-			     sizeof(vertex) );
+	DRM_COPY_FROM_USER_IOCTL(vertex,
+				 (drm_mga_vertex_t __user *) data,
+				 sizeof(vertex));
 
-        if(vertex.idx < 0 || vertex.idx > dma->buf_count) return DRM_ERR(EINVAL);
+	if (vertex.idx < 0 || vertex.idx > dma->buf_count)
+		return DRM_ERR(EINVAL);
 	buf = dma->buflist[vertex.idx];
 	buf_priv = buf->dev_private;
 
 	buf->used = vertex.used;
 	buf_priv->discard = vertex.discard;
 
-	if ( !mga_verify_state( dev_priv ) ) {
-		if ( vertex.discard ) {
-			if ( buf_priv->dispatched == 1 )
-				AGE_BUFFER( buf_priv );
+	if (!mga_verify_state(dev_priv)) {
+		if (vertex.discard) {
+			if (buf_priv->dispatched == 1)
+				AGE_BUFFER(buf_priv);
 			buf_priv->dispatched = 0;
-			mga_freelist_put( dev, buf );
+			mga_freelist_put(dev, buf);
 		}
 		return DRM_ERR(EINVAL);
 	}
 
-	WRAP_TEST_WITH_RETURN( dev_priv );
+	WRAP_TEST_WITH_RETURN(dev_priv);
 
-	mga_dma_dispatch_vertex( dev, buf );
+	mga_dma_dispatch_vertex(dev, buf);
 
 	return 0;
 }
 
-static int mga_dma_indices( DRM_IOCTL_ARGS )
+static int mga_dma_indices(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_mga_private_t *dev_priv = dev->dev_private;
@@ -973,37 +961,38 @@ static int mga_dma_indices( DRM_IOCTL_AR
 	drm_mga_buf_priv_t *buf_priv;
 	drm_mga_indices_t indices;
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	DRM_COPY_FROM_USER_IOCTL( indices,
-			     (drm_mga_indices_t __user *)data,
-			     sizeof(indices) );
+	DRM_COPY_FROM_USER_IOCTL(indices,
+				 (drm_mga_indices_t __user *) data,
+				 sizeof(indices));
 
-        if(indices.idx < 0 || indices.idx > dma->buf_count) return DRM_ERR(EINVAL);
+	if (indices.idx < 0 || indices.idx > dma->buf_count)
+		return DRM_ERR(EINVAL);
 
 	buf = dma->buflist[indices.idx];
 	buf_priv = buf->dev_private;
 
 	buf_priv->discard = indices.discard;
 
-	if ( !mga_verify_state( dev_priv ) ) {
-		if ( indices.discard ) {
-			if ( buf_priv->dispatched == 1 )
-				AGE_BUFFER( buf_priv );
+	if (!mga_verify_state(dev_priv)) {
+		if (indices.discard) {
+			if (buf_priv->dispatched == 1)
+				AGE_BUFFER(buf_priv);
 			buf_priv->dispatched = 0;
-			mga_freelist_put( dev, buf );
+			mga_freelist_put(dev, buf);
 		}
 		return DRM_ERR(EINVAL);
 	}
 
-	WRAP_TEST_WITH_RETURN( dev_priv );
+	WRAP_TEST_WITH_RETURN(dev_priv);
 
-	mga_dma_dispatch_indices( dev, buf, indices.start, indices.end );
+	mga_dma_dispatch_indices(dev, buf, indices.start, indices.end);
 
 	return 0;
 }
 
-static int mga_dma_iload( DRM_IOCTL_ARGS )
+static int mga_dma_iload(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_device_dma_t *dma = dev->dma;
@@ -1011,32 +1000,34 @@ static int mga_dma_iload( DRM_IOCTL_ARGS
 	drm_buf_t *buf;
 	drm_mga_buf_priv_t *buf_priv;
 	drm_mga_iload_t iload;
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	DRM_COPY_FROM_USER_IOCTL( iload, (drm_mga_iload_t __user *)data, sizeof(iload) );
+	DRM_COPY_FROM_USER_IOCTL(iload, (drm_mga_iload_t __user *) data,
+				 sizeof(iload));
 
 #if 0
-	if ( mga_do_wait_for_idle( dev_priv ) < 0 ) {
-		if ( MGA_DMA_DEBUG )
-			DRM_INFO( "%s: -EBUSY\n", __FUNCTION__ );
+	if (mga_do_wait_for_idle(dev_priv) < 0) {
+		if (MGA_DMA_DEBUG)
+			DRM_INFO("%s: -EBUSY\n", __FUNCTION__);
 		return DRM_ERR(EBUSY);
 	}
 #endif
-        if(iload.idx < 0 || iload.idx > dma->buf_count) return DRM_ERR(EINVAL);
+	if (iload.idx < 0 || iload.idx > dma->buf_count)
+		return DRM_ERR(EINVAL);
 
 	buf = dma->buflist[iload.idx];
 	buf_priv = buf->dev_private;
 
-	if ( mga_verify_iload( dev_priv, iload.dstorg, iload.length ) ) {
-		mga_freelist_put( dev, buf );
+	if (mga_verify_iload(dev_priv, iload.dstorg, iload.length)) {
+		mga_freelist_put(dev, buf);
 		return DRM_ERR(EINVAL);
 	}
 
-	WRAP_TEST_WITH_RETURN( dev_priv );
+	WRAP_TEST_WITH_RETURN(dev_priv);
 
-	mga_dma_dispatch_iload( dev, buf, iload.dstorg, iload.length );
+	mga_dma_dispatch_iload(dev, buf, iload.dstorg, iload.length);
 
 	/* Make sure we restore the 3D state next time.
 	 */
@@ -1045,27 +1036,28 @@ static int mga_dma_iload( DRM_IOCTL_ARGS
 	return 0;
 }
 
-static int mga_dma_blit( DRM_IOCTL_ARGS )
+static int mga_dma_blit(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_mga_private_t *dev_priv = dev->dev_private;
 	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
 	drm_mga_blit_t blit;
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	DRM_COPY_FROM_USER_IOCTL( blit, (drm_mga_blit_t __user *)data, sizeof(blit) );
+	DRM_COPY_FROM_USER_IOCTL(blit, (drm_mga_blit_t __user *) data,
+				 sizeof(blit));
 
-	if ( sarea_priv->nbox > MGA_NR_SAREA_CLIPRECTS )
+	if (sarea_priv->nbox > MGA_NR_SAREA_CLIPRECTS)
 		sarea_priv->nbox = MGA_NR_SAREA_CLIPRECTS;
 
-	if ( mga_verify_blit( dev_priv, blit.srcorg, blit.dstorg ) )
+	if (mga_verify_blit(dev_priv, blit.srcorg, blit.dstorg))
 		return DRM_ERR(EINVAL);
 
-	WRAP_TEST_WITH_RETURN( dev_priv );
+	WRAP_TEST_WITH_RETURN(dev_priv);
 
-	mga_dma_dispatch_blit( dev, &blit );
+	mga_dma_dispatch_blit(dev, &blit);
 
 	/* Make sure we restore the 3D state next time.
 	 */
@@ -1074,50 +1066,118 @@ static int mga_dma_blit( DRM_IOCTL_ARGS 
 	return 0;
 }
 
-static int mga_getparam( DRM_IOCTL_ARGS )
+static int mga_getparam(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_mga_private_t *dev_priv = dev->dev_private;
 	drm_mga_getparam_t param;
 	int value;
 
-	if ( !dev_priv ) {
-		DRM_ERROR( "%s called with no initialization\n", __FUNCTION__ );
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
 		return DRM_ERR(EINVAL);
 	}
 
-	DRM_COPY_FROM_USER_IOCTL( param, (drm_mga_getparam_t __user *)data,
-			     sizeof(param) );
+	DRM_COPY_FROM_USER_IOCTL(param, (drm_mga_getparam_t __user *) data,
+				 sizeof(param));
 
-	DRM_DEBUG( "pid=%d\n", DRM_CURRENTPID );
+	DRM_DEBUG("pid=%d\n", DRM_CURRENTPID);
 
-	switch( param.param ) {
+	switch (param.param) {
 	case MGA_PARAM_IRQ_NR:
 		value = dev->irq;
 		break;
+	case MGA_PARAM_CARD_TYPE:
+		value = dev_priv->chipset;
+		break;
 	default:
 		return DRM_ERR(EINVAL);
 	}
 
-	if ( DRM_COPY_TO_USER( param.value, &value, sizeof(int) ) ) {
-		DRM_ERROR( "copy_to_user\n" );
+	if (DRM_COPY_TO_USER(param.value, &value, sizeof(int))) {
+		DRM_ERROR("copy_to_user\n");
+		return DRM_ERR(EFAULT);
+	}
+
+	return 0;
+}
+
+static int mga_set_fence(DRM_IOCTL_ARGS)
+{
+	DRM_DEVICE;
+	drm_mga_private_t *dev_priv = dev->dev_private;
+	u32 temp;
+	DMA_LOCALS;
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return DRM_ERR(EINVAL);
+	}
+
+	DRM_DEBUG("pid=%d\n", DRM_CURRENTPID);
+
+	/* I would normal do this assignment in the declaration of temp,
+	 * but dev_priv may be NULL.
+	 */
+
+	temp = dev_priv->next_fence_to_post;
+	dev_priv->next_fence_to_post++;
+
+	BEGIN_DMA(1);
+	DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+		  MGA_DMAPAD, 0x00000000,
+		  MGA_DMAPAD, 0x00000000,
+		  MGA_SOFTRAP, 0x00000000);
+	ADVANCE_DMA();
+
+	if (DRM_COPY_TO_USER( (u32 __user *) data, & temp, sizeof(u32))) {
+		DRM_ERROR("copy_to_user\n");
+		return DRM_ERR(EFAULT);
+	}
+
+	return 0;
+}
+
+static int mga_wait_fence(DRM_IOCTL_ARGS)
+{
+	DRM_DEVICE;
+	drm_mga_private_t *dev_priv = dev->dev_private;
+	u32 fence;
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return DRM_ERR(EINVAL);
+	}
+
+	DRM_COPY_FROM_USER_IOCTL(fence, (u32 __user *) data, sizeof(u32));
+
+	DRM_DEBUG("pid=%d\n", DRM_CURRENTPID);
+
+	mga_driver_fence_wait(dev, & fence);
+
+	if (DRM_COPY_TO_USER( (u32 __user *) data, & fence, sizeof(u32))) {
+		DRM_ERROR("copy_to_user\n");
 		return DRM_ERR(EFAULT);
 	}
-	
+
 	return 0;
 }
 
 drm_ioctl_desc_t mga_ioctls[] = {
-	[DRM_IOCTL_NR(DRM_MGA_INIT)]    = { mga_dma_init,    1, 1 },
-	[DRM_IOCTL_NR(DRM_MGA_FLUSH)]   = { mga_dma_flush,   1, 0 },
-	[DRM_IOCTL_NR(DRM_MGA_RESET)]   = { mga_dma_reset,   1, 0 },
-	[DRM_IOCTL_NR(DRM_MGA_SWAP)]    = { mga_dma_swap,    1, 0 },
-	[DRM_IOCTL_NR(DRM_MGA_CLEAR)]   = { mga_dma_clear,   1, 0 },
-	[DRM_IOCTL_NR(DRM_MGA_VERTEX)]  = { mga_dma_vertex,  1, 0 },
-	[DRM_IOCTL_NR(DRM_MGA_INDICES)] = { mga_dma_indices, 1, 0 },
-	[DRM_IOCTL_NR(DRM_MGA_ILOAD)]   = { mga_dma_iload,   1, 0 },
-	[DRM_IOCTL_NR(DRM_MGA_BLIT)]    = { mga_dma_blit,    1, 0 },
-	[DRM_IOCTL_NR(DRM_MGA_GETPARAM)]= { mga_getparam,    1, 0 },
+	[DRM_IOCTL_NR(DRM_MGA_INIT)] = {mga_dma_init, 1, 1},
+	[DRM_IOCTL_NR(DRM_MGA_FLUSH)] = {mga_dma_flush, 1, 0},
+	[DRM_IOCTL_NR(DRM_MGA_RESET)] = {mga_dma_reset, 1, 0},
+	[DRM_IOCTL_NR(DRM_MGA_SWAP)] = {mga_dma_swap, 1, 0},
+	[DRM_IOCTL_NR(DRM_MGA_CLEAR)] = {mga_dma_clear, 1, 0},
+	[DRM_IOCTL_NR(DRM_MGA_VERTEX)] = {mga_dma_vertex, 1, 0},
+	[DRM_IOCTL_NR(DRM_MGA_INDICES)] = {mga_dma_indices, 1, 0},
+	[DRM_IOCTL_NR(DRM_MGA_ILOAD)] = {mga_dma_iload, 1, 0},
+	[DRM_IOCTL_NR(DRM_MGA_BLIT)] = {mga_dma_blit, 1, 0},
+	[DRM_IOCTL_NR(DRM_MGA_GETPARAM)] = {mga_getparam, 1, 0},
+	[DRM_IOCTL_NR(DRM_MGA_SET_FENCE)] = {mga_set_fence, 1, 0},
+	[DRM_IOCTL_NR(DRM_MGA_WAIT_FENCE)] = {mga_wait_fence, 1, 0},
+	[DRM_IOCTL_NR(DRM_MGA_DMA_BOOTSTRAP)] = {mga_dma_bootstrap, 1, 1},
+
 };
 
 int mga_max_ioctl = DRM_ARRAY_SIZE(mga_ioctls);
diff -purN linux-2.6.12.orig/drivers/char/drm/mga_ucode.h linux-2.6.12/drivers/char/drm/mga_ucode.h
--- linux-2.6.12.orig/drivers/char/drm/mga_ucode.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/mga_ucode.h	2005-07-05 08:37:49.000000000 +0200
@@ -40,11606 +40,11606 @@
 
 static unsigned char warp_g200_tgz[] = {
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x98, 0xA0, 0xE9,
-0x40, 0x40, 0xD8, 0xEC,
+	0x00, 0x98, 0xA0, 0xE9,
+	0x40, 0x40, 0xD8, 0xEC,
 
-0xFF, 0x80, 0xC0, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x1F, 0xD7, 0x18, 0xBD,
-0x3F, 0xD7, 0x22, 0xBD,
+	0x1F, 0xD7, 0x18, 0xBD,
+	0x3F, 0xD7, 0x22, 0xBD,
 
-0x81, 0x04,
-0x89, 0x04,
-0x01, 0x04,
-0x09, 0x04,
+	0x81, 0x04,
+	0x89, 0x04,
+	0x01, 0x04,
+	0x09, 0x04,
 
-0xC9, 0x41, 0xC0, 0xEC,
-0x11, 0x04,
-0x00, 0xE0,
+	0xC9, 0x41, 0xC0, 0xEC,
+	0x11, 0x04,
+	0x00, 0xE0,
 
-0x41, 0xCC, 0x41, 0xCD,
-0x49, 0xCC, 0x49, 0xCD,
+	0x41, 0xCC, 0x41, 0xCD,
+	0x49, 0xCC, 0x49, 0xCD,
 
-0xD1, 0x41, 0xC0, 0xEC,
-0x51, 0xCC, 0x51, 0xCD,
+	0xD1, 0x41, 0xC0, 0xEC,
+	0x51, 0xCC, 0x51, 0xCD,
 
-0x80, 0x04,
-0x10, 0x04,
-0x08, 0x04,
-0x00, 0xE0,
+	0x80, 0x04,
+	0x10, 0x04,
+	0x08, 0x04,
+	0x00, 0xE0,
 
-0x00, 0xCC, 0xC0, 0xCD,
-0xD1, 0x49, 0xC0, 0xEC,
+	0x00, 0xCC, 0xC0, 0xCD,
+	0xD1, 0x49, 0xC0, 0xEC,
 
-0x8A, 0x1F, 0x20, 0xE9,
-0x8B, 0x3F, 0x20, 0xE9,
+	0x8A, 0x1F, 0x20, 0xE9,
+	0x8B, 0x3F, 0x20, 0xE9,
 
-0x41, 0x3C, 0x41, 0xAD,
-0x49, 0x3C, 0x49, 0xAD,
+	0x41, 0x3C, 0x41, 0xAD,
+	0x49, 0x3C, 0x49, 0xAD,
 
-0x10, 0xCC, 0x10, 0xCD,
-0x08, 0xCC, 0x08, 0xCD,
+	0x10, 0xCC, 0x10, 0xCD,
+	0x08, 0xCC, 0x08, 0xCD,
 
-0xB9, 0x41, 0x49, 0xBB,
-0x1F, 0xF0, 0x41, 0xCD,
+	0xB9, 0x41, 0x49, 0xBB,
+	0x1F, 0xF0, 0x41, 0xCD,
 
-0x51, 0x3C, 0x51, 0xAD,
-0x00, 0x98, 0x80, 0xE9,
+	0x51, 0x3C, 0x51, 0xAD,
+	0x00, 0x98, 0x80, 0xE9,
 
-0x72, 0x80, 0x07, 0xEA,
-0x24, 0x1F, 0x20, 0xE9,
+	0x72, 0x80, 0x07, 0xEA,
+	0x24, 0x1F, 0x20, 0xE9,
 
-0x15, 0x41, 0x49, 0xBD,
-0x1D, 0x41, 0x51, 0xBD,
+	0x15, 0x41, 0x49, 0xBD,
+	0x1D, 0x41, 0x51, 0xBD,
 
-0x2E, 0x41, 0x2A, 0xB8,
-0x34, 0x53, 0xA0, 0xE8,
+	0x2E, 0x41, 0x2A, 0xB8,
+	0x34, 0x53, 0xA0, 0xE8,
 
-0x15, 0x30,
-0x1D, 0x30,
-0x58, 0xE3,
-0x00, 0xE0,
+	0x15, 0x30,
+	0x1D, 0x30,
+	0x58, 0xE3,
+	0x00, 0xE0,
 
-0xB5, 0x40, 0x48, 0xBD,
-0x3D, 0x40, 0x50, 0xBD,
+	0xB5, 0x40, 0x48, 0xBD,
+	0x3D, 0x40, 0x50, 0xBD,
 
-0x24, 0x43, 0xA0, 0xE8,
-0x2C, 0x4B, 0xA0, 0xE8,
+	0x24, 0x43, 0xA0, 0xE8,
+	0x2C, 0x4B, 0xA0, 0xE8,
 
-0x15, 0x72,
-0x09, 0xE3,
-0x00, 0xE0,
-0x1D, 0x72,
+	0x15, 0x72,
+	0x09, 0xE3,
+	0x00, 0xE0,
+	0x1D, 0x72,
 
-0x35, 0x30,
-0xB5, 0x30,
-0xBD, 0x30,
-0x3D, 0x30,
+	0x35, 0x30,
+	0xB5, 0x30,
+	0xBD, 0x30,
+	0x3D, 0x30,
 
-0x9C, 0x97, 0x57, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x9C, 0x97, 0x57, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x6C, 0x64, 0xC8, 0xEC,
-0x98, 0xE1,
-0xB5, 0x05,
+	0x6C, 0x64, 0xC8, 0xEC,
+	0x98, 0xE1,
+	0xB5, 0x05,
 
-0xBD, 0x05,
-0x2E, 0x30,
-0x32, 0xC0, 0xA0, 0xE8,
+	0xBD, 0x05,
+	0x2E, 0x30,
+	0x32, 0xC0, 0xA0, 0xE8,
 
-0x33, 0xC0, 0xA0, 0xE8,
-0x74, 0x64, 0xC8, 0xEC,
+	0x33, 0xC0, 0xA0, 0xE8,
+	0x74, 0x64, 0xC8, 0xEC,
 
-0x40, 0x3C, 0x40, 0xAD,
-0x32, 0x6A,
-0x2A, 0x30,
+	0x40, 0x3C, 0x40, 0xAD,
+	0x32, 0x6A,
+	0x2A, 0x30,
 
-0x20, 0x73,
-0x33, 0x6A,
-0x00, 0xE0,
-0x28, 0x73,
+	0x20, 0x73,
+	0x33, 0x6A,
+	0x00, 0xE0,
+	0x28, 0x73,
 
-0x1C, 0x72,
-0x83, 0xE2,
-0x60, 0x80, 0x15, 0xEA,
+	0x1C, 0x72,
+	0x83, 0xE2,
+	0x60, 0x80, 0x15, 0xEA,
 
-0xB8, 0x3D, 0x28, 0xDF,
-0x30, 0x35, 0x20, 0xDF,
+	0xB8, 0x3D, 0x28, 0xDF,
+	0x30, 0x35, 0x20, 0xDF,
 
-0x40, 0x30,
-0x00, 0xE0,
-0xCC, 0xE2,
-0x64, 0x72,
+	0x40, 0x30,
+	0x00, 0xE0,
+	0xCC, 0xE2,
+	0x64, 0x72,
 
-0x25, 0x42, 0x52, 0xBF,
-0x2D, 0x42, 0x4A, 0xBF,
+	0x25, 0x42, 0x52, 0xBF,
+	0x2D, 0x42, 0x4A, 0xBF,
 
-0x30, 0x2E, 0x30, 0xDF,
-0x38, 0x2E, 0x38, 0xDF,
+	0x30, 0x2E, 0x30, 0xDF,
+	0x38, 0x2E, 0x38, 0xDF,
 
-0x18, 0x1D, 0x45, 0xE9,
-0x1E, 0x15, 0x45, 0xE9,
+	0x18, 0x1D, 0x45, 0xE9,
+	0x1E, 0x15, 0x45, 0xE9,
 
-0x2B, 0x49, 0x51, 0xBD,
-0x00, 0xE0,
-0x1F, 0x73,
+	0x2B, 0x49, 0x51, 0xBD,
+	0x00, 0xE0,
+	0x1F, 0x73,
 
-0x38, 0x38, 0x40, 0xAF,
-0x30, 0x30, 0x40, 0xAF,
+	0x38, 0x38, 0x40, 0xAF,
+	0x30, 0x30, 0x40, 0xAF,
 
-0x24, 0x1F, 0x24, 0xDF,
-0x1D, 0x32, 0x20, 0xE9,
+	0x24, 0x1F, 0x24, 0xDF,
+	0x1D, 0x32, 0x20, 0xE9,
 
-0x2C, 0x1F, 0x2C, 0xDF,
-0x1A, 0x33, 0x20, 0xE9,
+	0x2C, 0x1F, 0x2C, 0xDF,
+	0x1A, 0x33, 0x20, 0xE9,
 
-0xB0, 0x10,
-0x08, 0xE3,
-0x40, 0x10,
-0xB8, 0x10,
+	0xB0, 0x10,
+	0x08, 0xE3,
+	0x40, 0x10,
+	0xB8, 0x10,
 
-0x26, 0xF0, 0x30, 0xCD,
-0x2F, 0xF0, 0x38, 0xCD,
+	0x26, 0xF0, 0x30, 0xCD,
+	0x2F, 0xF0, 0x38, 0xCD,
 
-0x2B, 0x80, 0x20, 0xE9,
-0x2A, 0x80, 0x20, 0xE9,
+	0x2B, 0x80, 0x20, 0xE9,
+	0x2A, 0x80, 0x20, 0xE9,
 
-0xA6, 0x20,
-0x88, 0xE2,
-0x00, 0xE0,
-0xAF, 0x20,
+	0xA6, 0x20,
+	0x88, 0xE2,
+	0x00, 0xE0,
+	0xAF, 0x20,
 
-0x28, 0x2A, 0x26, 0xAF,
-0x20, 0x2A, 0xC0, 0xAF,
+	0x28, 0x2A, 0x26, 0xAF,
+	0x20, 0x2A, 0xC0, 0xAF,
 
-0x34, 0x1F, 0x34, 0xDF,
-0x46, 0x24, 0x46, 0xDF,
+	0x34, 0x1F, 0x34, 0xDF,
+	0x46, 0x24, 0x46, 0xDF,
 
-0x28, 0x30, 0x80, 0xBF,
-0x20, 0x38, 0x80, 0xBF,
+	0x28, 0x30, 0x80, 0xBF,
+	0x20, 0x38, 0x80, 0xBF,
 
-0x47, 0x24, 0x47, 0xDF,
-0x4E, 0x2C, 0x4E, 0xDF,
+	0x47, 0x24, 0x47, 0xDF,
+	0x4E, 0x2C, 0x4E, 0xDF,
 
-0x4F, 0x2C, 0x4F, 0xDF,
-0x56, 0x34, 0x56, 0xDF,
+	0x4F, 0x2C, 0x4F, 0xDF,
+	0x56, 0x34, 0x56, 0xDF,
 
-0x28, 0x15, 0x28, 0xDF,
-0x20, 0x1D, 0x20, 0xDF,
+	0x28, 0x15, 0x28, 0xDF,
+	0x20, 0x1D, 0x20, 0xDF,
 
-0x57, 0x34, 0x57, 0xDF,
-0x00, 0xE0,
-0x1D, 0x05,
+	0x57, 0x34, 0x57, 0xDF,
+	0x00, 0xE0,
+	0x1D, 0x05,
 
-0x04, 0x80, 0x10, 0xEA,
-0x89, 0xE2,
-0x2B, 0x30,
+	0x04, 0x80, 0x10, 0xEA,
+	0x89, 0xE2,
+	0x2B, 0x30,
 
-0x3F, 0xC1, 0x1D, 0xBD,
-0x00, 0x80, 0x00, 0xE8,
+	0x3F, 0xC1, 0x1D, 0xBD,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xA0, 0x68,
-0xBF, 0x25,
-0x00, 0x80, 0x00, 0xE8,
+	0xA0, 0x68,
+	0xBF, 0x25,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x20, 0xC0, 0x20, 0xAF,
-0x28, 0x05,
-0x97, 0x74,
+	0x20, 0xC0, 0x20, 0xAF,
+	0x28, 0x05,
+	0x97, 0x74,
 
-0x00, 0xE0,
-0x2A, 0x10,
-0x16, 0xC0, 0x20, 0xE9,
+	0x00, 0xE0,
+	0x2A, 0x10,
+	0x16, 0xC0, 0x20, 0xE9,
 
-0x04, 0x80, 0x10, 0xEA,
-0x8C, 0xE2,
-0x95, 0x05,
+	0x04, 0x80, 0x10, 0xEA,
+	0x8C, 0xE2,
+	0x95, 0x05,
 
-0x28, 0xC1, 0x28, 0xAD,
-0x1F, 0xC1, 0x15, 0xBD,
+	0x28, 0xC1, 0x28, 0xAD,
+	0x1F, 0xC1, 0x15, 0xBD,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xA8, 0x67,
-0x9F, 0x6B,
-0x00, 0x80, 0x00, 0xE8,
+	0xA8, 0x67,
+	0x9F, 0x6B,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x28, 0xC0, 0x28, 0xAD,
-0x1D, 0x25,
-0x20, 0x05,
+	0x28, 0xC0, 0x28, 0xAD,
+	0x1D, 0x25,
+	0x20, 0x05,
 
-0x28, 0x32, 0x80, 0xAD,
-0x40, 0x2A, 0x40, 0xBD,
+	0x28, 0x32, 0x80, 0xAD,
+	0x40, 0x2A, 0x40, 0xBD,
 
-0x1C, 0x80, 0x20, 0xE9,
-0x20, 0x33, 0x20, 0xAD,
+	0x1C, 0x80, 0x20, 0xE9,
+	0x20, 0x33, 0x20, 0xAD,
 
-0x20, 0x73,
-0x00, 0xE0,
-0xB6, 0x49, 0x51, 0xBB,
+	0x20, 0x73,
+	0x00, 0xE0,
+	0xB6, 0x49, 0x51, 0xBB,
 
-0x26, 0x2F, 0xB0, 0xE8,
-0x19, 0x20, 0x20, 0xE9,
+	0x26, 0x2F, 0xB0, 0xE8,
+	0x19, 0x20, 0x20, 0xE9,
 
-0x35, 0x20, 0x35, 0xDF,
-0x3D, 0x20, 0x3D, 0xDF,
+	0x35, 0x20, 0x35, 0xDF,
+	0x3D, 0x20, 0x3D, 0xDF,
 
-0x15, 0x20, 0x15, 0xDF,
-0x1D, 0x20, 0x1D, 0xDF,
+	0x15, 0x20, 0x15, 0xDF,
+	0x1D, 0x20, 0x1D, 0xDF,
 
-0x26, 0xD0, 0x26, 0xCD,
-0x29, 0x49, 0x2A, 0xB8,
+	0x26, 0xD0, 0x26, 0xCD,
+	0x29, 0x49, 0x2A, 0xB8,
 
-0x26, 0x40, 0x80, 0xBD,
-0x3B, 0x48, 0x50, 0xBD,
+	0x26, 0x40, 0x80, 0xBD,
+	0x3B, 0x48, 0x50, 0xBD,
 
-0x3E, 0x54, 0x57, 0x9F,
-0x00, 0xE0,
-0x82, 0xE1,
+	0x3E, 0x54, 0x57, 0x9F,
+	0x00, 0xE0,
+	0x82, 0xE1,
 
-0x1E, 0xAF, 0x59, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x1E, 0xAF, 0x59, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x26, 0x30,
-0x29, 0x30,
-0x48, 0x3C, 0x48, 0xAD,
+	0x26, 0x30,
+	0x29, 0x30,
+	0x48, 0x3C, 0x48, 0xAD,
 
-0x2B, 0x72,
-0xC2, 0xE1,
-0x2C, 0xC0, 0x44, 0xC2,
+	0x2B, 0x72,
+	0xC2, 0xE1,
+	0x2C, 0xC0, 0x44, 0xC2,
 
-0x05, 0x24, 0x34, 0xBF,
-0x0D, 0x24, 0x2C, 0xBF,
+	0x05, 0x24, 0x34, 0xBF,
+	0x0D, 0x24, 0x2C, 0xBF,
 
-0x2D, 0x46, 0x4E, 0xBF,
-0x25, 0x46, 0x56, 0xBF,
+	0x2D, 0x46, 0x4E, 0xBF,
+	0x25, 0x46, 0x56, 0xBF,
 
-0x20, 0x1D, 0x6F, 0x8F,
-0x32, 0x3E, 0x5F, 0xE9,
+	0x20, 0x1D, 0x6F, 0x8F,
+	0x32, 0x3E, 0x5F, 0xE9,
 
-0x3E, 0x50, 0x56, 0x9F,
-0x00, 0xE0,
-0x3B, 0x30,
+	0x3E, 0x50, 0x56, 0x9F,
+	0x00, 0xE0,
+	0x3B, 0x30,
 
-0x1E, 0x8F, 0x51, 0x9F,
-0x33, 0x1E, 0x5F, 0xE9,
+	0x1E, 0x8F, 0x51, 0x9F,
+	0x33, 0x1E, 0x5F, 0xE9,
 
-0x05, 0x44, 0x54, 0xB2,
-0x0D, 0x44, 0x4C, 0xB2,
+	0x05, 0x44, 0x54, 0xB2,
+	0x0D, 0x44, 0x4C, 0xB2,
 
-0x19, 0xC0, 0xB0, 0xE8,
-0x34, 0xC0, 0x44, 0xC4,
+	0x19, 0xC0, 0xB0, 0xE8,
+	0x34, 0xC0, 0x44, 0xC4,
 
-0x33, 0x73,
-0x00, 0xE0,
-0x3E, 0x62, 0x57, 0x9F,
+	0x33, 0x73,
+	0x00, 0xE0,
+	0x3E, 0x62, 0x57, 0x9F,
 
-0x1E, 0xAF, 0x59, 0x9F,
-0x00, 0xE0,
-0x0D, 0x20,
+	0x1E, 0xAF, 0x59, 0x9F,
+	0x00, 0xE0,
+	0x0D, 0x20,
 
-0x84, 0x3E, 0x58, 0xE9,
-0x28, 0x1D, 0x6F, 0x8F,
+	0x84, 0x3E, 0x58, 0xE9,
+	0x28, 0x1D, 0x6F, 0x8F,
 
-0x05, 0x20,
-0x00, 0xE0,
-0x85, 0x1E, 0x58, 0xE9,
+	0x05, 0x20,
+	0x00, 0xE0,
+	0x85, 0x1E, 0x58, 0xE9,
 
-0x9B, 0x3B, 0x33, 0xDF,
-0x20, 0x20, 0x42, 0xAF,
+	0x9B, 0x3B, 0x33, 0xDF,
+	0x20, 0x20, 0x42, 0xAF,
 
-0x30, 0x42, 0x56, 0x9F,
-0x80, 0x3E, 0x57, 0xE9,
+	0x30, 0x42, 0x56, 0x9F,
+	0x80, 0x3E, 0x57, 0xE9,
 
-0x3F, 0x8F, 0x51, 0x9F,
-0x30, 0x80, 0x5F, 0xE9,
+	0x3F, 0x8F, 0x51, 0x9F,
+	0x30, 0x80, 0x5F, 0xE9,
 
-0x28, 0x28, 0x24, 0xAF,
-0x81, 0x1E, 0x57, 0xE9,
+	0x28, 0x28, 0x24, 0xAF,
+	0x81, 0x1E, 0x57, 0xE9,
 
-0x05, 0x47, 0x57, 0xBF,
-0x0D, 0x47, 0x4F, 0xBF,
+	0x05, 0x47, 0x57, 0xBF,
+	0x0D, 0x47, 0x4F, 0xBF,
 
-0x88, 0x80, 0x58, 0xE9,
-0x1B, 0x29, 0x1B, 0xDF,
+	0x88, 0x80, 0x58, 0xE9,
+	0x1B, 0x29, 0x1B, 0xDF,
 
-0x30, 0x1D, 0x6F, 0x8F,
-0x3A, 0x30, 0x4F, 0xE9,
+	0x30, 0x1D, 0x6F, 0x8F,
+	0x3A, 0x30, 0x4F, 0xE9,
 
-0x1C, 0x30, 0x26, 0xDF,
-0x09, 0xE3,
-0x3B, 0x05,
+	0x1C, 0x30, 0x26, 0xDF,
+	0x09, 0xE3,
+	0x3B, 0x05,
 
-0x3E, 0x50, 0x56, 0x9F,
-0x3B, 0x3F, 0x4F, 0xE9,
+	0x3E, 0x50, 0x56, 0x9F,
+	0x3B, 0x3F, 0x4F, 0xE9,
 
-0x1E, 0x8F, 0x51, 0x9F,
-0x00, 0xE0,
-0xAC, 0x20,
+	0x1E, 0x8F, 0x51, 0x9F,
+	0x00, 0xE0,
+	0xAC, 0x20,
 
-0x2D, 0x44, 0x4C, 0xB4,
-0x2C, 0x1C, 0xC0, 0xAF,
+	0x2D, 0x44, 0x4C, 0xB4,
+	0x2C, 0x1C, 0xC0, 0xAF,
 
-0x25, 0x44, 0x54, 0xB4,
-0x00, 0xE0,
-0xC8, 0x30,
+	0x25, 0x44, 0x54, 0xB4,
+	0x00, 0xE0,
+	0xC8, 0x30,
 
-0x30, 0x46, 0x30, 0xAF,
-0x1B, 0x1B, 0x48, 0xAF,
+	0x30, 0x46, 0x30, 0xAF,
+	0x1B, 0x1B, 0x48, 0xAF,
 
-0x00, 0xE0,
-0x25, 0x20,
-0x38, 0x2C, 0x4F, 0xE9,
+	0x00, 0xE0,
+	0x25, 0x20,
+	0x38, 0x2C, 0x4F, 0xE9,
 
-0x86, 0x80, 0x57, 0xE9,
-0x38, 0x1D, 0x6F, 0x8F,
+	0x86, 0x80, 0x57, 0xE9,
+	0x38, 0x1D, 0x6F, 0x8F,
 
-0x28, 0x74,
-0x00, 0xE0,
-0x0D, 0x44, 0x4C, 0xB0,
+	0x28, 0x74,
+	0x00, 0xE0,
+	0x0D, 0x44, 0x4C, 0xB0,
 
-0x05, 0x44, 0x54, 0xB0,
-0x2D, 0x20,
-0x9B, 0x10,
+	0x05, 0x44, 0x54, 0xB0,
+	0x2D, 0x20,
+	0x9B, 0x10,
 
-0x82, 0x3E, 0x57, 0xE9,
-0x32, 0xF0, 0x1B, 0xCD,
+	0x82, 0x3E, 0x57, 0xE9,
+	0x32, 0xF0, 0x1B, 0xCD,
 
-0x1E, 0xBD, 0x59, 0x9F,
-0x83, 0x1E, 0x57, 0xE9,
+	0x1E, 0xBD, 0x59, 0x9F,
+	0x83, 0x1E, 0x57, 0xE9,
 
-0x38, 0x47, 0x38, 0xAF,
-0x34, 0x20,
-0x2A, 0x30,
+	0x38, 0x47, 0x38, 0xAF,
+	0x34, 0x20,
+	0x2A, 0x30,
 
-0x00, 0xE0,
-0x0D, 0x20,
-0x32, 0x20,
-0x05, 0x20,
+	0x00, 0xE0,
+	0x0D, 0x20,
+	0x32, 0x20,
+	0x05, 0x20,
 
-0x87, 0x80, 0x57, 0xE9,
-0x1F, 0x54, 0x57, 0x9F,
+	0x87, 0x80, 0x57, 0xE9,
+	0x1F, 0x54, 0x57, 0x9F,
 
-0x17, 0x42, 0x56, 0x9F,
-0x00, 0xE0,
-0x3B, 0x6A,
+	0x17, 0x42, 0x56, 0x9F,
+	0x00, 0xE0,
+	0x3B, 0x6A,
 
-0x3F, 0x8F, 0x51, 0x9F,
-0x37, 0x1E, 0x4F, 0xE9,
+	0x3F, 0x8F, 0x51, 0x9F,
+	0x37, 0x1E, 0x4F, 0xE9,
 
-0x37, 0x32, 0x2A, 0xAF,
-0x00, 0xE0,
-0x32, 0x00,
+	0x37, 0x32, 0x2A, 0xAF,
+	0x00, 0xE0,
+	0x32, 0x00,
 
-0x00, 0x80, 0x00, 0xE8,
-0x27, 0xC0, 0x44, 0xC0,
+	0x00, 0x80, 0x00, 0xE8,
+	0x27, 0xC0, 0x44, 0xC0,
 
-0x36, 0x1F, 0x4F, 0xE9,
-0x1F, 0x1F, 0x26, 0xDF,
+	0x36, 0x1F, 0x4F, 0xE9,
+	0x1F, 0x1F, 0x26, 0xDF,
 
-0x37, 0x1B, 0x37, 0xBF,
-0x17, 0x26, 0x17, 0xDF,
+	0x37, 0x1B, 0x37, 0xBF,
+	0x17, 0x26, 0x17, 0xDF,
 
-0x3E, 0x17, 0x4F, 0xE9,
-0x3F, 0x3F, 0x4F, 0xE9,
+	0x3E, 0x17, 0x4F, 0xE9,
+	0x3F, 0x3F, 0x4F, 0xE9,
 
-0x34, 0x1F, 0x34, 0xAF,
-0x2B, 0x05,
-0xA7, 0x20,
+	0x34, 0x1F, 0x34, 0xAF,
+	0x2B, 0x05,
+	0xA7, 0x20,
 
-0x33, 0x2B, 0x37, 0xDF,
-0x27, 0x17, 0xC0, 0xAF,
+	0x33, 0x2B, 0x37, 0xDF,
+	0x27, 0x17, 0xC0, 0xAF,
 
-0x34, 0x80, 0x4F, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0x34, 0x80, 0x4F, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x03, 0x80, 0x0A, 0xEA,
-0x17, 0xC1, 0x2B, 0xBD,
+	0x03, 0x80, 0x0A, 0xEA,
+	0x17, 0xC1, 0x2B, 0xBD,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xB3, 0x68,
-0x97, 0x25,
-0x00, 0x80, 0x00, 0xE8,
+	0xB3, 0x68,
+	0x97, 0x25,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x33, 0xC0, 0x33, 0xAF,
-0x3C, 0x27, 0x4F, 0xE9,
+	0x33, 0xC0, 0x33, 0xAF,
+	0x3C, 0x27, 0x4F, 0xE9,
 
-0x57, 0x39, 0x20, 0xE9,
-0x28, 0x19, 0x60, 0xEC,
+	0x57, 0x39, 0x20, 0xE9,
+	0x28, 0x19, 0x60, 0xEC,
 
-0x2B, 0x32, 0x20, 0xE9,
-0x1D, 0x3B, 0x20, 0xE9,
+	0x2B, 0x32, 0x20, 0xE9,
+	0x1D, 0x3B, 0x20, 0xE9,
 
-0xB3, 0x05,
-0x00, 0xE0,
-0x16, 0x28, 0x20, 0xE9,
+	0xB3, 0x05,
+	0x00, 0xE0,
+	0x16, 0x28, 0x20, 0xE9,
 
-0x23, 0x3B, 0x33, 0xAD,
-0x1E, 0x2B, 0x20, 0xE9,
+	0x23, 0x3B, 0x33, 0xAD,
+	0x1E, 0x2B, 0x20, 0xE9,
 
-0x1C, 0x80, 0x20, 0xE9,
-0x57, 0x36, 0x20, 0xE9,
+	0x1C, 0x80, 0x20, 0xE9,
+	0x57, 0x36, 0x20, 0xE9,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x40, 0x40, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x40, 0x40, 0xD8, 0xEC,
 
-0xFF, 0x80, 0xC0, 0xE9,
-0x90, 0xE2,
-0x00, 0xE0,
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x90, 0xE2,
+	0x00, 0xE0,
 
-0x85, 0xFF, 0x20, 0xEA,
-0x19, 0xC8, 0xC1, 0xCD,
+	0x85, 0xFF, 0x20, 0xEA,
+	0x19, 0xC8, 0xC1, 0xCD,
 
-0x1F, 0xD7, 0x18, 0xBD,
-0x3F, 0xD7, 0x22, 0xBD,
+	0x1F, 0xD7, 0x18, 0xBD,
+	0x3F, 0xD7, 0x22, 0xBD,
 
-0x9F, 0x41, 0x49, 0xBD,
-0x00, 0x80, 0x00, 0xE8,
+	0x9F, 0x41, 0x49, 0xBD,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x25, 0x41, 0x49, 0xBD,
-0x2D, 0x41, 0x51, 0xBD,
+	0x25, 0x41, 0x49, 0xBD,
+	0x2D, 0x41, 0x51, 0xBD,
 
-0x0D, 0x80, 0x07, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0x0D, 0x80, 0x07, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x35, 0x40, 0x48, 0xBD,
-0x3D, 0x40, 0x50, 0xBD,
+	0x35, 0x40, 0x48, 0xBD,
+	0x3D, 0x40, 0x50, 0xBD,
 
-0x00, 0x80, 0x00, 0xE8,
-0x25, 0x30,
-0x2D, 0x30,
+	0x00, 0x80, 0x00, 0xE8,
+	0x25, 0x30,
+	0x2D, 0x30,
 
-0x35, 0x30,
-0xB5, 0x30,
-0xBD, 0x30,
-0x3D, 0x30,
+	0x35, 0x30,
+	0xB5, 0x30,
+	0xBD, 0x30,
+	0x3D, 0x30,
 
-0x9C, 0xA7, 0x5B, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x9C, 0xA7, 0x5B, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x84, 0xFF, 0x0A, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0x84, 0xFF, 0x0A, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xC9, 0x41, 0xC8, 0xEC,
-0x42, 0xE1,
-0x00, 0xE0,
+	0xC9, 0x41, 0xC8, 0xEC,
+	0x42, 0xE1,
+	0x00, 0xE0,
 
-0x82, 0xFF, 0x20, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0x82, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xC8, 0x40, 0xC0, 0xEC,
-0x00, 0x80, 0x00, 0xE8,
+	0xC8, 0x40, 0xC0, 0xEC,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x7F, 0xFF, 0x20, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0x7F, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
 };
 
 static unsigned char warp_g200_tgza[] = {
 
-0x00, 0x98, 0xA0, 0xE9,
-0x40, 0x40, 0xD8, 0xEC,
+	0x00, 0x98, 0xA0, 0xE9,
+	0x40, 0x40, 0xD8, 0xEC,
 
-0xFF, 0x80, 0xC0, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x1F, 0xD7, 0x18, 0xBD,
-0x3F, 0xD7, 0x22, 0xBD,
+	0x1F, 0xD7, 0x18, 0xBD,
+	0x3F, 0xD7, 0x22, 0xBD,
 
-0x81, 0x04,
-0x89, 0x04,
-0x01, 0x04,
-0x09, 0x04,
+	0x81, 0x04,
+	0x89, 0x04,
+	0x01, 0x04,
+	0x09, 0x04,
 
-0xC9, 0x41, 0xC0, 0xEC,
-0x11, 0x04,
-0x00, 0xE0,
+	0xC9, 0x41, 0xC0, 0xEC,
+	0x11, 0x04,
+	0x00, 0xE0,
 
-0x41, 0xCC, 0x41, 0xCD,
-0x49, 0xCC, 0x49, 0xCD,
+	0x41, 0xCC, 0x41, 0xCD,
+	0x49, 0xCC, 0x49, 0xCD,
 
-0xD1, 0x41, 0xC0, 0xEC,
-0x51, 0xCC, 0x51, 0xCD,
+	0xD1, 0x41, 0xC0, 0xEC,
+	0x51, 0xCC, 0x51, 0xCD,
 
-0x80, 0x04,
-0x10, 0x04,
-0x08, 0x04,
-0x00, 0xE0,
+	0x80, 0x04,
+	0x10, 0x04,
+	0x08, 0x04,
+	0x00, 0xE0,
 
-0x00, 0xCC, 0xC0, 0xCD,
-0xD1, 0x49, 0xC0, 0xEC,
+	0x00, 0xCC, 0xC0, 0xCD,
+	0xD1, 0x49, 0xC0, 0xEC,
 
-0x8A, 0x1F, 0x20, 0xE9,
-0x8B, 0x3F, 0x20, 0xE9,
+	0x8A, 0x1F, 0x20, 0xE9,
+	0x8B, 0x3F, 0x20, 0xE9,
 
-0x41, 0x3C, 0x41, 0xAD,
-0x49, 0x3C, 0x49, 0xAD,
+	0x41, 0x3C, 0x41, 0xAD,
+	0x49, 0x3C, 0x49, 0xAD,
 
-0x10, 0xCC, 0x10, 0xCD,
-0x08, 0xCC, 0x08, 0xCD,
+	0x10, 0xCC, 0x10, 0xCD,
+	0x08, 0xCC, 0x08, 0xCD,
 
-0xB9, 0x41, 0x49, 0xBB,
-0x1F, 0xF0, 0x41, 0xCD,
+	0xB9, 0x41, 0x49, 0xBB,
+	0x1F, 0xF0, 0x41, 0xCD,
 
-0x51, 0x3C, 0x51, 0xAD,
-0x00, 0x98, 0x80, 0xE9,
+	0x51, 0x3C, 0x51, 0xAD,
+	0x00, 0x98, 0x80, 0xE9,
 
-0x7D, 0x80, 0x07, 0xEA,
-0x24, 0x1F, 0x20, 0xE9,
+	0x7D, 0x80, 0x07, 0xEA,
+	0x24, 0x1F, 0x20, 0xE9,
 
-0x15, 0x41, 0x49, 0xBD,
-0x1D, 0x41, 0x51, 0xBD,
+	0x15, 0x41, 0x49, 0xBD,
+	0x1D, 0x41, 0x51, 0xBD,
 
-0x2E, 0x41, 0x2A, 0xB8,
-0x34, 0x53, 0xA0, 0xE8,
+	0x2E, 0x41, 0x2A, 0xB8,
+	0x34, 0x53, 0xA0, 0xE8,
 
-0x15, 0x30,
-0x1D, 0x30,
-0x58, 0xE3,
-0x00, 0xE0,
+	0x15, 0x30,
+	0x1D, 0x30,
+	0x58, 0xE3,
+	0x00, 0xE0,
 
-0xB5, 0x40, 0x48, 0xBD,
-0x3D, 0x40, 0x50, 0xBD,
+	0xB5, 0x40, 0x48, 0xBD,
+	0x3D, 0x40, 0x50, 0xBD,
 
-0x24, 0x43, 0xA0, 0xE8,
-0x2C, 0x4B, 0xA0, 0xE8,
+	0x24, 0x43, 0xA0, 0xE8,
+	0x2C, 0x4B, 0xA0, 0xE8,
 
-0x15, 0x72,
-0x09, 0xE3,
-0x00, 0xE0,
-0x1D, 0x72,
+	0x15, 0x72,
+	0x09, 0xE3,
+	0x00, 0xE0,
+	0x1D, 0x72,
 
-0x35, 0x30,
-0xB5, 0x30,
-0xBD, 0x30,
-0x3D, 0x30,
+	0x35, 0x30,
+	0xB5, 0x30,
+	0xBD, 0x30,
+	0x3D, 0x30,
 
-0x9C, 0x97, 0x57, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x9C, 0x97, 0x57, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x6C, 0x64, 0xC8, 0xEC,
-0x98, 0xE1,
-0xB5, 0x05,
+	0x6C, 0x64, 0xC8, 0xEC,
+	0x98, 0xE1,
+	0xB5, 0x05,
 
-0xBD, 0x05,
-0x2E, 0x30,
-0x32, 0xC0, 0xA0, 0xE8,
+	0xBD, 0x05,
+	0x2E, 0x30,
+	0x32, 0xC0, 0xA0, 0xE8,
 
-0x33, 0xC0, 0xA0, 0xE8,
-0x74, 0x64, 0xC8, 0xEC,
+	0x33, 0xC0, 0xA0, 0xE8,
+	0x74, 0x64, 0xC8, 0xEC,
 
-0x40, 0x3C, 0x40, 0xAD,
-0x32, 0x6A,
-0x2A, 0x30,
+	0x40, 0x3C, 0x40, 0xAD,
+	0x32, 0x6A,
+	0x2A, 0x30,
 
-0x20, 0x73,
-0x33, 0x6A,
-0x00, 0xE0,
-0x28, 0x73,
+	0x20, 0x73,
+	0x33, 0x6A,
+	0x00, 0xE0,
+	0x28, 0x73,
 
-0x1C, 0x72,
-0x83, 0xE2,
-0x6B, 0x80, 0x15, 0xEA,
+	0x1C, 0x72,
+	0x83, 0xE2,
+	0x6B, 0x80, 0x15, 0xEA,
 
-0xB8, 0x3D, 0x28, 0xDF,
-0x30, 0x35, 0x20, 0xDF,
+	0xB8, 0x3D, 0x28, 0xDF,
+	0x30, 0x35, 0x20, 0xDF,
 
-0x40, 0x30,
-0x00, 0xE0,
-0xCC, 0xE2,
-0x64, 0x72,
+	0x40, 0x30,
+	0x00, 0xE0,
+	0xCC, 0xE2,
+	0x64, 0x72,
 
-0x25, 0x42, 0x52, 0xBF,
-0x2D, 0x42, 0x4A, 0xBF,
+	0x25, 0x42, 0x52, 0xBF,
+	0x2D, 0x42, 0x4A, 0xBF,
 
-0x30, 0x2E, 0x30, 0xDF,
-0x38, 0x2E, 0x38, 0xDF,
+	0x30, 0x2E, 0x30, 0xDF,
+	0x38, 0x2E, 0x38, 0xDF,
 
-0x18, 0x1D, 0x45, 0xE9,
-0x1E, 0x15, 0x45, 0xE9,
+	0x18, 0x1D, 0x45, 0xE9,
+	0x1E, 0x15, 0x45, 0xE9,
 
-0x2B, 0x49, 0x51, 0xBD,
-0x00, 0xE0,
-0x1F, 0x73,
+	0x2B, 0x49, 0x51, 0xBD,
+	0x00, 0xE0,
+	0x1F, 0x73,
 
-0x38, 0x38, 0x40, 0xAF,
-0x30, 0x30, 0x40, 0xAF,
+	0x38, 0x38, 0x40, 0xAF,
+	0x30, 0x30, 0x40, 0xAF,
 
-0x24, 0x1F, 0x24, 0xDF,
-0x1D, 0x32, 0x20, 0xE9,
+	0x24, 0x1F, 0x24, 0xDF,
+	0x1D, 0x32, 0x20, 0xE9,
 
-0x2C, 0x1F, 0x2C, 0xDF,
-0x1A, 0x33, 0x20, 0xE9,
+	0x2C, 0x1F, 0x2C, 0xDF,
+	0x1A, 0x33, 0x20, 0xE9,
 
-0xB0, 0x10,
-0x08, 0xE3,
-0x40, 0x10,
-0xB8, 0x10,
+	0xB0, 0x10,
+	0x08, 0xE3,
+	0x40, 0x10,
+	0xB8, 0x10,
 
-0x26, 0xF0, 0x30, 0xCD,
-0x2F, 0xF0, 0x38, 0xCD,
+	0x26, 0xF0, 0x30, 0xCD,
+	0x2F, 0xF0, 0x38, 0xCD,
 
-0x2B, 0x80, 0x20, 0xE9,
-0x2A, 0x80, 0x20, 0xE9,
+	0x2B, 0x80, 0x20, 0xE9,
+	0x2A, 0x80, 0x20, 0xE9,
 
-0xA6, 0x20,
-0x88, 0xE2,
-0x00, 0xE0,
-0xAF, 0x20,
+	0xA6, 0x20,
+	0x88, 0xE2,
+	0x00, 0xE0,
+	0xAF, 0x20,
 
-0x28, 0x2A, 0x26, 0xAF,
-0x20, 0x2A, 0xC0, 0xAF,
+	0x28, 0x2A, 0x26, 0xAF,
+	0x20, 0x2A, 0xC0, 0xAF,
 
-0x34, 0x1F, 0x34, 0xDF,
-0x46, 0x24, 0x46, 0xDF,
+	0x34, 0x1F, 0x34, 0xDF,
+	0x46, 0x24, 0x46, 0xDF,
 
-0x28, 0x30, 0x80, 0xBF,
-0x20, 0x38, 0x80, 0xBF,
+	0x28, 0x30, 0x80, 0xBF,
+	0x20, 0x38, 0x80, 0xBF,
 
-0x47, 0x24, 0x47, 0xDF,
-0x4E, 0x2C, 0x4E, 0xDF,
+	0x47, 0x24, 0x47, 0xDF,
+	0x4E, 0x2C, 0x4E, 0xDF,
 
-0x4F, 0x2C, 0x4F, 0xDF,
-0x56, 0x34, 0x56, 0xDF,
+	0x4F, 0x2C, 0x4F, 0xDF,
+	0x56, 0x34, 0x56, 0xDF,
 
-0x28, 0x15, 0x28, 0xDF,
-0x20, 0x1D, 0x20, 0xDF,
+	0x28, 0x15, 0x28, 0xDF,
+	0x20, 0x1D, 0x20, 0xDF,
 
-0x57, 0x34, 0x57, 0xDF,
-0x00, 0xE0,
-0x1D, 0x05,
+	0x57, 0x34, 0x57, 0xDF,
+	0x00, 0xE0,
+	0x1D, 0x05,
 
-0x04, 0x80, 0x10, 0xEA,
-0x89, 0xE2,
-0x2B, 0x30,
+	0x04, 0x80, 0x10, 0xEA,
+	0x89, 0xE2,
+	0x2B, 0x30,
 
-0x3F, 0xC1, 0x1D, 0xBD,
-0x00, 0x80, 0x00, 0xE8,
+	0x3F, 0xC1, 0x1D, 0xBD,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xA0, 0x68,
-0xBF, 0x25,
-0x00, 0x80, 0x00, 0xE8,
+	0xA0, 0x68,
+	0xBF, 0x25,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x20, 0xC0, 0x20, 0xAF,
-0x28, 0x05,
-0x97, 0x74,
+	0x20, 0xC0, 0x20, 0xAF,
+	0x28, 0x05,
+	0x97, 0x74,
 
-0x00, 0xE0,
-0x2A, 0x10,
-0x16, 0xC0, 0x20, 0xE9,
+	0x00, 0xE0,
+	0x2A, 0x10,
+	0x16, 0xC0, 0x20, 0xE9,
 
-0x04, 0x80, 0x10, 0xEA,
-0x8C, 0xE2,
-0x95, 0x05,
+	0x04, 0x80, 0x10, 0xEA,
+	0x8C, 0xE2,
+	0x95, 0x05,
 
-0x28, 0xC1, 0x28, 0xAD,
-0x1F, 0xC1, 0x15, 0xBD,
+	0x28, 0xC1, 0x28, 0xAD,
+	0x1F, 0xC1, 0x15, 0xBD,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xA8, 0x67,
-0x9F, 0x6B,
-0x00, 0x80, 0x00, 0xE8,
+	0xA8, 0x67,
+	0x9F, 0x6B,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x28, 0xC0, 0x28, 0xAD,
-0x1D, 0x25,
-0x20, 0x05,
+	0x28, 0xC0, 0x28, 0xAD,
+	0x1D, 0x25,
+	0x20, 0x05,
 
-0x28, 0x32, 0x80, 0xAD,
-0x40, 0x2A, 0x40, 0xBD,
+	0x28, 0x32, 0x80, 0xAD,
+	0x40, 0x2A, 0x40, 0xBD,
 
-0x1C, 0x80, 0x20, 0xE9,
-0x20, 0x33, 0x20, 0xAD,
+	0x1C, 0x80, 0x20, 0xE9,
+	0x20, 0x33, 0x20, 0xAD,
 
-0x20, 0x73,
-0x00, 0xE0,
-0xB6, 0x49, 0x51, 0xBB,
+	0x20, 0x73,
+	0x00, 0xE0,
+	0xB6, 0x49, 0x51, 0xBB,
 
-0x26, 0x2F, 0xB0, 0xE8,
-0x19, 0x20, 0x20, 0xE9,
+	0x26, 0x2F, 0xB0, 0xE8,
+	0x19, 0x20, 0x20, 0xE9,
 
-0x35, 0x20, 0x35, 0xDF,
-0x3D, 0x20, 0x3D, 0xDF,
+	0x35, 0x20, 0x35, 0xDF,
+	0x3D, 0x20, 0x3D, 0xDF,
 
-0x15, 0x20, 0x15, 0xDF,
-0x1D, 0x20, 0x1D, 0xDF,
+	0x15, 0x20, 0x15, 0xDF,
+	0x1D, 0x20, 0x1D, 0xDF,
 
-0x26, 0xD0, 0x26, 0xCD,
-0x29, 0x49, 0x2A, 0xB8,
+	0x26, 0xD0, 0x26, 0xCD,
+	0x29, 0x49, 0x2A, 0xB8,
 
-0x26, 0x40, 0x80, 0xBD,
-0x3B, 0x48, 0x50, 0xBD,
+	0x26, 0x40, 0x80, 0xBD,
+	0x3B, 0x48, 0x50, 0xBD,
 
-0x3E, 0x54, 0x57, 0x9F,
-0x00, 0xE0,
-0x82, 0xE1,
+	0x3E, 0x54, 0x57, 0x9F,
+	0x00, 0xE0,
+	0x82, 0xE1,
 
-0x1E, 0xAF, 0x59, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x1E, 0xAF, 0x59, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x26, 0x30,
-0x29, 0x30,
-0x48, 0x3C, 0x48, 0xAD,
+	0x26, 0x30,
+	0x29, 0x30,
+	0x48, 0x3C, 0x48, 0xAD,
 
-0x2B, 0x72,
-0xC2, 0xE1,
-0x2C, 0xC0, 0x44, 0xC2,
+	0x2B, 0x72,
+	0xC2, 0xE1,
+	0x2C, 0xC0, 0x44, 0xC2,
 
-0x05, 0x24, 0x34, 0xBF,
-0x0D, 0x24, 0x2C, 0xBF,
+	0x05, 0x24, 0x34, 0xBF,
+	0x0D, 0x24, 0x2C, 0xBF,
 
-0x2D, 0x46, 0x4E, 0xBF,
-0x25, 0x46, 0x56, 0xBF,
+	0x2D, 0x46, 0x4E, 0xBF,
+	0x25, 0x46, 0x56, 0xBF,
 
-0x20, 0x1D, 0x6F, 0x8F,
-0x32, 0x3E, 0x5F, 0xE9,
+	0x20, 0x1D, 0x6F, 0x8F,
+	0x32, 0x3E, 0x5F, 0xE9,
 
-0x3E, 0x50, 0x56, 0x9F,
-0x00, 0xE0,
-0x3B, 0x30,
+	0x3E, 0x50, 0x56, 0x9F,
+	0x00, 0xE0,
+	0x3B, 0x30,
 
-0x1E, 0x8F, 0x51, 0x9F,
-0x33, 0x1E, 0x5F, 0xE9,
+	0x1E, 0x8F, 0x51, 0x9F,
+	0x33, 0x1E, 0x5F, 0xE9,
 
-0x05, 0x44, 0x54, 0xB2,
-0x0D, 0x44, 0x4C, 0xB2,
+	0x05, 0x44, 0x54, 0xB2,
+	0x0D, 0x44, 0x4C, 0xB2,
 
-0x19, 0xC0, 0xB0, 0xE8,
-0x34, 0xC0, 0x44, 0xC4,
+	0x19, 0xC0, 0xB0, 0xE8,
+	0x34, 0xC0, 0x44, 0xC4,
 
-0x33, 0x73,
-0x00, 0xE0,
-0x3E, 0x62, 0x57, 0x9F,
+	0x33, 0x73,
+	0x00, 0xE0,
+	0x3E, 0x62, 0x57, 0x9F,
 
-0x1E, 0xAF, 0x59, 0x9F,
-0x00, 0xE0,
-0x0D, 0x20,
+	0x1E, 0xAF, 0x59, 0x9F,
+	0x00, 0xE0,
+	0x0D, 0x20,
 
-0x84, 0x3E, 0x58, 0xE9,
-0x28, 0x1D, 0x6F, 0x8F,
+	0x84, 0x3E, 0x58, 0xE9,
+	0x28, 0x1D, 0x6F, 0x8F,
 
-0x05, 0x20,
-0x00, 0xE0,
-0x85, 0x1E, 0x58, 0xE9,
+	0x05, 0x20,
+	0x00, 0xE0,
+	0x85, 0x1E, 0x58, 0xE9,
 
-0x9B, 0x3B, 0x33, 0xDF,
-0x20, 0x20, 0x42, 0xAF,
+	0x9B, 0x3B, 0x33, 0xDF,
+	0x20, 0x20, 0x42, 0xAF,
 
-0x30, 0x42, 0x56, 0x9F,
-0x80, 0x3E, 0x57, 0xE9,
+	0x30, 0x42, 0x56, 0x9F,
+	0x80, 0x3E, 0x57, 0xE9,
 
-0x3F, 0x8F, 0x51, 0x9F,
-0x30, 0x80, 0x5F, 0xE9,
+	0x3F, 0x8F, 0x51, 0x9F,
+	0x30, 0x80, 0x5F, 0xE9,
 
-0x28, 0x28, 0x24, 0xAF,
-0x81, 0x1E, 0x57, 0xE9,
+	0x28, 0x28, 0x24, 0xAF,
+	0x81, 0x1E, 0x57, 0xE9,
 
-0x05, 0x47, 0x57, 0xBF,
-0x0D, 0x47, 0x4F, 0xBF,
+	0x05, 0x47, 0x57, 0xBF,
+	0x0D, 0x47, 0x4F, 0xBF,
 
-0x88, 0x80, 0x58, 0xE9,
-0x1B, 0x29, 0x1B, 0xDF,
+	0x88, 0x80, 0x58, 0xE9,
+	0x1B, 0x29, 0x1B, 0xDF,
 
-0x30, 0x1D, 0x6F, 0x8F,
-0x3A, 0x30, 0x4F, 0xE9,
+	0x30, 0x1D, 0x6F, 0x8F,
+	0x3A, 0x30, 0x4F, 0xE9,
 
-0x1C, 0x30, 0x26, 0xDF,
-0x09, 0xE3,
-0x3B, 0x05,
+	0x1C, 0x30, 0x26, 0xDF,
+	0x09, 0xE3,
+	0x3B, 0x05,
 
-0x3E, 0x50, 0x56, 0x9F,
-0x3B, 0x3F, 0x4F, 0xE9,
+	0x3E, 0x50, 0x56, 0x9F,
+	0x3B, 0x3F, 0x4F, 0xE9,
 
-0x1E, 0x8F, 0x51, 0x9F,
-0x00, 0xE0,
-0xAC, 0x20,
+	0x1E, 0x8F, 0x51, 0x9F,
+	0x00, 0xE0,
+	0xAC, 0x20,
 
-0x2D, 0x44, 0x4C, 0xB4,
-0x2C, 0x1C, 0xC0, 0xAF,
+	0x2D, 0x44, 0x4C, 0xB4,
+	0x2C, 0x1C, 0xC0, 0xAF,
 
-0x25, 0x44, 0x54, 0xB4,
-0x00, 0xE0,
-0xC8, 0x30,
+	0x25, 0x44, 0x54, 0xB4,
+	0x00, 0xE0,
+	0xC8, 0x30,
 
-0x30, 0x46, 0x30, 0xAF,
-0x1B, 0x1B, 0x48, 0xAF,
+	0x30, 0x46, 0x30, 0xAF,
+	0x1B, 0x1B, 0x48, 0xAF,
 
-0x00, 0xE0,
-0x25, 0x20,
-0x38, 0x2C, 0x4F, 0xE9,
+	0x00, 0xE0,
+	0x25, 0x20,
+	0x38, 0x2C, 0x4F, 0xE9,
 
-0x86, 0x80, 0x57, 0xE9,
-0x38, 0x1D, 0x6F, 0x8F,
+	0x86, 0x80, 0x57, 0xE9,
+	0x38, 0x1D, 0x6F, 0x8F,
 
-0x28, 0x74,
-0x00, 0xE0,
-0x0D, 0x44, 0x4C, 0xB0,
+	0x28, 0x74,
+	0x00, 0xE0,
+	0x0D, 0x44, 0x4C, 0xB0,
 
-0x05, 0x44, 0x54, 0xB0,
-0x2D, 0x20,
-0x9B, 0x10,
+	0x05, 0x44, 0x54, 0xB0,
+	0x2D, 0x20,
+	0x9B, 0x10,
 
-0x82, 0x3E, 0x57, 0xE9,
-0x32, 0xF0, 0x1B, 0xCD,
+	0x82, 0x3E, 0x57, 0xE9,
+	0x32, 0xF0, 0x1B, 0xCD,
 
-0x1E, 0xBD, 0x59, 0x9F,
-0x83, 0x1E, 0x57, 0xE9,
+	0x1E, 0xBD, 0x59, 0x9F,
+	0x83, 0x1E, 0x57, 0xE9,
 
-0x38, 0x47, 0x38, 0xAF,
-0x34, 0x20,
-0x2A, 0x30,
+	0x38, 0x47, 0x38, 0xAF,
+	0x34, 0x20,
+	0x2A, 0x30,
 
-0x00, 0xE0,
-0x0D, 0x20,
-0x32, 0x20,
-0x05, 0x20,
+	0x00, 0xE0,
+	0x0D, 0x20,
+	0x32, 0x20,
+	0x05, 0x20,
 
-0x87, 0x80, 0x57, 0xE9,
-0x1F, 0x54, 0x57, 0x9F,
+	0x87, 0x80, 0x57, 0xE9,
+	0x1F, 0x54, 0x57, 0x9F,
 
-0x17, 0x42, 0x56, 0x9F,
-0x00, 0xE0,
-0x3B, 0x6A,
+	0x17, 0x42, 0x56, 0x9F,
+	0x00, 0xE0,
+	0x3B, 0x6A,
 
-0x3F, 0x8F, 0x51, 0x9F,
-0x37, 0x1E, 0x4F, 0xE9,
+	0x3F, 0x8F, 0x51, 0x9F,
+	0x37, 0x1E, 0x4F, 0xE9,
 
-0x37, 0x32, 0x2A, 0xAF,
-0x00, 0xE0,
-0x32, 0x00,
+	0x37, 0x32, 0x2A, 0xAF,
+	0x00, 0xE0,
+	0x32, 0x00,
 
-0x00, 0x80, 0x00, 0xE8,
-0x27, 0xC0, 0x44, 0xC0,
+	0x00, 0x80, 0x00, 0xE8,
+	0x27, 0xC0, 0x44, 0xC0,
 
-0x36, 0x1F, 0x4F, 0xE9,
-0x1F, 0x1F, 0x26, 0xDF,
+	0x36, 0x1F, 0x4F, 0xE9,
+	0x1F, 0x1F, 0x26, 0xDF,
 
-0x37, 0x1B, 0x37, 0xBF,
-0x17, 0x26, 0x17, 0xDF,
+	0x37, 0x1B, 0x37, 0xBF,
+	0x17, 0x26, 0x17, 0xDF,
 
-0x3E, 0x17, 0x4F, 0xE9,
-0x3F, 0x3F, 0x4F, 0xE9,
+	0x3E, 0x17, 0x4F, 0xE9,
+	0x3F, 0x3F, 0x4F, 0xE9,
 
-0x34, 0x1F, 0x34, 0xAF,
-0x2B, 0x05,
-0xA7, 0x20,
+	0x34, 0x1F, 0x34, 0xAF,
+	0x2B, 0x05,
+	0xA7, 0x20,
 
-0x33, 0x2B, 0x37, 0xDF,
-0x27, 0x17, 0xC0, 0xAF,
+	0x33, 0x2B, 0x37, 0xDF,
+	0x27, 0x17, 0xC0, 0xAF,
 
-0x34, 0x80, 0x4F, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0x34, 0x80, 0x4F, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x2D, 0x44, 0x4C, 0xB6,
-0x25, 0x44, 0x54, 0xB6,
+	0x2D, 0x44, 0x4C, 0xB6,
+	0x25, 0x44, 0x54, 0xB6,
 
-0x03, 0x80, 0x2A, 0xEA,
-0x17, 0xC1, 0x2B, 0xBD,
+	0x03, 0x80, 0x2A, 0xEA,
+	0x17, 0xC1, 0x2B, 0xBD,
 
-0x2D, 0x20,
-0x25, 0x20,
-0x07, 0xC0, 0x44, 0xC6,
+	0x2D, 0x20,
+	0x25, 0x20,
+	0x07, 0xC0, 0x44, 0xC6,
 
-0xB3, 0x68,
-0x97, 0x25,
-0x00, 0x80, 0x00, 0xE8,
+	0xB3, 0x68,
+	0x97, 0x25,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x33, 0xC0, 0x33, 0xAF,
-0x3C, 0x27, 0x4F, 0xE9,
+	0x33, 0xC0, 0x33, 0xAF,
+	0x3C, 0x27, 0x4F, 0xE9,
 
-0x1F, 0x62, 0x57, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x1F, 0x62, 0x57, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x3F, 0x3D, 0x5D, 0x9F,
-0x00, 0xE0,
-0x07, 0x20,
+	0x3F, 0x3D, 0x5D, 0x9F,
+	0x00, 0xE0,
+	0x07, 0x20,
 
-0x00, 0x80, 0x00, 0xE8,
-0x28, 0x19, 0x60, 0xEC,
+	0x00, 0x80, 0x00, 0xE8,
+	0x28, 0x19, 0x60, 0xEC,
 
-0xB3, 0x05,
-0x00, 0xE0,
-0x00, 0x80, 0x00, 0xE8,
+	0xB3, 0x05,
+	0x00, 0xE0,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x23, 0x3B, 0x33, 0xAD,
-0x00, 0x80, 0x00, 0xE8,
+	0x23, 0x3B, 0x33, 0xAD,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x1F, 0x26, 0x1F, 0xDF,
-0x9D, 0x1F, 0x4F, 0xE9,
+	0x1F, 0x26, 0x1F, 0xDF,
+	0x9D, 0x1F, 0x4F, 0xE9,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x9E, 0x3F, 0x4F, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+	0x9E, 0x3F, 0x4F, 0xE9,
 
-0x07, 0x07, 0x1F, 0xAF,
-0x00, 0x80, 0x00, 0xE8,
+	0x07, 0x07, 0x1F, 0xAF,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x9C, 0x80, 0x4F, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0x9C, 0x80, 0x4F, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x57, 0x39, 0x20, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+	0x57, 0x39, 0x20, 0xE9,
 
-0x16, 0x28, 0x20, 0xE9,
-0x1D, 0x3B, 0x20, 0xE9,
+	0x16, 0x28, 0x20, 0xE9,
+	0x1D, 0x3B, 0x20, 0xE9,
 
-0x1E, 0x2B, 0x20, 0xE9,
-0x2B, 0x32, 0x20, 0xE9,
+	0x1E, 0x2B, 0x20, 0xE9,
+	0x2B, 0x32, 0x20, 0xE9,
 
-0x1C, 0x23, 0x20, 0xE9,
-0x57, 0x36, 0x20, 0xE9,
+	0x1C, 0x23, 0x20, 0xE9,
+	0x57, 0x36, 0x20, 0xE9,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x40, 0x40, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x40, 0x40, 0xD8, 0xEC,
 
-0xFF, 0x80, 0xC0, 0xE9,
-0x90, 0xE2,
-0x00, 0xE0,
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x90, 0xE2,
+	0x00, 0xE0,
 
-0x7A, 0xFF, 0x20, 0xEA,
-0x19, 0xC8, 0xC1, 0xCD,
+	0x7A, 0xFF, 0x20, 0xEA,
+	0x19, 0xC8, 0xC1, 0xCD,
 
-0x1F, 0xD7, 0x18, 0xBD,
-0x3F, 0xD7, 0x22, 0xBD,
+	0x1F, 0xD7, 0x18, 0xBD,
+	0x3F, 0xD7, 0x22, 0xBD,
 
-0x9F, 0x41, 0x49, 0xBD,
-0x00, 0x80, 0x00, 0xE8,
+	0x9F, 0x41, 0x49, 0xBD,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x25, 0x41, 0x49, 0xBD,
-0x2D, 0x41, 0x51, 0xBD,
+	0x25, 0x41, 0x49, 0xBD,
+	0x2D, 0x41, 0x51, 0xBD,
 
-0x0D, 0x80, 0x07, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0x0D, 0x80, 0x07, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x35, 0x40, 0x48, 0xBD,
-0x3D, 0x40, 0x50, 0xBD,
+	0x35, 0x40, 0x48, 0xBD,
+	0x3D, 0x40, 0x50, 0xBD,
 
-0x00, 0x80, 0x00, 0xE8,
-0x25, 0x30,
-0x2D, 0x30,
+	0x00, 0x80, 0x00, 0xE8,
+	0x25, 0x30,
+	0x2D, 0x30,
 
-0x35, 0x30,
-0xB5, 0x30,
-0xBD, 0x30,
-0x3D, 0x30,
+	0x35, 0x30,
+	0xB5, 0x30,
+	0xBD, 0x30,
+	0x3D, 0x30,
 
-0x9C, 0xA7, 0x5B, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x9C, 0xA7, 0x5B, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x79, 0xFF, 0x0A, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0x79, 0xFF, 0x0A, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xC9, 0x41, 0xC8, 0xEC,
-0x42, 0xE1,
-0x00, 0xE0,
+	0xC9, 0x41, 0xC8, 0xEC,
+	0x42, 0xE1,
+	0x00, 0xE0,
 
-0x77, 0xFF, 0x20, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0x77, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xC8, 0x40, 0xC0, 0xEC,
-0x00, 0x80, 0x00, 0xE8,
+	0xC8, 0x40, 0xC0, 0xEC,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x74, 0xFF, 0x20, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0x74, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
 };
 
 static unsigned char warp_g200_tgzaf[] = {
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x98, 0xA0, 0xE9,
-0x40, 0x40, 0xD8, 0xEC,
+	0x00, 0x98, 0xA0, 0xE9,
+	0x40, 0x40, 0xD8, 0xEC,
 
-0xFF, 0x80, 0xC0, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x1F, 0xD7, 0x18, 0xBD,
-0x3F, 0xD7, 0x22, 0xBD,
+	0x1F, 0xD7, 0x18, 0xBD,
+	0x3F, 0xD7, 0x22, 0xBD,
 
-0x81, 0x04,
-0x89, 0x04,
-0x01, 0x04,
-0x09, 0x04,
+	0x81, 0x04,
+	0x89, 0x04,
+	0x01, 0x04,
+	0x09, 0x04,
 
-0xC9, 0x41, 0xC0, 0xEC,
-0x11, 0x04,
-0x00, 0xE0,
+	0xC9, 0x41, 0xC0, 0xEC,
+	0x11, 0x04,
+	0x00, 0xE0,
 
-0x41, 0xCC, 0x41, 0xCD,
-0x49, 0xCC, 0x49, 0xCD,
+	0x41, 0xCC, 0x41, 0xCD,
+	0x49, 0xCC, 0x49, 0xCD,
 
-0xD1, 0x41, 0xC0, 0xEC,
-0x51, 0xCC, 0x51, 0xCD,
+	0xD1, 0x41, 0xC0, 0xEC,
+	0x51, 0xCC, 0x51, 0xCD,
 
-0x80, 0x04,
-0x10, 0x04,
-0x08, 0x04,
-0x00, 0xE0,
+	0x80, 0x04,
+	0x10, 0x04,
+	0x08, 0x04,
+	0x00, 0xE0,
 
-0x00, 0xCC, 0xC0, 0xCD,
-0xD1, 0x49, 0xC0, 0xEC,
+	0x00, 0xCC, 0xC0, 0xCD,
+	0xD1, 0x49, 0xC0, 0xEC,
 
-0x8A, 0x1F, 0x20, 0xE9,
-0x8B, 0x3F, 0x20, 0xE9,
+	0x8A, 0x1F, 0x20, 0xE9,
+	0x8B, 0x3F, 0x20, 0xE9,
 
-0x41, 0x3C, 0x41, 0xAD,
-0x49, 0x3C, 0x49, 0xAD,
+	0x41, 0x3C, 0x41, 0xAD,
+	0x49, 0x3C, 0x49, 0xAD,
 
-0x10, 0xCC, 0x10, 0xCD,
-0x08, 0xCC, 0x08, 0xCD,
+	0x10, 0xCC, 0x10, 0xCD,
+	0x08, 0xCC, 0x08, 0xCD,
 
-0xB9, 0x41, 0x49, 0xBB,
-0x1F, 0xF0, 0x41, 0xCD,
+	0xB9, 0x41, 0x49, 0xBB,
+	0x1F, 0xF0, 0x41, 0xCD,
 
-0x51, 0x3C, 0x51, 0xAD,
-0x00, 0x98, 0x80, 0xE9,
+	0x51, 0x3C, 0x51, 0xAD,
+	0x00, 0x98, 0x80, 0xE9,
 
-0x83, 0x80, 0x07, 0xEA,
-0x24, 0x1F, 0x20, 0xE9,
+	0x83, 0x80, 0x07, 0xEA,
+	0x24, 0x1F, 0x20, 0xE9,
 
-0x21, 0x45, 0x80, 0xE8,
-0x1A, 0x4D, 0x80, 0xE8,
+	0x21, 0x45, 0x80, 0xE8,
+	0x1A, 0x4D, 0x80, 0xE8,
 
-0x31, 0x55, 0x80, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x31, 0x55, 0x80, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x15, 0x41, 0x49, 0xBD,
-0x1D, 0x41, 0x51, 0xBD,
+	0x15, 0x41, 0x49, 0xBD,
+	0x1D, 0x41, 0x51, 0xBD,
 
-0x2E, 0x41, 0x2A, 0xB8,
-0x34, 0x53, 0xA0, 0xE8,
+	0x2E, 0x41, 0x2A, 0xB8,
+	0x34, 0x53, 0xA0, 0xE8,
 
-0x15, 0x30,
-0x1D, 0x30,
-0x58, 0xE3,
-0x00, 0xE0,
+	0x15, 0x30,
+	0x1D, 0x30,
+	0x58, 0xE3,
+	0x00, 0xE0,
 
-0xB5, 0x40, 0x48, 0xBD,
-0x3D, 0x40, 0x50, 0xBD,
+	0xB5, 0x40, 0x48, 0xBD,
+	0x3D, 0x40, 0x50, 0xBD,
 
-0x24, 0x43, 0xA0, 0xE8,
-0x2C, 0x4B, 0xA0, 0xE8,
+	0x24, 0x43, 0xA0, 0xE8,
+	0x2C, 0x4B, 0xA0, 0xE8,
 
-0x15, 0x72,
-0x09, 0xE3,
-0x00, 0xE0,
-0x1D, 0x72,
+	0x15, 0x72,
+	0x09, 0xE3,
+	0x00, 0xE0,
+	0x1D, 0x72,
 
-0x35, 0x30,
-0xB5, 0x30,
-0xBD, 0x30,
-0x3D, 0x30,
+	0x35, 0x30,
+	0xB5, 0x30,
+	0xBD, 0x30,
+	0x3D, 0x30,
 
-0x9C, 0x97, 0x57, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x9C, 0x97, 0x57, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x6C, 0x64, 0xC8, 0xEC,
-0x98, 0xE1,
-0xB5, 0x05,
+	0x6C, 0x64, 0xC8, 0xEC,
+	0x98, 0xE1,
+	0xB5, 0x05,
 
-0xBD, 0x05,
-0x2E, 0x30,
-0x32, 0xC0, 0xA0, 0xE8,
+	0xBD, 0x05,
+	0x2E, 0x30,
+	0x32, 0xC0, 0xA0, 0xE8,
 
-0x33, 0xC0, 0xA0, 0xE8,
-0x74, 0x64, 0xC8, 0xEC,
+	0x33, 0xC0, 0xA0, 0xE8,
+	0x74, 0x64, 0xC8, 0xEC,
 
-0x40, 0x3C, 0x40, 0xAD,
-0x32, 0x6A,
-0x2A, 0x30,
+	0x40, 0x3C, 0x40, 0xAD,
+	0x32, 0x6A,
+	0x2A, 0x30,
 
-0x20, 0x73,
-0x33, 0x6A,
-0x00, 0xE0,
-0x28, 0x73,
+	0x20, 0x73,
+	0x33, 0x6A,
+	0x00, 0xE0,
+	0x28, 0x73,
 
-0x1C, 0x72,
-0x83, 0xE2,
-0x6F, 0x80, 0x15, 0xEA,
+	0x1C, 0x72,
+	0x83, 0xE2,
+	0x6F, 0x80, 0x15, 0xEA,
 
-0xB8, 0x3D, 0x28, 0xDF,
-0x30, 0x35, 0x20, 0xDF,
+	0xB8, 0x3D, 0x28, 0xDF,
+	0x30, 0x35, 0x20, 0xDF,
 
-0x40, 0x30,
-0x00, 0xE0,
-0xCC, 0xE2,
-0x64, 0x72,
+	0x40, 0x30,
+	0x00, 0xE0,
+	0xCC, 0xE2,
+	0x64, 0x72,
 
-0x25, 0x42, 0x52, 0xBF,
-0x2D, 0x42, 0x4A, 0xBF,
+	0x25, 0x42, 0x52, 0xBF,
+	0x2D, 0x42, 0x4A, 0xBF,
 
-0x30, 0x2E, 0x30, 0xDF,
-0x38, 0x2E, 0x38, 0xDF,
+	0x30, 0x2E, 0x30, 0xDF,
+	0x38, 0x2E, 0x38, 0xDF,
 
-0x18, 0x1D, 0x45, 0xE9,
-0x1E, 0x15, 0x45, 0xE9,
+	0x18, 0x1D, 0x45, 0xE9,
+	0x1E, 0x15, 0x45, 0xE9,
 
-0x2B, 0x49, 0x51, 0xBD,
-0x00, 0xE0,
-0x1F, 0x73,
+	0x2B, 0x49, 0x51, 0xBD,
+	0x00, 0xE0,
+	0x1F, 0x73,
 
-0x38, 0x38, 0x40, 0xAF,
-0x30, 0x30, 0x40, 0xAF,
+	0x38, 0x38, 0x40, 0xAF,
+	0x30, 0x30, 0x40, 0xAF,
 
-0x24, 0x1F, 0x24, 0xDF,
-0x1D, 0x32, 0x20, 0xE9,
+	0x24, 0x1F, 0x24, 0xDF,
+	0x1D, 0x32, 0x20, 0xE9,
 
-0x2C, 0x1F, 0x2C, 0xDF,
-0x1A, 0x33, 0x20, 0xE9,
+	0x2C, 0x1F, 0x2C, 0xDF,
+	0x1A, 0x33, 0x20, 0xE9,
 
-0xB0, 0x10,
-0x08, 0xE3,
-0x40, 0x10,
-0xB8, 0x10,
+	0xB0, 0x10,
+	0x08, 0xE3,
+	0x40, 0x10,
+	0xB8, 0x10,
 
-0x26, 0xF0, 0x30, 0xCD,
-0x2F, 0xF0, 0x38, 0xCD,
+	0x26, 0xF0, 0x30, 0xCD,
+	0x2F, 0xF0, 0x38, 0xCD,
 
-0x2B, 0x80, 0x20, 0xE9,
-0x2A, 0x80, 0x20, 0xE9,
+	0x2B, 0x80, 0x20, 0xE9,
+	0x2A, 0x80, 0x20, 0xE9,
 
-0xA6, 0x20,
-0x88, 0xE2,
-0x00, 0xE0,
-0xAF, 0x20,
+	0xA6, 0x20,
+	0x88, 0xE2,
+	0x00, 0xE0,
+	0xAF, 0x20,
 
-0x28, 0x2A, 0x26, 0xAF,
-0x20, 0x2A, 0xC0, 0xAF,
+	0x28, 0x2A, 0x26, 0xAF,
+	0x20, 0x2A, 0xC0, 0xAF,
 
-0x34, 0x1F, 0x34, 0xDF,
-0x46, 0x24, 0x46, 0xDF,
+	0x34, 0x1F, 0x34, 0xDF,
+	0x46, 0x24, 0x46, 0xDF,
 
-0x28, 0x30, 0x80, 0xBF,
-0x20, 0x38, 0x80, 0xBF,
+	0x28, 0x30, 0x80, 0xBF,
+	0x20, 0x38, 0x80, 0xBF,
 
-0x47, 0x24, 0x47, 0xDF,
-0x4E, 0x2C, 0x4E, 0xDF,
+	0x47, 0x24, 0x47, 0xDF,
+	0x4E, 0x2C, 0x4E, 0xDF,
 
-0x4F, 0x2C, 0x4F, 0xDF,
-0x56, 0x34, 0x56, 0xDF,
+	0x4F, 0x2C, 0x4F, 0xDF,
+	0x56, 0x34, 0x56, 0xDF,
 
-0x28, 0x15, 0x28, 0xDF,
-0x20, 0x1D, 0x20, 0xDF,
+	0x28, 0x15, 0x28, 0xDF,
+	0x20, 0x1D, 0x20, 0xDF,
 
-0x57, 0x34, 0x57, 0xDF,
-0x00, 0xE0,
-0x1D, 0x05,
+	0x57, 0x34, 0x57, 0xDF,
+	0x00, 0xE0,
+	0x1D, 0x05,
 
-0x04, 0x80, 0x10, 0xEA,
-0x89, 0xE2,
-0x2B, 0x30,
+	0x04, 0x80, 0x10, 0xEA,
+	0x89, 0xE2,
+	0x2B, 0x30,
 
-0x3F, 0xC1, 0x1D, 0xBD,
-0x00, 0x80, 0x00, 0xE8,
+	0x3F, 0xC1, 0x1D, 0xBD,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xA0, 0x68,
-0xBF, 0x25,
-0x00, 0x80, 0x00, 0xE8,
+	0xA0, 0x68,
+	0xBF, 0x25,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x20, 0xC0, 0x20, 0xAF,
-0x28, 0x05,
-0x97, 0x74,
+	0x20, 0xC0, 0x20, 0xAF,
+	0x28, 0x05,
+	0x97, 0x74,
 
-0x00, 0xE0,
-0x2A, 0x10,
-0x16, 0xC0, 0x20, 0xE9,
+	0x00, 0xE0,
+	0x2A, 0x10,
+	0x16, 0xC0, 0x20, 0xE9,
 
-0x04, 0x80, 0x10, 0xEA,
-0x8C, 0xE2,
-0x95, 0x05,
+	0x04, 0x80, 0x10, 0xEA,
+	0x8C, 0xE2,
+	0x95, 0x05,
 
-0x28, 0xC1, 0x28, 0xAD,
-0x1F, 0xC1, 0x15, 0xBD,
+	0x28, 0xC1, 0x28, 0xAD,
+	0x1F, 0xC1, 0x15, 0xBD,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xA8, 0x67,
-0x9F, 0x6B,
-0x00, 0x80, 0x00, 0xE8,
+	0xA8, 0x67,
+	0x9F, 0x6B,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x28, 0xC0, 0x28, 0xAD,
-0x1D, 0x25,
-0x20, 0x05,
+	0x28, 0xC0, 0x28, 0xAD,
+	0x1D, 0x25,
+	0x20, 0x05,
 
-0x28, 0x32, 0x80, 0xAD,
-0x40, 0x2A, 0x40, 0xBD,
+	0x28, 0x32, 0x80, 0xAD,
+	0x40, 0x2A, 0x40, 0xBD,
 
-0x1C, 0x80, 0x20, 0xE9,
-0x20, 0x33, 0x20, 0xAD,
+	0x1C, 0x80, 0x20, 0xE9,
+	0x20, 0x33, 0x20, 0xAD,
 
-0x20, 0x73,
-0x00, 0xE0,
-0xB6, 0x49, 0x51, 0xBB,
+	0x20, 0x73,
+	0x00, 0xE0,
+	0xB6, 0x49, 0x51, 0xBB,
 
-0x26, 0x2F, 0xB0, 0xE8,
-0x19, 0x20, 0x20, 0xE9,
+	0x26, 0x2F, 0xB0, 0xE8,
+	0x19, 0x20, 0x20, 0xE9,
 
-0x35, 0x20, 0x35, 0xDF,
-0x3D, 0x20, 0x3D, 0xDF,
+	0x35, 0x20, 0x35, 0xDF,
+	0x3D, 0x20, 0x3D, 0xDF,
 
-0x15, 0x20, 0x15, 0xDF,
-0x1D, 0x20, 0x1D, 0xDF,
+	0x15, 0x20, 0x15, 0xDF,
+	0x1D, 0x20, 0x1D, 0xDF,
 
-0x26, 0xD0, 0x26, 0xCD,
-0x29, 0x49, 0x2A, 0xB8,
+	0x26, 0xD0, 0x26, 0xCD,
+	0x29, 0x49, 0x2A, 0xB8,
 
-0x26, 0x40, 0x80, 0xBD,
-0x3B, 0x48, 0x50, 0xBD,
+	0x26, 0x40, 0x80, 0xBD,
+	0x3B, 0x48, 0x50, 0xBD,
 
-0x3E, 0x54, 0x57, 0x9F,
-0x00, 0xE0,
-0x82, 0xE1,
+	0x3E, 0x54, 0x57, 0x9F,
+	0x00, 0xE0,
+	0x82, 0xE1,
 
-0x1E, 0xAF, 0x59, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x1E, 0xAF, 0x59, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x26, 0x30,
-0x29, 0x30,
-0x48, 0x3C, 0x48, 0xAD,
+	0x26, 0x30,
+	0x29, 0x30,
+	0x48, 0x3C, 0x48, 0xAD,
 
-0x2B, 0x72,
-0xC2, 0xE1,
-0x2C, 0xC0, 0x44, 0xC2,
+	0x2B, 0x72,
+	0xC2, 0xE1,
+	0x2C, 0xC0, 0x44, 0xC2,
 
-0x05, 0x24, 0x34, 0xBF,
-0x0D, 0x24, 0x2C, 0xBF,
+	0x05, 0x24, 0x34, 0xBF,
+	0x0D, 0x24, 0x2C, 0xBF,
 
-0x2D, 0x46, 0x4E, 0xBF,
-0x25, 0x46, 0x56, 0xBF,
+	0x2D, 0x46, 0x4E, 0xBF,
+	0x25, 0x46, 0x56, 0xBF,
 
-0x20, 0x1D, 0x6F, 0x8F,
-0x32, 0x3E, 0x5F, 0xE9,
+	0x20, 0x1D, 0x6F, 0x8F,
+	0x32, 0x3E, 0x5F, 0xE9,
 
-0x3E, 0x50, 0x56, 0x9F,
-0x00, 0xE0,
-0x3B, 0x30,
+	0x3E, 0x50, 0x56, 0x9F,
+	0x00, 0xE0,
+	0x3B, 0x30,
 
-0x1E, 0x8F, 0x51, 0x9F,
-0x33, 0x1E, 0x5F, 0xE9,
+	0x1E, 0x8F, 0x51, 0x9F,
+	0x33, 0x1E, 0x5F, 0xE9,
 
-0x05, 0x44, 0x54, 0xB2,
-0x0D, 0x44, 0x4C, 0xB2,
+	0x05, 0x44, 0x54, 0xB2,
+	0x0D, 0x44, 0x4C, 0xB2,
 
-0x19, 0xC0, 0xB0, 0xE8,
-0x34, 0xC0, 0x44, 0xC4,
+	0x19, 0xC0, 0xB0, 0xE8,
+	0x34, 0xC0, 0x44, 0xC4,
 
-0x33, 0x73,
-0x00, 0xE0,
-0x3E, 0x62, 0x57, 0x9F,
+	0x33, 0x73,
+	0x00, 0xE0,
+	0x3E, 0x62, 0x57, 0x9F,
 
-0x1E, 0xAF, 0x59, 0x9F,
-0x00, 0xE0,
-0x0D, 0x20,
+	0x1E, 0xAF, 0x59, 0x9F,
+	0x00, 0xE0,
+	0x0D, 0x20,
 
-0x84, 0x3E, 0x58, 0xE9,
-0x28, 0x1D, 0x6F, 0x8F,
+	0x84, 0x3E, 0x58, 0xE9,
+	0x28, 0x1D, 0x6F, 0x8F,
 
-0x05, 0x20,
-0x00, 0xE0,
-0x85, 0x1E, 0x58, 0xE9,
+	0x05, 0x20,
+	0x00, 0xE0,
+	0x85, 0x1E, 0x58, 0xE9,
 
-0x9B, 0x3B, 0x33, 0xDF,
-0x20, 0x20, 0x42, 0xAF,
+	0x9B, 0x3B, 0x33, 0xDF,
+	0x20, 0x20, 0x42, 0xAF,
 
-0x30, 0x42, 0x56, 0x9F,
-0x80, 0x3E, 0x57, 0xE9,
+	0x30, 0x42, 0x56, 0x9F,
+	0x80, 0x3E, 0x57, 0xE9,
 
-0x3F, 0x8F, 0x51, 0x9F,
-0x30, 0x80, 0x5F, 0xE9,
+	0x3F, 0x8F, 0x51, 0x9F,
+	0x30, 0x80, 0x5F, 0xE9,
 
-0x28, 0x28, 0x24, 0xAF,
-0x81, 0x1E, 0x57, 0xE9,
+	0x28, 0x28, 0x24, 0xAF,
+	0x81, 0x1E, 0x57, 0xE9,
 
-0x05, 0x47, 0x57, 0xBF,
-0x0D, 0x47, 0x4F, 0xBF,
+	0x05, 0x47, 0x57, 0xBF,
+	0x0D, 0x47, 0x4F, 0xBF,
 
-0x88, 0x80, 0x58, 0xE9,
-0x1B, 0x29, 0x1B, 0xDF,
+	0x88, 0x80, 0x58, 0xE9,
+	0x1B, 0x29, 0x1B, 0xDF,
 
-0x30, 0x1D, 0x6F, 0x8F,
-0x3A, 0x30, 0x4F, 0xE9,
+	0x30, 0x1D, 0x6F, 0x8F,
+	0x3A, 0x30, 0x4F, 0xE9,
 
-0x1C, 0x30, 0x26, 0xDF,
-0x09, 0xE3,
-0x3B, 0x05,
+	0x1C, 0x30, 0x26, 0xDF,
+	0x09, 0xE3,
+	0x3B, 0x05,
 
-0x3E, 0x50, 0x56, 0x9F,
-0x3B, 0x3F, 0x4F, 0xE9,
+	0x3E, 0x50, 0x56, 0x9F,
+	0x3B, 0x3F, 0x4F, 0xE9,
 
-0x1E, 0x8F, 0x51, 0x9F,
-0x00, 0xE0,
-0xAC, 0x20,
+	0x1E, 0x8F, 0x51, 0x9F,
+	0x00, 0xE0,
+	0xAC, 0x20,
 
-0x2D, 0x44, 0x4C, 0xB4,
-0x2C, 0x1C, 0xC0, 0xAF,
+	0x2D, 0x44, 0x4C, 0xB4,
+	0x2C, 0x1C, 0xC0, 0xAF,
 
-0x25, 0x44, 0x54, 0xB4,
-0x00, 0xE0,
-0xC8, 0x30,
+	0x25, 0x44, 0x54, 0xB4,
+	0x00, 0xE0,
+	0xC8, 0x30,
 
-0x30, 0x46, 0x30, 0xAF,
-0x1B, 0x1B, 0x48, 0xAF,
+	0x30, 0x46, 0x30, 0xAF,
+	0x1B, 0x1B, 0x48, 0xAF,
 
-0x00, 0xE0,
-0x25, 0x20,
-0x38, 0x2C, 0x4F, 0xE9,
+	0x00, 0xE0,
+	0x25, 0x20,
+	0x38, 0x2C, 0x4F, 0xE9,
 
-0x86, 0x80, 0x57, 0xE9,
-0x38, 0x1D, 0x6F, 0x8F,
+	0x86, 0x80, 0x57, 0xE9,
+	0x38, 0x1D, 0x6F, 0x8F,
 
-0x28, 0x74,
-0x00, 0xE0,
-0x0D, 0x44, 0x4C, 0xB0,
+	0x28, 0x74,
+	0x00, 0xE0,
+	0x0D, 0x44, 0x4C, 0xB0,
 
-0x05, 0x44, 0x54, 0xB0,
-0x2D, 0x20,
-0x9B, 0x10,
+	0x05, 0x44, 0x54, 0xB0,
+	0x2D, 0x20,
+	0x9B, 0x10,
 
-0x82, 0x3E, 0x57, 0xE9,
-0x32, 0xF0, 0x1B, 0xCD,
+	0x82, 0x3E, 0x57, 0xE9,
+	0x32, 0xF0, 0x1B, 0xCD,
 
-0x1E, 0xBD, 0x59, 0x9F,
-0x83, 0x1E, 0x57, 0xE9,
+	0x1E, 0xBD, 0x59, 0x9F,
+	0x83, 0x1E, 0x57, 0xE9,
 
-0x38, 0x47, 0x38, 0xAF,
-0x34, 0x20,
-0x2A, 0x30,
+	0x38, 0x47, 0x38, 0xAF,
+	0x34, 0x20,
+	0x2A, 0x30,
 
-0x00, 0xE0,
-0x0D, 0x20,
-0x32, 0x20,
-0x05, 0x20,
+	0x00, 0xE0,
+	0x0D, 0x20,
+	0x32, 0x20,
+	0x05, 0x20,
 
-0x87, 0x80, 0x57, 0xE9,
-0x1F, 0x54, 0x57, 0x9F,
+	0x87, 0x80, 0x57, 0xE9,
+	0x1F, 0x54, 0x57, 0x9F,
 
-0x17, 0x42, 0x56, 0x9F,
-0x00, 0xE0,
-0x3B, 0x6A,
+	0x17, 0x42, 0x56, 0x9F,
+	0x00, 0xE0,
+	0x3B, 0x6A,
 
-0x3F, 0x8F, 0x51, 0x9F,
-0x37, 0x1E, 0x4F, 0xE9,
+	0x3F, 0x8F, 0x51, 0x9F,
+	0x37, 0x1E, 0x4F, 0xE9,
 
-0x37, 0x32, 0x2A, 0xAF,
-0x00, 0xE0,
-0x32, 0x00,
+	0x37, 0x32, 0x2A, 0xAF,
+	0x00, 0xE0,
+	0x32, 0x00,
 
-0x00, 0x80, 0x00, 0xE8,
-0x27, 0xC0, 0x44, 0xC0,
+	0x00, 0x80, 0x00, 0xE8,
+	0x27, 0xC0, 0x44, 0xC0,
 
-0x36, 0x1F, 0x4F, 0xE9,
-0x1F, 0x1F, 0x26, 0xDF,
+	0x36, 0x1F, 0x4F, 0xE9,
+	0x1F, 0x1F, 0x26, 0xDF,
 
-0x37, 0x1B, 0x37, 0xBF,
-0x17, 0x26, 0x17, 0xDF,
+	0x37, 0x1B, 0x37, 0xBF,
+	0x17, 0x26, 0x17, 0xDF,
 
-0x3E, 0x17, 0x4F, 0xE9,
-0x3F, 0x3F, 0x4F, 0xE9,
+	0x3E, 0x17, 0x4F, 0xE9,
+	0x3F, 0x3F, 0x4F, 0xE9,
 
-0x34, 0x1F, 0x34, 0xAF,
-0x2B, 0x05,
-0xA7, 0x20,
+	0x34, 0x1F, 0x34, 0xAF,
+	0x2B, 0x05,
+	0xA7, 0x20,
 
-0x33, 0x2B, 0x37, 0xDF,
-0x27, 0x17, 0xC0, 0xAF,
+	0x33, 0x2B, 0x37, 0xDF,
+	0x27, 0x17, 0xC0, 0xAF,
 
-0x34, 0x80, 0x4F, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0x34, 0x80, 0x4F, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x0D, 0x21, 0x1A, 0xB6,
-0x05, 0x21, 0x31, 0xB6,
+	0x0D, 0x21, 0x1A, 0xB6,
+	0x05, 0x21, 0x31, 0xB6,
 
-0x2D, 0x44, 0x4C, 0xB6,
-0x25, 0x44, 0x54, 0xB6,
+	0x2D, 0x44, 0x4C, 0xB6,
+	0x25, 0x44, 0x54, 0xB6,
 
-0x03, 0x80, 0x2A, 0xEA,
-0x17, 0xC1, 0x2B, 0xBD,
+	0x03, 0x80, 0x2A, 0xEA,
+	0x17, 0xC1, 0x2B, 0xBD,
 
-0x0D, 0x20,
-0x05, 0x20,
-0x2F, 0xC0, 0x21, 0xC6,
+	0x0D, 0x20,
+	0x05, 0x20,
+	0x2F, 0xC0, 0x21, 0xC6,
 
-0xB3, 0x68,
-0x97, 0x25,
-0x00, 0x80, 0x00, 0xE8,
+	0xB3, 0x68,
+	0x97, 0x25,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x33, 0xC0, 0x33, 0xAF,
-0x3C, 0x27, 0x4F, 0xE9,
+	0x33, 0xC0, 0x33, 0xAF,
+	0x3C, 0x27, 0x4F, 0xE9,
 
-0x00, 0xE0,
-0x25, 0x20,
-0x07, 0xC0, 0x44, 0xC6,
+	0x00, 0xE0,
+	0x25, 0x20,
+	0x07, 0xC0, 0x44, 0xC6,
 
-0x17, 0x50, 0x56, 0x9F,
-0x00, 0xE0,
-0x2D, 0x20,
+	0x17, 0x50, 0x56, 0x9F,
+	0x00, 0xE0,
+	0x2D, 0x20,
 
-0x37, 0x0F, 0x5C, 0x9F,
-0x00, 0xE0,
-0x2F, 0x20,
+	0x37, 0x0F, 0x5C, 0x9F,
+	0x00, 0xE0,
+	0x2F, 0x20,
 
-0x1F, 0x62, 0x57, 0x9F,
-0x00, 0xE0,
-0x07, 0x20,
+	0x1F, 0x62, 0x57, 0x9F,
+	0x00, 0xE0,
+	0x07, 0x20,
 
-0x3F, 0x3D, 0x5D, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x3F, 0x3D, 0x5D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x28, 0x19, 0x60, 0xEC,
+	0x00, 0x80, 0x00, 0xE8,
+	0x28, 0x19, 0x60, 0xEC,
 
-0xB3, 0x05,
-0x00, 0xE0,
-0x17, 0x26, 0x17, 0xDF,
+	0xB3, 0x05,
+	0x00, 0xE0,
+	0x17, 0x26, 0x17, 0xDF,
 
-0x23, 0x3B, 0x33, 0xAD,
-0x35, 0x17, 0x4F, 0xE9,
+	0x23, 0x3B, 0x33, 0xAD,
+	0x35, 0x17, 0x4F, 0xE9,
 
-0x1F, 0x26, 0x1F, 0xDF,
-0x9D, 0x1F, 0x4F, 0xE9,
+	0x1F, 0x26, 0x1F, 0xDF,
+	0x9D, 0x1F, 0x4F, 0xE9,
 
-0x9E, 0x3F, 0x4F, 0xE9,
-0x39, 0x37, 0x4F, 0xE9,
+	0x9E, 0x3F, 0x4F, 0xE9,
+	0x39, 0x37, 0x4F, 0xE9,
 
-0x2F, 0x2F, 0x17, 0xAF,
-0x00, 0x80, 0x00, 0xE8,
+	0x2F, 0x2F, 0x17, 0xAF,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x07, 0x07, 0x1F, 0xAF,
-0x00, 0x80, 0x00, 0xE8,
+	0x07, 0x07, 0x1F, 0xAF,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x31, 0x80, 0x4F, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0x31, 0x80, 0x4F, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x9C, 0x80, 0x4F, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0x9C, 0x80, 0x4F, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x57, 0x39, 0x20, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+	0x57, 0x39, 0x20, 0xE9,
 
-0x16, 0x28, 0x20, 0xE9,
-0x1D, 0x3B, 0x20, 0xE9,
+	0x16, 0x28, 0x20, 0xE9,
+	0x1D, 0x3B, 0x20, 0xE9,
 
-0x1E, 0x2B, 0x20, 0xE9,
-0x2B, 0x32, 0x20, 0xE9,
+	0x1E, 0x2B, 0x20, 0xE9,
+	0x2B, 0x32, 0x20, 0xE9,
 
-0x1C, 0x23, 0x20, 0xE9,
-0x57, 0x36, 0x20, 0xE9,
+	0x1C, 0x23, 0x20, 0xE9,
+	0x57, 0x36, 0x20, 0xE9,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x40, 0x40, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x40, 0x40, 0xD8, 0xEC,
 
-0xFF, 0x80, 0xC0, 0xE9,
-0x90, 0xE2,
-0x00, 0xE0,
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x90, 0xE2,
+	0x00, 0xE0,
 
-0x74, 0xFF, 0x20, 0xEA,
-0x19, 0xC8, 0xC1, 0xCD,
+	0x74, 0xFF, 0x20, 0xEA,
+	0x19, 0xC8, 0xC1, 0xCD,
 
-0x1F, 0xD7, 0x18, 0xBD,
-0x3F, 0xD7, 0x22, 0xBD,
+	0x1F, 0xD7, 0x18, 0xBD,
+	0x3F, 0xD7, 0x22, 0xBD,
 
-0x9F, 0x41, 0x49, 0xBD,
-0x00, 0x80, 0x00, 0xE8,
+	0x9F, 0x41, 0x49, 0xBD,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x25, 0x41, 0x49, 0xBD,
-0x2D, 0x41, 0x51, 0xBD,
+	0x25, 0x41, 0x49, 0xBD,
+	0x2D, 0x41, 0x51, 0xBD,
 
-0x0D, 0x80, 0x07, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0x0D, 0x80, 0x07, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x35, 0x40, 0x48, 0xBD,
-0x3D, 0x40, 0x50, 0xBD,
+	0x35, 0x40, 0x48, 0xBD,
+	0x3D, 0x40, 0x50, 0xBD,
 
-0x00, 0x80, 0x00, 0xE8,
-0x25, 0x30,
-0x2D, 0x30,
+	0x00, 0x80, 0x00, 0xE8,
+	0x25, 0x30,
+	0x2D, 0x30,
 
-0x35, 0x30,
-0xB5, 0x30,
-0xBD, 0x30,
-0x3D, 0x30,
+	0x35, 0x30,
+	0xB5, 0x30,
+	0xBD, 0x30,
+	0x3D, 0x30,
 
-0x9C, 0xA7, 0x5B, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x9C, 0xA7, 0x5B, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x73, 0xFF, 0x0A, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0x73, 0xFF, 0x0A, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xC9, 0x41, 0xC8, 0xEC,
-0x42, 0xE1,
-0x00, 0xE0,
+	0xC9, 0x41, 0xC8, 0xEC,
+	0x42, 0xE1,
+	0x00, 0xE0,
 
-0x71, 0xFF, 0x20, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0x71, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xC8, 0x40, 0xC0, 0xEC,
-0x00, 0x80, 0x00, 0xE8,
+	0xC8, 0x40, 0xC0, 0xEC,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x6E, 0xFF, 0x20, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0x6E, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
 };
 
 static unsigned char warp_g200_tgzf[] = {
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x98, 0xA0, 0xE9,
-0x40, 0x40, 0xD8, 0xEC,
+	0x00, 0x98, 0xA0, 0xE9,
+	0x40, 0x40, 0xD8, 0xEC,
 
-0xFF, 0x80, 0xC0, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x1F, 0xD7, 0x18, 0xBD,
-0x3F, 0xD7, 0x22, 0xBD,
+	0x1F, 0xD7, 0x18, 0xBD,
+	0x3F, 0xD7, 0x22, 0xBD,
 
-0x81, 0x04,
-0x89, 0x04,
-0x01, 0x04,
-0x09, 0x04,
+	0x81, 0x04,
+	0x89, 0x04,
+	0x01, 0x04,
+	0x09, 0x04,
 
-0xC9, 0x41, 0xC0, 0xEC,
-0x11, 0x04,
-0x00, 0xE0,
+	0xC9, 0x41, 0xC0, 0xEC,
+	0x11, 0x04,
+	0x00, 0xE0,
 
-0x41, 0xCC, 0x41, 0xCD,
-0x49, 0xCC, 0x49, 0xCD,
+	0x41, 0xCC, 0x41, 0xCD,
+	0x49, 0xCC, 0x49, 0xCD,
 
-0xD1, 0x41, 0xC0, 0xEC,
-0x51, 0xCC, 0x51, 0xCD,
+	0xD1, 0x41, 0xC0, 0xEC,
+	0x51, 0xCC, 0x51, 0xCD,
 
-0x80, 0x04,
-0x10, 0x04,
-0x08, 0x04,
-0x00, 0xE0,
+	0x80, 0x04,
+	0x10, 0x04,
+	0x08, 0x04,
+	0x00, 0xE0,
 
-0x00, 0xCC, 0xC0, 0xCD,
-0xD1, 0x49, 0xC0, 0xEC,
+	0x00, 0xCC, 0xC0, 0xCD,
+	0xD1, 0x49, 0xC0, 0xEC,
 
-0x8A, 0x1F, 0x20, 0xE9,
-0x8B, 0x3F, 0x20, 0xE9,
+	0x8A, 0x1F, 0x20, 0xE9,
+	0x8B, 0x3F, 0x20, 0xE9,
 
-0x41, 0x3C, 0x41, 0xAD,
-0x49, 0x3C, 0x49, 0xAD,
+	0x41, 0x3C, 0x41, 0xAD,
+	0x49, 0x3C, 0x49, 0xAD,
 
-0x10, 0xCC, 0x10, 0xCD,
-0x08, 0xCC, 0x08, 0xCD,
+	0x10, 0xCC, 0x10, 0xCD,
+	0x08, 0xCC, 0x08, 0xCD,
 
-0xB9, 0x41, 0x49, 0xBB,
-0x1F, 0xF0, 0x41, 0xCD,
+	0xB9, 0x41, 0x49, 0xBB,
+	0x1F, 0xF0, 0x41, 0xCD,
 
-0x51, 0x3C, 0x51, 0xAD,
-0x00, 0x98, 0x80, 0xE9,
+	0x51, 0x3C, 0x51, 0xAD,
+	0x00, 0x98, 0x80, 0xE9,
 
-0x7F, 0x80, 0x07, 0xEA,
-0x24, 0x1F, 0x20, 0xE9,
+	0x7F, 0x80, 0x07, 0xEA,
+	0x24, 0x1F, 0x20, 0xE9,
 
-0x21, 0x45, 0x80, 0xE8,
-0x1A, 0x4D, 0x80, 0xE8,
+	0x21, 0x45, 0x80, 0xE8,
+	0x1A, 0x4D, 0x80, 0xE8,
 
-0x31, 0x55, 0x80, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x31, 0x55, 0x80, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x15, 0x41, 0x49, 0xBD,
-0x1D, 0x41, 0x51, 0xBD,
+	0x15, 0x41, 0x49, 0xBD,
+	0x1D, 0x41, 0x51, 0xBD,
 
-0x2E, 0x41, 0x2A, 0xB8,
-0x34, 0x53, 0xA0, 0xE8,
+	0x2E, 0x41, 0x2A, 0xB8,
+	0x34, 0x53, 0xA0, 0xE8,
 
-0x15, 0x30,
-0x1D, 0x30,
-0x58, 0xE3,
-0x00, 0xE0,
+	0x15, 0x30,
+	0x1D, 0x30,
+	0x58, 0xE3,
+	0x00, 0xE0,
 
-0xB5, 0x40, 0x48, 0xBD,
-0x3D, 0x40, 0x50, 0xBD,
+	0xB5, 0x40, 0x48, 0xBD,
+	0x3D, 0x40, 0x50, 0xBD,
 
-0x24, 0x43, 0xA0, 0xE8,
-0x2C, 0x4B, 0xA0, 0xE8,
+	0x24, 0x43, 0xA0, 0xE8,
+	0x2C, 0x4B, 0xA0, 0xE8,
 
-0x15, 0x72,
-0x09, 0xE3,
-0x00, 0xE0,
-0x1D, 0x72,
+	0x15, 0x72,
+	0x09, 0xE3,
+	0x00, 0xE0,
+	0x1D, 0x72,
 
-0x35, 0x30,
-0xB5, 0x30,
-0xBD, 0x30,
-0x3D, 0x30,
+	0x35, 0x30,
+	0xB5, 0x30,
+	0xBD, 0x30,
+	0x3D, 0x30,
 
-0x9C, 0x97, 0x57, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x9C, 0x97, 0x57, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x6C, 0x64, 0xC8, 0xEC,
-0x98, 0xE1,
-0xB5, 0x05,
+	0x6C, 0x64, 0xC8, 0xEC,
+	0x98, 0xE1,
+	0xB5, 0x05,
 
-0xBD, 0x05,
-0x2E, 0x30,
-0x32, 0xC0, 0xA0, 0xE8,
+	0xBD, 0x05,
+	0x2E, 0x30,
+	0x32, 0xC0, 0xA0, 0xE8,
 
-0x33, 0xC0, 0xA0, 0xE8,
-0x74, 0x64, 0xC8, 0xEC,
+	0x33, 0xC0, 0xA0, 0xE8,
+	0x74, 0x64, 0xC8, 0xEC,
 
-0x40, 0x3C, 0x40, 0xAD,
-0x32, 0x6A,
-0x2A, 0x30,
+	0x40, 0x3C, 0x40, 0xAD,
+	0x32, 0x6A,
+	0x2A, 0x30,
 
-0x20, 0x73,
-0x33, 0x6A,
-0x00, 0xE0,
-0x28, 0x73,
+	0x20, 0x73,
+	0x33, 0x6A,
+	0x00, 0xE0,
+	0x28, 0x73,
 
-0x1C, 0x72,
-0x83, 0xE2,
-0x6B, 0x80, 0x15, 0xEA,
+	0x1C, 0x72,
+	0x83, 0xE2,
+	0x6B, 0x80, 0x15, 0xEA,
 
-0xB8, 0x3D, 0x28, 0xDF,
-0x30, 0x35, 0x20, 0xDF,
+	0xB8, 0x3D, 0x28, 0xDF,
+	0x30, 0x35, 0x20, 0xDF,
 
-0x40, 0x30,
-0x00, 0xE0,
-0xCC, 0xE2,
-0x64, 0x72,
+	0x40, 0x30,
+	0x00, 0xE0,
+	0xCC, 0xE2,
+	0x64, 0x72,
 
-0x25, 0x42, 0x52, 0xBF,
-0x2D, 0x42, 0x4A, 0xBF,
+	0x25, 0x42, 0x52, 0xBF,
+	0x2D, 0x42, 0x4A, 0xBF,
 
-0x30, 0x2E, 0x30, 0xDF,
-0x38, 0x2E, 0x38, 0xDF,
+	0x30, 0x2E, 0x30, 0xDF,
+	0x38, 0x2E, 0x38, 0xDF,
 
-0x18, 0x1D, 0x45, 0xE9,
-0x1E, 0x15, 0x45, 0xE9,
+	0x18, 0x1D, 0x45, 0xE9,
+	0x1E, 0x15, 0x45, 0xE9,
 
-0x2B, 0x49, 0x51, 0xBD,
-0x00, 0xE0,
-0x1F, 0x73,
+	0x2B, 0x49, 0x51, 0xBD,
+	0x00, 0xE0,
+	0x1F, 0x73,
 
-0x38, 0x38, 0x40, 0xAF,
-0x30, 0x30, 0x40, 0xAF,
+	0x38, 0x38, 0x40, 0xAF,
+	0x30, 0x30, 0x40, 0xAF,
 
-0x24, 0x1F, 0x24, 0xDF,
-0x1D, 0x32, 0x20, 0xE9,
+	0x24, 0x1F, 0x24, 0xDF,
+	0x1D, 0x32, 0x20, 0xE9,
 
-0x2C, 0x1F, 0x2C, 0xDF,
-0x1A, 0x33, 0x20, 0xE9,
+	0x2C, 0x1F, 0x2C, 0xDF,
+	0x1A, 0x33, 0x20, 0xE9,
 
-0xB0, 0x10,
-0x08, 0xE3,
-0x40, 0x10,
-0xB8, 0x10,
+	0xB0, 0x10,
+	0x08, 0xE3,
+	0x40, 0x10,
+	0xB8, 0x10,
 
-0x26, 0xF0, 0x30, 0xCD,
-0x2F, 0xF0, 0x38, 0xCD,
+	0x26, 0xF0, 0x30, 0xCD,
+	0x2F, 0xF0, 0x38, 0xCD,
 
-0x2B, 0x80, 0x20, 0xE9,
-0x2A, 0x80, 0x20, 0xE9,
+	0x2B, 0x80, 0x20, 0xE9,
+	0x2A, 0x80, 0x20, 0xE9,
 
-0xA6, 0x20,
-0x88, 0xE2,
-0x00, 0xE0,
-0xAF, 0x20,
+	0xA6, 0x20,
+	0x88, 0xE2,
+	0x00, 0xE0,
+	0xAF, 0x20,
 
-0x28, 0x2A, 0x26, 0xAF,
-0x20, 0x2A, 0xC0, 0xAF,
+	0x28, 0x2A, 0x26, 0xAF,
+	0x20, 0x2A, 0xC0, 0xAF,
 
-0x34, 0x1F, 0x34, 0xDF,
-0x46, 0x24, 0x46, 0xDF,
+	0x34, 0x1F, 0x34, 0xDF,
+	0x46, 0x24, 0x46, 0xDF,
 
-0x28, 0x30, 0x80, 0xBF,
-0x20, 0x38, 0x80, 0xBF,
+	0x28, 0x30, 0x80, 0xBF,
+	0x20, 0x38, 0x80, 0xBF,
 
-0x47, 0x24, 0x47, 0xDF,
-0x4E, 0x2C, 0x4E, 0xDF,
+	0x47, 0x24, 0x47, 0xDF,
+	0x4E, 0x2C, 0x4E, 0xDF,
 
-0x4F, 0x2C, 0x4F, 0xDF,
-0x56, 0x34, 0x56, 0xDF,
+	0x4F, 0x2C, 0x4F, 0xDF,
+	0x56, 0x34, 0x56, 0xDF,
 
-0x28, 0x15, 0x28, 0xDF,
-0x20, 0x1D, 0x20, 0xDF,
+	0x28, 0x15, 0x28, 0xDF,
+	0x20, 0x1D, 0x20, 0xDF,
 
-0x57, 0x34, 0x57, 0xDF,
-0x00, 0xE0,
-0x1D, 0x05,
+	0x57, 0x34, 0x57, 0xDF,
+	0x00, 0xE0,
+	0x1D, 0x05,
 
-0x04, 0x80, 0x10, 0xEA,
-0x89, 0xE2,
-0x2B, 0x30,
+	0x04, 0x80, 0x10, 0xEA,
+	0x89, 0xE2,
+	0x2B, 0x30,
 
-0x3F, 0xC1, 0x1D, 0xBD,
-0x00, 0x80, 0x00, 0xE8,
+	0x3F, 0xC1, 0x1D, 0xBD,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xA0, 0x68,
-0xBF, 0x25,
-0x00, 0x80, 0x00, 0xE8,
+	0xA0, 0x68,
+	0xBF, 0x25,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x20, 0xC0, 0x20, 0xAF,
-0x28, 0x05,
-0x97, 0x74,
+	0x20, 0xC0, 0x20, 0xAF,
+	0x28, 0x05,
+	0x97, 0x74,
 
-0x00, 0xE0,
-0x2A, 0x10,
-0x16, 0xC0, 0x20, 0xE9,
+	0x00, 0xE0,
+	0x2A, 0x10,
+	0x16, 0xC0, 0x20, 0xE9,
 
-0x04, 0x80, 0x10, 0xEA,
-0x8C, 0xE2,
-0x95, 0x05,
+	0x04, 0x80, 0x10, 0xEA,
+	0x8C, 0xE2,
+	0x95, 0x05,
 
-0x28, 0xC1, 0x28, 0xAD,
-0x1F, 0xC1, 0x15, 0xBD,
+	0x28, 0xC1, 0x28, 0xAD,
+	0x1F, 0xC1, 0x15, 0xBD,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xA8, 0x67,
-0x9F, 0x6B,
-0x00, 0x80, 0x00, 0xE8,
+	0xA8, 0x67,
+	0x9F, 0x6B,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x28, 0xC0, 0x28, 0xAD,
-0x1D, 0x25,
-0x20, 0x05,
+	0x28, 0xC0, 0x28, 0xAD,
+	0x1D, 0x25,
+	0x20, 0x05,
 
-0x28, 0x32, 0x80, 0xAD,
-0x40, 0x2A, 0x40, 0xBD,
+	0x28, 0x32, 0x80, 0xAD,
+	0x40, 0x2A, 0x40, 0xBD,
 
-0x1C, 0x80, 0x20, 0xE9,
-0x20, 0x33, 0x20, 0xAD,
+	0x1C, 0x80, 0x20, 0xE9,
+	0x20, 0x33, 0x20, 0xAD,
 
-0x20, 0x73,
-0x00, 0xE0,
-0xB6, 0x49, 0x51, 0xBB,
+	0x20, 0x73,
+	0x00, 0xE0,
+	0xB6, 0x49, 0x51, 0xBB,
 
-0x26, 0x2F, 0xB0, 0xE8,
-0x19, 0x20, 0x20, 0xE9,
+	0x26, 0x2F, 0xB0, 0xE8,
+	0x19, 0x20, 0x20, 0xE9,
 
-0x35, 0x20, 0x35, 0xDF,
-0x3D, 0x20, 0x3D, 0xDF,
+	0x35, 0x20, 0x35, 0xDF,
+	0x3D, 0x20, 0x3D, 0xDF,
 
-0x15, 0x20, 0x15, 0xDF,
-0x1D, 0x20, 0x1D, 0xDF,
+	0x15, 0x20, 0x15, 0xDF,
+	0x1D, 0x20, 0x1D, 0xDF,
 
-0x26, 0xD0, 0x26, 0xCD,
-0x29, 0x49, 0x2A, 0xB8,
+	0x26, 0xD0, 0x26, 0xCD,
+	0x29, 0x49, 0x2A, 0xB8,
 
-0x26, 0x40, 0x80, 0xBD,
-0x3B, 0x48, 0x50, 0xBD,
+	0x26, 0x40, 0x80, 0xBD,
+	0x3B, 0x48, 0x50, 0xBD,
 
-0x3E, 0x54, 0x57, 0x9F,
-0x00, 0xE0,
-0x82, 0xE1,
+	0x3E, 0x54, 0x57, 0x9F,
+	0x00, 0xE0,
+	0x82, 0xE1,
 
-0x1E, 0xAF, 0x59, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x1E, 0xAF, 0x59, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x26, 0x30,
-0x29, 0x30,
-0x48, 0x3C, 0x48, 0xAD,
+	0x26, 0x30,
+	0x29, 0x30,
+	0x48, 0x3C, 0x48, 0xAD,
 
-0x2B, 0x72,
-0xC2, 0xE1,
-0x2C, 0xC0, 0x44, 0xC2,
+	0x2B, 0x72,
+	0xC2, 0xE1,
+	0x2C, 0xC0, 0x44, 0xC2,
 
-0x05, 0x24, 0x34, 0xBF,
-0x0D, 0x24, 0x2C, 0xBF,
+	0x05, 0x24, 0x34, 0xBF,
+	0x0D, 0x24, 0x2C, 0xBF,
 
-0x2D, 0x46, 0x4E, 0xBF,
-0x25, 0x46, 0x56, 0xBF,
+	0x2D, 0x46, 0x4E, 0xBF,
+	0x25, 0x46, 0x56, 0xBF,
 
-0x20, 0x1D, 0x6F, 0x8F,
-0x32, 0x3E, 0x5F, 0xE9,
+	0x20, 0x1D, 0x6F, 0x8F,
+	0x32, 0x3E, 0x5F, 0xE9,
 
-0x3E, 0x50, 0x56, 0x9F,
-0x00, 0xE0,
-0x3B, 0x30,
+	0x3E, 0x50, 0x56, 0x9F,
+	0x00, 0xE0,
+	0x3B, 0x30,
 
-0x1E, 0x8F, 0x51, 0x9F,
-0x33, 0x1E, 0x5F, 0xE9,
+	0x1E, 0x8F, 0x51, 0x9F,
+	0x33, 0x1E, 0x5F, 0xE9,
 
-0x05, 0x44, 0x54, 0xB2,
-0x0D, 0x44, 0x4C, 0xB2,
+	0x05, 0x44, 0x54, 0xB2,
+	0x0D, 0x44, 0x4C, 0xB2,
 
-0x19, 0xC0, 0xB0, 0xE8,
-0x34, 0xC0, 0x44, 0xC4,
+	0x19, 0xC0, 0xB0, 0xE8,
+	0x34, 0xC0, 0x44, 0xC4,
 
-0x33, 0x73,
-0x00, 0xE0,
-0x3E, 0x62, 0x57, 0x9F,
+	0x33, 0x73,
+	0x00, 0xE0,
+	0x3E, 0x62, 0x57, 0x9F,
 
-0x1E, 0xAF, 0x59, 0x9F,
-0x00, 0xE0,
-0x0D, 0x20,
+	0x1E, 0xAF, 0x59, 0x9F,
+	0x00, 0xE0,
+	0x0D, 0x20,
 
-0x84, 0x3E, 0x58, 0xE9,
-0x28, 0x1D, 0x6F, 0x8F,
+	0x84, 0x3E, 0x58, 0xE9,
+	0x28, 0x1D, 0x6F, 0x8F,
 
-0x05, 0x20,
-0x00, 0xE0,
-0x85, 0x1E, 0x58, 0xE9,
+	0x05, 0x20,
+	0x00, 0xE0,
+	0x85, 0x1E, 0x58, 0xE9,
 
-0x9B, 0x3B, 0x33, 0xDF,
-0x20, 0x20, 0x42, 0xAF,
+	0x9B, 0x3B, 0x33, 0xDF,
+	0x20, 0x20, 0x42, 0xAF,
 
-0x30, 0x42, 0x56, 0x9F,
-0x80, 0x3E, 0x57, 0xE9,
+	0x30, 0x42, 0x56, 0x9F,
+	0x80, 0x3E, 0x57, 0xE9,
 
-0x3F, 0x8F, 0x51, 0x9F,
-0x30, 0x80, 0x5F, 0xE9,
+	0x3F, 0x8F, 0x51, 0x9F,
+	0x30, 0x80, 0x5F, 0xE9,
 
-0x28, 0x28, 0x24, 0xAF,
-0x81, 0x1E, 0x57, 0xE9,
+	0x28, 0x28, 0x24, 0xAF,
+	0x81, 0x1E, 0x57, 0xE9,
 
-0x05, 0x47, 0x57, 0xBF,
-0x0D, 0x47, 0x4F, 0xBF,
+	0x05, 0x47, 0x57, 0xBF,
+	0x0D, 0x47, 0x4F, 0xBF,
 
-0x88, 0x80, 0x58, 0xE9,
-0x1B, 0x29, 0x1B, 0xDF,
+	0x88, 0x80, 0x58, 0xE9,
+	0x1B, 0x29, 0x1B, 0xDF,
 
-0x30, 0x1D, 0x6F, 0x8F,
-0x3A, 0x30, 0x4F, 0xE9,
+	0x30, 0x1D, 0x6F, 0x8F,
+	0x3A, 0x30, 0x4F, 0xE9,
 
-0x1C, 0x30, 0x26, 0xDF,
-0x09, 0xE3,
-0x3B, 0x05,
+	0x1C, 0x30, 0x26, 0xDF,
+	0x09, 0xE3,
+	0x3B, 0x05,
 
-0x3E, 0x50, 0x56, 0x9F,
-0x3B, 0x3F, 0x4F, 0xE9,
+	0x3E, 0x50, 0x56, 0x9F,
+	0x3B, 0x3F, 0x4F, 0xE9,
 
-0x1E, 0x8F, 0x51, 0x9F,
-0x00, 0xE0,
-0xAC, 0x20,
+	0x1E, 0x8F, 0x51, 0x9F,
+	0x00, 0xE0,
+	0xAC, 0x20,
 
-0x2D, 0x44, 0x4C, 0xB4,
-0x2C, 0x1C, 0xC0, 0xAF,
+	0x2D, 0x44, 0x4C, 0xB4,
+	0x2C, 0x1C, 0xC0, 0xAF,
 
-0x25, 0x44, 0x54, 0xB4,
-0x00, 0xE0,
-0xC8, 0x30,
+	0x25, 0x44, 0x54, 0xB4,
+	0x00, 0xE0,
+	0xC8, 0x30,
 
-0x30, 0x46, 0x30, 0xAF,
-0x1B, 0x1B, 0x48, 0xAF,
+	0x30, 0x46, 0x30, 0xAF,
+	0x1B, 0x1B, 0x48, 0xAF,
 
-0x00, 0xE0,
-0x25, 0x20,
-0x38, 0x2C, 0x4F, 0xE9,
+	0x00, 0xE0,
+	0x25, 0x20,
+	0x38, 0x2C, 0x4F, 0xE9,
 
-0x86, 0x80, 0x57, 0xE9,
-0x38, 0x1D, 0x6F, 0x8F,
+	0x86, 0x80, 0x57, 0xE9,
+	0x38, 0x1D, 0x6F, 0x8F,
 
-0x28, 0x74,
-0x00, 0xE0,
-0x0D, 0x44, 0x4C, 0xB0,
+	0x28, 0x74,
+	0x00, 0xE0,
+	0x0D, 0x44, 0x4C, 0xB0,
 
-0x05, 0x44, 0x54, 0xB0,
-0x2D, 0x20,
-0x9B, 0x10,
+	0x05, 0x44, 0x54, 0xB0,
+	0x2D, 0x20,
+	0x9B, 0x10,
 
-0x82, 0x3E, 0x57, 0xE9,
-0x32, 0xF0, 0x1B, 0xCD,
+	0x82, 0x3E, 0x57, 0xE9,
+	0x32, 0xF0, 0x1B, 0xCD,
 
-0x1E, 0xBD, 0x59, 0x9F,
-0x83, 0x1E, 0x57, 0xE9,
+	0x1E, 0xBD, 0x59, 0x9F,
+	0x83, 0x1E, 0x57, 0xE9,
 
-0x38, 0x47, 0x38, 0xAF,
-0x34, 0x20,
-0x2A, 0x30,
+	0x38, 0x47, 0x38, 0xAF,
+	0x34, 0x20,
+	0x2A, 0x30,
 
-0x00, 0xE0,
-0x0D, 0x20,
-0x32, 0x20,
-0x05, 0x20,
+	0x00, 0xE0,
+	0x0D, 0x20,
+	0x32, 0x20,
+	0x05, 0x20,
 
-0x87, 0x80, 0x57, 0xE9,
-0x1F, 0x54, 0x57, 0x9F,
+	0x87, 0x80, 0x57, 0xE9,
+	0x1F, 0x54, 0x57, 0x9F,
 
-0x17, 0x42, 0x56, 0x9F,
-0x00, 0xE0,
-0x3B, 0x6A,
+	0x17, 0x42, 0x56, 0x9F,
+	0x00, 0xE0,
+	0x3B, 0x6A,
 
-0x3F, 0x8F, 0x51, 0x9F,
-0x37, 0x1E, 0x4F, 0xE9,
+	0x3F, 0x8F, 0x51, 0x9F,
+	0x37, 0x1E, 0x4F, 0xE9,
 
-0x37, 0x32, 0x2A, 0xAF,
-0x00, 0xE0,
-0x32, 0x00,
+	0x37, 0x32, 0x2A, 0xAF,
+	0x00, 0xE0,
+	0x32, 0x00,
 
-0x00, 0x80, 0x00, 0xE8,
-0x27, 0xC0, 0x44, 0xC0,
+	0x00, 0x80, 0x00, 0xE8,
+	0x27, 0xC0, 0x44, 0xC0,
 
-0x36, 0x1F, 0x4F, 0xE9,
-0x1F, 0x1F, 0x26, 0xDF,
+	0x36, 0x1F, 0x4F, 0xE9,
+	0x1F, 0x1F, 0x26, 0xDF,
 
-0x37, 0x1B, 0x37, 0xBF,
-0x17, 0x26, 0x17, 0xDF,
+	0x37, 0x1B, 0x37, 0xBF,
+	0x17, 0x26, 0x17, 0xDF,
 
-0x3E, 0x17, 0x4F, 0xE9,
-0x3F, 0x3F, 0x4F, 0xE9,
+	0x3E, 0x17, 0x4F, 0xE9,
+	0x3F, 0x3F, 0x4F, 0xE9,
 
-0x34, 0x1F, 0x34, 0xAF,
-0x2B, 0x05,
-0xA7, 0x20,
+	0x34, 0x1F, 0x34, 0xAF,
+	0x2B, 0x05,
+	0xA7, 0x20,
 
-0x33, 0x2B, 0x37, 0xDF,
-0x27, 0x17, 0xC0, 0xAF,
+	0x33, 0x2B, 0x37, 0xDF,
+	0x27, 0x17, 0xC0, 0xAF,
 
-0x34, 0x80, 0x4F, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0x34, 0x80, 0x4F, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x0D, 0x21, 0x1A, 0xB6,
-0x05, 0x21, 0x31, 0xB6,
+	0x0D, 0x21, 0x1A, 0xB6,
+	0x05, 0x21, 0x31, 0xB6,
 
-0x03, 0x80, 0x2A, 0xEA,
-0x17, 0xC1, 0x2B, 0xBD,
+	0x03, 0x80, 0x2A, 0xEA,
+	0x17, 0xC1, 0x2B, 0xBD,
 
-0x0D, 0x20,
-0x05, 0x20,
-0x2F, 0xC0, 0x21, 0xC6,
+	0x0D, 0x20,
+	0x05, 0x20,
+	0x2F, 0xC0, 0x21, 0xC6,
 
-0xB3, 0x68,
-0x97, 0x25,
-0x00, 0x80, 0x00, 0xE8,
+	0xB3, 0x68,
+	0x97, 0x25,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x33, 0xC0, 0x33, 0xAF,
-0x3C, 0x27, 0x4F, 0xE9,
+	0x33, 0xC0, 0x33, 0xAF,
+	0x3C, 0x27, 0x4F, 0xE9,
 
-0x17, 0x50, 0x56, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x17, 0x50, 0x56, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x37, 0x0F, 0x5C, 0x9F,
-0x00, 0xE0,
-0x2F, 0x20,
+	0x37, 0x0F, 0x5C, 0x9F,
+	0x00, 0xE0,
+	0x2F, 0x20,
 
-0x00, 0x80, 0x00, 0xE8,
-0x28, 0x19, 0x60, 0xEC,
+	0x00, 0x80, 0x00, 0xE8,
+	0x28, 0x19, 0x60, 0xEC,
 
-0xB3, 0x05,
-0x00, 0xE0,
-0x00, 0x80, 0x00, 0xE8,
+	0xB3, 0x05,
+	0x00, 0xE0,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x23, 0x3B, 0x33, 0xAD,
-0x00, 0x80, 0x00, 0xE8,
+	0x23, 0x3B, 0x33, 0xAD,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x17, 0x26, 0x17, 0xDF,
-0x35, 0x17, 0x4F, 0xE9,
+	0x17, 0x26, 0x17, 0xDF,
+	0x35, 0x17, 0x4F, 0xE9,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x39, 0x37, 0x4F, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+	0x39, 0x37, 0x4F, 0xE9,
 
-0x2F, 0x2F, 0x17, 0xAF,
-0x00, 0x80, 0x00, 0xE8,
+	0x2F, 0x2F, 0x17, 0xAF,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x31, 0x80, 0x4F, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0x31, 0x80, 0x4F, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x57, 0x39, 0x20, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+	0x57, 0x39, 0x20, 0xE9,
 
-0x16, 0x28, 0x20, 0xE9,
-0x1D, 0x3B, 0x20, 0xE9,
+	0x16, 0x28, 0x20, 0xE9,
+	0x1D, 0x3B, 0x20, 0xE9,
 
-0x1E, 0x2B, 0x20, 0xE9,
-0x2B, 0x32, 0x20, 0xE9,
+	0x1E, 0x2B, 0x20, 0xE9,
+	0x2B, 0x32, 0x20, 0xE9,
 
-0x1C, 0x23, 0x20, 0xE9,
-0x57, 0x36, 0x20, 0xE9,
+	0x1C, 0x23, 0x20, 0xE9,
+	0x57, 0x36, 0x20, 0xE9,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x40, 0x40, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x40, 0x40, 0xD8, 0xEC,
 
-0xFF, 0x80, 0xC0, 0xE9,
-0x90, 0xE2,
-0x00, 0xE0,
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x90, 0xE2,
+	0x00, 0xE0,
 
-0x78, 0xFF, 0x20, 0xEA,
-0x19, 0xC8, 0xC1, 0xCD,
+	0x78, 0xFF, 0x20, 0xEA,
+	0x19, 0xC8, 0xC1, 0xCD,
 
-0x1F, 0xD7, 0x18, 0xBD,
-0x3F, 0xD7, 0x22, 0xBD,
+	0x1F, 0xD7, 0x18, 0xBD,
+	0x3F, 0xD7, 0x22, 0xBD,
 
-0x9F, 0x41, 0x49, 0xBD,
-0x00, 0x80, 0x00, 0xE8,
+	0x9F, 0x41, 0x49, 0xBD,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x25, 0x41, 0x49, 0xBD,
-0x2D, 0x41, 0x51, 0xBD,
+	0x25, 0x41, 0x49, 0xBD,
+	0x2D, 0x41, 0x51, 0xBD,
 
-0x0D, 0x80, 0x07, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0x0D, 0x80, 0x07, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x35, 0x40, 0x48, 0xBD,
-0x3D, 0x40, 0x50, 0xBD,
+	0x35, 0x40, 0x48, 0xBD,
+	0x3D, 0x40, 0x50, 0xBD,
 
-0x00, 0x80, 0x00, 0xE8,
-0x25, 0x30,
-0x2D, 0x30,
+	0x00, 0x80, 0x00, 0xE8,
+	0x25, 0x30,
+	0x2D, 0x30,
 
-0x35, 0x30,
-0xB5, 0x30,
-0xBD, 0x30,
-0x3D, 0x30,
+	0x35, 0x30,
+	0xB5, 0x30,
+	0xBD, 0x30,
+	0x3D, 0x30,
 
-0x9C, 0xA7, 0x5B, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x9C, 0xA7, 0x5B, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x77, 0xFF, 0x0A, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0x77, 0xFF, 0x0A, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xC9, 0x41, 0xC8, 0xEC,
-0x42, 0xE1,
-0x00, 0xE0,
+	0xC9, 0x41, 0xC8, 0xEC,
+	0x42, 0xE1,
+	0x00, 0xE0,
 
-0x75, 0xFF, 0x20, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0x75, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xC8, 0x40, 0xC0, 0xEC,
-0x00, 0x80, 0x00, 0xE8,
+	0xC8, 0x40, 0xC0, 0xEC,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x72, 0xFF, 0x20, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0x72, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
 };
 
 static unsigned char warp_g200_tgzs[] = {
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x98, 0xA0, 0xE9,
-0x40, 0x40, 0xD8, 0xEC,
+	0x00, 0x98, 0xA0, 0xE9,
+	0x40, 0x40, 0xD8, 0xEC,
 
-0xFF, 0x80, 0xC0, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x1F, 0xD7, 0x18, 0xBD,
-0x3F, 0xD7, 0x22, 0xBD,
+	0x1F, 0xD7, 0x18, 0xBD,
+	0x3F, 0xD7, 0x22, 0xBD,
 
-0x81, 0x04,
-0x89, 0x04,
-0x01, 0x04,
-0x09, 0x04,
+	0x81, 0x04,
+	0x89, 0x04,
+	0x01, 0x04,
+	0x09, 0x04,
 
-0xC9, 0x41, 0xC0, 0xEC,
-0x11, 0x04,
-0x00, 0xE0,
+	0xC9, 0x41, 0xC0, 0xEC,
+	0x11, 0x04,
+	0x00, 0xE0,
 
-0x41, 0xCC, 0x41, 0xCD,
-0x49, 0xCC, 0x49, 0xCD,
+	0x41, 0xCC, 0x41, 0xCD,
+	0x49, 0xCC, 0x49, 0xCD,
 
-0xD1, 0x41, 0xC0, 0xEC,
-0x51, 0xCC, 0x51, 0xCD,
+	0xD1, 0x41, 0xC0, 0xEC,
+	0x51, 0xCC, 0x51, 0xCD,
 
-0x80, 0x04,
-0x10, 0x04,
-0x08, 0x04,
-0x00, 0xE0,
+	0x80, 0x04,
+	0x10, 0x04,
+	0x08, 0x04,
+	0x00, 0xE0,
 
-0x00, 0xCC, 0xC0, 0xCD,
-0xD1, 0x49, 0xC0, 0xEC,
+	0x00, 0xCC, 0xC0, 0xCD,
+	0xD1, 0x49, 0xC0, 0xEC,
 
-0x8A, 0x1F, 0x20, 0xE9,
-0x8B, 0x3F, 0x20, 0xE9,
+	0x8A, 0x1F, 0x20, 0xE9,
+	0x8B, 0x3F, 0x20, 0xE9,
 
-0x41, 0x3C, 0x41, 0xAD,
-0x49, 0x3C, 0x49, 0xAD,
+	0x41, 0x3C, 0x41, 0xAD,
+	0x49, 0x3C, 0x49, 0xAD,
 
-0x10, 0xCC, 0x10, 0xCD,
-0x08, 0xCC, 0x08, 0xCD,
+	0x10, 0xCC, 0x10, 0xCD,
+	0x08, 0xCC, 0x08, 0xCD,
 
-0xB9, 0x41, 0x49, 0xBB,
-0x1F, 0xF0, 0x41, 0xCD,
+	0xB9, 0x41, 0x49, 0xBB,
+	0x1F, 0xF0, 0x41, 0xCD,
 
-0x51, 0x3C, 0x51, 0xAD,
-0x00, 0x98, 0x80, 0xE9,
+	0x51, 0x3C, 0x51, 0xAD,
+	0x00, 0x98, 0x80, 0xE9,
 
-0x8B, 0x80, 0x07, 0xEA,
-0x24, 0x1F, 0x20, 0xE9,
+	0x8B, 0x80, 0x07, 0xEA,
+	0x24, 0x1F, 0x20, 0xE9,
 
-0x21, 0x45, 0x80, 0xE8,
-0x1A, 0x4D, 0x80, 0xE8,
+	0x21, 0x45, 0x80, 0xE8,
+	0x1A, 0x4D, 0x80, 0xE8,
 
-0x31, 0x55, 0x80, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x31, 0x55, 0x80, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x15, 0x41, 0x49, 0xBD,
-0x1D, 0x41, 0x51, 0xBD,
+	0x15, 0x41, 0x49, 0xBD,
+	0x1D, 0x41, 0x51, 0xBD,
 
-0x2E, 0x41, 0x2A, 0xB8,
-0x34, 0x53, 0xA0, 0xE8,
+	0x2E, 0x41, 0x2A, 0xB8,
+	0x34, 0x53, 0xA0, 0xE8,
 
-0x15, 0x30,
-0x1D, 0x30,
-0x58, 0xE3,
-0x00, 0xE0,
+	0x15, 0x30,
+	0x1D, 0x30,
+	0x58, 0xE3,
+	0x00, 0xE0,
 
-0xB5, 0x40, 0x48, 0xBD,
-0x3D, 0x40, 0x50, 0xBD,
+	0xB5, 0x40, 0x48, 0xBD,
+	0x3D, 0x40, 0x50, 0xBD,
 
-0x24, 0x43, 0xA0, 0xE8,
-0x2C, 0x4B, 0xA0, 0xE8,
+	0x24, 0x43, 0xA0, 0xE8,
+	0x2C, 0x4B, 0xA0, 0xE8,
 
-0x15, 0x72,
-0x09, 0xE3,
-0x00, 0xE0,
-0x1D, 0x72,
+	0x15, 0x72,
+	0x09, 0xE3,
+	0x00, 0xE0,
+	0x1D, 0x72,
 
-0x35, 0x30,
-0xB5, 0x30,
-0xBD, 0x30,
-0x3D, 0x30,
+	0x35, 0x30,
+	0xB5, 0x30,
+	0xBD, 0x30,
+	0x3D, 0x30,
 
-0x9C, 0x97, 0x57, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x9C, 0x97, 0x57, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x6C, 0x64, 0xC8, 0xEC,
-0x98, 0xE1,
-0xB5, 0x05,
+	0x6C, 0x64, 0xC8, 0xEC,
+	0x98, 0xE1,
+	0xB5, 0x05,
 
-0xBD, 0x05,
-0x2E, 0x30,
-0x32, 0xC0, 0xA0, 0xE8,
+	0xBD, 0x05,
+	0x2E, 0x30,
+	0x32, 0xC0, 0xA0, 0xE8,
 
-0x33, 0xC0, 0xA0, 0xE8,
-0x74, 0x64, 0xC8, 0xEC,
+	0x33, 0xC0, 0xA0, 0xE8,
+	0x74, 0x64, 0xC8, 0xEC,
 
-0x40, 0x3C, 0x40, 0xAD,
-0x32, 0x6A,
-0x2A, 0x30,
+	0x40, 0x3C, 0x40, 0xAD,
+	0x32, 0x6A,
+	0x2A, 0x30,
 
-0x20, 0x73,
-0x33, 0x6A,
-0x00, 0xE0,
-0x28, 0x73,
+	0x20, 0x73,
+	0x33, 0x6A,
+	0x00, 0xE0,
+	0x28, 0x73,
 
-0x1C, 0x72,
-0x83, 0xE2,
-0x77, 0x80, 0x15, 0xEA,
+	0x1C, 0x72,
+	0x83, 0xE2,
+	0x77, 0x80, 0x15, 0xEA,
 
-0xB8, 0x3D, 0x28, 0xDF,
-0x30, 0x35, 0x20, 0xDF,
+	0xB8, 0x3D, 0x28, 0xDF,
+	0x30, 0x35, 0x20, 0xDF,
 
-0x40, 0x30,
-0x00, 0xE0,
-0xCC, 0xE2,
-0x64, 0x72,
+	0x40, 0x30,
+	0x00, 0xE0,
+	0xCC, 0xE2,
+	0x64, 0x72,
 
-0x25, 0x42, 0x52, 0xBF,
-0x2D, 0x42, 0x4A, 0xBF,
+	0x25, 0x42, 0x52, 0xBF,
+	0x2D, 0x42, 0x4A, 0xBF,
 
-0x30, 0x2E, 0x30, 0xDF,
-0x38, 0x2E, 0x38, 0xDF,
+	0x30, 0x2E, 0x30, 0xDF,
+	0x38, 0x2E, 0x38, 0xDF,
 
-0x18, 0x1D, 0x45, 0xE9,
-0x1E, 0x15, 0x45, 0xE9,
+	0x18, 0x1D, 0x45, 0xE9,
+	0x1E, 0x15, 0x45, 0xE9,
 
-0x2B, 0x49, 0x51, 0xBD,
-0x00, 0xE0,
-0x1F, 0x73,
+	0x2B, 0x49, 0x51, 0xBD,
+	0x00, 0xE0,
+	0x1F, 0x73,
 
-0x38, 0x38, 0x40, 0xAF,
-0x30, 0x30, 0x40, 0xAF,
+	0x38, 0x38, 0x40, 0xAF,
+	0x30, 0x30, 0x40, 0xAF,
 
-0x24, 0x1F, 0x24, 0xDF,
-0x1D, 0x32, 0x20, 0xE9,
+	0x24, 0x1F, 0x24, 0xDF,
+	0x1D, 0x32, 0x20, 0xE9,
 
-0x2C, 0x1F, 0x2C, 0xDF,
-0x1A, 0x33, 0x20, 0xE9,
+	0x2C, 0x1F, 0x2C, 0xDF,
+	0x1A, 0x33, 0x20, 0xE9,
 
-0xB0, 0x10,
-0x08, 0xE3,
-0x40, 0x10,
-0xB8, 0x10,
+	0xB0, 0x10,
+	0x08, 0xE3,
+	0x40, 0x10,
+	0xB8, 0x10,
 
-0x26, 0xF0, 0x30, 0xCD,
-0x2F, 0xF0, 0x38, 0xCD,
+	0x26, 0xF0, 0x30, 0xCD,
+	0x2F, 0xF0, 0x38, 0xCD,
 
-0x2B, 0x80, 0x20, 0xE9,
-0x2A, 0x80, 0x20, 0xE9,
+	0x2B, 0x80, 0x20, 0xE9,
+	0x2A, 0x80, 0x20, 0xE9,
 
-0xA6, 0x20,
-0x88, 0xE2,
-0x00, 0xE0,
-0xAF, 0x20,
+	0xA6, 0x20,
+	0x88, 0xE2,
+	0x00, 0xE0,
+	0xAF, 0x20,
 
-0x28, 0x2A, 0x26, 0xAF,
-0x20, 0x2A, 0xC0, 0xAF,
+	0x28, 0x2A, 0x26, 0xAF,
+	0x20, 0x2A, 0xC0, 0xAF,
 
-0x34, 0x1F, 0x34, 0xDF,
-0x46, 0x24, 0x46, 0xDF,
+	0x34, 0x1F, 0x34, 0xDF,
+	0x46, 0x24, 0x46, 0xDF,
 
-0x28, 0x30, 0x80, 0xBF,
-0x20, 0x38, 0x80, 0xBF,
+	0x28, 0x30, 0x80, 0xBF,
+	0x20, 0x38, 0x80, 0xBF,
 
-0x47, 0x24, 0x47, 0xDF,
-0x4E, 0x2C, 0x4E, 0xDF,
+	0x47, 0x24, 0x47, 0xDF,
+	0x4E, 0x2C, 0x4E, 0xDF,
 
-0x4F, 0x2C, 0x4F, 0xDF,
-0x56, 0x34, 0x56, 0xDF,
+	0x4F, 0x2C, 0x4F, 0xDF,
+	0x56, 0x34, 0x56, 0xDF,
 
-0x28, 0x15, 0x28, 0xDF,
-0x20, 0x1D, 0x20, 0xDF,
+	0x28, 0x15, 0x28, 0xDF,
+	0x20, 0x1D, 0x20, 0xDF,
 
-0x57, 0x34, 0x57, 0xDF,
-0x00, 0xE0,
-0x1D, 0x05,
+	0x57, 0x34, 0x57, 0xDF,
+	0x00, 0xE0,
+	0x1D, 0x05,
 
-0x04, 0x80, 0x10, 0xEA,
-0x89, 0xE2,
-0x2B, 0x30,
+	0x04, 0x80, 0x10, 0xEA,
+	0x89, 0xE2,
+	0x2B, 0x30,
 
-0x3F, 0xC1, 0x1D, 0xBD,
-0x00, 0x80, 0x00, 0xE8,
+	0x3F, 0xC1, 0x1D, 0xBD,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xA0, 0x68,
-0xBF, 0x25,
-0x00, 0x80, 0x00, 0xE8,
+	0xA0, 0x68,
+	0xBF, 0x25,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x20, 0xC0, 0x20, 0xAF,
-0x28, 0x05,
-0x97, 0x74,
+	0x20, 0xC0, 0x20, 0xAF,
+	0x28, 0x05,
+	0x97, 0x74,
 
-0x00, 0xE0,
-0x2A, 0x10,
-0x16, 0xC0, 0x20, 0xE9,
+	0x00, 0xE0,
+	0x2A, 0x10,
+	0x16, 0xC0, 0x20, 0xE9,
 
-0x04, 0x80, 0x10, 0xEA,
-0x8C, 0xE2,
-0x95, 0x05,
+	0x04, 0x80, 0x10, 0xEA,
+	0x8C, 0xE2,
+	0x95, 0x05,
 
-0x28, 0xC1, 0x28, 0xAD,
-0x1F, 0xC1, 0x15, 0xBD,
+	0x28, 0xC1, 0x28, 0xAD,
+	0x1F, 0xC1, 0x15, 0xBD,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xA8, 0x67,
-0x9F, 0x6B,
-0x00, 0x80, 0x00, 0xE8,
+	0xA8, 0x67,
+	0x9F, 0x6B,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x28, 0xC0, 0x28, 0xAD,
-0x1D, 0x25,
-0x20, 0x05,
+	0x28, 0xC0, 0x28, 0xAD,
+	0x1D, 0x25,
+	0x20, 0x05,
 
-0x28, 0x32, 0x80, 0xAD,
-0x40, 0x2A, 0x40, 0xBD,
+	0x28, 0x32, 0x80, 0xAD,
+	0x40, 0x2A, 0x40, 0xBD,
 
-0x1C, 0x80, 0x20, 0xE9,
-0x20, 0x33, 0x20, 0xAD,
+	0x1C, 0x80, 0x20, 0xE9,
+	0x20, 0x33, 0x20, 0xAD,
 
-0x20, 0x73,
-0x00, 0xE0,
-0xB6, 0x49, 0x51, 0xBB,
+	0x20, 0x73,
+	0x00, 0xE0,
+	0xB6, 0x49, 0x51, 0xBB,
 
-0x26, 0x2F, 0xB0, 0xE8,
-0x19, 0x20, 0x20, 0xE9,
+	0x26, 0x2F, 0xB0, 0xE8,
+	0x19, 0x20, 0x20, 0xE9,
 
-0x35, 0x20, 0x35, 0xDF,
-0x3D, 0x20, 0x3D, 0xDF,
+	0x35, 0x20, 0x35, 0xDF,
+	0x3D, 0x20, 0x3D, 0xDF,
 
-0x15, 0x20, 0x15, 0xDF,
-0x1D, 0x20, 0x1D, 0xDF,
+	0x15, 0x20, 0x15, 0xDF,
+	0x1D, 0x20, 0x1D, 0xDF,
 
-0x26, 0xD0, 0x26, 0xCD,
-0x29, 0x49, 0x2A, 0xB8,
+	0x26, 0xD0, 0x26, 0xCD,
+	0x29, 0x49, 0x2A, 0xB8,
 
-0x26, 0x40, 0x80, 0xBD,
-0x3B, 0x48, 0x50, 0xBD,
+	0x26, 0x40, 0x80, 0xBD,
+	0x3B, 0x48, 0x50, 0xBD,
 
-0x3E, 0x54, 0x57, 0x9F,
-0x00, 0xE0,
-0x82, 0xE1,
+	0x3E, 0x54, 0x57, 0x9F,
+	0x00, 0xE0,
+	0x82, 0xE1,
 
-0x1E, 0xAF, 0x59, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x1E, 0xAF, 0x59, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x26, 0x30,
-0x29, 0x30,
-0x48, 0x3C, 0x48, 0xAD,
+	0x26, 0x30,
+	0x29, 0x30,
+	0x48, 0x3C, 0x48, 0xAD,
 
-0x2B, 0x72,
-0xC2, 0xE1,
-0x2C, 0xC0, 0x44, 0xC2,
+	0x2B, 0x72,
+	0xC2, 0xE1,
+	0x2C, 0xC0, 0x44, 0xC2,
 
-0x05, 0x24, 0x34, 0xBF,
-0x0D, 0x24, 0x2C, 0xBF,
+	0x05, 0x24, 0x34, 0xBF,
+	0x0D, 0x24, 0x2C, 0xBF,
 
-0x2D, 0x46, 0x4E, 0xBF,
-0x25, 0x46, 0x56, 0xBF,
+	0x2D, 0x46, 0x4E, 0xBF,
+	0x25, 0x46, 0x56, 0xBF,
 
-0x20, 0x1D, 0x6F, 0x8F,
-0x32, 0x3E, 0x5F, 0xE9,
+	0x20, 0x1D, 0x6F, 0x8F,
+	0x32, 0x3E, 0x5F, 0xE9,
 
-0x3E, 0x50, 0x56, 0x9F,
-0x00, 0xE0,
-0x3B, 0x30,
+	0x3E, 0x50, 0x56, 0x9F,
+	0x00, 0xE0,
+	0x3B, 0x30,
 
-0x1E, 0x8F, 0x51, 0x9F,
-0x33, 0x1E, 0x5F, 0xE9,
+	0x1E, 0x8F, 0x51, 0x9F,
+	0x33, 0x1E, 0x5F, 0xE9,
 
-0x05, 0x44, 0x54, 0xB2,
-0x0D, 0x44, 0x4C, 0xB2,
+	0x05, 0x44, 0x54, 0xB2,
+	0x0D, 0x44, 0x4C, 0xB2,
 
-0x19, 0xC0, 0xB0, 0xE8,
-0x34, 0xC0, 0x44, 0xC4,
+	0x19, 0xC0, 0xB0, 0xE8,
+	0x34, 0xC0, 0x44, 0xC4,
 
-0x33, 0x73,
-0x00, 0xE0,
-0x3E, 0x62, 0x57, 0x9F,
+	0x33, 0x73,
+	0x00, 0xE0,
+	0x3E, 0x62, 0x57, 0x9F,
 
-0x1E, 0xAF, 0x59, 0x9F,
-0x00, 0xE0,
-0x0D, 0x20,
+	0x1E, 0xAF, 0x59, 0x9F,
+	0x00, 0xE0,
+	0x0D, 0x20,
 
-0x84, 0x3E, 0x58, 0xE9,
-0x28, 0x1D, 0x6F, 0x8F,
+	0x84, 0x3E, 0x58, 0xE9,
+	0x28, 0x1D, 0x6F, 0x8F,
 
-0x05, 0x20,
-0x00, 0xE0,
-0x85, 0x1E, 0x58, 0xE9,
+	0x05, 0x20,
+	0x00, 0xE0,
+	0x85, 0x1E, 0x58, 0xE9,
 
-0x9B, 0x3B, 0x33, 0xDF,
-0x20, 0x20, 0x42, 0xAF,
+	0x9B, 0x3B, 0x33, 0xDF,
+	0x20, 0x20, 0x42, 0xAF,
 
-0x30, 0x42, 0x56, 0x9F,
-0x80, 0x3E, 0x57, 0xE9,
+	0x30, 0x42, 0x56, 0x9F,
+	0x80, 0x3E, 0x57, 0xE9,
 
-0x3F, 0x8F, 0x51, 0x9F,
-0x30, 0x80, 0x5F, 0xE9,
+	0x3F, 0x8F, 0x51, 0x9F,
+	0x30, 0x80, 0x5F, 0xE9,
 
-0x28, 0x28, 0x24, 0xAF,
-0x81, 0x1E, 0x57, 0xE9,
+	0x28, 0x28, 0x24, 0xAF,
+	0x81, 0x1E, 0x57, 0xE9,
 
-0x05, 0x47, 0x57, 0xBF,
-0x0D, 0x47, 0x4F, 0xBF,
+	0x05, 0x47, 0x57, 0xBF,
+	0x0D, 0x47, 0x4F, 0xBF,
 
-0x88, 0x80, 0x58, 0xE9,
-0x1B, 0x29, 0x1B, 0xDF,
+	0x88, 0x80, 0x58, 0xE9,
+	0x1B, 0x29, 0x1B, 0xDF,
 
-0x30, 0x1D, 0x6F, 0x8F,
-0x3A, 0x30, 0x4F, 0xE9,
+	0x30, 0x1D, 0x6F, 0x8F,
+	0x3A, 0x30, 0x4F, 0xE9,
 
-0x1C, 0x30, 0x26, 0xDF,
-0x09, 0xE3,
-0x3B, 0x05,
+	0x1C, 0x30, 0x26, 0xDF,
+	0x09, 0xE3,
+	0x3B, 0x05,
 
-0x3E, 0x50, 0x56, 0x9F,
-0x3B, 0x3F, 0x4F, 0xE9,
+	0x3E, 0x50, 0x56, 0x9F,
+	0x3B, 0x3F, 0x4F, 0xE9,
 
-0x1E, 0x8F, 0x51, 0x9F,
-0x00, 0xE0,
-0xAC, 0x20,
+	0x1E, 0x8F, 0x51, 0x9F,
+	0x00, 0xE0,
+	0xAC, 0x20,
 
-0x2D, 0x44, 0x4C, 0xB4,
-0x2C, 0x1C, 0xC0, 0xAF,
+	0x2D, 0x44, 0x4C, 0xB4,
+	0x2C, 0x1C, 0xC0, 0xAF,
 
-0x25, 0x44, 0x54, 0xB4,
-0x00, 0xE0,
-0xC8, 0x30,
+	0x25, 0x44, 0x54, 0xB4,
+	0x00, 0xE0,
+	0xC8, 0x30,
 
-0x30, 0x46, 0x30, 0xAF,
-0x1B, 0x1B, 0x48, 0xAF,
+	0x30, 0x46, 0x30, 0xAF,
+	0x1B, 0x1B, 0x48, 0xAF,
 
-0x00, 0xE0,
-0x25, 0x20,
-0x38, 0x2C, 0x4F, 0xE9,
+	0x00, 0xE0,
+	0x25, 0x20,
+	0x38, 0x2C, 0x4F, 0xE9,
 
-0x86, 0x80, 0x57, 0xE9,
-0x38, 0x1D, 0x6F, 0x8F,
+	0x86, 0x80, 0x57, 0xE9,
+	0x38, 0x1D, 0x6F, 0x8F,
 
-0x28, 0x74,
-0x00, 0xE0,
-0x0D, 0x44, 0x4C, 0xB0,
+	0x28, 0x74,
+	0x00, 0xE0,
+	0x0D, 0x44, 0x4C, 0xB0,
 
-0x05, 0x44, 0x54, 0xB0,
-0x2D, 0x20,
-0x9B, 0x10,
+	0x05, 0x44, 0x54, 0xB0,
+	0x2D, 0x20,
+	0x9B, 0x10,
 
-0x82, 0x3E, 0x57, 0xE9,
-0x32, 0xF0, 0x1B, 0xCD,
+	0x82, 0x3E, 0x57, 0xE9,
+	0x32, 0xF0, 0x1B, 0xCD,
 
-0x1E, 0xBD, 0x59, 0x9F,
-0x83, 0x1E, 0x57, 0xE9,
+	0x1E, 0xBD, 0x59, 0x9F,
+	0x83, 0x1E, 0x57, 0xE9,
 
-0x38, 0x47, 0x38, 0xAF,
-0x34, 0x20,
-0x2A, 0x30,
+	0x38, 0x47, 0x38, 0xAF,
+	0x34, 0x20,
+	0x2A, 0x30,
 
-0x00, 0xE0,
-0x0D, 0x20,
-0x32, 0x20,
-0x05, 0x20,
+	0x00, 0xE0,
+	0x0D, 0x20,
+	0x32, 0x20,
+	0x05, 0x20,
 
-0x87, 0x80, 0x57, 0xE9,
-0x1F, 0x54, 0x57, 0x9F,
+	0x87, 0x80, 0x57, 0xE9,
+	0x1F, 0x54, 0x57, 0x9F,
 
-0x17, 0x42, 0x56, 0x9F,
-0x00, 0xE0,
-0x3B, 0x6A,
+	0x17, 0x42, 0x56, 0x9F,
+	0x00, 0xE0,
+	0x3B, 0x6A,
 
-0x3F, 0x8F, 0x51, 0x9F,
-0x37, 0x1E, 0x4F, 0xE9,
+	0x3F, 0x8F, 0x51, 0x9F,
+	0x37, 0x1E, 0x4F, 0xE9,
 
-0x37, 0x32, 0x2A, 0xAF,
-0x00, 0xE0,
-0x32, 0x00,
+	0x37, 0x32, 0x2A, 0xAF,
+	0x00, 0xE0,
+	0x32, 0x00,
 
-0x00, 0x80, 0x00, 0xE8,
-0x27, 0xC0, 0x44, 0xC0,
+	0x00, 0x80, 0x00, 0xE8,
+	0x27, 0xC0, 0x44, 0xC0,
 
-0x36, 0x1F, 0x4F, 0xE9,
-0x1F, 0x1F, 0x26, 0xDF,
+	0x36, 0x1F, 0x4F, 0xE9,
+	0x1F, 0x1F, 0x26, 0xDF,
 
-0x37, 0x1B, 0x37, 0xBF,
-0x17, 0x26, 0x17, 0xDF,
+	0x37, 0x1B, 0x37, 0xBF,
+	0x17, 0x26, 0x17, 0xDF,
 
-0x3E, 0x17, 0x4F, 0xE9,
-0x3F, 0x3F, 0x4F, 0xE9,
+	0x3E, 0x17, 0x4F, 0xE9,
+	0x3F, 0x3F, 0x4F, 0xE9,
 
-0x34, 0x1F, 0x34, 0xAF,
-0x2B, 0x05,
-0xA7, 0x20,
+	0x34, 0x1F, 0x34, 0xAF,
+	0x2B, 0x05,
+	0xA7, 0x20,
 
-0x33, 0x2B, 0x37, 0xDF,
-0x27, 0x17, 0xC0, 0xAF,
+	0x33, 0x2B, 0x37, 0xDF,
+	0x27, 0x17, 0xC0, 0xAF,
 
-0x34, 0x80, 0x4F, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0x34, 0x80, 0x4F, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x2D, 0x21, 0x1A, 0xB0,
-0x25, 0x21, 0x31, 0xB0,
+	0x2D, 0x21, 0x1A, 0xB0,
+	0x25, 0x21, 0x31, 0xB0,
 
-0x0D, 0x21, 0x1A, 0xB2,
-0x05, 0x21, 0x31, 0xB2,
+	0x0D, 0x21, 0x1A, 0xB2,
+	0x05, 0x21, 0x31, 0xB2,
 
-0x03, 0x80, 0x2A, 0xEA,
-0x17, 0xC1, 0x2B, 0xBD,
+	0x03, 0x80, 0x2A, 0xEA,
+	0x17, 0xC1, 0x2B, 0xBD,
 
-0x2D, 0x20,
-0x25, 0x20,
-0x05, 0x20,
-0x0D, 0x20,
+	0x2D, 0x20,
+	0x25, 0x20,
+	0x05, 0x20,
+	0x0D, 0x20,
 
-0xB3, 0x68,
-0x97, 0x25,
-0x00, 0x80, 0x00, 0xE8,
+	0xB3, 0x68,
+	0x97, 0x25,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x33, 0xC0, 0x33, 0xAF,
-0x2F, 0xC0, 0x21, 0xC0,
+	0x33, 0xC0, 0x33, 0xAF,
+	0x2F, 0xC0, 0x21, 0xC0,
 
-0x16, 0x42, 0x56, 0x9F,
-0x3C, 0x27, 0x4F, 0xE9,
+	0x16, 0x42, 0x56, 0x9F,
+	0x3C, 0x27, 0x4F, 0xE9,
 
-0x1E, 0x62, 0x57, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x1E, 0x62, 0x57, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x25, 0x21, 0x31, 0xB4,
-0x2D, 0x21, 0x1A, 0xB4,
+	0x25, 0x21, 0x31, 0xB4,
+	0x2D, 0x21, 0x1A, 0xB4,
 
-0x3F, 0x2F, 0x5D, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x3F, 0x2F, 0x5D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x33, 0x05,
-0x00, 0xE0,
-0x28, 0x19, 0x60, 0xEC,
+	0x33, 0x05,
+	0x00, 0xE0,
+	0x28, 0x19, 0x60, 0xEC,
 
-0x37, 0x0F, 0x5C, 0x9F,
-0x00, 0xE0,
-0x2F, 0x20,
+	0x37, 0x0F, 0x5C, 0x9F,
+	0x00, 0xE0,
+	0x2F, 0x20,
 
-0x23, 0x3B, 0x33, 0xAD,
-0x1E, 0x26, 0x1E, 0xDF,
+	0x23, 0x3B, 0x33, 0xAD,
+	0x1E, 0x26, 0x1E, 0xDF,
 
-0xA7, 0x1E, 0x4F, 0xE9,
-0x17, 0x26, 0x16, 0xDF,
+	0xA7, 0x1E, 0x4F, 0xE9,
+	0x17, 0x26, 0x16, 0xDF,
 
-0x2D, 0x20,
-0x00, 0xE0,
-0xA8, 0x3F, 0x4F, 0xE9,
+	0x2D, 0x20,
+	0x00, 0xE0,
+	0xA8, 0x3F, 0x4F, 0xE9,
 
-0x2F, 0x2F, 0x1E, 0xAF,
-0x25, 0x20,
-0x00, 0xE0,
+	0x2F, 0x2F, 0x1E, 0xAF,
+	0x25, 0x20,
+	0x00, 0xE0,
 
-0xA4, 0x16, 0x4F, 0xE9,
-0x0F, 0xC0, 0x21, 0xC2,
+	0xA4, 0x16, 0x4F, 0xE9,
+	0x0F, 0xC0, 0x21, 0xC2,
 
-0xA6, 0x80, 0x4F, 0xE9,
-0x1F, 0x62, 0x57, 0x9F,
+	0xA6, 0x80, 0x4F, 0xE9,
+	0x1F, 0x62, 0x57, 0x9F,
 
-0x3F, 0x2F, 0x5D, 0x9F,
-0x00, 0xE0,
-0x8F, 0x20,
+	0x3F, 0x2F, 0x5D, 0x9F,
+	0x00, 0xE0,
+	0x8F, 0x20,
 
-0xA5, 0x37, 0x4F, 0xE9,
-0x0F, 0x17, 0x0F, 0xAF,
+	0xA5, 0x37, 0x4F, 0xE9,
+	0x0F, 0x17, 0x0F, 0xAF,
 
-0x06, 0xC0, 0x21, 0xC4,
-0x00, 0x80, 0x00, 0xE8,
+	0x06, 0xC0, 0x21, 0xC4,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0xA3, 0x80, 0x4F, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+	0xA3, 0x80, 0x4F, 0xE9,
 
-0x06, 0x20,
-0x00, 0xE0,
-0x1F, 0x26, 0x1F, 0xDF,
+	0x06, 0x20,
+	0x00, 0xE0,
+	0x1F, 0x26, 0x1F, 0xDF,
 
-0xA1, 0x1F, 0x4F, 0xE9,
-0xA2, 0x3F, 0x4F, 0xE9,
+	0xA1, 0x1F, 0x4F, 0xE9,
+	0xA2, 0x3F, 0x4F, 0xE9,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x06, 0x06, 0x1F, 0xAF,
-0x00, 0x80, 0x00, 0xE8,
+	0x06, 0x06, 0x1F, 0xAF,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xA0, 0x80, 0x4F, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0xA0, 0x80, 0x4F, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x57, 0x39, 0x20, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+	0x57, 0x39, 0x20, 0xE9,
 
-0x16, 0x28, 0x20, 0xE9,
-0x1D, 0x3B, 0x20, 0xE9,
+	0x16, 0x28, 0x20, 0xE9,
+	0x1D, 0x3B, 0x20, 0xE9,
 
-0x1E, 0x2B, 0x20, 0xE9,
-0x2B, 0x32, 0x20, 0xE9,
+	0x1E, 0x2B, 0x20, 0xE9,
+	0x2B, 0x32, 0x20, 0xE9,
 
-0x1C, 0x23, 0x20, 0xE9,
-0x57, 0x36, 0x20, 0xE9,
+	0x1C, 0x23, 0x20, 0xE9,
+	0x57, 0x36, 0x20, 0xE9,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x40, 0x40, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x40, 0x40, 0xD8, 0xEC,
 
-0xFF, 0x80, 0xC0, 0xE9,
-0x90, 0xE2,
-0x00, 0xE0,
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x90, 0xE2,
+	0x00, 0xE0,
 
-0x6C, 0xFF, 0x20, 0xEA,
-0x19, 0xC8, 0xC1, 0xCD,
+	0x6C, 0xFF, 0x20, 0xEA,
+	0x19, 0xC8, 0xC1, 0xCD,
 
-0x1F, 0xD7, 0x18, 0xBD,
-0x3F, 0xD7, 0x22, 0xBD,
+	0x1F, 0xD7, 0x18, 0xBD,
+	0x3F, 0xD7, 0x22, 0xBD,
 
-0x9F, 0x41, 0x49, 0xBD,
-0x00, 0x80, 0x00, 0xE8,
+	0x9F, 0x41, 0x49, 0xBD,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x25, 0x41, 0x49, 0xBD,
-0x2D, 0x41, 0x51, 0xBD,
+	0x25, 0x41, 0x49, 0xBD,
+	0x2D, 0x41, 0x51, 0xBD,
 
-0x0D, 0x80, 0x07, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0x0D, 0x80, 0x07, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x35, 0x40, 0x48, 0xBD,
-0x3D, 0x40, 0x50, 0xBD,
+	0x35, 0x40, 0x48, 0xBD,
+	0x3D, 0x40, 0x50, 0xBD,
 
-0x00, 0x80, 0x00, 0xE8,
-0x25, 0x30,
-0x2D, 0x30,
+	0x00, 0x80, 0x00, 0xE8,
+	0x25, 0x30,
+	0x2D, 0x30,
 
-0x35, 0x30,
-0xB5, 0x30,
-0xBD, 0x30,
-0x3D, 0x30,
+	0x35, 0x30,
+	0xB5, 0x30,
+	0xBD, 0x30,
+	0x3D, 0x30,
 
-0x9C, 0xA7, 0x5B, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x9C, 0xA7, 0x5B, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x6B, 0xFF, 0x0A, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0x6B, 0xFF, 0x0A, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xC9, 0x41, 0xC8, 0xEC,
-0x42, 0xE1,
-0x00, 0xE0,
+	0xC9, 0x41, 0xC8, 0xEC,
+	0x42, 0xE1,
+	0x00, 0xE0,
 
-0x69, 0xFF, 0x20, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0x69, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xC8, 0x40, 0xC0, 0xEC,
-0x00, 0x80, 0x00, 0xE8,
+	0xC8, 0x40, 0xC0, 0xEC,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x66, 0xFF, 0x20, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0x66, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
 };
 
 static unsigned char warp_g200_tgzsa[] = {
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x98, 0xA0, 0xE9,
-0x40, 0x40, 0xD8, 0xEC,
+	0x00, 0x98, 0xA0, 0xE9,
+	0x40, 0x40, 0xD8, 0xEC,
 
-0xFF, 0x80, 0xC0, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x1F, 0xD7, 0x18, 0xBD,
-0x3F, 0xD7, 0x22, 0xBD,
+	0x1F, 0xD7, 0x18, 0xBD,
+	0x3F, 0xD7, 0x22, 0xBD,
 
-0x81, 0x04,
-0x89, 0x04,
-0x01, 0x04,
-0x09, 0x04,
+	0x81, 0x04,
+	0x89, 0x04,
+	0x01, 0x04,
+	0x09, 0x04,
 
-0xC9, 0x41, 0xC0, 0xEC,
-0x11, 0x04,
-0x00, 0xE0,
+	0xC9, 0x41, 0xC0, 0xEC,
+	0x11, 0x04,
+	0x00, 0xE0,
 
-0x41, 0xCC, 0x41, 0xCD,
-0x49, 0xCC, 0x49, 0xCD,
+	0x41, 0xCC, 0x41, 0xCD,
+	0x49, 0xCC, 0x49, 0xCD,
 
-0xD1, 0x41, 0xC0, 0xEC,
-0x51, 0xCC, 0x51, 0xCD,
+	0xD1, 0x41, 0xC0, 0xEC,
+	0x51, 0xCC, 0x51, 0xCD,
 
-0x80, 0x04,
-0x10, 0x04,
-0x08, 0x04,
-0x00, 0xE0,
+	0x80, 0x04,
+	0x10, 0x04,
+	0x08, 0x04,
+	0x00, 0xE0,
 
-0x00, 0xCC, 0xC0, 0xCD,
-0xD1, 0x49, 0xC0, 0xEC,
+	0x00, 0xCC, 0xC0, 0xCD,
+	0xD1, 0x49, 0xC0, 0xEC,
 
-0x8A, 0x1F, 0x20, 0xE9,
-0x8B, 0x3F, 0x20, 0xE9,
+	0x8A, 0x1F, 0x20, 0xE9,
+	0x8B, 0x3F, 0x20, 0xE9,
 
-0x41, 0x3C, 0x41, 0xAD,
-0x49, 0x3C, 0x49, 0xAD,
+	0x41, 0x3C, 0x41, 0xAD,
+	0x49, 0x3C, 0x49, 0xAD,
 
-0x10, 0xCC, 0x10, 0xCD,
-0x08, 0xCC, 0x08, 0xCD,
+	0x10, 0xCC, 0x10, 0xCD,
+	0x08, 0xCC, 0x08, 0xCD,
 
-0xB9, 0x41, 0x49, 0xBB,
-0x1F, 0xF0, 0x41, 0xCD,
+	0xB9, 0x41, 0x49, 0xBB,
+	0x1F, 0xF0, 0x41, 0xCD,
 
-0x51, 0x3C, 0x51, 0xAD,
-0x00, 0x98, 0x80, 0xE9,
+	0x51, 0x3C, 0x51, 0xAD,
+	0x00, 0x98, 0x80, 0xE9,
 
-0x8F, 0x80, 0x07, 0xEA,
-0x24, 0x1F, 0x20, 0xE9,
+	0x8F, 0x80, 0x07, 0xEA,
+	0x24, 0x1F, 0x20, 0xE9,
 
-0x21, 0x45, 0x80, 0xE8,
-0x1A, 0x4D, 0x80, 0xE8,
+	0x21, 0x45, 0x80, 0xE8,
+	0x1A, 0x4D, 0x80, 0xE8,
 
-0x31, 0x55, 0x80, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x31, 0x55, 0x80, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x15, 0x41, 0x49, 0xBD,
-0x1D, 0x41, 0x51, 0xBD,
+	0x15, 0x41, 0x49, 0xBD,
+	0x1D, 0x41, 0x51, 0xBD,
 
-0x2E, 0x41, 0x2A, 0xB8,
-0x34, 0x53, 0xA0, 0xE8,
+	0x2E, 0x41, 0x2A, 0xB8,
+	0x34, 0x53, 0xA0, 0xE8,
 
-0x15, 0x30,
-0x1D, 0x30,
-0x58, 0xE3,
-0x00, 0xE0,
+	0x15, 0x30,
+	0x1D, 0x30,
+	0x58, 0xE3,
+	0x00, 0xE0,
 
-0xB5, 0x40, 0x48, 0xBD,
-0x3D, 0x40, 0x50, 0xBD,
+	0xB5, 0x40, 0x48, 0xBD,
+	0x3D, 0x40, 0x50, 0xBD,
 
-0x24, 0x43, 0xA0, 0xE8,
-0x2C, 0x4B, 0xA0, 0xE8,
+	0x24, 0x43, 0xA0, 0xE8,
+	0x2C, 0x4B, 0xA0, 0xE8,
 
-0x15, 0x72,
-0x09, 0xE3,
-0x00, 0xE0,
-0x1D, 0x72,
+	0x15, 0x72,
+	0x09, 0xE3,
+	0x00, 0xE0,
+	0x1D, 0x72,
 
-0x35, 0x30,
-0xB5, 0x30,
-0xBD, 0x30,
-0x3D, 0x30,
+	0x35, 0x30,
+	0xB5, 0x30,
+	0xBD, 0x30,
+	0x3D, 0x30,
 
-0x9C, 0x97, 0x57, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x9C, 0x97, 0x57, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x6C, 0x64, 0xC8, 0xEC,
-0x98, 0xE1,
-0xB5, 0x05,
+	0x6C, 0x64, 0xC8, 0xEC,
+	0x98, 0xE1,
+	0xB5, 0x05,
 
-0xBD, 0x05,
-0x2E, 0x30,
-0x32, 0xC0, 0xA0, 0xE8,
+	0xBD, 0x05,
+	0x2E, 0x30,
+	0x32, 0xC0, 0xA0, 0xE8,
 
-0x33, 0xC0, 0xA0, 0xE8,
-0x74, 0x64, 0xC8, 0xEC,
+	0x33, 0xC0, 0xA0, 0xE8,
+	0x74, 0x64, 0xC8, 0xEC,
 
-0x40, 0x3C, 0x40, 0xAD,
-0x32, 0x6A,
-0x2A, 0x30,
+	0x40, 0x3C, 0x40, 0xAD,
+	0x32, 0x6A,
+	0x2A, 0x30,
 
-0x20, 0x73,
-0x33, 0x6A,
-0x00, 0xE0,
-0x28, 0x73,
+	0x20, 0x73,
+	0x33, 0x6A,
+	0x00, 0xE0,
+	0x28, 0x73,
 
-0x1C, 0x72,
-0x83, 0xE2,
-0x7B, 0x80, 0x15, 0xEA,
+	0x1C, 0x72,
+	0x83, 0xE2,
+	0x7B, 0x80, 0x15, 0xEA,
 
-0xB8, 0x3D, 0x28, 0xDF,
-0x30, 0x35, 0x20, 0xDF,
+	0xB8, 0x3D, 0x28, 0xDF,
+	0x30, 0x35, 0x20, 0xDF,
 
-0x40, 0x30,
-0x00, 0xE0,
-0xCC, 0xE2,
-0x64, 0x72,
+	0x40, 0x30,
+	0x00, 0xE0,
+	0xCC, 0xE2,
+	0x64, 0x72,
 
-0x25, 0x42, 0x52, 0xBF,
-0x2D, 0x42, 0x4A, 0xBF,
+	0x25, 0x42, 0x52, 0xBF,
+	0x2D, 0x42, 0x4A, 0xBF,
 
-0x30, 0x2E, 0x30, 0xDF,
-0x38, 0x2E, 0x38, 0xDF,
+	0x30, 0x2E, 0x30, 0xDF,
+	0x38, 0x2E, 0x38, 0xDF,
 
-0x18, 0x1D, 0x45, 0xE9,
-0x1E, 0x15, 0x45, 0xE9,
+	0x18, 0x1D, 0x45, 0xE9,
+	0x1E, 0x15, 0x45, 0xE9,
 
-0x2B, 0x49, 0x51, 0xBD,
-0x00, 0xE0,
-0x1F, 0x73,
+	0x2B, 0x49, 0x51, 0xBD,
+	0x00, 0xE0,
+	0x1F, 0x73,
 
-0x38, 0x38, 0x40, 0xAF,
-0x30, 0x30, 0x40, 0xAF,
+	0x38, 0x38, 0x40, 0xAF,
+	0x30, 0x30, 0x40, 0xAF,
 
-0x24, 0x1F, 0x24, 0xDF,
-0x1D, 0x32, 0x20, 0xE9,
+	0x24, 0x1F, 0x24, 0xDF,
+	0x1D, 0x32, 0x20, 0xE9,
 
-0x2C, 0x1F, 0x2C, 0xDF,
-0x1A, 0x33, 0x20, 0xE9,
+	0x2C, 0x1F, 0x2C, 0xDF,
+	0x1A, 0x33, 0x20, 0xE9,
 
-0xB0, 0x10,
-0x08, 0xE3,
-0x40, 0x10,
-0xB8, 0x10,
+	0xB0, 0x10,
+	0x08, 0xE3,
+	0x40, 0x10,
+	0xB8, 0x10,
 
-0x26, 0xF0, 0x30, 0xCD,
-0x2F, 0xF0, 0x38, 0xCD,
+	0x26, 0xF0, 0x30, 0xCD,
+	0x2F, 0xF0, 0x38, 0xCD,
 
-0x2B, 0x80, 0x20, 0xE9,
-0x2A, 0x80, 0x20, 0xE9,
+	0x2B, 0x80, 0x20, 0xE9,
+	0x2A, 0x80, 0x20, 0xE9,
 
-0xA6, 0x20,
-0x88, 0xE2,
-0x00, 0xE0,
-0xAF, 0x20,
+	0xA6, 0x20,
+	0x88, 0xE2,
+	0x00, 0xE0,
+	0xAF, 0x20,
 
-0x28, 0x2A, 0x26, 0xAF,
-0x20, 0x2A, 0xC0, 0xAF,
+	0x28, 0x2A, 0x26, 0xAF,
+	0x20, 0x2A, 0xC0, 0xAF,
 
-0x34, 0x1F, 0x34, 0xDF,
-0x46, 0x24, 0x46, 0xDF,
+	0x34, 0x1F, 0x34, 0xDF,
+	0x46, 0x24, 0x46, 0xDF,
 
-0x28, 0x30, 0x80, 0xBF,
-0x20, 0x38, 0x80, 0xBF,
+	0x28, 0x30, 0x80, 0xBF,
+	0x20, 0x38, 0x80, 0xBF,
 
-0x47, 0x24, 0x47, 0xDF,
-0x4E, 0x2C, 0x4E, 0xDF,
+	0x47, 0x24, 0x47, 0xDF,
+	0x4E, 0x2C, 0x4E, 0xDF,
 
-0x4F, 0x2C, 0x4F, 0xDF,
-0x56, 0x34, 0x56, 0xDF,
+	0x4F, 0x2C, 0x4F, 0xDF,
+	0x56, 0x34, 0x56, 0xDF,
 
-0x28, 0x15, 0x28, 0xDF,
-0x20, 0x1D, 0x20, 0xDF,
+	0x28, 0x15, 0x28, 0xDF,
+	0x20, 0x1D, 0x20, 0xDF,
 
-0x57, 0x34, 0x57, 0xDF,
-0x00, 0xE0,
-0x1D, 0x05,
+	0x57, 0x34, 0x57, 0xDF,
+	0x00, 0xE0,
+	0x1D, 0x05,
 
-0x04, 0x80, 0x10, 0xEA,
-0x89, 0xE2,
-0x2B, 0x30,
+	0x04, 0x80, 0x10, 0xEA,
+	0x89, 0xE2,
+	0x2B, 0x30,
 
-0x3F, 0xC1, 0x1D, 0xBD,
-0x00, 0x80, 0x00, 0xE8,
+	0x3F, 0xC1, 0x1D, 0xBD,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xA0, 0x68,
-0xBF, 0x25,
-0x00, 0x80, 0x00, 0xE8,
+	0xA0, 0x68,
+	0xBF, 0x25,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x20, 0xC0, 0x20, 0xAF,
-0x28, 0x05,
-0x97, 0x74,
+	0x20, 0xC0, 0x20, 0xAF,
+	0x28, 0x05,
+	0x97, 0x74,
 
-0x00, 0xE0,
-0x2A, 0x10,
-0x16, 0xC0, 0x20, 0xE9,
+	0x00, 0xE0,
+	0x2A, 0x10,
+	0x16, 0xC0, 0x20, 0xE9,
 
-0x04, 0x80, 0x10, 0xEA,
-0x8C, 0xE2,
-0x95, 0x05,
+	0x04, 0x80, 0x10, 0xEA,
+	0x8C, 0xE2,
+	0x95, 0x05,
 
-0x28, 0xC1, 0x28, 0xAD,
-0x1F, 0xC1, 0x15, 0xBD,
+	0x28, 0xC1, 0x28, 0xAD,
+	0x1F, 0xC1, 0x15, 0xBD,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xA8, 0x67,
-0x9F, 0x6B,
-0x00, 0x80, 0x00, 0xE8,
+	0xA8, 0x67,
+	0x9F, 0x6B,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x28, 0xC0, 0x28, 0xAD,
-0x1D, 0x25,
-0x20, 0x05,
+	0x28, 0xC0, 0x28, 0xAD,
+	0x1D, 0x25,
+	0x20, 0x05,
 
-0x28, 0x32, 0x80, 0xAD,
-0x40, 0x2A, 0x40, 0xBD,
+	0x28, 0x32, 0x80, 0xAD,
+	0x40, 0x2A, 0x40, 0xBD,
 
-0x1C, 0x80, 0x20, 0xE9,
-0x20, 0x33, 0x20, 0xAD,
+	0x1C, 0x80, 0x20, 0xE9,
+	0x20, 0x33, 0x20, 0xAD,
 
-0x20, 0x73,
-0x00, 0xE0,
-0xB6, 0x49, 0x51, 0xBB,
+	0x20, 0x73,
+	0x00, 0xE0,
+	0xB6, 0x49, 0x51, 0xBB,
 
-0x26, 0x2F, 0xB0, 0xE8,
-0x19, 0x20, 0x20, 0xE9,
+	0x26, 0x2F, 0xB0, 0xE8,
+	0x19, 0x20, 0x20, 0xE9,
 
-0x35, 0x20, 0x35, 0xDF,
-0x3D, 0x20, 0x3D, 0xDF,
+	0x35, 0x20, 0x35, 0xDF,
+	0x3D, 0x20, 0x3D, 0xDF,
 
-0x15, 0x20, 0x15, 0xDF,
-0x1D, 0x20, 0x1D, 0xDF,
+	0x15, 0x20, 0x15, 0xDF,
+	0x1D, 0x20, 0x1D, 0xDF,
 
-0x26, 0xD0, 0x26, 0xCD,
-0x29, 0x49, 0x2A, 0xB8,
+	0x26, 0xD0, 0x26, 0xCD,
+	0x29, 0x49, 0x2A, 0xB8,
 
-0x26, 0x40, 0x80, 0xBD,
-0x3B, 0x48, 0x50, 0xBD,
+	0x26, 0x40, 0x80, 0xBD,
+	0x3B, 0x48, 0x50, 0xBD,
 
-0x3E, 0x54, 0x57, 0x9F,
-0x00, 0xE0,
-0x82, 0xE1,
+	0x3E, 0x54, 0x57, 0x9F,
+	0x00, 0xE0,
+	0x82, 0xE1,
 
-0x1E, 0xAF, 0x59, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x1E, 0xAF, 0x59, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x26, 0x30,
-0x29, 0x30,
-0x48, 0x3C, 0x48, 0xAD,
+	0x26, 0x30,
+	0x29, 0x30,
+	0x48, 0x3C, 0x48, 0xAD,
 
-0x2B, 0x72,
-0xC2, 0xE1,
-0x2C, 0xC0, 0x44, 0xC2,
+	0x2B, 0x72,
+	0xC2, 0xE1,
+	0x2C, 0xC0, 0x44, 0xC2,
 
-0x05, 0x24, 0x34, 0xBF,
-0x0D, 0x24, 0x2C, 0xBF,
+	0x05, 0x24, 0x34, 0xBF,
+	0x0D, 0x24, 0x2C, 0xBF,
 
-0x2D, 0x46, 0x4E, 0xBF,
-0x25, 0x46, 0x56, 0xBF,
+	0x2D, 0x46, 0x4E, 0xBF,
+	0x25, 0x46, 0x56, 0xBF,
 
-0x20, 0x1D, 0x6F, 0x8F,
-0x32, 0x3E, 0x5F, 0xE9,
+	0x20, 0x1D, 0x6F, 0x8F,
+	0x32, 0x3E, 0x5F, 0xE9,
 
-0x3E, 0x50, 0x56, 0x9F,
-0x00, 0xE0,
-0x3B, 0x30,
+	0x3E, 0x50, 0x56, 0x9F,
+	0x00, 0xE0,
+	0x3B, 0x30,
 
-0x1E, 0x8F, 0x51, 0x9F,
-0x33, 0x1E, 0x5F, 0xE9,
+	0x1E, 0x8F, 0x51, 0x9F,
+	0x33, 0x1E, 0x5F, 0xE9,
 
-0x05, 0x44, 0x54, 0xB2,
-0x0D, 0x44, 0x4C, 0xB2,
+	0x05, 0x44, 0x54, 0xB2,
+	0x0D, 0x44, 0x4C, 0xB2,
 
-0x19, 0xC0, 0xB0, 0xE8,
-0x34, 0xC0, 0x44, 0xC4,
+	0x19, 0xC0, 0xB0, 0xE8,
+	0x34, 0xC0, 0x44, 0xC4,
 
-0x33, 0x73,
-0x00, 0xE0,
-0x3E, 0x62, 0x57, 0x9F,
+	0x33, 0x73,
+	0x00, 0xE0,
+	0x3E, 0x62, 0x57, 0x9F,
 
-0x1E, 0xAF, 0x59, 0x9F,
-0x00, 0xE0,
-0x0D, 0x20,
+	0x1E, 0xAF, 0x59, 0x9F,
+	0x00, 0xE0,
+	0x0D, 0x20,
 
-0x84, 0x3E, 0x58, 0xE9,
-0x28, 0x1D, 0x6F, 0x8F,
+	0x84, 0x3E, 0x58, 0xE9,
+	0x28, 0x1D, 0x6F, 0x8F,
 
-0x05, 0x20,
-0x00, 0xE0,
-0x85, 0x1E, 0x58, 0xE9,
+	0x05, 0x20,
+	0x00, 0xE0,
+	0x85, 0x1E, 0x58, 0xE9,
 
-0x9B, 0x3B, 0x33, 0xDF,
-0x20, 0x20, 0x42, 0xAF,
+	0x9B, 0x3B, 0x33, 0xDF,
+	0x20, 0x20, 0x42, 0xAF,
 
-0x30, 0x42, 0x56, 0x9F,
-0x80, 0x3E, 0x57, 0xE9,
+	0x30, 0x42, 0x56, 0x9F,
+	0x80, 0x3E, 0x57, 0xE9,
 
-0x3F, 0x8F, 0x51, 0x9F,
-0x30, 0x80, 0x5F, 0xE9,
+	0x3F, 0x8F, 0x51, 0x9F,
+	0x30, 0x80, 0x5F, 0xE9,
 
-0x28, 0x28, 0x24, 0xAF,
-0x81, 0x1E, 0x57, 0xE9,
+	0x28, 0x28, 0x24, 0xAF,
+	0x81, 0x1E, 0x57, 0xE9,
 
-0x05, 0x47, 0x57, 0xBF,
-0x0D, 0x47, 0x4F, 0xBF,
+	0x05, 0x47, 0x57, 0xBF,
+	0x0D, 0x47, 0x4F, 0xBF,
 
-0x88, 0x80, 0x58, 0xE9,
-0x1B, 0x29, 0x1B, 0xDF,
+	0x88, 0x80, 0x58, 0xE9,
+	0x1B, 0x29, 0x1B, 0xDF,
 
-0x30, 0x1D, 0x6F, 0x8F,
-0x3A, 0x30, 0x4F, 0xE9,
+	0x30, 0x1D, 0x6F, 0x8F,
+	0x3A, 0x30, 0x4F, 0xE9,
 
-0x1C, 0x30, 0x26, 0xDF,
-0x09, 0xE3,
-0x3B, 0x05,
+	0x1C, 0x30, 0x26, 0xDF,
+	0x09, 0xE3,
+	0x3B, 0x05,
 
-0x3E, 0x50, 0x56, 0x9F,
-0x3B, 0x3F, 0x4F, 0xE9,
+	0x3E, 0x50, 0x56, 0x9F,
+	0x3B, 0x3F, 0x4F, 0xE9,
 
-0x1E, 0x8F, 0x51, 0x9F,
-0x00, 0xE0,
-0xAC, 0x20,
+	0x1E, 0x8F, 0x51, 0x9F,
+	0x00, 0xE0,
+	0xAC, 0x20,
 
-0x2D, 0x44, 0x4C, 0xB4,
-0x2C, 0x1C, 0xC0, 0xAF,
+	0x2D, 0x44, 0x4C, 0xB4,
+	0x2C, 0x1C, 0xC0, 0xAF,
 
-0x25, 0x44, 0x54, 0xB4,
-0x00, 0xE0,
-0xC8, 0x30,
+	0x25, 0x44, 0x54, 0xB4,
+	0x00, 0xE0,
+	0xC8, 0x30,
 
-0x30, 0x46, 0x30, 0xAF,
-0x1B, 0x1B, 0x48, 0xAF,
+	0x30, 0x46, 0x30, 0xAF,
+	0x1B, 0x1B, 0x48, 0xAF,
 
-0x00, 0xE0,
-0x25, 0x20,
-0x38, 0x2C, 0x4F, 0xE9,
+	0x00, 0xE0,
+	0x25, 0x20,
+	0x38, 0x2C, 0x4F, 0xE9,
 
-0x86, 0x80, 0x57, 0xE9,
-0x38, 0x1D, 0x6F, 0x8F,
+	0x86, 0x80, 0x57, 0xE9,
+	0x38, 0x1D, 0x6F, 0x8F,
 
-0x28, 0x74,
-0x00, 0xE0,
-0x0D, 0x44, 0x4C, 0xB0,
+	0x28, 0x74,
+	0x00, 0xE0,
+	0x0D, 0x44, 0x4C, 0xB0,
 
-0x05, 0x44, 0x54, 0xB0,
-0x2D, 0x20,
-0x9B, 0x10,
+	0x05, 0x44, 0x54, 0xB0,
+	0x2D, 0x20,
+	0x9B, 0x10,
 
-0x82, 0x3E, 0x57, 0xE9,
-0x32, 0xF0, 0x1B, 0xCD,
+	0x82, 0x3E, 0x57, 0xE9,
+	0x32, 0xF0, 0x1B, 0xCD,
 
-0x1E, 0xBD, 0x59, 0x9F,
-0x83, 0x1E, 0x57, 0xE9,
+	0x1E, 0xBD, 0x59, 0x9F,
+	0x83, 0x1E, 0x57, 0xE9,
 
-0x38, 0x47, 0x38, 0xAF,
-0x34, 0x20,
-0x2A, 0x30,
+	0x38, 0x47, 0x38, 0xAF,
+	0x34, 0x20,
+	0x2A, 0x30,
 
-0x00, 0xE0,
-0x0D, 0x20,
-0x32, 0x20,
-0x05, 0x20,
+	0x00, 0xE0,
+	0x0D, 0x20,
+	0x32, 0x20,
+	0x05, 0x20,
 
-0x87, 0x80, 0x57, 0xE9,
-0x1F, 0x54, 0x57, 0x9F,
+	0x87, 0x80, 0x57, 0xE9,
+	0x1F, 0x54, 0x57, 0x9F,
 
-0x17, 0x42, 0x56, 0x9F,
-0x00, 0xE0,
-0x3B, 0x6A,
+	0x17, 0x42, 0x56, 0x9F,
+	0x00, 0xE0,
+	0x3B, 0x6A,
 
-0x3F, 0x8F, 0x51, 0x9F,
-0x37, 0x1E, 0x4F, 0xE9,
+	0x3F, 0x8F, 0x51, 0x9F,
+	0x37, 0x1E, 0x4F, 0xE9,
 
-0x37, 0x32, 0x2A, 0xAF,
-0x00, 0xE0,
-0x32, 0x00,
+	0x37, 0x32, 0x2A, 0xAF,
+	0x00, 0xE0,
+	0x32, 0x00,
 
-0x00, 0x80, 0x00, 0xE8,
-0x27, 0xC0, 0x44, 0xC0,
+	0x00, 0x80, 0x00, 0xE8,
+	0x27, 0xC0, 0x44, 0xC0,
 
-0x36, 0x1F, 0x4F, 0xE9,
-0x1F, 0x1F, 0x26, 0xDF,
+	0x36, 0x1F, 0x4F, 0xE9,
+	0x1F, 0x1F, 0x26, 0xDF,
 
-0x37, 0x1B, 0x37, 0xBF,
-0x17, 0x26, 0x17, 0xDF,
+	0x37, 0x1B, 0x37, 0xBF,
+	0x17, 0x26, 0x17, 0xDF,
 
-0x3E, 0x17, 0x4F, 0xE9,
-0x3F, 0x3F, 0x4F, 0xE9,
+	0x3E, 0x17, 0x4F, 0xE9,
+	0x3F, 0x3F, 0x4F, 0xE9,
 
-0x34, 0x1F, 0x34, 0xAF,
-0x2B, 0x05,
-0xA7, 0x20,
+	0x34, 0x1F, 0x34, 0xAF,
+	0x2B, 0x05,
+	0xA7, 0x20,
 
-0x33, 0x2B, 0x37, 0xDF,
-0x27, 0x17, 0xC0, 0xAF,
+	0x33, 0x2B, 0x37, 0xDF,
+	0x27, 0x17, 0xC0, 0xAF,
 
-0x34, 0x80, 0x4F, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0x34, 0x80, 0x4F, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x2D, 0x21, 0x1A, 0xB0,
-0x25, 0x21, 0x31, 0xB0,
+	0x2D, 0x21, 0x1A, 0xB0,
+	0x25, 0x21, 0x31, 0xB0,
 
-0x0D, 0x21, 0x1A, 0xB2,
-0x05, 0x21, 0x31, 0xB2,
+	0x0D, 0x21, 0x1A, 0xB2,
+	0x05, 0x21, 0x31, 0xB2,
 
-0x03, 0x80, 0x2A, 0xEA,
-0x17, 0xC1, 0x2B, 0xBD,
+	0x03, 0x80, 0x2A, 0xEA,
+	0x17, 0xC1, 0x2B, 0xBD,
 
-0x2D, 0x20,
-0x25, 0x20,
-0x05, 0x20,
-0x0D, 0x20,
+	0x2D, 0x20,
+	0x25, 0x20,
+	0x05, 0x20,
+	0x0D, 0x20,
 
-0xB3, 0x68,
-0x97, 0x25,
-0x00, 0x80, 0x00, 0xE8,
+	0xB3, 0x68,
+	0x97, 0x25,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x33, 0xC0, 0x33, 0xAF,
-0x2F, 0xC0, 0x21, 0xC0,
+	0x33, 0xC0, 0x33, 0xAF,
+	0x2F, 0xC0, 0x21, 0xC0,
 
-0x16, 0x42, 0x56, 0x9F,
-0x3C, 0x27, 0x4F, 0xE9,
+	0x16, 0x42, 0x56, 0x9F,
+	0x3C, 0x27, 0x4F, 0xE9,
 
-0x1E, 0x62, 0x57, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x1E, 0x62, 0x57, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x25, 0x21, 0x31, 0xB4,
-0x2D, 0x21, 0x1A, 0xB4,
+	0x25, 0x21, 0x31, 0xB4,
+	0x2D, 0x21, 0x1A, 0xB4,
 
-0x3F, 0x2F, 0x5D, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x3F, 0x2F, 0x5D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x33, 0x05,
-0x00, 0xE0,
-0x28, 0x19, 0x60, 0xEC,
+	0x33, 0x05,
+	0x00, 0xE0,
+	0x28, 0x19, 0x60, 0xEC,
 
-0x0D, 0x44, 0x4C, 0xB6,
-0x05, 0x44, 0x54, 0xB6,
+	0x0D, 0x44, 0x4C, 0xB6,
+	0x05, 0x44, 0x54, 0xB6,
 
-0x37, 0x0F, 0x5C, 0x9F,
-0x00, 0xE0,
-0x2F, 0x20,
+	0x37, 0x0F, 0x5C, 0x9F,
+	0x00, 0xE0,
+	0x2F, 0x20,
 
-0x23, 0x3B, 0x33, 0xAD,
-0x1E, 0x26, 0x1E, 0xDF,
+	0x23, 0x3B, 0x33, 0xAD,
+	0x1E, 0x26, 0x1E, 0xDF,
 
-0xA7, 0x1E, 0x4F, 0xE9,
-0x17, 0x26, 0x16, 0xDF,
+	0xA7, 0x1E, 0x4F, 0xE9,
+	0x17, 0x26, 0x16, 0xDF,
 
-0x2D, 0x20,
-0x00, 0xE0,
-0xA8, 0x3F, 0x4F, 0xE9,
+	0x2D, 0x20,
+	0x00, 0xE0,
+	0xA8, 0x3F, 0x4F, 0xE9,
 
-0x2F, 0x2F, 0x1E, 0xAF,
-0x25, 0x20,
-0x00, 0xE0,
+	0x2F, 0x2F, 0x1E, 0xAF,
+	0x25, 0x20,
+	0x00, 0xE0,
 
-0xA4, 0x16, 0x4F, 0xE9,
-0x0F, 0xC0, 0x21, 0xC2,
+	0xA4, 0x16, 0x4F, 0xE9,
+	0x0F, 0xC0, 0x21, 0xC2,
 
-0xA6, 0x80, 0x4F, 0xE9,
-0x1F, 0x62, 0x57, 0x9F,
+	0xA6, 0x80, 0x4F, 0xE9,
+	0x1F, 0x62, 0x57, 0x9F,
 
-0x0D, 0x20,
-0x05, 0x20,
-0x00, 0x80, 0x00, 0xE8,
+	0x0D, 0x20,
+	0x05, 0x20,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x3F, 0x2F, 0x5D, 0x9F,
-0x00, 0xE0,
-0x0F, 0x20,
+	0x3F, 0x2F, 0x5D, 0x9F,
+	0x00, 0xE0,
+	0x0F, 0x20,
 
-0x17, 0x50, 0x56, 0x9F,
-0xA5, 0x37, 0x4F, 0xE9,
+	0x17, 0x50, 0x56, 0x9F,
+	0xA5, 0x37, 0x4F, 0xE9,
 
-0x06, 0xC0, 0x21, 0xC4,
-0x0F, 0x17, 0x0F, 0xAF,
+	0x06, 0xC0, 0x21, 0xC4,
+	0x0F, 0x17, 0x0F, 0xAF,
 
-0x37, 0x0F, 0x5C, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x37, 0x0F, 0x5C, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x2F, 0xC0, 0x44, 0xC6,
-0xA3, 0x80, 0x4F, 0xE9,
+	0x2F, 0xC0, 0x44, 0xC6,
+	0xA3, 0x80, 0x4F, 0xE9,
 
-0x06, 0x20,
-0x00, 0xE0,
-0x1F, 0x26, 0x1F, 0xDF,
+	0x06, 0x20,
+	0x00, 0xE0,
+	0x1F, 0x26, 0x1F, 0xDF,
 
-0x17, 0x26, 0x17, 0xDF,
-0x9D, 0x17, 0x4F, 0xE9,
+	0x17, 0x26, 0x17, 0xDF,
+	0x9D, 0x17, 0x4F, 0xE9,
 
-0xA1, 0x1F, 0x4F, 0xE9,
-0xA2, 0x3F, 0x4F, 0xE9,
+	0xA1, 0x1F, 0x4F, 0xE9,
+	0xA2, 0x3F, 0x4F, 0xE9,
 
-0x06, 0x06, 0x1F, 0xAF,
-0x00, 0xE0,
-0xAF, 0x20,
+	0x06, 0x06, 0x1F, 0xAF,
+	0x00, 0xE0,
+	0xAF, 0x20,
 
-0x9E, 0x37, 0x4F, 0xE9,
-0x2F, 0x17, 0x2F, 0xAF,
+	0x9E, 0x37, 0x4F, 0xE9,
+	0x2F, 0x17, 0x2F, 0xAF,
 
-0xA0, 0x80, 0x4F, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0xA0, 0x80, 0x4F, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x9C, 0x80, 0x4F, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+	0x9C, 0x80, 0x4F, 0xE9,
 
-0x00, 0x80, 0x00, 0xE8,
-0x57, 0x39, 0x20, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+	0x57, 0x39, 0x20, 0xE9,
 
-0x16, 0x28, 0x20, 0xE9,
-0x1D, 0x3B, 0x20, 0xE9,
+	0x16, 0x28, 0x20, 0xE9,
+	0x1D, 0x3B, 0x20, 0xE9,
 
-0x1E, 0x2B, 0x20, 0xE9,
-0x2B, 0x32, 0x20, 0xE9,
+	0x1E, 0x2B, 0x20, 0xE9,
+	0x2B, 0x32, 0x20, 0xE9,
 
-0x1C, 0x23, 0x20, 0xE9,
-0x57, 0x36, 0x20, 0xE9,
+	0x1C, 0x23, 0x20, 0xE9,
+	0x57, 0x36, 0x20, 0xE9,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x40, 0x40, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x40, 0x40, 0xD8, 0xEC,
 
-0xFF, 0x80, 0xC0, 0xE9,
-0x90, 0xE2,
-0x00, 0xE0,
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x90, 0xE2,
+	0x00, 0xE0,
 
-0x68, 0xFF, 0x20, 0xEA,
-0x19, 0xC8, 0xC1, 0xCD,
+	0x68, 0xFF, 0x20, 0xEA,
+	0x19, 0xC8, 0xC1, 0xCD,
 
-0x1F, 0xD7, 0x18, 0xBD,
-0x3F, 0xD7, 0x22, 0xBD,
+	0x1F, 0xD7, 0x18, 0xBD,
+	0x3F, 0xD7, 0x22, 0xBD,
 
-0x9F, 0x41, 0x49, 0xBD,
-0x00, 0x80, 0x00, 0xE8,
+	0x9F, 0x41, 0x49, 0xBD,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x25, 0x41, 0x49, 0xBD,
-0x2D, 0x41, 0x51, 0xBD,
+	0x25, 0x41, 0x49, 0xBD,
+	0x2D, 0x41, 0x51, 0xBD,
 
-0x0D, 0x80, 0x07, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0x0D, 0x80, 0x07, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x35, 0x40, 0x48, 0xBD,
-0x3D, 0x40, 0x50, 0xBD,
+	0x35, 0x40, 0x48, 0xBD,
+	0x3D, 0x40, 0x50, 0xBD,
 
-0x00, 0x80, 0x00, 0xE8,
-0x25, 0x30,
-0x2D, 0x30,
+	0x00, 0x80, 0x00, 0xE8,
+	0x25, 0x30,
+	0x2D, 0x30,
 
-0x35, 0x30,
-0xB5, 0x30,
-0xBD, 0x30,
-0x3D, 0x30,
+	0x35, 0x30,
+	0xB5, 0x30,
+	0xBD, 0x30,
+	0x3D, 0x30,
 
-0x9C, 0xA7, 0x5B, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x9C, 0xA7, 0x5B, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x67, 0xFF, 0x0A, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0x67, 0xFF, 0x0A, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xC9, 0x41, 0xC8, 0xEC,
-0x42, 0xE1,
-0x00, 0xE0,
+	0xC9, 0x41, 0xC8, 0xEC,
+	0x42, 0xE1,
+	0x00, 0xE0,
 
-0x65, 0xFF, 0x20, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0x65, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xC8, 0x40, 0xC0, 0xEC,
-0x00, 0x80, 0x00, 0xE8,
+	0xC8, 0x40, 0xC0, 0xEC,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x62, 0xFF, 0x20, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0x62, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
 };
 
 static unsigned char warp_g200_tgzsaf[] = {
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x98, 0xA0, 0xE9,
-0x40, 0x40, 0xD8, 0xEC,
+	0x00, 0x98, 0xA0, 0xE9,
+	0x40, 0x40, 0xD8, 0xEC,
 
-0xFF, 0x80, 0xC0, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x1F, 0xD7, 0x18, 0xBD,
-0x3F, 0xD7, 0x22, 0xBD,
+	0x1F, 0xD7, 0x18, 0xBD,
+	0x3F, 0xD7, 0x22, 0xBD,
 
-0x81, 0x04,
-0x89, 0x04,
-0x01, 0x04,
-0x09, 0x04,
+	0x81, 0x04,
+	0x89, 0x04,
+	0x01, 0x04,
+	0x09, 0x04,
 
-0xC9, 0x41, 0xC0, 0xEC,
-0x11, 0x04,
-0x00, 0xE0,
+	0xC9, 0x41, 0xC0, 0xEC,
+	0x11, 0x04,
+	0x00, 0xE0,
 
-0x41, 0xCC, 0x41, 0xCD,
-0x49, 0xCC, 0x49, 0xCD,
+	0x41, 0xCC, 0x41, 0xCD,
+	0x49, 0xCC, 0x49, 0xCD,
 
-0xD1, 0x41, 0xC0, 0xEC,
-0x51, 0xCC, 0x51, 0xCD,
+	0xD1, 0x41, 0xC0, 0xEC,
+	0x51, 0xCC, 0x51, 0xCD,
 
-0x80, 0x04,
-0x10, 0x04,
-0x08, 0x04,
-0x00, 0xE0,
+	0x80, 0x04,
+	0x10, 0x04,
+	0x08, 0x04,
+	0x00, 0xE0,
 
-0x00, 0xCC, 0xC0, 0xCD,
-0xD1, 0x49, 0xC0, 0xEC,
+	0x00, 0xCC, 0xC0, 0xCD,
+	0xD1, 0x49, 0xC0, 0xEC,
 
-0x8A, 0x1F, 0x20, 0xE9,
-0x8B, 0x3F, 0x20, 0xE9,
+	0x8A, 0x1F, 0x20, 0xE9,
+	0x8B, 0x3F, 0x20, 0xE9,
 
-0x41, 0x3C, 0x41, 0xAD,
-0x49, 0x3C, 0x49, 0xAD,
+	0x41, 0x3C, 0x41, 0xAD,
+	0x49, 0x3C, 0x49, 0xAD,
 
-0x10, 0xCC, 0x10, 0xCD,
-0x08, 0xCC, 0x08, 0xCD,
+	0x10, 0xCC, 0x10, 0xCD,
+	0x08, 0xCC, 0x08, 0xCD,
 
-0xB9, 0x41, 0x49, 0xBB,
-0x1F, 0xF0, 0x41, 0xCD,
+	0xB9, 0x41, 0x49, 0xBB,
+	0x1F, 0xF0, 0x41, 0xCD,
 
-0x51, 0x3C, 0x51, 0xAD,
-0x00, 0x98, 0x80, 0xE9,
+	0x51, 0x3C, 0x51, 0xAD,
+	0x00, 0x98, 0x80, 0xE9,
 
-0x94, 0x80, 0x07, 0xEA,
-0x24, 0x1F, 0x20, 0xE9,
+	0x94, 0x80, 0x07, 0xEA,
+	0x24, 0x1F, 0x20, 0xE9,
 
-0x21, 0x45, 0x80, 0xE8,
-0x1A, 0x4D, 0x80, 0xE8,
+	0x21, 0x45, 0x80, 0xE8,
+	0x1A, 0x4D, 0x80, 0xE8,
 
-0x31, 0x55, 0x80, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x31, 0x55, 0x80, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x15, 0x41, 0x49, 0xBD,
-0x1D, 0x41, 0x51, 0xBD,
+	0x15, 0x41, 0x49, 0xBD,
+	0x1D, 0x41, 0x51, 0xBD,
 
-0x2E, 0x41, 0x2A, 0xB8,
-0x34, 0x53, 0xA0, 0xE8,
+	0x2E, 0x41, 0x2A, 0xB8,
+	0x34, 0x53, 0xA0, 0xE8,
 
-0x15, 0x30,
-0x1D, 0x30,
-0x58, 0xE3,
-0x00, 0xE0,
+	0x15, 0x30,
+	0x1D, 0x30,
+	0x58, 0xE3,
+	0x00, 0xE0,
 
-0xB5, 0x40, 0x48, 0xBD,
-0x3D, 0x40, 0x50, 0xBD,
+	0xB5, 0x40, 0x48, 0xBD,
+	0x3D, 0x40, 0x50, 0xBD,
 
-0x24, 0x43, 0xA0, 0xE8,
-0x2C, 0x4B, 0xA0, 0xE8,
+	0x24, 0x43, 0xA0, 0xE8,
+	0x2C, 0x4B, 0xA0, 0xE8,
 
-0x15, 0x72,
-0x09, 0xE3,
-0x00, 0xE0,
-0x1D, 0x72,
+	0x15, 0x72,
+	0x09, 0xE3,
+	0x00, 0xE0,
+	0x1D, 0x72,
 
-0x35, 0x30,
-0xB5, 0x30,
-0xBD, 0x30,
-0x3D, 0x30,
+	0x35, 0x30,
+	0xB5, 0x30,
+	0xBD, 0x30,
+	0x3D, 0x30,
 
-0x9C, 0x97, 0x57, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x9C, 0x97, 0x57, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x6C, 0x64, 0xC8, 0xEC,
-0x98, 0xE1,
-0xB5, 0x05,
+	0x6C, 0x64, 0xC8, 0xEC,
+	0x98, 0xE1,
+	0xB5, 0x05,
 
-0xBD, 0x05,
-0x2E, 0x30,
-0x32, 0xC0, 0xA0, 0xE8,
+	0xBD, 0x05,
+	0x2E, 0x30,
+	0x32, 0xC0, 0xA0, 0xE8,
 
-0x33, 0xC0, 0xA0, 0xE8,
-0x74, 0x64, 0xC8, 0xEC,
+	0x33, 0xC0, 0xA0, 0xE8,
+	0x74, 0x64, 0xC8, 0xEC,
 
-0x40, 0x3C, 0x40, 0xAD,
-0x32, 0x6A,
-0x2A, 0x30,
+	0x40, 0x3C, 0x40, 0xAD,
+	0x32, 0x6A,
+	0x2A, 0x30,
 
-0x20, 0x73,
-0x33, 0x6A,
-0x00, 0xE0,
-0x28, 0x73,
+	0x20, 0x73,
+	0x33, 0x6A,
+	0x00, 0xE0,
+	0x28, 0x73,
 
-0x1C, 0x72,
-0x83, 0xE2,
-0x80, 0x80, 0x15, 0xEA,
+	0x1C, 0x72,
+	0x83, 0xE2,
+	0x80, 0x80, 0x15, 0xEA,
 
-0xB8, 0x3D, 0x28, 0xDF,
-0x30, 0x35, 0x20, 0xDF,
+	0xB8, 0x3D, 0x28, 0xDF,
+	0x30, 0x35, 0x20, 0xDF,
 
-0x40, 0x30,
-0x00, 0xE0,
-0xCC, 0xE2,
-0x64, 0x72,
+	0x40, 0x30,
+	0x00, 0xE0,
+	0xCC, 0xE2,
+	0x64, 0x72,
 
-0x25, 0x42, 0x52, 0xBF,
-0x2D, 0x42, 0x4A, 0xBF,
+	0x25, 0x42, 0x52, 0xBF,
+	0x2D, 0x42, 0x4A, 0xBF,
 
-0x30, 0x2E, 0x30, 0xDF,
-0x38, 0x2E, 0x38, 0xDF,
+	0x30, 0x2E, 0x30, 0xDF,
+	0x38, 0x2E, 0x38, 0xDF,
 
-0x18, 0x1D, 0x45, 0xE9,
-0x1E, 0x15, 0x45, 0xE9,
+	0x18, 0x1D, 0x45, 0xE9,
+	0x1E, 0x15, 0x45, 0xE9,
 
-0x2B, 0x49, 0x51, 0xBD,
-0x00, 0xE0,
-0x1F, 0x73,
+	0x2B, 0x49, 0x51, 0xBD,
+	0x00, 0xE0,
+	0x1F, 0x73,
 
-0x38, 0x38, 0x40, 0xAF,
-0x30, 0x30, 0x40, 0xAF,
+	0x38, 0x38, 0x40, 0xAF,
+	0x30, 0x30, 0x40, 0xAF,
 
-0x24, 0x1F, 0x24, 0xDF,
-0x1D, 0x32, 0x20, 0xE9,
+	0x24, 0x1F, 0x24, 0xDF,
+	0x1D, 0x32, 0x20, 0xE9,
 
-0x2C, 0x1F, 0x2C, 0xDF,
-0x1A, 0x33, 0x20, 0xE9,
+	0x2C, 0x1F, 0x2C, 0xDF,
+	0x1A, 0x33, 0x20, 0xE9,
 
-0xB0, 0x10,
-0x08, 0xE3,
-0x40, 0x10,
-0xB8, 0x10,
+	0xB0, 0x10,
+	0x08, 0xE3,
+	0x40, 0x10,
+	0xB8, 0x10,
 
-0x26, 0xF0, 0x30, 0xCD,
-0x2F, 0xF0, 0x38, 0xCD,
+	0x26, 0xF0, 0x30, 0xCD,
+	0x2F, 0xF0, 0x38, 0xCD,
 
-0x2B, 0x80, 0x20, 0xE9,
-0x2A, 0x80, 0x20, 0xE9,
+	0x2B, 0x80, 0x20, 0xE9,
+	0x2A, 0x80, 0x20, 0xE9,
 
-0xA6, 0x20,
-0x88, 0xE2,
-0x00, 0xE0,
-0xAF, 0x20,
+	0xA6, 0x20,
+	0x88, 0xE2,
+	0x00, 0xE0,
+	0xAF, 0x20,
 
-0x28, 0x2A, 0x26, 0xAF,
-0x20, 0x2A, 0xC0, 0xAF,
+	0x28, 0x2A, 0x26, 0xAF,
+	0x20, 0x2A, 0xC0, 0xAF,
 
-0x34, 0x1F, 0x34, 0xDF,
-0x46, 0x24, 0x46, 0xDF,
+	0x34, 0x1F, 0x34, 0xDF,
+	0x46, 0x24, 0x46, 0xDF,
 
-0x28, 0x30, 0x80, 0xBF,
-0x20, 0x38, 0x80, 0xBF,
+	0x28, 0x30, 0x80, 0xBF,
+	0x20, 0x38, 0x80, 0xBF,
 
-0x47, 0x24, 0x47, 0xDF,
-0x4E, 0x2C, 0x4E, 0xDF,
+	0x47, 0x24, 0x47, 0xDF,
+	0x4E, 0x2C, 0x4E, 0xDF,
 
-0x4F, 0x2C, 0x4F, 0xDF,
-0x56, 0x34, 0x56, 0xDF,
+	0x4F, 0x2C, 0x4F, 0xDF,
+	0x56, 0x34, 0x56, 0xDF,
 
-0x28, 0x15, 0x28, 0xDF,
-0x20, 0x1D, 0x20, 0xDF,
+	0x28, 0x15, 0x28, 0xDF,
+	0x20, 0x1D, 0x20, 0xDF,
 
-0x57, 0x34, 0x57, 0xDF,
-0x00, 0xE0,
-0x1D, 0x05,
+	0x57, 0x34, 0x57, 0xDF,
+	0x00, 0xE0,
+	0x1D, 0x05,
 
-0x04, 0x80, 0x10, 0xEA,
-0x89, 0xE2,
-0x2B, 0x30,
+	0x04, 0x80, 0x10, 0xEA,
+	0x89, 0xE2,
+	0x2B, 0x30,
 
-0x3F, 0xC1, 0x1D, 0xBD,
-0x00, 0x80, 0x00, 0xE8,
+	0x3F, 0xC1, 0x1D, 0xBD,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xA0, 0x68,
-0xBF, 0x25,
-0x00, 0x80, 0x00, 0xE8,
+	0xA0, 0x68,
+	0xBF, 0x25,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x20, 0xC0, 0x20, 0xAF,
-0x28, 0x05,
-0x97, 0x74,
+	0x20, 0xC0, 0x20, 0xAF,
+	0x28, 0x05,
+	0x97, 0x74,
 
-0x00, 0xE0,
-0x2A, 0x10,
-0x16, 0xC0, 0x20, 0xE9,
+	0x00, 0xE0,
+	0x2A, 0x10,
+	0x16, 0xC0, 0x20, 0xE9,
 
-0x04, 0x80, 0x10, 0xEA,
-0x8C, 0xE2,
-0x95, 0x05,
+	0x04, 0x80, 0x10, 0xEA,
+	0x8C, 0xE2,
+	0x95, 0x05,
 
-0x28, 0xC1, 0x28, 0xAD,
-0x1F, 0xC1, 0x15, 0xBD,
+	0x28, 0xC1, 0x28, 0xAD,
+	0x1F, 0xC1, 0x15, 0xBD,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xA8, 0x67,
-0x9F, 0x6B,
-0x00, 0x80, 0x00, 0xE8,
+	0xA8, 0x67,
+	0x9F, 0x6B,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x28, 0xC0, 0x28, 0xAD,
-0x1D, 0x25,
-0x20, 0x05,
+	0x28, 0xC0, 0x28, 0xAD,
+	0x1D, 0x25,
+	0x20, 0x05,
 
-0x28, 0x32, 0x80, 0xAD,
-0x40, 0x2A, 0x40, 0xBD,
+	0x28, 0x32, 0x80, 0xAD,
+	0x40, 0x2A, 0x40, 0xBD,
 
-0x1C, 0x80, 0x20, 0xE9,
-0x20, 0x33, 0x20, 0xAD,
+	0x1C, 0x80, 0x20, 0xE9,
+	0x20, 0x33, 0x20, 0xAD,
 
-0x20, 0x73,
-0x00, 0xE0,
-0xB6, 0x49, 0x51, 0xBB,
+	0x20, 0x73,
+	0x00, 0xE0,
+	0xB6, 0x49, 0x51, 0xBB,
 
-0x26, 0x2F, 0xB0, 0xE8,
-0x19, 0x20, 0x20, 0xE9,
+	0x26, 0x2F, 0xB0, 0xE8,
+	0x19, 0x20, 0x20, 0xE9,
 
-0x35, 0x20, 0x35, 0xDF,
-0x3D, 0x20, 0x3D, 0xDF,
+	0x35, 0x20, 0x35, 0xDF,
+	0x3D, 0x20, 0x3D, 0xDF,
 
-0x15, 0x20, 0x15, 0xDF,
-0x1D, 0x20, 0x1D, 0xDF,
+	0x15, 0x20, 0x15, 0xDF,
+	0x1D, 0x20, 0x1D, 0xDF,
 
-0x26, 0xD0, 0x26, 0xCD,
-0x29, 0x49, 0x2A, 0xB8,
+	0x26, 0xD0, 0x26, 0xCD,
+	0x29, 0x49, 0x2A, 0xB8,
 
-0x26, 0x40, 0x80, 0xBD,
-0x3B, 0x48, 0x50, 0xBD,
+	0x26, 0x40, 0x80, 0xBD,
+	0x3B, 0x48, 0x50, 0xBD,
 
-0x3E, 0x54, 0x57, 0x9F,
-0x00, 0xE0,
-0x82, 0xE1,
+	0x3E, 0x54, 0x57, 0x9F,
+	0x00, 0xE0,
+	0x82, 0xE1,
 
-0x1E, 0xAF, 0x59, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x1E, 0xAF, 0x59, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x26, 0x30,
-0x29, 0x30,
-0x48, 0x3C, 0x48, 0xAD,
+	0x26, 0x30,
+	0x29, 0x30,
+	0x48, 0x3C, 0x48, 0xAD,
 
-0x2B, 0x72,
-0xC2, 0xE1,
-0x2C, 0xC0, 0x44, 0xC2,
+	0x2B, 0x72,
+	0xC2, 0xE1,
+	0x2C, 0xC0, 0x44, 0xC2,
 
-0x05, 0x24, 0x34, 0xBF,
-0x0D, 0x24, 0x2C, 0xBF,
+	0x05, 0x24, 0x34, 0xBF,
+	0x0D, 0x24, 0x2C, 0xBF,
 
-0x2D, 0x46, 0x4E, 0xBF,
-0x25, 0x46, 0x56, 0xBF,
+	0x2D, 0x46, 0x4E, 0xBF,
+	0x25, 0x46, 0x56, 0xBF,
 
-0x20, 0x1D, 0x6F, 0x8F,
-0x32, 0x3E, 0x5F, 0xE9,
+	0x20, 0x1D, 0x6F, 0x8F,
+	0x32, 0x3E, 0x5F, 0xE9,
 
-0x3E, 0x50, 0x56, 0x9F,
-0x00, 0xE0,
-0x3B, 0x30,
+	0x3E, 0x50, 0x56, 0x9F,
+	0x00, 0xE0,
+	0x3B, 0x30,
 
-0x1E, 0x8F, 0x51, 0x9F,
-0x33, 0x1E, 0x5F, 0xE9,
+	0x1E, 0x8F, 0x51, 0x9F,
+	0x33, 0x1E, 0x5F, 0xE9,
 
-0x05, 0x44, 0x54, 0xB2,
-0x0D, 0x44, 0x4C, 0xB2,
+	0x05, 0x44, 0x54, 0xB2,
+	0x0D, 0x44, 0x4C, 0xB2,
 
-0x19, 0xC0, 0xB0, 0xE8,
-0x34, 0xC0, 0x44, 0xC4,
+	0x19, 0xC0, 0xB0, 0xE8,
+	0x34, 0xC0, 0x44, 0xC4,
 
-0x33, 0x73,
-0x00, 0xE0,
-0x3E, 0x62, 0x57, 0x9F,
+	0x33, 0x73,
+	0x00, 0xE0,
+	0x3E, 0x62, 0x57, 0x9F,
 
-0x1E, 0xAF, 0x59, 0x9F,
-0x00, 0xE0,
-0x0D, 0x20,
+	0x1E, 0xAF, 0x59, 0x9F,
+	0x00, 0xE0,
+	0x0D, 0x20,
 
-0x84, 0x3E, 0x58, 0xE9,
-0x28, 0x1D, 0x6F, 0x8F,
+	0x84, 0x3E, 0x58, 0xE9,
+	0x28, 0x1D, 0x6F, 0x8F,
 
-0x05, 0x20,
-0x00, 0xE0,
-0x85, 0x1E, 0x58, 0xE9,
+	0x05, 0x20,
+	0x00, 0xE0,
+	0x85, 0x1E, 0x58, 0xE9,
 
-0x9B, 0x3B, 0x33, 0xDF,
-0x20, 0x20, 0x42, 0xAF,
+	0x9B, 0x3B, 0x33, 0xDF,
+	0x20, 0x20, 0x42, 0xAF,
 
-0x30, 0x42, 0x56, 0x9F,
-0x80, 0x3E, 0x57, 0xE9,
+	0x30, 0x42, 0x56, 0x9F,
+	0x80, 0x3E, 0x57, 0xE9,
 
-0x3F, 0x8F, 0x51, 0x9F,
-0x30, 0x80, 0x5F, 0xE9,
+	0x3F, 0x8F, 0x51, 0x9F,
+	0x30, 0x80, 0x5F, 0xE9,
 
-0x28, 0x28, 0x24, 0xAF,
-0x81, 0x1E, 0x57, 0xE9,
+	0x28, 0x28, 0x24, 0xAF,
+	0x81, 0x1E, 0x57, 0xE9,
 
-0x05, 0x47, 0x57, 0xBF,
-0x0D, 0x47, 0x4F, 0xBF,
+	0x05, 0x47, 0x57, 0xBF,
+	0x0D, 0x47, 0x4F, 0xBF,
 
-0x88, 0x80, 0x58, 0xE9,
-0x1B, 0x29, 0x1B, 0xDF,
+	0x88, 0x80, 0x58, 0xE9,
+	0x1B, 0x29, 0x1B, 0xDF,
 
-0x30, 0x1D, 0x6F, 0x8F,
-0x3A, 0x30, 0x4F, 0xE9,
+	0x30, 0x1D, 0x6F, 0x8F,
+	0x3A, 0x30, 0x4F, 0xE9,
 
-0x1C, 0x30, 0x26, 0xDF,
-0x09, 0xE3,
-0x3B, 0x05,
+	0x1C, 0x30, 0x26, 0xDF,
+	0x09, 0xE3,
+	0x3B, 0x05,
 
-0x3E, 0x50, 0x56, 0x9F,
-0x3B, 0x3F, 0x4F, 0xE9,
+	0x3E, 0x50, 0x56, 0x9F,
+	0x3B, 0x3F, 0x4F, 0xE9,
 
-0x1E, 0x8F, 0x51, 0x9F,
-0x00, 0xE0,
-0xAC, 0x20,
+	0x1E, 0x8F, 0x51, 0x9F,
+	0x00, 0xE0,
+	0xAC, 0x20,
 
-0x2D, 0x44, 0x4C, 0xB4,
-0x2C, 0x1C, 0xC0, 0xAF,
+	0x2D, 0x44, 0x4C, 0xB4,
+	0x2C, 0x1C, 0xC0, 0xAF,
 
-0x25, 0x44, 0x54, 0xB4,
-0x00, 0xE0,
-0xC8, 0x30,
+	0x25, 0x44, 0x54, 0xB4,
+	0x00, 0xE0,
+	0xC8, 0x30,
 
-0x30, 0x46, 0x30, 0xAF,
-0x1B, 0x1B, 0x48, 0xAF,
+	0x30, 0x46, 0x30, 0xAF,
+	0x1B, 0x1B, 0x48, 0xAF,
 
-0x00, 0xE0,
-0x25, 0x20,
-0x38, 0x2C, 0x4F, 0xE9,
+	0x00, 0xE0,
+	0x25, 0x20,
+	0x38, 0x2C, 0x4F, 0xE9,
 
-0x86, 0x80, 0x57, 0xE9,
-0x38, 0x1D, 0x6F, 0x8F,
+	0x86, 0x80, 0x57, 0xE9,
+	0x38, 0x1D, 0x6F, 0x8F,
 
-0x28, 0x74,
-0x00, 0xE0,
-0x0D, 0x44, 0x4C, 0xB0,
+	0x28, 0x74,
+	0x00, 0xE0,
+	0x0D, 0x44, 0x4C, 0xB0,
 
-0x05, 0x44, 0x54, 0xB0,
-0x2D, 0x20,
-0x9B, 0x10,
+	0x05, 0x44, 0x54, 0xB0,
+	0x2D, 0x20,
+	0x9B, 0x10,
 
-0x82, 0x3E, 0x57, 0xE9,
-0x32, 0xF0, 0x1B, 0xCD,
+	0x82, 0x3E, 0x57, 0xE9,
+	0x32, 0xF0, 0x1B, 0xCD,
 
-0x1E, 0xBD, 0x59, 0x9F,
-0x83, 0x1E, 0x57, 0xE9,
+	0x1E, 0xBD, 0x59, 0x9F,
+	0x83, 0x1E, 0x57, 0xE9,
 
-0x38, 0x47, 0x38, 0xAF,
-0x34, 0x20,
-0x2A, 0x30,
+	0x38, 0x47, 0x38, 0xAF,
+	0x34, 0x20,
+	0x2A, 0x30,
 
-0x00, 0xE0,
-0x0D, 0x20,
-0x32, 0x20,
-0x05, 0x20,
+	0x00, 0xE0,
+	0x0D, 0x20,
+	0x32, 0x20,
+	0x05, 0x20,
 
-0x87, 0x80, 0x57, 0xE9,
-0x1F, 0x54, 0x57, 0x9F,
+	0x87, 0x80, 0x57, 0xE9,
+	0x1F, 0x54, 0x57, 0x9F,
 
-0x17, 0x42, 0x56, 0x9F,
-0x00, 0xE0,
-0x3B, 0x6A,
+	0x17, 0x42, 0x56, 0x9F,
+	0x00, 0xE0,
+	0x3B, 0x6A,
 
-0x3F, 0x8F, 0x51, 0x9F,
-0x37, 0x1E, 0x4F, 0xE9,
+	0x3F, 0x8F, 0x51, 0x9F,
+	0x37, 0x1E, 0x4F, 0xE9,
 
-0x37, 0x32, 0x2A, 0xAF,
-0x00, 0xE0,
-0x32, 0x00,
+	0x37, 0x32, 0x2A, 0xAF,
+	0x00, 0xE0,
+	0x32, 0x00,
 
-0x00, 0x80, 0x00, 0xE8,
-0x27, 0xC0, 0x44, 0xC0,
+	0x00, 0x80, 0x00, 0xE8,
+	0x27, 0xC0, 0x44, 0xC0,
 
-0x36, 0x1F, 0x4F, 0xE9,
-0x1F, 0x1F, 0x26, 0xDF,
+	0x36, 0x1F, 0x4F, 0xE9,
+	0x1F, 0x1F, 0x26, 0xDF,
 
-0x37, 0x1B, 0x37, 0xBF,
-0x17, 0x26, 0x17, 0xDF,
+	0x37, 0x1B, 0x37, 0xBF,
+	0x17, 0x26, 0x17, 0xDF,
 
-0x3E, 0x17, 0x4F, 0xE9,
-0x3F, 0x3F, 0x4F, 0xE9,
+	0x3E, 0x17, 0x4F, 0xE9,
+	0x3F, 0x3F, 0x4F, 0xE9,
 
-0x34, 0x1F, 0x34, 0xAF,
-0x2B, 0x05,
-0xA7, 0x20,
+	0x34, 0x1F, 0x34, 0xAF,
+	0x2B, 0x05,
+	0xA7, 0x20,
 
-0x33, 0x2B, 0x37, 0xDF,
-0x27, 0x17, 0xC0, 0xAF,
+	0x33, 0x2B, 0x37, 0xDF,
+	0x27, 0x17, 0xC0, 0xAF,
 
-0x34, 0x80, 0x4F, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0x34, 0x80, 0x4F, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x2D, 0x21, 0x1A, 0xB0,
-0x25, 0x21, 0x31, 0xB0,
+	0x2D, 0x21, 0x1A, 0xB0,
+	0x25, 0x21, 0x31, 0xB0,
 
-0x0D, 0x21, 0x1A, 0xB2,
-0x05, 0x21, 0x31, 0xB2,
+	0x0D, 0x21, 0x1A, 0xB2,
+	0x05, 0x21, 0x31, 0xB2,
 
-0x03, 0x80, 0x2A, 0xEA,
-0x17, 0xC1, 0x2B, 0xBD,
+	0x03, 0x80, 0x2A, 0xEA,
+	0x17, 0xC1, 0x2B, 0xBD,
 
-0x2D, 0x20,
-0x25, 0x20,
-0x05, 0x20,
-0x0D, 0x20,
+	0x2D, 0x20,
+	0x25, 0x20,
+	0x05, 0x20,
+	0x0D, 0x20,
 
-0xB3, 0x68,
-0x97, 0x25,
-0x00, 0x80, 0x00, 0xE8,
+	0xB3, 0x68,
+	0x97, 0x25,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x33, 0xC0, 0x33, 0xAF,
-0x2F, 0xC0, 0x21, 0xC0,
+	0x33, 0xC0, 0x33, 0xAF,
+	0x2F, 0xC0, 0x21, 0xC0,
 
-0x16, 0x42, 0x56, 0x9F,
-0x3C, 0x27, 0x4F, 0xE9,
+	0x16, 0x42, 0x56, 0x9F,
+	0x3C, 0x27, 0x4F, 0xE9,
 
-0x1E, 0x62, 0x57, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x1E, 0x62, 0x57, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x25, 0x21, 0x31, 0xB4,
-0x2D, 0x21, 0x1A, 0xB4,
+	0x25, 0x21, 0x31, 0xB4,
+	0x2D, 0x21, 0x1A, 0xB4,
 
-0x3F, 0x2F, 0x5D, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x3F, 0x2F, 0x5D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x33, 0x05,
-0x00, 0xE0,
-0x28, 0x19, 0x60, 0xEC,
+	0x33, 0x05,
+	0x00, 0xE0,
+	0x28, 0x19, 0x60, 0xEC,
 
-0x0D, 0x21, 0x1A, 0xB6,
-0x05, 0x21, 0x31, 0xB6,
+	0x0D, 0x21, 0x1A, 0xB6,
+	0x05, 0x21, 0x31, 0xB6,
 
-0x37, 0x0F, 0x5C, 0x9F,
-0x00, 0xE0,
-0x2F, 0x20,
+	0x37, 0x0F, 0x5C, 0x9F,
+	0x00, 0xE0,
+	0x2F, 0x20,
 
-0x23, 0x3B, 0x33, 0xAD,
-0x1E, 0x26, 0x1E, 0xDF,
+	0x23, 0x3B, 0x33, 0xAD,
+	0x1E, 0x26, 0x1E, 0xDF,
 
-0xA7, 0x1E, 0x4F, 0xE9,
-0x17, 0x26, 0x16, 0xDF,
+	0xA7, 0x1E, 0x4F, 0xE9,
+	0x17, 0x26, 0x16, 0xDF,
 
-0x2D, 0x20,
-0x00, 0xE0,
-0xA8, 0x3F, 0x4F, 0xE9,
+	0x2D, 0x20,
+	0x00, 0xE0,
+	0xA8, 0x3F, 0x4F, 0xE9,
 
-0x2F, 0x2F, 0x1E, 0xAF,
-0x25, 0x20,
-0x00, 0xE0,
+	0x2F, 0x2F, 0x1E, 0xAF,
+	0x25, 0x20,
+	0x00, 0xE0,
 
-0xA4, 0x16, 0x4F, 0xE9,
-0x0F, 0xC0, 0x21, 0xC2,
+	0xA4, 0x16, 0x4F, 0xE9,
+	0x0F, 0xC0, 0x21, 0xC2,
 
-0xA6, 0x80, 0x4F, 0xE9,
-0x1F, 0x62, 0x57, 0x9F,
+	0xA6, 0x80, 0x4F, 0xE9,
+	0x1F, 0x62, 0x57, 0x9F,
 
-0x0D, 0x20,
-0x05, 0x20,
-0x2F, 0xC0, 0x21, 0xC6,
+	0x0D, 0x20,
+	0x05, 0x20,
+	0x2F, 0xC0, 0x21, 0xC6,
 
-0x2D, 0x44, 0x4C, 0xB6,
-0x25, 0x44, 0x54, 0xB6,
+	0x2D, 0x44, 0x4C, 0xB6,
+	0x25, 0x44, 0x54, 0xB6,
 
-0x3F, 0x2F, 0x5D, 0x9F,
-0x00, 0xE0,
-0x0F, 0x20,
+	0x3F, 0x2F, 0x5D, 0x9F,
+	0x00, 0xE0,
+	0x0F, 0x20,
 
-0x2D, 0x20,
-0x25, 0x20,
-0x07, 0xC0, 0x44, 0xC6,
+	0x2D, 0x20,
+	0x25, 0x20,
+	0x07, 0xC0, 0x44, 0xC6,
 
-0x17, 0x50, 0x56, 0x9F,
-0xA5, 0x37, 0x4F, 0xE9,
+	0x17, 0x50, 0x56, 0x9F,
+	0xA5, 0x37, 0x4F, 0xE9,
 
-0x06, 0xC0, 0x21, 0xC4,
-0x0F, 0x17, 0x0F, 0xAF,
+	0x06, 0xC0, 0x21, 0xC4,
+	0x0F, 0x17, 0x0F, 0xAF,
 
-0x37, 0x0F, 0x5C, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x37, 0x0F, 0x5C, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x1E, 0x62, 0x57, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x1E, 0x62, 0x57, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x3E, 0x3D, 0x5D, 0x9F,
-0x00, 0xE0,
-0x07, 0x20,
+	0x3E, 0x3D, 0x5D, 0x9F,
+	0x00, 0xE0,
+	0x07, 0x20,
 
-0x2F, 0x20,
-0x00, 0xE0,
-0xA3, 0x0F, 0x4F, 0xE9,
+	0x2F, 0x20,
+	0x00, 0xE0,
+	0xA3, 0x0F, 0x4F, 0xE9,
 
-0x06, 0x20,
-0x00, 0xE0,
-0x1F, 0x26, 0x1F, 0xDF,
+	0x06, 0x20,
+	0x00, 0xE0,
+	0x1F, 0x26, 0x1F, 0xDF,
 
-0x17, 0x26, 0x17, 0xDF,
-0xA1, 0x1F, 0x4F, 0xE9,
+	0x17, 0x26, 0x17, 0xDF,
+	0xA1, 0x1F, 0x4F, 0xE9,
 
-0x1E, 0x26, 0x1E, 0xDF,
-0x9D, 0x1E, 0x4F, 0xE9,
+	0x1E, 0x26, 0x1E, 0xDF,
+	0x9D, 0x1E, 0x4F, 0xE9,
 
-0x35, 0x17, 0x4F, 0xE9,
-0xA2, 0x3F, 0x4F, 0xE9,
+	0x35, 0x17, 0x4F, 0xE9,
+	0xA2, 0x3F, 0x4F, 0xE9,
 
-0x06, 0x06, 0x1F, 0xAF,
-0x39, 0x37, 0x4F, 0xE9,
+	0x06, 0x06, 0x1F, 0xAF,
+	0x39, 0x37, 0x4F, 0xE9,
 
-0x2F, 0x2F, 0x17, 0xAF,
-0x07, 0x07, 0x1E, 0xAF,
+	0x2F, 0x2F, 0x17, 0xAF,
+	0x07, 0x07, 0x1E, 0xAF,
 
-0xA0, 0x80, 0x4F, 0xE9,
-0x9E, 0x3E, 0x4F, 0xE9,
+	0xA0, 0x80, 0x4F, 0xE9,
+	0x9E, 0x3E, 0x4F, 0xE9,
 
-0x31, 0x80, 0x4F, 0xE9,
-0x9C, 0x80, 0x4F, 0xE9,
+	0x31, 0x80, 0x4F, 0xE9,
+	0x9C, 0x80, 0x4F, 0xE9,
 
-0x00, 0x80, 0x00, 0xE8,
-0x57, 0x39, 0x20, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+	0x57, 0x39, 0x20, 0xE9,
 
-0x16, 0x28, 0x20, 0xE9,
-0x1D, 0x3B, 0x20, 0xE9,
+	0x16, 0x28, 0x20, 0xE9,
+	0x1D, 0x3B, 0x20, 0xE9,
 
-0x1E, 0x2B, 0x20, 0xE9,
-0x2B, 0x32, 0x20, 0xE9,
+	0x1E, 0x2B, 0x20, 0xE9,
+	0x2B, 0x32, 0x20, 0xE9,
 
-0x1C, 0x23, 0x20, 0xE9,
-0x57, 0x36, 0x20, 0xE9,
+	0x1C, 0x23, 0x20, 0xE9,
+	0x57, 0x36, 0x20, 0xE9,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x40, 0x40, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x40, 0x40, 0xD8, 0xEC,
 
-0xFF, 0x80, 0xC0, 0xE9,
-0x90, 0xE2,
-0x00, 0xE0,
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x90, 0xE2,
+	0x00, 0xE0,
 
-0x63, 0xFF, 0x20, 0xEA,
-0x19, 0xC8, 0xC1, 0xCD,
+	0x63, 0xFF, 0x20, 0xEA,
+	0x19, 0xC8, 0xC1, 0xCD,
 
-0x1F, 0xD7, 0x18, 0xBD,
-0x3F, 0xD7, 0x22, 0xBD,
+	0x1F, 0xD7, 0x18, 0xBD,
+	0x3F, 0xD7, 0x22, 0xBD,
 
-0x9F, 0x41, 0x49, 0xBD,
-0x00, 0x80, 0x00, 0xE8,
+	0x9F, 0x41, 0x49, 0xBD,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x25, 0x41, 0x49, 0xBD,
-0x2D, 0x41, 0x51, 0xBD,
+	0x25, 0x41, 0x49, 0xBD,
+	0x2D, 0x41, 0x51, 0xBD,
 
-0x0D, 0x80, 0x07, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0x0D, 0x80, 0x07, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x35, 0x40, 0x48, 0xBD,
-0x3D, 0x40, 0x50, 0xBD,
+	0x35, 0x40, 0x48, 0xBD,
+	0x3D, 0x40, 0x50, 0xBD,
 
-0x00, 0x80, 0x00, 0xE8,
-0x25, 0x30,
-0x2D, 0x30,
+	0x00, 0x80, 0x00, 0xE8,
+	0x25, 0x30,
+	0x2D, 0x30,
 
-0x35, 0x30,
-0xB5, 0x30,
-0xBD, 0x30,
-0x3D, 0x30,
+	0x35, 0x30,
+	0xB5, 0x30,
+	0xBD, 0x30,
+	0x3D, 0x30,
 
-0x9C, 0xA7, 0x5B, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x9C, 0xA7, 0x5B, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x62, 0xFF, 0x0A, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0x62, 0xFF, 0x0A, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xC9, 0x41, 0xC8, 0xEC,
-0x42, 0xE1,
-0x00, 0xE0,
+	0xC9, 0x41, 0xC8, 0xEC,
+	0x42, 0xE1,
+	0x00, 0xE0,
 
-0x60, 0xFF, 0x20, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0x60, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xC8, 0x40, 0xC0, 0xEC,
-0x00, 0x80, 0x00, 0xE8,
+	0xC8, 0x40, 0xC0, 0xEC,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x5D, 0xFF, 0x20, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0x5D, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
 };
 
 static unsigned char warp_g200_tgzsf[] = {
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x98, 0xA0, 0xE9,
-0x40, 0x40, 0xD8, 0xEC,
+	0x00, 0x98, 0xA0, 0xE9,
+	0x40, 0x40, 0xD8, 0xEC,
 
-0xFF, 0x80, 0xC0, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x1F, 0xD7, 0x18, 0xBD,
-0x3F, 0xD7, 0x22, 0xBD,
+	0x1F, 0xD7, 0x18, 0xBD,
+	0x3F, 0xD7, 0x22, 0xBD,
 
-0x81, 0x04,
-0x89, 0x04,
-0x01, 0x04,
-0x09, 0x04,
+	0x81, 0x04,
+	0x89, 0x04,
+	0x01, 0x04,
+	0x09, 0x04,
 
-0xC9, 0x41, 0xC0, 0xEC,
-0x11, 0x04,
-0x00, 0xE0,
+	0xC9, 0x41, 0xC0, 0xEC,
+	0x11, 0x04,
+	0x00, 0xE0,
 
-0x41, 0xCC, 0x41, 0xCD,
-0x49, 0xCC, 0x49, 0xCD,
+	0x41, 0xCC, 0x41, 0xCD,
+	0x49, 0xCC, 0x49, 0xCD,
 
-0xD1, 0x41, 0xC0, 0xEC,
-0x51, 0xCC, 0x51, 0xCD,
+	0xD1, 0x41, 0xC0, 0xEC,
+	0x51, 0xCC, 0x51, 0xCD,
 
-0x80, 0x04,
-0x10, 0x04,
-0x08, 0x04,
-0x00, 0xE0,
+	0x80, 0x04,
+	0x10, 0x04,
+	0x08, 0x04,
+	0x00, 0xE0,
 
-0x00, 0xCC, 0xC0, 0xCD,
-0xD1, 0x49, 0xC0, 0xEC,
+	0x00, 0xCC, 0xC0, 0xCD,
+	0xD1, 0x49, 0xC0, 0xEC,
 
-0x8A, 0x1F, 0x20, 0xE9,
-0x8B, 0x3F, 0x20, 0xE9,
+	0x8A, 0x1F, 0x20, 0xE9,
+	0x8B, 0x3F, 0x20, 0xE9,
 
-0x41, 0x3C, 0x41, 0xAD,
-0x49, 0x3C, 0x49, 0xAD,
+	0x41, 0x3C, 0x41, 0xAD,
+	0x49, 0x3C, 0x49, 0xAD,
 
-0x10, 0xCC, 0x10, 0xCD,
-0x08, 0xCC, 0x08, 0xCD,
+	0x10, 0xCC, 0x10, 0xCD,
+	0x08, 0xCC, 0x08, 0xCD,
 
-0xB9, 0x41, 0x49, 0xBB,
-0x1F, 0xF0, 0x41, 0xCD,
+	0xB9, 0x41, 0x49, 0xBB,
+	0x1F, 0xF0, 0x41, 0xCD,
 
-0x51, 0x3C, 0x51, 0xAD,
-0x00, 0x98, 0x80, 0xE9,
+	0x51, 0x3C, 0x51, 0xAD,
+	0x00, 0x98, 0x80, 0xE9,
 
-0x8F, 0x80, 0x07, 0xEA,
-0x24, 0x1F, 0x20, 0xE9,
+	0x8F, 0x80, 0x07, 0xEA,
+	0x24, 0x1F, 0x20, 0xE9,
 
-0x21, 0x45, 0x80, 0xE8,
-0x1A, 0x4D, 0x80, 0xE8,
+	0x21, 0x45, 0x80, 0xE8,
+	0x1A, 0x4D, 0x80, 0xE8,
 
-0x31, 0x55, 0x80, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x31, 0x55, 0x80, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x15, 0x41, 0x49, 0xBD,
-0x1D, 0x41, 0x51, 0xBD,
+	0x15, 0x41, 0x49, 0xBD,
+	0x1D, 0x41, 0x51, 0xBD,
 
-0x2E, 0x41, 0x2A, 0xB8,
-0x34, 0x53, 0xA0, 0xE8,
+	0x2E, 0x41, 0x2A, 0xB8,
+	0x34, 0x53, 0xA0, 0xE8,
 
-0x15, 0x30,
-0x1D, 0x30,
-0x58, 0xE3,
-0x00, 0xE0,
+	0x15, 0x30,
+	0x1D, 0x30,
+	0x58, 0xE3,
+	0x00, 0xE0,
 
-0xB5, 0x40, 0x48, 0xBD,
-0x3D, 0x40, 0x50, 0xBD,
+	0xB5, 0x40, 0x48, 0xBD,
+	0x3D, 0x40, 0x50, 0xBD,
 
-0x24, 0x43, 0xA0, 0xE8,
-0x2C, 0x4B, 0xA0, 0xE8,
+	0x24, 0x43, 0xA0, 0xE8,
+	0x2C, 0x4B, 0xA0, 0xE8,
 
-0x15, 0x72,
-0x09, 0xE3,
-0x00, 0xE0,
-0x1D, 0x72,
+	0x15, 0x72,
+	0x09, 0xE3,
+	0x00, 0xE0,
+	0x1D, 0x72,
 
-0x35, 0x30,
-0xB5, 0x30,
-0xBD, 0x30,
-0x3D, 0x30,
+	0x35, 0x30,
+	0xB5, 0x30,
+	0xBD, 0x30,
+	0x3D, 0x30,
 
-0x9C, 0x97, 0x57, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x9C, 0x97, 0x57, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x6C, 0x64, 0xC8, 0xEC,
-0x98, 0xE1,
-0xB5, 0x05,
+	0x6C, 0x64, 0xC8, 0xEC,
+	0x98, 0xE1,
+	0xB5, 0x05,
 
-0xBD, 0x05,
-0x2E, 0x30,
-0x32, 0xC0, 0xA0, 0xE8,
+	0xBD, 0x05,
+	0x2E, 0x30,
+	0x32, 0xC0, 0xA0, 0xE8,
 
-0x33, 0xC0, 0xA0, 0xE8,
-0x74, 0x64, 0xC8, 0xEC,
+	0x33, 0xC0, 0xA0, 0xE8,
+	0x74, 0x64, 0xC8, 0xEC,
 
-0x40, 0x3C, 0x40, 0xAD,
-0x32, 0x6A,
-0x2A, 0x30,
+	0x40, 0x3C, 0x40, 0xAD,
+	0x32, 0x6A,
+	0x2A, 0x30,
 
-0x20, 0x73,
-0x33, 0x6A,
-0x00, 0xE0,
-0x28, 0x73,
+	0x20, 0x73,
+	0x33, 0x6A,
+	0x00, 0xE0,
+	0x28, 0x73,
 
-0x1C, 0x72,
-0x83, 0xE2,
-0x7B, 0x80, 0x15, 0xEA,
+	0x1C, 0x72,
+	0x83, 0xE2,
+	0x7B, 0x80, 0x15, 0xEA,
 
-0xB8, 0x3D, 0x28, 0xDF,
-0x30, 0x35, 0x20, 0xDF,
+	0xB8, 0x3D, 0x28, 0xDF,
+	0x30, 0x35, 0x20, 0xDF,
 
-0x40, 0x30,
-0x00, 0xE0,
-0xCC, 0xE2,
-0x64, 0x72,
+	0x40, 0x30,
+	0x00, 0xE0,
+	0xCC, 0xE2,
+	0x64, 0x72,
 
-0x25, 0x42, 0x52, 0xBF,
-0x2D, 0x42, 0x4A, 0xBF,
+	0x25, 0x42, 0x52, 0xBF,
+	0x2D, 0x42, 0x4A, 0xBF,
 
-0x30, 0x2E, 0x30, 0xDF,
-0x38, 0x2E, 0x38, 0xDF,
+	0x30, 0x2E, 0x30, 0xDF,
+	0x38, 0x2E, 0x38, 0xDF,
 
-0x18, 0x1D, 0x45, 0xE9,
-0x1E, 0x15, 0x45, 0xE9,
+	0x18, 0x1D, 0x45, 0xE9,
+	0x1E, 0x15, 0x45, 0xE9,
 
-0x2B, 0x49, 0x51, 0xBD,
-0x00, 0xE0,
-0x1F, 0x73,
+	0x2B, 0x49, 0x51, 0xBD,
+	0x00, 0xE0,
+	0x1F, 0x73,
 
-0x38, 0x38, 0x40, 0xAF,
-0x30, 0x30, 0x40, 0xAF,
+	0x38, 0x38, 0x40, 0xAF,
+	0x30, 0x30, 0x40, 0xAF,
 
-0x24, 0x1F, 0x24, 0xDF,
-0x1D, 0x32, 0x20, 0xE9,
+	0x24, 0x1F, 0x24, 0xDF,
+	0x1D, 0x32, 0x20, 0xE9,
 
-0x2C, 0x1F, 0x2C, 0xDF,
-0x1A, 0x33, 0x20, 0xE9,
+	0x2C, 0x1F, 0x2C, 0xDF,
+	0x1A, 0x33, 0x20, 0xE9,
 
-0xB0, 0x10,
-0x08, 0xE3,
-0x40, 0x10,
-0xB8, 0x10,
+	0xB0, 0x10,
+	0x08, 0xE3,
+	0x40, 0x10,
+	0xB8, 0x10,
 
-0x26, 0xF0, 0x30, 0xCD,
-0x2F, 0xF0, 0x38, 0xCD,
+	0x26, 0xF0, 0x30, 0xCD,
+	0x2F, 0xF0, 0x38, 0xCD,
 
-0x2B, 0x80, 0x20, 0xE9,
-0x2A, 0x80, 0x20, 0xE9,
+	0x2B, 0x80, 0x20, 0xE9,
+	0x2A, 0x80, 0x20, 0xE9,
 
-0xA6, 0x20,
-0x88, 0xE2,
-0x00, 0xE0,
-0xAF, 0x20,
+	0xA6, 0x20,
+	0x88, 0xE2,
+	0x00, 0xE0,
+	0xAF, 0x20,
 
-0x28, 0x2A, 0x26, 0xAF,
-0x20, 0x2A, 0xC0, 0xAF,
+	0x28, 0x2A, 0x26, 0xAF,
+	0x20, 0x2A, 0xC0, 0xAF,
 
-0x34, 0x1F, 0x34, 0xDF,
-0x46, 0x24, 0x46, 0xDF,
+	0x34, 0x1F, 0x34, 0xDF,
+	0x46, 0x24, 0x46, 0xDF,
 
-0x28, 0x30, 0x80, 0xBF,
-0x20, 0x38, 0x80, 0xBF,
+	0x28, 0x30, 0x80, 0xBF,
+	0x20, 0x38, 0x80, 0xBF,
 
-0x47, 0x24, 0x47, 0xDF,
-0x4E, 0x2C, 0x4E, 0xDF,
+	0x47, 0x24, 0x47, 0xDF,
+	0x4E, 0x2C, 0x4E, 0xDF,
 
-0x4F, 0x2C, 0x4F, 0xDF,
-0x56, 0x34, 0x56, 0xDF,
+	0x4F, 0x2C, 0x4F, 0xDF,
+	0x56, 0x34, 0x56, 0xDF,
 
-0x28, 0x15, 0x28, 0xDF,
-0x20, 0x1D, 0x20, 0xDF,
+	0x28, 0x15, 0x28, 0xDF,
+	0x20, 0x1D, 0x20, 0xDF,
 
-0x57, 0x34, 0x57, 0xDF,
-0x00, 0xE0,
-0x1D, 0x05,
+	0x57, 0x34, 0x57, 0xDF,
+	0x00, 0xE0,
+	0x1D, 0x05,
 
-0x04, 0x80, 0x10, 0xEA,
-0x89, 0xE2,
-0x2B, 0x30,
+	0x04, 0x80, 0x10, 0xEA,
+	0x89, 0xE2,
+	0x2B, 0x30,
 
-0x3F, 0xC1, 0x1D, 0xBD,
-0x00, 0x80, 0x00, 0xE8,
+	0x3F, 0xC1, 0x1D, 0xBD,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xA0, 0x68,
-0xBF, 0x25,
-0x00, 0x80, 0x00, 0xE8,
+	0xA0, 0x68,
+	0xBF, 0x25,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x20, 0xC0, 0x20, 0xAF,
-0x28, 0x05,
-0x97, 0x74,
+	0x20, 0xC0, 0x20, 0xAF,
+	0x28, 0x05,
+	0x97, 0x74,
 
-0x00, 0xE0,
-0x2A, 0x10,
-0x16, 0xC0, 0x20, 0xE9,
+	0x00, 0xE0,
+	0x2A, 0x10,
+	0x16, 0xC0, 0x20, 0xE9,
 
-0x04, 0x80, 0x10, 0xEA,
-0x8C, 0xE2,
-0x95, 0x05,
+	0x04, 0x80, 0x10, 0xEA,
+	0x8C, 0xE2,
+	0x95, 0x05,
 
-0x28, 0xC1, 0x28, 0xAD,
-0x1F, 0xC1, 0x15, 0xBD,
+	0x28, 0xC1, 0x28, 0xAD,
+	0x1F, 0xC1, 0x15, 0xBD,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xA8, 0x67,
-0x9F, 0x6B,
-0x00, 0x80, 0x00, 0xE8,
+	0xA8, 0x67,
+	0x9F, 0x6B,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x28, 0xC0, 0x28, 0xAD,
-0x1D, 0x25,
-0x20, 0x05,
+	0x28, 0xC0, 0x28, 0xAD,
+	0x1D, 0x25,
+	0x20, 0x05,
 
-0x28, 0x32, 0x80, 0xAD,
-0x40, 0x2A, 0x40, 0xBD,
+	0x28, 0x32, 0x80, 0xAD,
+	0x40, 0x2A, 0x40, 0xBD,
 
-0x1C, 0x80, 0x20, 0xE9,
-0x20, 0x33, 0x20, 0xAD,
+	0x1C, 0x80, 0x20, 0xE9,
+	0x20, 0x33, 0x20, 0xAD,
 
-0x20, 0x73,
-0x00, 0xE0,
-0xB6, 0x49, 0x51, 0xBB,
+	0x20, 0x73,
+	0x00, 0xE0,
+	0xB6, 0x49, 0x51, 0xBB,
 
-0x26, 0x2F, 0xB0, 0xE8,
-0x19, 0x20, 0x20, 0xE9,
+	0x26, 0x2F, 0xB0, 0xE8,
+	0x19, 0x20, 0x20, 0xE9,
 
-0x35, 0x20, 0x35, 0xDF,
-0x3D, 0x20, 0x3D, 0xDF,
+	0x35, 0x20, 0x35, 0xDF,
+	0x3D, 0x20, 0x3D, 0xDF,
 
-0x15, 0x20, 0x15, 0xDF,
-0x1D, 0x20, 0x1D, 0xDF,
+	0x15, 0x20, 0x15, 0xDF,
+	0x1D, 0x20, 0x1D, 0xDF,
 
-0x26, 0xD0, 0x26, 0xCD,
-0x29, 0x49, 0x2A, 0xB8,
+	0x26, 0xD0, 0x26, 0xCD,
+	0x29, 0x49, 0x2A, 0xB8,
 
-0x26, 0x40, 0x80, 0xBD,
-0x3B, 0x48, 0x50, 0xBD,
+	0x26, 0x40, 0x80, 0xBD,
+	0x3B, 0x48, 0x50, 0xBD,
 
-0x3E, 0x54, 0x57, 0x9F,
-0x00, 0xE0,
-0x82, 0xE1,
+	0x3E, 0x54, 0x57, 0x9F,
+	0x00, 0xE0,
+	0x82, 0xE1,
 
-0x1E, 0xAF, 0x59, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x1E, 0xAF, 0x59, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x26, 0x30,
-0x29, 0x30,
-0x48, 0x3C, 0x48, 0xAD,
+	0x26, 0x30,
+	0x29, 0x30,
+	0x48, 0x3C, 0x48, 0xAD,
 
-0x2B, 0x72,
-0xC2, 0xE1,
-0x2C, 0xC0, 0x44, 0xC2,
+	0x2B, 0x72,
+	0xC2, 0xE1,
+	0x2C, 0xC0, 0x44, 0xC2,
 
-0x05, 0x24, 0x34, 0xBF,
-0x0D, 0x24, 0x2C, 0xBF,
+	0x05, 0x24, 0x34, 0xBF,
+	0x0D, 0x24, 0x2C, 0xBF,
 
-0x2D, 0x46, 0x4E, 0xBF,
-0x25, 0x46, 0x56, 0xBF,
+	0x2D, 0x46, 0x4E, 0xBF,
+	0x25, 0x46, 0x56, 0xBF,
 
-0x20, 0x1D, 0x6F, 0x8F,
-0x32, 0x3E, 0x5F, 0xE9,
+	0x20, 0x1D, 0x6F, 0x8F,
+	0x32, 0x3E, 0x5F, 0xE9,
 
-0x3E, 0x50, 0x56, 0x9F,
-0x00, 0xE0,
-0x3B, 0x30,
+	0x3E, 0x50, 0x56, 0x9F,
+	0x00, 0xE0,
+	0x3B, 0x30,
 
-0x1E, 0x8F, 0x51, 0x9F,
-0x33, 0x1E, 0x5F, 0xE9,
+	0x1E, 0x8F, 0x51, 0x9F,
+	0x33, 0x1E, 0x5F, 0xE9,
 
-0x05, 0x44, 0x54, 0xB2,
-0x0D, 0x44, 0x4C, 0xB2,
+	0x05, 0x44, 0x54, 0xB2,
+	0x0D, 0x44, 0x4C, 0xB2,
 
-0x19, 0xC0, 0xB0, 0xE8,
-0x34, 0xC0, 0x44, 0xC4,
+	0x19, 0xC0, 0xB0, 0xE8,
+	0x34, 0xC0, 0x44, 0xC4,
 
-0x33, 0x73,
-0x00, 0xE0,
-0x3E, 0x62, 0x57, 0x9F,
+	0x33, 0x73,
+	0x00, 0xE0,
+	0x3E, 0x62, 0x57, 0x9F,
 
-0x1E, 0xAF, 0x59, 0x9F,
-0x00, 0xE0,
-0x0D, 0x20,
+	0x1E, 0xAF, 0x59, 0x9F,
+	0x00, 0xE0,
+	0x0D, 0x20,
 
-0x84, 0x3E, 0x58, 0xE9,
-0x28, 0x1D, 0x6F, 0x8F,
+	0x84, 0x3E, 0x58, 0xE9,
+	0x28, 0x1D, 0x6F, 0x8F,
 
-0x05, 0x20,
-0x00, 0xE0,
-0x85, 0x1E, 0x58, 0xE9,
+	0x05, 0x20,
+	0x00, 0xE0,
+	0x85, 0x1E, 0x58, 0xE9,
 
-0x9B, 0x3B, 0x33, 0xDF,
-0x20, 0x20, 0x42, 0xAF,
+	0x9B, 0x3B, 0x33, 0xDF,
+	0x20, 0x20, 0x42, 0xAF,
 
-0x30, 0x42, 0x56, 0x9F,
-0x80, 0x3E, 0x57, 0xE9,
+	0x30, 0x42, 0x56, 0x9F,
+	0x80, 0x3E, 0x57, 0xE9,
 
-0x3F, 0x8F, 0x51, 0x9F,
-0x30, 0x80, 0x5F, 0xE9,
+	0x3F, 0x8F, 0x51, 0x9F,
+	0x30, 0x80, 0x5F, 0xE9,
 
-0x28, 0x28, 0x24, 0xAF,
-0x81, 0x1E, 0x57, 0xE9,
+	0x28, 0x28, 0x24, 0xAF,
+	0x81, 0x1E, 0x57, 0xE9,
 
-0x05, 0x47, 0x57, 0xBF,
-0x0D, 0x47, 0x4F, 0xBF,
+	0x05, 0x47, 0x57, 0xBF,
+	0x0D, 0x47, 0x4F, 0xBF,
 
-0x88, 0x80, 0x58, 0xE9,
-0x1B, 0x29, 0x1B, 0xDF,
+	0x88, 0x80, 0x58, 0xE9,
+	0x1B, 0x29, 0x1B, 0xDF,
 
-0x30, 0x1D, 0x6F, 0x8F,
-0x3A, 0x30, 0x4F, 0xE9,
+	0x30, 0x1D, 0x6F, 0x8F,
+	0x3A, 0x30, 0x4F, 0xE9,
 
-0x1C, 0x30, 0x26, 0xDF,
-0x09, 0xE3,
-0x3B, 0x05,
+	0x1C, 0x30, 0x26, 0xDF,
+	0x09, 0xE3,
+	0x3B, 0x05,
 
-0x3E, 0x50, 0x56, 0x9F,
-0x3B, 0x3F, 0x4F, 0xE9,
+	0x3E, 0x50, 0x56, 0x9F,
+	0x3B, 0x3F, 0x4F, 0xE9,
 
-0x1E, 0x8F, 0x51, 0x9F,
-0x00, 0xE0,
-0xAC, 0x20,
+	0x1E, 0x8F, 0x51, 0x9F,
+	0x00, 0xE0,
+	0xAC, 0x20,
 
-0x2D, 0x44, 0x4C, 0xB4,
-0x2C, 0x1C, 0xC0, 0xAF,
+	0x2D, 0x44, 0x4C, 0xB4,
+	0x2C, 0x1C, 0xC0, 0xAF,
 
-0x25, 0x44, 0x54, 0xB4,
-0x00, 0xE0,
-0xC8, 0x30,
+	0x25, 0x44, 0x54, 0xB4,
+	0x00, 0xE0,
+	0xC8, 0x30,
 
-0x30, 0x46, 0x30, 0xAF,
-0x1B, 0x1B, 0x48, 0xAF,
+	0x30, 0x46, 0x30, 0xAF,
+	0x1B, 0x1B, 0x48, 0xAF,
 
-0x00, 0xE0,
-0x25, 0x20,
-0x38, 0x2C, 0x4F, 0xE9,
+	0x00, 0xE0,
+	0x25, 0x20,
+	0x38, 0x2C, 0x4F, 0xE9,
 
-0x86, 0x80, 0x57, 0xE9,
-0x38, 0x1D, 0x6F, 0x8F,
+	0x86, 0x80, 0x57, 0xE9,
+	0x38, 0x1D, 0x6F, 0x8F,
 
-0x28, 0x74,
-0x00, 0xE0,
-0x0D, 0x44, 0x4C, 0xB0,
+	0x28, 0x74,
+	0x00, 0xE0,
+	0x0D, 0x44, 0x4C, 0xB0,
 
-0x05, 0x44, 0x54, 0xB0,
-0x2D, 0x20,
-0x9B, 0x10,
+	0x05, 0x44, 0x54, 0xB0,
+	0x2D, 0x20,
+	0x9B, 0x10,
 
-0x82, 0x3E, 0x57, 0xE9,
-0x32, 0xF0, 0x1B, 0xCD,
+	0x82, 0x3E, 0x57, 0xE9,
+	0x32, 0xF0, 0x1B, 0xCD,
 
-0x1E, 0xBD, 0x59, 0x9F,
-0x83, 0x1E, 0x57, 0xE9,
+	0x1E, 0xBD, 0x59, 0x9F,
+	0x83, 0x1E, 0x57, 0xE9,
 
-0x38, 0x47, 0x38, 0xAF,
-0x34, 0x20,
-0x2A, 0x30,
+	0x38, 0x47, 0x38, 0xAF,
+	0x34, 0x20,
+	0x2A, 0x30,
 
-0x00, 0xE0,
-0x0D, 0x20,
-0x32, 0x20,
-0x05, 0x20,
+	0x00, 0xE0,
+	0x0D, 0x20,
+	0x32, 0x20,
+	0x05, 0x20,
 
-0x87, 0x80, 0x57, 0xE9,
-0x1F, 0x54, 0x57, 0x9F,
+	0x87, 0x80, 0x57, 0xE9,
+	0x1F, 0x54, 0x57, 0x9F,
 
-0x17, 0x42, 0x56, 0x9F,
-0x00, 0xE0,
-0x3B, 0x6A,
+	0x17, 0x42, 0x56, 0x9F,
+	0x00, 0xE0,
+	0x3B, 0x6A,
 
-0x3F, 0x8F, 0x51, 0x9F,
-0x37, 0x1E, 0x4F, 0xE9,
+	0x3F, 0x8F, 0x51, 0x9F,
+	0x37, 0x1E, 0x4F, 0xE9,
 
-0x37, 0x32, 0x2A, 0xAF,
-0x00, 0xE0,
-0x32, 0x00,
+	0x37, 0x32, 0x2A, 0xAF,
+	0x00, 0xE0,
+	0x32, 0x00,
 
-0x00, 0x80, 0x00, 0xE8,
-0x27, 0xC0, 0x44, 0xC0,
+	0x00, 0x80, 0x00, 0xE8,
+	0x27, 0xC0, 0x44, 0xC0,
 
-0x36, 0x1F, 0x4F, 0xE9,
-0x1F, 0x1F, 0x26, 0xDF,
+	0x36, 0x1F, 0x4F, 0xE9,
+	0x1F, 0x1F, 0x26, 0xDF,
 
-0x37, 0x1B, 0x37, 0xBF,
-0x17, 0x26, 0x17, 0xDF,
+	0x37, 0x1B, 0x37, 0xBF,
+	0x17, 0x26, 0x17, 0xDF,
 
-0x3E, 0x17, 0x4F, 0xE9,
-0x3F, 0x3F, 0x4F, 0xE9,
+	0x3E, 0x17, 0x4F, 0xE9,
+	0x3F, 0x3F, 0x4F, 0xE9,
 
-0x34, 0x1F, 0x34, 0xAF,
-0x2B, 0x05,
-0xA7, 0x20,
+	0x34, 0x1F, 0x34, 0xAF,
+	0x2B, 0x05,
+	0xA7, 0x20,
 
-0x33, 0x2B, 0x37, 0xDF,
-0x27, 0x17, 0xC0, 0xAF,
+	0x33, 0x2B, 0x37, 0xDF,
+	0x27, 0x17, 0xC0, 0xAF,
 
-0x34, 0x80, 0x4F, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0x34, 0x80, 0x4F, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x2D, 0x21, 0x1A, 0xB0,
-0x25, 0x21, 0x31, 0xB0,
+	0x2D, 0x21, 0x1A, 0xB0,
+	0x25, 0x21, 0x31, 0xB0,
 
-0x0D, 0x21, 0x1A, 0xB2,
-0x05, 0x21, 0x31, 0xB2,
+	0x0D, 0x21, 0x1A, 0xB2,
+	0x05, 0x21, 0x31, 0xB2,
 
-0x03, 0x80, 0x2A, 0xEA,
-0x17, 0xC1, 0x2B, 0xBD,
+	0x03, 0x80, 0x2A, 0xEA,
+	0x17, 0xC1, 0x2B, 0xBD,
 
-0x2D, 0x20,
-0x25, 0x20,
-0x05, 0x20,
-0x0D, 0x20,
+	0x2D, 0x20,
+	0x25, 0x20,
+	0x05, 0x20,
+	0x0D, 0x20,
 
-0xB3, 0x68,
-0x97, 0x25,
-0x00, 0x80, 0x00, 0xE8,
+	0xB3, 0x68,
+	0x97, 0x25,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x33, 0xC0, 0x33, 0xAF,
-0x2F, 0xC0, 0x21, 0xC0,
+	0x33, 0xC0, 0x33, 0xAF,
+	0x2F, 0xC0, 0x21, 0xC0,
 
-0x16, 0x42, 0x56, 0x9F,
-0x3C, 0x27, 0x4F, 0xE9,
+	0x16, 0x42, 0x56, 0x9F,
+	0x3C, 0x27, 0x4F, 0xE9,
 
-0x1E, 0x62, 0x57, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x1E, 0x62, 0x57, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x25, 0x21, 0x31, 0xB4,
-0x2D, 0x21, 0x1A, 0xB4,
+	0x25, 0x21, 0x31, 0xB4,
+	0x2D, 0x21, 0x1A, 0xB4,
 
-0x3F, 0x2F, 0x5D, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x3F, 0x2F, 0x5D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x33, 0x05,
-0x00, 0xE0,
-0x28, 0x19, 0x60, 0xEC,
+	0x33, 0x05,
+	0x00, 0xE0,
+	0x28, 0x19, 0x60, 0xEC,
 
-0x0D, 0x21, 0x1A, 0xB6,
-0x05, 0x21, 0x31, 0xB6,
+	0x0D, 0x21, 0x1A, 0xB6,
+	0x05, 0x21, 0x31, 0xB6,
 
-0x37, 0x0F, 0x5C, 0x9F,
-0x00, 0xE0,
-0x2F, 0x20,
+	0x37, 0x0F, 0x5C, 0x9F,
+	0x00, 0xE0,
+	0x2F, 0x20,
 
-0x23, 0x3B, 0x33, 0xAD,
-0x1E, 0x26, 0x1E, 0xDF,
+	0x23, 0x3B, 0x33, 0xAD,
+	0x1E, 0x26, 0x1E, 0xDF,
 
-0xA7, 0x1E, 0x4F, 0xE9,
-0x17, 0x26, 0x16, 0xDF,
+	0xA7, 0x1E, 0x4F, 0xE9,
+	0x17, 0x26, 0x16, 0xDF,
 
-0x2D, 0x20,
-0x00, 0xE0,
-0xA8, 0x3F, 0x4F, 0xE9,
+	0x2D, 0x20,
+	0x00, 0xE0,
+	0xA8, 0x3F, 0x4F, 0xE9,
 
-0x2F, 0x2F, 0x1E, 0xAF,
-0x25, 0x20,
-0x00, 0xE0,
+	0x2F, 0x2F, 0x1E, 0xAF,
+	0x25, 0x20,
+	0x00, 0xE0,
 
-0xA4, 0x16, 0x4F, 0xE9,
-0x0F, 0xC0, 0x21, 0xC2,
+	0xA4, 0x16, 0x4F, 0xE9,
+	0x0F, 0xC0, 0x21, 0xC2,
 
-0xA6, 0x80, 0x4F, 0xE9,
-0x1F, 0x62, 0x57, 0x9F,
+	0xA6, 0x80, 0x4F, 0xE9,
+	0x1F, 0x62, 0x57, 0x9F,
 
-0x0D, 0x20,
-0x05, 0x20,
-0x2F, 0xC0, 0x21, 0xC6,
+	0x0D, 0x20,
+	0x05, 0x20,
+	0x2F, 0xC0, 0x21, 0xC6,
 
-0x3F, 0x2F, 0x5D, 0x9F,
-0x00, 0xE0,
-0x0F, 0x20,
+	0x3F, 0x2F, 0x5D, 0x9F,
+	0x00, 0xE0,
+	0x0F, 0x20,
 
-0x17, 0x50, 0x56, 0x9F,
-0xA5, 0x37, 0x4F, 0xE9,
+	0x17, 0x50, 0x56, 0x9F,
+	0xA5, 0x37, 0x4F, 0xE9,
 
-0x06, 0xC0, 0x21, 0xC4,
-0x0F, 0x17, 0x0F, 0xAF,
+	0x06, 0xC0, 0x21, 0xC4,
+	0x0F, 0x17, 0x0F, 0xAF,
 
-0x37, 0x0F, 0x5C, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x37, 0x0F, 0x5C, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x2F, 0x20,
-0x00, 0xE0,
-0xA3, 0x80, 0x4F, 0xE9,
+	0x2F, 0x20,
+	0x00, 0xE0,
+	0xA3, 0x80, 0x4F, 0xE9,
 
-0x06, 0x20,
-0x00, 0xE0,
-0x1F, 0x26, 0x1F, 0xDF,
+	0x06, 0x20,
+	0x00, 0xE0,
+	0x1F, 0x26, 0x1F, 0xDF,
 
-0x17, 0x26, 0x17, 0xDF,
-0x35, 0x17, 0x4F, 0xE9,
+	0x17, 0x26, 0x17, 0xDF,
+	0x35, 0x17, 0x4F, 0xE9,
 
-0xA1, 0x1F, 0x4F, 0xE9,
-0xA2, 0x3F, 0x4F, 0xE9,
+	0xA1, 0x1F, 0x4F, 0xE9,
+	0xA2, 0x3F, 0x4F, 0xE9,
 
-0x06, 0x06, 0x1F, 0xAF,
-0x39, 0x37, 0x4F, 0xE9,
+	0x06, 0x06, 0x1F, 0xAF,
+	0x39, 0x37, 0x4F, 0xE9,
 
-0x2F, 0x2F, 0x17, 0xAF,
-0x00, 0x80, 0x00, 0xE8,
+	0x2F, 0x2F, 0x17, 0xAF,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xA0, 0x80, 0x4F, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0xA0, 0x80, 0x4F, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x31, 0x80, 0x4F, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0x31, 0x80, 0x4F, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x57, 0x39, 0x20, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+	0x57, 0x39, 0x20, 0xE9,
 
-0x16, 0x28, 0x20, 0xE9,
-0x1D, 0x3B, 0x20, 0xE9,
+	0x16, 0x28, 0x20, 0xE9,
+	0x1D, 0x3B, 0x20, 0xE9,
 
-0x1E, 0x2B, 0x20, 0xE9,
-0x2B, 0x32, 0x20, 0xE9,
+	0x1E, 0x2B, 0x20, 0xE9,
+	0x2B, 0x32, 0x20, 0xE9,
 
-0x1C, 0x23, 0x20, 0xE9,
-0x57, 0x36, 0x20, 0xE9,
+	0x1C, 0x23, 0x20, 0xE9,
+	0x57, 0x36, 0x20, 0xE9,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x40, 0x40, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x40, 0x40, 0xD8, 0xEC,
 
-0xFF, 0x80, 0xC0, 0xE9,
-0x90, 0xE2,
-0x00, 0xE0,
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x90, 0xE2,
+	0x00, 0xE0,
 
-0x68, 0xFF, 0x20, 0xEA,
-0x19, 0xC8, 0xC1, 0xCD,
+	0x68, 0xFF, 0x20, 0xEA,
+	0x19, 0xC8, 0xC1, 0xCD,
 
-0x1F, 0xD7, 0x18, 0xBD,
-0x3F, 0xD7, 0x22, 0xBD,
+	0x1F, 0xD7, 0x18, 0xBD,
+	0x3F, 0xD7, 0x22, 0xBD,
 
-0x9F, 0x41, 0x49, 0xBD,
-0x00, 0x80, 0x00, 0xE8,
+	0x9F, 0x41, 0x49, 0xBD,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x25, 0x41, 0x49, 0xBD,
-0x2D, 0x41, 0x51, 0xBD,
+	0x25, 0x41, 0x49, 0xBD,
+	0x2D, 0x41, 0x51, 0xBD,
 
-0x0D, 0x80, 0x07, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0x0D, 0x80, 0x07, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x35, 0x40, 0x48, 0xBD,
-0x3D, 0x40, 0x50, 0xBD,
+	0x35, 0x40, 0x48, 0xBD,
+	0x3D, 0x40, 0x50, 0xBD,
 
-0x00, 0x80, 0x00, 0xE8,
-0x25, 0x30,
-0x2D, 0x30,
+	0x00, 0x80, 0x00, 0xE8,
+	0x25, 0x30,
+	0x2D, 0x30,
 
-0x35, 0x30,
-0xB5, 0x30,
-0xBD, 0x30,
-0x3D, 0x30,
+	0x35, 0x30,
+	0xB5, 0x30,
+	0xBD, 0x30,
+	0x3D, 0x30,
 
-0x9C, 0xA7, 0x5B, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x9C, 0xA7, 0x5B, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x67, 0xFF, 0x0A, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0x67, 0xFF, 0x0A, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xC9, 0x41, 0xC8, 0xEC,
-0x42, 0xE1,
-0x00, 0xE0,
+	0xC9, 0x41, 0xC8, 0xEC,
+	0x42, 0xE1,
+	0x00, 0xE0,
 
-0x65, 0xFF, 0x20, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0x65, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xC8, 0x40, 0xC0, 0xEC,
-0x00, 0x80, 0x00, 0xE8,
+	0xC8, 0x40, 0xC0, 0xEC,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x62, 0xFF, 0x20, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0x62, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
 };
 
 static unsigned char warp_g400_t2gz[] = {
 
-0x00, 0x8A, 0x98, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x8A, 0x98, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x00, 0x00, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
 
-0xFF, 0x80, 0xC0, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x0A, 0x40, 0x50, 0xBF,
-0x2A, 0x40, 0x60, 0xBF,
+	0x0A, 0x40, 0x50, 0xBF,
+	0x2A, 0x40, 0x60, 0xBF,
 
-0x32, 0x41, 0x51, 0xBF,
-0x3A, 0x41, 0x61, 0xBF,
+	0x32, 0x41, 0x51, 0xBF,
+	0x3A, 0x41, 0x61, 0xBF,
 
-0xC3, 0x6B,
-0xD3, 0x6B,
-0x00, 0x8A, 0x98, 0xE9,
+	0xC3, 0x6B,
+	0xD3, 0x6B,
+	0x00, 0x8A, 0x98, 0xE9,
 
-0x73, 0x7B, 0xC8, 0xEC,
-0x96, 0xE2,
-0x41, 0x04,
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x96, 0xE2,
+	0x41, 0x04,
 
-0x7B, 0x43, 0xA0, 0xE8,
-0x73, 0x53, 0xA0, 0xE8,
+	0x7B, 0x43, 0xA0, 0xE8,
+	0x73, 0x53, 0xA0, 0xE8,
 
-0xAD, 0xEE, 0x23, 0x9F,
-0x00, 0xE0,
-0x51, 0x04,
+	0xAD, 0xEE, 0x23, 0x9F,
+	0x00, 0xE0,
+	0x51, 0x04,
 
-0x90, 0xE2,
-0x61, 0x04,
-0x31, 0x46, 0xB1, 0xE8,
+	0x90, 0xE2,
+	0x61, 0x04,
+	0x31, 0x46, 0xB1, 0xE8,
 
-0x51, 0x41, 0xE0, 0xEC,
-0x39, 0x67, 0xB1, 0xE8,
+	0x51, 0x41, 0xE0, 0xEC,
+	0x39, 0x67, 0xB1, 0xE8,
 
-0x00, 0x04,
-0x46, 0xE2,
-0x73, 0x63, 0xA0, 0xE8,
+	0x00, 0x04,
+	0x46, 0xE2,
+	0x73, 0x63, 0xA0, 0xE8,
 
-0x61, 0x41, 0xE0, 0xEC,
-0x31, 0x00,
-0x39, 0x00,
+	0x61, 0x41, 0xE0, 0xEC,
+	0x31, 0x00,
+	0x39, 0x00,
 
-0x78, 0x80, 0x15, 0xEA,
-0x10, 0x04,
-0x20, 0x04,
+	0x78, 0x80, 0x15, 0xEA,
+	0x10, 0x04,
+	0x20, 0x04,
 
-0x61, 0x51, 0xE0, 0xEC,
-0x2F, 0x41, 0x60, 0xEA,
+	0x61, 0x51, 0xE0, 0xEC,
+	0x2F, 0x41, 0x60, 0xEA,
 
-0x31, 0x20,
-0x39, 0x20,
-0x1F, 0x42, 0xA0, 0xE8,
+	0x31, 0x20,
+	0x39, 0x20,
+	0x1F, 0x42, 0xA0, 0xE8,
 
-0x2A, 0x42, 0x52, 0xBF,
-0x0F, 0x52, 0xA0, 0xE8,
+	0x2A, 0x42, 0x52, 0xBF,
+	0x0F, 0x52, 0xA0, 0xE8,
 
-0x1A, 0x42, 0x62, 0xBF,
-0x1E, 0x51, 0x60, 0xEA,
+	0x1A, 0x42, 0x62, 0xBF,
+	0x1E, 0x51, 0x60, 0xEA,
 
-0x73, 0x7B, 0xC8, 0xEC,
-0x0E, 0x61, 0x60, 0xEA,
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x0E, 0x61, 0x60, 0xEA,
 
-0x32, 0x40, 0x50, 0xBD,
-0x22, 0x40, 0x60, 0xBD,
+	0x32, 0x40, 0x50, 0xBD,
+	0x22, 0x40, 0x60, 0xBD,
 
-0x12, 0x41, 0x51, 0xBD,
-0x3A, 0x41, 0x61, 0xBD,
+	0x12, 0x41, 0x51, 0xBD,
+	0x3A, 0x41, 0x61, 0xBD,
 
-0xBF, 0x2F, 0x0E, 0xBD,
-0x97, 0xE2,
-0x7B, 0x72,
+	0xBF, 0x2F, 0x0E, 0xBD,
+	0x97, 0xE2,
+	0x7B, 0x72,
 
-0x32, 0x20,
-0x22, 0x20,
-0x12, 0x20,
-0x3A, 0x20,
+	0x32, 0x20,
+	0x22, 0x20,
+	0x12, 0x20,
+	0x3A, 0x20,
 
-0x35, 0x48, 0xB1, 0xE8,
-0x3D, 0x59, 0xB1, 0xE8,
+	0x35, 0x48, 0xB1, 0xE8,
+	0x3D, 0x59, 0xB1, 0xE8,
 
-0x46, 0x31, 0x46, 0xBF,
-0x56, 0x31, 0x56, 0xBF,
+	0x46, 0x31, 0x46, 0xBF,
+	0x56, 0x31, 0x56, 0xBF,
 
-0xB3, 0xE2, 0x2D, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0xB3, 0xE2, 0x2D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x66, 0x31, 0x66, 0xBF,
-0x47, 0x39, 0x47, 0xBF,
+	0x66, 0x31, 0x66, 0xBF,
+	0x47, 0x39, 0x47, 0xBF,
 
-0x57, 0x39, 0x57, 0xBF,
-0x67, 0x39, 0x67, 0xBF,
+	0x57, 0x39, 0x57, 0xBF,
+	0x67, 0x39, 0x67, 0xBF,
 
-0x69, 0x80, 0x07, 0xEA,
-0x24, 0x41, 0x20, 0xE9,
+	0x69, 0x80, 0x07, 0xEA,
+	0x24, 0x41, 0x20, 0xE9,
 
-0x35, 0x00,
-0x3D, 0x00,
-0x00, 0xE0,
-0x2D, 0x73,
+	0x35, 0x00,
+	0x3D, 0x00,
+	0x00, 0xE0,
+	0x2D, 0x73,
 
-0x33, 0x72,
-0x0C, 0xE3,
-0x8D, 0x2F, 0x1E, 0xBD,
+	0x33, 0x72,
+	0x0C, 0xE3,
+	0x8D, 0x2F, 0x1E, 0xBD,
 
-0x43, 0x75, 0xF8, 0xEC,
-0x35, 0x20,
-0x3D, 0x20,
+	0x43, 0x75, 0xF8, 0xEC,
+	0x35, 0x20,
+	0x3D, 0x20,
 
-0x43, 0x43, 0x2D, 0xDF,
-0x53, 0x53, 0x2D, 0xDF,
+	0x43, 0x43, 0x2D, 0xDF,
+	0x53, 0x53, 0x2D, 0xDF,
 
-0xAE, 0x1E, 0x0E, 0xBD,
-0x58, 0xE3,
-0x33, 0x66,
+	0xAE, 0x1E, 0x0E, 0xBD,
+	0x58, 0xE3,
+	0x33, 0x66,
 
-0x48, 0x35, 0x48, 0xBF,
-0x58, 0x35, 0x58, 0xBF,
+	0x48, 0x35, 0x48, 0xBF,
+	0x58, 0x35, 0x58, 0xBF,
 
-0x68, 0x35, 0x68, 0xBF,
-0x49, 0x3D, 0x49, 0xBF,
+	0x68, 0x35, 0x68, 0xBF,
+	0x49, 0x3D, 0x49, 0xBF,
 
-0x59, 0x3D, 0x59, 0xBF,
-0x69, 0x3D, 0x69, 0xBF,
+	0x59, 0x3D, 0x59, 0xBF,
+	0x69, 0x3D, 0x69, 0xBF,
 
-0x63, 0x63, 0x2D, 0xDF,
-0x4D, 0x7D, 0xF8, 0xEC,
+	0x63, 0x63, 0x2D, 0xDF,
+	0x4D, 0x7D, 0xF8, 0xEC,
 
-0x59, 0xE3,
-0x00, 0xE0,
-0xB8, 0x38, 0x33, 0xBF,
+	0x59, 0xE3,
+	0x00, 0xE0,
+	0xB8, 0x38, 0x33, 0xBF,
 
-0x2D, 0x73,
-0x30, 0x76,
-0x18, 0x3A, 0x41, 0xE9,
+	0x2D, 0x73,
+	0x30, 0x76,
+	0x18, 0x3A, 0x41, 0xE9,
 
-0x3F, 0x53, 0xA0, 0xE8,
-0x05, 0x80, 0x3D, 0xEA,
+	0x3F, 0x53, 0xA0, 0xE8,
+	0x05, 0x80, 0x3D, 0xEA,
 
-0x37, 0x43, 0xA0, 0xE8,
-0x3D, 0x63, 0xA0, 0xE8,
+	0x37, 0x43, 0xA0, 0xE8,
+	0x3D, 0x63, 0xA0, 0xE8,
 
-0x50, 0x70, 0xF8, 0xEC,
-0x2B, 0x50, 0x3C, 0xE9,
+	0x50, 0x70, 0xF8, 0xEC,
+	0x2B, 0x50, 0x3C, 0xE9,
 
-0x1F, 0x0F, 0xBC, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x1F, 0x0F, 0xBC, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x59, 0x78, 0xF8, 0xEC,
-0x00, 0x80, 0x00, 0xE8,
+	0x59, 0x78, 0xF8, 0xEC,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x15, 0xC0, 0x20, 0xE9,
-0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
 
-0x15, 0xC0, 0x20, 0xE9,
-0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
 
-0x1E, 0x12, 0x41, 0xE9,
-0x1A, 0x22, 0x41, 0xE9,
+	0x1E, 0x12, 0x41, 0xE9,
+	0x1A, 0x22, 0x41, 0xE9,
 
-0x46, 0x37, 0x46, 0xDF,
-0x56, 0x3F, 0x56, 0xDF,
+	0x46, 0x37, 0x46, 0xDF,
+	0x56, 0x3F, 0x56, 0xDF,
 
-0x2B, 0x40, 0x3D, 0xE9,
-0x66, 0x3D, 0x66, 0xDF,
+	0x2B, 0x40, 0x3D, 0xE9,
+	0x66, 0x3D, 0x66, 0xDF,
 
-0x1D, 0x32, 0x41, 0xE9,
-0x67, 0x3D, 0x67, 0xDF,
+	0x1D, 0x32, 0x41, 0xE9,
+	0x67, 0x3D, 0x67, 0xDF,
 
-0x47, 0x37, 0x47, 0xDF,
-0x57, 0x3F, 0x57, 0xDF,
+	0x47, 0x37, 0x47, 0xDF,
+	0x57, 0x3F, 0x57, 0xDF,
 
-0x2A, 0x40, 0x20, 0xE9,
-0x59, 0x3F, 0x59, 0xDF,
+	0x2A, 0x40, 0x20, 0xE9,
+	0x59, 0x3F, 0x59, 0xDF,
 
-0x16, 0x30, 0x20, 0xE9,
-0x69, 0x3D, 0x69, 0xDF,
+	0x16, 0x30, 0x20, 0xE9,
+	0x69, 0x3D, 0x69, 0xDF,
 
-0x48, 0x37, 0x48, 0xDF,
-0x58, 0x3F, 0x58, 0xDF,
+	0x48, 0x37, 0x48, 0xDF,
+	0x58, 0x3F, 0x58, 0xDF,
 
-0x12, 0x12, 0x2D, 0xDF,
-0x22, 0x22, 0x2D, 0xDF,
+	0x12, 0x12, 0x2D, 0xDF,
+	0x22, 0x22, 0x2D, 0xDF,
 
-0x32, 0x32, 0x2D, 0xDF,
-0x3A, 0x3A, 0x2D, 0xDF,
+	0x32, 0x32, 0x2D, 0xDF,
+	0x3A, 0x3A, 0x2D, 0xDF,
 
-0x68, 0x3D, 0x68, 0xDF,
-0x49, 0x37, 0x49, 0xDF,
+	0x68, 0x3D, 0x68, 0xDF,
+	0x49, 0x37, 0x49, 0xDF,
 
-0x3D, 0xCF, 0x74, 0xC0,
-0x37, 0xCF, 0x74, 0xC4,
+	0x3D, 0xCF, 0x74, 0xC0,
+	0x37, 0xCF, 0x74, 0xC4,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x34, 0x80, 0x20, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x34, 0x80, 0x20, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x3C, 0x3D, 0x20, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3C, 0x3D, 0x20, 0xE9,
 
-0x0A, 0x44, 0x54, 0xB0,
-0x02, 0x44, 0x64, 0xB0,
+	0x0A, 0x44, 0x54, 0xB0,
+	0x02, 0x44, 0x64, 0xB0,
 
-0x2A, 0x44, 0x54, 0xB2,
-0x1A, 0x44, 0x64, 0xB2,
+	0x2A, 0x44, 0x54, 0xB2,
+	0x1A, 0x44, 0x64, 0xB2,
 
-0x25, 0x80, 0x3A, 0xEA,
-0x0A, 0x20,
-0x02, 0x20,
+	0x25, 0x80, 0x3A, 0xEA,
+	0x0A, 0x20,
+	0x02, 0x20,
 
-0x3D, 0xCF, 0x74, 0xC2,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x3D, 0xCF, 0x74, 0xC2,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x32, 0x31, 0x5F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x32, 0x31, 0x5F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x33, 0x39, 0x5F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x33, 0x39, 0x5F, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x2A, 0x44, 0x54, 0xB4,
-0x1A, 0x44, 0x64, 0xB4,
+	0x2A, 0x44, 0x54, 0xB4,
+	0x1A, 0x44, 0x64, 0xB4,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x38, 0x3D, 0x20, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x38, 0x3D, 0x20, 0xE9,
 
-0x88, 0x73, 0x5E, 0xE9,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x88, 0x73, 0x5E, 0xE9,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0x2A, 0x46, 0x56, 0xBF,
-0x1A, 0x46, 0x66, 0xBF,
+	0x2A, 0x46, 0x56, 0xBF,
+	0x1A, 0x46, 0x66, 0xBF,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x3E, 0x30, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x3E, 0x30, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x3F, 0x38, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3F, 0x38, 0x4F, 0xE9,
 
-0x0A, 0x47, 0x57, 0xBF,
-0x02, 0x47, 0x67, 0xBF,
+	0x0A, 0x47, 0x57, 0xBF,
+	0x02, 0x47, 0x67, 0xBF,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x3A, 0x31, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x3A, 0x31, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x3B, 0x39, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3B, 0x39, 0x4F, 0xE9,
 
-0x2A, 0x43, 0x53, 0xBF,
-0x1A, 0x43, 0x63, 0xBF,
+	0x2A, 0x43, 0x53, 0xBF,
+	0x1A, 0x43, 0x63, 0xBF,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x36, 0x31, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x36, 0x31, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x37, 0x39, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x37, 0x39, 0x4F, 0xE9,
 
-0x0A, 0x48, 0x58, 0xBF,
-0x02, 0x48, 0x68, 0xBF,
+	0x0A, 0x48, 0x58, 0xBF,
+	0x02, 0x48, 0x68, 0xBF,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x80, 0x31, 0x57, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x80, 0x31, 0x57, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x81, 0x39, 0x57, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x81, 0x39, 0x57, 0xE9,
 
-0x2A, 0x49, 0x59, 0xBF,
-0x1A, 0x49, 0x69, 0xBF,
+	0x2A, 0x49, 0x59, 0xBF,
+	0x1A, 0x49, 0x69, 0xBF,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x82, 0x30, 0x57, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x82, 0x30, 0x57, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x83, 0x38, 0x57, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x83, 0x38, 0x57, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x84, 0x31, 0x5E, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x84, 0x31, 0x5E, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x85, 0x39, 0x5E, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x85, 0x39, 0x5E, 0xE9,
 
-0x86, 0x76, 0x57, 0xE9,
-0x8A, 0x36, 0x20, 0xE9,
+	0x86, 0x76, 0x57, 0xE9,
+	0x8A, 0x36, 0x20, 0xE9,
 
-0x87, 0x77, 0x57, 0xE9,
-0x8B, 0x3E, 0xBF, 0xEA,
+	0x87, 0x77, 0x57, 0xE9,
+	0x8B, 0x3E, 0xBF, 0xEA,
 
-0x80, 0x30, 0x57, 0xE9,
-0x81, 0x38, 0x57, 0xE9,
+	0x80, 0x30, 0x57, 0xE9,
+	0x81, 0x38, 0x57, 0xE9,
 
-0x82, 0x31, 0x57, 0xE9,
-0x86, 0x78, 0x57, 0xE9,
+	0x82, 0x31, 0x57, 0xE9,
+	0x86, 0x78, 0x57, 0xE9,
 
-0x83, 0x39, 0x57, 0xE9,
-0x87, 0x79, 0x57, 0xE9,
+	0x83, 0x39, 0x57, 0xE9,
+	0x87, 0x79, 0x57, 0xE9,
 
-0x30, 0x1F, 0x5F, 0xE9,
-0x8A, 0x34, 0x20, 0xE9,
+	0x30, 0x1F, 0x5F, 0xE9,
+	0x8A, 0x34, 0x20, 0xE9,
 
-0x8B, 0x3C, 0x20, 0xE9,
-0x37, 0x50, 0x60, 0xBD,
+	0x8B, 0x3C, 0x20, 0xE9,
+	0x37, 0x50, 0x60, 0xBD,
 
-0x57, 0x0D, 0x20, 0xE9,
-0x35, 0x51, 0x61, 0xBD,
+	0x57, 0x0D, 0x20, 0xE9,
+	0x35, 0x51, 0x61, 0xBD,
 
-0x2B, 0x50, 0x20, 0xE9,
-0x1D, 0x37, 0xE1, 0xEA,
+	0x2B, 0x50, 0x20, 0xE9,
+	0x1D, 0x37, 0xE1, 0xEA,
 
-0x1E, 0x35, 0xE1, 0xEA,
-0x00, 0xE0,
-0x0E, 0x77,
+	0x1E, 0x35, 0xE1, 0xEA,
+	0x00, 0xE0,
+	0x0E, 0x77,
 
-0x24, 0x51, 0x20, 0xE9,
-0x9F, 0xFF, 0x20, 0xEA,
+	0x24, 0x51, 0x20, 0xE9,
+	0x9F, 0xFF, 0x20, 0xEA,
 
-0x16, 0x0E, 0x20, 0xE9,
-0x57, 0x2E, 0xBF, 0xEA,
+	0x16, 0x0E, 0x20, 0xE9,
+	0x57, 0x2E, 0xBF, 0xEA,
 
-0x0B, 0x46, 0xA0, 0xE8,
-0x1B, 0x56, 0xA0, 0xE8,
+	0x0B, 0x46, 0xA0, 0xE8,
+	0x1B, 0x56, 0xA0, 0xE8,
 
-0x2B, 0x66, 0xA0, 0xE8,
-0x0C, 0x47, 0xA0, 0xE8,
+	0x2B, 0x66, 0xA0, 0xE8,
+	0x0C, 0x47, 0xA0, 0xE8,
 
-0x1C, 0x57, 0xA0, 0xE8,
-0x2C, 0x67, 0xA0, 0xE8,
+	0x1C, 0x57, 0xA0, 0xE8,
+	0x2C, 0x67, 0xA0, 0xE8,
 
-0x0B, 0x00,
-0x1B, 0x00,
-0x2B, 0x00,
-0x00, 0xE0,
+	0x0B, 0x00,
+	0x1B, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
 
-0x0C, 0x00,
-0x1C, 0x00,
-0x2C, 0x00,
-0x00, 0xE0,
+	0x0C, 0x00,
+	0x1C, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
 
-0x0B, 0x65,
-0x1B, 0x65,
-0x2B, 0x65,
-0x00, 0xE0,
+	0x0B, 0x65,
+	0x1B, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
 
-0x0C, 0x65,
-0x1C, 0x65,
-0x2C, 0x65,
-0x00, 0xE0,
+	0x0C, 0x65,
+	0x1C, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
 
-0x0B, 0x1B, 0x60, 0xEC,
-0x36, 0xD7, 0x36, 0xAD,
+	0x0B, 0x1B, 0x60, 0xEC,
+	0x36, 0xD7, 0x36, 0xAD,
 
-0x2B, 0x80, 0x60, 0xEC,
-0x0C, 0x1C, 0x60, 0xEC,
+	0x2B, 0x80, 0x60, 0xEC,
+	0x0C, 0x1C, 0x60, 0xEC,
 
-0x3E, 0xD7, 0x3E, 0xAD,
-0x2C, 0x80, 0x60, 0xEC,
+	0x3E, 0xD7, 0x3E, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
 
-0x0B, 0x2B, 0xDE, 0xE8,
-0x1B, 0x80, 0xDE, 0xE8,
+	0x0B, 0x2B, 0xDE, 0xE8,
+	0x1B, 0x80, 0xDE, 0xE8,
 
-0x36, 0x80, 0x36, 0xBD,
-0x3E, 0x80, 0x3E, 0xBD,
+	0x36, 0x80, 0x36, 0xBD,
+	0x3E, 0x80, 0x3E, 0xBD,
 
-0x33, 0xD7, 0x0B, 0xBD,
-0x3B, 0xD7, 0x1B, 0xBD,
+	0x33, 0xD7, 0x0B, 0xBD,
+	0x3B, 0xD7, 0x1B, 0xBD,
 
-0x46, 0x80, 0x46, 0xCF,
-0x57, 0x80, 0x57, 0xCF,
+	0x46, 0x80, 0x46, 0xCF,
+	0x57, 0x80, 0x57, 0xCF,
 
-0x66, 0x33, 0x66, 0xCF,
-0x47, 0x3B, 0x47, 0xCF,
+	0x66, 0x33, 0x66, 0xCF,
+	0x47, 0x3B, 0x47, 0xCF,
 
-0x56, 0x33, 0x56, 0xCF,
-0x67, 0x3B, 0x67, 0xCF,
+	0x56, 0x33, 0x56, 0xCF,
+	0x67, 0x3B, 0x67, 0xCF,
 
-0x0B, 0x48, 0xA0, 0xE8,
-0x1B, 0x58, 0xA0, 0xE8,
+	0x0B, 0x48, 0xA0, 0xE8,
+	0x1B, 0x58, 0xA0, 0xE8,
 
-0x2B, 0x68, 0xA0, 0xE8,
-0x0C, 0x49, 0xA0, 0xE8,
+	0x2B, 0x68, 0xA0, 0xE8,
+	0x0C, 0x49, 0xA0, 0xE8,
 
-0x1C, 0x59, 0xA0, 0xE8,
-0x2C, 0x69, 0xA0, 0xE8,
+	0x1C, 0x59, 0xA0, 0xE8,
+	0x2C, 0x69, 0xA0, 0xE8,
 
-0x0B, 0x00,
-0x1B, 0x00,
-0x2B, 0x00,
-0x00, 0xE0,
+	0x0B, 0x00,
+	0x1B, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
 
-0x0C, 0x00,
-0x1C, 0x00,
-0x2C, 0x00,
-0x00, 0xE0,
+	0x0C, 0x00,
+	0x1C, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
 
-0x0B, 0x65,
-0x1B, 0x65,
-0x2B, 0x65,
-0x00, 0xE0,
+	0x0B, 0x65,
+	0x1B, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
 
-0x0C, 0x65,
-0x1C, 0x65,
-0x2C, 0x65,
-0x00, 0xE0,
+	0x0C, 0x65,
+	0x1C, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
 
-0x0B, 0x1B, 0x60, 0xEC,
-0x34, 0xD7, 0x34, 0xAD,
+	0x0B, 0x1B, 0x60, 0xEC,
+	0x34, 0xD7, 0x34, 0xAD,
 
-0x2B, 0x80, 0x60, 0xEC,
-0x0C, 0x1C, 0x60, 0xEC,
+	0x2B, 0x80, 0x60, 0xEC,
+	0x0C, 0x1C, 0x60, 0xEC,
 
-0x3C, 0xD7, 0x3C, 0xAD,
-0x2C, 0x80, 0x60, 0xEC,
+	0x3C, 0xD7, 0x3C, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
 
-0x0B, 0x2B, 0xDE, 0xE8,
-0x1B, 0x80, 0xDE, 0xE8,
+	0x0B, 0x2B, 0xDE, 0xE8,
+	0x1B, 0x80, 0xDE, 0xE8,
 
-0x34, 0x80, 0x34, 0xBD,
-0x3C, 0x80, 0x3C, 0xBD,
+	0x34, 0x80, 0x34, 0xBD,
+	0x3C, 0x80, 0x3C, 0xBD,
 
-0x33, 0xD7, 0x0B, 0xBD,
-0x3B, 0xD7, 0x1B, 0xBD,
+	0x33, 0xD7, 0x0B, 0xBD,
+	0x3B, 0xD7, 0x1B, 0xBD,
 
-0x48, 0x80, 0x48, 0xCF,
-0x59, 0x80, 0x59, 0xCF,
+	0x48, 0x80, 0x48, 0xCF,
+	0x59, 0x80, 0x59, 0xCF,
 
-0x68, 0x33, 0x68, 0xCF,
-0x49, 0x3B, 0x49, 0xCF,
+	0x68, 0x33, 0x68, 0xCF,
+	0x49, 0x3B, 0x49, 0xCF,
 
-0xBE, 0xFF, 0x20, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0xBE, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x58, 0x33, 0x58, 0xCF,
-0x69, 0x3B, 0x69, 0xCF,
+	0x58, 0x33, 0x58, 0xCF,
+	0x69, 0x3B, 0x69, 0xCF,
 
-0x7D, 0xFF, 0x20, 0xEA,
-0x57, 0xC0, 0xBF, 0xEA,
+	0x7D, 0xFF, 0x20, 0xEA,
+	0x57, 0xC0, 0xBF, 0xEA,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x00, 0x00, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
 
 };
 
 static unsigned char warp_g400_t2gza[] = {
 
-0x00, 0x8A, 0x98, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x8A, 0x98, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x00, 0x00, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
 
-0xFF, 0x80, 0xC0, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x0A, 0x40, 0x50, 0xBF,
-0x2A, 0x40, 0x60, 0xBF,
+	0x0A, 0x40, 0x50, 0xBF,
+	0x2A, 0x40, 0x60, 0xBF,
 
-0x32, 0x41, 0x51, 0xBF,
-0x3A, 0x41, 0x61, 0xBF,
+	0x32, 0x41, 0x51, 0xBF,
+	0x3A, 0x41, 0x61, 0xBF,
 
-0xC3, 0x6B,
-0xD3, 0x6B,
-0x00, 0x8A, 0x98, 0xE9,
+	0xC3, 0x6B,
+	0xD3, 0x6B,
+	0x00, 0x8A, 0x98, 0xE9,
 
-0x73, 0x7B, 0xC8, 0xEC,
-0x96, 0xE2,
-0x41, 0x04,
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x96, 0xE2,
+	0x41, 0x04,
 
-0x7B, 0x43, 0xA0, 0xE8,
-0x73, 0x53, 0xA0, 0xE8,
+	0x7B, 0x43, 0xA0, 0xE8,
+	0x73, 0x53, 0xA0, 0xE8,
 
-0xAD, 0xEE, 0x23, 0x9F,
-0x00, 0xE0,
-0x51, 0x04,
+	0xAD, 0xEE, 0x23, 0x9F,
+	0x00, 0xE0,
+	0x51, 0x04,
 
-0x90, 0xE2,
-0x61, 0x04,
-0x31, 0x46, 0xB1, 0xE8,
+	0x90, 0xE2,
+	0x61, 0x04,
+	0x31, 0x46, 0xB1, 0xE8,
 
-0x51, 0x41, 0xE0, 0xEC,
-0x39, 0x67, 0xB1, 0xE8,
+	0x51, 0x41, 0xE0, 0xEC,
+	0x39, 0x67, 0xB1, 0xE8,
 
-0x00, 0x04,
-0x46, 0xE2,
-0x73, 0x63, 0xA0, 0xE8,
+	0x00, 0x04,
+	0x46, 0xE2,
+	0x73, 0x63, 0xA0, 0xE8,
 
-0x61, 0x41, 0xE0, 0xEC,
-0x31, 0x00,
-0x39, 0x00,
+	0x61, 0x41, 0xE0, 0xEC,
+	0x31, 0x00,
+	0x39, 0x00,
 
-0x7C, 0x80, 0x15, 0xEA,
-0x10, 0x04,
-0x20, 0x04,
+	0x7C, 0x80, 0x15, 0xEA,
+	0x10, 0x04,
+	0x20, 0x04,
 
-0x61, 0x51, 0xE0, 0xEC,
-0x2F, 0x41, 0x60, 0xEA,
+	0x61, 0x51, 0xE0, 0xEC,
+	0x2F, 0x41, 0x60, 0xEA,
 
-0x31, 0x20,
-0x39, 0x20,
-0x1F, 0x42, 0xA0, 0xE8,
+	0x31, 0x20,
+	0x39, 0x20,
+	0x1F, 0x42, 0xA0, 0xE8,
 
-0x2A, 0x42, 0x52, 0xBF,
-0x0F, 0x52, 0xA0, 0xE8,
+	0x2A, 0x42, 0x52, 0xBF,
+	0x0F, 0x52, 0xA0, 0xE8,
 
-0x1A, 0x42, 0x62, 0xBF,
-0x1E, 0x51, 0x60, 0xEA,
+	0x1A, 0x42, 0x62, 0xBF,
+	0x1E, 0x51, 0x60, 0xEA,
 
-0x73, 0x7B, 0xC8, 0xEC,
-0x0E, 0x61, 0x60, 0xEA,
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x0E, 0x61, 0x60, 0xEA,
 
-0x32, 0x40, 0x50, 0xBD,
-0x22, 0x40, 0x60, 0xBD,
+	0x32, 0x40, 0x50, 0xBD,
+	0x22, 0x40, 0x60, 0xBD,
 
-0x12, 0x41, 0x51, 0xBD,
-0x3A, 0x41, 0x61, 0xBD,
+	0x12, 0x41, 0x51, 0xBD,
+	0x3A, 0x41, 0x61, 0xBD,
 
-0xBF, 0x2F, 0x0E, 0xBD,
-0x97, 0xE2,
-0x7B, 0x72,
+	0xBF, 0x2F, 0x0E, 0xBD,
+	0x97, 0xE2,
+	0x7B, 0x72,
 
-0x32, 0x20,
-0x22, 0x20,
-0x12, 0x20,
-0x3A, 0x20,
+	0x32, 0x20,
+	0x22, 0x20,
+	0x12, 0x20,
+	0x3A, 0x20,
 
-0x35, 0x48, 0xB1, 0xE8,
-0x3D, 0x59, 0xB1, 0xE8,
+	0x35, 0x48, 0xB1, 0xE8,
+	0x3D, 0x59, 0xB1, 0xE8,
 
-0x46, 0x31, 0x46, 0xBF,
-0x56, 0x31, 0x56, 0xBF,
+	0x46, 0x31, 0x46, 0xBF,
+	0x56, 0x31, 0x56, 0xBF,
 
-0xB3, 0xE2, 0x2D, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0xB3, 0xE2, 0x2D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x66, 0x31, 0x66, 0xBF,
-0x47, 0x39, 0x47, 0xBF,
+	0x66, 0x31, 0x66, 0xBF,
+	0x47, 0x39, 0x47, 0xBF,
 
-0x57, 0x39, 0x57, 0xBF,
-0x67, 0x39, 0x67, 0xBF,
+	0x57, 0x39, 0x57, 0xBF,
+	0x67, 0x39, 0x67, 0xBF,
 
-0x6D, 0x80, 0x07, 0xEA,
-0x24, 0x41, 0x20, 0xE9,
+	0x6D, 0x80, 0x07, 0xEA,
+	0x24, 0x41, 0x20, 0xE9,
 
-0x35, 0x00,
-0x3D, 0x00,
-0x00, 0xE0,
-0x2D, 0x73,
+	0x35, 0x00,
+	0x3D, 0x00,
+	0x00, 0xE0,
+	0x2D, 0x73,
 
-0x33, 0x72,
-0x0C, 0xE3,
-0x8D, 0x2F, 0x1E, 0xBD,
+	0x33, 0x72,
+	0x0C, 0xE3,
+	0x8D, 0x2F, 0x1E, 0xBD,
 
-0x43, 0x75, 0xF8, 0xEC,
-0x35, 0x20,
-0x3D, 0x20,
+	0x43, 0x75, 0xF8, 0xEC,
+	0x35, 0x20,
+	0x3D, 0x20,
 
-0x43, 0x43, 0x2D, 0xDF,
-0x53, 0x53, 0x2D, 0xDF,
+	0x43, 0x43, 0x2D, 0xDF,
+	0x53, 0x53, 0x2D, 0xDF,
 
-0xAE, 0x1E, 0x0E, 0xBD,
-0x58, 0xE3,
-0x33, 0x66,
+	0xAE, 0x1E, 0x0E, 0xBD,
+	0x58, 0xE3,
+	0x33, 0x66,
 
-0x48, 0x35, 0x48, 0xBF,
-0x58, 0x35, 0x58, 0xBF,
+	0x48, 0x35, 0x48, 0xBF,
+	0x58, 0x35, 0x58, 0xBF,
 
-0x68, 0x35, 0x68, 0xBF,
-0x49, 0x3D, 0x49, 0xBF,
+	0x68, 0x35, 0x68, 0xBF,
+	0x49, 0x3D, 0x49, 0xBF,
 
-0x59, 0x3D, 0x59, 0xBF,
-0x69, 0x3D, 0x69, 0xBF,
+	0x59, 0x3D, 0x59, 0xBF,
+	0x69, 0x3D, 0x69, 0xBF,
 
-0x63, 0x63, 0x2D, 0xDF,
-0x4D, 0x7D, 0xF8, 0xEC,
+	0x63, 0x63, 0x2D, 0xDF,
+	0x4D, 0x7D, 0xF8, 0xEC,
 
-0x59, 0xE3,
-0x00, 0xE0,
-0xB8, 0x38, 0x33, 0xBF,
+	0x59, 0xE3,
+	0x00, 0xE0,
+	0xB8, 0x38, 0x33, 0xBF,
 
-0x2D, 0x73,
-0x30, 0x76,
-0x18, 0x3A, 0x41, 0xE9,
+	0x2D, 0x73,
+	0x30, 0x76,
+	0x18, 0x3A, 0x41, 0xE9,
 
-0x3F, 0x53, 0xA0, 0xE8,
-0x05, 0x80, 0x3D, 0xEA,
+	0x3F, 0x53, 0xA0, 0xE8,
+	0x05, 0x80, 0x3D, 0xEA,
 
-0x37, 0x43, 0xA0, 0xE8,
-0x3D, 0x63, 0xA0, 0xE8,
+	0x37, 0x43, 0xA0, 0xE8,
+	0x3D, 0x63, 0xA0, 0xE8,
 
-0x50, 0x70, 0xF8, 0xEC,
-0x2B, 0x50, 0x3C, 0xE9,
+	0x50, 0x70, 0xF8, 0xEC,
+	0x2B, 0x50, 0x3C, 0xE9,
 
-0x1F, 0x0F, 0xBC, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x1F, 0x0F, 0xBC, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x59, 0x78, 0xF8, 0xEC,
-0x00, 0x80, 0x00, 0xE8,
+	0x59, 0x78, 0xF8, 0xEC,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x15, 0xC0, 0x20, 0xE9,
-0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
 
-0x15, 0xC0, 0x20, 0xE9,
-0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
 
-0x1E, 0x12, 0x41, 0xE9,
-0x1A, 0x22, 0x41, 0xE9,
+	0x1E, 0x12, 0x41, 0xE9,
+	0x1A, 0x22, 0x41, 0xE9,
 
-0x46, 0x37, 0x46, 0xDF,
-0x56, 0x3F, 0x56, 0xDF,
+	0x46, 0x37, 0x46, 0xDF,
+	0x56, 0x3F, 0x56, 0xDF,
 
-0x2B, 0x40, 0x3D, 0xE9,
-0x66, 0x3D, 0x66, 0xDF,
+	0x2B, 0x40, 0x3D, 0xE9,
+	0x66, 0x3D, 0x66, 0xDF,
 
-0x1D, 0x32, 0x41, 0xE9,
-0x67, 0x3D, 0x67, 0xDF,
+	0x1D, 0x32, 0x41, 0xE9,
+	0x67, 0x3D, 0x67, 0xDF,
 
-0x47, 0x37, 0x47, 0xDF,
-0x57, 0x3F, 0x57, 0xDF,
+	0x47, 0x37, 0x47, 0xDF,
+	0x57, 0x3F, 0x57, 0xDF,
 
-0x2A, 0x40, 0x20, 0xE9,
-0x59, 0x3F, 0x59, 0xDF,
+	0x2A, 0x40, 0x20, 0xE9,
+	0x59, 0x3F, 0x59, 0xDF,
 
-0x16, 0x30, 0x20, 0xE9,
-0x69, 0x3D, 0x69, 0xDF,
+	0x16, 0x30, 0x20, 0xE9,
+	0x69, 0x3D, 0x69, 0xDF,
 
-0x48, 0x37, 0x48, 0xDF,
-0x58, 0x3F, 0x58, 0xDF,
+	0x48, 0x37, 0x48, 0xDF,
+	0x58, 0x3F, 0x58, 0xDF,
 
-0x12, 0x12, 0x2D, 0xDF,
-0x22, 0x22, 0x2D, 0xDF,
+	0x12, 0x12, 0x2D, 0xDF,
+	0x22, 0x22, 0x2D, 0xDF,
 
-0x32, 0x32, 0x2D, 0xDF,
-0x3A, 0x3A, 0x2D, 0xDF,
+	0x32, 0x32, 0x2D, 0xDF,
+	0x3A, 0x3A, 0x2D, 0xDF,
 
-0x68, 0x3D, 0x68, 0xDF,
-0x49, 0x37, 0x49, 0xDF,
+	0x68, 0x3D, 0x68, 0xDF,
+	0x49, 0x37, 0x49, 0xDF,
 
-0x3D, 0xCF, 0x74, 0xC0,
-0x37, 0xCF, 0x74, 0xC4,
+	0x3D, 0xCF, 0x74, 0xC0,
+	0x37, 0xCF, 0x74, 0xC4,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x34, 0x80, 0x20, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x34, 0x80, 0x20, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x3C, 0x3D, 0x20, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3C, 0x3D, 0x20, 0xE9,
 
-0x0A, 0x44, 0x54, 0xB0,
-0x02, 0x44, 0x64, 0xB0,
+	0x0A, 0x44, 0x54, 0xB0,
+	0x02, 0x44, 0x64, 0xB0,
 
-0x2A, 0x44, 0x54, 0xB2,
-0x1A, 0x44, 0x64, 0xB2,
+	0x2A, 0x44, 0x54, 0xB2,
+	0x1A, 0x44, 0x64, 0xB2,
 
-0x29, 0x80, 0x3A, 0xEA,
-0x0A, 0x20,
-0x02, 0x20,
+	0x29, 0x80, 0x3A, 0xEA,
+	0x0A, 0x20,
+	0x02, 0x20,
 
-0x0F, 0xCF, 0x74, 0xC6,
-0x3D, 0xCF, 0x74, 0xC2,
+	0x0F, 0xCF, 0x74, 0xC6,
+	0x3D, 0xCF, 0x74, 0xC2,
 
-0x88, 0x73, 0x5E, 0xE9,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x88, 0x73, 0x5E, 0xE9,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x32, 0x31, 0x5F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x32, 0x31, 0x5F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x33, 0x39, 0x5F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x33, 0x39, 0x5F, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x9C, 0x0F, 0x20, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x9C, 0x0F, 0x20, 0xE9,
 
-0x0A, 0x44, 0x54, 0xB4,
-0x02, 0x44, 0x64, 0xB4,
+	0x0A, 0x44, 0x54, 0xB4,
+	0x02, 0x44, 0x64, 0xB4,
 
-0x2A, 0x44, 0x54, 0xB6,
-0x1A, 0x44, 0x64, 0xB6,
+	0x2A, 0x44, 0x54, 0xB6,
+	0x1A, 0x44, 0x64, 0xB6,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x38, 0x3D, 0x20, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x38, 0x3D, 0x20, 0xE9,
 
-0x0A, 0x20,
-0x02, 0x20,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x0A, 0x20,
+	0x02, 0x20,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0x0A, 0x47, 0x57, 0xBF,
-0x02, 0x47, 0x67, 0xBF,
+	0x0A, 0x47, 0x57, 0xBF,
+	0x02, 0x47, 0x67, 0xBF,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x3E, 0x30, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x3E, 0x30, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x3F, 0x38, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x3F, 0x38, 0x4F, 0xE9,
 
-0x2A, 0x46, 0x56, 0xBF,
-0x1A, 0x46, 0x66, 0xBF,
+	0x2A, 0x46, 0x56, 0xBF,
+	0x1A, 0x46, 0x66, 0xBF,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x3A, 0x31, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x3A, 0x31, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x3B, 0x39, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3B, 0x39, 0x4F, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x36, 0x30, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x36, 0x30, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x37, 0x38, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x37, 0x38, 0x4F, 0xE9,
 
-0x2A, 0x43, 0x53, 0xBF,
-0x1A, 0x43, 0x63, 0xBF,
+	0x2A, 0x43, 0x53, 0xBF,
+	0x1A, 0x43, 0x63, 0xBF,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x9D, 0x31, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x9D, 0x31, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x9E, 0x39, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x9E, 0x39, 0x4F, 0xE9,
 
-0x0A, 0x48, 0x58, 0xBF,
-0x02, 0x48, 0x68, 0xBF,
+	0x0A, 0x48, 0x58, 0xBF,
+	0x02, 0x48, 0x68, 0xBF,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x80, 0x31, 0x57, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x80, 0x31, 0x57, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x81, 0x39, 0x57, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x81, 0x39, 0x57, 0xE9,
 
-0x2A, 0x49, 0x59, 0xBF,
-0x1A, 0x49, 0x69, 0xBF,
+	0x2A, 0x49, 0x59, 0xBF,
+	0x1A, 0x49, 0x69, 0xBF,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x82, 0x30, 0x57, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x82, 0x30, 0x57, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x83, 0x38, 0x57, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x83, 0x38, 0x57, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x84, 0x31, 0x5E, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x84, 0x31, 0x5E, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x85, 0x39, 0x5E, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x85, 0x39, 0x5E, 0xE9,
 
-0x86, 0x76, 0x57, 0xE9,
-0x8A, 0x36, 0x20, 0xE9,
+	0x86, 0x76, 0x57, 0xE9,
+	0x8A, 0x36, 0x20, 0xE9,
 
-0x87, 0x77, 0x57, 0xE9,
-0x8B, 0x3E, 0xBF, 0xEA,
+	0x87, 0x77, 0x57, 0xE9,
+	0x8B, 0x3E, 0xBF, 0xEA,
 
-0x80, 0x30, 0x57, 0xE9,
-0x81, 0x38, 0x57, 0xE9,
+	0x80, 0x30, 0x57, 0xE9,
+	0x81, 0x38, 0x57, 0xE9,
 
-0x82, 0x31, 0x57, 0xE9,
-0x86, 0x78, 0x57, 0xE9,
+	0x82, 0x31, 0x57, 0xE9,
+	0x86, 0x78, 0x57, 0xE9,
 
-0x83, 0x39, 0x57, 0xE9,
-0x87, 0x79, 0x57, 0xE9,
+	0x83, 0x39, 0x57, 0xE9,
+	0x87, 0x79, 0x57, 0xE9,
 
-0x30, 0x1F, 0x5F, 0xE9,
-0x8A, 0x34, 0x20, 0xE9,
+	0x30, 0x1F, 0x5F, 0xE9,
+	0x8A, 0x34, 0x20, 0xE9,
 
-0x8B, 0x3C, 0x20, 0xE9,
-0x37, 0x50, 0x60, 0xBD,
+	0x8B, 0x3C, 0x20, 0xE9,
+	0x37, 0x50, 0x60, 0xBD,
 
-0x57, 0x0D, 0x20, 0xE9,
-0x35, 0x51, 0x61, 0xBD,
+	0x57, 0x0D, 0x20, 0xE9,
+	0x35, 0x51, 0x61, 0xBD,
 
-0x2B, 0x50, 0x20, 0xE9,
-0x1D, 0x37, 0xE1, 0xEA,
+	0x2B, 0x50, 0x20, 0xE9,
+	0x1D, 0x37, 0xE1, 0xEA,
 
-0x1E, 0x35, 0xE1, 0xEA,
-0x00, 0xE0,
-0x0E, 0x77,
+	0x1E, 0x35, 0xE1, 0xEA,
+	0x00, 0xE0,
+	0x0E, 0x77,
 
-0x24, 0x51, 0x20, 0xE9,
-0x9B, 0xFF, 0x20, 0xEA,
+	0x24, 0x51, 0x20, 0xE9,
+	0x9B, 0xFF, 0x20, 0xEA,
 
-0x16, 0x0E, 0x20, 0xE9,
-0x57, 0x2E, 0xBF, 0xEA,
+	0x16, 0x0E, 0x20, 0xE9,
+	0x57, 0x2E, 0xBF, 0xEA,
 
-0x0B, 0x46, 0xA0, 0xE8,
-0x1B, 0x56, 0xA0, 0xE8,
+	0x0B, 0x46, 0xA0, 0xE8,
+	0x1B, 0x56, 0xA0, 0xE8,
 
-0x2B, 0x66, 0xA0, 0xE8,
-0x0C, 0x47, 0xA0, 0xE8,
+	0x2B, 0x66, 0xA0, 0xE8,
+	0x0C, 0x47, 0xA0, 0xE8,
 
-0x1C, 0x57, 0xA0, 0xE8,
-0x2C, 0x67, 0xA0, 0xE8,
+	0x1C, 0x57, 0xA0, 0xE8,
+	0x2C, 0x67, 0xA0, 0xE8,
 
-0x0B, 0x00,
-0x1B, 0x00,
-0x2B, 0x00,
-0x00, 0xE0,
+	0x0B, 0x00,
+	0x1B, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
 
-0x0C, 0x00,
-0x1C, 0x00,
-0x2C, 0x00,
-0x00, 0xE0,
+	0x0C, 0x00,
+	0x1C, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
 
-0x0B, 0x65,
-0x1B, 0x65,
-0x2B, 0x65,
-0x00, 0xE0,
+	0x0B, 0x65,
+	0x1B, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
 
-0x0C, 0x65,
-0x1C, 0x65,
-0x2C, 0x65,
-0x00, 0xE0,
+	0x0C, 0x65,
+	0x1C, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
 
-0x0B, 0x1B, 0x60, 0xEC,
-0x36, 0xD7, 0x36, 0xAD,
+	0x0B, 0x1B, 0x60, 0xEC,
+	0x36, 0xD7, 0x36, 0xAD,
 
-0x2B, 0x80, 0x60, 0xEC,
-0x0C, 0x1C, 0x60, 0xEC,
+	0x2B, 0x80, 0x60, 0xEC,
+	0x0C, 0x1C, 0x60, 0xEC,
 
-0x3E, 0xD7, 0x3E, 0xAD,
-0x2C, 0x80, 0x60, 0xEC,
+	0x3E, 0xD7, 0x3E, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
 
-0x0B, 0x2B, 0xDE, 0xE8,
-0x1B, 0x80, 0xDE, 0xE8,
+	0x0B, 0x2B, 0xDE, 0xE8,
+	0x1B, 0x80, 0xDE, 0xE8,
 
-0x36, 0x80, 0x36, 0xBD,
-0x3E, 0x80, 0x3E, 0xBD,
+	0x36, 0x80, 0x36, 0xBD,
+	0x3E, 0x80, 0x3E, 0xBD,
 
-0x33, 0xD7, 0x0B, 0xBD,
-0x3B, 0xD7, 0x1B, 0xBD,
+	0x33, 0xD7, 0x0B, 0xBD,
+	0x3B, 0xD7, 0x1B, 0xBD,
 
-0x46, 0x80, 0x46, 0xCF,
-0x57, 0x80, 0x57, 0xCF,
+	0x46, 0x80, 0x46, 0xCF,
+	0x57, 0x80, 0x57, 0xCF,
 
-0x66, 0x33, 0x66, 0xCF,
-0x47, 0x3B, 0x47, 0xCF,
+	0x66, 0x33, 0x66, 0xCF,
+	0x47, 0x3B, 0x47, 0xCF,
 
-0x56, 0x33, 0x56, 0xCF,
-0x67, 0x3B, 0x67, 0xCF,
+	0x56, 0x33, 0x56, 0xCF,
+	0x67, 0x3B, 0x67, 0xCF,
 
-0x0B, 0x48, 0xA0, 0xE8,
-0x1B, 0x58, 0xA0, 0xE8,
+	0x0B, 0x48, 0xA0, 0xE8,
+	0x1B, 0x58, 0xA0, 0xE8,
 
-0x2B, 0x68, 0xA0, 0xE8,
-0x0C, 0x49, 0xA0, 0xE8,
+	0x2B, 0x68, 0xA0, 0xE8,
+	0x0C, 0x49, 0xA0, 0xE8,
 
-0x1C, 0x59, 0xA0, 0xE8,
-0x2C, 0x69, 0xA0, 0xE8,
+	0x1C, 0x59, 0xA0, 0xE8,
+	0x2C, 0x69, 0xA0, 0xE8,
 
-0x0B, 0x00,
-0x1B, 0x00,
-0x2B, 0x00,
-0x00, 0xE0,
+	0x0B, 0x00,
+	0x1B, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
 
-0x0C, 0x00,
-0x1C, 0x00,
-0x2C, 0x00,
-0x00, 0xE0,
+	0x0C, 0x00,
+	0x1C, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
 
-0x0B, 0x65,
-0x1B, 0x65,
-0x2B, 0x65,
-0x00, 0xE0,
+	0x0B, 0x65,
+	0x1B, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
 
-0x0C, 0x65,
-0x1C, 0x65,
-0x2C, 0x65,
-0x00, 0xE0,
+	0x0C, 0x65,
+	0x1C, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
 
-0x0B, 0x1B, 0x60, 0xEC,
-0x34, 0xD7, 0x34, 0xAD,
+	0x0B, 0x1B, 0x60, 0xEC,
+	0x34, 0xD7, 0x34, 0xAD,
 
-0x2B, 0x80, 0x60, 0xEC,
-0x0C, 0x1C, 0x60, 0xEC,
+	0x2B, 0x80, 0x60, 0xEC,
+	0x0C, 0x1C, 0x60, 0xEC,
 
-0x3C, 0xD7, 0x3C, 0xAD,
-0x2C, 0x80, 0x60, 0xEC,
+	0x3C, 0xD7, 0x3C, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
 
-0x0B, 0x2B, 0xDE, 0xE8,
-0x1B, 0x80, 0xDE, 0xE8,
+	0x0B, 0x2B, 0xDE, 0xE8,
+	0x1B, 0x80, 0xDE, 0xE8,
 
-0x34, 0x80, 0x34, 0xBD,
-0x3C, 0x80, 0x3C, 0xBD,
+	0x34, 0x80, 0x34, 0xBD,
+	0x3C, 0x80, 0x3C, 0xBD,
 
-0x33, 0xD7, 0x0B, 0xBD,
-0x3B, 0xD7, 0x1B, 0xBD,
+	0x33, 0xD7, 0x0B, 0xBD,
+	0x3B, 0xD7, 0x1B, 0xBD,
 
-0x48, 0x80, 0x48, 0xCF,
-0x59, 0x80, 0x59, 0xCF,
+	0x48, 0x80, 0x48, 0xCF,
+	0x59, 0x80, 0x59, 0xCF,
 
-0x68, 0x33, 0x68, 0xCF,
-0x49, 0x3B, 0x49, 0xCF,
+	0x68, 0x33, 0x68, 0xCF,
+	0x49, 0x3B, 0x49, 0xCF,
 
-0xBA, 0xFF, 0x20, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0xBA, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x58, 0x33, 0x58, 0xCF,
-0x69, 0x3B, 0x69, 0xCF,
+	0x58, 0x33, 0x58, 0xCF,
+	0x69, 0x3B, 0x69, 0xCF,
 
-0x79, 0xFF, 0x20, 0xEA,
-0x57, 0xC0, 0xBF, 0xEA,
+	0x79, 0xFF, 0x20, 0xEA,
+	0x57, 0xC0, 0xBF, 0xEA,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x00, 0x00, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
 
 };
 
 static unsigned char warp_g400_t2gzaf[] = {
 
-0x00, 0x8A, 0x98, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x8A, 0x98, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x00, 0x00, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
 
-0xFF, 0x80, 0xC0, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x0A, 0x40, 0x50, 0xBF,
-0x2A, 0x40, 0x60, 0xBF,
+	0x0A, 0x40, 0x50, 0xBF,
+	0x2A, 0x40, 0x60, 0xBF,
 
-0x32, 0x41, 0x51, 0xBF,
-0x3A, 0x41, 0x61, 0xBF,
+	0x32, 0x41, 0x51, 0xBF,
+	0x3A, 0x41, 0x61, 0xBF,
 
-0xC3, 0x6B,
-0xD3, 0x6B,
-0x00, 0x8A, 0x98, 0xE9,
+	0xC3, 0x6B,
+	0xD3, 0x6B,
+	0x00, 0x8A, 0x98, 0xE9,
 
-0x73, 0x7B, 0xC8, 0xEC,
-0x96, 0xE2,
-0x41, 0x04,
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x96, 0xE2,
+	0x41, 0x04,
 
-0x7B, 0x43, 0xA0, 0xE8,
-0x73, 0x53, 0xA0, 0xE8,
+	0x7B, 0x43, 0xA0, 0xE8,
+	0x73, 0x53, 0xA0, 0xE8,
 
-0xAD, 0xEE, 0x23, 0x9F,
-0x00, 0xE0,
-0x51, 0x04,
+	0xAD, 0xEE, 0x23, 0x9F,
+	0x00, 0xE0,
+	0x51, 0x04,
 
-0x90, 0xE2,
-0x61, 0x04,
-0x31, 0x46, 0xB1, 0xE8,
+	0x90, 0xE2,
+	0x61, 0x04,
+	0x31, 0x46, 0xB1, 0xE8,
 
-0x51, 0x41, 0xE0, 0xEC,
-0x39, 0x67, 0xB1, 0xE8,
+	0x51, 0x41, 0xE0, 0xEC,
+	0x39, 0x67, 0xB1, 0xE8,
 
-0x00, 0x04,
-0x46, 0xE2,
-0x73, 0x63, 0xA0, 0xE8,
+	0x00, 0x04,
+	0x46, 0xE2,
+	0x73, 0x63, 0xA0, 0xE8,
 
-0x61, 0x41, 0xE0, 0xEC,
-0x31, 0x00,
-0x39, 0x00,
+	0x61, 0x41, 0xE0, 0xEC,
+	0x31, 0x00,
+	0x39, 0x00,
 
-0x81, 0x80, 0x15, 0xEA,
-0x10, 0x04,
-0x20, 0x04,
+	0x81, 0x80, 0x15, 0xEA,
+	0x10, 0x04,
+	0x20, 0x04,
 
-0x61, 0x51, 0xE0, 0xEC,
-0x2F, 0x41, 0x60, 0xEA,
+	0x61, 0x51, 0xE0, 0xEC,
+	0x2F, 0x41, 0x60, 0xEA,
 
-0x31, 0x20,
-0x39, 0x20,
-0x1F, 0x42, 0xA0, 0xE8,
+	0x31, 0x20,
+	0x39, 0x20,
+	0x1F, 0x42, 0xA0, 0xE8,
 
-0x2A, 0x42, 0x52, 0xBF,
-0x0F, 0x52, 0xA0, 0xE8,
+	0x2A, 0x42, 0x52, 0xBF,
+	0x0F, 0x52, 0xA0, 0xE8,
 
-0x1A, 0x42, 0x62, 0xBF,
-0x1E, 0x51, 0x60, 0xEA,
+	0x1A, 0x42, 0x62, 0xBF,
+	0x1E, 0x51, 0x60, 0xEA,
 
-0x73, 0x7B, 0xC8, 0xEC,
-0x0E, 0x61, 0x60, 0xEA,
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x0E, 0x61, 0x60, 0xEA,
 
-0x32, 0x40, 0x50, 0xBD,
-0x22, 0x40, 0x60, 0xBD,
+	0x32, 0x40, 0x50, 0xBD,
+	0x22, 0x40, 0x60, 0xBD,
 
-0x12, 0x41, 0x51, 0xBD,
-0x3A, 0x41, 0x61, 0xBD,
+	0x12, 0x41, 0x51, 0xBD,
+	0x3A, 0x41, 0x61, 0xBD,
 
-0xBF, 0x2F, 0x0E, 0xBD,
-0x97, 0xE2,
-0x7B, 0x72,
+	0xBF, 0x2F, 0x0E, 0xBD,
+	0x97, 0xE2,
+	0x7B, 0x72,
 
-0x32, 0x20,
-0x22, 0x20,
-0x12, 0x20,
-0x3A, 0x20,
+	0x32, 0x20,
+	0x22, 0x20,
+	0x12, 0x20,
+	0x3A, 0x20,
 
-0x35, 0x48, 0xB1, 0xE8,
-0x3D, 0x59, 0xB1, 0xE8,
+	0x35, 0x48, 0xB1, 0xE8,
+	0x3D, 0x59, 0xB1, 0xE8,
 
-0x46, 0x31, 0x46, 0xBF,
-0x56, 0x31, 0x56, 0xBF,
+	0x46, 0x31, 0x46, 0xBF,
+	0x56, 0x31, 0x56, 0xBF,
 
-0xB3, 0xE2, 0x2D, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0xB3, 0xE2, 0x2D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x66, 0x31, 0x66, 0xBF,
-0x47, 0x39, 0x47, 0xBF,
+	0x66, 0x31, 0x66, 0xBF,
+	0x47, 0x39, 0x47, 0xBF,
 
-0x57, 0x39, 0x57, 0xBF,
-0x67, 0x39, 0x67, 0xBF,
+	0x57, 0x39, 0x57, 0xBF,
+	0x67, 0x39, 0x67, 0xBF,
 
-0x72, 0x80, 0x07, 0xEA,
-0x24, 0x41, 0x20, 0xE9,
+	0x72, 0x80, 0x07, 0xEA,
+	0x24, 0x41, 0x20, 0xE9,
 
-0x35, 0x00,
-0x3D, 0x00,
-0x00, 0xE0,
-0x2D, 0x73,
+	0x35, 0x00,
+	0x3D, 0x00,
+	0x00, 0xE0,
+	0x2D, 0x73,
 
-0x33, 0x72,
-0x0C, 0xE3,
-0x8D, 0x2F, 0x1E, 0xBD,
+	0x33, 0x72,
+	0x0C, 0xE3,
+	0x8D, 0x2F, 0x1E, 0xBD,
 
-0x43, 0x75, 0xF8, 0xEC,
-0x35, 0x20,
-0x3D, 0x20,
+	0x43, 0x75, 0xF8, 0xEC,
+	0x35, 0x20,
+	0x3D, 0x20,
 
-0x43, 0x43, 0x2D, 0xDF,
-0x53, 0x53, 0x2D, 0xDF,
+	0x43, 0x43, 0x2D, 0xDF,
+	0x53, 0x53, 0x2D, 0xDF,
 
-0xAE, 0x1E, 0x0E, 0xBD,
-0x58, 0xE3,
-0x33, 0x66,
+	0xAE, 0x1E, 0x0E, 0xBD,
+	0x58, 0xE3,
+	0x33, 0x66,
 
-0x48, 0x35, 0x48, 0xBF,
-0x58, 0x35, 0x58, 0xBF,
+	0x48, 0x35, 0x48, 0xBF,
+	0x58, 0x35, 0x58, 0xBF,
 
-0x68, 0x35, 0x68, 0xBF,
-0x49, 0x3D, 0x49, 0xBF,
+	0x68, 0x35, 0x68, 0xBF,
+	0x49, 0x3D, 0x49, 0xBF,
 
-0x59, 0x3D, 0x59, 0xBF,
-0x69, 0x3D, 0x69, 0xBF,
+	0x59, 0x3D, 0x59, 0xBF,
+	0x69, 0x3D, 0x69, 0xBF,
 
-0x63, 0x63, 0x2D, 0xDF,
-0x4D, 0x7D, 0xF8, 0xEC,
+	0x63, 0x63, 0x2D, 0xDF,
+	0x4D, 0x7D, 0xF8, 0xEC,
 
-0x59, 0xE3,
-0x00, 0xE0,
-0xB8, 0x38, 0x33, 0xBF,
+	0x59, 0xE3,
+	0x00, 0xE0,
+	0xB8, 0x38, 0x33, 0xBF,
 
-0x2D, 0x73,
-0x30, 0x76,
-0x18, 0x3A, 0x41, 0xE9,
+	0x2D, 0x73,
+	0x30, 0x76,
+	0x18, 0x3A, 0x41, 0xE9,
 
-0x3F, 0x53, 0xA0, 0xE8,
-0x05, 0x80, 0x3D, 0xEA,
+	0x3F, 0x53, 0xA0, 0xE8,
+	0x05, 0x80, 0x3D, 0xEA,
 
-0x37, 0x43, 0xA0, 0xE8,
-0x3D, 0x63, 0xA0, 0xE8,
+	0x37, 0x43, 0xA0, 0xE8,
+	0x3D, 0x63, 0xA0, 0xE8,
 
-0x50, 0x70, 0xF8, 0xEC,
-0x2B, 0x50, 0x3C, 0xE9,
+	0x50, 0x70, 0xF8, 0xEC,
+	0x2B, 0x50, 0x3C, 0xE9,
 
-0x1F, 0x0F, 0xBC, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x1F, 0x0F, 0xBC, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x59, 0x78, 0xF8, 0xEC,
-0x00, 0x80, 0x00, 0xE8,
+	0x59, 0x78, 0xF8, 0xEC,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x15, 0xC0, 0x20, 0xE9,
-0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
 
-0x15, 0xC0, 0x20, 0xE9,
-0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
 
-0x1E, 0x12, 0x41, 0xE9,
-0x1A, 0x22, 0x41, 0xE9,
+	0x1E, 0x12, 0x41, 0xE9,
+	0x1A, 0x22, 0x41, 0xE9,
 
-0x46, 0x37, 0x46, 0xDF,
-0x56, 0x3F, 0x56, 0xDF,
+	0x46, 0x37, 0x46, 0xDF,
+	0x56, 0x3F, 0x56, 0xDF,
 
-0x2B, 0x40, 0x3D, 0xE9,
-0x66, 0x3D, 0x66, 0xDF,
+	0x2B, 0x40, 0x3D, 0xE9,
+	0x66, 0x3D, 0x66, 0xDF,
 
-0x1D, 0x32, 0x41, 0xE9,
-0x67, 0x3D, 0x67, 0xDF,
+	0x1D, 0x32, 0x41, 0xE9,
+	0x67, 0x3D, 0x67, 0xDF,
 
-0x47, 0x37, 0x47, 0xDF,
-0x57, 0x3F, 0x57, 0xDF,
+	0x47, 0x37, 0x47, 0xDF,
+	0x57, 0x3F, 0x57, 0xDF,
 
-0x2A, 0x40, 0x20, 0xE9,
-0x59, 0x3F, 0x59, 0xDF,
+	0x2A, 0x40, 0x20, 0xE9,
+	0x59, 0x3F, 0x59, 0xDF,
 
-0x16, 0x30, 0x20, 0xE9,
-0x69, 0x3D, 0x69, 0xDF,
+	0x16, 0x30, 0x20, 0xE9,
+	0x69, 0x3D, 0x69, 0xDF,
 
-0x48, 0x37, 0x48, 0xDF,
-0x58, 0x3F, 0x58, 0xDF,
+	0x48, 0x37, 0x48, 0xDF,
+	0x58, 0x3F, 0x58, 0xDF,
 
-0x12, 0x12, 0x2D, 0xDF,
-0x22, 0x22, 0x2D, 0xDF,
+	0x12, 0x12, 0x2D, 0xDF,
+	0x22, 0x22, 0x2D, 0xDF,
 
-0x32, 0x32, 0x2D, 0xDF,
-0x3A, 0x3A, 0x2D, 0xDF,
+	0x32, 0x32, 0x2D, 0xDF,
+	0x3A, 0x3A, 0x2D, 0xDF,
 
-0x68, 0x3D, 0x68, 0xDF,
-0x49, 0x37, 0x49, 0xDF,
+	0x68, 0x3D, 0x68, 0xDF,
+	0x49, 0x37, 0x49, 0xDF,
 
-0x3D, 0xCF, 0x74, 0xC0,
-0x37, 0xCF, 0x74, 0xC4,
+	0x3D, 0xCF, 0x74, 0xC0,
+	0x37, 0xCF, 0x74, 0xC4,
 
-0x0A, 0x44, 0x54, 0xB0,
-0x02, 0x44, 0x64, 0xB0,
+	0x0A, 0x44, 0x54, 0xB0,
+	0x02, 0x44, 0x64, 0xB0,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x34, 0x37, 0x20, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x34, 0x37, 0x20, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x3C, 0x3D, 0x20, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3C, 0x3D, 0x20, 0xE9,
 
-0x2A, 0x44, 0x54, 0xB2,
-0x1A, 0x44, 0x64, 0xB2,
+	0x2A, 0x44, 0x54, 0xB2,
+	0x1A, 0x44, 0x64, 0xB2,
 
-0x2E, 0x80, 0x3A, 0xEA,
-0x0A, 0x20,
-0x02, 0x20,
+	0x2E, 0x80, 0x3A, 0xEA,
+	0x0A, 0x20,
+	0x02, 0x20,
 
-0x88, 0x73, 0x5E, 0xE9,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x88, 0x73, 0x5E, 0xE9,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0x3D, 0xCF, 0x74, 0xC2,
-0x0F, 0xCF, 0x74, 0xC6,
+	0x3D, 0xCF, 0x74, 0xC2,
+	0x0F, 0xCF, 0x74, 0xC6,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x32, 0x31, 0x5F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x32, 0x31, 0x5F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x33, 0x39, 0x5F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x33, 0x39, 0x5F, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x9C, 0x0F, 0x20, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x9C, 0x0F, 0x20, 0xE9,
 
-0x0A, 0x44, 0x54, 0xB4,
-0x02, 0x44, 0x64, 0xB4,
+	0x0A, 0x44, 0x54, 0xB4,
+	0x02, 0x44, 0x64, 0xB4,
 
-0x2A, 0x44, 0x54, 0xB6,
-0x1A, 0x44, 0x64, 0xB6,
+	0x2A, 0x44, 0x54, 0xB6,
+	0x1A, 0x44, 0x64, 0xB6,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x38, 0x3D, 0x20, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x38, 0x3D, 0x20, 0xE9,
 
-0x0A, 0x20,
-0x02, 0x20,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x0A, 0x20,
+	0x02, 0x20,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0x3D, 0xCF, 0x75, 0xC6,
-0x00, 0x80, 0x00, 0xE8,
+	0x3D, 0xCF, 0x75, 0xC6,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x3E, 0x30, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x3E, 0x30, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x3F, 0x38, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x3F, 0x38, 0x4F, 0xE9,
 
-0x0A, 0x45, 0x55, 0xB6,
-0x02, 0x45, 0x65, 0xB6,
+	0x0A, 0x45, 0x55, 0xB6,
+	0x02, 0x45, 0x65, 0xB6,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x3A, 0x31, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x3A, 0x31, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x3B, 0x39, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3B, 0x39, 0x4F, 0xE9,
 
-0x31, 0x3D, 0x20, 0xE9,
-0x0A, 0x20,
-0x02, 0x20,
+	0x31, 0x3D, 0x20, 0xE9,
+	0x0A, 0x20,
+	0x02, 0x20,
 
-0x2A, 0x46, 0x56, 0xBF,
-0x1A, 0x46, 0x66, 0xBF,
+	0x2A, 0x46, 0x56, 0xBF,
+	0x1A, 0x46, 0x66, 0xBF,
 
-0x0A, 0x47, 0x57, 0xBF,
-0x02, 0x47, 0x67, 0xBF,
+	0x0A, 0x47, 0x57, 0xBF,
+	0x02, 0x47, 0x67, 0xBF,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x36, 0x30, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x36, 0x30, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x37, 0x38, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x37, 0x38, 0x4F, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x9D, 0x31, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x9D, 0x31, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x9E, 0x39, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x9E, 0x39, 0x4F, 0xE9,
 
-0x2A, 0x43, 0x53, 0xBF,
-0x1A, 0x43, 0x63, 0xBF,
+	0x2A, 0x43, 0x53, 0xBF,
+	0x1A, 0x43, 0x63, 0xBF,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x35, 0x30, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x35, 0x30, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x39, 0x38, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x39, 0x38, 0x4F, 0xE9,
 
-0x0A, 0x48, 0x58, 0xBF,
-0x02, 0x48, 0x68, 0xBF,
+	0x0A, 0x48, 0x58, 0xBF,
+	0x02, 0x48, 0x68, 0xBF,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x80, 0x31, 0x57, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x80, 0x31, 0x57, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x81, 0x39, 0x57, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x81, 0x39, 0x57, 0xE9,
 
-0x2A, 0x49, 0x59, 0xBF,
-0x1A, 0x49, 0x69, 0xBF,
+	0x2A, 0x49, 0x59, 0xBF,
+	0x1A, 0x49, 0x69, 0xBF,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x82, 0x30, 0x57, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x82, 0x30, 0x57, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x83, 0x38, 0x57, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x83, 0x38, 0x57, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x84, 0x31, 0x5E, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x84, 0x31, 0x5E, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x85, 0x39, 0x5E, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x85, 0x39, 0x5E, 0xE9,
 
-0x86, 0x76, 0x57, 0xE9,
-0x8A, 0x36, 0x20, 0xE9,
+	0x86, 0x76, 0x57, 0xE9,
+	0x8A, 0x36, 0x20, 0xE9,
 
-0x87, 0x77, 0x57, 0xE9,
-0x8B, 0x3E, 0xBF, 0xEA,
+	0x87, 0x77, 0x57, 0xE9,
+	0x8B, 0x3E, 0xBF, 0xEA,
 
-0x80, 0x30, 0x57, 0xE9,
-0x81, 0x38, 0x57, 0xE9,
+	0x80, 0x30, 0x57, 0xE9,
+	0x81, 0x38, 0x57, 0xE9,
 
-0x82, 0x31, 0x57, 0xE9,
-0x86, 0x78, 0x57, 0xE9,
+	0x82, 0x31, 0x57, 0xE9,
+	0x86, 0x78, 0x57, 0xE9,
 
-0x83, 0x39, 0x57, 0xE9,
-0x87, 0x79, 0x57, 0xE9,
+	0x83, 0x39, 0x57, 0xE9,
+	0x87, 0x79, 0x57, 0xE9,
 
-0x30, 0x1F, 0x5F, 0xE9,
-0x8A, 0x34, 0x20, 0xE9,
+	0x30, 0x1F, 0x5F, 0xE9,
+	0x8A, 0x34, 0x20, 0xE9,
 
-0x8B, 0x3C, 0x20, 0xE9,
-0x37, 0x50, 0x60, 0xBD,
+	0x8B, 0x3C, 0x20, 0xE9,
+	0x37, 0x50, 0x60, 0xBD,
 
-0x57, 0x0D, 0x20, 0xE9,
-0x35, 0x51, 0x61, 0xBD,
+	0x57, 0x0D, 0x20, 0xE9,
+	0x35, 0x51, 0x61, 0xBD,
 
-0x2B, 0x50, 0x20, 0xE9,
-0x1D, 0x37, 0xE1, 0xEA,
+	0x2B, 0x50, 0x20, 0xE9,
+	0x1D, 0x37, 0xE1, 0xEA,
 
-0x1E, 0x35, 0xE1, 0xEA,
-0x00, 0xE0,
-0x0E, 0x77,
+	0x1E, 0x35, 0xE1, 0xEA,
+	0x00, 0xE0,
+	0x0E, 0x77,
 
-0x24, 0x51, 0x20, 0xE9,
-0x96, 0xFF, 0x20, 0xEA,
+	0x24, 0x51, 0x20, 0xE9,
+	0x96, 0xFF, 0x20, 0xEA,
 
-0x16, 0x0E, 0x20, 0xE9,
-0x57, 0x2E, 0xBF, 0xEA,
+	0x16, 0x0E, 0x20, 0xE9,
+	0x57, 0x2E, 0xBF, 0xEA,
 
-0x0B, 0x46, 0xA0, 0xE8,
-0x1B, 0x56, 0xA0, 0xE8,
+	0x0B, 0x46, 0xA0, 0xE8,
+	0x1B, 0x56, 0xA0, 0xE8,
 
-0x2B, 0x66, 0xA0, 0xE8,
-0x0C, 0x47, 0xA0, 0xE8,
+	0x2B, 0x66, 0xA0, 0xE8,
+	0x0C, 0x47, 0xA0, 0xE8,
 
-0x1C, 0x57, 0xA0, 0xE8,
-0x2C, 0x67, 0xA0, 0xE8,
+	0x1C, 0x57, 0xA0, 0xE8,
+	0x2C, 0x67, 0xA0, 0xE8,
 
-0x0B, 0x00,
-0x1B, 0x00,
-0x2B, 0x00,
-0x00, 0xE0,
+	0x0B, 0x00,
+	0x1B, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
 
-0x0C, 0x00,
-0x1C, 0x00,
-0x2C, 0x00,
-0x00, 0xE0,
+	0x0C, 0x00,
+	0x1C, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
 
-0x0B, 0x65,
-0x1B, 0x65,
-0x2B, 0x65,
-0x00, 0xE0,
+	0x0B, 0x65,
+	0x1B, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
 
-0x0C, 0x65,
-0x1C, 0x65,
-0x2C, 0x65,
-0x00, 0xE0,
+	0x0C, 0x65,
+	0x1C, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
 
-0x0B, 0x1B, 0x60, 0xEC,
-0x36, 0xD7, 0x36, 0xAD,
+	0x0B, 0x1B, 0x60, 0xEC,
+	0x36, 0xD7, 0x36, 0xAD,
 
-0x2B, 0x80, 0x60, 0xEC,
-0x0C, 0x1C, 0x60, 0xEC,
+	0x2B, 0x80, 0x60, 0xEC,
+	0x0C, 0x1C, 0x60, 0xEC,
 
-0x3E, 0xD7, 0x3E, 0xAD,
-0x2C, 0x80, 0x60, 0xEC,
+	0x3E, 0xD7, 0x3E, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
 
-0x0B, 0x2B, 0xDE, 0xE8,
-0x1B, 0x80, 0xDE, 0xE8,
+	0x0B, 0x2B, 0xDE, 0xE8,
+	0x1B, 0x80, 0xDE, 0xE8,
 
-0x36, 0x80, 0x36, 0xBD,
-0x3E, 0x80, 0x3E, 0xBD,
+	0x36, 0x80, 0x36, 0xBD,
+	0x3E, 0x80, 0x3E, 0xBD,
 
-0x33, 0xD7, 0x0B, 0xBD,
-0x3B, 0xD7, 0x1B, 0xBD,
+	0x33, 0xD7, 0x0B, 0xBD,
+	0x3B, 0xD7, 0x1B, 0xBD,
 
-0x46, 0x80, 0x46, 0xCF,
-0x57, 0x80, 0x57, 0xCF,
+	0x46, 0x80, 0x46, 0xCF,
+	0x57, 0x80, 0x57, 0xCF,
 
-0x66, 0x33, 0x66, 0xCF,
-0x47, 0x3B, 0x47, 0xCF,
+	0x66, 0x33, 0x66, 0xCF,
+	0x47, 0x3B, 0x47, 0xCF,
 
-0x56, 0x33, 0x56, 0xCF,
-0x67, 0x3B, 0x67, 0xCF,
+	0x56, 0x33, 0x56, 0xCF,
+	0x67, 0x3B, 0x67, 0xCF,
 
-0x0B, 0x48, 0xA0, 0xE8,
-0x1B, 0x58, 0xA0, 0xE8,
+	0x0B, 0x48, 0xA0, 0xE8,
+	0x1B, 0x58, 0xA0, 0xE8,
 
-0x2B, 0x68, 0xA0, 0xE8,
-0x0C, 0x49, 0xA0, 0xE8,
+	0x2B, 0x68, 0xA0, 0xE8,
+	0x0C, 0x49, 0xA0, 0xE8,
 
-0x1C, 0x59, 0xA0, 0xE8,
-0x2C, 0x69, 0xA0, 0xE8,
+	0x1C, 0x59, 0xA0, 0xE8,
+	0x2C, 0x69, 0xA0, 0xE8,
 
-0x0B, 0x00,
-0x1B, 0x00,
-0x2B, 0x00,
-0x00, 0xE0,
+	0x0B, 0x00,
+	0x1B, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
 
-0x0C, 0x00,
-0x1C, 0x00,
-0x2C, 0x00,
-0x00, 0xE0,
+	0x0C, 0x00,
+	0x1C, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
 
-0x0B, 0x65,
-0x1B, 0x65,
-0x2B, 0x65,
-0x00, 0xE0,
+	0x0B, 0x65,
+	0x1B, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
 
-0x0C, 0x65,
-0x1C, 0x65,
-0x2C, 0x65,
-0x00, 0xE0,
+	0x0C, 0x65,
+	0x1C, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
 
-0x0B, 0x1B, 0x60, 0xEC,
-0x34, 0xD7, 0x34, 0xAD,
+	0x0B, 0x1B, 0x60, 0xEC,
+	0x34, 0xD7, 0x34, 0xAD,
 
-0x2B, 0x80, 0x60, 0xEC,
-0x0C, 0x1C, 0x60, 0xEC,
+	0x2B, 0x80, 0x60, 0xEC,
+	0x0C, 0x1C, 0x60, 0xEC,
 
-0x3C, 0xD7, 0x3C, 0xAD,
-0x2C, 0x80, 0x60, 0xEC,
+	0x3C, 0xD7, 0x3C, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
 
-0x0B, 0x2B, 0xDE, 0xE8,
-0x1B, 0x80, 0xDE, 0xE8,
+	0x0B, 0x2B, 0xDE, 0xE8,
+	0x1B, 0x80, 0xDE, 0xE8,
 
-0x34, 0x80, 0x34, 0xBD,
-0x3C, 0x80, 0x3C, 0xBD,
+	0x34, 0x80, 0x34, 0xBD,
+	0x3C, 0x80, 0x3C, 0xBD,
 
-0x33, 0xD7, 0x0B, 0xBD,
-0x3B, 0xD7, 0x1B, 0xBD,
+	0x33, 0xD7, 0x0B, 0xBD,
+	0x3B, 0xD7, 0x1B, 0xBD,
 
-0x48, 0x80, 0x48, 0xCF,
-0x59, 0x80, 0x59, 0xCF,
+	0x48, 0x80, 0x48, 0xCF,
+	0x59, 0x80, 0x59, 0xCF,
 
-0x68, 0x33, 0x68, 0xCF,
-0x49, 0x3B, 0x49, 0xCF,
+	0x68, 0x33, 0x68, 0xCF,
+	0x49, 0x3B, 0x49, 0xCF,
 
-0xB5, 0xFF, 0x20, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0xB5, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x58, 0x33, 0x58, 0xCF,
-0x69, 0x3B, 0x69, 0xCF,
+	0x58, 0x33, 0x58, 0xCF,
+	0x69, 0x3B, 0x69, 0xCF,
 
-0x74, 0xFF, 0x20, 0xEA,
-0x57, 0xC0, 0xBF, 0xEA,
+	0x74, 0xFF, 0x20, 0xEA,
+	0x57, 0xC0, 0xBF, 0xEA,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x00, 0x00, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
 
 };
 
 static unsigned char warp_g400_t2gzf[] = {
 
-0x00, 0x8A, 0x98, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x8A, 0x98, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x00, 0x00, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
 
-0xFF, 0x80, 0xC0, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x0A, 0x40, 0x50, 0xBF,
-0x2A, 0x40, 0x60, 0xBF,
+	0x0A, 0x40, 0x50, 0xBF,
+	0x2A, 0x40, 0x60, 0xBF,
 
-0x32, 0x41, 0x51, 0xBF,
-0x3A, 0x41, 0x61, 0xBF,
+	0x32, 0x41, 0x51, 0xBF,
+	0x3A, 0x41, 0x61, 0xBF,
 
-0xC3, 0x6B,
-0xD3, 0x6B,
-0x00, 0x8A, 0x98, 0xE9,
+	0xC3, 0x6B,
+	0xD3, 0x6B,
+	0x00, 0x8A, 0x98, 0xE9,
 
-0x73, 0x7B, 0xC8, 0xEC,
-0x96, 0xE2,
-0x41, 0x04,
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x96, 0xE2,
+	0x41, 0x04,
 
-0x7B, 0x43, 0xA0, 0xE8,
-0x73, 0x53, 0xA0, 0xE8,
+	0x7B, 0x43, 0xA0, 0xE8,
+	0x73, 0x53, 0xA0, 0xE8,
 
-0xAD, 0xEE, 0x23, 0x9F,
-0x00, 0xE0,
-0x51, 0x04,
+	0xAD, 0xEE, 0x23, 0x9F,
+	0x00, 0xE0,
+	0x51, 0x04,
 
-0x90, 0xE2,
-0x61, 0x04,
-0x31, 0x46, 0xB1, 0xE8,
+	0x90, 0xE2,
+	0x61, 0x04,
+	0x31, 0x46, 0xB1, 0xE8,
 
-0x51, 0x41, 0xE0, 0xEC,
-0x39, 0x67, 0xB1, 0xE8,
+	0x51, 0x41, 0xE0, 0xEC,
+	0x39, 0x67, 0xB1, 0xE8,
 
-0x00, 0x04,
-0x46, 0xE2,
-0x73, 0x63, 0xA0, 0xE8,
+	0x00, 0x04,
+	0x46, 0xE2,
+	0x73, 0x63, 0xA0, 0xE8,
 
-0x61, 0x41, 0xE0, 0xEC,
-0x31, 0x00,
-0x39, 0x00,
+	0x61, 0x41, 0xE0, 0xEC,
+	0x31, 0x00,
+	0x39, 0x00,
 
-0x7D, 0x80, 0x15, 0xEA,
-0x10, 0x04,
-0x20, 0x04,
+	0x7D, 0x80, 0x15, 0xEA,
+	0x10, 0x04,
+	0x20, 0x04,
 
-0x61, 0x51, 0xE0, 0xEC,
-0x2F, 0x41, 0x60, 0xEA,
+	0x61, 0x51, 0xE0, 0xEC,
+	0x2F, 0x41, 0x60, 0xEA,
 
-0x31, 0x20,
-0x39, 0x20,
-0x1F, 0x42, 0xA0, 0xE8,
+	0x31, 0x20,
+	0x39, 0x20,
+	0x1F, 0x42, 0xA0, 0xE8,
 
-0x2A, 0x42, 0x52, 0xBF,
-0x0F, 0x52, 0xA0, 0xE8,
+	0x2A, 0x42, 0x52, 0xBF,
+	0x0F, 0x52, 0xA0, 0xE8,
 
-0x1A, 0x42, 0x62, 0xBF,
-0x1E, 0x51, 0x60, 0xEA,
+	0x1A, 0x42, 0x62, 0xBF,
+	0x1E, 0x51, 0x60, 0xEA,
 
-0x73, 0x7B, 0xC8, 0xEC,
-0x0E, 0x61, 0x60, 0xEA,
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x0E, 0x61, 0x60, 0xEA,
 
-0x32, 0x40, 0x50, 0xBD,
-0x22, 0x40, 0x60, 0xBD,
+	0x32, 0x40, 0x50, 0xBD,
+	0x22, 0x40, 0x60, 0xBD,
 
-0x12, 0x41, 0x51, 0xBD,
-0x3A, 0x41, 0x61, 0xBD,
+	0x12, 0x41, 0x51, 0xBD,
+	0x3A, 0x41, 0x61, 0xBD,
 
-0xBF, 0x2F, 0x0E, 0xBD,
-0x97, 0xE2,
-0x7B, 0x72,
+	0xBF, 0x2F, 0x0E, 0xBD,
+	0x97, 0xE2,
+	0x7B, 0x72,
 
-0x32, 0x20,
-0x22, 0x20,
-0x12, 0x20,
-0x3A, 0x20,
+	0x32, 0x20,
+	0x22, 0x20,
+	0x12, 0x20,
+	0x3A, 0x20,
 
-0x35, 0x48, 0xB1, 0xE8,
-0x3D, 0x59, 0xB1, 0xE8,
+	0x35, 0x48, 0xB1, 0xE8,
+	0x3D, 0x59, 0xB1, 0xE8,
 
-0x46, 0x31, 0x46, 0xBF,
-0x56, 0x31, 0x56, 0xBF,
+	0x46, 0x31, 0x46, 0xBF,
+	0x56, 0x31, 0x56, 0xBF,
 
-0xB3, 0xE2, 0x2D, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0xB3, 0xE2, 0x2D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x66, 0x31, 0x66, 0xBF,
-0x47, 0x39, 0x47, 0xBF,
+	0x66, 0x31, 0x66, 0xBF,
+	0x47, 0x39, 0x47, 0xBF,
 
-0x57, 0x39, 0x57, 0xBF,
-0x67, 0x39, 0x67, 0xBF,
+	0x57, 0x39, 0x57, 0xBF,
+	0x67, 0x39, 0x67, 0xBF,
 
-0x6E, 0x80, 0x07, 0xEA,
-0x24, 0x41, 0x20, 0xE9,
+	0x6E, 0x80, 0x07, 0xEA,
+	0x24, 0x41, 0x20, 0xE9,
 
-0x35, 0x00,
-0x3D, 0x00,
-0x00, 0xE0,
-0x2D, 0x73,
+	0x35, 0x00,
+	0x3D, 0x00,
+	0x00, 0xE0,
+	0x2D, 0x73,
 
-0x33, 0x72,
-0x0C, 0xE3,
-0x8D, 0x2F, 0x1E, 0xBD,
+	0x33, 0x72,
+	0x0C, 0xE3,
+	0x8D, 0x2F, 0x1E, 0xBD,
 
-0x43, 0x75, 0xF8, 0xEC,
-0x35, 0x20,
-0x3D, 0x20,
+	0x43, 0x75, 0xF8, 0xEC,
+	0x35, 0x20,
+	0x3D, 0x20,
 
-0x43, 0x43, 0x2D, 0xDF,
-0x53, 0x53, 0x2D, 0xDF,
+	0x43, 0x43, 0x2D, 0xDF,
+	0x53, 0x53, 0x2D, 0xDF,
 
-0xAE, 0x1E, 0x0E, 0xBD,
-0x58, 0xE3,
-0x33, 0x66,
+	0xAE, 0x1E, 0x0E, 0xBD,
+	0x58, 0xE3,
+	0x33, 0x66,
 
-0x48, 0x35, 0x48, 0xBF,
-0x58, 0x35, 0x58, 0xBF,
+	0x48, 0x35, 0x48, 0xBF,
+	0x58, 0x35, 0x58, 0xBF,
 
-0x68, 0x35, 0x68, 0xBF,
-0x49, 0x3D, 0x49, 0xBF,
+	0x68, 0x35, 0x68, 0xBF,
+	0x49, 0x3D, 0x49, 0xBF,
 
-0x59, 0x3D, 0x59, 0xBF,
-0x69, 0x3D, 0x69, 0xBF,
+	0x59, 0x3D, 0x59, 0xBF,
+	0x69, 0x3D, 0x69, 0xBF,
 
-0x63, 0x63, 0x2D, 0xDF,
-0x4D, 0x7D, 0xF8, 0xEC,
+	0x63, 0x63, 0x2D, 0xDF,
+	0x4D, 0x7D, 0xF8, 0xEC,
 
-0x59, 0xE3,
-0x00, 0xE0,
-0xB8, 0x38, 0x33, 0xBF,
+	0x59, 0xE3,
+	0x00, 0xE0,
+	0xB8, 0x38, 0x33, 0xBF,
 
-0x2D, 0x73,
-0x30, 0x76,
-0x18, 0x3A, 0x41, 0xE9,
+	0x2D, 0x73,
+	0x30, 0x76,
+	0x18, 0x3A, 0x41, 0xE9,
 
-0x3F, 0x53, 0xA0, 0xE8,
-0x05, 0x80, 0x3D, 0xEA,
+	0x3F, 0x53, 0xA0, 0xE8,
+	0x05, 0x80, 0x3D, 0xEA,
 
-0x37, 0x43, 0xA0, 0xE8,
-0x3D, 0x63, 0xA0, 0xE8,
+	0x37, 0x43, 0xA0, 0xE8,
+	0x3D, 0x63, 0xA0, 0xE8,
 
-0x50, 0x70, 0xF8, 0xEC,
-0x2B, 0x50, 0x3C, 0xE9,
+	0x50, 0x70, 0xF8, 0xEC,
+	0x2B, 0x50, 0x3C, 0xE9,
 
-0x1F, 0x0F, 0xBC, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x1F, 0x0F, 0xBC, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x59, 0x78, 0xF8, 0xEC,
-0x00, 0x80, 0x00, 0xE8,
+	0x59, 0x78, 0xF8, 0xEC,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x15, 0xC0, 0x20, 0xE9,
-0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
 
-0x15, 0xC0, 0x20, 0xE9,
-0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
 
-0x1E, 0x12, 0x41, 0xE9,
-0x1A, 0x22, 0x41, 0xE9,
+	0x1E, 0x12, 0x41, 0xE9,
+	0x1A, 0x22, 0x41, 0xE9,
 
-0x46, 0x37, 0x46, 0xDF,
-0x56, 0x3F, 0x56, 0xDF,
+	0x46, 0x37, 0x46, 0xDF,
+	0x56, 0x3F, 0x56, 0xDF,
 
-0x2B, 0x40, 0x3D, 0xE9,
-0x66, 0x3D, 0x66, 0xDF,
+	0x2B, 0x40, 0x3D, 0xE9,
+	0x66, 0x3D, 0x66, 0xDF,
 
-0x1D, 0x32, 0x41, 0xE9,
-0x67, 0x3D, 0x67, 0xDF,
+	0x1D, 0x32, 0x41, 0xE9,
+	0x67, 0x3D, 0x67, 0xDF,
 
-0x47, 0x37, 0x47, 0xDF,
-0x57, 0x3F, 0x57, 0xDF,
+	0x47, 0x37, 0x47, 0xDF,
+	0x57, 0x3F, 0x57, 0xDF,
 
-0x2A, 0x40, 0x20, 0xE9,
-0x59, 0x3F, 0x59, 0xDF,
+	0x2A, 0x40, 0x20, 0xE9,
+	0x59, 0x3F, 0x59, 0xDF,
 
-0x16, 0x30, 0x20, 0xE9,
-0x69, 0x3D, 0x69, 0xDF,
+	0x16, 0x30, 0x20, 0xE9,
+	0x69, 0x3D, 0x69, 0xDF,
 
-0x48, 0x37, 0x48, 0xDF,
-0x58, 0x3F, 0x58, 0xDF,
+	0x48, 0x37, 0x48, 0xDF,
+	0x58, 0x3F, 0x58, 0xDF,
 
-0x12, 0x12, 0x2D, 0xDF,
-0x22, 0x22, 0x2D, 0xDF,
+	0x12, 0x12, 0x2D, 0xDF,
+	0x22, 0x22, 0x2D, 0xDF,
 
-0x32, 0x32, 0x2D, 0xDF,
-0x3A, 0x3A, 0x2D, 0xDF,
+	0x32, 0x32, 0x2D, 0xDF,
+	0x3A, 0x3A, 0x2D, 0xDF,
 
-0x68, 0x3D, 0x68, 0xDF,
-0x49, 0x37, 0x49, 0xDF,
+	0x68, 0x3D, 0x68, 0xDF,
+	0x49, 0x37, 0x49, 0xDF,
 
-0x3D, 0xCF, 0x74, 0xC0,
-0x37, 0xCF, 0x74, 0xC4,
+	0x3D, 0xCF, 0x74, 0xC0,
+	0x37, 0xCF, 0x74, 0xC4,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x34, 0x80, 0x20, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x34, 0x80, 0x20, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x88, 0x73, 0x5E, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0x88, 0x73, 0x5E, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x0F, 0xCF, 0x75, 0xC6,
-0x3C, 0x3D, 0x20, 0xE9,
+	0x0F, 0xCF, 0x75, 0xC6,
+	0x3C, 0x3D, 0x20, 0xE9,
 
-0x0A, 0x44, 0x54, 0xB0,
-0x02, 0x44, 0x64, 0xB0,
+	0x0A, 0x44, 0x54, 0xB0,
+	0x02, 0x44, 0x64, 0xB0,
 
-0x2A, 0x44, 0x54, 0xB2,
-0x1A, 0x44, 0x64, 0xB2,
+	0x2A, 0x44, 0x54, 0xB2,
+	0x1A, 0x44, 0x64, 0xB2,
 
-0x28, 0x80, 0x3A, 0xEA,
-0x0A, 0x20,
-0x02, 0x20,
+	0x28, 0x80, 0x3A, 0xEA,
+	0x0A, 0x20,
+	0x02, 0x20,
 
-0x3D, 0xCF, 0x74, 0xC2,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x3D, 0xCF, 0x74, 0xC2,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x32, 0x31, 0x5F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x32, 0x31, 0x5F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x33, 0x39, 0x5F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x33, 0x39, 0x5F, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x31, 0x0F, 0x20, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x31, 0x0F, 0x20, 0xE9,
 
-0x0A, 0x44, 0x54, 0xB4,
-0x02, 0x44, 0x64, 0xB4,
+	0x0A, 0x44, 0x54, 0xB4,
+	0x02, 0x44, 0x64, 0xB4,
 
-0x2A, 0x45, 0x55, 0xB6,
-0x1A, 0x45, 0x65, 0xB6,
+	0x2A, 0x45, 0x55, 0xB6,
+	0x1A, 0x45, 0x65, 0xB6,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x38, 0x3D, 0x20, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x38, 0x3D, 0x20, 0xE9,
 
-0x0A, 0x20,
-0x02, 0x20,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x0A, 0x20,
+	0x02, 0x20,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0x0A, 0x47, 0x57, 0xBF,
-0x02, 0x47, 0x67, 0xBF,
+	0x0A, 0x47, 0x57, 0xBF,
+	0x02, 0x47, 0x67, 0xBF,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x3E, 0x30, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x3E, 0x30, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x3F, 0x38, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x3F, 0x38, 0x4F, 0xE9,
 
-0x2A, 0x46, 0x56, 0xBF,
-0x1A, 0x46, 0x66, 0xBF,
+	0x2A, 0x46, 0x56, 0xBF,
+	0x1A, 0x46, 0x66, 0xBF,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x3A, 0x31, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x3A, 0x31, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x3B, 0x39, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3B, 0x39, 0x4F, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x36, 0x30, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x36, 0x30, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x37, 0x38, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x37, 0x38, 0x4F, 0xE9,
 
-0x2A, 0x43, 0x53, 0xBF,
-0x1A, 0x43, 0x63, 0xBF,
+	0x2A, 0x43, 0x53, 0xBF,
+	0x1A, 0x43, 0x63, 0xBF,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x35, 0x31, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x35, 0x31, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x39, 0x39, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x39, 0x39, 0x4F, 0xE9,
 
-0x0A, 0x48, 0x58, 0xBF,
-0x02, 0x48, 0x68, 0xBF,
+	0x0A, 0x48, 0x58, 0xBF,
+	0x02, 0x48, 0x68, 0xBF,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x80, 0x31, 0x57, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x80, 0x31, 0x57, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x81, 0x39, 0x57, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x81, 0x39, 0x57, 0xE9,
 
-0x2A, 0x49, 0x59, 0xBF,
-0x1A, 0x49, 0x69, 0xBF,
+	0x2A, 0x49, 0x59, 0xBF,
+	0x1A, 0x49, 0x69, 0xBF,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x82, 0x30, 0x57, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x82, 0x30, 0x57, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x83, 0x38, 0x57, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x83, 0x38, 0x57, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x84, 0x31, 0x5E, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x84, 0x31, 0x5E, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x85, 0x39, 0x5E, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x85, 0x39, 0x5E, 0xE9,
 
-0x86, 0x76, 0x57, 0xE9,
-0x8A, 0x36, 0x20, 0xE9,
+	0x86, 0x76, 0x57, 0xE9,
+	0x8A, 0x36, 0x20, 0xE9,
 
-0x87, 0x77, 0x57, 0xE9,
-0x8B, 0x3E, 0xBF, 0xEA,
+	0x87, 0x77, 0x57, 0xE9,
+	0x8B, 0x3E, 0xBF, 0xEA,
 
-0x80, 0x30, 0x57, 0xE9,
-0x81, 0x38, 0x57, 0xE9,
+	0x80, 0x30, 0x57, 0xE9,
+	0x81, 0x38, 0x57, 0xE9,
 
-0x82, 0x31, 0x57, 0xE9,
-0x86, 0x78, 0x57, 0xE9,
+	0x82, 0x31, 0x57, 0xE9,
+	0x86, 0x78, 0x57, 0xE9,
 
-0x83, 0x39, 0x57, 0xE9,
-0x87, 0x79, 0x57, 0xE9,
+	0x83, 0x39, 0x57, 0xE9,
+	0x87, 0x79, 0x57, 0xE9,
 
-0x30, 0x1F, 0x5F, 0xE9,
-0x8A, 0x34, 0x20, 0xE9,
+	0x30, 0x1F, 0x5F, 0xE9,
+	0x8A, 0x34, 0x20, 0xE9,
 
-0x8B, 0x3C, 0x20, 0xE9,
-0x37, 0x50, 0x60, 0xBD,
+	0x8B, 0x3C, 0x20, 0xE9,
+	0x37, 0x50, 0x60, 0xBD,
 
-0x57, 0x0D, 0x20, 0xE9,
-0x35, 0x51, 0x61, 0xBD,
+	0x57, 0x0D, 0x20, 0xE9,
+	0x35, 0x51, 0x61, 0xBD,
 
-0x2B, 0x50, 0x20, 0xE9,
-0x1D, 0x37, 0xE1, 0xEA,
+	0x2B, 0x50, 0x20, 0xE9,
+	0x1D, 0x37, 0xE1, 0xEA,
 
-0x1E, 0x35, 0xE1, 0xEA,
-0x00, 0xE0,
-0x0E, 0x77,
+	0x1E, 0x35, 0xE1, 0xEA,
+	0x00, 0xE0,
+	0x0E, 0x77,
 
-0x24, 0x51, 0x20, 0xE9,
-0x9A, 0xFF, 0x20, 0xEA,
+	0x24, 0x51, 0x20, 0xE9,
+	0x9A, 0xFF, 0x20, 0xEA,
 
-0x16, 0x0E, 0x20, 0xE9,
-0x57, 0x2E, 0xBF, 0xEA,
+	0x16, 0x0E, 0x20, 0xE9,
+	0x57, 0x2E, 0xBF, 0xEA,
 
-0x0B, 0x46, 0xA0, 0xE8,
-0x1B, 0x56, 0xA0, 0xE8,
+	0x0B, 0x46, 0xA0, 0xE8,
+	0x1B, 0x56, 0xA0, 0xE8,
 
-0x2B, 0x66, 0xA0, 0xE8,
-0x0C, 0x47, 0xA0, 0xE8,
+	0x2B, 0x66, 0xA0, 0xE8,
+	0x0C, 0x47, 0xA0, 0xE8,
 
-0x1C, 0x57, 0xA0, 0xE8,
-0x2C, 0x67, 0xA0, 0xE8,
+	0x1C, 0x57, 0xA0, 0xE8,
+	0x2C, 0x67, 0xA0, 0xE8,
 
-0x0B, 0x00,
-0x1B, 0x00,
-0x2B, 0x00,
-0x00, 0xE0,
+	0x0B, 0x00,
+	0x1B, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
 
-0x0C, 0x00,
-0x1C, 0x00,
-0x2C, 0x00,
-0x00, 0xE0,
+	0x0C, 0x00,
+	0x1C, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
 
-0x0B, 0x65,
-0x1B, 0x65,
-0x2B, 0x65,
-0x00, 0xE0,
+	0x0B, 0x65,
+	0x1B, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
 
-0x0C, 0x65,
-0x1C, 0x65,
-0x2C, 0x65,
-0x00, 0xE0,
+	0x0C, 0x65,
+	0x1C, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
 
-0x0B, 0x1B, 0x60, 0xEC,
-0x36, 0xD7, 0x36, 0xAD,
+	0x0B, 0x1B, 0x60, 0xEC,
+	0x36, 0xD7, 0x36, 0xAD,
 
-0x2B, 0x80, 0x60, 0xEC,
-0x0C, 0x1C, 0x60, 0xEC,
+	0x2B, 0x80, 0x60, 0xEC,
+	0x0C, 0x1C, 0x60, 0xEC,
 
-0x3E, 0xD7, 0x3E, 0xAD,
-0x2C, 0x80, 0x60, 0xEC,
+	0x3E, 0xD7, 0x3E, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
 
-0x0B, 0x2B, 0xDE, 0xE8,
-0x1B, 0x80, 0xDE, 0xE8,
+	0x0B, 0x2B, 0xDE, 0xE8,
+	0x1B, 0x80, 0xDE, 0xE8,
 
-0x36, 0x80, 0x36, 0xBD,
-0x3E, 0x80, 0x3E, 0xBD,
+	0x36, 0x80, 0x36, 0xBD,
+	0x3E, 0x80, 0x3E, 0xBD,
 
-0x33, 0xD7, 0x0B, 0xBD,
-0x3B, 0xD7, 0x1B, 0xBD,
+	0x33, 0xD7, 0x0B, 0xBD,
+	0x3B, 0xD7, 0x1B, 0xBD,
 
-0x46, 0x80, 0x46, 0xCF,
-0x57, 0x80, 0x57, 0xCF,
+	0x46, 0x80, 0x46, 0xCF,
+	0x57, 0x80, 0x57, 0xCF,
 
-0x66, 0x33, 0x66, 0xCF,
-0x47, 0x3B, 0x47, 0xCF,
+	0x66, 0x33, 0x66, 0xCF,
+	0x47, 0x3B, 0x47, 0xCF,
 
-0x56, 0x33, 0x56, 0xCF,
-0x67, 0x3B, 0x67, 0xCF,
+	0x56, 0x33, 0x56, 0xCF,
+	0x67, 0x3B, 0x67, 0xCF,
 
-0x0B, 0x48, 0xA0, 0xE8,
-0x1B, 0x58, 0xA0, 0xE8,
+	0x0B, 0x48, 0xA0, 0xE8,
+	0x1B, 0x58, 0xA0, 0xE8,
 
-0x2B, 0x68, 0xA0, 0xE8,
-0x0C, 0x49, 0xA0, 0xE8,
+	0x2B, 0x68, 0xA0, 0xE8,
+	0x0C, 0x49, 0xA0, 0xE8,
 
-0x1C, 0x59, 0xA0, 0xE8,
-0x2C, 0x69, 0xA0, 0xE8,
+	0x1C, 0x59, 0xA0, 0xE8,
+	0x2C, 0x69, 0xA0, 0xE8,
 
-0x0B, 0x00,
-0x1B, 0x00,
-0x2B, 0x00,
-0x00, 0xE0,
+	0x0B, 0x00,
+	0x1B, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
 
-0x0C, 0x00,
-0x1C, 0x00,
-0x2C, 0x00,
-0x00, 0xE0,
+	0x0C, 0x00,
+	0x1C, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
 
-0x0B, 0x65,
-0x1B, 0x65,
-0x2B, 0x65,
-0x00, 0xE0,
+	0x0B, 0x65,
+	0x1B, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
 
-0x0C, 0x65,
-0x1C, 0x65,
-0x2C, 0x65,
-0x00, 0xE0,
+	0x0C, 0x65,
+	0x1C, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
 
-0x0B, 0x1B, 0x60, 0xEC,
-0x34, 0xD7, 0x34, 0xAD,
+	0x0B, 0x1B, 0x60, 0xEC,
+	0x34, 0xD7, 0x34, 0xAD,
 
-0x2B, 0x80, 0x60, 0xEC,
-0x0C, 0x1C, 0x60, 0xEC,
+	0x2B, 0x80, 0x60, 0xEC,
+	0x0C, 0x1C, 0x60, 0xEC,
 
-0x3C, 0xD7, 0x3C, 0xAD,
-0x2C, 0x80, 0x60, 0xEC,
+	0x3C, 0xD7, 0x3C, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
 
-0x0B, 0x2B, 0xDE, 0xE8,
-0x1B, 0x80, 0xDE, 0xE8,
+	0x0B, 0x2B, 0xDE, 0xE8,
+	0x1B, 0x80, 0xDE, 0xE8,
 
-0x34, 0x80, 0x34, 0xBD,
-0x3C, 0x80, 0x3C, 0xBD,
+	0x34, 0x80, 0x34, 0xBD,
+	0x3C, 0x80, 0x3C, 0xBD,
 
-0x33, 0xD7, 0x0B, 0xBD,
-0x3B, 0xD7, 0x1B, 0xBD,
+	0x33, 0xD7, 0x0B, 0xBD,
+	0x3B, 0xD7, 0x1B, 0xBD,
 
-0x48, 0x80, 0x48, 0xCF,
-0x59, 0x80, 0x59, 0xCF,
+	0x48, 0x80, 0x48, 0xCF,
+	0x59, 0x80, 0x59, 0xCF,
 
-0x68, 0x33, 0x68, 0xCF,
-0x49, 0x3B, 0x49, 0xCF,
+	0x68, 0x33, 0x68, 0xCF,
+	0x49, 0x3B, 0x49, 0xCF,
 
-0xBB, 0xFF, 0x20, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0xBB, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x58, 0x33, 0x58, 0xCF,
-0x69, 0x3B, 0x69, 0xCF,
+	0x58, 0x33, 0x58, 0xCF,
+	0x69, 0x3B, 0x69, 0xCF,
 
-0x78, 0xFF, 0x20, 0xEA,
-0x57, 0xC0, 0xBF, 0xEA,
+	0x78, 0xFF, 0x20, 0xEA,
+	0x57, 0xC0, 0xBF, 0xEA,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x00, 0x00, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
 
 };
 
 static unsigned char warp_g400_t2gzs[] = {
 
-0x00, 0x8A, 0x98, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x8A, 0x98, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x00, 0x00, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
 
-0xFF, 0x80, 0xC0, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x0A, 0x40, 0x50, 0xBF,
-0x2A, 0x40, 0x60, 0xBF,
+	0x0A, 0x40, 0x50, 0xBF,
+	0x2A, 0x40, 0x60, 0xBF,
 
-0x32, 0x41, 0x51, 0xBF,
-0x3A, 0x41, 0x61, 0xBF,
+	0x32, 0x41, 0x51, 0xBF,
+	0x3A, 0x41, 0x61, 0xBF,
 
-0xC3, 0x6B,
-0xD3, 0x6B,
-0x00, 0x8A, 0x98, 0xE9,
+	0xC3, 0x6B,
+	0xD3, 0x6B,
+	0x00, 0x8A, 0x98, 0xE9,
 
-0x73, 0x7B, 0xC8, 0xEC,
-0x96, 0xE2,
-0x41, 0x04,
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x96, 0xE2,
+	0x41, 0x04,
 
-0x7B, 0x43, 0xA0, 0xE8,
-0x73, 0x53, 0xA0, 0xE8,
+	0x7B, 0x43, 0xA0, 0xE8,
+	0x73, 0x53, 0xA0, 0xE8,
 
-0xAD, 0xEE, 0x23, 0x9F,
-0x00, 0xE0,
-0x51, 0x04,
+	0xAD, 0xEE, 0x23, 0x9F,
+	0x00, 0xE0,
+	0x51, 0x04,
 
-0x90, 0xE2,
-0x61, 0x04,
-0x31, 0x46, 0xB1, 0xE8,
+	0x90, 0xE2,
+	0x61, 0x04,
+	0x31, 0x46, 0xB1, 0xE8,
 
-0x51, 0x41, 0xE0, 0xEC,
-0x39, 0x67, 0xB1, 0xE8,
+	0x51, 0x41, 0xE0, 0xEC,
+	0x39, 0x67, 0xB1, 0xE8,
 
-0x00, 0x04,
-0x46, 0xE2,
-0x73, 0x63, 0xA0, 0xE8,
+	0x00, 0x04,
+	0x46, 0xE2,
+	0x73, 0x63, 0xA0, 0xE8,
 
-0x61, 0x41, 0xE0, 0xEC,
-0x31, 0x00,
-0x39, 0x00,
+	0x61, 0x41, 0xE0, 0xEC,
+	0x31, 0x00,
+	0x39, 0x00,
 
-0x85, 0x80, 0x15, 0xEA,
-0x10, 0x04,
-0x20, 0x04,
+	0x85, 0x80, 0x15, 0xEA,
+	0x10, 0x04,
+	0x20, 0x04,
 
-0x61, 0x51, 0xE0, 0xEC,
-0x2F, 0x41, 0x60, 0xEA,
+	0x61, 0x51, 0xE0, 0xEC,
+	0x2F, 0x41, 0x60, 0xEA,
 
-0x31, 0x20,
-0x39, 0x20,
-0x1F, 0x42, 0xA0, 0xE8,
+	0x31, 0x20,
+	0x39, 0x20,
+	0x1F, 0x42, 0xA0, 0xE8,
 
-0x2A, 0x42, 0x52, 0xBF,
-0x0F, 0x52, 0xA0, 0xE8,
+	0x2A, 0x42, 0x52, 0xBF,
+	0x0F, 0x52, 0xA0, 0xE8,
 
-0x1A, 0x42, 0x62, 0xBF,
-0x1E, 0x51, 0x60, 0xEA,
+	0x1A, 0x42, 0x62, 0xBF,
+	0x1E, 0x51, 0x60, 0xEA,
 
-0x73, 0x7B, 0xC8, 0xEC,
-0x0E, 0x61, 0x60, 0xEA,
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x0E, 0x61, 0x60, 0xEA,
 
-0x32, 0x40, 0x50, 0xBD,
-0x22, 0x40, 0x60, 0xBD,
+	0x32, 0x40, 0x50, 0xBD,
+	0x22, 0x40, 0x60, 0xBD,
 
-0x12, 0x41, 0x51, 0xBD,
-0x3A, 0x41, 0x61, 0xBD,
+	0x12, 0x41, 0x51, 0xBD,
+	0x3A, 0x41, 0x61, 0xBD,
 
-0xBF, 0x2F, 0x0E, 0xBD,
-0x97, 0xE2,
-0x7B, 0x72,
+	0xBF, 0x2F, 0x0E, 0xBD,
+	0x97, 0xE2,
+	0x7B, 0x72,
 
-0x32, 0x20,
-0x22, 0x20,
-0x12, 0x20,
-0x3A, 0x20,
+	0x32, 0x20,
+	0x22, 0x20,
+	0x12, 0x20,
+	0x3A, 0x20,
 
-0x35, 0x48, 0xB1, 0xE8,
-0x3D, 0x59, 0xB1, 0xE8,
+	0x35, 0x48, 0xB1, 0xE8,
+	0x3D, 0x59, 0xB1, 0xE8,
 
-0x46, 0x31, 0x46, 0xBF,
-0x56, 0x31, 0x56, 0xBF,
+	0x46, 0x31, 0x46, 0xBF,
+	0x56, 0x31, 0x56, 0xBF,
 
-0xB3, 0xE2, 0x2D, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0xB3, 0xE2, 0x2D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x66, 0x31, 0x66, 0xBF,
-0x47, 0x39, 0x47, 0xBF,
+	0x66, 0x31, 0x66, 0xBF,
+	0x47, 0x39, 0x47, 0xBF,
 
-0x57, 0x39, 0x57, 0xBF,
-0x67, 0x39, 0x67, 0xBF,
+	0x57, 0x39, 0x57, 0xBF,
+	0x67, 0x39, 0x67, 0xBF,
 
-0x76, 0x80, 0x07, 0xEA,
-0x24, 0x41, 0x20, 0xE9,
+	0x76, 0x80, 0x07, 0xEA,
+	0x24, 0x41, 0x20, 0xE9,
 
-0x35, 0x00,
-0x3D, 0x00,
-0x00, 0xE0,
-0x2D, 0x73,
+	0x35, 0x00,
+	0x3D, 0x00,
+	0x00, 0xE0,
+	0x2D, 0x73,
 
-0x33, 0x72,
-0x0C, 0xE3,
-0x8D, 0x2F, 0x1E, 0xBD,
+	0x33, 0x72,
+	0x0C, 0xE3,
+	0x8D, 0x2F, 0x1E, 0xBD,
 
-0x43, 0x75, 0xF8, 0xEC,
-0x35, 0x20,
-0x3D, 0x20,
+	0x43, 0x75, 0xF8, 0xEC,
+	0x35, 0x20,
+	0x3D, 0x20,
 
-0x43, 0x43, 0x2D, 0xDF,
-0x53, 0x53, 0x2D, 0xDF,
+	0x43, 0x43, 0x2D, 0xDF,
+	0x53, 0x53, 0x2D, 0xDF,
 
-0xAE, 0x1E, 0x0E, 0xBD,
-0x58, 0xE3,
-0x33, 0x66,
+	0xAE, 0x1E, 0x0E, 0xBD,
+	0x58, 0xE3,
+	0x33, 0x66,
 
-0x48, 0x35, 0x48, 0xBF,
-0x58, 0x35, 0x58, 0xBF,
+	0x48, 0x35, 0x48, 0xBF,
+	0x58, 0x35, 0x58, 0xBF,
 
-0x68, 0x35, 0x68, 0xBF,
-0x49, 0x3D, 0x49, 0xBF,
+	0x68, 0x35, 0x68, 0xBF,
+	0x49, 0x3D, 0x49, 0xBF,
 
-0x59, 0x3D, 0x59, 0xBF,
-0x69, 0x3D, 0x69, 0xBF,
+	0x59, 0x3D, 0x59, 0xBF,
+	0x69, 0x3D, 0x69, 0xBF,
 
-0x63, 0x63, 0x2D, 0xDF,
-0x4D, 0x7D, 0xF8, 0xEC,
+	0x63, 0x63, 0x2D, 0xDF,
+	0x4D, 0x7D, 0xF8, 0xEC,
 
-0x59, 0xE3,
-0x00, 0xE0,
-0xB8, 0x38, 0x33, 0xBF,
+	0x59, 0xE3,
+	0x00, 0xE0,
+	0xB8, 0x38, 0x33, 0xBF,
 
-0x2D, 0x73,
-0x30, 0x76,
-0x18, 0x3A, 0x41, 0xE9,
+	0x2D, 0x73,
+	0x30, 0x76,
+	0x18, 0x3A, 0x41, 0xE9,
 
-0x3F, 0x53, 0xA0, 0xE8,
-0x05, 0x80, 0x3D, 0xEA,
+	0x3F, 0x53, 0xA0, 0xE8,
+	0x05, 0x80, 0x3D, 0xEA,
 
-0x37, 0x43, 0xA0, 0xE8,
-0x3D, 0x63, 0xA0, 0xE8,
+	0x37, 0x43, 0xA0, 0xE8,
+	0x3D, 0x63, 0xA0, 0xE8,
 
-0x50, 0x70, 0xF8, 0xEC,
-0x2B, 0x50, 0x3C, 0xE9,
+	0x50, 0x70, 0xF8, 0xEC,
+	0x2B, 0x50, 0x3C, 0xE9,
 
-0x1F, 0x0F, 0xBC, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x1F, 0x0F, 0xBC, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x59, 0x78, 0xF8, 0xEC,
-0x00, 0x80, 0x00, 0xE8,
+	0x59, 0x78, 0xF8, 0xEC,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x15, 0xC0, 0x20, 0xE9,
-0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
 
-0x15, 0xC0, 0x20, 0xE9,
-0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
 
-0x1E, 0x12, 0x41, 0xE9,
-0x1A, 0x22, 0x41, 0xE9,
+	0x1E, 0x12, 0x41, 0xE9,
+	0x1A, 0x22, 0x41, 0xE9,
 
-0x46, 0x37, 0x46, 0xDF,
-0x56, 0x3F, 0x56, 0xDF,
+	0x46, 0x37, 0x46, 0xDF,
+	0x56, 0x3F, 0x56, 0xDF,
 
-0x2B, 0x40, 0x3D, 0xE9,
-0x66, 0x3D, 0x66, 0xDF,
+	0x2B, 0x40, 0x3D, 0xE9,
+	0x66, 0x3D, 0x66, 0xDF,
 
-0x1D, 0x32, 0x41, 0xE9,
-0x67, 0x3D, 0x67, 0xDF,
+	0x1D, 0x32, 0x41, 0xE9,
+	0x67, 0x3D, 0x67, 0xDF,
 
-0x47, 0x37, 0x47, 0xDF,
-0x57, 0x3F, 0x57, 0xDF,
+	0x47, 0x37, 0x47, 0xDF,
+	0x57, 0x3F, 0x57, 0xDF,
 
-0x2A, 0x40, 0x20, 0xE9,
-0x59, 0x3F, 0x59, 0xDF,
+	0x2A, 0x40, 0x20, 0xE9,
+	0x59, 0x3F, 0x59, 0xDF,
 
-0x16, 0x30, 0x20, 0xE9,
-0x69, 0x3D, 0x69, 0xDF,
+	0x16, 0x30, 0x20, 0xE9,
+	0x69, 0x3D, 0x69, 0xDF,
 
-0x48, 0x37, 0x48, 0xDF,
-0x58, 0x3F, 0x58, 0xDF,
+	0x48, 0x37, 0x48, 0xDF,
+	0x58, 0x3F, 0x58, 0xDF,
 
-0x68, 0x3D, 0x68, 0xDF,
-0x49, 0x37, 0x49, 0xDF,
+	0x68, 0x3D, 0x68, 0xDF,
+	0x49, 0x37, 0x49, 0xDF,
 
-0x32, 0x32, 0x2D, 0xDF,
-0x22, 0x22, 0x2D, 0xDF,
+	0x32, 0x32, 0x2D, 0xDF,
+	0x22, 0x22, 0x2D, 0xDF,
 
-0x12, 0x12, 0x2D, 0xDF,
-0x3A, 0x3A, 0x2D, 0xDF,
+	0x12, 0x12, 0x2D, 0xDF,
+	0x3A, 0x3A, 0x2D, 0xDF,
 
-0x0F, 0xCF, 0x74, 0xC2,
-0x37, 0xCF, 0x74, 0xC4,
+	0x0F, 0xCF, 0x74, 0xC2,
+	0x37, 0xCF, 0x74, 0xC4,
 
-0x0A, 0x44, 0x54, 0xB0,
-0x02, 0x44, 0x64, 0xB0,
+	0x0A, 0x44, 0x54, 0xB0,
+	0x02, 0x44, 0x64, 0xB0,
 
-0x3D, 0xCF, 0x74, 0xC0,
-0x34, 0x37, 0x20, 0xE9,
+	0x3D, 0xCF, 0x74, 0xC0,
+	0x34, 0x37, 0x20, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x38, 0x0F, 0x20, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x38, 0x0F, 0x20, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x3C, 0x3D, 0x20, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3C, 0x3D, 0x20, 0xE9,
 
-0x2A, 0x44, 0x54, 0xB2,
-0x1A, 0x44, 0x64, 0xB2,
+	0x2A, 0x44, 0x54, 0xB2,
+	0x1A, 0x44, 0x64, 0xB2,
 
-0x31, 0x80, 0x3A, 0xEA,
-0x0A, 0x20,
-0x02, 0x20,
+	0x31, 0x80, 0x3A, 0xEA,
+	0x0A, 0x20,
+	0x02, 0x20,
 
-0x0F, 0xCF, 0x75, 0xC0,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x0F, 0xCF, 0x75, 0xC0,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x32, 0x31, 0x5F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x32, 0x31, 0x5F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x33, 0x39, 0x5F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x33, 0x39, 0x5F, 0xE9,
 
-0x3D, 0xCF, 0x75, 0xC2,
-0x37, 0xCF, 0x75, 0xC4,
+	0x3D, 0xCF, 0x75, 0xC2,
+	0x37, 0xCF, 0x75, 0xC4,
 
-0x31, 0x53, 0x2F, 0x9F,
-0xA6, 0x0F, 0x20, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA6, 0x0F, 0x20, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0xA3, 0x3D, 0x20, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA3, 0x3D, 0x20, 0xE9,
 
-0x2A, 0x44, 0x54, 0xB4,
-0x1A, 0x44, 0x64, 0xB4,
+	0x2A, 0x44, 0x54, 0xB4,
+	0x1A, 0x44, 0x64, 0xB4,
 
-0x0A, 0x45, 0x55, 0xB0,
-0x02, 0x45, 0x65, 0xB0,
+	0x0A, 0x45, 0x55, 0xB0,
+	0x02, 0x45, 0x65, 0xB0,
 
-0x88, 0x73, 0x5E, 0xE9,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x88, 0x73, 0x5E, 0xE9,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0xA0, 0x37, 0x20, 0xE9,
-0x0A, 0x20,
-0x02, 0x20,
+	0xA0, 0x37, 0x20, 0xE9,
+	0x0A, 0x20,
+	0x02, 0x20,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x3E, 0x30, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x3E, 0x30, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x3F, 0x38, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3F, 0x38, 0x4F, 0xE9,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x3A, 0x31, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x3A, 0x31, 0x4F, 0xE9,
 
-0x2A, 0x45, 0x55, 0xB2,
-0x1A, 0x45, 0x65, 0xB2,
+	0x2A, 0x45, 0x55, 0xB2,
+	0x1A, 0x45, 0x65, 0xB2,
 
-0x0A, 0x45, 0x55, 0xB4,
-0x02, 0x45, 0x65, 0xB4,
+	0x0A, 0x45, 0x55, 0xB4,
+	0x02, 0x45, 0x65, 0xB4,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x3B, 0x39, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x3B, 0x39, 0x4F, 0xE9,
 
-0x2A, 0x20,
-0x1A, 0x20,
-0x0A, 0x20,
-0x02, 0x20,
+	0x2A, 0x20,
+	0x1A, 0x20,
+	0x0A, 0x20,
+	0x02, 0x20,
 
-0x2A, 0x46, 0x56, 0xBF,
-0x1A, 0x46, 0x66, 0xBF,
+	0x2A, 0x46, 0x56, 0xBF,
+	0x1A, 0x46, 0x66, 0xBF,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x36, 0x31, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x36, 0x31, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x37, 0x39, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x37, 0x39, 0x4F, 0xE9,
 
-0x30, 0x50, 0x2E, 0x9F,
-0xA7, 0x30, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0xA7, 0x30, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0xA8, 0x38, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0xA8, 0x38, 0x4F, 0xE9,
 
-0x0A, 0x47, 0x57, 0xBF,
-0x02, 0x47, 0x67, 0xBF,
+	0x0A, 0x47, 0x57, 0xBF,
+	0x02, 0x47, 0x67, 0xBF,
 
-0x31, 0x53, 0x2F, 0x9F,
-0xA4, 0x31, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA4, 0x31, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0xA5, 0x39, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA5, 0x39, 0x4F, 0xE9,
 
-0x2A, 0x43, 0x53, 0xBF,
-0x1A, 0x43, 0x63, 0xBF,
+	0x2A, 0x43, 0x53, 0xBF,
+	0x1A, 0x43, 0x63, 0xBF,
 
-0x30, 0x50, 0x2E, 0x9F,
-0xA1, 0x30, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0xA1, 0x30, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0xA2, 0x38, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0xA2, 0x38, 0x4F, 0xE9,
 
-0x0A, 0x48, 0x58, 0xBF,
-0x02, 0x48, 0x68, 0xBF,
+	0x0A, 0x48, 0x58, 0xBF,
+	0x02, 0x48, 0x68, 0xBF,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x80, 0x31, 0x57, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x80, 0x31, 0x57, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x81, 0x39, 0x57, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x81, 0x39, 0x57, 0xE9,
 
-0x2A, 0x49, 0x59, 0xBF,
-0x1A, 0x49, 0x69, 0xBF,
+	0x2A, 0x49, 0x59, 0xBF,
+	0x1A, 0x49, 0x69, 0xBF,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x82, 0x30, 0x57, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x82, 0x30, 0x57, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x83, 0x38, 0x57, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x83, 0x38, 0x57, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x84, 0x31, 0x5E, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x84, 0x31, 0x5E, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x85, 0x39, 0x5E, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x85, 0x39, 0x5E, 0xE9,
 
-0x86, 0x76, 0x57, 0xE9,
-0x8A, 0x36, 0x20, 0xE9,
+	0x86, 0x76, 0x57, 0xE9,
+	0x8A, 0x36, 0x20, 0xE9,
 
-0x87, 0x77, 0x57, 0xE9,
-0x8B, 0x3E, 0xBF, 0xEA,
+	0x87, 0x77, 0x57, 0xE9,
+	0x8B, 0x3E, 0xBF, 0xEA,
 
-0x80, 0x30, 0x57, 0xE9,
-0x81, 0x38, 0x57, 0xE9,
+	0x80, 0x30, 0x57, 0xE9,
+	0x81, 0x38, 0x57, 0xE9,
 
-0x82, 0x31, 0x57, 0xE9,
-0x86, 0x78, 0x57, 0xE9,
+	0x82, 0x31, 0x57, 0xE9,
+	0x86, 0x78, 0x57, 0xE9,
 
-0x83, 0x39, 0x57, 0xE9,
-0x87, 0x79, 0x57, 0xE9,
+	0x83, 0x39, 0x57, 0xE9,
+	0x87, 0x79, 0x57, 0xE9,
 
-0x30, 0x1F, 0x5F, 0xE9,
-0x8A, 0x34, 0x20, 0xE9,
+	0x30, 0x1F, 0x5F, 0xE9,
+	0x8A, 0x34, 0x20, 0xE9,
 
-0x8B, 0x3C, 0x20, 0xE9,
-0x37, 0x50, 0x60, 0xBD,
+	0x8B, 0x3C, 0x20, 0xE9,
+	0x37, 0x50, 0x60, 0xBD,
 
-0x57, 0x0D, 0x20, 0xE9,
-0x35, 0x51, 0x61, 0xBD,
+	0x57, 0x0D, 0x20, 0xE9,
+	0x35, 0x51, 0x61, 0xBD,
 
-0x2B, 0x50, 0x20, 0xE9,
-0x1D, 0x37, 0xE1, 0xEA,
+	0x2B, 0x50, 0x20, 0xE9,
+	0x1D, 0x37, 0xE1, 0xEA,
 
-0x1E, 0x35, 0xE1, 0xEA,
-0x00, 0xE0,
-0x0E, 0x77,
+	0x1E, 0x35, 0xE1, 0xEA,
+	0x00, 0xE0,
+	0x0E, 0x77,
 
-0x24, 0x51, 0x20, 0xE9,
-0x92, 0xFF, 0x20, 0xEA,
+	0x24, 0x51, 0x20, 0xE9,
+	0x92, 0xFF, 0x20, 0xEA,
 
-0x16, 0x0E, 0x20, 0xE9,
-0x57, 0x2E, 0xBF, 0xEA,
+	0x16, 0x0E, 0x20, 0xE9,
+	0x57, 0x2E, 0xBF, 0xEA,
 
-0x0B, 0x46, 0xA0, 0xE8,
-0x1B, 0x56, 0xA0, 0xE8,
+	0x0B, 0x46, 0xA0, 0xE8,
+	0x1B, 0x56, 0xA0, 0xE8,
 
-0x2B, 0x66, 0xA0, 0xE8,
-0x0C, 0x47, 0xA0, 0xE8,
+	0x2B, 0x66, 0xA0, 0xE8,
+	0x0C, 0x47, 0xA0, 0xE8,
 
-0x1C, 0x57, 0xA0, 0xE8,
-0x2C, 0x67, 0xA0, 0xE8,
+	0x1C, 0x57, 0xA0, 0xE8,
+	0x2C, 0x67, 0xA0, 0xE8,
 
-0x0B, 0x00,
-0x1B, 0x00,
-0x2B, 0x00,
-0x00, 0xE0,
+	0x0B, 0x00,
+	0x1B, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
 
-0x0C, 0x00,
-0x1C, 0x00,
-0x2C, 0x00,
-0x00, 0xE0,
+	0x0C, 0x00,
+	0x1C, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
 
-0x0B, 0x65,
-0x1B, 0x65,
-0x2B, 0x65,
-0x00, 0xE0,
+	0x0B, 0x65,
+	0x1B, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
 
-0x0C, 0x65,
-0x1C, 0x65,
-0x2C, 0x65,
-0x00, 0xE0,
+	0x0C, 0x65,
+	0x1C, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
 
-0x0B, 0x1B, 0x60, 0xEC,
-0x36, 0xD7, 0x36, 0xAD,
+	0x0B, 0x1B, 0x60, 0xEC,
+	0x36, 0xD7, 0x36, 0xAD,
 
-0x2B, 0x80, 0x60, 0xEC,
-0x0C, 0x1C, 0x60, 0xEC,
+	0x2B, 0x80, 0x60, 0xEC,
+	0x0C, 0x1C, 0x60, 0xEC,
 
-0x3E, 0xD7, 0x3E, 0xAD,
-0x2C, 0x80, 0x60, 0xEC,
+	0x3E, 0xD7, 0x3E, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
 
-0x0B, 0x2B, 0xDE, 0xE8,
-0x1B, 0x80, 0xDE, 0xE8,
+	0x0B, 0x2B, 0xDE, 0xE8,
+	0x1B, 0x80, 0xDE, 0xE8,
 
-0x36, 0x80, 0x36, 0xBD,
-0x3E, 0x80, 0x3E, 0xBD,
+	0x36, 0x80, 0x36, 0xBD,
+	0x3E, 0x80, 0x3E, 0xBD,
 
-0x33, 0xD7, 0x0B, 0xBD,
-0x3B, 0xD7, 0x1B, 0xBD,
+	0x33, 0xD7, 0x0B, 0xBD,
+	0x3B, 0xD7, 0x1B, 0xBD,
 
-0x46, 0x80, 0x46, 0xCF,
-0x57, 0x80, 0x57, 0xCF,
+	0x46, 0x80, 0x46, 0xCF,
+	0x57, 0x80, 0x57, 0xCF,
 
-0x66, 0x33, 0x66, 0xCF,
-0x47, 0x3B, 0x47, 0xCF,
+	0x66, 0x33, 0x66, 0xCF,
+	0x47, 0x3B, 0x47, 0xCF,
 
-0x56, 0x33, 0x56, 0xCF,
-0x67, 0x3B, 0x67, 0xCF,
+	0x56, 0x33, 0x56, 0xCF,
+	0x67, 0x3B, 0x67, 0xCF,
 
-0x0B, 0x48, 0xA0, 0xE8,
-0x1B, 0x58, 0xA0, 0xE8,
+	0x0B, 0x48, 0xA0, 0xE8,
+	0x1B, 0x58, 0xA0, 0xE8,
 
-0x2B, 0x68, 0xA0, 0xE8,
-0x0C, 0x49, 0xA0, 0xE8,
+	0x2B, 0x68, 0xA0, 0xE8,
+	0x0C, 0x49, 0xA0, 0xE8,
 
-0x1C, 0x59, 0xA0, 0xE8,
-0x2C, 0x69, 0xA0, 0xE8,
+	0x1C, 0x59, 0xA0, 0xE8,
+	0x2C, 0x69, 0xA0, 0xE8,
 
-0x0B, 0x00,
-0x1B, 0x00,
-0x2B, 0x00,
-0x00, 0xE0,
+	0x0B, 0x00,
+	0x1B, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
 
-0x0C, 0x00,
-0x1C, 0x00,
-0x2C, 0x00,
-0x00, 0xE0,
+	0x0C, 0x00,
+	0x1C, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
 
-0x0B, 0x65,
-0x1B, 0x65,
-0x2B, 0x65,
-0x00, 0xE0,
+	0x0B, 0x65,
+	0x1B, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
 
-0x0C, 0x65,
-0x1C, 0x65,
-0x2C, 0x65,
-0x00, 0xE0,
+	0x0C, 0x65,
+	0x1C, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
 
-0x0B, 0x1B, 0x60, 0xEC,
-0x34, 0xD7, 0x34, 0xAD,
+	0x0B, 0x1B, 0x60, 0xEC,
+	0x34, 0xD7, 0x34, 0xAD,
 
-0x2B, 0x80, 0x60, 0xEC,
-0x0C, 0x1C, 0x60, 0xEC,
+	0x2B, 0x80, 0x60, 0xEC,
+	0x0C, 0x1C, 0x60, 0xEC,
 
-0x3C, 0xD7, 0x3C, 0xAD,
-0x2C, 0x80, 0x60, 0xEC,
+	0x3C, 0xD7, 0x3C, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
 
-0x0B, 0x2B, 0xDE, 0xE8,
-0x1B, 0x80, 0xDE, 0xE8,
+	0x0B, 0x2B, 0xDE, 0xE8,
+	0x1B, 0x80, 0xDE, 0xE8,
 
-0x34, 0x80, 0x34, 0xBD,
-0x3C, 0x80, 0x3C, 0xBD,
+	0x34, 0x80, 0x34, 0xBD,
+	0x3C, 0x80, 0x3C, 0xBD,
 
-0x33, 0xD7, 0x0B, 0xBD,
-0x3B, 0xD7, 0x1B, 0xBD,
+	0x33, 0xD7, 0x0B, 0xBD,
+	0x3B, 0xD7, 0x1B, 0xBD,
 
-0x48, 0x80, 0x48, 0xCF,
-0x59, 0x80, 0x59, 0xCF,
+	0x48, 0x80, 0x48, 0xCF,
+	0x59, 0x80, 0x59, 0xCF,
 
-0x68, 0x33, 0x68, 0xCF,
-0x49, 0x3B, 0x49, 0xCF,
+	0x68, 0x33, 0x68, 0xCF,
+	0x49, 0x3B, 0x49, 0xCF,
 
-0xB2, 0xFF, 0x20, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0xB2, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x58, 0x33, 0x58, 0xCF,
-0x69, 0x3B, 0x69, 0xCF,
+	0x58, 0x33, 0x58, 0xCF,
+	0x69, 0x3B, 0x69, 0xCF,
 
-0x70, 0xFF, 0x20, 0xEA,
-0x57, 0xC0, 0xBF, 0xEA,
+	0x70, 0xFF, 0x20, 0xEA,
+	0x57, 0xC0, 0xBF, 0xEA,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x00, 0x00, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
 
 };
 
 static unsigned char warp_g400_t2gzsa[] = {
 
-0x00, 0x8A, 0x98, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x8A, 0x98, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x00, 0x00, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
 
-0xFF, 0x80, 0xC0, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x0A, 0x40, 0x50, 0xBF,
-0x2A, 0x40, 0x60, 0xBF,
+	0x0A, 0x40, 0x50, 0xBF,
+	0x2A, 0x40, 0x60, 0xBF,
 
-0x32, 0x41, 0x51, 0xBF,
-0x3A, 0x41, 0x61, 0xBF,
+	0x32, 0x41, 0x51, 0xBF,
+	0x3A, 0x41, 0x61, 0xBF,
 
-0xC3, 0x6B,
-0xD3, 0x6B,
-0x00, 0x8A, 0x98, 0xE9,
+	0xC3, 0x6B,
+	0xD3, 0x6B,
+	0x00, 0x8A, 0x98, 0xE9,
 
-0x73, 0x7B, 0xC8, 0xEC,
-0x96, 0xE2,
-0x41, 0x04,
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x96, 0xE2,
+	0x41, 0x04,
 
-0x7B, 0x43, 0xA0, 0xE8,
-0x73, 0x53, 0xA0, 0xE8,
+	0x7B, 0x43, 0xA0, 0xE8,
+	0x73, 0x53, 0xA0, 0xE8,
 
-0xAD, 0xEE, 0x23, 0x9F,
-0x00, 0xE0,
-0x51, 0x04,
+	0xAD, 0xEE, 0x23, 0x9F,
+	0x00, 0xE0,
+	0x51, 0x04,
 
-0x90, 0xE2,
-0x61, 0x04,
-0x31, 0x46, 0xB1, 0xE8,
+	0x90, 0xE2,
+	0x61, 0x04,
+	0x31, 0x46, 0xB1, 0xE8,
 
-0x51, 0x41, 0xE0, 0xEC,
-0x39, 0x67, 0xB1, 0xE8,
+	0x51, 0x41, 0xE0, 0xEC,
+	0x39, 0x67, 0xB1, 0xE8,
 
-0x00, 0x04,
-0x46, 0xE2,
-0x73, 0x63, 0xA0, 0xE8,
+	0x00, 0x04,
+	0x46, 0xE2,
+	0x73, 0x63, 0xA0, 0xE8,
 
-0x61, 0x41, 0xE0, 0xEC,
-0x31, 0x00,
-0x39, 0x00,
+	0x61, 0x41, 0xE0, 0xEC,
+	0x31, 0x00,
+	0x39, 0x00,
 
-0x8A, 0x80, 0x15, 0xEA,
-0x10, 0x04,
-0x20, 0x04,
+	0x8A, 0x80, 0x15, 0xEA,
+	0x10, 0x04,
+	0x20, 0x04,
 
-0x61, 0x51, 0xE0, 0xEC,
-0x2F, 0x41, 0x60, 0xEA,
+	0x61, 0x51, 0xE0, 0xEC,
+	0x2F, 0x41, 0x60, 0xEA,
 
-0x31, 0x20,
-0x39, 0x20,
-0x1F, 0x42, 0xA0, 0xE8,
+	0x31, 0x20,
+	0x39, 0x20,
+	0x1F, 0x42, 0xA0, 0xE8,
 
-0x2A, 0x42, 0x52, 0xBF,
-0x0F, 0x52, 0xA0, 0xE8,
+	0x2A, 0x42, 0x52, 0xBF,
+	0x0F, 0x52, 0xA0, 0xE8,
 
-0x1A, 0x42, 0x62, 0xBF,
-0x1E, 0x51, 0x60, 0xEA,
+	0x1A, 0x42, 0x62, 0xBF,
+	0x1E, 0x51, 0x60, 0xEA,
 
-0x73, 0x7B, 0xC8, 0xEC,
-0x0E, 0x61, 0x60, 0xEA,
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x0E, 0x61, 0x60, 0xEA,
 
-0x32, 0x40, 0x50, 0xBD,
-0x22, 0x40, 0x60, 0xBD,
+	0x32, 0x40, 0x50, 0xBD,
+	0x22, 0x40, 0x60, 0xBD,
 
-0x12, 0x41, 0x51, 0xBD,
-0x3A, 0x41, 0x61, 0xBD,
+	0x12, 0x41, 0x51, 0xBD,
+	0x3A, 0x41, 0x61, 0xBD,
 
-0xBF, 0x2F, 0x0E, 0xBD,
-0x97, 0xE2,
-0x7B, 0x72,
+	0xBF, 0x2F, 0x0E, 0xBD,
+	0x97, 0xE2,
+	0x7B, 0x72,
 
-0x32, 0x20,
-0x22, 0x20,
-0x12, 0x20,
-0x3A, 0x20,
+	0x32, 0x20,
+	0x22, 0x20,
+	0x12, 0x20,
+	0x3A, 0x20,
 
-0x35, 0x48, 0xB1, 0xE8,
-0x3D, 0x59, 0xB1, 0xE8,
+	0x35, 0x48, 0xB1, 0xE8,
+	0x3D, 0x59, 0xB1, 0xE8,
 
-0x46, 0x31, 0x46, 0xBF,
-0x56, 0x31, 0x56, 0xBF,
+	0x46, 0x31, 0x46, 0xBF,
+	0x56, 0x31, 0x56, 0xBF,
 
-0xB3, 0xE2, 0x2D, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0xB3, 0xE2, 0x2D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x66, 0x31, 0x66, 0xBF,
-0x47, 0x39, 0x47, 0xBF,
+	0x66, 0x31, 0x66, 0xBF,
+	0x47, 0x39, 0x47, 0xBF,
 
-0x57, 0x39, 0x57, 0xBF,
-0x67, 0x39, 0x67, 0xBF,
+	0x57, 0x39, 0x57, 0xBF,
+	0x67, 0x39, 0x67, 0xBF,
 
-0x7B, 0x80, 0x07, 0xEA,
-0x24, 0x41, 0x20, 0xE9,
+	0x7B, 0x80, 0x07, 0xEA,
+	0x24, 0x41, 0x20, 0xE9,
 
-0x35, 0x00,
-0x3D, 0x00,
-0x00, 0xE0,
-0x2D, 0x73,
+	0x35, 0x00,
+	0x3D, 0x00,
+	0x00, 0xE0,
+	0x2D, 0x73,
 
-0x33, 0x72,
-0x0C, 0xE3,
-0x8D, 0x2F, 0x1E, 0xBD,
+	0x33, 0x72,
+	0x0C, 0xE3,
+	0x8D, 0x2F, 0x1E, 0xBD,
 
-0x43, 0x75, 0xF8, 0xEC,
-0x35, 0x20,
-0x3D, 0x20,
+	0x43, 0x75, 0xF8, 0xEC,
+	0x35, 0x20,
+	0x3D, 0x20,
 
-0x43, 0x43, 0x2D, 0xDF,
-0x53, 0x53, 0x2D, 0xDF,
+	0x43, 0x43, 0x2D, 0xDF,
+	0x53, 0x53, 0x2D, 0xDF,
 
-0xAE, 0x1E, 0x0E, 0xBD,
-0x58, 0xE3,
-0x33, 0x66,
+	0xAE, 0x1E, 0x0E, 0xBD,
+	0x58, 0xE3,
+	0x33, 0x66,
 
-0x48, 0x35, 0x48, 0xBF,
-0x58, 0x35, 0x58, 0xBF,
+	0x48, 0x35, 0x48, 0xBF,
+	0x58, 0x35, 0x58, 0xBF,
 
-0x68, 0x35, 0x68, 0xBF,
-0x49, 0x3D, 0x49, 0xBF,
+	0x68, 0x35, 0x68, 0xBF,
+	0x49, 0x3D, 0x49, 0xBF,
 
-0x59, 0x3D, 0x59, 0xBF,
-0x69, 0x3D, 0x69, 0xBF,
+	0x59, 0x3D, 0x59, 0xBF,
+	0x69, 0x3D, 0x69, 0xBF,
 
-0x63, 0x63, 0x2D, 0xDF,
-0x4D, 0x7D, 0xF8, 0xEC,
+	0x63, 0x63, 0x2D, 0xDF,
+	0x4D, 0x7D, 0xF8, 0xEC,
 
-0x59, 0xE3,
-0x00, 0xE0,
-0xB8, 0x38, 0x33, 0xBF,
+	0x59, 0xE3,
+	0x00, 0xE0,
+	0xB8, 0x38, 0x33, 0xBF,
 
-0x2D, 0x73,
-0x30, 0x76,
-0x18, 0x3A, 0x41, 0xE9,
+	0x2D, 0x73,
+	0x30, 0x76,
+	0x18, 0x3A, 0x41, 0xE9,
 
-0x3F, 0x53, 0xA0, 0xE8,
-0x05, 0x80, 0x3D, 0xEA,
+	0x3F, 0x53, 0xA0, 0xE8,
+	0x05, 0x80, 0x3D, 0xEA,
 
-0x37, 0x43, 0xA0, 0xE8,
-0x3D, 0x63, 0xA0, 0xE8,
+	0x37, 0x43, 0xA0, 0xE8,
+	0x3D, 0x63, 0xA0, 0xE8,
 
-0x50, 0x70, 0xF8, 0xEC,
-0x2B, 0x50, 0x3C, 0xE9,
+	0x50, 0x70, 0xF8, 0xEC,
+	0x2B, 0x50, 0x3C, 0xE9,
 
-0x1F, 0x0F, 0xBC, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x1F, 0x0F, 0xBC, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x59, 0x78, 0xF8, 0xEC,
-0x00, 0x80, 0x00, 0xE8,
+	0x59, 0x78, 0xF8, 0xEC,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x15, 0xC0, 0x20, 0xE9,
-0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
 
-0x15, 0xC0, 0x20, 0xE9,
-0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
 
-0x1E, 0x12, 0x41, 0xE9,
-0x1A, 0x22, 0x41, 0xE9,
+	0x1E, 0x12, 0x41, 0xE9,
+	0x1A, 0x22, 0x41, 0xE9,
 
-0x46, 0x37, 0x46, 0xDF,
-0x56, 0x3F, 0x56, 0xDF,
+	0x46, 0x37, 0x46, 0xDF,
+	0x56, 0x3F, 0x56, 0xDF,
 
-0x2B, 0x40, 0x3D, 0xE9,
-0x66, 0x3D, 0x66, 0xDF,
+	0x2B, 0x40, 0x3D, 0xE9,
+	0x66, 0x3D, 0x66, 0xDF,
 
-0x1D, 0x32, 0x41, 0xE9,
-0x67, 0x3D, 0x67, 0xDF,
+	0x1D, 0x32, 0x41, 0xE9,
+	0x67, 0x3D, 0x67, 0xDF,
 
-0x47, 0x37, 0x47, 0xDF,
-0x57, 0x3F, 0x57, 0xDF,
+	0x47, 0x37, 0x47, 0xDF,
+	0x57, 0x3F, 0x57, 0xDF,
 
-0x2A, 0x40, 0x20, 0xE9,
-0x59, 0x3F, 0x59, 0xDF,
+	0x2A, 0x40, 0x20, 0xE9,
+	0x59, 0x3F, 0x59, 0xDF,
 
-0x16, 0x30, 0x20, 0xE9,
-0x69, 0x3D, 0x69, 0xDF,
+	0x16, 0x30, 0x20, 0xE9,
+	0x69, 0x3D, 0x69, 0xDF,
 
-0x48, 0x37, 0x48, 0xDF,
-0x58, 0x3F, 0x58, 0xDF,
+	0x48, 0x37, 0x48, 0xDF,
+	0x58, 0x3F, 0x58, 0xDF,
 
-0x68, 0x3D, 0x68, 0xDF,
-0x49, 0x37, 0x49, 0xDF,
+	0x68, 0x3D, 0x68, 0xDF,
+	0x49, 0x37, 0x49, 0xDF,
 
-0x32, 0x32, 0x2D, 0xDF,
-0x22, 0x22, 0x2D, 0xDF,
+	0x32, 0x32, 0x2D, 0xDF,
+	0x22, 0x22, 0x2D, 0xDF,
 
-0x12, 0x12, 0x2D, 0xDF,
-0x3A, 0x3A, 0x2D, 0xDF,
+	0x12, 0x12, 0x2D, 0xDF,
+	0x3A, 0x3A, 0x2D, 0xDF,
 
-0x0F, 0xCF, 0x74, 0xC2,
-0x37, 0xCF, 0x74, 0xC4,
+	0x0F, 0xCF, 0x74, 0xC2,
+	0x37, 0xCF, 0x74, 0xC4,
 
-0x0A, 0x44, 0x54, 0xB0,
-0x02, 0x44, 0x64, 0xB0,
+	0x0A, 0x44, 0x54, 0xB0,
+	0x02, 0x44, 0x64, 0xB0,
 
-0x3D, 0xCF, 0x74, 0xC0,
-0x34, 0x37, 0x20, 0xE9,
+	0x3D, 0xCF, 0x74, 0xC0,
+	0x34, 0x37, 0x20, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x38, 0x0F, 0x20, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x38, 0x0F, 0x20, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x3C, 0x3D, 0x20, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3C, 0x3D, 0x20, 0xE9,
 
-0x2A, 0x44, 0x54, 0xB2,
-0x1A, 0x44, 0x64, 0xB2,
+	0x2A, 0x44, 0x54, 0xB2,
+	0x1A, 0x44, 0x64, 0xB2,
 
-0x36, 0x80, 0x3A, 0xEA,
-0x0A, 0x20,
-0x02, 0x20,
+	0x36, 0x80, 0x3A, 0xEA,
+	0x0A, 0x20,
+	0x02, 0x20,
 
-0x0F, 0xCF, 0x75, 0xC0,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x0F, 0xCF, 0x75, 0xC0,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x32, 0x31, 0x5F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x32, 0x31, 0x5F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x33, 0x39, 0x5F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x33, 0x39, 0x5F, 0xE9,
 
-0x3D, 0xCF, 0x75, 0xC2,
-0x37, 0xCF, 0x75, 0xC4,
+	0x3D, 0xCF, 0x75, 0xC2,
+	0x37, 0xCF, 0x75, 0xC4,
 
-0x31, 0x53, 0x2F, 0x9F,
-0xA6, 0x0F, 0x20, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA6, 0x0F, 0x20, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0xA3, 0x3D, 0x20, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA3, 0x3D, 0x20, 0xE9,
 
-0x2A, 0x44, 0x54, 0xB4,
-0x1A, 0x44, 0x64, 0xB4,
+	0x2A, 0x44, 0x54, 0xB4,
+	0x1A, 0x44, 0x64, 0xB4,
 
-0x0A, 0x45, 0x55, 0xB0,
-0x02, 0x45, 0x65, 0xB0,
+	0x0A, 0x45, 0x55, 0xB0,
+	0x02, 0x45, 0x65, 0xB0,
 
-0x88, 0x73, 0x5E, 0xE9,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x88, 0x73, 0x5E, 0xE9,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0xA0, 0x37, 0x20, 0xE9,
-0x0A, 0x20,
-0x02, 0x20,
+	0xA0, 0x37, 0x20, 0xE9,
+	0x0A, 0x20,
+	0x02, 0x20,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x3E, 0x30, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x3E, 0x30, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x3F, 0x38, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3F, 0x38, 0x4F, 0xE9,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x3A, 0x31, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x3A, 0x31, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x3B, 0x39, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x3B, 0x39, 0x4F, 0xE9,
 
-0x2A, 0x45, 0x55, 0xB2,
-0x1A, 0x45, 0x65, 0xB2,
+	0x2A, 0x45, 0x55, 0xB2,
+	0x1A, 0x45, 0x65, 0xB2,
 
-0x0A, 0x45, 0x55, 0xB4,
-0x02, 0x45, 0x65, 0xB4,
+	0x0A, 0x45, 0x55, 0xB4,
+	0x02, 0x45, 0x65, 0xB4,
 
-0x0F, 0xCF, 0x74, 0xC6,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x0F, 0xCF, 0x74, 0xC6,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0xA7, 0x30, 0x4F, 0xE9,
-0x0A, 0x20,
-0x02, 0x20,
+	0xA7, 0x30, 0x4F, 0xE9,
+	0x0A, 0x20,
+	0x02, 0x20,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x9C, 0x0F, 0x20, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x9C, 0x0F, 0x20, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0xA8, 0x38, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA8, 0x38, 0x4F, 0xE9,
 
-0x2A, 0x44, 0x54, 0xB6,
-0x1A, 0x44, 0x64, 0xB6,
+	0x2A, 0x44, 0x54, 0xB6,
+	0x1A, 0x44, 0x64, 0xB6,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x36, 0x31, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x36, 0x31, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x37, 0x39, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x37, 0x39, 0x4F, 0xE9,
 
-0x00, 0x80, 0x00, 0xE8,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x00, 0x80, 0x00, 0xE8,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0x2A, 0x46, 0x56, 0xBF,
-0x1A, 0x46, 0x66, 0xBF,
+	0x2A, 0x46, 0x56, 0xBF,
+	0x1A, 0x46, 0x66, 0xBF,
 
-0x31, 0x53, 0x2F, 0x9F,
-0xA4, 0x31, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA4, 0x31, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0xA5, 0x39, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA5, 0x39, 0x4F, 0xE9,
 
-0x0A, 0x47, 0x57, 0xBF,
-0x02, 0x47, 0x67, 0xBF,
+	0x0A, 0x47, 0x57, 0xBF,
+	0x02, 0x47, 0x67, 0xBF,
 
-0x31, 0x53, 0x2F, 0x9F,
-0xA1, 0x30, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA1, 0x30, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0xA2, 0x38, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA2, 0x38, 0x4F, 0xE9,
 
-0x2A, 0x43, 0x53, 0xBF,
-0x1A, 0x43, 0x63, 0xBF,
+	0x2A, 0x43, 0x53, 0xBF,
+	0x1A, 0x43, 0x63, 0xBF,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x9D, 0x31, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x9D, 0x31, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x9E, 0x39, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x9E, 0x39, 0x4F, 0xE9,
 
-0x0A, 0x48, 0x58, 0xBF,
-0x02, 0x48, 0x68, 0xBF,
+	0x0A, 0x48, 0x58, 0xBF,
+	0x02, 0x48, 0x68, 0xBF,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x80, 0x31, 0x57, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x80, 0x31, 0x57, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x81, 0x39, 0x57, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x81, 0x39, 0x57, 0xE9,
 
-0x2A, 0x49, 0x59, 0xBF,
-0x1A, 0x49, 0x69, 0xBF,
+	0x2A, 0x49, 0x59, 0xBF,
+	0x1A, 0x49, 0x69, 0xBF,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x82, 0x30, 0x57, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x82, 0x30, 0x57, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x83, 0x38, 0x57, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x83, 0x38, 0x57, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x84, 0x31, 0x5E, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x84, 0x31, 0x5E, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x85, 0x39, 0x5E, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x85, 0x39, 0x5E, 0xE9,
 
-0x86, 0x76, 0x57, 0xE9,
-0x8A, 0x36, 0x20, 0xE9,
+	0x86, 0x76, 0x57, 0xE9,
+	0x8A, 0x36, 0x20, 0xE9,
 
-0x87, 0x77, 0x57, 0xE9,
-0x8B, 0x3E, 0xBF, 0xEA,
+	0x87, 0x77, 0x57, 0xE9,
+	0x8B, 0x3E, 0xBF, 0xEA,
 
-0x80, 0x30, 0x57, 0xE9,
-0x81, 0x38, 0x57, 0xE9,
+	0x80, 0x30, 0x57, 0xE9,
+	0x81, 0x38, 0x57, 0xE9,
 
-0x82, 0x31, 0x57, 0xE9,
-0x86, 0x78, 0x57, 0xE9,
+	0x82, 0x31, 0x57, 0xE9,
+	0x86, 0x78, 0x57, 0xE9,
 
-0x83, 0x39, 0x57, 0xE9,
-0x87, 0x79, 0x57, 0xE9,
+	0x83, 0x39, 0x57, 0xE9,
+	0x87, 0x79, 0x57, 0xE9,
 
-0x30, 0x1F, 0x5F, 0xE9,
-0x8A, 0x34, 0x20, 0xE9,
+	0x30, 0x1F, 0x5F, 0xE9,
+	0x8A, 0x34, 0x20, 0xE9,
 
-0x8B, 0x3C, 0x20, 0xE9,
-0x37, 0x50, 0x60, 0xBD,
+	0x8B, 0x3C, 0x20, 0xE9,
+	0x37, 0x50, 0x60, 0xBD,
 
-0x57, 0x0D, 0x20, 0xE9,
-0x35, 0x51, 0x61, 0xBD,
+	0x57, 0x0D, 0x20, 0xE9,
+	0x35, 0x51, 0x61, 0xBD,
 
-0x2B, 0x50, 0x20, 0xE9,
-0x1D, 0x37, 0xE1, 0xEA,
+	0x2B, 0x50, 0x20, 0xE9,
+	0x1D, 0x37, 0xE1, 0xEA,
 
-0x1E, 0x35, 0xE1, 0xEA,
-0x00, 0xE0,
-0x0E, 0x77,
+	0x1E, 0x35, 0xE1, 0xEA,
+	0x00, 0xE0,
+	0x0E, 0x77,
 
-0x24, 0x51, 0x20, 0xE9,
-0x8D, 0xFF, 0x20, 0xEA,
+	0x24, 0x51, 0x20, 0xE9,
+	0x8D, 0xFF, 0x20, 0xEA,
 
-0x16, 0x0E, 0x20, 0xE9,
-0x57, 0x2E, 0xBF, 0xEA,
+	0x16, 0x0E, 0x20, 0xE9,
+	0x57, 0x2E, 0xBF, 0xEA,
 
-0x0B, 0x46, 0xA0, 0xE8,
-0x1B, 0x56, 0xA0, 0xE8,
+	0x0B, 0x46, 0xA0, 0xE8,
+	0x1B, 0x56, 0xA0, 0xE8,
 
-0x2B, 0x66, 0xA0, 0xE8,
-0x0C, 0x47, 0xA0, 0xE8,
+	0x2B, 0x66, 0xA0, 0xE8,
+	0x0C, 0x47, 0xA0, 0xE8,
 
-0x1C, 0x57, 0xA0, 0xE8,
-0x2C, 0x67, 0xA0, 0xE8,
+	0x1C, 0x57, 0xA0, 0xE8,
+	0x2C, 0x67, 0xA0, 0xE8,
 
-0x0B, 0x00,
-0x1B, 0x00,
-0x2B, 0x00,
-0x00, 0xE0,
+	0x0B, 0x00,
+	0x1B, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
 
-0x0C, 0x00,
-0x1C, 0x00,
-0x2C, 0x00,
-0x00, 0xE0,
+	0x0C, 0x00,
+	0x1C, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
 
-0x0B, 0x65,
-0x1B, 0x65,
-0x2B, 0x65,
-0x00, 0xE0,
+	0x0B, 0x65,
+	0x1B, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
 
-0x0C, 0x65,
-0x1C, 0x65,
-0x2C, 0x65,
-0x00, 0xE0,
+	0x0C, 0x65,
+	0x1C, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
 
-0x0B, 0x1B, 0x60, 0xEC,
-0x36, 0xD7, 0x36, 0xAD,
+	0x0B, 0x1B, 0x60, 0xEC,
+	0x36, 0xD7, 0x36, 0xAD,
 
-0x2B, 0x80, 0x60, 0xEC,
-0x0C, 0x1C, 0x60, 0xEC,
+	0x2B, 0x80, 0x60, 0xEC,
+	0x0C, 0x1C, 0x60, 0xEC,
 
-0x3E, 0xD7, 0x3E, 0xAD,
-0x2C, 0x80, 0x60, 0xEC,
+	0x3E, 0xD7, 0x3E, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
 
-0x0B, 0x2B, 0xDE, 0xE8,
-0x1B, 0x80, 0xDE, 0xE8,
+	0x0B, 0x2B, 0xDE, 0xE8,
+	0x1B, 0x80, 0xDE, 0xE8,
 
-0x36, 0x80, 0x36, 0xBD,
-0x3E, 0x80, 0x3E, 0xBD,
+	0x36, 0x80, 0x36, 0xBD,
+	0x3E, 0x80, 0x3E, 0xBD,
 
-0x33, 0xD7, 0x0B, 0xBD,
-0x3B, 0xD7, 0x1B, 0xBD,
+	0x33, 0xD7, 0x0B, 0xBD,
+	0x3B, 0xD7, 0x1B, 0xBD,
 
-0x46, 0x80, 0x46, 0xCF,
-0x57, 0x80, 0x57, 0xCF,
+	0x46, 0x80, 0x46, 0xCF,
+	0x57, 0x80, 0x57, 0xCF,
 
-0x66, 0x33, 0x66, 0xCF,
-0x47, 0x3B, 0x47, 0xCF,
+	0x66, 0x33, 0x66, 0xCF,
+	0x47, 0x3B, 0x47, 0xCF,
 
-0x56, 0x33, 0x56, 0xCF,
-0x67, 0x3B, 0x67, 0xCF,
+	0x56, 0x33, 0x56, 0xCF,
+	0x67, 0x3B, 0x67, 0xCF,
 
-0x0B, 0x48, 0xA0, 0xE8,
-0x1B, 0x58, 0xA0, 0xE8,
+	0x0B, 0x48, 0xA0, 0xE8,
+	0x1B, 0x58, 0xA0, 0xE8,
 
-0x2B, 0x68, 0xA0, 0xE8,
-0x0C, 0x49, 0xA0, 0xE8,
+	0x2B, 0x68, 0xA0, 0xE8,
+	0x0C, 0x49, 0xA0, 0xE8,
 
-0x1C, 0x59, 0xA0, 0xE8,
-0x2C, 0x69, 0xA0, 0xE8,
+	0x1C, 0x59, 0xA0, 0xE8,
+	0x2C, 0x69, 0xA0, 0xE8,
 
-0x0B, 0x00,
-0x1B, 0x00,
-0x2B, 0x00,
-0x00, 0xE0,
+	0x0B, 0x00,
+	0x1B, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
 
-0x0C, 0x00,
-0x1C, 0x00,
-0x2C, 0x00,
-0x00, 0xE0,
+	0x0C, 0x00,
+	0x1C, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
 
-0x0B, 0x65,
-0x1B, 0x65,
-0x2B, 0x65,
-0x00, 0xE0,
+	0x0B, 0x65,
+	0x1B, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
 
-0x0C, 0x65,
-0x1C, 0x65,
-0x2C, 0x65,
-0x00, 0xE0,
+	0x0C, 0x65,
+	0x1C, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
 
-0x0B, 0x1B, 0x60, 0xEC,
-0x34, 0xD7, 0x34, 0xAD,
+	0x0B, 0x1B, 0x60, 0xEC,
+	0x34, 0xD7, 0x34, 0xAD,
 
-0x2B, 0x80, 0x60, 0xEC,
-0x0C, 0x1C, 0x60, 0xEC,
+	0x2B, 0x80, 0x60, 0xEC,
+	0x0C, 0x1C, 0x60, 0xEC,
 
-0x3C, 0xD7, 0x3C, 0xAD,
-0x2C, 0x80, 0x60, 0xEC,
+	0x3C, 0xD7, 0x3C, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
 
-0x0B, 0x2B, 0xDE, 0xE8,
-0x1B, 0x80, 0xDE, 0xE8,
+	0x0B, 0x2B, 0xDE, 0xE8,
+	0x1B, 0x80, 0xDE, 0xE8,
 
-0x34, 0x80, 0x34, 0xBD,
-0x3C, 0x80, 0x3C, 0xBD,
+	0x34, 0x80, 0x34, 0xBD,
+	0x3C, 0x80, 0x3C, 0xBD,
 
-0x33, 0xD7, 0x0B, 0xBD,
-0x3B, 0xD7, 0x1B, 0xBD,
+	0x33, 0xD7, 0x0B, 0xBD,
+	0x3B, 0xD7, 0x1B, 0xBD,
 
-0x48, 0x80, 0x48, 0xCF,
-0x59, 0x80, 0x59, 0xCF,
+	0x48, 0x80, 0x48, 0xCF,
+	0x59, 0x80, 0x59, 0xCF,
 
-0x68, 0x33, 0x68, 0xCF,
-0x49, 0x3B, 0x49, 0xCF,
+	0x68, 0x33, 0x68, 0xCF,
+	0x49, 0x3B, 0x49, 0xCF,
 
-0xAD, 0xFF, 0x20, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0xAD, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x58, 0x33, 0x58, 0xCF,
-0x69, 0x3B, 0x69, 0xCF,
+	0x58, 0x33, 0x58, 0xCF,
+	0x69, 0x3B, 0x69, 0xCF,
 
-0x6B, 0xFF, 0x20, 0xEA,
-0x57, 0xC0, 0xBF, 0xEA,
+	0x6B, 0xFF, 0x20, 0xEA,
+	0x57, 0xC0, 0xBF, 0xEA,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x00, 0x00, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
 
 };
 
 static unsigned char warp_g400_t2gzsaf[] = {
 
-0x00, 0x8A, 0x98, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x8A, 0x98, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x00, 0x00, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
 
-0xFF, 0x80, 0xC0, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x0A, 0x40, 0x50, 0xBF,
-0x2A, 0x40, 0x60, 0xBF,
+	0x0A, 0x40, 0x50, 0xBF,
+	0x2A, 0x40, 0x60, 0xBF,
 
-0x32, 0x41, 0x51, 0xBF,
-0x3A, 0x41, 0x61, 0xBF,
+	0x32, 0x41, 0x51, 0xBF,
+	0x3A, 0x41, 0x61, 0xBF,
 
-0xC3, 0x6B,
-0xD3, 0x6B,
-0x00, 0x8A, 0x98, 0xE9,
+	0xC3, 0x6B,
+	0xD3, 0x6B,
+	0x00, 0x8A, 0x98, 0xE9,
 
-0x73, 0x7B, 0xC8, 0xEC,
-0x96, 0xE2,
-0x41, 0x04,
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x96, 0xE2,
+	0x41, 0x04,
 
-0x7B, 0x43, 0xA0, 0xE8,
-0x73, 0x53, 0xA0, 0xE8,
+	0x7B, 0x43, 0xA0, 0xE8,
+	0x73, 0x53, 0xA0, 0xE8,
 
-0xAD, 0xEE, 0x23, 0x9F,
-0x00, 0xE0,
-0x51, 0x04,
+	0xAD, 0xEE, 0x23, 0x9F,
+	0x00, 0xE0,
+	0x51, 0x04,
 
-0x90, 0xE2,
-0x61, 0x04,
-0x31, 0x46, 0xB1, 0xE8,
+	0x90, 0xE2,
+	0x61, 0x04,
+	0x31, 0x46, 0xB1, 0xE8,
 
-0x51, 0x41, 0xE0, 0xEC,
-0x39, 0x67, 0xB1, 0xE8,
+	0x51, 0x41, 0xE0, 0xEC,
+	0x39, 0x67, 0xB1, 0xE8,
 
-0x00, 0x04,
-0x46, 0xE2,
-0x73, 0x63, 0xA0, 0xE8,
+	0x00, 0x04,
+	0x46, 0xE2,
+	0x73, 0x63, 0xA0, 0xE8,
 
-0x61, 0x41, 0xE0, 0xEC,
-0x31, 0x00,
-0x39, 0x00,
+	0x61, 0x41, 0xE0, 0xEC,
+	0x31, 0x00,
+	0x39, 0x00,
 
-0x8E, 0x80, 0x15, 0xEA,
-0x10, 0x04,
-0x20, 0x04,
+	0x8E, 0x80, 0x15, 0xEA,
+	0x10, 0x04,
+	0x20, 0x04,
 
-0x61, 0x51, 0xE0, 0xEC,
-0x2F, 0x41, 0x60, 0xEA,
+	0x61, 0x51, 0xE0, 0xEC,
+	0x2F, 0x41, 0x60, 0xEA,
 
-0x31, 0x20,
-0x39, 0x20,
-0x1F, 0x42, 0xA0, 0xE8,
+	0x31, 0x20,
+	0x39, 0x20,
+	0x1F, 0x42, 0xA0, 0xE8,
 
-0x2A, 0x42, 0x52, 0xBF,
-0x0F, 0x52, 0xA0, 0xE8,
+	0x2A, 0x42, 0x52, 0xBF,
+	0x0F, 0x52, 0xA0, 0xE8,
 
-0x1A, 0x42, 0x62, 0xBF,
-0x1E, 0x51, 0x60, 0xEA,
+	0x1A, 0x42, 0x62, 0xBF,
+	0x1E, 0x51, 0x60, 0xEA,
 
-0x73, 0x7B, 0xC8, 0xEC,
-0x0E, 0x61, 0x60, 0xEA,
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x0E, 0x61, 0x60, 0xEA,
 
-0x32, 0x40, 0x50, 0xBD,
-0x22, 0x40, 0x60, 0xBD,
+	0x32, 0x40, 0x50, 0xBD,
+	0x22, 0x40, 0x60, 0xBD,
 
-0x12, 0x41, 0x51, 0xBD,
-0x3A, 0x41, 0x61, 0xBD,
+	0x12, 0x41, 0x51, 0xBD,
+	0x3A, 0x41, 0x61, 0xBD,
 
-0xBF, 0x2F, 0x0E, 0xBD,
-0x97, 0xE2,
-0x7B, 0x72,
+	0xBF, 0x2F, 0x0E, 0xBD,
+	0x97, 0xE2,
+	0x7B, 0x72,
 
-0x32, 0x20,
-0x22, 0x20,
-0x12, 0x20,
-0x3A, 0x20,
+	0x32, 0x20,
+	0x22, 0x20,
+	0x12, 0x20,
+	0x3A, 0x20,
 
-0x35, 0x48, 0xB1, 0xE8,
-0x3D, 0x59, 0xB1, 0xE8,
+	0x35, 0x48, 0xB1, 0xE8,
+	0x3D, 0x59, 0xB1, 0xE8,
 
-0x46, 0x31, 0x46, 0xBF,
-0x56, 0x31, 0x56, 0xBF,
+	0x46, 0x31, 0x46, 0xBF,
+	0x56, 0x31, 0x56, 0xBF,
 
-0xB3, 0xE2, 0x2D, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0xB3, 0xE2, 0x2D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x66, 0x31, 0x66, 0xBF,
-0x47, 0x39, 0x47, 0xBF,
+	0x66, 0x31, 0x66, 0xBF,
+	0x47, 0x39, 0x47, 0xBF,
 
-0x57, 0x39, 0x57, 0xBF,
-0x67, 0x39, 0x67, 0xBF,
+	0x57, 0x39, 0x57, 0xBF,
+	0x67, 0x39, 0x67, 0xBF,
 
-0x7F, 0x80, 0x07, 0xEA,
-0x24, 0x41, 0x20, 0xE9,
+	0x7F, 0x80, 0x07, 0xEA,
+	0x24, 0x41, 0x20, 0xE9,
 
-0x35, 0x00,
-0x3D, 0x00,
-0x00, 0xE0,
-0x2D, 0x73,
+	0x35, 0x00,
+	0x3D, 0x00,
+	0x00, 0xE0,
+	0x2D, 0x73,
 
-0x33, 0x72,
-0x0C, 0xE3,
-0x8D, 0x2F, 0x1E, 0xBD,
+	0x33, 0x72,
+	0x0C, 0xE3,
+	0x8D, 0x2F, 0x1E, 0xBD,
 
-0x43, 0x75, 0xF8, 0xEC,
-0x35, 0x20,
-0x3D, 0x20,
+	0x43, 0x75, 0xF8, 0xEC,
+	0x35, 0x20,
+	0x3D, 0x20,
 
-0x43, 0x43, 0x2D, 0xDF,
-0x53, 0x53, 0x2D, 0xDF,
+	0x43, 0x43, 0x2D, 0xDF,
+	0x53, 0x53, 0x2D, 0xDF,
 
-0xAE, 0x1E, 0x0E, 0xBD,
-0x58, 0xE3,
-0x33, 0x66,
+	0xAE, 0x1E, 0x0E, 0xBD,
+	0x58, 0xE3,
+	0x33, 0x66,
 
-0x48, 0x35, 0x48, 0xBF,
-0x58, 0x35, 0x58, 0xBF,
+	0x48, 0x35, 0x48, 0xBF,
+	0x58, 0x35, 0x58, 0xBF,
 
-0x68, 0x35, 0x68, 0xBF,
-0x49, 0x3D, 0x49, 0xBF,
+	0x68, 0x35, 0x68, 0xBF,
+	0x49, 0x3D, 0x49, 0xBF,
 
-0x59, 0x3D, 0x59, 0xBF,
-0x69, 0x3D, 0x69, 0xBF,
+	0x59, 0x3D, 0x59, 0xBF,
+	0x69, 0x3D, 0x69, 0xBF,
 
-0x63, 0x63, 0x2D, 0xDF,
-0x4D, 0x7D, 0xF8, 0xEC,
+	0x63, 0x63, 0x2D, 0xDF,
+	0x4D, 0x7D, 0xF8, 0xEC,
 
-0x59, 0xE3,
-0x00, 0xE0,
-0xB8, 0x38, 0x33, 0xBF,
+	0x59, 0xE3,
+	0x00, 0xE0,
+	0xB8, 0x38, 0x33, 0xBF,
 
-0x2D, 0x73,
-0x30, 0x76,
-0x18, 0x3A, 0x41, 0xE9,
+	0x2D, 0x73,
+	0x30, 0x76,
+	0x18, 0x3A, 0x41, 0xE9,
 
-0x3F, 0x53, 0xA0, 0xE8,
-0x05, 0x80, 0x3D, 0xEA,
+	0x3F, 0x53, 0xA0, 0xE8,
+	0x05, 0x80, 0x3D, 0xEA,
 
-0x37, 0x43, 0xA0, 0xE8,
-0x3D, 0x63, 0xA0, 0xE8,
+	0x37, 0x43, 0xA0, 0xE8,
+	0x3D, 0x63, 0xA0, 0xE8,
 
-0x50, 0x70, 0xF8, 0xEC,
-0x2B, 0x50, 0x3C, 0xE9,
+	0x50, 0x70, 0xF8, 0xEC,
+	0x2B, 0x50, 0x3C, 0xE9,
 
-0x1F, 0x0F, 0xBC, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x1F, 0x0F, 0xBC, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x59, 0x78, 0xF8, 0xEC,
-0x00, 0x80, 0x00, 0xE8,
+	0x59, 0x78, 0xF8, 0xEC,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x15, 0xC0, 0x20, 0xE9,
-0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
 
-0x15, 0xC0, 0x20, 0xE9,
-0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
 
-0x1E, 0x12, 0x41, 0xE9,
-0x1A, 0x22, 0x41, 0xE9,
+	0x1E, 0x12, 0x41, 0xE9,
+	0x1A, 0x22, 0x41, 0xE9,
 
-0x46, 0x37, 0x46, 0xDF,
-0x56, 0x3F, 0x56, 0xDF,
+	0x46, 0x37, 0x46, 0xDF,
+	0x56, 0x3F, 0x56, 0xDF,
 
-0x2B, 0x40, 0x3D, 0xE9,
-0x66, 0x3D, 0x66, 0xDF,
+	0x2B, 0x40, 0x3D, 0xE9,
+	0x66, 0x3D, 0x66, 0xDF,
 
-0x1D, 0x32, 0x41, 0xE9,
-0x67, 0x3D, 0x67, 0xDF,
+	0x1D, 0x32, 0x41, 0xE9,
+	0x67, 0x3D, 0x67, 0xDF,
 
-0x47, 0x37, 0x47, 0xDF,
-0x57, 0x3F, 0x57, 0xDF,
+	0x47, 0x37, 0x47, 0xDF,
+	0x57, 0x3F, 0x57, 0xDF,
 
-0x2A, 0x40, 0x20, 0xE9,
-0x59, 0x3F, 0x59, 0xDF,
+	0x2A, 0x40, 0x20, 0xE9,
+	0x59, 0x3F, 0x59, 0xDF,
 
-0x16, 0x30, 0x20, 0xE9,
-0x69, 0x3D, 0x69, 0xDF,
+	0x16, 0x30, 0x20, 0xE9,
+	0x69, 0x3D, 0x69, 0xDF,
 
-0x48, 0x37, 0x48, 0xDF,
-0x58, 0x3F, 0x58, 0xDF,
+	0x48, 0x37, 0x48, 0xDF,
+	0x58, 0x3F, 0x58, 0xDF,
 
-0x68, 0x3D, 0x68, 0xDF,
-0x49, 0x37, 0x49, 0xDF,
+	0x68, 0x3D, 0x68, 0xDF,
+	0x49, 0x37, 0x49, 0xDF,
 
-0x32, 0x32, 0x2D, 0xDF,
-0x22, 0x22, 0x2D, 0xDF,
+	0x32, 0x32, 0x2D, 0xDF,
+	0x22, 0x22, 0x2D, 0xDF,
 
-0x12, 0x12, 0x2D, 0xDF,
-0x3A, 0x3A, 0x2D, 0xDF,
+	0x12, 0x12, 0x2D, 0xDF,
+	0x3A, 0x3A, 0x2D, 0xDF,
 
-0x0F, 0xCF, 0x74, 0xC2,
-0x37, 0xCF, 0x74, 0xC4,
+	0x0F, 0xCF, 0x74, 0xC2,
+	0x37, 0xCF, 0x74, 0xC4,
 
-0x0A, 0x44, 0x54, 0xB0,
-0x02, 0x44, 0x64, 0xB0,
+	0x0A, 0x44, 0x54, 0xB0,
+	0x02, 0x44, 0x64, 0xB0,
 
-0x3D, 0xCF, 0x74, 0xC0,
-0x34, 0x37, 0x20, 0xE9,
+	0x3D, 0xCF, 0x74, 0xC0,
+	0x34, 0x37, 0x20, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x38, 0x0F, 0x20, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x38, 0x0F, 0x20, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x3C, 0x3D, 0x20, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3C, 0x3D, 0x20, 0xE9,
 
-0x2A, 0x44, 0x54, 0xB2,
-0x1A, 0x44, 0x64, 0xB2,
+	0x2A, 0x44, 0x54, 0xB2,
+	0x1A, 0x44, 0x64, 0xB2,
 
-0x3A, 0x80, 0x3A, 0xEA,
-0x0A, 0x20,
-0x02, 0x20,
+	0x3A, 0x80, 0x3A, 0xEA,
+	0x0A, 0x20,
+	0x02, 0x20,
 
-0x0F, 0xCF, 0x75, 0xC0,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x0F, 0xCF, 0x75, 0xC0,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x32, 0x31, 0x5F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x32, 0x31, 0x5F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x33, 0x39, 0x5F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x33, 0x39, 0x5F, 0xE9,
 
-0x3D, 0xCF, 0x75, 0xC2,
-0x37, 0xCF, 0x75, 0xC4,
+	0x3D, 0xCF, 0x75, 0xC2,
+	0x37, 0xCF, 0x75, 0xC4,
 
-0x31, 0x53, 0x2F, 0x9F,
-0xA6, 0x0F, 0x20, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA6, 0x0F, 0x20, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0xA3, 0x3D, 0x20, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA3, 0x3D, 0x20, 0xE9,
 
-0x2A, 0x44, 0x54, 0xB4,
-0x1A, 0x44, 0x64, 0xB4,
+	0x2A, 0x44, 0x54, 0xB4,
+	0x1A, 0x44, 0x64, 0xB4,
 
-0x0A, 0x45, 0x55, 0xB0,
-0x02, 0x45, 0x65, 0xB0,
+	0x0A, 0x45, 0x55, 0xB0,
+	0x02, 0x45, 0x65, 0xB0,
 
-0x88, 0x73, 0x5E, 0xE9,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x88, 0x73, 0x5E, 0xE9,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0xA0, 0x37, 0x20, 0xE9,
-0x0A, 0x20,
-0x02, 0x20,
+	0xA0, 0x37, 0x20, 0xE9,
+	0x0A, 0x20,
+	0x02, 0x20,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x3E, 0x30, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x3E, 0x30, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x3F, 0x38, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3F, 0x38, 0x4F, 0xE9,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x3A, 0x31, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x3A, 0x31, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x3B, 0x39, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x3B, 0x39, 0x4F, 0xE9,
 
-0x2A, 0x45, 0x55, 0xB2,
-0x1A, 0x45, 0x65, 0xB2,
+	0x2A, 0x45, 0x55, 0xB2,
+	0x1A, 0x45, 0x65, 0xB2,
 
-0x0A, 0x45, 0x55, 0xB4,
-0x02, 0x45, 0x65, 0xB4,
+	0x0A, 0x45, 0x55, 0xB4,
+	0x02, 0x45, 0x65, 0xB4,
 
-0x0F, 0xCF, 0x74, 0xC6,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x0F, 0xCF, 0x74, 0xC6,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0xA7, 0x30, 0x4F, 0xE9,
-0x0A, 0x20,
-0x02, 0x20,
+	0xA7, 0x30, 0x4F, 0xE9,
+	0x0A, 0x20,
+	0x02, 0x20,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x9C, 0x0F, 0x20, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x9C, 0x0F, 0x20, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0xA8, 0x38, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA8, 0x38, 0x4F, 0xE9,
 
-0x2A, 0x44, 0x54, 0xB6,
-0x1A, 0x44, 0x64, 0xB6,
+	0x2A, 0x44, 0x54, 0xB6,
+	0x1A, 0x44, 0x64, 0xB6,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x36, 0x31, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x36, 0x31, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x37, 0x39, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x37, 0x39, 0x4F, 0xE9,
 
-0x0A, 0x45, 0x55, 0xB6,
-0x02, 0x45, 0x65, 0xB6,
+	0x0A, 0x45, 0x55, 0xB6,
+	0x02, 0x45, 0x65, 0xB6,
 
-0x3D, 0xCF, 0x75, 0xC6,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x3D, 0xCF, 0x75, 0xC6,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0x2A, 0x46, 0x56, 0xBF,
-0x1A, 0x46, 0x66, 0xBF,
+	0x2A, 0x46, 0x56, 0xBF,
+	0x1A, 0x46, 0x66, 0xBF,
 
-0x31, 0x53, 0x2F, 0x9F,
-0xA4, 0x31, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA4, 0x31, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0xA5, 0x39, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA5, 0x39, 0x4F, 0xE9,
 
-0x31, 0x3D, 0x20, 0xE9,
-0x0A, 0x20,
-0x02, 0x20,
+	0x31, 0x3D, 0x20, 0xE9,
+	0x0A, 0x20,
+	0x02, 0x20,
 
-0x0A, 0x47, 0x57, 0xBF,
-0x02, 0x47, 0x67, 0xBF,
+	0x0A, 0x47, 0x57, 0xBF,
+	0x02, 0x47, 0x67, 0xBF,
 
-0x30, 0x50, 0x2E, 0x9F,
-0xA1, 0x30, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0xA1, 0x30, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0xA2, 0x38, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0xA2, 0x38, 0x4F, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x9D, 0x31, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x9D, 0x31, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x9E, 0x39, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x9E, 0x39, 0x4F, 0xE9,
 
-0x2A, 0x43, 0x53, 0xBF,
-0x1A, 0x43, 0x63, 0xBF,
+	0x2A, 0x43, 0x53, 0xBF,
+	0x1A, 0x43, 0x63, 0xBF,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x35, 0x30, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x35, 0x30, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x39, 0x38, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x39, 0x38, 0x4F, 0xE9,
 
-0x0A, 0x48, 0x58, 0xBF,
-0x02, 0x48, 0x68, 0xBF,
+	0x0A, 0x48, 0x58, 0xBF,
+	0x02, 0x48, 0x68, 0xBF,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x80, 0x31, 0x57, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x80, 0x31, 0x57, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x81, 0x39, 0x57, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x81, 0x39, 0x57, 0xE9,
 
-0x2A, 0x49, 0x59, 0xBF,
-0x1A, 0x49, 0x69, 0xBF,
+	0x2A, 0x49, 0x59, 0xBF,
+	0x1A, 0x49, 0x69, 0xBF,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x82, 0x30, 0x57, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x82, 0x30, 0x57, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x83, 0x38, 0x57, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x83, 0x38, 0x57, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x84, 0x31, 0x5E, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x84, 0x31, 0x5E, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x85, 0x39, 0x5E, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x85, 0x39, 0x5E, 0xE9,
 
-0x86, 0x76, 0x57, 0xE9,
-0x8A, 0x36, 0x20, 0xE9,
+	0x86, 0x76, 0x57, 0xE9,
+	0x8A, 0x36, 0x20, 0xE9,
 
-0x87, 0x77, 0x57, 0xE9,
-0x8B, 0x3E, 0xBF, 0xEA,
+	0x87, 0x77, 0x57, 0xE9,
+	0x8B, 0x3E, 0xBF, 0xEA,
 
-0x80, 0x30, 0x57, 0xE9,
-0x81, 0x38, 0x57, 0xE9,
+	0x80, 0x30, 0x57, 0xE9,
+	0x81, 0x38, 0x57, 0xE9,
 
-0x82, 0x31, 0x57, 0xE9,
-0x86, 0x78, 0x57, 0xE9,
+	0x82, 0x31, 0x57, 0xE9,
+	0x86, 0x78, 0x57, 0xE9,
 
-0x83, 0x39, 0x57, 0xE9,
-0x87, 0x79, 0x57, 0xE9,
+	0x83, 0x39, 0x57, 0xE9,
+	0x87, 0x79, 0x57, 0xE9,
 
-0x30, 0x1F, 0x5F, 0xE9,
-0x8A, 0x34, 0x20, 0xE9,
+	0x30, 0x1F, 0x5F, 0xE9,
+	0x8A, 0x34, 0x20, 0xE9,
 
-0x8B, 0x3C, 0x20, 0xE9,
-0x37, 0x50, 0x60, 0xBD,
+	0x8B, 0x3C, 0x20, 0xE9,
+	0x37, 0x50, 0x60, 0xBD,
 
-0x57, 0x0D, 0x20, 0xE9,
-0x35, 0x51, 0x61, 0xBD,
+	0x57, 0x0D, 0x20, 0xE9,
+	0x35, 0x51, 0x61, 0xBD,
 
-0x2B, 0x50, 0x20, 0xE9,
-0x1D, 0x37, 0xE1, 0xEA,
+	0x2B, 0x50, 0x20, 0xE9,
+	0x1D, 0x37, 0xE1, 0xEA,
 
-0x1E, 0x35, 0xE1, 0xEA,
-0x00, 0xE0,
-0x0E, 0x77,
+	0x1E, 0x35, 0xE1, 0xEA,
+	0x00, 0xE0,
+	0x0E, 0x77,
 
-0x24, 0x51, 0x20, 0xE9,
-0x89, 0xFF, 0x20, 0xEA,
+	0x24, 0x51, 0x20, 0xE9,
+	0x89, 0xFF, 0x20, 0xEA,
 
-0x16, 0x0E, 0x20, 0xE9,
-0x57, 0x2E, 0xBF, 0xEA,
+	0x16, 0x0E, 0x20, 0xE9,
+	0x57, 0x2E, 0xBF, 0xEA,
 
-0x0B, 0x46, 0xA0, 0xE8,
-0x1B, 0x56, 0xA0, 0xE8,
+	0x0B, 0x46, 0xA0, 0xE8,
+	0x1B, 0x56, 0xA0, 0xE8,
 
-0x2B, 0x66, 0xA0, 0xE8,
-0x0C, 0x47, 0xA0, 0xE8,
+	0x2B, 0x66, 0xA0, 0xE8,
+	0x0C, 0x47, 0xA0, 0xE8,
 
-0x1C, 0x57, 0xA0, 0xE8,
-0x2C, 0x67, 0xA0, 0xE8,
+	0x1C, 0x57, 0xA0, 0xE8,
+	0x2C, 0x67, 0xA0, 0xE8,
 
-0x0B, 0x00,
-0x1B, 0x00,
-0x2B, 0x00,
-0x00, 0xE0,
+	0x0B, 0x00,
+	0x1B, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
 
-0x0C, 0x00,
-0x1C, 0x00,
-0x2C, 0x00,
-0x00, 0xE0,
+	0x0C, 0x00,
+	0x1C, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
 
-0x0B, 0x65,
-0x1B, 0x65,
-0x2B, 0x65,
-0x00, 0xE0,
+	0x0B, 0x65,
+	0x1B, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
 
-0x0C, 0x65,
-0x1C, 0x65,
-0x2C, 0x65,
-0x00, 0xE0,
+	0x0C, 0x65,
+	0x1C, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
 
-0x0B, 0x1B, 0x60, 0xEC,
-0x36, 0xD7, 0x36, 0xAD,
+	0x0B, 0x1B, 0x60, 0xEC,
+	0x36, 0xD7, 0x36, 0xAD,
 
-0x2B, 0x80, 0x60, 0xEC,
-0x0C, 0x1C, 0x60, 0xEC,
+	0x2B, 0x80, 0x60, 0xEC,
+	0x0C, 0x1C, 0x60, 0xEC,
 
-0x3E, 0xD7, 0x3E, 0xAD,
-0x2C, 0x80, 0x60, 0xEC,
+	0x3E, 0xD7, 0x3E, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
 
-0x0B, 0x2B, 0xDE, 0xE8,
-0x1B, 0x80, 0xDE, 0xE8,
+	0x0B, 0x2B, 0xDE, 0xE8,
+	0x1B, 0x80, 0xDE, 0xE8,
 
-0x36, 0x80, 0x36, 0xBD,
-0x3E, 0x80, 0x3E, 0xBD,
+	0x36, 0x80, 0x36, 0xBD,
+	0x3E, 0x80, 0x3E, 0xBD,
 
-0x33, 0xD7, 0x0B, 0xBD,
-0x3B, 0xD7, 0x1B, 0xBD,
+	0x33, 0xD7, 0x0B, 0xBD,
+	0x3B, 0xD7, 0x1B, 0xBD,
 
-0x46, 0x80, 0x46, 0xCF,
-0x57, 0x80, 0x57, 0xCF,
+	0x46, 0x80, 0x46, 0xCF,
+	0x57, 0x80, 0x57, 0xCF,
 
-0x66, 0x33, 0x66, 0xCF,
-0x47, 0x3B, 0x47, 0xCF,
+	0x66, 0x33, 0x66, 0xCF,
+	0x47, 0x3B, 0x47, 0xCF,
 
-0x56, 0x33, 0x56, 0xCF,
-0x67, 0x3B, 0x67, 0xCF,
+	0x56, 0x33, 0x56, 0xCF,
+	0x67, 0x3B, 0x67, 0xCF,
 
-0x0B, 0x48, 0xA0, 0xE8,
-0x1B, 0x58, 0xA0, 0xE8,
+	0x0B, 0x48, 0xA0, 0xE8,
+	0x1B, 0x58, 0xA0, 0xE8,
 
-0x2B, 0x68, 0xA0, 0xE8,
-0x0C, 0x49, 0xA0, 0xE8,
+	0x2B, 0x68, 0xA0, 0xE8,
+	0x0C, 0x49, 0xA0, 0xE8,
 
-0x1C, 0x59, 0xA0, 0xE8,
-0x2C, 0x69, 0xA0, 0xE8,
+	0x1C, 0x59, 0xA0, 0xE8,
+	0x2C, 0x69, 0xA0, 0xE8,
 
-0x0B, 0x00,
-0x1B, 0x00,
-0x2B, 0x00,
-0x00, 0xE0,
+	0x0B, 0x00,
+	0x1B, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
 
-0x0C, 0x00,
-0x1C, 0x00,
-0x2C, 0x00,
-0x00, 0xE0,
+	0x0C, 0x00,
+	0x1C, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
 
-0x0B, 0x65,
-0x1B, 0x65,
-0x2B, 0x65,
-0x00, 0xE0,
+	0x0B, 0x65,
+	0x1B, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
 
-0x0C, 0x65,
-0x1C, 0x65,
-0x2C, 0x65,
-0x00, 0xE0,
+	0x0C, 0x65,
+	0x1C, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
 
-0x0B, 0x1B, 0x60, 0xEC,
-0x34, 0xD7, 0x34, 0xAD,
+	0x0B, 0x1B, 0x60, 0xEC,
+	0x34, 0xD7, 0x34, 0xAD,
 
-0x2B, 0x80, 0x60, 0xEC,
-0x0C, 0x1C, 0x60, 0xEC,
+	0x2B, 0x80, 0x60, 0xEC,
+	0x0C, 0x1C, 0x60, 0xEC,
 
-0x3C, 0xD7, 0x3C, 0xAD,
-0x2C, 0x80, 0x60, 0xEC,
+	0x3C, 0xD7, 0x3C, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
 
-0x0B, 0x2B, 0xDE, 0xE8,
-0x1B, 0x80, 0xDE, 0xE8,
+	0x0B, 0x2B, 0xDE, 0xE8,
+	0x1B, 0x80, 0xDE, 0xE8,
 
-0x34, 0x80, 0x34, 0xBD,
-0x3C, 0x80, 0x3C, 0xBD,
+	0x34, 0x80, 0x34, 0xBD,
+	0x3C, 0x80, 0x3C, 0xBD,
 
-0x33, 0xD7, 0x0B, 0xBD,
-0x3B, 0xD7, 0x1B, 0xBD,
+	0x33, 0xD7, 0x0B, 0xBD,
+	0x3B, 0xD7, 0x1B, 0xBD,
 
-0x48, 0x80, 0x48, 0xCF,
-0x59, 0x80, 0x59, 0xCF,
+	0x48, 0x80, 0x48, 0xCF,
+	0x59, 0x80, 0x59, 0xCF,
 
-0x68, 0x33, 0x68, 0xCF,
-0x49, 0x3B, 0x49, 0xCF,
+	0x68, 0x33, 0x68, 0xCF,
+	0x49, 0x3B, 0x49, 0xCF,
 
-0xA9, 0xFF, 0x20, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0xA9, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x58, 0x33, 0x58, 0xCF,
-0x69, 0x3B, 0x69, 0xCF,
+	0x58, 0x33, 0x58, 0xCF,
+	0x69, 0x3B, 0x69, 0xCF,
 
-0x67, 0xFF, 0x20, 0xEA,
-0x57, 0xC0, 0xBF, 0xEA,
+	0x67, 0xFF, 0x20, 0xEA,
+	0x57, 0xC0, 0xBF, 0xEA,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x00, 0x00, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
 
 };
 
 static unsigned char warp_g400_t2gzsf[] = {
 
-0x00, 0x8A, 0x98, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x8A, 0x98, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x00, 0x00, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
 
-0xFF, 0x80, 0xC0, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x0A, 0x40, 0x50, 0xBF,
-0x2A, 0x40, 0x60, 0xBF,
+	0x0A, 0x40, 0x50, 0xBF,
+	0x2A, 0x40, 0x60, 0xBF,
 
-0x32, 0x41, 0x51, 0xBF,
-0x3A, 0x41, 0x61, 0xBF,
+	0x32, 0x41, 0x51, 0xBF,
+	0x3A, 0x41, 0x61, 0xBF,
 
-0xC3, 0x6B,
-0xD3, 0x6B,
-0x00, 0x8A, 0x98, 0xE9,
+	0xC3, 0x6B,
+	0xD3, 0x6B,
+	0x00, 0x8A, 0x98, 0xE9,
 
-0x73, 0x7B, 0xC8, 0xEC,
-0x96, 0xE2,
-0x41, 0x04,
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x96, 0xE2,
+	0x41, 0x04,
 
-0x7B, 0x43, 0xA0, 0xE8,
-0x73, 0x53, 0xA0, 0xE8,
+	0x7B, 0x43, 0xA0, 0xE8,
+	0x73, 0x53, 0xA0, 0xE8,
 
-0xAD, 0xEE, 0x23, 0x9F,
-0x00, 0xE0,
-0x51, 0x04,
+	0xAD, 0xEE, 0x23, 0x9F,
+	0x00, 0xE0,
+	0x51, 0x04,
 
-0x90, 0xE2,
-0x61, 0x04,
-0x31, 0x46, 0xB1, 0xE8,
+	0x90, 0xE2,
+	0x61, 0x04,
+	0x31, 0x46, 0xB1, 0xE8,
 
-0x51, 0x41, 0xE0, 0xEC,
-0x39, 0x67, 0xB1, 0xE8,
+	0x51, 0x41, 0xE0, 0xEC,
+	0x39, 0x67, 0xB1, 0xE8,
 
-0x00, 0x04,
-0x46, 0xE2,
-0x73, 0x63, 0xA0, 0xE8,
+	0x00, 0x04,
+	0x46, 0xE2,
+	0x73, 0x63, 0xA0, 0xE8,
 
-0x61, 0x41, 0xE0, 0xEC,
-0x31, 0x00,
-0x39, 0x00,
+	0x61, 0x41, 0xE0, 0xEC,
+	0x31, 0x00,
+	0x39, 0x00,
 
-0x8A, 0x80, 0x15, 0xEA,
-0x10, 0x04,
-0x20, 0x04,
+	0x8A, 0x80, 0x15, 0xEA,
+	0x10, 0x04,
+	0x20, 0x04,
 
-0x61, 0x51, 0xE0, 0xEC,
-0x2F, 0x41, 0x60, 0xEA,
+	0x61, 0x51, 0xE0, 0xEC,
+	0x2F, 0x41, 0x60, 0xEA,
 
-0x31, 0x20,
-0x39, 0x20,
-0x1F, 0x42, 0xA0, 0xE8,
+	0x31, 0x20,
+	0x39, 0x20,
+	0x1F, 0x42, 0xA0, 0xE8,
 
-0x2A, 0x42, 0x52, 0xBF,
-0x0F, 0x52, 0xA0, 0xE8,
+	0x2A, 0x42, 0x52, 0xBF,
+	0x0F, 0x52, 0xA0, 0xE8,
 
-0x1A, 0x42, 0x62, 0xBF,
-0x1E, 0x51, 0x60, 0xEA,
+	0x1A, 0x42, 0x62, 0xBF,
+	0x1E, 0x51, 0x60, 0xEA,
 
-0x73, 0x7B, 0xC8, 0xEC,
-0x0E, 0x61, 0x60, 0xEA,
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x0E, 0x61, 0x60, 0xEA,
 
-0x32, 0x40, 0x50, 0xBD,
-0x22, 0x40, 0x60, 0xBD,
+	0x32, 0x40, 0x50, 0xBD,
+	0x22, 0x40, 0x60, 0xBD,
 
-0x12, 0x41, 0x51, 0xBD,
-0x3A, 0x41, 0x61, 0xBD,
+	0x12, 0x41, 0x51, 0xBD,
+	0x3A, 0x41, 0x61, 0xBD,
 
-0xBF, 0x2F, 0x0E, 0xBD,
-0x97, 0xE2,
-0x7B, 0x72,
+	0xBF, 0x2F, 0x0E, 0xBD,
+	0x97, 0xE2,
+	0x7B, 0x72,
 
-0x32, 0x20,
-0x22, 0x20,
-0x12, 0x20,
-0x3A, 0x20,
+	0x32, 0x20,
+	0x22, 0x20,
+	0x12, 0x20,
+	0x3A, 0x20,
 
-0x35, 0x48, 0xB1, 0xE8,
-0x3D, 0x59, 0xB1, 0xE8,
+	0x35, 0x48, 0xB1, 0xE8,
+	0x3D, 0x59, 0xB1, 0xE8,
 
-0x46, 0x31, 0x46, 0xBF,
-0x56, 0x31, 0x56, 0xBF,
+	0x46, 0x31, 0x46, 0xBF,
+	0x56, 0x31, 0x56, 0xBF,
 
-0xB3, 0xE2, 0x2D, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0xB3, 0xE2, 0x2D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x66, 0x31, 0x66, 0xBF,
-0x47, 0x39, 0x47, 0xBF,
+	0x66, 0x31, 0x66, 0xBF,
+	0x47, 0x39, 0x47, 0xBF,
 
-0x57, 0x39, 0x57, 0xBF,
-0x67, 0x39, 0x67, 0xBF,
+	0x57, 0x39, 0x57, 0xBF,
+	0x67, 0x39, 0x67, 0xBF,
 
-0x7B, 0x80, 0x07, 0xEA,
-0x24, 0x41, 0x20, 0xE9,
+	0x7B, 0x80, 0x07, 0xEA,
+	0x24, 0x41, 0x20, 0xE9,
 
-0x35, 0x00,
-0x3D, 0x00,
-0x00, 0xE0,
-0x2D, 0x73,
+	0x35, 0x00,
+	0x3D, 0x00,
+	0x00, 0xE0,
+	0x2D, 0x73,
 
-0x33, 0x72,
-0x0C, 0xE3,
-0x8D, 0x2F, 0x1E, 0xBD,
+	0x33, 0x72,
+	0x0C, 0xE3,
+	0x8D, 0x2F, 0x1E, 0xBD,
 
-0x43, 0x75, 0xF8, 0xEC,
-0x35, 0x20,
-0x3D, 0x20,
+	0x43, 0x75, 0xF8, 0xEC,
+	0x35, 0x20,
+	0x3D, 0x20,
 
-0x43, 0x43, 0x2D, 0xDF,
-0x53, 0x53, 0x2D, 0xDF,
+	0x43, 0x43, 0x2D, 0xDF,
+	0x53, 0x53, 0x2D, 0xDF,
 
-0xAE, 0x1E, 0x0E, 0xBD,
-0x58, 0xE3,
-0x33, 0x66,
+	0xAE, 0x1E, 0x0E, 0xBD,
+	0x58, 0xE3,
+	0x33, 0x66,
 
-0x48, 0x35, 0x48, 0xBF,
-0x58, 0x35, 0x58, 0xBF,
+	0x48, 0x35, 0x48, 0xBF,
+	0x58, 0x35, 0x58, 0xBF,
 
-0x68, 0x35, 0x68, 0xBF,
-0x49, 0x3D, 0x49, 0xBF,
+	0x68, 0x35, 0x68, 0xBF,
+	0x49, 0x3D, 0x49, 0xBF,
 
-0x59, 0x3D, 0x59, 0xBF,
-0x69, 0x3D, 0x69, 0xBF,
+	0x59, 0x3D, 0x59, 0xBF,
+	0x69, 0x3D, 0x69, 0xBF,
 
-0x63, 0x63, 0x2D, 0xDF,
-0x4D, 0x7D, 0xF8, 0xEC,
+	0x63, 0x63, 0x2D, 0xDF,
+	0x4D, 0x7D, 0xF8, 0xEC,
 
-0x59, 0xE3,
-0x00, 0xE0,
-0xB8, 0x38, 0x33, 0xBF,
+	0x59, 0xE3,
+	0x00, 0xE0,
+	0xB8, 0x38, 0x33, 0xBF,
 
-0x2D, 0x73,
-0x30, 0x76,
-0x18, 0x3A, 0x41, 0xE9,
+	0x2D, 0x73,
+	0x30, 0x76,
+	0x18, 0x3A, 0x41, 0xE9,
 
-0x3F, 0x53, 0xA0, 0xE8,
-0x05, 0x80, 0x3D, 0xEA,
+	0x3F, 0x53, 0xA0, 0xE8,
+	0x05, 0x80, 0x3D, 0xEA,
 
-0x37, 0x43, 0xA0, 0xE8,
-0x3D, 0x63, 0xA0, 0xE8,
+	0x37, 0x43, 0xA0, 0xE8,
+	0x3D, 0x63, 0xA0, 0xE8,
 
-0x50, 0x70, 0xF8, 0xEC,
-0x2B, 0x50, 0x3C, 0xE9,
+	0x50, 0x70, 0xF8, 0xEC,
+	0x2B, 0x50, 0x3C, 0xE9,
 
-0x1F, 0x0F, 0xBC, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x1F, 0x0F, 0xBC, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x59, 0x78, 0xF8, 0xEC,
-0x00, 0x80, 0x00, 0xE8,
+	0x59, 0x78, 0xF8, 0xEC,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x15, 0xC0, 0x20, 0xE9,
-0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
 
-0x15, 0xC0, 0x20, 0xE9,
-0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
 
-0x1E, 0x12, 0x41, 0xE9,
-0x1A, 0x22, 0x41, 0xE9,
+	0x1E, 0x12, 0x41, 0xE9,
+	0x1A, 0x22, 0x41, 0xE9,
 
-0x46, 0x37, 0x46, 0xDF,
-0x56, 0x3F, 0x56, 0xDF,
+	0x46, 0x37, 0x46, 0xDF,
+	0x56, 0x3F, 0x56, 0xDF,
 
-0x2B, 0x40, 0x3D, 0xE9,
-0x66, 0x3D, 0x66, 0xDF,
+	0x2B, 0x40, 0x3D, 0xE9,
+	0x66, 0x3D, 0x66, 0xDF,
 
-0x1D, 0x32, 0x41, 0xE9,
-0x67, 0x3D, 0x67, 0xDF,
+	0x1D, 0x32, 0x41, 0xE9,
+	0x67, 0x3D, 0x67, 0xDF,
 
-0x47, 0x37, 0x47, 0xDF,
-0x57, 0x3F, 0x57, 0xDF,
+	0x47, 0x37, 0x47, 0xDF,
+	0x57, 0x3F, 0x57, 0xDF,
 
-0x2A, 0x40, 0x20, 0xE9,
-0x59, 0x3F, 0x59, 0xDF,
+	0x2A, 0x40, 0x20, 0xE9,
+	0x59, 0x3F, 0x59, 0xDF,
 
-0x16, 0x30, 0x20, 0xE9,
-0x69, 0x3D, 0x69, 0xDF,
+	0x16, 0x30, 0x20, 0xE9,
+	0x69, 0x3D, 0x69, 0xDF,
 
-0x48, 0x37, 0x48, 0xDF,
-0x58, 0x3F, 0x58, 0xDF,
+	0x48, 0x37, 0x48, 0xDF,
+	0x58, 0x3F, 0x58, 0xDF,
 
-0x68, 0x3D, 0x68, 0xDF,
-0x49, 0x37, 0x49, 0xDF,
+	0x68, 0x3D, 0x68, 0xDF,
+	0x49, 0x37, 0x49, 0xDF,
 
-0x32, 0x32, 0x2D, 0xDF,
-0x22, 0x22, 0x2D, 0xDF,
+	0x32, 0x32, 0x2D, 0xDF,
+	0x22, 0x22, 0x2D, 0xDF,
 
-0x12, 0x12, 0x2D, 0xDF,
-0x3A, 0x3A, 0x2D, 0xDF,
+	0x12, 0x12, 0x2D, 0xDF,
+	0x3A, 0x3A, 0x2D, 0xDF,
 
-0x0F, 0xCF, 0x74, 0xC2,
-0x37, 0xCF, 0x74, 0xC4,
+	0x0F, 0xCF, 0x74, 0xC2,
+	0x37, 0xCF, 0x74, 0xC4,
 
-0x0A, 0x44, 0x54, 0xB0,
-0x02, 0x44, 0x64, 0xB0,
+	0x0A, 0x44, 0x54, 0xB0,
+	0x02, 0x44, 0x64, 0xB0,
 
-0x3D, 0xCF, 0x74, 0xC0,
-0x34, 0x37, 0x20, 0xE9,
+	0x3D, 0xCF, 0x74, 0xC0,
+	0x34, 0x37, 0x20, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x38, 0x0F, 0x20, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x38, 0x0F, 0x20, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x3C, 0x3D, 0x20, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3C, 0x3D, 0x20, 0xE9,
 
-0x2A, 0x44, 0x54, 0xB2,
-0x1A, 0x44, 0x64, 0xB2,
+	0x2A, 0x44, 0x54, 0xB2,
+	0x1A, 0x44, 0x64, 0xB2,
 
-0x36, 0x80, 0x3A, 0xEA,
-0x0A, 0x20,
-0x02, 0x20,
+	0x36, 0x80, 0x3A, 0xEA,
+	0x0A, 0x20,
+	0x02, 0x20,
 
-0x0F, 0xCF, 0x75, 0xC0,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x0F, 0xCF, 0x75, 0xC0,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x32, 0x31, 0x5F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x32, 0x31, 0x5F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x33, 0x39, 0x5F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x33, 0x39, 0x5F, 0xE9,
 
-0x3D, 0xCF, 0x75, 0xC2,
-0x37, 0xCF, 0x75, 0xC4,
+	0x3D, 0xCF, 0x75, 0xC2,
+	0x37, 0xCF, 0x75, 0xC4,
 
-0x31, 0x53, 0x2F, 0x9F,
-0xA6, 0x0F, 0x20, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA6, 0x0F, 0x20, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0xA3, 0x3D, 0x20, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA3, 0x3D, 0x20, 0xE9,
 
-0x2A, 0x44, 0x54, 0xB4,
-0x1A, 0x44, 0x64, 0xB4,
+	0x2A, 0x44, 0x54, 0xB4,
+	0x1A, 0x44, 0x64, 0xB4,
 
-0x0A, 0x45, 0x55, 0xB0,
-0x02, 0x45, 0x65, 0xB0,
+	0x0A, 0x45, 0x55, 0xB0,
+	0x02, 0x45, 0x65, 0xB0,
 
-0x88, 0x73, 0x5E, 0xE9,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x88, 0x73, 0x5E, 0xE9,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0xA0, 0x37, 0x20, 0xE9,
-0x0A, 0x20,
-0x02, 0x20,
+	0xA0, 0x37, 0x20, 0xE9,
+	0x0A, 0x20,
+	0x02, 0x20,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x3E, 0x30, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x3E, 0x30, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x3F, 0x38, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3F, 0x38, 0x4F, 0xE9,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x3A, 0x31, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x3A, 0x31, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x3B, 0x39, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x3B, 0x39, 0x4F, 0xE9,
 
-0x2A, 0x45, 0x55, 0xB2,
-0x1A, 0x45, 0x65, 0xB2,
+	0x2A, 0x45, 0x55, 0xB2,
+	0x1A, 0x45, 0x65, 0xB2,
 
-0x0A, 0x45, 0x55, 0xB4,
-0x02, 0x45, 0x65, 0xB4,
+	0x0A, 0x45, 0x55, 0xB4,
+	0x02, 0x45, 0x65, 0xB4,
 
-0x0F, 0xCF, 0x75, 0xC6,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x0F, 0xCF, 0x75, 0xC6,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0xA7, 0x30, 0x4F, 0xE9,
-0x0A, 0x20,
-0x02, 0x20,
+	0xA7, 0x30, 0x4F, 0xE9,
+	0x0A, 0x20,
+	0x02, 0x20,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x31, 0x0F, 0x20, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x31, 0x0F, 0x20, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0xA8, 0x38, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA8, 0x38, 0x4F, 0xE9,
 
-0x2A, 0x45, 0x55, 0xB6,
-0x1A, 0x45, 0x65, 0xB6,
+	0x2A, 0x45, 0x55, 0xB6,
+	0x1A, 0x45, 0x65, 0xB6,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x36, 0x31, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x36, 0x31, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x37, 0x39, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x37, 0x39, 0x4F, 0xE9,
 
-0x00, 0x80, 0x00, 0xE8,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x00, 0x80, 0x00, 0xE8,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0x2A, 0x46, 0x56, 0xBF,
-0x1A, 0x46, 0x66, 0xBF,
+	0x2A, 0x46, 0x56, 0xBF,
+	0x1A, 0x46, 0x66, 0xBF,
 
-0x31, 0x53, 0x2F, 0x9F,
-0xA4, 0x31, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA4, 0x31, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0xA5, 0x39, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA5, 0x39, 0x4F, 0xE9,
 
-0x0A, 0x47, 0x57, 0xBF,
-0x02, 0x47, 0x67, 0xBF,
+	0x0A, 0x47, 0x57, 0xBF,
+	0x02, 0x47, 0x67, 0xBF,
 
-0x31, 0x53, 0x2F, 0x9F,
-0xA1, 0x30, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA1, 0x30, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0xA2, 0x38, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA2, 0x38, 0x4F, 0xE9,
 
-0x2A, 0x43, 0x53, 0xBF,
-0x1A, 0x43, 0x63, 0xBF,
+	0x2A, 0x43, 0x53, 0xBF,
+	0x1A, 0x43, 0x63, 0xBF,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x35, 0x31, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x35, 0x31, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x39, 0x39, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x39, 0x39, 0x4F, 0xE9,
 
-0x0A, 0x48, 0x58, 0xBF,
-0x02, 0x48, 0x68, 0xBF,
+	0x0A, 0x48, 0x58, 0xBF,
+	0x02, 0x48, 0x68, 0xBF,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x80, 0x31, 0x57, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x80, 0x31, 0x57, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x81, 0x39, 0x57, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x81, 0x39, 0x57, 0xE9,
 
-0x2A, 0x49, 0x59, 0xBF,
-0x1A, 0x49, 0x69, 0xBF,
+	0x2A, 0x49, 0x59, 0xBF,
+	0x1A, 0x49, 0x69, 0xBF,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x82, 0x30, 0x57, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x82, 0x30, 0x57, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x83, 0x38, 0x57, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x83, 0x38, 0x57, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x84, 0x31, 0x5E, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x84, 0x31, 0x5E, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x85, 0x39, 0x5E, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x85, 0x39, 0x5E, 0xE9,
 
-0x86, 0x76, 0x57, 0xE9,
-0x8A, 0x36, 0x20, 0xE9,
+	0x86, 0x76, 0x57, 0xE9,
+	0x8A, 0x36, 0x20, 0xE9,
 
-0x87, 0x77, 0x57, 0xE9,
-0x8B, 0x3E, 0xBF, 0xEA,
+	0x87, 0x77, 0x57, 0xE9,
+	0x8B, 0x3E, 0xBF, 0xEA,
 
-0x80, 0x30, 0x57, 0xE9,
-0x81, 0x38, 0x57, 0xE9,
+	0x80, 0x30, 0x57, 0xE9,
+	0x81, 0x38, 0x57, 0xE9,
 
-0x82, 0x31, 0x57, 0xE9,
-0x86, 0x78, 0x57, 0xE9,
+	0x82, 0x31, 0x57, 0xE9,
+	0x86, 0x78, 0x57, 0xE9,
 
-0x83, 0x39, 0x57, 0xE9,
-0x87, 0x79, 0x57, 0xE9,
+	0x83, 0x39, 0x57, 0xE9,
+	0x87, 0x79, 0x57, 0xE9,
 
-0x30, 0x1F, 0x5F, 0xE9,
-0x8A, 0x34, 0x20, 0xE9,
+	0x30, 0x1F, 0x5F, 0xE9,
+	0x8A, 0x34, 0x20, 0xE9,
 
-0x8B, 0x3C, 0x20, 0xE9,
-0x37, 0x50, 0x60, 0xBD,
+	0x8B, 0x3C, 0x20, 0xE9,
+	0x37, 0x50, 0x60, 0xBD,
 
-0x57, 0x0D, 0x20, 0xE9,
-0x35, 0x51, 0x61, 0xBD,
+	0x57, 0x0D, 0x20, 0xE9,
+	0x35, 0x51, 0x61, 0xBD,
 
-0x2B, 0x50, 0x20, 0xE9,
-0x1D, 0x37, 0xE1, 0xEA,
+	0x2B, 0x50, 0x20, 0xE9,
+	0x1D, 0x37, 0xE1, 0xEA,
 
-0x1E, 0x35, 0xE1, 0xEA,
-0x00, 0xE0,
-0x0E, 0x77,
+	0x1E, 0x35, 0xE1, 0xEA,
+	0x00, 0xE0,
+	0x0E, 0x77,
 
-0x24, 0x51, 0x20, 0xE9,
-0x8D, 0xFF, 0x20, 0xEA,
+	0x24, 0x51, 0x20, 0xE9,
+	0x8D, 0xFF, 0x20, 0xEA,
 
-0x16, 0x0E, 0x20, 0xE9,
-0x57, 0x2E, 0xBF, 0xEA,
+	0x16, 0x0E, 0x20, 0xE9,
+	0x57, 0x2E, 0xBF, 0xEA,
 
-0x0B, 0x46, 0xA0, 0xE8,
-0x1B, 0x56, 0xA0, 0xE8,
+	0x0B, 0x46, 0xA0, 0xE8,
+	0x1B, 0x56, 0xA0, 0xE8,
 
-0x2B, 0x66, 0xA0, 0xE8,
-0x0C, 0x47, 0xA0, 0xE8,
+	0x2B, 0x66, 0xA0, 0xE8,
+	0x0C, 0x47, 0xA0, 0xE8,
 
-0x1C, 0x57, 0xA0, 0xE8,
-0x2C, 0x67, 0xA0, 0xE8,
+	0x1C, 0x57, 0xA0, 0xE8,
+	0x2C, 0x67, 0xA0, 0xE8,
 
-0x0B, 0x00,
-0x1B, 0x00,
-0x2B, 0x00,
-0x00, 0xE0,
+	0x0B, 0x00,
+	0x1B, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
 
-0x0C, 0x00,
-0x1C, 0x00,
-0x2C, 0x00,
-0x00, 0xE0,
+	0x0C, 0x00,
+	0x1C, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
 
-0x0B, 0x65,
-0x1B, 0x65,
-0x2B, 0x65,
-0x00, 0xE0,
+	0x0B, 0x65,
+	0x1B, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
 
-0x0C, 0x65,
-0x1C, 0x65,
-0x2C, 0x65,
-0x00, 0xE0,
+	0x0C, 0x65,
+	0x1C, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
 
-0x0B, 0x1B, 0x60, 0xEC,
-0x36, 0xD7, 0x36, 0xAD,
+	0x0B, 0x1B, 0x60, 0xEC,
+	0x36, 0xD7, 0x36, 0xAD,
 
-0x2B, 0x80, 0x60, 0xEC,
-0x0C, 0x1C, 0x60, 0xEC,
+	0x2B, 0x80, 0x60, 0xEC,
+	0x0C, 0x1C, 0x60, 0xEC,
 
-0x3E, 0xD7, 0x3E, 0xAD,
-0x2C, 0x80, 0x60, 0xEC,
+	0x3E, 0xD7, 0x3E, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
 
-0x0B, 0x2B, 0xDE, 0xE8,
-0x1B, 0x80, 0xDE, 0xE8,
+	0x0B, 0x2B, 0xDE, 0xE8,
+	0x1B, 0x80, 0xDE, 0xE8,
 
-0x36, 0x80, 0x36, 0xBD,
-0x3E, 0x80, 0x3E, 0xBD,
+	0x36, 0x80, 0x36, 0xBD,
+	0x3E, 0x80, 0x3E, 0xBD,
 
-0x33, 0xD7, 0x0B, 0xBD,
-0x3B, 0xD7, 0x1B, 0xBD,
+	0x33, 0xD7, 0x0B, 0xBD,
+	0x3B, 0xD7, 0x1B, 0xBD,
 
-0x46, 0x80, 0x46, 0xCF,
-0x57, 0x80, 0x57, 0xCF,
+	0x46, 0x80, 0x46, 0xCF,
+	0x57, 0x80, 0x57, 0xCF,
 
-0x66, 0x33, 0x66, 0xCF,
-0x47, 0x3B, 0x47, 0xCF,
+	0x66, 0x33, 0x66, 0xCF,
+	0x47, 0x3B, 0x47, 0xCF,
 
-0x56, 0x33, 0x56, 0xCF,
-0x67, 0x3B, 0x67, 0xCF,
+	0x56, 0x33, 0x56, 0xCF,
+	0x67, 0x3B, 0x67, 0xCF,
 
-0x0B, 0x48, 0xA0, 0xE8,
-0x1B, 0x58, 0xA0, 0xE8,
+	0x0B, 0x48, 0xA0, 0xE8,
+	0x1B, 0x58, 0xA0, 0xE8,
 
-0x2B, 0x68, 0xA0, 0xE8,
-0x0C, 0x49, 0xA0, 0xE8,
+	0x2B, 0x68, 0xA0, 0xE8,
+	0x0C, 0x49, 0xA0, 0xE8,
 
-0x1C, 0x59, 0xA0, 0xE8,
-0x2C, 0x69, 0xA0, 0xE8,
+	0x1C, 0x59, 0xA0, 0xE8,
+	0x2C, 0x69, 0xA0, 0xE8,
 
-0x0B, 0x00,
-0x1B, 0x00,
-0x2B, 0x00,
-0x00, 0xE0,
+	0x0B, 0x00,
+	0x1B, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
 
-0x0C, 0x00,
-0x1C, 0x00,
-0x2C, 0x00,
-0x00, 0xE0,
+	0x0C, 0x00,
+	0x1C, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
 
-0x0B, 0x65,
-0x1B, 0x65,
-0x2B, 0x65,
-0x00, 0xE0,
+	0x0B, 0x65,
+	0x1B, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
 
-0x0C, 0x65,
-0x1C, 0x65,
-0x2C, 0x65,
-0x00, 0xE0,
+	0x0C, 0x65,
+	0x1C, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
 
-0x0B, 0x1B, 0x60, 0xEC,
-0x34, 0xD7, 0x34, 0xAD,
+	0x0B, 0x1B, 0x60, 0xEC,
+	0x34, 0xD7, 0x34, 0xAD,
 
-0x2B, 0x80, 0x60, 0xEC,
-0x0C, 0x1C, 0x60, 0xEC,
+	0x2B, 0x80, 0x60, 0xEC,
+	0x0C, 0x1C, 0x60, 0xEC,
 
-0x3C, 0xD7, 0x3C, 0xAD,
-0x2C, 0x80, 0x60, 0xEC,
+	0x3C, 0xD7, 0x3C, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
 
-0x0B, 0x2B, 0xDE, 0xE8,
-0x1B, 0x80, 0xDE, 0xE8,
+	0x0B, 0x2B, 0xDE, 0xE8,
+	0x1B, 0x80, 0xDE, 0xE8,
 
-0x34, 0x80, 0x34, 0xBD,
-0x3C, 0x80, 0x3C, 0xBD,
+	0x34, 0x80, 0x34, 0xBD,
+	0x3C, 0x80, 0x3C, 0xBD,
 
-0x33, 0xD7, 0x0B, 0xBD,
-0x3B, 0xD7, 0x1B, 0xBD,
+	0x33, 0xD7, 0x0B, 0xBD,
+	0x3B, 0xD7, 0x1B, 0xBD,
 
-0x48, 0x80, 0x48, 0xCF,
-0x59, 0x80, 0x59, 0xCF,
+	0x48, 0x80, 0x48, 0xCF,
+	0x59, 0x80, 0x59, 0xCF,
 
-0x68, 0x33, 0x68, 0xCF,
-0x49, 0x3B, 0x49, 0xCF,
+	0x68, 0x33, 0x68, 0xCF,
+	0x49, 0x3B, 0x49, 0xCF,
 
-0xAD, 0xFF, 0x20, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0xAD, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x58, 0x33, 0x58, 0xCF,
-0x69, 0x3B, 0x69, 0xCF,
+	0x58, 0x33, 0x58, 0xCF,
+	0x69, 0x3B, 0x69, 0xCF,
 
-0x6B, 0xFF, 0x20, 0xEA,
-0x57, 0xC0, 0xBF, 0xEA,
+	0x6B, 0xFF, 0x20, 0xEA,
+	0x57, 0xC0, 0xBF, 0xEA,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x00, 0x00, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
 
 };
 
 static unsigned char warp_g400_tgz[] = {
 
-0x00, 0x88, 0x98, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x88, 0x98, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x00, 0x00, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
 
-0xFF, 0x80, 0xC0, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x22, 0x40, 0x48, 0xBF,
-0x2A, 0x40, 0x50, 0xBF,
+	0x22, 0x40, 0x48, 0xBF,
+	0x2A, 0x40, 0x50, 0xBF,
 
-0x32, 0x41, 0x49, 0xBF,
-0x3A, 0x41, 0x51, 0xBF,
+	0x32, 0x41, 0x49, 0xBF,
+	0x3A, 0x41, 0x51, 0xBF,
 
-0xC3, 0x6B,
-0xCB, 0x6B,
-0x00, 0x88, 0x98, 0xE9,
+	0xC3, 0x6B,
+	0xCB, 0x6B,
+	0x00, 0x88, 0x98, 0xE9,
 
-0x73, 0x7B, 0xC8, 0xEC,
-0x96, 0xE2,
-0x41, 0x04,
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x96, 0xE2,
+	0x41, 0x04,
 
-0x7B, 0x43, 0xA0, 0xE8,
-0x73, 0x4B, 0xA0, 0xE8,
+	0x7B, 0x43, 0xA0, 0xE8,
+	0x73, 0x4B, 0xA0, 0xE8,
 
-0xAD, 0xEE, 0x29, 0x9F,
-0x00, 0xE0,
-0x49, 0x04,
+	0xAD, 0xEE, 0x29, 0x9F,
+	0x00, 0xE0,
+	0x49, 0x04,
 
-0x90, 0xE2,
-0x51, 0x04,
-0x31, 0x46, 0xB1, 0xE8,
+	0x90, 0xE2,
+	0x51, 0x04,
+	0x31, 0x46, 0xB1, 0xE8,
 
-0x49, 0x41, 0xC0, 0xEC,
-0x39, 0x57, 0xB1, 0xE8,
+	0x49, 0x41, 0xC0, 0xEC,
+	0x39, 0x57, 0xB1, 0xE8,
 
-0x00, 0x04,
-0x46, 0xE2,
-0x73, 0x53, 0xA0, 0xE8,
+	0x00, 0x04,
+	0x46, 0xE2,
+	0x73, 0x53, 0xA0, 0xE8,
 
-0x51, 0x41, 0xC0, 0xEC,
-0x31, 0x00,
-0x39, 0x00,
+	0x51, 0x41, 0xC0, 0xEC,
+	0x31, 0x00,
+	0x39, 0x00,
 
-0x58, 0x80, 0x15, 0xEA,
-0x08, 0x04,
-0x10, 0x04,
+	0x58, 0x80, 0x15, 0xEA,
+	0x08, 0x04,
+	0x10, 0x04,
 
-0x51, 0x49, 0xC0, 0xEC,
-0x2F, 0x41, 0x60, 0xEA,
+	0x51, 0x49, 0xC0, 0xEC,
+	0x2F, 0x41, 0x60, 0xEA,
 
-0x31, 0x20,
-0x39, 0x20,
-0x1F, 0x42, 0xA0, 0xE8,
+	0x31, 0x20,
+	0x39, 0x20,
+	0x1F, 0x42, 0xA0, 0xE8,
 
-0x2A, 0x42, 0x4A, 0xBF,
-0x27, 0x4A, 0xA0, 0xE8,
+	0x2A, 0x42, 0x4A, 0xBF,
+	0x27, 0x4A, 0xA0, 0xE8,
 
-0x1A, 0x42, 0x52, 0xBF,
-0x1E, 0x49, 0x60, 0xEA,
+	0x1A, 0x42, 0x52, 0xBF,
+	0x1E, 0x49, 0x60, 0xEA,
 
-0x73, 0x7B, 0xC8, 0xEC,
-0x26, 0x51, 0x60, 0xEA,
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x26, 0x51, 0x60, 0xEA,
 
-0x32, 0x40, 0x48, 0xBD,
-0x22, 0x40, 0x50, 0xBD,
+	0x32, 0x40, 0x48, 0xBD,
+	0x22, 0x40, 0x50, 0xBD,
 
-0x12, 0x41, 0x49, 0xBD,
-0x3A, 0x41, 0x51, 0xBD,
+	0x12, 0x41, 0x49, 0xBD,
+	0x3A, 0x41, 0x51, 0xBD,
 
-0xBF, 0x2F, 0x26, 0xBD,
-0x00, 0xE0,
-0x7B, 0x72,
+	0xBF, 0x2F, 0x26, 0xBD,
+	0x00, 0xE0,
+	0x7B, 0x72,
 
-0x32, 0x20,
-0x22, 0x20,
-0x12, 0x20,
-0x3A, 0x20,
+	0x32, 0x20,
+	0x22, 0x20,
+	0x12, 0x20,
+	0x3A, 0x20,
 
-0x46, 0x31, 0x46, 0xBF,
-0x4E, 0x31, 0x4E, 0xBF,
+	0x46, 0x31, 0x46, 0xBF,
+	0x4E, 0x31, 0x4E, 0xBF,
 
-0xB3, 0xE2, 0x2D, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0xB3, 0xE2, 0x2D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x56, 0x31, 0x56, 0xBF,
-0x47, 0x39, 0x47, 0xBF,
+	0x56, 0x31, 0x56, 0xBF,
+	0x47, 0x39, 0x47, 0xBF,
 
-0x4F, 0x39, 0x4F, 0xBF,
-0x57, 0x39, 0x57, 0xBF,
+	0x4F, 0x39, 0x4F, 0xBF,
+	0x57, 0x39, 0x57, 0xBF,
 
-0x4A, 0x80, 0x07, 0xEA,
-0x24, 0x41, 0x20, 0xE9,
+	0x4A, 0x80, 0x07, 0xEA,
+	0x24, 0x41, 0x20, 0xE9,
 
-0x42, 0x73, 0xF8, 0xEC,
-0x00, 0xE0,
-0x2D, 0x73,
+	0x42, 0x73, 0xF8, 0xEC,
+	0x00, 0xE0,
+	0x2D, 0x73,
 
-0x33, 0x72,
-0x0C, 0xE3,
-0xA5, 0x2F, 0x1E, 0xBD,
+	0x33, 0x72,
+	0x0C, 0xE3,
+	0xA5, 0x2F, 0x1E, 0xBD,
 
-0x43, 0x43, 0x2D, 0xDF,
-0x4B, 0x4B, 0x2D, 0xDF,
+	0x43, 0x43, 0x2D, 0xDF,
+	0x4B, 0x4B, 0x2D, 0xDF,
 
-0xAE, 0x1E, 0x26, 0xBD,
-0x58, 0xE3,
-0x33, 0x66,
+	0xAE, 0x1E, 0x26, 0xBD,
+	0x58, 0xE3,
+	0x33, 0x66,
 
-0x53, 0x53, 0x2D, 0xDF,
-0x00, 0x80, 0x00, 0xE8,
+	0x53, 0x53, 0x2D, 0xDF,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xB8, 0x38, 0x33, 0xBF,
-0x00, 0xE0,
-0x59, 0xE3,
+	0xB8, 0x38, 0x33, 0xBF,
+	0x00, 0xE0,
+	0x59, 0xE3,
 
-0x1E, 0x12, 0x41, 0xE9,
-0x1A, 0x22, 0x41, 0xE9,
+	0x1E, 0x12, 0x41, 0xE9,
+	0x1A, 0x22, 0x41, 0xE9,
 
-0x2B, 0x40, 0x3D, 0xE9,
-0x3F, 0x4B, 0xA0, 0xE8,
+	0x2B, 0x40, 0x3D, 0xE9,
+	0x3F, 0x4B, 0xA0, 0xE8,
 
-0x2D, 0x73,
-0x30, 0x76,
-0x05, 0x80, 0x3D, 0xEA,
+	0x2D, 0x73,
+	0x30, 0x76,
+	0x05, 0x80, 0x3D, 0xEA,
 
-0x37, 0x43, 0xA0, 0xE8,
-0x3D, 0x53, 0xA0, 0xE8,
+	0x37, 0x43, 0xA0, 0xE8,
+	0x3D, 0x53, 0xA0, 0xE8,
 
-0x48, 0x70, 0xF8, 0xEC,
-0x2B, 0x48, 0x3C, 0xE9,
+	0x48, 0x70, 0xF8, 0xEC,
+	0x2B, 0x48, 0x3C, 0xE9,
 
-0x1F, 0x27, 0xBC, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x1F, 0x27, 0xBC, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x15, 0xC0, 0x20, 0xE9,
-0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
 
-0x15, 0xC0, 0x20, 0xE9,
-0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
 
-0x18, 0x3A, 0x41, 0xE9,
-0x1D, 0x32, 0x41, 0xE9,
+	0x18, 0x3A, 0x41, 0xE9,
+	0x1D, 0x32, 0x41, 0xE9,
 
-0x2A, 0x40, 0x20, 0xE9,
-0x56, 0x3D, 0x56, 0xDF,
+	0x2A, 0x40, 0x20, 0xE9,
+	0x56, 0x3D, 0x56, 0xDF,
 
-0x46, 0x37, 0x46, 0xDF,
-0x4E, 0x3F, 0x4E, 0xDF,
+	0x46, 0x37, 0x46, 0xDF,
+	0x4E, 0x3F, 0x4E, 0xDF,
 
-0x16, 0x30, 0x20, 0xE9,
-0x4F, 0x3F, 0x4F, 0xDF,
+	0x16, 0x30, 0x20, 0xE9,
+	0x4F, 0x3F, 0x4F, 0xDF,
 
-0x32, 0x32, 0x2D, 0xDF,
-0x22, 0x22, 0x2D, 0xDF,
+	0x32, 0x32, 0x2D, 0xDF,
+	0x22, 0x22, 0x2D, 0xDF,
 
-0x12, 0x12, 0x2D, 0xDF,
-0x3A, 0x3A, 0x2D, 0xDF,
+	0x12, 0x12, 0x2D, 0xDF,
+	0x3A, 0x3A, 0x2D, 0xDF,
 
-0x47, 0x37, 0x47, 0xDF,
-0x57, 0x3D, 0x57, 0xDF,
+	0x47, 0x37, 0x47, 0xDF,
+	0x57, 0x3D, 0x57, 0xDF,
 
-0x3D, 0xCF, 0x74, 0xC0,
-0x37, 0xCF, 0x74, 0xC4,
+	0x3D, 0xCF, 0x74, 0xC0,
+	0x37, 0xCF, 0x74, 0xC4,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x34, 0x80, 0x20, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x34, 0x80, 0x20, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x3C, 0x3D, 0x20, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3C, 0x3D, 0x20, 0xE9,
 
-0x0A, 0x44, 0x4C, 0xB0,
-0x02, 0x44, 0x54, 0xB0,
+	0x0A, 0x44, 0x4C, 0xB0,
+	0x02, 0x44, 0x54, 0xB0,
 
-0x2A, 0x44, 0x4C, 0xB2,
-0x1A, 0x44, 0x54, 0xB2,
+	0x2A, 0x44, 0x4C, 0xB2,
+	0x1A, 0x44, 0x54, 0xB2,
 
-0x1D, 0x80, 0x3A, 0xEA,
-0x0A, 0x20,
-0x02, 0x20,
+	0x1D, 0x80, 0x3A, 0xEA,
+	0x0A, 0x20,
+	0x02, 0x20,
 
-0x3D, 0xCF, 0x74, 0xC2,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x3D, 0xCF, 0x74, 0xC2,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x32, 0x31, 0x5F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x32, 0x31, 0x5F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x33, 0x39, 0x5F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x33, 0x39, 0x5F, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x2A, 0x44, 0x4C, 0xB4,
-0x1A, 0x44, 0x54, 0xB4,
+	0x2A, 0x44, 0x4C, 0xB4,
+	0x1A, 0x44, 0x54, 0xB4,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x38, 0x3D, 0x20, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x38, 0x3D, 0x20, 0xE9,
 
-0x88, 0x73, 0x5E, 0xE9,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x88, 0x73, 0x5E, 0xE9,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0x2A, 0x46, 0x4E, 0xBF,
-0x1A, 0x46, 0x56, 0xBF,
+	0x2A, 0x46, 0x4E, 0xBF,
+	0x1A, 0x46, 0x56, 0xBF,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x3E, 0x30, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x3E, 0x30, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x3F, 0x38, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3F, 0x38, 0x4F, 0xE9,
 
-0x0A, 0x47, 0x4F, 0xBF,
-0x02, 0x47, 0x57, 0xBF,
+	0x0A, 0x47, 0x4F, 0xBF,
+	0x02, 0x47, 0x57, 0xBF,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x3A, 0x31, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x3A, 0x31, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x3B, 0x39, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3B, 0x39, 0x4F, 0xE9,
 
-0x2A, 0x43, 0x4B, 0xBF,
-0x1A, 0x43, 0x53, 0xBF,
+	0x2A, 0x43, 0x4B, 0xBF,
+	0x1A, 0x43, 0x53, 0xBF,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x36, 0x31, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x36, 0x31, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x37, 0x39, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x37, 0x39, 0x4F, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x80, 0x31, 0x57, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x80, 0x31, 0x57, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x81, 0x39, 0x57, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x81, 0x39, 0x57, 0xE9,
 
-0x37, 0x48, 0x50, 0xBD,
-0x8A, 0x36, 0x20, 0xE9,
+	0x37, 0x48, 0x50, 0xBD,
+	0x8A, 0x36, 0x20, 0xE9,
 
-0x86, 0x76, 0x57, 0xE9,
-0x8B, 0x3E, 0x20, 0xE9,
+	0x86, 0x76, 0x57, 0xE9,
+	0x8B, 0x3E, 0x20, 0xE9,
 
-0x82, 0x30, 0x57, 0xE9,
-0x87, 0x77, 0x57, 0xE9,
+	0x82, 0x30, 0x57, 0xE9,
+	0x87, 0x77, 0x57, 0xE9,
 
-0x83, 0x38, 0x57, 0xE9,
-0x35, 0x49, 0x51, 0xBD,
+	0x83, 0x38, 0x57, 0xE9,
+	0x35, 0x49, 0x51, 0xBD,
 
-0x84, 0x31, 0x5E, 0xE9,
-0x30, 0x1F, 0x5F, 0xE9,
+	0x84, 0x31, 0x5E, 0xE9,
+	0x30, 0x1F, 0x5F, 0xE9,
 
-0x85, 0x39, 0x5E, 0xE9,
-0x57, 0x25, 0x20, 0xE9,
+	0x85, 0x39, 0x5E, 0xE9,
+	0x57, 0x25, 0x20, 0xE9,
 
-0x2B, 0x48, 0x20, 0xE9,
-0x1D, 0x37, 0xE1, 0xEA,
+	0x2B, 0x48, 0x20, 0xE9,
+	0x1D, 0x37, 0xE1, 0xEA,
 
-0x1E, 0x35, 0xE1, 0xEA,
-0x00, 0xE0,
-0x26, 0x77,
+	0x1E, 0x35, 0xE1, 0xEA,
+	0x00, 0xE0,
+	0x26, 0x77,
 
-0x24, 0x49, 0x20, 0xE9,
-0xAF, 0xFF, 0x20, 0xEA,
+	0x24, 0x49, 0x20, 0xE9,
+	0xAF, 0xFF, 0x20, 0xEA,
 
-0x16, 0x26, 0x20, 0xE9,
-0x57, 0x2E, 0xBF, 0xEA,
+	0x16, 0x26, 0x20, 0xE9,
+	0x57, 0x2E, 0xBF, 0xEA,
 
-0x1C, 0x46, 0xA0, 0xE8,
-0x23, 0x4E, 0xA0, 0xE8,
+	0x1C, 0x46, 0xA0, 0xE8,
+	0x23, 0x4E, 0xA0, 0xE8,
 
-0x2B, 0x56, 0xA0, 0xE8,
-0x1D, 0x47, 0xA0, 0xE8,
+	0x2B, 0x56, 0xA0, 0xE8,
+	0x1D, 0x47, 0xA0, 0xE8,
 
-0x24, 0x4F, 0xA0, 0xE8,
-0x2C, 0x57, 0xA0, 0xE8,
+	0x24, 0x4F, 0xA0, 0xE8,
+	0x2C, 0x57, 0xA0, 0xE8,
 
-0x1C, 0x00,
-0x23, 0x00,
-0x2B, 0x00,
-0x00, 0xE0,
+	0x1C, 0x00,
+	0x23, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
 
-0x1D, 0x00,
-0x24, 0x00,
-0x2C, 0x00,
-0x00, 0xE0,
+	0x1D, 0x00,
+	0x24, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
 
-0x1C, 0x65,
-0x23, 0x65,
-0x2B, 0x65,
-0x00, 0xE0,
+	0x1C, 0x65,
+	0x23, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
 
-0x1D, 0x65,
-0x24, 0x65,
-0x2C, 0x65,
-0x00, 0xE0,
+	0x1D, 0x65,
+	0x24, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
 
-0x1C, 0x23, 0x60, 0xEC,
-0x36, 0xD7, 0x36, 0xAD,
+	0x1C, 0x23, 0x60, 0xEC,
+	0x36, 0xD7, 0x36, 0xAD,
 
-0x2B, 0x80, 0x60, 0xEC,
-0x1D, 0x24, 0x60, 0xEC,
+	0x2B, 0x80, 0x60, 0xEC,
+	0x1D, 0x24, 0x60, 0xEC,
 
-0x3E, 0xD7, 0x3E, 0xAD,
-0x2C, 0x80, 0x60, 0xEC,
+	0x3E, 0xD7, 0x3E, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
 
-0x1C, 0x2B, 0xDE, 0xE8,
-0x23, 0x80, 0xDE, 0xE8,
+	0x1C, 0x2B, 0xDE, 0xE8,
+	0x23, 0x80, 0xDE, 0xE8,
 
-0x36, 0x80, 0x36, 0xBD,
-0x3E, 0x80, 0x3E, 0xBD,
+	0x36, 0x80, 0x36, 0xBD,
+	0x3E, 0x80, 0x3E, 0xBD,
 
-0x33, 0xD7, 0x1C, 0xBD,
-0x3B, 0xD7, 0x23, 0xBD,
+	0x33, 0xD7, 0x1C, 0xBD,
+	0x3B, 0xD7, 0x23, 0xBD,
 
-0x46, 0x80, 0x46, 0xCF,
-0x4F, 0x80, 0x4F, 0xCF,
+	0x46, 0x80, 0x46, 0xCF,
+	0x4F, 0x80, 0x4F, 0xCF,
 
-0x56, 0x33, 0x56, 0xCF,
-0x47, 0x3B, 0x47, 0xCF,
+	0x56, 0x33, 0x56, 0xCF,
+	0x47, 0x3B, 0x47, 0xCF,
 
-0xD6, 0xFF, 0x20, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0xD6, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x4E, 0x33, 0x4E, 0xCF,
-0x57, 0x3B, 0x57, 0xCF,
+	0x4E, 0x33, 0x4E, 0xCF,
+	0x57, 0x3B, 0x57, 0xCF,
 
-0x9D, 0xFF, 0x20, 0xEA,
-0x57, 0xC0, 0xBF, 0xEA,
+	0x9D, 0xFF, 0x20, 0xEA,
+	0x57, 0xC0, 0xBF, 0xEA,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x00, 0x00, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
 
 };
 
 static unsigned char warp_g400_tgza[] = {
 
-0x00, 0x88, 0x98, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x88, 0x98, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x00, 0x00, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
 
-0xFF, 0x80, 0xC0, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x22, 0x40, 0x48, 0xBF,
-0x2A, 0x40, 0x50, 0xBF,
+	0x22, 0x40, 0x48, 0xBF,
+	0x2A, 0x40, 0x50, 0xBF,
 
-0x32, 0x41, 0x49, 0xBF,
-0x3A, 0x41, 0x51, 0xBF,
+	0x32, 0x41, 0x49, 0xBF,
+	0x3A, 0x41, 0x51, 0xBF,
 
-0xC3, 0x6B,
-0xCB, 0x6B,
-0x00, 0x88, 0x98, 0xE9,
+	0xC3, 0x6B,
+	0xCB, 0x6B,
+	0x00, 0x88, 0x98, 0xE9,
 
-0x73, 0x7B, 0xC8, 0xEC,
-0x96, 0xE2,
-0x41, 0x04,
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x96, 0xE2,
+	0x41, 0x04,
 
-0x7B, 0x43, 0xA0, 0xE8,
-0x73, 0x4B, 0xA0, 0xE8,
+	0x7B, 0x43, 0xA0, 0xE8,
+	0x73, 0x4B, 0xA0, 0xE8,
 
-0xAD, 0xEE, 0x29, 0x9F,
-0x00, 0xE0,
-0x49, 0x04,
+	0xAD, 0xEE, 0x29, 0x9F,
+	0x00, 0xE0,
+	0x49, 0x04,
 
-0x90, 0xE2,
-0x51, 0x04,
-0x31, 0x46, 0xB1, 0xE8,
+	0x90, 0xE2,
+	0x51, 0x04,
+	0x31, 0x46, 0xB1, 0xE8,
 
-0x49, 0x41, 0xC0, 0xEC,
-0x39, 0x57, 0xB1, 0xE8,
+	0x49, 0x41, 0xC0, 0xEC,
+	0x39, 0x57, 0xB1, 0xE8,
 
-0x00, 0x04,
-0x46, 0xE2,
-0x73, 0x53, 0xA0, 0xE8,
+	0x00, 0x04,
+	0x46, 0xE2,
+	0x73, 0x53, 0xA0, 0xE8,
 
-0x51, 0x41, 0xC0, 0xEC,
-0x31, 0x00,
-0x39, 0x00,
+	0x51, 0x41, 0xC0, 0xEC,
+	0x31, 0x00,
+	0x39, 0x00,
 
-0x5C, 0x80, 0x15, 0xEA,
-0x08, 0x04,
-0x10, 0x04,
+	0x5C, 0x80, 0x15, 0xEA,
+	0x08, 0x04,
+	0x10, 0x04,
 
-0x51, 0x49, 0xC0, 0xEC,
-0x2F, 0x41, 0x60, 0xEA,
+	0x51, 0x49, 0xC0, 0xEC,
+	0x2F, 0x41, 0x60, 0xEA,
 
-0x31, 0x20,
-0x39, 0x20,
-0x1F, 0x42, 0xA0, 0xE8,
+	0x31, 0x20,
+	0x39, 0x20,
+	0x1F, 0x42, 0xA0, 0xE8,
 
-0x2A, 0x42, 0x4A, 0xBF,
-0x27, 0x4A, 0xA0, 0xE8,
+	0x2A, 0x42, 0x4A, 0xBF,
+	0x27, 0x4A, 0xA0, 0xE8,
 
-0x1A, 0x42, 0x52, 0xBF,
-0x1E, 0x49, 0x60, 0xEA,
+	0x1A, 0x42, 0x52, 0xBF,
+	0x1E, 0x49, 0x60, 0xEA,
 
-0x73, 0x7B, 0xC8, 0xEC,
-0x26, 0x51, 0x60, 0xEA,
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x26, 0x51, 0x60, 0xEA,
 
-0x32, 0x40, 0x48, 0xBD,
-0x22, 0x40, 0x50, 0xBD,
+	0x32, 0x40, 0x48, 0xBD,
+	0x22, 0x40, 0x50, 0xBD,
 
-0x12, 0x41, 0x49, 0xBD,
-0x3A, 0x41, 0x51, 0xBD,
+	0x12, 0x41, 0x49, 0xBD,
+	0x3A, 0x41, 0x51, 0xBD,
 
-0xBF, 0x2F, 0x26, 0xBD,
-0x00, 0xE0,
-0x7B, 0x72,
+	0xBF, 0x2F, 0x26, 0xBD,
+	0x00, 0xE0,
+	0x7B, 0x72,
 
-0x32, 0x20,
-0x22, 0x20,
-0x12, 0x20,
-0x3A, 0x20,
+	0x32, 0x20,
+	0x22, 0x20,
+	0x12, 0x20,
+	0x3A, 0x20,
 
-0x46, 0x31, 0x46, 0xBF,
-0x4E, 0x31, 0x4E, 0xBF,
+	0x46, 0x31, 0x46, 0xBF,
+	0x4E, 0x31, 0x4E, 0xBF,
 
-0xB3, 0xE2, 0x2D, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0xB3, 0xE2, 0x2D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x56, 0x31, 0x56, 0xBF,
-0x47, 0x39, 0x47, 0xBF,
+	0x56, 0x31, 0x56, 0xBF,
+	0x47, 0x39, 0x47, 0xBF,
 
-0x4F, 0x39, 0x4F, 0xBF,
-0x57, 0x39, 0x57, 0xBF,
+	0x4F, 0x39, 0x4F, 0xBF,
+	0x57, 0x39, 0x57, 0xBF,
 
-0x4E, 0x80, 0x07, 0xEA,
-0x24, 0x41, 0x20, 0xE9,
+	0x4E, 0x80, 0x07, 0xEA,
+	0x24, 0x41, 0x20, 0xE9,
 
-0x42, 0x73, 0xF8, 0xEC,
-0x00, 0xE0,
-0x2D, 0x73,
+	0x42, 0x73, 0xF8, 0xEC,
+	0x00, 0xE0,
+	0x2D, 0x73,
 
-0x33, 0x72,
-0x0C, 0xE3,
-0xA5, 0x2F, 0x1E, 0xBD,
+	0x33, 0x72,
+	0x0C, 0xE3,
+	0xA5, 0x2F, 0x1E, 0xBD,
 
-0x43, 0x43, 0x2D, 0xDF,
-0x4B, 0x4B, 0x2D, 0xDF,
+	0x43, 0x43, 0x2D, 0xDF,
+	0x4B, 0x4B, 0x2D, 0xDF,
 
-0xAE, 0x1E, 0x26, 0xBD,
-0x58, 0xE3,
-0x33, 0x66,
+	0xAE, 0x1E, 0x26, 0xBD,
+	0x58, 0xE3,
+	0x33, 0x66,
 
-0x53, 0x53, 0x2D, 0xDF,
-0x00, 0x80, 0x00, 0xE8,
+	0x53, 0x53, 0x2D, 0xDF,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xB8, 0x38, 0x33, 0xBF,
-0x00, 0xE0,
-0x59, 0xE3,
+	0xB8, 0x38, 0x33, 0xBF,
+	0x00, 0xE0,
+	0x59, 0xE3,
 
-0x1E, 0x12, 0x41, 0xE9,
-0x1A, 0x22, 0x41, 0xE9,
+	0x1E, 0x12, 0x41, 0xE9,
+	0x1A, 0x22, 0x41, 0xE9,
 
-0x2B, 0x40, 0x3D, 0xE9,
-0x3F, 0x4B, 0xA0, 0xE8,
+	0x2B, 0x40, 0x3D, 0xE9,
+	0x3F, 0x4B, 0xA0, 0xE8,
 
-0x2D, 0x73,
-0x30, 0x76,
-0x05, 0x80, 0x3D, 0xEA,
+	0x2D, 0x73,
+	0x30, 0x76,
+	0x05, 0x80, 0x3D, 0xEA,
 
-0x37, 0x43, 0xA0, 0xE8,
-0x3D, 0x53, 0xA0, 0xE8,
+	0x37, 0x43, 0xA0, 0xE8,
+	0x3D, 0x53, 0xA0, 0xE8,
 
-0x48, 0x70, 0xF8, 0xEC,
-0x2B, 0x48, 0x3C, 0xE9,
+	0x48, 0x70, 0xF8, 0xEC,
+	0x2B, 0x48, 0x3C, 0xE9,
 
-0x1F, 0x27, 0xBC, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x1F, 0x27, 0xBC, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x15, 0xC0, 0x20, 0xE9,
-0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
 
-0x15, 0xC0, 0x20, 0xE9,
-0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
 
-0x18, 0x3A, 0x41, 0xE9,
-0x1D, 0x32, 0x41, 0xE9,
+	0x18, 0x3A, 0x41, 0xE9,
+	0x1D, 0x32, 0x41, 0xE9,
 
-0x2A, 0x40, 0x20, 0xE9,
-0x56, 0x3D, 0x56, 0xDF,
+	0x2A, 0x40, 0x20, 0xE9,
+	0x56, 0x3D, 0x56, 0xDF,
 
-0x46, 0x37, 0x46, 0xDF,
-0x4E, 0x3F, 0x4E, 0xDF,
+	0x46, 0x37, 0x46, 0xDF,
+	0x4E, 0x3F, 0x4E, 0xDF,
 
-0x16, 0x30, 0x20, 0xE9,
-0x4F, 0x3F, 0x4F, 0xDF,
+	0x16, 0x30, 0x20, 0xE9,
+	0x4F, 0x3F, 0x4F, 0xDF,
 
-0x32, 0x32, 0x2D, 0xDF,
-0x22, 0x22, 0x2D, 0xDF,
+	0x32, 0x32, 0x2D, 0xDF,
+	0x22, 0x22, 0x2D, 0xDF,
 
-0x12, 0x12, 0x2D, 0xDF,
-0x3A, 0x3A, 0x2D, 0xDF,
+	0x12, 0x12, 0x2D, 0xDF,
+	0x3A, 0x3A, 0x2D, 0xDF,
 
-0x47, 0x37, 0x47, 0xDF,
-0x57, 0x3D, 0x57, 0xDF,
+	0x47, 0x37, 0x47, 0xDF,
+	0x57, 0x3D, 0x57, 0xDF,
 
-0x3D, 0xCF, 0x74, 0xC0,
-0x37, 0xCF, 0x74, 0xC4,
+	0x3D, 0xCF, 0x74, 0xC0,
+	0x37, 0xCF, 0x74, 0xC4,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x34, 0x80, 0x20, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x34, 0x80, 0x20, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x3C, 0x3D, 0x20, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3C, 0x3D, 0x20, 0xE9,
 
-0x27, 0xCF, 0x74, 0xC6,
-0x3D, 0xCF, 0x74, 0xC2,
+	0x27, 0xCF, 0x74, 0xC6,
+	0x3D, 0xCF, 0x74, 0xC2,
 
-0x0A, 0x44, 0x4C, 0xB0,
-0x02, 0x44, 0x54, 0xB0,
+	0x0A, 0x44, 0x4C, 0xB0,
+	0x02, 0x44, 0x54, 0xB0,
 
-0x2A, 0x44, 0x4C, 0xB2,
-0x1A, 0x44, 0x54, 0xB2,
+	0x2A, 0x44, 0x4C, 0xB2,
+	0x1A, 0x44, 0x54, 0xB2,
 
-0x20, 0x80, 0x3A, 0xEA,
-0x0A, 0x20,
-0x02, 0x20,
+	0x20, 0x80, 0x3A, 0xEA,
+	0x0A, 0x20,
+	0x02, 0x20,
 
-0x88, 0x73, 0x5E, 0xE9,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x88, 0x73, 0x5E, 0xE9,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x32, 0x31, 0x5F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x32, 0x31, 0x5F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x33, 0x39, 0x5F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x33, 0x39, 0x5F, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x9C, 0x27, 0x20, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x9C, 0x27, 0x20, 0xE9,
 
-0x0A, 0x44, 0x4C, 0xB4,
-0x02, 0x44, 0x54, 0xB4,
+	0x0A, 0x44, 0x4C, 0xB4,
+	0x02, 0x44, 0x54, 0xB4,
 
-0x2A, 0x44, 0x4C, 0xB6,
-0x1A, 0x44, 0x54, 0xB6,
+	0x2A, 0x44, 0x4C, 0xB6,
+	0x1A, 0x44, 0x54, 0xB6,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x38, 0x3D, 0x20, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x38, 0x3D, 0x20, 0xE9,
 
-0x0A, 0x20,
-0x02, 0x20,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x0A, 0x20,
+	0x02, 0x20,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0x0A, 0x47, 0x4F, 0xBF,
-0x02, 0x47, 0x57, 0xBF,
+	0x0A, 0x47, 0x4F, 0xBF,
+	0x02, 0x47, 0x57, 0xBF,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x3E, 0x30, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x3E, 0x30, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x3F, 0x38, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x3F, 0x38, 0x4F, 0xE9,
 
-0x2A, 0x46, 0x4E, 0xBF,
-0x1A, 0x46, 0x56, 0xBF,
+	0x2A, 0x46, 0x4E, 0xBF,
+	0x1A, 0x46, 0x56, 0xBF,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x3A, 0x31, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x3A, 0x31, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x3B, 0x39, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3B, 0x39, 0x4F, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x36, 0x30, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x36, 0x30, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x37, 0x38, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x37, 0x38, 0x4F, 0xE9,
 
-0x2A, 0x43, 0x4B, 0xBF,
-0x1A, 0x43, 0x53, 0xBF,
+	0x2A, 0x43, 0x4B, 0xBF,
+	0x1A, 0x43, 0x53, 0xBF,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x9D, 0x31, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x9D, 0x31, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x9E, 0x39, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x9E, 0x39, 0x4F, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x80, 0x31, 0x57, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x80, 0x31, 0x57, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x81, 0x39, 0x57, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x81, 0x39, 0x57, 0xE9,
 
-0x37, 0x48, 0x50, 0xBD,
-0x8A, 0x36, 0x20, 0xE9,
+	0x37, 0x48, 0x50, 0xBD,
+	0x8A, 0x36, 0x20, 0xE9,
 
-0x86, 0x76, 0x57, 0xE9,
-0x8B, 0x3E, 0x20, 0xE9,
+	0x86, 0x76, 0x57, 0xE9,
+	0x8B, 0x3E, 0x20, 0xE9,
 
-0x82, 0x30, 0x57, 0xE9,
-0x87, 0x77, 0x57, 0xE9,
+	0x82, 0x30, 0x57, 0xE9,
+	0x87, 0x77, 0x57, 0xE9,
 
-0x83, 0x38, 0x57, 0xE9,
-0x35, 0x49, 0x51, 0xBD,
+	0x83, 0x38, 0x57, 0xE9,
+	0x35, 0x49, 0x51, 0xBD,
 
-0x84, 0x31, 0x5E, 0xE9,
-0x30, 0x1F, 0x5F, 0xE9,
+	0x84, 0x31, 0x5E, 0xE9,
+	0x30, 0x1F, 0x5F, 0xE9,
 
-0x85, 0x39, 0x5E, 0xE9,
-0x57, 0x25, 0x20, 0xE9,
+	0x85, 0x39, 0x5E, 0xE9,
+	0x57, 0x25, 0x20, 0xE9,
 
-0x2B, 0x48, 0x20, 0xE9,
-0x1D, 0x37, 0xE1, 0xEA,
+	0x2B, 0x48, 0x20, 0xE9,
+	0x1D, 0x37, 0xE1, 0xEA,
 
-0x1E, 0x35, 0xE1, 0xEA,
-0x00, 0xE0,
-0x26, 0x77,
+	0x1E, 0x35, 0xE1, 0xEA,
+	0x00, 0xE0,
+	0x26, 0x77,
 
-0x24, 0x49, 0x20, 0xE9,
-0xAB, 0xFF, 0x20, 0xEA,
+	0x24, 0x49, 0x20, 0xE9,
+	0xAB, 0xFF, 0x20, 0xEA,
 
-0x16, 0x26, 0x20, 0xE9,
-0x57, 0x2E, 0xBF, 0xEA,
+	0x16, 0x26, 0x20, 0xE9,
+	0x57, 0x2E, 0xBF, 0xEA,
 
-0x1C, 0x46, 0xA0, 0xE8,
-0x23, 0x4E, 0xA0, 0xE8,
+	0x1C, 0x46, 0xA0, 0xE8,
+	0x23, 0x4E, 0xA0, 0xE8,
 
-0x2B, 0x56, 0xA0, 0xE8,
-0x1D, 0x47, 0xA0, 0xE8,
+	0x2B, 0x56, 0xA0, 0xE8,
+	0x1D, 0x47, 0xA0, 0xE8,
 
-0x24, 0x4F, 0xA0, 0xE8,
-0x2C, 0x57, 0xA0, 0xE8,
+	0x24, 0x4F, 0xA0, 0xE8,
+	0x2C, 0x57, 0xA0, 0xE8,
 
-0x1C, 0x00,
-0x23, 0x00,
-0x2B, 0x00,
-0x00, 0xE0,
+	0x1C, 0x00,
+	0x23, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
 
-0x1D, 0x00,
-0x24, 0x00,
-0x2C, 0x00,
-0x00, 0xE0,
+	0x1D, 0x00,
+	0x24, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
 
-0x1C, 0x65,
-0x23, 0x65,
-0x2B, 0x65,
-0x00, 0xE0,
+	0x1C, 0x65,
+	0x23, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
 
-0x1D, 0x65,
-0x24, 0x65,
-0x2C, 0x65,
-0x00, 0xE0,
+	0x1D, 0x65,
+	0x24, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
 
-0x1C, 0x23, 0x60, 0xEC,
-0x36, 0xD7, 0x36, 0xAD,
+	0x1C, 0x23, 0x60, 0xEC,
+	0x36, 0xD7, 0x36, 0xAD,
 
-0x2B, 0x80, 0x60, 0xEC,
-0x1D, 0x24, 0x60, 0xEC,
+	0x2B, 0x80, 0x60, 0xEC,
+	0x1D, 0x24, 0x60, 0xEC,
 
-0x3E, 0xD7, 0x3E, 0xAD,
-0x2C, 0x80, 0x60, 0xEC,
+	0x3E, 0xD7, 0x3E, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
 
-0x1C, 0x2B, 0xDE, 0xE8,
-0x23, 0x80, 0xDE, 0xE8,
+	0x1C, 0x2B, 0xDE, 0xE8,
+	0x23, 0x80, 0xDE, 0xE8,
 
-0x36, 0x80, 0x36, 0xBD,
-0x3E, 0x80, 0x3E, 0xBD,
+	0x36, 0x80, 0x36, 0xBD,
+	0x3E, 0x80, 0x3E, 0xBD,
 
-0x33, 0xD7, 0x1C, 0xBD,
-0x3B, 0xD7, 0x23, 0xBD,
+	0x33, 0xD7, 0x1C, 0xBD,
+	0x3B, 0xD7, 0x23, 0xBD,
 
-0x46, 0x80, 0x46, 0xCF,
-0x4F, 0x80, 0x4F, 0xCF,
+	0x46, 0x80, 0x46, 0xCF,
+	0x4F, 0x80, 0x4F, 0xCF,
 
-0x56, 0x33, 0x56, 0xCF,
-0x47, 0x3B, 0x47, 0xCF,
+	0x56, 0x33, 0x56, 0xCF,
+	0x47, 0x3B, 0x47, 0xCF,
 
-0xD3, 0xFF, 0x20, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0xD3, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x4E, 0x33, 0x4E, 0xCF,
-0x57, 0x3B, 0x57, 0xCF,
+	0x4E, 0x33, 0x4E, 0xCF,
+	0x57, 0x3B, 0x57, 0xCF,
 
-0x99, 0xFF, 0x20, 0xEA,
-0x57, 0xC0, 0xBF, 0xEA,
+	0x99, 0xFF, 0x20, 0xEA,
+	0x57, 0xC0, 0xBF, 0xEA,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x00, 0x00, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
 
 };
 
 static unsigned char warp_g400_tgzaf[] = {
 
-0x00, 0x88, 0x98, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x88, 0x98, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x00, 0x00, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
 
-0xFF, 0x80, 0xC0, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x22, 0x40, 0x48, 0xBF,
-0x2A, 0x40, 0x50, 0xBF,
+	0x22, 0x40, 0x48, 0xBF,
+	0x2A, 0x40, 0x50, 0xBF,
 
-0x32, 0x41, 0x49, 0xBF,
-0x3A, 0x41, 0x51, 0xBF,
+	0x32, 0x41, 0x49, 0xBF,
+	0x3A, 0x41, 0x51, 0xBF,
 
-0xC3, 0x6B,
-0xCB, 0x6B,
-0x00, 0x88, 0x98, 0xE9,
+	0xC3, 0x6B,
+	0xCB, 0x6B,
+	0x00, 0x88, 0x98, 0xE9,
 
-0x73, 0x7B, 0xC8, 0xEC,
-0x96, 0xE2,
-0x41, 0x04,
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x96, 0xE2,
+	0x41, 0x04,
 
-0x7B, 0x43, 0xA0, 0xE8,
-0x73, 0x4B, 0xA0, 0xE8,
+	0x7B, 0x43, 0xA0, 0xE8,
+	0x73, 0x4B, 0xA0, 0xE8,
 
-0xAD, 0xEE, 0x29, 0x9F,
-0x00, 0xE0,
-0x49, 0x04,
+	0xAD, 0xEE, 0x29, 0x9F,
+	0x00, 0xE0,
+	0x49, 0x04,
 
-0x90, 0xE2,
-0x51, 0x04,
-0x31, 0x46, 0xB1, 0xE8,
+	0x90, 0xE2,
+	0x51, 0x04,
+	0x31, 0x46, 0xB1, 0xE8,
 
-0x49, 0x41, 0xC0, 0xEC,
-0x39, 0x57, 0xB1, 0xE8,
+	0x49, 0x41, 0xC0, 0xEC,
+	0x39, 0x57, 0xB1, 0xE8,
 
-0x00, 0x04,
-0x46, 0xE2,
-0x73, 0x53, 0xA0, 0xE8,
+	0x00, 0x04,
+	0x46, 0xE2,
+	0x73, 0x53, 0xA0, 0xE8,
 
-0x51, 0x41, 0xC0, 0xEC,
-0x31, 0x00,
-0x39, 0x00,
+	0x51, 0x41, 0xC0, 0xEC,
+	0x31, 0x00,
+	0x39, 0x00,
 
-0x61, 0x80, 0x15, 0xEA,
-0x08, 0x04,
-0x10, 0x04,
+	0x61, 0x80, 0x15, 0xEA,
+	0x08, 0x04,
+	0x10, 0x04,
 
-0x51, 0x49, 0xC0, 0xEC,
-0x2F, 0x41, 0x60, 0xEA,
+	0x51, 0x49, 0xC0, 0xEC,
+	0x2F, 0x41, 0x60, 0xEA,
 
-0x31, 0x20,
-0x39, 0x20,
-0x1F, 0x42, 0xA0, 0xE8,
+	0x31, 0x20,
+	0x39, 0x20,
+	0x1F, 0x42, 0xA0, 0xE8,
 
-0x2A, 0x42, 0x4A, 0xBF,
-0x27, 0x4A, 0xA0, 0xE8,
+	0x2A, 0x42, 0x4A, 0xBF,
+	0x27, 0x4A, 0xA0, 0xE8,
 
-0x1A, 0x42, 0x52, 0xBF,
-0x1E, 0x49, 0x60, 0xEA,
+	0x1A, 0x42, 0x52, 0xBF,
+	0x1E, 0x49, 0x60, 0xEA,
 
-0x73, 0x7B, 0xC8, 0xEC,
-0x26, 0x51, 0x60, 0xEA,
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x26, 0x51, 0x60, 0xEA,
 
-0x32, 0x40, 0x48, 0xBD,
-0x22, 0x40, 0x50, 0xBD,
+	0x32, 0x40, 0x48, 0xBD,
+	0x22, 0x40, 0x50, 0xBD,
 
-0x12, 0x41, 0x49, 0xBD,
-0x3A, 0x41, 0x51, 0xBD,
+	0x12, 0x41, 0x49, 0xBD,
+	0x3A, 0x41, 0x51, 0xBD,
 
-0xBF, 0x2F, 0x26, 0xBD,
-0x00, 0xE0,
-0x7B, 0x72,
+	0xBF, 0x2F, 0x26, 0xBD,
+	0x00, 0xE0,
+	0x7B, 0x72,
 
-0x32, 0x20,
-0x22, 0x20,
-0x12, 0x20,
-0x3A, 0x20,
+	0x32, 0x20,
+	0x22, 0x20,
+	0x12, 0x20,
+	0x3A, 0x20,
 
-0x46, 0x31, 0x46, 0xBF,
-0x4E, 0x31, 0x4E, 0xBF,
+	0x46, 0x31, 0x46, 0xBF,
+	0x4E, 0x31, 0x4E, 0xBF,
 
-0xB3, 0xE2, 0x2D, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0xB3, 0xE2, 0x2D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x56, 0x31, 0x56, 0xBF,
-0x47, 0x39, 0x47, 0xBF,
+	0x56, 0x31, 0x56, 0xBF,
+	0x47, 0x39, 0x47, 0xBF,
 
-0x4F, 0x39, 0x4F, 0xBF,
-0x57, 0x39, 0x57, 0xBF,
+	0x4F, 0x39, 0x4F, 0xBF,
+	0x57, 0x39, 0x57, 0xBF,
 
-0x53, 0x80, 0x07, 0xEA,
-0x24, 0x41, 0x20, 0xE9,
+	0x53, 0x80, 0x07, 0xEA,
+	0x24, 0x41, 0x20, 0xE9,
 
-0x42, 0x73, 0xF8, 0xEC,
-0x00, 0xE0,
-0x2D, 0x73,
+	0x42, 0x73, 0xF8, 0xEC,
+	0x00, 0xE0,
+	0x2D, 0x73,
 
-0x33, 0x72,
-0x0C, 0xE3,
-0xA5, 0x2F, 0x1E, 0xBD,
+	0x33, 0x72,
+	0x0C, 0xE3,
+	0xA5, 0x2F, 0x1E, 0xBD,
 
-0x43, 0x43, 0x2D, 0xDF,
-0x4B, 0x4B, 0x2D, 0xDF,
+	0x43, 0x43, 0x2D, 0xDF,
+	0x4B, 0x4B, 0x2D, 0xDF,
 
-0xAE, 0x1E, 0x26, 0xBD,
-0x58, 0xE3,
-0x33, 0x66,
+	0xAE, 0x1E, 0x26, 0xBD,
+	0x58, 0xE3,
+	0x33, 0x66,
 
-0x53, 0x53, 0x2D, 0xDF,
-0x00, 0x80, 0x00, 0xE8,
+	0x53, 0x53, 0x2D, 0xDF,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xB8, 0x38, 0x33, 0xBF,
-0x00, 0xE0,
-0x59, 0xE3,
+	0xB8, 0x38, 0x33, 0xBF,
+	0x00, 0xE0,
+	0x59, 0xE3,
 
-0x1E, 0x12, 0x41, 0xE9,
-0x1A, 0x22, 0x41, 0xE9,
+	0x1E, 0x12, 0x41, 0xE9,
+	0x1A, 0x22, 0x41, 0xE9,
 
-0x2B, 0x40, 0x3D, 0xE9,
-0x3F, 0x4B, 0xA0, 0xE8,
+	0x2B, 0x40, 0x3D, 0xE9,
+	0x3F, 0x4B, 0xA0, 0xE8,
 
-0x2D, 0x73,
-0x30, 0x76,
-0x05, 0x80, 0x3D, 0xEA,
+	0x2D, 0x73,
+	0x30, 0x76,
+	0x05, 0x80, 0x3D, 0xEA,
 
-0x37, 0x43, 0xA0, 0xE8,
-0x3D, 0x53, 0xA0, 0xE8,
+	0x37, 0x43, 0xA0, 0xE8,
+	0x3D, 0x53, 0xA0, 0xE8,
 
-0x48, 0x70, 0xF8, 0xEC,
-0x2B, 0x48, 0x3C, 0xE9,
+	0x48, 0x70, 0xF8, 0xEC,
+	0x2B, 0x48, 0x3C, 0xE9,
 
-0x1F, 0x27, 0xBC, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x1F, 0x27, 0xBC, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x15, 0xC0, 0x20, 0xE9,
-0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
 
-0x15, 0xC0, 0x20, 0xE9,
-0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
 
-0x18, 0x3A, 0x41, 0xE9,
-0x1D, 0x32, 0x41, 0xE9,
+	0x18, 0x3A, 0x41, 0xE9,
+	0x1D, 0x32, 0x41, 0xE9,
 
-0x2A, 0x40, 0x20, 0xE9,
-0x56, 0x3D, 0x56, 0xDF,
+	0x2A, 0x40, 0x20, 0xE9,
+	0x56, 0x3D, 0x56, 0xDF,
 
-0x46, 0x37, 0x46, 0xDF,
-0x4E, 0x3F, 0x4E, 0xDF,
+	0x46, 0x37, 0x46, 0xDF,
+	0x4E, 0x3F, 0x4E, 0xDF,
 
-0x16, 0x30, 0x20, 0xE9,
-0x4F, 0x3F, 0x4F, 0xDF,
+	0x16, 0x30, 0x20, 0xE9,
+	0x4F, 0x3F, 0x4F, 0xDF,
 
-0x32, 0x32, 0x2D, 0xDF,
-0x22, 0x22, 0x2D, 0xDF,
+	0x32, 0x32, 0x2D, 0xDF,
+	0x22, 0x22, 0x2D, 0xDF,
 
-0x12, 0x12, 0x2D, 0xDF,
-0x3A, 0x3A, 0x2D, 0xDF,
+	0x12, 0x12, 0x2D, 0xDF,
+	0x3A, 0x3A, 0x2D, 0xDF,
 
-0x47, 0x37, 0x47, 0xDF,
-0x57, 0x3D, 0x57, 0xDF,
+	0x47, 0x37, 0x47, 0xDF,
+	0x57, 0x3D, 0x57, 0xDF,
 
-0x3D, 0xCF, 0x74, 0xC0,
-0x37, 0xCF, 0x74, 0xC4,
+	0x3D, 0xCF, 0x74, 0xC0,
+	0x37, 0xCF, 0x74, 0xC4,
 
-0x0A, 0x44, 0x4C, 0xB0,
-0x02, 0x44, 0x54, 0xB0,
+	0x0A, 0x44, 0x4C, 0xB0,
+	0x02, 0x44, 0x54, 0xB0,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x34, 0x37, 0x20, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x34, 0x37, 0x20, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x3C, 0x3D, 0x20, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3C, 0x3D, 0x20, 0xE9,
 
-0x2A, 0x44, 0x4C, 0xB2,
-0x1A, 0x44, 0x54, 0xB2,
+	0x2A, 0x44, 0x4C, 0xB2,
+	0x1A, 0x44, 0x54, 0xB2,
 
-0x26, 0x80, 0x3A, 0xEA,
-0x0A, 0x20,
-0x02, 0x20,
+	0x26, 0x80, 0x3A, 0xEA,
+	0x0A, 0x20,
+	0x02, 0x20,
 
-0x88, 0x73, 0x5E, 0xE9,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x88, 0x73, 0x5E, 0xE9,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0x3D, 0xCF, 0x74, 0xC2,
-0x27, 0xCF, 0x74, 0xC6,
+	0x3D, 0xCF, 0x74, 0xC2,
+	0x27, 0xCF, 0x74, 0xC6,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x32, 0x31, 0x5F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x32, 0x31, 0x5F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x33, 0x39, 0x5F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x33, 0x39, 0x5F, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x9C, 0x27, 0x20, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x9C, 0x27, 0x20, 0xE9,
 
-0x0A, 0x44, 0x4C, 0xB4,
-0x02, 0x44, 0x54, 0xB4,
+	0x0A, 0x44, 0x4C, 0xB4,
+	0x02, 0x44, 0x54, 0xB4,
 
-0x2A, 0x44, 0x4C, 0xB6,
-0x1A, 0x44, 0x54, 0xB6,
+	0x2A, 0x44, 0x4C, 0xB6,
+	0x1A, 0x44, 0x54, 0xB6,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x38, 0x3D, 0x20, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x38, 0x3D, 0x20, 0xE9,
 
-0x0A, 0x20,
-0x02, 0x20,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x0A, 0x20,
+	0x02, 0x20,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0x3D, 0xCF, 0x75, 0xC6,
-0x00, 0x80, 0x00, 0xE8,
+	0x3D, 0xCF, 0x75, 0xC6,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x3E, 0x30, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x3E, 0x30, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x3F, 0x38, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x3F, 0x38, 0x4F, 0xE9,
 
-0x0A, 0x45, 0x4D, 0xB6,
-0x02, 0x45, 0x55, 0xB6,
+	0x0A, 0x45, 0x4D, 0xB6,
+	0x02, 0x45, 0x55, 0xB6,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x3A, 0x31, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x3A, 0x31, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x3B, 0x39, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3B, 0x39, 0x4F, 0xE9,
 
-0x31, 0x3D, 0x20, 0xE9,
-0x0A, 0x20,
-0x02, 0x20,
+	0x31, 0x3D, 0x20, 0xE9,
+	0x0A, 0x20,
+	0x02, 0x20,
 
-0x2A, 0x46, 0x4E, 0xBF,
-0x1A, 0x46, 0x56, 0xBF,
+	0x2A, 0x46, 0x4E, 0xBF,
+	0x1A, 0x46, 0x56, 0xBF,
 
-0x0A, 0x47, 0x4F, 0xBF,
-0x02, 0x47, 0x57, 0xBF,
+	0x0A, 0x47, 0x4F, 0xBF,
+	0x02, 0x47, 0x57, 0xBF,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x36, 0x30, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x36, 0x30, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x37, 0x38, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x37, 0x38, 0x4F, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x9D, 0x31, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x9D, 0x31, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x9E, 0x39, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x9E, 0x39, 0x4F, 0xE9,
 
-0x2A, 0x43, 0x4B, 0xBF,
-0x1A, 0x43, 0x53, 0xBF,
+	0x2A, 0x43, 0x4B, 0xBF,
+	0x1A, 0x43, 0x53, 0xBF,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x35, 0x30, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x35, 0x30, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x39, 0x38, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x39, 0x38, 0x4F, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x80, 0x31, 0x57, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x80, 0x31, 0x57, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x81, 0x39, 0x57, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x81, 0x39, 0x57, 0xE9,
 
-0x37, 0x48, 0x50, 0xBD,
-0x8A, 0x36, 0x20, 0xE9,
+	0x37, 0x48, 0x50, 0xBD,
+	0x8A, 0x36, 0x20, 0xE9,
 
-0x86, 0x76, 0x57, 0xE9,
-0x8B, 0x3E, 0x20, 0xE9,
+	0x86, 0x76, 0x57, 0xE9,
+	0x8B, 0x3E, 0x20, 0xE9,
 
-0x82, 0x30, 0x57, 0xE9,
-0x87, 0x77, 0x57, 0xE9,
+	0x82, 0x30, 0x57, 0xE9,
+	0x87, 0x77, 0x57, 0xE9,
 
-0x83, 0x38, 0x57, 0xE9,
-0x35, 0x49, 0x51, 0xBD,
+	0x83, 0x38, 0x57, 0xE9,
+	0x35, 0x49, 0x51, 0xBD,
 
-0x84, 0x31, 0x5E, 0xE9,
-0x30, 0x1F, 0x5F, 0xE9,
+	0x84, 0x31, 0x5E, 0xE9,
+	0x30, 0x1F, 0x5F, 0xE9,
 
-0x85, 0x39, 0x5E, 0xE9,
-0x57, 0x25, 0x20, 0xE9,
+	0x85, 0x39, 0x5E, 0xE9,
+	0x57, 0x25, 0x20, 0xE9,
 
-0x2B, 0x48, 0x20, 0xE9,
-0x1D, 0x37, 0xE1, 0xEA,
+	0x2B, 0x48, 0x20, 0xE9,
+	0x1D, 0x37, 0xE1, 0xEA,
 
-0x1E, 0x35, 0xE1, 0xEA,
-0x00, 0xE0,
-0x26, 0x77,
+	0x1E, 0x35, 0xE1, 0xEA,
+	0x00, 0xE0,
+	0x26, 0x77,
 
-0x24, 0x49, 0x20, 0xE9,
-0xA6, 0xFF, 0x20, 0xEA,
+	0x24, 0x49, 0x20, 0xE9,
+	0xA6, 0xFF, 0x20, 0xEA,
 
-0x16, 0x26, 0x20, 0xE9,
-0x57, 0x2E, 0xBF, 0xEA,
+	0x16, 0x26, 0x20, 0xE9,
+	0x57, 0x2E, 0xBF, 0xEA,
 
-0x1C, 0x46, 0xA0, 0xE8,
-0x23, 0x4E, 0xA0, 0xE8,
+	0x1C, 0x46, 0xA0, 0xE8,
+	0x23, 0x4E, 0xA0, 0xE8,
 
-0x2B, 0x56, 0xA0, 0xE8,
-0x1D, 0x47, 0xA0, 0xE8,
+	0x2B, 0x56, 0xA0, 0xE8,
+	0x1D, 0x47, 0xA0, 0xE8,
 
-0x24, 0x4F, 0xA0, 0xE8,
-0x2C, 0x57, 0xA0, 0xE8,
+	0x24, 0x4F, 0xA0, 0xE8,
+	0x2C, 0x57, 0xA0, 0xE8,
 
-0x1C, 0x00,
-0x23, 0x00,
-0x2B, 0x00,
-0x00, 0xE0,
+	0x1C, 0x00,
+	0x23, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
 
-0x1D, 0x00,
-0x24, 0x00,
-0x2C, 0x00,
-0x00, 0xE0,
+	0x1D, 0x00,
+	0x24, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
 
-0x1C, 0x65,
-0x23, 0x65,
-0x2B, 0x65,
-0x00, 0xE0,
+	0x1C, 0x65,
+	0x23, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
 
-0x1D, 0x65,
-0x24, 0x65,
-0x2C, 0x65,
-0x00, 0xE0,
+	0x1D, 0x65,
+	0x24, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
 
-0x1C, 0x23, 0x60, 0xEC,
-0x36, 0xD7, 0x36, 0xAD,
+	0x1C, 0x23, 0x60, 0xEC,
+	0x36, 0xD7, 0x36, 0xAD,
 
-0x2B, 0x80, 0x60, 0xEC,
-0x1D, 0x24, 0x60, 0xEC,
+	0x2B, 0x80, 0x60, 0xEC,
+	0x1D, 0x24, 0x60, 0xEC,
 
-0x3E, 0xD7, 0x3E, 0xAD,
-0x2C, 0x80, 0x60, 0xEC,
+	0x3E, 0xD7, 0x3E, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
 
-0x1C, 0x2B, 0xDE, 0xE8,
-0x23, 0x80, 0xDE, 0xE8,
+	0x1C, 0x2B, 0xDE, 0xE8,
+	0x23, 0x80, 0xDE, 0xE8,
 
-0x36, 0x80, 0x36, 0xBD,
-0x3E, 0x80, 0x3E, 0xBD,
+	0x36, 0x80, 0x36, 0xBD,
+	0x3E, 0x80, 0x3E, 0xBD,
 
-0x33, 0xD7, 0x1C, 0xBD,
-0x3B, 0xD7, 0x23, 0xBD,
+	0x33, 0xD7, 0x1C, 0xBD,
+	0x3B, 0xD7, 0x23, 0xBD,
 
-0x46, 0x80, 0x46, 0xCF,
-0x4F, 0x80, 0x4F, 0xCF,
+	0x46, 0x80, 0x46, 0xCF,
+	0x4F, 0x80, 0x4F, 0xCF,
 
-0x56, 0x33, 0x56, 0xCF,
-0x47, 0x3B, 0x47, 0xCF,
+	0x56, 0x33, 0x56, 0xCF,
+	0x47, 0x3B, 0x47, 0xCF,
 
-0xCD, 0xFF, 0x20, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0xCD, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x4E, 0x33, 0x4E, 0xCF,
-0x57, 0x3B, 0x57, 0xCF,
+	0x4E, 0x33, 0x4E, 0xCF,
+	0x57, 0x3B, 0x57, 0xCF,
 
-0x94, 0xFF, 0x20, 0xEA,
-0x57, 0xC0, 0xBF, 0xEA,
+	0x94, 0xFF, 0x20, 0xEA,
+	0x57, 0xC0, 0xBF, 0xEA,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x00, 0x00, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
 
 };
 
 static unsigned char warp_g400_tgzf[] = {
 
-0x00, 0x88, 0x98, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x88, 0x98, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x00, 0x00, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
 
-0xFF, 0x80, 0xC0, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x22, 0x40, 0x48, 0xBF,
-0x2A, 0x40, 0x50, 0xBF,
+	0x22, 0x40, 0x48, 0xBF,
+	0x2A, 0x40, 0x50, 0xBF,
 
-0x32, 0x41, 0x49, 0xBF,
-0x3A, 0x41, 0x51, 0xBF,
+	0x32, 0x41, 0x49, 0xBF,
+	0x3A, 0x41, 0x51, 0xBF,
 
-0xC3, 0x6B,
-0xCB, 0x6B,
-0x00, 0x88, 0x98, 0xE9,
+	0xC3, 0x6B,
+	0xCB, 0x6B,
+	0x00, 0x88, 0x98, 0xE9,
 
-0x73, 0x7B, 0xC8, 0xEC,
-0x96, 0xE2,
-0x41, 0x04,
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x96, 0xE2,
+	0x41, 0x04,
 
-0x7B, 0x43, 0xA0, 0xE8,
-0x73, 0x4B, 0xA0, 0xE8,
+	0x7B, 0x43, 0xA0, 0xE8,
+	0x73, 0x4B, 0xA0, 0xE8,
 
-0xAD, 0xEE, 0x29, 0x9F,
-0x00, 0xE0,
-0x49, 0x04,
+	0xAD, 0xEE, 0x29, 0x9F,
+	0x00, 0xE0,
+	0x49, 0x04,
 
-0x90, 0xE2,
-0x51, 0x04,
-0x31, 0x46, 0xB1, 0xE8,
+	0x90, 0xE2,
+	0x51, 0x04,
+	0x31, 0x46, 0xB1, 0xE8,
 
-0x49, 0x41, 0xC0, 0xEC,
-0x39, 0x57, 0xB1, 0xE8,
+	0x49, 0x41, 0xC0, 0xEC,
+	0x39, 0x57, 0xB1, 0xE8,
 
-0x00, 0x04,
-0x46, 0xE2,
-0x73, 0x53, 0xA0, 0xE8,
+	0x00, 0x04,
+	0x46, 0xE2,
+	0x73, 0x53, 0xA0, 0xE8,
 
-0x51, 0x41, 0xC0, 0xEC,
-0x31, 0x00,
-0x39, 0x00,
+	0x51, 0x41, 0xC0, 0xEC,
+	0x31, 0x00,
+	0x39, 0x00,
 
-0x5D, 0x80, 0x15, 0xEA,
-0x08, 0x04,
-0x10, 0x04,
+	0x5D, 0x80, 0x15, 0xEA,
+	0x08, 0x04,
+	0x10, 0x04,
 
-0x51, 0x49, 0xC0, 0xEC,
-0x2F, 0x41, 0x60, 0xEA,
+	0x51, 0x49, 0xC0, 0xEC,
+	0x2F, 0x41, 0x60, 0xEA,
 
-0x31, 0x20,
-0x39, 0x20,
-0x1F, 0x42, 0xA0, 0xE8,
+	0x31, 0x20,
+	0x39, 0x20,
+	0x1F, 0x42, 0xA0, 0xE8,
 
-0x2A, 0x42, 0x4A, 0xBF,
-0x27, 0x4A, 0xA0, 0xE8,
+	0x2A, 0x42, 0x4A, 0xBF,
+	0x27, 0x4A, 0xA0, 0xE8,
 
-0x1A, 0x42, 0x52, 0xBF,
-0x1E, 0x49, 0x60, 0xEA,
+	0x1A, 0x42, 0x52, 0xBF,
+	0x1E, 0x49, 0x60, 0xEA,
 
-0x73, 0x7B, 0xC8, 0xEC,
-0x26, 0x51, 0x60, 0xEA,
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x26, 0x51, 0x60, 0xEA,
 
-0x32, 0x40, 0x48, 0xBD,
-0x22, 0x40, 0x50, 0xBD,
+	0x32, 0x40, 0x48, 0xBD,
+	0x22, 0x40, 0x50, 0xBD,
 
-0x12, 0x41, 0x49, 0xBD,
-0x3A, 0x41, 0x51, 0xBD,
+	0x12, 0x41, 0x49, 0xBD,
+	0x3A, 0x41, 0x51, 0xBD,
 
-0xBF, 0x2F, 0x26, 0xBD,
-0x00, 0xE0,
-0x7B, 0x72,
+	0xBF, 0x2F, 0x26, 0xBD,
+	0x00, 0xE0,
+	0x7B, 0x72,
 
-0x32, 0x20,
-0x22, 0x20,
-0x12, 0x20,
-0x3A, 0x20,
+	0x32, 0x20,
+	0x22, 0x20,
+	0x12, 0x20,
+	0x3A, 0x20,
 
-0x46, 0x31, 0x46, 0xBF,
-0x4E, 0x31, 0x4E, 0xBF,
+	0x46, 0x31, 0x46, 0xBF,
+	0x4E, 0x31, 0x4E, 0xBF,
 
-0xB3, 0xE2, 0x2D, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0xB3, 0xE2, 0x2D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x56, 0x31, 0x56, 0xBF,
-0x47, 0x39, 0x47, 0xBF,
+	0x56, 0x31, 0x56, 0xBF,
+	0x47, 0x39, 0x47, 0xBF,
 
-0x4F, 0x39, 0x4F, 0xBF,
-0x57, 0x39, 0x57, 0xBF,
+	0x4F, 0x39, 0x4F, 0xBF,
+	0x57, 0x39, 0x57, 0xBF,
 
-0x4F, 0x80, 0x07, 0xEA,
-0x24, 0x41, 0x20, 0xE9,
+	0x4F, 0x80, 0x07, 0xEA,
+	0x24, 0x41, 0x20, 0xE9,
 
-0x42, 0x73, 0xF8, 0xEC,
-0x00, 0xE0,
-0x2D, 0x73,
+	0x42, 0x73, 0xF8, 0xEC,
+	0x00, 0xE0,
+	0x2D, 0x73,
 
-0x33, 0x72,
-0x0C, 0xE3,
-0xA5, 0x2F, 0x1E, 0xBD,
+	0x33, 0x72,
+	0x0C, 0xE3,
+	0xA5, 0x2F, 0x1E, 0xBD,
 
-0x43, 0x43, 0x2D, 0xDF,
-0x4B, 0x4B, 0x2D, 0xDF,
+	0x43, 0x43, 0x2D, 0xDF,
+	0x4B, 0x4B, 0x2D, 0xDF,
 
-0xAE, 0x1E, 0x26, 0xBD,
-0x58, 0xE3,
-0x33, 0x66,
+	0xAE, 0x1E, 0x26, 0xBD,
+	0x58, 0xE3,
+	0x33, 0x66,
 
-0x53, 0x53, 0x2D, 0xDF,
-0x00, 0x80, 0x00, 0xE8,
+	0x53, 0x53, 0x2D, 0xDF,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xB8, 0x38, 0x33, 0xBF,
-0x00, 0xE0,
-0x59, 0xE3,
+	0xB8, 0x38, 0x33, 0xBF,
+	0x00, 0xE0,
+	0x59, 0xE3,
 
-0x1E, 0x12, 0x41, 0xE9,
-0x1A, 0x22, 0x41, 0xE9,
+	0x1E, 0x12, 0x41, 0xE9,
+	0x1A, 0x22, 0x41, 0xE9,
 
-0x2B, 0x40, 0x3D, 0xE9,
-0x3F, 0x4B, 0xA0, 0xE8,
+	0x2B, 0x40, 0x3D, 0xE9,
+	0x3F, 0x4B, 0xA0, 0xE8,
 
-0x2D, 0x73,
-0x30, 0x76,
-0x05, 0x80, 0x3D, 0xEA,
+	0x2D, 0x73,
+	0x30, 0x76,
+	0x05, 0x80, 0x3D, 0xEA,
 
-0x37, 0x43, 0xA0, 0xE8,
-0x3D, 0x53, 0xA0, 0xE8,
+	0x37, 0x43, 0xA0, 0xE8,
+	0x3D, 0x53, 0xA0, 0xE8,
 
-0x48, 0x70, 0xF8, 0xEC,
-0x2B, 0x48, 0x3C, 0xE9,
+	0x48, 0x70, 0xF8, 0xEC,
+	0x2B, 0x48, 0x3C, 0xE9,
 
-0x1F, 0x27, 0xBC, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x1F, 0x27, 0xBC, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x15, 0xC0, 0x20, 0xE9,
-0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
 
-0x15, 0xC0, 0x20, 0xE9,
-0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
 
-0x18, 0x3A, 0x41, 0xE9,
-0x1D, 0x32, 0x41, 0xE9,
+	0x18, 0x3A, 0x41, 0xE9,
+	0x1D, 0x32, 0x41, 0xE9,
 
-0x2A, 0x40, 0x20, 0xE9,
-0x56, 0x3D, 0x56, 0xDF,
+	0x2A, 0x40, 0x20, 0xE9,
+	0x56, 0x3D, 0x56, 0xDF,
 
-0x46, 0x37, 0x46, 0xDF,
-0x4E, 0x3F, 0x4E, 0xDF,
+	0x46, 0x37, 0x46, 0xDF,
+	0x4E, 0x3F, 0x4E, 0xDF,
 
-0x16, 0x30, 0x20, 0xE9,
-0x4F, 0x3F, 0x4F, 0xDF,
+	0x16, 0x30, 0x20, 0xE9,
+	0x4F, 0x3F, 0x4F, 0xDF,
 
-0x32, 0x32, 0x2D, 0xDF,
-0x22, 0x22, 0x2D, 0xDF,
+	0x32, 0x32, 0x2D, 0xDF,
+	0x22, 0x22, 0x2D, 0xDF,
 
-0x12, 0x12, 0x2D, 0xDF,
-0x3A, 0x3A, 0x2D, 0xDF,
+	0x12, 0x12, 0x2D, 0xDF,
+	0x3A, 0x3A, 0x2D, 0xDF,
 
-0x47, 0x37, 0x47, 0xDF,
-0x57, 0x3D, 0x57, 0xDF,
+	0x47, 0x37, 0x47, 0xDF,
+	0x57, 0x3D, 0x57, 0xDF,
 
-0x3D, 0xCF, 0x74, 0xC0,
-0x37, 0xCF, 0x74, 0xC4,
+	0x3D, 0xCF, 0x74, 0xC0,
+	0x37, 0xCF, 0x74, 0xC4,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x34, 0x80, 0x20, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x34, 0x80, 0x20, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x88, 0x73, 0x5E, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0x88, 0x73, 0x5E, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x27, 0xCF, 0x75, 0xC6,
-0x3C, 0x3D, 0x20, 0xE9,
+	0x27, 0xCF, 0x75, 0xC6,
+	0x3C, 0x3D, 0x20, 0xE9,
 
-0x0A, 0x44, 0x4C, 0xB0,
-0x02, 0x44, 0x54, 0xB0,
+	0x0A, 0x44, 0x4C, 0xB0,
+	0x02, 0x44, 0x54, 0xB0,
 
-0x2A, 0x44, 0x4C, 0xB2,
-0x1A, 0x44, 0x54, 0xB2,
+	0x2A, 0x44, 0x4C, 0xB2,
+	0x1A, 0x44, 0x54, 0xB2,
 
-0x20, 0x80, 0x3A, 0xEA,
-0x0A, 0x20,
-0x02, 0x20,
+	0x20, 0x80, 0x3A, 0xEA,
+	0x0A, 0x20,
+	0x02, 0x20,
 
-0x3D, 0xCF, 0x74, 0xC2,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x3D, 0xCF, 0x74, 0xC2,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x32, 0x31, 0x5F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x32, 0x31, 0x5F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x33, 0x39, 0x5F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x33, 0x39, 0x5F, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x31, 0x27, 0x20, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x31, 0x27, 0x20, 0xE9,
 
-0x0A, 0x44, 0x4C, 0xB4,
-0x02, 0x44, 0x54, 0xB4,
+	0x0A, 0x44, 0x4C, 0xB4,
+	0x02, 0x44, 0x54, 0xB4,
 
-0x2A, 0x45, 0x4D, 0xB6,
-0x1A, 0x45, 0x55, 0xB6,
+	0x2A, 0x45, 0x4D, 0xB6,
+	0x1A, 0x45, 0x55, 0xB6,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x38, 0x3D, 0x20, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x38, 0x3D, 0x20, 0xE9,
 
-0x0A, 0x20,
-0x02, 0x20,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x0A, 0x20,
+	0x02, 0x20,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0x0A, 0x47, 0x4F, 0xBF,
-0x02, 0x47, 0x57, 0xBF,
+	0x0A, 0x47, 0x4F, 0xBF,
+	0x02, 0x47, 0x57, 0xBF,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x3E, 0x30, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x3E, 0x30, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x3F, 0x38, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x3F, 0x38, 0x4F, 0xE9,
 
-0x2A, 0x46, 0x4E, 0xBF,
-0x1A, 0x46, 0x56, 0xBF,
+	0x2A, 0x46, 0x4E, 0xBF,
+	0x1A, 0x46, 0x56, 0xBF,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x3A, 0x31, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x3A, 0x31, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x3B, 0x39, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3B, 0x39, 0x4F, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x36, 0x30, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x36, 0x30, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x37, 0x38, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x37, 0x38, 0x4F, 0xE9,
 
-0x2A, 0x43, 0x4B, 0xBF,
-0x1A, 0x43, 0x53, 0xBF,
+	0x2A, 0x43, 0x4B, 0xBF,
+	0x1A, 0x43, 0x53, 0xBF,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x35, 0x31, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x35, 0x31, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x39, 0x39, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x39, 0x39, 0x4F, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x80, 0x31, 0x57, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x80, 0x31, 0x57, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x81, 0x39, 0x57, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x81, 0x39, 0x57, 0xE9,
 
-0x37, 0x48, 0x50, 0xBD,
-0x8A, 0x36, 0x20, 0xE9,
+	0x37, 0x48, 0x50, 0xBD,
+	0x8A, 0x36, 0x20, 0xE9,
 
-0x86, 0x76, 0x57, 0xE9,
-0x8B, 0x3E, 0x20, 0xE9,
+	0x86, 0x76, 0x57, 0xE9,
+	0x8B, 0x3E, 0x20, 0xE9,
 
-0x82, 0x30, 0x57, 0xE9,
-0x87, 0x77, 0x57, 0xE9,
+	0x82, 0x30, 0x57, 0xE9,
+	0x87, 0x77, 0x57, 0xE9,
 
-0x83, 0x38, 0x57, 0xE9,
-0x35, 0x49, 0x51, 0xBD,
+	0x83, 0x38, 0x57, 0xE9,
+	0x35, 0x49, 0x51, 0xBD,
 
-0x84, 0x31, 0x5E, 0xE9,
-0x30, 0x1F, 0x5F, 0xE9,
+	0x84, 0x31, 0x5E, 0xE9,
+	0x30, 0x1F, 0x5F, 0xE9,
 
-0x85, 0x39, 0x5E, 0xE9,
-0x57, 0x25, 0x20, 0xE9,
+	0x85, 0x39, 0x5E, 0xE9,
+	0x57, 0x25, 0x20, 0xE9,
 
-0x2B, 0x48, 0x20, 0xE9,
-0x1D, 0x37, 0xE1, 0xEA,
+	0x2B, 0x48, 0x20, 0xE9,
+	0x1D, 0x37, 0xE1, 0xEA,
 
-0x1E, 0x35, 0xE1, 0xEA,
-0x00, 0xE0,
-0x26, 0x77,
+	0x1E, 0x35, 0xE1, 0xEA,
+	0x00, 0xE0,
+	0x26, 0x77,
 
-0x24, 0x49, 0x20, 0xE9,
-0xAA, 0xFF, 0x20, 0xEA,
+	0x24, 0x49, 0x20, 0xE9,
+	0xAA, 0xFF, 0x20, 0xEA,
 
-0x16, 0x26, 0x20, 0xE9,
-0x57, 0x2E, 0xBF, 0xEA,
+	0x16, 0x26, 0x20, 0xE9,
+	0x57, 0x2E, 0xBF, 0xEA,
 
-0x1C, 0x46, 0xA0, 0xE8,
-0x23, 0x4E, 0xA0, 0xE8,
+	0x1C, 0x46, 0xA0, 0xE8,
+	0x23, 0x4E, 0xA0, 0xE8,
 
-0x2B, 0x56, 0xA0, 0xE8,
-0x1D, 0x47, 0xA0, 0xE8,
+	0x2B, 0x56, 0xA0, 0xE8,
+	0x1D, 0x47, 0xA0, 0xE8,
 
-0x24, 0x4F, 0xA0, 0xE8,
-0x2C, 0x57, 0xA0, 0xE8,
+	0x24, 0x4F, 0xA0, 0xE8,
+	0x2C, 0x57, 0xA0, 0xE8,
 
-0x1C, 0x00,
-0x23, 0x00,
-0x2B, 0x00,
-0x00, 0xE0,
+	0x1C, 0x00,
+	0x23, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
 
-0x1D, 0x00,
-0x24, 0x00,
-0x2C, 0x00,
-0x00, 0xE0,
+	0x1D, 0x00,
+	0x24, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
 
-0x1C, 0x65,
-0x23, 0x65,
-0x2B, 0x65,
-0x00, 0xE0,
+	0x1C, 0x65,
+	0x23, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
 
-0x1D, 0x65,
-0x24, 0x65,
-0x2C, 0x65,
-0x00, 0xE0,
+	0x1D, 0x65,
+	0x24, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
 
-0x1C, 0x23, 0x60, 0xEC,
-0x36, 0xD7, 0x36, 0xAD,
+	0x1C, 0x23, 0x60, 0xEC,
+	0x36, 0xD7, 0x36, 0xAD,
 
-0x2B, 0x80, 0x60, 0xEC,
-0x1D, 0x24, 0x60, 0xEC,
+	0x2B, 0x80, 0x60, 0xEC,
+	0x1D, 0x24, 0x60, 0xEC,
 
-0x3E, 0xD7, 0x3E, 0xAD,
-0x2C, 0x80, 0x60, 0xEC,
+	0x3E, 0xD7, 0x3E, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
 
-0x1C, 0x2B, 0xDE, 0xE8,
-0x23, 0x80, 0xDE, 0xE8,
+	0x1C, 0x2B, 0xDE, 0xE8,
+	0x23, 0x80, 0xDE, 0xE8,
 
-0x36, 0x80, 0x36, 0xBD,
-0x3E, 0x80, 0x3E, 0xBD,
+	0x36, 0x80, 0x36, 0xBD,
+	0x3E, 0x80, 0x3E, 0xBD,
 
-0x33, 0xD7, 0x1C, 0xBD,
-0x3B, 0xD7, 0x23, 0xBD,
+	0x33, 0xD7, 0x1C, 0xBD,
+	0x3B, 0xD7, 0x23, 0xBD,
 
-0x46, 0x80, 0x46, 0xCF,
-0x4F, 0x80, 0x4F, 0xCF,
+	0x46, 0x80, 0x46, 0xCF,
+	0x4F, 0x80, 0x4F, 0xCF,
 
-0x56, 0x33, 0x56, 0xCF,
-0x47, 0x3B, 0x47, 0xCF,
+	0x56, 0x33, 0x56, 0xCF,
+	0x47, 0x3B, 0x47, 0xCF,
 
-0xD3, 0xFF, 0x20, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0xD3, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x4E, 0x33, 0x4E, 0xCF,
-0x57, 0x3B, 0x57, 0xCF,
+	0x4E, 0x33, 0x4E, 0xCF,
+	0x57, 0x3B, 0x57, 0xCF,
 
-0x98, 0xFF, 0x20, 0xEA,
-0x57, 0xC0, 0xBF, 0xEA,
+	0x98, 0xFF, 0x20, 0xEA,
+	0x57, 0xC0, 0xBF, 0xEA,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x00, 0x00, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
 
 };
 
 static unsigned char warp_g400_tgzs[] = {
 
-0x00, 0x88, 0x98, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x88, 0x98, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x00, 0x00, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
 
-0xFF, 0x80, 0xC0, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x22, 0x40, 0x48, 0xBF,
-0x2A, 0x40, 0x50, 0xBF,
+	0x22, 0x40, 0x48, 0xBF,
+	0x2A, 0x40, 0x50, 0xBF,
 
-0x32, 0x41, 0x49, 0xBF,
-0x3A, 0x41, 0x51, 0xBF,
+	0x32, 0x41, 0x49, 0xBF,
+	0x3A, 0x41, 0x51, 0xBF,
 
-0xC3, 0x6B,
-0xCB, 0x6B,
-0x00, 0x88, 0x98, 0xE9,
+	0xC3, 0x6B,
+	0xCB, 0x6B,
+	0x00, 0x88, 0x98, 0xE9,
 
-0x73, 0x7B, 0xC8, 0xEC,
-0x96, 0xE2,
-0x41, 0x04,
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x96, 0xE2,
+	0x41, 0x04,
 
-0x7B, 0x43, 0xA0, 0xE8,
-0x73, 0x4B, 0xA0, 0xE8,
+	0x7B, 0x43, 0xA0, 0xE8,
+	0x73, 0x4B, 0xA0, 0xE8,
 
-0xAD, 0xEE, 0x29, 0x9F,
-0x00, 0xE0,
-0x49, 0x04,
+	0xAD, 0xEE, 0x29, 0x9F,
+	0x00, 0xE0,
+	0x49, 0x04,
 
-0x90, 0xE2,
-0x51, 0x04,
-0x31, 0x46, 0xB1, 0xE8,
+	0x90, 0xE2,
+	0x51, 0x04,
+	0x31, 0x46, 0xB1, 0xE8,
 
-0x49, 0x41, 0xC0, 0xEC,
-0x39, 0x57, 0xB1, 0xE8,
+	0x49, 0x41, 0xC0, 0xEC,
+	0x39, 0x57, 0xB1, 0xE8,
 
-0x00, 0x04,
-0x46, 0xE2,
-0x73, 0x53, 0xA0, 0xE8,
+	0x00, 0x04,
+	0x46, 0xE2,
+	0x73, 0x53, 0xA0, 0xE8,
 
-0x51, 0x41, 0xC0, 0xEC,
-0x31, 0x00,
-0x39, 0x00,
+	0x51, 0x41, 0xC0, 0xEC,
+	0x31, 0x00,
+	0x39, 0x00,
 
-0x65, 0x80, 0x15, 0xEA,
-0x08, 0x04,
-0x10, 0x04,
+	0x65, 0x80, 0x15, 0xEA,
+	0x08, 0x04,
+	0x10, 0x04,
 
-0x51, 0x49, 0xC0, 0xEC,
-0x2F, 0x41, 0x60, 0xEA,
+	0x51, 0x49, 0xC0, 0xEC,
+	0x2F, 0x41, 0x60, 0xEA,
 
-0x31, 0x20,
-0x39, 0x20,
-0x1F, 0x42, 0xA0, 0xE8,
+	0x31, 0x20,
+	0x39, 0x20,
+	0x1F, 0x42, 0xA0, 0xE8,
 
-0x2A, 0x42, 0x4A, 0xBF,
-0x27, 0x4A, 0xA0, 0xE8,
+	0x2A, 0x42, 0x4A, 0xBF,
+	0x27, 0x4A, 0xA0, 0xE8,
 
-0x1A, 0x42, 0x52, 0xBF,
-0x1E, 0x49, 0x60, 0xEA,
+	0x1A, 0x42, 0x52, 0xBF,
+	0x1E, 0x49, 0x60, 0xEA,
 
-0x73, 0x7B, 0xC8, 0xEC,
-0x26, 0x51, 0x60, 0xEA,
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x26, 0x51, 0x60, 0xEA,
 
-0x32, 0x40, 0x48, 0xBD,
-0x22, 0x40, 0x50, 0xBD,
+	0x32, 0x40, 0x48, 0xBD,
+	0x22, 0x40, 0x50, 0xBD,
 
-0x12, 0x41, 0x49, 0xBD,
-0x3A, 0x41, 0x51, 0xBD,
+	0x12, 0x41, 0x49, 0xBD,
+	0x3A, 0x41, 0x51, 0xBD,
 
-0xBF, 0x2F, 0x26, 0xBD,
-0x00, 0xE0,
-0x7B, 0x72,
+	0xBF, 0x2F, 0x26, 0xBD,
+	0x00, 0xE0,
+	0x7B, 0x72,
 
-0x32, 0x20,
-0x22, 0x20,
-0x12, 0x20,
-0x3A, 0x20,
+	0x32, 0x20,
+	0x22, 0x20,
+	0x12, 0x20,
+	0x3A, 0x20,
 
-0x46, 0x31, 0x46, 0xBF,
-0x4E, 0x31, 0x4E, 0xBF,
+	0x46, 0x31, 0x46, 0xBF,
+	0x4E, 0x31, 0x4E, 0xBF,
 
-0xB3, 0xE2, 0x2D, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0xB3, 0xE2, 0x2D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x56, 0x31, 0x56, 0xBF,
-0x47, 0x39, 0x47, 0xBF,
+	0x56, 0x31, 0x56, 0xBF,
+	0x47, 0x39, 0x47, 0xBF,
 
-0x4F, 0x39, 0x4F, 0xBF,
-0x57, 0x39, 0x57, 0xBF,
+	0x4F, 0x39, 0x4F, 0xBF,
+	0x57, 0x39, 0x57, 0xBF,
 
-0x57, 0x80, 0x07, 0xEA,
-0x24, 0x41, 0x20, 0xE9,
+	0x57, 0x80, 0x07, 0xEA,
+	0x24, 0x41, 0x20, 0xE9,
 
-0x42, 0x73, 0xF8, 0xEC,
-0x00, 0xE0,
-0x2D, 0x73,
+	0x42, 0x73, 0xF8, 0xEC,
+	0x00, 0xE0,
+	0x2D, 0x73,
 
-0x33, 0x72,
-0x0C, 0xE3,
-0xA5, 0x2F, 0x1E, 0xBD,
+	0x33, 0x72,
+	0x0C, 0xE3,
+	0xA5, 0x2F, 0x1E, 0xBD,
 
-0x43, 0x43, 0x2D, 0xDF,
-0x4B, 0x4B, 0x2D, 0xDF,
+	0x43, 0x43, 0x2D, 0xDF,
+	0x4B, 0x4B, 0x2D, 0xDF,
 
-0xAE, 0x1E, 0x26, 0xBD,
-0x58, 0xE3,
-0x33, 0x66,
+	0xAE, 0x1E, 0x26, 0xBD,
+	0x58, 0xE3,
+	0x33, 0x66,
 
-0x53, 0x53, 0x2D, 0xDF,
-0x00, 0x80, 0x00, 0xE8,
+	0x53, 0x53, 0x2D, 0xDF,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xB8, 0x38, 0x33, 0xBF,
-0x00, 0xE0,
-0x59, 0xE3,
+	0xB8, 0x38, 0x33, 0xBF,
+	0x00, 0xE0,
+	0x59, 0xE3,
 
-0x1E, 0x12, 0x41, 0xE9,
-0x1A, 0x22, 0x41, 0xE9,
+	0x1E, 0x12, 0x41, 0xE9,
+	0x1A, 0x22, 0x41, 0xE9,
 
-0x2B, 0x40, 0x3D, 0xE9,
-0x3F, 0x4B, 0xA0, 0xE8,
+	0x2B, 0x40, 0x3D, 0xE9,
+	0x3F, 0x4B, 0xA0, 0xE8,
 
-0x2D, 0x73,
-0x30, 0x76,
-0x05, 0x80, 0x3D, 0xEA,
+	0x2D, 0x73,
+	0x30, 0x76,
+	0x05, 0x80, 0x3D, 0xEA,
 
-0x37, 0x43, 0xA0, 0xE8,
-0x3D, 0x53, 0xA0, 0xE8,
+	0x37, 0x43, 0xA0, 0xE8,
+	0x3D, 0x53, 0xA0, 0xE8,
 
-0x48, 0x70, 0xF8, 0xEC,
-0x2B, 0x48, 0x3C, 0xE9,
+	0x48, 0x70, 0xF8, 0xEC,
+	0x2B, 0x48, 0x3C, 0xE9,
 
-0x1F, 0x27, 0xBC, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x1F, 0x27, 0xBC, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x15, 0xC0, 0x20, 0xE9,
-0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
 
-0x15, 0xC0, 0x20, 0xE9,
-0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
 
-0x18, 0x3A, 0x41, 0xE9,
-0x1D, 0x32, 0x41, 0xE9,
+	0x18, 0x3A, 0x41, 0xE9,
+	0x1D, 0x32, 0x41, 0xE9,
 
-0x2A, 0x40, 0x20, 0xE9,
-0x56, 0x3D, 0x56, 0xDF,
+	0x2A, 0x40, 0x20, 0xE9,
+	0x56, 0x3D, 0x56, 0xDF,
 
-0x46, 0x37, 0x46, 0xDF,
-0x4E, 0x3F, 0x4E, 0xDF,
+	0x46, 0x37, 0x46, 0xDF,
+	0x4E, 0x3F, 0x4E, 0xDF,
 
-0x16, 0x30, 0x20, 0xE9,
-0x4F, 0x3F, 0x4F, 0xDF,
+	0x16, 0x30, 0x20, 0xE9,
+	0x4F, 0x3F, 0x4F, 0xDF,
 
-0x47, 0x37, 0x47, 0xDF,
-0x57, 0x3D, 0x57, 0xDF,
+	0x47, 0x37, 0x47, 0xDF,
+	0x57, 0x3D, 0x57, 0xDF,
 
-0x32, 0x32, 0x2D, 0xDF,
-0x22, 0x22, 0x2D, 0xDF,
+	0x32, 0x32, 0x2D, 0xDF,
+	0x22, 0x22, 0x2D, 0xDF,
 
-0x12, 0x12, 0x2D, 0xDF,
-0x3A, 0x3A, 0x2D, 0xDF,
+	0x12, 0x12, 0x2D, 0xDF,
+	0x3A, 0x3A, 0x2D, 0xDF,
 
-0x27, 0xCF, 0x74, 0xC2,
-0x37, 0xCF, 0x74, 0xC4,
+	0x27, 0xCF, 0x74, 0xC2,
+	0x37, 0xCF, 0x74, 0xC4,
 
-0x0A, 0x44, 0x4C, 0xB0,
-0x02, 0x44, 0x54, 0xB0,
+	0x0A, 0x44, 0x4C, 0xB0,
+	0x02, 0x44, 0x54, 0xB0,
 
-0x3D, 0xCF, 0x74, 0xC0,
-0x34, 0x37, 0x20, 0xE9,
+	0x3D, 0xCF, 0x74, 0xC0,
+	0x34, 0x37, 0x20, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x38, 0x27, 0x20, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x38, 0x27, 0x20, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x3C, 0x3D, 0x20, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3C, 0x3D, 0x20, 0xE9,
 
-0x2A, 0x44, 0x4C, 0xB2,
-0x1A, 0x44, 0x54, 0xB2,
+	0x2A, 0x44, 0x4C, 0xB2,
+	0x1A, 0x44, 0x54, 0xB2,
 
-0x29, 0x80, 0x3A, 0xEA,
-0x0A, 0x20,
-0x02, 0x20,
+	0x29, 0x80, 0x3A, 0xEA,
+	0x0A, 0x20,
+	0x02, 0x20,
 
-0x27, 0xCF, 0x75, 0xC0,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x27, 0xCF, 0x75, 0xC0,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x32, 0x31, 0x5F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x32, 0x31, 0x5F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x33, 0x39, 0x5F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x33, 0x39, 0x5F, 0xE9,
 
-0x3D, 0xCF, 0x75, 0xC2,
-0x37, 0xCF, 0x75, 0xC4,
+	0x3D, 0xCF, 0x75, 0xC2,
+	0x37, 0xCF, 0x75, 0xC4,
 
-0x31, 0x53, 0x2F, 0x9F,
-0xA6, 0x27, 0x20, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA6, 0x27, 0x20, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0xA3, 0x3D, 0x20, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA3, 0x3D, 0x20, 0xE9,
 
-0x2A, 0x44, 0x4C, 0xB4,
-0x1A, 0x44, 0x54, 0xB4,
+	0x2A, 0x44, 0x4C, 0xB4,
+	0x1A, 0x44, 0x54, 0xB4,
 
-0x0A, 0x45, 0x4D, 0xB0,
-0x02, 0x45, 0x55, 0xB0,
+	0x0A, 0x45, 0x4D, 0xB0,
+	0x02, 0x45, 0x55, 0xB0,
 
-0x88, 0x73, 0x5E, 0xE9,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x88, 0x73, 0x5E, 0xE9,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0xA0, 0x37, 0x20, 0xE9,
-0x0A, 0x20,
-0x02, 0x20,
+	0xA0, 0x37, 0x20, 0xE9,
+	0x0A, 0x20,
+	0x02, 0x20,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x3E, 0x30, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x3E, 0x30, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x3F, 0x38, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3F, 0x38, 0x4F, 0xE9,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x3A, 0x31, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x3A, 0x31, 0x4F, 0xE9,
 
-0x2A, 0x45, 0x4D, 0xB2,
-0x1A, 0x45, 0x55, 0xB2,
+	0x2A, 0x45, 0x4D, 0xB2,
+	0x1A, 0x45, 0x55, 0xB2,
 
-0x0A, 0x45, 0x4D, 0xB4,
-0x02, 0x45, 0x55, 0xB4,
+	0x0A, 0x45, 0x4D, 0xB4,
+	0x02, 0x45, 0x55, 0xB4,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x3B, 0x39, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x3B, 0x39, 0x4F, 0xE9,
 
-0x0A, 0x20,
-0x02, 0x20,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x0A, 0x20,
+	0x02, 0x20,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0x2A, 0x46, 0x4E, 0xBF,
-0x1A, 0x46, 0x56, 0xBF,
+	0x2A, 0x46, 0x4E, 0xBF,
+	0x1A, 0x46, 0x56, 0xBF,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x36, 0x31, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x36, 0x31, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x37, 0x39, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x37, 0x39, 0x4F, 0xE9,
 
-0x30, 0x50, 0x2E, 0x9F,
-0xA7, 0x30, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0xA7, 0x30, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0xA8, 0x38, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0xA8, 0x38, 0x4F, 0xE9,
 
-0x0A, 0x47, 0x4F, 0xBF,
-0x02, 0x47, 0x57, 0xBF,
+	0x0A, 0x47, 0x4F, 0xBF,
+	0x02, 0x47, 0x57, 0xBF,
 
-0x31, 0x53, 0x2F, 0x9F,
-0xA4, 0x31, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA4, 0x31, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0xA5, 0x39, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA5, 0x39, 0x4F, 0xE9,
 
-0x2A, 0x43, 0x4B, 0xBF,
-0x1A, 0x43, 0x53, 0xBF,
+	0x2A, 0x43, 0x4B, 0xBF,
+	0x1A, 0x43, 0x53, 0xBF,
 
-0x30, 0x50, 0x2E, 0x9F,
-0xA1, 0x30, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0xA1, 0x30, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0xA2, 0x38, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0xA2, 0x38, 0x4F, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x80, 0x31, 0x57, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x80, 0x31, 0x57, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x81, 0x39, 0x57, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x81, 0x39, 0x57, 0xE9,
 
-0x37, 0x48, 0x50, 0xBD,
-0x8A, 0x36, 0x20, 0xE9,
+	0x37, 0x48, 0x50, 0xBD,
+	0x8A, 0x36, 0x20, 0xE9,
 
-0x86, 0x76, 0x57, 0xE9,
-0x8B, 0x3E, 0x20, 0xE9,
+	0x86, 0x76, 0x57, 0xE9,
+	0x8B, 0x3E, 0x20, 0xE9,
 
-0x82, 0x30, 0x57, 0xE9,
-0x87, 0x77, 0x57, 0xE9,
+	0x82, 0x30, 0x57, 0xE9,
+	0x87, 0x77, 0x57, 0xE9,
 
-0x83, 0x38, 0x57, 0xE9,
-0x35, 0x49, 0x51, 0xBD,
+	0x83, 0x38, 0x57, 0xE9,
+	0x35, 0x49, 0x51, 0xBD,
 
-0x84, 0x31, 0x5E, 0xE9,
-0x30, 0x1F, 0x5F, 0xE9,
+	0x84, 0x31, 0x5E, 0xE9,
+	0x30, 0x1F, 0x5F, 0xE9,
 
-0x85, 0x39, 0x5E, 0xE9,
-0x57, 0x25, 0x20, 0xE9,
+	0x85, 0x39, 0x5E, 0xE9,
+	0x57, 0x25, 0x20, 0xE9,
 
-0x2B, 0x48, 0x20, 0xE9,
-0x1D, 0x37, 0xE1, 0xEA,
+	0x2B, 0x48, 0x20, 0xE9,
+	0x1D, 0x37, 0xE1, 0xEA,
 
-0x1E, 0x35, 0xE1, 0xEA,
-0x00, 0xE0,
-0x26, 0x77,
+	0x1E, 0x35, 0xE1, 0xEA,
+	0x00, 0xE0,
+	0x26, 0x77,
 
-0x24, 0x49, 0x20, 0xE9,
-0xA2, 0xFF, 0x20, 0xEA,
+	0x24, 0x49, 0x20, 0xE9,
+	0xA2, 0xFF, 0x20, 0xEA,
 
-0x16, 0x26, 0x20, 0xE9,
-0x57, 0x2E, 0xBF, 0xEA,
+	0x16, 0x26, 0x20, 0xE9,
+	0x57, 0x2E, 0xBF, 0xEA,
 
-0x1C, 0x46, 0xA0, 0xE8,
-0x23, 0x4E, 0xA0, 0xE8,
+	0x1C, 0x46, 0xA0, 0xE8,
+	0x23, 0x4E, 0xA0, 0xE8,
 
-0x2B, 0x56, 0xA0, 0xE8,
-0x1D, 0x47, 0xA0, 0xE8,
+	0x2B, 0x56, 0xA0, 0xE8,
+	0x1D, 0x47, 0xA0, 0xE8,
 
-0x24, 0x4F, 0xA0, 0xE8,
-0x2C, 0x57, 0xA0, 0xE8,
+	0x24, 0x4F, 0xA0, 0xE8,
+	0x2C, 0x57, 0xA0, 0xE8,
 
-0x1C, 0x00,
-0x23, 0x00,
-0x2B, 0x00,
-0x00, 0xE0,
+	0x1C, 0x00,
+	0x23, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
 
-0x1D, 0x00,
-0x24, 0x00,
-0x2C, 0x00,
-0x00, 0xE0,
+	0x1D, 0x00,
+	0x24, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
 
-0x1C, 0x65,
-0x23, 0x65,
-0x2B, 0x65,
-0x00, 0xE0,
+	0x1C, 0x65,
+	0x23, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
 
-0x1D, 0x65,
-0x24, 0x65,
-0x2C, 0x65,
-0x00, 0xE0,
+	0x1D, 0x65,
+	0x24, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
 
-0x1C, 0x23, 0x60, 0xEC,
-0x36, 0xD7, 0x36, 0xAD,
+	0x1C, 0x23, 0x60, 0xEC,
+	0x36, 0xD7, 0x36, 0xAD,
 
-0x2B, 0x80, 0x60, 0xEC,
-0x1D, 0x24, 0x60, 0xEC,
+	0x2B, 0x80, 0x60, 0xEC,
+	0x1D, 0x24, 0x60, 0xEC,
 
-0x3E, 0xD7, 0x3E, 0xAD,
-0x2C, 0x80, 0x60, 0xEC,
+	0x3E, 0xD7, 0x3E, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
 
-0x1C, 0x2B, 0xDE, 0xE8,
-0x23, 0x80, 0xDE, 0xE8,
+	0x1C, 0x2B, 0xDE, 0xE8,
+	0x23, 0x80, 0xDE, 0xE8,
 
-0x36, 0x80, 0x36, 0xBD,
-0x3E, 0x80, 0x3E, 0xBD,
+	0x36, 0x80, 0x36, 0xBD,
+	0x3E, 0x80, 0x3E, 0xBD,
 
-0x33, 0xD7, 0x1C, 0xBD,
-0x3B, 0xD7, 0x23, 0xBD,
+	0x33, 0xD7, 0x1C, 0xBD,
+	0x3B, 0xD7, 0x23, 0xBD,
 
-0x46, 0x80, 0x46, 0xCF,
-0x4F, 0x80, 0x4F, 0xCF,
+	0x46, 0x80, 0x46, 0xCF,
+	0x4F, 0x80, 0x4F, 0xCF,
 
-0x56, 0x33, 0x56, 0xCF,
-0x47, 0x3B, 0x47, 0xCF,
+	0x56, 0x33, 0x56, 0xCF,
+	0x47, 0x3B, 0x47, 0xCF,
 
-0xCA, 0xFF, 0x20, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0xCA, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x4E, 0x33, 0x4E, 0xCF,
-0x57, 0x3B, 0x57, 0xCF,
+	0x4E, 0x33, 0x4E, 0xCF,
+	0x57, 0x3B, 0x57, 0xCF,
 
-0x90, 0xFF, 0x20, 0xEA,
-0x57, 0xC0, 0xBF, 0xEA,
+	0x90, 0xFF, 0x20, 0xEA,
+	0x57, 0xC0, 0xBF, 0xEA,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x00, 0x00, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
 
 };
 
 static unsigned char warp_g400_tgzsa[] = {
 
-0x00, 0x88, 0x98, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x88, 0x98, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x00, 0x00, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
 
-0xFF, 0x80, 0xC0, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x22, 0x40, 0x48, 0xBF,
-0x2A, 0x40, 0x50, 0xBF,
+	0x22, 0x40, 0x48, 0xBF,
+	0x2A, 0x40, 0x50, 0xBF,
 
-0x32, 0x41, 0x49, 0xBF,
-0x3A, 0x41, 0x51, 0xBF,
+	0x32, 0x41, 0x49, 0xBF,
+	0x3A, 0x41, 0x51, 0xBF,
 
-0xC3, 0x6B,
-0xCB, 0x6B,
-0x00, 0x88, 0x98, 0xE9,
+	0xC3, 0x6B,
+	0xCB, 0x6B,
+	0x00, 0x88, 0x98, 0xE9,
 
-0x73, 0x7B, 0xC8, 0xEC,
-0x96, 0xE2,
-0x41, 0x04,
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x96, 0xE2,
+	0x41, 0x04,
 
-0x7B, 0x43, 0xA0, 0xE8,
-0x73, 0x4B, 0xA0, 0xE8,
+	0x7B, 0x43, 0xA0, 0xE8,
+	0x73, 0x4B, 0xA0, 0xE8,
 
-0xAD, 0xEE, 0x29, 0x9F,
-0x00, 0xE0,
-0x49, 0x04,
+	0xAD, 0xEE, 0x29, 0x9F,
+	0x00, 0xE0,
+	0x49, 0x04,
 
-0x90, 0xE2,
-0x51, 0x04,
-0x31, 0x46, 0xB1, 0xE8,
+	0x90, 0xE2,
+	0x51, 0x04,
+	0x31, 0x46, 0xB1, 0xE8,
 
-0x49, 0x41, 0xC0, 0xEC,
-0x39, 0x57, 0xB1, 0xE8,
+	0x49, 0x41, 0xC0, 0xEC,
+	0x39, 0x57, 0xB1, 0xE8,
 
-0x00, 0x04,
-0x46, 0xE2,
-0x73, 0x53, 0xA0, 0xE8,
+	0x00, 0x04,
+	0x46, 0xE2,
+	0x73, 0x53, 0xA0, 0xE8,
 
-0x51, 0x41, 0xC0, 0xEC,
-0x31, 0x00,
-0x39, 0x00,
+	0x51, 0x41, 0xC0, 0xEC,
+	0x31, 0x00,
+	0x39, 0x00,
 
-0x6A, 0x80, 0x15, 0xEA,
-0x08, 0x04,
-0x10, 0x04,
+	0x6A, 0x80, 0x15, 0xEA,
+	0x08, 0x04,
+	0x10, 0x04,
 
-0x51, 0x49, 0xC0, 0xEC,
-0x2F, 0x41, 0x60, 0xEA,
+	0x51, 0x49, 0xC0, 0xEC,
+	0x2F, 0x41, 0x60, 0xEA,
 
-0x31, 0x20,
-0x39, 0x20,
-0x1F, 0x42, 0xA0, 0xE8,
+	0x31, 0x20,
+	0x39, 0x20,
+	0x1F, 0x42, 0xA0, 0xE8,
 
-0x2A, 0x42, 0x4A, 0xBF,
-0x27, 0x4A, 0xA0, 0xE8,
+	0x2A, 0x42, 0x4A, 0xBF,
+	0x27, 0x4A, 0xA0, 0xE8,
 
-0x1A, 0x42, 0x52, 0xBF,
-0x1E, 0x49, 0x60, 0xEA,
+	0x1A, 0x42, 0x52, 0xBF,
+	0x1E, 0x49, 0x60, 0xEA,
 
-0x73, 0x7B, 0xC8, 0xEC,
-0x26, 0x51, 0x60, 0xEA,
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x26, 0x51, 0x60, 0xEA,
 
-0x32, 0x40, 0x48, 0xBD,
-0x22, 0x40, 0x50, 0xBD,
+	0x32, 0x40, 0x48, 0xBD,
+	0x22, 0x40, 0x50, 0xBD,
 
-0x12, 0x41, 0x49, 0xBD,
-0x3A, 0x41, 0x51, 0xBD,
+	0x12, 0x41, 0x49, 0xBD,
+	0x3A, 0x41, 0x51, 0xBD,
 
-0xBF, 0x2F, 0x26, 0xBD,
-0x00, 0xE0,
-0x7B, 0x72,
+	0xBF, 0x2F, 0x26, 0xBD,
+	0x00, 0xE0,
+	0x7B, 0x72,
 
-0x32, 0x20,
-0x22, 0x20,
-0x12, 0x20,
-0x3A, 0x20,
+	0x32, 0x20,
+	0x22, 0x20,
+	0x12, 0x20,
+	0x3A, 0x20,
 
-0x46, 0x31, 0x46, 0xBF,
-0x4E, 0x31, 0x4E, 0xBF,
+	0x46, 0x31, 0x46, 0xBF,
+	0x4E, 0x31, 0x4E, 0xBF,
 
-0xB3, 0xE2, 0x2D, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0xB3, 0xE2, 0x2D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x56, 0x31, 0x56, 0xBF,
-0x47, 0x39, 0x47, 0xBF,
+	0x56, 0x31, 0x56, 0xBF,
+	0x47, 0x39, 0x47, 0xBF,
 
-0x4F, 0x39, 0x4F, 0xBF,
-0x57, 0x39, 0x57, 0xBF,
+	0x4F, 0x39, 0x4F, 0xBF,
+	0x57, 0x39, 0x57, 0xBF,
 
-0x5C, 0x80, 0x07, 0xEA,
-0x24, 0x41, 0x20, 0xE9,
+	0x5C, 0x80, 0x07, 0xEA,
+	0x24, 0x41, 0x20, 0xE9,
 
-0x42, 0x73, 0xF8, 0xEC,
-0x00, 0xE0,
-0x2D, 0x73,
+	0x42, 0x73, 0xF8, 0xEC,
+	0x00, 0xE0,
+	0x2D, 0x73,
 
-0x33, 0x72,
-0x0C, 0xE3,
-0xA5, 0x2F, 0x1E, 0xBD,
+	0x33, 0x72,
+	0x0C, 0xE3,
+	0xA5, 0x2F, 0x1E, 0xBD,
 
-0x43, 0x43, 0x2D, 0xDF,
-0x4B, 0x4B, 0x2D, 0xDF,
+	0x43, 0x43, 0x2D, 0xDF,
+	0x4B, 0x4B, 0x2D, 0xDF,
 
-0xAE, 0x1E, 0x26, 0xBD,
-0x58, 0xE3,
-0x33, 0x66,
+	0xAE, 0x1E, 0x26, 0xBD,
+	0x58, 0xE3,
+	0x33, 0x66,
 
-0x53, 0x53, 0x2D, 0xDF,
-0x00, 0x80, 0x00, 0xE8,
+	0x53, 0x53, 0x2D, 0xDF,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xB8, 0x38, 0x33, 0xBF,
-0x00, 0xE0,
-0x59, 0xE3,
+	0xB8, 0x38, 0x33, 0xBF,
+	0x00, 0xE0,
+	0x59, 0xE3,
 
-0x1E, 0x12, 0x41, 0xE9,
-0x1A, 0x22, 0x41, 0xE9,
+	0x1E, 0x12, 0x41, 0xE9,
+	0x1A, 0x22, 0x41, 0xE9,
 
-0x2B, 0x40, 0x3D, 0xE9,
-0x3F, 0x4B, 0xA0, 0xE8,
+	0x2B, 0x40, 0x3D, 0xE9,
+	0x3F, 0x4B, 0xA0, 0xE8,
 
-0x2D, 0x73,
-0x30, 0x76,
-0x05, 0x80, 0x3D, 0xEA,
+	0x2D, 0x73,
+	0x30, 0x76,
+	0x05, 0x80, 0x3D, 0xEA,
 
-0x37, 0x43, 0xA0, 0xE8,
-0x3D, 0x53, 0xA0, 0xE8,
+	0x37, 0x43, 0xA0, 0xE8,
+	0x3D, 0x53, 0xA0, 0xE8,
 
-0x48, 0x70, 0xF8, 0xEC,
-0x2B, 0x48, 0x3C, 0xE9,
+	0x48, 0x70, 0xF8, 0xEC,
+	0x2B, 0x48, 0x3C, 0xE9,
 
-0x1F, 0x27, 0xBC, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x1F, 0x27, 0xBC, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x15, 0xC0, 0x20, 0xE9,
-0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
 
-0x15, 0xC0, 0x20, 0xE9,
-0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
 
-0x18, 0x3A, 0x41, 0xE9,
-0x1D, 0x32, 0x41, 0xE9,
+	0x18, 0x3A, 0x41, 0xE9,
+	0x1D, 0x32, 0x41, 0xE9,
 
-0x2A, 0x40, 0x20, 0xE9,
-0x56, 0x3D, 0x56, 0xDF,
+	0x2A, 0x40, 0x20, 0xE9,
+	0x56, 0x3D, 0x56, 0xDF,
 
-0x46, 0x37, 0x46, 0xDF,
-0x4E, 0x3F, 0x4E, 0xDF,
+	0x46, 0x37, 0x46, 0xDF,
+	0x4E, 0x3F, 0x4E, 0xDF,
 
-0x16, 0x30, 0x20, 0xE9,
-0x4F, 0x3F, 0x4F, 0xDF,
+	0x16, 0x30, 0x20, 0xE9,
+	0x4F, 0x3F, 0x4F, 0xDF,
 
-0x47, 0x37, 0x47, 0xDF,
-0x57, 0x3D, 0x57, 0xDF,
+	0x47, 0x37, 0x47, 0xDF,
+	0x57, 0x3D, 0x57, 0xDF,
 
-0x32, 0x32, 0x2D, 0xDF,
-0x22, 0x22, 0x2D, 0xDF,
+	0x32, 0x32, 0x2D, 0xDF,
+	0x22, 0x22, 0x2D, 0xDF,
 
-0x12, 0x12, 0x2D, 0xDF,
-0x3A, 0x3A, 0x2D, 0xDF,
+	0x12, 0x12, 0x2D, 0xDF,
+	0x3A, 0x3A, 0x2D, 0xDF,
 
-0x27, 0xCF, 0x74, 0xC2,
-0x37, 0xCF, 0x74, 0xC4,
+	0x27, 0xCF, 0x74, 0xC2,
+	0x37, 0xCF, 0x74, 0xC4,
 
-0x0A, 0x44, 0x4C, 0xB0,
-0x02, 0x44, 0x54, 0xB0,
+	0x0A, 0x44, 0x4C, 0xB0,
+	0x02, 0x44, 0x54, 0xB0,
 
-0x3D, 0xCF, 0x74, 0xC0,
-0x34, 0x37, 0x20, 0xE9,
+	0x3D, 0xCF, 0x74, 0xC0,
+	0x34, 0x37, 0x20, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x38, 0x27, 0x20, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x38, 0x27, 0x20, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x3C, 0x3D, 0x20, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3C, 0x3D, 0x20, 0xE9,
 
-0x2A, 0x44, 0x4C, 0xB2,
-0x1A, 0x44, 0x54, 0xB2,
+	0x2A, 0x44, 0x4C, 0xB2,
+	0x1A, 0x44, 0x54, 0xB2,
 
-0x2E, 0x80, 0x3A, 0xEA,
-0x0A, 0x20,
-0x02, 0x20,
+	0x2E, 0x80, 0x3A, 0xEA,
+	0x0A, 0x20,
+	0x02, 0x20,
 
-0x27, 0xCF, 0x75, 0xC0,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x27, 0xCF, 0x75, 0xC0,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x32, 0x31, 0x5F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x32, 0x31, 0x5F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x33, 0x39, 0x5F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x33, 0x39, 0x5F, 0xE9,
 
-0x3D, 0xCF, 0x75, 0xC2,
-0x37, 0xCF, 0x75, 0xC4,
+	0x3D, 0xCF, 0x75, 0xC2,
+	0x37, 0xCF, 0x75, 0xC4,
 
-0x31, 0x53, 0x2F, 0x9F,
-0xA6, 0x27, 0x20, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA6, 0x27, 0x20, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0xA3, 0x3D, 0x20, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA3, 0x3D, 0x20, 0xE9,
 
-0x2A, 0x44, 0x4C, 0xB4,
-0x1A, 0x44, 0x54, 0xB4,
+	0x2A, 0x44, 0x4C, 0xB4,
+	0x1A, 0x44, 0x54, 0xB4,
 
-0x0A, 0x45, 0x4D, 0xB0,
-0x02, 0x45, 0x55, 0xB0,
+	0x0A, 0x45, 0x4D, 0xB0,
+	0x02, 0x45, 0x55, 0xB0,
 
-0x88, 0x73, 0x5E, 0xE9,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x88, 0x73, 0x5E, 0xE9,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0xA0, 0x37, 0x20, 0xE9,
-0x0A, 0x20,
-0x02, 0x20,
+	0xA0, 0x37, 0x20, 0xE9,
+	0x0A, 0x20,
+	0x02, 0x20,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x3E, 0x30, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x3E, 0x30, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x3F, 0x38, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3F, 0x38, 0x4F, 0xE9,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x3A, 0x31, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x3A, 0x31, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x3B, 0x39, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x3B, 0x39, 0x4F, 0xE9,
 
-0x2A, 0x45, 0x4D, 0xB2,
-0x1A, 0x45, 0x55, 0xB2,
+	0x2A, 0x45, 0x4D, 0xB2,
+	0x1A, 0x45, 0x55, 0xB2,
 
-0x0A, 0x45, 0x4D, 0xB4,
-0x02, 0x45, 0x55, 0xB4,
+	0x0A, 0x45, 0x4D, 0xB4,
+	0x02, 0x45, 0x55, 0xB4,
 
-0x27, 0xCF, 0x74, 0xC6,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x27, 0xCF, 0x74, 0xC6,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0xA7, 0x30, 0x4F, 0xE9,
-0x0A, 0x20,
-0x02, 0x20,
+	0xA7, 0x30, 0x4F, 0xE9,
+	0x0A, 0x20,
+	0x02, 0x20,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x9C, 0x27, 0x20, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x9C, 0x27, 0x20, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0xA8, 0x38, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA8, 0x38, 0x4F, 0xE9,
 
-0x2A, 0x44, 0x4C, 0xB6,
-0x1A, 0x44, 0x54, 0xB6,
+	0x2A, 0x44, 0x4C, 0xB6,
+	0x1A, 0x44, 0x54, 0xB6,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x36, 0x31, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x36, 0x31, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x37, 0x39, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x37, 0x39, 0x4F, 0xE9,
 
-0x00, 0x80, 0x00, 0xE8,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x00, 0x80, 0x00, 0xE8,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0x2A, 0x46, 0x4E, 0xBF,
-0x1A, 0x46, 0x56, 0xBF,
+	0x2A, 0x46, 0x4E, 0xBF,
+	0x1A, 0x46, 0x56, 0xBF,
 
-0x31, 0x53, 0x2F, 0x9F,
-0xA4, 0x31, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA4, 0x31, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0xA5, 0x39, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA5, 0x39, 0x4F, 0xE9,
 
-0x0A, 0x47, 0x4F, 0xBF,
-0x02, 0x47, 0x57, 0xBF,
+	0x0A, 0x47, 0x4F, 0xBF,
+	0x02, 0x47, 0x57, 0xBF,
 
-0x31, 0x53, 0x2F, 0x9F,
-0xA1, 0x30, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA1, 0x30, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0xA2, 0x38, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA2, 0x38, 0x4F, 0xE9,
 
-0x2A, 0x43, 0x4B, 0xBF,
-0x1A, 0x43, 0x53, 0xBF,
+	0x2A, 0x43, 0x4B, 0xBF,
+	0x1A, 0x43, 0x53, 0xBF,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x9D, 0x31, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x9D, 0x31, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x9E, 0x39, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x9E, 0x39, 0x4F, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x80, 0x31, 0x57, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x80, 0x31, 0x57, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x81, 0x39, 0x57, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x81, 0x39, 0x57, 0xE9,
 
-0x37, 0x48, 0x50, 0xBD,
-0x8A, 0x36, 0x20, 0xE9,
+	0x37, 0x48, 0x50, 0xBD,
+	0x8A, 0x36, 0x20, 0xE9,
 
-0x86, 0x76, 0x57, 0xE9,
-0x8B, 0x3E, 0x20, 0xE9,
+	0x86, 0x76, 0x57, 0xE9,
+	0x8B, 0x3E, 0x20, 0xE9,
 
-0x82, 0x30, 0x57, 0xE9,
-0x87, 0x77, 0x57, 0xE9,
+	0x82, 0x30, 0x57, 0xE9,
+	0x87, 0x77, 0x57, 0xE9,
 
-0x83, 0x38, 0x57, 0xE9,
-0x35, 0x49, 0x51, 0xBD,
+	0x83, 0x38, 0x57, 0xE9,
+	0x35, 0x49, 0x51, 0xBD,
 
-0x84, 0x31, 0x5E, 0xE9,
-0x30, 0x1F, 0x5F, 0xE9,
+	0x84, 0x31, 0x5E, 0xE9,
+	0x30, 0x1F, 0x5F, 0xE9,
 
-0x85, 0x39, 0x5E, 0xE9,
-0x57, 0x25, 0x20, 0xE9,
+	0x85, 0x39, 0x5E, 0xE9,
+	0x57, 0x25, 0x20, 0xE9,
 
-0x2B, 0x48, 0x20, 0xE9,
-0x1D, 0x37, 0xE1, 0xEA,
+	0x2B, 0x48, 0x20, 0xE9,
+	0x1D, 0x37, 0xE1, 0xEA,
 
-0x1E, 0x35, 0xE1, 0xEA,
-0x00, 0xE0,
-0x26, 0x77,
+	0x1E, 0x35, 0xE1, 0xEA,
+	0x00, 0xE0,
+	0x26, 0x77,
 
-0x24, 0x49, 0x20, 0xE9,
-0x9D, 0xFF, 0x20, 0xEA,
+	0x24, 0x49, 0x20, 0xE9,
+	0x9D, 0xFF, 0x20, 0xEA,
 
-0x16, 0x26, 0x20, 0xE9,
-0x57, 0x2E, 0xBF, 0xEA,
+	0x16, 0x26, 0x20, 0xE9,
+	0x57, 0x2E, 0xBF, 0xEA,
 
-0x1C, 0x46, 0xA0, 0xE8,
-0x23, 0x4E, 0xA0, 0xE8,
+	0x1C, 0x46, 0xA0, 0xE8,
+	0x23, 0x4E, 0xA0, 0xE8,
 
-0x2B, 0x56, 0xA0, 0xE8,
-0x1D, 0x47, 0xA0, 0xE8,
+	0x2B, 0x56, 0xA0, 0xE8,
+	0x1D, 0x47, 0xA0, 0xE8,
 
-0x24, 0x4F, 0xA0, 0xE8,
-0x2C, 0x57, 0xA0, 0xE8,
+	0x24, 0x4F, 0xA0, 0xE8,
+	0x2C, 0x57, 0xA0, 0xE8,
 
-0x1C, 0x00,
-0x23, 0x00,
-0x2B, 0x00,
-0x00, 0xE0,
+	0x1C, 0x00,
+	0x23, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
 
-0x1D, 0x00,
-0x24, 0x00,
-0x2C, 0x00,
-0x00, 0xE0,
+	0x1D, 0x00,
+	0x24, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
 
-0x1C, 0x65,
-0x23, 0x65,
-0x2B, 0x65,
-0x00, 0xE0,
+	0x1C, 0x65,
+	0x23, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
 
-0x1D, 0x65,
-0x24, 0x65,
-0x2C, 0x65,
-0x00, 0xE0,
+	0x1D, 0x65,
+	0x24, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
 
-0x1C, 0x23, 0x60, 0xEC,
-0x36, 0xD7, 0x36, 0xAD,
+	0x1C, 0x23, 0x60, 0xEC,
+	0x36, 0xD7, 0x36, 0xAD,
 
-0x2B, 0x80, 0x60, 0xEC,
-0x1D, 0x24, 0x60, 0xEC,
+	0x2B, 0x80, 0x60, 0xEC,
+	0x1D, 0x24, 0x60, 0xEC,
 
-0x3E, 0xD7, 0x3E, 0xAD,
-0x2C, 0x80, 0x60, 0xEC,
+	0x3E, 0xD7, 0x3E, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
 
-0x1C, 0x2B, 0xDE, 0xE8,
-0x23, 0x80, 0xDE, 0xE8,
+	0x1C, 0x2B, 0xDE, 0xE8,
+	0x23, 0x80, 0xDE, 0xE8,
 
-0x36, 0x80, 0x36, 0xBD,
-0x3E, 0x80, 0x3E, 0xBD,
+	0x36, 0x80, 0x36, 0xBD,
+	0x3E, 0x80, 0x3E, 0xBD,
 
-0x33, 0xD7, 0x1C, 0xBD,
-0x3B, 0xD7, 0x23, 0xBD,
+	0x33, 0xD7, 0x1C, 0xBD,
+	0x3B, 0xD7, 0x23, 0xBD,
 
-0x46, 0x80, 0x46, 0xCF,
-0x4F, 0x80, 0x4F, 0xCF,
+	0x46, 0x80, 0x46, 0xCF,
+	0x4F, 0x80, 0x4F, 0xCF,
 
-0x56, 0x33, 0x56, 0xCF,
-0x47, 0x3B, 0x47, 0xCF,
+	0x56, 0x33, 0x56, 0xCF,
+	0x47, 0x3B, 0x47, 0xCF,
 
-0xC5, 0xFF, 0x20, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0xC5, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x4E, 0x33, 0x4E, 0xCF,
-0x57, 0x3B, 0x57, 0xCF,
+	0x4E, 0x33, 0x4E, 0xCF,
+	0x57, 0x3B, 0x57, 0xCF,
 
-0x8B, 0xFF, 0x20, 0xEA,
-0x57, 0xC0, 0xBF, 0xEA,
+	0x8B, 0xFF, 0x20, 0xEA,
+	0x57, 0xC0, 0xBF, 0xEA,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x00, 0x00, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
 
 };
 
 static unsigned char warp_g400_tgzsaf[] = {
 
-0x00, 0x88, 0x98, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x88, 0x98, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x00, 0x00, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
 
-0xFF, 0x80, 0xC0, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x22, 0x40, 0x48, 0xBF,
-0x2A, 0x40, 0x50, 0xBF,
+	0x22, 0x40, 0x48, 0xBF,
+	0x2A, 0x40, 0x50, 0xBF,
 
-0x32, 0x41, 0x49, 0xBF,
-0x3A, 0x41, 0x51, 0xBF,
+	0x32, 0x41, 0x49, 0xBF,
+	0x3A, 0x41, 0x51, 0xBF,
 
-0xC3, 0x6B,
-0xCB, 0x6B,
-0x00, 0x88, 0x98, 0xE9,
+	0xC3, 0x6B,
+	0xCB, 0x6B,
+	0x00, 0x88, 0x98, 0xE9,
 
-0x73, 0x7B, 0xC8, 0xEC,
-0x96, 0xE2,
-0x41, 0x04,
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x96, 0xE2,
+	0x41, 0x04,
 
-0x7B, 0x43, 0xA0, 0xE8,
-0x73, 0x4B, 0xA0, 0xE8,
+	0x7B, 0x43, 0xA0, 0xE8,
+	0x73, 0x4B, 0xA0, 0xE8,
 
-0xAD, 0xEE, 0x29, 0x9F,
-0x00, 0xE0,
-0x49, 0x04,
+	0xAD, 0xEE, 0x29, 0x9F,
+	0x00, 0xE0,
+	0x49, 0x04,
 
-0x90, 0xE2,
-0x51, 0x04,
-0x31, 0x46, 0xB1, 0xE8,
+	0x90, 0xE2,
+	0x51, 0x04,
+	0x31, 0x46, 0xB1, 0xE8,
 
-0x49, 0x41, 0xC0, 0xEC,
-0x39, 0x57, 0xB1, 0xE8,
+	0x49, 0x41, 0xC0, 0xEC,
+	0x39, 0x57, 0xB1, 0xE8,
 
-0x00, 0x04,
-0x46, 0xE2,
-0x73, 0x53, 0xA0, 0xE8,
+	0x00, 0x04,
+	0x46, 0xE2,
+	0x73, 0x53, 0xA0, 0xE8,
 
-0x51, 0x41, 0xC0, 0xEC,
-0x31, 0x00,
-0x39, 0x00,
+	0x51, 0x41, 0xC0, 0xEC,
+	0x31, 0x00,
+	0x39, 0x00,
 
-0x6E, 0x80, 0x15, 0xEA,
-0x08, 0x04,
-0x10, 0x04,
+	0x6E, 0x80, 0x15, 0xEA,
+	0x08, 0x04,
+	0x10, 0x04,
 
-0x51, 0x49, 0xC0, 0xEC,
-0x2F, 0x41, 0x60, 0xEA,
+	0x51, 0x49, 0xC0, 0xEC,
+	0x2F, 0x41, 0x60, 0xEA,
 
-0x31, 0x20,
-0x39, 0x20,
-0x1F, 0x42, 0xA0, 0xE8,
+	0x31, 0x20,
+	0x39, 0x20,
+	0x1F, 0x42, 0xA0, 0xE8,
 
-0x2A, 0x42, 0x4A, 0xBF,
-0x27, 0x4A, 0xA0, 0xE8,
+	0x2A, 0x42, 0x4A, 0xBF,
+	0x27, 0x4A, 0xA0, 0xE8,
 
-0x1A, 0x42, 0x52, 0xBF,
-0x1E, 0x49, 0x60, 0xEA,
+	0x1A, 0x42, 0x52, 0xBF,
+	0x1E, 0x49, 0x60, 0xEA,
 
-0x73, 0x7B, 0xC8, 0xEC,
-0x26, 0x51, 0x60, 0xEA,
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x26, 0x51, 0x60, 0xEA,
 
-0x32, 0x40, 0x48, 0xBD,
-0x22, 0x40, 0x50, 0xBD,
+	0x32, 0x40, 0x48, 0xBD,
+	0x22, 0x40, 0x50, 0xBD,
 
-0x12, 0x41, 0x49, 0xBD,
-0x3A, 0x41, 0x51, 0xBD,
+	0x12, 0x41, 0x49, 0xBD,
+	0x3A, 0x41, 0x51, 0xBD,
 
-0xBF, 0x2F, 0x26, 0xBD,
-0x00, 0xE0,
-0x7B, 0x72,
+	0xBF, 0x2F, 0x26, 0xBD,
+	0x00, 0xE0,
+	0x7B, 0x72,
 
-0x32, 0x20,
-0x22, 0x20,
-0x12, 0x20,
-0x3A, 0x20,
+	0x32, 0x20,
+	0x22, 0x20,
+	0x12, 0x20,
+	0x3A, 0x20,
 
-0x46, 0x31, 0x46, 0xBF,
-0x4E, 0x31, 0x4E, 0xBF,
+	0x46, 0x31, 0x46, 0xBF,
+	0x4E, 0x31, 0x4E, 0xBF,
 
-0xB3, 0xE2, 0x2D, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0xB3, 0xE2, 0x2D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x56, 0x31, 0x56, 0xBF,
-0x47, 0x39, 0x47, 0xBF,
+	0x56, 0x31, 0x56, 0xBF,
+	0x47, 0x39, 0x47, 0xBF,
 
-0x4F, 0x39, 0x4F, 0xBF,
-0x57, 0x39, 0x57, 0xBF,
+	0x4F, 0x39, 0x4F, 0xBF,
+	0x57, 0x39, 0x57, 0xBF,
 
-0x60, 0x80, 0x07, 0xEA,
-0x24, 0x41, 0x20, 0xE9,
+	0x60, 0x80, 0x07, 0xEA,
+	0x24, 0x41, 0x20, 0xE9,
 
-0x42, 0x73, 0xF8, 0xEC,
-0x00, 0xE0,
-0x2D, 0x73,
+	0x42, 0x73, 0xF8, 0xEC,
+	0x00, 0xE0,
+	0x2D, 0x73,
 
-0x33, 0x72,
-0x0C, 0xE3,
-0xA5, 0x2F, 0x1E, 0xBD,
+	0x33, 0x72,
+	0x0C, 0xE3,
+	0xA5, 0x2F, 0x1E, 0xBD,
 
-0x43, 0x43, 0x2D, 0xDF,
-0x4B, 0x4B, 0x2D, 0xDF,
+	0x43, 0x43, 0x2D, 0xDF,
+	0x4B, 0x4B, 0x2D, 0xDF,
 
-0xAE, 0x1E, 0x26, 0xBD,
-0x58, 0xE3,
-0x33, 0x66,
+	0xAE, 0x1E, 0x26, 0xBD,
+	0x58, 0xE3,
+	0x33, 0x66,
 
-0x53, 0x53, 0x2D, 0xDF,
-0x00, 0x80, 0x00, 0xE8,
+	0x53, 0x53, 0x2D, 0xDF,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xB8, 0x38, 0x33, 0xBF,
-0x00, 0xE0,
-0x59, 0xE3,
+	0xB8, 0x38, 0x33, 0xBF,
+	0x00, 0xE0,
+	0x59, 0xE3,
 
-0x1E, 0x12, 0x41, 0xE9,
-0x1A, 0x22, 0x41, 0xE9,
+	0x1E, 0x12, 0x41, 0xE9,
+	0x1A, 0x22, 0x41, 0xE9,
 
-0x2B, 0x40, 0x3D, 0xE9,
-0x3F, 0x4B, 0xA0, 0xE8,
+	0x2B, 0x40, 0x3D, 0xE9,
+	0x3F, 0x4B, 0xA0, 0xE8,
 
-0x2D, 0x73,
-0x30, 0x76,
-0x05, 0x80, 0x3D, 0xEA,
+	0x2D, 0x73,
+	0x30, 0x76,
+	0x05, 0x80, 0x3D, 0xEA,
 
-0x37, 0x43, 0xA0, 0xE8,
-0x3D, 0x53, 0xA0, 0xE8,
+	0x37, 0x43, 0xA0, 0xE8,
+	0x3D, 0x53, 0xA0, 0xE8,
 
-0x48, 0x70, 0xF8, 0xEC,
-0x2B, 0x48, 0x3C, 0xE9,
+	0x48, 0x70, 0xF8, 0xEC,
+	0x2B, 0x48, 0x3C, 0xE9,
 
-0x1F, 0x27, 0xBC, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x1F, 0x27, 0xBC, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x15, 0xC0, 0x20, 0xE9,
-0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
 
-0x15, 0xC0, 0x20, 0xE9,
-0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
 
-0x18, 0x3A, 0x41, 0xE9,
-0x1D, 0x32, 0x41, 0xE9,
+	0x18, 0x3A, 0x41, 0xE9,
+	0x1D, 0x32, 0x41, 0xE9,
 
-0x2A, 0x40, 0x20, 0xE9,
-0x56, 0x3D, 0x56, 0xDF,
+	0x2A, 0x40, 0x20, 0xE9,
+	0x56, 0x3D, 0x56, 0xDF,
 
-0x46, 0x37, 0x46, 0xDF,
-0x4E, 0x3F, 0x4E, 0xDF,
+	0x46, 0x37, 0x46, 0xDF,
+	0x4E, 0x3F, 0x4E, 0xDF,
 
-0x16, 0x30, 0x20, 0xE9,
-0x4F, 0x3F, 0x4F, 0xDF,
+	0x16, 0x30, 0x20, 0xE9,
+	0x4F, 0x3F, 0x4F, 0xDF,
 
-0x47, 0x37, 0x47, 0xDF,
-0x57, 0x3D, 0x57, 0xDF,
+	0x47, 0x37, 0x47, 0xDF,
+	0x57, 0x3D, 0x57, 0xDF,
 
-0x32, 0x32, 0x2D, 0xDF,
-0x22, 0x22, 0x2D, 0xDF,
+	0x32, 0x32, 0x2D, 0xDF,
+	0x22, 0x22, 0x2D, 0xDF,
 
-0x12, 0x12, 0x2D, 0xDF,
-0x3A, 0x3A, 0x2D, 0xDF,
+	0x12, 0x12, 0x2D, 0xDF,
+	0x3A, 0x3A, 0x2D, 0xDF,
 
-0x27, 0xCF, 0x74, 0xC2,
-0x37, 0xCF, 0x74, 0xC4,
+	0x27, 0xCF, 0x74, 0xC2,
+	0x37, 0xCF, 0x74, 0xC4,
 
-0x0A, 0x44, 0x4C, 0xB0,
-0x02, 0x44, 0x54, 0xB0,
+	0x0A, 0x44, 0x4C, 0xB0,
+	0x02, 0x44, 0x54, 0xB0,
 
-0x3D, 0xCF, 0x74, 0xC0,
-0x34, 0x37, 0x20, 0xE9,
+	0x3D, 0xCF, 0x74, 0xC0,
+	0x34, 0x37, 0x20, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x38, 0x27, 0x20, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x38, 0x27, 0x20, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x3C, 0x3D, 0x20, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3C, 0x3D, 0x20, 0xE9,
 
-0x2A, 0x44, 0x4C, 0xB2,
-0x1A, 0x44, 0x54, 0xB2,
+	0x2A, 0x44, 0x4C, 0xB2,
+	0x1A, 0x44, 0x54, 0xB2,
 
-0x32, 0x80, 0x3A, 0xEA,
-0x0A, 0x20,
-0x02, 0x20,
+	0x32, 0x80, 0x3A, 0xEA,
+	0x0A, 0x20,
+	0x02, 0x20,
 
-0x27, 0xCF, 0x75, 0xC0,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x27, 0xCF, 0x75, 0xC0,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x32, 0x31, 0x5F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x32, 0x31, 0x5F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x33, 0x39, 0x5F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x33, 0x39, 0x5F, 0xE9,
 
-0x3D, 0xCF, 0x75, 0xC2,
-0x37, 0xCF, 0x75, 0xC4,
+	0x3D, 0xCF, 0x75, 0xC2,
+	0x37, 0xCF, 0x75, 0xC4,
 
-0x31, 0x53, 0x2F, 0x9F,
-0xA6, 0x27, 0x20, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA6, 0x27, 0x20, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0xA3, 0x3D, 0x20, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA3, 0x3D, 0x20, 0xE9,
 
-0x2A, 0x44, 0x4C, 0xB4,
-0x1A, 0x44, 0x54, 0xB4,
+	0x2A, 0x44, 0x4C, 0xB4,
+	0x1A, 0x44, 0x54, 0xB4,
 
-0x0A, 0x45, 0x4D, 0xB0,
-0x02, 0x45, 0x55, 0xB0,
+	0x0A, 0x45, 0x4D, 0xB0,
+	0x02, 0x45, 0x55, 0xB0,
 
-0x88, 0x73, 0x5E, 0xE9,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x88, 0x73, 0x5E, 0xE9,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0xA0, 0x37, 0x20, 0xE9,
-0x0A, 0x20,
-0x02, 0x20,
+	0xA0, 0x37, 0x20, 0xE9,
+	0x0A, 0x20,
+	0x02, 0x20,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x3E, 0x30, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x3E, 0x30, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x3F, 0x38, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3F, 0x38, 0x4F, 0xE9,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x3A, 0x31, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x3A, 0x31, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x3B, 0x39, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x3B, 0x39, 0x4F, 0xE9,
 
-0x2A, 0x45, 0x4D, 0xB2,
-0x1A, 0x45, 0x55, 0xB2,
+	0x2A, 0x45, 0x4D, 0xB2,
+	0x1A, 0x45, 0x55, 0xB2,
 
-0x0A, 0x45, 0x4D, 0xB4,
-0x02, 0x45, 0x55, 0xB4,
+	0x0A, 0x45, 0x4D, 0xB4,
+	0x02, 0x45, 0x55, 0xB4,
 
-0x27, 0xCF, 0x74, 0xC6,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x27, 0xCF, 0x74, 0xC6,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0xA7, 0x30, 0x4F, 0xE9,
-0x0A, 0x20,
-0x02, 0x20,
+	0xA7, 0x30, 0x4F, 0xE9,
+	0x0A, 0x20,
+	0x02, 0x20,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x9C, 0x27, 0x20, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x9C, 0x27, 0x20, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0xA8, 0x38, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA8, 0x38, 0x4F, 0xE9,
 
-0x2A, 0x44, 0x4C, 0xB6,
-0x1A, 0x44, 0x54, 0xB6,
+	0x2A, 0x44, 0x4C, 0xB6,
+	0x1A, 0x44, 0x54, 0xB6,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x36, 0x31, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x36, 0x31, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x37, 0x39, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x37, 0x39, 0x4F, 0xE9,
 
-0x0A, 0x45, 0x4D, 0xB6,
-0x02, 0x45, 0x55, 0xB6,
+	0x0A, 0x45, 0x4D, 0xB6,
+	0x02, 0x45, 0x55, 0xB6,
 
-0x3D, 0xCF, 0x75, 0xC6,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x3D, 0xCF, 0x75, 0xC6,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0x2A, 0x46, 0x4E, 0xBF,
-0x1A, 0x46, 0x56, 0xBF,
+	0x2A, 0x46, 0x4E, 0xBF,
+	0x1A, 0x46, 0x56, 0xBF,
 
-0x31, 0x53, 0x2F, 0x9F,
-0xA4, 0x31, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA4, 0x31, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0xA5, 0x39, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA5, 0x39, 0x4F, 0xE9,
 
-0x31, 0x3D, 0x20, 0xE9,
-0x0A, 0x20,
-0x02, 0x20,
+	0x31, 0x3D, 0x20, 0xE9,
+	0x0A, 0x20,
+	0x02, 0x20,
 
-0x0A, 0x47, 0x4F, 0xBF,
-0x02, 0x47, 0x57, 0xBF,
+	0x0A, 0x47, 0x4F, 0xBF,
+	0x02, 0x47, 0x57, 0xBF,
 
-0x30, 0x50, 0x2E, 0x9F,
-0xA1, 0x30, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0xA1, 0x30, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0xA2, 0x38, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0xA2, 0x38, 0x4F, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x9D, 0x31, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x9D, 0x31, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x9E, 0x39, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x9E, 0x39, 0x4F, 0xE9,
 
-0x2A, 0x43, 0x4B, 0xBF,
-0x1A, 0x43, 0x53, 0xBF,
+	0x2A, 0x43, 0x4B, 0xBF,
+	0x1A, 0x43, 0x53, 0xBF,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x35, 0x30, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x35, 0x30, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x39, 0x38, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x39, 0x38, 0x4F, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x80, 0x31, 0x57, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x80, 0x31, 0x57, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x81, 0x39, 0x57, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x81, 0x39, 0x57, 0xE9,
 
-0x37, 0x48, 0x50, 0xBD,
-0x8A, 0x36, 0x20, 0xE9,
+	0x37, 0x48, 0x50, 0xBD,
+	0x8A, 0x36, 0x20, 0xE9,
 
-0x86, 0x76, 0x57, 0xE9,
-0x8B, 0x3E, 0x20, 0xE9,
+	0x86, 0x76, 0x57, 0xE9,
+	0x8B, 0x3E, 0x20, 0xE9,
 
-0x82, 0x30, 0x57, 0xE9,
-0x87, 0x77, 0x57, 0xE9,
+	0x82, 0x30, 0x57, 0xE9,
+	0x87, 0x77, 0x57, 0xE9,
 
-0x83, 0x38, 0x57, 0xE9,
-0x35, 0x49, 0x51, 0xBD,
+	0x83, 0x38, 0x57, 0xE9,
+	0x35, 0x49, 0x51, 0xBD,
 
-0x84, 0x31, 0x5E, 0xE9,
-0x30, 0x1F, 0x5F, 0xE9,
+	0x84, 0x31, 0x5E, 0xE9,
+	0x30, 0x1F, 0x5F, 0xE9,
 
-0x85, 0x39, 0x5E, 0xE9,
-0x57, 0x25, 0x20, 0xE9,
+	0x85, 0x39, 0x5E, 0xE9,
+	0x57, 0x25, 0x20, 0xE9,
 
-0x2B, 0x48, 0x20, 0xE9,
-0x1D, 0x37, 0xE1, 0xEA,
+	0x2B, 0x48, 0x20, 0xE9,
+	0x1D, 0x37, 0xE1, 0xEA,
 
-0x1E, 0x35, 0xE1, 0xEA,
-0x00, 0xE0,
-0x26, 0x77,
+	0x1E, 0x35, 0xE1, 0xEA,
+	0x00, 0xE0,
+	0x26, 0x77,
 
-0x24, 0x49, 0x20, 0xE9,
-0x99, 0xFF, 0x20, 0xEA,
+	0x24, 0x49, 0x20, 0xE9,
+	0x99, 0xFF, 0x20, 0xEA,
 
-0x16, 0x26, 0x20, 0xE9,
-0x57, 0x2E, 0xBF, 0xEA,
+	0x16, 0x26, 0x20, 0xE9,
+	0x57, 0x2E, 0xBF, 0xEA,
 
-0x1C, 0x46, 0xA0, 0xE8,
-0x23, 0x4E, 0xA0, 0xE8,
+	0x1C, 0x46, 0xA0, 0xE8,
+	0x23, 0x4E, 0xA0, 0xE8,
 
-0x2B, 0x56, 0xA0, 0xE8,
-0x1D, 0x47, 0xA0, 0xE8,
+	0x2B, 0x56, 0xA0, 0xE8,
+	0x1D, 0x47, 0xA0, 0xE8,
 
-0x24, 0x4F, 0xA0, 0xE8,
-0x2C, 0x57, 0xA0, 0xE8,
+	0x24, 0x4F, 0xA0, 0xE8,
+	0x2C, 0x57, 0xA0, 0xE8,
 
-0x1C, 0x00,
-0x23, 0x00,
-0x2B, 0x00,
-0x00, 0xE0,
+	0x1C, 0x00,
+	0x23, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
 
-0x1D, 0x00,
-0x24, 0x00,
-0x2C, 0x00,
-0x00, 0xE0,
+	0x1D, 0x00,
+	0x24, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
 
-0x1C, 0x65,
-0x23, 0x65,
-0x2B, 0x65,
-0x00, 0xE0,
+	0x1C, 0x65,
+	0x23, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
 
-0x1D, 0x65,
-0x24, 0x65,
-0x2C, 0x65,
-0x00, 0xE0,
+	0x1D, 0x65,
+	0x24, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
 
-0x1C, 0x23, 0x60, 0xEC,
-0x36, 0xD7, 0x36, 0xAD,
+	0x1C, 0x23, 0x60, 0xEC,
+	0x36, 0xD7, 0x36, 0xAD,
 
-0x2B, 0x80, 0x60, 0xEC,
-0x1D, 0x24, 0x60, 0xEC,
+	0x2B, 0x80, 0x60, 0xEC,
+	0x1D, 0x24, 0x60, 0xEC,
 
-0x3E, 0xD7, 0x3E, 0xAD,
-0x2C, 0x80, 0x60, 0xEC,
+	0x3E, 0xD7, 0x3E, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
 
-0x1C, 0x2B, 0xDE, 0xE8,
-0x23, 0x80, 0xDE, 0xE8,
+	0x1C, 0x2B, 0xDE, 0xE8,
+	0x23, 0x80, 0xDE, 0xE8,
 
-0x36, 0x80, 0x36, 0xBD,
-0x3E, 0x80, 0x3E, 0xBD,
+	0x36, 0x80, 0x36, 0xBD,
+	0x3E, 0x80, 0x3E, 0xBD,
 
-0x33, 0xD7, 0x1C, 0xBD,
-0x3B, 0xD7, 0x23, 0xBD,
+	0x33, 0xD7, 0x1C, 0xBD,
+	0x3B, 0xD7, 0x23, 0xBD,
 
-0x46, 0x80, 0x46, 0xCF,
-0x4F, 0x80, 0x4F, 0xCF,
+	0x46, 0x80, 0x46, 0xCF,
+	0x4F, 0x80, 0x4F, 0xCF,
 
-0x56, 0x33, 0x56, 0xCF,
-0x47, 0x3B, 0x47, 0xCF,
+	0x56, 0x33, 0x56, 0xCF,
+	0x47, 0x3B, 0x47, 0xCF,
 
-0xC1, 0xFF, 0x20, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0xC1, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x4E, 0x33, 0x4E, 0xCF,
-0x57, 0x3B, 0x57, 0xCF,
+	0x4E, 0x33, 0x4E, 0xCF,
+	0x57, 0x3B, 0x57, 0xCF,
 
-0x87, 0xFF, 0x20, 0xEA,
-0x57, 0xC0, 0xBF, 0xEA,
+	0x87, 0xFF, 0x20, 0xEA,
+	0x57, 0xC0, 0xBF, 0xEA,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x00, 0x00, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
 
 };
 
 static unsigned char warp_g400_tgzsf[] = {
 
-0x00, 0x88, 0x98, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x88, 0x98, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x00, 0x00, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
 
-0xFF, 0x80, 0xC0, 0xE9,
-0x00, 0x80, 0x00, 0xE8,
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x22, 0x40, 0x48, 0xBF,
-0x2A, 0x40, 0x50, 0xBF,
+	0x22, 0x40, 0x48, 0xBF,
+	0x2A, 0x40, 0x50, 0xBF,
 
-0x32, 0x41, 0x49, 0xBF,
-0x3A, 0x41, 0x51, 0xBF,
+	0x32, 0x41, 0x49, 0xBF,
+	0x3A, 0x41, 0x51, 0xBF,
 
-0xC3, 0x6B,
-0xCB, 0x6B,
-0x00, 0x88, 0x98, 0xE9,
+	0xC3, 0x6B,
+	0xCB, 0x6B,
+	0x00, 0x88, 0x98, 0xE9,
 
-0x73, 0x7B, 0xC8, 0xEC,
-0x96, 0xE2,
-0x41, 0x04,
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x96, 0xE2,
+	0x41, 0x04,
 
-0x7B, 0x43, 0xA0, 0xE8,
-0x73, 0x4B, 0xA0, 0xE8,
+	0x7B, 0x43, 0xA0, 0xE8,
+	0x73, 0x4B, 0xA0, 0xE8,
 
-0xAD, 0xEE, 0x29, 0x9F,
-0x00, 0xE0,
-0x49, 0x04,
+	0xAD, 0xEE, 0x29, 0x9F,
+	0x00, 0xE0,
+	0x49, 0x04,
 
-0x90, 0xE2,
-0x51, 0x04,
-0x31, 0x46, 0xB1, 0xE8,
+	0x90, 0xE2,
+	0x51, 0x04,
+	0x31, 0x46, 0xB1, 0xE8,
 
-0x49, 0x41, 0xC0, 0xEC,
-0x39, 0x57, 0xB1, 0xE8,
+	0x49, 0x41, 0xC0, 0xEC,
+	0x39, 0x57, 0xB1, 0xE8,
 
-0x00, 0x04,
-0x46, 0xE2,
-0x73, 0x53, 0xA0, 0xE8,
+	0x00, 0x04,
+	0x46, 0xE2,
+	0x73, 0x53, 0xA0, 0xE8,
 
-0x51, 0x41, 0xC0, 0xEC,
-0x31, 0x00,
-0x39, 0x00,
+	0x51, 0x41, 0xC0, 0xEC,
+	0x31, 0x00,
+	0x39, 0x00,
 
-0x6A, 0x80, 0x15, 0xEA,
-0x08, 0x04,
-0x10, 0x04,
+	0x6A, 0x80, 0x15, 0xEA,
+	0x08, 0x04,
+	0x10, 0x04,
 
-0x51, 0x49, 0xC0, 0xEC,
-0x2F, 0x41, 0x60, 0xEA,
+	0x51, 0x49, 0xC0, 0xEC,
+	0x2F, 0x41, 0x60, 0xEA,
 
-0x31, 0x20,
-0x39, 0x20,
-0x1F, 0x42, 0xA0, 0xE8,
+	0x31, 0x20,
+	0x39, 0x20,
+	0x1F, 0x42, 0xA0, 0xE8,
 
-0x2A, 0x42, 0x4A, 0xBF,
-0x27, 0x4A, 0xA0, 0xE8,
+	0x2A, 0x42, 0x4A, 0xBF,
+	0x27, 0x4A, 0xA0, 0xE8,
 
-0x1A, 0x42, 0x52, 0xBF,
-0x1E, 0x49, 0x60, 0xEA,
+	0x1A, 0x42, 0x52, 0xBF,
+	0x1E, 0x49, 0x60, 0xEA,
 
-0x73, 0x7B, 0xC8, 0xEC,
-0x26, 0x51, 0x60, 0xEA,
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x26, 0x51, 0x60, 0xEA,
 
-0x32, 0x40, 0x48, 0xBD,
-0x22, 0x40, 0x50, 0xBD,
+	0x32, 0x40, 0x48, 0xBD,
+	0x22, 0x40, 0x50, 0xBD,
 
-0x12, 0x41, 0x49, 0xBD,
-0x3A, 0x41, 0x51, 0xBD,
+	0x12, 0x41, 0x49, 0xBD,
+	0x3A, 0x41, 0x51, 0xBD,
 
-0xBF, 0x2F, 0x26, 0xBD,
-0x00, 0xE0,
-0x7B, 0x72,
+	0xBF, 0x2F, 0x26, 0xBD,
+	0x00, 0xE0,
+	0x7B, 0x72,
 
-0x32, 0x20,
-0x22, 0x20,
-0x12, 0x20,
-0x3A, 0x20,
+	0x32, 0x20,
+	0x22, 0x20,
+	0x12, 0x20,
+	0x3A, 0x20,
 
-0x46, 0x31, 0x46, 0xBF,
-0x4E, 0x31, 0x4E, 0xBF,
+	0x46, 0x31, 0x46, 0xBF,
+	0x4E, 0x31, 0x4E, 0xBF,
 
-0xB3, 0xE2, 0x2D, 0x9F,
-0x00, 0x80, 0x00, 0xE8,
+	0xB3, 0xE2, 0x2D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x56, 0x31, 0x56, 0xBF,
-0x47, 0x39, 0x47, 0xBF,
+	0x56, 0x31, 0x56, 0xBF,
+	0x47, 0x39, 0x47, 0xBF,
 
-0x4F, 0x39, 0x4F, 0xBF,
-0x57, 0x39, 0x57, 0xBF,
+	0x4F, 0x39, 0x4F, 0xBF,
+	0x57, 0x39, 0x57, 0xBF,
 
-0x5C, 0x80, 0x07, 0xEA,
-0x24, 0x41, 0x20, 0xE9,
+	0x5C, 0x80, 0x07, 0xEA,
+	0x24, 0x41, 0x20, 0xE9,
 
-0x42, 0x73, 0xF8, 0xEC,
-0x00, 0xE0,
-0x2D, 0x73,
+	0x42, 0x73, 0xF8, 0xEC,
+	0x00, 0xE0,
+	0x2D, 0x73,
 
-0x33, 0x72,
-0x0C, 0xE3,
-0xA5, 0x2F, 0x1E, 0xBD,
+	0x33, 0x72,
+	0x0C, 0xE3,
+	0xA5, 0x2F, 0x1E, 0xBD,
 
-0x43, 0x43, 0x2D, 0xDF,
-0x4B, 0x4B, 0x2D, 0xDF,
+	0x43, 0x43, 0x2D, 0xDF,
+	0x4B, 0x4B, 0x2D, 0xDF,
 
-0xAE, 0x1E, 0x26, 0xBD,
-0x58, 0xE3,
-0x33, 0x66,
+	0xAE, 0x1E, 0x26, 0xBD,
+	0x58, 0xE3,
+	0x33, 0x66,
 
-0x53, 0x53, 0x2D, 0xDF,
-0x00, 0x80, 0x00, 0xE8,
+	0x53, 0x53, 0x2D, 0xDF,
+	0x00, 0x80, 0x00, 0xE8,
 
-0xB8, 0x38, 0x33, 0xBF,
-0x00, 0xE0,
-0x59, 0xE3,
+	0xB8, 0x38, 0x33, 0xBF,
+	0x00, 0xE0,
+	0x59, 0xE3,
 
-0x1E, 0x12, 0x41, 0xE9,
-0x1A, 0x22, 0x41, 0xE9,
+	0x1E, 0x12, 0x41, 0xE9,
+	0x1A, 0x22, 0x41, 0xE9,
 
-0x2B, 0x40, 0x3D, 0xE9,
-0x3F, 0x4B, 0xA0, 0xE8,
+	0x2B, 0x40, 0x3D, 0xE9,
+	0x3F, 0x4B, 0xA0, 0xE8,
 
-0x2D, 0x73,
-0x30, 0x76,
-0x05, 0x80, 0x3D, 0xEA,
+	0x2D, 0x73,
+	0x30, 0x76,
+	0x05, 0x80, 0x3D, 0xEA,
 
-0x37, 0x43, 0xA0, 0xE8,
-0x3D, 0x53, 0xA0, 0xE8,
+	0x37, 0x43, 0xA0, 0xE8,
+	0x3D, 0x53, 0xA0, 0xE8,
 
-0x48, 0x70, 0xF8, 0xEC,
-0x2B, 0x48, 0x3C, 0xE9,
+	0x48, 0x70, 0xF8, 0xEC,
+	0x2B, 0x48, 0x3C, 0xE9,
 
-0x1F, 0x27, 0xBC, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x1F, 0x27, 0xBC, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x00, 0x80, 0x00, 0xE8,
-0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x15, 0xC0, 0x20, 0xE9,
-0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
 
-0x15, 0xC0, 0x20, 0xE9,
-0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
 
-0x18, 0x3A, 0x41, 0xE9,
-0x1D, 0x32, 0x41, 0xE9,
+	0x18, 0x3A, 0x41, 0xE9,
+	0x1D, 0x32, 0x41, 0xE9,
 
-0x2A, 0x40, 0x20, 0xE9,
-0x56, 0x3D, 0x56, 0xDF,
+	0x2A, 0x40, 0x20, 0xE9,
+	0x56, 0x3D, 0x56, 0xDF,
 
-0x46, 0x37, 0x46, 0xDF,
-0x4E, 0x3F, 0x4E, 0xDF,
+	0x46, 0x37, 0x46, 0xDF,
+	0x4E, 0x3F, 0x4E, 0xDF,
 
-0x16, 0x30, 0x20, 0xE9,
-0x4F, 0x3F, 0x4F, 0xDF,
+	0x16, 0x30, 0x20, 0xE9,
+	0x4F, 0x3F, 0x4F, 0xDF,
 
-0x47, 0x37, 0x47, 0xDF,
-0x57, 0x3D, 0x57, 0xDF,
+	0x47, 0x37, 0x47, 0xDF,
+	0x57, 0x3D, 0x57, 0xDF,
 
-0x32, 0x32, 0x2D, 0xDF,
-0x22, 0x22, 0x2D, 0xDF,
+	0x32, 0x32, 0x2D, 0xDF,
+	0x22, 0x22, 0x2D, 0xDF,
 
-0x12, 0x12, 0x2D, 0xDF,
-0x3A, 0x3A, 0x2D, 0xDF,
+	0x12, 0x12, 0x2D, 0xDF,
+	0x3A, 0x3A, 0x2D, 0xDF,
 
-0x27, 0xCF, 0x74, 0xC2,
-0x37, 0xCF, 0x74, 0xC4,
+	0x27, 0xCF, 0x74, 0xC2,
+	0x37, 0xCF, 0x74, 0xC4,
 
-0x0A, 0x44, 0x4C, 0xB0,
-0x02, 0x44, 0x54, 0xB0,
+	0x0A, 0x44, 0x4C, 0xB0,
+	0x02, 0x44, 0x54, 0xB0,
 
-0x3D, 0xCF, 0x74, 0xC0,
-0x34, 0x37, 0x20, 0xE9,
+	0x3D, 0xCF, 0x74, 0xC0,
+	0x34, 0x37, 0x20, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x38, 0x27, 0x20, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x38, 0x27, 0x20, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x3C, 0x3D, 0x20, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3C, 0x3D, 0x20, 0xE9,
 
-0x2A, 0x44, 0x4C, 0xB2,
-0x1A, 0x44, 0x54, 0xB2,
+	0x2A, 0x44, 0x4C, 0xB2,
+	0x1A, 0x44, 0x54, 0xB2,
 
-0x2E, 0x80, 0x3A, 0xEA,
-0x0A, 0x20,
-0x02, 0x20,
+	0x2E, 0x80, 0x3A, 0xEA,
+	0x0A, 0x20,
+	0x02, 0x20,
 
-0x27, 0xCF, 0x75, 0xC0,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x27, 0xCF, 0x75, 0xC0,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x32, 0x31, 0x5F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x32, 0x31, 0x5F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x33, 0x39, 0x5F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x33, 0x39, 0x5F, 0xE9,
 
-0x3D, 0xCF, 0x75, 0xC2,
-0x37, 0xCF, 0x75, 0xC4,
+	0x3D, 0xCF, 0x75, 0xC2,
+	0x37, 0xCF, 0x75, 0xC4,
 
-0x31, 0x53, 0x2F, 0x9F,
-0xA6, 0x27, 0x20, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA6, 0x27, 0x20, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0xA3, 0x3D, 0x20, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA3, 0x3D, 0x20, 0xE9,
 
-0x2A, 0x44, 0x4C, 0xB4,
-0x1A, 0x44, 0x54, 0xB4,
+	0x2A, 0x44, 0x4C, 0xB4,
+	0x1A, 0x44, 0x54, 0xB4,
 
-0x0A, 0x45, 0x4D, 0xB0,
-0x02, 0x45, 0x55, 0xB0,
+	0x0A, 0x45, 0x4D, 0xB0,
+	0x02, 0x45, 0x55, 0xB0,
 
-0x88, 0x73, 0x5E, 0xE9,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x88, 0x73, 0x5E, 0xE9,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0xA0, 0x37, 0x20, 0xE9,
-0x0A, 0x20,
-0x02, 0x20,
+	0xA0, 0x37, 0x20, 0xE9,
+	0x0A, 0x20,
+	0x02, 0x20,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x3E, 0x30, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x3E, 0x30, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x3F, 0x38, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3F, 0x38, 0x4F, 0xE9,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x3A, 0x31, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x3A, 0x31, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x3B, 0x39, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x3B, 0x39, 0x4F, 0xE9,
 
-0x2A, 0x45, 0x4D, 0xB2,
-0x1A, 0x45, 0x55, 0xB2,
+	0x2A, 0x45, 0x4D, 0xB2,
+	0x1A, 0x45, 0x55, 0xB2,
 
-0x0A, 0x45, 0x4D, 0xB4,
-0x02, 0x45, 0x55, 0xB4,
+	0x0A, 0x45, 0x4D, 0xB4,
+	0x02, 0x45, 0x55, 0xB4,
 
-0x27, 0xCF, 0x75, 0xC6,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x27, 0xCF, 0x75, 0xC6,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0xA7, 0x30, 0x4F, 0xE9,
-0x0A, 0x20,
-0x02, 0x20,
+	0xA7, 0x30, 0x4F, 0xE9,
+	0x0A, 0x20,
+	0x02, 0x20,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x31, 0x27, 0x20, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x31, 0x27, 0x20, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0xA8, 0x38, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA8, 0x38, 0x4F, 0xE9,
 
-0x2A, 0x45, 0x4D, 0xB6,
-0x1A, 0x45, 0x55, 0xB6,
+	0x2A, 0x45, 0x4D, 0xB6,
+	0x1A, 0x45, 0x55, 0xB6,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x36, 0x31, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x36, 0x31, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x37, 0x39, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x37, 0x39, 0x4F, 0xE9,
 
-0x00, 0x80, 0x00, 0xE8,
-0x2A, 0x20,
-0x1A, 0x20,
+	0x00, 0x80, 0x00, 0xE8,
+	0x2A, 0x20,
+	0x1A, 0x20,
 
-0x2A, 0x46, 0x4E, 0xBF,
-0x1A, 0x46, 0x56, 0xBF,
+	0x2A, 0x46, 0x4E, 0xBF,
+	0x1A, 0x46, 0x56, 0xBF,
 
-0x31, 0x53, 0x2F, 0x9F,
-0xA4, 0x31, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA4, 0x31, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0xA5, 0x39, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA5, 0x39, 0x4F, 0xE9,
 
-0x0A, 0x47, 0x4F, 0xBF,
-0x02, 0x47, 0x57, 0xBF,
+	0x0A, 0x47, 0x4F, 0xBF,
+	0x02, 0x47, 0x57, 0xBF,
 
-0x31, 0x53, 0x2F, 0x9F,
-0xA1, 0x30, 0x4F, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA1, 0x30, 0x4F, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0xA2, 0x38, 0x4F, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA2, 0x38, 0x4F, 0xE9,
 
-0x2A, 0x43, 0x4B, 0xBF,
-0x1A, 0x43, 0x53, 0xBF,
+	0x2A, 0x43, 0x4B, 0xBF,
+	0x1A, 0x43, 0x53, 0xBF,
 
-0x30, 0x50, 0x2E, 0x9F,
-0x35, 0x31, 0x4F, 0xE9,
+	0x30, 0x50, 0x2E, 0x9F,
+	0x35, 0x31, 0x4F, 0xE9,
 
-0x38, 0x21, 0x2C, 0x9F,
-0x39, 0x39, 0x4F, 0xE9,
+	0x38, 0x21, 0x2C, 0x9F,
+	0x39, 0x39, 0x4F, 0xE9,
 
-0x31, 0x53, 0x2F, 0x9F,
-0x80, 0x31, 0x57, 0xE9,
+	0x31, 0x53, 0x2F, 0x9F,
+	0x80, 0x31, 0x57, 0xE9,
 
-0x39, 0xE5, 0x2C, 0x9F,
-0x81, 0x39, 0x57, 0xE9,
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x81, 0x39, 0x57, 0xE9,
 
-0x37, 0x48, 0x50, 0xBD,
-0x8A, 0x36, 0x20, 0xE9,
+	0x37, 0x48, 0x50, 0xBD,
+	0x8A, 0x36, 0x20, 0xE9,
 
-0x86, 0x76, 0x57, 0xE9,
-0x8B, 0x3E, 0x20, 0xE9,
+	0x86, 0x76, 0x57, 0xE9,
+	0x8B, 0x3E, 0x20, 0xE9,
 
-0x82, 0x30, 0x57, 0xE9,
-0x87, 0x77, 0x57, 0xE9,
+	0x82, 0x30, 0x57, 0xE9,
+	0x87, 0x77, 0x57, 0xE9,
 
-0x83, 0x38, 0x57, 0xE9,
-0x35, 0x49, 0x51, 0xBD,
+	0x83, 0x38, 0x57, 0xE9,
+	0x35, 0x49, 0x51, 0xBD,
 
-0x84, 0x31, 0x5E, 0xE9,
-0x30, 0x1F, 0x5F, 0xE9,
+	0x84, 0x31, 0x5E, 0xE9,
+	0x30, 0x1F, 0x5F, 0xE9,
 
-0x85, 0x39, 0x5E, 0xE9,
-0x57, 0x25, 0x20, 0xE9,
+	0x85, 0x39, 0x5E, 0xE9,
+	0x57, 0x25, 0x20, 0xE9,
 
-0x2B, 0x48, 0x20, 0xE9,
-0x1D, 0x37, 0xE1, 0xEA,
+	0x2B, 0x48, 0x20, 0xE9,
+	0x1D, 0x37, 0xE1, 0xEA,
 
-0x1E, 0x35, 0xE1, 0xEA,
-0x00, 0xE0,
-0x26, 0x77,
+	0x1E, 0x35, 0xE1, 0xEA,
+	0x00, 0xE0,
+	0x26, 0x77,
 
-0x24, 0x49, 0x20, 0xE9,
-0x9D, 0xFF, 0x20, 0xEA,
+	0x24, 0x49, 0x20, 0xE9,
+	0x9D, 0xFF, 0x20, 0xEA,
 
-0x16, 0x26, 0x20, 0xE9,
-0x57, 0x2E, 0xBF, 0xEA,
+	0x16, 0x26, 0x20, 0xE9,
+	0x57, 0x2E, 0xBF, 0xEA,
 
-0x1C, 0x46, 0xA0, 0xE8,
-0x23, 0x4E, 0xA0, 0xE8,
+	0x1C, 0x46, 0xA0, 0xE8,
+	0x23, 0x4E, 0xA0, 0xE8,
 
-0x2B, 0x56, 0xA0, 0xE8,
-0x1D, 0x47, 0xA0, 0xE8,
+	0x2B, 0x56, 0xA0, 0xE8,
+	0x1D, 0x47, 0xA0, 0xE8,
 
-0x24, 0x4F, 0xA0, 0xE8,
-0x2C, 0x57, 0xA0, 0xE8,
+	0x24, 0x4F, 0xA0, 0xE8,
+	0x2C, 0x57, 0xA0, 0xE8,
 
-0x1C, 0x00,
-0x23, 0x00,
-0x2B, 0x00,
-0x00, 0xE0,
+	0x1C, 0x00,
+	0x23, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
 
-0x1D, 0x00,
-0x24, 0x00,
-0x2C, 0x00,
-0x00, 0xE0,
+	0x1D, 0x00,
+	0x24, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
 
-0x1C, 0x65,
-0x23, 0x65,
-0x2B, 0x65,
-0x00, 0xE0,
+	0x1C, 0x65,
+	0x23, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
 
-0x1D, 0x65,
-0x24, 0x65,
-0x2C, 0x65,
-0x00, 0xE0,
+	0x1D, 0x65,
+	0x24, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
 
-0x1C, 0x23, 0x60, 0xEC,
-0x36, 0xD7, 0x36, 0xAD,
+	0x1C, 0x23, 0x60, 0xEC,
+	0x36, 0xD7, 0x36, 0xAD,
 
-0x2B, 0x80, 0x60, 0xEC,
-0x1D, 0x24, 0x60, 0xEC,
+	0x2B, 0x80, 0x60, 0xEC,
+	0x1D, 0x24, 0x60, 0xEC,
 
-0x3E, 0xD7, 0x3E, 0xAD,
-0x2C, 0x80, 0x60, 0xEC,
+	0x3E, 0xD7, 0x3E, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
 
-0x1C, 0x2B, 0xDE, 0xE8,
-0x23, 0x80, 0xDE, 0xE8,
+	0x1C, 0x2B, 0xDE, 0xE8,
+	0x23, 0x80, 0xDE, 0xE8,
 
-0x36, 0x80, 0x36, 0xBD,
-0x3E, 0x80, 0x3E, 0xBD,
+	0x36, 0x80, 0x36, 0xBD,
+	0x3E, 0x80, 0x3E, 0xBD,
 
-0x33, 0xD7, 0x1C, 0xBD,
-0x3B, 0xD7, 0x23, 0xBD,
+	0x33, 0xD7, 0x1C, 0xBD,
+	0x3B, 0xD7, 0x23, 0xBD,
 
-0x46, 0x80, 0x46, 0xCF,
-0x4F, 0x80, 0x4F, 0xCF,
+	0x46, 0x80, 0x46, 0xCF,
+	0x4F, 0x80, 0x4F, 0xCF,
 
-0x56, 0x33, 0x56, 0xCF,
-0x47, 0x3B, 0x47, 0xCF,
+	0x56, 0x33, 0x56, 0xCF,
+	0x47, 0x3B, 0x47, 0xCF,
 
-0xC5, 0xFF, 0x20, 0xEA,
-0x00, 0x80, 0x00, 0xE8,
+	0xC5, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
 
-0x4E, 0x33, 0x4E, 0xCF,
-0x57, 0x3B, 0x57, 0xCF,
+	0x4E, 0x33, 0x4E, 0xCF,
+	0x57, 0x3B, 0x57, 0xCF,
 
-0x8B, 0xFF, 0x20, 0xEA,
-0x57, 0xC0, 0xBF, 0xEA,
+	0x8B, 0xFF, 0x20, 0xEA,
+	0x57, 0xC0, 0xBF, 0xEA,
 
-0x00, 0x80, 0xA0, 0xE9,
-0x00, 0x00, 0xD8, 0xEC,
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
 
 };
diff -purN linux-2.6.12.orig/drivers/char/drm/mga_warp.c linux-2.6.12/drivers/char/drm/mga_warp.c
--- linux-2.6.12.orig/drivers/char/drm/mga_warp.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/mga_warp.c	2005-07-05 08:37:47.000000000 +0200
@@ -33,8 +33,7 @@
 #include "mga_drv.h"
 #include "mga_ucode.h"
 
-
-#define MGA_WARP_CODE_ALIGN		256		/* in bytes */
+#define MGA_WARP_CODE_ALIGN		256	/* in bytes */
 
 #define WARP_UCODE_SIZE( which )					\
 	((sizeof(which) / MGA_WARP_CODE_ALIGN + 1) * MGA_WARP_CODE_ALIGN)
@@ -48,125 +47,112 @@ do {									\
 	vcbase += WARP_UCODE_SIZE( which );				\
 } while (0)
 
+static const unsigned int mga_warp_g400_microcode_size =
+	       (WARP_UCODE_SIZE(warp_g400_tgz) +
+		WARP_UCODE_SIZE(warp_g400_tgza) +
+		WARP_UCODE_SIZE(warp_g400_tgzaf) +
+		WARP_UCODE_SIZE(warp_g400_tgzf) +
+		WARP_UCODE_SIZE(warp_g400_tgzs) +
+		WARP_UCODE_SIZE(warp_g400_tgzsa) +
+		WARP_UCODE_SIZE(warp_g400_tgzsaf) +
+		WARP_UCODE_SIZE(warp_g400_tgzsf) +
+		WARP_UCODE_SIZE(warp_g400_t2gz) +
+		WARP_UCODE_SIZE(warp_g400_t2gza) +
+		WARP_UCODE_SIZE(warp_g400_t2gzaf) +
+		WARP_UCODE_SIZE(warp_g400_t2gzf) +
+		WARP_UCODE_SIZE(warp_g400_t2gzs) +
+		WARP_UCODE_SIZE(warp_g400_t2gzsa) +
+		WARP_UCODE_SIZE(warp_g400_t2gzsaf) +
+		WARP_UCODE_SIZE(warp_g400_t2gzsf));
+
+static const unsigned int mga_warp_g200_microcode_size =
+	       (WARP_UCODE_SIZE(warp_g200_tgz) +
+		WARP_UCODE_SIZE(warp_g200_tgza) +
+		WARP_UCODE_SIZE(warp_g200_tgzaf) +
+		WARP_UCODE_SIZE(warp_g200_tgzf) +
+		WARP_UCODE_SIZE(warp_g200_tgzs) +
+		WARP_UCODE_SIZE(warp_g200_tgzsa) +
+		WARP_UCODE_SIZE(warp_g200_tgzsaf) +
+		WARP_UCODE_SIZE(warp_g200_tgzsf));
 
-static unsigned int mga_warp_g400_microcode_size( drm_mga_private_t *dev_priv )
-{
-	unsigned int size;
-
-	size = ( WARP_UCODE_SIZE( warp_g400_tgz ) +
-		 WARP_UCODE_SIZE( warp_g400_tgza ) +
-		 WARP_UCODE_SIZE( warp_g400_tgzaf ) +
-		 WARP_UCODE_SIZE( warp_g400_tgzf ) +
-		 WARP_UCODE_SIZE( warp_g400_tgzs ) +
-		 WARP_UCODE_SIZE( warp_g400_tgzsa ) +
-		 WARP_UCODE_SIZE( warp_g400_tgzsaf ) +
-		 WARP_UCODE_SIZE( warp_g400_tgzsf ) +
-		 WARP_UCODE_SIZE( warp_g400_t2gz ) +
-		 WARP_UCODE_SIZE( warp_g400_t2gza ) +
-		 WARP_UCODE_SIZE( warp_g400_t2gzaf ) +
-		 WARP_UCODE_SIZE( warp_g400_t2gzf ) +
-		 WARP_UCODE_SIZE( warp_g400_t2gzs ) +
-		 WARP_UCODE_SIZE( warp_g400_t2gzsa ) +
-		 WARP_UCODE_SIZE( warp_g400_t2gzsaf ) +
-		 WARP_UCODE_SIZE( warp_g400_t2gzsf ) );
-
-	size = PAGE_ALIGN( size );
-
-	DRM_DEBUG( "G400 ucode size = %d bytes\n", size );
-	return size;
-}
 
-static unsigned int mga_warp_g200_microcode_size( drm_mga_private_t *dev_priv )
+unsigned int mga_warp_microcode_size(const drm_mga_private_t * dev_priv)
 {
-	unsigned int size;
-
-	size = ( WARP_UCODE_SIZE( warp_g200_tgz ) +
-		 WARP_UCODE_SIZE( warp_g200_tgza ) +
-		 WARP_UCODE_SIZE( warp_g200_tgzaf ) +
-		 WARP_UCODE_SIZE( warp_g200_tgzf ) +
-		 WARP_UCODE_SIZE( warp_g200_tgzs ) +
-		 WARP_UCODE_SIZE( warp_g200_tgzsa ) +
-		 WARP_UCODE_SIZE( warp_g200_tgzsaf ) +
-		 WARP_UCODE_SIZE( warp_g200_tgzsf ) );
-
-	size = PAGE_ALIGN( size );
-
-	DRM_DEBUG( "G200 ucode size = %d bytes\n", size );
-	return size;
+	switch (dev_priv->chipset) {
+	case MGA_CARD_TYPE_G400:
+	case MGA_CARD_TYPE_G550:
+		return PAGE_ALIGN(mga_warp_g400_microcode_size);
+	case MGA_CARD_TYPE_G200:
+		return PAGE_ALIGN(mga_warp_g200_microcode_size);
+	default:
+		return 0;
+	}
 }
 
-static int mga_warp_install_g400_microcode( drm_mga_private_t *dev_priv )
+static int mga_warp_install_g400_microcode(drm_mga_private_t * dev_priv)
 {
 	unsigned char *vcbase = dev_priv->warp->handle;
 	unsigned long pcbase = dev_priv->warp->offset;
-	unsigned int size;
-
-	size = mga_warp_g400_microcode_size( dev_priv );
-	if ( size > dev_priv->warp->size ) {
-		DRM_ERROR( "microcode too large! (%u > %lu)\n",
-			   size, dev_priv->warp->size );
-		return DRM_ERR(ENOMEM);
-	}
 
-	memset( dev_priv->warp_pipe_phys, 0,
-		sizeof(dev_priv->warp_pipe_phys) );
+	memset(dev_priv->warp_pipe_phys, 0, sizeof(dev_priv->warp_pipe_phys));
 
-	WARP_UCODE_INSTALL( warp_g400_tgz,	MGA_WARP_TGZ );
-	WARP_UCODE_INSTALL( warp_g400_tgzf,	MGA_WARP_TGZF );
-	WARP_UCODE_INSTALL( warp_g400_tgza,	MGA_WARP_TGZA );
-	WARP_UCODE_INSTALL( warp_g400_tgzaf,	MGA_WARP_TGZAF );
-	WARP_UCODE_INSTALL( warp_g400_tgzs,	MGA_WARP_TGZS );
-	WARP_UCODE_INSTALL( warp_g400_tgzsf,	MGA_WARP_TGZSF );
-	WARP_UCODE_INSTALL( warp_g400_tgzsa,	MGA_WARP_TGZSA );
-	WARP_UCODE_INSTALL( warp_g400_tgzsaf,	MGA_WARP_TGZSAF );
-
-	WARP_UCODE_INSTALL( warp_g400_t2gz,	MGA_WARP_T2GZ );
-	WARP_UCODE_INSTALL( warp_g400_t2gzf,	MGA_WARP_T2GZF );
-	WARP_UCODE_INSTALL( warp_g400_t2gza,	MGA_WARP_T2GZA );
-	WARP_UCODE_INSTALL( warp_g400_t2gzaf,	MGA_WARP_T2GZAF );
-	WARP_UCODE_INSTALL( warp_g400_t2gzs,	MGA_WARP_T2GZS );
-	WARP_UCODE_INSTALL( warp_g400_t2gzsf,	MGA_WARP_T2GZSF );
-	WARP_UCODE_INSTALL( warp_g400_t2gzsa,	MGA_WARP_T2GZSA );
-	WARP_UCODE_INSTALL( warp_g400_t2gzsaf,	MGA_WARP_T2GZSAF );
+	WARP_UCODE_INSTALL(warp_g400_tgz, MGA_WARP_TGZ);
+	WARP_UCODE_INSTALL(warp_g400_tgzf, MGA_WARP_TGZF);
+	WARP_UCODE_INSTALL(warp_g400_tgza, MGA_WARP_TGZA);
+	WARP_UCODE_INSTALL(warp_g400_tgzaf, MGA_WARP_TGZAF);
+	WARP_UCODE_INSTALL(warp_g400_tgzs, MGA_WARP_TGZS);
+	WARP_UCODE_INSTALL(warp_g400_tgzsf, MGA_WARP_TGZSF);
+	WARP_UCODE_INSTALL(warp_g400_tgzsa, MGA_WARP_TGZSA);
+	WARP_UCODE_INSTALL(warp_g400_tgzsaf, MGA_WARP_TGZSAF);
+
+	WARP_UCODE_INSTALL(warp_g400_t2gz, MGA_WARP_T2GZ);
+	WARP_UCODE_INSTALL(warp_g400_t2gzf, MGA_WARP_T2GZF);
+	WARP_UCODE_INSTALL(warp_g400_t2gza, MGA_WARP_T2GZA);
+	WARP_UCODE_INSTALL(warp_g400_t2gzaf, MGA_WARP_T2GZAF);
+	WARP_UCODE_INSTALL(warp_g400_t2gzs, MGA_WARP_T2GZS);
+	WARP_UCODE_INSTALL(warp_g400_t2gzsf, MGA_WARP_T2GZSF);
+	WARP_UCODE_INSTALL(warp_g400_t2gzsa, MGA_WARP_T2GZSA);
+	WARP_UCODE_INSTALL(warp_g400_t2gzsaf, MGA_WARP_T2GZSAF);
 
 	return 0;
 }
 
-static int mga_warp_install_g200_microcode( drm_mga_private_t *dev_priv )
+static int mga_warp_install_g200_microcode(drm_mga_private_t * dev_priv)
 {
 	unsigned char *vcbase = dev_priv->warp->handle;
 	unsigned long pcbase = dev_priv->warp->offset;
-	unsigned int size;
 
-	size = mga_warp_g200_microcode_size( dev_priv );
-	if ( size > dev_priv->warp->size ) {
-		DRM_ERROR( "microcode too large! (%u > %lu)\n",
-			   size, dev_priv->warp->size );
-		return DRM_ERR(ENOMEM);
-	}
+	memset(dev_priv->warp_pipe_phys, 0, sizeof(dev_priv->warp_pipe_phys));
 
-	memset( dev_priv->warp_pipe_phys, 0,
-		sizeof(dev_priv->warp_pipe_phys) );
-
-	WARP_UCODE_INSTALL( warp_g200_tgz,	MGA_WARP_TGZ );
-	WARP_UCODE_INSTALL( warp_g200_tgzf,	MGA_WARP_TGZF );
-	WARP_UCODE_INSTALL( warp_g200_tgza,	MGA_WARP_TGZA );
-	WARP_UCODE_INSTALL( warp_g200_tgzaf,	MGA_WARP_TGZAF );
-	WARP_UCODE_INSTALL( warp_g200_tgzs,	MGA_WARP_TGZS );
-	WARP_UCODE_INSTALL( warp_g200_tgzsf,	MGA_WARP_TGZSF );
-	WARP_UCODE_INSTALL( warp_g200_tgzsa,	MGA_WARP_TGZSA );
-	WARP_UCODE_INSTALL( warp_g200_tgzsaf,	MGA_WARP_TGZSAF );
+	WARP_UCODE_INSTALL(warp_g200_tgz, MGA_WARP_TGZ);
+	WARP_UCODE_INSTALL(warp_g200_tgzf, MGA_WARP_TGZF);
+	WARP_UCODE_INSTALL(warp_g200_tgza, MGA_WARP_TGZA);
+	WARP_UCODE_INSTALL(warp_g200_tgzaf, MGA_WARP_TGZAF);
+	WARP_UCODE_INSTALL(warp_g200_tgzs, MGA_WARP_TGZS);
+	WARP_UCODE_INSTALL(warp_g200_tgzsf, MGA_WARP_TGZSF);
+	WARP_UCODE_INSTALL(warp_g200_tgzsa, MGA_WARP_TGZSA);
+	WARP_UCODE_INSTALL(warp_g200_tgzsaf, MGA_WARP_TGZSAF);
 
 	return 0;
 }
 
-int mga_warp_install_microcode(	drm_mga_private_t *dev_priv )
+int mga_warp_install_microcode(drm_mga_private_t * dev_priv)
 {
-	switch ( dev_priv->chipset ) {
+	const unsigned int size = mga_warp_microcode_size(dev_priv);
+
+	DRM_DEBUG("MGA ucode size = %d bytes\n", size);
+	if (size > dev_priv->warp->size) {
+		DRM_ERROR("microcode too large! (%u > %lu)\n",
+			  size, dev_priv->warp->size);
+		return DRM_ERR(ENOMEM);
+	}
+
+	switch (dev_priv->chipset) {
 	case MGA_CARD_TYPE_G400:
-		return mga_warp_install_g400_microcode( dev_priv );
+	case MGA_CARD_TYPE_G550:
+		return mga_warp_install_g400_microcode(dev_priv);
 	case MGA_CARD_TYPE_G200:
-		return mga_warp_install_g200_microcode( dev_priv );
+		return mga_warp_install_g200_microcode(dev_priv);
 	default:
 		return DRM_ERR(EINVAL);
 	}
@@ -174,35 +160,35 @@ int mga_warp_install_microcode(	drm_mga_
 
 #define WMISC_EXPECTED		(MGA_WUCODECACHE_ENABLE | MGA_WMASTER_ENABLE)
 
-int mga_warp_init( drm_mga_private_t *dev_priv )
+int mga_warp_init(drm_mga_private_t * dev_priv)
 {
 	u32 wmisc;
 
 	/* FIXME: Get rid of these damned magic numbers...
 	 */
-	switch ( dev_priv->chipset ) {
+	switch (dev_priv->chipset) {
 	case MGA_CARD_TYPE_G400:
-		MGA_WRITE( MGA_WIADDR2, MGA_WMODE_SUSPEND );
-		MGA_WRITE( MGA_WGETMSB, 0x00000E00 );
-		MGA_WRITE( MGA_WVRTXSZ, 0x00001807 );
-		MGA_WRITE( MGA_WACCEPTSEQ, 0x18000000 );
+	case MGA_CARD_TYPE_G550:
+		MGA_WRITE(MGA_WIADDR2, MGA_WMODE_SUSPEND);
+		MGA_WRITE(MGA_WGETMSB, 0x00000E00);
+		MGA_WRITE(MGA_WVRTXSZ, 0x00001807);
+		MGA_WRITE(MGA_WACCEPTSEQ, 0x18000000);
 		break;
 	case MGA_CARD_TYPE_G200:
-		MGA_WRITE( MGA_WIADDR, MGA_WMODE_SUSPEND );
-		MGA_WRITE( MGA_WGETMSB, 0x1606 );
-		MGA_WRITE( MGA_WVRTXSZ, 7 );
+		MGA_WRITE(MGA_WIADDR, MGA_WMODE_SUSPEND);
+		MGA_WRITE(MGA_WGETMSB, 0x1606);
+		MGA_WRITE(MGA_WVRTXSZ, 7);
 		break;
 	default:
 		return DRM_ERR(EINVAL);
 	}
 
-	MGA_WRITE( MGA_WMISC, (MGA_WUCODECACHE_ENABLE |
-			       MGA_WMASTER_ENABLE |
-			       MGA_WCACHEFLUSH_ENABLE) );
-	wmisc = MGA_READ( MGA_WMISC );
-	if ( wmisc != WMISC_EXPECTED ) {
-		DRM_ERROR( "WARP engine config failed! 0x%x != 0x%x\n",
-			   wmisc, WMISC_EXPECTED );
+	MGA_WRITE(MGA_WMISC, (MGA_WUCODECACHE_ENABLE |
+			      MGA_WMASTER_ENABLE | MGA_WCACHEFLUSH_ENABLE));
+	wmisc = MGA_READ(MGA_WMISC);
+	if (wmisc != WMISC_EXPECTED) {
+		DRM_ERROR("WARP engine config failed! 0x%x != 0x%x\n",
+			  wmisc, WMISC_EXPECTED);
 		return DRM_ERR(EINVAL);
 	}
 
diff -purN linux-2.6.12.orig/drivers/char/drm/r128_cce.c linux-2.6.12/drivers/char/drm/r128_cce.c
--- linux-2.6.12.orig/drivers/char/drm/r128_cce.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/r128_cce.c	2005-07-05 08:37:47.000000000 +0200
@@ -80,7 +80,7 @@ static u32 r128_cce_microcode[] = {
 	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
 };
 
-static int R128_READ_PLL(drm_device_t *dev, int addr)
+static int R128_READ_PLL(drm_device_t * dev, int addr)
 {
 	drm_r128_private_t *dev_priv = dev->dev_private;
 
@@ -89,106 +89,105 @@ static int R128_READ_PLL(drm_device_t *d
 }
 
 #if R128_FIFO_DEBUG
-static void r128_status( drm_r128_private_t *dev_priv )
+static void r128_status(drm_r128_private_t * dev_priv)
 {
-	printk( "GUI_STAT           = 0x%08x\n",
-		(unsigned int)R128_READ( R128_GUI_STAT ) );
-	printk( "PM4_STAT           = 0x%08x\n",
-		(unsigned int)R128_READ( R128_PM4_STAT ) );
-	printk( "PM4_BUFFER_DL_WPTR = 0x%08x\n",
-		(unsigned int)R128_READ( R128_PM4_BUFFER_DL_WPTR ) );
-	printk( "PM4_BUFFER_DL_RPTR = 0x%08x\n",
-		(unsigned int)R128_READ( R128_PM4_BUFFER_DL_RPTR ) );
-	printk( "PM4_MICRO_CNTL     = 0x%08x\n",
-		(unsigned int)R128_READ( R128_PM4_MICRO_CNTL ) );
-	printk( "PM4_BUFFER_CNTL    = 0x%08x\n",
-		(unsigned int)R128_READ( R128_PM4_BUFFER_CNTL ) );
+	printk("GUI_STAT           = 0x%08x\n",
+	       (unsigned int)R128_READ(R128_GUI_STAT));
+	printk("PM4_STAT           = 0x%08x\n",
+	       (unsigned int)R128_READ(R128_PM4_STAT));
+	printk("PM4_BUFFER_DL_WPTR = 0x%08x\n",
+	       (unsigned int)R128_READ(R128_PM4_BUFFER_DL_WPTR));
+	printk("PM4_BUFFER_DL_RPTR = 0x%08x\n",
+	       (unsigned int)R128_READ(R128_PM4_BUFFER_DL_RPTR));
+	printk("PM4_MICRO_CNTL     = 0x%08x\n",
+	       (unsigned int)R128_READ(R128_PM4_MICRO_CNTL));
+	printk("PM4_BUFFER_CNTL    = 0x%08x\n",
+	       (unsigned int)R128_READ(R128_PM4_BUFFER_CNTL));
 }
 #endif
 
-
 /* ================================================================
  * Engine, FIFO control
  */
 
-static int r128_do_pixcache_flush( drm_r128_private_t *dev_priv )
+static int r128_do_pixcache_flush(drm_r128_private_t * dev_priv)
 {
 	u32 tmp;
 	int i;
 
-	tmp = R128_READ( R128_PC_NGUI_CTLSTAT ) | R128_PC_FLUSH_ALL;
-	R128_WRITE( R128_PC_NGUI_CTLSTAT, tmp );
+	tmp = R128_READ(R128_PC_NGUI_CTLSTAT) | R128_PC_FLUSH_ALL;
+	R128_WRITE(R128_PC_NGUI_CTLSTAT, tmp);
 
-	for ( i = 0 ; i < dev_priv->usec_timeout ; i++ ) {
-		if ( !(R128_READ( R128_PC_NGUI_CTLSTAT ) & R128_PC_BUSY) ) {
+	for (i = 0; i < dev_priv->usec_timeout; i++) {
+		if (!(R128_READ(R128_PC_NGUI_CTLSTAT) & R128_PC_BUSY)) {
 			return 0;
 		}
-		DRM_UDELAY( 1 );
+		DRM_UDELAY(1);
 	}
 
 #if R128_FIFO_DEBUG
-	DRM_ERROR( "failed!\n" );
+	DRM_ERROR("failed!\n");
 #endif
 	return DRM_ERR(EBUSY);
 }
 
-static int r128_do_wait_for_fifo( drm_r128_private_t *dev_priv, int entries )
+static int r128_do_wait_for_fifo(drm_r128_private_t * dev_priv, int entries)
 {
 	int i;
 
-	for ( i = 0 ; i < dev_priv->usec_timeout ; i++ ) {
-		int slots = R128_READ( R128_GUI_STAT ) & R128_GUI_FIFOCNT_MASK;
-		if ( slots >= entries ) return 0;
-		DRM_UDELAY( 1 );
+	for (i = 0; i < dev_priv->usec_timeout; i++) {
+		int slots = R128_READ(R128_GUI_STAT) & R128_GUI_FIFOCNT_MASK;
+		if (slots >= entries)
+			return 0;
+		DRM_UDELAY(1);
 	}
 
 #if R128_FIFO_DEBUG
-	DRM_ERROR( "failed!\n" );
+	DRM_ERROR("failed!\n");
 #endif
 	return DRM_ERR(EBUSY);
 }
 
-static int r128_do_wait_for_idle( drm_r128_private_t *dev_priv )
+static int r128_do_wait_for_idle(drm_r128_private_t * dev_priv)
 {
 	int i, ret;
 
-	ret = r128_do_wait_for_fifo( dev_priv, 64 );
-	if ( ret ) return ret;
-
-	for ( i = 0 ; i < dev_priv->usec_timeout ; i++ ) {
-		if ( !(R128_READ( R128_GUI_STAT ) & R128_GUI_ACTIVE) ) {
-			r128_do_pixcache_flush( dev_priv );
+	ret = r128_do_wait_for_fifo(dev_priv, 64);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < dev_priv->usec_timeout; i++) {
+		if (!(R128_READ(R128_GUI_STAT) & R128_GUI_ACTIVE)) {
+			r128_do_pixcache_flush(dev_priv);
 			return 0;
 		}
-		DRM_UDELAY( 1 );
+		DRM_UDELAY(1);
 	}
 
 #if R128_FIFO_DEBUG
-	DRM_ERROR( "failed!\n" );
+	DRM_ERROR("failed!\n");
 #endif
 	return DRM_ERR(EBUSY);
 }
 
-
 /* ================================================================
  * CCE control, initialization
  */
 
 /* Load the microcode for the CCE */
-static void r128_cce_load_microcode( drm_r128_private_t *dev_priv )
+static void r128_cce_load_microcode(drm_r128_private_t * dev_priv)
 {
 	int i;
 
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
-	r128_do_wait_for_idle( dev_priv );
+	r128_do_wait_for_idle(dev_priv);
 
-	R128_WRITE( R128_PM4_MICROCODE_ADDR, 0 );
-	for ( i = 0 ; i < 256 ; i++ ) {
-		R128_WRITE( R128_PM4_MICROCODE_DATAH,
-			    r128_cce_microcode[i * 2] );
-		R128_WRITE( R128_PM4_MICROCODE_DATAL,
-			    r128_cce_microcode[i * 2 + 1] );
+	R128_WRITE(R128_PM4_MICROCODE_ADDR, 0);
+	for (i = 0; i < 256; i++) {
+		R128_WRITE(R128_PM4_MICROCODE_DATAH, r128_cce_microcode[i * 2]);
+		R128_WRITE(R128_PM4_MICROCODE_DATAL,
+			   r128_cce_microcode[i * 2 + 1]);
 	}
 }
 
@@ -196,51 +195,51 @@ static void r128_cce_load_microcode( drm
  * prior to a wait for idle, as it informs the engine that the command
  * stream is ending.
  */
-static void r128_do_cce_flush( drm_r128_private_t *dev_priv )
+static void r128_do_cce_flush(drm_r128_private_t * dev_priv)
 {
 	u32 tmp;
 
-	tmp = R128_READ( R128_PM4_BUFFER_DL_WPTR ) | R128_PM4_BUFFER_DL_DONE;
-	R128_WRITE( R128_PM4_BUFFER_DL_WPTR, tmp );
+	tmp = R128_READ(R128_PM4_BUFFER_DL_WPTR) | R128_PM4_BUFFER_DL_DONE;
+	R128_WRITE(R128_PM4_BUFFER_DL_WPTR, tmp);
 }
 
 /* Wait for the CCE to go idle.
  */
-int r128_do_cce_idle( drm_r128_private_t *dev_priv )
+int r128_do_cce_idle(drm_r128_private_t * dev_priv)
 {
 	int i;
 
-	for ( i = 0 ; i < dev_priv->usec_timeout ; i++ ) {
-		if ( GET_RING_HEAD( dev_priv ) == dev_priv->ring.tail ) {
-			int pm4stat = R128_READ( R128_PM4_STAT );
-			if ( ( (pm4stat & R128_PM4_FIFOCNT_MASK) >=
-			       dev_priv->cce_fifo_size ) &&
-			     !(pm4stat & (R128_PM4_BUSY |
-					  R128_PM4_GUI_ACTIVE)) ) {
-				return r128_do_pixcache_flush( dev_priv );
+	for (i = 0; i < dev_priv->usec_timeout; i++) {
+		if (GET_RING_HEAD(dev_priv) == dev_priv->ring.tail) {
+			int pm4stat = R128_READ(R128_PM4_STAT);
+			if (((pm4stat & R128_PM4_FIFOCNT_MASK) >=
+			     dev_priv->cce_fifo_size) &&
+			    !(pm4stat & (R128_PM4_BUSY |
+					 R128_PM4_GUI_ACTIVE))) {
+				return r128_do_pixcache_flush(dev_priv);
 			}
 		}
-		DRM_UDELAY( 1 );
+		DRM_UDELAY(1);
 	}
 
 #if R128_FIFO_DEBUG
-	DRM_ERROR( "failed!\n" );
-	r128_status( dev_priv );
+	DRM_ERROR("failed!\n");
+	r128_status(dev_priv);
 #endif
 	return DRM_ERR(EBUSY);
 }
 
 /* Start the Concurrent Command Engine.
  */
-static void r128_do_cce_start( drm_r128_private_t *dev_priv )
+static void r128_do_cce_start(drm_r128_private_t * dev_priv)
 {
-	r128_do_wait_for_idle( dev_priv );
+	r128_do_wait_for_idle(dev_priv);
 
-	R128_WRITE( R128_PM4_BUFFER_CNTL,
-		    dev_priv->cce_mode | dev_priv->ring.size_l2qw
-		    | R128_PM4_BUFFER_CNTL_NOUPDATE );
-	R128_READ( R128_PM4_BUFFER_ADDR ); /* as per the sample code */
-	R128_WRITE( R128_PM4_MICRO_CNTL, R128_PM4_MICRO_FREERUN );
+	R128_WRITE(R128_PM4_BUFFER_CNTL,
+		   dev_priv->cce_mode | dev_priv->ring.size_l2qw
+		   | R128_PM4_BUFFER_CNTL_NOUPDATE);
+	R128_READ(R128_PM4_BUFFER_ADDR);	/* as per the sample code */
+	R128_WRITE(R128_PM4_MICRO_CNTL, R128_PM4_MICRO_FREERUN);
 
 	dev_priv->cce_running = 1;
 }
@@ -249,10 +248,10 @@ static void r128_do_cce_start( drm_r128_
  * commands, so you must wait for the CCE command stream to complete
  * before calling this routine.
  */
-static void r128_do_cce_reset( drm_r128_private_t *dev_priv )
+static void r128_do_cce_reset(drm_r128_private_t * dev_priv)
 {
-	R128_WRITE( R128_PM4_BUFFER_DL_WPTR, 0 );
-	R128_WRITE( R128_PM4_BUFFER_DL_RPTR, 0 );
+	R128_WRITE(R128_PM4_BUFFER_DL_WPTR, 0);
+	R128_WRITE(R128_PM4_BUFFER_DL_RPTR, 0);
 	dev_priv->ring.tail = 0;
 }
 
@@ -260,121 +259,119 @@ static void r128_do_cce_reset( drm_r128_
  * commands, so you must flush the command stream and wait for the CCE
  * to go idle before calling this routine.
  */
-static void r128_do_cce_stop( drm_r128_private_t *dev_priv )
+static void r128_do_cce_stop(drm_r128_private_t * dev_priv)
 {
-	R128_WRITE( R128_PM4_MICRO_CNTL, 0 );
-	R128_WRITE( R128_PM4_BUFFER_CNTL,
-		    R128_PM4_NONPM4 | R128_PM4_BUFFER_CNTL_NOUPDATE );
+	R128_WRITE(R128_PM4_MICRO_CNTL, 0);
+	R128_WRITE(R128_PM4_BUFFER_CNTL,
+		   R128_PM4_NONPM4 | R128_PM4_BUFFER_CNTL_NOUPDATE);
 
 	dev_priv->cce_running = 0;
 }
 
 /* Reset the engine.  This will stop the CCE if it is running.
  */
-static int r128_do_engine_reset( drm_device_t *dev )
+static int r128_do_engine_reset(drm_device_t * dev)
 {
 	drm_r128_private_t *dev_priv = dev->dev_private;
 	u32 clock_cntl_index, mclk_cntl, gen_reset_cntl;
 
-	r128_do_pixcache_flush( dev_priv );
+	r128_do_pixcache_flush(dev_priv);
 
-	clock_cntl_index = R128_READ( R128_CLOCK_CNTL_INDEX );
-	mclk_cntl = R128_READ_PLL( dev, R128_MCLK_CNTL );
+	clock_cntl_index = R128_READ(R128_CLOCK_CNTL_INDEX);
+	mclk_cntl = R128_READ_PLL(dev, R128_MCLK_CNTL);
 
-	R128_WRITE_PLL( R128_MCLK_CNTL,
-			mclk_cntl | R128_FORCE_GCP | R128_FORCE_PIPE3D_CP );
+	R128_WRITE_PLL(R128_MCLK_CNTL,
+		       mclk_cntl | R128_FORCE_GCP | R128_FORCE_PIPE3D_CP);
 
-	gen_reset_cntl = R128_READ( R128_GEN_RESET_CNTL );
+	gen_reset_cntl = R128_READ(R128_GEN_RESET_CNTL);
 
 	/* Taken from the sample code - do not change */
-	R128_WRITE( R128_GEN_RESET_CNTL,
-		    gen_reset_cntl | R128_SOFT_RESET_GUI );
-	R128_READ( R128_GEN_RESET_CNTL );
-	R128_WRITE( R128_GEN_RESET_CNTL,
-		    gen_reset_cntl & ~R128_SOFT_RESET_GUI );
-	R128_READ( R128_GEN_RESET_CNTL );
-
-	R128_WRITE_PLL( R128_MCLK_CNTL, mclk_cntl );
-	R128_WRITE( R128_CLOCK_CNTL_INDEX, clock_cntl_index );
-	R128_WRITE( R128_GEN_RESET_CNTL, gen_reset_cntl );
+	R128_WRITE(R128_GEN_RESET_CNTL, gen_reset_cntl | R128_SOFT_RESET_GUI);
+	R128_READ(R128_GEN_RESET_CNTL);
+	R128_WRITE(R128_GEN_RESET_CNTL, gen_reset_cntl & ~R128_SOFT_RESET_GUI);
+	R128_READ(R128_GEN_RESET_CNTL);
+
+	R128_WRITE_PLL(R128_MCLK_CNTL, mclk_cntl);
+	R128_WRITE(R128_CLOCK_CNTL_INDEX, clock_cntl_index);
+	R128_WRITE(R128_GEN_RESET_CNTL, gen_reset_cntl);
 
 	/* Reset the CCE ring */
-	r128_do_cce_reset( dev_priv );
+	r128_do_cce_reset(dev_priv);
 
 	/* The CCE is no longer running after an engine reset */
 	dev_priv->cce_running = 0;
 
 	/* Reset any pending vertex, indirect buffers */
-	r128_freelist_reset( dev );
+	r128_freelist_reset(dev);
 
 	return 0;
 }
 
-static void r128_cce_init_ring_buffer( drm_device_t *dev,
-				       drm_r128_private_t *dev_priv )
+static void r128_cce_init_ring_buffer(drm_device_t * dev,
+				      drm_r128_private_t * dev_priv)
 {
 	u32 ring_start;
 	u32 tmp;
 
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
 	/* The manual (p. 2) says this address is in "VM space".  This
 	 * means it's an offset from the start of AGP space.
 	 */
 #if __OS_HAS_AGP
-	if ( !dev_priv->is_pci )
+	if (!dev_priv->is_pci)
 		ring_start = dev_priv->cce_ring->offset - dev->agp->base;
 	else
 #endif
 		ring_start = dev_priv->cce_ring->offset - dev->sg->handle;
 
-	R128_WRITE( R128_PM4_BUFFER_OFFSET, ring_start | R128_AGP_OFFSET );
+	R128_WRITE(R128_PM4_BUFFER_OFFSET, ring_start | R128_AGP_OFFSET);
 
-	R128_WRITE( R128_PM4_BUFFER_DL_WPTR, 0 );
-	R128_WRITE( R128_PM4_BUFFER_DL_RPTR, 0 );
+	R128_WRITE(R128_PM4_BUFFER_DL_WPTR, 0);
+	R128_WRITE(R128_PM4_BUFFER_DL_RPTR, 0);
 
 	/* Set watermark control */
-	R128_WRITE( R128_PM4_BUFFER_WM_CNTL,
-		    ((R128_WATERMARK_L/4) << R128_WMA_SHIFT)
-		    | ((R128_WATERMARK_M/4) << R128_WMB_SHIFT)
-		    | ((R128_WATERMARK_N/4) << R128_WMC_SHIFT)
-		    | ((R128_WATERMARK_K/64) << R128_WB_WM_SHIFT) );
+	R128_WRITE(R128_PM4_BUFFER_WM_CNTL,
+		   ((R128_WATERMARK_L / 4) << R128_WMA_SHIFT)
+		   | ((R128_WATERMARK_M / 4) << R128_WMB_SHIFT)
+		   | ((R128_WATERMARK_N / 4) << R128_WMC_SHIFT)
+		   | ((R128_WATERMARK_K / 64) << R128_WB_WM_SHIFT));
 
 	/* Force read.  Why?  Because it's in the examples... */
-	R128_READ( R128_PM4_BUFFER_ADDR );
+	R128_READ(R128_PM4_BUFFER_ADDR);
 
 	/* Turn on bus mastering */
-	tmp = R128_READ( R128_BUS_CNTL ) & ~R128_BUS_MASTER_DIS;
-	R128_WRITE( R128_BUS_CNTL, tmp );
+	tmp = R128_READ(R128_BUS_CNTL) & ~R128_BUS_MASTER_DIS;
+	R128_WRITE(R128_BUS_CNTL, tmp);
 }
 
-static int r128_do_init_cce( drm_device_t *dev, drm_r128_init_t *init )
+static int r128_do_init_cce(drm_device_t * dev, drm_r128_init_t * init)
 {
 	drm_r128_private_t *dev_priv;
 
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
-	dev_priv = drm_alloc( sizeof(drm_r128_private_t), DRM_MEM_DRIVER );
-	if ( dev_priv == NULL )
+	dev_priv = drm_alloc(sizeof(drm_r128_private_t), DRM_MEM_DRIVER);
+	if (dev_priv == NULL)
 		return DRM_ERR(ENOMEM);
 
-	memset( dev_priv, 0, sizeof(drm_r128_private_t) );
+	memset(dev_priv, 0, sizeof(drm_r128_private_t));
 
 	dev_priv->is_pci = init->is_pci;
 
-	if ( dev_priv->is_pci && !dev->sg ) {
-		DRM_ERROR( "PCI GART memory not allocated!\n" );
+	if (dev_priv->is_pci && !dev->sg) {
+		DRM_ERROR("PCI GART memory not allocated!\n");
 		dev->dev_private = (void *)dev_priv;
-		r128_do_cleanup_cce( dev );
+		r128_do_cleanup_cce(dev);
 		return DRM_ERR(EINVAL);
 	}
 
 	dev_priv->usec_timeout = init->usec_timeout;
-	if ( dev_priv->usec_timeout < 1 ||
-	     dev_priv->usec_timeout > R128_MAX_USEC_TIMEOUT ) {
-		DRM_DEBUG( "TIMEOUT problem!\n" );
+	if (dev_priv->usec_timeout < 1 ||
+	    dev_priv->usec_timeout > R128_MAX_USEC_TIMEOUT) {
+		DRM_DEBUG("TIMEOUT problem!\n");
 		dev->dev_private = (void *)dev_priv;
-		r128_do_cleanup_cce( dev );
+		r128_do_cleanup_cce(dev);
 		return DRM_ERR(EINVAL);
 	}
 
@@ -382,23 +379,23 @@ static int r128_do_init_cce( drm_device_
 
 	/* GH: Simple idle check.
 	 */
-	atomic_set( &dev_priv->idle_count, 0 );
+	atomic_set(&dev_priv->idle_count, 0);
 
 	/* We don't support anything other than bus-mastering ring mode,
 	 * but the ring can be in either AGP or PCI space for the ring
 	 * read pointer.
 	 */
-	if ( ( init->cce_mode != R128_PM4_192BM ) &&
-	     ( init->cce_mode != R128_PM4_128BM_64INDBM ) &&
-	     ( init->cce_mode != R128_PM4_64BM_128INDBM ) &&
-	     ( init->cce_mode != R128_PM4_64BM_64VCBM_64INDBM ) ) {
-		DRM_DEBUG( "Bad cce_mode!\n" );
+	if ((init->cce_mode != R128_PM4_192BM) &&
+	    (init->cce_mode != R128_PM4_128BM_64INDBM) &&
+	    (init->cce_mode != R128_PM4_64BM_128INDBM) &&
+	    (init->cce_mode != R128_PM4_64BM_64VCBM_64INDBM)) {
+		DRM_DEBUG("Bad cce_mode!\n");
 		dev->dev_private = (void *)dev_priv;
-		r128_do_cleanup_cce( dev );
+		r128_do_cleanup_cce(dev);
 		return DRM_ERR(EINVAL);
 	}
 
-	switch ( init->cce_mode ) {
+	switch (init->cce_mode) {
 	case R128_PM4_NONPM4:
 		dev_priv->cce_fifo_size = 0;
 		break;
@@ -419,7 +416,7 @@ static int r128_do_init_cce( drm_device_
 		break;
 	}
 
-	switch ( init->fb_bpp ) {
+	switch (init->fb_bpp) {
 	case 16:
 		dev_priv->color_fmt = R128_DATATYPE_RGB565;
 		break;
@@ -428,12 +425,12 @@ static int r128_do_init_cce( drm_device_
 		dev_priv->color_fmt = R128_DATATYPE_ARGB8888;
 		break;
 	}
-	dev_priv->front_offset	= init->front_offset;
-	dev_priv->front_pitch	= init->front_pitch;
-	dev_priv->back_offset	= init->back_offset;
-	dev_priv->back_pitch	= init->back_pitch;
+	dev_priv->front_offset = init->front_offset;
+	dev_priv->front_pitch = init->front_pitch;
+	dev_priv->back_offset = init->back_offset;
+	dev_priv->back_pitch = init->back_pitch;
 
-	switch ( init->depth_bpp ) {
+	switch (init->depth_bpp) {
 	case 16:
 		dev_priv->depth_fmt = R128_DATATYPE_RGB565;
 		break;
@@ -443,217 +440,220 @@ static int r128_do_init_cce( drm_device_
 		dev_priv->depth_fmt = R128_DATATYPE_ARGB8888;
 		break;
 	}
-	dev_priv->depth_offset	= init->depth_offset;
-	dev_priv->depth_pitch	= init->depth_pitch;
-	dev_priv->span_offset	= init->span_offset;
+	dev_priv->depth_offset = init->depth_offset;
+	dev_priv->depth_pitch = init->depth_pitch;
+	dev_priv->span_offset = init->span_offset;
 
-	dev_priv->front_pitch_offset_c = (((dev_priv->front_pitch/8) << 21) |
+	dev_priv->front_pitch_offset_c = (((dev_priv->front_pitch / 8) << 21) |
 					  (dev_priv->front_offset >> 5));
-	dev_priv->back_pitch_offset_c = (((dev_priv->back_pitch/8) << 21) |
+	dev_priv->back_pitch_offset_c = (((dev_priv->back_pitch / 8) << 21) |
 					 (dev_priv->back_offset >> 5));
-	dev_priv->depth_pitch_offset_c = (((dev_priv->depth_pitch/8) << 21) |
+	dev_priv->depth_pitch_offset_c = (((dev_priv->depth_pitch / 8) << 21) |
 					  (dev_priv->depth_offset >> 5) |
 					  R128_DST_TILE);
-	dev_priv->span_pitch_offset_c = (((dev_priv->depth_pitch/8) << 21) |
+	dev_priv->span_pitch_offset_c = (((dev_priv->depth_pitch / 8) << 21) |
 					 (dev_priv->span_offset >> 5));
 
 	DRM_GETSAREA();
-	
-	if(!dev_priv->sarea) {
+
+	if (!dev_priv->sarea) {
 		DRM_ERROR("could not find sarea!\n");
 		dev->dev_private = (void *)dev_priv;
-		r128_do_cleanup_cce( dev );
+		r128_do_cleanup_cce(dev);
 		return DRM_ERR(EINVAL);
 	}
 
 	dev_priv->mmio = drm_core_findmap(dev, init->mmio_offset);
-	if(!dev_priv->mmio) {
+	if (!dev_priv->mmio) {
 		DRM_ERROR("could not find mmio region!\n");
 		dev->dev_private = (void *)dev_priv;
-		r128_do_cleanup_cce( dev );
+		r128_do_cleanup_cce(dev);
 		return DRM_ERR(EINVAL);
 	}
 	dev_priv->cce_ring = drm_core_findmap(dev, init->ring_offset);
-	if(!dev_priv->cce_ring) {
+	if (!dev_priv->cce_ring) {
 		DRM_ERROR("could not find cce ring region!\n");
 		dev->dev_private = (void *)dev_priv;
-		r128_do_cleanup_cce( dev );
+		r128_do_cleanup_cce(dev);
 		return DRM_ERR(EINVAL);
 	}
 	dev_priv->ring_rptr = drm_core_findmap(dev, init->ring_rptr_offset);
-	if(!dev_priv->ring_rptr) {
+	if (!dev_priv->ring_rptr) {
 		DRM_ERROR("could not find ring read pointer!\n");
 		dev->dev_private = (void *)dev_priv;
-		r128_do_cleanup_cce( dev );
+		r128_do_cleanup_cce(dev);
 		return DRM_ERR(EINVAL);
 	}
 	dev->agp_buffer_map = drm_core_findmap(dev, init->buffers_offset);
-	if(!dev->agp_buffer_map) {
+	if (!dev->agp_buffer_map) {
 		DRM_ERROR("could not find dma buffer region!\n");
 		dev->dev_private = (void *)dev_priv;
-		r128_do_cleanup_cce( dev );
+		r128_do_cleanup_cce(dev);
 		return DRM_ERR(EINVAL);
 	}
 
-	if ( !dev_priv->is_pci ) {
-		dev_priv->agp_textures = drm_core_findmap(dev, init->agp_textures_offset);
-		if(!dev_priv->agp_textures) {
+	if (!dev_priv->is_pci) {
+		dev_priv->agp_textures =
+		    drm_core_findmap(dev, init->agp_textures_offset);
+		if (!dev_priv->agp_textures) {
 			DRM_ERROR("could not find agp texture region!\n");
 			dev->dev_private = (void *)dev_priv;
-			r128_do_cleanup_cce( dev );
+			r128_do_cleanup_cce(dev);
 			return DRM_ERR(EINVAL);
 		}
 	}
 
 	dev_priv->sarea_priv =
-		(drm_r128_sarea_t *)((u8 *)dev_priv->sarea->handle +
-				     init->sarea_priv_offset);
+	    (drm_r128_sarea_t *) ((u8 *) dev_priv->sarea->handle +
+				  init->sarea_priv_offset);
 
 #if __OS_HAS_AGP
-	if ( !dev_priv->is_pci ) {
-		drm_core_ioremap( dev_priv->cce_ring, dev );
-		drm_core_ioremap( dev_priv->ring_rptr, dev );
-		drm_core_ioremap( dev->agp_buffer_map, dev );
-		if(!dev_priv->cce_ring->handle ||
-		   !dev_priv->ring_rptr->handle ||
-		   !dev->agp_buffer_map->handle) {
+	if (!dev_priv->is_pci) {
+		drm_core_ioremap(dev_priv->cce_ring, dev);
+		drm_core_ioremap(dev_priv->ring_rptr, dev);
+		drm_core_ioremap(dev->agp_buffer_map, dev);
+		if (!dev_priv->cce_ring->handle ||
+		    !dev_priv->ring_rptr->handle ||
+		    !dev->agp_buffer_map->handle) {
 			DRM_ERROR("Could not ioremap agp regions!\n");
 			dev->dev_private = (void *)dev_priv;
-			r128_do_cleanup_cce( dev );
+			r128_do_cleanup_cce(dev);
 			return DRM_ERR(ENOMEM);
 		}
 	} else
 #endif
 	{
-		dev_priv->cce_ring->handle =
-			(void *)dev_priv->cce_ring->offset;
+		dev_priv->cce_ring->handle = (void *)dev_priv->cce_ring->offset;
 		dev_priv->ring_rptr->handle =
-			(void *)dev_priv->ring_rptr->offset;
-		dev->agp_buffer_map->handle = (void *)dev->agp_buffer_map->offset;
+		    (void *)dev_priv->ring_rptr->offset;
+		dev->agp_buffer_map->handle =
+		    (void *)dev->agp_buffer_map->offset;
 	}
 
 #if __OS_HAS_AGP
-	if ( !dev_priv->is_pci )
+	if (!dev_priv->is_pci)
 		dev_priv->cce_buffers_offset = dev->agp->base;
 	else
 #endif
 		dev_priv->cce_buffers_offset = dev->sg->handle;
 
-	dev_priv->ring.start = (u32 *)dev_priv->cce_ring->handle;
-	dev_priv->ring.end = ((u32 *)dev_priv->cce_ring->handle
+	dev_priv->ring.start = (u32 *) dev_priv->cce_ring->handle;
+	dev_priv->ring.end = ((u32 *) dev_priv->cce_ring->handle
 			      + init->ring_size / sizeof(u32));
 	dev_priv->ring.size = init->ring_size;
-	dev_priv->ring.size_l2qw = drm_order( init->ring_size / 8 );
+	dev_priv->ring.size_l2qw = drm_order(init->ring_size / 8);
 
-	dev_priv->ring.tail_mask =
-		(dev_priv->ring.size / sizeof(u32)) - 1;
+	dev_priv->ring.tail_mask = (dev_priv->ring.size / sizeof(u32)) - 1;
 
 	dev_priv->ring.high_mark = 128;
 
 	dev_priv->sarea_priv->last_frame = 0;
-	R128_WRITE( R128_LAST_FRAME_REG, dev_priv->sarea_priv->last_frame );
+	R128_WRITE(R128_LAST_FRAME_REG, dev_priv->sarea_priv->last_frame);
 
 	dev_priv->sarea_priv->last_dispatch = 0;
-	R128_WRITE( R128_LAST_DISPATCH_REG,
-		    dev_priv->sarea_priv->last_dispatch );
+	R128_WRITE(R128_LAST_DISPATCH_REG, dev_priv->sarea_priv->last_dispatch);
 
 #if __OS_HAS_AGP
-	if ( dev_priv->is_pci ) {
+	if (dev_priv->is_pci) {
 #endif
-		if (!drm_ati_pcigart_init( dev, &dev_priv->phys_pci_gart,
-     					    &dev_priv->bus_pci_gart) ) {
-			DRM_ERROR( "failed to init PCI GART!\n" );
+		if (!drm_ati_pcigart_init(dev, &dev_priv->phys_pci_gart,
+					  &dev_priv->bus_pci_gart)) {
+			DRM_ERROR("failed to init PCI GART!\n");
 			dev->dev_private = (void *)dev_priv;
-			r128_do_cleanup_cce( dev );
+			r128_do_cleanup_cce(dev);
 			return DRM_ERR(ENOMEM);
 		}
-		R128_WRITE( R128_PCI_GART_PAGE, dev_priv->bus_pci_gart );
+		R128_WRITE(R128_PCI_GART_PAGE, dev_priv->bus_pci_gart);
 #if __OS_HAS_AGP
 	}
 #endif
 
-	r128_cce_init_ring_buffer( dev, dev_priv );
-	r128_cce_load_microcode( dev_priv );
+	r128_cce_init_ring_buffer(dev, dev_priv);
+	r128_cce_load_microcode(dev_priv);
 
 	dev->dev_private = (void *)dev_priv;
 
-	r128_do_engine_reset( dev );
+	r128_do_engine_reset(dev);
 
 	return 0;
 }
 
-int r128_do_cleanup_cce( drm_device_t *dev )
+int r128_do_cleanup_cce(drm_device_t * dev)
 {
 
 	/* Make sure interrupts are disabled here because the uninstall ioctl
 	 * may not have been called from userspace and after dev_private
 	 * is freed, it's too late.
 	 */
-	if ( dev->irq_enabled ) drm_irq_uninstall(dev);
+	if (dev->irq_enabled)
+		drm_irq_uninstall(dev);
 
-	if ( dev->dev_private ) {
+	if (dev->dev_private) {
 		drm_r128_private_t *dev_priv = dev->dev_private;
 
 #if __OS_HAS_AGP
-		if ( !dev_priv->is_pci ) {
-			if ( dev_priv->cce_ring != NULL )
-				drm_core_ioremapfree( dev_priv->cce_ring, dev );
-			if ( dev_priv->ring_rptr != NULL )
-				drm_core_ioremapfree( dev_priv->ring_rptr, dev );
-			if ( dev->agp_buffer_map != NULL )
-				drm_core_ioremapfree( dev->agp_buffer_map, dev );
+		if (!dev_priv->is_pci) {
+			if (dev_priv->cce_ring != NULL)
+				drm_core_ioremapfree(dev_priv->cce_ring, dev);
+			if (dev_priv->ring_rptr != NULL)
+				drm_core_ioremapfree(dev_priv->ring_rptr, dev);
+			if (dev->agp_buffer_map != NULL) {
+				drm_core_ioremapfree(dev->agp_buffer_map, dev);
+				dev->agp_buffer_map = NULL;
+			}
 		} else
 #endif
 		{
-			if (!drm_ati_pcigart_cleanup( dev,
-						dev_priv->phys_pci_gart,
-						dev_priv->bus_pci_gart ))
-				DRM_ERROR( "failed to cleanup PCI GART!\n" );
+			if (!drm_ati_pcigart_cleanup(dev,
+						     dev_priv->phys_pci_gart,
+						     dev_priv->bus_pci_gart))
+				DRM_ERROR("failed to cleanup PCI GART!\n");
 		}
 
-		drm_free( dev->dev_private, sizeof(drm_r128_private_t),
-			   DRM_MEM_DRIVER );
+		drm_free(dev->dev_private, sizeof(drm_r128_private_t),
+			 DRM_MEM_DRIVER);
 		dev->dev_private = NULL;
 	}
 
 	return 0;
 }
 
-int r128_cce_init( DRM_IOCTL_ARGS )
+int r128_cce_init(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_r128_init_t init;
 
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	DRM_COPY_FROM_USER_IOCTL( init, (drm_r128_init_t __user *)data, sizeof(init) );
+	DRM_COPY_FROM_USER_IOCTL(init, (drm_r128_init_t __user *) data,
+				 sizeof(init));
 
-	switch ( init.func ) {
+	switch (init.func) {
 	case R128_INIT_CCE:
-		return r128_do_init_cce( dev, &init );
+		return r128_do_init_cce(dev, &init);
 	case R128_CLEANUP_CCE:
-		return r128_do_cleanup_cce( dev );
+		return r128_do_cleanup_cce(dev);
 	}
 
 	return DRM_ERR(EINVAL);
 }
 
-int r128_cce_start( DRM_IOCTL_ARGS )
+int r128_cce_start(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_r128_private_t *dev_priv = dev->dev_private;
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	if ( dev_priv->cce_running || dev_priv->cce_mode == R128_PM4_NONPM4 ) {
-		DRM_DEBUG( "%s while CCE running\n", __FUNCTION__ );
+	if (dev_priv->cce_running || dev_priv->cce_mode == R128_PM4_NONPM4) {
+		DRM_DEBUG("%s while CCE running\n", __FUNCTION__);
 		return 0;
 	}
 
-	r128_do_cce_start( dev_priv );
+	r128_do_cce_start(dev_priv);
 
 	return 0;
 }
@@ -661,61 +661,63 @@ int r128_cce_start( DRM_IOCTL_ARGS )
 /* Stop the CCE.  The engine must have been idled before calling this
  * routine.
  */
-int r128_cce_stop( DRM_IOCTL_ARGS )
+int r128_cce_stop(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_r128_private_t *dev_priv = dev->dev_private;
 	drm_r128_cce_stop_t stop;
 	int ret;
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	DRM_COPY_FROM_USER_IOCTL(stop, (drm_r128_cce_stop_t __user *)data, sizeof(stop) );
+	DRM_COPY_FROM_USER_IOCTL(stop, (drm_r128_cce_stop_t __user *) data,
+				 sizeof(stop));
 
 	/* Flush any pending CCE commands.  This ensures any outstanding
 	 * commands are exectuted by the engine before we turn it off.
 	 */
-	if ( stop.flush ) {
-		r128_do_cce_flush( dev_priv );
+	if (stop.flush) {
+		r128_do_cce_flush(dev_priv);
 	}
 
 	/* If we fail to make the engine go idle, we return an error
 	 * code so that the DRM ioctl wrapper can try again.
 	 */
-	if ( stop.idle ) {
-		ret = r128_do_cce_idle( dev_priv );
-		if ( ret ) return ret;
+	if (stop.idle) {
+		ret = r128_do_cce_idle(dev_priv);
+		if (ret)
+			return ret;
 	}
 
 	/* Finally, we can turn off the CCE.  If the engine isn't idle,
 	 * we will get some dropped triangles as they won't be fully
 	 * rendered before the CCE is shut down.
 	 */
-	r128_do_cce_stop( dev_priv );
+	r128_do_cce_stop(dev_priv);
 
 	/* Reset the engine */
-	r128_do_engine_reset( dev );
+	r128_do_engine_reset(dev);
 
 	return 0;
 }
 
 /* Just reset the CCE ring.  Called as part of an X Server engine reset.
  */
-int r128_cce_reset( DRM_IOCTL_ARGS )
+int r128_cce_reset(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_r128_private_t *dev_priv = dev->dev_private;
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	if ( !dev_priv ) {
-		DRM_DEBUG( "%s called before init done\n", __FUNCTION__ );
+	if (!dev_priv) {
+		DRM_DEBUG("%s called before init done\n", __FUNCTION__);
 		return DRM_ERR(EINVAL);
 	}
 
-	r128_do_cce_reset( dev_priv );
+	r128_do_cce_reset(dev_priv);
 
 	/* The CCE is no longer running after an engine reset */
 	dev_priv->cce_running = 0;
@@ -723,37 +725,36 @@ int r128_cce_reset( DRM_IOCTL_ARGS )
 	return 0;
 }
 
-int r128_cce_idle( DRM_IOCTL_ARGS )
+int r128_cce_idle(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_r128_private_t *dev_priv = dev->dev_private;
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	if ( dev_priv->cce_running ) {
-		r128_do_cce_flush( dev_priv );
+	if (dev_priv->cce_running) {
+		r128_do_cce_flush(dev_priv);
 	}
 
-	return r128_do_cce_idle( dev_priv );
+	return r128_do_cce_idle(dev_priv);
 }
 
-int r128_engine_reset( DRM_IOCTL_ARGS )
+int r128_engine_reset(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	return r128_do_engine_reset( dev );
+	return r128_do_engine_reset(dev);
 }
 
-int r128_fullscreen( DRM_IOCTL_ARGS )
+int r128_fullscreen(DRM_IOCTL_ARGS)
 {
 	return DRM_ERR(EINVAL);
 }
 
-
 /* ================================================================
  * Freelist management
  */
@@ -761,7 +762,7 @@ int r128_fullscreen( DRM_IOCTL_ARGS )
 #define R128_BUFFER_FREE	0
 
 #if 0
-static int r128_freelist_init( drm_device_t *dev )
+static int r128_freelist_init(drm_device_t * dev)
 {
 	drm_device_dma_t *dma = dev->dma;
 	drm_r128_private_t *dev_priv = dev->dev_private;
@@ -770,27 +771,26 @@ static int r128_freelist_init( drm_devic
 	drm_r128_freelist_t *entry;
 	int i;
 
-	dev_priv->head = drm_alloc( sizeof(drm_r128_freelist_t),
-				     DRM_MEM_DRIVER );
-	if ( dev_priv->head == NULL )
+	dev_priv->head = drm_alloc(sizeof(drm_r128_freelist_t), DRM_MEM_DRIVER);
+	if (dev_priv->head == NULL)
 		return DRM_ERR(ENOMEM);
 
-	memset( dev_priv->head, 0, sizeof(drm_r128_freelist_t) );
+	memset(dev_priv->head, 0, sizeof(drm_r128_freelist_t));
 	dev_priv->head->age = R128_BUFFER_USED;
 
-	for ( i = 0 ; i < dma->buf_count ; i++ ) {
+	for (i = 0; i < dma->buf_count; i++) {
 		buf = dma->buflist[i];
 		buf_priv = buf->dev_private;
 
-		entry = drm_alloc( sizeof(drm_r128_freelist_t),
-				    DRM_MEM_DRIVER );
-		if ( !entry ) return DRM_ERR(ENOMEM);
+		entry = drm_alloc(sizeof(drm_r128_freelist_t), DRM_MEM_DRIVER);
+		if (!entry)
+			return DRM_ERR(ENOMEM);
 
 		entry->age = R128_BUFFER_FREE;
 		entry->buf = buf;
 		entry->prev = dev_priv->head;
 		entry->next = dev_priv->head->next;
-		if ( !entry->next )
+		if (!entry->next)
 			dev_priv->tail = entry;
 
 		buf_priv->discard = 0;
@@ -799,7 +799,7 @@ static int r128_freelist_init( drm_devic
 
 		dev_priv->head->next = entry;
 
-		if ( dev_priv->head->next )
+		if (dev_priv->head->next)
 			dev_priv->head->next->prev = entry;
 	}
 
@@ -808,7 +808,7 @@ static int r128_freelist_init( drm_devic
 }
 #endif
 
-static drm_buf_t *r128_freelist_get( drm_device_t *dev )
+static drm_buf_t *r128_freelist_get(drm_device_t * dev)
 {
 	drm_device_dma_t *dma = dev->dma;
 	drm_r128_private_t *dev_priv = dev->dev_private;
@@ -818,20 +818,20 @@ static drm_buf_t *r128_freelist_get( drm
 
 	/* FIXME: Optimize -- use freelist code */
 
-	for ( i = 0 ; i < dma->buf_count ; i++ ) {
+	for (i = 0; i < dma->buf_count; i++) {
 		buf = dma->buflist[i];
 		buf_priv = buf->dev_private;
-		if ( buf->filp == 0 )
+		if (buf->filp == 0)
 			return buf;
 	}
 
-	for ( t = 0 ; t < dev_priv->usec_timeout ; t++ ) {
-		u32 done_age = R128_READ( R128_LAST_DISPATCH_REG );
+	for (t = 0; t < dev_priv->usec_timeout; t++) {
+		u32 done_age = R128_READ(R128_LAST_DISPATCH_REG);
 
-		for ( i = 0 ; i < dma->buf_count ; i++ ) {
+		for (i = 0; i < dma->buf_count; i++) {
 			buf = dma->buflist[i];
 			buf_priv = buf->dev_private;
-			if ( buf->pending && buf_priv->age <= done_age ) {
+			if (buf->pending && buf_priv->age <= done_age) {
 				/* The buffer has been processed, so it
 				 * can now be used.
 				 */
@@ -839,63 +839,63 @@ static drm_buf_t *r128_freelist_get( drm
 				return buf;
 			}
 		}
-		DRM_UDELAY( 1 );
+		DRM_UDELAY(1);
 	}
 
-	DRM_DEBUG( "returning NULL!\n" );
+	DRM_DEBUG("returning NULL!\n");
 	return NULL;
 }
 
-void r128_freelist_reset( drm_device_t *dev )
+void r128_freelist_reset(drm_device_t * dev)
 {
 	drm_device_dma_t *dma = dev->dma;
 	int i;
 
-	for ( i = 0 ; i < dma->buf_count ; i++ ) {
+	for (i = 0; i < dma->buf_count; i++) {
 		drm_buf_t *buf = dma->buflist[i];
 		drm_r128_buf_priv_t *buf_priv = buf->dev_private;
 		buf_priv->age = 0;
 	}
 }
 
-
 /* ================================================================
  * CCE command submission
  */
 
-int r128_wait_ring( drm_r128_private_t *dev_priv, int n )
+int r128_wait_ring(drm_r128_private_t * dev_priv, int n)
 {
 	drm_r128_ring_buffer_t *ring = &dev_priv->ring;
 	int i;
 
-	for ( i = 0 ; i < dev_priv->usec_timeout ; i++ ) {
-		r128_update_ring_snapshot( dev_priv );
-		if ( ring->space >= n )
+	for (i = 0; i < dev_priv->usec_timeout; i++) {
+		r128_update_ring_snapshot(dev_priv);
+		if (ring->space >= n)
 			return 0;
-		DRM_UDELAY( 1 );
+		DRM_UDELAY(1);
 	}
 
 	/* FIXME: This is being ignored... */
-	DRM_ERROR( "failed!\n" );
+	DRM_ERROR("failed!\n");
 	return DRM_ERR(EBUSY);
 }
 
-static int r128_cce_get_buffers( DRMFILE filp, drm_device_t *dev, drm_dma_t *d )
+static int r128_cce_get_buffers(DRMFILE filp, drm_device_t * dev, drm_dma_t * d)
 {
 	int i;
 	drm_buf_t *buf;
 
-	for ( i = d->granted_count ; i < d->request_count ; i++ ) {
-		buf = r128_freelist_get( dev );
-		if ( !buf ) return DRM_ERR(EAGAIN);
+	for (i = d->granted_count; i < d->request_count; i++) {
+		buf = r128_freelist_get(dev);
+		if (!buf)
+			return DRM_ERR(EAGAIN);
 
 		buf->filp = filp;
 
-		if ( DRM_COPY_TO_USER( &d->request_indices[i], &buf->idx,
-				   sizeof(buf->idx) ) )
+		if (DRM_COPY_TO_USER(&d->request_indices[i], &buf->idx,
+				     sizeof(buf->idx)))
 			return DRM_ERR(EFAULT);
-		if ( DRM_COPY_TO_USER( &d->request_sizes[i], &buf->total,
-				   sizeof(buf->total) ) )
+		if (DRM_COPY_TO_USER(&d->request_sizes[i], &buf->total,
+				     sizeof(buf->total)))
 			return DRM_ERR(EFAULT);
 
 		d->granted_count++;
@@ -903,7 +903,7 @@ static int r128_cce_get_buffers( DRMFILE
 	return 0;
 }
 
-int r128_cce_buffers( DRM_IOCTL_ARGS )
+int r128_cce_buffers(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_device_dma_t *dma = dev->dma;
@@ -911,33 +911,33 @@ int r128_cce_buffers( DRM_IOCTL_ARGS )
 	drm_dma_t __user *argp = (void __user *)data;
 	drm_dma_t d;
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	DRM_COPY_FROM_USER_IOCTL( d, argp, sizeof(d) );
+	DRM_COPY_FROM_USER_IOCTL(d, argp, sizeof(d));
 
 	/* Please don't send us buffers.
 	 */
-	if ( d.send_count != 0 ) {
-		DRM_ERROR( "Process %d trying to send %d buffers via drmDMA\n",
-			   DRM_CURRENTPID, d.send_count );
+	if (d.send_count != 0) {
+		DRM_ERROR("Process %d trying to send %d buffers via drmDMA\n",
+			  DRM_CURRENTPID, d.send_count);
 		return DRM_ERR(EINVAL);
 	}
 
 	/* We'll send you buffers.
 	 */
-	if ( d.request_count < 0 || d.request_count > dma->buf_count ) {
-		DRM_ERROR( "Process %d trying to get %d buffers (of %d max)\n",
-			   DRM_CURRENTPID, d.request_count, dma->buf_count );
+	if (d.request_count < 0 || d.request_count > dma->buf_count) {
+		DRM_ERROR("Process %d trying to get %d buffers (of %d max)\n",
+			  DRM_CURRENTPID, d.request_count, dma->buf_count);
 		return DRM_ERR(EINVAL);
 	}
 
 	d.granted_count = 0;
 
-	if ( d.request_count ) {
-		ret = r128_cce_get_buffers( filp, dev, &d );
+	if (d.request_count) {
+		ret = r128_cce_get_buffers(filp, dev, &d);
 	}
 
-	DRM_COPY_TO_USER_IOCTL(argp, d, sizeof(d) );
+	DRM_COPY_TO_USER_IOCTL(argp, d, sizeof(d));
 
 	return ret;
 }
diff -purN linux-2.6.12.orig/drivers/char/drm/r128_drm.h linux-2.6.12/drivers/char/drm/r128_drm.h
--- linux-2.6.12.orig/drivers/char/drm/r128_drm.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/r128_drm.h	2005-07-05 08:37:49.000000000 +0200
@@ -93,7 +93,7 @@
 #define R128_MAX_TEXTURE_LEVELS		11
 #define R128_MAX_TEXTURE_UNITS		2
 
-#endif /* __R128_SAREA_DEFINES__ */
+#endif				/* __R128_SAREA_DEFINES__ */
 
 typedef struct {
 	/* Context state - can be written in one large chunk */
@@ -140,7 +140,6 @@ typedef struct {
 	unsigned int tex_border_color;
 } drm_r128_texture_regs_t;
 
-
 typedef struct drm_r128_sarea {
 	/* The channel for communication of state information to the kernel
 	 * on firing a vertex buffer.
@@ -161,14 +160,13 @@ typedef struct drm_r128_sarea {
 	unsigned int last_frame;
 	unsigned int last_dispatch;
 
-	drm_tex_region_t tex_list[R128_NR_TEX_HEAPS][R128_NR_TEX_REGIONS+1];
+	drm_tex_region_t tex_list[R128_NR_TEX_HEAPS][R128_NR_TEX_REGIONS + 1];
 	unsigned int tex_age[R128_NR_TEX_HEAPS];
 	int ctx_owner;
-	int pfAllowPageFlip;        /* number of 3d windows (0,1,2 or more) */
-	int pfCurrentPage;	    /* which buffer is being displayed? */
+	int pfAllowPageFlip;	/* number of 3d windows (0,1,2 or more) */
+	int pfCurrentPage;	/* which buffer is being displayed? */
 } drm_r128_sarea_t;
 
-
 /* WARNING: If you change any of these defines, make sure to change the
  * defines in the Xserver file (xf86drmR128.h)
  */
@@ -220,7 +218,7 @@ typedef struct drm_r128_sarea {
 
 typedef struct drm_r128_init {
 	enum {
-		R128_INIT_CCE    = 0x01,
+		R128_INIT_CCE = 0x01,
 		R128_CLEANUP_CCE = 0x02
 	} func;
 #if CONFIG_XFREE86_VERSION < XFREE86_VERSION(4,1,0,0)
@@ -278,9 +276,9 @@ typedef struct drm_r128_clear {
 
 typedef struct drm_r128_vertex {
 	int prim;
-	int idx;			/* Index of vertex buffer */
-	int count;			/* Number of vertices in buffer */
-	int discard;			/* Client finished with buffer? */
+	int idx;		/* Index of vertex buffer */
+	int count;		/* Number of vertices in buffer */
+	int discard;		/* Client finished with buffer? */
 } drm_r128_vertex_t;
 
 typedef struct drm_r128_indices {
@@ -288,7 +286,7 @@ typedef struct drm_r128_indices {
 	int idx;
 	int start;
 	int end;
-	int discard;			/* Client finished with buffer? */
+	int discard;		/* Client finished with buffer? */
 } drm_r128_indices_t;
 
 typedef struct drm_r128_blit {
@@ -302,10 +300,10 @@ typedef struct drm_r128_blit {
 
 typedef struct drm_r128_depth {
 	enum {
-		R128_WRITE_SPAN		= 0x01,
-		R128_WRITE_PIXELS	= 0x02,
-		R128_READ_SPAN		= 0x03,
-		R128_READ_PIXELS	= 0x04
+		R128_WRITE_SPAN = 0x01,
+		R128_WRITE_PIXELS = 0x02,
+		R128_READ_SPAN = 0x03,
+		R128_READ_PIXELS = 0x04
 	} func;
 	int n;
 	int __user *x;
@@ -327,13 +325,13 @@ typedef struct drm_r128_indirect {
 
 typedef struct drm_r128_fullscreen {
 	enum {
-		R128_INIT_FULLSCREEN    = 0x01,
+		R128_INIT_FULLSCREEN = 0x01,
 		R128_CLEANUP_FULLSCREEN = 0x02
 	} func;
 } drm_r128_fullscreen_t;
 
 /* 2.3: An ioctl to get parameters that aren't available to the 3d
- * client any other way.  
+ * client any other way.
  */
 #define R128_PARAM_IRQ_NR            1
 
diff -purN linux-2.6.12.orig/drivers/char/drm/r128_drv.c linux-2.6.12/drivers/char/drm/r128_drv.c
--- linux-2.6.12.orig/drivers/char/drm/r128_drv.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/r128_drv.c	2005-07-05 08:37:27.000000000 +0200
@@ -37,30 +37,28 @@
 
 #include "drm_pciids.h"
 
-static int postinit( struct drm_device *dev, unsigned long flags )
+static int postinit(struct drm_device *dev, unsigned long flags)
 {
-	DRM_INFO( "Initialized %s %d.%d.%d %s on minor %d: %s\n",
-		DRIVER_NAME,
-		DRIVER_MAJOR,
-		DRIVER_MINOR,
-		DRIVER_PATCHLEVEL,
-		DRIVER_DATE,
-		dev->primary.minor,
-		pci_pretty_name(dev->pdev)
-		);
+	DRM_INFO("Initialized %s %d.%d.%d %s on minor %d: %s\n",
+		 DRIVER_NAME,
+		 DRIVER_MAJOR,
+		 DRIVER_MINOR,
+		 DRIVER_PATCHLEVEL,
+		 DRIVER_DATE, dev->primary.minor, pci_pretty_name(dev->pdev)
+	    );
 	return 0;
 }
 
-static int version( drm_version_t *version )
+static int version(drm_version_t * version)
 {
 	int len;
 
 	version->version_major = DRIVER_MAJOR;
 	version->version_minor = DRIVER_MINOR;
 	version->version_patchlevel = DRIVER_PATCHLEVEL;
-	DRM_COPY( version->name, DRIVER_NAME );
-	DRM_COPY( version->date, DRIVER_DATE );
-	DRM_COPY( version->desc, DRIVER_DESC );
+	DRM_COPY(version->name, DRIVER_NAME);
+	DRM_COPY(version->date, DRIVER_DATE);
+	DRM_COPY(version->desc, DRIVER_DESC);
 	return 0;
 }
 
@@ -71,8 +69,12 @@ static struct pci_device_id pciidlist[] 
 extern drm_ioctl_desc_t r128_ioctls[];
 extern int r128_max_ioctl;
 
+static int probe(struct pci_dev *pdev, const struct pci_device_id *ent);
 static struct drm_driver driver = {
-	.driver_features = DRIVER_USE_AGP | DRIVER_USE_MTRR | DRIVER_PCI_DMA | DRIVER_SG | DRIVER_HAVE_DMA | DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED | DRIVER_IRQ_VBL,
+	.driver_features =
+	    DRIVER_USE_AGP | DRIVER_USE_MTRR | DRIVER_PCI_DMA | DRIVER_SG |
+	    DRIVER_HAVE_DMA | DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED |
+	    DRIVER_IRQ_VBL,
 	.dev_priv_size = sizeof(drm_r128_buf_priv_t),
 	.prerelease = r128_driver_prerelease,
 	.pretakedown = r128_driver_pretakedown,
@@ -96,17 +98,29 @@ static struct drm_driver driver = {
 		.mmap = drm_mmap,
 		.poll = drm_poll,
 		.fasync = drm_fasync,
-	},
+#ifdef CONFIG_COMPAT
+		.compat_ioctl = r128_compat_ioctl,
+#endif
+		},
 	.pci_driver = {
-		.name          = DRIVER_NAME,
-		.id_table      = pciidlist,
+		.name = DRIVER_NAME,
+		.id_table = pciidlist,
+		.probe = probe,
+		.remove = __devexit_p(drm_cleanup_pci),
 	}
 };
 
+static int probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	return drm_get_dev(pdev, ent, &driver);
+}
+
+
 static int __init r128_init(void)
 {
 	driver.num_ioctls = r128_max_ioctl;
-	return drm_init(&driver);
+
+	return drm_init(&driver, pciidlist);
 }
 
 static void __exit r128_exit(void)
@@ -117,6 +131,6 @@ static void __exit r128_exit(void)
 module_init(r128_init);
 module_exit(r128_exit);
 
-MODULE_AUTHOR( DRIVER_AUTHOR );
-MODULE_DESCRIPTION( DRIVER_DESC );
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL and additional rights");
diff -purN linux-2.6.12.orig/drivers/char/drm/r128_drv.h linux-2.6.12/drivers/char/drm/r128_drv.h
--- linux-2.6.12.orig/drivers/char/drm/r128_drv.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/r128_drv.h	2005-07-05 08:37:49.000000000 +0200
@@ -52,14 +52,13 @@
 #define DRIVER_MINOR		5
 #define DRIVER_PATCHLEVEL	0
 
-
 #define GET_RING_HEAD(dev_priv)		R128_READ( R128_PM4_BUFFER_DL_RPTR )
 
 typedef struct drm_r128_freelist {
-   	unsigned int age;
-   	drm_buf_t *buf;
-   	struct drm_r128_freelist *next;
-   	struct drm_r128_freelist *prev;
+	unsigned int age;
+	drm_buf_t *buf;
+	struct drm_r128_freelist *next;
+	struct drm_r128_freelist *prev;
 } drm_r128_freelist_t;
 
 typedef struct drm_r128_ring_buffer {
@@ -83,8 +82,8 @@ typedef struct drm_r128_private {
 	int cce_fifo_size;
 	int cce_running;
 
-   	drm_r128_freelist_t *head;
-   	drm_r128_freelist_t *tail;
+	drm_r128_freelist_t *head;
+	drm_r128_freelist_t *tail;
 
 	int usec_timeout;
 	int is_pci;
@@ -127,34 +126,37 @@ typedef struct drm_r128_buf_priv {
 	int prim;
 	int discard;
 	int dispatched;
-   	drm_r128_freelist_t *list_entry;
+	drm_r128_freelist_t *list_entry;
 } drm_r128_buf_priv_t;
 
 				/* r128_cce.c */
-extern int r128_cce_init( DRM_IOCTL_ARGS );
-extern int r128_cce_start( DRM_IOCTL_ARGS );
-extern int r128_cce_stop( DRM_IOCTL_ARGS );
-extern int r128_cce_reset( DRM_IOCTL_ARGS );
-extern int r128_cce_idle( DRM_IOCTL_ARGS );
-extern int r128_engine_reset( DRM_IOCTL_ARGS );
-extern int r128_fullscreen( DRM_IOCTL_ARGS );
-extern int r128_cce_buffers( DRM_IOCTL_ARGS );
-
-extern void r128_freelist_reset( drm_device_t *dev );
-
-extern int r128_wait_ring( drm_r128_private_t *dev_priv, int n );
-
-extern int r128_do_cce_idle( drm_r128_private_t *dev_priv );
-extern int r128_do_cleanup_cce( drm_device_t *dev );
-
-extern int r128_driver_vblank_wait(drm_device_t *dev, unsigned int *sequence);
-
-extern irqreturn_t r128_driver_irq_handler( DRM_IRQ_ARGS );
-extern void r128_driver_irq_preinstall( drm_device_t *dev );
-extern void r128_driver_irq_postinstall( drm_device_t *dev );
-extern void r128_driver_irq_uninstall( drm_device_t *dev );
-extern void r128_driver_pretakedown(drm_device_t *dev);
-extern void r128_driver_prerelease(drm_device_t *dev, DRMFILE filp);
+extern int r128_cce_init(DRM_IOCTL_ARGS);
+extern int r128_cce_start(DRM_IOCTL_ARGS);
+extern int r128_cce_stop(DRM_IOCTL_ARGS);
+extern int r128_cce_reset(DRM_IOCTL_ARGS);
+extern int r128_cce_idle(DRM_IOCTL_ARGS);
+extern int r128_engine_reset(DRM_IOCTL_ARGS);
+extern int r128_fullscreen(DRM_IOCTL_ARGS);
+extern int r128_cce_buffers(DRM_IOCTL_ARGS);
+
+extern void r128_freelist_reset(drm_device_t * dev);
+
+extern int r128_wait_ring(drm_r128_private_t * dev_priv, int n);
+
+extern int r128_do_cce_idle(drm_r128_private_t * dev_priv);
+extern int r128_do_cleanup_cce(drm_device_t * dev);
+
+extern int r128_driver_vblank_wait(drm_device_t * dev, unsigned int *sequence);
+
+extern irqreturn_t r128_driver_irq_handler(DRM_IRQ_ARGS);
+extern void r128_driver_irq_preinstall(drm_device_t * dev);
+extern void r128_driver_irq_postinstall(drm_device_t * dev);
+extern void r128_driver_irq_uninstall(drm_device_t * dev);
+extern void r128_driver_pretakedown(drm_device_t * dev);
+extern void r128_driver_prerelease(drm_device_t * dev, DRMFILE filp);
+
+extern long r128_compat_ioctl(struct file *filp, unsigned int cmd,
+			      unsigned long arg);
 
 /* Register definitions, register access macros and drmAddMap constants
  * for Rage 128 kernel driver.
@@ -263,7 +265,6 @@ extern void r128_driver_prerelease(drm_d
 #	define R128_EVENT_CRTC_OFFSET		(1 << 0)
 #define R128_WINDOW_XY_OFFSET		0x1bcc
 
-
 /* CCE registers
  */
 #define R128_PM4_BUFFER_OFFSET		0x0700
@@ -314,7 +315,6 @@ extern void r128_driver_prerelease(drm_d
 #define R128_PM4_FIFO_DATA_EVEN		0x1000
 #define R128_PM4_FIFO_DATA_ODD		0x1004
 
-
 /* CCE command packets
  */
 #define R128_CCE_PACKET0		0x00000000
@@ -392,7 +392,6 @@ do {									\
 	R128_WRITE(R128_CLOCK_CNTL_DATA, (val));			\
 } while (0)
 
-
 #define CCE_PACKET0( reg, n )		(R128_CCE_PACKET0 |		\
 					 ((n) << 16) | ((reg) >> 2))
 #define CCE_PACKET1( reg0, reg1 )	(R128_CCE_PACKET1 |		\
@@ -401,13 +400,11 @@ do {									\
 #define CCE_PACKET3( pkt, n )		(R128_CCE_PACKET3 |		\
 					 (pkt) | ((n) << 16))
 
-
-static __inline__ void
-r128_update_ring_snapshot( drm_r128_private_t *dev_priv )
+static __inline__ void r128_update_ring_snapshot(drm_r128_private_t * dev_priv)
 {
 	drm_r128_ring_buffer_t *ring = &dev_priv->ring;
-	ring->space = (GET_RING_HEAD( dev_priv ) - ring->tail) * sizeof(u32);
-	if ( ring->space <= 0 )
+	ring->space = (GET_RING_HEAD(dev_priv) - ring->tail) * sizeof(u32);
+	if (ring->space <= 0)
 		ring->space += ring->size;
 }
 
@@ -448,7 +445,6 @@ do {									\
 	OUT_RING( R128_EVENT_CRTC_OFFSET );				\
 } while (0)
 
-
 /* ================================================================
  * Ring control
  */
@@ -518,4 +514,4 @@ do {									\
 	write &= tail_mask;						\
 } while (0)
 
-#endif /* __R128_DRV_H__ */
+#endif				/* __R128_DRV_H__ */
diff -purN linux-2.6.12.orig/drivers/char/drm/r128_ioc32.c linux-2.6.12/drivers/char/drm/r128_ioc32.c
--- linux-2.6.12.orig/drivers/char/drm/r128_ioc32.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/drm/r128_ioc32.c	2005-07-05 08:37:27.000000000 +0200
@@ -0,0 +1,219 @@
+/**
+ * \file r128_ioc32.c
+ *
+ * 32-bit ioctl compatibility routines for the R128 DRM.
+ *
+ * \author Dave Airlie <airlied@linux.ie> with code from patches by Egbert Eich
+ *
+ * Copyright (C) Paul Mackerras 2005
+ * Copyright (C) Egbert Eich 2003,2004
+ * Copyright (C) Dave Airlie 2005
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+#include <linux/compat.h>
+#include <linux/ioctl32.h>
+
+#include "drmP.h"
+#include "drm.h"
+#include "r128_drm.h"
+
+typedef struct drm_r128_init32 {
+	int func;
+	unsigned int sarea_priv_offset;
+	int is_pci;
+	int cce_mode;
+	int cce_secure;
+	int ring_size;
+	int usec_timeout;
+
+	unsigned int fb_bpp;
+	unsigned int front_offset, front_pitch;
+	unsigned int back_offset, back_pitch;
+	unsigned int depth_bpp;
+	unsigned int depth_offset, depth_pitch;
+	unsigned int span_offset;
+
+	unsigned int fb_offset;
+	unsigned int mmio_offset;
+	unsigned int ring_offset;
+	unsigned int ring_rptr_offset;
+	unsigned int buffers_offset;
+	unsigned int agp_textures_offset;
+} drm_r128_init32_t;
+
+static int compat_r128_init(struct file *file, unsigned int cmd,
+			    unsigned long arg)
+{
+	drm_r128_init32_t init32;
+	drm_r128_init_t __user *init;
+	
+	if (copy_from_user(&init32, (void __user *)arg, sizeof(init32)))
+		return -EFAULT;
+	
+	init = compat_alloc_user_space(sizeof(*init));
+	if (!access_ok(VERIFY_WRITE, init, sizeof(*init))
+	    || __put_user(init32.func, &init->func)
+	    || __put_user(init32.sarea_priv_offset, &init->sarea_priv_offset)
+	    || __put_user(init32.is_pci, &init->is_pci)
+	    || __put_user(init32.cce_mode, &init->cce_mode)
+	    || __put_user(init32.cce_secure, &init->cce_secure)
+	    || __put_user(init32.ring_size, &init->ring_size)
+	    || __put_user(init32.usec_timeout, &init->usec_timeout)
+	    || __put_user(init32.fb_bpp, &init->fb_bpp)
+	    || __put_user(init32.front_offset, &init->front_offset)
+	    || __put_user(init32.front_pitch, &init->front_pitch)
+	    || __put_user(init32.back_offset, &init->back_offset)
+	    || __put_user(init32.back_pitch, &init->back_pitch)
+	    || __put_user(init32.depth_bpp, &init->depth_bpp)
+	    || __put_user(init32.depth_offset, &init->depth_offset)
+	    || __put_user(init32.depth_pitch, &init->depth_pitch)
+	    || __put_user(init32.span_offset, &init->span_offset)
+	    || __put_user(init32.fb_offset, &init->fb_offset)
+	    || __put_user(init32.mmio_offset, &init->mmio_offset)
+	    || __put_user(init32.ring_offset, &init->ring_offset)
+	    || __put_user(init32.ring_rptr_offset, &init->ring_rptr_offset)
+	    || __put_user(init32.buffers_offset, &init->buffers_offset)
+	    || __put_user(init32.agp_textures_offset, &init->agp_textures_offset))
+		return -EFAULT;
+	
+	return drm_ioctl(file->f_dentry->d_inode, file,
+			 DRM_IOCTL_R128_INIT, (unsigned long)init);
+}
+
+
+typedef struct drm_r128_depth32 {
+	int func;
+	int n;
+	u32 x;
+	u32 y;
+	u32 buffer;
+	u32 mask;
+} drm_r128_depth32_t;
+
+static int compat_r128_depth(struct file *file, unsigned int cmd,
+			     unsigned long arg)
+{
+	drm_r128_depth32_t depth32;
+	drm_r128_depth_t __user *depth;
+
+	if (copy_from_user(&depth32, (void __user *)arg, sizeof(depth32)))
+		return -EFAULT;
+
+	depth = compat_alloc_user_space(sizeof(*depth));
+	if (!access_ok(VERIFY_WRITE, depth, sizeof(*depth))
+	    || __put_user(depth32.func, &depth->func)
+	    || __put_user(depth32.n, &depth->n)
+	    || __put_user((int __user *)(unsigned long)depth32.x, &depth->x)
+	    || __put_user((int __user *)(unsigned long)depth32.y, &depth->y)
+	    || __put_user((unsigned int __user *)(unsigned long)depth32.buffer, &depth->buffer)
+	    || __put_user((unsigned char __user *)(unsigned long)depth32.mask, &depth->mask))
+		return -EFAULT;
+	
+	return drm_ioctl(file->f_dentry->d_inode, file,
+			 DRM_IOCTL_R128_DEPTH, (unsigned long)depth);	
+	
+}
+
+typedef struct drm_r128_stipple32 {
+	u32 mask;
+} drm_r128_stipple32_t;
+
+static int compat_r128_stipple(struct file *file, unsigned int cmd,
+			       unsigned long arg)
+{
+	drm_r128_stipple32_t stipple32;
+	drm_r128_stipple_t __user *stipple;
+
+	if (copy_from_user(&stipple32, (void __user *)arg, sizeof(stipple32)))
+		return -EFAULT;
+
+	stipple = compat_alloc_user_space(sizeof(*stipple));
+	if (!access_ok(VERIFY_WRITE, stipple, sizeof(*stipple))
+	    || __put_user((unsigned int __user *)(unsigned long)stipple32.mask, &stipple->mask))
+		return -EFAULT;
+
+	return drm_ioctl(file->f_dentry->d_inode, file,
+			 DRM_IOCTL_R128_STIPPLE, (unsigned long)stipple);
+}
+
+typedef struct drm_r128_getparam32 {
+	int param;
+	u32 value;
+} drm_r128_getparam32_t;
+
+static int compat_r128_getparam(struct file *file, unsigned int cmd,
+				unsigned long arg)
+{
+	drm_r128_getparam32_t getparam32;
+	drm_r128_getparam_t __user *getparam;
+
+	if (copy_from_user(&getparam32, (void __user *)arg, sizeof(getparam32)))
+		return -EFAULT;
+
+	getparam = compat_alloc_user_space(sizeof(*getparam));
+	if (!access_ok(VERIFY_WRITE, getparam, sizeof(*getparam))
+	    || __put_user(getparam32.param, &getparam->param)
+	    || __put_user((void __user *)(unsigned long)getparam32.value, &getparam->value))
+		return -EFAULT;
+	
+	return drm_ioctl(file->f_dentry->d_inode, file,
+			 DRM_IOCTL_R128_GETPARAM, (unsigned long)getparam);
+}
+
+drm_ioctl_compat_t *r128_compat_ioctls[] = {
+	[DRM_R128_INIT] = compat_r128_init,
+	[DRM_R128_DEPTH] = compat_r128_depth,
+	[DRM_R128_STIPPLE] = compat_r128_stipple,
+	[DRM_R128_GETPARAM] = compat_r128_getparam,
+};
+
+/**
+ * Called whenever a 32-bit process running under a 64-bit kernel
+ * performs an ioctl on /dev/dri/card<n>.
+ *
+ * \param filp file pointer.
+ * \param cmd command.
+ * \param arg user argument.
+ * \return zero on success or negative number on failure.
+ */
+long r128_compat_ioctl(struct file *filp, unsigned int cmd,
+			 unsigned long arg)
+{
+	unsigned int nr = DRM_IOCTL_NR(cmd);
+	drm_ioctl_compat_t *fn = NULL;
+	int ret;
+
+	if (nr < DRM_COMMAND_BASE)
+		return drm_compat_ioctl(filp, cmd, arg);
+
+	if (nr < DRM_COMMAND_BASE + DRM_ARRAY_SIZE(r128_compat_ioctls))
+		fn = r128_compat_ioctls[nr - DRM_COMMAND_BASE];
+
+	lock_kernel();		/* XXX for now */
+	if (fn != NULL)
+		ret = (*fn)(filp, cmd, arg);
+	else
+		ret = drm_ioctl(filp->f_dentry->d_inode, filp, cmd, arg);
+	unlock_kernel();
+
+	return ret;
+}
diff -purN linux-2.6.12.orig/drivers/char/drm/r128_irq.c linux-2.6.12/drivers/char/drm/r128_irq.c
--- linux-2.6.12.orig/drivers/char/drm/r128_irq.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/r128_irq.c	2005-07-05 08:37:47.000000000 +0200
@@ -1,7 +1,7 @@
 /* r128_irq.c -- IRQ handling for radeon -*- linux-c -*-
  *
  * Copyright (C) The Weather Channel, Inc.  2002.  All Rights Reserved.
- * 
+ *
  * The Weather Channel (TM) funded Tungsten Graphics to develop the
  * initial release of the Radeon 8500 driver under the XFree86 license.
  * This notice must be preserved.
@@ -35,68 +35,67 @@
 #include "r128_drm.h"
 #include "r128_drv.h"
 
-irqreturn_t r128_driver_irq_handler( DRM_IRQ_ARGS )
+irqreturn_t r128_driver_irq_handler(DRM_IRQ_ARGS)
 {
 	drm_device_t *dev = (drm_device_t *) arg;
-	drm_r128_private_t *dev_priv = 
-	   (drm_r128_private_t *)dev->dev_private;
+	drm_r128_private_t *dev_priv = (drm_r128_private_t *) dev->dev_private;
 	int status;
 
-	status = R128_READ( R128_GEN_INT_STATUS );
-	
+	status = R128_READ(R128_GEN_INT_STATUS);
+
 	/* VBLANK interrupt */
-	if ( status & R128_CRTC_VBLANK_INT ) {
-		R128_WRITE( R128_GEN_INT_STATUS, R128_CRTC_VBLANK_INT_AK );
+	if (status & R128_CRTC_VBLANK_INT) {
+		R128_WRITE(R128_GEN_INT_STATUS, R128_CRTC_VBLANK_INT_AK);
 		atomic_inc(&dev->vbl_received);
 		DRM_WAKEUP(&dev->vbl_queue);
-		drm_vbl_send_signals( dev );
+		drm_vbl_send_signals(dev);
 		return IRQ_HANDLED;
 	}
 	return IRQ_NONE;
 }
 
-int r128_driver_vblank_wait(drm_device_t *dev, unsigned int *sequence)
+int r128_driver_vblank_wait(drm_device_t * dev, unsigned int *sequence)
 {
 	unsigned int cur_vblank;
 	int ret = 0;
 
 	/* Assume that the user has missed the current sequence number
 	 * by about a day rather than she wants to wait for years
-	 * using vertical blanks... 
+	 * using vertical blanks...
 	 */
-	DRM_WAIT_ON( ret, dev->vbl_queue, 3*DRM_HZ, 
-		     ( ( ( cur_vblank = atomic_read(&dev->vbl_received ) )
-			 - *sequence ) <= (1<<23) ) );
+	DRM_WAIT_ON(ret, dev->vbl_queue, 3 * DRM_HZ,
+		    (((cur_vblank = atomic_read(&dev->vbl_received))
+		      - *sequence) <= (1 << 23)));
 
 	*sequence = cur_vblank;
 
 	return ret;
 }
 
-void r128_driver_irq_preinstall( drm_device_t *dev ) {
-  	drm_r128_private_t *dev_priv = 
-	   (drm_r128_private_t *)dev->dev_private;
+void r128_driver_irq_preinstall(drm_device_t * dev)
+{
+	drm_r128_private_t *dev_priv = (drm_r128_private_t *) dev->dev_private;
 
 	/* Disable *all* interrupts */
-      	R128_WRITE( R128_GEN_INT_CNTL, 0 );
+	R128_WRITE(R128_GEN_INT_CNTL, 0);
 	/* Clear vblank bit if it's already high */
-   	R128_WRITE( R128_GEN_INT_STATUS, R128_CRTC_VBLANK_INT_AK );
+	R128_WRITE(R128_GEN_INT_STATUS, R128_CRTC_VBLANK_INT_AK);
 }
 
-void r128_driver_irq_postinstall( drm_device_t *dev ) {
-  	drm_r128_private_t *dev_priv = 
-	   (drm_r128_private_t *)dev->dev_private;
+void r128_driver_irq_postinstall(drm_device_t * dev)
+{
+	drm_r128_private_t *dev_priv = (drm_r128_private_t *) dev->dev_private;
 
 	/* Turn on VBL interrupt */
-   	R128_WRITE( R128_GEN_INT_CNTL, R128_CRTC_VBLANK_INT_EN );
+	R128_WRITE(R128_GEN_INT_CNTL, R128_CRTC_VBLANK_INT_EN);
 }
 
-void r128_driver_irq_uninstall( drm_device_t *dev ) {
-  	drm_r128_private_t *dev_priv = 
-	   (drm_r128_private_t *)dev->dev_private;
+void r128_driver_irq_uninstall(drm_device_t * dev)
+{
+	drm_r128_private_t *dev_priv = (drm_r128_private_t *) dev->dev_private;
 	if (!dev_priv)
 		return;
 
 	/* Disable *all* interrupts */
-	R128_WRITE( R128_GEN_INT_CNTL, 0 );
+	R128_WRITE(R128_GEN_INT_CNTL, 0);
 }
diff -purN linux-2.6.12.orig/drivers/char/drm/r128_state.c linux-2.6.12/drivers/char/drm/r128_state.c
--- linux-2.6.12.orig/drivers/char/drm/r128_state.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/r128_state.c	2005-07-05 08:37:47.000000000 +0200
@@ -32,235 +32,233 @@
 #include "r128_drm.h"
 #include "r128_drv.h"
 
-
 /* ================================================================
  * CCE hardware state programming functions
  */
 
-static void r128_emit_clip_rects( drm_r128_private_t *dev_priv,
-				  drm_clip_rect_t *boxes, int count )
+static void r128_emit_clip_rects(drm_r128_private_t * dev_priv,
+				 drm_clip_rect_t * boxes, int count)
 {
 	u32 aux_sc_cntl = 0x00000000;
 	RING_LOCALS;
-	DRM_DEBUG( "    %s\n", __FUNCTION__ );
+	DRM_DEBUG("    %s\n", __FUNCTION__);
 
-	BEGIN_RING( (count < 3? count: 3) * 5 + 2 );
+	BEGIN_RING((count < 3 ? count : 3) * 5 + 2);
 
-	if ( count >= 1 ) {
-		OUT_RING( CCE_PACKET0( R128_AUX1_SC_LEFT, 3 ) );
-		OUT_RING( boxes[0].x1 );
-		OUT_RING( boxes[0].x2 - 1 );
-		OUT_RING( boxes[0].y1 );
-		OUT_RING( boxes[0].y2 - 1 );
+	if (count >= 1) {
+		OUT_RING(CCE_PACKET0(R128_AUX1_SC_LEFT, 3));
+		OUT_RING(boxes[0].x1);
+		OUT_RING(boxes[0].x2 - 1);
+		OUT_RING(boxes[0].y1);
+		OUT_RING(boxes[0].y2 - 1);
 
 		aux_sc_cntl |= (R128_AUX1_SC_EN | R128_AUX1_SC_MODE_OR);
 	}
-	if ( count >= 2 ) {
-		OUT_RING( CCE_PACKET0( R128_AUX2_SC_LEFT, 3 ) );
-		OUT_RING( boxes[1].x1 );
-		OUT_RING( boxes[1].x2 - 1 );
-		OUT_RING( boxes[1].y1 );
-		OUT_RING( boxes[1].y2 - 1 );
+	if (count >= 2) {
+		OUT_RING(CCE_PACKET0(R128_AUX2_SC_LEFT, 3));
+		OUT_RING(boxes[1].x1);
+		OUT_RING(boxes[1].x2 - 1);
+		OUT_RING(boxes[1].y1);
+		OUT_RING(boxes[1].y2 - 1);
 
 		aux_sc_cntl |= (R128_AUX2_SC_EN | R128_AUX2_SC_MODE_OR);
 	}
-	if ( count >= 3 ) {
-		OUT_RING( CCE_PACKET0( R128_AUX3_SC_LEFT, 3 ) );
-		OUT_RING( boxes[2].x1 );
-		OUT_RING( boxes[2].x2 - 1 );
-		OUT_RING( boxes[2].y1 );
-		OUT_RING( boxes[2].y2 - 1 );
+	if (count >= 3) {
+		OUT_RING(CCE_PACKET0(R128_AUX3_SC_LEFT, 3));
+		OUT_RING(boxes[2].x1);
+		OUT_RING(boxes[2].x2 - 1);
+		OUT_RING(boxes[2].y1);
+		OUT_RING(boxes[2].y2 - 1);
 
 		aux_sc_cntl |= (R128_AUX3_SC_EN | R128_AUX3_SC_MODE_OR);
 	}
 
-	OUT_RING( CCE_PACKET0( R128_AUX_SC_CNTL, 0 ) );
-	OUT_RING( aux_sc_cntl );
+	OUT_RING(CCE_PACKET0(R128_AUX_SC_CNTL, 0));
+	OUT_RING(aux_sc_cntl);
 
 	ADVANCE_RING();
 }
 
-static __inline__ void r128_emit_core( drm_r128_private_t *dev_priv )
+static __inline__ void r128_emit_core(drm_r128_private_t * dev_priv)
 {
 	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
 	drm_r128_context_regs_t *ctx = &sarea_priv->context_state;
 	RING_LOCALS;
-	DRM_DEBUG( "    %s\n", __FUNCTION__ );
+	DRM_DEBUG("    %s\n", __FUNCTION__);
 
-	BEGIN_RING( 2 );
+	BEGIN_RING(2);
 
-	OUT_RING( CCE_PACKET0( R128_SCALE_3D_CNTL, 0 ) );
-	OUT_RING( ctx->scale_3d_cntl );
+	OUT_RING(CCE_PACKET0(R128_SCALE_3D_CNTL, 0));
+	OUT_RING(ctx->scale_3d_cntl);
 
 	ADVANCE_RING();
 }
 
-static __inline__ void r128_emit_context( drm_r128_private_t *dev_priv )
+static __inline__ void r128_emit_context(drm_r128_private_t * dev_priv)
 {
 	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
 	drm_r128_context_regs_t *ctx = &sarea_priv->context_state;
 	RING_LOCALS;
-	DRM_DEBUG( "    %s\n", __FUNCTION__ );
+	DRM_DEBUG("    %s\n", __FUNCTION__);
 
-	BEGIN_RING( 13 );
+	BEGIN_RING(13);
 
-	OUT_RING( CCE_PACKET0( R128_DST_PITCH_OFFSET_C, 11 ) );
-	OUT_RING( ctx->dst_pitch_offset_c );
-	OUT_RING( ctx->dp_gui_master_cntl_c );
-	OUT_RING( ctx->sc_top_left_c );
-	OUT_RING( ctx->sc_bottom_right_c );
-	OUT_RING( ctx->z_offset_c );
-	OUT_RING( ctx->z_pitch_c );
-	OUT_RING( ctx->z_sten_cntl_c );
-	OUT_RING( ctx->tex_cntl_c );
-	OUT_RING( ctx->misc_3d_state_cntl_reg );
-	OUT_RING( ctx->texture_clr_cmp_clr_c );
-	OUT_RING( ctx->texture_clr_cmp_msk_c );
-	OUT_RING( ctx->fog_color_c );
+	OUT_RING(CCE_PACKET0(R128_DST_PITCH_OFFSET_C, 11));
+	OUT_RING(ctx->dst_pitch_offset_c);
+	OUT_RING(ctx->dp_gui_master_cntl_c);
+	OUT_RING(ctx->sc_top_left_c);
+	OUT_RING(ctx->sc_bottom_right_c);
+	OUT_RING(ctx->z_offset_c);
+	OUT_RING(ctx->z_pitch_c);
+	OUT_RING(ctx->z_sten_cntl_c);
+	OUT_RING(ctx->tex_cntl_c);
+	OUT_RING(ctx->misc_3d_state_cntl_reg);
+	OUT_RING(ctx->texture_clr_cmp_clr_c);
+	OUT_RING(ctx->texture_clr_cmp_msk_c);
+	OUT_RING(ctx->fog_color_c);
 
 	ADVANCE_RING();
 }
 
-static __inline__ void r128_emit_setup( drm_r128_private_t *dev_priv )
+static __inline__ void r128_emit_setup(drm_r128_private_t * dev_priv)
 {
 	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
 	drm_r128_context_regs_t *ctx = &sarea_priv->context_state;
 	RING_LOCALS;
-	DRM_DEBUG( "    %s\n", __FUNCTION__ );
+	DRM_DEBUG("    %s\n", __FUNCTION__);
 
-	BEGIN_RING( 3 );
+	BEGIN_RING(3);
 
-	OUT_RING( CCE_PACKET1( R128_SETUP_CNTL, R128_PM4_VC_FPU_SETUP ) );
-	OUT_RING( ctx->setup_cntl );
-	OUT_RING( ctx->pm4_vc_fpu_setup );
+	OUT_RING(CCE_PACKET1(R128_SETUP_CNTL, R128_PM4_VC_FPU_SETUP));
+	OUT_RING(ctx->setup_cntl);
+	OUT_RING(ctx->pm4_vc_fpu_setup);
 
 	ADVANCE_RING();
 }
 
-static __inline__ void r128_emit_masks( drm_r128_private_t *dev_priv )
+static __inline__ void r128_emit_masks(drm_r128_private_t * dev_priv)
 {
 	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
 	drm_r128_context_regs_t *ctx = &sarea_priv->context_state;
 	RING_LOCALS;
-	DRM_DEBUG( "    %s\n", __FUNCTION__ );
+	DRM_DEBUG("    %s\n", __FUNCTION__);
 
-	BEGIN_RING( 5 );
+	BEGIN_RING(5);
 
-	OUT_RING( CCE_PACKET0( R128_DP_WRITE_MASK, 0 ) );
-	OUT_RING( ctx->dp_write_mask );
+	OUT_RING(CCE_PACKET0(R128_DP_WRITE_MASK, 0));
+	OUT_RING(ctx->dp_write_mask);
 
-	OUT_RING( CCE_PACKET0( R128_STEN_REF_MASK_C, 1 ) );
-	OUT_RING( ctx->sten_ref_mask_c );
-	OUT_RING( ctx->plane_3d_mask_c );
+	OUT_RING(CCE_PACKET0(R128_STEN_REF_MASK_C, 1));
+	OUT_RING(ctx->sten_ref_mask_c);
+	OUT_RING(ctx->plane_3d_mask_c);
 
 	ADVANCE_RING();
 }
 
-static __inline__ void r128_emit_window( drm_r128_private_t *dev_priv )
+static __inline__ void r128_emit_window(drm_r128_private_t * dev_priv)
 {
 	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
 	drm_r128_context_regs_t *ctx = &sarea_priv->context_state;
 	RING_LOCALS;
-	DRM_DEBUG( "    %s\n", __FUNCTION__ );
+	DRM_DEBUG("    %s\n", __FUNCTION__);
 
-	BEGIN_RING( 2 );
+	BEGIN_RING(2);
 
-	OUT_RING( CCE_PACKET0( R128_WINDOW_XY_OFFSET, 0 ) );
-	OUT_RING( ctx->window_xy_offset );
+	OUT_RING(CCE_PACKET0(R128_WINDOW_XY_OFFSET, 0));
+	OUT_RING(ctx->window_xy_offset);
 
 	ADVANCE_RING();
 }
 
-static __inline__ void r128_emit_tex0( drm_r128_private_t *dev_priv )
+static __inline__ void r128_emit_tex0(drm_r128_private_t * dev_priv)
 {
 	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
 	drm_r128_context_regs_t *ctx = &sarea_priv->context_state;
 	drm_r128_texture_regs_t *tex = &sarea_priv->tex_state[0];
 	int i;
 	RING_LOCALS;
-	DRM_DEBUG( "    %s\n", __FUNCTION__ );
+	DRM_DEBUG("    %s\n", __FUNCTION__);
 
-	BEGIN_RING( 7 + R128_MAX_TEXTURE_LEVELS );
+	BEGIN_RING(7 + R128_MAX_TEXTURE_LEVELS);
 
-	OUT_RING( CCE_PACKET0( R128_PRIM_TEX_CNTL_C,
-			       2 + R128_MAX_TEXTURE_LEVELS ) );
-	OUT_RING( tex->tex_cntl );
-	OUT_RING( tex->tex_combine_cntl );
-	OUT_RING( ctx->tex_size_pitch_c );
-	for ( i = 0 ; i < R128_MAX_TEXTURE_LEVELS ; i++ ) {
-		OUT_RING( tex->tex_offset[i] );
-	}
-
-	OUT_RING( CCE_PACKET0( R128_CONSTANT_COLOR_C, 1 ) );
-	OUT_RING( ctx->constant_color_c );
-	OUT_RING( tex->tex_border_color );
+	OUT_RING(CCE_PACKET0(R128_PRIM_TEX_CNTL_C,
+			     2 + R128_MAX_TEXTURE_LEVELS));
+	OUT_RING(tex->tex_cntl);
+	OUT_RING(tex->tex_combine_cntl);
+	OUT_RING(ctx->tex_size_pitch_c);
+	for (i = 0; i < R128_MAX_TEXTURE_LEVELS; i++) {
+		OUT_RING(tex->tex_offset[i]);
+	}
+
+	OUT_RING(CCE_PACKET0(R128_CONSTANT_COLOR_C, 1));
+	OUT_RING(ctx->constant_color_c);
+	OUT_RING(tex->tex_border_color);
 
 	ADVANCE_RING();
 }
 
-static __inline__ void r128_emit_tex1( drm_r128_private_t *dev_priv )
+static __inline__ void r128_emit_tex1(drm_r128_private_t * dev_priv)
 {
 	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
 	drm_r128_texture_regs_t *tex = &sarea_priv->tex_state[1];
 	int i;
 	RING_LOCALS;
-	DRM_DEBUG( "    %s\n", __FUNCTION__ );
+	DRM_DEBUG("    %s\n", __FUNCTION__);
 
-	BEGIN_RING( 5 + R128_MAX_TEXTURE_LEVELS );
+	BEGIN_RING(5 + R128_MAX_TEXTURE_LEVELS);
 
-	OUT_RING( CCE_PACKET0( R128_SEC_TEX_CNTL_C,
-			       1 + R128_MAX_TEXTURE_LEVELS ) );
-	OUT_RING( tex->tex_cntl );
-	OUT_RING( tex->tex_combine_cntl );
-	for ( i = 0 ; i < R128_MAX_TEXTURE_LEVELS ; i++ ) {
-		OUT_RING( tex->tex_offset[i] );
+	OUT_RING(CCE_PACKET0(R128_SEC_TEX_CNTL_C, 1 + R128_MAX_TEXTURE_LEVELS));
+	OUT_RING(tex->tex_cntl);
+	OUT_RING(tex->tex_combine_cntl);
+	for (i = 0; i < R128_MAX_TEXTURE_LEVELS; i++) {
+		OUT_RING(tex->tex_offset[i]);
 	}
 
-	OUT_RING( CCE_PACKET0( R128_SEC_TEXTURE_BORDER_COLOR_C, 0 ) );
-	OUT_RING( tex->tex_border_color );
+	OUT_RING(CCE_PACKET0(R128_SEC_TEXTURE_BORDER_COLOR_C, 0));
+	OUT_RING(tex->tex_border_color);
 
 	ADVANCE_RING();
 }
 
-static __inline__ void r128_emit_state( drm_r128_private_t *dev_priv )
+static __inline__ void r128_emit_state(drm_r128_private_t * dev_priv)
 {
 	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
 	unsigned int dirty = sarea_priv->dirty;
 
-	DRM_DEBUG( "%s: dirty=0x%08x\n", __FUNCTION__, dirty );
+	DRM_DEBUG("%s: dirty=0x%08x\n", __FUNCTION__, dirty);
 
-	if ( dirty & R128_UPLOAD_CORE ) {
-		r128_emit_core( dev_priv );
+	if (dirty & R128_UPLOAD_CORE) {
+		r128_emit_core(dev_priv);
 		sarea_priv->dirty &= ~R128_UPLOAD_CORE;
 	}
 
-	if ( dirty & R128_UPLOAD_CONTEXT ) {
-		r128_emit_context( dev_priv );
+	if (dirty & R128_UPLOAD_CONTEXT) {
+		r128_emit_context(dev_priv);
 		sarea_priv->dirty &= ~R128_UPLOAD_CONTEXT;
 	}
 
-	if ( dirty & R128_UPLOAD_SETUP ) {
-		r128_emit_setup( dev_priv );
+	if (dirty & R128_UPLOAD_SETUP) {
+		r128_emit_setup(dev_priv);
 		sarea_priv->dirty &= ~R128_UPLOAD_SETUP;
 	}
 
-	if ( dirty & R128_UPLOAD_MASKS ) {
-		r128_emit_masks( dev_priv );
+	if (dirty & R128_UPLOAD_MASKS) {
+		r128_emit_masks(dev_priv);
 		sarea_priv->dirty &= ~R128_UPLOAD_MASKS;
 	}
 
-	if ( dirty & R128_UPLOAD_WINDOW ) {
-		r128_emit_window( dev_priv );
+	if (dirty & R128_UPLOAD_WINDOW) {
+		r128_emit_window(dev_priv);
 		sarea_priv->dirty &= ~R128_UPLOAD_WINDOW;
 	}
 
-	if ( dirty & R128_UPLOAD_TEX0 ) {
-		r128_emit_tex0( dev_priv );
+	if (dirty & R128_UPLOAD_TEX0) {
+		r128_emit_tex0(dev_priv);
 		sarea_priv->dirty &= ~R128_UPLOAD_TEX0;
 	}
 
-	if ( dirty & R128_UPLOAD_TEX1 ) {
-		r128_emit_tex1( dev_priv );
+	if (dirty & R128_UPLOAD_TEX1) {
+		r128_emit_tex1(dev_priv);
 		sarea_priv->dirty &= ~R128_UPLOAD_TEX1;
 	}
 
@@ -270,26 +268,23 @@ static __inline__ void r128_emit_state( 
 	sarea_priv->dirty &= ~R128_REQUIRE_QUIESCENCE;
 }
 
-
 #if R128_PERFORMANCE_BOXES
 /* ================================================================
  * Performance monitoring functions
  */
 
-static void r128_clear_box( drm_r128_private_t *dev_priv,
-			    int x, int y, int w, int h,
-			    int r, int g, int b )
+static void r128_clear_box(drm_r128_private_t * dev_priv,
+			   int x, int y, int w, int h, int r, int g, int b)
 {
 	u32 pitch, offset;
 	u32 fb_bpp, color;
 	RING_LOCALS;
 
-	switch ( dev_priv->fb_bpp ) {
+	switch (dev_priv->fb_bpp) {
 	case 16:
 		fb_bpp = R128_GMC_DST_16BPP;
 		color = (((r & 0xf8) << 8) |
-			 ((g & 0xfc) << 3) |
-			 ((b & 0xf8) >> 3));
+			 ((g & 0xfc) << 3) | ((b & 0xf8) >> 3));
 		break;
 	case 24:
 		fb_bpp = R128_GMC_DST_24BPP;
@@ -297,7 +292,7 @@ static void r128_clear_box( drm_r128_pri
 		break;
 	case 32:
 		fb_bpp = R128_GMC_DST_32BPP;
-		color = (((0xff) << 24) | (r << 16) | (g <<  8) | b);
+		color = (((0xff) << 24) | (r << 16) | (g << 8) | b);
 		break;
 	default:
 		return;
@@ -306,60 +301,58 @@ static void r128_clear_box( drm_r128_pri
 	offset = dev_priv->back_offset;
 	pitch = dev_priv->back_pitch >> 3;
 
-	BEGIN_RING( 6 );
+	BEGIN_RING(6);
 
-	OUT_RING( CCE_PACKET3( R128_CNTL_PAINT_MULTI, 4 ) );
-	OUT_RING( R128_GMC_DST_PITCH_OFFSET_CNTL |
-		  R128_GMC_BRUSH_SOLID_COLOR |
-		  fb_bpp |
-		  R128_GMC_SRC_DATATYPE_COLOR |
-		  R128_ROP3_P |
-		  R128_GMC_CLR_CMP_CNTL_DIS |
-		  R128_GMC_AUX_CLIP_DIS );
+	OUT_RING(CCE_PACKET3(R128_CNTL_PAINT_MULTI, 4));
+	OUT_RING(R128_GMC_DST_PITCH_OFFSET_CNTL |
+		 R128_GMC_BRUSH_SOLID_COLOR |
+		 fb_bpp |
+		 R128_GMC_SRC_DATATYPE_COLOR |
+		 R128_ROP3_P |
+		 R128_GMC_CLR_CMP_CNTL_DIS | R128_GMC_AUX_CLIP_DIS);
 
-	OUT_RING( (pitch << 21) | (offset >> 5) );
-	OUT_RING( color );
+	OUT_RING((pitch << 21) | (offset >> 5));
+	OUT_RING(color);
 
-	OUT_RING( (x << 16) | y );
-	OUT_RING( (w << 16) | h );
+	OUT_RING((x << 16) | y);
+	OUT_RING((w << 16) | h);
 
 	ADVANCE_RING();
 }
 
-static void r128_cce_performance_boxes( drm_r128_private_t *dev_priv )
+static void r128_cce_performance_boxes(drm_r128_private_t * dev_priv)
 {
-	if ( atomic_read( &dev_priv->idle_count ) == 0 ) {
-		r128_clear_box( dev_priv, 64, 4, 8, 8, 0, 255, 0 );
+	if (atomic_read(&dev_priv->idle_count) == 0) {
+		r128_clear_box(dev_priv, 64, 4, 8, 8, 0, 255, 0);
 	} else {
-		atomic_set( &dev_priv->idle_count, 0 );
+		atomic_set(&dev_priv->idle_count, 0);
 	}
 }
 
 #endif
 
-
 /* ================================================================
  * CCE command dispatch functions
  */
 
-static void r128_print_dirty( const char *msg, unsigned int flags )
+static void r128_print_dirty(const char *msg, unsigned int flags)
 {
-	DRM_INFO( "%s: (0x%x) %s%s%s%s%s%s%s%s%s\n",
-		  msg,
-		  flags,
-		  (flags & R128_UPLOAD_CORE)        ? "core, " : "",
-		  (flags & R128_UPLOAD_CONTEXT)     ? "context, " : "",
-		  (flags & R128_UPLOAD_SETUP)       ? "setup, " : "",
-		  (flags & R128_UPLOAD_TEX0)        ? "tex0, " : "",
-		  (flags & R128_UPLOAD_TEX1)        ? "tex1, " : "",
-		  (flags & R128_UPLOAD_MASKS)       ? "masks, " : "",
-		  (flags & R128_UPLOAD_WINDOW)      ? "window, " : "",
-		  (flags & R128_UPLOAD_CLIPRECTS)   ? "cliprects, " : "",
-		  (flags & R128_REQUIRE_QUIESCENCE) ? "quiescence, " : "" );
+	DRM_INFO("%s: (0x%x) %s%s%s%s%s%s%s%s%s\n",
+		 msg,
+		 flags,
+		 (flags & R128_UPLOAD_CORE) ? "core, " : "",
+		 (flags & R128_UPLOAD_CONTEXT) ? "context, " : "",
+		 (flags & R128_UPLOAD_SETUP) ? "setup, " : "",
+		 (flags & R128_UPLOAD_TEX0) ? "tex0, " : "",
+		 (flags & R128_UPLOAD_TEX1) ? "tex1, " : "",
+		 (flags & R128_UPLOAD_MASKS) ? "masks, " : "",
+		 (flags & R128_UPLOAD_WINDOW) ? "window, " : "",
+		 (flags & R128_UPLOAD_CLIPRECTS) ? "cliprects, " : "",
+		 (flags & R128_REQUIRE_QUIESCENCE) ? "quiescence, " : "");
 }
 
-static void r128_cce_dispatch_clear( drm_device_t *dev,
-				     drm_r128_clear_t *clear )
+static void r128_cce_dispatch_clear(drm_device_t * dev,
+				    drm_r128_clear_t * clear)
 {
 	drm_r128_private_t *dev_priv = dev->dev_private;
 	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
@@ -368,102 +361,103 @@ static void r128_cce_dispatch_clear( drm
 	unsigned int flags = clear->flags;
 	int i;
 	RING_LOCALS;
-	DRM_DEBUG( "%s\n", __FUNCTION__ );
+	DRM_DEBUG("%s\n", __FUNCTION__);
 
-	if ( dev_priv->page_flipping && dev_priv->current_page == 1 ) {
+	if (dev_priv->page_flipping && dev_priv->current_page == 1) {
 		unsigned int tmp = flags;
 
 		flags &= ~(R128_FRONT | R128_BACK);
-		if ( tmp & R128_FRONT ) flags |= R128_BACK;
-		if ( tmp & R128_BACK )  flags |= R128_FRONT;
+		if (tmp & R128_FRONT)
+			flags |= R128_BACK;
+		if (tmp & R128_BACK)
+			flags |= R128_FRONT;
 	}
 
-	for ( i = 0 ; i < nbox ; i++ ) {
+	for (i = 0; i < nbox; i++) {
 		int x = pbox[i].x1;
 		int y = pbox[i].y1;
 		int w = pbox[i].x2 - x;
 		int h = pbox[i].y2 - y;
 
-		DRM_DEBUG( "dispatch clear %d,%d-%d,%d flags 0x%x\n",
-			   pbox[i].x1, pbox[i].y1, pbox[i].x2,
-			   pbox[i].y2, flags );
+		DRM_DEBUG("dispatch clear %d,%d-%d,%d flags 0x%x\n",
+			  pbox[i].x1, pbox[i].y1, pbox[i].x2,
+			  pbox[i].y2, flags);
 
-		if ( flags & (R128_FRONT | R128_BACK) ) {
-			BEGIN_RING( 2 );
+		if (flags & (R128_FRONT | R128_BACK)) {
+			BEGIN_RING(2);
 
-			OUT_RING( CCE_PACKET0( R128_DP_WRITE_MASK, 0 ) );
-			OUT_RING( clear->color_mask );
+			OUT_RING(CCE_PACKET0(R128_DP_WRITE_MASK, 0));
+			OUT_RING(clear->color_mask);
 
 			ADVANCE_RING();
 		}
 
-		if ( flags & R128_FRONT ) {
-			BEGIN_RING( 6 );
+		if (flags & R128_FRONT) {
+			BEGIN_RING(6);
 
-			OUT_RING( CCE_PACKET3( R128_CNTL_PAINT_MULTI, 4 ) );
-			OUT_RING( R128_GMC_DST_PITCH_OFFSET_CNTL |
-				  R128_GMC_BRUSH_SOLID_COLOR |
-				  (dev_priv->color_fmt << 8) |
-				  R128_GMC_SRC_DATATYPE_COLOR |
-				  R128_ROP3_P |
-				  R128_GMC_CLR_CMP_CNTL_DIS |
-				  R128_GMC_AUX_CLIP_DIS );
+			OUT_RING(CCE_PACKET3(R128_CNTL_PAINT_MULTI, 4));
+			OUT_RING(R128_GMC_DST_PITCH_OFFSET_CNTL |
+				 R128_GMC_BRUSH_SOLID_COLOR |
+				 (dev_priv->color_fmt << 8) |
+				 R128_GMC_SRC_DATATYPE_COLOR |
+				 R128_ROP3_P |
+				 R128_GMC_CLR_CMP_CNTL_DIS |
+				 R128_GMC_AUX_CLIP_DIS);
 
-			OUT_RING( dev_priv->front_pitch_offset_c );
-			OUT_RING( clear->clear_color );
+			OUT_RING(dev_priv->front_pitch_offset_c);
+			OUT_RING(clear->clear_color);
 
-			OUT_RING( (x << 16) | y );
-			OUT_RING( (w << 16) | h );
+			OUT_RING((x << 16) | y);
+			OUT_RING((w << 16) | h);
 
 			ADVANCE_RING();
 		}
 
-		if ( flags & R128_BACK ) {
-			BEGIN_RING( 6 );
+		if (flags & R128_BACK) {
+			BEGIN_RING(6);
 
-			OUT_RING( CCE_PACKET3( R128_CNTL_PAINT_MULTI, 4 ) );
-			OUT_RING( R128_GMC_DST_PITCH_OFFSET_CNTL |
-				  R128_GMC_BRUSH_SOLID_COLOR |
-				  (dev_priv->color_fmt << 8) |
-				  R128_GMC_SRC_DATATYPE_COLOR |
-				  R128_ROP3_P |
-				  R128_GMC_CLR_CMP_CNTL_DIS |
-				  R128_GMC_AUX_CLIP_DIS );
+			OUT_RING(CCE_PACKET3(R128_CNTL_PAINT_MULTI, 4));
+			OUT_RING(R128_GMC_DST_PITCH_OFFSET_CNTL |
+				 R128_GMC_BRUSH_SOLID_COLOR |
+				 (dev_priv->color_fmt << 8) |
+				 R128_GMC_SRC_DATATYPE_COLOR |
+				 R128_ROP3_P |
+				 R128_GMC_CLR_CMP_CNTL_DIS |
+				 R128_GMC_AUX_CLIP_DIS);
 
-			OUT_RING( dev_priv->back_pitch_offset_c );
-			OUT_RING( clear->clear_color );
+			OUT_RING(dev_priv->back_pitch_offset_c);
+			OUT_RING(clear->clear_color);
 
-			OUT_RING( (x << 16) | y );
-			OUT_RING( (w << 16) | h );
+			OUT_RING((x << 16) | y);
+			OUT_RING((w << 16) | h);
 
 			ADVANCE_RING();
 		}
 
-		if ( flags & R128_DEPTH ) {
-			BEGIN_RING( 6 );
+		if (flags & R128_DEPTH) {
+			BEGIN_RING(6);
 
-			OUT_RING( CCE_PACKET3( R128_CNTL_PAINT_MULTI, 4 ) );
-			OUT_RING( R128_GMC_DST_PITCH_OFFSET_CNTL |
-				  R128_GMC_BRUSH_SOLID_COLOR |
-				  (dev_priv->depth_fmt << 8) |
-				  R128_GMC_SRC_DATATYPE_COLOR |
-				  R128_ROP3_P |
-				  R128_GMC_CLR_CMP_CNTL_DIS |
-				  R128_GMC_AUX_CLIP_DIS |
-				  R128_GMC_WR_MSK_DIS );
+			OUT_RING(CCE_PACKET3(R128_CNTL_PAINT_MULTI, 4));
+			OUT_RING(R128_GMC_DST_PITCH_OFFSET_CNTL |
+				 R128_GMC_BRUSH_SOLID_COLOR |
+				 (dev_priv->depth_fmt << 8) |
+				 R128_GMC_SRC_DATATYPE_COLOR |
+				 R128_ROP3_P |
+				 R128_GMC_CLR_CMP_CNTL_DIS |
+				 R128_GMC_AUX_CLIP_DIS | R128_GMC_WR_MSK_DIS);
 
-			OUT_RING( dev_priv->depth_pitch_offset_c );
-			OUT_RING( clear->clear_depth );
+			OUT_RING(dev_priv->depth_pitch_offset_c);
+			OUT_RING(clear->clear_depth);
 
-			OUT_RING( (x << 16) | y );
-			OUT_RING( (w << 16) | h );
+			OUT_RING((x << 16) | y);
+			OUT_RING((w << 16) | h);
 
 			ADVANCE_RING();
 		}
 	}
 }
 
-static void r128_cce_dispatch_swap( drm_device_t *dev )
+static void r128_cce_dispatch_swap(drm_device_t * dev)
 {
 	drm_r128_private_t *dev_priv = dev->dev_private;
 	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
@@ -471,48 +465,46 @@ static void r128_cce_dispatch_swap( drm_
 	drm_clip_rect_t *pbox = sarea_priv->boxes;
 	int i;
 	RING_LOCALS;
-	DRM_DEBUG( "%s\n", __FUNCTION__ );
+	DRM_DEBUG("%s\n", __FUNCTION__);
 
 #if R128_PERFORMANCE_BOXES
 	/* Do some trivial performance monitoring...
 	 */
-	r128_cce_performance_boxes( dev_priv );
+	r128_cce_performance_boxes(dev_priv);
 #endif
 
-	for ( i = 0 ; i < nbox ; i++ ) {
+	for (i = 0; i < nbox; i++) {
 		int x = pbox[i].x1;
 		int y = pbox[i].y1;
 		int w = pbox[i].x2 - x;
 		int h = pbox[i].y2 - y;
 
-		BEGIN_RING( 7 );
+		BEGIN_RING(7);
 
-		OUT_RING( CCE_PACKET3( R128_CNTL_BITBLT_MULTI, 5 ) );
-		OUT_RING( R128_GMC_SRC_PITCH_OFFSET_CNTL |
-			  R128_GMC_DST_PITCH_OFFSET_CNTL |
-			  R128_GMC_BRUSH_NONE |
-			  (dev_priv->color_fmt << 8) |
-			  R128_GMC_SRC_DATATYPE_COLOR |
-			  R128_ROP3_S |
-			  R128_DP_SRC_SOURCE_MEMORY |
-			  R128_GMC_CLR_CMP_CNTL_DIS |
-			  R128_GMC_AUX_CLIP_DIS |
-			  R128_GMC_WR_MSK_DIS );
+		OUT_RING(CCE_PACKET3(R128_CNTL_BITBLT_MULTI, 5));
+		OUT_RING(R128_GMC_SRC_PITCH_OFFSET_CNTL |
+			 R128_GMC_DST_PITCH_OFFSET_CNTL |
+			 R128_GMC_BRUSH_NONE |
+			 (dev_priv->color_fmt << 8) |
+			 R128_GMC_SRC_DATATYPE_COLOR |
+			 R128_ROP3_S |
+			 R128_DP_SRC_SOURCE_MEMORY |
+			 R128_GMC_CLR_CMP_CNTL_DIS |
+			 R128_GMC_AUX_CLIP_DIS | R128_GMC_WR_MSK_DIS);
 
 		/* Make this work even if front & back are flipped:
 		 */
 		if (dev_priv->current_page == 0) {
-			OUT_RING( dev_priv->back_pitch_offset_c );
-			OUT_RING( dev_priv->front_pitch_offset_c );
-		} 
-		else {
-			OUT_RING( dev_priv->front_pitch_offset_c );
-			OUT_RING( dev_priv->back_pitch_offset_c );
+			OUT_RING(dev_priv->back_pitch_offset_c);
+			OUT_RING(dev_priv->front_pitch_offset_c);
+		} else {
+			OUT_RING(dev_priv->front_pitch_offset_c);
+			OUT_RING(dev_priv->back_pitch_offset_c);
 		}
 
-		OUT_RING( (x << 16) | y );
-		OUT_RING( (x << 16) | y );
-		OUT_RING( (w << 16) | h );
+		OUT_RING((x << 16) | y);
+		OUT_RING((x << 16) | y);
+		OUT_RING((w << 16) | h);
 
 		ADVANCE_RING();
 	}
@@ -523,38 +515,37 @@ static void r128_cce_dispatch_swap( drm_
 	 */
 	dev_priv->sarea_priv->last_frame++;
 
-	BEGIN_RING( 2 );
+	BEGIN_RING(2);
 
-	OUT_RING( CCE_PACKET0( R128_LAST_FRAME_REG, 0 ) );
-	OUT_RING( dev_priv->sarea_priv->last_frame );
+	OUT_RING(CCE_PACKET0(R128_LAST_FRAME_REG, 0));
+	OUT_RING(dev_priv->sarea_priv->last_frame);
 
 	ADVANCE_RING();
 }
 
-static void r128_cce_dispatch_flip( drm_device_t *dev )
+static void r128_cce_dispatch_flip(drm_device_t * dev)
 {
 	drm_r128_private_t *dev_priv = dev->dev_private;
 	RING_LOCALS;
-	DRM_DEBUG("%s: page=%d pfCurrentPage=%d\n", 
-		__FUNCTION__,
-		dev_priv->current_page,
-		dev_priv->sarea_priv->pfCurrentPage);
+	DRM_DEBUG("%s: page=%d pfCurrentPage=%d\n",
+		  __FUNCTION__,
+		  dev_priv->current_page, dev_priv->sarea_priv->pfCurrentPage);
 
 #if R128_PERFORMANCE_BOXES
 	/* Do some trivial performance monitoring...
 	 */
-	r128_cce_performance_boxes( dev_priv );
+	r128_cce_performance_boxes(dev_priv);
 #endif
 
-	BEGIN_RING( 4 );
+	BEGIN_RING(4);
 
 	R128_WAIT_UNTIL_PAGE_FLIPPED();
-	OUT_RING( CCE_PACKET0( R128_CRTC_OFFSET, 0 ) );
+	OUT_RING(CCE_PACKET0(R128_CRTC_OFFSET, 0));
 
-	if ( dev_priv->current_page == 0 ) {
-		OUT_RING( dev_priv->back_offset );
+	if (dev_priv->current_page == 0) {
+		OUT_RING(dev_priv->back_offset);
 	} else {
-		OUT_RING( dev_priv->front_offset );
+		OUT_RING(dev_priv->front_offset);
 	}
 
 	ADVANCE_RING();
@@ -565,18 +556,17 @@ static void r128_cce_dispatch_flip( drm_
 	 */
 	dev_priv->sarea_priv->last_frame++;
 	dev_priv->sarea_priv->pfCurrentPage = dev_priv->current_page =
-					      1 - dev_priv->current_page;
+	    1 - dev_priv->current_page;
 
-	BEGIN_RING( 2 );
+	BEGIN_RING(2);
 
-	OUT_RING( CCE_PACKET0( R128_LAST_FRAME_REG, 0 ) );
-	OUT_RING( dev_priv->sarea_priv->last_frame );
+	OUT_RING(CCE_PACKET0(R128_LAST_FRAME_REG, 0));
+	OUT_RING(dev_priv->sarea_priv->last_frame);
 
 	ADVANCE_RING();
 }
 
-static void r128_cce_dispatch_vertex( drm_device_t *dev,
-				      drm_buf_t *buf )
+static void r128_cce_dispatch_vertex(drm_device_t * dev, drm_buf_t * buf)
 {
 	drm_r128_private_t *dev_priv = dev->dev_private;
 	drm_r128_buf_priv_t *buf_priv = buf->dev_private;
@@ -587,50 +577,50 @@ static void r128_cce_dispatch_vertex( dr
 	int prim = buf_priv->prim;
 	int i = 0;
 	RING_LOCALS;
-	DRM_DEBUG( "buf=%d nbox=%d\n", buf->idx, sarea_priv->nbox );
+	DRM_DEBUG("buf=%d nbox=%d\n", buf->idx, sarea_priv->nbox);
 
-	if ( 0 )
-		r128_print_dirty( "dispatch_vertex", sarea_priv->dirty );
+	if (0)
+		r128_print_dirty("dispatch_vertex", sarea_priv->dirty);
 
-	if ( buf->used ) {
+	if (buf->used) {
 		buf_priv->dispatched = 1;
 
-		if ( sarea_priv->dirty & ~R128_UPLOAD_CLIPRECTS ) {
-			r128_emit_state( dev_priv );
+		if (sarea_priv->dirty & ~R128_UPLOAD_CLIPRECTS) {
+			r128_emit_state(dev_priv);
 		}
 
 		do {
 			/* Emit the next set of up to three cliprects */
-			if ( i < sarea_priv->nbox ) {
-				r128_emit_clip_rects( dev_priv,
-						      &sarea_priv->boxes[i],
-						      sarea_priv->nbox - i );
+			if (i < sarea_priv->nbox) {
+				r128_emit_clip_rects(dev_priv,
+						     &sarea_priv->boxes[i],
+						     sarea_priv->nbox - i);
 			}
 
 			/* Emit the vertex buffer rendering commands */
-			BEGIN_RING( 5 );
+			BEGIN_RING(5);
 
-			OUT_RING( CCE_PACKET3( R128_3D_RNDR_GEN_INDX_PRIM, 3 ) );
-			OUT_RING( offset );
-			OUT_RING( size );
-			OUT_RING( format );
-			OUT_RING( prim | R128_CCE_VC_CNTL_PRIM_WALK_LIST |
-				  (size << R128_CCE_VC_CNTL_NUM_SHIFT) );
+			OUT_RING(CCE_PACKET3(R128_3D_RNDR_GEN_INDX_PRIM, 3));
+			OUT_RING(offset);
+			OUT_RING(size);
+			OUT_RING(format);
+			OUT_RING(prim | R128_CCE_VC_CNTL_PRIM_WALK_LIST |
+				 (size << R128_CCE_VC_CNTL_NUM_SHIFT));
 
 			ADVANCE_RING();
 
 			i += 3;
-		} while ( i < sarea_priv->nbox );
+		} while (i < sarea_priv->nbox);
 	}
 
-	if ( buf_priv->discard ) {
+	if (buf_priv->discard) {
 		buf_priv->age = dev_priv->sarea_priv->last_dispatch;
 
 		/* Emit the vertex buffer age */
-		BEGIN_RING( 2 );
+		BEGIN_RING(2);
 
-		OUT_RING( CCE_PACKET0( R128_LAST_DISPATCH_REG, 0 ) );
-		OUT_RING( buf_priv->age );
+		OUT_RING(CCE_PACKET0(R128_LAST_DISPATCH_REG, 0));
+		OUT_RING(buf_priv->age);
 
 		ADVANCE_RING();
 
@@ -646,17 +636,15 @@ static void r128_cce_dispatch_vertex( dr
 	sarea_priv->nbox = 0;
 }
 
-static void r128_cce_dispatch_indirect( drm_device_t *dev,
-					drm_buf_t *buf,
-					int start, int end )
+static void r128_cce_dispatch_indirect(drm_device_t * dev,
+				       drm_buf_t * buf, int start, int end)
 {
 	drm_r128_private_t *dev_priv = dev->dev_private;
 	drm_r128_buf_priv_t *buf_priv = buf->dev_private;
 	RING_LOCALS;
-	DRM_DEBUG( "indirect: buf=%d s=0x%x e=0x%x\n",
-		   buf->idx, start, end );
+	DRM_DEBUG("indirect: buf=%d s=0x%x e=0x%x\n", buf->idx, start, end);
 
-	if ( start != end ) {
+	if (start != end) {
 		int offset = buf->bus_address + start;
 		int dwords = (end - start + 3) / sizeof(u32);
 
@@ -664,33 +652,33 @@ static void r128_cce_dispatch_indirect( 
 		 * dwords, so if we've been given an odd number we must
 		 * pad the data with a Type-2 CCE packet.
 		 */
-		if ( dwords & 1 ) {
+		if (dwords & 1) {
 			u32 *data = (u32 *)
-				((char *)dev->agp_buffer_map->handle
-				 + buf->offset + start);
-			data[dwords++] = cpu_to_le32( R128_CCE_PACKET2 );
+			    ((char *)dev->agp_buffer_map->handle
+			     + buf->offset + start);
+			data[dwords++] = cpu_to_le32(R128_CCE_PACKET2);
 		}
 
 		buf_priv->dispatched = 1;
 
 		/* Fire off the indirect buffer */
-		BEGIN_RING( 3 );
+		BEGIN_RING(3);
 
-		OUT_RING( CCE_PACKET0( R128_PM4_IW_INDOFF, 1 ) );
-		OUT_RING( offset );
-		OUT_RING( dwords );
+		OUT_RING(CCE_PACKET0(R128_PM4_IW_INDOFF, 1));
+		OUT_RING(offset);
+		OUT_RING(dwords);
 
 		ADVANCE_RING();
 	}
 
-	if ( buf_priv->discard ) {
+	if (buf_priv->discard) {
 		buf_priv->age = dev_priv->sarea_priv->last_dispatch;
 
 		/* Emit the indirect buffer age */
-		BEGIN_RING( 2 );
+		BEGIN_RING(2);
 
-		OUT_RING( CCE_PACKET0( R128_LAST_DISPATCH_REG, 0 ) );
-		OUT_RING( buf_priv->age );
+		OUT_RING(CCE_PACKET0(R128_LAST_DISPATCH_REG, 0));
+		OUT_RING(buf_priv->age);
 
 		ADVANCE_RING();
 
@@ -703,10 +691,9 @@ static void r128_cce_dispatch_indirect( 
 	dev_priv->sarea_priv->last_dispatch++;
 }
 
-static void r128_cce_dispatch_indices( drm_device_t *dev,
-				       drm_buf_t *buf,
-				       int start, int end,
-				       int count )
+static void r128_cce_dispatch_indices(drm_device_t * dev,
+				      drm_buf_t * buf,
+				      int start, int end, int count)
 {
 	drm_r128_private_t *dev_priv = dev->dev_private;
 	drm_r128_buf_priv_t *buf_priv = buf->dev_private;
@@ -718,62 +705,62 @@ static void r128_cce_dispatch_indices( d
 	int dwords;
 	int i = 0;
 	RING_LOCALS;
-	DRM_DEBUG( "indices: s=%d e=%d c=%d\n", start, end, count );
+	DRM_DEBUG("indices: s=%d e=%d c=%d\n", start, end, count);
 
-	if ( 0 )
-		r128_print_dirty( "dispatch_indices", sarea_priv->dirty );
+	if (0)
+		r128_print_dirty("dispatch_indices", sarea_priv->dirty);
 
-	if ( start != end ) {
+	if (start != end) {
 		buf_priv->dispatched = 1;
 
-		if ( sarea_priv->dirty & ~R128_UPLOAD_CLIPRECTS ) {
-			r128_emit_state( dev_priv );
+		if (sarea_priv->dirty & ~R128_UPLOAD_CLIPRECTS) {
+			r128_emit_state(dev_priv);
 		}
 
 		dwords = (end - start + 3) / sizeof(u32);
 
-		data = (u32 *)((char *)dev->agp_buffer_map->handle
-			       + buf->offset + start);
+		data = (u32 *) ((char *)dev->agp_buffer_map->handle
+				+ buf->offset + start);
 
-		data[0] = cpu_to_le32( CCE_PACKET3( R128_3D_RNDR_GEN_INDX_PRIM,
-						    dwords-2 ) );
+		data[0] = cpu_to_le32(CCE_PACKET3(R128_3D_RNDR_GEN_INDX_PRIM,
+						  dwords - 2));
 
-		data[1] = cpu_to_le32( offset );
-		data[2] = cpu_to_le32( R128_MAX_VB_VERTS );
-		data[3] = cpu_to_le32( format );
-		data[4] = cpu_to_le32( (prim | R128_CCE_VC_CNTL_PRIM_WALK_IND |
-					(count << 16)) );
+		data[1] = cpu_to_le32(offset);
+		data[2] = cpu_to_le32(R128_MAX_VB_VERTS);
+		data[3] = cpu_to_le32(format);
+		data[4] = cpu_to_le32((prim | R128_CCE_VC_CNTL_PRIM_WALK_IND |
+				       (count << 16)));
 
-		if ( count & 0x1 ) {
+		if (count & 0x1) {
 #ifdef __LITTLE_ENDIAN
-			data[dwords-1] &= 0x0000ffff;
+			data[dwords - 1] &= 0x0000ffff;
 #else
-			data[dwords-1] &= 0xffff0000;
+			data[dwords - 1] &= 0xffff0000;
 #endif
 		}
 
 		do {
 			/* Emit the next set of up to three cliprects */
-			if ( i < sarea_priv->nbox ) {
-				r128_emit_clip_rects( dev_priv,
-						      &sarea_priv->boxes[i],
-						      sarea_priv->nbox - i );
+			if (i < sarea_priv->nbox) {
+				r128_emit_clip_rects(dev_priv,
+						     &sarea_priv->boxes[i],
+						     sarea_priv->nbox - i);
 			}
 
-			r128_cce_dispatch_indirect( dev, buf, start, end );
+			r128_cce_dispatch_indirect(dev, buf, start, end);
 
 			i += 3;
-		} while ( i < sarea_priv->nbox );
+		} while (i < sarea_priv->nbox);
 	}
 
-	if ( buf_priv->discard ) {
+	if (buf_priv->discard) {
 		buf_priv->age = dev_priv->sarea_priv->last_dispatch;
 
 		/* Emit the vertex buffer age */
-		BEGIN_RING( 2 );
+		BEGIN_RING(2);
 
-		OUT_RING( CCE_PACKET0( R128_LAST_DISPATCH_REG, 0 ) );
-		OUT_RING( buf_priv->age );
+		OUT_RING(CCE_PACKET0(R128_LAST_DISPATCH_REG, 0));
+		OUT_RING(buf_priv->age);
 
 		ADVANCE_RING();
 
@@ -788,9 +775,8 @@ static void r128_cce_dispatch_indices( d
 	sarea_priv->nbox = 0;
 }
 
-static int r128_cce_dispatch_blit( DRMFILE filp,
-				   drm_device_t *dev,
-				   drm_r128_blit_t *blit )
+static int r128_cce_dispatch_blit(DRMFILE filp,
+				  drm_device_t * dev, drm_r128_blit_t * blit)
 {
 	drm_r128_private_t *dev_priv = dev->dev_private;
 	drm_device_dma_t *dma = dev->dma;
@@ -799,13 +785,13 @@ static int r128_cce_dispatch_blit( DRMFI
 	u32 *data;
 	int dword_shift, dwords;
 	RING_LOCALS;
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
 	/* The compiler won't optimize away a division by a variable,
 	 * even if the only legal values are powers of two.  Thus, we'll
 	 * use a shift instead.
 	 */
-	switch ( blit->format ) {
+	switch (blit->format) {
 	case R128_DATATYPE_ARGB8888:
 		dword_shift = 0;
 		break;
@@ -821,7 +807,7 @@ static int r128_cce_dispatch_blit( DRMFI
 		dword_shift = 2;
 		break;
 	default:
-		DRM_ERROR( "invalid blit format %d\n", blit->format );
+		DRM_ERROR("invalid blit format %d\n", blit->format);
 		return DRM_ERR(EINVAL);
 	}
 
@@ -830,10 +816,10 @@ static int r128_cce_dispatch_blit( DRMFI
 	 * data from the host data blit, otherwise part of the texture
 	 * image may be corrupted.
 	 */
-	BEGIN_RING( 2 );
+	BEGIN_RING(2);
 
-	OUT_RING( CCE_PACKET0( R128_PC_GUI_CTLSTAT, 0 ) );
-	OUT_RING( R128_PC_RI_GUI | R128_PC_FLUSH_GUI );
+	OUT_RING(CCE_PACKET0(R128_PC_GUI_CTLSTAT, 0));
+	OUT_RING(R128_PC_RI_GUI | R128_PC_FLUSH_GUI);
 
 	ADVANCE_RING();
 
@@ -842,13 +828,13 @@ static int r128_cce_dispatch_blit( DRMFI
 	buf = dma->buflist[blit->idx];
 	buf_priv = buf->dev_private;
 
-	if ( buf->filp != filp ) {
-		DRM_ERROR( "process %d using buffer owned by %p\n",
-			   DRM_CURRENTPID, buf->filp );
+	if (buf->filp != filp) {
+		DRM_ERROR("process %d using buffer owned by %p\n",
+			  DRM_CURRENTPID, buf->filp);
 		return DRM_ERR(EINVAL);
 	}
-	if ( buf->pending ) {
-		DRM_ERROR( "sending pending buffer %d\n", blit->idx );
+	if (buf->pending) {
+		DRM_ERROR("sending pending buffer %d\n", blit->idx);
 		return DRM_ERR(EINVAL);
 	}
 
@@ -856,45 +842,43 @@ static int r128_cce_dispatch_blit( DRMFI
 
 	dwords = (blit->width * blit->height) >> dword_shift;
 
-	data = (u32 *)((char *)dev->agp_buffer_map->handle + buf->offset);
+	data = (u32 *) ((char *)dev->agp_buffer_map->handle + buf->offset);
 
-	data[0] = cpu_to_le32( CCE_PACKET3( R128_CNTL_HOSTDATA_BLT, dwords + 6 ) );
-	data[1] = cpu_to_le32( (R128_GMC_DST_PITCH_OFFSET_CNTL |
-				R128_GMC_BRUSH_NONE |
-				(blit->format << 8) |
-				R128_GMC_SRC_DATATYPE_COLOR |
-				R128_ROP3_S |
-				R128_DP_SRC_SOURCE_HOST_DATA |
-				R128_GMC_CLR_CMP_CNTL_DIS |
-				R128_GMC_AUX_CLIP_DIS |
-				R128_GMC_WR_MSK_DIS) );
-
-	data[2] = cpu_to_le32( (blit->pitch << 21) | (blit->offset >> 5) );
-	data[3] = cpu_to_le32( 0xffffffff );
-	data[4] = cpu_to_le32( 0xffffffff );
-	data[5] = cpu_to_le32( (blit->y << 16) | blit->x );
-	data[6] = cpu_to_le32( (blit->height << 16) | blit->width );
-	data[7] = cpu_to_le32( dwords );
+	data[0] = cpu_to_le32(CCE_PACKET3(R128_CNTL_HOSTDATA_BLT, dwords + 6));
+	data[1] = cpu_to_le32((R128_GMC_DST_PITCH_OFFSET_CNTL |
+			       R128_GMC_BRUSH_NONE |
+			       (blit->format << 8) |
+			       R128_GMC_SRC_DATATYPE_COLOR |
+			       R128_ROP3_S |
+			       R128_DP_SRC_SOURCE_HOST_DATA |
+			       R128_GMC_CLR_CMP_CNTL_DIS |
+			       R128_GMC_AUX_CLIP_DIS | R128_GMC_WR_MSK_DIS));
+
+	data[2] = cpu_to_le32((blit->pitch << 21) | (blit->offset >> 5));
+	data[3] = cpu_to_le32(0xffffffff);
+	data[4] = cpu_to_le32(0xffffffff);
+	data[5] = cpu_to_le32((blit->y << 16) | blit->x);
+	data[6] = cpu_to_le32((blit->height << 16) | blit->width);
+	data[7] = cpu_to_le32(dwords);
 
 	buf->used = (dwords + 8) * sizeof(u32);
 
-	r128_cce_dispatch_indirect( dev, buf, 0, buf->used );
+	r128_cce_dispatch_indirect(dev, buf, 0, buf->used);
 
 	/* Flush the pixel cache after the blit completes.  This ensures
 	 * the texture data is written out to memory before rendering
 	 * continues.
 	 */
-	BEGIN_RING( 2 );
+	BEGIN_RING(2);
 
-	OUT_RING( CCE_PACKET0( R128_PC_GUI_CTLSTAT, 0 ) );
-	OUT_RING( R128_PC_FLUSH_GUI );
+	OUT_RING(CCE_PACKET0(R128_PC_GUI_CTLSTAT, 0));
+	OUT_RING(R128_PC_FLUSH_GUI);
 
 	ADVANCE_RING();
 
 	return 0;
 }
 
-
 /* ================================================================
  * Tiled depth buffer management
  *
@@ -902,8 +886,8 @@ static int r128_cce_dispatch_blit( DRMFI
  * have hardware stencil support.
  */
 
-static int r128_cce_dispatch_write_span( drm_device_t *dev,
-					 drm_r128_depth_t *depth )
+static int r128_cce_dispatch_write_span(drm_device_t * dev,
+					drm_r128_depth_t * depth)
 {
 	drm_r128_private_t *dev_priv = dev->dev_private;
 	int count, x, y;
@@ -911,95 +895,95 @@ static int r128_cce_dispatch_write_span(
 	u8 *mask;
 	int i, buffer_size, mask_size;
 	RING_LOCALS;
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
 	count = depth->n;
 	if (count > 4096 || count <= 0)
 		return DRM_ERR(EMSGSIZE);
 
-	if ( DRM_COPY_FROM_USER( &x, depth->x, sizeof(x) ) ) {
+	if (DRM_COPY_FROM_USER(&x, depth->x, sizeof(x))) {
 		return DRM_ERR(EFAULT);
 	}
-	if ( DRM_COPY_FROM_USER( &y, depth->y, sizeof(y) ) ) {
+	if (DRM_COPY_FROM_USER(&y, depth->y, sizeof(y))) {
 		return DRM_ERR(EFAULT);
 	}
 
 	buffer_size = depth->n * sizeof(u32);
-	buffer = drm_alloc( buffer_size, DRM_MEM_BUFS );
-	if ( buffer == NULL )
+	buffer = drm_alloc(buffer_size, DRM_MEM_BUFS);
+	if (buffer == NULL)
 		return DRM_ERR(ENOMEM);
-	if ( DRM_COPY_FROM_USER( buffer, depth->buffer, buffer_size ) ) {
-		drm_free( buffer, buffer_size, DRM_MEM_BUFS);
+	if (DRM_COPY_FROM_USER(buffer, depth->buffer, buffer_size)) {
+		drm_free(buffer, buffer_size, DRM_MEM_BUFS);
 		return DRM_ERR(EFAULT);
 	}
 
 	mask_size = depth->n * sizeof(u8);
-	if ( depth->mask ) {
-		mask = drm_alloc( mask_size, DRM_MEM_BUFS );
-		if ( mask == NULL ) {
-			drm_free( buffer, buffer_size, DRM_MEM_BUFS );
+	if (depth->mask) {
+		mask = drm_alloc(mask_size, DRM_MEM_BUFS);
+		if (mask == NULL) {
+			drm_free(buffer, buffer_size, DRM_MEM_BUFS);
 			return DRM_ERR(ENOMEM);
 		}
-		if ( DRM_COPY_FROM_USER( mask, depth->mask, mask_size ) ) {
-			drm_free( buffer, buffer_size, DRM_MEM_BUFS );
-			drm_free( mask, mask_size, DRM_MEM_BUFS );
+		if (DRM_COPY_FROM_USER(mask, depth->mask, mask_size)) {
+			drm_free(buffer, buffer_size, DRM_MEM_BUFS);
+			drm_free(mask, mask_size, DRM_MEM_BUFS);
 			return DRM_ERR(EFAULT);
 		}
 
-		for ( i = 0 ; i < count ; i++, x++ ) {
-			if ( mask[i] ) {
-				BEGIN_RING( 6 );
-
-				OUT_RING( CCE_PACKET3( R128_CNTL_PAINT_MULTI, 4 ) );
-				OUT_RING( R128_GMC_DST_PITCH_OFFSET_CNTL |
-					  R128_GMC_BRUSH_SOLID_COLOR |
-					  (dev_priv->depth_fmt << 8) |
-					  R128_GMC_SRC_DATATYPE_COLOR |
-					  R128_ROP3_P |
-					  R128_GMC_CLR_CMP_CNTL_DIS |
-					  R128_GMC_WR_MSK_DIS );
+		for (i = 0; i < count; i++, x++) {
+			if (mask[i]) {
+				BEGIN_RING(6);
+
+				OUT_RING(CCE_PACKET3(R128_CNTL_PAINT_MULTI, 4));
+				OUT_RING(R128_GMC_DST_PITCH_OFFSET_CNTL |
+					 R128_GMC_BRUSH_SOLID_COLOR |
+					 (dev_priv->depth_fmt << 8) |
+					 R128_GMC_SRC_DATATYPE_COLOR |
+					 R128_ROP3_P |
+					 R128_GMC_CLR_CMP_CNTL_DIS |
+					 R128_GMC_WR_MSK_DIS);
 
-				OUT_RING( dev_priv->depth_pitch_offset_c );
-				OUT_RING( buffer[i] );
+				OUT_RING(dev_priv->depth_pitch_offset_c);
+				OUT_RING(buffer[i]);
 
-				OUT_RING( (x << 16) | y );
-				OUT_RING( (1 << 16) | 1 );
+				OUT_RING((x << 16) | y);
+				OUT_RING((1 << 16) | 1);
 
 				ADVANCE_RING();
 			}
 		}
 
-		drm_free( mask, mask_size, DRM_MEM_BUFS );
+		drm_free(mask, mask_size, DRM_MEM_BUFS);
 	} else {
-		for ( i = 0 ; i < count ; i++, x++ ) {
-			BEGIN_RING( 6 );
+		for (i = 0; i < count; i++, x++) {
+			BEGIN_RING(6);
 
-			OUT_RING( CCE_PACKET3( R128_CNTL_PAINT_MULTI, 4 ) );
-			OUT_RING( R128_GMC_DST_PITCH_OFFSET_CNTL |
-				  R128_GMC_BRUSH_SOLID_COLOR |
-				  (dev_priv->depth_fmt << 8) |
-				  R128_GMC_SRC_DATATYPE_COLOR |
-				  R128_ROP3_P |
-				  R128_GMC_CLR_CMP_CNTL_DIS |
-				  R128_GMC_WR_MSK_DIS );
+			OUT_RING(CCE_PACKET3(R128_CNTL_PAINT_MULTI, 4));
+			OUT_RING(R128_GMC_DST_PITCH_OFFSET_CNTL |
+				 R128_GMC_BRUSH_SOLID_COLOR |
+				 (dev_priv->depth_fmt << 8) |
+				 R128_GMC_SRC_DATATYPE_COLOR |
+				 R128_ROP3_P |
+				 R128_GMC_CLR_CMP_CNTL_DIS |
+				 R128_GMC_WR_MSK_DIS);
 
-			OUT_RING( dev_priv->depth_pitch_offset_c );
-			OUT_RING( buffer[i] );
+			OUT_RING(dev_priv->depth_pitch_offset_c);
+			OUT_RING(buffer[i]);
 
-			OUT_RING( (x << 16) | y );
-			OUT_RING( (1 << 16) | 1 );
+			OUT_RING((x << 16) | y);
+			OUT_RING((1 << 16) | 1);
 
 			ADVANCE_RING();
 		}
 	}
 
-	drm_free( buffer, buffer_size, DRM_MEM_BUFS );
+	drm_free(buffer, buffer_size, DRM_MEM_BUFS);
 
 	return 0;
 }
 
-static int r128_cce_dispatch_write_pixels( drm_device_t *dev,
-					   drm_r128_depth_t *depth )
+static int r128_cce_dispatch_write_pixels(drm_device_t * dev,
+					  drm_r128_depth_t * depth)
 {
 	drm_r128_private_t *dev_priv = dev->dev_private;
 	int count, *x, *y;
@@ -1007,7 +991,7 @@ static int r128_cce_dispatch_write_pixel
 	u8 *mask;
 	int i, xbuf_size, ybuf_size, buffer_size, mask_size;
 	RING_LOCALS;
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
 	count = depth->n;
 	if (count > 4096 || count <= 0)
@@ -1015,270 +999,266 @@ static int r128_cce_dispatch_write_pixel
 
 	xbuf_size = count * sizeof(*x);
 	ybuf_size = count * sizeof(*y);
-	x = drm_alloc( xbuf_size, DRM_MEM_BUFS );
-	if ( x == NULL ) {
+	x = drm_alloc(xbuf_size, DRM_MEM_BUFS);
+	if (x == NULL) {
 		return DRM_ERR(ENOMEM);
 	}
-	y = drm_alloc( ybuf_size, DRM_MEM_BUFS );
-	if ( y == NULL ) {
-		drm_free( x, xbuf_size, DRM_MEM_BUFS );
+	y = drm_alloc(ybuf_size, DRM_MEM_BUFS);
+	if (y == NULL) {
+		drm_free(x, xbuf_size, DRM_MEM_BUFS);
 		return DRM_ERR(ENOMEM);
 	}
-	if ( DRM_COPY_FROM_USER( x, depth->x, xbuf_size ) ) {
-		drm_free( x, xbuf_size, DRM_MEM_BUFS );
-		drm_free( y, ybuf_size, DRM_MEM_BUFS );
+	if (DRM_COPY_FROM_USER(x, depth->x, xbuf_size)) {
+		drm_free(x, xbuf_size, DRM_MEM_BUFS);
+		drm_free(y, ybuf_size, DRM_MEM_BUFS);
 		return DRM_ERR(EFAULT);
 	}
-	if ( DRM_COPY_FROM_USER( y, depth->y, xbuf_size ) ) {
-		drm_free( x, xbuf_size, DRM_MEM_BUFS );
-		drm_free( y, ybuf_size, DRM_MEM_BUFS );
+	if (DRM_COPY_FROM_USER(y, depth->y, xbuf_size)) {
+		drm_free(x, xbuf_size, DRM_MEM_BUFS);
+		drm_free(y, ybuf_size, DRM_MEM_BUFS);
 		return DRM_ERR(EFAULT);
 	}
 
 	buffer_size = depth->n * sizeof(u32);
-	buffer = drm_alloc( buffer_size, DRM_MEM_BUFS );
-	if ( buffer == NULL ) {
-		drm_free( x, xbuf_size, DRM_MEM_BUFS );
-		drm_free( y, ybuf_size, DRM_MEM_BUFS );
+	buffer = drm_alloc(buffer_size, DRM_MEM_BUFS);
+	if (buffer == NULL) {
+		drm_free(x, xbuf_size, DRM_MEM_BUFS);
+		drm_free(y, ybuf_size, DRM_MEM_BUFS);
 		return DRM_ERR(ENOMEM);
 	}
-	if ( DRM_COPY_FROM_USER( buffer, depth->buffer, buffer_size ) ) {
-		drm_free( x, xbuf_size, DRM_MEM_BUFS );
-		drm_free( y, ybuf_size, DRM_MEM_BUFS );
-		drm_free( buffer, buffer_size, DRM_MEM_BUFS );
+	if (DRM_COPY_FROM_USER(buffer, depth->buffer, buffer_size)) {
+		drm_free(x, xbuf_size, DRM_MEM_BUFS);
+		drm_free(y, ybuf_size, DRM_MEM_BUFS);
+		drm_free(buffer, buffer_size, DRM_MEM_BUFS);
 		return DRM_ERR(EFAULT);
 	}
 
-	if ( depth->mask ) {
+	if (depth->mask) {
 		mask_size = depth->n * sizeof(u8);
-		mask = drm_alloc( mask_size, DRM_MEM_BUFS );
-		if ( mask == NULL ) {
-			drm_free( x, xbuf_size, DRM_MEM_BUFS );
-			drm_free( y, ybuf_size, DRM_MEM_BUFS );
-			drm_free( buffer, buffer_size, DRM_MEM_BUFS );
+		mask = drm_alloc(mask_size, DRM_MEM_BUFS);
+		if (mask == NULL) {
+			drm_free(x, xbuf_size, DRM_MEM_BUFS);
+			drm_free(y, ybuf_size, DRM_MEM_BUFS);
+			drm_free(buffer, buffer_size, DRM_MEM_BUFS);
 			return DRM_ERR(ENOMEM);
 		}
-		if ( DRM_COPY_FROM_USER( mask, depth->mask, mask_size ) ) {
-			drm_free( x, xbuf_size, DRM_MEM_BUFS  );
-			drm_free( y, ybuf_size, DRM_MEM_BUFS  );
-			drm_free( buffer, buffer_size, DRM_MEM_BUFS  );
-			drm_free( mask, mask_size, DRM_MEM_BUFS  );
+		if (DRM_COPY_FROM_USER(mask, depth->mask, mask_size)) {
+			drm_free(x, xbuf_size, DRM_MEM_BUFS);
+			drm_free(y, ybuf_size, DRM_MEM_BUFS);
+			drm_free(buffer, buffer_size, DRM_MEM_BUFS);
+			drm_free(mask, mask_size, DRM_MEM_BUFS);
 			return DRM_ERR(EFAULT);
 		}
 
-		for ( i = 0 ; i < count ; i++ ) {
-			if ( mask[i] ) {
-				BEGIN_RING( 6 );
-
-				OUT_RING( CCE_PACKET3( R128_CNTL_PAINT_MULTI, 4 ) );
-				OUT_RING( R128_GMC_DST_PITCH_OFFSET_CNTL |
-					  R128_GMC_BRUSH_SOLID_COLOR |
-					  (dev_priv->depth_fmt << 8) |
-					  R128_GMC_SRC_DATATYPE_COLOR |
-					  R128_ROP3_P |
-					  R128_GMC_CLR_CMP_CNTL_DIS |
-					  R128_GMC_WR_MSK_DIS );
+		for (i = 0; i < count; i++) {
+			if (mask[i]) {
+				BEGIN_RING(6);
+
+				OUT_RING(CCE_PACKET3(R128_CNTL_PAINT_MULTI, 4));
+				OUT_RING(R128_GMC_DST_PITCH_OFFSET_CNTL |
+					 R128_GMC_BRUSH_SOLID_COLOR |
+					 (dev_priv->depth_fmt << 8) |
+					 R128_GMC_SRC_DATATYPE_COLOR |
+					 R128_ROP3_P |
+					 R128_GMC_CLR_CMP_CNTL_DIS |
+					 R128_GMC_WR_MSK_DIS);
 
-				OUT_RING( dev_priv->depth_pitch_offset_c );
-				OUT_RING( buffer[i] );
+				OUT_RING(dev_priv->depth_pitch_offset_c);
+				OUT_RING(buffer[i]);
 
-				OUT_RING( (x[i] << 16) | y[i] );
-				OUT_RING( (1 << 16) | 1 );
+				OUT_RING((x[i] << 16) | y[i]);
+				OUT_RING((1 << 16) | 1);
 
 				ADVANCE_RING();
 			}
 		}
 
-		drm_free( mask, mask_size, DRM_MEM_BUFS );
+		drm_free(mask, mask_size, DRM_MEM_BUFS);
 	} else {
-		for ( i = 0 ; i < count ; i++ ) {
-			BEGIN_RING( 6 );
+		for (i = 0; i < count; i++) {
+			BEGIN_RING(6);
 
-			OUT_RING( CCE_PACKET3( R128_CNTL_PAINT_MULTI, 4 ) );
-			OUT_RING( R128_GMC_DST_PITCH_OFFSET_CNTL |
-				  R128_GMC_BRUSH_SOLID_COLOR |
-				  (dev_priv->depth_fmt << 8) |
-				  R128_GMC_SRC_DATATYPE_COLOR |
-				  R128_ROP3_P |
-				  R128_GMC_CLR_CMP_CNTL_DIS |
-				  R128_GMC_WR_MSK_DIS );
+			OUT_RING(CCE_PACKET3(R128_CNTL_PAINT_MULTI, 4));
+			OUT_RING(R128_GMC_DST_PITCH_OFFSET_CNTL |
+				 R128_GMC_BRUSH_SOLID_COLOR |
+				 (dev_priv->depth_fmt << 8) |
+				 R128_GMC_SRC_DATATYPE_COLOR |
+				 R128_ROP3_P |
+				 R128_GMC_CLR_CMP_CNTL_DIS |
+				 R128_GMC_WR_MSK_DIS);
 
-			OUT_RING( dev_priv->depth_pitch_offset_c );
-			OUT_RING( buffer[i] );
+			OUT_RING(dev_priv->depth_pitch_offset_c);
+			OUT_RING(buffer[i]);
 
-			OUT_RING( (x[i] << 16) | y[i] );
-			OUT_RING( (1 << 16) | 1 );
+			OUT_RING((x[i] << 16) | y[i]);
+			OUT_RING((1 << 16) | 1);
 
 			ADVANCE_RING();
 		}
 	}
 
-	drm_free( x, xbuf_size, DRM_MEM_BUFS );
-	drm_free( y, ybuf_size, DRM_MEM_BUFS );
-	drm_free( buffer, buffer_size, DRM_MEM_BUFS );
+	drm_free(x, xbuf_size, DRM_MEM_BUFS);
+	drm_free(y, ybuf_size, DRM_MEM_BUFS);
+	drm_free(buffer, buffer_size, DRM_MEM_BUFS);
 
 	return 0;
 }
 
-static int r128_cce_dispatch_read_span( drm_device_t *dev,
-					drm_r128_depth_t *depth )
+static int r128_cce_dispatch_read_span(drm_device_t * dev,
+				       drm_r128_depth_t * depth)
 {
 	drm_r128_private_t *dev_priv = dev->dev_private;
 	int count, x, y;
 	RING_LOCALS;
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
 	count = depth->n;
 	if (count > 4096 || count <= 0)
 		return DRM_ERR(EMSGSIZE);
 
-	if ( DRM_COPY_FROM_USER( &x, depth->x, sizeof(x) ) ) {
+	if (DRM_COPY_FROM_USER(&x, depth->x, sizeof(x))) {
 		return DRM_ERR(EFAULT);
 	}
-	if ( DRM_COPY_FROM_USER( &y, depth->y, sizeof(y) ) ) {
+	if (DRM_COPY_FROM_USER(&y, depth->y, sizeof(y))) {
 		return DRM_ERR(EFAULT);
 	}
 
-	BEGIN_RING( 7 );
+	BEGIN_RING(7);
 
-	OUT_RING( CCE_PACKET3( R128_CNTL_BITBLT_MULTI, 5 ) );
-	OUT_RING( R128_GMC_SRC_PITCH_OFFSET_CNTL |
-		  R128_GMC_DST_PITCH_OFFSET_CNTL |
-		  R128_GMC_BRUSH_NONE |
-		  (dev_priv->depth_fmt << 8) |
-		  R128_GMC_SRC_DATATYPE_COLOR |
-		  R128_ROP3_S |
-		  R128_DP_SRC_SOURCE_MEMORY |
-		  R128_GMC_CLR_CMP_CNTL_DIS |
-		  R128_GMC_WR_MSK_DIS );
-
-	OUT_RING( dev_priv->depth_pitch_offset_c );
-	OUT_RING( dev_priv->span_pitch_offset_c );
-
-	OUT_RING( (x << 16) | y );
-	OUT_RING( (0 << 16) | 0 );
-	OUT_RING( (count << 16) | 1 );
+	OUT_RING(CCE_PACKET3(R128_CNTL_BITBLT_MULTI, 5));
+	OUT_RING(R128_GMC_SRC_PITCH_OFFSET_CNTL |
+		 R128_GMC_DST_PITCH_OFFSET_CNTL |
+		 R128_GMC_BRUSH_NONE |
+		 (dev_priv->depth_fmt << 8) |
+		 R128_GMC_SRC_DATATYPE_COLOR |
+		 R128_ROP3_S |
+		 R128_DP_SRC_SOURCE_MEMORY |
+		 R128_GMC_CLR_CMP_CNTL_DIS | R128_GMC_WR_MSK_DIS);
+
+	OUT_RING(dev_priv->depth_pitch_offset_c);
+	OUT_RING(dev_priv->span_pitch_offset_c);
+
+	OUT_RING((x << 16) | y);
+	OUT_RING((0 << 16) | 0);
+	OUT_RING((count << 16) | 1);
 
 	ADVANCE_RING();
 
 	return 0;
 }
 
-static int r128_cce_dispatch_read_pixels( drm_device_t *dev,
-					  drm_r128_depth_t *depth )
+static int r128_cce_dispatch_read_pixels(drm_device_t * dev,
+					 drm_r128_depth_t * depth)
 {
 	drm_r128_private_t *dev_priv = dev->dev_private;
 	int count, *x, *y;
 	int i, xbuf_size, ybuf_size;
 	RING_LOCALS;
-	DRM_DEBUG( "%s\n", __FUNCTION__ );
+	DRM_DEBUG("%s\n", __FUNCTION__);
 
 	count = depth->n;
 	if (count > 4096 || count <= 0)
 		return DRM_ERR(EMSGSIZE);
 
-	if ( count > dev_priv->depth_pitch ) {
+	if (count > dev_priv->depth_pitch) {
 		count = dev_priv->depth_pitch;
 	}
 
 	xbuf_size = count * sizeof(*x);
 	ybuf_size = count * sizeof(*y);
-	x = drm_alloc( xbuf_size, DRM_MEM_BUFS );
-	if ( x == NULL ) {
+	x = drm_alloc(xbuf_size, DRM_MEM_BUFS);
+	if (x == NULL) {
 		return DRM_ERR(ENOMEM);
 	}
-	y = drm_alloc( ybuf_size, DRM_MEM_BUFS );
-	if ( y == NULL ) {
-		drm_free( x, xbuf_size, DRM_MEM_BUFS );
+	y = drm_alloc(ybuf_size, DRM_MEM_BUFS);
+	if (y == NULL) {
+		drm_free(x, xbuf_size, DRM_MEM_BUFS);
 		return DRM_ERR(ENOMEM);
 	}
-	if ( DRM_COPY_FROM_USER( x, depth->x, xbuf_size ) ) {
-		drm_free( x, xbuf_size, DRM_MEM_BUFS );
-		drm_free( y, ybuf_size, DRM_MEM_BUFS );
+	if (DRM_COPY_FROM_USER(x, depth->x, xbuf_size)) {
+		drm_free(x, xbuf_size, DRM_MEM_BUFS);
+		drm_free(y, ybuf_size, DRM_MEM_BUFS);
 		return DRM_ERR(EFAULT);
 	}
-	if ( DRM_COPY_FROM_USER( y, depth->y, ybuf_size ) ) {
-		drm_free( x, xbuf_size, DRM_MEM_BUFS );
-		drm_free( y, ybuf_size, DRM_MEM_BUFS );
+	if (DRM_COPY_FROM_USER(y, depth->y, ybuf_size)) {
+		drm_free(x, xbuf_size, DRM_MEM_BUFS);
+		drm_free(y, ybuf_size, DRM_MEM_BUFS);
 		return DRM_ERR(EFAULT);
 	}
 
-	for ( i = 0 ; i < count ; i++ ) {
-		BEGIN_RING( 7 );
+	for (i = 0; i < count; i++) {
+		BEGIN_RING(7);
 
-		OUT_RING( CCE_PACKET3( R128_CNTL_BITBLT_MULTI, 5 ) );
-		OUT_RING( R128_GMC_SRC_PITCH_OFFSET_CNTL |
-			  R128_GMC_DST_PITCH_OFFSET_CNTL |
-			  R128_GMC_BRUSH_NONE |
-			  (dev_priv->depth_fmt << 8) |
-			  R128_GMC_SRC_DATATYPE_COLOR |
-			  R128_ROP3_S |
-			  R128_DP_SRC_SOURCE_MEMORY |
-			  R128_GMC_CLR_CMP_CNTL_DIS |
-			  R128_GMC_WR_MSK_DIS );
-
-		OUT_RING( dev_priv->depth_pitch_offset_c );
-		OUT_RING( dev_priv->span_pitch_offset_c );
-
-		OUT_RING( (x[i] << 16) | y[i] );
-		OUT_RING( (i << 16) | 0 );
-		OUT_RING( (1 << 16) | 1 );
+		OUT_RING(CCE_PACKET3(R128_CNTL_BITBLT_MULTI, 5));
+		OUT_RING(R128_GMC_SRC_PITCH_OFFSET_CNTL |
+			 R128_GMC_DST_PITCH_OFFSET_CNTL |
+			 R128_GMC_BRUSH_NONE |
+			 (dev_priv->depth_fmt << 8) |
+			 R128_GMC_SRC_DATATYPE_COLOR |
+			 R128_ROP3_S |
+			 R128_DP_SRC_SOURCE_MEMORY |
+			 R128_GMC_CLR_CMP_CNTL_DIS | R128_GMC_WR_MSK_DIS);
+
+		OUT_RING(dev_priv->depth_pitch_offset_c);
+		OUT_RING(dev_priv->span_pitch_offset_c);
+
+		OUT_RING((x[i] << 16) | y[i]);
+		OUT_RING((i << 16) | 0);
+		OUT_RING((1 << 16) | 1);
 
 		ADVANCE_RING();
 	}
 
-	drm_free( x, xbuf_size, DRM_MEM_BUFS );
-	drm_free( y, ybuf_size, DRM_MEM_BUFS );
+	drm_free(x, xbuf_size, DRM_MEM_BUFS);
+	drm_free(y, ybuf_size, DRM_MEM_BUFS);
 
 	return 0;
 }
 
-
 /* ================================================================
  * Polygon stipple
  */
 
-static void r128_cce_dispatch_stipple( drm_device_t *dev, u32 *stipple )
+static void r128_cce_dispatch_stipple(drm_device_t * dev, u32 * stipple)
 {
 	drm_r128_private_t *dev_priv = dev->dev_private;
 	int i;
 	RING_LOCALS;
-	DRM_DEBUG( "%s\n", __FUNCTION__ );
+	DRM_DEBUG("%s\n", __FUNCTION__);
 
-	BEGIN_RING( 33 );
+	BEGIN_RING(33);
 
-	OUT_RING( CCE_PACKET0( R128_BRUSH_DATA0, 31 ) );
-	for ( i = 0 ; i < 32 ; i++ ) {
-		OUT_RING( stipple[i] );
+	OUT_RING(CCE_PACKET0(R128_BRUSH_DATA0, 31));
+	for (i = 0; i < 32; i++) {
+		OUT_RING(stipple[i]);
 	}
 
 	ADVANCE_RING();
 }
 
-
 /* ================================================================
  * IOCTL functions
  */
 
-static int r128_cce_clear( DRM_IOCTL_ARGS )
+static int r128_cce_clear(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_r128_private_t *dev_priv = dev->dev_private;
 	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
 	drm_r128_clear_t clear;
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	DRM_COPY_FROM_USER_IOCTL( clear, (drm_r128_clear_t __user *) data,
-			     sizeof(clear) );
+	DRM_COPY_FROM_USER_IOCTL(clear, (drm_r128_clear_t __user *) data,
+				 sizeof(clear));
 
-	RING_SPACE_TEST_WITH_RETURN( dev_priv );
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
 
-	if ( sarea_priv->nbox > R128_NR_SAREA_CLIPRECTS )
+	if (sarea_priv->nbox > R128_NR_SAREA_CLIPRECTS)
 		sarea_priv->nbox = R128_NR_SAREA_CLIPRECTS;
 
-	r128_cce_dispatch_clear( dev, &clear );
+	r128_cce_dispatch_clear(dev, &clear);
 	COMMIT_RING();
 
 	/* Make sure we restore the 3D state next time.
@@ -1288,17 +1268,17 @@ static int r128_cce_clear( DRM_IOCTL_ARG
 	return 0;
 }
 
-static int r128_do_init_pageflip( drm_device_t *dev )
+static int r128_do_init_pageflip(drm_device_t * dev)
 {
 	drm_r128_private_t *dev_priv = dev->dev_private;
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
-	dev_priv->crtc_offset =      R128_READ( R128_CRTC_OFFSET );
-	dev_priv->crtc_offset_cntl = R128_READ( R128_CRTC_OFFSET_CNTL );
+	dev_priv->crtc_offset = R128_READ(R128_CRTC_OFFSET);
+	dev_priv->crtc_offset_cntl = R128_READ(R128_CRTC_OFFSET_CNTL);
 
-	R128_WRITE( R128_CRTC_OFFSET, dev_priv->front_offset );
-	R128_WRITE( R128_CRTC_OFFSET_CNTL,
-		    dev_priv->crtc_offset_cntl | R128_CRTC_OFFSET_FLIP_CNTL );
+	R128_WRITE(R128_CRTC_OFFSET, dev_priv->front_offset);
+	R128_WRITE(R128_CRTC_OFFSET_CNTL,
+		   dev_priv->crtc_offset_cntl | R128_CRTC_OFFSET_FLIP_CNTL);
 
 	dev_priv->page_flipping = 1;
 	dev_priv->current_page = 0;
@@ -1307,16 +1287,16 @@ static int r128_do_init_pageflip( drm_de
 	return 0;
 }
 
-int r128_do_cleanup_pageflip( drm_device_t *dev )
+static int r128_do_cleanup_pageflip(drm_device_t * dev)
 {
 	drm_r128_private_t *dev_priv = dev->dev_private;
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
-	R128_WRITE( R128_CRTC_OFFSET,      dev_priv->crtc_offset );
-	R128_WRITE( R128_CRTC_OFFSET_CNTL, dev_priv->crtc_offset_cntl );
+	R128_WRITE(R128_CRTC_OFFSET, dev_priv->crtc_offset);
+	R128_WRITE(R128_CRTC_OFFSET_CNTL, dev_priv->crtc_offset_cntl);
 
 	if (dev_priv->current_page != 0) {
-		r128_cce_dispatch_flip( dev );
+		r128_cce_dispatch_flip(dev);
 		COMMIT_RING();
 	}
 
@@ -1325,43 +1305,43 @@ int r128_do_cleanup_pageflip( drm_device
 }
 
 /* Swapping and flipping are different operations, need different ioctls.
- * They can & should be intermixed to support multiple 3d windows.  
+ * They can & should be intermixed to support multiple 3d windows.
  */
 
-static int r128_cce_flip( DRM_IOCTL_ARGS )
+static int r128_cce_flip(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_r128_private_t *dev_priv = dev->dev_private;
-	DRM_DEBUG( "%s\n", __FUNCTION__ );
+	DRM_DEBUG("%s\n", __FUNCTION__);
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	RING_SPACE_TEST_WITH_RETURN( dev_priv );
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
 
-	if (!dev_priv->page_flipping) 
-		r128_do_init_pageflip( dev );
+	if (!dev_priv->page_flipping)
+		r128_do_init_pageflip(dev);
 
-	r128_cce_dispatch_flip( dev );
+	r128_cce_dispatch_flip(dev);
 
 	COMMIT_RING();
 	return 0;
 }
 
-static int r128_cce_swap( DRM_IOCTL_ARGS )
+static int r128_cce_swap(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_r128_private_t *dev_priv = dev->dev_private;
 	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
-	DRM_DEBUG( "%s\n", __FUNCTION__ );
+	DRM_DEBUG("%s\n", __FUNCTION__);
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	RING_SPACE_TEST_WITH_RETURN( dev_priv );
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
 
-	if ( sarea_priv->nbox > R128_NR_SAREA_CLIPRECTS )
+	if (sarea_priv->nbox > R128_NR_SAREA_CLIPRECTS)
 		sarea_priv->nbox = R128_NR_SAREA_CLIPRECTS;
 
-	r128_cce_dispatch_swap( dev );
+	r128_cce_dispatch_swap(dev);
 	dev_priv->sarea_priv->dirty |= (R128_UPLOAD_CONTEXT |
 					R128_UPLOAD_MASKS);
 
@@ -1369,7 +1349,7 @@ static int r128_cce_swap( DRM_IOCTL_ARGS
 	return 0;
 }
 
-static int r128_cce_vertex( DRM_IOCTL_ARGS )
+static int r128_cce_vertex(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_r128_private_t *dev_priv = dev->dev_private;
@@ -1378,44 +1358,43 @@ static int r128_cce_vertex( DRM_IOCTL_AR
 	drm_r128_buf_priv_t *buf_priv;
 	drm_r128_vertex_t vertex;
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	if ( !dev_priv ) {
-		DRM_ERROR( "%s called with no initialization\n", __FUNCTION__ );
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
 		return DRM_ERR(EINVAL);
 	}
 
-	DRM_COPY_FROM_USER_IOCTL( vertex, (drm_r128_vertex_t __user *) data,
-			     sizeof(vertex) );
+	DRM_COPY_FROM_USER_IOCTL(vertex, (drm_r128_vertex_t __user *) data,
+				 sizeof(vertex));
 
-	DRM_DEBUG( "pid=%d index=%d count=%d discard=%d\n",
-		   DRM_CURRENTPID,
-		   vertex.idx, vertex.count, vertex.discard );
+	DRM_DEBUG("pid=%d index=%d count=%d discard=%d\n",
+		  DRM_CURRENTPID, vertex.idx, vertex.count, vertex.discard);
 
-	if ( vertex.idx < 0 || vertex.idx >= dma->buf_count ) {
-		DRM_ERROR( "buffer index %d (of %d max)\n",
-			   vertex.idx, dma->buf_count - 1 );
+	if (vertex.idx < 0 || vertex.idx >= dma->buf_count) {
+		DRM_ERROR("buffer index %d (of %d max)\n",
+			  vertex.idx, dma->buf_count - 1);
 		return DRM_ERR(EINVAL);
 	}
-	if ( vertex.prim < 0 ||
-	     vertex.prim > R128_CCE_VC_CNTL_PRIM_TYPE_TRI_TYPE2 ) {
-		DRM_ERROR( "buffer prim %d\n", vertex.prim );
+	if (vertex.prim < 0 ||
+	    vertex.prim > R128_CCE_VC_CNTL_PRIM_TYPE_TRI_TYPE2) {
+		DRM_ERROR("buffer prim %d\n", vertex.prim);
 		return DRM_ERR(EINVAL);
 	}
 
-	RING_SPACE_TEST_WITH_RETURN( dev_priv );
-	VB_AGE_TEST_WITH_RETURN( dev_priv );
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
+	VB_AGE_TEST_WITH_RETURN(dev_priv);
 
 	buf = dma->buflist[vertex.idx];
 	buf_priv = buf->dev_private;
 
-	if ( buf->filp != filp ) {
-		DRM_ERROR( "process %d using buffer owned by %p\n",
-			   DRM_CURRENTPID, buf->filp );
+	if (buf->filp != filp) {
+		DRM_ERROR("process %d using buffer owned by %p\n",
+			  DRM_CURRENTPID, buf->filp);
 		return DRM_ERR(EINVAL);
 	}
-	if ( buf->pending ) {
-		DRM_ERROR( "sending pending buffer %d\n", vertex.idx );
+	if (buf->pending) {
+		DRM_ERROR("sending pending buffer %d\n", vertex.idx);
 		return DRM_ERR(EINVAL);
 	}
 
@@ -1423,13 +1402,13 @@ static int r128_cce_vertex( DRM_IOCTL_AR
 	buf_priv->prim = vertex.prim;
 	buf_priv->discard = vertex.discard;
 
-	r128_cce_dispatch_vertex( dev, buf );
+	r128_cce_dispatch_vertex(dev, buf);
 
 	COMMIT_RING();
 	return 0;
 }
 
-static int r128_cce_indices( DRM_IOCTL_ARGS )
+static int r128_cce_indices(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_r128_private_t *dev_priv = dev->dev_private;
@@ -1439,55 +1418,54 @@ static int r128_cce_indices( DRM_IOCTL_A
 	drm_r128_indices_t elts;
 	int count;
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	if ( !dev_priv ) {
-		DRM_ERROR( "%s called with no initialization\n", __FUNCTION__ );
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
 		return DRM_ERR(EINVAL);
 	}
 
-	DRM_COPY_FROM_USER_IOCTL( elts, (drm_r128_indices_t __user *) data,
-			     sizeof(elts) );
+	DRM_COPY_FROM_USER_IOCTL(elts, (drm_r128_indices_t __user *) data,
+				 sizeof(elts));
 
-	DRM_DEBUG( "pid=%d buf=%d s=%d e=%d d=%d\n", DRM_CURRENTPID,
-		   elts.idx, elts.start, elts.end, elts.discard );
+	DRM_DEBUG("pid=%d buf=%d s=%d e=%d d=%d\n", DRM_CURRENTPID,
+		  elts.idx, elts.start, elts.end, elts.discard);
 
-	if ( elts.idx < 0 || elts.idx >= dma->buf_count ) {
-		DRM_ERROR( "buffer index %d (of %d max)\n",
-			   elts.idx, dma->buf_count - 1 );
+	if (elts.idx < 0 || elts.idx >= dma->buf_count) {
+		DRM_ERROR("buffer index %d (of %d max)\n",
+			  elts.idx, dma->buf_count - 1);
 		return DRM_ERR(EINVAL);
 	}
-	if ( elts.prim < 0 ||
-	     elts.prim > R128_CCE_VC_CNTL_PRIM_TYPE_TRI_TYPE2 ) {
-		DRM_ERROR( "buffer prim %d\n", elts.prim );
+	if (elts.prim < 0 || elts.prim > R128_CCE_VC_CNTL_PRIM_TYPE_TRI_TYPE2) {
+		DRM_ERROR("buffer prim %d\n", elts.prim);
 		return DRM_ERR(EINVAL);
 	}
 
-	RING_SPACE_TEST_WITH_RETURN( dev_priv );
-	VB_AGE_TEST_WITH_RETURN( dev_priv );
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
+	VB_AGE_TEST_WITH_RETURN(dev_priv);
 
 	buf = dma->buflist[elts.idx];
 	buf_priv = buf->dev_private;
 
-	if ( buf->filp != filp ) {
-		DRM_ERROR( "process %d using buffer owned by %p\n",
-			   DRM_CURRENTPID, buf->filp );
+	if (buf->filp != filp) {
+		DRM_ERROR("process %d using buffer owned by %p\n",
+			  DRM_CURRENTPID, buf->filp);
 		return DRM_ERR(EINVAL);
 	}
-	if ( buf->pending ) {
-		DRM_ERROR( "sending pending buffer %d\n", elts.idx );
+	if (buf->pending) {
+		DRM_ERROR("sending pending buffer %d\n", elts.idx);
 		return DRM_ERR(EINVAL);
 	}
 
 	count = (elts.end - elts.start) / sizeof(u16);
 	elts.start -= R128_INDEX_PRIM_OFFSET;
 
-	if ( elts.start & 0x7 ) {
-		DRM_ERROR( "misaligned buffer 0x%x\n", elts.start );
+	if (elts.start & 0x7) {
+		DRM_ERROR("misaligned buffer 0x%x\n", elts.start);
 		return DRM_ERR(EINVAL);
 	}
-	if ( elts.start < buf->used ) {
-		DRM_ERROR( "no header 0x%x - 0x%x\n", elts.start, buf->used );
+	if (elts.start < buf->used) {
+		DRM_ERROR("no header 0x%x - 0x%x\n", elts.start, buf->used);
 		return DRM_ERR(EINVAL);
 	}
 
@@ -1495,13 +1473,13 @@ static int r128_cce_indices( DRM_IOCTL_A
 	buf_priv->prim = elts.prim;
 	buf_priv->discard = elts.discard;
 
-	r128_cce_dispatch_indices( dev, buf, elts.start, elts.end, count );
+	r128_cce_dispatch_indices(dev, buf, elts.start, elts.end, count);
 
 	COMMIT_RING();
 	return 0;
 }
 
-static int r128_cce_blit( DRM_IOCTL_ARGS )
+static int r128_cce_blit(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_device_dma_t *dma = dev->dma;
@@ -1509,87 +1487,82 @@ static int r128_cce_blit( DRM_IOCTL_ARGS
 	drm_r128_blit_t blit;
 	int ret;
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	DRM_COPY_FROM_USER_IOCTL( blit, (drm_r128_blit_t __user *) data,
-			     sizeof(blit) );
+	DRM_COPY_FROM_USER_IOCTL(blit, (drm_r128_blit_t __user *) data,
+				 sizeof(blit));
 
-	DRM_DEBUG( "pid=%d index=%d\n", DRM_CURRENTPID, blit.idx );
+	DRM_DEBUG("pid=%d index=%d\n", DRM_CURRENTPID, blit.idx);
 
-	if ( blit.idx < 0 || blit.idx >= dma->buf_count ) {
-		DRM_ERROR( "buffer index %d (of %d max)\n",
-			   blit.idx, dma->buf_count - 1 );
+	if (blit.idx < 0 || blit.idx >= dma->buf_count) {
+		DRM_ERROR("buffer index %d (of %d max)\n",
+			  blit.idx, dma->buf_count - 1);
 		return DRM_ERR(EINVAL);
 	}
 
-	RING_SPACE_TEST_WITH_RETURN( dev_priv );
-	VB_AGE_TEST_WITH_RETURN( dev_priv );
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
+	VB_AGE_TEST_WITH_RETURN(dev_priv);
 
-	ret = r128_cce_dispatch_blit( filp, dev, &blit );
+	ret = r128_cce_dispatch_blit(filp, dev, &blit);
 
 	COMMIT_RING();
 	return ret;
 }
 
-static int r128_cce_depth( DRM_IOCTL_ARGS )
+static int r128_cce_depth(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_r128_private_t *dev_priv = dev->dev_private;
 	drm_r128_depth_t depth;
 	int ret;
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	DRM_COPY_FROM_USER_IOCTL( depth, (drm_r128_depth_t __user *) data,
-			     sizeof(depth) );
+	DRM_COPY_FROM_USER_IOCTL(depth, (drm_r128_depth_t __user *) data,
+				 sizeof(depth));
 
-	RING_SPACE_TEST_WITH_RETURN( dev_priv );
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
 
 	ret = DRM_ERR(EINVAL);
-	switch ( depth.func ) {
+	switch (depth.func) {
 	case R128_WRITE_SPAN:
-		ret = r128_cce_dispatch_write_span( dev, &depth );
-		break;
+		ret = r128_cce_dispatch_write_span(dev, &depth);
 	case R128_WRITE_PIXELS:
-		ret = r128_cce_dispatch_write_pixels( dev, &depth );
-		break;
+		ret = r128_cce_dispatch_write_pixels(dev, &depth);
 	case R128_READ_SPAN:
-		ret = r128_cce_dispatch_read_span( dev, &depth );
-		break;
+		ret = r128_cce_dispatch_read_span(dev, &depth);
 	case R128_READ_PIXELS:
-		ret = r128_cce_dispatch_read_pixels( dev, &depth );
-		break;
+		ret = r128_cce_dispatch_read_pixels(dev, &depth);
 	}
 
 	COMMIT_RING();
 	return ret;
 }
 
-static int r128_cce_stipple( DRM_IOCTL_ARGS )
+static int r128_cce_stipple(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_r128_private_t *dev_priv = dev->dev_private;
 	drm_r128_stipple_t stipple;
 	u32 mask[32];
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	DRM_COPY_FROM_USER_IOCTL( stipple, (drm_r128_stipple_t __user *) data,
-			     sizeof(stipple) );
+	DRM_COPY_FROM_USER_IOCTL(stipple, (drm_r128_stipple_t __user *) data,
+				 sizeof(stipple));
 
-	if ( DRM_COPY_FROM_USER( &mask, stipple.mask,
-			     32 * sizeof(u32) ) )
-		return DRM_ERR( EFAULT );
+	if (DRM_COPY_FROM_USER(&mask, stipple.mask, 32 * sizeof(u32)))
+		return DRM_ERR(EFAULT);
 
-	RING_SPACE_TEST_WITH_RETURN( dev_priv );
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
 
-	r128_cce_dispatch_stipple( dev, mask );
+	r128_cce_dispatch_stipple(dev, mask);
 
 	COMMIT_RING();
 	return 0;
 }
 
-static int r128_cce_indirect( DRM_IOCTL_ARGS )
+static int r128_cce_indirect(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_r128_private_t *dev_priv = dev->dev_private;
@@ -1601,47 +1574,46 @@ static int r128_cce_indirect( DRM_IOCTL_
 	RING_LOCALS;
 #endif
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	if ( !dev_priv ) {
-		DRM_ERROR( "%s called with no initialization\n", __FUNCTION__ );
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
 		return DRM_ERR(EINVAL);
 	}
 
-	DRM_COPY_FROM_USER_IOCTL( indirect, (drm_r128_indirect_t __user *) data,
-			     sizeof(indirect) );
+	DRM_COPY_FROM_USER_IOCTL(indirect, (drm_r128_indirect_t __user *) data,
+				 sizeof(indirect));
 
-	DRM_DEBUG( "indirect: idx=%d s=%d e=%d d=%d\n",
-		   indirect.idx, indirect.start,
-		   indirect.end, indirect.discard );
+	DRM_DEBUG("indirect: idx=%d s=%d e=%d d=%d\n",
+		  indirect.idx, indirect.start, indirect.end, indirect.discard);
 
-	if ( indirect.idx < 0 || indirect.idx >= dma->buf_count ) {
-		DRM_ERROR( "buffer index %d (of %d max)\n",
-			   indirect.idx, dma->buf_count - 1 );
+	if (indirect.idx < 0 || indirect.idx >= dma->buf_count) {
+		DRM_ERROR("buffer index %d (of %d max)\n",
+			  indirect.idx, dma->buf_count - 1);
 		return DRM_ERR(EINVAL);
 	}
 
 	buf = dma->buflist[indirect.idx];
 	buf_priv = buf->dev_private;
 
-	if ( buf->filp != filp ) {
-		DRM_ERROR( "process %d using buffer owned by %p\n",
-			   DRM_CURRENTPID, buf->filp );
+	if (buf->filp != filp) {
+		DRM_ERROR("process %d using buffer owned by %p\n",
+			  DRM_CURRENTPID, buf->filp);
 		return DRM_ERR(EINVAL);
 	}
-	if ( buf->pending ) {
-		DRM_ERROR( "sending pending buffer %d\n", indirect.idx );
+	if (buf->pending) {
+		DRM_ERROR("sending pending buffer %d\n", indirect.idx);
 		return DRM_ERR(EINVAL);
 	}
 
-	if ( indirect.start < buf->used ) {
-		DRM_ERROR( "reusing indirect: start=0x%x actual=0x%x\n",
-			   indirect.start, buf->used );
+	if (indirect.start < buf->used) {
+		DRM_ERROR("reusing indirect: start=0x%x actual=0x%x\n",
+			  indirect.start, buf->used);
 		return DRM_ERR(EINVAL);
 	}
 
-	RING_SPACE_TEST_WITH_RETURN( dev_priv );
-	VB_AGE_TEST_WITH_RETURN( dev_priv );
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
+	VB_AGE_TEST_WITH_RETURN(dev_priv);
 
 	buf->used = indirect.end;
 	buf_priv->discard = indirect.discard;
@@ -1650,7 +1622,7 @@ static int r128_cce_indirect( DRM_IOCTL_
 	/* Wait for the 3D stream to idle before the indirect buffer
 	 * containing 2D acceleration commands is processed.
 	 */
-	BEGIN_RING( 2 );
+	BEGIN_RING(2);
 	RADEON_WAIT_UNTIL_3D_IDLE();
 	ADVANCE_RING();
 #endif
@@ -1659,30 +1631,30 @@ static int r128_cce_indirect( DRM_IOCTL_
 	 * X server.  This is insecure and is thus only available to
 	 * privileged clients.
 	 */
-	r128_cce_dispatch_indirect( dev, buf, indirect.start, indirect.end );
+	r128_cce_dispatch_indirect(dev, buf, indirect.start, indirect.end);
 
 	COMMIT_RING();
 	return 0;
 }
 
-static int r128_getparam( DRM_IOCTL_ARGS )
+static int r128_getparam(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_r128_private_t *dev_priv = dev->dev_private;
 	drm_r128_getparam_t param;
 	int value;
 
-	if ( !dev_priv ) {
-		DRM_ERROR( "%s called with no initialization\n", __FUNCTION__ );
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
 		return DRM_ERR(EINVAL);
 	}
 
-	DRM_COPY_FROM_USER_IOCTL( param, (drm_r128_getparam_t __user *)data,
-			     sizeof(param) );
+	DRM_COPY_FROM_USER_IOCTL(param, (drm_r128_getparam_t __user *) data,
+				 sizeof(param));
 
-	DRM_DEBUG( "pid=%d\n", DRM_CURRENTPID );
+	DRM_DEBUG("pid=%d\n", DRM_CURRENTPID);
 
-	switch( param.param ) {
+	switch (param.param) {
 	case R128_PARAM_IRQ_NR:
 		value = dev->irq;
 		break;
@@ -1690,47 +1662,47 @@ static int r128_getparam( DRM_IOCTL_ARGS
 		return DRM_ERR(EINVAL);
 	}
 
-	if ( DRM_COPY_TO_USER( param.value, &value, sizeof(int) ) ) {
-		DRM_ERROR( "copy_to_user\n" );
+	if (DRM_COPY_TO_USER(param.value, &value, sizeof(int))) {
+		DRM_ERROR("copy_to_user\n");
 		return DRM_ERR(EFAULT);
 	}
-	
+
 	return 0;
 }
 
-void r128_driver_prerelease(drm_device_t *dev, DRMFILE filp)
+void r128_driver_prerelease(drm_device_t * dev, DRMFILE filp)
 {
-	if ( dev->dev_private ) {
+	if (dev->dev_private) {
 		drm_r128_private_t *dev_priv = dev->dev_private;
-		if ( dev_priv->page_flipping ) {
-			r128_do_cleanup_pageflip( dev );
+		if (dev_priv->page_flipping) {
+			r128_do_cleanup_pageflip(dev);
 		}
-	}			
+	}
 }
 
-void r128_driver_pretakedown(drm_device_t *dev)
+void r128_driver_pretakedown(drm_device_t * dev)
 {
-	r128_do_cleanup_cce( dev );
+	r128_do_cleanup_cce(dev);
 }
 
 drm_ioctl_desc_t r128_ioctls[] = {
-	[DRM_IOCTL_NR(DRM_R128_INIT)]       = { r128_cce_init,     1, 1 },
-	[DRM_IOCTL_NR(DRM_R128_CCE_START)]  = { r128_cce_start,    1, 1 },
-	[DRM_IOCTL_NR(DRM_R128_CCE_STOP)]   = { r128_cce_stop,     1, 1 },
-	[DRM_IOCTL_NR(DRM_R128_CCE_RESET)]  = { r128_cce_reset,    1, 1 },
-	[DRM_IOCTL_NR(DRM_R128_CCE_IDLE)]   = { r128_cce_idle,     1, 0 },
-	[DRM_IOCTL_NR(DRM_R128_RESET)]      = { r128_engine_reset, 1, 0 },
-	[DRM_IOCTL_NR(DRM_R128_FULLSCREEN)] = { r128_fullscreen,   1, 0 },
-	[DRM_IOCTL_NR(DRM_R128_SWAP)]       = { r128_cce_swap,     1, 0 },
-	[DRM_IOCTL_NR(DRM_R128_FLIP)]       = { r128_cce_flip,     1, 0 },
-	[DRM_IOCTL_NR(DRM_R128_CLEAR)]      = { r128_cce_clear,    1, 0 },
-	[DRM_IOCTL_NR(DRM_R128_VERTEX)]     = { r128_cce_vertex,   1, 0 },
-	[DRM_IOCTL_NR(DRM_R128_INDICES)]    = { r128_cce_indices,  1, 0 },
-	[DRM_IOCTL_NR(DRM_R128_BLIT)]       = { r128_cce_blit,     1, 0 },
-	[DRM_IOCTL_NR(DRM_R128_DEPTH)]      = { r128_cce_depth,    1, 0 },
-	[DRM_IOCTL_NR(DRM_R128_STIPPLE)]    = { r128_cce_stipple,  1, 0 },
-	[DRM_IOCTL_NR(DRM_R128_INDIRECT)]   = { r128_cce_indirect, 1, 1 },
-	[DRM_IOCTL_NR(DRM_R128_GETPARAM)]   = { r128_getparam, 1, 0 },
+	[DRM_IOCTL_NR(DRM_R128_INIT)] = {r128_cce_init, 1, 1},
+	[DRM_IOCTL_NR(DRM_R128_CCE_START)] = {r128_cce_start, 1, 1},
+	[DRM_IOCTL_NR(DRM_R128_CCE_STOP)] = {r128_cce_stop, 1, 1},
+	[DRM_IOCTL_NR(DRM_R128_CCE_RESET)] = {r128_cce_reset, 1, 1},
+	[DRM_IOCTL_NR(DRM_R128_CCE_IDLE)] = {r128_cce_idle, 1, 0},
+	[DRM_IOCTL_NR(DRM_R128_RESET)] = {r128_engine_reset, 1, 0},
+	[DRM_IOCTL_NR(DRM_R128_FULLSCREEN)] = {r128_fullscreen, 1, 0},
+	[DRM_IOCTL_NR(DRM_R128_SWAP)] = {r128_cce_swap, 1, 0},
+	[DRM_IOCTL_NR(DRM_R128_FLIP)] = {r128_cce_flip, 1, 0},
+	[DRM_IOCTL_NR(DRM_R128_CLEAR)] = {r128_cce_clear, 1, 0},
+	[DRM_IOCTL_NR(DRM_R128_VERTEX)] = {r128_cce_vertex, 1, 0},
+	[DRM_IOCTL_NR(DRM_R128_INDICES)] = {r128_cce_indices, 1, 0},
+	[DRM_IOCTL_NR(DRM_R128_BLIT)] = {r128_cce_blit, 1, 0},
+	[DRM_IOCTL_NR(DRM_R128_DEPTH)] = {r128_cce_depth, 1, 0},
+	[DRM_IOCTL_NR(DRM_R128_STIPPLE)] = {r128_cce_stipple, 1, 0},
+	[DRM_IOCTL_NR(DRM_R128_INDIRECT)] = {r128_cce_indirect, 1, 1},
+	[DRM_IOCTL_NR(DRM_R128_GETPARAM)] = {r128_getparam, 1, 0},
 };
 
 int r128_max_ioctl = DRM_ARRAY_SIZE(r128_ioctls);
diff -purN linux-2.6.12.orig/drivers/char/drm/radeon_cp.c linux-2.6.12/drivers/char/drm/radeon_cp.c
--- linux-2.6.12.orig/drivers/char/drm/radeon_cp.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/radeon_cp.c	2005-07-05 08:37:47.000000000 +0200
@@ -35,526 +35,525 @@
 
 #define RADEON_FIFO_DEBUG	0
 
-static int radeon_do_cleanup_cp( drm_device_t *dev );
+static int radeon_do_cleanup_cp(drm_device_t * dev);
 
 /* CP microcode (from ATI) */
 static u32 R200_cp_microcode[][2] = {
-	{ 0x21007000, 0000000000 },        
-	{ 0x20007000, 0000000000 }, 
-	{ 0x000000ab, 0x00000004 },
-	{ 0x000000af, 0x00000004 },
-	{ 0x66544a49, 0000000000 },
-	{ 0x49494174, 0000000000 },
-	{ 0x54517d83, 0000000000 },
-	{ 0x498d8b64, 0000000000 },
-	{ 0x49494949, 0000000000 },
-	{ 0x49da493c, 0000000000 },
-	{ 0x49989898, 0000000000 },
-	{ 0xd34949d5, 0000000000 },
-	{ 0x9dc90e11, 0000000000 },
-	{ 0xce9b9b9b, 0000000000 },
-	{ 0x000f0000, 0x00000016 },
-	{ 0x352e232c, 0000000000 },
-	{ 0x00000013, 0x00000004 },
-	{ 0x000f0000, 0x00000016 },
-	{ 0x352e272c, 0000000000 },
-	{ 0x000f0001, 0x00000016 },
-	{ 0x3239362f, 0000000000 },
-	{ 0x000077ef, 0x00000002 },
-	{ 0x00061000, 0x00000002 },
-	{ 0x00000020, 0x0000001a },
-	{ 0x00004000, 0x0000001e },
-	{ 0x00061000, 0x00000002 },
-	{ 0x00000020, 0x0000001a },
-	{ 0x00004000, 0x0000001e },
-	{ 0x00061000, 0x00000002 },
-	{ 0x00000020, 0x0000001a },
-	{ 0x00004000, 0x0000001e },
-	{ 0x00000016, 0x00000004 },
-	{ 0x0003802a, 0x00000002 },
-	{ 0x040067e0, 0x00000002 },
-	{ 0x00000016, 0x00000004 },
-	{ 0x000077e0, 0x00000002 },
-	{ 0x00065000, 0x00000002 },
-	{ 0x000037e1, 0x00000002 },
-	{ 0x040067e1, 0x00000006 },
-	{ 0x000077e0, 0x00000002 },
-	{ 0x000077e1, 0x00000002 },
-	{ 0x000077e1, 0x00000006 },
-	{ 0xffffffff, 0000000000 },
-	{ 0x10000000, 0000000000 },
-	{ 0x0003802a, 0x00000002 },
-	{ 0x040067e0, 0x00000006 },
-	{ 0x00007675, 0x00000002 },
-	{ 0x00007676, 0x00000002 },
-	{ 0x00007677, 0x00000002 },
-	{ 0x00007678, 0x00000006 },
-	{ 0x0003802b, 0x00000002 },
-	{ 0x04002676, 0x00000002 },
-	{ 0x00007677, 0x00000002 },
-	{ 0x00007678, 0x00000006 },
-	{ 0x0000002e, 0x00000018 },
-	{ 0x0000002e, 0x00000018 },
-	{ 0000000000, 0x00000006 },
-	{ 0x0000002f, 0x00000018 },
-	{ 0x0000002f, 0x00000018 },
-	{ 0000000000, 0x00000006 },
-	{ 0x01605000, 0x00000002 },
-	{ 0x00065000, 0x00000002 },
-	{ 0x00098000, 0x00000002 },
-	{ 0x00061000, 0x00000002 },
-	{ 0x64c0603d, 0x00000004 },
-	{ 0x00080000, 0x00000016 },
-	{ 0000000000, 0000000000 },
-	{ 0x0400251d, 0x00000002 },
-	{ 0x00007580, 0x00000002 },
-	{ 0x00067581, 0x00000002 },
-	{ 0x04002580, 0x00000002 },
-	{ 0x00067581, 0x00000002 },
-	{ 0x00000046, 0x00000004 },
-	{ 0x00005000, 0000000000 },
-	{ 0x00061000, 0x00000002 },
-	{ 0x0000750e, 0x00000002 },
-	{ 0x00019000, 0x00000002 },
-	{ 0x00011055, 0x00000014 },
-	{ 0x00000055, 0x00000012 },
-	{ 0x0400250f, 0x00000002 },
-	{ 0x0000504a, 0x00000004 },
-	{ 0x00007565, 0x00000002 },
-	{ 0x00007566, 0x00000002 },
-	{ 0x00000051, 0x00000004 },
-	{ 0x01e655b4, 0x00000002 },
-	{ 0x4401b0dc, 0x00000002 },
-	{ 0x01c110dc, 0x00000002 },
-	{ 0x2666705d, 0x00000018 },
-	{ 0x040c2565, 0x00000002 },
-	{ 0x0000005d, 0x00000018 },
-	{ 0x04002564, 0x00000002 },
-	{ 0x00007566, 0x00000002 },
-	{ 0x00000054, 0x00000004 },
-	{ 0x00401060, 0x00000008 },
-	{ 0x00101000, 0x00000002 },
-	{ 0x000d80ff, 0x00000002 },
-	{ 0x00800063, 0x00000008 },
-	{ 0x000f9000, 0x00000002 },
-	{ 0x000e00ff, 0x00000002 },
-	{ 0000000000, 0x00000006 },
-	{ 0x00000080, 0x00000018 },
-	{ 0x00000054, 0x00000004 },
-	{ 0x00007576, 0x00000002 },
-	{ 0x00065000, 0x00000002 },
-	{ 0x00009000, 0x00000002 },
-	{ 0x00041000, 0x00000002 },
-	{ 0x0c00350e, 0x00000002 },
-	{ 0x00049000, 0x00000002 },
-	{ 0x00051000, 0x00000002 },
-	{ 0x01e785f8, 0x00000002 },
-	{ 0x00200000, 0x00000002 },
-	{ 0x00600073, 0x0000000c },
-	{ 0x00007563, 0x00000002 },
-	{ 0x006075f0, 0x00000021 },
-	{ 0x20007068, 0x00000004 },
-	{ 0x00005068, 0x00000004 },
-	{ 0x00007576, 0x00000002 },
-	{ 0x00007577, 0x00000002 },
-	{ 0x0000750e, 0x00000002 },
-	{ 0x0000750f, 0x00000002 },
-	{ 0x00a05000, 0x00000002 },
-	{ 0x00600076, 0x0000000c },
-	{ 0x006075f0, 0x00000021 },
-	{ 0x000075f8, 0x00000002 },
-	{ 0x00000076, 0x00000004 },
-	{ 0x000a750e, 0x00000002 },
-	{ 0x0020750f, 0x00000002 },
-	{ 0x00600079, 0x00000004 },
-	{ 0x00007570, 0x00000002 },
-	{ 0x00007571, 0x00000002 },
-	{ 0x00007572, 0x00000006 },
-	{ 0x00005000, 0x00000002 },
-	{ 0x00a05000, 0x00000002 },
-	{ 0x00007568, 0x00000002 },
-	{ 0x00061000, 0x00000002 },
-	{ 0x00000084, 0x0000000c },
-	{ 0x00058000, 0x00000002 },
-	{ 0x0c607562, 0x00000002 },
-	{ 0x00000086, 0x00000004 },
-	{ 0x00600085, 0x00000004 },
-	{ 0x400070dd, 0000000000 },
-	{ 0x000380dd, 0x00000002 },
-	{ 0x00000093, 0x0000001c },
-	{ 0x00065095, 0x00000018 },
-	{ 0x040025bb, 0x00000002 },
-	{ 0x00061096, 0x00000018 },
-	{ 0x040075bc, 0000000000 },
-	{ 0x000075bb, 0x00000002 },
-	{ 0x000075bc, 0000000000 },
-	{ 0x00090000, 0x00000006 },
-	{ 0x00090000, 0x00000002 },
-	{ 0x000d8002, 0x00000006 },
-	{ 0x00005000, 0x00000002 },
-	{ 0x00007821, 0x00000002 },
-	{ 0x00007800, 0000000000 },
-	{ 0x00007821, 0x00000002 },
-	{ 0x00007800, 0000000000 },
-	{ 0x01665000, 0x00000002 },
-	{ 0x000a0000, 0x00000002 },
-	{ 0x000671cc, 0x00000002 },
-	{ 0x0286f1cd, 0x00000002 },
-	{ 0x000000a3, 0x00000010 },
-	{ 0x21007000, 0000000000 },
-	{ 0x000000aa, 0x0000001c },
-	{ 0x00065000, 0x00000002 },
-	{ 0x000a0000, 0x00000002 },
-	{ 0x00061000, 0x00000002 },
-	{ 0x000b0000, 0x00000002 },
-	{ 0x38067000, 0x00000002 },
-	{ 0x000a00a6, 0x00000004 },
-	{ 0x20007000, 0000000000 },
-	{ 0x01200000, 0x00000002 },
-	{ 0x20077000, 0x00000002 },
-	{ 0x01200000, 0x00000002 },
-	{ 0x20007000, 0000000000 },
-	{ 0x00061000, 0x00000002 },
-	{ 0x0120751b, 0x00000002 },
-	{ 0x8040750a, 0x00000002 },
-	{ 0x8040750b, 0x00000002 },
-	{ 0x00110000, 0x00000002 },
-	{ 0x000380dd, 0x00000002 },
-	{ 0x000000bd, 0x0000001c },
-	{ 0x00061096, 0x00000018 },
-	{ 0x844075bd, 0x00000002 },
-	{ 0x00061095, 0x00000018 },
-	{ 0x840075bb, 0x00000002 },
-	{ 0x00061096, 0x00000018 },
-	{ 0x844075bc, 0x00000002 },
-	{ 0x000000c0, 0x00000004 },
-	{ 0x804075bd, 0x00000002 },
-	{ 0x800075bb, 0x00000002 },
-	{ 0x804075bc, 0x00000002 },
-	{ 0x00108000, 0x00000002 },
-	{ 0x01400000, 0x00000002 },
-	{ 0x006000c4, 0x0000000c },
-	{ 0x20c07000, 0x00000020 },
-	{ 0x000000c6, 0x00000012 },
-	{ 0x00800000, 0x00000006 },
-	{ 0x0080751d, 0x00000006 },
-	{ 0x000025bb, 0x00000002 },
-	{ 0x000040c0, 0x00000004 },
-	{ 0x0000775c, 0x00000002 },
-	{ 0x00a05000, 0x00000002 },
-	{ 0x00661000, 0x00000002 },
-	{ 0x0460275d, 0x00000020 },
-	{ 0x00004000, 0000000000 },
-	{ 0x00007999, 0x00000002 },
-	{ 0x00a05000, 0x00000002 },
-	{ 0x00661000, 0x00000002 },
-	{ 0x0460299b, 0x00000020 },
-	{ 0x00004000, 0000000000 },
-	{ 0x01e00830, 0x00000002 },
-	{ 0x21007000, 0000000000 },
-	{ 0x00005000, 0x00000002 },
-	{ 0x00038042, 0x00000002 },
-	{ 0x040025e0, 0x00000002 },
-	{ 0x000075e1, 0000000000 },
-	{ 0x00000001, 0000000000 },
-	{ 0x000380d9, 0x00000002 },
-	{ 0x04007394, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
+	{0x21007000, 0000000000},
+	{0x20007000, 0000000000},
+	{0x000000ab, 0x00000004},
+	{0x000000af, 0x00000004},
+	{0x66544a49, 0000000000},
+	{0x49494174, 0000000000},
+	{0x54517d83, 0000000000},
+	{0x498d8b64, 0000000000},
+	{0x49494949, 0000000000},
+	{0x49da493c, 0000000000},
+	{0x49989898, 0000000000},
+	{0xd34949d5, 0000000000},
+	{0x9dc90e11, 0000000000},
+	{0xce9b9b9b, 0000000000},
+	{0x000f0000, 0x00000016},
+	{0x352e232c, 0000000000},
+	{0x00000013, 0x00000004},
+	{0x000f0000, 0x00000016},
+	{0x352e272c, 0000000000},
+	{0x000f0001, 0x00000016},
+	{0x3239362f, 0000000000},
+	{0x000077ef, 0x00000002},
+	{0x00061000, 0x00000002},
+	{0x00000020, 0x0000001a},
+	{0x00004000, 0x0000001e},
+	{0x00061000, 0x00000002},
+	{0x00000020, 0x0000001a},
+	{0x00004000, 0x0000001e},
+	{0x00061000, 0x00000002},
+	{0x00000020, 0x0000001a},
+	{0x00004000, 0x0000001e},
+	{0x00000016, 0x00000004},
+	{0x0003802a, 0x00000002},
+	{0x040067e0, 0x00000002},
+	{0x00000016, 0x00000004},
+	{0x000077e0, 0x00000002},
+	{0x00065000, 0x00000002},
+	{0x000037e1, 0x00000002},
+	{0x040067e1, 0x00000006},
+	{0x000077e0, 0x00000002},
+	{0x000077e1, 0x00000002},
+	{0x000077e1, 0x00000006},
+	{0xffffffff, 0000000000},
+	{0x10000000, 0000000000},
+	{0x0003802a, 0x00000002},
+	{0x040067e0, 0x00000006},
+	{0x00007675, 0x00000002},
+	{0x00007676, 0x00000002},
+	{0x00007677, 0x00000002},
+	{0x00007678, 0x00000006},
+	{0x0003802b, 0x00000002},
+	{0x04002676, 0x00000002},
+	{0x00007677, 0x00000002},
+	{0x00007678, 0x00000006},
+	{0x0000002e, 0x00000018},
+	{0x0000002e, 0x00000018},
+	{0000000000, 0x00000006},
+	{0x0000002f, 0x00000018},
+	{0x0000002f, 0x00000018},
+	{0000000000, 0x00000006},
+	{0x01605000, 0x00000002},
+	{0x00065000, 0x00000002},
+	{0x00098000, 0x00000002},
+	{0x00061000, 0x00000002},
+	{0x64c0603d, 0x00000004},
+	{0x00080000, 0x00000016},
+	{0000000000, 0000000000},
+	{0x0400251d, 0x00000002},
+	{0x00007580, 0x00000002},
+	{0x00067581, 0x00000002},
+	{0x04002580, 0x00000002},
+	{0x00067581, 0x00000002},
+	{0x00000046, 0x00000004},
+	{0x00005000, 0000000000},
+	{0x00061000, 0x00000002},
+	{0x0000750e, 0x00000002},
+	{0x00019000, 0x00000002},
+	{0x00011055, 0x00000014},
+	{0x00000055, 0x00000012},
+	{0x0400250f, 0x00000002},
+	{0x0000504a, 0x00000004},
+	{0x00007565, 0x00000002},
+	{0x00007566, 0x00000002},
+	{0x00000051, 0x00000004},
+	{0x01e655b4, 0x00000002},
+	{0x4401b0dc, 0x00000002},
+	{0x01c110dc, 0x00000002},
+	{0x2666705d, 0x00000018},
+	{0x040c2565, 0x00000002},
+	{0x0000005d, 0x00000018},
+	{0x04002564, 0x00000002},
+	{0x00007566, 0x00000002},
+	{0x00000054, 0x00000004},
+	{0x00401060, 0x00000008},
+	{0x00101000, 0x00000002},
+	{0x000d80ff, 0x00000002},
+	{0x00800063, 0x00000008},
+	{0x000f9000, 0x00000002},
+	{0x000e00ff, 0x00000002},
+	{0000000000, 0x00000006},
+	{0x00000080, 0x00000018},
+	{0x00000054, 0x00000004},
+	{0x00007576, 0x00000002},
+	{0x00065000, 0x00000002},
+	{0x00009000, 0x00000002},
+	{0x00041000, 0x00000002},
+	{0x0c00350e, 0x00000002},
+	{0x00049000, 0x00000002},
+	{0x00051000, 0x00000002},
+	{0x01e785f8, 0x00000002},
+	{0x00200000, 0x00000002},
+	{0x00600073, 0x0000000c},
+	{0x00007563, 0x00000002},
+	{0x006075f0, 0x00000021},
+	{0x20007068, 0x00000004},
+	{0x00005068, 0x00000004},
+	{0x00007576, 0x00000002},
+	{0x00007577, 0x00000002},
+	{0x0000750e, 0x00000002},
+	{0x0000750f, 0x00000002},
+	{0x00a05000, 0x00000002},
+	{0x00600076, 0x0000000c},
+	{0x006075f0, 0x00000021},
+	{0x000075f8, 0x00000002},
+	{0x00000076, 0x00000004},
+	{0x000a750e, 0x00000002},
+	{0x0020750f, 0x00000002},
+	{0x00600079, 0x00000004},
+	{0x00007570, 0x00000002},
+	{0x00007571, 0x00000002},
+	{0x00007572, 0x00000006},
+	{0x00005000, 0x00000002},
+	{0x00a05000, 0x00000002},
+	{0x00007568, 0x00000002},
+	{0x00061000, 0x00000002},
+	{0x00000084, 0x0000000c},
+	{0x00058000, 0x00000002},
+	{0x0c607562, 0x00000002},
+	{0x00000086, 0x00000004},
+	{0x00600085, 0x00000004},
+	{0x400070dd, 0000000000},
+	{0x000380dd, 0x00000002},
+	{0x00000093, 0x0000001c},
+	{0x00065095, 0x00000018},
+	{0x040025bb, 0x00000002},
+	{0x00061096, 0x00000018},
+	{0x040075bc, 0000000000},
+	{0x000075bb, 0x00000002},
+	{0x000075bc, 0000000000},
+	{0x00090000, 0x00000006},
+	{0x00090000, 0x00000002},
+	{0x000d8002, 0x00000006},
+	{0x00005000, 0x00000002},
+	{0x00007821, 0x00000002},
+	{0x00007800, 0000000000},
+	{0x00007821, 0x00000002},
+	{0x00007800, 0000000000},
+	{0x01665000, 0x00000002},
+	{0x000a0000, 0x00000002},
+	{0x000671cc, 0x00000002},
+	{0x0286f1cd, 0x00000002},
+	{0x000000a3, 0x00000010},
+	{0x21007000, 0000000000},
+	{0x000000aa, 0x0000001c},
+	{0x00065000, 0x00000002},
+	{0x000a0000, 0x00000002},
+	{0x00061000, 0x00000002},
+	{0x000b0000, 0x00000002},
+	{0x38067000, 0x00000002},
+	{0x000a00a6, 0x00000004},
+	{0x20007000, 0000000000},
+	{0x01200000, 0x00000002},
+	{0x20077000, 0x00000002},
+	{0x01200000, 0x00000002},
+	{0x20007000, 0000000000},
+	{0x00061000, 0x00000002},
+	{0x0120751b, 0x00000002},
+	{0x8040750a, 0x00000002},
+	{0x8040750b, 0x00000002},
+	{0x00110000, 0x00000002},
+	{0x000380dd, 0x00000002},
+	{0x000000bd, 0x0000001c},
+	{0x00061096, 0x00000018},
+	{0x844075bd, 0x00000002},
+	{0x00061095, 0x00000018},
+	{0x840075bb, 0x00000002},
+	{0x00061096, 0x00000018},
+	{0x844075bc, 0x00000002},
+	{0x000000c0, 0x00000004},
+	{0x804075bd, 0x00000002},
+	{0x800075bb, 0x00000002},
+	{0x804075bc, 0x00000002},
+	{0x00108000, 0x00000002},
+	{0x01400000, 0x00000002},
+	{0x006000c4, 0x0000000c},
+	{0x20c07000, 0x00000020},
+	{0x000000c6, 0x00000012},
+	{0x00800000, 0x00000006},
+	{0x0080751d, 0x00000006},
+	{0x000025bb, 0x00000002},
+	{0x000040c0, 0x00000004},
+	{0x0000775c, 0x00000002},
+	{0x00a05000, 0x00000002},
+	{0x00661000, 0x00000002},
+	{0x0460275d, 0x00000020},
+	{0x00004000, 0000000000},
+	{0x00007999, 0x00000002},
+	{0x00a05000, 0x00000002},
+	{0x00661000, 0x00000002},
+	{0x0460299b, 0x00000020},
+	{0x00004000, 0000000000},
+	{0x01e00830, 0x00000002},
+	{0x21007000, 0000000000},
+	{0x00005000, 0x00000002},
+	{0x00038042, 0x00000002},
+	{0x040025e0, 0x00000002},
+	{0x000075e1, 0000000000},
+	{0x00000001, 0000000000},
+	{0x000380d9, 0x00000002},
+	{0x04007394, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
 };
 
-
 static u32 radeon_cp_microcode[][2] = {
-	{ 0x21007000, 0000000000 },
-	{ 0x20007000, 0000000000 },
-	{ 0x000000b4, 0x00000004 },
-	{ 0x000000b8, 0x00000004 },
-	{ 0x6f5b4d4c, 0000000000 },
-	{ 0x4c4c427f, 0000000000 },
-	{ 0x5b568a92, 0000000000 },
-	{ 0x4ca09c6d, 0000000000 },
-	{ 0xad4c4c4c, 0000000000 },
-	{ 0x4ce1af3d, 0000000000 },
-	{ 0xd8afafaf, 0000000000 },
-	{ 0xd64c4cdc, 0000000000 },
-	{ 0x4cd10d10, 0000000000 },
-	{ 0x000f0000, 0x00000016 },
-	{ 0x362f242d, 0000000000 },
-	{ 0x00000012, 0x00000004 },
-	{ 0x000f0000, 0x00000016 },
-	{ 0x362f282d, 0000000000 },
-	{ 0x000380e7, 0x00000002 },
-	{ 0x04002c97, 0x00000002 },
-	{ 0x000f0001, 0x00000016 },
-	{ 0x333a3730, 0000000000 },
-	{ 0x000077ef, 0x00000002 },
-	{ 0x00061000, 0x00000002 },
-	{ 0x00000021, 0x0000001a },
-	{ 0x00004000, 0x0000001e },
-	{ 0x00061000, 0x00000002 },
-	{ 0x00000021, 0x0000001a },
-	{ 0x00004000, 0x0000001e },
-	{ 0x00061000, 0x00000002 },
-	{ 0x00000021, 0x0000001a },
-	{ 0x00004000, 0x0000001e },
-	{ 0x00000017, 0x00000004 },
-	{ 0x0003802b, 0x00000002 },
-	{ 0x040067e0, 0x00000002 },
-	{ 0x00000017, 0x00000004 },
-	{ 0x000077e0, 0x00000002 },
-	{ 0x00065000, 0x00000002 },
-	{ 0x000037e1, 0x00000002 },
-	{ 0x040067e1, 0x00000006 },
-	{ 0x000077e0, 0x00000002 },
-	{ 0x000077e1, 0x00000002 },
-	{ 0x000077e1, 0x00000006 },
-	{ 0xffffffff, 0000000000 },
-	{ 0x10000000, 0000000000 },
-	{ 0x0003802b, 0x00000002 },
-	{ 0x040067e0, 0x00000006 },
-	{ 0x00007675, 0x00000002 },
-	{ 0x00007676, 0x00000002 },
-	{ 0x00007677, 0x00000002 },
-	{ 0x00007678, 0x00000006 },
-	{ 0x0003802c, 0x00000002 },
-	{ 0x04002676, 0x00000002 },
-	{ 0x00007677, 0x00000002 },
-	{ 0x00007678, 0x00000006 },
-	{ 0x0000002f, 0x00000018 },
-	{ 0x0000002f, 0x00000018 },
-	{ 0000000000, 0x00000006 },
-	{ 0x00000030, 0x00000018 },
-	{ 0x00000030, 0x00000018 },
-	{ 0000000000, 0x00000006 },
-	{ 0x01605000, 0x00000002 },
-	{ 0x00065000, 0x00000002 },
-	{ 0x00098000, 0x00000002 },
-	{ 0x00061000, 0x00000002 },
-	{ 0x64c0603e, 0x00000004 },
-	{ 0x000380e6, 0x00000002 },
-	{ 0x040025c5, 0x00000002 },
-	{ 0x00080000, 0x00000016 },
-	{ 0000000000, 0000000000 },
-	{ 0x0400251d, 0x00000002 },
-	{ 0x00007580, 0x00000002 },
-	{ 0x00067581, 0x00000002 },
-	{ 0x04002580, 0x00000002 },
-	{ 0x00067581, 0x00000002 },
-	{ 0x00000049, 0x00000004 },
-	{ 0x00005000, 0000000000 },
-	{ 0x000380e6, 0x00000002 },
-	{ 0x040025c5, 0x00000002 },
-	{ 0x00061000, 0x00000002 },
-	{ 0x0000750e, 0x00000002 },
-	{ 0x00019000, 0x00000002 },
-	{ 0x00011055, 0x00000014 },
-	{ 0x00000055, 0x00000012 },
-	{ 0x0400250f, 0x00000002 },
-	{ 0x0000504f, 0x00000004 },
-	{ 0x000380e6, 0x00000002 },
-	{ 0x040025c5, 0x00000002 },
-	{ 0x00007565, 0x00000002 },
-	{ 0x00007566, 0x00000002 },
-	{ 0x00000058, 0x00000004 },
-	{ 0x000380e6, 0x00000002 },
-	{ 0x040025c5, 0x00000002 },
-	{ 0x01e655b4, 0x00000002 },
-	{ 0x4401b0e4, 0x00000002 },
-	{ 0x01c110e4, 0x00000002 },
-	{ 0x26667066, 0x00000018 },
-	{ 0x040c2565, 0x00000002 },
-	{ 0x00000066, 0x00000018 },
-	{ 0x04002564, 0x00000002 },
-	{ 0x00007566, 0x00000002 },
-	{ 0x0000005d, 0x00000004 },
-	{ 0x00401069, 0x00000008 },
-	{ 0x00101000, 0x00000002 },
-	{ 0x000d80ff, 0x00000002 },
-	{ 0x0080006c, 0x00000008 },
-	{ 0x000f9000, 0x00000002 },
-	{ 0x000e00ff, 0x00000002 },
-	{ 0000000000, 0x00000006 },
-	{ 0x0000008f, 0x00000018 },
-	{ 0x0000005b, 0x00000004 },
-	{ 0x000380e6, 0x00000002 },
-	{ 0x040025c5, 0x00000002 },
-	{ 0x00007576, 0x00000002 },
-	{ 0x00065000, 0x00000002 },
-	{ 0x00009000, 0x00000002 },
-	{ 0x00041000, 0x00000002 },
-	{ 0x0c00350e, 0x00000002 },
-	{ 0x00049000, 0x00000002 },
-	{ 0x00051000, 0x00000002 },
-	{ 0x01e785f8, 0x00000002 },
-	{ 0x00200000, 0x00000002 },
-	{ 0x0060007e, 0x0000000c },
-	{ 0x00007563, 0x00000002 },
-	{ 0x006075f0, 0x00000021 },
-	{ 0x20007073, 0x00000004 },
-	{ 0x00005073, 0x00000004 },
-	{ 0x000380e6, 0x00000002 },
-	{ 0x040025c5, 0x00000002 },
-	{ 0x00007576, 0x00000002 },
-	{ 0x00007577, 0x00000002 },
-	{ 0x0000750e, 0x00000002 },
-	{ 0x0000750f, 0x00000002 },
-	{ 0x00a05000, 0x00000002 },
-	{ 0x00600083, 0x0000000c },
-	{ 0x006075f0, 0x00000021 },
-	{ 0x000075f8, 0x00000002 },
-	{ 0x00000083, 0x00000004 },
-	{ 0x000a750e, 0x00000002 },
-	{ 0x000380e6, 0x00000002 },
-	{ 0x040025c5, 0x00000002 },
-	{ 0x0020750f, 0x00000002 },
-	{ 0x00600086, 0x00000004 },
-	{ 0x00007570, 0x00000002 },
-	{ 0x00007571, 0x00000002 },
-	{ 0x00007572, 0x00000006 },
-	{ 0x000380e6, 0x00000002 },
-	{ 0x040025c5, 0x00000002 },
-	{ 0x00005000, 0x00000002 },
-	{ 0x00a05000, 0x00000002 },
-	{ 0x00007568, 0x00000002 },
-	{ 0x00061000, 0x00000002 },
-	{ 0x00000095, 0x0000000c },
-	{ 0x00058000, 0x00000002 },
-	{ 0x0c607562, 0x00000002 },
-	{ 0x00000097, 0x00000004 },
-	{ 0x000380e6, 0x00000002 },
-	{ 0x040025c5, 0x00000002 },
-	{ 0x00600096, 0x00000004 },
-	{ 0x400070e5, 0000000000 },
-	{ 0x000380e6, 0x00000002 },
-	{ 0x040025c5, 0x00000002 },
-	{ 0x000380e5, 0x00000002 },
-	{ 0x000000a8, 0x0000001c },
-	{ 0x000650aa, 0x00000018 },
-	{ 0x040025bb, 0x00000002 },
-	{ 0x000610ab, 0x00000018 },
-	{ 0x040075bc, 0000000000 },
-	{ 0x000075bb, 0x00000002 },
-	{ 0x000075bc, 0000000000 },
-	{ 0x00090000, 0x00000006 },
-	{ 0x00090000, 0x00000002 },
-	{ 0x000d8002, 0x00000006 },
-	{ 0x00007832, 0x00000002 },
-	{ 0x00005000, 0x00000002 },
-	{ 0x000380e7, 0x00000002 },
-	{ 0x04002c97, 0x00000002 },
-	{ 0x00007820, 0x00000002 },
-	{ 0x00007821, 0x00000002 },
-	{ 0x00007800, 0000000000 },
-	{ 0x01200000, 0x00000002 },
-	{ 0x20077000, 0x00000002 },
-	{ 0x01200000, 0x00000002 },
-	{ 0x20007000, 0x00000002 },
-	{ 0x00061000, 0x00000002 },
-	{ 0x0120751b, 0x00000002 },
-	{ 0x8040750a, 0x00000002 },
-	{ 0x8040750b, 0x00000002 },
-	{ 0x00110000, 0x00000002 },
-	{ 0x000380e5, 0x00000002 },
-	{ 0x000000c6, 0x0000001c },
-	{ 0x000610ab, 0x00000018 },
-	{ 0x844075bd, 0x00000002 },
-	{ 0x000610aa, 0x00000018 },
-	{ 0x840075bb, 0x00000002 },
-	{ 0x000610ab, 0x00000018 },
-	{ 0x844075bc, 0x00000002 },
-	{ 0x000000c9, 0x00000004 },
-	{ 0x804075bd, 0x00000002 },
-	{ 0x800075bb, 0x00000002 },
-	{ 0x804075bc, 0x00000002 },
-	{ 0x00108000, 0x00000002 },
-	{ 0x01400000, 0x00000002 },
-	{ 0x006000cd, 0x0000000c },
-	{ 0x20c07000, 0x00000020 },
-	{ 0x000000cf, 0x00000012 },
-	{ 0x00800000, 0x00000006 },
-	{ 0x0080751d, 0x00000006 },
-	{ 0000000000, 0000000000 },
-	{ 0x0000775c, 0x00000002 },
-	{ 0x00a05000, 0x00000002 },
-	{ 0x00661000, 0x00000002 },
-	{ 0x0460275d, 0x00000020 },
-	{ 0x00004000, 0000000000 },
-	{ 0x01e00830, 0x00000002 },
-	{ 0x21007000, 0000000000 },
-	{ 0x6464614d, 0000000000 },
-	{ 0x69687420, 0000000000 },
-	{ 0x00000073, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0x00005000, 0x00000002 },
-	{ 0x000380d0, 0x00000002 },
-	{ 0x040025e0, 0x00000002 },
-	{ 0x000075e1, 0000000000 },
-	{ 0x00000001, 0000000000 },
-	{ 0x000380e0, 0x00000002 },
-	{ 0x04002394, 0x00000002 },
-	{ 0x00005000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0x00000008, 0000000000 },
-	{ 0x00000004, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
-	{ 0000000000, 0000000000 },
+	{0x21007000, 0000000000},
+	{0x20007000, 0000000000},
+	{0x000000b4, 0x00000004},
+	{0x000000b8, 0x00000004},
+	{0x6f5b4d4c, 0000000000},
+	{0x4c4c427f, 0000000000},
+	{0x5b568a92, 0000000000},
+	{0x4ca09c6d, 0000000000},
+	{0xad4c4c4c, 0000000000},
+	{0x4ce1af3d, 0000000000},
+	{0xd8afafaf, 0000000000},
+	{0xd64c4cdc, 0000000000},
+	{0x4cd10d10, 0000000000},
+	{0x000f0000, 0x00000016},
+	{0x362f242d, 0000000000},
+	{0x00000012, 0x00000004},
+	{0x000f0000, 0x00000016},
+	{0x362f282d, 0000000000},
+	{0x000380e7, 0x00000002},
+	{0x04002c97, 0x00000002},
+	{0x000f0001, 0x00000016},
+	{0x333a3730, 0000000000},
+	{0x000077ef, 0x00000002},
+	{0x00061000, 0x00000002},
+	{0x00000021, 0x0000001a},
+	{0x00004000, 0x0000001e},
+	{0x00061000, 0x00000002},
+	{0x00000021, 0x0000001a},
+	{0x00004000, 0x0000001e},
+	{0x00061000, 0x00000002},
+	{0x00000021, 0x0000001a},
+	{0x00004000, 0x0000001e},
+	{0x00000017, 0x00000004},
+	{0x0003802b, 0x00000002},
+	{0x040067e0, 0x00000002},
+	{0x00000017, 0x00000004},
+	{0x000077e0, 0x00000002},
+	{0x00065000, 0x00000002},
+	{0x000037e1, 0x00000002},
+	{0x040067e1, 0x00000006},
+	{0x000077e0, 0x00000002},
+	{0x000077e1, 0x00000002},
+	{0x000077e1, 0x00000006},
+	{0xffffffff, 0000000000},
+	{0x10000000, 0000000000},
+	{0x0003802b, 0x00000002},
+	{0x040067e0, 0x00000006},
+	{0x00007675, 0x00000002},
+	{0x00007676, 0x00000002},
+	{0x00007677, 0x00000002},
+	{0x00007678, 0x00000006},
+	{0x0003802c, 0x00000002},
+	{0x04002676, 0x00000002},
+	{0x00007677, 0x00000002},
+	{0x00007678, 0x00000006},
+	{0x0000002f, 0x00000018},
+	{0x0000002f, 0x00000018},
+	{0000000000, 0x00000006},
+	{0x00000030, 0x00000018},
+	{0x00000030, 0x00000018},
+	{0000000000, 0x00000006},
+	{0x01605000, 0x00000002},
+	{0x00065000, 0x00000002},
+	{0x00098000, 0x00000002},
+	{0x00061000, 0x00000002},
+	{0x64c0603e, 0x00000004},
+	{0x000380e6, 0x00000002},
+	{0x040025c5, 0x00000002},
+	{0x00080000, 0x00000016},
+	{0000000000, 0000000000},
+	{0x0400251d, 0x00000002},
+	{0x00007580, 0x00000002},
+	{0x00067581, 0x00000002},
+	{0x04002580, 0x00000002},
+	{0x00067581, 0x00000002},
+	{0x00000049, 0x00000004},
+	{0x00005000, 0000000000},
+	{0x000380e6, 0x00000002},
+	{0x040025c5, 0x00000002},
+	{0x00061000, 0x00000002},
+	{0x0000750e, 0x00000002},
+	{0x00019000, 0x00000002},
+	{0x00011055, 0x00000014},
+	{0x00000055, 0x00000012},
+	{0x0400250f, 0x00000002},
+	{0x0000504f, 0x00000004},
+	{0x000380e6, 0x00000002},
+	{0x040025c5, 0x00000002},
+	{0x00007565, 0x00000002},
+	{0x00007566, 0x00000002},
+	{0x00000058, 0x00000004},
+	{0x000380e6, 0x00000002},
+	{0x040025c5, 0x00000002},
+	{0x01e655b4, 0x00000002},
+	{0x4401b0e4, 0x00000002},
+	{0x01c110e4, 0x00000002},
+	{0x26667066, 0x00000018},
+	{0x040c2565, 0x00000002},
+	{0x00000066, 0x00000018},
+	{0x04002564, 0x00000002},
+	{0x00007566, 0x00000002},
+	{0x0000005d, 0x00000004},
+	{0x00401069, 0x00000008},
+	{0x00101000, 0x00000002},
+	{0x000d80ff, 0x00000002},
+	{0x0080006c, 0x00000008},
+	{0x000f9000, 0x00000002},
+	{0x000e00ff, 0x00000002},
+	{0000000000, 0x00000006},
+	{0x0000008f, 0x00000018},
+	{0x0000005b, 0x00000004},
+	{0x000380e6, 0x00000002},
+	{0x040025c5, 0x00000002},
+	{0x00007576, 0x00000002},
+	{0x00065000, 0x00000002},
+	{0x00009000, 0x00000002},
+	{0x00041000, 0x00000002},
+	{0x0c00350e, 0x00000002},
+	{0x00049000, 0x00000002},
+	{0x00051000, 0x00000002},
+	{0x01e785f8, 0x00000002},
+	{0x00200000, 0x00000002},
+	{0x0060007e, 0x0000000c},
+	{0x00007563, 0x00000002},
+	{0x006075f0, 0x00000021},
+	{0x20007073, 0x00000004},
+	{0x00005073, 0x00000004},
+	{0x000380e6, 0x00000002},
+	{0x040025c5, 0x00000002},
+	{0x00007576, 0x00000002},
+	{0x00007577, 0x00000002},
+	{0x0000750e, 0x00000002},
+	{0x0000750f, 0x00000002},
+	{0x00a05000, 0x00000002},
+	{0x00600083, 0x0000000c},
+	{0x006075f0, 0x00000021},
+	{0x000075f8, 0x00000002},
+	{0x00000083, 0x00000004},
+	{0x000a750e, 0x00000002},
+	{0x000380e6, 0x00000002},
+	{0x040025c5, 0x00000002},
+	{0x0020750f, 0x00000002},
+	{0x00600086, 0x00000004},
+	{0x00007570, 0x00000002},
+	{0x00007571, 0x00000002},
+	{0x00007572, 0x00000006},
+	{0x000380e6, 0x00000002},
+	{0x040025c5, 0x00000002},
+	{0x00005000, 0x00000002},
+	{0x00a05000, 0x00000002},
+	{0x00007568, 0x00000002},
+	{0x00061000, 0x00000002},
+	{0x00000095, 0x0000000c},
+	{0x00058000, 0x00000002},
+	{0x0c607562, 0x00000002},
+	{0x00000097, 0x00000004},
+	{0x000380e6, 0x00000002},
+	{0x040025c5, 0x00000002},
+	{0x00600096, 0x00000004},
+	{0x400070e5, 0000000000},
+	{0x000380e6, 0x00000002},
+	{0x040025c5, 0x00000002},
+	{0x000380e5, 0x00000002},
+	{0x000000a8, 0x0000001c},
+	{0x000650aa, 0x00000018},
+	{0x040025bb, 0x00000002},
+	{0x000610ab, 0x00000018},
+	{0x040075bc, 0000000000},
+	{0x000075bb, 0x00000002},
+	{0x000075bc, 0000000000},
+	{0x00090000, 0x00000006},
+	{0x00090000, 0x00000002},
+	{0x000d8002, 0x00000006},
+	{0x00007832, 0x00000002},
+	{0x00005000, 0x00000002},
+	{0x000380e7, 0x00000002},
+	{0x04002c97, 0x00000002},
+	{0x00007820, 0x00000002},
+	{0x00007821, 0x00000002},
+	{0x00007800, 0000000000},
+	{0x01200000, 0x00000002},
+	{0x20077000, 0x00000002},
+	{0x01200000, 0x00000002},
+	{0x20007000, 0x00000002},
+	{0x00061000, 0x00000002},
+	{0x0120751b, 0x00000002},
+	{0x8040750a, 0x00000002},
+	{0x8040750b, 0x00000002},
+	{0x00110000, 0x00000002},
+	{0x000380e5, 0x00000002},
+	{0x000000c6, 0x0000001c},
+	{0x000610ab, 0x00000018},
+	{0x844075bd, 0x00000002},
+	{0x000610aa, 0x00000018},
+	{0x840075bb, 0x00000002},
+	{0x000610ab, 0x00000018},
+	{0x844075bc, 0x00000002},
+	{0x000000c9, 0x00000004},
+	{0x804075bd, 0x00000002},
+	{0x800075bb, 0x00000002},
+	{0x804075bc, 0x00000002},
+	{0x00108000, 0x00000002},
+	{0x01400000, 0x00000002},
+	{0x006000cd, 0x0000000c},
+	{0x20c07000, 0x00000020},
+	{0x000000cf, 0x00000012},
+	{0x00800000, 0x00000006},
+	{0x0080751d, 0x00000006},
+	{0000000000, 0000000000},
+	{0x0000775c, 0x00000002},
+	{0x00a05000, 0x00000002},
+	{0x00661000, 0x00000002},
+	{0x0460275d, 0x00000020},
+	{0x00004000, 0000000000},
+	{0x01e00830, 0x00000002},
+	{0x21007000, 0000000000},
+	{0x6464614d, 0000000000},
+	{0x69687420, 0000000000},
+	{0x00000073, 0000000000},
+	{0000000000, 0000000000},
+	{0x00005000, 0x00000002},
+	{0x000380d0, 0x00000002},
+	{0x040025e0, 0x00000002},
+	{0x000075e1, 0000000000},
+	{0x00000001, 0000000000},
+	{0x000380e0, 0x00000002},
+	{0x04002394, 0x00000002},
+	{0x00005000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0x00000008, 0000000000},
+	{0x00000004, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
 };
 
 static u32 R300_cp_microcode[][2] = {
@@ -695,7 +694,7 @@ static u32 R300_cp_microcode[][2] = {
 	{ 0x0000e571, 0x00000004 },
 	{ 0x0000e572, 0x0000000c },
 	{ 0x0000a000, 0x00000004 },
-	{ 0x0140a000, 0x00000004 },
+	{ 0x0140a000, 0x00000004 }, 
 	{ 0x0000e568, 0x00000004 },
 	{ 0x000c2000, 0x00000004 },
 	{ 0x00000089, 0x00000018 },
@@ -816,7 +815,7 @@ static u32 R300_cp_microcode[][2] = {
 	{ 0000000000, 0000000000 },
 };
 
-static int RADEON_READ_PLL(drm_device_t *dev, int addr)
+static int RADEON_READ_PLL(drm_device_t * dev, int addr)
 {
 	drm_radeon_private_t *dev_priv = dev->dev_private;
 
@@ -825,144 +824,141 @@ static int RADEON_READ_PLL(drm_device_t 
 }
 
 #if RADEON_FIFO_DEBUG
-static void radeon_status( drm_radeon_private_t *dev_priv )
+static void radeon_status(drm_radeon_private_t * dev_priv)
 {
-	printk( "%s:\n", __FUNCTION__ );
-	printk( "RBBM_STATUS = 0x%08x\n",
-		(unsigned int)RADEON_READ( RADEON_RBBM_STATUS ) );
-	printk( "CP_RB_RTPR = 0x%08x\n",
-		(unsigned int)RADEON_READ( RADEON_CP_RB_RPTR ) );
-	printk( "CP_RB_WTPR = 0x%08x\n",
-		(unsigned int)RADEON_READ( RADEON_CP_RB_WPTR ) );
-	printk( "AIC_CNTL = 0x%08x\n",
-		(unsigned int)RADEON_READ( RADEON_AIC_CNTL ) );
-	printk( "AIC_STAT = 0x%08x\n",
-		(unsigned int)RADEON_READ( RADEON_AIC_STAT ) );
-	printk( "AIC_PT_BASE = 0x%08x\n",
-		(unsigned int)RADEON_READ( RADEON_AIC_PT_BASE ) );
-	printk( "TLB_ADDR = 0x%08x\n",
-		(unsigned int)RADEON_READ( RADEON_AIC_TLB_ADDR ) );
-	printk( "TLB_DATA = 0x%08x\n",
-		(unsigned int)RADEON_READ( RADEON_AIC_TLB_DATA ) );
+	printk("%s:\n", __FUNCTION__);
+	printk("RBBM_STATUS = 0x%08x\n",
+	       (unsigned int)RADEON_READ(RADEON_RBBM_STATUS));
+	printk("CP_RB_RTPR = 0x%08x\n",
+	       (unsigned int)RADEON_READ(RADEON_CP_RB_RPTR));
+	printk("CP_RB_WTPR = 0x%08x\n",
+	       (unsigned int)RADEON_READ(RADEON_CP_RB_WPTR));
+	printk("AIC_CNTL = 0x%08x\n",
+	       (unsigned int)RADEON_READ(RADEON_AIC_CNTL));
+	printk("AIC_STAT = 0x%08x\n",
+	       (unsigned int)RADEON_READ(RADEON_AIC_STAT));
+	printk("AIC_PT_BASE = 0x%08x\n",
+	       (unsigned int)RADEON_READ(RADEON_AIC_PT_BASE));
+	printk("TLB_ADDR = 0x%08x\n",
+	       (unsigned int)RADEON_READ(RADEON_AIC_TLB_ADDR));
+	printk("TLB_DATA = 0x%08x\n",
+	       (unsigned int)RADEON_READ(RADEON_AIC_TLB_DATA));
 }
 #endif
 
-
 /* ================================================================
  * Engine, FIFO control
  */
 
-static int radeon_do_pixcache_flush( drm_radeon_private_t *dev_priv )
+static int radeon_do_pixcache_flush(drm_radeon_private_t * dev_priv)
 {
 	u32 tmp;
 	int i;
 
 	dev_priv->stats.boxes |= RADEON_BOX_WAIT_IDLE;
 
-	tmp  = RADEON_READ( RADEON_RB2D_DSTCACHE_CTLSTAT );
+	tmp = RADEON_READ(RADEON_RB2D_DSTCACHE_CTLSTAT);
 	tmp |= RADEON_RB2D_DC_FLUSH_ALL;
-	RADEON_WRITE( RADEON_RB2D_DSTCACHE_CTLSTAT, tmp );
+	RADEON_WRITE(RADEON_RB2D_DSTCACHE_CTLSTAT, tmp);
 
-	for ( i = 0 ; i < dev_priv->usec_timeout ; i++ ) {
-		if ( !(RADEON_READ( RADEON_RB2D_DSTCACHE_CTLSTAT )
-		       & RADEON_RB2D_DC_BUSY) ) {
+	for (i = 0; i < dev_priv->usec_timeout; i++) {
+		if (!(RADEON_READ(RADEON_RB2D_DSTCACHE_CTLSTAT)
+		      & RADEON_RB2D_DC_BUSY)) {
 			return 0;
 		}
-		DRM_UDELAY( 1 );
+		DRM_UDELAY(1);
 	}
 
 #if RADEON_FIFO_DEBUG
-	DRM_ERROR( "failed!\n" );
-	radeon_status( dev_priv );
+	DRM_ERROR("failed!\n");
+	radeon_status(dev_priv);
 #endif
 	return DRM_ERR(EBUSY);
 }
 
-static int radeon_do_wait_for_fifo( drm_radeon_private_t *dev_priv,
-				    int entries )
+static int radeon_do_wait_for_fifo(drm_radeon_private_t * dev_priv, int entries)
 {
 	int i;
 
 	dev_priv->stats.boxes |= RADEON_BOX_WAIT_IDLE;
 
-	for ( i = 0 ; i < dev_priv->usec_timeout ; i++ ) {
-		int slots = ( RADEON_READ( RADEON_RBBM_STATUS )
-			      & RADEON_RBBM_FIFOCNT_MASK );
-		if ( slots >= entries ) return 0;
-		DRM_UDELAY( 1 );
+	for (i = 0; i < dev_priv->usec_timeout; i++) {
+		int slots = (RADEON_READ(RADEON_RBBM_STATUS)
+			     & RADEON_RBBM_FIFOCNT_MASK);
+		if (slots >= entries)
+			return 0;
+		DRM_UDELAY(1);
 	}
 
 #if RADEON_FIFO_DEBUG
-	DRM_ERROR( "failed!\n" );
-	radeon_status( dev_priv );
+	DRM_ERROR("failed!\n");
+	radeon_status(dev_priv);
 #endif
 	return DRM_ERR(EBUSY);
 }
 
-static int radeon_do_wait_for_idle( drm_radeon_private_t *dev_priv )
+static int radeon_do_wait_for_idle(drm_radeon_private_t * dev_priv)
 {
 	int i, ret;
 
 	dev_priv->stats.boxes |= RADEON_BOX_WAIT_IDLE;
 
-	ret = radeon_do_wait_for_fifo( dev_priv, 64 );
-	if ( ret ) return ret;
-
-	for ( i = 0 ; i < dev_priv->usec_timeout ; i++ ) {
-		if ( !(RADEON_READ( RADEON_RBBM_STATUS )
-		       & RADEON_RBBM_ACTIVE) ) {
-			radeon_do_pixcache_flush( dev_priv );
+	ret = radeon_do_wait_for_fifo(dev_priv, 64);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < dev_priv->usec_timeout; i++) {
+		if (!(RADEON_READ(RADEON_RBBM_STATUS)
+		      & RADEON_RBBM_ACTIVE)) {
+			radeon_do_pixcache_flush(dev_priv);
 			return 0;
 		}
-		DRM_UDELAY( 1 );
+		DRM_UDELAY(1);
 	}
 
 #if RADEON_FIFO_DEBUG
-	DRM_ERROR( "failed!\n" );
-	radeon_status( dev_priv );
+	DRM_ERROR("failed!\n");
+	radeon_status(dev_priv);
 #endif
 	return DRM_ERR(EBUSY);
 }
 
-
 /* ================================================================
  * CP control, initialization
  */
 
 /* Load the microcode for the CP */
-static void radeon_cp_load_microcode( drm_radeon_private_t *dev_priv )
+static void radeon_cp_load_microcode(drm_radeon_private_t * dev_priv)
 {
 	int i;
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
-	radeon_do_wait_for_idle( dev_priv );
+	radeon_do_wait_for_idle(dev_priv);
 
-	RADEON_WRITE( RADEON_CP_ME_RAM_ADDR, 0 );
+	RADEON_WRITE(RADEON_CP_ME_RAM_ADDR, 0);
 
 	if (dev_priv->microcode_version==UCODE_R200) {
 		DRM_INFO("Loading R200 Microcode\n");
-		for ( i = 0 ; i < 256 ; i++ ) 
-		{
-			RADEON_WRITE( RADEON_CP_ME_RAM_DATAH,
-				      R200_cp_microcode[i][1] );
-			RADEON_WRITE( RADEON_CP_ME_RAM_DATAL,
-				      R200_cp_microcode[i][0] );
+		for (i = 0; i < 256; i++) {
+			RADEON_WRITE(RADEON_CP_ME_RAM_DATAH,
+				     R200_cp_microcode[i][1]);
+			RADEON_WRITE(RADEON_CP_ME_RAM_DATAL,
+				     R200_cp_microcode[i][0]);
 		}
 	} else if (dev_priv->microcode_version==UCODE_R300) {
 		DRM_INFO("Loading R300 Microcode\n");
-		for ( i = 0 ; i < 256 ; i++ ) 
-		{
+		for ( i = 0 ; i < 256 ; i++ ) {
 			RADEON_WRITE( RADEON_CP_ME_RAM_DATAH,
 				      R300_cp_microcode[i][1] );
 			RADEON_WRITE( RADEON_CP_ME_RAM_DATAL,
 				      R300_cp_microcode[i][0] );
 		}
 	} else {
-		for ( i = 0 ; i < 256 ; i++ ) {
-			RADEON_WRITE( RADEON_CP_ME_RAM_DATAH,
-				      radeon_cp_microcode[i][1] );
-			RADEON_WRITE( RADEON_CP_ME_RAM_DATAL,
-				      radeon_cp_microcode[i][0] );
+		for (i = 0; i < 256; i++) {
+			RADEON_WRITE(RADEON_CP_ME_RAM_DATAH,
+				     radeon_cp_microcode[i][1]);
+			RADEON_WRITE(RADEON_CP_ME_RAM_DATAL,
+				     radeon_cp_microcode[i][0]);
 		}
 	}
 }
@@ -971,25 +967,25 @@ static void radeon_cp_load_microcode( dr
  * prior to a wait for idle, as it informs the engine that the command
  * stream is ending.
  */
-static void radeon_do_cp_flush( drm_radeon_private_t *dev_priv )
+static void radeon_do_cp_flush(drm_radeon_private_t * dev_priv)
 {
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 #if 0
 	u32 tmp;
 
-	tmp = RADEON_READ( RADEON_CP_RB_WPTR ) | (1 << 31);
-	RADEON_WRITE( RADEON_CP_RB_WPTR, tmp );
+	tmp = RADEON_READ(RADEON_CP_RB_WPTR) | (1 << 31);
+	RADEON_WRITE(RADEON_CP_RB_WPTR, tmp);
 #endif
 }
 
 /* Wait for the CP to go idle.
  */
-int radeon_do_cp_idle( drm_radeon_private_t *dev_priv )
+int radeon_do_cp_idle(drm_radeon_private_t * dev_priv)
 {
 	RING_LOCALS;
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
-	BEGIN_RING( 6 );
+	BEGIN_RING(6);
 
 	RADEON_PURGE_CACHE();
 	RADEON_PURGE_ZCACHE();
@@ -998,23 +994,23 @@ int radeon_do_cp_idle( drm_radeon_privat
 	ADVANCE_RING();
 	COMMIT_RING();
 
-	return radeon_do_wait_for_idle( dev_priv );
+	return radeon_do_wait_for_idle(dev_priv);
 }
 
 /* Start the Command Processor.
  */
-static void radeon_do_cp_start( drm_radeon_private_t *dev_priv )
+static void radeon_do_cp_start(drm_radeon_private_t * dev_priv)
 {
 	RING_LOCALS;
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
-	radeon_do_wait_for_idle( dev_priv );
+	radeon_do_wait_for_idle(dev_priv);
 
-	RADEON_WRITE( RADEON_CP_CSQ_CNTL, dev_priv->cp_mode );
+	RADEON_WRITE(RADEON_CP_CSQ_CNTL, dev_priv->cp_mode);
 
 	dev_priv->cp_running = 1;
 
-	BEGIN_RING( 6 );
+	BEGIN_RING(6);
 
 	RADEON_PURGE_CACHE();
 	RADEON_PURGE_ZCACHE();
@@ -1028,14 +1024,14 @@ static void radeon_do_cp_start( drm_rade
  * commands, so you must wait for the CP command stream to complete
  * before calling this routine.
  */
-static void radeon_do_cp_reset( drm_radeon_private_t *dev_priv )
+static void radeon_do_cp_reset(drm_radeon_private_t * dev_priv)
 {
 	u32 cur_read_ptr;
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
-	cur_read_ptr = RADEON_READ( RADEON_CP_RB_RPTR );
-	RADEON_WRITE( RADEON_CP_RB_WPTR, cur_read_ptr );
-	SET_RING_HEAD( dev_priv, cur_read_ptr );
+	cur_read_ptr = RADEON_READ(RADEON_CP_RB_RPTR);
+	RADEON_WRITE(RADEON_CP_RB_WPTR, cur_read_ptr);
+	SET_RING_HEAD(dev_priv, cur_read_ptr);
 	dev_priv->ring.tail = cur_read_ptr;
 }
 
@@ -1043,118 +1039,116 @@ static void radeon_do_cp_reset( drm_rade
  * commands, so you must flush the command stream and wait for the CP
  * to go idle before calling this routine.
  */
-static void radeon_do_cp_stop( drm_radeon_private_t *dev_priv )
+static void radeon_do_cp_stop(drm_radeon_private_t * dev_priv)
 {
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
-	RADEON_WRITE( RADEON_CP_CSQ_CNTL, RADEON_CSQ_PRIDIS_INDDIS );
+	RADEON_WRITE(RADEON_CP_CSQ_CNTL, RADEON_CSQ_PRIDIS_INDDIS);
 
 	dev_priv->cp_running = 0;
 }
 
 /* Reset the engine.  This will stop the CP if it is running.
  */
-static int radeon_do_engine_reset( drm_device_t *dev )
+static int radeon_do_engine_reset(drm_device_t * dev)
 {
 	drm_radeon_private_t *dev_priv = dev->dev_private;
 	u32 clock_cntl_index, mclk_cntl, rbbm_soft_reset;
-	DRM_DEBUG( "\n" );
-
-	radeon_do_pixcache_flush( dev_priv );
-
-	clock_cntl_index = RADEON_READ( RADEON_CLOCK_CNTL_INDEX );
-	mclk_cntl = RADEON_READ_PLL( dev, RADEON_MCLK_CNTL );
+	DRM_DEBUG("\n");
 
-	RADEON_WRITE_PLL( RADEON_MCLK_CNTL, ( mclk_cntl |
-					      RADEON_FORCEON_MCLKA |
-					      RADEON_FORCEON_MCLKB |
- 					      RADEON_FORCEON_YCLKA |
-					      RADEON_FORCEON_YCLKB |
-					      RADEON_FORCEON_MC |
-					      RADEON_FORCEON_AIC ) );
+	radeon_do_pixcache_flush(dev_priv);
 
-	rbbm_soft_reset = RADEON_READ( RADEON_RBBM_SOFT_RESET );
+	clock_cntl_index = RADEON_READ(RADEON_CLOCK_CNTL_INDEX);
+	mclk_cntl = RADEON_READ_PLL(dev, RADEON_MCLK_CNTL);
 
-	RADEON_WRITE( RADEON_RBBM_SOFT_RESET, ( rbbm_soft_reset |
-						RADEON_SOFT_RESET_CP |
+	RADEON_WRITE_PLL(RADEON_MCLK_CNTL, (mclk_cntl |
+					    RADEON_FORCEON_MCLKA |
+					    RADEON_FORCEON_MCLKB |
+					    RADEON_FORCEON_YCLKA |
+					    RADEON_FORCEON_YCLKB |
+					    RADEON_FORCEON_MC |
+					    RADEON_FORCEON_AIC));
+
+	rbbm_soft_reset = RADEON_READ(RADEON_RBBM_SOFT_RESET);
+
+	RADEON_WRITE(RADEON_RBBM_SOFT_RESET, (rbbm_soft_reset |
+					      RADEON_SOFT_RESET_CP |
+					      RADEON_SOFT_RESET_HI |
+					      RADEON_SOFT_RESET_SE |
+					      RADEON_SOFT_RESET_RE |
+					      RADEON_SOFT_RESET_PP |
+					      RADEON_SOFT_RESET_E2 |
+					      RADEON_SOFT_RESET_RB));
+	RADEON_READ(RADEON_RBBM_SOFT_RESET);
+	RADEON_WRITE(RADEON_RBBM_SOFT_RESET, (rbbm_soft_reset &
+					      ~(RADEON_SOFT_RESET_CP |
 						RADEON_SOFT_RESET_HI |
 						RADEON_SOFT_RESET_SE |
 						RADEON_SOFT_RESET_RE |
 						RADEON_SOFT_RESET_PP |
 						RADEON_SOFT_RESET_E2 |
-						RADEON_SOFT_RESET_RB ) );
-	RADEON_READ( RADEON_RBBM_SOFT_RESET );
-	RADEON_WRITE( RADEON_RBBM_SOFT_RESET, ( rbbm_soft_reset &
-						~( RADEON_SOFT_RESET_CP |
-						   RADEON_SOFT_RESET_HI |
-						   RADEON_SOFT_RESET_SE |
-						   RADEON_SOFT_RESET_RE |
-						   RADEON_SOFT_RESET_PP |
-						   RADEON_SOFT_RESET_E2 |
-						   RADEON_SOFT_RESET_RB ) ) );
-	RADEON_READ( RADEON_RBBM_SOFT_RESET );
-
-
-	RADEON_WRITE_PLL( RADEON_MCLK_CNTL, mclk_cntl );
-	RADEON_WRITE( RADEON_CLOCK_CNTL_INDEX, clock_cntl_index );
-	RADEON_WRITE( RADEON_RBBM_SOFT_RESET,  rbbm_soft_reset );
+						RADEON_SOFT_RESET_RB)));
+	RADEON_READ(RADEON_RBBM_SOFT_RESET);
+
+	RADEON_WRITE_PLL(RADEON_MCLK_CNTL, mclk_cntl);
+	RADEON_WRITE(RADEON_CLOCK_CNTL_INDEX, clock_cntl_index);
+	RADEON_WRITE(RADEON_RBBM_SOFT_RESET, rbbm_soft_reset);
 
 	/* Reset the CP ring */
-	radeon_do_cp_reset( dev_priv );
+	radeon_do_cp_reset(dev_priv);
 
 	/* The CP is no longer running after an engine reset */
 	dev_priv->cp_running = 0;
 
 	/* Reset any pending vertex, indirect buffers */
-	radeon_freelist_reset( dev );
+	radeon_freelist_reset(dev);
 
 	return 0;
 }
 
-static void radeon_cp_init_ring_buffer( drm_device_t *dev,
-				        drm_radeon_private_t *dev_priv )
+static void radeon_cp_init_ring_buffer(drm_device_t * dev,
+				       drm_radeon_private_t * dev_priv)
 {
 	u32 ring_start, cur_read_ptr;
 	u32 tmp;
 
 	/* Initialize the memory controller */
-	RADEON_WRITE( RADEON_MC_FB_LOCATION,
-		      ( ( dev_priv->gart_vm_start - 1 ) & 0xffff0000 )
-		    | ( dev_priv->fb_location >> 16 ) );
+	RADEON_WRITE(RADEON_MC_FB_LOCATION,
+		     ((dev_priv->gart_vm_start - 1) & 0xffff0000)
+		     | (dev_priv->fb_location >> 16));
 
 #if __OS_HAS_AGP
-	if ( !dev_priv->is_pci ) {
-		RADEON_WRITE( RADEON_MC_AGP_LOCATION,
-			      (((dev_priv->gart_vm_start - 1 +
-				 dev_priv->gart_size) & 0xffff0000) |
-			       (dev_priv->gart_vm_start >> 16)) );
+	if (dev_priv->flags & CHIP_IS_AGP) {
+		RADEON_WRITE(RADEON_MC_AGP_LOCATION,
+			     (((dev_priv->gart_vm_start - 1 +
+				dev_priv->gart_size) & 0xffff0000) |
+			      (dev_priv->gart_vm_start >> 16)));
 
 		ring_start = (dev_priv->cp_ring->offset
-			      - dev->agp->base
-			      + dev_priv->gart_vm_start);
-       } else
+			      - dev->agp->base + dev_priv->gart_vm_start);
+	} else
 #endif
 		ring_start = (dev_priv->cp_ring->offset
-			      - dev->sg->handle
-			      + dev_priv->gart_vm_start);
+			      - dev->sg->handle + dev_priv->gart_vm_start);
 
-	RADEON_WRITE( RADEON_CP_RB_BASE, ring_start );
+	RADEON_WRITE(RADEON_CP_RB_BASE, ring_start);
 
 	/* Set the write pointer delay */
-	RADEON_WRITE( RADEON_CP_RB_WPTR_DELAY, 0 );
+	RADEON_WRITE(RADEON_CP_RB_WPTR_DELAY, 0);
 
 	/* Initialize the ring buffer's read and write pointers */
-	cur_read_ptr = RADEON_READ( RADEON_CP_RB_RPTR );
-	RADEON_WRITE( RADEON_CP_RB_WPTR, cur_read_ptr );
-	SET_RING_HEAD( dev_priv, cur_read_ptr );
+	cur_read_ptr = RADEON_READ(RADEON_CP_RB_RPTR);
+	RADEON_WRITE(RADEON_CP_RB_WPTR, cur_read_ptr);
+	SET_RING_HEAD(dev_priv, cur_read_ptr);
 	dev_priv->ring.tail = cur_read_ptr;
 
 #if __OS_HAS_AGP
-	if ( !dev_priv->is_pci ) {
-		RADEON_WRITE( RADEON_CP_RB_RPTR_ADDR,
-			      dev_priv->ring_rptr->offset
-			      - dev->agp->base
-			      + dev_priv->gart_vm_start);
+	if (dev_priv->flags & CHIP_IS_AGP) {
+		/* set RADEON_AGP_BASE here instead of relying on X from user space */
+		RADEON_WRITE(RADEON_AGP_BASE, (unsigned int)dev->agp->base);
+		RADEON_WRITE(RADEON_CP_RB_RPTR_ADDR,
+			     dev_priv->ring_rptr->offset
+			     - dev->agp->base + dev_priv->gart_vm_start);
 	} else
 #endif
 	{
@@ -1164,11 +1158,10 @@ static void radeon_cp_init_ring_buffer( 
 		tmp_ofs = dev_priv->ring_rptr->offset - dev->sg->handle;
 		page_ofs = tmp_ofs >> PAGE_SHIFT;
 
-		RADEON_WRITE( RADEON_CP_RB_RPTR_ADDR,
-			     entry->busaddr[page_ofs]);
-		DRM_DEBUG( "ring rptr: offset=0x%08lx handle=0x%08lx\n",
-			   (unsigned long) entry->busaddr[page_ofs],
-			   entry->handle + tmp_ofs );
+		RADEON_WRITE(RADEON_CP_RB_RPTR_ADDR, entry->busaddr[page_ofs]);
+		DRM_DEBUG("ring rptr: offset=0x%08lx handle=0x%08lx\n",
+			  (unsigned long)entry->busaddr[page_ofs],
+			  entry->handle + tmp_ofs);
 	}
 
 	/* Initialize the scratch register pointer.  This will cause
@@ -1178,112 +1171,110 @@ static void radeon_cp_init_ring_buffer( 
 	 * We simply put this behind the ring read pointer, this works
 	 * with PCI GART as well as (whatever kind of) AGP GART
 	 */
-	RADEON_WRITE( RADEON_SCRATCH_ADDR, RADEON_READ( RADEON_CP_RB_RPTR_ADDR )
-					 + RADEON_SCRATCH_REG_OFFSET );
+	RADEON_WRITE(RADEON_SCRATCH_ADDR, RADEON_READ(RADEON_CP_RB_RPTR_ADDR)
+		     + RADEON_SCRATCH_REG_OFFSET);
 
 	dev_priv->scratch = ((__volatile__ u32 *)
 			     dev_priv->ring_rptr->handle +
 			     (RADEON_SCRATCH_REG_OFFSET / sizeof(u32)));
 
-	RADEON_WRITE( RADEON_SCRATCH_UMSK, 0x7 );
+	RADEON_WRITE(RADEON_SCRATCH_UMSK, 0x7);
 
 	/* Writeback doesn't seem to work everywhere, test it first */
-	DRM_WRITE32( dev_priv->ring_rptr, RADEON_SCRATCHOFF(1), 0 );
-	RADEON_WRITE( RADEON_SCRATCH_REG1, 0xdeadbeef );
+	DRM_WRITE32(dev_priv->ring_rptr, RADEON_SCRATCHOFF(1), 0);
+	RADEON_WRITE(RADEON_SCRATCH_REG1, 0xdeadbeef);
 
-	for ( tmp = 0 ; tmp < dev_priv->usec_timeout ; tmp++ ) {
-		if ( DRM_READ32( dev_priv->ring_rptr, RADEON_SCRATCHOFF(1) ) == 0xdeadbeef )
+	for (tmp = 0; tmp < dev_priv->usec_timeout; tmp++) {
+		if (DRM_READ32(dev_priv->ring_rptr, RADEON_SCRATCHOFF(1)) ==
+		    0xdeadbeef)
 			break;
-		DRM_UDELAY( 1 );
+		DRM_UDELAY(1);
 	}
 
-	if ( tmp < dev_priv->usec_timeout ) {
+	if (tmp < dev_priv->usec_timeout) {
 		dev_priv->writeback_works = 1;
-		DRM_DEBUG( "writeback test succeeded, tmp=%d\n", tmp );
+		DRM_DEBUG("writeback test succeeded, tmp=%d\n", tmp);
 	} else {
 		dev_priv->writeback_works = 0;
-		DRM_DEBUG( "writeback test failed\n" );
+		DRM_DEBUG("writeback test failed\n");
 	}
 
 	dev_priv->sarea_priv->last_frame = dev_priv->scratch[0] = 0;
-	RADEON_WRITE( RADEON_LAST_FRAME_REG,
-		      dev_priv->sarea_priv->last_frame );
+	RADEON_WRITE(RADEON_LAST_FRAME_REG, dev_priv->sarea_priv->last_frame);
 
 	dev_priv->sarea_priv->last_dispatch = dev_priv->scratch[1] = 0;
-	RADEON_WRITE( RADEON_LAST_DISPATCH_REG,
-		      dev_priv->sarea_priv->last_dispatch );
+	RADEON_WRITE(RADEON_LAST_DISPATCH_REG,
+		     dev_priv->sarea_priv->last_dispatch);
 
 	dev_priv->sarea_priv->last_clear = dev_priv->scratch[2] = 0;
-	RADEON_WRITE( RADEON_LAST_CLEAR_REG,
-		      dev_priv->sarea_priv->last_clear );
+	RADEON_WRITE(RADEON_LAST_CLEAR_REG, dev_priv->sarea_priv->last_clear);
 
 	/* Set ring buffer size */
 #ifdef __BIG_ENDIAN
-	RADEON_WRITE( RADEON_CP_RB_CNTL, dev_priv->ring.size_l2qw | RADEON_BUF_SWAP_32BIT );
+	RADEON_WRITE(RADEON_CP_RB_CNTL,
+		     dev_priv->ring.size_l2qw | RADEON_BUF_SWAP_32BIT);
 #else
-	RADEON_WRITE( RADEON_CP_RB_CNTL, dev_priv->ring.size_l2qw );
+	RADEON_WRITE(RADEON_CP_RB_CNTL, dev_priv->ring.size_l2qw);
 #endif
 
-	radeon_do_wait_for_idle( dev_priv );
+	radeon_do_wait_for_idle(dev_priv);
 
 	/* Turn on bus mastering */
-	tmp = RADEON_READ( RADEON_BUS_CNTL ) & ~RADEON_BUS_MASTER_DIS;
-	RADEON_WRITE( RADEON_BUS_CNTL, tmp );
+	tmp = RADEON_READ(RADEON_BUS_CNTL) & ~RADEON_BUS_MASTER_DIS;
+	RADEON_WRITE(RADEON_BUS_CNTL, tmp);
 
 	/* Sync everything up */
-	RADEON_WRITE( RADEON_ISYNC_CNTL,
-		      (RADEON_ISYNC_ANY2D_IDLE3D |
-		       RADEON_ISYNC_ANY3D_IDLE2D |
-		       RADEON_ISYNC_WAIT_IDLEGUI |
-		       RADEON_ISYNC_CPSCRATCH_IDLEGUI) );
+	RADEON_WRITE(RADEON_ISYNC_CNTL,
+		     (RADEON_ISYNC_ANY2D_IDLE3D |
+		      RADEON_ISYNC_ANY3D_IDLE2D |
+		      RADEON_ISYNC_WAIT_IDLEGUI |
+		      RADEON_ISYNC_CPSCRATCH_IDLEGUI));
 }
 
 /* Enable or disable PCI GART on the chip */
-static void radeon_set_pcigart( drm_radeon_private_t *dev_priv, int on )
+static void radeon_set_pcigart(drm_radeon_private_t * dev_priv, int on)
 {
-	u32 tmp	= RADEON_READ( RADEON_AIC_CNTL );
+	u32 tmp = RADEON_READ(RADEON_AIC_CNTL);
 
-	if ( on ) {
-		RADEON_WRITE( RADEON_AIC_CNTL, tmp | RADEON_PCIGART_TRANSLATE_EN );
+	if (on) {
+		RADEON_WRITE(RADEON_AIC_CNTL,
+			     tmp | RADEON_PCIGART_TRANSLATE_EN);
 
 		/* set PCI GART page-table base address
 		 */
-		RADEON_WRITE( RADEON_AIC_PT_BASE, dev_priv->bus_pci_gart );
+		RADEON_WRITE(RADEON_AIC_PT_BASE, dev_priv->bus_pci_gart);
 
 		/* set address range for PCI address translate
 		 */
-		RADEON_WRITE( RADEON_AIC_LO_ADDR, dev_priv->gart_vm_start );
-		RADEON_WRITE( RADEON_AIC_HI_ADDR, dev_priv->gart_vm_start
-						  + dev_priv->gart_size - 1);
+		RADEON_WRITE(RADEON_AIC_LO_ADDR, dev_priv->gart_vm_start);
+		RADEON_WRITE(RADEON_AIC_HI_ADDR, dev_priv->gart_vm_start
+			     + dev_priv->gart_size - 1);
 
 		/* Turn off AGP aperture -- is this required for PCI GART?
 		 */
-		RADEON_WRITE( RADEON_MC_AGP_LOCATION, 0xffffffc0 ); /* ?? */
-		RADEON_WRITE( RADEON_AGP_COMMAND, 0 ); /* clear AGP_COMMAND */
+		RADEON_WRITE(RADEON_MC_AGP_LOCATION, 0xffffffc0);	/* ?? */
+		RADEON_WRITE(RADEON_AGP_COMMAND, 0);	/* clear AGP_COMMAND */
 	} else {
-		RADEON_WRITE( RADEON_AIC_CNTL, tmp & ~RADEON_PCIGART_TRANSLATE_EN );
+		RADEON_WRITE(RADEON_AIC_CNTL,
+			     tmp & ~RADEON_PCIGART_TRANSLATE_EN);
 	}
 }
 
-static int radeon_do_init_cp( drm_device_t *dev, drm_radeon_init_t *init )
+static int radeon_do_init_cp(drm_device_t * dev, drm_radeon_init_t * init)
 {
-	drm_radeon_private_t *dev_priv = dev->dev_private;;
-	DRM_DEBUG( "\n" );
-
-	dev_priv->is_pci = init->is_pci;
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	DRM_DEBUG("\n");
 
-	if ( dev_priv->is_pci && !dev->sg ) {
-		DRM_ERROR( "PCI GART memory not allocated!\n" );
-		dev->dev_private = (void *)dev_priv;
+	if ((!(dev_priv->flags & CHIP_IS_AGP)) && !dev->sg) {
+		DRM_ERROR("PCI GART memory not allocated!\n");
 		radeon_do_cleanup_cp(dev);
 		return DRM_ERR(EINVAL);
 	}
 
 	dev_priv->usec_timeout = init->usec_timeout;
-	if ( dev_priv->usec_timeout < 1 ||
-	     dev_priv->usec_timeout > RADEON_MAX_USEC_TIMEOUT ) {
-		DRM_DEBUG( "TIMEOUT problem!\n" );
-		dev->dev_private = (void *)dev_priv;
+	if (dev_priv->usec_timeout < 1 ||
+	    dev_priv->usec_timeout > RADEON_MAX_USEC_TIMEOUT) {
+		DRM_DEBUG("TIMEOUT problem!\n");
 		radeon_do_cleanup_cp(dev);
 		return DRM_ERR(EINVAL);
 	}
@@ -1297,8 +1288,9 @@ static int radeon_do_init_cp( drm_device
 		break;
 	default:
 		dev_priv->microcode_version=UCODE_R100;
+		break;
 	}
-	
+
 	dev_priv->do_boxes = 0;
 	dev_priv->cp_mode = init->cp_mode;
 
@@ -1306,15 +1298,14 @@ static int radeon_do_init_cp( drm_device
 	 * but the ring can be in either AGP or PCI space for the ring
 	 * read pointer.
 	 */
-	if ( ( init->cp_mode != RADEON_CSQ_PRIBM_INDDIS ) &&
-	     ( init->cp_mode != RADEON_CSQ_PRIBM_INDBM ) ) {
-		DRM_DEBUG( "BAD cp_mode (%x)!\n", init->cp_mode );
-		dev->dev_private = (void *)dev_priv;
+	if ((init->cp_mode != RADEON_CSQ_PRIBM_INDDIS) &&
+	    (init->cp_mode != RADEON_CSQ_PRIBM_INDBM)) {
+		DRM_DEBUG("BAD cp_mode (%x)!\n", init->cp_mode);
 		radeon_do_cleanup_cp(dev);
 		return DRM_ERR(EINVAL);
 	}
 
-	switch ( init->fb_bpp ) {
+	switch (init->fb_bpp) {
 	case 16:
 		dev_priv->color_fmt = RADEON_COLOR_FORMAT_RGB565;
 		break;
@@ -1323,12 +1314,12 @@ static int radeon_do_init_cp( drm_device
 		dev_priv->color_fmt = RADEON_COLOR_FORMAT_ARGB8888;
 		break;
 	}
-	dev_priv->front_offset	= init->front_offset;
-	dev_priv->front_pitch	= init->front_pitch;
-	dev_priv->back_offset	= init->back_offset;
-	dev_priv->back_pitch	= init->back_pitch;
+	dev_priv->front_offset = init->front_offset;
+	dev_priv->front_pitch = init->front_pitch;
+	dev_priv->back_offset = init->back_offset;
+	dev_priv->back_pitch = init->back_pitch;
 
-	switch ( init->depth_bpp ) {
+	switch (init->depth_bpp) {
 	case 16:
 		dev_priv->depth_fmt = RADEON_DEPTH_FORMAT_16BIT_INT_Z;
 		break;
@@ -1337,8 +1328,8 @@ static int radeon_do_init_cp( drm_device
 		dev_priv->depth_fmt = RADEON_DEPTH_FORMAT_24BIT_INT_Z;
 		break;
 	}
-	dev_priv->depth_offset	= init->depth_offset;
-	dev_priv->depth_pitch	= init->depth_pitch;
+	dev_priv->depth_offset = init->depth_offset;
+	dev_priv->depth_pitch = init->depth_pitch;
 
 	/* Hardware state for depth clears.  Remove this if/when we no
 	 * longer clear the depth buffer with a 3D rectangle.  Hard-code
@@ -1347,16 +1338,16 @@ static int radeon_do_init_cp( drm_device
 	 */
 	dev_priv->depth_clear.rb3d_cntl = (RADEON_PLANE_MASK_ENABLE |
 					   (dev_priv->color_fmt << 10) |
-					   (dev_priv->microcode_version == UCODE_R100 ? RADEON_ZBLOCK16 : 0));
+					   (dev_priv->microcode_version == UCODE_R100 ?
+						RADEON_ZBLOCK16 : 0));
 
-	dev_priv->depth_clear.rb3d_zstencilcntl = 
-		(dev_priv->depth_fmt |
-		 RADEON_Z_TEST_ALWAYS |
-		 RADEON_STENCIL_TEST_ALWAYS |
-		 RADEON_STENCIL_S_FAIL_REPLACE |
-		 RADEON_STENCIL_ZPASS_REPLACE |
-		 RADEON_STENCIL_ZFAIL_REPLACE |
-		 RADEON_Z_WRITE_ENABLE);
+	dev_priv->depth_clear.rb3d_zstencilcntl =
+	    (dev_priv->depth_fmt |
+	     RADEON_Z_TEST_ALWAYS |
+	     RADEON_STENCIL_TEST_ALWAYS |
+	     RADEON_STENCIL_S_FAIL_REPLACE |
+	     RADEON_STENCIL_ZPASS_REPLACE |
+	     RADEON_STENCIL_ZFAIL_REPLACE | RADEON_Z_WRITE_ENABLE);
 
 	dev_priv->depth_clear.se_cntl = (RADEON_FFACE_CULL_CW |
 					 RADEON_BFACE_SOLID |
@@ -1378,284 +1369,274 @@ static int radeon_do_init_cp( drm_device
 	dev_priv->ring_rptr_offset = init->ring_rptr_offset;
 	dev_priv->buffers_offset = init->buffers_offset;
 	dev_priv->gart_textures_offset = init->gart_textures_offset;
-	
-	if(!dev_priv->sarea) {
+
+	if (!dev_priv->sarea) {
 		DRM_ERROR("could not find sarea!\n");
-		dev->dev_private = (void *)dev_priv;
 		radeon_do_cleanup_cp(dev);
 		return DRM_ERR(EINVAL);
 	}
 
 	dev_priv->mmio = drm_core_findmap(dev, init->mmio_offset);
-	if(!dev_priv->mmio) {
+	if (!dev_priv->mmio) {
 		DRM_ERROR("could not find mmio region!\n");
-		dev->dev_private = (void *)dev_priv;
 		radeon_do_cleanup_cp(dev);
 		return DRM_ERR(EINVAL);
 	}
 	dev_priv->cp_ring = drm_core_findmap(dev, init->ring_offset);
-	if(!dev_priv->cp_ring) {
+	if (!dev_priv->cp_ring) {
 		DRM_ERROR("could not find cp ring region!\n");
-		dev->dev_private = (void *)dev_priv;
 		radeon_do_cleanup_cp(dev);
 		return DRM_ERR(EINVAL);
 	}
 	dev_priv->ring_rptr = drm_core_findmap(dev, init->ring_rptr_offset);
-	if(!dev_priv->ring_rptr) {
+	if (!dev_priv->ring_rptr) {
 		DRM_ERROR("could not find ring read pointer!\n");
-		dev->dev_private = (void *)dev_priv;
 		radeon_do_cleanup_cp(dev);
 		return DRM_ERR(EINVAL);
 	}
 	dev->agp_buffer_map = drm_core_findmap(dev, init->buffers_offset);
-	if(!dev->agp_buffer_map) {
+	if (!dev->agp_buffer_map) {
 		DRM_ERROR("could not find dma buffer region!\n");
-		dev->dev_private = (void *)dev_priv;
 		radeon_do_cleanup_cp(dev);
 		return DRM_ERR(EINVAL);
 	}
 
-	if ( init->gart_textures_offset ) {
-		dev_priv->gart_textures = drm_core_findmap(dev, init->gart_textures_offset);
-		if ( !dev_priv->gart_textures ) {
+	if (init->gart_textures_offset) {
+		dev_priv->gart_textures =
+		    drm_core_findmap(dev, init->gart_textures_offset);
+		if (!dev_priv->gart_textures) {
 			DRM_ERROR("could not find GART texture region!\n");
-			dev->dev_private = (void *)dev_priv;
 			radeon_do_cleanup_cp(dev);
 			return DRM_ERR(EINVAL);
 		}
 	}
 
 	dev_priv->sarea_priv =
-		(drm_radeon_sarea_t *)((u8 *)dev_priv->sarea->handle +
-				       init->sarea_priv_offset);
+	    (drm_radeon_sarea_t *) ((u8 *) dev_priv->sarea->handle +
+				    init->sarea_priv_offset);
 
 #if __OS_HAS_AGP
-	if ( !dev_priv->is_pci ) {
-		drm_core_ioremap( dev_priv->cp_ring, dev );
-		drm_core_ioremap( dev_priv->ring_rptr, dev );
-		drm_core_ioremap( dev->agp_buffer_map, dev );
-		if(!dev_priv->cp_ring->handle ||
-		   !dev_priv->ring_rptr->handle ||
-		   !dev->agp_buffer_map->handle) {
+	if (dev_priv->flags & CHIP_IS_AGP) {
+		drm_core_ioremap(dev_priv->cp_ring, dev);
+		drm_core_ioremap(dev_priv->ring_rptr, dev);
+		drm_core_ioremap(dev->agp_buffer_map, dev);
+		if (!dev_priv->cp_ring->handle ||
+		    !dev_priv->ring_rptr->handle ||
+		    !dev->agp_buffer_map->handle) {
 			DRM_ERROR("could not find ioremap agp regions!\n");
-			dev->dev_private = (void *)dev_priv;
 			radeon_do_cleanup_cp(dev);
 			return DRM_ERR(EINVAL);
 		}
 	} else
 #endif
 	{
-		dev_priv->cp_ring->handle =
-			(void *)dev_priv->cp_ring->offset;
+		dev_priv->cp_ring->handle = (void *)dev_priv->cp_ring->offset;
 		dev_priv->ring_rptr->handle =
-			(void *)dev_priv->ring_rptr->offset;
-		dev->agp_buffer_map->handle = (void *)dev->agp_buffer_map->offset;
-
-		DRM_DEBUG( "dev_priv->cp_ring->handle %p\n",
-			   dev_priv->cp_ring->handle );
-		DRM_DEBUG( "dev_priv->ring_rptr->handle %p\n",
-			   dev_priv->ring_rptr->handle );
-		DRM_DEBUG( "dev->agp_buffer_map->handle %p\n",
-			   dev->agp_buffer_map->handle );
-	}
-
-	dev_priv->fb_location = ( RADEON_READ( RADEON_MC_FB_LOCATION )
-				& 0xffff ) << 16;
-
-	dev_priv->front_pitch_offset = (((dev_priv->front_pitch/64) << 22) |
-					( ( dev_priv->front_offset
-					  + dev_priv->fb_location ) >> 10 ) );
-
-	dev_priv->back_pitch_offset = (((dev_priv->back_pitch/64) << 22) |
-				       ( ( dev_priv->back_offset
-					 + dev_priv->fb_location ) >> 10 ) );
-
-	dev_priv->depth_pitch_offset = (((dev_priv->depth_pitch/64) << 22) |
-					( ( dev_priv->depth_offset
-					  + dev_priv->fb_location ) >> 10 ) );
-
+		    (void *)dev_priv->ring_rptr->offset;
+		dev->agp_buffer_map->handle =
+		    (void *)dev->agp_buffer_map->offset;
+
+		DRM_DEBUG("dev_priv->cp_ring->handle %p\n",
+			  dev_priv->cp_ring->handle);
+		DRM_DEBUG("dev_priv->ring_rptr->handle %p\n",
+			  dev_priv->ring_rptr->handle);
+		DRM_DEBUG("dev->agp_buffer_map->handle %p\n",
+			  dev->agp_buffer_map->handle);
+	}
+
+	dev_priv->fb_location = (RADEON_READ(RADEON_MC_FB_LOCATION)
+				 & 0xffff) << 16;
+
+	dev_priv->front_pitch_offset = (((dev_priv->front_pitch / 64) << 22) |
+					((dev_priv->front_offset
+					  + dev_priv->fb_location) >> 10));
+
+	dev_priv->back_pitch_offset = (((dev_priv->back_pitch / 64) << 22) |
+				       ((dev_priv->back_offset
+					 + dev_priv->fb_location) >> 10));
+
+	dev_priv->depth_pitch_offset = (((dev_priv->depth_pitch / 64) << 22) |
+					((dev_priv->depth_offset
+					  + dev_priv->fb_location) >> 10));
 
 	dev_priv->gart_size = init->gart_size;
 	dev_priv->gart_vm_start = dev_priv->fb_location
-				+ RADEON_READ( RADEON_CONFIG_APER_SIZE );
+	    + RADEON_READ(RADEON_CONFIG_APER_SIZE);
 
 #if __OS_HAS_AGP
-	if ( !dev_priv->is_pci )
+	if (dev_priv->flags & CHIP_IS_AGP)
 		dev_priv->gart_buffers_offset = (dev->agp_buffer_map->offset
-						- dev->agp->base
-						+ dev_priv->gart_vm_start);
+						 - dev->agp->base
+						 + dev_priv->gart_vm_start);
 	else
 #endif
 		dev_priv->gart_buffers_offset = (dev->agp_buffer_map->offset
-						- dev->sg->handle
-						+ dev_priv->gart_vm_start);
+						 - dev->sg->handle
+						 + dev_priv->gart_vm_start);
 
-	DRM_DEBUG( "dev_priv->gart_size %d\n",
-		   dev_priv->gart_size );
-	DRM_DEBUG( "dev_priv->gart_vm_start 0x%x\n",
-		   dev_priv->gart_vm_start );
-	DRM_DEBUG( "dev_priv->gart_buffers_offset 0x%lx\n",
-		   dev_priv->gart_buffers_offset );
+	DRM_DEBUG("dev_priv->gart_size %d\n", dev_priv->gart_size);
+	DRM_DEBUG("dev_priv->gart_vm_start 0x%x\n", dev_priv->gart_vm_start);
+	DRM_DEBUG("dev_priv->gart_buffers_offset 0x%lx\n",
+		  dev_priv->gart_buffers_offset);
 
-	dev_priv->ring.start = (u32 *)dev_priv->cp_ring->handle;
-	dev_priv->ring.end = ((u32 *)dev_priv->cp_ring->handle
+	dev_priv->ring.start = (u32 *) dev_priv->cp_ring->handle;
+	dev_priv->ring.end = ((u32 *) dev_priv->cp_ring->handle
 			      + init->ring_size / sizeof(u32));
 	dev_priv->ring.size = init->ring_size;
-	dev_priv->ring.size_l2qw = drm_order( init->ring_size / 8 );
+	dev_priv->ring.size_l2qw = drm_order(init->ring_size / 8);
 
-	dev_priv->ring.tail_mask =
-		(dev_priv->ring.size / sizeof(u32)) - 1;
+	dev_priv->ring.tail_mask = (dev_priv->ring.size / sizeof(u32)) - 1;
 
 	dev_priv->ring.high_mark = RADEON_RING_HIGH_MARK;
 
 #if __OS_HAS_AGP
-	if ( !dev_priv->is_pci ) {
+	if (dev_priv->flags & CHIP_IS_AGP) {
 		/* Turn off PCI GART */
-		radeon_set_pcigart( dev_priv, 0 );
+		radeon_set_pcigart(dev_priv, 0);
 	} else
 #endif
 	{
-		if (!drm_ati_pcigart_init( dev, &dev_priv->phys_pci_gart,
-					    &dev_priv->bus_pci_gart)) {
-			DRM_ERROR( "failed to init PCI GART!\n" );
-			dev->dev_private = (void *)dev_priv;
+		if (!drm_ati_pcigart_init(dev, &dev_priv->phys_pci_gart,
+					  &dev_priv->bus_pci_gart)) {
+			DRM_ERROR("failed to init PCI GART!\n");
 			radeon_do_cleanup_cp(dev);
 			return DRM_ERR(ENOMEM);
 		}
 
 		/* Turn on PCI GART */
-		radeon_set_pcigart( dev_priv, 1 );
+		radeon_set_pcigart(dev_priv, 1);
 	}
 
-	radeon_cp_load_microcode( dev_priv );
-	radeon_cp_init_ring_buffer( dev, dev_priv );
+	radeon_cp_load_microcode(dev_priv);
+	radeon_cp_init_ring_buffer(dev, dev_priv);
 
 	dev_priv->last_buf = 0;
 
-	dev->dev_private = (void *)dev_priv;
-
-	radeon_do_engine_reset( dev );
+	radeon_do_engine_reset(dev);
 
 	return 0;
 }
 
-static int radeon_do_cleanup_cp( drm_device_t *dev )
+static int radeon_do_cleanup_cp(drm_device_t * dev)
 {
 	drm_radeon_private_t *dev_priv = dev->dev_private;
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
 	/* Make sure interrupts are disabled here because the uninstall ioctl
 	 * may not have been called from userspace and after dev_private
 	 * is freed, it's too late.
 	 */
-	if ( dev->irq_enabled ) drm_irq_uninstall(dev);
+	if (dev->irq_enabled)
+		drm_irq_uninstall(dev);
 
 #if __OS_HAS_AGP
-	if ( !dev_priv->is_pci ) {
-		if ( dev_priv->cp_ring != NULL )
-			drm_core_ioremapfree( dev_priv->cp_ring, dev );
-		if ( dev_priv->ring_rptr != NULL )
-			drm_core_ioremapfree( dev_priv->ring_rptr, dev );
-		if ( dev->agp_buffer_map != NULL )
-		{
-			drm_core_ioremapfree( dev->agp_buffer_map, dev );
+	if (dev_priv->flags & CHIP_IS_AGP) {
+		if (dev_priv->cp_ring != NULL) {
+			drm_core_ioremapfree(dev_priv->cp_ring, dev);
+			dev_priv->cp_ring = NULL;
+		}
+		if (dev_priv->ring_rptr != NULL) {
+			drm_core_ioremapfree(dev_priv->ring_rptr, dev);
+			dev_priv->ring_rptr = NULL;
+		}
+		if (dev->agp_buffer_map != NULL) {
+			drm_core_ioremapfree(dev->agp_buffer_map, dev);
 			dev->agp_buffer_map = NULL;
 		}
 	} else
 #endif
 	{
-		if (!drm_ati_pcigart_cleanup( dev,
-					      dev_priv->phys_pci_gart,
-					      dev_priv->bus_pci_gart ))
-			DRM_ERROR( "failed to cleanup PCI GART!\n" );
+		if (!drm_ati_pcigart_cleanup(dev,
+					     dev_priv->phys_pci_gart,
+					     dev_priv->bus_pci_gart))
+			DRM_ERROR("failed to cleanup PCI GART!\n");
 	}
-	
 	/* only clear to the start of flags */
 	memset(dev_priv, 0, offsetof(drm_radeon_private_t, flags));
 
 	return 0;
 }
 
-/* This code will reinit the Radeon CP hardware after a resume from disc.  
- * AFAIK, it would be very difficult to pickle the state at suspend time, so 
+/* This code will reinit the Radeon CP hardware after a resume from disc.
+ * AFAIK, it would be very difficult to pickle the state at suspend time, so
  * here we make sure that all Radeon hardware initialisation is re-done without
  * affecting running applications.
  *
  * Charl P. Botha <http://cpbotha.net>
  */
-static int radeon_do_resume_cp( drm_device_t *dev )
+static int radeon_do_resume_cp(drm_device_t * dev)
 {
 	drm_radeon_private_t *dev_priv = dev->dev_private;
 
-	if ( !dev_priv ) {
-		DRM_ERROR( "Called with no initialization\n" );
-		return DRM_ERR( EINVAL );
+	if (!dev_priv) {
+		DRM_ERROR("Called with no initialization\n");
+		return DRM_ERR(EINVAL);
 	}
 
 	DRM_DEBUG("Starting radeon_do_resume_cp()\n");
 
 #if __OS_HAS_AGP
-	if ( !dev_priv->is_pci ) {
+	if (dev_priv->flags & CHIP_IS_AGP) {
 		/* Turn off PCI GART */
-		radeon_set_pcigart( dev_priv, 0 );
+		radeon_set_pcigart(dev_priv, 0);
 	} else
 #endif
 	{
 		/* Turn on PCI GART */
-		radeon_set_pcigart( dev_priv, 1 );
+		radeon_set_pcigart(dev_priv, 1);
 	}
 
-	radeon_cp_load_microcode( dev_priv );
-	radeon_cp_init_ring_buffer( dev, dev_priv );
+	radeon_cp_load_microcode(dev_priv);
+	radeon_cp_init_ring_buffer(dev, dev_priv);
 
-	radeon_do_engine_reset( dev );
+	radeon_do_engine_reset(dev);
 
 	DRM_DEBUG("radeon_do_resume_cp() complete\n");
 
 	return 0;
 }
 
-
-int radeon_cp_init( DRM_IOCTL_ARGS )
+int radeon_cp_init(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_radeon_init_t init;
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	DRM_COPY_FROM_USER_IOCTL( init, (drm_radeon_init_t __user *)data, sizeof(init) );
+	DRM_COPY_FROM_USER_IOCTL(init, (drm_radeon_init_t __user *) data,
+				 sizeof(init));
 
-	switch ( init.func ) {
+	switch (init.func) {
 	case RADEON_INIT_CP:
 	case RADEON_INIT_R200_CP:
 	case RADEON_INIT_R300_CP:
-		return radeon_do_init_cp( dev, &init );
+		return radeon_do_init_cp(dev, &init);
 	case RADEON_CLEANUP_CP:
-		return radeon_do_cleanup_cp( dev );
+		return radeon_do_cleanup_cp(dev);
 	}
 
 	return DRM_ERR(EINVAL);
 }
 
-int radeon_cp_start( DRM_IOCTL_ARGS )
+int radeon_cp_start(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_radeon_private_t *dev_priv = dev->dev_private;
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	if ( dev_priv->cp_running ) {
-		DRM_DEBUG( "%s while CP running\n", __FUNCTION__ );
+	if (dev_priv->cp_running) {
+		DRM_DEBUG("%s while CP running\n", __FUNCTION__);
 		return 0;
 	}
-	if ( dev_priv->cp_mode == RADEON_CSQ_PRIDIS_INDDIS ) {
-		DRM_DEBUG( "%s called with bogus CP mode (%d)\n",
-			   __FUNCTION__, dev_priv->cp_mode );
+	if (dev_priv->cp_mode == RADEON_CSQ_PRIDIS_INDDIS) {
+		DRM_DEBUG("%s called with bogus CP mode (%d)\n",
+			  __FUNCTION__, dev_priv->cp_mode);
 		return 0;
 	}
 
-	radeon_do_cp_start( dev_priv );
+	radeon_do_cp_start(dev_priv);
 
 	return 0;
 }
@@ -1663,17 +1644,18 @@ int radeon_cp_start( DRM_IOCTL_ARGS )
 /* Stop the CP.  The engine must have been idled before calling this
  * routine.
  */
-int radeon_cp_stop( DRM_IOCTL_ARGS )
+int radeon_cp_stop(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_radeon_private_t *dev_priv = dev->dev_private;
 	drm_radeon_cp_stop_t stop;
 	int ret;
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	DRM_COPY_FROM_USER_IOCTL( stop, (drm_radeon_cp_stop_t __user *)data, sizeof(stop) );
+	DRM_COPY_FROM_USER_IOCTL(stop, (drm_radeon_cp_stop_t __user *) data,
+				 sizeof(stop));
 
 	if (!dev_priv->cp_running)
 		return 0;
@@ -1681,54 +1663,60 @@ int radeon_cp_stop( DRM_IOCTL_ARGS )
 	/* Flush any pending CP commands.  This ensures any outstanding
 	 * commands are exectuted by the engine before we turn it off.
 	 */
-	if ( stop.flush ) {
-		radeon_do_cp_flush( dev_priv );
+	if (stop.flush) {
+		radeon_do_cp_flush(dev_priv);
 	}
 
 	/* If we fail to make the engine go idle, we return an error
 	 * code so that the DRM ioctl wrapper can try again.
 	 */
-	if ( stop.idle ) {
-		ret = radeon_do_cp_idle( dev_priv );
-		if ( ret ) return ret;
+	if (stop.idle) {
+		ret = radeon_do_cp_idle(dev_priv);
+		if (ret)
+			return ret;
 	}
 
 	/* Finally, we can turn off the CP.  If the engine isn't idle,
 	 * we will get some dropped triangles as they won't be fully
 	 * rendered before the CP is shut down.
 	 */
-	radeon_do_cp_stop( dev_priv );
+	radeon_do_cp_stop(dev_priv);
 
 	/* Reset the engine */
-	radeon_do_engine_reset( dev );
+	radeon_do_engine_reset(dev);
 
 	return 0;
 }
 
-
-void radeon_do_release( drm_device_t *dev )
+void radeon_do_release(drm_device_t * dev)
 {
 	drm_radeon_private_t *dev_priv = dev->dev_private;
 	int i, ret;
 
 	if (dev_priv) {
+
 		if (dev_priv->cp_running) {
 			/* Stop the cp */
-			while ((ret = radeon_do_cp_idle( dev_priv )) != 0) {
+			while ((ret = radeon_do_cp_idle(dev_priv)) != 0) {
 				DRM_DEBUG("radeon_do_cp_idle %d\n", ret);
 #ifdef __linux__
 				schedule();
 #else
+#if defined(__FreeBSD__) && __FreeBSD_version > 500000
+				msleep(&ret, &dev->dev_lock, PZERO, "rdnrel",
+				       1);
+#else
 				tsleep(&ret, PZERO, "rdnrel", 1);
 #endif
+#endif
 			}
-			radeon_do_cp_stop( dev_priv );
-			radeon_do_engine_reset( dev );
+			radeon_do_cp_stop(dev_priv);
+			radeon_do_engine_reset(dev);
 		}
 
 		/* Disable *all* interrupts */
 		if (dev_priv->mmio)	/* remove this after permanent addmaps */
-			RADEON_WRITE( RADEON_GEN_INT_CNTL, 0 );
+			RADEON_WRITE(RADEON_GEN_INT_CNTL, 0);
 
 		if (dev_priv->mmio) {/* remove all surfaces */
 			for (i = 0; i < RADEON_MAX_SURFACES; i++) {
@@ -1739,30 +1727,30 @@ void radeon_do_release( drm_device_t *de
 		}
 
 		/* Free memory heap structures */
-		radeon_mem_takedown( &(dev_priv->gart_heap) );
-		radeon_mem_takedown( &(dev_priv->fb_heap) );
+		radeon_mem_takedown(&(dev_priv->gart_heap));
+		radeon_mem_takedown(&(dev_priv->fb_heap));
 
 		/* deallocate kernel resources */
-		radeon_do_cleanup_cp( dev );
+		radeon_do_cleanup_cp(dev);
 	}
 }
 
 /* Just reset the CP ring.  Called as part of an X Server engine reset.
  */
-int radeon_cp_reset( DRM_IOCTL_ARGS )
+int radeon_cp_reset(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_radeon_private_t *dev_priv = dev->dev_private;
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	if ( !dev_priv ) {
-		DRM_DEBUG( "%s called before init done\n", __FUNCTION__ );
+	if (!dev_priv) {
+		DRM_DEBUG("%s called before init done\n", __FUNCTION__);
 		return DRM_ERR(EINVAL);
 	}
 
-	radeon_do_cp_reset( dev_priv );
+	radeon_do_cp_reset(dev_priv);
 
 	/* The CP is no longer running after an engine reset */
 	dev_priv->cp_running = 0;
@@ -1770,50 +1758,47 @@ int radeon_cp_reset( DRM_IOCTL_ARGS )
 	return 0;
 }
 
-int radeon_cp_idle( DRM_IOCTL_ARGS )
+int radeon_cp_idle(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_radeon_private_t *dev_priv = dev->dev_private;
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	return radeon_do_cp_idle( dev_priv );
+	return radeon_do_cp_idle(dev_priv);
 }
 
 /* Added by Charl P. Botha to call radeon_do_resume_cp().
  */
-int radeon_cp_resume( DRM_IOCTL_ARGS )
+int radeon_cp_resume(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 
 	return radeon_do_resume_cp(dev);
 }
 
-
-int radeon_engine_reset( DRM_IOCTL_ARGS )
+int radeon_engine_reset(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	return radeon_do_engine_reset( dev );
+	return radeon_do_engine_reset(dev);
 }
 
-
 /* ================================================================
  * Fullscreen mode
  */
 
 /* KW: Deprecated to say the least:
  */
-int radeon_fullscreen( DRM_IOCTL_ARGS )
+int radeon_fullscreen(DRM_IOCTL_ARGS)
 {
 	return 0;
 }
 
-
 /* ================================================================
  * Freelist management
  */
@@ -1822,20 +1807,20 @@ int radeon_fullscreen( DRM_IOCTL_ARGS )
  *   bufs until freelist code is used.  Note this hides a problem with
  *   the scratch register * (used to keep track of last buffer
  *   completed) being written to before * the last buffer has actually
- *   completed rendering.  
+ *   completed rendering.
  *
  * KW:  It's also a good way to find free buffers quickly.
  *
  * KW: Ideally this loop wouldn't exist, and freelist_get wouldn't
  * sleep.  However, bugs in older versions of radeon_accel.c mean that
  * we essentially have to do this, else old clients will break.
- * 
+ *
  * However, it does leave open a potential deadlock where all the
  * buffers are held by other clients, which can't release them because
- * they can't get the lock.  
+ * they can't get the lock.
  */
 
-drm_buf_t *radeon_freelist_get( drm_device_t *dev )
+drm_buf_t *radeon_freelist_get(drm_device_t * dev)
 {
 	drm_device_dma_t *dma = dev->dma;
 	drm_radeon_private_t *dev_priv = dev->dev_private;
@@ -1844,19 +1829,19 @@ drm_buf_t *radeon_freelist_get( drm_devi
 	int i, t;
 	int start;
 
-	if ( ++dev_priv->last_buf >= dma->buf_count )
+	if (++dev_priv->last_buf >= dma->buf_count)
 		dev_priv->last_buf = 0;
 
 	start = dev_priv->last_buf;
 
-	for ( t = 0 ; t < dev_priv->usec_timeout ; t++ ) {
-		u32 done_age = GET_SCRATCH( 1 );
-		DRM_DEBUG("done_age = %d\n",done_age);
-		for ( i = start ; i < dma->buf_count ; i++ ) {
+	for (t = 0; t < dev_priv->usec_timeout; t++) {
+		u32 done_age = GET_SCRATCH(1);
+		DRM_DEBUG("done_age = %d\n", done_age);
+		for (i = start; i < dma->buf_count; i++) {
 			buf = dma->buflist[i];
 			buf_priv = buf->dev_private;
-			if ( buf->filp == 0 || (buf->pending && 
-					       buf_priv->age <= done_age) ) {
+			if (buf->filp == 0 || (buf->pending &&
+					       buf_priv->age <= done_age)) {
 				dev_priv->stats.requested_bufs++;
 				buf->pending = 0;
 				return buf;
@@ -1865,16 +1850,17 @@ drm_buf_t *radeon_freelist_get( drm_devi
 		}
 
 		if (t) {
-			DRM_UDELAY( 1 );
+			DRM_UDELAY(1);
 			dev_priv->stats.freelist_loops++;
 		}
 	}
 
-	DRM_DEBUG( "returning NULL!\n" );
+	DRM_DEBUG("returning NULL!\n");
 	return NULL;
 }
+
 #if 0
-drm_buf_t *radeon_freelist_get( drm_device_t *dev )
+drm_buf_t *radeon_freelist_get(drm_device_t * dev)
 {
 	drm_device_dma_t *dma = dev->dma;
 	drm_radeon_private_t *dev_priv = dev->dev_private;
@@ -1884,18 +1870,18 @@ drm_buf_t *radeon_freelist_get( drm_devi
 	int start;
 	u32 done_age = DRM_READ32(dev_priv->ring_rptr, RADEON_SCRATCHOFF(1));
 
-	if ( ++dev_priv->last_buf >= dma->buf_count )
+	if (++dev_priv->last_buf >= dma->buf_count)
 		dev_priv->last_buf = 0;
 
 	start = dev_priv->last_buf;
 	dev_priv->stats.freelist_loops++;
-	
-	for ( t = 0 ; t < 2 ; t++ ) {
-		for ( i = start ; i < dma->buf_count ; i++ ) {
+
+	for (t = 0; t < 2; t++) {
+		for (i = start; i < dma->buf_count; i++) {
 			buf = dma->buflist[i];
 			buf_priv = buf->dev_private;
-			if ( buf->filp == 0 || (buf->pending && 
-					       buf_priv->age <= done_age) ) {
+			if (buf->filp == 0 || (buf->pending &&
+					       buf_priv->age <= done_age)) {
 				dev_priv->stats.requested_bufs++;
 				buf->pending = 0;
 				return buf;
@@ -1908,73 +1894,74 @@ drm_buf_t *radeon_freelist_get( drm_devi
 }
 #endif
 
-void radeon_freelist_reset( drm_device_t *dev )
+void radeon_freelist_reset(drm_device_t * dev)
 {
 	drm_device_dma_t *dma = dev->dma;
 	drm_radeon_private_t *dev_priv = dev->dev_private;
 	int i;
 
 	dev_priv->last_buf = 0;
-	for ( i = 0 ; i < dma->buf_count ; i++ ) {
+	for (i = 0; i < dma->buf_count; i++) {
 		drm_buf_t *buf = dma->buflist[i];
 		drm_radeon_buf_priv_t *buf_priv = buf->dev_private;
 		buf_priv->age = 0;
 	}
 }
 
-
 /* ================================================================
  * CP command submission
  */
 
-int radeon_wait_ring( drm_radeon_private_t *dev_priv, int n )
+int radeon_wait_ring(drm_radeon_private_t * dev_priv, int n)
 {
 	drm_radeon_ring_buffer_t *ring = &dev_priv->ring;
 	int i;
-	u32 last_head = GET_RING_HEAD( dev_priv );
+	u32 last_head = GET_RING_HEAD(dev_priv);
 
-	for ( i = 0 ; i < dev_priv->usec_timeout ; i++ ) {
-		u32 head = GET_RING_HEAD( dev_priv );
+	for (i = 0; i < dev_priv->usec_timeout; i++) {
+		u32 head = GET_RING_HEAD(dev_priv);
 
 		ring->space = (head - ring->tail) * sizeof(u32);
-		if ( ring->space <= 0 )
+		if (ring->space <= 0)
 			ring->space += ring->size;
-		if ( ring->space > n )
+		if (ring->space > n)
 			return 0;
-		
+
 		dev_priv->stats.boxes |= RADEON_BOX_WAIT_IDLE;
 
 		if (head != last_head)
 			i = 0;
 		last_head = head;
 
-		DRM_UDELAY( 1 );
+		DRM_UDELAY(1);
 	}
 
 	/* FIXME: This return value is ignored in the BEGIN_RING macro! */
 #if RADEON_FIFO_DEBUG
-	radeon_status( dev_priv );
-	DRM_ERROR( "failed!\n" );
+	radeon_status(dev_priv);
+	DRM_ERROR("failed!\n");
 #endif
 	return DRM_ERR(EBUSY);
 }
 
-static int radeon_cp_get_buffers( DRMFILE filp, drm_device_t *dev, drm_dma_t *d )
+static int radeon_cp_get_buffers(DRMFILE filp, drm_device_t * dev,
+				 drm_dma_t * d)
 {
 	int i;
 	drm_buf_t *buf;
 
-	for ( i = d->granted_count ; i < d->request_count ; i++ ) {
-		buf = radeon_freelist_get( dev );
-		if ( !buf ) return DRM_ERR(EBUSY); /* NOTE: broken client */
+	for (i = d->granted_count; i < d->request_count; i++) {
+		buf = radeon_freelist_get(dev);
+		if (!buf)
+			return DRM_ERR(EBUSY);	/* NOTE: broken client */
 
 		buf->filp = filp;
 
-		if ( DRM_COPY_TO_USER( &d->request_indices[i], &buf->idx,
-				   sizeof(buf->idx) ) )
+		if (DRM_COPY_TO_USER(&d->request_indices[i], &buf->idx,
+				     sizeof(buf->idx)))
 			return DRM_ERR(EFAULT);
-		if ( DRM_COPY_TO_USER( &d->request_sizes[i], &buf->total,
-				   sizeof(buf->total) ) )
+		if (DRM_COPY_TO_USER(&d->request_sizes[i], &buf->total,
+				     sizeof(buf->total)))
 			return DRM_ERR(EFAULT);
 
 		d->granted_count++;
@@ -1982,7 +1969,7 @@ static int radeon_cp_get_buffers( DRMFIL
 	return 0;
 }
 
-int radeon_cp_buffers( DRM_IOCTL_ARGS )
+int radeon_cp_buffers(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_device_dma_t *dma = dev->dma;
@@ -1990,38 +1977,39 @@ int radeon_cp_buffers( DRM_IOCTL_ARGS )
 	drm_dma_t __user *argp = (void __user *)data;
 	drm_dma_t d;
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	DRM_COPY_FROM_USER_IOCTL( d, argp, sizeof(d) );
+	DRM_COPY_FROM_USER_IOCTL(d, argp, sizeof(d));
 
 	/* Please don't send us buffers.
 	 */
-	if ( d.send_count != 0 ) {
-		DRM_ERROR( "Process %d trying to send %d buffers via drmDMA\n",
-			   DRM_CURRENTPID, d.send_count );
+	if (d.send_count != 0) {
+		DRM_ERROR("Process %d trying to send %d buffers via drmDMA\n",
+			  DRM_CURRENTPID, d.send_count);
 		return DRM_ERR(EINVAL);
 	}
 
 	/* We'll send you buffers.
 	 */
-	if ( d.request_count < 0 || d.request_count > dma->buf_count ) {
-		DRM_ERROR( "Process %d trying to get %d buffers (of %d max)\n",
-			   DRM_CURRENTPID, d.request_count, dma->buf_count );
+	if (d.request_count < 0 || d.request_count > dma->buf_count) {
+		DRM_ERROR("Process %d trying to get %d buffers (of %d max)\n",
+			  DRM_CURRENTPID, d.request_count, dma->buf_count);
 		return DRM_ERR(EINVAL);
 	}
 
 	d.granted_count = 0;
 
-	if ( d.request_count ) {
-		ret = radeon_cp_get_buffers( filp, dev, &d );
+	if (d.request_count) {
+		ret = radeon_cp_get_buffers(filp, dev, &d);
 	}
 
-	DRM_COPY_TO_USER_IOCTL( argp, d, sizeof(d) );
+	DRM_COPY_TO_USER_IOCTL(argp, d, sizeof(d));
 
 	return ret;
 }
 
-int radeon_driver_preinit(struct drm_device *dev, unsigned long flags)
+/* Always create a map record for MMIO and FB memory, done from DRIVER_POSTINIT */
+int radeon_preinit(struct drm_device *dev, unsigned long flags)
 {
 	drm_radeon_private_t *dev_priv;
 	int ret = 0;
@@ -2045,15 +2033,42 @@ int radeon_driver_preinit(struct drm_dev
 	/* all other chips have no hierarchical z buffer */
 		break;
 	}
+
+	if (drm_device_is_agp(dev))
+		dev_priv->flags |= CHIP_IS_AGP;
+
+	DRM_DEBUG("%s card detected\n",
+		  ((dev_priv->flags & CHIP_IS_AGP) ? "AGP" : "PCI"));
+
 	return ret;
 }
 
-int radeon_driver_postcleanup(struct drm_device *dev)
+int radeon_presetup(struct drm_device *dev)
+{
+	int ret;
+	drm_local_map_t *map;
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+
+	ret = drm_addmap(dev, drm_get_resource_start(dev, 2),
+			 drm_get_resource_len(dev, 2), _DRM_REGISTERS,
+			 _DRM_READ_ONLY, &dev_priv->mmio);
+	if (ret != 0)
+		return ret;
+
+	ret = drm_addmap(dev, drm_get_resource_start(dev, 0),
+			 drm_get_resource_len(dev, 0), _DRM_FRAME_BUFFER,
+			 _DRM_WRITE_COMBINING, &map);
+	if (ret != 0)
+		return ret;
+
+	return 0;
+}
+
+int radeon_postcleanup(struct drm_device *dev)
 {
 	drm_radeon_private_t *dev_priv = dev->dev_private;
 
 	DRM_DEBUG("\n");
-
 	drm_free(dev_priv, sizeof(*dev_priv), DRM_MEM_DRIVER);
 
 	dev->dev_private = NULL;
diff -purN linux-2.6.12.orig/drivers/char/drm/radeon_drm.h linux-2.6.12/drivers/char/drm/radeon_drm.h
--- linux-2.6.12.orig/drivers/char/drm/radeon_drm.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/radeon_drm.h	2005-07-05 08:37:49.000000000 +0200
@@ -57,78 +57,77 @@
 #define RADEON_UPLOAD_TEX0IMAGES	0x00001000
 #define RADEON_UPLOAD_TEX1IMAGES	0x00002000
 #define RADEON_UPLOAD_TEX2IMAGES	0x00004000
-#define RADEON_UPLOAD_CLIPRECTS		0x00008000 /* handled client-side */
+#define RADEON_UPLOAD_CLIPRECTS		0x00008000	/* handled client-side */
 #define RADEON_REQUIRE_QUIESCENCE	0x00010000
-#define RADEON_UPLOAD_ZBIAS		0x00020000 /* version 1.2 and newer */
+#define RADEON_UPLOAD_ZBIAS		0x00020000	/* version 1.2 and newer */
 #define RADEON_UPLOAD_ALL		0x003effff
 #define RADEON_UPLOAD_CONTEXT_ALL       0x003e01ff
 
-
 /* New style per-packet identifiers for use in cmd_buffer ioctl with
  * the RADEON_EMIT_PACKET command.  Comments relate new packets to old
  * state bits and the packet size:
  */
-#define RADEON_EMIT_PP_MISC                         0 /* context/7 */
-#define RADEON_EMIT_PP_CNTL                         1 /* context/3 */
-#define RADEON_EMIT_RB3D_COLORPITCH                 2 /* context/1 */
-#define RADEON_EMIT_RE_LINE_PATTERN                 3 /* line/2 */
-#define RADEON_EMIT_SE_LINE_WIDTH                   4 /* line/1 */
-#define RADEON_EMIT_PP_LUM_MATRIX                   5 /* bumpmap/1 */
-#define RADEON_EMIT_PP_ROT_MATRIX_0                 6 /* bumpmap/2 */
-#define RADEON_EMIT_RB3D_STENCILREFMASK             7 /* masks/3 */
-#define RADEON_EMIT_SE_VPORT_XSCALE                 8 /* viewport/6 */
-#define RADEON_EMIT_SE_CNTL                         9 /* setup/2 */
-#define RADEON_EMIT_SE_CNTL_STATUS                  10 /* setup/1 */
-#define RADEON_EMIT_RE_MISC                         11 /* misc/1 */
-#define RADEON_EMIT_PP_TXFILTER_0                   12 /* tex0/6 */
-#define RADEON_EMIT_PP_BORDER_COLOR_0               13 /* tex0/1 */
-#define RADEON_EMIT_PP_TXFILTER_1                   14 /* tex1/6 */
-#define RADEON_EMIT_PP_BORDER_COLOR_1               15 /* tex1/1 */
-#define RADEON_EMIT_PP_TXFILTER_2                   16 /* tex2/6 */
-#define RADEON_EMIT_PP_BORDER_COLOR_2               17 /* tex2/1 */
-#define RADEON_EMIT_SE_ZBIAS_FACTOR                 18 /* zbias/2 */
-#define RADEON_EMIT_SE_TCL_OUTPUT_VTX_FMT           19 /* tcl/11 */
-#define RADEON_EMIT_SE_TCL_MATERIAL_EMMISSIVE_RED   20 /* material/17 */
-#define R200_EMIT_PP_TXCBLEND_0                     21 /* tex0/4 */
-#define R200_EMIT_PP_TXCBLEND_1                     22 /* tex1/4 */
-#define R200_EMIT_PP_TXCBLEND_2                     23 /* tex2/4 */
-#define R200_EMIT_PP_TXCBLEND_3                     24 /* tex3/4 */
-#define R200_EMIT_PP_TXCBLEND_4                     25 /* tex4/4 */
-#define R200_EMIT_PP_TXCBLEND_5                     26 /* tex5/4 */
-#define R200_EMIT_PP_TXCBLEND_6                     27 /* /4 */
-#define R200_EMIT_PP_TXCBLEND_7                     28 /* /4 */
-#define R200_EMIT_TCL_LIGHT_MODEL_CTL_0             29 /* tcl/7 */
-#define R200_EMIT_TFACTOR_0                         30 /* tf/7 */
-#define R200_EMIT_VTX_FMT_0                         31 /* vtx/5 */
-#define R200_EMIT_VAP_CTL                           32 /* vap/1 */
-#define R200_EMIT_MATRIX_SELECT_0                   33 /* msl/5 */
-#define R200_EMIT_TEX_PROC_CTL_2                    34 /* tcg/5 */
-#define R200_EMIT_TCL_UCP_VERT_BLEND_CTL            35 /* tcl/1 */
-#define R200_EMIT_PP_TXFILTER_0                     36 /* tex0/6 */
-#define R200_EMIT_PP_TXFILTER_1                     37 /* tex1/6 */
-#define R200_EMIT_PP_TXFILTER_2                     38 /* tex2/6 */
-#define R200_EMIT_PP_TXFILTER_3                     39 /* tex3/6 */
-#define R200_EMIT_PP_TXFILTER_4                     40 /* tex4/6 */
-#define R200_EMIT_PP_TXFILTER_5                     41 /* tex5/6 */
-#define R200_EMIT_PP_TXOFFSET_0                     42 /* tex0/1 */
-#define R200_EMIT_PP_TXOFFSET_1                     43 /* tex1/1 */
-#define R200_EMIT_PP_TXOFFSET_2                     44 /* tex2/1 */
-#define R200_EMIT_PP_TXOFFSET_3                     45 /* tex3/1 */
-#define R200_EMIT_PP_TXOFFSET_4                     46 /* tex4/1 */
-#define R200_EMIT_PP_TXOFFSET_5                     47 /* tex5/1 */
-#define R200_EMIT_VTE_CNTL                          48 /* vte/1 */
-#define R200_EMIT_OUTPUT_VTX_COMP_SEL               49 /* vtx/1 */
-#define R200_EMIT_PP_TAM_DEBUG3                     50 /* tam/1 */
-#define R200_EMIT_PP_CNTL_X                         51 /* cst/1 */
-#define R200_EMIT_RB3D_DEPTHXY_OFFSET               52 /* cst/1 */
-#define R200_EMIT_RE_AUX_SCISSOR_CNTL               53 /* cst/1 */
-#define R200_EMIT_RE_SCISSOR_TL_0                   54 /* cst/2 */
-#define R200_EMIT_RE_SCISSOR_TL_1                   55 /* cst/2 */
-#define R200_EMIT_RE_SCISSOR_TL_2                   56 /* cst/2 */
-#define R200_EMIT_SE_VAP_CNTL_STATUS                57 /* cst/1 */
-#define R200_EMIT_SE_VTX_STATE_CNTL                 58 /* cst/1 */
-#define R200_EMIT_RE_POINTSIZE                      59 /* cst/1 */
-#define R200_EMIT_TCL_INPUT_VTX_VECTOR_ADDR_0       60 /* cst/4 */
+#define RADEON_EMIT_PP_MISC                         0	/* context/7 */
+#define RADEON_EMIT_PP_CNTL                         1	/* context/3 */
+#define RADEON_EMIT_RB3D_COLORPITCH                 2	/* context/1 */
+#define RADEON_EMIT_RE_LINE_PATTERN                 3	/* line/2 */
+#define RADEON_EMIT_SE_LINE_WIDTH                   4	/* line/1 */
+#define RADEON_EMIT_PP_LUM_MATRIX                   5	/* bumpmap/1 */
+#define RADEON_EMIT_PP_ROT_MATRIX_0                 6	/* bumpmap/2 */
+#define RADEON_EMIT_RB3D_STENCILREFMASK             7	/* masks/3 */
+#define RADEON_EMIT_SE_VPORT_XSCALE                 8	/* viewport/6 */
+#define RADEON_EMIT_SE_CNTL                         9	/* setup/2 */
+#define RADEON_EMIT_SE_CNTL_STATUS                  10	/* setup/1 */
+#define RADEON_EMIT_RE_MISC                         11	/* misc/1 */
+#define RADEON_EMIT_PP_TXFILTER_0                   12	/* tex0/6 */
+#define RADEON_EMIT_PP_BORDER_COLOR_0               13	/* tex0/1 */
+#define RADEON_EMIT_PP_TXFILTER_1                   14	/* tex1/6 */
+#define RADEON_EMIT_PP_BORDER_COLOR_1               15	/* tex1/1 */
+#define RADEON_EMIT_PP_TXFILTER_2                   16	/* tex2/6 */
+#define RADEON_EMIT_PP_BORDER_COLOR_2               17	/* tex2/1 */
+#define RADEON_EMIT_SE_ZBIAS_FACTOR                 18	/* zbias/2 */
+#define RADEON_EMIT_SE_TCL_OUTPUT_VTX_FMT           19	/* tcl/11 */
+#define RADEON_EMIT_SE_TCL_MATERIAL_EMMISSIVE_RED   20	/* material/17 */
+#define R200_EMIT_PP_TXCBLEND_0                     21	/* tex0/4 */
+#define R200_EMIT_PP_TXCBLEND_1                     22	/* tex1/4 */
+#define R200_EMIT_PP_TXCBLEND_2                     23	/* tex2/4 */
+#define R200_EMIT_PP_TXCBLEND_3                     24	/* tex3/4 */
+#define R200_EMIT_PP_TXCBLEND_4                     25	/* tex4/4 */
+#define R200_EMIT_PP_TXCBLEND_5                     26	/* tex5/4 */
+#define R200_EMIT_PP_TXCBLEND_6                     27	/* /4 */
+#define R200_EMIT_PP_TXCBLEND_7                     28	/* /4 */
+#define R200_EMIT_TCL_LIGHT_MODEL_CTL_0             29	/* tcl/7 */
+#define R200_EMIT_TFACTOR_0                         30	/* tf/7 */
+#define R200_EMIT_VTX_FMT_0                         31	/* vtx/5 */
+#define R200_EMIT_VAP_CTL                           32	/* vap/1 */
+#define R200_EMIT_MATRIX_SELECT_0                   33	/* msl/5 */
+#define R200_EMIT_TEX_PROC_CTL_2                    34	/* tcg/5 */
+#define R200_EMIT_TCL_UCP_VERT_BLEND_CTL            35	/* tcl/1 */
+#define R200_EMIT_PP_TXFILTER_0                     36	/* tex0/6 */
+#define R200_EMIT_PP_TXFILTER_1                     37	/* tex1/6 */
+#define R200_EMIT_PP_TXFILTER_2                     38	/* tex2/6 */
+#define R200_EMIT_PP_TXFILTER_3                     39	/* tex3/6 */
+#define R200_EMIT_PP_TXFILTER_4                     40	/* tex4/6 */
+#define R200_EMIT_PP_TXFILTER_5                     41	/* tex5/6 */
+#define R200_EMIT_PP_TXOFFSET_0                     42	/* tex0/1 */
+#define R200_EMIT_PP_TXOFFSET_1                     43	/* tex1/1 */
+#define R200_EMIT_PP_TXOFFSET_2                     44	/* tex2/1 */
+#define R200_EMIT_PP_TXOFFSET_3                     45	/* tex3/1 */
+#define R200_EMIT_PP_TXOFFSET_4                     46	/* tex4/1 */
+#define R200_EMIT_PP_TXOFFSET_5                     47	/* tex5/1 */
+#define R200_EMIT_VTE_CNTL                          48	/* vte/1 */
+#define R200_EMIT_OUTPUT_VTX_COMP_SEL               49	/* vtx/1 */
+#define R200_EMIT_PP_TAM_DEBUG3                     50	/* tam/1 */
+#define R200_EMIT_PP_CNTL_X                         51	/* cst/1 */
+#define R200_EMIT_RB3D_DEPTHXY_OFFSET               52	/* cst/1 */
+#define R200_EMIT_RE_AUX_SCISSOR_CNTL               53	/* cst/1 */
+#define R200_EMIT_RE_SCISSOR_TL_0                   54	/* cst/2 */
+#define R200_EMIT_RE_SCISSOR_TL_1                   55	/* cst/2 */
+#define R200_EMIT_RE_SCISSOR_TL_2                   56	/* cst/2 */
+#define R200_EMIT_SE_VAP_CNTL_STATUS                57	/* cst/1 */
+#define R200_EMIT_SE_VTX_STATE_CNTL                 58	/* cst/1 */
+#define R200_EMIT_RE_POINTSIZE                      59	/* cst/1 */
+#define R200_EMIT_TCL_INPUT_VTX_VECTOR_ADDR_0       60	/* cst/4 */
 #define R200_EMIT_PP_CUBIC_FACES_0                  61
 #define R200_EMIT_PP_CUBIC_OFFSETS_0                62
 #define R200_EMIT_PP_CUBIC_FACES_1                  63
@@ -158,48 +157,46 @@
 /* Commands understood by cmd_buffer ioctl.  More can be added but
  * obviously these can't be removed or changed:
  */
-#define RADEON_CMD_PACKET      1 /* emit one of the register packets above */
-#define RADEON_CMD_SCALARS     2 /* emit scalar data */
-#define RADEON_CMD_VECTORS     3 /* emit vector data */
-#define RADEON_CMD_DMA_DISCARD 4 /* discard current dma buf */
-#define RADEON_CMD_PACKET3     5 /* emit hw packet */
-#define RADEON_CMD_PACKET3_CLIP 6 /* emit hw packet wrapped in cliprects */
-#define RADEON_CMD_SCALARS2     7 /* r200 stopgap */
-#define RADEON_CMD_WAIT         8 /* emit hw wait commands -- note:
-				   *  doesn't make the cpu wait, just
-				   *  the graphics hardware */
-
+#define RADEON_CMD_PACKET      1	/* emit one of the register packets above */
+#define RADEON_CMD_SCALARS     2	/* emit scalar data */
+#define RADEON_CMD_VECTORS     3	/* emit vector data */
+#define RADEON_CMD_DMA_DISCARD 4	/* discard current dma buf */
+#define RADEON_CMD_PACKET3     5	/* emit hw packet */
+#define RADEON_CMD_PACKET3_CLIP 6	/* emit hw packet wrapped in cliprects */
+#define RADEON_CMD_SCALARS2     7	/* r200 stopgap */
+#define RADEON_CMD_WAIT         8	/* emit hw wait commands -- note:
+					 *  doesn't make the cpu wait, just
+					 *  the graphics hardware */
 
 typedef union {
 	int i;
-	struct { 
+	struct {
 		unsigned char cmd_type, pad0, pad1, pad2;
 	} header;
-	struct { 
+	struct {
 		unsigned char cmd_type, packet_id, pad0, pad1;
 	} packet;
-	struct { 
-		unsigned char cmd_type, offset, stride, count; 
+	struct {
+		unsigned char cmd_type, offset, stride, count;
 	} scalars;
-	struct { 
-		unsigned char cmd_type, offset, stride, count; 
+	struct {
+		unsigned char cmd_type, offset, stride, count;
 	} vectors;
-	struct { 
-		unsigned char cmd_type, buf_idx, pad0, pad1; 
+	struct {
+		unsigned char cmd_type, buf_idx, pad0, pad1;
 	} dma;
-	struct { 
-		unsigned char cmd_type, flags, pad0, pad1; 
+	struct {
+		unsigned char cmd_type, flags, pad0, pad1;
 	} wait;
 } drm_radeon_cmd_header_t;
 
 #define RADEON_WAIT_2D  0x1
 #define RADEON_WAIT_3D  0x2
 
-
 #define RADEON_FRONT			0x1
 #define RADEON_BACK			0x2
 #define RADEON_DEPTH			0x4
-#define RADEON_STENCIL			0x8
+#define RADEON_STENCIL                  0x8
 #define RADEON_CLEAR_FASTZ		0x80000000
 #define RADEON_USE_HIERZ		0x40000000
 #define RADEON_USE_COMP_ZBUF		0x20000000
@@ -246,7 +243,7 @@ typedef union {
 #define RADEON_OFFSET_ALIGN             (1 << RADEON_OFFSET_SHIFT)
 #define RADEON_OFFSET_MASK              (RADEON_OFFSET_ALIGN - 1)
 
-#endif /* __RADEON_SAREA_DEFINES__ */
+#endif				/* __RADEON_SAREA_DEFINES__ */
 
 typedef struct {
 	unsigned int red;
@@ -257,7 +254,7 @@ typedef struct {
 
 typedef struct {
 	/* Context state */
-	unsigned int pp_misc;				/* 0x1c14 */
+	unsigned int pp_misc;	/* 0x1c14 */
 	unsigned int pp_fog_color;
 	unsigned int re_solid_color;
 	unsigned int rb3d_blendcntl;
@@ -265,7 +262,7 @@ typedef struct {
 	unsigned int rb3d_depthpitch;
 	unsigned int rb3d_zstencilcntl;
 
-	unsigned int pp_cntl;				/* 0x1c38 */
+	unsigned int pp_cntl;	/* 0x1c38 */
 	unsigned int rb3d_cntl;
 	unsigned int rb3d_coloroffset;
 	unsigned int re_width_height;
@@ -273,27 +270,27 @@ typedef struct {
 	unsigned int se_cntl;
 
 	/* Vertex format state */
-	unsigned int se_coord_fmt;			/* 0x1c50 */
+	unsigned int se_coord_fmt;	/* 0x1c50 */
 
 	/* Line state */
-	unsigned int re_line_pattern;			/* 0x1cd0 */
+	unsigned int re_line_pattern;	/* 0x1cd0 */
 	unsigned int re_line_state;
 
-	unsigned int se_line_width;			/* 0x1db8 */
+	unsigned int se_line_width;	/* 0x1db8 */
 
 	/* Bumpmap state */
-	unsigned int pp_lum_matrix;			/* 0x1d00 */
+	unsigned int pp_lum_matrix;	/* 0x1d00 */
 
-	unsigned int pp_rot_matrix_0;			/* 0x1d58 */
+	unsigned int pp_rot_matrix_0;	/* 0x1d58 */
 	unsigned int pp_rot_matrix_1;
 
 	/* Mask state */
-	unsigned int rb3d_stencilrefmask;		/* 0x1d7c */
+	unsigned int rb3d_stencilrefmask;	/* 0x1d7c */
 	unsigned int rb3d_ropcntl;
 	unsigned int rb3d_planemask;
 
 	/* Viewport state */
-	unsigned int se_vport_xscale;			/* 0x1d98 */
+	unsigned int se_vport_xscale;	/* 0x1d98 */
 	unsigned int se_vport_xoffset;
 	unsigned int se_vport_yscale;
 	unsigned int se_vport_yoffset;
@@ -301,20 +298,19 @@ typedef struct {
 	unsigned int se_vport_zoffset;
 
 	/* Setup state */
-	unsigned int se_cntl_status;			/* 0x2140 */
+	unsigned int se_cntl_status;	/* 0x2140 */
 
 	/* Misc state */
-	unsigned int re_top_left;			/* 0x26c0 */
+	unsigned int re_top_left;	/* 0x26c0 */
 	unsigned int re_misc;
 } drm_radeon_context_regs_t;
 
 typedef struct {
 	/* Zbias state */
-	unsigned int se_zbias_factor;			/* 0x1dac */
+	unsigned int se_zbias_factor;	/* 0x1dac */
 	unsigned int se_zbias_constant;
 } drm_radeon_context2_regs_t;
 
-
 /* Setup registers for each texture unit
  */
 typedef struct {
@@ -332,11 +328,10 @@ typedef struct {
 	unsigned int finish;
 	unsigned int prim:8;
 	unsigned int stateidx:8;
-	unsigned int numverts:16; /* overloaded as offset/64 for elt prims */
-        unsigned int vc_format;   /* vertex format */
+	unsigned int numverts:16;	/* overloaded as offset/64 for elt prims */
+	unsigned int vc_format;	/* vertex format */
 } drm_radeon_prim_t;
 
-
 typedef struct {
 	drm_radeon_context_regs_t context;
 	drm_radeon_texture_regs_t tex[RADEON_MAX_TEXTURE_UNITS];
@@ -344,7 +339,6 @@ typedef struct {
 	unsigned int dirty;
 } drm_radeon_state_t;
 
-
 typedef struct {
 	/* The channel for communication of state information to the
 	 * kernel on firing a vertex buffer with either of the
@@ -367,16 +361,16 @@ typedef struct {
 	unsigned int last_dispatch;
 	unsigned int last_clear;
 
-	drm_tex_region_t tex_list[RADEON_NR_TEX_HEAPS][RADEON_NR_TEX_REGIONS+1];
+	drm_tex_region_t tex_list[RADEON_NR_TEX_HEAPS][RADEON_NR_TEX_REGIONS +
+						       1];
 	unsigned int tex_age[RADEON_NR_TEX_HEAPS];
 	int ctx_owner;
-        int pfState;                /* number of 3d windows (0,1,2ormore) */
-        int pfCurrentPage;	    /* which buffer is being displayed? */
-	int crtc2_base;		    /* CRTC2 frame offset */
+	int pfState;		/* number of 3d windows (0,1,2ormore) */
+	int pfCurrentPage;	/* which buffer is being displayed? */
+	int crtc2_base;		/* CRTC2 frame offset */
 	int tiling_enabled;	/* set by drm, read by 2d + 3d clients */
 } drm_radeon_sarea_t;
 
-
 /* WARNING: If you change any of these defines, make sure to change the
  * defines in the Xserver file (xf86drmRadeon.h)
  *
@@ -386,15 +380,15 @@ typedef struct {
 /* Radeon specific ioctls
  * The device specific ioctl range is 0x40 to 0x79.
  */
-#define DRM_RADEON_CP_INIT    0x00 
-#define DRM_RADEON_CP_START   0x01 
+#define DRM_RADEON_CP_INIT    0x00
+#define DRM_RADEON_CP_START   0x01
 #define DRM_RADEON_CP_STOP    0x02
 #define DRM_RADEON_CP_RESET   0x03
 #define DRM_RADEON_CP_IDLE    0x04
-#define DRM_RADEON_RESET      0x05 
+#define DRM_RADEON_RESET      0x05
 #define DRM_RADEON_FULLSCREEN 0x06
-#define DRM_RADEON_SWAP       0x07 
-#define DRM_RADEON_CLEAR      0x08 
+#define DRM_RADEON_SWAP       0x07
+#define DRM_RADEON_CLEAR      0x08
 #define DRM_RADEON_VERTEX     0x09
 #define DRM_RADEON_INDICES    0x0A
 #define DRM_RADEON_NOT_USED
@@ -445,13 +439,13 @@ typedef struct {
 
 typedef struct drm_radeon_init {
 	enum {
-		RADEON_INIT_CP    = 0x01,
+		RADEON_INIT_CP = 0x01,
 		RADEON_CLEANUP_CP = 0x02,
 		RADEON_INIT_R200_CP = 0x03,
 		RADEON_INIT_R300_CP = 0x04
 	} func;
 	unsigned long sarea_priv_offset;
-	int is_pci;
+	int is_pci;		/* not used, driver asks hardware */
 	int cp_mode;
 	int gart_size;
 	int ring_size;
@@ -478,7 +472,7 @@ typedef struct drm_radeon_cp_stop {
 
 typedef struct drm_radeon_fullscreen {
 	enum {
-		RADEON_INIT_FULLSCREEN    = 0x01,
+		RADEON_INIT_FULLSCREEN = 0x01,
 		RADEON_CLEANUP_FULLSCREEN = 0x02
 	} func;
 } drm_radeon_fullscreen_t;
@@ -499,15 +493,15 @@ typedef struct drm_radeon_clear {
 	unsigned int clear_color;
 	unsigned int clear_depth;
 	unsigned int color_mask;
-	unsigned int depth_mask;   /* misnamed field:  should be stencil */
+	unsigned int depth_mask;	/* misnamed field:  should be stencil */
 	drm_radeon_clear_rect_t __user *depth_boxes;
 } drm_radeon_clear_t;
 
 typedef struct drm_radeon_vertex {
 	int prim;
-	int idx;			/* Index of vertex buffer */
-	int count;			/* Number of vertices in buffer */
-	int discard;			/* Client finished with buffer? */
+	int idx;		/* Index of vertex buffer */
+	int count;		/* Number of vertices in buffer */
+	int discard;		/* Client finished with buffer? */
 } drm_radeon_vertex_t;
 
 typedef struct drm_radeon_indices {
@@ -515,7 +509,7 @@ typedef struct drm_radeon_indices {
 	int idx;
 	int start;
 	int end;
-	int discard;			/* Client finished with buffer? */
+	int discard;		/* Client finished with buffer? */
 } drm_radeon_indices_t;
 
 /* v1.2 - obsoletes drm_radeon_vertex and drm_radeon_indices
@@ -523,8 +517,8 @@ typedef struct drm_radeon_indices {
  *      - supports driver change to emit native primitives
  */
 typedef struct drm_radeon_vertex2 {
-	int idx;			/* Index of vertex buffer */
-	int discard;			/* Client finished with buffer? */
+	int idx;		/* Index of vertex buffer */
+	int discard;		/* Client finished with buffer? */
 	int nr_states;
 	drm_radeon_state_t __user *state;
 	int nr_prims;
@@ -532,10 +526,10 @@ typedef struct drm_radeon_vertex2 {
 } drm_radeon_vertex2_t;
 
 /* v1.3 - obsoletes drm_radeon_vertex2
- *      - allows arbitarily large cliprect list 
+ *      - allows arbitarily large cliprect list
  *      - allows updating of tcl packet, vector and scalar state
  *      - allows memory-efficient description of state updates
- *      - allows state to be emitted without a primitive 
+ *      - allows state to be emitted without a primitive
  *           (for clears, ctx switches)
  *      - allows more than one dma buffer to be referenced per ioctl
  *      - supports tcl driver
@@ -549,7 +543,7 @@ typedef struct drm_radeon_cmd_buffer {
 } drm_radeon_cmd_buffer_t;
 
 typedef struct drm_radeon_tex_image {
-	unsigned int x, y;		/* Blit coordinates */
+	unsigned int x, y;	/* Blit coordinates */
 	unsigned int width, height;
 	const void __user *data;
 } drm_radeon_tex_image_t;
@@ -558,7 +552,7 @@ typedef struct drm_radeon_texture {
 	unsigned int offset;
 	int pitch;
 	int format;
-	int width;			/* Texture image coordinates */
+	int width;		/* Texture image coordinates */
 	int height;
 	drm_radeon_tex_image_t __user *image;
 } drm_radeon_texture_t;
@@ -574,19 +568,18 @@ typedef struct drm_radeon_indirect {
 	int discard;
 } drm_radeon_indirect_t;
 
-
 /* 1.3: An ioctl to get parameters that aren't available to the 3d
- * client any other way.  
+ * client any other way.
  */
-#define RADEON_PARAM_GART_BUFFER_OFFSET    1 /* card offset of 1st GART buffer */
+#define RADEON_PARAM_GART_BUFFER_OFFSET    1	/* card offset of 1st GART buffer */
 #define RADEON_PARAM_LAST_FRAME            2
 #define RADEON_PARAM_LAST_DISPATCH         3
 #define RADEON_PARAM_LAST_CLEAR            4
 /* Added with DRM version 1.6. */
 #define RADEON_PARAM_IRQ_NR                5
-#define RADEON_PARAM_GART_BASE             6 /* card offset of GART base */
+#define RADEON_PARAM_GART_BASE             6	/* card offset of GART base */
 /* Added with DRM version 1.8. */
-#define RADEON_PARAM_REGISTER_HANDLE       7 /* for drmMap() */
+#define RADEON_PARAM_REGISTER_HANDLE       7	/* for drmMap() */
 #define RADEON_PARAM_STATUS_HANDLE         8
 #define RADEON_PARAM_SAREA_HANDLE          9
 #define RADEON_PARAM_GART_TEX_HANDLE       10
@@ -617,10 +610,9 @@ typedef struct drm_radeon_mem_free {
 typedef struct drm_radeon_mem_init_heap {
 	int region;
 	int size;
-	int start;	
+	int start;
 } drm_radeon_mem_init_heap_t;
 
-
 /* 1.6: Userspace can request & wait on irq's:
  */
 typedef struct drm_radeon_irq_emit {
@@ -631,14 +623,13 @@ typedef struct drm_radeon_irq_wait {
 	int irq_seq;
 } drm_radeon_irq_wait_t;
 
-
 /* 1.10: Clients tell the DRM where they think the framebuffer is located in
  * the card's address space, via a new generic ioctl to set parameters
  */
 
 typedef struct drm_radeon_setparam {
 	unsigned int param;
-	int64_t      value;
+	int64_t value;
 } drm_radeon_setparam_t;
 
 #define RADEON_SETPARAM_FB_LOCATION    1	/* determined framebuffer location */
@@ -656,4 +647,5 @@ typedef struct drm_radeon_surface_free {
 	unsigned int address;
 } drm_radeon_surface_free_t;
 
+
 #endif
diff -purN linux-2.6.12.orig/drivers/char/drm/radeon_drv.c linux-2.6.12/drivers/char/drm/radeon_drv.c
--- linux-2.6.12.orig/drivers/char/drm/radeon_drv.c	2005-07-05 08:36:22.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/radeon_drv.c	2005-07-05 08:37:27.000000000 +0200
@@ -29,7 +29,6 @@
  * OTHER DEALINGS IN THE SOFTWARE.
  */
 
-
 #include <linux/config.h>
 #include "drmP.h"
 #include "drm.h"
@@ -38,33 +37,42 @@
 
 #include "drm_pciids.h"
 
-static int postinit( struct drm_device *dev, unsigned long flags )
+static int postinit(struct drm_device *dev, unsigned long flags)
 {
-	DRM_INFO( "Initialized %s %d.%d.%d %s on minor %d: %s\n",
-		DRIVER_NAME,
-		DRIVER_MAJOR,
-		DRIVER_MINOR,
-		DRIVER_PATCHLEVEL,
-		DRIVER_DATE,
-		dev->primary.minor,
-		pci_pretty_name(dev->pdev)
-		);
+	DRM_INFO("Initialized %s %d.%d.%d %s on minor %d: %s\n",
+		 DRIVER_NAME,
+		 DRIVER_MAJOR,
+		 DRIVER_MINOR,
+		 DRIVER_PATCHLEVEL,
+		 DRIVER_DATE, dev->primary.minor, pci_pretty_name(dev->pdev)
+	    );
 	return 0;
 }
 
-static int version( drm_version_t *version )
+static int version(drm_version_t * version)
 {
 	int len;
 
 	version->version_major = DRIVER_MAJOR;
 	version->version_minor = DRIVER_MINOR;
 	version->version_patchlevel = DRIVER_PATCHLEVEL;
-	DRM_COPY( version->name, DRIVER_NAME );
-	DRM_COPY( version->date, DRIVER_DATE );
-	DRM_COPY( version->desc, DRIVER_DESC );
+	DRM_COPY(version->name, DRIVER_NAME);
+	DRM_COPY(version->date, DRIVER_DATE);
+	DRM_COPY(version->desc, DRIVER_DESC);
 	return 0;
 }
 
+static int dri_library_name(struct drm_device * dev, char * buf)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	int family = dev_priv->flags & CHIP_FAMILY_MASK;
+
+	return snprintf(buf, PAGE_SIZE, "%s\n",
+		(family < CHIP_R200) ? "radeon" :
+		((family < CHIP_R300) ? "r200" :
+ 		"r300"));
+}
+
 static struct pci_device_id pciidlist[] = {
 	radeon_PCI_IDS
 };
@@ -72,15 +80,21 @@ static struct pci_device_id pciidlist[] 
 extern drm_ioctl_desc_t radeon_ioctls[];
 extern int radeon_max_ioctl;
 
+static int probe(struct pci_dev *pdev, const struct pci_device_id *ent);
 static struct drm_driver driver = {
-	.driver_features = DRIVER_USE_AGP | DRIVER_USE_MTRR | DRIVER_PCI_DMA | DRIVER_SG | DRIVER_HAVE_IRQ | DRIVER_HAVE_DMA | DRIVER_IRQ_SHARED | DRIVER_IRQ_VBL,
+	.driver_features =
+	    DRIVER_USE_AGP | DRIVER_USE_MTRR | DRIVER_PCI_DMA | DRIVER_SG |
+	    DRIVER_HAVE_IRQ | DRIVER_HAVE_DMA | DRIVER_IRQ_SHARED |
+	    DRIVER_IRQ_VBL,
 	.dev_priv_size = sizeof(drm_radeon_buf_priv_t),
-	.preinit = radeon_driver_preinit,
-	.postcleanup = radeon_driver_postcleanup,
+	.preinit = radeon_preinit,
+	.presetup = radeon_presetup,
+	.postcleanup = radeon_postcleanup,
 	.prerelease = radeon_driver_prerelease,
 	.pretakedown = radeon_driver_pretakedown,
 	.open_helper = radeon_driver_open_helper,
 	.vblank_wait = radeon_driver_vblank_wait,
+	.dri_library_name = dri_library_name,
 	.irq_preinstall = radeon_driver_irq_preinstall,
 	.irq_postinstall = radeon_driver_irq_postinstall,
 	.irq_uninstall = radeon_driver_irq_uninstall,
@@ -104,17 +118,24 @@ static struct drm_driver driver = {
 #ifdef CONFIG_COMPAT
 		.compat_ioctl = radeon_compat_ioctl,
 #endif
-	},
+		},
 	.pci_driver = {
-		.name          = DRIVER_NAME,
-		.id_table      = pciidlist,
+		.name = DRIVER_NAME,
+		.id_table = pciidlist,
+		.probe = probe,
+		.remove = __devexit_p(drm_cleanup_pci),
 	}
 };
 
+static int probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	return drm_get_dev(pdev, ent, &driver);
+}
+
 static int __init radeon_init(void)
 {
 	driver.num_ioctls = radeon_max_ioctl;
-	return drm_init(&driver);
+	return drm_init(&driver, pciidlist);
 }
 
 static void __exit radeon_exit(void)
@@ -125,6 +146,6 @@ static void __exit radeon_exit(void)
 module_init(radeon_init);
 module_exit(radeon_exit);
 
-MODULE_AUTHOR( DRIVER_AUTHOR );
-MODULE_DESCRIPTION( DRIVER_DESC );
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL and additional rights");
diff -purN linux-2.6.12.orig/drivers/char/drm/radeon_drv.h linux-2.6.12/drivers/char/drm/radeon_drv.h
--- linux-2.6.12.orig/drivers/char/drm/radeon_drv.h	2005-07-05 08:36:22.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/radeon_drv.h	2005-07-05 08:37:49.000000000 +0200
@@ -68,12 +68,12 @@
  * 1.9 - Add DRM_IOCTL_RADEON_CP_RESUME ioctl.
  *       Add texture rectangle support for r100.
  * 1.10- Add SETPARAM ioctl; first parameter to set is FB_LOCATION, which
- *       clients use to tell the DRM where they think the framebuffer is 
+ *       clients use to tell the DRM where they think the framebuffer is
  *       located in the card's address space
  * 1.11- Add packet R200_EMIT_RB3D_BLENDCOLOR to support GL_EXT_blend_color
  *       and GL_EXT_blend_[func|equation]_separate on r200
  * 1.12- Add R300 CP microcode support - this just loads the CP on r300
- *       (No 3D support yet - just microcode loading)
+ *       (No 3D support yet - just microcode loading).
  * 1.13- Add packet R200_EMIT_TCL_POINT_SPRITE_CNTL for ARB_point_parameters
  *     - Add hyperz support, add hyperz flags to clear ioctl.
  * 1.14- Add support for color tiling
@@ -83,16 +83,11 @@
  * 1.16- Add R200_EMIT_PP_TRI_PERF_CNTL packet to support brilinear
  *       texture filtering on r200
  */
+
 #define DRIVER_MAJOR		1
 #define DRIVER_MINOR		16
 #define DRIVER_PATCHLEVEL	0
 
-#define GET_RING_HEAD(dev_priv)		DRM_READ32(  (dev_priv)->ring_rptr, 0 )
-#define SET_RING_HEAD(dev_priv,val)	DRM_WRITE32( (dev_priv)->ring_rptr, 0, (val) )
-
-/*
- * Radeon chip families
- */
 enum radeon_family {
 	CHIP_R100,
 	CHIP_RS100,
@@ -129,11 +124,14 @@ enum radeon_chip_flags {
 	CHIP_HAS_HIERZ = 0x00100000UL, 
 };
 
+#define GET_RING_HEAD(dev_priv)		DRM_READ32(  (dev_priv)->ring_rptr, 0 )
+#define SET_RING_HEAD(dev_priv,val)	DRM_WRITE32( (dev_priv)->ring_rptr, 0, (val) )
+
 typedef struct drm_radeon_freelist {
-   	unsigned int age;
-   	drm_buf_t *buf;
-   	struct drm_radeon_freelist *next;
-   	struct drm_radeon_freelist *prev;
+	unsigned int age;
+	drm_buf_t *buf;
+	struct drm_radeon_freelist *next;
+	struct drm_radeon_freelist *prev;
 } drm_radeon_freelist_t;
 
 typedef struct drm_radeon_ring_buffer {
@@ -183,6 +181,7 @@ struct radeon_virt_surface {
 };
 
 typedef struct drm_radeon_private {
+
 	drm_radeon_ring_buffer_t ring;
 	drm_radeon_sarea_t *sarea_priv;
 
@@ -195,8 +194,8 @@ typedef struct drm_radeon_private {
 	int cp_mode;
 	int cp_running;
 
-   	drm_radeon_freelist_t *head;
-   	drm_radeon_freelist_t *tail;
+	drm_radeon_freelist_t *head;
+	drm_radeon_freelist_t *tail;
 	int last_buf;
 	volatile u32 *scratch;
 	int writeback_works;
@@ -205,7 +204,6 @@ typedef struct drm_radeon_private {
 
 	int microcode_version;
 
-	int is_pci;
 	unsigned long phys_pci_gart;
 	dma_addr_t bus_pci_gart;
 
@@ -239,7 +237,7 @@ typedef struct drm_radeon_private {
 	u32 depth_pitch_offset;
 
 	drm_radeon_depth_clear_t depth_clear;
-	
+
 	unsigned long fb_offset;
 	unsigned long mmio_offset;
 	unsigned long ring_offset;
@@ -257,14 +255,15 @@ typedef struct drm_radeon_private {
 	struct mem_block *fb_heap;
 
 	/* SW interrupt */
-   	wait_queue_head_t swi_queue;
-   	atomic_t swi_emitted;
+	wait_queue_head_t swi_queue;
+	atomic_t swi_emitted;
 
 	struct radeon_surface surfaces[RADEON_MAX_SURFACES];
 	struct radeon_virt_surface virt_surfaces[2*RADEON_MAX_SURFACES];
-
+	
 	/* starting from here on, data is preserved accross an open */
 	uint32_t flags;		/* see radeon_chip_flags */
+
 } drm_radeon_private_t;
 
 typedef struct drm_radeon_buf_priv {
@@ -272,53 +271,48 @@ typedef struct drm_radeon_buf_priv {
 } drm_radeon_buf_priv_t;
 
 				/* radeon_cp.c */
-extern int radeon_cp_init( DRM_IOCTL_ARGS );
-extern int radeon_cp_start( DRM_IOCTL_ARGS );
-extern int radeon_cp_stop( DRM_IOCTL_ARGS );
-extern int radeon_cp_reset( DRM_IOCTL_ARGS );
-extern int radeon_cp_idle( DRM_IOCTL_ARGS );
-extern int radeon_cp_resume( DRM_IOCTL_ARGS );
-extern int radeon_engine_reset( DRM_IOCTL_ARGS );
-extern int radeon_fullscreen( DRM_IOCTL_ARGS );
-extern int radeon_cp_buffers( DRM_IOCTL_ARGS );
-
-extern void radeon_freelist_reset( drm_device_t *dev );
-extern drm_buf_t *radeon_freelist_get( drm_device_t *dev );
-
-extern int radeon_wait_ring( drm_radeon_private_t *dev_priv, int n );
-
-extern int radeon_do_cp_idle( drm_radeon_private_t *dev_priv );
-
-extern int radeon_driver_preinit(struct drm_device *dev, unsigned long flags);
-extern int radeon_driver_postcleanup(struct drm_device *dev);
-
-extern int radeon_mem_alloc( DRM_IOCTL_ARGS );
-extern int radeon_mem_free( DRM_IOCTL_ARGS );
-extern int radeon_mem_init_heap( DRM_IOCTL_ARGS );
-extern void radeon_mem_takedown( struct mem_block **heap );
-extern void radeon_mem_release( DRMFILE filp, struct mem_block *heap );
+extern int radeon_cp_init(DRM_IOCTL_ARGS);
+extern int radeon_cp_start(DRM_IOCTL_ARGS);
+extern int radeon_cp_stop(DRM_IOCTL_ARGS);
+extern int radeon_cp_reset(DRM_IOCTL_ARGS);
+extern int radeon_cp_idle(DRM_IOCTL_ARGS);
+extern int radeon_cp_resume(DRM_IOCTL_ARGS);
+extern int radeon_engine_reset(DRM_IOCTL_ARGS);
+extern int radeon_fullscreen(DRM_IOCTL_ARGS);
+extern int radeon_cp_buffers(DRM_IOCTL_ARGS);
+
+extern void radeon_freelist_reset(drm_device_t * dev);
+extern drm_buf_t *radeon_freelist_get(drm_device_t * dev);
+
+extern int radeon_wait_ring(drm_radeon_private_t * dev_priv, int n);
+
+extern int radeon_do_cp_idle(drm_radeon_private_t * dev_priv);
+
+extern int radeon_mem_alloc(DRM_IOCTL_ARGS);
+extern int radeon_mem_free(DRM_IOCTL_ARGS);
+extern int radeon_mem_init_heap(DRM_IOCTL_ARGS);
+extern void radeon_mem_takedown(struct mem_block **heap);
+extern void radeon_mem_release(DRMFILE filp, struct mem_block *heap);
 
 				/* radeon_irq.c */
-extern int radeon_irq_emit( DRM_IOCTL_ARGS );
-extern int radeon_irq_wait( DRM_IOCTL_ARGS );
-
-extern void radeon_do_release(drm_device_t *dev);
-extern int radeon_driver_vblank_wait(drm_device_t *dev, unsigned int *sequence);
-extern irqreturn_t radeon_driver_irq_handler( DRM_IRQ_ARGS );
-extern void radeon_driver_irq_preinstall( drm_device_t *dev );
-extern void radeon_driver_irq_postinstall( drm_device_t *dev );
-extern void radeon_driver_irq_uninstall( drm_device_t *dev );
-extern void radeon_driver_prerelease(drm_device_t *dev, DRMFILE filp);
-extern void radeon_driver_pretakedown(drm_device_t *dev);
-extern int radeon_driver_open_helper(drm_device_t *dev, drm_file_t *filp_priv);
-extern void radeon_driver_free_filp_priv(drm_device_t *dev, drm_file_t *filp_priv);
-
-extern int radeon_preinit( struct drm_device *dev, unsigned long flags );
-extern int radeon_postinit( struct drm_device *dev, unsigned long flags );
-extern int radeon_postcleanup( struct drm_device *dev );
+extern int radeon_irq_emit(DRM_IOCTL_ARGS);
+extern int radeon_irq_wait(DRM_IOCTL_ARGS);
 
+extern void radeon_do_release(drm_device_t * dev);
+extern int radeon_driver_vblank_wait(drm_device_t * dev,
+				     unsigned int *sequence);
+extern irqreturn_t radeon_driver_irq_handler(DRM_IRQ_ARGS);
+extern void radeon_driver_irq_preinstall(drm_device_t * dev);
+extern void radeon_driver_irq_postinstall(drm_device_t * dev);
+extern void radeon_driver_irq_uninstall(drm_device_t * dev);
+extern void radeon_driver_prerelease(drm_device_t * dev, DRMFILE filp);
+extern void radeon_driver_pretakedown(drm_device_t * dev);
+extern int radeon_driver_open_helper(drm_device_t * dev,
+				     drm_file_t * filp_priv);
+extern void radeon_driver_free_filp_priv(drm_device_t * dev,
+					 drm_file_t * filp_priv);
 extern long radeon_compat_ioctl(struct file *filp, unsigned int cmd,
-				unsigned long arg);
+					 unsigned long arg);
 
 /* Flags for stats.boxes
  */
@@ -328,13 +322,13 @@ extern long radeon_compat_ioctl(struct f
 #define RADEON_BOX_WAIT_IDLE     0x8
 #define RADEON_BOX_TEXTURE_LOAD  0x10
 
-
-
 /* Register definitions, register access macros and drmAddMap constants
  * for Radeon kernel driver.
  */
-
 #define RADEON_AGP_COMMAND		0x0f60
+#define RADEON_AGP_COMMAND_PCI_CONFIG	0x0060	/* offset in PCI config */
+#       define RADEON_AGP_ENABLE            (1<<8)
+
 #define RADEON_AUX_SCISSOR_CNTL		0x26f0
 #	define RADEON_EXCLUSIVE_SCISSOR_0	(1 << 24)
 #	define RADEON_EXCLUSIVE_SCISSOR_1	(1 << 25)
@@ -357,6 +351,11 @@ extern long radeon_compat_ioctl(struct f
 #define RADEON_CRTC2_OFFSET		0x0324
 #define RADEON_CRTC2_OFFSET_CNTL	0x0328
 
+#define RADEON_MPP_TB_CONFIG		0x01c0
+#define RADEON_MEM_CNTL			0x0140
+#define RADEON_MEM_SDRAM_MODE_REG	0x0158
+#define RADEON_AGP_BASE			0x0170
+
 #define RADEON_RB3D_COLOROFFSET		0x1c40
 #define RADEON_RB3D_COLORPITCH		0x1c48
 
@@ -399,7 +398,6 @@ extern long radeon_compat_ioctl(struct f
 				? DRM_READ32( dev_priv->ring_rptr, RADEON_SCRATCHOFF(x) ) \
 				: RADEON_READ( RADEON_SCRATCH_REG0 + 4*(x) ) )
 
-
 #define RADEON_GEN_INT_CNTL		0x0040
 #	define RADEON_CRTC_VBLANK_MASK		(1 << 0)
 #	define RADEON_GUI_IDLE_INT_ENABLE	(1 << 19)
@@ -485,15 +483,15 @@ extern long radeon_compat_ioctl(struct f
 #define RADEON_RB3D_ZSTENCILCNTL	0x1c2c
 #	define RADEON_Z_TEST_MASK		(7 << 4)
 #	define RADEON_Z_TEST_ALWAYS		(7 << 4)
-#	define RADEON_Z_HIERARCHY_ENABLE	(1 << 8)
+#	define RADEON_Z_HIERARCHY_ENABLE        (1 << 8)
 #	define RADEON_STENCIL_TEST_ALWAYS	(7 << 12)
 #	define RADEON_STENCIL_S_FAIL_REPLACE	(2 << 16)
 #	define RADEON_STENCIL_ZPASS_REPLACE	(2 << 20)
 #	define RADEON_STENCIL_ZFAIL_REPLACE	(2 << 24)
-#	define RADEON_Z_COMPRESSION_ENABLE	(1 << 28)
-#	define RADEON_FORCE_Z_DIRTY		(1 << 29)
+#	define RADEON_Z_COMPRESSION_ENABLE      (1 << 28)
+#	define RADEON_FORCE_Z_DIRTY             (1 << 29)
 #	define RADEON_Z_WRITE_ENABLE		(1 << 30)
-#	define RADEON_Z_DECOMPRESSION_ENABLE	(1 << 31)
+#	define RADEON_Z_DECOMPRESSION_ENABLE    (1 << 31)
 #define RADEON_RBBM_SOFT_RESET		0x00f0
 #	define RADEON_SOFT_RESET_CP		(1 <<  0)
 #	define RADEON_SOFT_RESET_HI		(1 <<  1)
@@ -607,7 +605,6 @@ extern long radeon_compat_ioctl(struct f
 #	define RADEON_DEPTH_FORMAT_16BIT_INT_Z	(0 << 0)
 #	define RADEON_DEPTH_FORMAT_24BIT_INT_Z	(2 << 0)
 
-
 /* CP registers */
 #define RADEON_CP_ME_RAM_ADDR		0x07d4
 #define RADEON_CP_ME_RAM_RADDR		0x07d8
@@ -728,19 +725,19 @@ extern long radeon_compat_ioctl(struct f
 #define R200_PP_TXCBLEND_5                0x2f50
 #define R200_PP_TXCBLEND_6                0x2f60
 #define R200_PP_TXCBLEND_7                0x2f70
-#define R200_SE_TCL_LIGHT_MODEL_CTL_0     0x2268 
+#define R200_SE_TCL_LIGHT_MODEL_CTL_0     0x2268
 #define R200_PP_TFACTOR_0                 0x2ee0
 #define R200_SE_VTX_FMT_0                 0x2088
 #define R200_SE_VAP_CNTL                  0x2080
 #define R200_SE_TCL_MATRIX_SEL_0          0x2230
-#define R200_SE_TCL_TEX_PROC_CTL_2        0x22a8 
-#define R200_SE_TCL_UCP_VERT_BLEND_CTL    0x22c0 
-#define R200_PP_TXFILTER_5                0x2ca0 
-#define R200_PP_TXFILTER_4                0x2c80 
-#define R200_PP_TXFILTER_3                0x2c60 
-#define R200_PP_TXFILTER_2                0x2c40 
-#define R200_PP_TXFILTER_1                0x2c20 
-#define R200_PP_TXFILTER_0                0x2c00 
+#define R200_SE_TCL_TEX_PROC_CTL_2        0x22a8
+#define R200_SE_TCL_UCP_VERT_BLEND_CTL    0x22c0
+#define R200_PP_TXFILTER_5                0x2ca0
+#define R200_PP_TXFILTER_4                0x2c80
+#define R200_PP_TXFILTER_3                0x2c60
+#define R200_PP_TXFILTER_2                0x2c40
+#define R200_PP_TXFILTER_1                0x2c20
+#define R200_PP_TXFILTER_0                0x2c00
 #define R200_PP_TXOFFSET_5                0x2d78
 #define R200_PP_TXOFFSET_4                0x2d60
 #define R200_PP_TXOFFSET_3                0x2d48
@@ -794,13 +791,13 @@ extern long radeon_compat_ioctl(struct f
 #define R200_RE_SCISSOR_TL_0              0x1cd8
 #define R200_RE_SCISSOR_TL_1              0x1ce0
 #define R200_RE_SCISSOR_TL_2              0x1ce8
-#define R200_RB3D_DEPTHXY_OFFSET          0x1d60 
+#define R200_RB3D_DEPTHXY_OFFSET          0x1d60
 #define R200_RE_AUX_SCISSOR_CNTL          0x26f0
 #define R200_SE_VTX_STATE_CNTL            0x2180
 #define R200_RE_POINTSIZE                 0x2648
 #define R200_SE_TCL_INPUT_VTX_VECTOR_ADDR_0 0x2254
 
-#define RADEON_PP_TEX_SIZE_0                0x1d04  /* NPOT */
+#define RADEON_PP_TEX_SIZE_0                0x1d04	/* NPOT */
 #define RADEON_PP_TEX_SIZE_1                0x1d0c
 #define RADEON_PP_TEX_SIZE_2                0x1d14
 
@@ -821,13 +818,43 @@ extern long radeon_compat_ioctl(struct f
 #define SE_VTX_FMT_0__VTX_COLOR_0_FMT__SHIFT               0x0000000b
 #define R200_3D_DRAW_IMMD_2      0xC0003500
 #define R200_SE_VTX_FMT_1                 0x208c
-#define R200_RE_CNTL                      0x1c50 
+#define R200_RE_CNTL                      0x1c50
 
 #define R200_RB3D_BLENDCOLOR              0x3218
 
 #define R200_SE_TCL_POINT_SPRITE_CNTL     0x22c4
 
-#define R200_PP_TRI_PERF 0x2cf8
+#define R200_PP_TRI_PERF                  0x2cf8
+
+/* MPEG settings from VHA code */
+#define RADEON_VHA_SETTO16_1                       0x2694
+#define RADEON_VHA_SETTO16_2                       0x2680
+#define RADEON_VHA_SETTO0_1                        0x1840
+#define RADEON_VHA_FB_OFFSET                       0x19e4
+#define RADEON_VHA_SETTO1AND70S                    0x19d8
+#define RADEON_VHA_DST_PITCH                       0x1408
+
+// set as reference header
+#define RADEON_VHA_BACKFRAME0_OFF_Y              0x1840
+#define RADEON_VHA_BACKFRAME1_OFF_PITCH_Y        0x1844
+#define RADEON_VHA_BACKFRAME0_OFF_U              0x1848
+#define RADEON_VHA_BACKFRAME1_OFF_PITCH_U        0x184c
+#define RADOEN_VHA_BACKFRAME0_OFF_V              0x1850
+#define RADEON_VHA_BACKFRAME1_OFF_PITCH_V        0x1854
+#define RADEON_VHA_FORWFRAME0_OFF_Y              0x1858
+#define RADEON_VHA_FORWFRAME1_OFF_PITCH_Y        0x185c
+#define RADEON_VHA_FORWFRAME0_OFF_U              0x1860
+#define RADEON_VHA_FORWFRAME1_OFF_PITCH_U        0x1864
+#define RADEON_VHA_FORWFRAME0_OFF_V              0x1868
+#define RADEON_VHA_FORWFRAME0_OFF_PITCH_V        0x1880
+#define RADEON_VHA_BACKFRAME0_OFF_Y_2            0x1884
+#define RADEON_VHA_BACKFRAME1_OFF_PITCH_Y_2      0x1888
+#define RADEON_VHA_BACKFRAME0_OFF_U_2            0x188c
+#define RADEON_VHA_BACKFRAME1_OFF_PITCH_U_2      0x1890
+#define RADEON_VHA_BACKFRAME0_OFF_V_2            0x1894
+#define RADEON_VHA_BACKFRAME1_OFF_PITCH_V_2      0x1898
+
+
 
 /* Constants */
 #define RADEON_MAX_USEC_TIMEOUT		100000	/* 100 ms */
@@ -855,6 +882,10 @@ do {									\
 	RADEON_WRITE( RADEON_CLOCK_CNTL_DATA, (val) );			\
 } while (0)
 
+extern int radeon_preinit(struct drm_device *dev, unsigned long flags);
+extern int radeon_presetup(struct drm_device *dev);
+extern int radeon_postcleanup(struct drm_device *dev);
+
 #define CP_PACKET0( reg, n )						\
 	(RADEON_CP_PACKET0 | ((n) << 16) | ((reg) >> 2))
 #define CP_PACKET0_TABLE( reg, n )					\
@@ -866,7 +897,6 @@ do {									\
 #define CP_PACKET3( pkt, n )						\
 	(RADEON_CP_PACKET3 | (pkt) | ((n) << 16))
 
-
 /* ================================================================
  * Engine control helper macros
  */
@@ -915,12 +945,11 @@ do {									\
 	OUT_RING( RADEON_RB3D_ZC_FLUSH_ALL );				\
 } while (0)
 
-
 /* ================================================================
  * Misc helper macros
  */
 
-/* Perfbox functionality only.  
+/* Perfbox functionality only.
  */
 #define RING_SPACE_TEST_WITH_RETURN( dev_priv )				\
 do {									\
@@ -957,7 +986,6 @@ do {									\
 	OUT_RING( age );						\
 } while (0)
 
-
 /* ================================================================
  * Ring control
  */
@@ -1018,15 +1046,14 @@ do {									\
 	OUT_RING( val );						\
 } while (0)
 
-
-#define OUT_RING_TABLE( tab, sz ) do {					\
+#define OUT_RING_TABLE( tab, sz ) do {				\
 	int _size = (sz);					\
 	int *_tab = (int *)(tab);				\
 								\
 	if (write + _size > mask) {				\
 		int _i = (mask+1) - write;			\
 		_size -= _i;					\
-		while (_i > 0 ) {				\
+		while (_i > 0) {				\
 			*(int *)(ring + write) = *_tab++;	\
 			write++;				\
 			_i--;					\
@@ -1034,7 +1061,6 @@ do {									\
 		write = 0;					\
 		_tab += _i;					\
 	}							\
-								\
 	while (_size > 0) {					\
 		*(ring + write) = *_tab++;			\
 		write++;					\
@@ -1043,5 +1069,4 @@ do {									\
 	write &= mask;						\
 } while (0)
 
-
-#endif /* __RADEON_DRV_H__ */
+#endif				/* __RADEON_DRV_H__ */
diff -purN linux-2.6.12.orig/drivers/char/drm/radeon_irq.c linux-2.6.12/drivers/char/drm/radeon_irq.c
--- linux-2.6.12.orig/drivers/char/drm/radeon_irq.c	2005-07-05 08:36:22.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/radeon_irq.c	2005-07-05 08:37:47.000000000 +0200
@@ -1,7 +1,7 @@
 /* radeon_irq.c -- IRQ handling for radeon -*- linux-c -*-
  *
  * Copyright (C) The Weather Channel, Inc.  2002.  All Rights Reserved.
- * 
+ *
  * The Weather Channel (TM) funded Tungsten Graphics to develop the
  * initial release of the Radeon 8500 driver under the XFree86 license.
  * This notice must be preserved.
@@ -35,7 +35,7 @@
 #include "radeon_drm.h"
 #include "radeon_drv.h"
 
-static __inline__ u32 radeon_acknowledge_irqs(drm_radeon_private_t *dev_priv, u32 mask)
+static __inline__ u32 radeon_acknowledge_irqs(drm_radeon_private_t * dev_priv, u32 mask)
 {
 	u32 irqs = RADEON_READ(RADEON_GEN_INT_STATUS) & mask;
 	if (irqs)
@@ -61,12 +61,12 @@ static __inline__ u32 radeon_acknowledge
  * tied to dma at all, this is just a hangover from dri prehistory.
  */
 
-irqreturn_t radeon_driver_irq_handler( DRM_IRQ_ARGS )
+irqreturn_t radeon_driver_irq_handler(DRM_IRQ_ARGS)
 {
 	drm_device_t *dev = (drm_device_t *) arg;
-	drm_radeon_private_t *dev_priv = 
-	   (drm_radeon_private_t *)dev->dev_private;
-   	u32 stat;
+	drm_radeon_private_t *dev_priv =
+	    (drm_radeon_private_t *) dev->dev_private;
+	u32 stat;
 
 	/* Only consider the bits we're interested in - others could be used
 	 * outside the DRM
@@ -78,20 +78,20 @@ irqreturn_t radeon_driver_irq_handler( D
 
 	/* SW interrupt */
 	if (stat & RADEON_SW_INT_TEST) {
-		DRM_WAKEUP( &dev_priv->swi_queue );
+		DRM_WAKEUP(&dev_priv->swi_queue);
 	}
 
 	/* VBLANK interrupt */
 	if (stat & RADEON_CRTC_VBLANK_STAT) {
 		atomic_inc(&dev->vbl_received);
 		DRM_WAKEUP(&dev->vbl_queue);
-		drm_vbl_send_signals( dev );
+		drm_vbl_send_signals(dev);
 	}
 
 	return IRQ_HANDLED;
 }
 
-static int radeon_emit_irq(drm_device_t *dev)
+static int radeon_emit_irq(drm_device_t * dev)
 {
 	drm_radeon_private_t *dev_priv = dev->dev_private;
 	unsigned int ret;
@@ -100,42 +100,41 @@ static int radeon_emit_irq(drm_device_t 
 	atomic_inc(&dev_priv->swi_emitted);
 	ret = atomic_read(&dev_priv->swi_emitted);
 
-	BEGIN_RING( 4 );
-	OUT_RING_REG( RADEON_LAST_SWI_REG, ret );
-	OUT_RING_REG( RADEON_GEN_INT_STATUS, RADEON_SW_INT_FIRE );
-	ADVANCE_RING(); 
- 	COMMIT_RING();
+	BEGIN_RING(4);
+	OUT_RING_REG(RADEON_LAST_SWI_REG, ret);
+	OUT_RING_REG(RADEON_GEN_INT_STATUS, RADEON_SW_INT_FIRE);
+	ADVANCE_RING();
+	COMMIT_RING();
 
 	return ret;
 }
 
-
-static int radeon_wait_irq(drm_device_t *dev, int swi_nr)
+static int radeon_wait_irq(drm_device_t * dev, int swi_nr)
 {
-  	drm_radeon_private_t *dev_priv = 
-	   (drm_radeon_private_t *)dev->dev_private;
+	drm_radeon_private_t *dev_priv =
+	    (drm_radeon_private_t *) dev->dev_private;
 	int ret = 0;
 
- 	if (RADEON_READ( RADEON_LAST_SWI_REG ) >= swi_nr)  
- 		return 0; 
+	if (RADEON_READ(RADEON_LAST_SWI_REG) >= swi_nr)
+		return 0;
 
 	dev_priv->stats.boxes |= RADEON_BOX_WAIT_IDLE;
 
-	DRM_WAIT_ON( ret, dev_priv->swi_queue, 3 * DRM_HZ, 
-		     RADEON_READ( RADEON_LAST_SWI_REG ) >= swi_nr );
+	DRM_WAIT_ON(ret, dev_priv->swi_queue, 3 * DRM_HZ,
+		    RADEON_READ(RADEON_LAST_SWI_REG) >= swi_nr);
 
 	return ret;
 }
 
-int radeon_driver_vblank_wait(drm_device_t *dev, unsigned int *sequence)
+int radeon_driver_vblank_wait(drm_device_t * dev, unsigned int *sequence)
 {
-  	drm_radeon_private_t *dev_priv = 
-	   (drm_radeon_private_t *)dev->dev_private;
+	drm_radeon_private_t *dev_priv =
+	    (drm_radeon_private_t *) dev->dev_private;
 	unsigned int cur_vblank;
 	int ret = 0;
 
-	if ( !dev_priv ) {
-		DRM_ERROR( "%s called with no initialization\n", __FUNCTION__ );
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
 		return DRM_ERR(EINVAL);
 	}
 
@@ -145,101 +144,100 @@ int radeon_driver_vblank_wait(drm_device
 
 	/* Assume that the user has missed the current sequence number
 	 * by about a day rather than she wants to wait for years
-	 * using vertical blanks... 
+	 * using vertical blanks...
 	 */
-	DRM_WAIT_ON( ret, dev->vbl_queue, 3*DRM_HZ, 
-		     ( ( ( cur_vblank = atomic_read(&dev->vbl_received ) )
-			 - *sequence ) <= (1<<23) ) );
+	DRM_WAIT_ON(ret, dev->vbl_queue, 3 * DRM_HZ,
+		    (((cur_vblank = atomic_read(&dev->vbl_received))
+		      - *sequence) <= (1 << 23)));
 
 	*sequence = cur_vblank;
 
 	return ret;
 }
 
-
 /* Needs the lock as it touches the ring.
  */
-int radeon_irq_emit( DRM_IOCTL_ARGS )
+int radeon_irq_emit(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_radeon_private_t *dev_priv = dev->dev_private;
 	drm_radeon_irq_emit_t emit;
 	int result;
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	if ( !dev_priv ) {
-		DRM_ERROR( "%s called with no initialization\n", __FUNCTION__ );
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
 		return DRM_ERR(EINVAL);
 	}
 
-	DRM_COPY_FROM_USER_IOCTL( emit, (drm_radeon_irq_emit_t __user *)data,
-				  sizeof(emit) );
+	DRM_COPY_FROM_USER_IOCTL(emit, (drm_radeon_irq_emit_t __user *) data,
+				 sizeof(emit));
 
-	result = radeon_emit_irq( dev );
+	result = radeon_emit_irq(dev);
 
-	if ( DRM_COPY_TO_USER( emit.irq_seq, &result, sizeof(int) ) ) {
-		DRM_ERROR( "copy_to_user\n" );
+	if (DRM_COPY_TO_USER(emit.irq_seq, &result, sizeof(int))) {
+		DRM_ERROR("copy_to_user\n");
 		return DRM_ERR(EFAULT);
 	}
 
 	return 0;
 }
 
-
 /* Doesn't need the hardware lock.
  */
-int radeon_irq_wait( DRM_IOCTL_ARGS )
+int radeon_irq_wait(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_radeon_private_t *dev_priv = dev->dev_private;
 	drm_radeon_irq_wait_t irqwait;
 
-	if ( !dev_priv ) {
-		DRM_ERROR( "%s called with no initialization\n", __FUNCTION__ );
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
 		return DRM_ERR(EINVAL);
 	}
 
-	DRM_COPY_FROM_USER_IOCTL( irqwait, (drm_radeon_irq_wait_t __user*)data,
-				  sizeof(irqwait) );
+	DRM_COPY_FROM_USER_IOCTL(irqwait, (drm_radeon_irq_wait_t __user *) data,
+				 sizeof(irqwait));
 
-	return radeon_wait_irq( dev, irqwait.irq_seq );
+	return radeon_wait_irq(dev, irqwait.irq_seq);
 }
 
-
 /* drm_dma.h hooks
 */
-void radeon_driver_irq_preinstall( drm_device_t *dev ) {
+void radeon_driver_irq_preinstall(drm_device_t * dev)
+{
 	drm_radeon_private_t *dev_priv =
-		(drm_radeon_private_t *)dev->dev_private;
+	    (drm_radeon_private_t *) dev->dev_private;
 
- 	/* Disable *all* interrupts */
-      	RADEON_WRITE( RADEON_GEN_INT_CNTL, 0 );
+	/* Disable *all* interrupts */
+	RADEON_WRITE(RADEON_GEN_INT_CNTL, 0);
 
 	/* Clear bits if they're already high */
-	radeon_acknowledge_irqs(dev_priv, (RADEON_SW_INT_TEST_ACK |
+	radeon_acknowledge_irqs(dev_priv, (RADEON_SW_INT_TEST_ACK | 
 					   RADEON_CRTC_VBLANK_STAT));
 }
 
-void radeon_driver_irq_postinstall( drm_device_t *dev ) {
+void radeon_driver_irq_postinstall(drm_device_t * dev)
+{
 	drm_radeon_private_t *dev_priv =
-		(drm_radeon_private_t *)dev->dev_private;
+	    (drm_radeon_private_t *) dev->dev_private;
 
-   	atomic_set(&dev_priv->swi_emitted, 0);
-	DRM_INIT_WAITQUEUE( &dev_priv->swi_queue );
+	atomic_set(&dev_priv->swi_emitted, 0);
+	DRM_INIT_WAITQUEUE(&dev_priv->swi_queue);
 
 	/* Turn on SW and VBL ints */
-   	RADEON_WRITE( RADEON_GEN_INT_CNTL,
-		      RADEON_CRTC_VBLANK_MASK |	
-		      RADEON_SW_INT_ENABLE );
+	RADEON_WRITE(RADEON_GEN_INT_CNTL,
+		     RADEON_CRTC_VBLANK_MASK | RADEON_SW_INT_ENABLE);
 }
 
-void radeon_driver_irq_uninstall( drm_device_t *dev ) {
+void radeon_driver_irq_uninstall(drm_device_t * dev)
+{
 	drm_radeon_private_t *dev_priv =
-		(drm_radeon_private_t *)dev->dev_private;
+	    (drm_radeon_private_t *) dev->dev_private;
 	if (!dev_priv)
 		return;
 
 	/* Disable *all* interrupts */
-	RADEON_WRITE( RADEON_GEN_INT_CNTL, 0 );
+	RADEON_WRITE(RADEON_GEN_INT_CNTL, 0);
 }
diff -purN linux-2.6.12.orig/drivers/char/drm/radeon_mem.c linux-2.6.12/drivers/char/drm/radeon_mem.c
--- linux-2.6.12.orig/drivers/char/drm/radeon_mem.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/radeon_mem.c	2005-07-05 08:37:47.000000000 +0200
@@ -1,7 +1,7 @@
 /* radeon_mem.c -- Simple GART/fb memory manager for radeon -*- linux-c -*-
  *
  * Copyright (C) The Weather Channel, Inc.  2002.  All Rights Reserved.
- * 
+ *
  * The Weather Channel (TM) funded Tungsten Graphics to develop the
  * initial release of the Radeon 8500 driver under the XFree86 license.
  * This notice must be preserved.
@@ -35,16 +35,17 @@
 #include "radeon_drv.h"
 
 /* Very simple allocator for GART memory, working on a static range
- * already mapped into each client's address space.  
+ * already mapped into each client's address space.
  */
 
 static struct mem_block *split_block(struct mem_block *p, int start, int size,
-				     DRMFILE filp )
+				     DRMFILE filp)
 {
 	/* Maybe cut off the start of an existing block */
 	if (start > p->start) {
-		struct mem_block *newblock = drm_alloc(sizeof(*newblock), DRM_MEM_BUFS );
-		if (!newblock) 
+		struct mem_block *newblock =
+		    drm_alloc(sizeof(*newblock), DRM_MEM_BUFS);
+		if (!newblock)
 			goto out;
 		newblock->start = start;
 		newblock->size = p->size - (start - p->start);
@@ -56,10 +57,11 @@ static struct mem_block *split_block(str
 		p->size -= newblock->size;
 		p = newblock;
 	}
-   
+
 	/* Maybe cut off the end of an existing block */
 	if (size < p->size) {
-		struct mem_block *newblock = drm_alloc(sizeof(*newblock), DRM_MEM_BUFS );
+		struct mem_block *newblock =
+		    drm_alloc(sizeof(*newblock), DRM_MEM_BUFS);
 		if (!newblock)
 			goto out;
 		newblock->start = start + size;
@@ -72,28 +74,28 @@ static struct mem_block *split_block(str
 		p->size = size;
 	}
 
- out:
+      out:
 	/* Our block is in the middle */
 	p->filp = filp;
 	return p;
 }
 
-static struct mem_block *alloc_block( struct mem_block *heap, int size, 
-				      int align2, DRMFILE filp )
+static struct mem_block *alloc_block(struct mem_block *heap, int size,
+				     int align2, DRMFILE filp)
 {
 	struct mem_block *p;
-	int mask = (1 << align2)-1;
+	int mask = (1 << align2) - 1;
 
 	list_for_each(p, heap) {
 		int start = (p->start + mask) & ~mask;
 		if (p->filp == 0 && start + size <= p->start + p->size)
-			return split_block( p, start, size, filp );
+			return split_block(p, start, size, filp);
 	}
 
 	return NULL;
 }
 
-static struct mem_block *find_block( struct mem_block *heap, int start )
+static struct mem_block *find_block(struct mem_block *heap, int start)
 {
 	struct mem_block *p;
 
@@ -104,8 +106,7 @@ static struct mem_block *find_block( str
 	return NULL;
 }
 
-
-static void free_block( struct mem_block *p )
+static void free_block(struct mem_block *p)
 {
 	p->filp = NULL;
 
@@ -117,7 +118,7 @@ static void free_block( struct mem_block
 		p->size += q->size;
 		p->next = q->next;
 		p->next->prev = p;
-		drm_free(q, sizeof(*q), DRM_MEM_BUFS );
+		drm_free(q, sizeof(*q), DRM_MEM_BUFS);
 	}
 
 	if (p->prev->filp == 0) {
@@ -125,7 +126,7 @@ static void free_block( struct mem_block
 		q->size += p->size;
 		q->next = p->next;
 		q->next->prev = q;
-		drm_free(p, sizeof(*q), DRM_MEM_BUFS );
+		drm_free(p, sizeof(*q), DRM_MEM_BUFS);
 	}
 }
 
@@ -133,14 +134,14 @@ static void free_block( struct mem_block
  */
 static int init_heap(struct mem_block **heap, int start, int size)
 {
-	struct mem_block *blocks = drm_alloc(sizeof(*blocks), DRM_MEM_BUFS );
+	struct mem_block *blocks = drm_alloc(sizeof(*blocks), DRM_MEM_BUFS);
 
-	if (!blocks) 
+	if (!blocks)
 		return DRM_ERR(ENOMEM);
-	
-	*heap = drm_alloc(sizeof(**heap), DRM_MEM_BUFS );
+
+	*heap = drm_alloc(sizeof(**heap), DRM_MEM_BUFS);
 	if (!*heap) {
-		drm_free( blocks, sizeof(*blocks), DRM_MEM_BUFS );
+		drm_free(blocks, sizeof(*blocks), DRM_MEM_BUFS);
 		return DRM_ERR(ENOMEM);
 	}
 
@@ -149,16 +150,15 @@ static int init_heap(struct mem_block **
 	blocks->filp = NULL;
 	blocks->next = blocks->prev = *heap;
 
-	memset( *heap, 0, sizeof(**heap) );
-	(*heap)->filp = (DRMFILE) -1;
+	memset(*heap, 0, sizeof(**heap));
+	(*heap)->filp = (DRMFILE) - 1;
 	(*heap)->next = (*heap)->prev = blocks;
 	return 0;
 }
 
-
 /* Free all blocks associated with the releasing file.
  */
-void radeon_mem_release( DRMFILE filp, struct mem_block *heap )
+void radeon_mem_release(DRMFILE filp, struct mem_block *heap)
 {
 	struct mem_block *p;
 
@@ -166,7 +166,7 @@ void radeon_mem_release( DRMFILE filp, s
 		return;
 
 	list_for_each(p, heap) {
-		if (p->filp == filp) 
+		if (p->filp == filp)
 			p->filp = NULL;
 	}
 
@@ -179,40 +179,37 @@ void radeon_mem_release( DRMFILE filp, s
 			p->size += q->size;
 			p->next = q->next;
 			p->next->prev = p;
-			drm_free(q, sizeof(*q),DRM_MEM_DRIVER);
+			drm_free(q, sizeof(*q), DRM_MEM_DRIVER);
 		}
 	}
 }
 
 /* Shutdown.
  */
-void radeon_mem_takedown( struct mem_block **heap )
+void radeon_mem_takedown(struct mem_block **heap)
 {
 	struct mem_block *p;
-	
+
 	if (!*heap)
 		return;
 
-	for (p = (*heap)->next ; p != *heap ; ) {
+	for (p = (*heap)->next; p != *heap;) {
 		struct mem_block *q = p;
 		p = p->next;
-		drm_free(q, sizeof(*q),DRM_MEM_DRIVER);
+		drm_free(q, sizeof(*q), DRM_MEM_DRIVER);
 	}
 
-	drm_free( *heap, sizeof(**heap),DRM_MEM_DRIVER );
+	drm_free(*heap, sizeof(**heap), DRM_MEM_DRIVER);
 	*heap = NULL;
 }
 
-
-
 /* IOCTL HANDLERS */
 
-static struct mem_block **get_heap( drm_radeon_private_t *dev_priv,
-				   int region )
+static struct mem_block **get_heap(drm_radeon_private_t * dev_priv, int region)
 {
-	switch( region ) {
+	switch (region) {
 	case RADEON_MEM_REGION_GART:
- 		return &dev_priv->gart_heap; 
+		return &dev_priv->gart_heap;
 	case RADEON_MEM_REGION_FB:
 		return &dev_priv->fb_heap;
 	default:
@@ -220,103 +217,98 @@ static struct mem_block **get_heap( drm_
 	}
 }
 
-int radeon_mem_alloc( DRM_IOCTL_ARGS )
+int radeon_mem_alloc(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_radeon_private_t *dev_priv = dev->dev_private;
 	drm_radeon_mem_alloc_t alloc;
 	struct mem_block *block, **heap;
 
-	if ( !dev_priv ) {
-		DRM_ERROR( "%s called with no initialization\n", __FUNCTION__ );
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
 		return DRM_ERR(EINVAL);
 	}
 
-	DRM_COPY_FROM_USER_IOCTL( alloc, (drm_radeon_mem_alloc_t __user *)data,
-				  sizeof(alloc) );
+	DRM_COPY_FROM_USER_IOCTL(alloc, (drm_radeon_mem_alloc_t __user *) data,
+				 sizeof(alloc));
 
-	heap = get_heap( dev_priv, alloc.region );
+	heap = get_heap(dev_priv, alloc.region);
 	if (!heap || !*heap)
 		return DRM_ERR(EFAULT);
-	
+
 	/* Make things easier on ourselves: all allocations at least
 	 * 4k aligned.
 	 */
 	if (alloc.alignment < 12)
 		alloc.alignment = 12;
 
-	block = alloc_block( *heap, alloc.size, alloc.alignment,
-			     filp );
+	block = alloc_block(*heap, alloc.size, alloc.alignment, filp);
 
-	if (!block) 
+	if (!block)
 		return DRM_ERR(ENOMEM);
 
-	if ( DRM_COPY_TO_USER( alloc.region_offset, &block->start, 
-			       sizeof(int) ) ) {
-		DRM_ERROR( "copy_to_user\n" );
+	if (DRM_COPY_TO_USER(alloc.region_offset, &block->start, sizeof(int))) {
+		DRM_ERROR("copy_to_user\n");
 		return DRM_ERR(EFAULT);
 	}
-	
+
 	return 0;
 }
 
-
-
-int radeon_mem_free( DRM_IOCTL_ARGS )
+int radeon_mem_free(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_radeon_private_t *dev_priv = dev->dev_private;
 	drm_radeon_mem_free_t memfree;
 	struct mem_block *block, **heap;
 
-	if ( !dev_priv ) {
-		DRM_ERROR( "%s called with no initialization\n", __FUNCTION__ );
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
 		return DRM_ERR(EINVAL);
 	}
 
-	DRM_COPY_FROM_USER_IOCTL( memfree, (drm_radeon_mem_free_t __user *)data,
-				  sizeof(memfree) );
+	DRM_COPY_FROM_USER_IOCTL(memfree, (drm_radeon_mem_free_t __user *) data,
+				 sizeof(memfree));
 
-	heap = get_heap( dev_priv, memfree.region );
+	heap = get_heap(dev_priv, memfree.region);
 	if (!heap || !*heap)
 		return DRM_ERR(EFAULT);
-	
-	block = find_block( *heap, memfree.region_offset );
+
+	block = find_block(*heap, memfree.region_offset);
 	if (!block)
 		return DRM_ERR(EFAULT);
 
 	if (block->filp != filp)
 		return DRM_ERR(EPERM);
 
-	free_block( block );	
+	free_block(block);
 	return 0;
 }
 
-int radeon_mem_init_heap( DRM_IOCTL_ARGS )
+int radeon_mem_init_heap(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_radeon_private_t *dev_priv = dev->dev_private;
 	drm_radeon_mem_init_heap_t initheap;
 	struct mem_block **heap;
 
-	if ( !dev_priv ) {
-		DRM_ERROR( "%s called with no initialization\n", __FUNCTION__ );
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
 		return DRM_ERR(EINVAL);
 	}
 
-	DRM_COPY_FROM_USER_IOCTL( initheap, (drm_radeon_mem_init_heap_t __user *)data,
-				  sizeof(initheap) );
+	DRM_COPY_FROM_USER_IOCTL(initheap,
+				 (drm_radeon_mem_init_heap_t __user *) data,
+				 sizeof(initheap));
 
-	heap = get_heap( dev_priv, initheap.region );
-	if (!heap) 
+	heap = get_heap(dev_priv, initheap.region);
+	if (!heap)
 		return DRM_ERR(EFAULT);
-	
+
 	if (*heap) {
 		DRM_ERROR("heap already initialized?");
 		return DRM_ERR(EFAULT);
 	}
-		
-	return init_heap( heap, initheap.start, initheap.size );
-}
-
 
+	return init_heap(heap, initheap.start, initheap.size);
+}
diff -purN linux-2.6.12.orig/drivers/char/drm/radeon_state.c linux-2.6.12/drivers/char/drm/radeon_state.c
--- linux-2.6.12.orig/drivers/char/drm/radeon_state.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/radeon_state.c	2005-07-05 08:37:47.000000000 +0200
@@ -37,51 +37,53 @@
  * Helper functions for client state checking and fixup
  */
 
-static __inline__ int radeon_check_and_fixup_offset( drm_radeon_private_t *dev_priv,
-						     drm_file_t *filp_priv,
-						     u32 *offset ) {
+static __inline__ int radeon_check_and_fixup_offset(drm_radeon_private_t *
+						    dev_priv,
+						    drm_file_t * filp_priv,
+						    u32 * offset)
+{
 	u32 off = *offset;
 	struct drm_radeon_driver_file_fields *radeon_priv;
 
-	if ( off >= dev_priv->fb_location &&
-	     off < ( dev_priv->gart_vm_start + dev_priv->gart_size ) )
+	if (off >= dev_priv->fb_location &&
+	    off < (dev_priv->gart_vm_start + dev_priv->gart_size))
 		return 0;
 
 	radeon_priv = filp_priv->driver_priv;
+
 	off += radeon_priv->radeon_fb_delta;
 
-	DRM_DEBUG( "offset fixed up to 0x%x\n", off );
+	DRM_DEBUG("offset fixed up to 0x%x\n", off);
 
-	if ( off < dev_priv->fb_location ||
-	     off >= ( dev_priv->gart_vm_start + dev_priv->gart_size ) )
-		return DRM_ERR( EINVAL );
+	if (off < dev_priv->fb_location ||
+	    off >= (dev_priv->gart_vm_start + dev_priv->gart_size))
+		return DRM_ERR(EINVAL);
 
 	*offset = off;
 
 	return 0;
 }
 
-static __inline__ int radeon_check_and_fixup_packets( drm_radeon_private_t *dev_priv,
-						      drm_file_t *filp_priv,
-						      int id,
-						      u32 __user *data ) {
-	switch ( id ) {
+static __inline__ int radeon_check_and_fixup_packets(drm_radeon_private_t *
+						     dev_priv,
+						     drm_file_t * filp_priv,
+						     int id, u32 __user * data)
+{
+	switch (id) {
 
 	case RADEON_EMIT_PP_MISC:
-		if ( radeon_check_and_fixup_offset( dev_priv, filp_priv,
-						    &data[( RADEON_RB3D_DEPTHOFFSET
-							    - RADEON_PP_MISC ) / 4] ) ) {
-			DRM_ERROR( "Invalid depth buffer offset\n" );
-			return DRM_ERR( EINVAL );
+		if (radeon_check_and_fixup_offset(dev_priv, filp_priv,
+		    &data[(RADEON_RB3D_DEPTHOFFSET - RADEON_PP_MISC) / 4])) {
+			DRM_ERROR("Invalid depth buffer offset\n");
+			return DRM_ERR(EINVAL);
 		}
 		break;
 
 	case RADEON_EMIT_PP_CNTL:
-		if ( radeon_check_and_fixup_offset( dev_priv, filp_priv,
-						    &data[( RADEON_RB3D_COLOROFFSET
-							    - RADEON_PP_CNTL ) / 4] ) ) {
-			DRM_ERROR( "Invalid colour buffer offset\n" );
-			return DRM_ERR( EINVAL );
+		if (radeon_check_and_fixup_offset(dev_priv, filp_priv,
+		    &data[(RADEON_RB3D_COLOROFFSET - RADEON_PP_CNTL) / 4])) {
+			DRM_ERROR("Invalid colour buffer offset\n");
+			return DRM_ERR(EINVAL);
 		}
 		break;
 
@@ -91,21 +93,20 @@ static __inline__ int radeon_check_and_f
 	case R200_EMIT_PP_TXOFFSET_3:
 	case R200_EMIT_PP_TXOFFSET_4:
 	case R200_EMIT_PP_TXOFFSET_5:
-		if ( radeon_check_and_fixup_offset( dev_priv, filp_priv,
-						    &data[0] ) ) {
-			DRM_ERROR( "Invalid R200 texture offset\n" );
-			return DRM_ERR( EINVAL );
+		if (radeon_check_and_fixup_offset(dev_priv, filp_priv,
+						  &data[0])) {
+			DRM_ERROR("Invalid R200 texture offset\n");
+			return DRM_ERR(EINVAL);
 		}
 		break;
 
 	case RADEON_EMIT_PP_TXFILTER_0:
 	case RADEON_EMIT_PP_TXFILTER_1:
 	case RADEON_EMIT_PP_TXFILTER_2:
-		if ( radeon_check_and_fixup_offset( dev_priv, filp_priv,
-						    &data[( RADEON_PP_TXOFFSET_0
-							    - RADEON_PP_TXFILTER_0 ) / 4] ) ) {
-			DRM_ERROR( "Invalid R100 texture offset\n" );
-			return DRM_ERR( EINVAL );
+		if (radeon_check_and_fixup_offset(dev_priv, filp_priv,
+		    &data[(RADEON_PP_TXOFFSET_0 - RADEON_PP_TXFILTER_0) / 4])) {
+			DRM_ERROR("Invalid R100 texture offset\n");
+			return DRM_ERR(EINVAL);
 		}
 		break;
 
@@ -114,17 +115,19 @@ static __inline__ int radeon_check_and_f
 	case R200_EMIT_PP_CUBIC_OFFSETS_2:
 	case R200_EMIT_PP_CUBIC_OFFSETS_3:
 	case R200_EMIT_PP_CUBIC_OFFSETS_4:
-	case R200_EMIT_PP_CUBIC_OFFSETS_5: {
-		int i;
-		for ( i = 0; i < 5; i++ ) {
-			if ( radeon_check_and_fixup_offset( dev_priv, filp_priv,
-							    &data[i] ) ) {
-				DRM_ERROR( "Invalid R200 cubic texture offset\n" );
-				return DRM_ERR( EINVAL );
+	case R200_EMIT_PP_CUBIC_OFFSETS_5:{
+			int i;
+			for (i = 0; i < 5; i++) {
+				if (radeon_check_and_fixup_offset(dev_priv,
+								  filp_priv,
+								  &data[i])) {
+					DRM_ERROR
+					    ("Invalid R200 cubic texture offset\n");
+					return DRM_ERR(EINVAL);
+				}
 			}
+			break;
 		}
-		break;
-	}
 
 	case RADEON_EMIT_PP_CUBIC_OFFSETS_T0:
 	case RADEON_EMIT_PP_CUBIC_OFFSETS_T1:
@@ -211,243 +214,247 @@ static __inline__ int radeon_check_and_f
 		break;
 
 	default:
-		DRM_ERROR( "Unknown state packet ID %d\n", id );
-		return DRM_ERR( EINVAL );
+		DRM_ERROR("Unknown state packet ID %d\n", id);
+		return DRM_ERR(EINVAL);
 	}
 
 	return 0;
 }
 
-static __inline__ int radeon_check_and_fixup_packet3( drm_radeon_private_t *dev_priv,
-						      drm_file_t *filp_priv,
-						      drm_radeon_cmd_buffer_t *cmdbuf,
-						      unsigned int *cmdsz ) {
+static __inline__ int radeon_check_and_fixup_packet3(drm_radeon_private_t *
+						     dev_priv,
+						     drm_file_t * filp_priv,
+						     drm_radeon_cmd_buffer_t *
+						     cmdbuf,
+						     unsigned int *cmdsz)
+{
 	u32 *cmd = (u32 *) cmdbuf->buf;
 
-	*cmdsz = 2 + ( ( cmd[0] & RADEON_CP_PACKET_COUNT_MASK ) >> 16 );
+	*cmdsz = 2 + ((cmd[0] & RADEON_CP_PACKET_COUNT_MASK) >> 16);
 
-	if ( ( cmd[0] & 0xc0000000 ) != RADEON_CP_PACKET3 ) {
-		DRM_ERROR( "Not a type 3 packet\n" );
-		return DRM_ERR( EINVAL );
+	if ((cmd[0] & 0xc0000000) != RADEON_CP_PACKET3) {
+		DRM_ERROR("Not a type 3 packet\n");
+		return DRM_ERR(EINVAL);
 	}
 
-	if ( 4 * *cmdsz > cmdbuf->bufsz ) {
-		DRM_ERROR( "Packet size larger than size of data provided\n" );
-		return DRM_ERR( EINVAL );
+	if (4 * *cmdsz > cmdbuf->bufsz) {
+		DRM_ERROR("Packet size larger than size of data provided\n");
+		return DRM_ERR(EINVAL);
 	}
 
 	/* Check client state and fix it up if necessary */
-	if ( cmd[0] & 0x8000 ) { /* MSB of opcode: next DWORD GUI_CNTL */
+	if (cmd[0] & 0x8000) {	/* MSB of opcode: next DWORD GUI_CNTL */
 		u32 offset;
 
-		if ( cmd[1] & ( RADEON_GMC_SRC_PITCH_OFFSET_CNTL
-			      | RADEON_GMC_DST_PITCH_OFFSET_CNTL ) ) {
+		if (cmd[1] & (RADEON_GMC_SRC_PITCH_OFFSET_CNTL
+			      | RADEON_GMC_DST_PITCH_OFFSET_CNTL)) {
 			offset = cmd[2] << 10;
-			if ( radeon_check_and_fixup_offset( dev_priv, filp_priv, &offset ) ) {
-				DRM_ERROR( "Invalid first packet offset\n" );
-				return DRM_ERR( EINVAL );
+			if (radeon_check_and_fixup_offset
+			    (dev_priv, filp_priv, &offset)) {
+				DRM_ERROR("Invalid first packet offset\n");
+				return DRM_ERR(EINVAL);
 			}
-			cmd[2] = ( cmd[2] & 0xffc00000 ) | offset >> 10;
+			cmd[2] = (cmd[2] & 0xffc00000) | offset >> 10;
 		}
 
-		if ( ( cmd[1] & RADEON_GMC_SRC_PITCH_OFFSET_CNTL ) &&
-		     ( cmd[1] & RADEON_GMC_DST_PITCH_OFFSET_CNTL ) ) {
+		if ((cmd[1] & RADEON_GMC_SRC_PITCH_OFFSET_CNTL) &&
+		    (cmd[1] & RADEON_GMC_DST_PITCH_OFFSET_CNTL)) {
 			offset = cmd[3] << 10;
-			if ( radeon_check_and_fixup_offset( dev_priv, filp_priv, &offset ) ) {
-				DRM_ERROR( "Invalid second packet offset\n" );
-				return DRM_ERR( EINVAL );
+			if (radeon_check_and_fixup_offset
+			    (dev_priv, filp_priv, &offset)) {
+				DRM_ERROR("Invalid second packet offset\n");
+				return DRM_ERR(EINVAL);
 			}
-			cmd[3] = ( cmd[3] & 0xffc00000 ) | offset >> 10;
+			cmd[3] = (cmd[3] & 0xffc00000) | offset >> 10;
 		}
 	}
 
 	return 0;
 }
 
-
 /* ================================================================
  * CP hardware state programming functions
  */
 
-static __inline__ void radeon_emit_clip_rect( drm_radeon_private_t *dev_priv,
-					  drm_clip_rect_t *box )
+static __inline__ void radeon_emit_clip_rect(drm_radeon_private_t * dev_priv,
+					     drm_clip_rect_t * box)
 {
 	RING_LOCALS;
 
-	DRM_DEBUG( "   box:  x1=%d y1=%d  x2=%d y2=%d\n",
-		   box->x1, box->y1, box->x2, box->y2 );
+	DRM_DEBUG("   box:  x1=%d y1=%d  x2=%d y2=%d\n",
+		  box->x1, box->y1, box->x2, box->y2);
 
-	BEGIN_RING( 4 );
-	OUT_RING( CP_PACKET0( RADEON_RE_TOP_LEFT, 0 ) );
-	OUT_RING( (box->y1 << 16) | box->x1 );
-	OUT_RING( CP_PACKET0( RADEON_RE_WIDTH_HEIGHT, 0 ) );
-	OUT_RING( ((box->y2 - 1) << 16) | (box->x2 - 1) );
+	BEGIN_RING(4);
+	OUT_RING(CP_PACKET0(RADEON_RE_TOP_LEFT, 0));
+	OUT_RING((box->y1 << 16) | box->x1);
+	OUT_RING(CP_PACKET0(RADEON_RE_WIDTH_HEIGHT, 0));
+	OUT_RING(((box->y2 - 1) << 16) | (box->x2 - 1));
 	ADVANCE_RING();
 }
 
 /* Emit 1.1 state
  */
-static int radeon_emit_state( drm_radeon_private_t *dev_priv,
-			      drm_file_t *filp_priv,
-			      drm_radeon_context_regs_t *ctx,
-			      drm_radeon_texture_regs_t *tex,
-			      unsigned int dirty )
+static int radeon_emit_state(drm_radeon_private_t * dev_priv,
+			     drm_file_t * filp_priv,
+			     drm_radeon_context_regs_t * ctx,
+			     drm_radeon_texture_regs_t * tex,
+			     unsigned int dirty)
 {
 	RING_LOCALS;
-	DRM_DEBUG( "dirty=0x%08x\n", dirty );
+	DRM_DEBUG("dirty=0x%08x\n", dirty);
 
-	if ( dirty & RADEON_UPLOAD_CONTEXT ) {
-		if ( radeon_check_and_fixup_offset( dev_priv, filp_priv,
-						    &ctx->rb3d_depthoffset ) ) {
-			DRM_ERROR( "Invalid depth buffer offset\n" );
-			return DRM_ERR( EINVAL );
+	if (dirty & RADEON_UPLOAD_CONTEXT) {
+		if (radeon_check_and_fixup_offset(dev_priv, filp_priv,
+						  &ctx->rb3d_depthoffset)) {
+			DRM_ERROR("Invalid depth buffer offset\n");
+			return DRM_ERR(EINVAL);
 		}
 
-		if ( radeon_check_and_fixup_offset( dev_priv, filp_priv,
-						    &ctx->rb3d_coloroffset ) ) {
-			DRM_ERROR( "Invalid depth buffer offset\n" );
-			return DRM_ERR( EINVAL );
+		if (radeon_check_and_fixup_offset(dev_priv, filp_priv,
+						  &ctx->rb3d_coloroffset)) {
+			DRM_ERROR("Invalid depth buffer offset\n");
+			return DRM_ERR(EINVAL);
 		}
 
-		BEGIN_RING( 14 );
-		OUT_RING( CP_PACKET0( RADEON_PP_MISC, 6 ) );
-		OUT_RING( ctx->pp_misc );
-		OUT_RING( ctx->pp_fog_color );
-		OUT_RING( ctx->re_solid_color );
-		OUT_RING( ctx->rb3d_blendcntl );
-		OUT_RING( ctx->rb3d_depthoffset );
-		OUT_RING( ctx->rb3d_depthpitch );
-		OUT_RING( ctx->rb3d_zstencilcntl );
-		OUT_RING( CP_PACKET0( RADEON_PP_CNTL, 2 ) );
-		OUT_RING( ctx->pp_cntl );
-		OUT_RING( ctx->rb3d_cntl );
-		OUT_RING( ctx->rb3d_coloroffset );
-		OUT_RING( CP_PACKET0( RADEON_RB3D_COLORPITCH, 0 ) );
-		OUT_RING( ctx->rb3d_colorpitch );
+		BEGIN_RING(14);
+		OUT_RING(CP_PACKET0(RADEON_PP_MISC, 6));
+		OUT_RING(ctx->pp_misc);
+		OUT_RING(ctx->pp_fog_color);
+		OUT_RING(ctx->re_solid_color);
+		OUT_RING(ctx->rb3d_blendcntl);
+		OUT_RING(ctx->rb3d_depthoffset);
+		OUT_RING(ctx->rb3d_depthpitch);
+		OUT_RING(ctx->rb3d_zstencilcntl);
+		OUT_RING(CP_PACKET0(RADEON_PP_CNTL, 2));
+		OUT_RING(ctx->pp_cntl);
+		OUT_RING(ctx->rb3d_cntl);
+		OUT_RING(ctx->rb3d_coloroffset);
+		OUT_RING(CP_PACKET0(RADEON_RB3D_COLORPITCH, 0));
+		OUT_RING(ctx->rb3d_colorpitch);
 		ADVANCE_RING();
 	}
 
-	if ( dirty & RADEON_UPLOAD_VERTFMT ) {
-		BEGIN_RING( 2 );
-		OUT_RING( CP_PACKET0( RADEON_SE_COORD_FMT, 0 ) );
-		OUT_RING( ctx->se_coord_fmt );
+	if (dirty & RADEON_UPLOAD_VERTFMT) {
+		BEGIN_RING(2);
+		OUT_RING(CP_PACKET0(RADEON_SE_COORD_FMT, 0));
+		OUT_RING(ctx->se_coord_fmt);
 		ADVANCE_RING();
 	}
 
-	if ( dirty & RADEON_UPLOAD_LINE ) {
-		BEGIN_RING( 5 );
-		OUT_RING( CP_PACKET0( RADEON_RE_LINE_PATTERN, 1 ) );
-		OUT_RING( ctx->re_line_pattern );
-		OUT_RING( ctx->re_line_state );
-		OUT_RING( CP_PACKET0( RADEON_SE_LINE_WIDTH, 0 ) );
-		OUT_RING( ctx->se_line_width );
+	if (dirty & RADEON_UPLOAD_LINE) {
+		BEGIN_RING(5);
+		OUT_RING(CP_PACKET0(RADEON_RE_LINE_PATTERN, 1));
+		OUT_RING(ctx->re_line_pattern);
+		OUT_RING(ctx->re_line_state);
+		OUT_RING(CP_PACKET0(RADEON_SE_LINE_WIDTH, 0));
+		OUT_RING(ctx->se_line_width);
 		ADVANCE_RING();
 	}
 
-	if ( dirty & RADEON_UPLOAD_BUMPMAP ) {
-		BEGIN_RING( 5 );
-		OUT_RING( CP_PACKET0( RADEON_PP_LUM_MATRIX, 0 ) );
-		OUT_RING( ctx->pp_lum_matrix );
-		OUT_RING( CP_PACKET0( RADEON_PP_ROT_MATRIX_0, 1 ) );
-		OUT_RING( ctx->pp_rot_matrix_0 );
-		OUT_RING( ctx->pp_rot_matrix_1 );
+	if (dirty & RADEON_UPLOAD_BUMPMAP) {
+		BEGIN_RING(5);
+		OUT_RING(CP_PACKET0(RADEON_PP_LUM_MATRIX, 0));
+		OUT_RING(ctx->pp_lum_matrix);
+		OUT_RING(CP_PACKET0(RADEON_PP_ROT_MATRIX_0, 1));
+		OUT_RING(ctx->pp_rot_matrix_0);
+		OUT_RING(ctx->pp_rot_matrix_1);
 		ADVANCE_RING();
 	}
 
-	if ( dirty & RADEON_UPLOAD_MASKS ) {
-		BEGIN_RING( 4 );
-		OUT_RING( CP_PACKET0( RADEON_RB3D_STENCILREFMASK, 2 ) );
-		OUT_RING( ctx->rb3d_stencilrefmask );
-		OUT_RING( ctx->rb3d_ropcntl );
-		OUT_RING( ctx->rb3d_planemask );
+	if (dirty & RADEON_UPLOAD_MASKS) {
+		BEGIN_RING(4);
+		OUT_RING(CP_PACKET0(RADEON_RB3D_STENCILREFMASK, 2));
+		OUT_RING(ctx->rb3d_stencilrefmask);
+		OUT_RING(ctx->rb3d_ropcntl);
+		OUT_RING(ctx->rb3d_planemask);
 		ADVANCE_RING();
 	}
 
-	if ( dirty & RADEON_UPLOAD_VIEWPORT ) {
-		BEGIN_RING( 7 );
-		OUT_RING( CP_PACKET0( RADEON_SE_VPORT_XSCALE, 5 ) );
-		OUT_RING( ctx->se_vport_xscale );
-		OUT_RING( ctx->se_vport_xoffset );
-		OUT_RING( ctx->se_vport_yscale );
-		OUT_RING( ctx->se_vport_yoffset );
-		OUT_RING( ctx->se_vport_zscale );
-		OUT_RING( ctx->se_vport_zoffset );
+	if (dirty & RADEON_UPLOAD_VIEWPORT) {
+		BEGIN_RING(7);
+		OUT_RING(CP_PACKET0(RADEON_SE_VPORT_XSCALE, 5));
+		OUT_RING(ctx->se_vport_xscale);
+		OUT_RING(ctx->se_vport_xoffset);
+		OUT_RING(ctx->se_vport_yscale);
+		OUT_RING(ctx->se_vport_yoffset);
+		OUT_RING(ctx->se_vport_zscale);
+		OUT_RING(ctx->se_vport_zoffset);
 		ADVANCE_RING();
 	}
 
-	if ( dirty & RADEON_UPLOAD_SETUP ) {
-		BEGIN_RING( 4 );
-		OUT_RING( CP_PACKET0( RADEON_SE_CNTL, 0 ) );
-		OUT_RING( ctx->se_cntl );
-		OUT_RING( CP_PACKET0( RADEON_SE_CNTL_STATUS, 0 ) );
-		OUT_RING( ctx->se_cntl_status );
+	if (dirty & RADEON_UPLOAD_SETUP) {
+		BEGIN_RING(4);
+		OUT_RING(CP_PACKET0(RADEON_SE_CNTL, 0));
+		OUT_RING(ctx->se_cntl);
+		OUT_RING(CP_PACKET0(RADEON_SE_CNTL_STATUS, 0));
+		OUT_RING(ctx->se_cntl_status);
 		ADVANCE_RING();
 	}
 
-	if ( dirty & RADEON_UPLOAD_MISC ) {
-		BEGIN_RING( 2 );
-		OUT_RING( CP_PACKET0( RADEON_RE_MISC, 0 ) );
-		OUT_RING( ctx->re_misc );
+	if (dirty & RADEON_UPLOAD_MISC) {
+		BEGIN_RING(2);
+		OUT_RING(CP_PACKET0(RADEON_RE_MISC, 0));
+		OUT_RING(ctx->re_misc);
 		ADVANCE_RING();
 	}
 
-	if ( dirty & RADEON_UPLOAD_TEX0 ) {
-		if ( radeon_check_and_fixup_offset( dev_priv, filp_priv,
-						    &tex[0].pp_txoffset ) ) {
-			DRM_ERROR( "Invalid texture offset for unit 0\n" );
-			return DRM_ERR( EINVAL );
+	if (dirty & RADEON_UPLOAD_TEX0) {
+		if (radeon_check_and_fixup_offset(dev_priv, filp_priv,
+						  &tex[0].pp_txoffset)) {
+			DRM_ERROR("Invalid texture offset for unit 0\n");
+			return DRM_ERR(EINVAL);
 		}
 
-		BEGIN_RING( 9 );
-		OUT_RING( CP_PACKET0( RADEON_PP_TXFILTER_0, 5 ) );
-		OUT_RING( tex[0].pp_txfilter );
-		OUT_RING( tex[0].pp_txformat );
-		OUT_RING( tex[0].pp_txoffset );
-		OUT_RING( tex[0].pp_txcblend );
-		OUT_RING( tex[0].pp_txablend );
-		OUT_RING( tex[0].pp_tfactor );
-		OUT_RING( CP_PACKET0( RADEON_PP_BORDER_COLOR_0, 0 ) );
-		OUT_RING( tex[0].pp_border_color );
+		BEGIN_RING(9);
+		OUT_RING(CP_PACKET0(RADEON_PP_TXFILTER_0, 5));
+		OUT_RING(tex[0].pp_txfilter);
+		OUT_RING(tex[0].pp_txformat);
+		OUT_RING(tex[0].pp_txoffset);
+		OUT_RING(tex[0].pp_txcblend);
+		OUT_RING(tex[0].pp_txablend);
+		OUT_RING(tex[0].pp_tfactor);
+		OUT_RING(CP_PACKET0(RADEON_PP_BORDER_COLOR_0, 0));
+		OUT_RING(tex[0].pp_border_color);
 		ADVANCE_RING();
 	}
 
-	if ( dirty & RADEON_UPLOAD_TEX1 ) {
-		if ( radeon_check_and_fixup_offset( dev_priv, filp_priv,
-						    &tex[1].pp_txoffset ) ) {
-			DRM_ERROR( "Invalid texture offset for unit 1\n" );
-			return DRM_ERR( EINVAL );
+	if (dirty & RADEON_UPLOAD_TEX1) {
+		if (radeon_check_and_fixup_offset(dev_priv, filp_priv,
+						  &tex[1].pp_txoffset)) {
+			DRM_ERROR("Invalid texture offset for unit 1\n");
+			return DRM_ERR(EINVAL);
 		}
 
-		BEGIN_RING( 9 );
-		OUT_RING( CP_PACKET0( RADEON_PP_TXFILTER_1, 5 ) );
-		OUT_RING( tex[1].pp_txfilter );
-		OUT_RING( tex[1].pp_txformat );
-		OUT_RING( tex[1].pp_txoffset );
-		OUT_RING( tex[1].pp_txcblend );
-		OUT_RING( tex[1].pp_txablend );
-		OUT_RING( tex[1].pp_tfactor );
-		OUT_RING( CP_PACKET0( RADEON_PP_BORDER_COLOR_1, 0 ) );
-		OUT_RING( tex[1].pp_border_color );
+		BEGIN_RING(9);
+		OUT_RING(CP_PACKET0(RADEON_PP_TXFILTER_1, 5));
+		OUT_RING(tex[1].pp_txfilter);
+		OUT_RING(tex[1].pp_txformat);
+		OUT_RING(tex[1].pp_txoffset);
+		OUT_RING(tex[1].pp_txcblend);
+		OUT_RING(tex[1].pp_txablend);
+		OUT_RING(tex[1].pp_tfactor);
+		OUT_RING(CP_PACKET0(RADEON_PP_BORDER_COLOR_1, 0));
+		OUT_RING(tex[1].pp_border_color);
 		ADVANCE_RING();
 	}
 
-	if ( dirty & RADEON_UPLOAD_TEX2 ) {
-		if ( radeon_check_and_fixup_offset( dev_priv, filp_priv,
-						    &tex[2].pp_txoffset ) ) {
-			DRM_ERROR( "Invalid texture offset for unit 2\n" );
-			return DRM_ERR( EINVAL );
+	if (dirty & RADEON_UPLOAD_TEX2) {
+		if (radeon_check_and_fixup_offset(dev_priv, filp_priv,
+						  &tex[2].pp_txoffset)) {
+			DRM_ERROR("Invalid texture offset for unit 2\n");
+			return DRM_ERR(EINVAL);
 		}
 
-		BEGIN_RING( 9 );
-		OUT_RING( CP_PACKET0( RADEON_PP_TXFILTER_2, 5 ) );
-		OUT_RING( tex[2].pp_txfilter );
-		OUT_RING( tex[2].pp_txformat );
-		OUT_RING( tex[2].pp_txoffset );
-		OUT_RING( tex[2].pp_txcblend );
-		OUT_RING( tex[2].pp_txablend );
-		OUT_RING( tex[2].pp_tfactor );
-		OUT_RING( CP_PACKET0( RADEON_PP_BORDER_COLOR_2, 0 ) );
-		OUT_RING( tex[2].pp_border_color );
+		BEGIN_RING(9);
+		OUT_RING(CP_PACKET0(RADEON_PP_TXFILTER_2, 5));
+		OUT_RING(tex[2].pp_txfilter);
+		OUT_RING(tex[2].pp_txformat);
+		OUT_RING(tex[2].pp_txoffset);
+		OUT_RING(tex[2].pp_txcblend);
+		OUT_RING(tex[2].pp_txablend);
+		OUT_RING(tex[2].pp_tfactor);
+		OUT_RING(CP_PACKET0(RADEON_PP_BORDER_COLOR_2, 0));
+		OUT_RING(tex[2].pp_border_color);
 		ADVANCE_RING();
 	}
 
@@ -456,129 +463,135 @@ static int radeon_emit_state( drm_radeon
 
 /* Emit 1.2 state
  */
-static int radeon_emit_state2( drm_radeon_private_t *dev_priv,
-			       drm_file_t *filp_priv,
-			       drm_radeon_state_t *state )
+static int radeon_emit_state2(drm_radeon_private_t * dev_priv,
+			      drm_file_t * filp_priv,
+			      drm_radeon_state_t * state)
 {
 	RING_LOCALS;
 
 	if (state->dirty & RADEON_UPLOAD_ZBIAS) {
-		BEGIN_RING( 3 );
-		OUT_RING( CP_PACKET0( RADEON_SE_ZBIAS_FACTOR, 1 ) );
-		OUT_RING( state->context2.se_zbias_factor ); 
-		OUT_RING( state->context2.se_zbias_constant ); 
+		BEGIN_RING(3);
+		OUT_RING(CP_PACKET0(RADEON_SE_ZBIAS_FACTOR, 1));
+		OUT_RING(state->context2.se_zbias_factor);
+		OUT_RING(state->context2.se_zbias_constant);
 		ADVANCE_RING();
 	}
 
-	return radeon_emit_state( dev_priv, filp_priv, &state->context,
-			   state->tex, state->dirty );
+	return radeon_emit_state(dev_priv, filp_priv, &state->context,
+				 state->tex, state->dirty);
 }
 
 /* New (1.3) state mechanism.  3 commands (packet, scalar, vector) in
  * 1.3 cmdbuffers allow all previous state to be updated as well as
- * the tcl scalar and vector areas.  
+ * the tcl scalar and vector areas.
  */
-static struct { 
-	int start; 
-	int len; 
+static struct {
+	int start;
+	int len;
 	const char *name;
 } packet[RADEON_MAX_STATE_PACKETS] = {
-	{ RADEON_PP_MISC,7,"RADEON_PP_MISC" },
-	{ RADEON_PP_CNTL,3,"RADEON_PP_CNTL" },
-	{ RADEON_RB3D_COLORPITCH,1,"RADEON_RB3D_COLORPITCH" },
-	{ RADEON_RE_LINE_PATTERN,2,"RADEON_RE_LINE_PATTERN" },
-	{ RADEON_SE_LINE_WIDTH,1,"RADEON_SE_LINE_WIDTH" },
-	{ RADEON_PP_LUM_MATRIX,1,"RADEON_PP_LUM_MATRIX" },
-	{ RADEON_PP_ROT_MATRIX_0,2,"RADEON_PP_ROT_MATRIX_0" },
-	{ RADEON_RB3D_STENCILREFMASK,3,"RADEON_RB3D_STENCILREFMASK" },
-	{ RADEON_SE_VPORT_XSCALE,6,"RADEON_SE_VPORT_XSCALE" },
-	{ RADEON_SE_CNTL,2,"RADEON_SE_CNTL" },
-	{ RADEON_SE_CNTL_STATUS,1,"RADEON_SE_CNTL_STATUS" },
-	{ RADEON_RE_MISC,1,"RADEON_RE_MISC" },
-	{ RADEON_PP_TXFILTER_0,6,"RADEON_PP_TXFILTER_0" },
-	{ RADEON_PP_BORDER_COLOR_0,1,"RADEON_PP_BORDER_COLOR_0" },
-	{ RADEON_PP_TXFILTER_1,6,"RADEON_PP_TXFILTER_1" },
-	{ RADEON_PP_BORDER_COLOR_1,1,"RADEON_PP_BORDER_COLOR_1" },
-	{ RADEON_PP_TXFILTER_2,6,"RADEON_PP_TXFILTER_2" },
-	{ RADEON_PP_BORDER_COLOR_2,1,"RADEON_PP_BORDER_COLOR_2" },
-	{ RADEON_SE_ZBIAS_FACTOR,2,"RADEON_SE_ZBIAS_FACTOR" },
-	{ RADEON_SE_TCL_OUTPUT_VTX_FMT,11,"RADEON_SE_TCL_OUTPUT_VTX_FMT" },
-	{ RADEON_SE_TCL_MATERIAL_EMMISSIVE_RED,17,"RADEON_SE_TCL_MATERIAL_EMMISSIVE_RED" },
-	{ R200_PP_TXCBLEND_0, 4, "R200_PP_TXCBLEND_0" },
-	{ R200_PP_TXCBLEND_1, 4, "R200_PP_TXCBLEND_1" },
-	{ R200_PP_TXCBLEND_2, 4, "R200_PP_TXCBLEND_2" },
-	{ R200_PP_TXCBLEND_3, 4, "R200_PP_TXCBLEND_3" },
-	{ R200_PP_TXCBLEND_4, 4, "R200_PP_TXCBLEND_4" },
-	{ R200_PP_TXCBLEND_5, 4, "R200_PP_TXCBLEND_5" },
-	{ R200_PP_TXCBLEND_6, 4, "R200_PP_TXCBLEND_6" },
-	{ R200_PP_TXCBLEND_7, 4, "R200_PP_TXCBLEND_7" },
-	{ R200_SE_TCL_LIGHT_MODEL_CTL_0, 6, "R200_SE_TCL_LIGHT_MODEL_CTL_0" },
-	{ R200_PP_TFACTOR_0, 6, "R200_PP_TFACTOR_0" },
-	{ R200_SE_VTX_FMT_0, 4, "R200_SE_VTX_FMT_0" },
-	{ R200_SE_VAP_CNTL, 1, "R200_SE_VAP_CNTL" },
-	{ R200_SE_TCL_MATRIX_SEL_0, 5, "R200_SE_TCL_MATRIX_SEL_0" },
-	{ R200_SE_TCL_TEX_PROC_CTL_2, 5, "R200_SE_TCL_TEX_PROC_CTL_2" },
-	{ R200_SE_TCL_UCP_VERT_BLEND_CTL, 1, "R200_SE_TCL_UCP_VERT_BLEND_CTL" },
-	{ R200_PP_TXFILTER_0, 6, "R200_PP_TXFILTER_0" },
-	{ R200_PP_TXFILTER_1, 6, "R200_PP_TXFILTER_1" },
-	{ R200_PP_TXFILTER_2, 6, "R200_PP_TXFILTER_2" },
-	{ R200_PP_TXFILTER_3, 6, "R200_PP_TXFILTER_3" },
-	{ R200_PP_TXFILTER_4, 6, "R200_PP_TXFILTER_4" },
-	{ R200_PP_TXFILTER_5, 6, "R200_PP_TXFILTER_5" },
-	{ R200_PP_TXOFFSET_0, 1, "R200_PP_TXOFFSET_0" },
-	{ R200_PP_TXOFFSET_1, 1, "R200_PP_TXOFFSET_1" },
-	{ R200_PP_TXOFFSET_2, 1, "R200_PP_TXOFFSET_2" },
-	{ R200_PP_TXOFFSET_3, 1, "R200_PP_TXOFFSET_3" },
-	{ R200_PP_TXOFFSET_4, 1, "R200_PP_TXOFFSET_4" },
-	{ R200_PP_TXOFFSET_5, 1, "R200_PP_TXOFFSET_5" },
-	{ R200_SE_VTE_CNTL, 1, "R200_SE_VTE_CNTL" },
-	{ R200_SE_TCL_OUTPUT_VTX_COMP_SEL, 1, "R200_SE_TCL_OUTPUT_VTX_COMP_SEL" },
-	{ R200_PP_TAM_DEBUG3, 1, "R200_PP_TAM_DEBUG3" },
-	{ R200_PP_CNTL_X, 1, "R200_PP_CNTL_X" }, 
-	{ R200_RB3D_DEPTHXY_OFFSET, 1, "R200_RB3D_DEPTHXY_OFFSET" }, 
-	{ R200_RE_AUX_SCISSOR_CNTL, 1, "R200_RE_AUX_SCISSOR_CNTL" }, 
-	{ R200_RE_SCISSOR_TL_0, 2, "R200_RE_SCISSOR_TL_0" }, 
-	{ R200_RE_SCISSOR_TL_1, 2, "R200_RE_SCISSOR_TL_1" }, 
-	{ R200_RE_SCISSOR_TL_2, 2, "R200_RE_SCISSOR_TL_2" }, 
-	{ R200_SE_VAP_CNTL_STATUS, 1, "R200_SE_VAP_CNTL_STATUS" }, 
-	{ R200_SE_VTX_STATE_CNTL, 1, "R200_SE_VTX_STATE_CNTL" }, 
-	{ R200_RE_POINTSIZE, 1, "R200_RE_POINTSIZE" }, 
-	{ R200_SE_TCL_INPUT_VTX_VECTOR_ADDR_0, 4, "R200_SE_TCL_INPUT_VTX_VECTOR_ADDR_0" },
-	{ R200_PP_CUBIC_FACES_0, 1, "R200_PP_CUBIC_FACES_0" }, /* 61 */
-	{ R200_PP_CUBIC_OFFSET_F1_0, 5, "R200_PP_CUBIC_OFFSET_F1_0" }, /* 62 */
-	{ R200_PP_CUBIC_FACES_1, 1, "R200_PP_CUBIC_FACES_1" },
-	{ R200_PP_CUBIC_OFFSET_F1_1, 5, "R200_PP_CUBIC_OFFSET_F1_1" },
-	{ R200_PP_CUBIC_FACES_2, 1, "R200_PP_CUBIC_FACES_2" },
-	{ R200_PP_CUBIC_OFFSET_F1_2, 5, "R200_PP_CUBIC_OFFSET_F1_2" },
-	{ R200_PP_CUBIC_FACES_3, 1, "R200_PP_CUBIC_FACES_3" },
-	{ R200_PP_CUBIC_OFFSET_F1_3, 5, "R200_PP_CUBIC_OFFSET_F1_3" },
-	{ R200_PP_CUBIC_FACES_4, 1, "R200_PP_CUBIC_FACES_4" },
-	{ R200_PP_CUBIC_OFFSET_F1_4, 5, "R200_PP_CUBIC_OFFSET_F1_4" },
-	{ R200_PP_CUBIC_FACES_5, 1, "R200_PP_CUBIC_FACES_5" },
-	{ R200_PP_CUBIC_OFFSET_F1_5, 5, "R200_PP_CUBIC_OFFSET_F1_5" },
-	{ RADEON_PP_TEX_SIZE_0, 2, "RADEON_PP_TEX_SIZE_0" },
-	{ RADEON_PP_TEX_SIZE_1, 2, "RADEON_PP_TEX_SIZE_1" },
-	{ RADEON_PP_TEX_SIZE_2, 2, "RADEON_PP_TEX_SIZE_2" },
-	{ R200_RB3D_BLENDCOLOR, 3, "R200_RB3D_BLENDCOLOR" },
-	{ R200_SE_TCL_POINT_SPRITE_CNTL, 1, "R200_SE_TCL_POINT_SPRITE_CNTL" },
-	{ RADEON_PP_CUBIC_FACES_0, 1, "RADEON_PP_CUBIC_FACES_0"},
-	{ RADEON_PP_CUBIC_OFFSET_T0_0, 5, "RADEON_PP_CUBIC_OFFSET_T0_0"},
-	{ RADEON_PP_CUBIC_FACES_1, 1, "RADEON_PP_CUBIC_FACES_1"},
-	{ RADEON_PP_CUBIC_OFFSET_T1_0, 5, "RADEON_PP_CUBIC_OFFSET_T1_0"},
-	{ RADEON_PP_CUBIC_FACES_2, 1, "RADEON_PP_CUBIC_FACES_2"},
-	{ RADEON_PP_CUBIC_OFFSET_T2_0, 5, "RADEON_PP_CUBIC_OFFSET_T2_0"},
-	{ R200_PP_TRI_PERF, 2, "R200_PP_TRI_PERF"},
+	{
+	RADEON_PP_MISC, 7, "RADEON_PP_MISC"}, {
+	RADEON_PP_CNTL, 3, "RADEON_PP_CNTL"}, {
+	RADEON_RB3D_COLORPITCH, 1, "RADEON_RB3D_COLORPITCH"}, {
+	RADEON_RE_LINE_PATTERN, 2, "RADEON_RE_LINE_PATTERN"}, {
+	RADEON_SE_LINE_WIDTH, 1, "RADEON_SE_LINE_WIDTH"}, {
+	RADEON_PP_LUM_MATRIX, 1, "RADEON_PP_LUM_MATRIX"}, {
+	RADEON_PP_ROT_MATRIX_0, 2, "RADEON_PP_ROT_MATRIX_0"}, {
+	RADEON_RB3D_STENCILREFMASK, 3, "RADEON_RB3D_STENCILREFMASK"}, {
+	RADEON_SE_VPORT_XSCALE, 6, "RADEON_SE_VPORT_XSCALE"}, {
+	RADEON_SE_CNTL, 2, "RADEON_SE_CNTL"}, {
+	RADEON_SE_CNTL_STATUS, 1, "RADEON_SE_CNTL_STATUS"}, {
+	RADEON_RE_MISC, 1, "RADEON_RE_MISC"}, {
+	RADEON_PP_TXFILTER_0, 6, "RADEON_PP_TXFILTER_0"}, {
+	RADEON_PP_BORDER_COLOR_0, 1, "RADEON_PP_BORDER_COLOR_0"}, {
+	RADEON_PP_TXFILTER_1, 6, "RADEON_PP_TXFILTER_1"}, {
+	RADEON_PP_BORDER_COLOR_1, 1, "RADEON_PP_BORDER_COLOR_1"}, {
+	RADEON_PP_TXFILTER_2, 6, "RADEON_PP_TXFILTER_2"}, {
+	RADEON_PP_BORDER_COLOR_2, 1, "RADEON_PP_BORDER_COLOR_2"}, {
+	RADEON_SE_ZBIAS_FACTOR, 2, "RADEON_SE_ZBIAS_FACTOR"}, {
+	RADEON_SE_TCL_OUTPUT_VTX_FMT, 11, "RADEON_SE_TCL_OUTPUT_VTX_FMT"}, {
+	RADEON_SE_TCL_MATERIAL_EMMISSIVE_RED, 17,
+		    "RADEON_SE_TCL_MATERIAL_EMMISSIVE_RED"}, {
+	R200_PP_TXCBLEND_0, 4, "R200_PP_TXCBLEND_0"}, {
+	R200_PP_TXCBLEND_1, 4, "R200_PP_TXCBLEND_1"}, {
+	R200_PP_TXCBLEND_2, 4, "R200_PP_TXCBLEND_2"}, {
+	R200_PP_TXCBLEND_3, 4, "R200_PP_TXCBLEND_3"}, {
+	R200_PP_TXCBLEND_4, 4, "R200_PP_TXCBLEND_4"}, {
+	R200_PP_TXCBLEND_5, 4, "R200_PP_TXCBLEND_5"}, {
+	R200_PP_TXCBLEND_6, 4, "R200_PP_TXCBLEND_6"}, {
+	R200_PP_TXCBLEND_7, 4, "R200_PP_TXCBLEND_7"}, {
+	R200_SE_TCL_LIGHT_MODEL_CTL_0, 6, "R200_SE_TCL_LIGHT_MODEL_CTL_0"},
+	{
+	R200_PP_TFACTOR_0, 6, "R200_PP_TFACTOR_0"}, {
+	R200_SE_VTX_FMT_0, 4, "R200_SE_VTX_FMT_0"}, {
+	R200_SE_VAP_CNTL, 1, "R200_SE_VAP_CNTL"}, {
+	R200_SE_TCL_MATRIX_SEL_0, 5, "R200_SE_TCL_MATRIX_SEL_0"}, {
+	R200_SE_TCL_TEX_PROC_CTL_2, 5, "R200_SE_TCL_TEX_PROC_CTL_2"}, {
+	R200_SE_TCL_UCP_VERT_BLEND_CTL, 1, "R200_SE_TCL_UCP_VERT_BLEND_CTL"},
+	{
+	R200_PP_TXFILTER_0, 6, "R200_PP_TXFILTER_0"}, {
+	R200_PP_TXFILTER_1, 6, "R200_PP_TXFILTER_1"}, {
+	R200_PP_TXFILTER_2, 6, "R200_PP_TXFILTER_2"}, {
+	R200_PP_TXFILTER_3, 6, "R200_PP_TXFILTER_3"}, {
+	R200_PP_TXFILTER_4, 6, "R200_PP_TXFILTER_4"}, {
+	R200_PP_TXFILTER_5, 6, "R200_PP_TXFILTER_5"}, {
+	R200_PP_TXOFFSET_0, 1, "R200_PP_TXOFFSET_0"}, {
+	R200_PP_TXOFFSET_1, 1, "R200_PP_TXOFFSET_1"}, {
+	R200_PP_TXOFFSET_2, 1, "R200_PP_TXOFFSET_2"}, {
+	R200_PP_TXOFFSET_3, 1, "R200_PP_TXOFFSET_3"}, {
+	R200_PP_TXOFFSET_4, 1, "R200_PP_TXOFFSET_4"}, {
+	R200_PP_TXOFFSET_5, 1, "R200_PP_TXOFFSET_5"}, {
+	R200_SE_VTE_CNTL, 1, "R200_SE_VTE_CNTL"}, {
+	R200_SE_TCL_OUTPUT_VTX_COMP_SEL, 1, "R200_SE_TCL_OUTPUT_VTX_COMP_SEL"},
+	{
+	R200_PP_TAM_DEBUG3, 1, "R200_PP_TAM_DEBUG3"}, {
+	R200_PP_CNTL_X, 1, "R200_PP_CNTL_X"}, {
+	R200_RB3D_DEPTHXY_OFFSET, 1, "R200_RB3D_DEPTHXY_OFFSET"}, {
+	R200_RE_AUX_SCISSOR_CNTL, 1, "R200_RE_AUX_SCISSOR_CNTL"}, {
+	R200_RE_SCISSOR_TL_0, 2, "R200_RE_SCISSOR_TL_0"}, {
+	R200_RE_SCISSOR_TL_1, 2, "R200_RE_SCISSOR_TL_1"}, {
+	R200_RE_SCISSOR_TL_2, 2, "R200_RE_SCISSOR_TL_2"}, {
+	R200_SE_VAP_CNTL_STATUS, 1, "R200_SE_VAP_CNTL_STATUS"}, {
+	R200_SE_VTX_STATE_CNTL, 1, "R200_SE_VTX_STATE_CNTL"}, {
+	R200_RE_POINTSIZE, 1, "R200_RE_POINTSIZE"}, {
+	R200_SE_TCL_INPUT_VTX_VECTOR_ADDR_0, 4,
+		    "R200_SE_TCL_INPUT_VTX_VECTOR_ADDR_0"}, {
+	R200_PP_CUBIC_FACES_0, 1, "R200_PP_CUBIC_FACES_0"},	/* 61 */
+	{
+	R200_PP_CUBIC_OFFSET_F1_0, 5, "R200_PP_CUBIC_OFFSET_F1_0"},	/* 62 */
+	{
+	R200_PP_CUBIC_FACES_1, 1, "R200_PP_CUBIC_FACES_1"}, {
+	R200_PP_CUBIC_OFFSET_F1_1, 5, "R200_PP_CUBIC_OFFSET_F1_1"}, {
+	R200_PP_CUBIC_FACES_2, 1, "R200_PP_CUBIC_FACES_2"}, {
+	R200_PP_CUBIC_OFFSET_F1_2, 5, "R200_PP_CUBIC_OFFSET_F1_2"}, {
+	R200_PP_CUBIC_FACES_3, 1, "R200_PP_CUBIC_FACES_3"}, {
+	R200_PP_CUBIC_OFFSET_F1_3, 5, "R200_PP_CUBIC_OFFSET_F1_3"}, {
+	R200_PP_CUBIC_FACES_4, 1, "R200_PP_CUBIC_FACES_4"}, {
+	R200_PP_CUBIC_OFFSET_F1_4, 5, "R200_PP_CUBIC_OFFSET_F1_4"}, {
+	R200_PP_CUBIC_FACES_5, 1, "R200_PP_CUBIC_FACES_5"}, {
+	R200_PP_CUBIC_OFFSET_F1_5, 5, "R200_PP_CUBIC_OFFSET_F1_5"}, {
+	RADEON_PP_TEX_SIZE_0, 2, "RADEON_PP_TEX_SIZE_0"}, {
+	RADEON_PP_TEX_SIZE_1, 2, "RADEON_PP_TEX_SIZE_1"}, {
+	RADEON_PP_TEX_SIZE_2, 2, "RADEON_PP_TEX_SIZE_2"}, {
+	R200_RB3D_BLENDCOLOR, 3, "R200_RB3D_BLENDCOLOR"}, {
+	R200_SE_TCL_POINT_SPRITE_CNTL, 1, "R200_SE_TCL_POINT_SPRITE_CNTL"},
+	{
+	RADEON_PP_CUBIC_FACES_0, 1, "RADEON_PP_CUBIC_FACES_0"}, {
+	RADEON_PP_CUBIC_OFFSET_T0_0, 5, "RADEON_PP_CUBIC_OFFSET_T0_0"}, {
+	RADEON_PP_CUBIC_FACES_1, 1, "RADEON_PP_CUBIC_FACES_1"}, {
+	RADEON_PP_CUBIC_OFFSET_T1_0, 5, "RADEON_PP_CUBIC_OFFSET_T1_0"}, {
+	RADEON_PP_CUBIC_FACES_2, 1, "RADEON_PP_CUBIC_FACES_2"}, {
+	RADEON_PP_CUBIC_OFFSET_T2_0, 5, "RADEON_PP_CUBIC_OFFSET_T2_0"}, {
+	R200_PP_TRI_PERF, 2, "R200_PP_TRI_PERF"},
 };
 
-
-
 /* ================================================================
  * Performance monitoring functions
  */
 
-static void radeon_clear_box( drm_radeon_private_t *dev_priv,
-			      int x, int y, int w, int h,
-			      int r, int g, int b )
+static void radeon_clear_box(drm_radeon_private_t * dev_priv,
+			     int x, int y, int w, int h, int r, int g, int b)
 {
 	u32 color;
 	RING_LOCALS;
@@ -586,49 +599,47 @@ static void radeon_clear_box( drm_radeon
 	x += dev_priv->sarea_priv->boxes[0].x1;
 	y += dev_priv->sarea_priv->boxes[0].y1;
 
-	switch ( dev_priv->color_fmt ) {
+	switch (dev_priv->color_fmt) {
 	case RADEON_COLOR_FORMAT_RGB565:
 		color = (((r & 0xf8) << 8) |
-			 ((g & 0xfc) << 3) |
-			 ((b & 0xf8) >> 3));
+			 ((g & 0xfc) << 3) | ((b & 0xf8) >> 3));
 		break;
 	case RADEON_COLOR_FORMAT_ARGB8888:
 	default:
-		color = (((0xff) << 24) | (r << 16) | (g <<  8) | b);
+		color = (((0xff) << 24) | (r << 16) | (g << 8) | b);
 		break;
 	}
 
-	BEGIN_RING( 4 );
-	RADEON_WAIT_UNTIL_3D_IDLE();		
-	OUT_RING( CP_PACKET0( RADEON_DP_WRITE_MASK, 0 ) );
-	OUT_RING( 0xffffffff );
+	BEGIN_RING(4);
+	RADEON_WAIT_UNTIL_3D_IDLE();
+	OUT_RING(CP_PACKET0(RADEON_DP_WRITE_MASK, 0));
+	OUT_RING(0xffffffff);
 	ADVANCE_RING();
 
-	BEGIN_RING( 6 );
+	BEGIN_RING(6);
 
-	OUT_RING( CP_PACKET3( RADEON_CNTL_PAINT_MULTI, 4 ) );
-	OUT_RING( RADEON_GMC_DST_PITCH_OFFSET_CNTL |
-		  RADEON_GMC_BRUSH_SOLID_COLOR |
-		  (dev_priv->color_fmt << 8) |
-		  RADEON_GMC_SRC_DATATYPE_COLOR |
-		  RADEON_ROP3_P |
-		  RADEON_GMC_CLR_CMP_CNTL_DIS );
-
- 	if ( dev_priv->page_flipping && dev_priv->current_page == 1 ) { 
-		OUT_RING( dev_priv->front_pitch_offset );
- 	} else {	 
-		OUT_RING( dev_priv->back_pitch_offset );
- 	} 
+	OUT_RING(CP_PACKET3(RADEON_CNTL_PAINT_MULTI, 4));
+	OUT_RING(RADEON_GMC_DST_PITCH_OFFSET_CNTL |
+		 RADEON_GMC_BRUSH_SOLID_COLOR |
+		 (dev_priv->color_fmt << 8) |
+		 RADEON_GMC_SRC_DATATYPE_COLOR |
+		 RADEON_ROP3_P | RADEON_GMC_CLR_CMP_CNTL_DIS);
+
+	if (dev_priv->page_flipping && dev_priv->current_page == 1) {
+		OUT_RING(dev_priv->front_pitch_offset);
+	} else {
+		OUT_RING(dev_priv->back_pitch_offset);
+	}
 
-	OUT_RING( color );
+	OUT_RING(color);
 
-	OUT_RING( (x << 16) | y );
-	OUT_RING( (w << 16) | h );
+	OUT_RING((x << 16) | y);
+	OUT_RING((w << 16) | h);
 
 	ADVANCE_RING();
 }
 
-static void radeon_cp_performance_boxes( drm_radeon_private_t *dev_priv )
+static void radeon_cp_performance_boxes(drm_radeon_private_t * dev_priv)
 {
 	/* Collapse various things into a wait flag -- trying to
 	 * guess if userspase slept -- better just to have them tell us.
@@ -644,50 +655,50 @@ static void radeon_cp_performance_boxes(
 
 	/* Purple box for page flipping
 	 */
-	if ( dev_priv->stats.boxes & RADEON_BOX_FLIP ) 
-		radeon_clear_box( dev_priv, 4, 4, 8, 8, 255, 0, 255 );
+	if (dev_priv->stats.boxes & RADEON_BOX_FLIP)
+		radeon_clear_box(dev_priv, 4, 4, 8, 8, 255, 0, 255);
 
 	/* Red box if we have to wait for idle at any point
 	 */
-	if ( dev_priv->stats.boxes & RADEON_BOX_WAIT_IDLE ) 
-		radeon_clear_box( dev_priv, 16, 4, 8, 8, 255, 0, 0 );
+	if (dev_priv->stats.boxes & RADEON_BOX_WAIT_IDLE)
+		radeon_clear_box(dev_priv, 16, 4, 8, 8, 255, 0, 0);
 
 	/* Blue box: lost context?
 	 */
 
 	/* Yellow box for texture swaps
 	 */
-	if ( dev_priv->stats.boxes & RADEON_BOX_TEXTURE_LOAD ) 
-		radeon_clear_box( dev_priv, 40, 4, 8, 8, 255, 255, 0 );
+	if (dev_priv->stats.boxes & RADEON_BOX_TEXTURE_LOAD)
+		radeon_clear_box(dev_priv, 40, 4, 8, 8, 255, 255, 0);
 
 	/* Green box if hardware never idles (as far as we can tell)
 	 */
-	if ( !(dev_priv->stats.boxes & RADEON_BOX_DMA_IDLE) ) 
-		radeon_clear_box( dev_priv, 64, 4, 8, 8, 0, 255, 0 );
+	if (!(dev_priv->stats.boxes & RADEON_BOX_DMA_IDLE))
+		radeon_clear_box(dev_priv, 64, 4, 8, 8, 0, 255, 0);
 
-
-	/* Draw bars indicating number of buffers allocated 
+	/* Draw bars indicating number of buffers allocated
 	 * (not a great measure, easily confused)
 	 */
 	if (dev_priv->stats.requested_bufs) {
 		if (dev_priv->stats.requested_bufs > 100)
 			dev_priv->stats.requested_bufs = 100;
 
-		radeon_clear_box( dev_priv, 4, 16,  
-				  dev_priv->stats.requested_bufs, 4,
-				  196, 128, 128 );
+		radeon_clear_box(dev_priv, 4, 16,
+				 dev_priv->stats.requested_bufs, 4,
+				 196, 128, 128);
 	}
 
-	memset( &dev_priv->stats, 0, sizeof(dev_priv->stats) );
+	memset(&dev_priv->stats, 0, sizeof(dev_priv->stats));
 
 }
+
 /* ================================================================
  * CP command dispatch functions
  */
 
-static void radeon_cp_dispatch_clear( drm_device_t *dev,
-				      drm_radeon_clear_t *clear,
-				      drm_radeon_clear_rect_t *depth_boxes )
+static void radeon_cp_dispatch_clear(drm_device_t * dev,
+				     drm_radeon_clear_t * clear,
+				     drm_radeon_clear_rect_t * depth_boxes)
 {
 	drm_radeon_private_t *dev_priv = dev->dev_private;
 	drm_radeon_sarea_t *sarea_priv = dev_priv->sarea_priv;
@@ -695,32 +706,34 @@ static void radeon_cp_dispatch_clear( dr
 	int nbox = sarea_priv->nbox;
 	drm_clip_rect_t *pbox = sarea_priv->boxes;
 	unsigned int flags = clear->flags;
-	u32 rb3d_cntl = 0, rb3d_stencilrefmask= 0;
+	u32 rb3d_cntl = 0, rb3d_stencilrefmask = 0;
 	int i;
 	RING_LOCALS;
-	DRM_DEBUG( "flags = 0x%x\n", flags );
+	DRM_DEBUG("flags = 0x%x\n", flags);
 
 	dev_priv->stats.clears++;
 
-	if ( dev_priv->page_flipping && dev_priv->current_page == 1 ) {
+	if (dev_priv->page_flipping && dev_priv->current_page == 1) {
 		unsigned int tmp = flags;
 
 		flags &= ~(RADEON_FRONT | RADEON_BACK);
-		if ( tmp & RADEON_FRONT ) flags |= RADEON_BACK;
-		if ( tmp & RADEON_BACK )  flags |= RADEON_FRONT;
+		if (tmp & RADEON_FRONT)
+			flags |= RADEON_BACK;
+		if (tmp & RADEON_BACK)
+			flags |= RADEON_FRONT;
 	}
 
-	if ( flags & (RADEON_FRONT | RADEON_BACK) ) {
+	if (flags & (RADEON_FRONT | RADEON_BACK)) {
 
-		BEGIN_RING( 4 );
+		BEGIN_RING(4);
 
 		/* Ensure the 3D stream is idle before doing a
 		 * 2D fill to clear the front or back buffer.
 		 */
 		RADEON_WAIT_UNTIL_3D_IDLE();
-		
-		OUT_RING( CP_PACKET0( RADEON_DP_WRITE_MASK, 0 ) );
-		OUT_RING( clear->color_mask );
+
+		OUT_RING(CP_PACKET0(RADEON_DP_WRITE_MASK, 0));
+		OUT_RING(clear->color_mask);
 
 		ADVANCE_RING();
 
@@ -728,57 +741,61 @@ static void radeon_cp_dispatch_clear( dr
 		 */
 		dev_priv->sarea_priv->ctx_owner = 0;
 
-		for ( i = 0 ; i < nbox ; i++ ) {
+		for (i = 0; i < nbox; i++) {
 			int x = pbox[i].x1;
 			int y = pbox[i].y1;
 			int w = pbox[i].x2 - x;
 			int h = pbox[i].y2 - y;
 
-			DRM_DEBUG( "dispatch clear %d,%d-%d,%d flags 0x%x\n",
-				   x, y, w, h, flags );
+			DRM_DEBUG("dispatch clear %d,%d-%d,%d flags 0x%x\n",
+				  x, y, w, h, flags);
+
+			if (flags & RADEON_FRONT) {
+				BEGIN_RING(6);
+
+				OUT_RING(CP_PACKET3
+					 (RADEON_CNTL_PAINT_MULTI, 4));
+				OUT_RING(RADEON_GMC_DST_PITCH_OFFSET_CNTL |
+					 RADEON_GMC_BRUSH_SOLID_COLOR |
+					 (dev_priv->
+					  color_fmt << 8) |
+					 RADEON_GMC_SRC_DATATYPE_COLOR |
+					 RADEON_ROP3_P |
+					 RADEON_GMC_CLR_CMP_CNTL_DIS);
+
+				OUT_RING(dev_priv->front_pitch_offset);
+				OUT_RING(clear->clear_color);
+
+				OUT_RING((x << 16) | y);
+				OUT_RING((w << 16) | h);
 
-			if ( flags & RADEON_FRONT ) {
-				BEGIN_RING( 6 );
-				
-				OUT_RING( CP_PACKET3( RADEON_CNTL_PAINT_MULTI, 4 ) );
-				OUT_RING( RADEON_GMC_DST_PITCH_OFFSET_CNTL |
-					  RADEON_GMC_BRUSH_SOLID_COLOR |
-					  (dev_priv->color_fmt << 8) |
-					  RADEON_GMC_SRC_DATATYPE_COLOR |
-					  RADEON_ROP3_P |
-					  RADEON_GMC_CLR_CMP_CNTL_DIS );
-
-				OUT_RING( dev_priv->front_pitch_offset );
-				OUT_RING( clear->clear_color );
-				
-				OUT_RING( (x << 16) | y );
-				OUT_RING( (w << 16) | h );
-				
 				ADVANCE_RING();
 			}
-			
-			if ( flags & RADEON_BACK ) {
-				BEGIN_RING( 6 );
-				
-				OUT_RING( CP_PACKET3( RADEON_CNTL_PAINT_MULTI, 4 ) );
-				OUT_RING( RADEON_GMC_DST_PITCH_OFFSET_CNTL |
-					  RADEON_GMC_BRUSH_SOLID_COLOR |
-					  (dev_priv->color_fmt << 8) |
-					  RADEON_GMC_SRC_DATATYPE_COLOR |
-					  RADEON_ROP3_P |
-					  RADEON_GMC_CLR_CMP_CNTL_DIS );
-				
-				OUT_RING( dev_priv->back_pitch_offset );
-				OUT_RING( clear->clear_color );
 
-				OUT_RING( (x << 16) | y );
-				OUT_RING( (w << 16) | h );
+			if (flags & RADEON_BACK) {
+				BEGIN_RING(6);
+
+				OUT_RING(CP_PACKET3
+					 (RADEON_CNTL_PAINT_MULTI, 4));
+				OUT_RING(RADEON_GMC_DST_PITCH_OFFSET_CNTL |
+					 RADEON_GMC_BRUSH_SOLID_COLOR |
+					 (dev_priv->
+					  color_fmt << 8) |
+					 RADEON_GMC_SRC_DATATYPE_COLOR |
+					 RADEON_ROP3_P |
+					 RADEON_GMC_CLR_CMP_CNTL_DIS);
+
+				OUT_RING(dev_priv->back_pitch_offset);
+				OUT_RING(clear->clear_color);
+
+				OUT_RING((x << 16) | y);
+				OUT_RING((w << 16) | h);
 
 				ADVANCE_RING();
 			}
 		}
 	}
-	
+
 	/* hyper z clear */
 	/* no docs available, based on reverse engeneering by Stephane Marchesin */
 	if ((flags & (RADEON_DEPTH | RADEON_STENCIL)) && (flags & RADEON_CLEAR_FASTZ)) {
@@ -930,8 +947,8 @@ static void radeon_cp_dispatch_clear( dr
 	 * rendering a quad into just those buffers.  Thus, we have to
 	 * make sure the 3D engine is configured correctly.
 	 */
-	if ((dev_priv->microcode_version == UCODE_R200) &&
-	    (flags & (RADEON_DEPTH | RADEON_STENCIL))) {
+	else if ((dev_priv->microcode_version == UCODE_R200) &&
+		(flags & (RADEON_DEPTH | RADEON_STENCIL))) {
 
 		int tempPP_CNTL;
 		int tempRE_CNTL;
@@ -956,30 +973,27 @@ static void radeon_cp_dispatch_clear( dr
 
 		tempSE_CNTL = depth_clear->se_cntl;
 
-
-
 		/* Disable TCL */
 
-		tempSE_VAP_CNTL = (/* SE_VAP_CNTL__FORCE_W_TO_ONE_MASK |  */
-				   (0x9 << SE_VAP_CNTL__VF_MAX_VTX_NUM__SHIFT));
+		tempSE_VAP_CNTL = (	/* SE_VAP_CNTL__FORCE_W_TO_ONE_MASK |  */
+					  (0x9 <<
+					   SE_VAP_CNTL__VF_MAX_VTX_NUM__SHIFT));
 
 		tempRB3D_PLANEMASK = 0x0;
 
 		tempRE_AUX_SCISSOR_CNTL = 0x0;
 
 		tempSE_VTE_CNTL =
-			SE_VTE_CNTL__VTX_XY_FMT_MASK |
-			SE_VTE_CNTL__VTX_Z_FMT_MASK;
+		    SE_VTE_CNTL__VTX_XY_FMT_MASK | SE_VTE_CNTL__VTX_Z_FMT_MASK;
 
-		/* Vertex format (X, Y, Z, W)*/
+		/* Vertex format (X, Y, Z, W) */
 		tempSE_VTX_FMT_0 =
-			SE_VTX_FMT_0__VTX_Z0_PRESENT_MASK |
-			SE_VTX_FMT_0__VTX_W0_PRESENT_MASK;
+		    SE_VTX_FMT_0__VTX_Z0_PRESENT_MASK |
+		    SE_VTX_FMT_0__VTX_W0_PRESENT_MASK;
 		tempSE_VTX_FMT_1 = 0x0;
 
-
-		/* 
-		 * Depth buffer specific enables 
+		/*
+		 * Depth buffer specific enables
 		 */
 		if (flags & RADEON_DEPTH) {
 			/* Enable depth buffer */
@@ -989,12 +1003,12 @@ static void radeon_cp_dispatch_clear( dr
 			tempRB3D_CNTL &= ~RADEON_Z_ENABLE;
 		}
 
-		/* 
+		/*
 		 * Stencil buffer specific enables
 		 */
-		if ( flags & RADEON_STENCIL ) {
-			tempRB3D_CNTL |=  RADEON_STENCIL_ENABLE;
-			tempRB3D_STENCILREFMASK = clear->depth_mask; 
+		if (flags & RADEON_STENCIL) {
+			tempRB3D_CNTL |= RADEON_STENCIL_ENABLE;
+			tempRB3D_STENCILREFMASK = clear->depth_mask;
 		} else {
 			tempRB3D_CNTL &= ~RADEON_STENCIL_ENABLE;
 			tempRB3D_STENCILREFMASK = 0x00000000;
@@ -1008,73 +1022,69 @@ static void radeon_cp_dispatch_clear( dr
 			tempRB3D_ZSTENCILCNTL |= RADEON_Z_HIERARCHY_ENABLE;
 		}
 
-		BEGIN_RING( 26 );
+		BEGIN_RING(26);
 		RADEON_WAIT_UNTIL_2D_IDLE();
 
-		OUT_RING_REG( RADEON_PP_CNTL, tempPP_CNTL );
-		OUT_RING_REG( R200_RE_CNTL, tempRE_CNTL );
-		OUT_RING_REG( RADEON_RB3D_CNTL, tempRB3D_CNTL );
-		OUT_RING_REG( RADEON_RB3D_ZSTENCILCNTL,
-			      tempRB3D_ZSTENCILCNTL );
-		OUT_RING_REG( RADEON_RB3D_STENCILREFMASK, 
-			      tempRB3D_STENCILREFMASK );
-		OUT_RING_REG( RADEON_RB3D_PLANEMASK, tempRB3D_PLANEMASK );
-		OUT_RING_REG( RADEON_SE_CNTL, tempSE_CNTL );
-		OUT_RING_REG( R200_SE_VTE_CNTL, tempSE_VTE_CNTL );
-		OUT_RING_REG( R200_SE_VTX_FMT_0, tempSE_VTX_FMT_0 );
-		OUT_RING_REG( R200_SE_VTX_FMT_1, tempSE_VTX_FMT_1 );
-		OUT_RING_REG( R200_SE_VAP_CNTL, tempSE_VAP_CNTL );
-		OUT_RING_REG( R200_RE_AUX_SCISSOR_CNTL, 
-			      tempRE_AUX_SCISSOR_CNTL );
+		OUT_RING_REG(RADEON_PP_CNTL, tempPP_CNTL);
+		OUT_RING_REG(R200_RE_CNTL, tempRE_CNTL);
+		OUT_RING_REG(RADEON_RB3D_CNTL, tempRB3D_CNTL);
+		OUT_RING_REG(RADEON_RB3D_ZSTENCILCNTL, tempRB3D_ZSTENCILCNTL);
+		OUT_RING_REG(RADEON_RB3D_STENCILREFMASK,
+			     tempRB3D_STENCILREFMASK);
+		OUT_RING_REG(RADEON_RB3D_PLANEMASK, tempRB3D_PLANEMASK);
+		OUT_RING_REG(RADEON_SE_CNTL, tempSE_CNTL);
+		OUT_RING_REG(R200_SE_VTE_CNTL, tempSE_VTE_CNTL);
+		OUT_RING_REG(R200_SE_VTX_FMT_0, tempSE_VTX_FMT_0);
+		OUT_RING_REG(R200_SE_VTX_FMT_1, tempSE_VTX_FMT_1);
+		OUT_RING_REG(R200_SE_VAP_CNTL, tempSE_VAP_CNTL);
+		OUT_RING_REG(R200_RE_AUX_SCISSOR_CNTL, tempRE_AUX_SCISSOR_CNTL);
 		ADVANCE_RING();
 
 		/* Make sure we restore the 3D state next time.
 		 */
 		dev_priv->sarea_priv->ctx_owner = 0;
 
-		for ( i = 0 ; i < nbox ; i++ ) {
-			
-			/* Funny that this should be required -- 
+		for (i = 0; i < nbox; i++) {
+
+			/* Funny that this should be required --
 			 *  sets top-left?
 			 */
-			radeon_emit_clip_rect( dev_priv,
-					       &sarea_priv->boxes[i] );
+			radeon_emit_clip_rect(dev_priv, &sarea_priv->boxes[i]);
 
-			BEGIN_RING( 14 );
-			OUT_RING( CP_PACKET3( R200_3D_DRAW_IMMD_2, 12 ) );
-			OUT_RING( (RADEON_PRIM_TYPE_RECT_LIST |
-				   RADEON_PRIM_WALK_RING |
-				   (3 << RADEON_NUM_VERTICES_SHIFT)) );
-			OUT_RING( depth_boxes[i].ui[CLEAR_X1] );
-			OUT_RING( depth_boxes[i].ui[CLEAR_Y1] );
-			OUT_RING( depth_boxes[i].ui[CLEAR_DEPTH] );
-			OUT_RING( 0x3f800000 );
-			OUT_RING( depth_boxes[i].ui[CLEAR_X1] );
-			OUT_RING( depth_boxes[i].ui[CLEAR_Y2] );
-			OUT_RING( depth_boxes[i].ui[CLEAR_DEPTH] );
-			OUT_RING( 0x3f800000 );
-			OUT_RING( depth_boxes[i].ui[CLEAR_X2] );
-			OUT_RING( depth_boxes[i].ui[CLEAR_Y2] );
-			OUT_RING( depth_boxes[i].ui[CLEAR_DEPTH] );
-			OUT_RING( 0x3f800000 );
+			BEGIN_RING(14);
+			OUT_RING(CP_PACKET3(R200_3D_DRAW_IMMD_2, 12));
+			OUT_RING((RADEON_PRIM_TYPE_RECT_LIST |
+				  RADEON_PRIM_WALK_RING |
+				  (3 << RADEON_NUM_VERTICES_SHIFT)));
+			OUT_RING(depth_boxes[i].ui[CLEAR_X1]);
+			OUT_RING(depth_boxes[i].ui[CLEAR_Y1]);
+			OUT_RING(depth_boxes[i].ui[CLEAR_DEPTH]);
+			OUT_RING(0x3f800000);
+			OUT_RING(depth_boxes[i].ui[CLEAR_X1]);
+			OUT_RING(depth_boxes[i].ui[CLEAR_Y2]);
+			OUT_RING(depth_boxes[i].ui[CLEAR_DEPTH]);
+			OUT_RING(0x3f800000);
+			OUT_RING(depth_boxes[i].ui[CLEAR_X2]);
+			OUT_RING(depth_boxes[i].ui[CLEAR_Y2]);
+			OUT_RING(depth_boxes[i].ui[CLEAR_DEPTH]);
+			OUT_RING(0x3f800000);
 			ADVANCE_RING();
 		}
-	} 
-	else if ( (flags & (RADEON_DEPTH | RADEON_STENCIL)) ) {
+	} else if ((flags & (RADEON_DEPTH | RADEON_STENCIL))) {
 
 		int tempRB3D_ZSTENCILCNTL = depth_clear->rb3d_zstencilcntl;
-
+		
 		rb3d_cntl = depth_clear->rb3d_cntl;
 
-		if ( flags & RADEON_DEPTH ) {
-			rb3d_cntl |=  RADEON_Z_ENABLE;
+		if (flags & RADEON_DEPTH) {
+			rb3d_cntl |= RADEON_Z_ENABLE;
 		} else {
 			rb3d_cntl &= ~RADEON_Z_ENABLE;
 		}
 
-		if ( flags & RADEON_STENCIL ) {
-			rb3d_cntl |=  RADEON_STENCIL_ENABLE;
-			rb3d_stencilrefmask = clear->depth_mask; /* misnamed field */
+		if (flags & RADEON_STENCIL) {
+			rb3d_cntl |= RADEON_STENCIL_ENABLE;
+			rb3d_stencilrefmask = clear->depth_mask;	/* misnamed field */
 		} else {
 			rb3d_cntl &= ~RADEON_STENCIL_ENABLE;
 			rb3d_stencilrefmask = 0x00000000;
@@ -1088,60 +1098,55 @@ static void radeon_cp_dispatch_clear( dr
 			tempRB3D_ZSTENCILCNTL |= RADEON_Z_HIERARCHY_ENABLE;
 		}
 
-		BEGIN_RING( 13 );
+		BEGIN_RING(13);
 		RADEON_WAIT_UNTIL_2D_IDLE();
 
-		OUT_RING( CP_PACKET0( RADEON_PP_CNTL, 1 ) );
-		OUT_RING( 0x00000000 );
-		OUT_RING( rb3d_cntl );
-		
-		OUT_RING_REG( RADEON_RB3D_ZSTENCILCNTL, tempRB3D_ZSTENCILCNTL );
-		OUT_RING_REG( RADEON_RB3D_STENCILREFMASK,
-			      rb3d_stencilrefmask );
-		OUT_RING_REG( RADEON_RB3D_PLANEMASK,
-			      0x00000000 );
-		OUT_RING_REG( RADEON_SE_CNTL,
-			      depth_clear->se_cntl );
+		OUT_RING(CP_PACKET0(RADEON_PP_CNTL, 1));
+		OUT_RING(0x00000000);
+		OUT_RING(rb3d_cntl);
+
+		OUT_RING_REG(RADEON_RB3D_ZSTENCILCNTL, tempRB3D_ZSTENCILCNTL);
+		OUT_RING_REG(RADEON_RB3D_STENCILREFMASK, rb3d_stencilrefmask);
+		OUT_RING_REG(RADEON_RB3D_PLANEMASK, 0x00000000);
+		OUT_RING_REG(RADEON_SE_CNTL, depth_clear->se_cntl);
 		ADVANCE_RING();
 
 		/* Make sure we restore the 3D state next time.
 		 */
 		dev_priv->sarea_priv->ctx_owner = 0;
 
-		for ( i = 0 ; i < nbox ; i++ ) {
-			
-			/* Funny that this should be required -- 
+		for (i = 0; i < nbox; i++) {
+
+			/* Funny that this should be required --
 			 *  sets top-left?
 			 */
-			radeon_emit_clip_rect( dev_priv,
-					       &sarea_priv->boxes[i] );
+			radeon_emit_clip_rect(dev_priv, &sarea_priv->boxes[i]);
 
-			BEGIN_RING( 15 );
+			BEGIN_RING(15);
 
-			OUT_RING( CP_PACKET3( RADEON_3D_DRAW_IMMD, 13 ) );
-			OUT_RING( RADEON_VTX_Z_PRESENT |
-				  RADEON_VTX_PKCOLOR_PRESENT);
-			OUT_RING( (RADEON_PRIM_TYPE_RECT_LIST |
-				   RADEON_PRIM_WALK_RING |
-				   RADEON_MAOS_ENABLE |
-				   RADEON_VTX_FMT_RADEON_MODE |
-				   (3 << RADEON_NUM_VERTICES_SHIFT)) );
-
-
-			OUT_RING( depth_boxes[i].ui[CLEAR_X1] );
-			OUT_RING( depth_boxes[i].ui[CLEAR_Y1] );
-			OUT_RING( depth_boxes[i].ui[CLEAR_DEPTH] );
-			OUT_RING( 0x0 );
-
-			OUT_RING( depth_boxes[i].ui[CLEAR_X1] );
-			OUT_RING( depth_boxes[i].ui[CLEAR_Y2] );
-			OUT_RING( depth_boxes[i].ui[CLEAR_DEPTH] );
-			OUT_RING( 0x0 );
-
-			OUT_RING( depth_boxes[i].ui[CLEAR_X2] );
-			OUT_RING( depth_boxes[i].ui[CLEAR_Y2] );
-			OUT_RING( depth_boxes[i].ui[CLEAR_DEPTH] );
-			OUT_RING( 0x0 );
+			OUT_RING(CP_PACKET3(RADEON_3D_DRAW_IMMD, 13));
+			OUT_RING(RADEON_VTX_Z_PRESENT |
+				 RADEON_VTX_PKCOLOR_PRESENT);
+			OUT_RING((RADEON_PRIM_TYPE_RECT_LIST |
+				  RADEON_PRIM_WALK_RING |
+				  RADEON_MAOS_ENABLE |
+				  RADEON_VTX_FMT_RADEON_MODE |
+				  (3 << RADEON_NUM_VERTICES_SHIFT)));
+
+			OUT_RING(depth_boxes[i].ui[CLEAR_X1]);
+			OUT_RING(depth_boxes[i].ui[CLEAR_Y1]);
+			OUT_RING(depth_boxes[i].ui[CLEAR_DEPTH]);
+			OUT_RING(0x0);
+
+			OUT_RING(depth_boxes[i].ui[CLEAR_X1]);
+			OUT_RING(depth_boxes[i].ui[CLEAR_Y2]);
+			OUT_RING(depth_boxes[i].ui[CLEAR_DEPTH]);
+			OUT_RING(0x0);
+
+			OUT_RING(depth_boxes[i].ui[CLEAR_X2]);
+			OUT_RING(depth_boxes[i].ui[CLEAR_Y2]);
+			OUT_RING(depth_boxes[i].ui[CLEAR_DEPTH]);
+			OUT_RING(0x0);
 
 			ADVANCE_RING();
 		}
@@ -1153,15 +1158,15 @@ static void radeon_cp_dispatch_clear( dr
 	 */
 	dev_priv->sarea_priv->last_clear++;
 
-	BEGIN_RING( 4 );
+	BEGIN_RING(4);
 
-	RADEON_CLEAR_AGE( dev_priv->sarea_priv->last_clear );
+	RADEON_CLEAR_AGE(dev_priv->sarea_priv->last_clear);
 	RADEON_WAIT_UNTIL_IDLE();
 
 	ADVANCE_RING();
 }
 
-static void radeon_cp_dispatch_swap( drm_device_t *dev )
+static void radeon_cp_dispatch_swap(drm_device_t * dev)
 {
 	drm_radeon_private_t *dev_priv = dev->dev_private;
 	drm_radeon_sarea_t *sarea_priv = dev_priv->sarea_priv;
@@ -1169,59 +1174,55 @@ static void radeon_cp_dispatch_swap( drm
 	drm_clip_rect_t *pbox = sarea_priv->boxes;
 	int i;
 	RING_LOCALS;
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
 	/* Do some trivial performance monitoring...
 	 */
 	if (dev_priv->do_boxes)
-		radeon_cp_performance_boxes( dev_priv );
-
+		radeon_cp_performance_boxes(dev_priv);
 
 	/* Wait for the 3D stream to idle before dispatching the bitblt.
 	 * This will prevent data corruption between the two streams.
 	 */
-	BEGIN_RING( 2 );
+	BEGIN_RING(2);
 
 	RADEON_WAIT_UNTIL_3D_IDLE();
 
 	ADVANCE_RING();
 
-	for ( i = 0 ; i < nbox ; i++ ) {
+	for (i = 0; i < nbox; i++) {
 		int x = pbox[i].x1;
 		int y = pbox[i].y1;
 		int w = pbox[i].x2 - x;
 		int h = pbox[i].y2 - y;
 
-		DRM_DEBUG( "dispatch swap %d,%d-%d,%d\n",
-			   x, y, w, h );
+		DRM_DEBUG("dispatch swap %d,%d-%d,%d\n", x, y, w, h);
 
-		BEGIN_RING( 7 );
+		BEGIN_RING(7);
+
+		OUT_RING(CP_PACKET3(RADEON_CNTL_BITBLT_MULTI, 5));
+		OUT_RING(RADEON_GMC_SRC_PITCH_OFFSET_CNTL |
+			 RADEON_GMC_DST_PITCH_OFFSET_CNTL |
+			 RADEON_GMC_BRUSH_NONE |
+			 (dev_priv->color_fmt << 8) |
+			 RADEON_GMC_SRC_DATATYPE_COLOR |
+			 RADEON_ROP3_S |
+			 RADEON_DP_SRC_SOURCE_MEMORY |
+			 RADEON_GMC_CLR_CMP_CNTL_DIS | RADEON_GMC_WR_MSK_DIS);
 
-		OUT_RING( CP_PACKET3( RADEON_CNTL_BITBLT_MULTI, 5 ) );
-		OUT_RING( RADEON_GMC_SRC_PITCH_OFFSET_CNTL |
-			  RADEON_GMC_DST_PITCH_OFFSET_CNTL |
-			  RADEON_GMC_BRUSH_NONE |
-			  (dev_priv->color_fmt << 8) |
-			  RADEON_GMC_SRC_DATATYPE_COLOR |
-			  RADEON_ROP3_S |
-			  RADEON_DP_SRC_SOURCE_MEMORY |
-			  RADEON_GMC_CLR_CMP_CNTL_DIS |
-			  RADEON_GMC_WR_MSK_DIS );
-		
 		/* Make this work even if front & back are flipped:
 		 */
 		if (dev_priv->current_page == 0) {
-			OUT_RING( dev_priv->back_pitch_offset );
-			OUT_RING( dev_priv->front_pitch_offset );
-		} 
-		else {
-			OUT_RING( dev_priv->front_pitch_offset );
-			OUT_RING( dev_priv->back_pitch_offset );
+			OUT_RING(dev_priv->back_pitch_offset);
+			OUT_RING(dev_priv->front_pitch_offset);
+		} else {
+			OUT_RING(dev_priv->front_pitch_offset);
+			OUT_RING(dev_priv->back_pitch_offset);
 		}
 
-		OUT_RING( (x << 16) | y );
-		OUT_RING( (x << 16) | y );
-		OUT_RING( (w << 16) | h );
+		OUT_RING((x << 16) | y);
+		OUT_RING((x << 16) | y);
+		OUT_RING((w << 16) | h);
 
 		ADVANCE_RING();
 	}
@@ -1232,44 +1233,43 @@ static void radeon_cp_dispatch_swap( drm
 	 */
 	dev_priv->sarea_priv->last_frame++;
 
-	BEGIN_RING( 4 );
+	BEGIN_RING(4);
 
-	RADEON_FRAME_AGE( dev_priv->sarea_priv->last_frame );
+	RADEON_FRAME_AGE(dev_priv->sarea_priv->last_frame);
 	RADEON_WAIT_UNTIL_2D_IDLE();
 
 	ADVANCE_RING();
 }
 
-static void radeon_cp_dispatch_flip( drm_device_t *dev )
+static void radeon_cp_dispatch_flip(drm_device_t * dev)
 {
 	drm_radeon_private_t *dev_priv = dev->dev_private;
-	drm_sarea_t *sarea = (drm_sarea_t *)dev_priv->sarea->handle;
+	drm_sarea_t *sarea = (drm_sarea_t *) dev_priv->sarea->handle;
 	int offset = (dev_priv->current_page == 1)
-		   ? dev_priv->front_offset : dev_priv->back_offset;
+	    ? dev_priv->front_offset : dev_priv->back_offset;
 	RING_LOCALS;
-	DRM_DEBUG( "%s: page=%d pfCurrentPage=%d\n", 
-		__FUNCTION__, 
-		dev_priv->current_page,
-		dev_priv->sarea_priv->pfCurrentPage);
+	DRM_DEBUG("%s: page=%d pfCurrentPage=%d\n",
+		  __FUNCTION__,
+		  dev_priv->current_page, dev_priv->sarea_priv->pfCurrentPage);
 
 	/* Do some trivial performance monitoring...
 	 */
 	if (dev_priv->do_boxes) {
 		dev_priv->stats.boxes |= RADEON_BOX_FLIP;
-		radeon_cp_performance_boxes( dev_priv );
+		radeon_cp_performance_boxes(dev_priv);
 	}
 
 	/* Update the frame offsets for both CRTCs
 	 */
-	BEGIN_RING( 6 );
+	BEGIN_RING(6);
 
 	RADEON_WAIT_UNTIL_3D_IDLE();
-	OUT_RING_REG( RADEON_CRTC_OFFSET, ( ( sarea->frame.y * dev_priv->front_pitch
-					      + sarea->frame.x 
-					      * ( dev_priv->color_fmt - 2 ) ) & ~7 )
-					  + offset );
-	OUT_RING_REG( RADEON_CRTC2_OFFSET, dev_priv->sarea_priv->crtc2_base
-					   + offset );
+	OUT_RING_REG(RADEON_CRTC_OFFSET,
+		     ((sarea->frame.y * dev_priv->front_pitch +
+		       sarea->frame.x * (dev_priv->color_fmt - 2)) & ~7)
+		     + offset);
+	OUT_RING_REG(RADEON_CRTC2_OFFSET, dev_priv->sarea_priv->crtc2_base
+		     + offset);
 
 	ADVANCE_RING();
 
@@ -1279,16 +1279,16 @@ static void radeon_cp_dispatch_flip( drm
 	 */
 	dev_priv->sarea_priv->last_frame++;
 	dev_priv->sarea_priv->pfCurrentPage = dev_priv->current_page =
-					      1 - dev_priv->current_page;
+	    1 - dev_priv->current_page;
 
-	BEGIN_RING( 2 );
+	BEGIN_RING(2);
 
-	RADEON_FRAME_AGE( dev_priv->sarea_priv->last_frame );
+	RADEON_FRAME_AGE(dev_priv->sarea_priv->last_frame);
 
 	ADVANCE_RING();
 }
 
-static int bad_prim_vertex_nr( int primitive, int nr )
+static int bad_prim_vertex_nr(int primitive, int nr)
 {
 	switch (primitive & RADEON_PRIM_TYPE_MASK) {
 	case RADEON_PRIM_TYPE_NONE:
@@ -1308,24 +1308,21 @@ static int bad_prim_vertex_nr( int primi
 		return nr < 3;
 	default:
 		return 1;
-	}	
+	}
 }
 
-
-
 typedef struct {
 	unsigned int start;
 	unsigned int finish;
 	unsigned int prim;
 	unsigned int numverts;
-	unsigned int offset;   
-        unsigned int vc_format;
+	unsigned int offset;
+	unsigned int vc_format;
 } drm_radeon_tcl_prim_t;
 
-static void radeon_cp_dispatch_vertex( drm_device_t *dev,
-				       drm_buf_t *buf,
-				       drm_radeon_tcl_prim_t *prim )
-
+static void radeon_cp_dispatch_vertex(drm_device_t * dev,
+				      drm_buf_t * buf,
+				      drm_radeon_tcl_prim_t * prim)
 {
 	drm_radeon_private_t *dev_priv = dev->dev_private;
 	drm_radeon_sarea_t *sarea_priv = dev_priv->sarea_priv;
@@ -1337,45 +1334,39 @@ static void radeon_cp_dispatch_vertex( d
 
 	DRM_DEBUG("hwprim 0x%x vfmt 0x%x %d..%d %d verts\n",
 		  prim->prim,
-		  prim->vc_format,
-		  prim->start,
-		  prim->finish,
-		  prim->numverts);
-
-	if (bad_prim_vertex_nr( prim->prim, prim->numverts )) {
-		DRM_ERROR( "bad prim %x numverts %d\n", 
-			   prim->prim, prim->numverts );
+		  prim->vc_format, prim->start, prim->finish, prim->numverts);
+
+	if (bad_prim_vertex_nr(prim->prim, prim->numverts)) {
+		DRM_ERROR("bad prim %x numverts %d\n",
+			  prim->prim, prim->numverts);
 		return;
 	}
 
 	do {
 		/* Emit the next cliprect */
-		if ( i < nbox ) {
-			radeon_emit_clip_rect( dev_priv, 
-					       &sarea_priv->boxes[i] );
+		if (i < nbox) {
+			radeon_emit_clip_rect(dev_priv, &sarea_priv->boxes[i]);
 		}
 
 		/* Emit the vertex buffer rendering commands */
-		BEGIN_RING( 5 );
+		BEGIN_RING(5);
 
-		OUT_RING( CP_PACKET3( RADEON_3D_RNDR_GEN_INDX_PRIM, 3 ) );
-		OUT_RING( offset );
-		OUT_RING( numverts );
-		OUT_RING( prim->vc_format );
-		OUT_RING( prim->prim | RADEON_PRIM_WALK_LIST |
-			  RADEON_COLOR_ORDER_RGBA |
-			  RADEON_VTX_FMT_RADEON_MODE |
-			  (numverts << RADEON_NUM_VERTICES_SHIFT) );
+		OUT_RING(CP_PACKET3(RADEON_3D_RNDR_GEN_INDX_PRIM, 3));
+		OUT_RING(offset);
+		OUT_RING(numverts);
+		OUT_RING(prim->vc_format);
+		OUT_RING(prim->prim | RADEON_PRIM_WALK_LIST |
+			 RADEON_COLOR_ORDER_RGBA |
+			 RADEON_VTX_FMT_RADEON_MODE |
+			 (numverts << RADEON_NUM_VERTICES_SHIFT));
 
 		ADVANCE_RING();
 
 		i++;
-	} while ( i < nbox );
+	} while (i < nbox);
 }
 
-
-
-static void radeon_cp_discard_buffer( drm_device_t *dev, drm_buf_t *buf )
+static void radeon_cp_discard_buffer(drm_device_t * dev, drm_buf_t * buf)
 {
 	drm_radeon_private_t *dev_priv = dev->dev_private;
 	drm_radeon_buf_priv_t *buf_priv = buf->dev_private;
@@ -1384,24 +1375,22 @@ static void radeon_cp_discard_buffer( dr
 	buf_priv->age = ++dev_priv->sarea_priv->last_dispatch;
 
 	/* Emit the vertex buffer age */
-	BEGIN_RING( 2 );
-	RADEON_DISPATCH_AGE( buf_priv->age );
+	BEGIN_RING(2);
+	RADEON_DISPATCH_AGE(buf_priv->age);
 	ADVANCE_RING();
 
 	buf->pending = 1;
 	buf->used = 0;
 }
 
-static void radeon_cp_dispatch_indirect( drm_device_t *dev,
-					 drm_buf_t *buf,
-					 int start, int end )
+static void radeon_cp_dispatch_indirect(drm_device_t * dev,
+					drm_buf_t * buf, int start, int end)
 {
 	drm_radeon_private_t *dev_priv = dev->dev_private;
 	RING_LOCALS;
-	DRM_DEBUG( "indirect: buf=%d s=0x%x e=0x%x\n",
-		   buf->idx, start, end );
+	DRM_DEBUG("indirect: buf=%d s=0x%x e=0x%x\n", buf->idx, start, end);
 
-	if ( start != end ) {
+	if (start != end) {
 		int offset = (dev_priv->gart_buffers_offset
 			      + buf->offset + start);
 		int dwords = (end - start + 3) / sizeof(u32);
@@ -1410,28 +1399,27 @@ static void radeon_cp_dispatch_indirect(
 		 * dwords, so if we've been given an odd number we must
 		 * pad the data with a Type-2 CP packet.
 		 */
-		if ( dwords & 1 ) {
+		if (dwords & 1) {
 			u32 *data = (u32 *)
-				((char *)dev->agp_buffer_map->handle
-				 + buf->offset + start);
+			    ((char *)dev->agp_buffer_map->handle
+			     + buf->offset + start);
 			data[dwords++] = RADEON_CP_PACKET2;
 		}
 
 		/* Fire off the indirect buffer */
-		BEGIN_RING( 3 );
+		BEGIN_RING(3);
 
-		OUT_RING( CP_PACKET0( RADEON_CP_IB_BASE, 1 ) );
-		OUT_RING( offset );
-		OUT_RING( dwords );
+		OUT_RING(CP_PACKET0(RADEON_CP_IB_BASE, 1));
+		OUT_RING(offset);
+		OUT_RING(dwords);
 
 		ADVANCE_RING();
 	}
 }
 
-
-static void radeon_cp_dispatch_indices( drm_device_t *dev,
-					drm_buf_t *elt_buf,
-					drm_radeon_tcl_prim_t *prim )
+static void radeon_cp_dispatch_indices(drm_device_t * dev,
+				       drm_buf_t * elt_buf,
+				       drm_radeon_tcl_prim_t * prim)
 {
 	drm_radeon_private_t *dev_priv = dev->dev_private;
 	drm_radeon_sarea_t *sarea_priv = dev_priv->sarea_priv;
@@ -1446,30 +1434,24 @@ static void radeon_cp_dispatch_indices( 
 	DRM_DEBUG("hwprim 0x%x vfmt 0x%x %d..%d offset: %x nr %d\n",
 		  prim->prim,
 		  prim->vc_format,
-		  prim->start,
-		  prim->finish,
-		  prim->offset,
-		  prim->numverts);
-
-	if (bad_prim_vertex_nr( prim->prim, count )) {
-		DRM_ERROR( "bad prim %x count %d\n", 
-			   prim->prim, count );
+		  prim->start, prim->finish, prim->offset, prim->numverts);
+
+	if (bad_prim_vertex_nr(prim->prim, count)) {
+		DRM_ERROR("bad prim %x count %d\n", prim->prim, count);
 		return;
 	}
 
-
-	if ( start >= prim->finish ||
-	     (prim->start & 0x7) ) {
-		DRM_ERROR( "buffer prim %d\n", prim->prim );
+	if (start >= prim->finish || (prim->start & 0x7)) {
+		DRM_ERROR("buffer prim %d\n", prim->prim);
 		return;
 	}
 
 	dwords = (prim->finish - prim->start + 3) / sizeof(u32);
 
-	data = (u32 *)((char *)dev->agp_buffer_map->handle +
-		       elt_buf->offset + prim->start);
+	data = (u32 *) ((char *)dev->agp_buffer_map->handle +
+			elt_buf->offset + prim->start);
 
-	data[0] = CP_PACKET3( RADEON_3D_RNDR_GEN_INDX_PRIM, dwords-2 );
+	data[0] = CP_PACKET3(RADEON_3D_RNDR_GEN_INDX_PRIM, dwords - 2);
 	data[1] = offset;
 	data[2] = prim->numverts;
 	data[3] = prim->vc_format;
@@ -1477,28 +1459,26 @@ static void radeon_cp_dispatch_indices( 
 		   RADEON_PRIM_WALK_IND |
 		   RADEON_COLOR_ORDER_RGBA |
 		   RADEON_VTX_FMT_RADEON_MODE |
-		   (count << RADEON_NUM_VERTICES_SHIFT) );
+		   (count << RADEON_NUM_VERTICES_SHIFT));
 
 	do {
-		if ( i < nbox ) 
-			radeon_emit_clip_rect( dev_priv, 
-					       &sarea_priv->boxes[i] );
-
-		radeon_cp_dispatch_indirect( dev, elt_buf,
-					     prim->start,
-					     prim->finish );
+		if (i < nbox)
+			radeon_emit_clip_rect(dev_priv, &sarea_priv->boxes[i]);
+
+		radeon_cp_dispatch_indirect(dev, elt_buf,
+					    prim->start, prim->finish);
 
 		i++;
-	} while ( i < nbox );
+	} while (i < nbox);
 
 }
 
 #define RADEON_MAX_TEXTURE_SIZE (RADEON_BUFFER_SIZE - 8 * sizeof(u32))
 
-static int radeon_cp_dispatch_texture( DRMFILE filp,
-				       drm_device_t *dev,
-				       drm_radeon_texture_t *tex,
-				       drm_radeon_tex_image_t *image )
+static int radeon_cp_dispatch_texture(DRMFILE filp,
+				      drm_device_t * dev,
+				      drm_radeon_texture_t * tex,
+				      drm_radeon_tex_image_t * image)
 {
 	drm_radeon_private_t *dev_priv = dev->dev_private;
 	drm_file_t *filp_priv;
@@ -1512,11 +1492,11 @@ static int radeon_cp_dispatch_texture( D
 	u32 texpitch, microtile;
 	RING_LOCALS;
 
-	DRM_GET_PRIV_WITH_RETURN( filp_priv, filp );
+	DRM_GET_PRIV_WITH_RETURN(filp_priv, filp);
 
-	if ( radeon_check_and_fixup_offset( dev_priv, filp_priv, &tex->offset ) ) {
-		DRM_ERROR( "Invalid destination offset\n" );
-		return DRM_ERR( EINVAL );
+	if (radeon_check_and_fixup_offset(dev_priv, filp_priv, &tex->offset)) {
+		DRM_ERROR("Invalid destination offset\n");
+		return DRM_ERR(EINVAL);
 	}
 
 	dev_priv->stats.boxes |= RADEON_BOX_TEXTURE_LOAD;
@@ -1525,7 +1505,7 @@ static int radeon_cp_dispatch_texture( D
 	 * up with the texture data from the host data blit, otherwise
 	 * part of the texture image may be corrupted.
 	 */
-	BEGIN_RING( 4 );
+	BEGIN_RING(4);
 	RADEON_FLUSH_CACHE();
 	RADEON_WAIT_UNTIL_IDLE();
 	ADVANCE_RING();
@@ -1535,17 +1515,16 @@ static int radeon_cp_dispatch_texture( D
 	 * chip wants it, but we need to compensate for the fact that the CP
 	 * ring gets byte-swapped
 	 */
-	BEGIN_RING( 2 );
-	OUT_RING_REG( RADEON_RBBM_GUICNTL, RADEON_HOST_DATA_SWAP_32BIT );
+	BEGIN_RING(2);
+	OUT_RING_REG(RADEON_RBBM_GUICNTL, RADEON_HOST_DATA_SWAP_32BIT);
 	ADVANCE_RING();
 #endif
 
-
 	/* The compiler won't optimize away a division by a variable,
 	 * even if the only legal values are powers of two.  Thus, we'll
 	 * use a shift instead.
 	 */
-	switch ( tex->format ) {
+	switch (tex->format) {
 	case RADEON_TXFORMAT_ARGB8888:
 	case RADEON_TXFORMAT_RGBA8888:
 		format = RADEON_COLOR_FORMAT_ARGB8888;
@@ -1569,7 +1548,7 @@ static int radeon_cp_dispatch_texture( D
 		blit_width = image->width * 1;
 		break;
 	default:
-		DRM_ERROR( "invalid texture format %d\n", tex->format );
+		DRM_ERROR("invalid texture format %d\n", tex->format);
 		return DRM_ERR(EINVAL);
 	}
 	texpitch = tex->pitch;
@@ -1583,48 +1562,48 @@ static int radeon_cp_dispatch_texture( D
 	}
 	else microtile = 0;
 
-	DRM_DEBUG("tex=%dx%d blit=%d\n", tex_width, tex->height, blit_width );
+	DRM_DEBUG("tex=%dx%d blit=%d\n", tex_width, tex->height, blit_width);
 
 	do {
-		DRM_DEBUG( "tex: ofs=0x%x p=%d f=%d x=%hd y=%hd w=%hd h=%hd\n",
-			   tex->offset >> 10, tex->pitch, tex->format,
-			   image->x, image->y, image->width, image->height );
+		DRM_DEBUG("tex: ofs=0x%x p=%d f=%d x=%hd y=%hd w=%hd h=%hd\n",
+			  tex->offset >> 10, tex->pitch, tex->format,
+			  image->x, image->y, image->width, image->height);
 
 		/* Make a copy of some parameters in case we have to
 		 * update them for a multi-pass texture blit.
 		 */
 		height = image->height;
 		data = (const u8 __user *)image->data;
-		
+
 		size = height * blit_width;
 
-		if ( size > RADEON_MAX_TEXTURE_SIZE ) {
+		if (size > RADEON_MAX_TEXTURE_SIZE) {
 			height = RADEON_MAX_TEXTURE_SIZE / blit_width;
 			size = height * blit_width;
-		} else if ( size < 4 && size > 0 ) {
+		} else if (size < 4 && size > 0) {
 			size = 4;
-		} else if ( size == 0 ) {
+		} else if (size == 0) {
 			return 0;
 		}
 
-		buf = radeon_freelist_get( dev );
-		if ( 0 && !buf ) {
-			radeon_do_cp_idle( dev_priv );
-			buf = radeon_freelist_get( dev );
+		buf = radeon_freelist_get(dev);
+		if (0 && !buf) {
+			radeon_do_cp_idle(dev_priv);
+			buf = radeon_freelist_get(dev);
 		}
-		if ( !buf ) {
+		if (!buf) {
 			DRM_DEBUG("radeon_cp_dispatch_texture: EAGAIN\n");
-			if (DRM_COPY_TO_USER( tex->image, image, sizeof(*image) ))
+			if (DRM_COPY_TO_USER(tex->image, image, sizeof(*image)))
 				return DRM_ERR(EFAULT);
 			return DRM_ERR(EAGAIN);
 		}
 
-
 		/* Dispatch the indirect buffer.
 		 */
-		buffer = (u32*)((char*)dev->agp_buffer_map->handle + buf->offset);
+		buffer =
+		    (u32 *) ((char *)dev->agp_buffer_map->handle + buf->offset);
 		dwords = size / 4;
-		buffer[0] = CP_PACKET3( RADEON_CNTL_HOSTDATA_BLT, dwords + 6 );
+		buffer[0] = CP_PACKET3(RADEON_CNTL_HOSTDATA_BLT, dwords + 6);
 		buffer[1] = (RADEON_GMC_DST_PITCH_OFFSET_CNTL |
 			     RADEON_GMC_BRUSH_NONE |
 			     (format << 8) |
@@ -1633,7 +1612,7 @@ static int radeon_cp_dispatch_texture( D
 			     RADEON_DP_SRC_SOURCE_HOST_DATA |
 			     RADEON_GMC_CLR_CMP_CNTL_DIS |
 			     RADEON_GMC_WR_MSK_DIS);
-		
+
 		buffer[2] = (texpitch << 22) | (tex->offset >> 10);
 		buffer[3] = 0xffffffff;
 		buffer[4] = 0xffffffff;
@@ -1642,8 +1621,6 @@ static int radeon_cp_dispatch_texture( D
 		buffer[7] = dwords;
 		buffer += 8;
 
-		
-
 		if (microtile) {
 			/* texture micro tiling in use, minimum texture width is thus 16 bytes.
 			   however, we cannot use blitter directly for texture width < 64 bytes,
@@ -1656,7 +1633,7 @@ static int radeon_cp_dispatch_texture( D
 			if (tex->height == 1) {
 				if (tex_width >= 64 || tex_width <= 16) {
 					if (DRM_COPY_FROM_USER(buffer, data,
-							       tex_width * sizeof(u32))) {
+						       tex_width * sizeof(u32))) {
 						DRM_ERROR("EFAULT on pad, %d bytes\n",
 							  tex_width);
 						return DRM_ERR(EFAULT);
@@ -1691,8 +1668,8 @@ static int radeon_cp_dispatch_texture( D
 					data += tex_width;
 				}
 			} else if (tex_width == 32) {
-				/* TODO: make sure this works when not fitting in one buffer
-				   (i.e. 32bytes x 2048...) */
+			/* TODO: make sure this works when not fitting in one buffer
+				(i.e. 32bytes x 2048...) */
 				for (i = 0; i < tex->height; i += 2) {
 					if (DRM_COPY_FROM_USER(buffer, data, 16)) {
 						DRM_ERROR("EFAULT on pad, %d bytes\n",
@@ -1738,9 +1715,10 @@ static int radeon_cp_dispatch_texture( D
 				 * need to pad out each image scanline to the minimum
 				 * width.
 				 */
-				for (i = 0 ; i < tex->height ; i++) {
-					if (DRM_COPY_FROM_USER(buffer, data, tex_width )) {
-						DRM_ERROR("EFAULT on pad, %d bytes\n", tex_width);
+				for (i = 0; i < tex->height; i++) {
+					if (DRM_COPY_FROM_USER(buffer, data, tex_width)) {
+						DRM_ERROR("EFAULT on pad, %d bytes\n",
+							  tex_width);
 						return DRM_ERR(EFAULT);
 					}
 					buffer += 8;
@@ -1751,8 +1729,8 @@ static int radeon_cp_dispatch_texture( D
 
 		buf->filp = filp;
 		buf->used = (dwords + 8) * sizeof(u32);
-		radeon_cp_dispatch_indirect( dev, buf, 0, buf->used );
-		radeon_cp_discard_buffer( dev, buf );
+		radeon_cp_dispatch_indirect(dev, buf, 0, buf->used);
+		radeon_cp_discard_buffer(dev, buf);
 
 		/* Update the input parameters for next time */
 		image->y += height;
@@ -1764,29 +1742,28 @@ static int radeon_cp_dispatch_texture( D
 	 * the texture data is written out to memory before rendering
 	 * continues.
 	 */
-	BEGIN_RING( 4 );
+	BEGIN_RING(4);
 	RADEON_FLUSH_CACHE();
 	RADEON_WAIT_UNTIL_2D_IDLE();
 	ADVANCE_RING();
 	return 0;
 }
 
-
-static void radeon_cp_dispatch_stipple( drm_device_t *dev, u32 *stipple )
+static void radeon_cp_dispatch_stipple(drm_device_t * dev, u32 * stipple)
 {
 	drm_radeon_private_t *dev_priv = dev->dev_private;
 	int i;
 	RING_LOCALS;
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
-	BEGIN_RING( 35 );
+	BEGIN_RING(35);
 
-	OUT_RING( CP_PACKET0( RADEON_RE_STIPPLE_ADDR, 0 ) );
-	OUT_RING( 0x00000000 );
+	OUT_RING(CP_PACKET0(RADEON_RE_STIPPLE_ADDR, 0));
+	OUT_RING(0x00000000);
 
-	OUT_RING( CP_PACKET0_TABLE( RADEON_RE_STIPPLE_DATA, 31 ) );
-	for ( i = 0 ; i < 32 ; i++ ) {
-		OUT_RING( stipple[i] );
+	OUT_RING(CP_PACKET0_TABLE(RADEON_RE_STIPPLE_DATA, 31));
+	for (i = 0; i < 32; i++) {
+		OUT_RING(stipple[i]);
 	}
 
 	ADVANCE_RING();
@@ -1807,7 +1784,6 @@ static void radeon_apply_surface_regs(in
 		dev_priv->surfaces[surf_index].upper);
 }
 
-
 /* Allocates a virtual surface
  * doesn't always allocate a real surface, will stretch an existing 
  * surface when possible.
@@ -1928,7 +1904,7 @@ static int free_surface(DRMFILE filp, dr
 				dev_priv->surfaces[s->surface_index].refcount--;
 				if (dev_priv->surfaces[s->surface_index].refcount == 0)
 					dev_priv->surfaces[s->surface_index].flags = 0;
-				s->filp = NULL;
+				s->filp = 0;
 				radeon_apply_surface_regs(s->surface_index, dev_priv);
 				return 0;
 			}
@@ -1950,6 +1926,7 @@ static void radeon_surfaces_release(DRMF
 /* ================================================================
  * IOCTL functions
  */
+
 static int radeon_surface_alloc(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
@@ -1981,7 +1958,7 @@ static int radeon_surface_free(DRM_IOCTL
 		return DRM_ERR(EINVAL);
 	}
 
-	DRM_COPY_FROM_USER_IOCTL(memfree, (drm_radeon_mem_free_t __user *)data,
+	DRM_COPY_FROM_USER_IOCTL(memfree, (drm_radeon_surface_free_t __user *)data,
 				  sizeof(memfree) );
 
 	if (free_surface(filp, dev_priv, memfree.address))
@@ -1990,51 +1967,52 @@ static int radeon_surface_free(DRM_IOCTL
 		return 0;
 }
 
-static int radeon_cp_clear( DRM_IOCTL_ARGS )
+static int radeon_cp_clear(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_radeon_private_t *dev_priv = dev->dev_private;
 	drm_radeon_sarea_t *sarea_priv = dev_priv->sarea_priv;
 	drm_radeon_clear_t clear;
 	drm_radeon_clear_rect_t depth_boxes[RADEON_NR_SAREA_CLIPRECTS];
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	DRM_COPY_FROM_USER_IOCTL( clear, (drm_radeon_clear_t __user *)data,
-			     sizeof(clear) );
+	DRM_COPY_FROM_USER_IOCTL(clear, (drm_radeon_clear_t __user *) data,
+				 sizeof(clear));
 
-	RING_SPACE_TEST_WITH_RETURN( dev_priv );
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
 
-	if ( sarea_priv->nbox > RADEON_NR_SAREA_CLIPRECTS )
+	if (sarea_priv->nbox > RADEON_NR_SAREA_CLIPRECTS)
 		sarea_priv->nbox = RADEON_NR_SAREA_CLIPRECTS;
 
-	if ( DRM_COPY_FROM_USER( &depth_boxes, clear.depth_boxes,
-			     sarea_priv->nbox * sizeof(depth_boxes[0]) ) )
+	if (DRM_COPY_FROM_USER(&depth_boxes, clear.depth_boxes,
+			       sarea_priv->nbox * sizeof(depth_boxes[0])))
 		return DRM_ERR(EFAULT);
 
-	radeon_cp_dispatch_clear( dev, &clear, depth_boxes );
+	radeon_cp_dispatch_clear(dev, &clear, depth_boxes);
 
 	COMMIT_RING();
 	return 0;
 }
 
-
 /* Not sure why this isn't set all the time:
- */ 
-static int radeon_do_init_pageflip( drm_device_t *dev )
+ */
+static int radeon_do_init_pageflip(drm_device_t * dev)
 {
 	drm_radeon_private_t *dev_priv = dev->dev_private;
 	RING_LOCALS;
 
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
-	BEGIN_RING( 6 );
+	BEGIN_RING(6);
 	RADEON_WAIT_UNTIL_3D_IDLE();
-	OUT_RING( CP_PACKET0( RADEON_CRTC_OFFSET_CNTL, 0 ) );
-	OUT_RING( RADEON_READ( RADEON_CRTC_OFFSET_CNTL ) | RADEON_CRTC_OFFSET_FLIP_CNTL );
-	OUT_RING( CP_PACKET0( RADEON_CRTC2_OFFSET_CNTL, 0 ) );
-	OUT_RING( RADEON_READ( RADEON_CRTC2_OFFSET_CNTL ) | RADEON_CRTC_OFFSET_FLIP_CNTL );
+	OUT_RING(CP_PACKET0(RADEON_CRTC_OFFSET_CNTL, 0));
+	OUT_RING(RADEON_READ(RADEON_CRTC_OFFSET_CNTL) |
+		 RADEON_CRTC_OFFSET_FLIP_CNTL);
+	OUT_RING(CP_PACKET0(RADEON_CRTC2_OFFSET_CNTL, 0));
+	OUT_RING(RADEON_READ(RADEON_CRTC2_OFFSET_CNTL) |
+		 RADEON_CRTC_OFFSET_FLIP_CNTL);
 	ADVANCE_RING();
 
 	dev_priv->page_flipping = 1;
@@ -2047,62 +2025,62 @@ static int radeon_do_init_pageflip( drm_
 /* Called whenever a client dies, from drm_release.
  * NOTE:  Lock isn't necessarily held when this is called!
  */
-static int radeon_do_cleanup_pageflip( drm_device_t *dev )
+static int radeon_do_cleanup_pageflip(drm_device_t * dev)
 {
 	drm_radeon_private_t *dev_priv = dev->dev_private;
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
 	if (dev_priv->current_page != 0)
-		radeon_cp_dispatch_flip( dev );
+		radeon_cp_dispatch_flip(dev);
 
 	dev_priv->page_flipping = 0;
 	return 0;
 }
 
 /* Swapping and flipping are different operations, need different ioctls.
- * They can & should be intermixed to support multiple 3d windows.  
+ * They can & should be intermixed to support multiple 3d windows.
  */
-static int radeon_cp_flip( DRM_IOCTL_ARGS )
+static int radeon_cp_flip(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_radeon_private_t *dev_priv = dev->dev_private;
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	RING_SPACE_TEST_WITH_RETURN( dev_priv );
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
 
-	if (!dev_priv->page_flipping) 
-		radeon_do_init_pageflip( dev );
-		
-	radeon_cp_dispatch_flip( dev );
+	if (!dev_priv->page_flipping)
+		radeon_do_init_pageflip(dev);
+
+	radeon_cp_dispatch_flip(dev);
 
 	COMMIT_RING();
 	return 0;
 }
 
-static int radeon_cp_swap( DRM_IOCTL_ARGS )
+static int radeon_cp_swap(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_radeon_private_t *dev_priv = dev->dev_private;
 	drm_radeon_sarea_t *sarea_priv = dev_priv->sarea_priv;
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	RING_SPACE_TEST_WITH_RETURN( dev_priv );
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
 
-	if ( sarea_priv->nbox > RADEON_NR_SAREA_CLIPRECTS )
+	if (sarea_priv->nbox > RADEON_NR_SAREA_CLIPRECTS)
 		sarea_priv->nbox = RADEON_NR_SAREA_CLIPRECTS;
 
-	radeon_cp_dispatch_swap( dev );
+	radeon_cp_dispatch_swap(dev);
 	dev_priv->sarea_priv->ctx_owner = 0;
 
 	COMMIT_RING();
 	return 0;
 }
 
-static int radeon_cp_vertex( DRM_IOCTL_ARGS )
+static int radeon_cp_vertex(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_radeon_private_t *dev_priv = dev->dev_private;
@@ -2113,55 +2091,58 @@ static int radeon_cp_vertex( DRM_IOCTL_A
 	drm_radeon_vertex_t vertex;
 	drm_radeon_tcl_prim_t prim;
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return DRM_ERR(EINVAL);
+	}
 
-	DRM_GET_PRIV_WITH_RETURN( filp_priv, filp );
+	DRM_GET_PRIV_WITH_RETURN(filp_priv, filp);
 
-	DRM_COPY_FROM_USER_IOCTL( vertex, (drm_radeon_vertex_t __user *)data,
-			     sizeof(vertex) );
+	DRM_COPY_FROM_USER_IOCTL(vertex, (drm_radeon_vertex_t __user *) data,
+				 sizeof(vertex));
 
-	DRM_DEBUG( "pid=%d index=%d count=%d discard=%d\n",
-		   DRM_CURRENTPID,
-		   vertex.idx, vertex.count, vertex.discard );
+	DRM_DEBUG("pid=%d index=%d count=%d discard=%d\n",
+		  DRM_CURRENTPID, vertex.idx, vertex.count, vertex.discard);
 
-	if ( vertex.idx < 0 || vertex.idx >= dma->buf_count ) {
-		DRM_ERROR( "buffer index %d (of %d max)\n",
-			   vertex.idx, dma->buf_count - 1 );
+	if (vertex.idx < 0 || vertex.idx >= dma->buf_count) {
+		DRM_ERROR("buffer index %d (of %d max)\n",
+			  vertex.idx, dma->buf_count - 1);
 		return DRM_ERR(EINVAL);
 	}
-	if ( vertex.prim < 0 ||
-	     vertex.prim > RADEON_PRIM_TYPE_3VRT_LINE_LIST ) {
-		DRM_ERROR( "buffer prim %d\n", vertex.prim );
+	if (vertex.prim < 0 || vertex.prim > RADEON_PRIM_TYPE_3VRT_LINE_LIST) {
+		DRM_ERROR("buffer prim %d\n", vertex.prim);
 		return DRM_ERR(EINVAL);
 	}
 
-	RING_SPACE_TEST_WITH_RETURN( dev_priv );
-	VB_AGE_TEST_WITH_RETURN( dev_priv );
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
+	VB_AGE_TEST_WITH_RETURN(dev_priv);
 
 	buf = dma->buflist[vertex.idx];
 
-	if ( buf->filp != filp ) {
-		DRM_ERROR( "process %d using buffer owned by %p\n",
-			   DRM_CURRENTPID, buf->filp );
+	if (buf->filp != filp) {
+		DRM_ERROR("process %d using buffer owned by %p\n",
+			  DRM_CURRENTPID, buf->filp);
 		return DRM_ERR(EINVAL);
 	}
-	if ( buf->pending ) {
-		DRM_ERROR( "sending pending buffer %d\n", vertex.idx );
+	if (buf->pending) {
+		DRM_ERROR("sending pending buffer %d\n", vertex.idx);
 		return DRM_ERR(EINVAL);
 	}
 
 	/* Build up a prim_t record:
 	 */
 	if (vertex.count) {
-		buf->used = vertex.count; /* not used? */
+		buf->used = vertex.count;	/* not used? */
 
-		if ( sarea_priv->dirty & ~RADEON_UPLOAD_CLIPRECTS ) {
-			if ( radeon_emit_state( dev_priv, filp_priv,
-						&sarea_priv->context_state,
-						sarea_priv->tex_state,
-						sarea_priv->dirty ) ) {
-				DRM_ERROR( "radeon_emit_state failed\n" );
-				return DRM_ERR( EINVAL );
+		if (sarea_priv->dirty & ~RADEON_UPLOAD_CLIPRECTS) {
+			if (radeon_emit_state(dev_priv, filp_priv,
+					      &sarea_priv->context_state,
+					      sarea_priv->tex_state,
+					      sarea_priv->dirty)) {
+				DRM_ERROR("radeon_emit_state failed\n");
+				return DRM_ERR(EINVAL);
 			}
 
 			sarea_priv->dirty &= ~(RADEON_UPLOAD_TEX0IMAGES |
@@ -2171,23 +2152,23 @@ static int radeon_cp_vertex( DRM_IOCTL_A
 		}
 
 		prim.start = 0;
-		prim.finish = vertex.count; /* unused */
+		prim.finish = vertex.count;	/* unused */
 		prim.prim = vertex.prim;
 		prim.numverts = vertex.count;
 		prim.vc_format = dev_priv->sarea_priv->vc_format;
-		
-		radeon_cp_dispatch_vertex( dev, buf, &prim );
+
+		radeon_cp_dispatch_vertex(dev, buf, &prim);
 	}
 
 	if (vertex.discard) {
-		radeon_cp_discard_buffer( dev, buf );
+		radeon_cp_discard_buffer(dev, buf);
 	}
 
 	COMMIT_RING();
 	return 0;
 }
 
-static int radeon_cp_indices( DRM_IOCTL_ARGS )
+static int radeon_cp_indices(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_radeon_private_t *dev_priv = dev->dev_private;
@@ -2199,69 +2180,67 @@ static int radeon_cp_indices( DRM_IOCTL_
 	drm_radeon_tcl_prim_t prim;
 	int count;
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	if ( !dev_priv ) {
-		DRM_ERROR( "%s called with no initialization\n", __FUNCTION__ );
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
 		return DRM_ERR(EINVAL);
 	}
 
-	DRM_GET_PRIV_WITH_RETURN( filp_priv, filp );
+	DRM_GET_PRIV_WITH_RETURN(filp_priv, filp);
 
-	DRM_COPY_FROM_USER_IOCTL( elts, (drm_radeon_indices_t __user *)data,
-			     sizeof(elts) );
+	DRM_COPY_FROM_USER_IOCTL(elts, (drm_radeon_indices_t __user *) data,
+				 sizeof(elts));
 
-	DRM_DEBUG( "pid=%d index=%d start=%d end=%d discard=%d\n",
-		   DRM_CURRENTPID,
-		   elts.idx, elts.start, elts.end, elts.discard );
+	DRM_DEBUG("pid=%d index=%d start=%d end=%d discard=%d\n",
+		  DRM_CURRENTPID, elts.idx, elts.start, elts.end, elts.discard);
 
-	if ( elts.idx < 0 || elts.idx >= dma->buf_count ) {
-		DRM_ERROR( "buffer index %d (of %d max)\n",
-			   elts.idx, dma->buf_count - 1 );
+	if (elts.idx < 0 || elts.idx >= dma->buf_count) {
+		DRM_ERROR("buffer index %d (of %d max)\n",
+			  elts.idx, dma->buf_count - 1);
 		return DRM_ERR(EINVAL);
 	}
-	if ( elts.prim < 0 ||
-	     elts.prim > RADEON_PRIM_TYPE_3VRT_LINE_LIST ) {
-		DRM_ERROR( "buffer prim %d\n", elts.prim );
+	if (elts.prim < 0 || elts.prim > RADEON_PRIM_TYPE_3VRT_LINE_LIST) {
+		DRM_ERROR("buffer prim %d\n", elts.prim);
 		return DRM_ERR(EINVAL);
 	}
 
-	RING_SPACE_TEST_WITH_RETURN( dev_priv );
-	VB_AGE_TEST_WITH_RETURN( dev_priv );
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
+	VB_AGE_TEST_WITH_RETURN(dev_priv);
 
 	buf = dma->buflist[elts.idx];
 
-	if ( buf->filp != filp ) {
-		DRM_ERROR( "process %d using buffer owned by %p\n",
-			   DRM_CURRENTPID, buf->filp );
+	if (buf->filp != filp) {
+		DRM_ERROR("process %d using buffer owned by %p\n",
+			  DRM_CURRENTPID, buf->filp);
 		return DRM_ERR(EINVAL);
 	}
-	if ( buf->pending ) {
-		DRM_ERROR( "sending pending buffer %d\n", elts.idx );
+	if (buf->pending) {
+		DRM_ERROR("sending pending buffer %d\n", elts.idx);
 		return DRM_ERR(EINVAL);
 	}
 
 	count = (elts.end - elts.start) / sizeof(u16);
 	elts.start -= RADEON_INDEX_PRIM_OFFSET;
 
-	if ( elts.start & 0x7 ) {
-		DRM_ERROR( "misaligned buffer 0x%x\n", elts.start );
+	if (elts.start & 0x7) {
+		DRM_ERROR("misaligned buffer 0x%x\n", elts.start);
 		return DRM_ERR(EINVAL);
 	}
-	if ( elts.start < buf->used ) {
-		DRM_ERROR( "no header 0x%x - 0x%x\n", elts.start, buf->used );
+	if (elts.start < buf->used) {
+		DRM_ERROR("no header 0x%x - 0x%x\n", elts.start, buf->used);
 		return DRM_ERR(EINVAL);
 	}
 
 	buf->used = elts.end;
 
-	if ( sarea_priv->dirty & ~RADEON_UPLOAD_CLIPRECTS ) {
-		if ( radeon_emit_state( dev_priv, filp_priv,
-					&sarea_priv->context_state,
-					sarea_priv->tex_state,
-					sarea_priv->dirty ) ) {
-			DRM_ERROR( "radeon_emit_state failed\n" );
-			return DRM_ERR( EINVAL );
+	if (sarea_priv->dirty & ~RADEON_UPLOAD_CLIPRECTS) {
+		if (radeon_emit_state(dev_priv, filp_priv,
+				      &sarea_priv->context_state,
+				      sarea_priv->tex_state,
+				      sarea_priv->dirty)) {
+			DRM_ERROR("radeon_emit_state failed\n");
+			return DRM_ERR(EINVAL);
 		}
 
 		sarea_priv->dirty &= ~(RADEON_UPLOAD_TEX0IMAGES |
@@ -2270,26 +2249,25 @@ static int radeon_cp_indices( DRM_IOCTL_
 				       RADEON_REQUIRE_QUIESCENCE);
 	}
 
-
 	/* Build up a prim_t record:
 	 */
 	prim.start = elts.start;
-	prim.finish = elts.end; 
+	prim.finish = elts.end;
 	prim.prim = elts.prim;
 	prim.offset = 0;	/* offset from start of dma buffers */
-	prim.numverts = RADEON_MAX_VB_VERTS; /* duh */
+	prim.numverts = RADEON_MAX_VB_VERTS;	/* duh */
 	prim.vc_format = dev_priv->sarea_priv->vc_format;
-	
-	radeon_cp_dispatch_indices( dev, buf, &prim );
+
+	radeon_cp_dispatch_indices(dev, buf, &prim);
 	if (elts.discard) {
-		radeon_cp_discard_buffer( dev, buf );
+		radeon_cp_discard_buffer(dev, buf);
 	}
 
 	COMMIT_RING();
 	return 0;
 }
 
-static int radeon_cp_texture( DRM_IOCTL_ARGS )
+static int radeon_cp_texture(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_radeon_private_t *dev_priv = dev->dev_private;
@@ -2297,53 +2275,54 @@ static int radeon_cp_texture( DRM_IOCTL_
 	drm_radeon_tex_image_t image;
 	int ret;
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	DRM_COPY_FROM_USER_IOCTL( tex, (drm_radeon_texture_t __user *)data, sizeof(tex) );
+	DRM_COPY_FROM_USER_IOCTL(tex, (drm_radeon_texture_t __user *) data,
+				 sizeof(tex));
 
-	if ( tex.image == NULL ) {
-		DRM_ERROR( "null texture image!\n" );
+	if (tex.image == NULL) {
+		DRM_ERROR("null texture image!\n");
 		return DRM_ERR(EINVAL);
 	}
 
-	if ( DRM_COPY_FROM_USER( &image,
-			     (drm_radeon_tex_image_t __user *)tex.image,
-			     sizeof(image) ) )
+	if (DRM_COPY_FROM_USER(&image,
+			       (drm_radeon_tex_image_t __user *) tex.image,
+			       sizeof(image)))
 		return DRM_ERR(EFAULT);
 
-	RING_SPACE_TEST_WITH_RETURN( dev_priv );
-	VB_AGE_TEST_WITH_RETURN( dev_priv );
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
+	VB_AGE_TEST_WITH_RETURN(dev_priv);
 
-	ret = radeon_cp_dispatch_texture( filp, dev, &tex, &image );
+	ret = radeon_cp_dispatch_texture(filp, dev, &tex, &image);
 
 	COMMIT_RING();
 	return ret;
 }
 
-static int radeon_cp_stipple( DRM_IOCTL_ARGS )
+static int radeon_cp_stipple(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_radeon_private_t *dev_priv = dev->dev_private;
 	drm_radeon_stipple_t stipple;
 	u32 mask[32];
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	DRM_COPY_FROM_USER_IOCTL( stipple, (drm_radeon_stipple_t __user *)data,
-			     sizeof(stipple) );
+	DRM_COPY_FROM_USER_IOCTL(stipple, (drm_radeon_stipple_t __user *) data,
+				 sizeof(stipple));
 
-	if ( DRM_COPY_FROM_USER( &mask, stipple.mask, 32 * sizeof(u32) ) )
+	if (DRM_COPY_FROM_USER(&mask, stipple.mask, 32 * sizeof(u32)))
 		return DRM_ERR(EFAULT);
 
-	RING_SPACE_TEST_WITH_RETURN( dev_priv );
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
 
-	radeon_cp_dispatch_stipple( dev, mask );
+	radeon_cp_dispatch_stipple(dev, mask);
 
 	COMMIT_RING();
 	return 0;
 }
 
-static int radeon_cp_indirect( DRM_IOCTL_ARGS )
+static int radeon_cp_indirect(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_radeon_private_t *dev_priv = dev->dev_private;
@@ -2352,53 +2331,53 @@ static int radeon_cp_indirect( DRM_IOCTL
 	drm_radeon_indirect_t indirect;
 	RING_LOCALS;
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	if ( !dev_priv ) {
-		DRM_ERROR( "%s called with no initialization\n", __FUNCTION__ );
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
 		return DRM_ERR(EINVAL);
 	}
 
-	DRM_COPY_FROM_USER_IOCTL( indirect, (drm_radeon_indirect_t __user *)data,
-			     sizeof(indirect) );
+	DRM_COPY_FROM_USER_IOCTL(indirect,
+				 (drm_radeon_indirect_t __user *) data,
+				 sizeof(indirect));
 
-	DRM_DEBUG( "indirect: idx=%d s=%d e=%d d=%d\n",
-		   indirect.idx, indirect.start,
-		   indirect.end, indirect.discard );
-
-	if ( indirect.idx < 0 || indirect.idx >= dma->buf_count ) {
-		DRM_ERROR( "buffer index %d (of %d max)\n",
-			   indirect.idx, dma->buf_count - 1 );
+	DRM_DEBUG("indirect: idx=%d s=%d e=%d d=%d\n",
+		  indirect.idx, indirect.start, indirect.end, indirect.discard);
+
+	if (indirect.idx < 0 || indirect.idx >= dma->buf_count) {
+		DRM_ERROR("buffer index %d (of %d max)\n",
+			  indirect.idx, dma->buf_count - 1);
 		return DRM_ERR(EINVAL);
 	}
 
 	buf = dma->buflist[indirect.idx];
 
-	if ( buf->filp != filp ) {
-		DRM_ERROR( "process %d using buffer owned by %p\n",
-			   DRM_CURRENTPID, buf->filp );
+	if (buf->filp != filp) {
+		DRM_ERROR("process %d using buffer owned by %p\n",
+			  DRM_CURRENTPID, buf->filp);
 		return DRM_ERR(EINVAL);
 	}
-	if ( buf->pending ) {
-		DRM_ERROR( "sending pending buffer %d\n", indirect.idx );
+	if (buf->pending) {
+		DRM_ERROR("sending pending buffer %d\n", indirect.idx);
 		return DRM_ERR(EINVAL);
 	}
 
-	if ( indirect.start < buf->used ) {
-		DRM_ERROR( "reusing indirect: start=0x%x actual=0x%x\n",
-			   indirect.start, buf->used );
+	if (indirect.start < buf->used) {
+		DRM_ERROR("reusing indirect: start=0x%x actual=0x%x\n",
+			  indirect.start, buf->used);
 		return DRM_ERR(EINVAL);
 	}
 
-	RING_SPACE_TEST_WITH_RETURN( dev_priv );
-	VB_AGE_TEST_WITH_RETURN( dev_priv );
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
+	VB_AGE_TEST_WITH_RETURN(dev_priv);
 
 	buf->used = indirect.end;
 
 	/* Wait for the 3D stream to idle before the indirect buffer
 	 * containing 2D acceleration commands is processed.
 	 */
-	BEGIN_RING( 2 );
+	BEGIN_RING(2);
 
 	RADEON_WAIT_UNTIL_3D_IDLE();
 
@@ -2408,17 +2387,16 @@ static int radeon_cp_indirect( DRM_IOCTL
 	 * X server.  This is insecure and is thus only available to
 	 * privileged clients.
 	 */
-	radeon_cp_dispatch_indirect( dev, buf, indirect.start, indirect.end );
+	radeon_cp_dispatch_indirect(dev, buf, indirect.start, indirect.end);
 	if (indirect.discard) {
-		radeon_cp_discard_buffer( dev, buf );
+		radeon_cp_discard_buffer(dev, buf);
 	}
 
-
 	COMMIT_RING();
 	return 0;
 }
 
-static int radeon_cp_vertex2( DRM_IOCTL_ARGS )
+static int radeon_cp_vertex2(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_radeon_private_t *dev_priv = dev->dev_private;
@@ -2430,65 +2408,64 @@ static int radeon_cp_vertex2( DRM_IOCTL_
 	int i;
 	unsigned char laststate;
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	if ( !dev_priv ) {
-		DRM_ERROR( "%s called with no initialization\n", __FUNCTION__ );
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
 		return DRM_ERR(EINVAL);
 	}
 
-	DRM_GET_PRIV_WITH_RETURN( filp_priv, filp );
+	DRM_GET_PRIV_WITH_RETURN(filp_priv, filp);
 
-	DRM_COPY_FROM_USER_IOCTL( vertex, (drm_radeon_vertex2_t __user *)data,
-			     sizeof(vertex) );
+	DRM_COPY_FROM_USER_IOCTL(vertex, (drm_radeon_vertex2_t __user *) data,
+				 sizeof(vertex));
 
-	DRM_DEBUG( "pid=%d index=%d discard=%d\n",
-		   DRM_CURRENTPID,
-		   vertex.idx, vertex.discard );
+	DRM_DEBUG("pid=%d index=%d discard=%d\n",
+		  DRM_CURRENTPID, vertex.idx, vertex.discard);
 
-	if ( vertex.idx < 0 || vertex.idx >= dma->buf_count ) {
-		DRM_ERROR( "buffer index %d (of %d max)\n",
-			   vertex.idx, dma->buf_count - 1 );
+	if (vertex.idx < 0 || vertex.idx >= dma->buf_count) {
+		DRM_ERROR("buffer index %d (of %d max)\n",
+			  vertex.idx, dma->buf_count - 1);
 		return DRM_ERR(EINVAL);
 	}
 
-	RING_SPACE_TEST_WITH_RETURN( dev_priv );
-	VB_AGE_TEST_WITH_RETURN( dev_priv );
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
+	VB_AGE_TEST_WITH_RETURN(dev_priv);
 
 	buf = dma->buflist[vertex.idx];
 
-	if ( buf->filp != filp ) {
-		DRM_ERROR( "process %d using buffer owned by %p\n",
-			   DRM_CURRENTPID, buf->filp );
+	if (buf->filp != filp) {
+		DRM_ERROR("process %d using buffer owned by %p\n",
+			  DRM_CURRENTPID, buf->filp);
 		return DRM_ERR(EINVAL);
 	}
 
-	if ( buf->pending ) {
-		DRM_ERROR( "sending pending buffer %d\n", vertex.idx );
+	if (buf->pending) {
+		DRM_ERROR("sending pending buffer %d\n", vertex.idx);
 		return DRM_ERR(EINVAL);
 	}
-	
+
 	if (sarea_priv->nbox > RADEON_NR_SAREA_CLIPRECTS)
 		return DRM_ERR(EINVAL);
 
-	for (laststate = 0xff, i = 0 ; i < vertex.nr_prims ; i++) {
+	for (laststate = 0xff, i = 0; i < vertex.nr_prims; i++) {
 		drm_radeon_prim_t prim;
 		drm_radeon_tcl_prim_t tclprim;
-		
-		if ( DRM_COPY_FROM_USER( &prim, &vertex.prim[i], sizeof(prim) ) )
+
+		if (DRM_COPY_FROM_USER(&prim, &vertex.prim[i], sizeof(prim)))
 			return DRM_ERR(EFAULT);
-		
-		if ( prim.stateidx != laststate ) {
-			drm_radeon_state_t state;			       
-				
-			if ( DRM_COPY_FROM_USER( &state, 
-					     &vertex.state[prim.stateidx], 
-					     sizeof(state) ) )
+
+		if (prim.stateidx != laststate) {
+			drm_radeon_state_t state;
+
+			if (DRM_COPY_FROM_USER(&state,
+					       &vertex.state[prim.stateidx],
+					       sizeof(state)))
 				return DRM_ERR(EFAULT);
 
-			if ( radeon_emit_state2( dev_priv, filp_priv, &state ) ) {
-				DRM_ERROR( "radeon_emit_state2 failed\n" );
-				return DRM_ERR( EINVAL );
+			if (radeon_emit_state2(dev_priv, filp_priv, &state)) {
+				DRM_ERROR("radeon_emit_state2 failed\n");
+				return DRM_ERR(EINVAL);
 			}
 
 			laststate = prim.stateidx;
@@ -2499,42 +2476,40 @@ static int radeon_cp_vertex2( DRM_IOCTL_
 		tclprim.prim = prim.prim;
 		tclprim.vc_format = prim.vc_format;
 
-		if ( prim.prim & RADEON_PRIM_WALK_IND ) {
+		if (prim.prim & RADEON_PRIM_WALK_IND) {
 			tclprim.offset = prim.numverts * 64;
-			tclprim.numverts = RADEON_MAX_VB_VERTS; /* duh */
+			tclprim.numverts = RADEON_MAX_VB_VERTS;	/* duh */
 
-			radeon_cp_dispatch_indices( dev, buf, &tclprim );
+			radeon_cp_dispatch_indices(dev, buf, &tclprim);
 		} else {
 			tclprim.numverts = prim.numverts;
-			tclprim.offset = 0; /* not used */
+			tclprim.offset = 0;	/* not used */
 
-			radeon_cp_dispatch_vertex( dev, buf, &tclprim );
+			radeon_cp_dispatch_vertex(dev, buf, &tclprim);
 		}
-		
+
 		if (sarea_priv->nbox == 1)
 			sarea_priv->nbox = 0;
 	}
 
-	if ( vertex.discard ) {
-		radeon_cp_discard_buffer( dev, buf );
+	if (vertex.discard) {
+		radeon_cp_discard_buffer(dev, buf);
 	}
 
 	COMMIT_RING();
 	return 0;
 }
 
-
-static int radeon_emit_packets( 
-	drm_radeon_private_t *dev_priv,
-	drm_file_t *filp_priv,
-	drm_radeon_cmd_header_t header,
-	drm_radeon_cmd_buffer_t *cmdbuf )
+static int radeon_emit_packets(drm_radeon_private_t * dev_priv,
+			       drm_file_t * filp_priv,
+			       drm_radeon_cmd_header_t header,
+			       drm_radeon_cmd_buffer_t * cmdbuf)
 {
 	int id = (int)header.packet.packet_id;
 	int sz, reg;
 	int *data = (int *)cmdbuf->buf;
 	RING_LOCALS;
-   
+
 	if (id >= RADEON_MAX_STATE_PACKETS)
 		return DRM_ERR(EINVAL);
 
@@ -2542,18 +2517,18 @@ static int radeon_emit_packets( 
 	reg = packet[id].start;
 
 	if (sz * sizeof(int) > cmdbuf->bufsz) {
-		DRM_ERROR( "Packet size provided larger than data provided\n" );
+		DRM_ERROR("Packet size provided larger than data provided\n");
 		return DRM_ERR(EINVAL);
 	}
 
-	if ( radeon_check_and_fixup_packets( dev_priv, filp_priv, id, data ) ) {
-		DRM_ERROR( "Packet verification failed\n" );
-		return DRM_ERR( EINVAL );
+	if (radeon_check_and_fixup_packets(dev_priv, filp_priv, id, data)) {
+		DRM_ERROR("Packet verification failed\n");
+		return DRM_ERR(EINVAL);
 	}
 
-	BEGIN_RING(sz+1);
-	OUT_RING( CP_PACKET0( reg, (sz-1) ) );
-	OUT_RING_TABLE( data, sz );
+	BEGIN_RING(sz + 1);
+	OUT_RING(CP_PACKET0(reg, (sz - 1)));
+	OUT_RING_TABLE(data, sz);
 	ADVANCE_RING();
 
 	cmdbuf->buf += sz * sizeof(int);
@@ -2561,21 +2536,20 @@ static int radeon_emit_packets( 
 	return 0;
 }
 
-static __inline__ int radeon_emit_scalars( 
-	drm_radeon_private_t *dev_priv,
-	drm_radeon_cmd_header_t header,
-	drm_radeon_cmd_buffer_t *cmdbuf )
+static __inline__ int radeon_emit_scalars(drm_radeon_private_t * dev_priv,
+					  drm_radeon_cmd_header_t header,
+					  drm_radeon_cmd_buffer_t * cmdbuf)
 {
 	int sz = header.scalars.count;
 	int start = header.scalars.offset;
 	int stride = header.scalars.stride;
 	RING_LOCALS;
 
-	BEGIN_RING( 3+sz );
-	OUT_RING( CP_PACKET0( RADEON_SE_TCL_SCALAR_INDX_REG, 0 ) );
-	OUT_RING( start | (stride << RADEON_SCAL_INDX_DWORD_STRIDE_SHIFT));
-	OUT_RING( CP_PACKET0_TABLE( RADEON_SE_TCL_SCALAR_DATA_REG, sz-1 ) );
-	OUT_RING_TABLE( cmdbuf->buf, sz );
+	BEGIN_RING(3 + sz);
+	OUT_RING(CP_PACKET0(RADEON_SE_TCL_SCALAR_INDX_REG, 0));
+	OUT_RING(start | (stride << RADEON_SCAL_INDX_DWORD_STRIDE_SHIFT));
+	OUT_RING(CP_PACKET0_TABLE(RADEON_SE_TCL_SCALAR_DATA_REG, sz - 1));
+	OUT_RING_TABLE(cmdbuf->buf, sz);
 	ADVANCE_RING();
 	cmdbuf->buf += sz * sizeof(int);
 	cmdbuf->bufsz -= sz * sizeof(int);
@@ -2584,42 +2558,40 @@ static __inline__ int radeon_emit_scalar
 
 /* God this is ugly
  */
-static __inline__ int radeon_emit_scalars2( 
-	drm_radeon_private_t *dev_priv,
-	drm_radeon_cmd_header_t header,
-	drm_radeon_cmd_buffer_t *cmdbuf )
+static __inline__ int radeon_emit_scalars2(drm_radeon_private_t * dev_priv,
+					   drm_radeon_cmd_header_t header,
+					   drm_radeon_cmd_buffer_t * cmdbuf)
 {
 	int sz = header.scalars.count;
 	int start = ((unsigned int)header.scalars.offset) + 0x100;
 	int stride = header.scalars.stride;
 	RING_LOCALS;
 
-	BEGIN_RING( 3+sz );
-	OUT_RING( CP_PACKET0( RADEON_SE_TCL_SCALAR_INDX_REG, 0 ) );
-	OUT_RING( start | (stride << RADEON_SCAL_INDX_DWORD_STRIDE_SHIFT));
-	OUT_RING( CP_PACKET0_TABLE( RADEON_SE_TCL_SCALAR_DATA_REG, sz-1 ) );
-	OUT_RING_TABLE( cmdbuf->buf, sz );
+	BEGIN_RING(3 + sz);
+	OUT_RING(CP_PACKET0(RADEON_SE_TCL_SCALAR_INDX_REG, 0));
+	OUT_RING(start | (stride << RADEON_SCAL_INDX_DWORD_STRIDE_SHIFT));
+	OUT_RING(CP_PACKET0_TABLE(RADEON_SE_TCL_SCALAR_DATA_REG, sz - 1));
+	OUT_RING_TABLE(cmdbuf->buf, sz);
 	ADVANCE_RING();
 	cmdbuf->buf += sz * sizeof(int);
 	cmdbuf->bufsz -= sz * sizeof(int);
 	return 0;
 }
 
-static __inline__ int radeon_emit_vectors( 
-	drm_radeon_private_t *dev_priv,
-	drm_radeon_cmd_header_t header,
-	drm_radeon_cmd_buffer_t *cmdbuf )
+static __inline__ int radeon_emit_vectors(drm_radeon_private_t * dev_priv,
+					  drm_radeon_cmd_header_t header,
+					  drm_radeon_cmd_buffer_t * cmdbuf)
 {
 	int sz = header.vectors.count;
 	int start = header.vectors.offset;
 	int stride = header.vectors.stride;
 	RING_LOCALS;
 
-	BEGIN_RING( 3+sz );
-	OUT_RING( CP_PACKET0( RADEON_SE_TCL_VECTOR_INDX_REG, 0 ) );
-	OUT_RING( start | (stride << RADEON_VEC_INDX_OCTWORD_STRIDE_SHIFT));
-	OUT_RING( CP_PACKET0_TABLE( RADEON_SE_TCL_VECTOR_DATA_REG, (sz-1) ) );
-	OUT_RING_TABLE( cmdbuf->buf, sz );
+	BEGIN_RING(3 + sz);
+	OUT_RING(CP_PACKET0(RADEON_SE_TCL_VECTOR_INDX_REG, 0));
+	OUT_RING(start | (stride << RADEON_VEC_INDX_OCTWORD_STRIDE_SHIFT));
+	OUT_RING(CP_PACKET0_TABLE(RADEON_SE_TCL_VECTOR_DATA_REG, (sz - 1)));
+	OUT_RING_TABLE(cmdbuf->buf, sz);
 	ADVANCE_RING();
 
 	cmdbuf->buf += sz * sizeof(int);
@@ -2627,10 +2599,9 @@ static __inline__ int radeon_emit_vector
 	return 0;
 }
 
-
-static int radeon_emit_packet3( drm_device_t *dev,
-				drm_file_t *filp_priv,
-				drm_radeon_cmd_buffer_t *cmdbuf )
+static int radeon_emit_packet3(drm_device_t * dev,
+			       drm_file_t * filp_priv,
+			       drm_radeon_cmd_buffer_t * cmdbuf)
 {
 	drm_radeon_private_t *dev_priv = dev->dev_private;
 	unsigned int cmdsz;
@@ -2639,14 +2610,14 @@ static int radeon_emit_packet3( drm_devi
 
 	DRM_DEBUG("\n");
 
-	if ( ( ret = radeon_check_and_fixup_packet3( dev_priv, filp_priv,
-						     cmdbuf, &cmdsz ) ) ) {
-		DRM_ERROR( "Packet verification failed\n" );
+	if ((ret = radeon_check_and_fixup_packet3(dev_priv, filp_priv,
+						  cmdbuf, &cmdsz))) {
+		DRM_ERROR("Packet verification failed\n");
 		return ret;
 	}
 
-	BEGIN_RING( cmdsz );
-	OUT_RING_TABLE( cmdbuf->buf, cmdsz );
+	BEGIN_RING(cmdsz);
+	OUT_RING_TABLE(cmdbuf->buf, cmdsz);
 	ADVANCE_RING();
 
 	cmdbuf->buf += cmdsz * 4;
@@ -2654,11 +2625,10 @@ static int radeon_emit_packet3( drm_devi
 	return 0;
 }
 
-
-static int radeon_emit_packet3_cliprect( drm_device_t *dev,
-					 drm_file_t *filp_priv,
-					 drm_radeon_cmd_buffer_t *cmdbuf,
-					 int orig_nbox )
+static int radeon_emit_packet3_cliprect(drm_device_t * dev,
+					drm_file_t * filp_priv,
+					drm_radeon_cmd_buffer_t * cmdbuf,
+					int orig_nbox)
 {
 	drm_radeon_private_t *dev_priv = dev->dev_private;
 	drm_clip_rect_t box;
@@ -2670,9 +2640,9 @@ static int radeon_emit_packet3_cliprect(
 
 	DRM_DEBUG("\n");
 
-	if ( ( ret = radeon_check_and_fixup_packet3( dev_priv, filp_priv,
-						     cmdbuf, &cmdsz ) ) ) {
-		DRM_ERROR( "Packet verification failed\n" );
+	if ((ret = radeon_check_and_fixup_packet3(dev_priv, filp_priv,
+						  cmdbuf, &cmdsz))) {
+		DRM_ERROR("Packet verification failed\n");
 		return ret;
 	}
 
@@ -2680,8 +2650,8 @@ static int radeon_emit_packet3_cliprect(
 		goto out;
 
 	do {
-		if ( i < cmdbuf->nbox ) {
-			if (DRM_COPY_FROM_USER( &box, &boxes[i], sizeof(box) ))
+		if (i < cmdbuf->nbox) {
+			if (DRM_COPY_FROM_USER(&box, &boxes[i], sizeof(box)))
 				return DRM_ERR(EFAULT);
 			/* FIXME The second and subsequent times round
 			 * this loop, send a WAIT_UNTIL_3D_IDLE before
@@ -2695,30 +2665,29 @@ static int radeon_emit_packet3_cliprect(
 			 * the correct place to fix it but this works
 			 * around it until I can figure that out - Tim
 			 * Smith */
-			if ( i ) {
-				BEGIN_RING( 2 );
+			if (i) {
+				BEGIN_RING(2);
 				RADEON_WAIT_UNTIL_3D_IDLE();
 				ADVANCE_RING();
 			}
-			radeon_emit_clip_rect( dev_priv, &box );
+			radeon_emit_clip_rect(dev_priv, &box);
 		}
-		
-		BEGIN_RING( cmdsz );
-		OUT_RING_TABLE( cmdbuf->buf, cmdsz );
+
+		BEGIN_RING(cmdsz);
+		OUT_RING_TABLE(cmdbuf->buf, cmdsz);
 		ADVANCE_RING();
 
-	} while ( ++i < cmdbuf->nbox );
- 	if (cmdbuf->nbox == 1)
+	} while (++i < cmdbuf->nbox);
+	if (cmdbuf->nbox == 1)
 		cmdbuf->nbox = 0;
 
- out:
+      out:
 	cmdbuf->buf += cmdsz * 4;
 	cmdbuf->bufsz -= cmdsz * 4;
 	return 0;
 }
 
-
-static int radeon_emit_wait( drm_device_t *dev, int flags )
+static int radeon_emit_wait(drm_device_t * dev, int flags)
 {
 	drm_radeon_private_t *dev_priv = dev->dev_private;
 	RING_LOCALS;
@@ -2726,18 +2695,18 @@ static int radeon_emit_wait( drm_device_
 	DRM_DEBUG("%s: %x\n", __FUNCTION__, flags);
 	switch (flags) {
 	case RADEON_WAIT_2D:
-		BEGIN_RING( 2 );
-		RADEON_WAIT_UNTIL_2D_IDLE(); 
+		BEGIN_RING(2);
+		RADEON_WAIT_UNTIL_2D_IDLE();
 		ADVANCE_RING();
 		break;
 	case RADEON_WAIT_3D:
-		BEGIN_RING( 2 );
-		RADEON_WAIT_UNTIL_3D_IDLE(); 
+		BEGIN_RING(2);
+		RADEON_WAIT_UNTIL_3D_IDLE();
 		ADVANCE_RING();
 		break;
-	case RADEON_WAIT_2D|RADEON_WAIT_3D:
-		BEGIN_RING( 2 );
-		RADEON_WAIT_UNTIL_IDLE(); 
+	case RADEON_WAIT_2D | RADEON_WAIT_3D:
+		BEGIN_RING(2);
+		RADEON_WAIT_UNTIL_IDLE();
 		ADVANCE_RING();
 		break;
 	default:
@@ -2747,7 +2716,7 @@ static int radeon_emit_wait( drm_device_
 	return 0;
 }
 
-static int radeon_cp_cmdbuf( DRM_IOCTL_ARGS )
+static int radeon_cp_cmdbuf(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_radeon_private_t *dev_priv = dev->dev_private;
@@ -2758,24 +2727,25 @@ static int radeon_cp_cmdbuf( DRM_IOCTL_A
 	drm_radeon_cmd_buffer_t cmdbuf;
 	drm_radeon_cmd_header_t header;
 	int orig_nbox, orig_bufsz;
-	char *kbuf=NULL;
+	char *kbuf = NULL;
 
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
 
-	if ( !dev_priv ) {
-		DRM_ERROR( "%s called with no initialization\n", __FUNCTION__ );
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
 		return DRM_ERR(EINVAL);
 	}
 
-	DRM_GET_PRIV_WITH_RETURN( filp_priv, filp );
+	DRM_GET_PRIV_WITH_RETURN(filp_priv, filp);
 
-	DRM_COPY_FROM_USER_IOCTL( cmdbuf, (drm_radeon_cmd_buffer_t __user *)data,
-			     sizeof(cmdbuf) );
+	DRM_COPY_FROM_USER_IOCTL(cmdbuf,
+				 (drm_radeon_cmd_buffer_t __user *) data,
+				 sizeof(cmdbuf));
 
-	RING_SPACE_TEST_WITH_RETURN( dev_priv );
-	VB_AGE_TEST_WITH_RETURN( dev_priv );
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
+	VB_AGE_TEST_WITH_RETURN(dev_priv);
 
-	if (cmdbuf.bufsz > 64*1024 || cmdbuf.bufsz<0) {
+	if (cmdbuf.bufsz > 64 * 1024 || cmdbuf.bufsz < 0) {
 		return DRM_ERR(EINVAL);
 	}
 
@@ -2797,16 +2767,16 @@ static int radeon_cp_cmdbuf( DRM_IOCTL_A
 
 	orig_nbox = cmdbuf.nbox;
 
-	while ( cmdbuf.bufsz >= sizeof(header) ) {
-
+	while (cmdbuf.bufsz >= sizeof(header)) {
 		header.i = *(int *)cmdbuf.buf;
 		cmdbuf.buf += sizeof(header);
 		cmdbuf.bufsz -= sizeof(header);
 
 		switch (header.header.cmd_type) {
-		case RADEON_CMD_PACKET: 
+		case RADEON_CMD_PACKET:
 			DRM_DEBUG("RADEON_CMD_PACKET\n");
-			if (radeon_emit_packets( dev_priv, filp_priv, header, &cmdbuf )) {
+			if (radeon_emit_packets
+			    (dev_priv, filp_priv, header, &cmdbuf)) {
 				DRM_ERROR("radeon_emit_packets failed\n");
 				goto err;
 			}
@@ -2814,7 +2784,7 @@ static int radeon_cp_cmdbuf( DRM_IOCTL_A
 
 		case RADEON_CMD_SCALARS:
 			DRM_DEBUG("RADEON_CMD_SCALARS\n");
-			if (radeon_emit_scalars( dev_priv, header, &cmdbuf )) {
+			if (radeon_emit_scalars(dev_priv, header, &cmdbuf)) {
 				DRM_ERROR("radeon_emit_scalars failed\n");
 				goto err;
 			}
@@ -2822,7 +2792,7 @@ static int radeon_cp_cmdbuf( DRM_IOCTL_A
 
 		case RADEON_CMD_VECTORS:
 			DRM_DEBUG("RADEON_CMD_VECTORS\n");
-			if (radeon_emit_vectors( dev_priv, header, &cmdbuf )) {
+			if (radeon_emit_vectors(dev_priv, header, &cmdbuf)) {
 				DRM_ERROR("radeon_emit_vectors failed\n");
 				goto err;
 			}
@@ -2831,25 +2801,25 @@ static int radeon_cp_cmdbuf( DRM_IOCTL_A
 		case RADEON_CMD_DMA_DISCARD:
 			DRM_DEBUG("RADEON_CMD_DMA_DISCARD\n");
 			idx = header.dma.buf_idx;
-			if ( idx < 0 || idx >= dma->buf_count ) {
-				DRM_ERROR( "buffer index %d (of %d max)\n",
-					   idx, dma->buf_count - 1 );
+			if (idx < 0 || idx >= dma->buf_count) {
+				DRM_ERROR("buffer index %d (of %d max)\n",
+					  idx, dma->buf_count - 1);
 				goto err;
 			}
 
 			buf = dma->buflist[idx];
-			if ( buf->filp != filp || buf->pending ) {
-				DRM_ERROR( "bad buffer %p %p %d\n",
-					   buf->filp, filp, buf->pending);
+			if (buf->filp != filp || buf->pending) {
+				DRM_ERROR("bad buffer %p %p %d\n",
+					  buf->filp, filp, buf->pending);
 				goto err;
 			}
 
-			radeon_cp_discard_buffer( dev, buf );
+			radeon_cp_discard_buffer(dev, buf);
 			break;
 
 		case RADEON_CMD_PACKET3:
 			DRM_DEBUG("RADEON_CMD_PACKET3\n");
-			if (radeon_emit_packet3( dev, filp_priv, &cmdbuf )) {
+			if (radeon_emit_packet3(dev, filp_priv, &cmdbuf)) {
 				DRM_ERROR("radeon_emit_packet3 failed\n");
 				goto err;
 			}
@@ -2857,7 +2827,8 @@ static int radeon_cp_cmdbuf( DRM_IOCTL_A
 
 		case RADEON_CMD_PACKET3_CLIP:
 			DRM_DEBUG("RADEON_CMD_PACKET3_CLIP\n");
-			if (radeon_emit_packet3_cliprect( dev, filp_priv, &cmdbuf, orig_nbox )) {
+			if (radeon_emit_packet3_cliprect
+			    (dev, filp_priv, &cmdbuf, orig_nbox)) {
 				DRM_ERROR("radeon_emit_packet3_clip failed\n");
 				goto err;
 			}
@@ -2865,7 +2836,7 @@ static int radeon_cp_cmdbuf( DRM_IOCTL_A
 
 		case RADEON_CMD_SCALARS2:
 			DRM_DEBUG("RADEON_CMD_SCALARS2\n");
-			if (radeon_emit_scalars2( dev_priv, header, &cmdbuf )) {
+			if (radeon_emit_scalars2(dev_priv, header, &cmdbuf)) {
 				DRM_ERROR("radeon_emit_scalars2 failed\n");
 				goto err;
 			}
@@ -2873,13 +2844,13 @@ static int radeon_cp_cmdbuf( DRM_IOCTL_A
 
 		case RADEON_CMD_WAIT:
 			DRM_DEBUG("RADEON_CMD_WAIT\n");
-			if (radeon_emit_wait( dev, header.wait.flags )) {
+			if (radeon_emit_wait(dev, header.wait.flags)) {
 				DRM_ERROR("radeon_emit_wait failed\n");
 				goto err;
 			}
 			break;
 		default:
-			DRM_ERROR("bad cmd_type %d at %p\n", 
+			DRM_ERROR("bad cmd_type %d at %p\n",
 				  header.header.cmd_type,
 				  cmdbuf.buf - sizeof(header));
 			goto err;
@@ -2888,7 +2859,6 @@ static int radeon_cp_cmdbuf( DRM_IOCTL_A
 
 	if (orig_bufsz != 0)
 		drm_free(kbuf, orig_bufsz, DRM_MEM_DRIVER);
-
 	DRM_DEBUG("DONE\n");
 	COMMIT_RING();
 	return 0;
@@ -2899,39 +2869,37 @@ err:
 	return DRM_ERR(EINVAL);
 }
 
-
-
-static int radeon_cp_getparam( DRM_IOCTL_ARGS )
+static int radeon_cp_getparam(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_radeon_private_t *dev_priv = dev->dev_private;
 	drm_radeon_getparam_t param;
 	int value;
 
-	if ( !dev_priv ) {
-		DRM_ERROR( "%s called with no initialization\n", __FUNCTION__ );
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
 		return DRM_ERR(EINVAL);
 	}
 
-	DRM_COPY_FROM_USER_IOCTL( param, (drm_radeon_getparam_t __user *)data,
-			     sizeof(param) );
+	DRM_COPY_FROM_USER_IOCTL(param, (drm_radeon_getparam_t __user *) data,
+				 sizeof(param));
 
-	DRM_DEBUG( "pid=%d\n", DRM_CURRENTPID );
+	DRM_DEBUG("pid=%d\n", DRM_CURRENTPID);
 
-	switch( param.param ) {
+	switch (param.param) {
 	case RADEON_PARAM_GART_BUFFER_OFFSET:
 		value = dev_priv->gart_buffers_offset;
 		break;
 	case RADEON_PARAM_LAST_FRAME:
 		dev_priv->stats.last_frame_reads++;
-		value = GET_SCRATCH( 0 );
+		value = GET_SCRATCH(0);
 		break;
 	case RADEON_PARAM_LAST_DISPATCH:
-		value = GET_SCRATCH( 1 );
+		value = GET_SCRATCH(1);
 		break;
 	case RADEON_PARAM_LAST_CLEAR:
 		dev_priv->stats.last_clear_reads++;
-		value = GET_SCRATCH( 2 );
+		value = GET_SCRATCH(2);
 		break;
 	case RADEON_PARAM_IRQ_NR:
 		value = dev->irq;
@@ -2946,15 +2914,15 @@ static int radeon_cp_getparam( DRM_IOCTL
 		value = dev_priv->ring_rptr_offset;
 		break;
 #if BITS_PER_LONG == 32
-	/*
-	 * This ioctl() doesn't work on 64-bit platforms because hw_lock is a
-	 * pointer which can't fit into an int-sized variable.  According to
-	 * Michel Dnzer, the ioctl() is only used on embedded platforms, so
-	 * not supporting it shouldn't be a problem.  If the same functionality
-	 * is needed on 64-bit platforms, a new ioctl() would have to be added,
-	 * so backwards-compatibility for the embedded platforms can be
-	 * maintained.  --davidm 4-Feb-2004.
-	 */
+		/*
+		 * This ioctl() doesn't work on 64-bit platforms because hw_lock is a
+		 * pointer which can't fit into an int-sized variable.  According to
+		 * Michel Dnzer, the ioctl() is only used on embedded platforms, so
+		 * not supporting it shouldn't be a problem.  If the same functionality
+		 * is needed on 64-bit platforms, a new ioctl() would have to be added,
+		 * so backwards-compatibility for the embedded platforms can be
+		 * maintained.  --davidm 4-Feb-2004.
+		 */
 	case RADEON_PARAM_SAREA_HANDLE:
 		/* The lock is the first dword in the sarea. */
 		value = (long)dev->lock.hw_lock;
@@ -2967,32 +2935,33 @@ static int radeon_cp_getparam( DRM_IOCTL
 		return DRM_ERR(EINVAL);
 	}
 
-	if ( DRM_COPY_TO_USER( param.value, &value, sizeof(int) ) ) {
-		DRM_ERROR( "copy_to_user\n" );
+	if (DRM_COPY_TO_USER(param.value, &value, sizeof(int))) {
+		DRM_ERROR("copy_to_user\n");
 		return DRM_ERR(EFAULT);
 	}
-	
+
 	return 0;
 }
 
-static int radeon_cp_setparam( DRM_IOCTL_ARGS ) {
+static int radeon_cp_setparam(DRM_IOCTL_ARGS)
+{
 	DRM_DEVICE;
 	drm_radeon_private_t *dev_priv = dev->dev_private;
 	drm_file_t *filp_priv;
 	drm_radeon_setparam_t sp;
 	struct drm_radeon_driver_file_fields *radeon_priv;
 
-	if ( !dev_priv ) {
-		DRM_ERROR( "%s called with no initialization\n", __FUNCTION__ );
-		return DRM_ERR( EINVAL );
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return DRM_ERR(EINVAL);
 	}
 
-	DRM_GET_PRIV_WITH_RETURN( filp_priv, filp );
+	DRM_GET_PRIV_WITH_RETURN(filp_priv, filp);
 
-	DRM_COPY_FROM_USER_IOCTL( sp, ( drm_radeon_setparam_t __user * )data,
-				  sizeof( sp ) );
+	DRM_COPY_FROM_USER_IOCTL(sp, (drm_radeon_setparam_t __user *) data,
+				 sizeof(sp));
 
-	switch( sp.param ) {
+	switch (sp.param) {
 	case RADEON_SETPARAM_FB_LOCATION:
 		radeon_priv = filp_priv->driver_priv;
 		radeon_priv->radeon_fb_delta = dev_priv->fb_location - sp.value;
@@ -3010,10 +2979,10 @@ static int radeon_cp_setparam( DRM_IOCTL
 			dev_priv->back_pitch_offset |= RADEON_DST_TILE_MACRO;
 			dev_priv->sarea_priv->tiling_enabled = 1;
 		}
-		break;	
+		break;
 	default:
-		DRM_DEBUG( "Invalid parameter %d\n", sp.param );
-		return DRM_ERR( EINVAL );
+		DRM_DEBUG("Invalid parameter %d\n", sp.param);
+		return DRM_ERR(EINVAL);
 	}
 
 	return 0;
@@ -3022,81 +2991,86 @@ static int radeon_cp_setparam( DRM_IOCTL
 /* When a client dies:
  *    - Check for and clean up flipped page state
  *    - Free any alloced GART memory.
+ *    - Free any alloced radeon surfaces.
  *
  * DRM infrastructure takes care of reclaiming dma buffers.
  */
-void radeon_driver_prerelease(drm_device_t *dev, DRMFILE filp)
+void radeon_driver_prerelease(drm_device_t * dev, DRMFILE filp)
 {
-	if ( dev->dev_private ) {				
-		drm_radeon_private_t *dev_priv = dev->dev_private; 
-		if ( dev_priv->page_flipping ) {		
-			radeon_do_cleanup_pageflip( dev );	
-		}						
-		radeon_mem_release( filp, dev_priv->gart_heap ); 
-		radeon_mem_release( filp, dev_priv->fb_heap );	
+	if (dev->dev_private) {
+		drm_radeon_private_t *dev_priv = dev->dev_private;
+		if (dev_priv->page_flipping) {
+			radeon_do_cleanup_pageflip(dev);
+		}
+		radeon_mem_release(filp, dev_priv->gart_heap);
+		radeon_mem_release(filp, dev_priv->fb_heap);
 		radeon_surfaces_release(filp, dev_priv);
-	}				
+	}
 }
 
-void radeon_driver_pretakedown(drm_device_t *dev)
+void radeon_driver_pretakedown(drm_device_t * dev)
 {
 	radeon_do_release(dev);
 }
 
-int radeon_driver_open_helper(drm_device_t *dev, drm_file_t *filp_priv)
+int radeon_driver_open_helper(drm_device_t * dev, drm_file_t * filp_priv)
 {
 	drm_radeon_private_t *dev_priv = dev->dev_private;
 	struct drm_radeon_driver_file_fields *radeon_priv;
-	
-	radeon_priv = (struct drm_radeon_driver_file_fields *)drm_alloc(sizeof(*radeon_priv), DRM_MEM_FILES);
-	
+
+	DRM_DEBUG("\n");
+	radeon_priv =
+	    (struct drm_radeon_driver_file_fields *)
+	    drm_alloc(sizeof(*radeon_priv), DRM_MEM_FILES);
+
 	if (!radeon_priv)
 		return -ENOMEM;
 
 	filp_priv->driver_priv = radeon_priv;
-	if ( dev_priv )
+
+	if (dev_priv)
 		radeon_priv->radeon_fb_delta = dev_priv->fb_location;
 	else
 		radeon_priv->radeon_fb_delta = 0;
 	return 0;
 }
 
-
-void radeon_driver_free_filp_priv(drm_device_t *dev, drm_file_t *filp_priv)
+void radeon_driver_free_filp_priv(drm_device_t * dev, drm_file_t * filp_priv)
 {
-	 struct drm_radeon_driver_file_fields *radeon_priv = filp_priv->driver_priv;
-	 
-	 drm_free(radeon_priv, sizeof(*radeon_priv), DRM_MEM_FILES);
+	struct drm_radeon_driver_file_fields *radeon_priv =
+	    filp_priv->driver_priv;
+
+	drm_free(radeon_priv, sizeof(*radeon_priv), DRM_MEM_FILES);
 }
 
 drm_ioctl_desc_t radeon_ioctls[] = {
-	[DRM_IOCTL_NR(DRM_RADEON_CP_INIT)]    = { radeon_cp_init,      1, 1 },
-	[DRM_IOCTL_NR(DRM_RADEON_CP_START)]   = { radeon_cp_start,     1, 1 },
-	[DRM_IOCTL_NR(DRM_RADEON_CP_STOP)]    = { radeon_cp_stop,      1, 1 },
-	[DRM_IOCTL_NR(DRM_RADEON_CP_RESET)]   = { radeon_cp_reset,     1, 1 },
-	[DRM_IOCTL_NR(DRM_RADEON_CP_IDLE)]    = { radeon_cp_idle,      1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_CP_RESUME)]  = { radeon_cp_resume,    1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_RESET)]      = { radeon_engine_reset, 1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_FULLSCREEN)] = { radeon_fullscreen,   1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_SWAP)]       = { radeon_cp_swap,      1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_CLEAR)]      = { radeon_cp_clear,     1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_VERTEX)]     = { radeon_cp_vertex,    1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_INDICES)]    = { radeon_cp_indices,   1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_TEXTURE)]    = { radeon_cp_texture,   1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_STIPPLE)]    = { radeon_cp_stipple,   1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_INDIRECT)]   = { radeon_cp_indirect,  1, 1 },
-	[DRM_IOCTL_NR(DRM_RADEON_VERTEX2)]    = { radeon_cp_vertex2,   1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_CMDBUF)]     = { radeon_cp_cmdbuf,    1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_GETPARAM)]   = { radeon_cp_getparam,  1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_FLIP)]       = { radeon_cp_flip,      1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_ALLOC)]      = { radeon_mem_alloc,    1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_FREE)]       = { radeon_mem_free,     1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_INIT_HEAP)]  = { radeon_mem_init_heap,1, 1 },
-	[DRM_IOCTL_NR(DRM_RADEON_IRQ_EMIT)]   = { radeon_irq_emit,     1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_IRQ_WAIT)]   = { radeon_irq_wait,     1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_SETPARAM)]   = { radeon_cp_setparam,  1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_SURF_ALLOC)] = { radeon_surface_alloc,1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_SURF_FREE)]  = { radeon_surface_free, 1, 0 }
+	[DRM_IOCTL_NR(DRM_RADEON_CP_INIT)] = {radeon_cp_init, 1, 1},
+	[DRM_IOCTL_NR(DRM_RADEON_CP_START)] = {radeon_cp_start, 1, 1},
+	[DRM_IOCTL_NR(DRM_RADEON_CP_STOP)] = {radeon_cp_stop, 1, 1},
+	[DRM_IOCTL_NR(DRM_RADEON_CP_RESET)] = {radeon_cp_reset, 1, 1},
+	[DRM_IOCTL_NR(DRM_RADEON_CP_IDLE)] = {radeon_cp_idle, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_CP_RESUME)] = {radeon_cp_resume, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_RESET)] = {radeon_engine_reset, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_FULLSCREEN)] = {radeon_fullscreen, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_SWAP)] = {radeon_cp_swap, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_CLEAR)] = {radeon_cp_clear, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_VERTEX)] = {radeon_cp_vertex, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_INDICES)] = {radeon_cp_indices, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_TEXTURE)] = {radeon_cp_texture, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_STIPPLE)] = {radeon_cp_stipple, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_INDIRECT)] = {radeon_cp_indirect, 1, 1},
+	[DRM_IOCTL_NR(DRM_RADEON_VERTEX2)] = {radeon_cp_vertex2, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_CMDBUF)] = {radeon_cp_cmdbuf, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_GETPARAM)] = {radeon_cp_getparam, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_FLIP)] = {radeon_cp_flip, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_ALLOC)] = {radeon_mem_alloc, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_FREE)] = {radeon_mem_free, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_INIT_HEAP)] = {radeon_mem_init_heap, 1, 1},
+	[DRM_IOCTL_NR(DRM_RADEON_IRQ_EMIT)] = {radeon_irq_emit, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_IRQ_WAIT)] = {radeon_irq_wait, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_SETPARAM)] = {radeon_cp_setparam, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_SURF_ALLOC)] = {radeon_surface_alloc, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_SURF_FREE)] = {radeon_surface_free, 1, 0}
 };
 
 int radeon_max_ioctl = DRM_ARRAY_SIZE(radeon_ioctls);
diff -purN linux-2.6.12.orig/drivers/char/drm/savage_bci.c linux-2.6.12/drivers/char/drm/savage_bci.c
--- linux-2.6.12.orig/drivers/char/drm/savage_bci.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/drm/savage_bci.c	2005-07-05 08:37:47.000000000 +0200
@@ -0,0 +1,1086 @@
+/* savage_bci.c -- BCI support for Savage
+ *
+ * Copyright 2004  Felix Kuehling
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT. IN NO EVENT SHALL FELIX KUEHLING BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
+ * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include "drmP.h"
+#include "savage_drm.h"
+#include "savage_drv.h"
+
+/* Need a long timeout for shadow status updates can take a while
+ * and so can waiting for events when the queue is full. */
+#define SAVAGE_DEFAULT_USEC_TIMEOUT	1000000 /* 1s */
+#define SAVAGE_EVENT_USEC_TIMEOUT	5000000 /* 5s */
+#define SAVAGE_FREELIST_DEBUG		0
+
+static int
+savage_bci_wait_fifo_shadow(drm_savage_private_t *dev_priv, unsigned int n)
+{
+	uint32_t mask = dev_priv->status_used_mask;
+	uint32_t threshold = dev_priv->bci_threshold_hi;
+	uint32_t status;
+	int i;
+
+#if SAVAGE_BCI_DEBUG
+	if (n > dev_priv->cob_size + SAVAGE_BCI_FIFO_SIZE - threshold)
+		DRM_ERROR("Trying to emit %d words "
+			  "(more than guaranteed space in COB)\n", n);
+#endif
+
+	for (i = 0; i < SAVAGE_DEFAULT_USEC_TIMEOUT; i++) {
+		DRM_MEMORYBARRIER();
+		status = dev_priv->status_ptr[0];
+		if ((status & mask) < threshold)
+			return 0;
+		DRM_UDELAY(1);
+	}
+
+#if SAVAGE_BCI_DEBUG
+	DRM_ERROR("failed!\n");
+	DRM_INFO("   status=0x%08x, threshold=0x%08x\n", status, threshold);
+#endif
+	return DRM_ERR(EBUSY);
+}
+
+static int
+savage_bci_wait_fifo_s3d(drm_savage_private_t *dev_priv, unsigned int n)
+{
+	uint32_t maxUsed = dev_priv->cob_size + SAVAGE_BCI_FIFO_SIZE - n;
+	uint32_t status;
+	int i;
+
+	for (i = 0; i < SAVAGE_DEFAULT_USEC_TIMEOUT; i++) {
+		status = SAVAGE_READ(SAVAGE_STATUS_WORD0);
+		if ((status & SAVAGE_FIFO_USED_MASK_S3D) <= maxUsed)
+			return 0;
+		DRM_UDELAY(1);
+	}
+
+#if SAVAGE_BCI_DEBUG
+	DRM_ERROR("failed!\n");
+	DRM_INFO("   status=0x%08x\n", status);
+#endif
+	return DRM_ERR(EBUSY);
+}
+
+static int
+savage_bci_wait_fifo_s4(drm_savage_private_t *dev_priv, unsigned int n)
+{
+	uint32_t maxUsed = dev_priv->cob_size + SAVAGE_BCI_FIFO_SIZE - n;
+	uint32_t status;
+	int i;
+
+	for (i = 0; i < SAVAGE_DEFAULT_USEC_TIMEOUT; i++) {
+		status = SAVAGE_READ(SAVAGE_ALT_STATUS_WORD0);
+		if ((status & SAVAGE_FIFO_USED_MASK_S4) <= maxUsed)
+			return 0;
+		DRM_UDELAY(1);
+	}
+
+#if SAVAGE_BCI_DEBUG
+	DRM_ERROR("failed!\n");
+	DRM_INFO("   status=0x%08x\n", status);
+#endif
+	return DRM_ERR(EBUSY);
+}
+
+/*
+ * Waiting for events.
+ *
+ * The BIOSresets the event tag to 0 on mode changes. Therefore we
+ * never emit 0 to the event tag. If we find a 0 event tag we know the
+ * BIOS stomped on it and return success assuming that the BIOS waited
+ * for engine idle.
+ *
+ * Note: if the Xserver uses the event tag it has to follow the same
+ * rule. Otherwise there may be glitches every 2^16 events.
+ */
+static int
+savage_bci_wait_event_shadow(drm_savage_private_t *dev_priv, uint16_t e)
+{
+	uint32_t status;
+	int i;
+
+	for (i = 0; i < SAVAGE_EVENT_USEC_TIMEOUT; i++) {
+		DRM_MEMORYBARRIER();
+		status = dev_priv->status_ptr[1];
+		if ((((status & 0xffff) - e) & 0xffff) <= 0x7fff ||
+		    (status & 0xffff) == 0)
+			return 0;
+		DRM_UDELAY(1);
+	}
+
+#if SAVAGE_BCI_DEBUG
+	DRM_ERROR("failed!\n");
+	DRM_INFO("   status=0x%08x, e=0x%04x\n", status, e);
+#endif
+
+	return DRM_ERR(EBUSY);
+}
+
+static int
+savage_bci_wait_event_reg(drm_savage_private_t *dev_priv, uint16_t e)
+{
+	uint32_t status;
+	int i;
+
+	for (i = 0; i < SAVAGE_EVENT_USEC_TIMEOUT; i++) {
+		status = SAVAGE_READ(SAVAGE_STATUS_WORD1);
+		if ((((status & 0xffff) - e) & 0xffff) <= 0x7fff ||
+		    (status & 0xffff) == 0)
+			return 0;
+		DRM_UDELAY(1);
+	}
+
+#if SAVAGE_BCI_DEBUG
+	DRM_ERROR("failed!\n");
+	DRM_INFO("   status=0x%08x, e=0x%04x\n", status, e);
+#endif
+
+	return DRM_ERR(EBUSY);
+}
+
+uint16_t savage_bci_emit_event(drm_savage_private_t *dev_priv,
+			       unsigned int flags)
+{
+	uint16_t count;
+	BCI_LOCALS;
+
+	if (dev_priv->status_ptr) {
+		/* coordinate with Xserver */
+		count = dev_priv->status_ptr[1023];
+		if (count < dev_priv->event_counter)
+			dev_priv->event_wrap++;
+	} else {
+		count = dev_priv->event_counter;
+	}
+	count = (count + 1) & 0xffff;
+	if (count == 0) {
+		count++; /* See the comment above savage_wait_event_*. */
+		dev_priv->event_wrap++;
+	}
+	dev_priv->event_counter = count;
+	if (dev_priv->status_ptr)
+		dev_priv->status_ptr[1023] = (uint32_t)count;
+
+	if ((flags & (SAVAGE_WAIT_2D | SAVAGE_WAIT_3D))) {
+		unsigned int wait_cmd = BCI_CMD_WAIT;
+		if ((flags & SAVAGE_WAIT_2D))
+			wait_cmd |= BCI_CMD_WAIT_2D;
+		if ((flags & SAVAGE_WAIT_3D))
+			wait_cmd |= BCI_CMD_WAIT_3D;
+		BEGIN_BCI(2);
+		BCI_WRITE(wait_cmd);
+	} else {
+		BEGIN_BCI(1);
+	}
+	BCI_WRITE(BCI_CMD_UPDATE_EVENT_TAG | (uint32_t)count);
+
+	return count;
+}
+
+/*
+ * Freelist management
+ */
+static int savage_freelist_init(drm_device_t *dev)
+{
+	drm_savage_private_t *dev_priv = dev->dev_private;
+	drm_device_dma_t *dma = dev->dma;
+	drm_buf_t *buf;
+	drm_savage_buf_priv_t *entry;
+	int i;
+	DRM_DEBUG("count=%d\n", dma->buf_count);
+
+	dev_priv->head.next = &dev_priv->tail;
+	dev_priv->head.prev = NULL;
+	dev_priv->head.buf = NULL;
+
+	dev_priv->tail.next = NULL;
+	dev_priv->tail.prev = &dev_priv->head;
+	dev_priv->tail.buf = NULL;
+
+	for (i = 0; i < dma->buf_count; i++) {
+		buf = dma->buflist[i];
+		entry = buf->dev_private;
+
+		SET_AGE(&entry->age, 0, 0);
+		entry->buf = buf;
+
+		entry->next = dev_priv->head.next;
+		entry->prev = &dev_priv->head;
+		dev_priv->head.next->prev = entry;
+		dev_priv->head.next = entry;
+	}
+
+	return 0;
+}
+
+static drm_buf_t *savage_freelist_get(drm_device_t *dev)
+{
+	drm_savage_private_t *dev_priv = dev->dev_private;
+	drm_savage_buf_priv_t *tail = dev_priv->tail.prev;
+	uint16_t event;
+	unsigned int wrap;
+	DRM_DEBUG("\n");
+
+	UPDATE_EVENT_COUNTER();
+	if (dev_priv->status_ptr)
+		event = dev_priv->status_ptr[1] & 0xffff;
+	else
+		event = SAVAGE_READ(SAVAGE_STATUS_WORD1) & 0xffff;
+	wrap = dev_priv->event_wrap;
+	if (event > dev_priv->event_counter)
+		wrap--; /* hardware hasn't passed the last wrap yet */
+
+	DRM_DEBUG("   tail=0x%04x %d\n", tail->age.event, tail->age.wrap);
+	DRM_DEBUG("   head=0x%04x %d\n", event, wrap);
+
+	if (tail->buf && (TEST_AGE(&tail->age, event, wrap) || event == 0)) {
+		drm_savage_buf_priv_t *next = tail->next;
+		drm_savage_buf_priv_t *prev = tail->prev;
+		prev->next = next;
+		next->prev = prev;
+		tail->next = tail->prev = NULL;
+		return tail->buf;
+	}
+
+	DRM_DEBUG("returning NULL, tail->buf=%p!\n", tail->buf);
+	return NULL;
+}
+
+void savage_freelist_put(drm_device_t *dev, drm_buf_t *buf)
+{
+	drm_savage_private_t *dev_priv = dev->dev_private;
+	drm_savage_buf_priv_t *entry = buf->dev_private, *prev, *next;
+
+	DRM_DEBUG("age=0x%04x wrap=%d\n", entry->age.event, entry->age.wrap);
+
+	if (entry->next != NULL || entry->prev != NULL) {
+		DRM_ERROR("entry already on freelist.\n");
+		return;
+	}
+
+	prev = &dev_priv->head;
+	next = prev->next;
+	prev->next = entry;
+	next->prev = entry;
+	entry->prev = prev;
+	entry->next = next;
+}
+
+/*
+ * Command DMA
+ */
+static int savage_dma_init(drm_savage_private_t *dev_priv)
+{
+	unsigned int i;
+
+	dev_priv->nr_dma_pages = dev_priv->cmd_dma->size /
+		(SAVAGE_DMA_PAGE_SIZE*4);
+	dev_priv->dma_pages = drm_alloc(sizeof(drm_savage_dma_page_t) *
+					dev_priv->nr_dma_pages,
+					DRM_MEM_DRIVER);
+	if (dev_priv->dma_pages == NULL)
+		return DRM_ERR(ENOMEM);
+
+	for (i = 0; i < dev_priv->nr_dma_pages; ++i) {
+		SET_AGE(&dev_priv->dma_pages[i].age, 0, 0);
+		dev_priv->dma_pages[i].used = 0;
+		dev_priv->dma_pages[i].flushed = 0;
+	}
+	SET_AGE(&dev_priv->last_dma_age, 0, 0);
+
+	dev_priv->first_dma_page = 0;
+	dev_priv->current_dma_page = 0;
+
+	return 0;
+}
+
+void savage_dma_reset(drm_savage_private_t *dev_priv)
+{
+	uint16_t event;
+	unsigned int wrap, i;
+	event = savage_bci_emit_event(dev_priv, 0);
+	wrap = dev_priv->event_wrap;
+	for (i = 0; i < dev_priv->nr_dma_pages; ++i) {
+		SET_AGE(&dev_priv->dma_pages[i].age, event, wrap);
+		dev_priv->dma_pages[i].used = 0;
+		dev_priv->dma_pages[i].flushed = 0;
+	}
+	SET_AGE(&dev_priv->last_dma_age, event, wrap);
+	dev_priv->first_dma_page = dev_priv->current_dma_page = 0;
+}
+
+void savage_dma_wait(drm_savage_private_t *dev_priv, unsigned int page)
+{
+	uint16_t event;
+	unsigned int wrap;
+
+	/* Faked DMA buffer pages don't age. */
+	if (dev_priv->cmd_dma == &dev_priv->fake_dma)
+		return;
+
+	UPDATE_EVENT_COUNTER();
+	if (dev_priv->status_ptr)
+		event = dev_priv->status_ptr[1] & 0xffff;
+	else
+		event = SAVAGE_READ(SAVAGE_STATUS_WORD1) & 0xffff;
+	wrap = dev_priv->event_wrap;
+	if (event > dev_priv->event_counter)
+		wrap--; /* hardware hasn't passed the last wrap yet */
+
+	if (dev_priv->dma_pages[page].age.wrap > wrap ||
+	    (dev_priv->dma_pages[page].age.wrap == wrap &&
+	     dev_priv->dma_pages[page].age.event > event)) {
+		if (dev_priv->wait_evnt(dev_priv,
+					dev_priv->dma_pages[page].age.event)
+		    < 0)
+			DRM_ERROR("wait_evnt failed!\n");
+	}
+}
+
+uint32_t *savage_dma_alloc(drm_savage_private_t *dev_priv, unsigned int n)
+{
+	unsigned int cur = dev_priv->current_dma_page;
+	unsigned int rest = SAVAGE_DMA_PAGE_SIZE -
+		dev_priv->dma_pages[cur].used;
+	unsigned int nr_pages = (n - rest + SAVAGE_DMA_PAGE_SIZE-1) /
+		SAVAGE_DMA_PAGE_SIZE;
+	uint32_t *dma_ptr;
+	unsigned int i;
+
+	DRM_DEBUG("cur=%u, cur->used=%u, n=%u, rest=%u, nr_pages=%u\n",
+		  cur, dev_priv->dma_pages[cur].used, n, rest, nr_pages);
+
+	if (cur + nr_pages < dev_priv->nr_dma_pages) {
+		dma_ptr = (uint32_t *)dev_priv->cmd_dma->handle +
+			cur*SAVAGE_DMA_PAGE_SIZE +
+			dev_priv->dma_pages[cur].used;
+		if (n < rest)
+			rest = n;
+		dev_priv->dma_pages[cur].used += rest;
+		n -= rest;
+		cur++;
+	} else {
+		dev_priv->dma_flush(dev_priv);
+		nr_pages = (n + SAVAGE_DMA_PAGE_SIZE-1) / SAVAGE_DMA_PAGE_SIZE;
+		for (i = cur; i < dev_priv->nr_dma_pages; ++i) {
+			dev_priv->dma_pages[i].age = dev_priv->last_dma_age;
+			dev_priv->dma_pages[i].used = 0;
+			dev_priv->dma_pages[i].flushed = 0;
+		}
+		dma_ptr = (uint32_t *)dev_priv->cmd_dma->handle;
+		dev_priv->first_dma_page = cur = 0;
+	}
+	for (i = cur; nr_pages > 0; ++i, --nr_pages) {
+#if SAVAGE_DMA_DEBUG
+		if (dev_priv->dma_pages[i].used) {
+			DRM_ERROR("unflushed page %u: used=%u\n",
+				  i, dev_priv->dma_pages[i].used);
+		}
+#endif
+		if (n > SAVAGE_DMA_PAGE_SIZE)
+			dev_priv->dma_pages[i].used = SAVAGE_DMA_PAGE_SIZE;
+		else
+			dev_priv->dma_pages[i].used = n;
+		n -= SAVAGE_DMA_PAGE_SIZE;
+	}
+	dev_priv->current_dma_page = --i;
+
+	DRM_DEBUG("cur=%u, cur->used=%u, n=%u\n",
+		  i, dev_priv->dma_pages[i].used, n);
+
+	savage_dma_wait(dev_priv, dev_priv->current_dma_page);
+
+	return dma_ptr;
+}
+
+static void savage_dma_flush(drm_savage_private_t *dev_priv)
+{
+	unsigned int first = dev_priv->first_dma_page;
+	unsigned int cur = dev_priv->current_dma_page;
+	uint16_t event;
+	unsigned int wrap, pad, align, len, i;
+	unsigned long phys_addr;
+	BCI_LOCALS;
+
+	if (first == cur &&
+	    dev_priv->dma_pages[cur].used == dev_priv->dma_pages[cur].flushed)
+		return;
+
+	/* pad length to multiples of 2 entries
+	 * align start of next DMA block to multiles of 8 entries */
+	pad = -dev_priv->dma_pages[cur].used & 1;
+	align = -(dev_priv->dma_pages[cur].used + pad) & 7;
+
+	DRM_DEBUG("first=%u, cur=%u, first->flushed=%u, cur->used=%u, "
+		  "pad=%u, align=%u\n",
+		  first, cur, dev_priv->dma_pages[first].flushed,
+		  dev_priv->dma_pages[cur].used, pad, align);
+
+	/* pad with noops */
+	if (pad) {
+		uint32_t *dma_ptr = (uint32_t *)dev_priv->cmd_dma->handle +
+			cur * SAVAGE_DMA_PAGE_SIZE +
+			dev_priv->dma_pages[cur].used;
+		dev_priv->dma_pages[cur].used += pad;
+		while(pad != 0) {
+			*dma_ptr++ = BCI_CMD_WAIT;
+			pad--;
+		}
+	}
+
+	DRM_MEMORYBARRIER();
+
+	/* do flush ... */
+	phys_addr = dev_priv->cmd_dma->offset +
+		(first * SAVAGE_DMA_PAGE_SIZE +
+		 dev_priv->dma_pages[first].flushed) * 4;
+	len = (cur - first) * SAVAGE_DMA_PAGE_SIZE +
+		dev_priv->dma_pages[cur].used -
+		dev_priv->dma_pages[first].flushed;
+
+	DRM_DEBUG("phys_addr=%lx, len=%u\n",
+		  phys_addr | dev_priv->dma_type, len);
+
+	BEGIN_BCI(3);
+	BCI_SET_REGISTERS(SAVAGE_DMABUFADDR, 1);
+	BCI_WRITE(phys_addr | dev_priv->dma_type);
+	BCI_DMA(len);
+
+	/* fix alignment of the start of the next block */
+	dev_priv->dma_pages[cur].used += align;
+
+	/* age DMA pages */
+	event = savage_bci_emit_event(dev_priv, 0);
+	wrap = dev_priv->event_wrap;
+	for (i = first; i < cur; ++i) {
+		SET_AGE(&dev_priv->dma_pages[i].age, event, wrap);
+		dev_priv->dma_pages[i].used = 0;
+		dev_priv->dma_pages[i].flushed = 0;
+	}
+	/* age the current page only when it's full */
+	if (dev_priv->dma_pages[cur].used == SAVAGE_DMA_PAGE_SIZE) {
+		SET_AGE(&dev_priv->dma_pages[cur].age, event, wrap);
+		dev_priv->dma_pages[cur].used = 0;
+		dev_priv->dma_pages[cur].flushed = 0;
+		/* advance to next page */
+		cur++;
+		if (cur == dev_priv->nr_dma_pages)
+			cur = 0;
+		dev_priv->first_dma_page = dev_priv->current_dma_page = cur;
+	} else {
+		dev_priv->first_dma_page = cur;
+		dev_priv->dma_pages[cur].flushed = dev_priv->dma_pages[i].used;
+	}
+	SET_AGE(&dev_priv->last_dma_age, event, wrap);
+
+	DRM_DEBUG("first=cur=%u, cur->used=%u, cur->flushed=%u\n", cur,
+		  dev_priv->dma_pages[cur].used,
+		  dev_priv->dma_pages[cur].flushed);
+}
+
+static void savage_fake_dma_flush(drm_savage_private_t *dev_priv)
+{
+	unsigned int i, j;
+	BCI_LOCALS;
+
+	if (dev_priv->first_dma_page == dev_priv->current_dma_page &&
+	    dev_priv->dma_pages[dev_priv->current_dma_page].used == 0)
+		return;
+
+	DRM_DEBUG("first=%u, cur=%u, cur->used=%u\n",
+		  dev_priv->first_dma_page, dev_priv->current_dma_page,
+		  dev_priv->dma_pages[dev_priv->current_dma_page].used);
+
+	for (i = dev_priv->first_dma_page;
+	     i <= dev_priv->current_dma_page && dev_priv->dma_pages[i].used;
+	     ++i) {
+		uint32_t *dma_ptr = (uint32_t *)dev_priv->cmd_dma->handle +
+			i * SAVAGE_DMA_PAGE_SIZE;
+#if SAVAGE_DMA_DEBUG
+		/* Sanity check: all pages except the last one must be full. */
+		if (i < dev_priv->current_dma_page &&
+		    dev_priv->dma_pages[i].used != SAVAGE_DMA_PAGE_SIZE) {
+			DRM_ERROR("partial DMA page %u: used=%u",
+				  i, dev_priv->dma_pages[i].used);
+		}
+#endif
+		BEGIN_BCI(dev_priv->dma_pages[i].used);
+		for (j = 0; j < dev_priv->dma_pages[i].used; ++j) {
+			BCI_WRITE(dma_ptr[j]);
+		}
+		dev_priv->dma_pages[i].used = 0;
+	}
+
+	/* reset to first page */
+	dev_priv->first_dma_page = dev_priv->current_dma_page = 0;
+}
+
+/*
+ * Initalize mappings. On Savage4 and SavageIX the alignment
+ * and size of the aperture is not suitable for automatic MTRR setup
+ * in drm_addmap. Therefore we do it manually before the maps are
+ * initialized. We also need to take care of deleting the MTRRs in
+ * postcleanup.
+ */
+int savage_preinit(drm_device_t *dev, unsigned long chipset)
+{
+	drm_savage_private_t *dev_priv;
+	unsigned long mmio_base, fb_base, fb_size, aperture_base;
+	/* fb_rsrc and aper_rsrc aren't really used currently, but still exist
+	 * in case we decide we need information on the BAR for BSD in the
+	 * future.
+	 */
+	unsigned int fb_rsrc, aper_rsrc;
+	int ret = 0;
+
+	dev_priv = drm_alloc(sizeof(drm_savage_private_t), DRM_MEM_DRIVER);
+	if (dev_priv == NULL)
+		return DRM_ERR(ENOMEM);
+
+	memset(dev_priv, 0, sizeof(drm_savage_private_t));
+	dev->dev_private = (void *)dev_priv;
+	dev_priv->chipset = (enum savage_family)chipset;
+
+	dev_priv->mtrr[0].handle = -1;
+	dev_priv->mtrr[1].handle = -1;
+	dev_priv->mtrr[2].handle = -1;
+	if (S3_SAVAGE3D_SERIES(dev_priv->chipset)) {
+		fb_rsrc = 0;
+		fb_base = drm_get_resource_start(dev, 0);
+		fb_size = SAVAGE_FB_SIZE_S3;
+		mmio_base = fb_base + SAVAGE_FB_SIZE_S3;
+		aper_rsrc = 0;
+		aperture_base = fb_base + SAVAGE_APERTURE_OFFSET;
+		/* this should always be true */
+		if (drm_get_resource_len(dev, 0) == 0x08000000) {
+			/* Don't make MMIO write-cobining! We need 3
+			 * MTRRs. */
+			dev_priv->mtrr[0].base = fb_base;
+			dev_priv->mtrr[0].size = 0x01000000;
+			dev_priv->mtrr[0].handle = mtrr_add(
+				dev_priv->mtrr[0].base, dev_priv->mtrr[0].size,
+				MTRR_TYPE_WRCOMB, 1);
+			dev_priv->mtrr[1].base = fb_base+0x02000000;
+			dev_priv->mtrr[1].size = 0x02000000;
+			dev_priv->mtrr[1].handle = mtrr_add(
+				dev_priv->mtrr[1].base, dev_priv->mtrr[1].size,
+				MTRR_TYPE_WRCOMB, 1);
+			dev_priv->mtrr[2].base = fb_base+0x04000000;
+			dev_priv->mtrr[2].size = 0x04000000;
+			dev_priv->mtrr[2].handle = mtrr_add(
+				dev_priv->mtrr[2].base, dev_priv->mtrr[2].size,
+				MTRR_TYPE_WRCOMB, 1);
+		} else {
+			DRM_ERROR("strange pci_resource_len %08lx\n",
+				  drm_get_resource_len(dev, 0));
+		}
+	} else if (chipset != S3_SUPERSAVAGE && chipset != S3_SAVAGE2000) {
+		mmio_base = drm_get_resource_start(dev, 0);
+		fb_rsrc = 1;
+		fb_base = drm_get_resource_start(dev, 1);
+		fb_size = SAVAGE_FB_SIZE_S4;
+		aper_rsrc = 1;
+		aperture_base = fb_base + SAVAGE_APERTURE_OFFSET;
+		/* this should always be true */
+		if (drm_get_resource_len(dev, 1) == 0x08000000) {
+			/* Can use one MTRR to cover both fb and
+			 * aperture. */
+			dev_priv->mtrr[0].base = fb_base;
+			dev_priv->mtrr[0].size = 0x08000000;
+			dev_priv->mtrr[0].handle = mtrr_add(
+				dev_priv->mtrr[0].base, dev_priv->mtrr[0].size,
+				MTRR_TYPE_WRCOMB, 1);
+		} else {
+			DRM_ERROR("strange pci_resource_len %08lx\n",
+				  drm_get_resource_len(dev, 1));
+		}
+	} else {
+		mmio_base = drm_get_resource_start(dev, 0);
+		fb_rsrc = 1;
+		fb_base = drm_get_resource_start(dev, 1);
+		fb_size = drm_get_resource_len(dev, 1);
+		aper_rsrc = 2;
+		aperture_base = drm_get_resource_start(dev, 2);
+		/* Automatic MTRR setup will do the right thing. */
+	}
+
+	ret = drm_addmap(dev, mmio_base, SAVAGE_MMIO_SIZE, _DRM_REGISTERS,
+			 _DRM_READ_ONLY, &dev_priv->mmio);
+	if (ret)
+		return ret;
+
+	ret = drm_addmap(dev, fb_base, fb_size, _DRM_FRAME_BUFFER,
+			 _DRM_WRITE_COMBINING, &dev_priv->fb);
+	if (ret)
+		return ret;
+
+	ret = drm_addmap(dev, aperture_base, SAVAGE_APERTURE_SIZE,
+			 _DRM_FRAME_BUFFER, _DRM_WRITE_COMBINING,
+			 &dev_priv->aperture);
+	if (ret)
+		return ret;
+
+	return ret;
+}
+
+/*
+ * Delete MTRRs and free device-private data.
+ */
+int savage_postcleanup(drm_device_t *dev)
+{
+	drm_savage_private_t *dev_priv = dev->dev_private;
+	int i;
+
+	for (i = 0; i < 3; ++i)
+		if (dev_priv->mtrr[i].handle >= 0)
+			mtrr_del(dev_priv->mtrr[i].handle,
+				 dev_priv->mtrr[i].base,
+				 dev_priv->mtrr[i].size);
+
+	drm_free(dev_priv, sizeof(drm_savage_private_t), DRM_MEM_DRIVER);
+
+	return 0;
+}
+
+static int savage_do_init_bci(drm_device_t *dev, drm_savage_init_t *init)
+{
+	drm_savage_private_t *dev_priv = dev->dev_private;
+
+	if (init->fb_bpp != 16 && init->fb_bpp != 32) {
+		DRM_ERROR("invalid frame buffer bpp %d!\n", init->fb_bpp);
+		return DRM_ERR(EINVAL);
+	}
+	if (init->depth_bpp != 16 && init->depth_bpp != 32) {
+		DRM_ERROR("invalid depth buffer bpp %d!\n", init->fb_bpp);
+		return DRM_ERR(EINVAL);
+	}
+	if (init->dma_type != SAVAGE_DMA_AGP &&
+	    init->dma_type != SAVAGE_DMA_PCI) {
+		DRM_ERROR("invalid dma memory type %d!\n", init->dma_type);
+		return DRM_ERR(EINVAL);
+	}
+
+	dev_priv->cob_size = init->cob_size;
+	dev_priv->bci_threshold_lo = init->bci_threshold_lo;
+	dev_priv->bci_threshold_hi = init->bci_threshold_hi;
+	dev_priv->dma_type = init->dma_type;
+
+	dev_priv->fb_bpp = init->fb_bpp;
+	dev_priv->front_offset = init->front_offset;
+	dev_priv->front_pitch = init->front_pitch;
+	dev_priv->back_offset = init->back_offset;
+	dev_priv->back_pitch = init->back_pitch;
+	dev_priv->depth_bpp = init->depth_bpp;
+	dev_priv->depth_offset = init->depth_offset;
+	dev_priv->depth_pitch = init->depth_pitch;
+
+	dev_priv->texture_offset = init->texture_offset;
+	dev_priv->texture_size = init->texture_size;
+
+	DRM_GETSAREA();
+	if (!dev_priv->sarea) {
+		DRM_ERROR("could not find sarea!\n");
+		savage_do_cleanup_bci(dev);
+		return DRM_ERR(EINVAL);
+	}
+	if (init->status_offset != 0) {
+		dev_priv->status = drm_core_findmap(dev, init->status_offset);
+		if (!dev_priv->status) {
+			DRM_ERROR("could not find shadow status region!\n");
+			savage_do_cleanup_bci(dev);
+			return DRM_ERR(EINVAL);
+		}
+	} else {
+		dev_priv->status = NULL;
+	}
+	if (dev_priv->dma_type == SAVAGE_DMA_AGP && init->buffers_offset) {
+		dev->agp_buffer_map = drm_core_findmap(dev,
+						       init->buffers_offset);
+		if (!dev->agp_buffer_map) {
+			DRM_ERROR("could not find DMA buffer region!\n");
+			savage_do_cleanup_bci(dev);
+			return DRM_ERR(EINVAL);
+		}
+		drm_core_ioremap(dev->agp_buffer_map, dev);
+		if (!dev->agp_buffer_map) {
+			DRM_ERROR("failed to ioremap DMA buffer region!\n");
+			savage_do_cleanup_bci(dev);
+			return DRM_ERR(ENOMEM);
+		}
+	}
+	if (init->agp_textures_offset) {
+		dev_priv->agp_textures =
+			drm_core_findmap(dev, init->agp_textures_offset);
+		if (!dev_priv->agp_textures) {
+			DRM_ERROR("could not find agp texture region!\n");
+			savage_do_cleanup_bci(dev);
+			return DRM_ERR(EINVAL);
+		}
+	} else {
+		dev_priv->agp_textures = NULL;
+	}
+
+	if (init->cmd_dma_offset) {
+		if (S3_SAVAGE3D_SERIES(dev_priv->chipset)) {
+			DRM_ERROR("command DMA not supported on "
+				  "Savage3D/MX/IX.\n");
+			savage_do_cleanup_bci(dev);
+			return DRM_ERR(EINVAL);
+		}
+		if (dev->dma && dev->dma->buflist) {
+			DRM_ERROR("command and vertex DMA not supported "
+				  "at the same time.\n");
+			savage_do_cleanup_bci(dev);
+			return DRM_ERR(EINVAL);
+		}
+		dev_priv->cmd_dma = drm_core_findmap(dev, init->cmd_dma_offset);
+		if (!dev_priv->cmd_dma) {
+			DRM_ERROR("could not find command DMA region!\n");
+			savage_do_cleanup_bci(dev);
+			return DRM_ERR(EINVAL);
+		}
+		if (dev_priv->dma_type == SAVAGE_DMA_AGP) {
+			if (dev_priv->cmd_dma->type != _DRM_AGP) {
+				DRM_ERROR("AGP command DMA region is not a "
+					  "_DRM_AGP map!\n");
+				savage_do_cleanup_bci(dev);
+				return DRM_ERR(EINVAL);
+			}
+			drm_core_ioremap(dev_priv->cmd_dma, dev);
+			if (!dev_priv->cmd_dma->handle) {
+				DRM_ERROR("failed to ioremap command "
+					  "DMA region!\n");
+				savage_do_cleanup_bci(dev);
+				return DRM_ERR(ENOMEM);
+			}
+		} else if (dev_priv->cmd_dma->type != _DRM_CONSISTENT) {
+			DRM_ERROR("PCI command DMA region is not a "
+				  "_DRM_CONSISTENT map!\n");
+			savage_do_cleanup_bci(dev);
+			return DRM_ERR(EINVAL);
+		}
+	} else {
+		dev_priv->cmd_dma = NULL;
+	}
+
+	dev_priv->dma_flush = savage_dma_flush;
+	if (!dev_priv->cmd_dma) {
+		DRM_DEBUG("falling back to faked command DMA.\n");
+		dev_priv->fake_dma.offset = 0;
+		dev_priv->fake_dma.size = SAVAGE_FAKE_DMA_SIZE;
+		dev_priv->fake_dma.type = _DRM_SHM;
+		dev_priv->fake_dma.handle = drm_alloc(SAVAGE_FAKE_DMA_SIZE,
+						      DRM_MEM_DRIVER);
+		if (!dev_priv->fake_dma.handle) {
+			DRM_ERROR("could not allocate faked DMA buffer!\n");
+			savage_do_cleanup_bci(dev);
+			return DRM_ERR(ENOMEM);
+		}
+		dev_priv->cmd_dma = &dev_priv->fake_dma;
+		dev_priv->dma_flush = savage_fake_dma_flush;
+	}
+
+	dev_priv->sarea_priv =
+		(drm_savage_sarea_t *)((uint8_t *)dev_priv->sarea->handle +
+				       init->sarea_priv_offset);
+
+	/* setup bitmap descriptors */
+	{
+		unsigned int color_tile_format;
+		unsigned int depth_tile_format;
+		unsigned int front_stride, back_stride, depth_stride;
+		if (dev_priv->chipset <= S3_SAVAGE4) {
+			color_tile_format = dev_priv->fb_bpp == 16 ?
+				SAVAGE_BD_TILE_16BPP : SAVAGE_BD_TILE_32BPP;
+			depth_tile_format = dev_priv->depth_bpp == 16 ?
+				SAVAGE_BD_TILE_16BPP : SAVAGE_BD_TILE_32BPP;
+		} else {
+			color_tile_format = SAVAGE_BD_TILE_DEST;
+			depth_tile_format = SAVAGE_BD_TILE_DEST;
+		}
+		front_stride = dev_priv->front_pitch / (dev_priv->fb_bpp/8);
+		back_stride  = dev_priv-> back_pitch / (dev_priv->fb_bpp/8);
+		depth_stride = dev_priv->depth_pitch / (dev_priv->depth_bpp/8);
+
+		dev_priv->front_bd = front_stride | SAVAGE_BD_BW_DISABLE |
+			(dev_priv->fb_bpp << SAVAGE_BD_BPP_SHIFT) |
+			(color_tile_format << SAVAGE_BD_TILE_SHIFT);
+
+		dev_priv-> back_bd =  back_stride | SAVAGE_BD_BW_DISABLE |
+			(dev_priv->fb_bpp << SAVAGE_BD_BPP_SHIFT) |
+			(color_tile_format << SAVAGE_BD_TILE_SHIFT);
+
+		dev_priv->depth_bd = depth_stride | SAVAGE_BD_BW_DISABLE |
+			(dev_priv->depth_bpp << SAVAGE_BD_BPP_SHIFT) |
+			(depth_tile_format << SAVAGE_BD_TILE_SHIFT);
+	}
+
+	/* setup status and bci ptr */
+	dev_priv->event_counter = 0;
+	dev_priv->event_wrap = 0;
+	dev_priv->bci_ptr = (volatile uint32_t *)
+	    ((uint8_t *)dev_priv->mmio->handle + SAVAGE_BCI_OFFSET);
+	if (S3_SAVAGE3D_SERIES(dev_priv->chipset)) {
+		dev_priv->status_used_mask = SAVAGE_FIFO_USED_MASK_S3D;
+	} else {
+		dev_priv->status_used_mask = SAVAGE_FIFO_USED_MASK_S4;
+	}
+	if (dev_priv->status != NULL) {
+		dev_priv->status_ptr =
+			(volatile uint32_t *)dev_priv->status->handle;
+		dev_priv->wait_fifo = savage_bci_wait_fifo_shadow;
+		dev_priv->wait_evnt = savage_bci_wait_event_shadow;
+		dev_priv->status_ptr[1023] = dev_priv->event_counter;
+	} else {
+		dev_priv->status_ptr = NULL;
+		if (S3_SAVAGE3D_SERIES(dev_priv->chipset)) {
+			dev_priv->wait_fifo = savage_bci_wait_fifo_s3d;
+		} else {
+			dev_priv->wait_fifo = savage_bci_wait_fifo_s4;
+		}
+		dev_priv->wait_evnt = savage_bci_wait_event_reg;
+	}
+
+	/* cliprect functions */
+	if (S3_SAVAGE3D_SERIES(dev_priv->chipset))
+		dev_priv->emit_clip_rect = savage_emit_clip_rect_s3d;
+	else
+		dev_priv->emit_clip_rect = savage_emit_clip_rect_s4;
+
+	if (savage_freelist_init(dev) < 0) {
+		DRM_ERROR("could not initialize freelist\n");
+		savage_do_cleanup_bci(dev);
+		return DRM_ERR(ENOMEM);
+	}
+
+	if (savage_dma_init(dev_priv) <  0) {
+		DRM_ERROR("could not initialize command DMA\n");
+		savage_do_cleanup_bci(dev);
+		return DRM_ERR(ENOMEM);
+	}
+
+	return 0;
+}
+
+int savage_do_cleanup_bci(drm_device_t *dev)
+{
+	drm_savage_private_t *dev_priv = dev->dev_private;
+
+	if (dev_priv->cmd_dma == &dev_priv->fake_dma) {
+		if (dev_priv->fake_dma.handle)
+			drm_free(dev_priv->fake_dma.handle,
+				 SAVAGE_FAKE_DMA_SIZE, DRM_MEM_DRIVER);
+	} else if (dev_priv->cmd_dma && dev_priv->cmd_dma->handle &&
+		   dev_priv->cmd_dma->type == _DRM_AGP &&
+		   dev_priv->dma_type == SAVAGE_DMA_AGP)
+		drm_core_ioremapfree(dev_priv->cmd_dma, dev);
+
+	if (dev_priv->dma_type == SAVAGE_DMA_AGP &&
+	    dev->agp_buffer_map && dev->agp_buffer_map->handle) {
+		drm_core_ioremapfree(dev->agp_buffer_map, dev);
+		/* make sure the next instance (which may be running
+		 * in PCI mode) doesn't try to use an old
+		 * agp_buffer_map. */
+		dev->agp_buffer_map = NULL;
+	}
+
+	if (dev_priv->dma_pages)
+		drm_free(dev_priv->dma_pages,
+			 sizeof(drm_savage_dma_page_t)*dev_priv->nr_dma_pages,
+			 DRM_MEM_DRIVER);
+
+	return 0;
+}
+
+int savage_bci_init(DRM_IOCTL_ARGS)
+{
+	DRM_DEVICE;
+	drm_savage_init_t init;
+
+	LOCK_TEST_WITH_RETURN(dev, filp);
+
+	DRM_COPY_FROM_USER_IOCTL(init, (drm_savage_init_t __user *)data,
+				 sizeof(init));
+
+	switch (init.func) {
+	case SAVAGE_INIT_BCI:
+		return savage_do_init_bci(dev, &init);
+	case SAVAGE_CLEANUP_BCI:
+		return savage_do_cleanup_bci(dev);
+	}
+
+	return DRM_ERR(EINVAL);
+}
+
+int savage_bci_event_emit(DRM_IOCTL_ARGS)
+{
+	DRM_DEVICE;
+	drm_savage_private_t *dev_priv = dev->dev_private;
+	drm_savage_event_emit_t event;
+
+	DRM_DEBUG("\n");
+
+	LOCK_TEST_WITH_RETURN(dev, filp);
+
+	DRM_COPY_FROM_USER_IOCTL(event, (drm_savage_event_emit_t __user *)data,
+				 sizeof(event));
+
+	event.count = savage_bci_emit_event(dev_priv, event.flags);
+	event.count |= dev_priv->event_wrap << 16;
+	DRM_COPY_TO_USER_IOCTL(&((drm_savage_event_emit_t __user *)data)->count,
+			       event.count, sizeof(event.count));
+	return 0;
+}
+
+int savage_bci_event_wait(DRM_IOCTL_ARGS)
+{
+	DRM_DEVICE;
+	drm_savage_private_t *dev_priv = dev->dev_private;
+	drm_savage_event_wait_t event;
+	unsigned int event_e, hw_e;
+	unsigned int event_w, hw_w;
+
+	DRM_DEBUG("\n");
+
+	DRM_COPY_FROM_USER_IOCTL(event, (drm_savage_event_wait_t __user *)data,
+				 sizeof(event));
+
+	UPDATE_EVENT_COUNTER();
+	if (dev_priv->status_ptr)
+		hw_e = dev_priv->status_ptr[1] & 0xffff;
+	else
+		hw_e = SAVAGE_READ(SAVAGE_STATUS_WORD1) & 0xffff;
+	hw_w = dev_priv->event_wrap;
+	if (hw_e > dev_priv->event_counter)
+		hw_w--; /* hardware hasn't passed the last wrap yet */
+
+	event_e = event.count & 0xffff;
+	event_w = event.count >> 16;
+
+	/* Don't need to wait if
+	 * - event counter wrapped since the event was emitted or
+	 * - the hardware has advanced up to or over the event to wait for.
+	 */
+	if (event_w < hw_w || (event_w == hw_w && event_e <= hw_e) )
+		return 0;
+	else
+		return dev_priv->wait_evnt(dev_priv, event_e);
+}
+
+/*
+ * DMA buffer management
+ */
+
+static int savage_bci_get_buffers(DRMFILE filp, drm_device_t *dev, drm_dma_t *d)
+{
+	drm_buf_t *buf;
+	int i;
+
+	for (i = d->granted_count; i < d->request_count; i++) {
+		buf = savage_freelist_get(dev);
+		if (!buf)
+			return DRM_ERR(EAGAIN);
+
+		buf->filp = filp;
+
+		if (DRM_COPY_TO_USER(&d->request_indices[i],
+				     &buf->idx, sizeof(buf->idx)))
+			return DRM_ERR(EFAULT);
+		if (DRM_COPY_TO_USER(&d->request_sizes[i],
+				     &buf->total, sizeof(buf->total)))
+			return DRM_ERR(EFAULT);
+
+		d->granted_count++;
+	}
+	return 0;
+}
+
+int savage_bci_buffers(DRM_IOCTL_ARGS)
+{
+	DRM_DEVICE;
+	drm_device_dma_t *dma = dev->dma;
+	drm_dma_t d;
+	int ret = 0;
+
+	LOCK_TEST_WITH_RETURN(dev, filp);
+
+	DRM_COPY_FROM_USER_IOCTL(d, (drm_dma_t __user *)data, sizeof(d));
+
+	/* Please don't send us buffers.
+	 */
+	if (d.send_count != 0) {
+		DRM_ERROR("Process %d trying to send %d buffers via drmDMA\n",
+			  DRM_CURRENTPID, d.send_count);
+		return DRM_ERR(EINVAL);
+	}
+
+	/* We'll send you buffers.
+	 */
+	if (d.request_count < 0 || d.request_count > dma->buf_count) {
+		DRM_ERROR("Process %d trying to get %d buffers (of %d max)\n",
+			  DRM_CURRENTPID, d.request_count, dma->buf_count);
+		return DRM_ERR(EINVAL);
+	}
+
+	d.granted_count = 0;
+
+	if (d.request_count) {
+		ret = savage_bci_get_buffers(filp, dev, &d);
+	}
+
+	DRM_COPY_TO_USER_IOCTL((drm_dma_t __user *)data, d, sizeof(d));
+
+	return ret;
+}
+
+void savage_reclaim_buffers(drm_device_t *dev, DRMFILE filp) {
+	drm_device_dma_t *dma = dev->dma;
+	drm_savage_private_t *dev_priv = dev->dev_private;
+	int i;
+
+	if (!dma)
+		return;
+	if (!dev_priv)
+		return;
+	if (!dma->buflist)
+		return;
+
+	/*i830_flush_queue(dev);*/
+
+	for (i = 0; i < dma->buf_count; i++) {
+		drm_buf_t *buf = dma->buflist[i];
+		drm_savage_buf_priv_t *buf_priv = buf->dev_private;
+
+		if (buf->filp == filp && buf_priv &&
+		    buf_priv->next == NULL && buf_priv->prev == NULL) {
+			uint16_t event;
+			DRM_DEBUG("reclaimed from client\n");
+			event = savage_bci_emit_event(dev_priv, SAVAGE_WAIT_3D);
+			SET_AGE(&buf_priv->age, event, dev_priv->event_wrap);
+			savage_freelist_put(dev, buf);
+		}
+	}
+
+	drm_core_reclaim_buffers(dev, filp);
+}
diff -purN linux-2.6.12.orig/drivers/char/drm/savage_drm.h linux-2.6.12/drivers/char/drm/savage_drm.h
--- linux-2.6.12.orig/drivers/char/drm/savage_drm.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/drm/savage_drm.h	2005-07-05 08:37:49.000000000 +0200
@@ -0,0 +1,209 @@
+/* savage_drm.h -- Public header for the savage driver
+ *
+ * Copyright 2004  Felix Kuehling
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT. IN NO EVENT SHALL FELIX KUEHLING BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
+ * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef __SAVAGE_DRM_H__
+#define __SAVAGE_DRM_H__
+
+#ifndef __SAVAGE_SAREA_DEFINES__
+#define __SAVAGE_SAREA_DEFINES__
+
+/* 2 heaps (1 for card, 1 for agp), each divided into upto 128
+ * regions, subject to a minimum region size of (1<<16) == 64k.
+ *
+ * Clients may subdivide regions internally, but when sharing between
+ * clients, the region size is the minimum granularity.
+ */
+
+#define SAVAGE_CARD_HEAP		0
+#define SAVAGE_AGP_HEAP			1
+#define SAVAGE_NR_TEX_HEAPS		2
+#define SAVAGE_NR_TEX_REGIONS		16
+#define SAVAGE_LOG_MIN_TEX_REGION_SIZE	16
+
+#endif /* __SAVAGE_SAREA_DEFINES__ */
+
+typedef struct _drm_savage_sarea {
+	/* LRU lists for texture memory in agp space and on the card.
+	 */
+	drm_tex_region_t texList[SAVAGE_NR_TEX_HEAPS][SAVAGE_NR_TEX_REGIONS+1];
+	unsigned int texAge[SAVAGE_NR_TEX_HEAPS];
+
+	/* Mechanism to validate card state.
+	 */
+	int ctxOwner;
+} drm_savage_sarea_t, *drm_savage_sarea_ptr;
+
+/* Savage-specific ioctls
+ */
+#define DRM_SAVAGE_BCI_INIT		0x00
+#define DRM_SAVAGE_BCI_CMDBUF           0x01
+#define DRM_SAVAGE_BCI_EVENT_EMIT	0x02
+#define DRM_SAVAGE_BCI_EVENT_WAIT	0x03
+
+#define DRM_IOCTL_SAVAGE_INIT		DRM_IOW( DRM_COMMAND_BASE + DRM_SAVAGE_BCI_INIT, drm_savage_init_t)
+#define DRM_IOCTL_SAVAGE_CMDBUF		DRM_IOW( DRM_COMMAND_BASE + DRM_SAVAGE_BCI_CMDBUF, drm_savage_cmdbuf_t)
+#define DRM_IOCTL_SAVAGE_EVENT_EMIT	DRM_IOWR(DRM_COMMAND_BASE + DRM_SAVAGE_BCI_EVENT_EMIT, drm_savage_event_emit_t)
+#define DRM_IOCTL_SAVAGE_EVENT_WAIT	DRM_IOW( DRM_COMMAND_BASE + DRM_SAVAGE_BCI_EVENT_WAIT, drm_savage_event_wait_t)
+
+#define SAVAGE_DMA_PCI	1
+#define SAVAGE_DMA_AGP	3
+typedef struct drm_savage_init {
+	enum {
+		SAVAGE_INIT_BCI = 1,
+		SAVAGE_CLEANUP_BCI = 2
+	} func;
+	unsigned int sarea_priv_offset;
+
+	/* some parameters */
+	unsigned int cob_size;
+	unsigned int bci_threshold_lo, bci_threshold_hi;
+	unsigned int dma_type;
+
+	/* frame buffer layout */
+	unsigned int fb_bpp;
+	unsigned int front_offset, front_pitch;
+	unsigned int back_offset, back_pitch;
+	unsigned int depth_bpp;
+	unsigned int depth_offset, depth_pitch;
+
+	/* local textures */
+	unsigned int texture_offset;
+	unsigned int texture_size;
+
+	/* physical locations of non-permanent maps */
+	unsigned long status_offset;
+	unsigned long buffers_offset;
+	unsigned long agp_textures_offset;
+	unsigned long cmd_dma_offset;
+} drm_savage_init_t;
+
+typedef union drm_savage_cmd_header drm_savage_cmd_header_t;
+typedef struct drm_savage_cmdbuf {
+				/* command buffer in client's address space */
+	drm_savage_cmd_header_t __user *cmd_addr;
+	unsigned int size;	/* size of the command buffer in 64bit units */
+
+	unsigned int dma_idx;	/* DMA buffer index to use */
+	int discard;		/* discard DMA buffer when done */
+				/* vertex buffer in client's address space */
+	unsigned int __user *vb_addr;
+	unsigned int vb_size;	/* size of client vertex buffer in bytes */
+	unsigned int vb_stride;	/* stride of vertices in 32bit words */
+				/* boxes in client's address space */
+	drm_clip_rect_t __user *box_addr;
+	unsigned int nbox;	/* number of clipping boxes */
+} drm_savage_cmdbuf_t;
+
+#define SAVAGE_WAIT_2D  0x1 /* wait for 2D idle before updating event tag */
+#define SAVAGE_WAIT_3D  0x2 /* wait for 3D idle before updating event tag */
+#define SAVAGE_WAIT_IRQ 0x4 /* emit or wait for IRQ, not implemented yet */
+typedef struct drm_savage_event {
+	unsigned int count;
+	unsigned int flags;
+} drm_savage_event_emit_t, drm_savage_event_wait_t;
+
+/* Commands for the cmdbuf ioctl
+ */
+#define SAVAGE_CMD_STATE	0  /* a range of state registers */
+#define SAVAGE_CMD_DMA_PRIM	1  /* vertices from DMA buffer */
+#define SAVAGE_CMD_VB_PRIM	2  /* vertices from client vertex buffer */
+#define SAVAGE_CMD_DMA_IDX	3  /* indexed vertices from DMA buffer */
+#define SAVAGE_CMD_VB_IDX	4  /* indexed vertices client vertex buffer */
+#define SAVAGE_CMD_CLEAR	5  /* clear buffers */
+#define SAVAGE_CMD_SWAP		6  /* swap buffers */
+
+/* Primitive types
+*/
+#define SAVAGE_PRIM_TRILIST	0  /* triangle list */
+#define SAVAGE_PRIM_TRISTRIP	1  /* triangle strip */
+#define SAVAGE_PRIM_TRIFAN	2  /* triangle fan */
+#define SAVAGE_PRIM_TRILIST_201	3  /* reorder verts for correct flat
+				    * shading on s3d */
+
+/* Skip flags (vertex format)
+ */
+#define SAVAGE_SKIP_Z		0x01
+#define SAVAGE_SKIP_W		0x02
+#define SAVAGE_SKIP_C0		0x04
+#define SAVAGE_SKIP_C1		0x08
+#define SAVAGE_SKIP_S0		0x10
+#define SAVAGE_SKIP_T0		0x20
+#define SAVAGE_SKIP_ST0		0x30
+#define SAVAGE_SKIP_S1		0x40
+#define SAVAGE_SKIP_T1		0x80
+#define SAVAGE_SKIP_ST1		0xc0
+#define SAVAGE_SKIP_ALL_S3D	0x3f
+#define SAVAGE_SKIP_ALL_S4	0xff
+
+/* Buffer names for clear command
+ */
+#define SAVAGE_FRONT		0x1
+#define SAVAGE_BACK		0x2
+#define SAVAGE_DEPTH		0x4
+
+/* 64-bit command header
+ */
+union drm_savage_cmd_header {
+	struct {
+		unsigned char cmd;	/* command */
+		unsigned char pad0;
+		unsigned short pad1;
+		unsigned short pad2;
+		unsigned short pad3;
+	} cmd; /* generic */
+	struct {
+		unsigned char cmd;
+		unsigned char global;	/* need idle engine? */
+		unsigned short count;	/* number of consecutive registers */
+		unsigned short start;	/* first register */
+		unsigned short pad3;
+	} state; /* SAVAGE_CMD_STATE */
+	struct {
+		unsigned char cmd;
+		unsigned char prim;	/* primitive type */
+		unsigned short skip;	/* vertex format (skip flags) */
+		unsigned short count;	/* number of vertices */
+		unsigned short start;	/* first vertex in DMA/vertex buffer */
+	} prim; /* SAVAGE_CMD_DMA_PRIM, SAVAGE_CMD_VB_PRIM */
+	struct {
+		unsigned char cmd;
+		unsigned char prim;
+		unsigned short skip;
+		unsigned short count;	/* number of indices that follow */
+		unsigned short pad3;
+	} idx; /* SAVAGE_CMD_DMA_IDX, SAVAGE_CMD_VB_IDX */
+	struct {
+		unsigned char cmd;
+		unsigned char pad0;
+		unsigned short pad1;
+		unsigned int flags;
+	} clear0; /* SAVAGE_CMD_CLEAR */
+	struct {
+		unsigned int mask;
+		unsigned int value;
+	} clear1; /* SAVAGE_CMD_CLEAR data */
+};
+
+#endif
diff -purN linux-2.6.12.orig/drivers/char/drm/savage_drv.c linux-2.6.12/drivers/char/drm/savage_drv.c
--- linux-2.6.12.orig/drivers/char/drm/savage_drv.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/drm/savage_drv.c	2005-07-05 08:37:27.000000000 +0200
@@ -0,0 +1,124 @@
+/* savage_drv.c -- Savage driver for Linux
+ *
+ * Copyright 2004  Felix Kuehling
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT. IN NO EVENT SHALL FELIX KUEHLING BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
+ * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <linux/config.h>
+#include "drmP.h"
+#include "savage_drm.h"
+#include "savage_drv.h"
+
+#include "drm_pciids.h"
+
+static int postinit( struct drm_device *dev, unsigned long flags )
+{
+	DRM_INFO( "Initialized %s %d.%d.%d %s on minor %d: %s\n",
+		DRIVER_NAME,
+		DRIVER_MAJOR,
+		DRIVER_MINOR,
+		DRIVER_PATCHLEVEL,
+		DRIVER_DATE,
+		dev->primary.minor,
+		pci_pretty_name(dev->pdev)
+		);
+	return 0;
+}
+
+static int version( drm_version_t *version )
+{
+	int len;
+
+	version->version_major = DRIVER_MAJOR;
+	version->version_minor = DRIVER_MINOR;
+	version->version_patchlevel = DRIVER_PATCHLEVEL;
+	DRM_COPY( version->name, DRIVER_NAME );
+	DRM_COPY( version->date, DRIVER_DATE );
+	DRM_COPY( version->desc, DRIVER_DESC );
+	return 0;
+}
+
+static struct pci_device_id pciidlist[] = {
+	savage_PCI_IDS
+};
+
+static drm_ioctl_desc_t ioctls[] = {
+	[DRM_IOCTL_NR(DRM_SAVAGE_BCI_INIT)] = {savage_bci_init, 1, 1},
+	[DRM_IOCTL_NR(DRM_SAVAGE_BCI_CMDBUF)] = {savage_bci_cmdbuf, 1, 0},
+	[DRM_IOCTL_NR(DRM_SAVAGE_BCI_EVENT_EMIT)] = {savage_bci_event_emit, 1, 0},
+	[DRM_IOCTL_NR(DRM_SAVAGE_BCI_EVENT_WAIT)] = {savage_bci_event_wait, 1, 0},
+};
+
+static int probe(struct pci_dev *pdev, const struct pci_device_id *ent);
+static struct drm_driver driver = {
+	.driver_features =
+	    DRIVER_USE_AGP | DRIVER_USE_MTRR |
+	    DRIVER_HAVE_DMA | DRIVER_PCI_DMA,
+	.dev_priv_size = sizeof(drm_savage_buf_priv_t),
+	.preinit = savage_preinit,
+	.postinit = postinit,
+	.postcleanup = savage_postcleanup,
+	.reclaim_buffers = savage_reclaim_buffers,
+	.get_map_ofs = drm_core_get_map_ofs,
+	.get_reg_ofs = drm_core_get_reg_ofs,
+	.version = version,
+	.ioctls = ioctls,
+	.num_ioctls = DRM_ARRAY_SIZE(ioctls),
+	.dma_ioctl = savage_bci_buffers,
+	.fops = {
+		.owner   = THIS_MODULE,
+		.open	 = drm_open,
+		.release = drm_release,
+		.ioctl	 = drm_ioctl,
+		.mmap	 = drm_mmap,
+		.poll = drm_poll,
+		.fasync  = drm_fasync,
+	},
+	.pci_driver = {
+		.name          = DRIVER_NAME,
+		.id_table      = pciidlist,
+		.probe         = probe,
+		.remove        = __devexit_p(drm_cleanup_pci),
+	}
+};
+
+static int probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	return drm_get_dev(pdev, ent, &driver);
+}
+
+static int __init savage_init(void)
+{
+	return drm_init(&driver, pciidlist);
+}
+
+static void __exit savage_exit(void)
+{
+	drm_exit(&driver);
+}
+
+module_init(savage_init);
+module_exit(savage_exit);
+
+MODULE_AUTHOR( DRIVER_AUTHOR );
+MODULE_DESCRIPTION( DRIVER_DESC );
+MODULE_LICENSE("GPL and additional rights");
diff -purN linux-2.6.12.orig/drivers/char/drm/savage_drv.h linux-2.6.12/drivers/char/drm/savage_drv.h
--- linux-2.6.12.orig/drivers/char/drm/savage_drv.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/drm/savage_drv.h	2005-07-05 08:37:49.000000000 +0200
@@ -0,0 +1,582 @@
+/* savage_drv.h -- Private header for the savage driver
+ *
+ * Copyright 2004  Felix Kuehling
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT. IN NO EVENT SHALL FELIX KUEHLING BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
+ * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef __SAVAGE_DRV_H__
+#define __SAVAGE_DRV_H__
+
+#define DRIVER_AUTHOR	"Felix Kuehling"
+
+#define DRIVER_NAME	"savage"
+#define DRIVER_DESC	"Savage3D/MX/IX, Savage4, SuperSavage, Twister, ProSavage[DDR]"
+#define DRIVER_DATE	"20050313"
+
+#define DRIVER_MAJOR		2
+#define DRIVER_MINOR		4
+#define DRIVER_PATCHLEVEL	1
+/* Interface history:
+ *
+ * 1.x   The DRM driver from the VIA/S3 code drop, basically a dummy
+ * 2.0   The first real DRM
+ * 2.1   Scissors registers managed by the DRM, 3D operations clipped by
+ *       cliprects of the cmdbuf ioctl
+ * 2.2   Implemented SAVAGE_CMD_DMA_IDX and SAVAGE_CMD_VB_IDX
+ * 2.3   Event counters used by BCI_EVENT_EMIT/WAIT ioctls are now 32 bits
+ *       wide and thus very long lived (unlikely to ever wrap). The size
+ *       in the struct was 32 bits before, but only 16 bits were used
+ * 2.4   Implemented command DMA. Now drm_savage_init_t.cmd_dma_offset is
+ *       actually used
+ */
+
+typedef struct drm_savage_age {
+	uint16_t event;
+	unsigned int wrap;
+} drm_savage_age_t;
+
+typedef struct drm_savage_buf_priv {
+	struct drm_savage_buf_priv *next;
+	struct drm_savage_buf_priv *prev;
+	drm_savage_age_t age;
+	drm_buf_t *buf;
+} drm_savage_buf_priv_t;
+
+typedef struct drm_savage_dma_page {
+	drm_savage_age_t age;
+	unsigned int used, flushed;
+} drm_savage_dma_page_t;
+#define SAVAGE_DMA_PAGE_SIZE 1024 /* in dwords */
+/* Fake DMA buffer size in bytes. 4 pages. Allows a maximum command
+ * size of 16kbytes or 4k entries. Minimum requirement would be
+ * 10kbytes for 255 40-byte vertices in one drawing command. */
+#define SAVAGE_FAKE_DMA_SIZE (SAVAGE_DMA_PAGE_SIZE*4*4)
+
+/* interesting bits of hardware state that are saved in dev_priv */
+typedef union {
+	struct drm_savage_common_state {
+		uint32_t vbaddr;
+	} common;
+	struct {
+		unsigned char pad[sizeof(struct drm_savage_common_state)];
+		uint32_t texctrl, texaddr;
+		uint32_t scstart, new_scstart;
+		uint32_t scend, new_scend;
+	} s3d;
+	struct {
+		unsigned char pad[sizeof(struct drm_savage_common_state)];
+		uint32_t texdescr, texaddr0, texaddr1;
+		uint32_t drawctrl0, new_drawctrl0;
+		uint32_t drawctrl1, new_drawctrl1;
+	} s4;
+} drm_savage_state_t;
+
+/* these chip tags should match the ones in the 2D driver in savage_regs.h. */
+enum savage_family {
+	S3_UNKNOWN = 0,
+	S3_SAVAGE3D,
+	S3_SAVAGE_MX,
+	S3_SAVAGE4,
+	S3_PROSAVAGE,
+	S3_TWISTER,
+	S3_PROSAVAGEDDR,
+	S3_SUPERSAVAGE,
+	S3_SAVAGE2000,
+	S3_LAST
+};
+
+#define S3_SAVAGE3D_SERIES(chip)  ((chip>=S3_SAVAGE3D) && (chip<=S3_SAVAGE_MX))
+
+#define S3_SAVAGE4_SERIES(chip)  ((chip==S3_SAVAGE4)            \
+                                  || (chip==S3_PROSAVAGE)       \
+                                  || (chip==S3_TWISTER)         \
+                                  || (chip==S3_PROSAVAGEDDR))
+
+#define	S3_SAVAGE_MOBILE_SERIES(chip)	((chip==S3_SAVAGE_MX) || (chip==S3_SUPERSAVAGE))
+
+#define S3_SAVAGE_SERIES(chip)    ((chip>=S3_SAVAGE3D) && (chip<=S3_SAVAGE2000))
+
+#define S3_MOBILE_TWISTER_SERIES(chip)   ((chip==S3_TWISTER)    \
+                                          ||(chip==S3_PROSAVAGEDDR))
+
+/* flags */
+#define SAVAGE_IS_AGP 1
+
+typedef struct drm_savage_private {
+	drm_savage_sarea_t *sarea_priv;
+
+	drm_savage_buf_priv_t head, tail;
+
+	/* who am I? */
+	enum savage_family chipset;
+
+	unsigned int cob_size;
+	unsigned int bci_threshold_lo, bci_threshold_hi;
+	unsigned int dma_type;
+
+	/* frame buffer layout */
+	unsigned int fb_bpp;
+	unsigned int front_offset, front_pitch;
+	unsigned int back_offset, back_pitch;
+	unsigned int depth_bpp;
+	unsigned int depth_offset, depth_pitch;
+
+	/* bitmap descriptors for swap and clear */
+	unsigned int front_bd, back_bd, depth_bd;
+
+	/* local textures */
+	unsigned int texture_offset;
+	unsigned int texture_size;
+
+	/* memory regions in physical memory */
+	drm_local_map_t *sarea;
+	drm_local_map_t *mmio;
+	drm_local_map_t *fb;
+	drm_local_map_t *aperture;
+	drm_local_map_t *status;
+	drm_local_map_t *agp_textures;
+	drm_local_map_t *cmd_dma;
+	drm_local_map_t fake_dma;
+
+	struct {
+		int handle;
+		unsigned long base, size;
+	} mtrr[3];
+
+	/* BCI and status-related stuff */
+	volatile uint32_t *status_ptr, *bci_ptr;
+	uint32_t status_used_mask;
+	uint16_t event_counter;
+	unsigned int event_wrap;
+
+	/* Savage4 command DMA */
+	drm_savage_dma_page_t *dma_pages;
+	unsigned int nr_dma_pages, first_dma_page, current_dma_page;
+	drm_savage_age_t last_dma_age;
+
+	/* saved hw state for global/local check on S3D */
+	uint32_t hw_draw_ctrl, hw_zbuf_ctrl;
+	/* and for scissors (global, so don't emit if not changed) */
+	uint32_t hw_scissors_start, hw_scissors_end;
+
+	drm_savage_state_t state;
+
+	/* after emitting a wait cmd Savage3D needs 63 nops before next DMA */
+	unsigned int waiting;
+
+	/* config/hardware-dependent function pointers */
+	int (*wait_fifo)(struct drm_savage_private *dev_priv, unsigned int n);
+	int (*wait_evnt)(struct drm_savage_private *dev_priv, uint16_t e);
+	/* Err, there is a macro wait_event in include/linux/wait.h.
+	 * Avoid unwanted macro expansion. */
+	void (*emit_clip_rect)(struct drm_savage_private *dev_priv,
+			       drm_clip_rect_t *pbox);
+	void (*dma_flush)(struct drm_savage_private *dev_priv);
+} drm_savage_private_t;
+
+/* ioctls */
+extern int savage_bci_init(DRM_IOCTL_ARGS);
+extern int savage_bci_cmdbuf(DRM_IOCTL_ARGS);
+extern int savage_bci_event_emit(DRM_IOCTL_ARGS);
+extern int savage_bci_event_wait(DRM_IOCTL_ARGS);
+extern int savage_bci_buffers(DRM_IOCTL_ARGS);
+
+/* BCI functions */
+extern uint16_t savage_bci_emit_event(drm_savage_private_t *dev_priv,
+				      unsigned int flags);
+extern void savage_freelist_put(drm_device_t *dev, drm_buf_t *buf);
+extern void savage_dma_reset(drm_savage_private_t *dev_priv);
+extern void savage_dma_wait(drm_savage_private_t *dev_priv, unsigned int page);
+extern uint32_t *savage_dma_alloc(drm_savage_private_t *dev_priv,
+				  unsigned int n);
+extern int savage_preinit(drm_device_t *dev, unsigned long chipset);
+extern int savage_postcleanup(drm_device_t *dev);
+extern int savage_do_cleanup_bci(drm_device_t *dev);
+extern void savage_reclaim_buffers(drm_device_t *dev, DRMFILE filp);
+
+/* state functions */
+extern void savage_emit_clip_rect_s3d(drm_savage_private_t *dev_priv,
+				      drm_clip_rect_t *pbox);
+extern void savage_emit_clip_rect_s4(drm_savage_private_t *dev_priv,
+				     drm_clip_rect_t *pbox);
+
+#define SAVAGE_FB_SIZE_S3	0x01000000	/*  16MB */
+#define SAVAGE_FB_SIZE_S4	0x02000000	/*  32MB */
+#define SAVAGE_MMIO_SIZE        0x00080000	/* 512kB */
+#define SAVAGE_APERTURE_OFFSET  0x02000000	/*  32MB */
+#define SAVAGE_APERTURE_SIZE    0x05000000	/* 5 tiled surfaces, 16MB each */
+
+#define SAVAGE_BCI_OFFSET       0x00010000      /* offset of the BCI region
+						 * inside the MMIO region */
+#define SAVAGE_BCI_FIFO_SIZE	32		/* number of entries in on-chip
+						 * BCI FIFO */
+
+/*
+ * MMIO registers
+ */
+#define SAVAGE_STATUS_WORD0		0x48C00
+#define SAVAGE_STATUS_WORD1		0x48C04
+#define SAVAGE_ALT_STATUS_WORD0 	0x48C60
+
+#define SAVAGE_FIFO_USED_MASK_S3D	0x0001ffff
+#define SAVAGE_FIFO_USED_MASK_S4	0x001fffff
+
+/* Copied from savage_bci.h in the 2D driver with some renaming. */
+
+/* Bitmap descriptors */
+#define SAVAGE_BD_STRIDE_SHIFT 0
+#define SAVAGE_BD_BPP_SHIFT   16
+#define SAVAGE_BD_TILE_SHIFT  24
+#define SAVAGE_BD_BW_DISABLE  (1<<28)
+/* common: */
+#define	SAVAGE_BD_TILE_LINEAR		0
+/* savage4, MX, IX, 3D */
+#define	SAVAGE_BD_TILE_16BPP		2
+#define	SAVAGE_BD_TILE_32BPP		3
+/* twister, prosavage, DDR, supersavage, 2000 */
+#define	SAVAGE_BD_TILE_DEST		1
+#define	SAVAGE_BD_TILE_TEXTURE		2
+/* GBD - BCI enable */
+/* savage4, MX, IX, 3D */
+#define SAVAGE_GBD_BCI_ENABLE                    8
+/* twister, prosavage, DDR, supersavage, 2000 */
+#define SAVAGE_GBD_BCI_ENABLE_TWISTER            0
+
+#define SAVAGE_GBD_BIG_ENDIAN                    4
+#define SAVAGE_GBD_LITTLE_ENDIAN                 0
+#define SAVAGE_GBD_64                            1
+
+/*  Global Bitmap Descriptor */
+#define SAVAGE_BCI_GLB_BD_LOW             0x8168
+#define SAVAGE_BCI_GLB_BD_HIGH            0x816C
+
+/*
+ * BCI registers
+ */
+/* Savage4/Twister/ProSavage 3D registers */
+#define SAVAGE_DRAWLOCALCTRL_S4		0x1e
+#define SAVAGE_TEXPALADDR_S4		0x1f
+#define SAVAGE_TEXCTRL0_S4		0x20
+#define SAVAGE_TEXCTRL1_S4		0x21
+#define SAVAGE_TEXADDR0_S4		0x22
+#define SAVAGE_TEXADDR1_S4		0x23
+#define SAVAGE_TEXBLEND0_S4		0x24
+#define SAVAGE_TEXBLEND1_S4		0x25
+#define SAVAGE_TEXXPRCLR_S4		0x26 /* never used */
+#define SAVAGE_TEXDESCR_S4		0x27
+#define SAVAGE_FOGTABLE_S4		0x28
+#define SAVAGE_FOGCTRL_S4		0x30
+#define SAVAGE_STENCILCTRL_S4		0x31
+#define SAVAGE_ZBUFCTRL_S4		0x32
+#define SAVAGE_ZBUFOFF_S4		0x33
+#define SAVAGE_DESTCTRL_S4		0x34
+#define SAVAGE_DRAWCTRL0_S4		0x35
+#define SAVAGE_DRAWCTRL1_S4		0x36
+#define SAVAGE_ZWATERMARK_S4		0x37
+#define SAVAGE_DESTTEXRWWATERMARK_S4	0x38
+#define SAVAGE_TEXBLENDCOLOR_S4		0x39
+/* Savage3D/MX/IX 3D registers */
+#define SAVAGE_TEXPALADDR_S3D		0x18
+#define SAVAGE_TEXXPRCLR_S3D		0x19 /* never used */
+#define SAVAGE_TEXADDR_S3D		0x1A
+#define SAVAGE_TEXDESCR_S3D		0x1B
+#define SAVAGE_TEXCTRL_S3D		0x1C
+#define SAVAGE_FOGTABLE_S3D		0x20
+#define SAVAGE_FOGCTRL_S3D		0x30
+#define SAVAGE_DRAWCTRL_S3D		0x31
+#define SAVAGE_ZBUFCTRL_S3D		0x32
+#define SAVAGE_ZBUFOFF_S3D		0x33
+#define SAVAGE_DESTCTRL_S3D		0x34
+#define SAVAGE_SCSTART_S3D		0x35
+#define SAVAGE_SCEND_S3D		0x36
+#define SAVAGE_ZWATERMARK_S3D		0x37 
+#define SAVAGE_DESTTEXRWWATERMARK_S3D	0x38
+/* common stuff */
+#define SAVAGE_VERTBUFADDR		0x3e
+#define SAVAGE_BITPLANEWTMASK		0xd7
+#define SAVAGE_DMABUFADDR		0x51
+
+/* texture enable bits (needed for tex addr checking) */
+#define SAVAGE_TEXCTRL_TEXEN_MASK	0x00010000 /* S3D */
+#define SAVAGE_TEXDESCR_TEX0EN_MASK	0x02000000 /* S4 */
+#define SAVAGE_TEXDESCR_TEX1EN_MASK	0x04000000 /* S4 */
+
+/* Global fields in Savage4/Twister/ProSavage 3D registers:
+ *
+ * All texture registers and DrawLocalCtrl are local. All other
+ * registers are global. */
+
+/* Global fields in Savage3D/MX/IX 3D registers:
+ *
+ * All texture registers are local. DrawCtrl and ZBufCtrl are
+ * partially local. All other registers are global.
+ *
+ * DrawCtrl global fields: cullMode, alphaTestCmpFunc, alphaTestEn, alphaRefVal
+ * ZBufCtrl global fields: zCmpFunc, zBufEn
+ */
+#define SAVAGE_DRAWCTRL_S3D_GLOBAL	0x03f3c00c
+#define SAVAGE_ZBUFCTRL_S3D_GLOBAL	0x00000027
+
+/* Masks for scissor bits (drawCtrl[01] on s4, scissorStart/End on s3d)
+ */
+#define SAVAGE_SCISSOR_MASK_S4		0x00fff7ff
+#define SAVAGE_SCISSOR_MASK_S3D		0x07ff07ff
+
+/*
+ * BCI commands
+ */
+#define BCI_CMD_NOP                  0x40000000
+#define BCI_CMD_RECT                 0x48000000
+#define BCI_CMD_RECT_XP              0x01000000
+#define BCI_CMD_RECT_YP              0x02000000
+#define BCI_CMD_SCANLINE             0x50000000
+#define BCI_CMD_LINE                 0x5C000000
+#define BCI_CMD_LINE_LAST_PIXEL      0x58000000
+#define BCI_CMD_BYTE_TEXT            0x63000000
+#define BCI_CMD_NT_BYTE_TEXT         0x67000000
+#define BCI_CMD_BIT_TEXT             0x6C000000
+#define BCI_CMD_GET_ROP(cmd)         (((cmd) >> 16) & 0xFF)
+#define BCI_CMD_SET_ROP(cmd, rop)    ((cmd) |= ((rop & 0xFF) << 16))
+#define BCI_CMD_SEND_COLOR           0x00008000
+
+#define BCI_CMD_CLIP_NONE            0x00000000
+#define BCI_CMD_CLIP_CURRENT         0x00002000
+#define BCI_CMD_CLIP_LR              0x00004000
+#define BCI_CMD_CLIP_NEW             0x00006000
+
+#define BCI_CMD_DEST_GBD             0x00000000
+#define BCI_CMD_DEST_PBD             0x00000800
+#define BCI_CMD_DEST_PBD_NEW         0x00000C00
+#define BCI_CMD_DEST_SBD             0x00001000
+#define BCI_CMD_DEST_SBD_NEW         0x00001400
+
+#define BCI_CMD_SRC_TRANSPARENT      0x00000200
+#define BCI_CMD_SRC_SOLID            0x00000000
+#define BCI_CMD_SRC_GBD              0x00000020
+#define BCI_CMD_SRC_COLOR            0x00000040
+#define BCI_CMD_SRC_MONO             0x00000060
+#define BCI_CMD_SRC_PBD_COLOR        0x00000080
+#define BCI_CMD_SRC_PBD_MONO         0x000000A0
+#define BCI_CMD_SRC_PBD_COLOR_NEW    0x000000C0
+#define BCI_CMD_SRC_PBD_MONO_NEW     0x000000E0
+#define BCI_CMD_SRC_SBD_COLOR        0x00000100
+#define BCI_CMD_SRC_SBD_MONO         0x00000120
+#define BCI_CMD_SRC_SBD_COLOR_NEW    0x00000140
+#define BCI_CMD_SRC_SBD_MONO_NEW     0x00000160
+
+#define BCI_CMD_PAT_TRANSPARENT      0x00000010
+#define BCI_CMD_PAT_NONE             0x00000000
+#define BCI_CMD_PAT_COLOR            0x00000002
+#define BCI_CMD_PAT_MONO             0x00000003
+#define BCI_CMD_PAT_PBD_COLOR        0x00000004
+#define BCI_CMD_PAT_PBD_MONO         0x00000005
+#define BCI_CMD_PAT_PBD_COLOR_NEW    0x00000006
+#define BCI_CMD_PAT_PBD_MONO_NEW     0x00000007
+#define BCI_CMD_PAT_SBD_COLOR        0x00000008
+#define BCI_CMD_PAT_SBD_MONO         0x00000009
+#define BCI_CMD_PAT_SBD_COLOR_NEW    0x0000000A
+#define BCI_CMD_PAT_SBD_MONO_NEW     0x0000000B
+
+#define BCI_BD_BW_DISABLE            0x10000000
+#define BCI_BD_TILE_MASK             0x03000000
+#define BCI_BD_TILE_NONE             0x00000000
+#define BCI_BD_TILE_16               0x02000000
+#define BCI_BD_TILE_32               0x03000000
+#define BCI_BD_GET_BPP(bd)           (((bd) >> 16) & 0xFF)
+#define BCI_BD_SET_BPP(bd, bpp)      ((bd) |= (((bpp) & 0xFF) << 16))
+#define BCI_BD_GET_STRIDE(bd)        ((bd) & 0xFFFF)
+#define BCI_BD_SET_STRIDE(bd, st)    ((bd) |= ((st) & 0xFFFF))
+
+#define BCI_CMD_SET_REGISTER            0x96000000
+
+#define BCI_CMD_WAIT                    0xC0000000
+#define BCI_CMD_WAIT_3D                 0x00010000
+#define BCI_CMD_WAIT_2D                 0x00020000
+
+#define BCI_CMD_UPDATE_EVENT_TAG        0x98000000
+
+#define BCI_CMD_DRAW_PRIM               0x80000000
+#define BCI_CMD_DRAW_INDEXED_PRIM       0x88000000
+#define BCI_CMD_DRAW_CONT               0x01000000
+#define BCI_CMD_DRAW_TRILIST            0x00000000
+#define BCI_CMD_DRAW_TRISTRIP           0x02000000
+#define BCI_CMD_DRAW_TRIFAN             0x04000000
+#define BCI_CMD_DRAW_SKIPFLAGS          0x000000ff
+#define BCI_CMD_DRAW_NO_Z		0x00000001
+#define BCI_CMD_DRAW_NO_W		0x00000002
+#define BCI_CMD_DRAW_NO_CD		0x00000004
+#define BCI_CMD_DRAW_NO_CS		0x00000008
+#define BCI_CMD_DRAW_NO_U0		0x00000010
+#define BCI_CMD_DRAW_NO_V0		0x00000020
+#define BCI_CMD_DRAW_NO_UV0		0x00000030
+#define BCI_CMD_DRAW_NO_U1		0x00000040
+#define BCI_CMD_DRAW_NO_V1		0x00000080
+#define BCI_CMD_DRAW_NO_UV1		0x000000c0
+
+#define BCI_CMD_DMA			0xa8000000
+
+#define BCI_W_H(w, h)                ((((h) << 16) | (w)) & 0x0FFF0FFF)
+#define BCI_X_Y(x, y)                ((((y) << 16) | (x)) & 0x0FFF0FFF)
+#define BCI_X_W(x, y)                ((((w) << 16) | (x)) & 0x0FFF0FFF)
+#define BCI_CLIP_LR(l, r)            ((((r) << 16) | (l)) & 0x0FFF0FFF)
+#define BCI_CLIP_TL(t, l)            ((((t) << 16) | (l)) & 0x0FFF0FFF)
+#define BCI_CLIP_BR(b, r)            ((((b) << 16) | (r)) & 0x0FFF0FFF)
+
+#define BCI_LINE_X_Y(x, y)           (((y) << 16) | ((x) & 0xFFFF))
+#define BCI_LINE_STEPS(diag, axi)    (((axi) << 16) | ((diag) & 0xFFFF))
+#define BCI_LINE_MISC(maj, ym, xp, yp, err) \
+	(((maj) & 0x1FFF) | \
+	((ym) ? 1<<13 : 0) | \
+	((xp) ? 1<<14 : 0) | \
+	((yp) ? 1<<15 : 0) | \
+	((err) << 16))
+
+/*
+ * common commands
+ */
+#define BCI_SET_REGISTERS( first, n )			\
+	BCI_WRITE(BCI_CMD_SET_REGISTER |		\
+		  ((uint32_t)(n) & 0xff) << 16 |	\
+		  ((uint32_t)(first) & 0xffff))
+#define DMA_SET_REGISTERS( first, n )			\
+	DMA_WRITE(BCI_CMD_SET_REGISTER |		\
+		  ((uint32_t)(n) & 0xff) << 16 |	\
+		  ((uint32_t)(first) & 0xffff))
+
+#define BCI_DRAW_PRIMITIVE(n, type, skip)         \
+        BCI_WRITE(BCI_CMD_DRAW_PRIM | (type) | (skip) | \
+		  ((n) << 16))
+#define DMA_DRAW_PRIMITIVE(n, type, skip)         \
+        DMA_WRITE(BCI_CMD_DRAW_PRIM | (type) | (skip) | \
+		  ((n) << 16))
+
+#define BCI_DRAW_INDICES_S3D(n, type, i0)         \
+        BCI_WRITE(BCI_CMD_DRAW_INDEXED_PRIM | (type) |  \
+		  ((n) << 16) | (i0))
+
+#define BCI_DRAW_INDICES_S4(n, type, skip)        \
+        BCI_WRITE(BCI_CMD_DRAW_INDEXED_PRIM | (type) |  \
+                  (skip) | ((n) << 16))
+
+#define BCI_DMA(n)	\
+	BCI_WRITE(BCI_CMD_DMA | (((n) >> 1) - 1))
+
+/*
+ * access to MMIO
+ */
+#define SAVAGE_READ(reg)	DRM_READ32(  dev_priv->mmio, (reg) )
+#define SAVAGE_WRITE(reg)	DRM_WRITE32( dev_priv->mmio, (reg) )
+
+/*
+ * access to the burst command interface (BCI)
+ */
+#define SAVAGE_BCI_DEBUG 1
+
+#define BCI_LOCALS    volatile uint32_t *bci_ptr;
+
+#define BEGIN_BCI( n ) do {			\
+	dev_priv->wait_fifo(dev_priv, (n));	\
+	bci_ptr = dev_priv->bci_ptr;		\
+} while(0)
+
+#define BCI_WRITE( val ) *bci_ptr++ = (uint32_t)(val)
+
+#define BCI_COPY_FROM_USER(src,n) do {				\
+    unsigned int i;						\
+    for (i = 0; i < n; ++i) {					\
+	uint32_t val;						\
+	DRM_GET_USER_UNCHECKED(val, &((uint32_t*)(src))[i]);	\
+	BCI_WRITE(val);						\
+    }								\
+} while(0)
+
+/*
+ * command DMA support
+ */
+#define SAVAGE_DMA_DEBUG 1
+
+#define DMA_LOCALS   uint32_t *dma_ptr;
+
+#define BEGIN_DMA( n ) do {						\
+	unsigned int cur = dev_priv->current_dma_page;			\
+	unsigned int rest = SAVAGE_DMA_PAGE_SIZE -			\
+		dev_priv->dma_pages[cur].used;				\
+	if ((n) > rest) {						\
+		dma_ptr = savage_dma_alloc(dev_priv, (n));		\
+	} else { /* fast path for small allocations */			\
+		dma_ptr = (uint32_t *)dev_priv->cmd_dma->handle +	\
+			cur * SAVAGE_DMA_PAGE_SIZE +			\
+			dev_priv->dma_pages[cur].used;			\
+		if (dev_priv->dma_pages[cur].used == 0)			\
+			savage_dma_wait(dev_priv, cur);			\
+		dev_priv->dma_pages[cur].used += (n);			\
+	}								\
+} while(0)
+
+#define DMA_WRITE( val ) *dma_ptr++ = (uint32_t)(val)
+
+#define DMA_COPY_FROM_USER(src,n) do {				\
+	DRM_COPY_FROM_USER_UNCHECKED(dma_ptr, (src), (n)*4);	\
+	dma_ptr += n;						\
+} while(0)
+
+#if SAVAGE_DMA_DEBUG
+#define DMA_COMMIT() do {						\
+	unsigned int cur = dev_priv->current_dma_page;			\
+	uint32_t *expected = (uint32_t *)dev_priv->cmd_dma->handle +	\
+			cur * SAVAGE_DMA_PAGE_SIZE +			\
+			dev_priv->dma_pages[cur].used;			\
+	if (dma_ptr != expected) {					\
+		DRM_ERROR("DMA allocation and use don't match: "	\
+			  "%p != %p\n", expected, dma_ptr);		\
+		savage_dma_reset(dev_priv);				\
+	}								\
+} while(0)
+#else
+#define DMA_COMMIT() do {/* nothing */} while(0)
+#endif
+
+#define DMA_FLUSH() dev_priv->dma_flush(dev_priv)
+
+/* Buffer aging via event tag
+ */
+
+#define UPDATE_EVENT_COUNTER( ) do {			\
+	if (dev_priv->status_ptr) {			\
+		uint16_t count;				\
+		/* coordinate with Xserver */		\
+		count = dev_priv->status_ptr[1023];	\
+		if (count < dev_priv->event_counter)	\
+			dev_priv->event_wrap++;		\
+		dev_priv->event_counter = count;	\
+	}						\
+} while(0)
+
+#define SET_AGE( age, e, w ) do {	\
+	(age)->event = e;		\
+	(age)->wrap = w;		\
+} while(0)
+
+#define TEST_AGE( age, e, w )				\
+	( (age)->wrap < (w) || ( (age)->wrap == (w) && (age)->event <= (e) ) )
+
+#endif /* __SAVAGE_DRV_H__ */
diff -purN linux-2.6.12.orig/drivers/char/drm/savage_state.c linux-2.6.12/drivers/char/drm/savage_state.c
--- linux-2.6.12.orig/drivers/char/drm/savage_state.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/drm/savage_state.c	2005-07-05 08:37:47.000000000 +0200
@@ -0,0 +1,1146 @@
+/* savage_state.c -- State and drawing support for Savage
+ *
+ * Copyright 2004  Felix Kuehling
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT. IN NO EVENT SHALL FELIX KUEHLING BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
+ * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include "drmP.h"
+#include "savage_drm.h"
+#include "savage_drv.h"
+
+void savage_emit_clip_rect_s3d(drm_savage_private_t *dev_priv,
+			       drm_clip_rect_t *pbox)
+{
+	uint32_t scstart = dev_priv->state.s3d.new_scstart;
+	uint32_t scend   = dev_priv->state.s3d.new_scend;
+	scstart = (scstart & ~SAVAGE_SCISSOR_MASK_S3D) |
+		((uint32_t)pbox->x1 & 0x000007ff) | 
+		(((uint32_t)pbox->y1 << 16) & 0x07ff0000);
+	scend   = (scend   & ~SAVAGE_SCISSOR_MASK_S3D) |
+		(((uint32_t)pbox->x2-1) & 0x000007ff) |
+		((((uint32_t)pbox->y2-1) << 16) & 0x07ff0000);
+	if (scstart != dev_priv->state.s3d.scstart ||
+	    scend   != dev_priv->state.s3d.scend) {
+		DMA_LOCALS;
+		BEGIN_DMA(4);
+		DMA_WRITE(BCI_CMD_WAIT|BCI_CMD_WAIT_3D);
+		DMA_SET_REGISTERS(SAVAGE_SCSTART_S3D, 2);
+		DMA_WRITE(scstart);
+		DMA_WRITE(scend);
+		dev_priv->state.s3d.scstart = scstart;
+		dev_priv->state.s3d.scend   = scend;
+		dev_priv->waiting = 1;
+		DMA_COMMIT();
+	}
+}
+
+void savage_emit_clip_rect_s4(drm_savage_private_t *dev_priv,
+			      drm_clip_rect_t *pbox)
+{
+	uint32_t drawctrl0 = dev_priv->state.s4.new_drawctrl0;
+	uint32_t drawctrl1 = dev_priv->state.s4.new_drawctrl1;
+	drawctrl0 = (drawctrl0 & ~SAVAGE_SCISSOR_MASK_S4) |
+		((uint32_t)pbox->x1 & 0x000007ff) |
+		(((uint32_t)pbox->y1 << 12) & 0x00fff000);
+	drawctrl1 = (drawctrl1 & ~SAVAGE_SCISSOR_MASK_S4) |
+		(((uint32_t)pbox->x2-1) & 0x000007ff) |
+		((((uint32_t)pbox->y2-1) << 12) & 0x00fff000);
+	if (drawctrl0 != dev_priv->state.s4.drawctrl0 ||
+	    drawctrl1 != dev_priv->state.s4.drawctrl1) {
+		DMA_LOCALS;
+		BEGIN_DMA(4);
+		DMA_WRITE(BCI_CMD_WAIT|BCI_CMD_WAIT_3D);
+		DMA_SET_REGISTERS(SAVAGE_DRAWCTRL0_S4, 2);
+		DMA_WRITE(drawctrl0);
+		DMA_WRITE(drawctrl1);
+		dev_priv->state.s4.drawctrl0 = drawctrl0;
+		dev_priv->state.s4.drawctrl1 = drawctrl1;
+		dev_priv->waiting = 1;
+		DMA_COMMIT();
+	}
+}
+
+static int savage_verify_texaddr(drm_savage_private_t *dev_priv, int unit,
+				 uint32_t addr)
+{
+	if ((addr & 6) != 2) { /* reserved bits */
+		DRM_ERROR("bad texAddr%d %08x (reserved bits)\n", unit, addr);
+		return DRM_ERR(EINVAL);
+	}
+	if (!(addr & 1)) { /* local */
+		addr &= ~7;
+		if (addr <  dev_priv->texture_offset ||
+		    addr >= dev_priv->texture_offset+dev_priv->texture_size) {
+			DRM_ERROR("bad texAddr%d %08x (local addr out of range)\n",
+				  unit, addr);
+			return DRM_ERR(EINVAL);
+		}
+	} else { /* AGP */
+		if (!dev_priv->agp_textures) {
+			DRM_ERROR("bad texAddr%d %08x (AGP not available)\n",
+				  unit, addr);
+			return DRM_ERR(EINVAL);
+		}
+		addr &= ~7;
+		if (addr < dev_priv->agp_textures->offset ||
+		    addr >= (dev_priv->agp_textures->offset +
+			     dev_priv->agp_textures->size)) {
+			DRM_ERROR("bad texAddr%d %08x (AGP addr out of range)\n",
+				  unit, addr);
+			return DRM_ERR(EINVAL);
+		}
+	}
+	return 0;
+}
+
+#define SAVE_STATE(reg,where)			\
+	if(start <= reg && start+count > reg)	\
+		DRM_GET_USER_UNCHECKED(dev_priv->state.where, &regs[reg-start])
+#define SAVE_STATE_MASK(reg,where,mask) do {			\
+	if(start <= reg && start+count > reg) {			\
+		uint32_t tmp;					\
+		DRM_GET_USER_UNCHECKED(tmp, &regs[reg-start]);	\
+		dev_priv->state.where = (tmp & (mask)) |	\
+			(dev_priv->state.where & ~(mask));	\
+	}							\
+} while (0)
+static int savage_verify_state_s3d(drm_savage_private_t *dev_priv,
+				   unsigned int start, unsigned int count,
+				   const uint32_t __user *regs)
+{
+	if (start < SAVAGE_TEXPALADDR_S3D ||
+	    start+count-1 > SAVAGE_DESTTEXRWWATERMARK_S3D) {
+		DRM_ERROR("invalid register range (0x%04x-0x%04x)\n",
+			  start, start+count-1);
+		return DRM_ERR(EINVAL);
+	}
+
+	SAVE_STATE_MASK(SAVAGE_SCSTART_S3D, s3d.new_scstart,
+			~SAVAGE_SCISSOR_MASK_S3D);
+	SAVE_STATE_MASK(SAVAGE_SCEND_S3D, s3d.new_scend,
+			~SAVAGE_SCISSOR_MASK_S3D);
+
+	/* if any texture regs were changed ... */
+	if (start <= SAVAGE_TEXCTRL_S3D &&
+	    start+count > SAVAGE_TEXPALADDR_S3D) {
+		/* ... check texture state */
+		SAVE_STATE(SAVAGE_TEXCTRL_S3D, s3d.texctrl);
+		SAVE_STATE(SAVAGE_TEXADDR_S3D, s3d.texaddr);
+		if (dev_priv->state.s3d.texctrl & SAVAGE_TEXCTRL_TEXEN_MASK)
+			return savage_verify_texaddr(
+				dev_priv, 0, dev_priv->state.s3d.texaddr);
+	}
+
+	return 0;
+}
+
+static int savage_verify_state_s4(drm_savage_private_t *dev_priv,
+				  unsigned int start, unsigned int count,
+				  const uint32_t __user *regs)
+{
+	int ret = 0;
+
+	if (start < SAVAGE_DRAWLOCALCTRL_S4 ||
+	    start+count-1 > SAVAGE_TEXBLENDCOLOR_S4) {
+		DRM_ERROR("invalid register range (0x%04x-0x%04x)\n",
+			  start, start+count-1);
+		return DRM_ERR(EINVAL);
+	}
+
+	SAVE_STATE_MASK(SAVAGE_DRAWCTRL0_S4, s4.new_drawctrl0,
+			~SAVAGE_SCISSOR_MASK_S4);
+	SAVE_STATE_MASK(SAVAGE_DRAWCTRL1_S4, s4.new_drawctrl1,
+			~SAVAGE_SCISSOR_MASK_S4);
+
+	/* if any texture regs were changed ... */
+	if (start <= SAVAGE_TEXDESCR_S4 &&
+	    start+count > SAVAGE_TEXPALADDR_S4) {
+		/* ... check texture state */
+		SAVE_STATE(SAVAGE_TEXDESCR_S4, s4.texdescr);
+		SAVE_STATE(SAVAGE_TEXADDR0_S4, s4.texaddr0);
+		SAVE_STATE(SAVAGE_TEXADDR1_S4, s4.texaddr1);
+		if (dev_priv->state.s4.texdescr & SAVAGE_TEXDESCR_TEX0EN_MASK)
+			ret |= savage_verify_texaddr(
+				dev_priv, 0, dev_priv->state.s4.texaddr0);
+		if (dev_priv->state.s4.texdescr & SAVAGE_TEXDESCR_TEX1EN_MASK)
+			ret |= savage_verify_texaddr(
+				dev_priv, 1, dev_priv->state.s4.texaddr1);
+	}
+
+	return ret;
+}
+#undef SAVE_STATE
+#undef SAVE_STATE_MASK
+
+static int savage_dispatch_state(drm_savage_private_t *dev_priv,
+				 const drm_savage_cmd_header_t *cmd_header,
+				 const uint32_t __user *regs)
+{
+	unsigned int count = cmd_header->state.count;
+	unsigned int start = cmd_header->state.start;
+	unsigned int count2 = 0;
+	unsigned int bci_size;
+	int ret;
+	DMA_LOCALS;
+
+	if (!count)
+		return 0;
+
+	if (DRM_VERIFYAREA_READ(regs, count*4))
+		return DRM_ERR(EFAULT);
+
+	if (S3_SAVAGE3D_SERIES(dev_priv->chipset)) {
+		ret = savage_verify_state_s3d(dev_priv, start, count, regs);
+		if (ret != 0)
+			return ret;
+		/* scissor regs are emitted in savage_dispatch_draw */
+		if (start < SAVAGE_SCSTART_S3D) {
+			if (start+count > SAVAGE_SCEND_S3D+1)
+				count2 = count - (SAVAGE_SCEND_S3D+1 - start);
+			if (start+count > SAVAGE_SCSTART_S3D)
+				count = SAVAGE_SCSTART_S3D - start;
+		} else if (start <= SAVAGE_SCEND_S3D) {
+			if (start+count > SAVAGE_SCEND_S3D+1) {
+				count -= SAVAGE_SCEND_S3D+1 - start;
+				start = SAVAGE_SCEND_S3D+1;
+			} else
+				return 0;
+		}
+	} else {
+		ret = savage_verify_state_s4(dev_priv, start, count, regs);
+		if (ret != 0)
+			return ret;
+		/* scissor regs are emitted in savage_dispatch_draw */
+		if (start < SAVAGE_DRAWCTRL0_S4) {
+			if (start+count > SAVAGE_DRAWCTRL1_S4+1)
+				count2 = count - (SAVAGE_DRAWCTRL1_S4+1 - start);
+			if (start+count > SAVAGE_DRAWCTRL0_S4)
+				count = SAVAGE_DRAWCTRL0_S4 - start;
+		} else if (start <= SAVAGE_DRAWCTRL1_S4) {
+			if (start+count > SAVAGE_DRAWCTRL1_S4+1) {
+				count -= SAVAGE_DRAWCTRL1_S4+1 - start;
+				start = SAVAGE_DRAWCTRL1_S4+1;
+			} else
+				return 0;
+		}
+	}
+
+	bci_size = count + (count+254)/255 + count2 + (count2+254)/255;
+
+	if (cmd_header->state.global) {
+		BEGIN_DMA(bci_size+1);
+		DMA_WRITE(BCI_CMD_WAIT | BCI_CMD_WAIT_3D);
+		dev_priv->waiting = 1;
+	} else {
+		BEGIN_DMA(bci_size);
+	}
+
+	do {
+		while (count > 0) {
+			unsigned int n = count < 255 ? count : 255;
+			DMA_SET_REGISTERS(start, n);
+			DMA_COPY_FROM_USER(regs, n);
+			count -= n;
+			start += n;
+			regs += n;
+		}
+		start += 2;
+		regs += 2;
+		count = count2;
+		count2 = 0;
+	} while (count);
+
+	DMA_COMMIT();
+
+	return 0;
+}
+
+static int savage_dispatch_dma_prim(drm_savage_private_t *dev_priv,
+				    const drm_savage_cmd_header_t *cmd_header,
+				    const drm_buf_t *dmabuf)
+{
+	unsigned char reorder = 0;
+	unsigned int prim = cmd_header->prim.prim;
+	unsigned int skip = cmd_header->prim.skip;
+	unsigned int n = cmd_header->prim.count;
+	unsigned int start = cmd_header->prim.start;
+	unsigned int i;
+	BCI_LOCALS;
+
+	if (!dmabuf) {
+	    DRM_ERROR("called without dma buffers!\n");
+	    return DRM_ERR(EINVAL);
+	}
+
+	if (!n)
+		return 0;
+
+	switch (prim) {
+	case SAVAGE_PRIM_TRILIST_201:
+		reorder = 1;
+		prim = SAVAGE_PRIM_TRILIST;
+	case SAVAGE_PRIM_TRILIST:
+		if (n % 3 != 0) {
+			DRM_ERROR("wrong number of vertices %u in TRILIST\n",
+				  n);
+			return DRM_ERR(EINVAL);
+		}
+		break;
+	case SAVAGE_PRIM_TRISTRIP:
+	case SAVAGE_PRIM_TRIFAN:
+		if (n < 3) {
+			DRM_ERROR("wrong number of vertices %u in TRIFAN/STRIP\n",
+				  n);
+			return DRM_ERR(EINVAL);
+		}
+		break;
+	default:
+		DRM_ERROR("invalid primitive type %u\n", prim);
+		return DRM_ERR(EINVAL);
+	}
+
+	if (S3_SAVAGE3D_SERIES(dev_priv->chipset)) {
+		if (skip != 0) {
+			DRM_ERROR("invalid skip flags 0x%04x for DMA\n",
+				  skip);
+			return DRM_ERR(EINVAL);
+		}
+	} else {
+		unsigned int size = 10 - (skip & 1) - (skip >> 1 & 1) -
+			(skip >> 2 & 1) - (skip >> 3 & 1) - (skip >> 4 & 1) -
+			(skip >> 5 & 1) - (skip >> 6 & 1) - (skip >> 7 & 1);
+		if (skip > SAVAGE_SKIP_ALL_S4 || size != 8) {
+			DRM_ERROR("invalid skip flags 0x%04x for DMA\n",
+				  skip);
+			return DRM_ERR(EINVAL);
+		}
+		if (reorder) {
+			DRM_ERROR("TRILIST_201 used on Savage4 hardware\n");
+			return DRM_ERR(EINVAL);
+		}
+	}
+
+	if (start + n > dmabuf->total/32) {
+		DRM_ERROR("vertex indices (%u-%u) out of range (0-%u)\n",
+			  start, start + n - 1, dmabuf->total/32);
+		return DRM_ERR(EINVAL);
+	}
+
+	/* Vertex DMA doesn't work with command DMA at the same time,
+	 * so we use BCI_... to submit commands here. Flush buffered
+	 * faked DMA first. */
+	DMA_FLUSH();
+
+	if (dmabuf->bus_address != dev_priv->state.common.vbaddr) {
+		BEGIN_BCI(2);
+		BCI_SET_REGISTERS(SAVAGE_VERTBUFADDR, 1);
+		BCI_WRITE(dmabuf->bus_address | dev_priv->dma_type);
+		dev_priv->state.common.vbaddr = dmabuf->bus_address;
+	}
+	if (S3_SAVAGE3D_SERIES(dev_priv->chipset) && dev_priv->waiting) {
+		/* Workaround for what looks like a hardware bug. If a
+		 * WAIT_3D_IDLE was emitted some time before the
+		 * indexed drawing command then the engine will lock
+		 * up. There are two known workarounds:
+		 * WAIT_IDLE_EMPTY or emit at least 63 NOPs. */
+		BEGIN_BCI(63);
+		for (i = 0; i < 63; ++i)
+			BCI_WRITE(BCI_CMD_WAIT);
+		dev_priv->waiting = 0;
+	}
+
+	prim <<= 25;
+	while (n != 0) {
+		/* Can emit up to 255 indices (85 triangles) at once. */
+		unsigned int count = n > 255 ? 255 : n;
+		if (reorder) {
+			/* Need to reorder indices for correct flat
+			 * shading while preserving the clock sense
+			 * for correct culling. Only on Savage3D. */
+			int reorder[3] = {-1, -1, -1};
+			reorder[start%3] = 2;
+
+			BEGIN_BCI((count+1+1)/2);
+			BCI_DRAW_INDICES_S3D(count, prim, start+2);
+
+			for (i = start+1; i+1 < start+count; i += 2)
+				BCI_WRITE((i + reorder[i % 3]) |
+					  ((i+1 + reorder[(i+1) % 3]) << 16));
+			if (i < start+count)
+				BCI_WRITE(i + reorder[i%3]);
+		} else if (S3_SAVAGE3D_SERIES(dev_priv->chipset)) {
+			BEGIN_BCI((count+1+1)/2);
+			BCI_DRAW_INDICES_S3D(count, prim, start);
+
+			for (i = start+1; i+1 < start+count; i += 2)
+				BCI_WRITE(i | ((i+1) << 16));
+			if (i < start+count)
+				BCI_WRITE(i);
+		} else {
+			BEGIN_BCI((count+2+1)/2);
+			BCI_DRAW_INDICES_S4(count, prim, skip);
+
+			for (i = start; i+1 < start+count; i += 2)
+				BCI_WRITE(i | ((i+1) << 16));
+			if (i < start+count)
+				BCI_WRITE(i);
+		}
+
+		start += count;
+		n -= count;
+
+		prim |= BCI_CMD_DRAW_CONT;
+	}
+
+	return 0;
+}
+
+static int savage_dispatch_vb_prim(drm_savage_private_t *dev_priv,
+				   const drm_savage_cmd_header_t *cmd_header,
+				   const uint32_t __user *vtxbuf,
+				   unsigned int vb_size,
+				   unsigned int vb_stride)
+{
+	unsigned char reorder = 0;
+	unsigned int prim = cmd_header->prim.prim;
+	unsigned int skip = cmd_header->prim.skip;
+	unsigned int n = cmd_header->prim.count;
+	unsigned int start = cmd_header->prim.start;
+	unsigned int vtx_size;
+	unsigned int i;
+	DMA_LOCALS;
+
+	if (!n)
+		return 0;
+
+	switch (prim) {
+	case SAVAGE_PRIM_TRILIST_201:
+		reorder = 1;
+		prim = SAVAGE_PRIM_TRILIST;
+	case SAVAGE_PRIM_TRILIST:
+		if (n % 3 != 0) {
+			DRM_ERROR("wrong number of vertices %u in TRILIST\n",
+				  n);
+			return DRM_ERR(EINVAL);
+		}
+		break;
+	case SAVAGE_PRIM_TRISTRIP:
+	case SAVAGE_PRIM_TRIFAN:
+		if (n < 3) {
+			DRM_ERROR("wrong number of vertices %u in TRIFAN/STRIP\n",
+				  n);
+			return DRM_ERR(EINVAL);
+		}
+		break;
+	default:
+		DRM_ERROR("invalid primitive type %u\n", prim);
+		return DRM_ERR(EINVAL);
+	}
+
+	if (S3_SAVAGE3D_SERIES(dev_priv->chipset)) {
+		if (skip > SAVAGE_SKIP_ALL_S3D) {
+			DRM_ERROR("invalid skip flags 0x%04x\n", skip);
+			return DRM_ERR(EINVAL);
+		}
+		vtx_size = 8; /* full vertex */
+	} else {
+		if (skip > SAVAGE_SKIP_ALL_S4) {
+			DRM_ERROR("invalid skip flags 0x%04x\n", skip);
+			return DRM_ERR(EINVAL);
+		}
+		vtx_size = 10; /* full vertex */
+	}
+
+	vtx_size -= (skip & 1) + (skip >> 1 & 1) +
+		(skip >> 2 & 1) + (skip >> 3 & 1) + (skip >> 4 & 1) +
+		(skip >> 5 & 1) + (skip >> 6 & 1) + (skip >> 7 & 1);
+
+	if (vtx_size > vb_stride) {
+		DRM_ERROR("vertex size greater than vb stride (%u > %u)\n",
+			  vtx_size, vb_stride);
+		return DRM_ERR(EINVAL);
+	}
+
+	if (start + n > vb_size / (vb_stride*4)) {
+		DRM_ERROR("vertex indices (%u-%u) out of range (0-%u)\n",
+			  start, start + n - 1, vb_size / (vb_stride*4));
+		return DRM_ERR(EINVAL);
+	}
+
+	prim <<= 25;
+	while (n != 0) {
+		/* Can emit up to 255 vertices (85 triangles) at once. */
+		unsigned int count = n > 255 ? 255 : n;
+		if (reorder) {
+			/* Need to reorder vertices for correct flat
+			 * shading while preserving the clock sense
+			 * for correct culling. Only on Savage3D. */
+			int reorder[3] = {-1, -1, -1};
+			reorder[start%3] = 2;
+
+			BEGIN_DMA(count*vtx_size+1);
+			DMA_DRAW_PRIMITIVE(count, prim, skip);
+
+			for (i = start; i < start+count; ++i) {
+				unsigned int j = i + reorder[i % 3];
+				DMA_COPY_FROM_USER(&vtxbuf[vb_stride*j],
+						   vtx_size);
+			}
+
+			DMA_COMMIT();
+		} else {
+			BEGIN_DMA(count*vtx_size+1);
+			DMA_DRAW_PRIMITIVE(count, prim, skip);
+
+			if (vb_stride == vtx_size) {
+				DMA_COPY_FROM_USER(&vtxbuf[vb_stride*start],
+						   vtx_size*count);
+			} else {
+				for (i = start; i < start+count; ++i) {
+					DMA_COPY_FROM_USER(
+						&vtxbuf[vb_stride*i],
+						vtx_size);
+				}
+			}
+
+			DMA_COMMIT();
+		}
+
+		start += count;
+		n -= count;
+
+		prim |= BCI_CMD_DRAW_CONT;
+	}
+
+	return 0;
+}
+
+static int savage_dispatch_dma_idx(drm_savage_private_t *dev_priv,
+				   const drm_savage_cmd_header_t *cmd_header,
+				   const uint16_t __user *usr_idx,
+				   const drm_buf_t *dmabuf)
+{
+	unsigned char reorder = 0;
+	unsigned int prim = cmd_header->idx.prim;
+	unsigned int skip = cmd_header->idx.skip;
+	unsigned int n = cmd_header->idx.count;
+	unsigned int i;
+	BCI_LOCALS;
+
+	if (!dmabuf) {
+	    DRM_ERROR("called without dma buffers!\n");
+	    return DRM_ERR(EINVAL);
+	}
+
+	if (!n)
+		return 0;
+
+	switch (prim) {
+	case SAVAGE_PRIM_TRILIST_201:
+		reorder = 1;
+		prim = SAVAGE_PRIM_TRILIST;
+	case SAVAGE_PRIM_TRILIST:
+		if (n % 3 != 0) {
+			DRM_ERROR("wrong number of indices %u in TRILIST\n",
+				  n);
+			return DRM_ERR(EINVAL);
+		}
+		break;
+	case SAVAGE_PRIM_TRISTRIP:
+	case SAVAGE_PRIM_TRIFAN:
+		if (n < 3) {
+			DRM_ERROR("wrong number of indices %u in TRIFAN/STRIP\n",
+				  n);
+			return DRM_ERR(EINVAL);
+		}
+		break;
+	default:
+		DRM_ERROR("invalid primitive type %u\n", prim);
+		return DRM_ERR(EINVAL);
+	}
+
+	if (S3_SAVAGE3D_SERIES(dev_priv->chipset)) {
+		if (skip != 0) {
+			DRM_ERROR("invalid skip flags 0x%04x for DMA\n",
+				  skip);
+			return DRM_ERR(EINVAL);
+		}
+	} else {
+		unsigned int size = 10 - (skip & 1) - (skip >> 1 & 1) -
+			(skip >> 2 & 1) - (skip >> 3 & 1) - (skip >> 4 & 1) -
+			(skip >> 5 & 1) - (skip >> 6 & 1) - (skip >> 7 & 1);
+		if (skip > SAVAGE_SKIP_ALL_S4 || size != 8) {
+			DRM_ERROR("invalid skip flags 0x%04x for DMA\n",
+				  skip);
+			return DRM_ERR(EINVAL);
+		}
+		if (reorder) {
+			DRM_ERROR("TRILIST_201 used on Savage4 hardware\n");
+			return DRM_ERR(EINVAL);
+		}
+	}
+
+	/* Vertex DMA doesn't work with command DMA at the same time,
+	 * so we use BCI_... to submit commands here. Flush buffered
+	 * faked DMA first. */
+	DMA_FLUSH();
+
+	if (dmabuf->bus_address != dev_priv->state.common.vbaddr) {
+		BEGIN_BCI(2);
+		BCI_SET_REGISTERS(SAVAGE_VERTBUFADDR, 1);
+		BCI_WRITE(dmabuf->bus_address | dev_priv->dma_type);
+		dev_priv->state.common.vbaddr = dmabuf->bus_address;
+	}
+	if (S3_SAVAGE3D_SERIES(dev_priv->chipset) && dev_priv->waiting) {
+		/* Workaround for what looks like a hardware bug. If a
+		 * WAIT_3D_IDLE was emitted some time before the
+		 * indexed drawing command then the engine will lock
+		 * up. There are two known workarounds:
+		 * WAIT_IDLE_EMPTY or emit at least 63 NOPs. */
+		BEGIN_BCI(63);
+		for (i = 0; i < 63; ++i)
+			BCI_WRITE(BCI_CMD_WAIT);
+		dev_priv->waiting = 0;
+	}
+
+	prim <<= 25;
+	while (n != 0) {
+		/* Can emit up to 255 indices (85 triangles) at once. */
+		unsigned int count = n > 255 ? 255 : n;
+		/* Is it ok to allocate 510 bytes on the stack in an ioctl? */
+		uint16_t idx[255];
+
+		/* Copy and check indices */
+		DRM_COPY_FROM_USER_UNCHECKED(idx, usr_idx, count*2);
+		for (i = 0; i < count; ++i) {
+			if (idx[i] > dmabuf->total/32) {
+				DRM_ERROR("idx[%u]=%u out of range (0-%u)\n",
+					  i, idx[i], dmabuf->total/32);
+				return DRM_ERR(EINVAL);
+			}
+		}
+
+		if (reorder) {
+			/* Need to reorder indices for correct flat
+			 * shading while preserving the clock sense
+			 * for correct culling. Only on Savage3D. */
+			int reorder[3] = {2, -1, -1};
+
+			BEGIN_BCI((count+1+1)/2);
+			BCI_DRAW_INDICES_S3D(count, prim, idx[2]);
+
+			for (i = 1; i+1 < count; i += 2)
+				BCI_WRITE(idx[i + reorder[i % 3]] |
+					  (idx[i+1 + reorder[(i+1) % 3]] << 16));
+			if (i < count)
+				BCI_WRITE(idx[i + reorder[i%3]]);
+		} else if (S3_SAVAGE3D_SERIES(dev_priv->chipset)) {
+			BEGIN_BCI((count+1+1)/2);
+			BCI_DRAW_INDICES_S3D(count, prim, idx[0]);
+
+			for (i = 1; i+1 < count; i += 2)
+				BCI_WRITE(idx[i] | (idx[i+1] << 16));
+			if (i < count)
+				BCI_WRITE(idx[i]);
+		} else {
+			BEGIN_BCI((count+2+1)/2);
+			BCI_DRAW_INDICES_S4(count, prim, skip);
+
+			for (i = 0; i+1 < count; i += 2)
+				BCI_WRITE(idx[i] | (idx[i+1] << 16));
+			if (i < count)
+				BCI_WRITE(idx[i]);
+		}
+
+		usr_idx += count;
+		n -= count;
+
+		prim |= BCI_CMD_DRAW_CONT;
+	}
+
+	return 0;
+}
+
+static int savage_dispatch_vb_idx(drm_savage_private_t *dev_priv,
+				  const drm_savage_cmd_header_t *cmd_header,
+				  const uint16_t __user *usr_idx,
+				  const uint32_t __user *vtxbuf,
+				  unsigned int vb_size,
+				  unsigned int vb_stride)
+{
+	unsigned char reorder = 0;
+	unsigned int prim = cmd_header->idx.prim;
+	unsigned int skip = cmd_header->idx.skip;
+	unsigned int n = cmd_header->idx.count;
+	unsigned int vtx_size;
+	unsigned int i;
+	DMA_LOCALS;
+
+	if (!n)
+		return 0;
+
+	switch (prim) {
+	case SAVAGE_PRIM_TRILIST_201:
+		reorder = 1;
+		prim = SAVAGE_PRIM_TRILIST;
+	case SAVAGE_PRIM_TRILIST:
+		if (n % 3 != 0) {
+			DRM_ERROR("wrong number of indices %u in TRILIST\n",
+				  n);
+			return DRM_ERR(EINVAL);
+		}
+		break;
+	case SAVAGE_PRIM_TRISTRIP:
+	case SAVAGE_PRIM_TRIFAN:
+		if (n < 3) {
+			DRM_ERROR("wrong number of indices %u in TRIFAN/STRIP\n",
+				  n);
+			return DRM_ERR(EINVAL);
+		}
+		break;
+	default:
+		DRM_ERROR("invalid primitive type %u\n", prim);
+		return DRM_ERR(EINVAL);
+	}
+
+	if (S3_SAVAGE3D_SERIES(dev_priv->chipset)) {
+		if (skip > SAVAGE_SKIP_ALL_S3D) {
+			DRM_ERROR("invalid skip flags 0x%04x\n", skip);
+			return DRM_ERR(EINVAL);
+		}
+		vtx_size = 8; /* full vertex */
+	} else {
+		if (skip > SAVAGE_SKIP_ALL_S4) {
+			DRM_ERROR("invalid skip flags 0x%04x\n", skip);
+			return DRM_ERR(EINVAL);
+		}
+		vtx_size = 10; /* full vertex */
+	}
+
+	vtx_size -= (skip & 1) + (skip >> 1 & 1) +
+		(skip >> 2 & 1) + (skip >> 3 & 1) + (skip >> 4 & 1) +
+		(skip >> 5 & 1) + (skip >> 6 & 1) + (skip >> 7 & 1);
+
+	if (vtx_size > vb_stride) {
+		DRM_ERROR("vertex size greater than vb stride (%u > %u)\n",
+			  vtx_size, vb_stride);
+		return DRM_ERR(EINVAL);
+	}
+
+	prim <<= 25;
+	while (n != 0) {
+		/* Can emit up to 255 vertices (85 triangles) at once. */
+		unsigned int count = n > 255 ? 255 : n;
+		/* Is it ok to allocate 510 bytes on the stack in an ioctl? */
+		uint16_t idx[255];
+
+		/* Copy and check indices */
+		DRM_COPY_FROM_USER_UNCHECKED(idx, usr_idx, count*2);
+		for (i = 0; i < count; ++i) {
+			if (idx[i] > vb_size / (vb_stride*4)) {
+				DRM_ERROR("idx[%u]=%u out of range (0-%u)\n",
+					  i, idx[i],  vb_size / (vb_stride*4));
+				return DRM_ERR(EINVAL);
+			}
+		}
+
+		if (reorder) {
+			/* Need to reorder vertices for correct flat
+			 * shading while preserving the clock sense
+			 * for correct culling. Only on Savage3D. */
+			int reorder[3] = {2, -1, -1};
+
+			BEGIN_DMA(count*vtx_size+1);
+			DMA_DRAW_PRIMITIVE(count, prim, skip);
+
+			for (i = 0; i < count; ++i) {
+				unsigned int j = idx[i + reorder[i % 3]];
+				DMA_COPY_FROM_USER(&vtxbuf[vb_stride*j],
+						   vtx_size);
+			}
+
+			DMA_COMMIT();
+		} else {
+			BEGIN_DMA(count*vtx_size+1);
+			DMA_DRAW_PRIMITIVE(count, prim, skip);
+
+			for (i = 0; i < count; ++i) {
+				unsigned int j = idx[i];
+				DMA_COPY_FROM_USER(&vtxbuf[vb_stride*j],
+						   vtx_size);
+			}
+
+			DMA_COMMIT();
+		}
+
+		usr_idx += count;
+		n -= count;
+
+		prim |= BCI_CMD_DRAW_CONT;
+	}
+
+	return 0;
+}
+
+static int savage_dispatch_clear(drm_savage_private_t *dev_priv,
+				 const drm_savage_cmd_header_t *cmd_header,
+				 const drm_savage_cmd_header_t __user *data,
+				 unsigned int nbox,
+				 const drm_clip_rect_t __user *usr_boxes)
+{
+	unsigned int flags = cmd_header->clear0.flags, mask, value;
+	unsigned int clear_cmd;
+	unsigned int i, nbufs;
+	DMA_LOCALS;
+
+	if (nbox == 0)
+		return 0;
+
+	DRM_GET_USER_UNCHECKED(mask, &((const drm_savage_cmd_header_t*)data)
+			       ->clear1.mask);
+	DRM_GET_USER_UNCHECKED(value, &((const drm_savage_cmd_header_t*)data)
+			       ->clear1.value);
+
+	clear_cmd = BCI_CMD_RECT | BCI_CMD_RECT_XP | BCI_CMD_RECT_YP |
+		BCI_CMD_SEND_COLOR | BCI_CMD_DEST_PBD_NEW;
+	BCI_CMD_SET_ROP(clear_cmd,0xCC);
+
+	nbufs = ((flags & SAVAGE_FRONT) ? 1 : 0) +
+		((flags & SAVAGE_BACK) ? 1 : 0) +
+		((flags & SAVAGE_DEPTH) ? 1 : 0);
+	if (nbufs == 0)
+		return 0;
+
+	if (mask != 0xffffffff) {
+		/* set mask */
+		BEGIN_DMA(2);
+		DMA_SET_REGISTERS(SAVAGE_BITPLANEWTMASK, 1);
+		DMA_WRITE(mask);
+		DMA_COMMIT();
+	}
+	for (i = 0; i < nbox; ++i) {
+		drm_clip_rect_t box;
+		unsigned int x, y, w, h;
+		unsigned int buf;
+		DRM_COPY_FROM_USER_UNCHECKED(&box, &usr_boxes[i], sizeof(box));
+		x = box.x1, y = box.y1;
+		w = box.x2 - box.x1;
+		h = box.y2 - box.y1;
+		BEGIN_DMA(nbufs*6);
+		for (buf = SAVAGE_FRONT; buf <= SAVAGE_DEPTH; buf <<= 1) {
+			if (!(flags & buf))
+				continue;
+			DMA_WRITE(clear_cmd);
+			switch(buf) {
+			case SAVAGE_FRONT:
+				DMA_WRITE(dev_priv->front_offset);
+				DMA_WRITE(dev_priv->front_bd);
+				break;
+			case SAVAGE_BACK:
+				DMA_WRITE(dev_priv->back_offset);
+				DMA_WRITE(dev_priv->back_bd);
+				break;
+			case SAVAGE_DEPTH:
+				DMA_WRITE(dev_priv->depth_offset);
+				DMA_WRITE(dev_priv->depth_bd);
+				break;
+			}
+			DMA_WRITE(value);
+			DMA_WRITE(BCI_X_Y(x, y));
+			DMA_WRITE(BCI_W_H(w, h));
+		}
+		DMA_COMMIT();
+	}
+	if (mask != 0xffffffff) {
+		/* reset mask */
+		BEGIN_DMA(2);
+		DMA_SET_REGISTERS(SAVAGE_BITPLANEWTMASK, 1);
+		DMA_WRITE(0xffffffff);
+		DMA_COMMIT();
+	}
+
+	return 0;
+}
+
+static int savage_dispatch_swap(drm_savage_private_t *dev_priv,
+				unsigned int nbox,
+				const drm_clip_rect_t __user *usr_boxes)
+{
+	unsigned int swap_cmd;
+	unsigned int i;
+	DMA_LOCALS;
+
+	if (nbox == 0)
+		return 0;
+
+	swap_cmd = BCI_CMD_RECT | BCI_CMD_RECT_XP | BCI_CMD_RECT_YP |
+		BCI_CMD_SRC_PBD_COLOR_NEW | BCI_CMD_DEST_GBD;
+	BCI_CMD_SET_ROP(swap_cmd,0xCC);
+
+	for (i = 0; i < nbox; ++i) {
+		drm_clip_rect_t box;
+		DRM_COPY_FROM_USER_UNCHECKED(&box, &usr_boxes[i], sizeof(box));
+
+		BEGIN_DMA(6);
+		DMA_WRITE(swap_cmd);
+		DMA_WRITE(dev_priv->back_offset);
+		DMA_WRITE(dev_priv->back_bd);
+		DMA_WRITE(BCI_X_Y(box.x1, box.y1));
+		DMA_WRITE(BCI_X_Y(box.x1, box.y1));
+		DMA_WRITE(BCI_W_H(box.x2-box.x1, box.y2-box.y1));
+		DMA_COMMIT();
+	}
+
+	return 0;
+}
+
+static int savage_dispatch_draw(drm_savage_private_t *dev_priv,
+				const drm_savage_cmd_header_t __user *start,
+				const drm_savage_cmd_header_t __user *end,
+				const drm_buf_t *dmabuf,
+				const unsigned int __user *usr_vtxbuf,
+				unsigned int vb_size, unsigned int vb_stride,
+				unsigned int nbox,
+				const drm_clip_rect_t __user *usr_boxes)
+{
+	unsigned int i, j;
+	int ret;
+
+	for (i = 0; i < nbox; ++i) {
+		drm_clip_rect_t box;
+		const drm_savage_cmd_header_t __user *usr_cmdbuf;
+		DRM_COPY_FROM_USER_UNCHECKED(&box, &usr_boxes[i], sizeof(box));
+		dev_priv->emit_clip_rect(dev_priv, &box);
+
+		usr_cmdbuf = start;
+		while (usr_cmdbuf < end) {
+			drm_savage_cmd_header_t cmd_header;
+			DRM_COPY_FROM_USER_UNCHECKED(&cmd_header, usr_cmdbuf,
+						     sizeof(cmd_header));
+			usr_cmdbuf++;
+			switch (cmd_header.cmd.cmd) {
+			case SAVAGE_CMD_DMA_PRIM:
+				ret = savage_dispatch_dma_prim(
+					dev_priv, &cmd_header, dmabuf);
+				break;
+			case SAVAGE_CMD_VB_PRIM:
+				ret = savage_dispatch_vb_prim(
+					dev_priv, &cmd_header,
+					(const uint32_t __user *)usr_vtxbuf,
+					vb_size, vb_stride);
+				break;
+			case SAVAGE_CMD_DMA_IDX:
+				j = (cmd_header.idx.count + 3) / 4;
+				/* j was check in savage_bci_cmdbuf */
+				ret = savage_dispatch_dma_idx(
+					dev_priv, &cmd_header,
+					(const uint16_t __user *)usr_cmdbuf,
+					dmabuf);
+				usr_cmdbuf += j;
+				break;
+			case SAVAGE_CMD_VB_IDX:
+				j = (cmd_header.idx.count + 3) / 4;
+				/* j was check in savage_bci_cmdbuf */
+				ret = savage_dispatch_vb_idx(
+					dev_priv, &cmd_header,
+					(const uint16_t __user *)usr_cmdbuf,
+					(const uint32_t __user *)usr_vtxbuf,
+					vb_size, vb_stride);
+				usr_cmdbuf += j;
+				break;
+			default:
+				/* What's the best return code? EFAULT? */
+				DRM_ERROR("IMPLEMENTATION ERROR: "
+					  "non-drawing-command %d\n",
+					  cmd_header.cmd.cmd);
+				return DRM_ERR(EINVAL);
+			}
+
+			if (ret != 0)
+				return ret;
+		}
+	}
+
+	return 0;
+}
+
+int savage_bci_cmdbuf(DRM_IOCTL_ARGS)
+{
+	DRM_DEVICE;
+	drm_savage_private_t *dev_priv = dev->dev_private;
+	drm_device_dma_t *dma = dev->dma;
+	drm_buf_t *dmabuf;
+	drm_savage_cmdbuf_t cmdbuf;
+	drm_savage_cmd_header_t __user *usr_cmdbuf;
+	drm_savage_cmd_header_t __user *first_draw_cmd;
+	unsigned int __user *usr_vtxbuf;
+	drm_clip_rect_t __user *usr_boxes;
+	unsigned int i, j;
+	int ret = 0;
+
+	DRM_DEBUG("\n");
+	
+	LOCK_TEST_WITH_RETURN(dev, filp);
+
+	DRM_COPY_FROM_USER_IOCTL(cmdbuf, (drm_savage_cmdbuf_t __user *)data,
+				 sizeof(cmdbuf));
+
+	if (dma && dma->buflist) {
+		if (cmdbuf.dma_idx > dma->buf_count) {
+			DRM_ERROR("vertex buffer index %u out of range (0-%u)\n",
+				  cmdbuf.dma_idx, dma->buf_count-1);
+			return DRM_ERR(EINVAL);
+		}
+		dmabuf = dma->buflist[cmdbuf.dma_idx];
+	} else {
+		dmabuf = NULL;
+	}
+
+	usr_cmdbuf = (drm_savage_cmd_header_t __user *)cmdbuf.cmd_addr;
+	usr_vtxbuf = (unsigned int __user *)cmdbuf.vb_addr;
+	usr_boxes = (drm_clip_rect_t __user *)cmdbuf.box_addr;
+	if ((cmdbuf.size && DRM_VERIFYAREA_READ(usr_cmdbuf, cmdbuf.size*8)) ||
+	    (cmdbuf.vb_size && DRM_VERIFYAREA_READ(
+		    usr_vtxbuf, cmdbuf.vb_size)) ||
+	    (cmdbuf.nbox && DRM_VERIFYAREA_READ(
+		    usr_boxes, cmdbuf.nbox*sizeof(drm_clip_rect_t))))
+		return DRM_ERR(EFAULT);
+
+	/* Make sure writes to DMA buffers are finished before sending
+	 * DMA commands to the graphics hardware. */
+	DRM_MEMORYBARRIER();
+
+	/* Coming from user space. Don't know if the Xserver has
+	 * emitted wait commands. Assuming the worst. */
+	dev_priv->waiting = 1;
+
+	i = 0;
+	first_draw_cmd = NULL;
+	while (i < cmdbuf.size) {
+		drm_savage_cmd_header_t cmd_header;
+		DRM_COPY_FROM_USER_UNCHECKED(&cmd_header, usr_cmdbuf,
+					     sizeof(cmd_header));
+		usr_cmdbuf++;
+		i++;
+
+		/* Group drawing commands with same state to minimize
+		 * iterations over clip rects. */
+		j = 0;
+		switch (cmd_header.cmd.cmd) {
+		case SAVAGE_CMD_DMA_IDX:
+		case SAVAGE_CMD_VB_IDX:
+			j = (cmd_header.idx.count + 3) / 4;
+			if (i + j > cmdbuf.size) {
+				DRM_ERROR("indexed drawing command extends "
+					  "beyond end of command buffer\n");
+				DMA_FLUSH();
+				return DRM_ERR(EINVAL);
+			}
+			/* fall through */
+		case SAVAGE_CMD_DMA_PRIM:
+		case SAVAGE_CMD_VB_PRIM:
+			if (!first_draw_cmd)
+				first_draw_cmd = usr_cmdbuf-1;
+			usr_cmdbuf += j;
+			i += j;
+			break;
+		default:
+			if (first_draw_cmd) {
+				ret = savage_dispatch_draw (
+					dev_priv, first_draw_cmd, usr_cmdbuf-1,
+					dmabuf, usr_vtxbuf, cmdbuf.vb_size,
+					cmdbuf.vb_stride,
+					cmdbuf.nbox, usr_boxes);
+				if (ret != 0)
+					return ret;
+				first_draw_cmd = NULL;
+			}
+		}
+		if (first_draw_cmd)
+			continue;
+
+		switch (cmd_header.cmd.cmd) {
+		case SAVAGE_CMD_STATE:
+			j = (cmd_header.state.count + 1) / 2;
+			if (i + j > cmdbuf.size) {
+				DRM_ERROR("command SAVAGE_CMD_STATE extends "
+					  "beyond end of command buffer\n");
+				DMA_FLUSH();
+				return DRM_ERR(EINVAL);
+			}
+			ret = savage_dispatch_state(
+				dev_priv, &cmd_header,
+				(uint32_t __user *)usr_cmdbuf);
+			usr_cmdbuf += j;
+			i += j;
+			break;
+		case SAVAGE_CMD_CLEAR:
+			if (i + 1 > cmdbuf.size) {
+				DRM_ERROR("command SAVAGE_CMD_CLEAR extends "
+					  "beyond end of command buffer\n");
+				DMA_FLUSH();
+				return DRM_ERR(EINVAL);
+			}
+			ret = savage_dispatch_clear(dev_priv, &cmd_header,
+						    usr_cmdbuf,
+						    cmdbuf.nbox, usr_boxes);
+			usr_cmdbuf++;
+			i++;
+			break;
+		case SAVAGE_CMD_SWAP:
+			ret = savage_dispatch_swap(dev_priv,
+						   cmdbuf.nbox, usr_boxes);
+			break;
+		default:
+			DRM_ERROR("invalid command 0x%x\n", cmd_header.cmd.cmd);
+			DMA_FLUSH();
+			return DRM_ERR(EINVAL);
+		}
+
+		if (ret != 0) {
+			DMA_FLUSH();
+			return ret;
+		}
+	}
+
+	if (first_draw_cmd) {
+		ret = savage_dispatch_draw (
+			dev_priv, first_draw_cmd, usr_cmdbuf, dmabuf,
+			usr_vtxbuf, cmdbuf.vb_size, cmdbuf.vb_stride,
+			cmdbuf.nbox, usr_boxes);
+		if (ret != 0) {
+			DMA_FLUSH();
+			return ret;
+		}
+	}
+
+	DMA_FLUSH();
+
+	if (dmabuf && cmdbuf.discard) {
+		drm_savage_buf_priv_t *buf_priv = dmabuf->dev_private;
+		uint16_t event;
+		event = savage_bci_emit_event(dev_priv, SAVAGE_WAIT_3D);
+		SET_AGE(&buf_priv->age, event, dev_priv->event_wrap);
+		savage_freelist_put(dev, dmabuf);
+	}
+
+	return 0;
+}
diff -purN linux-2.6.12.orig/drivers/char/drm/sis_drm.h linux-2.6.12/drivers/char/drm/sis_drm.h
--- linux-2.6.12.orig/drivers/char/drm/sis_drm.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/sis_drm.h	2005-07-05 08:37:49.000000000 +0200
@@ -39,4 +39,4 @@ typedef struct {
 	unsigned int offset, size;
 } drm_sis_fb_t;
 
-#endif /* __SIS_DRM_H__ */
+#endif				/* __SIS_DRM_H__ */
diff -purN linux-2.6.12.orig/drivers/char/drm/sis_drv.c linux-2.6.12/drivers/char/drm/sis_drv.c
--- linux-2.6.12.orig/drivers/char/drm/sis_drv.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/sis_drv.c	2005-07-05 08:37:27.000000000 +0200
@@ -10,11 +10,11 @@
  * the rights to use, copy, modify, merge, publish, distribute, sublicense,
  * and/or sell copies of the Software, and to permit persons to whom the
  * Software is furnished to do so, subject to the following conditions:
- * 
+ *
  * The above copyright notice and this permission notice (including the next
  * paragraph) shall be included in all copies or substantial portions of the
  * Software.
- * 
+ *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
@@ -31,41 +31,40 @@
 #include "sis_drv.h"
 
 #include "drm_pciids.h"
-  
-static int postinit( struct drm_device *dev, unsigned long flags )
+
+static int postinit(struct drm_device *dev, unsigned long flags)
 {
-	DRM_INFO( "Initialized %s %d.%d.%d %s on minor %d: %s\n",
-		DRIVER_NAME,
-		DRIVER_MAJOR,
-		DRIVER_MINOR,
-		DRIVER_PATCHLEVEL,
-		DRIVER_DATE,
-		dev->primary.minor,
-		pci_pretty_name(dev->pdev)
-		);
+	DRM_INFO("Initialized %s %d.%d.%d %s on minor %d: %s\n",
+		 DRIVER_NAME,
+		 DRIVER_MAJOR,
+		 DRIVER_MINOR,
+		 DRIVER_PATCHLEVEL,
+		 DRIVER_DATE, dev->primary.minor, pci_pretty_name(dev->pdev)
+	    );
 	return 0;
 }
 
-static int version( drm_version_t *version )
+static int version(drm_version_t * version)
 {
 	int len;
 
 	version->version_major = DRIVER_MAJOR;
 	version->version_minor = DRIVER_MINOR;
 	version->version_patchlevel = DRIVER_PATCHLEVEL;
-	DRM_COPY( version->name, DRIVER_NAME );
-	DRM_COPY( version->date, DRIVER_DATE );
-	DRM_COPY( version->desc, DRIVER_DESC );
+	DRM_COPY(version->name, DRIVER_NAME);
+	DRM_COPY(version->date, DRIVER_DATE);
+	DRM_COPY(version->desc, DRIVER_DESC);
 	return 0;
 }
 
 static struct pci_device_id pciidlist[] = {
-	sisdrv_PCI_IDS
+	sis_PCI_IDS
 };
 
 extern drm_ioctl_desc_t sis_ioctls[];
 extern int sis_max_ioctl;
 
+static int probe(struct pci_dev *pdev, const struct pci_device_id *ent);
 static struct drm_driver driver = {
 	.driver_features = DRIVER_USE_AGP | DRIVER_USE_MTRR,
 	.context_ctor = sis_init_context,
@@ -84,17 +83,24 @@ static struct drm_driver driver = {
 		.mmap = drm_mmap,
 		.poll = drm_poll,
 		.fasync = drm_fasync,
-	},
+		},
 	.pci_driver = {
-		.name          = DRIVER_NAME,
-		.id_table      = pciidlist,
+		.name = DRIVER_NAME,
+		.id_table = pciidlist,
+		.probe = probe,
+		.remove = __devexit_p(drm_cleanup_pci),
 	}
 };
 
+static int probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	return drm_get_dev(pdev, ent, &driver);
+}
+
 static int __init sis_init(void)
 {
 	driver.num_ioctls = sis_max_ioctl;
-	return drm_init(&driver);
+	return drm_init(&driver, pciidlist);
 }
 
 static void __exit sis_exit(void)
@@ -105,6 +111,6 @@ static void __exit sis_exit(void)
 module_init(sis_init);
 module_exit(sis_exit);
 
-MODULE_AUTHOR( DRIVER_AUTHOR );
-MODULE_DESCRIPTION( DRIVER_DESC );
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL and additional rights");
diff -purN linux-2.6.12.orig/drivers/char/drm/sis_drv.h linux-2.6.12/drivers/char/drm/sis_drv.h
--- linux-2.6.12.orig/drivers/char/drm/sis_drv.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/sis_drv.h	2005-07-05 08:37:49.000000000 +0200
@@ -10,11 +10,11 @@
  * the rights to use, copy, modify, merge, publish, distribute, sublicense,
  * and/or sell copies of the Software, and to permit persons to whom the
  * Software is furnished to do so, subject to the following conditions:
- * 
+ *
  * The above copyright notice and this permission notice (including the next
  * paragraph) shall be included in all copies or substantial portions of the
  * Software.
- * 
+ *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
@@ -22,7 +22,7 @@
  * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  * DEALINGS IN THE SOFTWARE.
- * 
+ *
  */
 
 #ifndef _SIS_DRV_H_
@@ -46,7 +46,7 @@ typedef struct drm_sis_private {
 	memHeap_t *FBHeap;
 } drm_sis_private_t;
 
-extern int sis_init_context(drm_device_t *dev, int context);
-extern int sis_final_context(drm_device_t *dev, int context);
+extern int sis_init_context(drm_device_t * dev, int context);
+extern int sis_final_context(drm_device_t * dev, int context);
 
 #endif
diff -purN linux-2.6.12.orig/drivers/char/drm/sis_ds.c linux-2.6.12/drivers/char/drm/sis_ds.c
--- linux-2.6.12.orig/drivers/char/drm/sis_ds.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/sis_ds.c	2005-07-05 08:37:47.000000000 +0200
@@ -10,11 +10,11 @@
  * the rights to use, copy, modify, merge, publish, distribute, sublicense,
  * and/or sell copies of the Software, and to permit persons to whom the
  * Software is furnished to do so, subject to the following conditions:
- * 
+ *
  * The above copyright notice and this permission notice (including the next
  * paragraph) shall be included in all copies or substantial portions of the
  * Software.
- * 
+ *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
@@ -22,10 +22,10 @@
  * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  * DEALINGS IN THE SOFTWARE.
- * 
+ *
  * Authors:
  *    Sung-Ching Lin <sclin@sis.com.tw>
- * 
+ *
  */
 
 #include "drmP.h"
@@ -41,13 +41,13 @@ set_t *setInit(void)
 	int i;
 	set_t *set;
 
-	set = (set_t *)drm_alloc(sizeof(set_t), DRM_MEM_DRIVER);
+	set = (set_t *) drm_alloc(sizeof(set_t), DRM_MEM_DRIVER);
 	if (set != NULL) {
 		for (i = 0; i < SET_SIZE; i++) {
-			set->list[i].free_next = i + 1;    
+			set->list[i].free_next = i + 1;
 			set->list[i].alloc_next = -1;
 		}
-		set->list[SET_SIZE-1].free_next = -1;
+		set->list[SET_SIZE - 1].free_next = -1;
 		set->free = 0;
 		set->alloc = -1;
 		set->trace = -1;
@@ -55,10 +55,10 @@ set_t *setInit(void)
 	return set;
 }
 
-int setAdd(set_t *set, ITEM_TYPE item)
+int setAdd(set_t * set, ITEM_TYPE item)
 {
 	int free = set->free;
-  
+
 	if (free != -1) {
 		set->list[free].val = item;
 		set->free = set->list[free].free_next;
@@ -67,16 +67,16 @@ int setAdd(set_t *set, ITEM_TYPE item)
 	}
 
 	set->list[free].alloc_next = set->alloc;
-	set->alloc = free;  
-	set->list[free].free_next = -1;    
+	set->alloc = free;
+	set->list[free].free_next = -1;
 
 	return 1;
 }
 
-int setDel(set_t *set, ITEM_TYPE item)
+int setDel(set_t * set, ITEM_TYPE item)
 {
 	int alloc = set->alloc;
-	int prev = -1;  
+	int prev = -1;
 
 	while (alloc != -1) {
 		if (set->list[alloc].val == item) {
@@ -103,7 +103,7 @@ int setDel(set_t *set, ITEM_TYPE item)
 
 /* setFirst -> setAdd -> setNext is wrong */
 
-int setFirst(set_t *set, ITEM_TYPE *item)
+int setFirst(set_t * set, ITEM_TYPE * item)
 {
 	if (set->alloc == -1)
 		return 0;
@@ -114,7 +114,7 @@ int setFirst(set_t *set, ITEM_TYPE *item
 	return 1;
 }
 
-int setNext(set_t *set, ITEM_TYPE *item)
+int setNext(set_t * set, ITEM_TYPE * item)
 {
 	if (set->trace == -1)
 		return 0;
@@ -125,7 +125,7 @@ int setNext(set_t *set, ITEM_TYPE *item)
 	return 1;
 }
 
-int setDestroy(set_t *set)
+int setDestroy(set_t * set)
 {
 	drm_free(set, sizeof(set_t), DRM_MEM_DRIVER);
 
@@ -149,35 +149,34 @@ int setDestroy(set_t *set)
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * WITTAWAT YAMWONG, OR ANY OTHER CONTRIBUTORS BE LIABLE FOR ANY CLAIM, 
- * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
- * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE 
+ * KEITH WHITWELL, OR ANY OTHER CONTRIBUTORS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  *
  */
 
 #define ISFREE(bptr) ((bptr)->free)
 
-memHeap_t *mmInit(int ofs,
-		  int size)
+memHeap_t *mmInit(int ofs, int size)
 {
 	PMemBlock blocks;
 
 	if (size <= 0)
 		return NULL;
 
-	blocks = (TMemBlock *)drm_calloc(1, sizeof(TMemBlock), DRM_MEM_DRIVER);
+	blocks = (TMemBlock *) drm_calloc(1, sizeof(TMemBlock), DRM_MEM_DRIVER);
 	if (blocks != NULL) {
 		blocks->ofs = ofs;
 		blocks->size = size;
 		blocks->free = 1;
-		return (memHeap_t *)blocks;
+		return (memHeap_t *) blocks;
 	} else
 		return NULL;
 }
 
 /* Checks if a pointer 'b' is part of the heap 'heap' */
-int mmBlockInHeap(memHeap_t *heap, PMemBlock b)
+int mmBlockInHeap(memHeap_t * heap, PMemBlock b)
 {
 	TMemBlock *p;
 
@@ -194,16 +193,16 @@ int mmBlockInHeap(memHeap_t *heap, PMemB
 		return 0;
 }
 
-static TMemBlock* SliceBlock(TMemBlock *p, 
-			     int startofs, int size, 
+static TMemBlock *SliceBlock(TMemBlock * p,
+			     int startofs, int size,
 			     int reserved, int alignment)
 {
 	TMemBlock *newblock;
 
 	/* break left */
 	if (startofs > p->ofs) {
-		newblock = (TMemBlock*) drm_calloc(1, sizeof(TMemBlock),
-		    DRM_MEM_DRIVER);
+		newblock = (TMemBlock *) drm_calloc(1, sizeof(TMemBlock),
+						    DRM_MEM_DRIVER);
 		newblock->ofs = startofs;
 		newblock->size = p->size - (startofs - p->ofs);
 		newblock->free = 1;
@@ -215,8 +214,8 @@ static TMemBlock* SliceBlock(TMemBlock *
 
 	/* break right */
 	if (size < p->size) {
-		newblock = (TMemBlock*) drm_calloc(1, sizeof(TMemBlock),
-		    DRM_MEM_DRIVER);
+		newblock = (TMemBlock *) drm_calloc(1, sizeof(TMemBlock),
+						    DRM_MEM_DRIVER);
 		newblock->ofs = startofs + size;
 		newblock->size = p->size - size;
 		newblock->free = 1;
@@ -232,37 +231,37 @@ static TMemBlock* SliceBlock(TMemBlock *
 	return p;
 }
 
-PMemBlock mmAllocMem( memHeap_t *heap, int size, int align2, int startSearch)
+PMemBlock mmAllocMem(memHeap_t * heap, int size, int align2, int startSearch)
 {
-	int mask,startofs, endofs;
+	int mask, startofs, endofs;
 	TMemBlock *p;
-	
+
 	if (heap == NULL || align2 < 0 || size <= 0)
 		return NULL;
 
-	mask = (1 << align2)-1;
+	mask = (1 << align2) - 1;
 	startofs = 0;
-	p = (TMemBlock *)heap;
+	p = (TMemBlock *) heap;
 	while (p != NULL) {
 		if (ISFREE(p)) {
 			startofs = (p->ofs + mask) & ~mask;
-			if ( startofs < startSearch ) {
+			if (startofs < startSearch) {
 				startofs = startSearch;
 			}
-			endofs = startofs+size;
-			if (endofs <= (p->ofs+p->size))
+			endofs = startofs + size;
+			if (endofs <= (p->ofs + p->size))
 				break;
 		}
 		p = p->next;
 	}
 	if (p == NULL)
 		return NULL;
-	p = SliceBlock(p,startofs,size,0,mask+1);
+	p = SliceBlock(p, startofs, size, 0, mask + 1);
 	p->heap = heap;
 	return p;
 }
 
-static __inline__ int Join2Blocks(TMemBlock *p)
+static __inline__ int Join2Blocks(TMemBlock * p)
 {
 	if (p->free && p->next && p->next->free) {
 		TMemBlock *q = p->next;
@@ -295,7 +294,6 @@ int mmFreeMem(PMemBlock b)
 	p->free = 1;
 	Join2Blocks(p);
 	if (prev)
-	Join2Blocks(prev);
+		Join2Blocks(prev);
 	return 0;
 }
-
diff -purN linux-2.6.12.orig/drivers/char/drm/sis_ds.h linux-2.6.12/drivers/char/drm/sis_ds.h
--- linux-2.6.12.orig/drivers/char/drm/sis_ds.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/sis_ds.h	2005-07-05 08:37:49.000000000 +0200
@@ -10,11 +10,11 @@
  * the rights to use, copy, modify, merge, publish, distribute, sublicense,
  * and/or sell copies of the Software, and to permit persons to whom the
  * Software is furnished to do so, subject to the following conditions:
- * 
+ *
  * The above copyright notice and this permission notice (including the next
  * paragraph) shall be included in all copies or substantial portions of the
  * Software.
- * 
+ *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
@@ -22,10 +22,10 @@
  * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  * DEALINGS IN THE SOFTWARE.
- * 
+ *
  * Authors:
  *    Sung-Ching Lin <sclin@sis.com.tw>
- * 
+ *
  */
 
 #ifndef __SIS_DS_H__
@@ -35,7 +35,7 @@
 
 #define SET_SIZE 5000
 
-typedef unsigned int ITEM_TYPE;
+typedef unsigned long ITEM_TYPE;
 
 typedef struct {
 	ITEM_TYPE val;
@@ -50,11 +50,11 @@ typedef struct {
 } set_t;
 
 set_t *setInit(void);
-int setAdd(set_t *set, ITEM_TYPE item);
-int setDel(set_t *set, ITEM_TYPE item);
-int setFirst(set_t *set, ITEM_TYPE *item);
-int setNext(set_t *set, ITEM_TYPE *item);
-int setDestroy(set_t *set);
+int setAdd(set_t * set, ITEM_TYPE item);
+int setDel(set_t * set, ITEM_TYPE item);
+int setFirst(set_t * set, ITEM_TYPE * item);
+int setNext(set_t * set, ITEM_TYPE * item);
+int setDestroy(set_t * set);
 
 /*
  * GLX Hardware Device Driver common code
@@ -73,9 +73,9 @@ int setDestroy(set_t *set);
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * WITTAWAT YAMWONG, OR ANY OTHER CONTRIBUTORS BE LIABLE FOR ANY CLAIM, 
- * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
- * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE 
+ * KEITH WHITWELL, OR ANY OTHER CONTRIBUTORS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  *
  */
@@ -83,7 +83,7 @@ int setDestroy(set_t *set);
 struct mem_block_t {
 	struct mem_block_t *next;
 	struct mem_block_t *heap;
-	int ofs,size;
+	int ofs, size;
 	int align;
 	unsigned int free:1;
 	unsigned int reserved:1;
@@ -109,11 +109,11 @@ static __inline__ void mmMarkReserved(PM
 	b->reserved = 1;
 }
 
-/* 
+/*
  * input: total size in bytes
  * return: a heap pointer if OK, NULL if error
  */
-memHeap_t *mmInit( int ofs, int size );
+memHeap_t *mmInit(int ofs, int size);
 
 /*
  * Allocate 'size' bytes with 2^align2 bytes alignment,
@@ -125,21 +125,21 @@ memHeap_t *mmInit( int ofs, int size );
  *		startSearch = linear offset from start of heap to begin search
  * return: pointer to the allocated block, 0 if error
  */
-PMemBlock mmAllocMem( memHeap_t *heap, int size, int align2, int startSearch );
+PMemBlock mmAllocMem(memHeap_t * heap, int size, int align2, int startSearch);
 
 /*
  * Returns 1 if the block 'b' is part of the heap 'heap'
  */
-int mmBlockInHeap( PMemBlock heap, PMemBlock b );
+int mmBlockInHeap(PMemBlock heap, PMemBlock b);
 
 /*
  * Free block starts at offset
  * input: pointer to a block
  * return: 0 if OK, -1 if error
  */
-int mmFreeMem( PMemBlock b );
+int mmFreeMem(PMemBlock b);
 
 /* For debuging purpose. */
-void mmDumpMemInfo( memHeap_t *mmInit );
+void mmDumpMemInfo(memHeap_t * mmInit);
 
-#endif /* __SIS_DS_H__ */
+#endif				/* __SIS_DS_H__ */
diff -purN linux-2.6.12.orig/drivers/char/drm/sis_mm.c linux-2.6.12/drivers/char/drm/sis_mm.c
--- linux-2.6.12.orig/drivers/char/drm/sis_mm.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/sis_mm.c	2005-07-05 08:37:47.000000000 +0200
@@ -10,11 +10,11 @@
  * the rights to use, copy, modify, merge, publish, distribute, sublicense,
  * and/or sell copies of the Software, and to permit persons to whom the
  * Software is furnished to do so, subject to the following conditions:
- * 
+ *
  * The above copyright notice and this permission notice (including the next
  * paragraph) shall be included in all copies or substantial portions of the
  * Software.
- * 
+ *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
@@ -22,40 +22,42 @@
  * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  * DEALINGS IN THE SOFTWARE.
- * 
+ *
  * Authors:
  *    Sung-Ching Lin <sclin@sis.com.tw>
- * 
+ *
  */
 
+#if defined(__linux__) && defined(CONFIG_FB_SIS)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#include <video/sisfb.h>
+#else
+#include <linux/sisfb.h>
+#endif
+#endif
 #include "drmP.h"
 #include "sis_drm.h"
 #include "sis_drv.h"
 #include "sis_ds.h"
-#if defined(__linux__) && defined(CONFIG_FB_SIS)
-#include <video/sisfb.h>
-#endif
 
 #define MAX_CONTEXT 100
-#define VIDEO_TYPE 0 
+#define VIDEO_TYPE 0
 #define AGP_TYPE 1
 
 typedef struct {
 	int used;
 	int context;
-	set_t *sets[2]; /* 0 for video, 1 for AGP */
+	set_t *sets[2];		/* 0 for video, 1 for AGP */
 } sis_context_t;
 
 static sis_context_t global_ppriv[MAX_CONTEXT];
 
-
 static int add_alloc_set(int context, int type, unsigned int val)
 {
 	int i, retval = 0;
-	
+
 	for (i = 0; i < MAX_CONTEXT; i++) {
-		if (global_ppriv[i].used && global_ppriv[i].context == context)
-		{
+		if (global_ppriv[i].used && global_ppriv[i].context == context) {
 			retval = setAdd(global_ppriv[i].sets[type], val);
 			break;
 		}
@@ -64,12 +66,11 @@ static int add_alloc_set(int context, in
 }
 
 static int del_alloc_set(int context, int type, unsigned int val)
-{  
+{
 	int i, retval = 0;
 
 	for (i = 0; i < MAX_CONTEXT; i++) {
-		if (global_ppriv[i].used && global_ppriv[i].context == context)
-		{
+		if (global_ppriv[i].used && global_ppriv[i].context == context) {
 			retval = setDel(global_ppriv[i].sets[type], val);
 			break;
 		}
@@ -77,15 +78,15 @@ static int del_alloc_set(int context, in
 	return retval;
 }
 
-/* fb management via fb device */ 
+/* fb management via fb device */
 #if defined(__linux__) && defined(CONFIG_FB_SIS)
 
-static int sis_fb_init( DRM_IOCTL_ARGS )
+static int sis_fb_init(DRM_IOCTL_ARGS)
 {
 	return 0;
 }
 
-static int sis_fb_alloc( DRM_IOCTL_ARGS )
+static int sis_fb_alloc(DRM_IOCTL_ARGS)
 {
 	drm_sis_mem_t fb;
 	struct sis_memreq req;
@@ -105,7 +106,7 @@ static int sis_fb_alloc( DRM_IOCTL_ARGS 
 			sis_free(req.offset);
 			retval = DRM_ERR(EINVAL);
 		}
-	} else {  
+	} else {
 		fb.offset = 0;
 		fb.size = 0;
 		fb.free = 0;
@@ -113,26 +114,26 @@ static int sis_fb_alloc( DRM_IOCTL_ARGS 
 
 	DRM_COPY_TO_USER_IOCTL(argp, fb, sizeof(fb));
 
-	DRM_DEBUG("alloc fb, size = %d, offset = %d\n", fb.size, req.offset);
+	DRM_DEBUG("alloc fb, size = %d, offset = %ld\n", fb.size, req.offset);
 
 	return retval;
 }
 
-static int sis_fb_free( DRM_IOCTL_ARGS )
+static int sis_fb_free(DRM_IOCTL_ARGS)
 {
 	drm_sis_mem_t fb;
 	int retval = 0;
 
-	DRM_COPY_FROM_USER_IOCTL(fb, (drm_sis_mem_t __user *)data, sizeof(fb));
+	DRM_COPY_FROM_USER_IOCTL(fb, (drm_sis_mem_t __user *) data, sizeof(fb));
 
 	if (!fb.free)
 		return DRM_ERR(EINVAL);
 
 	if (!del_alloc_set(fb.context, VIDEO_TYPE, fb.free))
 		retval = DRM_ERR(EINVAL);
-	sis_free((u32)fb.free);
+	sis_free(fb.free);
 
-	DRM_DEBUG("free fb, offset = %lu\n", fb.free);
+	DRM_DEBUG("free fb, offset = 0x%lx\n", fb.free);
 
 	return retval;
 }
@@ -149,17 +150,17 @@ static int sis_fb_free( DRM_IOCTL_ARGS )
  *    X driver/sisfb                                  HW-   Command-
  *  framebuffer memory           DRI heap           Cursor   queue
  */
-static int sis_fb_init( DRM_IOCTL_ARGS )
+static int sis_fb_init(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_sis_private_t *dev_priv = dev->dev_private;
 	drm_sis_fb_t fb;
 
-	DRM_COPY_FROM_USER_IOCTL(fb, (drm_sis_fb_t __user *)data, sizeof(fb));
+	DRM_COPY_FROM_USER_IOCTL(fb, (drm_sis_fb_t __user *) data, sizeof(fb));
 
 	if (dev_priv == NULL) {
 		dev->dev_private = drm_calloc(1, sizeof(drm_sis_private_t),
-		    DRM_MEM_DRIVER);
+					      DRM_MEM_DRIVER);
 		dev_priv = dev->dev_private;
 		if (dev_priv == NULL)
 			return ENOMEM;
@@ -175,7 +176,7 @@ static int sis_fb_init( DRM_IOCTL_ARGS )
 	return 0;
 }
 
-static int sis_fb_alloc( DRM_IOCTL_ARGS )
+static int sis_fb_alloc(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_sis_private_t *dev_priv = dev->dev_private;
@@ -186,9 +187,9 @@ static int sis_fb_alloc( DRM_IOCTL_ARGS 
 
 	if (dev_priv == NULL || dev_priv->FBHeap == NULL)
 		return DRM_ERR(EINVAL);
-  
+
 	DRM_COPY_FROM_USER_IOCTL(fb, argp, sizeof(fb));
-  
+
 	block = mmAllocMem(dev_priv->FBHeap, fb.size, 0, 0);
 	if (block) {
 		/* TODO */
@@ -196,7 +197,7 @@ static int sis_fb_alloc( DRM_IOCTL_ARGS 
 		fb.free = (unsigned long)block;
 		if (!add_alloc_set(fb.context, VIDEO_TYPE, fb.free)) {
 			DRM_DEBUG("adding to allocation set fails\n");
-			mmFreeMem((PMemBlock)fb.free);
+			mmFreeMem((PMemBlock) fb.free);
 			retval = DRM_ERR(EINVAL);
 		}
 	} else {
@@ -212,7 +213,7 @@ static int sis_fb_alloc( DRM_IOCTL_ARGS 
 	return retval;
 }
 
-static int sis_fb_free( DRM_IOCTL_ARGS )
+static int sis_fb_free(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_sis_private_t *dev_priv = dev->dev_private;
@@ -221,14 +222,14 @@ static int sis_fb_free( DRM_IOCTL_ARGS )
 	if (dev_priv == NULL || dev_priv->FBHeap == NULL)
 		return DRM_ERR(EINVAL);
 
-	DRM_COPY_FROM_USER_IOCTL(fb, (drm_sis_mem_t __user *)data, sizeof(fb));
+	DRM_COPY_FROM_USER_IOCTL(fb, (drm_sis_mem_t __user *) data, sizeof(fb));
 
-	if (!mmBlockInHeap(dev_priv->FBHeap, (PMemBlock)fb.free))
+	if (!mmBlockInHeap(dev_priv->FBHeap, (PMemBlock) fb.free))
 		return DRM_ERR(EINVAL);
 
 	if (!del_alloc_set(fb.context, VIDEO_TYPE, fb.free))
 		return DRM_ERR(EINVAL);
-	mmFreeMem((PMemBlock)fb.free);
+	mmFreeMem((PMemBlock) fb.free);
 
 	DRM_DEBUG("free fb, free = 0x%lx\n", fb.free);
 
@@ -237,9 +238,9 @@ static int sis_fb_free( DRM_IOCTL_ARGS )
 
 #endif
 
-/* agp memory management */ 
+/* agp memory management */
 
-static int sis_ioctl_agp_init( DRM_IOCTL_ARGS )
+static int sis_ioctl_agp_init(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_sis_private_t *dev_priv = dev->dev_private;
@@ -247,7 +248,7 @@ static int sis_ioctl_agp_init( DRM_IOCTL
 
 	if (dev_priv == NULL) {
 		dev->dev_private = drm_calloc(1, sizeof(drm_sis_private_t),
-		    DRM_MEM_DRIVER);
+					      DRM_MEM_DRIVER);
 		dev_priv = dev->dev_private;
 		if (dev_priv == NULL)
 			return ENOMEM;
@@ -256,29 +257,30 @@ static int sis_ioctl_agp_init( DRM_IOCTL
 	if (dev_priv->AGPHeap != NULL)
 		return DRM_ERR(EINVAL);
 
-	DRM_COPY_FROM_USER_IOCTL(agp, (drm_sis_agp_t __user *)data, sizeof(agp));
+	DRM_COPY_FROM_USER_IOCTL(agp, (drm_sis_agp_t __user *) data,
+				 sizeof(agp));
 
 	dev_priv->AGPHeap = mmInit(agp.offset, agp.size);
 
 	DRM_DEBUG("offset = %u, size = %u", agp.offset, agp.size);
-  
+
 	return 0;
 }
 
-static int sis_ioctl_agp_alloc( DRM_IOCTL_ARGS )
+static int sis_ioctl_agp_alloc(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_sis_private_t *dev_priv = dev->dev_private;
-	drm_sis_mem_t __user *argp = (void __user *)data;
+	drm_sis_mem_t __user *argp = (drm_sis_mem_t __user *)data;
 	drm_sis_mem_t agp;
 	PMemBlock block;
 	int retval = 0;
-   
+
 	if (dev_priv == NULL || dev_priv->AGPHeap == NULL)
 		return DRM_ERR(EINVAL);
-  
+
 	DRM_COPY_FROM_USER_IOCTL(agp, argp, sizeof(agp));
-  
+
 	block = mmAllocMem(dev_priv->AGPHeap, agp.size, 0, 0);
 	if (block) {
 		/* TODO */
@@ -286,10 +288,10 @@ static int sis_ioctl_agp_alloc( DRM_IOCT
 		agp.free = (unsigned long)block;
 		if (!add_alloc_set(agp.context, AGP_TYPE, agp.free)) {
 			DRM_DEBUG("adding to allocation set fails\n");
-			mmFreeMem((PMemBlock)agp.free);
+			mmFreeMem((PMemBlock) agp.free);
 			retval = -1;
 		}
-	} else {  
+	} else {
 		agp.offset = 0;
 		agp.size = 0;
 		agp.free = 0;
@@ -302,7 +304,7 @@ static int sis_ioctl_agp_alloc( DRM_IOCT
 	return retval;
 }
 
-static int sis_ioctl_agp_free( DRM_IOCTL_ARGS )
+static int sis_ioctl_agp_free(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
 	drm_sis_private_t *dev_priv = dev->dev_private;
@@ -311,12 +313,13 @@ static int sis_ioctl_agp_free( DRM_IOCTL
 	if (dev_priv == NULL || dev_priv->AGPHeap == NULL)
 		return DRM_ERR(EINVAL);
 
-	DRM_COPY_FROM_USER_IOCTL(agp, (drm_sis_mem_t __user *)data, sizeof(agp));
+	DRM_COPY_FROM_USER_IOCTL(agp, (drm_sis_mem_t __user *) data,
+				 sizeof(agp));
 
-	if (!mmBlockInHeap(dev_priv->AGPHeap, (PMemBlock)agp.free))
+	if (!mmBlockInHeap(dev_priv->AGPHeap, (PMemBlock) agp.free))
 		return DRM_ERR(EINVAL);
 
-	mmFreeMem((PMemBlock)agp.free);
+	mmFreeMem((PMemBlock) agp.free);
 	if (!del_alloc_set(agp.context, AGP_TYPE, agp.free))
 		return DRM_ERR(EINVAL);
 
@@ -329,31 +332,30 @@ int sis_init_context(struct drm_device *
 {
 	int i;
 
-	for (i = 0; i < MAX_CONTEXT ; i++) {
+	for (i = 0; i < MAX_CONTEXT; i++) {
 		if (global_ppriv[i].used &&
 		    (global_ppriv[i].context == context))
 			break;
 	}
 
 	if (i >= MAX_CONTEXT) {
-		for (i = 0; i < MAX_CONTEXT ; i++) {
+		for (i = 0; i < MAX_CONTEXT; i++) {
 			if (!global_ppriv[i].used) {
 				global_ppriv[i].context = context;
 				global_ppriv[i].used = 1;
 				global_ppriv[i].sets[0] = setInit();
 				global_ppriv[i].sets[1] = setInit();
 				DRM_DEBUG("init allocation set, socket=%d, "
-				    "context = %d\n", i, context);
+					  "context = %d\n", i, context);
 				break;
 			}
 		}
 		if ((i >= MAX_CONTEXT) || (global_ppriv[i].sets[0] == NULL) ||
-		    (global_ppriv[i].sets[1] == NULL))
-		{
+		    (global_ppriv[i].sets[1] == NULL)) {
 			return 0;
 		}
 	}
-	
+
 	return 1;
 }
 
@@ -361,7 +363,7 @@ int sis_final_context(struct drm_device 
 {
 	int i;
 
-	for (i=0; i<MAX_CONTEXT; i++) {
+	for (i = 0; i < MAX_CONTEXT; i++) {
 		if (global_ppriv[i].used &&
 		    (global_ppriv[i].context == context))
 			break;
@@ -369,7 +371,7 @@ int sis_final_context(struct drm_device 
 
 	if (i < MAX_CONTEXT) {
 		set_t *set;
-		unsigned int item;
+		ITEM_TYPE item;
 		int retval;
 
 		DRM_DEBUG("find socket %d, context = %d\n", i, context);
@@ -378,11 +380,11 @@ int sis_final_context(struct drm_device 
 		set = global_ppriv[i].sets[0];
 		retval = setFirst(set, &item);
 		while (retval) {
-			DRM_DEBUG("free video memory 0x%x\n", item);
+			DRM_DEBUG("free video memory 0x%lx\n", item);
 #if defined(__linux__) && defined(CONFIG_FB_SIS)
 			sis_free(item);
 #else
-			mmFreeMem((PMemBlock)item);
+			mmFreeMem((PMemBlock) item);
 #endif
 			retval = setNext(set, &item);
 		}
@@ -392,26 +394,25 @@ int sis_final_context(struct drm_device 
 		set = global_ppriv[i].sets[1];
 		retval = setFirst(set, &item);
 		while (retval) {
-			DRM_DEBUG("free agp memory 0x%x\n", item);
-			mmFreeMem((PMemBlock)item);
+			DRM_DEBUG("free agp memory 0x%lx\n", item);
+			mmFreeMem((PMemBlock) item);
 			retval = setNext(set, &item);
 		}
 		setDestroy(set);
 
-		global_ppriv[i].used = 0;	  
-        }
-	
+		global_ppriv[i].used = 0;
+	}
+
 	return 1;
 }
 
 drm_ioctl_desc_t sis_ioctls[] = {
-	[DRM_IOCTL_NR(DRM_SIS_FB_ALLOC)]  = { sis_fb_alloc,        1, 0 },
-	[DRM_IOCTL_NR(DRM_SIS_FB_FREE)]   = { sis_fb_free,         1, 0 },
-	[DRM_IOCTL_NR(DRM_SIS_AGP_INIT)]  = { sis_ioctl_agp_init,  1, 1 },
-	[DRM_IOCTL_NR(DRM_SIS_AGP_ALLOC)] = { sis_ioctl_agp_alloc, 1, 0 },
-	[DRM_IOCTL_NR(DRM_SIS_AGP_FREE)]  = { sis_ioctl_agp_free,  1, 0 },
-	[DRM_IOCTL_NR(DRM_SIS_FB_INIT)]   = { sis_fb_init,         1, 1 }
+	[DRM_IOCTL_NR(DRM_SIS_FB_ALLOC)] = {sis_fb_alloc, 1, 0},
+	[DRM_IOCTL_NR(DRM_SIS_FB_FREE)] = {sis_fb_free, 1, 0},
+	[DRM_IOCTL_NR(DRM_SIS_AGP_INIT)] = {sis_ioctl_agp_init, 1, 1},
+	[DRM_IOCTL_NR(DRM_SIS_AGP_ALLOC)] = {sis_ioctl_agp_alloc, 1, 0},
+	[DRM_IOCTL_NR(DRM_SIS_AGP_FREE)] = {sis_ioctl_agp_free, 1, 0},
+	[DRM_IOCTL_NR(DRM_SIS_FB_INIT)] = {sis_fb_init, 1, 1}
 };
 
 int sis_max_ioctl = DRM_ARRAY_SIZE(sis_ioctls);
-
diff -purN linux-2.6.12.orig/drivers/char/drm/tdfx_drv.c linux-2.6.12/drivers/char/drm/tdfx_drv.c
--- linux-2.6.12.orig/drivers/char/drm/tdfx_drv.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/tdfx_drv.c	2005-07-05 08:37:27.000000000 +0200
@@ -36,30 +36,28 @@
 
 #include "drm_pciids.h"
 
-static int postinit( struct drm_device *dev, unsigned long flags )
+static int postinit(struct drm_device *dev, unsigned long flags)
 {
-	DRM_INFO( "Initialized %s %d.%d.%d %s on minor %d: %s\n",
-		DRIVER_NAME,
-		DRIVER_MAJOR,
-		DRIVER_MINOR,
-		DRIVER_PATCHLEVEL,
-		DRIVER_DATE,
-		dev->primary.minor,
-		pci_pretty_name(dev->pdev)
-		);
+	DRM_INFO("Initialized %s %d.%d.%d %s on minor %d: %s\n",
+		 DRIVER_NAME,
+		 DRIVER_MAJOR,
+		 DRIVER_MINOR,
+		 DRIVER_PATCHLEVEL,
+		 DRIVER_DATE, dev->primary.minor, pci_pretty_name(dev->pdev)
+	    );
 	return 0;
 }
 
-static int version( drm_version_t *version )
+static int version(drm_version_t * version)
 {
 	int len;
 
 	version->version_major = DRIVER_MAJOR;
 	version->version_minor = DRIVER_MINOR;
 	version->version_patchlevel = DRIVER_PATCHLEVEL;
-	DRM_COPY( version->name, DRIVER_NAME );
-	DRM_COPY( version->date, DRIVER_DATE );
-	DRM_COPY( version->desc, DRIVER_DESC );
+	DRM_COPY(version->name, DRIVER_NAME);
+	DRM_COPY(version->date, DRIVER_DATE);
+	DRM_COPY(version->desc, DRIVER_DESC);
 	return 0;
 }
 
@@ -67,6 +65,7 @@ static struct pci_device_id pciidlist[] 
 	tdfx_PCI_IDS
 };
 
+static int probe(struct pci_dev *pdev, const struct pci_device_id *ent);
 static struct drm_driver driver = {
 	.driver_features = DRIVER_USE_MTRR,
 	.reclaim_buffers = drm_core_reclaim_buffers,
@@ -82,16 +81,24 @@ static struct drm_driver driver = {
 		.mmap = drm_mmap,
 		.poll = drm_poll,
 		.fasync = drm_fasync,
-	},
+		},
 	.pci_driver = {
-		.name          = DRIVER_NAME,
-		.id_table      = pciidlist,
+		.name = DRIVER_NAME,
+		.id_table = pciidlist,
+		.probe = probe,
+		.remove = __devexit_p(drm_cleanup_pci),
 	}
 };
 
+static int probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	return drm_get_dev(pdev, ent, &driver);
+}
+
+
 static int __init tdfx_init(void)
 {
-	return drm_init(&driver);
+	return drm_init(&driver, pciidlist);
 }
 
 static void __exit tdfx_exit(void)
@@ -102,6 +109,6 @@ static void __exit tdfx_exit(void)
 module_init(tdfx_init);
 module_exit(tdfx_exit);
 
-MODULE_AUTHOR( DRIVER_AUTHOR );
-MODULE_DESCRIPTION( DRIVER_DESC );
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL and additional rights");
diff -purN linux-2.6.12.orig/drivers/char/drm/tdfx_drv.h linux-2.6.12/drivers/char/drm/tdfx_drv.h
--- linux-2.6.12.orig/drivers/char/drm/tdfx_drv.h	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/tdfx_drv.h	2005-07-05 08:37:49.000000000 +0200
@@ -30,10 +30,6 @@
 #ifndef __TDFX_H__
 #define __TDFX_H__
 
-/* This remains constant for all DRM template files.
- */
-#define DRM(x) tdfx_##x
-
 /* General customization:
  */
 
diff -purN linux-2.6.12.orig/drivers/char/drm/via_3d_reg.h linux-2.6.12/drivers/char/drm/via_3d_reg.h
--- linux-2.6.12.orig/drivers/char/drm/via_3d_reg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/drm/via_3d_reg.h	2005-07-05 08:37:49.000000000 +0200
@@ -0,0 +1,1651 @@
+/*
+ * Copyright 1998-2003 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2003 S3 Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * VIA, S3 GRAPHICS, AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef VIA_3D_REG_H
+#define VIA_3D_REG_H
+#define HC_REG_BASE             0x0400
+
+#define HC_REG_TRANS_SPACE      0x0040
+
+#define HC_ParaN_MASK           0xffffffff
+#define HC_Para_MASK            0x00ffffff
+#define HC_SubA_MASK            0xff000000
+#define HC_SubA_SHIFT           24
+/* Transmission Setting
+ */
+#define HC_REG_TRANS_SET        0x003c
+#define HC_ParaSubType_MASK     0xff000000
+#define HC_ParaType_MASK        0x00ff0000
+#define HC_ParaOS_MASK          0x0000ff00
+#define HC_ParaAdr_MASK         0x000000ff
+#define HC_ParaSubType_SHIFT    24
+#define HC_ParaType_SHIFT       16
+#define HC_ParaOS_SHIFT         8
+#define HC_ParaAdr_SHIFT        0
+
+#define HC_ParaType_CmdVdata    0x0000
+#define HC_ParaType_NotTex      0x0001
+#define HC_ParaType_Tex         0x0002
+#define HC_ParaType_Palette     0x0003
+#define HC_ParaType_PreCR       0x0010
+#define HC_ParaType_Auto        0x00fe
+
+/* Transmission Space
+ */
+#define HC_REG_Hpara0           0x0040
+#define HC_REG_HpataAF          0x02fc
+
+/* Read
+ */
+#define HC_REG_HREngSt          0x0000
+#define HC_REG_HRFIFOempty      0x0004
+#define HC_REG_HRFIFOfull       0x0008
+#define HC_REG_HRErr            0x000c
+#define HC_REG_FIFOstatus       0x0010
+/* HC_REG_HREngSt          0x0000
+ */
+#define HC_HDASZC_MASK          0x00010000
+#define HC_HSGEMI_MASK          0x0000f000
+#define HC_HLGEMISt_MASK        0x00000f00
+#define HC_HCRSt_MASK           0x00000080
+#define HC_HSE0St_MASK          0x00000040
+#define HC_HSE1St_MASK          0x00000020
+#define HC_HPESt_MASK           0x00000010
+#define HC_HXESt_MASK           0x00000008
+#define HC_HBESt_MASK           0x00000004
+#define HC_HE2St_MASK           0x00000002
+#define HC_HE3St_MASK           0x00000001
+/* HC_REG_HRFIFOempty      0x0004
+ */
+#define HC_HRZDempty_MASK       0x00000010
+#define HC_HRTXAempty_MASK      0x00000008
+#define HC_HRTXDempty_MASK      0x00000004
+#define HC_HWZDempty_MASK       0x00000002
+#define HC_HWCDempty_MASK       0x00000001
+/* HC_REG_HRFIFOfull       0x0008
+ */
+#define HC_HRZDfull_MASK        0x00000010
+#define HC_HRTXAfull_MASK       0x00000008
+#define HC_HRTXDfull_MASK       0x00000004
+#define HC_HWZDfull_MASK        0x00000002
+#define HC_HWCDfull_MASK        0x00000001
+/* HC_REG_HRErr            0x000c
+ */
+#define HC_HAGPCMErr_MASK       0x80000000
+#define HC_HAGPCMErrC_MASK      0x70000000
+/* HC_REG_FIFOstatus       0x0010
+ */
+#define HC_HRFIFOATall_MASK     0x80000000
+#define HC_HRFIFOATbusy_MASK    0x40000000
+#define HC_HRATFGMDo_MASK       0x00000100
+#define HC_HRATFGMDi_MASK       0x00000080
+#define HC_HRATFRZD_MASK        0x00000040
+#define HC_HRATFRTXA_MASK       0x00000020
+#define HC_HRATFRTXD_MASK       0x00000010
+#define HC_HRATFWZD_MASK        0x00000008
+#define HC_HRATFWCD_MASK        0x00000004
+#define HC_HRATTXTAG_MASK       0x00000002
+#define HC_HRATTXCH_MASK        0x00000001
+
+/* AGP Command Setting
+ */
+#define HC_SubA_HAGPBstL        0x0060
+#define HC_SubA_HAGPBendL       0x0061
+#define HC_SubA_HAGPCMNT        0x0062
+#define HC_SubA_HAGPBpL         0x0063
+#define HC_SubA_HAGPBpH         0x0064
+/* HC_SubA_HAGPCMNT        0x0062
+ */
+#define HC_HAGPCMNT_MASK        0x00800000
+#define HC_HCmdErrClr_MASK      0x00400000
+#define HC_HAGPBendH_MASK       0x0000ff00
+#define HC_HAGPBstH_MASK        0x000000ff
+#define HC_HAGPBendH_SHIFT      8
+#define HC_HAGPBstH_SHIFT       0
+/* HC_SubA_HAGPBpL         0x0063
+ */
+#define HC_HAGPBpL_MASK         0x00fffffc
+#define HC_HAGPBpID_MASK        0x00000003
+#define HC_HAGPBpID_PAUSE       0x00000000
+#define HC_HAGPBpID_JUMP        0x00000001
+#define HC_HAGPBpID_STOP        0x00000002
+/* HC_SubA_HAGPBpH         0x0064
+ */
+#define HC_HAGPBpH_MASK         0x00ffffff
+
+/* Miscellaneous Settings
+ */
+#define HC_SubA_HClipTB         0x0070
+#define HC_SubA_HClipLR         0x0071
+#define HC_SubA_HFPClipTL       0x0072
+#define HC_SubA_HFPClipBL       0x0073
+#define HC_SubA_HFPClipLL       0x0074
+#define HC_SubA_HFPClipRL       0x0075
+#define HC_SubA_HFPClipTBH      0x0076
+#define HC_SubA_HFPClipLRH      0x0077
+#define HC_SubA_HLP             0x0078
+#define HC_SubA_HLPRF           0x0079
+#define HC_SubA_HSolidCL        0x007a
+#define HC_SubA_HPixGC          0x007b
+#define HC_SubA_HSPXYOS         0x007c
+#define HC_SubA_HVertexCNT      0x007d
+
+#define HC_HClipT_MASK          0x00fff000
+#define HC_HClipT_SHIFT         12
+#define HC_HClipB_MASK          0x00000fff
+#define HC_HClipB_SHIFT         0
+#define HC_HClipL_MASK          0x00fff000
+#define HC_HClipL_SHIFT         12
+#define HC_HClipR_MASK          0x00000fff
+#define HC_HClipR_SHIFT         0
+#define HC_HFPClipBH_MASK       0x0000ff00
+#define HC_HFPClipBH_SHIFT      8
+#define HC_HFPClipTH_MASK       0x000000ff
+#define HC_HFPClipTH_SHIFT      0
+#define HC_HFPClipRH_MASK       0x0000ff00
+#define HC_HFPClipRH_SHIFT      8
+#define HC_HFPClipLH_MASK       0x000000ff
+#define HC_HFPClipLH_SHIFT      0
+#define HC_HSolidCH_MASK        0x000000ff
+#define HC_HPixGC_MASK          0x00800000
+#define HC_HSPXOS_MASK          0x00fff000
+#define HC_HSPXOS_SHIFT         12
+#define HC_HSPYOS_MASK          0x00000fff
+
+/* Command
+ * Command A
+ */
+#define HC_HCmdHeader_MASK      0xfe000000	/*0xffe00000 */
+#define HC_HE3Fire_MASK         0x00100000
+#define HC_HPMType_MASK         0x000f0000
+#define HC_HEFlag_MASK          0x0000e000
+#define HC_HShading_MASK        0x00001c00
+#define HC_HPMValidN_MASK       0x00000200
+#define HC_HPLEND_MASK          0x00000100
+#define HC_HVCycle_MASK         0x000000ff
+#define HC_HVCycle_Style_MASK   0x000000c0
+#define HC_HVCycle_ChgA_MASK    0x00000030
+#define HC_HVCycle_ChgB_MASK    0x0000000c
+#define HC_HVCycle_ChgC_MASK    0x00000003
+#define HC_HPMType_Point        0x00000000
+#define HC_HPMType_Line         0x00010000
+#define HC_HPMType_Tri          0x00020000
+#define HC_HPMType_TriWF        0x00040000
+#define HC_HEFlag_NoAA          0x00000000
+#define HC_HEFlag_ab            0x00008000
+#define HC_HEFlag_bc            0x00004000
+#define HC_HEFlag_ca            0x00002000
+#define HC_HShading_Solid       0x00000000
+#define HC_HShading_FlatA       0x00000400
+#define HC_HShading_FlatB       0x00000800
+#define HC_HShading_FlatC       0x00000c00
+#define HC_HShading_Gouraud     0x00001000
+#define HC_HVCycle_Full         0x00000000
+#define HC_HVCycle_AFP          0x00000040
+#define HC_HVCycle_One          0x000000c0
+#define HC_HVCycle_NewA         0x00000000
+#define HC_HVCycle_AA           0x00000010
+#define HC_HVCycle_AB           0x00000020
+#define HC_HVCycle_AC           0x00000030
+#define HC_HVCycle_NewB         0x00000000
+#define HC_HVCycle_BA           0x00000004
+#define HC_HVCycle_BB           0x00000008
+#define HC_HVCycle_BC           0x0000000c
+#define HC_HVCycle_NewC         0x00000000
+#define HC_HVCycle_CA           0x00000001
+#define HC_HVCycle_CB           0x00000002
+#define HC_HVCycle_CC           0x00000003
+
+/* Command B
+ */
+#define HC_HLPrst_MASK          0x00010000
+#define HC_HLLastP_MASK         0x00008000
+#define HC_HVPMSK_MASK          0x00007f80
+#define HC_HBFace_MASK          0x00000040
+#define HC_H2nd1VT_MASK         0x0000003f
+#define HC_HVPMSK_X             0x00004000
+#define HC_HVPMSK_Y             0x00002000
+#define HC_HVPMSK_Z             0x00001000
+#define HC_HVPMSK_W             0x00000800
+#define HC_HVPMSK_Cd            0x00000400
+#define HC_HVPMSK_Cs            0x00000200
+#define HC_HVPMSK_S             0x00000100
+#define HC_HVPMSK_T             0x00000080
+
+/* Enable Setting
+ */
+#define HC_SubA_HEnable         0x0000
+#define HC_HenTXEnvMap_MASK     0x00200000
+#define HC_HenVertexCNT_MASK    0x00100000
+#define HC_HenCPUDAZ_MASK       0x00080000
+#define HC_HenDASZWC_MASK       0x00040000
+#define HC_HenFBCull_MASK       0x00020000
+#define HC_HenCW_MASK           0x00010000
+#define HC_HenAA_MASK           0x00008000
+#define HC_HenST_MASK           0x00004000
+#define HC_HenZT_MASK           0x00002000
+#define HC_HenZW_MASK           0x00001000
+#define HC_HenAT_MASK           0x00000800
+#define HC_HenAW_MASK           0x00000400
+#define HC_HenSP_MASK           0x00000200
+#define HC_HenLP_MASK           0x00000100
+#define HC_HenTXCH_MASK         0x00000080
+#define HC_HenTXMP_MASK         0x00000040
+#define HC_HenTXPP_MASK         0x00000020
+#define HC_HenTXTR_MASK         0x00000010
+#define HC_HenCS_MASK           0x00000008
+#define HC_HenFOG_MASK          0x00000004
+#define HC_HenABL_MASK          0x00000002
+#define HC_HenDT_MASK           0x00000001
+
+/* Z Setting
+ */
+#define HC_SubA_HZWBBasL        0x0010
+#define HC_SubA_HZWBBasH        0x0011
+#define HC_SubA_HZWBType        0x0012
+#define HC_SubA_HZBiasL         0x0013
+#define HC_SubA_HZWBend         0x0014
+#define HC_SubA_HZWTMD          0x0015
+#define HC_SubA_HZWCDL          0x0016
+#define HC_SubA_HZWCTAGnum      0x0017
+#define HC_SubA_HZCYNum         0x0018
+#define HC_SubA_HZWCFire        0x0019
+/* HC_SubA_HZWBType
+ */
+#define HC_HZWBType_MASK        0x00800000
+#define HC_HZBiasedWB_MASK      0x00400000
+#define HC_HZONEasFF_MASK       0x00200000
+#define HC_HZOONEasFF_MASK      0x00100000
+#define HC_HZWBFM_MASK          0x00030000
+#define HC_HZWBLoc_MASK         0x0000c000
+#define HC_HZWBPit_MASK         0x00003fff
+#define HC_HZWBFM_16            0x00000000
+#define HC_HZWBFM_32            0x00020000
+#define HC_HZWBFM_24            0x00030000
+#define HC_HZWBLoc_Local        0x00000000
+#define HC_HZWBLoc_SyS          0x00004000
+/* HC_SubA_HZWBend
+ */
+#define HC_HZWBend_MASK         0x00ffe000
+#define HC_HZBiasH_MASK         0x000000ff
+#define HC_HZWBend_SHIFT        10
+/* HC_SubA_HZWTMD
+ */
+#define HC_HZWTMD_MASK          0x00070000
+#define HC_HEBEBias_MASK        0x00007f00
+#define HC_HZNF_MASK            0x000000ff
+#define HC_HZWTMD_NeverPass     0x00000000
+#define HC_HZWTMD_LT            0x00010000
+#define HC_HZWTMD_EQ            0x00020000
+#define HC_HZWTMD_LE            0x00030000
+#define HC_HZWTMD_GT            0x00040000
+#define HC_HZWTMD_NE            0x00050000
+#define HC_HZWTMD_GE            0x00060000
+#define HC_HZWTMD_AllPass       0x00070000
+#define HC_HEBEBias_SHIFT       8
+/* HC_SubA_HZWCDL          0x0016
+ */
+#define HC_HZWCDL_MASK          0x00ffffff
+/* HC_SubA_HZWCTAGnum      0x0017
+ */
+#define HC_HZWCTAGnum_MASK      0x00ff0000
+#define HC_HZWCTAGnum_SHIFT     16
+#define HC_HZWCDH_MASK          0x000000ff
+#define HC_HZWCDH_SHIFT         0
+/* HC_SubA_HZCYNum         0x0018
+ */
+#define HC_HZCYNum_MASK         0x00030000
+#define HC_HZCYNum_SHIFT        16
+#define HC_HZWCQWnum_MASK       0x00003fff
+#define HC_HZWCQWnum_SHIFT      0
+/* HC_SubA_HZWCFire        0x0019
+ */
+#define HC_ZWCFire_MASK         0x00010000
+#define HC_HZWCQWnumLast_MASK   0x00003fff
+#define HC_HZWCQWnumLast_SHIFT  0
+
+/* Stencil Setting
+ */
+#define HC_SubA_HSTREF          0x0023
+#define HC_SubA_HSTMD           0x0024
+/* HC_SubA_HSBFM
+ */
+#define HC_HSBFM_MASK           0x00030000
+#define HC_HSBLoc_MASK          0x0000c000
+#define HC_HSBPit_MASK          0x00003fff
+/* HC_SubA_HSTREF
+ */
+#define HC_HSTREF_MASK          0x00ff0000
+#define HC_HSTOPMSK_MASK        0x0000ff00
+#define HC_HSTBMSK_MASK         0x000000ff
+#define HC_HSTREF_SHIFT         16
+#define HC_HSTOPMSK_SHIFT       8
+/* HC_SubA_HSTMD
+ */
+#define HC_HSTMD_MASK           0x00070000
+#define HC_HSTOPSF_MASK         0x000001c0
+#define HC_HSTOPSPZF_MASK       0x00000038
+#define HC_HSTOPSPZP_MASK       0x00000007
+#define HC_HSTMD_NeverPass      0x00000000
+#define HC_HSTMD_LT             0x00010000
+#define HC_HSTMD_EQ             0x00020000
+#define HC_HSTMD_LE             0x00030000
+#define HC_HSTMD_GT             0x00040000
+#define HC_HSTMD_NE             0x00050000
+#define HC_HSTMD_GE             0x00060000
+#define HC_HSTMD_AllPass        0x00070000
+#define HC_HSTOPSF_KEEP         0x00000000
+#define HC_HSTOPSF_ZERO         0x00000040
+#define HC_HSTOPSF_REPLACE      0x00000080
+#define HC_HSTOPSF_INCRSAT      0x000000c0
+#define HC_HSTOPSF_DECRSAT      0x00000100
+#define HC_HSTOPSF_INVERT       0x00000140
+#define HC_HSTOPSF_INCR         0x00000180
+#define HC_HSTOPSF_DECR         0x000001c0
+#define HC_HSTOPSPZF_KEEP       0x00000000
+#define HC_HSTOPSPZF_ZERO       0x00000008
+#define HC_HSTOPSPZF_REPLACE    0x00000010
+#define HC_HSTOPSPZF_INCRSAT    0x00000018
+#define HC_HSTOPSPZF_DECRSAT    0x00000020
+#define HC_HSTOPSPZF_INVERT     0x00000028
+#define HC_HSTOPSPZF_INCR       0x00000030
+#define HC_HSTOPSPZF_DECR       0x00000038
+#define HC_HSTOPSPZP_KEEP       0x00000000
+#define HC_HSTOPSPZP_ZERO       0x00000001
+#define HC_HSTOPSPZP_REPLACE    0x00000002
+#define HC_HSTOPSPZP_INCRSAT    0x00000003
+#define HC_HSTOPSPZP_DECRSAT    0x00000004
+#define HC_HSTOPSPZP_INVERT     0x00000005
+#define HC_HSTOPSPZP_INCR       0x00000006
+#define HC_HSTOPSPZP_DECR       0x00000007
+
+/* Alpha Setting
+ */
+#define HC_SubA_HABBasL         0x0030
+#define HC_SubA_HABBasH         0x0031
+#define HC_SubA_HABFM           0x0032
+#define HC_SubA_HATMD           0x0033
+#define HC_SubA_HABLCsat        0x0034
+#define HC_SubA_HABLCop         0x0035
+#define HC_SubA_HABLAsat        0x0036
+#define HC_SubA_HABLAop         0x0037
+#define HC_SubA_HABLRCa         0x0038
+#define HC_SubA_HABLRFCa        0x0039
+#define HC_SubA_HABLRCbias      0x003a
+#define HC_SubA_HABLRCb         0x003b
+#define HC_SubA_HABLRFCb        0x003c
+#define HC_SubA_HABLRAa         0x003d
+#define HC_SubA_HABLRAb         0x003e
+/* HC_SubA_HABFM
+ */
+#define HC_HABFM_MASK           0x00030000
+#define HC_HABLoc_MASK          0x0000c000
+#define HC_HABPit_MASK          0x000007ff
+/* HC_SubA_HATMD
+ */
+#define HC_HATMD_MASK           0x00000700
+#define HC_HATREF_MASK          0x000000ff
+#define HC_HATMD_NeverPass      0x00000000
+#define HC_HATMD_LT             0x00000100
+#define HC_HATMD_EQ             0x00000200
+#define HC_HATMD_LE             0x00000300
+#define HC_HATMD_GT             0x00000400
+#define HC_HATMD_NE             0x00000500
+#define HC_HATMD_GE             0x00000600
+#define HC_HATMD_AllPass        0x00000700
+/* HC_SubA_HABLCsat
+ */
+#define HC_HABLCsat_MASK        0x00010000
+#define HC_HABLCa_MASK          0x0000fc00
+#define HC_HABLCa_C_MASK        0x0000c000
+#define HC_HABLCa_OPC_MASK      0x00003c00
+#define HC_HABLFCa_MASK         0x000003f0
+#define HC_HABLFCa_C_MASK       0x00000300
+#define HC_HABLFCa_OPC_MASK     0x000000f0
+#define HC_HABLCbias_MASK       0x0000000f
+#define HC_HABLCbias_C_MASK     0x00000008
+#define HC_HABLCbias_OPC_MASK   0x00000007
+/*-- Define the input color.
+ */
+#define HC_XC_Csrc              0x00000000
+#define HC_XC_Cdst              0x00000001
+#define HC_XC_Asrc              0x00000002
+#define HC_XC_Adst              0x00000003
+#define HC_XC_Fog               0x00000004
+#define HC_XC_HABLRC            0x00000005
+#define HC_XC_minSrcDst         0x00000006
+#define HC_XC_maxSrcDst         0x00000007
+#define HC_XC_mimAsrcInvAdst    0x00000008
+#define HC_XC_OPC               0x00000000
+#define HC_XC_InvOPC            0x00000010
+#define HC_XC_OPCp5             0x00000020
+/*-- Define the input Alpha
+ */
+#define HC_XA_OPA               0x00000000
+#define HC_XA_InvOPA            0x00000010
+#define HC_XA_OPAp5             0x00000020
+#define HC_XA_0                 0x00000000
+#define HC_XA_Asrc              0x00000001
+#define HC_XA_Adst              0x00000002
+#define HC_XA_Fog               0x00000003
+#define HC_XA_minAsrcFog        0x00000004
+#define HC_XA_minAsrcAdst       0x00000005
+#define HC_XA_maxAsrcFog        0x00000006
+#define HC_XA_maxAsrcAdst       0x00000007
+#define HC_XA_HABLRA            0x00000008
+#define HC_XA_minAsrcInvAdst    0x00000008
+#define HC_XA_HABLFRA           0x00000009
+/*--
+ */
+#define HC_HABLCa_OPC           (HC_XC_OPC << 10)
+#define HC_HABLCa_InvOPC        (HC_XC_InvOPC << 10)
+#define HC_HABLCa_OPCp5         (HC_XC_OPCp5 << 10)
+#define HC_HABLCa_Csrc          (HC_XC_Csrc << 10)
+#define HC_HABLCa_Cdst          (HC_XC_Cdst << 10)
+#define HC_HABLCa_Asrc          (HC_XC_Asrc << 10)
+#define HC_HABLCa_Adst          (HC_XC_Adst << 10)
+#define HC_HABLCa_Fog           (HC_XC_Fog << 10)
+#define HC_HABLCa_HABLRCa       (HC_XC_HABLRC << 10)
+#define HC_HABLCa_minSrcDst     (HC_XC_minSrcDst << 10)
+#define HC_HABLCa_maxSrcDst     (HC_XC_maxSrcDst << 10)
+#define HC_HABLFCa_OPC              (HC_XC_OPC << 4)
+#define HC_HABLFCa_InvOPC           (HC_XC_InvOPC << 4)
+#define HC_HABLFCa_OPCp5            (HC_XC_OPCp5 << 4)
+#define HC_HABLFCa_Csrc             (HC_XC_Csrc << 4)
+#define HC_HABLFCa_Cdst             (HC_XC_Cdst << 4)
+#define HC_HABLFCa_Asrc             (HC_XC_Asrc << 4)
+#define HC_HABLFCa_Adst             (HC_XC_Adst << 4)
+#define HC_HABLFCa_Fog              (HC_XC_Fog << 4)
+#define HC_HABLFCa_HABLRCa          (HC_XC_HABLRC << 4)
+#define HC_HABLFCa_minSrcDst        (HC_XC_minSrcDst << 4)
+#define HC_HABLFCa_maxSrcDst        (HC_XC_maxSrcDst << 4)
+#define HC_HABLFCa_mimAsrcInvAdst   (HC_XC_mimAsrcInvAdst << 4)
+#define HC_HABLCbias_HABLRCbias 0x00000000
+#define HC_HABLCbias_Asrc       0x00000001
+#define HC_HABLCbias_Adst       0x00000002
+#define HC_HABLCbias_Fog        0x00000003
+#define HC_HABLCbias_Cin        0x00000004
+/* HC_SubA_HABLCop         0x0035
+ */
+#define HC_HABLdot_MASK         0x00010000
+#define HC_HABLCop_MASK         0x00004000
+#define HC_HABLCb_MASK          0x00003f00
+#define HC_HABLCb_C_MASK        0x00003000
+#define HC_HABLCb_OPC_MASK      0x00000f00
+#define HC_HABLFCb_MASK         0x000000fc
+#define HC_HABLFCb_C_MASK       0x000000c0
+#define HC_HABLFCb_OPC_MASK     0x0000003c
+#define HC_HABLCshift_MASK      0x00000003
+#define HC_HABLCb_OPC           (HC_XC_OPC << 8)
+#define HC_HABLCb_InvOPC        (HC_XC_InvOPC << 8)
+#define HC_HABLCb_OPCp5         (HC_XC_OPCp5 << 8)
+#define HC_HABLCb_Csrc          (HC_XC_Csrc << 8)
+#define HC_HABLCb_Cdst          (HC_XC_Cdst << 8)
+#define HC_HABLCb_Asrc          (HC_XC_Asrc << 8)
+#define HC_HABLCb_Adst          (HC_XC_Adst << 8)
+#define HC_HABLCb_Fog           (HC_XC_Fog << 8)
+#define HC_HABLCb_HABLRCa       (HC_XC_HABLRC << 8)
+#define HC_HABLCb_minSrcDst     (HC_XC_minSrcDst << 8)
+#define HC_HABLCb_maxSrcDst     (HC_XC_maxSrcDst << 8)
+#define HC_HABLFCb_OPC              (HC_XC_OPC << 2)
+#define HC_HABLFCb_InvOPC           (HC_XC_InvOPC << 2)
+#define HC_HABLFCb_OPCp5            (HC_XC_OPCp5 << 2)
+#define HC_HABLFCb_Csrc             (HC_XC_Csrc << 2)
+#define HC_HABLFCb_Cdst             (HC_XC_Cdst << 2)
+#define HC_HABLFCb_Asrc             (HC_XC_Asrc << 2)
+#define HC_HABLFCb_Adst             (HC_XC_Adst << 2)
+#define HC_HABLFCb_Fog              (HC_XC_Fog << 2)
+#define HC_HABLFCb_HABLRCb          (HC_XC_HABLRC << 2)
+#define HC_HABLFCb_minSrcDst        (HC_XC_minSrcDst << 2)
+#define HC_HABLFCb_maxSrcDst        (HC_XC_maxSrcDst << 2)
+#define HC_HABLFCb_mimAsrcInvAdst   (HC_XC_mimAsrcInvAdst << 2)
+/* HC_SubA_HABLAsat        0x0036
+ */
+#define HC_HABLAsat_MASK        0x00010000
+#define HC_HABLAa_MASK          0x0000fc00
+#define HC_HABLAa_A_MASK        0x0000c000
+#define HC_HABLAa_OPA_MASK      0x00003c00
+#define HC_HABLFAa_MASK         0x000003f0
+#define HC_HABLFAa_A_MASK       0x00000300
+#define HC_HABLFAa_OPA_MASK     0x000000f0
+#define HC_HABLAbias_MASK       0x0000000f
+#define HC_HABLAbias_A_MASK     0x00000008
+#define HC_HABLAbias_OPA_MASK   0x00000007
+#define HC_HABLAa_OPA           (HC_XA_OPA << 10)
+#define HC_HABLAa_InvOPA        (HC_XA_InvOPA << 10)
+#define HC_HABLAa_OPAp5         (HC_XA_OPAp5 << 10)
+#define HC_HABLAa_0             (HC_XA_0 << 10)
+#define HC_HABLAa_Asrc          (HC_XA_Asrc << 10)
+#define HC_HABLAa_Adst          (HC_XA_Adst << 10)
+#define HC_HABLAa_Fog           (HC_XA_Fog << 10)
+#define HC_HABLAa_minAsrcFog    (HC_XA_minAsrcFog << 10)
+#define HC_HABLAa_minAsrcAdst   (HC_XA_minAsrcAdst << 10)
+#define HC_HABLAa_maxAsrcFog    (HC_XA_maxAsrcFog << 10)
+#define HC_HABLAa_maxAsrcAdst   (HC_XA_maxAsrcAdst << 10)
+#define HC_HABLAa_HABLRA        (HC_XA_HABLRA << 10)
+#define HC_HABLFAa_OPA          (HC_XA_OPA << 4)
+#define HC_HABLFAa_InvOPA       (HC_XA_InvOPA << 4)
+#define HC_HABLFAa_OPAp5        (HC_XA_OPAp5 << 4)
+#define HC_HABLFAa_0            (HC_XA_0 << 4)
+#define HC_HABLFAa_Asrc         (HC_XA_Asrc << 4)
+#define HC_HABLFAa_Adst         (HC_XA_Adst << 4)
+#define HC_HABLFAa_Fog          (HC_XA_Fog << 4)
+#define HC_HABLFAa_minAsrcFog   (HC_XA_minAsrcFog << 4)
+#define HC_HABLFAa_minAsrcAdst  (HC_XA_minAsrcAdst << 4)
+#define HC_HABLFAa_maxAsrcFog   (HC_XA_maxAsrcFog << 4)
+#define HC_HABLFAa_maxAsrcAdst  (HC_XA_maxAsrcAdst << 4)
+#define HC_HABLFAa_minAsrcInvAdst   (HC_XA_minAsrcInvAdst << 4)
+#define HC_HABLFAa_HABLFRA          (HC_XA_HABLFRA << 4)
+#define HC_HABLAbias_HABLRAbias 0x00000000
+#define HC_HABLAbias_Asrc       0x00000001
+#define HC_HABLAbias_Adst       0x00000002
+#define HC_HABLAbias_Fog        0x00000003
+#define HC_HABLAbias_Aaa        0x00000004
+/* HC_SubA_HABLAop         0x0037
+ */
+#define HC_HABLAop_MASK         0x00004000
+#define HC_HABLAb_MASK          0x00003f00
+#define HC_HABLAb_OPA_MASK      0x00000f00
+#define HC_HABLFAb_MASK         0x000000fc
+#define HC_HABLFAb_OPA_MASK     0x0000003c
+#define HC_HABLAshift_MASK      0x00000003
+#define HC_HABLAb_OPA           (HC_XA_OPA << 8)
+#define HC_HABLAb_InvOPA        (HC_XA_InvOPA << 8)
+#define HC_HABLAb_OPAp5         (HC_XA_OPAp5 << 8)
+#define HC_HABLAb_0             (HC_XA_0 << 8)
+#define HC_HABLAb_Asrc          (HC_XA_Asrc << 8)
+#define HC_HABLAb_Adst          (HC_XA_Adst << 8)
+#define HC_HABLAb_Fog           (HC_XA_Fog << 8)
+#define HC_HABLAb_minAsrcFog    (HC_XA_minAsrcFog << 8)
+#define HC_HABLAb_minAsrcAdst   (HC_XA_minAsrcAdst << 8)
+#define HC_HABLAb_maxAsrcFog    (HC_XA_maxAsrcFog << 8)
+#define HC_HABLAb_maxAsrcAdst   (HC_XA_maxAsrcAdst << 8)
+#define HC_HABLAb_HABLRA        (HC_XA_HABLRA << 8)
+#define HC_HABLFAb_OPA          (HC_XA_OPA << 2)
+#define HC_HABLFAb_InvOPA       (HC_XA_InvOPA << 2)
+#define HC_HABLFAb_OPAp5        (HC_XA_OPAp5 << 2)
+#define HC_HABLFAb_0            (HC_XA_0 << 2)
+#define HC_HABLFAb_Asrc         (HC_XA_Asrc << 2)
+#define HC_HABLFAb_Adst         (HC_XA_Adst << 2)
+#define HC_HABLFAb_Fog          (HC_XA_Fog << 2)
+#define HC_HABLFAb_minAsrcFog   (HC_XA_minAsrcFog << 2)
+#define HC_HABLFAb_minAsrcAdst  (HC_XA_minAsrcAdst << 2)
+#define HC_HABLFAb_maxAsrcFog   (HC_XA_maxAsrcFog << 2)
+#define HC_HABLFAb_maxAsrcAdst  (HC_XA_maxAsrcAdst << 2)
+#define HC_HABLFAb_minAsrcInvAdst   (HC_XA_minAsrcInvAdst << 2)
+#define HC_HABLFAb_HABLFRA          (HC_XA_HABLFRA << 2)
+/* HC_SubA_HABLRAa         0x003d
+ */
+#define HC_HABLRAa_MASK         0x00ff0000
+#define HC_HABLRFAa_MASK        0x0000ff00
+#define HC_HABLRAbias_MASK      0x000000ff
+#define HC_HABLRAa_SHIFT        16
+#define HC_HABLRFAa_SHIFT       8
+/* HC_SubA_HABLRAb         0x003e
+ */
+#define HC_HABLRAb_MASK         0x0000ff00
+#define HC_HABLRFAb_MASK        0x000000ff
+#define HC_HABLRAb_SHIFT        8
+
+/* Destination Setting
+ */
+#define HC_SubA_HDBBasL         0x0040
+#define HC_SubA_HDBBasH         0x0041
+#define HC_SubA_HDBFM           0x0042
+#define HC_SubA_HFBBMSKL        0x0043
+#define HC_SubA_HROP            0x0044
+/* HC_SubA_HDBFM           0x0042
+ */
+#define HC_HDBFM_MASK           0x001f0000
+#define HC_HDBLoc_MASK          0x0000c000
+#define HC_HDBPit_MASK          0x00003fff
+#define HC_HDBFM_RGB555         0x00000000
+#define HC_HDBFM_RGB565         0x00010000
+#define HC_HDBFM_ARGB4444       0x00020000
+#define HC_HDBFM_ARGB1555       0x00030000
+#define HC_HDBFM_BGR555         0x00040000
+#define HC_HDBFM_BGR565         0x00050000
+#define HC_HDBFM_ABGR4444       0x00060000
+#define HC_HDBFM_ABGR1555       0x00070000
+#define HC_HDBFM_ARGB0888       0x00080000
+#define HC_HDBFM_ARGB8888       0x00090000
+#define HC_HDBFM_ABGR0888       0x000a0000
+#define HC_HDBFM_ABGR8888       0x000b0000
+#define HC_HDBLoc_Local         0x00000000
+#define HC_HDBLoc_Sys           0x00004000
+/* HC_SubA_HROP            0x0044
+ */
+#define HC_HROP_MASK            0x00000f00
+#define HC_HFBBMSKH_MASK        0x000000ff
+#define HC_HROP_BLACK           0x00000000
+#define HC_HROP_DPon            0x00000100
+#define HC_HROP_DPna            0x00000200
+#define HC_HROP_Pn              0x00000300
+#define HC_HROP_PDna            0x00000400
+#define HC_HROP_Dn              0x00000500
+#define HC_HROP_DPx             0x00000600
+#define HC_HROP_DPan            0x00000700
+#define HC_HROP_DPa             0x00000800
+#define HC_HROP_DPxn            0x00000900
+#define HC_HROP_D               0x00000a00
+#define HC_HROP_DPno            0x00000b00
+#define HC_HROP_P               0x00000c00
+#define HC_HROP_PDno            0x00000d00
+#define HC_HROP_DPo             0x00000e00
+#define HC_HROP_WHITE           0x00000f00
+
+/* Fog Setting
+ */
+#define HC_SubA_HFogLF          0x0050
+#define HC_SubA_HFogCL          0x0051
+#define HC_SubA_HFogCH          0x0052
+#define HC_SubA_HFogStL         0x0053
+#define HC_SubA_HFogStH         0x0054
+#define HC_SubA_HFogOOdMF       0x0055
+#define HC_SubA_HFogOOdEF       0x0056
+#define HC_SubA_HFogEndL        0x0057
+#define HC_SubA_HFogDenst       0x0058
+/* HC_SubA_FogLF           0x0050
+ */
+#define HC_FogLF_MASK           0x00000010
+#define HC_FogEq_MASK           0x00000008
+#define HC_FogMD_MASK           0x00000007
+#define HC_FogMD_LocalFog        0x00000000
+#define HC_FogMD_LinearFog       0x00000002
+#define HC_FogMD_ExponentialFog  0x00000004
+#define HC_FogMD_Exponential2Fog 0x00000005
+/* #define HC_FogMD_FogTable       0x00000003 */
+
+/* HC_SubA_HFogDenst        0x0058
+ */
+#define HC_FogDenst_MASK        0x001fff00
+#define HC_FogEndL_MASK         0x000000ff
+
+/* Texture subtype definitions
+ */
+#define HC_SubType_Tex0         0x00000000
+#define HC_SubType_Tex1         0x00000001
+#define HC_SubType_TexGeneral   0x000000fe
+
+/* Attribute of texture n
+ */
+#define HC_SubA_HTXnL0BasL      0x0000
+#define HC_SubA_HTXnL1BasL      0x0001
+#define HC_SubA_HTXnL2BasL      0x0002
+#define HC_SubA_HTXnL3BasL      0x0003
+#define HC_SubA_HTXnL4BasL      0x0004
+#define HC_SubA_HTXnL5BasL      0x0005
+#define HC_SubA_HTXnL6BasL      0x0006
+#define HC_SubA_HTXnL7BasL      0x0007
+#define HC_SubA_HTXnL8BasL      0x0008
+#define HC_SubA_HTXnL9BasL      0x0009
+#define HC_SubA_HTXnLaBasL      0x000a
+#define HC_SubA_HTXnLbBasL      0x000b
+#define HC_SubA_HTXnLcBasL      0x000c
+#define HC_SubA_HTXnLdBasL      0x000d
+#define HC_SubA_HTXnLeBasL      0x000e
+#define HC_SubA_HTXnLfBasL      0x000f
+#define HC_SubA_HTXnL10BasL     0x0010
+#define HC_SubA_HTXnL11BasL     0x0011
+#define HC_SubA_HTXnL012BasH    0x0020
+#define HC_SubA_HTXnL345BasH    0x0021
+#define HC_SubA_HTXnL678BasH    0x0022
+#define HC_SubA_HTXnL9abBasH    0x0023
+#define HC_SubA_HTXnLcdeBasH    0x0024
+#define HC_SubA_HTXnLf1011BasH  0x0025
+#define HC_SubA_HTXnL0Pit       0x002b
+#define HC_SubA_HTXnL1Pit       0x002c
+#define HC_SubA_HTXnL2Pit       0x002d
+#define HC_SubA_HTXnL3Pit       0x002e
+#define HC_SubA_HTXnL4Pit       0x002f
+#define HC_SubA_HTXnL5Pit       0x0030
+#define HC_SubA_HTXnL6Pit       0x0031
+#define HC_SubA_HTXnL7Pit       0x0032
+#define HC_SubA_HTXnL8Pit       0x0033
+#define HC_SubA_HTXnL9Pit       0x0034
+#define HC_SubA_HTXnLaPit       0x0035
+#define HC_SubA_HTXnLbPit       0x0036
+#define HC_SubA_HTXnLcPit       0x0037
+#define HC_SubA_HTXnLdPit       0x0038
+#define HC_SubA_HTXnLePit       0x0039
+#define HC_SubA_HTXnLfPit       0x003a
+#define HC_SubA_HTXnL10Pit      0x003b
+#define HC_SubA_HTXnL11Pit      0x003c
+#define HC_SubA_HTXnL0_5WE      0x004b
+#define HC_SubA_HTXnL6_bWE      0x004c
+#define HC_SubA_HTXnLc_11WE     0x004d
+#define HC_SubA_HTXnL0_5HE      0x0051
+#define HC_SubA_HTXnL6_bHE      0x0052
+#define HC_SubA_HTXnLc_11HE     0x0053
+#define HC_SubA_HTXnL0OS        0x0077
+#define HC_SubA_HTXnTB          0x0078
+#define HC_SubA_HTXnMPMD        0x0079
+#define HC_SubA_HTXnCLODu       0x007a
+#define HC_SubA_HTXnFM          0x007b
+#define HC_SubA_HTXnTRCH        0x007c
+#define HC_SubA_HTXnTRCL        0x007d
+#define HC_SubA_HTXnTBC         0x007e
+#define HC_SubA_HTXnTRAH        0x007f
+#define HC_SubA_HTXnTBLCsat     0x0080
+#define HC_SubA_HTXnTBLCop      0x0081
+#define HC_SubA_HTXnTBLMPfog    0x0082
+#define HC_SubA_HTXnTBLAsat     0x0083
+#define HC_SubA_HTXnTBLRCa      0x0085
+#define HC_SubA_HTXnTBLRCb      0x0086
+#define HC_SubA_HTXnTBLRCc      0x0087
+#define HC_SubA_HTXnTBLRCbias   0x0088
+#define HC_SubA_HTXnTBLRAa      0x0089
+#define HC_SubA_HTXnTBLRFog     0x008a
+#define HC_SubA_HTXnBumpM00     0x0090
+#define HC_SubA_HTXnBumpM01     0x0091
+#define HC_SubA_HTXnBumpM10     0x0092
+#define HC_SubA_HTXnBumpM11     0x0093
+#define HC_SubA_HTXnLScale      0x0094
+#define HC_SubA_HTXSMD          0x0000
+/* HC_SubA_HTXnL012BasH    0x0020
+ */
+#define HC_HTXnL0BasH_MASK      0x000000ff
+#define HC_HTXnL1BasH_MASK      0x0000ff00
+#define HC_HTXnL2BasH_MASK      0x00ff0000
+#define HC_HTXnL1BasH_SHIFT     8
+#define HC_HTXnL2BasH_SHIFT     16
+/* HC_SubA_HTXnL345BasH    0x0021
+ */
+#define HC_HTXnL3BasH_MASK      0x000000ff
+#define HC_HTXnL4BasH_MASK      0x0000ff00
+#define HC_HTXnL5BasH_MASK      0x00ff0000
+#define HC_HTXnL4BasH_SHIFT     8
+#define HC_HTXnL5BasH_SHIFT     16
+/* HC_SubA_HTXnL678BasH    0x0022
+ */
+#define HC_HTXnL6BasH_MASK      0x000000ff
+#define HC_HTXnL7BasH_MASK      0x0000ff00
+#define HC_HTXnL8BasH_MASK      0x00ff0000
+#define HC_HTXnL7BasH_SHIFT     8
+#define HC_HTXnL8BasH_SHIFT     16
+/* HC_SubA_HTXnL9abBasH    0x0023
+ */
+#define HC_HTXnL9BasH_MASK      0x000000ff
+#define HC_HTXnLaBasH_MASK      0x0000ff00
+#define HC_HTXnLbBasH_MASK      0x00ff0000
+#define HC_HTXnLaBasH_SHIFT     8
+#define HC_HTXnLbBasH_SHIFT     16
+/* HC_SubA_HTXnLcdeBasH    0x0024
+ */
+#define HC_HTXnLcBasH_MASK      0x000000ff
+#define HC_HTXnLdBasH_MASK      0x0000ff00
+#define HC_HTXnLeBasH_MASK      0x00ff0000
+#define HC_HTXnLdBasH_SHIFT     8
+#define HC_HTXnLeBasH_SHIFT     16
+/* HC_SubA_HTXnLcdeBasH    0x0025
+ */
+#define HC_HTXnLfBasH_MASK      0x000000ff
+#define HC_HTXnL10BasH_MASK      0x0000ff00
+#define HC_HTXnL11BasH_MASK      0x00ff0000
+#define HC_HTXnL10BasH_SHIFT     8
+#define HC_HTXnL11BasH_SHIFT     16
+/* HC_SubA_HTXnL0Pit       0x002b
+ */
+#define HC_HTXnLnPit_MASK       0x00003fff
+#define HC_HTXnEnPit_MASK       0x00080000
+#define HC_HTXnLnPitE_MASK      0x00f00000
+#define HC_HTXnLnPitE_SHIFT     20
+/* HC_SubA_HTXnL0_5WE      0x004b
+ */
+#define HC_HTXnL0WE_MASK        0x0000000f
+#define HC_HTXnL1WE_MASK        0x000000f0
+#define HC_HTXnL2WE_MASK        0x00000f00
+#define HC_HTXnL3WE_MASK        0x0000f000
+#define HC_HTXnL4WE_MASK        0x000f0000
+#define HC_HTXnL5WE_MASK        0x00f00000
+#define HC_HTXnL1WE_SHIFT       4
+#define HC_HTXnL2WE_SHIFT       8
+#define HC_HTXnL3WE_SHIFT       12
+#define HC_HTXnL4WE_SHIFT       16
+#define HC_HTXnL5WE_SHIFT       20
+/* HC_SubA_HTXnL6_bWE      0x004c
+ */
+#define HC_HTXnL6WE_MASK        0x0000000f
+#define HC_HTXnL7WE_MASK        0x000000f0
+#define HC_HTXnL8WE_MASK        0x00000f00
+#define HC_HTXnL9WE_MASK        0x0000f000
+#define HC_HTXnLaWE_MASK        0x000f0000
+#define HC_HTXnLbWE_MASK        0x00f00000
+#define HC_HTXnL7WE_SHIFT       4
+#define HC_HTXnL8WE_SHIFT       8
+#define HC_HTXnL9WE_SHIFT       12
+#define HC_HTXnLaWE_SHIFT       16
+#define HC_HTXnLbWE_SHIFT       20
+/* HC_SubA_HTXnLc_11WE      0x004d
+ */
+#define HC_HTXnLcWE_MASK        0x0000000f
+#define HC_HTXnLdWE_MASK        0x000000f0
+#define HC_HTXnLeWE_MASK        0x00000f00
+#define HC_HTXnLfWE_MASK        0x0000f000
+#define HC_HTXnL10WE_MASK       0x000f0000
+#define HC_HTXnL11WE_MASK       0x00f00000
+#define HC_HTXnLdWE_SHIFT       4
+#define HC_HTXnLeWE_SHIFT       8
+#define HC_HTXnLfWE_SHIFT       12
+#define HC_HTXnL10WE_SHIFT      16
+#define HC_HTXnL11WE_SHIFT      20
+/* HC_SubA_HTXnL0_5HE      0x0051
+ */
+#define HC_HTXnL0HE_MASK        0x0000000f
+#define HC_HTXnL1HE_MASK        0x000000f0
+#define HC_HTXnL2HE_MASK        0x00000f00
+#define HC_HTXnL3HE_MASK        0x0000f000
+#define HC_HTXnL4HE_MASK        0x000f0000
+#define HC_HTXnL5HE_MASK        0x00f00000
+#define HC_HTXnL1HE_SHIFT       4
+#define HC_HTXnL2HE_SHIFT       8
+#define HC_HTXnL3HE_SHIFT       12
+#define HC_HTXnL4HE_SHIFT       16
+#define HC_HTXnL5HE_SHIFT       20
+/* HC_SubA_HTXnL6_bHE      0x0052
+ */
+#define HC_HTXnL6HE_MASK        0x0000000f
+#define HC_HTXnL7HE_MASK        0x000000f0
+#define HC_HTXnL8HE_MASK        0x00000f00
+#define HC_HTXnL9HE_MASK        0x0000f000
+#define HC_HTXnLaHE_MASK        0x000f0000
+#define HC_HTXnLbHE_MASK        0x00f00000
+#define HC_HTXnL7HE_SHIFT       4
+#define HC_HTXnL8HE_SHIFT       8
+#define HC_HTXnL9HE_SHIFT       12
+#define HC_HTXnLaHE_SHIFT       16
+#define HC_HTXnLbHE_SHIFT       20
+/* HC_SubA_HTXnLc_11HE      0x0053
+ */
+#define HC_HTXnLcHE_MASK        0x0000000f
+#define HC_HTXnLdHE_MASK        0x000000f0
+#define HC_HTXnLeHE_MASK        0x00000f00
+#define HC_HTXnLfHE_MASK        0x0000f000
+#define HC_HTXnL10HE_MASK       0x000f0000
+#define HC_HTXnL11HE_MASK       0x00f00000
+#define HC_HTXnLdHE_SHIFT       4
+#define HC_HTXnLeHE_SHIFT       8
+#define HC_HTXnLfHE_SHIFT       12
+#define HC_HTXnL10HE_SHIFT      16
+#define HC_HTXnL11HE_SHIFT      20
+/* HC_SubA_HTXnL0OS        0x0077
+ */
+#define HC_HTXnL0OS_MASK        0x003ff000
+#define HC_HTXnLVmax_MASK       0x00000fc0
+#define HC_HTXnLVmin_MASK       0x0000003f
+#define HC_HTXnL0OS_SHIFT       12
+#define HC_HTXnLVmax_SHIFT      6
+/* HC_SubA_HTXnTB          0x0078
+ */
+#define HC_HTXnTB_MASK          0x00f00000
+#define HC_HTXnFLSe_MASK        0x0000e000
+#define HC_HTXnFLSs_MASK        0x00001c00
+#define HC_HTXnFLTe_MASK        0x00000380
+#define HC_HTXnFLTs_MASK        0x00000070
+#define HC_HTXnFLDs_MASK        0x0000000f
+#define HC_HTXnTB_NoTB          0x00000000
+#define HC_HTXnTB_TBC_S         0x00100000
+#define HC_HTXnTB_TBC_T         0x00200000
+#define HC_HTXnTB_TB_S          0x00400000
+#define HC_HTXnTB_TB_T          0x00800000
+#define HC_HTXnFLSe_Nearest     0x00000000
+#define HC_HTXnFLSe_Linear      0x00002000
+#define HC_HTXnFLSe_NonLinear   0x00004000
+#define HC_HTXnFLSe_Sharp       0x00008000
+#define HC_HTXnFLSe_Flat_Gaussian_Cubic 0x0000c000
+#define HC_HTXnFLSs_Nearest     0x00000000
+#define HC_HTXnFLSs_Linear      0x00000400
+#define HC_HTXnFLSs_NonLinear   0x00000800
+#define HC_HTXnFLSs_Flat_Gaussian_Cubic 0x00001800
+#define HC_HTXnFLTe_Nearest     0x00000000
+#define HC_HTXnFLTe_Linear      0x00000080
+#define HC_HTXnFLTe_NonLinear   0x00000100
+#define HC_HTXnFLTe_Sharp       0x00000180
+#define HC_HTXnFLTe_Flat_Gaussian_Cubic 0x00000300
+#define HC_HTXnFLTs_Nearest     0x00000000
+#define HC_HTXnFLTs_Linear      0x00000010
+#define HC_HTXnFLTs_NonLinear   0x00000020
+#define HC_HTXnFLTs_Flat_Gaussian_Cubic 0x00000060
+#define HC_HTXnFLDs_Tex0        0x00000000
+#define HC_HTXnFLDs_Nearest     0x00000001
+#define HC_HTXnFLDs_Linear      0x00000002
+#define HC_HTXnFLDs_NonLinear   0x00000003
+#define HC_HTXnFLDs_Dither      0x00000004
+#define HC_HTXnFLDs_ConstLOD    0x00000005
+#define HC_HTXnFLDs_Ani         0x00000006
+#define HC_HTXnFLDs_AniDither   0x00000007
+/* HC_SubA_HTXnMPMD        0x0079
+ */
+#define HC_HTXnMPMD_SMASK       0x00070000
+#define HC_HTXnMPMD_TMASK       0x00380000
+#define HC_HTXnLODDTf_MASK      0x00000007
+#define HC_HTXnXY2ST_MASK       0x00000008
+#define HC_HTXnMPMD_Tsingle     0x00000000
+#define HC_HTXnMPMD_Tclamp      0x00080000
+#define HC_HTXnMPMD_Trepeat     0x00100000
+#define HC_HTXnMPMD_Tmirror     0x00180000
+#define HC_HTXnMPMD_Twrap       0x00200000
+#define HC_HTXnMPMD_Ssingle     0x00000000
+#define HC_HTXnMPMD_Sclamp      0x00010000
+#define HC_HTXnMPMD_Srepeat     0x00020000
+#define HC_HTXnMPMD_Smirror     0x00030000
+#define HC_HTXnMPMD_Swrap       0x00040000
+/* HC_SubA_HTXnCLODu       0x007a
+ */
+#define HC_HTXnCLODu_MASK       0x000ffc00
+#define HC_HTXnCLODd_MASK       0x000003ff
+#define HC_HTXnCLODu_SHIFT      10
+/* HC_SubA_HTXnFM          0x007b
+ */
+#define HC_HTXnFM_MASK          0x00ff0000
+#define HC_HTXnLoc_MASK         0x00000003
+#define HC_HTXnFM_INDEX         0x00000000
+#define HC_HTXnFM_Intensity     0x00080000
+#define HC_HTXnFM_Lum           0x00100000
+#define HC_HTXnFM_Alpha         0x00180000
+#define HC_HTXnFM_DX            0x00280000
+#define HC_HTXnFM_ARGB16        0x00880000
+#define HC_HTXnFM_ARGB32        0x00980000
+#define HC_HTXnFM_ABGR16        0x00a80000
+#define HC_HTXnFM_ABGR32        0x00b80000
+#define HC_HTXnFM_RGBA16        0x00c80000
+#define HC_HTXnFM_RGBA32        0x00d80000
+#define HC_HTXnFM_BGRA16        0x00e80000
+#define HC_HTXnFM_BGRA32        0x00f80000
+#define HC_HTXnFM_BUMPMAP       0x00380000
+#define HC_HTXnFM_Index1        (HC_HTXnFM_INDEX     | 0x00000000)
+#define HC_HTXnFM_Index2        (HC_HTXnFM_INDEX     | 0x00010000)
+#define HC_HTXnFM_Index4        (HC_HTXnFM_INDEX     | 0x00020000)
+#define HC_HTXnFM_Index8        (HC_HTXnFM_INDEX     | 0x00030000)
+#define HC_HTXnFM_T1            (HC_HTXnFM_Intensity | 0x00000000)
+#define HC_HTXnFM_T2            (HC_HTXnFM_Intensity | 0x00010000)
+#define HC_HTXnFM_T4            (HC_HTXnFM_Intensity | 0x00020000)
+#define HC_HTXnFM_T8            (HC_HTXnFM_Intensity | 0x00030000)
+#define HC_HTXnFM_L1            (HC_HTXnFM_Lum       | 0x00000000)
+#define HC_HTXnFM_L2            (HC_HTXnFM_Lum       | 0x00010000)
+#define HC_HTXnFM_L4            (HC_HTXnFM_Lum       | 0x00020000)
+#define HC_HTXnFM_L8            (HC_HTXnFM_Lum       | 0x00030000)
+#define HC_HTXnFM_AL44          (HC_HTXnFM_Lum       | 0x00040000)
+#define HC_HTXnFM_AL88          (HC_HTXnFM_Lum       | 0x00050000)
+#define HC_HTXnFM_A1            (HC_HTXnFM_Alpha     | 0x00000000)
+#define HC_HTXnFM_A2            (HC_HTXnFM_Alpha     | 0x00010000)
+#define HC_HTXnFM_A4            (HC_HTXnFM_Alpha     | 0x00020000)
+#define HC_HTXnFM_A8            (HC_HTXnFM_Alpha     | 0x00030000)
+#define HC_HTXnFM_DX1           (HC_HTXnFM_DX        | 0x00010000)
+#define HC_HTXnFM_DX23          (HC_HTXnFM_DX        | 0x00020000)
+#define HC_HTXnFM_DX45          (HC_HTXnFM_DX        | 0x00030000)
+#define HC_HTXnFM_RGB555        (HC_HTXnFM_ARGB16    | 0x00000000)
+#define HC_HTXnFM_RGB565        (HC_HTXnFM_ARGB16    | 0x00010000)
+#define HC_HTXnFM_ARGB1555      (HC_HTXnFM_ARGB16    | 0x00020000)
+#define HC_HTXnFM_ARGB4444      (HC_HTXnFM_ARGB16    | 0x00030000)
+#define HC_HTXnFM_ARGB0888      (HC_HTXnFM_ARGB32    | 0x00000000)
+#define HC_HTXnFM_ARGB8888      (HC_HTXnFM_ARGB32    | 0x00010000)
+#define HC_HTXnFM_BGR555        (HC_HTXnFM_ABGR16    | 0x00000000)
+#define HC_HTXnFM_BGR565        (HC_HTXnFM_ABGR16    | 0x00010000)
+#define HC_HTXnFM_ABGR1555      (HC_HTXnFM_ABGR16    | 0x00020000)
+#define HC_HTXnFM_ABGR4444      (HC_HTXnFM_ABGR16    | 0x00030000)
+#define HC_HTXnFM_ABGR0888      (HC_HTXnFM_ABGR32    | 0x00000000)
+#define HC_HTXnFM_ABGR8888      (HC_HTXnFM_ABGR32    | 0x00010000)
+#define HC_HTXnFM_RGBA5550      (HC_HTXnFM_RGBA16    | 0x00000000)
+#define HC_HTXnFM_RGBA5551      (HC_HTXnFM_RGBA16    | 0x00020000)
+#define HC_HTXnFM_RGBA4444      (HC_HTXnFM_RGBA16    | 0x00030000)
+#define HC_HTXnFM_RGBA8880      (HC_HTXnFM_RGBA32    | 0x00000000)
+#define HC_HTXnFM_RGBA8888      (HC_HTXnFM_RGBA32    | 0x00010000)
+#define HC_HTXnFM_BGRA5550      (HC_HTXnFM_BGRA16    | 0x00000000)
+#define HC_HTXnFM_BGRA5551      (HC_HTXnFM_BGRA16    | 0x00020000)
+#define HC_HTXnFM_BGRA4444      (HC_HTXnFM_BGRA16    | 0x00030000)
+#define HC_HTXnFM_BGRA8880      (HC_HTXnFM_BGRA32    | 0x00000000)
+#define HC_HTXnFM_BGRA8888      (HC_HTXnFM_BGRA32    | 0x00010000)
+#define HC_HTXnFM_VU88          (HC_HTXnFM_BUMPMAP   | 0x00000000)
+#define HC_HTXnFM_LVU655        (HC_HTXnFM_BUMPMAP   | 0x00010000)
+#define HC_HTXnFM_LVU888        (HC_HTXnFM_BUMPMAP   | 0x00020000)
+#define HC_HTXnLoc_Local        0x00000000
+#define HC_HTXnLoc_Sys          0x00000002
+#define HC_HTXnLoc_AGP          0x00000003
+/* HC_SubA_HTXnTRAH        0x007f
+ */
+#define HC_HTXnTRAH_MASK        0x00ff0000
+#define HC_HTXnTRAL_MASK        0x0000ff00
+#define HC_HTXnTBA_MASK         0x000000ff
+#define HC_HTXnTRAH_SHIFT       16
+#define HC_HTXnTRAL_SHIFT       8
+/* HC_SubA_HTXnTBLCsat     0x0080
+ *-- Define the input texture.
+ */
+#define HC_XTC_TOPC             0x00000000
+#define HC_XTC_InvTOPC          0x00000010
+#define HC_XTC_TOPCp5           0x00000020
+#define HC_XTC_Cbias            0x00000000
+#define HC_XTC_InvCbias         0x00000010
+#define HC_XTC_0                0x00000000
+#define HC_XTC_Dif              0x00000001
+#define HC_XTC_Spec             0x00000002
+#define HC_XTC_Tex              0x00000003
+#define HC_XTC_Cur              0x00000004
+#define HC_XTC_Adif             0x00000005
+#define HC_XTC_Fog              0x00000006
+#define HC_XTC_Atex             0x00000007
+#define HC_XTC_Acur             0x00000008
+#define HC_XTC_HTXnTBLRC        0x00000009
+#define HC_XTC_Ctexnext         0x0000000a
+/*--
+ */
+#define HC_HTXnTBLCsat_MASK     0x00800000
+#define HC_HTXnTBLCa_MASK       0x000fc000
+#define HC_HTXnTBLCb_MASK       0x00001f80
+#define HC_HTXnTBLCc_MASK       0x0000003f
+#define HC_HTXnTBLCa_TOPC       (HC_XTC_TOPC << 14)
+#define HC_HTXnTBLCa_InvTOPC    (HC_XTC_InvTOPC << 14)
+#define HC_HTXnTBLCa_TOPCp5     (HC_XTC_TOPCp5 << 14)
+#define HC_HTXnTBLCa_0          (HC_XTC_0 << 14)
+#define HC_HTXnTBLCa_Dif        (HC_XTC_Dif << 14)
+#define HC_HTXnTBLCa_Spec       (HC_XTC_Spec << 14)
+#define HC_HTXnTBLCa_Tex        (HC_XTC_Tex << 14)
+#define HC_HTXnTBLCa_Cur        (HC_XTC_Cur << 14)
+#define HC_HTXnTBLCa_Adif       (HC_XTC_Adif << 14)
+#define HC_HTXnTBLCa_Fog        (HC_XTC_Fog << 14)
+#define HC_HTXnTBLCa_Atex       (HC_XTC_Atex << 14)
+#define HC_HTXnTBLCa_Acur       (HC_XTC_Acur << 14)
+#define HC_HTXnTBLCa_HTXnTBLRC  (HC_XTC_HTXnTBLRC << 14)
+#define HC_HTXnTBLCa_Ctexnext   (HC_XTC_Ctexnext << 14)
+#define HC_HTXnTBLCb_TOPC       (HC_XTC_TOPC << 7)
+#define HC_HTXnTBLCb_InvTOPC    (HC_XTC_InvTOPC << 7)
+#define HC_HTXnTBLCb_TOPCp5     (HC_XTC_TOPCp5 << 7)
+#define HC_HTXnTBLCb_0          (HC_XTC_0 << 7)
+#define HC_HTXnTBLCb_Dif        (HC_XTC_Dif << 7)
+#define HC_HTXnTBLCb_Spec       (HC_XTC_Spec << 7)
+#define HC_HTXnTBLCb_Tex        (HC_XTC_Tex << 7)
+#define HC_HTXnTBLCb_Cur        (HC_XTC_Cur << 7)
+#define HC_HTXnTBLCb_Adif       (HC_XTC_Adif << 7)
+#define HC_HTXnTBLCb_Fog        (HC_XTC_Fog << 7)
+#define HC_HTXnTBLCb_Atex       (HC_XTC_Atex << 7)
+#define HC_HTXnTBLCb_Acur       (HC_XTC_Acur << 7)
+#define HC_HTXnTBLCb_HTXnTBLRC  (HC_XTC_HTXnTBLRC << 7)
+#define HC_HTXnTBLCb_Ctexnext   (HC_XTC_Ctexnext << 7)
+#define HC_HTXnTBLCc_TOPC       (HC_XTC_TOPC << 0)
+#define HC_HTXnTBLCc_InvTOPC    (HC_XTC_InvTOPC << 0)
+#define HC_HTXnTBLCc_TOPCp5     (HC_XTC_TOPCp5 << 0)
+#define HC_HTXnTBLCc_0          (HC_XTC_0 << 0)
+#define HC_HTXnTBLCc_Dif        (HC_XTC_Dif << 0)
+#define HC_HTXnTBLCc_Spec       (HC_XTC_Spec << 0)
+#define HC_HTXnTBLCc_Tex        (HC_XTC_Tex << 0)
+#define HC_HTXnTBLCc_Cur        (HC_XTC_Cur << 0)
+#define HC_HTXnTBLCc_Adif       (HC_XTC_Adif << 0)
+#define HC_HTXnTBLCc_Fog        (HC_XTC_Fog << 0)
+#define HC_HTXnTBLCc_Atex       (HC_XTC_Atex << 0)
+#define HC_HTXnTBLCc_Acur       (HC_XTC_Acur << 0)
+#define HC_HTXnTBLCc_HTXnTBLRC  (HC_XTC_HTXnTBLRC << 0)
+#define HC_HTXnTBLCc_Ctexnext   (HC_XTC_Ctexnext << 0)
+/* HC_SubA_HTXnTBLCop      0x0081
+ */
+#define HC_HTXnTBLdot_MASK      0x00c00000
+#define HC_HTXnTBLCop_MASK      0x00380000
+#define HC_HTXnTBLCbias_MASK    0x0007c000
+#define HC_HTXnTBLCshift_MASK   0x00001800
+#define HC_HTXnTBLAop_MASK      0x00000380
+#define HC_HTXnTBLAbias_MASK    0x00000078
+#define HC_HTXnTBLAshift_MASK   0x00000003
+#define HC_HTXnTBLCop_Add       0x00000000
+#define HC_HTXnTBLCop_Sub       0x00080000
+#define HC_HTXnTBLCop_Min       0x00100000
+#define HC_HTXnTBLCop_Max       0x00180000
+#define HC_HTXnTBLCop_Mask      0x00200000
+#define HC_HTXnTBLCbias_Cbias           (HC_XTC_Cbias << 14)
+#define HC_HTXnTBLCbias_InvCbias        (HC_XTC_InvCbias << 14)
+#define HC_HTXnTBLCbias_0               (HC_XTC_0 << 14)
+#define HC_HTXnTBLCbias_Dif             (HC_XTC_Dif << 14)
+#define HC_HTXnTBLCbias_Spec            (HC_XTC_Spec << 14)
+#define HC_HTXnTBLCbias_Tex             (HC_XTC_Tex << 14)
+#define HC_HTXnTBLCbias_Cur             (HC_XTC_Cur << 14)
+#define HC_HTXnTBLCbias_Adif            (HC_XTC_Adif << 14)
+#define HC_HTXnTBLCbias_Fog             (HC_XTC_Fog << 14)
+#define HC_HTXnTBLCbias_Atex            (HC_XTC_Atex << 14)
+#define HC_HTXnTBLCbias_Acur            (HC_XTC_Acur << 14)
+#define HC_HTXnTBLCbias_HTXnTBLRC       (HC_XTC_HTXnTBLRC << 14)
+#define HC_HTXnTBLCshift_1      0x00000000
+#define HC_HTXnTBLCshift_2      0x00000800
+#define HC_HTXnTBLCshift_No     0x00001000
+#define HC_HTXnTBLCshift_DotP   0x00001800
+/*=* John Sheng [2003.7.18] texture combine *=*/
+#define HC_HTXnTBLDOT3   0x00080000
+#define HC_HTXnTBLDOT4   0x000C0000
+
+#define HC_HTXnTBLAop_Add       0x00000000
+#define HC_HTXnTBLAop_Sub       0x00000080
+#define HC_HTXnTBLAop_Min       0x00000100
+#define HC_HTXnTBLAop_Max       0x00000180
+#define HC_HTXnTBLAop_Mask      0x00000200
+#define HC_HTXnTBLAbias_Inv             0x00000040
+#define HC_HTXnTBLAbias_Adif            0x00000000
+#define HC_HTXnTBLAbias_Fog             0x00000008
+#define HC_HTXnTBLAbias_Acur            0x00000010
+#define HC_HTXnTBLAbias_HTXnTBLRAbias   0x00000018
+#define HC_HTXnTBLAbias_Atex            0x00000020
+#define HC_HTXnTBLAshift_1      0x00000000
+#define HC_HTXnTBLAshift_2      0x00000001
+#define HC_HTXnTBLAshift_No     0x00000002
+/* #define HC_HTXnTBLAshift_DotP   0x00000003 */
+/* HC_SubA_HTXnTBLMPFog    0x0082
+ */
+#define HC_HTXnTBLMPfog_MASK    0x00e00000
+#define HC_HTXnTBLMPfog_0       0x00000000
+#define HC_HTXnTBLMPfog_Adif    0x00200000
+#define HC_HTXnTBLMPfog_Fog     0x00400000
+#define HC_HTXnTBLMPfog_Atex    0x00600000
+#define HC_HTXnTBLMPfog_Acur    0x00800000
+#define HC_HTXnTBLMPfog_GHTXnTBLRFog    0x00a00000
+/* HC_SubA_HTXnTBLAsat     0x0083
+ *-- Define the texture alpha input.
+ */
+#define HC_XTA_TOPA             0x00000000
+#define HC_XTA_InvTOPA          0x00000008
+#define HC_XTA_TOPAp5           0x00000010
+#define HC_XTA_Adif             0x00000000
+#define HC_XTA_Fog              0x00000001
+#define HC_XTA_Acur             0x00000002
+#define HC_XTA_HTXnTBLRA        0x00000003
+#define HC_XTA_Atex             0x00000004
+#define HC_XTA_Atexnext         0x00000005
+/*--
+ */
+#define HC_HTXnTBLAsat_MASK     0x00800000
+#define HC_HTXnTBLAMB_MASK      0x00700000
+#define HC_HTXnTBLAa_MASK       0x0007c000
+#define HC_HTXnTBLAb_MASK       0x00000f80
+#define HC_HTXnTBLAc_MASK       0x0000001f
+#define HC_HTXnTBLAMB_SHIFT     20
+#define HC_HTXnTBLAa_TOPA       (HC_XTA_TOPA << 14)
+#define HC_HTXnTBLAa_InvTOPA    (HC_XTA_InvTOPA << 14)
+#define HC_HTXnTBLAa_TOPAp5     (HC_XTA_TOPAp5 << 14)
+#define HC_HTXnTBLAa_Adif       (HC_XTA_Adif << 14)
+#define HC_HTXnTBLAa_Fog        (HC_XTA_Fog << 14)
+#define HC_HTXnTBLAa_Acur       (HC_XTA_Acur << 14)
+#define HC_HTXnTBLAa_HTXnTBLRA  (HC_XTA_HTXnTBLRA << 14)
+#define HC_HTXnTBLAa_Atex       (HC_XTA_Atex << 14)
+#define HC_HTXnTBLAa_Atexnext   (HC_XTA_Atexnext << 14)
+#define HC_HTXnTBLAb_TOPA       (HC_XTA_TOPA << 7)
+#define HC_HTXnTBLAb_InvTOPA    (HC_XTA_InvTOPA << 7)
+#define HC_HTXnTBLAb_TOPAp5     (HC_XTA_TOPAp5 << 7)
+#define HC_HTXnTBLAb_Adif       (HC_XTA_Adif << 7)
+#define HC_HTXnTBLAb_Fog        (HC_XTA_Fog << 7)
+#define HC_HTXnTBLAb_Acur       (HC_XTA_Acur << 7)
+#define HC_HTXnTBLAb_HTXnTBLRA  (HC_XTA_HTXnTBLRA << 7)
+#define HC_HTXnTBLAb_Atex       (HC_XTA_Atex << 7)
+#define HC_HTXnTBLAb_Atexnext   (HC_XTA_Atexnext << 7)
+#define HC_HTXnTBLAc_TOPA       (HC_XTA_TOPA << 0)
+#define HC_HTXnTBLAc_InvTOPA    (HC_XTA_InvTOPA << 0)
+#define HC_HTXnTBLAc_TOPAp5     (HC_XTA_TOPAp5 << 0)
+#define HC_HTXnTBLAc_Adif       (HC_XTA_Adif << 0)
+#define HC_HTXnTBLAc_Fog        (HC_XTA_Fog << 0)
+#define HC_HTXnTBLAc_Acur       (HC_XTA_Acur << 0)
+#define HC_HTXnTBLAc_HTXnTBLRA  (HC_XTA_HTXnTBLRA << 0)
+#define HC_HTXnTBLAc_Atex       (HC_XTA_Atex << 0)
+#define HC_HTXnTBLAc_Atexnext   (HC_XTA_Atexnext << 0)
+/* HC_SubA_HTXnTBLRAa      0x0089
+ */
+#define HC_HTXnTBLRAa_MASK      0x00ff0000
+#define HC_HTXnTBLRAb_MASK      0x0000ff00
+#define HC_HTXnTBLRAc_MASK      0x000000ff
+#define HC_HTXnTBLRAa_SHIFT     16
+#define HC_HTXnTBLRAb_SHIFT     8
+#define HC_HTXnTBLRAc_SHIFT     0
+/* HC_SubA_HTXnTBLRFog     0x008a
+ */
+#define HC_HTXnTBLRFog_MASK     0x0000ff00
+#define HC_HTXnTBLRAbias_MASK   0x000000ff
+#define HC_HTXnTBLRFog_SHIFT    8
+#define HC_HTXnTBLRAbias_SHIFT  0
+/* HC_SubA_HTXnLScale      0x0094
+ */
+#define HC_HTXnLScale_MASK      0x0007fc00
+#define HC_HTXnLOff_MASK        0x000001ff
+#define HC_HTXnLScale_SHIFT     10
+/* HC_SubA_HTXSMD          0x0000
+ */
+#define HC_HTXSMD_MASK          0x00000080
+#define HC_HTXTMD_MASK          0x00000040
+#define HC_HTXNum_MASK          0x00000038
+#define HC_HTXTRMD_MASK         0x00000006
+#define HC_HTXCHCLR_MASK        0x00000001
+#define HC_HTXNum_SHIFT         3
+
+/* Texture Palette n
+ */
+#define HC_SubType_TexPalette0  0x00000000
+#define HC_SubType_TexPalette1  0x00000001
+#define HC_SubType_FogTable     0x00000010
+#define HC_SubType_Stipple      0x00000014
+/* HC_SubA_TexPalette0     0x0000
+ */
+#define HC_HTPnA_MASK           0xff000000
+#define HC_HTPnR_MASK           0x00ff0000
+#define HC_HTPnG_MASK           0x0000ff00
+#define HC_HTPnB_MASK           0x000000ff
+/* HC_SubA_FogTable        0x0010
+ */
+#define HC_HFPn3_MASK           0xff000000
+#define HC_HFPn2_MASK           0x00ff0000
+#define HC_HFPn1_MASK           0x0000ff00
+#define HC_HFPn_MASK            0x000000ff
+#define HC_HFPn3_SHIFT          24
+#define HC_HFPn2_SHIFT          16
+#define HC_HFPn1_SHIFT          8
+
+/* Auto Testing & Security
+ */
+#define HC_SubA_HenFIFOAT       0x0000
+#define HC_SubA_HFBDrawFirst    0x0004
+#define HC_SubA_HFBBasL         0x0005
+#define HC_SubA_HFBDst          0x0006
+/* HC_SubA_HenFIFOAT       0x0000
+ */
+#define HC_HenFIFOAT_MASK       0x00000020
+#define HC_HenGEMILock_MASK     0x00000010
+#define HC_HenFBASwap_MASK      0x00000008
+#define HC_HenOT_MASK           0x00000004
+#define HC_HenCMDQ_MASK         0x00000002
+#define HC_HenTXCTSU_MASK       0x00000001
+/* HC_SubA_HFBDrawFirst    0x0004
+ */
+#define HC_HFBDrawFirst_MASK    0x00000800
+#define HC_HFBQueue_MASK        0x00000400
+#define HC_HFBLock_MASK         0x00000200
+#define HC_HEOF_MASK            0x00000100
+#define HC_HFBBasH_MASK         0x000000ff
+
+/* GEMI Setting
+ */
+#define HC_SubA_HTArbRCM        0x0008
+#define HC_SubA_HTArbRZ         0x000a
+#define HC_SubA_HTArbWZ         0x000b
+#define HC_SubA_HTArbRTX        0x000c
+#define HC_SubA_HTArbRCW        0x000d
+#define HC_SubA_HTArbE2         0x000e
+#define HC_SubA_HArbRQCM        0x0010
+#define HC_SubA_HArbWQCM        0x0011
+#define HC_SubA_HGEMITout       0x0020
+#define HC_SubA_HFthRTXD        0x0040
+#define HC_SubA_HFthRTXA        0x0044
+#define HC_SubA_HCMDQstL        0x0050
+#define HC_SubA_HCMDQendL       0x0051
+#define HC_SubA_HCMDQLen        0x0052
+/* HC_SubA_HTArbRCM        0x0008
+ */
+#define HC_HTArbRCM_MASK        0x0000ffff
+/* HC_SubA_HTArbRZ         0x000a
+ */
+#define HC_HTArbRZ_MASK         0x0000ffff
+/* HC_SubA_HTArbWZ         0x000b
+ */
+#define HC_HTArbWZ_MASK         0x0000ffff
+/* HC_SubA_HTArbRTX        0x000c
+ */
+#define HC_HTArbRTX_MASK        0x0000ffff
+/* HC_SubA_HTArbRCW        0x000d
+ */
+#define HC_HTArbRCW_MASK        0x0000ffff
+/* HC_SubA_HTArbE2         0x000e
+ */
+#define HC_HTArbE2_MASK         0x0000ffff
+/* HC_SubA_HArbRQCM        0x0010
+ */
+#define HC_HTArbRQCM_MASK       0x0000ffff
+/* HC_SubA_HArbWQCM        0x0011
+ */
+#define HC_HArbWQCM_MASK        0x0000ffff
+/* HC_SubA_HGEMITout       0x0020
+ */
+#define HC_HGEMITout_MASK       0x000f0000
+#define HC_HNPArbZC_MASK        0x0000ffff
+#define HC_HGEMITout_SHIFT      16
+/* HC_SubA_HFthRTXD        0x0040
+ */
+#define HC_HFthRTXD_MASK        0x00ff0000
+#define HC_HFthRZD_MASK         0x0000ff00
+#define HC_HFthWZD_MASK         0x000000ff
+#define HC_HFthRTXD_SHIFT       16
+#define HC_HFthRZD_SHIFT        8
+/* HC_SubA_HFthRTXA        0x0044
+ */
+#define HC_HFthRTXA_MASK        0x000000ff
+
+/******************************************************************************
+** Define the Halcyon Internal register access constants. For simulator only.
+******************************************************************************/
+#define HC_SIMA_HAGPBstL        0x0000
+#define HC_SIMA_HAGPBendL       0x0001
+#define HC_SIMA_HAGPCMNT        0x0002
+#define HC_SIMA_HAGPBpL         0x0003
+#define HC_SIMA_HAGPBpH         0x0004
+#define HC_SIMA_HClipTB         0x0005
+#define HC_SIMA_HClipLR         0x0006
+#define HC_SIMA_HFPClipTL       0x0007
+#define HC_SIMA_HFPClipBL       0x0008
+#define HC_SIMA_HFPClipLL       0x0009
+#define HC_SIMA_HFPClipRL       0x000a
+#define HC_SIMA_HFPClipTBH      0x000b
+#define HC_SIMA_HFPClipLRH      0x000c
+#define HC_SIMA_HLP             0x000d
+#define HC_SIMA_HLPRF           0x000e
+#define HC_SIMA_HSolidCL        0x000f
+#define HC_SIMA_HPixGC          0x0010
+#define HC_SIMA_HSPXYOS         0x0011
+#define HC_SIMA_HCmdA           0x0012
+#define HC_SIMA_HCmdB           0x0013
+#define HC_SIMA_HEnable         0x0014
+#define HC_SIMA_HZWBBasL        0x0015
+#define HC_SIMA_HZWBBasH        0x0016
+#define HC_SIMA_HZWBType        0x0017
+#define HC_SIMA_HZBiasL         0x0018
+#define HC_SIMA_HZWBend         0x0019
+#define HC_SIMA_HZWTMD          0x001a
+#define HC_SIMA_HZWCDL          0x001b
+#define HC_SIMA_HZWCTAGnum      0x001c
+#define HC_SIMA_HZCYNum         0x001d
+#define HC_SIMA_HZWCFire        0x001e
+/* #define HC_SIMA_HSBBasL         0x001d */
+/* #define HC_SIMA_HSBBasH         0x001e */
+/* #define HC_SIMA_HSBFM           0x001f */
+#define HC_SIMA_HSTREF          0x0020
+#define HC_SIMA_HSTMD           0x0021
+#define HC_SIMA_HABBasL         0x0022
+#define HC_SIMA_HABBasH         0x0023
+#define HC_SIMA_HABFM           0x0024
+#define HC_SIMA_HATMD           0x0025
+#define HC_SIMA_HABLCsat        0x0026
+#define HC_SIMA_HABLCop         0x0027
+#define HC_SIMA_HABLAsat        0x0028
+#define HC_SIMA_HABLAop         0x0029
+#define HC_SIMA_HABLRCa         0x002a
+#define HC_SIMA_HABLRFCa        0x002b
+#define HC_SIMA_HABLRCbias      0x002c
+#define HC_SIMA_HABLRCb         0x002d
+#define HC_SIMA_HABLRFCb        0x002e
+#define HC_SIMA_HABLRAa         0x002f
+#define HC_SIMA_HABLRAb         0x0030
+#define HC_SIMA_HDBBasL         0x0031
+#define HC_SIMA_HDBBasH         0x0032
+#define HC_SIMA_HDBFM           0x0033
+#define HC_SIMA_HFBBMSKL        0x0034
+#define HC_SIMA_HROP            0x0035
+#define HC_SIMA_HFogLF          0x0036
+#define HC_SIMA_HFogCL          0x0037
+#define HC_SIMA_HFogCH          0x0038
+#define HC_SIMA_HFogStL         0x0039
+#define HC_SIMA_HFogStH         0x003a
+#define HC_SIMA_HFogOOdMF       0x003b
+#define HC_SIMA_HFogOOdEF       0x003c
+#define HC_SIMA_HFogEndL        0x003d
+#define HC_SIMA_HFogDenst       0x003e
+/*---- start of texture 0 setting ----
+ */
+#define HC_SIMA_HTX0L0BasL      0x0040
+#define HC_SIMA_HTX0L1BasL      0x0041
+#define HC_SIMA_HTX0L2BasL      0x0042
+#define HC_SIMA_HTX0L3BasL      0x0043
+#define HC_SIMA_HTX0L4BasL      0x0044
+#define HC_SIMA_HTX0L5BasL      0x0045
+#define HC_SIMA_HTX0L6BasL      0x0046
+#define HC_SIMA_HTX0L7BasL      0x0047
+#define HC_SIMA_HTX0L8BasL      0x0048
+#define HC_SIMA_HTX0L9BasL      0x0049
+#define HC_SIMA_HTX0LaBasL      0x004a
+#define HC_SIMA_HTX0LbBasL      0x004b
+#define HC_SIMA_HTX0LcBasL      0x004c
+#define HC_SIMA_HTX0LdBasL      0x004d
+#define HC_SIMA_HTX0LeBasL      0x004e
+#define HC_SIMA_HTX0LfBasL      0x004f
+#define HC_SIMA_HTX0L10BasL     0x0050
+#define HC_SIMA_HTX0L11BasL     0x0051
+#define HC_SIMA_HTX0L012BasH    0x0052
+#define HC_SIMA_HTX0L345BasH    0x0053
+#define HC_SIMA_HTX0L678BasH    0x0054
+#define HC_SIMA_HTX0L9abBasH    0x0055
+#define HC_SIMA_HTX0LcdeBasH    0x0056
+#define HC_SIMA_HTX0Lf1011BasH  0x0057
+#define HC_SIMA_HTX0L0Pit       0x0058
+#define HC_SIMA_HTX0L1Pit       0x0059
+#define HC_SIMA_HTX0L2Pit       0x005a
+#define HC_SIMA_HTX0L3Pit       0x005b
+#define HC_SIMA_HTX0L4Pit       0x005c
+#define HC_SIMA_HTX0L5Pit       0x005d
+#define HC_SIMA_HTX0L6Pit       0x005e
+#define HC_SIMA_HTX0L7Pit       0x005f
+#define HC_SIMA_HTX0L8Pit       0x0060
+#define HC_SIMA_HTX0L9Pit       0x0061
+#define HC_SIMA_HTX0LaPit       0x0062
+#define HC_SIMA_HTX0LbPit       0x0063
+#define HC_SIMA_HTX0LcPit       0x0064
+#define HC_SIMA_HTX0LdPit       0x0065
+#define HC_SIMA_HTX0LePit       0x0066
+#define HC_SIMA_HTX0LfPit       0x0067
+#define HC_SIMA_HTX0L10Pit      0x0068
+#define HC_SIMA_HTX0L11Pit      0x0069
+#define HC_SIMA_HTX0L0_5WE      0x006a
+#define HC_SIMA_HTX0L6_bWE      0x006b
+#define HC_SIMA_HTX0Lc_11WE     0x006c
+#define HC_SIMA_HTX0L0_5HE      0x006d
+#define HC_SIMA_HTX0L6_bHE      0x006e
+#define HC_SIMA_HTX0Lc_11HE     0x006f
+#define HC_SIMA_HTX0L0OS        0x0070
+#define HC_SIMA_HTX0TB          0x0071
+#define HC_SIMA_HTX0MPMD        0x0072
+#define HC_SIMA_HTX0CLODu       0x0073
+#define HC_SIMA_HTX0FM          0x0074
+#define HC_SIMA_HTX0TRCH        0x0075
+#define HC_SIMA_HTX0TRCL        0x0076
+#define HC_SIMA_HTX0TBC         0x0077
+#define HC_SIMA_HTX0TRAH        0x0078
+#define HC_SIMA_HTX0TBLCsat     0x0079
+#define HC_SIMA_HTX0TBLCop      0x007a
+#define HC_SIMA_HTX0TBLMPfog    0x007b
+#define HC_SIMA_HTX0TBLAsat     0x007c
+#define HC_SIMA_HTX0TBLRCa      0x007d
+#define HC_SIMA_HTX0TBLRCb      0x007e
+#define HC_SIMA_HTX0TBLRCc      0x007f
+#define HC_SIMA_HTX0TBLRCbias   0x0080
+#define HC_SIMA_HTX0TBLRAa      0x0081
+#define HC_SIMA_HTX0TBLRFog     0x0082
+#define HC_SIMA_HTX0BumpM00     0x0083
+#define HC_SIMA_HTX0BumpM01     0x0084
+#define HC_SIMA_HTX0BumpM10     0x0085
+#define HC_SIMA_HTX0BumpM11     0x0086
+#define HC_SIMA_HTX0LScale      0x0087
+/*---- end of texture 0 setting ----      0x008f
+ */
+#define HC_SIMA_TX0TX1_OFF      0x0050
+/*---- start of texture 1 setting ----
+ */
+#define HC_SIMA_HTX1L0BasL      (HC_SIMA_HTX0L0BasL + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1L1BasL      (HC_SIMA_HTX0L1BasL + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1L2BasL      (HC_SIMA_HTX0L2BasL + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1L3BasL      (HC_SIMA_HTX0L3BasL + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1L4BasL      (HC_SIMA_HTX0L4BasL + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1L5BasL      (HC_SIMA_HTX0L5BasL + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1L6BasL      (HC_SIMA_HTX0L6BasL + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1L7BasL      (HC_SIMA_HTX0L7BasL + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1L8BasL      (HC_SIMA_HTX0L8BasL + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1L9BasL      (HC_SIMA_HTX0L9BasL + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1LaBasL      (HC_SIMA_HTX0LaBasL + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1LbBasL      (HC_SIMA_HTX0LbBasL + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1LcBasL      (HC_SIMA_HTX0LcBasL + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1LdBasL      (HC_SIMA_HTX0LdBasL + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1LeBasL      (HC_SIMA_HTX0LeBasL + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1LfBasL      (HC_SIMA_HTX0LfBasL + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1L10BasL     (HC_SIMA_HTX0L10BasL + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1L11BasL     (HC_SIMA_HTX0L11BasL + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1L012BasH    (HC_SIMA_HTX0L012BasH + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1L345BasH    (HC_SIMA_HTX0L345BasH + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1L678BasH    (HC_SIMA_HTX0L678BasH + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1L9abBasH    (HC_SIMA_HTX0L9abBasH + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1LcdeBasH    (HC_SIMA_HTX0LcdeBasH + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1Lf1011BasH  (HC_SIMA_HTX0Lf1011BasH + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1L0Pit       (HC_SIMA_HTX0L0Pit + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1L1Pit       (HC_SIMA_HTX0L1Pit + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1L2Pit       (HC_SIMA_HTX0L2Pit + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1L3Pit       (HC_SIMA_HTX0L3Pit + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1L4Pit       (HC_SIMA_HTX0L4Pit + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1L5Pit       (HC_SIMA_HTX0L5Pit + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1L6Pit       (HC_SIMA_HTX0L6Pit + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1L7Pit       (HC_SIMA_HTX0L7Pit + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1L8Pit       (HC_SIMA_HTX0L8Pit + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1L9Pit       (HC_SIMA_HTX0L9Pit + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1LaPit       (HC_SIMA_HTX0LaPit + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1LbPit       (HC_SIMA_HTX0LbPit + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1LcPit       (HC_SIMA_HTX0LcPit + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1LdPit       (HC_SIMA_HTX0LdPit + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1LePit       (HC_SIMA_HTX0LePit + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1LfPit       (HC_SIMA_HTX0LfPit + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1L10Pit      (HC_SIMA_HTX0L10Pit + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1L11Pit      (HC_SIMA_HTX0L11Pit + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1L0_5WE      (HC_SIMA_HTX0L0_5WE + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1L6_bWE      (HC_SIMA_HTX0L6_bWE + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1Lc_11WE     (HC_SIMA_HTX0Lc_11WE + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1L0_5HE      (HC_SIMA_HTX0L0_5HE + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1L6_bHE      (HC_SIMA_HTX0L6_bHE + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1Lc_11HE      (HC_SIMA_HTX0Lc_11HE + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1L0OS        (HC_SIMA_HTX0L0OS + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1TB          (HC_SIMA_HTX0TB + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1MPMD        (HC_SIMA_HTX0MPMD + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1CLODu       (HC_SIMA_HTX0CLODu + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1FM          (HC_SIMA_HTX0FM + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1TRCH        (HC_SIMA_HTX0TRCH + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1TRCL        (HC_SIMA_HTX0TRCL + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1TBC         (HC_SIMA_HTX0TBC + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1TRAH        (HC_SIMA_HTX0TRAH + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1LTC         (HC_SIMA_HTX0LTC + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1LTA         (HC_SIMA_HTX0LTA + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1TBLCsat     (HC_SIMA_HTX0TBLCsat + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1TBLCop      (HC_SIMA_HTX0TBLCop + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1TBLMPfog    (HC_SIMA_HTX0TBLMPfog + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1TBLAsat     (HC_SIMA_HTX0TBLAsat + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1TBLRCa      (HC_SIMA_HTX0TBLRCa + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1TBLRCb      (HC_SIMA_HTX0TBLRCb + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1TBLRCc      (HC_SIMA_HTX0TBLRCc + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1TBLRCbias   (HC_SIMA_HTX0TBLRCbias + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1TBLRAa      (HC_SIMA_HTX0TBLRAa + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1TBLRFog     (HC_SIMA_HTX0TBLRFog + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1BumpM00     (HC_SIMA_HTX0BumpM00 + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1BumpM01     (HC_SIMA_HTX0BumpM01 + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1BumpM10     (HC_SIMA_HTX0BumpM10 + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1BumpM11     (HC_SIMA_HTX0BumpM11 + HC_SIMA_TX0TX1_OFF)
+#define HC_SIMA_HTX1LScale      (HC_SIMA_HTX0LScale + HC_SIMA_TX0TX1_OFF)
+/*---- end of texture 1 setting ---- 0xaf
+ */
+#define HC_SIMA_HTXSMD          0x00b0
+#define HC_SIMA_HenFIFOAT       0x00b1
+#define HC_SIMA_HFBDrawFirst    0x00b2
+#define HC_SIMA_HFBBasL         0x00b3
+#define HC_SIMA_HTArbRCM        0x00b4
+#define HC_SIMA_HTArbRZ         0x00b5
+#define HC_SIMA_HTArbWZ         0x00b6
+#define HC_SIMA_HTArbRTX        0x00b7
+#define HC_SIMA_HTArbRCW        0x00b8
+#define HC_SIMA_HTArbE2         0x00b9
+#define HC_SIMA_HGEMITout       0x00ba
+#define HC_SIMA_HFthRTXD        0x00bb
+#define HC_SIMA_HFthRTXA        0x00bc
+/* Define the texture palette 0
+ */
+#define HC_SIMA_HTP0            0x0100
+#define HC_SIMA_HTP1            0x0200
+#define HC_SIMA_FOGTABLE        0x0300
+#define HC_SIMA_STIPPLE         0x0400
+#define HC_SIMA_HE3Fire         0x0440
+#define HC_SIMA_TRANS_SET       0x0441
+#define HC_SIMA_HREngSt         0x0442
+#define HC_SIMA_HRFIFOempty     0x0443
+#define HC_SIMA_HRFIFOfull      0x0444
+#define HC_SIMA_HRErr           0x0445
+#define HC_SIMA_FIFOstatus      0x0446
+
+/******************************************************************************
+** Define the AGP command header.
+******************************************************************************/
+#define HC_ACMD_MASK            0xfe000000
+#define HC_ACMD_SUB_MASK        0x0c000000
+#define HC_ACMD_HCmdA           0xee000000
+#define HC_ACMD_HCmdB           0xec000000
+#define HC_ACMD_HCmdC           0xea000000
+#define HC_ACMD_H1              0xf0000000
+#define HC_ACMD_H2              0xf2000000
+#define HC_ACMD_H3              0xf4000000
+#define HC_ACMD_H4              0xf6000000
+
+#define HC_ACMD_H1IO_MASK       0x000001ff
+#define HC_ACMD_H2IO1_MASK      0x001ff000
+#define HC_ACMD_H2IO2_MASK      0x000001ff
+#define HC_ACMD_H2IO1_SHIFT     12
+#define HC_ACMD_H2IO2_SHIFT     0
+#define HC_ACMD_H3IO_MASK       0x000001ff
+#define HC_ACMD_H3COUNT_MASK    0x01fff000
+#define HC_ACMD_H3COUNT_SHIFT   12
+#define HC_ACMD_H4ID_MASK       0x000001ff
+#define HC_ACMD_H4COUNT_MASK    0x01fffe00
+#define HC_ACMD_H4COUNT_SHIFT   9
+
+/********************************************************************************
+** Define Header
+********************************************************************************/
+#define HC_HEADER2		0xF210F110
+
+/********************************************************************************
+** Define Dummy Value
+********************************************************************************/
+#define HC_DUMMY		0xCCCCCCCC
+/********************************************************************************
+** Define for DMA use
+********************************************************************************/
+#define HALCYON_HEADER2     0XF210F110
+#define HALCYON_FIRECMD     0XEE100000
+#define HALCYON_FIREMASK    0XFFF00000
+#define HALCYON_CMDB        0XEC000000
+#define HALCYON_CMDBMASK    0XFFFE0000
+#define HALCYON_SUB_ADDR0   0X00000000
+#define HALCYON_HEADER1MASK 0XFFFFFC00
+#define HALCYON_HEADER1     0XF0000000
+#define HC_SubA_HAGPBstL        0x0060
+#define HC_SubA_HAGPBendL       0x0061
+#define HC_SubA_HAGPCMNT        0x0062
+#define HC_SubA_HAGPBpL         0x0063
+#define HC_SubA_HAGPBpH         0x0064
+#define HC_HAGPCMNT_MASK        0x00800000
+#define HC_HCmdErrClr_MASK      0x00400000
+#define HC_HAGPBendH_MASK       0x0000ff00
+#define HC_HAGPBstH_MASK        0x000000ff
+#define HC_HAGPBendH_SHIFT      8
+#define HC_HAGPBstH_SHIFT       0
+#define HC_HAGPBpL_MASK         0x00fffffc
+#define HC_HAGPBpID_MASK        0x00000003
+#define HC_HAGPBpID_PAUSE       0x00000000
+#define HC_HAGPBpID_JUMP        0x00000001
+#define HC_HAGPBpID_STOP        0x00000002
+#define HC_HAGPBpH_MASK         0x00ffffff
+
+
+#define VIA_VIDEO_HEADER5       0xFE040000
+#define VIA_VIDEO_HEADER6       0xFE050000
+#define VIA_VIDEO_HEADER7       0xFE060000
+#define VIA_VIDEOMASK           0xFFFF0000
+#endif
diff -purN linux-2.6.12.orig/drivers/char/drm/via_dma.c linux-2.6.12/drivers/char/drm/via_dma.c
--- linux-2.6.12.orig/drivers/char/drm/via_dma.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/drm/via_dma.c	2005-07-05 08:37:47.000000000 +0200
@@ -0,0 +1,741 @@
+/* via_dma.c -- DMA support for the VIA Unichrome/Pro
+ * 
+ * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
+ * All Rights Reserved.
+ *
+ * Copyright 2004 Digeo, Inc., Palo Alto, CA, U.S.A.
+ * All Rights Reserved.
+ * 
+ * Copyright 2004 The Unichrome project.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDERS, AUTHORS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, 
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE 
+ * USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: 
+ *    Tungsten Graphics, 
+ *    Erdi Chen, 
+ *    Thomas Hellstrom.
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "via_drm.h"
+#include "via_drv.h"
+#include "via_3d_reg.h"
+
+#define CMDBUF_ALIGNMENT_SIZE   (0x100)
+#define CMDBUF_ALIGNMENT_MASK   (0x0ff)
+
+/* defines for VIA 3D registers */
+#define VIA_REG_STATUS          0x400
+#define VIA_REG_TRANSET         0x43C
+#define VIA_REG_TRANSPACE       0x440
+
+/* VIA_REG_STATUS(0x400): Engine Status */
+#define VIA_CMD_RGTR_BUSY       0x00000080	/* Command Regulator is busy */
+#define VIA_2D_ENG_BUSY         0x00000001	/* 2D Engine is busy */
+#define VIA_3D_ENG_BUSY         0x00000002	/* 3D Engine is busy */
+#define VIA_VR_QUEUE_BUSY       0x00020000	/* Virtual Queue is busy */
+
+#define SetReg2DAGP(nReg, nData) {				\
+	*((uint32_t *)(vb)) = ((nReg) >> 2) | HALCYON_HEADER1;	\
+	*((uint32_t *)(vb) + 1) = (nData);			\
+	vb = ((uint32_t *)vb) + 2;				\
+	dev_priv->dma_low +=8;					\
+}
+
+#define via_flush_write_combine() DRM_MEMORYBARRIER() 
+
+#define VIA_OUT_RING_QW(w1,w2)			\
+	*vb++ = (w1);				\
+	*vb++ = (w2);				\
+	dev_priv->dma_low += 8; 
+
+static void via_cmdbuf_start(drm_via_private_t * dev_priv);
+static void via_cmdbuf_pause(drm_via_private_t * dev_priv);
+static void via_cmdbuf_reset(drm_via_private_t * dev_priv);
+static void via_cmdbuf_rewind(drm_via_private_t * dev_priv);
+static int via_wait_idle(drm_via_private_t * dev_priv);
+static void via_pad_cache(drm_via_private_t *dev_priv, int qwords);
+
+
+/*
+ * Free space in command buffer.
+ */
+
+static uint32_t
+via_cmdbuf_space(drm_via_private_t *dev_priv)
+{
+	uint32_t agp_base = dev_priv->dma_offset + 
+		(uint32_t) dev_priv->agpAddr;
+	uint32_t hw_addr = *(dev_priv->hw_addr_ptr) - agp_base;
+	
+	return ((hw_addr <= dev_priv->dma_low) ? 
+		(dev_priv->dma_high + hw_addr - dev_priv->dma_low) : 
+		(hw_addr - dev_priv->dma_low));
+}
+
+/*
+ * How much does the command regulator lag behind?
+ */
+
+static uint32_t
+via_cmdbuf_lag(drm_via_private_t *dev_priv)
+{
+	uint32_t agp_base = dev_priv->dma_offset + 
+		(uint32_t) dev_priv->agpAddr;
+	uint32_t hw_addr = *(dev_priv->hw_addr_ptr) - agp_base;
+	
+	return ((hw_addr <= dev_priv->dma_low) ? 
+		(dev_priv->dma_low - hw_addr) : 
+		(dev_priv->dma_wrap + dev_priv->dma_low - hw_addr));
+}
+
+/*
+ * Check that the given size fits in the buffer, otherwise wait.
+ */
+
+static inline int
+via_cmdbuf_wait(drm_via_private_t * dev_priv, unsigned int size)
+{
+	uint32_t agp_base = dev_priv->dma_offset + (uint32_t) dev_priv->agpAddr;
+	uint32_t cur_addr, hw_addr, next_addr;
+	volatile uint32_t *hw_addr_ptr;
+	uint32_t count;
+	hw_addr_ptr = dev_priv->hw_addr_ptr;
+	cur_addr = dev_priv->dma_low;
+	next_addr = cur_addr + size + 512*1024;
+	count = 1000000;
+	do {
+	        hw_addr = *hw_addr_ptr - agp_base;
+		if (count-- == 0) {
+			DRM_ERROR("via_cmdbuf_wait timed out hw %x cur_addr %x next_addr %x\n",
+				  hw_addr, cur_addr, next_addr);
+			return -1;
+		}
+	} while ((cur_addr < hw_addr) && (next_addr >= hw_addr));
+	return 0;
+}
+
+
+/*
+ * Checks whether buffer head has reach the end. Rewind the ring buffer
+ * when necessary.
+ *
+ * Returns virtual pointer to ring buffer.
+ */
+
+static inline uint32_t *via_check_dma(drm_via_private_t * dev_priv,
+				      unsigned int size)
+{
+	if ((dev_priv->dma_low + size + 4*CMDBUF_ALIGNMENT_SIZE) > dev_priv->dma_high) {
+		via_cmdbuf_rewind(dev_priv);
+	}
+	if (via_cmdbuf_wait(dev_priv, size) != 0) {
+		return NULL;
+	}
+
+	return (uint32_t *) (dev_priv->dma_ptr + dev_priv->dma_low);
+}
+
+int via_dma_cleanup(drm_device_t * dev)
+{
+	if (dev->dev_private) {
+		drm_via_private_t *dev_priv =
+			(drm_via_private_t *) dev->dev_private;
+
+		if (dev_priv->ring.virtual_start) {
+			via_cmdbuf_reset(dev_priv);
+
+			drm_core_ioremapfree(&dev_priv->ring.map, dev);
+			dev_priv->ring.virtual_start = NULL;
+		}
+
+	}
+
+	return 0;
+}
+
+static int via_initialize(drm_device_t * dev,
+			  drm_via_private_t * dev_priv,
+			  drm_via_dma_init_t * init)
+{
+	if (!dev_priv || !dev_priv->mmio) {
+		DRM_ERROR("via_dma_init called before via_map_init\n");
+		return DRM_ERR(EFAULT);
+	}
+
+	if (dev_priv->ring.virtual_start != NULL) {
+		DRM_ERROR("%s called again without calling cleanup\n",
+			  __FUNCTION__);
+		return DRM_ERR(EFAULT);
+	}
+
+	if (!dev->agp || !dev->agp->base) {
+		DRM_ERROR("%s called with no agp memory available\n", 
+			  __FUNCTION__);
+		return DRM_ERR(EFAULT);
+	}
+
+	dev_priv->ring.map.offset = dev->agp->base + init->offset;
+	dev_priv->ring.map.size = init->size;
+	dev_priv->ring.map.type = 0;
+	dev_priv->ring.map.flags = 0;
+	dev_priv->ring.map.mtrr = 0;
+
+	drm_core_ioremap(&dev_priv->ring.map, dev);
+
+	if (dev_priv->ring.map.handle == NULL) {
+		via_dma_cleanup(dev);
+		DRM_ERROR("can not ioremap virtual address for"
+			  " ring buffer\n");
+		return DRM_ERR(ENOMEM);
+	}
+
+	dev_priv->ring.virtual_start = dev_priv->ring.map.handle;
+
+	dev_priv->dma_ptr = dev_priv->ring.virtual_start;
+	dev_priv->dma_low = 0;
+	dev_priv->dma_high = init->size;
+	dev_priv->dma_wrap = init->size;
+	dev_priv->dma_offset = init->offset;
+	dev_priv->last_pause_ptr = NULL;
+	dev_priv->hw_addr_ptr = dev_priv->mmio->handle + init->reg_pause_addr;
+
+	via_cmdbuf_start(dev_priv);
+
+	return 0;
+}
+
+int via_dma_init(DRM_IOCTL_ARGS)
+{
+	DRM_DEVICE;
+	drm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;
+	drm_via_dma_init_t init;
+	int retcode = 0;
+
+	DRM_COPY_FROM_USER_IOCTL(init, (drm_via_dma_init_t *) data,
+				 sizeof(init));
+
+	switch (init.func) {
+	case VIA_INIT_DMA:
+		if (!capable(CAP_SYS_ADMIN))
+			retcode = DRM_ERR(EPERM);
+		else
+			retcode = via_initialize(dev, dev_priv, &init);
+		break;
+	case VIA_CLEANUP_DMA:
+		if (!capable(CAP_SYS_ADMIN))
+			retcode = DRM_ERR(EPERM);
+		else
+			retcode = via_dma_cleanup(dev);
+		break;
+        case VIA_DMA_INITIALIZED:
+		retcode = (dev_priv->ring.virtual_start != NULL) ? 
+			0: DRM_ERR( EFAULT );
+	        break;
+	default:
+		retcode = DRM_ERR(EINVAL);
+		break;
+	}
+
+	return retcode;
+}
+
+
+
+static int via_dispatch_cmdbuffer(drm_device_t * dev, drm_via_cmdbuffer_t * cmd)
+{
+	drm_via_private_t *dev_priv;
+	uint32_t *vb;
+	int ret;
+
+	dev_priv = (drm_via_private_t *) dev->dev_private;
+
+	if (dev_priv->ring.virtual_start == NULL) {
+		DRM_ERROR("%s called without initializing AGP ring buffer.\n",
+			  __FUNCTION__);
+		return DRM_ERR(EFAULT);
+	}
+
+	if (cmd->size > VIA_PCI_BUF_SIZE) {
+		return DRM_ERR(ENOMEM);
+	} 
+
+
+	if (DRM_COPY_FROM_USER(dev_priv->pci_buf, cmd->buf, cmd->size))
+		return DRM_ERR(EFAULT);
+
+	/*
+	 * Running this function on AGP memory is dead slow. Therefore
+	 * we run it on a temporary cacheable system memory buffer and
+	 * copy it to AGP memory when ready.
+	 */
+
+		
+	if ((ret = via_verify_command_stream((uint32_t *)dev_priv->pci_buf, cmd->size, dev, 1))) {
+		return ret;
+	}
+       	
+	
+	vb = via_check_dma(dev_priv, (cmd->size < 0x100) ? 0x102 : cmd->size);
+	if (vb == NULL) {
+		return DRM_ERR(EAGAIN);
+	}
+
+	memcpy(vb, dev_priv->pci_buf, cmd->size);
+	
+	dev_priv->dma_low += cmd->size;
+
+	/*
+	 * Small submissions somehow stalls the CPU. (AGP cache effects?)
+	 * pad to greater size.
+	 */
+
+	if (cmd->size < 0x100)
+	  via_pad_cache(dev_priv,(0x100 - cmd->size) >> 3);
+	via_cmdbuf_pause(dev_priv);
+
+	return 0;
+}
+
+int via_driver_dma_quiescent(drm_device_t * dev)
+{
+	drm_via_private_t *dev_priv = dev->dev_private;
+
+	if (!via_wait_idle(dev_priv)) {
+		return DRM_ERR(EBUSY);
+	}
+	return 0;
+}
+
+int via_flush_ioctl(DRM_IOCTL_ARGS)
+{
+	DRM_DEVICE;
+
+	LOCK_TEST_WITH_RETURN( dev, filp );
+
+	return via_driver_dma_quiescent(dev);
+}
+
+int via_cmdbuffer(DRM_IOCTL_ARGS)
+{
+	DRM_DEVICE;
+	drm_via_cmdbuffer_t cmdbuf;
+	int ret;
+
+	LOCK_TEST_WITH_RETURN( dev, filp );
+
+	DRM_COPY_FROM_USER_IOCTL(cmdbuf, (drm_via_cmdbuffer_t *) data,
+				 sizeof(cmdbuf));
+
+	DRM_DEBUG("via cmdbuffer, buf %p size %lu\n", cmdbuf.buf, cmdbuf.size);
+
+	ret = via_dispatch_cmdbuffer(dev, &cmdbuf);
+	if (ret) {
+		return ret;
+	}
+
+	return 0;
+}
+
+extern int 
+via_parse_command_stream(drm_device_t *dev, const uint32_t * buf, unsigned int size);
+static int via_dispatch_pci_cmdbuffer(drm_device_t * dev,
+				      drm_via_cmdbuffer_t * cmd)
+{
+	drm_via_private_t *dev_priv = dev->dev_private;
+	int ret;
+
+	if (cmd->size > VIA_PCI_BUF_SIZE) {
+		return DRM_ERR(ENOMEM);
+	} 
+	if (DRM_COPY_FROM_USER(dev_priv->pci_buf, cmd->buf, cmd->size))
+		return DRM_ERR(EFAULT);
+	
+	if ((ret = via_verify_command_stream((uint32_t *)dev_priv->pci_buf, cmd->size, dev, 0))) {
+		return ret;
+	}
+	
+	ret = via_parse_command_stream(dev, (const uint32_t *)dev_priv->pci_buf, cmd->size);
+	return ret;
+}
+
+int via_pci_cmdbuffer(DRM_IOCTL_ARGS)
+{
+	DRM_DEVICE;
+	drm_via_cmdbuffer_t cmdbuf;
+	int ret;
+
+	LOCK_TEST_WITH_RETURN( dev, filp );
+
+	DRM_COPY_FROM_USER_IOCTL(cmdbuf, (drm_via_cmdbuffer_t *) data,
+				 sizeof(cmdbuf));
+
+	DRM_DEBUG("via_pci_cmdbuffer, buf %p size %lu\n", cmdbuf.buf,
+		  cmdbuf.size);
+
+	ret = via_dispatch_pci_cmdbuffer(dev, &cmdbuf);
+	if (ret) {
+		return ret;
+	}
+
+	return 0;
+}
+
+
+static inline uint32_t *via_align_buffer(drm_via_private_t * dev_priv,
+					 uint32_t * vb, int qw_count)
+{
+        for (; qw_count > 0; --qw_count) {
+		VIA_OUT_RING_QW(HC_DUMMY, HC_DUMMY);
+	}
+	return vb;
+}
+
+
+/*
+ * This function is used internally by ring buffer mangement code.
+ *
+ * Returns virtual pointer to ring buffer.
+ */
+static inline uint32_t *via_get_dma(drm_via_private_t * dev_priv)
+{
+	return (uint32_t *) (dev_priv->dma_ptr + dev_priv->dma_low);
+}
+
+/*
+ * Hooks a segment of data into the tail of the ring-buffer by
+ * modifying the pause address stored in the buffer itself. If
+ * the regulator has already paused, restart it.
+ */
+static int via_hook_segment(drm_via_private_t *dev_priv,
+			    uint32_t pause_addr_hi, uint32_t pause_addr_lo,
+			    int no_pci_fire)
+{
+	int paused, count;
+	volatile uint32_t *paused_at = dev_priv->last_pause_ptr;
+
+	via_flush_write_combine();
+	while(! *(via_get_dma(dev_priv)-1));
+	*dev_priv->last_pause_ptr = pause_addr_lo;
+	via_flush_write_combine();
+
+	/*
+	 * The below statement is inserted to really force the flush.
+	 * Not sure it is needed.
+	 */
+
+	while(! *dev_priv->last_pause_ptr);
+	dev_priv->last_pause_ptr = via_get_dma(dev_priv) - 1;
+	while(! *dev_priv->last_pause_ptr);
+
+
+	paused = 0;
+	count = 20; 
+
+	while (!(paused = (VIA_READ(0x41c) & 0x80000000)) && count--);
+	if ((count <= 8) && (count >= 0)) {
+		uint32_t rgtr, ptr;
+		rgtr = *(dev_priv->hw_addr_ptr);
+		ptr = ((char *)dev_priv->last_pause_ptr - dev_priv->dma_ptr) + 
+			dev_priv->dma_offset + (uint32_t) dev_priv->agpAddr + 4 - 
+			CMDBUF_ALIGNMENT_SIZE;
+		if (rgtr <= ptr) {
+			DRM_ERROR("Command regulator\npaused at count %d, address %x, "
+				  "while current pause address is %x.\n"
+				  "Please mail this message to "
+				  "<unichrome-devel@lists.sourceforge.net>\n",
+				  count, rgtr, ptr);
+		}
+	}
+		
+	if (paused && !no_pci_fire) {
+	        uint32_t rgtr,ptr;
+		uint32_t ptr_low;
+
+		count = 1000000;
+		while ((VIA_READ(VIA_REG_STATUS) & VIA_CMD_RGTR_BUSY) && count--);
+		
+		rgtr = *(dev_priv->hw_addr_ptr);
+		ptr = ((char *)paused_at - dev_priv->dma_ptr) + 
+			dev_priv->dma_offset + (uint32_t) dev_priv->agpAddr + 4;
+		
+
+		ptr_low = (ptr > 3*CMDBUF_ALIGNMENT_SIZE) ? 
+			ptr - 3*CMDBUF_ALIGNMENT_SIZE : 0;
+		if (rgtr <= ptr && rgtr >= ptr_low) {
+			VIA_WRITE(VIA_REG_TRANSET, (HC_ParaType_PreCR << 16));
+			VIA_WRITE(VIA_REG_TRANSPACE, pause_addr_hi);
+			VIA_WRITE(VIA_REG_TRANSPACE, pause_addr_lo);
+		} 
+	}
+	return paused;
+}
+
+
+
+static int via_wait_idle(drm_via_private_t * dev_priv)
+{
+	int count = 10000000;
+	while (count-- && (VIA_READ(VIA_REG_STATUS) &
+			   (VIA_CMD_RGTR_BUSY | VIA_2D_ENG_BUSY |
+			    VIA_3D_ENG_BUSY))) ;
+	return count;
+}
+
+static uint32_t *via_align_cmd(drm_via_private_t * dev_priv, uint32_t cmd_type,
+			       uint32_t addr, uint32_t *cmd_addr_hi, 
+			       uint32_t *cmd_addr_lo,
+			       int skip_wait)
+{
+	uint32_t agp_base;
+	uint32_t cmd_addr, addr_lo, addr_hi;
+	uint32_t *vb;
+	uint32_t qw_pad_count;
+
+	if (!skip_wait)
+		via_cmdbuf_wait(dev_priv, 2*CMDBUF_ALIGNMENT_SIZE);
+
+	vb = via_get_dma(dev_priv);
+	VIA_OUT_RING_QW( HC_HEADER2 | ((VIA_REG_TRANSET >> 2) << 12) |
+			 (VIA_REG_TRANSPACE >> 2), HC_ParaType_PreCR << 16); 
+	agp_base = dev_priv->dma_offset + (uint32_t) dev_priv->agpAddr;
+	qw_pad_count = (CMDBUF_ALIGNMENT_SIZE >> 3) -
+		((dev_priv->dma_low & CMDBUF_ALIGNMENT_MASK) >> 3);
+
+	
+	cmd_addr = (addr) ? addr : 
+		agp_base + dev_priv->dma_low - 8 + (qw_pad_count << 3);
+	addr_lo = ((HC_SubA_HAGPBpL << 24) | (cmd_type & HC_HAGPBpID_MASK) |
+		   (cmd_addr & HC_HAGPBpL_MASK));
+	addr_hi = ((HC_SubA_HAGPBpH << 24) | (cmd_addr >> 24));
+
+	vb = via_align_buffer(dev_priv, vb, qw_pad_count - 1);
+	VIA_OUT_RING_QW(*cmd_addr_hi = addr_hi, 
+			*cmd_addr_lo = addr_lo);
+	return vb;
+}
+
+
+
+
+static void via_cmdbuf_start(drm_via_private_t * dev_priv)
+{
+	uint32_t pause_addr_lo, pause_addr_hi;
+	uint32_t start_addr, start_addr_lo;
+	uint32_t end_addr, end_addr_lo;
+	uint32_t command;
+	uint32_t agp_base;
+
+
+	dev_priv->dma_low = 0;
+
+	agp_base = dev_priv->dma_offset + (uint32_t) dev_priv->agpAddr;
+	start_addr = agp_base;
+	end_addr = agp_base + dev_priv->dma_high;
+
+	start_addr_lo = ((HC_SubA_HAGPBstL << 24) | (start_addr & 0xFFFFFF));
+	end_addr_lo = ((HC_SubA_HAGPBendL << 24) | (end_addr & 0xFFFFFF));
+	command = ((HC_SubA_HAGPCMNT << 24) | (start_addr >> 24) |
+		   ((end_addr & 0xff000000) >> 16));
+
+	dev_priv->last_pause_ptr = 
+		via_align_cmd(dev_priv, HC_HAGPBpID_PAUSE, 0, 
+			      &pause_addr_hi, & pause_addr_lo, 1) - 1;
+
+	via_flush_write_combine();
+	while(! *dev_priv->last_pause_ptr);
+
+	VIA_WRITE(VIA_REG_TRANSET, (HC_ParaType_PreCR << 16));
+	VIA_WRITE(VIA_REG_TRANSPACE, command);
+	VIA_WRITE(VIA_REG_TRANSPACE, start_addr_lo);
+	VIA_WRITE(VIA_REG_TRANSPACE, end_addr_lo);
+
+	VIA_WRITE(VIA_REG_TRANSPACE, pause_addr_hi);
+	VIA_WRITE(VIA_REG_TRANSPACE, pause_addr_lo);
+
+	VIA_WRITE(VIA_REG_TRANSPACE, command | HC_HAGPCMNT_MASK);
+}
+
+static void via_pad_cache(drm_via_private_t *dev_priv, int qwords)
+{
+	uint32_t *vb;
+
+	via_cmdbuf_wait(dev_priv, qwords + 2);
+	vb = via_get_dma(dev_priv);
+	VIA_OUT_RING_QW( HC_HEADER2, HC_ParaType_NotTex << 16);
+	via_align_buffer(dev_priv,vb,qwords);
+}
+
+static inline void via_dummy_bitblt(drm_via_private_t * dev_priv)
+{
+	uint32_t *vb = via_get_dma(dev_priv);
+	SetReg2DAGP(0x0C, (0 | (0 << 16)));
+	SetReg2DAGP(0x10, 0 | (0 << 16));
+	SetReg2DAGP(0x0, 0x1 | 0x2000 | 0xAA000000); 
+}
+
+
+static void via_cmdbuf_jump(drm_via_private_t * dev_priv)
+{
+	uint32_t agp_base;
+	uint32_t pause_addr_lo, pause_addr_hi;
+	uint32_t jump_addr_lo, jump_addr_hi;
+	volatile uint32_t *last_pause_ptr;
+	uint32_t dma_low_save1, dma_low_save2;
+
+	agp_base = dev_priv->dma_offset + (uint32_t) dev_priv->agpAddr;
+	via_align_cmd(dev_priv,  HC_HAGPBpID_JUMP, 0, &jump_addr_hi, 
+		      &jump_addr_lo, 0);
+	
+	dev_priv->dma_wrap = dev_priv->dma_low;
+
+
+	/*
+	 * Wrap command buffer to the beginning.
+	 */
+
+	dev_priv->dma_low = 0;
+	if (via_cmdbuf_wait(dev_priv, CMDBUF_ALIGNMENT_SIZE) != 0) {
+		DRM_ERROR("via_cmdbuf_jump failed\n");
+	}
+
+	via_dummy_bitblt(dev_priv);
+	via_dummy_bitblt(dev_priv); 
+
+	last_pause_ptr = via_align_cmd(dev_priv,  HC_HAGPBpID_PAUSE, 0, &pause_addr_hi, 
+				       &pause_addr_lo, 0) -1;
+	via_align_cmd(dev_priv,  HC_HAGPBpID_PAUSE, 0, &pause_addr_hi, 
+		      &pause_addr_lo, 0);
+
+	*last_pause_ptr = pause_addr_lo;
+	dma_low_save1 = dev_priv->dma_low;
+
+	/*
+	 * Now, set a trap that will pause the regulator if it tries to rerun the old
+	 * command buffer. (Which may happen if via_hook_segment detecs a command regulator pause
+	 * and reissues the jump command over PCI, while the regulator has already taken the jump
+	 * and actually paused at the current buffer end).
+	 * There appears to be no other way to detect this condition, since the hw_addr_pointer
+	 * does not seem to get updated immediately when a jump occurs.
+	 */
+
+	last_pause_ptr = via_align_cmd(dev_priv,  HC_HAGPBpID_PAUSE, 0, &pause_addr_hi, 
+				       &pause_addr_lo, 0) -1;
+	via_align_cmd(dev_priv,  HC_HAGPBpID_PAUSE, 0, &pause_addr_hi, 
+		      &pause_addr_lo, 0);
+	*last_pause_ptr = pause_addr_lo;
+
+	dma_low_save2 = dev_priv->dma_low;
+	dev_priv->dma_low = dma_low_save1;	
+	via_hook_segment( dev_priv, jump_addr_hi, jump_addr_lo, 0);
+	dev_priv->dma_low = dma_low_save2;
+	via_hook_segment( dev_priv, pause_addr_hi, pause_addr_lo, 0);
+}
+
+
+static void via_cmdbuf_rewind(drm_via_private_t * dev_priv)
+{
+	via_cmdbuf_jump(dev_priv); 
+}
+
+static void via_cmdbuf_flush(drm_via_private_t * dev_priv, uint32_t cmd_type)
+{
+	uint32_t pause_addr_lo, pause_addr_hi;
+
+	via_align_cmd(dev_priv, cmd_type, 0, &pause_addr_hi, &pause_addr_lo, 0);
+	via_hook_segment( dev_priv, pause_addr_hi, pause_addr_lo, 0);
+}
+
+
+static void via_cmdbuf_pause(drm_via_private_t * dev_priv)
+{
+	via_cmdbuf_flush(dev_priv, HC_HAGPBpID_PAUSE);
+}
+
+static void via_cmdbuf_reset(drm_via_private_t * dev_priv)
+{
+	via_cmdbuf_flush(dev_priv, HC_HAGPBpID_STOP);
+	via_wait_idle(dev_priv);
+}
+
+/*
+ * User interface to the space and lag functions.
+ */
+
+int 
+via_cmdbuf_size(DRM_IOCTL_ARGS)
+{
+	DRM_DEVICE;
+	drm_via_cmdbuf_size_t d_siz;
+	int ret = 0;
+	uint32_t tmp_size, count;
+	drm_via_private_t *dev_priv;
+
+	DRM_DEBUG("via cmdbuf_size\n");
+	LOCK_TEST_WITH_RETURN( dev, filp );
+
+	dev_priv = (drm_via_private_t *) dev->dev_private;
+
+	if (dev_priv->ring.virtual_start == NULL) {
+		DRM_ERROR("%s called without initializing AGP ring buffer.\n",
+			  __FUNCTION__);
+		return DRM_ERR(EFAULT);
+	}
+
+	DRM_COPY_FROM_USER_IOCTL(d_siz, (drm_via_cmdbuf_size_t *) data,
+				 sizeof(d_siz));
+
+
+	count = 1000000;
+	tmp_size = d_siz.size;
+	switch(d_siz.func) {
+	case VIA_CMDBUF_SPACE:
+		while (((tmp_size = via_cmdbuf_space(dev_priv)) < d_siz.size) && count--) {
+			if (!d_siz.wait) {
+				break;
+			}
+		}
+		if (!count) {
+			DRM_ERROR("VIA_CMDBUF_SPACE timed out.\n");
+			ret = DRM_ERR(EAGAIN);
+		}
+		break;
+	case VIA_CMDBUF_LAG:
+		while (((tmp_size = via_cmdbuf_lag(dev_priv)) > d_siz.size) && count--) {
+			if (!d_siz.wait) {
+				break;
+			}
+		}
+		if (!count) {
+			DRM_ERROR("VIA_CMDBUF_LAG timed out.\n");
+			ret = DRM_ERR(EAGAIN);
+		}
+		break;
+	default:
+		ret = DRM_ERR(EFAULT);
+	}
+	d_siz.size = tmp_size;
+
+	DRM_COPY_TO_USER_IOCTL((drm_via_cmdbuf_size_t *) data, d_siz,
+			       sizeof(d_siz));
+	return ret;
+}
diff -purN linux-2.6.12.orig/drivers/char/drm/via_drm.h linux-2.6.12/drivers/char/drm/via_drm.h
--- linux-2.6.12.orig/drivers/char/drm/via_drm.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/drm/via_drm.h	2005-07-05 08:37:49.000000000 +0200
@@ -0,0 +1,243 @@
+/*
+ * Copyright 1998-2003 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2003 S3 Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * VIA, S3 GRAPHICS, AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+#ifndef _VIA_DRM_H_
+#define _VIA_DRM_H_
+
+/* WARNING: These defines must be the same as what the Xserver uses.
+ * if you change them, you must change the defines in the Xserver.
+ */
+
+#ifndef _VIA_DEFINES_
+#define _VIA_DEFINES_
+
+#ifndef __KERNEL__
+#include "via_drmclient.h"
+#endif
+
+#define VIA_NR_SAREA_CLIPRECTS 		8
+#define VIA_NR_XVMC_PORTS               10
+#define VIA_NR_XVMC_LOCKS               5
+#define VIA_MAX_CACHELINE_SIZE          64
+#define XVMCLOCKPTR(saPriv,lockNo)					\
+	((volatile drm_hw_lock_t *)(((((unsigned long) (saPriv)->XvMCLockArea) + \
+				      (VIA_MAX_CACHELINE_SIZE - 1)) &	\
+				     ~(VIA_MAX_CACHELINE_SIZE - 1)) +	\
+				    VIA_MAX_CACHELINE_SIZE*(lockNo)))
+
+/* Each region is a minimum of 64k, and there are at most 64 of them.
+ */
+#define VIA_NR_TEX_REGIONS 64
+#define VIA_LOG_MIN_TEX_REGION_SIZE 16
+#endif
+
+#define VIA_UPLOAD_TEX0IMAGE  0x1	/* handled clientside */
+#define VIA_UPLOAD_TEX1IMAGE  0x2	/* handled clientside */
+#define VIA_UPLOAD_CTX        0x4
+#define VIA_UPLOAD_BUFFERS    0x8
+#define VIA_UPLOAD_TEX0       0x10
+#define VIA_UPLOAD_TEX1       0x20
+#define VIA_UPLOAD_CLIPRECTS  0x40
+#define VIA_UPLOAD_ALL        0xff
+
+/* VIA specific ioctls */
+#define DRM_VIA_ALLOCMEM	0x00
+#define DRM_VIA_FREEMEM	        0x01
+#define DRM_VIA_AGP_INIT	0x02
+#define DRM_VIA_FB_INIT	        0x03
+#define DRM_VIA_MAP_INIT	0x04
+#define DRM_VIA_DEC_FUTEX       0x05
+#define NOT_USED
+#define DRM_VIA_DMA_INIT	0x07
+#define DRM_VIA_CMDBUFFER	0x08
+#define DRM_VIA_FLUSH	        0x09
+#define DRM_VIA_PCICMD	        0x0a
+#define DRM_VIA_CMDBUF_SIZE	0x0b
+#define NOT_USED
+#define DRM_VIA_WAIT_IRQ        0x0d
+
+#define DRM_IOCTL_VIA_ALLOCMEM	  DRM_IOWR(DRM_COMMAND_BASE + DRM_VIA_ALLOCMEM, drm_via_mem_t)
+#define DRM_IOCTL_VIA_FREEMEM	  DRM_IOW( DRM_COMMAND_BASE + DRM_VIA_FREEMEM, drm_via_mem_t)
+#define DRM_IOCTL_VIA_AGP_INIT	  DRM_IOWR(DRM_COMMAND_BASE + DRM_VIA_AGP_INIT, drm_via_agp_t)
+#define DRM_IOCTL_VIA_FB_INIT	  DRM_IOWR(DRM_COMMAND_BASE + DRM_VIA_FB_INIT, drm_via_fb_t)
+#define DRM_IOCTL_VIA_MAP_INIT	  DRM_IOWR(DRM_COMMAND_BASE + DRM_VIA_MAP_INIT, drm_via_init_t)
+#define DRM_IOCTL_VIA_DEC_FUTEX   DRM_IOW( DRM_COMMAND_BASE + DRM_VIA_DEC_FUTEX, drm_via_futex_t)
+#define DRM_IOCTL_VIA_DMA_INIT	  DRM_IOWR(DRM_COMMAND_BASE + DRM_VIA_DMA_INIT, drm_via_dma_init_t)
+#define DRM_IOCTL_VIA_CMDBUFFER	  DRM_IOW( DRM_COMMAND_BASE + DRM_VIA_CMDBUFFER, drm_via_cmdbuffer_t)
+#define DRM_IOCTL_VIA_FLUSH	  DRM_IO(  DRM_COMMAND_BASE + DRM_VIA_FLUSH)
+#define DRM_IOCTL_VIA_PCICMD	  DRM_IOW( DRM_COMMAND_BASE + DRM_VIA_PCICMD, drm_via_cmdbuffer_t)
+#define DRM_IOCTL_VIA_CMDBUF_SIZE DRM_IOWR( DRM_COMMAND_BASE + DRM_VIA_CMDBUF_SIZE, \
+					    drm_via_cmdbuf_size_t)
+#define DRM_IOCTL_VIA_WAIT_IRQ    DRM_IOWR( DRM_COMMAND_BASE + DRM_VIA_WAIT_IRQ, drm_via_irqwait_t)
+
+/* Indices into buf.Setup where various bits of state are mirrored per
+ * context and per buffer.  These can be fired at the card as a unit,
+ * or in a piecewise fashion as required.
+ */
+
+#define VIA_TEX_SETUP_SIZE 8
+
+/* Flags for clear ioctl
+ */
+#define VIA_FRONT   0x1
+#define VIA_BACK    0x2
+#define VIA_DEPTH   0x4
+#define VIA_STENCIL 0x8
+#define VIDEO 0
+#define AGP 1
+typedef struct {
+	uint32_t offset;
+	uint32_t size;
+} drm_via_agp_t;
+
+typedef struct {
+	uint32_t offset;
+	uint32_t size;
+} drm_via_fb_t;
+
+typedef struct {
+	uint32_t context;
+	uint32_t type;
+	uint32_t size;
+	unsigned long index;
+	unsigned long offset;
+} drm_via_mem_t;
+
+typedef struct _drm_via_init {
+	enum {
+		VIA_INIT_MAP = 0x01,
+		VIA_CLEANUP_MAP = 0x02
+	} func;
+
+	unsigned long sarea_priv_offset;
+	unsigned long fb_offset;
+	unsigned long mmio_offset;
+	unsigned long agpAddr;
+} drm_via_init_t;
+
+typedef struct _drm_via_futex {
+	enum {
+		VIA_FUTEX_WAIT = 0x00,
+		VIA_FUTEX_WAKE = 0X01
+	} func;
+	uint32_t ms;
+	uint32_t lock;
+	uint32_t val;
+} drm_via_futex_t;
+
+typedef struct _drm_via_dma_init {
+	enum {
+		VIA_INIT_DMA = 0x01,
+		VIA_CLEANUP_DMA = 0x02,
+                VIA_DMA_INITIALIZED = 0x03
+	} func;
+
+	unsigned long offset;
+	unsigned long size;
+	unsigned long reg_pause_addr;
+} drm_via_dma_init_t;
+
+typedef struct _drm_via_cmdbuffer {
+	char *buf;
+	unsigned long size;
+} drm_via_cmdbuffer_t;
+
+/* Warning: If you change the SAREA structure you must change the Xserver
+ * structure as well */
+
+typedef struct _drm_via_tex_region {
+	unsigned char next, prev;	/* indices to form a circular LRU  */
+	unsigned char inUse;	/* owned by a client, or free? */
+	int age;		/* tracked by clients to update local LRU's */
+} drm_via_tex_region_t;
+
+typedef struct _drm_via_sarea {
+	unsigned int dirty;
+	unsigned int nbox;
+	drm_clip_rect_t boxes[VIA_NR_SAREA_CLIPRECTS];
+	drm_via_tex_region_t texList[VIA_NR_TEX_REGIONS + 1];
+	int texAge;		/* last time texture was uploaded */
+	int ctxOwner;		/* last context to upload state */
+	int vertexPrim;
+
+	/*
+	 * Below is for XvMC.
+	 * We want the lock integers alone on, and aligned to, a cache line.
+	 * Therefore this somewhat strange construct.
+	 */
+
+	char XvMCLockArea[VIA_MAX_CACHELINE_SIZE * (VIA_NR_XVMC_LOCKS + 1)];
+
+	unsigned int XvMCDisplaying[VIA_NR_XVMC_PORTS];
+	unsigned int XvMCSubPicOn[VIA_NR_XVMC_PORTS];
+	unsigned int XvMCCtxNoGrabbed;	/* Last context to hold decoder */
+
+} drm_via_sarea_t;
+
+typedef struct _drm_via_cmdbuf_size {
+	enum {
+		VIA_CMDBUF_SPACE = 0x01,
+		VIA_CMDBUF_LAG = 0x02
+	} func;
+	int wait;
+	uint32_t size;
+} drm_via_cmdbuf_size_t;
+
+typedef enum {
+	VIA_IRQ_ABSOLUTE = 0x0,
+	VIA_IRQ_RELATIVE = 0x1,
+	VIA_IRQ_SIGNAL = 0x10000000,
+	VIA_IRQ_FORCE_SEQUENCE = 0x20000000
+} via_irq_seq_type_t;
+
+#define VIA_IRQ_FLAGS_MASK 0xF0000000
+
+struct drm_via_wait_irq_request{
+	unsigned irq;
+	via_irq_seq_type_t type;
+	uint32_t sequence;
+	uint32_t signal;
+};
+
+typedef union drm_via_irqwait {
+	struct drm_via_wait_irq_request request;
+	struct drm_wait_vblank_reply reply;
+} drm_via_irqwait_t;
+
+#ifdef __KERNEL__
+
+int via_fb_init(DRM_IOCTL_ARGS);
+int via_mem_alloc(DRM_IOCTL_ARGS);
+int via_mem_free(DRM_IOCTL_ARGS);
+int via_agp_init(DRM_IOCTL_ARGS);
+int via_map_init(DRM_IOCTL_ARGS);
+int via_decoder_futex(DRM_IOCTL_ARGS);
+int via_dma_init(DRM_IOCTL_ARGS);
+int via_cmdbuffer(DRM_IOCTL_ARGS);
+int via_flush_ioctl(DRM_IOCTL_ARGS);
+int via_pci_cmdbuffer(DRM_IOCTL_ARGS);
+int via_cmdbuf_size(DRM_IOCTL_ARGS);
+int via_wait_irq(DRM_IOCTL_ARGS);
+
+#endif
+#endif				/* _VIA_DRM_H_ */
diff -purN linux-2.6.12.orig/drivers/char/drm/via_drv.c linux-2.6.12/drivers/char/drm/via_drv.c
--- linux-2.6.12.orig/drivers/char/drm/via_drv.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/drm/via_drv.c	2005-07-05 08:37:47.000000000 +0200
@@ -0,0 +1,140 @@
+/*
+ * Copyright 1998-2003 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2003 S3 Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * VIA, S3 GRAPHICS, AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include <linux/config.h>
+#include "drmP.h"
+#include "via_drm.h"
+#include "via_drv.h"
+
+#include "drm_pciids.h"
+
+static int postinit(struct drm_device *dev, unsigned long flags)
+{
+	DRM_INFO("Initialized %s %d.%d.%d %s on minor %d: %s\n",
+		 DRIVER_NAME,
+		 DRIVER_MAJOR,
+		 DRIVER_MINOR,
+		 DRIVER_PATCHLEVEL,
+		 DRIVER_DATE, dev->primary.minor, pci_pretty_name(dev->pdev)
+	    );
+	return 0;
+}
+
+static int version(drm_version_t * version)
+{
+	int len;
+
+	version->version_major = DRIVER_MAJOR;
+	version->version_minor = DRIVER_MINOR;
+	version->version_patchlevel = DRIVER_PATCHLEVEL;
+	DRM_COPY(version->name, DRIVER_NAME);
+	DRM_COPY(version->date, DRIVER_DATE);
+	DRM_COPY(version->desc, DRIVER_DESC);
+	return 0;
+}
+
+static int dri_library_name(struct drm_device * dev, char * buf)
+{
+	return snprintf(buf, PAGE_SIZE, "unichrome\n");
+}
+
+static struct pci_device_id pciidlist[] = {
+	viadrv_PCI_IDS
+};
+
+static drm_ioctl_desc_t ioctls[] = {
+	[DRM_IOCTL_NR(DRM_VIA_ALLOCMEM)] = {via_mem_alloc, 1, 0},
+	[DRM_IOCTL_NR(DRM_VIA_FREEMEM)] = {via_mem_free, 1, 0},
+	[DRM_IOCTL_NR(DRM_VIA_AGP_INIT)] = {via_agp_init, 1, 0},
+	[DRM_IOCTL_NR(DRM_VIA_FB_INIT)] = {via_fb_init, 1, 0},
+	[DRM_IOCTL_NR(DRM_VIA_MAP_INIT)] = {via_map_init, 1, 0},
+	[DRM_IOCTL_NR(DRM_VIA_DEC_FUTEX)] = {via_decoder_futex, 1, 0},
+	[DRM_IOCTL_NR(DRM_VIA_DMA_INIT)] = {via_dma_init, 1, 0},
+	[DRM_IOCTL_NR(DRM_VIA_CMDBUFFER)] = {via_cmdbuffer, 1, 0},
+	[DRM_IOCTL_NR(DRM_VIA_FLUSH)] = {via_flush_ioctl, 1, 0},
+	[DRM_IOCTL_NR(DRM_VIA_PCICMD)] = {via_pci_cmdbuffer, 1, 0},
+	[DRM_IOCTL_NR(DRM_VIA_CMDBUF_SIZE)] = {via_cmdbuf_size, 1, 0},
+	[DRM_IOCTL_NR(DRM_VIA_WAIT_IRQ)] = {via_wait_irq, 1, 0}
+};
+
+static int probe(struct pci_dev *pdev, const struct pci_device_id *ent);
+static struct drm_driver driver = {
+	.driver_features =
+	    DRIVER_USE_AGP | DRIVER_USE_MTRR | DRIVER_HAVE_IRQ |
+	    DRIVER_IRQ_SHARED | DRIVER_IRQ_VBL,
+	.context_ctor = via_init_context,
+	.context_dtor = via_final_context,
+	.vblank_wait = via_driver_vblank_wait,
+	.irq_preinstall = via_driver_irq_preinstall,
+	.irq_postinstall = via_driver_irq_postinstall,
+	.irq_uninstall = via_driver_irq_uninstall,
+	.irq_handler = via_driver_irq_handler,
+	.dma_quiescent = via_driver_dma_quiescent,
+	.dri_library_name = dri_library_name,
+	.reclaim_buffers = drm_core_reclaim_buffers,
+	.get_map_ofs = drm_core_get_map_ofs,
+	.get_reg_ofs = drm_core_get_reg_ofs,
+	.postinit = postinit,
+	.version = version,
+	.ioctls = ioctls,
+	.num_ioctls = DRM_ARRAY_SIZE(ioctls),
+	.fops = {
+		.owner = THIS_MODULE,
+		.open = drm_open,
+		.release = drm_release,
+		.ioctl = drm_ioctl,
+		.mmap = drm_mmap,
+		.poll = drm_poll,
+		.fasync = drm_fasync,
+		},
+	.pci_driver = {
+		.name = DRIVER_NAME,
+		.id_table = pciidlist,
+		.probe = probe,
+		.remove = __devexit_p(drm_cleanup_pci),
+	}
+};
+
+static int probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	return drm_get_dev(pdev, ent, &driver);
+}
+
+static int __init via_init(void)
+{
+	via_init_command_verifier();
+	return drm_init(&driver, pciidlist);
+}
+
+static void __exit via_exit(void)
+{
+	drm_exit(&driver);
+}
+
+module_init(via_init);
+module_exit(via_exit);
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL and additional rights");
diff -purN linux-2.6.12.orig/drivers/char/drm/via_drv.h linux-2.6.12/drivers/char/drm/via_drv.h
--- linux-2.6.12.orig/drivers/char/drm/via_drv.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/drm/via_drv.h	2005-07-05 08:37:49.000000000 +0200
@@ -0,0 +1,118 @@
+/*
+ * Copyright 1998-2003 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2003 S3 Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * VIA, S3 GRAPHICS, AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+#ifndef _VIA_DRV_H_
+#define _VIA_DRV_H_
+
+#define DRIVER_AUTHOR	"VIA"
+
+#define DRIVER_NAME		"via"
+#define DRIVER_DESC		"VIA Unichrome / Pro"
+#define DRIVER_DATE		"20050523"
+
+#define DRIVER_MAJOR		2
+#define DRIVER_MINOR		6
+#define DRIVER_PATCHLEVEL	3
+
+#include "via_verifier.h"
+
+#define VIA_PCI_BUF_SIZE 60000
+#define VIA_FIRE_BUF_SIZE  1024
+#define VIA_NUM_IRQS 2
+
+
+
+typedef struct drm_via_ring_buffer {
+	drm_map_t map;
+	char *virtual_start;
+} drm_via_ring_buffer_t;
+
+typedef uint32_t maskarray_t[5];
+
+typedef struct drm_via_irq {
+	atomic_t irq_received;
+	uint32_t pending_mask;
+	uint32_t enable_mask;
+	wait_queue_head_t irq_queue;
+} drm_via_irq_t;
+	
+typedef struct drm_via_private {
+	drm_via_sarea_t *sarea_priv;
+	drm_map_t *sarea;
+	drm_map_t *fb;
+	drm_map_t *mmio;
+	unsigned long agpAddr;
+	wait_queue_head_t decoder_queue[VIA_NR_XVMC_LOCKS];
+	char *dma_ptr;
+	unsigned int dma_low;
+	unsigned int dma_high;
+	unsigned int dma_offset;
+	uint32_t dma_wrap;
+	volatile uint32_t *last_pause_ptr;
+	volatile uint32_t *hw_addr_ptr;
+	drm_via_ring_buffer_t ring;
+        struct timeval last_vblank;
+        int last_vblank_valid;
+        unsigned usec_per_vblank;
+	drm_via_state_t hc_state;
+	char pci_buf[VIA_PCI_BUF_SIZE];
+	const uint32_t *fire_offsets[VIA_FIRE_BUF_SIZE];
+	uint32_t num_fire_offsets;
+	int pro_group_a;
+	drm_via_irq_t via_irqs[VIA_NUM_IRQS];
+	unsigned num_irqs;
+	maskarray_t *irq_masks;
+	uint32_t irq_enable_mask; 
+	uint32_t irq_pending_mask;	
+} drm_via_private_t;
+
+/* VIA MMIO register access */
+#define VIA_BASE ((dev_priv->mmio))
+
+#define VIA_READ(reg)		DRM_READ32(VIA_BASE, reg)
+#define VIA_WRITE(reg,val)	DRM_WRITE32(VIA_BASE, reg, val)
+#define VIA_READ8(reg)		DRM_READ8(VIA_BASE, reg)
+#define VIA_WRITE8(reg,val)	DRM_WRITE8(VIA_BASE, reg, val)
+
+extern int via_init_context(drm_device_t * dev, int context);
+extern int via_final_context(drm_device_t * dev, int context);
+
+extern int via_do_cleanup_map(drm_device_t * dev);
+extern int via_map_init(struct inode *inode, struct file *filp,
+			unsigned int cmd, unsigned long arg);
+extern int via_driver_vblank_wait(drm_device_t * dev, unsigned int *sequence);
+
+extern irqreturn_t via_driver_irq_handler(DRM_IRQ_ARGS);
+extern void via_driver_irq_preinstall(drm_device_t * dev);
+extern void via_driver_irq_postinstall(drm_device_t * dev);
+extern void via_driver_irq_uninstall(drm_device_t * dev);
+
+extern int via_dma_cleanup(drm_device_t * dev);
+extern void via_init_command_verifier(void);
+extern int via_driver_dma_quiescent(drm_device_t * dev);
+extern void via_init_futex(drm_via_private_t *dev_priv);
+extern void via_cleanup_futex(drm_via_private_t *dev_priv);
+extern void via_release_futex(drm_via_private_t *dev_priv, int context);
+
+
+#endif
diff -purN linux-2.6.12.orig/drivers/char/drm/via_ds.c linux-2.6.12/drivers/char/drm/via_ds.c
--- linux-2.6.12.orig/drivers/char/drm/via_ds.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/drm/via_ds.c	2005-07-05 08:37:47.000000000 +0200
@@ -0,0 +1,280 @@
+/*
+ * Copyright 1998-2003 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2003 S3 Graphics, Inc. All Rights Reserved.
+ * Copyright 2000 Silicon Integrated Systems Corp, Inc., HsinChu, Taiwan.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * VIA, S3 GRAPHICS, AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/poll.h>
+#include <linux/pci.h>
+#include <asm/io.h>
+
+#include "via_ds.h"
+extern unsigned int VIA_DEBUG;
+
+set_t *via_setInit(void)
+{
+	int i;
+	set_t *set;
+	set = (set_t *) drm_alloc(sizeof(set_t), DRM_MEM_DRIVER);
+	for (i = 0; i < SET_SIZE; i++) {
+		set->list[i].free_next = i + 1;
+		set->list[i].alloc_next = -1;
+	}
+	set->list[SET_SIZE - 1].free_next = -1;
+	set->free = 0;
+	set->alloc = -1;
+	set->trace = -1;
+	return set;
+}
+
+int via_setAdd(set_t * set, ITEM_TYPE item)
+{
+	int free = set->free;
+	if (free != -1) {
+		set->list[free].val = item;
+		set->free = set->list[free].free_next;
+	} else {
+		return 0;
+	}
+	set->list[free].alloc_next = set->alloc;
+	set->alloc = free;
+	set->list[free].free_next = -1;
+	return 1;
+}
+
+int via_setDel(set_t * set, ITEM_TYPE item)
+{
+	int alloc = set->alloc;
+	int prev = -1;
+
+	while (alloc != -1) {
+		if (set->list[alloc].val == item) {
+			if (prev != -1)
+				set->list[prev].alloc_next =
+				    set->list[alloc].alloc_next;
+			else
+				set->alloc = set->list[alloc].alloc_next;
+			break;
+		}
+		prev = alloc;
+		alloc = set->list[alloc].alloc_next;
+	}
+
+	if (alloc == -1)
+		return 0;
+
+	set->list[alloc].free_next = set->free;
+	set->free = alloc;
+	set->list[alloc].alloc_next = -1;
+
+	return 1;
+}
+
+/* setFirst -> setAdd -> setNext is wrong */
+
+int via_setFirst(set_t * set, ITEM_TYPE * item)
+{
+	if (set->alloc == -1)
+		return 0;
+
+	*item = set->list[set->alloc].val;
+	set->trace = set->list[set->alloc].alloc_next;
+
+	return 1;
+}
+
+int via_setNext(set_t * set, ITEM_TYPE * item)
+{
+	if (set->trace == -1)
+		return 0;
+
+	*item = set->list[set->trace].val;
+	set->trace = set->list[set->trace].alloc_next;
+
+	return 1;
+}
+
+int via_setDestroy(set_t * set)
+{
+	drm_free(set, sizeof(set_t), DRM_MEM_DRIVER);
+
+	return 1;
+}
+
+#define ISFREE(bptr) ((bptr)->free)
+
+#define fprintf(fmt, arg...) do{}while(0)
+
+memHeap_t *via_mmInit(int ofs, int size)
+{
+	PMemBlock blocks;
+
+	if (size <= 0)
+		return 0;
+
+	blocks = (TMemBlock *) drm_calloc(1, sizeof(TMemBlock), DRM_MEM_DRIVER);
+
+	if (blocks) {
+		blocks->ofs = ofs;
+		blocks->size = size;
+		blocks->free = 1;
+		return (memHeap_t *) blocks;
+	} else
+		return 0;
+}
+
+static TMemBlock *SliceBlock(TMemBlock * p,
+			     int startofs, int size,
+			     int reserved, int alignment)
+{
+	TMemBlock *newblock;
+
+	/* break left */
+	if (startofs > p->ofs) {
+		newblock =
+		    (TMemBlock *) drm_calloc(1, sizeof(TMemBlock),
+					     DRM_MEM_DRIVER);
+		newblock->ofs = startofs;
+		newblock->size = p->size - (startofs - p->ofs);
+		newblock->free = 1;
+		newblock->next = p->next;
+		p->size -= newblock->size;
+		p->next = newblock;
+		p = newblock;
+	}
+
+	/* break right */
+	if (size < p->size) {
+		newblock =
+		    (TMemBlock *) drm_calloc(1, sizeof(TMemBlock),
+					     DRM_MEM_DRIVER);
+		newblock->ofs = startofs + size;
+		newblock->size = p->size - size;
+		newblock->free = 1;
+		newblock->next = p->next;
+		p->size = size;
+		p->next = newblock;
+	}
+
+	/* p = middle block */
+	p->align = alignment;
+	p->free = 0;
+	p->reserved = reserved;
+	return p;
+}
+
+PMemBlock via_mmAllocMem(memHeap_t * heap, int size, int align2,
+			 int startSearch)
+{
+	int mask, startofs, endofs;
+	TMemBlock *p;
+
+	if (!heap || align2 < 0 || size <= 0)
+		return NULL;
+
+	mask = (1 << align2) - 1;
+	startofs = 0;
+	p = (TMemBlock *) heap;
+
+	while (p) {
+		if (ISFREE(p)) {
+			startofs = (p->ofs + mask) & ~mask;
+
+			if (startofs < startSearch)
+				startofs = startSearch;
+
+			endofs = startofs + size;
+
+			if (endofs <= (p->ofs + p->size))
+				break;
+		}
+
+		p = p->next;
+	}
+
+	if (!p)
+		return NULL;
+
+	p = SliceBlock(p, startofs, size, 0, mask + 1);
+	p->heap = heap;
+
+	return p;
+}
+
+static __inline__ int Join2Blocks(TMemBlock * p)
+{
+	if (p->free && p->next && p->next->free) {
+		TMemBlock *q = p->next;
+		p->size += q->size;
+		p->next = q->next;
+		drm_free(q, sizeof(TMemBlock), DRM_MEM_DRIVER);
+
+		return 1;
+	}
+
+	return 0;
+}
+
+int via_mmFreeMem(PMemBlock b)
+{
+	TMemBlock *p, *prev;
+
+	if (!b)
+		return 0;
+
+	if (!b->heap) {
+		fprintf(stderr, "no heap\n");
+
+		return -1;
+	}
+
+	p = b->heap;
+	prev = NULL;
+
+	while (p && p != b) {
+		prev = p;
+		p = p->next;
+	}
+
+	if (!p || p->free || p->reserved) {
+		if (!p)
+			fprintf(stderr, "block not found in heap\n");
+		else if (p->free)
+			fprintf(stderr, "block already free\n");
+		else
+			fprintf(stderr, "block is reserved\n");
+
+		return -1;
+	}
+
+	p->free = 1;
+	Join2Blocks(p);
+
+	if (prev)
+		Join2Blocks(prev);
+
+	return 0;
+}
diff -purN linux-2.6.12.orig/drivers/char/drm/via_ds.h linux-2.6.12/drivers/char/drm/via_ds.h
--- linux-2.6.12.orig/drivers/char/drm/via_ds.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/drm/via_ds.h	2005-07-05 08:37:49.000000000 +0200
@@ -0,0 +1,104 @@
+/*
+ * Copyright 1998-2003 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2003 S3 Graphics, Inc. All Rights Reserved.
+ * Copyright 2000 Silicon Integrated Systems Corp, Inc., HsinChu, Taiwan.
+ * All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * VIA, S3 GRAPHICS, AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+#ifndef _via_ds_h_
+#define _via_ds_h_
+
+#include "drmP.h"
+
+/* Set Data Structure */
+#define SET_SIZE 5000
+typedef unsigned long ITEM_TYPE;
+
+typedef struct {
+	ITEM_TYPE val;
+	int alloc_next, free_next;
+} list_item_t;
+
+typedef struct {
+	int alloc;
+	int free;
+	int trace;
+	list_item_t list[SET_SIZE];
+} set_t;
+
+set_t *via_setInit(void);
+int via_setAdd(set_t * set, ITEM_TYPE item);
+int via_setDel(set_t * set, ITEM_TYPE item);
+int via_setFirst(set_t * set, ITEM_TYPE * item);
+int via_setNext(set_t * set, ITEM_TYPE * item);
+int via_setDestroy(set_t * set);
+
+#endif
+
+#ifndef MM_INC
+#define MM_INC
+
+struct mem_block_t {
+	struct mem_block_t *next;
+	struct mem_block_t *heap;
+	int ofs, size;
+	int align;
+	int free:1;
+	int reserved:1;
+};
+typedef struct mem_block_t TMemBlock;
+typedef struct mem_block_t *PMemBlock;
+
+/* a heap is just the first block in a chain */
+typedef struct mem_block_t memHeap_t;
+
+static __inline__ int mmBlockSize(PMemBlock b)
+{
+	return b->size;
+}
+
+static __inline__ int mmOffset(PMemBlock b)
+{
+	return b->ofs;
+}
+
+static __inline__ void mmMarkReserved(PMemBlock b)
+{
+	b->reserved = 1;
+}
+
+/*
+ * input: total size in bytes
+ * return: a heap pointer if OK, NULL if error
+ */
+memHeap_t *via_mmInit(int ofs, int size);
+
+PMemBlock via_mmAllocMem(memHeap_t * heap, int size, int align2,
+			 int startSearch);
+
+/*
+ * Free block starts at offset
+ * input: pointer to a block
+ * return: 0 if OK, -1 if error
+ */
+int via_mmFreeMem(PMemBlock b);
+
+#endif
diff -purN linux-2.6.12.orig/drivers/char/drm/via_irq.c linux-2.6.12/drivers/char/drm/via_irq.c
--- linux-2.6.12.orig/drivers/char/drm/via_irq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/drm/via_irq.c	2005-07-05 08:37:47.000000000 +0200
@@ -0,0 +1,339 @@
+/* via_irq.c
+ *
+ * Copyright 2004 BEAM Ltd.
+ * Copyright 2002 Tungsten Graphics, Inc.
+ * Copyright 2005 Thomas Hellstrom.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * BEAM LTD, TUNGSTEN GRAPHICS  AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Terry Barnaby <terry1@beam.ltd.uk>
+ *    Keith Whitwell <keith@tungstengraphics.com>
+ *    Thomas Hellstrom <unichrome@shipmail.org>
+ *
+ * This code provides standard DRM access to the Via Unichrome / Pro Vertical blank
+ * interrupt, as well as an infrastructure to handle other interrupts of the chip.
+ * The refresh rate is also calculated for video playback sync purposes.
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "via_drm.h"
+#include "via_drv.h"
+
+#define VIA_REG_INTERRUPT       0x200
+
+/* VIA_REG_INTERRUPT */
+#define VIA_IRQ_GLOBAL          (1 << 31)
+#define VIA_IRQ_VBLANK_ENABLE   (1 << 19)
+#define VIA_IRQ_VBLANK_PENDING  (1 << 3)
+#define VIA_IRQ_HQV0_ENABLE     (1 << 11)
+#define VIA_IRQ_HQV1_ENABLE     (1 << 25)
+#define VIA_IRQ_HQV0_PENDING    (1 << 9)
+#define VIA_IRQ_HQV1_PENDING    (1 << 10)
+
+/*
+ * Device-specific IRQs go here. This type might need to be extended with
+ * the register if there are multiple IRQ control registers.
+ * Currently we activate the HQV interrupts of  Unichrome Pro group A. 
+ */
+
+static maskarray_t via_pro_group_a_irqs[] = {
+	{VIA_IRQ_HQV0_ENABLE, VIA_IRQ_HQV0_PENDING, 0x000003D0, 0x00008010, 0x00000000 },
+	{VIA_IRQ_HQV1_ENABLE, VIA_IRQ_HQV1_PENDING, 0x000013D0, 0x00008010, 0x00000000 }};
+static int via_num_pro_group_a = sizeof(via_pro_group_a_irqs)/sizeof(maskarray_t);
+
+static maskarray_t via_unichrome_irqs[] = {};
+static int via_num_unichrome = sizeof(via_unichrome_irqs)/sizeof(maskarray_t);
+
+
+static unsigned time_diff(struct timeval *now,struct timeval *then) 
+{
+    return (now->tv_usec >= then->tv_usec) ?
+        now->tv_usec - then->tv_usec :
+        1000000 - (then->tv_usec - now->tv_usec);
+}
+
+irqreturn_t via_driver_irq_handler(DRM_IRQ_ARGS)
+{
+	drm_device_t *dev = (drm_device_t *) arg;
+	drm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;
+	u32 status;
+	int handled = 0;
+	struct timeval cur_vblank;
+	drm_via_irq_t *cur_irq = dev_priv->via_irqs;
+	int i;
+
+	status = VIA_READ(VIA_REG_INTERRUPT);
+	if (status & VIA_IRQ_VBLANK_PENDING) {
+		atomic_inc(&dev->vbl_received);
+                if (!(atomic_read(&dev->vbl_received) & 0x0F)) {
+			do_gettimeofday(&cur_vblank);
+                        if (dev_priv->last_vblank_valid) {
+				dev_priv->usec_per_vblank = 
+					time_diff( &cur_vblank,&dev_priv->last_vblank) >> 4;
+			}
+			dev_priv->last_vblank = cur_vblank;
+			dev_priv->last_vblank_valid = 1;
+                }
+                if (!(atomic_read(&dev->vbl_received) & 0xFF)) {
+			DRM_DEBUG("US per vblank is: %u\n",
+				dev_priv->usec_per_vblank);
+		}
+		DRM_WAKEUP(&dev->vbl_queue);
+		drm_vbl_send_signals(dev);
+		handled = 1;
+	}
+	
+
+	for (i=0; i<dev_priv->num_irqs; ++i) {
+		if (status & cur_irq->pending_mask) {
+			atomic_inc( &cur_irq->irq_received );
+			DRM_WAKEUP( &cur_irq->irq_queue );
+			handled = 1;
+		}
+		cur_irq++;
+	}
+	
+	/* Acknowlege interrupts */
+	VIA_WRITE(VIA_REG_INTERRUPT, status);
+
+
+	if (handled)
+		return IRQ_HANDLED;
+	else
+		return IRQ_NONE;
+}
+
+static __inline__ void viadrv_acknowledge_irqs(drm_via_private_t * dev_priv)
+{
+	u32 status;
+
+	if (dev_priv) {
+		/* Acknowlege interrupts */
+		status = VIA_READ(VIA_REG_INTERRUPT);
+		VIA_WRITE(VIA_REG_INTERRUPT, status | 
+			  dev_priv->irq_pending_mask);
+	}
+}
+
+int via_driver_vblank_wait(drm_device_t * dev, unsigned int *sequence)
+{
+	drm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;
+	unsigned int cur_vblank;
+	int ret = 0;
+
+	DRM_DEBUG("viadrv_vblank_wait\n");
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	viadrv_acknowledge_irqs(dev_priv);
+
+	/* Assume that the user has missed the current sequence number
+	 * by about a day rather than she wants to wait for years
+	 * using vertical blanks...
+	 */
+
+	DRM_WAIT_ON(ret, dev->vbl_queue, 3 * DRM_HZ,
+		    (((cur_vblank = atomic_read(&dev->vbl_received)) -
+		      *sequence) <= (1 << 23)));
+	
+	*sequence = cur_vblank;
+	return ret;
+}
+
+static int 
+via_driver_irq_wait(drm_device_t * dev, unsigned int irq, int force_sequence,
+		    unsigned int *sequence)
+{
+	drm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;
+	unsigned int cur_irq_sequence;
+	drm_via_irq_t *cur_irq = dev_priv->via_irqs;
+	int ret = 0;
+	maskarray_t *masks = dev_priv->irq_masks;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return DRM_ERR(EINVAL);
+	}
+
+	if (irq >= dev_priv->num_irqs ) {
+		DRM_ERROR("%s Trying to wait on unknown irq %d\n", __FUNCTION__, irq);
+		return DRM_ERR(EINVAL);
+	}
+		
+	cur_irq += irq;
+
+	if (masks[irq][2] && !force_sequence) {
+		DRM_WAIT_ON(ret, cur_irq->irq_queue, 3 * DRM_HZ,
+			    ((VIA_READ(masks[irq][2]) & masks[irq][3]) == masks[irq][4]));
+		cur_irq_sequence = atomic_read(&cur_irq->irq_received);
+	} else {
+		DRM_WAIT_ON(ret, cur_irq->irq_queue, 3 * DRM_HZ,
+			    (((cur_irq_sequence = atomic_read(&cur_irq->irq_received)) -
+			      *sequence) <= (1 << 23)));		
+	}
+	*sequence = cur_irq_sequence;
+	return ret;
+}
+
+
+/*
+ * drm_dma.h hooks
+ */
+
+void via_driver_irq_preinstall(drm_device_t * dev)
+{
+	drm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;
+	u32 status;
+	drm_via_irq_t *cur_irq = dev_priv->via_irqs;
+	int i;
+
+	DRM_DEBUG("driver_irq_preinstall: dev_priv: %p\n", dev_priv);
+	if (dev_priv) {
+
+		dev_priv->irq_enable_mask = VIA_IRQ_VBLANK_ENABLE;
+		dev_priv->irq_pending_mask = VIA_IRQ_VBLANK_PENDING;
+
+		dev_priv->irq_masks = (dev_priv->pro_group_a) ?
+			via_pro_group_a_irqs : via_unichrome_irqs;
+		dev_priv->num_irqs = (dev_priv->pro_group_a) ?
+			via_num_pro_group_a : via_num_unichrome;
+		
+		for(i=0; i < dev_priv->num_irqs; ++i) {
+			atomic_set(&cur_irq->irq_received, 0);
+			cur_irq->enable_mask = dev_priv->irq_masks[i][0]; 
+			cur_irq->pending_mask = dev_priv->irq_masks[i][1];
+			DRM_INIT_WAITQUEUE( &cur_irq->irq_queue );
+			dev_priv->irq_enable_mask |= cur_irq->enable_mask;
+			dev_priv->irq_pending_mask |= cur_irq->pending_mask;
+			cur_irq++;
+			
+			DRM_DEBUG("Initializing IRQ %d\n", i);
+		}
+			
+	        dev_priv->last_vblank_valid = 0;
+
+		// Clear VSync interrupt regs
+		status = VIA_READ(VIA_REG_INTERRUPT);
+		VIA_WRITE(VIA_REG_INTERRUPT, status & 
+			  ~(dev_priv->irq_enable_mask));
+		
+		/* Clear bits if they're already high */
+		viadrv_acknowledge_irqs(dev_priv);
+	}
+}
+
+void via_driver_irq_postinstall(drm_device_t * dev)
+{
+	drm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;
+	u32 status;
+
+	DRM_DEBUG("via_driver_irq_postinstall\n");
+	if (dev_priv) {
+		status = VIA_READ(VIA_REG_INTERRUPT);
+		VIA_WRITE(VIA_REG_INTERRUPT, status | VIA_IRQ_GLOBAL
+			  | dev_priv->irq_enable_mask);
+
+		/* Some magic, oh for some data sheets ! */
+
+		VIA_WRITE8(0x83d4, 0x11);
+		VIA_WRITE8(0x83d5, VIA_READ8(0x83d5) | 0x30);
+		
+	}
+}
+
+void via_driver_irq_uninstall(drm_device_t * dev)
+{
+	drm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;
+	u32 status;
+
+	DRM_DEBUG("driver_irq_uninstall)\n");
+	if (dev_priv) {
+
+		/* Some more magic, oh for some data sheets ! */
+
+		VIA_WRITE8(0x83d4, 0x11);
+		VIA_WRITE8(0x83d5, VIA_READ8(0x83d5) & ~0x30);
+
+		status = VIA_READ(VIA_REG_INTERRUPT);
+		VIA_WRITE(VIA_REG_INTERRUPT, status & 
+			  ~(VIA_IRQ_VBLANK_ENABLE | dev_priv->irq_enable_mask));
+	}
+}
+
+int via_wait_irq(DRM_IOCTL_ARGS)
+{
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
+	drm_via_irqwait_t __user *argp = (void __user *)data;
+	drm_via_irqwait_t irqwait;
+	struct timeval now;
+	int ret = 0;
+	drm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;
+	drm_via_irq_t *cur_irq = dev_priv->via_irqs;
+	int force_sequence;
+
+	if (!dev->irq)
+		return DRM_ERR(EINVAL);
+
+	DRM_COPY_FROM_USER_IOCTL(irqwait, argp, sizeof(irqwait));
+	if (irqwait.request.irq >= dev_priv->num_irqs) {
+		DRM_ERROR("%s Trying to wait on unknown irq %d\n", __FUNCTION__, 
+			  irqwait.request.irq);
+		return DRM_ERR(EINVAL);
+	}
+
+	cur_irq += irqwait.request.irq;
+
+	switch (irqwait.request.type & ~VIA_IRQ_FLAGS_MASK) {
+	case VIA_IRQ_RELATIVE:
+		irqwait.request.sequence += atomic_read(&cur_irq->irq_received);
+		irqwait.request.type &= ~_DRM_VBLANK_RELATIVE;
+	case VIA_IRQ_ABSOLUTE:
+		break;
+	default:
+		return DRM_ERR(EINVAL);
+	}
+
+	if (irqwait.request.type & VIA_IRQ_SIGNAL) {
+		DRM_ERROR("%s Signals on Via IRQs not implemented yet.\n", 
+			  __FUNCTION__);
+		return DRM_ERR(EINVAL);
+	}
+
+	force_sequence = (irqwait.request.type & VIA_IRQ_FORCE_SEQUENCE);
+
+	ret = via_driver_irq_wait(dev, irqwait.request.irq, force_sequence,
+				  &irqwait.request.sequence);
+	do_gettimeofday(&now);
+	irqwait.reply.tval_sec = now.tv_sec;
+	irqwait.reply.tval_usec = now.tv_usec;
+
+	DRM_COPY_TO_USER_IOCTL(argp, irqwait, sizeof(irqwait));
+
+	return ret;
+}
diff -purN linux-2.6.12.orig/drivers/char/drm/via_map.c linux-2.6.12/drivers/char/drm/via_map.c
--- linux-2.6.12.orig/drivers/char/drm/via_map.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/drm/via_map.c	2005-07-05 08:37:47.000000000 +0200
@@ -0,0 +1,110 @@
+/*
+ * Copyright 1998-2003 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2003 S3 Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * VIA, S3 GRAPHICS, AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+#include "drmP.h"
+#include "via_drm.h"
+#include "via_drv.h"
+
+static int via_do_init_map(drm_device_t * dev, drm_via_init_t * init)
+{
+	drm_via_private_t *dev_priv;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	dev_priv = drm_alloc(sizeof(drm_via_private_t), DRM_MEM_DRIVER);
+	if (dev_priv == NULL)
+		return -ENOMEM;
+
+	memset(dev_priv, 0, sizeof(drm_via_private_t));
+
+	DRM_GETSAREA();
+	if (!dev_priv->sarea) {
+		DRM_ERROR("could not find sarea!\n");
+		dev->dev_private = (void *)dev_priv;
+		via_do_cleanup_map(dev);
+		return -EINVAL;
+	}
+
+	dev_priv->fb = drm_core_findmap(dev, init->fb_offset);
+	if (!dev_priv->fb) {
+		DRM_ERROR("could not find framebuffer!\n");
+		dev->dev_private = (void *)dev_priv;
+		via_do_cleanup_map(dev);
+		return -EINVAL;
+	}
+	dev_priv->mmio = drm_core_findmap(dev, init->mmio_offset);
+	if (!dev_priv->mmio) {
+		DRM_ERROR("could not find mmio region!\n");
+		dev->dev_private = (void *)dev_priv;
+		via_do_cleanup_map(dev);
+		return -EINVAL;
+	}
+
+	dev_priv->sarea_priv =
+	    (drm_via_sarea_t *) ((u8 *) dev_priv->sarea->handle +
+				 init->sarea_priv_offset);
+
+	dev_priv->agpAddr = init->agpAddr;
+
+	via_init_futex( dev_priv );
+	dev_priv->pro_group_a = (dev->pdev->device == 0x3118);
+
+	dev->dev_private = (void *)dev_priv;
+	return 0;
+}
+
+int via_do_cleanup_map(drm_device_t * dev)
+{
+	if (dev->dev_private) {
+
+		drm_via_private_t *dev_priv = dev->dev_private;
+
+		via_dma_cleanup(dev);
+
+		drm_free(dev_priv, sizeof(drm_via_private_t), DRM_MEM_DRIVER);
+		dev->dev_private = NULL;
+	}
+
+	return 0;
+}
+
+int via_map_init(DRM_IOCTL_ARGS)
+{
+	DRM_DEVICE;
+	drm_via_init_t init;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	DRM_COPY_FROM_USER_IOCTL(init, (drm_via_init_t *) data, sizeof(init));
+
+	switch (init.func) {
+	case VIA_INIT_MAP:
+		return via_do_init_map(dev, &init);
+	case VIA_CLEANUP_MAP:
+		return via_do_cleanup_map(dev);
+	}
+
+	return -EINVAL;
+}
+
+
diff -purN linux-2.6.12.orig/drivers/char/drm/via_mm.c linux-2.6.12/drivers/char/drm/via_mm.c
--- linux-2.6.12.orig/drivers/char/drm/via_mm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/drm/via_mm.c	2005-07-05 08:37:47.000000000 +0200
@@ -0,0 +1,358 @@
+/*
+ * Copyright 1998-2003 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2003 S3 Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * VIA, S3 GRAPHICS, AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+#include "drmP.h"
+#include "via_drm.h"
+#include "via_drv.h"
+#include "via_ds.h"
+#include "via_mm.h"
+
+#define MAX_CONTEXT 100
+
+typedef struct {
+	int used;
+	int context;
+	set_t *sets[2];		/* 0 for frame buffer, 1 for AGP , 2 for System */
+} via_context_t;
+
+static via_context_t global_ppriv[MAX_CONTEXT];
+
+static int via_agp_alloc(drm_via_mem_t * mem);
+static int via_agp_free(drm_via_mem_t * mem);
+static int via_fb_alloc(drm_via_mem_t * mem);
+static int via_fb_free(drm_via_mem_t * mem);
+
+static int add_alloc_set(int context, int type, unsigned int val)
+{
+	int i, retval = 0;
+
+	for (i = 0; i < MAX_CONTEXT; i++) {
+		if (global_ppriv[i].used && global_ppriv[i].context == context) {
+			retval = via_setAdd(global_ppriv[i].sets[type], val);
+			break;
+		}
+	}
+
+	return retval;
+}
+
+static int del_alloc_set(int context, int type, unsigned int val)
+{
+	int i, retval = 0;
+
+	for (i = 0; i < MAX_CONTEXT; i++)
+		if (global_ppriv[i].used && global_ppriv[i].context == context) {
+			retval = via_setDel(global_ppriv[i].sets[type], val);
+			break;
+		}
+
+	return retval;
+}
+
+/* agp memory management */
+static memHeap_t *AgpHeap = NULL;
+
+int via_agp_init(DRM_IOCTL_ARGS)
+{
+	drm_via_agp_t agp;
+
+	DRM_COPY_FROM_USER_IOCTL(agp, (drm_via_agp_t *) data, sizeof(agp));
+
+	AgpHeap = via_mmInit(agp.offset, agp.size);
+
+	DRM_DEBUG("offset = %lu, size = %lu", (unsigned long)agp.offset, (unsigned long)agp.size);
+
+	return 0;
+}
+
+/* fb memory management */
+static memHeap_t *FBHeap = NULL;
+
+int via_fb_init(DRM_IOCTL_ARGS)
+{
+	drm_via_fb_t fb;
+
+	DRM_COPY_FROM_USER_IOCTL(fb, (drm_via_fb_t *) data, sizeof(fb));
+
+	FBHeap = via_mmInit(fb.offset, fb.size);
+
+	DRM_DEBUG("offset = %lu, size = %lu", (unsigned long)fb.offset, (unsigned long)fb.size);
+
+	return 0;
+}
+
+int via_init_context(struct drm_device *dev, int context)
+{
+	int i;
+
+	for (i = 0; i < MAX_CONTEXT; i++)
+		if (global_ppriv[i].used &&
+		    (global_ppriv[i].context == context))
+			break;
+
+	if (i >= MAX_CONTEXT) {
+		for (i = 0; i < MAX_CONTEXT; i++) {
+			if (!global_ppriv[i].used) {
+				global_ppriv[i].context = context;
+				global_ppriv[i].used = 1;
+				global_ppriv[i].sets[0] = via_setInit();
+				global_ppriv[i].sets[1] = via_setInit();
+				DRM_DEBUG("init allocation set, socket=%d,"
+					  " context = %d\n", i, context);
+				break;
+			}
+		}
+
+		if ((i >= MAX_CONTEXT) || (global_ppriv[i].sets[0] == NULL) ||
+		    (global_ppriv[i].sets[1] == NULL)) {
+			return 0;
+		}
+	}
+
+	return 1;
+}
+
+int via_final_context(struct drm_device *dev, int context)
+{	
+        int i;
+	drm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;
+
+	for (i = 0; i < MAX_CONTEXT; i++)
+		if (global_ppriv[i].used &&
+		    (global_ppriv[i].context == context))
+			break;
+
+	if (i < MAX_CONTEXT) {
+		set_t *set;
+		ITEM_TYPE item;
+		int retval;
+
+		DRM_DEBUG("find socket %d, context = %d\n", i, context);
+
+		/* Video Memory */
+		set = global_ppriv[i].sets[0];
+		retval = via_setFirst(set, &item);
+		while (retval) {
+			DRM_DEBUG("free video memory 0x%lx\n", item);
+			via_mmFreeMem((PMemBlock) item);
+			retval = via_setNext(set, &item);
+		}
+		via_setDestroy(set);
+
+		/* AGP Memory */
+		set = global_ppriv[i].sets[1];
+		retval = via_setFirst(set, &item);
+		while (retval) {
+			DRM_DEBUG("free agp memory 0x%lx\n", item);
+			via_mmFreeMem((PMemBlock) item);
+			retval = via_setNext(set, &item);
+		}
+		via_setDestroy(set);
+		global_ppriv[i].used = 0;
+	}
+	via_release_futex(dev_priv, context); 
+	
+			
+#if defined(__linux__)
+	/* Linux specific until context tracking code gets ported to BSD */
+	/* Last context, perform cleanup */
+	if (dev->ctx_count == 1 && dev->dev_private) {
+	        DRM_DEBUG("Last Context\n");
+		if (dev->irq)
+			drm_irq_uninstall(dev);
+
+		via_cleanup_futex(dev_priv);
+		via_do_cleanup_map(dev);
+	}
+#endif
+
+	return 1;
+}
+
+int via_mem_alloc(DRM_IOCTL_ARGS)
+{
+	drm_via_mem_t mem;
+
+	DRM_COPY_FROM_USER_IOCTL(mem, (drm_via_mem_t *) data, sizeof(mem));
+
+	switch (mem.type) {
+	case VIDEO:
+		if (via_fb_alloc(&mem) < 0)
+			return -EFAULT;
+		DRM_COPY_TO_USER_IOCTL((drm_via_mem_t *) data, mem,
+				       sizeof(mem));
+		return 0;
+	case AGP:
+		if (via_agp_alloc(&mem) < 0)
+			return -EFAULT;
+		DRM_COPY_TO_USER_IOCTL((drm_via_mem_t *) data, mem,
+				       sizeof(mem));
+		return 0;
+	}
+
+	return -EFAULT;
+}
+
+static int via_fb_alloc(drm_via_mem_t * mem)
+{
+	drm_via_mm_t fb;
+	PMemBlock block;
+	int retval = 0;
+
+	if (!FBHeap)
+		return -1;
+
+	fb.size = mem->size;
+	fb.context = mem->context;
+
+	block = via_mmAllocMem(FBHeap, fb.size, 5, 0);
+	if (block) {
+		fb.offset = block->ofs;
+		fb.free = (unsigned long)block;
+		if (!add_alloc_set(fb.context, VIDEO, fb.free)) {
+			DRM_DEBUG("adding to allocation set fails\n");
+			via_mmFreeMem((PMemBlock) fb.free);
+			retval = -1;
+		}
+	} else {
+		fb.offset = 0;
+		fb.size = 0;
+		fb.free = 0;
+		retval = -1;
+	}
+
+	mem->offset = fb.offset;
+	mem->index = fb.free;
+
+	DRM_DEBUG("alloc fb, size = %d, offset = %d\n", fb.size,
+		  (int)fb.offset);
+
+	return retval;
+}
+
+static int via_agp_alloc(drm_via_mem_t * mem)
+{
+	drm_via_mm_t agp;
+	PMemBlock block;
+	int retval = 0;
+
+	if (!AgpHeap)
+		return -1;
+
+	agp.size = mem->size;
+	agp.context = mem->context;
+
+	block = via_mmAllocMem(AgpHeap, agp.size, 5, 0);
+	if (block) {
+		agp.offset = block->ofs;
+		agp.free = (unsigned long)block;
+		if (!add_alloc_set(agp.context, AGP, agp.free)) {
+			DRM_DEBUG("adding to allocation set fails\n");
+			via_mmFreeMem((PMemBlock) agp.free);
+			retval = -1;
+		}
+	} else {
+		agp.offset = 0;
+		agp.size = 0;
+		agp.free = 0;
+	}
+
+	mem->offset = agp.offset;
+	mem->index = agp.free;
+
+	DRM_DEBUG("alloc agp, size = %d, offset = %d\n", agp.size,
+		  (unsigned int)agp.offset);
+	return retval;
+}
+
+int via_mem_free(DRM_IOCTL_ARGS)
+{
+	drm_via_mem_t mem;
+
+	DRM_COPY_FROM_USER_IOCTL(mem, (drm_via_mem_t *) data, sizeof(mem));
+
+	switch (mem.type) {
+
+	case VIDEO:
+		if (via_fb_free(&mem) == 0)
+			return 0;
+		break;
+	case AGP:
+		if (via_agp_free(&mem) == 0)
+			return 0;
+		break;
+	}
+
+	return -EFAULT;
+}
+
+static int via_fb_free(drm_via_mem_t * mem)
+{
+	drm_via_mm_t fb;
+	int retval = 0;
+
+	if (!FBHeap) {
+		return -1;
+	}
+
+	fb.free = mem->index;
+	fb.context = mem->context;
+
+	if (!fb.free) {
+		return -1;
+
+	}
+
+	via_mmFreeMem((PMemBlock) fb.free);
+
+	if (!del_alloc_set(fb.context, VIDEO, fb.free)) {
+		retval = -1;
+	}
+
+	DRM_DEBUG("free fb, free = %ld\n", fb.free);
+
+	return retval;
+}
+
+static int via_agp_free(drm_via_mem_t * mem)
+{
+	drm_via_mm_t agp;
+
+	int retval = 0;
+
+	agp.free = mem->index;
+	agp.context = mem->context;
+
+	if (!agp.free)
+		return -1;
+
+	via_mmFreeMem((PMemBlock) agp.free);
+
+	if (!del_alloc_set(agp.context, AGP, agp.free)) {
+		retval = -1;
+	}
+
+	DRM_DEBUG("free agp, free = %ld\n", agp.free);
+
+	return retval;
+}
diff -purN linux-2.6.12.orig/drivers/char/drm/via_mm.h linux-2.6.12/drivers/char/drm/via_mm.h
--- linux-2.6.12.orig/drivers/char/drm/via_mm.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/drm/via_mm.h	2005-07-05 08:37:49.000000000 +0200
@@ -0,0 +1,40 @@
+/*
+ * Copyright 1998-2003 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2003 S3 Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * VIA, S3 GRAPHICS, AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+#ifndef _via_drm_mm_h_
+#define _via_drm_mm_h_
+
+typedef struct {
+	unsigned int context;
+	unsigned int size;
+	unsigned long offset;
+	unsigned long free;
+} drm_via_mm_t;
+
+typedef struct {
+	unsigned int size;
+	unsigned long handle;
+	void *virtual;
+} drm_via_dma_t;
+
+#endif
diff -purN linux-2.6.12.orig/drivers/char/drm/via_verifier.c linux-2.6.12/drivers/char/drm/via_verifier.c
--- linux-2.6.12.orig/drivers/char/drm/via_verifier.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/drm/via_verifier.c	2005-07-05 08:37:47.000000000 +0200
@@ -0,0 +1,1061 @@
+/*
+ * Copyright 2004 The Unichrome Project. All Rights Reserved.
+ * Copyright 2005 Thomas Hellstrom. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHOR(S), AND/OR THE COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Thomas Hellstrom 2004, 2005.
+ * This code was written using docs obtained under NDA from VIA Inc.
+ *
+ * Don't run this code directly on an AGP buffer. Due to cache problems it will
+ * be very slow.
+ */
+
+
+#include "via_3d_reg.h"
+#include "drmP.h"
+#include "drm.h"
+#include "via_drm.h"
+#include "via_verifier.h"
+#include "via_drv.h"
+
+typedef enum{
+	state_command,
+	state_header2,
+	state_header1,
+	state_vheader5,
+	state_vheader6,
+	state_error
+} verifier_state_t;
+
+
+typedef enum{
+	no_check = 0,
+	check_for_header2,
+	check_for_header1,
+	check_for_header2_err,
+	check_for_header1_err,
+	check_for_fire,
+	check_z_buffer_addr0,
+	check_z_buffer_addr1,
+	check_z_buffer_addr_mode,
+	check_destination_addr0,
+	check_destination_addr1,
+	check_destination_addr_mode,
+	check_for_dummy,
+	check_for_dd,
+	check_texture_addr0,
+	check_texture_addr1,
+	check_texture_addr2,
+	check_texture_addr3,
+	check_texture_addr4,
+	check_texture_addr5,
+	check_texture_addr6,
+	check_texture_addr7,
+	check_texture_addr8,
+	check_texture_addr_mode,
+	check_for_vertex_count,
+	check_number_texunits,
+	forbidden_command
+}hazard_t;
+
+/*
+ * Associates each hazard above with a possible multi-command
+ * sequence. For example an address that is split over multiple
+ * commands and that needs to be checked at the first command 
+ * that does not include any part of the address.
+ */
+
+static drm_via_sequence_t seqs[] = { 
+	no_sequence,
+	no_sequence,
+	no_sequence,
+	no_sequence,
+	no_sequence,
+	no_sequence,
+	z_address,
+	z_address,
+	z_address,
+	dest_address,
+	dest_address,
+	dest_address,
+	no_sequence,
+	no_sequence,
+	tex_address,
+	tex_address,
+	tex_address,
+	tex_address,
+	tex_address,
+	tex_address,
+	tex_address,
+	tex_address,
+	tex_address,
+	tex_address,
+	no_sequence
+};
+    
+typedef struct{
+	unsigned int code;
+	hazard_t hz;
+} hz_init_t;
+
+
+
+static hz_init_t init_table1[] = {
+	{0xf2, check_for_header2_err},
+	{0xf0, check_for_header1_err},
+	{0xee, check_for_fire},
+	{0xcc, check_for_dummy},
+	{0xdd, check_for_dd},
+	{0x00, no_check},
+	{0x10, check_z_buffer_addr0},
+	{0x11, check_z_buffer_addr1},
+	{0x12, check_z_buffer_addr_mode},
+	{0x13, no_check},
+	{0x14, no_check},
+	{0x15, no_check},
+	{0x23, no_check},
+	{0x24, no_check},
+	{0x33, no_check},
+	{0x34, no_check},
+	{0x35, no_check},
+	{0x36, no_check},
+	{0x37, no_check},
+	{0x38, no_check},
+	{0x39, no_check},
+	{0x3A, no_check},
+	{0x3B, no_check},
+	{0x3C, no_check},
+	{0x3D, no_check},
+	{0x3E, no_check},
+	{0x40, check_destination_addr0},
+	{0x41, check_destination_addr1},
+	{0x42, check_destination_addr_mode},
+	{0x43, no_check},
+	{0x44, no_check},
+	{0x50, no_check},
+	{0x51, no_check},
+	{0x52, no_check},
+	{0x53, no_check},
+	{0x54, no_check},
+	{0x55, no_check},
+	{0x56, no_check},
+	{0x57, no_check},
+	{0x58, no_check},
+	{0x70, no_check},
+	{0x71, no_check},
+	{0x78, no_check},
+	{0x79, no_check},
+	{0x7A, no_check},
+	{0x7B, no_check},
+	{0x7C, no_check},
+	{0x7D, check_for_vertex_count}
+};
+
+   
+		       
+static hz_init_t init_table2[] = {
+	{0xf2, check_for_header2_err},
+	{0xf0, check_for_header1_err},
+	{0xee, check_for_fire},
+	{0xcc, check_for_dummy},
+	{0x00, check_texture_addr0},
+	{0x01, check_texture_addr0},
+	{0x02, check_texture_addr0},
+	{0x03, check_texture_addr0},
+	{0x04, check_texture_addr0},
+	{0x05, check_texture_addr0},
+	{0x06, check_texture_addr0},
+	{0x07, check_texture_addr0},
+	{0x08, check_texture_addr0},
+	{0x09, check_texture_addr0},
+	{0x20, check_texture_addr1},
+	{0x21, check_texture_addr1},
+	{0x22, check_texture_addr1},
+	{0x23, check_texture_addr4},
+	{0x2B, check_texture_addr3},
+	{0x2C, check_texture_addr3},
+	{0x2D, check_texture_addr3},
+	{0x2E, check_texture_addr3},
+	{0x2F, check_texture_addr3},
+	{0x30, check_texture_addr3},
+	{0x31, check_texture_addr3},
+	{0x32, check_texture_addr3},
+	{0x33, check_texture_addr3},
+	{0x34, check_texture_addr3},
+	{0x4B, check_texture_addr5},
+	{0x4C, check_texture_addr6},
+	{0x51, check_texture_addr7},
+	{0x52, check_texture_addr8},
+	{0x77, check_texture_addr2},
+	{0x78, no_check},
+	{0x79, no_check},
+	{0x7A, no_check},
+	{0x7B, check_texture_addr_mode},
+	{0x7C, no_check},
+	{0x7D, no_check},
+	{0x7E, no_check},
+	{0x7F, no_check},
+	{0x80, no_check},
+	{0x81, no_check},
+	{0x82, no_check},
+	{0x83, no_check},
+	{0x85, no_check},
+	{0x86, no_check},
+	{0x87, no_check},
+	{0x88, no_check},
+	{0x89, no_check},
+	{0x8A, no_check},
+	{0x90, no_check},
+	{0x91, no_check},
+	{0x92, no_check},
+	{0x93, no_check}
+};
+
+static hz_init_t init_table3[] = {
+	{0xf2, check_for_header2_err},
+	{0xf0, check_for_header1_err},
+	{0xcc, check_for_dummy},
+	{0x00, check_number_texunits}
+};
+   
+		       
+static hazard_t table1[256]; 
+static hazard_t table2[256]; 
+static hazard_t table3[256]; 
+
+
+
+static __inline__ int
+eat_words(const uint32_t **buf, const uint32_t *buf_end, unsigned num_words)
+{
+	if ((*buf - buf_end) >= num_words) {
+		*buf += num_words;
+		return 0;
+	} 
+	DRM_ERROR("Illegal termination of DMA command buffer\n");
+	return 1;
+}
+
+
+/*
+ * Partially stolen from drm_memory.h
+ */
+
+static __inline__ drm_map_t *
+via_drm_lookup_agp_map (drm_via_state_t *seq, unsigned long offset, unsigned long size, 
+			drm_device_t *dev)
+{
+	struct list_head *list;
+	drm_map_list_t *r_list;
+	drm_map_t *map = seq->map_cache;
+
+	if (map && map->offset <= offset && (offset + size) <= (map->offset + map->size)) {
+		return map;
+	}
+		
+	list_for_each(list, &dev->maplist->head) {
+		r_list = (drm_map_list_t *) list;
+		map = r_list->map;
+		if (!map)
+			continue;
+		if (map->offset <= offset && (offset + size) <= (map->offset + map->size) && 
+		    !(map->flags & _DRM_RESTRICTED) && (map->type == _DRM_AGP)) {
+			seq->map_cache = map;
+			return map;
+		}
+	}
+	return NULL;
+}
+
+
+/*
+ * Require that all AGP texture levels reside in the same AGP map which should 
+ * be mappable by the client. This is not a big restriction.
+ * FIXME: To actually enforce this security policy strictly, drm_rmmap 
+ * would have to wait for dma quiescent before removing an AGP map. 
+ * The via_drm_lookup_agp_map call in reality seems to take
+ * very little CPU time.
+ */
+
+
+static __inline__ int
+finish_current_sequence(drm_via_state_t *cur_seq) 
+{
+	switch(cur_seq->unfinished) {
+	case z_address:
+		DRM_DEBUG("Z Buffer start address is 0x%x\n", cur_seq->z_addr);
+		break;
+	case dest_address:
+		DRM_DEBUG("Destination start address is 0x%x\n", cur_seq->d_addr);
+		break;
+	case tex_address:
+		if (cur_seq->agp_texture) {			 
+			unsigned start = cur_seq->tex_level_lo[cur_seq->texture];
+			unsigned end = cur_seq->tex_level_hi[cur_seq->texture];
+			unsigned long lo=~0, hi=0, tmp;
+			uint32_t *addr, *pitch, *height, tex;
+			unsigned i;
+
+			if (end > 9) end = 9;
+			if (start > 9) start = 9;
+
+			addr =&(cur_seq->t_addr[tex = cur_seq->texture][start]);
+			pitch = &(cur_seq->pitch[tex][start]);
+			height = &(cur_seq->height[tex][start]);
+
+			for (i=start; i<= end; ++i) {
+				tmp = *addr++;
+				if (tmp < lo) lo = tmp;
+				tmp += (*height++ << *pitch++);
+				if (tmp > hi) hi = tmp;
+			}
+
+			if (! via_drm_lookup_agp_map (cur_seq, lo, hi - lo, cur_seq->dev)) {
+				DRM_ERROR("AGP texture is not in allowed map\n");
+				return 2;
+			}
+		}	
+		break;
+	default:
+		break;
+	}
+	cur_seq->unfinished = no_sequence;
+	return 0;
+}
+
+static __inline__ int 
+investigate_hazard( uint32_t cmd, hazard_t hz, drm_via_state_t *cur_seq)
+{
+	register uint32_t tmp, *tmp_addr;
+
+	if (cur_seq->unfinished && (cur_seq->unfinished != seqs[hz])) {
+		int ret;
+		if ((ret = finish_current_sequence(cur_seq))) return ret;
+	}
+
+	switch(hz) {
+	case check_for_header2:
+		if (cmd == HALCYON_HEADER2) return 1;
+		return 0;
+	case check_for_header1:
+		if ((cmd & HALCYON_HEADER1MASK) == HALCYON_HEADER1) return 1;
+		return 0;
+	case check_for_header2_err:
+		if (cmd == HALCYON_HEADER2) return 1;
+		DRM_ERROR("Illegal DMA HALCYON_HEADER2 command\n");
+		break;
+	case check_for_header1_err:
+		if ((cmd & HALCYON_HEADER1MASK) == HALCYON_HEADER1) return 1;
+		DRM_ERROR("Illegal DMA HALCYON_HEADER1 command\n");
+		break;
+	case check_for_fire:
+		if ((cmd & HALCYON_FIREMASK) == HALCYON_FIRECMD) return 1; 
+		DRM_ERROR("Illegal DMA HALCYON_FIRECMD command\n");
+		break;
+	case check_for_dummy:
+		if (HC_DUMMY == cmd) return 0;
+		DRM_ERROR("Illegal DMA HC_DUMMY command\n");
+		break;
+	case check_for_dd:
+		if (0xdddddddd == cmd) return 0;
+		DRM_ERROR("Illegal DMA 0xdddddddd command\n");
+		break;
+	case check_z_buffer_addr0:
+		cur_seq->unfinished = z_address;
+		cur_seq->z_addr = (cur_seq->z_addr & 0xFF000000) |
+			(cmd & 0x00FFFFFF);
+		return 0;
+	case check_z_buffer_addr1:
+		cur_seq->unfinished = z_address;
+		cur_seq->z_addr = (cur_seq->z_addr & 0x00FFFFFF) |
+			((cmd & 0xFF) << 24);
+		return 0;
+	case check_z_buffer_addr_mode:
+		cur_seq->unfinished = z_address;
+		if ((cmd & 0x0000C000) == 0) return 0;
+		DRM_ERROR("Attempt to place Z buffer in system memory\n");
+		return 2;
+	case check_destination_addr0:
+		cur_seq->unfinished = dest_address;
+		cur_seq->d_addr = (cur_seq->d_addr & 0xFF000000) |
+			(cmd & 0x00FFFFFF);
+		return 0;
+	case check_destination_addr1:
+		cur_seq->unfinished = dest_address;
+		cur_seq->d_addr = (cur_seq->d_addr & 0x00FFFFFF) |
+			((cmd & 0xFF) << 24);
+		return 0;
+	case check_destination_addr_mode:
+		cur_seq->unfinished = dest_address;
+		if ((cmd & 0x0000C000) == 0) return 0;
+		DRM_ERROR("Attempt to place 3D drawing buffer in system memory\n");
+		return 2;	    
+	case check_texture_addr0:
+		cur_seq->unfinished = tex_address;
+		tmp = (cmd >> 24);
+		tmp_addr = &cur_seq->t_addr[cur_seq->texture][tmp];
+		*tmp_addr = (*tmp_addr & 0xFF000000) | (cmd & 0x00FFFFFF);
+		return 0;
+	case check_texture_addr1:
+		cur_seq->unfinished = tex_address;
+		tmp = ((cmd >> 24) - 0x20);
+		tmp += tmp << 1;
+		tmp_addr = &cur_seq->t_addr[cur_seq->texture][tmp];
+		*tmp_addr = (*tmp_addr & 0x00FFFFFF) | ((cmd & 0xFF) << 24);
+		tmp_addr++;
+		*tmp_addr = (*tmp_addr & 0x00FFFFFF) | ((cmd & 0xFF00) << 16);
+		tmp_addr++;
+		*tmp_addr = (*tmp_addr & 0x00FFFFFF) | ((cmd & 0xFF0000) << 8);
+		return 0;
+	case check_texture_addr2:
+		cur_seq->unfinished = tex_address;
+		cur_seq->tex_level_lo[tmp = cur_seq->texture] = cmd & 0x3F;
+		cur_seq->tex_level_hi[tmp] = (cmd & 0xFC0) >> 6;
+		return 0;
+	case check_texture_addr3:
+		cur_seq->unfinished = tex_address;
+		tmp = ((cmd >> 24) - 0x2B);
+		cur_seq->pitch[cur_seq->texture][tmp] = (cmd & 0x00F00000) >> 20;
+		if (!tmp && (cmd & 0x000FFFFF)) {
+			DRM_ERROR("Unimplemented texture level 0 pitch mode.\n");
+			return 2;
+		}
+		return 0;
+	case check_texture_addr4:
+		cur_seq->unfinished = tex_address;
+		tmp_addr = &cur_seq->t_addr[cur_seq->texture][9];
+		*tmp_addr = (*tmp_addr & 0x00FFFFFF) | ((cmd & 0xFF) << 24);
+		return 0;
+	case check_texture_addr5:
+	case check_texture_addr6:
+		cur_seq->unfinished = tex_address;
+		/*
+		 * Texture width. We don't care since we have the pitch.
+		 */  
+		return 0;
+	case check_texture_addr7:
+		cur_seq->unfinished = tex_address;
+		tmp_addr = &(cur_seq->height[cur_seq->texture][0]);
+		tmp_addr[5] = 1 << ((cmd & 0x00F00000) >> 20);
+		tmp_addr[4] = 1 << ((cmd & 0x000F0000) >> 16);
+		tmp_addr[3] = 1 << ((cmd & 0x0000F000) >> 12);
+		tmp_addr[2] = 1 << ((cmd & 0x00000F00) >> 8);
+		tmp_addr[1] = 1 << ((cmd & 0x000000F0) >> 4);
+		tmp_addr[0] = 1 << (cmd & 0x0000000F);
+		return 0;
+	case check_texture_addr8:
+		cur_seq->unfinished = tex_address;
+		tmp_addr = &(cur_seq->height[cur_seq->texture][0]);
+		tmp_addr[9] = 1 << ((cmd & 0x0000F000) >> 12);
+	        tmp_addr[8] = 1 << ((cmd & 0x00000F00) >> 8);
+		tmp_addr[7] = 1 << ((cmd & 0x000000F0) >> 4);
+		tmp_addr[6] = 1 << (cmd & 0x0000000F);
+		return 0;
+	case check_texture_addr_mode:
+		cur_seq->unfinished = tex_address;
+		if ( 2 == (tmp = cmd & 0x00000003)) {
+			DRM_ERROR("Attempt to fetch texture from system memory.\n"); 
+			return 2;
+		}
+		cur_seq->agp_texture = (tmp == 3);
+		cur_seq->tex_palette_size[cur_seq->texture] = 
+			(cmd >> 16) & 0x000000007;
+		return 0;
+	case check_for_vertex_count:
+		cur_seq->vertex_count = cmd & 0x0000FFFF;
+		return 0;
+	case check_number_texunits:
+	        cur_seq->multitex = (cmd >> 3) & 1;
+		return 0;
+	default:
+		DRM_ERROR("Illegal DMA data: 0x%x\n", cmd);
+		return 2;
+	}
+	return 2;
+}
+
+
+static __inline__ int
+via_check_prim_list(uint32_t const **buffer, const uint32_t *buf_end,
+		    drm_via_state_t *cur_seq)
+{
+	drm_via_private_t *dev_priv = (drm_via_private_t *) cur_seq->dev->dev_private;
+	uint32_t a_fire, bcmd , dw_count;
+	int ret = 0;
+	int have_fire;
+	const uint32_t *buf = *buffer;
+
+	while(buf < buf_end) {
+	        have_fire = 0;
+		if ((buf_end - buf) < 2) {
+			DRM_ERROR("Unexpected termination of primitive list.\n");
+			ret = 1;
+			break;
+		}
+		if ((*buf & HC_ACMD_MASK) != HC_ACMD_HCmdB) break;
+		bcmd = *buf++;
+		if ((*buf & HC_ACMD_MASK) != HC_ACMD_HCmdA) {
+			DRM_ERROR("Expected Vertex List A command, got 0x%x\n",
+				  *buf);
+			ret = 1;
+			break;
+		}
+		a_fire = *buf++ | HC_HPLEND_MASK | HC_HPMValidN_MASK | HC_HE3Fire_MASK;	
+	
+		/*
+		 * How many dwords per vertex ?
+		 */ 
+		
+		if (cur_seq->agp && ((bcmd & (0xF << 11)) == 0)) {
+			DRM_ERROR("Illegal B command vertex data for AGP.\n");
+			ret = 1;
+			break;
+		} 
+
+		dw_count = 0;
+		if (bcmd & (1 << 7)) dw_count += (cur_seq->multitex) ? 2:1;
+		if (bcmd & (1 << 8)) dw_count += (cur_seq->multitex) ? 2:1;
+		if (bcmd & (1 << 9)) dw_count++;
+		if (bcmd & (1 << 10)) dw_count++;
+		if (bcmd & (1 << 11)) dw_count++;
+		if (bcmd & (1 << 12)) dw_count++;
+		if (bcmd & (1 << 13)) dw_count++;
+		if (bcmd & (1 << 14)) dw_count++;
+
+		while(buf < buf_end) {
+			if (*buf == a_fire) {
+				if (dev_priv->num_fire_offsets >= VIA_FIRE_BUF_SIZE) {
+					DRM_ERROR("Fire offset buffer full.\n");
+					ret = 1;
+					break;
+				}
+				dev_priv->fire_offsets[dev_priv->num_fire_offsets++] = buf;
+			        have_fire = 1;
+				buf++;
+				if (buf < buf_end && *buf == a_fire) 
+					buf++;
+				break;
+			}
+			if ((*buf == HALCYON_HEADER2) || 
+			    ((*buf & HALCYON_FIREMASK) == HALCYON_FIRECMD)) {
+				DRM_ERROR("Missing Vertex Fire command, "
+					  "Stray Vertex Fire command  or verifier "
+					  "lost sync.\n");
+				ret = 1;
+				break;
+			}
+			if ((ret = eat_words(&buf, buf_end, dw_count)))
+				break;
+		}
+		if (buf >= buf_end && !have_fire) {
+			DRM_ERROR("Missing Vertex Fire command or verifier "
+				  "lost sync.\n");
+			ret = 1;
+			break;
+		}
+		if (cur_seq->agp && ((buf - cur_seq->buf_start) & 0x01)) {
+			DRM_ERROR("AGP Primitive list end misaligned.\n");
+			ret = 1;
+			break;
+		}
+	} 
+	*buffer = buf;
+	return ret;
+}
+
+
+		       
+
+
+static __inline__ verifier_state_t
+via_check_header2( uint32_t const **buffer, const uint32_t *buf_end, 
+		   drm_via_state_t *hc_state)
+{
+	uint32_t cmd;
+	int hz_mode;
+	hazard_t hz;
+	const uint32_t *buf = *buffer;
+	const hazard_t *hz_table;
+
+
+	if ((buf_end - buf) < 2) {
+		DRM_ERROR("Illegal termination of DMA HALCYON_HEADER2 sequence.\n");
+		return state_error;
+	}
+	buf++;
+	cmd = (*buf++ & 0xFFFF0000) >> 16;
+
+	switch(cmd) {
+	case HC_ParaType_CmdVdata:
+		if (via_check_prim_list(&buf, buf_end, hc_state )) 
+			return state_error;
+		*buffer = buf;
+		return state_command;
+	case HC_ParaType_NotTex:
+		hz_table = table1;
+		break;
+	case HC_ParaType_Tex:
+		hc_state->texture = 0;
+		hz_table = table2;
+		break;
+	case (HC_ParaType_Tex | (HC_SubType_Tex1 << 8)):
+		hc_state->texture = 1;
+		hz_table = table2;
+		break;
+	case (HC_ParaType_Tex | (HC_SubType_TexGeneral << 8)):
+		hz_table = table3;
+		break;
+	case HC_ParaType_Auto:
+		if (eat_words(&buf, buf_end, 2))
+			return state_error;
+		*buffer = buf;
+		return state_command;
+	case (HC_ParaType_Palette | (HC_SubType_Stipple << 8)):
+		if (eat_words(&buf, buf_end, 32))
+			return state_error;
+		*buffer = buf;
+		return state_command;
+	case (HC_ParaType_Palette | (HC_SubType_TexPalette0 << 8)):
+	case (HC_ParaType_Palette | (HC_SubType_TexPalette1 << 8)):
+		DRM_ERROR("Texture palettes are rejected because of "
+			  "lack of info how to determine their size.\n");
+		return state_error;
+	case (HC_ParaType_Palette | (HC_SubType_FogTable << 8)):
+		DRM_ERROR("Fog factor palettes are rejected because of "
+			  "lack of info how to determine their size.\n");
+		return state_error;
+	default:
+
+		/*
+		 * There are some unimplemented HC_ParaTypes here, that
+		 * need to be implemented if the Mesa driver is extended.
+		 */
+
+		DRM_ERROR("Invalid or unimplemented HALCYON_HEADER2 "
+			  "DMA subcommand: 0x%x. Previous dword: 0x%x\n", 
+			  cmd, *(buf -2));
+		*buffer = buf;
+		return state_error;
+	}
+
+	while(buf < buf_end) {
+		cmd = *buf++;
+		if ((hz = hz_table[cmd >> 24])) {
+			if ((hz_mode = investigate_hazard(cmd, hz, hc_state))) {
+				if (hz_mode == 1) {
+					buf--;
+					break;
+				}
+				return state_error;
+			}
+		} else if (hc_state->unfinished && 
+			   finish_current_sequence(hc_state)) {
+			return state_error;
+		}
+	}
+	if (hc_state->unfinished && finish_current_sequence(hc_state)) {
+		return state_error;
+	}
+	*buffer = buf;
+	return state_command;
+}
+
+static __inline__ verifier_state_t
+via_parse_header2( drm_via_private_t *dev_priv, uint32_t const **buffer, const uint32_t *buf_end,
+		   int *fire_count)
+{
+	uint32_t cmd;
+	const uint32_t *buf = *buffer;
+	const uint32_t *next_fire; 
+	int burst = 0;
+
+	next_fire = dev_priv->fire_offsets[*fire_count];
+	buf++;
+	cmd = (*buf & 0xFFFF0000) >> 16;
+	VIA_WRITE(HC_REG_TRANS_SET + HC_REG_BASE, *buf++);
+	switch(cmd) {
+	case HC_ParaType_CmdVdata:
+		while ((buf < buf_end) &&
+		       (*fire_count < dev_priv->num_fire_offsets) && 
+		       (*buf & HC_ACMD_MASK) == HC_ACMD_HCmdB ) {
+			while(buf <= next_fire) {
+				VIA_WRITE(HC_REG_TRANS_SPACE + HC_REG_BASE + (burst & 63), *buf++);
+				burst += 4;
+			}
+			if ( ( buf < buf_end ) && ((*buf & HALCYON_FIREMASK) == HALCYON_FIRECMD))
+				buf++;
+
+			if (++(*fire_count) < dev_priv->num_fire_offsets) 
+				next_fire = dev_priv->fire_offsets[*fire_count];
+		}
+		break;
+	default:
+		while(buf < buf_end) {
+			
+			if ( *buf == HC_HEADER2 ||
+			     (*buf & HALCYON_HEADER1MASK) == HALCYON_HEADER1  ||
+			     (*buf & VIA_VIDEOMASK) == VIA_VIDEO_HEADER5 ||
+			     (*buf & VIA_VIDEOMASK) == VIA_VIDEO_HEADER6 ) break;
+			
+			VIA_WRITE(HC_REG_TRANS_SPACE + HC_REG_BASE + (burst & 63), *buf++);
+			burst +=4;
+		}
+	}
+	*buffer = buf;
+	return state_command;
+}
+
+
+
+static __inline__ int
+verify_mmio_address( uint32_t address)
+{
+	if ((address > 0x3FF) && (address < 0xC00 )) {
+		DRM_ERROR("Invalid VIDEO DMA command. "
+			  "Attempt to access 3D- or command burst area.\n");
+		return 1;
+	} else if ((address > 0xCFF) && (address < 0x1300)) {
+		DRM_ERROR("Invalid VIDEO DMA command. "
+			  "Attempt to access PCI DMA area.\n");
+		return 1;		
+	} else if (address > 0x13FF ) {
+		DRM_ERROR("Invalid VIDEO DMA command. "
+			  "Attempt to access VGA registers.\n");
+		return 1;
+	}
+	return 0;
+}
+
+static __inline__ int
+verify_video_tail( uint32_t const **buffer, const uint32_t *buf_end, uint32_t dwords) 
+{
+	const uint32_t *buf = *buffer;
+
+	if (buf_end - buf < dwords) {
+		DRM_ERROR("Illegal termination of video command.\n");
+		return 1;
+	}
+	while (dwords--) {
+		if (*buf++) {
+			DRM_ERROR("Illegal video command tail.\n");
+			return 1;
+		}
+	}
+	*buffer = buf;
+	return 0;
+}
+		
+
+static __inline__ verifier_state_t
+via_check_header1( uint32_t const **buffer, const uint32_t *buf_end )
+{
+	uint32_t cmd;
+	const uint32_t *buf = *buffer;
+	verifier_state_t ret = state_command;
+
+	while (buf < buf_end) {
+		cmd = *buf;
+		if ((cmd > ((0x3FF >> 2) | HALCYON_HEADER1)) &&
+		    (cmd < ((0xC00 >> 2) | HALCYON_HEADER1))) {			
+			if ((cmd & HALCYON_HEADER1MASK) != HALCYON_HEADER1) 
+				break;
+			DRM_ERROR("Invalid HALCYON_HEADER1 command. "
+				  "Attempt to access 3D- or command burst area.\n");
+			ret = state_error;
+			break;
+		} else if (cmd > ((0xCFF >> 2) | HALCYON_HEADER1)) {
+			if ((cmd & HALCYON_HEADER1MASK) != HALCYON_HEADER1) 
+				break;
+			DRM_ERROR("Invalid HALCYON_HEADER1 command. "
+				  "Attempt to access VGA registers.\n");
+			ret = state_error;
+			break;			
+		} else {			
+			buf += 2;
+		}
+	}
+	*buffer = buf;
+	return ret;
+}
+
+static __inline__ verifier_state_t
+via_parse_header1( drm_via_private_t *dev_priv, uint32_t const **buffer, const uint32_t *buf_end )
+{
+	register uint32_t cmd;
+	const uint32_t *buf = *buffer;
+
+	while (buf < buf_end) {
+		cmd = *buf;
+		if ((cmd & HALCYON_HEADER1MASK) != HALCYON_HEADER1) break;
+		VIA_WRITE( (cmd & ~HALCYON_HEADER1MASK) << 2, *++buf); 
+		buf++;
+	}
+	*buffer = buf;
+	return state_command;
+}
+
+static __inline__ verifier_state_t
+via_check_vheader5( uint32_t const **buffer, const uint32_t *buf_end )
+{
+	uint32_t data;
+	const uint32_t *buf = *buffer;
+
+	if (buf_end - buf < 4) {
+		DRM_ERROR("Illegal termination of video header5 command\n");
+		return state_error;
+	}
+
+	data = *buf++ & ~VIA_VIDEOMASK;
+	if (verify_mmio_address(data))
+		return state_error;
+
+	data = *buf++;
+	if (*buf++ != 0x00F50000) {
+		DRM_ERROR("Illegal header5 header data\n");
+		return state_error;
+	}
+	if (*buf++ != 0x00000000) {
+		DRM_ERROR("Illegal header5 header data\n");
+		return state_error;
+	}
+	if (eat_words(&buf, buf_end, data)) 
+		return state_error;
+	if ((data & 3) && verify_video_tail(&buf, buf_end, 4 - (data & 3))) 
+		return state_error;
+	*buffer = buf;
+	return state_command;
+	       
+} 
+
+static __inline__ verifier_state_t
+via_parse_vheader5( drm_via_private_t *dev_priv, uint32_t const **buffer, const uint32_t *buf_end )
+{
+  uint32_t addr, count, i;
+	const uint32_t *buf = *buffer;
+	
+	addr = *buf++ & ~VIA_VIDEOMASK;
+	i = count = *buf;
+	buf += 3;
+	while(i--) {
+		VIA_WRITE(addr, *buf++);
+	}
+	if (count & 3) buf += 4 - (count & 3);
+	*buffer = buf;
+	return state_command;	       
+} 
+
+
+static __inline__ verifier_state_t
+via_check_vheader6( uint32_t const **buffer, const uint32_t *buf_end )
+{
+	uint32_t data;
+	const uint32_t *buf = *buffer;
+	uint32_t i;
+
+
+	if (buf_end - buf < 4) {
+		DRM_ERROR("Illegal termination of video header6 command\n");
+		return state_error;
+	}
+	buf++;
+	data = *buf++;
+	if (*buf++ != 0x00F60000) {
+		DRM_ERROR("Illegal header6 header data\n");
+		return state_error;
+	}
+	if (*buf++ != 0x00000000) {
+		DRM_ERROR("Illegal header6 header data\n");
+		return state_error;
+	}
+	if ((buf_end - buf) < (data << 1)) {
+		DRM_ERROR("Illegal termination of video header6 command\n");
+		return state_error;
+	}
+	for (i=0; i<data; ++i) {
+		if (verify_mmio_address(*buf++))
+			return state_error;
+		buf++;
+	}
+	data <<= 1;
+	if ((data & 3) && verify_video_tail(&buf, buf_end, 4 - (data & 3)))
+		return state_error;
+	*buffer = buf;
+	return state_command;
+} 
+
+static __inline__ verifier_state_t
+via_parse_vheader6( drm_via_private_t *dev_priv, uint32_t const **buffer, const uint32_t *buf_end )
+{
+
+  uint32_t addr, count, i;
+	const uint32_t *buf = *buffer;
+
+	i = count = *++buf;
+	buf += 3;
+	while(i--) {
+		addr = *buf++;
+		VIA_WRITE(addr, *buf++);
+	}
+	count <<= 1;
+	if (count & 3) buf += 4 - (count & 3);
+	*buffer = buf;
+	return state_command;
+} 
+
+
+
+int 
+via_verify_command_stream(const uint32_t * buf, unsigned int size, drm_device_t *dev,
+			  int agp)
+{
+
+	drm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;
+	drm_via_state_t *hc_state = &dev_priv->hc_state;
+	drm_via_state_t saved_state = *hc_state;
+	uint32_t cmd;
+	const uint32_t *buf_end = buf + ( size >> 2 );
+	verifier_state_t state = state_command;
+	int pro_group_a = dev_priv->pro_group_a;
+	
+	hc_state->dev = dev;
+	hc_state->unfinished = no_sequence;
+	hc_state->map_cache = NULL;
+	hc_state->agp = agp;
+	hc_state->buf_start = buf;
+	dev_priv->num_fire_offsets = 0;
+
+	while (buf < buf_end) {
+
+		switch (state) {
+		case state_header2:
+		  state = via_check_header2( &buf, buf_end, hc_state );
+			break;
+		case state_header1:
+			state = via_check_header1( &buf, buf_end );
+			break;
+		case state_vheader5:
+			state = via_check_vheader5( &buf, buf_end );
+			break;
+		case state_vheader6:
+			state = via_check_vheader6( &buf, buf_end );
+			break;
+		case state_command:
+			if (HALCYON_HEADER2 == (cmd = *buf)) 
+				state = state_header2;
+			else if ((cmd & HALCYON_HEADER1MASK) == HALCYON_HEADER1) 
+				state = state_header1;
+			else if (pro_group_a && (cmd & VIA_VIDEOMASK) == VIA_VIDEO_HEADER5)
+				state = state_vheader5;
+			else if (pro_group_a && (cmd & VIA_VIDEOMASK) == VIA_VIDEO_HEADER6)
+				state = state_vheader6;
+			else {
+				DRM_ERROR("Invalid / Unimplemented DMA HEADER command. 0x%x\n",
+					  cmd);
+				state = state_error;
+			}
+			break;
+		case state_error:
+		default:
+			*hc_state = saved_state;
+			return DRM_ERR(EINVAL);			
+		}
+	}	
+	if (state == state_error) {
+		*hc_state = saved_state;
+		return DRM_ERR(EINVAL);
+	}
+	return 0;
+}
+
+int 
+via_parse_command_stream(drm_device_t *dev, const uint32_t * buf, unsigned int size)
+{
+
+	drm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;
+	uint32_t cmd;
+	const uint32_t *buf_end = buf + ( size >> 2 );
+	verifier_state_t state = state_command;
+	int fire_count = 0;
+	
+	while (buf < buf_end) {
+
+		switch (state) {
+		case state_header2:
+		  state = via_parse_header2( dev_priv, &buf, buf_end, &fire_count );
+			break;
+		case state_header1:
+			state = via_parse_header1( dev_priv, &buf, buf_end );
+			break;
+		case state_vheader5:
+			state = via_parse_vheader5( dev_priv, &buf, buf_end );
+			break;
+		case state_vheader6:
+			state = via_parse_vheader6( dev_priv, &buf, buf_end );
+			break;
+		case state_command:
+			if (HALCYON_HEADER2 == (cmd = *buf)) 
+				state = state_header2;
+			else if ((cmd & HALCYON_HEADER1MASK) == HALCYON_HEADER1) 
+				state = state_header1;
+			else if ((cmd & VIA_VIDEOMASK) == VIA_VIDEO_HEADER5)
+				state = state_vheader5;
+			else if ((cmd & VIA_VIDEOMASK) == VIA_VIDEO_HEADER6)
+				state = state_vheader6;
+			else {
+				DRM_ERROR("Invalid / Unimplemented DMA HEADER command. 0x%x\n",
+					  cmd);
+				state = state_error;
+			}
+			break;
+		case state_error:
+		default:
+			return DRM_ERR(EINVAL);			
+		}
+	}	
+	if (state == state_error) {
+		return DRM_ERR(EINVAL);
+	}
+	return 0;
+}
+
+
+
+static void 
+setup_hazard_table(hz_init_t init_table[], hazard_t table[], int size)
+{
+	int i;
+
+	for(i=0; i<256; ++i) {
+		table[i] = forbidden_command;
+	}
+
+	for(i=0; i<size; ++i) {
+		table[init_table[i].code] = init_table[i].hz;
+	}
+}
+
+void 
+via_init_command_verifier( void )
+{
+	setup_hazard_table(init_table1, table1, sizeof(init_table1) / sizeof(hz_init_t));
+	setup_hazard_table(init_table2, table2, sizeof(init_table2) / sizeof(hz_init_t));
+	setup_hazard_table(init_table3, table3, sizeof(init_table3) / sizeof(hz_init_t));
+}
diff -purN linux-2.6.12.orig/drivers/char/drm/via_verifier.h linux-2.6.12/drivers/char/drm/via_verifier.h
--- linux-2.6.12.orig/drivers/char/drm/via_verifier.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/drm/via_verifier.h	2005-07-05 08:37:49.000000000 +0200
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2004 The Unichrome Project. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * THE UNICHROME PROJECT, AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Thomas Hellstrm 2004.
+ */
+
+#ifndef _VIA_VERIFIER_H_
+#define _VIA_VERIFIER_H_
+
+typedef enum{
+	no_sequence = 0, 
+	z_address,
+	dest_address,
+	tex_address
+}drm_via_sequence_t;
+
+
+
+typedef struct{
+	unsigned texture;
+	uint32_t z_addr; 
+	uint32_t d_addr; 
+        uint32_t t_addr[2][10];
+	uint32_t pitch[2][10];
+	uint32_t height[2][10];
+	uint32_t tex_level_lo[2]; 
+	uint32_t tex_level_hi[2];
+	uint32_t tex_palette_size[2];
+	drm_via_sequence_t unfinished;
+	int agp_texture;
+	int multitex;
+	drm_device_t *dev;
+	drm_map_t *map_cache;
+	uint32_t vertex_count;
+	int agp;
+	const uint32_t *buf_start;
+} drm_via_state_t;
+
+extern int via_verify_command_stream(const uint32_t * buf, unsigned int size, 
+				     drm_device_t *dev, int agp);
+
+#endif
diff -purN linux-2.6.12.orig/drivers/char/drm/via_video.c linux-2.6.12/drivers/char/drm/via_video.c
--- linux-2.6.12.orig/drivers/char/drm/via_video.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/drm/via_video.c	2005-07-05 08:37:47.000000000 +0200
@@ -0,0 +1,97 @@
+/*
+ * Copyright 2005 Thomas Hellstrom. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHOR(S), AND/OR THE COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Thomas Hellstrom 2005.
+ *
+ * Video and XvMC related functions.
+ */
+
+#include "drmP.h"
+#include "via_drm.h"
+#include "via_drv.h"
+
+void
+via_init_futex(drm_via_private_t *dev_priv)
+{
+	unsigned int i;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	for (i = 0; i < VIA_NR_XVMC_LOCKS; ++i) {
+		DRM_INIT_WAITQUEUE(&(dev_priv->decoder_queue[i]));
+		XVMCLOCKPTR(dev_priv->sarea_priv, i)->lock = 0;
+	}
+}
+
+void
+via_cleanup_futex(drm_via_private_t *dev_priv)
+{
+}	
+
+void
+via_release_futex(drm_via_private_t *dev_priv, int context)
+{
+	unsigned int i;
+	volatile int *lock;
+
+	for (i=0; i < VIA_NR_XVMC_LOCKS; ++i) {
+	        lock = (int *) XVMCLOCKPTR(dev_priv->sarea_priv, i);
+		if ( (_DRM_LOCKING_CONTEXT( *lock ) == context)) {
+			if (_DRM_LOCK_IS_HELD( *lock ) && (*lock & _DRM_LOCK_CONT)) {
+				DRM_WAKEUP( &(dev_priv->decoder_queue[i]));
+			}
+			*lock = 0;
+		}
+	}	
+}	
+
+int 
+via_decoder_futex(DRM_IOCTL_ARGS)
+{
+	DRM_DEVICE;
+	drm_via_futex_t fx;
+	volatile int *lock;
+	drm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;
+	drm_via_sarea_t *sAPriv = dev_priv->sarea_priv;
+	int ret = 0;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	DRM_COPY_FROM_USER_IOCTL(fx, (drm_via_futex_t *) data, sizeof(fx));
+
+	if (fx.lock > VIA_NR_XVMC_LOCKS)
+		return -EFAULT;
+
+	lock = (int *)XVMCLOCKPTR(sAPriv, fx.lock);
+
+	switch (fx.func) {
+	case VIA_FUTEX_WAIT:
+		DRM_WAIT_ON(ret, dev_priv->decoder_queue[fx.lock],
+			    (fx.ms / 10) * (DRM_HZ / 100), *lock != fx.val);
+		return ret;
+	case VIA_FUTEX_WAKE:
+		DRM_WAKEUP(&(dev_priv->decoder_queue[fx.lock]));
+		return 0;
+	}
+	return 0;
+}
+
--- linux-2.6.12.orig/drivers/char/drm/drm_pciids.h.orig	2005-07-05 09:15:53.000000000 +0200
+++ linux-2.6.12/drivers/char/drm/drm_pciids.h	2005-07-05 09:15:46.000000000 +0200
@@ -0,0 +1,234 @@
+/*
+   This file is auto-generated from the drm_pciids.txt in the DRM CVS
+   Please contact dri-devel@lists.sf.net to add new cards to this list
+*/
+#define radeon_PCI_IDS \
+	{0x1002, 0x4136, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS100|CHIP_IS_IGP}, \
+	{0x1002, 0x4137, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS200|CHIP_IS_IGP}, \
+	{0x1002, 0x4144, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R300}, \
+	{0x1002, 0x4145, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R300}, \
+	{0x1002, 0x4146, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R300}, \
+	{0x1002, 0x4147, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R300}, \
+	{0x1002, 0x4150, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350}, \
+	{0x1002, 0x4151, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350}, \
+	{0x1002, 0x4152, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350}, \
+	{0x1002, 0x4153, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350}, \
+	{0x1002, 0x4154, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350}, \
+	{0x1002, 0x4156, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350}, \
+	{0x1002, 0x4237, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS250|CHIP_IS_IGP}, \
+	{0x1002, 0x4242, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
+	{0x1002, 0x4243, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
+	{0x1002, 0x4336, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS100|CHIP_IS_IGP|CHIP_IS_MOBILITY}, \
+	{0x1002, 0x4337, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS200|CHIP_IS_IGP|CHIP_IS_MOBILITY}, \
+	{0x1002, 0x4437, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS250|CHIP_IS_IGP|CHIP_IS_MOBILITY}, \
+	{0x1002, 0x4964, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R250}, \
+	{0x1002, 0x4965, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R250}, \
+	{0x1002, 0x4966, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R250}, \
+	{0x1002, 0x4967, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R250}, \
+	{0x1002, 0x4C57, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV200|CHIP_IS_MOBILITY}, \
+	{0x1002, 0x4C58, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV200|CHIP_IS_MOBILITY}, \
+	{0x1002, 0x4C59, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV100|CHIP_IS_MOBILITY}, \
+	{0x1002, 0x4C5A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV100|CHIP_IS_MOBILITY}, \
+	{0x1002, 0x4C64, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R250|CHIP_IS_MOBILITY}, \
+	{0x1002, 0x4C65, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R250|CHIP_IS_MOBILITY}, \
+	{0x1002, 0x4C66, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R250|CHIP_IS_MOBILITY}, \
+	{0x1002, 0x4C67, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R250|CHIP_IS_MOBILITY}, \
+	{0x1002, 0x4E50, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350|CHIP_IS_MOBILITY}, \
+	{0x1002, 0x5144, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R100|CHIP_SINGLE_CRTC}, \
+	{0x1002, 0x5145, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R100|CHIP_SINGLE_CRTC}, \
+	{0x1002, 0x5146, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R100|CHIP_SINGLE_CRTC}, \
+	{0x1002, 0x5147, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R100|CHIP_SINGLE_CRTC}, \
+	{0x1002, 0x5148, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
+	{0x1002, 0x5149, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
+	{0x1002, 0x514A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
+	{0x1002, 0x514B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
+	{0x1002, 0x514C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
+	{0x1002, 0x514D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
+	{0x1002, 0x514E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
+	{0x1002, 0x514F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
+	{0x1002, 0x5157, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV200}, \
+	{0x1002, 0x5158, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV200}, \
+	{0x1002, 0x5159, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV100}, \
+	{0x1002, 0x515A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV100}, \
+	{0x1002, 0x515E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV100}, \
+	{0x1002, 0x5168, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
+	{0x1002, 0x5169, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
+	{0x1002, 0x516A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
+	{0x1002, 0x516B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
+	{0x1002, 0x516C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
+	{0x1002, 0x5834, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS300|CHIP_IS_IGP}, \
+	{0x1002, 0x5835, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS300|CHIP_IS_IGP|CHIP_IS_MOBILITY}, \
+	{0x1002, 0x5836, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS300|CHIP_IS_IGP}, \
+	{0x1002, 0x5837, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS300|CHIP_IS_IGP}, \
+	{0x1002, 0x5960, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
+	{0x1002, 0x5961, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
+	{0x1002, 0x5962, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
+	{0x1002, 0x5963, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
+	{0x1002, 0x5964, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
+	{0x1002, 0x5968, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
+	{0x1002, 0x5969, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV100}, \
+	{0x1002, 0x596A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
+	{0x1002, 0x596B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
+	{0x1002, 0x5c61, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280|CHIP_IS_MOBILITY}, \
+	{0x1002, 0x5c62, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
+	{0x1002, 0x5c63, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280|CHIP_IS_MOBILITY}, \
+	{0x1002, 0x5c64, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
+	{0, 0, 0}
+
+#define r128_PCI_IDS \
+	{0x1002, 0x4c45, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x4c46, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x4d46, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x4d4c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x5041, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x5042, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x5043, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x5044, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x5045, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x5046, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x5047, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x5048, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x5049, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x504A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x504B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x504C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x504D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x504E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x504F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x5050, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x5051, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x5052, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x5053, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x5054, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x5055, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x5056, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x5057, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x5058, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x5245, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x5246, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x5247, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x524b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x524c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x534d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x5446, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x544C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x5452, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0, 0, 0}
+
+#define mga_PCI_IDS \
+	{0x102b, 0x0520, PCI_ANY_ID, PCI_ANY_ID, 0, 0, MGA_CARD_TYPE_G200}, \
+	{0x102b, 0x0521, PCI_ANY_ID, PCI_ANY_ID, 0, 0, MGA_CARD_TYPE_G200}, \
+	{0x102b, 0x0525, PCI_ANY_ID, PCI_ANY_ID, 0, 0, MGA_CARD_TYPE_G400}, \
+	{0x102b, 0x2527, PCI_ANY_ID, PCI_ANY_ID, 0, 0, MGA_CARD_TYPE_G550}, \
+	{0, 0, 0}
+
+#define mach64_PCI_IDS \
+	{0x1002, 0x4749, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x4750, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x4751, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x4742, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x4744, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x4c49, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x4c50, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x4c51, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x4c42, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x4c44, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x474c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x474f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x4752, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x4753, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x474d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x474e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x4c52, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x4c53, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x4c4d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x4c4e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0, 0, 0}
+
+#define sis_PCI_IDS \
+	{0x1039, 0x0300, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1039, 0x5300, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1039, 0x6300, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1039, 0x7300, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0, 0, 0}
+
+#define tdfx_PCI_IDS \
+	{0x121a, 0x0003, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x121a, 0x0004, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x121a, 0x0005, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x121a, 0x0007, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x121a, 0x0009, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x121a, 0x000b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0, 0, 0}
+
+#define viadrv_PCI_IDS \
+	{0x1106, 0x3022, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1106, 0x3118, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1106, 0x3122, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1106, 0x7205, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1106, 0x3108, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0, 0, 0}
+
+#define i810_PCI_IDS \
+	{0x8086, 0x7121, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x8086, 0x7123, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x8086, 0x7125, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x8086, 0x1132, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0, 0, 0}
+
+#define i830_PCI_IDS \
+	{0x8086, 0x3577, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x8086, 0x2562, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x8086, 0x3582, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x8086, 0x2572, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0, 0, 0}
+
+#define gamma_PCI_IDS \
+	{0x3d3d, 0x0008, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0, 0, 0}
+
+#define savage_PCI_IDS \
+	{0x5333, 0x8a20, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_SAVAGE3D}, \
+	{0x5333, 0x8a21, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_SAVAGE3D}, \
+	{0x5333, 0x8a22, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_SAVAGE4}, \
+	{0x5333, 0x8a23, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_SAVAGE4}, \
+	{0x5333, 0x8c10, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_SAVAGE_MX}, \
+	{0x5333, 0x8c11, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_SAVAGE_MX}, \
+	{0x5333, 0x8c12, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_SAVAGE_MX}, \
+	{0x5333, 0x8c13, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_SAVAGE_MX}, \
+	{0x5333, 0x8c22, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_SUPERSAVAGE}, \
+	{0x5333, 0x8c24, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_SUPERSAVAGE}, \
+	{0x5333, 0x8c26, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_SUPERSAVAGE}, \
+	{0x5333, 0x8c2a, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_SUPERSAVAGE}, \
+	{0x5333, 0x8c2b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_SUPERSAVAGE}, \
+	{0x5333, 0x8c2c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_SUPERSAVAGE}, \
+	{0x5333, 0x8c2d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_SUPERSAVAGE}, \
+	{0x5333, 0x8c2e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_SUPERSAVAGE}, \
+	{0x5333, 0x8c2f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_SUPERSAVAGE}, \
+	{0x5333, 0x8a25, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_PROSAVAGE}, \
+	{0x5333, 0x8a26, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_PROSAVAGE}, \
+	{0x5333, 0x8d01, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_TWISTER}, \
+	{0x5333, 0x8d02, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_TWISTER}, \
+	{0x5333, 0x8d03, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_PROSAVAGEDDR}, \
+	{0x5333, 0x8d04, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_PROSAVAGEDDR}, \
+	{0, 0, 0}
+
+#define ffb_PCI_IDS \
+	{0, 0, 0}
+
+#define i915_PCI_IDS \
+	{0x8086, 0x3577, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x8086, 0x2562, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x8086, 0x3582, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x8086, 0x2572, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x8086, 0x2582, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x8086, 0x2592, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x8086, 0x2772, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0, 0, 0}
+
+#define imagine_PCI_IDS \
+	{0x105d, 0x2309, PCI_ANY_ID, PCI_ANY_ID, 0, 0, IMAGINE_128}, \
+	{0x105d, 0x2339, PCI_ANY_ID, PCI_ANY_ID, 0, 0, IMAGINE_128_2}, \
+	{0x105d, 0x493d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, IMAGINE_T2R}, \
+	{0x105d, 0x5348, PCI_ANY_ID, PCI_ANY_ID, 0, 0, IMAGINE_REV4}, \
+	{0, 0, 0}

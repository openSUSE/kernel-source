diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/arm/Kconfig linux/sound/arm/Kconfig
--- linux-2.6.8/sound/arm/Kconfig	2004-08-14 07:37:41.000000000 +0200
+++ linux/sound/arm/Kconfig	2004-09-13 12:28:27.000000000 +0200
@@ -4,12 +4,15 @@ menu "ALSA ARM devices"
 	depends on SND!=n && ARM
 
 config SND_SA11XX_UDA1341
-	tristate "SA11xx UDA1341TS driver (H3600)"
+	tristate "SA11xx UDA1341TS driver (iPaq H3600)"
 	depends on ARCH_SA1100 && SND && L3
 	select SND_PCM
 	help
-	  Say Y or M if you have a Compaq iPaq H3x00 handheld computer and want
-	  to use its Philips UDA 1341 audio chip.
+	  Say Y here if you have a Compaq iPaq H3x00 handheld computer
+	  and want to use its Philips UDA 1341 audio chip.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-sa11xx-uda1341.
 
 endmenu
 
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/core/Kconfig linux/sound/core/Kconfig
--- linux-2.6.8/sound/core/Kconfig	2004-08-14 07:37:26.000000000 +0200
+++ linux/sound/core/Kconfig	2004-09-13 12:28:27.000000000 +0200
@@ -17,17 +17,26 @@ config SND_SEQUENCER
 	depends on SND
 	select SND_TIMER
 	help
-	  Say 'Y' or 'M' to enable MIDI sequencer and router support. This feature
-	  allows routing and enqueing MIDI events. Events can be processed at given
-	  time.
+	  Say Y or M to enable MIDI sequencer and router support.  This
+	  feature allows routing and enqueueing of MIDI events.  Events
+	  can be processed at a given time.
+
+	  Many programs require this feature, so you should enable it
+	  unless you know what you're doing.
 
 config SND_SEQ_DUMMY
 	tristate "Sequencer dummy client"
 	depends on SND_SEQUENCER
 	help
-	  Say 'Y' or 'M' to enable dummy sequencer client. This client is a simple
-	  midi-through client. All normal input events are redirected to output port
-	  immediately.
+	  Say Y here to enable the dummy sequencer client.  This client
+	  is a simple MIDI-through client: all normal input events are
+	  redirected to the output port immediately.
+
+	  You don't need this unless you want to connect many MIDI
+	  devices or applications together.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-seq-dummy.
 
 config SND_OSSEMUL
 	bool
@@ -37,7 +46,13 @@ config SND_MIXER_OSS
 	depends on SND
 	select SND_OSSEMUL
 	help
-	  Say 'Y' or 'M' to enable mixer OSS API emulation (/dev/mixer*).
+	  To enable OSS mixer API emulation (/dev/mixer*), say Y here
+	  and read <file:Documentation/sound/alsa/OSS-Emulation.txt>.
+
+	  Many programs still use the OSS API, so say Y.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-mixer-oss.
 
 config SND_PCM_OSS
 	tristate "OSS PCM (digital audio) API"
@@ -45,15 +60,26 @@ config SND_PCM_OSS
 	select SND_OSSEMUL
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to enable digital audio (PCM) OSS API emulation (/dev/dsp*).
+	  To enable OSS digital audio (PCM) emulation (/dev/dsp*), say Y
+	  here and read <file:Documentation/sound/alsa/OSS-Emulation.txt>.
+
+	  Many programs still use the OSS API, so say Y.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-pcm-oss.
 
 config SND_SEQUENCER_OSS
 	bool "OSS Sequencer API"
 	depends on SND_SEQUENCER
 	select SND_OSSEMUL
 	help
-	  Say 'Y' to enable OSS sequencer emulation (both /dev/sequencer and
-	  /dev/music interfaces).
+	  Say Y here to enable OSS sequencer emulation (both
+	  /dev/sequencer and /dev/music interfaces).
+
+	  Many programs still use the OSS API, so say Y.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-seq-oss.
 
 config SND_BIT32_EMUL
 	tristate "Emulation for 32-bit applications"
@@ -63,38 +89,51 @@ config SND_BIT32_EMUL
 	select SND_TIMER
 	select SND_HWDEP
 	help
-	  Say 'Y' or 'M' to enable the emulation for 32-bit ALSA-native
+	  Say Y here to enable the emulation for 32-bit ALSA-native
 	  applications.
 
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-ioctl32.
+
 config SND_RTCTIMER
 	tristate "RTC Timer support"
 	depends on SND && RTC
 	select SND_TIMER
 	help
-	  Say 'Y' or 'M' to enable RTC timer support for ALSA. ALSA code uses RTC
-	  timer as precise timing source and maps the RTC timer to the ALSA's timer
-	  interface. ALSA sequencer code can also use this timing source.
+	  Say Y here to enable RTC timer support for ALSA.  ALSA uses
+	  the RTC timer as a precise timing source and maps the RTC
+	  timer to ALSA's timer interface.  The ALSA sequencer code also
+	  can use this timing source.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-rtctimer.
 
 config SND_VERBOSE_PRINTK
 	bool "Verbose printk"
 	depends on SND
 	help
-	  Say 'Y' to enable verbose log messages. These messages will help to
-	  identify source file and position containing printed messages.
+	  Say Y here to enable verbose log messages.  These messages
+	  will help to identify source file and position containing
+	  printed messages.
+
+	  You don't need this unless you're debugging ALSA.
 
 config SND_DEBUG
 	bool "Debug"
 	depends on SND
 	help
-	  Say 'Y' to enable ALSA debug code.
+	  Say Y here to enable ALSA debug code.
 
 config SND_DEBUG_MEMORY
 	bool "Debug memory"
 	depends on SND_DEBUG
 	help
-	  Say 'Y' to enable debugging of memory allocation.
+	  Say Y here to enable debugging of memory allocations.
 
 config SND_DEBUG_DETECT
 	bool "Debug detection"
 	depends on SND_DEBUG
+	help
+	  Say Y here to enable extra-verbose log messages printed when
+	  detecting devices.
 
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/core/ioctl32/ioctl32.c linux/sound/core/ioctl32/ioctl32.c
--- linux-2.6.8/sound/core/ioctl32/ioctl32.c	2004-09-15 11:20:37.707465632 +0200
+++ linux/sound/core/ioctl32/ioctl32.c	2004-09-15 11:04:51.491548089 +0200
@@ -246,7 +246,7 @@ struct sndrv_ctl_elem_value32 {
 		struct sndrv_aes_iec958 iec958;
         } value;
         unsigned char reserved[128];
-} __attribute__((packed));
+};
 
 
 /* hmm, it's so hard to retrieve the value type from the control id.. */
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/core/ioctl32/pcm32.c linux/sound/core/ioctl32/pcm32.c
--- linux-2.6.8/sound/core/ioctl32/pcm32.c	2004-09-15 11:20:37.708465480 +0200
+++ linux/sound/core/ioctl32/pcm32.c	2004-09-15 11:04:51.728508223 +0200
@@ -439,6 +439,30 @@ DEFINE_ALSA_IOCTL_ENTRY(pcm_sync_ptr, pc
 
 
 /*
+ * When PCM is used on 32bit mode, we need to disable
+ * mmap of PCM status/control records because of the size
+ * incompatibility.
+ * 
+ * Since INFO ioctl is always called at first, we mark the
+ * mmap-disabling in this ioctl wrapper.
+ */
+static int snd_pcm_info_ioctl32(unsigned int fd, unsigned int cmd, unsigned long arg, struct file *filp)
+{
+	snd_pcm_file_t *pcm_file;
+	snd_pcm_substream_t *substream;
+	if (! filp->f_op || ! filp->f_op->ioctl)
+		return -ENOTTY;
+	pcm_file = filp->private_data;
+	if (! pcm_file)
+		return -ENOTTY;
+	substream = pcm_file->substream;
+	if (! substream)
+		return -ENOTTY;
+	substream->no_mmap_ctrl = 1;
+	return filp->f_op->ioctl(filp->f_dentry->d_inode, filp, cmd, arg);
+}
+
+/*
  */
 #define AP(x) snd_ioctl32_##x
 
@@ -456,13 +480,14 @@ enum {
 	SNDRV_PCM_IOCTL_READN_FRAMES32 = _IOR('A', 0x53, struct sndrv_xfern32),
 	SNDRV_PCM_IOCTL_HW_REFINE_OLD32 = _IOWR('A', 0x10, struct sndrv_pcm_hw_params_old32),
 	SNDRV_PCM_IOCTL_HW_PARAMS_OLD32 = _IOWR('A', 0x11, struct sndrv_pcm_hw_params_old32),
-	SNDRV_PCM_IOCTL_SYNC_PTR32 = _IOWR('A', 0x23, struct sndrv_pcm_sync_ptr),
+	SNDRV_PCM_IOCTL_SYNC_PTR32 = _IOWR('A', 0x23, struct sndrv_pcm_sync_ptr32),
 
 };
 
 struct ioctl32_mapper pcm_mappers[] = {
 	MAP_COMPAT(SNDRV_PCM_IOCTL_PVERSION),
-	MAP_COMPAT(SNDRV_PCM_IOCTL_INFO),
+	/* MAP_COMPAT(SNDRV_PCM_IOCTL_INFO), */
+	{ SNDRV_PCM_IOCTL_INFO, snd_pcm_info_ioctl32 },
 	MAP_COMPAT(SNDRV_PCM_IOCTL_TSTAMP),
 	{ SNDRV_PCM_IOCTL_HW_REFINE32, AP(pcm_hw_refine) },
 	{ SNDRV_PCM_IOCTL_HW_PARAMS32, AP(pcm_hw_params) },
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/core/memalloc.c linux/sound/core/memalloc.c
--- linux-2.6.8/sound/core/memalloc.c	2004-09-15 11:20:37.710465176 +0200
+++ linux/sound/core/memalloc.c	2004-08-31 11:46:13.000000000 +0200
@@ -246,9 +246,9 @@ static void *snd_malloc_dev_pages(struct
 	snd_assert(size > 0, return NULL);
 	snd_assert(dma != NULL, return NULL);
 	pg = get_order(size);
-	gfp_flags = GFP_KERNEL;
-	if (pg > 0)
-		gfp_flags |= __GFP_NOWARN;
+	gfp_flags = GFP_KERNEL
+		| __GFP_NORETRY /* don't trigger OOM-killer */
+		| __GFP_NOWARN; /* no stack trace print - this call is non-critical */
 	res = dma_alloc_coherent(dev, PAGE_SIZE << pg, dma, gfp_flags);
 	if (res != NULL) {
 #ifdef NEED_RESERVE_PAGES
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/core/oss/pcm_oss.c linux/sound/core/oss/pcm_oss.c
--- linux-2.6.8/sound/core/oss/pcm_oss.c	2004-09-15 11:20:37.723463200 +0200
+++ linux/sound/core/oss/pcm_oss.c	2004-09-07 19:22:40.000000000 +0200
@@ -834,9 +834,14 @@ static ssize_t snd_pcm_oss_write1(snd_pc
 				if (tmp <= 0)
 					return xfer > 0 ? (snd_pcm_sframes_t)xfer : tmp;
 				runtime->oss.bytes += tmp;
-				runtime->oss.buffer_used = 0;
 				runtime->oss.period_ptr += tmp;
 				runtime->oss.period_ptr %= runtime->oss.period_bytes;
+				if ((substream->ffile->f_flags & O_NONBLOCK) != 0 &&
+				    tmp != runtime->oss.buffer_used) {
+					runtime->oss.buffer_used = 0;
+					break;
+				}
+				runtime->oss.buffer_used = 0;
 			}
 		} else {
 			tmp = snd_pcm_oss_write2(substream, (char *)buf, runtime->oss.period_bytes, 0);
@@ -846,6 +851,9 @@ static ssize_t snd_pcm_oss_write1(snd_pc
 			buf += tmp;
 			bytes -= tmp;
 			xfer += tmp;
+			if ((substream->ffile->f_flags & O_NONBLOCK) != 0 &&
+			    tmp != runtime->oss.period_bytes)
+				break;
 		}
 	}
 	return xfer;
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/core/pcm_native.c linux/sound/core/pcm_native.c
--- linux-2.6.8/sound/core/pcm_native.c	2004-09-15 11:20:37.769456208 +0200
+++ linux/sound/core/pcm_native.c	2004-09-15 11:04:51.165602927 +0200
@@ -1973,6 +1973,7 @@ static int snd_pcm_open_file(struct file
 
 	str = substream->pstr;
 	substream->file = pcm_file;
+	substream->no_mmap_ctrl = 0;
 
 	pcm_file->substream = substream;
 
@@ -3158,8 +3159,12 @@ static int snd_pcm_mmap(struct file *fil
 	offset = area->vm_pgoff << PAGE_SHIFT;
 	switch (offset) {
 	case SNDRV_PCM_MMAP_OFFSET_STATUS:
+		if (substream->no_mmap_ctrl)
+			return -ENXIO;
 		return snd_pcm_mmap_status(substream, file, area);
 	case SNDRV_PCM_MMAP_OFFSET_CONTROL:
+		if (substream->no_mmap_ctrl)
+			return -ENXIO;
 		return snd_pcm_mmap_control(substream, file, area);
 	default:
 		return snd_pcm_mmap_data(substream, file, area);
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/core/seq/seq_clientmgr.c linux/sound/core/seq/seq_clientmgr.c
--- linux-2.6.8/sound/core/seq/seq_clientmgr.c	2004-09-15 11:20:37.859442528 +0200
+++ linux/sound/core/seq/seq_clientmgr.c	2004-09-07 22:43:39.000000000 +0200
@@ -156,7 +156,10 @@ client_t *snd_seq_client_use_ptr(int cli
 					card_requested[card] = 1;
 					snd_request_card(card);
 				}
-				snd_seq_device_load_drivers();
+				/* FIXME: may cause blocking when called from
+				 * module_init(), so disable this feature
+				 */
+				/* snd_seq_device_load_drivers(); */
 			}
 		}
 		spin_lock_irqsave(&clients_lock, flags);
@@ -420,7 +423,10 @@ static ssize_t snd_seq_read(struct file 
 			count -= err;
 			buf += err;
 		} else {
-			copy_to_user(buf, &cell->event, sizeof(snd_seq_event_t));
+			if (copy_to_user(buf, &cell->event, sizeof(snd_seq_event_t))) {
+				err = -EFAULT;
+				break;
+			}
 			count -= sizeof(snd_seq_event_t);
 			buf += sizeof(snd_seq_event_t);
 		}
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/drivers/Kconfig linux/sound/drivers/Kconfig
--- linux-2.6.8/sound/drivers/Kconfig	2004-08-14 07:37:37.000000000 +0200
+++ linux/sound/drivers/Kconfig	2004-09-13 12:28:28.000000000 +0200
@@ -30,8 +30,14 @@ config SND_DUMMY
 	depends on SND
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to include dummy driver. This driver does nothing, but
-	  emulates various mixer controls and PCM devices.
+	  Say Y here to include the dummy driver.  This driver does
+	  nothing, but emulates various mixer controls and PCM devices.
+
+	  You don't need this unless you're testing the hardware support
+	  of programs using the ALSA API.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-dummy.
 
 config SND_VIRMIDI
 	tristate "Virtual MIDI soundcard"
@@ -39,8 +45,14 @@ config SND_VIRMIDI
 	select SND_TIMER
 	select SND_RAWMIDI
 	help
-	  Say 'Y' or 'M' to include virtual MIDI driver. This driver allows to
-	  connect applications using raw MIDI devices to sequencer.
+	  Say Y here to include the virtual MIDI driver.  This driver
+	  allows to connect applications using raw MIDI devices to
+	  sequencer clients.
+
+	  If you don't know what MIDI is, say N here.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-virmidi.
 
 config SND_MTPAV
 	tristate "MOTU MidiTimePiece AV multiport MIDI"
@@ -48,23 +60,39 @@ config SND_MTPAV
 	select SND_TIMER
 	select SND_RAWMIDI
 	help
-	  Say 'Y' or 'M' to include support for MOTU MidiTimePiece AV multiport
-	  MIDI adapter.
+	  To use a MOTU MidiTimePiece AV multiport MIDI adapter
+	  connected to the parallel port, say Y here and make sure that
+	  the standard parallel port driver isn't used for the port.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-mtpav.
 
 config SND_SERIAL_U16550
-	tristate "UART16550 - MIDI only driver"
+	tristate "UART16550 serial MIDI driver"
 	depends on SND
 	select SND_TIMER
 	select SND_RAWMIDI
 	help
-	  Say 'Y' or 'M' to include support for MIDI serial port driver. It works
-	  with serial UARTs 16550 and better.
+	  To include support for MIDI serial port interfaces, say Y here
+	  and read <file:Documentation/sound/alsa/serial-u16550.txt>.
+	  This driver works with serial UARTs 16550 and better.
+
+	  This driver accesses the serial port hardware directly, so
+	  make sure that the standard serial driver isn't used or
+	  deactivated with setserial before loading this driver.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-serial-u16550.
 
 config SND_MPU401
 	tristate "Generic MPU-401 UART driver"
 	depends on SND
 	select SND_MPU401_UART
 	help
-	  Say 'Y' or 'M' to include support for MPU401 hardware using UART access.
+	  Say Y here to include support for MIDI ports compatible with
+	  the Roland MPU-401 interface in UART mode.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-mpu401.
 
 endmenu
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/drivers/dummy.c linux/sound/drivers/dummy.c
--- linux-2.6.8/sound/drivers/dummy.c	2004-09-15 11:20:37.916433864 +0200
+++ linux/sound/drivers/dummy.c	2004-09-07 19:22:41.000000000 +0200
@@ -557,7 +557,7 @@ DUMMY_VOLUME("CD Volume", 0, MIXER_ADDR_
 DUMMY_CAPSRC("CD Capture Switch", 0, MIXER_ADDR_MASTER)
 };
 
-int __init snd_card_dummy_new_mixer(snd_card_dummy_t * dummy)
+static int __init snd_card_dummy_new_mixer(snd_card_dummy_t * dummy)
 {
 	snd_card_t *card = dummy->card;
 	unsigned int idx;
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/isa/Kconfig linux/sound/isa/Kconfig
--- linux-2.6.8/sound/isa/Kconfig	2004-09-15 11:20:38.039415168 +0200
+++ linux/sound/isa/Kconfig	2004-09-13 12:28:31.000000000 +0200
@@ -10,17 +10,25 @@ config SND_AD1816A
 	select SND_MPU401_UART
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to include support for Analog Devices SoundPort AD1816A or
-	  compatible sound chips.
+	  Say Y here to include support for Analog Devices SoundPort
+	  AD1816A or compatible sound chips.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-ad1816a.
 
 config SND_AD1848
 	tristate "Generic AD1848/CS4248 driver"
 	depends on SND
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to include support for AD1848 (Analog Devices) or CS4248 
-	  (Cirrus Logic - Crystal Semiconductors) chips. Please, for newer chips
-	  from Cirrus Logic, use CS4231, CS4232 or CS4236+ driver.
+	  Say Y here to include support for AD1848 (Analog Devices) or
+	  CS4248 (Cirrus Logic - Crystal Semiconductors) chips.
+	  
+	  For newer chips from Cirrus Logic, use the CS4231, CS4232 or
+	  CS4236+ drivers.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-ad1848.
 
 config SND_CS4231
 	tristate "Generic Cirrus Logic CS4231 driver"
@@ -28,8 +36,11 @@ config SND_CS4231
 	select SND_MPU401_UART
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to include support for CS4231 chips from Cirrus Logic -
-	  Crystal Semiconductors.
+	  Say Y here to include support for CS4231 chips from Cirrus
+	  Logic - Crystal Semiconductors.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-cs4231.
 
 config SND_CS4232
 	tristate "Generic Cirrus Logic CS4232 driver"
@@ -38,8 +49,11 @@ config SND_CS4232
 	select SND_MPU401_UART
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to include support for CS4232 chips from Cirrus Logic -
-	  Crystal Semiconductors.
+	  Say Y here to include support for CS4232 chips from Cirrus
+	  Logic - Crystal Semiconductors.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-cs4232.
 
 config SND_CS4236
 	tristate "Generic Cirrus Logic CS4236+ driver"
@@ -48,8 +62,11 @@ config SND_CS4236
 	select SND_MPU401_UART
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to include support for CS4235,CS4236,CS4237B,CS4238B,CS4239
-	  chips from Cirrus Logic - Crystal Semiconductors.
+	  Say Y to include support for CS4235,CS4236,CS4237B,CS4238B,
+	  CS4239 chips from Cirrus Logic - Crystal Semiconductors.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-cs4236.
 
 config SND_ES968
 	tristate "Generic ESS ES968 driver"
@@ -57,7 +74,10 @@ config SND_ES968
 	select SND_MPU401_UART
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to include support for ESS AudioDrive ES968 chip.
+	  Say Y here to include support for ESS AudioDrive ES968 chips.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-es968.
 
 config SND_ES1688
 	tristate "Generic ESS ES688/ES1688 driver"
@@ -66,7 +86,11 @@ config SND_ES1688
 	select SND_MPU401_UART
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to include support for ESS AudioDrive ES688 or ES1688 chips.
+	  Say Y here to include support for ESS AudioDrive ES688 or
+	  ES1688 chips.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-es1688.
 
 config SND_ES18XX
 	tristate "Generic ESS ES18xx driver"
@@ -75,7 +99,10 @@ config SND_ES18XX
 	select SND_MPU401_UART
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to include support for ESS AudioDrive ES18xx chips.
+	  Say Y here to include support for ESS AudioDrive ES18xx chips.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-es18xx.
 
 config SND_GUS_SYNTH
 	tristate
@@ -87,7 +114,11 @@ config SND_GUSCLASSIC
 	select SND_PCM
 	select SND_GUS_SYNTH
 	help
-	  Say 'Y' or 'M' to include support for Gravis UltraSound Classic soundcard.
+	  Say Y here to include support for Gravis UltraSound Classic
+	  soundcards.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-gusclassic.
 
 config SND_GUSEXTREME
 	tristate "Gravis UltraSound Extreme"
@@ -97,7 +128,11 @@ config SND_GUSEXTREME
 	select SND_PCM
 	select SND_GUS_SYNTH
 	help
-	  Say 'Y' or 'M' to include support for Gravis UltraSound Extreme soundcard.
+	  Say Y here to include support for Gravis UltraSound Extreme
+	  soundcards.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-gusextreme.
 
 config SND_GUSMAX
 	tristate "Gravis UltraSound MAX"
@@ -106,7 +141,11 @@ config SND_GUSMAX
 	select SND_PCM
 	select SND_GUS_SYNTH
 	help
-	  Say 'Y' or 'M' to include support for Gravis UltraSound MAX soundcard.
+	  Say Y here to include support for Gravis UltraSound MAX
+	  soundcards.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-gusmax.
 
 config SND_INTERWAVE
 	tristate "AMD InterWave, Gravis UltraSound PnP"
@@ -115,9 +154,12 @@ config SND_INTERWAVE
 	select SND_PCM
 	select SND_GUS_SYNTH
 	help
-	  Say 'Y' or 'M' to include support for AMD InterWave based soundcards
-	  (Gravis UltraSound Plug & Play, STB SoundRage32, MED3210, Dynasonic Pro,
-	  Panasonic PCA761AW).
+	  Say Y here to include support for AMD InterWave based
+	  soundcards (Gravis UltraSound Plug & Play, STB SoundRage32,
+	  MED3210, Dynasonic Pro, Panasonic PCA761AW).
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-interwave.
 
 config SND_INTERWAVE_STB
 	tristate "AMD InterWave + TEA6330T (UltraSound 32-Pro)"
@@ -126,8 +168,12 @@ config SND_INTERWAVE_STB
 	select SND_PCM
 	select SND_GUS_SYNTH
 	help
-	  Say 'Y' or 'M' to include support for AMD InterWave based soundcards
-	  with TEA6330T bass and treble regulator (UltraSound 32-Pro).
+	  Say Y here to include support for AMD InterWave based
+	  soundcards with a TEA6330T bass and treble regulator
+	  (UltraSound 32-Pro).
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-interwave-stb.
 
 config SND_OPTI92X_AD1848
 	tristate "OPTi 82C92x - AD1848"
@@ -137,8 +183,11 @@ config SND_OPTI92X_AD1848
 	select SND_MPU401_UART
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to include support for Opti92x soundcards equiped with
-	  AD1848 codec.
+	  Say Y here to include support for soundcards based on Opti
+	  82C92x or OTI-601 chips and using an AD1848 codec.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-opti92x-ad1848.
 
 config SND_OPTI92X_CS4231
 	tristate "OPTi 82C92x - CS4231"
@@ -148,8 +197,11 @@ config SND_OPTI92X_CS4231
 	select SND_MPU401_UART
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to include support for Opti92x soundcards equiped with
-	  CS4231 codec.
+	  Say Y here to include support for soundcards based on Opti
+	  82C92x chips and using a CS4231 codec.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-opti92x-cs4231.
 
 config SND_OPTI93X
 	tristate "OPTi 82C93x"
@@ -158,7 +210,11 @@ config SND_OPTI93X
 	select SND_MPU401_UART
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to include support for Opti93x soundcards.
+	  Say Y here to include support for soundcards based on Opti
+	  82C93x chips.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-opti93x.
 
 config SND_SB8
 	tristate "Sound Blaster 1.0/2.0/Pro (8-bit)"
@@ -167,8 +223,11 @@ config SND_SB8
 	select SND_RAWMIDI
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to include support for Sound Blaster 1.0/2.0/Pro (8-bit)
-	  soundcards or 100% compatible from Creative.
+	  Say Y here to include support for Creative Sound Blaster 1.0/
+	  2.0/Pro (8-bit) or 100% compatible soundcards.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-sb8.
 
 config SND_SB16
 	tristate "Sound Blaster 16 (PnP)"
@@ -177,8 +236,11 @@ config SND_SB16
 	select SND_MPU401_UART
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to include support for Sound Blaster 16 (including
-	  Plug and Play version).
+	  Say Y here to include support for Sound Blaster 16 soundcards
+	  (including the Plug and Play version).
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-sb16.
 
 config SND_SBAWE
 	tristate "Sound Blaster AWE (32,64) (PnP)"
@@ -187,16 +249,19 @@ config SND_SBAWE
 	select SND_MPU401_UART
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to include support for Sound Blaster AWE (including
-	  Plug and Play version).
+	  Say Y here to include support for Sound Blaster AWE soundcards
+	  (including the Plug and Play version).
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-sbawe.
 
 config SND_SB16_CSP
 	bool "Sound Blaster 16/AWE CSP support"
 	depends on (SND_SB16 || SND_SBAWE) && (BROKEN || !PPC)
 	help
-	  Say 'Y' to include support for CSP core. This special coprocessor
-	  can do variable tasks like various compression and decompression
-	  algorithms.
+	  Say Y here to include support for the CSP core.  This special
+	  coprocessor can do variable tasks like various compression and
+	  decompression algorithms.
 
 config SND_WAVEFRONT
 	tristate "Turtle Beach Maui,Tropez,Tropez+ (Wavefront)"
@@ -205,8 +270,11 @@ config SND_WAVEFRONT
 	select SND_MPU401_UART
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to include support for Turtle Beach Maui, Tropez
-	  and Tropez+ soundcards based on Wavefront chip.
+	  Say Y here to include support for Turtle Beach Maui, Tropez
+	  and Tropez+ soundcards based on the Wavefront chip.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-wavefront.
 
 config SND_ALS100
 	tristate "Avance Logic ALS100/ALS120"
@@ -215,8 +283,11 @@ config SND_ALS100
 	select SND_MPU401_UART
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to include support for Avance Logic ALS100, ALS110,
-	  ALS120 and ALS200 soundcards.
+	  Say Y here to include support for soundcards based on Avance
+	  Logic ALS100, ALS110, ALS120 and ALS200 chips.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-als100.
 
 config SND_AZT2320
 	tristate "Aztech Systems AZT2320"
@@ -225,14 +296,22 @@ config SND_AZT2320
 	select SND_MPU401_UART
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to include support for Aztech Systems AZT2320 soundcard.
+	  Say Y here to include support for soundcards based on the
+	  Aztech Systems AZT2320 chip.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-azt2320.
 
 config SND_CMI8330
 	tristate "C-Media CMI8330"
 	depends on SND
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to include support for C-Media CMI8330 based soundcards.
+	  Say Y here to include support for soundcards based on the
+	  C-Media CMI8330 chip.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-cmi8330.
 
 config SND_DT019X
 	tristate "Diamond Technologies DT-019X, Avance Logic ALS-007"
@@ -241,8 +320,11 @@ config SND_DT019X
 	select SND_MPU401_UART
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to include support for Diamond Technologies DT-019X and
-	  Avance Logic ALS-007 soundcards.
+	  Say Y here to include support for soundcards based on the
+	  Diamond Technologies DT-019X or Avance Logic ALS-007 chips.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-dt019x.
 
 config SND_OPL3SA2
 	tristate "Yamaha OPL3-SA2/SA3"
@@ -251,14 +333,22 @@ config SND_OPL3SA2
 	select SND_MPU401_UART
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to include support for Yamaha OPL3SA2 or OPL3SA3 chips.
+	  Say Y here to include support for Yamaha OPL3-SA2 and OPL3-SA3
+	  chips.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-opl3sa2.
 
 config SND_SGALAXY
 	tristate "Aztech Sound Galaxy"
 	depends on SND
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to include support for Aztech Sound Galaxy.
+	  Say Y here to include support for Aztech Sound Galaxy
+	  soundcards.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-sgalaxy.
 
 config SND_SSCAPE
 	tristate "Ensoniq SoundScape PnP driver"
@@ -267,7 +357,10 @@ config SND_SSCAPE
 	select SND_MPU401_UART
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to include support for Ensoniq SoundScape PnP
-	  soundcard.
+	  Say Y here to include support for Ensoniq SoundScape PnP
+	  soundcards.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-sscape.
 
 endmenu
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/isa/es18xx.c linux/sound/isa/es18xx.c
--- linux-2.6.8/sound/isa/es18xx.c	2004-09-15 11:20:38.206389784 +0200
+++ linux/sound/isa/es18xx.c	2004-08-26 17:50:31.000000000 +0200
@@ -419,6 +419,11 @@ static void snd_es18xx_rate_set(es18xx_t
 		
 	if ((chip->caps & ES18XX_PCM2) && mode == DAC2) {
 		snd_es18xx_mixer_write(chip, 0x70, bits);
+		/*
+		 * Comment from kernel oss driver:
+		 * FKS: fascinating: 0x72 doesn't seem to work.
+		 */
+		snd_es18xx_write(chip, 0xA2, div0);
 		snd_es18xx_mixer_write(chip, 0x72, div0);
 	} else {
 		snd_es18xx_write(chip, 0xA1, bits);
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/isa/wavefront/wavefront_fx.c linux/sound/isa/wavefront/wavefront_fx.c
--- linux-2.6.8/sound/isa/wavefront/wavefront_fx.c	2004-09-15 11:20:38.347368352 +0200
+++ linux/sound/isa/wavefront/wavefront_fx.c	2004-08-04 11:26:08.000000000 +0200
@@ -34,7 +34,7 @@
 
 /* weird stuff, derived from port I/O tracing with dosemu */
 
-unsigned char page_zero[] __initdata = {
+static unsigned char page_zero[] __initdata = {
 0x01, 0x7c, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf5, 0x00,
 0x11, 0x00, 0x20, 0x00, 0x32, 0x00, 0x40, 0x00, 0x13, 0x00, 0x00,
 0x00, 0x14, 0x02, 0x76, 0x00, 0x60, 0x00, 0x80, 0x02, 0x00, 0x00,
@@ -61,7 +61,7 @@ unsigned char page_zero[] __initdata = {
 0x1d, 0x02, 0xdf
 };
 
-unsigned char page_one[] __initdata = {
+static unsigned char page_one[] __initdata = {
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x19, 0x00,
 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xd8, 0x00, 0x00,
 0x02, 0x20, 0x00, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x01,
@@ -88,7 +88,7 @@ unsigned char page_one[] __initdata = {
 0x60, 0x00, 0x1b
 };
 
-unsigned char page_two[] __initdata = {
+static unsigned char page_two[] __initdata = {
 0xc4, 0x00, 0x44, 0x07, 0x44, 0x00, 0x40, 0x25, 0x01, 0x06, 0xc4,
 0x07, 0x40, 0x25, 0x01, 0x00, 0x46, 0x46, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
@@ -103,7 +103,7 @@ unsigned char page_two[] __initdata = {
 0x46, 0x05, 0x46, 0x07, 0x46, 0x07, 0x44
 };
 
-unsigned char page_three[] __initdata = {
+static unsigned char page_three[] __initdata = {
 0x07, 0x40, 0x00, 0x00, 0x00, 0x47, 0x00, 0x40, 0x00, 0x40, 0x06,
 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
@@ -118,7 +118,7 @@ unsigned char page_three[] __initdata = 
 0x02, 0x00, 0x42, 0x00, 0xc0, 0x00, 0x40
 };
 
-unsigned char page_four[] __initdata = {
+static unsigned char page_four[] __initdata = {
 0x63, 0x03, 0x26, 0x02, 0x2c, 0x00, 0x24, 0x00, 0x2e, 0x02, 0x02,
 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
@@ -133,7 +133,7 @@ unsigned char page_four[] __initdata = {
 0x02, 0x62, 0x02, 0x20, 0x01, 0x21, 0x01
 };
 
-unsigned char page_six[] __initdata = {
+static unsigned char page_six[] __initdata = {
 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x04, 0x00, 0x00, 0x06, 0x00,
 0x00, 0x08, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x0e,
 0x00, 0x00, 0x10, 0x00, 0x00, 0x12, 0x00, 0x00, 0x14, 0x00, 0x00,
@@ -154,7 +154,7 @@ unsigned char page_six[] __initdata = {
 0x80, 0x00, 0x7e, 0x80, 0x80
 };
 
-unsigned char page_seven[] __initdata = {
+static unsigned char page_seven[] __initdata = {
 0x0f, 0xff, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x02, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x0f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
 0x08, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x0f,
@@ -181,7 +181,7 @@ unsigned char page_seven[] __initdata = 
 0x00, 0x02, 0x00
 };
 
-unsigned char page_zero_v2[] __initdata = {
+static unsigned char page_zero_v2[] __initdata = {
 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
@@ -193,7 +193,7 @@ unsigned char page_zero_v2[] __initdata 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
 };
 
-unsigned char page_one_v2[] __initdata = {
+static unsigned char page_one_v2[] __initdata = {
 0x01, 0xc0, 0x01, 0xfa, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
@@ -205,21 +205,21 @@ unsigned char page_one_v2[] __initdata =
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
 };
 
-unsigned char page_two_v2[] __initdata = {
+static unsigned char page_two_v2[] __initdata = {
 0x46, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00
 };
-unsigned char page_three_v2[] __initdata = {
+static unsigned char page_three_v2[] __initdata = {
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00
 };
-unsigned char page_four_v2[] __initdata = {
+static unsigned char page_four_v2[] __initdata = {
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
@@ -227,7 +227,7 @@ unsigned char page_four_v2[] __initdata 
 0x00, 0x00, 0x00, 0x00
 };
 
-unsigned char page_seven_v2[] __initdata = {
+static unsigned char page_seven_v2[] __initdata = {
 0x0f, 0xff, 0x0f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
@@ -239,7 +239,7 @@ unsigned char page_seven_v2[] __initdata
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
 };
 
-unsigned char mod_v2[] __initdata = {
+static unsigned char mod_v2[] __initdata = {
 0x01, 0x00, 0x02, 0x00, 0x01, 0x01, 0x02, 0x00, 0x01, 0x02, 0x02,
 0x00, 0x01, 0x03, 0x02, 0x00, 0x01, 0x04, 0x02, 0x00, 0x01, 0x05,
 0x02, 0x00, 0x01, 0x06, 0x02, 0x00, 0x01, 0x07, 0x02, 0x00, 0xb0,
@@ -269,7 +269,7 @@ unsigned char mod_v2[] __initdata = {
 0x02, 0x01, 0x01, 0x04, 0x02, 0x01, 0x01, 0x05, 0x02, 0x01, 0x01,
 0x06, 0x02, 0x01, 0x01, 0x07, 0x02, 0x01
 };
-unsigned char coefficients[] __initdata = {
+static unsigned char coefficients[] __initdata = {
 0x07, 0x46, 0x00, 0x00, 0x07, 0x49, 0x00, 0x00, 0x00, 0x4b, 0x03,
 0x11, 0x00, 0x4d, 0x01, 0x32, 0x07, 0x46, 0x00, 0x00, 0x07, 0x49,
 0x00, 0x00, 0x07, 0x40, 0x00, 0x00, 0x07, 0x41, 0x00, 0x00, 0x01,
@@ -305,14 +305,14 @@ unsigned char coefficients[] __initdata 
 0x06, 0x6c, 0x4c, 0x6c, 0x06, 0x50, 0x52, 0xe2, 0x06, 0x42, 0x02,
 0xba
 };
-unsigned char coefficients2[] __initdata = {
+static unsigned char coefficients2[] __initdata = {
 0x07, 0x46, 0x00, 0x00, 0x07, 0x49, 0x00, 0x00, 0x07, 0x45, 0x0f,
 0xff, 0x07, 0x48, 0x0f, 0xff, 0x07, 0x7b, 0x04, 0xcc, 0x07, 0x7d,
 0x04, 0xcc, 0x07, 0x7c, 0x00, 0x00, 0x07, 0x7e, 0x00, 0x00, 0x07,
 0x46, 0x00, 0x00, 0x07, 0x49, 0x00, 0x00, 0x07, 0x47, 0x00, 0x00,
 0x07, 0x4a, 0x00, 0x00, 0x07, 0x4c, 0x00, 0x00, 0x07, 0x4e, 0x00, 0x00
 };
-unsigned char coefficients3[] __initdata = {
+static unsigned char coefficients3[] __initdata = {
 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x28, 0x00, 0x51, 0x00,
 0x51, 0x00, 0x7a, 0x00, 0x7a, 0x00, 0xa3, 0x00, 0xa3, 0x00, 0xcc,
 0x00, 0xcc, 0x00, 0xf5, 0x00, 0xf5, 0x01, 0x1e, 0x01, 0x1e, 0x01,
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/parisc/Kconfig linux/sound/parisc/Kconfig
--- linux-2.6.8/sound/parisc/Kconfig	2004-08-14 07:37:14.000000000 +0200
+++ linux/sound/parisc/Kconfig	2004-09-13 12:28:33.000000000 +0200
@@ -8,7 +8,10 @@ config SND_HARMONY
 	depends on SND
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to include support for Harmony/Vivace soundchip
+	  Say Y here to include support for the Harmony/Vivace soundchip
 	  on HP712s, 715/new and many other GSC based machines.
 
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-harmony.
+
 endmenu
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/parisc/harmony.c linux/sound/parisc/harmony.c
--- linux-2.6.8/sound/parisc/harmony.c	2004-09-15 11:20:40.782998080 +0200
+++ linux/sound/parisc/harmony.c	2004-07-30 15:22:07.000000000 +0200
@@ -6,7 +6,7 @@
  *
  *	Harmony is found in HP 712s, 715/new and many other GSC based machines.
  *	On older 715 machines you'll find the technically identical chip 
- *	called 'Vivace'. Both Harmony and Vivace are supported by this driver.
+ *	called 'Vivace'. Both Harmony and Vicace are supported by this driver.
  *
  *  this ALSA driver is based on OSS driver by:
  *	Copyright 2000 (c) Linuxcare Canada, Alex deVries <alex@linuxcare.com>
@@ -43,7 +43,7 @@
  * to be recorded is put in RNXTADD. There is 2 read-only registers, PCURADD and 
  * RCURADD that provides adress of current page.
  * 
- * Harmony has no way to control full duplex or half duplex mode. It means
+ * Harmony has no way to controll full duplex or half duplex mode. It means
  * that we always need to provide adresses of playback and capture data, even
  * when this is not needed. That's why we statically alloc one graveyard
  * buffer (to put recorded data in play-only mode) and a silence buffer.
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/pci/Kconfig linux/sound/pci/Kconfig
--- linux-2.6.8/sound/pci/Kconfig	2004-09-15 11:20:40.784997776 +0200
+++ linux/sound/pci/Kconfig	2004-09-13 14:59:02.000000000 +0200
@@ -8,27 +8,41 @@ config SND_AC97_CODEC
 	select SND_PCM
 
 config SND_ALI5451
-	tristate "ALi PCI Audio M5451"
+	tristate "ALi M5451 PCI Audio Controller"
 	depends on SND
 	select SND_MPU401_UART
 	select SND_AC97_CODEC
 	help
-	  Say 'Y' or 'M' to include support for ALI PCI Audio M5451 sound core.
+	  Say Y here to include support for the integrated AC97 sound
+	  device on motherboards using the ALi M5451 Audio Controller
+	  (M1535/M1535D/M1535+/M1535D+ south bridges).  Newer chipsets
+	  use the "Intel/SiS/nVidia/AMD/ALi AC97 Controller" driver.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-ali5451.
 
 config SND_ATIIXP
-	tristate "ATI IXP 150/200/250/300"
+	tristate "ATI IXP AC97 Controller"
 	depends on SND
 	select SND_AC97_CODEC
 	help
-	  Say 'Y' or 'M' to include support for ATI IXP 150/200/250/300 AC97 controller.
+	  Say Y here to include support for the integrated AC97 sound
+	  device on motherboards with ATI chipsets (ATI IXP 150/200/250/
+	  300/400).
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-atiixp.
 
 config SND_ATIIXP_MODEM
-	tristate "ATI IXP 150/200/250 Modem"
+	tristate "ATI IXP Modem"
 	depends on SND
 	select SND_AC97_CODEC
 	help
-	  Say 'Y' or 'M' to include support for ATI IXP 150/200/250 AC97 modem
-	  controller.
+	  Say Y here to include support for the integrated MC97 modem on
+	  motherboards with ATI chipsets (ATI IXP 150/200/250).
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-atiixp-modem.
 
 config SND_AU8810
         tristate "Aureal Advantage"
@@ -36,10 +50,14 @@ config SND_AU8810
 	select SND_MPU401_UART
 	select SND_AC97_CODEC
         help
-          Say 'Y' or 'M' to include support for Aureal Advantage soundcards.
-          Supported features: Hardware Mixer, SRC, EQ and SPDIF output.
+	  Say Y here to include support for Aureal Advantage soundcards.
+
+	  Supported features: Hardware Mixer, SRC, EQ and SPDIF output.
           3D support code is in place, but not yet useable. For more info, 
           email the ALSA developer list, or mjander@users.sourceforge.net.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-au8810.
  
 config SND_AU8820
         tristate "Aureal Vortex"
@@ -47,9 +65,13 @@ config SND_AU8820
 	select SND_MPU401_UART
 	select SND_AC97_CODEC
         help
-          Say 'Y' or 'M' to include support for Aureal Vortex soundcards.
+	  Say Y here to include support for Aureal Vortex soundcards.
+
           Supported features: Hardware Mixer and SRC. For more info, email 
           the ALSA developer list, or mjander@users.sourceforge.net.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-au8820.
  
 config SND_AU8830
         tristate "Aureal Vortex 2"
@@ -57,10 +79,14 @@ config SND_AU8830
 	select SND_MPU401_UART
 	select SND_AC97_CODEC
         help
-          Say 'Y' or 'M' to include support for Aureal Vortex 2 soundcards.
+	  Say Y here to include support for Aureal Vortex 2 soundcards.
+
           Supported features: Hardware Mixer, SRC, EQ and SPDIF output.
           3D support code is in place, but not yet useable. For more info, 
           email the ALSA developer list, or mjander@users.sourceforge.net.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-au8830.
  
 config SND_AZT3328
 	tristate "Aztech AZF3328 / PCI168 (EXPERIMENTAL)"
@@ -69,15 +95,22 @@ config SND_AZT3328
 	select SND_MPU401_UART
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to include support for Aztech AZF3328 (PCI168) soundcards.
+	  Say Y here to include support for Aztech AZF3328 (PCI168)
+	  soundcards.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-azt3328.
 
 config SND_BT87X
         tristate "Bt87x Audio Capture"
         depends on SND
 	select SND_PCM
         help
-          Say 'Y' or 'M' to include support for recording audio from TV cards
-          based on Brooktree Bt878/Bt879 chips.
+	  Say Y here to include support for recording audio from TV
+	  cards based on Brooktree Bt878/Bt879 chips.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-bt87x.
 
 config SND_CS46XX
 	tristate "Cirrus Logic (Sound Fusion) CS4280/CS461x/CS462x/CS463x"
@@ -85,14 +118,19 @@ config SND_CS46XX
 	select SND_RAWMIDI
 	select SND_AC97_CODEC
 	help
-	  Say 'Y' or 'M' to include support for Cirrus Logic CS4610 / CS4612 /
-	  CS4614 / CS4615 / CS4622 / CS4624 / CS4630 / CS4280 chips.
+	  Say Y here to include support for Cirrus Logic CS4610/CS4612/
+	  CS4614/CS4615/CS4622/CS4624/CS4630/CS4280 chips.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-cs46xx.
 
 config SND_CS46XX_NEW_DSP
 	bool "Cirrus Logic (Sound Fusion) New DSP support (EXPERIMENTAL)"
 	depends on SND_CS46XX && EXPERIMENTAL
 	help
-	  Say 'Y' to use a new DSP image for SPDIF and dual codecs.
+	  Say Y here to use a new DSP image for SPDIF and dual codecs.
+
+	  This works better than the old code, so say Y.
 
 config SND_CS4281
 	tristate "Cirrus Logic (Sound Fusion) CS4281"
@@ -101,24 +139,37 @@ config SND_CS4281
 	select SND_RAWMIDI
 	select SND_AC97_CODEC
 	help
-	  Say 'Y' or 'M' to include support for Cirrus Logic CS4281.
+	  Say Y here to include support for Cirrus Logic CS4281 chips.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-cs4281.
 
 config SND_EMU10K1
-	tristate "EMU10K1 (SB Live! & Audigy, E-mu APS)"
+	tristate "Emu10k1 (SB Live!, Audigy, E-mu APS)"
 	depends on SND
 	select SND_HWDEP
 	select SND_RAWMIDI
 	select SND_AC97_CODEC
 	help
-	  Say 'Y' or 'M' to include support for Sound Blaster PCI 512, Live!,
-	  Audigy and E-mu APS (partially supported).
+	  Say Y to include support for Sound Blaster PCI 512, Live!,
+	  Audigy and E-mu APS (partially supported) soundcards.
+
+	  The confusing multitude of mixer controls is documented in
+	  <file:Documentation/sound/alsa/SB-Live-mixer.txt> and
+	  <file:Documentation/sound/alsa/Audigy-mixer.txt>.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-emu10k1.
 
 config SND_KORG1212
 	tristate "Korg 1212 IO"
 	depends on SND
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to include support for Korg 1212IO.
+	  Say Y here to include support for Korg 1212IO soundcards.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-korg1212.
 
 config SND_MIXART
 	tristate "Digigram miXart"
@@ -126,38 +177,55 @@ config SND_MIXART
 	select SND_HWDEP
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to include support for Digigram miXart soundcard.
+	  If you want to use Digigram miXart soundcards, say Y here and
+	  read <file:Documentation/sound/alsa/MIXART.txt>.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-mixart.
 
 config SND_NM256
 	tristate "NeoMagic NM256AV/ZX"
 	depends on SND
 	select SND_AC97_CODEC
 	help
-	  Say 'Y' or 'M' to include support for NeoMagic NM256AV/ZX chips.
+	  Say Y here to include support for NeoMagic NM256AV/ZX chips.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-nm256.
 
 config SND_RME32
 	tristate "RME Digi32, 32/8, 32 PRO"
 	depends on SND
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to include support for RME Digi32, Digi32 PRO and
-	  Digi32/8 (Sek'd Prodif32, Prodif96 and Prodif Gold) audio devices.
+	  Say Y to include support for RME Digi32, Digi32 PRO and
+	  Digi32/8 (Sek'd Prodif32, Prodif96 and Prodif Gold) audio
+	  devices.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-rme32.
 
 config SND_RME96
 	tristate "RME Digi96, 96/8, 96/8 PRO"
 	depends on SND
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to include support for RME Digi96, Digi96/8 and
-	  Digi96/8 PRO/PAD/PST.
+	  Say Y here to include support for RME Digi96, Digi96/8 and
+	  Digi96/8 PRO/PAD/PST soundcards.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-rme96.
 
 config SND_RME9652
 	tristate "RME Digi9652 (Hammerfall)"
 	depends on SND
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to include support for RME Hammerfall (RME Digi9652 /
-	  Digi9636) soundcards.
+	  Say Y here to include support for RME Hammerfall (RME
+	  Digi9652/Digi9636) soundcards.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-rme9652.
 
 config SND_HDSP
 	tristate "RME Hammerfall DSP Audio"
@@ -166,17 +234,23 @@ config SND_HDSP
 	select SND_RAWMIDI
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to include support for RME Hammerfall DSP Audio
+	  Say Y here to include support for RME Hammerfall DSP Audio
 	  soundcards.
 
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-hdsp.
+
 config SND_TRIDENT
 	tristate "Trident 4D-Wave DX/NX; SiS 7018"
 	depends on SND
 	select SND_MPU401_UART
 	select SND_AC97_CODEC
 	help
-	  Say 'Y' or 'M' to include support for Trident 4D-Wave DX/NX and
-	  SiS 7018 soundcards.
+	  Say Y here to include support for soundcards based on Trident
+	  4D-Wave DX/NX or SiS 7018 chips.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-trident.
 
 config SND_YMFPCI
 	tristate "Yamaha YMF724/740/744/754"
@@ -185,9 +259,12 @@ config SND_YMFPCI
 	select SND_MPU401_UART
 	select SND_AC97_CODEC
 	help
-	  Say 'Y' or 'M' to include support for Yamaha PCI audio chips - 
+	  Say Y here to include support for Yamaha PCI audio chips -
 	  YMF724, YMF724F, YMF740, YMF740C, YMF744, YMF754.
 
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-ymfpci.
+
 config SND_ALS4000
 	tristate "Avance Logic ALS4000"
 	depends on SND
@@ -195,7 +272,11 @@ config SND_ALS4000
 	select SND_MPU401_UART
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to include support for Avance Logic ALS4000.
+	  Say Y here to include support for soundcards based on Avance Logic
+	  ALS4000 chips.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-als4000.
 
 config SND_CMIPCI
 	tristate "C-Media 8738, 8338"
@@ -204,8 +285,12 @@ config SND_CMIPCI
 	select SND_MPU401_UART
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to include support for C-Media CMI8338 and 8738 PCI
-	  soundcards.
+	  If you want to use soundcards based on C-Media CMI8338 or CMI8738
+	  chips, say Y here and read
+	  <file:Documentation/sound/alsa/CMIPCI.txt>.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-cmipci.
 
 config SND_ENS1370
 	tristate "(Creative) Ensoniq AudioPCI 1370"
@@ -213,7 +298,10 @@ config SND_ENS1370
 	select SND_RAWMIDI
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to include support for Ensoniq AudioPCI ES1370.
+	  Say Y here to include support for Ensoniq AudioPCI ES1370 chips.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-ens1370.
 
 config SND_ENS1371
 	tristate "(Creative) Ensoniq AudioPCI 1371/1373"
@@ -221,9 +309,12 @@ config SND_ENS1371
 	select SND_RAWMIDI
 	select SND_AC97_CODEC
 	help
-	  Say 'Y' or 'M' to include support for Ensoniq AudioPCI ES1371 and
+	  Say Y here to include support for Ensoniq AudioPCI ES1371 chips and
 	  Sound Blaster PCI 64 or 128 soundcards.
 
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-ens1371.
+
 config SND_ES1938
 	tristate "ESS ES1938/1946/1969 (Solo-1)"
 	depends on SND
@@ -231,8 +322,11 @@ config SND_ES1938
 	select SND_MPU401_UART
 	select SND_AC97_CODEC
 	help
-	  Say 'Y' or 'M' to include support for ESS Solo-1 (ES1938, ES1946, ES1969)
-	  soundcard.
+	  Say Y here to include support for soundcards based on ESS Solo-1
+	  (ES1938, ES1946, ES1969) chips.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-es1938.
 
 config SND_ES1968
 	tristate "ESS ES1968/1978 (Maestro-1/2/2E)"
@@ -240,14 +334,22 @@ config SND_ES1968
 	select SND_MPU401_UART
 	select SND_AC97_CODEC
 	help
-	  Say 'Y' or 'M' to include support for ESS Maestro 1/2/2E.
+	  Say Y here to include support for soundcards based on ESS Maestro
+	  1/2/2E chips.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-es1968.
 
 config SND_MAESTRO3
 	tristate "ESS Allegro/Maestro3"
 	depends on SND
 	select SND_AC97_CODEC
 	help
-	  Say 'Y' or 'M' to include support for ESS Maestro 3 (Allegro) soundcard.
+	  Say Y here to include support for soundcards based on ESS Maestro 3
+	  (Allegro) chips.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-maestro3.
 
 config SND_FM801
 	tristate "ForteMedia FM801"
@@ -256,15 +358,23 @@ config SND_FM801
 	select SND_MPU401_UART
 	select SND_AC97_CODEC
 	help
-	  Say 'Y' or 'M' to include support for ForteMedia FM801 based soundcards.
+	  Say Y here to include support for soundcards based on the ForteMedia
+	  FM801 chip.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-fm801.
 
 config SND_FM801_TEA575X
 	tristate "ForteMedia FM801 + TEA5757 tuner"
 	depends on SND_FM801
         select VIDEO_DEV
 	help
-	  Say 'Y' or 'M' to include support for ForteMedia FM801 based soundcards
-          with TEA5757 tuner connected to GPIO1-3 pins (Media Forte SF256-PCS-02).
+	  Say Y here to include support for soundcards based on the ForteMedia
+	  FM801 chip with a TEA5757 tuner connected to GPIO1-3 pins (Media
+	  Forte SF256-PCS-02).
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-fm801-tea575x.
 
 config SND_ICE1712
 	tristate "ICEnsemble ICE1712 (Envy24)"
@@ -272,10 +382,16 @@ config SND_ICE1712
 	select SND_MPU401_UART
 	select SND_AC97_CODEC
 	help
-	  Say 'Y' or 'M' to include support for ICE1712 (Envy24) based soundcards.
-	  Currently supported hardware is: MidiMan M Audio - Delta 1010(LT), Dio 2496,
-	  Delta 66/44, Audiophile 24/96; Hoontech SoundTrack DSP 24 (Value);
-	  TerraTec - EWX 24/96, EWS 88MT, EWS 88D, DMX 6Fire.
+	  Say Y here to include support for soundcards based on the
+	  ICE1712 (Envy24) chip.
+
+	  Currently supported hardware is: M-Audio Delta 1010(LT),
+	  DiO 2496, 66, 44, 410, Audiophile 24/96; Digigram VX442;
+	  TerraTec EWX 24/96, EWS 88MT, 88D, DMX 6Fire, Phase 88;
+	  Hoontech SoundTrack DSP 24/Value/Media7.1; Event EZ8.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-ice1712.
 
 config SND_ICE1724
 	tristate "ICE/VT1724/1720 (Envy24HT/PT)"
@@ -283,27 +399,40 @@ config SND_ICE1724
 	select SND_MPU401_UART
 	select SND_AC97_CODEC
 	help
-	  Say 'Y' or 'M' to include support for ICE/VT1724/1720 (Envy24HT/PT) based
-	  soundcards.
-	  Currently supported hardware is: MidiMan M Audio - Revolution 7.1,
-	  AMP Ltd AUDIO2000, Terratec Aureon 5.1 Sky/7.1, AudioTrak Prodigy 7.1.
+	  Say Y here to include support for soundcards based on
+	  ICE/VT1724/1720 (Envy24HT/PT) chips.
+
+	  Currently supported hardware is: AMP AUDIO2000; M-Audio
+	  Revolution 7.1; TerraTec Aureon 5.1 Sky, 7.1 Space/Universe;
+	  AudioTrak Prodigy 7.1; Pontis MS300; Albatron K8X800 Pro II;
+	  Chaintech ZNF3-150/250.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-ice1724.
 
 config SND_INTEL8X0
-	tristate "Intel i8x0/MX440, SiS 7012; Ali 5455; NForce Audio; AMD768/8111"
+	tristate "Intel/SiS/nVidia/AMD/ALi AC97 Controller"
 	depends on SND
-	select SND_MPU401_UART
 	select SND_AC97_CODEC
 	help
-	  Say 'Y' or 'M' to include support for Intel8x0 based soundcards,
-	  SiS 7012, AMD768/8111, NVidia NForce and ALi 5455 chips.
+	  Say Y here to include support for the integrated AC97 sound
+	  device on motherboards with Intel/SiS/nVidia/AMD chipsets, or
+	  ALi chipsets using the M5455 Audio Controller.  (There is a
+	  separate driver for ALi M5451 Audio Controllers.)
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-intel8x0.
 
 config SND_INTEL8X0M
-	tristate "Intel i8x0/MX440; SiS 7013; NForce; AMD768/8111 modems (EXPERIMENTAL)"
+	tristate "Intel/SiS/nVidia/AMD MC97 Modem (EXPERIMENTAL)"
 	depends on SND && EXPERIMENTAL
 	select SND_AC97_CODEC
 	help
-	  Say 'Y' or 'M' to include support for Intel8x0, SiS 7013, NVidia NForce
-          and AMD768/8111 based modems.
+	  Say Y here to include support for the integrated MC97 modem on
+	  motherboards with Intel/SiS/nVidia/AMD chipsets.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-intel8x0m.
 
 config SND_SONICVIBES
 	tristate "S3 SonicVibes"
@@ -312,22 +441,33 @@ config SND_SONICVIBES
 	select SND_MPU401_UART
 	select SND_AC97_CODEC
 	help
-	  Say 'Y' or 'M' to include support for S3 SonicVibes based soundcards.
+	  Say Y here to include support for soundcards based on the S3
+	  SonicVibes chip.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-sonicvibes.
 
 config SND_VIA82XX
-	tristate "VIA 82C686A/B, 8233 South Bridge"
+	tristate "VIA 82C686A/B, 8233/8235 AC97 Controller"
 	depends on SND
 	select SND_MPU401_UART
 	select SND_AC97_CODEC
 	help
-	  Say 'Y' or 'M' to include support for VIA VT82C686A/B, VT8233 South Bridge.
+	  Say Y here to include support for the integrated AC97 sound
+	  device on motherboards with VIA chipsets.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-via82xx.
 
 config SND_VX222
 	tristate "Digigram VX222"
 	depends on SND
 	select SND_VX_LIB
 	help
-	  Say 'Y' or 'M' to include support for Digigram VX222 soundcards.
+	  Say Y here to include support for Digigram VX222 soundcards.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-vx222.
 
 endmenu
 
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/pci/ac97/ac97_codec.c linux/sound/pci/ac97/ac97_codec.c
--- linux-2.6.8/sound/pci/ac97/ac97_codec.c	2004-09-15 11:20:40.795996104 +0200
+++ linux/sound/pci/ac97/ac97_codec.c	2004-09-13 12:28:33.000000000 +0200
@@ -749,6 +749,14 @@ AC97_DOUBLE("Surround Playback Volume", 
 static const snd_kcontrol_new_t snd_ac97_control_eapd =
 AC97_SINGLE("External Amplifier", AC97_POWERDOWN, 15, 1, 1);
 
+/* change the existing EAPD control as inverted */
+static void set_inv_eapd(ac97_t *ac97, snd_kcontrol_t *kctl)
+{
+	kctl->private_value = AC97_SINGLE_VALUE(AC97_POWERDOWN, 15, 1, 0);
+	snd_ac97_update_bits(ac97, AC97_POWERDOWN, (1<<15), (1<<15)); /* EAPD up */
+	ac97->scaps |= AC97_SCAP_INV_EAPD;
+}
+
 static int snd_ac97_spdif_mask_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
@@ -1559,7 +1567,7 @@ static int snd_ac97_mixer_build(ac97_t *
 			return err;
 	}
 
-	snd_ac97_write_cache(ac97, AC97_GENERAL_PURPOSE, 0x0000);
+	snd_ac97_update_bits(ac97, AC97_GENERAL_PURPOSE, ~AC97_GP_DRSS_MASK, 0x0000);
 
 	/* build 3D controls */
 	if (ac97->build_ops && ac97->build_ops->build_3d) {
@@ -1610,7 +1618,12 @@ static int snd_ac97_mixer_build(ac97_t *
 			return err;
 
 	if (snd_ac97_try_bit(ac97, AC97_POWERDOWN, 15)) {
-		if ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_control_eapd, ac97))) < 0)
+		kctl = snd_ac97_cnew(&snd_ac97_control_eapd, ac97);
+		if (! kctl)
+			return -ENOMEM;
+		if (ac97->scaps & AC97_SCAP_INV_EAPD)
+			set_inv_eapd(ac97, kctl);
+		if ((err = snd_ctl_add(card, kctl)) < 0)
 			return err;
 	}
 
@@ -1646,6 +1659,9 @@ static void snd_ac97_determine_rates(ac9
 {
 	unsigned int result = 0;
 
+	if ((ac97->ext_id & AC97_EI_DRA) && reg == AC97_PCM_FRONT_DAC_RATE)
+		snd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS,
+				     AC97_EA_DRA, 0);
 	/* test a non-standard rate */
 	if (snd_ac97_test_rate(ac97, reg, shadow_reg, 11000))
 		result |= SNDRV_PCM_RATE_CONTINUOUS;
@@ -1664,6 +1680,23 @@ static void snd_ac97_determine_rates(ac9
 		result |= SNDRV_PCM_RATE_44100;
 	if (snd_ac97_test_rate(ac97, reg, shadow_reg, 48000))
 		result |= SNDRV_PCM_RATE_48000;
+	if ((ac97->flags & AC97_DOUBLE_RATE) &&
+	    reg == AC97_PCM_FRONT_DAC_RATE) {
+		/* test standard double rates */
+		snd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS,
+				     AC97_EA_DRA, AC97_EA_DRA);
+		if (snd_ac97_test_rate(ac97, reg, shadow_reg, 64000 / 2))
+			result |= SNDRV_PCM_RATE_64000;
+		if (snd_ac97_test_rate(ac97, reg, shadow_reg, 88200 / 2))
+			result |= SNDRV_PCM_RATE_88200;
+		if (snd_ac97_test_rate(ac97, reg, shadow_reg, 96000 / 2))
+			result |= SNDRV_PCM_RATE_96000;
+		/* some codecs don't support variable double rates */
+		if (!snd_ac97_test_rate(ac97, reg, shadow_reg, 76100 / 2))
+			result &= ~SNDRV_PCM_RATE_CONTINUOUS;
+		snd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS,
+				     AC97_EA_DRA, 0);
+	}
 	*r_result = result;
 }
 
@@ -1726,6 +1759,22 @@ void snd_ac97_get_name(ac97_t *ac97, uns
 	sprintf(name + strlen(name), " id %x", id & 0xff);
 }
 
+/**
+ * snd_ac97_get_short_name - retrieve codec name
+ * @ac97: the codec instance
+ *
+ * Returns the short identifying name of the codec.
+ */
+const char *snd_ac97_get_short_name(ac97_t *ac97)
+{
+	const ac97_codec_id_t *pid;
+
+	for (pid = snd_ac97_codec_ids; pid->id; pid++)
+		if (pid->id == (ac97->id & pid->mask))
+			return pid->name;
+	return "unknown codec";
+}
+
 
 /* wait for a while until registers are accessible after RESET
  * return 0 if ok, negative not ready
@@ -1733,9 +1782,10 @@ void snd_ac97_get_name(ac97_t *ac97, uns
 static int ac97_reset_wait(ac97_t *ac97, int timeout, int with_modem)
 {
 	unsigned long end_time;
+	unsigned short val;
+
 	end_time = jiffies + timeout;
 	do {
-		unsigned short ext_mid;
 		
 		/* use preliminary reads to settle the communication */
 		snd_ac97_read(ac97, AC97_RESET);
@@ -1743,17 +1793,24 @@ static int ac97_reset_wait(ac97_t *ac97,
 		snd_ac97_read(ac97, AC97_VENDOR_ID2);
 		/* modem? */
 		if (with_modem) {
-			ext_mid = snd_ac97_read(ac97, AC97_EXTENDED_MID);
-			if (ext_mid != 0xffff && (ext_mid & 1) != 0)
+			val = snd_ac97_read(ac97, AC97_EXTENDED_MID);
+			if (val != 0xffff && (val & 1) != 0)
+				return 0;
+		}
+		if (ac97->scaps & AC97_SCAP_DETECT_BY_VENDOR) {
+			/* probably only Xbox issue - all registers are read as zero */
+			val = snd_ac97_read(ac97, AC97_VENDOR_ID1);
+			if (val != 0 && val != 0xffff)
+				return 0;
+		} else {
+			/* because the PCM or MASTER volume registers can be modified,
+			 * the REC_GAIN register is used for tests
+			 */
+			/* test if we can write to the record gain volume register */
+			snd_ac97_write_cache(ac97, AC97_REC_GAIN, 0x8a05);
+			if ((snd_ac97_read(ac97, AC97_REC_GAIN) & 0x7fff) == 0x0a05)
 				return 0;
 		}
-		/* because the PCM or MASTER volume registers can be modified,
-		 * the REC_GAIN register is used for tests
-		 */
-		/* test if we can write to the record gain volume register */
-		snd_ac97_write_cache(ac97, AC97_REC_GAIN, 0x8a05);
-		if ((snd_ac97_read(ac97, AC97_REC_GAIN) & 0x7fff) == 0x0a05)
-			return 0;
 		set_current_state(TASK_UNINTERRUPTIBLE);
 		schedule_timeout(1);
 	} while (time_after_eq(end_time, jiffies));
@@ -2006,11 +2063,20 @@ int snd_ac97_mixer(ac97_bus_t *bus, ac97
 		ac97->addr = (ac97->ext_mid & AC97_MEI_ADDR_MASK) >> AC97_MEI_ADDR_SHIFT;
 	if (ac97->ext_id & 0x0189)	/* L/R, MIC, SDAC, LDAC VRA support */
 		snd_ac97_write_cache(ac97, AC97_EXTENDED_STATUS, ac97->ext_id & 0x0189);
+	if ((ac97->ext_id & AC97_EI_DRA) && bus->dra) {
+		/* Intel controllers require double rate data to be put in
+		 * slots 7+8, so let's hope the codec supports it. */
+		snd_ac97_update_bits(ac97, AC97_GENERAL_PURPOSE, AC97_GP_DRSS_MASK, AC97_GP_DRSS_78);
+		if ((snd_ac97_read(ac97, AC97_GENERAL_PURPOSE) & AC97_GP_DRSS_MASK) == AC97_GP_DRSS_78)
+			ac97->flags |= AC97_DOUBLE_RATE;
+	}
 	if (ac97->ext_id & AC97_EI_VRA) {	/* VRA support */
 		snd_ac97_determine_rates(ac97, AC97_PCM_FRONT_DAC_RATE, 0, &ac97->rates[AC97_RATES_FRONT_DAC]);
 		snd_ac97_determine_rates(ac97, AC97_PCM_LR_ADC_RATE, 0, &ac97->rates[AC97_RATES_ADC]);
 	} else {
 		ac97->rates[AC97_RATES_FRONT_DAC] = SNDRV_PCM_RATE_48000;
+		if (ac97->flags & AC97_DOUBLE_RATE)
+			ac97->rates[AC97_RATES_FRONT_DAC] |= SNDRV_PCM_RATE_96000;
 		ac97->rates[AC97_RATES_ADC] = SNDRV_PCM_RATE_48000;
 	}
 	if (ac97->ext_id & AC97_EI_SPDIF) {
@@ -2317,9 +2383,9 @@ int snd_ac97_swap_ctl(ac97_t *ac97, cons
 
 static int swap_headphone(ac97_t *ac97, int remove_master)
 {
+	if (ctl_find(ac97, "Headphone Playback Switch", NULL) == NULL)
+		return -ENOENT;
 	if (remove_master) {
-		if (ctl_find(ac97, "Headphone Playback Switch", NULL) == NULL)
-			return 0;
 		snd_ac97_remove_ctl(ac97, "Master Playback", "Switch");
 		snd_ac97_remove_ctl(ac97, "Master Playback", "Volume");
 	} else
@@ -2330,9 +2396,9 @@ static int swap_headphone(ac97_t *ac97, 
 
 static int swap_surround(ac97_t *ac97)
 {
-	/* FIXME: error checks.. */
-	snd_ac97_swap_ctl(ac97, "Master Playback", "Surround Playback", "Switch");
-	snd_ac97_swap_ctl(ac97, "Master Playback", "Surround Playback", "Volume");
+	if (snd_ac97_swap_ctl(ac97, "Master Playback", "Surround Playback", "Switch") ||
+	    snd_ac97_swap_ctl(ac97, "Master Playback", "Surround Playback", "Volume"))
+		return -ENOENT;
 	return 0;
 }
 
@@ -2363,6 +2429,15 @@ static int tune_alc_jack(ac97_t *ac97)
 	return snd_ctl_add(ac97->bus->card, snd_ac97_cnew(&snd_ac97_alc_jack_detect, ac97));
 }
 
+static int tune_inv_eapd(ac97_t *ac97)
+{
+	snd_kcontrol_t *kctl = ctl_find(ac97, "External Amplifier", NULL);
+	if (! kctl)
+		return -ENOENT;
+	set_inv_eapd(ac97, kctl);
+	return 0;
+}
+
 static int apply_quirk(ac97_t *ac97, int quirk)
 {
 	switch (quirk) {
@@ -2378,6 +2453,8 @@ static int apply_quirk(ac97_t *ac97, int
 		return tune_ad_sharing(ac97);
 	case AC97_TUNE_ALC_JACK:
 		return tune_alc_jack(ac97);
+	case AC97_TUNE_INV_EAPD:
+		return tune_inv_eapd(ac97);
 	}
 	return -EINVAL;
 }
@@ -2413,6 +2490,8 @@ int snd_ac97_tune_hardware(ac97_t *ac97,
 			continue;
 		if ((! quirk->mask && quirk->device == ac97->subsystem_device) ||
 		    quirk->device == (quirk->mask & ac97->subsystem_device)) {
+			if (quirk->codec_id && quirk->codec_id != ac97->id)
+				continue;
 			snd_printdd("ac97 quirk for %s (%04x:%04x)\n", quirk->name, ac97->subsystem_vendor, ac97->subsystem_device);
 			result = apply_quirk(ac97, quirk->type);
 			if (result < 0)
@@ -2433,11 +2512,13 @@ EXPORT_SYMBOL(snd_ac97_read);
 EXPORT_SYMBOL(snd_ac97_write_cache);
 EXPORT_SYMBOL(snd_ac97_update);
 EXPORT_SYMBOL(snd_ac97_update_bits);
+EXPORT_SYMBOL(snd_ac97_get_short_name);
 EXPORT_SYMBOL(snd_ac97_bus);
 EXPORT_SYMBOL(snd_ac97_mixer);
 EXPORT_SYMBOL(snd_ac97_pcm_assign);
 EXPORT_SYMBOL(snd_ac97_pcm_open);
 EXPORT_SYMBOL(snd_ac97_pcm_close);
+EXPORT_SYMBOL(snd_ac97_pcm_double_rate_rules);
 EXPORT_SYMBOL(snd_ac97_tune_hardware);
 EXPORT_SYMBOL(snd_ac97_set_rate);
 #ifdef CONFIG_PM
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/pci/ac97/ac97_pcm.c linux/sound/pci/ac97/ac97_pcm.c
--- linux-2.6.8/sound/pci/ac97/ac97_pcm.c	2004-09-15 11:20:40.809993976 +0200
+++ linux/sound/pci/ac97/ac97_pcm.c	2004-09-01 21:13:58.000000000 +0200
@@ -93,54 +93,52 @@ static unsigned char rate_reg_tables[2][
   },
 },
 {
-  /* FIXME: double rates */
+  /* double rates */
   {
-  	/* 3&4 front, 7&8 rear, 6&9 center/lfe */
+  	/* 3&4 front, 7&8 front (t+1) */
 	AC97_PCM_FRONT_DAC_RATE,	/* slot 3 */
 	AC97_PCM_FRONT_DAC_RATE,	/* slot 4 */
 	0xff,				/* slot 5 */
-	AC97_PCM_LFE_DAC_RATE,		/* slot 6 */
-	AC97_PCM_SURR_DAC_RATE,		/* slot 7 */
-	AC97_PCM_SURR_DAC_RATE,		/* slot 8 */
-	AC97_PCM_LFE_DAC_RATE,		/* slot 9 */
+	0xff,				/* slot 6 */
+	AC97_PCM_FRONT_DAC_RATE,	/* slot 7 */
+	AC97_PCM_FRONT_DAC_RATE,	/* slot 8 */
+	0xff,				/* slot 9 */
 	0xff,				/* slot 10 */
 	0xff,				/* slot 11 */
   },
   {
-  	/* 7&8 front, 6&9 rear, 10&11 center/lfe */
+	/* not specified in the specification */
 	0xff,				/* slot 3 */
 	0xff,				/* slot 4 */
 	0xff,				/* slot 5 */
-	AC97_PCM_SURR_DAC_RATE,		/* slot 6 */
-	AC97_PCM_FRONT_DAC_RATE,	/* slot 7 */
-	AC97_PCM_FRONT_DAC_RATE,	/* slot 8 */
-	AC97_PCM_SURR_DAC_RATE,		/* slot 9 */
-	AC97_PCM_LFE_DAC_RATE,		/* slot 10 */
-	AC97_PCM_LFE_DAC_RATE,		/* slot 11 */
+	0xff,				/* slot 6 */
+	0xff,				/* slot 7 */
+	0xff,				/* slot 8 */
+	0xff,				/* slot 9 */
+	0xff,				/* slot 10 */
+	0xff,				/* slot 11 */
   },
   {
-  	/* 6&9 front, 10&11 rear, 3&4 center/lfe */
-	AC97_PCM_LFE_DAC_RATE,		/* slot 3 */
-	AC97_PCM_LFE_DAC_RATE,		/* slot 4 */
+	0xff,				/* slot 3 */
+	0xff,				/* slot 4 */
 	0xff,				/* slot 5 */
-	AC97_PCM_FRONT_DAC_RATE,	/* slot 6 */
+	0xff,				/* slot 6 */
 	0xff,				/* slot 7 */
 	0xff,				/* slot 8 */
-	AC97_PCM_FRONT_DAC_RATE,	/* slot 9 */
-	AC97_PCM_SURR_DAC_RATE,		/* slot 10 */
-	AC97_PCM_SURR_DAC_RATE,		/* slot 11 */
+	0xff,				/* slot 9 */
+	0xff,				/* slot 10 */
+	0xff,				/* slot 11 */
   },
   {
-  	/* 10&11 front, 3&4 rear, 7&8 center/lfe */
-	AC97_PCM_SURR_DAC_RATE,		/* slot 3 */
-	AC97_PCM_SURR_DAC_RATE,		/* slot 4 */
+	0xff,				/* slot 3 */
+	0xff,				/* slot 4 */
 	0xff,				/* slot 5 */
 	0xff,				/* slot 6 */
-	AC97_PCM_LFE_DAC_RATE,		/* slot 7 */
-	AC97_PCM_LFE_DAC_RATE,		/* slot 8 */
+	0xff,				/* slot 7 */
+	0xff,				/* slot 8 */
 	0xff,				/* slot 9 */
-	AC97_PCM_FRONT_DAC_RATE,	/* slot 10 */
-	AC97_PCM_FRONT_DAC_RATE,	/* slot 11 */
+	0xff,				/* slot 10 */
+	0xff,				/* slot 11 */
   }
 }};
 
@@ -180,6 +178,7 @@ static int set_spdif_rate(ac97_t *ac97, 
 	if (! (ac97->ext_id & AC97_EI_SPDIF))
 		return -ENODEV;
 
+	/* TODO: double rate support */
 	if (ac97->flags & AC97_CS_SPDIF) {
 		switch (rate) {
 		case 48000: bits = 0; break;
@@ -257,10 +256,19 @@ static int set_spdif_rate(ac97_t *ac97, 
  *
  * Returns zero if successful, or a negative error code on failure.
  */
-int snd_ac97_set_rate(ac97_t *ac97, int reg, unsigned short rate)
+int snd_ac97_set_rate(ac97_t *ac97, int reg, unsigned int rate)
 {
+	int dbl;
 	unsigned int tmp;
 	
+	dbl = rate > 48000;
+	if (dbl) {
+		if (!(ac97->flags & AC97_DOUBLE_RATE))
+			return -EINVAL;
+		if (reg != AC97_PCM_FRONT_DAC_RATE)
+			return -EINVAL;
+	}
+
 	switch (reg) {
 	case AC97_PCM_MIC_ADC_RATE:
 		if ((ac97->regs[AC97_EXTENDED_STATUS] & AC97_EA_VRM) == 0)	/* MIC VRA */
@@ -270,7 +278,7 @@ int snd_ac97_set_rate(ac97_t *ac97, int 
 	case AC97_PCM_FRONT_DAC_RATE:
 	case AC97_PCM_LR_ADC_RATE:
 		if ((ac97->regs[AC97_EXTENDED_STATUS] & AC97_EA_VRA) == 0)	/* VRA */
-			if (rate != 48000)
+			if (rate != 48000 && rate != 96000)
 				return -EINVAL;
 		break;
 	case AC97_PCM_SURR_DAC_RATE:
@@ -287,9 +295,14 @@ int snd_ac97_set_rate(ac97_t *ac97, int 
 	default:
 		return -EINVAL;
 	}
-	tmp = ((unsigned int)rate * ac97->bus->clock) / 48000;
+	if (dbl)
+		rate /= 2;
+	tmp = (rate * ac97->bus->clock) / 48000;
 	if (tmp > 65535)
 		return -EINVAL;
+	if ((ac97->ext_id & AC97_EI_DRA) && reg == AC97_PCM_FRONT_DAC_RATE)
+		snd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS,
+				     AC97_EA_DRA, dbl ? AC97_EA_DRA : 0);
 	snd_ac97_update(ac97, reg, tmp & 0xffff);
 	snd_ac97_read(ac97, reg);
 	return 0;
@@ -401,6 +414,9 @@ static unsigned int get_rates(struct ac9
 		}
 		rates &= pcm->r[dbl].codec[cidx]->rates[idx];
 	}
+	if (!dbl)
+		rates &= ~(SNDRV_PCM_RATE_64000 | SNDRV_PCM_RATE_88200 |
+			   SNDRV_PCM_RATE_96000);
 	return rates;
 }
 
@@ -447,7 +463,6 @@ int snd_ac97_pcm_assign(ac97_bus_t *bus,
 			}
 		}
 	}
-	/* FIXME: add double rate allocation */
 	/* first step - exclusive devices */
 	for (i = 0; i < pcms_count; i++) {
 		pcm = &pcms[i];
@@ -498,6 +513,26 @@ int snd_ac97_pcm_assign(ac97_bus_t *bus,
 			rpcm->r[0].slots |= tmp;
 			rpcm->rates &= rates;
 		}
+		/* for double rate, we check the first codec only */
+		if (pcm->stream == SNDRV_PCM_STREAM_PLAYBACK &&
+		    bus->codec[0] && (bus->codec[0]->flags & AC97_DOUBLE_RATE) &&
+		    rate_table[pcm->stream][0] == 0) {
+			tmp = (1<<AC97_SLOT_PCM_LEFT) | (1<<AC97_SLOT_PCM_RIGHT) |
+			      (1<<AC97_SLOT_PCM_LEFT_0) | (1<<AC97_SLOT_PCM_RIGHT_0);
+			if ((tmp & pcm->r[1].slots) == tmp) {
+				rpcm->r[1].slots = tmp;
+				rpcm->r[1].rslots[0] = tmp;
+				rpcm->r[1].rate_table[0] = 0;
+				rpcm->r[1].codec[0] = bus->codec[0];
+				if (pcm->exclusive)
+					avail_slots[pcm->stream][0] &= ~tmp;
+				if (bus->no_vra)
+					rates = SNDRV_PCM_RATE_96000;
+				else
+					rates = get_rates(rpcm, 0, tmp, 1);
+				rpcm->rates |= rates;
+			}
+		}
 		if (rpcm->rates == ~0)
 			rpcm->rates = 0; /* not used */
 	}
@@ -519,13 +554,12 @@ int snd_ac97_pcm_open(struct ac97_pcm *p
 		      enum ac97_pcm_cfg cfg, unsigned short slots)
 {
 	ac97_bus_t *bus;
-	int i, cidx, r = 0, ok_flag;
+	int i, cidx, r, ok_flag;
 	unsigned int reg_ok = 0;
 	unsigned char reg;
 	int err = 0;
 
-	if (rate > 48000)	/* FIXME: add support for double rate */
-		return -EINVAL;
+	r = rate > 48000;
 	bus = pcm->bus;
 	if (cfg == AC97_PCM_CFG_SPDIF) {
 		int err;
@@ -614,3 +648,55 @@ int snd_ac97_pcm_close(struct ac97_pcm *
 	spin_unlock_irq(&pcm->bus->bus_lock);
 	return 0;
 }
+
+static int double_rate_hw_constraint_rate(snd_pcm_hw_params_t *params,
+					  snd_pcm_hw_rule_t *rule)
+{
+	snd_interval_t *channels = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
+	if (channels->min > 2) {
+		static const snd_interval_t single_rates = {
+			.min = 1,
+			.max = 48000,
+		};
+		snd_interval_t *rate = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
+		return snd_interval_refine(rate, &single_rates);
+	}
+	return 0;
+}
+
+static int double_rate_hw_constraint_channels(snd_pcm_hw_params_t *params,
+					      snd_pcm_hw_rule_t *rule)
+{
+	snd_interval_t *rate = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
+	if (rate->min > 48000) {
+		static const snd_interval_t double_rate_channels = {
+			.min = 2,
+			.max = 2,
+		};
+		snd_interval_t *channels = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
+		return snd_interval_refine(channels, &double_rate_channels);
+	}
+	return 0;
+}
+
+/**
+ * snd_ac97_pcm_double_rate_rules - set double rate constraints
+ * @runtime: the runtime of the ac97 front playback pcm
+ *
+ * Installs the hardware constraint rules to prevent using double rates and
+ * more than two channels at the same time.
+ */
+int snd_ac97_pcm_double_rate_rules(snd_pcm_runtime_t *runtime)
+{
+	int err;
+
+	err = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+				  double_rate_hw_constraint_rate, NULL,
+				  SNDRV_PCM_HW_PARAM_CHANNELS, -1);
+	if (err < 0)
+		return err;
+	err = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
+				  double_rate_hw_constraint_channels, NULL,
+				  SNDRV_PCM_HW_PARAM_RATE, -1);
+	return err;
+}
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/pci/ac97/ac97_proc.c linux/sound/pci/ac97/ac97_proc.c
--- linux-2.6.8/sound/pci/ac97/ac97_proc.c	2004-09-15 11:20:40.811993672 +0200
+++ linux/sound/pci/ac97/ac97_proc.c	2004-09-01 21:13:58.000000000 +0200
@@ -75,6 +75,7 @@ static void snd_ac97_proc_read_main(ac97
 	static const char *spdif_slots[4] = { " SPDIF=3/4", " SPDIF=7/8", " SPDIF=6/9", " SPDIF=res" };
 	static const char *spdif_rates[4] = { " Rate=44.1kHz", " Rate=res", " Rate=48kHz", " Rate=32kHz" };
 	static const char *spdif_rates_cs4205[4] = { " Rate=48kHz", " Rate=44.1kHz", " Rate=res", " Rate=res" };
+	static const char *double_rate_slots[4] = { "10/11", "7/8", "reserved", "reserved" };
 
 	snd_ac97_get_name(NULL, ac97->id, name, 0);
 	snd_iprintf(buffer, "%d-%d/%d: %s\n\n", ac97->addr, ac97->num, subidx, name);
@@ -137,6 +138,9 @@ static void snd_ac97_proc_read_main(ac97
 		    val & 0x0200 ? "Mic" : "MIX",
 		    val & 0x0100 ? "Mic2" : "Mic1",
 		    val & 0x0080 ? "on" : "off");
+	if (ac97->ext_id & AC97_EI_DRA)
+		snd_iprintf(buffer, "Double rate slots: %s\n",
+			    double_rate_slots[(val >> 10) & 3]);
 
 	ext = snd_ac97_read(ac97, AC97_EXTENDED_ID);
 	if (ext == 0)
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/pci/atiixp.c linux/sound/pci/atiixp.c
--- linux-2.6.8/sound/pci/atiixp.c	2004-09-15 11:20:40.859986376 +0200
+++ linux/sound/pci/atiixp.c	2004-09-13 12:28:33.000000000 +0200
@@ -1585,8 +1585,10 @@ static int __devinit snd_atiixp_probe(st
 
 	snd_atiixp_chip_start(chip);
 
-	sprintf(card->longname, "%s rev %x at 0x%lx, irq %i",
-		card->shortname, revision, chip->addr, chip->irq);
+	snprintf(card->longname, sizeof(card->longname),
+		 "%s rev %x with %s at %#lx, irq %i", card->shortname, revision,
+		 chip->ac97[0] ? snd_ac97_get_short_name(chip->ac97[0]) : "?",
+		 chip->addr, chip->irq);
 
 	snd_card_set_pm_callback(card, snd_atiixp_suspend, snd_atiixp_resume, chip);
 
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/pci/bt87x.c linux/sound/pci/bt87x.c
--- linux-2.6.8/sound/pci/bt87x.c	2004-09-15 11:20:40.938974368 +0200
+++ linux/sound/pci/bt87x.c	2004-09-06 14:48:19.000000000 +0200
@@ -264,8 +264,9 @@ static irqreturn_t snd_bt87x_interrupt(i
 			snd_printk(KERN_ERR "Aieee - PCI error! status %#08x, PCI status %#04x\n",
 				   status, pci_status);
 		}
-	}
-	if (status & INT_RISCI) {
+		if (chip->reg_control & CTL_ACAP_EN)
+			snd_pcm_stop(chip->substream, SNDRV_PCM_STATE_XRUN);
+	} else if ((status & INT_RISCI) && (chip->reg_control & CTL_ACAP_EN)) {
 		int current_block, irq_block;
 
 		/* assume that exactly one line has been recorded */
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/pci/cs46xx/cs46xx_lib.c linux/sound/pci/cs46xx/cs46xx_lib.c
--- linux-2.6.8/sound/pci/cs46xx/cs46xx_lib.c	2004-09-15 11:20:40.994965856 +0200
+++ linux/sound/pci/cs46xx/cs46xx_lib.c	2004-09-03 16:18:30.000000000 +0200
@@ -203,12 +203,6 @@ static unsigned short snd_cs46xx_ac97_re
 
 	val = snd_cs46xx_codec_read(chip, reg, codec_index);
 
-	/* HACK: voyetra uses EAPD bit in the reverse way.
-	 * we flip the bit to show the mixer status correctly
-	 */
-	if (reg == AC97_POWERDOWN && chip->amplifier_ctrl == amp_voyetra)
-		val ^= 0x8000;
-
 	return val;
 }
 
@@ -289,12 +283,6 @@ static void snd_cs46xx_ac97_write(ac97_t
 		   codec_index == CS46XX_SECONDARY_CODEC_INDEX,
 		   return);
 
-	/* HACK: voyetra uses EAPD bit in the reverse way.
-	 * we flip the bit to show the mixer status correctly
-	 */
-	if (reg == AC97_POWERDOWN && chip->amplifier_ctrl == amp_voyetra)
-		val ^= 0x8000;
-
 	snd_cs46xx_codec_write(chip, reg, val, codec_index);
 }
 
@@ -2405,6 +2393,8 @@ int __devinit snd_cs46xx_mixer(cs46xx_t 
 	memset(&ac97, 0, sizeof(ac97));
 	ac97.private_data = chip;
 	ac97.private_free = snd_cs46xx_mixer_free_ac97;
+	if (chip->amplifier_ctrl == amp_voyetra)
+		ac97.scaps = AC97_SCAP_INV_EAPD;
 
 	snd_cs46xx_codec_write(chip, AC97_MASTER, 0x8000,
 			       CS46XX_PRIMARY_CODEC_INDEX);
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/pci/emu10k1/emufx.c linux/sound/pci/emu10k1/emufx.c
--- linux-2.6.8/sound/pci/emu10k1/emufx.c	2004-09-15 11:20:41.058956128 +0200
+++ linux/sound/pci/emu10k1/emufx.c	2004-09-06 17:02:12.000000000 +0200
@@ -480,7 +480,7 @@ static void snd_emu10k1_write_op(emu10k1
 static void snd_emu10k1_audigy_write_op(emu10k1_fx8010_code_t *icode, unsigned int *ptr,
 					u32 op, u32 r, u32 a, u32 x, u32 y)
 {
-	snd_assert(*ptr < 512, return);
+	snd_assert(*ptr < 1024, return);
 	set_bit(*ptr, icode->code_valid);
 	icode->code[*ptr    ][0] = ((x & 0x7ff) << 12) | (y & 0x7ff);
 	icode->code[(*ptr)++][1] = ((op & 0x0f) << 24) | ((r & 0x7ff) << 12) | (a & 0x7ff);
@@ -505,7 +505,7 @@ static void snd_emu10k1_gpr_poke(emu10k1
 {
 	int gpr;
 
-	for (gpr = 0; gpr < 0x100; gpr++) {
+	for (gpr = 0; gpr < (emu->audigy ? 0x200 : 0x100); gpr++) {
 		if (!test_bit(gpr, icode->gpr_valid))
 			continue;
 		snd_emu10k1_ptr_write(emu, emu->gpr_base + gpr, 0, icode->gpr_map[gpr]);
@@ -516,7 +516,7 @@ static void snd_emu10k1_gpr_peek(emu10k1
 {
 	int gpr;
 
-	for (gpr = 0; gpr < 0x100; gpr++) {
+	for (gpr = 0; gpr < (emu->audigy ? 0x200 : 0x100); gpr++) {
 		set_bit(gpr, icode->gpr_valid);
 		icode->gpr_map[gpr] = snd_emu10k1_ptr_read(emu, emu->gpr_base + gpr, 0);
 	}
@@ -526,11 +526,16 @@ static void snd_emu10k1_tram_poke(emu10k
 {
 	int tram;
 
-	for (tram = 0; tram < 0xa0; tram++) {
+	for (tram = 0; tram < (emu->audigy ? 0x100 : 0xa0); tram++) {
 		if (!test_bit(tram, icode->tram_valid))
 			continue;
 		snd_emu10k1_ptr_write(emu, TANKMEMDATAREGBASE + tram, 0, icode->tram_data_map[tram]);
-		snd_emu10k1_ptr_write(emu, TANKMEMADDRREGBASE + tram, 0, icode->tram_addr_map[tram]);
+		if (!emu->audigy)
+			snd_emu10k1_ptr_write(emu, TANKMEMADDRREGBASE + tram, 0, icode->tram_addr_map[tram]);
+		else {
+			snd_emu10k1_ptr_write(emu, TANKMEMADDRREGBASE + tram, 0, icode->tram_addr_map[tram] << 12);
+			snd_emu10k1_ptr_write(emu, A_TANKMEMCTLREGBASE + tram, 0, icode->tram_addr_map[tram] >> 20);
+		}
 	}
 }
 
@@ -539,10 +544,15 @@ static void snd_emu10k1_tram_peek(emu10k
 	int tram;
 
 	memset(icode->tram_valid, 0, sizeof(icode->tram_valid));
-	for (tram = 0; tram < 0xa0; tram++) {
+	for (tram = 0; tram < (emu->audigy ? 0x100 : 0xa0); tram++) {
 		set_bit(tram, icode->tram_valid);
 		icode->tram_data_map[tram] = snd_emu10k1_ptr_read(emu, TANKMEMDATAREGBASE + tram, 0);
-		icode->tram_addr_map[tram] = snd_emu10k1_ptr_read(emu, TANKMEMADDRREGBASE + tram, 0);
+		if (!emu->audigy)
+			icode->tram_addr_map[tram] = snd_emu10k1_ptr_read(emu, TANKMEMADDRREGBASE + tram, 0);
+		else {
+			icode->tram_addr_map[tram] = snd_emu10k1_ptr_read(emu, TANKMEMADDRREGBASE + tram, 0) >> 12;
+			icode->tram_addr_map[tram] |= snd_emu10k1_ptr_read(emu, A_TANKMEMCTLREGBASE + tram, 0) << 20;
+		}
 	}
 }
 
@@ -550,7 +560,7 @@ static void snd_emu10k1_code_poke(emu10k
 {
 	u32 pc;
 
-	for (pc = 0; pc < 512; pc++) {
+	for (pc = 0; pc < (emu->audigy ? 1024 : 512); pc++) {
 		if (!test_bit(pc, icode->code_valid))
 			continue;
 		snd_emu10k1_efx_write(emu, pc * 2, icode->code[pc][0]);
@@ -563,7 +573,7 @@ static void snd_emu10k1_code_peek(emu10k
 	u32 pc;
 
 	memset(icode->code_valid, 0, sizeof(icode->code_valid));
-	for (pc = 0; pc < 512; pc++) {
+	for (pc = 0; pc < (emu->audigy ? 1024 : 512); pc++) {
 		set_bit(pc, icode->code_valid);
 		icode->code[pc][0] = snd_emu10k1_efx_read(emu, pc * 2);
 		icode->code[pc][1] = snd_emu10k1_efx_read(emu, pc * 2 + 1);
@@ -962,8 +972,12 @@ static int __devinit _snd_emu10k1_audigy
 	}
 
 	/* clear free GPRs */
-	for (i = 0; i < 256; i++)
+	for (i = 0; i < 512; i++)
 		set_bit(i, icode->gpr_valid);
+		
+	/* clear TRAM data & address lines */
+	for (i = 0; i < 256; i++)
+		set_bit(i, icode->tram_valid);
 
 	strcpy(icode->name, "Audigy DSP code for ALSA");
 	ptr = 0;
@@ -1311,7 +1325,7 @@ A_OP(icode, &ptr, iMAC0, A_GPR(var), A_G
 		goto __err;
 	}
 	/* clear remaining instruction memory */
-	while (ptr < 0x200)
+	while (ptr < 0x400)
 		A_OP(icode, &ptr, 0x0f, 0xc0, 0xc0, 0xcf, 0xc0);
 
 	seg = snd_enter_user();
@@ -2067,8 +2081,6 @@ static int snd_emu10k1_fx8010_ioctl(snd_
 		kfree(icode);
 		return res;
 	case SNDRV_EMU10K1_IOCTL_PCM_POKE:
-		if (emu->audigy)
-			return -EINVAL;
 		ipcm = (emu10k1_fx8010_pcm_t *)kmalloc(sizeof(*ipcm), GFP_KERNEL);
 		if (ipcm == NULL)
 			return -ENOMEM;
@@ -2080,8 +2092,6 @@ static int snd_emu10k1_fx8010_ioctl(snd_
 		kfree(ipcm);
 		return res;
 	case SNDRV_EMU10K1_IOCTL_PCM_PEEK:
-		if (emu->audigy)
-			return -EINVAL;
 		ipcm = kcalloc(1, sizeof(*ipcm), GFP_KERNEL);
 		if (ipcm == NULL)
 			return -ENOMEM;
@@ -2097,8 +2107,6 @@ static int snd_emu10k1_fx8010_ioctl(snd_
 		kfree(ipcm);
 		return res;
 	case SNDRV_EMU10K1_IOCTL_TRAM_SETUP:
-		if (emu->audigy)
-			return -EINVAL;
 		if (!capable(CAP_SYS_ADMIN))
 			return -EPERM;
 		if (get_user(addr, (unsigned int __user *)argp))
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/pci/emu10k1/emupcm.c linux/sound/pci/emu10k1/emupcm.c
--- linux-2.6.8/sound/pci/emu10k1/emupcm.c	2004-09-15 11:20:41.061955672 +0200
+++ linux/sound/pci/emu10k1/emupcm.c	2004-09-15 11:43:16.689228121 +0200
@@ -1092,6 +1092,7 @@ static int snd_emu10k1_pcm_efx_voices_ma
 	emu10k1_t *emu = snd_kcontrol_chip(kcontrol);
 	unsigned int nval[2], bits;
 	int nefx = emu->audigy ? 64 : 32;
+	int nefxb = emu->audigy ? 7 : 6;
 	int change, idx;
 	
 	nval[0] = nval[1] = 0;
@@ -1100,8 +1101,14 @@ static int snd_emu10k1_pcm_efx_voices_ma
 			nval[idx / 32] |= 1 << (idx % 32);
 			bits++;
 		}
-	if (bits != 1 && bits != 2 && bits != 4 && bits != 8)
+		
+	for (idx = 0; idx < nefxb; idx++)
+		if (1 << idx == bits)
+			break;
+	
+	if (idx >= nefxb)
 		return -EINVAL;
+
 	spin_lock_irq(&emu->reg_lock);
 	change = (nval[0] != emu->efx_voices_mask[0]) ||
 		(nval[1] != emu->efx_voices_mask[1]);
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/pci/emu10k1/emuproc.c linux/sound/pci/emu10k1/emuproc.c
--- linux-2.6.8/sound/pci/emu10k1/emuproc.c	2004-09-15 11:20:41.072954000 +0200
+++ linux/sound/pci/emu10k1/emuproc.c	2004-09-06 17:02:12.000000000 +0200
@@ -229,7 +229,7 @@ static void snd_emu10k1_proc_acode_read(
 
 	snd_iprintf(buffer, "FX8010 Instruction List '%s'\n", emu->fx8010.name);
 	snd_iprintf(buffer, "  Code dump      :\n");
-	for (pc = 0; pc < 512; pc++) {
+	for (pc = 0; pc < (emu->audigy ? 1024 : 512); pc++) {
 		u32 low, high;
 			
 		low = snd_emu10k1_efx_read(emu, pc * 2);
@@ -256,9 +256,13 @@ static void snd_emu10k1_proc_acode_read(
 }
 
 #define TOTAL_SIZE_GPR		(0x100*4)
+#define A_TOTAL_SIZE_GPR	(0x200*4)
 #define TOTAL_SIZE_TANKMEM_DATA	(0xa0*4)
 #define TOTAL_SIZE_TANKMEM_ADDR (0xa0*4)
+#define A_TOTAL_SIZE_TANKMEM_DATA (0x100*4)
+#define A_TOTAL_SIZE_TANKMEM_ADDR (0x100*4)
 #define TOTAL_SIZE_CODE		(0x200*8)
+#define A_TOTAL_SIZE_CODE	(0x400*8)
 
 static long snd_emu10k1_fx8010_read(snd_info_entry_t *entry, void *file_private_data,
 				    struct file *file, char __user *buf,
@@ -267,12 +271,12 @@ static long snd_emu10k1_fx8010_read(snd_
 	long size;
 	emu10k1_t *emu = entry->private_data;
 	unsigned int offset;
+	int tram_addr = 0;
 	
 	if (!strcmp(entry->name, "fx8010_tram_addr")) {
-		if (emu->audigy) return -EINVAL;
 		offset = TANKMEMADDRREGBASE;
+		tram_addr = 1;
 	} else if (!strcmp(entry->name, "fx8010_tram_data")) {
-		if (emu->audigy) return -EINVAL;
 		offset = TANKMEMDATAREGBASE;
 	} else if (!strcmp(entry->name, "fx8010_code")) {
 		offset = emu->audigy ? A_MICROCODEBASE : MICROCODEBASE;
@@ -289,7 +293,11 @@ static long snd_emu10k1_fx8010_read(snd_
 		if ((tmp = kmalloc(size + 8, GFP_KERNEL)) == NULL)
 			return -ENOMEM;
 		for (idx = 0; idx < ((pos & 3) + size + 3) >> 2; idx++)
-			tmp[idx] = snd_emu10k1_ptr_read(emu, offset + idx + (pos >> 2), 0);
+			if (tram_addr && emu->audigy) {
+				tmp[idx] = snd_emu10k1_ptr_read(emu, offset + idx + (pos >> 2), 0) >> 11;
+				tmp[idx] |= snd_emu10k1_ptr_read(emu, 0x100 + idx + (pos >> 2), 0) << 20;
+			} else 
+				tmp[idx] = snd_emu10k1_ptr_read(emu, offset + idx + (pos >> 2), 0);
 		if (copy_to_user(buf, ((char *)tmp) + (pos & 3), size))
 			res = -EFAULT;
 		else {
@@ -316,35 +324,35 @@ int __devinit snd_emu10k1_proc_init(emu1
 		entry->content = SNDRV_INFO_CONTENT_DATA;
 		entry->private_data = emu;
 		entry->mode = S_IFREG | S_IRUGO /*| S_IWUSR*/;
-		entry->size = TOTAL_SIZE_GPR;
+		entry->size = emu->audigy ? A_TOTAL_SIZE_GPR : TOTAL_SIZE_GPR;
 		entry->c.ops = &snd_emu10k1_proc_ops_fx8010;
 	}
-	if (!emu->audigy && ! snd_card_proc_new(emu->card, "fx8010_tram_data", &entry)) {
+	if (! snd_card_proc_new(emu->card, "fx8010_tram_data", &entry)) {
 		entry->content = SNDRV_INFO_CONTENT_DATA;
 		entry->private_data = emu;
 		entry->mode = S_IFREG | S_IRUGO /*| S_IWUSR*/;
-		entry->size = TOTAL_SIZE_TANKMEM_DATA;
+		entry->size = emu->audigy ? A_TOTAL_SIZE_TANKMEM_DATA : TOTAL_SIZE_TANKMEM_DATA ;
 		entry->c.ops = &snd_emu10k1_proc_ops_fx8010;
 	}
-	if (!emu->audigy && ! snd_card_proc_new(emu->card, "fx8010_tram_addr", &entry)) {
+	if (! snd_card_proc_new(emu->card, "fx8010_tram_addr", &entry)) {
 		entry->content = SNDRV_INFO_CONTENT_DATA;
 		entry->private_data = emu;
 		entry->mode = S_IFREG | S_IRUGO /*| S_IWUSR*/;
-		entry->size = TOTAL_SIZE_TANKMEM_ADDR;
+		entry->size = emu->audigy ? A_TOTAL_SIZE_TANKMEM_ADDR : TOTAL_SIZE_TANKMEM_ADDR ;
 		entry->c.ops = &snd_emu10k1_proc_ops_fx8010;
 	}
 	if (! snd_card_proc_new(emu->card, "fx8010_code", &entry)) {
 		entry->content = SNDRV_INFO_CONTENT_DATA;
 		entry->private_data = emu;
 		entry->mode = S_IFREG | S_IRUGO /*| S_IWUSR*/;
-		entry->size = TOTAL_SIZE_CODE;
+		entry->size = emu->audigy ? A_TOTAL_SIZE_CODE : TOTAL_SIZE_CODE;
 		entry->c.ops = &snd_emu10k1_proc_ops_fx8010;
 	}
 	if (! snd_card_proc_new(emu->card, "fx8010_acode", &entry)) {
 		entry->content = SNDRV_INFO_CONTENT_TEXT;
 		entry->private_data = emu;
 		entry->mode = S_IFREG | S_IRUGO /*| S_IWUSR*/;
-		entry->c.text.read_size = 64*1024;
+		entry->c.text.read_size = 128*1024;
 		entry->c.text.read = snd_emu10k1_proc_acode_read;
 	}
 	return 0;
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/pci/ens1370.c linux/sound/pci/ens1370.c
--- linux-2.6.8/sound/pci/ens1370.c	2004-09-15 11:20:41.097950200 +0200
+++ linux/sound/pci/ens1370.c	2004-09-01 21:12:32.000000000 +0200
@@ -372,6 +372,7 @@ typedef struct _snd_ensoniq ensoniq_t;
 
 struct _snd_ensoniq {
 	spinlock_t reg_lock;
+	struct semaphore src_mutex;
 
 	int irq;
 
@@ -513,6 +514,7 @@ static unsigned int snd_es1371_wait_src_
 		r = inl(ES_REG(ensoniq, 1371_SMPRATE));
 		if ((r & ES_1371_SRC_RAM_BUSY) == 0)
 			return r;
+		cond_resched();
 	}
 	snd_printk("wait source ready timeout 0x%lx [0x%x]\n", ES_REG(ensoniq, 1371_SMPRATE), r);
 	return 0;
@@ -696,6 +698,7 @@ static void snd_es1371_adc_rate(ensoniq_
 {
 	unsigned int n, truncm, freq, result;
 
+	down(&ensoniq->src_mutex);
 	n = rate / 3000;
 	if ((1 << n) & ((1 << 15) | (1 << 13) | (1 << 11) | (1 << 9)))
 		n--;
@@ -719,12 +722,14 @@ static void snd_es1371_adc_rate(ensoniq_
 	snd_es1371_src_write(ensoniq, ES_SMPREG_ADC + ES_SMPREG_VFREQ_FRAC, freq & 0x7fff);
 	snd_es1371_src_write(ensoniq, ES_SMPREG_VOL_ADC, n << 8);
 	snd_es1371_src_write(ensoniq, ES_SMPREG_VOL_ADC + 1, n << 8);
+	up(&ensoniq->src_mutex);
 }
 
 static void snd_es1371_dac1_rate(ensoniq_t * ensoniq, unsigned int rate)
 {
 	unsigned int freq, r;
 
+	down(&ensoniq->src_mutex);
 	freq = ((rate << 15) + 1500) / 3000;
 	r = (snd_es1371_wait_src_ready(ensoniq) & (ES_1371_SRC_DISABLE | ES_1371_DIS_P2 | ES_1371_DIS_R1)) | ES_1371_DIS_P1;
 	outl(r, ES_REG(ensoniq, 1371_SMPRATE));
@@ -734,12 +739,14 @@ static void snd_es1371_dac1_rate(ensoniq
 	snd_es1371_src_write(ensoniq, ES_SMPREG_DAC1 + ES_SMPREG_VFREQ_FRAC, freq & 0x7fff);
 	r = (snd_es1371_wait_src_ready(ensoniq) & (ES_1371_SRC_DISABLE | ES_1371_DIS_P2 | ES_1371_DIS_R1));
 	outl(r, ES_REG(ensoniq, 1371_SMPRATE));
+	up(&ensoniq->src_mutex);
 }
 
 static void snd_es1371_dac2_rate(ensoniq_t * ensoniq, unsigned int rate)
 {
 	unsigned int freq, r;
 
+	down(&ensoniq->src_mutex);
 	freq = ((rate << 15) + 1500) / 3000;
 	r = (snd_es1371_wait_src_ready(ensoniq) & (ES_1371_SRC_DISABLE | ES_1371_DIS_P1 | ES_1371_DIS_R1)) | ES_1371_DIS_P2;
 	outl(r, ES_REG(ensoniq, 1371_SMPRATE));
@@ -749,6 +756,7 @@ static void snd_es1371_dac2_rate(ensoniq
 	snd_es1371_src_write(ensoniq, ES_SMPREG_DAC2 + ES_SMPREG_VFREQ_FRAC, freq & 0x7fff);
 	r = (snd_es1371_wait_src_ready(ensoniq) & (ES_1371_SRC_DISABLE | ES_1371_DIS_P1 | ES_1371_DIS_R1));
 	outl(r, ES_REG(ensoniq, 1371_SMPRATE));
+	up(&ensoniq->src_mutex);
 }
 
 #endif /* CHIP1371 */
@@ -846,6 +854,13 @@ static int snd_ensoniq_playback1_prepare
 		mode |= 0x01;
 	spin_lock_irq(&ensoniq->reg_lock);
 	ensoniq->ctrl &= ~ES_DAC1_EN;
+#ifdef CHIP1371
+	/* 48k doesn't need SRC (it breaks AC3-passthru) */
+	if (runtime->rate == 48000)
+		ensoniq->ctrl |= ES_1373_BYPASS_P1;
+	else
+		ensoniq->ctrl &= ~ES_1373_BYPASS_P1;
+#endif
 	outl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));
 	outl(ES_MEM_PAGEO(ES_PAGE_DAC), ES_REG(ensoniq, MEM_PAGE));
 	outl(runtime->dma_addr, ES_REG(ensoniq, DAC1_FRAME));
@@ -863,11 +878,12 @@ static int snd_ensoniq_playback1_prepare
 	case 44100: ensoniq->ctrl |= ES_1370_WTSRSEL(3); break;
 	default: snd_BUG();
 	}
-#else
-	snd_es1371_dac1_rate(ensoniq, runtime->rate);
 #endif
 	outl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));
 	spin_unlock_irq(&ensoniq->reg_lock);
+#ifndef CHIP1370
+	snd_es1371_dac1_rate(ensoniq, runtime->rate);
+#endif
 	return 0;
 }
 
@@ -901,11 +917,12 @@ static int snd_ensoniq_playback2_prepare
 		ensoniq->ctrl |= ES_1370_PCLKDIVO(ES_1370_SRTODIV(runtime->rate));
 		ensoniq->u.es1370.pclkdiv_lock |= ES_MODE_PLAY2;
 	}
-#else
-	snd_es1371_dac2_rate(ensoniq, runtime->rate);
 #endif
 	outl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));
 	spin_unlock_irq(&ensoniq->reg_lock);
+#ifndef CHIP1370
+	snd_es1371_dac2_rate(ensoniq, runtime->rate);
+#endif
 	return 0;
 }
 
@@ -937,11 +954,12 @@ static int snd_ensoniq_capture_prepare(s
 		ensoniq->ctrl |= ES_1370_PCLKDIVO(ES_1370_SRTODIV(runtime->rate));
 		ensoniq->u.es1370.pclkdiv_lock |= ES_MODE_CAPTURE;
 	}
-#else
-	snd_es1371_adc_rate(ensoniq, runtime->rate);
 #endif
 	outl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));
 	spin_unlock_irq(&ensoniq->reg_lock);
+#ifndef CHIP1370
+	snd_es1371_adc_rate(ensoniq, runtime->rate);
+#endif
 	return 0;
 }
 
@@ -1879,6 +1897,7 @@ static int __devinit snd_ensoniq_create(
 	if (ensoniq == NULL)
 		return -ENOMEM;
 	spin_lock_init(&ensoniq->reg_lock);
+	init_MUTEX(&ensoniq->src_mutex);
 	ensoniq->card = card;
 	ensoniq->pci = pci;
 	ensoniq->irq = -1;
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/pci/ice1712/Makefile linux/sound/pci/ice1712/Makefile
--- linux-2.6.8/sound/pci/ice1712/Makefile	2004-09-15 11:20:41.123946248 +0200
+++ linux/sound/pci/ice1712/Makefile	2004-09-07 19:22:50.000000000 +0200
@@ -5,7 +5,7 @@
 
 snd-ice17xx-ak4xxx-objs := ak4xxx.o
 snd-ice1712-objs := ice1712.o delta.o hoontech.o ews.o
-snd-ice1724-objs := ice1724.o amp.o revo.o aureon.o vt1720_mobo.o pontis.o
+snd-ice1724-objs := ice1724.o amp.o revo.o aureon.o vt1720_mobo.o pontis.o prodigy192.o
 
 # Toplevel Module Dependency
 obj-$(CONFIG_SND_ICE1712) += snd-ice1712.o snd-ice17xx-ak4xxx.o
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/pci/ice1712/ice1712.c linux/sound/pci/ice1712/ice1712.c
--- linux-2.6.8/sound/pci/ice1712/ice1712.c	2004-09-15 11:20:41.161940472 +0200
+++ linux/sound/pci/ice1712/ice1712.c	2004-08-25 16:01:30.000000000 +0200
@@ -2308,28 +2308,47 @@ static int __devinit snd_ice1712_read_ee
 {
 	int dev = 0xa0;		/* EEPROM device address */
 	unsigned int i, size;
+	struct snd_ice1712_card_info **tbl, *c;
 
-	if ((inb(ICEREG(ice, I2C_CTRL)) & ICE1712_I2C_EEPROM) == 0) {
-		snd_printk("ICE1712 has not detected EEPROM\n");
-		return -EIO;
-	}
-	if (modelname && *modelname) {
-		struct snd_ice1712_card_info **tbl, *c;
-		for (tbl = card_tables; *tbl; tbl++) {
-			for (c = *tbl; c->subvendor; c++) {
-				if (c->model && !strcmp(modelname, c->model)) {
-					/* use the given subvendor */
-					printk(KERN_INFO "ice1712: Using board model %s\n", c->name);
-					ice->eeprom.subvendor = c->subvendor;
-					break;
-				}
+	if (! modelname || ! *modelname) {
+		ice->eeprom.subvendor = 0;
+		if ((inb(ICEREG(ice, I2C_CTRL)) & ICE1712_I2C_EEPROM) != 0)
+			ice->eeprom.subvendor = (snd_ice1712_read_i2c(ice, dev, 0x00) << 0) |
+				(snd_ice1712_read_i2c(ice, dev, 0x01) << 8) | 
+				(snd_ice1712_read_i2c(ice, dev, 0x02) << 16) | 
+				(snd_ice1712_read_i2c(ice, dev, 0x03) << 24);
+		if (ice->eeprom.subvendor == 0 || ice->eeprom.subvendor == (unsigned int)-1) {
+			/* invalid subvendor from EEPROM, try the PCI subststem ID instead */
+			u16 vendor, device;
+			pci_read_config_word(ice->pci, PCI_SUBSYSTEM_VENDOR_ID, &vendor);
+			pci_read_config_word(ice->pci, PCI_SUBSYSTEM_ID, &device);
+			ice->eeprom.subvendor = ((unsigned int)swab16(vendor) << 16) | swab16(device);
+			if (ice->eeprom.subvendor == 0 || ice->eeprom.subvendor == (unsigned int)-1) {
+				printk(KERN_ERR "ice1712: No valid ID is found\n");
+				return -ENXIO;
 			}
 		}
-	} else
-		ice->eeprom.subvendor = (snd_ice1712_read_i2c(ice, dev, 0x00) << 0) |
-			(snd_ice1712_read_i2c(ice, dev, 0x01) << 8) | 
-			(snd_ice1712_read_i2c(ice, dev, 0x02) << 16) | 
-			(snd_ice1712_read_i2c(ice, dev, 0x03) << 24);
+	}
+	for (tbl = card_tables; *tbl; tbl++) {
+		for (c = *tbl; c->subvendor; c++) {
+			if (modelname && c->model && ! strcmp(modelname, c->model)) {
+				printk(KERN_INFO "ice1712: Using board model %s\n", c->name);
+				ice->eeprom.subvendor = c->subvendor;
+			} else if (c->subvendor != ice->eeprom.subvendor)
+				continue;
+			if (! c->eeprom_size || ! c->eeprom_data)
+				goto found;
+			/* if the EEPROM is given by the driver, use it */
+			snd_printdd("using the defined eeprom..\n");
+			ice->eeprom.version = 1;
+			ice->eeprom.size = c->eeprom_size + 6;
+			memcpy(ice->eeprom.data, c->eeprom_data, c->eeprom_size);
+			goto read_skipped;
+		}
+	}
+	printk(KERN_WARNING "ice1712: No matching model found for ID 0x%x\n", ice->eeprom.subvendor);
+
+ found:
 	ice->eeprom.size = snd_ice1712_read_i2c(ice, dev, 0x04);
 	if (ice->eeprom.size < 6)
 		ice->eeprom.size = 32; /* FIXME: any cards without the correct size? */
@@ -2346,6 +2365,7 @@ static int __devinit snd_ice1712_read_ee
 	for (i = 0; i < size; i++)
 		ice->eeprom.data[i] = snd_ice1712_read_i2c(ice, dev, i + 6);
 
+ read_skipped:
 	ice->eeprom.gpiomask = ice->eeprom.data[ICE_EEP1_GPIO_MASK];
 	ice->eeprom.gpiostate = ice->eeprom.data[ICE_EEP1_GPIO_STATE];
 	ice->eeprom.gpiodir = ice->eeprom.data[ICE_EEP1_GPIO_DIR];
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/pci/ice1712/ice1724.c linux/sound/pci/ice1712/ice1724.c
--- linux-2.6.8/sound/pci/ice1712/ice1724.c	2004-09-15 11:20:41.193935608 +0200
+++ linux/sound/pci/ice1712/ice1724.c	2004-09-07 19:22:50.000000000 +0200
@@ -46,6 +46,7 @@
 #include "aureon.h"
 #include "vt1720_mobo.h"
 #include "pontis.h"
+#include "prodigy192.h"
 
 
 MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
@@ -57,6 +58,7 @@ MODULE_SUPPORTED_DEVICE("{"
 	       AUREON_DEVICE_DESC
 	       VT1720_MOBO_DEVICE_DESC
 	       PONTIS_DEVICE_DESC
+	       PRODIGY192_DEVICE_DESC
 		"{VIA,VT1720},"
 		"{VIA,VT1724},"
 		"{ICEnsemble,Generic ICE1724},"
@@ -1864,6 +1866,7 @@ static struct snd_ice1712_card_info *car
 	snd_vt1724_aureon_cards,
 	snd_vt1720_mobo_cards,
 	snd_vt1720_pontis_cards,
+	snd_vt1724_prodigy192_cards,
 	NULL,
 };
 
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/pci/ice1712/pontis.c linux/sound/pci/ice1712/pontis.c
--- linux-2.6.8/sound/pci/ice1712/pontis.c	2004-09-15 11:20:41.195935304 +0200
+++ linux/sound/pci/ice1712/pontis.c	2004-09-15 11:36:25.722534238 +0200
@@ -490,7 +490,7 @@ static int pontis_gpio_mask_get(snd_kcon
 	ice1712_t *ice = snd_kcontrol_chip(kcontrol);
 	down(&ice->gpio_mutex);
 	/* 4-7 reserved */
-	ucontrol->value.integer.value[0] = (~ice->gpio.write_mask & 0xffff) | 0x00f0;
+	ucontrol->value.integer.value[0] = (ice->gpio.write_mask & 0xffff) | 0x00f0;
 	up(&ice->gpio_mutex);
 	return 0;
 }
@@ -502,7 +502,7 @@ static int pontis_gpio_mask_put(snd_kcon
 	int changed;
 	down(&ice->gpio_mutex);
 	/* 4-7 reserved */
-	val = (~ucontrol->value.integer.value[0] & 0xffff) | 0x00f0;
+	val = (ucontrol->value.integer.value[0] & 0xffff) | 0x00f0;
 	changed = val != ice->gpio.write_mask;
 	ice->gpio.write_mask = val;
 	up(&ice->gpio_mutex);
@@ -823,7 +823,7 @@ static unsigned char pontis_eeprom[] __d
 	0x80,	/* ACLINK: I2S */
 	0xf8,	/* I2S: vol, 96k, 24bit, 192k */
 	0xc3,	/* SPDIF: out-en, out-int, spdif-in */
-	0x07,	/* GPIO_DIR */
+	0x00,	/* GPIO_DIR */
 	0x00,	/* GPIO_DIR1 */
 	0x00,	/* GPIO_DIR2 (ignored) */
 	0x0f,	/* GPIO_MASK (4-7 reserved for CS8416) */
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/pci/ice1712/prodigy192.c linux/sound/pci/ice1712/prodigy192.c
--- linux-2.6.8/sound/pci/ice1712/prodigy192.c	1970-01-01 01:00:00.000000000 +0100
+++ linux/sound/pci/ice1712/prodigy192.c	2004-09-07 17:02:49.000000000 +0200
@@ -0,0 +1,524 @@
+/*
+ *   ALSA driver for ICEnsemble VT1724 (Envy24HT)
+ *
+ *   Lowlevel functions for AudioTrak Prodigy 192 cards
+ *
+ *	Copyright (c) 2003 Takashi Iwai <tiwai@suse.de>
+ *      Copyright (c) 2003 Dimitromanolakis Apostolos <apostol@cs.utoronto.ca>
+ *      Copyright (c) 2004 Kouichi ONO <co2b@ceres.dti.ne.jp>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */      
+
+#include <sound/driver.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <sound/core.h>
+
+#include "ice1712.h"
+#include "envy24ht.h"
+#include "prodigy192.h"
+#include "stac946x.h"
+
+static void stac9460_put(ice1712_t *ice, int reg, unsigned char val)
+{
+	snd_vt1724_write_i2c(ice, PRODIGY192_STAC9460_ADDR, reg, val);
+}
+
+static unsigned char stac9460_get(ice1712_t *ice, int reg)
+{
+	return snd_vt1724_read_i2c(ice, PRODIGY192_STAC9460_ADDR, reg);
+}
+
+/*
+ * DAC mute control
+ */
+static int stac9460_dac_mute_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int stac9460_dac_mute_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	ice1712_t *ice = snd_kcontrol_chip(kcontrol);
+	unsigned char val;
+	int idx;
+
+	if (kcontrol->private_value)
+		idx = STAC946X_MASTER_VOLUME;
+	else
+		idx  = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id) + STAC946X_LF_VOLUME;
+	val = stac9460_get(ice, idx);
+	ucontrol->value.integer.value[0] = (~val >> 7) & 0x1;
+	return 0;
+}
+
+static int stac9460_dac_mute_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	ice1712_t *ice = snd_kcontrol_chip(kcontrol);
+	unsigned char new, old;
+	int idx;
+	int change;
+
+	if (kcontrol->private_value)
+		idx = STAC946X_MASTER_VOLUME;
+	else
+		idx  = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id) + STAC946X_LF_VOLUME;
+	old = stac9460_get(ice, idx);
+	new = (~ucontrol->value.integer.value[0]<< 7 & 0x80) | (old & ~0x80);
+	change = (new != old);
+	if (change)
+		stac9460_put(ice, idx, new);
+
+	return change;
+}
+
+/*
+ * DAC volume attenuation mixer control
+ */
+static int stac9460_dac_vol_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;			/* mute */
+	uinfo->value.integer.max = 0x7f;		/* 0dB */
+	return 0;
+}
+
+static int stac9460_dac_vol_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	ice1712_t *ice = snd_kcontrol_chip(kcontrol);
+	int idx;
+	unsigned char vol;
+
+	if (kcontrol->private_value)
+		idx = STAC946X_MASTER_VOLUME;
+	else
+		idx  = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id) + STAC946X_LF_VOLUME;
+	vol = stac9460_get(ice, idx) & 0x7f;
+	ucontrol->value.integer.value[0] = 0x7f - vol;
+
+	return 0;
+}
+
+static int stac9460_dac_vol_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	ice1712_t *ice = snd_kcontrol_chip(kcontrol);
+	int idx;
+	unsigned char tmp, ovol, nvol;
+	int change;
+
+	if (kcontrol->private_value)
+		idx = STAC946X_MASTER_VOLUME;
+	else
+		idx  = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id) + STAC946X_LF_VOLUME;
+	nvol = ucontrol->value.integer.value[0];
+	tmp = stac9460_get(ice, idx);
+	ovol = 0x7f - (tmp & 0x7f);
+	change = (ovol != nvol);
+	if (change) {
+		stac9460_put(ice, idx, (0x7f - nvol) | (tmp & 0x80));
+	}
+	return change;
+}
+
+/*
+ * ADC mute control
+ */
+static int stac9460_adc_mute_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int stac9460_adc_mute_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	ice1712_t *ice = snd_kcontrol_chip(kcontrol);
+	unsigned char val;
+	int i;
+
+	for (i = 0; i < 2; ++i) {
+		val = stac9460_get(ice, STAC946X_MIC_L_VOLUME + i);
+		ucontrol->value.integer.value[i] = ~val>>7 & 0x1;
+	}
+
+	return 0;
+}
+
+static int stac9460_adc_mute_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	ice1712_t *ice = snd_kcontrol_chip(kcontrol);
+	unsigned char new, old;
+	int i, reg;
+	int change;
+
+	for (i = 0; i < 2; ++i) {
+		reg = STAC946X_MIC_L_VOLUME + i;
+		old = stac9460_get(ice, reg);
+		new = (~ucontrol->value.integer.value[i]<<7&0x80) | (old&~0x80);
+		change = (new != old);
+		if (change)
+			stac9460_put(ice, reg, new);
+	}
+
+	return change;
+}
+
+/*
+ * ADC gain mixer control
+ */
+static int stac9460_adc_vol_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;		/* 0dB */
+	uinfo->value.integer.max = 0x0f;	/* 22.5dB */
+	return 0;
+}
+
+static int stac9460_adc_vol_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	ice1712_t *ice = snd_kcontrol_chip(kcontrol);
+	int i, reg;
+	unsigned char vol;
+
+	for (i = 0; i < 2; ++i) {
+		reg = STAC946X_MIC_L_VOLUME + i;
+		vol = stac9460_get(ice, reg) & 0x0f;
+		ucontrol->value.integer.value[i] = 0x0f - vol;
+	}
+
+	return 0;
+}
+
+static int stac9460_adc_vol_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	ice1712_t *ice = snd_kcontrol_chip(kcontrol);
+	int i, reg;
+	unsigned char ovol, nvol;
+	int change;
+
+	for (i = 0; i < 2; ++i) {
+		reg = STAC946X_MIC_L_VOLUME + i;
+		nvol = ucontrol->value.integer.value[i];
+		ovol = 0x0f - stac9460_get(ice, reg);
+		change = ((ovol & 0x0f)  != nvol);
+		if (change)
+			stac9460_put(ice, reg, (0x0f - nvol) | (ovol & ~0x0f));
+	}
+
+	return change;
+}
+
+#if 0
+/*
+ * Headphone Amplifier
+ */
+static int aureon_set_headphone_amp(ice1712_t *ice, int enable)
+{
+	unsigned int tmp, tmp2;
+
+	tmp2 = tmp = snd_ice1712_gpio_read(ice);
+	if (enable)
+		tmp |= AUREON_HP_SEL;
+	else
+		tmp &= ~ AUREON_HP_SEL;
+	if (tmp != tmp2) {
+		snd_ice1712_gpio_write(ice, tmp);
+		return 1;
+	}
+	return 0;
+}
+
+static int aureon_get_headphone_amp(ice1712_t *ice)
+{
+	unsigned int tmp = snd_ice1712_gpio_read(ice);
+
+	return ( tmp & AUREON_HP_SEL )!= 0;
+}
+
+static int aureon_bool_info(snd_kcontrol_t *k, snd_ctl_elem_info_t *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int aureon_hpamp_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	ice1712_t *ice = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.integer.value[0] = aureon_get_headphone_amp(ice);
+	return 0;
+}
+
+
+static int aureon_hpamp_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	ice1712_t *ice = snd_kcontrol_chip(kcontrol);
+
+	return aureon_set_headphone_amp(ice,ucontrol->value.integer.value[0]);
+}
+
+/*
+ * Deemphasis
+ */
+static int aureon_deemp_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	ice1712_t *ice = snd_kcontrol_chip(kcontrol);
+	ucontrol->value.integer.value[0] = (wm_get(ice, WM_DAC_CTRL2) & 0xf) == 0xf;
+	return 0;
+}
+
+static int aureon_deemp_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	ice1712_t *ice = snd_kcontrol_chip(kcontrol);
+	int temp, temp2;
+	temp2 = temp = wm_get(ice, WM_DAC_CTRL2);
+	if (ucontrol->value.integer.value[0])
+		temp |= 0xf;
+	else
+		temp &= ~0xf;
+	if (temp != temp2) {
+		wm_put(ice, WM_DAC_CTRL2, temp);
+		return 1;
+	}
+	return 0;
+}
+
+/*
+ * ADC Oversampling
+ */
+static int aureon_oversampling_info(snd_kcontrol_t *k, snd_ctl_elem_info_t *uinfo)
+{
+	static char *texts[2] = { "128x", "64x"	};
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 2;
+
+	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		uinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;
+	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
+
+        return 0;
+}
+
+static int aureon_oversampling_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	ice1712_t *ice = snd_kcontrol_chip(kcontrol);
+	ucontrol->value.enumerated.item[0] = (wm_get(ice, WM_MASTER) & 0x8) == 0x8;
+	return 0;
+}
+
+static int aureon_oversampling_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	int temp, temp2;
+	ice1712_t *ice = snd_kcontrol_chip(kcontrol);
+
+	temp2 = temp = wm_get(ice, WM_MASTER);
+
+	if (ucontrol->value.enumerated.item[0])
+		temp |= 0x8;
+	else
+		temp &= ~0x8;
+
+	if (temp != temp2) {
+		wm_put(ice, WM_MASTER, temp);
+		return 1;
+	}
+	return 0;
+}
+#endif
+
+/*
+ * mixers
+ */
+
+static snd_kcontrol_new_t stac_controls[] __devinitdata = {
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Master Playback Switch",
+		.info = stac9460_dac_mute_info,
+		.get = stac9460_dac_mute_get,
+		.put = stac9460_dac_mute_put,
+		.private_value = 1,
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Master Playback Volume",
+		.info = stac9460_dac_vol_info,
+		.get = stac9460_dac_vol_get,
+		.put = stac9460_dac_vol_put,
+		.private_value = 1,
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "DAC Switch",
+		.count = 6,
+		.info = stac9460_dac_mute_info,
+		.get = stac9460_dac_mute_get,
+		.put = stac9460_dac_mute_put,
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "DAC Volume",
+		.count = 6,
+		.info = stac9460_dac_vol_info,
+		.get = stac9460_dac_vol_get,
+		.put = stac9460_dac_vol_put,
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "ADC Switch",
+		.count = 1,
+		.info = stac9460_adc_mute_info,
+		.get = stac9460_adc_mute_get,
+		.put = stac9460_adc_mute_put,
+
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "ADC Volume",
+		.count = 1,
+		.info = stac9460_adc_vol_info,
+		.get = stac9460_adc_vol_get,
+		.put = stac9460_adc_vol_put,
+	},
+#if 0
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Capture Route",
+		.info = wm_adc_mux_info,
+		.get = wm_adc_mux_get,
+		.put = wm_adc_mux_put,
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Headphone Amplifier Switch",
+		.info = aureon_bool_info,
+		.get = aureon_hpamp_get,
+		.put = aureon_hpamp_put
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "DAC Deemphasis Switch",
+		.info = aureon_bool_info,
+		.get = aureon_deemp_get,
+		.put = aureon_deemp_put
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "ADC Oversampling",
+		.info = aureon_oversampling_info,
+		.get = aureon_oversampling_get,
+		.put = aureon_oversampling_put
+	},
+#endif
+};
+
+static int __devinit prodigy192_add_controls(ice1712_t *ice)
+{
+	unsigned int i;
+	int err;
+
+	for (i = 0; i < ARRAY_SIZE(stac_controls); i++) {
+		err = snd_ctl_add(ice->card, snd_ctl_new1(&stac_controls[i], ice));
+		if (err < 0)
+			return err;
+	}
+	return 0;
+}
+
+
+/*
+ * initialize the chip
+ */
+static int __devinit prodigy192_init(ice1712_t *ice)
+{
+	static unsigned short stac_inits_prodigy[] = {
+		STAC946X_RESET, 0,
+/*		STAC946X_MASTER_VOLUME, 0,
+		STAC946X_LF_VOLUME, 0,
+		STAC946X_RF_VOLUME, 0,
+		STAC946X_LR_VOLUME, 0,
+		STAC946X_RR_VOLUME, 0,
+		STAC946X_CENTER_VOLUME, 0,
+		STAC946X_LFE_VOLUME, 0,*/
+		(unsigned short)-1
+	};
+	unsigned short *p;
+
+	/* prodigy 192 */
+	ice->num_total_dacs = 6;
+	ice->num_total_adcs = 2;
+	
+	/* initialize codec */
+	p = stac_inits_prodigy;
+	for (; *p != (unsigned short)-1; p += 2)
+		stac9460_put(ice, p[0], p[1]);
+
+	return 0;
+}
+
+
+/*
+ * Aureon boards don't provide the EEPROM data except for the vendor IDs.
+ * hence the driver needs to sets up it properly.
+ */
+
+static unsigned char prodigy71_eeprom[] __devinitdata = {
+	0x2b,	/* SYSCONF: clock 512, mpu401, spdif-in/ADC, 4DACs */
+	0x80,	/* ACLINK: I2S */
+	0xf8,	/* I2S: vol, 96k, 24bit, 192k */
+	0xc3,	/* SPDIF: out-en, out-int, spdif-in */
+	0xff,	/* GPIO_DIR */
+	0xff,	/* GPIO_DIR1 */
+	0xbf,	/* GPIO_DIR2 */
+	0x00,	/* GPIO_MASK */
+	0x00,	/* GPIO_MASK1 */
+	0x00,	/* GPIO_MASK2 */
+	0x00,	/* GPIO_STATE */
+	0x00,	/* GPIO_STATE1 */
+	0x00,	/* GPIO_STATE2 */
+};
+
+
+/* entry point */
+struct snd_ice1712_card_info snd_vt1724_prodigy192_cards[] __devinitdata = {
+	{
+		.subvendor = VT1724_SUBDEVICE_PRODIGY192VE,
+		.name = "Audiotrak Prodigy 192",
+		.model = "prodigy192",
+		.chip_init = prodigy192_init,
+		.build_controls = prodigy192_add_controls,
+		.eeprom_size = sizeof(prodigy71_eeprom),
+		.eeprom_data = prodigy71_eeprom,
+	},
+	{ } /* terminator */
+};
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/pci/ice1712/prodigy192.h linux/sound/pci/ice1712/prodigy192.h
--- linux-2.6.8/sound/pci/ice1712/prodigy192.h	1970-01-01 01:00:00.000000000 +0100
+++ linux/sound/pci/ice1712/prodigy192.h	2004-09-07 17:02:49.000000000 +0200
@@ -0,0 +1,11 @@
+#ifndef __SOUND_PRODIGY192_H
+#define __SOUND_PRODIGY192_H
+
+#define PRODIGY192_DEVICE_DESC 	       "{AudioTrak,Prodigy 192},"
+#define PRODIGY192_STAC9460_ADDR	0x54
+
+#define VT1724_SUBDEVICE_PRODIGY192VE	 0x34495345	/* PRODIGY 192 VE */
+
+extern struct snd_ice1712_card_info  snd_vt1724_prodigy192_cards[];
+
+#endif	/* __SOUND_PRODIGY192_H */
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/pci/ice1712/stac946x.h linux/sound/pci/ice1712/stac946x.h
--- linux-2.6.8/sound/pci/ice1712/stac946x.h	1970-01-01 01:00:00.000000000 +0100
+++ linux/sound/pci/ice1712/stac946x.h	2004-09-08 13:28:25.000000000 +0200
@@ -0,0 +1,25 @@
+#ifndef __SOUND_STAC946X_H
+#define __SOUND_STAC946X_H
+
+#define STAC946X_RESET			0x00
+#define STAC946X_STATUS			0x01
+#define STAC946X_MASTER_VOLUME		0x02
+#define STAC946X_LF_VOLUME		0x03
+#define STAC946X_RF_VOLUME		0x04
+#define STAC946X_LR_VOLUME		0x05
+#define STAC946X_RR_VOLUME		0x06
+#define STAC946X_CENTER_VOLUME		0x07
+#define STAC946X_LFE_VOLUME		0x08
+#define STAC946X_MIC_L_VOLUME		0x09
+#define STAC946X_MIC_R_VOLUME		0x0a
+#define STAC946X_DEEMPHASIS		0x0c
+#define STAC946X_GENERAL_PURPOSE	0x0d
+#define STAC946X_AUDIO_PORT_CONTROL	0x0e
+#define STAC946X_MASTER_CLOCKING	0x0f
+#define STAC946X_POWERDOWN_CTRL1	0x10
+#define STAC946X_POWERDOWN_CTRL2	0x11
+#define STAC946X_REVISION_CODE		0x12
+#define STAC946X_ADDRESS_CONTROL	0x13
+#define STAC946X_ADDRESS		0x14
+
+#endif  /*  __SOUND_STAC946X_H */
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/pci/intel8x0.c linux/sound/pci/intel8x0.c
--- linux-2.6.8/sound/pci/intel8x0.c	2004-09-15 11:20:41.219931656 +0200
+++ linux/sound/pci/intel8x0.c	2004-09-13 12:28:33.000000000 +0200
@@ -33,13 +33,11 @@
 #include <linux/init.h>
 #include <linux/pci.h>
 #include <linux/slab.h>
-#include <linux/gameport.h>
 #include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/ac97_codec.h>
 #include <sound/info.h>
-#include <sound/mpu401.h>
 #include <sound/initval.h>
 /* for 440MX workaround */
 #include <asm/pgtable.h>
@@ -64,23 +62,13 @@ MODULE_SUPPORTED_DEVICE("{{Intel,82801AA
 		"{AMD,AMD8111},"
 	        "{ALI,M5455}}");
 
-#if defined(CONFIG_GAMEPORT) || (defined(MODULE) && defined(CONFIG_GAMEPORT_MODULE))
-#define SUPPORT_JOYSTICK 1
-#endif
-#define SUPPORT_MIDI 1
-
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
 static int ac97_clock[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 0};
 static int ac97_quirk[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = AC97_TUNE_DEFAULT};
 static int buggy_irq[SNDRV_CARDS];
-#ifdef SUPPORT_JOYSTICK
-static int joystick[SNDRV_CARDS];
-#endif
-#ifdef SUPPORT_MIDI
-static int mpu_port[SNDRV_CARDS]; /* disabled */
-#endif
+static int xbox[SNDRV_CARDS];
 static int boot_devs;
 
 module_param_array(index, int, boot_devs, 0444);
@@ -95,14 +83,8 @@ module_param_array(ac97_quirk, int, boot
 MODULE_PARM_DESC(ac97_quirk, "AC'97 workaround for strange hardware.");
 module_param_array(buggy_irq, bool, boot_devs, 0444);
 MODULE_PARM_DESC(buggy_irq, "Enable workaround for buggy interrupts on some motherboards.");
-#ifdef SUPPORT_JOYSTICK
-module_param_array(joystick, bool, boot_devs, 0444);
-MODULE_PARM_DESC(joystick, "Enable joystick for Intel i8x0 soundcard.");
-#endif
-#ifdef SUPPORT_MIDI
-module_param_array(mpu_port, int, boot_devs, 0444);
-MODULE_PARM_DESC(mpu_port, "MPU401 port # for Intel i8x0 driver.");
-#endif
+module_param_array(xbox, bool, boot_devs, 0444);
+MODULE_PARM_DESC(xbox, "Set to 1 for Xbox, if you have problems with the AC'97 codec detection.");
 
 /*
  *  Direct registers
@@ -406,10 +388,10 @@ struct _snd_intel8x0 {
 
 	unsigned int mmio;
 	unsigned long addr;
-	void __iomem * remap_addr;
+	unsigned long remap_addr;
 	unsigned int bm_mmio;
 	unsigned long bmaddr;
-	void __iomem * remap_bmaddr;
+	unsigned long remap_bmaddr;
 
 	struct pci_dev *pci;
 	snd_card_t *card;
@@ -420,18 +402,18 @@ struct _snd_intel8x0 {
 
 	int multi4: 1,
 	    multi6: 1,
+	    dra: 1,
 	    smp20bit: 1;
 	int in_ac97_init: 1,
 	    in_sdin_init: 1;
 	int fix_nocache: 1; /* workaround for 440MX */
 	int buggy_irq: 1; /* workaround for buggy mobos */
+	int xbox: 1;	  /* workaround for Xbox AC'97 detection */
 
 	ac97_bus_t *ac97_bus;
 	ac97_t *ac97[3];
 	unsigned int ac97_sdin[3];
 
-	snd_rawmidi_t *rmidi;
-
 	spinlock_t reg_lock;
 	spinlock_t ac97_lock;
 	
@@ -954,6 +936,7 @@ static int snd_intel8x0_hw_params(snd_pc
 	ichdev_t *ichdev = get_ichdev(substream);
 	snd_pcm_runtime_t *runtime = substream->runtime;
 	size_t size = params_buffer_bytes(hw_params);
+	int dbl = params_rate(hw_params) > 48000;
 	int err;
 
 	if (chip->fix_nocache && runtime->dma_area && runtime->dma_bytes < size)
@@ -969,7 +952,7 @@ static int snd_intel8x0_hw_params(snd_pc
 	}
 	err = snd_ac97_pcm_open(ichdev->pcm, params_rate(hw_params),
 				params_channels(hw_params),
-				ichdev->pcm->r[0].slots);
+				ichdev->pcm->r[dbl].slots);
 	if (err >= 0) {
 		ichdev->pcm_open_flag = 1;
 		/* FIXME: hack to enable spdif support */
@@ -994,34 +977,35 @@ static int snd_intel8x0_hw_free(snd_pcm_
 }
 
 static void snd_intel8x0_setup_pcm_out(intel8x0_t *chip,
-				       int channels, int sample_bits)
+				       snd_pcm_runtime_t *runtime)
 {
 	unsigned int cnt;
+	int dbl = runtime->rate > 48000;
 	switch (chip->device_type) {
 	case DEVICE_ALI:
 		cnt = igetdword(chip, ICHREG(ALI_SCR));
 		cnt &= ~ICH_ALI_SC_PCM_246_MASK;
-		if (chip->multi4 && channels == 4)
+		if (runtime->channels == 4 || dbl)
 			cnt |= ICH_ALI_SC_PCM_4;
-		else if (chip->multi6 && channels == 6)
+		else if (runtime->channels == 6)
 			cnt |= ICH_ALI_SC_PCM_6;
 		iputdword(chip, ICHREG(ALI_SCR), cnt);
 		break;
 	case DEVICE_SIS:
 		cnt = igetdword(chip, ICHREG(GLOB_CNT));
 		cnt &= ~ICH_SIS_PCM_246_MASK;
-		if (chip->multi4 && channels == 4)
+		if (runtime->channels == 4 || dbl)
 			cnt |= ICH_SIS_PCM_4;
-		else if (chip->multi6 && channels == 6)
+		else if (runtime->channels == 6)
 			cnt |= ICH_SIS_PCM_6;
 		iputdword(chip, ICHREG(GLOB_CNT), cnt);
 		break;
 	default:
 		cnt = igetdword(chip, ICHREG(GLOB_CNT));
 		cnt &= ~(ICH_PCM_246_MASK | ICH_PCM_20BIT);
-		if (chip->multi4 && channels == 4)
+		if (runtime->channels == 4 || dbl)
 			cnt |= ICH_PCM_4;
-		else if (chip->multi6 && channels == 6)
+		else if (runtime->channels == 6)
 			cnt |= ICH_PCM_6;
 		if (chip->device_type == DEVICE_NFORCE) {
 			/* reset to 2ch once to keep the 6 channel data in alignment,
@@ -1032,7 +1016,7 @@ static void snd_intel8x0_setup_pcm_out(i
 				msleep(50); /* grrr... */
 			}
 		} else if (chip->device_type == DEVICE_INTEL_ICH4) {
-			if (sample_bits > 16)
+			if (runtime->sample_bits > 16)
 				cnt |= ICH_PCM_20BIT;
 		}
 		iputdword(chip, ICHREG(GLOB_CNT), cnt);
@@ -1051,8 +1035,7 @@ static int snd_intel8x0_pcm_prepare(snd_
 	ichdev->fragsize = snd_pcm_lib_period_bytes(substream);
 	spin_lock_irq(&chip->reg_lock);
 	if (ichdev->ichd == ICHD_PCMOUT) {
-		snd_intel8x0_setup_pcm_out(chip, runtime->channels,
-					   runtime->sample_bits);
+		snd_intel8x0_setup_pcm_out(chip, runtime);
 		if (chip->device_type == DEVICE_INTEL_ICH4) {
 			ichdev->pos_shift = (runtime->sample_bits > 16) ? 2 : 1;
 		}
@@ -1168,6 +1151,9 @@ static int snd_intel8x0_playback_open(sn
 		runtime->hw.channels_max = 4;
 		snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS, &hw_constraints_channels4);
 	}
+	if (chip->dra) {
+		snd_ac97_pcm_double_rate_rules(runtime);
+	}
 	if (chip->smp20bit) {
 		runtime->hw.formats |= SNDRV_PCM_FMTBIT_S32_LE;
 		snd_pcm_hw_constraint_msbits(runtime, 0, 32, 20);
@@ -1662,6 +1648,12 @@ static struct ac97_pcm ac97_pcm_defs[] _
 					 (1 << AC97_SLOT_PCM_SLEFT) |
 					 (1 << AC97_SLOT_PCM_SRIGHT) |
 					 (1 << AC97_SLOT_LFE)
+			},
+			{
+				.slots = (1 << AC97_SLOT_PCM_LEFT) |
+					 (1 << AC97_SLOT_PCM_RIGHT) |
+					 (1 << AC97_SLOT_PCM_LEFT_0) |
+					 (1 << AC97_SLOT_PCM_RIGHT_0)
 			}
 		}
 	},
@@ -1718,6 +1710,12 @@ static struct ac97_pcm ac97_pcm_defs[] _
 static struct ac97_quirk ac97_quirks[] __devinitdata = {
 	{
 		.vendor = 0x0e11,
+		.device = 0x008a,
+		.name = "Compaq Evo W4000",	/* AD1885 */
+		.type = AC97_TUNE_HP_ONLY
+	},
+	{
+		.vendor = 0x0e11,
 		.device = 0x00b8,
 		.name = "Compaq Evo D510C",
 		.type = AC97_TUNE_HP_ONLY
@@ -1764,6 +1762,12 @@ static struct ac97_quirk ac97_quirks[] _
 		.name = "HP xw4200",	/* AD1981B*/
 		.type = AC97_TUNE_HP_ONLY
 	},
+	{
+		.vendor = 0x104d,
+		.device = 0x8197,
+		.name = "Sony S1XP",
+		.type = AC97_TUNE_INV_EAPD
+	},
  	{
 		.vendor = 0x1043,
 		.device = 0x80f3,
@@ -1771,6 +1775,12 @@ static struct ac97_quirk ac97_quirks[] _
 		.type = AC97_TUNE_AD_SHARING
 	},
 	{
+		.vendor = 0x10cf,
+		.device = 0x11c3,
+		.name = "Fujitsu-Siemens E4010",
+		.type = AC97_TUNE_HP_ONLY
+	},
+	{
 		.vendor = 0x10f1,
 		.device = 0x2665,
 		.name = "Fujitsu-Siemens Celsius",	/* AD1981? */
@@ -1901,6 +1911,8 @@ static int __devinit snd_intel8x0_mixer(
 	ac97.private_data = chip;
 	ac97.private_free = snd_intel8x0_mixer_free_ac97;
 	ac97.scaps = AC97_SCAP_SKIP_MODEM;
+	if (chip->xbox)
+		ac97.scaps |= AC97_SCAP_DETECT_BY_VENDOR;
 	if (chip->device_type != DEVICE_ALI) {
 		glob_sta = igetdword(chip, ICHREG(GLOB_STA));
 		ops = &standard_bus_ops;
@@ -1944,6 +1956,7 @@ static int __devinit snd_intel8x0_mixer(
 	/* FIXME: my test board doesn't work well with VRA... */
 	if (chip->device_type == DEVICE_ALI)
 		pbus->no_vra = 1;
+	pbus->dra = 1;
 	chip->ac97_bus = pbus;
 
 	ac97.pci = chip->pci;
@@ -2004,6 +2017,9 @@ static int __devinit snd_intel8x0_mixer(
 		if (pbus->pcms[0].r[0].slots & (1 << AC97_SLOT_LFE))
 			chip->multi6 = 1;
 	}
+	if (pbus->pcms[0].r[1].rslots[0]) {
+		chip->dra = 1;
+	}
 	if (chip->device_type == DEVICE_INTEL_ICH4) {
 		if ((igetdword(chip, ICHREG(GLOB_STA)) & ICH_SAMPLE_CAP) == ICH_SAMPLE_16_20)
 			chip->smp20bit = 1;
@@ -2227,9 +2243,9 @@ static int snd_intel8x0_free(intel8x0_t 
 		snd_dma_free_pages(&chip->bdbars);
 	}
 	if (chip->remap_addr)
-		iounmap(chip->remap_addr);
+		iounmap((void *) chip->remap_addr);
 	if (chip->remap_bmaddr)
-		iounmap(chip->remap_bmaddr);
+		iounmap((void *) chip->remap_bmaddr);
 	pci_release_regions(chip->pci);
 	kfree(chip);
 	return 0;
@@ -2502,8 +2518,9 @@ static int __devinit snd_intel8x0_create
 	if (pci_resource_flags(pci, 2) & IORESOURCE_MEM) {	/* ICH4 and Nforce */
 		chip->mmio = 1;
 		chip->addr = pci_resource_start(pci, 2);
-		chip->remap_addr = ioremap_nocache(chip->addr, pci_resource_len(pci, 2));
-		if (!chip->remap_addr) {
+		chip->remap_addr = (unsigned long) ioremap_nocache(chip->addr,
+								   pci_resource_len(pci, 2));
+		if (chip->remap_addr == 0) {
 			snd_printk("AC'97 space ioremap problem\n");
 			snd_intel8x0_free(chip);
 			return -EIO;
@@ -2514,8 +2531,9 @@ static int __devinit snd_intel8x0_create
 	if (pci_resource_flags(pci, 3) & IORESOURCE_MEM) {	/* ICH4 */
 		chip->bm_mmio = 1;
 		chip->bmaddr = pci_resource_start(pci, 3);
-		chip->remap_bmaddr = ioremap_nocache(chip->bmaddr, pci_resource_len(pci, 3));
-		if (!chip->remap_bmaddr) {
+		chip->remap_bmaddr = (unsigned long) ioremap_nocache(chip->bmaddr,
+								     pci_resource_len(pci, 3));
+		if (chip->remap_bmaddr == 0) {
 			snd_printk("Controller space ioremap problem\n");
 			snd_intel8x0_free(chip);
 			return -EIO;
@@ -2679,6 +2697,8 @@ static int __devinit snd_intel8x0_probe(
 	}
 	if (buggy_irq[dev])
 		chip->buggy_irq = 1;
+	if (xbox[dev])
+		chip->xbox = 1;
 
 	if ((err = snd_intel8x0_mixer(chip, ac97_clock[dev], ac97_quirk[dev])) < 0) {
 		snd_card_free(card);
@@ -2689,20 +2709,11 @@ static int __devinit snd_intel8x0_probe(
 		return err;
 	}
 	
-	if (mpu_port[dev] == 0x300 || mpu_port[dev] == 0x330) {
-		if ((err = snd_mpu401_uart_new(card, 0, MPU401_HW_INTEL8X0,
-					       mpu_port[dev], 0,
-					       -1, 0, &chip->rmidi)) < 0) {
-			printk(KERN_ERR "intel8x0: no UART401 device at 0x%x, skipping.\n", mpu_port[dev]);
-			mpu_port[dev] = 0;
-		}
-	} else
-		mpu_port[dev] = 0;
-
 	snd_intel8x0_proc_init(chip);
 
-	sprintf(card->longname, "%s at 0x%lx, irq %i",
-		card->shortname, chip->addr, chip->irq);
+	snprintf(card->longname, sizeof(card->longname),
+		 "%s with %s at %#lx, irq %i", card->shortname,
+		 snd_ac97_get_short_name(chip->ac97[0]), chip->addr, chip->irq);
 
 	if (! ac97_clock[dev])
 		intel8x0_measure_ac97_clock(chip);
@@ -2731,129 +2742,18 @@ static struct pci_driver driver = {
 };
 
 
-#if defined(SUPPORT_JOYSTICK) || defined(SUPPORT_MIDI)
-/*
- * initialize joystick/midi addresses
- */
-
-#ifdef SUPPORT_JOYSTICK
-/* there is only one available device, so we keep it here */
-static struct pci_dev *ich_gameport_pci;
-static struct gameport ich_gameport = { .io = 0x200 };
-#endif
-
-static int __devinit snd_intel8x0_joystick_probe(struct pci_dev *pci,
-						 const struct pci_device_id *id)
-{
-	u16 val;
-	static int dev;
-	if (dev >= SNDRV_CARDS)
-		return -ENODEV;
-	if (!enable[dev]) {
-		dev++;
-		return -ENOENT;
-	}
-
-	pci_read_config_word(pci, 0xe6, &val);
-#ifdef SUPPORT_JOYSTICK
-	val &= ~0x100;
-	if (joystick[dev]) {
-		if (! request_region(ich_gameport.io, 8, "ICH gameport")) {
-			printk(KERN_WARNING "intel8x0: cannot grab gameport 0x%x\n",  ich_gameport.io);
-			joystick[dev] = 0;
-		} else {
-			ich_gameport_pci = pci;
-			gameport_register_port(&ich_gameport);
-			val |= 0x100;
-		}
-	}
-#endif
-#ifdef SUPPORT_MIDI
-	val &= ~0x20;
-	if (mpu_port[dev] > 0) {
-		if (mpu_port[dev] == 0x300 || mpu_port[dev] == 0x330) {
-			u8 b;
-			val |= 0x20;
-			pci_read_config_byte(pci, 0xe2, &b);
-			if (mpu_port[dev] == 0x300)
-				b |= 0x08;
-			else
-				b &= ~0x08;
-			pci_write_config_byte(pci, 0xe2, b);
-		}
-	}
-#endif
-	pci_write_config_word(pci, 0xe6, val);
-	return 0;
-}
-
-static void __devexit snd_intel8x0_joystick_remove(struct pci_dev *pci)
-{
-	u16 val;
-#ifdef SUPPORT_JOYSTICK
-	if (ich_gameport_pci == pci) {
-		gameport_unregister_port(&ich_gameport);
-		release_region(ich_gameport.io, 8);
-		ich_gameport_pci = NULL;
-	}
-#endif
-	/* disable joystick and MIDI */
-	pci_read_config_word(pci, 0xe6, &val);
-	val &= ~0x120;
-	pci_write_config_word(pci, 0xe6, val);
-}
-
-static struct pci_device_id snd_intel8x0_joystick_ids[] = {
-	{ 0x8086, 0x2410, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },	/* 82801AA */
-	{ 0x8086, 0x2420, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },	/* 82901AB */
-	{ 0x8086, 0x2440, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 }, /* ICH2 */
-	{ 0x8086, 0x244c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 }, /* ICH2M */
-	{ 0x8086, 0x248c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },	/* ICH3 */
-	// { 0x8086, 0x7195, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },	/* 440MX */
-	// { 0x1039, 0x7012, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },	/* SI7012 */
-	{ 0x10de, 0x01b2, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },	/* NFORCE */
-	{ 0x10de, 0x006b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },	/* NFORCE2 */
-	{ 0x10de, 0x00db, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },	/* NFORCE3 */
-	{ 0, }
-};
-
-static struct pci_driver joystick_driver = {
-	.name = "Intel ICH Joystick",
-	.id_table = snd_intel8x0_joystick_ids,
-	.probe = snd_intel8x0_joystick_probe,
-	.remove = __devexit_p(snd_intel8x0_joystick_remove),
-};
-
-static int have_joystick;
-#endif
-
 static int __init alsa_card_intel8x0_init(void)
 {
 	int err;
 
         if ((err = pci_module_init(&driver)) < 0)
                 return err;
-
-#if defined(SUPPORT_JOYSTICK) || defined(SUPPORT_MIDI)
-	if (pci_module_init(&joystick_driver) < 0) {
-		snd_printdd(KERN_INFO "no joystick found\n");
-		have_joystick = 0;
-	} else {
-		snd_printdd(KERN_INFO "joystick(s) found\n");
-		have_joystick = 1;
-	}
-#endif
         return 0;
-
 }
 
 static void __exit alsa_card_intel8x0_exit(void)
 {
 	pci_unregister_driver(&driver);
-#if defined(SUPPORT_JOYSTICK) || defined(SUPPORT_MIDI)
-	if (have_joystick)
-		pci_unregister_driver(&joystick_driver);
-#endif
 }
 
 module_init(alsa_card_intel8x0_init)
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/pci/intel8x0m.c linux/sound/pci/intel8x0m.c
--- linux-2.6.8/sound/pci/intel8x0m.c	2004-09-15 11:20:41.238928768 +0200
+++ linux/sound/pci/intel8x0m.c	2004-09-08 17:21:03.000000000 +0200
@@ -30,13 +30,11 @@
 #include <linux/init.h>
 #include <linux/pci.h>
 #include <linux/slab.h>
-#include <linux/gameport.h>
 #include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/ac97_codec.h>
 #include <sound/info.h>
-#include <sound/mpu401.h>
 #include <sound/initval.h>
 
 MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
@@ -48,8 +46,13 @@ MODULE_SUPPORTED_DEVICE("{{Intel,82801AA
 		"{Intel,82801CA-ICH3},"
 		"{Intel,82801DB-ICH4},"
 		"{Intel,ICH5},"
-	        "{Intel,MX440}}");
-
+	        "{Intel,MX440},"
+		"{SiS,7013},"
+		"{NVidia,NForce Modem},"
+		"{NVidia,NForce2 Modem},"
+		"{NVidia,NForce2s Modem},"
+		"{NVidia,NForce3 Modem},"
+		"{AMD,AMD768}}");
 
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
@@ -1332,15 +1335,7 @@ static int __devinit snd_intel8x0m_probe
 	if (card == NULL)
 		return -ENOMEM;
 
-	switch (pci_id->driver_data) {
-	case DEVICE_NFORCE:
-		strcpy(card->driver, "NFORCE-MODEM");
-		break;
-	default:
-		strcpy(card->driver, "ICH-MODEM");
-		break;
-	}
-
+	strcpy(card->driver, "ICH-MODEM");
 	strcpy(card->shortname, "Intel ICH");
 	for (name = shortnames; name->id; name++) {
 		if (pci->device == name->id) {
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/pci/korg1212/korg1212.c linux/sound/pci/korg1212/korg1212.c
--- linux-2.6.8/sound/pci/korg1212/korg1212.c	2004-09-15 11:20:41.257925880 +0200
+++ linux/sound/pci/korg1212/korg1212.c	2004-08-31 11:46:23.000000000 +0200
@@ -168,7 +168,7 @@ typedef enum {
 #define DOORBELL_VAL_MASK    0x00FF    // the doorbell value is one byte
 
 #define CARD_BOOT_DELAY_IN_MS  10
-
+#define CARD_BOOT_TIMEOUT      10
 #define DSP_BOOT_DELAY_IN_MS   200
 
 #define kNumBuffers		8
@@ -382,6 +382,9 @@ struct _snd_korg1212 {
         snd_pcm_substream_t *playback_substream;
         snd_pcm_substream_t *capture_substream;
 
+	pid_t capture_pid;
+	pid_t playback_pid;
+
  	CardState cardState;
         int running;
         int idleMonitorOn;           // indicates whether the card is in idle monitor mode.
@@ -844,6 +847,20 @@ static int snd_korg1212_SetMonitorMode(k
 
 #endif /* not used */
 
+static inline int snd_korg1212_use_is_exclusive(korg1212_t *korg1212)
+{
+	unsigned long flags;
+	int ret = 1;
+
+	spin_lock_irqsave(&korg1212->lock, flags);
+	if ((korg1212->playback_pid != korg1212->capture_pid) &&
+	    (korg1212->playback_pid >= 0) && (korg1212->capture_pid >= 0)) {
+		ret = 0;
+	}
+	spin_unlock_irqrestore(&korg1212->lock, flags);
+	return ret;
+}
+
 static int snd_korg1212_SetRate(korg1212_t *korg1212, int rate)
 {
         static ClockSourceIndex s44[] = { K1212_CLKIDX_AdatAt44_1K,
@@ -855,6 +872,10 @@ static int snd_korg1212_SetRate(korg1212
                                           K1212_CLKIDX_LocalAt48K };
         int parm;
 
+        if (!snd_korg1212_use_is_exclusive (korg1212)) {
+                return -EBUSY;
+        }
+
         switch(rate) {
                 case 44100:
                 parm = s44[korg1212->clkSource];
@@ -1245,7 +1266,7 @@ static int snd_korg1212_downloadDSPCode(
 	if (rc) K1212_DEBUG_PRINTK("K1212_DEBUG: Start DSP Download RC = %d [%s]\n", rc, stateName[korg1212->cardState]);
 #endif
 
-	if (! sleep_on_timeout(&korg1212->wait, HZ * 4))
+	if (! sleep_on_timeout(&korg1212->wait, HZ * CARD_BOOT_TIMEOUT))
 		return -EBUSY; /* timeout */
 
 	snd_korg1212_OnDSPDownloadComplete(korg1212);
@@ -1414,6 +1435,7 @@ static int snd_korg1212_playback_open(sn
         spin_lock_irqsave(&korg1212->lock, flags);
 
         korg1212->playback_substream = substream;
+	korg1212->playback_pid = current->pid;
         korg1212->periodsize = K1212_PERIODS;
 	korg1212->channels = K1212_CHANNELS;
 
@@ -1444,6 +1466,7 @@ static int snd_korg1212_capture_open(snd
         spin_lock_irqsave(&korg1212->lock, flags);
 
         korg1212->capture_substream = substream;
+	korg1212->capture_pid = current->pid;
         korg1212->periodsize = K1212_PERIODS;
 	korg1212->channels = K1212_CHANNELS;
 
@@ -1466,6 +1489,7 @@ static int snd_korg1212_playback_close(s
 
         spin_lock_irqsave(&korg1212->lock, flags);
 
+	korg1212->playback_pid = -1;
         korg1212->playback_substream = NULL;
         korg1212->periodsize = 0;
 
@@ -1486,6 +1510,7 @@ static int snd_korg1212_capture_close(sn
 
         spin_lock_irqsave(&korg1212->lock, flags);
 
+	korg1212->capture_pid = -1;
         korg1212->capture_substream = NULL;
         korg1212->periodsize = 0;
 
@@ -1522,22 +1547,45 @@ static int snd_korg1212_hw_params(snd_pc
         unsigned long flags;
         korg1212_t *korg1212 = snd_pcm_substream_chip(substream);
         int err;
+	pid_t this_pid;
+	pid_t other_pid;
 
 #if K1212_DEBUG_LEVEL > 0
 		K1212_DEBUG_PRINTK("K1212_DEBUG: snd_korg1212_hw_params [%s]\n", stateName[korg1212->cardState]);
 #endif
 
         spin_lock_irqsave(&korg1212->lock, flags);
+
+	if (substream->pstr->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		this_pid = korg1212->playback_pid;
+		other_pid = korg1212->capture_pid;
+	} else {
+		this_pid = korg1212->capture_pid;
+		other_pid = korg1212->playback_pid;
+	}
+
+	if ((other_pid > 0) && (this_pid != other_pid)) {
+
+		/* The other stream is open, and not by the same
+		   task as this one. Make sure that the parameters
+		   that matter are the same.
+		 */
+
+		if ((int)params_rate(params) != korg1212->clkRate) {
+			spin_unlock_irqrestore(&korg1212->lock, flags);
+			_snd_pcm_hw_param_setempty(params, SNDRV_PCM_HW_PARAM_RATE);
+			return -EBUSY;
+		}
+
+        	spin_unlock_irqrestore(&korg1212->lock, flags);
+	        return 0;
+	}
+
         if ((err = snd_korg1212_SetRate(korg1212, params_rate(params))) < 0) {
                 spin_unlock_irqrestore(&korg1212->lock, flags);
                 return err;
         }
-/*
-        if (params_format(params) != SNDRV_PCM_FORMAT_S16_LE) {
-                spin_unlock_irqrestore(&korg1212->lock, flags);
-                return -EINVAL;
-        }
-*/
+
 	korg1212->channels = params_channels(params);
         korg1212->periodsize = K1212_PERIOD_BYTES;
 
@@ -2183,6 +2231,8 @@ static int __devinit snd_korg1212_create
 	korg1212->opencnt = 0;
 	korg1212->playcnt = 0;
 	korg1212->setcnt = 0;
+	korg1212->playback_pid = -1;
+	korg1212->capture_pid = -1;
         snd_korg1212_setCardState(korg1212, K1212_STATE_UNINITIALIZED);
         korg1212->idleMonitorOn = 0;
         korg1212->clkSrcRate = K1212_CLKIDX_LocalAt44_1K;
@@ -2312,7 +2362,7 @@ static int __devinit snd_korg1212_create
 
 #if K1212_DEBUG_LEVEL > 0
         K1212_DEBUG_PRINTK("K1212_DEBUG: Record Data Area = 0x%p (0x%08x), %d bytes\n",
-		korg1212->recordDataBufsPtr, korg1212->RecDataBufsPhy, korg1212->DataBufsSize);
+		korg1212->recordDataBufsPtr, korg1212->RecDataPhy, korg1212->DataBufsSize);
 #endif
 
 #else // K1212_LARGEALLOC
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/pci/mixart/mixart.c linux/sound/pci/mixart/mixart.c
--- linux-2.6.8/sound/pci/mixart/mixart.c	2004-09-15 11:20:41.272923600 +0200
+++ linux/sound/pci/mixart/mixart.c	2004-08-16 11:06:23.000000000 +0200
@@ -620,10 +620,7 @@ static int snd_mixart_hw_params(snd_pcm_
 		bufferinfo[i].available_length = subs->runtime->dma_bytes;
 		/* bufferinfo[i].buffer_id  is already defined */
 
-		snd_printdd("snd_mixart_hw_params(pcm %d) : dma_addr(%x) dma_bytes(%x) subs-number(%d)\n", i,
-				bufferinfo[i].buffer_address,
-				bufferinfo[i].available_length,
-				subs->number);
+		snd_printdd("snd_mixart_hw_params(pcm %d) : dma_addr(%x) dma_bytes(%x) subs-number(%d)\n", i, subs->runtime->dma_addr, subs->runtime->dma_bytes, subs->number);
 	}
 	up(&mgr->setup_mutex);
 
@@ -1291,10 +1288,11 @@ static int __devinit snd_mixart_probe(st
 	pci_set_master(pci);
 
 	/* check if we can restrict PCI DMA transfers to 32 bits */
-	if (pci_set_dma_mask(pci, 0xffffffff) < 0) {
+	if (!pci_dma_supported(pci, 0xffffffff)) {
 		snd_printk(KERN_ERR "architecture does not support 32bit PCI busmaster DMA\n");
 		return -ENXIO;
 	}
+	pci_set_dma_mask(pci, 0xffffffff);
 
 	/*
 	 */
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/pci/mixart/mixart_core.c linux/sound/pci/mixart/mixart_core.c
--- linux-2.6.8/sound/pci/mixart/mixart_core.c	2004-09-15 11:20:41.274923296 +0200
+++ linux/sound/pci/mixart/mixart_core.c	2004-06-29 18:02:24.000000000 +0200
@@ -379,7 +379,7 @@ void snd_mixart_msg_tasklet( unsigned lo
 					snd_printk(KERN_ERR "tasklet : error MSG_STREAM_ST***_***PUT_STAGE_PACKET status=%x\n", mixart_msg_data[0]);
 				break;
 			default:
-				snd_printdd("tasklet received mf(%x) : msg_id(%x) uid(%x, %x) size(%zd)\n",
+				snd_printdd("tasklet received mf(%x) : msg_id(%x) uid(%x, %x) size(%d)\n",
 					   msg, resp.message_id, resp.uid.object_id, resp.uid.desc, resp.size);
 				break;
 			}
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/pci/rme9652/hdsp.c linux/sound/pci/rme9652/hdsp.c
--- linux-2.6.8/sound/pci/rme9652/hdsp.c	2004-09-15 11:20:41.360910224 +0200
+++ linux/sound/pci/rme9652/hdsp.c	2004-08-04 11:26:14.000000000 +0200
@@ -802,7 +802,7 @@ static int hdsp_write_gain(hdsp_t *hdsp,
 	
 	if (hdsp->io_type == H9652 || hdsp->io_type == H9632) {
 
-		/* from martin bjrnsen:
+		/* from martin bjrnsen:
 		   
 		   "You can only write dwords to the
 		   mixer memory which contain two
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/pci/via82xx.c linux/sound/pci/via82xx.c
--- linux-2.6.8/sound/pci/via82xx.c	2004-09-15 11:20:41.450896544 +0200
+++ linux/sound/pci/via82xx.c	2004-09-13 12:28:33.000000000 +0200
@@ -1547,6 +1547,13 @@ static void snd_via82xx_mixer_free_ac97(
 }
 
 static struct ac97_quirk ac97_quirks[] = {
+	{
+		.vendor = 0x1106,
+		.device = 0x4161,
+		.codec_id = 0x56494161, /* VT1612A */
+		.name = "Soltek SL-75DRV5",
+		.type = AC97_TUNE_NONE
+	},
 	{	/* FIXME: which codec? */
 		.vendor = 0x1106,
 		.device = 0x4161,
@@ -1606,6 +1613,7 @@ static int __devinit snd_via82xx_mixer_n
 		return err;
 	chip->ac97_bus->private_free = snd_via82xx_mixer_free_ac97_bus;
 	chip->ac97_bus->clock = chip->ac97_clock;
+	chip->ac97_bus->shared_type = AC97_SHARED_TYPE_VIA;
 
 	memset(&ac97, 0, sizeof(ac97));
 	ac97.private_data = chip;
@@ -2235,8 +2243,9 @@ static int __devinit snd_via82xx_probe(s
 	for (i = 0; i < chip->num_devs; i++)
 		snd_via82xx_channel_reset(chip, &chip->devs[i]);
 
-	sprintf(card->longname, "%s at 0x%lx, irq %d",
-		card->shortname, chip->port, chip->irq);
+	snprintf(card->longname, sizeof(card->longname),
+		 "%s with %s at %#lx, irq %d", card->shortname,
+		 snd_ac97_get_short_name(chip->ac97), chip->port, chip->irq);
 
 	snd_via82xx_proc_init(chip);
 
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/pcmcia/Kconfig linux/sound/pcmcia/Kconfig
--- linux-2.6.8/sound/pcmcia/Kconfig	2004-08-14 07:36:58.000000000 +0200
+++ linux/sound/pcmcia/Kconfig	2004-09-13 12:28:35.000000000 +0200
@@ -8,20 +8,32 @@ config SND_VXPOCKET
 	depends on SND && PCMCIA && ISA
 	select SND_VX_LIB
 	help
-	  Say 'Y' or 'M' to include support for Digigram VXpocket soundcard.
+	  Say Y here to include support for Digigram VXpocket
+	  soundcards.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-vxpocket.
 
 config SND_VXP440
 	tristate "Digigram VXpocket 440"
 	depends on SND && PCMCIA && ISA
 	select SND_VX_LIB
 	help
-	  Say 'Y' or 'M' to include support for Digigram VXpocket 440 soundcard.
+	  Say Y here to include support for Digigram VXpocket 440
+	  soundcards.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-vxp440.
 
 config SND_PDAUDIOCF
 	tristate "Sound Core PDAudioCF"
 	depends on SND && PCMCIA && ISA
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to include support for Sound Core PDAudioCF soundcard.
+	  Say Y here to include support for Sound Core PDAudioCF
+	  soundcards.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-pdaudiocf.
 
 endmenu
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/ppc/Kconfig linux/sound/ppc/Kconfig
--- linux-2.6.8/sound/ppc/Kconfig	2004-09-15 11:20:41.506888032 +0200
+++ linux/sound/ppc/Kconfig	2004-09-13 12:28:36.000000000 +0200
@@ -13,6 +13,11 @@ config SND_POWERMAC
 	tristate "PowerMac (AWACS, DACA, Burgundy, Tumbler, Keywest)"
 	depends on SND && I2C && INPUT
 	select SND_PCM
+	help
+	  Say Y here to include support for the integrated sound device.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-powermac.
 
 endmenu
 
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/usb/Kconfig linux/sound/usb/Kconfig
--- linux-2.6.8/sound/usb/Kconfig	2004-09-15 11:20:41.642867360 +0200
+++ linux/sound/usb/Kconfig	2004-09-13 14:59:05.000000000 +0200
@@ -1,6 +1,6 @@
 # ALSA USB drivers
 
-menu "ALSA USB devices"
+menu "USB devices"
 	depends on SND!=n && USB!=n
 
 config SND_USB_AUDIO
@@ -9,7 +9,11 @@ config SND_USB_AUDIO
 	select SND_RAWMIDI
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to include support for USB audio and USB MIDI devices.
+	  Say Y here to include support for USB audio and USB MIDI
+	  devices.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-usb-audio.
 
 config SND_USB_USX2Y
 	tristate "Tascam US-122, US-224 and US-428 USB driver"
@@ -18,8 +22,11 @@ config SND_USB_USX2Y
 	select SND_RAWMIDI
 	select SND_PCM
 	help
-	  Say 'Y' or 'M' to include support for Tascam USB Audio/MIDI 
+	  Say Y here to include support for Tascam USB Audio/MIDI
 	  interfaces or controllers US-122, US-224 and US-428.
 
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-usb-usx2y.
+
 endmenu
 
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/usb/usbaudio.c linux/sound/usb/usbaudio.c
--- linux-2.6.8/sound/usb/usbaudio.c	2004-09-15 11:20:41.661864472 +0200
+++ linux/sound/usb/usbaudio.c	2004-09-07 19:22:53.000000000 +0200
@@ -2823,6 +2823,56 @@ static int create_ua700_quirk(snd_usb_au
 	return 0;
 }
 
+/*
+ * Create a stream for an Edirol UA-1000 interface.
+ */
+static int create_ua1000_quirk(snd_usb_audio_t *chip, struct usb_interface *iface)
+{
+	static const struct audioformat ua1000_format = {
+		.format = SNDRV_PCM_FORMAT_S32_LE,
+		.fmt_type = USB_FORMAT_TYPE_I,
+		.altsetting = 1,
+		.altset_idx = 1,
+		.attributes = 0,
+		.rates = SNDRV_PCM_RATE_CONTINUOUS,
+	};
+	struct usb_host_interface *alts;
+	struct usb_interface_descriptor *altsd;
+	struct audioformat *fp;
+	int stream, err;
+
+	if (iface->num_altsetting != 2)
+		return -ENXIO;
+	alts = &iface->altsetting[1];
+	altsd = get_iface_desc(alts);
+	if (alts->extralen != 11 || alts->extra[1] != CS_AUDIO_INTERFACE ||
+	    altsd->bNumEndpoints != 1)
+		return -ENXIO;
+
+	fp = kmalloc(sizeof(*fp), GFP_KERNEL);
+	if (!fp)
+		return -ENOMEM;
+	memcpy(fp, &ua1000_format, sizeof(*fp));
+
+	fp->channels = alts->extra[4];
+	fp->iface = altsd->bInterfaceNumber;
+	fp->endpoint = get_endpoint(alts, 0)->bEndpointAddress;
+	fp->ep_attr = get_endpoint(alts, 0)->bmAttributes;
+	fp->maxpacksize = get_endpoint(alts, 0)->wMaxPacketSize;
+	fp->rate_max = fp->rate_min = combine_triple(&alts->extra[8]);
+
+	stream = (fp->endpoint & USB_DIR_IN)
+		? SNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK;
+	err = add_audio_endpoint(chip, stream, fp);
+	if (err < 0) {
+		kfree(fp);
+		return err;
+	}
+	/* FIXME: playback must be synchronized to capture */
+	usb_set_interface(chip->dev, fp->iface, 0);
+	return 0;
+}
+
 static int snd_usb_create_quirk(snd_usb_audio_t *chip,
 				struct usb_interface *iface,
 				const snd_usb_audio_quirk_t *quirk);
@@ -2912,6 +2962,8 @@ static int snd_usb_create_quirk(snd_usb_
 		return create_standard_interface_quirk(chip, iface, quirk);
 	case QUIRK_AUDIO_EDIROL_UA700:
 		return create_ua700_quirk(chip, iface);
+	case QUIRK_AUDIO_EDIROL_UA1000:
+		return create_ua1000_quirk(chip, iface);
 	default:
 		snd_printd(KERN_ERR "invalid quirk type %d\n", quirk->type);
 		return -ENXIO;
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/usb/usbaudio.h linux/sound/usb/usbaudio.h
--- linux-2.6.8/sound/usb/usbaudio.h	2004-09-15 11:20:41.662864320 +0200
+++ linux/sound/usb/usbaudio.h	2004-09-07 19:22:53.000000000 +0200
@@ -156,6 +156,7 @@ struct snd_usb_audio {
 #define QUIRK_AUDIO_STANDARD_INTERFACE	5
 #define QUIRK_MIDI_STANDARD_INTERFACE	6
 #define QUIRK_AUDIO_EDIROL_UA700	7
+#define QUIRK_AUDIO_EDIROL_UA1000	8
 
 typedef struct snd_usb_audio_quirk snd_usb_audio_quirk_t;
 typedef struct snd_usb_midi_endpoint_info snd_usb_midi_endpoint_info_t;
@@ -187,7 +188,7 @@ struct snd_usb_midi_endpoint_info {
 
 /* for QUIRK_AUDIO/MIDI_STANDARD_INTERFACE, data is NULL */
 
-/* for QUIRK_AUDIO_EDIROL_UA700, data is NULL */
+/* for QUIRK_AUDIO_EDIROL_UA700/1000, data is NULL */
 
 /*
  */
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/usb/usbmixer_maps.c linux/sound/usb/usbmixer_maps.c
--- linux-2.6.8/sound/usb/usbmixer_maps.c	2004-09-15 11:20:41.679861736 +0200
+++ linux/sound/usb/usbmixer_maps.c	2004-09-03 15:40:16.000000000 +0200
@@ -91,6 +91,14 @@ static struct usbmix_name_map extigy_map
 	{ 0 } /* terminator */
 };
 
+/* LineX FM Transmitter entry - needed to bypass controls bug */
+static struct usbmix_name_map linex_map[] = {
+	/* 1: IT pcm */
+	/* 2: OT Speaker */ 
+	{ 3, "Master" }, /* FU: master volume - left / right / mute */
+	{ 0 } /* terminator */
+};
+
 /* Section "justlink_map" below added by James Courtier-Dutton <James@superbug.demon.co.uk>
  * sourced from Maplin Electronics (http://www.maplin.co.uk), part number A56AK
  * Part has 2 connectors that act as a single output. (TOSLINK Optical for digital out, and 3.5mm Jack for Analogue out.)
@@ -120,6 +128,7 @@ static struct usbmix_name_map justlink_m
 
 static struct usbmix_ctl_map usbmix_ctl_maps[] = {
 	{ 0x41e, 0x3000, extigy_map, 1 },
+	{ 0x8bb, 0x2702, linex_map, 1 },
 	{ 0xc45, 0x1158, justlink_map, 0 },
 	{ 0 } /* terminator */
 };
diff -rupN --exclude=CVS --exclude='.#*' linux-2.6.8/sound/usb/usbquirks.h linux/sound/usb/usbquirks.h
--- linux-2.6.8/sound/usb/usbquirks.h	2004-09-15 11:20:41.680861584 +0200
+++ linux/sound/usb/usbquirks.h	2004-09-07 19:22:54.000000000 +0200
@@ -638,37 +638,11 @@ YAMAHA_DEVICE(0x7010, "UB99"),
 		.data = (const snd_usb_audio_quirk_t[]) {
 			{
 				.ifnum = 1,
-				.type = QUIRK_AUDIO_FIXED_ENDPOINT,
-				.data = & (const struct audioformat) {
-					.format = SNDRV_PCM_FORMAT_S24,
-					.channels = 12,
-					.iface = 1,
-					.altsetting = 1,
-					.altset_idx = 1,
-					.attributes = 0,
-					.endpoint = 0x81,
-					.ep_attr = 0x01,
-					.rates = SNDRV_PCM_RATE_CONTINUOUS,
-					.rate_min = 48000,
-					.rate_max = 48000,
-				}
+				.type = QUIRK_AUDIO_EDIROL_UA1000
 			},
 			{
 				.ifnum = 2,
-				.type = QUIRK_AUDIO_FIXED_ENDPOINT,
-				.data = & (const struct audioformat) {
-					.format = SNDRV_PCM_FORMAT_S24,
-					.channels = 10,
-					.iface = 2,
-					.altsetting = 1,
-					.altset_idx = 1,
-					.attributes = 0,
-					.endpoint = 0x02,
-					.ep_attr = 0x01,
-					.rates = SNDRV_PCM_RATE_CONTINUOUS,
-					.rate_min = 48000,
-					.rate_max = 48000,
-				}
+				.type = QUIRK_AUDIO_EDIROL_UA1000
 			},
 			{
 				.ifnum = 3,
diff -ruN --exclude=CVS --exclude='.#*' linux-2.6.8/include/sound/ac97_codec.h linux/include/sound/ac97_codec.h
--- linux-2.6.8/include/sound/ac97_codec.h	2004-09-15 11:20:36.038719320 +0200
+++ linux/include/sound/ac97_codec.h	2004-09-13 12:28:30.000000000 +0200
@@ -26,6 +26,7 @@
  */
 
 #include <linux/bitops.h>
+#include "pcm.h"
 #include "control.h"
 #include "info.h"
 
@@ -133,6 +134,11 @@
 #define AC97_BC_20BIT_ADC	0x0200	/* 20-bit ADC resolution */
 #define AC97_BC_ADC_MASK	0x0300
 
+/* general purpose */
+#define AC97_GP_DRSS_MASK	0x0c00	/* double rate slot select */
+#define AC97_GP_DRSS_1011	0x0000	/* LR(C) 10+11(+12) */
+#define AC97_GP_DRSS_78		0x0400	/* LR 7+8 */
+
 /* extended audio ID bit defines */
 #define AC97_EI_VRA		0x0001	/* Variable bit rate supported */
 #define AC97_EI_DRA		0x0002	/* Double rate supported */
@@ -348,6 +354,8 @@
 #define AC97_SCAP_SKIP_AUDIO	(1<<4)	/* skip audio part of codec */
 #define AC97_SCAP_SKIP_MODEM	(1<<5)	/* skip modem part of codec */
 #define AC97_SCAP_INDEP_SDIN	(1<<6)	/* independent SDIN */
+#define AC97_SCAP_INV_EAPD	(1<<7)	/* inverted EAPD */
+#define AC97_SCAP_DETECT_BY_VENDOR (1<<8) /* use vendor registers for read tests */
 
 /* ac97->flags */
 #define AC97_HAS_PC_BEEP	(1<<0)	/* force PC Speaker usage */
@@ -355,6 +363,7 @@
 #define AC97_CS_SPDIF		(1<<2)	/* Cirrus Logic uses funky SPDIF */
 #define AC97_CX_SPDIF		(1<<3)	/* Conexant's spdif interface */
 #define AC97_STEREO_MUTES	(1<<4)	/* has stereo mute bits */
+#define AC97_DOUBLE_RATE	(1<<5)	/* supports double rate playback */
 
 /* rates indexes */
 #define AC97_RATES_FRONT_DAC	0
@@ -369,6 +378,7 @@
 	AC97_SHARED_TYPE_NONE,
 	AC97_SHARED_TYPE_ICH,
 	AC97_SHARED_TYPE_ATIIXP,
+	AC97_SHARED_TYPE_VIA,
 	AC97_SHARED_TYPES
 };
 
@@ -432,6 +442,7 @@
 	snd_card_t *card;
 	unsigned short num;	/* bus number */
 	unsigned short no_vra: 1, /* bridge doesn't support VRA */
+		       dra: 1,	/* bridge supports double rate */
 		       isdin: 1;/* independent SDIN */
 	unsigned int clock;	/* AC'97 base clock (usually 48000Hz) */
 	spinlock_t bus_lock;	/* used mainly for slot allocation */
@@ -518,6 +529,7 @@
 /* functions */
 int snd_ac97_bus(snd_card_t *card, int num, ac97_bus_ops_t *ops, void *private_data, ac97_bus_t **rbus); /* create new AC97 bus */
 int snd_ac97_mixer(ac97_bus_t *bus, ac97_template_t *template, ac97_t **rac97);	/* create mixer controls */
+const char *snd_ac97_get_short_name(ac97_t *ac97);
 
 void snd_ac97_write(ac97_t *ac97, unsigned short reg, unsigned short value);
 unsigned short snd_ac97_read(ac97_t *ac97, unsigned short reg);
@@ -538,18 +550,20 @@
 	AC97_TUNE_SWAP_SURROUND, /* swap master and surround controls */
 	AC97_TUNE_AD_SHARING,	/* for AD1985, turn on OMS bit and use headphone */
 	AC97_TUNE_ALC_JACK,	/* for Realtek, enable JACK detection */
+	AC97_TUNE_INV_EAPD,	/* inverted EAPD implementation */
 };
 
 struct ac97_quirk {
 	unsigned short vendor;	/* PCI vendor id */
 	unsigned short device;	/* PCI device id */
 	unsigned short mask;	/* device id bit mask, 0 = accept all */
+	unsigned int codec_id;	/* codec id (if any), 0 = accept all */
 	const char *name;	/* name shown as info */
 	int type;		/* quirk type above */
 };
 
 int snd_ac97_tune_hardware(ac97_t *ac97, struct ac97_quirk *quirk, int override);
-int snd_ac97_set_rate(ac97_t *ac97, int reg, unsigned short rate);
+int snd_ac97_set_rate(ac97_t *ac97, int reg, unsigned int rate);
 
 int snd_ac97_pcm_assign(ac97_bus_t *ac97,
 			unsigned short pcms_count,
@@ -557,5 +571,6 @@
 int snd_ac97_pcm_open(struct ac97_pcm *pcm, unsigned int rate,
 		      enum ac97_pcm_cfg cfg, unsigned short slots);
 int snd_ac97_pcm_close(struct ac97_pcm *pcm);
+int snd_ac97_pcm_double_rate_rules(snd_pcm_runtime_t *runtime);
 
 #endif /* __SOUND_AC97_CODEC_H */
diff -ruN --exclude=CVS --exclude='.#*' linux-2.6.8/include/sound/emu10k1.h linux/include/sound/emu10k1.h
--- linux-2.6.8/include/sound/emu10k1.h	2004-09-15 11:20:36.061715824 +0200
+++ linux/include/sound/emu10k1.h	2004-09-06 17:02:09.000000000 +0200
@@ -737,6 +737,9 @@
 #define FXGPREGBASE		0x100		/* FX general purpose registers base       	*/
 #define A_FXGPREGBASE		0x400		/* Audigy GPRs, 0x400 to 0x5ff			*/
 
+#define A_TANKMEMCTLREGBASE	0x100		/* Tank memory control registers base - only for Audigy */
+#define A_TANKMEMCTLREG_MASK	0x1f		/* only 5 bits used - only for Audigy */
+
 /* Tank audio data is logarithmically compressed down to 16 bits before writing to TRAM and is	*/
 /* decompressed back to 20 bits on a read.  There are a total of 160 locations, the last 32	*/
 /* locations are for external TRAM. 								*/
@@ -857,7 +860,7 @@
 	struct list_head list;		/* list link container */
 	unsigned int vcount;
 	unsigned int count;		/* count of GPR (1..16) */
-	unsigned char gpr[32];		/* GPR number(s) */
+	unsigned short gpr[32];		/* GPR number(s) */
 	unsigned int value[32];
 	unsigned int min;		/* minimum range */
 	unsigned int max;		/* maximum range */
@@ -870,7 +873,7 @@
 typedef struct _snd_emu10k1_fx8010_irq {
 	struct _snd_emu10k1_fx8010_irq *next;
 	snd_fx8010_irq_handler_t *handler;
-	unsigned char gpr_running;
+	unsigned short gpr_running;
 	void *private_data;
 } snd_emu10k1_fx8010_irq_t;
 
@@ -881,12 +884,12 @@
 	unsigned int channels;		/* 16-bit channels count */
 	unsigned int tram_start;	/* initial ring buffer position in TRAM (in samples) */
 	unsigned int buffer_size;	/* count of buffered samples */
-	unsigned char gpr_size;		/* GPR containing size of ring buffer in samples (host) */
-	unsigned char gpr_ptr;		/* GPR containing current pointer in the ring buffer (host = reset, FX8010) */
-	unsigned char gpr_count;	/* GPR containing count of samples between two interrupts (host) */
-	unsigned char gpr_tmpcount;	/* GPR containing current count of samples to interrupt (host = set, FX8010) */
-	unsigned char gpr_trigger;	/* GPR containing trigger (activate) information (host) */
-	unsigned char gpr_running;	/* GPR containing info if PCM is running (FX8010) */
+	unsigned short gpr_size;		/* GPR containing size of ring buffer in samples (host) */
+	unsigned short gpr_ptr;		/* GPR containing current pointer in the ring buffer (host = reset, FX8010) */
+	unsigned short gpr_count;	/* GPR containing count of samples between two interrupts (host) */
+	unsigned short gpr_tmpcount;	/* GPR containing current count of samples to interrupt (host = set, FX8010) */
+	unsigned short gpr_trigger;	/* GPR containing trigger (activate) information (host) */
+	unsigned short gpr_running;	/* GPR containing info if PCM is running (FX8010) */
 	unsigned char etram[32];	/* external TRAM address & data */
 	snd_pcm_indirect_t pcm_rec;
 	unsigned int tram_pos;
@@ -1141,6 +1144,13 @@
 #define ITRAM_ADDR(x)	(TANKMEMADDRREGBASE + 0x00 + (x)) /* x = 0x00 - 0x7f */
 #define ETRAM_ADDR(x)	(TANKMEMADDRREGBASE + 0x80 + (x)) /* x = 0x00 - 0x1f */
 
+#define A_ITRAM_DATA(x)	(TANKMEMDATAREGBASE + 0x00 + (x)) /* x = 0x00 - 0xbf */
+#define A_ETRAM_DATA(x)	(TANKMEMDATAREGBASE + 0xc0 + (x)) /* x = 0x00 - 0x3f */
+#define A_ITRAM_ADDR(x)	(TANKMEMADDRREGBASE + 0x00 + (x)) /* x = 0x00 - 0xbf */
+#define A_ETRAM_ADDR(x)	(TANKMEMADDRREGBASE + 0xc0 + (x)) /* x = 0x00 - 0x3f */
+#define A_ITRAM_CTL(x)	(A_TANKMEMCTLREGBASE + 0x00 + (x)) /* x = 0x00 - 0xbf */
+#define A_ETRAM_CTL(x)	(A_TANKMEMCTLREGBASE + 0xc0 + (x)) /* x = 0x00 - 0x3f */
+
 #define A_FXBUS(x)	(0x00 + (x))	/* x = 0x00 - 0x3f? */
 #define A_EXTIN(x)	(0x40 + (x))	/* x = 0x00 - 0x1f? */
 #define A_EXTOUT(x)	(0x60 + (x))	/* x = 0x00 - 0x1f? */
@@ -1269,8 +1279,11 @@
 #define A_C_00100000	0xd5
 #define A_GPR_ACCU	0xd6		/* ACCUM, accumulator */
 #define A_GPR_COND	0xd7		/* CCR, condition register */
-/* 0xd8 = noise1 */
-/* 0xd9 = noise2 */
+#define A_GPR_NOISE0	0xd8		/* noise source */
+#define A_GPR_NOISE1	0xd9		/* noise source */
+#define A_GPR_IRQ	0xda		/* IRQ register */
+#define A_GPR_DBAC	0xdb		/* TRAM Delay Base Address Counter - internal */
+#define A_GPR_DBACE	0xde		/* TRAM Delay Base Address Counter - external */
 
 /* definitions for debug register */
 #define EMU10K1_DBG_ZC			0x80000000	/* zero tram counter */
@@ -1310,7 +1323,7 @@
 	snd_ctl_elem_id_t id;		/* full control ID definition */
 	unsigned int vcount;		/* visible count */
 	unsigned int count;		/* count of GPR (1..16) */
-	unsigned char gpr[32];		/* GPR number(s) */
+	unsigned short gpr[32];		/* GPR number(s) */
 	unsigned int value[32];		/* initial values */
 	unsigned int min;		/* minimum range */
 	unsigned int max;		/* maximum range */
@@ -1320,8 +1333,8 @@
 typedef struct {
 	char name[128];
 
-	unsigned long gpr_valid[0x100/(sizeof(unsigned long)*8)]; /* bitmask of valid initializers */
-	unsigned int gpr_map[0x100];	  /* initializers */
+	unsigned long gpr_valid[0x200/(sizeof(unsigned long)*8)]; /* bitmask of valid initializers */
+	unsigned int gpr_map[0x200];	  /* initializers */
 
 	unsigned int gpr_add_control_count; /* count of GPR controls to add/replace */
 	emu10k1_fx8010_control_gpr_t __user *gpr_add_controls; /* GPR controls to add/replace */
@@ -1333,12 +1346,12 @@
 	unsigned int gpr_list_control_total; /* total count of GPR controls */
 	emu10k1_fx8010_control_gpr_t __user *gpr_list_controls; /* listed GPR controls */
 
-	unsigned long tram_valid[0xa0/(sizeof(unsigned long)*8)]; /* bitmask of valid initializers */
-	unsigned int tram_data_map[0xa0]; /* data initializers */
-	unsigned int tram_addr_map[0xa0]; /* map initializers */
+	unsigned long tram_valid[0x100/(sizeof(unsigned long)*8)]; /* bitmask of valid initializers */
+	unsigned int tram_data_map[0x100]; /* data initializers */
+	unsigned int tram_addr_map[0x100]; /* map initializers */
 
-	unsigned long code_valid[512/(sizeof(unsigned long)*8)];  /* bitmask of valid instructions */
-	unsigned int code[512][2];	  /* one instruction - 64 bits */
+	unsigned long code_valid[1024/(sizeof(unsigned long)*8)];  /* bitmask of valid instructions */
+	unsigned int code[1024][2];	  /* one instruction - 64 bits */
 } emu10k1_fx8010_code_t;
 
 typedef struct {
@@ -1354,12 +1367,12 @@
 	unsigned int channels;		/* 16-bit channels count, zero = remove this substream */
 	unsigned int tram_start;	/* ring buffer position in TRAM (in samples) */
 	unsigned int buffer_size;	/* count of buffered samples */
-	unsigned char gpr_size;		/* GPR containing size of ringbuffer in samples (host) */
-	unsigned char gpr_ptr;		/* GPR containing current pointer in the ring buffer (host = reset, FX8010) */
-	unsigned char gpr_count;	/* GPR containing count of samples between two interrupts (host) */
-	unsigned char gpr_tmpcount;	/* GPR containing current count of samples to interrupt (host = set, FX8010) */
-	unsigned char gpr_trigger;	/* GPR containing trigger (activate) information (host) */
-	unsigned char gpr_running;	/* GPR containing info if PCM is running (FX8010) */
+	unsigned short gpr_size;		/* GPR containing size of ringbuffer in samples (host) */
+	unsigned short gpr_ptr;		/* GPR containing current pointer in the ring buffer (host = reset, FX8010) */
+	unsigned short gpr_count;	/* GPR containing count of samples between two interrupts (host) */
+	unsigned short gpr_tmpcount;	/* GPR containing current count of samples to interrupt (host = set, FX8010) */
+	unsigned short gpr_trigger;	/* GPR containing trigger (activate) information (host) */
+	unsigned short gpr_running;	/* GPR containing info if PCM is running (FX8010) */
 	unsigned char pad;		/* reserved */
 	unsigned char etram[32];	/* external TRAM address & data (one per channel) */
 	unsigned int res2;		/* reserved */
diff -ruN --exclude=CVS --exclude='.#*' linux-2.6.8/include/sound/pcm.h linux/include/sound/pcm.h
--- linux-2.6.8/include/sound/pcm.h	2004-09-15 11:20:36.085712176 +0200
+++ linux/include/sound/pcm.h	2004-09-15 11:04:54.145101649 +0200
@@ -405,6 +405,8 @@
 	snd_info_entry_t *proc_sw_params_entry;
 	snd_info_entry_t *proc_status_entry;
 	snd_info_entry_t *proc_prealloc_entry;
+	/* misc flags */
+	unsigned int no_mmap_ctrl: 1;
 };
 
 #if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
diff -ruN --exclude=CVS --exclude='.#*' linux-2.6.8/include/sound/version.h linux/include/sound/version.h
--- linux-2.6.8/include/sound/version.h	2004-09-15 11:20:36.121706704 +0200
+++ linux/include/sound/version.h	2004-09-08 19:47:12.000000000 +0200
@@ -1,3 +1,3 @@
 /* include/version.h.  Generated by configure.  */
-#define CONFIG_SND_VERSION "1.0.6"
-#define CONFIG_SND_DATE " (Sun Aug 15 07:17:53 2004 UTC)"
+#define CONFIG_SND_VERSION "1.0.7rc1"
+#define CONFIG_SND_DATE ""
diff -ruN --exclude=CVS --exclude='.#*' linux-2.6.8/Documentation/sound/alsa/ALSA-Configuration.txt linux/Documentation/sound/alsa/ALSA-Configuration.txt
--- linux-2.6.8/Documentation/sound/alsa/ALSA-Configuration.txt	2004-09-15 11:20:15.351864200 +0200
+++ linux/Documentation/sound/alsa/ALSA-Configuration.txt	2004-09-03 16:13:40.000000000 +0200
@@ -661,8 +661,6 @@
 			* ALi m5455
 
     ac97_clock	  - AC'97 codec clock base (0 = auto-detect)
-    joystick      - Enable joystick (default off)
-    mpu_port      - MPU401 port # (0 = disabled, 0x330,0x300)
     ac97_quirk    - AC'97 workaround for strange hardware (-1 = default)
                     -1 = default, don't override
                      0 = disable
@@ -670,6 +668,7 @@
                      2 = swap headphone and master controls
                      3 = for AD1985, turn on OMS bit and use headphone
                      4 = for ALC65x, turn on the jack sense mode
+                     5 = inverted EAPD implementation
     buggy_irq      - Enable workaround for buggy interrupts on some
                      motherboards (default off)
 
@@ -679,8 +678,9 @@
     if you still encounter too fast playback, specify the clock
     explicitly via the module option "ac97_clock=41194".
 
-    The joystick and MPU-401 are supported only certain hardwares.
-    MPU401 is experimental,  It doesn't work perfectly.
+    Joystick/MIDI ports are not supported by this driver.  If your
+    motherboard has these devices, use the ns558 or snd-mpu401
+    modules, respectively.
 
     The ac97_quirk option is used to enable/override the workaround
     for specific devices.  Some hardware have swapped output pins
diff -ruN --exclude=CVS --exclude='.#*' linux-2.6.8/Documentation/sound/alsa/DocBook/writing-an-alsa-driver.tmpl linux/Documentation/sound/alsa/DocBook/writing-an-alsa-driver.tmpl
--- linux-2.6.8/Documentation/sound/alsa/DocBook/writing-an-alsa-driver.tmpl	2004-09-15 11:20:15.357863288 +0200
+++ linux/Documentation/sound/alsa/DocBook/writing-an-alsa-driver.tmpl	2004-09-01 21:13:57.000000000 +0200
@@ -4060,8 +4060,8 @@
       <para>
         Also, there is a function to change the sample rate (of a
         certain register such as
-        <constant>AC97_PCM_FRONT_DAC_RATE</constant>) when VRA is
-        supported by the codec:
+        <constant>AC97_PCM_FRONT_DAC_RATE</constant>) when VRA or
+        DRA is supported by the codec:
         <function>snd_ac97_set_rate()</function>. 
 
         <informalexample>
diff -ruN --exclude=CVS --exclude='.#*' linux-2.6.8/Documentation/sound/alsa/Joystick.txt linux/Documentation/sound/alsa/Joystick.txt
--- linux-2.6.8/Documentation/sound/alsa/Joystick.txt	2004-08-14 07:36:58.000000000 +0200
+++ linux/Documentation/sound/alsa/Joystick.txt	2004-09-13 12:28:27.000000000 +0200
@@ -49,17 +49,15 @@
     cs46xx	N/A		N/A
     es1938	N/A		N/A
     es1968	joystick	0 = disable (default), 1 = enable
-    intel8x0(*1)joystick	0 = disable (default), 1 = enable
     sonicvibes	N/A		N/A
     trident	N/A		N/A
-    via82xx(*2)	joystick	0 = disable (default), 1 = enable
+    via82xx(*1)	joystick	0 = disable (default), 1 = enable
     ymfpci	joystick_port	0 = disable (default), 1 = auto-detect,
-                                manual: 0x201, 0x202, 0x204, 0x205(*3)
+                                manual: 0x201, 0x202, 0x204, 0x205(*2)
     ---------------------------------------------------------------------------
 
-    *1)  not all chips support joystick
-    *2)  VIA686A/B only
-    *3)  With YMF744/754 chips, the port address can be chosen arbitrarily
+    *1)  VIA686A/B only
+    *2)  With YMF744/754 chips, the port address can be chosen arbitrarily
 
 The following drivers don't support gameport natively, but there are
 additional modules.  Load the corresponding module to add the gameport

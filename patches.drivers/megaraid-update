diff -urNp linux-2.6.5/drivers/scsi/Kconfig linux-2.6.5.SUSE/drivers/scsi/Kconfig
--- linux-2.6.5/drivers/scsi/Kconfig	2004-04-29 16:32:18.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/Kconfig	2004-04-29 16:35:01.000000000 +0200
@@ -402,15 +402,78 @@ config SCSI_IN2000
 	  To compile this driver as a module, choose M here: the
 	  module will be called in2000.
 
-config SCSI_MEGARAID
-	tristate "AMI MegaRAID support"
+config MEGARAID_NEWGEN
+	bool "LSI Logic New Generation RAID Device Drivers"
 	depends on PCI && SCSI
+	default y
 	help
-	  This driver supports the AMI MegaRAID 418, 428, 438, 466, 762, 490
-	  and 467 SCSI host adapters.
+	LSI Logic RAID Device Drivers
 
-	  To compile this driver as a module, choose M here: the
-	  module will be called megaraid.
+config MEGARAID_MM
+	tristate "LSI Logic Management Module (New Driver)"
+	depends on PCI && SCSI && MEGARAID_NEWGEN
+	default m
+	help
+	Management Module provides ioctl, sysfs support for LSI Logic
+	RAID controllers.
+	To compile this driver as a module, choose M here: the
+	module will be called megaraid_mm
+
+config MEGARAID_MAILBOX
+	tristate "LSI Logic MegaRAID Driver (New Driver)"
+	depends on PCI && SCSI && MEGARAID_MM
+	default $MEGARAID_MM
+	help
+	List of supported controllers
+
+	OEM	Product Name		Ser	VID :DID :SVID:SSID
+	---	------------		---	---- ---- ---- ----
+	Dell	PERC3/Di		N/A	1028:000E:1028:0123
+	Dell	PERC4/SC		520	1000:1960:1028:0520
+	Dell	PERC4/DC		518	1000:1960:1028:0518
+	Dell	PERC4/QC		531	1000:0407:1028:0531
+	Dell	PERC4/Di		N/A	1028:000F:1028:014A
+	Dell	PERC 4e/Si		N/A	1028:0013:1028:016c
+	Dell	PERC 4e/Di		N/A	1028:0013:1028:016d
+	Dell	PERC 4e/Di		N/A	1028:0013:1028:016e
+	Dell	PERC 4e/Di		N/A	1028:0013:1028:016f
+	Dell	PERC 4e/Di		N/A	1028:0013:1028:0170
+	Dell	PERC 4e/DC		N/A	1000:0408:1028:0002
+	Dell	PERC 4e/SC		N/A	1000:0408:1028:0001
+
+	LSI	MegaRAID SCSI 320-0	520-0	1000:1960:1000:A520
+	LSI	MegaRAID SCSI 320-1	520	1000:1960:1000:0520
+	LSI	MegaRAID SCSI 320-2	518	1000:1960:1000:0518
+	LSI	MegaRAID SCSI 320-0X	EP055	1000:0407:1000:0530
+	LSI	MegaRAID SCSI 320-2X	532	1000:0407:1000:0532
+	LSI	MegaRAID SCSI 320-4X	531	1000:0407:1000:0531
+
+	LSI	MegaRAID SCSI 320-1E	N/A	1000:0408:1000:0001
+	LSI	MegaRAID SCSI 320-2E	EP078	1000:0408:1000:0002
+	LSI	MegaRAID SCSI 320-4E
+
+	LSI	MegaRAID SATA 150-2	534	1095:3112:1000:0534
+	LSI	MegaRAID SATA 150-4	523	1000:1960:1000:4523
+	LSI	MegaRAID SATA 150-6	523	1000:1960:1000:0523
+	LSI	MegaRAID SATA 150-4X		1000:0409:1000:1504
+	LSI	MegaRAID SATA 150-8X		1000:0409:1000:1508
+
+	To compile this driver as a module, choose M here: the
+	module will be called megaraid
+
+if MEGARAID_NEWGEN=n
+config MEGARAID_LEGACY
+	tristate "LSI Logic Legacy MegaRAID Driver"
+	depends on PCI && SCSI
+	default m
+	help
+	This driver supports the AMI MegaRAID 418, 428, 438, 466, 762, 490
+	and 467 SCSI host adapters. This driver also support the all U320
+	RAID controllers
+
+	To compile this driver as a module, choose M here: the
+	module will be called megaraid
+endif
 
 config SCSI_SATA
 	bool "Serial ATA (SATA) support"
diff -urNp linux-2.6.5/drivers/scsi/Makefile linux-2.6.5.SUSE/drivers/scsi/Makefile
--- linux-2.6.5/drivers/scsi/Makefile	2004-04-29 16:32:18.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/Makefile	2004-04-29 16:35:46.000000000 +0200
@@ -95,7 +95,9 @@ obj-$(CONFIG_SCSI_IBMMCA)	+= ibmmca.o
 obj-$(CONFIG_SCSI_EATA)		+= eata.o
 obj-$(CONFIG_SCSI_DC395x)	+= dc395x.o
 obj-$(CONFIG_SCSI_DC390T)	+= tmscsim.o
-obj-$(CONFIG_SCSI_MEGARAID)	+= megaraid.o
+obj-$(CONFIG_MEGARAID_MM)	+= megaraid_mm.o
+obj-$(CONFIG_MEGARAID_MAILBOX)	+= megaraid.o
+megaraid-objs			+= megaraid_mbox.o megaraid_clib.o
 obj-$(CONFIG_SCSI_ACARD)	+= atp870u.o
 obj-$(CONFIG_SCSI_SUNESP)	+= esp.o
 obj-$(CONFIG_SCSI_GDTH)		+= gdth.o
diff -urNp linux-2.6.5/drivers/scsi/README.megaraid linux-2.6.5.SUSE/drivers/scsi/README.megaraid
--- linux-2.6.5/drivers/scsi/README.megaraid	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/README.megaraid	2004-04-27 18:45:56.000000000 +0200
@@ -0,0 +1,70 @@
+			Notes on Management Module
+			~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Overview:
+--------
+
+Different classes of controllers from LSI Logic, accept and respond to the
+user applications in a similar way. They understand the same firmware control
+commands. Furthermore, the applications also can treat different classes of
+the controllers uniformly. Hence it is logical to have a single module that
+interefaces with the applications on one side and all the low level drivers
+on the other.
+
+The advantages, though obvious, are listed for completeness:
+
+	i.	Avoid duplicate code from the low level drivers.
+	ii.	Unburden the low level drivers from having to export the
+		character node device and related handling.
+	iii.	Implement any policy mechanisms in one place.
+	iv.	Applications have to interface with only module instead of
+		multiple low level drivers.
+
+Currently this module (called Common Management Module) is used only to issue
+ioctl commands. But this module is envisioned to handle all user space level
+interactions. So any 'proc', 'sysfs' implementations will be localized in this
+common module.
+
+Credits:
+-------
+
+"Shared code in a third module, a "library module", is an acceptable
+solution. modprobe automatically loads dependent modules, so users
+running "modprobe driver1" or "modprobe driver2" would automatically
+load the shared library module."
+
+		- Jeff Garzik (jgarzik@pobox.com), 02.25.2004 LKML
+
+"As Jeff hinted, if your userspace<->driver API is consistent between
+your new MPT-based RAID controllers and your existing megaraid driver,
+then perhaps you need a single small helper module (lsiioctl or some
+better name), loaded by both mptraid and megaraid automatically, which
+handles registering the /dev/megaraid node dynamically. In this case,
+both mptraid and megaraid would register with lsiioctl for each
+adapter discovered, and lsiioctl would essentially be a switch,
+redirecting userspace tool ioctls to the appropriate driver."
+
+		- Matt Domsch, (Matt_Domsch@dell.com), 02.25.2004 LKML
+
+Design:
+------
+
+The Common Management Module is implemented in megaraid_mm.[ch] files. This
+module acts as a registry for low level hba drivers. The low level drivers
+(currently only megaraid) register each controller with the common module.
+
+The applications interface with the common module via the character device
+node exported by the module.
+
+The lower level drivers now understand only a new improved ioctl packet called
+uioc_t. The management module converts the older ioctl packets from the older
+applications into uioc_t. After driver handles the uioc_t, the common module
+will convert that back into the old format before returning to applications.
+
+As new applications evolve and replace the old ones, the old packet format 
+will be retired.
+
+Common module dedicates one uioc_t packet to each controller registered. This
+can easily be more than one. But since megaraid is the only low level driver
+today, and it can handle only one ioctl, there is no reason to have more. But
+as new controller classes get added, this will be tuned appropriately.
diff -urNp linux-2.6.5/drivers/scsi/kdep.h linux-2.6.5.SUSE/drivers/scsi/kdep.h
--- linux-2.6.5/drivers/scsi/kdep.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/kdep.h	2004-04-27 18:45:56.000000000 +0200
@@ -0,0 +1,92 @@
+/*
+ *
+ *			Linux MegaRAID device driver
+ *
+ * Copyright (c) 2003-2004  LSI Logic Corporation.
+ *
+ *	   This program is free software; you can redistribute it and/or
+ *	   modify it under the terms of the GNU General Public License
+ *	   as published by the Free Software Foundation; either version
+ *	   2 of the License, or (at your option) any later version.
+ *
+ * FILE		: kdep.h
+ * Version	: v2.20.0 (Apr 14 2004)
+ *
+ * This file maintains the backward compatibility in lk 2.6 driver to lk 2.4
+ * drivers.
+ */
+
+#include <linux/mm.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <linux/delay.h>
+#include <linux/version.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <linux/pci.h>
+#include <linux/list.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#include <linux/blkdev.h>
+#else
+#include <linux/reboot.h>
+#include <linux/blk.h>
+#include "sd.h"
+#endif
+#include "scsi.h"
+#include "hosts.h"
+#include <scsi/scsicam.h>
+
+#ifndef _KDEP_H_
+#define _KDEP_H_
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+
+#define mraid_scsi_host_alloc		scsi_host_alloc
+#define mraid_scsi_host_dealloc		scsi_host_put
+#define mraid_scsi_set_pdev(host, pdev)	scsi_set_device(host, &(pdev)->dev)
+
+// conversion from scsi command
+#define SCP2HOST(scp)			(scp)->device->host	// to host
+#define SCP2HOSTDATA(scp)		SCP2HOST(scp)->hostdata	// to soft state
+#define SCP2CHANNEL(scp)		(scp)->device->channel	// to channel
+#define SCP2TARGET(scp)			(scp)->device->id	// to target
+#define SCP2LUN(scp)			(scp)->device->lun	// to LUN
+
+#else	// lk 2.4
+
+#define mraid_scsi_host_alloc		scsi_register
+#define mraid_scsi_host_dealloc		scsi_unregister
+#define mraid_scsi_set_pdev(host, pdev)	scsi_set_pci_device(host, pdev)
+
+#define scsi_add_host(x,y)		(0)
+#define scsi_remove_host(x)		do {} while(0)
+#define scsi_scan_host(x)		do {} while(0)
+
+// conversion from scsi command
+#define SCP2HOST(scp)			(scp)->host		// to host
+#define SCP2HOSTDATA(scp)		SCP2HOST(scp)->hostdata	// to soft state
+#define SCP2CHANNEL(scp)		(scp)->channel		// to channel
+#define SCP2TARGET(scp)			(scp)->target		// to target
+#define SCP2LUN(scp)			(scp)->lun		// to LUN
+
+typedef void irqreturn_t;
+#define	IRQ_RETVAL(x)
+
+#endif
+
+// generic macro to convert scsi command and host to controller's soft state
+#define SCSIHOST2ADAP(host)	(adapter_t *)(((caddr_t *)(host->hostdata))[0])
+#define SCP2ADAPTER(scp)	SCSIHOST2ADAP(SCP2HOST(scp))
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#define mraid_set_host_lock(host, plock) scsi_assign_lock(host, plock)
+#elif defined SCSI_HAS_HOST_LOCK
+#define mraid_set_host_lock(host, plock) (host)->lock = plock
+#else
+	adapter->host_lock = &io_request_lock;
+#endif
+
+#endif	// _KDEP_H_
+
+/* vim: set ts=8 sw=8 tw=78 ai si: */
diff -urNp linux-2.6.5/drivers/scsi/lsi_defs.h linux-2.6.5.SUSE/drivers/scsi/lsi_defs.h
--- linux-2.6.5/drivers/scsi/lsi_defs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/lsi_defs.h	2004-04-27 18:45:56.000000000 +0200
@@ -0,0 +1,256 @@
+/*
+ * lsi_defs.h	: Information common to all LSI's intelligent controllers
+ */
+
+#ifndef LSI_COMMON_DEFS
+#define LSI_COMMON_DEFS
+
+/*
+ * Definitions common for all LSI modules
+ */
+
+#define MAX_CDB_LEN	  		   	10
+#define MAX_EXT_CDB_LEN				16
+#define MAX_REQ_SENSE_LEN			0x20
+
+#define	LSI_MAX_LOGICAL_DRIVES_64LD		(64+1)
+#define LSI_MAX_PHYSICAL_DEVICES		60
+#define LSI_MAX_CHANNELS			16
+#define LSI_MAX_DEVICES_PER_CHANNEL		16
+
+#define ADDR_LO(addr)	(((unsigned long)(addr)) & 0xffffffff)
+#define ADDR_HI(addr)	((((ulong)(addr)) & 0xffffffff00000000ULL) >> 32)
+#define ADDR_64(hi, lo)	((((uint64_t)(hi)) << 32) | (lo))
+
+typedef enum { MRAID_FALSE, MRAID_TRUE } bool_t;
+typedef enum { MRAID_SUCCESS, MRAID_FAILURE, MRAID_BUSY } status_t;
+
+/**
+ * con_log() - console log routine
+ * @param level		: indicates the severity of the message.
+ * @fparam mt		: format string
+ *
+ * con_log displays the error messages on the console based on the current
+ * debug level. Also it attaches the appropriate kernel severity level with
+ * the message.
+ *
+ *
+ * consolge messages debug levels
+ */
+#define	CL_ANN		0	/* print unconditionally, announcements */
+#define CL_DLEVEL1	1	/* debug level 1, informative */
+#define CL_DLEVEL2	2	/* debug level 2, verbose */
+#define CL_DLEVEL3	3	/* debug level 3, very verbose */
+
+#define	con_log(level, fmt) if (LSI_DBGLVL >= level) printk fmt;
+
+/*
+ * Definitions & Declarations needed to use common management module
+ */
+
+#define MEGAIOC_MAGIC		'm'
+#define MEGAIOCCMD		_IOWR(MEGAIOC_MAGIC, 0, mimd_t)
+
+#define MEGAIOC_QNADAP		'm'	/* Query # of adapters		*/
+#define MEGAIOC_QDRVRVER	'e'	/* Query driver version		*/
+#define MEGAIOC_QADAPINFO   	'g'	/* Query adapter information	*/
+
+#define USCSICMD		0x80
+#define VENDOR_SPECIFIC_CMDS	0xE0
+#define MEGA_INTERNAL_CMD	(VENDOR_SPECIFIC_CMDS + 0x01)
+
+#define UIOC_RD			0x00001
+#define UIOC_WR			0x00002
+
+#define MBOX_CMD		0x00000	
+#define GET_DRIVER_VER		0x10000
+#define GET_N_ADAP		0x20000
+#define GET_ADAP_INFO		0x30000
+#define GET_CAP			0x40000
+#define GET_STATS		0x50000
+#define GET_IOCTL_VERSION	0x01
+
+#define MAX_LSI_CMN_ADAPS	16
+
+#define EXT_IOCTL_SIGN_SZ	16
+#define EXT_IOCTL_SIGN		"$$_EXTD_IOCTL_$$"
+
+#define	MBOX_LEGACY		0x00		/* ioctl has legacy mbox*/
+#define MBOX_HPE		0x01		/* ioctl has hpe mbox	*/
+
+#define	APPTYPE_MIMD		0x00		/* old existing apps	*/
+#define APPTYPE_UIOC		0x01		/* new apps using uioc	*/
+
+#define IOCTL_ISSUE		0x00000001	/* Issue ioctl		*/
+#define IOCTL_ABORT		0x00000002	/* Abort previous ioctl	*/
+
+#define DRVRTYPE_MBOX		0x00000001	/* regular mbox driver	*/
+#define DRVRTYPE_HPE		0x00000002	/* new hpe driver	*/
+
+#define LC_SUCCESS		0x00000000	/* Generic success code	*/
+#define	LC_EFULL		0x00000001	/* Exceeded max capacity*/
+#define LC_EINVAL		0x00000002	/* Invalid argument	*/
+#define LC_EEXISTS		0x00000004	/* Already exists	*/
+#define LC_ENOADP		0x00000008	/* Adp not found	*/
+#define LC_ENOTSUPP		0x00000010	/* Op not supported	*/
+#define LC_ETIME		0x00000020	/* Op timedout		*/
+#define LC_PENDING		0x00000040	/* ioctl pending @ lld	*/
+#define LC_UNKNOWN		0x00000080	/* Unknown err frm lld	*/
+#define LC_ENOMEM		0x00000100	/* Mem alloc failed	*/
+
+#define MKADAP(adapno)	(MEGAIOC_MAGIC << 8 | (adapno) )
+#define GETADAP(mkadap)	((mkadap) ^ MEGAIOC_MAGIC << 8)
+
+/**
+ * struct uioc_t - the common ioctl packet structure
+ *
+ * @signature	: Must be "$$_EXTD_IOCTL_$$"
+ * @mb_type	: Type of the mail box (MB_LEGACY or MB_HPE)
+ * @app_type	: Type of the issuing application (existing or new)
+ * @opcode	: Opcode of the command
+ * @adapno	: Adapter number
+ * @cmdbuf	: Pointer to buffer - can point to mbox or plain data buffer
+ * @xferlen	: xferlen for DCMD and non mailbox commands
+ * @data_dir	: Direction of the data transfer
+ * @status	: Status from the driver
+ *
+ * Note		: All LSI drivers understand only this packet. Any other
+ *		: format sent by applications would be converted to this.
+ *		: All addresses are 64 bits (even on 32-bit platforms).
+ */
+
+typedef void(*DONE)(void);
+
+#define EXT_IOCTL_PACKET_SZ		128
+#define IOC_VALID_FIELDS_SZ		(46+sizeof(DONE))
+
+/* 
+ * FIXME: reserve 32 bytes for driver at the bottom
+ */
+typedef struct uioc {
+
+/* User Apps: */
+	
+	uint8_t		signature[EXT_IOCTL_SIGN_SZ];
+	uint8_t		mb_type;
+	uint8_t		app_type;
+	uint32_t	opcode;
+	uint32_t	adapno;
+	uint64_t	cmdbuf;
+	uint32_t	xferlen;
+	uint32_t	data_dir;
+	uint32_t	status;
+
+/* Driver Data: */	
+	void (*done)(struct uioc*);
+
+	uint8_t		reserved[EXT_IOCTL_PACKET_SZ - IOC_VALID_FIELDS_SZ];
+
+} __attribute__ ((packed)) uioc_t;
+
+/**
+ * struct mraid_hba_info - information about the controller
+ *
+ * @param pci_vendor_id		: PCI vendor id
+ * @param pci_device_id		: PCI device id
+ * @param subsystem_vendor_id	: PCI subsystem vendor id
+ * @param subsystem_device_id	: PCI subsystem device id
+ * @param baseport		: base port of hba memory
+ * @param pci_bus		: PCI bus
+ * @param pci_dev_fn		: PCI device/function values
+ * @param irq			: interrupt vector for the device
+ * @param reserved1		: filler to align a even boundary
+ * @param reserved		: reserved space
+ *
+ * Extended information of 256 bytes about the controller. Align on the single
+ * byte boundary so that 32-bit applications can be run on 64-bit platform
+ * drivers withoug re-compilation.
+ * NOTE: reduce the number of reserved bytes whenever new field are added, so
+ * that total size of the structure remains 256 bytes.
+ */
+typedef struct mraid_hba_info {
+
+	uint16_t	pci_vendor_id;
+	uint16_t	pci_device_id;
+	uint16_t	subsys_vendor_id;
+	uint16_t	subsys_device_id;
+
+	uint64_t	baseport;
+	uint8_t		pci_bus;
+	uint8_t		pci_dev_fn;
+	uint8_t		pci_slot;
+	uint8_t		irq;
+
+	uint8_t		reserved1;
+	uint32_t	unique_id;
+	uint32_t	host_no;
+
+	uint8_t		num_ldrv;
+
+	uint8_t		reserved[256 - 30];
+
+} __attribute__ ((packed)) mraid_hba_info_t;
+
+typedef struct mcontroller {
+
+	uint64_t	base;
+	uint8_t		irq;
+	uint8_t		numldrv;
+	uint8_t		pcibus;
+	uint16_t	pcidev;
+	uint8_t		pcifun;
+	uint16_t	pciid;
+	uint16_t	pcivendor;
+	uint8_t		pcislot;
+	uint32_t	uid;
+
+} __attribute__ ((packed)) mcontroller_t;
+
+/**
+ * mraid_mmadp_t: Structure that drivers pass during (un)registration
+ *
+ * @unique_id	: Any unique id (usually PCI bus+dev+fn)
+ * @drvr_type	: megaraid or hpe (DRVRTYPE_MBOX or DRVRTYPE_HPE)
+ * @drv_data	: Driver specific; not touched by the common module
+ * @dev		: pci dev; used for allocating dma'ble memory
+ * @issue_uioc	: Driver supplied routine to issue uioc_t commands
+ *		: issue_uioc(drvr_data, kioc, ISSUE/ABORT, uioc_done)
+ */
+
+typedef struct mraid_mmadp {
+
+/* Filled by driver */
+
+	uint32_t		unique_id;
+	uint32_t		drvr_type;
+	ulong			drvr_data;
+	uint8_t			timeout;
+
+	struct pci_dev*		pdev;
+
+	int(*issue_uioc)(ulong, uioc_t*, uint32_t);
+
+/* Maintained by common module */
+
+	uioc_t			kioc;
+	struct semaphore	kioc_mtx;
+
+	caddr_t			memblk;
+	dma_addr_t		memblk_dmah;
+
+	caddr_t			int_data;
+	uint32_t		int_data_len;
+	dma_addr_t		int_data_dmah;
+	caddr_t			int_data_user;
+
+	caddr_t			int_pthru;
+	uint32_t		int_pthru_len;
+	dma_addr_t		int_pthru_dmah;
+	caddr_t			int_pthru_user;
+
+} mraid_mmadp_t;
+
+uint32_t mraid_mm_register_adp( mraid_mmadp_t* );
+uint32_t mraid_mm_unregister_adp( uint32_t );
+
+#endif /*LSI_COMMON_DEFS*/
diff -urNp linux-2.6.5/drivers/scsi/mbox_defs.h linux-2.6.5.SUSE/drivers/scsi/mbox_defs.h
--- linux-2.6.5/drivers/scsi/mbox_defs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/mbox_defs.h	2004-04-27 18:45:56.000000000 +0200
@@ -0,0 +1,829 @@
+/*
+ *
+ *			Linux MegaRAID Unified device driver
+ *
+ * Copyright (c) 2003-2004  LSI Logic Corporation.
+ *
+ *	   This program is free software; you can redistribute it and/or
+ *	   modify it under the terms of the GNU General Public License
+ *	   as published by the Free Software Foundation; either version
+ *	   2 of the License, or (at your option) any later version.
+ *
+ * FILE		: mbox_defs.h
+ *
+ */
+#ifndef _MRAID_UNIFIED_MBOX_DEFS_H_
+#define _MRAID_UNIFIED_MBOX_DEFS_H_
+
+#include "lsi_defs.h"
+
+/*
+ * All drivers must define the size of maximum transfer that can happen
+ * through the firmware commands. If an application need to transfer more than
+ * this amount of data, driver must allocate that memory on the fly and
+ * release it after completing the command.
+ */
+#define MBOX_IBUF_SIZE	4096
+
+
+#define SIGN_OFFSET_64BIT	0xA4	// signature offset of 64-bit HBAs
+#define HBA_SIGNATURE_64BIT	0x0299	// signature for 64-bit HBAs
+
+
+/*
+ * Commands and states for mailbox based controllers
+ */
+
+#define MBOXCMD_LREAD		0x01
+#define MBOXCMD_LWRITE		0x02
+#define MBOXCMD_PASSTHRU	0x03
+#define MBOXCMD_ADPEXTINQ	0x04
+#define MBOXCMD_ADAPTERINQ	0x05
+#define MBOXCMD_LREAD64		0xA7
+#define MBOXCMD_LWRITE64	0xA8
+#define MBOXCMD_PASSTHRU64	0xC3
+#define MBOXCMD_EXTPTHRU	0xE3
+
+#define MAIN_MISC_OPCODE	0xA4
+#define GET_MAX_SG_SUPPORT	0x01
+#define SUPPORT_EXT_CDB		0x16
+
+#define FC_NEW_CONFIG		0xA1
+#define NC_SUBOP_PRODUCT_INFO	0x0E
+#define NC_SUBOP_ENQUIRY3	0x0F
+#define ENQ3_GET_SOLICITED_FULL	0x02
+#define OP_DCMD_READ_CONFIG	0x04
+#define NEW_READ_CONFIG_8LD	0x67
+#define READ_CONFIG_8LD		0x07
+#define FLUSH_ADAPTER		0x0A
+#define FLUSH_SYSTEM		0xFE
+
+/*
+ * Command for random deletion of logical drives
+ */
+#define	FC_DEL_LOGDRV		0xA4
+#define	OP_SUP_DEL_LOGDRV	0x2A
+#define OP_GET_LDID_MAP		0x18
+#define OP_DEL_LOGDRV		0x1C
+
+/*
+ * BIOS commands
+ */
+#define IS_BIOS_ENABLED		0x62
+#define GET_BIOS		0x01
+#define CHNL_CLASS		0xA9
+#define GET_CHNL_CLASS		0x00
+#define SET_CHNL_CLASS		0x01
+#define CH_RAID			0x01
+#define CH_SCSI			0x00
+#define BIOS_PVT_DATA		0x40
+#define GET_BIOS_PVT_DATA	0x00
+
+
+/*
+ * Commands to support clustering
+ */
+#define GET_TARGET_ID		0x7D
+#define CLUSTER_OP		0x70
+#define GET_CLUSTER_MODE	0x02
+#define CLUSTER_CMD		0x6E
+#define RESERVE_LD		0x01
+#define RELEASE_LD		0x02
+#define RESET_RESERVATIONS	0x03
+#define RESERVATION_STATUS	0x04
+#define RESERVE_PD		0x05
+#define RELEASE_PD		0x06
+
+
+/*
+ * Module battery status
+ */
+#define BATTERY_MODULE_MISSING		0x01
+#define BATTERY_LOW_VOLTAGE		0x02
+#define BATTERY_TEMP_HIGH		0x04
+#define BATTERY_PACK_MISSING		0x08
+#define BATTERY_CHARGE_MASK		0x30
+#define BATTERY_CHARGE_DONE		0x00
+#define BATTERY_CHARGE_INPROG		0x10
+#define BATTERY_CHARGE_FAIL		0x20
+#define BATTERY_CYCLES_EXCEEDED		0x40
+
+/*
+ * Physical drive states.
+ */
+#define PDRV_UNCNF	0
+#define PDRV_ONLINE	3
+#define PDRV_FAILED	4
+#define PDRV_RBLD	5
+#define PDRV_HOTSPARE	6
+
+
+/*
+ * Raid logical drive states.
+ */
+#define RDRV_OFFLINE	0
+#define RDRV_DEGRADED	1
+#define RDRV_OPTIMAL	2
+#define RDRV_DELETED	3
+
+/*
+ * Read, write and cache policies
+ */
+#define NO_READ_AHEAD		0
+#define READ_AHEAD		1
+#define ADAP_READ_AHEAD		2
+#define WRMODE_WRITE_THRU	0
+#define WRMODE_WRITE_BACK	1
+#define CACHED_IO		0
+#define DIRECT_IO		1
+
+#define MAX_LOGICAL_DRIVES_8LD		8
+#define MAX_LOGICAL_DRIVES_40LD		40
+#define FC_MAX_PHYSICAL_DEVICES		256
+#define MAX_MBOX_CHANNELS		5
+#define MAX_MBOX_TARGET			15
+#define MBOX_MAX_PHYSICAL_DRIVES	MAX_MBOX_CHANNELS*MAX_MBOX_TARGET
+#define MAX_ROW_SIZE_40LD		32
+#define MAX_ROW_SIZE_8LD		8
+#define SPAN_DEPTH_8_SPANS		8
+#define SPAN_DEPTH_4_SPANS		4
+
+
+/*
+ * Parameters for the io-mapped controllers
+ */
+
+/* I/O Port offsets */
+#define MBOX_CMD_PORT	 		0x00
+#define MBOX_ACK_PORT	 		0x00
+#define MBOX_TOGGLE_PORT		0x01
+#define MBOX_INTR_PORT	  		0x0a
+
+#define MBOX_BUSY_PORT     		0x00
+#define MBOX_PORT0	 		0x04
+#define MBOX_PORT1	 		0x05
+#define MBOX_PORT2	 		0x06
+#define MBOX_PORT3	 		0x07
+#define ENABLE_MBOX_REGION 		0x0B
+
+/* I/O Port Values */
+#define MBOX_ISSUE_BYTE	 		0x10
+#define MBOX_ACK_BYTE	   		0x08
+#define MBOX_ENABLE_INTR_BYTE   	0xc0
+#define MBOX_DISABLE_INTR_BYTE  	0x00
+#define MBOX_VALID_INTR_BYTE    	0x40
+#define MBOX_BUSY_BYTE     		0x10
+#define ENABLE_MBOX_BYTE   		0x00
+#define MBOX_INTR_VALID			0x40
+
+
+/**
+ * struct mbox_t - Driver and f/w handshake structure.
+ * @cmd		: firmware command
+ * @cmdid	: command id
+ * @numsectors	: number of sectors to be transferred
+ * @lba		: Logical Block Address on LD
+ * @xferaddr	: DMA address for data transfer
+ * @logdrv	: logical drive number
+ * @numsge	: number of scatter gather elements in sg list
+ * @resvd	: reserved
+ * @busy	: f/w busy, must wait to issue more commands.
+ * @numstatus	: number of commands completed.
+ * @status	: status of the commands completed
+ * @completed	: array of completed command ids.
+ * @poll	: poll and ack sequence
+ * @ack		: poll and ack sequence
+ *
+ * The central handshake structure between the driver and the firmware. This
+ * structure must be allocated by the driver and aligned at 8-byte boundary.
+ */
+#define MBOX_MAX_FIRMWARE_STATUS	46
+typedef struct {
+	uint8_t			cmd;
+	uint8_t			cmdid;
+	uint16_t		numsectors;
+	uint32_t		lba;
+	uint32_t		xferaddr;
+	uint8_t			logdrv;
+	uint8_t			numsge;
+	uint8_t			resvd;
+	volatile uint8_t	busy;
+	volatile uint8_t	numstatus;
+	volatile uint8_t	status;
+	volatile uint8_t	completed[MBOX_MAX_FIRMWARE_STATUS];
+	volatile uint8_t	poll;
+	volatile uint8_t	ack;
+} __attribute__ ((packed)) mbox_t;
+
+
+/**
+ * mbox64_t - 64-bit extension for the mailbox
+ * @segment_lo	: the low 32-bits of the address of the scatter-gather list
+ * @segment_hi	: the upper 32-bits of the address of the scatter-gather list
+ * @mbox	: 32-bit mailbox, whose xferadder field must be set to
+ *		0xFFFFFFFF
+ *
+ * This is the extension of the 32-bit mailbox to be able to perform DMA
+ * beyond 4GB address range.
+ */
+typedef struct {
+	uint32_t	xferaddr_lo;
+	uint32_t	xferaddr_hi;
+	mbox_t		mbox32;
+} __attribute__ ((packed)) mbox64_t;
+
+/*
+ * mailbox structure used for internal commands
+ */
+typedef struct {
+	u8	cmd;
+	u8	cmdid;
+	u8	opcode;
+	u8	subopcode;
+	u32	lba;
+	u32	xferaddr;
+	u8	logdrv;
+	u8	rsvd[3];
+	u8	numstatus;
+	u8	status;
+} __attribute__ ((packed)) int_mbox_t;
+
+/**
+ * mraid_passthru_t - passthru structure to issue commands to physical devices
+ * @timeout		: command timeout, 0=6sec, 1=60sec, 2=10min, 3=3hr
+ * @ars			: set if ARS required after check condition
+ * @islogical		: set if command meant for logical devices
+ * @logdrv		: logical drive number if command for LD
+ * @channel		: Channel on which physical device is located
+ * @target		: SCSI target of the device
+ * @queuetag		: unused
+ * @queueaction		: unused
+ * @cdb			: SCSI CDB
+ * @cdblen		: length of the CDB
+ * @reqsenselen		: amount of request sense data to be returned
+ * @reqsensearea	: Sense information buffer
+ * @numsge		: number of scatter-gather elements in the sg list
+ * @scsistatus		: SCSI status of the command completed.
+ * @dataxferaddr	: DMA data transfer address
+ * @dataxferlen		: amount of the data to be transferred.
+ */
+typedef struct {
+	uint8_t		timeout		:3;
+	uint8_t		ars		:1;
+	uint8_t		reserved	:3;
+	uint8_t		islogical	:1;
+	uint8_t		logdrv;
+	uint8_t		channel;
+	uint8_t		target;
+	uint8_t		queuetag;
+	uint8_t		queueaction;
+	uint8_t		cdb[MAX_CDB_LEN];
+	uint8_t		cdblen;
+	uint8_t		reqsenselen;
+	uint8_t		reqsensearea[MAX_REQ_SENSE_LEN];
+	uint8_t		numsge;
+	uint8_t		scsistatus;
+	uint32_t	dataxferaddr;
+	uint32_t	dataxferlen;
+} __attribute__ ((packed)) mraid_passthru_t;
+
+typedef struct {
+
+	uint32_t		dataxferaddr_lo;
+	uint32_t		dataxferaddr_hi;
+	mraid_passthru_t	pthru32;
+
+} __attribute__ ((packed)) mega_passthru64_t;
+
+/**
+ * mraid_epassthru_t - passthru structure to issue commands to physical devices
+ * @timeout		: command timeout, 0=6sec, 1=60sec, 2=10min, 3=3hr
+ * @ars			: set if ARS required after check condition
+ * @rsvd1		: reserved field
+ * @cd_rom		: (?)
+ * @rsvd2		: reserved field
+ * @islogical		: set if command meant for logical devices
+ * @logdrv		: logical drive number if command for LD
+ * @channel		: Channel on which physical device is located
+ * @target		: SCSI target of the device
+ * @queuetag		: unused
+ * @queueaction		: unused
+ * @cdblen		: length of the CDB
+ * @rsvd3		: reserved field
+ * @cdb			: SCSI CDB
+ * @numsge		: number of scatter-gather elements in the sg list
+ * @status		: SCSI status of the command completed.
+ * @reqsenselen		: amount of request sense data to be returned
+ * @reqsensearea	: Sense information buffer
+ * @rsvd4		: reserved field
+ * @dataxferaddr	: DMA data transfer address
+ * @dataxferlen		: amount of the data to be transferred.
+ */
+typedef struct {
+	uint8_t		timeout		:3;
+	uint8_t		ars		:1;
+	uint8_t		rsvd1		:1;
+	uint8_t		cd_rom		:1;
+	uint8_t		rsvd2		:1;
+	uint8_t		islogical	:1;
+	uint8_t		logdrv;
+	uint8_t		channel;
+	uint8_t		target;
+	uint8_t		queuetag;
+	uint8_t		queueaction;
+	uint8_t		cdblen;
+	uint8_t		rsvd3;
+	uint8_t		cdb[MAX_EXT_CDB_LEN];
+	uint8_t		numsge;
+	uint8_t		status;
+	uint8_t		reqsenselen;
+	uint8_t		reqsensearea[MAX_REQ_SENSE_LEN];
+	uint8_t		rsvd4;
+	uint32_t	dataxferaddr;
+	uint32_t	dataxferlen;
+} __attribute__ ((packed)) mraid_epassthru_t;
+
+
+/**
+ * mraid_pinfo_t - product info, static information about the controller
+ * @data_size		: current size in bytes (not including resvd)
+ * @config_signature	: Current value is 0x00282008
+ * @fw_version		: Firmware version
+ * @bios_version	: version of the BIOS
+ * @product_name	: Name given to the controller
+ * @max_commands	: Maximum concurrent commands supported
+ * @nchannels		: Number of SCSI Channels detected
+ * @fc_loop_present	: Number of Fibre Loops detected
+ * @mem_type		: EDO, FPM, SDRAM etc
+ * @signature		:
+ * @dram_size		: In terms of MB
+ * @subsysid		: device PCI subsystem ID
+ * @subsysvid		: device PCI subsystem vendor ID
+ * @notify_counters	:
+ * @pad1k		: 135 + 889 resvd = 1024 total size
+ *
+ * This structures holds the information about the controller which is not
+ * expected to change dynamically.
+ *
+ * The current value of config signature is 0x00282008:
+ * 0x28 = MAX_LOGICAL_DRIVES,
+ * 0x20 = Number of stripes and
+ * 0x08 = Number of spans
+ */
+typedef struct {
+	uint32_t	data_size;
+	uint32_t	config_signature;
+	uint8_t		fw_version[16];
+	uint8_t		bios_version[16];
+	uint8_t		product_name[80];
+	uint8_t		max_commands;
+	uint8_t		nchannels;
+	uint8_t		fc_loop_present;
+	uint8_t		mem_type;
+	uint32_t	signature;
+	uint16_t	dram_size;
+	uint16_t	subsysid;
+	uint16_t	subsysvid;
+	uint8_t		notify_counters;
+	uint8_t		pad1k[889];
+} __attribute__ ((packed)) mraid_pinfo_t;
+
+
+/**
+ * mraid_notify_t - the notification structure
+ * @global_counter		: Any change increments this counter
+ * @param_counter		: Indicates any params changed
+ * @param_id			: Param modified - defined below
+ * @param_val			: New val of last param modified
+ * @write_config_counter	: write config occurred
+ * @write_config_rsvd		:
+ * @ldrv_op_counter		: Indicates ldrv op started/completed
+ * @ldrv_opid			: ldrv num
+ * @ldrv_opcmd			: ldrv operation - defined below
+ * @ldrv_opstatus		: status of the operation
+ * @ldrv_state_counter		: Indicates change of ldrv state
+ * @ldrv_state_id		: ldrv num
+ * @ldrv_state_new		: New state
+ * @ldrv_state_old		: old state
+ * @pdrv_state_counter		: Indicates change of ldrv state
+ * @pdrv_state_id		: pdrv id
+ * @pdrv_state_new		: New state
+ * @pdrv_state_old		: old state
+ * @pdrv_fmt_counter		: Indicates pdrv format started/over
+ * @pdrv_fmt_id			: pdrv id
+ * @pdrv_fmt_val		: format started/over
+ * @pdrv_fmt_rsvd		:
+ * @targ_xfer_counter		: Indicates SCSI-2 Xfer rate change
+ * @targ_xfer_id		: pdrv Id
+ * @targ_xfer_val		: new Xfer params of last pdrv
+ * @targ_xfer_rsvd		:
+ * @fcloop_id_chg_counter	: Indicates loopid changed
+ * @fcloopid_pdrvid		: pdrv id
+ * @fcloop_id0			: loopid on fc loop 0
+ * @fcloop_id1			: loopid on fc loop 1
+ * @fcloop_state_counter	: Indicates loop state changed
+ * @fcloop_state0		: state of fc loop 0
+ * @fcloop_state1		: state of fc loop 1
+ * @fcloop_state_rsvd		:
+ */
+typedef struct {
+	uint32_t	global_counter;
+	uint8_t		param_counter;
+	uint8_t		param_id;
+	uint16_t	param_val;
+	uint8_t		write_config_counter;
+	uint8_t		write_config_rsvd[3];
+	uint8_t		ldrv_op_counter;
+	uint8_t		ldrv_opid;
+	uint8_t		ldrv_opcmd;
+	uint8_t		ldrv_opstatus;
+	uint8_t		ldrv_state_counter;
+	uint8_t		ldrv_state_id;
+	uint8_t		ldrv_state_new;
+	uint8_t		ldrv_state_old;
+	uint8_t		pdrv_state_counter;
+	uint8_t		pdrv_state_id;
+	uint8_t		pdrv_state_new;
+	uint8_t		pdrv_state_old;
+	uint8_t		pdrv_fmt_counter;
+	uint8_t		pdrv_fmt_id;
+	uint8_t		pdrv_fmt_val;
+	uint8_t		pdrv_fmt_rsvd;
+	uint8_t		targ_xfer_counter;
+	uint8_t		targ_xfer_id;
+	uint8_t		targ_xfer_val;
+	uint8_t		targ_xfer_rsvd;
+	uint8_t		fcloop_id_chg_counter;
+	uint8_t		fcloopid_pdrvid;
+	uint8_t		fcloop_id0;
+	uint8_t		fcloop_id1;
+	uint8_t		fcloop_state_counter;
+	uint8_t		fcloop_state0;
+	uint8_t		fcloop_state1;
+	uint8_t		fcloop_state_rsvd;
+} __attribute__ ((packed)) mraid_notify_t;
+
+
+/**
+ * mraid_inquiry3_t - enquiry for device information
+ *
+ * @data_size		: current size in bytes (not including resvd)
+ * @notify		:
+ * @notify_rsvd		:
+ * @rebuild_rate	: rebuild rate (0% - 100%)
+ * @cache_flush_int	: cache flush interval in seconds
+ * @sense_alert		:
+ * @drive_insert_count	: drive insertion count
+ * @battery_status	:
+ * @num_ldrv		: no. of Log Drives configured
+ * @recon_state		: state of reconstruct
+ * @ldrv_op_status	: logdrv Status
+ * @ldrv_size		: size of each log drv
+ * @ldrv_prop		:
+ * @ldrv_state		: state of log drives
+ * @pdrv_state		: state of phys drvs.
+ * @pdrv_format		:
+ * @targ_xfer		: phys device transfer rate
+ * @pad1k		: 761 + 263reserved = 1024 bytes total size
+ */
+#define MAX_NOTIFY_SIZE		0x80
+#define CUR_NOTIFY_SIZE		sizeof(mraid_notify_t)
+
+typedef struct {
+	uint32_t	data_size;
+
+	mraid_notify_t	notify;
+
+	uint8_t		notify_rsvd[MAX_NOTIFY_SIZE - CUR_NOTIFY_SIZE];
+
+	uint8_t		rebuild_rate;
+	uint8_t		cache_flush_int;
+	uint8_t		sense_alert;
+	uint8_t		drive_insert_count;
+
+	uint8_t		battery_status;
+	uint8_t		num_ldrv;
+	uint8_t		recon_state[MAX_LOGICAL_DRIVES_40LD / 8];
+	uint16_t	ldrv_op_status[MAX_LOGICAL_DRIVES_40LD / 8];
+
+	uint32_t	ldrv_size[MAX_LOGICAL_DRIVES_40LD];
+	uint8_t		ldrv_prop[MAX_LOGICAL_DRIVES_40LD];
+	uint8_t		ldrv_state[MAX_LOGICAL_DRIVES_40LD];
+	uint8_t		pdrv_state[FC_MAX_PHYSICAL_DEVICES];
+	uint16_t	pdrv_format[FC_MAX_PHYSICAL_DEVICES / 16];
+
+	uint8_t		targ_xfer[80];
+	uint8_t		pad1k[263];
+} __attribute__ ((packed)) mraid_inquiry3_t;
+
+
+/**
+ * mraid_adapinfo_t - information about the adapter
+ * @max_commands		: max concurrent commands supported
+ * @rebuild_rate		: rebuild rate - 0% thru 100%
+ * @max_targ_per_chan		: max targ per channel
+ * @nchannels			: number of channels on HBA
+ * @fw_version			: firmware version
+ * @age_of_flash		: number of times FW has been flashed
+ * @chip_set_value		: contents of 0xC0000832
+ * @dram_size			: in MB
+ * @cache_flush_interval	: in seconds
+ * @bios_version		:
+ * @board_type			:
+ * @sense_alert			:
+ * @write_config_count		: increase with every configuration change
+ * @drive_inserted_count	: increase with every drive inserted
+ * @inserted_drive		: channel:Id of inserted drive
+ * @battery_status		: bit 0: battery module missing
+ *				bit 1: VBAD
+ *				bit 2: temprature high
+ *				bit 3: battery pack missing
+ *				bit 4,5:
+ *					00 - charge complete
+ *					01 - fast charge in progress
+ *					10 - fast charge fail
+ *					11 - undefined
+ *				bit 6: counter > 1000
+ *				bit 7: Undefined
+ * @dec_fault_bus_info		:
+ */
+typedef struct {
+	uint8_t		max_commands;
+	uint8_t		rebuild_rate;
+	uint8_t		max_targ_per_chan;
+	uint8_t		nchannels;
+	uint8_t		fw_version[4];
+	uint16_t	age_of_flash;
+	uint8_t		chip_set_value;
+	uint8_t		dram_size;
+	uint8_t		cache_flush_interval;
+	uint8_t		bios_version[4];
+	uint8_t		board_type;
+	uint8_t		sense_alert;
+	uint8_t		write_config_count;
+	uint8_t		battery_status;
+	uint8_t		dec_fault_bus_info;
+} __attribute__ ((packed)) mraid_adapinfo_t;
+
+
+/**
+ * mraid_ldrv_info_t - information about the logical drives
+ * @nldrv	: Number of logical drives configured
+ * @rsvd	:
+ * @size	: size of each logical drive
+ * @prop	:
+ * @state	: state of each logical drive
+ */
+typedef struct {
+	uint8_t		nldrv;
+	uint8_t		rsvd[3];
+	uint32_t	size[MAX_LOGICAL_DRIVES_8LD];
+	uint8_t		prop[MAX_LOGICAL_DRIVES_8LD];
+	uint8_t		state[MAX_LOGICAL_DRIVES_8LD];
+} __attribute__ ((packed)) mraid_ldrv_info_t;
+
+
+/**
+ * mraid_pdrv_info_t - information about the physical drives
+ * @pdrv_state	: state of each physical drive
+ */
+typedef struct {
+	uint8_t		pdrv_state[MBOX_MAX_PHYSICAL_DRIVES];
+	uint8_t		rsvd;
+} __attribute__ ((packed)) mraid_pdrv_info_t;
+
+
+/**
+ * mraid_inquiry_t - RAID inquiry, mailbox command 0x05
+ * @mraid_adapinfo_t	: adapter information
+ * @mraid_ldrv_info_t	: logical drives information
+ * @mraid_pdrv_info_t	: physical drives information
+ */
+typedef struct {
+	mraid_adapinfo_t	adapter_info;
+	mraid_ldrv_info_t	logdrv_info;
+	mraid_pdrv_info_t	pdrv_info;
+} __attribute__ ((packed)) mraid_inquiry_t;
+
+
+/**
+ * mraid_extinq_t - RAID extended inquiry, mailbox command 0x04
+ *
+ * @raid_inq		: raid inquiry
+ * @phys_drv_format	:
+ * @stack_attn		:
+ * @modem_status	:
+ * @rsvd		:
+ */
+typedef struct {
+	mraid_inquiry_t	raid_inq;
+	uint16_t	phys_drv_format[MAX_MBOX_CHANNELS];
+	uint8_t		stack_attn;
+	uint8_t		modem_status;
+	uint8_t		rsvd[2];
+} __attribute__ ((packed)) mraid_extinq_t;
+
+
+/**
+ * adap_device_t - device information
+ * @channel	: channel fpor the device
+ * @target	: target ID of the device
+ */
+typedef struct {
+	uint8_t		channel;
+	uint8_t		target;
+}__attribute__ ((packed)) adap_device_t;
+
+
+/**
+ * adap_span_40ld_t - 40LD span
+ * @start_blk	: starting block
+ * @num_blks	: number of blocks
+ */
+typedef struct {
+	uint32_t	start_blk;
+	uint32_t	num_blks;
+	adap_device_t	device[MAX_ROW_SIZE_40LD];
+}__attribute__ ((packed)) adap_span_40ld_t;
+
+
+/**
+ * adap_span_8ld_t - 8LD span
+ * @start_blk	: starting block
+ * @num_blks	: number of blocks
+ */
+typedef struct {
+	uint32_t	start_blk;
+	uint32_t	num_blks;
+	adap_device_t	device[MAX_ROW_SIZE_8LD];
+}__attribute__ ((packed)) adap_span_8ld_t;
+
+
+/**
+ * logdrv_param_t - logical drives parameters
+ *
+ * @span_depth	: total number of spans
+ * @level	: RAID level
+ * @read_ahead	: read ahead, no read ahead, adaptive read ahead
+ * @stripe_sz	: encoded stripe size
+ * @status	: status of the logical drive
+ * @write_mode	: write mode, write_through/write_back
+ * @direct_io	: direct io or through cache
+ * @row_size	: number of stripes in a row
+ */
+typedef struct {
+	uint8_t		span_depth;
+	uint8_t		level;
+	uint8_t		read_ahead;
+	uint8_t		stripe_sz;
+	uint8_t		status;
+	uint8_t		write_mode;
+	uint8_t		direct_io;
+	uint8_t		row_size;
+} __attribute__ ((packed)) logdrv_param_t;
+
+
+/**
+ * logdrv_40ld_t - logical drive definition for 40LD controllers
+ * @lparam	: logical drives parameters
+ * @span	: span
+ */
+typedef struct {
+	logdrv_param_t		lparam;
+	adap_span_40ld_t	span[SPAN_DEPTH_8_SPANS];
+}__attribute__ ((packed)) logdrv_40ld_t;
+
+
+/**
+ * logdrv_8ld_span8_t - logical drive definition for 8LD controllers
+ * @lparam	: logical drives parameters
+ * @span	: span
+ *
+ * 8-LD logical drive with upto 8 spans
+ */
+typedef struct {
+	logdrv_param_t	lparam;
+	adap_span_8ld_t	span[SPAN_DEPTH_8_SPANS];
+}__attribute__ ((packed)) logdrv_8ld_span8_t;
+
+
+/**
+ * logdrv_8ld_span4_t - logical drive definition for 8LD controllers
+ * @lparam	: logical drives parameters
+ * @span	: span
+ *
+ * 8-LD logical drive with upto 4 spans
+ */
+typedef struct {
+	logdrv_param_t	lparam;
+	adap_span_8ld_t	span[SPAN_DEPTH_4_SPANS];
+}__attribute__ ((packed)) logdrv_8ld_span4_t;
+
+
+/**
+ * phys_drive_t - physical device information
+ * @type	: Type of the device
+ * @cur_status	: current status of the device
+ * @tag_depth	: Level of tagging
+ * @sync_neg	: sync negotiation - ENABLE or DISBALE
+ * @size	: configurable size in terms of 512 byte
+ */
+typedef struct {
+	uint8_t		type;
+	uint8_t		cur_status;
+	uint8_t		tag_depth;
+	uint8_t		sync_neg;
+	uint32_t	size;
+}__attribute__ ((packed)) phys_drive_t;
+
+
+/**
+ * disk_array_40ld_t - disk array for 40LD controllers
+ * @numldrv	: number of logical drives
+ * @resvd	:
+ * @ldrv	: logical drives information
+ * @pdrv	: physical drives information
+ */
+typedef struct {
+	uint8_t		numldrv;
+	uint8_t		resvd[3];
+	logdrv_40ld_t	ldrv[MAX_LOGICAL_DRIVES_40LD];
+	phys_drive_t	pdrv[MBOX_MAX_PHYSICAL_DRIVES];
+}__attribute__ ((packed)) disk_array_40ld_t;
+
+
+/**
+ * disk_array_8ld_span8_t - disk array for 8LD controllers
+ * @numldrv	: number of logical drives
+ * @resvd	:
+ * @ldrv	: logical drives information
+ * @pdrv	: physical drives information
+ *
+ * Disk array for 8LD logical drives with upto 8 spans
+ */
+typedef struct {
+	uint8_t			numldrv;
+	uint8_t			resvd[3];
+	logdrv_8ld_span8_t	ldrv[MAX_LOGICAL_DRIVES_8LD];
+	phys_drive_t		pdrv[MBOX_MAX_PHYSICAL_DRIVES];
+}__attribute__ ((packed)) disk_array_8ld_span8_t;
+
+
+/**
+ * disk_array_8ld_span4_t - disk array for 8LD controllers
+ * @numldrv	: number of logical drives
+ * @resvd	:
+ * @ldrv	: logical drives information
+ * @pdrv	: physical drives information
+ *
+ * Disk array for 8LD logical drives with upto 4 spans
+ */
+typedef struct {
+	uint8_t			numldrv;
+	uint8_t			resvd[3];
+	logdrv_8ld_span4_t	ldrv[MAX_LOGICAL_DRIVES_8LD];
+	phys_drive_t		pdrv[MBOX_MAX_PHYSICAL_DRIVES];
+}__attribute__ ((packed)) disk_array_8ld_span4_t;
+
+
+/**
+ * private_bios_data - bios private data for boot devices
+ * @geometry	: bits 0-3 - BIOS geometry, 0x0001 - 1GB, 0x0010 - 2GB,
+ *		0x1000 - 8GB, Others values are invalid
+ * @unused	: bits 4-7 are unused
+ * @boot_drv	: logical drive set as boot drive, 0..7 - for 8LD cards,
+ * 		0..39 - for 40LD cards
+ * @cksum	: 0-(sum of first 13 bytes of this structure)
+ */
+struct private_bios_data {
+	uint8_t		geometry	:4;
+	uint8_t		unused		:4;
+	uint8_t		boot_drv;
+	uint8_t		rsvd[12];
+	uint16_t	cksum;
+} __attribute__ ((packed));
+
+
+/**
+ * mbox_sgl64 - 64-bit scatter list for mailbox based controllers
+ * @address	: address of the buffer
+ * @length	: data transfer length
+ */
+typedef struct {
+	uint64_t	address;
+	uint32_t	length;
+} __attribute__ ((packed)) mbox_sgl64;
+
+/**
+ * mbox_sgl32 - 32-bit scatter list for mailbox based controllers
+ * @address	: address of the buffer
+ * @length	: data transfer length
+ */
+typedef struct {
+	uint32_t	address;
+	uint32_t	length;
+} __attribute__ ((packed)) mbox_sgl32;
+
+#endif		/* _MRAID_UNIFIED_MBOX_DEFS_H_ */
+
+/* vim: set ts=8 sw=8 tw=78: */
diff -urNp linux-2.6.5/drivers/scsi/mega_common.h linux-2.6.5.SUSE/drivers/scsi/mega_common.h
--- linux-2.6.5/drivers/scsi/mega_common.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/mega_common.h	2004-04-27 18:45:56.000000000 +0200
@@ -0,0 +1,416 @@
+/*
+ *
+ *			Linux MegaRAID device driver
+ *
+ * Copyright (c) 2003-2004  LSI Logic Corporation.
+ *
+ *	   This program is free software; you can redistribute it and/or
+ *	   modify it under the terms of the GNU General Public License
+ *	   as published by the Free Software Foundation; either version
+ *	   2 of the License, or (at your option) any later version.
+ *
+ * FILE		: mega_common.h
+ * Version	: v2.20.0 (Apr 14 2004)
+ *
+ * Libaray of common routine used by all megaraid drivers.
+ */
+
+#ifndef _MEGA_COMMON_H_
+#define _MEGA_COMMON_H_
+
+#include "lsi_defs.h"
+
+#define PCI_DIR(scp)		scsi_to_pci_dma_dir(scp->sc_data_direction)
+
+#define VENDOR_SPECIFIC_COMMAND	0xE0
+
+/*
+ * lockscope definitions, callers can specify the lock scope with this data
+ * type. LOCK_INT would mean the caller has not acquired the lock before
+ * making the call and LOCK_EXT would mean otherwise.
+ */
+typedef enum { LOCK_INT, LOCK_EXT } lockscope_t;
+
+/**
+ * scb_t - scsi command control block
+ * @param ccb		: command control block for individual driver
+ * @param list		: list of control blocks
+ * @param gp		: general purpose field for LLDs
+ * @param sno		: all SCBs have a serial number
+ * @param scp		: associated scsi command
+ * @param state		: current state of scb
+ * @param dma_dir	: direction of data transfer
+ * @param dma_type	: transfer with sg list, buffer, or no data transfer
+ * @param dev_channel	: actual channel on the device
+ * @param dev_target	: actual target on the device
+ * @param status	: completion status
+ * @param entry_time	: command entry time
+ * @param exit_time	: command exit time
+ *
+ * This is our central data structure to issue commands the each driver.
+ * Driver specific data structures are maintained in the ccb field.
+ * scb provides a field 'gp', which can be used by LLD for its own purposes
+ *
+ * dev_channel and dev_target must be initialized with the actual channel and
+ * target on the controller.
+ */
+typedef struct {
+	caddr_t			ccb;
+	struct list_head	list;
+	unsigned long		gp;	
+	unsigned int		sno;
+	Scsi_Cmnd		*scp;
+	uint32_t		state;
+	uint32_t		dma_direction;
+	uint32_t		dma_type;
+	uint16_t		dev_channel;
+	uint16_t		dev_target;
+	uint32_t		status;
+	unsigned long		entry_time;
+	unsigned long		exit_time;
+} scb_t;
+
+/*
+ * SCB states as it transitions from one state to another
+ */
+#define SCB_FREE	0x0000	/* on the free list */
+#define SCB_ACTIVE	0x0001	/* off the free list */
+#define SCB_PENDQ	0x0002	/* on the pending queue */
+#define SCB_ISSUED	0x0004	/* issued - owner f/w */
+#define SCB_ABORT	0x0008	/* Got an abort for this one */
+#define SCB_RESET	0x0010	/* Got a reset for this one */
+
+/*
+ * DMA types for scb
+ */
+#define MRAID_DMA_NONE	0x0000	/* no data transfer for this command */
+#define MRAID_DMA_WSG	0x0001	/* data transfer using a sg list */
+#define MRAID_DMA_WBUF	0x0002	/* data transfer using a contiguous buffer */
+
+
+/**
+ * struct adapter_t - driver's initialization structure
+ * @param list			: list of megaraid host structures
+ * @param dpc_h			: tasklet handle
+ * @param slot			: slot number in global array of adapters
+ * @param id			: PCI device identifier
+ * @param host			: pointer to host structure of mid-layer
+ * @param init_id		: initiator ID, the default value should be 7
+ * @param boot_enabled		: set if this device is boot capable
+ * @param bd_channel		: the physical channel number with boot device
+ * @param bd_target		: the target of the boot device
+ * @param virtual_ch		: the channel number to export logical drives on
+ * @param max_channel		: maximum channel number supported - inclusive
+ * @param max_target		: max target supported - inclusive
+ * @param max_lun		: max lun supported - inclusive
+ * @param device_ids		: to convert kernel device addr to our devices.
+ * @param max_cdb_sz		: biggest CDB size supported.
+ * @param max_cmds		: max outstanding commands
+ * @param ha			: is high availability present - clustering
+ * @param sglen			: max sg elements supported
+ * @param max_sectors		: max sectors per request
+ * @param cmd_per_lun		: max outstanding commands per LUN
+ * @param highmem_dma		: can DMA beyond 4GB addresses. See also, NOTES.
+ * @param fw_version		: firmware version
+ * @param bios_version		: bios version
+ * @param ibuf			: buffer to issue internal commands
+ * @param ibuf_dma_h		: dma handle for the above buffer
+ * @param flags			: controller specific flags
+ * @param unique_id		: unique identifier for each adapter
+ * @param irq			: IRQ for this adapter
+ * @param mdevice		: each contoller's device data
+ * @param pdev			: pci configuration pointer for kernel
+ * @param lock			: synchronization lock for mid-layer and driver
+ * @param host_lock		: pointer to appropriate lock
+ * @param scb_list		: pointer to the bulk of SCBs memory area
+ * @param scb_pool		: pool of free scbs.
+ * @param pend_list		: pending commands list
+ * @param completed_list	: list of completed commands
+ * @param quiescent		: driver is quiescent for now.
+ * @param outstanding_cmds	: number of commands pending in the driver
+ * @param iscb			: control block for command issued internally
+ * @param isc			: associated SCSI command for generality
+ * @param imtx			: allow only one internal pending command
+ * @param iwq			: wait queue for synchronous internal commands
+ * @param ito			: internal timeout value, (-1) means no timeout
+ * @param icmd_recovery		: internal command path timed out
+ * @param stats			: IO stastics about the controller
+ * @param raid_device		: raid adapter specific pointer
+ *
+ * The fields init_id, boot_enabled, bd_channel, bd_target, virtual_ch,
+ * max_channel, max_target, max_lun, and device_ids are part of a subsytem
+ * called the device map.
+ * If LLDs want to have a flexbile booting order for their devices (boot from
+ * any logical or physical device) - they should make use of the framework
+ * APIs mraid_setup_device_map(adapter_t *) and
+ * MRAID_GET_DEVICE_MAP(adp, scp, channel, target, islogical).
+ *
+ * mraid_setup_device_map() can be called anytime after the device map is
+ * available and MRAID_GET_DEVICE_MAP() can be called whenever the mapping is
+ * required, usually from LLD's queue entry point. The formar API sets up the
+ * fields 'device_ids' with appropriate value. Make sure before calling this
+ * routine - all fields in device map are filled in otherwise unexpected
+ * behavior will result. The later uses this information to return information
+ * about the device in question. LLDs can use the macro
+ * MRAID_IS_LOGICAL(adapter_t *, struct scsi_cmnd *) to find out if the
+ * device in question is a logical drive.
+ *
+ * quiescent flag should be set by the driver if it is not accepting more
+ * commands
+ *
+ * If any internal command is timed out, icmd flag_recovery should be set and
+ * further internal commands will return error until the command is actually
+ * completed if ever.
+ *
+ * NOTES:
+ * i.	the highmem_dma flag denotes whether we are registering ourselves as a
+ * 64-bit capable driver or not. If a HBA supports 64-bit addressing, that
+ * alone is not a sufficient condition for registering as 64-bit driver. The
+ * kernel should also provide support for such arrangement. To denote if the
+ * HBA supports 64-bit addressing, the flag DMA_64 is set in adapter_t
+ * object.
+ */
+
+/*
+ * amount of space required to store the bios and firmware version strings
+ */
+#define VERSION_SIZE	16
+
+
+/*
+ * Valid values for flags field of adapter_t structure.
+ */
+#define MRAID_DMA_64		0x00000001	/* can dma in 64-bit address
+						range */
+#define MRAID_BOARD_MEMMAP	0x00000002	/* Is a memory-mapped
+						controller */
+#define MRAID_BOARD_IOMAP	0x00000004	/* Is a IO-mapped controller */
+
+
+typedef struct {
+	struct list_head		list;
+	struct tasklet_struct		dpc_h;
+	int				slot;
+
+	const struct pci_device_id	*pci_id;
+	struct pci_dev			*pdev;
+	uint32_t			unique_id;
+	uint8_t				irq;
+	bool_t				highmem_dma;
+
+	spinlock_t			*host_lock;
+	spinlock_t			lock;
+	scb_t				iscb;
+	Scsi_Cmnd			isc;
+	struct scsi_device		isdev;
+	struct semaphore		imtx;
+#define MRAID_STATE_SLEEP		0
+#define MRAID_WAKEUP_NORM		1
+#define MRAID_WAKEUP_TIMEOUT		2
+#define MRAID_INTERNAL_COMMAND		VENDOR_SPECIFIC_COMMAND
+	wait_queue_head_t		iwq;
+
+	bool_t				quiescent;
+	int				outstanding_cmds;
+	uint8_t				ito;
+	uint8_t				icmd_recovery;
+	caddr_t				ibuf;
+	dma_addr_t			ibuf_dma_h;
+
+	scb_t				*scb_list;
+	struct list_head		scb_pool;
+	struct list_head		pend_list;
+	struct list_head		completed_list;
+
+	uint8_t				max_channel;
+	uint16_t			max_target;
+	uint8_t				max_lun;
+	int				max_cmds;
+	uint8_t				fw_version[VERSION_SIZE];
+	uint8_t				bios_version[VERSION_SIZE];
+	uint8_t				max_cdb_sz;
+	bool_t				ha;
+	uint16_t			init_id;
+
+	bool_t				boot_enabled;
+	uint8_t				bd_channel;
+	uint16_t			bd_target;
+	uint8_t				virtual_ch;
+	int	device_ids[LSI_MAX_CHANNELS][LSI_MAX_LOGICAL_DRIVES_64LD];
+
+	struct Scsi_Host		*host;
+
+	uint16_t			sglen;
+	uint16_t			max_sectors;
+	uint16_t			cmd_per_lun;
+	uint32_t			flags;
+
+#ifdef MRAID_HAVE_STATS
+	mraid_stats_t			stats;
+#endif
+	caddr_t				raid_device;
+
+	atomic_t			being_detached;
+
+} adapter_t;
+
+
+/**
+ * MRAID_GET_DEVICE_MAP - device ids
+ * @param adp		- Adapter's soft state
+ * @param scp		- mid-layer scsi command pointer
+ * @param p_chan	- physical channel on the controller
+ * @param target	- target id of the device or logical drive number
+ * @param islogical	- set if the command is for the logical drive
+ *
+ * Macro to retrieve information about device class, logical or physical and
+ * the corresponding physical channel and target or logical drive number
+ **/
+#define MRAID_GET_DEVICE_MAP(adp, scp, p_chan, target, islogical)	\
+	/*								\
+	 * Is the request coming for the virtual channel		\
+	 */								\
+	islogical = (SCP2CHANNEL(scp) == (adp)->virtual_ch) ? 1 : 0;	\
+									\
+	/*								\
+	 * Get an index into our table of drive ids mapping		\
+	 */								\
+	if (islogical) {						\
+		p_chan = 0xFF;						\
+		target =						\
+		(adp)->device_ids[(adp)->virtual_ch][SCP2TARGET(scp)];	\
+	}								\
+	else {								\
+		p_chan = ((adp)->device_ids[SCP2CHANNEL(scp)][SCP2TARGET(scp)] >> 8) & 0xFF;	\
+		target = ((adp)->device_ids[SCP2CHANNEL(scp)][SCP2TARGET(scp)] & 0xFF);	\
+	}
+
+#define MRAID_IS_LOGICAL(adp, scp)	\
+	(SCP2CHANNEL(scp) == (adp)->virtual_ch) ? MRAID_TRUE : MRAID_FALSE;
+
+/**
+ * struct mraid_driver_t - global driver data
+ * @param is_pvt_intf		: Is intrface available for private interfaces
+ * @param driver_version	: driver version
+ * @param device_list		: list of adapter_t structures
+ * @param attach_count		: number of controllers detected by the driver
+ * @param raid_device		: array of attached raid controllers
+ *
+ * mraid_driver_t contains information which is global to the driver.
+ *
+ * FIXME: we provide two external interfaces in addition to the regular IO
+ * path, private ioctl and /proc. Care must be taken about using these two
+ * interfaces while module is being unloaded. For now, we provide a macro,
+ * IS_INTF_AVAILABLE(), which would return 1 if it is ok to use. In case of 0,
+ * the corresponding entry points in each LLD must return w/o further
+ * processing.
+ */
+#define MAX_CONTROLLERS		32
+typedef struct _mraid_driver_t {
+	atomic_t		is_pvt_intf;
+	uint8_t			driver_version[8];
+	struct list_head	device_list;
+	uint8_t			attach_count;
+	adapter_t		*adapter[MAX_CONTROLLERS];
+} mraid_driver_t;
+
+#define SET_PRV_INTF_AVAILABLE() atomic_set(&mraid_driver_g.is_pvt_intf, 1)
+#define SET_PRV_INTF_UNAVAILABLE() atomic_set(&mraid_driver_g.is_pvt_intf, 0)
+#define IS_PRV_INTF_AVAILABLE() atomic_read(&mraid_driver_g.is_pvt_intf) ? 1 : 0
+
+
+/*
+ * ### Helper routines ###
+ */
+extern int debug_level;
+#define LSI_DBGLVL debug_level
+
+/*
+ * Assertaion helpers. The driver must use the foursome macros:
+ * try_assertion {
+ * 	ASSERT(expression);
+ * }
+ * catch_assertion {
+ * 	// failed assetion steps
+ * }
+ * end_assertion
+ *
+ * Depending on compliation flag 'DEBUG' flag, the assert condition can panic
+ * the machine or just print the assertion failure message. In the later case,
+ * the driver will catch the failure in catch_assertion block and can take
+ * recovery action.
+ * NOTE: This is not a generic implementation since we only catch an integer
+ * true-false assertion failure unlike C++ fullblown try-catch-throw
+ * exceptions.
+ */
+#define try_assertion {			\
+	int	__assertion_catched = 0;
+#define catch_assertion if( __assertion_catched )
+#define	end_assertion				}
+
+#if defined (_ASSERT_PANIC)
+#define ASSERT_ACTION	panic
+#else
+#define ASSERT_ACTION	printk
+#endif
+
+#define ASSERT(expression)						\
+	if( !(expression) ) {						\
+		__assertion_catched = 1;				\
+	ASSERT_ACTION("assertion failed:(%s), file: %s, line: %d:%s\n",	\
+			#expression, __FILE__, __LINE__, __FUNCTION__);	\
+	}
+
+/*
+ * Library to allocate memory regions which are DMA'able
+ */
+/*
+ * struct mraid_pci_blk_pool - structure holds DMA memory pool info
+ * @param dev			: pci device that will be doing the DMA
+ * @param dmah_arr		: dma handle for allocated pages
+ * @param page_arr		: virtual addresses for all allocated pages
+ * @param page_count		: actual number of pages allocated
+ *
+ * Pool allocator, wraps the pci_alloc_consistent page allocator, so
+ * small blocks are easily used by drivers for bus mastering controllers.
+ *
+ * Limit number of pages to max MEMLIB_MAX_PAGES
+ */
+#define	MEMLIB_MAX_PAGES	64
+
+struct mraid_pci_blk_pool {
+	struct pci_dev	*dev;
+	dma_addr_t	dmah_arr[MEMLIB_MAX_PAGES];
+	caddr_t		page_arr[MEMLIB_MAX_PAGES];
+	int		page_count;
+};
+
+/*
+ * struct mraid_pci_blk - structure holds DMA memory block info
+ * @param vaddr		: virtual address to a memory block
+ * @param dma_addr	: DMA handle to a memory block
+ *
+ * This structure is filled up for the caller. It is the responsibilty of the
+ * caller to allocate this array big enough to store addresses for all
+ * requested elements
+ */
+struct mraid_pci_blk {
+	caddr_t		vaddr;
+	dma_addr_t	dma_addr;
+};
+
+void mraid_setup_device_map(adapter_t *);
+void mraid_icmd_done(struct scsi_cmnd *);
+void mraid_icmd_timeout(unsigned long);
+inline scb_t *mraid_get_icmd(adapter_t *);
+inline void mraid_free_icmd(adapter_t *);
+inline scb_t *mraid_alloc_scb(adapter_t *, struct scsi_cmnd *);
+inline void mraid_dealloc_scb(adapter_t *, scb_t *);
+void mraid_add_scb_to_pool(adapter_t *, scb_t *);
+struct mraid_pci_blk_pool *mraid_pci_blk_pool_create(struct pci_dev *,
+	size_t, size_t, size_t, struct mraid_pci_blk[]);
+void mraid_pci_blk_pool_destroy(struct mraid_pci_blk_pool *);
+
+#endif /* _MEGA_COMMON_H_ */
+
+/* vim: set ts=8 sw=8 tw=78: */
diff -urNp linux-2.6.5/drivers/scsi/megaraid.c linux-2.6.5.SUSE/drivers/scsi/megaraid.c
--- linux-2.6.5/drivers/scsi/megaraid.c	2004-04-04 05:36:12.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/megaraid.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,5137 +0,0 @@
-/*
- *
- *			Linux MegaRAID device driver
- *
- * Copyright  2002  LSI Logic Corporation.
- *
- *	   This program is free software; you can redistribute it and/or
- *	   modify it under the terms of the GNU General Public License
- *	   as published by the Free Software Foundation; either version
- *	   2 of the License, or (at your option) any later version.
- *
- * Copyright (c) 2002  Red Hat, Inc. All rights reserved.
- *	  - fixes
- *	  - speed-ups (list handling fixes, issued_list, optimizations.)
- *	  - lots of cleanups.
- *
- * Copyright (c) 2003  Christoph Hellwig  <hch@lst.de>
- *	  - new-style, hotplug-aware pci probing and scsi registration
- *
- * Version : v2.00.3 (Feb 19, 2003) - Atul Mukker <Atul.Mukker@lsil.com>
- *
- * Description: Linux device driver for LSI Logic MegaRAID controller
- *
- * Supported controllers: MegaRAID 418, 428, 438, 466, 762, 467, 471, 490, 493
- *					518, 520, 531, 532
- *
- * This driver is supported by LSI Logic, with assistance from Red Hat, Dell,
- * and others. Please send updates to the public mailing list
- * linux-megaraid-devel@dell.com, and subscribe to and read archives of this
- * list at http://lists.us.dell.com/.
- *
- * For history of changes, see ChangeLog.megaraid.
- *
- */
-
-#include <linux/mm.h>
-#include <linux/fs.h>
-#include <linux/blkdev.h>
-#include <asm/uaccess.h>
-#include <asm/io.h>
-#include <linux/delay.h>
-#include <linux/proc_fs.h>
-#include <linux/reboot.h>
-#include <linux/module.h>
-#include <linux/list.h>
-#include <linux/interrupt.h>
-#include <linux/pci.h>
-#include <linux/init.h>
-#include <scsi/scsicam.h>
-
-#include "scsi.h"
-#include "hosts.h"
-
-#include "megaraid.h"
-
-MODULE_AUTHOR ("LSI Logic Corporation");
-MODULE_DESCRIPTION ("LSI Logic MegaRAID driver");
-MODULE_LICENSE ("GPL");
-
-static unsigned int max_cmd_per_lun = DEF_CMD_PER_LUN;
-MODULE_PARM(max_cmd_per_lun, "i");
-MODULE_PARM_DESC(max_cmd_per_lun, "Maximum number of commands which can be issued to a single LUN (default=DEF_CMD_PER_LUN=63)");
-
-static unsigned short int max_sectors_per_io = MAX_SECTORS_PER_IO;
-MODULE_PARM(max_sectors_per_io, "h");
-MODULE_PARM_DESC(max_sectors_per_io, "Maximum number of sectors per I/O request (default=MAX_SECTORS_PER_IO=128)");
-
-
-static unsigned short int max_mbox_busy_wait = MBOX_BUSY_WAIT;
-MODULE_PARM(max_mbox_busy_wait, "h");
-MODULE_PARM_DESC(max_mbox_busy_wait, "Maximum wait for mailbox in microseconds if busy (default=MBOX_BUSY_WAIT=10)");
-
-#define RDINDOOR(adapter)		readl((adapter)->base + 0x20)
-#define RDOUTDOOR(adapter)		readl((adapter)->base + 0x2C)
-#define WRINDOOR(adapter,value)		writel(value, (adapter)->base + 0x20)
-#define WROUTDOOR(adapter,value)	writel(value, (adapter)->base + 0x2C)
-
-/*
- * Global variables
- */
-
-static int hba_count;
-static adapter_t *hba_soft_state[MAX_CONTROLLERS];
-static struct proc_dir_entry *mega_proc_dir_entry;
-
-/* For controller re-ordering */
-static struct mega_hbas mega_hbas[MAX_CONTROLLERS];
-
-/*
- * The File Operations structure for the serial/ioctl interface of the driver
- */
-static struct file_operations megadev_fops = {
-	.owner		= THIS_MODULE,
-	.ioctl		= megadev_ioctl,
-	.open		= megadev_open,
-};
-
-/*
- * Array to structures for storing the information about the controllers. This
- * information is sent to the user level applications, when they do an ioctl
- * for this information.
- */
-static struct mcontroller mcontroller[MAX_CONTROLLERS];
-
-/* The current driver version */
-static u32 driver_ver = 0x02000000;
-
-/* major number used by the device for character interface */
-static int major;
-
-#define IS_RAID_CH(hba, ch)	(((hba)->mega_ch_class >> (ch)) & 0x01)
-
-
-/*
- * Debug variable to print some diagnostic messages
- */
-static int trace_level;
-
-/**
- * mega_setup_mailbox()
- * @adapter - pointer to our soft state
- *
- * Allocates a 8 byte aligned memory for the handshake mailbox.
- */
-static int
-mega_setup_mailbox(adapter_t *adapter)
-{
-	unsigned long	align;
-
-	adapter->una_mbox64 = pci_alloc_consistent(adapter->dev,
-			sizeof(mbox64_t), &adapter->una_mbox64_dma);
-
-	if( !adapter->una_mbox64 ) return -1;
-		
-	adapter->mbox = &adapter->una_mbox64->mbox;
-
-	adapter->mbox = (mbox_t *)((((unsigned long) adapter->mbox) + 15) &
-			(~0UL ^ 0xFUL));
-
-	adapter->mbox64 = (mbox64_t *)(((unsigned long)adapter->mbox) - 8);
-
-	align = ((void *)adapter->mbox) - ((void *)&adapter->una_mbox64->mbox);
-
-	adapter->mbox_dma = adapter->una_mbox64_dma + 8 + align;
-
-	/*
-	 * Register the mailbox if the controller is an io-mapped controller
-	 */
-	if( adapter->flag & BOARD_IOMAP ) {
-
-		outb_p(adapter->mbox_dma & 0xFF,
-				adapter->host->io_port + MBOX_PORT0);
-
-		outb_p((adapter->mbox_dma >> 8) & 0xFF,
-				adapter->host->io_port + MBOX_PORT1);
-
-		outb_p((adapter->mbox_dma >> 16) & 0xFF,
-				adapter->host->io_port + MBOX_PORT2);
-
-		outb_p((adapter->mbox_dma >> 24) & 0xFF,
-				adapter->host->io_port + MBOX_PORT3);
-
-		outb_p(ENABLE_MBOX_BYTE,
-				adapter->host->io_port + ENABLE_MBOX_REGION);
-
-		irq_ack(adapter);
-
-		irq_enable(adapter);
-	}
-
-	return 0;
-}
-
-
-/*
- * mega_query_adapter()
- * @adapter - pointer to our soft state
- *
- * Issue the adapter inquiry commands to the controller and find out
- * information and parameter about the devices attached
- */
-static int
-mega_query_adapter(adapter_t *adapter)
-{
-	dma_addr_t	prod_info_dma_handle;
-	mega_inquiry3	*inquiry3;
-	u8	raw_mbox[sizeof(struct mbox_out)];
-	mbox_t	*mbox;
-	int	retval;
-
-	/* Initialize adapter inquiry mailbox */
-
-	mbox = (mbox_t *)raw_mbox;
-
-	memset((void *)adapter->mega_buffer, 0, MEGA_BUFFER_SIZE);
-	memset(&mbox->m_out, 0, sizeof(raw_mbox));
-
-	/*
-	 * Try to issue Inquiry3 command
-	 * if not succeeded, then issue MEGA_MBOXCMD_ADAPTERINQ command and
-	 * update enquiry3 structure
-	 */
-	mbox->m_out.xferaddr = (u32)adapter->buf_dma_handle;
-
-	inquiry3 = (mega_inquiry3 *)adapter->mega_buffer;
-
-	raw_mbox[0] = FC_NEW_CONFIG;		/* i.e. mbox->cmd=0xA1 */
-	raw_mbox[2] = NC_SUBOP_ENQUIRY3;	/* i.e. 0x0F */
-	raw_mbox[3] = ENQ3_GET_SOLICITED_FULL;	/* i.e. 0x02 */
-
-	/* Issue a blocking command to the card */
-	if ((retval = issue_scb_block(adapter, raw_mbox))) {
-		/* the adapter does not support 40ld */
-
-		mraid_ext_inquiry	*ext_inq;
-		mraid_inquiry		*inq;
-		dma_addr_t		dma_handle;
-
-		ext_inq = pci_alloc_consistent(adapter->dev,
-				sizeof(mraid_ext_inquiry), &dma_handle);
-
-		if( ext_inq == NULL ) return -1;
-
-		inq = &ext_inq->raid_inq;
-
-		mbox->m_out.xferaddr = (u32)dma_handle;
-
-		/*issue old 0x04 command to adapter */
-		mbox->m_out.cmd = MEGA_MBOXCMD_ADPEXTINQ;
-
-		issue_scb_block(adapter, raw_mbox);
-
-		/*
-		 * update Enquiry3 and ProductInfo structures with
-		 * mraid_inquiry structure
-		 */
-		mega_8_to_40ld(inq, inquiry3,
-				(mega_product_info *)&adapter->product_info);
-
-		pci_free_consistent(adapter->dev, sizeof(mraid_ext_inquiry),
-				ext_inq, dma_handle);
-
-	} else {		/*adapter supports 40ld */
-		adapter->flag |= BOARD_40LD;
-
-		/*
-		 * get product_info, which is static information and will be
-		 * unchanged
-		 */
-		prod_info_dma_handle = pci_map_single(adapter->dev, (void *)
-				&adapter->product_info,
-				sizeof(mega_product_info), PCI_DMA_FROMDEVICE);
-
-		mbox->m_out.xferaddr = prod_info_dma_handle;
-
-		raw_mbox[0] = FC_NEW_CONFIG;	/* i.e. mbox->cmd=0xA1 */
-		raw_mbox[2] = NC_SUBOP_PRODUCT_INFO;	/* i.e. 0x0E */
-
-		if ((retval = issue_scb_block(adapter, raw_mbox)))
-			printk(KERN_WARNING
-			"megaraid: Product_info cmd failed with error: %d\n",
-				retval);
-
-		pci_unmap_single(adapter->dev, prod_info_dma_handle,
-				sizeof(mega_product_info), PCI_DMA_FROMDEVICE);
-	}
-
-
-	/*
-	 * kernel scans the channels from 0 to <= max_channel
-	 */
-	adapter->host->max_channel =
-		adapter->product_info.nchannels + NVIRT_CHAN -1;
-
-	adapter->host->max_id = 16;	/* max targets per channel */
-
-	adapter->host->max_lun = 7;	/* Upto 7 luns for non disk devices */
-
-	adapter->host->cmd_per_lun = max_cmd_per_lun;
-
-	adapter->numldrv = inquiry3->num_ldrv;
-
-	adapter->max_cmds = adapter->product_info.max_commands;
-
-	if(adapter->max_cmds > MAX_COMMANDS)
-		adapter->max_cmds = MAX_COMMANDS;
-
-	adapter->host->can_queue = adapter->max_cmds - 1;
-
-	/*
-	 * Get the maximum number of scatter-gather elements supported by this
-	 * firmware
-	 */
-	mega_get_max_sgl(adapter);
-
-	adapter->host->sg_tablesize = adapter->sglen;
-
-
-	/* use HP firmware and bios version encoding */
-	if (adapter->product_info.subsysvid == HP_SUBSYS_VID) {
-		sprintf (adapter->fw_version, "%c%d%d.%d%d",
-			 adapter->product_info.fw_version[2],
-			 adapter->product_info.fw_version[1] >> 8,
-			 adapter->product_info.fw_version[1] & 0x0f,
-			 adapter->product_info.fw_version[0] >> 8,
-			 adapter->product_info.fw_version[0] & 0x0f);
-		sprintf (adapter->bios_version, "%c%d%d.%d%d",
-			 adapter->product_info.bios_version[2],
-			 adapter->product_info.bios_version[1] >> 8,
-			 adapter->product_info.bios_version[1] & 0x0f,
-			 adapter->product_info.bios_version[0] >> 8,
-			 adapter->product_info.bios_version[0] & 0x0f);
-	} else {
-		memcpy(adapter->fw_version,
-				(char *)adapter->product_info.fw_version, 4);
-		adapter->fw_version[4] = 0;
-
-		memcpy(adapter->bios_version,
-				(char *)adapter->product_info.bios_version, 4);
-
-		adapter->bios_version[4] = 0;
-	}
-
-	printk(KERN_NOTICE "megaraid: [%s:%s] detected %d logical drives.\n",
-		adapter->fw_version, adapter->bios_version, adapter->numldrv);
-
-	/*
-	 * Do we support extended (>10 bytes) cdbs
-	 */
-	adapter->support_ext_cdb = mega_support_ext_cdb(adapter);
-	if (adapter->support_ext_cdb)
-		printk(KERN_NOTICE "megaraid: supports extended CDBs.\n");
-
-
-	return 0;
-}
-
-
-/*
- * megaraid_queue()
- * @scmd - Issue this scsi command
- * @done - the callback hook into the scsi mid-layer
- *
- * The command queuing entry point for the mid-layer.
- */
-static int
-megaraid_queue(Scsi_Cmnd *scmd, void (*done)(Scsi_Cmnd *))
-{
-	adapter_t	*adapter;
-	scb_t	*scb;
-	int	busy=0;
-
-	adapter = (adapter_t *)scmd->device->host->hostdata;
-
-	scmd->scsi_done = done;
-
-
-	/*
-	 * Allocate and build a SCB request
-	 * busy flag will be set if mega_build_cmd() command could not
-	 * allocate scb. We will return non-zero status in that case.
-	 * NOTE: scb can be null even though certain commands completed
-	 * successfully, e.g., MODE_SENSE and TEST_UNIT_READY, we would
-	 * return 0 in that case.
-	 */
-
-	scb = mega_build_cmd(adapter, scmd, &busy);
-
-	if(scb) {
-		scb->state |= SCB_PENDQ;
-		list_add_tail(&scb->list, &adapter->pending_list);
-
-		/*
-		 * Check if the HBA is in quiescent state, e.g., during a
-		 * delete logical drive opertion. If it is, don't run
-		 * the pending_list.
-		 */
-		if(atomic_read(&adapter->quiescent) == 0) {
-			mega_runpendq(adapter);
-		}
-		return 0;
-	}
-
-	return busy;
-}
-
-
-/**
- * mega_build_cmd()
- * @adapter - pointer to our soft state
- * @cmd - Prepare using this scsi command
- * @busy - busy flag if no resources
- *
- * Prepares a command and scatter gather list for the controller. This routine
- * also finds out if the commands is intended for a logical drive or a
- * physical device and prepares the controller command accordingly.
- *
- * We also re-order the logical drives and physical devices based on their
- * boot settings.
- */
-static scb_t *
-mega_build_cmd(adapter_t *adapter, Scsi_Cmnd *cmd, int *busy)
-{
-	mega_ext_passthru	*epthru;
-	mega_passthru	*pthru;
-	scb_t	*scb;
-	mbox_t	*mbox;
-	long	seg;
-	char	islogical;
-	int	max_ldrv_num;
-	int	channel = 0;
-	int	target = 0;
-	int	ldrv_num = 0;   /* logical drive number */
-
-
-	/*
-	 * filter the internal and ioctl commands
-	 */
-	if((cmd->cmnd[0] == MEGA_INTERNAL_CMD)) {
-		return cmd->buffer;
-	}
-
-
-	/*
-	 * We know what channels our logical drives are on - mega_find_card()
-	 */
-	islogical = adapter->logdrv_chan[cmd->device->channel];
-
-	/*
-	 * The theory: If physical drive is chosen for boot, all the physical
-	 * devices are exported before the logical drives, otherwise physical
-	 * devices are pushed after logical drives, in which case - Kernel sees
-	 * the physical devices on virtual channel which is obviously converted
-	 * to actual channel on the HBA.
-	 */
-	if( adapter->boot_pdrv_enabled ) {
-		if( islogical ) {
-			/* logical channel */
-			channel = cmd->device->channel -
-				adapter->product_info.nchannels;
-		}
-		else {
-			/* this is physical channel */
-			channel = cmd->device->channel; 
-			target = cmd->device->id;
-
-			/*
-			 * boot from a physical disk, that disk needs to be
-			 * exposed first IF both the channels are SCSI, then
-			 * booting from the second channel is not allowed.
-			 */
-			if( target == 0 ) {
-				target = adapter->boot_pdrv_tgt;
-			}
-			else if( target == adapter->boot_pdrv_tgt ) {
-				target = 0;
-			}
-		}
-	}
-	else {
-		if( islogical ) {
-			/* this is the logical channel */
-			channel = cmd->device->channel;	
-		}
-		else {
-			/* physical channel */
-			channel = cmd->device->channel - NVIRT_CHAN;	
-			target = cmd->device->id;
-		}
-	}
-
-
-	if(islogical) {
-
-		/* have just LUN 0 for each target on virtual channels */
-		if (cmd->device->lun) {
-			cmd->result = (DID_BAD_TARGET << 16);
-			cmd->scsi_done(cmd);
-			return NULL;
-		}
-
-		ldrv_num = mega_get_ldrv_num(adapter, cmd, channel);
-
-
-		max_ldrv_num = (adapter->flag & BOARD_40LD) ?
-			MAX_LOGICAL_DRIVES_40LD : MAX_LOGICAL_DRIVES_8LD;
-
-		/*
-		 * max_ldrv_num increases by 0x80 if some logical drive was
-		 * deleted.
-		 */
-		if(adapter->read_ldidmap)
-			max_ldrv_num += 0x80;
-
-		if(ldrv_num > max_ldrv_num ) {
-			cmd->result = (DID_BAD_TARGET << 16);
-			cmd->scsi_done(cmd);
-			return NULL;
-		}
-
-	}
-	else {
-		if( cmd->device->lun > 7) {
-			/*
-			 * Do not support lun >7 for physically accessed
-			 * devices
-			 */
-			cmd->result = (DID_BAD_TARGET << 16);
-			cmd->scsi_done(cmd);
-			return NULL;
-		}
-	}
-
-	/*
-	 *
-	 * Logical drive commands
-	 *
-	 */
-	if(islogical) {
-		switch (cmd->cmnd[0]) {
-		case TEST_UNIT_READY:
-			memset(cmd->request_buffer, 0, cmd->request_bufflen);
-
-#if MEGA_HAVE_CLUSTERING
-			/*
-			 * Do we support clustering and is the support enabled
-			 * If no, return success always
-			 */
-			if( !adapter->has_cluster ) {
-				cmd->result = (DID_OK << 16);
-				cmd->scsi_done(cmd);
-				return NULL;
-			}
-
-			if(!(scb = mega_allocate_scb(adapter, cmd))) {
-
-				cmd->result = (DID_ERROR << 16);
-				cmd->scsi_done(cmd);
-				*busy = 1;
-
-				return NULL;
-			}
-
-			scb->raw_mbox[0] = MEGA_CLUSTER_CMD;
-			scb->raw_mbox[2] = MEGA_RESERVATION_STATUS;
-			scb->raw_mbox[3] = ldrv_num;
-
-			scb->dma_direction = PCI_DMA_NONE;
-
-			return scb;
-#else
-			cmd->result = (DID_OK << 16);
-			cmd->scsi_done(cmd);
-			return NULL;
-#endif
-
-		case MODE_SENSE:
-			memset(cmd->request_buffer, 0, cmd->cmnd[4]);
-			cmd->result = (DID_OK << 16);
-			cmd->scsi_done(cmd);
-			return NULL;
-
-		case READ_CAPACITY:
-		case INQUIRY:
-
-			if(!(adapter->flag & (1L << cmd->device->channel))) {
-
-				printk(KERN_NOTICE
-					"scsi%d: scanning scsi channel %d ",
-						adapter->host->host_no,
-						cmd->device->channel);
-				printk("for logical drives.\n");
-
-				adapter->flag |= (1L << cmd->device->channel);
-			}
-
-			/* Allocate a SCB and initialize passthru */
-			if(!(scb = mega_allocate_scb(adapter, cmd))) {
-
-				cmd->result = (DID_ERROR << 16);
-				cmd->scsi_done(cmd);
-				*busy = 1;
-
-				return NULL;
-			}
-			pthru = scb->pthru;
-
-			mbox = (mbox_t *)scb->raw_mbox;
-			memset(mbox, 0, sizeof(scb->raw_mbox));
-			memset(pthru, 0, sizeof(mega_passthru));
-
-			pthru->timeout = 0;
-			pthru->ars = 1;
-			pthru->reqsenselen = 14;
-			pthru->islogical = 1;
-			pthru->logdrv = ldrv_num;
-			pthru->cdblen = cmd->cmd_len;
-			memcpy(pthru->cdb, cmd->cmnd, cmd->cmd_len);
-
-			if( adapter->has_64bit_addr ) {
-				mbox->m_out.cmd = MEGA_MBOXCMD_PASSTHRU64;
-			}
-			else {
-				mbox->m_out.cmd = MEGA_MBOXCMD_PASSTHRU;
-			}
-
-			scb->dma_direction = PCI_DMA_FROMDEVICE;
-
-			pthru->numsgelements = mega_build_sglist(adapter, scb,
-				&pthru->dataxferaddr, &pthru->dataxferlen);
-
-			mbox->m_out.xferaddr = scb->pthru_dma_addr;
-
-			return scb;
-
-		case READ_6:
-		case WRITE_6:
-		case READ_10:
-		case WRITE_10:
-		case READ_12:
-		case WRITE_12:
-
-			/* Allocate a SCB and initialize mailbox */
-			if(!(scb = mega_allocate_scb(adapter, cmd))) {
-
-				cmd->result = (DID_ERROR << 16);
-				cmd->scsi_done(cmd);
-				*busy = 1;
-
-				return NULL;
-			}
-			mbox = (mbox_t *)scb->raw_mbox;
-
-			memset(mbox, 0, sizeof(scb->raw_mbox));
-			mbox->m_out.logdrv = ldrv_num;
-
-			/*
-			 * A little hack: 2nd bit is zero for all scsi read
-			 * commands and is set for all scsi write commands
-			 */
-			if( adapter->has_64bit_addr ) {
-				mbox->m_out.cmd = (*cmd->cmnd & 0x02) ?
-					MEGA_MBOXCMD_LWRITE64:
-					MEGA_MBOXCMD_LREAD64 ;
-			}
-			else {
-				mbox->m_out.cmd = (*cmd->cmnd & 0x02) ?
-					MEGA_MBOXCMD_LWRITE:
-					MEGA_MBOXCMD_LREAD ;
-			}
-
-			/*
-			 * 6-byte READ(0x08) or WRITE(0x0A) cdb
-			 */
-			if( cmd->cmd_len == 6 ) {
-				mbox->m_out.numsectors = (u32) cmd->cmnd[4];
-				mbox->m_out.lba =
-					((u32)cmd->cmnd[1] << 16) |
-					((u32)cmd->cmnd[2] << 8) |
-					(u32)cmd->cmnd[3];
-
-				mbox->m_out.lba &= 0x1FFFFF;
-
-#if MEGA_HAVE_STATS
-				/*
-				 * Take modulo 0x80, since the logical drive
-				 * number increases by 0x80 when a logical
-				 * drive was deleted
-				 */
-				if (*cmd->cmnd == READ_6) {
-					adapter->nreads[ldrv_num%0x80]++;
-					adapter->nreadblocks[ldrv_num%0x80] +=
-						mbox->m_out.numsectors;
-				} else {
-					adapter->nwrites[ldrv_num%0x80]++;
-					adapter->nwriteblocks[ldrv_num%0x80] +=
-						mbox->m_out.numsectors;
-				}
-#endif
-			}
-
-			/*
-			 * 10-byte READ(0x28) or WRITE(0x2A) cdb
-			 */
-			if( cmd->cmd_len == 10 ) {
-				mbox->m_out.numsectors =
-					(u32)cmd->cmnd[8] |
-					((u32)cmd->cmnd[7] << 8);
-				mbox->m_out.lba =
-					((u32)cmd->cmnd[2] << 24) |
-					((u32)cmd->cmnd[3] << 16) |
-					((u32)cmd->cmnd[4] << 8) |
-					(u32)cmd->cmnd[5];
-
-#if MEGA_HAVE_STATS
-				if (*cmd->cmnd == READ_10) {
-					adapter->nreads[ldrv_num%0x80]++;
-					adapter->nreadblocks[ldrv_num%0x80] +=
-						mbox->m_out.numsectors;
-				} else {
-					adapter->nwrites[ldrv_num%0x80]++;
-					adapter->nwriteblocks[ldrv_num%0x80] +=
-						mbox->m_out.numsectors;
-				}
-#endif
-			}
-
-			/*
-			 * 12-byte READ(0xA8) or WRITE(0xAA) cdb
-			 */
-			if( cmd->cmd_len == 12 ) {
-				mbox->m_out.lba =
-					((u32)cmd->cmnd[2] << 24) |
-					((u32)cmd->cmnd[3] << 16) |
-					((u32)cmd->cmnd[4] << 8) |
-					(u32)cmd->cmnd[5];
-
-				mbox->m_out.numsectors =
-					((u32)cmd->cmnd[6] << 24) |
-					((u32)cmd->cmnd[7] << 16) |
-					((u32)cmd->cmnd[8] << 8) |
-					(u32)cmd->cmnd[9];
-
-#if MEGA_HAVE_STATS
-				if (*cmd->cmnd == READ_12) {
-					adapter->nreads[ldrv_num%0x80]++;
-					adapter->nreadblocks[ldrv_num%0x80] +=
-						mbox->m_out.numsectors;
-				} else {
-					adapter->nwrites[ldrv_num%0x80]++;
-					adapter->nwriteblocks[ldrv_num%0x80] +=
-						mbox->m_out.numsectors;
-				}
-#endif
-			}
-
-			/*
-			 * If it is a read command
-			 */
-			if( (*cmd->cmnd & 0x0F) == 0x08 ) {
-				scb->dma_direction = PCI_DMA_FROMDEVICE;
-			}
-			else {
-				scb->dma_direction = PCI_DMA_TODEVICE;
-			}
-
-			/* Calculate Scatter-Gather info */
-			mbox->m_out.numsgelements = mega_build_sglist(adapter, scb,
-					(u32 *)&mbox->m_out.xferaddr, (u32 *)&seg);
-
-			return scb;
-
-#if MEGA_HAVE_CLUSTERING
-		case RESERVE:	/* Fall through */
-		case RELEASE:
-
-			/*
-			 * Do we support clustering and is the support enabled
-			 */
-			if( ! adapter->has_cluster ) {
-
-				cmd->result = (DID_BAD_TARGET << 16);
-				cmd->scsi_done(cmd);
-				return NULL;
-			}
-
-			/* Allocate a SCB and initialize mailbox */
-			if(!(scb = mega_allocate_scb(adapter, cmd))) {
-
-				cmd->result = (DID_ERROR << 16);
-				cmd->scsi_done(cmd);
-				*busy = 1;
-
-				return NULL;
-			}
-
-			scb->raw_mbox[0] = MEGA_CLUSTER_CMD;
-			scb->raw_mbox[2] = ( *cmd->cmnd == RESERVE ) ?
-				MEGA_RESERVE_LD : MEGA_RELEASE_LD;
-
-			scb->raw_mbox[3] = ldrv_num;
-
-			scb->dma_direction = PCI_DMA_NONE;
-
-			return scb;
-#endif
-
-		default:
-			cmd->result = (DID_BAD_TARGET << 16);
-			cmd->scsi_done(cmd);
-			return NULL;
-		}
-	}
-
-	/*
-	 * Passthru drive commands
-	 */
-	else {
-		/* Allocate a SCB and initialize passthru */
-		if(!(scb = mega_allocate_scb(adapter, cmd))) {
-
-			cmd->result = (DID_ERROR << 16);
-			cmd->scsi_done(cmd);
-			*busy = 1;
-
-			return NULL;
-		}
-
-		mbox = (mbox_t *)scb->raw_mbox;
-		memset(mbox, 0, sizeof(scb->raw_mbox));
-
-		if( adapter->support_ext_cdb ) {
-
-			epthru = mega_prepare_extpassthru(adapter, scb, cmd,
-					channel, target);
-
-			mbox->m_out.cmd = MEGA_MBOXCMD_EXTPTHRU;
-
-			mbox->m_out.xferaddr = scb->epthru_dma_addr;
-
-		}
-		else {
-
-			pthru = mega_prepare_passthru(adapter, scb, cmd,
-					channel, target);
-
-			/* Initialize mailbox */
-			if( adapter->has_64bit_addr ) {
-				mbox->m_out.cmd = MEGA_MBOXCMD_PASSTHRU64;
-			}
-			else {
-				mbox->m_out.cmd = MEGA_MBOXCMD_PASSTHRU;
-			}
-
-			mbox->m_out.xferaddr = scb->pthru_dma_addr;
-
-		}
-		return scb;
-	}
-	return NULL;
-}
-
-
-/**
- * mega_prepare_passthru()
- * @adapter - pointer to our soft state
- * @scb - our scsi control block
- * @cmd - scsi command from the mid-layer
- * @channel - actual channel on the controller
- * @target - actual id on the controller.
- *
- * prepare a command for the scsi physical devices.
- */
-static mega_passthru *
-mega_prepare_passthru(adapter_t *adapter, scb_t *scb, Scsi_Cmnd *cmd,
-		int channel, int target)
-{
-	mega_passthru *pthru;
-
-	pthru = scb->pthru;
-	memset(pthru, 0, sizeof (mega_passthru));
-
-	/* 0=6sec/1=60sec/2=10min/3=3hrs */
-	pthru->timeout = 2;
-
-	pthru->ars = 1;
-	pthru->reqsenselen = 14;
-	pthru->islogical = 0;
-
-	pthru->channel = (adapter->flag & BOARD_40LD) ? 0 : channel;
-
-	pthru->target = (adapter->flag & BOARD_40LD) ?
-		(channel << 4) | target : target;
-
-	pthru->cdblen = cmd->cmd_len;
-	pthru->logdrv = cmd->device->lun;
-
-	memcpy(pthru->cdb, cmd->cmnd, cmd->cmd_len);
-
-	/* Not sure about the direction */
-	scb->dma_direction = PCI_DMA_BIDIRECTIONAL;
-
-	/* Special Code for Handling READ_CAPA/ INQ using bounce buffers */
-	switch (cmd->cmnd[0]) {
-	case INQUIRY:
-	case READ_CAPACITY:
-		if(!(adapter->flag & (1L << cmd->device->channel))) {
-
-			printk(KERN_NOTICE
-				"scsi%d: scanning scsi channel %d [P%d] ",
-					adapter->host->host_no,
-					cmd->device->channel, channel);
-			printk("for physical devices.\n");
-
-			adapter->flag |= (1L << cmd->device->channel);
-		}
-		/* Fall through */
-	default:
-		pthru->numsgelements = mega_build_sglist(adapter, scb,
-				&pthru->dataxferaddr, &pthru->dataxferlen);
-		break;
-	}
-	return pthru;
-}
-
-
-/**
- * mega_prepare_extpassthru()
- * @adapter - pointer to our soft state
- * @scb - our scsi control block
- * @cmd - scsi command from the mid-layer
- * @channel - actual channel on the controller
- * @target - actual id on the controller.
- *
- * prepare a command for the scsi physical devices. This rountine prepares
- * commands for devices which can take extended CDBs (>10 bytes)
- */
-static mega_ext_passthru *
-mega_prepare_extpassthru(adapter_t *adapter, scb_t *scb, Scsi_Cmnd *cmd,
-		int channel, int target)
-{
-	mega_ext_passthru	*epthru;
-
-	epthru = scb->epthru;
-	memset(epthru, 0, sizeof(mega_ext_passthru));
-
-	/* 0=6sec/1=60sec/2=10min/3=3hrs */
-	epthru->timeout = 2;
-
-	epthru->ars = 1;
-	epthru->reqsenselen = 14;
-	epthru->islogical = 0;
-
-	epthru->channel = (adapter->flag & BOARD_40LD) ? 0 : channel;
-	epthru->target = (adapter->flag & BOARD_40LD) ?
-		(channel << 4) | target : target;
-
-	epthru->cdblen = cmd->cmd_len;
-	epthru->logdrv = cmd->device->lun;
-
-	memcpy(epthru->cdb, cmd->cmnd, cmd->cmd_len);
-
-	/* Not sure about the direction */
-	scb->dma_direction = PCI_DMA_BIDIRECTIONAL;
-
-	switch(cmd->cmnd[0]) {
-	case INQUIRY:
-	case READ_CAPACITY:
-		if(!(adapter->flag & (1L << cmd->device->channel))) {
-
-			printk(KERN_NOTICE
-				"scsi%d: scanning scsi channel %d [P%d] ",
-					adapter->host->host_no,
-					cmd->device->channel, channel);
-			printk("for physical devices.\n");
-
-			adapter->flag |= (1L << cmd->device->channel);
-		}
-		/* Fall through */
-	default:
-		epthru->numsgelements = mega_build_sglist(adapter, scb,
-				&epthru->dataxferaddr, &epthru->dataxferlen);
-		break;
-	}
-
-	return epthru;
-}
-
-
-/**
- * mega_allocate_scb()
- * @adapter - pointer to our soft state
- * @cmd - scsi command from the mid-layer
- *
- * Allocate a SCB structure. This is the central structure for controller
- * commands.
- */
-static inline scb_t *
-mega_allocate_scb(adapter_t *adapter, Scsi_Cmnd *cmd)
-{
-	struct list_head *head = &adapter->free_list;
-	scb_t	*scb;
-
-	/* Unlink command from Free List */
-	if( !list_empty(head) ) {
-
-		scb = list_entry(head->next, scb_t, list);
-
-		list_del_init(head->next);
-
-		scb->state = SCB_ACTIVE;
-		scb->cmd = cmd;
-		scb->dma_type = MEGA_DMA_TYPE_NONE;
-
-		return scb;
-	}
-
-	return NULL;
-}
-
-
-/**
- * mega_runpendq()
- * @adapter - pointer to our soft state
- *
- * Runs through the list of pending requests.
- */
-static inline void
-mega_runpendq(adapter_t *adapter)
-{
-	if(!list_empty(&adapter->pending_list))
-		__mega_runpendq(adapter);
-}
-
-static void
-__mega_runpendq(adapter_t *adapter)
-{
-	scb_t *scb;
-	struct list_head *pos, *next;
-
-	/* Issue any pending commands to the card */
-	list_for_each_safe(pos, next, &adapter->pending_list) {
-
-		scb = list_entry(pos, scb_t, list);
-
-		if( !(scb->state & SCB_ISSUED) ) {
-
-			if( issue_scb(adapter, scb) != 0 )
-				return;
-		}
-	}
-
-	return;
-}
-
-
-/**
- * issue_scb()
- * @adapter - pointer to our soft state
- * @scb - scsi control block
- *
- * Post a command to the card if the mailbox is available, otherwise return
- * busy. We also take the scb from the pending list if the mailbox is
- * available.
- */
-static inline int
-issue_scb(adapter_t *adapter, scb_t *scb)
-{
-	volatile mbox64_t	*mbox64 = adapter->mbox64;
-	volatile mbox_t		*mbox = adapter->mbox;
-	unsigned int	i = 0;
-
-	if(unlikely(mbox->m_in.busy)) {
-		do {
-			udelay(1);
-			i++;
-		} while( mbox->m_in.busy && (i < max_mbox_busy_wait) );
-
-		if(mbox->m_in.busy) return -1;
-	}
-
-	/* Copy mailbox data into host structure */
-	memcpy((char *)&mbox->m_out, (char *)scb->raw_mbox, 
-			sizeof(struct mbox_out));
-
-	mbox->m_out.cmdid = scb->idx;	/* Set cmdid */
-	mbox->m_in.busy = 1;		/* Set busy */
-
-
-	/*
-	 * Increment the pending queue counter
-	 */
-	atomic_inc(&adapter->pend_cmds);
-
-	switch (mbox->m_out.cmd) {
-	case MEGA_MBOXCMD_LREAD64:
-	case MEGA_MBOXCMD_LWRITE64:
-	case MEGA_MBOXCMD_PASSTHRU64:
-	case MEGA_MBOXCMD_EXTPTHRU:
-		mbox64->xfer_segment_lo = mbox->m_out.xferaddr;
-		mbox64->xfer_segment_hi = 0;
-		mbox->m_out.xferaddr = 0xFFFFFFFF;
-		break;
-	default:
-		mbox64->xfer_segment_lo = 0;
-		mbox64->xfer_segment_hi = 0;
-	}
-
-	/*
-	 * post the command
-	 */
-	scb->state |= SCB_ISSUED;
-
-	if( likely(adapter->flag & BOARD_MEMMAP) ) {
-		mbox->m_in.poll = 0;
-		mbox->m_in.ack = 0;
-		WRINDOOR(adapter, adapter->mbox_dma | 0x1);
-	}
-	else {
-		irq_enable(adapter);
-		issue_command(adapter);
-	}
-
-	return 0;
-}
-
-
-/**
- * issue_scb_block()
- * @adapter - pointer to our soft state
- * @raw_mbox - the mailbox
- *
- * Issue a scb in synchronous and non-interrupt mode
- */
-static int
-issue_scb_block(adapter_t *adapter, u_char *raw_mbox)
-{
-	volatile mbox64_t *mbox64 = adapter->mbox64;
-	volatile mbox_t *mbox = adapter->mbox;
-	u8	byte;
-
-	/* Wait until mailbox is free */
-	if(mega_busywait_mbox (adapter))
-		goto bug_blocked_mailbox;
-
-	/* Copy mailbox data into host structure */
-	memcpy((char *) mbox, raw_mbox, sizeof(struct mbox_out));
-	mbox->m_out.cmdid = 0xFE;
-	mbox->m_in.busy = 1;
-
-	switch (raw_mbox[0]) {
-	case MEGA_MBOXCMD_LREAD64:
-	case MEGA_MBOXCMD_LWRITE64:
-	case MEGA_MBOXCMD_PASSTHRU64:
-	case MEGA_MBOXCMD_EXTPTHRU:
-		mbox64->xfer_segment_lo = mbox->m_out.xferaddr;
-		mbox64->xfer_segment_hi = 0;
-		mbox->m_out.xferaddr = 0xFFFFFFFF;
-		break;
-	default:
-		mbox64->xfer_segment_lo = 0;
-		mbox64->xfer_segment_hi = 0;
-	}
-
-	if( likely(adapter->flag & BOARD_MEMMAP) ) {
-		mbox->m_in.poll = 0;
-		mbox->m_in.ack = 0;
-		mbox->m_in.numstatus = 0xFF;
-		mbox->m_in.status = 0xFF;
-		WRINDOOR(adapter, adapter->mbox_dma | 0x1);
-
-		while((volatile u8)mbox->m_in.numstatus == 0xFF)
-			cpu_relax();
-
-		mbox->m_in.numstatus = 0xFF;
-
-		while( (volatile u8)mbox->m_in.poll != 0x77 )
-			cpu_relax();
-
-		mbox->m_in.poll = 0;
-		mbox->m_in.ack = 0x77;
-
-		WRINDOOR(adapter, adapter->mbox_dma | 0x2);
-
-		while(RDINDOOR(adapter) & 0x2)
-			cpu_relax();
-	}
-	else {
-		irq_disable(adapter);
-		issue_command(adapter);
-
-		while (!((byte = irq_state(adapter)) & INTR_VALID))
-			cpu_relax();
-
-		set_irq_state(adapter, byte);
-		irq_enable(adapter);
-		irq_ack(adapter);
-	}
-
-	return mbox->m_in.status;
-
-bug_blocked_mailbox:
-	printk(KERN_WARNING "megaraid: Blocked mailbox......!!\n");
-	udelay (1000);
-	return -1;
-}
-
-
-/**
- * megaraid_isr_iomapped()
- * @irq - irq
- * @devp - pointer to our soft state
- * @regs - unused
- *
- * Interrupt service routine for io-mapped controllers.
- * Find out if our device is interrupting. If yes, acknowledge the interrupt
- * and service the completed commands.
- */
-static irqreturn_t
-megaraid_isr_iomapped(int irq, void *devp, struct pt_regs *regs)
-{
-	adapter_t	*adapter = devp;
-	unsigned long	flags;
-	u8	status;
-	u8	nstatus;
-	u8	completed[MAX_FIRMWARE_STATUS];
-	u8	byte;
-	int	handled = 0;
-
-
-	/*
-	 * loop till F/W has more commands for us to complete.
-	 */
-	spin_lock_irqsave(&adapter->lock, flags);
-
-	do {
-		/* Check if a valid interrupt is pending */
-		byte = irq_state(adapter);
-		if( (byte & VALID_INTR_BYTE) == 0 ) {
-			/*
-			 * No more pending commands
-			 */
-			goto out_unlock;
-		}
-		set_irq_state(adapter, byte);
-
-		while((nstatus = (volatile u8)adapter->mbox->m_in.numstatus)
-				== 0xFF)
-			cpu_relax();
-		adapter->mbox->m_in.numstatus = 0xFF;
-
-		status = adapter->mbox->m_in.status;
-
-		/*
-		 * decrement the pending queue counter
-		 */
-		atomic_sub(nstatus, &adapter->pend_cmds);
-
-		memcpy(completed, (void *)adapter->mbox->m_in.completed, 
-				nstatus);
-
-		/* Acknowledge interrupt */
-		irq_ack(adapter);
-
-		mega_cmd_done(adapter, completed, nstatus, status);
-
-		mega_rundoneq(adapter);
-
-		handled = 1;
-
-		/* Loop through any pending requests */
-		if(atomic_read(&adapter->quiescent) == 0) {
-			mega_runpendq(adapter);
-		}
-
-	} while(1);
-
- out_unlock:
-
-	spin_unlock_irqrestore(&adapter->lock, flags);
-
-	return IRQ_RETVAL(handled);
-}
-
-
-/**
- * megaraid_isr_memmapped()
- * @irq - irq
- * @devp - pointer to our soft state
- * @regs - unused
- *
- * Interrupt service routine for memory-mapped controllers.
- * Find out if our device is interrupting. If yes, acknowledge the interrupt
- * and service the completed commands.
- */
-static irqreturn_t
-megaraid_isr_memmapped(int irq, void *devp, struct pt_regs *regs)
-{
-	adapter_t	*adapter = devp;
-	unsigned long	flags;
-	u8	status;
-	u32	dword = 0;
-	u8	nstatus;
-	u8	completed[MAX_FIRMWARE_STATUS];
-	int	handled = 0;
-
-
-	/*
-	 * loop till F/W has more commands for us to complete.
-	 */
-	spin_lock_irqsave(&adapter->lock, flags);
-
-	do {
-		/* Check if a valid interrupt is pending */
-		dword = RDOUTDOOR(adapter);
-		if(dword != 0x10001234) {
-			/*
-			 * No more pending commands
-			 */
-			goto out_unlock;
-		}
-		WROUTDOOR(adapter, 0x10001234);
-
-		while((nstatus = (volatile u8)adapter->mbox->m_in.numstatus)
-				== 0xFF) {
-			cpu_relax();
-		}
-		adapter->mbox->m_in.numstatus = 0xFF;
-
-		status = adapter->mbox->m_in.status;
-
-		/*
-		 * decrement the pending queue counter
-		 */
-		atomic_sub(nstatus, &adapter->pend_cmds);
-
-		memcpy(completed, (void *)adapter->mbox->m_in.completed, 
-				nstatus);
-
-		/* Acknowledge interrupt */
-		WRINDOOR(adapter, 0x2);
-
-		handled = 1;
-
-		while( RDINDOOR(adapter) & 0x02 ) cpu_relax();
-
-		mega_cmd_done(adapter, completed, nstatus, status);
-
-		mega_rundoneq(adapter);
-
-		/* Loop through any pending requests */
-		if(atomic_read(&adapter->quiescent) == 0) {
-			mega_runpendq(adapter);
-		}
-
-	} while(1);
-
- out_unlock:
-
-	spin_unlock_irqrestore(&adapter->lock, flags);
-
-	return IRQ_RETVAL(handled);
-}
-/**
- * mega_cmd_done()
- * @adapter - pointer to our soft state
- * @completed - array of ids of completed commands
- * @nstatus - number of completed commands
- * @status - status of the last command completed
- *
- * Complete the comamnds and call the scsi mid-layer callback hooks.
- */
-static inline void
-mega_cmd_done(adapter_t *adapter, u8 completed[], int nstatus, int status)
-{
-	mega_ext_passthru	*epthru = NULL;
-	struct scatterlist	*sgl;
-	Scsi_Cmnd	*cmd = NULL;
-	mega_passthru	*pthru = NULL;
-	mbox_t	*mbox = NULL;
-	u8	c;
-	scb_t	*scb;
-	int	islogical;
-	int	cmdid;
-	int	i;
-
-	/*
-	 * for all the commands completed, call the mid-layer callback routine
-	 * and free the scb.
-	 */
-	for( i = 0; i < nstatus; i++ ) {
-
-		cmdid = completed[i];
-
-		if( cmdid == CMDID_INT_CMDS ) { /* internal command */
-			scb = &adapter->int_scb;
-			cmd = scb->cmd;
-			mbox = (mbox_t *)scb->raw_mbox;
-
-			/*
-			 * Internal command interface do not fire the extended
-			 * passthru or 64-bit passthru
-			 */
-			pthru = scb->pthru;
-
-		}
-		else {
-			scb = &adapter->scb_list[cmdid];
-
-			/*
-			 * Make sure f/w has completed a valid command
-			 */
-			if( !(scb->state & SCB_ISSUED) || scb->cmd == NULL ) {
-				printk(KERN_CRIT
-					"megaraid: invalid command ");
-				printk("Id %d, scb->state:%x, scsi cmd:%p\n",
-					cmdid, scb->state, scb->cmd);
-
-				continue;
-			}
-
-			/*
-			 * Was a abort issued for this command
-			 */
-			if( scb->state & SCB_ABORT ) {
-
-				printk(KERN_WARNING
-				"megaraid: aborted cmd %lx[%x] complete.\n",
-					scb->cmd->serial_number, scb->idx);
-
-				scb->cmd->result = (DID_ABORT << 16);
-
-				list_add_tail(SCSI_LIST(scb->cmd),
-						&adapter->completed_list);
-
-				mega_free_scb(adapter, scb);
-
-				continue;
-			}
-
-			/*
-			 * Was a reset issued for this command
-			 */
-			if( scb->state & SCB_RESET ) {
-
-				printk(KERN_WARNING
-				"megaraid: reset cmd %lx[%x] complete.\n",
-					scb->cmd->serial_number, scb->idx);
-
-				scb->cmd->result = (DID_RESET << 16);
-
-				list_add_tail(SCSI_LIST(scb->cmd),
-						&adapter->completed_list);
-
-				mega_free_scb (adapter, scb);
-
-				continue;
-			}
-
-			cmd = scb->cmd;
-			pthru = scb->pthru;
-			epthru = scb->epthru;
-			mbox = (mbox_t *)scb->raw_mbox;
-
-#if MEGA_HAVE_STATS
-			{
-
-			int	logdrv = mbox->m_out.logdrv;
-
-			islogical = adapter->logdrv_chan[cmd->channel];
-			/*
-			 * Maintain an error counter for the logical drive.
-			 * Some application like SNMP agent need such
-			 * statistics
-			 */
-			if( status && islogical && (cmd->cmnd[0] == READ_6 ||
-						cmd->cmnd[0] == READ_10 ||
-						cmd->cmnd[0] == READ_12)) {
-				/*
-				 * Logical drive number increases by 0x80 when
-				 * a logical drive is deleted
-				 */
-				adapter->rd_errors[logdrv%0x80]++;
-			}
-
-			if( status && islogical && (cmd->cmnd[0] == WRITE_6 ||
-						cmd->cmnd[0] == WRITE_10 ||
-						cmd->cmnd[0] == WRITE_12)) {
-				/*
-				 * Logical drive number increases by 0x80 when
-				 * a logical drive is deleted
-				 */
-				adapter->wr_errors[logdrv%0x80]++;
-			}
-
-			}
-#endif
-		}
-
-		/*
-		 * Do not return the presence of hard disk on the channel so,
-		 * inquiry sent, and returned data==hard disk or removable
-		 * hard disk and not logical, request should return failure! -
-		 * PJ
-		 */
-		islogical = adapter->logdrv_chan[cmd->device->channel];
-		if( cmd->cmnd[0] == INQUIRY && !islogical ) {
-
-			if( cmd->use_sg ) {
-				sgl = (struct scatterlist *)
-					cmd->request_buffer;
-
-				if( sgl->page ) {
-					c = *(unsigned char *)
-					page_address((&sgl[0])->page) +
-					(&sgl[0])->offset; 
-				}
-				else {
-					printk(KERN_WARNING
-						"megaraid: invalid sg.\n");
-					c = 0;
-				}
-			}
-			else {
-				c = *(u8 *)cmd->request_buffer;
-			}
-
-			if(IS_RAID_CH(adapter, cmd->device->channel) &&
-					((c & 0x1F ) == TYPE_DISK)) {
-				status = 0xF0;
-			}
-		}
-
-		/* clear result; otherwise, success returns corrupt value */
-		cmd->result = 0;
-
-		/* Convert MegaRAID status to Linux error code */
-		switch (status) {
-		case 0x00:	/* SUCCESS , i.e. SCSI_STATUS_GOOD */
-			cmd->result |= (DID_OK << 16);
-			break;
-
-		case 0x02:	/* ERROR_ABORTED, i.e.
-				   SCSI_STATUS_CHECK_CONDITION */
-
-			/* set sense_buffer and result fields */
-			if( mbox->m_out.cmd == MEGA_MBOXCMD_PASSTHRU ||
-				mbox->m_out.cmd == MEGA_MBOXCMD_PASSTHRU64 ) {
-
-				memcpy(cmd->sense_buffer, pthru->reqsensearea,
-						14);
-
-				cmd->result = (DRIVER_SENSE << 24) |
-					(DID_OK << 16) |
-					(CHECK_CONDITION << 1);
-			}
-			else {
-				if (mbox->m_out.cmd == MEGA_MBOXCMD_EXTPTHRU) {
-
-					memcpy(cmd->sense_buffer,
-						epthru->reqsensearea, 14);
-
-					cmd->result = (DRIVER_SENSE << 24) |
-						(DID_OK << 16) |
-						(CHECK_CONDITION << 1);
-				} else {
-					cmd->sense_buffer[0] = 0x70;
-					cmd->sense_buffer[2] = ABORTED_COMMAND;
-					cmd->result |= (CHECK_CONDITION << 1);
-				}
-			}
-			break;
-
-		case 0x08:	/* ERR_DEST_DRIVE_FAILED, i.e.
-				   SCSI_STATUS_BUSY */
-			cmd->result |= (DID_BUS_BUSY << 16) | status;
-			break;
-
-		default:
-#if MEGA_HAVE_CLUSTERING
-			/*
-			 * If TEST_UNIT_READY fails, we know
-			 * MEGA_RESERVATION_STATUS failed
-			 */
-			if( cmd->cmnd[0] == TEST_UNIT_READY ) {
-				cmd->result |= (DID_ERROR << 16) |
-					(RESERVATION_CONFLICT << 1);
-			}
-			else
-			/*
-			 * Error code returned is 1 if Reserve or Release
-			 * failed or the input parameter is invalid
-			 */
-			if( status == 1 &&
-				(cmd->cmnd[0] == RESERVE ||
-					 cmd->cmnd[0] == RELEASE) ) {
-
-				cmd->result |= (DID_ERROR << 16) |
-					(RESERVATION_CONFLICT << 1);
-			}
-			else
-#endif
-				cmd->result |= (DID_BAD_TARGET << 16)|status;
-		}
-
-		/*
-		 * Only free SCBs for the commands coming down from the
-		 * mid-layer, not for which were issued internally
-		 *
-		 * For internal command, restore the status returned by the
-		 * firmware so that user can interpret it.
-		 */
-		if( cmdid == CMDID_INT_CMDS ) { /* internal command */
-			cmd->result = status;
-
-			/*
-			 * Remove the internal command from the pending list
-			 */
-			list_del_init(&scb->list);
-			scb->state = SCB_FREE;
-		}
-		else {
-			mega_free_scb(adapter, scb);
-		}
-
-		/* Add Scsi_Command to end of completed queue */
-		list_add_tail(SCSI_LIST(cmd), &adapter->completed_list);
-	}
-}
-
-
-/*
- * mega_runpendq()
- *
- * Run through the list of completed requests and finish it
- */
-static void
-mega_rundoneq (adapter_t *adapter)
-{
-	Scsi_Cmnd *cmd;
-	struct list_head *pos;
-
-	list_for_each(pos, &adapter->completed_list) {
-
-		Scsi_Pointer* spos = (Scsi_Pointer *)pos;
-
-		cmd = list_entry(spos, Scsi_Cmnd, SCp);
-		cmd->scsi_done(cmd);
-	}
-
-	INIT_LIST_HEAD(&adapter->completed_list);
-}
-
-
-/*
- * Free a SCB structure
- * Note: We assume the scsi commands associated with this scb is not free yet.
- */
-static void
-mega_free_scb(adapter_t *adapter, scb_t *scb)
-{
-	switch( scb->dma_type ) {
-
-	case MEGA_DMA_TYPE_NONE:
-		break;
-
-	case MEGA_BULK_DATA:
-		pci_unmap_page(adapter->dev, scb->dma_h_bulkdata,
-			scb->cmd->request_bufflen, scb->dma_direction);
-		break;
-
-	case MEGA_SGLIST:
-		pci_unmap_sg(adapter->dev, scb->cmd->request_buffer,
-			scb->cmd->use_sg, scb->dma_direction);
-		break;
-
-	default:
-		break;
-	}
-
-	/*
-	 * Remove from the pending list
-	 */
-	list_del_init(&scb->list);
-
-	/* Link the scb back into free list */
-	scb->state = SCB_FREE;
-	scb->cmd = NULL;
-
-	list_add(&scb->list, &adapter->free_list);
-}
-
-
-/*
- * Wait until the controller's mailbox is available
- */
-static inline int
-mega_busywait_mbox (adapter_t *adapter)
-{
-	if (adapter->mbox->m_in.busy)
-		return __mega_busywait_mbox(adapter);
-	return 0;
-}
-
-static int
-__mega_busywait_mbox (adapter_t *adapter)
-{
-	volatile mbox_t *mbox = adapter->mbox;
-	long counter;
-
-	for (counter = 0; counter < 10000; counter++) {
-		if (!mbox->m_in.busy)
-			return 0;
-		udelay(100); yield();
-	}
-	return -1;		/* give up after 1 second */
-}
-
-/*
- * Copies data to SGLIST
- * Note: For 64 bit cards, we need a minimum of one SG element for read/write
- */
-static int
-mega_build_sglist(adapter_t *adapter, scb_t *scb, u32 *buf, u32 *len)
-{
-	struct scatterlist	*sgl;
-	struct page	*page;
-	unsigned long	offset;
-	Scsi_Cmnd	*cmd;
-	int	sgcnt;
-	int	idx;
-
-	cmd = scb->cmd;
-
-	/* Scatter-gather not used */
-	if( !cmd->use_sg ) {
-
-		page = virt_to_page(cmd->request_buffer);
-		offset = offset_in_page(cmd->request_buffer);
-
-		scb->dma_h_bulkdata = pci_map_page(adapter->dev,
-						  page, offset,
-						  cmd->request_bufflen,
-						  scb->dma_direction);
-		scb->dma_type = MEGA_BULK_DATA;
-
-		/*
-		 * We need to handle special 64-bit commands that need a
-		 * minimum of 1 SG
-		 */
-		if( adapter->has_64bit_addr ) {
-			scb->sgl64[0].address = scb->dma_h_bulkdata;
-			scb->sgl64[0].length = cmd->request_bufflen;
-			*buf = (u32)scb->sgl_dma_addr;
-			*len = (u32)cmd->request_bufflen;
-			return 1;
-		}
-		else {
-			*buf = (u32)scb->dma_h_bulkdata;
-			*len = (u32)cmd->request_bufflen;
-		}
-		return 0;
-	}
-
-	sgl = (struct scatterlist *)cmd->request_buffer;
-
-	/*
-	 * Copy Scatter-Gather list info into controller structure.
-	 *
-	 * The number of sg elements returned must not exceed our limit
-	 */
-	sgcnt = pci_map_sg(adapter->dev, sgl, cmd->use_sg,
-			scb->dma_direction);
-
-	scb->dma_type = MEGA_SGLIST;
-
-	if( sgcnt > adapter->sglen ) BUG();
-
-	for( idx = 0; idx < sgcnt; idx++, sgl++ ) {
-
-		if( adapter->has_64bit_addr ) {
-			scb->sgl64[idx].address = sg_dma_address(sgl);
-			scb->sgl64[idx].length = sg_dma_len(sgl);
-		}
-		else {
-			scb->sgl[idx].address = sg_dma_address(sgl);
-			scb->sgl[idx].length = sg_dma_len(sgl);
-		}
-	}
-
-	/* Reset pointer and length fields */
-	*buf = scb->sgl_dma_addr;
-
-	/*
-	 * For passthru command, dataxferlen must be set, even for commands
-	 * with a sg list
-	 */
-	*len = (u32)cmd->request_bufflen;
-
-	/* Return count of SG requests */
-	return sgcnt;
-}
-
-
-/*
- * mega_8_to_40ld()
- *
- * takes all info in AdapterInquiry structure and puts it into ProductInfo and
- * Enquiry3 structures for later use
- */
-static void
-mega_8_to_40ld(mraid_inquiry *inquiry, mega_inquiry3 *enquiry3,
-		mega_product_info *product_info)
-{
-	int i;
-
-	product_info->max_commands = inquiry->adapter_info.max_commands;
-	enquiry3->rebuild_rate = inquiry->adapter_info.rebuild_rate;
-	product_info->nchannels = inquiry->adapter_info.nchannels;
-
-	for (i = 0; i < 4; i++) {
-		product_info->fw_version[i] =
-			inquiry->adapter_info.fw_version[i];
-
-		product_info->bios_version[i] =
-			inquiry->adapter_info.bios_version[i];
-	}
-	enquiry3->cache_flush_interval =
-		inquiry->adapter_info.cache_flush_interval;
-
-	product_info->dram_size = inquiry->adapter_info.dram_size;
-
-	enquiry3->num_ldrv = inquiry->logdrv_info.num_ldrv;
-
-	for (i = 0; i < MAX_LOGICAL_DRIVES_8LD; i++) {
-		enquiry3->ldrv_size[i] = inquiry->logdrv_info.ldrv_size[i];
-		enquiry3->ldrv_prop[i] = inquiry->logdrv_info.ldrv_prop[i];
-		enquiry3->ldrv_state[i] = inquiry->logdrv_info.ldrv_state[i];
-	}
-
-	for (i = 0; i < (MAX_PHYSICAL_DRIVES); i++)
-		enquiry3->pdrv_state[i] = inquiry->pdrv_info.pdrv_state[i];
-}
-
-static inline void
-mega_free_sgl(adapter_t *adapter)
-{
-	scb_t	*scb;
-	int	i;
-
-	for(i = 0; i < adapter->max_cmds; i++) {
-
-		scb = &adapter->scb_list[i];
-
-		if( scb->sgl64 ) {
-			pci_free_consistent(adapter->dev,
-				sizeof(mega_sgl64) * adapter->sglen,
-				scb->sgl64,
-				scb->sgl_dma_addr);
-
-			scb->sgl64 = NULL;
-		}
-
-		if( scb->pthru ) {
-			pci_free_consistent(adapter->dev, sizeof(mega_passthru),
-				scb->pthru, scb->pthru_dma_addr);
-
-			scb->pthru = NULL;
-		}
-
-		if( scb->epthru ) {
-			pci_free_consistent(adapter->dev,
-				sizeof(mega_ext_passthru),
-				scb->epthru, scb->epthru_dma_addr);
-
-			scb->epthru = NULL;
-		}
-
-	}
-}
-
-
-/*
- * Get information about the card/driver
- */
-const char *
-megaraid_info(struct Scsi_Host *host)
-{
-	static char buffer[512];
-	adapter_t *adapter;
-
-	adapter = (adapter_t *)host->hostdata;
-
-	sprintf (buffer,
-		 "LSI Logic MegaRAID %s %d commands %d targs %d chans %d luns",
-		 adapter->fw_version, adapter->product_info.max_commands,
-		 adapter->host->max_id, adapter->host->max_channel,
-		 adapter->host->max_lun);
-	return buffer;
-}
-
-/*
- * Abort a previous SCSI request. Only commands on the pending list can be
- * aborted. All the commands issued to the F/W must complete.
- */
-static int
-megaraid_abort(Scsi_Cmnd *cmd)
-{
-	adapter_t	*adapter;
-	int		rval;
-
-	adapter = (adapter_t *)cmd->device->host->hostdata;
-
-	rval =  megaraid_abort_and_reset(adapter, cmd, SCB_ABORT);
-
-	/*
-	 * This is required here to complete any completed requests
-	 * to be communicated over to the mid layer.
-	 */
-	mega_rundoneq(adapter);
-
-	return rval;
-}
-
-
-static int
-megaraid_reset(Scsi_Cmnd *cmd)
-{
-	adapter_t	*adapter;
-	megacmd_t	mc;
-	int		rval;
-
-	adapter = (adapter_t *)cmd->device->host->hostdata;
-
-#if MEGA_HAVE_CLUSTERING
-	mc.cmd = MEGA_CLUSTER_CMD;
-	mc.opcode = MEGA_RESET_RESERVATIONS;
-
-	spin_unlock_irq(&adapter->lock);
-	if( mega_internal_command(adapter, LOCK_INT, &mc, NULL) != 0 ) {
-		printk(KERN_WARNING
-				"megaraid: reservation reset failed.\n");
-	}
-	else {
-		printk(KERN_INFO "megaraid: reservation reset.\n");
-	}
-	spin_lock_irq(&adapter->lock);
-#endif
-
-	rval =  megaraid_abort_and_reset(adapter, cmd, SCB_RESET);
-
-	/*
-	 * This is required here to complete any completed requests
-	 * to be communicated over to the mid layer.
-	 */
-	mega_rundoneq(adapter);
-
-	return rval;
-}
-
-
-
-/**
- * megaraid_abort_and_reset()
- * @adapter - megaraid soft state
- * @cmd - scsi command to be aborted or reset
- * @aor - abort or reset flag
- *
- * Try to locate the scsi command in the pending queue. If found and is not
- * issued to the controller, abort/reset it. Otherwise return failure
- */
-static int
-megaraid_abort_and_reset(adapter_t *adapter, Scsi_Cmnd *cmd, int aor)
-{
-	struct list_head	*pos, *next;
-	scb_t			*scb;
-
-	printk(KERN_WARNING "megaraid: %s-%lx cmd=%x <c=%d t=%d l=%d>\n",
-	     (aor == SCB_ABORT)? "ABORTING":"RESET", cmd->serial_number,
-	     cmd->cmnd[0], cmd->device->channel, 
-	     cmd->device->id, cmd->device->lun);
-
-	if(list_empty(&adapter->pending_list))
-		return FALSE;
-
-	list_for_each_safe(pos, next, &adapter->pending_list) {
-
-		scb = list_entry(pos, scb_t, list);
-
-		if (scb->cmd == cmd) { /* Found command */
-
-			scb->state |= aor;
-
-			/*
-			 * Check if this command has firmare owenership. If
-			 * yes, we cannot reset this command. Whenever, f/w
-			 * completes this command, we will return appropriate
-			 * status from ISR.
-			 */
-			if( scb->state & SCB_ISSUED ) {
-
-				printk(KERN_WARNING
-					"megaraid: %s-%lx[%x], fw owner.\n",
-					(aor==SCB_ABORT) ? "ABORTING":"RESET",
-					cmd->serial_number, scb->idx);
-
-				return FALSE;
-			}
-			else {
-
-				/*
-				 * Not yet issued! Remove from the pending
-				 * list
-				 */
-				printk(KERN_WARNING
-					"megaraid: %s-%lx[%x], driver owner.\n",
-					(aor==SCB_ABORT) ? "ABORTING":"RESET",
-					cmd->serial_number, scb->idx);
-
-				mega_free_scb(adapter, scb);
-
-				if( aor == SCB_ABORT ) {
-					cmd->result = (DID_ABORT << 16);
-				}
-				else {
-					cmd->result = (DID_RESET << 16);
-				}
-
-				list_add_tail(SCSI_LIST(cmd),
-						&adapter->completed_list);
-
-				return TRUE;
-			}
-		}
-	}
-
-	return FALSE;
-}
-
-
-#ifdef CONFIG_PROC_FS
-/* Following code handles /proc fs  */
-
-#define CREATE_READ_PROC(string, func)	create_proc_read_entry(string,	\
-					S_IRUSR | S_IFREG,		\
-					controller_proc_dir_entry,	\
-					func, adapter)
-
-/**
- * mega_create_proc_entry()
- * @index - index in soft state array
- * @parent - parent node for this /proc entry
- *
- * Creates /proc entries for our controllers.
- */
-static void
-mega_create_proc_entry(int index, struct proc_dir_entry *parent)
-{
-	struct proc_dir_entry	*controller_proc_dir_entry = NULL;
-	u8		string[64] = { 0 };
-	adapter_t	*adapter = hba_soft_state[index];
-
-	sprintf(string, "hba%d", adapter->host->host_no);
-
-	controller_proc_dir_entry =
-		adapter->controller_proc_dir_entry = proc_mkdir(string, parent);
-
-	if(!controller_proc_dir_entry) {
-		printk(KERN_WARNING "\nmegaraid: proc_mkdir failed\n");
-		return;
-	}
-	adapter->proc_read = CREATE_READ_PROC("config", proc_read_config);
-	adapter->proc_stat = CREATE_READ_PROC("stat", proc_read_stat);
-	adapter->proc_mbox = CREATE_READ_PROC("mailbox", proc_read_mbox);
-#if MEGA_HAVE_ENH_PROC
-	adapter->proc_rr = CREATE_READ_PROC("rebuild-rate", proc_rebuild_rate);
-	adapter->proc_battery = CREATE_READ_PROC("battery-status",
-			proc_battery);
-
-	/*
-	 * Display each physical drive on its channel
-	 */
-	adapter->proc_pdrvstat[0] = CREATE_READ_PROC("diskdrives-ch0",
-					proc_pdrv_ch0);
-	adapter->proc_pdrvstat[1] = CREATE_READ_PROC("diskdrives-ch1",
-					proc_pdrv_ch1);
-	adapter->proc_pdrvstat[2] = CREATE_READ_PROC("diskdrives-ch2",
-					proc_pdrv_ch2);
-	adapter->proc_pdrvstat[3] = CREATE_READ_PROC("diskdrives-ch3",
-					proc_pdrv_ch3);
-
-	/*
-	 * Display a set of up to 10 logical drive through each of following
-	 * /proc entries
-	 */
-	adapter->proc_rdrvstat[0] = CREATE_READ_PROC("raiddrives-0-9",
-					proc_rdrv_10);
-	adapter->proc_rdrvstat[1] = CREATE_READ_PROC("raiddrives-10-19",
-					proc_rdrv_20);
-	adapter->proc_rdrvstat[2] = CREATE_READ_PROC("raiddrives-20-29",
-					proc_rdrv_30);
-	adapter->proc_rdrvstat[3] = CREATE_READ_PROC("raiddrives-30-39",
-					proc_rdrv_40);
-#endif
-}
-
-
-/**
- * proc_read_config()
- * @page - buffer to write the data in
- * @start - where the actual data has been written in page
- * @offset - same meaning as the read system call
- * @count - same meaning as the read system call
- * @eof - set if no more data needs to be returned
- * @data - pointer to our soft state
- *
- * Display configuration information about the controller.
- */
-static int
-proc_read_config(char *page, char **start, off_t offset, int count, int *eof,
-		void *data)
-{
-
-	adapter_t *adapter = (adapter_t *)data;
-	int len = 0;
-
-	len += sprintf(page+len, "%s", MEGARAID_VERSION);
-
-	if(adapter->product_info.product_name[0])
-		len += sprintf(page+len, "%s\n",
-				adapter->product_info.product_name);
-
-	len += sprintf(page+len, "Controller Type: ");
-
-	if( adapter->flag & BOARD_MEMMAP ) {
-		len += sprintf(page+len,
-			"438/466/467/471/493/518/520/531/532\n");
-	}
-	else {
-		len += sprintf(page+len,
-			"418/428/434\n");
-	}
-
-	if(adapter->flag & BOARD_40LD) {
-		len += sprintf(page+len,
-				"Controller Supports 40 Logical Drives\n");
-	}
-
-	if(adapter->flag & BOARD_64BIT) {
-		len += sprintf(page+len,
-		"Controller capable of 64-bit memory addressing\n");
-	}
-	if( adapter->has_64bit_addr ) {
-		len += sprintf(page+len,
-			"Controller using 64-bit memory addressing\n");
-	}
-	else {
-		len += sprintf(page+len,
-			"Controller is not using 64-bit memory addressing\n");
-	}
-
-	len += sprintf(page+len, "Base = %08lx, Irq = %d, ", adapter->base,
-			adapter->host->irq);
-
-	len += sprintf(page+len, "Logical Drives = %d, Channels = %d\n",
-			adapter->numldrv, adapter->product_info.nchannels);
-
-	len += sprintf(page+len, "Version =%s:%s, DRAM = %dMb\n",
-			adapter->fw_version, adapter->bios_version,
-			adapter->product_info.dram_size);
-
-	len += sprintf(page+len,
-		"Controller Queue Depth = %d, Driver Queue Depth = %d\n",
-		adapter->product_info.max_commands, adapter->max_cmds);
-
-	len += sprintf(page+len, "support_ext_cdb    = %d\n",
-			adapter->support_ext_cdb);
-	len += sprintf(page+len, "support_random_del = %d\n",
-			adapter->support_random_del);
-	len += sprintf(page+len, "boot_ldrv_enabled  = %d\n",
-			adapter->boot_ldrv_enabled);
-	len += sprintf(page+len, "boot_ldrv          = %d\n",
-			adapter->boot_ldrv);
-	len += sprintf(page+len, "boot_pdrv_enabled  = %d\n",
-			adapter->boot_pdrv_enabled);
-	len += sprintf(page+len, "boot_pdrv_ch       = %d\n",
-			adapter->boot_pdrv_ch);
-	len += sprintf(page+len, "boot_pdrv_tgt      = %d\n",
-			adapter->boot_pdrv_tgt);
-	len += sprintf(page+len, "quiescent          = %d\n",
-			atomic_read(&adapter->quiescent));
-	len += sprintf(page+len, "has_cluster        = %d\n",
-			adapter->has_cluster);
-
-	len += sprintf(page+len, "\nModule Parameters:\n");
-	len += sprintf(page+len, "max_cmd_per_lun    = %d\n",
-			max_cmd_per_lun);
-	len += sprintf(page+len, "max_sectors_per_io = %d\n",
-			max_sectors_per_io);
-
-	*eof = 1;
-
-	return len;
-}
-
-
-
-/**
- * proc_read_stat()
- * @page - buffer to write the data in
- * @start - where the actual data has been written in page
- * @offset - same meaning as the read system call
- * @count - same meaning as the read system call
- * @eof - set if no more data needs to be returned
- * @data - pointer to our soft state
- *
- * Diaplay statistical information about the I/O activity.
- */
-static int
-proc_read_stat(char *page, char **start, off_t offset, int count, int *eof,
-		void *data)
-{
-	adapter_t	*adapter;
-	int	len;
-	int	i;
-
-	i = 0;	/* avoid compilation warnings */
-	len = 0;
-	adapter = (adapter_t *)data;
-
-	len = sprintf(page, "Statistical Information for this controller\n");
-	len += sprintf(page+len, "pend_cmds = %d\n",
-			atomic_read(&adapter->pend_cmds));
-#if MEGA_HAVE_STATS
-	for(i = 0; i < adapter->numldrv; i++) {
-		len += sprintf(page+len, "Logical Drive %d:\n", i);
-
-		len += sprintf(page+len,
-			"\tReads Issued = %lu, Writes Issued = %lu\n",
-			adapter->nreads[i], adapter->nwrites[i]);
-
-		len += sprintf(page+len,
-			"\tSectors Read = %lu, Sectors Written = %lu\n",
-			adapter->nreadblocks[i], adapter->nwriteblocks[i]);
-
-		len += sprintf(page+len,
-			"\tRead errors = %lu, Write errors = %lu\n\n",
-			adapter->rd_errors[i], adapter->wr_errors[i]);
-	}
-#else
-	len += sprintf(page+len,
-			"IO and error counters not compiled in driver.\n");
-#endif
-
-	*eof = 1;
-
-	return len;
-}
-
-
-/**
- * proc_read_mbox()
- * @page - buffer to write the data in
- * @start - where the actual data has been written in page
- * @offset - same meaning as the read system call
- * @count - same meaning as the read system call
- * @eof - set if no more data needs to be returned
- * @data - pointer to our soft state
- *
- * Display mailbox information for the last command issued. This information
- * is good for debugging.
- */
-static int
-proc_read_mbox(char *page, char **start, off_t offset, int count, int *eof,
-		void *data)
-{
-
-	adapter_t	*adapter = (adapter_t *)data;
-	volatile mbox_t	*mbox = adapter->mbox;
-	int	len = 0;
-
-	len = sprintf(page, "Contents of Mail Box Structure\n");
-	len += sprintf(page+len, "  Fw Command   = 0x%02x\n", 
-			mbox->m_out.cmd);
-	len += sprintf(page+len, "  Cmd Sequence = 0x%02x\n", 
-			mbox->m_out.cmdid);
-	len += sprintf(page+len, "  No of Sectors= %04d\n", 
-			mbox->m_out.numsectors);
-	len += sprintf(page+len, "  LBA          = 0x%02x\n", 
-			mbox->m_out.lba);
-	len += sprintf(page+len, "  DTA          = 0x%08x\n", 
-			mbox->m_out.xferaddr);
-	len += sprintf(page+len, "  Logical Drive= 0x%02x\n", 
-			mbox->m_out.logdrv);
-	len += sprintf(page+len, "  No of SG Elmt= 0x%02x\n",
-			mbox->m_out.numsgelements);
-	len += sprintf(page+len, "  Busy         = %01x\n", 
-			mbox->m_in.busy);
-	len += sprintf(page+len, "  Status       = 0x%02x\n", 
-			mbox->m_in.status);
-
-	*eof = 1;
-
-	return len;
-}
-
-
-/**
- * proc_rebuild_rate()
- * @page - buffer to write the data in
- * @start - where the actual data has been written in page
- * @offset - same meaning as the read system call
- * @count - same meaning as the read system call
- * @eof - set if no more data needs to be returned
- * @data - pointer to our soft state
- *
- * Display current rebuild rate
- */
-static int
-proc_rebuild_rate(char *page, char **start, off_t offset, int count, int *eof,
-		void *data)
-{
-	adapter_t	*adapter = (adapter_t *)data;
-	dma_addr_t	dma_handle;
-	caddr_t		inquiry;
-	struct pci_dev	*pdev;
-	int	len = 0;
-
-	if( make_local_pdev(adapter, &pdev) != 0 ) {
-		*eof = 1;
-		return len;
-	}
-
-	if( (inquiry = mega_allocate_inquiry(&dma_handle, pdev)) == NULL ) {
-		free_local_pdev(pdev);
-		*eof = 1;
-		return len;
-	}
-
-	if( mega_adapinq(adapter, dma_handle) != 0 ) {
-
-		len = sprintf(page, "Adapter inquiry failed.\n");
-
-		printk(KERN_WARNING "megaraid: inquiry failed.\n");
-
-		mega_free_inquiry(inquiry, dma_handle, pdev);
-
-		free_local_pdev(pdev);
-
-		*eof = 1;
-
-		return len;
-	}
-
-	if( adapter->flag & BOARD_40LD ) {
-		len = sprintf(page, "Rebuild Rate: [%d%%]\n",
-			((mega_inquiry3 *)inquiry)->rebuild_rate);
-	}
-	else {
-		len = sprintf(page, "Rebuild Rate: [%d%%]\n",
-			((mraid_ext_inquiry *)
-			inquiry)->raid_inq.adapter_info.rebuild_rate);
-	}
-
-
-	mega_free_inquiry(inquiry, dma_handle, pdev);
-
-	free_local_pdev(pdev);
-
-	*eof = 1;
-
-	return len;
-}
-
-
-/**
- * proc_battery()
- * @page - buffer to write the data in
- * @start - where the actual data has been written in page
- * @offset - same meaning as the read system call
- * @count - same meaning as the read system call
- * @eof - set if no more data needs to be returned
- * @data - pointer to our soft state
- *
- * Display information about the battery module on the controller.
- */
-static int
-proc_battery(char *page, char **start, off_t offset, int count, int *eof,
-		void *data)
-{
-	adapter_t	*adapter = (adapter_t *)data;
-	dma_addr_t	dma_handle;
-	caddr_t		inquiry;
-	struct pci_dev	*pdev;
-	u8	battery_status = 0;
-	char	str[256];
-	int	len = 0;
-
-	if( make_local_pdev(adapter, &pdev) != 0 ) {
-		*eof = 1;
-		return len;
-	}
-
-	if( (inquiry = mega_allocate_inquiry(&dma_handle, pdev)) == NULL ) {
-		free_local_pdev(pdev);
-		*eof = 1;
-		return len;
-	}
-
-	if( mega_adapinq(adapter, dma_handle) != 0 ) {
-
-		len = sprintf(page, "Adapter inquiry failed.\n");
-
-		printk(KERN_WARNING "megaraid: inquiry failed.\n");
-
-		mega_free_inquiry(inquiry, dma_handle, pdev);
-
-		free_local_pdev(pdev);
-
-		*eof = 1;
-
-		return len;
-	}
-
-	if( adapter->flag & BOARD_40LD ) {
-		battery_status = ((mega_inquiry3 *)inquiry)->battery_status;
-	}
-	else {
-		battery_status = ((mraid_ext_inquiry *)inquiry)->
-			raid_inq.adapter_info.battery_status;
-	}
-
-	/*
-	 * Decode the battery status
-	 */
-	sprintf(str, "Battery Status:[%d]", battery_status);
-
-	if(battery_status == MEGA_BATT_CHARGE_DONE)
-		strcat(str, " Charge Done");
-
-	if(battery_status & MEGA_BATT_MODULE_MISSING)
-		strcat(str, " Module Missing");
-	
-	if(battery_status & MEGA_BATT_LOW_VOLTAGE)
-		strcat(str, " Low Voltage");
-	
-	if(battery_status & MEGA_BATT_TEMP_HIGH)
-		strcat(str, " Temperature High");
-	
-	if(battery_status & MEGA_BATT_PACK_MISSING)
-		strcat(str, " Pack Missing");
-	
-	if(battery_status & MEGA_BATT_CHARGE_INPROG)
-		strcat(str, " Charge In-progress");
-	
-	if(battery_status & MEGA_BATT_CHARGE_FAIL)
-		strcat(str, " Charge Fail");
-	
-	if(battery_status & MEGA_BATT_CYCLES_EXCEEDED)
-		strcat(str, " Cycles Exceeded");
-
-	len = sprintf(page, "%s\n", str);
-
-
-	mega_free_inquiry(inquiry, dma_handle, pdev);
-
-	free_local_pdev(pdev);
-
-	*eof = 1;
-
-	return len;
-}
-
-
-/**
- * proc_pdrv_ch0()
- * @page - buffer to write the data in
- * @start - where the actual data has been written in page
- * @offset - same meaning as the read system call
- * @count - same meaning as the read system call
- * @eof - set if no more data needs to be returned
- * @data - pointer to our soft state
- *
- * Display information about the physical drives on physical channel 0.
- */
-static int
-proc_pdrv_ch0(char *page, char **start, off_t offset, int count, int *eof,
-		void *data)
-{
-	adapter_t *adapter = (adapter_t *)data;
-
-	*eof = 1;
-
-	return (proc_pdrv(adapter, page, 0));
-}
-
-
-/**
- * proc_pdrv_ch1()
- * @page - buffer to write the data in
- * @start - where the actual data has been written in page
- * @offset - same meaning as the read system call
- * @count - same meaning as the read system call
- * @eof - set if no more data needs to be returned
- * @data - pointer to our soft state
- *
- * Display information about the physical drives on physical channel 1.
- */
-static int
-proc_pdrv_ch1(char *page, char **start, off_t offset, int count, int *eof,
-		void *data)
-{
-	adapter_t *adapter = (adapter_t *)data;
-
-	*eof = 1;
-
-	return (proc_pdrv(adapter, page, 1));
-}
-
-
-/**
- * proc_pdrv_ch2()
- * @page - buffer to write the data in
- * @start - where the actual data has been written in page
- * @offset - same meaning as the read system call
- * @count - same meaning as the read system call
- * @eof - set if no more data needs to be returned
- * @data - pointer to our soft state
- *
- * Display information about the physical drives on physical channel 2.
- */
-static int
-proc_pdrv_ch2(char *page, char **start, off_t offset, int count, int *eof,
-		void *data)
-{
-	adapter_t *adapter = (adapter_t *)data;
-
-	*eof = 1;
-
-	return (proc_pdrv(adapter, page, 2));
-}
-
-
-/**
- * proc_pdrv_ch3()
- * @page - buffer to write the data in
- * @start - where the actual data has been written in page
- * @offset - same meaning as the read system call
- * @count - same meaning as the read system call
- * @eof - set if no more data needs to be returned
- * @data - pointer to our soft state
- *
- * Display information about the physical drives on physical channel 3.
- */
-static int
-proc_pdrv_ch3(char *page, char **start, off_t offset, int count, int *eof,
-		void *data)
-{
-	adapter_t *adapter = (adapter_t *)data;
-
-	*eof = 1;
-
-	return (proc_pdrv(adapter, page, 3));
-}
-
-
-/**
- * proc_pdrv()
- * @page - buffer to write the data in
- * @adapter - pointer to our soft state
- *
- * Display information about the physical drives.
- */
-static int
-proc_pdrv(adapter_t *adapter, char *page, int channel)
-{
-	dma_addr_t	dma_handle;
-	char		*scsi_inq;
-	dma_addr_t	scsi_inq_dma_handle;
-	caddr_t		inquiry;
-	struct pci_dev	*pdev;
-	u8	*pdrv_state;
-	u8	state;
-	int	tgt;
-	int	max_channels;
-	int	len = 0;
-	char	str[80];
-	int	i;
-
-	if( make_local_pdev(adapter, &pdev) != 0 ) {
-		return len;
-	}
-
-	if( (inquiry = mega_allocate_inquiry(&dma_handle, pdev)) == NULL ) {
-		free_local_pdev(pdev);
-		return len;
-	}
-
-	if( mega_adapinq(adapter, dma_handle) != 0 ) {
-
-		len = sprintf(page, "Adapter inquiry failed.\n");
-
-		printk(KERN_WARNING "megaraid: inquiry failed.\n");
-
-		mega_free_inquiry(inquiry, dma_handle, pdev);
-
-		free_local_pdev(pdev);
-
-		return len;
-	}
-
-
-	scsi_inq = pci_alloc_consistent(pdev, 256, &scsi_inq_dma_handle);
-
-	if( scsi_inq == NULL ) {
-		len = sprintf(page, "memory not available for scsi inq.\n");
-
-		mega_free_inquiry(inquiry, dma_handle, pdev);
-
-		free_local_pdev(pdev);
-
-		return len;
-	}
-
-	if( adapter->flag & BOARD_40LD ) {
-		pdrv_state = ((mega_inquiry3 *)inquiry)->pdrv_state;
-	}
-	else {
-		pdrv_state = ((mraid_ext_inquiry *)inquiry)->
-			raid_inq.pdrv_info.pdrv_state;
-	}
-
-	max_channels = adapter->product_info.nchannels;
-
-	if( channel >= max_channels ) return 0;
-
-	for( tgt = 0; tgt <= MAX_TARGET; tgt++ ) {
-
-		i = channel*16 + tgt;
-
-		state = *(pdrv_state + i);
-
-		switch( state & 0x0F ) {
-
-		case PDRV_ONLINE:
-			sprintf(str,
-			"Channel:%2d Id:%2d State: Online",
-				channel, tgt);
-			break;
-
-		case PDRV_FAILED:
-			sprintf(str,
-			"Channel:%2d Id:%2d State: Failed",
-				channel, tgt);
-			break;
-
-		case PDRV_RBLD:
-			sprintf(str,
-			"Channel:%2d Id:%2d State: Rebuild",
-				channel, tgt);
-			break;
-
-		case PDRV_HOTSPARE:
-			sprintf(str,
-			"Channel:%2d Id:%2d State: Hot spare",
-				channel, tgt);
-			break;
-
-		default:
-			sprintf(str,
-			"Channel:%2d Id:%2d State: Un-configured",
-				channel, tgt);
-			break;
-
-		}
-
-		/*
-		 * This interface displays inquiries for disk drives
-		 * only. Inquries for logical drives and non-disk
-		 * devices are available through /proc/scsi/scsi
-		 */
-		memset(scsi_inq, 0, 256);
-		if( mega_internal_dev_inquiry(adapter, channel, tgt,
-				scsi_inq_dma_handle) ||
-				(scsi_inq[0] & 0x1F) != TYPE_DISK ) {
-			continue;
-		}
-
-		/*
-		 * Check for overflow. We print less than 240
-		 * characters for inquiry
-		 */
-		if( (len + 240) >= PAGE_SIZE ) break;
-
-		len += sprintf(page+len, "%s.\n", str);
-
-		len += mega_print_inquiry(page+len, scsi_inq);
-	}
-
-	pci_free_consistent(pdev, 256, scsi_inq, scsi_inq_dma_handle);
-
-	mega_free_inquiry(inquiry, dma_handle, pdev);
-
-	free_local_pdev(pdev);
-
-	return len;
-}
-
-
-/*
- * Display scsi inquiry
- */
-static int
-mega_print_inquiry(char *page, char *scsi_inq)
-{
-	int	len = 0;
-	int	i;
-
-	len = sprintf(page, "  Vendor: ");
-	for( i = 8; i < 16; i++ ) {
-		len += sprintf(page+len, "%c", scsi_inq[i]);
-	}
-
-	len += sprintf(page+len, "  Model: ");
-
-	for( i = 16; i < 32; i++ ) {
-		len += sprintf(page+len, "%c", scsi_inq[i]);
-	}
-
-	len += sprintf(page+len, "  Rev: ");
-
-	for( i = 32; i < 36; i++ ) {
-		len += sprintf(page+len, "%c", scsi_inq[i]);
-	}
-
-	len += sprintf(page+len, "\n");
-
-	i = scsi_inq[0] & 0x1f;
-
-	len += sprintf(page+len, "  Type:   %s ",
-		i < MAX_SCSI_DEVICE_CODE ? scsi_device_types[i] :
-		   "Unknown          ");
-
-	len += sprintf(page+len,
-	"                 ANSI SCSI revision: %02x", scsi_inq[2] & 0x07);
-
-	if( (scsi_inq[2] & 0x07) == 1 && (scsi_inq[3] & 0x0f) == 1 )
-		len += sprintf(page+len, " CCS\n");
-	else
-		len += sprintf(page+len, "\n");
-
-	return len;
-}
-
-
-/**
- * proc_rdrv_10()
- * @page - buffer to write the data in
- * @start - where the actual data has been written in page
- * @offset - same meaning as the read system call
- * @count - same meaning as the read system call
- * @eof - set if no more data needs to be returned
- * @data - pointer to our soft state
- *
- * Display real time information about the logical drives 0 through 9.
- */
-static int
-proc_rdrv_10(char *page, char **start, off_t offset, int count, int *eof,
-		void *data)
-{
-	adapter_t *adapter = (adapter_t *)data;
-
-	*eof = 1;
-
-	return (proc_rdrv(adapter, page, 0, 9));
-}
-
-
-/**
- * proc_rdrv_20()
- * @page - buffer to write the data in
- * @start - where the actual data has been written in page
- * @offset - same meaning as the read system call
- * @count - same meaning as the read system call
- * @eof - set if no more data needs to be returned
- * @data - pointer to our soft state
- *
- * Display real time information about the logical drives 0 through 9.
- */
-static int
-proc_rdrv_20(char *page, char **start, off_t offset, int count, int *eof,
-		void *data)
-{
-	adapter_t *adapter = (adapter_t *)data;
-
-	*eof = 1;
-
-	return (proc_rdrv(adapter, page, 10, 19));
-}
-
-
-/**
- * proc_rdrv_30()
- * @page - buffer to write the data in
- * @start - where the actual data has been written in page
- * @offset - same meaning as the read system call
- * @count - same meaning as the read system call
- * @eof - set if no more data needs to be returned
- * @data - pointer to our soft state
- *
- * Display real time information about the logical drives 0 through 9.
- */
-static int
-proc_rdrv_30(char *page, char **start, off_t offset, int count, int *eof,
-		void *data)
-{
-	adapter_t *adapter = (adapter_t *)data;
-
-	*eof = 1;
-
-	return (proc_rdrv(adapter, page, 20, 29));
-}
-
-
-/**
- * proc_rdrv_40()
- * @page - buffer to write the data in
- * @start - where the actual data has been written in page
- * @offset - same meaning as the read system call
- * @count - same meaning as the read system call
- * @eof - set if no more data needs to be returned
- * @data - pointer to our soft state
- *
- * Display real time information about the logical drives 0 through 9.
- */
-static int
-proc_rdrv_40(char *page, char **start, off_t offset, int count, int *eof,
-		void *data)
-{
-	adapter_t *adapter = (adapter_t *)data;
-
-	*eof = 1;
-
-	return (proc_rdrv(adapter, page, 30, 39));
-}
-
-
-/**
- * proc_rdrv()
- * @page - buffer to write the data in
- * @adapter - pointer to our soft state
- * @start - starting logical drive to display
- * @end - ending logical drive to display
- *
- * We do not print the inquiry information since its already available through
- * /proc/scsi/scsi interface
- */
-static int
-proc_rdrv(adapter_t *adapter, char *page, int start, int end )
-{
-	dma_addr_t	dma_handle;
-	logdrv_param	*lparam;
-	megacmd_t	mc;
-	char		*disk_array;
-	dma_addr_t	disk_array_dma_handle;
-	caddr_t		inquiry;
-	struct pci_dev	*pdev;
-	u8	*rdrv_state;
-	int	num_ldrv;
-	u32	array_sz;
-	int	len = 0;
-	int	i;
-
-	if( make_local_pdev(adapter, &pdev) != 0 ) {
-		return len;
-	}
-
-	if( (inquiry = mega_allocate_inquiry(&dma_handle, pdev)) == NULL ) {
-		free_local_pdev(pdev);
-		return len;
-	}
-
-	if( mega_adapinq(adapter, dma_handle) != 0 ) {
-
-		len = sprintf(page, "Adapter inquiry failed.\n");
-
-		printk(KERN_WARNING "megaraid: inquiry failed.\n");
-
-		mega_free_inquiry(inquiry, dma_handle, pdev);
-
-		free_local_pdev(pdev);
-
-		return len;
-	}
-
-	memset(&mc, 0, sizeof(megacmd_t));
-
-	if( adapter->flag & BOARD_40LD ) {
-		array_sz = sizeof(disk_array_40ld);
-
-		rdrv_state = ((mega_inquiry3 *)inquiry)->ldrv_state;
-
-		num_ldrv = ((mega_inquiry3 *)inquiry)->num_ldrv;
-	}
-	else {
-		array_sz = sizeof(disk_array_8ld);
-
-		rdrv_state = ((mraid_ext_inquiry *)inquiry)->
-			raid_inq.logdrv_info.ldrv_state;
-
-		num_ldrv = ((mraid_ext_inquiry *)inquiry)->
-			raid_inq.logdrv_info.num_ldrv;
-	}
-
-	disk_array = pci_alloc_consistent(pdev, array_sz,
-			&disk_array_dma_handle);
-
-	if( disk_array == NULL ) {
-		len = sprintf(page, "memory not available.\n");
-
-		mega_free_inquiry(inquiry, dma_handle, pdev);
-
-		free_local_pdev(pdev);
-
-		return len;
-	}
-
-	mc.xferaddr = (u32)disk_array_dma_handle;
-
-	if( adapter->flag & BOARD_40LD ) {
-		mc.cmd = FC_NEW_CONFIG;
-		mc.opcode = OP_DCMD_READ_CONFIG;
-
-		if( mega_internal_command(adapter, LOCK_INT, &mc, NULL) ) {
-
-			len = sprintf(page, "40LD read config failed.\n");
-
-			mega_free_inquiry(inquiry, dma_handle, pdev);
-
-			pci_free_consistent(pdev, array_sz, disk_array,
-					disk_array_dma_handle);
-
-			free_local_pdev(pdev);
-
-			return len;
-		}
-
-	}
-	else {
-		mc.cmd = NEW_READ_CONFIG_8LD;
-
-		if( mega_internal_command(adapter, LOCK_INT, &mc, NULL) ) {
-
-			mc.cmd = READ_CONFIG_8LD;
-
-			if( mega_internal_command(adapter, LOCK_INT, &mc,
-						NULL) ){
-
-				len = sprintf(page,
-					"8LD read config failed.\n");
-
-				mega_free_inquiry(inquiry, dma_handle, pdev);
-
-				pci_free_consistent(pdev, array_sz,
-						disk_array,
-						disk_array_dma_handle);
-
-				free_local_pdev(pdev);
-
-				return len;
-			}
-		}
-	}
-
-	for( i = start; i < ( (end+1 < num_ldrv) ? end+1 : num_ldrv ); i++ ) {
-
-		if( adapter->flag & BOARD_40LD ) {
-			lparam =
-			&((disk_array_40ld *)disk_array)->ldrv[i].lparam;
-		}
-		else {
-			lparam =
-			&((disk_array_8ld *)disk_array)->ldrv[i].lparam;
-		}
-
-		/*
-		 * Check for overflow. We print less than 240 characters for
-		 * information about each logical drive.
-		 */
-		if( (len + 240) >= PAGE_SIZE ) break;
-
-		len += sprintf(page+len, "Logical drive:%2d:, ", i);
-
-		switch( rdrv_state[i] & 0x0F ) {
-		case RDRV_OFFLINE:
-			len += sprintf(page+len, "state: offline");
-			break;
-
-		case RDRV_DEGRADED:
-			len += sprintf(page+len, "state: degraded");
-			break;
-
-		case RDRV_OPTIMAL:
-			len += sprintf(page+len, "state: optimal");
-			break;
-
-		case RDRV_DELETED:
-			len += sprintf(page+len, "state: deleted");
-			break;
-
-		default:
-			len += sprintf(page+len, "state: unknown");
-			break;
-		}
-
-		/*
-		 * Check if check consistency or initialization is going on
-		 * for this logical drive.
-		 */
-		if( (rdrv_state[i] & 0xF0) == 0x20 ) {
-			len += sprintf(page+len,
-					", check-consistency in progress");
-		}
-		else if( (rdrv_state[i] & 0xF0) == 0x10 ) {
-			len += sprintf(page+len,
-					", initialization in progress");
-		}
-		
-		len += sprintf(page+len, "\n");
-
-		len += sprintf(page+len, "Span depth:%3d, ",
-				lparam->span_depth);
-
-		len += sprintf(page+len, "RAID level:%3d, ",
-				lparam->level);
-
-		len += sprintf(page+len, "Stripe size:%3d, ",
-				lparam->stripe_sz ? lparam->stripe_sz/2: 128);
-
-		len += sprintf(page+len, "Row size:%3d\n",
-				lparam->row_size);
-
-
-		len += sprintf(page+len, "Read Policy: ");
-
-		switch(lparam->read_ahead) {
-
-		case NO_READ_AHEAD:
-			len += sprintf(page+len, "No read ahead, ");
-			break;
-
-		case READ_AHEAD:
-			len += sprintf(page+len, "Read ahead, ");
-			break;
-
-		case ADAP_READ_AHEAD:
-			len += sprintf(page+len, "Adaptive, ");
-			break;
-
-		}
-
-		len += sprintf(page+len, "Write Policy: ");
-
-		switch(lparam->write_mode) {
-
-		case WRMODE_WRITE_THRU:
-			len += sprintf(page+len, "Write thru, ");
-			break;
-
-		case WRMODE_WRITE_BACK:
-			len += sprintf(page+len, "Write back, ");
-			break;
-		}
-
-		len += sprintf(page+len, "Cache Policy: ");
-
-		switch(lparam->direct_io) {
-
-		case CACHED_IO:
-			len += sprintf(page+len, "Cached IO\n\n");
-			break;
-
-		case DIRECT_IO:
-			len += sprintf(page+len, "Direct IO\n\n");
-			break;
-		}
-	}
-
-	mega_free_inquiry(inquiry, dma_handle, pdev);
-
-	pci_free_consistent(pdev, array_sz, disk_array,
-			disk_array_dma_handle);
-
-	free_local_pdev(pdev);
-
-	return len;
-}
-
-#endif
-
-
-/**
- * megaraid_biosparam()
- *
- * Return the disk geometry for a particular disk
- */
-static int
-megaraid_biosparam(struct scsi_device *sdev, struct block_device *bdev,
-		    sector_t capacity, int geom[])
-{
-	adapter_t	*adapter;
-	unsigned char	*bh;
-	int	heads;
-	int	sectors;
-	int	cylinders;
-	int	rval;
-
-	/* Get pointer to host config structure */
-	adapter = (adapter_t *)sdev->host->hostdata;
-
-	if (IS_RAID_CH(adapter, sdev->channel)) {
-			/* Default heads (64) & sectors (32) */
-			heads = 64;
-			sectors = 32;
-			cylinders = (ulong)capacity / (heads * sectors);
-
-			/*
-			 * Handle extended translation size for logical drives
-			 * > 1Gb
-			 */
-			if ((ulong)capacity >= 0x200000) {
-				heads = 255;
-				sectors = 63;
-				cylinders = (ulong)capacity / (heads * sectors);
-			}
-
-			/* return result */
-			geom[0] = heads;
-			geom[1] = sectors;
-			geom[2] = cylinders;
-	}
-	else {
-		bh = scsi_bios_ptable(bdev);
-
-		if( bh ) {
-			rval = scsi_partsize(bh, capacity,
-					    &geom[2], &geom[0], &geom[1]);
-			kfree(bh);
-			if( rval != -1 )
-				return rval;
-		}
-
-		printk(KERN_INFO
-		"megaraid: invalid partition on this disk on channel %d\n",
-				sdev->channel);
-
-		/* Default heads (64) & sectors (32) */
-		heads = 64;
-		sectors = 32;
-		cylinders = (ulong)capacity / (heads * sectors);
-
-		/* Handle extended translation size for logical drives > 1Gb */
-		if ((ulong)capacity >= 0x200000) {
-			heads = 255;
-			sectors = 63;
-			cylinders = (ulong)capacity / (heads * sectors);
-		}
-
-		/* return result */
-		geom[0] = heads;
-		geom[1] = sectors;
-		geom[2] = cylinders;
-	}
-
-	return 0;
-}
-
-/**
- * mega_init_scb()
- * @adapter - pointer to our soft state
- *
- * Allocate memory for the various pointers in the scb structures:
- * scatter-gather list pointer, passthru and extended passthru structure
- * pointers.
- */
-static int
-mega_init_scb(adapter_t *adapter)
-{
-	scb_t	*scb;
-	int	i;
-
-	for( i = 0; i < adapter->max_cmds; i++ ) {
-
-		scb = &adapter->scb_list[i];
-
-		scb->sgl64 = NULL;
-		scb->sgl = NULL;
-		scb->pthru = NULL;
-		scb->epthru = NULL;
-	}
-
-	for( i = 0; i < adapter->max_cmds; i++ ) {
-
-		scb = &adapter->scb_list[i];
-
-		scb->idx = i;
-
-		scb->sgl64 = pci_alloc_consistent(adapter->dev,
-				sizeof(mega_sgl64) * adapter->sglen,
-				&scb->sgl_dma_addr);
-
-		scb->sgl = (mega_sglist *)scb->sgl64;
-
-		if( !scb->sgl ) {
-			printk(KERN_WARNING "RAID: Can't allocate sglist.\n");
-			mega_free_sgl(adapter);
-			return -1;
-		}
-
-		scb->pthru = pci_alloc_consistent(adapter->dev,
-				sizeof(mega_passthru),
-				&scb->pthru_dma_addr);
-
-		if( !scb->pthru ) {
-			printk(KERN_WARNING "RAID: Can't allocate passthru.\n");
-			mega_free_sgl(adapter);
-			return -1;
-		}
-
-		scb->epthru = pci_alloc_consistent(adapter->dev,
-				sizeof(mega_ext_passthru),
-				&scb->epthru_dma_addr);
-
-		if( !scb->epthru ) {
-			printk(KERN_WARNING
-				"Can't allocate extended passthru.\n");
-			mega_free_sgl(adapter);
-			return -1;
-		}
-
-
-		scb->dma_type = MEGA_DMA_TYPE_NONE;
-
-		/*
-		 * Link to free list
-		 * lock not required since we are loading the driver, so no
-		 * commands possible right now.
-		 */
-		scb->state = SCB_FREE;
-		scb->cmd = NULL;
-		list_add(&scb->list, &adapter->free_list);
-	}
-
-	return 0;
-}
-
-
-/**
- * megadev_open()
- * @inode - unused
- * @filep - unused
- *
- * Routines for the character/ioctl interface to the driver. Find out if this
- * is a valid open. If yes, increment the module use count so that it cannot
- * be unloaded.
- */
-static int
-megadev_open (struct inode *inode, struct file *filep)
-{
-	/*
-	 * Only allow superuser to access private ioctl interface
-	 */
-	if( !capable(CAP_SYS_ADMIN) ) return -EACCES;
-
-	return 0;
-}
-
-
-/**
- * megadev_ioctl()
- * @inode - Our device inode
- * @filep - unused
- * @cmd - ioctl command
- * @arg - user buffer
- *
- * ioctl entry point for our private ioctl interface. We move the data in from
- * the user space, prepare the command (if necessary, convert the old MIMD
- * ioctl to new ioctl command), and issue a synchronous command to the
- * controller.
- */
-static int
-megadev_ioctl(struct inode *inode, struct file *filep, unsigned int cmd,
-		unsigned long arg)
-{
-	adapter_t	*adapter;
-	nitioctl_t	uioc;
-	int		adapno;
-	int		rval;
-	mega_passthru	*upthru;	/* user address for passthru */
-	mega_passthru	*pthru;		/* copy user passthru here */
-	dma_addr_t	pthru_dma_hndl;
-	void		*data = NULL;	/* data to be transferred */
-	dma_addr_t	data_dma_hndl;	/* dma handle for data xfer area */
-	megacmd_t	mc;
-	megastat_t	*ustats;
-	int		num_ldrv;
-	u32		uxferaddr = 0;
-	struct pci_dev	*pdev;
-
-	ustats = NULL; /* avoid compilation warnings */
-	num_ldrv = 0;
-
-	/*
-	 * Make sure only USCSICMD are issued through this interface.
-	 * MIMD application would still fire different command.
-	 */
-	if( (_IOC_TYPE(cmd) != MEGAIOC_MAGIC) && (cmd != USCSICMD) ) {
-		return -EINVAL;
-	}
-
-	/*
-	 * Check and convert a possible MIMD command to NIT command.
-	 * mega_m_to_n() copies the data from the user space, so we do not
-	 * have to do it here.
-	 * NOTE: We will need some user address to copyout the data, therefore
-	 * the inteface layer will also provide us with the required user
-	 * addresses.
-	 */
-	memset(&uioc, 0, sizeof(nitioctl_t));
-	if( (rval = mega_m_to_n( (void *)arg, &uioc)) != 0 )
-		return rval;
-
-
-	switch( uioc.opcode ) {
-
-	case GET_DRIVER_VER:
-		if( put_user(driver_ver, (u32 *)uioc.uioc_uaddr) )
-			return (-EFAULT);
-
-		break;
-
-	case GET_N_ADAP:
-		if( put_user(hba_count, (u32 *)uioc.uioc_uaddr) )
-			return (-EFAULT);
-
-		/*
-		 * Shucks. MIMD interface returns a positive value for number
-		 * of adapters. TODO: Change it to return 0 when there is no
-		 * applicatio using mimd interface.
-		 */
-		return hba_count;
-
-	case GET_ADAP_INFO:
-
-		/*
-		 * Which adapter
-		 */
-		if( (adapno = GETADAP(uioc.adapno)) >= hba_count )
-			return (-ENODEV);
-
-		if( copy_to_user(uioc.uioc_uaddr, mcontroller+adapno,
-				sizeof(struct mcontroller)) )
-			return (-EFAULT);
-		break;
-
-#if MEGA_HAVE_STATS
-
-	case GET_STATS:
-		/*
-		 * Which adapter
-		 */
-		if( (adapno = GETADAP(uioc.adapno)) >= hba_count )
-			return (-ENODEV);
-
-		adapter = hba_soft_state[adapno];
-
-		ustats = (megastat_t *)uioc.uioc_uaddr;
-
-		if( copy_from_user(&num_ldrv, &ustats->num_ldrv, sizeof(int)) )
-			return (-EFAULT);
-
-		/*
-		 * Check for the validity of the logical drive number
-		 */
-		if( num_ldrv >= MAX_LOGICAL_DRIVES_40LD ) return -EINVAL;
-
-		if( copy_to_user(ustats->nreads, adapter->nreads,
-					num_ldrv*sizeof(u32)) )
-			return -EFAULT;
-
-		if( copy_to_user(ustats->nreadblocks, adapter->nreadblocks,
-					num_ldrv*sizeof(u32)) )
-			return -EFAULT;
-
-		if( copy_to_user(ustats->nwrites, adapter->nwrites,
-					num_ldrv*sizeof(u32)) )
-			return -EFAULT;
-
-		if( copy_to_user(ustats->nwriteblocks, adapter->nwriteblocks,
-					num_ldrv*sizeof(u32)) )
-			return -EFAULT;
-
-		if( copy_to_user(ustats->rd_errors, adapter->rd_errors,
-					num_ldrv*sizeof(u32)) )
-			return -EFAULT;
-
-		if( copy_to_user(ustats->wr_errors, adapter->wr_errors,
-					num_ldrv*sizeof(u32)) )
-			return -EFAULT;
-
-		return 0;
-
-#endif
-	case MBOX_CMD:
-
-		/*
-		 * Which adapter
-		 */
-		if( (adapno = GETADAP(uioc.adapno)) >= hba_count )
-			return (-ENODEV);
-
-		adapter = hba_soft_state[adapno];
-
-		/*
-		 * Deletion of logical drive is a special case. The adapter
-		 * should be quiescent before this command is issued.
-		 */
-		if( uioc.uioc_rmbox[0] == FC_DEL_LOGDRV &&
-				uioc.uioc_rmbox[2] == OP_DEL_LOGDRV ) {
-
-			/*
-			 * Do we support this feature
-			 */
-			if( !adapter->support_random_del ) {
-				printk(KERN_WARNING "megaraid: logdrv ");
-				printk("delete on non-supporting F/W.\n");
-
-				return (-EINVAL);
-			}
-
-			rval = mega_del_logdrv( adapter, uioc.uioc_rmbox[3] );
-
-			if( rval == 0 ) {
-				memset(&mc, 0, sizeof(megacmd_t));
-
-				mc.status = rval;
-
-				rval = mega_n_to_m((void *)arg, &mc);
-			}
-
-			return rval;
-		}
-		/*
-		 * This interface only support the regular passthru commands.
-		 * Reject extended passthru and 64-bit passthru
-		 */
-		if( uioc.uioc_rmbox[0] == MEGA_MBOXCMD_PASSTHRU64 ||
-			uioc.uioc_rmbox[0] == MEGA_MBOXCMD_EXTPTHRU ) {
-
-			printk(KERN_WARNING "megaraid: rejected passthru.\n");
-
-			return (-EINVAL);
-		}
-
-		/*
-		 * For all internal commands, the buffer must be allocated in
-		 * <4GB address range
-		 */
-		if( make_local_pdev(adapter, &pdev) != 0 )
-			return -EIO;
-
-		/* Is it a passthru command or a DCMD */
-		if( uioc.uioc_rmbox[0] == MEGA_MBOXCMD_PASSTHRU ) {
-			/* Passthru commands */
-
-			pthru = pci_alloc_consistent(pdev,
-					sizeof(mega_passthru),
-					&pthru_dma_hndl);
-
-			if( pthru == NULL ) {
-				free_local_pdev(pdev);
-				return (-ENOMEM);
-			}
-
-			/*
-			 * The user passthru structure
-			 */
-			upthru = (mega_passthru *)MBOX(uioc)->xferaddr;
-
-			/*
-			 * Copy in the user passthru here.
-			 */
-			if( copy_from_user(pthru, (char *)upthru,
-						sizeof(mega_passthru)) ) {
-
-				pci_free_consistent(pdev,
-						sizeof(mega_passthru), pthru,
-						pthru_dma_hndl);
-
-				free_local_pdev(pdev);
-
-				return (-EFAULT);
-			}
-
-			/*
-			 * Is there a data transfer
-			 */
-			if( pthru->dataxferlen ) {
-				data = pci_alloc_consistent(pdev,
-						pthru->dataxferlen,
-						&data_dma_hndl);
-
-				if( data == NULL ) {
-					pci_free_consistent(pdev,
-							sizeof(mega_passthru),
-							pthru,
-							pthru_dma_hndl);
-
-					free_local_pdev(pdev);
-
-					return (-ENOMEM);
-				}
-
-				/*
-				 * Save the user address and point the kernel
-				 * address at just allocated memory
-				 */
-				uxferaddr = pthru->dataxferaddr;
-				pthru->dataxferaddr = data_dma_hndl;
-			}
-
-
-			/*
-			 * Is data coming down-stream
-			 */
-			if( pthru->dataxferlen && (uioc.flags & UIOC_WR) ) {
-				/*
-				 * Get the user data
-				 */
-				if( copy_from_user(data, (char *)uxferaddr,
-							pthru->dataxferlen) ) {
-					rval = (-EFAULT);
-					goto freemem_and_return;
-				}
-			}
-
-			memset(&mc, 0, sizeof(megacmd_t));
-
-			mc.cmd = MEGA_MBOXCMD_PASSTHRU;
-			mc.xferaddr = (u32)pthru_dma_hndl;
-
-			/*
-			 * Issue the command
-			 */
-			mega_internal_command(adapter, LOCK_INT, &mc, pthru);
-
-			rval = mega_n_to_m((void *)arg, &mc);
-
-			if( rval ) goto freemem_and_return;
-
-
-			/*
-			 * Is data going up-stream
-			 */
-			if( pthru->dataxferlen && (uioc.flags & UIOC_RD) ) {
-				if( copy_to_user((char *)uxferaddr, data,
-							pthru->dataxferlen) ) {
-					rval = (-EFAULT);
-				}
-			}
-
-			/*
-			 * Send the request sense data also, irrespective of
-			 * whether the user has asked for it or not.
-			 */
-			copy_to_user(upthru->reqsensearea,
-					pthru->reqsensearea, 14);
-
-freemem_and_return:
-			if( pthru->dataxferlen ) {
-				pci_free_consistent(pdev,
-						pthru->dataxferlen, data,
-						data_dma_hndl);
-			}
-
-			pci_free_consistent(pdev, sizeof(mega_passthru),
-					pthru, pthru_dma_hndl);
-
-			free_local_pdev(pdev);
-
-			return rval;
-		}
-		else {
-			/* DCMD commands */
-
-			/*
-			 * Is there a data transfer
-			 */
-			if( uioc.xferlen ) {
-				data = pci_alloc_consistent(pdev,
-						uioc.xferlen, &data_dma_hndl);
-
-				if( data == NULL ) {
-					free_local_pdev(pdev);
-					return (-ENOMEM);
-				}
-
-				uxferaddr = MBOX(uioc)->xferaddr;
-			}
-
-			/*
-			 * Is data coming down-stream
-			 */
-			if( uioc.xferlen && (uioc.flags & UIOC_WR) ) {
-				/*
-				 * Get the user data
-				 */
-				if( copy_from_user(data, (char *)uxferaddr,
-							uioc.xferlen) ) {
-
-					pci_free_consistent(pdev,
-							uioc.xferlen,
-							data, data_dma_hndl);
-
-					free_local_pdev(pdev);
-
-					return (-EFAULT);
-				}
-			}
-
-			memcpy(&mc, MBOX(uioc), sizeof(megacmd_t));
-
-			mc.xferaddr = (u32)data_dma_hndl;
-
-			/*
-			 * Issue the command
-			 */
-			mega_internal_command(adapter, LOCK_INT, &mc, NULL);
-
-			rval = mega_n_to_m((void *)arg, &mc);
-
-			if( rval ) {
-				if( uioc.xferlen ) {
-					pci_free_consistent(pdev,
-							uioc.xferlen, data,
-							data_dma_hndl);
-				}
-
-				free_local_pdev(pdev);
-
-				return rval;
-			}
-
-			/*
-			 * Is data going up-stream
-			 */
-			if( uioc.xferlen && (uioc.flags & UIOC_RD) ) {
-				if( copy_to_user((char *)uxferaddr, data,
-							uioc.xferlen) ) {
-
-					rval = (-EFAULT);
-				}
-			}
-
-			if( uioc.xferlen ) {
-				pci_free_consistent(pdev,
-						uioc.xferlen, data,
-						data_dma_hndl);
-			}
-
-			free_local_pdev(pdev);
-
-			return rval;
-		}
-
-	default:
-		return (-EINVAL);
-	}
-
-	return 0;
-}
-
-/**
- * mega_m_to_n()
- * @arg - user address
- * @uioc - new ioctl structure
- *
- * A thin layer to convert older mimd interface ioctl structure to NIT ioctl
- * structure
- *
- * Converts the older mimd ioctl structure to newer NIT structure
- */
-static int
-mega_m_to_n(void *arg, nitioctl_t *uioc)
-{
-	struct uioctl_t	uioc_mimd;
-	char	signature[8] = {0};
-	u8	opcode;
-	u8	subopcode;
-
-
-	/*
-	 * check is the application conforms to NIT. We do not have to do much
-	 * in that case.
-	 * We exploit the fact that the signature is stored in the very
-	 * begining of the structure.
-	 */
-
-	if( copy_from_user(signature, (char *)arg, 7) )
-		return (-EFAULT);
-
-	if( memcmp(signature, "MEGANIT", 7) == 0 ) {
-
-		/*
-		 * NOTE NOTE: The nit ioctl is still under flux because of
-		 * change of mailbox definition, in HPE. No applications yet
-		 * use this interface and let's not have applications use this
-		 * interface till the new specifitions are in place.
-		 */
-		return -EINVAL;
-#if 0
-		if( copy_from_user(uioc, (char *)arg, sizeof(nitioctl_t)) )
-			return (-EFAULT);
-		return 0;
-#endif
-	}
-
-	/*
-	 * Else assume we have mimd uioctl_t as arg. Convert to nitioctl_t
-	 *
-	 * Get the user ioctl structure
-	 */
-	if( copy_from_user(&uioc_mimd, (char *)arg, sizeof(struct uioctl_t)) )
-		return (-EFAULT);
-
-
-	/*
-	 * Get the opcode and subopcode for the commands
-	 */
-	opcode = uioc_mimd.ui.fcs.opcode;
-	subopcode = uioc_mimd.ui.fcs.subopcode;
-
-	switch (opcode) {
-	case 0x82:
-
-		switch (subopcode) {
-
-		case MEGAIOC_QDRVRVER:	/* Query driver version */
-			uioc->opcode = GET_DRIVER_VER;
-			uioc->uioc_uaddr = uioc_mimd.data;
-			break;
-
-		case MEGAIOC_QNADAP:	/* Get # of adapters */
-			uioc->opcode = GET_N_ADAP;
-			uioc->uioc_uaddr = uioc_mimd.data;
-			break;
-
-		case MEGAIOC_QADAPINFO:	/* Get adapter information */
-			uioc->opcode = GET_ADAP_INFO;
-			uioc->adapno = uioc_mimd.ui.fcs.adapno;
-			uioc->uioc_uaddr = uioc_mimd.data;
-			break;
-
-		default:
-			return(-EINVAL);
-		}
-
-		break;
-
-
-	case 0x81:
-
-		uioc->opcode = MBOX_CMD;
-		uioc->adapno = uioc_mimd.ui.fcs.adapno;
-
-		memcpy(uioc->uioc_rmbox, uioc_mimd.mbox, 18);
-
-		uioc->xferlen = uioc_mimd.ui.fcs.length;
-
-		if( uioc_mimd.outlen ) uioc->flags = UIOC_RD;
-		if( uioc_mimd.inlen ) uioc->flags |= UIOC_WR;
-
-		break;
-
-	case 0x80:
-
-		uioc->opcode = MBOX_CMD;
-		uioc->adapno = uioc_mimd.ui.fcs.adapno;
-
-		memcpy(uioc->uioc_rmbox, uioc_mimd.mbox, 18);
-
-		/*
-		 * Choose the xferlen bigger of input and output data
-		 */
-		uioc->xferlen = uioc_mimd.outlen > uioc_mimd.inlen ?
-			uioc_mimd.outlen : uioc_mimd.inlen;
-
-		if( uioc_mimd.outlen ) uioc->flags = UIOC_RD;
-		if( uioc_mimd.inlen ) uioc->flags |= UIOC_WR;
-
-		break;
-
-	default:
-		return (-EINVAL);
-
-	}
-
-	return 0;
-}
-
-/*
- * mega_n_to_m()
- * @arg - user address
- * @mc - mailbox command
- *
- * Updates the status information to the application, depending on application
- * conforms to older mimd ioctl interface or newer NIT ioctl interface
- */
-static int
-mega_n_to_m(void *arg, megacmd_t *mc)
-{
-	nitioctl_t	*uiocp;
-	megacmd_t	*umc;
-	mega_passthru	*upthru;
-	struct uioctl_t	*uioc_mimd;
-	char	signature[8] = {0};
-
-	/*
-	 * check is the application conforms to NIT.
-	 */
-	if( copy_from_user(signature, (char *)arg, 7) )
-		return -EFAULT;
-
-	if( memcmp(signature, "MEGANIT", 7) == 0 ) {
-
-		uiocp = (nitioctl_t *)arg;
-
-		if( put_user(mc->status, (u8 *)&MBOX_P(uiocp)->status) )
-			return (-EFAULT);
-
-		if( mc->cmd == MEGA_MBOXCMD_PASSTHRU ) {
-
-			umc = MBOX_P(uiocp);
-
-			upthru = (mega_passthru *)umc->xferaddr;
-
-			if( put_user(mc->status, (u8 *)&upthru->scsistatus) )
-				return (-EFAULT);
-		}
-	}
-	else {
-		uioc_mimd = (struct uioctl_t *)arg;
-
-		if( put_user(mc->status, (u8 *)&uioc_mimd->mbox[17]) )
-			return (-EFAULT);
-
-		if( mc->cmd == MEGA_MBOXCMD_PASSTHRU ) {
-
-			umc = (megacmd_t *)uioc_mimd->mbox;
-
-			upthru = (mega_passthru *)umc->xferaddr;
-
-			if( put_user(mc->status, (u8 *)&upthru->scsistatus) )
-				return (-EFAULT);
-		}
-	}
-
-	return 0;
-}
-
-
-/*
- * MEGARAID 'FW' commands.
- */
-
-/**
- * mega_is_bios_enabled()
- * @adapter - pointer to our soft state
- *
- * issue command to find out if the BIOS is enabled for this controller
- */
-static int
-mega_is_bios_enabled(adapter_t *adapter)
-{
-	unsigned char	raw_mbox[sizeof(struct mbox_out)];
-	mbox_t	*mbox;
-	int	ret;
-
-	mbox = (mbox_t *)raw_mbox;
-
-	memset(&mbox->m_out, 0, sizeof(raw_mbox));
-
-	memset((void *)adapter->mega_buffer, 0, MEGA_BUFFER_SIZE);
-
-	mbox->m_out.xferaddr = (u32)adapter->buf_dma_handle;
-
-	raw_mbox[0] = IS_BIOS_ENABLED;
-	raw_mbox[2] = GET_BIOS;
-
-
-	ret = issue_scb_block(adapter, raw_mbox);
-
-	return *(char *)adapter->mega_buffer;
-}
-
-
-/**
- * mega_enum_raid_scsi()
- * @adapter - pointer to our soft state
- *
- * Find out what channels are RAID/SCSI. This information is used to
- * differentiate the virtual channels and physical channels and to support
- * ROMB feature and non-disk devices.
- */
-static void
-mega_enum_raid_scsi(adapter_t *adapter)
-{
-	unsigned char raw_mbox[sizeof(struct mbox_out)];
-	mbox_t *mbox;
-	int i;
-
-	mbox = (mbox_t *)raw_mbox;
-
-	memset(&mbox->m_out, 0, sizeof(raw_mbox));
-
-	/*
-	 * issue command to find out what channels are raid/scsi
-	 */
-	raw_mbox[0] = CHNL_CLASS;
-	raw_mbox[2] = GET_CHNL_CLASS;
-
-	memset((void *)adapter->mega_buffer, 0, MEGA_BUFFER_SIZE);
-
-	mbox->m_out.xferaddr = (u32)adapter->buf_dma_handle;
-
-	/*
-	 * Non-ROMB firware fail this command, so all channels
-	 * must be shown RAID
-	 */
-	adapter->mega_ch_class = 0xFF;
-
-	if(!issue_scb_block(adapter, raw_mbox)) {
-		adapter->mega_ch_class = *((char *)adapter->mega_buffer);
-
-	}
-
-	for( i = 0; i < adapter->product_info.nchannels; i++ ) { 
-		if( (adapter->mega_ch_class >> i) & 0x01 ) {
-			printk(KERN_INFO "megaraid: channel[%d] is raid.\n",
-					i);
-		}
-		else {
-			printk(KERN_INFO "megaraid: channel[%d] is scsi.\n",
-					i);
-		}
-	}
-
-	return;
-}
-
-
-/**
- * mega_get_boot_drv()
- * @adapter - pointer to our soft state
- *
- * Find out which device is the boot device. Note, any logical drive or any
- * phyical device (e.g., a CDROM) can be designated as a boot device.
- */
-static void
-mega_get_boot_drv(adapter_t *adapter)
-{
-	struct private_bios_data	*prv_bios_data;
-	unsigned char	raw_mbox[sizeof(struct mbox_out)];
-	mbox_t	*mbox;
-	u16	cksum = 0;
-	u8	*cksum_p;
-	u8	boot_pdrv;
-	int	i;
-
-	mbox = (mbox_t *)raw_mbox;
-
-	memset(&mbox->m_out, 0, sizeof(raw_mbox));
-
-	raw_mbox[0] = BIOS_PVT_DATA;
-	raw_mbox[2] = GET_BIOS_PVT_DATA;
-
-	memset((void *)adapter->mega_buffer, 0, MEGA_BUFFER_SIZE);
-
-	mbox->m_out.xferaddr = (u32)adapter->buf_dma_handle;
-
-	adapter->boot_ldrv_enabled = 0;
-	adapter->boot_ldrv = 0;
-
-	adapter->boot_pdrv_enabled = 0;
-	adapter->boot_pdrv_ch = 0;
-	adapter->boot_pdrv_tgt = 0;
-
-	if(issue_scb_block(adapter, raw_mbox) == 0) {
-		prv_bios_data =
-			(struct private_bios_data *)adapter->mega_buffer;
-
-		cksum = 0;
-		cksum_p = (char *)prv_bios_data;
-		for (i = 0; i < 14; i++ ) {
-			cksum += (u16)(*cksum_p++);
-		}
-
-		if (prv_bios_data->cksum == (u16)(0-cksum) ) {
-
-			/*
-			 * If MSB is set, a physical drive is set as boot
-			 * device
-			 */
-			if( prv_bios_data->boot_drv & 0x80 ) {
-				adapter->boot_pdrv_enabled = 1;
-				boot_pdrv = prv_bios_data->boot_drv & 0x7F;
-				adapter->boot_pdrv_ch = boot_pdrv / 16;
-				adapter->boot_pdrv_tgt = boot_pdrv % 16;
-			}
-			else {
-				adapter->boot_ldrv_enabled = 1;
-				adapter->boot_ldrv = prv_bios_data->boot_drv;
-			}
-		}
-	}
-
-}
-
-/**
- * mega_support_random_del()
- * @adapter - pointer to our soft state
- *
- * Find out if this controller supports random deletion and addition of
- * logical drives
- */
-static int
-mega_support_random_del(adapter_t *adapter)
-{
-	unsigned char raw_mbox[sizeof(struct mbox_out)];
-	mbox_t *mbox;
-	int rval;
-
-	mbox = (mbox_t *)raw_mbox;
-
-	memset(&mbox->m_out, 0, sizeof(raw_mbox));
-
-	/*
-	 * issue command
-	 */
-	raw_mbox[0] = FC_DEL_LOGDRV;
-	raw_mbox[2] = OP_SUP_DEL_LOGDRV;
-
-	rval = issue_scb_block(adapter, raw_mbox);
-
-	return !rval;
-}
-
-
-/**
- * mega_support_ext_cdb()
- * @adapter - pointer to our soft state
- *
- * Find out if this firmware support cdblen > 10
- */
-static int
-mega_support_ext_cdb(adapter_t *adapter)
-{
-	unsigned char raw_mbox[sizeof(struct mbox_out)];
-	mbox_t *mbox;
-	int rval;
-
-	mbox = (mbox_t *)raw_mbox;
-
-	memset(&mbox->m_out, 0, sizeof(raw_mbox));
-	/*
-	 * issue command to find out if controller supports extended CDBs.
-	 */
-	raw_mbox[0] = 0xA4;
-	raw_mbox[2] = 0x16;
-
-	rval = issue_scb_block(adapter, raw_mbox);
-
-	return !rval;
-}
-
-
-/**
- * mega_del_logdrv()
- * @adapter - pointer to our soft state
- * @logdrv - logical drive to be deleted
- *
- * Delete the specified logical drive. It is the responsibility of the user
- * app to let the OS know about this operation.
- */
-static int
-mega_del_logdrv(adapter_t *adapter, int logdrv)
-{
-	DECLARE_WAIT_QUEUE_HEAD(wq);
-	unsigned long flags;
-	scb_t *scb;
-	int rval;
-
-	/*
-	 * Stop sending commands to the controller, queue them internally.
-	 * When deletion is complete, ISR will flush the queue.
-	 */
-	atomic_set(&adapter->quiescent, 1);
-
-	/*
-	 * Wait till all the issued commands are complete and there are no
-	 * commands in the pending queue
-	 */
-	while( atomic_read(&adapter->pend_cmds) > 0 ||
-			!list_empty(&adapter->pending_list) ) {
-
-		sleep_on_timeout( &wq, 1*HZ );	/* sleep for 1s */
-	}
-
-	rval = mega_do_del_logdrv(adapter, logdrv);
-
-	spin_lock_irqsave(&adapter->lock, flags);
-
-	/*
-	 * If delete operation was successful, add 0x80 to the logical drive
-	 * ids for commands in the pending queue.
-	 */
-	if (adapter->read_ldidmap) {
-		struct list_head *pos;
-		list_for_each(pos, &adapter->pending_list) {
-			scb = list_entry(pos, scb_t, list);
-			if (scb->pthru->logdrv < 0x80 )
-				scb->pthru->logdrv += 0x80;
-		}
-	}
-
-	atomic_set(&adapter->quiescent, 0);
-
-	mega_runpendq(adapter);
-
-	spin_unlock_irqrestore(&adapter->lock, flags);
-
-	return rval;
-}
-
-
-static int
-mega_do_del_logdrv(adapter_t *adapter, int logdrv)
-{
-	megacmd_t	mc;
-	int	rval;
-
-	memset( &mc, 0, sizeof(megacmd_t));
-
-	mc.cmd = FC_DEL_LOGDRV;
-	mc.opcode = OP_DEL_LOGDRV;
-	mc.subopcode = logdrv;
-
-	rval = mega_internal_command(adapter, LOCK_INT, &mc, NULL);
-
-	/* log this event */
-	if(rval) {
-		printk(KERN_WARNING "megaraid: Delete LD-%d failed.", logdrv);
-		return rval;
-	}
-
-	/*
-	 * After deleting first logical drive, the logical drives must be
-	 * addressed by adding 0x80 to the logical drive id.
-	 */
-	adapter->read_ldidmap = 1;
-
-	return rval;
-}
-
-
-/**
- * mega_get_max_sgl()
- * @adapter - pointer to our soft state
- *
- * Find out the maximum number of scatter-gather elements supported by this
- * version of the firmware
- */
-static void
-mega_get_max_sgl(adapter_t *adapter)
-{
-	unsigned char	raw_mbox[sizeof(struct mbox_out)];
-	mbox_t	*mbox;
-
-	mbox = (mbox_t *)raw_mbox;
-
-	memset(mbox, 0, sizeof(raw_mbox));
-
-	memset((void *)adapter->mega_buffer, 0, MEGA_BUFFER_SIZE);
-
-	mbox->m_out.xferaddr = (u32)adapter->buf_dma_handle;
-
-	raw_mbox[0] = MAIN_MISC_OPCODE;
-	raw_mbox[2] = GET_MAX_SG_SUPPORT;
-
-
-	if( issue_scb_block(adapter, raw_mbox) ) {
-		/*
-		 * f/w does not support this command. Choose the default value
-		 */
-		adapter->sglen = MIN_SGLIST;
-	}
-	else {
-		adapter->sglen = *((char *)adapter->mega_buffer);
-		
-		/*
-		 * Make sure this is not more than the resources we are
-		 * planning to allocate
-		 */
-		if ( adapter->sglen > MAX_SGLIST )
-			adapter->sglen = MAX_SGLIST;
-	}
-
-	return;
-}
-
-
-/**
- * mega_support_cluster()
- * @adapter - pointer to our soft state
- *
- * Find out if this firmware support cluster calls.
- */
-static int
-mega_support_cluster(adapter_t *adapter)
-{
-	unsigned char	raw_mbox[sizeof(struct mbox_out)];
-	mbox_t	*mbox;
-
-	mbox = (mbox_t *)raw_mbox;
-
-	memset(mbox, 0, sizeof(raw_mbox));
-
-	memset((void *)adapter->mega_buffer, 0, MEGA_BUFFER_SIZE);
-
-	mbox->m_out.xferaddr = (u32)adapter->buf_dma_handle;
-
-	/*
-	 * Try to get the initiator id. This command will succeed iff the
-	 * clustering is available on this HBA.
-	 */
-	raw_mbox[0] = MEGA_GET_TARGET_ID;
-
-	if( issue_scb_block(adapter, raw_mbox) == 0 ) {
-
-		/*
-		 * Cluster support available. Get the initiator target id.
-		 * Tell our id to mid-layer too.
-		 */
-		adapter->this_id = *(u32 *)adapter->mega_buffer;
-		adapter->host->this_id = adapter->this_id;
-
-		return 1;
-	}
-
-	return 0;
-}
-
-
-
-/**
- * mega_get_ldrv_num()
- * @adapter - pointer to our soft state
- * @cmd - scsi mid layer command
- * @channel - channel on the controller
- *
- * Calculate the logical drive number based on the information in scsi command
- * and the channel number.
- */
-static inline int
-mega_get_ldrv_num(adapter_t *adapter, Scsi_Cmnd *cmd, int channel)
-{
-	int		tgt;
-	int		ldrv_num;
-
-	tgt = cmd->device->id;
-	
-	if ( tgt > adapter->this_id )
-		tgt--;	/* we do not get inquires for initiator id */
-
-	ldrv_num = (channel * 15) + tgt;
-
-
-	/*
-	 * If we have a logical drive with boot enabled, project it first
-	 */
-	if( adapter->boot_ldrv_enabled ) {
-		if( ldrv_num == 0 ) {
-			ldrv_num = adapter->boot_ldrv;
-		}
-		else {
-			if( ldrv_num <= adapter->boot_ldrv ) {
-				ldrv_num--;
-			}
-		}
-	}
-
-	/*
-	 * If "delete logical drive" feature is enabled on this controller.
-	 * Do only if at least one delete logical drive operation was done.
-	 *
-	 * Also, after logical drive deletion, instead of logical drive number,
-	 * the value returned should be 0x80+logical drive id.
-	 *
-	 * These is valid only for IO commands.
-	 */
-
-	if (adapter->support_random_del && adapter->read_ldidmap )
-		switch (cmd->cmnd[0]) {
-		case READ_6:	/* fall through */
-		case WRITE_6:	/* fall through */
-		case READ_10:	/* fall through */
-		case WRITE_10:
-			ldrv_num += 0x80;
-		}
-
-	return ldrv_num;
-}
-
-
-/**
- * mega_adapinq()
- * @adapter - pointer to our soft state
- * @dma_handle - DMA address of the buffer
- *
- * Issue internal comamnds while interrupts are available.
- * We only issue direct mailbox commands from within the driver. ioctl()
- * interface using these routines can issue passthru commands.
- */
-static int
-mega_adapinq(adapter_t *adapter, dma_addr_t dma_handle)
-{
-	megacmd_t	mc;
-
-	memset(&mc, 0, sizeof(megacmd_t));
-
-	if( adapter->flag & BOARD_40LD ) {
-		mc.cmd = FC_NEW_CONFIG;
-		mc.opcode = NC_SUBOP_ENQUIRY3;
-		mc.subopcode = ENQ3_GET_SOLICITED_FULL;
-	}
-	else {
-		mc.cmd = MEGA_MBOXCMD_ADPEXTINQ;
-	}
-
-	mc.xferaddr = (u32)dma_handle;
-
-	if ( mega_internal_command(adapter, LOCK_INT, &mc, NULL) != 0 ) {
-		return -1;
-	}
-
-	return 0;
-}
-
-
-/**
- * mega_allocate_inquiry()
- * @dma_handle - handle returned for dma address
- * @pdev - handle to pci device
- *
- * allocates memory for inquiry structure
- */
-static inline caddr_t
-mega_allocate_inquiry(dma_addr_t *dma_handle, struct pci_dev *pdev)
-{
-	return pci_alloc_consistent(pdev, sizeof(mega_inquiry3), dma_handle);
-}
-
-
-static inline void
-mega_free_inquiry(caddr_t inquiry, dma_addr_t dma_handle, struct pci_dev *pdev)
-{
-	pci_free_consistent(pdev, sizeof(mega_inquiry3), inquiry, dma_handle);
-}
-
-
-/** mega_internal_dev_inquiry()
- * @adapter - pointer to our soft state
- * @ch - channel for this device
- * @tgt - ID of this device
- * @buf_dma_handle - DMA address of the buffer
- *
- * Issue the scsi inquiry for the specified device.
- */
-static int
-mega_internal_dev_inquiry(adapter_t *adapter, u8 ch, u8 tgt,
-		dma_addr_t buf_dma_handle)
-{
-	mega_passthru	*pthru;
-	dma_addr_t	pthru_dma_handle;
-	megacmd_t	mc;
-	int		rval;
-	struct pci_dev	*pdev;
-
-
-	/*
-	 * For all internal commands, the buffer must be allocated in <4GB
-	 * address range
-	 */
-	if( make_local_pdev(adapter, &pdev) != 0 ) return -1;
-
-	pthru = pci_alloc_consistent(pdev, sizeof(mega_passthru),
-			&pthru_dma_handle);
-
-	if( pthru == NULL ) {
-		free_local_pdev(pdev);
-		return -1;
-	}
-
-	pthru->timeout = 2;
-	pthru->ars = 1;
-	pthru->reqsenselen = 14;
-	pthru->islogical = 0;
-
-	pthru->channel = (adapter->flag & BOARD_40LD) ? 0 : ch;
-
-	pthru->target = (adapter->flag & BOARD_40LD) ? (ch << 4)|tgt : tgt;
-
-	pthru->cdblen = 6;
-
-	pthru->cdb[0] = INQUIRY;
-	pthru->cdb[1] = 0;
-	pthru->cdb[2] = 0;
-	pthru->cdb[3] = 0;
-	pthru->cdb[4] = 255;
-	pthru->cdb[5] = 0;
-
-
-	pthru->dataxferaddr = (u32)buf_dma_handle;
-	pthru->dataxferlen = 256;
-
-	memset(&mc, 0, sizeof(megacmd_t));
-
-	mc.cmd = MEGA_MBOXCMD_PASSTHRU;
-	mc.xferaddr = (u32)pthru_dma_handle;
-
-	rval = mega_internal_command(adapter, LOCK_INT, &mc, pthru);
-
-	pci_free_consistent(pdev, sizeof(mega_passthru), pthru,
-			pthru_dma_handle);
-
-	free_local_pdev(pdev);
-
-	return rval;
-}
-
-
-/**
- * mega_internal_command()
- * @adapter - pointer to our soft state
- * @ls - the scope of the exclusion lock.
- * @mc - the mailbox command
- * @pthru - Passthru structure for DCDB commands
- *
- * Issue the internal commands in interrupt mode.
- * The last argument is the address of the passthru structure if the command
- * to be fired is a passthru command
- *
- * lockscope specifies whether the caller has already acquired the lock. Of
- * course, the caller must know which lock we are talking about.
- *
- * Note: parameter 'pthru' is null for non-passthru commands.
- */
-static int
-mega_internal_command(adapter_t *adapter, lockscope_t ls, megacmd_t *mc,
-		mega_passthru *pthru )
-{
-	Scsi_Cmnd	*scmd;
-	struct	scsi_device *sdev;
-	unsigned long	flags = 0;
-	scb_t	*scb;
-	int	rval;
-
-	/*
-	 * The internal commands share one command id and hence are
-	 * serialized. This is so because we want to reserve maximum number of
-	 * available command ids for the I/O commands.
-	 */
-	down(&adapter->int_mtx);
-
-	scb = &adapter->int_scb;
-	memset(scb, 0, sizeof(scb_t));
-
-	scmd = &adapter->int_scmd;
-	memset(scmd, 0, sizeof(Scsi_Cmnd));
-
-	sdev = kmalloc(sizeof(struct scsi_device), GFP_KERNEL);
-	memset(sdev, 0, sizeof(struct scsi_device));
-	scmd->device = sdev;
-
-	scmd->device->host = adapter->host;
-	scmd->buffer = (void *)scb;
-	scmd->cmnd[0] = MEGA_INTERNAL_CMD;
-
-	scb->state |= SCB_ACTIVE;
-	scb->cmd = scmd;
-
-	memcpy(scb->raw_mbox, mc, sizeof(megacmd_t));
-
-	/*
-	 * Is it a passthru command
-	 */
-	if( mc->cmd == MEGA_MBOXCMD_PASSTHRU ) {
-
-		scb->pthru = pthru;
-	}
-
-	scb->idx = CMDID_INT_CMDS;
-
-	scmd->state = 0;
-
-	/*
-	 * Get the lock only if the caller has not acquired it already
-	 */
-	if( ls == LOCK_INT ) spin_lock_irqsave(&adapter->lock, flags);
-
-	megaraid_queue(scmd, mega_internal_done);
-
-	if( ls == LOCK_INT ) spin_unlock_irqrestore(&adapter->lock, flags);
-
-	/*
-	 * Wait till this command finishes. Do not use
-	 * wait_event_interruptible(). It causes panic if CTRL-C is hit when
-	 * dumping e.g., physical disk information through /proc interface.
-	 */
-#if 0
-	wait_event_interruptible(adapter->int_waitq, scmd->state);
-#endif
-	wait_event(adapter->int_waitq, scmd->state);
-
-	rval = scmd->result;
-	mc->status = scmd->result;
-	kfree(sdev);
-
-	/*
-	 * Print a debug message for all failed commands. Applications can use
-	 * this information.
-	 */
-	if( scmd->result && trace_level ) {
-		printk("megaraid: cmd [%x, %x, %x] status:[%x]\n",
-			mc->cmd, mc->opcode, mc->subopcode, scmd->result);
-	}
-
-	up(&adapter->int_mtx);
-
-	return rval;
-}
-
-
-/**
- * mega_internal_done()
- * @scmd - internal scsi command
- *
- * Callback routine for internal commands.
- */
-static void
-mega_internal_done(Scsi_Cmnd *scmd)
-{
-	adapter_t	*adapter;
-
-	adapter = (adapter_t *)scmd->device->host->hostdata;
-
-	scmd->state = 1; /* thread waiting for its command to complete */
-
-	/*
-	 * See comment in mega_internal_command() routine for
-	 * wait_event_interruptible()
-	 */
-#if 0
-	wake_up_interruptible(&adapter->int_waitq);
-#endif
-	wake_up(&adapter->int_waitq);
-
-}
-
-
-static inline int
-make_local_pdev(adapter_t *adapter, struct pci_dev **pdev)
-{
-	*pdev = kmalloc(sizeof(struct pci_dev), GFP_KERNEL);
-
-	if( *pdev == NULL ) return -1;
-
-	memcpy(*pdev, adapter->dev, sizeof(struct pci_dev));
-
-	if( pci_set_dma_mask(*pdev, 0xffffffff) != 0 ) {
-		kfree(*pdev);
-		return -1;
-	}
-
-	return 0;
-}
-
-static inline void
-free_local_pdev(struct pci_dev *pdev)
-{
-	kfree(pdev);
-}
-
-static struct scsi_host_template megaraid_template = {
-	.module				= THIS_MODULE,
-	.name				= "MegaRAID",
-	.proc_name			= "megaraid",
-	.info				= megaraid_info,
-	.queuecommand			= megaraid_queue,	
-	.bios_param			= megaraid_biosparam,
-	.max_sectors			= MAX_SECTORS_PER_IO,
-	.can_queue			= MAX_COMMANDS,
-	.this_id			= DEFAULT_INITIATOR_ID,
-	.sg_tablesize			= MAX_SGLIST,
-	.cmd_per_lun			= DEF_CMD_PER_LUN,
-	.use_clustering			= ENABLE_CLUSTERING,
-	.eh_abort_handler		= megaraid_abort,
-	.eh_device_reset_handler	= megaraid_reset,
-	.eh_bus_reset_handler		= megaraid_reset,
-	.eh_host_reset_handler		= megaraid_reset,
-};
-
-static int __devinit
-megaraid_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
-{
-	struct Scsi_Host *host;
-	adapter_t *adapter;
-	unsigned long mega_baseport, tbase, flag = 0;
-	u16 subsysid, subsysvid;
-	u8 pci_bus, pci_dev_func;
-	int irq, i, j;
-	int error = -ENODEV;
-
-	if (pci_enable_device(pdev))
-		goto out;
-
-	pci_bus = pdev->bus->number;
-	pci_dev_func = pdev->devfn;
-
-	/*
-	 * For these vendor and device ids, signature offsets are not
-	 * valid and 64 bit is implicit
-	 */
-	if (id->driver_data & BOARD_64BIT)
-		flag |= BOARD_64BIT;
-	else {
-		u32 magic64;
-
-		pci_read_config_dword(pdev, PCI_CONF_AMISIG64, &magic64);
-		if (magic64 == HBA_SIGNATURE_64BIT)
-			flag |= BOARD_64BIT;
-	}
-
-	subsysvid = pdev->subsystem_vendor;
-	subsysid = pdev->subsystem_device;
-
-	printk(KERN_NOTICE "megaraid: found 0x%4.04x:0x%4.04x:bus %d:",
-		id->vendor, id->device, pci_bus);
-
-	printk("slot %d:func %d\n",
-		PCI_SLOT(pci_dev_func), PCI_FUNC(pci_dev_func));
-
-	/* Read the base port and IRQ from PCI */
-	mega_baseport = pci_resource_start(pdev, 0);
-	irq = pdev->irq;
-
-	tbase = mega_baseport;
-	if (pci_resource_flags(pdev, 0) & IORESOURCE_MEM) {
-		flag |= BOARD_MEMMAP;
-
-		if (!request_mem_region(mega_baseport, 128, "megaraid")) {
-			printk(KERN_WARNING "megaraid: mem region busy!\n");
-			goto out_disable_device;
-		}
-
-		mega_baseport = (unsigned long)ioremap(mega_baseport, 128);
-		if (!mega_baseport) {
-			printk(KERN_WARNING
-			       "megaraid: could not map hba memory\n");
-			goto out_release_region;
-		}
-	} else {
-		flag |= BOARD_IOMAP;
-		mega_baseport += 0x10;
-
-		if (!request_region(mega_baseport, 16, "megaraid"))
-			goto out_disable_device;
-	}
-
-	/* Initialize SCSI Host structure */
-	host = scsi_host_alloc(&megaraid_template, sizeof(adapter_t));
-	if (!host)
-		goto out_iounmap;
-
-	adapter = (adapter_t *)host->hostdata;
-	memset(adapter, 0, sizeof(adapter_t));
-
-	printk(KERN_NOTICE
-		"scsi%d:Found MegaRAID controller at 0x%lx, IRQ:%d\n",
-		host->host_no, mega_baseport, irq);
-
-	adapter->base = mega_baseport;
-
-	INIT_LIST_HEAD(&adapter->free_list);
-	INIT_LIST_HEAD(&adapter->pending_list);
-	INIT_LIST_HEAD(&adapter->completed_list);
-
-	adapter->flag = flag;
-	spin_lock_init(&adapter->lock);
-	scsi_assign_lock(host, &adapter->lock);
-
-	host->cmd_per_lun = max_cmd_per_lun;
-	host->max_sectors = max_sectors_per_io;
-
-	adapter->dev = pdev;
-	adapter->host = host;
-
-	adapter->host->irq = irq;
-
-	if (flag & BOARD_MEMMAP)
-		adapter->host->base = tbase;
-	else {
-		adapter->host->io_port = tbase;
-		adapter->host->n_io_port = 16;
-	}
-
-	adapter->host->unique_id = (pci_bus << 8) | pci_dev_func;
-
-	/*
-	 * Allocate buffer to issue internal commands.
-	 */
-	adapter->mega_buffer = pci_alloc_consistent(adapter->dev,
-		MEGA_BUFFER_SIZE, &adapter->buf_dma_handle);
-	if (!adapter->mega_buffer) {
-		printk(KERN_WARNING "megaraid: out of RAM.\n");
-		goto out_host_put;
-	}
-
-	adapter->scb_list = kmalloc(sizeof(scb_t) * MAX_COMMANDS, GFP_KERNEL);
-	if (!adapter->scb_list) {
-		printk(KERN_WARNING "megaraid: out of RAM.\n");
-		goto out_free_cmd_buffer;
-	}
-
-	if (request_irq(irq, (adapter->flag & BOARD_MEMMAP) ?
-				megaraid_isr_memmapped : megaraid_isr_iomapped,
-					SA_SHIRQ, "megaraid", adapter)) {
-		printk(KERN_WARNING
-			"megaraid: Couldn't register IRQ %d!\n", irq);
-		goto out_free_scb_list;
-	}
-
-	if (mega_setup_mailbox(adapter))
-		goto out_free_irq;
-
-	if (mega_query_adapter(adapter))
-		goto out_free_mbox;
-
-	/*
-	 * Have checks for some buggy f/w
-	 */
-	if ((subsysid == 0x1111) && (subsysvid == 0x1111)) {
-		/*
-		 * Which firmware
-		 */
-		if (!strcmp(adapter->fw_version, "3.00") ||
-				!strcmp(adapter->fw_version, "3.01")) {
-
-			printk( KERN_WARNING
-				"megaraid: Your  card is a Dell PERC "
-				"2/SC RAID controller with  "
-				"firmware\nmegaraid: 3.00 or 3.01.  "
-				"This driver is known to have "
-				"corruption issues\nmegaraid: with "
-				"those firmware versions on this "
-				"specific card.  In order\nmegaraid: "
-				"to protect your data, please upgrade "
-				"your firmware to version\nmegaraid: "
-				"3.10 or later, available from the "
-				"Dell Technical Support web\n"
-				"megaraid: site at\nhttp://support."
-				"dell.com/us/en/filelib/download/"
-				"index.asp?fileid=2940\n"
-			);
-		}
-	}
-
-	/*
-	 * If we have a HP 1M(0x60E7)/2M(0x60E8) controller with
-	 * firmware H.01.07, H.01.08, and H.01.09 disable 64 bit
-	 * support, since this firmware cannot handle 64 bit
-	 * addressing
-	 */
-	if ((subsysvid == HP_SUBSYS_VID) &&
-	    ((subsysid == 0x60E7) || (subsysid == 0x60E8))) {
-		/*
-		 * which firmware
-		 */
-		if (!strcmp(adapter->fw_version, "H01.07") ||
-		    !strcmp(adapter->fw_version, "H01.08") ||
-		    !strcmp(adapter->fw_version, "H01.09") ) {
-			printk(KERN_WARNING
-				"megaraid: Firmware H.01.07, "
-				"H.01.08, and H.01.09 on 1M/2M "
-				"controllers\n"
-				"megaraid: do not support 64 bit "
-				"addressing.\nmegaraid: DISABLING "
-				"64 bit support.\n");
-			adapter->flag &= ~BOARD_64BIT;
-		}
-	}
-
-	if (mega_is_bios_enabled(adapter))
-		mega_hbas[hba_count].is_bios_enabled = 1;
-	mega_hbas[hba_count].hostdata_addr = adapter;
-
-	/*
-	 * Find out which channel is raid and which is scsi. This is
-	 * for ROMB support.
-	 */
-	mega_enum_raid_scsi(adapter);
-
-	/*
-	 * Find out if a logical drive is set as the boot drive. If
-	 * there is one, will make that as the first logical drive.
-	 * ROMB: Do we have to boot from a physical drive. Then all
-	 * the physical drives would appear before the logical disks.
-	 * Else, all the physical drives would be exported to the mid
-	 * layer after logical drives.
-	 */
-	mega_get_boot_drv(adapter);
-
-	if (adapter->boot_pdrv_enabled) {
-		j = adapter->product_info.nchannels;
-		for( i = 0; i < j; i++ )
-			adapter->logdrv_chan[i] = 0;
-		for( i = j; i < NVIRT_CHAN + j; i++ )
-			adapter->logdrv_chan[i] = 1;
-	} else {
-		for (i = 0; i < NVIRT_CHAN; i++)
-			adapter->logdrv_chan[i] = 1;
-		for (i = NVIRT_CHAN; i < MAX_CHANNELS+NVIRT_CHAN; i++)
-			adapter->logdrv_chan[i] = 0;
-		adapter->mega_ch_class <<= NVIRT_CHAN;
-	}
-
-	/*
-	 * Do we support random deletion and addition of logical
-	 * drives
-	 */
-	adapter->read_ldidmap = 0;	/* set it after first logdrv
-						   delete cmd */
-	adapter->support_random_del = mega_support_random_del(adapter);
-
-	/* Initialize SCBs */
-	if (mega_init_scb(adapter))
-		goto out_free_mbox;
-
-	/*
-	 * Reset the pending commands counter
-	 */
-	atomic_set(&adapter->pend_cmds, 0);
-
-	/*
-	 * Reset the adapter quiescent flag
-	 */
-	atomic_set(&adapter->quiescent, 0);
-
-	hba_soft_state[hba_count] = adapter;
-
-	/*
-	 * Fill in the structure which needs to be passed back to the
-	 * application when it does an ioctl() for controller related
-	 * information.
-	 */
-	i = hba_count;
-
-	mcontroller[i].base = mega_baseport;
-	mcontroller[i].irq = irq;
-	mcontroller[i].numldrv = adapter->numldrv;
-	mcontroller[i].pcibus = pci_bus;
-	mcontroller[i].pcidev = id->device;
-	mcontroller[i].pcifun = PCI_FUNC (pci_dev_func);
-	mcontroller[i].pciid = -1;
-	mcontroller[i].pcivendor = id->vendor;
-	mcontroller[i].pcislot = PCI_SLOT(pci_dev_func);
-	mcontroller[i].uid = (pci_bus << 8) | pci_dev_func;
-
-
-	/* Set the Mode of addressing to 64 bit if we can */
-	if ((adapter->flag & BOARD_64BIT) && (sizeof(dma_addr_t) == 8)) {
-		pci_set_dma_mask(pdev, 0xffffffffffffffffULL);
-		adapter->has_64bit_addr = 1;
-	} else  {
-		pci_set_dma_mask(pdev, 0xffffffff);
-		adapter->has_64bit_addr = 0;
-	}
-		
-	init_MUTEX(&adapter->int_mtx);
-	init_waitqueue_head(&adapter->int_waitq);
-
-	adapter->this_id = DEFAULT_INITIATOR_ID;
-	adapter->host->this_id = DEFAULT_INITIATOR_ID;
-
-#if MEGA_HAVE_CLUSTERING
-	/*
-	 * Is cluster support enabled on this controller
-	 * Note: In a cluster the HBAs ( the initiators ) will have
-	 * different target IDs and we cannot assume it to be 7. Call
-	 * to mega_support_cluster() will get the target ids also if
-	 * the cluster support is available
-	 */
-	adapter->has_cluster = mega_support_cluster(adapter);
-	if (adapter->has_cluster) {
-		printk(KERN_NOTICE
-			"megaraid: Cluster driver, initiator id:%d\n",
-			adapter->this_id);
-	}
-#endif
-
-	pci_set_drvdata(pdev, host);
-
-	mega_create_proc_entry(hba_count, mega_proc_dir_entry);
-
-	error = scsi_add_host(host, &pdev->dev);
-	if (error)
-		goto out_free_mbox;
-
-	scsi_scan_host(host);
-	hba_count++;
-	return 0;
-
- out_free_mbox:
-	pci_free_consistent(adapter->dev, sizeof(mbox64_t),
-			adapter->una_mbox64, adapter->una_mbox64_dma);
- out_free_irq:
-	free_irq(adapter->host->irq, adapter);
- out_free_scb_list:
-	kfree(adapter->scb_list);
- out_free_cmd_buffer:
-	pci_free_consistent(adapter->dev, MEGA_BUFFER_SIZE,
-			adapter->mega_buffer, adapter->buf_dma_handle);
- out_host_put:
-	scsi_host_put(host);
- out_iounmap:
-	if (flag & BOARD_MEMMAP)
-		iounmap((void *)mega_baseport);
- out_release_region:
-	if (flag & BOARD_MEMMAP)
-		release_mem_region(tbase, 128);
-	else
-		release_region(mega_baseport, 16);
- out_disable_device:
-	pci_disable_device(pdev);
- out:
-	return error;
-}
-
-static void
-__megaraid_shutdown(adapter_t *adapter)
-{
-	u_char	raw_mbox[sizeof(struct mbox_out)];
-	mbox_t	*mbox = (mbox_t *)raw_mbox;
-	int	i;
-
-	/* Flush adapter cache */
-	memset(&mbox->m_out, 0, sizeof(raw_mbox));
-	raw_mbox[0] = FLUSH_ADAPTER;
-
-	free_irq(adapter->host->irq, adapter);
-
-	/* Issue a blocking (interrupts disabled) command to the card */
-	issue_scb_block(adapter, raw_mbox);
-
-	/* Flush disks cache */
-	memset(&mbox->m_out, 0, sizeof(raw_mbox));
-	raw_mbox[0] = FLUSH_SYSTEM;
-
-	/* Issue a blocking (interrupts disabled) command to the card */
-	issue_scb_block(adapter, raw_mbox);
-	
-	if (atomic_read(&adapter->pend_cmds) > 0)
-		printk(KERN_WARNING "megaraid: pending commands!!\n");
-
-	/*
-	 * Have a delibrate delay to make sure all the caches are
-	 * actually flushed.
-	 */
-	for (i = 0; i <= 10; i++)
-		mdelay(1000);
-}
-
-static void
-megaraid_remove_one(struct pci_dev *pdev)
-{
-	struct Scsi_Host *host = pci_get_drvdata(pdev);
-	adapter_t *adapter = (adapter_t *)host->hostdata;
-	char	buf[12] = { 0 };
-
-	scsi_remove_host(host);
-
-	__megaraid_shutdown(adapter);
-
-	/* Free our resources */
-	if (adapter->flag & BOARD_MEMMAP) {
-		iounmap((void *)adapter->base);
-		release_mem_region(adapter->host->base, 128);
-	} else
-		release_region(adapter->base, 16);
-
-	mega_free_sgl(adapter);
-
-#ifdef CONFIG_PROC_FS
-	if (adapter->controller_proc_dir_entry) {
-		remove_proc_entry("stat", adapter->controller_proc_dir_entry);
-		remove_proc_entry("config",
-				adapter->controller_proc_dir_entry);
-		remove_proc_entry("mailbox",
-				adapter->controller_proc_dir_entry);
-#if MEGA_HAVE_ENH_PROC
-		remove_proc_entry("rebuild-rate",
-				adapter->controller_proc_dir_entry);
-		remove_proc_entry("battery-status",
-				adapter->controller_proc_dir_entry);
-
-		remove_proc_entry("diskdrives-ch0",
-				adapter->controller_proc_dir_entry);
-		remove_proc_entry("diskdrives-ch1",
-				adapter->controller_proc_dir_entry);
-		remove_proc_entry("diskdrives-ch2",
-				adapter->controller_proc_dir_entry);
-		remove_proc_entry("diskdrives-ch3",
-				adapter->controller_proc_dir_entry);
-
-		remove_proc_entry("raiddrives-0-9",
-				adapter->controller_proc_dir_entry);
-		remove_proc_entry("raiddrives-10-19",
-				adapter->controller_proc_dir_entry);
-		remove_proc_entry("raiddrives-20-29",
-				adapter->controller_proc_dir_entry);
-		remove_proc_entry("raiddrives-30-39",
-				adapter->controller_proc_dir_entry);
-#endif
-		sprintf(buf, "hba%d", adapter->host->host_no);
-		remove_proc_entry(buf, mega_proc_dir_entry);
-	}
-#endif
-
-	pci_free_consistent(adapter->dev, MEGA_BUFFER_SIZE,
-			adapter->mega_buffer, adapter->buf_dma_handle);
-	kfree(adapter->scb_list);
-	pci_free_consistent(adapter->dev, sizeof(mbox64_t),
-			adapter->una_mbox64, adapter->una_mbox64_dma);
-
-	scsi_host_put(host);
-	pci_disable_device(pdev);
-
-	hba_count--;
-}
-
-static void
-megaraid_shutdown(struct device *dev)
-{
-	struct Scsi_Host *host = pci_get_drvdata(to_pci_dev(dev));
-	adapter_t *adapter = (adapter_t *)host->hostdata;
-
-	__megaraid_shutdown(adapter);
-}
-
-static struct pci_device_id megaraid_pci_tbl[] = {
-	{PCI_VENDOR_ID_DELL, PCI_DEVICE_ID_DISCOVERY,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_DELL, PCI_DEVICE_ID_PERC4_DI,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, BOARD_64BIT},
-	{PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_PERC4_QC_VERDE,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, BOARD_64BIT},
-	{PCI_VENDOR_ID_AMI, PCI_DEVICE_ID_AMI_MEGARAID,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_AMI, PCI_DEVICE_ID_AMI_MEGARAID2,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_AMI, PCI_DEVICE_ID_AMI_MEGARAID3,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_AMI_MEGARAID3,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_AMI_MEGARAID3,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{0,}
-};
-MODULE_DEVICE_TABLE(pci, megaraid_pci_tbl);
-
-static struct pci_driver megaraid_pci_driver = {
-	.name		= "megaraid",
-	.id_table	= megaraid_pci_tbl,
-	.probe		= megaraid_probe_one,
-	.remove		= __devexit_p(megaraid_remove_one),
-	.driver		= {
-		.shutdown = megaraid_shutdown,
-	},
-};
-
-static int __init megaraid_init(void)
-{
-	int error;
-
-	if ((max_cmd_per_lun <= 0) || (max_cmd_per_lun > MAX_CMD_PER_LUN))
-		max_cmd_per_lun = MAX_CMD_PER_LUN;
-	if (max_mbox_busy_wait > MBOX_BUSY_WAIT)
-		max_mbox_busy_wait = MBOX_BUSY_WAIT;
-
-#ifdef CONFIG_PROC_FS
-	mega_proc_dir_entry = proc_mkdir("megaraid", &proc_root);
-	if (!mega_proc_dir_entry) {
-		printk(KERN_WARNING
-				"megaraid: failed to create megaraid root\n");
-	}
-#endif
-	error = pci_module_init(&megaraid_pci_driver);
-	if (error) {
-#ifdef CONFIG_PROC_FS
-		remove_proc_entry("megaraid", &proc_root);
-#endif
-		return error;
-	}
-
-	/*
-	 * Register the driver as a character device, for applications
-	 * to access it for ioctls.
-	 * First argument (major) to register_chrdev implies a dynamic
-	 * major number allocation.
-	 */
-	major = register_chrdev(0, "megadev", &megadev_fops);
-	if (!major) {
-		printk(KERN_WARNING
-				"megaraid: failed to register char device\n");
-	}
-
-	return 0;
-}
-
-static void __exit megaraid_exit(void)
-{
-	/*
-	 * Unregister the character device interface to the driver.
-	 */
-	unregister_chrdev(major, "megadev");
-
-#ifdef CONFIG_PROC_FS
-	remove_proc_entry("megaraid", &proc_root);
-#endif
-
-	pci_unregister_driver(&megaraid_pci_driver);
-}
-
-module_init(megaraid_init);
-module_exit(megaraid_exit);
-
-/* vi: set ts=8 sw=8 tw=78: */
diff -urNp linux-2.6.5/drivers/scsi/megaraid.h linux-2.6.5.SUSE/drivers/scsi/megaraid.h
--- linux-2.6.5/drivers/scsi/megaraid.h	2004-04-04 05:37:07.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/megaraid.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,1079 +0,0 @@
-#ifndef __MEGARAID_H__
-#define __MEGARAID_H__
-
-#include <linux/spinlock.h>
-
-
-#define MEGARAID_VERSION	\
-	"v2.00.3 (Release Date: Wed Feb 19 08:51:30 EST 2003)\n"
-
-/*
- * Driver features - change the values to enable or disable features in the
- * driver.
- */
-
-/*
- * Comand coalescing - This feature allows the driver to be able to combine
- * two or more commands and issue as one command in order to boost I/O
- * performance. Useful if the nature of the I/O is sequential. It is not very
- * useful for random natured I/Os.
- */
-#define MEGA_HAVE_COALESCING	0
-
-/*
- * Clustering support - Set this flag if you are planning to use the
- * clustering services provided by the megaraid controllers and planning to
- * setup a cluster
- */
-#define MEGA_HAVE_CLUSTERING	1
-
-/*
- * Driver statistics - Set this flag if you are interested in statics about
- * number of I/O completed on each logical drive and how many interrupts
- * generated. If enabled, this information is available through /proc
- * interface and through the private ioctl. Setting this flag has a
- * performance penalty.
- */
-#define MEGA_HAVE_STATS		0
-
-/*
- * Enhanced /proc interface - This feature will allow you to have a more
- * detailed /proc interface for megaraid driver. E.g., a real time update of
- * the status of the logical drives, battery status, physical drives etc.
- */
-#define MEGA_HAVE_ENH_PROC	1
-
-#define MAX_DEV_TYPE	32
-
-#ifndef PCI_VENDOR_ID_LSI_LOGIC
-#define PCI_VENDOR_ID_LSI_LOGIC		0x1000
-#endif
-
-#ifndef PCI_VENDOR_ID_AMI
-#define PCI_VENDOR_ID_AMI		0x101E
-#endif
-
-#ifndef PCI_VENDOR_ID_DELL
-#define PCI_VENDOR_ID_DELL		0x1028
-#endif
-
-#ifndef PCI_VENDOR_ID_INTEL
-#define PCI_VENDOR_ID_INTEL		0x8086
-#endif
-
-#ifndef PCI_DEVICE_ID_AMI_MEGARAID
-#define PCI_DEVICE_ID_AMI_MEGARAID	0x9010
-#endif
-
-#ifndef PCI_DEVICE_ID_AMI_MEGARAID2
-#define PCI_DEVICE_ID_AMI_MEGARAID2	0x9060
-#endif
-
-#ifndef PCI_DEVICE_ID_AMI_MEGARAID3
-#define PCI_DEVICE_ID_AMI_MEGARAID3	0x1960
-#endif
-
-#define PCI_DEVICE_ID_DISCOVERY		0x000E
-#define PCI_DEVICE_ID_PERC4_DI		0x000F
-#define PCI_DEVICE_ID_PERC4_QC_VERDE	0x0407
-
-/* Sub-System Vendor IDs */
-#define	AMI_SUBSYS_VID			0x101E
-#define DELL_SUBSYS_VID			0x1028
-#define	HP_SUBSYS_VID			0x103C
-#define LSI_SUBSYS_VID			0x1000
-#define INTEL_SUBSYS_VID		0x8086
-
-#define HBA_SIGNATURE	      		0x3344
-#define HBA_SIGNATURE_471	  	0xCCCC
-#define HBA_SIGNATURE_64BIT		0x0299
-
-#define MBOX_BUSY_WAIT			10	/* wait for up to 10 usec for
-						   mailbox to be free */
-#define DEFAULT_INITIATOR_ID	7
-
-#define MAX_SGLIST		64	/* max supported in f/w */
-#define MIN_SGLIST		26	/* guaranteed to support these many */
-#define MAX_COMMANDS		126
-#define CMDID_INT_CMDS		MAX_COMMANDS+1	/* make sure CMDID_INT_CMDS
-					 	is less than max commands
-						supported by any f/w */
-
-#define MAX_CDB_LEN	     	10
-#define MAX_EXT_CDB_LEN		16	/* we support cdb length up to 16 */
-
-#define DEF_CMD_PER_LUN		63
-#define MAX_CMD_PER_LUN		MAX_COMMANDS
-#define MAX_FIRMWARE_STATUS	46
-#define MAX_XFER_PER_CMD	(64*1024)
-#define MAX_SECTORS_PER_IO	128
-
-#define MAX_LOGICAL_DRIVES_40LD		40
-#define FC_MAX_PHYSICAL_DEVICES		256
-#define MAX_LOGICAL_DRIVES_8LD		8
-#define MAX_CHANNELS			5
-#define MAX_TARGET			15
-#define MAX_PHYSICAL_DRIVES		MAX_CHANNELS*MAX_TARGET
-#define MAX_ROW_SIZE_40LD		32
-#define MAX_ROW_SIZE_8LD		8
-#define MAX_SPAN_DEPTH			8
-
-#define NVIRT_CHAN		4	/* # of virtual channels to represent
-					   up to 60 logical drives */
-struct mbox_out {
-	/* 0x0 */ u8 cmd;
-	/* 0x1 */ u8 cmdid;
-	/* 0x2 */ u16 numsectors;
-	/* 0x4 */ u32 lba;
-	/* 0x8 */ u32 xferaddr;
-	/* 0xC */ u8 logdrv;
-	/* 0xD */ u8 numsgelements;
-	/* 0xE */ u8 resvd;
-} __attribute__ ((packed));
-
-struct mbox_in {
-	/* 0xF */ volatile u8 busy;
-	/* 0x10 */ volatile u8 numstatus;
-	/* 0x11 */ volatile u8 status;
-	/* 0x12 */ volatile u8 completed[MAX_FIRMWARE_STATUS];
-	volatile u8 poll;
-	volatile u8 ack;
-} __attribute__ ((packed));
-
-typedef struct {
-	struct mbox_out	m_out;
-	struct mbox_in	m_in;
-} __attribute__ ((packed)) mbox_t;
-
-typedef struct {
-	u32 xfer_segment_lo;
-	u32 xfer_segment_hi;
-	mbox_t mbox;
-} __attribute__ ((packed)) mbox64_t;
-
-
-/*
- * Passthru definitions
- */
-#define MAX_REQ_SENSE_LEN       0x20
-
-typedef struct {
-	u8 timeout:3;		/* 0=6sec/1=60sec/2=10min/3=3hrs */
-	u8 ars:1;
-	u8 reserved:3;
-	u8 islogical:1;
-	u8 logdrv;		/* if islogical == 1 */
-	u8 channel;		/* if islogical == 0 */
-	u8 target;		/* if islogical == 0 */
-	u8 queuetag;		/* unused */
-	u8 queueaction;		/* unused */
-	u8 cdb[MAX_CDB_LEN];
-	u8 cdblen;
-	u8 reqsenselen;
-	u8 reqsensearea[MAX_REQ_SENSE_LEN];
-	u8 numsgelements;
-	u8 scsistatus;
-	u32 dataxferaddr;
-	u32 dataxferlen;
-} __attribute__ ((packed)) mega_passthru;
-
-
-/*
- * Extended passthru: support CDB > 10 bytes
- */
-typedef struct {
-	u8 timeout:3;		/* 0=6sec/1=60sec/2=10min/3=3hrs */
-	u8 ars:1;
-	u8 rsvd1:1;
-	u8 cd_rom:1;
-	u8 rsvd2:1;
-	u8 islogical:1;
-	u8 logdrv;		/* if islogical == 1 */
-	u8 channel;		/* if islogical == 0 */
-	u8 target;		/* if islogical == 0 */
-	u8 queuetag;		/* unused */
-	u8 queueaction;		/* unused */
-	u8 cdblen;
-	u8 rsvd3;
-	u8 cdb[MAX_EXT_CDB_LEN];
-	u8 numsgelements;
-	u8 status;
-	u8 reqsenselen;
-	u8 reqsensearea[MAX_REQ_SENSE_LEN];
-	u8 rsvd4;
-	u32 dataxferaddr;
-	u32 dataxferlen;
-} __attribute__ ((packed)) mega_ext_passthru;
-
-typedef struct {
-	u64 address;
-	u32 length;
-} __attribute__ ((packed)) mega_sgl64;
-
-typedef struct {
-	u32 address;
-	u32 length;
-} __attribute__ ((packed)) mega_sglist;
-
-
-/* Queued command data */
-typedef struct {
-	int	idx;
-	u32	state;
-	struct list_head	list;
-	u8	raw_mbox[66];
-	u32	dma_type;
-	u32	dma_direction;
-
-	Scsi_Cmnd	*cmd;
-	dma_addr_t	dma_h_bulkdata;
-	dma_addr_t	dma_h_sgdata;
-
-	mega_sglist	*sgl;
-	mega_sgl64	*sgl64;
-	dma_addr_t	sgl_dma_addr;
-
-	mega_passthru		*pthru;
-	dma_addr_t		pthru_dma_addr;
-	mega_ext_passthru	*epthru;
-	dma_addr_t		epthru_dma_addr;
-} scb_t;
-
-/*
- * Flags to follow the scb as it transitions between various stages
- */
-#define SCB_FREE	0x0000	/* on the free list */
-#define SCB_ACTIVE	0x0001	/* off the free list */
-#define SCB_PENDQ	0x0002	/* on the pending queue */
-#define SCB_ISSUED	0x0004	/* issued - owner f/w */
-#define SCB_ABORT	0x0008	/* Got an abort for this one */
-#define SCB_RESET	0x0010	/* Got a reset for this one */
-
-/*
- * Utilities declare this strcture size as 1024 bytes. So more fields can
- * be added in future.
- */
-typedef struct {
-	u32	data_size; /* current size in bytes (not including resvd) */
-
-	u32	config_signature;
-		/* Current value is 0x00282008
-		 * 0x28=MAX_LOGICAL_DRIVES,
-		 * 0x20=Number of stripes and
-		 * 0x08=Number of spans */
-
-	u8	fw_version[16];		/* printable ASCI string */
-	u8	bios_version[16];	/* printable ASCI string */
-	u8	product_name[80];	/* printable ASCI string */
-
-	u8	max_commands;		/* Max. concurrent commands supported */
-	u8	nchannels;		/* Number of SCSI Channels detected */
-	u8	fc_loop_present;	/* Number of Fibre Loops detected */
-	u8	mem_type;		/* EDO, FPM, SDRAM etc */
-
-	u32	signature;
-	u16	dram_size;		/* In terms of MB */
-	u16	subsysid;
-
-	u16	subsysvid;
-	u8	notify_counters;
-	u8	pad1k[889];		/* 135 + 889 resvd = 1024 total size */
-} __attribute__ ((packed)) mega_product_info;
-
-struct notify {
-	u32 global_counter;	/* Any change increments this counter */
-
-	u8 param_counter;	/* Indicates any params changed  */
-	u8 param_id;		/* Param modified - defined below */
-	u16 param_val;		/* New val of last param modified */
-
-	u8 write_config_counter;	/* write config occurred */
-	u8 write_config_rsvd[3];
-
-	u8 ldrv_op_counter;	/* Indicates ldrv op started/completed */
-	u8 ldrv_opid;		/* ldrv num */
-	u8 ldrv_opcmd;		/* ldrv operation - defined below */
-	u8 ldrv_opstatus;	/* status of the operation */
-
-	u8 ldrv_state_counter;	/* Indicates change of ldrv state */
-	u8 ldrv_state_id;		/* ldrv num */
-	u8 ldrv_state_new;	/* New state */
-	u8 ldrv_state_old;	/* old state */
-
-	u8 pdrv_state_counter;	/* Indicates change of ldrv state */
-	u8 pdrv_state_id;		/* pdrv id */
-	u8 pdrv_state_new;	/* New state */
-	u8 pdrv_state_old;	/* old state */
-
-	u8 pdrv_fmt_counter;	/* Indicates pdrv format started/over */
-	u8 pdrv_fmt_id;		/* pdrv id */
-	u8 pdrv_fmt_val;		/* format started/over */
-	u8 pdrv_fmt_rsvd;
-
-	u8 targ_xfer_counter;	/* Indicates SCSI-2 Xfer rate change */
-	u8 targ_xfer_id;	/* pdrv Id  */
-	u8 targ_xfer_val;		/* new Xfer params of last pdrv */
-	u8 targ_xfer_rsvd;
-
-	u8 fcloop_id_chg_counter;	/* Indicates loopid changed */
-	u8 fcloopid_pdrvid;		/* pdrv id */
-	u8 fcloop_id0;			/* loopid on fc loop 0 */
-	u8 fcloop_id1;			/* loopid on fc loop 1 */
-
-	u8 fcloop_state_counter;	/* Indicates loop state changed */
-	u8 fcloop_state0;		/* state of fc loop 0 */
-	u8 fcloop_state1;		/* state of fc loop 1 */
-	u8 fcloop_state_rsvd;
-} __attribute__ ((packed));
-
-#define MAX_NOTIFY_SIZE     0x80
-#define CUR_NOTIFY_SIZE     sizeof(struct notify)
-
-typedef struct {
-	u32	data_size; /* current size in bytes (not including resvd) */
-
-	struct notify notify;
-
-	u8	notify_rsvd[MAX_NOTIFY_SIZE - CUR_NOTIFY_SIZE];
-
-	u8	rebuild_rate;		/* Rebuild rate (0% - 100%) */
-	u8	cache_flush_interval;	/* In terms of Seconds */
-	u8	sense_alert;
-	u8	drive_insert_count;	/* drive insertion count */
-
-	u8	battery_status;
-	u8	num_ldrv;		/* No. of Log Drives configured */
-	u8	recon_state[MAX_LOGICAL_DRIVES_40LD / 8];	/* State of
-							   reconstruct */
-	u16	ldrv_op_status[MAX_LOGICAL_DRIVES_40LD / 8]; /* logdrv
-								 Status */
-
-	u32	ldrv_size[MAX_LOGICAL_DRIVES_40LD];/* Size of each log drv */
-	u8	ldrv_prop[MAX_LOGICAL_DRIVES_40LD];
-	u8	ldrv_state[MAX_LOGICAL_DRIVES_40LD];/* State of log drives */
-	u8	pdrv_state[FC_MAX_PHYSICAL_DEVICES];/* State of phys drvs. */
-	u16	pdrv_format[FC_MAX_PHYSICAL_DEVICES / 16];
-
-	u8	targ_xfer[80];	/* phys device transfer rate */
-	u8	pad1k[263];	/* 761 + 263reserved = 1024 bytes total size */
-} __attribute__ ((packed)) mega_inquiry3;
-
-
-/* Structures */
-typedef struct {
-	u8	max_commands;	/* Max concurrent commands supported */
-	u8	rebuild_rate;	/* Rebuild rate - 0% thru 100% */
-	u8	max_targ_per_chan;	/* Max targ per channel */
-	u8	nchannels;	/* Number of channels on HBA */
-	u8	fw_version[4];	/* Firmware version */
-	u16	age_of_flash;	/* Number of times FW has been flashed */
-	u8	chip_set_value;	/* Contents of 0xC0000832 */
-	u8	dram_size;	/* In MB */
-	u8	cache_flush_interval;	/* in seconds */
-	u8	bios_version[4];
-	u8	board_type;
-	u8	sense_alert;
-	u8	write_config_count;	/* Increase with every configuration
-					   change */
-	u8	drive_inserted_count;	/* Increase with every drive inserted
-					 */
-	u8	inserted_drive;	/* Channel:Id of inserted drive */
-	u8	battery_status;	/*
-				 * BIT 0: battery module missing
-				 * BIT 1: VBAD
-				 * BIT 2: temprature high
-				 * BIT 3: battery pack missing
-				 * BIT 4,5:
-				 *   00 - charge complete
-				 *   01 - fast charge in progress
-				 *   10 - fast charge fail
-				 *   11 - undefined
-				 * Bit 6: counter > 1000
-				 * Bit 7: Undefined
-				 */
-	u8	dec_fault_bus_info;
-} __attribute__ ((packed)) mega_adp_info;
-
-
-typedef struct {
-	u8	num_ldrv;	/* Number of logical drives configured */
-	u8	rsvd[3];
-	u32	ldrv_size[MAX_LOGICAL_DRIVES_8LD];
-	u8	ldrv_prop[MAX_LOGICAL_DRIVES_8LD];
-	u8	ldrv_state[MAX_LOGICAL_DRIVES_8LD];
-} __attribute__ ((packed)) mega_ldrv_info;
-
-typedef struct {
-	u8	pdrv_state[MAX_PHYSICAL_DRIVES];
-	u8	rsvd;
-} __attribute__ ((packed)) mega_pdrv_info;
-
-/* RAID inquiry: Mailbox command 0x05*/
-typedef struct {
-	mega_adp_info	adapter_info;
-	mega_ldrv_info	logdrv_info;
-	mega_pdrv_info	pdrv_info;
-} __attribute__ ((packed)) mraid_inquiry;
-
-
-/* RAID extended inquiry: Mailbox command 0x04*/
-typedef struct {
-	mraid_inquiry	raid_inq;
-	u16	phys_drv_format[MAX_CHANNELS];
-	u8	stack_attn;
-	u8	modem_status;
-	u8	rsvd[2];
-} __attribute__ ((packed)) mraid_ext_inquiry;
-
-
-typedef struct {
-	u8	channel;
-	u8	target;
-}__attribute__ ((packed)) adp_device;
-
-typedef struct {
-	u32		start_blk;	/* starting block */
-	u32		num_blks;	/* # of blocks */
-	adp_device	device[MAX_ROW_SIZE_40LD];
-}__attribute__ ((packed)) adp_span_40ld;
-
-typedef struct {
-	u32		start_blk;	/* starting block */
-	u32		num_blks;	/* # of blocks */
-	adp_device	device[MAX_ROW_SIZE_8LD];
-}__attribute__ ((packed)) adp_span_8ld;
-
-typedef struct {
-	u8	span_depth;	/* Total # of spans */
-	u8	level;		/* RAID level */
-	u8	read_ahead;	/* read ahead, no read ahead, adaptive read
-				   ahead */
-	u8	stripe_sz;	/* Encoded stripe size */
-	u8	status;		/* Status of the logical drive */
-	u8	write_mode;	/* write mode, write_through/write_back */
-	u8	direct_io;	/* direct io or through cache */
-	u8	row_size;	/* Number of stripes in a row */
-} __attribute__ ((packed)) logdrv_param;
-
-typedef struct {
-	logdrv_param	lparam;
-	adp_span_40ld	span[MAX_SPAN_DEPTH];
-}__attribute__ ((packed)) logdrv_40ld;
-
-typedef struct {
-	logdrv_param	lparam;
-	adp_span_8ld	span[MAX_SPAN_DEPTH];
-}__attribute__ ((packed)) logdrv_8ld;
-
-typedef struct {
-	u8	type;		/* Type of the device */
-	u8	cur_status;	/* current status of the device */
-	u8	tag_depth;	/* Level of tagging */
-	u8	sync_neg;	/* sync negotiation - ENABLE or DISBALE */
-	u32	size;		/* configurable size in terms of 512 byte
-				   blocks */
-}__attribute__ ((packed)) phys_drv;
-
-typedef struct {
-	u8		nlog_drives;		/* number of logical drives */
-	u8		resvd[3];
-	logdrv_40ld	ldrv[MAX_LOGICAL_DRIVES_40LD];
-	phys_drv	pdrv[MAX_PHYSICAL_DRIVES];
-}__attribute__ ((packed)) disk_array_40ld;
-
-typedef struct {
-	u8		nlog_drives;	/* number of logical drives */
-	u8		resvd[3];
-	logdrv_8ld	ldrv[MAX_LOGICAL_DRIVES_8LD];
-	phys_drv	pdrv[MAX_PHYSICAL_DRIVES];
-}__attribute__ ((packed)) disk_array_8ld;
-
-
-/*
- * User ioctl structure.
- * This structure will be used for Traditional Method ioctl interface
- * commands (0x80),Alternate Buffer Method (0x81) ioctl commands and the
- * Driver ioctls.
- * The Driver ioctl interface handles the commands at the driver level,
- * without being sent to the card.
- */
-/* system call imposed limit. Change accordingly */
-#define IOCTL_MAX_DATALEN       4096
-
-struct uioctl_t {
-	u32 inlen;
-	u32 outlen;
-	union {
-		u8 fca[16];
-		struct {
-			u8 opcode;
-			u8 subopcode;
-			u16 adapno;
-#if BITS_PER_LONG == 32
-			u8 *buffer;
-			u8 pad[4];
-#endif
-#if BITS_PER_LONG == 64
-			u8 *buffer;
-#endif
-			u32 length;
-		} __attribute__ ((packed)) fcs;
-	} __attribute__ ((packed)) ui;
-	u8 mbox[18];		/* 16 bytes + 2 status bytes */
-	mega_passthru pthru;
-#if BITS_PER_LONG == 32
-	char *data;		/* buffer <= 4096 for 0x80 commands */
-	char pad[4];
-#endif
-#if BITS_PER_LONG == 64
-	char *data;
-#endif
-} __attribute__ ((packed));
-
-/*
- * struct mcontroller is used to pass information about the controllers in the
- * system. Its upto the application how to use the information. We are passing
- * as much info about the cards as possible and useful. Before issuing the
- * call to find information about the cards, the applicaiton needs to issue a
- * ioctl first to find out the number of controllers in the system.
- */
-#define MAX_CONTROLLERS 32
-
-struct mcontroller {
-	u64 base;
-	u8 irq;
-	u8 numldrv;
-	u8 pcibus;
-	u16 pcidev;
-	u8 pcifun;
-	u16 pciid;
-	u16 pcivendor;
-	u8 pcislot;
-	u32 uid;
-};
-
-/*
- * mailbox structure used for internal commands
- */
-typedef struct {
-	u8	cmd;
-	u8	cmdid;
-	u8	opcode;
-	u8	subopcode;
-	u32	lba;
-	u32	xferaddr;
-	u8	logdrv;
-	u8	rsvd[3];
-	u8	numstatus;
-	u8	status;
-} __attribute__ ((packed)) megacmd_t;
-
-/*
- * Defines for Driver IOCTL interface
- */
-#define MEGAIOC_MAGIC  	'm'
-
-#define MEGAIOC_QNADAP		'm'	/* Query # of adapters */
-#define MEGAIOC_QDRVRVER	'e'	/* Query driver version */
-#define MEGAIOC_QADAPINFO   	'g'	/* Query adapter information */
-#define MKADAP(adapno)	  	(MEGAIOC_MAGIC << 8 | (adapno) )
-#define GETADAP(mkadap)	 	( (mkadap) ^ MEGAIOC_MAGIC << 8 )
-
-/*
- * Definition for the new ioctl interface (NIT)
- */
-
-/*
- * Vendor specific Group-7 commands
- */
-#define VENDOR_SPECIFIC_COMMANDS	0xE0
-#define MEGA_INTERNAL_CMD		VENDOR_SPECIFIC_COMMANDS + 0x01
-
-/*
- * The ioctl command. No other command shall be used for this interface
- */
-#define USCSICMD	VENDOR_SPECIFIC_COMMANDS
-
-/*
- * Data direction flags
- */
-#define UIOC_RD		0x00001
-#define UIOC_WR		0x00002
-
-/*
- * ioctl opcodes
- */
-#define MBOX_CMD	0x00000	/* DCMD or passthru command */
-#define GET_DRIVER_VER	0x10000	/* Get driver version */
-#define GET_N_ADAP	0x20000	/* Get number of adapters */
-#define GET_ADAP_INFO	0x30000	/* Get information about a adapter */
-#define GET_CAP		0x40000	/* Get ioctl capabilities */
-#define GET_STATS	0x50000	/* Get statistics, including error info */
-
-
-/*
- * The ioctl structure.
- * MBOX macro converts a nitioctl_t structure to megacmd_t pointer and
- * MBOX_P macro converts a nitioctl_t pointer to megacmd_t pointer.
- */
-typedef struct {
-	char		signature[8];	/* Must contain "MEGANIT" */
-	u32		opcode;		/* opcode for the command */
-	u32		adapno;		/* adapter number */
-	union {
-		u8	__raw_mbox[18];
-		caddr_t	__uaddr; /* xferaddr for non-mbox cmds */
-	}__ua;
-
-#define uioc_rmbox	__ua.__raw_mbox
-#define MBOX(uioc)	((megacmd_t *)&((uioc).__ua.__raw_mbox[0]))
-#define MBOX_P(uioc)	((megacmd_t *)&((uioc)->__ua.__raw_mbox[0]))
-#define uioc_uaddr	__ua.__uaddr
-
-	u32		xferlen;	/* xferlen for DCMD and non-mbox
-					   commands */
-	u32		flags;		/* data direction flags */
-}nitioctl_t;
-
-
-/*
- * I/O statistics for some applications like SNMP agent. The caller must
- * provide the number of logical drives for which status should be reported.
- */
-typedef struct {
-	int	num_ldrv;	/* Number for logical drives for which the
-				   status should be reported. */
-	u32	nreads[MAX_LOGICAL_DRIVES_40LD];	/* number of reads for
-							each logical drive */
-	u32	nreadblocks[MAX_LOGICAL_DRIVES_40LD];	/* number of blocks
-							read for each logical
-							drive */
-	u32	nwrites[MAX_LOGICAL_DRIVES_40LD];	/* number of writes
-							for each logical
-							drive */
-	u32	nwriteblocks[MAX_LOGICAL_DRIVES_40LD];	/* number of blocks
-							writes for each
-							logical drive */
-	u32	rd_errors[MAX_LOGICAL_DRIVES_40LD];	/* number of read
-							   errors for each
-							   logical drive */
-	u32	wr_errors[MAX_LOGICAL_DRIVES_40LD];	/* number of write
-							   errors for each
-							   logical drive */
-}megastat_t;
-
-
-struct private_bios_data {
-	u8	geometry:4;	/*
-				 * bits 0-3 - BIOS geometry
-				 * 0x0001 - 1GB
-				 * 0x0010 - 2GB
-				 * 0x1000 - 8GB
-				 * Others values are invalid
-							 */
-	u8	unused:4;	/* bits 4-7 are unused */
-	u8	boot_drv;	/*
-				 * logical drive set as boot drive
-				 * 0..7 - for 8LD cards
-				 * 0..39 - for 40LD cards
-				 */
-	u8	rsvd[12];
-	u16	cksum;	/* 0-(sum of first 13 bytes of this structure) */
-} __attribute__ ((packed));
-
-
-
-
-/*
- * Mailbox and firmware commands and subopcodes used in this driver.
- */
-
-#define MEGA_MBOXCMD_LREAD	0x01
-#define MEGA_MBOXCMD_LWRITE	0x02
-#define MEGA_MBOXCMD_PASSTHRU	0x03
-#define MEGA_MBOXCMD_ADPEXTINQ	0x04
-#define MEGA_MBOXCMD_ADAPTERINQ	0x05
-#define MEGA_MBOXCMD_LREAD64	0xA7
-#define MEGA_MBOXCMD_LWRITE64	0xA8
-#define MEGA_MBOXCMD_PASSTHRU64	0xC3
-#define MEGA_MBOXCMD_EXTPTHRU	0xE3
-
-#define MAIN_MISC_OPCODE	0xA4	/* f/w misc opcode */
-#define GET_MAX_SG_SUPPORT	0x01	/* get max sg len supported by f/w */
-
-#define FC_NEW_CONFIG		0xA1
-#define NC_SUBOP_PRODUCT_INFO	0x0E
-#define NC_SUBOP_ENQUIRY3	0x0F
-#define ENQ3_GET_SOLICITED_FULL	0x02
-#define OP_DCMD_READ_CONFIG	0x04
-#define NEW_READ_CONFIG_8LD	0x67
-#define READ_CONFIG_8LD		0x07
-#define FLUSH_ADAPTER		0x0A
-#define FLUSH_SYSTEM		0xFE
-
-/*
- * Command for random deletion of logical drives
- */
-#define	FC_DEL_LOGDRV		0xA4	/* f/w command */
-#define	OP_SUP_DEL_LOGDRV	0x2A	/* is feature supported */
-#define OP_GET_LDID_MAP		0x18	/* get ldid and logdrv number map */
-#define OP_DEL_LOGDRV		0x1C	/* delete logical drive */
-
-/*
- * BIOS commands
- */
-#define IS_BIOS_ENABLED		0x62
-#define GET_BIOS		0x01
-#define CHNL_CLASS		0xA9
-#define GET_CHNL_CLASS		0x00
-#define SET_CHNL_CLASS		0x01
-#define CH_RAID			0x01
-#define CH_SCSI			0x00
-#define BIOS_PVT_DATA		0x40
-#define GET_BIOS_PVT_DATA	0x00
-
-
-/*
- * Commands to support clustering
- */
-#define MEGA_GET_TARGET_ID	0x7D
-#define MEGA_CLUSTER_OP		0x70
-#define MEGA_GET_CLUSTER_MODE	0x02
-#define MEGA_CLUSTER_CMD	0x6E
-#define MEGA_RESERVE_LD		0x01
-#define MEGA_RELEASE_LD		0x02
-#define MEGA_RESET_RESERVATIONS	0x03
-#define MEGA_RESERVATION_STATUS	0x04
-#define MEGA_RESERVE_PD		0x05
-#define MEGA_RELEASE_PD		0x06
-
-
-/*
- * Module battery status
- */
-#define MEGA_BATT_MODULE_MISSING	0x01
-#define MEGA_BATT_LOW_VOLTAGE		0x02
-#define MEGA_BATT_TEMP_HIGH		0x04
-#define MEGA_BATT_PACK_MISSING		0x08
-#define MEGA_BATT_CHARGE_MASK		0x30
-#define MEGA_BATT_CHARGE_DONE		0x00
-#define MEGA_BATT_CHARGE_INPROG		0x10
-#define MEGA_BATT_CHARGE_FAIL		0x20
-#define MEGA_BATT_CYCLES_EXCEEDED	0x40
-
-/*
- * Physical drive states.
- */
-#define PDRV_UNCNF	0
-#define PDRV_ONLINE	3
-#define PDRV_FAILED	4
-#define PDRV_RBLD	5
-#define PDRV_HOTSPARE	6
-
-
-/*
- * Raid logical drive states.
- */
-#define RDRV_OFFLINE	0
-#define RDRV_DEGRADED	1
-#define RDRV_OPTIMAL	2
-#define RDRV_DELETED	3
-
-/*
- * Read, write and cache policies
- */
-#define NO_READ_AHEAD		0
-#define READ_AHEAD		1
-#define ADAP_READ_AHEAD		2
-#define WRMODE_WRITE_THRU	0
-#define WRMODE_WRITE_BACK	1
-#define CACHED_IO		0
-#define DIRECT_IO		1
-
-
-#define SCSI_LIST(scp) ((struct list_head *)(&(scp)->SCp))
-
-/*
- * Each controller's soft state
- */
-typedef struct {
-	int	this_id;	/* our id, may set to different than 7 if
-				   clustering is available */
-	u32	flag;
-
-	unsigned long	base;
-
-	/* mbox64 with mbox not aligned on 16-byte boundry */
-	mbox64_t	*una_mbox64;
-	dma_addr_t	una_mbox64_dma;
-
-	volatile mbox64_t	*mbox64;/* ptr to 64-bit mailbox */
-	volatile mbox_t		*mbox;	/* ptr to standard mailbox */
-	dma_addr_t		mbox_dma;
-
-	struct pci_dev	*dev;
-
-	struct list_head	free_list;
-	struct list_head	pending_list;
-	struct list_head	completed_list;
-
-	struct Scsi_Host	*host;
-
-#define MEGA_BUFFER_SIZE (2*1024)
-	u8		*mega_buffer;
-	dma_addr_t	buf_dma_handle;
-
-	mega_product_info	product_info;
-
-	u8		max_cmds;
-	scb_t		*scb_list;
-
-	atomic_t	pend_cmds;	/* maintain a counter for pending
-					   commands in firmware */
-
-#if MEGA_HAVE_STATS
-	u32	nreads[MAX_LOGICAL_DRIVES_40LD];
-	u32	nreadblocks[MAX_LOGICAL_DRIVES_40LD];
-	u32	nwrites[MAX_LOGICAL_DRIVES_40LD];
-	u32	nwriteblocks[MAX_LOGICAL_DRIVES_40LD];
-	u32	rd_errors[MAX_LOGICAL_DRIVES_40LD];
-	u32	wr_errors[MAX_LOGICAL_DRIVES_40LD];
-#endif
-
-	/* Host adapter parameters */
-	u8	numldrv;
-	u8	fw_version[7];
-	u8	bios_version[7];
-
-#ifdef CONFIG_PROC_FS
-	struct proc_dir_entry	*controller_proc_dir_entry;
-	struct proc_dir_entry	*proc_read;
-	struct proc_dir_entry	*proc_stat;
-	struct proc_dir_entry	*proc_mbox;
-
-#if MEGA_HAVE_ENH_PROC
-	struct proc_dir_entry	*proc_rr;
-	struct proc_dir_entry	*proc_battery;
-#define MAX_PROC_CHANNELS	4
-	struct proc_dir_entry	*proc_pdrvstat[MAX_PROC_CHANNELS];
-	struct proc_dir_entry	*proc_rdrvstat[MAX_PROC_CHANNELS];
-#endif
-
-#endif
-
-	int	has_64bit_addr;		/* are we using 64-bit addressing */
-	int	support_ext_cdb;
-	int	boot_ldrv_enabled;
-	int	boot_ldrv;
-	int	boot_pdrv_enabled;	/* boot from physical drive */
-	int	boot_pdrv_ch;		/* boot physical drive channel */
-	int	boot_pdrv_tgt;		/* boot physical drive target */
-
-
-	int	support_random_del;	/* Do we support random deletion of
-					   logdrvs */
-	int	read_ldidmap;	/* set after logical drive deltion. The
-				   logical drive number must be read from the
-				   map */
-	atomic_t	quiescent;	/* a stage reached when delete logical
-					   drive needs to be done. Stop
-					   sending requests to the hba till
-					   delete operation is completed */
-	spinlock_t	lock;
-
-	u8	logdrv_chan[MAX_CHANNELS+NVIRT_CHAN]; /* logical drive are on
-							what channels. */
-	int	mega_ch_class;
-
-	u8	sglen;	/* f/w supported scatter-gather list length */
-
-	scb_t			int_scb;
-	Scsi_Cmnd		int_scmd;
-	struct semaphore	int_mtx;	/* To synchronize the internal
-						commands */
-	wait_queue_head_t	int_waitq;	/* wait queue for internal
-						 cmds */
-
-	int	has_cluster;	/* cluster support on this HBA */
-}adapter_t;
-
-
-struct mega_hbas {
-	int is_bios_enabled;
-	adapter_t *hostdata_addr;
-};
-
-
-/*
- * For state flag. Do not use LSB(8 bits) which are
- * reserved for storing info about channels.
- */
-#define IN_ABORT	0x80000000L
-#define IN_RESET	0x40000000L
-#define BOARD_MEMMAP	0x20000000L
-#define BOARD_IOMAP	0x10000000L
-#define BOARD_40LD   	0x08000000L
-#define BOARD_64BIT	0x04000000L
-
-#define INTR_VALID			0x40
-
-#define PCI_CONF_AMISIG			0xa0
-#define PCI_CONF_AMISIG64		0xa4
-
-
-#define MEGA_DMA_TYPE_NONE		0xFFFF
-#define MEGA_BULK_DATA			0x0001
-#define MEGA_SGLIST			0x0002
-
-/*
- * lockscope definitions, callers can specify the lock scope with this data
- * type. LOCK_INT would mean the caller has not acquired the lock before
- * making the call and LOCK_EXT would mean otherwise.
- */
-typedef enum { LOCK_INT, LOCK_EXT } lockscope_t;
-
-/*
- * Parameters for the io-mapped controllers
- */
-
-/* I/O Port offsets */
-#define CMD_PORT	 	0x00
-#define ACK_PORT	 	0x00
-#define TOGGLE_PORT		0x01
-#define INTR_PORT	  	0x0a
-
-#define MBOX_BUSY_PORT     	0x00
-#define MBOX_PORT0	 	0x04
-#define MBOX_PORT1	 	0x05
-#define MBOX_PORT2	 	0x06
-#define MBOX_PORT3	 	0x07
-#define ENABLE_MBOX_REGION 	0x0B
-
-/* I/O Port Values */
-#define ISSUE_BYTE	 	0x10
-#define ACK_BYTE	   	0x08
-#define ENABLE_INTR_BYTE   	0xc0
-#define DISABLE_INTR_BYTE  	0x00
-#define VALID_INTR_BYTE    	0x40
-#define MBOX_BUSY_BYTE     	0x10
-#define ENABLE_MBOX_BYTE   	0x00
-
-
-/* Setup some port macros here */
-#define issue_command(adapter)	\
-		outb_p(ISSUE_BYTE, (adapter)->base + CMD_PORT)
-
-#define irq_state(adapter)	inb_p((adapter)->base + INTR_PORT)
-
-#define set_irq_state(adapter, value)	\
-		outb_p((value), (adapter)->base + INTR_PORT)
-
-#define irq_ack(adapter)	\
-		outb_p(ACK_BYTE, (adapter)->base + ACK_PORT)
-
-#define irq_enable(adapter)	\
-	outb_p(ENABLE_INTR_BYTE, (adapter)->base + TOGGLE_PORT)
-
-#define irq_disable(adapter)	\
-	outb_p(DISABLE_INTR_BYTE, (adapter)->base + TOGGLE_PORT)
-
-
-/*
- * This is our SYSDEP area. All kernel specific detail should be placed here -
- * as much as possible
- */
-
-/*
- * End of SYSDEP area
- */
-
-const char *megaraid_info (struct Scsi_Host *);
-
-static int mega_query_adapter(adapter_t *);
-static inline int issue_scb(adapter_t *, scb_t *);
-static int mega_setup_mailbox(adapter_t *);
-
-static int megaraid_queue (Scsi_Cmnd *, void (*)(Scsi_Cmnd *));
-static scb_t * mega_build_cmd(adapter_t *, Scsi_Cmnd *, int *);
-static inline scb_t *mega_allocate_scb(adapter_t *, Scsi_Cmnd *);
-static void __mega_runpendq(adapter_t *);
-static inline void mega_runpendq(adapter_t *);
-static int issue_scb_block(adapter_t *, u_char *);
-
-static irqreturn_t megaraid_isr_memmapped(int, void *, struct pt_regs *);
-static irqreturn_t megaraid_isr_iomapped(int, void *, struct pt_regs *);
-
-static void mega_free_scb(adapter_t *, scb_t *);
-
-static int megaraid_abort(Scsi_Cmnd *);
-static int megaraid_reset(Scsi_Cmnd *);
-static int megaraid_abort_and_reset(adapter_t *, Scsi_Cmnd *, int);
-static int megaraid_biosparam(struct scsi_device *, struct block_device *,
-		sector_t, int []);
-static int mega_print_inquiry(char *, char *);
-
-static int mega_build_sglist (adapter_t *adapter, scb_t *scb,
-			      u32 *buffer, u32 *length);
-static inline int mega_busywait_mbox (adapter_t *);
-static int __mega_busywait_mbox (adapter_t *);
-static void mega_rundoneq (adapter_t *);
-static inline void mega_cmd_done(adapter_t *, u8 [], int, int);
-static inline void mega_free_sgl (adapter_t *adapter);
-static void mega_8_to_40ld (mraid_inquiry *inquiry,
-		mega_inquiry3 *enquiry3, mega_product_info *);
-
-static int megadev_open (struct inode *, struct file *);
-static int megadev_ioctl (struct inode *, struct file *, unsigned int,
-		unsigned long);
-static int mega_m_to_n(void *, nitioctl_t *);
-static int mega_n_to_m(void *, megacmd_t *);
-
-static int mega_init_scb (adapter_t *);
-
-static int mega_is_bios_enabled (adapter_t *);
-
-#ifdef CONFIG_PROC_FS
-static void mega_create_proc_entry(int, struct proc_dir_entry *);
-static int proc_read_config(char *, char **, off_t, int, int *, void *);
-static int proc_read_stat(char *, char **, off_t, int, int *, void *);
-static int proc_read_mbox(char *, char **, off_t, int, int *, void *);
-static int proc_rebuild_rate(char *, char **, off_t, int, int *, void *);
-static int proc_battery(char *, char **, off_t, int, int *, void *);
-static int proc_pdrv_ch0(char *, char **, off_t, int, int *, void *);
-static int proc_pdrv_ch1(char *, char **, off_t, int, int *, void *);
-static int proc_pdrv_ch2(char *, char **, off_t, int, int *, void *);
-static int proc_pdrv_ch3(char *, char **, off_t, int, int *, void *);
-static int proc_pdrv(adapter_t *, char *, int);
-static int proc_rdrv_10(char *, char **, off_t, int, int *, void *);
-static int proc_rdrv_20(char *, char **, off_t, int, int *, void *);
-static int proc_rdrv_30(char *, char **, off_t, int, int *, void *);
-static int proc_rdrv_40(char *, char **, off_t, int, int *, void *);
-static int proc_rdrv(adapter_t *, char *, int, int);
-#endif
-
-static int mega_adapinq(adapter_t *, dma_addr_t);
-static int mega_internal_dev_inquiry(adapter_t *, u8, u8, dma_addr_t);
-static inline caddr_t mega_allocate_inquiry(dma_addr_t *, struct pci_dev *);
-static inline void mega_free_inquiry(caddr_t, dma_addr_t, struct pci_dev *);
-static inline int make_local_pdev(adapter_t *, struct pci_dev **);
-static inline void free_local_pdev(struct pci_dev *);
-
-static int mega_support_ext_cdb(adapter_t *);
-static mega_passthru* mega_prepare_passthru(adapter_t *, scb_t *,
-		Scsi_Cmnd *, int, int);
-static mega_ext_passthru* mega_prepare_extpassthru(adapter_t *,
-		scb_t *, Scsi_Cmnd *, int, int);
-static void mega_enum_raid_scsi(adapter_t *);
-static void mega_get_boot_drv(adapter_t *);
-static inline int mega_get_ldrv_num(adapter_t *, Scsi_Cmnd *, int);
-static int mega_support_random_del(adapter_t *);
-static int mega_del_logdrv(adapter_t *, int);
-static int mega_do_del_logdrv(adapter_t *, int);
-static void mega_get_max_sgl(adapter_t *);
-static int mega_internal_command(adapter_t *, lockscope_t, megacmd_t *,
-		mega_passthru *);
-static void mega_internal_done(Scsi_Cmnd *);
-static int mega_support_cluster(adapter_t *);
-#endif
-
-/* vi: set ts=8 sw=8 tw=78: */
diff -urNp linux-2.6.5/drivers/scsi/megaraid_clib.c linux-2.6.5.SUSE/drivers/scsi/megaraid_clib.c
--- linux-2.6.5/drivers/scsi/megaraid_clib.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/megaraid_clib.c	2004-04-27 18:45:56.000000000 +0200
@@ -0,0 +1,342 @@
+/*
+ *
+ *			Linux MegaRAID device driver
+ *
+ * Copyright (c) 2003-2004  LSI Logic Corporation.
+ *
+ *	   This program is free software; you can redistribute it and/or
+ *	   modify it under the terms of the GNU General Public License
+ *	   as published by the Free Software Foundation; either version
+ *	   2 of the License, or (at your option) any later version.
+ *
+ * FILE		: megaraid_clib.c
+ * Version	: v2.20.0 (Apr 14 2004)
+ *
+ * Libaray of common routine used by all megaraid drivers.
+ */
+
+#include "kdep.h"
+#include "mega_common.h"
+
+/*
+ * debug level - threshold for amount of information to be displayed by the
+ * driver. This level can be changed through modules parameters, ioctl or
+ * sysfs/proc interface. By default, print the announcement messages only.
+ */
+int debug_level = CL_ANN;
+MODULE_PARM(debug_level, "i");
+MODULE_PARM_DESC(debug_level, "Debug level for driver (default=0)");
+
+/**
+ * mraid_setup_device_map - manage device ids
+ * @adapter	: Driver's soft state
+ *
+ * Manange the device ids and shuffle the logical devices around if necessary
+ * so that the boot device is first to be exported
+ * The indexes are prepared so that for each channel/target requset coming
+ * from the kernel can be mapped to appropriate LD or physical device
+ **/
+void
+mraid_setup_device_map(adapter_t *adapter)
+{
+	uint8_t		c;
+	uint8_t		t;
+	uint32_t	tvar;
+
+	/*
+	 * First fill the values on the logical drive channel
+	 */
+	for (t = 0; t < LSI_MAX_LOGICAL_DRIVES_64LD; t++)
+		adapter->device_ids[adapter->max_channel][t] =
+			(t < adapter->init_id) ?  t : t - 1;
+
+	adapter->device_ids[adapter->max_channel][adapter->init_id] = 0xFF;
+
+	/*
+	 * Fill the values on the physical devices channels
+	 */
+	for (c = 0; c < adapter->max_channel; c++)
+		for (t = 0; t < LSI_MAX_LOGICAL_DRIVES_64LD; t++)
+			adapter->device_ids[c][t] = (c << 8) | t;
+	/*
+	 * If the boot device is a logical drive, then swap the boot
+	 * logical drive with the first logical drive
+	 */
+	if ((adapter->bd_channel == 0xFF) && (adapter->bd_target != 0)) {
+
+		tvar = adapter->device_ids[adapter->max_channel][adapter->bd_target];
+		adapter->device_ids[adapter->max_channel][adapter->bd_target] =
+			adapter->device_ids[adapter->max_channel][0];
+
+		adapter->device_ids[adapter->max_channel][0] = tvar;
+	}
+}
+
+
+/**
+ * mraid_get_icmd - get access rights to the internal command structure
+ * @adapter	: pointer to our soft state
+ *
+ * Synchronize access to the single internal command strucuture.
+ **/
+inline scb_t *
+mraid_get_icmd(adapter_t *adapter)
+{
+	down(&adapter->imtx);
+	return &adapter->iscb;
+}
+
+
+/**
+ * mraid_free_icmd - release access rights to the internal command structure
+ * @adapter	: pointer to our soft state
+ *
+ * Synchronize access to the single internal command strucuture.
+ **/
+inline void
+mraid_free_icmd(adapter_t *adapter)
+{
+	up(&adapter->imtx);
+}
+
+
+/**
+ * mraid_alloc_scb - detach and return a scb from the free list
+ * @adapter	: controller's soft state
+ *
+ * return the scb from the head of the free list. NULL if there are none
+ * available
+ **/
+inline scb_t *
+mraid_alloc_scb(adapter_t *adapter, struct scsi_cmnd *scp)
+{
+	struct list_head *head = &adapter->scb_pool;
+	scb_t	*scb;
+
+	/* detach scb from free pool */
+	if (!list_empty(head)) {
+
+		scb = list_entry(head->next, scb_t, list);
+		list_del_init(head->next);
+		scb->state	= SCB_ACTIVE;
+		scb->scp	= scp;
+		scb->dma_type	= MRAID_DMA_NONE;
+
+		return scb;
+	}
+
+	return NULL;
+}
+
+
+/**
+ * mraid_dealloc_scb - return the scb to the free pool
+ * @adapter	: controller's soft state
+ * @scb		: scb to be freed
+ *
+ * return the scb back to the free list of scbs. The caller must 'flush' the
+ * SCB before calling us. E.g., performing pci_unamp and/or pci_sync etc.
+ * NOTE NOTE: Make sure the scb is not on any list before calling this
+ * routine.
+ **/
+inline void
+mraid_dealloc_scb(adapter_t *adapter, scb_t *scb)
+{
+	/*
+	 * put scb in the free pool
+	 */
+	scb->state	= SCB_FREE;
+	scb->scp	= NULL;
+	list_add(&scb->list, &adapter->scb_pool);
+
+	return;
+}
+
+
+/**
+ * mraid_add_scb_to_pool - add a newly allocated SCB to the free pool
+ * @adapter	: controller's soft state
+ * @scb		: newly allocated scb to be added
+ *
+ * LLDs allocate the SCB and than add them to the free pool.
+ **/
+void
+mraid_add_scb_to_pool(adapter_t *adapter, scb_t *scb)
+{
+	list_add(&scb->list, &adapter->scb_pool);
+
+	return;
+}
+
+
+/*
+ * Library to allocate memory regions which are DMA'able
+ */
+
+/**
+ * mraid_pci_blk_pool_create - Creates a pool of pci consistent memory
+ * blocks for DMA.
+ * @dev		: pci device that will be doing the DMA
+ * @blk_count	: number of memory blocks to be created.
+ * @blk_size	: size of each blocks to be created.
+ * @blk_align	: alignment requirement for blocks; must be a power of two
+ * @blk		: array of DMA block pointers where each block information
+ * returned.
+ *
+ * Returns a pci allocation pool handle with the requested characteristics,
+ * or null if one can't be created.  mraid_pci_blk_pool_create()
+ * may be used to allocate memory.  Such memory will all have "consistent"
+ * DMA mappings, accessible by the device and its driver without using
+ * cache flushing primitives.  The actual size of blocks allocated may be
+ * larger than requested because of alignment.
+ *
+ * NOTE: This library must be used for requests less than PAGE_SIZE
+ */
+struct mraid_pci_blk_pool *
+mraid_pci_blk_pool_create(struct pci_dev *dev, size_t blk_count, size_t
+	blk_size, size_t blk_align, struct mraid_pci_blk blk[])
+{
+	struct mraid_pci_blk_pool	*pool;
+	size_t				each_blk_size = blk_size;
+	int				blks_per_page;
+	int				num_pages;
+	int				pg_idx;
+	caddr_t				page_addr;
+	dma_addr_t			tmp_dmah;
+	int				i;
+
+	if (blk_align == 0) blk_align = 1;
+
+	if (blk_count == 0 || each_blk_size == 0) return NULL;
+
+	if (each_blk_size < blk_align) {
+		each_blk_size = blk_align;
+	}
+	else if ((each_blk_size % blk_align) != 0) {
+		each_blk_size += blk_align + 1;
+		each_blk_size &= ~(blk_align - 1);
+	}
+
+	/*
+	 * each_blk_size is the actual size that we apportion for each block.
+	 * Note that each_blk_size >= blk_size
+	 *
+	 * Next task is to find the number of blocks (each_blk_size) that we
+	 * can fit in a single page.
+	 */
+	blks_per_page = PAGE_SIZE / each_blk_size;
+
+	if (!blks_per_page) {
+		con_log(CL_ANN, (KERN_WARNING
+		"megaraid: memlib request more than PAGE_SIZE buffer.\n"));
+
+		return NULL;
+	}
+
+	/*
+	 * If the number of blocks that we cat fit in a page is blks_per_page,
+	 * then the total number of pages required to accommodate "blk_count"
+	 * number of blocks is ...
+	 */
+	num_pages = ( (blk_count - 1) / blks_per_page ) + 1;
+
+	if (num_pages > MEMLIB_MAX_PAGES) {
+		con_log(CL_ANN, (KERN_WARNING
+		"megaraid: not allocating %#x pages\n", num_pages));
+
+		return NULL;
+	}
+
+	/*
+	 * Let us allocate the mraid_pci_blk_pool first. This is akin to the
+	 * handle that the client must pass back to us to deallocate memory
+	 */
+	pool = kmalloc(sizeof (struct mraid_pci_blk_pool), GFP_KERNEL);
+	if (pool == NULL) return NULL;
+
+	/*
+	 * Initialize the pool
+	 */
+	memset(pool, 0, sizeof(struct mraid_pci_blk_pool));
+	pool->page_count = num_pages;
+	pool->dev = dev;
+
+	/*
+	 * Allocate all pages in a loop
+	 */
+	for (i = 0; i < num_pages; i++) {
+
+		pool->page_arr[i] = pci_alloc_consistent( dev, PAGE_SIZE-1,
+							&pool->dmah_arr[i] );
+		if (pool->page_arr[i] == NULL) {
+			con_log(CL_ANN, (KERN_WARNING
+				"megaraid: Failed to alloc page # %d\n", i ));
+			goto memlib_fail_alloc;
+		}
+	}
+
+
+	/*
+	 * Now we have required number of pages. All we have to do is to divy
+	 * up each page into blks_per_page number of blocks
+	 */
+	pg_idx		= -1;
+	page_addr	= NULL;
+	tmp_dmah	= 0;
+
+	for (i = 0; i < blk_count; i++) {
+
+		if ((i % blks_per_page) == 0) {
+			pg_idx++;
+			page_addr	= pool->page_arr[ pg_idx ];
+			tmp_dmah	= pool->dmah_arr[ pg_idx ];
+		}
+
+		blk[i].vaddr	= page_addr;
+		blk[i].dma_addr	= tmp_dmah;
+
+		page_addr	+= each_blk_size;
+		tmp_dmah	+= each_blk_size;
+	}
+
+	return pool;
+
+memlib_fail_alloc:
+
+	mraid_pci_blk_pool_destroy( pool );
+	return NULL;
+}
+
+
+/**
+ * mraid_pci_pool_destroy - destroys a pool of pci memory blocks.
+ * @blk_pool	: pci block pool that will be destroyed
+ *
+ * Caller guarantees that no more memory from the pool is in use.
+ */
+void
+mraid_pci_blk_pool_destroy(struct mraid_pci_blk_pool *blk_pool)
+{
+	int i;
+
+	if (!blk_pool) {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid critical: null pointer for pool destroy\n"));
+		return;
+	}
+
+	for (i = 0; i < blk_pool->page_count; i++) {
+
+		if (blk_pool->page_arr[i]) {
+			pci_free_consistent( blk_pool->dev, PAGE_SIZE-1,
+						blk_pool->page_arr[i],
+						blk_pool->dmah_arr[i] );
+			blk_pool->dmah_arr[i] = 0;
+			blk_pool->page_arr[i] = NULL;
+		}
+	}
+
+	kfree( blk_pool );
+}
+
+/* vim: set ts=8 sw=8 tw=78 ai si: */
diff -urNp linux-2.6.5/drivers/scsi/megaraid_mbox.c linux-2.6.5.SUSE/drivers/scsi/megaraid_mbox.c
--- linux-2.6.5/drivers/scsi/megaraid_mbox.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/megaraid_mbox.c	2004-04-27 18:45:56.000000000 +0200
@@ -0,0 +1,4490 @@
+/*
+ *
+ *			Linux MegaRAID device driver
+ *
+ * Copyright (c) 2003-2004  LSI Logic Corporation.
+ *
+ *	   This program is free software; you can redistribute it and/or
+ *	   modify it under the terms of the GNU General Public License
+ *	   as published by the Free Software Foundation; either version
+ *	   2 of the License, or (at your option) any later version.
+ *
+ * FILE		: megaraid.c
+ * Version	: v2.20.0 (Apr 14 2004)
+ *
+ * Authors:
+ * 	Atul Mukker		<Atul.Mukker@lsil.com>
+ * 	Sreenivas Bagalkote	<Sreenivas.Bagalkote@lsil.com>
+ * 	Manoj Jose		<Manoj.Jose@lsil.com>
+ *
+ * List of supported controllers
+ *
+ * OEM	Product Name	NickName	Ser	VID	DID	SSVID	SSID
+ * ---	------------	-------		---	---	---	----	----
+ * Dell	PERC3/Di 	Discovery	N/A	1028	000E	1028	0123
+ * Dell	PERC4/SC			520	1000	1960	1028	0520
+ * Dell	PERC4/DC			518	1000	1960	1028	0518
+ * Dell	PERC4/QC			531	1000	0407	1028	0531
+ * Dell	PERC4/Di	Everglades	N/A	1028	000F	1028	014A
+ * Dell	PERC 4e/Si	Big Bend	N/A	1028	0013	1028	016c
+ * Dell	PERC 4e/Di	Kobuk		N/A	1028	0013	1028	016d
+ * Dell	PERC 4e/Di	Corvette	N/A	1028	0013	1028	016e
+ * Dell	PERC 4e/Di	Expedition	N/A	1028	0013	1028	016f
+ * Dell	PERC 4e/Di	Guadalupe	N/A	1028	0013	1028	0170
+ * Dell	PERC 4e/DC	320-2E		N/A	1000	0408	1028	0002
+ * Dell	PERC 4e/SC	320-1E		N/A	1000	0408	1028	0001
+ *
+ *
+ * LSI	MegaRAID SCSI 320-2XR		EP033	1000	0040	1000	0033
+ * 	Baracuda
+ * LSI	MegaRAID SCSI 320-2XRWS		EP066	1000	0040	1000	0066
+ * 	Low Profile
+ * LSI	MegaRAID SCSI 320-1XR
+ * 	Trinidad
+ * LSI	MegaRAID SCSI 320-0		520-0	1000	1960	1000	A520
+ * LSI	MegaRAID SCSI 320-1		520	1000	1960	1000	0520
+ * LSI	MegaRAID SCSI 320-2		518	1000	1960	1000	0518
+ * LSI	MegaRAID SCSI 320-0X	ZCR	EP055	1000	0407	1000	0530
+ * LSI	MegaRAID SCSI 320-2X		532	1000	0407	1000	0532
+ * LSI	MegaRAID SCSI 320-4X		531	1000	0407	1000	0531
+ *
+ *
+ * LSI	MegaRAID SCSI 320-1E	Aruba	N/A	1000	0408	1000	0001
+ * LSI	MegaRAID SCSI 320-2E	Cayman	EP078	1000	0408	1000	0002
+ * LSI	MegaRAID SCSI 320-4E	Bermuda
+ *
+ *
+ * LSI	MegaRAID SATA 150-2		534	1095	3112	1000	0534
+ * LSI	MegaRAID SATA 150-4		523	1000	1960	1000	4523
+ * LSI	MegaRAID SATA 150-6		523	1000	1960	1000	0523
+ * LSI	MegaRAID SATA 150-4X			1000	0409	1000	1504
+ * LSI	MegaRAID SATA 150-8X			1000	0409	1000	1508
+ *
+ * For history of changes, see changelog.megaraid
+ */
+
+#include "megaraid_mbox.h"
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int megaraid_detect(Scsi_Host_Template *);
+static int megaraid_release(struct Scsi_Host *);
+static int megaraid_shutdown_notify(struct notifier_block *, ulong, void*);
+#endif
+
+static int megaraid_init(void);
+static void megaraid_exit(void);
+
+static int megaraid_probe_one(struct pci_dev*, const struct pci_device_id*);
+static void megaraid_detach_one(struct pci_dev *);
+
+static status_t megaraid_io_attach(adapter_t *);
+static void megaraid_io_detach(adapter_t *);
+
+static status_t megaraid_setup_dma(adapter_t *);
+
+static status_t megaraid_alloc_cmd_packets(adapter_t *);
+static void megaraid_free_cmd_packets(adapter_t *);
+
+static status_t megaraid_init_mbox(adapter_t *);
+static void megaraid_fini_mbox(adapter_t *);
+
+static int megaraid_abort_handler(struct scsi_cmnd *);
+static int megaraid_reset_handler(struct scsi_cmnd *);
+static int mbox_post_sync_cmd(adapter_t *, uint8_t []);
+static int mbox_post_sync_cmd_fast(adapter_t *, uint8_t []);
+
+static status_t megaraid_mbox_product_info(adapter_t *);
+static status_t megaraid_mbox_extended_cdb(adapter_t *);
+static status_t megaraid_mbox_support_ha(adapter_t *, uint16_t *);
+static status_t megaraid_mbox_boot_enabled(adapter_t *);
+static void megaraid_mbox_get_boot_dev(adapter_t *);
+static int megaraid_mbox_get_max_sg(adapter_t *);
+
+static void megaraid_mbox_display_scb(adapter_t *, scb_t *, int);
+
+static int megaraid_queue_command(struct scsi_cmnd *,
+		void (*)(struct scsi_cmnd *));
+
+static const char *megaraid_info(struct Scsi_Host *);
+
+static inline scb_t *megaraid_mbox_build_cmd(adapter_t *, Scsi_Cmnd *, int *);
+static inline void megaraid_mbox_prepare_pthru(adapter_t *, scb_t *,
+		Scsi_Cmnd *);
+static inline void megaraid_mbox_prepare_epthru(adapter_t *, scb_t *,
+		Scsi_Cmnd *);
+static inline int megaraid_mbox_mksgl(adapter_t *, scb_t *, uint32_t *,
+		uint32_t *);
+
+static inline void megaraid_mbox_runpendq(adapter_t *);
+static inline status_t mbox_post_cmd(adapter_t *, scb_t *);
+
+static void megaraid_mbox_dpc(unsigned long);
+static inline void megaraid_mbox_free_scb(adapter_t *, scb_t *);
+
+static irqreturn_t megaraid_isr_memmapped(int, void *, struct pt_regs *);
+static irqreturn_t megaraid_isr_iomapped(int, void *, struct pt_regs *);
+
+static inline bool_t megaraid_memmbox_ack_sequence(adapter_t *);
+static inline bool_t megaraid_iombox_ack_sequence(adapter_t *);
+
+static inline status_t megaraid_busywait_mbox(mraid_device_t *);
+static inline status_t __megaraid_busywait_mbox(mraid_device_t *);
+
+static status_t megaraid_cmm_register(adapter_t *);
+static status_t megaraid_cmm_unregister(adapter_t *);
+static int megaraid_mbox_mm_cmd(ulong, uioc_t*, uint32_t);
+static int megaraid_mbox_internal_command(adapter_t *, uioc_t *);
+static void megaraid_mbox_internal_done(Scsi_Cmnd *);
+static int gather_hbainfo(adapter_t *, mraid_hba_info_t *);
+static void megaraid_update_logdrv_ids(adapter_t*);
+static int wait_till_fw_empty(adapter_t*);
+
+
+
+MODULE_AUTHOR("LSI Logic Corporation");
+MODULE_DESCRIPTION("LSI Logic MegaRAID unified driver");
+MODULE_LICENSE("GPL");
+
+/*
+ * ### modules parameters for driver ###
+ */
+
+/*
+ * Set to enable driver to expose unconfigured disk to kernel
+ */
+static int expose_unconf_disks = 0;
+MODULE_PARM(expose_unconf_disks, "i");
+MODULE_PARM_DESC(expose_unconf_disks,
+	"Set to expose unconfigured disks to kernel (default=0)");
+
+/**
+ * driver wait time if the adapter's mailbox is busy
+ */
+static unsigned int max_mbox_busy_wait = MBOX_BUSY_WAIT;
+MODULE_PARM(max_mbox_busy_wait, "i");
+MODULE_PARM_DESC(max_mbox_busy_wait,
+	"Max wait for mailbox in microseconds if busy (default=10)");
+
+/**
+ * number of sectors per IO command
+ */
+static unsigned int megaraid_max_sectors = MBOX_MAX_SECTORS;
+MODULE_PARM(megaraid_max_sectors, "i");
+MODULE_PARM_DESC(megaraid_max_sectors,
+	"Maximum number of sectors per IO command (default=128)");
+
+/**
+ * number of commands supported by the driver
+ */
+static unsigned int megaraid_driver_cmds = MBOX_MAX_DRIVER_CMDS;
+MODULE_PARM(megaraid_driver_cmds, "i");
+MODULE_PARM_DESC(megaraid_driver_cmds,
+	"Maximum number of commands supported by the driver (default=190)");
+
+
+/**
+ * number of commands per logical unit
+ */
+static unsigned int megaraid_cmd_per_lun = MBOX_MAX_DRIVER_CMDS;
+MODULE_PARM(megaraid_cmd_per_lun, "i");
+MODULE_PARM_DESC(megaraid_cmd_per_lun,
+	"Maximum number of commands per logical unit (default=190)");
+
+
+/**
+ * Fast driver load option, skip scanning for physical devices during load.
+ * This would result in non-disk devices being skipped during driver load
+ * time. These can be later added though, using /proc/scsi/scsi
+ */
+static unsigned int megaraid_fast_load = 0;
+MODULE_PARM(megaraid_fast_load, "i");
+MODULE_PARM_DESC(megaraid_fast_load,
+	"Faster loading of the driver, skips physical devices! (default=0)");
+
+
+/*
+ * ### global data ###
+ */
+mraid_driver_t mraid_driver_g = {
+	.driver_version	= { 0x20, 0x01, 0x02, 0x00, 1, 19, 20, 4},
+};
+
+
+/*
+ * PCI table for all supported controllers.
+ */
+static struct pci_device_id pci_id_table_g[] =  {
+	{
+		.vendor		= PCI_VENDOR_ID_LSI_LOGIC,
+		.device		= PCI_DEVICE_ID_MEGARAID_SATA_PCIX,
+		.subvendor	= PCI_ANY_ID,
+		.subdevice	= PCI_ANY_ID,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+		.driver_data	= MBOX_FLAGS_64BIT
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_DELL,
+		.device		= PCI_DEVICE_ID_PERC4E_SI_DI,
+		.subvendor	= PCI_ANY_ID,
+		.subdevice	= PCI_ANY_ID,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+		.driver_data	= MBOX_FLAGS_64BIT
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_LSI_LOGIC,
+		.device		= PCI_DEVICE_ID_PERC4E_DC_SC,
+		.subvendor	= PCI_ANY_ID,
+		.subdevice	= PCI_ANY_ID,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+		.driver_data	= MBOX_FLAGS_64BIT
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_DELL,
+		.device		= PCI_DEVICE_ID_DISCOVERY,
+		.subvendor	= PCI_ANY_ID,
+		.subdevice	= PCI_ANY_ID,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+		.driver_data	= 0
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_DELL,
+		.device		= PCI_DEVICE_ID_PERC4_DI,
+		.subvendor	= PCI_ANY_ID,
+		.subdevice	= PCI_ANY_ID,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+		.driver_data	= MBOX_FLAGS_64BIT
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_LSI_LOGIC,
+		.device		= PCI_DEVICE_ID_PERC4_QC_VERDE,
+		.subvendor	= PCI_ANY_ID,
+		.subdevice	= PCI_ANY_ID,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+		.driver_data	= MBOX_FLAGS_64BIT
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_AMI,
+		.device		= PCI_DEVICE_ID_AMI_MEGARAID,
+		.subvendor	= PCI_ANY_ID,
+		.subdevice	= PCI_ANY_ID,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+		.driver_data	= 0
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_AMI,
+		.device		= PCI_DEVICE_ID_AMI_MEGARAID2,
+		.subvendor	= PCI_ANY_ID,
+		.subdevice	= PCI_ANY_ID,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+		.driver_data	= 0
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_AMI,
+		.device		= PCI_DEVICE_ID_AMI_MEGARAID3,
+		.subvendor	= PCI_ANY_ID,
+		.subdevice	= PCI_ANY_ID,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+		.driver_data	= 0
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_INTEL,
+		.device		= PCI_DEVICE_ID_AMI_MEGARAID3,
+		.subvendor	= PCI_ANY_ID,
+		.subdevice	= PCI_ANY_ID,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+		.driver_data	= 0
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_LSI_LOGIC,
+		.device		= PCI_DEVICE_ID_AMI_MEGARAID3,
+		.subvendor	= PCI_ANY_ID,
+		.subdevice	= PCI_ANY_ID,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+		.driver_data	= 0
+	},
+	{0}	/* Terminating entry */
+};
+MODULE_DEVICE_TABLE(pci, pci_id_table_g);
+
+
+// lk 2.6 TODO: Add the shutdown routine
+static struct pci_driver megaraid_pci_driver_g = {
+	.name		= "megaraid",
+	.id_table	= pci_id_table_g,
+	.probe		= megaraid_probe_one,
+	.remove		= __devexit_p(megaraid_detach_one),
+#if 0
+	.driver		= {
+		.shutdown = mraid_shutdown
+	}
+#endif
+};
+
+/*
+ * ### START: LK 2.4 compatibility layer ###
+ *
+ * This layer only accounts for lk 2.4 and lk 2.6, not for, e.g. lk 2.5
+ */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+
+/*
+ * Scsi host template for megaraid unified driver
+ */
+#define MRAID_TEMPLATE							\
+{									\
+	.module				= THIS_MODULE,			\
+	.name				= "MegaRAID",			\
+	.proc_name			= "megaraid",			\
+	.info				= megaraid_info,		\
+	.queuecommand			= megaraid_queue_command,	\
+	.eh_abort_handler		= megaraid_abort_handler,	\
+	.eh_device_reset_handler	= megaraid_reset_handler,	\
+	.eh_bus_reset_handler		= megaraid_reset_handler,	\
+	.eh_host_reset_handler		= megaraid_reset_handler,	\
+	.use_clustering			= ENABLE_CLUSTERING,		\
+}
+
+#else	// lk 2.4
+
+#define MRAID_TEMPLATE							\
+{									\
+	.name				= "MegaRAID",			\
+	.proc_name			= "megaraid",			\
+	.info				= megaraid_info,		\
+	.queuecommand			= megaraid_queue_command,	\
+	.eh_abort_handler		= megaraid_abort_handler,	\
+	.eh_device_reset_handler	= megaraid_reset_handler,	\
+	.eh_bus_reset_handler		= megaraid_reset_handler,	\
+	.eh_host_reset_handler		= megaraid_reset_handler,	\
+	.use_clustering			= ENABLE_CLUSTERING,		\
+	.use_new_eh_code		= 1,				\
+	.highmem_io			= 1,				\
+	.vary_io			= 1,				\
+	.detect				= megaraid_detect,		\
+	.release			= megaraid_release,		\
+}
+
+static struct notifier_block megaraid_shutdown_notifier = {
+	.notifier_call = megaraid_shutdown_notify
+};
+#endif
+
+static Scsi_Host_Template megaraid_template_g = MRAID_TEMPLATE;
+static Scsi_Host_Template *megaraid_template_gp = &megaraid_template_g;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+/**
+ * megaraid_detect - old-style detect
+ * @param host_template	: megaraid host template
+ *
+ * This is called with the old-sytle driver load interface.  We simply call
+ * the new-style driver load entry point and return number of active
+ * controllers to mid-layer.
+ * We will need to override the location of the template since the old-style
+ * drivers rely of "driver_template" to be defined by the drivers.
+ */
+static int __init
+megaraid_detect(Scsi_Host_Template *host_template)
+{
+	// override the template for old-style interface
+	megaraid_template_gp = host_template;
+
+	megaraid_init();	// module entry point for new drivers
+
+	/*
+	 * Register the Shutdown Notification hook in kernel
+	 */
+	if (register_reboot_notifier(&megaraid_shutdown_notifier)) {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: shutdown notification not registered.\n"));
+	}
+
+	return mraid_driver_g.attach_count;
+}
+
+
+/**
+ * megaraid_release - old-style release
+ * @param host	: host to be released
+ *
+ * This is called with the old-sytle driver unload interface. We call the
+ * corresponding detach routine. When the attach counter goes down to 0, call
+ * the new-style module exit point. While calling this exit routine, we rely
+ * on the fact that the mraid_device_t device list has been initialized to
+ * NULL and traversing this list in the new-style exit point will have no
+ * effect.
+ */
+static int
+megaraid_release(struct Scsi_Host *host)
+{
+	adapter_t		*adapter;
+
+	con_log(CL_DLEVEL1, (KERN_NOTICE "megaraid: release.\n"));
+
+	adapter = SCSIHOST2ADAP(host);
+
+	megaraid_detach_one(adapter->pdev);
+
+	if (mraid_driver_g.attach_count == 0) {
+		unregister_reboot_notifier(&megaraid_shutdown_notifier);
+		megaraid_exit();
+	}
+
+	return 0;
+}
+
+
+/**
+ * megaraid_shutdown_notify - shutdown notification hook
+ * @param this		: unused
+ * @param code		: shutdown code
+ * @param unused	: unused
+ *
+ * This routine will be called when the use has done a forced shutdown on the
+ * system. Invoke the appropriate LLD's shutdown notification entry point
+ */
+static int
+megaraid_shutdown_notify (struct notifier_block *this, unsigned long code,
+		void *unused)
+{
+	adapter_t		*adapter;
+	struct list_head	*pos, *next;
+	int			i;
+
+	/*
+	 * Invoke the LLD's shutdown notification hook for all possible
+	 * shutdown codes: SYS_DOWN, SYS_HALT, SYS_RESTART, SYS_POWER_OFF
+	 */
+	list_for_each_safe(pos, next, &mraid_driver_g.device_list) {
+
+		adapter = list_entry(pos, adapter_t, list);
+
+		// FIXME: Add shutdown notification
+	}
+
+	/*
+	 * Have a delibrate delay to make sure all the caches are actually
+	 * flushed.
+	 */
+	con_log(CL_ANN, (KERN_INFO "megaraid: cache flush delay:   "));
+	for (i = 9; i >= 0; i--) {
+		con_log(CL_ANN, ("\b\b\b[%d]", i));
+		mdelay(1000);
+	}
+	con_log(CL_ANN, ("\b\b\b[done]\n"));
+	mdelay(1000);
+
+	return NOTIFY_OK;
+}
+#endif
+/*
+ * ### END: LK 2.4 compatibility layer ###
+ */
+
+/**
+ * megaraid_init - module load hook
+ *
+ * We register ourselves as hotplug enabled module and let PCI subsystem
+ * discover our adaters
+ **/
+static int __init
+megaraid_init(void)
+{
+	int			rval;
+
+	// Announce the driver version
+	con_log(CL_ANN, (KERN_INFO "megaraid: %s\n", MEGARAID_VERSION));
+
+	// check validity of module parameters
+	if (megaraid_driver_cmds > MBOX_MAX_DRIVER_CMDS) {
+
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid mailbox: max commands reset to %d\n",
+			MBOX_MAX_DRIVER_CMDS));
+
+		megaraid_driver_cmds = MBOX_MAX_DRIVER_CMDS;
+	}
+
+	if (megaraid_cmd_per_lun > MBOX_MAX_DRIVER_CMDS) {
+
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid mailbox: max commands per lun reset to %d\n",
+			MBOX_MAX_DRIVER_CMDS));
+
+		megaraid_cmd_per_lun = MBOX_MAX_DRIVER_CMDS;
+	}
+
+
+	/*
+	 * Setup the driver global data structures
+	 */
+	INIT_LIST_HEAD(&mraid_driver_g.device_list);
+
+	// register as a PCI hot-plug driver module
+	if ((rval = pci_module_init(&megaraid_pci_driver_g))) {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: could not register hotplug support.\n"));
+	}
+
+	// FIXME
+	SET_PRV_INTF_AVAILABLE();
+
+	return rval;
+}
+
+
+/**
+ * megaraid_exit - driver unload entry point
+ *
+ * We simply unwrap the megaraid_init routine here
+ */
+static void __exit
+megaraid_exit(void)
+{
+	con_log(CL_DLEVEL1, (KERN_NOTICE "megaraid: unloading framework\n"));
+
+	SET_PRV_INTF_UNAVAILABLE();
+
+	// unregister as PCI hotplug driver
+	pci_unregister_driver(&megaraid_pci_driver_g);
+
+	// All adapters must be detached by now
+	try_assertion {
+		ASSERT(list_empty(&mraid_driver_g.device_list));
+	}
+	catch_assertion {
+		con_log(CL_ANN, (KERN_CRIT
+		"megaraid panic: not all adapters are released\n"));
+
+		BUG();
+	}
+	end_assertion
+
+	return;
+}
+
+
+/**
+ * megaraid_probe_one - PCI hotplug entry point
+ * @param pdev	: handle to this controller's PCI configuration space
+ * @param id	: pci device id of the class of controllers
+ *
+ * This routine should be called whenever a new adapter is detected by the
+ * PCI hotplug susbsytem.
+ **/
+static int __devinit
+megaraid_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
+{
+	adapter_t	*adapter;
+	status_t	rval;
+	uint16_t	subsysvid;
+	uint32_t	unique_id;
+	int		i;
+
+
+	// Make sure this adapter is not already setup
+	unique_id	= pdev->bus->number << 8 | pdev->devfn;
+
+	for (i = 0; i < mraid_driver_g.attach_count; i++) {
+		if (mraid_driver_g.adapter[i]->unique_id == unique_id) {
+
+			con_log(CL_ANN, (KERN_WARNING
+				"megaraid: reject re-init request for dev: "));
+
+			con_log(CL_ANN, ("%#4.04x:%#4.04x:%#4.04x:%#4.04x:",
+				pdev->vendor, pdev->device,
+				pdev->subsystem_vendor,
+				pdev->subsystem_device));
+
+			con_log(CL_ANN, ("bus %d:slot %d:func %d\n",
+				pdev->bus->number, PCI_SLOT(pdev->devfn),
+				PCI_FUNC(pdev->devfn)));
+
+			return -ENODEV;	// already initialized
+		}
+	}
+
+
+	// detected a new controller
+	con_log(CL_ANN, (KERN_INFO
+		"megaraid: probe new device %#4.04x:%#4.04x:%#4.04x:%#4.04x: ",
+		pdev->vendor, pdev->device, pdev->subsystem_vendor,
+		pdev->subsystem_device));
+
+	con_log(CL_ANN, ("bus %d:slot %d:func %d\n", pdev->bus->number,
+		PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn)));
+
+	/*
+	 * If we do not find a valid subsys vendor id, refuse to load the
+	 * driver.
+	 */
+	subsysvid = pdev->subsystem_vendor;
+
+	if (subsysvid && (subsysvid != PCI_VENDOR_ID_AMI) &&
+			(subsysvid != PCI_VENDOR_ID_DELL) &&
+			(subsysvid != PCI_VENDOR_ID_HP) &&
+			(subsysvid != PCI_VENDOR_ID_INTEL) &&
+			(subsysvid != PCI_SUBSYS_ID_FSC) &&
+			(subsysvid != PCI_VENDOR_ID_LSI_LOGIC)) {
+
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: not loading for subsysvid:%#4.04x\n",
+			subsysvid));
+
+		return -ENODEV;
+	}
+
+	if (pci_enable_device(pdev)) {
+		con_log(CL_ANN, (KERN_WARNING
+				"megaraid: pci_enable_device failed.\n"));
+		return -ENODEV;
+	}
+
+	// Enable bus-mastering on this controller
+	// FIXME: should this be done in adapter specific code?
+	pci_set_master(pdev);
+
+	/*
+	 * Allocate the per driver initialization structure
+	 */
+	adapter = kmalloc(sizeof(adapter_t), GFP_KERNEL);
+
+	if (adapter == NULL) {
+		con_log(CL_ANN, (KERN_WARNING
+		"megaraid: out of memory, %s %d.\n", __FUNCTION__, __LINE__));
+
+		pci_disable_device(pdev);
+
+		return -ENODEV;
+	}
+	memset(adapter, 0, sizeof(adapter_t));
+
+
+	// set up PCI related soft state and other pre-known parameters
+	adapter->unique_id	= unique_id;
+	adapter->irq		= pdev->irq;
+	adapter->pci_id		= id;
+	adapter->pdev		= pdev;
+
+	atomic_set(&adapter->being_detached, 0);
+
+	// Setup the default DMA mask. This would be changed later on
+	// depending on hardware capabilities
+	if (pci_set_dma_mask(adapter->pdev, 0xFFFFFFFF) != 0) {
+
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: pci_set_dma_mask failed:%d\n", __LINE__));
+
+		kfree(adapter);
+
+		pci_disable_device(pdev);
+
+		return -ENODEV;
+	}
+
+
+	// Initialize the synchronization lock for kernel and LLD
+	spin_lock_init(&adapter->lock);
+	adapter->host_lock = &adapter->lock;
+
+
+	// Setup resources to issue internal commands with interrupts availble
+	init_MUTEX(&adapter->imtx);
+	init_waitqueue_head(&adapter->iwq);
+
+
+	// Initialize the command queues: the list of free SCBs and the list
+	// of pending SCBs.
+	INIT_LIST_HEAD(&adapter->scb_pool);
+	INIT_LIST_HEAD(&adapter->pend_list);
+	INIT_LIST_HEAD(&adapter->completed_list);
+
+
+	// Start the mailbox based controller
+	if (megaraid_init_mbox(adapter) != MRAID_SUCCESS) {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: maibox adapter did not initialize\n"));
+
+		kfree(adapter);
+
+		pci_disable_device(pdev);
+
+		return -ENODEV;
+	}
+
+	// attach with scsi mid-layer
+	rval = megaraid_io_attach(adapter);
+
+	if (rval != MRAID_SUCCESS) {
+
+		megaraid_fini_mbox(adapter);
+
+		kfree(adapter);
+
+		pci_disable_device(pdev);
+
+		return -ENODEV;
+	}
+
+	/*
+	 * We maintain an index of each adapter's soft state for application
+	 * access path
+	 */
+	for (i = 0; i < MAX_CONTROLLERS; i++) {
+		if (mraid_driver_g.adapter[i] == NULL) {
+			mraid_driver_g.adapter[i] = adapter;
+			adapter->slot = i;
+			break;
+		}
+	}
+	if (i == MAX_CONTROLLERS) {	// paranoia :-)
+		con_log(CL_ANN, (KERN_WARNING "megaraid: too many HBAs.\n"));
+
+		megaraid_fini_mbox(adapter);
+
+		kfree(adapter);
+
+		pci_disable_device(pdev);
+
+		return -ENODEV;
+	}
+
+	/*
+	 * Register with LSI Common Management Module
+	 */
+	if (megaraid_cmm_register(adapter) != MRAID_SUCCESS) {
+		con_log(CL_ANN, (KERN_WARNING
+		"megaraid: could not register with management module\n"));
+		// continue loading
+	}
+
+	/*
+	 * successfully attached this driver. Increment the device counter and
+	 * display interesting facts about the driver.
+	 */
+	mraid_driver_g.attach_count++;
+
+	// setup adapter handle in PCI soft state
+	pci_set_drvdata(pdev, adapter);
+
+	// put the adapter in the global list of our controllers
+	list_add_tail(&adapter->list, &mraid_driver_g.device_list);
+
+	con_log(CL_ANN, (KERN_NOTICE
+		"megaraid: fw version:[%s] bios version:[%s]\n",
+		adapter->fw_version, adapter->bios_version));
+
+	return 0;
+}
+
+
+/**
+ * megaraid_detach_one - release the framework resources and call LLD release
+ * routine
+ * @param pdev	: handle for our PCI cofiguration space
+ *
+ * This routine is called during driver unload. We free all the allocated
+ * resources and call the corresponding LLD so that it can also release all
+ * its resources.
+ *
+ * This routine is also called from the PCI hotplug system
+ **/
+static void
+megaraid_detach_one(struct pci_dev *pdev)
+{
+	adapter_t	*adapter;
+
+
+	// Start a rollback on this adapter
+	adapter = pci_get_drvdata(pdev);
+
+
+	// Make sure we don't break for multiple detach(?) for a controller
+	if (!adapter) {
+		con_log(CL_DLEVEL1, (KERN_CRIT
+		"megaraid: Invalid detach on %#4.04x:%#4.04x:%#4.04x:%#4.04x\n",
+			pdev->vendor, pdev->device, pdev->subsystem_vendor,
+			pdev->subsystem_device));
+
+		return;
+	}
+	else {
+		con_log(CL_ANN, (KERN_NOTICE
+		"megaraid: detaching device %#4.04x:%#4.04x:%#4.04x:%#4.04x\n",
+			pdev->vendor, pdev->device, pdev->subsystem_vendor,
+			pdev->subsystem_device));
+	}
+
+
+	// do not allow any more requests from the management module for this
+	// adapter.
+	// FIXME: How do we account for the request which might still be
+	// pending with us?
+	atomic_set(&adapter->being_detached, 1);
+
+	// remove the adapter from the global list of our controllers
+	list_del_init(&adapter->list);
+
+	// reset the device state in the PCI structure. We check this
+	// condition when we enter here. If the device state is NULL,
+	// that would mean the device has already been removed
+	pci_set_drvdata(pdev, NULL);
+
+	mraid_driver_g.attach_count--;
+
+
+	// Make sure we are unloading the right adapter
+	if (mraid_driver_g.adapter[adapter->slot] != adapter) {
+		con_log(CL_ANN, (KERN_CRIT
+			"megaraid: invalid device handle:%s:%d.\n",
+			__FILE__, __LINE__));
+		BUG();
+	}
+	mraid_driver_g.adapter[adapter->slot] = NULL;
+
+	/*
+	 * Unregister from common management module
+	 *
+	 * FIXME: this must return success or failure for conditions if there
+	 * is a command pending with LLD or not.
+	 */
+	megaraid_cmm_unregister(adapter);
+
+	megaraid_io_detach(adapter);
+
+	// finalize the mailbox based controller
+	megaraid_fini_mbox(adapter);
+
+	kfree(adapter);
+
+	pci_disable_device(pdev);
+
+	return;
+}
+
+
+/**
+ * megaraid_io_attach - attach a device with the IO subsystem
+ * @param adapter	: controller's soft state
+ *
+ * Attach this device with the IO subsystem
+ **/
+static status_t
+megaraid_io_attach(adapter_t *adapter)
+{
+	struct Scsi_Host	*host;
+
+	// Initialize SCSI Host structure
+	host = mraid_scsi_host_alloc(megaraid_template_gp, 8);
+	if (!host) {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: scsi_register failed.\n"));
+
+		return MRAID_FAILURE;
+	}
+
+	SCSIHOST2ADAP(host)	= adapter;
+	adapter->host		= host;
+
+	// export the parameters required by the mid-layer
+	mraid_set_host_lock(host, adapter->host_lock);
+	mraid_scsi_set_pdev(host, adapter->pdev);
+
+	host->irq		= adapter->irq;
+	host->unique_id		= adapter->unique_id;
+	host->can_queue		= adapter->max_cmds;
+	host->this_id		= adapter->init_id;
+	host->sg_tablesize	= adapter->sglen;
+	host->max_sectors	= adapter->max_sectors;
+	host->cmd_per_lun	= adapter->cmd_per_lun;
+	host->max_channel	= adapter->max_channel;
+	host->max_id		= adapter->max_target;
+	host->max_lun		= adapter->max_lun;
+
+
+	// notify mid-layer about the new controller
+	if (scsi_add_host(host, &adapter->pdev->dev)) {
+
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: scsi_add_host failed.\n"));
+
+		mraid_scsi_host_dealloc(host);
+
+		return MRAID_FAILURE;
+	}
+
+	scsi_scan_host(host);
+
+	return MRAID_SUCCESS;
+}
+
+
+/**
+ * megaraid_io_detach - detach a device from the IO subsystem
+ * @param adapter	: controller's soft state
+ *
+ * Detach this device from the IO subsystem
+ **/
+static void
+megaraid_io_detach(adapter_t *adapter)
+{
+	struct Scsi_Host	*host;
+
+	con_log(CL_DLEVEL1, (KERN_INFO "megaraid: io detach\n"));
+
+	host = adapter->host;
+
+	scsi_remove_host(host);
+
+	mraid_scsi_host_dealloc(host);
+
+	return;
+}
+
+
+/**
+ * megaraid_info - information string about the driver
+ * @host	: megaraid host
+ *
+ * returns a descriptive string about the driver
+ **/
+static const char *
+megaraid_info(struct Scsi_Host *host)
+{
+	return "LSI Logic Corporation MegaRAID driver";
+}
+
+
+/**
+ * megaraid_setup_dma - setup appropriate DMA masks
+ * @param adapter	: controller's soft state
+ *
+ * This routine would setup the appropriate DMA masks. This would be called
+ * after the controller's capabilities have been determined
+ *
+ * Retrun:	MRAID_SUCCESS, if some DMA mask was set
+ *		MRAID_FAILURE, if DMA mask could not be set
+ */
+static status_t
+megaraid_setup_dma(adapter_t *adapter)
+{
+	/*
+	 * Set the mask to do DMA in 64-bit range if supported by firmware and
+	 * kernel
+	 */
+	adapter->highmem_dma = MRAID_FALSE;
+	if ((adapter->flags & MRAID_DMA_64) && (sizeof(dma_addr_t) == 8)) {
+
+		if (pci_set_dma_mask(adapter->pdev, 0xFFFFFFFFFFFFFFFFULL)
+				!= 0) {
+
+			con_log(CL_ANN, (KERN_WARNING
+			"megaraid: could not set DMA mask for 64-bit.\n"));
+
+			adapter->highmem_dma = MRAID_FALSE;
+		}
+		else {
+			adapter->highmem_dma = MRAID_TRUE;
+		}
+	}
+	if (adapter->highmem_dma == MRAID_FALSE) {
+		if (pci_set_dma_mask(adapter->pdev, 0xFFFFFFFF) != 0) {
+
+			con_log(CL_ANN, (KERN_WARNING
+				"megaraid: pci_set_dma_mask failed:%d\n",
+				__LINE__));
+
+			return MRAID_FAILURE;
+		}
+		con_log(CL_DLEVEL1, (KERN_NOTICE
+			"megaraid: not supporting 64-bit addressing [%d:%d]\n",
+			adapter->highmem_dma, (int)sizeof(dma_addr_t)));
+	}
+	else {
+		con_log(CL_DLEVEL1, (KERN_NOTICE
+			"megaraid: supporting 64-bit addressing [%d:%d]\n",
+			adapter->highmem_dma, (int)sizeof(dma_addr_t)));
+	}
+
+	return MRAID_SUCCESS;
+}
+
+
+/*
+ * START: Mailbox Low Level Driver
+ *
+ * This is section specific to the single mailbox based controllers
+ */
+
+/**
+ * megaraid_init_mbox - initialize controller
+ * @param adapter	- our soft state
+ *
+ * . Allocate 16-byte aligned mailbox memory for firmware handshake
+ * . Allocate controller's memory resources
+ * . Find out all initialization data
+ * . Allocate memory required for all the commands
+ * . Use internal library of FW routines, build up complete soft state
+ */
+static status_t __init
+megaraid_init_mbox(adapter_t *adapter)
+{
+	struct pci_dev		*pdev;
+	mraid_device_t		*raid_dev;
+	uint32_t		magic64;
+	bool_t			mem_region_f	= MRAID_FALSE;
+	bool_t			alloc_cmds_f	= MRAID_FALSE;
+	bool_t			irq_f		= MRAID_FALSE;
+
+
+	adapter->quiescent	= MRAID_FALSE;
+	adapter->ito		= MBOX_TIMEOUT;
+
+	pdev = adapter->pdev;
+
+	/*
+	 * Allocate and initialize the init data structure for mailbox
+	 * controllers
+	 */
+	raid_dev = kmalloc(sizeof(mraid_device_t), GFP_KERNEL);
+	if (raid_dev == NULL) return MRAID_FAILURE;
+
+	memset(raid_dev, 0, sizeof(mraid_device_t));
+
+	/*
+	 * Attach the adapter soft state is raid device soft state
+	 */
+	adapter->raid_device = (caddr_t)raid_dev;
+
+
+	// our baseport
+	raid_dev->baseport = pci_resource_start(pdev, 0);
+
+	/*
+	 * Check for IO mapped controller
+	 */
+	if (pci_resource_flags(pdev, 0) & IORESOURCE_IO) {
+
+		adapter->flags |= MRAID_BOARD_IOMAP;
+
+		raid_dev->baseaddr = raid_dev->baseport + 0x10;
+
+		if (!request_region(raid_dev->baseaddr, 16, "megaraid")) {
+			con_log(CL_ANN, (KERN_WARNING
+				"megaraid: could not claim IO region\n") );
+			goto fail_init;
+		}
+
+		outb_p(ENABLE_MBOX_BYTE, raid_dev->baseport +
+				ENABLE_MBOX_REGION);
+
+		iombox_irq_ack(raid_dev);
+
+		iombox_irq_enable(raid_dev);
+
+	}
+	else {
+
+		/*
+		 * Memory mapped controllers.
+		 */
+		adapter->flags |= MRAID_BOARD_MEMMAP;
+
+		if (!request_mem_region(raid_dev->baseport, 128,
+				"MegaRAID: LSI Logic Corporation")) {
+
+			con_log(CL_ANN, (KERN_WARNING
+					"megaraid: mem region busy\n"));
+
+			goto fail_init;
+		}
+
+		raid_dev->baseaddr = (unsigned long)
+				ioremap_nocache(raid_dev->baseport, 128);
+
+		if (!raid_dev->baseaddr) {
+
+			con_log(CL_ANN, (KERN_WARNING
+				"megaraid: could not map hba memory\n") );
+
+			release_mem_region(raid_dev->baseport, 128);
+
+			goto fail_init;
+		}
+	}
+	mem_region_f = MRAID_TRUE;
+
+	/*
+	 * Does this firmware support DMA in high memory
+	 *
+	 * For these vendor and device ids, signature offsets are not valid
+	 * and 64-bit is implicit
+	 */
+	if (adapter->pci_id->driver_data & MBOX_FLAGS_64BIT) {
+		adapter->flags |= MRAID_DMA_64;
+	}
+	else {
+		pci_read_config_dword(pdev, SIGN_OFFSET_64BIT, &magic64);
+
+		if (magic64 == HBA_SIGNATURE_64BIT)
+			adapter->flags |= MRAID_DMA_64;
+	}
+
+	//
+	// Setup the rest of the soft state using the library of FW routines
+	//
+
+	// request IRQ and register the interrupt service routine
+	if (request_irq(adapter->irq, (adapter->flags & MRAID_BOARD_MEMMAP) ?
+		megaraid_isr_memmapped : megaraid_isr_iomapped, SA_SHIRQ,
+		"megaraid", adapter)) {
+
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: Couldn't register IRQ %d!\n", adapter->irq));
+
+		goto fail_init;
+	}
+
+	irq_f = MRAID_TRUE;
+
+
+	// allocate memory required for commands
+	if (megaraid_alloc_cmd_packets(adapter) != MRAID_SUCCESS) {
+		goto fail_init;
+	}
+	alloc_cmds_f = MRAID_TRUE;
+
+	// Product info
+	if (megaraid_mbox_product_info(adapter) != MRAID_SUCCESS) {
+		goto fail_init;
+	}
+
+	// Do we support extended CDBs
+	adapter->max_cdb_sz = 10;
+	if (megaraid_mbox_extended_cdb(adapter) == MRAID_SUCCESS) {
+		adapter->max_cdb_sz = 16;
+	}
+
+	/*
+	 * Do we support cluster environment, if we do, what is the initiator
+	 * id.
+	 * NOTE: In a non-cluster aware firmware environment, the LLD should
+	 * return 7 as initiator id.
+	 */
+	adapter->ha		= MRAID_FALSE;
+	adapter->init_id	= -1;
+	if (megaraid_mbox_support_ha(adapter, &adapter->init_id) ==
+			MRAID_SUCCESS) {
+		adapter->ha = MRAID_TRUE;
+	}
+
+	/*
+	 * Check if the user has enabled BIOS on this controller.
+	 */
+	if (megaraid_mbox_boot_enabled(adapter) == MRAID_SUCCESS) {
+		/*
+		 * Find out our boot device. This routine will also setup the
+		 * appropriate meta data for us.
+		 */
+		megaraid_mbox_get_boot_dev(adapter);
+	}
+
+	/*
+	 * find out the maximum number of scatter-gather elements supported by
+	 * this firmware
+	 */
+	adapter->sglen = megaraid_mbox_get_max_sg(adapter);
+
+	/*
+	 * Other parameters required by upper layer
+	 *
+	 * maximum number of sectors per IO command
+	 */
+	adapter->max_sectors = megaraid_max_sectors;
+
+	/*
+	 * number of queued commands per LUN.
+	 */
+	adapter->cmd_per_lun = megaraid_cmd_per_lun;
+
+	if (megaraid_setup_dma(adapter) != MRAID_SUCCESS) {
+		goto fail_init;
+	}
+
+	// setup tasklet for DPC
+	tasklet_init(&adapter->dpc_h, megaraid_mbox_dpc,
+			(unsigned long)adapter);
+
+	con_log(CL_DLEVEL1, (KERN_INFO
+		"megaraid mbox hba successfully initialized\n"));
+
+	return MRAID_SUCCESS;
+
+fail_init:
+	if (alloc_cmds_f) {
+		megaraid_free_cmd_packets(adapter);
+	}
+	if (irq_f == MRAID_TRUE) {
+		free_irq(adapter->irq, adapter);
+	}
+	if (mem_region_f) {
+		if (adapter->flags & MRAID_BOARD_MEMMAP) {
+			iounmap((caddr_t)raid_dev->baseaddr);
+			release_mem_region(raid_dev->baseport, 128);
+		}
+		else {
+			release_region(raid_dev->baseaddr, 16);
+		}
+	}
+
+	kfree(raid_dev);
+
+	return MRAID_FAILURE;
+}
+
+
+/**
+ * megaraid_fini_mbox - undo controller initialization
+ * @param adapter	- our soft state
+ */
+static void
+megaraid_fini_mbox(adapter_t *adapter)
+{
+	mraid_device_t *raid_dev = ADAP2RAIDDEV(adapter);
+
+	megaraid_free_cmd_packets(adapter);
+
+	free_irq(adapter->irq, adapter);
+
+	if (adapter->flags & MRAID_BOARD_MEMMAP) {
+
+		iounmap((caddr_t)raid_dev->baseaddr);
+
+		release_mem_region(raid_dev->baseport, 128);
+	}
+	else {
+		release_region(raid_dev->baseaddr, 16);
+	}
+
+	kfree(raid_dev);
+
+	return;
+}
+
+
+/**
+ * megaraid_alloc_cmd_packets - allocate shared mailbox
+ * @param adapter	: soft state of the raid controller
+ *
+ * Allocate and align the shared mailbox. This maibox is used to issue
+ * all the commands. For IO based controllers, the mailbox is also regsitered
+ * with the FW. Allocate memory for all commands as well.
+ * This is our big allocator
+ */
+static status_t
+megaraid_alloc_cmd_packets(adapter_t *adapter)
+{
+	mraid_device_t		*raid_dev = ADAP2RAIDDEV(adapter);
+	struct pci_dev		*pdev;
+	unsigned long		align;
+	scb_t			*scb;
+	mbox_ccb_t		*ccb;
+	mbox_t			*una_mbox;
+	dma_addr_t		una_mbox_dma_h;
+	struct mraid_pci_blk	*pthru_pci_blk;
+	struct mraid_pci_blk	*epthru_pci_blk;
+	struct mraid_pci_blk	*sg_pci_blk;
+	struct mraid_pci_blk	*mbox_pci_blk;
+	bool_t			alloc_ibuf_f 		= MRAID_FALSE;
+	bool_t			alloc_common_mbox_f 	= MRAID_FALSE;
+	bool_t			alloc_int_ccb_f 	= MRAID_FALSE;
+	bool_t			alloc_int_ccb_pthru_f	= MRAID_FALSE;
+	bool_t			alloc_scb_f		= MRAID_FALSE;
+	bool_t			alloc_mbox_f		= MRAID_FALSE;
+	bool_t			alloc_pthru_f		= MRAID_FALSE;
+	bool_t			alloc_epthru_f		= MRAID_FALSE;
+	bool_t			alloc_sg_pool_f		= MRAID_FALSE;
+	int			i;
+
+	pdev = adapter->pdev;
+
+	/*
+	 * Setup the mailbox
+	 * Allocate the common 16-byte aligned memory for the handshake
+	 * mailbox.
+	 */
+	raid_dev->una_mbox64 = pci_alloc_consistent(adapter->pdev,
+			sizeof(mbox64_t), &raid_dev->una_mbox64_dma);
+
+	if (!raid_dev->una_mbox64) {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: out of memory, %s %d\n", __FUNCTION__,
+			__LINE__));
+		return MRAID_FAILURE;
+	}
+	memset(raid_dev->una_mbox64, 0, sizeof(mbox64_t));
+	alloc_common_mbox_f = MRAID_TRUE;
+
+	/*
+	 * Align the mailbox at 16-byte boundary
+	 */
+	raid_dev->mbox	= &raid_dev->una_mbox64->mbox32;
+
+	raid_dev->mbox	= (mbox_t *)((((unsigned long)raid_dev->mbox) + 15) &
+				(~0UL ^ 0xFUL));
+
+	raid_dev->mbox64 = (mbox64_t *)(((unsigned long)raid_dev->mbox) - 8);
+
+	align = ((void *)raid_dev->mbox -
+			((void *)&raid_dev->una_mbox64->mbox32));
+
+	raid_dev->mbox_dma = (unsigned long)raid_dev->una_mbox64_dma + 8 +
+			align;
+
+	/*
+	 * Check for IO mapped controller and register mailbox
+	 */
+	if (pci_resource_flags(adapter->pdev, 0) & IORESOURCE_IO) {
+		/*
+		 * Let firmware know the mailbox address
+		 */
+		outb_p(raid_dev->mbox_dma & 0xFF, raid_dev->baseport +
+				MBOX_PORT0);
+
+		outb_p((raid_dev->mbox_dma >> 8) & 0xFF,
+				raid_dev->baseport + MBOX_PORT1);
+
+		outb_p((raid_dev->mbox_dma >> 16) & 0xFF,
+				raid_dev->baseport + MBOX_PORT2);
+
+		outb_p((raid_dev->mbox_dma >> 24) & 0xFF,
+				raid_dev->baseport + MBOX_PORT3);
+	}
+
+	/*
+	 * Allocate memory for commands issued internally, through ioctl and
+	 * /proc
+	 */
+	adapter->ibuf = pci_alloc_consistent(pdev, MBOX_IBUF_SIZE,
+				&adapter->ibuf_dma_h);
+	if (!adapter->ibuf) {
+
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: out of memory, %s %d\n", __FUNCTION__,
+			__LINE__));
+
+		goto fail_alloc_cmds;
+	}
+	alloc_ibuf_f = MRAID_TRUE;
+	memset(adapter->ibuf, 0, MBOX_IBUF_SIZE);
+
+	/*
+	 * Attach mailbox drivers specific data structure with the scb for
+	 * internal commands.
+	 * NOTE: for internal command, we use the direct mailbox commands and
+	 * passthru command without scatter-gather list. Therefore, memory
+	 * allocation for scatter-gather list is not required. The data
+	 * transfer address would be the internal buffer and it's dma address.
+	 */
+	ccb = kmalloc(sizeof(mbox_ccb_t), GFP_KERNEL);
+	if (ccb == NULL) {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: out of memory, %s %d\n", __FUNCTION__,
+			__LINE__));
+
+		goto fail_alloc_cmds;
+	}
+	memset(ccb, 0, sizeof(mbox_ccb_t));
+	alloc_int_ccb_f = MRAID_TRUE;
+
+
+	/*
+	 * Allocate passthru structure for internal commands.
+	 * NOTE: for internal commands, we never use extended and 64-bit
+	 * passthru mailbox commands.
+	 *
+	 * HACK: piggyback the mailbox on the 'extra' memory allocated below
+	 * so that we do not need to track additional memory handles for
+	 * mailbox for internal commands. Put a buffer of about 1k bytes
+	 * between these two structures, just to separate them.
+	 */
+	ccb->pthru = pci_alloc_consistent(adapter->pdev, 2048,
+		&ccb->pthru_dma_h);
+
+	if (ccb->pthru == NULL) {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: out of memory, %s %d\n", __FUNCTION__,
+			__LINE__));
+
+		goto fail_alloc_cmds;
+	}
+	memset(ccb->pthru, 0, sizeof(mraid_passthru_t));
+	alloc_int_ccb_pthru_f = MRAID_TRUE;
+
+	una_mbox	= (mbox_t *)((unsigned long)ccb->pthru + 1024);
+	una_mbox_dma_h	= (dma_addr_t)((unsigned long)ccb->pthru_dma_h + 1024);
+
+	ccb->mbox	= (mbox_t *)((((unsigned long)una_mbox) + 15) &
+				(~0UL ^ 0xFUL));
+
+	align		= ((caddr_t)ccb->mbox) - ((caddr_t)una_mbox);
+	ccb->mbox_dma_h	= (dma_addr_t)((unsigned long)una_mbox_dma_h + align);
+	ccb->mbox64	= (mbox64_t *)((unsigned long)ccb->mbox - 8);
+	ccb->raw_mbox	= (uint8_t *)ccb->mbox;
+
+	// Attach with framework
+	adapter->iscb.ccb = (caddr_t)ccb;
+
+
+	// Allocate memory for our SCSI Command Blocks and their associated
+	// memory
+
+	/*
+	 * Allocate memory for the base list of scb. Later allocate memory for
+	 * CCBs and embedded components of each CCB and point the pointers in
+	 * scb to the allocated components
+	 * NOTE: The code to allocate SCB will be duplicated in all the LLD
+	 * since the calling routine does not yet know the number of available
+	 * commands.
+	 */
+	adapter->scb_list = kmalloc(sizeof(scb_t) * megaraid_driver_cmds,
+			GFP_KERNEL);
+
+	if (adapter->scb_list == NULL) {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: out of memory, %s %d\n", __FUNCTION__,
+			__LINE__));
+		goto fail_alloc_cmds;
+	}
+	alloc_scb_f = MRAID_TRUE;
+	memset(adapter->scb_list, 0, sizeof(scb_t) * megaraid_driver_cmds);
+
+	// Allocate memory for 16-bytes aligned mailboxes
+	raid_dev->mbox_pool_handle = mraid_pci_blk_pool_create(adapter->pdev,
+			megaraid_driver_cmds, sizeof(mbox64_t) + 16, 16,
+			raid_dev->mbox_pool);
+
+	if (raid_dev->mbox_pool_handle == NULL) {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: out of memory, %s %d\n", __FUNCTION__,
+			__LINE__));
+		goto fail_alloc_cmds;
+	}
+	alloc_mbox_f = MRAID_TRUE;
+
+	/*
+	 * Allocate memory for each embedded passthru strucuture pointer
+	 * Request for a 128 bytes aligned structure for each passthru command
+	 * structure
+	 */
+	raid_dev->pthru_pool_handle = mraid_pci_blk_pool_create(adapter->pdev,
+			megaraid_driver_cmds, sizeof(mraid_passthru_t), 128,
+			raid_dev->pthru_pool);
+
+	if (raid_dev->pthru_pool_handle == NULL) {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: out of memory, %s %d\n", __FUNCTION__,
+			__LINE__));
+		goto fail_alloc_cmds;
+	}
+	alloc_pthru_f = MRAID_TRUE;
+
+	/*
+	 * Allocate memory for each embedded extended passthru strucuture
+	 * pointer. Request for a 128 bytes aligned structure for each
+	 * extended passthru command structure
+	 */
+	raid_dev->epthru_pool_handle = mraid_pci_blk_pool_create(adapter->pdev,
+			megaraid_driver_cmds, sizeof(mraid_epassthru_t), 128,
+			raid_dev->epthru_pool);
+
+	if (raid_dev->epthru_pool_handle == NULL) {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: out of memory, %s %d\n", __FUNCTION__,
+			__LINE__));
+		goto fail_alloc_cmds;
+	}
+	alloc_epthru_f = MRAID_TRUE;
+
+	// Allocate memory for each scatter-gather list. Request for 512 bytes
+	// alignment for each sg list
+	raid_dev->sg_pool_handle = mraid_pci_blk_pool_create(adapter->pdev,
+		megaraid_driver_cmds, sizeof(mbox_sgl64) * MBOX_MAX_SG_SIZE,
+		512, raid_dev->sg_pool);
+
+	if (raid_dev->sg_pool_handle == NULL) {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: out of memory, %s %d\n", __FUNCTION__,
+			__LINE__));
+		goto fail_alloc_cmds;
+	}
+	alloc_sg_pool_f = MRAID_TRUE;
+
+	// Adjust the scb pointers and link in the free pool
+	pthru_pci_blk	= raid_dev->pthru_pool;
+	epthru_pci_blk	= raid_dev->epthru_pool;
+	sg_pci_blk	= raid_dev->sg_pool;
+	mbox_pci_blk	= raid_dev->mbox_pool;
+
+	for (i = 0; i < megaraid_driver_cmds; i++) {
+		scb			= adapter->scb_list + i;
+		ccb			= raid_dev->ccb_list + i;
+
+		ccb->mbox	= (mbox_t *)(mbox_pci_blk[i].vaddr + 16);
+		ccb->raw_mbox	= (uint8_t *)ccb->mbox;
+		ccb->mbox64	= (mbox64_t *)(mbox_pci_blk[i].vaddr + 8);
+		ccb->mbox_dma_h	= mbox_pci_blk[i].dma_addr + 16;
+
+		// make sure the mailbox is aligned properly
+		if (ccb->mbox_dma_h & 0x0F) {
+			con_log(CL_ANN, (KERN_CRIT
+				"megaraid mbox: not aligned on 16-bytes\n"));
+
+			goto fail_alloc_cmds;
+		}
+
+		ccb->pthru	= (mraid_passthru_t *)pthru_pci_blk[i].vaddr;
+		ccb->pthru_dma_h	= pthru_pci_blk[i].dma_addr;
+
+		ccb->epthru	= (mraid_epassthru_t *)epthru_pci_blk[i].vaddr;
+		ccb->epthru_dma_h	= epthru_pci_blk[i].dma_addr;
+
+		ccb->sgl64		= (mbox_sgl64 *)sg_pci_blk[i].vaddr;
+		ccb->sgl_dma_h		= sg_pci_blk[i].dma_addr;
+		ccb->sgl32		= (mbox_sgl32 *)ccb->sgl64;
+
+		scb->ccb		= (caddr_t)ccb;
+		scb->gp			= 0;
+
+		// cmdid will be allocated later
+		scb->sno		= -1;
+
+		scb->scp		= NULL;
+		scb->state		= SCB_FREE;
+		scb->dma_direction	= PCI_DMA_NONE;
+		scb->dma_type		= MRAID_DMA_NONE;
+		scb->dev_channel	= -1;
+		scb->dev_target		= -1;
+
+		/*
+		 * put scb in the free pool.
+		 */
+		mraid_add_scb_to_pool(adapter, scb);
+	}
+
+	return MRAID_SUCCESS;
+
+fail_alloc_cmds:
+	if (alloc_sg_pool_f == MRAID_TRUE) {
+		mraid_pci_blk_pool_destroy(raid_dev->sg_pool_handle);
+	}
+	if (alloc_epthru_f == MRAID_TRUE) {
+		mraid_pci_blk_pool_destroy(raid_dev->epthru_pool_handle);
+	}
+	if (alloc_pthru_f == MRAID_TRUE) {
+		mraid_pci_blk_pool_destroy(raid_dev->pthru_pool_handle);
+	}
+	if (alloc_mbox_f == MRAID_TRUE) {
+		mraid_pci_blk_pool_destroy(raid_dev->mbox_pool_handle);
+	}
+	if (alloc_scb_f == MRAID_TRUE ) kfree(adapter->scb_list);
+
+	if (alloc_int_ccb_pthru_f) {
+		pci_free_consistent(pdev, 2048,
+			((mbox_ccb_t *)(adapter->iscb.ccb))->pthru,
+			((mbox_ccb_t *)(adapter->iscb.ccb))->pthru_dma_h);
+	}
+	if (alloc_int_ccb_f) {
+		kfree(adapter->iscb.ccb);
+	}
+	if (alloc_ibuf_f) {
+		pci_free_consistent(pdev, MBOX_IBUF_SIZE,
+			(void *)adapter->ibuf, adapter->ibuf_dma_h);
+	}
+	if (alloc_common_mbox_f == MRAID_TRUE) {
+		pci_free_consistent(adapter->pdev, sizeof(mbox64_t),
+			(caddr_t)raid_dev->una_mbox64,
+			raid_dev->una_mbox64_dma);
+	}
+
+	return MRAID_FAILURE;
+}
+
+
+/**
+ * megaraid_free_common_mailbox - free shared mailbox
+ * @param adapter	: soft state of the raid controller
+ *
+ * Release memory resources allocated for commands
+ */
+static void
+megaraid_free_cmd_packets(adapter_t *adapter)
+{
+	mraid_device_t *raid_dev = ADAP2RAIDDEV(adapter);
+
+	mraid_pci_blk_pool_destroy(raid_dev->sg_pool_handle);
+	mraid_pci_blk_pool_destroy(raid_dev->epthru_pool_handle);
+	mraid_pci_blk_pool_destroy(raid_dev->pthru_pool_handle);
+	mraid_pci_blk_pool_destroy(raid_dev->mbox_pool_handle);
+	kfree(adapter->scb_list);
+
+	pci_free_consistent(adapter->pdev, 2048,
+		((mbox_ccb_t *)(adapter->iscb.ccb))->pthru,
+		((mbox_ccb_t *)(adapter->iscb.ccb))->pthru_dma_h);
+
+	kfree(adapter->iscb.ccb);
+
+	pci_free_consistent(adapter->pdev, MBOX_IBUF_SIZE,
+		(void *)adapter->ibuf, adapter->ibuf_dma_h);
+
+	pci_free_consistent(adapter->pdev, sizeof(mbox64_t),
+		(caddr_t)raid_dev->una_mbox64, raid_dev->una_mbox64_dma);
+	return;
+}
+
+
+/**
+ * megaraid_queue_command - generic queue entry point for all LLDs
+ * @scp		: pointer to the scsi command to be executed
+ * @done	: callback routine to be called after the cmd has be completed
+ *
+ * Queue entry point for mailbox based controllers. This entry point is common
+ * for memory and IO based controllers
+ */
+static int
+megaraid_queue_command(struct scsi_cmnd *scp, void (* done)(struct scsi_cmnd *))
+{
+	adapter_t	*adapter;
+	scb_t		*scb;
+	int		if_busy;
+
+	adapter		= SCP2ADAPTER(scp);
+	scp->scsi_done	= done;
+	scp->result	= 0;
+
+	/*
+	 * Allocate and build a SCB request
+	 * if_busy flag will be set if megaraid_mbox_build_cmd() command could
+	 * not allocate scb. We will return non-zero status in that case.
+	 * NOTE: scb can be null even though certain commands completed
+	 * successfully, e.g., MODE_SENSE and TEST_UNIT_READY, it would
+	 * return 0 in that case.
+	 */
+	if_busy	= 0;
+	scb	= megaraid_mbox_build_cmd(adapter, scp, &if_busy);
+
+	if (scb) {
+		scb->state |= SCB_PENDQ;
+		list_add_tail(&scb->list, &adapter->pend_list);
+
+		/*
+		 * Check if the HBA is in quiescent state, e.g., during a
+		 * delete logical drive opertion. If it is, don't run the
+		 * pending list.
+		 */
+		if (adapter->quiescent == MRAID_FALSE) {
+			megaraid_mbox_runpendq(adapter);
+		}
+#if 0
+		/*
+		 * Perform a preemptive interrupt acknowledgement sequence.
+		 * This should reduce the number of interrupts generated to
+		 * the OS and boosting performance.
+		 * TODO: compare results w/ and w/o this.
+		 */
+		if (likely(adapter->flags & MRAID_BOARD_MEMMAP)) {
+			megaraid_memmbox_ack_sequence(adapter);
+		}
+		else {
+			megaraid_iombox_ack_sequence(adapter);
+		}
+
+		tasklet_schedule(&adapter->dpc_h);	// schedule the DPC
+#endif
+		return 0;
+	}
+
+	return if_busy;
+}
+
+
+/**
+ * megaraid_mbox_build_cmd - transform the mid-layer scsi command to megaraid
+ * firmware lingua
+ * @adapter	- controller's soft state
+ * @scp		- mid-layer scsi command pointer
+ * @busy	- set if request could not be completed because of lack of
+ *		resources
+ *
+ * convert the command issued by mid-layer to format understood by megaraid
+ * firmware. We also complete certain command without sending them to firmware
+ */
+static inline scb_t *
+megaraid_mbox_build_cmd(adapter_t *adapter, Scsi_Cmnd *scp, int *busy)
+{
+	mraid_device_t		*rdev = ADAP2RAIDDEV(adapter);
+	int			channel;
+	int			target;
+	bool_t			islogical;
+	mbox_ccb_t		*ccb;
+	mraid_passthru_t	*pthru;
+	mbox_t			*mbox;
+	scb_t			*scb;
+	uint32_t		xferlen;
+	char			skip[] = "skipping";
+	char			scan[] = "scanning";
+	char			*ss;
+
+
+	/*
+	 * If the command is already prepared, i.e., internal commands, return
+	 * immediately.
+	 */
+	if (scp->cmnd[0] == MRAID_INTERNAL_COMMAND) {
+		return &adapter->iscb;
+	}
+
+	/*
+	 * Get the appropriate device map for the device this command is
+	 * intended for
+	 */
+	MRAID_GET_DEVICE_MAP(adapter, scp, channel, target, islogical);
+
+	/*
+	 * Logical drive commands
+	 */
+	if (islogical == MRAID_TRUE) {
+		switch (scp->cmnd[0]) {
+		case TEST_UNIT_READY:
+			/*
+			 * Do we support clustering and is the support enabled
+			 * If no, return success always
+			 */
+			if (adapter->ha != MRAID_TRUE) {
+				scp->result = (DID_OK << 16);
+				scp->scsi_done(scp);
+				return NULL;
+			}
+
+			if (!(scb = mraid_alloc_scb(adapter, scp))) {
+				scp->result = (DID_ERROR << 16);
+				scp->scsi_done(scp);
+				*busy = 1;
+				return NULL;
+			}
+
+			scb->dma_direction	= PCI_DIR(scp);
+			scb->dev_target		= 0xFF;
+			scb->dev_target		= target;
+			ccb			= (mbox_ccb_t *)scb->ccb;
+
+			/*
+			 * The command id will be provided by the command
+			 * issuance routine
+			 */
+			ccb->raw_mbox[0]	= CLUSTER_CMD;
+			ccb->raw_mbox[2]	= RESERVATION_STATUS;
+			ccb->raw_mbox[3]	= target;
+
+			return scb;
+
+		case MODE_SENSE:
+			if (scp->use_sg) {
+				struct scatterlist	*sgl;
+				caddr_t			vaddr;
+
+				sgl = (struct scatterlist *)scp->request_buffer;
+				if (sgl->page) {
+					vaddr = (caddr_t)
+						(page_address((&sgl[0])->page)
+						+ (&sgl[0])->offset);
+
+					memset(vaddr, 0, scp->cmnd[4]);
+				}
+				else {
+					con_log(CL_ANN, (KERN_WARNING
+					"megaraid mailbox: invalid sg:%d\n",
+					__LINE__));
+				}
+			}
+			else {
+				memset(scp->request_buffer, 0, scp->cmnd[4]);
+			}
+			scp->result = (DID_OK << 16);
+			scp->scsi_done(scp);
+			return NULL;
+
+		case INQUIRY:
+			/*
+			 * Display the channel scan for logical drives
+			 * Do not display scan for a channel if already done.
+			 */
+			if (!(rdev->last_disp & (1L << SCP2CHANNEL(scp)))) {
+
+				con_log(CL_ANN, (KERN_INFO
+					"scsi[%d]: scanning scsi channel %d",
+					adapter->host->host_no,
+					SCP2CHANNEL(scp)));
+
+				con_log(CL_ANN, (
+					" [virtual] for logical drives\n"));
+
+				rdev->last_disp |= (1L << SCP2CHANNEL(scp));
+			}
+
+			/* Fall through */
+
+		case READ_CAPACITY:
+			/*
+			 * Do not allow LUN > 0 for logical drives and
+			 * requests for more than 40 logical drives
+			 */
+			if (SCP2LUN(scp)) {
+				scp->result = (DID_BAD_TARGET << 16);
+				scp->scsi_done(scp);
+				return NULL;
+			}
+			if ((target % 0x80) >= MAX_LOGICAL_DRIVES_40LD) {
+				scp->result = (DID_BAD_TARGET << 16);
+				scp->scsi_done(scp);
+				return NULL;
+			}
+
+
+			/* Allocate a SCB and initialize passthru */
+			if (!(scb = mraid_alloc_scb(adapter, scp))) {
+				scp->result = (DID_ERROR << 16);
+				scp->scsi_done(scp);
+				*busy = 1;
+				return NULL;
+			}
+
+			ccb			= (mbox_ccb_t *)scb->ccb;
+			scb->dev_channel	= 0xFF;
+			scb->dev_target		= target;
+			pthru			= ccb->pthru;
+			mbox			= ccb->mbox;
+
+			pthru->timeout		= 0;
+			pthru->ars		= 1;
+			pthru->reqsenselen	= 14;
+			pthru->islogical	= 1;
+			pthru->logdrv		= target;
+			pthru->cdblen		= scp->cmd_len;
+			memcpy(pthru->cdb, scp->cmnd, scp->cmd_len);
+
+			/*
+			 * If 64-bit dma is supported, issue the appropriate
+			 * mailbox command.
+			 */
+			if (adapter->highmem_dma == MRAID_TRUE) {
+				mbox->cmd = MBOXCMD_PASSTHRU64;
+			}
+			else {
+				mbox->cmd = MBOXCMD_PASSTHRU;
+			}
+			scb->dma_direction = PCI_DIR(scp);
+
+			pthru->numsge = megaraid_mbox_mksgl(adapter, scb,
+				&pthru->dataxferaddr, &pthru->dataxferlen);
+
+			mbox->xferaddr = ccb->pthru_dma_h;
+
+			return scb;
+
+		case READ_6:
+		case WRITE_6:
+		case READ_10:
+		case WRITE_10:
+		case READ_12:
+		case WRITE_12:
+
+			/*
+			 * Allocate a SCB and initialize mailbox
+			 */
+			if (!(scb = mraid_alloc_scb(adapter, scp))) {
+				scp->result = (DID_ERROR << 16);
+				scp->scsi_done(scp);
+				*busy = 1;
+				return NULL;
+			}
+			ccb			= (mbox_ccb_t *)scb->ccb;
+			scb->dev_channel	= 0xFF;
+			scb->dev_target		= target;
+			mbox			= ccb->mbox;
+			mbox->logdrv		= target;
+
+			/*
+			 * A little hack: 2nd bit is zero for all scsi read
+			 * commands and is set for all scsi write commands
+			 */
+			if (adapter->highmem_dma == MRAID_TRUE) {
+				mbox->cmd = (scp->cmnd[0] & 0x02) ?
+					MBOXCMD_LWRITE64:
+					MBOXCMD_LREAD64 ;
+			}
+			else {
+				mbox->cmd = (scp->cmnd[0] & 0x02) ?
+					MBOXCMD_LWRITE:
+					MBOXCMD_LREAD ;
+			}
+
+			/*
+			 * 6-byte READ(0x08) or WRITE(0x0A) cdb
+			 */
+			if (scp->cmd_len == 6) {
+				mbox->numsectors = (uint32_t)scp->cmnd[4];
+				mbox->lba =
+					((uint32_t)scp->cmnd[1] << 16)	|
+					((uint32_t)scp->cmnd[2] << 8)	|
+					(uint32_t)scp->cmnd[3];
+
+				mbox->lba &= 0x1FFFFF;
+			}
+
+			/*
+			 * 10-byte READ(0x28) or WRITE(0x2A) cdb
+			 */
+			else if (scp->cmd_len == 10) {
+				mbox->numsectors =
+					(uint32_t)scp->cmnd[8] |
+					((uint32_t)scp->cmnd[7] << 8);
+				mbox->lba =
+					((uint32_t)scp->cmnd[2] << 24) |
+					((uint32_t)scp->cmnd[3] << 16) |
+					((uint32_t)scp->cmnd[4] << 8) |
+					(uint32_t)scp->cmnd[5];
+			}
+
+			/*
+			 * 12-byte READ(0xA8) or WRITE(0xAA) cdb
+			 */
+			else if (scp->cmd_len == 12) {
+				mbox->lba =
+					((uint32_t)scp->cmnd[2] << 24) |
+					((uint32_t)scp->cmnd[3] << 16) |
+					((uint32_t)scp->cmnd[4] << 8) |
+					(uint32_t)scp->cmnd[5];
+
+				mbox->numsectors =
+					((uint32_t)scp->cmnd[6] << 24) |
+					((uint32_t)scp->cmnd[7] << 16) |
+					((uint32_t)scp->cmnd[8] << 8) |
+					(uint32_t)scp->cmnd[9];
+			}
+			else {
+				con_log(CL_ANN, (KERN_WARNING
+					"megaraid: unsupported CDB length\n"));
+
+				scp->result = (DID_ERROR << 16);
+				scp->scsi_done(scp);
+				return NULL;
+			}
+
+
+
+			scb->dma_direction = PCI_DIR(scp);
+
+			/*
+			 * Calculate Scatter-Gather info
+			 */
+			mbox->numsge = megaraid_mbox_mksgl(adapter, scb,
+					(uint32_t *)&mbox->xferaddr, &xferlen);
+
+#ifdef MRAID_HAVE_STATS
+			/*
+			 * keep counter of number of IO commands coming down.
+			 * Some applications are interested in this data
+			 */
+			if (scp->cmnd[0] & 0x02) {	/* read commands */
+				adapter->nreads[target % 0x80]++;
+				adapter->nreadblocks[target % 0x80] +=
+					mbox->numsectors;
+			}
+			else {	/* write commands */
+				adapter->nwrites[target % 0x80]++;
+				adapter->nwriteblocks[target % 0x80] +=
+					mbox->numsectors;
+			}
+#endif
+
+			return scb;
+
+		case RESERVE:
+		case RELEASE:
+			/*
+			 * Do we support clustering and is the support enabled
+			 */
+			if (!adapter->ha) {
+				scp->result = (DID_BAD_TARGET << 16);
+				scp->scsi_done(scp);
+				return NULL;
+			}
+
+			/*
+			 * Allocate a SCB and initialize mailbox
+			 */
+			if (!(scb = mraid_alloc_scb(adapter, scp))) {
+				scp->result = (DID_ERROR << 16);
+				scp->scsi_done(scp);
+				*busy = 1;
+				return NULL;
+			}
+
+			ccb			= (mbox_ccb_t *)scb->ccb;
+			scb->dev_channel	= 0xFF;
+			scb->dev_target		= target;
+			ccb->raw_mbox[0]	= CLUSTER_CMD;
+			/*
+			 * The command id will be provided by the command
+			 * issuance routine
+			 */
+			ccb->raw_mbox[2]	=  (scp->cmnd[0] == RESERVE) ?
+						RESERVE_LD : RELEASE_LD;
+
+			ccb->raw_mbox[3]	= target;
+			scb->dma_direction	= PCI_DIR(scp);
+
+			return scb;
+
+		default:
+			scp->result = (DID_BAD_TARGET << 16);
+			scp->scsi_done(scp);
+			return NULL;
+		}
+	}
+	else { // Passthru device commands
+
+		// Do not allow access to target id > 15 or LUN > 7
+		if (target > 15 || SCP2LUN(scp) > 7) {
+			scp->result = (DID_BAD_TARGET << 16);
+			scp->scsi_done(scp);
+			return NULL;
+		}
+
+		// if fast load option was set and scan for last device is
+		// over, reset the fast_load flag so that during a possible
+		// next scan, devices can be made available
+		// TODO: check if this works ok!
+		if (megaraid_fast_load && (target == 15) &&
+			(SCP2CHANNEL(scp) == adapter->max_channel -1)) {
+
+			con_log(CL_ANN, (KERN_INFO
+				"megaraid mailbox: physical device scan "
+				"re-enabled\n"));
+			megaraid_fast_load = 0;
+		}
+
+		/*
+		 * Display the channel scan for physical devices
+		 */
+		if (!(rdev->last_disp & (1L << SCP2CHANNEL(scp)))) {
+
+			ss = megaraid_fast_load ? skip : scan;
+
+			con_log(CL_ANN, (KERN_INFO
+				"scsi[%d]: %s scsi channel %d [Phy %d]",
+				adapter->host->host_no, ss, SCP2CHANNEL(scp),
+				channel));
+
+			con_log(CL_ANN, (
+				" for non-raid devices\n"));
+
+			rdev->last_disp |= (1L << SCP2CHANNEL(scp));
+		}
+
+		// disable channel sweep if fast load option given
+		if (megaraid_fast_load) {
+			scp->result = (DID_BAD_TARGET << 16);
+			scp->scsi_done(scp);
+			return NULL;
+		}
+
+		/*
+		 * Allocate a SCB and initialize passthru
+		 */
+		if (!(scb = mraid_alloc_scb(adapter, scp))) {
+			scp->result = (DID_ERROR << 16);
+			scp->scsi_done(scp);
+			*busy = 1;
+			return NULL;
+		}
+
+		ccb			= (mbox_ccb_t *)scb->ccb;
+		scb->dev_channel	= channel;
+		scb->dev_target		= target;
+		scb->dma_direction	= PCI_DIR(scp);
+		mbox			= ccb->mbox;
+
+		// Does this firmware support extended CDBs
+		if (adapter->max_cdb_sz == 16) {
+			mbox->cmd	= MBOXCMD_EXTPTHRU;
+			megaraid_mbox_prepare_epthru(adapter, scb, scp);
+			mbox->xferaddr	= (uint32_t)ccb->epthru_dma_h;
+		}
+		else {
+			if (adapter->highmem_dma == MRAID_TRUE) {
+				mbox->cmd = MBOXCMD_PASSTHRU64;
+			}
+			else {
+				mbox->cmd = MBOXCMD_PASSTHRU;
+			}
+			megaraid_mbox_prepare_pthru(adapter, scb, scp);
+			mbox->xferaddr = (uint32_t)ccb->pthru_dma_h;
+		}
+		return scb;
+	}
+}
+
+
+/**
+ * megaraid_mbox_prepare_pthru - prepare a command for physical devices
+ * @adapter	- pointer to controller's soft state
+ * @scb		- scsi control block
+ * @scp		- scsi command from the mid-layer
+ *
+ * prepare a command for the scsi physical devices
+ */
+static inline void
+megaraid_mbox_prepare_pthru(adapter_t *adapter, scb_t *scb, Scsi_Cmnd *scp)
+{
+	mraid_device_t		*rdev = ADAP2RAIDDEV(adapter);
+	mbox_ccb_t		*ccb;
+	mraid_passthru_t	*pthru;
+	uint8_t			channel;
+	uint8_t			target;
+
+	ccb	= (mbox_ccb_t *)scb->ccb;
+	pthru	= ccb->pthru;
+	channel	= scb->dev_channel;
+	target	= scb->dev_target;
+
+	pthru->timeout		= 2;	/* 0=6sec,1=60sec,2=10min,3=3hrs */
+	pthru->ars		= 1;
+	pthru->islogical	= 0;
+	pthru->channel		= (rdev->flags & MBOX_BOARD_40LD) ? 0 : channel;
+	pthru->target		= (rdev->flags & MBOX_BOARD_40LD) ?
+					(channel << 4) | target : target;
+	pthru->logdrv		= SCP2LUN(scp);
+	pthru->reqsenselen	= 14;
+	pthru->cdblen		= scp->cmd_len;
+
+	memcpy(pthru->cdb, scp->cmnd, scp->cmd_len);
+
+	if (scp->request_bufflen) {
+		pthru->numsge = megaraid_mbox_mksgl(adapter, scb,
+				&pthru->dataxferaddr, &pthru->dataxferlen);
+	}
+	else {
+		pthru->dataxferaddr	= 0;
+		pthru->dataxferlen	= 0;
+	}
+	return;
+}
+
+
+/**
+ * megaraid_mbox_prepare_epthru - prepare a command for physical devices
+ * @adapter	- pointer to controller's soft state
+ * @scb		- scsi control block
+ * @scp		- scsi command from the mid-layer
+ *
+ * prepare a command for the scsi physical devices. This rountine prepares
+ * commands for devices which can take extended CDBs (>10 bytes)
+ */
+static inline void
+megaraid_mbox_prepare_epthru(adapter_t *adapter, scb_t *scb, Scsi_Cmnd *scp)
+{
+	mraid_device_t		*rdev = ADAP2RAIDDEV(adapter);
+	mbox_ccb_t		*ccb;
+	mraid_epassthru_t	*epthru;
+	uint8_t			channel;
+	uint8_t			target;
+
+	ccb	= (mbox_ccb_t *)scb->ccb;
+	epthru	= ccb->epthru;
+	channel	= scb->dev_channel;
+	target	= scb->dev_target;
+
+	epthru->timeout		= 2;	/* 0=6sec,1=60sec,2=10min,3=3hrs */
+	epthru->ars		= 1;
+	epthru->islogical	= 0;
+	epthru->channel		= (rdev->flags & MBOX_BOARD_40LD) ? 0 : channel;
+	epthru->target		= (rdev->flags & MBOX_BOARD_40LD) ?
+					(channel << 4) | target : target;
+	epthru->logdrv		= SCP2LUN(scp);
+	epthru->reqsenselen	= 14;
+	epthru->cdblen		= scp->cmd_len;
+
+	memcpy(epthru->cdb, scp->cmnd, scp->cmd_len);
+
+	if (scp->request_bufflen) {
+		epthru->numsge = megaraid_mbox_mksgl(adapter, scb,
+				&epthru->dataxferaddr, &epthru->dataxferlen);
+	}
+	else {
+		epthru->dataxferaddr	= 0;
+		epthru->dataxferlen	= 0;
+	}
+	return;
+}
+
+
+/**
+ * megaraid_mbox_mksgl - make the scatter-gather list
+ * @adapter	- controller's soft state
+ * @scb		- scsi control block
+ * @xferaddr	- start of data transfer address (block/sg list)
+ * @xferlen	- total amount of data to be transferred
+ *
+ * prepare the scatter-gather list
+ */
+static inline int
+megaraid_mbox_mksgl(adapter_t *adapter, scb_t *scb, uint32_t *xferaddr,
+		uint32_t *xferlen)
+{
+	struct scatterlist	*sgl;
+	mbox_ccb_t		*ccb;
+	struct page		*page;
+	unsigned long		offset;
+	Scsi_Cmnd		*scp;
+	int			sgcnt;
+	int			i;
+
+
+	scp	= scb->scp;
+	ccb	= (mbox_ccb_t *)scb->ccb;
+
+	if (!scp->use_sg) {	/* scatter-gather list not used */
+
+		page = virt_to_page(scp->request_buffer);
+
+		offset = ((unsigned long)scp->request_buffer & ~PAGE_MASK);
+
+		ccb->buf_dma_h = pci_map_page(adapter->pdev, page, offset,
+						  scp->request_bufflen,
+						  scb->dma_direction);
+		scb->dma_type = MRAID_DMA_WBUF;
+
+		/*
+		 * We need to handle special 64-bit commands that need a
+		 * minimum of 1 SG
+		 */
+		sgcnt = 1;
+		if (adapter->highmem_dma == MRAID_TRUE) {
+			ccb->sgl64[0].address	= ccb->buf_dma_h;
+			ccb->sgl64[0].length	= scp->request_bufflen;
+			*xferaddr	= (uint32_t)ccb->sgl_dma_h;
+			*xferlen	= (uint32_t)scp->request_bufflen;
+		}
+		else {
+			*xferaddr	= (uint32_t)ccb->buf_dma_h;
+			*xferlen	= (uint32_t)scp->request_bufflen;
+			sgcnt		= 0;
+		}
+
+		if (scb->dma_direction == PCI_DMA_TODEVICE) {
+			pci_dma_sync_single(adapter->pdev, ccb->buf_dma_h,
+					scp->request_bufflen,
+					PCI_DMA_TODEVICE);
+		}
+
+		return sgcnt;
+	}
+
+	sgl = (struct scatterlist *)scp->request_buffer;
+
+	// The number of sg elements returned must not exceed our limit
+	sgcnt = pci_map_sg(adapter->pdev, sgl, scp->use_sg,
+			scb->dma_direction);
+
+	if (sgcnt > adapter->sglen) {
+		con_log(CL_ANN, (KERN_CRIT
+			"megaraid critical: too many sg elements:%d\n",
+			sgcnt));
+		BUG();
+	}
+
+	scb->dma_type = MRAID_DMA_WSG;
+
+	for (i = 0; i < sgcnt; i++, sgl++) {
+		if (adapter->highmem_dma == MRAID_TRUE) {
+			ccb->sgl64[i].address = sg_dma_address(sgl);
+			ccb->sgl64[i].length = sg_dma_len(sgl);
+		}
+		else {
+			ccb->sgl32[i].address = sg_dma_address(sgl);
+			ccb->sgl32[i].length = sg_dma_len(sgl);
+		}
+	}
+
+	// dataxferlen must be set, even for commands with a sg list
+	*xferaddr = ccb->sgl_dma_h;
+	*xferlen = (uint32_t)scp->request_bufflen;
+
+	if (scb->dma_direction == PCI_DMA_TODEVICE) {
+		pci_dma_sync_sg(adapter->pdev, scp->request_buffer,
+				scp->use_sg, PCI_DMA_TODEVICE);
+	}
+
+	// Return count of SG nodes
+	return sgcnt;
+}
+
+
+/**
+ * megaraid_mbox_runpendq - execute commands queued in the pending queue
+ * @adapter	- controller's soft state
+ *
+ * scan the pending list for commands which are not yet issued and try to
+ * post to the controller.
+ */
+static inline void
+megaraid_mbox_runpendq(adapter_t *adapter)
+{
+	struct list_head *pos, *next;
+	scb_t	*scb;
+
+	if (!list_empty(&adapter->pend_list)) {
+
+		// Issue all pending commands to the card
+		list_for_each_safe (pos, next, &adapter->pend_list) {
+
+			scb = list_entry(pos, scb_t, list);
+
+			if (!(scb->state & SCB_ISSUED)) {
+
+				if (mbox_post_cmd(adapter, scb) !=
+						MRAID_SUCCESS) {
+					return;
+				}
+			}
+		}
+	}
+	return;
+}
+
+
+/**
+ * mbox_post_cmd - issue a mailbox command
+ * @adapter	- controller's soft state
+ * @scb		- command to be issued
+ *
+ * post the command to the controller if mailbox is availble.
+ */
+static inline status_t
+mbox_post_cmd(adapter_t *adapter, scb_t *scb)
+{
+	mraid_device_t	*raid_dev = ADAP2RAIDDEV(adapter);
+	mbox64_t	*mbox64;
+	mbox_t		*mbox;
+	mbox_ccb_t	*ccb;
+	unsigned int	i = 0;
+
+
+	ccb	= (mbox_ccb_t *)scb->ccb;
+	mbox	= raid_dev->mbox;
+	mbox64	= raid_dev->mbox64;
+
+	/*
+	 * Check for busy mailbox. If it is, return failure - the caller
+	 * should retry later.
+	 */
+	if (unlikely(mbox->busy)) {
+		do {
+			udelay(1);
+			i++;
+		} while(mbox->busy && (i < max_mbox_busy_wait));
+
+		if (mbox->busy) return MRAID_FAILURE;
+	}
+
+	// Do we have an available command id. If not return failure
+	MBOX_GET_CMDID(raid_dev, scb);
+
+	if (scb->sno == -1) return MRAID_FAILURE;
+
+	// Copy this command's mailbox data into "adapter's" mailbox
+	memcpy((caddr_t)mbox64, (caddr_t)ccb->mbox64, 24);
+	mbox->cmdid = scb->sno;
+
+	// only modify the transfer addresses if mbox64 is not already setup
+	if (mbox->xferaddr != 0xFFFFFFFF) {
+		switch (mbox->cmd) {
+		case MBOXCMD_EXTPTHRU:
+			if (adapter->highmem_dma != MRAID_TRUE) break;
+			// else fall-through
+		case MBOXCMD_LREAD64:
+		case MBOXCMD_LWRITE64:
+		case MBOXCMD_PASSTHRU64:
+			mbox64->xferaddr_lo = mbox->xferaddr;
+			mbox64->xferaddr_hi = 0;
+			mbox->xferaddr = 0xFFFFFFFF;
+			break;
+		default:
+			mbox64->xferaddr_lo = 0;
+			mbox64->xferaddr_hi = 0;
+		}
+	}
+
+	// post the command and increment the oustanding commands counter/
+	scb->state |= SCB_ISSUED;
+
+	adapter->outstanding_cmds++;
+
+	mbox->busy = 1;		// Set busy
+	if (likely(adapter->flags & MRAID_BOARD_MEMMAP)) {
+		mbox->poll = 0;
+		mbox->ack = 0;
+		wmb();
+		WRINDOOR(raid_dev, raid_dev->mbox_dma | 0x1);
+	}
+	else {
+		iombox_irq_enable(raid_dev);
+		iombox_issue_command(raid_dev);
+	}
+
+	return MRAID_SUCCESS;
+}
+
+
+/**
+ * megaraid_isr_memmapped - isr for memory based mailbox based controllers
+ * @irq		- irq
+ * @devp	- pointer to our soft state
+ * @regs	- unused
+ *
+ * Interrupt service routine for memory-mapped mailbox controllers.
+ */
+static irqreturn_t
+megaraid_isr_memmapped(int irq, void *devp, struct pt_regs *regs)
+{
+	adapter_t	*adapter = devp;
+	unsigned long	flags;
+	bool_t		handled;
+
+
+	spin_lock_irqsave(adapter->host_lock, flags);
+
+	handled = megaraid_memmbox_ack_sequence(adapter);
+
+	/* Loop through any pending requests */
+	if (adapter->quiescent == MRAID_FALSE) {
+		megaraid_mbox_runpendq(adapter);
+	}
+
+	spin_unlock_irqrestore(adapter->host_lock, flags);
+
+	// TODO: do we need to schedule tasklet everytime
+	tasklet_schedule(&adapter->dpc_h);	// schedule the DPC
+
+	if (handled == MRAID_TRUE) {
+		return IRQ_RETVAL(1);
+	}
+	else {
+		return IRQ_RETVAL(0);
+	}
+}
+
+
+/**
+ * megaraid_memmbox_ack_sequence - interrupt ack sequence for memory mapped HBAs
+ * @adapter	- controller's soft state
+ *
+ * Interrupt ackrowledgement sequence for memory mapped HBAs
+ */
+static inline bool_t
+megaraid_memmbox_ack_sequence(adapter_t *adapter)
+{
+	mraid_device_t	*raid_dev = ADAP2RAIDDEV(adapter);
+	mbox_t		*mbox;
+	scb_t		*scb;
+	Scsi_Cmnd	*scp;
+	uint8_t		nstatus;
+	uint8_t		cmdid;
+	bool_t		handled;
+	uint32_t	dword;
+	int		i;
+
+	mbox	= raid_dev->mbox;
+
+	// loop till F/W has more commands for us to complete
+	handled = MRAID_FALSE;
+	do {
+		/*
+		 * Check if a valid interrupt is pending. If found, force the
+		 * interrupt line low.
+		 */
+		dword = RDOUTDOOR(raid_dev);
+		if (dword != 0x10001234) {
+			// No more pending commands
+
+			return handled;
+		}
+		handled = MRAID_TRUE;
+		WROUTDOOR(raid_dev, 0x10001234);
+
+		while ((nstatus = mbox->numstatus) == 0xFF)
+			cpu_relax();
+		mbox->numstatus = 0xFF;
+
+		adapter->outstanding_cmds -= nstatus;
+
+		for (i = 0; i < nstatus; i++) {
+			while ((cmdid = mbox->completed[i]) == 0xFF)
+				cpu_relax();
+
+			mbox->completed[i] = 0xFF;
+
+			// handle internal commands right away
+			if (unlikely(cmdid == raid_dev->int_cmdid)) {
+
+				scb		= &adapter->iscb;
+				scp		= scb->scp;
+				scp->result	= mbox->status;
+				scb->status	= mbox->status;
+
+				/*
+				 * Remove the command from the pending list
+				 * and call the internal callback routine
+				 */
+				list_del_init(&scb->list);
+				scb->state = SCB_FREE;
+				scp->scsi_done(scp);
+			}
+			else {
+				/*
+				 * SCB associated with this command id and put
+				 * in the completed list. Move the scb for
+				 * existing list to the completed list
+				 */
+				scb = MBOX_GET_CMDID_SCB(raid_dev, cmdid);
+				scb->status = mbox->status;
+				list_move_tail(&scb->list,
+						&adapter->completed_list);
+			}
+		}
+
+		// Acknowledge interrupt
+		WRINDOOR(raid_dev, 0x02);
+
+		// FIXME: this may not be required
+		while (RDINDOOR(raid_dev) & 0x02) cpu_relax();
+
+	} while(1);
+}
+
+
+static void
+megaraid_mbox_dpc(unsigned long devp)
+{
+	adapter_t		*adapter = (adapter_t *)devp;
+	mraid_device_t		*raid_dev = ADAP2RAIDDEV(adapter);
+	struct list_head	*pos, *next;
+	struct scatterlist	*sgl;
+	scb_t			*scb;
+	Scsi_Cmnd		*scp;
+	mraid_passthru_t	*pthru;
+	mraid_epassthru_t	*epthru;
+	mbox_ccb_t		*ccb;
+	bool_t			islogical;
+	int			pdev_index;
+	int			pdev_state;
+	mbox_t			*mbox;
+	unsigned long		flags;
+	uint8_t			c;
+	int			status;
+#ifdef MRAID_HAVE_STATS
+	int			ldrv_num = 0;
+#endif
+
+	spin_lock_irqsave(adapter->host_lock, flags);
+
+	list_for_each_safe(pos, next, &adapter->completed_list) {
+		scb = list_entry(pos, scb_t, list);
+
+		status		= scb->status;
+		scp		= scb->scp;
+		ccb		= (mbox_ccb_t *)scb->ccb;
+		pthru		= ccb->pthru;
+		epthru		= ccb->epthru;
+		mbox		= ccb->mbox;
+		islogical	= MRAID_IS_LOGICAL(adapter, scp);
+
+		/*
+		 * Make sure f/w has completed a valid command
+		 */
+		if (!(scb->state & SCB_ISSUED)) {
+			con_log(CL_ANN, (KERN_CRIT
+			"megaraid critical err: invalid command %d:%d:%p\n",
+				scb->sno, scb->state, scp));
+			continue;	// Must never happen!
+		}
+
+		// Was an abort issued for this command earlier
+		if (scb->state & SCB_ABORT) {
+
+			con_log(CL_ANN, (KERN_NOTICE
+			"megaraid: aborted cmd %lx[%x] completed\n",
+				scp->serial_number, scb->sno));
+
+			scp->result = (DID_ABORT << 16);
+			scp->scsi_done(scb->scp);
+			megaraid_mbox_free_scb(adapter, scb);
+
+			continue;
+		}
+
+		// Was a reset issued for this command earlier
+		if (scb->state & SCB_RESET) {
+
+			con_log(CL_ANN, (KERN_WARNING
+			"megaraid: reset cmd %lx[%x] completed\n",
+				scp->serial_number, scb->sno));
+
+			scb->scp->result = (DID_RESET << 16);
+			scp->scsi_done(scb->scp);
+			megaraid_mbox_free_scb(adapter, scb);
+
+			continue;
+		}
+
+#ifdef MRAID_HAVE_STATS
+		ldrv_num = mbox->logdrv;
+
+		/*
+		 * Maintain an error counter for the logical drive.
+		 * Some application like SNMP agent need such statistics
+		 */
+		if (status && (islogical == MRAID_TRUE) &&
+				(scp->cmnd[0] == READ_6 ||
+				scp->cmnd[0] == READ_10 ||
+				scp->cmnd[0] == READ_12)) {
+			/*
+			 * Logical drive number increases by 0x80 when a
+			 * logical drive is deleted
+			 */
+			adapter->rd_errors[ldrv_num % 0x80]++;
+		}
+
+		if (status && (islogical == MRAID_TRUE) &&
+				(scp->cmnd[0] == WRITE_6 ||
+				scp->cmnd[0] == WRITE_10 ||
+				scp->cmnd[0] == WRITE_12)) {
+			/*
+			 * Logical drive number increases by 0x80 when
+			 * a logical drive is deleted
+			 */
+			adapter->wr_errors[ldrv_num % 0x80]++;
+		}
+#endif
+
+		/*
+		 * If the inquiry came of a disk drive which is not part of
+		 * any RAID array, expose it to the kernel. For this to be
+		 * enabled, user must set the "expose_unconf_disks" flag to 1
+		 * by specifying it on module parameter list.
+		 * This would enable data migration off drives from other
+		 * configurations.
+		 * TODO: Add code for ROMB configurations, where the disks on
+		 * the SCSI channel must be exposed unconditionally
+		 */
+		if (scp->cmnd[0] == INQUIRY && status == 0 &&
+				islogical == MRAID_FALSE) {
+
+			if (scp->use_sg) {
+				sgl = (struct scatterlist *)
+					scp->request_buffer;
+
+				if (sgl->page) {
+					c = *(unsigned char *)
+					(page_address((&sgl[0])->page) +
+						(&sgl[0])->offset);
+				}
+				else {
+					con_log(CL_ANN, (KERN_WARNING
+					"megaraid mailbox: invalid sg:%d\n",
+					__LINE__));
+					c = 0;
+				}
+			}
+			else {
+				c = *(uint8_t *)scp->request_buffer;
+			}
+
+			if ((c & 0x1F ) == TYPE_DISK) {
+				pdev_index = (scb->dev_channel * 16) +
+					scb->dev_target;
+				pdev_state =
+					raid_dev->pdrv_state[pdev_index] & 0x0F;
+
+				if (pdev_state == PDRV_ONLINE		||
+					pdev_state == PDRV_FAILED	||
+					pdev_state == PDRV_RBLD		||
+					pdev_state == PDRV_HOTSPARE	||
+					expose_unconf_disks == 0) {
+
+					status = 0xF0;
+				}
+			}
+		}
+
+		// clear result; otherwise, success returns corrupt value
+		scp->result = 0;
+
+		// Convert MegaRAID status to Linux error code
+		switch (status) {
+
+		case 0x00:
+
+			scp->result = (DID_OK << 16);
+			break;
+
+		case 0x02:
+
+			/* set sense_buffer and result fields */
+			if (mbox->cmd == MBOXCMD_PASSTHRU ||
+				mbox->cmd == MBOXCMD_PASSTHRU64) {
+
+				memcpy(scp->sense_buffer, pthru->reqsensearea,
+						14);
+
+				scp->result = DRIVER_SENSE << 24 |
+					DID_OK << 16 | CHECK_CONDITION << 1;
+			}
+			else {
+				if (mbox->cmd == MBOXCMD_EXTPTHRU) {
+
+					memcpy(scp->sense_buffer,
+						epthru->reqsensearea, 14);
+
+					scp->result = DRIVER_SENSE << 24 |
+						DID_OK << 16 |
+						CHECK_CONDITION << 1;
+				} else {
+					scp->sense_buffer[0] = 0x70;
+					scp->sense_buffer[2] = ABORTED_COMMAND;
+					scp->result = CHECK_CONDITION << 1;
+				}
+			}
+			break;
+
+		case 0x08:
+
+			scp->result = DID_BUS_BUSY << 16 | status;
+			break;
+
+		default:
+
+			/*
+			 * If TEST_UNIT_READY fails, we know
+			 * RESERVATION_STATUS failed
+			 */
+			if (scp->cmnd[0] == TEST_UNIT_READY) {
+				scp->result = DID_ERROR << 16 |
+					RESERVATION_CONFLICT << 1;
+			}
+			else
+			/*
+			 * Error code returned is 1 if Reserve or Release
+			 * failed or the input parameter is invalid
+			 */
+			if (status == 1 && (scp->cmnd[0] == RESERVE ||
+					 scp->cmnd[0] == RELEASE)) {
+
+				scp->result = DID_ERROR << 16 |
+					RESERVATION_CONFLICT << 1;
+			}
+			else {
+				scp->result = DID_BAD_TARGET << 16 | status;
+			}
+		}
+
+		// print a level 1 debug message for all failed commands
+		if (status) {
+			megaraid_mbox_display_scb(adapter, scb, CL_DLEVEL1);
+		}
+
+		/*
+		 * Free our internal resources and call the mid-layer callback
+		 * routine
+		 */
+		megaraid_mbox_free_scb(adapter, scb);
+		scp->scsi_done(scp);
+	}
+
+	spin_unlock_irqrestore(adapter->host_lock, flags);
+
+	return;
+}
+
+
+/**
+ * megaraid_mbox_free_scb - free the per-command internal resources
+ * @adapter	- controller's soft state
+ * @scb		- pointer to the resource packet to be freed
+ *
+ * Put the scb back in the available pool and call DMA sync whereever
+ * required.
+ */
+static inline void
+megaraid_mbox_free_scb(adapter_t *adapter, scb_t *scb)
+{
+	mraid_device_t	*raid_dev = ADAP2RAIDDEV(adapter);
+	mbox_ccb_t	*ccb;
+
+	ccb	= (mbox_ccb_t *)scb->ccb;
+
+	switch (scb->dma_type) {
+
+	case MRAID_DMA_WBUF:
+		if (scb->dma_direction == PCI_DMA_FROMDEVICE) {
+			pci_dma_sync_single(adapter->pdev,
+					ccb->buf_dma_h,
+					scb->scp->request_bufflen,
+					PCI_DMA_FROMDEVICE);
+		}
+
+		pci_unmap_page(adapter->pdev, ccb->buf_dma_h,
+			scb->scp->request_bufflen, scb->dma_direction);
+
+		break;
+
+	case MRAID_DMA_WSG:
+		if (scb->dma_direction == PCI_DMA_FROMDEVICE) {
+			pci_dma_sync_sg(adapter->pdev,
+					scb->scp->request_buffer,
+					scb->scp->use_sg, PCI_DMA_FROMDEVICE);
+		}
+
+		pci_unmap_sg(adapter->pdev, scb->scp->request_buffer,
+			scb->scp->use_sg, scb->dma_direction);
+
+		break;
+
+	default:
+		break;
+	}
+
+	/*
+	 * Free the command id associated with this SCB so that it can
+	 * be re-used
+	 */
+	MBOX_FREE_CMDID(raid_dev, scb->sno);
+
+	/*
+	 * Remove the command from the pending list and return scb to the
+	 * pool of free SCBs
+	 */
+	scb->sno = -1;
+	list_del_init(&scb->list);
+	mraid_dealloc_scb(adapter, scb);
+
+	return;
+}
+
+
+/**
+ * megaraid_isr_iomapped - isr for IO based mailbox based controllers
+ * @irq		- irq
+ * @devp	- pointer to our soft state
+ * @regs	- unused
+ *
+ * Interrupt service routine for IO-mapped mailbox controllers.
+ */
+static irqreturn_t
+megaraid_isr_iomapped(int irq, void *devp, struct pt_regs *regs)
+{
+	adapter_t	*adapter = (adapter_t *)devp;
+	unsigned long	flags;
+	bool_t		handled;
+
+
+	spin_lock_irqsave(adapter->host_lock, flags);
+
+	handled = megaraid_iombox_ack_sequence(adapter);
+
+	/* Loop through any pending requests */
+	if (adapter->quiescent == MRAID_FALSE) {
+		megaraid_mbox_runpendq(adapter);
+	}
+
+	spin_unlock_irqrestore(adapter->host_lock, flags);
+
+	tasklet_schedule(&adapter->dpc_h);	// schedule the DPC
+
+	if (handled == MRAID_TRUE) {
+		return IRQ_RETVAL(1);
+	}
+	else {
+		return IRQ_RETVAL(0);
+	}
+}
+
+
+/**
+ * megaraid_iombox_ack_sequence - interrupt ack sequence for IO mapped HBAs
+ * @adapter	- controller's soft state
+ *
+ * Interrupt ackrowledgement sequence for memory mapped HBAs
+ */
+static inline bool_t
+megaraid_iombox_ack_sequence(adapter_t *adapter)
+{
+	mraid_device_t	*raid_dev = ADAP2RAIDDEV(adapter);
+	volatile mbox_t	*mbox;
+	scb_t		*scb;
+	Scsi_Cmnd	*scp;
+	uint8_t		nstatus;
+	uint8_t		cmdid;
+	bool_t		handled;
+	uint8_t		byte;
+	int		i;
+
+
+	try_assertion {
+		ASSERT(spin_is_locked(adapter->host_lock));
+	}
+	catch_assertion {
+		con_log(CL_ANN, (KERN_CRIT "megaraid: host lock not locked\n"));
+	}
+	end_assertion
+
+
+
+	mbox	= raid_dev->mbox;
+
+	/*
+	 * loop till F/W has more commands for us to complete.
+	 */
+	handled = MRAID_FALSE;
+	do {
+		/* Check if a valid interrupt is pending */
+		byte = iombox_irq_state(raid_dev);
+
+		if ((byte & MBOX_VALID_INTR_BYTE) == 0) {
+			/* No more pending commands */
+			return handled;
+		}
+		handled = MRAID_TRUE;
+		iombox_set_irq_state(raid_dev, byte);
+
+		while ((nstatus = mbox->numstatus) == 0xFF)
+			cpu_relax();
+		mbox->numstatus = 0xFF;
+
+		adapter->outstanding_cmds -= nstatus;
+
+		for (i = 0; i < nstatus; i++) {
+			while ((cmdid = mbox->completed[i]) == 0xFF)
+				cpu_relax();
+
+			mbox->completed[i] = 0xFF;
+
+			/* handle internal commands right away */
+			if (unlikely(cmdid == raid_dev->int_cmdid)) {
+
+				scb		= &adapter->iscb;
+				scp		= scb->scp;
+				scp->result	= mbox->status;
+				scb->status	= mbox->status;
+
+				/*
+				 * Remove the command from the pending list
+				 * and call the internal callback routine
+				 */
+				list_del_init(&scb->list);
+				scb->state = SCB_FREE;
+				scp->scsi_done(scp);
+			}
+			else {
+				/*
+				 * SCB associated with this command id and put
+				 * in the completed list. Move the scb for
+				 * existing list to the completed list
+				 */
+				scb = MBOX_GET_CMDID_SCB(raid_dev, cmdid);
+				scb->status = mbox->status;
+				list_move_tail(&scb->list,
+						&adapter->completed_list);
+			}
+		}
+
+		/* Acknowledge interrupt */
+		iombox_irq_ack(raid_dev);
+
+	} while(1);
+}
+
+
+/**
+ * megaraid_abort_handler - abort the scsi command
+ * @scp		: command to be aborted
+ *
+ * Abort a previous SCSI request. Only commands on the pending list can be
+ * aborted. All the commands issued to the F/W must complete.
+ **/
+static int
+megaraid_abort_handler(struct scsi_cmnd *scp)
+{
+	adapter_t		*adapter;
+	mraid_device_t		*raid_dev;
+	scb_t			*scb;
+	struct list_head	*pos, *next;
+	unsigned long		iter;
+
+
+	adapter		= SCP2ADAPTER(scp);
+	raid_dev	= ADAP2RAIDDEV(adapter);
+
+	try_assertion {
+		ASSERT(spin_is_locked(adapter->host_lock));
+	}
+	catch_assertion {
+		return FAILED;
+	}
+	end_assertion
+
+	con_log(CL_ANN, (KERN_WARNING
+		"megaraid: aborting-%ld cmd=%x <c=%d t=%d l=%d>\n",
+		scp->serial_number, scp->cmnd[0], SCP2CHANNEL(scp),
+		SCP2TARGET(scp), SCP2LUN(scp)));
+
+	// If FW has stopped responding, simply return failure
+	if (raid_dev->hw_error) {
+		con_log(CL_DLEVEL1, (KERN_NOTICE
+			"megaraid: hw error, not aborting\n"));
+		return FAILED;
+	}
+
+
+	// Find out if this command is still on the pending list. If it is and
+	// was never issued, abort and return success. If the command is owned
+	// by the firmware, we must wait for it to complete by the FW.
+	// Change the state of the SCB to 'aborted' so that appropriate status
+	// can be returned from the dpc if this command ever completes.
+	scb = NULL;
+	list_for_each_safe(pos, next, &adapter->pend_list) {
+
+		scb = list_entry(pos, scb_t, list);
+
+		if (scb->scp == scp) { // Found command
+
+			scb->state |= SCB_ABORT;
+
+			/*
+			 * Check if this command was never issued. If this is
+			 * the case, take it off from the pending list and
+			 * complete.
+			 */
+			if (!(scb->state & SCB_ISSUED)) {
+
+				con_log(CL_ANN, (KERN_WARNING
+				"megaraid abort: %ld:%d[%d:%d], driver owner\n",
+					scp->serial_number, scb->sno,
+					scb->dev_channel, scb->dev_target));
+
+				scp->result = (DID_ABORT << 16);
+				scp->scsi_done(scp);
+
+				megaraid_mbox_free_scb(adapter, scb);
+
+				return SUCCESS;
+			}
+		}
+	}
+
+
+	// There might a race here, where the command was completed by the
+	// firmware and now it is on the completed list. Before we could
+	// complete the command to the kernel in dpc, the abort came.
+	// Find out if this is the case to avoid the race.
+	list_for_each_safe(pos, next, &adapter->completed_list) {
+
+		scb = list_entry(pos, scb_t, list);
+
+		if (scb->scp == scp) { // Found command
+
+			con_log(CL_ANN, (KERN_WARNING
+			"megaraid: %ld:%d[%d:%d], abort from completed list\n",
+				scp->serial_number, scb->sno,
+				scb->dev_channel, scb->dev_target));
+
+			scp->result = (DID_ABORT << 16);
+			scp->scsi_done(scp);
+
+			megaraid_mbox_free_scb(adapter, scb);
+
+			return SUCCESS;
+		}
+	}
+
+	// Check do we even own this command, in which case this would be on
+	// the pending list. If we do now own this command, return success
+	// because otherwise we would end up having the controller marked
+	// offline.
+	if ((scb) && !(scb->state & SCB_ABORT)) {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid abort: %ld:%d[%d:%d], do now own\n",
+			scp->serial_number, scb->sno, scb->dev_channel,
+			scb->dev_target));
+
+
+		// FIXME: is it ok to do a callback for this command?
+		scp->result = (DID_ABORT << 16);
+		scp->scsi_done(scp);
+
+		megaraid_mbox_free_scb(adapter, scb);
+
+		return SUCCESS;
+	}
+
+
+	// We cannot actually abort a command owned by firmware, wait some
+	// more time and hope it completes
+	iter = 0;
+	do {
+		if (adapter->flags & MRAID_BOARD_MEMMAP) {
+			megaraid_memmbox_ack_sequence(adapter);
+		}
+		else {
+			megaraid_iombox_ack_sequence(adapter);
+		}
+
+		list_for_each_safe(pos, next, &adapter->completed_list) {
+
+			scb = list_entry(pos, scb_t, list);
+
+			if (scb->scp == scp) { // Found command
+
+				con_log(CL_ANN, (KERN_WARNING
+				"megaraid: %ld:%d[%d:%d], abort complete\n",
+					scp->serial_number, scb->sno,
+					scb->dev_channel, scb->dev_target));
+
+				scp->result = (DID_ABORT << 16);
+				scp->scsi_done(scp);
+
+				megaraid_mbox_free_scb(adapter, scb);
+
+				return SUCCESS;
+			}
+		}
+
+		/*
+		 * print a message once every second only
+		 */
+		if (!(iter % 1000)) {
+			con_log(CL_ANN, (
+			"megaraid: Wait for command to complete: iter:%ld\n",
+				iter));
+		}
+
+		if (iter++ < MBOX_ABORT_SLEEP * 1000) {
+			mdelay(1);
+		}
+		else {
+			con_log(CL_ANN, (KERN_WARNING
+				"megaraid: critical hardware error!\n"));
+
+			raid_dev->hw_error = 1;
+
+			return FAILED;
+		}
+
+	} while (1);
+
+	return FAILED;
+}
+
+
+/**
+ * megaraid_reset_handler - device reset hadler for mailbox based driver
+ * @scp		: reference command
+ *
+ * Reset handler for the mailbox based controller. The commands completion is
+ * already tried by the abort handler. We try to reset SCSI reservations if
+ * any exists.
+ **/
+static int
+megaraid_reset_handler(struct scsi_cmnd *scp)
+{
+	adapter_t		*adapter;
+	scb_t			*iscb;
+	mbox_ccb_t		*ccb;
+	mraid_device_t		*raid_dev;
+	int			rval;
+
+	adapter		= SCP2ADAPTER(scp);
+	raid_dev	= ADAP2RAIDDEV(adapter);
+
+	// return failure if adapter is not responding
+	if (raid_dev->hw_error) return FAILED;
+
+	// FIXME: remove mraid_get_icmd from the code
+	iscb		= mraid_get_icmd(adapter);
+	ccb		= (mbox_ccb_t *)iscb->ccb;
+
+	// clear reservations if any
+	ccb->raw_mbox[0] = CLUSTER_CMD;
+	ccb->raw_mbox[2] = RESET_RESERVATIONS;
+
+	if (mbox_post_sync_cmd_fast(adapter, ccb->raw_mbox) == 0) {
+		con_log(CL_ANN,
+			(KERN_INFO "megaraid: reservation reset\n"));
+	}
+	else {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: reservation reset failed\n"));
+	}
+
+	mraid_free_icmd(adapter);
+
+	rval = SUCCESS;
+
+	// If there are outstanding commands, return failure
+	if (adapter->outstanding_cmds) {
+		con_log(CL_ANN, (KERN_INFO
+			"megaraid: reset failed, %d commands outstanding\n",
+			adapter->outstanding_cmds));
+		rval = FAILED;
+	}
+
+	return rval;
+}
+
+
+/*
+ * START: internal commands library
+ *
+ * This section of the driver has the common routine used by the driver and
+ * also has all the FW routines
+ */
+
+/**
+ * mbox_post_sync_cmd() - blocking command to the mailbox based controllers
+ * @adapter	- controller's soft state
+ * @raw_mbox	- the mailbox
+ *
+ * Issue a scb in synchronous and non-interrupt mode for mailbox based
+ * controllers
+ */
+static int
+mbox_post_sync_cmd(adapter_t *adapter, uint8_t raw_mbox[])
+{
+	mraid_device_t	*raid_dev = ADAP2RAIDDEV(adapter);
+	mbox64_t	*mbox64;
+	mbox_t		*mbox;
+	uint8_t		byte;
+	uint8_t		status;
+	long		i;
+
+
+	mbox64	= raid_dev->mbox64;
+	mbox	= raid_dev->mbox;
+
+	/*
+	 * Wait until mailbox is free
+	 */
+	if (megaraid_busywait_mbox(raid_dev) == MRAID_FAILURE)
+		goto blocked_mailbox;
+
+	/*
+	 * Copy mailbox data into host structure
+	 */
+	memcpy((caddr_t)mbox, (caddr_t)raw_mbox, 16);
+	mbox->cmdid		= 0xFE;
+	mbox->busy		= 1;
+	mbox->poll		= 0;
+	mbox->ack		= 0;
+	mbox->numstatus		= 0xFF;
+	mbox->status		= 0xFF;
+
+	switch (raw_mbox[0]) {
+
+	case MBOXCMD_EXTPTHRU:
+		if (adapter->highmem_dma != MRAID_TRUE) break;
+		// else fall-through
+
+	case MBOXCMD_LREAD64:
+	case MBOXCMD_LWRITE64:
+	case MBOXCMD_PASSTHRU64:
+		mbox64->xferaddr_lo	= mbox->xferaddr;
+		mbox64->xferaddr_hi	= 0;
+		mbox->xferaddr		= 0xFFFFFFFF;
+		break;
+	default:
+		mbox64->xferaddr_lo	= 0;
+		mbox64->xferaddr_hi	= 0;
+	}
+
+	if (likely(adapter->flags & MRAID_BOARD_MEMMAP)) {
+
+		wmb();
+		WRINDOOR(raid_dev, raid_dev->mbox_dma | 0x1);
+
+		// wait for maximum 1 second for status to post
+		for (i = 0; i < 40000; i++) {
+			if (mbox->numstatus != 0xFF) break;
+			udelay(25); yield();
+		}
+		if (i == 40000) {
+			con_log(CL_ANN, (KERN_WARNING
+				"megaraid mailbox: status not available\n"));
+			return -1;
+		}
+
+		// wait for maximum 1 second for poll semaphore
+		for (i = 0; i < 40000; i++) {
+			if (mbox->poll == 0x77) break;
+			udelay(25); yield();
+		}
+		if (i == 40000) {
+			con_log(CL_ANN, (KERN_WARNING
+			"megaraid mailbox: could not get poll semaphore\n"));
+			return -1;
+		}
+
+		WRINDOOR(raid_dev, raid_dev->mbox_dma | 0x2);
+		wmb();
+
+		// wait for maximum 1 second for acknowledgement
+		for (i = 0; i < 40000; i++) {
+			if ((RDINDOOR(raid_dev) & 0x2) == 0) {
+				mbox->poll	= 0;
+				mbox->ack	= 0x77;
+				break;
+			}
+			udelay(25); yield();
+		}
+		if (i == 40000) {
+			con_log(CL_ANN, (KERN_WARNING
+				"megaraid mailbox: could not acknowledge\n"));
+			return -1;
+		}
+
+		status = mbox->status;
+	}
+	else {
+		iombox_irq_disable(raid_dev);
+		iombox_issue_command(raid_dev);
+
+		while (!((byte = iombox_irq_state(raid_dev)) & MBOX_INTR_VALID))
+			cpu_relax();
+
+		status = mbox->status;
+
+		iombox_set_irq_state(raid_dev, byte);
+		iombox_irq_enable(raid_dev);
+		iombox_irq_ack(raid_dev);
+	}
+
+	// invalidate the completed command id array. After command
+	// completion, firmware would write the valid id.
+	mbox->numstatus	= 0xFF;
+	mbox->status	= 0xFF;
+	for (i = 0; i < MBOX_MAX_FIRMWARE_STATUS; i++) {
+		mbox->completed[i] = 0xFF;
+	}
+
+	return status;
+
+blocked_mailbox:
+
+	con_log(CL_ANN, (KERN_WARNING "megaraid: blocked mailbox\n") );
+	return -1;
+}
+
+
+/**
+ * mbox_post_sync_cmd_fast - blocking command to the mailbox based controllers
+ * @adapter	- controller's soft state
+ * @raw_mbox	- the mailbox
+ *
+ * Issue a scb in synchronous and non-interrupt mode for mailbox based
+ * controllers
+ */
+static int
+mbox_post_sync_cmd_fast(adapter_t *adapter, uint8_t raw_mbox[])
+{
+	mraid_device_t	*raid_dev = ADAP2RAIDDEV(adapter);
+	mbox_t		*mbox;
+	long		i;
+
+
+	mbox	= raid_dev->mbox;
+
+	// return immediately if the mailbox is busy
+	if (mbox->busy) return MRAID_FAILURE;
+
+	// Copy mailbox data into host structure
+	memcpy((caddr_t)mbox, (caddr_t)raw_mbox, 16);
+	mbox->cmdid		= 0xFE;
+	mbox->busy		= 1;
+	mbox->poll		= 0;
+	mbox->ack		= 0;
+	mbox->numstatus		= 0xFF;
+	mbox->status		= 0xFF;
+
+	wmb();
+	WRINDOOR(raid_dev, raid_dev->mbox_dma | 0x1);
+
+	for (i = 0; i < 0xFFFFF; i++) {
+		if (mbox->numstatus != 0xFF) break;
+	}
+
+	WRINDOOR(raid_dev, raid_dev->mbox_dma | 0x2);
+	wmb();
+
+	return mbox->status;
+}
+
+
+/**
+ * megaraid_busywait_mbox() - Wait until the controller's mailbox is available
+ * @raid_dev	- RAID device (HBA) soft state
+ *
+ * wait until the controller's mailbox is available to accept more commands.
+ */
+static inline status_t
+megaraid_busywait_mbox(mraid_device_t *raid_dev)
+{
+	volatile mbox_t	*mbox = raid_dev->mbox;
+
+	if (mbox->busy)
+		return __megaraid_busywait_mbox(raid_dev);
+
+	return MRAID_SUCCESS;
+}
+
+
+/**
+ * __megaraid_busywait_mbox() - Wait until controller's mailbox is available
+ * @raid_dev	- mailbox data structures
+ *
+ * wait until the controller's mailbox is available to accept more commands.
+ */
+static inline status_t
+__megaraid_busywait_mbox(mraid_device_t *raid_dev)
+{
+	volatile mbox_t	*mbox = raid_dev->mbox;
+	unsigned long	counter;
+
+
+	for (counter = 0; counter < 10000; counter++) {
+
+		if (!mbox->busy) return MRAID_SUCCESS;
+
+		udelay(100); yield();
+	}
+	return MRAID_FAILURE;	/* give up after 1 second */
+}
+
+
+
+/**
+ * megaraid_mbox_product_info - some static information about the controller
+ * @adapter	- our soft state
+ *
+ * issue commands to the controller to grab some parameters required by our
+ * caller.
+ */
+static status_t
+megaraid_mbox_product_info(adapter_t *adapter)
+{
+	mraid_device_t		*raid_dev = ADAP2RAIDDEV(adapter);
+	mbox_ccb_t		*ccb;
+	mbox_t			*mbox;
+	mraid_pinfo_t		*pinfo;
+	dma_addr_t		pinfo_dma_h;
+	mraid_inquiry3_t	*mraid_inq3;
+	scb_t			*iscb;
+	int			adapter_max_cmds;
+	int			i;
+
+
+	// FIXME: mraid_get_icmd not required, remove.....
+	iscb	= mraid_get_icmd(adapter);
+	ccb	= (mbox_ccb_t *)iscb->ccb;
+
+	/*
+	 * Issue an ENQUIRY3 command to find out if this is a 40LD controller.
+	 * Depending on whether we have a 40LD controller or not, we will need
+	 * to issue different commands to find out certain adapter parameters,
+	 * e.g., max channels, max commands etc.
+	 */
+	pinfo = pci_alloc_consistent(adapter->pdev, sizeof(mraid_pinfo_t),
+			&pinfo_dma_h);
+
+	if (pinfo == NULL) {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: out of memory, %s %d\n", __FUNCTION__,
+			__LINE__));
+		mraid_free_icmd(adapter);
+
+		return MRAID_FAILURE;
+	}
+	memset(pinfo, 0, sizeof(mraid_pinfo_t));
+
+	mbox = ccb->mbox;
+
+	mbox->xferaddr = (uint32_t)adapter->ibuf_dma_h;
+	memset((void *)adapter->ibuf, 0, MBOX_IBUF_SIZE);
+
+	// NOTE: ccb->raw_mbox and ccb->mbox are same memory location
+	ccb->raw_mbox[0] = FC_NEW_CONFIG;
+	ccb->raw_mbox[2] = NC_SUBOP_ENQUIRY3;
+	ccb->raw_mbox[3] = ENQ3_GET_SOLICITED_FULL;
+
+	// Issue the command
+	if (mbox_post_sync_cmd(adapter, ccb->raw_mbox) == 0) {
+
+		/*
+		 * Collect information about state of each physical drive
+		 * attached to the controller. We will expose all the disks
+		 * which are not part of RAID
+		 */
+		mraid_inq3 = (mraid_inquiry3_t *)adapter->ibuf;
+		for (i = 0; i < MBOX_MAX_PHYSICAL_DRIVES; i++) {
+			raid_dev->pdrv_state[i] = mraid_inq3->pdrv_state[i];
+		}
+
+		/*
+		 * 40LD controller
+		 * Get product info for information like number of channels,
+		 * maximum commands supported.
+		 */
+		raid_dev->flags = MBOX_BOARD_40LD;
+
+		memset((caddr_t)ccb->raw_mbox, 0, sizeof(ccb->raw_mbox));
+		mbox->xferaddr = (uint32_t)pinfo_dma_h;
+
+		ccb->raw_mbox[0] = FC_NEW_CONFIG;
+		ccb->raw_mbox[2] = NC_SUBOP_PRODUCT_INFO;
+
+		if (mbox_post_sync_cmd(adapter, ccb->raw_mbox) != 0) {
+
+			con_log(CL_ANN, (KERN_WARNING
+				"megaraid: product info failed\n"));
+
+			pci_free_consistent(adapter->pdev,
+				sizeof(mraid_pinfo_t), pinfo, pinfo_dma_h);
+
+			mraid_free_icmd(adapter);
+
+			return MRAID_FAILURE;
+		}
+	}
+	else {	// 8LD controller
+		mraid_extinq_t	*ext_inq;
+		mraid_inquiry_t	*inq;
+		dma_addr_t	dma_handle;
+
+		raid_dev->flags = MBOX_BOARD_8LD;
+
+		ext_inq = pci_alloc_consistent(adapter->pdev,
+				sizeof(mraid_extinq_t), &dma_handle);
+
+		if (ext_inq == NULL) {
+
+			con_log(CL_ANN, (KERN_WARNING
+				"megaraid: out of memory, %s %d.\n",
+				__FUNCTION__, __LINE__));
+
+			pci_free_consistent(adapter->pdev,
+					sizeof(mraid_pinfo_t), pinfo,
+					pinfo_dma_h);
+
+			mraid_free_icmd(adapter);
+
+			return MRAID_FAILURE;
+		}
+
+		/*
+		 * issue old 0x04 command to adapter
+		 */
+		inq		= &ext_inq->raid_inq;
+		memset((caddr_t)ccb->raw_mbox, 0, sizeof(mbox_t));
+		mbox->xferaddr	= (uint32_t)dma_handle;
+		mbox->cmd	= MBOXCMD_ADPEXTINQ;
+
+		if (mbox_post_sync_cmd(adapter, ccb->raw_mbox) == 0) {
+
+			con_log(CL_ANN, (KERN_WARNING
+			"megaraid error: adapter inquiry failed\n") );
+
+			pci_free_consistent(adapter->pdev,
+					sizeof(mraid_extinq_t), ext_inq,
+					dma_handle);
+
+			pci_free_consistent(adapter->pdev,
+					sizeof(mraid_pinfo_t), pinfo,
+					pinfo_dma_h);
+
+			mraid_free_icmd(adapter);
+
+			return MRAID_FAILURE;
+		}
+
+		/*
+		 * Collect information about state of each physical drive
+		 * attached to the controller. We will expose all the disks
+		 * which are not part of RAID
+		 */
+		for (i = 0; i < MBOX_MAX_PHYSICAL_DRIVES; i++) {
+			raid_dev->pdrv_state[i] = inq->pdrv_info.pdrv_state[i];
+		}
+
+		/*
+		 * update the product info structure with mraid_inquiry
+		 * structure
+		 */
+		pinfo->max_commands	= inq->adapter_info.max_commands;
+		pinfo->nchannels	= inq->adapter_info.nchannels;
+
+		for (i = 0; i < 4; i++) {
+			pinfo->fw_version[i] =
+				inq->adapter_info.fw_version[i];
+
+			pinfo->bios_version[i] =
+				inq->adapter_info.bios_version[i];
+		}
+
+		pci_free_consistent(adapter->pdev, sizeof(mraid_extinq_t),
+				ext_inq, dma_handle);
+	}
+
+	/*
+	 * Setup some parameters for host, as required by our caller
+	 */
+	adapter->max_channel = pinfo->nchannels;
+
+	/*
+	 * we will export all the logical drives on a single channel.
+	 * Add 1 since inquires do not come for inititor ID
+	 */
+	adapter->max_target	= MAX_LOGICAL_DRIVES_40LD + 1;
+	adapter->max_lun	= 8;	// up to 8 LUNs for non-disk devices
+
+	/*
+	 * Reserve one ID for internal commands. For commands issued
+	 * internally, always use command ID 0.
+	 */
+	raid_dev->int_cmdid	= 0;
+	adapter->iscb.sno	= 0;
+
+	// maximum commands supported by the firmware
+	if (pinfo->max_commands > MBOX_MAX_COMMANDS) {
+		adapter_max_cmds = MBOX_MAX_COMMANDS;
+	}
+	else {
+		adapter_max_cmds = pinfo->max_commands;
+	}
+
+	/*
+	 * Populate the commands id pool with available command ids and
+	 * invalidate rest of the entries.
+	 * ID 0 is reserved for driver internal commands
+	 */
+	for (i = 0; i < adapter_max_cmds - 1; i++) {
+		raid_dev->cmdid_instance[i].cmdid	= i + 1;
+		raid_dev->cmdid_instance[i].scb		= NULL;
+	}
+	raid_dev->cmdid_index = i - 1;	// index of last available cmd id
+
+	for ( ; i < MBOX_MAX_COMMANDS; i++) {	// invalidate rest of the slots
+		raid_dev->cmdid_instance[i].cmdid	= -1;
+		raid_dev->cmdid_instance[i].scb		= NULL;
+	}
+
+	/*
+	 * Set the number of supported commands equal to that supported by the
+	 * _driver_
+	 */
+	adapter->max_cmds	= megaraid_driver_cmds;
+
+	memset(adapter->fw_version, 0, VERSION_SIZE);
+	memset(adapter->bios_version, 0, VERSION_SIZE);
+
+	/*
+	 * use HP firmware and bios version encoding for HP controllers
+	 */
+	if (pinfo->subsysvid == PCI_VENDOR_ID_HP) {
+		sprintf(adapter->fw_version, "%c%d%d.%d%d",
+			pinfo->fw_version[2],
+			pinfo->fw_version[1] >> 8,
+			pinfo->fw_version[1] & 0x0f,
+			pinfo->fw_version[0] >> 8,
+			pinfo->fw_version[0] & 0x0f);
+		sprintf(adapter->bios_version, "%c%d%d.%d%d",
+			pinfo->bios_version[2],
+			pinfo->bios_version[1] >> 8,
+			pinfo->bios_version[1] & 0x0f,
+			pinfo->bios_version[0] >> 8,
+			pinfo->bios_version[0] & 0x0f);
+	}
+	else {
+		memcpy(adapter->fw_version, pinfo->fw_version, 4);
+		adapter->fw_version[4] = 0;
+
+		memcpy(adapter->bios_version, pinfo->bios_version, 4);
+		adapter->bios_version[4] = 0;
+	}
+
+	/*
+	 * Extra checks for some buggy firmware
+	 */
+	if ((pinfo->subsysid == 0x1111) && (pinfo->subsysvid == 0x1111)) {
+
+		if (!strcmp(adapter->fw_version, "3.00") ||
+				!strcmp(adapter->fw_version, "3.01")) {
+
+			con_log (CL_ANN,  (KERN_WARNING
+				"megaraid: Your  card is a Dell PERC "
+				"2/SC RAID controller with  "
+				"firmware\nmegaraid: 3.00 or 3.01.  "
+				"This driver is known to have "
+				"corruption issues\nmegaraid: with "
+				"those firmware versions on this "
+				"specific card.  In order\nmegaraid: "
+				"to protect your data, please upgrade "
+				"your firmware to version\nmegaraid: "
+				"3.10 or later, available from the "
+				"Dell Technical Support web\n"
+				"megaraid: site at\nhttp://support."
+				"dell.com/us/en/filelib/download/"
+				"index.asp?fileid=2940\n"
+			));
+		}
+	}
+
+	/*
+	 * If we have a HP 1M(0x60E7)/2M(0x60E8) controller with firmware
+	 * H.01.07, H.01.08, and H.01.09 disable 64 bit support, since this
+	 * firmware cannot handle 64 bit addressing
+	 */
+	if ((pinfo->subsysvid == PCI_VENDOR_ID_HP) &&
+		((pinfo->subsysid == 0x60E7)||(pinfo->subsysid == 0x60E8))) {
+
+		if (!strcmp(adapter->fw_version, "H01.07")		||
+			!strcmp(adapter->fw_version, "H01.08")	||
+			!strcmp(adapter->fw_version, "H01.09")) {
+
+			con_log(CL_ANN, (KERN_WARNING
+				"megaraid: Firmware H.01.07, H.01.08, and "
+				"H.01.09 on 1M/2M controllers\n"
+				"megaraid: do not support 64 bit "
+				"addressing.\nmegaraid: DISABLING "
+				"64 bit support.\n") );
+
+			adapter->flags		&= ~MRAID_DMA_64;
+			adapter->highmem_dma	= MRAID_FALSE;
+		}
+	}
+
+	pci_free_consistent(adapter->pdev, sizeof(mraid_pinfo_t), pinfo,
+			pinfo_dma_h);
+
+	mraid_free_icmd(adapter);
+
+	return MRAID_SUCCESS;
+}
+
+
+
+/**
+ * megaraid_mbox_extended_cdb - check for support for extended CDBs
+ * @adapter	- soft state for the controller
+ *
+ * this routine check whether the controller in question supports extended
+ * ( > 10 bytes ) CDBs
+ */
+static status_t
+megaraid_mbox_extended_cdb(adapter_t *adapter)
+{
+	mbox_ccb_t	*ccb;
+	mbox_t		*mbox;
+	scb_t		*iscb;
+	status_t	rval;
+
+	iscb		= mraid_get_icmd(adapter);
+	ccb		= (mbox_ccb_t *)iscb->ccb;
+	mbox		= ccb->mbox;
+
+	memset((caddr_t)ccb->raw_mbox, 0, sizeof(mbox_t));
+	mbox->xferaddr	= (uint32_t)adapter->ibuf_dma_h;
+
+	memset((void *)adapter->ibuf, 0, MBOX_IBUF_SIZE);
+
+	ccb->raw_mbox[0] = MAIN_MISC_OPCODE;
+	ccb->raw_mbox[2] = SUPPORT_EXT_CDB;
+
+	/*
+	 * Issue the command
+	 */
+	rval = MRAID_FAILURE;
+	if (mbox_post_sync_cmd(adapter, ccb->raw_mbox) == 0) {
+		rval = MRAID_SUCCESS;
+	}
+
+	mraid_free_icmd(adapter);
+
+	return rval;
+}
+
+
+/**
+ * megaraid_mbox_support_ha - Do we support clustering
+ * @adapter	- soft state for the controller
+ * @init_id	- ID of the initiator
+ *
+ * Determine if the firmware supports clustering and the ID of the initiator.
+ */
+static status_t
+megaraid_mbox_support_ha(adapter_t *adapter, uint16_t *init_id)
+{
+	mbox_ccb_t	*ccb;
+	mbox_t		*mbox;
+	scb_t		*iscb;
+	status_t	rval;
+
+
+	iscb	= mraid_get_icmd(adapter);
+	ccb	= (mbox_ccb_t *)iscb->ccb;
+	mbox	= ccb->mbox;
+	memset((caddr_t)ccb->raw_mbox, 0, sizeof(mbox_t));
+	mbox->xferaddr = (uint32_t)adapter->ibuf_dma_h;
+
+	memset((void *)adapter->ibuf, 0, MBOX_IBUF_SIZE);
+
+	ccb->raw_mbox[0] = GET_TARGET_ID;
+
+	// Issue the command
+	*init_id = 7;
+	rval =  MRAID_FAILURE;
+	if (mbox_post_sync_cmd(adapter, ccb->raw_mbox) == 0) {
+
+		*init_id = *(uint8_t *)adapter->ibuf;
+
+		con_log(CL_ANN, (KERN_INFO
+			"megaraid: cluster firmware, initiator ID: %d\n",
+			*init_id));
+
+		rval =  MRAID_SUCCESS;
+	}
+
+	mraid_free_icmd(adapter);
+
+	return rval;
+}
+
+
+/**
+ * megaraid_mbox_boot_enabled - check for boot support
+ * @adapter	- soft state for the controller
+ *
+ * this routine check whether the controller in question has the BIOS enabled
+ * for booting purposes
+ */
+static status_t
+megaraid_mbox_boot_enabled(adapter_t *adapter)
+{
+	mbox_ccb_t	*ccb;
+	mbox_t		*mbox;
+	scb_t		*iscb;
+	status_t	rval;
+
+
+	iscb	= mraid_get_icmd(adapter);
+	ccb	= (mbox_ccb_t *)iscb->ccb;
+	mbox	= ccb->mbox;
+
+	memset((caddr_t)ccb->raw_mbox, 0, sizeof(mbox_t));
+	memset((void *)adapter->ibuf, 0, MBOX_IBUF_SIZE);
+
+	mbox->xferaddr		= (uint32_t)adapter->ibuf_dma_h;
+	ccb->raw_mbox[0]	= IS_BIOS_ENABLED;
+	ccb->raw_mbox[2]	= GET_BIOS;
+
+	// issue the command
+	rval = MRAID_FAILURE;
+	if (mbox_post_sync_cmd(adapter, ccb->raw_mbox) == 0) {
+		if (*(char *)adapter->ibuf) {
+			adapter->boot_enabled = MRAID_TRUE;
+		}
+		else {
+			adapter->boot_enabled = MRAID_FALSE;
+		}
+
+		rval = MRAID_SUCCESS;
+	}
+
+	mraid_free_icmd(adapter);
+
+	return rval;
+}
+
+
+/**
+ * megaraid_mbox_get_boot_dev - find out our boot device
+ * @adapter	- soft state for the controller
+ *
+ * Find out the booting device. All the physical devices are exported on their
+ * native address (channel and target) and no re-ordering is done for them.
+ * The logical drives are exported on a virtual channel. Logical drives are
+ * re-ordered so that the boot logical drive is the first one to be exposed
+ * before any other logical drive.
+ */
+static void
+megaraid_mbox_get_boot_dev(adapter_t *adapter)
+{
+	struct private_bios_data	*bios_data;
+	mbox_ccb_t			*ccb;
+	mbox_t				*mbox;
+	uint16_t			cksum;
+	uint8_t				*cksum_p;
+	uint8_t				boot_dev;
+	scb_t				*iscb;
+	int				i;
+
+
+	iscb		= mraid_get_icmd(adapter);
+	ccb		= (mbox_ccb_t *)iscb->ccb;
+	mbox		= ccb->mbox;
+	memset((caddr_t)ccb->raw_mbox, 0, sizeof(mbox_t));
+	mbox->xferaddr	= (uint32_t)adapter->ibuf_dma_h;
+
+	memset((void *)adapter->ibuf, 0, MBOX_IBUF_SIZE);
+
+	ccb->raw_mbox[0] = BIOS_PVT_DATA;
+	ccb->raw_mbox[2] = GET_BIOS_PVT_DATA;
+
+	/*
+	 * All logical drives appear on a virtual channel. This virtual
+	 * channel is exported *after* all the physical channels. bd_channel
+	 * represents the physical channel of the boot device, which is
+	 * meaningless for logical drives. We invalidate (set to 0xFF) for
+	 * logical drives
+	 */
+	adapter->virtual_ch	= adapter->max_channel;
+	adapter->bd_channel	= 0xFF;
+
+	if (mbox_post_sync_cmd(adapter, ccb->raw_mbox) == 0) {
+		bios_data = (struct private_bios_data *)adapter->ibuf;
+
+		cksum = 0;
+		cksum_p = (char *)bios_data;
+		for (i = 0; i < 14; i++) {
+			cksum += (uint8_t)(*cksum_p++);
+		}
+
+		if (bios_data->cksum == (uint16_t)(0-cksum) ) {
+			/*
+			 * If MSB is set, a physical drive is set as boot
+			 * device.
+			 */
+			if (bios_data->boot_drv & 0x80) {
+				boot_dev	= bios_data->boot_drv & 0x7F;
+				adapter->bd_channel	= boot_dev / 16;
+				adapter->bd_target	= boot_dev % 16;
+			}
+			else {
+				adapter->bd_target	= bios_data->boot_drv;
+			}
+		}
+	}
+	else {
+		con_log(CL_ANN, (KERN_WARNING
+		"megaraid: No BIOS private data, Assuming defaults\n"));
+	}
+
+	/*
+	 * Prepare the device ids array and shuffle the devices around
+	 * so that boot device/channel are exported first
+	 */
+	mraid_setup_device_map(adapter);
+
+	mraid_free_icmd(adapter);
+
+	return;
+}
+
+
+/**
+ * megaraid_mbox_get_max_sg - maximum sg elements supported by the firmware
+ * @adapter	- soft state for the controller
+ *
+ * Find out the maximum number of scatter-gather elements supported by the
+ * firmware
+ */
+static int
+megaraid_mbox_get_max_sg(adapter_t *adapter)
+{
+	mbox_ccb_t	*ccb;
+	mbox_t		*mbox;
+	scb_t		*iscb;
+	int		nsg;
+
+
+	iscb	= mraid_get_icmd(adapter);
+	ccb	= (mbox_ccb_t *)iscb->ccb;
+	mbox	= ccb->mbox;
+	memset((caddr_t)ccb->raw_mbox, 0, sizeof(mbox_t));
+	mbox->xferaddr = (uint32_t)adapter->ibuf_dma_h;
+
+	memset((void *)adapter->ibuf, 0, MBOX_IBUF_SIZE);
+
+	ccb->raw_mbox[0] = MAIN_MISC_OPCODE;
+	ccb->raw_mbox[2] = GET_MAX_SG_SUPPORT;
+
+	// Issue the command
+	if (mbox_post_sync_cmd(adapter, ccb->raw_mbox) == 0) {
+		nsg =  *(uint8_t *)adapter->ibuf;
+	}
+	else {
+		nsg =  MBOX_DEFAULT_SG_SIZE;
+	}
+
+	if (nsg > MBOX_MAX_SG_SIZE) nsg = MBOX_MAX_SG_SIZE;
+
+	mraid_free_icmd(adapter);
+
+	return nsg;
+}
+
+
+/**
+ * megaraid_mbox_display_scb - display SCB information, mostly debug purposes
+ * @param adapter	: controllers' soft state
+ * @param scb		: SCB to be displayed
+ * @param level	: debug level for console print
+ */
+static void
+megaraid_mbox_display_scb(adapter_t *adapter, scb_t *scb, int level)
+{
+	mbox_ccb_t		*ccb;
+	struct scsi_cmnd	*scp;
+	mbox_t			*mbox;
+	int			i;
+
+
+	ccb	= (mbox_ccb_t *)scb->ccb;
+	scp	= scb->scp;
+	mbox	= ccb->mbox;
+
+	con_log(level, (KERN_NOTICE
+		"megaraid mailbox: status:%#x cmd:%#x id:%#x ", scb->status,
+		mbox->cmd, scb->sno));
+
+	con_log(level, ("sec:%#x lba:%#x addr:%#x ld:%d sg:%d\n",
+		mbox->numsectors, mbox->lba, mbox->xferaddr, mbox->logdrv,
+		mbox->numsge));
+
+	if (!scp) return;
+
+	con_log(level, (KERN_NOTICE "scsi cmnd: "));
+
+	for (i = 0; i < scp->cmd_len; i++) {
+		con_log(level, ("%#2.02x ", scp->cmnd[i]));
+	}
+
+	con_log(level, ("\n"));
+
+	return;
+}
+
+
+/*
+ * END: internal commands library
+ */
+
+/*
+ * START: Interface for the common management module
+ *
+ * This is the module, which interfaces with the common mangement module to
+ * provide support for ioctl and sysfs
+ */
+
+/**
+ * megaraid_cmm_register - register with the mangement module
+ * @param adapter	: HBA soft state
+ *
+ * Register with the management module, which allows applications to issue
+ * ioctl calls to the drivers. This interface is used by the management module
+ * to setup sysfs support as well.
+ */
+static status_t
+megaraid_cmm_register(adapter_t *adapter)
+{
+	mraid_mmadp_t	adp;
+
+	adp.unique_id		= adapter->unique_id;
+	adp.drvr_type		= DRVRTYPE_MBOX;
+	adp.drvr_data		= (ulong)adapter;
+	adp.pdev		= adapter->pdev;
+	adp.issue_uioc		= megaraid_mbox_mm_cmd;
+	adp.timeout		= 30;
+
+	mraid_mm_register_adp(&adp); //FIXME: Check for error messages
+
+	return MRAID_SUCCESS;
+}
+
+
+/**
+ * megaraid_cmm_unregister - un-register with the mangement module
+ * @param adapter	: HBA soft state
+ *
+ * Un-register with the management module.
+ */
+static status_t
+megaraid_cmm_unregister(adapter_t *adapter)
+{
+	mraid_mm_unregister_adp( adapter->unique_id );
+	return MRAID_SUCCESS;
+}
+
+
+/**
+ * megaraid_mbox_mm_cmd - interface for CMM to issue commands to LLD
+ * @param drvr_data	: LLD specific data
+ * @param kioc		: CMM interface packet
+ * @param action	: command action
+ *
+ * This routine is invoked whenever the Common Mangement Module (CMM) has a
+ * command for us. The 'action' parameter specifies if this is a new command
+ * or otherwise.
+ * TODO: add support for command aborting
+ */
+static int
+megaraid_mbox_mm_cmd(ulong drvr_data, uioc_t *kioc, uint32_t action)
+{
+	adapter_t	*adp;
+	int		i;
+
+	if (!kioc || !drvr_data)
+		return (-EINVAL);
+
+	if (action != IOCTL_ISSUE) {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: unsupported management action:%#2x\n",
+			action));
+		return LC_ENOTSUPP;
+	}
+
+	/*
+	 * Check if drvr_data points to a valid adapter
+	 */
+	adp = (adapter_t *)drvr_data;
+
+	for (i = 0; i < MAX_CONTROLLERS; i++) {
+		if (mraid_driver_g.adapter[i] == adp) {
+			break;
+		}
+	}
+
+	if (i == MAX_CONTROLLERS) {
+		con_log(CL_ANN, ("megaraid ioctl: no such adapter\n"));
+		return (-ENODEV);
+	}
+
+	// make sure this adapter is not being detached right now.
+	if (atomic_read(&adp->being_detached)) {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: reject management request, detaching.\n"));
+		return (-ENODEV);
+	}
+
+	switch (kioc->opcode) {
+
+	case GET_ADAP_INFO:
+
+		kioc->status =  gather_hbainfo(adp,
+				(mraid_hba_info_t *)(ulong)kioc->cmdbuf);
+
+		kioc->done(kioc);
+
+		return kioc->status;
+
+	case MBOX_CMD:
+
+		return megaraid_mbox_internal_command(adp, kioc);
+
+	default:
+		return (-EINVAL);
+	}
+
+	return 0;
+}
+
+/**
+ * megaraid_mbox_internal_command - issues commands routed through CMM
+ * @param adapter	: HBA soft state
+ * @param kioc		: management command packet
+ *
+ * Issues commands, which are routed through the management module.
+ */
+static int
+megaraid_mbox_internal_command(adapter_t *adapter, uioc_t *kioc)
+{
+	mraid_device_t		*raid_dev = ADAP2RAIDDEV(adapter);
+	mbox64_t		*mbox64;
+	scb_t			*scb;
+	mbox_ccb_t		*ccb;
+	Scsi_Cmnd		*scmd;
+	uint8_t*		raw_mbox;
+	unsigned long		flags = 0;
+
+	/*
+	 * The internal commands share one command id and hence are serialized.
+	 * This is so because we want to reserve maximum number of available
+	 * command ids for the I/O commands.
+	 * The mutex is released when the command is completed by the
+	 * firmware.
+	 */
+	down(&adapter->imtx);
+
+	mbox64		= (mbox64_t *)(ulong)kioc->cmdbuf;
+	raw_mbox	= (uint8_t*) &mbox64->mbox32;
+	scb		= &adapter->iscb;
+	ccb		= (mbox_ccb_t *)scb->ccb;
+	scmd		= &adapter->isc;
+
+	memset(scmd, 0, sizeof(Scsi_Cmnd));
+
+	scmd->device	= &adapter->isdev;
+	SCP2HOST(scmd)	= adapter->host;
+	scmd->buffer	= (void *)scb;
+	scmd->cmnd[0]	= MRAID_INTERNAL_COMMAND;
+
+	scb->state	= SCB_ACTIVE;
+	scb->scp	= scmd;
+
+	memcpy(ccb->mbox64, mbox64, sizeof(mbox64_t));
+
+	scb->gp		= (ulong)kioc;
+	scmd->state	= 0;
+	scb->sno	= raid_dev->int_cmdid;
+
+	/*
+	 * If it is a logdrv random delete operation, we have to wait till
+	 * there are no outstanding cmds at the fw and then issue it directly
+	 */
+	if (raw_mbox[0] == FC_DEL_LOGDRV && raw_mbox[2] == OP_DEL_LOGDRV) {
+
+		if (wait_till_fw_empty(adapter))
+			return (-ETIME);
+
+		INIT_LIST_HEAD( &scb->list );
+		scmd->scsi_done	= megaraid_mbox_internal_done;
+
+		if (mbox_post_cmd(adapter, scb) != MRAID_SUCCESS)
+			return (-EBUSY);
+
+		return 0;
+	}
+
+	spin_lock_irqsave(adapter->host_lock, flags);
+	megaraid_queue_command(scmd, megaraid_mbox_internal_done);
+	spin_unlock_irqrestore(adapter->host_lock, flags);
+
+	return 0;
+}
+
+static int
+wait_till_fw_empty( adapter_t* adp )
+{
+	DECLARE_WAIT_QUEUE_HEAD(wq);
+
+	/*
+	 * Set the quiescent flag to stop issuing cmds to FW.
+	 */
+	//TODO: spin_lock protect ?!
+	adp->quiescent = MRAID_TRUE;
+
+	/*
+	 * Wait till there are no more cmds outstanding at FW
+	 */
+	while (adp->outstanding_cmds > 0)
+		sleep_on_timeout( &wq, 1*HZ );
+
+	//TODO: Implement a countdown mechanism where if fw doesn't
+	//complete its cmds in a certain period, we have to return
+	//error
+
+	return 0;
+}
+
+
+/**
+ * megaraid_mbox_internal_done()
+ * @scmd - internal scsi command
+ *
+ * Callback routine for internal commands originated from the management
+ * module. Also, release the adapter mutex used to serialize access to
+ * internal command index.
+ */
+static void
+megaraid_mbox_internal_done(Scsi_Cmnd *scmd)
+{
+	adapter_t		*adapter = SCP2ADAPTER(scmd);
+	scb_t			*scb;
+	uioc_t			*kioc;
+	mbox64_t		*mbox64;
+	uint8_t			*raw_mbox;
+
+	scb			= (scb_t *)scmd->buffer;
+	kioc			= (uioc_t *)scb->gp;
+	kioc->status		= LC_SUCCESS;
+	mbox64			= (mbox64_t *)(ulong)kioc->cmdbuf;
+	mbox64->mbox32.status	= scmd->result;
+	raw_mbox		= (uint8_t*) &mbox64->mbox32;
+
+
+	if (raw_mbox[0] == FC_DEL_LOGDRV && raw_mbox[2] == OP_DEL_LOGDRV
+							&& !scmd->result) {
+		/*
+		 * It was a del logdrv command and it succeeded
+		 */
+		megaraid_update_logdrv_ids( adapter );
+		adapter->quiescent = MRAID_FALSE;
+		megaraid_mbox_runpendq( adapter );
+	}
+
+	up(&adapter->imtx);	// ready for the next command
+
+	kioc->done(kioc);
+
+	return;
+}
+
+
+/**
+ * megaraid_update_logdrv_ids - update logical drive ids after drive deletion
+ * @param adp	: HBA soft state
+ *
+ * Update the logical drives ids in the device_ids array after a random drive
+ * deletion operation. The new ids would then be automatically picked up by the
+ * queue routines.
+ * We would need to explicitly update the drive ids for the commands on the
+ * pending lists though.
+ */
+static void
+megaraid_update_logdrv_ids( adapter_t* adp )
+{
+	int			i;
+	uint8_t			*rm;
+	scb_t			*scb;
+	mbox_ccb_t		*ccb;
+	struct list_head 	*pos;
+	struct list_head	*next;
+
+	// Change the logical drives numbers in device_ids array one
+	// slot in device_ids is reserved for target id, that's why
+	// "<=" below
+	for (i = 0; i <= MAX_LOGICAL_DRIVES_40LD; i++) {
+
+		if (adp->device_ids[adp->virtual_ch][i] < 0x80) {
+			adp->device_ids[adp->virtual_ch][i] += 0x80;
+		}
+	}
+
+	if (list_empty(&adp->pend_list))
+		return;
+
+	list_for_each_safe (pos, next, &adp->pend_list) {
+
+		scb = list_entry( pos, scb_t, list );
+		ccb = (mbox_ccb_t*)scb->ccb;
+
+		if (scb->state & SCB_ISSUED) {
+			con_log(CL_ANN, (KERN_WARNING
+				"megaraid: invalid scb state\n"));
+			continue;
+		}
+
+		rm = ccb->raw_mbox;
+
+		// LD  read/write operations
+		if (rm[0] == MBOXCMD_LREAD || rm[0] == MBOXCMD_LWRITE ||
+				rm[0] == MBOXCMD_LREAD64 ||
+				rm[0] == MBOXCMD_LWRITE64) {
+
+			if (ccb->mbox->logdrv < 0x80) {
+				ccb->mbox->logdrv += 0x80;
+			}
+		}
+
+		// LD  passthru operations
+		if (ccb->pthru->islogical &&
+				(rm[0] == MBOXCMD_PASSTHRU ||
+				rm[0] == MBOXCMD_PASSTHRU64)) {
+
+			if (ccb->pthru->logdrv < 0x80) {
+				ccb->pthru->logdrv += 0x80;
+			}
+		}
+
+		if (ccb->epthru->islogical && rm[0] == MBOXCMD_EXTPTHRU) {
+			if (ccb->epthru->logdrv < 0x80) {
+				ccb->epthru->logdrv += 0x80;
+			}
+		}
+	}
+}
+
+
+/**
+ * gather_hbainfo - HBA characteristics for the applications
+ * @param adapter	: HBA soft state
+ * @param hinfo		: pointer to the caller's host info strucuture
+ */
+static int
+gather_hbainfo(adapter_t *adp, mraid_hba_info_t *hinfo)
+{
+	hinfo->pci_vendor_id	= adp->pdev->vendor;
+	hinfo->pci_device_id	= adp->pdev->device;
+	hinfo->subsys_vendor_id	= adp->pdev->subsystem_vendor;
+	hinfo->subsys_device_id	= adp->pdev->subsystem_device;
+
+	hinfo->pci_bus		= adp->pdev->bus->number;
+	hinfo->pci_dev_fn	= adp->pdev->devfn;
+	hinfo->pci_slot		= PCI_SLOT(adp->pdev->devfn);
+	hinfo->irq		= adp->host->irq;
+	hinfo->baseport		= ADAP2RAIDDEV(adp)->baseport;
+
+	hinfo->unique_id	= (hinfo->pci_bus << 8) | adp->pdev->devfn;
+	hinfo->host_no		= adp->host->host_no;
+
+	return 0;
+}
+
+/*
+ * END: Interface for the common management module
+ */
+
+
+/*
+ * END: Mailbox Low Level Driver
+ */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+module_init(megaraid_init);
+module_exit(megaraid_exit);
+#else
+static Scsi_Host_Template driver_template = MRAID_TEMPLATE;
+#include "../scsi_module.c"
+#endif
+
+/* vim: set ts=8 sw=8 tw=78 ai si: */
diff -urNp linux-2.6.5/drivers/scsi/megaraid_mbox.h linux-2.6.5.SUSE/drivers/scsi/megaraid_mbox.h
--- linux-2.6.5/drivers/scsi/megaraid_mbox.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/megaraid_mbox.h	2004-04-27 18:46:34.000000000 +0200
@@ -0,0 +1,247 @@
+/*
+ *
+ *			Linux MegaRAID device driver
+ *
+ * Copyright (c) 2003-2004  LSI Logic Corporation.
+ *
+ *	   This program is free software; you can redistribute it and/or
+ *	   modify it under the terms of the GNU General Public License
+ *	   as published by the Free Software Foundation; either version
+ *	   2 of the License, or (at your option) any later version.
+ *
+ * FILE		: megaraid.h
+ * Version	: v2.20.0 (Apr 14 2004)
+ */
+
+#ifndef _MEGARAID_H_
+#define _MEGARAID_H_
+
+#include "kdep.h"
+#include "mbox_defs.h"
+#include "mega_common.h"
+
+
+#define MEGARAID_VERSION	\
+	"v2.20.0.B2.04.27.2004 (Release Date: Tue Apr 27 12:46:24 EDT 2004)"
+
+
+/*
+ * Define some PCI values here until they are put in the kernel
+ */
+#define PCI_DEVICE_ID_DISCOVERY			0x000E
+#define PCI_DEVICE_ID_PERC4_DI			0x000F
+#define PCI_DEVICE_ID_PERC4_QC_VERDE		0x0407
+#define PCI_DEVICE_ID_PERC4E_SI_DI		0x0013
+#define PCI_DEVICE_ID_PERC4E_DC_SC		0x0408
+#define PCI_DEVICE_ID_MEGARAID_SATA_PCIX	0x0409
+
+#ifndef PCI_SUBSYS_ID_FSC
+#define PCI_SUBSYS_ID_FSC			0x1734
+#endif
+
+#define MBOX_MAX_COMMANDS	126	// max command ids available to driver
+#define MBOX_MAX_DRIVER_CMDS	256	// number of cmds supported by driver
+#define MBOX_DEFAULT_SG_SIZE	26	// default sg size supported by all fw
+#define MBOX_MAX_SG_SIZE	32	// maximum scatter-gather list size
+#define MBOX_MAX_SECTORS	128
+#define MBOX_TIMEOUT		30	// timeout value for internal cmds
+#define MBOX_BUSY_WAIT		10	// max usec to wait for busy mailbox
+#define MBOX_ABORT_SLEEP	30	// wait this long in abort handler
+#define MBOX_RESET_SLEEP	30	// wait this long in reset handler
+
+#define CMDID_INT_CMDS		(MBOX_MAX_COMMANDS + 1)
+
+
+/**
+ * mbox_ccb_t - command control block specific to mailbox based controllers
+ * @raw_mbox		: raw mailbox pointer
+ * @mbox		: mailbox
+ * @mbox64		: extended mailbox
+ * @mbox_dma_h		: maibox dma address
+ * @sgl64		: 64-bit scatter-gather list
+ * @sgl32		: 32-bit scatter-gather list
+ * @sgl_dma_h		: dma handle for the scatter-gather list
+ * @pthru		: passthru structure
+ * @pthru_dma_h		: dma handle for the passthru structure
+ * @epthru		: extended passthru structure
+ * @epthru_dma_h	: dma handle for extended passthru structure
+ * @buf_dma_h		: dma handle for buffers w/o sg list
+ *
+ * command control block specific to the mailbox based controllers
+ */
+typedef struct {
+	uint8_t			*raw_mbox;
+	mbox_t			*mbox;
+	mbox64_t		*mbox64;
+	dma_addr_t		mbox_dma_h;
+	mbox_sgl64		*sgl64;
+	mbox_sgl32		*sgl32;
+	dma_addr_t		sgl_dma_h;
+	mraid_passthru_t	*pthru;
+	dma_addr_t		pthru_dma_h;
+	mraid_epassthru_t	*epthru;
+	dma_addr_t		epthru_dma_h;
+	dma_addr_t		buf_dma_h;
+} mbox_ccb_t;
+
+
+/**
+ * mraid_device_t - adapter soft state structure for mailbox controllers
+ * @param baseport		: base port of hba memory
+ * @param baseaddr		: mapped addr of hba memory
+ * @param una_mbox64		: 64-bit mbox - unaligned
+ * @param una_mbox64_dma	: mbox dma addr - unaligned
+ * @param mbox64		: 64-bit mbox - aligned
+ * @param mbox			: 32-bit mbox - aligned
+ * @param mbox_dma		: mbox dma addr - aligned
+ * @param ccb_list		: list of our command control blocks
+ * @param mbox_pool		: pool of mailboxes
+ * @param mbox_pool_handle	: handle for the mailbox pool memory
+ * @param sg_pool		: pool of scatter-gather lists for this driver
+ * @param sg_pool_handle	: handle to the pool above
+ * @param pthru_pool		: a pool for passthru commands
+ * @param pthru_pool_handle	: handle to the pool above
+ * @param epthru_pool		: a pool for extended passthru commands
+ * @param epthru_pool_handle	: handle to the pool above
+ * @param int_cmdid		: command id for internal commands
+ * @param pdrv_state		: array for state of each physical drive.
+ * @param flags			: mailbox hba specific flags
+ * @param cmdid			: available command ids
+ * @param scb			: associated scb
+ * @param cmdid_index		: top of stack of available command ids
+ * @param proc_read		: /proc configuration read
+ * @param proc_stat		: /proc information for statistics
+ * @param proc_mbox		: /proc information for current mailbox
+ * @param proc_rr		: /proc information for rebuild rate
+ * @param proc_battery		: /proc information for battery status
+ * @param proc_pdrvstat		: /proc information for physical drives state
+ * @param proc_rdrvstat		: /proc information for logical drives status
+ * @param last_disp		: flag used to show device scanning
+ * @param hw_error		: set if FW not responding
+ *
+ * Initialization structure for mailbox controllers: memory based and IO based
+ * All the fields in this structure are LLD specific and may be discovered at
+ * init() or start() time.
+ */
+typedef struct {
+	mbox64_t			*una_mbox64;
+	dma_addr_t			una_mbox64_dma;
+	mbox_t				*mbox;
+	mbox64_t			*mbox64;
+	dma_addr_t			mbox_dma;
+
+	unsigned long			baseport;
+	unsigned long			baseaddr;
+
+	struct mraid_pci_blk		mbox_pool[MBOX_MAX_DRIVER_CMDS];
+	struct mraid_pci_blk_pool	*mbox_pool_handle;
+	struct mraid_pci_blk		pthru_pool[MBOX_MAX_DRIVER_CMDS];
+	struct mraid_pci_blk_pool	*pthru_pool_handle;
+	struct mraid_pci_blk		epthru_pool[MBOX_MAX_DRIVER_CMDS];
+	struct mraid_pci_blk_pool	*epthru_pool_handle;
+	struct mraid_pci_blk		sg_pool[MBOX_MAX_DRIVER_CMDS];
+	struct mraid_pci_blk_pool	*sg_pool_handle;
+
+	mbox_ccb_t			ccb_list[MBOX_MAX_DRIVER_CMDS];
+
+	struct tasklet_struct		dpc_h;
+
+	uint8_t				int_cmdid;
+	uint8_t				pdrv_state[MBOX_MAX_PHYSICAL_DRIVES];
+	uint32_t			flags;
+
+	struct {
+		int			cmdid;
+		scb_t			*scb;
+	} cmdid_instance[MBOX_MAX_COMMANDS];
+	int				cmdid_index;
+#ifdef CONFIG_PROC_FS
+	struct proc_dir_entry		*proc_root;
+	struct proc_dir_entry		*proc_read;
+	struct proc_dir_entry		*proc_stat;
+	struct proc_dir_entry		*proc_rr;
+	struct proc_dir_entry		*proc_battery;
+#define MBOX_MAX_PROC_CHANNELS		4
+	struct proc_dir_entry		*proc_pdrvstat[MBOX_MAX_PROC_CHANNELS];
+	struct proc_dir_entry		*proc_rdrvstat[MBOX_MAX_PROC_CHANNELS];
+#endif
+	uint32_t			last_disp;
+	int				hw_error;
+} mraid_device_t;
+
+// route to raid device from adapter
+#define ADAP2RAIDDEV(adp)	((mraid_device_t *)((adp)->raid_device))
+
+
+/*
+ * This driver supports more commands than made available by the firmware.
+ * Following macros enable us to assign free command ids to the driver
+ * commands. Make sure try not to allocate commands ids for driver internal
+ * commands. These commands have fixed command ID.
+ */
+/*
+ * Get a free command id.
+ */
+#define INTERNAL_CMD_SIGNATURE	(-1)	// signature to differetiate cmds
+
+#define	MBOX_GET_CMDID(rdev, scb)					\
+if (scb->scp->cmnd[0] != MRAID_INTERNAL_COMMAND) {			\
+	if (rdev->cmdid_index == -1) {					\
+		scb->sno = -1;						\
+	}								\
+	else {								\
+		scb->sno =						\
+		rdev->cmdid_instance[rdev->cmdid_index].cmdid;		\
+		rdev->cmdid_instance[scb->sno].scb = scb;		\
+		rdev->cmdid_instance[rdev->cmdid_index].cmdid = -1;	\
+		rdev->cmdid_index--;					\
+	}								\
+}									\
+
+/*
+ * Get SCB corresponding to the command id
+ */
+#define MBOX_GET_CMDID_SCB(rdev, id)	 rdev->cmdid_instance[id].scb
+
+/*
+ * Free a command id
+ */
+#define MBOX_FREE_CMDID(rdev, id)					\
+		rdev->cmdid_instance[++rdev->cmdid_index].cmdid = id;	\
+		rdev->cmdid_instance[id].scb = NULL;			\
+
+/*
+ * Valid values for raid device flags
+ */
+#define MBOX_BOARD_8LD		0x00000001	// 8 LD controller
+#define MBOX_BOARD_40LD		0x00000002	// 40 LD controller
+#define MBOX_FLAGS_64BIT        0x00010000      // supports 64-bit addressing
+
+#define RDINDOOR(rdev)		readl((rdev)->baseaddr + 0x20)
+#define RDOUTDOOR(rdev)		readl((rdev)->baseaddr + 0x2C)
+#define WRINDOOR(rdev, value)	writel(value, (rdev)->baseaddr + 0x20)
+#define WROUTDOOR(rdev, value)	writel(value, (rdev)->baseaddr + 0x2C)
+
+/* Setup some port macros here for io mapped, mbox based controllers */
+#define iombox_issue_command(rdev)			\
+		outb_p(MBOX_ISSUE_BYTE, (rdev)->baseaddr + MBOX_CMD_PORT)
+
+#define iombox_irq_state(rdev)				\
+		inb_p((rdev)->baseaddr + MBOX_INTR_PORT)
+
+#define iombox_set_irq_state(rdev, value)		\
+		outb_p((value), (rdev)->baseaddr + MBOX_INTR_PORT)
+
+#define iombox_irq_ack(rdev)				\
+		outb_p(MBOX_ACK_BYTE, (rdev)->baseaddr + MBOX_ACK_PORT)
+
+#define iombox_irq_enable(rdev)				\
+	outb_p(MBOX_ENABLE_INTR_BYTE, (rdev)->baseaddr + MBOX_TOGGLE_PORT)
+
+#define iombox_irq_disable(rdev)			\
+	outb_p(MBOX_DISABLE_INTR_BYTE, (rdev)->baseaddr + MBOX_TOGGLE_PORT)
+
+
+#endif // _MEGARAID_H_
+
+/* vim: set ts=8 sw=8 tw=78: */
diff -urNp linux-2.6.5/drivers/scsi/megaraid_mm.c linux-2.6.5.SUSE/drivers/scsi/megaraid_mm.c
--- linux-2.6.5/drivers/scsi/megaraid_mm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/megaraid_mm.c	2004-04-27 18:45:56.000000000 +0200
@@ -0,0 +1,724 @@
+/*
+ *
+ *			Linux MegaRAID device driver
+ *
+ * Copyright (c) 2003-2004  LSI Logic Corporation.
+ *
+ *	   This program is free software; you can redistribute it and/or
+ *	   modify it under the terms of the GNU General Public License
+ *	   as published by the Free Software Foundation; either version
+ *	   2 of the License, or (at your option) any later version.
+ *
+ * FILE		: megaraid_mm.c
+ * Version	: v1.0.0.0.04.17.2004 (Apr 14 2004)
+ *
+ * Common management module
+ */
+
+#include "megaraid_mm.h"
+
+MODULE_AUTHOR		("LSI Logic Corporation");
+MODULE_DESCRIPTION	("LSI Logic Management Module");
+MODULE_LICENSE		("GPL");
+MODULE_PARM		(dbglevel, "i");
+MODULE_PARM_DESC	(dbglevel, "Debug level (default=0)");
+
+EXPORT_SYMBOL		( mraid_mm_register_adp );
+EXPORT_SYMBOL		( mraid_mm_unregister_adp );
+
+static int		majorno;
+static int		dbglevel	= CL_DLEVEL1;
+spinlock_t		lc_lock		= SPIN_LOCK_UNLOCKED;
+static uint32_t		drvr_ver	= 0x01000000;
+
+static int		slots_inuse	= 0;
+static mraid_mmadp_t 	adparr[MAX_LSI_CMN_ADAPS];
+
+wait_queue_head_t	wait_q;
+
+static struct file_operations lsi_fops = {
+
+	.ioctl		= megaraid_mm_ioctl,
+	.open		= megaraid_mm_open,
+	.release	= megaraid_mm_close,
+	.owner		= THIS_MODULE,
+};
+
+static int
+megaraid_mm_ioctl( struct inode* inode, struct file* filep, unsigned int cmd,
+							unsigned long arg )
+{
+	uioc_t*		kioc;
+	char		signature[EXT_IOCTL_SIGN_SZ]	= {0};
+	int		rval;
+	mraid_mmadp_t*	adp;
+	int		adp_index;
+	uint8_t		old_ioctl;
+	int		drvrcmd_rval;
+
+	/*
+	 * Make sure only USCSICMD are issued through this interface.
+	 * MIMD application would still fire different command.
+	 */
+
+	if( (_IOC_TYPE(cmd) != MEGAIOC_MAGIC) && (cmd != USCSICMD) ) {
+		return -EINVAL;
+	}
+
+	/* 
+	 * Look for signature to see if this is the new or old ioctl format. 
+	 */
+	if( copy_from_user(signature, (char *)arg, EXT_IOCTL_SIGN_SZ) ) {
+		con_log(CL_ANN,(KERN_WARNING "cp from usr addr failed\n"));
+		return (-EFAULT);
+	}	
+
+	if( memcmp(signature, EXT_IOCTL_SIGN, EXT_IOCTL_SIGN_SZ) == 0 ) 
+		old_ioctl = MRAID_FALSE;
+	else
+		old_ioctl = MRAID_TRUE;
+
+	/*
+	 * If it is a driver ioctl (as opposed to fw ioctls), then we can
+	 * handle the command locally. rval > 0 means it is not a drvr cmd
+	 */
+	rval = handle_drvrcmd( arg, old_ioctl, &drvrcmd_rval );
+
+	if (rval < 0)	
+		return rval;
+	else if (rval == 0)
+		return drvrcmd_rval;
+
+	/* 
+	 * Call the approprite converter to convert to kernel space
+	 */
+	if (old_ioctl == MRAID_FALSE) {
+		/* 
+		 * User sent the new uioc_t packet. We don't support it yet.
+		 */
+		return (-EINVAL);
+	}
+	else {
+		/* 
+		 * User sent the old mimd_t ioctl packet. Convert it to
+		 * uioc. If there is an error, the mutexes and other resources
+		 * would have been released already. So we can just return.
+		 */
+		if ((rval = mimd_to_kioc((mimd_t*)arg, &adp_index))) {
+			return rval;
+		}
+	}
+
+	adp		= &adparr[adp_index];
+	kioc		= &adp->kioc;
+	kioc->done	= ioctl_done;
+
+	/* 
+	 * Issue the IOCTL to the low level driver
+	 */
+	if ((rval = lld_ioctl( adp, kioc ))) {
+		up( &adp->kioc_mtx );
+		return rval;
+	}
+
+	/* 
+	 * Convert the kioc back to user space 
+	 */
+	rval = kioc_to_mimd( kioc, (mimd_t*) arg );
+	up( &adp->kioc_mtx );
+
+	return rval;
+}
+
+/*
+ * handle_drvrcmd()	: This routine checks if the opcode is a driver
+ * 			  cmd and if it is, handles it.
+ *
+ * @arg			: packet sent by the user app
+ * @old_ioctl		: mimd if MRAID_TRUE; uioc otherwise
+ */
+static int
+handle_drvrcmd( ulong arg, uint8_t old_ioctl, int* rval )
+{
+	mimd_t*		umimd;
+	mimd_t		kmimd;
+	uint8_t		opcode;
+	uint8_t		subopcode;
+
+	if (old_ioctl == MRAID_TRUE)
+		goto old_packet;
+	else
+		goto new_packet;
+
+new_packet:
+	return (-ENOTSUPP);
+
+old_packet:
+	*rval = 0;
+	umimd = (mimd_t*) arg;
+
+	if (copy_from_user( &kmimd, umimd, sizeof(mimd_t)))
+		return (-EFAULT);
+
+	opcode		= kmimd.ui.fcs.opcode;
+	subopcode	= kmimd.ui.fcs.subopcode;
+
+	/*
+	 * If the opcode is 0x82 and the subopcode is either GET_DRVRVER or
+	 * GET_NUMADP, then we can handle. Otherwise we should return 1 to
+	 * indicate that we cannot handle this.
+	 */
+	if (opcode != 0x82)
+		return 1;
+
+	switch( subopcode ) {
+
+	case MEGAIOC_QDRVRVER:
+
+		if (copy_to_user(kmimd.data, &drvr_ver, sizeof(uint32_t)))
+			return (-EFAULT);
+
+		return 0;
+
+	case MEGAIOC_QNADAP:
+
+		*rval = slots_inuse;
+
+		if(copy_to_user(kmimd.data, &slots_inuse, sizeof(uint32_t)))
+			return (-EFAULT);
+
+		return 0;
+
+	default:
+		/* cannot handle */
+		return 1;
+	}
+
+	return 0;
+}
+
+/**
+ * mimd_to_kioc	: Converter from old to new ioctl format
+ * 
+ * @umimd	: user space old MIMD IOCTL
+ * @kioc	: kernel space new format IOCTL
+ *
+ * Routine to convert MIMD interface IOCTL to new interface IOCTL packet. The
+ * new packet is in kernel space so that driver can perform operations on it
+ * freely.
+ */
+
+static int
+mimd_to_kioc( mimd_t* umimd, int* adp_index )
+{
+	uint64_t		temp;
+	uint32_t		adapno;
+	uint8_t			opcode;
+	uint8_t			subopcode;
+	uint32_t		bufsz = 0;
+	mimd_t			mimd;
+
+	mraid_mmadp_t*		adp;
+	mbox64_t*		mbox64;
+	mraid_passthru_t*	pthru32;
+	uioc_t*			kioc;
+
+	if( copy_from_user( &mimd, umimd, sizeof(mimd_t)) )
+		return (-EFAULT);
+
+	/*
+	 * Applications are not allowed to send extd pthru
+	 */
+	if( mimd.mbox[0] == 0xC3 )
+		return (-EINVAL);
+
+	opcode		= mimd.ui.fcs.opcode;
+	subopcode	= mimd.ui.fcs.subopcode;
+	adapno		= GETADAP(mimd.ui.fcs.adapno);
+
+	if( adapno >= slots_inuse ) 
+		return (-ENODEV);
+
+	adp = &adparr[ adapno ];
+
+	down( &adp->kioc_mtx );
+
+	kioc		= &adp->kioc;
+	kioc->adapno	= adapno;
+	*adp_index	= adapno;
+
+	kioc->mb_type	= MBOX_LEGACY;
+	kioc->app_type	= APPTYPE_MIMD;
+
+	switch( opcode ) {
+
+	case 0x82:
+
+		if (subopcode == MEGAIOC_QADAPINFO) {
+
+			kioc->opcode	= GET_ADAP_INFO;
+			kioc->data_dir	= UIOC_RD;
+			kioc->xferlen	= sizeof(mraid_hba_info_t);
+			kioc->cmdbuf	= (ulong)adp->memblk;
+			bufsz		= kioc->xferlen;
+		}
+		else {
+			con_log( CL_ANN, ("Invalid subop\n"));
+
+			up( &adp->kioc_mtx );
+			return (-EINVAL);
+		}
+
+		break;
+
+	case 0x81:
+
+		kioc->opcode	= MBOX_CMD;
+		kioc->xferlen	= mimd.ui.fcs.length;
+		bufsz		= sizeof(mbox64_t);
+		kioc->cmdbuf	= (ulong)adp->memblk;
+
+		if( mimd.outlen ) kioc->data_dir  = UIOC_RD;
+		if( mimd.inlen  ) kioc->data_dir |= UIOC_WR;
+
+		break;
+
+	case 0x80:
+
+		bufsz		= sizeof(mbox64_t);
+		kioc->opcode	= MBOX_CMD;
+		kioc->xferlen	= (mimd.outlen > mimd.inlen) ?
+					mimd.outlen : mimd.inlen;
+		kioc->cmdbuf	= (ulong)adp->memblk;
+
+		if( mimd.outlen ) kioc->data_dir  = UIOC_RD;
+		if( mimd.inlen  ) kioc->data_dir |= UIOC_WR;
+
+		break;
+
+	default:
+		up( &adp->kioc_mtx );
+		return (-EINVAL);
+	}
+
+	memset( (void*)((ulong)kioc->cmdbuf), 0, bufsz );
+	
+	/*
+	 * If driver command, nothing else to do
+	 */
+	if( opcode == 0x82 ) 
+		return 0;
+
+	/*
+	 * This is a mailbox cmd; copy the mailbox from mimd 
+	 */
+	mbox64 = (mbox64_t*) ((ulong)kioc->cmdbuf);
+	memcpy( &(mbox64->mbox32), mimd.mbox, 18 );
+	
+	mbox64->xferaddr_lo	= mbox64->mbox32.xferaddr;
+	mbox64->xferaddr_hi	= 0;
+	mbox64->mbox32.xferaddr	= 0xffffffff;
+
+	if( mbox64->mbox32.cmd != 0x03 ) {	/* Not pthru; regular DCMD */
+
+		/*
+		 * We had allocated 28K for memblk. adp->kioc.cmdbuf is 
+		 * is pointing to the beginning for that memory block. Since
+		 * this is a mailbox command, the beginning of the block is
+		 * treated as a mailbox. Now we need the data. We will leave
+		 * the first 1k for mailbox and have int_data point to the 
+		 * memblk + 1024
+		 */
+		adp->int_data		= adp->memblk + 1024;
+		adp->int_data_dmah	= (ulong)adp->memblk_dmah + 1024;
+
+		temp			= mbox64->xferaddr_lo;
+		mbox64->xferaddr_lo	= adp->int_data_dmah;
+		adp->int_data_len	= kioc->xferlen;
+		adp->int_data_user	= (caddr_t)(ulong)temp;
+		
+		if( kioc->data_dir & UIOC_WR ) {
+			if(copy_from_user(adp->int_data, 
+					(void*)(ulong)temp, kioc->xferlen)){
+				up( &adp->kioc_mtx );
+				return (-EFAULT);
+			}
+		}
+
+		return 0;
+	}
+
+	/* 
+	 * This is a regular 32-bit pthru cmd; mbox points to pthru struct.
+	 * Just like in above case, the beginning for memblk is treated as
+	 * a mailbox. The passthru will begin at next 1K boundary. And the
+	 * data will start 1K after that.
+	 */
+	mbox64->mbox32.cmd = 0x03;
+
+	adp->int_pthru		= adp->memblk + 1024;
+	adp->int_pthru_dmah	= adp->memblk_dmah + 1024;
+
+	temp			= mbox64->xferaddr_lo;
+	pthru32			= (mraid_passthru_t*)adp->int_pthru;
+	mbox64->xferaddr_lo	= adp->int_pthru_dmah;
+	adp->int_pthru_len	= sizeof(mraid_passthru_t);
+	adp->int_pthru_user	= (caddr_t)(ulong)temp;
+
+	if( copy_from_user( pthru32, (void*)(ulong)temp, 
+					sizeof(mraid_passthru_t)) ) {
+		up( &adp->kioc_mtx );
+		return (-EFAULT);
+	}
+
+	adp->int_data			= adp->memblk + 2048;
+	adp->int_data_dmah		= adp->memblk_dmah + 2048;
+
+	temp				= pthru32->dataxferaddr;
+	pthru32->dataxferaddr		= adp->int_data_dmah;
+	adp->int_data_len		= pthru32->dataxferlen;
+	adp->int_data_user		= (caddr_t)(ulong)temp;
+
+	if( copy_from_user(adp->int_data, (void*)(ulong)temp,
+					adp->int_data_len) ) {
+		up( &adp->kioc_mtx );
+		return (-EFAULT);
+	}
+
+	return 0;
+}
+
+/**
+ * lld_ioctl	: Routine to issue ioctl to low level drvr
+ *
+ * @adp		: The adapter entry in adparr
+ * @kioc	: The ioctl packet with kernel addresses
+ */
+static int
+lld_ioctl( mraid_mmadp_t* adp, uioc_t* kioc )
+{
+	int			rval;
+	struct timer_list	timer;
+	struct timer_list*	tp = NULL;
+
+	if (!adp || !kioc)
+		return (-EINVAL);
+
+	kioc->status	= LC_PENDING;
+	rval		= adp->issue_uioc( adp->drvr_data, kioc, IOCTL_ISSUE); 
+
+	if( rval )
+		return rval;
+
+	/*
+	 * Start the timer
+	 */
+	if (adp->timeout > 0) {
+		tp		= &timer;
+		init_timer(tp);
+
+		tp->function	= lld_timedout;
+		tp->data	= (ulong) kioc;
+		tp->expires	= jiffies + adp->timeout * HZ;
+
+		add_timer(tp);
+	}
+
+	/*
+	 * Wait till the low level driver completes the ioctl. After this
+	 * call, the ioctl either completed successfully or timedout.
+	 */
+	wait_event( wait_q, (kioc->status != LC_PENDING) );
+	del_timer_sync( tp );
+
+	return 0;
+}
+
+/*
+ * ioctl_done	: callback from the low level driver
+ *
+ * @kioc	: completed ioctl packet
+ */
+void
+ioctl_done( uioc_t* kioc )
+{
+	/*
+	 * When the kioc returns from driver, make sure it still doesn't
+	 * have LC_PENDING in status. Otherwise, driver will hang on
+	 * wait_event forever
+	 */
+	if( kioc->status == LC_PENDING ){
+		con_log( CL_ANN, ("lld didn't change status!!\n"));
+		kioc->status = LC_UNKNOWN;
+	}
+
+	wake_up( &wait_q );
+}
+
+/*
+ * lld_timedout	: callback from the expired timer
+ *
+ * @ptr		: ioctl packet that timed out
+ */
+void
+lld_timedout( ulong ptr )
+{
+	uioc_t* kioc	= (uioc_t*)ptr;
+	kioc->status 	= LC_ETIME;
+
+	wake_up( &wait_q );
+}
+
+/**
+ * kioc_to_mimd	: Converter from new back to old format
+ *
+ * @kioc	: Kernel space IOCTL packet (successfully issued)
+ * @mimd	: User space MIMD packet
+ */
+static int
+kioc_to_mimd( uioc_t* kioc, mimd_t* mimd )
+{
+	mimd_t			kmimd;
+	uint8_t			opcode;
+	uint8_t			subopcode;
+
+	mbox64_t*		mbox64;
+	mraid_passthru_t*	upthru32;
+	mraid_passthru_t*	kpthru32;
+	mcontroller_t		cinfo;
+	mraid_hba_info_t*	hinfo;
+
+	mraid_mmadp_t*		adp = &adparr[ kioc->adapno ];
+
+	if (kioc->status != LC_SUCCESS)
+		return (-EFAULT);
+
+	if (copy_from_user( &kmimd, mimd, sizeof(mimd_t)))
+		return (-EFAULT);
+
+	opcode		= kmimd.ui.fcs.opcode;
+	subopcode	= kmimd.ui.fcs.subopcode;
+
+	if( opcode == 0x82 ) {
+		switch( subopcode ) {
+
+		case MEGAIOC_QADAPINFO:
+
+			hinfo = (mraid_hba_info_t*)(ulong)kioc->cmdbuf;
+			hinfo_to_cinfo( hinfo, &cinfo );
+
+			if (copy_to_user(kmimd.data, &cinfo, sizeof(cinfo)))
+				return (-EFAULT);
+
+			return 0;
+
+		default:
+			return (-EINVAL);
+		}
+
+		return 0;
+	}
+
+	mbox64 = (mbox64_t*) (ulong)kioc->cmdbuf;
+
+	if( adp->int_pthru_len ) {
+
+		upthru32 = (mraid_passthru_t*)adp->int_pthru_user;
+		kpthru32 = (mraid_passthru_t*)adp->int_pthru;
+
+		if( copy_to_user( (void*) &(upthru32->scsistatus),
+					(void*)&(kpthru32->scsistatus),
+					sizeof( uint8_t )) ) {
+			return (-EFAULT);
+		}
+	}
+
+	if( adp->int_data_len ) {
+		if( copy_to_user(adp->int_data_user, adp->int_data,
+					adp->int_data_len ) ) {
+			return (-EFAULT);
+		}
+	}
+
+	if (copy_to_user((void*)&mimd->mbox[17], (void*)&mbox64->mbox32.status,
+				sizeof(uint8_t))) {
+		return (-EFAULT);
+	}
+
+	adp->int_data		= NULL;
+	adp->int_data_len	= 0;
+	adp->int_data_dmah	= 0;
+	adp->int_data_user	= NULL;
+	adp->int_pthru		= NULL;
+	adp->int_pthru_len	= 0;
+	adp->int_pthru_dmah	= 0;
+	adp->int_pthru_user	= NULL;
+
+	return 0;
+}
+
+static void
+hinfo_to_cinfo( mraid_hba_info_t* hinfo, mcontroller_t* cinfo )
+{
+	if( !hinfo || !cinfo )
+		return;
+
+	cinfo->base		= hinfo->baseport;
+	cinfo->irq		= hinfo->irq;
+	cinfo->numldrv		= hinfo->num_ldrv;
+	cinfo->pcibus		= hinfo->pci_bus;
+	cinfo->pcidev		= hinfo->pci_slot; 
+	cinfo->pcifun		= PCI_FUNC(hinfo->pci_dev_fn);
+	cinfo->pciid		= hinfo->pci_device_id;
+	cinfo->pcivendor	= hinfo->pci_vendor_id;
+	cinfo->pcislot		= hinfo->pci_slot;
+	cinfo->uid		= hinfo->unique_id;
+}
+
+/*
+ * mraid_mm_register_adp	: Registration routine for low level drvrs
+ *
+ * @adp				: Adapter objejct
+ */
+uint32_t
+mraid_mm_register_adp( mraid_mmadp_t* adp )
+{
+	int	i;
+	int	cur_slot;
+
+	caddr_t		memblk;
+	dma_addr_t	memblk_dmah;
+
+	if (!adp) 
+		return LC_EINVAL;
+
+	if (adp->drvr_type != DRVRTYPE_MBOX)
+		return LC_ENOTSUPP;
+
+	memblk = pci_alloc_consistent(adp->pdev, MEMBLK_SZ, &memblk_dmah);
+
+	if( !memblk )
+		return LC_ENOMEM;
+
+	spin_lock( &lc_lock );
+
+	if (slots_inuse >= MAX_LSI_CMN_ADAPS ) {
+		spin_unlock( &lc_lock );
+		return LC_EFULL;
+	}
+
+	cur_slot = slots_inuse++;
+	spin_unlock( &lc_lock );
+
+	/* 
+	 * Return error if it is a duplicate unique_id 
+	 */
+	for (i=0; i < MAX_LSI_CMN_ADAPS; i++ ) {
+		if (adparr[i].unique_id == adp->unique_id) {
+			return LC_EEXISTS;
+		}
+	}
+
+	adparr[cur_slot].unique_id	= adp->unique_id;
+	adparr[cur_slot].drvr_type	= adp->drvr_type;
+	adparr[cur_slot].drvr_data	= adp->drvr_data;
+	adparr[cur_slot].pdev		= adp->pdev;
+	adparr[cur_slot].issue_uioc	= adp->issue_uioc;
+	adparr[cur_slot].timeout	= adp->timeout;
+	adparr[cur_slot].memblk		= memblk;
+	adparr[cur_slot].memblk_dmah	= memblk_dmah;
+
+	init_MUTEX( &adparr[cur_slot].kioc_mtx );
+
+	return 0;
+}
+
+/*
+ * mraid_mm_unregister_adp	: Unregister routine for low level drivers
+ *
+ * @unique_id			: UID of the adpater
+ */
+uint32_t
+mraid_mm_unregister_adp( uint32_t unique_id )
+{
+	int i;
+
+	spin_lock( &lc_lock );
+
+	for (i = 0; i < MAX_LSI_CMN_ADAPS; i++ ) {
+		if (adparr[i].unique_id == unique_id) {
+
+			pci_free_consistent( adparr[i].pdev, MEMBLK_SZ,
+				adparr[i].memblk, adparr[i].memblk_dmah );
+		
+			memset( &adparr[i], 0, sizeof(mraid_mmadp_t) );
+			spin_unlock( &lc_lock );
+
+			con_log( CL_ANN, ("Unregistered one lsi adp\n"));
+			return 0;
+		}
+	}
+
+	spin_unlock( &lc_lock );
+	return LC_ENOADP;
+}
+
+static int
+megaraid_mm_open( struct inode *inode, struct file *filep )
+{
+	return 0;
+}
+
+static int
+megaraid_mm_close( struct inode *inode, struct file *filep )
+{
+	return 0;
+}
+
+static int __init
+megaraid_mm_init(void)
+{
+	// Announce the driver version
+	con_log(CL_ANN, (KERN_INFO "megaraid_mm: %s\n", 
+					LSI_COMMON_MOD_VERSION));
+
+	majorno = register_chrdev( 0, "megadev", &lsi_fops );
+
+	if (majorno < 0) {
+		con_log( CL_ANN, ("lsi_cmnmod: cannot get major\n"));
+		return majorno;
+	}
+	init_waitqueue_head( &wait_q );
+	memset( adparr, 0, sizeof(mraid_mmadp_t) * MAX_LSI_CMN_ADAPS );
+
+	slots_inuse = 0;
+
+	register_ioctl32_conversion( MEGAIOCCMD, megaraid_mm_compat_ioctl );
+	
+	return 0; 
+}
+
+#ifdef LSI_CONFIG_COMPAT
+static int
+megaraid_mm_compat_ioctl( unsigned int fd, unsigned int cmd,
+			ulong arg, struct file* filep )
+{
+	struct inode *inode = filep->f_dentry->d_inode;
+
+	return megaraid_mm_ioctl(inode, filep, cmd, arg);
+}
+#endif
+
+static void __exit
+megaraid_mm_exit(void)
+{
+	con_log( CL_ANN, ("exiting common mod \n" ));
+
+	unregister_chrdev( majorno, "megadev" );
+	unregister_ioctl32_conversion( MEGAIOCCMD );
+}
+
+module_init( megaraid_mm_init);
+module_exit( megaraid_mm_exit);
+
+/* vi: set ts=8 sw=8 tw=78: */
diff -urNp linux-2.6.5/drivers/scsi/megaraid_mm.h linux-2.6.5.SUSE/drivers/scsi/megaraid_mm.h
--- linux-2.6.5/drivers/scsi/megaraid_mm.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/megaraid_mm.h	2004-04-27 18:45:56.000000000 +0200
@@ -0,0 +1,143 @@
+/*
+ *
+ *			Linux MegaRAID device driver
+ *
+ * Copyright (c) 2003-2004  LSI Logic Corporation.
+ *
+ *	   This program is free software; you can redistribute it and/or
+ *	   modify it under the terms of the GNU General Public License
+ *	   as published by the Free Software Foundation; either version
+ *	   2 of the License, or (at your option) any later version.
+ *
+ * FILE		: megaraid_mm.h
+ * Version	: v2.20.0 (Apr 14 2004)
+ */
+
+#ifndef MEGARAID_MM_H
+#define MEGARAID_MM_H
+
+#include <linux/spinlock.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <linux/delay.h>
+#include <linux/version.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <linux/pci.h>
+#include <linux/list.h>
+#include <linux/reboot.h>
+
+#include "mbox_defs.h"
+
+#define LSI_COMMON_MOD_VERSION	\
+	"v1.0.0.B1.04.07.2004 (Release Date: Wed Apr  7 17:20:39 EDT 2004)"
+
+#define LSI_DBGLVL	dbglevel
+/*
+ * Sz of mem allocated for each internal ioctl packet
+ */
+#define MEMBLK_SZ	(28*1024)
+
+/*
+ * Localizing ioctl32 differences
+ */
+
+#if defined (CONFIG_COMPAT) || defined(__x86_64__) || defined(IA32_EMULATION)
+#define LSI_CONFIG_COMPAT
+#endif
+
+#ifdef LSI_CONFIG_COMPAT
+#include <asm/ioctl32.h>
+#else
+#define register_ioctl32_conversion(a,b)	do{}while(0)
+#define unregister_ioctl32_conversion(a)	do{}while(0)
+#endif /* LSI_CONFIG_COMPAT */
+
+/**
+ * mimd_t	: Old style ioctl packet structure (depracated)
+ *
+ * @inlen	:
+ * @outlen	:
+ * @fca		:
+ * @opcode	:
+ * @subopcode	:
+ * @adapno	:
+ * @buffer	:
+ * @pad		:
+ * @length	:
+ * @mbox	:
+ * @pthru	:
+ * @data	:
+ * @pad		:
+ *
+ * Note		: This structure is DEPRACATED. New applications must use
+ *		: uioc_t structure instead. All new hba drivers use the new
+ *		: format. If we get this mimd packet, we will convert it into
+ *		: new uioc_t format and send it to the hba drivers.
+ */
+
+typedef struct mimd {
+
+	uint32_t inlen;
+	uint32_t outlen;
+
+	union {
+		uint8_t fca[16];
+		struct {
+			uint8_t opcode;
+			uint8_t subopcode;
+			uint16_t adapno;
+#if BITS_PER_LONG == 32
+			uint8_t *buffer;
+			uint8_t pad[4];
+#endif
+#if BITS_PER_LONG == 64
+			uint8_t *buffer;
+#endif
+			uint32_t length;
+		} __attribute__ ((packed)) fcs;
+	} __attribute__ ((packed)) ui;
+
+	uint8_t mbox[18];		/* 16 bytes + 2 status bytes */
+	mraid_passthru_t pthru;
+
+#if BITS_PER_LONG == 32
+	char *data;		/* buffer <= 4096 for 0x80 commands */
+	char pad[4];
+#endif
+#if BITS_PER_LONG == 64
+	char *data;
+#endif
+
+} __attribute__ ((packed))mimd_t;
+
+/*
+ * Entry points for char node driver
+ */
+static int	megaraid_mm_open ( struct inode*, struct file* );
+static int	megaraid_mm_close( struct inode*, struct file* );
+static int	megaraid_mm_ioctl( struct inode*, struct file*, uint, ulong );
+
+/*
+ * routines to convert to and from the old the format
+ */
+static int	mimd_to_kioc( mimd_t*, int* );
+static int	kioc_to_mimd( uioc_t*, mimd_t* );
+
+/*
+ * Helper functions
+ */
+static int	handle_drvrcmd( ulong, uint8_t, int* );
+static int	lld_ioctl( mraid_mmadp_t*, uioc_t* );
+void		ioctl_done( uioc_t* );
+void		lld_timedout( ulong );
+static void	hinfo_to_cinfo( mraid_hba_info_t*, mcontroller_t*);
+
+#ifdef LSI_CONFIG_COMPAT
+static int	megaraid_mm_compat_ioctl( unsigned int, unsigned int,
+						ulong, struct file* );
+#endif
+
+#endif /*MEGARAID_MM_H*/
+

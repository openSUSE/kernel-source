From: Jiri Benc <jbenc@suse.cz>
Subject: Enable ixgbe as entropy source (disabled by default)
References: FATE#307517
Patch-mainline: never

Current disk-less systems have no entropy source whatsoever. Therefore, the
network drivers tg3, bnx2, e1000, e1000e, igb and ixgbe should be enabled to
feed entropy to the kernel via the IRQF_SAMPLE_RANDOM flag when loaded. This
option shall not be enabled by default but implemented via a module option to
be activated by the administrator.

Signed-off-by: Brandon Philips <bphilips@suse.de>

---
 drivers/net/ixgbe/ixgbe_main.c |   22 +++++++++++++++++++---
 1 file changed, 19 insertions(+), 3 deletions(-)

--- a/drivers/net/ixgbe/ixgbe_main.c
+++ b/drivers/net/ixgbe/ixgbe_main.c
@@ -56,6 +56,11 @@ static const char ixgbe_driver_string[]
 static const char ixgbe_copyright[] =
				"Copyright (c) 1999-2011 Intel Corporation.";
 
+static int entropy = 0;
+module_param(entropy, int, 0);
+MODULE_PARM_DESC(entropy, "Allow ixgbe to populate the /dev/random entropy pool");
+
+
 static const struct ixgbe_info *ixgbe_info_tbl[] = {
 	[board_82598] = &ixgbe_82598_info,
 	[board_82599] = &ixgbe_82599_info,
@@ -2317,6 +2322,7 @@ static int ixgbe_request_msix_irqs(struc
 	irqreturn_t (*handler)(int, void *);
 	int i, vector, q_vectors, err;
 	int ri = 0, ti = 0;
+	int irq_flags;
 
 	/* Decrement for Other and TCP Timer vectors */
 	q_vectors = adapter->num_msix_vectors - NON_Q_VECTORS;
@@ -2334,22 +2340,27 @@ static int ixgbe_request_msix_irqs(struc
 		struct ixgbe_q_vector *q_vector = adapter->q_vector[vector];
 		handler = SET_HANDLER(q_vector);
 
+		irq_flags = 0;
 		if (handler == &ixgbe_msix_clean_rx) {
 			snprintf(q_vector->name, sizeof(q_vector->name) - 1,
 			         "%s-%s-%d", netdev->name, "rx", ri++);
+			if (entropy)
+				irq_flags = IRQF_SAMPLE_RANDOM;
 		} else if (handler == &ixgbe_msix_clean_tx) {
 			snprintf(q_vector->name, sizeof(q_vector->name) - 1,
 			         "%s-%s-%d", netdev->name, "tx", ti++);
 		} else if (handler == &ixgbe_msix_clean_many) {
 			snprintf(q_vector->name, sizeof(q_vector->name) - 1,
 			         "%s-%s-%d", netdev->name, "TxRx", ri++);
+			if (entropy)
+				irq_flags = IRQF_SAMPLE_RANDOM;
 			ti++;
 		} else {
 			/* skip this unused q_vector */
 			continue;
 		}
 		err = request_irq(adapter->msix_entries[vector].vector,
-				  handler, 0, q_vector->name,
+				  handler, irq_flags, q_vector->name,
 				  q_vector);
 		if (err) {
 			e_err(probe, "request_irq failed for MSIX interrupt "
@@ -2563,14 +2574,19 @@ static int ixgbe_request_irq(struct ixgb
 {
 	struct net_device *netdev = adapter->netdev;
 	int err;
+	int irq_flags = 0;
+
+	if (entropy)
+		irq_flags = IRQF_SAMPLE_RANDOM;
 
 	if (adapter->flags & IXGBE_FLAG_MSIX_ENABLED) {
 		err = ixgbe_request_msix_irqs(adapter);
 	} else if (adapter->flags & IXGBE_FLAG_MSI_ENABLED) {
-		err = request_irq(adapter->pdev->irq, ixgbe_intr, 0,
+		err = request_irq(adapter->pdev->irq, ixgbe_intr, irq_flags,
 				  netdev->name, netdev);
 	} else {
-		err = request_irq(adapter->pdev->irq, ixgbe_intr, IRQF_SHARED,
+		irq_flags |= IRQF_SHARED;
+		err = request_irq(adapter->pdev->irq, ixgbe_intr, irq_flags,
 				  netdev->name, netdev);
 	}
 

From: Laurie Barry <laurie.barry@emulex.com>
Subject: lpfc driver update to 8.3.5.3
References: bnc#572427
Patch-Mainline: Submitted to scsi-misc

This patch updates the Emulex lpfc driver to 8.3.5.3.

These are the changes included in this patch (8.3.5 --> 8.3.5.3):

 * Changed version number to 8.3.5.1
 * Fixed: lpfc_unreg_vfi failure after devloss timeout. Fixed RPI bit
   leak (CR 94542)
 * Fix crash due to list corruption while unloading driver (CR
   94889)
 * Fix Zeroed frame on wire after FLOGI (CR 94950)
 * Fix Vport does not rediscover after FCF goes away
 * Fixed the call from lpfc_new_scsi_buf_s3 to use
  lpfc_release_scsi_buf_s3
 * Fix memory leak found in lpfc_sli4_read_rev
 * Fixed total_scsi_bufs counting
 * Fix CVL received on Port 1 not processed by driver
 * Fixed locking issue
 * Added PCI ID for LPSe12002-ML1-E EmulexSecure Fibre Channel Adapter
 * Add DHCHAP support
 * Stop and abort all I/Os on HBA for AER uncorrectable non-fatal
   error handling
 * Made AER sysfs entry point return "Operation not permitted" to
   OneConnect HBAs
 * Removed the use of the locally defined FC transport layer related
   macros
 * SLI4_FIXED: Fixed Check for aborted els command
 * Fix bug with missing new line characters in log messages (CR
   94092)
 * Fix bug with probe_one routines not putting the Scsi_Host back
   upon error (CR 94088)
 * Fixed discovery failure during quick link bounce
 * Add support for Clear Virtual Link
 * Handling unsolicited CT exchange sequence abort (lower level
   driver part)
 * Fix switch name not used in the FCF record for FCoE HBAs
 * SLI4: Enabled SLI4 HBA UE error polling error-condition action
   code
 * Fix Vports unable to be created on Port2 Tigershark HBA (CR
   90670)
 * Implemented persistent port disable functionality
 * Rewrite lpfc_sli4_scmd_to_wqidx_distr() to handle counter
   rollover cleanly
 * Added new state in link_state sysfs attribute for persistent link
   down
 * Fix for firmware dump failure (CR 90533)
 * Use PCI config space register to determine SLI rev of the HBA
 * Fixed mailbox timeout during HBA reset
 * Modified resume_rpi mailbox data structure according to new spec
 * Remove always true conditional in lpfc_sli_read_serdes_param()
 * SLI4: Do not issue mailbox command when LPFC_HBA_ERROR with
   MBX_POLL mode
 * Fix accumulated total length not being filled in on SLI4
   unsolicited IOCBs
 * Fixed SLI3 inband remote mamagement (CR 91042)
 * Fix FCoE Paramers in region 23 not being read correctly
 * Wait for HBA POST completion before checking Online and UE
   registers (SLI4)
 * Fixed static vport creation on SLI4 HBAs
 * Fixed vport create not to send init_vpi before REG_VFI
 * Remove cast when using pci_read_config_dword() to access
   LPFC_SLIREV_CONF_WORD
 * Fix use of first_iocbq pointer before checking for NULL

 * Changed version number to 8.3.5.2
 * Fix Dead FCF not triggering discovery of other FCF (CR 97048, 97049)
 * Fix vport->fc_flag set outside of lock caused I/O failure during pci-func 
   reset (CR 96975)
 * Fix driver tries to process failed read FCF record
 * Fixed hbq buff adds to receive queue
 * Fixed hbq buff only for sli4
 * Fix multi-frame sequence response frames go to wrong DID (CR 96915)
 * Fixed fc header seq_count checks (CR 97010)
 * Fixed adapter reset and offline/online stress test failing with I/O errors 
   (CR 92904)
 * Fix vport fails to register VPI after devloss timeout (CR 96740)
 * Blocked all SCSI I/O requests from midlayer until target rediscovery during 
   EEH (CR 95889)
 * Fix PCI device vendor for EmulexSecure HBA
 * Fixed in-band remote firmware download (CR 96090)
 * Made OneCommand CNA set up and use single FCP EQ only under INTx interrupt 
   mode (CR 96645)
 * Fix vport not logging out when being deleted (CR 96339)
 * Add new READ_FCF_RECORD failure code
 * Remove temporary OneConnect CNA PCI Device IDs
 * Fixed panic when unmapping luns (CR 94833)
 * Added handling of ELS request for Reinstate Recovery Qualifier (RRQ)
 * Remove use of ONLINE registers to correspond to firmware changes
 * Made ABTS WQE go to the same WQ as the WQE to be aborted (CR 96110)
 * Fixed Dead FCoE port after creating vports (CR 95449)
 * Fix crash driver when fcauthd is started (CR 95584)
 * Fix hbq pointer corruption (CR 95313)
 * Fixed panic during pci-hot-plug testing (CR 95246)
 * Fix reg_vfi and reg_vpi routines to use little endian wwn
 * Change default TC BE3 driver identification string to include model number
 * Migrate LUN queue depth ramp up code to scsi mid-layer
 * Fix for lost MSI interrupt (CR 95404)
 * Fix vport keep-alive does not contain the correct WWN
 * Fix reporting of max_vpi to uppper layer
 * Added PCI read after EQarm doorbell PCI write in INTx mode to flush PCI 
   pipeline
 * Fix driver unable to discover targets after FCF DEAD

 * Changed version number to 8.3.5.3
 * Merge change from upstream scsi-misc-2.6 git tree to move blocking
   scsi_eh code from FC LLDs to SCSI FC transport class.
 * Clean up ELS commands when unregistering unused ELS commands (CR
   97048)
 * Fix an issue in SLI4 when aborted els cmd's xri (SGL) was released
   before HBA's abort XRI event (CR 97288)
 * Support for Nport ID change after Clear Virtual Link (CR 97188)
 * Fixed unsolicited CT command response on SLI4
 * Add QOS Link Speed info (CR 96665)

Signed-off-by: James Smart <james.smart@emulex.com>
Acked-by: Hannes Reinecke <hare@suse.de>

diff -urpN a/drivers/scsi/lpfc/lpfc_attr.c b/drivers/scsi/lpfc/lpfc_attr.c
--- a/drivers/scsi/lpfc/lpfc_attr.c	2010-01-12 16:47:00.980080000 -0500
+++ b/drivers/scsi/lpfc/lpfc_attr.c	2010-01-12 16:46:28.402802000 -0500
@@ -45,6 +45,8 @@
 #include "lpfc_compat.h"
 #include "lpfc_crtn.h"
 #include "lpfc_vport.h"
+#include "lpfc_auth_access.h"
+#include "lpfc_security.h"
 
 #define LPFC_DEF_DEVLOSS_TMO 30
 #define LPFC_MIN_DEVLOSS_TMO 1
@@ -639,7 +641,7 @@ lpfc_do_offline(struct lpfc_hba *phba, u
  * -EIO reset not configured or error posting the event
  * zero for success
  **/
-static int
+int
 lpfc_selective_reset(struct lpfc_hba *phba)
 {
 	struct completion online_compl;
@@ -1197,6 +1199,152 @@ lpfc_poll_store(struct device *dev, stru
 	return strlen(buf);
 }
 
+static ssize_t
+lpfc_auth_state_show(struct device *dev, struct device_attribute *attr,
+		    char *buf)
+{
+	struct Scsi_Host  *shost = class_to_shost(dev);
+	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
+	switch (vport->auth.auth_state) {
+	case LPFC_AUTH_UNKNOWN:
+		if (vport->auth.auth_msg_state == LPFC_AUTH_NEGOTIATE ||
+		    vport->auth.auth_msg_state == LPFC_DHCHAP_CHALLENGE ||
+		    vport->auth.auth_msg_state == LPFC_DHCHAP_REPLY ||
+		    vport->auth.auth_msg_state == LPFC_DHCHAP_SUCCESS_REPLY)
+			return snprintf(buf, PAGE_SIZE, "Authenticating\n");
+		else
+			return snprintf(buf, PAGE_SIZE, "Not Authenticated\n");
+	case LPFC_AUTH_FAIL:
+		return snprintf(buf, PAGE_SIZE, "Failed\n");
+	case LPFC_AUTH_FAIL_ELS_TMO:
+		return snprintf(buf, PAGE_SIZE, "Failed - ELS Timeout\n");
+	case LPFC_AUTH_FAIL_TRANS_TMO:
+		return snprintf(buf, PAGE_SIZE, "Failed - "
+				"Transaction Timeout\n");
+	case LPFC_AUTH_FAIL_LS_RJT_GEN:
+		return snprintf(buf, PAGE_SIZE, "Failed - LS_RJT\n");
+	case LPFC_AUTH_FAIL_LS_RJT_BUSY:
+		return snprintf(buf, PAGE_SIZE, "Failed - LS_RJT Busy\n");
+	case LPFC_AUTH_FAIL_AUTH_RJT:
+		return snprintf(buf, PAGE_SIZE, "Failed - AUTH RJT\n");
+	case LPFC_AUTH_SUCCESS:
+		if (vport->auth.auth_msg_state == LPFC_AUTH_NEGOTIATE ||
+		    vport->auth.auth_msg_state == LPFC_DHCHAP_CHALLENGE ||
+		    vport->auth.auth_msg_state == LPFC_DHCHAP_REPLY ||
+		    vport->auth.auth_msg_state == LPFC_DHCHAP_SUCCESS_REPLY)
+			return snprintf(buf, PAGE_SIZE, "Authenticating\n");
+		else if (vport->auth.auth_msg_state == LPFC_DHCHAP_SUCCESS)
+			return snprintf(buf, PAGE_SIZE, "Authenticated\n");
+	}
+	return snprintf(buf, PAGE_SIZE, "Unknown\n");
+}
+
+static ssize_t
+lpfc_auth_dir_show(struct device *dev, struct device_attribute *attr,
+		   char *buf)
+{
+	struct Scsi_Host  *shost = class_to_shost(dev);
+	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
+	if (!vport->cfg_enable_auth ||
+	    vport->auth.auth_state != LPFC_AUTH_SUCCESS)
+		return snprintf(buf, PAGE_SIZE, "Unknown\n");
+	if (vport->auth.direction == AUTH_DIRECTION_LOCAL)
+		return snprintf(buf, PAGE_SIZE, "Local Authenticated\n");
+	else if (vport->auth.direction == AUTH_DIRECTION_REMOTE)
+		return snprintf(buf, PAGE_SIZE, "Remote Authenticated\n");
+	else if (vport->auth.direction == AUTH_DIRECTION_BIDI)
+		return snprintf(buf, PAGE_SIZE, "Bidi Authentication\n");
+	return snprintf(buf, PAGE_SIZE, "Unknown\n");
+}
+
+static ssize_t
+lpfc_auth_protocol_show(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct Scsi_Host  *shost = class_to_shost(dev);
+	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
+	if (vport->cfg_enable_auth &&
+	    vport->auth.auth_state == LPFC_AUTH_SUCCESS)
+		return snprintf(buf, PAGE_SIZE, "1 (DH-CHAP)\n");
+	else
+		return snprintf(buf, PAGE_SIZE, "Unknown\n");
+}
+
+static ssize_t
+lpfc_auth_dhgroup_show(struct device *dev, struct device_attribute *attr,
+		       char *buf)
+{
+	struct Scsi_Host  *shost = class_to_shost(dev);
+	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
+	if (!vport->cfg_enable_auth ||
+	    vport->auth.auth_state != LPFC_AUTH_SUCCESS)
+		return snprintf(buf, PAGE_SIZE, "Unknown\n");
+	switch (vport->auth.group_id) {
+	case DH_GROUP_NULL:
+		return snprintf(buf, PAGE_SIZE, "0 (NULL)\n");
+	case DH_GROUP_1024:
+		return snprintf(buf, PAGE_SIZE, "1 (1024)\n");
+	case DH_GROUP_1280:
+		return snprintf(buf, PAGE_SIZE, "2 (1280)\n");
+	case DH_GROUP_1536:
+		return snprintf(buf, PAGE_SIZE, "3 (1536)\n");
+	case DH_GROUP_2048:
+		return snprintf(buf, PAGE_SIZE, "4 (2048)\n");
+	}
+	return snprintf(buf, PAGE_SIZE, "%d (Unrecognized)\n",
+			vport->auth.group_id);
+}
+
+static ssize_t
+lpfc_auth_hash_show(struct device *dev, struct device_attribute *attr,
+		    char *buf)
+{
+	struct Scsi_Host  *shost = class_to_shost(dev);
+	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
+	if (!vport->cfg_enable_auth ||
+	    vport->auth.auth_state != LPFC_AUTH_SUCCESS)
+		return snprintf(buf, PAGE_SIZE, "Unknown\n");
+	switch (vport->auth.hash_id) {
+	case FC_SP_HASH_MD5:
+		return snprintf(buf, PAGE_SIZE, "5 (MD5)\n");
+	case FC_SP_HASH_SHA1:
+		return snprintf(buf, PAGE_SIZE, "6 (SHA1)\n");
+	}
+	return snprintf(buf, PAGE_SIZE, "%d (Unrecognized)\n",
+			vport->auth.hash_id);
+}
+static ssize_t
+lpfc_auth_last_show(struct device *dev, struct device_attribute *attr,
+		    char *buf)
+{
+	struct Scsi_Host  *shost = class_to_shost(dev);
+	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
+	struct timeval last_time;
+	if (!vport->cfg_enable_auth || vport->auth.last_auth == 0)
+		return snprintf(buf, PAGE_SIZE, "%d\n", -1);
+	jiffies_to_timeval((jiffies - vport->auth.last_auth), &last_time);
+	return snprintf(buf, PAGE_SIZE, "%ld\n", last_time.tv_sec);
+}
+
+static ssize_t
+lpfc_auth_next_show(struct device *dev, struct device_attribute *attr,
+		    char *buf)
+{
+	struct Scsi_Host  *shost = class_to_shost(dev);
+	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
+	unsigned long next_jiff;
+	struct timeval next_time;
+	if (!vport->cfg_enable_auth ||
+	    vport->auth.last_auth == 0 ||
+	    vport->auth.reauth_interval == 0)
+		return snprintf(buf, PAGE_SIZE, "%d\n", -1);
+	/* calculate the amount of time left until next auth */
+	next_jiff = (msecs_to_jiffies(vport->auth.reauth_interval * 60000) +
+		     vport->auth.last_auth) - jiffies;
+	jiffies_to_timeval(next_jiff, &next_time);
+	return snprintf(buf, PAGE_SIZE, "%ld\n", next_time.tv_sec);
+}
+
 /**
  * lpfc_param_show - Return a cfg attribute value in decimal
  *
@@ -1634,7 +1782,38 @@ static DEVICE_ATTR(max_xri, S_IRUGO, lpf
 static DEVICE_ATTR(used_xri, S_IRUGO, lpfc_used_xri_show, NULL);
 static DEVICE_ATTR(npiv_info, S_IRUGO, lpfc_npiv_info_show, NULL);
 static DEVICE_ATTR(lpfc_temp_sensor, S_IRUGO, lpfc_temp_sensor_show, NULL);
+static DEVICE_ATTR(auth_state, S_IRUGO, lpfc_auth_state_show, NULL);
+static DEVICE_ATTR(auth_dir, S_IRUGO, lpfc_auth_dir_show, NULL);
+static DEVICE_ATTR(auth_protocol, S_IRUGO, lpfc_auth_protocol_show, NULL);
+static DEVICE_ATTR(auth_dhgroup, S_IRUGO, lpfc_auth_dhgroup_show, NULL);
+static DEVICE_ATTR(auth_hash, S_IRUGO, lpfc_auth_hash_show, NULL);
+static DEVICE_ATTR(auth_last, S_IRUGO, lpfc_auth_last_show, NULL);
+static DEVICE_ATTR(auth_next, S_IRUGO, lpfc_auth_next_show, NULL);
 
+static int
+lpfc_parse_wwn(const char *ns, uint8_t *nm)
+{
+	unsigned int i, j;
+	memset(nm, 0, 8);
+
+	/* Validate and store the new name */
+	for (i = 0, j = 0; i < 16; i++) {
+		if ((*ns >= 'a') && (*ns <= 'f'))
+			j = ((j << 4) | ((*ns++ - 'a') + 10));
+		else if ((*ns >= 'A') && (*ns <= 'F'))
+			j = ((j << 4) | ((*ns++ - 'A') + 10));
+		else if ((*ns >= '0') && (*ns <= '9'))
+			j = ((j << 4) | (*ns++ - '0'));
+		else
+			return -EINVAL;
+		if (i % 2) {
+			nm[i/2] = j & 0xff;
+			j = 0;
+		}
+	}
+
+	return 0;
+}
 
 static char *lpfc_soft_wwn_key = "C99G71SL8032A";
 
@@ -2030,6 +2209,88 @@ lpfc_vport_param_store(nodev_tmo)
 
 static DEVICE_ATTR(lpfc_nodev_tmo, S_IRUGO | S_IWUSR,
 		   lpfc_nodev_tmo_show, lpfc_nodev_tmo_store);
+static ssize_t
+lpfc_authenticate(struct device *dev, struct device_attribute *attr,
+		  const char *buf, size_t count)
+{
+	struct Scsi_Host *shost = class_to_shost(dev);
+	struct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;
+	struct lpfc_hba   *phba = vport->phba;
+	struct lpfc_nodelist *ndlp;
+	int status;
+	struct lpfc_name wwpn;
+
+	if (lpfc_parse_wwn(buf, wwpn.u.wwn))
+		return -EINVAL;
+
+	if (vport->port_state == LPFC_VPORT_FAILED) {
+		lpfc_issue_lip(shost);
+		return strlen(buf);
+	}
+	if ((vport->fc_flag & FC_OFFLINE_MODE) ||
+	    (phba->sli.sli_flag & LPFC_BLOCK_MGMT_IO) ||
+	    (!vport->cfg_enable_auth))
+		return -EPERM;
+
+	/* If vport already in the middle of authentication do not restart */
+	if ((vport->auth.auth_msg_state == LPFC_AUTH_NEGOTIATE) ||
+	    (vport->auth.auth_msg_state == LPFC_DHCHAP_CHALLENGE) ||
+	    (vport->auth.auth_msg_state == LPFC_DHCHAP_REPLY))
+		return -EAGAIN;
+
+	if (wwn_to_u64(wwpn.u.wwn) == AUTH_FABRIC_WWN)
+		ndlp = lpfc_findnode_did(vport, Fabric_DID);
+	else
+		ndlp = lpfc_findnode_wwnn(vport, &wwpn);
+	if (!ndlp || !NLP_CHK_NODE_ACT(ndlp))
+		return -EPERM;
+	status = lpfc_start_node_authentication(ndlp);
+	if (status)
+		return status;
+	return strlen(buf);
+}
+static DEVICE_ATTR(lpfc_authenticate, S_IRUGO | S_IWUSR, NULL,
+		   lpfc_authenticate);
+
+static ssize_t
+lpfc_update_auth_config(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	struct Scsi_Host *shost = class_to_shost(dev);
+	struct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;
+	struct lpfc_hba   *phba = vport->phba;
+	struct lpfc_nodelist *ndlp;
+	struct lpfc_name wwpn;
+	int status;
+
+	if (lpfc_parse_wwn(buf, wwpn.u.wwn))
+		return -EINVAL;
+
+	if ((vport->fc_flag & FC_OFFLINE_MODE) ||
+	    (phba->sli.sli_flag & LPFC_BLOCK_MGMT_IO) ||
+	    (!vport->cfg_enable_auth))
+		return -EPERM;
+
+	/* If vport already in the middle of authentication do not restart */
+	if ((vport->auth.auth_msg_state == LPFC_AUTH_NEGOTIATE) ||
+	    (vport->auth.auth_msg_state == LPFC_DHCHAP_CHALLENGE) ||
+	    (vport->auth.auth_msg_state == LPFC_DHCHAP_REPLY))
+		return -EAGAIN;
+
+	if (wwn_to_u64(wwpn.u.wwn) == AUTH_FABRIC_WWN)
+		status = lpfc_get_auth_config(vport, NULL);
+	else {
+		ndlp = lpfc_findnode_wwnn(vport, &wwpn);
+		if (!ndlp || !NLP_CHK_NODE_ACT(ndlp))
+			return -EPERM;
+		status = lpfc_get_auth_config(vport, ndlp);
+	}
+	if (status)
+		return -EPERM;
+	return strlen(buf);
+}
+static DEVICE_ATTR(lpfc_update_auth_config, S_IRUGO | S_IWUSR,
+		   NULL, lpfc_update_auth_config);
 
 /*
 # lpfc_devloss_tmo: If set, it will hold all I/O errors on devices that
@@ -2835,6 +3096,9 @@ lpfc_aer_support_store(struct device *de
 	struct lpfc_hba *phba = vport->phba;
 	int val = 0, rc = -EINVAL;
 
+	/* AER not supported on OC devices yet */
+	if (phba->pci_dev_grp == LPFC_PCI_DEV_OC)
+		return -EPERM;
 	if (!isdigit(buf[0]))
 		return -EINVAL;
 	if (sscanf(buf, "%i", &val) != 1)
@@ -2851,10 +3115,11 @@ lpfc_aer_support_store(struct device *de
 				phba->cfg_aer_support = 0;
 				rc = strlen(buf);
 			} else
-				rc = -EINVAL;
-		} else
+				rc = -EPERM;
+		} else {
 			phba->cfg_aer_support = 0;
-		rc = strlen(buf);
+			rc = strlen(buf);
+		}
 		break;
 	case 1:
 		if (!(phba->hba_flag & HBA_AER_ENABLED)) {
@@ -2866,10 +3131,11 @@ lpfc_aer_support_store(struct device *de
 				phba->cfg_aer_support = 1;
 				rc = strlen(buf);
 			} else
-				 rc = -EINVAL;
-		} else
+				 rc = -EPERM;
+		} else {
 			phba->cfg_aer_support = 1;
-		rc = strlen(buf);
+			rc = strlen(buf);
+		}
 		break;
 	default:
 		rc = -EINVAL;
@@ -2905,6 +3171,12 @@ lpfc_param_show(aer_support)
 static int
 lpfc_aer_support_init(struct lpfc_hba *phba, int val)
 {
+	/* AER not supported on OC devices yet */
+	if (phba->pci_dev_grp == LPFC_PCI_DEV_OC) {
+		phba->cfg_aer_support = 0;
+		return -EPERM;
+	}
+
 	if (val == 0 || val == 1) {
 		phba->cfg_aer_support = val;
 		return 0;
@@ -2913,6 +3185,7 @@ lpfc_aer_support_init(struct lpfc_hba *p
 			"2712 lpfc_aer_support attribute value %d out "
 			"of range, allowed values are 0|1, setting it "
 			"to default value of 1\n", val);
+	/* By default, try to enable AER on a device */
 	phba->cfg_aer_support = 1;
 	return -EINVAL;
 }
@@ -2948,18 +3221,23 @@ lpfc_aer_cleanup_state(struct device *de
 	struct lpfc_hba   *phba = vport->phba;
 	int val, rc = -1;
 
+	/* AER not supported on OC devices yet */
+	if (phba->pci_dev_grp == LPFC_PCI_DEV_OC)
+		return -EPERM;
 	if (!isdigit(buf[0]))
 		return -EINVAL;
 	if (sscanf(buf, "%i", &val) != 1)
 		return -EINVAL;
+	if (val != 1)
+		return -EINVAL;
 
-	if (val == 1 && phba->hba_flag & HBA_AER_ENABLED)
+	if (phba->hba_flag & HBA_AER_ENABLED)
 		rc = pci_cleanup_aer_uncorrect_error_status(phba->pcidev);
 
 	if (rc == 0)
 		return strlen(buf);
 	else
-		return -EINVAL;
+		return -EPERM;
 }
 
 static DEVICE_ATTR(lpfc_aer_state_cleanup, S_IWUSR, NULL,
@@ -3106,6 +3384,48 @@ LPFC_ATTR_R(use_msi, 0, 0, 2, "Use Messa
 	    "MSI-X (2), if possible");
 
 /*
+# lpfc_enable_auth: controls FC Authentication.
+#       0 = Authentication OFF
+#       1 = Authentication ON
+# Value range [0,1]. Default value is 0.
+*/
+static int lpfc_enable_auth;
+module_param(lpfc_enable_auth, int, 0);
+MODULE_PARM_DESC(lpfc_enable_auth, "Enable FC Authentication");
+lpfc_vport_param_show(enable_auth);
+lpfc_vport_param_init(enable_auth, 0, 0, 1);
+static int
+lpfc_enable_auth_set(struct lpfc_vport *vport, int val)
+{
+	if (val == vport->cfg_enable_auth)
+		return 0;
+	if (val == 0) {
+		spin_lock_irq(&fc_security_user_lock);
+		list_del(&vport->sc_users);
+		spin_unlock_irq(&fc_security_user_lock);
+		vport->cfg_enable_auth = val;
+		lpfc_fc_queue_security_work(vport,
+					    &vport->sc_offline_work);
+		return 0;
+	} else if (val == 1) {
+		spin_lock_irq(&fc_security_user_lock);
+		list_add_tail(&vport->sc_users, &fc_security_user_list);
+		spin_unlock_irq(&fc_security_user_lock);
+		vport->cfg_enable_auth = val;
+		lpfc_fc_queue_security_work(vport,
+					    &vport->sc_online_work);
+		return 0;
+	}
+	lpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,
+			 "0560 lpfc_enable_auth attribute cannot be set to %d, "
+			 "allowed range is [0, 1]\n", val);
+	return -EINVAL;
+}
+lpfc_vport_param_store(enable_auth);
+static DEVICE_ATTR(lpfc_enable_auth, S_IRUGO | S_IWUSR,
+		   lpfc_enable_auth_show, lpfc_enable_auth_store);
+
+/*
 # lpfc_fcp_imax: Set the maximum number of fast-path FCP interrupts per second
 #
 # Value range is [636,651042]. Default value is 10000.
@@ -3246,6 +3566,16 @@ struct device_attribute *lpfc_hba_attrs[
 	&dev_attr_lpfc_poll,
 	&dev_attr_lpfc_poll_tmo,
 	&dev_attr_lpfc_use_msi,
+	&dev_attr_lpfc_enable_auth,
+	&dev_attr_lpfc_authenticate,
+	&dev_attr_lpfc_update_auth_config,
+	&dev_attr_auth_state,
+	&dev_attr_auth_dir,
+	&dev_attr_auth_protocol,
+	&dev_attr_auth_dhgroup,
+	&dev_attr_auth_hash,
+	&dev_attr_auth_last,
+	&dev_attr_auth_next,
 	&dev_attr_lpfc_fcp_imax,
 	&dev_attr_lpfc_fcp_wq_count,
 	&dev_attr_lpfc_fcp_eq_count,
@@ -3283,6 +3613,13 @@ struct device_attribute *lpfc_vport_attr
 	&dev_attr_nport_evt_cnt,
 	&dev_attr_npiv_info,
 	&dev_attr_lpfc_enable_da_id,
+	&dev_attr_auth_state,
+	&dev_attr_auth_dir,
+	&dev_attr_auth_protocol,
+	&dev_attr_auth_dhgroup,
+	&dev_attr_auth_hash,
+	&dev_attr_auth_last,
+	&dev_attr_auth_next,
 	&dev_attr_lpfc_max_scsicmpl_time,
 	&dev_attr_lpfc_stat_data_ctrl,
 	&dev_attr_lpfc_static_vport,
@@ -4464,5 +4801,9 @@ lpfc_get_vport_cfgparam(struct lpfc_vpor
 	lpfc_max_luns_init(vport, lpfc_max_luns);
 	lpfc_scan_down_init(vport, lpfc_scan_down);
 	lpfc_enable_da_id_init(vport, lpfc_enable_da_id);
+	if (vport->phba->sli_rev != LPFC_SLI_REV4)
+		lpfc_enable_auth_init(vport, lpfc_enable_auth);
+	else
+		lpfc_enable_auth_init(vport, 0);
 	return;
 }
diff -urpN a/drivers/scsi/lpfc/lpfc_auth_access.c b/drivers/scsi/lpfc/lpfc_auth_access.c
--- a/drivers/scsi/lpfc/lpfc_auth_access.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/scsi/lpfc/lpfc_auth_access.c	2010-01-12 16:46:28.422798000 -0500
@@ -0,0 +1,602 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Copyright (C) 2006-2008 Emulex.  All rights reserved.           *
+ * EMULEX and SLI are trademarks of Emulex.                        *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of version 2 of the GNU General       *
+ * Public License as published by the Free Software Foundation.    *
+ * This program is distributed in the hope that it will be useful. *
+ * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *
+ * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *
+ * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *
+ * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *
+ * TO BE LEGALLY INVALID.  See the GNU General Public License for  *
+ * more details, a copy of which can be found in the file COPYING  *
+ * included with this package.                                     *
+ *******************************************************************/
+#include <linux/blkdev.h>
+#include <linux/pci.h>
+#include <linux/kthread.h>
+#include <linux/interrupt.h>
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/sched.h>	/* workqueue stuff, HZ */
+#include <scsi/scsi_device.h>
+#include <scsi/scsi_host.h>
+#include <scsi/scsi_transport.h>
+#include <scsi/scsi_transport_fc.h>
+#include <scsi/scsi_cmnd.h>
+#include <linux/time.h>
+#include <linux/jiffies.h>
+#include <linux/security.h>
+#include <net/sock.h>
+#include <net/netlink.h>
+
+#include <scsi/scsi.h>
+
+#include "lpfc_hw4.h"
+#include "lpfc_hw.h"
+#include "lpfc_sli.h"
+#include "lpfc_sli4.h"
+#include "lpfc_nl.h"
+#include "lpfc_disc.h"
+#include "lpfc_scsi.h"
+#include "lpfc.h"
+#include "lpfc_logmsg.h"
+#include "lpfc_crtn.h"
+#include "lpfc_vport.h"
+#include "lpfc_auth_access.h"
+
+/* fc security */
+struct workqueue_struct *security_work_q;
+struct list_head fc_security_user_list;
+int fc_service_state = FC_SC_SERVICESTATE_UNKNOWN;
+static int fc_service_pid;
+DEFINE_SPINLOCK(fc_security_user_lock);
+
+static inline struct lpfc_vport *
+lpfc_fc_find_vport(unsigned long host_no)
+{
+	struct lpfc_vport *vport;
+	struct Scsi_Host *shost;
+
+	list_for_each_entry(vport, &fc_security_user_list, sc_users) {
+		shost = lpfc_shost_from_vport(vport);
+		if (shost && (shost->host_no == host_no))
+			return vport;
+	}
+
+	return NULL;
+}
+
+
+/**
+ * lpfc_fc_sc_add_timer
+ *
+ *
+ **/
+
+void
+lpfc_fc_sc_add_timer(struct fc_security_request *req, int timeout,
+		    void (*complete)(struct fc_security_request *))
+{
+
+	init_timer(&req->timer);
+
+
+	req->timer.data = (unsigned long)req;
+	req->timer.expires = jiffies + timeout;
+	req->timer.function = (void (*)(unsigned long)) complete;
+
+	add_timer(&req->timer);
+}
+/**
+ * lpfc_fc_sc_req_times_out
+ *
+ *
+ **/
+
+void
+lpfc_fc_sc_req_times_out(struct fc_security_request *req)
+{
+
+	unsigned long flags;
+	int found = 0;
+	struct fc_security_request *fc_sc_req;
+	struct lpfc_vport *vport = req->vport;
+	struct Scsi_Host *shost = lpfc_shost_from_vport(vport);
+
+	if (!req)
+		return;
+
+	spin_lock_irqsave(shost->host_lock, flags);
+
+	/* To avoid a completion race check to see if request is on the list */
+
+	list_for_each_entry(fc_sc_req, &vport->sc_response_wait_queue, rlist)
+		if (fc_sc_req == req) {
+			found = 1;
+			break;
+		}
+
+	if (!found) {
+		spin_unlock_irqrestore(shost->host_lock, flags);
+		return;
+		}
+
+	list_del(&fc_sc_req->rlist);
+
+	spin_unlock_irqrestore(shost->host_lock, flags);
+
+	lpfc_printf_vlog(vport, KERN_WARNING, LOG_SECURITY,
+			 "1019 Request tranid %d timed out\n",
+			 fc_sc_req->tran_id);
+
+	switch (fc_sc_req->req_type) {
+
+	case FC_NL_SC_GET_CONFIG_REQ:
+		lpfc_security_config(shost, -ETIMEDOUT,
+			fc_sc_req->data);
+		break;
+
+	case FC_NL_SC_DHCHAP_MAKE_CHALLENGE_REQ:
+		lpfc_dhchap_make_challenge(shost, -ETIMEDOUT,
+			fc_sc_req->data, 0);
+		break;
+
+	case FC_NL_SC_DHCHAP_MAKE_RESPONSE_REQ:
+		lpfc_dhchap_make_response(shost, -ETIMEDOUT,
+			fc_sc_req->data, 0);
+		break;
+
+	case FC_NL_SC_DHCHAP_AUTHENTICATE_REQ:
+		lpfc_dhchap_authenticate(shost, -ETIMEDOUT, fc_sc_req->data, 0);
+		break;
+	}
+
+	kfree(fc_sc_req);
+
+}
+
+
+static inline struct fc_security_request *
+lpfc_fc_find_sc_request(u32 tran_id, u32 type, struct lpfc_vport *vport)
+{
+	struct fc_security_request *fc_sc_req;
+
+	list_for_each_entry(fc_sc_req, &vport->sc_response_wait_queue, rlist)
+		if (fc_sc_req->tran_id == tran_id &&
+			fc_sc_req->req_type == type)
+			return fc_sc_req;
+	return NULL;
+}
+
+
+
+/**
+ * lpfc_fc_sc_request
+ *
+ *
+ **/
+
+int
+lpfc_fc_sc_request(struct lpfc_vport *vport,
+	      u32 msg_type,
+	      struct fc_auth_req *auth_req,
+	      u32 auth_req_len, /* includes length of struct fc_auth_req */
+	      struct fc_auth_rsp *auth_rsp,
+	      u32 auth_rsp_len)	/* includes length of struct fc_auth_rsp */
+{
+	struct Scsi_Host *shost = lpfc_shost_from_vport(vport);
+	struct fc_security_request *fc_sc_req;
+	struct fc_nl_sc_message *fc_nl_sc_msg;
+	unsigned long flags;
+	u32 len;
+	u32 seq = ++vport->sc_tran_id;
+
+	if (fc_service_state != FC_SC_SERVICESTATE_ONLINE)
+		return -EINVAL;
+
+	if (vport->port_state == FC_PORTSTATE_DELETED)
+		return -EINVAL;
+
+	fc_sc_req = kzalloc(sizeof(struct fc_security_request), GFP_KERNEL);
+	if (!fc_sc_req)
+		return -ENOMEM;
+
+	fc_sc_req->req_type = msg_type;
+	fc_sc_req->data = auth_rsp;
+	fc_sc_req->data_len = auth_rsp_len;
+	fc_sc_req->vport = vport;
+	fc_sc_req->tran_id = seq;
+
+	len = sizeof(struct fc_nl_sc_message) + auth_req_len;
+	fc_nl_sc_msg = kzalloc(len, GFP_KERNEL);
+	if (!fc_nl_sc_msg) {
+		kfree(fc_sc_req);
+		return -ENOMEM;
+	}
+	fc_nl_sc_msg->msgtype = msg_type;
+	fc_nl_sc_msg->data_len = auth_req_len;
+	memcpy(fc_nl_sc_msg->data, auth_req, auth_req_len);
+	fc_nl_sc_msg->tran_id = seq;
+
+	lpfc_fc_sc_add_timer(fc_sc_req, FC_SC_REQ_TIMEOUT,
+			     lpfc_fc_sc_req_times_out);
+
+	spin_lock_irqsave(shost->host_lock, flags);
+	list_add_tail(&fc_sc_req->rlist, &vport->sc_response_wait_queue);
+	spin_unlock_irqrestore(shost->host_lock, flags);
+	scsi_nl_send_vendor_msg(fc_service_pid, shost->host_no,
+				(SCSI_NL_VID_TYPE_PCI | PCI_VENDOR_ID_EMULEX),
+				(char *) fc_nl_sc_msg, len);
+	kfree(fc_nl_sc_msg);
+	return 0;
+}
+
+/**
+ * lpfc_fc_security_get_config
+ *
+ *
+ **/
+
+int
+lpfc_fc_security_get_config(struct Scsi_Host *shost,
+			struct fc_auth_req *auth_req,
+			u32 auth_req_len,
+			struct fc_auth_rsp *auth_rsp,
+			u32 auth_rsp_len)
+{
+
+	return lpfc_fc_sc_request((struct lpfc_vport *) shost->hostdata,
+				  FC_NL_SC_GET_CONFIG_REQ, auth_req,
+				  auth_req_len, auth_rsp, auth_rsp_len);
+
+}
+EXPORT_SYMBOL(lpfc_fc_security_get_config);
+
+/**
+ * lpfc_fc_security_dhchap_make_challenge
+ *
+ *
+ **/
+
+int
+lpfc_fc_security_dhchap_make_challenge(struct Scsi_Host *shost,
+				  struct fc_auth_req *auth_req,
+				  u32 auth_req_len,
+				  struct fc_auth_rsp *auth_rsp,
+				  u32 auth_rsp_len)
+{
+
+	return lpfc_fc_sc_request((struct lpfc_vport *) shost->hostdata,
+				  FC_NL_SC_DHCHAP_MAKE_CHALLENGE_REQ,
+				  auth_req, auth_req_len,
+				  auth_rsp, auth_rsp_len);
+
+}
+EXPORT_SYMBOL(lpfc_fc_security_dhchap_make_challenge);
+
+/**
+ * lpfc_fc_security_dhchap_make_response
+ *
+ *
+ **/
+
+int
+lpfc_fc_security_dhchap_make_response(struct Scsi_Host *shost,
+			struct fc_auth_req *auth_req,
+			u32 auth_req_len,
+			struct fc_auth_rsp *auth_rsp,
+			u32 auth_rsp_len)
+{
+
+	return lpfc_fc_sc_request((struct lpfc_vport *) shost->hostdata,
+				  FC_NL_SC_DHCHAP_MAKE_RESPONSE_REQ,
+				  auth_req, auth_req_len,
+				  auth_rsp, auth_rsp_len);
+
+}
+EXPORT_SYMBOL(lpfc_fc_security_dhchap_make_response);
+
+
+/**
+ * lpfc_fc_security_dhchap_authenticate
+ *
+ *
+ **/
+
+int
+lpfc_fc_security_dhchap_authenticate(struct Scsi_Host *shost,
+			struct fc_auth_req *auth_req,
+			u32 auth_req_len,
+			struct fc_auth_rsp *auth_rsp,
+			u32 auth_rsp_len)
+{
+
+	return lpfc_fc_sc_request((struct lpfc_vport *) shost->hostdata,
+				  FC_NL_SC_DHCHAP_AUTHENTICATE_REQ,
+				  auth_req, auth_req_len,
+				  auth_rsp, auth_rsp_len);
+
+}
+EXPORT_SYMBOL(lpfc_fc_security_dhchap_authenticate);
+
+/**
+ * lpfc_fc_queue_security_work - Queue work to the fc_host security workqueue.
+ * @shost:	Pointer to Scsi_Host bound to fc_host.
+ * @work:	Work to queue for execution.
+ *
+ * Return value:
+ *	1 - work queued for execution
+ *	0 - work is already queued
+ *	-EINVAL - work queue doesn't exist
+ **/
+int
+lpfc_fc_queue_security_work(struct lpfc_vport *vport, struct work_struct *work)
+{
+	if (unlikely(!security_work_q)) {
+		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
+			"1021 ERROR: attempted to queue security work, "
+			"when no workqueue created.\n");
+		dump_stack();
+
+		return -EINVAL;
+	}
+
+	return queue_work(security_work_q, work);
+
+}
+
+
+
+ /**
+ * lpfc_fc_sc_schedule_notify_all
+ *
+ *
+ **/
+
+void
+lpfc_fc_sc_schedule_notify_all(int message)
+{
+	struct lpfc_vport *vport;
+	unsigned long flags;
+
+	spin_lock_irqsave(&fc_security_user_lock, flags);
+	list_for_each_entry(vport, &fc_security_user_list, sc_users) {
+		switch (message) {
+		case FC_NL_SC_REG:
+			lpfc_fc_queue_security_work(vport,
+						    &vport->sc_online_work);
+			break;
+		case FC_NL_SC_DEREG:
+			lpfc_fc_queue_security_work(vport,
+						    &vport->sc_offline_work);
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&fc_security_user_lock, flags);
+}
+
+
+
+/**
+ * lpfc_fc_sc_security_online
+ *
+ *
+ **/
+
+void
+lpfc_fc_sc_security_online(struct work_struct *work)
+{
+	struct lpfc_vport *vport = container_of(work, struct lpfc_vport,
+						sc_online_work);
+	lpfc_security_service_online(lpfc_shost_from_vport(vport));
+	return;
+}
+
+/**
+ * lpfc_fc_sc_security_offline
+ *
+ *
+ **/
+void
+lpfc_fc_sc_security_offline(struct work_struct *work)
+{
+	struct lpfc_vport *vport = container_of(work, struct lpfc_vport,
+						sc_offline_work);
+	lpfc_security_service_offline(lpfc_shost_from_vport(vport));
+	return;
+}
+
+
+/**
+ * lpfc_fc_sc_process_msg
+ *
+ *
+ **/
+static void
+lpfc_fc_sc_process_msg(struct work_struct *work)
+{
+	struct fc_sc_msg_work_q_wrapper *wqw =
+		container_of(work, struct fc_sc_msg_work_q_wrapper, work);
+
+	switch (wqw->msgtype) {
+
+	case FC_NL_SC_GET_CONFIG_RSP:
+		lpfc_security_config(lpfc_shost_from_vport(wqw->fc_sc_req->
+				vport), wqw->status,
+				wqw->fc_sc_req->data);
+		break;
+
+	case FC_NL_SC_DHCHAP_MAKE_CHALLENGE_RSP:
+		lpfc_dhchap_make_challenge(lpfc_shost_from_vport(wqw->
+					fc_sc_req->vport), wqw->status,
+					wqw->fc_sc_req->data, wqw->data_len);
+		break;
+
+	case FC_NL_SC_DHCHAP_MAKE_RESPONSE_RSP:
+		lpfc_dhchap_make_response(lpfc_shost_from_vport(wqw->
+					fc_sc_req->vport), wqw->status,
+					wqw->fc_sc_req->data, wqw->data_len);
+		break;
+
+	case FC_NL_SC_DHCHAP_AUTHENTICATE_RSP:
+		lpfc_dhchap_authenticate(lpfc_shost_from_vport(wqw->fc_sc_req->
+					vport),
+					wqw->status,
+					wqw->fc_sc_req->data, wqw->data_len);
+		break;
+	}
+
+	kfree(wqw->fc_sc_req);
+	kfree(wqw);
+
+	return;
+}
+
+
+/**
+ * lpfc_fc_sc_schedule_msg
+ *
+ *
+ **/
+
+int
+lpfc_fc_sc_schedule_msg(struct Scsi_Host *shost,
+			struct fc_nl_sc_message *fc_nl_sc_msg, int rcvlen)
+{
+	struct fc_security_request *fc_sc_req;
+	u32 req_type;
+	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
+	int err = 0;
+	struct fc_sc_msg_work_q_wrapper *wqw;
+	unsigned long flags;
+
+	if (vport->port_state == FC_PORTSTATE_DELETED) {
+		printk(KERN_WARNING
+		"%s: Host being deleted.\n", __func__);
+		return -EBADR;
+	}
+
+	wqw = kzalloc(sizeof(struct fc_sc_msg_work_q_wrapper), GFP_KERNEL);
+
+	if (!wqw)
+		return -ENOMEM;
+
+	switch (fc_nl_sc_msg->msgtype) {
+	case FC_NL_SC_GET_CONFIG_RSP:
+		req_type = FC_NL_SC_GET_CONFIG_REQ;
+		break;
+
+	case FC_NL_SC_DHCHAP_MAKE_CHALLENGE_RSP:
+		req_type = FC_NL_SC_DHCHAP_MAKE_CHALLENGE_REQ;
+		break;
+
+	case FC_NL_SC_DHCHAP_MAKE_RESPONSE_RSP:
+		req_type = FC_NL_SC_DHCHAP_MAKE_RESPONSE_REQ;
+		break;
+
+	case FC_NL_SC_DHCHAP_AUTHENTICATE_RSP:
+		req_type = FC_NL_SC_DHCHAP_AUTHENTICATE_REQ;
+		break;
+
+	default:
+		kfree(wqw);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(shost->host_lock, flags);
+
+	fc_sc_req = lpfc_fc_find_sc_request(fc_nl_sc_msg->tran_id,
+				req_type, vport);
+
+	if (!fc_sc_req) {
+		spin_unlock_irqrestore(shost->host_lock, flags);
+		lpfc_printf_vlog(vport, KERN_WARNING, LOG_SECURITY,
+				 "1022 Security request does not exist.\n");
+		kfree(wqw);
+		return -EBADR;
+	}
+
+	list_del(&fc_sc_req->rlist);
+
+	spin_unlock_irqrestore(shost->host_lock, flags);
+
+	del_singleshot_timer_sync(&fc_sc_req->timer);
+
+	wqw->status = 0;
+	wqw->fc_sc_req = fc_sc_req;
+	wqw->data_len = rcvlen;
+	wqw->msgtype = fc_nl_sc_msg->msgtype;
+
+	if (!fc_sc_req->data ||
+		(fc_sc_req->data_len < fc_nl_sc_msg->data_len)) {
+		wqw->status = -ENOBUFS;
+		wqw->data_len = 0;
+		lpfc_printf_vlog(vport, KERN_WARNING, LOG_SECURITY,
+				 "1023 Warning - data may have been truncated. "
+				 "data:%p reqdl:%x mesdl:%x\n",
+				 fc_sc_req->data,
+				 fc_sc_req->data_len, fc_nl_sc_msg->data_len);
+	} else {
+		memcpy(fc_sc_req->data, fc_nl_sc_msg->data,
+			fc_nl_sc_msg->data_len);
+	}
+
+	INIT_WORK(&wqw->work, lpfc_fc_sc_process_msg);
+	lpfc_fc_queue_security_work(vport, &wqw->work);
+
+	return err;
+}
+
+int
+lpfc_rcv_nl_msg(struct Scsi_Host *shost, void *payload,
+		uint32_t len, uint32_t pid)
+{
+	struct fc_nl_sc_message *msg = (struct fc_nl_sc_message *)payload;
+	int err = 0;
+printk("%s %d - msgtype:%x\n", __func__, __LINE__, msg->msgtype);
+	switch (msg->msgtype) {
+	case FC_NL_SC_REG:
+		fc_service_pid = pid;
+		fc_service_state = FC_SC_SERVICESTATE_ONLINE;
+		lpfc_fc_sc_schedule_notify_all(FC_NL_SC_REG);
+		break;
+	case FC_NL_SC_DEREG:
+		fc_service_pid = pid;
+		fc_service_state = FC_SC_SERVICESTATE_OFFLINE;
+		lpfc_fc_sc_schedule_notify_all(FC_NL_SC_DEREG);
+		break;
+	case FC_NL_SC_GET_CONFIG_RSP:
+	case FC_NL_SC_DHCHAP_MAKE_CHALLENGE_RSP:
+	case FC_NL_SC_DHCHAP_MAKE_RESPONSE_RSP:
+	case FC_NL_SC_DHCHAP_AUTHENTICATE_RSP:
+		err = lpfc_fc_sc_schedule_msg(shost, msg, len);
+		break;
+	default:
+		printk(KERN_WARNING "%s: unknown msg type 0x%x len %d\n",
+		       __func__, msg->msgtype, len);
+		break;
+	}
+	return err;
+}
+
+void
+lpfc_rcv_nl_event(struct notifier_block *this,
+		  unsigned long event,
+		  void *ptr)
+{
+	struct netlink_notify *n = ptr;
+
+	if ((event == NETLINK_URELEASE) &&
+	    (n->protocol == NETLINK_SCSITRANSPORT) && (n->pid)) {
+		printk(KERN_WARNING "Warning - Security Service Offline\n");
+		fc_service_state = FC_SC_SERVICESTATE_OFFLINE;
+		lpfc_fc_sc_schedule_notify_all(FC_NL_SC_DEREG);
+	}
+}
diff -urpN a/drivers/scsi/lpfc/lpfc_auth_access.h b/drivers/scsi/lpfc/lpfc_auth_access.h
--- a/drivers/scsi/lpfc/lpfc_auth_access.h	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/scsi/lpfc/lpfc_auth_access.h	2010-01-12 16:46:28.429798000 -0500
@@ -0,0 +1,225 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Copyright (C) 2006-2008 Emulex.  All rights reserved.           *
+ * EMULEX and SLI are trademarks of Emulex.                        *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of version 2 of the GNU General       *
+ * Public License as published by the Free Software Foundation.    *
+ * This program is distributed in the hope that it will be useful. *
+ * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *
+ * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *
+ * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *
+ * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *
+ * TO BE LEGALLY INVALID.  See the GNU General Public License for  *
+ * more details, a copy of which can be found in the file COPYING  *
+ * included with this package.                                     *
+ *******************************************************************/
+
+#define FC_SC_REQ_TIMEOUT (60*HZ)
+
+enum fc_sc_service_state {
+	FC_SC_SERVICESTATE_UNKNOWN,
+	FC_SC_SERVICESTATE_ONLINE,
+	FC_SC_SERVICESTATE_OFFLINE,
+	FC_SC_SERVICESTATE_ERROR,
+};
+
+struct fc_security_request {
+	struct list_head rlist;
+	int pid;
+	u32 tran_id;
+	u32 req_type;
+	struct timer_list timer;
+	struct lpfc_vport *vport;
+	u32 data_len;
+	void *data;
+};
+
+struct fc_sc_msg_work_q_wrapper {
+	struct work_struct work;
+	struct fc_security_request *fc_sc_req;
+	u32 data_len;
+	int status;
+	u32 msgtype;
+};
+struct fc_sc_notify_work_q_wrapper {
+	struct work_struct work;
+	struct Scsi_Host *shost;
+	int msg;
+};
+
+#define FC_DHCHAP	1
+#define FC_FCAP		2
+#define FC_FCPAP	3
+#define FC_KERBEROS	4
+
+#define FC_AUTHMODE_UNKNOWN	0
+#define FC_AUTHMODE_NONE	1
+#define FC_AUTHMODE_ACTIVE	2
+#define FC_AUTHMODE_PASSIVE	3
+
+#define FC_SP_HASH_MD5  0x5
+#define FC_SP_HASH_SHA1 0x6
+
+#define DH_GROUP_NULL	0x00
+#define DH_GROUP_1024	0x01
+#define DH_GROUP_1280	0x02
+#define DH_GROUP_1536	0x03
+#define DH_GROUP_2048	0x04
+
+#define MAX_AUTH_REQ_SIZE 1024
+#define MAX_AUTH_RSP_SIZE 1024
+
+#define AUTH_FABRIC_WWN	0xFFFFFFFFFFFFFFFFLL
+
+struct fc_auth_req {
+	uint64_t local_wwpn;
+	uint64_t remote_wwpn;
+	union {
+		struct dhchap_challenge_req {
+			uint32_t transaction_id;
+			uint32_t dh_group_id;
+			uint32_t hash_id;
+		} dhchap_challenge;
+		struct dhchap_reply_req {
+			uint32_t transaction_id;
+			uint32_t dh_group_id;
+			uint32_t hash_id;
+			uint32_t bidirectional;
+			uint32_t received_challenge_len;
+			uint32_t received_public_key_len;
+			uint8_t  data[0];
+		} dhchap_reply;
+		struct dhchap_success_req {
+			uint32_t transaction_id;
+			uint32_t dh_group_id;
+			uint32_t hash_id;
+			uint32_t our_challenge_len;
+			uint32_t received_response_len;
+			uint32_t received_public_key_len;
+			uint32_t received_challenge_len;
+			uint8_t  data[0];
+		} dhchap_success;
+	} u;
+} __attribute__ ((packed));
+
+struct fc_auth_rsp {
+	uint64_t local_wwpn;
+	uint64_t remote_wwpn;
+	union {
+		struct authinfo {
+			uint8_t  auth_mode;
+			uint16_t auth_timeout;
+			uint8_t  bidirectional;
+			uint8_t  type_priority[4];
+			uint16_t type_len;
+			uint8_t  hash_priority[4];
+			uint16_t hash_len;
+			uint8_t  dh_group_priority[8];
+			uint16_t dh_group_len;
+			uint32_t reauth_interval;
+		} dhchap_security_config;
+		struct dhchap_challenge_rsp {
+			uint32_t transaction_id;
+			uint32_t our_challenge_len;
+			uint32_t our_public_key_len;
+			uint8_t  data[0];
+		} dhchap_challenge;
+		struct dhchap_reply_rsp {
+			uint32_t transaction_id;
+			uint32_t our_challenge_rsp_len;
+			uint32_t our_public_key_len;
+			uint32_t our_challenge_len;
+			uint8_t  data[0];
+		} dhchap_reply;
+		struct dhchap_success_rsp {
+			uint32_t transaction_id;
+			uint32_t authenticated;
+			uint32_t response_len;
+			uint8_t  data[0];
+		} dhchap_success;
+	} u;
+} __attribute__ ((packed));
+
+int
+lpfc_fc_security_get_config(struct Scsi_Host *shost,
+			struct fc_auth_req *auth_req,
+			u32 req_len,
+			struct fc_auth_rsp *auth_rsp,
+			u32 rsp_len);
+int
+lpfc_fc_security_dhchap_make_challenge(struct Scsi_Host *shost,
+			struct fc_auth_req *auth_req,
+			u32 req_len,
+			struct fc_auth_rsp *auth_rsp,
+			u32 rsp_len);
+int
+lpfc_fc_security_dhchap_make_response(struct Scsi_Host *shost,
+			struct fc_auth_req *auth_req,
+			u32 req_len,
+			struct fc_auth_rsp *auth_rsp,
+			u32 rsp_len);
+int
+lpfc_fc_security_dhchap_authenticate(struct Scsi_Host *shost,
+			struct fc_auth_req *auth_req,
+			u32 req_len,
+			struct fc_auth_rsp *auth_rsp,
+			u32 rsp_len);
+
+int lpfc_fc_queue_security_work(struct lpfc_vport *,
+		struct work_struct *);
+
+/*
+ * FC Transport Message Types
+ */
+	/* user -> kernel */
+#define FC_NL_EVENTS_REG			0x0001
+#define FC_NL_EVENTS_DEREG			0x0002
+#define FC_NL_SC_REG				0x0003
+#define FC_NL_SC_DEREG				0x0004
+#define FC_NL_SC_GET_CONFIG_RSP			0x0005
+#define FC_NL_SC_SET_CONFIG_RSP			0x0006
+#define FC_NL_SC_DHCHAP_MAKE_CHALLENGE_RSP	0x0007
+#define FC_NL_SC_DHCHAP_MAKE_RESPONSE_RSP	0x0008
+#define FC_NL_SC_DHCHAP_AUTHENTICATE_RSP	0x0009
+	/* kernel -> user */
+/* #define FC_NL_ASYNC_EVENT			0x0100 */
+#define FC_NL_SC_GET_CONFIG_REQ			0x0020
+#define FC_NL_SC_SET_CONFIG_REQ			0x0030
+#define FC_NL_SC_DHCHAP_MAKE_CHALLENGE_REQ	0x0040
+#define FC_NL_SC_DHCHAP_MAKE_RESPONSE_REQ	0x0050
+#define FC_NL_SC_DHCHAP_AUTHENTICATE_REQ	0x0060
+
+/*
+ * Message Structures :
+ */
+
+/* macro to round up message lengths to 8byte boundary */
+#define FC_NL_MSGALIGN(len)		(((len) + 7) & ~7)
+
+#define FC_NETLINK_API_VERSION		1
+
+/* Single Netlink Message type to send all FC Transport messages */
+#define FC_TRANSPORT_MSG		(NLMSG_MIN_TYPE + 1)
+
+/* SCSI_TRANSPORT_MSG event message header */
+/*
+struct scsi_nl_hdr {
+	uint8_t version;
+	uint8_t transport;
+	uint16_t magic;
+	uint16_t msgtype;
+	uint16_t msglen;
+} __attribute__((aligned(sizeof(uint64_t))));
+*/
+struct fc_nl_sc_message {
+	uint16_t msgtype;
+	uint16_t rsvd;
+	uint32_t tran_id;
+	uint32_t data_len;
+	uint8_t data[0];
+} __attribute__((aligned(sizeof(uint64_t))));
+
diff -urpN a/drivers/scsi/lpfc/lpfc_auth.c b/drivers/scsi/lpfc/lpfc_auth.c
--- a/drivers/scsi/lpfc/lpfc_auth.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/scsi/lpfc/lpfc_auth.c	2010-01-12 16:46:28.437802000 -0500
@@ -0,0 +1,833 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Copyright (C) 2006-2008 Emulex.  All rights reserved.           *
+ * EMULEX and SLI are trademarks of Emulex.                        *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of version 2 of the GNU General       *
+ * Public License as published by the Free Software Foundation.    *
+ * This program is distributed in the hope that it will be useful. *
+ * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *
+ * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *
+ * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *
+ * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *
+ * TO BE LEGALLY INVALID.  See the GNU General Public License for  *
+ * more details, a copy of which can be found in the file COPYING  *
+ * included with this package.                                     *
+ *******************************************************************/
+/* See Fibre Channel protocol T11 FC-SP for details */
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+
+#include <scsi/scsi.h>
+#include <scsi/scsi_tcq.h>
+#include <scsi/scsi_transport_fc.h>
+
+#include "lpfc_hw4.h"
+#include "lpfc_hw.h"
+#include "lpfc_sli.h"
+#include "lpfc_sli4.h"
+#include "lpfc_nl.h"
+#include "lpfc_disc.h"
+#include "lpfc.h"
+#include "lpfc_crtn.h"
+#include "lpfc_logmsg.h"
+#include "lpfc_auth_access.h"
+#include "lpfc_auth.h"
+
+void
+lpfc_start_authentication(struct lpfc_vport *vport,
+		       struct lpfc_nodelist *ndlp)
+{
+	uint32_t nego_payload_len;
+	uint8_t *nego_payload;
+
+	nego_payload = kmalloc(MAX_AUTH_REQ_SIZE, GFP_KERNEL);
+	if (!nego_payload)
+		return;
+	vport->auth.trans_id++;
+	vport->auth.auth_msg_state = LPFC_AUTH_NEGOTIATE;
+	nego_payload_len = lpfc_build_auth_neg(vport, nego_payload);
+	lpfc_issue_els_auth(vport, ndlp, AUTH_NEGOTIATE,
+			    nego_payload, nego_payload_len);
+	kfree(nego_payload);
+}
+
+void
+lpfc_dhchap_make_challenge(struct Scsi_Host *shost, int status,
+			void *rsp, uint32_t rsp_len)
+{
+	struct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;
+	struct lpfc_nodelist *ndlp;
+	uint32_t chal_payload_len;
+	uint8_t *chal_payload;
+	struct fc_auth_rsp *auth_rsp = rsp;
+
+	ndlp = lpfc_findnode_did(vport, Fabric_DID);
+	if (!ndlp || !NLP_CHK_NODE_ACT(ndlp)) {
+		kfree(rsp);
+		return;
+	}
+
+	lpfc_printf_vlog(vport, KERN_INFO, LOG_SECURITY,
+			 "1003 Send dhchap challenge local_wwpn "
+			 "%llX remote_wwpn %llX \n",
+			 (unsigned long long)auth_rsp->local_wwpn,
+			 (unsigned long long)auth_rsp->remote_wwpn);
+
+	chal_payload = kmalloc(MAX_AUTH_REQ_SIZE, GFP_KERNEL);
+	if (!chal_payload) {
+		kfree(rsp);
+		return;
+	}
+	vport->auth.auth_msg_state = LPFC_DHCHAP_CHALLENGE;
+	chal_payload_len = lpfc_build_dhchap_challenge(vport,
+				chal_payload, rsp);
+	lpfc_issue_els_auth(vport, ndlp, DHCHAP_CHALLENGE,
+			    chal_payload, chal_payload_len);
+	kfree(chal_payload);
+	kfree(rsp);
+}
+
+
+void
+lpfc_dhchap_make_response(struct Scsi_Host *shost, int status,
+			void *rsp, uint32_t rsp_len)
+{
+	struct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;
+	struct lpfc_nodelist *ndlp;
+	uint32_t reply_payload_len;
+	uint8_t *reply_payload;
+	struct fc_auth_rsp *auth_rsp = rsp;
+
+	ndlp = lpfc_findnode_did(vport, Fabric_DID);
+	if (!ndlp || !NLP_CHK_NODE_ACT(ndlp)) {
+		kfree(rsp);
+		return;
+	}
+
+	lpfc_printf_vlog(vport, KERN_INFO, LOG_SECURITY,
+			 "1004 Send dhchap reply local_wwpn "
+			 "%llX remote_wwpn %llX \n",
+			 (unsigned long long)auth_rsp->local_wwpn,
+			 (unsigned long long)auth_rsp->remote_wwpn);
+
+	reply_payload = kmalloc(MAX_AUTH_REQ_SIZE, GFP_KERNEL);
+	if (!reply_payload) {
+		kfree(rsp);
+		return;
+	}
+
+	vport->auth.auth_msg_state = LPFC_DHCHAP_REPLY;
+	reply_payload_len = lpfc_build_dhchap_reply(vport, reply_payload, rsp);
+	lpfc_issue_els_auth(vport, ndlp, DHCHAP_REPLY,
+			    reply_payload, reply_payload_len);
+	kfree(reply_payload);
+	kfree(rsp);
+
+}
+
+
+void
+lpfc_dhchap_authenticate(struct Scsi_Host *shost,
+			int status, void *rsp,
+			uint32_t rsp_len)
+{
+	struct fc_auth_rsp *auth_rsp = (struct fc_auth_rsp *)rsp;
+	struct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;
+	struct lpfc_nodelist *ndlp;
+
+	ndlp = lpfc_findnode_did(vport, Fabric_DID);
+	if (!ndlp || !NLP_CHK_NODE_ACT(ndlp)) {
+		kfree(rsp);
+		return;
+	}
+	if (status != 0) {
+		lpfc_issue_els_auth_reject(vport, ndlp,
+			AUTH_ERR, AUTHENTICATION_FAILED);
+		kfree(rsp);
+		return;
+	}
+
+	if (auth_rsp->u.dhchap_success.authenticated) {
+		uint32_t suc_payload_len;
+		uint8_t *suc_payload;
+
+		suc_payload = kmalloc(MAX_AUTH_REQ_SIZE, GFP_KERNEL);
+		if (!suc_payload) {
+			lpfc_issue_els_auth_reject(vport, ndlp,
+				AUTH_ERR, AUTHENTICATION_FAILED);
+			kfree(rsp);
+			return;
+		}
+		suc_payload_len = lpfc_build_dhchap_success(vport,
+				suc_payload, rsp);
+		if (suc_payload_len == sizeof(uint32_t)) {
+			/* Auth is complete after sending this SUCCESS */
+			vport->auth.auth_msg_state = LPFC_DHCHAP_SUCCESS;
+		} else {
+			/* Need to wait for SUCCESS from Auth Initiator */
+			vport->auth.auth_msg_state = LPFC_DHCHAP_SUCCESS_REPLY;
+		}
+		lpfc_issue_els_auth(vport, ndlp, DHCHAP_SUCCESS,
+				    suc_payload, suc_payload_len);
+		kfree(suc_payload);
+		vport->auth.direction |= AUTH_DIRECTION_LOCAL;
+	} else {
+		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
+				 "1005 AUTHENTICATION_FAILURE Nport:x%x\n",
+				 ndlp->nlp_DID);
+		lpfc_issue_els_auth_reject(vport, ndlp,
+					   AUTH_ERR, AUTHENTICATION_FAILED);
+		if (vport->auth.auth_state == LPFC_AUTH_SUCCESS)
+			lpfc_port_auth_failed(ndlp, LPFC_AUTH_FAIL_AUTH_RJT);
+	}
+
+	kfree(rsp);
+}
+
+int
+lpfc_unpack_auth_negotiate(struct lpfc_vport *vport, uint8_t *message,
+			   uint8_t *reason, uint8_t *explanation)
+{
+	uint32_t prot_len;
+	uint32_t param_len;
+	int i, j = 0;
+
+	/* Following is the format of the message. Name Format.
+	 * uint16_t  nameTag;
+	 * uint16_t  nameLength;
+	 * uint8_t   name[8];
+	 * AUTH_Negotiate Message
+	 * uint32_t  NumberOfAuthProtocals
+	 * uint32_t  AuthProtParameter#1Len
+	 * uint32_t  AuthProtID#1  (DH-CHAP = 0x1)
+	 * AUTH_Negotiate DH-CHAP
+	 * uint16_t  DH-CHAPParameterTag (HashList = 0x1)
+	 * uint16_t  DH-CHAPParameterWordCount (number of uint32_t entries)
+	 * uint8_t   DH-CHAPParameter[]; (uint32_t entries)
+	 * uint16_t  DH-CHAPParameterTag (DHglDList = 0x2)
+	 * uint16_t  DH-CHAPParameterWordCount (number of uint32_t entries)
+	 * uint8_t   DH-CHAPParameter[]; (uint32_t entries)
+	 * DHCHAP_Challenge Message
+	 * uint32_t  hashIdentifier;
+	 * uint32_t  dhgroupIdentifier;
+	 * uint32_t  challengevalueLen;
+	 * uint8_t   challengeValue[];
+	 * uint32_t  dhvalueLen;
+	 * uint8_t   dhvalue[];
+	 */
+
+	/* Name Tag */
+	if (be16_to_cpu(*(uint16_t *)message) != NAME_TAG) {
+		*reason = AUTH_ERR;
+		*explanation = BAD_PAYLOAD;
+		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
+				 "1006 Bad Name tag in auth message 0x%x\n",
+				 be16_to_cpu(*(uint16_t *)message));
+		return 1;
+	}
+	message += sizeof(uint16_t);
+
+	/* Name Length */
+	if (be16_to_cpu(*(uint16_t *)message) != NAME_LEN) {
+		*reason = AUTH_ERR;
+		*explanation = BAD_PAYLOAD;
+		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
+				 "1007 Bad Name length in auth message 0x%x\n",
+				 be16_to_cpu(*(uint16_t *)message));
+		return 1;
+	}
+	message += sizeof(uint16_t);
+
+	/* Skip over Remote Port Name */
+	message += NAME_LEN;
+
+	 /* Number of Auth Protocols must be 1 DH-CHAP */
+	if (be32_to_cpu(*(uint32_t *)message) != 1) {
+		*reason = AUTH_ERR;
+		*explanation = BAD_PAYLOAD;
+		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
+				 "1008 Bad Number of Protocols 0x%x\n",
+				 be32_to_cpu(*(uint32_t *)message));
+		return 1;
+	}
+	message += sizeof(uint32_t);
+
+	/* Protocol Parameter Length */
+	prot_len = be32_to_cpu(*(uint32_t *)message);
+	message += sizeof(uint32_t);
+
+	/* Protocol Parameter type */
+	if (be32_to_cpu(*(uint32_t *)message) != FC_DHCHAP) {
+		*reason = AUTH_ERR;
+		*explanation = BAD_PAYLOAD;
+		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
+				 "1009 Bad param type 0x%x\n",
+				 be32_to_cpu(*(uint32_t *)message));
+		return 1;
+	}
+	message += sizeof(uint32_t);
+
+	/* Parameter #1 Tag */
+	if (be16_to_cpu(*(uint16_t *)message) != HASH_LIST_TAG) {
+		*reason = AUTH_ERR;
+		*explanation = BAD_PAYLOAD;
+		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
+				 "1010 Bad Tag 1 0x%x\n",
+				 be16_to_cpu(*(uint16_t *)message));
+		return 1;
+	}
+	message += sizeof(uint16_t);
+
+	/* Parameter #1 Length */
+	param_len =  be16_to_cpu(*(uint16_t *)message);
+	message += sizeof(uint16_t);
+
+	/* Choose a hash function */
+	for (i = 0; i < vport->auth.hash_len; i++) {
+		for (j = 0; j < param_len; j++) {
+			if (vport->auth.hash_priority[i] ==
+			    be32_to_cpu(((uint32_t *)message)[j]))
+				break;
+		}
+		if (j != param_len)
+			break;
+	}
+	if (i == vport->auth.hash_len && j == param_len) {
+		*reason = AUTH_ERR;
+		*explanation = BAD_PAYLOAD;
+		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
+				 "1011 Auth_neg no hash function chosen.\n");
+		return 1;
+	}
+	vport->auth.hash_id = vport->auth.hash_priority[i];
+	message += sizeof(uint32_t) * param_len;
+
+	/* Parameter #2 Tag */
+	if (be16_to_cpu(*(uint16_t *)message) != DHGID_LIST_TAG) {
+		*reason = AUTH_ERR;
+		*explanation = BAD_PAYLOAD;
+		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
+				 "1012 Auth_negotiate Bad Tag 2 0x%x\n",
+				 be16_to_cpu(*(uint16_t *)message));
+		return 1;
+	}
+	message += sizeof(uint16_t);
+
+	/* Parameter #2 Length */
+	param_len =  be16_to_cpu(*(uint16_t *)message);
+	message += sizeof(uint16_t);
+
+	/* Choose a DH Group */
+	for (i = 0; i < vport->auth.dh_group_len; i++) {
+		for (j = 0; j < param_len; j++) {
+			if (vport->auth.dh_group_priority[i] ==
+			    be32_to_cpu(((uint32_t *)message)[j]))
+				break;
+		}
+		if (j != param_len)
+			break;
+	}
+	if (i == vport->auth.dh_group_len && j == param_len) {
+		*reason = AUTH_ERR;
+		*explanation = BAD_PAYLOAD;
+		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
+				 "1013 Auth_negotiate  no DH_group found. \n");
+		return 1;
+	}
+	vport->auth.group_id = vport->auth.dh_group_priority[i];
+	message += sizeof(uint32_t) * param_len;
+
+	return 0;
+}
+
+int
+lpfc_unpack_dhchap_challenge(struct lpfc_vport *vport, uint8_t *message,
+			     uint8_t *reason, uint8_t *explanation)
+{
+	int i;
+
+	/* Following is the format of the message DHCHAP_Challenge.
+	 * uint16_t  nameTag;
+	 * uint16_t  nameLength;
+	 * uint8_t   name[8];
+	 * uint32_t  hashIdentifier;
+	 * uint32_t  dhgroupIdentifier;
+	 * uint32_t  challengevalueLen;
+	 * uint8_t   challengeValue[];
+	 * uint32_t  dhvalueLen;
+	 * uint8_t   dhvalue[];
+	 */
+
+	/* Name Tag */
+	if (be16_to_cpu(*(uint16_t *)message) != NAME_TAG) {
+		*reason = AUTH_ERR;
+		*explanation = BAD_PAYLOAD;
+		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
+				 "1014 dhchap challenge bad name tag 0x%x. \n",
+				 be16_to_cpu(*(uint16_t *)message));
+		return 1;
+	}
+	message += sizeof(uint16_t);
+
+	/* Name Length */
+	if (be16_to_cpu(*(uint16_t *)message) != NAME_LEN) {
+		*reason = AUTH_ERR;
+		*explanation = BAD_PAYLOAD;
+		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
+				 "1015 dhchap challenge bad name length "
+				 "0x%x.\n", be16_to_cpu(*(uint16_t *)message));
+		return 1;
+	}
+	message += sizeof(uint16_t);
+
+	/* Remote Port Name */
+	message += NAME_LEN;
+
+	/* Hash ID */
+	vport->auth.hash_id = be32_to_cpu(*(uint32_t *)message);  /* Hash id */
+	for (i = 0; i < vport->auth.hash_len; i++) {
+		if (vport->auth.hash_id == vport->auth.hash_priority[i])
+			break;
+	}
+	if (i == vport->auth.hash_len) {
+		*reason = LOGIC_ERR;
+		*explanation = BAD_ALGORITHM;
+		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
+				 "1016 dhchap challenge Hash ID not Supported "
+				 "0x%x. \n", vport->auth.hash_id);
+		return 1;
+	}
+	message += sizeof(uint32_t);
+
+	vport->auth.group_id =
+		be32_to_cpu(*(uint32_t *)message);  /* DH group id */
+	for (i = 0; i < vport->auth.dh_group_len; i++) {
+		if (vport->auth.group_id == vport->auth.dh_group_priority[i])
+			break;
+	}
+	if (i == vport->auth.dh_group_len) {
+		*reason = LOGIC_ERR;
+		*explanation = BAD_DHGROUP;
+		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
+				 "1017 dhchap challenge could not find DH "
+				 "Group. \n");
+		return 1;
+	}
+	message += sizeof(uint32_t);
+
+	vport->auth.challenge_len =
+		be32_to_cpu(*(uint32_t *)message);  /* Challenge Len */
+	message += sizeof(uint32_t);
+
+	/* copy challenge to vport */
+	if (vport->auth.challenge != NULL)
+		kfree(vport->auth.challenge);
+	vport->auth.challenge = kmalloc(vport->auth.challenge_len, GFP_KERNEL);
+	if (!vport->auth.challenge) {
+		*reason = AUTH_ERR;
+		return 1;
+	}
+	memcpy(vport->auth.challenge, message, vport->auth.challenge_len);
+	message += vport->auth.challenge_len;
+
+	vport->auth.dh_pub_key_len =
+		be32_to_cpu(*(uint32_t *)message);  /* DH Value Len */
+	message += sizeof(uint32_t);
+
+	if (vport->auth.dh_pub_key_len != 0) {
+		if (vport->auth.group_id == DH_GROUP_NULL) {
+			*reason = LOGIC_ERR;
+			*explanation = BAD_DHGROUP;
+			lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
+					 "1018 dhchap challenge No Public key "
+					 "for non-NULL DH Group.\n");
+			return 1;
+		}
+
+		/* Copy to the vport to save for authentication */
+		if (vport->auth.dh_pub_key != NULL)
+			kfree(vport->auth.dh_pub_key);
+		vport->auth.dh_pub_key = kmalloc(vport->auth.dh_pub_key_len,
+				GFP_KERNEL);
+		if (!vport->auth.dh_pub_key) {
+			*reason = AUTH_ERR;
+			return 1;
+		}
+		memcpy(vport->auth.dh_pub_key, message,
+			vport->auth.dh_pub_key_len);
+	}
+	return 0;
+}
+
+int
+lpfc_unpack_dhchap_reply(struct lpfc_vport *vport, uint8_t *message,
+			 struct fc_auth_req *fc_req)
+{
+	uint32_t rsp_len;
+	uint32_t dh_len;
+	uint32_t challenge_len;
+
+	/* Following is the format of the message DHCHAP_Reply.
+	 * uint32_t	Response Value Length;
+	 * uint8_t	Response Value[];
+	 * uint32_t	DH Value Length;
+	 * uint8_t	DH Value[];
+	 * uint32_t	Challenge Value Length;
+	 * uint8_t	Challenge Value[];
+	 */
+
+	rsp_len = be32_to_cpu(*(uint32_t *)message);   /* Response Len */
+	message += sizeof(uint32_t);
+	memcpy(fc_req->u.dhchap_success.data + vport->auth.challenge_len,
+	       message, rsp_len);
+	fc_req->u.dhchap_success.received_response_len = rsp_len;
+	message += rsp_len;
+
+	dh_len = be32_to_cpu(*(uint32_t *)message);   /* DH Len */
+	message += sizeof(uint32_t);
+	memcpy(fc_req->u.dhchap_success.data + vport->auth.challenge_len +
+	       rsp_len, message, dh_len);
+	fc_req->u.dhchap_success.received_public_key_len = dh_len;
+	message += dh_len;
+
+	challenge_len = be32_to_cpu(*(uint32_t *)message);   /* Challenge Len */
+	message += sizeof(uint32_t);
+	memcpy(fc_req->u.dhchap_success.data + vport->auth.challenge_len
+	       + rsp_len + dh_len, message, challenge_len);
+	fc_req->u.dhchap_success.received_challenge_len = challenge_len;
+	message += challenge_len;
+
+	return rsp_len + dh_len + challenge_len;
+}
+
+int
+lpfc_unpack_dhchap_success(struct lpfc_vport *vport, uint8_t *message,
+			   struct fc_auth_req *fc_req)
+{
+	uint32_t rsp_len = 0;
+
+	/* DHCHAP_Success.
+	 * uint32_t  responseValueLen;
+	 * uint8_t   response[];
+	 */
+
+	rsp_len = be32_to_cpu(*(uint32_t *)message);   /* Response Len */
+	message += sizeof(uint32_t);
+	memcpy(fc_req->u.dhchap_success.data + vport->auth.challenge_len,
+	       message, rsp_len);
+	fc_req->u.dhchap_success.received_response_len = rsp_len;
+
+	memcpy(fc_req->u.dhchap_success.data +
+		vport->auth.challenge_len + rsp_len,
+		vport->auth.dh_pub_key, vport->auth.dh_pub_key_len);
+
+	fc_req->u.dhchap_success.received_public_key_len =
+		vport->auth.dh_pub_key_len;
+
+	fc_req->u.dhchap_success.received_challenge_len = 0;
+
+	return vport->auth.challenge_len + rsp_len + vport->auth.dh_pub_key_len;
+}
+
+int
+lpfc_build_auth_neg(struct lpfc_vport *vport, uint8_t *message)
+{
+	uint8_t *message_start = message;
+	uint8_t *params_start;
+	uint32_t *params_len;
+	uint32_t len;
+	int i;
+
+	/* Because some of the fields are not static in length
+	 * and number we will pack on the fly.This will be expanded
+	 * in the future to optionally offer DHCHAP or FCAP or both.
+	 * The packing is done in Big Endian byte order DHCHAP_Reply.
+	 *
+	 * uint16_t nameTag;
+	 * uint16_t nameLength;
+	 * uint8_t  name[8];
+	 * uint32_t available;		For now we will only offer one
+					protocol ( DHCHAP ) for authentication.
+	 * uint32_t potocolParamsLenId#1;
+	 * uint32_t protocolId#1;	1 : DHCHAP. The protocol list is
+	 *					in order of preference.
+	 * uint16_t parameter#1Tag	1 : HashList
+	 * uint16_t parameter#1Len	2 : Count of how many parameter values
+	 *                                  follow in order of preference.
+	 * uint16_t parameter#1value#1	5 : MD5 Hash Function
+	 * uint16_t parameter#1value#2	6 : SHA-1 Hash Function
+	 * uint16_t parameter#2Tag		2 : DHglDList
+	 * uint16_t parameter#2Len		1 : Only One is supported now
+	 * uint16_t parameter#2value#1	0 : NULL DH-CHAP Algorithm
+	 * uint16_t parameter#2value#2 ...
+	 * uint32_t protocolParamsLenId#2;
+	 * uint32_t protocolId#2;         2 = FCAP
+	 * uint16_t parameter#1Tag
+	 * uint16_t parameter#1Len
+	 * uint16_t parameter#1value#1
+	 * uint16_t parameter#1value#2 ...
+	 * uint16_t parameter#2Tag
+	 * uint16_t parameter#2Len
+	 * uint16_t parameter#2value#1
+	 * uint16_t parameter#2value#2 ...
+	 */
+
+
+	/* Name Tag */
+	*((uint16_t *)message) = cpu_to_be16(NAME_TAG);
+	message += sizeof(uint16_t);
+
+	/* Name Len */
+	*((uint16_t *)message) = cpu_to_be16(NAME_LEN);
+	message += sizeof(uint16_t);
+
+	memcpy(message, vport->fc_portname.u.wwn, sizeof(uint64_t));
+
+	message += sizeof(uint64_t);
+
+	/* Protocols Available */
+	*((uint32_t *)message) = cpu_to_be32(PROTS_NUM);
+	message += sizeof(uint32_t);
+
+	/* First Protocol Params Len */
+	params_len = (uint32_t *)message;
+	message += sizeof(uint32_t);
+
+	/* Start of first Param */
+	params_start = message;
+
+	 /* Protocol Id */
+	*((uint32_t *)message) = cpu_to_be32(FC_DHCHAP);
+	message += sizeof(uint32_t);
+
+	/* Hash List Tag */
+	*((uint16_t *)message) = cpu_to_be16(HASH_LIST_TAG);
+	message += sizeof(uint16_t);
+
+	/* Hash Value Len */
+	*((uint16_t *)message) = cpu_to_be16(vport->auth.hash_len);
+	message += sizeof(uint16_t);
+
+	/* Hash Value each 4 byte words */
+	for (i = 0; i < vport->auth.hash_len; i++) {
+		*((uint32_t *)message) =
+			cpu_to_be32(vport->auth.hash_priority[i]);
+		message += sizeof(uint32_t);
+	}
+
+	/* DHgIDList Tag */
+	*((uint16_t *)message) = cpu_to_be16(DHGID_LIST_TAG);
+	message += sizeof(uint16_t);
+
+	/* DHgIDListValue Len */
+	*((uint16_t *)message) = cpu_to_be16(vport->auth.dh_group_len);
+
+	message += sizeof(uint16_t);
+
+	/* DHgIDList each 4 byte words */
+
+	for (i = 0; i < vport->auth.dh_group_len; i++) {
+		*((uint32_t *)message) =
+			cpu_to_be32(vport->auth.dh_group_priority[i]);
+		message += sizeof(uint32_t);
+	}
+
+	*params_len = cpu_to_be32(message - params_start);
+
+	len = (uint32_t)(message - message_start);
+
+	return len;
+}
+
+int
+lpfc_build_dhchap_challenge(struct lpfc_vport *vport, uint8_t *message,
+			    struct fc_auth_rsp *fc_rsp)
+{
+	uint8_t *message_start = message;
+
+	/* Because some of the fields are not static in length and number
+	 * we will pack on the fly. The packing is done in Big Endian byte
+	 * order DHCHAP_Challenge.
+	 *
+	 * uint16_t  nameTag;
+	 * uint16_t  nameLength;
+	 * uint8_t   name[8];
+	 * uint32_t  Hash_Identifier;
+	 * uint32_t  DH_Group_Identifier;
+	 * uint32_t  Challenge_Value_Length;
+	 * uint8_t   Challenge_Value[];
+	 * uint32_t  DH_Value_Length;
+	 * uint8_t   DH_Value[];
+	 */
+
+	/* Name Tag */
+	*((uint16_t *)message) = cpu_to_be16(NAME_TAG);
+	message += sizeof(uint16_t);
+
+	/* Name Len */
+	*((uint16_t *)message) = cpu_to_be16(NAME_LEN);
+	message += sizeof(uint16_t);
+
+	memcpy(message, vport->fc_portname.u.wwn, NAME_LEN);
+	message += NAME_LEN;
+
+	/* Hash Value each 4 byte words */
+	*((uint32_t *)message) = cpu_to_be32(vport->auth.hash_id);
+	message += sizeof(uint32_t);
+
+	/* DH group id each 4 byte words */
+	*((uint32_t *)message) = cpu_to_be32(vport->auth.group_id);
+	message += sizeof(uint32_t);
+
+	/* Challenge Length */
+	*((uint32_t *)message) = cpu_to_be32(fc_rsp->u.
+		dhchap_challenge.our_challenge_len);
+	message += sizeof(uint32_t);
+
+	/* copy challenge to vport to save */
+	kfree(vport->auth.challenge);
+	vport->auth.challenge_len = fc_rsp->u.
+		dhchap_challenge.our_challenge_len;
+	vport->auth.challenge = kmalloc(vport->auth.challenge_len, GFP_KERNEL);
+
+	if (!vport->auth.challenge)
+		return 0;
+
+	memcpy(vport->auth.challenge, fc_rsp->u.dhchap_challenge.data,
+	       fc_rsp->u.dhchap_challenge.our_challenge_len);
+
+	/* Challenge */
+	memcpy(message, fc_rsp->u.dhchap_challenge.data,
+	       fc_rsp->u.dhchap_challenge.our_challenge_len);
+	message += fc_rsp->u.dhchap_challenge.our_challenge_len;
+
+	/* Public Key length */
+	*((uint32_t *)message) = cpu_to_be32(fc_rsp->u.
+		dhchap_challenge.our_public_key_len);
+	message += sizeof(uint32_t);
+
+	/* Public Key */
+	memcpy(message, fc_rsp->u.dhchap_challenge.data +
+	       fc_rsp->u.dhchap_challenge.our_challenge_len,
+	       fc_rsp->u.dhchap_challenge.our_public_key_len);
+	message += fc_rsp->u.dhchap_challenge.our_public_key_len;
+
+	return (uint32_t)(message - message_start);
+
+}
+
+int
+lpfc_build_dhchap_reply(struct lpfc_vport *vport, uint8_t *message,
+				struct fc_auth_rsp *fc_rsp)
+
+{
+	uint8_t *message_start = message;
+
+	/*
+	 * Because some of the fields are not static in length and
+	 * number we will pack on the fly. The packing is done in
+	 * Big Endian byte order DHCHAP_Reply.
+	 *
+	 * uint32_t  ResonseLength;
+	 * uint8_t   ResponseValue[];
+	 * uint32_t  DHLength;
+	 * uint8_t   DHValue[];          Our Public key
+	 * uint32_t  ChallengeLength;    Used for bi-directional authentication
+	 * uint8_t   ChallengeValue[];
+	 *
+	 * The combined key ( g^x mod p )^y mod p is used as the last
+	 * hash of the password.
+	 *
+	 * g is the base 2 or 5.
+	 * y is our private key.
+	 * ( g^y mod p ) is our public key which we send.
+	 * ( g^x mod p ) is their public key which we received.
+	 */
+	/* Response Value Length */
+	*((uint32_t *)message) = cpu_to_be32(fc_rsp->u.dhchap_reply.
+		our_challenge_rsp_len);
+
+	message += sizeof(uint32_t);
+	/* Response Value */
+	memcpy(message, fc_rsp->u.dhchap_reply.data,
+		fc_rsp->u.dhchap_reply.our_challenge_rsp_len);
+
+	message += fc_rsp->u.dhchap_reply.our_challenge_rsp_len;
+	/* DH Value Length */
+	*((uint32_t *)message) = cpu_to_be32(fc_rsp->u.dhchap_reply.
+			our_public_key_len);
+
+	message += sizeof(uint32_t);
+	/* DH Value */
+	memcpy(message, fc_rsp->u.dhchap_reply.data +
+				fc_rsp->u.dhchap_reply.our_challenge_rsp_len,
+				fc_rsp->u.dhchap_reply.our_public_key_len);
+
+	message += fc_rsp->u.dhchap_reply.our_public_key_len;
+
+	if (vport->auth.bidirectional) {
+
+		/* copy to vport to save */
+		kfree(vport->auth.challenge);
+		vport->auth.challenge_len = fc_rsp->u.dhchap_reply.
+			our_challenge_len;
+		vport->auth.challenge = kmalloc(vport->auth.challenge_len,
+			GFP_KERNEL);
+		if (!vport->auth.challenge)
+			return 0;
+
+		memcpy(vport->auth.challenge, fc_rsp->u.dhchap_reply.data +
+		       fc_rsp->u.dhchap_reply.our_challenge_rsp_len +
+		       fc_rsp->u.dhchap_reply.our_public_key_len,
+		       fc_rsp->u.dhchap_reply.our_challenge_len);
+		/* Challenge Value Length */
+		*((uint32_t *)message) = cpu_to_be32(fc_rsp->u.
+			dhchap_reply.our_challenge_len);
+		message += sizeof(uint32_t);
+		/* Challenge Value */
+		memcpy(message, fc_rsp->u.dhchap_reply.data +
+			fc_rsp->u.dhchap_reply.our_challenge_rsp_len +
+			fc_rsp->u.dhchap_reply.our_public_key_len,
+			fc_rsp->u.dhchap_reply.our_challenge_len);
+
+		message += fc_rsp->u.dhchap_reply.our_challenge_len;
+
+	} else {
+		*((uint32_t *)message) = 0;      /* Challenge Len for No
+						bidirectional authentication */
+		message += sizeof(uint32_t); /* Challenge Value Not Present */
+	}
+
+	return (uint32_t)(message - message_start);
+
+}
+
+int
+lpfc_build_dhchap_success(struct lpfc_vport *vport, uint8_t *message,
+			  struct fc_auth_rsp *fc_rsp)
+{
+	uint8_t *message_start = message;
+
+	/*
+	 * Because some of the fields are not static in length and number
+	 * we will pack on the fly. The packing is done in Big Endian byte
+	 * order DHCHAP_Success.
+	 * uint32_t  responseValueLen;
+	 * uint8_t   response[];.
+	 */
+
+	*((uint32_t *)message) = cpu_to_be32(fc_rsp->u.
+			dhchap_success.response_len);
+	message += sizeof(uint32_t);
+
+	memcpy(message, fc_rsp->u.dhchap_success.data,
+	       fc_rsp->u.dhchap_success.response_len);
+	message += fc_rsp->u.dhchap_success.response_len;
+
+	return (uint32_t)(message - message_start);
+}
+
diff -urpN a/drivers/scsi/lpfc/lpfc_auth.h b/drivers/scsi/lpfc/lpfc_auth.h
--- a/drivers/scsi/lpfc/lpfc_auth.h	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/scsi/lpfc/lpfc_auth.h	2010-01-12 16:46:28.443798000 -0500
@@ -0,0 +1,92 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Copyright (C) 2006-2007 Emulex.  All rights reserved.           *
+ * EMULEX and SLI are trademarks of Emulex.                        *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of version 2 of the GNU General       *
+ * Public License as published by the Free Software Foundation.    *
+ * This program is distributed in the hope that it will be useful. *
+ * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *
+ * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *
+ * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *
+ * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *
+ * TO BE LEGALLY INVALID.  See the GNU General Public License for  *
+ * more details, a copy of which can be found in the file COPYING  *
+ * included with this package.                                     *
+ *******************************************************************/
+
+#define N_DH_GROUP            4
+#define ELS_CMD_AUTH_BYTE     0x90
+
+#define AUTH_REJECT           0xA
+#define AUTH_NEGOTIATE        0xB
+#define AUTH_DONE             0xC
+
+#define DHCHAP_CHALLENGE 0x10
+#define DHCHAP_REPLY     0x11
+#define DHCHAP_SUCCESS   0x12
+
+#define FCAP_REQUEST	0x13
+#define FCAP_ACK        0x14
+#define FCAP_CONFIRM    0x15
+
+#define PROTS_NUM	0x01
+
+#define NAME_TAG	0x01
+#define NAME_LEN	0x08
+
+#define HASH_LIST_TAG   0x01
+
+#define DHGID_LIST_TAG  0x02
+
+#define HBA_SECURITY       0x20
+
+#define AUTH_ERR                 0x1
+#define LOGIC_ERR                0x2
+
+#define BAD_DHGROUP              0x2
+#define BAD_ALGORITHM            0x3
+#define AUTHENTICATION_FAILED    0x5
+#define BAD_PAYLOAD              0x6
+#define BAD_PROTOCOL             0x7
+#define RESTART		         0x8
+
+#define AUTH_VERSION	0x1
+
+#define MAX_AUTH_MESSAGE_SIZE 1024
+
+struct lpfc_auth_reject {
+   uint8_t reason;
+   uint8_t explanation;
+   uint8_t reserved[2];
+}  __attribute__ ((packed));
+
+struct lpfc_auth_message {		/* Structure is in Big Endian format */
+	uint8_t command_code;
+	uint8_t flags;
+	uint8_t message_code;
+	uint8_t protocol_ver;
+	uint32_t message_len;
+	uint32_t trans_id;
+	uint8_t data[0];
+}  __attribute__ ((packed));
+
+int lpfc_build_auth_neg(struct lpfc_vport *vport, uint8_t *message);
+int lpfc_build_dhchap_challenge(struct lpfc_vport *vport, uint8_t *message,
+				struct fc_auth_rsp *fc_rsp);
+int lpfc_build_dhchap_reply(struct lpfc_vport *vport, uint8_t *message,
+			    struct fc_auth_rsp *fc_rsp);
+int lpfc_build_dhchap_success(struct lpfc_vport *vport, uint8_t *message,
+			      struct fc_auth_rsp *fc_rsp);
+
+int lpfc_unpack_auth_negotiate(struct lpfc_vport *vport, uint8_t *message,
+				 uint8_t *reason, uint8_t *explanation);
+int lpfc_unpack_dhchap_challenge(struct lpfc_vport *vport, uint8_t *message,
+				 uint8_t *reason, uint8_t *explanation);
+int lpfc_unpack_dhchap_reply(struct lpfc_vport *vport, uint8_t *message,
+			     struct fc_auth_req *fc_req);
+int lpfc_unpack_dhchap_success(struct lpfc_vport *vport, uint8_t *message,
+			       struct fc_auth_req *fc_req);
diff -urpN a/drivers/scsi/lpfc/lpfc_crtn.h b/drivers/scsi/lpfc/lpfc_crtn.h
--- a/drivers/scsi/lpfc/lpfc_crtn.h	2010-01-12 16:47:00.995078000 -0500
+++ b/drivers/scsi/lpfc/lpfc_crtn.h	2010-01-12 16:46:28.450798000 -0500
@@ -21,6 +21,12 @@
 typedef int (*node_filter)(struct lpfc_nodelist *, void *);
 
 struct fc_rport;
+int lpfc_issue_els_auth(struct lpfc_vport *, struct lpfc_nodelist *,
+			uint8_t message_code, uint8_t *payload,
+			uint32_t payload_len);
+int lpfc_issue_els_auth_reject(struct lpfc_vport *vport,
+			       struct lpfc_nodelist *ndlp,
+			       uint8_t reason, uint8_t explanation);
 void lpfc_down_link(struct lpfc_hba *, LPFC_MBOXQ_t *);
 void lpfc_sli_read_link_ste(struct lpfc_hba *);
 void lpfc_dump_mem(struct lpfc_hba *, LPFC_MBOXQ_t *, uint16_t, uint16_t);
@@ -44,6 +50,8 @@ int lpfc_reg_rpi(struct lpfc_hba *, uint
 void lpfc_unreg_login(struct lpfc_hba *, uint16_t, uint32_t, LPFC_MBOXQ_t *);
 void lpfc_unreg_did(struct lpfc_hba *, uint16_t, uint32_t, LPFC_MBOXQ_t *);
 void lpfc_reg_vpi(struct lpfc_vport *, LPFC_MBOXQ_t *);
+void lpfc_register_new_vport(struct lpfc_hba *, struct lpfc_vport *,
+			struct lpfc_nodelist *);
 void lpfc_unreg_vpi(struct lpfc_hba *, uint16_t, LPFC_MBOXQ_t *);
 void lpfc_init_link(struct lpfc_hba *, LPFC_MBOXQ_t *, uint32_t, uint32_t);
 void lpfc_request_features(struct lpfc_hba *, struct lpfcMboxq *);
@@ -52,10 +60,13 @@ struct lpfc_vport *lpfc_find_vport_by_di
 void lpfc_cleanup_rcv_buffers(struct lpfc_vport *);
 void lpfc_rcv_seq_check_edtov(struct lpfc_vport *);
 void lpfc_cleanup_rpis(struct lpfc_vport *, int);
+void lpfc_cleanup_pending_mbox(struct lpfc_vport *);
 int lpfc_linkdown(struct lpfc_hba *);
 void lpfc_linkdown_port(struct lpfc_vport *);
 void lpfc_port_link_failure(struct lpfc_vport *);
 void lpfc_mbx_cmpl_read_la(struct lpfc_hba *, LPFC_MBOXQ_t *);
+void lpfc_init_vpi_cmpl(struct lpfc_hba *, LPFC_MBOXQ_t *);
+void lpfc_retry_pport_discovery(struct lpfc_hba *);
 
 void lpfc_mbx_cmpl_reg_login(struct lpfc_hba *, LPFC_MBOXQ_t *);
 void lpfc_mbx_cmpl_dflt_rpi(struct lpfc_hba *, LPFC_MBOXQ_t *);
@@ -90,7 +101,9 @@ void lpfc_cleanup(struct lpfc_vport *);
 void lpfc_disc_timeout(unsigned long);
 
 struct lpfc_nodelist *__lpfc_findnode_rpi(struct lpfc_vport *, uint16_t);
-
+struct lpfc_nodelist *lpfc_findnode_wwnn(struct lpfc_vport *,
+					 struct lpfc_name *);
+void lpfc_port_auth_failed(struct lpfc_nodelist *, enum auth_state);
 void lpfc_worker_wake_up(struct lpfc_hba *);
 int lpfc_workq_post_event(struct lpfc_hba *, void *, void *, uint32_t);
 int lpfc_do_work(void *);
@@ -128,6 +141,8 @@ int lpfc_els_rsp_prli_acc(struct lpfc_vp
 void lpfc_cancel_retry_delay_tmo(struct lpfc_vport *, struct lpfc_nodelist *);
 void lpfc_els_retry_delay(unsigned long);
 void lpfc_els_retry_delay_handler(struct lpfc_nodelist *);
+void lpfc_reauth_node(unsigned long);
+void lpfc_reauthentication_handler(struct lpfc_nodelist *);
 void lpfc_els_unsol_event(struct lpfc_hba *, struct lpfc_sli_ring *,
 			  struct lpfc_iocbq *);
 int lpfc_els_handle_rscn(struct lpfc_vport *);
@@ -327,6 +342,29 @@ void destroy_port(struct lpfc_vport *);
 int lpfc_get_instance(void);
 void lpfc_host_attrib_init(struct Scsi_Host *);
 
+extern struct workqueue_struct *security_work_q;
+extern struct list_head fc_security_user_list;
+extern int fc_service_state;
+void lpfc_fc_sc_security_online(struct work_struct *work);
+void lpfc_fc_sc_security_offline(struct work_struct *work);
+int lpfc_fc_queue_security_work(struct lpfc_vport *, struct work_struct *);
+void lpfc_rcv_nl_event(struct notifier_block *, unsigned long , void *);
+int lpfc_selective_reset(struct lpfc_hba *);
+int lpfc_security_wait(struct lpfc_vport *);
+int  lpfc_get_security_enabled(struct Scsi_Host *);
+void lpfc_security_service_online(struct Scsi_Host *);
+void lpfc_security_service_offline(struct Scsi_Host *);
+void lpfc_security_config(struct Scsi_Host *, int status, void *);
+int lpfc_security_config_wait(struct lpfc_vport *vport);
+void lpfc_dhchap_make_challenge(struct Scsi_Host *, int , void *, uint32_t);
+void lpfc_dhchap_make_response(struct Scsi_Host *, int , void *, uint32_t);
+void lpfc_dhchap_authenticate(struct Scsi_Host *, int , void *, uint32_t);
+int lpfc_start_node_authentication(struct lpfc_nodelist *);
+int lpfc_get_auth_config(struct lpfc_vport *, struct lpfc_nodelist *);
+void lpfc_start_discovery(struct lpfc_vport *vport);
+void lpfc_start_authentication(struct lpfc_vport *, struct lpfc_nodelist *);
+int lpfc_rcv_nl_msg(struct Scsi_Host *, void *, uint32_t, uint32_t);
+
 extern void lpfc_debugfs_initialize(struct lpfc_vport *);
 extern void lpfc_debugfs_terminate(struct lpfc_vport *);
 extern void lpfc_debugfs_disc_trc(struct lpfc_vport *, int, char *, uint32_t,
@@ -335,6 +373,10 @@ extern void lpfc_debugfs_slow_ring_trc(s
 	uint32_t, uint32_t);
 extern struct lpfc_hbq_init *lpfc_hbq_defs[];
 
+extern spinlock_t fc_security_user_lock;
+extern struct list_head fc_security_user_list;
+extern int fc_service_state;
+
 /* externs BlockGuard */
 extern char *_dump_buf_data;
 extern unsigned long _dump_buf_data_order;
diff -urpN a/drivers/scsi/lpfc/lpfc_disc.h b/drivers/scsi/lpfc/lpfc_disc.h
--- a/drivers/scsi/lpfc/lpfc_disc.h	2010-01-12 16:47:01.021081000 -0500
+++ b/drivers/scsi/lpfc/lpfc_disc.h	2010-01-12 16:46:28.456800000 -0500
@@ -37,6 +37,7 @@ enum lpfc_work_type {
 	LPFC_EVT_KILL,
 	LPFC_EVT_ELS_RETRY,
 	LPFC_EVT_DEV_LOSS,
+	LPFC_EVT_REAUTH,
 	LPFC_EVT_FASTPATH_MGMT_EVT,
 };
 
@@ -99,14 +100,14 @@ struct lpfc_nodelist {
 #define NLP_USG_FREE_ACK_BIT	0x8	/* Indicate ndlp memory free invoked */
 
 	struct timer_list   nlp_delayfunc;	/* Used for delayed ELS cmds */
+	struct timer_list   nlp_reauth_tmr;	/* Used for re-authentication */
 	struct lpfc_hba *phba;
 	struct fc_rport *rport;			/* Corresponding FC transport
 						   port structure */
 	struct lpfc_vport *vport;
 	struct lpfc_work_evt els_retry_evt;
+	struct lpfc_work_evt els_reauth_evt;
 	struct lpfc_work_evt dev_loss_evt;
-	unsigned long last_ramp_up_time;        /* jiffy of last ramp up */
-	unsigned long last_q_full_time;		/* jiffy of last queue full */
 	struct kref     kref;
 	atomic_t cmd_pending;
 	uint32_t cmd_qdepth;
diff -urpN a/drivers/scsi/lpfc/lpfc_els.c b/drivers/scsi/lpfc/lpfc_els.c
--- a/drivers/scsi/lpfc/lpfc_els.c	2010-01-12 16:47:01.044080000 -0500
+++ b/drivers/scsi/lpfc/lpfc_els.c	2010-01-12 16:46:28.487798000 -0500
@@ -40,6 +40,9 @@
 #include "lpfc_crtn.h"
 #include "lpfc_vport.h"
 #include "lpfc_debugfs.h"
+#include "lpfc_auth_access.h"
+#include "lpfc_auth.h"
+#include "lpfc_security.h"
 
 static int lpfc_els_retry(struct lpfc_hba *, struct lpfc_iocbq *,
 			  struct lpfc_iocbq *);
@@ -50,9 +53,6 @@ static int lpfc_issue_els_fdisc(struct l
 				struct lpfc_nodelist *ndlp, uint8_t retry);
 static int lpfc_issue_fabric_iocb(struct lpfc_hba *phba,
 				  struct lpfc_iocbq *iocb);
-static void lpfc_register_new_vport(struct lpfc_hba *phba,
-				    struct lpfc_vport *vport,
-				    struct lpfc_nodelist *ndlp);
 
 static int lpfc_max_els_tries = 3;
 
@@ -177,9 +177,22 @@ lpfc_prep_els_iocb(struct lpfc_vport *vp
 		((elscmd == ELS_CMD_FLOGI) ||
 		 (elscmd == ELS_CMD_FDISC) ||
 		 (elscmd == ELS_CMD_LOGO)))
-		elsiocb->iocb_flag |= LPFC_FIP_ELS;
+		switch (elscmd) {
+		case ELS_CMD_FLOGI:
+		elsiocb->iocb_flag |= ((ELS_ID_FLOGI << LPFC_FIP_ELS_ID_SHIFT)
+					& LPFC_FIP_ELS_ID_MASK);
+		break;
+		case ELS_CMD_FDISC:
+		elsiocb->iocb_flag |= ((ELS_ID_FDISC << LPFC_FIP_ELS_ID_SHIFT)
+					& LPFC_FIP_ELS_ID_MASK);
+		break;
+		case ELS_CMD_LOGO:
+		elsiocb->iocb_flag |= ((ELS_ID_LOGO << LPFC_FIP_ELS_ID_SHIFT)
+					& LPFC_FIP_ELS_ID_MASK);
+		break;
+		}
 	else
-		elsiocb->iocb_flag &= ~LPFC_FIP_ELS;
+		elsiocb->iocb_flag &= ~LPFC_FIP_ELS_ID_MASK;
 
 	icmd = &elsiocb->iocb;
 
@@ -591,10 +604,16 @@ lpfc_cmpl_els_flogi_fabric(struct lpfc_v
 	} else {
 		ndlp->nlp_type |= NLP_FABRIC;
 		lpfc_nlp_set_state(vport, ndlp, NLP_STE_UNMAPPED_NODE);
-		if (vport->vfi_state & LPFC_VFI_REGISTERED) {
-			lpfc_start_fdiscs(phba);
-			lpfc_do_scr_ns_plogi(phba, vport);
-		} else
+		if ((!(vport->fc_flag & FC_VPORT_NEEDS_REG_VPI)) &&
+			(vport->vpi_state & LPFC_VPI_REGISTERED)) {
+			if (vport->cfg_enable_auth) {
+				if (lpfc_get_auth_config(vport, NULL))
+					return 1;
+			} else
+				lpfc_start_discovery(vport);
+		} else if (vport->fc_flag & FC_VFI_REGISTERED)
+			lpfc_register_new_vport(phba, vport, ndlp);
+		else
 			lpfc_issue_reg_vfi(vport);
 	}
 	return 0;
@@ -791,6 +810,9 @@ lpfc_cmpl_els_flogi(struct lpfc_hba *phb
 				 irsp->ulpTimeout);
 		goto flogifail;
 	}
+	spin_lock_irq(shost->host_lock);
+	vport->fc_flag &= ~FC_VPORT_CVL_RCVD;
+	spin_unlock_irq(shost->host_lock);
 
 	/*
 	 * The FLogI succeeded.  Sync the data for the CPU before
@@ -799,7 +821,10 @@ lpfc_cmpl_els_flogi(struct lpfc_hba *phb
 	prsp = list_get_first(&pcmd->list, struct lpfc_dmabuf, list);
 
 	sp = prsp->virt + sizeof(uint32_t);
-
+	if (sp->cmn.security)
+		ndlp->nlp_flag |= NLP_SC_REQ;
+	else
+		ndlp->nlp_flag &= ~NLP_SC_REQ;
 	/* FLOGI completes successfully */
 	lpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,
 			 "0101 FLOGI completes sucessfully "
@@ -807,6 +832,16 @@ lpfc_cmpl_els_flogi(struct lpfc_hba *phb
 			 irsp->un.ulpWord[4], sp->cmn.e_d_tov,
 			 sp->cmn.w2.r_a_tov, sp->cmn.edtovResolution);
 
+	if (!vport->cfg_enable_auth) {
+		vport->auth.security_active = 0;
+		if (sp->cmn.security) {
+			lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
+					 "1055 Authentication parameter is "
+					 "disabled, but is required by "
+					 "the fabric.\n");
+			goto flogifail;
+		}
+	}
 	if (vport->port_state == LPFC_FLOGI) {
 		/*
 		 * If Common Service Parameters indicate Nport
@@ -896,6 +931,10 @@ lpfc_issue_els_flogi(struct lpfc_vport *
 	sp = (struct serv_parm *) pcmd;
 
 	/* Setup CSPs accordingly for Fabric */
+
+	if (vport->cfg_enable_auth)
+		sp->cmn.security = 1;
+
 	sp->cmn.e_d_tov = 0;
 	sp->cmn.w2.r_a_tov = 0;
 	sp->cls1.classValid = 0;
@@ -1015,6 +1054,15 @@ lpfc_initial_flogi(struct lpfc_vport *vp
 	struct lpfc_hba *phba = vport->phba;
 	struct lpfc_nodelist *ndlp;
 
+	if (vport->cfg_enable_auth && lpfc_security_wait(vport)) {
+		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
+				 "2725 Authentication is enabled but "
+				 "authentication service is not "
+				 "running\n");
+		vport->auth.auth_mode = FC_AUTHMODE_UNKNOWN;
+		return 0;
+	}
+
 	vport->port_state = LPFC_FLOGI;
 	lpfc_set_disctmo(vport);
 
@@ -1068,6 +1116,14 @@ lpfc_initial_fdisc(struct lpfc_vport *vp
 	struct lpfc_hba *phba = vport->phba;
 	struct lpfc_nodelist *ndlp;
 
+	if (vport->cfg_enable_auth && lpfc_security_wait(vport)) {
+		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
+				 "1049 Authentication is enabled but "
+				 "authentication service is not "
+				 "running\n");
+		vport->auth.auth_mode = FC_AUTHMODE_UNKNOWN;
+		return 0;
+	}
 	/* First look for the Fabric ndlp */
 	ndlp = lpfc_findnode_did(vport, Fabric_DID);
 	if (!ndlp) {
@@ -2707,7 +2763,7 @@ lpfc_els_retry(struct lpfc_hba *phba, st
 	if (did == FDMI_DID)
 		retry = 1;
 
-	if ((cmd == ELS_CMD_FLOGI) &&
+	if (((cmd == ELS_CMD_FLOGI) || (cmd == ELS_CMD_FDISC)) &&
 	    (phba->fc_topology != TOPOLOGY_LOOP) &&
 	    !lpfc_error_lost_link(irsp)) {
 		/* FLOGI retry policy */
@@ -2801,6 +2857,17 @@ lpfc_els_retry(struct lpfc_hba *phba, st
 			lpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);
 			lpfc_issue_els_logo(vport, ndlp, cmdiocb->retry);
 			return 1;
+		case ELS_CMD_AUTH_NEG:
+		case ELS_CMD_DH_CHA:
+		case ELS_CMD_DH_REP:
+		case ELS_CMD_DH_SUC:
+			ndlp->nlp_prev_state = ndlp->nlp_state;
+			ndlp->nlp_state = NLP_STE_NPR_NODE;
+			lpfc_printf_log(phba, KERN_INFO, LOG_ELS,
+					"0153 Authentication LS_RJT Logical "
+					"busy\n");
+			lpfc_start_authentication(vport, ndlp);
+			return 1;
 		}
 	}
 	/* No retry ELS command <elsCmd> to remote NPORT <did> */
@@ -4129,8 +4196,8 @@ lpfc_els_rcv_rscn(struct lpfc_vport *vpo
 	spin_lock_irq(shost->host_lock);
 	if (vport->fc_rscn_flush) {
 		/* Another thread is walking fc_rscn_id_list on this vport */
-		spin_unlock_irq(shost->host_lock);
 		vport->fc_flag |= FC_RSCN_DISCOVERY;
+		spin_unlock_irq(shost->host_lock);
 		/* Send back ACC */
 		lpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);
 		return 0;
@@ -4508,6 +4575,29 @@ lpfc_els_rcv_lirr(struct lpfc_vport *vpo
 }
 
 /**
+ * lpfc_els_rcv_rrq - Process an unsolicited rrq iocb
+ * @vport: pointer to a host virtual N_Port data structure.
+ * @cmdiocb: pointer to lpfc command iocb data structure.
+ * @ndlp: pointer to a node-list data structure.
+ *
+ * This routine processes a Reinstate Recovery Qualifier (RRQ) IOCB
+ * received as an ELS unsolicited event. A request to RRQ shall only
+ * be accepted if the Originator Nx_Port N_Port_ID or the Responder
+ * Nx_Port N_Port_ID of the target Exchange is the same as the
+ * N_Port_ID of the Nx_Port that makes the request. If the RRQ is
+ * not accepted, an LS_RJT with reason code "Unable to perform
+ * command request" and reason code explanation "Invalid Originator
+ * S_ID" shall be returned. For now, we just unconditionally accept
+ * RRQ from the target.
+ **/
+static void
+lpfc_els_rcv_rrq(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,
+		 struct lpfc_nodelist *ndlp)
+{
+	lpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);
+}
+
+/**
  * lpfc_els_rsp_rps_acc - Completion callbk func for MBX_READ_LNK_STAT mbox cmd
  * @phba: pointer to lpfc hba data structure.
  * @pmb: pointer to the driver internal queue element for mailbox command.
@@ -5208,6 +5298,362 @@ lpfc_els_flush_all_cmd(struct lpfc_hba  
 	return;
 }
 
+static void
+lpfc_els_rcv_auth_neg(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,
+		  struct lpfc_nodelist *ndlp)
+{
+	struct Scsi_Host  *shost = lpfc_shost_from_vport(vport);
+	struct lpfc_dmabuf *pcmd = cmdiocb->context2;
+	struct lpfc_auth_message *authcmd;
+	uint8_t reason, explanation;
+	uint32_t message_len;
+	uint32_t trans_id;
+	struct fc_auth_req *fc_req;
+	struct fc_auth_rsp *fc_rsp;
+
+	authcmd = pcmd->virt;
+	message_len = be32_to_cpu(authcmd->message_len);
+	trans_id = be32_to_cpu(authcmd->trans_id);
+
+	lpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);
+
+	vport->auth.trans_id = trans_id;
+
+	if (lpfc_unpack_auth_negotiate(vport, authcmd->data,
+				       &reason, &explanation)) {
+		lpfc_issue_els_auth_reject(vport, ndlp, reason, explanation);
+		return;
+	}
+	vport->auth.direction = AUTH_DIRECTION_NONE;
+	lpfc_printf_vlog(vport, KERN_WARNING, LOG_SECURITY,
+			 "1033 Received auth_negotiate from Nport:x%x\n",
+			 ndlp->nlp_DID);
+
+	fc_req = kzalloc(sizeof(struct fc_auth_req), GFP_KERNEL);
+
+	fc_req->local_wwpn = wwn_to_u64(vport->fc_portname.u.wwn);
+	if (ndlp->nlp_type & NLP_FABRIC)
+		fc_req->remote_wwpn = AUTH_FABRIC_WWN;
+	else
+		fc_req->remote_wwpn = wwn_to_u64(ndlp->nlp_portname.u.wwn);
+	fc_req->u.dhchap_challenge.transaction_id = vport->auth.trans_id;
+	fc_req->u.dhchap_challenge.dh_group_id = vport->auth.group_id;
+	fc_req->u.dhchap_challenge.hash_id = vport->auth.hash_id;
+
+	fc_rsp = kzalloc(MAX_AUTH_RSP_SIZE, GFP_KERNEL);
+
+	if (lpfc_fc_security_dhchap_make_challenge(shost,
+			      fc_req, sizeof(struct fc_auth_req),
+	fc_rsp, MAX_AUTH_RSP_SIZE)) {
+		kfree(fc_rsp);
+		lpfc_issue_els_auth_reject(vport, ndlp, LOGIC_ERR, 0);
+	}
+
+	kfree(fc_req);
+
+}
+
+static void
+lpfc_els_rcv_chap_chal(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,
+		       struct lpfc_nodelist *ndlp)
+{
+
+	struct Scsi_Host  *shost = lpfc_shost_from_vport(vport);
+	struct lpfc_dmabuf *pcmd = cmdiocb->context2;
+	struct lpfc_auth_message *authcmd;
+	uint8_t reason, explanation;
+	uint32_t message_len;
+	uint32_t trans_id;
+	struct fc_auth_req *fc_req;
+	struct fc_auth_rsp *fc_rsp;
+	uint32_t fc_req_len;
+
+	authcmd = pcmd->virt;
+	message_len = be32_to_cpu(authcmd->message_len);
+	trans_id = be32_to_cpu(authcmd->trans_id);
+
+	lpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);
+
+	if (vport->auth.auth_msg_state != LPFC_AUTH_NEGOTIATE) {
+		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
+				 "1034 Not Expecting Challenge - Rejecting "
+				 "Challenge.\n");
+		lpfc_issue_els_auth_reject(vport, ndlp, AUTH_ERR, BAD_PROTOCOL);
+		return;
+	}
+
+	if (trans_id  != vport->auth.trans_id) {
+		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
+				 "1035 Transport ID does not match - Rejecting "
+				 "Challenge.\n");
+		lpfc_issue_els_auth_reject(vport, ndlp, AUTH_ERR, BAD_PAYLOAD);
+		return;
+	}
+
+	if (lpfc_unpack_dhchap_challenge(vport, authcmd->data,
+					 &reason, &explanation)) {
+		lpfc_issue_els_auth_reject(vport, ndlp, reason, explanation);
+		return;
+	}
+	vport->auth.direction = AUTH_DIRECTION_NONE;
+
+	fc_req_len = (sizeof(struct fc_auth_req) +
+		      vport->auth.challenge_len +
+		      vport->auth.dh_pub_key_len);
+	fc_req = kzalloc(fc_req_len, GFP_KERNEL);
+	fc_req->local_wwpn = wwn_to_u64(vport->fc_portname.u.wwn);
+	if (ndlp->nlp_type & NLP_FABRIC)
+		fc_req->remote_wwpn = AUTH_FABRIC_WWN;
+	else
+		fc_req->remote_wwpn = wwn_to_u64(ndlp->nlp_portname.u.wwn);
+	fc_req->u.dhchap_reply.transaction_id = vport->auth.trans_id;
+	fc_req->u.dhchap_reply.dh_group_id = vport->auth.group_id;
+	fc_req->u.dhchap_reply.hash_id = vport->auth.hash_id;
+	fc_req->u.dhchap_reply.bidirectional = vport->auth.bidirectional;
+	fc_req->u.dhchap_reply.received_challenge_len =
+		vport->auth.challenge_len;
+	fc_req->u.dhchap_reply.received_public_key_len =
+			vport->auth.dh_pub_key_len;
+	memcpy(fc_req->u.dhchap_reply.data, vport->auth.challenge,
+	       vport->auth.challenge_len);
+	if (vport->auth.group_id != DH_GROUP_NULL) {
+		memcpy(fc_req->u.dhchap_reply.data + vport->auth.challenge_len,
+			vport->auth.dh_pub_key, vport->auth.dh_pub_key_len);
+	}
+
+	fc_rsp = kzalloc(MAX_AUTH_RSP_SIZE, GFP_KERNEL);
+
+	if (lpfc_fc_security_dhchap_make_response(shost,
+			fc_req, fc_req_len,
+			fc_rsp, MAX_AUTH_RSP_SIZE)) {
+		kfree(fc_rsp);
+		lpfc_issue_els_auth_reject(vport, ndlp, LOGIC_ERR, 0);
+	}
+
+	kfree(fc_req);
+
+}
+
+static void
+lpfc_els_rcv_auth_rjt(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,
+		      struct lpfc_nodelist *ndlp)
+{
+
+	struct lpfc_dmabuf *pcmd = cmdiocb->context2;
+	struct lpfc_auth_message *authcmd;
+	uint32_t message_len;
+	uint32_t trans_id;
+	struct lpfc_auth_reject *rjt;
+	struct lpfc_hba *phba = vport->phba;
+
+	authcmd = pcmd->virt;
+	rjt = (struct lpfc_auth_reject *)authcmd->data;
+
+	message_len = be32_to_cpu(authcmd->message_len);
+	trans_id = be32_to_cpu(authcmd->trans_id);
+
+	lpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);
+
+	if (vport->auth.auth_state == LPFC_AUTH_SUCCESS) {
+		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
+				 "1036 Authentication transaction reject - "
+				 "re-auth request reason 0x%x exp 0x%x\n",
+				 rjt->reason, rjt->explanation);
+		lpfc_port_auth_failed(ndlp, LPFC_AUTH_FAIL_AUTH_RJT);
+		if (vport->auth.auth_msg_state == LPFC_DHCHAP_SUCCESS) {
+			/* start authentication */
+			lpfc_start_authentication(vport, ndlp);
+		}
+	} else {
+		if (rjt->reason == LOGIC_ERR && rjt->explanation == RESTART) {
+			lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
+					 "1037 Authentication transaction "
+					 "reject - restarting authentication. "
+					 "reason 0x%x exp 0x%x\n",
+					 rjt->reason, rjt->explanation);
+			/* restart auth */
+			lpfc_start_authentication(vport, ndlp);
+		} else {
+			lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
+				"1057 Authentication transaction "
+				"reject. reason 0x%x exp 0x%x\n",
+				rjt->reason, rjt->explanation);
+			lpfc_port_auth_failed(ndlp, LPFC_AUTH_FAIL_AUTH_RJT);
+			vport->auth.auth_msg_state = LPFC_AUTH_REJECT;
+			if (!(phba->sli3_options & LPFC_SLI3_NPIV_ENABLED) &&
+			    (phba->link_state != LPFC_CLEAR_LA)) {
+				/* If Auth failed enable link interrupt. */
+				lpfc_issue_clear_la(phba, vport);
+			}
+		}
+	}
+}
+
+static void
+lpfc_els_rcv_chap_reply(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,
+		  struct lpfc_nodelist *ndlp)
+{
+
+	struct Scsi_Host  *shost = lpfc_shost_from_vport(vport);
+	struct lpfc_dmabuf *pcmd = cmdiocb->context2;
+	struct lpfc_auth_message *authcmd;
+	uint32_t message_len;
+	uint32_t trans_id;
+	struct fc_auth_req *fc_req;
+	struct fc_auth_rsp *fc_rsp;
+	uint32_t data_len;
+
+	authcmd = pcmd->virt;
+	message_len = be32_to_cpu(authcmd->message_len);
+	trans_id = be32_to_cpu(authcmd->trans_id);
+
+	lpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);
+
+	fc_req = kzalloc(MAX_AUTH_REQ_SIZE, GFP_KERNEL);
+
+	fc_req->local_wwpn = wwn_to_u64(vport->fc_portname.u.wwn);
+	if (ndlp->nlp_type & NLP_FABRIC)
+		fc_req->remote_wwpn = AUTH_FABRIC_WWN;
+	else
+		fc_req->remote_wwpn = wwn_to_u64(ndlp->nlp_portname.u.wwn);
+
+	if (vport->auth.auth_msg_state != LPFC_DHCHAP_CHALLENGE) {
+		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
+				 "1039 Not Expecting Reply - rejecting. State "
+				 "0x%x\n", vport->auth.auth_state);
+
+		lpfc_issue_els_auth_reject(vport, ndlp, AUTH_ERR, BAD_PROTOCOL);
+		return;
+	}
+
+	if (trans_id  != vport->auth.trans_id) {
+		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
+				 "1040 Bad Reply trans_id- rejecting. "
+				 "Trans_id: 0x%x Expecting: 0x%x \n",
+				 trans_id, vport->auth.trans_id);
+		lpfc_issue_els_auth_reject(vport, ndlp, AUTH_ERR, BAD_PAYLOAD);
+		return;
+	}
+
+	/* Zero is a valid length to be returned */
+	data_len = lpfc_unpack_dhchap_reply(vport, authcmd->data, fc_req);
+	fc_req->u.dhchap_success.hash_id = vport->auth.hash_id;
+	fc_req->u.dhchap_success.dh_group_id = vport->auth.group_id;
+	fc_req->u.dhchap_success.transaction_id = vport->auth.trans_id;
+	fc_req->u.dhchap_success.our_challenge_len = vport->auth.challenge_len;
+	memcpy(fc_req->u.dhchap_success.data, vport->auth.challenge,
+		vport->auth.challenge_len);
+
+	fc_rsp = kzalloc(MAX_AUTH_RSP_SIZE, GFP_KERNEL);
+
+	if (lpfc_fc_security_dhchap_authenticate(shost, fc_req,
+			(sizeof(struct fc_auth_req) +
+			data_len + vport->auth.challenge_len),
+			fc_rsp, MAX_AUTH_RSP_SIZE)) {
+		kfree(fc_rsp);
+		lpfc_issue_els_auth_reject(vport, ndlp, LOGIC_ERR, 0);
+	}
+
+	kfree(fc_req);
+
+}
+
+static void
+lpfc_els_rcv_chap_suc(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,
+		  struct lpfc_nodelist *ndlp)
+{
+
+	struct Scsi_Host  *shost = lpfc_shost_from_vport(vport);
+	struct lpfc_dmabuf *pcmd = cmdiocb->context2;
+	struct lpfc_auth_message *authcmd;
+	uint32_t message_len;
+	uint32_t trans_id;
+	struct fc_auth_req *fc_req;
+	struct fc_auth_rsp *fc_rsp;
+	uint32_t data_len;
+
+	authcmd = pcmd->virt;
+	message_len = be32_to_cpu(authcmd->message_len);
+	trans_id = be32_to_cpu(authcmd->trans_id);
+
+	lpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);
+
+	if (vport->auth.auth_msg_state != LPFC_DHCHAP_REPLY &&
+	    vport->auth.auth_msg_state != LPFC_DHCHAP_SUCCESS_REPLY) {
+		lpfc_issue_els_auth_reject(vport, ndlp, AUTH_ERR, BAD_PROTOCOL);
+		return;
+	}
+
+	if (trans_id  != vport->auth.trans_id) {
+		lpfc_issue_els_auth_reject(vport, ndlp, AUTH_ERR, BAD_PAYLOAD);
+		return;
+	}
+
+	if (vport->auth.auth_msg_state == LPFC_DHCHAP_REPLY &&
+	    vport->auth.bidirectional) {
+
+		fc_req = kzalloc(MAX_AUTH_REQ_SIZE, GFP_KERNEL);
+		if (!fc_req)
+			return;
+
+		fc_req->local_wwpn = wwn_to_u64(vport->fc_portname.u.wwn);
+		if (ndlp->nlp_type & NLP_FABRIC)
+			fc_req->remote_wwpn = AUTH_FABRIC_WWN;
+		else
+			fc_req->remote_wwpn =
+				wwn_to_u64(ndlp->nlp_portname.u.wwn);
+		fc_req->u.dhchap_success.hash_id = vport->auth.hash_id;
+		fc_req->u.dhchap_success.dh_group_id = vport->auth.group_id;
+		fc_req->u.dhchap_success.transaction_id = vport->auth.trans_id;
+		fc_req->u.dhchap_success.our_challenge_len =
+				vport->auth.challenge_len;
+
+		memcpy(fc_req->u.dhchap_success.data, vport->auth.challenge,
+		       vport->auth.challenge_len);
+
+		/* Zero is a valid return length */
+		data_len = lpfc_unpack_dhchap_success(vport,
+						      authcmd->data,
+						      fc_req);
+
+		fc_rsp = kzalloc(MAX_AUTH_RSP_SIZE, GFP_KERNEL);
+		if (!fc_rsp)
+			return;
+
+		if (lpfc_fc_security_dhchap_authenticate(shost,
+			fc_req, sizeof(struct fc_auth_req) + data_len,
+			fc_rsp, MAX_AUTH_RSP_SIZE)) {
+			kfree(fc_rsp);
+			lpfc_issue_els_auth_reject(vport, ndlp, LOGIC_ERR, 0);
+		}
+
+		kfree(fc_req);
+
+	} else {
+		vport->auth.auth_msg_state = LPFC_DHCHAP_SUCCESS;
+
+		kfree(vport->auth.challenge);
+		vport->auth.challenge = NULL;
+		vport->auth.challenge_len = 0;
+
+		if (vport->auth.auth_state != LPFC_AUTH_SUCCESS) {
+			vport->auth.auth_state = LPFC_AUTH_SUCCESS;
+			lpfc_printf_vlog(vport, KERN_INFO, LOG_SECURITY,
+					 "1041 Authentication Successful\n");
+			lpfc_start_discovery(vport);
+		} else {
+			lpfc_printf_vlog(vport, KERN_INFO, LOG_SECURITY,
+				"1042 Re-Authentication Successful\n");
+		}
+		/* If config requires re-authentication start the timer */
+		vport->auth.last_auth = jiffies;
+		if (vport->auth.reauth_interval)
+			mod_timer(&ndlp->nlp_reauth_tmr, jiffies +
+				vport->auth.reauth_interval * 60 * HZ);
+	}
+	vport->auth.direction |= AUTH_DIRECTION_REMOTE;
+}
+
 /**
  * lpfc_send_els_failure_event - Posts an ELS command failure event
  * @phba: Pointer to hba context object.
@@ -5401,7 +5847,7 @@ lpfc_els_unsol_buffer(struct lpfc_hba *p
 	if (lpfc_els_chk_latt(vport))
 		goto dropit;
 
-	/* Ignore traffic recevied during vport shutdown. */
+	/* Ignore traffic received during vport shutdown. */
 	if (vport->load_flag & FC_UNLOADING)
 		goto dropit;
 
@@ -5623,6 +6069,50 @@ lpfc_els_unsol_buffer(struct lpfc_hba *p
 		if (newnode)
 			lpfc_nlp_put(ndlp);
 		break;
+	case ELS_CMD_RRQ:
+		lpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,
+			"RCV RRQ:         did:x%x/ste:x%x flg:x%x",
+			did, vport->port_state, ndlp->nlp_flag);
+
+		phba->fc_stat.elsRcvRRQ++;
+		lpfc_els_rcv_rrq(vport, elsiocb, ndlp);
+		if (newnode)
+			lpfc_nlp_put(ndlp);
+		break;
+	case ELS_CMD_AUTH_RJT:
+		lpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,
+			"RCV AUTH_RJT:        did:x%x/ste:x%x flg:x%x",
+			did, vport->port_state, ndlp->nlp_flag);
+		lpfc_els_rcv_auth_rjt(vport, elsiocb, ndlp);
+		break;
+	case ELS_CMD_AUTH_NEG:
+		lpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,
+			"RCV AUTH_NEG:        did:x%x/ste:x%x flg:x%x",
+			did, vport->port_state, ndlp->nlp_flag);
+		lpfc_els_rcv_auth_neg(vport, elsiocb, ndlp);
+		break;
+	case ELS_CMD_DH_CHA:
+		lpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,
+			"RCV DH_CHA:        did:x%x/ste:x%x flg:x%x",
+			did, vport->port_state, ndlp->nlp_flag);
+		lpfc_els_rcv_chap_chal(vport, elsiocb, ndlp);
+		break;
+	case ELS_CMD_DH_REP:
+		lpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,
+			"RCV DH_REP:        did:x%x/ste:x%x flg:x%x",
+			did, vport->port_state, ndlp->nlp_flag);
+		lpfc_els_rcv_chap_reply(vport, elsiocb, ndlp);
+		break;
+	case ELS_CMD_DH_SUC:
+		lpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,
+			"RCV DH_SUC:        did:x%x/ste:x%x flg:x%x",
+			did, vport->port_state, ndlp->nlp_flag);
+		lpfc_els_rcv_chap_suc(vport, elsiocb, ndlp);
+		break;
+	case ELS_CMD_AUTH_DONE:
+		lpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,
+			"RCV AUTH_DONE:        did:x%x/ste:x%x flg:x%x",
+			did, vport->port_state, ndlp->nlp_flag);
 	default:
 		lpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,
 			"RCV ELS cmd:     cmd:x%x did:x%x/ste:x%x",
@@ -5869,6 +6359,7 @@ lpfc_cmpl_reg_new_vport(struct lpfc_hba 
 	struct Scsi_Host  *shost = lpfc_shost_from_vport(vport);
 	struct lpfc_nodelist *ndlp = (struct lpfc_nodelist *) pmb->context2;
 	MAILBOX_t *mb = &pmb->u.mb;
+	int rc;
 
 	spin_lock_irq(shost->host_lock);
 	vport->fc_flag &= ~FC_VPORT_NEEDS_REG_VPI;
@@ -5890,6 +6381,26 @@ lpfc_cmpl_reg_new_vport(struct lpfc_hba 
 			spin_unlock_irq(shost->host_lock);
 			lpfc_can_disctmo(vport);
 			break;
+		/* If reg_vpi fail with invalid VPI status, re-init VPI */
+		case 0x20:
+			spin_lock_irq(shost->host_lock);
+			vport->fc_flag |= FC_VPORT_NEEDS_REG_VPI;
+			spin_unlock_irq(shost->host_lock);
+			lpfc_init_vpi(phba, pmb, vport->vpi);
+			pmb->vport = vport;
+			pmb->mbox_cmpl = lpfc_init_vpi_cmpl;
+			rc = lpfc_sli_issue_mbox(phba, pmb,
+				MBX_NOWAIT);
+			if (rc == MBX_NOT_FINISHED) {
+				lpfc_printf_vlog(vport,
+					KERN_ERR, LOG_MBOX,
+					"2732 Failed to issue INIT_VPI"
+					" mailbox command\n");
+			} else {
+				lpfc_nlp_put(ndlp);
+				return;
+			}
+
 		default:
 			/* Try to recover from this error */
 			lpfc_mbx_unreg_vpi(vport);
@@ -5902,15 +6413,21 @@ lpfc_cmpl_reg_new_vport(struct lpfc_hba 
 				lpfc_initial_fdisc(vport);
 			break;
 		}
-
 	} else {
-		if (vport == phba->pport)
+		spin_lock_irq(shost->host_lock);
+		vport->vpi_state |= LPFC_VPI_REGISTERED;
+		spin_unlock_irq(shost->host_lock);
+		if (vport == phba->pport) {
 			if (phba->sli_rev < LPFC_SLI_REV4)
 				lpfc_issue_fabric_reglogin(vport);
-			else
-				lpfc_issue_reg_vfi(vport);
+			else {
+				lpfc_start_fdiscs(phba);
+				lpfc_do_scr_ns_plogi(phba, vport);
+			}
+		} else if (vport->cfg_enable_auth)
+			lpfc_get_auth_config(vport, NULL);
 		else
-			lpfc_do_scr_ns_plogi(phba, vport);
+			lpfc_start_discovery(vport);
 	}
 
 	/* Now, we decrement the ndlp reference count held for this
@@ -5931,7 +6448,7 @@ lpfc_cmpl_reg_new_vport(struct lpfc_hba 
  * This routine registers the @vport as a new virtual port with a HBA.
  * It is done through a registering vpi mailbox command.
  **/
-static void
+void
 lpfc_register_new_vport(struct lpfc_hba *phba, struct lpfc_vport *vport,
 			struct lpfc_nodelist *ndlp)
 {
@@ -5972,6 +6489,78 @@ mbox_err_exit:
 }
 
 /**
+ * lpfc_retry_pport_discovery - Start timer to retry FLOGI.
+ * @phba: pointer to lpfc hba data structure.
+ *
+ * This routine abort all pending discovery commands and
+ * start a timer to retry FLOGI for the physical port
+ * discovery.
+ **/
+void
+lpfc_retry_pport_discovery(struct lpfc_hba *phba)
+{
+	struct lpfc_vport **vports;
+	struct lpfc_nodelist *ndlp;
+	struct Scsi_Host  *shost;
+	int i;
+	uint32_t link_state;
+
+	/* Treat this failure as linkdown for all vports */
+	link_state = phba->link_state;
+	lpfc_linkdown(phba);
+	phba->link_state = link_state;
+
+	vports = lpfc_create_vport_work_array(phba);
+
+	if (vports) {
+		for (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {
+			ndlp = lpfc_findnode_did(vports[i], Fabric_DID);
+			if (ndlp)
+				lpfc_cancel_retry_delay_tmo(vports[i], ndlp);
+			lpfc_els_flush_cmd(vports[i]);
+		}
+		lpfc_destroy_vport_work_array(phba, vports);
+	}
+
+	/* If fabric require FLOGI, then re-instantiate physical login */
+	ndlp = lpfc_findnode_did(phba->pport, Fabric_DID);
+	if (!ndlp)
+		return;
+
+
+	shost = lpfc_shost_from_vport(phba->pport);
+	mod_timer(&ndlp->nlp_delayfunc, jiffies + HZ);
+	spin_lock_irq(shost->host_lock);
+	ndlp->nlp_flag |= NLP_DELAY_TMO;
+	spin_unlock_irq(shost->host_lock);
+	ndlp->nlp_last_elscmd = ELS_CMD_FLOGI;
+	phba->pport->port_state = LPFC_FLOGI;
+	return;
+}
+
+/**
+ * lpfc_fabric_login_reqd - Check if FLOGI required.
+ * @phba: pointer to lpfc hba data structure.
+ * @cmdiocb: pointer to FDISC command iocb.
+ * @rspiocb: pointer to FDISC response iocb.
+ *
+ * This routine checks if a FLOGI is reguired for FDISC
+ * to succeed.
+ **/
+static int
+lpfc_fabric_login_reqd(struct lpfc_hba *phba,
+		struct lpfc_iocbq *cmdiocb,
+		struct lpfc_iocbq *rspiocb)
+{
+
+	if ((rspiocb->iocb.ulpStatus != IOSTAT_FABRIC_RJT) ||
+		(rspiocb->iocb.un.ulpWord[4] != RJT_LOGIN_REQUIRED))
+		return 0;
+	else
+		return 1;
+}
+
+/**
  * lpfc_cmpl_els_fdisc - Completion function for fdisc iocb command
  * @phba: pointer to lpfc hba data structure.
  * @cmdiocb: pointer to lpfc command iocb data structure.
@@ -6002,6 +6591,8 @@ lpfc_cmpl_els_fdisc(struct lpfc_hba *phb
 	struct lpfc_nodelist *next_np;
 	IOCB_t *irsp = &rspiocb->iocb;
 	struct lpfc_iocbq *piocb;
+	struct lpfc_dmabuf *pcmd = cmdiocb->context2, *prsp;
+	struct serv_parm *sp;
 
 	lpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,
 			 "0123 FDISC completes. x%x/x%x prevDID: x%x\n",
@@ -6020,6 +6611,12 @@ lpfc_cmpl_els_fdisc(struct lpfc_hba *phb
 		irsp->ulpStatus, irsp->un.ulpWord[4], vport->fc_prevDID);
 
 	if (irsp->ulpStatus) {
+
+		if (lpfc_fabric_login_reqd(phba, cmdiocb, rspiocb)) {
+			lpfc_retry_pport_discovery(phba);
+			goto out;
+		}
+
 		/* Check for retry */
 		if (lpfc_els_retry(phba, cmdiocb, rspiocb))
 			goto out;
@@ -6029,12 +6626,27 @@ lpfc_cmpl_els_fdisc(struct lpfc_hba *phb
 				 irsp->ulpStatus, irsp->un.ulpWord[4]);
 		goto fdisc_failed;
 	}
-		if (vport->fc_vport->vport_state == FC_VPORT_INITIALIZING)
-			lpfc_vport_set_state(vport, FC_VPORT_FAILED);
-		lpfc_nlp_put(ndlp);
-		/* giving up on FDISC. Cancel discovery timer */
-		lpfc_can_disctmo(vport);
+	prsp = list_get_first(&pcmd->list, struct lpfc_dmabuf, list);
+	sp = prsp->virt + sizeof(uint32_t);
+	if (sp->cmn.security)
+		ndlp->nlp_flag |= NLP_SC_REQ;
+	else
+		ndlp->nlp_flag &= ~NLP_SC_REQ;
+	if (vport->cfg_enable_auth) {
+		if (lpfc_get_auth_config(vport, NULL))
+			goto fdisc_failed;
+	} else {
+		vport->auth.security_active = 0;
+		if (sp->cmn.security) {
+			lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
+					 "1056 Authentication mode is "
+					 "disabled, but is required "
+					 "by the fabric.\n");
+			goto fdisc_failed;
+		}
+	}
 	spin_lock_irq(shost->host_lock);
+	vport->fc_flag &= ~FC_VPORT_CVL_RCVD;
 	vport->fc_flag |= FC_FABRIC;
 	if (vport->phba->fc_topology == TOPOLOGY_LOOP)
 		vport->fc_flag |=  FC_PUBLIC_LOOP;
@@ -6067,8 +6679,11 @@ lpfc_cmpl_els_fdisc(struct lpfc_hba *phb
 
 	if (vport->fc_flag & FC_VPORT_NEEDS_REG_VPI)
 		lpfc_register_new_vport(phba, vport, ndlp);
-	else
-		lpfc_do_scr_ns_plogi(phba, vport);
+	else if (vport->cfg_enable_auth) {
+		if (lpfc_get_auth_config(vport, NULL))
+			goto fdisc_failed;
+	} else
+		lpfc_start_discovery(vport);
 	goto out;
 fdisc_failed:
 	lpfc_vport_set_state(vport, FC_VPORT_FAILED);
@@ -6112,6 +6727,7 @@ lpfc_issue_els_fdisc(struct lpfc_vport *
 	int did = ndlp->nlp_DID;
 	int rc;
 
+	vport->port_state = LPFC_FDISC;
 	cmdsize = (sizeof(uint32_t) + sizeof(struct serv_parm));
 	elsiocb = lpfc_prep_els_iocb(vport, 1, cmdsize, retry, ndlp, did,
 				     ELS_CMD_FDISC);
@@ -6149,6 +6765,8 @@ lpfc_issue_els_fdisc(struct lpfc_vport *
 	sp->cls1.classValid = 0;
 	sp->cls2.seqDelivery = 1;
 	sp->cls3.seqDelivery = 1;
+	if (vport->cfg_enable_auth)
+		sp->cmn.security = 1;
 
 	pcmd += sizeof(uint32_t); /* CSP Word 2 */
 	pcmd += sizeof(uint32_t); /* CSP Word 3 */
@@ -6177,7 +6795,6 @@ lpfc_issue_els_fdisc(struct lpfc_vport *
 		return 1;
 	}
 	lpfc_vport_set_state(vport, FC_VPORT_INITIALIZING);
-	vport->port_state = LPFC_FDISC;
 	return 0;
 }
 
@@ -6620,6 +7237,191 @@ void lpfc_fabric_abort_hba(struct lpfc_h
 	lpfc_sli_cancel_iocbs(phba, &completions, IOSTAT_LOCAL_REJECT,
 			      IOERR_SLI_ABORTED);
 }
+static void
+lpfc_cmpl_els_auth(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,
+		   struct lpfc_iocbq *rspiocb)
+{
+	IOCB_t *irsp = &rspiocb->iocb;
+	struct lpfc_vport *vport = cmdiocb->vport;
+	struct lpfc_nodelist *ndlp = (struct lpfc_nodelist *) cmdiocb->context1;
+	enum auth_state auth_state;
+	struct ls_rjt stat;
+
+	/* Check to see if link went down during discovery */
+	if (lpfc_els_chk_latt(vport)) {
+		vport->auth.auth_msg_state = LPFC_AUTH_NONE;
+		lpfc_els_free_iocb(phba, cmdiocb);
+		return;
+	}
+
+	if (irsp->ulpStatus) {
+		auth_state = LPFC_AUTH_FAIL;
+		if (irsp->ulpStatus == IOSTAT_LS_RJT) {
+			stat.un.lsRjtError = be32_to_cpu(irsp->un.ulpWord[4]);
+			lpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,
+					 "1043 Authentication LS_RJT\n");
+			if (stat.un.b.lsRjtRsnCode == LSRJT_LOGICAL_BSY)
+				auth_state = LPFC_AUTH_FAIL_LS_RJT_BUSY;
+			else
+				auth_state = LPFC_AUTH_FAIL_LS_RJT_GEN;
+		} else if (irsp->ulpStatus == IOSTAT_LOCAL_REJECT &&
+			   (irsp->un.ulpWord[4] & 0xff) ==
+				IOERR_SEQUENCE_TIMEOUT) {
+			auth_state = LPFC_AUTH_FAIL_ELS_TMO;
+		}
+		/* Check for retry */
+		if (!lpfc_els_retry(phba, cmdiocb, rspiocb)) {
+			if (irsp->ulpStatus != IOSTAT_LS_RJT) {
+				lpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,
+						 "1045 Issue AUTH_NEG failed."
+						 "Status:%x\n",
+						 irsp->ulpStatus);
+			}
+			if (vport->auth.auth_mode == FC_AUTHMODE_ACTIVE) {
+				lpfc_can_disctmo(vport);
+				lpfc_port_auth_failed(ndlp, auth_state);
+			}
+		}
+		if (!(phba->sli3_options & LPFC_SLI3_NPIV_ENABLED) &&
+		    (phba->link_state != LPFC_CLEAR_LA))
+			lpfc_issue_clear_la(phba, vport);
+		lpfc_els_free_iocb(phba, cmdiocb);
+		return;
+	}
+
+	if (vport->auth.auth_msg_state == LPFC_DHCHAP_SUCCESS ||
+	    vport->auth.auth_msg_state == LPFC_DHCHAP_SUCCESS_REPLY) {
+
+		kfree(vport->auth.challenge);
+		vport->auth.challenge = NULL;
+		vport->auth.challenge_len = 0;
+		kfree(vport->auth.dh_pub_key);
+		vport->auth.dh_pub_key = NULL;
+		vport->auth.dh_pub_key_len = 0;
+
+		if (vport->auth.auth_msg_state == LPFC_DHCHAP_SUCCESS) {
+			if (vport->auth.auth_state != LPFC_AUTH_SUCCESS) {
+				lpfc_printf_vlog(vport, KERN_WARNING,
+						 LOG_SECURITY, "1046 "
+						 "Authentication Successful\n");
+				vport->auth.auth_state = LPFC_AUTH_SUCCESS;
+				lpfc_start_discovery(vport);
+			} else {
+				lpfc_printf_vlog(vport, KERN_WARNING,
+						 LOG_SECURITY,
+						 "1047 Re-Authentication"
+						 " Successful\n");
+			}
+		}
+		/* restart authentication timer */
+		vport->auth.last_auth = jiffies;
+		if (vport->auth.reauth_interval)
+			mod_timer(&ndlp->nlp_reauth_tmr,
+				jiffies +
+				vport->auth.reauth_interval * 60 * HZ);
+	}
+	lpfc_els_free_iocb(phba, cmdiocb);
+}
+
+int
+lpfc_issue_els_auth(struct lpfc_vport *vport,
+		    struct lpfc_nodelist *ndlp,
+		    uint8_t message_code,
+		    uint8_t *payload,
+		    uint32_t payload_len)
+{
+	struct lpfc_hba *phba = vport->phba;
+	struct lpfc_iocbq *elsiocb;
+	struct lpfc_auth_message *authreq;
+
+	elsiocb = lpfc_prep_els_iocb(vport, 1,
+			sizeof(struct lpfc_auth_message) + payload_len,
+			0, ndlp, ndlp->nlp_DID, ELS_CMD_AUTH);
+
+	if (!elsiocb)
+		return 1;
+	authreq = (struct lpfc_auth_message *)
+		(((struct lpfc_dmabuf *) elsiocb->context2)->virt);
+	authreq->command_code = ELS_CMD_AUTH_BYTE;
+	authreq->flags = 0;
+	authreq->message_code = message_code;
+	authreq->protocol_ver = AUTH_VERSION;
+	authreq->message_len = cpu_to_be32(payload_len);
+	authreq->trans_id = cpu_to_be32(vport->auth.trans_id);
+	memcpy(authreq->data, payload, payload_len);
+
+	elsiocb->iocb_cmpl = lpfc_cmpl_els_auth;
+
+	if (lpfc_sli_issue_iocb(phba, LPFC_ELS_RING,
+				elsiocb, 0) == IOCB_ERROR) {
+		lpfc_els_free_iocb(phba, elsiocb);
+		return 1;
+	}
+
+	return 0;
+}
+
+static void
+lpfc_cmpl_els_auth_reject(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,
+		    struct lpfc_iocbq *rspiocb)
+{
+	struct lpfc_vport *vport = cmdiocb->vport;
+	IOCB_t *irsp = &rspiocb->iocb;
+
+	if (irsp->ulpStatus) {
+		/* Check for retry */
+		if (!lpfc_els_retry(phba, cmdiocb, rspiocb)) {
+			lpfc_printf_log(phba, KERN_ERR, LOG_ELS,
+					"1048 Issue AUTH_REJECT failed.\n");
+		}
+	} else
+	       vport->port_state = LPFC_VPORT_UNKNOWN;
+
+	lpfc_els_free_iocb(phba, cmdiocb);
+}
+
+int
+lpfc_issue_els_auth_reject(struct lpfc_vport *vport,
+					struct lpfc_nodelist *ndlp,
+					uint8_t reason, uint8_t explanation)
+{
+	struct lpfc_hba *phba = vport->phba;
+	struct lpfc_iocbq *elsiocb;
+	struct lpfc_auth_message *authreq;
+	struct lpfc_auth_reject *reject;
+
+	vport->auth.auth_msg_state = LPFC_AUTH_REJECT;
+
+	elsiocb = lpfc_prep_els_iocb(vport, 1, sizeof(struct lpfc_auth_message)
+				     + sizeof(struct lpfc_auth_reject), 0, ndlp,
+				     ndlp->nlp_DID, ELS_CMD_AUTH);
+
+	if (!elsiocb)
+		return 1;
+
+	authreq = (struct lpfc_auth_message *)
+		(((struct lpfc_dmabuf *) elsiocb->context2)->virt);
+	authreq->command_code = ELS_CMD_AUTH_BYTE;
+	authreq->flags = 0;
+	authreq->message_code = AUTH_REJECT;
+	authreq->protocol_ver = AUTH_VERSION;
+	reject = (struct lpfc_auth_reject *)authreq->data;
+	memset(reject, 0, sizeof(struct lpfc_auth_reject));
+	reject->reason = reason;
+	reject->explanation = explanation;
+
+	authreq->message_len = cpu_to_be32(sizeof(struct lpfc_auth_reject));
+	authreq->trans_id = cpu_to_be32(vport->auth.trans_id);
+	elsiocb->iocb_cmpl = lpfc_cmpl_els_auth_reject;
+
+	if (lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0)
+			== IOCB_ERROR) {
+		lpfc_els_free_iocb(phba, elsiocb);
+		return 1;
+	}
+
+	return 0;
+}
 
 /**
  * lpfc_sli4_els_xri_aborted - Slow-path process of els xri abort
diff -urpN a/drivers/scsi/lpfc/lpfc.h b/drivers/scsi/lpfc/lpfc.h
--- a/drivers/scsi/lpfc/lpfc.h	2010-01-12 16:47:01.051078000 -0500
+++ b/drivers/scsi/lpfc/lpfc.h	2010-01-12 16:46:28.495798000 -0500
@@ -202,6 +202,7 @@ struct lpfc_stats {
 	uint32_t elsRcvLIRR;
 	uint32_t elsRcvRPS;
 	uint32_t elsRcvRPL;
+	uint32_t elsRcvRRQ;
 	uint32_t elsXmitFLOGI;
 	uint32_t elsXmitFDISC;
 	uint32_t elsXmitPLOGI;
@@ -279,6 +280,57 @@ enum hba_state {
 	LPFC_HBA_ERROR       =  -1
 };
 
+enum auth_state {
+	LPFC_AUTH_UNKNOWN		=  0,
+	LPFC_AUTH_SUCCESS		=  1,
+	LPFC_AUTH_FAIL			=  2,
+	LPFC_AUTH_FAIL_ELS_TMO		=  3,
+	LPFC_AUTH_FAIL_TRANS_TMO	=  4,
+	LPFC_AUTH_FAIL_LS_RJT_GEN	=  5,
+	LPFC_AUTH_FAIL_LS_RJT_BUSY	=  6,
+	LPFC_AUTH_FAIL_AUTH_RJT		=  7,
+};
+enum auth_msg_state {
+	LPFC_AUTH_NONE			=  0,
+	LPFC_AUTH_REJECT		=  1,	/* Sent a Reject */
+	LPFC_AUTH_NEGOTIATE		=  2,	/* Auth Negotiate */
+	LPFC_DHCHAP_CHALLENGE		=  3,	/* Challenge */
+	LPFC_DHCHAP_REPLY		=  4,	/* Reply */
+	LPFC_DHCHAP_SUCCESS_REPLY	=  5,	/* Success with Reply */
+	LPFC_DHCHAP_SUCCESS		=  6,	/* Success */
+	LPFC_AUTH_DONE			=  7,
+};
+
+struct lpfc_auth {
+	uint8_t auth_mode;
+	uint8_t bidirectional;
+	uint8_t hash_priority[4];
+	uint32_t hash_len;
+	uint8_t dh_group_priority[8];
+	uint32_t dh_group_len;
+	uint32_t reauth_interval;
+
+	uint8_t security_active;
+	enum auth_state auth_state;
+	enum auth_msg_state auth_msg_state;
+	uint32_t trans_id;              /* current transaction id. Can be set
+					   by incomming transactions as well */
+	uint32_t group_id;
+	uint32_t hash_id;
+	uint32_t direction;
+#define AUTH_DIRECTION_NONE	0
+#define AUTH_DIRECTION_REMOTE	0x1
+#define AUTH_DIRECTION_LOCAL	0x2
+#define AUTH_DIRECTION_BIDI	(AUTH_DIRECTION_LOCAL|AUTH_DIRECTION_REMOTE)
+
+	uint8_t *challenge;
+	uint32_t challenge_len;
+	uint8_t *dh_pub_key;
+	uint32_t dh_pub_key_len;
+
+	unsigned long last_auth;
+};
+
 struct lpfc_vport {
 	struct lpfc_hba *phba;
 	struct list_head listentry;
@@ -290,8 +342,8 @@ struct lpfc_vport {
 
 	uint16_t vpi;
 	uint16_t vfi;
-	uint8_t vfi_state;
-#define LPFC_VFI_REGISTERED	0x1
+	uint8_t vpi_state;
+#define LPFC_VPI_REGISTERED	0x1
 
 	uint32_t fc_flag;	/* FC flags */
 /* Several of these flags are HBA centric and should be moved to
@@ -314,6 +366,9 @@ struct lpfc_vport {
 #define FC_VPORT_NEEDS_REG_VPI	0x80000  /* Needs to have its vpi registered */
 #define FC_RSCN_DEFERRED	0x100000 /* A deferred RSCN being processed */
 #define FC_VPORT_NEEDS_INIT_VPI 0x200000 /* Need to INIT_VPI before FDISC */
+#define FC_VPORT_CVL_RCVD	0x400000 /* VLink failed due to CVL	 */
+#define FC_VFI_REGISTERED	0x800000 /* VFI is registered */
+#define FC_FDISC_COMPLETED	0x1000000/* FDISC completed */
 
 	uint32_t ct_flags;
 #define FC_CT_RFF_ID		0x1	 /* RFF_ID accepted by switch */
@@ -376,6 +431,15 @@ struct lpfc_vport {
 	uint8_t load_flag;
 #define FC_LOADING		0x1	/* HBA in process of loading drvr */
 #define FC_UNLOADING		0x2	/* HBA in process of unloading drvr */
+	/* Fields used for accessing auth service */
+	struct lpfc_auth auth;
+	uint32_t sc_tran_id;
+	struct list_head sc_response_wait_queue;
+	struct list_head sc_users;
+	struct work_struct sc_online_work;
+	struct work_struct sc_offline_work;
+	uint8_t security_service_state;
+
 	/* Vport Config Parameters */
 	uint32_t cfg_scan_down;
 	uint32_t cfg_lun_queue_depth;
@@ -391,6 +455,7 @@ struct lpfc_vport {
 	uint32_t cfg_max_luns;
 	uint32_t cfg_enable_da_id;
 	uint32_t cfg_max_scsicmpl_time;
+	uint32_t cfg_enable_auth;
 
 	uint32_t dev_loss_tmo_changed;
 
diff -urpN a/drivers/scsi/lpfc/lpfc_hbadisc.c b/drivers/scsi/lpfc/lpfc_hbadisc.c
--- a/drivers/scsi/lpfc/lpfc_hbadisc.c	2010-01-12 16:47:01.067083000 -0500
+++ b/drivers/scsi/lpfc/lpfc_hbadisc.c	2010-01-12 16:46:28.515801000 -0500
@@ -41,6 +41,8 @@
 #include "lpfc_crtn.h"
 #include "lpfc_vport.h"
 #include "lpfc_debugfs.h"
+#include "lpfc_security.h"
+#include "lpfc_auth_access.h"
 
 /* AlpaArray for assignment of scsid for scan-down and bind_method */
 static uint8_t lpfcAlpaArray[] = {
@@ -64,6 +66,26 @@ static void lpfc_disc_flush_list(struct 
 static void lpfc_unregister_fcfi_cmpl(struct lpfc_hba *, LPFC_MBOXQ_t *);
 
 void
+lpfc_start_discovery(struct lpfc_vport *vport)
+{
+	struct lpfc_hba *phba = vport->phba;
+
+	if (vport->auth.security_active &&
+	    vport->auth.auth_state != LPFC_AUTH_SUCCESS) {
+		lpfc_printf_vlog(vport, KERN_ERR, LOG_DISCOVERY,
+				 "0154 Authentication not complete.\n");
+		return;
+	}
+	if (vport->port_type == LPFC_NPIV_PORT) {
+		lpfc_do_scr_ns_plogi(phba, vport);
+		return;
+	}
+
+	lpfc_start_fdiscs(phba);
+	lpfc_do_scr_ns_plogi(phba, vport);
+}
+
+void
 lpfc_terminate_rport_io(struct fc_rport *rport)
 {
 	struct lpfc_rport_data *rdata;
@@ -422,6 +444,15 @@ lpfc_work_list_done(struct lpfc_hba *phb
 			 */
 			lpfc_nlp_put(ndlp);
 			break;
+		case LPFC_EVT_REAUTH:
+			ndlp = (struct lpfc_nodelist *) (evtp->evt_arg1);
+			lpfc_reauthentication_handler(ndlp);
+			free_evt = 0; /* evt is part of ndlp */
+			/* decrement the node reference count held
+			 * for this queued work
+			 */
+			lpfc_nlp_put(ndlp);
+			break;
 		case LPFC_EVT_DEV_LOSS:
 			ndlp = (struct lpfc_nodelist *)(evtp->evt_arg1);
 			lpfc_dev_loss_tmo_handler(ndlp);
@@ -681,6 +712,9 @@ lpfc_cleanup_rpis(struct lpfc_vport *vpo
 			continue;
 		if (ndlp->nlp_state == NLP_STE_UNUSED_NODE)
 			continue;
+		/* Stop re-authentication timer of all nodes. */
+		del_timer_sync(&ndlp->nlp_reauth_tmr);
+
 		if ((phba->sli3_options & LPFC_SLI3_VPORT_TEARDOWN) ||
 			((vport->port_type == LPFC_NPIV_PORT) &&
 			(ndlp->nlp_DID == NameServer_DID)))
@@ -706,6 +740,8 @@ lpfc_cleanup_rpis(struct lpfc_vport *vpo
 void
 lpfc_port_link_failure(struct lpfc_vport *vport)
 {
+	lpfc_vport_set_state(vport, FC_VPORT_LINKDOWN);
+
 	/* Cleanup any outstanding received buffers */
 	lpfc_cleanup_rcv_buffers(vport);
 
@@ -733,7 +769,25 @@ lpfc_linkdown_port(struct lpfc_vport *vp
 		vport->port_state, vport->fc_ns_retry, vport->fc_flag);
 
 	lpfc_port_link_failure(vport);
+	if (vport->auth.auth_state < LPFC_AUTH_FAIL) {
+		vport->auth.auth_state = LPFC_AUTH_UNKNOWN;
+		vport->auth.auth_msg_state = LPFC_AUTH_NONE;
+	}
+}
+
+void
+lpfc_port_auth_failed(struct lpfc_nodelist *ndlp, enum auth_state fail_state)
+{
+	struct lpfc_vport *vport = ndlp->vport;
 
+	vport->auth.auth_state = fail_state;
+	vport->auth.auth_msg_state = LPFC_AUTH_NONE;
+	lpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);
+	if (ndlp->nlp_type & NLP_FABRIC) {
+		lpfc_port_link_failure(vport);
+		lpfc_vport_set_state(vport, FC_VPORT_FAILED);
+		lpfc_issue_els_logo(vport, ndlp, 0);
+	}
 }
 
 int
@@ -747,6 +801,10 @@ lpfc_linkdown(struct lpfc_hba *phba)
 
 	if (phba->link_state == LPFC_LINK_DOWN)
 		return 0;
+
+	/* Block all SCSI stack I/Os */
+	lpfc_scsi_dev_block(phba);
+
 	spin_lock_irq(&phba->hbalock);
 	phba->fcf.fcf_flag &= ~(FCF_AVAILABLE | FCF_DISCOVERED);
 	if (phba->link_state > LPFC_LINK_DOWN) {
@@ -850,6 +908,8 @@ lpfc_linkup_port(struct lpfc_vport *vpor
 	if (vport->fc_flag & FC_LBIT)
 		lpfc_linkup_cleanup_nodes(vport);
 
+	vport->auth.auth_state = LPFC_AUTH_UNKNOWN;
+	vport->auth.auth_msg_state = LPFC_AUTH_NONE;
 }
 
 static int
@@ -970,9 +1030,12 @@ lpfc_mbx_cmpl_local_config_link(struct l
 	/* Start discovery by sending a FLOGI. port_state is identically
 	 * LPFC_FLOGI while waiting for FLOGI cmpl
 	 */
-	if (vport->port_state != LPFC_FLOGI) {
+	if ((vport->cfg_enable_auth) &&
+	    (vport->security_service_state == SECURITY_OFFLINE))
+		lpfc_issue_clear_la(phba, vport);
+	else if (vport->port_state != LPFC_FLOGI)
 		lpfc_initial_flogi(vport);
-	}
+
 	return;
 
 out:
@@ -1018,13 +1081,12 @@ lpfc_mbx_cmpl_reg_fcfi(struct lpfc_hba *
 		mempool_free(mboxq, phba->mbox_mem_pool);
 		return;
 	}
+	spin_lock_irqsave(&phba->hbalock, flags);
 	phba->fcf.fcf_flag |= (FCF_DISCOVERED | FCF_IN_USE);
 	phba->hba_flag &= ~FCF_DISC_INPROGRESS;
-	if (vport->port_state != LPFC_FLOGI) {
-		spin_lock_irqsave(&phba->hbalock, flags);
-		spin_unlock_irqrestore(&phba->hbalock, flags);
+	spin_unlock_irqrestore(&phba->hbalock, flags);
+	if (vport->port_state != LPFC_FLOGI)
 		lpfc_initial_flogi(vport);
-	}
 
 	mempool_free(mboxq, phba->mbox_mem_pool);
 	return;
@@ -1460,12 +1522,15 @@ lpfc_check_pending_fcoe_event(struct lpf
 
 	if (phba->link_state >= LPFC_LINK_UP)
 		lpfc_sli4_read_fcf_record(phba, LPFC_FCOE_FCF_GET_FIRST);
-	else
+	else {
 		/*
 		 * Do not continue FCF discovery and clear FCF_DISC_INPROGRESS
 		 * flag
 		 */
+		spin_lock_irq(&phba->hbalock);
 		phba->hba_flag &= ~FCF_DISC_INPROGRESS;
+		spin_unlock_irq(&phba->hbalock);
+	}
 
 	if (unreg_fcf) {
 		spin_lock_irq(&phba->hbalock);
@@ -1553,10 +1618,16 @@ lpfc_mbx_cmpl_read_fcf_record(struct lpf
 	 * to book keeping the FCFIs can be used.
 	 */
 	if (shdr_status || shdr_add_status) {
-		lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
-				"2521 READ_FCF_RECORD mailbox failed "
-				"with status x%x add_status x%x, mbx\n",
-				shdr_status, shdr_add_status);
+		if (shdr_status == STATUS_FCF_TABLE_EMPTY) {
+			lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
+					"2726 READ_FCF_RECORD Indicates empty "
+					"FCF table.\n");
+		} else {
+			lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
+					"2521 READ_FCF_RECORD mailbox failed "
+					"with status x%x add_status x%x, mbx\n",
+					shdr_status, shdr_add_status);
+		}
 		goto out;
 	}
 	/* Interpreting the returned information of FCF records */
@@ -1683,10 +1754,11 @@ out:
  *
  * This function handles completion of init vpi mailbox command.
  */
-static void
+void
 lpfc_init_vpi_cmpl(struct lpfc_hba *phba, LPFC_MBOXQ_t *mboxq)
 {
 	struct lpfc_vport *vport = mboxq->vport;
+	struct lpfc_nodelist *ndlp;
 	if (mboxq->u.mb.mbxStatus) {
 		lpfc_printf_vlog(vport, KERN_ERR,
 				LOG_MBOX,
@@ -1696,7 +1768,23 @@ lpfc_init_vpi_cmpl(struct lpfc_hba *phba
 		lpfc_vport_set_state(vport, FC_VPORT_FAILED);
 		return;
 	}
+	spin_lock_irq(&phba->hbalock);
 	vport->fc_flag &= ~FC_VPORT_NEEDS_INIT_VPI;
+	spin_unlock_irq(&phba->hbalock);
+
+	/* If this port is physical port or FDISC is done, do reg_vpi */
+	if ((phba->pport == vport) || (vport->port_state == LPFC_FDISC)) {
+			ndlp = lpfc_findnode_did(vport, Fabric_DID);
+			if (!ndlp)
+				lpfc_printf_vlog(vport, KERN_ERR,
+					LOG_DISCOVERY,
+					"2731 Cannot find fabric "
+					"controller node\n");
+			else
+				lpfc_register_new_vport(phba, vport, ndlp);
+			mempool_free(mboxq, phba->mbox_mem_pool);
+			return;
+	}
 
 	if (phba->link_flag & LS_NPIV_FAB_SUPPORTED)
 		lpfc_initial_fdisc(vport);
@@ -1705,6 +1793,7 @@ lpfc_init_vpi_cmpl(struct lpfc_hba *phba
 		lpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,
 				 "2606 No NPIV Fabric support\n");
 	}
+	mempool_free(mboxq, phba->mbox_mem_pool);
 	return;
 }
 
@@ -1798,14 +1887,18 @@ lpfc_mbx_cmpl_reg_vfi(struct lpfc_hba *p
 		lpfc_vport_set_state(vport, FC_VPORT_FAILED);
 		goto fail_free_mem;
 	}
-	/* Mark the vport has registered with its VFI */
-	vport->vfi_state |= LPFC_VFI_REGISTERED;
+	/* The VPI is implicitly registered when the VFI is registered */
+	vport->vpi_state |= LPFC_VPI_REGISTERED;
+	vport->fc_flag |= FC_VFI_REGISTERED;
+
+	vport->fc_flag &= ~FC_VPORT_NEEDS_REG_VPI;
 
 	if (vport->port_state == LPFC_FABRIC_CFG_LINK) {
-		lpfc_start_fdiscs(phba);
-		lpfc_do_scr_ns_plogi(phba, vport);
+		if (vport->cfg_enable_auth)
+			lpfc_get_auth_config(vport, NULL);
+		else
+			lpfc_start_discovery(vport);
 	}
-
 fail_free_mem:
 	mempool_free(mboxq, phba->mbox_mem_pool);
 	lpfc_mbuf_free(phba, dmabuf->virt, dmabuf->phys);
@@ -2257,13 +2350,17 @@ lpfc_mbx_cmpl_unreg_vpi(struct lpfc_hba 
 				 mb->mbxStatus);
 		break;
 	}
+	spin_lock_irq(&phba->hbalock);
+	vport->vpi_state &= ~LPFC_VPI_REGISTERED;
+	vport->fc_flag |= FC_VPORT_NEEDS_REG_VPI;
+	spin_unlock_irq(&phba->hbalock);
 	vport->unreg_vpi_cmpl = VPORT_OK;
 	mempool_free(pmb, phba->mbox_mem_pool);
 	/*
 	 * This shost reference might have been taken at the beginning of
 	 * lpfc_vport_delete()
 	 */
-	if (vport->load_flag & FC_UNLOADING)
+	if ((vport->load_flag & FC_UNLOADING) && (vport != phba->pport))
 		scsi_host_put(shost);
 }
 
@@ -2314,6 +2411,8 @@ lpfc_mbx_cmpl_reg_vpi(struct lpfc_hba *p
 		goto out;
 	}
 
+	vport->vpi_state |= LPFC_VPI_REGISTERED;
+	vport->fc_flag &= ~FC_VPORT_NEEDS_REG_VPI;
 	vport->num_disc_nodes = 0;
 	/* go thru NPR list and issue ELS PLOGIs */
 	if (vport->fc_npr_cnt)
@@ -2522,8 +2621,10 @@ lpfc_mbx_cmpl_fabric_reg_login(struct lp
 	lpfc_nlp_set_state(vport, ndlp, NLP_STE_UNMAPPED_NODE);
 
 	if (vport->port_state == LPFC_FABRIC_CFG_LINK) {
-		lpfc_start_fdiscs(phba);
-		lpfc_do_scr_ns_plogi(phba, vport);
+		if (vport->cfg_enable_auth)
+			lpfc_get_auth_config(vport, NULL);
+		else
+			lpfc_start_discovery(vport);
 	}
 
 	lpfc_mbuf_free(phba, mp->virt, mp->phys);
@@ -2908,9 +3009,13 @@ lpfc_initialize_node(struct lpfc_vport *
 {
 	INIT_LIST_HEAD(&ndlp->els_retry_evt.evt_listp);
 	INIT_LIST_HEAD(&ndlp->dev_loss_evt.evt_listp);
+	INIT_LIST_HEAD(&ndlp->els_reauth_evt.evt_listp);
 	init_timer(&ndlp->nlp_delayfunc);
 	ndlp->nlp_delayfunc.function = lpfc_els_retry_delay;
 	ndlp->nlp_delayfunc.data = (unsigned long)ndlp;
+	init_timer(&ndlp->nlp_reauth_tmr);
+	ndlp->nlp_reauth_tmr.function = lpfc_reauth_node;
+	ndlp->nlp_reauth_tmr.data = (unsigned long)ndlp;
 	ndlp->nlp_DID = did;
 	ndlp->vport = vport;
 	ndlp->phba = vport->phba;
@@ -3318,9 +3423,12 @@ lpfc_cleanup_node(struct lpfc_vport *vpo
 
 	ndlp->nlp_last_elscmd = 0;
 	del_timer_sync(&ndlp->nlp_delayfunc);
+	del_timer_sync(&ndlp->nlp_reauth_tmr);
 
 	list_del_init(&ndlp->els_retry_evt.evt_listp);
 	list_del_init(&ndlp->dev_loss_evt.evt_listp);
+	if (!list_empty(&ndlp->els_reauth_evt.evt_listp))
+		list_del_init(&ndlp->els_reauth_evt.evt_listp);
 
 	lpfc_unreg_rpi(vport, ndlp);
 
@@ -4124,7 +4232,14 @@ lpfc_filter_by_wwpn(struct lpfc_nodelist
 		      sizeof(ndlp->nlp_portname)) == 0;
 }
 
-static struct lpfc_nodelist *
+static int
+lpfc_filter_by_wwnn(struct lpfc_nodelist *ndlp, void *param)
+{
+	return memcmp(&ndlp->nlp_nodename, param,
+		      sizeof(ndlp->nlp_nodename)) == 0;
+}
+
+struct lpfc_nodelist *
 __lpfc_find_node(struct lpfc_vport *vport, node_filter filter, void *param)
 {
 	struct lpfc_nodelist *ndlp;
@@ -4137,6 +4252,22 @@ __lpfc_find_node(struct lpfc_vport *vpor
 }
 
 /*
+ * Search node lists for a remote port matching filter criteria
+ * Caller needs to hold host_lock before calling this routine.
+ */
+struct lpfc_nodelist *
+lpfc_find_node(struct lpfc_vport *vport, node_filter filter, void *param)
+{
+	struct Scsi_Host     *shost = lpfc_shost_from_vport(vport);
+	struct lpfc_nodelist *ndlp;
+
+	spin_lock_irq(shost->host_lock);
+	ndlp = __lpfc_find_node(vport, filter, param);
+	spin_unlock_irq(shost->host_lock);
+	return ndlp;
+}
+
+/*
  * This routine looks up the ndlp lists for the given RPI. If rpi found it
  * returns the node list element pointer else return NULL.
  */
@@ -4162,6 +4293,21 @@ lpfc_findnode_wwpn(struct lpfc_vport *vp
 	return ndlp;
 }
 
+/*
+ * This routine looks up the ndlp lists for the given WWNN. If WWNN found it
+ * returns the node element list pointer else return NULL.
+ */
+struct lpfc_nodelist *
+lpfc_findnode_wwnn(struct lpfc_vport *vport, struct lpfc_name *wwnn)
+{
+	struct Scsi_Host *shost = lpfc_shost_from_vport(vport);
+	struct lpfc_nodelist *ndlp;
+
+	spin_lock_irq(shost->host_lock);
+	ndlp = __lpfc_find_node(vport, lpfc_filter_by_wwnn, wwnn);
+	spin_unlock_irq(shost->host_lock);
+	return ndlp;
+}
 void
 lpfc_nlp_init(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,
 	      uint32_t did)
@@ -4367,6 +4513,14 @@ lpfc_fcf_inuse(struct lpfc_hba *phba)
 				ret = 1;
 				spin_unlock_irq(shost->host_lock);
 				goto out;
+			} else {
+				lpfc_printf_log(phba, KERN_INFO, LOG_ELS,
+					"2624 RPI %x DID %x flg %x still "
+					"logged in\n",
+					ndlp->nlp_rpi, ndlp->nlp_DID,
+					ndlp->nlp_flag);
+				if (ndlp->nlp_flag & NLP_RPI_VALID)
+					ret = 1;
 			}
 		}
 		spin_unlock_irq(shost->host_lock);
@@ -4435,6 +4589,7 @@ lpfc_unregister_unused_fcf(struct lpfc_h
 	int rc;
 	struct lpfc_vport **vports;
 	int i;
+	struct lpfc_nodelist *ndlp;
 
 	spin_lock_irq(&phba->hbalock);
 	/*
@@ -4462,12 +4617,21 @@ lpfc_unregister_unused_fcf(struct lpfc_h
 	if (vports &&
 		(phba->sli3_options & LPFC_SLI3_NPIV_ENABLED))
 		for (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {
+			/* Stop FLOGI/FDISC retries */
+			ndlp = lpfc_findnode_did(vports[i], Fabric_DID);
+			if (ndlp)
+				lpfc_cancel_retry_delay_tmo(vports[i], ndlp);
 			lpfc_mbx_unreg_vpi(vports[i]);
-			vports[i]->fc_flag |= FC_VPORT_NEEDS_REG_VPI;
-			vports[i]->vfi_state &= ~LPFC_VFI_REGISTERED;
+			spin_lock_irq(&phba->hbalock);
+			vports[i]->fc_flag |= FC_VPORT_NEEDS_INIT_VPI;
+			vports[i]->vpi_state &= ~LPFC_VPI_REGISTERED;
+			spin_unlock_irq(&phba->hbalock);
 		}
 	lpfc_destroy_vport_work_array(phba, vports);
 
+	/* Cleanup any outstanding ELS commands */
+	lpfc_els_flush_all_cmd(phba);
+
 	/* Unregister VFI */
 	mbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);
 	if (!mbox) {
@@ -4492,6 +4656,10 @@ lpfc_unregister_unused_fcf(struct lpfc_h
 		return;
 	}
 
+	spin_lock_irq(&phba->hbalock);
+	phba->pport->fc_flag &= ~FC_VFI_REGISTERED;
+	spin_unlock_irq(&phba->hbalock);
+
 	/* Unregister FCF */
 	mbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);
 	if (!mbox) {
diff -urpN a/drivers/scsi/lpfc/lpfc_hw4.h b/drivers/scsi/lpfc/lpfc_hw4.h
--- a/drivers/scsi/lpfc/lpfc_hw4.h	2010-01-12 16:47:01.078078000 -0500
+++ b/drivers/scsi/lpfc/lpfc_hw4.h	2010-01-12 16:46:28.528798000 -0500
@@ -194,6 +194,26 @@ struct lpfc_sli4_flags {
 #define lpfc_fip_flag_WORD word0
 };
 
+struct sli4_bls_acc {
+	uint32_t word0_rsvd;      /* Word0 must be reserved */
+	uint32_t word1;
+#define lpfc_abts_orig_SHIFT      0
+#define lpfc_abts_orig_MASK       0x00000001
+#define lpfc_abts_orig_WORD       word1
+#define LPFC_ABTS_UNSOL_RSP       1
+#define LPFC_ABTS_UNSOL_INT       0
+	uint32_t word2;
+#define lpfc_abts_rxid_SHIFT      0
+#define lpfc_abts_rxid_MASK       0x0000FFFF
+#define lpfc_abts_rxid_WORD       word2
+#define lpfc_abts_oxid_SHIFT      16
+#define lpfc_abts_oxid_MASK       0x0000FFFF
+#define lpfc_abts_oxid_WORD       word2
+	uint32_t word3;
+	uint32_t word4;
+	uint32_t word5_rsvd;	/* Word5 must be reserved */
+};
+
 /* event queue entry structure */
 struct lpfc_eqe {
 	uint32_t word0;
@@ -453,6 +473,13 @@ struct lpfc_wqe_generic{
 #define lpfc_wqe_gen_wqec_SHIFT		7
 #define lpfc_wqe_gen_wqec_MASK		0x00000001
 #define lpfc_wqe_gen_wqec_WORD		word11
+#define ELS_ID_FLOGI 3
+#define ELS_ID_FDISC 2
+#define ELS_ID_LOGO  1
+#define ELS_ID_DEFAULT 0
+#define lpfc_wqe_gen_els_id_SHIFT	4
+#define lpfc_wqe_gen_els_id_MASK	0x00000003
+#define lpfc_wqe_gen_els_id_WORD	word11
 #define lpfc_wqe_gen_cmd_type_SHIFT	0
 #define lpfc_wqe_gen_cmd_type_MASK	0x0000000F
 #define lpfc_wqe_gen_cmd_type_WORD	word11
@@ -487,8 +514,8 @@ struct lpfc_register {
 
 #define LPFC_UERR_STATUS_HI		0x00A4
 #define LPFC_UERR_STATUS_LO		0x00A0
-#define LPFC_ONLINE0			0x00B0
-#define LPFC_ONLINE1			0x00B4
+#define LPFC_UE_MASK_HI			0x00AC
+#define LPFC_UE_MASK_LO			0x00A8
 #define LPFC_SCRATCHPAD			0x0058
 
 /* BAR0 Registers */
@@ -986,7 +1013,7 @@ struct lpfc_mbx_wq_destroy {
 };
 
 #define LPFC_HDR_BUF_SIZE 128
-#define LPFC_DATA_BUF_SIZE 4096
+#define LPFC_DATA_BUF_SIZE 2048
 struct rq_context {
 	uint32_t word0;
 #define lpfc_rq_context_rq_size_SHIFT	16
@@ -1344,6 +1371,7 @@ struct lpfc_mbx_query_fw_cfg {
 #define STATUS_ERROR_ACITMAIN				0x2a
 #define STATUS_REBOOT_REQUIRED				0x2c
 #define STATUS_FCF_IN_USE				0x3a
+#define STATUS_FCF_TABLE_EMPTY				0x43
 
 struct lpfc_mbx_sli4_config {
 	struct mbox_header header;
@@ -1395,8 +1423,7 @@ struct lpfc_mbx_reg_vfi {
 #define lpfc_reg_vfi_fcfi_SHIFT		0
 #define lpfc_reg_vfi_fcfi_MASK		0x0000FFFF
 #define lpfc_reg_vfi_fcfi_WORD		word2
-	uint32_t word3_rsvd;
-	uint32_t word4_rsvd;
+	uint32_t wwn[2];
 	struct ulp_bde64 bde;
 	uint32_t word8_rsvd;
 	uint32_t word9_rsvd;
@@ -1932,6 +1959,9 @@ struct lpfc_acqe_link {
 #define LPFC_ASYNC_LINK_FAULT_NONE	0x0
 #define LPFC_ASYNC_LINK_FAULT_LOCAL	0x1
 #define LPFC_ASYNC_LINK_FAULT_REMOTE	0x2
+#define lpfc_acqe_qos_link_speed_SHIFT	16
+#define lpfc_acqe_qos_link_speed_MASK	0x0000FFFF
+#define lpfc_acqe_qos_link_speed_WORD	word1
 	uint32_t event_tag;
 	uint32_t trailer;
 };
@@ -1974,7 +2004,8 @@ struct lpfc_bmbx_create {
 #define SGL_ALIGN_SZ 64
 #define SGL_PAGE_SIZE 4096
 /* align SGL addr on a size boundary - adjust address up */
-#define NO_XRI ((uint16_t)-1)
+#define NO_XRI  ((uint16_t)-1)
+
 struct wqe_common {
 	uint32_t word6;
 #define wqe_xri_tag_SHIFT     0
diff -urpN a/drivers/scsi/lpfc/lpfc_hw.h b/drivers/scsi/lpfc/lpfc_hw.h
--- a/drivers/scsi/lpfc/lpfc_hw.h	2010-01-12 16:47:01.091079000 -0500
+++ b/drivers/scsi/lpfc/lpfc_hw.h	2010-01-12 16:46:28.563800000 -0500
@@ -353,7 +353,8 @@ struct csp {
 
 	uint16_t huntgroup:1;	/* FC Word 1, bit 23 */
 	uint16_t simplex:1;	/* FC Word 1, bit 22 */
-	uint16_t word1Reserved1:3;	/* FC Word 1, bit 21:19 */
+	uint16_t security:1;    /* FC Word 1, bit 21 */
+	uint16_t word1Reserved1:2;	/* FC Word 1, bit 20:19 */
 	uint16_t dhd:1;		/* FC Word 1, bit 18 */
 	uint16_t contIncSeqCnt:1;	/* FC Word 1, bit 17 */
 	uint16_t payloadlength:1;	/* FC Word 1, bit 16 */
@@ -370,7 +371,8 @@ struct csp {
 	uint16_t payloadlength:1;	/* FC Word 1, bit 16 */
 	uint16_t contIncSeqCnt:1;	/* FC Word 1, bit 17 */
 	uint16_t dhd:1;		/* FC Word 1, bit 18 */
-	uint16_t word1Reserved1:3;	/* FC Word 1, bit 21:19 */
+	uint16_t word1Reserved1:2;	/* FC Word 1, bit 20:19 */
+	 uint16_t security:1;    /* FC Word 1, bit 21 */
 	uint16_t simplex:1;	/* FC Word 1, bit 22 */
 	uint16_t huntgroup:1;	/* FC Word 1, bit 23 */
 #endif
@@ -538,6 +540,17 @@ struct fc_vft_header {
 #define ELS_CMD_SCR       0x62000000
 #define ELS_CMD_RNID      0x78000000
 #define ELS_CMD_LIRR      0x7A000000
+/*
+ * ELS commands for authentication
+ * ELS_CMD_AUTH<<24 | AUTH_NEGOTIATE<<8 | AUTH_VERSION
+ */
+#define ELS_CMD_AUTH      0x90000000
+#define ELS_CMD_AUTH_RJT  0x90000A01
+#define ELS_CMD_AUTH_NEG  0x90000B01
+#define ELS_CMD_AUTH_DONE 0x90000C01
+#define ELS_CMD_DH_CHA    0x90001001
+#define ELS_CMD_DH_REP    0x90001101
+#define ELS_CMD_DH_SUC    0x90001201
 #else	/*  __LITTLE_ENDIAN_BITFIELD */
 #define ELS_CMD_MASK      0xffff
 #define ELS_RSP_MASK      0xff
@@ -574,6 +587,17 @@ struct fc_vft_header {
 #define ELS_CMD_SCR       0x62
 #define ELS_CMD_RNID      0x78
 #define ELS_CMD_LIRR      0x7A
+/*
+ * ELS commands for authentication
+ * ELS_CMD_AUTH | AUTH_NEGOTIATE<<16 | AUTH_VERSION<<24
+ */
+#define ELS_CMD_AUTH      0x00000090
+#define ELS_CMD_AUTH_RJT  0x010A0090
+#define ELS_CMD_AUTH_NEG  0x010B0090
+#define ELS_CMD_AUTH_DONE 0x010C0090
+#define ELS_CMD_DH_CHA    0x01100090
+#define ELS_CMD_DH_REP    0x01110090
+#define ELS_CMD_DH_SUC    0x01120090
 #endif
 
 /*
@@ -1168,7 +1192,8 @@ typedef struct {
 #define PCI_DEVICE_ID_ZEPHYR_DCSP   0xfe12
 #define PCI_VENDOR_ID_SERVERENGINE  0x19a2
 #define PCI_DEVICE_ID_TIGERSHARK    0x0704
-#define PCI_DEVICE_ID_TS_BE3        0x0714
+#define PCI_DEVICE_ID_TOMCAT        0x0714
+#define PCI_DEVICE_ID_FALCON        0xf180
 
 #define JEDEC_ID_ADDRESS            0x0080001c
 #define FIREFLY_JEDEC_ID            0x1ACC
@@ -2293,8 +2318,7 @@ typedef struct {
 	uint32_t rsvd1;
 	uint32_t rsvd2:8;
 	uint32_t sid:24;
-	uint32_t rsvd3;
-	uint32_t rsvd4;
+	uint32_t wwn[2];
 	uint32_t rsvd5;
 	uint16_t vfi;
 	uint16_t vpi;
@@ -2302,8 +2326,7 @@ typedef struct {
 	uint32_t rsvd1;
 	uint32_t sid:24;
 	uint32_t rsvd2:8;
-	uint32_t rsvd3;
-	uint32_t rsvd4;
+	uint32_t wwn[2];
 	uint32_t rsvd5;
 	uint16_t vpi;
 	uint16_t vfi;
@@ -3540,7 +3563,7 @@ typedef struct _IOCB {	/* IOCB structure
 		ASYNCSTAT_FIELDS asyncstat; /* async_status iocb */
 		QUE_XRI64_CX_FIELDS quexri64cx; /* que_xri64_cx fields */
 		struct rcv_seq64 rcvseq64;	/* RCV_SEQ64 and RCV_CONT64 */
-
+		struct sli4_bls_acc bls_acc; /* UNSOL ABTS BLS_ACC params */
 		uint32_t ulpWord[IOCB_WORD_SZ - 2];	/* generic 6 'words' */
 	} un;
 	union {
diff -urpN a/drivers/scsi/lpfc/lpfc_init.c b/drivers/scsi/lpfc/lpfc_init.c
--- a/drivers/scsi/lpfc/lpfc_init.c	2010-01-12 16:47:01.117079000 -0500
+++ b/drivers/scsi/lpfc/lpfc_init.c	2010-01-12 16:46:28.595798000 -0500
@@ -47,6 +47,14 @@
 #include "lpfc_crtn.h"
 #include "lpfc_vport.h"
 #include "lpfc_version.h"
+#include "lpfc_auth_access.h"
+#include "lpfc_security.h"
+#include <net/sock.h>
+#include <linux/netlink.h>
+
+/* vendor ID used in SCSI netlink calls */
+#define LPFC_NL_VENDOR_ID (SCSI_NL_VID_TYPE_PCI | PCI_VENDOR_ID_EMULEX)
+const char *security_work_q_name = "fc_sc_wq";
 
 char *_dump_buf_data;
 unsigned long _dump_buf_data_order;
@@ -528,6 +536,9 @@ lpfc_config_port_post(struct lpfc_hba *p
 	/* Set up error attention (ERATT) polling timer */
 	mod_timer(&phba->eratt_poll, jiffies + HZ * LPFC_ERATT_POLL_INTERVAL);
 
+	if (vport->cfg_enable_auth &&
+	    vport->security_service_state == SECURITY_OFFLINE)
+			vport->auth.auth_mode = FC_AUTHMODE_UNKNOWN;
 	if (phba->hba_flag & LINK_DISABLED) {
 		lpfc_printf_log(phba,
 			KERN_ERR, LOG_INIT,
@@ -1182,8 +1193,7 @@ lpfc_handle_eratt_s3(struct lpfc_hba *ph
 		fc_host_post_vendor_event(shost, fc_get_event_number(),
 					  sizeof(temp_event_data),
 					  (char *) &temp_event_data,
-					  SCSI_NL_VID_TYPE_PCI
-					  | PCI_VENDOR_ID_EMULEX);
+					  LPFC_NL_VENDOR_ID);
 
 		spin_lock_irq(&phba->hbalock);
 		phba->over_temp_state = HBA_OVER_TEMP;
@@ -1205,7 +1215,7 @@ lpfc_handle_eratt_s3(struct lpfc_hba *ph
 		shost = lpfc_shost_from_vport(vport);
 		fc_host_post_vendor_event(shost, fc_get_event_number(),
 				sizeof(event_data), (char *) &event_data,
-				SCSI_NL_VID_TYPE_PCI | PCI_VENDOR_ID_EMULEX);
+				LPFC_NL_VENDOR_ID);
 
 		lpfc_offline_eratt(phba);
 	}
@@ -1529,10 +1539,10 @@ lpfc_get_hba_model_desc(struct lpfc_hba 
 	int GE = 0;
 	int oneConnect = 0; /* default is not a oneConnect */
 	struct {
-		char * name;
-		int    max_speed;
-		char * bus;
-	} m = {"<Unknown>", 0, ""};
+		char *name;
+		char *bus;
+		char *function;
+	} m = {"<Unknown>", "", ""};
 
 	if (mdp && mdp[0] != '\0'
 		&& descp && descp[0] != '\0')
@@ -1553,136 +1563,155 @@ lpfc_get_hba_model_desc(struct lpfc_hba 
 
 	switch (dev_id) {
 	case PCI_DEVICE_ID_FIREFLY:
-		m = (typeof(m)){"LP6000", max_speed, "PCI"};
+		m = (typeof(m)){"LP6000", "PCI", "Fibre Channel Adapter"};
 		break;
 	case PCI_DEVICE_ID_SUPERFLY:
 		if (vp->rev.biuRev >= 1 && vp->rev.biuRev <= 3)
-			m = (typeof(m)){"LP7000", max_speed,  "PCI"};
+			m = (typeof(m)){"LP7000", "PCI",
+					"Fibre Channel Adapter"};
 		else
-			m = (typeof(m)){"LP7000E", max_speed, "PCI"};
+			m = (typeof(m)){"LP7000E", "PCI",
+					"Fibre Channel Adapter"};
 		break;
 	case PCI_DEVICE_ID_DRAGONFLY:
-		m = (typeof(m)){"LP8000", max_speed, "PCI"};
+		m = (typeof(m)){"LP8000", "PCI",
+				"Fibre Channel Adapter"};
 		break;
 	case PCI_DEVICE_ID_CENTAUR:
 		if (FC_JEDEC_ID(vp->rev.biuRev) == CENTAUR_2G_JEDEC_ID)
-			m = (typeof(m)){"LP9002", max_speed, "PCI"};
+			m = (typeof(m)){"LP9002", "PCI",
+					"Fibre Channel Adapter"};
 		else
-			m = (typeof(m)){"LP9000", max_speed, "PCI"};
+			m = (typeof(m)){"LP9000", "PCI",
+					"Fibre Channel Adapter"};
 		break;
 	case PCI_DEVICE_ID_RFLY:
-		m = (typeof(m)){"LP952", max_speed, "PCI"};
+		m = (typeof(m)){"LP952", "PCI",
+				"Fibre Channel Adapter"};
 		break;
 	case PCI_DEVICE_ID_PEGASUS:
-		m = (typeof(m)){"LP9802", max_speed, "PCI-X"};
+		m = (typeof(m)){"LP9802", "PCI-X",
+				"Fibre Channel Adapter"};
 		break;
 	case PCI_DEVICE_ID_THOR:
-		m = (typeof(m)){"LP10000", max_speed, "PCI-X"};
+		m = (typeof(m)){"LP10000", "PCI-X",
+				"Fibre Channel Adapter"};
 		break;
 	case PCI_DEVICE_ID_VIPER:
-		m = (typeof(m)){"LPX1000", max_speed,  "PCI-X"};
+		m = (typeof(m)){"LPX1000",  "PCI-X",
+				"Fibre Channel Adapter"};
 		break;
 	case PCI_DEVICE_ID_PFLY:
-		m = (typeof(m)){"LP982", max_speed, "PCI-X"};
+		m = (typeof(m)){"LP982", "PCI-X",
+				"Fibre Channel Adapter"};
 		break;
 	case PCI_DEVICE_ID_TFLY:
-		m = (typeof(m)){"LP1050", max_speed, "PCI-X"};
+		m = (typeof(m)){"LP1050", "PCI-X",
+				"Fibre Channel Adapter"};
 		break;
 	case PCI_DEVICE_ID_HELIOS:
-		m = (typeof(m)){"LP11000", max_speed, "PCI-X2"};
+		m = (typeof(m)){"LP11000", "PCI-X2",
+				"Fibre Channel Adapter"};
 		break;
 	case PCI_DEVICE_ID_HELIOS_SCSP:
-		m = (typeof(m)){"LP11000-SP", max_speed, "PCI-X2"};
+		m = (typeof(m)){"LP11000-SP", "PCI-X2",
+				"Fibre Channel Adapter"};
 		break;
 	case PCI_DEVICE_ID_HELIOS_DCSP:
-		m = (typeof(m)){"LP11002-SP", max_speed, "PCI-X2"};
+		m = (typeof(m)){"LP11002-SP",  "PCI-X2",
+				"Fibre Channel Adapter"};
 		break;
 	case PCI_DEVICE_ID_NEPTUNE:
-		m = (typeof(m)){"LPe1000", max_speed, "PCIe"};
+		m = (typeof(m)){"LPe1000", "PCIe", "Fibre Channel Adapter"};
 		break;
 	case PCI_DEVICE_ID_NEPTUNE_SCSP:
-		m = (typeof(m)){"LPe1000-SP", max_speed, "PCIe"};
+		m = (typeof(m)){"LPe1000-SP", "PCIe", "Fibre Channel Adapter"};
 		break;
 	case PCI_DEVICE_ID_NEPTUNE_DCSP:
-		m = (typeof(m)){"LPe1002-SP", max_speed, "PCIe"};
+		m = (typeof(m)){"LPe1002-SP", "PCIe", "Fibre Channel Adapter"};
 		break;
 	case PCI_DEVICE_ID_BMID:
-		m = (typeof(m)){"LP1150", max_speed, "PCI-X2"};
+		m = (typeof(m)){"LP1150", "PCI-X2", "Fibre Channel Adapter"};
 		break;
 	case PCI_DEVICE_ID_BSMB:
-		m = (typeof(m)){"LP111", max_speed, "PCI-X2"};
+		m = (typeof(m)){"LP111", "PCI-X2", "Fibre Channel Adapter"};
 		break;
 	case PCI_DEVICE_ID_ZEPHYR:
-		m = (typeof(m)){"LPe11000", max_speed, "PCIe"};
+		m = (typeof(m)){"LPe11000", "PCIe", "Fibre Channel Adapter"};
 		break;
 	case PCI_DEVICE_ID_ZEPHYR_SCSP:
-		m = (typeof(m)){"LPe11000", max_speed, "PCIe"};
+		m = (typeof(m)){"LPe11000", "PCIe", "Fibre Channel Adapter"};
 		break;
 	case PCI_DEVICE_ID_ZEPHYR_DCSP:
-		m = (typeof(m)){"LP2105", max_speed, "PCIe"};
+		m = (typeof(m)){"LP2105", "PCIe", "FCoE Adapter"};
 		GE = 1;
 		break;
 	case PCI_DEVICE_ID_ZMID:
-		m = (typeof(m)){"LPe1150", max_speed, "PCIe"};
+		m = (typeof(m)){"LPe1150", "PCIe", "Fibre Channel Adapter"};
 		break;
 	case PCI_DEVICE_ID_ZSMB:
-		m = (typeof(m)){"LPe111", max_speed, "PCIe"};
+		m = (typeof(m)){"LPe111", "PCIe", "Fibre Channel Adapter"};
 		break;
 	case PCI_DEVICE_ID_LP101:
-		m = (typeof(m)){"LP101", max_speed, "PCI-X"};
+		m = (typeof(m)){"LP101", "PCI-X", "Fibre Channel Adapter"};
 		break;
 	case PCI_DEVICE_ID_LP10000S:
-		m = (typeof(m)){"LP10000-S", max_speed, "PCI"};
+		m = (typeof(m)){"LP10000-S", "PCI", "Fibre Channel Adapter"};
 		break;
 	case PCI_DEVICE_ID_LP11000S:
-		m = (typeof(m)){"LP11000-S", max_speed,
-			"PCI-X2"};
+		m = (typeof(m)){"LP11000-S", "PCI-X2", "Fibre Channel Adapter"};
 		break;
 	case PCI_DEVICE_ID_LPE11000S:
-		m = (typeof(m)){"LPe11000-S", max_speed,
-			"PCIe"};
+		m = (typeof(m)){"LPe11000-S", "PCIe", "Fibre Channel Adapter"};
 		break;
 	case PCI_DEVICE_ID_SAT:
-		m = (typeof(m)){"LPe12000", max_speed, "PCIe"};
+		m = (typeof(m)){"LPe12000", "PCIe", "Fibre Channel Adapter"};
 		break;
 	case PCI_DEVICE_ID_SAT_MID:
-		m = (typeof(m)){"LPe1250", max_speed, "PCIe"};
+		m = (typeof(m)){"LPe1250", "PCIe", "Fibre Channel Adapter"};
 		break;
 	case PCI_DEVICE_ID_SAT_SMB:
-		m = (typeof(m)){"LPe121", max_speed, "PCIe"};
+		m = (typeof(m)){"LPe121", "PCIe", "Fibre Channel Adapter"};
 		break;
 	case PCI_DEVICE_ID_SAT_DCSP:
-		m = (typeof(m)){"LPe12002-SP", max_speed, "PCIe"};
+		m = (typeof(m)){"LPe12002-SP", "PCIe", "Fibre Channel Adapter"};
 		break;
 	case PCI_DEVICE_ID_SAT_SCSP:
-		m = (typeof(m)){"LPe12000-SP", max_speed, "PCIe"};
+		m = (typeof(m)){"LPe12000-SP", "PCIe", "Fibre Channel Adapter"};
 		break;
 	case PCI_DEVICE_ID_SAT_S:
-		m = (typeof(m)){"LPe12000-S", max_speed, "PCIe"};
+		m = (typeof(m)){"LPe12000-S", "PCIe", "Fibre Channel Adapter"};
 		break;
 	case PCI_DEVICE_ID_HORNET:
-		m = (typeof(m)){"LP21000", max_speed, "PCIe"};
+		m = (typeof(m)){"LP21000", "PCIe", "FCoE Adapter"};
 		GE = 1;
 		break;
 	case PCI_DEVICE_ID_PROTEUS_VF:
-		m = (typeof(m)) {"LPev12000", max_speed, "PCIe IOV"};
+		m = (typeof(m)){"LPev12000", "PCIe IOV",
+				"Fibre Channel Adapter"};
 		break;
 	case PCI_DEVICE_ID_PROTEUS_PF:
-		m = (typeof(m)) {"LPev12000", max_speed, "PCIe IOV"};
+		m = (typeof(m)){"LPev12000", "PCIe IOV",
+				"Fibre Channel Adapter"};
 		break;
 	case PCI_DEVICE_ID_PROTEUS_S:
-		m = (typeof(m)) {"LPemv12002-S", max_speed, "PCIe IOV"};
+		m = (typeof(m)){"LPemv12002-S", "PCIe IOV",
+				"Fibre Channel Adapter"};
 		break;
 	case PCI_DEVICE_ID_TIGERSHARK:
 		oneConnect = 1;
-		m = (typeof(m)) {"OCe10100-F", max_speed, "PCIe"};
+		m = (typeof(m)){"OCe10100", "PCIe", "FCoE"};
 		break;
-	case PCI_DEVICE_ID_TS_BE3:
+	case PCI_DEVICE_ID_TOMCAT:
 		oneConnect = 1;
-		m = (typeof(m)) {"OCeXXXXX-F", max_speed, "PCIe"};
+		m = (typeof(m)){"OCe11100", "PCIe", "FCoE"};
+		break;
+	case PCI_DEVICE_ID_FALCON:
+		m = (typeof(m)){"LPSe12002-ML1-E", "PCIe",
+				"EmulexSecure Fibre"};
 		break;
 	default:
-		m = (typeof(m)){ NULL };
+		m = (typeof(m)){"Unknown", "", ""};
 		break;
 	}
 
@@ -1694,17 +1723,14 @@ lpfc_get_hba_model_desc(struct lpfc_hba 
 	if (descp && descp[0] == '\0') {
 		if (oneConnect)
 			snprintf(descp, 255,
-				"Emulex OneConnect %s, FCoE Initiator, Port %s",
-				m.name,
+				"Emulex OneConnect %s, %s Initiator, Port %s",
+				m.name, m.function,
 				phba->Port);
 		else
 			snprintf(descp, 255,
 				"Emulex %s %d%s %s %s",
-				m.name, m.max_speed,
-				(GE) ? "GE" : "Gb",
-				m.bus,
-				(GE) ? "FCoE Adapter" :
-					"Fibre Channel Adapter");
+				m.name, max_speed, (GE) ? "GE" : "Gb",
+				m.bus, m.function);
 	}
 }
 
@@ -2050,8 +2076,17 @@ lpfc_cleanup(struct lpfc_vport *vport)
 void
 lpfc_stop_vport_timers(struct lpfc_vport *vport)
 {
+	struct fc_security_request *fc_sc_req;
 	del_timer_sync(&vport->els_tmofunc);
 	del_timer_sync(&vport->fc_fdmitmo);
+	while (!list_empty(&vport->sc_response_wait_queue)) {
+		list_remove_head(&vport->sc_response_wait_queue, fc_sc_req,
+					   struct fc_security_request, rlist);
+		if (!fc_sc_req)
+			continue;
+		del_timer_sync(&fc_sc_req->timer);
+		kfree(fc_sc_req);
+	}
 	lpfc_can_disctmo(vport);
 	return;
 }
@@ -2229,7 +2264,10 @@ lpfc_offline_prep(struct lpfc_hba * phba
 
 			if (vports[i]->load_flag & FC_UNLOADING)
 				continue;
-			vports[i]->vfi_state &= ~LPFC_VFI_REGISTERED;
+			vports[i]->vpi_state &= ~LPFC_VPI_REGISTERED;
+			vports[i]->fc_flag |= FC_VPORT_NEEDS_REG_VPI;
+			vports[i]->fc_flag &= ~FC_VFI_REGISTERED;
+
 			shost =	lpfc_shost_from_vport(vports[i]);
 			list_for_each_entry_safe(ndlp, next_ndlp,
 						 &vports[i]->fc_nodes,
@@ -2320,6 +2358,7 @@ lpfc_scsi_free(struct lpfc_hba *phba)
 
 	spin_lock_irq(&phba->hbalock);
 	/* Release all the lpfc_scsi_bufs maintained by this host. */
+	spin_lock(&phba->scsi_buf_list_lock);
 	list_for_each_entry_safe(sb, sb_next, &phba->lpfc_scsi_buf_list, list) {
 		list_del(&sb->list);
 		pci_pool_free(phba->lpfc_scsi_dma_buf_pool, sb->data,
@@ -2327,6 +2366,7 @@ lpfc_scsi_free(struct lpfc_hba *phba)
 		kfree(sb);
 		phba->total_scsi_bufs--;
 	}
+	spin_unlock(&phba->scsi_buf_list_lock);
 
 	/* Release all the lpfc_iocbq entries maintained by this host. */
 	list_for_each_entry_safe(io, io_next, &phba->lpfc_iocb_list, list) {
@@ -2334,9 +2374,7 @@ lpfc_scsi_free(struct lpfc_hba *phba)
 		kfree(io);
 		phba->total_iocbq_bufs--;
 	}
-
 	spin_unlock_irq(&phba->hbalock);
-
 	return 0;
 }
 
@@ -2378,6 +2416,12 @@ lpfc_create_port(struct lpfc_hba *phba, 
 	vport->fc_flag |= FC_VPORT_NEEDS_REG_VPI;
 	vport->fc_rscn_flush = 0;
 
+	INIT_WORK(&vport->sc_online_work, lpfc_fc_sc_security_online);
+	INIT_WORK(&vport->sc_offline_work, lpfc_fc_sc_security_offline);
+	INIT_LIST_HEAD(&vport->sc_users);
+	INIT_LIST_HEAD(&vport->sc_response_wait_queue);
+	vport->security_service_state = SECURITY_OFFLINE;
+
 	lpfc_get_vport_cfgparam(vport);
 	shost->unique_id = instance;
 	shost->max_id = LPFC_MAX_TARGET;
@@ -2420,9 +2464,13 @@ lpfc_create_port(struct lpfc_hba *phba, 
 	vport->els_tmofunc.function = lpfc_els_timeout;
 	vport->els_tmofunc.data = (unsigned long)vport;
 
-	error = scsi_add_host_with_dma(shost, dev, &phba->pcidev->dev);
+	error = scsi_add_host(shost, dev);
 	if (error)
 		goto out_put_shost;
+	vport->auth.challenge = NULL;
+	vport->auth.challenge_len = 0;
+	vport->auth.dh_pub_key = NULL;
+	vport->auth.dh_pub_key_len = 0;
 
 	spin_lock_irq(&phba->hbalock);
 	list_add_tail(&vport->listentry, &phba->port_list);
@@ -2962,6 +3010,8 @@ lpfc_sli4_async_link_evt(struct lpfc_hba
 				bf_get(lpfc_acqe_link_physical, acqe_link);
 	phba->sli4_hba.link_state.fault =
 				bf_get(lpfc_acqe_link_fault, acqe_link);
+	phba->sli4_hba.link_state.logical_speed =
+				bf_get(lpfc_acqe_qos_link_speed, acqe_link);
 
 	/* Invoke the lpfc_handle_latt mailbox command callback function */
 	lpfc_mbx_cmpl_read_la(phba, pmb);
@@ -2990,6 +3040,10 @@ lpfc_sli4_async_fcoe_evt(struct lpfc_hba
 	struct lpfc_vport *vport;
 	struct lpfc_nodelist *ndlp;
 	struct Scsi_Host  *shost;
+	uint32_t link_state;
+	int active_vlink_present;
+	struct lpfc_vport **vports;
+	int i;
 
 	phba->fc_eventTag = acqe_fcoe->event_tag;
 	phba->fcoe_eventtag = acqe_fcoe->event_tag;
@@ -3036,9 +3090,12 @@ lpfc_sli4_async_fcoe_evt(struct lpfc_hba
 			break;
 		/*
 		 * Currently, driver support only one FCF - so treat this as
-		 * a link down.
+		 * a link down, but save the link state because we don't want
+		 * it to be changed to Link Down unless it is already down.
 		 */
+		link_state = phba->link_state;
 		lpfc_linkdown(phba);
+		phba->link_state = link_state;
 		/* Unregister FCF if no devices connected to it */
 		lpfc_unregister_unused_fcf(phba);
 		break;
@@ -3047,21 +3104,53 @@ lpfc_sli4_async_fcoe_evt(struct lpfc_hba
 			"2718 Clear Virtual Link Received for VPI 0x%x"
 			" tag 0x%x\n", acqe_fcoe->index, acqe_fcoe->event_tag);
 		vport = lpfc_find_vport_by_vpid(phba,
-				acqe_fcoe->index /*- phba->vpi_base*/);
+				acqe_fcoe->index - phba->vpi_base);
 		if (!vport)
 			break;
 		ndlp = lpfc_findnode_did(vport, Fabric_DID);
 		if (!ndlp)
 			break;
 		shost = lpfc_shost_from_vport(vport);
+		if (phba->pport->port_state <= LPFC_FLOGI)
+			break;
+		/* If virtual link is not yet instantiated ignore CVL */
+		if (vport->port_state <= LPFC_FDISC)
+			break;
+
 		lpfc_linkdown_port(vport);
-		if (vport->port_type != LPFC_NPIV_PORT) {
+		lpfc_cleanup_pending_mbox(vport);
+		spin_lock_irq(shost->host_lock);
+		vport->fc_flag |= FC_VPORT_CVL_RCVD;
+		spin_unlock_irq(shost->host_lock);
+		active_vlink_present = 0;
+
+		vports = lpfc_create_vport_work_array(phba);
+		if (vports) {
+			for (i = 0; i <= phba->max_vports && vports[i] != NULL;
+					i++) {
+				if ((!(vports[i]->fc_flag &
+					FC_VPORT_CVL_RCVD)) &&
+					(vports[i]->port_state > LPFC_FDISC)) {
+					active_vlink_present = 1;
+					break;
+				}
+			}
+			lpfc_destroy_vport_work_array(phba, vports);
+		}
+
+		if (active_vlink_present) {
+			/*
+			 * If there are other active VLinks present,
+			 * re-instantiate the Vlink using FDISC.
+			 */
 			mod_timer(&ndlp->nlp_delayfunc, jiffies + HZ);
 			spin_lock_irq(shost->host_lock);
 			ndlp->nlp_flag |= NLP_DELAY_TMO;
 			spin_unlock_irq(shost->host_lock);
-			ndlp->nlp_last_elscmd = ELS_CMD_FLOGI;
-			vport->port_state = LPFC_FLOGI;
+			ndlp->nlp_last_elscmd = ELS_CMD_FDISC;
+			vport->port_state = LPFC_FDISC;
+		} else {
+			lpfc_retry_pport_discovery(phba);
 		}
 		break;
 	default:
@@ -4618,7 +4707,6 @@ int
 lpfc_sli4_post_status_check(struct lpfc_hba *phba)
 {
 	struct lpfc_register sta_reg, uerrlo_reg, uerrhi_reg, scratchpad;
-	uint32_t onlnreg0, onlnreg1;
 	int i, port_error = -ENODEV;
 
 	if (!phba->sli4_hba.STAregaddr)
@@ -4662,21 +4750,20 @@ lpfc_sli4_post_status_check(struct lpfc_
 			bf_get(lpfc_scratchpad_slirev, &scratchpad),
 			bf_get(lpfc_scratchpad_featurelevel1, &scratchpad),
 			bf_get(lpfc_scratchpad_featurelevel2, &scratchpad));
-
+	phba->sli4_hba.ue_mask_lo = readl(phba->sli4_hba.UEMASKLOregaddr);
+	phba->sli4_hba.ue_mask_hi = readl(phba->sli4_hba.UEMASKHIregaddr);
 	/* With uncoverable error, log the error message and return error */
-	onlnreg0 = readl(phba->sli4_hba.ONLINE0regaddr);
-	onlnreg1 = readl(phba->sli4_hba.ONLINE1regaddr);
-	if ((onlnreg0 != LPFC_ONLINE_NERR) || (onlnreg1 != LPFC_ONLINE_NERR)) {
-		uerrlo_reg.word0 = readl(phba->sli4_hba.UERRLOregaddr);
-		uerrhi_reg.word0 = readl(phba->sli4_hba.UERRHIregaddr);
-		if (uerrlo_reg.word0 || uerrhi_reg.word0) {
-			lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
-					"1422 HBA Unrecoverable error: "
-					"uerr_lo_reg=0x%x, uerr_hi_reg=0x%x, "
-					"online0_reg=0x%x, online1_reg=0x%x\n",
-					uerrlo_reg.word0, uerrhi_reg.word0,
-					onlnreg0, onlnreg1);
-		}
+	uerrlo_reg.word0 = readl(phba->sli4_hba.UERRLOregaddr);
+	uerrhi_reg.word0 = readl(phba->sli4_hba.UERRHIregaddr);
+	if ((~phba->sli4_hba.ue_mask_lo & uerrlo_reg.word0) ||
+	    (~phba->sli4_hba.ue_mask_hi & uerrhi_reg.word0)) {
+		lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
+				"1422 HBA Unrecoverable error: "
+				"uerr_lo_reg=0x%x, uerr_hi_reg=0x%x, "
+				"ue_mask_lo_reg=0x%x, ue_mask_hi_reg=0x%x\n",
+				uerrlo_reg.word0, uerrhi_reg.word0,
+				phba->sli4_hba.ue_mask_lo,
+				phba->sli4_hba.ue_mask_hi);
 		return -ENODEV;
 	}
 
@@ -4697,10 +4784,10 @@ lpfc_sli4_bar0_register_memmap(struct lp
 					LPFC_UERR_STATUS_LO;
 	phba->sli4_hba.UERRHIregaddr = phba->sli4_hba.conf_regs_memmap_p +
 					LPFC_UERR_STATUS_HI;
-	phba->sli4_hba.ONLINE0regaddr = phba->sli4_hba.conf_regs_memmap_p +
-					LPFC_ONLINE0;
-	phba->sli4_hba.ONLINE1regaddr = phba->sli4_hba.conf_regs_memmap_p +
-					LPFC_ONLINE1;
+	phba->sli4_hba.UEMASKLOregaddr = phba->sli4_hba.conf_regs_memmap_p +
+					LPFC_UE_MASK_LO;
+	phba->sli4_hba.UEMASKHIregaddr = phba->sli4_hba.conf_regs_memmap_p +
+					LPFC_UE_MASK_HI;
 	phba->sli4_hba.SCRATCHPADregaddr = phba->sli4_hba.conf_regs_memmap_p +
 					LPFC_SCRATCHPAD;
 }
@@ -4931,7 +5018,8 @@ lpfc_sli4_read_config(struct lpfc_hba *p
 		phba->vpi_base = phba->sli4_hba.max_cfg_param.vpi_base;
 		phba->vfi_base = phba->sli4_hba.max_cfg_param.vfi_base;
 		phba->sli4_hba.next_rpi = phba->sli4_hba.max_cfg_param.rpi_base;
-		phba->max_vpi = phba->sli4_hba.max_cfg_param.max_vpi;
+		phba->max_vpi = (phba->sli4_hba.max_cfg_param.max_vpi > 0) ?
+				(phba->sli4_hba.max_cfg_param.max_vpi - 1) : 0;
 		phba->max_vports = phba->max_vpi;
 		lpfc_printf_log(phba, KERN_INFO, LOG_SLI,
 				"2003 cfg params XRI(B:%d M:%d), "
@@ -6860,6 +6948,7 @@ lpfc_pci_probe_one_s3(struct pci_dev *pd
 
 	/* Configure sysfs attributes */
 	vport = phba->pport;
+	shost = lpfc_shost_from_vport(vport);
 	error = lpfc_alloc_sysfs_attr(vport);
 	if (error) {
 		lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
@@ -6867,6 +6956,18 @@ lpfc_pci_probe_one_s3(struct pci_dev *pd
 		goto out_destroy_shost;
 	}
 
+	/* Add this shost to the security event list */
+	if ((lpfc_get_security_enabled)(shost)) {
+		spin_lock_irq(&fc_security_user_lock);
+		list_add_tail(&vport->sc_users, &fc_security_user_list);
+		spin_unlock_irq(&fc_security_user_lock);
+		/* Triggers fcauthd to register if it is running */
+		fc_host_post_event(shost, fc_get_event_number(),
+				   FCH_EVT_PORT_ONLINE, shost->host_no);
+		if (fc_service_state == FC_SC_SERVICESTATE_ONLINE)
+			lpfc_fc_queue_security_work(vport,
+						    &vport->sc_online_work);
+	}
 	shost = lpfc_shost_from_vport(vport); /* save shost for error cleanup */
 	/* Now, trying to enable interrupt and bring up the device */
 	cfg_mode = phba->cfg_use_msi;
@@ -6922,6 +7023,11 @@ out_remove_device:
 	lpfc_unset_hba(phba);
 out_free_sysfs_attr:
 	lpfc_free_sysfs_attr(vport);
+	if ((lpfc_get_security_enabled)(shost)) {
+		spin_lock_irq(&fc_security_user_lock);
+		list_del(&vport->sc_users);
+		spin_unlock_irq(&fc_security_user_lock);
+	}
 out_destroy_shost:
 	lpfc_destroy_shost(phba);
 out_unset_driver_resource:
@@ -7141,6 +7247,28 @@ lpfc_pci_resume_one_s3(struct pci_dev *p
 }
 
 /**
+ * lpfc_sli_prep_dev_for_recover - Prepare SLI3 device for pci slot recover
+ * @phba: pointer to lpfc hba data structure.
+ *
+ * This routine is called to prepare the SLI3 device for PCI slot recover. It
+ * aborts and stops all the on-going I/Os on the pci device.
+ **/
+static void
+lpfc_sli_prep_dev_for_recover(struct lpfc_hba *phba)
+{
+	lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
+			"2723 PCI channel I/O abort preparing for recovery\n");
+	/* Prepare for bringing HBA offline */
+	lpfc_offline_prep(phba);
+	/* Clear sli active flag to prevent sysfs access to HBA */
+	spin_lock_irq(&phba->hbalock);
+	phba->sli.sli_flag &= ~LPFC_SLI_ACTIVE;
+	spin_unlock_irq(&phba->hbalock);
+	/* Stop and flush all I/Os and bring HBA offline */
+	lpfc_offline(phba);
+}
+
+/**
  * lpfc_sli_prep_dev_for_reset - Prepare SLI3 device for pci slot reset
  * @phba: pointer to lpfc hba data structure.
  *
@@ -7155,7 +7283,7 @@ lpfc_sli_prep_dev_for_reset(struct lpfc_
 	struct lpfc_sli_ring  *pring;
 
 	lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
-			"2710 PCI channel I/O frozen\n");
+			"2710 PCI channel disable preparing for reset\n");
 	/* Disable interrupt and pci device */
 	lpfc_sli_disable_intr(phba);
 	pci_disable_device(phba->pcidev);
@@ -7180,9 +7308,7 @@ static void
 lpfc_prep_dev_for_perm_failure(struct lpfc_hba *phba)
 {
 	lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
-			"2711 PCI channel I/O permanent failure\n");
-	/* Block all SCSI devices' I/Os on the host */
-	lpfc_scsi_dev_block(phba);
+			"2711 PCI channel permanent disable for failure\n");
 	/* Clean up all driver's outstanding SCSI I/Os */
 	lpfc_sli_flush_fcp_rings(phba);
 }
@@ -7211,9 +7337,13 @@ lpfc_io_error_detected_s3(struct pci_dev
 	struct Scsi_Host *shost = pci_get_drvdata(pdev);
 	struct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;
 
+	/* Block all SCSI devices' I/Os on the host */
+	lpfc_scsi_dev_block(phba);
+
 	switch (state) {
 	case pci_channel_io_normal:
-		/* Non-fatal error, do nothing */
+		/* Non-fatal error, prepare for recovery */
+		lpfc_sli_prep_dev_for_recover(phba);
 		return PCI_ERS_RESULT_CAN_RECOVER;
 	case pci_channel_io_frozen:
 		/* Fatal error, prepare for slot reset */
@@ -7225,7 +7355,7 @@ lpfc_io_error_detected_s3(struct pci_dev
 		return PCI_ERS_RESULT_DISCONNECT;
 	default:
 		/* Unknown state, prepare and request slot reset */
-  		lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
+		lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
 				"0472 Unknown PCI error state: x%x\n", state);
 		lpfc_sli_prep_dev_for_reset(phba);
 		return PCI_ERS_RESULT_NEED_RESET;
@@ -7440,6 +7570,7 @@ lpfc_pci_probe_one_s4(struct pci_dev *pd
 
 	/* Configure sysfs attributes */
 	vport = phba->pport;
+	shost = lpfc_shost_from_vport(vport);
 	error = lpfc_alloc_sysfs_attr(vport);
 	if (error) {
 		lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
@@ -7447,6 +7578,20 @@ lpfc_pci_probe_one_s4(struct pci_dev *pd
 		goto out_destroy_shost;
 	}
 
+	/* Add this shost to the security event list */
+	if ((lpfc_get_security_enabled)(shost)) {
+#ifdef SCSI_NL_SHOST_VENDOR
+		/* Triggers fcauthd to register if it is running */
+		fc_host_post_event(shost, fc_get_event_number(),
+				   FCH_EVT_PORT_ONLINE, shost->host_no);
+#endif
+		spin_lock_irq(&fc_security_user_lock);
+		list_add_tail(&vport->sc_users, &fc_security_user_list);
+		spin_unlock_irq(&fc_security_user_lock);
+		if (fc_service_state == FC_SC_SERVICESTATE_ONLINE)
+			lpfc_fc_queue_security_work(vport,
+						    &vport->sc_online_work);
+	}
 	shost = lpfc_shost_from_vport(vport); /* save shost for error cleanup */
 	/* Now, trying to enable interrupt and bring up the device */
 	cfg_mode = phba->cfg_use_msi;
@@ -7461,6 +7606,9 @@ lpfc_pci_probe_one_s4(struct pci_dev *pd
 			error = -ENODEV;
 			goto out_free_sysfs_attr;
 		}
+		/* Default to single FCP EQ for non-MSI-X */
+		if (phba->intr_type != MSIX)
+			phba->cfg_fcp_eq_count = 1;
 		/* Set up SLI-4 HBA */
 		if (lpfc_sli4_hba_setup(phba)) {
 			lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
@@ -7504,6 +7652,11 @@ out_disable_intr:
 	lpfc_sli4_disable_intr(phba);
 out_free_sysfs_attr:
 	lpfc_free_sysfs_attr(vport);
+	if ((lpfc_get_security_enabled)(shost)) {
+		spin_lock_irq(&fc_security_user_lock);
+		list_del(&vport->sc_users);
+		spin_unlock_irq(&fc_security_user_lock);
+	}
 out_destroy_shost:
 	lpfc_destroy_shost(phba);
 out_unset_driver_resource:
@@ -8092,7 +8245,9 @@ static struct pci_device_id lpfc_id_tabl
 		PCI_ANY_ID, PCI_ANY_ID, },
 	{PCI_VENDOR_ID_SERVERENGINE, PCI_DEVICE_ID_TIGERSHARK,
 		PCI_ANY_ID, PCI_ANY_ID, },
-	{PCI_VENDOR_ID_SERVERENGINE, PCI_DEVICE_ID_TS_BE3,
+	{PCI_VENDOR_ID_SERVERENGINE, PCI_DEVICE_ID_TOMCAT,
+		PCI_ANY_ID, PCI_ANY_ID, },
+	{PCI_VENDOR_ID_EMULEX, PCI_DEVICE_ID_FALCON,
 		PCI_ANY_ID, PCI_ANY_ID, },
 	{ 0 }
 };
@@ -8151,12 +8306,29 @@ lpfc_init(void)
 			return -ENOMEM;
 		}
 	}
+	error = scsi_nl_add_driver(LPFC_NL_VENDOR_ID, &lpfc_template,
+				   lpfc_rcv_nl_msg, lpfc_rcv_nl_event);
+	if (error)
+		goto out_release_transport;
+	security_work_q = create_singlethread_workqueue(security_work_q_name);
+	if (!security_work_q)
+		goto out_nl_remove_driver;
+	INIT_LIST_HEAD(&fc_security_user_list);
 	error = pci_register_driver(&lpfc_driver);
-	if (error) {
-		fc_release_transport(lpfc_transport_template);
-		if (lpfc_enable_npiv)
-			fc_release_transport(lpfc_vport_transport_template);
-	}
+	if (error)
+		goto out_destroy_workqueue;
+
+	return error;
+
+out_destroy_workqueue:
+	destroy_workqueue(security_work_q);
+	security_work_q = NULL;
+out_nl_remove_driver:
+	scsi_nl_remove_driver(LPFC_NL_VENDOR_ID);
+out_release_transport:
+	fc_release_transport(lpfc_transport_template);
+	if (lpfc_enable_npiv)
+		fc_release_transport(lpfc_vport_transport_template);
 
 	return error;
 }
@@ -8172,6 +8344,10 @@ static void __exit
 lpfc_exit(void)
 {
 	pci_unregister_driver(&lpfc_driver);
+	if (security_work_q)
+		destroy_workqueue(security_work_q);
+	security_work_q = NULL;
+	scsi_nl_remove_driver(LPFC_NL_VENDOR_ID);
 	fc_release_transport(lpfc_transport_template);
 	if (lpfc_enable_npiv)
 		fc_release_transport(lpfc_vport_transport_template);
diff -urpN a/drivers/scsi/lpfc/lpfc_logmsg.h b/drivers/scsi/lpfc/lpfc_logmsg.h
--- a/drivers/scsi/lpfc/lpfc_logmsg.h	2010-01-12 16:47:01.121079000 -0500
+++ b/drivers/scsi/lpfc/lpfc_logmsg.h	2010-01-12 16:46:28.621798000 -0500
@@ -33,7 +33,7 @@
 #define LOG_FCP_ERROR	0x00001000	/* log errors, not underruns */
 #define LOG_LIBDFC	0x00002000	/* Libdfc events */
 #define LOG_VPORT	0x00004000	/* NPIV events */
-#define LOF_SECURITY	0x00008000	/* Security events */
+#define LOG_SECURITY	0x00008000	/* Security events */
 #define LOG_EVENT	0x00010000	/* CT,TEMP,DUMP, logging */
 #define LOG_ALL_MSG	0xffffffff	/* LOG all messages */
 
diff -urpN a/drivers/scsi/lpfc/lpfc_mbox.c b/drivers/scsi/lpfc/lpfc_mbox.c
--- a/drivers/scsi/lpfc/lpfc_mbox.c	2010-01-12 16:47:01.131080000 -0500
+++ b/drivers/scsi/lpfc/lpfc_mbox.c	2010-01-12 16:46:28.632800000 -0500
@@ -820,6 +820,10 @@ lpfc_reg_vpi(struct lpfc_vport *vport, L
 	mb->un.varRegVpi.vpi = vport->vpi + vport->phba->vpi_base;
 	mb->un.varRegVpi.sid = vport->fc_myDID;
 	mb->un.varRegVpi.vfi = vport->vfi + vport->phba->vfi_base;
+	memcpy(mb->un.varRegVpi.wwn, &vport->fc_portname,
+	       sizeof(struct lpfc_name));
+	mb->un.varRegVpi.wwn[0] = cpu_to_le32(mb->un.varRegVpi.wwn[0]);
+	mb->un.varRegVpi.wwn[1] = cpu_to_le32(mb->un.varRegVpi.wwn[1]);
 
 	mb->mbxCommand = MBX_REG_VPI;
 	mb->mbxOwner = OWN_HOST;
@@ -1818,6 +1822,9 @@ lpfc_reg_vfi(struct lpfcMboxq *mbox, str
 	bf_set(lpfc_reg_vfi_vfi, reg_vfi, vport->vfi + vport->phba->vfi_base);
 	bf_set(lpfc_reg_vfi_fcfi, reg_vfi, vport->phba->fcf.fcfi);
 	bf_set(lpfc_reg_vfi_vpi, reg_vfi, vport->vpi + vport->phba->vpi_base);
+	memcpy(reg_vfi->wwn, &vport->fc_portname, sizeof(struct lpfc_name));
+	reg_vfi->wwn[0] = cpu_to_le32(reg_vfi->wwn[0]);
+	reg_vfi->wwn[1] = cpu_to_le32(reg_vfi->wwn[1]);
 	reg_vfi->bde.addrHigh = putPaddrHigh(phys);
 	reg_vfi->bde.addrLow = putPaddrLow(phys);
 	reg_vfi->bde.tus.f.bdeSize = sizeof(vport->fc_sparam);
diff -urpN a/drivers/scsi/lpfc/lpfc_nportdisc.c b/drivers/scsi/lpfc/lpfc_nportdisc.c
--- a/drivers/scsi/lpfc/lpfc_nportdisc.c	2010-01-12 16:47:01.172080000 -0500
+++ b/drivers/scsi/lpfc/lpfc_nportdisc.c	2010-01-12 16:46:28.644801000 -0500
@@ -247,7 +247,7 @@ lpfc_rcv_plogi(struct lpfc_vport *vport,
 	int rc;
 
 	memset(&stat, 0, sizeof (struct ls_rjt));
-	if (vport->port_state <= LPFC_FLOGI) {
+	if (vport->port_state <= LPFC_FDISC) {
 		/* Before responding to PLOGI, check for pt2pt mode.
 		 * If we are pt2pt, with an outstanding FLOGI, abort
 		 * the FLOGI and resend it first.
@@ -1223,6 +1223,12 @@ lpfc_rcv_logo_reglogin_issue(struct lpfc
 	list_for_each_entry_safe(mb, nextmb, &phba->sli.mboxq, list) {
 		if ((mb->u.mb.mbxCommand == MBX_REG_LOGIN64) &&
 		   (ndlp == (struct lpfc_nodelist *) mb->context2)) {
+			if (phba->sli_rev == LPFC_SLI_REV4) {
+				spin_unlock_irq(&phba->hbalock);
+				lpfc_sli4_free_rpi(phba,
+					mb->u.mb.un.varRegLogin.rpi);
+				spin_lock_irq(&phba->hbalock);
+			}
 			mp = (struct lpfc_dmabuf *) (mb->context1);
 			if (mp) {
 				__lpfc_mbuf_free(phba, mp->virt, mp->phys);
@@ -1230,6 +1236,7 @@ lpfc_rcv_logo_reglogin_issue(struct lpfc
 			}
 			lpfc_nlp_put(ndlp);
 			list_del(&mb->list);
+			phba->sli.mboxq_cnt--;
 			mempool_free(mb, phba->mbox_mem_pool);
 		}
 	}
diff -urpN a/drivers/scsi/lpfc/lpfc_scsi.c b/drivers/scsi/lpfc/lpfc_scsi.c
--- a/drivers/scsi/lpfc/lpfc_scsi.c	2010-01-12 16:47:01.185078000 -0500
+++ b/drivers/scsi/lpfc/lpfc_scsi.c	2010-01-12 16:46:28.666798000 -0500
@@ -59,6 +59,8 @@ static char *dif_op_str[] = {
 };
 static void
 lpfc_release_scsi_buf_s4(struct lpfc_hba *phba, struct lpfc_scsi_buf *psb);
+static void
+lpfc_release_scsi_buf_s3(struct lpfc_hba *phba, struct lpfc_scsi_buf *psb);
 
 static void
 lpfc_debug_save_data(struct lpfc_hba *phba, struct scsi_cmnd *cmnd)
@@ -246,6 +248,36 @@ lpfc_send_sdev_queuedepth_change_event(s
 }
 
 /**
+ * lpfc_change_queue_depth - Alter scsi device queue depth
+ * @sdev: Pointer the scsi device on which to change the queue depth.
+ * @qdepth: New queue depth to set the sdev to.
+ * @reason: The reason for the queue depth change.
+ *
+ * This function is called by the midlayer and the LLD to alter the queue
+ * depth for a scsi device. This function sets the queue depth to the new
+ * value and sends an event out to log the queue depth change.
+ **/
+int
+lpfc_change_queue_depth(struct scsi_device *sdev, int qdepth, int reason)
+{
+	struct lpfc_vport *vport = (struct lpfc_vport *) sdev->host->hostdata;
+	struct lpfc_hba   *phba = vport->phba;
+	struct lpfc_rport_data *rdata;
+	unsigned long new_queue_depth, old_queue_depth;
+
+	old_queue_depth = sdev->queue_depth;
+	scsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev), qdepth);
+	new_queue_depth = sdev->queue_depth;
+	rdata = sdev->hostdata;
+	if (rdata)
+		lpfc_send_sdev_queuedepth_change_event(phba, vport,
+						       rdata->pnode, sdev->lun,
+						       old_queue_depth,
+						       new_queue_depth);
+	return sdev->queue_depth;
+}
+
+/**
  * lpfc_rampdown_queue_depth - Post RAMP_DOWN_QUEUE event to worker thread
  * @phba: The Hba for which this call is being executed.
  *
@@ -309,8 +341,10 @@ lpfc_rampup_queue_depth(struct lpfc_vpor
 	if (vport->cfg_lun_queue_depth <= queue_depth)
 		return;
 	spin_lock_irqsave(&phba->hbalock, flags);
-	if (((phba->last_ramp_up_time + QUEUE_RAMP_UP_INTERVAL) > jiffies) ||
-	 ((phba->last_rsrc_error_time + QUEUE_RAMP_UP_INTERVAL ) > jiffies)) {
+	if (time_before(jiffies,
+			phba->last_ramp_up_time + QUEUE_RAMP_UP_INTERVAL) ||
+	    time_before(jiffies,
+			phba->last_rsrc_error_time + QUEUE_RAMP_UP_INTERVAL)) {
 		spin_unlock_irqrestore(&phba->hbalock, flags);
 		return;
 	}
@@ -342,10 +376,9 @@ lpfc_ramp_down_queue_handler(struct lpfc
 	struct lpfc_vport **vports;
 	struct Scsi_Host  *shost;
 	struct scsi_device *sdev;
-	unsigned long new_queue_depth, old_queue_depth;
+	unsigned long new_queue_depth;
 	unsigned long num_rsrc_err, num_cmd_success;
 	int i;
-	struct lpfc_rport_data *rdata;
 
 	num_rsrc_err = atomic_read(&phba->num_rsrc_err);
 	num_cmd_success = atomic_read(&phba->num_cmd_success);
@@ -363,22 +396,8 @@ lpfc_ramp_down_queue_handler(struct lpfc
 				else
 					new_queue_depth = sdev->queue_depth -
 								new_queue_depth;
-				old_queue_depth = sdev->queue_depth;
-				if (sdev->ordered_tags)
-					scsi_adjust_queue_depth(sdev,
-							MSG_ORDERED_TAG,
-							new_queue_depth);
-				else
-					scsi_adjust_queue_depth(sdev,
-							MSG_SIMPLE_TAG,
-							new_queue_depth);
-				rdata = sdev->hostdata;
-				if (rdata)
-					lpfc_send_sdev_queuedepth_change_event(
-						phba, vports[i],
-						rdata->pnode,
-						sdev->lun, old_queue_depth,
-						new_queue_depth);
+				lpfc_change_queue_depth(sdev, new_queue_depth,
+							SCSI_QDEPTH_DEFAULT);
 			}
 		}
 	lpfc_destroy_vport_work_array(phba, vports);
@@ -402,7 +421,6 @@ lpfc_ramp_up_queue_handler(struct lpfc_h
 	struct Scsi_Host  *shost;
 	struct scsi_device *sdev;
 	int i;
-	struct lpfc_rport_data *rdata;
 
 	vports = lpfc_create_vport_work_array(phba);
 	if (vports != NULL)
@@ -412,22 +430,9 @@ lpfc_ramp_up_queue_handler(struct lpfc_h
 				if (vports[i]->cfg_lun_queue_depth <=
 				    sdev->queue_depth)
 					continue;
-				if (sdev->ordered_tags)
-					scsi_adjust_queue_depth(sdev,
-							MSG_ORDERED_TAG,
-							sdev->queue_depth+1);
-				else
-					scsi_adjust_queue_depth(sdev,
-							MSG_SIMPLE_TAG,
-							sdev->queue_depth+1);
-				rdata = sdev->hostdata;
-				if (rdata)
-					lpfc_send_sdev_queuedepth_change_event(
-						phba, vports[i],
-						rdata->pnode,
-						sdev->lun,
-						sdev->queue_depth - 1,
-						sdev->queue_depth);
+				lpfc_change_queue_depth(sdev,
+							sdev->queue_depth+1,
+							SCSI_QDEPTH_RAMP_UP);
 			}
 		}
 	lpfc_destroy_vport_work_array(phba, vports);
@@ -593,7 +598,7 @@ lpfc_new_scsi_buf_s3(struct lpfc_vport *
 		iocb->ulpClass = CLASS3;
 		psb->status = IOSTAT_SUCCESS;
 		/* Put it back into the SCSI buffer list */
-		lpfc_release_scsi_buf_s4(phba, psb);
+		lpfc_release_scsi_buf_s3(phba, psb);
 
 	}
 
@@ -621,6 +626,7 @@ lpfc_sli4_fcp_xri_aborted(struct lpfc_hb
 		&phba->sli4_hba.lpfc_abts_scsi_buf_list, list) {
 		if (psb->cur_iocbq.sli4_xritag == xri) {
 			list_del(&psb->list);
+			psb->exch_busy = 0;
 			psb->status = IOSTAT_SUCCESS;
 			spin_unlock_irqrestore(
 				&phba->sli4_hba.abts_scsi_buf_list_lock,
@@ -683,11 +689,12 @@ lpfc_sli4_repost_scsi_sgl_list(struct lp
 					 list);
 			if (status) {
 				/* Put this back on the abort scsi list */
-				psb->status = IOSTAT_LOCAL_REJECT;
-				psb->result = IOERR_ABORT_REQUESTED;
+				psb->exch_busy = 1;
 				rc++;
-			} else
+			} else {
+				psb->exch_busy = 0;
 				psb->status = IOSTAT_SUCCESS;
+			}
 			/* Put it back into the SCSI buffer list */
 			lpfc_release_scsi_buf_s4(phba, psb);
 		}
@@ -834,11 +841,12 @@ lpfc_new_scsi_buf_s4(struct lpfc_vport *
 						psb->cur_iocbq.sli4_xritag);
 			if (status) {
 				/* Put this back on the abort scsi list */
-				psb->status = IOSTAT_LOCAL_REJECT;
-				psb->result = IOERR_ABORT_REQUESTED;
+				psb->exch_busy = 1;
 				rc++;
-			} else
+			} else {
+				psb->exch_busy = 0;
 				psb->status = IOSTAT_SUCCESS;
+			}
 			/* Put it back into the SCSI buffer list */
 			lpfc_release_scsi_buf_s4(phba, psb);
 			break;
@@ -852,11 +860,12 @@ lpfc_new_scsi_buf_s4(struct lpfc_vport *
 				 list);
 			if (status) {
 				/* Put this back on the abort scsi list */
-				psb->status = IOSTAT_LOCAL_REJECT;
-				psb->result = IOERR_ABORT_REQUESTED;
+				psb->exch_busy = 1;
 				rc++;
-			} else
+			} else {
+				psb->exch_busy = 0;
 				psb->status = IOSTAT_SUCCESS;
+			}
 			/* Put it back into the SCSI buffer list */
 			lpfc_release_scsi_buf_s4(phba, psb);
 		}
@@ -946,8 +955,7 @@ lpfc_release_scsi_buf_s4(struct lpfc_hba
 {
 	unsigned long iflag = 0;
 
-	if (psb->status == IOSTAT_LOCAL_REJECT
-		&& psb->result == IOERR_ABORT_REQUESTED) {
+	if (psb->exch_busy) {
 		spin_lock_irqsave(&phba->sli4_hba.abts_scsi_buf_list_lock,
 					iflag);
 		psb->pCmd = NULL;
@@ -2208,7 +2216,7 @@ lpfc_scsi_cmd_iocb_cmpl(struct lpfc_hba 
 	struct scsi_cmnd *cmd = lpfc_cmd->pCmd;
 	int result;
 	struct scsi_device *tmp_sdev;
-	int depth = 0;
+	int depth;
 	unsigned long flags;
 	struct lpfc_fast_path_event *fast_path_evt;
 	struct Scsi_Host *shost = cmd->device->host;
@@ -2216,6 +2224,9 @@ lpfc_scsi_cmd_iocb_cmpl(struct lpfc_hba 
 
 	lpfc_cmd->result = pIocbOut->iocb.un.ulpWord[4];
 	lpfc_cmd->status = pIocbOut->iocb.ulpStatus;
+	/* pick up SLI4 exhange busy status from HBA */
+	lpfc_cmd->exch_busy = pIocbOut->iocb_flag & LPFC_EXCHANGE_BUSY;
+
 	if (pnode && NLP_CHK_NODE_ACT(pnode))
 		atomic_dec(&pnode->cmd_pending);
 
@@ -2375,67 +2386,29 @@ lpfc_scsi_cmd_iocb_cmpl(struct lpfc_hba 
 		return;
 	}
 
-
 	if (!result)
 		lpfc_rampup_queue_depth(vport, queue_depth);
 
-	if (!result && pnode && NLP_CHK_NODE_ACT(pnode) &&
-	   ((jiffies - pnode->last_ramp_up_time) >
-		LPFC_Q_RAMP_UP_INTERVAL * HZ) &&
-	   ((jiffies - pnode->last_q_full_time) >
-		LPFC_Q_RAMP_UP_INTERVAL * HZ) &&
-	   (vport->cfg_lun_queue_depth > queue_depth)) {
-		shost_for_each_device(tmp_sdev, shost) {
-			if (vport->cfg_lun_queue_depth > tmp_sdev->queue_depth){
-				if (tmp_sdev->id != scsi_id)
-					continue;
-				if (tmp_sdev->ordered_tags)
-					scsi_adjust_queue_depth(tmp_sdev,
-						MSG_ORDERED_TAG,
-						tmp_sdev->queue_depth+1);
-				else
-					scsi_adjust_queue_depth(tmp_sdev,
-						MSG_SIMPLE_TAG,
-						tmp_sdev->queue_depth+1);
-
-				pnode->last_ramp_up_time = jiffies;
-			}
-		}
-		lpfc_send_sdev_queuedepth_change_event(phba, vport, pnode,
-			0xFFFFFFFF,
-			queue_depth , queue_depth + 1);
-	}
-
 	/*
 	 * Check for queue full.  If the lun is reporting queue full, then
 	 * back off the lun queue depth to prevent target overloads.
 	 */
 	if (result == SAM_STAT_TASK_SET_FULL && pnode &&
 	    NLP_CHK_NODE_ACT(pnode)) {
-		pnode->last_q_full_time = jiffies;
-
 		shost_for_each_device(tmp_sdev, shost) {
 			if (tmp_sdev->id != scsi_id)
 				continue;
 			depth = scsi_track_queue_full(tmp_sdev,
-					tmp_sdev->queue_depth - 1);
-		}
-		/*
-		 * The queue depth cannot be lowered any more.
-		 * Modify the returned error code to store
-		 * the final depth value set by
-		 * scsi_track_queue_full.
-		 */
-		if (depth == -1)
-			depth = shost->cmd_per_lun;
-
-		if (depth) {
+						      tmp_sdev->queue_depth-1);
+			if (depth <= 0)
+				continue;
 			lpfc_printf_vlog(vport, KERN_WARNING, LOG_FCP,
 					 "0711 detected queue full - lun queue "
 					 "depth adjusted to %d.\n", depth);
 			lpfc_send_sdev_queuedepth_change_event(phba, vport,
-				pnode, 0xFFFFFFFF,
-				depth+1, depth);
+							       pnode,
+							       tmp_sdev->lun,
+							       depth+1, depth);
 		}
 	}
 
@@ -2728,6 +2701,13 @@ lpfc_info(struct Scsi_Host *host)
 				 " port %s",
 				 phba->Port);
 		}
+		len = strlen(lpfcinfobuf);
+		if (phba->sli4_hba.link_state.logical_speed) {
+			snprintf(lpfcinfobuf + len,
+				 384-len,
+				 " Logical Link Speed: %d Mbps",
+				 phba->sli4_hba.link_state.logical_speed * 10);
+		}
 	}
 	return lpfcinfobuf;
 }
@@ -2801,7 +2781,7 @@ lpfc_queuecommand(struct scsi_cmnd *cmnd
 	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
 	struct lpfc_hba   *phba = vport->phba;
 	struct lpfc_rport_data *rdata = cmnd->device->hostdata;
-	struct lpfc_nodelist *ndlp = rdata->pnode;
+	struct lpfc_nodelist *ndlp;
 	struct lpfc_scsi_buf *lpfc_cmd;
 	struct fc_rport *rport = starget_to_rport(scsi_target(cmnd->device));
 	int err;
@@ -2811,6 +2791,7 @@ lpfc_queuecommand(struct scsi_cmnd *cmnd
 		cmnd->result = err;
 		goto out_fail_command;
 	}
+	ndlp = rdata->pnode;
 
 	if (!(phba->sli3_options & LPFC_SLI3_BG_ENABLED) &&
 		scsi_get_prot_op(cmnd) != SCSI_PROT_NORMAL) {
@@ -3019,6 +3000,10 @@ lpfc_abort_handler(struct scsi_cmnd *cmn
 
 	icmd->ulpLe = 1;
 	icmd->ulpClass = cmd->ulpClass;
+
+	/* ABTS WQE must go to the same WQ as the WQE to be aborted */
+	abtsiocb->fcp_wqidx = iocb->fcp_wqidx;
+
 	if (lpfc_is_link_up(phba))
 		icmd->ulpCommand = CMD_ABORT_XRI_CN;
 	else
@@ -3185,9 +3170,15 @@ static int
 lpfc_chk_tgt_mapped(struct lpfc_vport *vport, struct scsi_cmnd *cmnd)
 {
 	struct lpfc_rport_data *rdata = cmnd->device->hostdata;
-	struct lpfc_nodelist *pnode = rdata->pnode;
+	struct lpfc_nodelist *pnode;
 	unsigned long later;
 
+	if (!rdata) {
+		lpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,
+			"0797 Tgt Map rport failure: rdata x%p\n", rdata);
+		return FAILED;
+	}
+	pnode = rdata->pnode;
 	/*
 	 * If target is not in a MAPPED state, delay until
 	 * target is rediscovered or devloss timeout expires.
@@ -3272,12 +3263,18 @@ lpfc_device_reset_handler(struct scsi_cm
 	struct Scsi_Host  *shost = cmnd->device->host;
 	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
 	struct lpfc_rport_data *rdata = cmnd->device->hostdata;
-	struct lpfc_nodelist *pnode = rdata->pnode;
+	struct lpfc_nodelist *pnode;
 	unsigned tgt_id = cmnd->device->id;
 	unsigned int lun_id = cmnd->device->lun;
 	struct lpfc_scsi_event_header scsi_event;
 	int status;
 
+	if (!rdata) {
+		lpfc_printf_vlog(vport, KERN_ERR, LOG_FCP,
+			"0798 Device Reset rport failure: rdata x%p\n", rdata);
+		return FAILED;
+	}
+	pnode = rdata->pnode;
 	fc_block_scsi_eh(cmnd);
 
 	status = lpfc_chk_tgt_mapped(vport, cmnd);
@@ -3331,12 +3328,18 @@ lpfc_target_reset_handler(struct scsi_cm
 	struct Scsi_Host  *shost = cmnd->device->host;
 	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
 	struct lpfc_rport_data *rdata = cmnd->device->hostdata;
-	struct lpfc_nodelist *pnode = rdata->pnode;
+	struct lpfc_nodelist *pnode;
 	unsigned tgt_id = cmnd->device->id;
 	unsigned int lun_id = cmnd->device->lun;
 	struct lpfc_scsi_event_header scsi_event;
 	int status;
 
+	if (!rdata) {
+		lpfc_printf_vlog(vport, KERN_ERR, LOG_FCP,
+			"0799 Target Reset rport failure: rdata x%p\n", rdata);
+		return FAILED;
+	}
+	pnode = rdata->pnode;
 	fc_block_scsi_eh(cmnd);
 
 	status = lpfc_chk_tgt_mapped(vport, cmnd);
@@ -3517,6 +3520,8 @@ lpfc_slave_alloc(struct scsi_device *sde
 				 "Allocated %d buffers.\n",
 				 num_to_alloc, num_allocated);
 	}
+	if (num_allocated > 0)
+		phba->total_scsi_bufs += num_allocated;
 	return 0;
 }
 
@@ -3596,6 +3601,7 @@ struct scsi_host_template lpfc_template 
 	.shost_attrs		= lpfc_hba_attrs,
 	.max_sectors		= 0xFFFF,
 	.vendor_id		= LPFC_NL_VENDOR_ID,
+	.change_queue_depth	= lpfc_change_queue_depth,
 };
 
 struct scsi_host_template lpfc_vport_template = {
@@ -3617,4 +3623,5 @@ struct scsi_host_template lpfc_vport_tem
 	.use_clustering		= ENABLE_CLUSTERING,
 	.shost_attrs		= lpfc_vport_attrs,
 	.max_sectors		= 0xFFFF,
+	.change_queue_depth	= lpfc_change_queue_depth,
 };
diff -urpN a/drivers/scsi/lpfc/lpfc_scsi.h b/drivers/scsi/lpfc/lpfc_scsi.h
--- a/drivers/scsi/lpfc/lpfc_scsi.h	2010-01-12 16:47:01.190078000 -0500
+++ b/drivers/scsi/lpfc/lpfc_scsi.h	2010-01-12 16:46:28.672798000 -0500
@@ -118,6 +118,7 @@ struct lpfc_scsi_buf {
 
 	uint32_t timeout;
 
+	uint16_t exch_busy;     /* SLI4 hba reported XB on complete WCQE */
 	uint16_t status;	/* From IOCB Word 7- ulpStatus */
 	uint32_t result;	/* From IOCB Word 4. */
 
diff -urpN a/drivers/scsi/lpfc/lpfc_security.c b/drivers/scsi/lpfc/lpfc_security.c
--- a/drivers/scsi/lpfc/lpfc_security.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/scsi/lpfc/lpfc_security.c	2010-01-12 16:46:28.679801000 -0500
@@ -0,0 +1,339 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Copyright (C) 2006-2008 Emulex.  All rights reserved.           *
+ * EMULEX and SLI are trademarks of Emulex.                        *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of version 2 of the GNU General       *
+ * Public License as published by the Free Software Foundation.    *
+ * This program is distributed in the hope that it will be useful. *
+ * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *
+ * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *
+ * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *
+ * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *
+ * TO BE LEGALLY INVALID.  See the GNU General Public License for  *
+ * more details, a copy of which can be found in the file COPYING  *
+ * included with this package.                                     *
+ *******************************************************************/
+
+#include <linux/delay.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+
+#include <scsi/scsi_tcq.h>
+#include <scsi/scsi_transport_fc.h>
+
+#include "lpfc_hw4.h"
+#include "lpfc_hw.h"
+#include "lpfc_sli.h"
+#include "lpfc_sli4.h"
+#include "lpfc_nl.h"
+#include "lpfc_disc.h"
+#include "lpfc.h"
+#include "lpfc_crtn.h"
+#include "lpfc_logmsg.h"
+#include "lpfc_security.h"
+#include "lpfc_auth_access.h"
+#include "lpfc_vport.h"
+
+void
+lpfc_security_service_online(struct Scsi_Host *shost)
+{
+	struct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;
+
+	vport->security_service_state = SECURITY_ONLINE;
+	if (vport->cfg_enable_auth &&
+	    vport->auth.auth_mode == FC_AUTHMODE_UNKNOWN &&
+	    vport->phba->link_state == LPFC_HBA_ERROR)
+		lpfc_selective_reset(vport->phba);
+}
+
+void
+lpfc_security_service_offline(struct Scsi_Host *shost)
+{
+	struct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;
+
+	vport->security_service_state = SECURITY_OFFLINE;
+}
+
+void
+lpfc_security_config(struct Scsi_Host *shost, int status, void *rsp)
+{
+	struct fc_auth_rsp *auth_rsp = (struct fc_auth_rsp *)rsp;
+	struct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;
+	struct lpfc_nodelist *ndlp;
+	uint32_t old_interval, new_interval;
+	unsigned long new_jiffies, temp_jiffies;
+	uint8_t last_auth_mode;
+
+	if (status)
+		return;
+	ndlp = lpfc_findnode_did(vport, Fabric_DID);
+	if (!ndlp || !NLP_CHK_NODE_ACT(ndlp))
+		return;
+
+	vport->auth.bidirectional =
+		auth_rsp->u.dhchap_security_config.bidirectional;
+	memcpy(&vport->auth.hash_priority[0],
+	       &auth_rsp->u.dhchap_security_config.hash_priority[0],
+	       sizeof(vport->auth.hash_priority));
+	vport->auth.hash_len = auth_rsp->u.dhchap_security_config.hash_len;
+	memcpy(&vport->auth.dh_group_priority[0],
+	       &auth_rsp->u.dhchap_security_config.
+	       dh_group_priority[0],
+	       sizeof(vport->auth.dh_group_priority));
+	vport->auth.dh_group_len =
+		auth_rsp->u.dhchap_security_config.dh_group_len;
+	old_interval = vport->auth.reauth_interval;
+	vport->auth.reauth_interval =
+		auth_rsp->u.dhchap_security_config.reauth_interval;
+	new_interval = vport->auth.reauth_interval;
+	/*
+	 * If interval changed we need to adjust the running timer
+	 *  If enabled then start timer now.
+	 *  If disabled then stop the timer.
+	 *  If changed to chorter then elapsed time, then set to fire now
+	 *  If changed to longer than elapsed time, extend the timer.
+	 */
+	if (old_interval != new_interval &&
+	    vport->auth.auth_state == LPFC_AUTH_SUCCESS) {
+		new_jiffies = msecs_to_jiffies(new_interval * 60000);
+		del_timer_sync(&ndlp->nlp_reauth_tmr);
+		if (old_interval == 0)
+			temp_jiffies = jiffies + new_jiffies;
+		if (new_interval == 0)
+			temp_jiffies = 0;
+		else if (new_jiffies < (jiffies - vport->auth.last_auth))
+			temp_jiffies = jiffies + msecs_to_jiffies(1);
+		else
+			temp_jiffies = jiffies + (new_jiffies -
+				(jiffies - vport->auth.last_auth));
+		if (temp_jiffies)
+			mod_timer(&ndlp->nlp_reauth_tmr, temp_jiffies);
+	}
+	last_auth_mode = vport->auth.auth_mode;
+	vport->auth.auth_mode =
+		auth_rsp->u.dhchap_security_config.auth_mode;
+	lpfc_printf_vlog(vport, KERN_INFO, LOG_SECURITY,
+		"1025 Received security config local_wwpn:"
+		 "%llX remote_wwpn:%llX mode:0x%x "
+		 "hash(%d):%x:%x:%x:%x bidir:0x%x "
+		 "dh_group(%d):%x:%x:%x:%x:%x:%x:%x:%x "
+		 "reauth_interval:0x%x\n",
+		 (unsigned long long)auth_rsp->local_wwpn,
+		 (unsigned long long)auth_rsp->remote_wwpn,
+		 auth_rsp->u.dhchap_security_config.auth_mode,
+		 auth_rsp->u.dhchap_security_config.hash_len,
+		 auth_rsp->u.dhchap_security_config.hash_priority[0],
+		 auth_rsp->u.dhchap_security_config.hash_priority[1],
+		 auth_rsp->u.dhchap_security_config.hash_priority[2],
+		 auth_rsp->u.dhchap_security_config.hash_priority[3],
+		 auth_rsp->u.dhchap_security_config.bidirectional,
+		 auth_rsp->u.dhchap_security_config.dh_group_len,
+		 auth_rsp->u.dhchap_security_config.dh_group_priority[0],
+		 auth_rsp->u.dhchap_security_config.dh_group_priority[1],
+		 auth_rsp->u.dhchap_security_config.dh_group_priority[2],
+		 auth_rsp->u.dhchap_security_config.dh_group_priority[3],
+		 auth_rsp->u.dhchap_security_config.dh_group_priority[4],
+		 auth_rsp->u.dhchap_security_config.dh_group_priority[5],
+		 auth_rsp->u.dhchap_security_config.dh_group_priority[6],
+		 auth_rsp->u.dhchap_security_config.dh_group_priority[7],
+		 auth_rsp->u.dhchap_security_config.reauth_interval);
+	kfree(auth_rsp);
+	if (vport->auth.auth_mode == FC_AUTHMODE_ACTIVE)
+		vport->auth.security_active = 1;
+	else if (vport->auth.auth_mode == FC_AUTHMODE_PASSIVE) {
+		if (ndlp->nlp_flag & NLP_SC_REQ)
+			vport->auth.security_active = 1;
+		else {
+			lpfc_printf_vlog(vport, KERN_INFO, LOG_SECURITY,
+					 "1038 Authentication not "
+					 "required by the fabric. "
+					 "Disabled.\n");
+			vport->auth.security_active = 0;
+		}
+	} else {
+		vport->auth.security_active = 0;
+		/*
+		* If switch require authentication and authentication
+		* is disabled for this HBA/Fabric port, fail the
+		* discovery.
+		*/
+		if (ndlp->nlp_flag & NLP_SC_REQ) {
+			lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
+					 "1050 Authentication mode is "
+					 "disabled, but is required by "
+					 "the fabric.\n");
+			lpfc_vport_set_state(vport, FC_VPORT_FAILED);
+			/* Cancel discovery timer */
+			lpfc_can_disctmo(vport);
+		}
+	}
+
+	if (last_auth_mode == FC_AUTHMODE_UNKNOWN) {
+		if (vport->auth.security_active)
+			lpfc_start_authentication(vport, ndlp);
+		else
+			lpfc_start_discovery(vport);
+	}
+}
+
+int
+lpfc_get_security_enabled(struct Scsi_Host *shost)
+{
+	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
+
+	return vport->cfg_enable_auth;
+}
+
+int
+lpfc_security_wait(struct lpfc_vport *vport)
+{
+	int i = 0;
+	if (vport->security_service_state == SECURITY_ONLINE)
+		return 0;
+	lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
+			"1058 Waiting for authentication service...\n");
+	while (vport->security_service_state == SECURITY_OFFLINE) {
+		i++;
+		if (i > SECURITY_WAIT_TMO * 2)
+			return -ETIMEDOUT;
+		/* Delay for half of a second */
+		msleep(500);
+	}
+	lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
+			"1059 Authentication service online.\n");
+	return 0;
+}
+
+int
+lpfc_security_config_wait(struct lpfc_vport *vport)
+{
+	int i = 0;
+
+	while (vport->auth.auth_mode == FC_AUTHMODE_UNKNOWN) {
+		i++;
+		if (i > 120)
+			return -ETIMEDOUT;
+		/* Delay for half of a second */
+		msleep(500);
+	}
+	return 0;
+}
+
+void
+lpfc_reauth_node(unsigned long ptr)
+{
+	struct lpfc_nodelist *ndlp = (struct lpfc_nodelist *) ptr;
+	struct lpfc_vport *vport = ndlp->vport;
+	struct lpfc_hba   *phba = vport->phba;
+	unsigned long flags;
+	struct lpfc_work_evt  *evtp = &ndlp->els_reauth_evt;
+
+	ndlp = (struct lpfc_nodelist *) ptr;
+	phba = ndlp->phba;
+
+	spin_lock_irqsave(&phba->hbalock, flags);
+	if (!list_empty(&evtp->evt_listp)) {
+		spin_unlock_irqrestore(&phba->hbalock, flags);
+		return;
+	}
+
+	/* We need to hold the node resource by incrementing the reference
+	 * count until this queued work is done
+	 */
+	evtp->evt_arg1 = lpfc_nlp_get(ndlp);
+	if (evtp->evt_arg1) {
+		evtp->evt = LPFC_EVT_REAUTH;
+		list_add_tail(&evtp->evt_listp, &phba->work_list);
+		lpfc_worker_wake_up(phba);
+	}
+	spin_unlock_irqrestore(&phba->hbalock, flags);
+	return;
+}
+
+void
+lpfc_reauthentication_handler(struct lpfc_nodelist *ndlp)
+{
+	struct lpfc_vport *vport = ndlp->vport;
+	if (vport->auth.auth_msg_state != LPFC_DHCHAP_SUCCESS)
+		return;
+
+	if (lpfc_start_node_authentication(ndlp)) {
+		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
+				 "1029 Reauthentication Failure\n");
+		if (vport->auth.auth_state == LPFC_AUTH_SUCCESS)
+			lpfc_port_auth_failed(ndlp, LPFC_AUTH_FAIL);
+	}
+}
+
+/*
+ * This function will kick start authentication for a node.
+ * This is used for re-authentication of a node or a user
+ * initiated node authentication.
+ */
+int
+lpfc_start_node_authentication(struct lpfc_nodelist *ndlp)
+{
+	struct lpfc_vport *vport;
+	int ret;
+
+	vport = ndlp->vport;
+	/* If there is authentication timer cancel the timer */
+	del_timer_sync(&ndlp->nlp_reauth_tmr);
+	ret = lpfc_get_auth_config(vport, ndlp);
+	if (ret)
+		return ret;
+	ret = lpfc_security_config_wait(vport);
+	if (ret) {
+		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
+				 "1032 Start Authentication: get config "
+				 "timed out.\n");
+		return ret;
+	}
+	return 0;
+}
+
+int
+lpfc_get_auth_config(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp)
+{
+	struct fc_auth_req auth_req;
+	struct fc_auth_rsp *auth_rsp;
+	struct Scsi_Host   *shost;
+	int ret;
+
+	shost = lpfc_shost_from_vport(vport);
+
+	auth_req.local_wwpn = wwn_to_u64(vport->fc_portname.u.wwn);
+	if ((ndlp == NULL) || (ndlp->nlp_type & NLP_FABRIC))
+		auth_req.remote_wwpn = AUTH_FABRIC_WWN;
+	else
+		auth_req.remote_wwpn = wwn_to_u64(ndlp->nlp_portname.u.wwn);
+	if (vport->security_service_state == SECURITY_OFFLINE) {
+		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
+				 "1053 Start Authentication: "
+				 "Security service offline.\n");
+		return -EINVAL;
+	}
+	auth_rsp = kmalloc(sizeof(struct fc_auth_rsp), GFP_KERNEL);
+	if (!auth_rsp) {
+		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
+				 "1028 Start Authentication: No buffers\n");
+		return -ENOMEM;
+	}
+	vport->auth.auth_mode = FC_AUTHMODE_UNKNOWN;
+	ret = lpfc_fc_security_get_config(shost, &auth_req,
+					  sizeof(struct fc_auth_req),
+					  auth_rsp,
+					  sizeof(struct fc_auth_rsp));
+	if (ret) {
+		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
+				 "1031 Start Authentication: Get config "
+				 "failed.\n");
+		kfree(auth_rsp);
+		return ret;
+	}
+	return 0;
+}
diff -urpN a/drivers/scsi/lpfc/lpfc_security.h b/drivers/scsi/lpfc/lpfc_security.h
--- a/drivers/scsi/lpfc/lpfc_security.h	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/scsi/lpfc/lpfc_security.h	2010-01-12 16:46:28.685799000 -0500
@@ -0,0 +1,24 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Copyright (C) 2006-2007 Emulex.  All rights reserved.           *
+ * EMULEX and SLI are trademarks of Emulex.                        *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of version 2 of the GNU General       *
+ * Public License as published by the Free Software Foundation.    *
+ * This program is distributed in the hope that it will be useful. *
+ * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *
+ * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *
+ * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *
+ * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *
+ * TO BE LEGALLY INVALID.  See the GNU General Public License for  *
+ * more details, a copy of which can be found in the file COPYING  *
+ * included with this package.                                     *
+ *******************************************************************/
+
+#define SECURITY_OFFLINE     0x0
+#define SECURITY_ONLINE      0x1
+
+#define SECURITY_WAIT_TMO    30	/* seconds to wait for the auth service */
diff -urpN a/drivers/scsi/lpfc/lpfc_sli4.h b/drivers/scsi/lpfc/lpfc_sli4.h
--- a/drivers/scsi/lpfc/lpfc_sli4.h	2010-01-12 16:47:01.195080000 -0500
+++ b/drivers/scsi/lpfc/lpfc_sli4.h	2010-01-12 16:46:28.692798000 -0500
@@ -28,7 +28,7 @@
 /* Multi-queue arrangement for fast-path FCP work queues */
 #define LPFC_FN_EQN_MAX       8
 #define LPFC_SP_EQN_DEF       1
-#define LPFC_FP_EQN_DEF       1
+#define LPFC_FP_EQN_DEF       4
 #define LPFC_FP_EQN_MIN       1
 #define LPFC_FP_EQN_MAX       (LPFC_FN_EQN_MAX - LPFC_SP_EQN_DEF)
 
@@ -63,6 +63,11 @@
 	 (fc_hdr)->fh_s_id[1] <<  8 | \
 	 (fc_hdr)->fh_s_id[2])
 
+#define sli4_fctl_from_fc_hdr(fc_hdr)  \
+	((fc_hdr)->fh_f_ctl[0] << 16 | \
+	 (fc_hdr)->fh_f_ctl[1] <<  8 | \
+	 (fc_hdr)->fh_f_ctl[2])
+
 enum lpfc_sli4_queue_type {
 	LPFC_EQ,
 	LPFC_GCQ,
@@ -121,6 +126,7 @@ struct lpfc_sli4_link {
 	uint8_t status;
 	uint8_t physical;
 	uint8_t fault;
+	uint16_t logical_speed;
 };
 
 struct lpfc_fcf {
@@ -288,9 +294,8 @@ struct lpfc_sli4_hba {
 	/* BAR0 PCI config space register memory map */
 	void __iomem *UERRLOregaddr; /* Address to UERR_STATUS_LO register */
 	void __iomem *UERRHIregaddr; /* Address to UERR_STATUS_HI register */
-	void __iomem *ONLINE0regaddr; /* Address to components of internal UE */
-	void __iomem *ONLINE1regaddr; /* Address to components of internal UE */
-#define LPFC_ONLINE_NERR	0xFFFFFFFF
+	void __iomem *UEMASKLOregaddr; /* Address to UE_MASK_LO register */
+	void __iomem *UEMASKHIregaddr; /* Address to UE_MASK_HI register */
 	void __iomem *SCRATCHPADregaddr; /* Address to scratchpad register */
 	/* BAR1 FCoE function CSR register memory map */
 	void __iomem *STAregaddr;    /* Address to HST_STATE register */
@@ -304,6 +309,8 @@ struct lpfc_sli4_hba {
 	void __iomem *MQDBregaddr;   /* Address to MQ_DOORBELL register */
 	void __iomem *BMBXregaddr;   /* Address to BootStrap MBX register */
 
+	uint32_t ue_mask_lo;
+	uint32_t ue_mask_hi;
 	struct msix_entry *msix_entries;
 	uint32_t cfg_eqn;
 	struct lpfc_fcp_eq_hdl *fcp_eq_hdl; /* FCP per-WQ handle */
diff -urpN a/drivers/scsi/lpfc/lpfc_sli.c b/drivers/scsi/lpfc/lpfc_sli.c
--- a/drivers/scsi/lpfc/lpfc_sli.c	2010-01-12 16:47:01.236039000 -0500
+++ b/drivers/scsi/lpfc/lpfc_sli.c	2010-01-12 16:46:28.745798000 -0500
@@ -263,6 +263,9 @@ lpfc_sli4_eq_release(struct lpfc_queue *
 	bf_set(lpfc_eqcq_doorbell_qt, &doorbell, LPFC_QUEUE_TYPE_EVENT);
 	bf_set(lpfc_eqcq_doorbell_eqid, &doorbell, q->queue_id);
 	writel(doorbell.word0, q->phba->sli4_hba.EQCQDBregaddr);
+	/* PCI read to flush PCI pipeline on re-arming for INTx mode */
+	if ((q->phba->intr_type == INTx) && (arm == LPFC_QUEUE_REARM))
+		readl(q->phba->sli4_hba.EQCQDBregaddr);
 	return released;
 }
 
@@ -577,10 +580,7 @@ __lpfc_sli_release_iocbq_s4(struct lpfc_
 	else
 		sglq = __lpfc_clear_active_sglq(phba, iocbq->sli4_xritag);
 	if (sglq)  {
-		if (iocbq->iocb_flag & LPFC_DRIVER_ABORTED
-			&& ((iocbq->iocb.ulpStatus == IOSTAT_LOCAL_REJECT)
-			&& (iocbq->iocb.un.ulpWord[4]
-				== IOERR_ABORT_REQUESTED))) {
+		if (iocbq->iocb_flag & LPFC_EXCHANGE_BUSY) {
 			spin_lock_irqsave(&phba->sli4_hba.abts_sgl_list_lock,
 					iflag);
 			list_add(&sglq->list,
@@ -1380,7 +1380,7 @@ lpfc_sli_hbq_to_firmware_s4(struct lpfc_
 /* HBQ for ELS and CT traffic. */
 static struct lpfc_hbq_init lpfc_els_hbq = {
 	.rn = 1,
-	.entry_count = 200,
+	.entry_count = 256,
 	.mask_count = 0,
 	.profile = 0,
 	.ring_mask = (1 << LPFC_ELS_RING),
@@ -1479,8 +1479,11 @@ err:
 int
 lpfc_sli_hbqbuf_add_hbqs(struct lpfc_hba *phba, uint32_t qno)
 {
-	return(lpfc_sli_hbqbuf_fill_hbqs(phba, qno,
-					 lpfc_hbq_defs[qno]->add_count));
+	if (phba->sli_rev == LPFC_SLI_REV4)
+		return 0;
+	else
+		return lpfc_sli_hbqbuf_fill_hbqs(phba, qno,
+					 lpfc_hbq_defs[qno]->add_count);
 }
 
 /**
@@ -1495,8 +1498,12 @@ lpfc_sli_hbqbuf_add_hbqs(struct lpfc_hba
 static int
 lpfc_sli_hbqbuf_init_hbqs(struct lpfc_hba *phba, uint32_t qno)
 {
-	return(lpfc_sli_hbqbuf_fill_hbqs(phba, qno,
-					 lpfc_hbq_defs[qno]->init_count));
+	if (phba->sli_rev == LPFC_SLI_REV4)
+		return lpfc_sli_hbqbuf_fill_hbqs(phba, qno,
+					 lpfc_hbq_defs[qno]->entry_count);
+	else
+		return lpfc_sli_hbqbuf_fill_hbqs(phba, qno,
+					 lpfc_hbq_defs[qno]->init_count);
 }
 
 /**
@@ -1707,6 +1714,7 @@ lpfc_sli_def_mbox_cmpl(struct lpfc_hba *
 	struct lpfc_dmabuf *mp;
 	uint16_t rpi, vpi;
 	int rc;
+	struct lpfc_vport  *vport = pmb->vport;
 
 	mp = (struct lpfc_dmabuf *) (pmb->context1);
 
@@ -1735,6 +1743,18 @@ lpfc_sli_def_mbox_cmpl(struct lpfc_hba *
 			return;
 	}
 
+	/* Unreg VPI, if the REG_VPI succeed after VLink failure */
+	if ((pmb->u.mb.mbxCommand == MBX_REG_VPI) &&
+		!(phba->pport->load_flag & FC_UNLOADING) &&
+		!pmb->u.mb.mbxStatus) {
+		lpfc_unreg_vpi(phba, pmb->u.mb.un.varRegVpi.vpi, pmb);
+		pmb->vport = vport;
+		pmb->mbox_cmpl = lpfc_sli_def_mbox_cmpl;
+		rc = lpfc_sli_issue_mbox(phba, pmb, MBX_NOWAIT);
+		if (rc != MBX_NOT_FINISHED)
+			return;
+	}
+
 	if (bf_get(lpfc_mqe_command, &pmb->u.mqe) == MBX_SLI4_CONFIG)
 		lpfc_sli4_mbox_cmd_free(phba, pmb);
 	else
@@ -2218,9 +2238,15 @@ lpfc_sli_process_sol_iocb(struct lpfc_hb
 			 * All other are passed to the completion callback.
 			 */
 			if (pring->ringno == LPFC_ELS_RING) {
-				if (cmdiocbp->iocb_flag & LPFC_DRIVER_ABORTED) {
+				if ((phba->sli_rev < LPFC_SLI_REV4) &&
+				    (cmdiocbp->iocb_flag &
+							LPFC_DRIVER_ABORTED)) {
+					spin_lock_irqsave(&phba->hbalock,
+							  iflag);
 					cmdiocbp->iocb_flag &=
 						~LPFC_DRIVER_ABORTED;
+					spin_unlock_irqrestore(&phba->hbalock,
+							       iflag);
 					saveq->iocb.ulpStatus =
 						IOSTAT_LOCAL_REJECT;
 					saveq->iocb.un.ulpWord[4] =
@@ -2230,7 +2256,47 @@ lpfc_sli_process_sol_iocb(struct lpfc_hb
 					 * of DMAing payload, so don't free data
 					 * buffer till after a hbeat.
 					 */
+					spin_lock_irqsave(&phba->hbalock,
+							  iflag);
 					saveq->iocb_flag |= LPFC_DELAY_MEM_FREE;
+					spin_unlock_irqrestore(&phba->hbalock,
+							       iflag);
+				}
+				if ((phba->sli_rev == LPFC_SLI_REV4) &&
+				    (saveq->iocb_flag & LPFC_EXCHANGE_BUSY)) {
+					/* Set cmdiocb flag for the exchange
+					 * busy so sgl (xri) will not be
+					 * released until the abort xri is
+					 * received from hba, clear the
+					 * LPFC_DRIVER_ABORTED bit in case
+					 * it was driver initiated abort.
+					 */
+					spin_lock_irqsave(&phba->hbalock,
+							  iflag);
+					cmdiocbp->iocb_flag &=
+						~LPFC_DRIVER_ABORTED;
+					cmdiocbp->iocb_flag |=
+						LPFC_EXCHANGE_BUSY;
+					spin_unlock_irqrestore(&phba->hbalock,
+							       iflag);
+					cmdiocbp->iocb.ulpStatus =
+						IOSTAT_LOCAL_REJECT;
+					cmdiocbp->iocb.un.ulpWord[4] =
+						IOERR_ABORT_REQUESTED;
+					/*
+					 * For SLI4, irsiocb contains NO_XRI
+					 * in sli_xritag, it shall not affect
+					 * releasing sgl (xri) process.
+					 */
+					saveq->iocb.ulpStatus =
+						IOSTAT_LOCAL_REJECT;
+					saveq->iocb.un.ulpWord[4] =
+						IOERR_SLI_ABORTED;
+					spin_lock_irqsave(&phba->hbalock,
+							  iflag);
+					saveq->iocb_flag |= LPFC_DELAY_MEM_FREE;
+					spin_unlock_irqrestore(&phba->hbalock,
+							       iflag);
 				}
 			}
 			(cmdiocbp->iocb_cmpl) (phba, cmdiocbp, saveq);
@@ -4107,6 +4173,7 @@ lpfc_sli4_read_rev(struct lpfc_hba *phba
 	if (rc) {
 		dma_free_coherent(&phba->pcidev->dev, dma_size,
 				  dmabuf->virt, dmabuf->phys);
+		kfree(dmabuf);
 		return -EIO;
 	}
 
@@ -5748,7 +5815,7 @@ static int
 lpfc_sli4_iocb2wqe(struct lpfc_hba *phba, struct lpfc_iocbq *iocbq,
 		union lpfc_wqe *wqe)
 {
-	uint32_t payload_len = 0;
+	uint32_t xmit_len = 0, total_len = 0;
 	uint8_t ct = 0;
 	uint32_t fip;
 	uint32_t abort_tag;
@@ -5756,12 +5823,15 @@ lpfc_sli4_iocb2wqe(struct lpfc_hba *phba
 	uint8_t cmnd;
 	uint16_t xritag;
 	struct ulp_bde64 *bpl = NULL;
+	uint32_t els_id = ELS_ID_DEFAULT;
+	int numBdes, i;
+	struct ulp_bde64 bde;
 
 	fip = phba->hba_flag & HBA_FIP_SUPPORT;
 	/* The fcp commands will set command type */
 	if (iocbq->iocb_flag &  LPFC_IO_FCP)
 		command_type = FCP_COMMAND;
-	else if (fip && (iocbq->iocb_flag & LPFC_FIP_ELS))
+	else if (fip && (iocbq->iocb_flag & LPFC_FIP_ELS_ID_MASK))
 		command_type = ELS_COMMAND_FIP;
 	else
 		command_type = ELS_COMMAND_NON_FIP;
@@ -5773,6 +5843,8 @@ lpfc_sli4_iocb2wqe(struct lpfc_hba *phba
 	wqe->words[7] = 0; /* The ct field has moved so reset */
 	/* words0-2 bpl convert bde */
 	if (iocbq->iocb.un.genreq64.bdl.bdeFlags == BUFF_TYPE_BLP_64) {
+		numBdes = iocbq->iocb.un.genreq64.bdl.bdeSize /
+				sizeof(struct ulp_bde64);
 		bpl  = (struct ulp_bde64 *)
 			((struct lpfc_dmabuf *)iocbq->context3)->virt;
 		if (!bpl)
@@ -5785,9 +5857,14 @@ lpfc_sli4_iocb2wqe(struct lpfc_hba *phba
 		 * can assign it to the sgl.
 		 */
 		wqe->generic.bde.tus.w  = le32_to_cpu(bpl->tus.w);
-		payload_len = wqe->generic.bde.tus.f.bdeSize;
+		xmit_len = wqe->generic.bde.tus.f.bdeSize;
+		total_len = 0;
+		for (i = 0; i < numBdes; i++) {
+			bde.tus.w  = le32_to_cpu(bpl[i].tus.w);
+			total_len += bde.tus.f.bdeSize;
+		}
 	} else
-		payload_len = iocbq->iocb.un.fcpi64.bdl.bdeSize;
+		xmit_len = iocbq->iocb.un.fcpi64.bdl.bdeSize;
 
 	iocbq->iocb.ulpIoTag = iocbq->iotag;
 	cmnd = iocbq->iocb.ulpCommand;
@@ -5801,7 +5878,7 @@ lpfc_sli4_iocb2wqe(struct lpfc_hba *phba
 				iocbq->iocb.ulpCommand);
 			return IOCB_ERROR;
 		}
-		wqe->els_req.payload_len = payload_len;
+		wqe->els_req.payload_len = xmit_len;
 		/* Els_reguest64 has a TMO */
 		bf_set(wqe_tmo, &wqe->els_req.wqe_com,
 			iocbq->iocb.ulpTimeout);
@@ -5822,7 +5899,22 @@ lpfc_sli4_iocb2wqe(struct lpfc_hba *phba
 		bf_set(lpfc_wqe_gen_ct, &wqe->generic, ct);
 		bf_set(lpfc_wqe_gen_pu, &wqe->generic, 0);
 		/* CCP CCPE PV PRI in word10 were set in the memcpy */
+
+		if (command_type == ELS_COMMAND_FIP) {
+			els_id = ((iocbq->iocb_flag & LPFC_FIP_ELS_ID_MASK)
+					>> LPFC_FIP_ELS_ID_SHIFT);
+		}
+		bf_set(lpfc_wqe_gen_els_id, &wqe->generic, els_id);
+
 	break;
+	case CMD_XMIT_SEQUENCE64_CX:
+		bf_set(lpfc_wqe_gen_context, &wqe->generic,
+					iocbq->iocb.un.ulpWord[3]);
+		wqe->generic.word3 = 0;
+		bf_set(wqe_rcvoxid, &wqe->generic, iocbq->iocb.ulpContext);
+		/* The entire sequence is transmitted for this IOCB */
+		xmit_len = total_len;
+		cmnd = CMD_XMIT_SEQUENCE64_CR;
 	case CMD_XMIT_SEQUENCE64_CR:
 		/* word3 iocb=io_tag32 wqe=payload_offset */
 		/* payload offset used for multilpe outstanding
@@ -5832,7 +5924,8 @@ lpfc_sli4_iocb2wqe(struct lpfc_hba *phba
 		/* word4 relative_offset memcpy */
 		/* word5 r_ctl/df_ctl memcpy */
 		bf_set(lpfc_wqe_gen_pu, &wqe->generic, 0);
-		wqe->xmit_sequence.xmit_len = payload_len;
+		wqe->xmit_sequence.xmit_len = xmit_len;
+		command_type = OTHER_COMMAND;
 	break;
 	case CMD_XMIT_BCAST64_CN:
 		/* word3 iocb=iotag32 wqe=payload_len */
@@ -5861,7 +5954,7 @@ lpfc_sli4_iocb2wqe(struct lpfc_hba *phba
 	case CMD_FCP_IREAD64_CR:
 		/* FCP_CMD is always the 1st sgl entry */
 		wqe->fcp_iread.payload_len =
-			payload_len + sizeof(struct fcp_rsp);
+			xmit_len + sizeof(struct fcp_rsp);
 
 		/* word 4 (xfer length) should have been set on the memcpy */
 
@@ -5898,7 +5991,7 @@ lpfc_sli4_iocb2wqe(struct lpfc_hba *phba
 		 * sgl[1] = rsp.
 		 *
 		 */
-		wqe->gen_req.command_len = payload_len;
+		wqe->gen_req.command_len = xmit_len;
 		/* Word4 parameter  copied in the memcpy */
 		/* Word5 [rctl, type, df_ctl, la] copied in memcpy */
 		/* word6 context tag copied in memcpy */
@@ -5950,12 +6043,10 @@ lpfc_sli4_iocb2wqe(struct lpfc_hba *phba
 		else
 			bf_set(abort_cmd_ia, &wqe->abort_cmd, 0);
 		bf_set(abort_cmd_criteria, &wqe->abort_cmd, T_XRI_TAG);
-		abort_tag = iocbq->iocb.un.acxri.abortIoTag;
 		wqe->words[5] = 0;
 		bf_set(lpfc_wqe_gen_ct, &wqe->generic,
 			((iocbq->iocb.ulpCt_h << 1) | iocbq->iocb.ulpCt_l));
 		abort_tag = iocbq->iocb.un.acxri.abortIoTag;
-		wqe->generic.abort_tag = abort_tag;
 		/*
 		 * The abort handler will send us CMD_ABORT_XRI_CN or
 		 * CMD_CLOSE_XRI_CN and the fw only accepts CMD_ABORT_XRI_CX
@@ -5971,10 +6062,25 @@ lpfc_sli4_iocb2wqe(struct lpfc_hba *phba
 		 * iocbq from scratch.
 		 */
 		memset(wqe, 0, sizeof(union lpfc_wqe));
+		/* OX_ID is invariable to who sent ABTS to CT exchange */
 		bf_set(xmit_bls_rsp64_oxid, &wqe->xmit_bls_rsp,
-		       iocbq->iocb.un.ulpWord[3]);
-		bf_set(xmit_bls_rsp64_rxid, &wqe->xmit_bls_rsp,
-		       iocbq->sli4_xritag);
+		       bf_get(lpfc_abts_oxid, &iocbq->iocb.un.bls_acc));
+		if (bf_get(lpfc_abts_orig, &iocbq->iocb.un.bls_acc) ==
+		    LPFC_ABTS_UNSOL_INT) {
+			/* ABTS sent by initiator to CT exchange, the
+			 * RX_ID field will be filled with the newly
+			 * allocated responder XRI.
+			 */
+			bf_set(xmit_bls_rsp64_rxid, &wqe->xmit_bls_rsp,
+			       iocbq->sli4_xritag);
+		} else {
+			/* ABTS sent by responder to CT exchange, the
+			 * RX_ID field will be filled with the responder
+			 * RX_ID from ABTS.
+			 */
+			bf_set(xmit_bls_rsp64_rxid, &wqe->xmit_bls_rsp,
+			       bf_get(lpfc_abts_rxid, &iocbq->iocb.un.bls_acc));
+		}
 		bf_set(xmit_bls_rsp64_seqcnthi, &wqe->xmit_bls_rsp, 0xffff);
 		bf_set(wqe_xmit_bls_pt, &wqe->xmit_bls_rsp.wqe_dest, 0x1);
 		bf_set(wqe_ctxt_tag, &wqe->xmit_bls_rsp.wqe_com,
@@ -6036,7 +6142,6 @@ __lpfc_sli_issue_iocb_s4(struct lpfc_hba
 	uint16_t xritag;
 	union lpfc_wqe wqe;
 	struct lpfc_sli_ring *pring = &phba->sli.ring[ring_number];
-	uint32_t fcp_wqidx;
 
 	if (piocb->sli4_xritag == NO_XRI) {
 		if (piocb->iocb.ulpCommand == CMD_ABORT_XRI_CN ||
@@ -6071,8 +6176,17 @@ __lpfc_sli_issue_iocb_s4(struct lpfc_hba
 		return IOCB_ERROR;
 
 	if (piocb->iocb_flag &  LPFC_IO_FCP) {
-		fcp_wqidx = lpfc_sli4_scmd_to_wqidx_distr(phba);
-		if (lpfc_sli4_wq_put(phba->sli4_hba.fcp_wq[fcp_wqidx], &wqe))
+		/*
+		 * For FCP command IOCB, get a new WQ index to distribute
+		 * WQE across the WQsr. On the other hand, for abort IOCB,
+		 * it carries the same WQ index to the original command
+		 * IOCB.
+		 */
+		if ((piocb->iocb.ulpCommand != CMD_ABORT_XRI_CN) &&
+		    (piocb->iocb.ulpCommand != CMD_CLOSE_XRI_CN))
+			piocb->fcp_wqidx = lpfc_sli4_scmd_to_wqidx_distr(phba);
+		if (lpfc_sli4_wq_put(phba->sli4_hba.fcp_wq[piocb->fcp_wqidx],
+				     &wqe))
 			return IOCB_ERROR;
 	} else {
 		if (lpfc_sli4_wq_put(phba->sli4_hba.els_wq, &wqe))
@@ -6944,7 +7058,14 @@ lpfc_sli_abort_els_cmpl(struct lpfc_hba 
 		    abort_iocb->iocb.ulpContext != abort_context ||
 		    (abort_iocb->iocb_flag & LPFC_DRIVER_ABORTED) == 0)
 			spin_unlock_irq(&phba->hbalock);
-		else {
+		else if (phba->sli_rev < LPFC_SLI_REV4) {
+			/*
+			 * leave the SLI4 aborted command on the txcmplq
+			 * list and the command complete WCQE's XB bit
+			 * will tell whether the SGL (XRI) can be released
+			 * immediately or to the aborted SGL list for the
+			 * following abort XRI from the HBA.
+			 */
 			list_del_init(&abort_iocb->list);
 			pring->txcmplq_cnt--;
 			spin_unlock_irq(&phba->hbalock);
@@ -6953,11 +7074,13 @@ lpfc_sli_abort_els_cmpl(struct lpfc_hba 
 			 * payload, so don't free data buffer till after
 			 * a hbeat.
 			 */
+			spin_lock_irq(&phba->hbalock);
 			abort_iocb->iocb_flag |= LPFC_DELAY_MEM_FREE;
-
 			abort_iocb->iocb_flag &= ~LPFC_DRIVER_ABORTED;
+			spin_unlock_irq(&phba->hbalock);
+
 			abort_iocb->iocb.ulpStatus = IOSTAT_LOCAL_REJECT;
-			abort_iocb->iocb.un.ulpWord[4] = IOERR_SLI_ABORTED;
+			abort_iocb->iocb.un.ulpWord[4] = IOERR_ABORT_REQUESTED;
 			(abort_iocb->iocb_cmpl)(phba, abort_iocb, abort_iocb);
 		}
 	}
@@ -7046,7 +7169,7 @@ lpfc_sli_issue_abort_iotag(struct lpfc_h
 		return 0;
 
 	/* This signals the response to set the correct status
-	 * before calling the completion handler.
+	 * before calling the completion handler
 	 */
 	cmdiocb->iocb_flag |= LPFC_DRIVER_ABORTED;
 
@@ -7062,6 +7185,9 @@ lpfc_sli_issue_abort_iotag(struct lpfc_h
 	iabt->ulpLe = 1;
 	iabt->ulpClass = icmd->ulpClass;
 
+	/* ABTS WQE must go to the same WQ as the WQE to be aborted */
+	abtsiocbp->fcp_wqidx = cmdiocb->fcp_wqidx;
+
 	if (phba->link_state >= LPFC_LINK_UP)
 		iabt->ulpCommand = CMD_ABORT_XRI_CN;
 	else
@@ -7265,6 +7391,9 @@ lpfc_sli_abort_iocb(struct lpfc_vport *v
 		abtsiocb->iocb.ulpClass = cmd->ulpClass;
 		abtsiocb->vport = phba->pport;
 
+		/* ABTS WQE must go to the same WQ as the WQE to be aborted */
+		abtsiocb->fcp_wqidx = iocbq->fcp_wqidx;
+
 		if (lpfc_is_link_up(phba))
 			abtsiocb->iocb.ulpCommand = CMD_ABORT_XRI_CN;
 		else
@@ -7630,31 +7759,28 @@ static int
 lpfc_sli4_eratt_read(struct lpfc_hba *phba)
 {
 	uint32_t uerr_sta_hi, uerr_sta_lo;
-	uint32_t onlnreg0, onlnreg1;
 
 	/* For now, use the SLI4 device internal unrecoverable error
 	 * registers for error attention. This can be changed later.
 	 */
-	onlnreg0 = readl(phba->sli4_hba.ONLINE0regaddr);
-	onlnreg1 = readl(phba->sli4_hba.ONLINE1regaddr);
-	if ((onlnreg0 != LPFC_ONLINE_NERR) || (onlnreg1 != LPFC_ONLINE_NERR)) {
-		uerr_sta_lo = readl(phba->sli4_hba.UERRLOregaddr);
-		uerr_sta_hi = readl(phba->sli4_hba.UERRHIregaddr);
-		if (uerr_sta_lo || uerr_sta_hi) {
-			lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
-					"1423 HBA Unrecoverable error: "
-					"uerr_lo_reg=0x%x, uerr_hi_reg=0x%x, "
-					"online0_reg=0x%x, online1_reg=0x%x\n",
-					uerr_sta_lo, uerr_sta_hi,
-					onlnreg0, onlnreg1);
-			phba->work_status[0] = uerr_sta_lo;
-			phba->work_status[1] = uerr_sta_hi;
-			/* Set the driver HA work bitmap */
-			phba->work_ha |= HA_ERATT;
-			/* Indicate polling handles this ERATT */
-			phba->hba_flag |= HBA_ERATT_HANDLED;
-			return 1;
-		}
+	uerr_sta_lo = readl(phba->sli4_hba.UERRLOregaddr);
+	uerr_sta_hi = readl(phba->sli4_hba.UERRHIregaddr);
+	if ((~phba->sli4_hba.ue_mask_lo & uerr_sta_lo) ||
+	    (~phba->sli4_hba.ue_mask_hi & uerr_sta_hi)) {
+		lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
+				"1423 HBA Unrecoverable error: "
+				"uerr_lo_reg=0x%x, uerr_hi_reg=0x%x, "
+				"ue_mask_lo_reg=0x%x, ue_mask_hi_reg=0x%x\n",
+				uerr_sta_lo, uerr_sta_hi,
+				phba->sli4_hba.ue_mask_lo,
+				phba->sli4_hba.ue_mask_hi);
+		phba->work_status[0] = uerr_sta_lo;
+		phba->work_status[1] = uerr_sta_hi;
+		/* Set the driver HA work bitmap */
+		phba->work_ha |= HA_ERATT;
+		/* Indicate polling handles this ERATT */
+		phba->hba_flag |= HBA_ERATT_HANDLED;
+		return 1;
 	}
 	return 0;
 }
@@ -7777,7 +7903,7 @@ irqreturn_t
 lpfc_sli_sp_intr_handler(int irq, void *dev_id)
 {
 	struct lpfc_hba  *phba;
-	uint32_t ha_copy;
+	uint32_t ha_copy, hc_copy;
 	uint32_t work_ha_copy;
 	unsigned long status;
 	unsigned long iflag;
@@ -7835,8 +7961,13 @@ lpfc_sli_sp_intr_handler(int irq, void *
 		}
 
 		/* Clear up only attention source related to slow-path */
+		hc_copy = readl(phba->HCregaddr);
+		writel(hc_copy & ~(HC_MBINT_ENA | HC_R2INT_ENA |
+			HC_LAINT_ENA | HC_ERINT_ENA),
+			phba->HCregaddr);
 		writel((ha_copy & (HA_MBATT | HA_R2_CLR_MSK)),
 			phba->HAregaddr);
+		writel(hc_copy, phba->HCregaddr);
 		readl(phba->HAregaddr); /* flush */
 		spin_unlock_irqrestore(&phba->hbalock, iflag);
 	} else
@@ -8146,6 +8277,7 @@ lpfc_sli_intr_handler(int irq, void *dev
 	struct lpfc_hba  *phba;
 	irqreturn_t sp_irq_rc, fp_irq_rc;
 	unsigned long status1, status2;
+	uint32_t hc_copy;
 
 	/*
 	 * Get the driver's phba structure from the dev_id and
@@ -8183,7 +8315,12 @@ lpfc_sli_intr_handler(int irq, void *dev
 	}
 
 	/* Clear attention sources except link and error attentions */
+	hc_copy = readl(phba->HCregaddr);
+	writel(hc_copy & ~(HC_MBINT_ENA | HC_R0INT_ENA | HC_R1INT_ENA
+		| HC_R2INT_ENA | HC_LAINT_ENA | HC_ERINT_ENA),
+		phba->HCregaddr);
 	writel((phba->ha_copy & ~(HA_LATT | HA_ERATT)), phba->HAregaddr);
+	writel(hc_copy, phba->HCregaddr);
 	readl(phba->HAregaddr); /* flush */
 	spin_unlock(&phba->hbalock);
 
@@ -8285,11 +8422,24 @@ void lpfc_sli4_els_xri_abort_event_proc(
 	}
 }
 
+/**
+ * lpfc_sli4_iocb_param_transfer - Transfer pIocbOut and cmpl status to pIocbIn
+ * @phba: pointer to lpfc hba data structure
+ * @pIocbIn: pointer to the rspiocbq
+ * @pIocbOut: pointer to the cmdiocbq
+ * @wcqe: pointer to the complete wcqe
+ *
+ * This routine transfers the fields of a command iocbq to a response iocbq
+ * by copying all the IOCB fields from command iocbq and transferring the
+ * completion status information from the complete wcqe.
+ **/
 static void
-lpfc_sli4_iocb_param_transfer(struct lpfc_iocbq *pIocbIn,
+lpfc_sli4_iocb_param_transfer(struct lpfc_hba *phba,
+			      struct lpfc_iocbq *pIocbIn,
 			      struct lpfc_iocbq *pIocbOut,
 			      struct lpfc_wcqe_complete *wcqe)
 {
+	unsigned long iflags;
 	size_t offset = offsetof(struct lpfc_iocbq, iocb);
 
 	memcpy((char *)pIocbIn + offset, (char *)pIocbOut + offset,
@@ -8303,8 +8453,17 @@ lpfc_sli4_iocb_param_transfer(struct lpf
 					wcqe->total_data_placed;
 		else
 			pIocbIn->iocb.un.ulpWord[4] = wcqe->parameter;
-	else
+	else {
 		pIocbIn->iocb.un.ulpWord[4] = wcqe->parameter;
+		pIocbIn->iocb.un.genreq64.bdl.bdeSize = wcqe->total_data_placed;
+	}
+
+	/* Pick up HBA exchange busy condition */
+	if (bf_get(lpfc_wcqe_c_xb, wcqe)) {
+		spin_lock_irqsave(&phba->hbalock, iflags);
+		pIocbIn->iocb_flag |= LPFC_EXCHANGE_BUSY;
+		spin_unlock_irqrestore(&phba->hbalock, iflags);
+	}
 }
 
 /**
@@ -8345,7 +8504,7 @@ lpfc_sli4_els_wcqe_to_rspiocbq(struct lp
 	}
 
 	/* Fake the irspiocbq and copy necessary response information */
-	lpfc_sli4_iocb_param_transfer(irspiocbq, cmdiocbq, wcqe);
+	lpfc_sli4_iocb_param_transfer(phba, irspiocbq, cmdiocbq, wcqe);
 
 	return irspiocbq;
 }
@@ -8663,7 +8822,6 @@ lpfc_sli4_sp_handle_rcqe(struct lpfc_hba
 	uint32_t status;
 	unsigned long iflags;
 
-	lpfc_sli4_rq_release(hrq, drq);
 	if (bf_get(lpfc_rcqe_rq_id, rcqe) != hrq->queue_id)
 		goto out;
 
@@ -8673,6 +8831,7 @@ lpfc_sli4_sp_handle_rcqe(struct lpfc_hba
 		lpfc_printf_log(phba, KERN_ERR, LOG_SLI,
 				"2537 Receive Frame Truncated!!\n");
 	case FC_STATUS_RQ_SUCCESS:
+		lpfc_sli4_rq_release(hrq, drq);
 		spin_lock_irqsave(&phba->hbalock, iflags);
 		dma_buf = lpfc_sli_hbqbuf_get(&phba->hbqs[0].hbq_buffer_list);
 		if (!dma_buf) {
@@ -8902,7 +9061,7 @@ lpfc_sli4_fp_handle_fcp_wcqe(struct lpfc
 	}
 
 	/* Fake the irspiocb and copy necessary response information */
-	lpfc_sli4_iocb_param_transfer(&irspiocbq, cmdiocbq, wcqe);
+	lpfc_sli4_iocb_param_transfer(phba, &irspiocbq, cmdiocbq, wcqe);
 
 	/* Pass the cmd_iocb and the rsp state to the upper layer */
 	(cmdiocbq->iocb_cmpl)(phba, cmdiocbq, &irspiocbq);
@@ -10877,7 +11036,8 @@ lpfc_fc_frame_add(struct lpfc_vport *vpo
 		return dmabuf;
 	}
 	temp_hdr = seq_dmabuf->hbuf.virt;
-	if (new_hdr->fh_seq_cnt < temp_hdr->fh_seq_cnt) {
+	if (be16_to_cpu(new_hdr->fh_seq_cnt) <
+		be16_to_cpu(temp_hdr->fh_seq_cnt)) {
 		list_del_init(&seq_dmabuf->hbuf.list);
 		list_add_tail(&dmabuf->hbuf.list, &vport->rcv_buffer_list);
 		list_add_tail(&dmabuf->dbuf.list, &seq_dmabuf->dbuf.list);
@@ -10888,6 +11048,11 @@ lpfc_fc_frame_add(struct lpfc_vport *vpo
 	list_move_tail(&seq_dmabuf->hbuf.list, &vport->rcv_buffer_list);
 	seq_dmabuf->time_stamp = jiffies;
 	lpfc_update_rcv_time_stamp(vport);
+	if (list_empty(&seq_dmabuf->dbuf.list)) {
+		temp_hdr = dmabuf->hbuf.virt;
+		list_add_tail(&dmabuf->dbuf.list, &seq_dmabuf->dbuf.list);
+		return seq_dmabuf;
+	}
 	/* find the correct place in the sequence to insert this frame */
 	list_for_each_entry_reverse(d_buf, &seq_dmabuf->dbuf.list, list) {
 		temp_dmabuf = container_of(d_buf, struct hbq_dmabuf, dbuf);
@@ -10896,7 +11061,8 @@ lpfc_fc_frame_add(struct lpfc_vport *vpo
 		 * If the frame's sequence count is greater than the frame on
 		 * the list then insert the frame right after this frame
 		 */
-		if (new_hdr->fh_seq_cnt > temp_hdr->fh_seq_cnt) {
+		if (be16_to_cpu(new_hdr->fh_seq_cnt) >
+			be16_to_cpu(temp_hdr->fh_seq_cnt)) {
 			list_add(&dmabuf->dbuf.list, &temp_dmabuf->dbuf.list);
 			return seq_dmabuf;
 		}
@@ -10989,8 +11155,8 @@ lpfc_sli4_seq_abort_acc(struct lpfc_hba 
 {
 	struct lpfc_iocbq *ctiocb = NULL;
 	struct lpfc_nodelist *ndlp;
-	uint16_t oxid;
-	uint32_t sid;
+	uint16_t oxid, rxid;
+	uint32_t sid, fctl;
 	IOCB_t *icmd;
 
 	if (!lpfc_is_link_up(phba))
@@ -10998,6 +11164,7 @@ lpfc_sli4_seq_abort_acc(struct lpfc_hba 
 
 	sid = sli4_sid_from_fc_hdr(fc_hdr);
 	oxid = be16_to_cpu(fc_hdr->fh_ox_id);
+	rxid = be16_to_cpu(fc_hdr->fh_rx_id);
 
 	ndlp = lpfc_findnode_did(phba->pport, sid);
 	if (!ndlp) {
@@ -11012,9 +11179,12 @@ lpfc_sli4_seq_abort_acc(struct lpfc_hba 
 	if (!ctiocb)
 		return;
 
+	/* Extract the F_CTL field from FC_HDR */
+	fctl = sli4_fctl_from_fc_hdr(fc_hdr);
+
 	icmd = &ctiocb->iocb;
-	icmd->un.xseq64.bdl.ulpIoTag32 = 0;
 	icmd->un.xseq64.bdl.bdeSize = 0;
+	icmd->un.xseq64.bdl.ulpIoTag32 = 0;
 	icmd->un.xseq64.w5.hcsw.Dfctl = 0;
 	icmd->un.xseq64.w5.hcsw.Rctl = FC_RCTL_BA_ACC;
 	icmd->un.xseq64.w5.hcsw.Type = FC_TYPE_BLS;
@@ -11025,13 +11195,30 @@ lpfc_sli4_seq_abort_acc(struct lpfc_hba 
 	icmd->ulpLe = 1;
 	icmd->ulpClass = CLASS3;
 	icmd->ulpContext = ndlp->nlp_rpi;
-	icmd->un.ulpWord[3] = oxid;
 
-	ctiocb->sli4_xritag = NO_XRI;
 	ctiocb->iocb_cmpl = NULL;
 	ctiocb->vport = phba->pport;
 	ctiocb->iocb_cmpl = lpfc_sli4_seq_abort_acc_cmpl;
 
+	if (fctl & FC_FC_EX_CTX) {
+		/* ABTS sent by responder to CT exchange, construction
+		 * of BA_ACC will use OX_ID from ABTS for the XRI_TAG
+		 * field and RX_ID from ABTS for RX_ID field.
+		 */
+		bf_set(lpfc_abts_orig, &icmd->un.bls_acc, LPFC_ABTS_UNSOL_RSP);
+		bf_set(lpfc_abts_rxid, &icmd->un.bls_acc, rxid);
+		ctiocb->sli4_xritag = oxid;
+	} else {
+		/* ABTS sent by initiator to CT exchange, construction
+		 * of BA_ACC will need to allocate a new XRI as for the
+		 * XRI_TAG and RX_ID fields.
+		 */
+		bf_set(lpfc_abts_orig, &icmd->un.bls_acc, LPFC_ABTS_UNSOL_INT);
+		bf_set(lpfc_abts_rxid, &icmd->un.bls_acc, NO_XRI);
+		ctiocb->sli4_xritag = NO_XRI;
+	}
+	bf_set(lpfc_abts_oxid, &icmd->un.bls_acc, oxid);
+
 	/* Xmit CT abts accept on exchange <xid> */
 	lpfc_printf_log(phba, KERN_INFO, LOG_ELS,
 			"1200 Xmit CT ABTS ACC on exchange x%x Data: x%x\n",
@@ -11058,19 +11245,31 @@ lpfc_sli4_handle_unsol_abort(struct lpfc
 {
 	struct lpfc_hba *phba = vport->phba;
 	struct fc_frame_header fc_hdr;
+	uint32_t fctl;
 	bool abts_par;
 
-	/* Try to abort partially assembled seq */
-	abts_par = lpfc_sli4_abort_partial_seq(vport, dmabuf);
-
 	/* Make a copy of fc_hdr before the dmabuf being released */
 	memcpy(&fc_hdr, dmabuf->hbuf.virt, sizeof(struct fc_frame_header));
+	fctl = sli4_fctl_from_fc_hdr(&fc_hdr);
 
-	/* Send abort to ULP if partially seq abort failed */
-	if (abts_par == false)
-		lpfc_sli4_send_seq_to_ulp(vport, dmabuf);
-	else
+	if (fctl & FC_FC_EX_CTX) {
+		/*
+		 * ABTS sent by responder to exchange, just free the buffer
+		 */
 		lpfc_in_buf_free(phba, &dmabuf->dbuf);
+	} else {
+		/*
+		 * ABTS sent by initiator to exchange, need to do cleanup
+		 */
+		/* Try to abort partially assembled seq */
+		abts_par = lpfc_sli4_abort_partial_seq(vport, dmabuf);
+
+		/* Send abort to ULP if partially seq abort failed */
+		if (abts_par == false)
+			lpfc_sli4_send_seq_to_ulp(vport, dmabuf);
+		else
+			lpfc_in_buf_free(phba, &dmabuf->dbuf);
+	}
 	/* Send basic accept (BA_ACC) to the abort requester */
 	lpfc_sli4_seq_abort_acc(phba, &fc_hdr);
 }
@@ -11110,7 +11309,7 @@ lpfc_seq_complete(struct hbq_dmabuf *dma
 		seq_dmabuf = container_of(d_buf, struct hbq_dmabuf, dbuf);
 		hdr = (struct fc_frame_header *)seq_dmabuf->hbuf.virt;
 		/* If there is a hole in the sequence count then fail. */
-		if (++seq_count != hdr->fh_seq_cnt)
+		if (++seq_count != be16_to_cpu(hdr->fh_seq_cnt))
 			return 0;
 		fctl = (hdr->fh_f_ctl[0] << 16 |
 			hdr->fh_f_ctl[1] << 8 |
@@ -11142,6 +11341,7 @@ lpfc_prep_seq(struct lpfc_vport *vport, 
 	struct lpfc_iocbq *first_iocbq, *iocbq;
 	struct fc_frame_header *fc_hdr;
 	uint32_t sid;
+	struct ulp_bde64 *pbde;
 
 	fc_hdr = (struct fc_frame_header *)seq_dmabuf->hbuf.virt;
 	/* remove from receive buffer list */
@@ -11183,8 +11383,9 @@ lpfc_prep_seq(struct lpfc_vport *vport, 
 		if (!iocbq->context3) {
 			iocbq->context3 = d_buf;
 			iocbq->iocb.ulpBdeCount++;
-			iocbq->iocb.unsli3.rcvsli3.bde2.tus.f.bdeSize =
-							LPFC_DATA_BUF_SIZE;
+			pbde = (struct ulp_bde64 *)
+					&iocbq->iocb.unsli3.sli3Words[4];
+			pbde->tus.f.bdeSize = LPFC_DATA_BUF_SIZE;
 			first_iocbq->iocb.unsli3.rcvsli3.acc_len +=
 				bf_get(lpfc_rcqe_length,
 				       &seq_dmabuf->cq_event.cqe.rcqe_cmpl);
@@ -11282,7 +11483,7 @@ lpfc_sli4_handle_received_buffer(struct 
 	}
 	fcfi = bf_get(lpfc_rcqe_fcf_id, &dmabuf->cq_event.cqe.rcqe_cmpl);
 	vport = lpfc_fc_frame_to_vport(phba, fc_hdr, fcfi);
-	if (!vport) {
+	if (!vport || !(vport->vpi_state & LPFC_VPI_REGISTERED)) {
 		/* throw out the frame */
 		lpfc_in_buf_free(phba, &dmabuf->dbuf);
 		return;
@@ -11301,15 +11502,9 @@ lpfc_sli4_handle_received_buffer(struct 
 		return;
 	}
 	/* If not last frame in sequence continue processing frames. */
-	if (!lpfc_seq_complete(seq_dmabuf)) {
-		/*
-		 * When saving off frames post a new one and mark this
-		 * frame to be freed when it is finished.
-		 **/
-		lpfc_sli_hbqbuf_fill_hbqs(phba, LPFC_ELS_HBQ, 1);
-		dmabuf->tag = -1;
+	if (!lpfc_seq_complete(seq_dmabuf))
 		return;
-	}
+
 	/* Send the complete sequence to the upper layer protocol */
 	lpfc_sli4_send_seq_to_ulp(vport, seq_dmabuf);
 }
@@ -11959,3 +12154,48 @@ out:
 	kfree(rgn23_data);
 	return;
 }
+
+/**
+ * lpfc_cleanup_pending_mbox - Free up vport discovery mailbox commands.
+ * @vport: pointer to vport data structure.
+ *
+ * This function iterate through the mailboxq and clean up all REG_LOGIN
+ * and REG_VPI mailbox commands associated with the vport. This function
+ * is called when driver want to restart discovery of the vport due to
+ * a Clear Virtual Link event.
+ **/
+void
+lpfc_cleanup_pending_mbox(struct lpfc_vport *vport)
+{
+	struct lpfc_hba *phba = vport->phba;
+	LPFC_MBOXQ_t *mb, *nextmb;
+	struct lpfc_dmabuf *mp;
+
+	spin_lock_irq(&phba->hbalock);
+	list_for_each_entry_safe(mb, nextmb, &phba->sli.mboxq, list) {
+		if (mb->vport != vport)
+			continue;
+
+		if ((mb->u.mb.mbxCommand != MBX_REG_LOGIN64) &&
+			(mb->u.mb.mbxCommand != MBX_REG_VPI))
+			continue;
+
+		if (mb->u.mb.mbxCommand == MBX_REG_LOGIN64) {
+			mp = (struct lpfc_dmabuf *) (mb->context1);
+			if (mp) {
+				__lpfc_mbuf_free(phba, mp->virt, mp->phys);
+				kfree(mp);
+			}
+		}
+		list_del(&mb->list);
+		mempool_free(mb, phba->mbox_mem_pool);
+	}
+	mb = phba->sli.mbox_active;
+	if (mb && (mb->vport == vport)) {
+		if ((mb->u.mb.mbxCommand == MBX_REG_LOGIN64) ||
+			(mb->u.mb.mbxCommand == MBX_REG_VPI))
+			mb->mbox_cmpl = lpfc_sli_def_mbox_cmpl;
+	}
+	spin_unlock_irq(&phba->hbalock);
+}
+
diff -urpN a/drivers/scsi/lpfc/lpfc_sli.h b/drivers/scsi/lpfc/lpfc_sli.h
--- a/drivers/scsi/lpfc/lpfc_sli.h	2010-01-12 16:47:01.241034000 -0500
+++ b/drivers/scsi/lpfc/lpfc_sli.h	2010-01-12 16:46:28.751798000 -0500
@@ -53,18 +53,21 @@ struct lpfc_iocbq {
 
 	IOCB_t iocb;		/* IOCB cmd */
 	uint8_t retry;		/* retry counter for IOCB cmd - if needed */
-	uint8_t iocb_flag;
+	uint16_t iocb_flag;
 #define LPFC_IO_LIBDFC		1	/* libdfc iocb */
 #define LPFC_IO_WAKE		2	/* High Priority Queue signal flag */
 #define LPFC_IO_FCP		4	/* FCP command -- iocbq in scsi_buf */
 #define LPFC_DRIVER_ABORTED	8	/* driver aborted this request */
 #define LPFC_IO_FABRIC		0x10	/* Iocb send using fabric scheduler */
 #define LPFC_DELAY_MEM_FREE	0x20    /* Defer free'ing of FC data */
-#define LPFC_FIP_ELS		0x40
+#define LPFC_EXCHANGE_BUSY	0x40    /* SLI4 hba reported XB in response */
+
+#define LPFC_FIP_ELS_ID_MASK	0xc000	/* ELS_ID range 0-3, non-shifted mask */
+#define LPFC_FIP_ELS_ID_SHIFT	14
 
-	uint8_t abort_count;
 	uint8_t rsvd2;
 	uint32_t drvrTimeout;	/* driver timeout in seconds */
+	uint32_t fcp_wqidx;	/* index to FCP work queue */
 	struct lpfc_vport *vport;/* virtual port pointer */
 	void *context1;		/* caller context information */
 	void *context2;		/* caller context information */
diff -urpN a/drivers/scsi/lpfc/lpfc_version.h b/drivers/scsi/lpfc/lpfc_version.h
--- a/drivers/scsi/lpfc/lpfc_version.h	2010-01-12 16:47:01.244034000 -0500
+++ b/drivers/scsi/lpfc/lpfc_version.h	2010-01-12 16:46:28.756798000 -0500
@@ -18,7 +18,7 @@
  * included with this package.                                     *
  *******************************************************************/
 
-#define LPFC_DRIVER_VERSION "8.3.5"
+#define LPFC_DRIVER_VERSION "8.3.5.3"
 #define LPFC_DRIVER_NAME		"lpfc"
 #define LPFC_SP_DRIVER_HANDLER_NAME	"lpfc:sp"
 #define LPFC_FP_DRIVER_HANDLER_NAME	"lpfc:fp"
diff -urpN a/drivers/scsi/lpfc/lpfc_vport.c b/drivers/scsi/lpfc/lpfc_vport.c
--- a/drivers/scsi/lpfc/lpfc_vport.c	2010-01-12 16:47:01.250025000 -0500
+++ b/drivers/scsi/lpfc/lpfc_vport.c	2010-01-12 16:46:28.765798000 -0500
@@ -44,6 +44,7 @@
 #include "lpfc_crtn.h"
 #include "lpfc_version.h"
 #include "lpfc_vport.h"
+#include "lpfc_auth_access.h"
 
 inline void lpfc_vport_set_state(struct lpfc_vport *vport,
 				 enum fc_vport_state new_state)
@@ -378,6 +379,21 @@ lpfc_vport_create(struct fc_vport *fc_vp
 		goto error_out;
 	}
 
+	shost = lpfc_shost_from_vport(vport);
+
+	if ((lpfc_get_security_enabled)(shost)) {
+		/* Triggers fcauthd to register if it is running */
+		fc_host_post_event(shost, fc_get_event_number(),
+				   FCH_EVT_PORT_ONLINE, shost->host_no);
+		spin_lock_irq(&fc_security_user_lock);
+		list_add_tail(&vport->sc_users, &fc_security_user_list);
+		spin_unlock_irq(&fc_security_user_lock);
+		if (fc_service_state == FC_SC_SERVICESTATE_ONLINE) {
+			lpfc_fc_queue_security_work(vport,
+				&vport->sc_online_work);
+		}
+	}
+
 	/* Create binary sysfs attribute for vport */
 	lpfc_alloc_sysfs_attr(vport);
 
@@ -389,7 +405,7 @@ lpfc_vport_create(struct fc_vport *fc_vp
 	 * by the port.
 	 */
 	if ((phba->sli_rev == LPFC_SLI_REV4) &&
-		(pport->vfi_state & LPFC_VFI_REGISTERED)) {
+		(pport->fc_flag & FC_VFI_REGISTERED)) {
 		rc = lpfc_sli4_init_vpi(phba, vpi);
 		if (rc) {
 			lpfc_printf_log(phba, KERN_ERR, LOG_VPORT,
@@ -512,8 +528,10 @@ enable_vport(struct fc_vport *fc_vport)
 		return VPORT_OK;
 	}
 
+	spin_lock_irq(&phba->hbalock);
 	vport->load_flag |= FC_LOADING;
 	vport->fc_flag |= FC_VPORT_NEEDS_REG_VPI;
+	spin_unlock_irq(&phba->hbalock);
 
 	/* Use the Physical nodes Fabric NDLP to determine if the link is
 	 * up and ready to FDISC.
@@ -700,6 +718,8 @@ lpfc_vport_delete(struct fc_vport *fc_vp
 			}
 			spin_unlock_irq(&phba->ndlp_lock);
 		}
+		if (!(vport->vpi_state & LPFC_VPI_REGISTERED))
+			goto skip_logo;
 		vport->unreg_vpi_cmpl = VPORT_INVAL;
 		timeout = msecs_to_jiffies(phba->fc_ratov * 2000);
 		if (!lpfc_issue_els_npiv_logo(vport, ndlp))
diff -urpN a/drivers/scsi/lpfc/Makefile b/drivers/scsi/lpfc/Makefile
--- a/drivers/scsi/lpfc/Makefile	2010-01-12 16:47:01.258017000 -0500
+++ b/drivers/scsi/lpfc/Makefile	2010-01-12 16:46:28.770799000 -0500
@@ -1,7 +1,7 @@
 #/*******************************************************************
 # * This file is part of the Emulex Linux Device Driver for         *
 # * Fibre Channel Host Bus Adapters.                                *
-# * Copyright (C) 2004-2006 Emulex.  All rights reserved.           *
+# * Copyright (C) 2004-2009 Emulex.  All rights reserved.           *
 # * EMULEX and SLI are trademarks of Emulex.                        *
 # * www.emulex.com                                                  *
 # *                                                                 *
@@ -28,4 +28,5 @@ obj-$(CONFIG_SCSI_LPFC) := lpfc.o
 
 lpfc-objs := lpfc_mem.o lpfc_sli.o lpfc_ct.o lpfc_els.o lpfc_hbadisc.o	\
 	lpfc_init.o lpfc_mbox.o lpfc_nportdisc.o lpfc_scsi.o lpfc_attr.o \
-	lpfc_vport.o lpfc_debugfs.o lpfc_bsg.o
+	lpfc_vport.o lpfc_debugfs.o lpfc_security.o lpfc_auth_access.o \
+	lpfc_auth.o lpfc_bsg.o

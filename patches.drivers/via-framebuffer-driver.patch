From: Joseph Chan <josephchan@via.com.tw>
Subject: Via Framebuffer driver
Patch-mainline: 2.6.28

This is a merge of the following commits in the upstream kernel tree that add
the via framebuffer driver to the kernel.  This is needed by the HP2133
hardware at the least, and other "netbook" type devices

	09a525ec1cf5a142f2e73f15527c169dafc6ff52
	6bde3ed98d9d0bc2e71b3123b003d5614debda74
	801b8a8c91ff054cc93fdac65e2f067c22986bbb
	ae35e8106a960dc19c930badd80dd14d47d83839
	c09c782f3e7d38e1f3842822209bb6faff4a2b1b
	d61e0bf38e3e4adb2c775d64e447f6f9bef67075
	c91b557ad0a4d4803874f8b908aa9732152b0f0b
	ac6c97e20f1befecd791feed57170ec6735dcce7
	37773cf564935a02b699b6db37a9f29f0bc6cd2c
	d42823ef6a3ebd388b193c5533efd7e7a00b7aa8
	29b619fae69a0638ce10d5d6bb3c53f5d3ca0390
	b3a45d8e5d9049c3a47b3f97405b4123bef5155b
	9f291634aa2d79dee2d8a61c5bdffe166001c580
	23966d5b52e6ee1f90bb343766a9703dafceae83

Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 Documentation/fb/viafb.modes      |  870 +++++++++++
 Documentation/fb/viafb.txt        |  214 ++
 drivers/video/Kconfig             |   18 
 drivers/video/Makefile            |    1 
 drivers/video/via/Makefile        |    7 
 drivers/video/via/accel.c         |  279 +++
 drivers/video/via/accel.h         |  169 ++
 drivers/video/via/chip.h          |  190 ++
 drivers/video/via/debug.h         |   41 
 drivers/video/via/dvi.c           |  682 +++++++++
 drivers/video/via/dvi.h           |   64 
 drivers/video/via/global.c        |   60 
 drivers/video/via/global.h        |   90 +
 drivers/video/via/hw.c            | 2865 ++++++++++++++++++++++++++++++++++++++
 drivers/video/via/hw.h            |  933 ++++++++++++
 drivers/video/via/iface.c         |   78 +
 drivers/video/via/iface.h         |   38 
 drivers/video/via/ioctl.c         |  112 +
 drivers/video/via/ioctl.h         |  210 ++
 drivers/video/via/lcd.c           | 1821 ++++++++++++++++++++++++
 drivers/video/via/lcd.h           |   94 +
 drivers/video/via/lcdtbl.h        |  591 +++++++
 drivers/video/via/share.h         | 1105 ++++++++++++++
 drivers/video/via/tbl1636.c       |   71 
 drivers/video/via/tbl1636.h       |   34 
 drivers/video/via/tblDPASetting.c |  109 +
 drivers/video/via/tblDPASetting.h |   47 
 drivers/video/via/via_i2c.c       |  177 ++
 drivers/video/via/via_i2c.h       |   46 
 drivers/video/via/via_utility.c   |  253 +++
 drivers/video/via/via_utility.h   |   35 
 drivers/video/via/viafbdev.c      | 2571 ++++++++++++++++++++++++++++++++++
 drivers/video/via/viafbdev.h      |  112 +
 drivers/video/via/viamode.c       | 1086 ++++++++++++++
 drivers/video/via/viamode.h       |  177 ++
 drivers/video/via/vt1636.c        |  306 ++++
 drivers/video/via/vt1636.h        |   44 
 37 files changed, 15600 insertions(+)

--- /dev/null
+++ b/Documentation/fb/viafb.modes
@@ -0,0 +1,870 @@
+#
+#
+#   These data are based on the CRTC parameters in
+#
+#       VIA Integration Graphics Chip
+#       (C) 2004 VIA Technologies Inc.
+#
+
+#
+#   640x480, 60 Hz, Non-Interlaced (25.175 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      640     480
+#   Scan Frequency      31.469 kHz  59.94 Hz
+#   Sync Width      3.813 us    0.064 ms
+#               12 chars    2 lines
+#   Front Porch     0.636 us    0.318  ms
+#               2 chars     10 lines
+#   Back Porch      1.907 us    1.048  ms
+#               6 chars     33 lines
+#   Active Time     25.422 us   15.253 ms
+#               80 chars    480 lines
+#   Blank Time      6.356 us    1.430 ms
+#               20 chars    45 lines
+#   Polarity        negative    negative
+#
+
+mode "640x480-60"
+# D: 25.175 MHz, H: 31.469 kHz, V: 59.94 Hz
+    geometry 640 480 640 480 32
+    timings 39722 48 16 33 10 96 2 endmode mode "480x640-60"
+# D: 24.823 MHz, H: 39.780 kHz, V: 60.00 Hz
+    geometry 480 640 480 640 32 timings 39722 72 24 19 1 48 3 endmode
+#
+#   640x480, 75 Hz, Non-Interlaced (31.50 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      640     480
+#   Scan Frequency      37.500 kHz  75.00 Hz
+#   Sync Width      2.032 us    0.080 ms
+#               8 chars     3 lines
+#   Front Porch     0.508 us    0.027 ms
+#               2 chars     1 lines
+#   Back Porch      3.810 us    0.427 ms
+#               15 chars    16 lines
+#   Active Time     20.317 us   12.800 ms
+#               80 chars    480 lines
+#   Blank Time      6.349 us    0.533 ms
+#               25 chars    20 lines
+#   Polarity        negative    negative
+#
+    mode "640x480-75"
+# D: 31.50 MHz, H: 37.500 kHz, V: 75.00 Hz
+    geometry 640 480 640 480 32 timings 31747 120 16 16 1 64 3 endmode
+#
+#   640x480, 85 Hz, Non-Interlaced (36.000 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      640     480
+#   Scan Frequency  43.269 kHz  85.00 Hz
+#   Sync Width      1.556 us    0.069 ms
+#               7 chars     3 lines
+#   Front Porch     1.556 us    0.023 ms
+#               7 chars     1 lines
+#   Back Porch      2.222 us    0.578 ms
+#               10 chars    25 lines
+#   Active Time     17.778 us   11.093 ms
+#               80 chars    480 lines
+#   Blank Time      5.333 us    0.670 ms
+#               24 chars    29 lines
+#   Polarity        negative    negative
+#
+    mode "640x480-85"
+# D: 36.000 MHz, H: 43.269 kHz, V: 85.00 Hz
+    geometry 640 480 640 480 32 timings 27777 80 56 25 1 56 3 endmode
+#
+#   640x480, 100 Hz, Non-Interlaced (43.163 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      640     480
+#   Scan Frequency      50.900 kHz  100.00 Hz
+#   Sync Width      1.483 us    0.058 ms
+#               8 chars     3 lines
+#   Front Porch     0.927 us    0.019 ms
+#               5 chars     1 lines
+#   Back Porch      2.409 us    0.475 ms
+#               13 chars    25 lines
+#   Active Time     14.827 us   9.430 ms
+#               80 chars    480 lines
+#   Blank Time      4.819 us    0.570 ms
+#               26 chars    29 lines
+#   Polarity        positive    positive
+#
+    mode "640x480-100"
+# D: 43.163 MHz, H: 50.900 kHz, V: 100.00 Hz
+    geometry 640 480 640 480 32 timings 23168 104 40 25 1 64 3 endmode
+#
+#   640x480, 120 Hz, Non-Interlaced (52.406 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      640     480
+#   Scan Frequency      61.800 kHz  120.00 Hz
+#   Sync Width      1.221 us    0.048 ms
+#               8 chars         3 lines
+#   Front Porch     0.763 us    0.016 ms
+#               5 chars     1 lines
+#   Back Porch      1.984 us    0.496 ms
+#               13 chars    31 lines
+#   Active Time     12.212 us   7.767 ms
+#               80 chars    480 lines
+#   Blank Time      3.969 us    0.566 ms
+#               26 chars    35 lines
+#   Polarity        positive    positive
+#
+    mode "640x480-120"
+# D: 52.406 MHz, H: 61.800 kHz, V: 120.00 Hz
+    geometry 640 480 640 480 32 timings 19081 104 40 31 1 64 3 endmode
+#
+#   720x480, 60 Hz, Non-Interlaced (26.880 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      720     480
+#   Scan Frequency      30.000 kHz  60.241 Hz
+#   Sync Width      2.679 us    0.099 ms
+#               9 chars     3 lines
+#   Front Porch     0.595 us    0.033 ms
+#               2 chars     1 lines
+#   Back Porch      3.274 us    0.462 ms
+#               11 chars    14 lines
+#   Active Time     26.786 us   16.000 ms
+#               90 chars    480 lines
+#   Blank Time      6.548 us    0.600 ms
+#               22 chars    18 lines
+#   Polarity        positive    positive
+#
+    mode "720x480-60"
+# D: 26.880 MHz, H: 30.000 kHz, V: 60.24 Hz
+    geometry 720 480 720 480 32 timings 37202 88 16 14 1 72 3 endmode
+#
+#   800x480, 60 Hz, Non-Interlaced (29.581 MHz dotclock)
+#
+#               Horizontal    Vertical
+#   Resolution      800         480
+#   Scan Frequency  29.892 kHz  60.00 Hz
+#   Sync Width      2.704 us    100.604 us
+#                   10 chars    3 lines
+#   Front Porch     0.541 us    33.535 us
+#                   2 chars     1 lines
+#   Back Porch      3.245 us    435.949 us
+#                   12 chars    13 lines
+#   Active Time     27.044 us   16.097 ms
+#                   100 chars   480 lines
+#   Blank Time      6.491 us    0.570 ms
+#                   24 chars    17 lines
+#   Polarity        positive    positive
+#
+    mode "800x480-60"
+# D: 29.500 MHz, H: 29.738 kHz, V: 60.00 Hz
+    geometry 800 480 800 480 32 timings 33805 96 24 10 3 72 7 endmode
+#
+#   720x576, 60 Hz, Non-Interlaced (32.668 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      720     576
+#   Scan Frequency      35.820 kHz  60.00 Hz
+#   Sync Width      2.204 us    0.083 ms
+#               9 chars     3 lines
+#   Front Porch     0.735 us    0.027 ms
+#               3 chars     1 lines
+#   Back Porch      2.939 us    0.459 ms
+#               12 chars    17 lines
+#   Active Time     22.040 us   16.080 ms
+#               90 chars    476 lines
+#   Blank Time      5.877 us    0.586 ms
+#               24 chars    21 lines
+#   Polarity        positive    positive
+#
+    mode "720x576-60"
+# D: 32.668 MHz, H: 35.820 kHz, V: 60.00 Hz
+    geometry 720 576 720 576 32 timings 30611 96 24 17 1 72 3 endmode
+#
+#   800x600, 60 Hz, Non-Interlaced (40.00 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      800     600
+#   Scan Frequency      37.879 kHz  60.32 Hz
+#   Sync Width      3.200 us    0.106 ms
+#               16 chars    4 lines
+#   Front Porch     1.000 us    0.026 ms
+#               5 chars     1 lines
+#   Back Porch      2.200 us    0.607 ms
+#               11 chars    23 lines
+#   Active Time     20.000 us   15.840 ms
+#               100 chars   600 lines
+#   Blank Time      6.400 us    0.739 ms
+#               32 chars    28 lines
+#   Polarity        positive    positive
+#
+    mode "800x600-60"
+# D: 40.00 MHz, H: 37.879 kHz, V: 60.32 Hz
+    geometry 800 600 800 600 32
+    timings 25000 88 40 23 1 128 4 hsync high vsync high endmode
+#
+#   800x600, 75 Hz, Non-Interlaced (49.50 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      800     600
+#   Scan Frequency      46.875 kHz  75.00 Hz
+#   Sync Width      1.616 us    0.064 ms
+#               10 chars    3 lines
+#   Front Porch     0.323 us    0.021 ms
+#               2 chars     1 lines
+#   Back Porch      3.232 us    0.448 ms
+#               20 chars    21 lines
+#   Active Time     16.162 us   12.800 ms
+#               100 chars   600 lines
+#   Blank Time      5.172 us    0.533 ms
+#               32 chars    25 lines
+#   Polarity        positive    positive
+#
+    mode "800x600-75"
+# D: 49.50 MHz, H: 46.875 kHz, V: 75.00 Hz
+    geometry 800 600 800 600 32
+    timings 20203 160 16 21 1 80 3 hsync high vsync high endmode
+#
+#   800x600, 85 Hz, Non-Interlaced (56.25 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      800     600
+#   Scan Frequency      53.674 kHz  85.061 Hz
+#   Sync Width      1.138 us    0.056 ms
+#               8 chars     3 lines
+#   Front Porch     0.569 us    0.019 ms
+#               4 chars     1 lines
+#   Back Porch      2.702 us    0.503 ms
+#               19 chars    27 lines
+#   Active Time     14.222 us   11.179 ms
+#               100 chars   600 lines
+#   Blank Time      4.409 us    0.578 ms
+#               31 chars    31 lines
+#   Polarity        positive    positive
+#
+    mode "800x600-85"
+# D: 56.25 MHz, H: 53.674 kHz, V: 85.061 Hz
+    geometry 800 600 800 600 32
+    timings 17777 152 32 27 1 64 3 hsync high vsync high endmode
+#
+#   800x600, 100 Hz, Non-Interlaced (67.50 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      800     600
+#   Scan Frequency      62.500 kHz  100.00 Hz
+#   Sync Width      0.948 us    0.064 ms
+#               8 chars     4 lines
+#   Front Porch     0.000 us    0.112 ms
+#               0 chars     7 lines
+#   Back Porch      3.200 us    0.224 ms
+#               27 chars    14 lines
+#   Active Time     11.852 us   9.600 ms
+#               100 chars   600 lines
+#   Blank Time      4.148 us    0.400 ms
+#               35 chars    25 lines
+#   Polarity        positive    positive
+#
+    mode "800x600-100"
+# D: 67.50 MHz, H: 62.500 kHz, V: 100.00 Hz
+    geometry 800 600 800 600 32
+    timings 14667 216 0 14 7 64 4 hsync high vsync high endmode
+#
+#   800x600, 120 Hz, Non-Interlaced (83.950 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      800     600
+#   Scan Frequency  77.160 kHz  120.00 Hz
+#   Sync Width      1.048 us    0.039 ms
+#               11 chars    3 lines
+#   Front Porch     0.667 us    0.013 ms
+#               7 chars     1 lines
+#   Back Porch      1.715 us    0.507 ms
+#               18 chars    39 lines
+#   Active Time     9.529 us    7.776 ms
+#               100 chars   600 lines
+#   Blank Time      3.431 us    0.557 ms
+#               36 chars    43 lines
+#   Polarity        positive    positive
+#
+    mode "800x600-120"
+# D: 83.950 MHz, H: 77.160 kHz, V: 120.00 Hz
+    geometry 800 600 800 600 32
+    timings 11912 144 56 39 1 88 3 hsync high vsync high endmode
+#
+#   848x480, 60 Hz, Non-Interlaced (31.490 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      848     480
+#   Scan Frequency  29.820 kHz  60.00 Hz
+#   Sync Width      2.795 us    0.099 ms
+#               11 chars    3 lines
+#   Front Porch     0.508 us    0.033 ms
+#               2 chars     1 lines
+#   Back Porch      3.303 us    0.429 ms
+#               13 chars    13 lines
+#   Active Time     26.929 us   16.097 ms
+#               106 chars   480 lines
+#   Blank Time      6.605 us    0.570 ms
+#               26 chars    17 lines
+#   Polarity        positive    positive
+#
+    mode "848x480-60"
+# D: 31.500 MHz, H: 29.830 kHz, V: 60.00 Hz
+    geometry 848 480 848 480 32
+    timings 31746 104 24 12 3 80 5 hsync high vsync high endmode
+#
+#   856x480, 60 Hz, Non-Interlaced (31.728 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      856     480
+#   Scan Frequency  29.820 kHz  60.00 Hz
+#   Sync Width      2.774 us    0.099 ms
+#               11 chars    3 lines
+#   Front Porch     0.504 us    0.033 ms
+#               2 chars     1 lines
+#   Back Porch      3.728 us    0.429 ms
+#               13 chars    13 lines
+#   Active Time     26.979 us   16.097 ms
+#               107 chars   480 lines
+#   Blank Time      6.556 us    0.570 ms
+#               26 chars    17 lines
+#   Polarity        positive    positive
+#
+    mode "856x480-60"
+# D: 31.728 MHz, H: 29.820 kHz, V: 60.00 Hz
+    geometry 856 480 856 480 32
+    timings 31518 104 16 13 1 88 3
+    hsync high vsync high endmode mode "960x600-60"
+# D: 45.250 MHz, H: 37.212 kHz, V: 60.00 Hz
+    geometry 960 600 960 600 32 timings 22099 128 32 15 3 96 6 endmode
+#
+#   1000x600, 60 Hz, Non-Interlaced (48.068 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1000     600
+#   Scan Frequency  37.320 kHz  60.00 Hz
+#   Sync Width      2.164 us    0.080 ms
+#               13 chars    3 lines
+#   Front Porch     0.832 us    0.027 ms
+#               5 chars     1 lines
+#   Back Porch      2.996 us    0.483 ms
+#               18 chars    18 lines
+#   Active Time     20.804 us   16.077 ms
+#               125 chars   600 lines
+#   Blank Time      5.991 us    0.589 ms
+#               36 chars    22 lines
+#   Polarity        negative    positive
+#
+    mode "1000x600-60"
+# D: 48.068 MHz, H: 37.320 kHz, V: 60.00 Hz
+    geometry 1000 600 1000 600 32
+    timings 20834 144 40 18 1 104 3 endmode mode "1024x576-60"
+# D: 46.996 MHz, H: 35.820 kHz, V: 60.00 Hz
+    geometry 1024 576 1024 576 32
+    timings 21278 144 40 17 1 104 3 endmode mode "1024x600-60"
+# D: 48.964 MHz, H: 37.320 kHz, V: 60.00 Hz
+    geometry 1024 600 1024 600 32
+    timings 20461 144 40 18 1 104 3 endmode mode "1088x612-60"
+# D: 52.952 MHz, H: 38.040 kHz, V: 60.00 Hz
+    geometry 1088 612 1088 612 32 timings 18877 152 48 16 3 104 5 endmode
+#
+#   1024x512, 60 Hz, Non-Interlaced (41.291 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1024    512
+#   Scan Frequency  31.860 kHz  60.00 Hz
+#   Sync Width      2.519 us    0.094 ms
+#               13 chars    3 lines
+#   Front Porch     0.775 us    0.031 ms
+#               4 chars     1 lines
+#   Back Porch      3.294 us    0.465 ms
+#               17 chars    15 lines
+#   Active Time     24.800 us   16.070 ms
+#               128 chars   512 lines
+#   Blank Time      6.587 us    0.596 ms
+#               34 chars    19 lines
+#   Polarity        positive    positive
+#
+    mode "1024x512-60"
+# D: 41.291 MHz, H: 31.860 kHz, V: 60.00 Hz
+    geometry 1024 512 1024 512 32
+    timings 24218 126 32 15 1 104 3 hsync high vsync high endmode
+#
+#   1024x600, 60 Hz, Non-Interlaced (48.875 MHz dotclock)
+#
+#                     Horizontal  Vertical
+#   Resolution          1024        768
+#   Scan Frequency      37.252 kHz  60.00 Hz
+#   Sync Width          2.128 us    80.532us
+#                       13 chars    3 lines
+#   Front Porch        0.818 us     26.844 us
+#                       5 chars     1 lines
+#   Back Porch          2.946 us    483.192 us
+#                       18 chars    18 lines
+#   Active Time         20.951 us   16.697 ms
+#                       128 chars   622 lines
+#   Blank Time          5.893 us    0.591 ms
+#                       36 chars    22 lines
+#   Polarity            negative    positive
+#
+#mode "1024x600-60"
+#     # D: 48.875 MHz, H: 37.252 kHz, V: 60.00 Hz
+#     geometry 1024 600 1024 600 32
+#    timings 20460  144 40 18 1 104  3
+# endmode
+#
+#   1024x768, 60 Hz, Non-Interlaced (65.00 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1024        768
+#   Scan Frequency      48.363 kHz  60.00 Hz
+#   Sync Width      2.092 us    0.124 ms
+#               17 chars    6 lines
+#   Front Porch     0.369 us    0.062 ms
+#               3 chars     3 lines
+#   Back Porch      2.462 us    0.601 ms
+#               20 chars    29 lines
+#   Active Time     15.754 us   15.880 ms
+#               128 chars   768 lines
+#   Blank Time      4.923 us    0.786 ms
+#               40 chars    38 lines
+#   Polarity        negative    negative
+#
+    mode "1024x768-60"
+# D: 65.00 MHz, H: 48.363 kHz, V: 60.00 Hz
+    geometry 1024 768 1024 768 32 timings 15385 160 24 29 3 136 6 endmode
+#
+#   1024x768, 75 Hz, Non-Interlaced (78.75 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1024        768
+#   Scan Frequency      60.023 kHz  75.03 Hz
+#   Sync Width      1.219 us    0.050 ms
+#               12 chars    3 lines
+#   Front Porch     0.203 us    0.017 ms
+#               2 chars     1 lines
+#   Back Porch      2.235 us    0.466 ms
+#               22 chars    28 lines
+#   Active Time     13.003 us   12.795 ms
+#               128 chars   768 lines
+#   Blank Time      3.657 us    0.533 ms
+#               36 chars    32 lines
+#   Polarity        positive    positive
+#
+    mode "1024x768-75"
+# D: 78.75 MHz, H: 60.023 kHz, V: 75.03 Hz
+    geometry 1024 768 1024 768 32
+    timings 12699 176 16 28 1 96 3 hsync high vsync high endmode
+#
+#   1024x768, 85 Hz, Non-Interlaced (94.50 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1024        768
+#   Scan Frequency  68.677 kHz  85.00 Hz
+#   Sync Width      1.016 us    0.044 ms
+#               12 chars    3 lines
+#   Front Porch     0.508 us    0.015 ms
+#               6 chars     1 lines
+#   Back Porch      2.201 us    0.524 ms
+#               26 chars    36 lines
+#   Active Time     10.836 us   11.183 ms
+#               128 chars   768 lines
+#   Blank Time      3.725 us    0.582 ms
+#               44 chars    40 lines
+#   Polarity        positive    positive
+#
+    mode "1024x768-85"
+# D: 94.50 MHz, H: 68.677 kHz, V: 85.00 Hz
+    geometry 1024 768 1024 768 32
+    timings 10582 208 48 36 1 96 3 hsync high vsync high endmode
+#
+#   1024x768, 100 Hz, Non-Interlaced (110.0 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1024        768
+#   Scan Frequency      79.023 kHz  99.78 Hz
+#   Sync Width      0.800 us    0.101 ms
+#               11 chars    8 lines
+#   Front Porch     0.000 us    0.000 ms
+#               0 chars     0 lines
+#   Back Porch      2.545 us    0.202 ms
+#               35 chars    16 lines
+#   Active Time     9.309 us    9.719 ms
+#               128 chars   768 lines
+#   Blank Time      3.345 us    0.304 ms
+#               46 chars    24 lines
+#   Polarity        negative    negative
+#
+    mode "1024x768-100"
+# D: 113.3 MHz, H: 79.023 kHz, V: 99.78 Hz
+    geometry 1024 768 1024 768 32
+    timings 8825 280 0 16 0 88 8 endmode mode "1152x720-60"
+# D: 66.750 MHz, H: 44.859 kHz, V: 60.00 Hz
+    geometry 1152 720 1152 720 32 timings 14981 168 56 19 3 112 6 endmode
+#
+#   1152x864, 75 Hz, Non-Interlaced (110.0 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1152        864
+#   Scan Frequency      75.137 kHz  74.99 Hz
+#   Sync Width      1.309 us    0.106 ms
+#               18 chars    8 lines
+#   Front Porch     0.245 us    0.599 ms
+#               3 chars     45 lines
+#   Back Porch      1.282 us    1.132 ms
+#               18 chars    85 lines
+#   Active Time     10.473 us   11.499 ms
+#               144 chars   864 lines
+#   Blank Time      2.836 us    1.837 ms
+#               39 chars    138 lines
+#   Polarity        positive    positive
+#
+    mode "1152x864-75"
+# D: 110.0 MHz, H: 75.137 kHz, V: 74.99 Hz
+    geometry 1152 864 1152 864 32
+    timings 9259 144 24 85 45 144 8
+    hsync high vsync high endmode mode "1200x720-60"
+# D: 70.184 MHz, H: 44.760 kHz, V: 60.00 Hz
+    geometry 1200 720 1200 720 32
+    timings 14253 184 28 22 1 128 3 endmode mode "1280x600-60"
+# D: 61.503 MHz, H: 37.320 kHz, V: 60.00 Hz
+    geometry 1280 600 1280 600 32
+    timings 16260 184 28 18 1 128 3 endmode mode "1280x720-50"
+# D: 60.466 MHz, H: 37.050 kHz, V: 50.00 Hz
+    geometry 1280 720 1280 720 32
+    timings 16538 176 48 17 1 128 3 endmode mode "1280x768-50"
+# D: 65.178 MHz, H: 39.550 kHz, V: 50.00 Hz
+    geometry 1280 768 1280 768 32 timings 15342 184 28 19 1 128 3 endmode
+#
+#   1280x768, 60 Hz, Non-Interlaced (80.136 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1280    768
+#   Scan Frequency  47.700 kHz  60.00 Hz
+#   Sync Width      1.697 us    0.063 ms
+#               17 chars    3 lines
+#   Front Porch     0.799 us    0.021 ms
+#               8 chars     1 lines
+#   Back Porch      2.496 us    0.483 ms
+#               25 chars    23 lines
+#   Active Time     15.973 us   16.101 ms
+#               160 chars   768 lines
+#   Blank Time      4.992 us    0.566 ms
+#               50 chars    27 lines
+#   Polarity        positive    positive
+#
+    mode "1280x768-60"
+# D: 80.13 MHz, H: 47.700 kHz, V: 60.00 Hz
+    geometry 1280 768 1280 768 32
+    timings 12480 200 48 23 1 126 3 hsync high vsync high endmode
+#
+#   1280x800, 60 Hz, Non-Interlaced (83.375 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1280    800
+#   Scan Frequency  49.628 kHz  60.00 Hz
+#   Sync Width      1.631 us    60.450 us
+#                   17 chars    3 lines
+#   Front Porch     0.768 us    20.15 us
+#                   8 chars     1 lines
+#   Back Porch      2.399 us    0.483 ms
+#                   25 chars    24 lines
+#   Active Time     15.352 us   16.120 ms
+#                   160 chars   800 lines
+#   Blank Time      4.798 us    0.564 ms
+#                   50 chars    28 lines
+#   Polarity        negtive    positive
+#
+    mode "1280x800-60"
+# D: 83.500 MHz, H: 49.702 kHz, V: 60.00 Hz
+    geometry 1280 800 1280 800 32 timings 11994 200 72 22 3 128 6 endmode
+#
+#   1280x960, 60 Hz, Non-Interlaced (108.00 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1280    960
+#   Scan Frequency  60.000 kHz  60.00 Hz
+#   Sync Width      1.037 us    0.050 ms
+#               14 chars    3 lines
+#   Front Porch     0.889 us    0.017 ms
+#               12 chars    1 lines
+#   Back Porch      2.889 us    0.600 ms
+#               39 chars    36 lines
+#   Active Time     11.852 us   16.000 ms
+#               160 chars   960 lines
+#   Blank Time      4.815 us    0.667 ms
+#               65 chars    40 lines
+#   Polarity        positive    positive
+#
+    mode "1280x960-60"
+# D: 108.00 MHz, H: 60.000 kHz, V: 60.00 Hz
+    geometry 1280 960 1280 960 32
+    timings 9259 312 96 36 1 112 3 hsync high vsync high endmode
+#
+#   1280x1024, 60 Hz, Non-Interlaced (108.00 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1280        1024
+#   Scan Frequency      63.981 kHz  60.02 Hz
+#   Sync Width      1.037 us    0.047 ms
+#               14 chars    3 lines
+#   Front Porch     0.444 us    0.015 ms
+#               6 chars     1 lines
+#   Back Porch      2.297 us    0.594 ms
+#               31 chars    38 lines
+#   Active Time     11.852 us   16.005 ms
+#               160 chars   1024 lines
+#   Blank Time      3.778 us    0.656 ms
+#               51 chars    42 lines
+#   Polarity        positive    positive
+#
+    mode "1280x1024-60"
+# D: 108.00 MHz, H: 63.981 kHz, V: 60.02 Hz
+    geometry 1280 1024 1280 1024 32
+    timings 9260 248 48 38 1 112 3 hsync high vsync high endmode
+#
+#   1280x1024, 75 Hz, Non-Interlaced (135.00 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1280        1024
+#   Scan Frequency      79.976 kHz  75.02 Hz
+#   Sync Width      1.067 us    0.038 ms
+#               18 chars    3 lines
+#   Front Porch     0.119 us    0.012 ms
+#               2 chars     1 lines
+#   Back Porch      1.837 us    0.475 ms
+#               31 chars    38 lines
+#   Active Time     9.481 us    12.804 ms
+#               160 chars   1024 lines
+#   Blank Time      3.022 us    0.525 ms
+#               51 chars    42 lines
+#   Polarity        positive    positive
+#
+    mode "1280x1024-75"
+# D: 135.00 MHz, H: 79.976 kHz, V: 75.02 Hz
+    geometry 1280 1024 1280 1024 32
+    timings 7408 248 16 38 1 144 3 hsync high vsync high endmode
+#
+#   1280x1024, 85 Hz, Non-Interlaced (157.50 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1280        1024
+#   Scan Frequency  91.146 kHz  85.02 Hz
+#   Sync Width      1.016 us    0.033 ms
+#               20 chars    3 lines
+#   Front Porch     0.406 us    0.011 ms
+#               8 chars     1 lines
+#   Back Porch      1.422 us    0.483 ms
+#               28 chars    44 lines
+#   Active Time     8.127 us    11.235 ms
+#               160 chars   1024 lines
+#   Blank Time      2.844 us    0.527 ms
+#               56 chars    48 lines
+#   Polarity        positive    positive
+#
+    mode "1280x1024-85"
+# D: 157.50 MHz, H: 91.146 kHz, V: 85.02 Hz
+    geometry 1280 1024 1280 1024 32
+    timings 6349 224 64 44 1 160 3
+    hsync high vsync high endmode mode "1440x900-60"
+# D: 106.500 MHz, H: 55.935 kHz, V: 60.00 Hz
+    geometry 1440 900 1440 900 32
+    timings 9390 232 80 25 3 152 6
+    hsync high vsync high endmode mode "1440x900-75"
+# D: 136.750 MHz, H: 70.635 kHz, V: 75.00 Hz
+    geometry 1440 900 1440 900 32
+    timings 7315 248 96 33 3 152 6 hsync high vsync high endmode
+#
+#   1440x1050, 60 Hz, Non-Interlaced (125.10 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1440        1050
+#   Scan Frequency      65.220 kHz  60.00 Hz
+#   Sync Width      1.204 us    0.046 ms
+#               19 chars    3 lines
+#   Front Porch     0.760 us    0.015 ms
+#               12 chars    1 lines
+#   Back Porch      1.964 us    0.495 ms
+#               31 chars    33 lines
+#   Active Time     11.405 us   16.099 ms
+#               180 chars   1050 lines
+#   Blank Time      3.928 us    0.567 ms
+#               62 chars    37 lines
+#   Polarity        positive    positive
+#
+    mode "1440x1050-60"
+# D: 125.10 MHz, H: 65.220 kHz, V: 60.00 Hz
+    geometry 1440 1050 1440 1050 32
+    timings 7993 248 96 33 1 152 3
+    hsync high vsync high endmode mode "1600x900-60"
+# D: 118.250 MHz, H: 55.990 kHz, V: 60.00 Hz
+    geometry 1600 900 1600 900 32
+    timings 8415 256 88 26 3 168 5 endmode mode "1600x1024-60"
+# D: 136.358 MHz, H: 63.600 kHz, V: 60.00 Hz
+    geometry 1600 1024 1600 1024 32 timings 7315 272 104 32 1 168 3 endmode
+#
+#   1600x1200, 60 Hz, Non-Interlaced (156.00 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1600        1200
+#   Scan Frequency      76.200 kHz  60.00 Hz
+#   Sync Width      1.026 us    0.105 ms
+#               20 chars    8 lines
+#   Front Porch     0.205 us    0.131 ms
+#               4 chars     10 lines
+#   Back Porch      1.636 us    0.682 ms
+#               32 chars    52 lines
+#   Active Time     10.256 us   15.748 ms
+#               200 chars   1200 lines
+#   Blank Time      2.872 us    0.866 ms
+#               56 chars    66 lines
+#   Polarity        negative    negative
+#
+    mode "1600x1200-60"
+# D: 156.00 MHz, H: 76.200 kHz, V: 60.00 Hz
+    geometry 1600 1200 1600 1200 32 timings 6172 256 32 52 10 160 8 endmode
+#
+#   1600x1200, 75 Hz, Non-Interlaced (202.50 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1600        1200
+#   Scan Frequency  93.750 kHz  75.00 Hz
+#   Sync Width      0.948 us    0.032 ms
+#               24 chars    3 lines
+#   Front Porch     0.316 us    0.011 ms
+#               8 chars     1 lines
+#   Back Porch      1.501 us    0.491 ms
+#               38 chars    46 lines
+#   Active Time     7.901 us    12.800 ms
+#               200 chars   1200 lines
+#   Blank Time      2.765 us    0.533 ms
+#               70 chars    50 lines
+#   Polarity    positive    positive
+#
+    mode "1600x1200-75"
+# D: 202.50 MHz, H: 93.750 kHz, V: 75.00 Hz
+    geometry 1600 1200 1600 1200 32
+    timings 4938 304 64 46 1 192 3
+    hsync high vsync high endmode mode "1680x1050-60"
+# D: 146.250 MHz, H: 65.290 kHz, V: 59.954 Hz
+    geometry 1680 1050 1680 1050 32
+    timings 6814 280 104 30 3 176 6
+    hsync high vsync high endmode mode "1680x1050-75"
+# D: 187.000 MHz, H: 82.306 kHz, V: 74.892 Hz
+    geometry 1680 1050 1680 1050 32
+    timings 5348 296 120 40 3 176 6
+    hsync high vsync high endmode mode "1792x1344-60"
+# D: 202.975 MHz, H: 83.460 kHz, V: 60.00 Hz
+    geometry 1792 1344 1792 1344 32
+    timings 4902 320 128 43 1 192 3
+    hsync high vsync high endmode mode "1856x1392-60"
+# D: 218.571 MHz, H: 86.460 kHz, V: 60.00 Hz
+    geometry 1856 1392 1856 1392 32
+    timings 4577 336 136 45 1 200 3
+    hsync high vsync high endmode mode "1920x1200-60"
+# D: 193.250 MHz, H: 74.556 kHz, V: 60.00 Hz
+    geometry 1920 1200 1920 1200 32
+    timings 5173 336 136 36 3 200 6
+    hsync high vsync high endmode mode "1920x1440-60"
+# D: 234.000 MHz, H:90.000 kHz, V: 60.00 Hz
+    geometry 1920 1440 1920 1440 32
+    timings 4274 344 128 56 1 208 3
+    hsync high vsync high endmode mode "1920x1440-75"
+# D: 297.000 MHz, H:112.500 kHz, V: 75.00 Hz
+    geometry 1920 1440 1920 1440 32
+    timings 3367 352 144 56 1 224 3
+    hsync high vsync high endmode mode "2048x1536-60"
+# D: 267.250 MHz, H: 95.446 kHz, V: 60.00 Hz
+    geometry 2048 1536 2048 1536 32
+    timings 3742 376 152 49 3 224 4 hsync high vsync high endmode
+#
+#   1280x720, 60 Hz, Non-Interlaced (74.481 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1280        720
+#   Scan Frequency      44.760 kHz  60.00 Hz
+#   Sync Width      1.826 us    67.024 ms
+#               17 chars    3 lines
+#   Front Porch     0.752 us    22.341 ms
+#               7 chars     1 lines
+#   Back Porch      2.578 us    491.510 ms
+#               24 chars    22 lines
+#   Active Time     17.186 us   16.086 ms
+#               160 chars   720 lines
+#   Blank Time      5.156 us    0.581 ms
+#               48 chars    26 lines
+#   Polarity        negative    negative
+#
+    mode "1280x720-60"
+# D: 74.481 MHz, H: 44.760 kHz, V: 60.00 Hz
+    geometry 1280 720 1280 720 32 timings 13426 192 64 22 1 136 3 endmode
+#
+#   1920x1080, 60 Hz, Non-Interlaced (172.798 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1920        1080
+#   Scan Frequency      67.080 kHz  60.00 Hz
+#   Sync Width      1.204 us    44.723 ms
+#               26 chars    3 lines
+#   Front Porch     0.694 us    14.908 ms
+#               15 chars     1 lines
+#   Back Porch      1.898 us    506.857 ms
+#               41 chars    34 lines
+#   Active Time     11.111 us   16.100 ms
+#               240 chars   1080 lines
+#   Blank Time      3.796 us    0.566 ms
+#               82 chars    38 lines
+#   Polarity        negative    negative
+#
+    mode "1920x1080-60"
+# D: 74.481 MHz, H: 67.080 kHz, V: 60.00 Hz
+    geometry 1920 1080 1920 1080 32 timings 5787 328 120 34 1 208 3 endmode
+#
+#   1400x1050, 60 Hz, Non-Interlaced (122.61 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1400        1050
+#   Scan Frequency      65.218 kHz  59.99 Hz
+#   Sync Width      1.037 us    0.047 ms
+#               19 chars    3 lines
+#   Front Porch     0.444 us    0.015 ms
+#               11 chars     1 lines
+#   Back Porch      1.185 us    0.188 ms
+#               30 chars    33 lines
+#   Active Time     12.963 us   16.411 ms
+#               175 chars   1050 lines
+#   Blank Time      2.667 us    0.250 ms
+#               60 chars    37 lines
+#   Polarity        negative    positive
+#
+    mode "1400x1050-60"
+# D: 122.750 MHz, H: 65.317 kHz, V: 59.99 Hz
+    geometry 1400 1050 1408 1050 32
+    timings 8214 232 88 32 3 144 4 endmode mode "1400x1050-75"
+# D: 156.000 MHz, H: 82.278 kHz, V: 74.867 Hz
+    geometry 1400 1050 1408 1050 32 timings 6410 248 104 42 3 144 4 endmode
+#
+#   1366x768, 60 Hz, Non-Interlaced (85.86 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1366        768
+#   Scan Frequency      47.700 kHz  60.00 Hz
+#   Sync Width      1.677 us    0.063 ms
+#               18 chars    3 lines
+#   Front Porch     0.839 us    0.021 ms
+#               9 chars     1 lines
+#   Back Porch      2.516 us    0.482 ms
+#               27 chars    23 lines
+#   Active Time     15.933 us   16.101 ms
+#               171 chars   768 lines
+#   Blank Time      5.031 us    0.566 ms
+#               54 chars    27 lines
+#   Polarity        negative    positive
+#
+    mode "1360x768-60"
+# D: 84.750 MHz, H: 47.720 kHz, V: 60.00 Hz
+    geometry 1360 768 1360 768 32
+    timings 11799 208 72 22 3 136 5 endmode mode "1366x768-60"
+# D: 85.86 MHz, H: 47.700 kHz, V: 60.00 Hz
+    geometry 1366 768 1366 768 32
+    timings 11647 216 72 23 1 144 3 endmode mode "1366x768-50"
+# D: 69,924 MHz, H: 39.550 kHz, V: 50.00 Hz
+    geometry 1366 768 1366 768 32 timings 14301 200 56 19 1 144 3 endmode
--- /dev/null
+++ b/Documentation/fb/viafb.txt
@@ -0,0 +1,214 @@
+
+        VIA Integration Graphic Chip Console Framebuffer Driver
+
+[Platform]
+-----------------------
+    The console framebuffer driver is for graphics chips of
+    VIA UniChrome Family(CLE266, PM800 / CN400 / CN300,
+                        P4M800CE / P4M800Pro / CN700 / VN800,
+                        CX700 / VX700, K8M890, P4M890,
+                        CN896 / P4M900, VX800)
+
+[Driver features]
+------------------------
+    Device: CRT, LCD, DVI
+
+    Support viafb_mode:
+        CRT:
+            640x480(60, 75, 85, 100, 120 Hz), 720x480(60 Hz),
+            720x576(60 Hz), 800x600(60, 75, 85, 100, 120 Hz),
+            848x480(60 Hz), 856x480(60 Hz), 1024x512(60 Hz),
+            1024x768(60, 75, 85, 100 Hz), 1152x864(75 Hz),
+            1280x768(60 Hz), 1280x960(60 Hz), 1280x1024(60, 75, 85 Hz),
+            1440x1050(60 Hz), 1600x1200(60, 75 Hz), 1280x720(60 Hz),
+            1920x1080(60 Hz), 1400x1050(60 Hz), 800x480(60 Hz)
+
+    color depth: 8 bpp, 16 bpp, 32 bpp supports.
+
+    Support 2D hardware accelerator.
+
+[Using the viafb module]
+-- -- --------------------
+    Start viafb with default settings:
+        #modprobe viafb
+
+    Start viafb with with user options:
+        #modprobe viafb viafb_mode=800x600 viafb_bpp=16 viafb_refresh=60
+                  viafb_active_dev=CRT+DVI viafb_dvi_port=DVP1
+                  viafb_mode1=1024x768 viafb_bpp=16 viafb_refresh1=60
+                  viafb_SAMM_ON=1
+
+    viafb_mode:
+        640x480 (default)
+        720x480
+        800x600
+        1024x768
+        ......
+
+    viafb_bpp:
+        8, 16, 32 (default:32)
+
+    viafb_refresh:
+        60, 75, 85, 100, 120 (default:60)
+
+    viafb_lcd_dsp_method:
+        0 : expansion (default)
+        1 : centering
+
+    viafb_lcd_mode:
+        0 : LCD panel with LSB data format input (default)
+        1 : LCD panel with MSB data format input
+
+    viafb_lcd_panel_id:
+        0 : Resolution: 640x480, Channel: single, Dithering: Enable
+        1 : Resolution: 800x600, Channel: single, Dithering: Enable
+        2 : Resolution: 1024x768, Channel: single, Dithering: Enable (default)
+        3 : Resolution: 1280x768, Channel: single, Dithering: Enable
+        4 : Resolution: 1280x1024, Channel: dual, Dithering: Enable
+        5 : Resolution: 1400x1050, Channel: dual, Dithering: Enable
+        6 : Resolution: 1600x1200, Channel: dual, Dithering: Enable
+
+        8 : Resolution: 800x480, Channel: single, Dithering: Enable
+        9 : Resolution: 1024x768, Channel: dual, Dithering: Enable
+        10: Resolution: 1024x768, Channel: single, Dithering: Disable
+        11: Resolution: 1024x768, Channel: dual, Dithering: Disable
+        12: Resolution: 1280x768, Channel: single, Dithering: Disable
+        13: Resolution: 1280x1024, Channel: dual, Dithering: Disable
+        14: Resolution: 1400x1050, Channel: dual, Dithering: Disable
+        15: Resolution: 1600x1200, Channel: dual, Dithering: Disable
+        16: Resolution: 1366x768, Channel: single, Dithering: Disable
+        17: Resolution: 1024x600, Channel: single, Dithering: Enable
+        18: Resolution: 1280x768, Channel: dual, Dithering: Enable
+        19: Resolution: 1280x800, Channel: single, Dithering: Enable
+
+    viafb_accel:
+        0 : No 2D Hardware Acceleration
+        1 : 2D Hardware Acceleration (default)
+
+    viafb_SAMM_ON:
+        0 : viafb_SAMM_ON disable (default)
+        1 : viafb_SAMM_ON enable
+
+    viafb_mode1: (secondary display device)
+        640x480 (default)
+        720x480
+        800x600
+        1024x768
+        ... ...
+
+    viafb_bpp1: (secondary display device)
+        8, 16, 32 (default:32)
+
+    viafb_refresh1: (secondary display device)
+        60, 75, 85, 100, 120 (default:60)
+
+    viafb_active_dev:
+        This option is used to specify active devices.(CRT, DVI, CRT+LCD...)
+        DVI stands for DVI or HDMI, E.g., If you want to enable HDMI,
+        set viafb_active_dev=DVI. In SAMM case, the previous of
+        viafb_active_dev is primary device, and the following is
+        secondary device.
+
+        For example:
+        To enable one device, such as DVI only, we can use:
+            modprobe viafb viafb_active_dev=DVI
+        To enable two devices, such as CRT+DVI:
+            modprobe viafb viafb_active_dev=CRT+DVI;
+
+        For DuoView case, we can use:
+            modprobe viafb viafb_active_dev=CRT+DVI
+            OR
+            modprobe viafb viafb_active_dev=DVI+CRT...
+
+        For SAMM case:
+        If CRT is primary and DVI is secondary, we should use:
+            modprobe viafb viafb_active_dev=CRT+DVI viafb_SAMM_ON=1...
+        If DVI is primary and CRT is secondary, we should use:
+            modprobe viafb viafb_active_dev=DVI+CRT viafb_SAMM_ON=1...
+
+    viafb_display_hardware_layout:
+        This option is used to specify display hardware layout for CX700 chip.
+        1 : LCD only
+        2 : DVI only
+        3 : LCD+DVI (default)
+        4 : LCD1+LCD2 (internal + internal)
+        16: LCD1+ExternalLCD2 (internal + external)
+
+    viafb_second_size:
+        This option is used to set second device memory size(MB) in SAMM case.
+        The minimal size is 16.
+
+    viafb_platform_epia_dvi:
+        This option is used to enable DVI on EPIA - M
+        0 : No DVI on EPIA - M (default)
+        1 : DVI on EPIA - M
+
+    viafb_bus_width:
+        When using 24 - Bit Bus Width Digital Interface,
+        this option should be set.
+        12: 12-Bit LVDS or 12-Bit TMDS (default)
+        24: 24-Bit LVDS or 24-Bit TMDS
+
+    viafb_device_lcd_dualedge:
+        When using Dual Edge Panel, this option should be set.
+        0 : No Dual Edge Panel (default)
+        1 : Dual Edge Panel
+
+    viafb_video_dev:
+        This option is used to specify video output devices(CRT, DVI, LCD) for
+        duoview case.
+        For example:
+        To output video on DVI, we should use:
+            modprobe viafb viafb_video_dev=DVI...
+
+    viafb_lcd_port:
+        This option is used to specify LCD output port,
+        available values are "DVP0" "DVP1" "DFP_HIGHLOW" "DFP_HIGH" "DFP_LOW".
+        for external LCD + external DVI on CX700(External LCD is on DVP0),
+        we should use:
+            modprobe viafb viafb_lcd_port=DVP0...
+
+Notes:
+    1. CRT may not display properly for DuoView CRT & DVI display at
+       the "640x480" PAL mode with DVI overscan enabled.
+    2. SAMM stands for single adapter multi monitors. It is different from
+       multi-head since SAMM support multi monitor at driver layers, thus fbcon
+       layer doesn't even know about it; SAMM's second screen doesn't have a
+       device node file, thus a user mode application can't access it directly.
+       When SAMM is enabled, viafb_mode and viafb_mode1, viafb_bpp and
+       viafb_bpp1, viafb_refresh and viafb_refresh1 can be different.
+    3. When console is depending on viafbinfo1, dynamically change resolution
+       and bpp, need to call VIAFB specified ioctl interface VIAFB_SET_DEVICE
+       instead of calling common ioctl function FBIOPUT_VSCREENINFO since
+       viafb doesn't support multi-head well, or it will cause screen crush.
+    4. VX800 2D accelerator hasn't been supported in this driver yet. When
+       using driver on VX800, the driver will disable the acceleration
+       function as default.
+
+
+[Configure viafb with "fbset" tool]
+-----------------------------------
+    "fbset" is an inbox utility of Linux.
+    1. Inquire current viafb information, type,
+           # fbset -i
+
+    2. Set various resolutions and viafb_refresh rates,
+           # fbset <resolution-vertical_sync>
+
+       example,
+           # fbset "1024x768-75"
+       or
+           # fbset -g 1024 768 1024 768 32
+       Check the file "/etc/fb.modes" to find display modes available.
+
+    3. Set the color depth,
+           # fbset -depth <value>
+
+       example,
+           # fbset -depth 16
+
+[Bootup with viafb]:
+--------------------
+    Add the following line to your grub.conf:
+    append = "video=viafb:viafb_mode=1024x768,viafb_bpp=32,viafb_refresh=85"
+
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -1498,6 +1498,24 @@ config FB_SIS_315
 	  (315/H/PRO, 55x, 650, 651, 740, 330, 661, 741, 760, 761) as well
 	  as XGI V3XT, V5, V8 and Z7.
 
+config FB_VIA
+       tristate "VIA UniChrome (Pro) and Chrome9 display support"
+       depends on FB && PCI
+       select FB_CFB_FILLRECT
+       select FB_CFB_COPYAREA
+       select FB_CFB_IMAGEBLIT
+       select FB_SOFT_CURSOR
+       select I2C_ALGOBIT
+       select I2C
+       help
+	  This is the frame buffer device driver for Graphics chips of VIA
+	  UniChrome (Pro) Family (CLE266,PM800/CN400,P4M800CE/P4M800Pro/
+	  CN700/VN800,CX700/VX700,P4M890) and Chrome9 Family (K8M890,CN896
+ 	  /P4M900,VX800)
+	  Say Y if you have a VIA UniChrome graphics board.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called viafb.
 config FB_NEOMAGIC
 	tristate "NeoMagic display support"
 	depends on FB && PCI
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -44,6 +44,7 @@ obj-$(CONFIG_FB_ATY)		  += aty/ macmodes
 obj-$(CONFIG_FB_ATY128)		  += aty/ macmodes.o
 obj-$(CONFIG_FB_RADEON)		  += aty/
 obj-$(CONFIG_FB_SIS)		  += sis/
+obj-$(CONFIG_FB_VIA)		  += via/
 obj-$(CONFIG_FB_KYRO)             += kyro/
 obj-$(CONFIG_FB_SAVAGE)		  += savage/
 obj-$(CONFIG_FB_GEODE)		  += geode/
--- /dev/null
+++ b/drivers/video/via/accel.c
@@ -0,0 +1,279 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#include "global.h"
+
+void viafb_init_accel(void)
+{
+	viaparinfo->fbmem_free -= CURSOR_SIZE;
+	viaparinfo->cursor_start = viaparinfo->fbmem_free;
+	viaparinfo->fbmem_used += CURSOR_SIZE;
+
+	/* Reverse 8*1024 memory space for cursor image */
+	viaparinfo->fbmem_free -= (CURSOR_SIZE + VQ_SIZE);
+	viaparinfo->VQ_start = viaparinfo->fbmem_free;
+	viaparinfo->VQ_end = viaparinfo->VQ_start + VQ_SIZE - 1;
+	viaparinfo->fbmem_used += (CURSOR_SIZE + VQ_SIZE); }
+
+void viafb_init_2d_engine(void)
+{
+	u32 dwVQStartAddr, dwVQEndAddr;
+	u32 dwVQLen, dwVQStartL, dwVQEndL, dwVQStartEndH;
+
+	/* init 2D engine regs to reset 2D engine */
+	writel(0x0, viaparinfo->io_virt + VIA_REG_GEMODE);
+	writel(0x0, viaparinfo->io_virt + VIA_REG_SRCPOS);
+	writel(0x0, viaparinfo->io_virt + VIA_REG_DSTPOS);
+	writel(0x0, viaparinfo->io_virt + VIA_REG_DIMENSION);
+	writel(0x0, viaparinfo->io_virt + VIA_REG_PATADDR);
+	writel(0x0, viaparinfo->io_virt + VIA_REG_FGCOLOR);
+	writel(0x0, viaparinfo->io_virt + VIA_REG_BGCOLOR);
+	writel(0x0, viaparinfo->io_virt + VIA_REG_CLIPTL);
+	writel(0x0, viaparinfo->io_virt + VIA_REG_CLIPBR);
+	writel(0x0, viaparinfo->io_virt + VIA_REG_OFFSET);
+	writel(0x0, viaparinfo->io_virt + VIA_REG_KEYCONTROL);
+	writel(0x0, viaparinfo->io_virt + VIA_REG_SRCBASE);
+	writel(0x0, viaparinfo->io_virt + VIA_REG_DSTBASE);
+	writel(0x0, viaparinfo->io_virt + VIA_REG_PITCH);
+	writel(0x0, viaparinfo->io_virt + VIA_REG_MONOPAT1);
+
+	/* Init AGP and VQ regs */
+	switch (viaparinfo->chip_info->gfx_chip_name) {
+	case UNICHROME_K8M890:
+	case UNICHROME_P4M900:
+		writel(0x00100000, viaparinfo->io_virt + VIA_REG_CR_TRANSET);
+		writel(0x680A0000, viaparinfo->io_virt + VIA_REG_CR_TRANSPACE);
+		writel(0x02000000, viaparinfo->io_virt + VIA_REG_CR_TRANSPACE);
+		break;
+
+	default:
+		writel(0x00100000, viaparinfo->io_virt + VIA_REG_TRANSET);
+		writel(0x00000000, viaparinfo->io_virt + VIA_REG_TRANSPACE);
+		writel(0x00333004, viaparinfo->io_virt + VIA_REG_TRANSPACE);
+		writel(0x60000000, viaparinfo->io_virt + VIA_REG_TRANSPACE);
+		writel(0x61000000, viaparinfo->io_virt + VIA_REG_TRANSPACE);
+		writel(0x62000000, viaparinfo->io_virt + VIA_REG_TRANSPACE);
+		writel(0x63000000, viaparinfo->io_virt + VIA_REG_TRANSPACE);
+		writel(0x64000000, viaparinfo->io_virt + VIA_REG_TRANSPACE);
+		writel(0x7D000000, viaparinfo->io_virt + VIA_REG_TRANSPACE);
+
+		writel(0xFE020000, viaparinfo->io_virt + VIA_REG_TRANSET);
+		writel(0x00000000, viaparinfo->io_virt + VIA_REG_TRANSPACE);
+		break;
+	}
+	if (viaparinfo->VQ_start != 0) {
+		/* Enable VQ */
+		dwVQStartAddr = viaparinfo->VQ_start;
+		dwVQEndAddr = viaparinfo->VQ_end;
+
+		dwVQStartL = 0x50000000 | (dwVQStartAddr & 0xFFFFFF);
+		dwVQEndL = 0x51000000 | (dwVQEndAddr & 0xFFFFFF);
+		dwVQStartEndH = 0x52000000 |
+			((dwVQStartAddr & 0xFF000000) >> 24) |
+			((dwVQEndAddr & 0xFF000000) >> 16);
+		dwVQLen = 0x53000000 | (VQ_SIZE >> 3);
+		switch (viaparinfo->chip_info->gfx_chip_name) {
+		case UNICHROME_K8M890:
+		case UNICHROME_P4M900:
+			dwVQStartL |= 0x20000000;
+			dwVQEndL |= 0x20000000;
+			dwVQStartEndH |= 0x20000000;
+			dwVQLen |= 0x20000000;
+			break;
+		default:
+			break;
+		}
+
+		switch (viaparinfo->chip_info->gfx_chip_name) {
+		case UNICHROME_K8M890:
+		case UNICHROME_P4M900:
+			writel(0x00100000,
+				viaparinfo->io_virt + VIA_REG_CR_TRANSET);
+			writel(dwVQStartEndH,
+				viaparinfo->io_virt + VIA_REG_CR_TRANSPACE);
+			writel(dwVQStartL,
+				viaparinfo->io_virt + VIA_REG_CR_TRANSPACE);
+			writel(dwVQEndL,
+				viaparinfo->io_virt + VIA_REG_CR_TRANSPACE);
+			writel(dwVQLen,
+				viaparinfo->io_virt + VIA_REG_CR_TRANSPACE);
+			writel(0x74301001,
+				viaparinfo->io_virt + VIA_REG_CR_TRANSPACE);
+			writel(0x00000000,
+				viaparinfo->io_virt + VIA_REG_CR_TRANSPACE);
+			break;
+		default:
+			writel(0x00FE0000,
+				viaparinfo->io_virt + VIA_REG_TRANSET);
+			writel(0x080003FE,
+				viaparinfo->io_virt + VIA_REG_TRANSPACE);
+			writel(0x0A00027C,
+				viaparinfo->io_virt + VIA_REG_TRANSPACE);
+			writel(0x0B000260,
+				viaparinfo->io_virt + VIA_REG_TRANSPACE);
+			writel(0x0C000274,
+				viaparinfo->io_virt + VIA_REG_TRANSPACE);
+			writel(0x0D000264,
+				viaparinfo->io_virt + VIA_REG_TRANSPACE);
+			writel(0x0E000000,
+				viaparinfo->io_virt + VIA_REG_TRANSPACE);
+			writel(0x0F000020,
+				viaparinfo->io_virt + VIA_REG_TRANSPACE);
+			writel(0x1000027E,
+				viaparinfo->io_virt + VIA_REG_TRANSPACE);
+			writel(0x110002FE,
+				viaparinfo->io_virt + VIA_REG_TRANSPACE);
+			writel(0x200F0060,
+				viaparinfo->io_virt + VIA_REG_TRANSPACE);
+
+			writel(0x00000006,
+				viaparinfo->io_virt + VIA_REG_TRANSPACE);
+			writel(0x40008C0F,
+				viaparinfo->io_virt + VIA_REG_TRANSPACE);
+			writel(0x44000000,
+				viaparinfo->io_virt + VIA_REG_TRANSPACE);
+			writel(0x45080C04,
+				viaparinfo->io_virt + VIA_REG_TRANSPACE);
+			writel(0x46800408,
+				viaparinfo->io_virt + VIA_REG_TRANSPACE);
+
+			writel(dwVQStartEndH,
+				viaparinfo->io_virt + VIA_REG_TRANSPACE);
+			writel(dwVQStartL,
+				viaparinfo->io_virt + VIA_REG_TRANSPACE);
+			writel(dwVQEndL,
+				viaparinfo->io_virt + VIA_REG_TRANSPACE);
+			writel(dwVQLen,
+				viaparinfo->io_virt + VIA_REG_TRANSPACE);
+			break;
+		}
+	} else {
+		/* Disable VQ */
+		switch (viaparinfo->chip_info->gfx_chip_name) {
+		case UNICHROME_K8M890:
+		case UNICHROME_P4M900:
+			writel(0x00100000,
+				viaparinfo->io_virt + VIA_REG_CR_TRANSET);
+			writel(0x74301000,
+				viaparinfo->io_virt + VIA_REG_CR_TRANSPACE);
+			break;
+		default:
+			writel(0x00FE0000,
+				viaparinfo->io_virt + VIA_REG_TRANSET);
+			writel(0x00000004,
+				viaparinfo->io_virt + VIA_REG_TRANSPACE);
+			writel(0x40008C0F,
+				viaparinfo->io_virt + VIA_REG_TRANSPACE);
+			writel(0x44000000,
+				viaparinfo->io_virt + VIA_REG_TRANSPACE);
+			writel(0x45080C04,
+				viaparinfo->io_virt + VIA_REG_TRANSPACE);
+			writel(0x46800408,
+				viaparinfo->io_virt + VIA_REG_TRANSPACE);
+			break;
+		}
+	}
+
+	viafb_set_2d_color_depth(viaparinfo->bpp);
+
+	writel(0x0, viaparinfo->io_virt + VIA_REG_SRCBASE);
+	writel(0x0, viaparinfo->io_virt + VIA_REG_DSTBASE);
+
+	writel(VIA_PITCH_ENABLE |
+		   (((viaparinfo->hres *
+		      viaparinfo->bpp >> 3) >> 3) | (((viaparinfo->hres *
+						   viaparinfo->
+						   bpp >> 3) >> 3) << 16)),
+					viaparinfo->io_virt + VIA_REG_PITCH);
+}
+
+void viafb_set_2d_color_depth(int bpp)
+{
+	u32 dwGEMode;
+
+	dwGEMode = readl(viaparinfo->io_virt + 0x04) & 0xFFFFFCFF;
+
+	switch (bpp) {
+	case 16:
+		dwGEMode |= VIA_GEM_16bpp;
+		break;
+	case 32:
+		dwGEMode |= VIA_GEM_32bpp;
+		break;
+	default:
+		dwGEMode |= VIA_GEM_8bpp;
+		break;
+	}
+
+	/* Set BPP and Pitch */
+	writel(dwGEMode, viaparinfo->io_virt + VIA_REG_GEMODE);
+}
+
+void viafb_hw_cursor_init(void)
+{
+	/* Set Cursor Image Base Address */
+	writel(viaparinfo->cursor_start,
+		viaparinfo->io_virt + VIA_REG_CURSOR_MODE);
+	writel(0x0, viaparinfo->io_virt + VIA_REG_CURSOR_POS);
+	writel(0x0, viaparinfo->io_virt + VIA_REG_CURSOR_ORG);
+	writel(0x0, viaparinfo->io_virt + VIA_REG_CURSOR_BG);
+	writel(0x0, viaparinfo->io_virt + VIA_REG_CURSOR_FG);
+}
+
+void viafb_show_hw_cursor(struct fb_info *info, int Status)
+{
+	u32 temp;
+	u32 iga_path = ((struct viafb_par *)(info->par))->iga_path;
+
+	temp = readl(viaparinfo->io_virt + VIA_REG_CURSOR_MODE);
+	switch (Status) {
+	case HW_Cursor_ON:
+		temp |= 0x1;
+		break;
+	case HW_Cursor_OFF:
+		temp &= 0xFFFFFFFE;
+		break;
+	}
+	switch (iga_path) {
+	case IGA2:
+		temp |= 0x80000000;
+		break;
+	case IGA1:
+	default:
+		temp &= 0x7FFFFFFF;
+	}
+	writel(temp, viaparinfo->io_virt + VIA_REG_CURSOR_MODE);
+}
+
+int viafb_wait_engine_idle(void)
+{
+	int loop = 0;
+
+	while (!(readl(viaparinfo->io_virt + VIA_REG_STATUS) &
+			VIA_VR_QUEUE_BUSY) && (loop++ < MAXLOOP))
+		cpu_relax();
+
+	while ((readl(viaparinfo->io_virt + VIA_REG_STATUS) &
+		    (VIA_CMD_RGTR_BUSY | VIA_2D_ENG_BUSY | VIA_3D_ENG_BUSY)) &&
+		    (loop++ < MAXLOOP))
+		cpu_relax();
+
+	return loop >= MAXLOOP;
+}
--- /dev/null
+++ b/drivers/video/via/accel.h
@@ -0,0 +1,169 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __ACCEL_H__
+#define __ACCEL_H__
+
+#define FB_ACCEL_VIA_UNICHROME  50
+
+/* MMIO Base Address Definition */
+#define MMIO_VGABASE                0x8000
+#define MMIO_CR_READ                (MMIO_VGABASE + 0x3D4)
+#define MMIO_CR_WRITE               (MMIO_VGABASE + 0x3D5)
+#define MMIO_SR_READ                (MMIO_VGABASE + 0x3C4)
+#define MMIO_SR_WRITE               (MMIO_VGABASE + 0x3C5)
+
+/* HW Cursor Status Define */
+#define HW_Cursor_ON    0
+#define HW_Cursor_OFF   1
+
+#define CURSOR_SIZE     (8 * 1024)
+#define VQ_SIZE         (256 * 1024)
+
+#define VIA_MMIO_BLTBASE        0x200000
+#define VIA_MMIO_BLTSIZE        0x200000
+
+/* Defines for 2D registers */
+#define VIA_REG_GECMD           0x000
+#define VIA_REG_GEMODE          0x004
+#define VIA_REG_SRCPOS          0x008
+#define VIA_REG_DSTPOS          0x00C
+/* width and height */
+#define VIA_REG_DIMENSION       0x010
+#define VIA_REG_PATADDR         0x014
+#define VIA_REG_FGCOLOR         0x018
+#define VIA_REG_BGCOLOR         0x01C
+/* top and left of clipping */
+#define VIA_REG_CLIPTL          0x020
+/* bottom and right of clipping */
+#define VIA_REG_CLIPBR          0x024
+#define VIA_REG_OFFSET          0x028
+/* color key control */
+#define VIA_REG_KEYCONTROL      0x02C
+#define VIA_REG_SRCBASE         0x030
+#define VIA_REG_DSTBASE         0x034
+/* pitch of src and dst */
+#define VIA_REG_PITCH           0x038
+#define VIA_REG_MONOPAT0        0x03C
+#define VIA_REG_MONOPAT1        0x040
+/* from 0x100 to 0x1ff */
+#define VIA_REG_COLORPAT        0x100
+
+/* VIA_REG_PITCH(0x38): Pitch Setting */
+#define VIA_PITCH_ENABLE        0x80000000
+
+/* defines for VIA HW cursor registers */
+#define VIA_REG_CURSOR_MODE     0x2D0
+#define VIA_REG_CURSOR_POS      0x2D4
+#define VIA_REG_CURSOR_ORG      0x2D8
+#define VIA_REG_CURSOR_BG       0x2DC
+#define VIA_REG_CURSOR_FG       0x2E0
+
+/* VIA_REG_GEMODE(0x04): GE mode */
+#define VIA_GEM_8bpp            0x00000000
+#define VIA_GEM_16bpp           0x00000100
+#define VIA_GEM_32bpp           0x00000300
+
+/* VIA_REG_GECMD(0x00): 2D Engine Command  */
+#define VIA_GEC_NOOP            0x00000000
+#define VIA_GEC_BLT             0x00000001
+#define VIA_GEC_LINE            0x00000005
+
+/* Rotate Command */
+#define VIA_GEC_ROT             0x00000008
+
+#define VIA_GEC_SRC_XY          0x00000000
+#define VIA_GEC_SRC_LINEAR      0x00000010
+#define VIA_GEC_DST_XY          0x00000000
+#define VIA_GEC_DST_LINRAT      0x00000020
+
+#define VIA_GEC_SRC_FB          0x00000000
+#define VIA_GEC_SRC_SYS         0x00000040
+#define VIA_GEC_DST_FB          0x00000000
+#define VIA_GEC_DST_SYS         0x00000080
+
+/* source is mono */
+#define VIA_GEC_SRC_MONO        0x00000100
+/* pattern is mono */
+#define VIA_GEC_PAT_MONO        0x00000200
+/* mono src is opaque */
+#define VIA_GEC_MSRC_OPAQUE     0x00000000
+/* mono src is transparent */
+#define VIA_GEC_MSRC_TRANS      0x00000400
+/* pattern is in frame buffer */
+#define VIA_GEC_PAT_FB          0x00000000
+/* pattern is from reg setting */
+#define VIA_GEC_PAT_REG         0x00000800
+
+#define VIA_GEC_CLIP_DISABLE    0x00000000
+#define VIA_GEC_CLIP_ENABLE     0x00001000
+
+#define VIA_GEC_FIXCOLOR_PAT    0x00002000
+
+#define VIA_GEC_INCX            0x00000000
+#define VIA_GEC_DECY            0x00004000
+#define VIA_GEC_INCY            0x00000000
+#define VIA_GEC_DECX            0x00008000
+/* mono pattern is opaque */
+#define VIA_GEC_MPAT_OPAQUE     0x00000000
+/* mono pattern is transparent */
+#define VIA_GEC_MPAT_TRANS      0x00010000
+
+#define VIA_GEC_MONO_UNPACK     0x00000000
+#define VIA_GEC_MONO_PACK       0x00020000
+#define VIA_GEC_MONO_DWORD      0x00000000
+#define VIA_GEC_MONO_WORD       0x00040000
+#define VIA_GEC_MONO_BYTE       0x00080000
+
+#define VIA_GEC_LASTPIXEL_ON    0x00000000
+#define VIA_GEC_LASTPIXEL_OFF   0x00100000
+#define VIA_GEC_X_MAJOR         0x00000000
+#define VIA_GEC_Y_MAJOR         0x00200000
+#define VIA_GEC_QUICK_START     0x00800000
+
+/* defines for VIA 3D registers */
+#define VIA_REG_STATUS          0x400
+#define VIA_REG_CR_TRANSET      0x41C
+#define VIA_REG_CR_TRANSPACE	0x420
+#define VIA_REG_TRANSET         0x43C
+#define VIA_REG_TRANSPACE       0x440
+
+/* VIA_REG_STATUS(0x400): Engine Status */
+
+/* Command Regulator is busy */
+#define VIA_CMD_RGTR_BUSY       0x00000080
+/* 2D Engine is busy */
+#define VIA_2D_ENG_BUSY         0x00000002
+/* 3D Engine is busy */
+#define VIA_3D_ENG_BUSY         0x00000001
+/* Virtual Queue is busy */
+#define VIA_VR_QUEUE_BUSY       0x00020000
+
+#define MAXLOOP                 0xFFFFFF
+
+void viafb_init_accel(void);
+void viafb_init_2d_engine(void);
+void set_2d_color_depth(int);
+void viafb_hw_cursor_init(void);
+void viafb_show_hw_cursor(struct fb_info *info, int Status); int
+viafb_wait_engine_idle(void); void viafb_set_2d_color_depth(int bpp);
+
+#endif /* __ACCEL_H__ */
--- /dev/null
+++ b/drivers/video/via/chip.h
@@ -0,0 +1,190 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#ifndef __CHIP_H__
+#define __CHIP_H__
+
+#include "global.h"
+
+/***************************************/
+/* Definition Graphic Chip Information */
+/***************************************/
+
+#define     PCI_VIA_VENDOR_ID       0x1106
+
+/* Define VIA Graphic Chip Name */
+#define     UNICHROME_CLE266        1
+#define     UNICHROME_CLE266_DID    0x3122
+#define     CLE266_REVISION_AX      0x0A
+#define     CLE266_REVISION_CX      0x0C
+
+#define     UNICHROME_K400          2
+#define     UNICHROME_K400_DID      0x7205
+
+#define     UNICHROME_K800          3
+#define     UNICHROME_K800_DID      0x3108
+
+#define     UNICHROME_PM800         4
+#define     UNICHROME_PM800_DID     0x3118
+
+#define     UNICHROME_CN700         5
+#define     UNICHROME_CN700_DID     0x3344
+
+#define     UNICHROME_CX700         6
+#define     UNICHROME_CX700_DID     0x3157
+#define     CX700_REVISION_700      0x0
+#define     CX700_REVISION_700M     0x1
+#define     CX700_REVISION_700M2    0x2
+
+#define     UNICHROME_CN750         7
+#define     UNICHROME_CN750_DID     0x3225
+
+#define     UNICHROME_K8M890        8
+#define     UNICHROME_K8M890_DID    0x3230
+
+#define     UNICHROME_P4M890        9
+#define     UNICHROME_P4M890_DID    0x3343
+
+#define     UNICHROME_P4M900        10
+#define     UNICHROME_P4M900_DID    0x3371
+
+#define     UNICHROME_VX800         11
+#define     UNICHROME_VX800_DID     0x1122
+
+/**************************************************/
+/* Definition TMDS Trasmitter Information         */
+/**************************************************/
+
+/* Definition TMDS Trasmitter Index */
+#define     NON_TMDS_TRANSMITTER    0x00
+#define     VT1632_TMDS             0x01
+#define     INTEGRATED_TMDS         0x42
+
+/* Definition TMDS Trasmitter I2C Slave Address */
+#define     VT1632_TMDS_I2C_ADDR    0x10
+
+/**************************************************/
+/* Definition LVDS Trasmitter Information         */
+/**************************************************/
+
+/* Definition LVDS Trasmitter Index */
+#define     NON_LVDS_TRANSMITTER    0x00
+#define     VT1631_LVDS             0x01
+#define     VT1636_LVDS             0x0E
+#define     INTEGRATED_LVDS         0x41
+
+/* Definition Digital Transmitter Mode */
+#define     TX_DATA_12_BITS         0x01
+#define     TX_DATA_24_BITS         0x02
+#define     TX_DATA_DDR_MODE        0x04
+#define     TX_DATA_SDR_MODE        0x08
+
+/* Definition LVDS Trasmitter I2C Slave Address */
+#define     VT1631_LVDS_I2C_ADDR    0x70
+#define     VT3271_LVDS_I2C_ADDR    0x80
+#define     VT1636_LVDS_I2C_ADDR    0x80
+
+struct tmds_chip_information {
+	int tmds_chip_name;
+	int tmds_chip_slave_addr;
+	int dvi_panel_id;
+	int data_mode;
+	int output_interface;
+	int i2c_port;
+	int device_type;
+};
+
+struct lvds_chip_information {
+	int lvds_chip_name;
+	int lvds_chip_slave_addr;
+	int data_mode;
+	int output_interface;
+	int i2c_port;
+};
+
+struct chip_information {
+	int gfx_chip_name;
+	int gfx_chip_revision;
+	int chip_on_slot;
+	struct tmds_chip_information tmds_chip_info;
+	struct lvds_chip_information lvds_chip_info;
+	struct lvds_chip_information lvds_chip_info2;
+};
+
+struct crt_setting_information {
+	int iga_path;
+	int h_active;
+	int v_active;
+	int bpp;
+	int refresh_rate;
+};
+
+struct tmds_setting_information {
+	int iga_path;
+	int h_active;
+	int v_active;
+	int bpp;
+	int refresh_rate;
+	int get_dvi_size_method;
+	int max_pixel_clock;
+	int dvi_panel_size;
+	int dvi_panel_hres;
+	int dvi_panel_vres;
+	int native_size;
+};
+
+struct lvds_setting_information {
+	int iga_path;
+	int h_active;
+	int v_active;
+	int bpp;
+	int refresh_rate;
+	int get_lcd_size_method;
+	int lcd_panel_id;
+	int lcd_panel_size;
+	int lcd_panel_hres;
+	int lcd_panel_vres;
+	int display_method;
+	int device_lcd_dualedge;
+	int LCDDithering;
+	int lcd_mode;
+	u32 vclk;		/*panel mode clock value */
+};
+
+struct GFX_DPA_SETTING {
+	int ClkRangeIndex;
+	u8 DVP0;		/* CR96[3:0] */
+	u8 DVP0DataDri_S1;	/* SR2A[5]   */
+	u8 DVP0DataDri_S;	/* SR1B[1]   */
+	u8 DVP0ClockDri_S1;	/* SR2A[4]   */
+	u8 DVP0ClockDri_S;	/* SR1E[2]   */
+	u8 DVP1;		/* CR9B[3:0] */
+	u8 DVP1Driving;		/* SR65[3:0], Data and Clock driving */
+	u8 DFPHigh;		/* CR97[3:0] */
+	u8 DFPLow;		/* CR99[3:0] */
+
+};
+
+struct VT1636_DPA_SETTING {
+	int PanelSizeID;
+	u8 CLK_SEL_ST1;
+	u8 CLK_SEL_ST2;
+};
+#endif /* __CHIP_H__ */
--- /dev/null
+++ b/drivers/video/via/debug.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#ifndef __DEBUG_H__
+#define __DEBUG_H__
+
+#ifndef VIAFB_DEBUG
+#define VIAFB_DEBUG 0
+#endif
+
+#if VIAFB_DEBUG
+#define DEBUG_MSG(f, a...)   printk(f, ## a)
+#else
+#define DEBUG_MSG(f, a...)
+#endif
+
+#define VIAFB_WARN 0
+#if VIAFB_WARN
+#define WARN_MSG(f, a...)   printk(f, ## a)
+#else
+#define WARN_MSG(f, a...)
+#endif
+
+#endif /* __DEBUG_H__ */
--- /dev/null
+++ b/drivers/video/via/dvi.c
@@ -0,0 +1,682 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#include "global.h"
+
+static void tmds_register_write(int index, u8 data);
+static int tmds_register_read(int index);
+static int tmds_register_read_bytes(int index, u8 *buff, int buff_len);
+static int check_reduce_blanking_mode(int mode_index,
+	int refresh_rate);
+static int dvi_get_panel_size_from_DDCv1(void);
+static int dvi_get_panel_size_from_DDCv2(void);
+static unsigned char dvi_get_panel_info(void);
+static int viafb_dvi_query_EDID(void);
+
+static int check_tmds_chip(int device_id_subaddr, int device_id)
+{
+	if (tmds_register_read(device_id_subaddr) == device_id)
+		return OK;
+	else
+		return FAIL;
+}
+
+void viafb_init_dvi_size(void)
+{
+	DEBUG_MSG(KERN_INFO "viafb_init_dvi_size()\n");
+	DEBUG_MSG(KERN_INFO
+		"viaparinfo->tmds_setting_info->get_dvi_size_method %d\n",
+		  viaparinfo->tmds_setting_info->get_dvi_size_method);
+
+	switch (viaparinfo->tmds_setting_info->get_dvi_size_method) {
+	case GET_DVI_SIZE_BY_SYSTEM_BIOS:
+		break;
+	case GET_DVI_SZIE_BY_HW_STRAPPING:
+		break;
+	case GET_DVI_SIZE_BY_VGA_BIOS:
+	default:
+		dvi_get_panel_info();
+		break;
+	}
+	return;
+}
+
+int viafb_tmds_trasmitter_identify(void)
+{
+	unsigned char sr2a = 0, sr1e = 0, sr3e = 0;
+
+	/* Turn on ouputting pad */
+	switch (viaparinfo->chip_info->gfx_chip_name) {
+	case UNICHROME_K8M890:
+	    /*=* DFP Low Pad on *=*/
+		sr2a = viafb_read_reg(VIASR, SR2A);
+		viafb_write_reg_mask(SR2A, VIASR, 0x03, BIT0 + BIT1);
+		break;
+
+	case UNICHROME_P4M900:
+	case UNICHROME_P4M890:
+		/* DFP Low Pad on */
+		sr2a = viafb_read_reg(VIASR, SR2A);
+		viafb_write_reg_mask(SR2A, VIASR, 0x03, BIT0 + BIT1);
+		/* DVP0 Pad on */
+		sr1e = viafb_read_reg(VIASR, SR1E);
+		viafb_write_reg_mask(SR1E, VIASR, 0xC0, BIT6 + BIT7);
+		break;
+
+	default:
+	    /* DVP0/DVP1 Pad on */
+		sr1e = viafb_read_reg(VIASR, SR1E);
+		viafb_write_reg_mask(SR1E, VIASR, 0xF0, BIT4 +
+			BIT5 + BIT6 + BIT7);
+	    /* SR3E[1]Multi-function selection:
+	    0 = Emulate I2C and DDC bus by GPIO2/3/4. */
+		sr3e = viafb_read_reg(VIASR, SR3E);
+		viafb_write_reg_mask(SR3E, VIASR, 0x0, BIT5);
+		break;
+	}
+
+	/* Check for VT1632: */
+	viaparinfo->chip_info->tmds_chip_info.tmds_chip_name = VT1632_TMDS;
+	viaparinfo->chip_info->
+		tmds_chip_info.tmds_chip_slave_addr = VT1632_TMDS_I2C_ADDR;
+	viaparinfo->chip_info->tmds_chip_info.i2c_port = I2CPORTINDEX;
+	if (check_tmds_chip(VT1632_DEVICE_ID_REG, VT1632_DEVICE_ID) != FAIL) {
+		/*
+		 * Currently only support 12bits,dual edge,add 24bits mode later
+		 */
+		tmds_register_write(0x08, 0x3b);
+
+		DEBUG_MSG(KERN_INFO "\n VT1632 TMDS ! \n");
+		DEBUG_MSG(KERN_INFO "\n %2d",
+			  viaparinfo->chip_info->tmds_chip_info.tmds_chip_name);
+		DEBUG_MSG(KERN_INFO "\n %2d",
+			  viaparinfo->chip_info->tmds_chip_info.i2c_port);
+		return OK;
+	} else {
+		viaparinfo->chip_info->tmds_chip_info.i2c_port = GPIOPORTINDEX;
+		if (check_tmds_chip(VT1632_DEVICE_ID_REG, VT1632_DEVICE_ID)
+		    != FAIL) {
+			tmds_register_write(0x08, 0x3b);
+			DEBUG_MSG(KERN_INFO "\n VT1632 TMDS ! \n");
+			DEBUG_MSG(KERN_INFO "\n %2d",
+				  viaparinfo->chip_info->
+				  tmds_chip_info.tmds_chip_name);
+			DEBUG_MSG(KERN_INFO "\n %2d",
+				  viaparinfo->chip_info->
+				  tmds_chip_info.i2c_port);
+			return OK;
+		}
+	}
+
+	viaparinfo->chip_info->tmds_chip_info.tmds_chip_name = INTEGRATED_TMDS;
+
+	if ((viaparinfo->chip_info->gfx_chip_name == UNICHROME_CX700) &&
+	    ((viafb_display_hardware_layout == HW_LAYOUT_DVI_ONLY) ||
+	     (viafb_display_hardware_layout == HW_LAYOUT_LCD_DVI))) {
+		DEBUG_MSG(KERN_INFO "\n Integrated TMDS ! \n");
+		return OK;
+	}
+
+	switch (viaparinfo->chip_info->gfx_chip_name) {
+	case UNICHROME_K8M890:
+		viafb_write_reg(SR2A, VIASR, sr2a);
+		break;
+
+	case UNICHROME_P4M900:
+	case UNICHROME_P4M890:
+		viafb_write_reg(SR2A, VIASR, sr2a);
+		viafb_write_reg(SR1E, VIASR, sr1e);
+		break;
+
+	default:
+		viafb_write_reg(SR1E, VIASR, sr1e);
+		viafb_write_reg(SR3E, VIASR, sr3e);
+		break;
+	}
+
+	viaparinfo->chip_info->
+		tmds_chip_info.tmds_chip_name = NON_TMDS_TRANSMITTER;
+	viaparinfo->chip_info->tmds_chip_info.
+		tmds_chip_slave_addr = VT1632_TMDS_I2C_ADDR;
+	return FAIL;
+}
+
+static void tmds_register_write(int index, u8 data)
+{
+	viaparinfo->i2c_stuff.i2c_port =
+		viaparinfo->chip_info->tmds_chip_info.i2c_port;
+
+	viafb_i2c_writebyte(viaparinfo->chip_info->tmds_chip_info.
+		tmds_chip_slave_addr, index,
+		     data);
+}
+
+static int tmds_register_read(int index)
+{
+	u8 data;
+
+	viaparinfo->i2c_stuff.i2c_port =
+		viaparinfo->chip_info->tmds_chip_info.i2c_port;
+	viafb_i2c_readbyte((u8) viaparinfo->chip_info->
+	    tmds_chip_info.tmds_chip_slave_addr,
+			(u8) index, &data);
+	return data;
+}
+
+static int tmds_register_read_bytes(int index, u8 *buff, int buff_len)
+{
+	viaparinfo->i2c_stuff.i2c_port =
+		viaparinfo->chip_info->tmds_chip_info.i2c_port;
+	viafb_i2c_readbytes((u8) viaparinfo->chip_info->tmds_chip_info.
+			 tmds_chip_slave_addr, (u8) index, buff, buff_len);
+	return 0;
+}
+
+static int check_reduce_blanking_mode(int mode_index,
+	int refresh_rate)
+{
+	if (refresh_rate != 60)
+		return false;
+
+	switch (mode_index) {
+		/* Following modes have reduce blanking mode. */
+	case VIA_RES_1360X768:
+	case VIA_RES_1400X1050:
+	case VIA_RES_1440X900:
+	case VIA_RES_1600X900:
+	case VIA_RES_1680X1050:
+	case VIA_RES_1920X1080:
+	case VIA_RES_1920X1200:
+		break;
+
+	default:
+		DEBUG_MSG(KERN_INFO
+			  "This dvi mode %d have no reduce blanking mode!\n",
+			  mode_index);
+		return false;
+	}
+
+	return true;
+}
+
+/* DVI Set Mode */
+void viafb_dvi_set_mode(int video_index, int mode_bpp, int set_iga)
+{
+	struct VideoModeTable *videoMode = NULL;
+	struct crt_mode_table *pDviTiming;
+	unsigned long desirePixelClock, maxPixelClock;
+	int status = 0;
+	videoMode = viafb_get_modetbl_pointer(video_index);
+	pDviTiming = videoMode->crtc;
+	desirePixelClock = pDviTiming->clk / 1000000;
+	maxPixelClock = (unsigned long)viaparinfo->
+		tmds_setting_info->max_pixel_clock;
+
+	DEBUG_MSG(KERN_INFO "\nDVI_set_mode!!\n");
+
+	if ((maxPixelClock != 0) && (desirePixelClock > maxPixelClock)) {
+		/*Check if reduce-blanking mode is exist */
+		status =
+		    check_reduce_blanking_mode(video_index,
+					       pDviTiming->refresh_rate);
+		if (status) {
+			video_index += 100;	/*Use reduce-blanking mode */
+			videoMode = viafb_get_modetbl_pointer(video_index);
+			pDviTiming = videoMode->crtc;
+			DEBUG_MSG(KERN_INFO
+				  "DVI use reduce blanking mode %d!!\n",
+				  video_index);
+		}
+	}
+	viafb_fill_crtc_timing(pDviTiming, video_index, mode_bpp / 8, set_iga);
+	viafb_set_output_path(DEVICE_DVI, set_iga,
+			viaparinfo->chip_info->tmds_chip_info.output_interface);
+}
+
+/* Sense DVI Connector */
+int viafb_dvi_sense(void)
+{
+	u8 RegSR1E = 0, RegSR3E = 0, RegCR6B = 0, RegCR91 = 0,
+		RegCR93 = 0, RegCR9B = 0, data;
+	int ret = false;
+
+	DEBUG_MSG(KERN_INFO "viafb_dvi_sense!!\n");
+
+	if (viaparinfo->chip_info->gfx_chip_name == UNICHROME_CLE266) {
+		/* DI1 Pad on */
+		RegSR1E = viafb_read_reg(VIASR, SR1E);
+		viafb_write_reg(SR1E, VIASR, RegSR1E | 0x30);
+
+		/* CR6B[0]VCK Input Selection: 1 = External clock. */
+		RegCR6B = viafb_read_reg(VIACR, CR6B);
+		viafb_write_reg(CR6B, VIACR, RegCR6B | 0x08);
+
+		/* CR91[4] VDD On [3] Data On [2] VEE On [1] Back Light Off
+		   [0] Software Control Power Sequence */
+		RegCR91 = viafb_read_reg(VIACR, CR91);
+		viafb_write_reg(CR91, VIACR, 0x1D);
+
+		/* CR93[7] DI1 Data Source Selection: 1 = DSP2.
+		   CR93[5] DI1 Clock Source: 1 = internal.
+		   CR93[4] DI1 Clock Polarity.
+		   CR93[3:1] DI1 Clock Adjust. CR93[0] DI1 enable */
+		RegCR93 = viafb_read_reg(VIACR, CR93);
+		viafb_write_reg(CR93, VIACR, 0x01);
+	} else {
+		/* DVP0/DVP1 Pad on */
+		RegSR1E = viafb_read_reg(VIASR, SR1E);
+		viafb_write_reg(SR1E, VIASR, RegSR1E | 0xF0);
+
+		/* SR3E[1]Multi-function selection:
+		   0 = Emulate I2C and DDC bus by GPIO2/3/4. */
+		RegSR3E = viafb_read_reg(VIASR, SR3E);
+		viafb_write_reg(SR3E, VIASR, RegSR3E & (~0x20));
+
+		/* CR91[4] VDD On [3] Data On [2] VEE On [1] Back Light Off
+		   [0] Software Control Power Sequence */
+		RegCR91 = viafb_read_reg(VIACR, CR91);
+		viafb_write_reg(CR91, VIACR, 0x1D);
+
+		/*CR9B[4] DVP1 Data Source Selection: 1 = From secondary
+		display.CR9B[2:0] DVP1 Clock Adjust */
+		RegCR9B = viafb_read_reg(VIACR, CR9B);
+		viafb_write_reg(CR9B, VIACR, 0x01);
+	}
+
+	data = (u8) tmds_register_read(0x09);
+	if (data & 0x04)
+		ret = true;
+
+	if (ret == false) {
+		if (viafb_dvi_query_EDID())
+			ret = true;
+	}
+
+	/* Restore status */
+	viafb_write_reg(SR1E, VIASR, RegSR1E);
+	viafb_write_reg(CR91, VIACR, RegCR91);
+	if (viaparinfo->chip_info->gfx_chip_name == UNICHROME_CLE266) {
+		viafb_write_reg(CR6B, VIACR, RegCR6B);
+		viafb_write_reg(CR93, VIACR, RegCR93);
+	} else {
+		viafb_write_reg(SR3E, VIASR, RegSR3E);
+		viafb_write_reg(CR9B, VIACR, RegCR9B);
+	}
+
+	return ret;
+}
+
+/* Query Flat Panel's EDID Table Version Through DVI Connector */
+static int viafb_dvi_query_EDID(void)
+{
+	u8 data0, data1;
+	int restore;
+
+	DEBUG_MSG(KERN_INFO "viafb_dvi_query_EDID!!\n");
+
+	restore = viaparinfo->chip_info->tmds_chip_info.tmds_chip_slave_addr;
+	viaparinfo->chip_info->tmds_chip_info.tmds_chip_slave_addr = 0xA0;
+
+	data0 = (u8) tmds_register_read(0x00);
+	data1 = (u8) tmds_register_read(0x01);
+	if ((data0 == 0) && (data1 == 0xFF)) {
+		viaparinfo->chip_info->
+			tmds_chip_info.tmds_chip_slave_addr = restore;
+		return EDID_VERSION_1;	/* Found EDID1 Table */
+	}
+
+	data0 = (u8) tmds_register_read(0x00);
+	viaparinfo->chip_info->tmds_chip_info.tmds_chip_slave_addr = restore;
+	if (data0 == 0x20)
+		return EDID_VERSION_2;	/* Found EDID2 Table */
+	else
+		return false;
+}
+
+/*
+ *
+ * int dvi_get_panel_size_from_DDCv1(void)
+ *
+ *     - Get Panel Size Using EDID1 Table
+ *
+ * Return Type:    int
+ *
+ */
+static int dvi_get_panel_size_from_DDCv1(void)
+{
+	int i, max_h = 0, max_v = 0, tmp, restore;
+	unsigned char rData;
+	unsigned char EDID_DATA[18];
+
+	DEBUG_MSG(KERN_INFO "\n dvi_get_panel_size_from_DDCv1 \n");
+
+	restore = viaparinfo->chip_info->tmds_chip_info.tmds_chip_slave_addr;
+	viaparinfo->chip_info->tmds_chip_info.tmds_chip_slave_addr = 0xA0;
+
+	rData = tmds_register_read(0x23);
+	if (rData & 0x3C)
+		max_h = 640;
+	if (rData & 0xC0)
+		max_h = 720;
+	if (rData & 0x03)
+		max_h = 800;
+
+	rData = tmds_register_read(0x24);
+	if (rData & 0xC0)
+		max_h = 800;
+	if (rData & 0x1E)
+		max_h = 1024;
+	if (rData & 0x01)
+		max_h = 1280;
+
+	for (i = 0x25; i < 0x6D; i++) {
+		switch (i) {
+		case 0x26:
+		case 0x28:
+		case 0x2A:
+		case 0x2C:
+		case 0x2E:
+		case 0x30:
+		case 0x32:
+		case 0x34:
+			rData = tmds_register_read(i);
+			if (rData == 1)
+				break;
+			/* data = (data + 31) * 8 */
+			tmp = (rData + 31) << 3;
+			if (tmp > max_h)
+				max_h = tmp;
+			break;
+
+		case 0x36:
+		case 0x48:
+		case 0x5A:
+		case 0x6C:
+			tmds_register_read_bytes(i, EDID_DATA, 10);
+			if (!(EDID_DATA[0] || EDID_DATA[1])) {
+				/* The first two byte must be zero. */
+				if (EDID_DATA[3] == 0xFD) {
+					/* To get max pixel clock. */
+					viaparinfo->tmds_setting_info->
+					max_pixel_clock = EDID_DATA[9] * 10;
+				}
+			}
+			break;
+
+		default:
+			break;
+		}
+	}
+
+	switch (max_h) {
+	case 640:
+		viaparinfo->tmds_setting_info->dvi_panel_size =
+			VIA_RES_640X480;
+		break;
+	case 800:
+		viaparinfo->tmds_setting_info->dvi_panel_size =
+			VIA_RES_800X600;
+		break;
+	case 1024:
+		viaparinfo->tmds_setting_info->dvi_panel_size =
+			VIA_RES_1024X768;
+		break;
+	case 1280:
+		viaparinfo->tmds_setting_info->dvi_panel_size =
+			VIA_RES_1280X1024;
+		break;
+	case 1400:
+		viaparinfo->tmds_setting_info->dvi_panel_size =
+			VIA_RES_1400X1050;
+		break;
+	case 1440:
+		viaparinfo->tmds_setting_info->dvi_panel_size =
+			VIA_RES_1440X1050;
+		break;
+	case 1600:
+		viaparinfo->tmds_setting_info->dvi_panel_size =
+			VIA_RES_1600X1200;
+		break;
+	case 1920:
+		if (max_v == 1200) {
+			viaparinfo->tmds_setting_info->dvi_panel_size =
+				VIA_RES_1920X1200;
+		} else {
+			viaparinfo->tmds_setting_info->dvi_panel_size =
+				VIA_RES_1920X1080;
+		}
+
+		break;
+	default:
+		viaparinfo->tmds_setting_info->dvi_panel_size =
+			VIA_RES_1024X768;
+		DEBUG_MSG(KERN_INFO "Unknow panel size max resolution = %d !\
+					 set default panel size.\n", max_h);
+		break;
+	}
+
+	DEBUG_MSG(KERN_INFO "DVI max pixelclock = %d\n",
+		  viaparinfo->tmds_setting_info->max_pixel_clock);
+	viaparinfo->chip_info->tmds_chip_info.tmds_chip_slave_addr = restore;
+	return viaparinfo->tmds_setting_info->dvi_panel_size;
+}
+
+/*
+ *
+ * int dvi_get_panel_size_from_DDCv2(void)
+ *
+ *     - Get Panel Size Using EDID2 Table
+ *
+ * Return Type:    int
+ *
+ */
+static int dvi_get_panel_size_from_DDCv2(void)
+{
+	int HSize = 0, restore;
+	unsigned char R_Buffer[2];
+
+	DEBUG_MSG(KERN_INFO "\n dvi_get_panel_size_from_DDCv2 \n");
+
+	restore = viaparinfo->chip_info->tmds_chip_info.tmds_chip_slave_addr;
+	viaparinfo->chip_info->tmds_chip_info.tmds_chip_slave_addr = 0xA2;
+
+	/* Horizontal: 0x76, 0x77 */
+	tmds_register_read_bytes(0x76, R_Buffer, 2);
+	HSize = R_Buffer[0];
+	HSize += R_Buffer[1] << 8;
+
+	switch (HSize) {
+	case 640:
+		viaparinfo->tmds_setting_info->dvi_panel_size =
+			VIA_RES_640X480;
+		break;
+	case 800:
+		viaparinfo->tmds_setting_info->dvi_panel_size =
+			VIA_RES_800X600;
+		break;
+	case 1024:
+		viaparinfo->tmds_setting_info->dvi_panel_size =
+			VIA_RES_1024X768;
+		break;
+	case 1280:
+		viaparinfo->tmds_setting_info->dvi_panel_size =
+			VIA_RES_1280X1024;
+		break;
+	case 1400:
+		viaparinfo->tmds_setting_info->dvi_panel_size =
+			VIA_RES_1400X1050;
+		break;
+	case 1440:
+		viaparinfo->tmds_setting_info->dvi_panel_size =
+			VIA_RES_1440X1050;
+		break;
+	case 1600:
+		viaparinfo->tmds_setting_info->dvi_panel_size =
+			VIA_RES_1600X1200;
+		break;
+	default:
+		viaparinfo->tmds_setting_info->dvi_panel_size =
+			VIA_RES_1024X768;
+		DEBUG_MSG(KERN_INFO "Unknow panel size max resolution = %d!\
+					set default panel size.\n", HSize);
+		break;
+	}
+
+	viaparinfo->chip_info->tmds_chip_info.tmds_chip_slave_addr = restore;
+	return viaparinfo->tmds_setting_info->dvi_panel_size;
+}
+
+/*
+ *
+ * unsigned char dvi_get_panel_info(void)
+ *
+ *     - Get Panel Size
+ *
+ * Return Type:    unsigned char
+ */
+static unsigned char dvi_get_panel_info(void)
+{
+	unsigned char dvipanelsize;
+	DEBUG_MSG(KERN_INFO "dvi_get_panel_info! \n");
+
+	viafb_dvi_sense();
+	switch (viafb_dvi_query_EDID()) {
+	case 1:
+		dvi_get_panel_size_from_DDCv1();
+		break;
+	case 2:
+		dvi_get_panel_size_from_DDCv2();
+		break;
+	default:
+		break;
+	}
+
+	DEBUG_MSG(KERN_INFO "dvi panel size is %2d \n",
+		  viaparinfo->tmds_setting_info->dvi_panel_size);
+	dvipanelsize = (unsigned char)(viaparinfo->
+		tmds_setting_info->dvi_panel_size);
+	return dvipanelsize;
+}
+
+/* If Disable DVI, turn off pad */
+void viafb_dvi_disable(void)
+{
+	if (viaparinfo->chip_info->
+		tmds_chip_info.output_interface == INTERFACE_DVP0)
+		viafb_write_reg(SR1E, VIASR,
+		viafb_read_reg(VIASR, SR1E) & (~0xC0));
+
+	if (viaparinfo->chip_info->
+		tmds_chip_info.output_interface == INTERFACE_DVP1)
+		viafb_write_reg(SR1E, VIASR,
+		viafb_read_reg(VIASR, SR1E) & (~0x30));
+
+	if (viaparinfo->chip_info->
+		tmds_chip_info.output_interface == INTERFACE_DFP_HIGH)
+		viafb_write_reg(SR2A, VIASR,
+		viafb_read_reg(VIASR, SR2A) & (~0x0C));
+
+	if (viaparinfo->chip_info->
+		tmds_chip_info.output_interface == INTERFACE_DFP_LOW)
+		viafb_write_reg(SR2A, VIASR,
+		viafb_read_reg(VIASR, SR2A) & (~0x03));
+
+	if (viaparinfo->chip_info->
+		tmds_chip_info.output_interface == INTERFACE_TMDS)
+		/* Turn off TMDS power. */
+		viafb_write_reg(CRD2, VIACR,
+		viafb_read_reg(VIACR, CRD2) | 0x08);
+}
+
+/* If Enable DVI, turn off pad */
+void viafb_dvi_enable(void)
+{
+	u8 data;
+
+	if (viaparinfo->chip_info->
+		tmds_chip_info.output_interface == INTERFACE_DVP0) {
+		viafb_write_reg(SR1E, VIASR,
+			viafb_read_reg(VIASR, SR1E) | 0xC0);
+		if (viaparinfo->chip_info->gfx_chip_name == UNICHROME_CLE266)
+			tmds_register_write(0x88, 0x3b);
+		else
+			/*clear CR91[5] to direct on display period
+			   in the secondary diplay path */
+			viafb_write_reg(CR91, VIACR,
+			viafb_read_reg(VIACR, CR91) & 0xDF);
+	}
+
+	if (viaparinfo->chip_info->
+		tmds_chip_info.output_interface == INTERFACE_DVP1) {
+		viafb_write_reg(SR1E, VIASR,
+			viafb_read_reg(VIASR, SR1E) | 0x30);
+
+		/*fix dvi cann't be enabled with MB VT5718C4 - Al Zhang */
+		if (viaparinfo->chip_info->gfx_chip_name == UNICHROME_CLE266) {
+			tmds_register_write(0x88, 0x3b);
+		} else {
+			/*clear CR91[5] to direct on display period
+			  in the secondary diplay path */
+			viafb_write_reg(CR91, VIACR,
+			viafb_read_reg(VIACR, CR91) & 0xDF);
+		}
+
+		/*fix DVI cannot enable on EPIA-M board */
+		if (viafb_platform_epia_dvi == 1) {
+			viafb_write_reg_mask(CR91, VIACR, 0x1f, 0x1f);
+			viafb_write_reg_mask(CR88, VIACR, 0x00, BIT6 + BIT0);
+			if (viafb_bus_width == 24) {
+				if (viafb_device_lcd_dualedge == 1)
+					data = 0x3F;
+				else
+					data = 0x37;
+				viafb_i2c_writebyte(viaparinfo->chip_info->
+					     tmds_chip_info.
+					     tmds_chip_slave_addr,
+					     0x08, data);
+			}
+		}
+	}
+
+	if (viaparinfo->chip_info->
+		tmds_chip_info.output_interface == INTERFACE_DFP_HIGH) {
+		viafb_write_reg(SR2A, VIASR,
+			viafb_read_reg(VIASR, SR2A) | 0x0C);
+		viafb_write_reg(CR91, VIACR,
+			viafb_read_reg(VIACR, CR91) & 0xDF);
+	}
+
+	if (viaparinfo->chip_info->
+		tmds_chip_info.output_interface == INTERFACE_DFP_LOW) {
+		viafb_write_reg(SR2A, VIASR,
+			viafb_read_reg(VIASR, SR2A) | 0x03);
+		viafb_write_reg(CR91, VIACR,
+			viafb_read_reg(VIACR, CR91) & 0xDF);
+	}
+	if (viaparinfo->chip_info->
+		tmds_chip_info.output_interface == INTERFACE_TMDS) {
+		/* Turn on Display period in the panel path. */
+		viafb_write_reg_mask(CR91, VIACR, 0, BIT7);
+
+		/* Turn on TMDS power. */
+		viafb_write_reg_mask(CRD2, VIACR, 0, BIT3);
+	}
+}
+
--- /dev/null
+++ b/drivers/video/via/dvi.h
@@ -0,0 +1,64 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __DVI_H__
+#define __DVI_H__
+
+/*Definition TMDS Device ID register*/
+#define     VT1632_DEVICE_ID_REG        0x02
+#define     VT1632_DEVICE_ID            0x92
+
+#define     GET_DVI_SIZE_BY_SYSTEM_BIOS     0x01
+#define     GET_DVI_SIZE_BY_VGA_BIOS        0x02
+#define     GET_DVI_SZIE_BY_HW_STRAPPING    0x03
+
+/* Definition DVI Panel ID*/
+/* Resolution: 640x480,   Channel: single, Dithering: Enable */
+#define     DVI_PANEL_ID0_640X480       0x00
+/* Resolution: 800x600,   Channel: single, Dithering: Enable */
+#define     DVI_PANEL_ID1_800x600       0x01
+/* Resolution: 1024x768,  Channel: single, Dithering: Enable */
+#define     DVI_PANEL_ID1_1024x768      0x02
+/* Resolution: 1280x768,  Channel: single, Dithering: Enable */
+#define     DVI_PANEL_ID1_1280x768      0x03
+/* Resolution: 1280x1024, Channel: dual,   Dithering: Enable */
+#define     DVI_PANEL_ID1_1280x1024     0x04
+/* Resolution: 1400x1050, Channel: dual,   Dithering: Enable */
+#define     DVI_PANEL_ID1_1400x1050     0x05
+/* Resolution: 1600x1200, Channel: dual,   Dithering: Enable */
+#define     DVI_PANEL_ID1_1600x1200     0x06
+
+/* Define the version of EDID*/
+#define     EDID_VERSION_1      1
+#define     EDID_VERSION_2      2
+
+#define     DEV_CONNECT_DVI     0x01
+#define     DEV_CONNECT_HDMI    0x02
+
+struct VideoModeTable *viafb_get_cea_mode_tbl_pointer(int Index);
+int viafb_dvi_sense(void);
+void viafb_dvi_disable(void);
+void viafb_dvi_enable(void);
+int viafb_tmds_trasmitter_identify(void);
+void viafb_init_dvi_size(void);
+void viafb_dvi_set_mode(int video_index, int mode_bpp, int set_iga);
+
+#endif /* __DVI_H__ */
--- /dev/null
+++ b/drivers/video/via/global.c
@@ -0,0 +1,60 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#include "global.h"
+int viafb_platform_epia_dvi = STATE_OFF;
+int viafb_device_lcd_dualedge = STATE_OFF;
+int viafb_bus_width = 12;
+int viafb_display_hardware_layout = HW_LAYOUT_LCD_DVI;
+int viafb_memsize;
+int viafb_DeviceStatus = CRT_Device;
+int viafb_hotplug;
+int viafb_refresh = 60;
+int viafb_refresh1 = 60;
+int viafb_lcd_dsp_method = LCD_EXPANDSION;
+int viafb_lcd_mode = LCD_OPENLDI;
+int viafb_bpp = 32;
+int viafb_bpp1 = 32;
+int viafb_accel = 1;
+int viafb_CRT_ON = 1;
+int viafb_DVI_ON;
+int viafb_LCD_ON ;
+int viafb_LCD2_ON;
+int viafb_SAMM_ON;
+int viafb_dual_fb;
+int viafb_hotplug_Xres = 640;
+int viafb_hotplug_Yres = 480;
+int viafb_hotplug_bpp = 32;
+int viafb_hotplug_refresh = 60;
+unsigned int viafb_second_offset;
+int viafb_second_size;
+int viafb_primary_dev = None_Device;
+void __iomem *viafb_FB_MM;
+unsigned int viafb_second_xres = 640;
+unsigned int viafb_second_yres = 480;
+unsigned int viafb_second_virtual_xres;
+unsigned int viafb_second_virtual_yres;
+int viafb_lcd_panel_id = LCD_PANEL_ID_MAXIMUM + 1;
+struct fb_cursor viacursor;
+struct fb_info *viafbinfo;
+struct fb_info *viafbinfo1;
+struct viafb_par *viaparinfo;
+struct viafb_par *viaparinfo1;
+
--- /dev/null
+++ b/drivers/video/via/global.h
@@ -0,0 +1,90 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GLOBAL_H__
+#define __GLOBAL_H__
+
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/pci.h>
+#include <linux/io.h>
+#include <linux/uaccess.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <linux/console.h>
+#include <linux/timer.h>
+
+#include "debug.h"
+
+#include "iface.h"
+#include "viafbdev.h"
+#include "chip.h"
+#include "debug.h"
+#include "accel.h"
+#include "share.h"
+#include "dvi.h"
+#include "viamode.h"
+#include "via_i2c.h"
+#include "hw.h"
+
+#include "lcd.h"
+#include "ioctl.h"
+#include "viamode.h"
+#include "via_utility.h"
+#include "vt1636.h"
+#include "tblDPASetting.h"
+#include "tbl1636.h"
+#include "viafbdev.h"
+
+/* External struct*/
+
+extern int viafb_platform_epia_dvi;
+extern int viafb_device_lcd_dualedge;
+extern int viafb_bus_width;
+extern int viafb_display_hardware_layout;
+extern struct offset offset_reg;
+extern struct viafb_par *viaparinfo;
+extern struct viafb_par *viaparinfo1;
+extern struct fb_info *viafbinfo;
+extern struct fb_info *viafbinfo1;
+extern int viafb_DeviceStatus;
+extern int viafb_refresh;
+extern int viafb_refresh1;
+extern int viafb_lcd_dsp_method;
+extern int viafb_lcd_mode;
+extern int viafb_bpp;
+extern int viafb_bpp1;
+
+extern int viafb_CRT_ON;
+extern int viafb_hotplug_Xres;
+extern int viafb_hotplug_Yres;
+extern int viafb_hotplug_bpp;
+extern int viafb_hotplug_refresh;
+extern int viafb_primary_dev;
+extern void __iomem *viafb_FB_MM;
+extern struct fb_cursor viacursor;
+
+extern unsigned int viafb_second_xres;
+extern unsigned int viafb_second_yres;
+extern int viafb_lcd_panel_id;
+
+#endif /* __GLOBAL_H__ */
--- /dev/null
+++ b/drivers/video/via/hw.c
@@ -0,0 +1,2865 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "global.h"
+
+static const struct pci_device_id_info pciidlist[] = {
+	{PCI_VIA_VENDOR_ID, UNICHROME_CLE266_DID, UNICHROME_CLE266},
+	{PCI_VIA_VENDOR_ID, UNICHROME_PM800_DID, UNICHROME_PM800},
+	{PCI_VIA_VENDOR_ID, UNICHROME_K400_DID, UNICHROME_K400},
+	{PCI_VIA_VENDOR_ID, UNICHROME_K800_DID, UNICHROME_K800},
+	{PCI_VIA_VENDOR_ID, UNICHROME_CN700_DID, UNICHROME_CN700},
+	{PCI_VIA_VENDOR_ID, UNICHROME_P4M890_DID, UNICHROME_P4M890},
+	{PCI_VIA_VENDOR_ID, UNICHROME_K8M890_DID, UNICHROME_K8M890},
+	{PCI_VIA_VENDOR_ID, UNICHROME_CX700_DID, UNICHROME_CX700},
+	{PCI_VIA_VENDOR_ID, UNICHROME_P4M900_DID, UNICHROME_P4M900},
+	{PCI_VIA_VENDOR_ID, UNICHROME_CN750_DID, UNICHROME_CN750},
+	{PCI_VIA_VENDOR_ID, UNICHROME_VX800_DID, UNICHROME_VX800},
+	{0, 0, 0}
+};
+
+struct offset offset_reg = {
+	/* IGA1 Offset Register */
+	{IGA1_OFFSET_REG_NUM, {{CR13, 0, 7}, {CR35, 5, 7} } },
+	/* IGA2 Offset Register */
+	{IGA2_OFFSET_REG_NUM, {{CR66, 0, 7}, {CR67, 0, 1} } }
+};
+
+static struct pll_map pll_value[] = {
+	{CLK_25_175M, CLE266_PLL_25_175M, K800_PLL_25_175M, CX700_25_175M},
+	{CLK_29_581M, CLE266_PLL_29_581M, K800_PLL_29_581M, CX700_29_581M},
+	{CLK_26_880M, CLE266_PLL_26_880M, K800_PLL_26_880M, CX700_26_880M},
+	{CLK_31_490M, CLE266_PLL_31_490M, K800_PLL_31_490M, CX700_31_490M},
+	{CLK_31_500M, CLE266_PLL_31_500M, K800_PLL_31_500M, CX700_31_500M},
+	{CLK_31_728M, CLE266_PLL_31_728M, K800_PLL_31_728M, CX700_31_728M},
+	{CLK_32_668M, CLE266_PLL_32_668M, K800_PLL_32_668M, CX700_32_668M},
+	{CLK_36_000M, CLE266_PLL_36_000M, K800_PLL_36_000M, CX700_36_000M},
+	{CLK_40_000M, CLE266_PLL_40_000M, K800_PLL_40_000M, CX700_40_000M},
+	{CLK_41_291M, CLE266_PLL_41_291M, K800_PLL_41_291M, CX700_41_291M},
+	{CLK_43_163M, CLE266_PLL_43_163M, K800_PLL_43_163M, CX700_43_163M},
+	{CLK_45_250M, CLE266_PLL_45_250M, K800_PLL_45_250M, CX700_45_250M},
+	{CLK_46_000M, CLE266_PLL_46_000M, K800_PLL_46_000M, CX700_46_000M},
+	{CLK_46_996M, CLE266_PLL_46_996M, K800_PLL_46_996M, CX700_46_996M},
+	{CLK_48_000M, CLE266_PLL_48_000M, K800_PLL_48_000M, CX700_48_000M},
+	{CLK_48_875M, CLE266_PLL_48_875M, K800_PLL_48_875M, CX700_48_875M},
+	{CLK_49_500M, CLE266_PLL_49_500M, K800_PLL_49_500M, CX700_49_500M},
+	{CLK_52_406M, CLE266_PLL_52_406M, K800_PLL_52_406M, CX700_52_406M},
+	{CLK_52_977M, CLE266_PLL_52_977M, K800_PLL_52_977M, CX700_52_977M},
+	{CLK_56_250M, CLE266_PLL_56_250M, K800_PLL_56_250M, CX700_56_250M},
+	{CLK_60_466M, CLE266_PLL_60_466M, K800_PLL_60_466M, CX700_60_466M},
+	{CLK_61_500M, CLE266_PLL_61_500M, K800_PLL_61_500M, CX700_61_500M},
+	{CLK_65_000M, CLE266_PLL_65_000M, K800_PLL_65_000M, CX700_65_000M},
+	{CLK_65_178M, CLE266_PLL_65_178M, K800_PLL_65_178M, CX700_65_178M},
+	{CLK_66_750M, CLE266_PLL_66_750M, K800_PLL_66_750M, CX700_66_750M},
+	{CLK_68_179M, CLE266_PLL_68_179M, K800_PLL_68_179M, CX700_68_179M},
+	{CLK_69_924M, CLE266_PLL_69_924M, K800_PLL_69_924M, CX700_69_924M},
+	{CLK_70_159M, CLE266_PLL_70_159M, K800_PLL_70_159M, CX700_70_159M},
+	{CLK_72_000M, CLE266_PLL_72_000M, K800_PLL_72_000M, CX700_72_000M},
+	{CLK_78_750M, CLE266_PLL_78_750M, K800_PLL_78_750M, CX700_78_750M},
+	{CLK_80_136M, CLE266_PLL_80_136M, K800_PLL_80_136M, CX700_80_136M},
+	{CLK_83_375M, CLE266_PLL_83_375M, K800_PLL_83_375M, CX700_83_375M},
+	{CLK_83_950M, CLE266_PLL_83_950M, K800_PLL_83_950M, CX700_83_950M},
+	{CLK_84_750M, CLE266_PLL_84_750M, K800_PLL_84_750M, CX700_84_750M},
+	{CLK_85_860M, CLE266_PLL_85_860M, K800_PLL_85_860M, CX700_85_860M},
+	{CLK_88_750M, CLE266_PLL_88_750M, K800_PLL_88_750M, CX700_88_750M},
+	{CLK_94_500M, CLE266_PLL_94_500M, K800_PLL_94_500M, CX700_94_500M},
+	{CLK_97_750M, CLE266_PLL_97_750M, K800_PLL_97_750M, CX700_97_750M},
+	{CLK_101_000M, CLE266_PLL_101_000M, K800_PLL_101_000M,
+	 CX700_101_000M},
+	{CLK_106_500M, CLE266_PLL_106_500M, K800_PLL_106_500M,
+	 CX700_106_500M},
+	{CLK_108_000M, CLE266_PLL_108_000M, K800_PLL_108_000M,
+	 CX700_108_000M},
+	{CLK_113_309M, CLE266_PLL_113_309M, K800_PLL_113_309M,
+	 CX700_113_309M},
+	{CLK_118_840M, CLE266_PLL_118_840M, K800_PLL_118_840M,
+	 CX700_118_840M},
+	{CLK_119_000M, CLE266_PLL_119_000M, K800_PLL_119_000M,
+	 CX700_119_000M},
+	{CLK_121_750M, CLE266_PLL_121_750M, K800_PLL_121_750M,
+	 CX700_121_750M},
+	{CLK_125_104M, CLE266_PLL_125_104M, K800_PLL_125_104M,
+	 CX700_125_104M},
+	{CLK_133_308M, CLE266_PLL_133_308M, K800_PLL_133_308M,
+	 CX700_133_308M},
+	{CLK_135_000M, CLE266_PLL_135_000M, K800_PLL_135_000M,
+	 CX700_135_000M},
+	{CLK_136_700M, CLE266_PLL_136_700M, K800_PLL_136_700M,
+	 CX700_136_700M},
+	{CLK_138_400M, CLE266_PLL_138_400M, K800_PLL_138_400M,
+	 CX700_138_400M},
+	{CLK_146_760M, CLE266_PLL_146_760M, K800_PLL_146_760M,
+	 CX700_146_760M},
+	{CLK_153_920M, CLE266_PLL_153_920M, K800_PLL_153_920M,
+	 CX700_153_920M},
+	{CLK_156_000M, CLE266_PLL_156_000M, K800_PLL_156_000M,
+	 CX700_156_000M},
+	{CLK_157_500M, CLE266_PLL_157_500M, K800_PLL_157_500M,
+	 CX700_157_500M},
+	{CLK_162_000M, CLE266_PLL_162_000M, K800_PLL_162_000M,
+	 CX700_162_000M},
+	{CLK_187_000M, CLE266_PLL_187_000M, K800_PLL_187_000M,
+	 CX700_187_000M},
+	{CLK_193_295M, CLE266_PLL_193_295M, K800_PLL_193_295M,
+	 CX700_193_295M},
+	{CLK_202_500M, CLE266_PLL_202_500M, K800_PLL_202_500M,
+	 CX700_202_500M},
+	{CLK_204_000M, CLE266_PLL_204_000M, K800_PLL_204_000M,
+	 CX700_204_000M},
+	{CLK_218_500M, CLE266_PLL_218_500M, K800_PLL_218_500M,
+	 CX700_218_500M},
+	{CLK_234_000M, CLE266_PLL_234_000M, K800_PLL_234_000M,
+	 CX700_234_000M},
+	{CLK_267_250M, CLE266_PLL_267_250M, K800_PLL_267_250M,
+	 CX700_267_250M},
+	{CLK_297_500M, CLE266_PLL_297_500M, K800_PLL_297_500M,
+	 CX700_297_500M},
+	{CLK_74_481M, CLE266_PLL_74_481M, K800_PLL_74_481M, CX700_74_481M},
+	{CLK_172_798M, CLE266_PLL_172_798M, K800_PLL_172_798M,
+	 CX700_172_798M},
+	{CLK_122_614M, CLE266_PLL_122_614M, K800_PLL_122_614M,
+	 CX700_122_614M},
+	{CLK_74_270M, CLE266_PLL_74_270M, K800_PLL_74_270M, CX700_74_270M},
+	{CLK_148_500M, CLE266_PLL_148_500M, K800_PLL_148_500M,
+	 CX700_148_500M}
+};
+
+static struct fifo_depth_select display_fifo_depth_reg = {
+	/* IGA1 FIFO Depth_Select */
+	{IGA1_FIFO_DEPTH_SELECT_REG_NUM, {{SR17, 0, 7} } },
+	/* IGA2 FIFO Depth_Select */
+	{IGA2_FIFO_DEPTH_SELECT_REG_NUM,
+	 {{CR68, 4, 7}, {CR94, 7, 7}, {CR95, 7, 7} } }
+};
+
+static struct fifo_threshold_select fifo_threshold_select_reg = {
+	/* IGA1 FIFO Threshold Select */
+	{IGA1_FIFO_THRESHOLD_REG_NUM, {{SR16, 0, 5}, {SR16, 7, 7} } },
+	/* IGA2 FIFO Threshold Select */
+	{IGA2_FIFO_THRESHOLD_REG_NUM, {{CR68, 0, 3}, {CR95, 4, 6} } }
+};
+
+static struct fifo_high_threshold_select fifo_high_threshold_select_reg = {
+	/* IGA1 FIFO High Threshold Select */
+	{IGA1_FIFO_HIGH_THRESHOLD_REG_NUM, {{SR18, 0, 5}, {SR18, 7, 7} } },
+	/* IGA2 FIFO High Threshold Select */
+	{IGA2_FIFO_HIGH_THRESHOLD_REG_NUM, {{CR92, 0, 3}, {CR95, 0, 2} } }
+};
+
+static struct display_queue_expire_num display_queue_expire_num_reg = {
+	/* IGA1 Display Queue Expire Num */
+	{IGA1_DISPLAY_QUEUE_EXPIRE_NUM_REG_NUM, {{SR22, 0, 4} } },
+	/* IGA2 Display Queue Expire Num */
+	{IGA2_DISPLAY_QUEUE_EXPIRE_NUM_REG_NUM, {{CR94, 0, 6} } }
+};
+
+/* Definition Fetch Count Registers*/
+static struct fetch_count fetch_count_reg = {
+	/* IGA1 Fetch Count Register */
+	{IGA1_FETCH_COUNT_REG_NUM, {{SR1C, 0, 7}, {SR1D, 0, 1} } },
+	/* IGA2 Fetch Count Register */
+	{IGA2_FETCH_COUNT_REG_NUM, {{CR65, 0, 7}, {CR67, 2, 3} } }
+};
+
+static struct iga1_crtc_timing iga1_crtc_reg = {
+	/* IGA1 Horizontal Total */
+	{IGA1_HOR_TOTAL_REG_NUM, {{CR00, 0, 7}, {CR36, 3, 3} } },
+	/* IGA1 Horizontal Addressable Video */
+	{IGA1_HOR_ADDR_REG_NUM, {{CR01, 0, 7} } },
+	/* IGA1 Horizontal Blank Start */
+	{IGA1_HOR_BLANK_START_REG_NUM, {{CR02, 0, 7} } },
+	/* IGA1 Horizontal Blank End */
+	{IGA1_HOR_BLANK_END_REG_NUM,
+	 {{CR03, 0, 4}, {CR05, 7, 7}, {CR33, 5, 5} } },
+	/* IGA1 Horizontal Sync Start */
+	{IGA1_HOR_SYNC_START_REG_NUM, {{CR04, 0, 7}, {CR33, 4, 4} } },
+	/* IGA1 Horizontal Sync End */
+	{IGA1_HOR_SYNC_END_REG_NUM, {{CR05, 0, 4} } },
+	/* IGA1 Vertical Total */
+	{IGA1_VER_TOTAL_REG_NUM,
+	 {{CR06, 0, 7}, {CR07, 0, 0}, {CR07, 5, 5}, {CR35, 0, 0} } },
+	/* IGA1 Vertical Addressable Video */
+	{IGA1_VER_ADDR_REG_NUM,
+	 {{CR12, 0, 7}, {CR07, 1, 1}, {CR07, 6, 6}, {CR35, 2, 2} } },
+	/* IGA1 Vertical Blank Start */
+	{IGA1_VER_BLANK_START_REG_NUM,
+	 {{CR15, 0, 7}, {CR07, 3, 3}, {CR09, 5, 5}, {CR35, 3, 3} } },
+	/* IGA1 Vertical Blank End */
+	{IGA1_VER_BLANK_END_REG_NUM, {{CR16, 0, 7} } },
+	/* IGA1 Vertical Sync Start */
+	{IGA1_VER_SYNC_START_REG_NUM,
+	 {{CR10, 0, 7}, {CR07, 2, 2}, {CR07, 7, 7}, {CR35, 1, 1} } },
+	/* IGA1 Vertical Sync End */
+	{IGA1_VER_SYNC_END_REG_NUM, {{CR11, 0, 3} } }
+};
+
+static struct iga2_crtc_timing iga2_crtc_reg = {
+	/* IGA2 Horizontal Total */
+	{IGA2_HOR_TOTAL_REG_NUM, {{CR50, 0, 7}, {CR55, 0, 3} } },
+	/* IGA2 Horizontal Addressable Video */
+	{IGA2_HOR_ADDR_REG_NUM, {{CR51, 0, 7}, {CR55, 4, 6} } },
+	/* IGA2 Horizontal Blank Start */
+	{IGA2_HOR_BLANK_START_REG_NUM, {{CR52, 0, 7}, {CR54, 0, 2} } },
+	/* IGA2 Horizontal Blank End */
+	{IGA2_HOR_BLANK_END_REG_NUM,
+	 {{CR53, 0, 7}, {CR54, 3, 5}, {CR5D, 6, 6} } },
+	/* IGA2 Horizontal Sync Start */
+	{IGA2_HOR_SYNC_START_REG_NUM,
+	 {{CR56, 0, 7}, {CR54, 6, 7}, {CR5C, 7, 7}, {CR5D, 7, 7} } },
+	/* IGA2 Horizontal Sync End */
+	{IGA2_HOR_SYNC_END_REG_NUM, {{CR57, 0, 7}, {CR5C, 6, 6} } },
+	/* IGA2 Vertical Total */
+	{IGA2_VER_TOTAL_REG_NUM, {{CR58, 0, 7}, {CR5D, 0, 2} } },
+	/* IGA2 Vertical Addressable Video */
+	{IGA2_VER_ADDR_REG_NUM, {{CR59, 0, 7}, {CR5D, 3, 5} } },
+	/* IGA2 Vertical Blank Start */
+	{IGA2_VER_BLANK_START_REG_NUM, {{CR5A, 0, 7}, {CR5C, 0, 2} } },
+	/* IGA2 Vertical Blank End */
+	{IGA2_VER_BLANK_END_REG_NUM, {{CR5B, 0, 7}, {CR5C, 3, 5} } },
+	/* IGA2 Vertical Sync Start */
+	{IGA2_VER_SYNC_START_REG_NUM, {{CR5E, 0, 7}, {CR5F, 5, 7} } },
+	/* IGA2 Vertical Sync End */
+	{IGA2_VER_SYNC_END_REG_NUM, {{CR5F, 0, 4} } }
+};
+
+static struct rgbLUT palLUT_table[] = {
+	/* {R,G,B} */
+	/* Index 0x00~0x03 */
+	{0x00, 0x00, 0x00}, {0x00, 0x00, 0x2A}, {0x00, 0x2A, 0x00}, {0x00,
+								     0x2A,
+								     0x2A},
+	/* Index 0x04~0x07 */
+	{0x2A, 0x00, 0x00}, {0x2A, 0x00, 0x2A}, {0x2A, 0x15, 0x00}, {0x2A,
+								     0x2A,
+								     0x2A},
+	/* Index 0x08~0x0B */
+	{0x15, 0x15, 0x15}, {0x15, 0x15, 0x3F}, {0x15, 0x3F, 0x15}, {0x15,
+								     0x3F,
+								     0x3F},
+	/* Index 0x0C~0x0F */
+	{0x3F, 0x15, 0x15}, {0x3F, 0x15, 0x3F}, {0x3F, 0x3F, 0x15}, {0x3F,
+								     0x3F,
+								     0x3F},
+	/* Index 0x10~0x13 */
+	{0x00, 0x00, 0x00}, {0x05, 0x05, 0x05}, {0x08, 0x08, 0x08}, {0x0B,
+								     0x0B,
+								     0x0B},
+	/* Index 0x14~0x17 */
+	{0x0E, 0x0E, 0x0E}, {0x11, 0x11, 0x11}, {0x14, 0x14, 0x14}, {0x18,
+								     0x18,
+								     0x18},
+	/* Index 0x18~0x1B */
+	{0x1C, 0x1C, 0x1C}, {0x20, 0x20, 0x20}, {0x24, 0x24, 0x24}, {0x28,
+								     0x28,
+								     0x28},
+	/* Index 0x1C~0x1F */
+	{0x2D, 0x2D, 0x2D}, {0x32, 0x32, 0x32}, {0x38, 0x38, 0x38}, {0x3F,
+								     0x3F,
+								     0x3F},
+	/* Index 0x20~0x23 */
+	{0x00, 0x00, 0x3F}, {0x10, 0x00, 0x3F}, {0x1F, 0x00, 0x3F}, {0x2F,
+								     0x00,
+								     0x3F},
+	/* Index 0x24~0x27 */
+	{0x3F, 0x00, 0x3F}, {0x3F, 0x00, 0x2F}, {0x3F, 0x00, 0x1F}, {0x3F,
+								     0x00,
+								     0x10},
+	/* Index 0x28~0x2B */
+	{0x3F, 0x00, 0x00}, {0x3F, 0x10, 0x00}, {0x3F, 0x1F, 0x00}, {0x3F,
+								     0x2F,
+								     0x00},
+	/* Index 0x2C~0x2F */
+	{0x3F, 0x3F, 0x00}, {0x2F, 0x3F, 0x00}, {0x1F, 0x3F, 0x00}, {0x10,
+								     0x3F,
+								     0x00},
+	/* Index 0x30~0x33 */
+	{0x00, 0x3F, 0x00}, {0x00, 0x3F, 0x10}, {0x00, 0x3F, 0x1F}, {0x00,
+								     0x3F,
+								     0x2F},
+	/* Index 0x34~0x37 */
+	{0x00, 0x3F, 0x3F}, {0x00, 0x2F, 0x3F}, {0x00, 0x1F, 0x3F}, {0x00,
+								     0x10,
+								     0x3F},
+	/* Index 0x38~0x3B */
+	{0x1F, 0x1F, 0x3F}, {0x27, 0x1F, 0x3F}, {0x2F, 0x1F, 0x3F}, {0x37,
+								     0x1F,
+								     0x3F},
+	/* Index 0x3C~0x3F */
+	{0x3F, 0x1F, 0x3F}, {0x3F, 0x1F, 0x37}, {0x3F, 0x1F, 0x2F}, {0x3F,
+								     0x1F,
+								     0x27},
+	/* Index 0x40~0x43 */
+	{0x3F, 0x1F, 0x1F}, {0x3F, 0x27, 0x1F}, {0x3F, 0x2F, 0x1F}, {0x3F,
+								     0x3F,
+								     0x1F},
+	/* Index 0x44~0x47 */
+	{0x3F, 0x3F, 0x1F}, {0x37, 0x3F, 0x1F}, {0x2F, 0x3F, 0x1F}, {0x27,
+								     0x3F,
+								     0x1F},
+	/* Index 0x48~0x4B */
+	{0x1F, 0x3F, 0x1F}, {0x1F, 0x3F, 0x27}, {0x1F, 0x3F, 0x2F}, {0x1F,
+								     0x3F,
+								     0x37},
+	/* Index 0x4C~0x4F */
+	{0x1F, 0x3F, 0x3F}, {0x1F, 0x37, 0x3F}, {0x1F, 0x2F, 0x3F}, {0x1F,
+								     0x27,
+								     0x3F},
+	/* Index 0x50~0x53 */
+	{0x2D, 0x2D, 0x3F}, {0x31, 0x2D, 0x3F}, {0x36, 0x2D, 0x3F}, {0x3A,
+								     0x2D,
+								     0x3F},
+	/* Index 0x54~0x57 */
+	{0x3F, 0x2D, 0x3F}, {0x3F, 0x2D, 0x3A}, {0x3F, 0x2D, 0x36}, {0x3F,
+								     0x2D,
+								     0x31},
+	/* Index 0x58~0x5B */
+	{0x3F, 0x2D, 0x2D}, {0x3F, 0x31, 0x2D}, {0x3F, 0x36, 0x2D}, {0x3F,
+								     0x3A,
+								     0x2D},
+	/* Index 0x5C~0x5F */
+	{0x3F, 0x3F, 0x2D}, {0x3A, 0x3F, 0x2D}, {0x36, 0x3F, 0x2D}, {0x31,
+								     0x3F,
+								     0x2D},
+	/* Index 0x60~0x63 */
+	{0x2D, 0x3F, 0x2D}, {0x2D, 0x3F, 0x31}, {0x2D, 0x3F, 0x36}, {0x2D,
+								     0x3F,
+								     0x3A},
+	/* Index 0x64~0x67 */
+	{0x2D, 0x3F, 0x3F}, {0x2D, 0x3A, 0x3F}, {0x2D, 0x36, 0x3F}, {0x2D,
+								     0x31,
+								     0x3F},
+	/* Index 0x68~0x6B */
+	{0x00, 0x00, 0x1C}, {0x07, 0x00, 0x1C}, {0x0E, 0x00, 0x1C}, {0x15,
+								     0x00,
+								     0x1C},
+	/* Index 0x6C~0x6F */
+	{0x1C, 0x00, 0x1C}, {0x1C, 0x00, 0x15}, {0x1C, 0x00, 0x0E}, {0x1C,
+								     0x00,
+								     0x07},
+	/* Index 0x70~0x73 */
+	{0x1C, 0x00, 0x00}, {0x1C, 0x07, 0x00}, {0x1C, 0x0E, 0x00}, {0x1C,
+								     0x15,
+								     0x00},
+	/* Index 0x74~0x77 */
+	{0x1C, 0x1C, 0x00}, {0x15, 0x1C, 0x00}, {0x0E, 0x1C, 0x00}, {0x07,
+								     0x1C,
+								     0x00},
+	/* Index 0x78~0x7B */
+	{0x00, 0x1C, 0x00}, {0x00, 0x1C, 0x07}, {0x00, 0x1C, 0x0E}, {0x00,
+								     0x1C,
+								     0x15},
+	/* Index 0x7C~0x7F */
+	{0x00, 0x1C, 0x1C}, {0x00, 0x15, 0x1C}, {0x00, 0x0E, 0x1C}, {0x00,
+								     0x07,
+								     0x1C},
+	/* Index 0x80~0x83 */
+	{0x0E, 0x0E, 0x1C}, {0x11, 0x0E, 0x1C}, {0x15, 0x0E, 0x1C}, {0x18,
+								     0x0E,
+								     0x1C},
+	/* Index 0x84~0x87 */
+	{0x1C, 0x0E, 0x1C}, {0x1C, 0x0E, 0x18}, {0x1C, 0x0E, 0x15}, {0x1C,
+								     0x0E,
+								     0x11},
+	/* Index 0x88~0x8B */
+	{0x1C, 0x0E, 0x0E}, {0x1C, 0x11, 0x0E}, {0x1C, 0x15, 0x0E}, {0x1C,
+								     0x18,
+								     0x0E},
+	/* Index 0x8C~0x8F */
+	{0x1C, 0x1C, 0x0E}, {0x18, 0x1C, 0x0E}, {0x15, 0x1C, 0x0E}, {0x11,
+								     0x1C,
+								     0x0E},
+	/* Index 0x90~0x93 */
+	{0x0E, 0x1C, 0x0E}, {0x0E, 0x1C, 0x11}, {0x0E, 0x1C, 0x15}, {0x0E,
+								     0x1C,
+								     0x18},
+	/* Index 0x94~0x97 */
+	{0x0E, 0x1C, 0x1C}, {0x0E, 0x18, 0x1C}, {0x0E, 0x15, 0x1C}, {0x0E,
+								     0x11,
+								     0x1C},
+	/* Index 0x98~0x9B */
+	{0x14, 0x14, 0x1C}, {0x16, 0x14, 0x1C}, {0x18, 0x14, 0x1C}, {0x1A,
+								     0x14,
+								     0x1C},
+	/* Index 0x9C~0x9F */
+	{0x1C, 0x14, 0x1C}, {0x1C, 0x14, 0x1A}, {0x1C, 0x14, 0x18}, {0x1C,
+								     0x14,
+								     0x16},
+	/* Index 0xA0~0xA3 */
+	{0x1C, 0x14, 0x14}, {0x1C, 0x16, 0x14}, {0x1C, 0x18, 0x14}, {0x1C,
+								     0x1A,
+								     0x14},
+	/* Index 0xA4~0xA7 */
+	{0x1C, 0x1C, 0x14}, {0x1A, 0x1C, 0x14}, {0x18, 0x1C, 0x14}, {0x16,
+								     0x1C,
+								     0x14},
+	/* Index 0xA8~0xAB */
+	{0x14, 0x1C, 0x14}, {0x14, 0x1C, 0x16}, {0x14, 0x1C, 0x18}, {0x14,
+								     0x1C,
+								     0x1A},
+	/* Index 0xAC~0xAF */
+	{0x14, 0x1C, 0x1C}, {0x14, 0x1A, 0x1C}, {0x14, 0x18, 0x1C}, {0x14,
+								     0x16,
+								     0x1C},
+	/* Index 0xB0~0xB3 */
+	{0x00, 0x00, 0x10}, {0x04, 0x00, 0x10}, {0x08, 0x00, 0x10}, {0x0C,
+								     0x00,
+								     0x10},
+	/* Index 0xB4~0xB7 */
+	{0x10, 0x00, 0x10}, {0x10, 0x00, 0x0C}, {0x10, 0x00, 0x08}, {0x10,
+								     0x00,
+								     0x04},
+	/* Index 0xB8~0xBB */
+	{0x10, 0x00, 0x00}, {0x10, 0x04, 0x00}, {0x10, 0x08, 0x00}, {0x10,
+								     0x0C,
+								     0x00},
+	/* Index 0xBC~0xBF */
+	{0x10, 0x10, 0x00}, {0x0C, 0x10, 0x00}, {0x08, 0x10, 0x00}, {0x04,
+								     0x10,
+								     0x00},
+	/* Index 0xC0~0xC3 */
+	{0x00, 0x10, 0x00}, {0x00, 0x10, 0x04}, {0x00, 0x10, 0x08}, {0x00,
+								     0x10,
+								     0x0C},
+	/* Index 0xC4~0xC7 */
+	{0x00, 0x10, 0x10}, {0x00, 0x0C, 0x10}, {0x00, 0x08, 0x10}, {0x00,
+								     0x04,
+								     0x10},
+	/* Index 0xC8~0xCB */
+	{0x08, 0x08, 0x10}, {0x0A, 0x08, 0x10}, {0x0C, 0x08, 0x10}, {0x0E,
+								     0x08,
+								     0x10},
+	/* Index 0xCC~0xCF */
+	{0x10, 0x08, 0x10}, {0x10, 0x08, 0x0E}, {0x10, 0x08, 0x0C}, {0x10,
+								     0x08,
+								     0x0A},
+	/* Index 0xD0~0xD3 */
+	{0x10, 0x08, 0x08}, {0x10, 0x0A, 0x08}, {0x10, 0x0C, 0x08}, {0x10,
+								     0x0E,
+								     0x08},
+	/* Index 0xD4~0xD7 */
+	{0x10, 0x10, 0x08}, {0x0E, 0x10, 0x08}, {0x0C, 0x10, 0x08}, {0x0A,
+								     0x10,
+								     0x08},
+	/* Index 0xD8~0xDB */
+	{0x08, 0x10, 0x08}, {0x08, 0x10, 0x0A}, {0x08, 0x10, 0x0C}, {0x08,
+								     0x10,
+								     0x0E},
+	/* Index 0xDC~0xDF */
+	{0x08, 0x10, 0x10}, {0x08, 0x0E, 0x10}, {0x08, 0x0C, 0x10}, {0x08,
+								     0x0A,
+								     0x10},
+	/* Index 0xE0~0xE3 */
+	{0x0B, 0x0B, 0x10}, {0x0C, 0x0B, 0x10}, {0x0D, 0x0B, 0x10}, {0x0F,
+								     0x0B,
+								     0x10},
+	/* Index 0xE4~0xE7 */
+	{0x10, 0x0B, 0x10}, {0x10, 0x0B, 0x0F}, {0x10, 0x0B, 0x0D}, {0x10,
+								     0x0B,
+								     0x0C},
+	/* Index 0xE8~0xEB */
+	{0x10, 0x0B, 0x0B}, {0x10, 0x0C, 0x0B}, {0x10, 0x0D, 0x0B}, {0x10,
+								     0x0F,
+								     0x0B},
+	/* Index 0xEC~0xEF */
+	{0x10, 0x10, 0x0B}, {0x0F, 0x10, 0x0B}, {0x0D, 0x10, 0x0B}, {0x0C,
+								     0x10,
+								     0x0B},
+	/* Index 0xF0~0xF3 */
+	{0x0B, 0x10, 0x0B}, {0x0B, 0x10, 0x0C}, {0x0B, 0x10, 0x0D}, {0x0B,
+								     0x10,
+								     0x0F},
+	/* Index 0xF4~0xF7 */
+	{0x0B, 0x10, 0x10}, {0x0B, 0x0F, 0x10}, {0x0B, 0x0D, 0x10}, {0x0B,
+								     0x0C,
+								     0x10},
+	/* Index 0xF8~0xFB */
+	{0x00, 0x00, 0x00}, {0x00, 0x00, 0x00}, {0x00, 0x00, 0x00}, {0x00,
+								     0x00,
+								     0x00},
+	/* Index 0xFC~0xFF */
+	{0x00, 0x00, 0x00}, {0x00, 0x00, 0x00}, {0x00, 0x00, 0x00}, {0x00,
+								     0x00,
+								     0x00}
+};
+
+static void set_crt_output_path(int set_iga);
+static void dvi_patch_skew_dvp0(void);
+static void dvi_patch_skew_dvp1(void);
+static void dvi_patch_skew_dvp_low(void);
+static void set_dvi_output_path(int set_iga, int output_interface);
+static void set_lcd_output_path(int set_iga, int output_interface);
+static int search_mode_setting(int ModeInfoIndex);
+static void load_fix_bit_crtc_reg(void);
+static void init_gfx_chip_info(void);
+static void init_tmds_chip_info(void);
+static void init_lvds_chip_info(void);
+static void device_screen_off(void);
+static void device_screen_on(void);
+static void set_display_channel(void);
+static void device_off(void);
+static void device_on(void);
+static void enable_second_display_channel(void);
+static void disable_second_display_channel(void);
+static int get_fb_size_from_pci(void);
+
+void viafb_write_reg(u8 index, u16 io_port, u8 data)
+{
+	outb(index, io_port);
+	outb(data, io_port + 1);
+	/*DEBUG_MSG(KERN_INFO "\nIndex=%2d Value=%2d", index, data); */
+}
+u8 viafb_read_reg(int io_port, u8 index)
+{
+	outb(index, io_port);
+	return inb(io_port + 1);
+}
+
+void viafb_lock_crt(void)
+{
+	viafb_write_reg_mask(CR11, VIACR, BIT7, BIT7);
+}
+
+void viafb_unlock_crt(void)
+{
+	viafb_write_reg_mask(CR11, VIACR, 0, BIT7);
+	viafb_write_reg_mask(CR47, VIACR, 0, BIT0);
+}
+
+void viafb_write_reg_mask(u8 index, int io_port, u8 data, u8 mask)
+{
+	u8 tmp;
+
+	outb(index, io_port);
+	tmp = inb(io_port + 1);
+	outb((data & mask) | (tmp & (~mask)), io_port + 1);
+	/*DEBUG_MSG(KERN_INFO "\nIndex=%2d Value=%2d", index, tmp); */
+}
+
+void write_dac_reg(u8 index, u8 r, u8 g, u8 b)
+{
+	outb(index, LUT_INDEX_WRITE);
+	outb(r, LUT_DATA);
+	outb(g, LUT_DATA);
+	outb(b, LUT_DATA);
+}
+
+/*Set IGA path for each device*/
+void viafb_set_iga_path(void)
+{
+
+	if (viafb_SAMM_ON == 1) {
+		if (viafb_CRT_ON) {
+			if (viafb_primary_dev == CRT_Device)
+				viaparinfo->crt_setting_info->iga_path = IGA1;
+			else
+				viaparinfo->crt_setting_info->iga_path = IGA2;
+		}
+
+		if (viafb_DVI_ON) {
+			if (viafb_primary_dev == DVI_Device)
+				viaparinfo->tmds_setting_info->iga_path = IGA1;
+			else
+				viaparinfo->tmds_setting_info->iga_path = IGA2;
+		}
+
+		if (viafb_LCD_ON) {
+			if (viafb_primary_dev == LCD_Device) {
+				if (viafb_dual_fb &&
+					(viaparinfo->chip_info->gfx_chip_name ==
+					UNICHROME_CLE266)) {
+					viaparinfo->
+					lvds_setting_info->iga_path = IGA2;
+					viaparinfo->
+					crt_setting_info->iga_path = IGA1;
+					viaparinfo->
+					tmds_setting_info->iga_path = IGA1;
+				} else
+					viaparinfo->
+					lvds_setting_info->iga_path = IGA1;
+			} else {
+				viaparinfo->lvds_setting_info->iga_path = IGA2;
+			}
+		}
+		if (viafb_LCD2_ON) {
+			if (LCD2_Device == viafb_primary_dev)
+				viaparinfo->lvds_setting_info2->iga_path = IGA1;
+			else
+				viaparinfo->lvds_setting_info2->iga_path = IGA2;
+		}
+	} else {
+		viafb_SAMM_ON = 0;
+
+		if (viafb_CRT_ON && viafb_LCD_ON) {
+			viaparinfo->crt_setting_info->iga_path = IGA1;
+			viaparinfo->lvds_setting_info->iga_path = IGA2;
+		} else if (viafb_CRT_ON && viafb_DVI_ON) {
+			viaparinfo->crt_setting_info->iga_path = IGA1;
+			viaparinfo->tmds_setting_info->iga_path = IGA2;
+		} else if (viafb_LCD_ON && viafb_DVI_ON) {
+			viaparinfo->tmds_setting_info->iga_path = IGA1;
+			viaparinfo->lvds_setting_info->iga_path = IGA2;
+		} else if (viafb_LCD_ON && viafb_LCD2_ON) {
+			viaparinfo->lvds_setting_info->iga_path = IGA2;
+			viaparinfo->lvds_setting_info2->iga_path = IGA2;
+		} else if (viafb_CRT_ON) {
+			viaparinfo->crt_setting_info->iga_path = IGA1;
+		} else if (viafb_LCD_ON) {
+			viaparinfo->lvds_setting_info->iga_path = IGA2;
+		} else if (viafb_DVI_ON) {
+			viaparinfo->tmds_setting_info->iga_path = IGA1;
+		}
+	}
+}
+
+void viafb_set_start_addr(void)
+{
+	unsigned long offset = 0, tmp = 0, size = 0;
+	unsigned long length;
+
+	DEBUG_MSG(KERN_INFO "viafb_set_start_addr!\n");
+	viafb_unlock_crt();
+	/* update starting address of IGA1 */
+	viafb_write_reg(CR0C, VIACR, 0x00);	/*initial starting address */
+	viafb_write_reg(CR0D, VIACR, 0x00);
+	viafb_write_reg(CR34, VIACR, 0x00);
+	viafb_write_reg_mask(CR48, VIACR, 0x00, 0x1F);
+
+	if (viafb_dual_fb) {
+		viaparinfo->iga_path = IGA1;
+		viaparinfo1->iga_path = IGA2;
+	}
+
+	if (viafb_SAMM_ON == 1) {
+		if (!viafb_dual_fb) {
+			if (viafb_second_size)
+				size = viafb_second_size * 1024 * 1024;
+			else
+				size = 8 * 1024 * 1024;
+		} else {
+
+			size = viaparinfo1->memsize;
+		}
+		offset = viafb_second_offset;
+		DEBUG_MSG(KERN_INFO
+			  "viafb_second_size=%lx, second start_adddress=%lx\n",
+			  size, offset);
+	}
+	if (viafb_SAMM_ON == 1) {
+		offset = offset >> 3;
+
+		tmp = viafb_read_reg(VIACR, 0x62) & 0x01;
+		tmp |= (offset & 0x7F) << 1;
+		viafb_write_reg(CR62, VIACR, tmp);
+		viafb_write_reg(CR63, VIACR, ((offset & 0x7F80) >> 7));
+		viafb_write_reg(CR64, VIACR, ((offset & 0x7F8000) >> 15));
+		viafb_write_reg(CRA3, VIACR, ((offset & 0x3800000) >> 23));
+	} else {
+		/* update starting address */
+		viafb_write_reg(CR62, VIACR, 0x00);
+		viafb_write_reg(CR63, VIACR, 0x00);
+		viafb_write_reg(CR64, VIACR, 0x00);
+		viafb_write_reg(CRA3, VIACR, 0x00);
+	}
+
+	if (viafb_SAMM_ON == 1) {
+		if (viafb_accel) {
+			if (!viafb_dual_fb)
+				length = size - viaparinfo->fbmem_used;
+			else
+				length = size - viaparinfo1->fbmem_used;
+		} else
+			length = size;
+		offset = (unsigned long)(void *)viafb_FB_MM +
+			viafb_second_offset;
+		memset((void *)offset, 0, length);
+	}
+
+	viafb_lock_crt();
+}
+
+void viafb_set_output_path(int device, int set_iga, int output_interface)
+{
+	switch (device) {
+	case DEVICE_CRT:
+		set_crt_output_path(set_iga);
+		break;
+	case DEVICE_DVI:
+		set_dvi_output_path(set_iga, output_interface);
+		break;
+	case DEVICE_LCD:
+		set_lcd_output_path(set_iga, output_interface);
+		break;
+	}
+}
+
+static void set_crt_output_path(int set_iga)
+{
+	viafb_write_reg_mask(CR36, VIACR, 0x00, BIT4 + BIT5);
+
+	switch (set_iga) {
+	case IGA1:
+		viafb_write_reg_mask(SR16, VIASR, 0x00, BIT6);
+		break;
+	case IGA2:
+	case IGA1_IGA2:
+		viafb_write_reg_mask(CR6A, VIACR, 0xC0, BIT6 + BIT7);
+		viafb_write_reg_mask(SR16, VIASR, 0x40, BIT6);
+		if (set_iga == IGA1_IGA2)
+			viafb_write_reg_mask(CR6B, VIACR, 0x08, BIT3);
+		break;
+	}
+}
+
+static void dvi_patch_skew_dvp0(void)
+{
+	/* Reset data driving first: */
+	viafb_write_reg_mask(SR1B, VIASR, 0, BIT1);
+	viafb_write_reg_mask(SR2A, VIASR, 0, BIT4);
+
+	switch (viaparinfo->chip_info->gfx_chip_name) {
+	case UNICHROME_P4M890:
+		{
+			if ((viaparinfo->tmds_setting_info->h_active == 1600) &&
+				(viaparinfo->tmds_setting_info->v_active ==
+				1200))
+				viafb_write_reg_mask(CR96, VIACR, 0x03,
+					       BIT0 + BIT1 + BIT2);
+			else
+				viafb_write_reg_mask(CR96, VIACR, 0x07,
+					       BIT0 + BIT1 + BIT2);
+			break;
+		}
+
+	case UNICHROME_P4M900:
+		{
+			viafb_write_reg_mask(CR96, VIACR, 0x07,
+				       BIT0 + BIT1 + BIT2 + BIT3);
+			viafb_write_reg_mask(SR1B, VIASR, 0x02, BIT1);
+			viafb_write_reg_mask(SR2A, VIASR, 0x10, BIT4);
+			break;
+		}
+
+	default:
+		{
+			break;
+		}
+	}
+}
+
+static void dvi_patch_skew_dvp1(void)
+{
+	switch (viaparinfo->chip_info->gfx_chip_name) {
+	case UNICHROME_CX700:
+		{
+			break;
+		}
+
+	default:
+		{
+			break;
+		}
+	}
+}
+
+static void dvi_patch_skew_dvp_low(void)
+{
+	switch (viaparinfo->chip_info->gfx_chip_name) {
+	case UNICHROME_K8M890:
+		{
+			viafb_write_reg_mask(CR99, VIACR, 0x03, BIT0 + BIT1);
+			break;
+		}
+
+	case UNICHROME_P4M900:
+		{
+			viafb_write_reg_mask(CR99, VIACR, 0x08,
+				       BIT0 + BIT1 + BIT2 + BIT3);
+			break;
+		}
+
+	case UNICHROME_P4M890:
+		{
+			viafb_write_reg_mask(CR99, VIACR, 0x0F,
+				       BIT0 + BIT1 + BIT2 + BIT3);
+			break;
+		}
+
+	default:
+		{
+			break;
+		}
+	}
+}
+
+static void set_dvi_output_path(int set_iga, int output_interface)
+{
+	switch (output_interface) {
+	case INTERFACE_DVP0:
+		viafb_write_reg_mask(CR6B, VIACR, 0x01, BIT0);
+
+		if (set_iga == IGA1) {
+			viafb_write_reg_mask(CR96, VIACR, 0x00, BIT4);
+			viafb_write_reg_mask(CR6C, VIACR, 0x21, BIT0 +
+				BIT5 + BIT7);
+		} else {
+			viafb_write_reg_mask(CR96, VIACR, 0x10, BIT4);
+			viafb_write_reg_mask(CR6C, VIACR, 0xA1, BIT0 +
+				BIT5 + BIT7);
+		}
+
+		viafb_write_reg_mask(SR1E, VIASR, 0xC0, BIT7 + BIT6);
+
+		dvi_patch_skew_dvp0();
+		break;
+
+	case INTERFACE_DVP1:
+		if (viaparinfo->chip_info->gfx_chip_name == UNICHROME_CLE266) {
+			if (set_iga == IGA1)
+				viafb_write_reg_mask(CR93, VIACR, 0x21,
+					       BIT0 + BIT5 + BIT7);
+			else
+				viafb_write_reg_mask(CR93, VIACR, 0xA1,
+					       BIT0 + BIT5 + BIT7);
+		} else {
+			if (set_iga == IGA1)
+				viafb_write_reg_mask(CR9B, VIACR, 0x00, BIT4);
+			else
+				viafb_write_reg_mask(CR9B, VIACR, 0x10, BIT4);
+		}
+
+		viafb_write_reg_mask(SR1E, VIASR, 0x30, BIT4 + BIT5);
+		dvi_patch_skew_dvp1();
+		break;
+	case INTERFACE_DFP_HIGH:
+		if (viaparinfo->chip_info->gfx_chip_name != UNICHROME_CLE266) {
+			if (set_iga == IGA1) {
+				viafb_write_reg_mask(CR96, VIACR, 0x00, BIT4);
+				viafb_write_reg_mask(CR97, VIACR, 0x03,
+					       BIT0 + BIT1 + BIT4);
+			} else {
+				viafb_write_reg_mask(CR96, VIACR, 0x10, BIT4);
+				viafb_write_reg_mask(CR97, VIACR, 0x13,
+					       BIT0 + BIT1 + BIT4);
+			}
+		}
+		viafb_write_reg_mask(SR2A, VIASR, 0x0C, BIT2 + BIT3);
+		break;
+
+	case INTERFACE_DFP_LOW:
+		if (viaparinfo->chip_info->gfx_chip_name == UNICHROME_CLE266)
+			break;
+
+		if (set_iga == IGA1) {
+			viafb_write_reg_mask(CR99, VIACR, 0x00, BIT4);
+			viafb_write_reg_mask(CR9B, VIACR, 0x00, BIT4);
+		} else {
+			viafb_write_reg_mask(CR99, VIACR, 0x10, BIT4);
+			viafb_write_reg_mask(CR9B, VIACR, 0x10, BIT4);
+		}
+
+		viafb_write_reg_mask(SR2A, VIASR, 0x03, BIT0 + BIT1);
+		dvi_patch_skew_dvp_low();
+		break;
+
+	case INTERFACE_TMDS:
+		if (set_iga == IGA1)
+			viafb_write_reg_mask(CR99, VIACR, 0x00, BIT4);
+		else
+			viafb_write_reg_mask(CR99, VIACR, 0x10, BIT4);
+		break;
+	}
+
+	if (set_iga == IGA2) {
+		enable_second_display_channel();
+		/* Disable LCD Scaling */
+		viafb_write_reg_mask(CR79, VIACR, 0x00, BIT0);
+	}
+}
+
+static void set_lcd_output_path(int set_iga, int output_interface)
+{
+	DEBUG_MSG(KERN_INFO
+		  "set_lcd_output_path, iga:%d,out_interface:%d\n",
+		  set_iga, output_interface);
+	switch (set_iga) {
+	case IGA1:
+		viafb_write_reg_mask(CR6B, VIACR, 0x00, BIT3);
+		viafb_write_reg_mask(CR6A, VIACR, 0x08, BIT3);
+
+		disable_second_display_channel();
+		break;
+
+	case IGA2:
+		viafb_write_reg_mask(CR6B, VIACR, 0x00, BIT3);
+		viafb_write_reg_mask(CR6A, VIACR, 0x08, BIT3);
+
+		enable_second_display_channel();
+		break;
+
+	case IGA1_IGA2:
+		viafb_write_reg_mask(CR6B, VIACR, 0x08, BIT3);
+		viafb_write_reg_mask(CR6A, VIACR, 0x08, BIT3);
+
+		disable_second_display_channel();
+		break;
+	}
+
+	switch (output_interface) {
+	case INTERFACE_DVP0:
+		if (set_iga == IGA1) {
+			viafb_write_reg_mask(CR96, VIACR, 0x00, BIT4);
+		} else {
+			viafb_write_reg(CR91, VIACR, 0x00);
+			viafb_write_reg_mask(CR96, VIACR, 0x10, BIT4);
+		}
+		break;
+
+	case INTERFACE_DVP1:
+		if (set_iga == IGA1)
+			viafb_write_reg_mask(CR9B, VIACR, 0x00, BIT4);
+		else {
+			viafb_write_reg(CR91, VIACR, 0x00);
+			viafb_write_reg_mask(CR9B, VIACR, 0x10, BIT4);
+		}
+		break;
+
+	case INTERFACE_DFP_HIGH:
+		if (set_iga == IGA1)
+			viafb_write_reg_mask(CR97, VIACR, 0x00, BIT4);
+		else {
+			viafb_write_reg(CR91, VIACR, 0x00);
+			viafb_write_reg_mask(CR97, VIACR, 0x10, BIT4);
+			viafb_write_reg_mask(CR96, VIACR, 0x10, BIT4);
+		}
+		break;
+
+	case INTERFACE_DFP_LOW:
+		if (set_iga == IGA1)
+			viafb_write_reg_mask(CR99, VIACR, 0x00, BIT4);
+		else {
+			viafb_write_reg(CR91, VIACR, 0x00);
+			viafb_write_reg_mask(CR99, VIACR, 0x10, BIT4);
+			viafb_write_reg_mask(CR9B, VIACR, 0x10, BIT4);
+		}
+
+		break;
+
+	case INTERFACE_DFP:
+		if ((UNICHROME_K8M890 == viaparinfo->chip_info->gfx_chip_name)
+		    || (UNICHROME_P4M890 ==
+		    viaparinfo->chip_info->gfx_chip_name))
+			viafb_write_reg_mask(CR97, VIACR, 0x84,
+				       BIT7 + BIT2 + BIT1 + BIT0);
+		if (set_iga == IGA1) {
+			viafb_write_reg_mask(CR97, VIACR, 0x00, BIT4);
+			viafb_write_reg_mask(CR99, VIACR, 0x00, BIT4);
+		} else {
+			viafb_write_reg(CR91, VIACR, 0x00);
+			viafb_write_reg_mask(CR97, VIACR, 0x10, BIT4);
+			viafb_write_reg_mask(CR99, VIACR, 0x10, BIT4);
+		}
+		break;
+
+	case INTERFACE_LVDS0:
+	case INTERFACE_LVDS0LVDS1:
+		if (set_iga == IGA1)
+			viafb_write_reg_mask(CR99, VIACR, 0x00, BIT4);
+		else
+			viafb_write_reg_mask(CR99, VIACR, 0x10, BIT4);
+
+		break;
+
+	case INTERFACE_LVDS1:
+		if (set_iga == IGA1)
+			viafb_write_reg_mask(CR97, VIACR, 0x00, BIT4);
+		else
+			viafb_write_reg_mask(CR97, VIACR, 0x10, BIT4);
+		break;
+	}
+}
+
+/* Search Mode Index */
+static int search_mode_setting(int ModeInfoIndex)
+{
+	int i = 0;
+
+	while ((i < NUM_TOTAL_MODETABLE) &&
+			(ModeInfoIndex != CLE266Modes[i].ModeIndex))
+		i++;
+	if (i >= NUM_TOTAL_MODETABLE)
+		i = 0;
+	return i;
+
+}
+
+struct VideoModeTable *viafb_get_modetbl_pointer(int Index)
+{
+	struct VideoModeTable *TmpTbl = NULL;
+	TmpTbl = &CLE266Modes[search_mode_setting(Index)];
+	return TmpTbl;
+}
+
+struct VideoModeTable *viafb_get_cea_mode_tbl_pointer(int Index)
+{
+	struct VideoModeTable *TmpTbl = NULL;
+	int i = 0;
+	while ((i < NUM_TOTAL_CEA_MODES) &&
+			(Index != CEA_HDMI_Modes[i].ModeIndex))
+		i++;
+	if ((i < NUM_TOTAL_CEA_MODES))
+		TmpTbl = &CEA_HDMI_Modes[i];
+	 else {
+		/*Still use general timing if don't find CEA timing */
+		i = 0;
+		while ((i < NUM_TOTAL_MODETABLE) &&
+				(Index != CLE266Modes[i].ModeIndex))
+		       i++;
+		if (i >= NUM_TOTAL_MODETABLE)
+			i = 0;
+		TmpTbl = &CLE266Modes[i];
+	}
+	return TmpTbl;
+}
+
+static void load_fix_bit_crtc_reg(void)
+{
+	/* always set to 1 */
+	viafb_write_reg_mask(CR03, VIACR, 0x80, BIT7);
+	/* line compare should set all bits = 1 (extend modes) */
+	viafb_write_reg(CR18, VIACR, 0xff);
+	/* line compare should set all bits = 1 (extend modes) */
+	viafb_write_reg_mask(CR07, VIACR, 0x10, BIT4);
+	/* line compare should set all bits = 1 (extend modes) */
+	viafb_write_reg_mask(CR09, VIACR, 0x40, BIT6);
+	/* line compare should set all bits = 1 (extend modes) */
+	viafb_write_reg_mask(CR35, VIACR, 0x10, BIT4);
+	/* line compare should set all bits = 1 (extend modes) */
+	viafb_write_reg_mask(CR33, VIACR, 0x06, BIT0 + BIT1 + BIT2);
+	/*viafb_write_reg_mask(CR32, VIACR, 0x01, BIT0); */
+	/* extend mode always set to e3h */
+	viafb_write_reg(CR17, VIACR, 0xe3);
+	/* extend mode always set to 0h */
+	viafb_write_reg(CR08, VIACR, 0x00);
+	/* extend mode always set to 0h */
+	viafb_write_reg(CR14, VIACR, 0x00);
+
+	/* If K8M800, enable Prefetch Mode. */
+	if ((viaparinfo->chip_info->gfx_chip_name == UNICHROME_K800)
+		|| (viaparinfo->chip_info->gfx_chip_name == UNICHROME_K8M890))
+		viafb_write_reg_mask(CR33, VIACR, 0x08, BIT3);
+	if ((viaparinfo->chip_info->gfx_chip_name == UNICHROME_CLE266)
+	    && (viaparinfo->chip_info->gfx_chip_revision == CLE266_REVISION_AX))
+		viafb_write_reg_mask(SR1A, VIASR, 0x02, BIT1);
+
+}
+
+void viafb_load_reg(int timing_value, int viafb_load_reg_num,
+	struct io_register *reg,
+	      int io_type)
+{
+	int reg_mask;
+	int bit_num = 0;
+	int data;
+	int i, j;
+	int shift_next_reg;
+	int start_index, end_index, cr_index;
+	u16 get_bit;
+
+	for (i = 0; i < viafb_load_reg_num; i++) {
+		reg_mask = 0;
+		data = 0;
+		start_index = reg[i].start_bit;
+		end_index = reg[i].end_bit;
+		cr_index = reg[i].io_addr;
+
+		shift_next_reg = bit_num;
+		for (j = start_index; j <= end_index; j++) {
+			/*if (bit_num==8) timing_value = timing_value >>8; */
+			reg_mask = reg_mask | (BIT0 << j);
+			get_bit = (timing_value & (BIT0 << bit_num));
+			data =
+			    data | ((get_bit >> shift_next_reg) << start_index);
+			bit_num++;
+		}
+		if (io_type == VIACR)
+			viafb_write_reg_mask(cr_index, VIACR, data, reg_mask);
+		else
+			viafb_write_reg_mask(cr_index, VIASR, data, reg_mask);
+	}
+
+}
+
+/* Write Registers */
+void viafb_write_regx(struct io_reg RegTable[], int ItemNum)
+{
+	int i;
+	unsigned char RegTemp;
+
+	/*DEBUG_MSG(KERN_INFO "Table Size : %x!!\n",ItemNum ); */
+
+	for (i = 0; i < ItemNum; i++) {
+		outb(RegTable[i].index, RegTable[i].port);
+		RegTemp = inb(RegTable[i].port + 1);
+		RegTemp = (RegTemp & (~RegTable[i].mask)) | RegTable[i].value;
+		outb(RegTemp, RegTable[i].port + 1);
+	}
+}
+
+void viafb_load_offset_reg(int h_addr, int bpp_byte, int set_iga)
+{
+	int reg_value;
+	int viafb_load_reg_num;
+	struct io_register *reg;
+
+	switch (set_iga) {
+	case IGA1_IGA2:
+	case IGA1:
+		reg_value = IGA1_OFFSET_FORMULA(h_addr, bpp_byte);
+		viafb_load_reg_num = offset_reg.iga1_offset_reg.reg_num;
+		reg = offset_reg.iga1_offset_reg.reg;
+		viafb_load_reg(reg_value, viafb_load_reg_num, reg, VIACR);
+		if (set_iga == IGA1)
+			break;
+	case IGA2:
+		reg_value = IGA2_OFFSET_FORMULA(h_addr, bpp_byte);
+		viafb_load_reg_num = offset_reg.iga2_offset_reg.reg_num;
+		reg = offset_reg.iga2_offset_reg.reg;
+		viafb_load_reg(reg_value, viafb_load_reg_num, reg, VIACR);
+		break;
+	}
+}
+
+void viafb_load_fetch_count_reg(int h_addr, int bpp_byte, int set_iga)
+{
+	int reg_value;
+	int viafb_load_reg_num;
+	struct io_register *reg = NULL;
+
+	switch (set_iga) {
+	case IGA1_IGA2:
+	case IGA1:
+		reg_value = IGA1_FETCH_COUNT_FORMULA(h_addr, bpp_byte);
+		viafb_load_reg_num = fetch_count_reg.
+			iga1_fetch_count_reg.reg_num;
+		reg = fetch_count_reg.iga1_fetch_count_reg.reg;
+		viafb_load_reg(reg_value, viafb_load_reg_num, reg, VIASR);
+		if (set_iga == IGA1)
+			break;
+	case IGA2:
+		reg_value = IGA2_FETCH_COUNT_FORMULA(h_addr, bpp_byte);
+		viafb_load_reg_num = fetch_count_reg.
+			iga2_fetch_count_reg.reg_num;
+		reg = fetch_count_reg.iga2_fetch_count_reg.reg;
+		viafb_load_reg(reg_value, viafb_load_reg_num, reg, VIACR);
+		break;
+	}
+
+}
+
+void viafb_load_FIFO_reg(int set_iga, int hor_active, int ver_active)
+{
+	int reg_value;
+	int viafb_load_reg_num;
+	struct io_register *reg = NULL;
+	int iga1_fifo_max_depth = 0, iga1_fifo_threshold =
+	    0, iga1_fifo_high_threshold = 0, iga1_display_queue_expire_num = 0;
+	int iga2_fifo_max_depth = 0, iga2_fifo_threshold =
+	    0, iga2_fifo_high_threshold = 0, iga2_display_queue_expire_num = 0;
+
+	if (set_iga == IGA1) {
+		if (viaparinfo->chip_info->gfx_chip_name == UNICHROME_K800) {
+			iga1_fifo_max_depth = K800_IGA1_FIFO_MAX_DEPTH;
+			iga1_fifo_threshold = K800_IGA1_FIFO_THRESHOLD;
+			iga1_fifo_high_threshold =
+			    K800_IGA1_FIFO_HIGH_THRESHOLD;
+			/* If resolution > 1280x1024, expire length = 64, else
+			   expire length = 128 */
+			if ((hor_active > 1280) && (ver_active > 1024))
+				iga1_display_queue_expire_num = 16;
+			else
+				iga1_display_queue_expire_num =
+				    K800_IGA1_DISPLAY_QUEUE_EXPIRE_NUM;
+
+		}
+
+		if (viaparinfo->chip_info->gfx_chip_name == UNICHROME_PM800) {
+			iga1_fifo_max_depth = P880_IGA1_FIFO_MAX_DEPTH;
+			iga1_fifo_threshold = P880_IGA1_FIFO_THRESHOLD;
+			iga1_fifo_high_threshold =
+			    P880_IGA1_FIFO_HIGH_THRESHOLD;
+			iga1_display_queue_expire_num =
+			    P880_IGA1_DISPLAY_QUEUE_EXPIRE_NUM;
+
+			/* If resolution > 1280x1024, expire length = 64, else
+			   expire length = 128 */
+			if ((hor_active > 1280) && (ver_active > 1024))
+				iga1_display_queue_expire_num = 16;
+			else
+				iga1_display_queue_expire_num =
+				    P880_IGA1_DISPLAY_QUEUE_EXPIRE_NUM;
+		}
+
+		if (viaparinfo->chip_info->gfx_chip_name == UNICHROME_CN700) {
+			iga1_fifo_max_depth = CN700_IGA1_FIFO_MAX_DEPTH;
+			iga1_fifo_threshold = CN700_IGA1_FIFO_THRESHOLD;
+			iga1_fifo_high_threshold =
+			    CN700_IGA1_FIFO_HIGH_THRESHOLD;
+
+			/* If resolution > 1280x1024, expire length = 64,
+			   else expire length = 128 */
+			if ((hor_active > 1280) && (ver_active > 1024))
+				iga1_display_queue_expire_num = 16;
+			else
+				iga1_display_queue_expire_num =
+				    CN700_IGA1_DISPLAY_QUEUE_EXPIRE_NUM;
+		}
+
+		if (viaparinfo->chip_info->gfx_chip_name == UNICHROME_CX700) {
+			iga1_fifo_max_depth = CX700_IGA1_FIFO_MAX_DEPTH;
+			iga1_fifo_threshold = CX700_IGA1_FIFO_THRESHOLD;
+			iga1_fifo_high_threshold =
+			    CX700_IGA1_FIFO_HIGH_THRESHOLD;
+			iga1_display_queue_expire_num =
+			    CX700_IGA1_DISPLAY_QUEUE_EXPIRE_NUM;
+		}
+
+		if (viaparinfo->chip_info->gfx_chip_name == UNICHROME_K8M890) {
+			iga1_fifo_max_depth = K8M890_IGA1_FIFO_MAX_DEPTH;
+			iga1_fifo_threshold = K8M890_IGA1_FIFO_THRESHOLD;
+			iga1_fifo_high_threshold =
+			    K8M890_IGA1_FIFO_HIGH_THRESHOLD;
+			iga1_display_queue_expire_num =
+			    K8M890_IGA1_DISPLAY_QUEUE_EXPIRE_NUM;
+		}
+
+		if (viaparinfo->chip_info->gfx_chip_name == UNICHROME_P4M890) {
+			iga1_fifo_max_depth = P4M890_IGA1_FIFO_MAX_DEPTH;
+			iga1_fifo_threshold = P4M890_IGA1_FIFO_THRESHOLD;
+			iga1_fifo_high_threshold =
+			    P4M890_IGA1_FIFO_HIGH_THRESHOLD;
+			iga1_display_queue_expire_num =
+			    P4M890_IGA1_DISPLAY_QUEUE_EXPIRE_NUM;
+		}
+
+		if (viaparinfo->chip_info->gfx_chip_name == UNICHROME_P4M900) {
+			iga1_fifo_max_depth = P4M900_IGA1_FIFO_MAX_DEPTH;
+			iga1_fifo_threshold = P4M900_IGA1_FIFO_THRESHOLD;
+			iga1_fifo_high_threshold =
+			    P4M900_IGA1_FIFO_HIGH_THRESHOLD;
+			iga1_display_queue_expire_num =
+			    P4M900_IGA1_DISPLAY_QUEUE_EXPIRE_NUM;
+		}
+
+		if (viaparinfo->chip_info->gfx_chip_name == UNICHROME_VX800) {
+			iga1_fifo_max_depth = VX800_IGA1_FIFO_MAX_DEPTH;
+			iga1_fifo_threshold = VX800_IGA1_FIFO_THRESHOLD;
+			iga1_fifo_high_threshold =
+			    VX800_IGA1_FIFO_HIGH_THRESHOLD;
+			iga1_display_queue_expire_num =
+			    VX800_IGA1_DISPLAY_QUEUE_EXPIRE_NUM;
+		}
+
+		/* Set Display FIFO Depath Select */
+		reg_value = IGA1_FIFO_DEPTH_SELECT_FORMULA(iga1_fifo_max_depth);
+		viafb_load_reg_num =
+		    display_fifo_depth_reg.iga1_fifo_depth_select_reg.reg_num;
+		reg = display_fifo_depth_reg.iga1_fifo_depth_select_reg.reg;
+		viafb_load_reg(reg_value, viafb_load_reg_num, reg, VIASR);
+
+		/* Set Display FIFO Threshold Select */
+		reg_value = IGA1_FIFO_THRESHOLD_FORMULA(iga1_fifo_threshold);
+		viafb_load_reg_num =
+		    fifo_threshold_select_reg.
+		    iga1_fifo_threshold_select_reg.reg_num;
+		reg =
+		    fifo_threshold_select_reg.
+		    iga1_fifo_threshold_select_reg.reg;
+		viafb_load_reg(reg_value, viafb_load_reg_num, reg, VIASR);
+
+		/* Set FIFO High Threshold Select */
+		reg_value =
+		    IGA1_FIFO_HIGH_THRESHOLD_FORMULA(iga1_fifo_high_threshold);
+		viafb_load_reg_num =
+		    fifo_high_threshold_select_reg.
+		    iga1_fifo_high_threshold_select_reg.reg_num;
+		reg =
+		    fifo_high_threshold_select_reg.
+		    iga1_fifo_high_threshold_select_reg.reg;
+		viafb_load_reg(reg_value, viafb_load_reg_num, reg, VIASR);
+
+		/* Set Display Queue Expire Num */
+		reg_value =
+		    IGA1_DISPLAY_QUEUE_EXPIRE_NUM_FORMULA
+		    (iga1_display_queue_expire_num);
+		viafb_load_reg_num =
+		    display_queue_expire_num_reg.
+		    iga1_display_queue_expire_num_reg.reg_num;
+		reg =
+		    display_queue_expire_num_reg.
+		    iga1_display_queue_expire_num_reg.reg;
+		viafb_load_reg(reg_value, viafb_load_reg_num, reg, VIASR);
+
+	} else {
+		if (viaparinfo->chip_info->gfx_chip_name == UNICHROME_K800) {
+			iga2_fifo_max_depth = K800_IGA2_FIFO_MAX_DEPTH;
+			iga2_fifo_threshold = K800_IGA2_FIFO_THRESHOLD;
+			iga2_fifo_high_threshold =
+			    K800_IGA2_FIFO_HIGH_THRESHOLD;
+
+			/* If resolution > 1280x1024, expire length = 64,
+			   else  expire length = 128 */
+			if ((hor_active > 1280) && (ver_active > 1024))
+				iga2_display_queue_expire_num = 16;
+			else
+				iga2_display_queue_expire_num =
+				    K800_IGA2_DISPLAY_QUEUE_EXPIRE_NUM;
+		}
+
+		if (viaparinfo->chip_info->gfx_chip_name == UNICHROME_PM800) {
+			iga2_fifo_max_depth = P880_IGA2_FIFO_MAX_DEPTH;
+			iga2_fifo_threshold = P880_IGA2_FIFO_THRESHOLD;
+			iga2_fifo_high_threshold =
+			    P880_IGA2_FIFO_HIGH_THRESHOLD;
+
+			/* If resolution > 1280x1024, expire length = 64,
+			   else  expire length = 128 */
+			if ((hor_active > 1280) && (ver_active > 1024))
+				iga2_display_queue_expire_num = 16;
+			else
+				iga2_display_queue_expire_num =
+				    P880_IGA2_DISPLAY_QUEUE_EXPIRE_NUM;
+		}
+
+		if (viaparinfo->chip_info->gfx_chip_name == UNICHROME_CN700) {
+			iga2_fifo_max_depth = CN700_IGA2_FIFO_MAX_DEPTH;
+			iga2_fifo_threshold = CN700_IGA2_FIFO_THRESHOLD;
+			iga2_fifo_high_threshold =
+			    CN700_IGA2_FIFO_HIGH_THRESHOLD;
+
+			/* If resolution > 1280x1024, expire length = 64,
+			   else expire length = 128 */
+			if ((hor_active > 1280) && (ver_active > 1024))
+				iga2_display_queue_expire_num = 16;
+			else
+				iga2_display_queue_expire_num =
+				    CN700_IGA2_DISPLAY_QUEUE_EXPIRE_NUM;
+		}
+
+		if (viaparinfo->chip_info->gfx_chip_name == UNICHROME_CX700) {
+			iga2_fifo_max_depth = CX700_IGA2_FIFO_MAX_DEPTH;
+			iga2_fifo_threshold = CX700_IGA2_FIFO_THRESHOLD;
+			iga2_fifo_high_threshold =
+			    CX700_IGA2_FIFO_HIGH_THRESHOLD;
+			iga2_display_queue_expire_num =
+			    CX700_IGA2_DISPLAY_QUEUE_EXPIRE_NUM;
+		}
+
+		if (viaparinfo->chip_info->gfx_chip_name == UNICHROME_K8M890) {
+			iga2_fifo_max_depth = K8M890_IGA2_FIFO_MAX_DEPTH;
+			iga2_fifo_threshold = K8M890_IGA2_FIFO_THRESHOLD;
+			iga2_fifo_high_threshold =
+			    K8M890_IGA2_FIFO_HIGH_THRESHOLD;
+			iga2_display_queue_expire_num =
+			    K8M890_IGA2_DISPLAY_QUEUE_EXPIRE_NUM;
+		}
+
+		if (viaparinfo->chip_info->gfx_chip_name == UNICHROME_P4M890) {
+			iga2_fifo_max_depth = P4M890_IGA2_FIFO_MAX_DEPTH;
+			iga2_fifo_threshold = P4M890_IGA2_FIFO_THRESHOLD;
+			iga2_fifo_high_threshold =
+			    P4M890_IGA2_FIFO_HIGH_THRESHOLD;
+			iga2_display_queue_expire_num =
+			    P4M890_IGA2_DISPLAY_QUEUE_EXPIRE_NUM;
+		}
+
+		if (viaparinfo->chip_info->gfx_chip_name == UNICHROME_P4M900) {
+			iga2_fifo_max_depth = P4M900_IGA2_FIFO_MAX_DEPTH;
+			iga2_fifo_threshold = P4M900_IGA2_FIFO_THRESHOLD;
+			iga2_fifo_high_threshold =
+			    P4M900_IGA2_FIFO_HIGH_THRESHOLD;
+			iga2_display_queue_expire_num =
+			    P4M900_IGA2_DISPLAY_QUEUE_EXPIRE_NUM;
+		}
+
+		if (viaparinfo->chip_info->gfx_chip_name == UNICHROME_VX800) {
+			iga2_fifo_max_depth = VX800_IGA2_FIFO_MAX_DEPTH;
+			iga2_fifo_threshold = VX800_IGA2_FIFO_THRESHOLD;
+			iga2_fifo_high_threshold =
+			    VX800_IGA2_FIFO_HIGH_THRESHOLD;
+			iga2_display_queue_expire_num =
+			    VX800_IGA2_DISPLAY_QUEUE_EXPIRE_NUM;
+		}
+
+		if (viaparinfo->chip_info->gfx_chip_name == UNICHROME_K800) {
+			/* Set Display FIFO Depath Select */
+			reg_value =
+			    IGA2_FIFO_DEPTH_SELECT_FORMULA(iga2_fifo_max_depth)
+			    - 1;
+			/* Patch LCD in IGA2 case */
+			viafb_load_reg_num =
+			    display_fifo_depth_reg.
+			    iga2_fifo_depth_select_reg.reg_num;
+			reg =
+			    display_fifo_depth_reg.
+			    iga2_fifo_depth_select_reg.reg;
+			viafb_load_reg(reg_value,
+				viafb_load_reg_num, reg, VIACR);
+		} else {
+
+			/* Set Display FIFO Depath Select */
+			reg_value =
+			    IGA2_FIFO_DEPTH_SELECT_FORMULA(iga2_fifo_max_depth);
+			viafb_load_reg_num =
+			    display_fifo_depth_reg.
+			    iga2_fifo_depth_select_reg.reg_num;
+			reg =
+			    display_fifo_depth_reg.
+			    iga2_fifo_depth_select_reg.reg;
+			viafb_load_reg(reg_value,
+				viafb_load_reg_num, reg, VIACR);
+		}
+
+		/* Set Display FIFO Threshold Select */
+		reg_value = IGA2_FIFO_THRESHOLD_FORMULA(iga2_fifo_threshold);
+		viafb_load_reg_num =
+		    fifo_threshold_select_reg.
+		    iga2_fifo_threshold_select_reg.reg_num;
+		reg =
+		    fifo_threshold_select_reg.
+		    iga2_fifo_threshold_select_reg.reg;
+		viafb_load_reg(reg_value, viafb_load_reg_num, reg, VIACR);
+
+		/* Set FIFO High Threshold Select */
+		reg_value =
+		    IGA2_FIFO_HIGH_THRESHOLD_FORMULA(iga2_fifo_high_threshold);
+		viafb_load_reg_num =
+		    fifo_high_threshold_select_reg.
+		    iga2_fifo_high_threshold_select_reg.reg_num;
+		reg =
+		    fifo_high_threshold_select_reg.
+		    iga2_fifo_high_threshold_select_reg.reg;
+		viafb_load_reg(reg_value, viafb_load_reg_num, reg, VIACR);
+
+		/* Set Display Queue Expire Num */
+		reg_value =
+		    IGA2_DISPLAY_QUEUE_EXPIRE_NUM_FORMULA
+		    (iga2_display_queue_expire_num);
+		viafb_load_reg_num =
+		    display_queue_expire_num_reg.
+		    iga2_display_queue_expire_num_reg.reg_num;
+		reg =
+		    display_queue_expire_num_reg.
+		    iga2_display_queue_expire_num_reg.reg;
+		viafb_load_reg(reg_value, viafb_load_reg_num, reg, VIACR);
+
+	}
+
+}
+
+u32 viafb_get_clk_value(int clk)
+{
+	int i;
+
+	for (i = 0; i < NUM_TOTAL_PLL_TABLE; i++) {
+		if (clk == pll_value[i].clk) {
+			switch (viaparinfo->chip_info->gfx_chip_name) {
+			case UNICHROME_CLE266:
+			case UNICHROME_K400:
+				return pll_value[i].cle266_pll;
+
+			case UNICHROME_K800:
+			case UNICHROME_PM800:
+			case UNICHROME_CN700:
+				return pll_value[i].k800_pll;
+
+			case UNICHROME_CX700:
+			case UNICHROME_K8M890:
+			case UNICHROME_P4M890:
+			case UNICHROME_P4M900:
+			case UNICHROME_VX800:
+				return pll_value[i].cx700_pll;
+			}
+		}
+	}
+
+	DEBUG_MSG(KERN_INFO "Can't find match PLL value\n\n");
+	return 0;
+}
+
+/* Set VCLK*/
+void viafb_set_vclock(u32 CLK, int set_iga)
+{
+	unsigned char RegTemp;
+
+	/* H.W. Reset : ON */
+	viafb_write_reg_mask(CR17, VIACR, 0x00, BIT7);
+
+	if ((set_iga == IGA1) || (set_iga == IGA1_IGA2)) {
+		/* Change D,N FOR VCLK */
+		switch (viaparinfo->chip_info->gfx_chip_name) {
+		case UNICHROME_CLE266:
+		case UNICHROME_K400:
+			viafb_write_reg(SR46, VIASR, CLK / 0x100);
+			viafb_write_reg(SR47, VIASR, CLK % 0x100);
+			break;
+
+		case UNICHROME_K800:
+		case UNICHROME_PM800:
+		case UNICHROME_CN700:
+		case UNICHROME_CX700:
+		case UNICHROME_K8M890:
+		case UNICHROME_P4M890:
+		case UNICHROME_P4M900:
+		case UNICHROME_VX800:
+			viafb_write_reg(SR44, VIASR, CLK / 0x10000);
+			DEBUG_MSG(KERN_INFO "\nSR44=%x", CLK / 0x10000);
+			viafb_write_reg(SR45, VIASR, (CLK & 0xFFFF) / 0x100);
+			DEBUG_MSG(KERN_INFO "\nSR45=%x",
+				  (CLK & 0xFFFF) / 0x100);
+			viafb_write_reg(SR46, VIASR, CLK % 0x100);
+			DEBUG_MSG(KERN_INFO "\nSR46=%x", CLK % 0x100);
+			break;
+		}
+	}
+
+	if ((set_iga == IGA2) || (set_iga == IGA1_IGA2)) {
+		/* Change D,N FOR LCK */
+		switch (viaparinfo->chip_info->gfx_chip_name) {
+		case UNICHROME_CLE266:
+		case UNICHROME_K400:
+			viafb_write_reg(SR44, VIASR, CLK / 0x100);
+			viafb_write_reg(SR45, VIASR, CLK % 0x100);
+			break;
+
+		case UNICHROME_K800:
+		case UNICHROME_PM800:
+		case UNICHROME_CN700:
+		case UNICHROME_CX700:
+		case UNICHROME_K8M890:
+		case UNICHROME_P4M890:
+		case UNICHROME_P4M900:
+		case UNICHROME_VX800:
+			viafb_write_reg(SR4A, VIASR, CLK / 0x10000);
+			viafb_write_reg(SR4B, VIASR, (CLK & 0xFFFF) / 0x100);
+			viafb_write_reg(SR4C, VIASR, CLK % 0x100);
+			break;
+		}
+	}
+
+	/* H.W. Reset : OFF */
+	viafb_write_reg_mask(CR17, VIACR, 0x80, BIT7);
+
+	/* Reset PLL */
+	if ((set_iga == IGA1) || (set_iga == IGA1_IGA2)) {
+		viafb_write_reg_mask(SR40, VIASR, 0x02, BIT1);
+		viafb_write_reg_mask(SR40, VIASR, 0x00, BIT1);
+	}
+
+	if ((set_iga == IGA2) || (set_iga == IGA1_IGA2)) {
+		viafb_write_reg_mask(SR40, VIASR, 0x01, BIT0);
+		viafb_write_reg_mask(SR40, VIASR, 0x00, BIT0);
+	}
+
+	/* Fire! */
+	RegTemp = inb(VIARMisc);
+	outb(RegTemp | (BIT2 + BIT3), VIAWMisc);
+}
+
+void viafb_load_crtc_timing(struct display_timing device_timing,
+	int set_iga)
+{
+	int i;
+	int viafb_load_reg_num = 0;
+	int reg_value = 0;
+	struct io_register *reg = NULL;
+
+	viafb_unlock_crt();
+
+	for (i = 0; i < 12; i++) {
+		if (set_iga == IGA1) {
+			switch (i) {
+			case H_TOTAL_INDEX:
+				reg_value =
+				    IGA1_HOR_TOTAL_FORMULA(device_timing.
+							   hor_total);
+				viafb_load_reg_num =
+					iga1_crtc_reg.hor_total.reg_num;
+				reg = iga1_crtc_reg.hor_total.reg;
+				break;
+			case H_ADDR_INDEX:
+				reg_value =
+				    IGA1_HOR_ADDR_FORMULA(device_timing.
+							  hor_addr);
+				viafb_load_reg_num =
+					iga1_crtc_reg.hor_addr.reg_num;
+				reg = iga1_crtc_reg.hor_addr.reg;
+				break;
+			case H_BLANK_START_INDEX:
+				reg_value =
+				    IGA1_HOR_BLANK_START_FORMULA
+				    (device_timing.hor_blank_start);
+				viafb_load_reg_num =
+				    iga1_crtc_reg.hor_blank_start.reg_num;
+				reg = iga1_crtc_reg.hor_blank_start.reg;
+				break;
+			case H_BLANK_END_INDEX:
+				reg_value =
+				    IGA1_HOR_BLANK_END_FORMULA
+				    (device_timing.hor_blank_start,
+				     device_timing.hor_blank_end);
+				viafb_load_reg_num =
+				    iga1_crtc_reg.hor_blank_end.reg_num;
+				reg = iga1_crtc_reg.hor_blank_end.reg;
+				break;
+			case H_SYNC_START_INDEX:
+				reg_value =
+				    IGA1_HOR_SYNC_START_FORMULA
+				    (device_timing.hor_sync_start);
+				viafb_load_reg_num =
+				    iga1_crtc_reg.hor_sync_start.reg_num;
+				reg = iga1_crtc_reg.hor_sync_start.reg;
+				break;
+			case H_SYNC_END_INDEX:
+				reg_value =
+				    IGA1_HOR_SYNC_END_FORMULA
+				    (device_timing.hor_sync_start,
+				     device_timing.hor_sync_end);
+				viafb_load_reg_num =
+				    iga1_crtc_reg.hor_sync_end.reg_num;
+				reg = iga1_crtc_reg.hor_sync_end.reg;
+				break;
+			case V_TOTAL_INDEX:
+				reg_value =
+				    IGA1_VER_TOTAL_FORMULA(device_timing.
+							   ver_total);
+				viafb_load_reg_num =
+					iga1_crtc_reg.ver_total.reg_num;
+				reg = iga1_crtc_reg.ver_total.reg;
+				break;
+			case V_ADDR_INDEX:
+				reg_value =
+				    IGA1_VER_ADDR_FORMULA(device_timing.
+							  ver_addr);
+				viafb_load_reg_num =
+					iga1_crtc_reg.ver_addr.reg_num;
+				reg = iga1_crtc_reg.ver_addr.reg;
+				break;
+			case V_BLANK_START_INDEX:
+				reg_value =
+				    IGA1_VER_BLANK_START_FORMULA
+				    (device_timing.ver_blank_start);
+				viafb_load_reg_num =
+				    iga1_crtc_reg.ver_blank_start.reg_num;
+				reg = iga1_crtc_reg.ver_blank_start.reg;
+				break;
+			case V_BLANK_END_INDEX:
+				reg_value =
+				    IGA1_VER_BLANK_END_FORMULA
+				    (device_timing.ver_blank_start,
+				     device_timing.ver_blank_end);
+				viafb_load_reg_num =
+				    iga1_crtc_reg.ver_blank_end.reg_num;
+				reg = iga1_crtc_reg.ver_blank_end.reg;
+				break;
+			case V_SYNC_START_INDEX:
+				reg_value =
+				    IGA1_VER_SYNC_START_FORMULA
+				    (device_timing.ver_sync_start);
+				viafb_load_reg_num =
+				    iga1_crtc_reg.ver_sync_start.reg_num;
+				reg = iga1_crtc_reg.ver_sync_start.reg;
+				break;
+			case V_SYNC_END_INDEX:
+				reg_value =
+				    IGA1_VER_SYNC_END_FORMULA
+				    (device_timing.ver_sync_start,
+				     device_timing.ver_sync_end);
+				viafb_load_reg_num =
+				    iga1_crtc_reg.ver_sync_end.reg_num;
+				reg = iga1_crtc_reg.ver_sync_end.reg;
+				break;
+
+			}
+		}
+
+		if (set_iga == IGA2) {
+			switch (i) {
+			case H_TOTAL_INDEX:
+				reg_value =
+				    IGA2_HOR_TOTAL_FORMULA(device_timing.
+							   hor_total);
+				viafb_load_reg_num =
+					iga2_crtc_reg.hor_total.reg_num;
+				reg = iga2_crtc_reg.hor_total.reg;
+				break;
+			case H_ADDR_INDEX:
+				reg_value =
+				    IGA2_HOR_ADDR_FORMULA(device_timing.
+							  hor_addr);
+				viafb_load_reg_num =
+					iga2_crtc_reg.hor_addr.reg_num;
+				reg = iga2_crtc_reg.hor_addr.reg;
+				break;
+			case H_BLANK_START_INDEX:
+				reg_value =
+				    IGA2_HOR_BLANK_START_FORMULA
+				    (device_timing.hor_blank_start);
+				viafb_load_reg_num =
+				    iga2_crtc_reg.hor_blank_start.reg_num;
+				reg = iga2_crtc_reg.hor_blank_start.reg;
+				break;
+			case H_BLANK_END_INDEX:
+				reg_value =
+				    IGA2_HOR_BLANK_END_FORMULA
+				    (device_timing.hor_blank_start,
+				     device_timing.hor_blank_end);
+				viafb_load_reg_num =
+				    iga2_crtc_reg.hor_blank_end.reg_num;
+				reg = iga2_crtc_reg.hor_blank_end.reg;
+				break;
+			case H_SYNC_START_INDEX:
+				reg_value =
+				    IGA2_HOR_SYNC_START_FORMULA
+				    (device_timing.hor_sync_start);
+				if (UNICHROME_CN700 <=
+					viaparinfo->chip_info->gfx_chip_name)
+					viafb_load_reg_num =
+					    iga2_crtc_reg.hor_sync_start.
+					    reg_num;
+				else
+					viafb_load_reg_num = 3;
+				reg = iga2_crtc_reg.hor_sync_start.reg;
+				break;
+			case H_SYNC_END_INDEX:
+				reg_value =
+				    IGA2_HOR_SYNC_END_FORMULA
+				    (device_timing.hor_sync_start,
+				     device_timing.hor_sync_end);
+				viafb_load_reg_num =
+				    iga2_crtc_reg.hor_sync_end.reg_num;
+				reg = iga2_crtc_reg.hor_sync_end.reg;
+				break;
+			case V_TOTAL_INDEX:
+				reg_value =
+				    IGA2_VER_TOTAL_FORMULA(device_timing.
+							   ver_total);
+				viafb_load_reg_num =
+					iga2_crtc_reg.ver_total.reg_num;
+				reg = iga2_crtc_reg.ver_total.reg;
+				break;
+			case V_ADDR_INDEX:
+				reg_value =
+				    IGA2_VER_ADDR_FORMULA(device_timing.
+							  ver_addr);
+				viafb_load_reg_num =
+					iga2_crtc_reg.ver_addr.reg_num;
+				reg = iga2_crtc_reg.ver_addr.reg;
+				break;
+			case V_BLANK_START_INDEX:
+				reg_value =
+				    IGA2_VER_BLANK_START_FORMULA
+				    (device_timing.ver_blank_start);
+				viafb_load_reg_num =
+				    iga2_crtc_reg.ver_blank_start.reg_num;
+				reg = iga2_crtc_reg.ver_blank_start.reg;
+				break;
+			case V_BLANK_END_INDEX:
+				reg_value =
+				    IGA2_VER_BLANK_END_FORMULA
+				    (device_timing.ver_blank_start,
+				     device_timing.ver_blank_end);
+				viafb_load_reg_num =
+				    iga2_crtc_reg.ver_blank_end.reg_num;
+				reg = iga2_crtc_reg.ver_blank_end.reg;
+				break;
+			case V_SYNC_START_INDEX:
+				reg_value =
+				    IGA2_VER_SYNC_START_FORMULA
+				    (device_timing.ver_sync_start);
+				viafb_load_reg_num =
+				    iga2_crtc_reg.ver_sync_start.reg_num;
+				reg = iga2_crtc_reg.ver_sync_start.reg;
+				break;
+			case V_SYNC_END_INDEX:
+				reg_value =
+				    IGA2_VER_SYNC_END_FORMULA
+				    (device_timing.ver_sync_start,
+				     device_timing.ver_sync_end);
+				viafb_load_reg_num =
+				    iga2_crtc_reg.ver_sync_end.reg_num;
+				reg = iga2_crtc_reg.ver_sync_end.reg;
+				break;
+
+			}
+		}
+		viafb_load_reg(reg_value, viafb_load_reg_num, reg, VIACR);
+	}
+
+	viafb_lock_crt();
+}
+
+void viafb_set_color_depth(int bpp_byte, int set_iga)
+{
+	if (set_iga == IGA1) {
+		switch (bpp_byte) {
+		case MODE_8BPP:
+			viafb_write_reg_mask(SR15, VIASR, 0x22, 0x7E);
+			break;
+		case MODE_16BPP:
+			viafb_write_reg_mask(SR15, VIASR, 0xB6, 0xFE);
+			break;
+		case MODE_32BPP:
+			viafb_write_reg_mask(SR15, VIASR, 0xAE, 0xFE);
+			break;
+		}
+	} else {
+		switch (bpp_byte) {
+		case MODE_8BPP:
+			viafb_write_reg_mask(CR67, VIACR, 0x00, BIT6 + BIT7);
+			break;
+		case MODE_16BPP:
+			viafb_write_reg_mask(CR67, VIACR, 0x40, BIT6 + BIT7);
+			break;
+		case MODE_32BPP:
+			viafb_write_reg_mask(CR67, VIACR, 0xC0, BIT6 + BIT7);
+			break;
+		}
+	}
+}
+
+void viafb_fill_crtc_timing(struct crt_mode_table *crt_table,
+	int mode_index, int bpp_byte, int set_iga)
+{
+	struct VideoModeTable *video_mode;
+	struct display_timing crt_reg;
+	int i;
+	int index = 0;
+	int h_addr, v_addr;
+	u32 pll_D_N;
+
+	video_mode = &CLE266Modes[search_mode_setting(mode_index)];
+
+	for (i = 0; i < video_mode->mode_array; i++) {
+		index = i;
+
+		if (crt_table[i].refresh_rate == viaparinfo->
+			crt_setting_info->refresh_rate)
+			break;
+	}
+
+	crt_reg = crt_table[index].crtc;
+
+	/* Mode 640x480 has border, but LCD/DFP didn't have border. */
+	/* So we would delete border. */
+	if ((viafb_LCD_ON | viafb_DVI_ON) && (mode_index == VIA_RES_640X480)
+	    && (viaparinfo->crt_setting_info->refresh_rate == 60)) {
+		/* The border is 8 pixels. */
+		crt_reg.hor_blank_start = crt_reg.hor_blank_start - 8;
+
+		/* Blanking time should add left and right borders. */
+		crt_reg.hor_blank_end = crt_reg.hor_blank_end + 16;
+	}
+
+	h_addr = crt_reg.hor_addr;
+	v_addr = crt_reg.ver_addr;
+
+	/* update polarity for CRT timing */
+	if (crt_table[index].h_sync_polarity == NEGATIVE) {
+		if (crt_table[index].v_sync_polarity == NEGATIVE)
+			outb((inb(VIARMisc) & (~(BIT6 + BIT7))) |
+			     (BIT6 + BIT7), VIAWMisc);
+		else
+			outb((inb(VIARMisc) & (~(BIT6 + BIT7))) | (BIT6),
+			     VIAWMisc);
+	} else {
+		if (crt_table[index].v_sync_polarity == NEGATIVE)
+			outb((inb(VIARMisc) & (~(BIT6 + BIT7))) | (BIT7),
+			     VIAWMisc);
+		else
+			outb((inb(VIARMisc) & (~(BIT6 + BIT7))), VIAWMisc);
+	}
+
+	if (set_iga == IGA1) {
+		viafb_unlock_crt();
+		viafb_write_reg(CR09, VIACR, 0x00);	/*initial CR09=0 */
+		viafb_write_reg_mask(CR11, VIACR, 0x00, BIT4 + BIT5 + BIT6);
+		viafb_write_reg_mask(CR17, VIACR, 0x00, BIT7);
+	}
+
+	switch (set_iga) {
+	case IGA1:
+		viafb_load_crtc_timing(crt_reg, IGA1);
+		break;
+	case IGA2:
+		viafb_load_crtc_timing(crt_reg, IGA2);
+		break;
+	}
+
+	load_fix_bit_crtc_reg();
+	viafb_lock_crt();
+	viafb_write_reg_mask(CR17, VIACR, 0x80, BIT7);
+	viafb_load_offset_reg(h_addr, bpp_byte, set_iga);
+	viafb_load_fetch_count_reg(h_addr, bpp_byte, set_iga);
+
+	/* load FIFO */
+	if ((viaparinfo->chip_info->gfx_chip_name != UNICHROME_CLE266)
+	    && (viaparinfo->chip_info->gfx_chip_name != UNICHROME_K400))
+		viafb_load_FIFO_reg(set_iga, h_addr, v_addr);
+
+	/* load SR Register About Memory and Color part */
+	viafb_set_color_depth(bpp_byte, set_iga);
+
+	pll_D_N = viafb_get_clk_value(crt_table[index].clk);
+	DEBUG_MSG(KERN_INFO "PLL=%x", pll_D_N);
+	viafb_set_vclock(pll_D_N, set_iga);
+
+}
+
+void viafb_init_chip_info(void)
+{
+	init_gfx_chip_info();
+	init_tmds_chip_info();
+	init_lvds_chip_info();
+
+	viaparinfo->crt_setting_info->iga_path = IGA1;
+	viaparinfo->crt_setting_info->refresh_rate = viafb_refresh;
+
+	/*Set IGA path for each device */
+	viafb_set_iga_path();
+
+	viaparinfo->lvds_setting_info->display_method = viafb_lcd_dsp_method;
+	viaparinfo->lvds_setting_info->get_lcd_size_method =
+		GET_LCD_SIZE_BY_USER_SETTING;
+	viaparinfo->lvds_setting_info->lcd_mode = viafb_lcd_mode;
+	viaparinfo->lvds_setting_info2->display_method =
+		viaparinfo->lvds_setting_info->display_method;
+	viaparinfo->lvds_setting_info2->lcd_mode =
+		viaparinfo->lvds_setting_info->lcd_mode;
+}
+
+void viafb_update_device_setting(int hres, int vres,
+	int bpp, int vmode_refresh, int flag)
+{
+	if (flag == 0) {
+		viaparinfo->crt_setting_info->h_active = hres;
+		viaparinfo->crt_setting_info->v_active = vres;
+		viaparinfo->crt_setting_info->bpp = bpp;
+		viaparinfo->crt_setting_info->refresh_rate =
+			vmode_refresh;
+
+		viaparinfo->tmds_setting_info->h_active = hres;
+		viaparinfo->tmds_setting_info->v_active = vres;
+		viaparinfo->tmds_setting_info->bpp = bpp;
+		viaparinfo->tmds_setting_info->refresh_rate =
+			vmode_refresh;
+
+		viaparinfo->lvds_setting_info->h_active = hres;
+		viaparinfo->lvds_setting_info->v_active = vres;
+		viaparinfo->lvds_setting_info->bpp = bpp;
+		viaparinfo->lvds_setting_info->refresh_rate =
+			vmode_refresh;
+		viaparinfo->lvds_setting_info2->h_active = hres;
+		viaparinfo->lvds_setting_info2->v_active = vres;
+		viaparinfo->lvds_setting_info2->bpp = bpp;
+		viaparinfo->lvds_setting_info2->refresh_rate =
+			vmode_refresh;
+	} else {
+
+		if (viaparinfo->tmds_setting_info->iga_path == IGA2) {
+			viaparinfo->tmds_setting_info->h_active = hres;
+			viaparinfo->tmds_setting_info->v_active = vres;
+			viaparinfo->tmds_setting_info->bpp = bpp;
+			viaparinfo->tmds_setting_info->refresh_rate =
+				vmode_refresh;
+		}
+
+		if (viaparinfo->lvds_setting_info->iga_path == IGA2) {
+			viaparinfo->lvds_setting_info->h_active = hres;
+			viaparinfo->lvds_setting_info->v_active = vres;
+			viaparinfo->lvds_setting_info->bpp = bpp;
+			viaparinfo->lvds_setting_info->refresh_rate =
+				vmode_refresh;
+		}
+		if (IGA2 == viaparinfo->lvds_setting_info2->iga_path) {
+			viaparinfo->lvds_setting_info2->h_active = hres;
+			viaparinfo->lvds_setting_info2->v_active = vres;
+			viaparinfo->lvds_setting_info2->bpp = bpp;
+			viaparinfo->lvds_setting_info2->refresh_rate =
+				vmode_refresh;
+		}
+	}
+}
+
+static void init_gfx_chip_info(void)
+{
+	struct pci_dev *pdev = NULL;
+	u32 i;
+	u8 tmp;
+
+	/* Indentify GFX Chip Name */
+	for (i = 0; pciidlist[i].vendor != 0; i++) {
+		pdev = pci_get_device(pciidlist[i].vendor,
+			pciidlist[i].device, 0);
+		if (pdev)
+			break;
+	}
+
+	if (!pciidlist[i].vendor)
+		return ;
+
+	viaparinfo->chip_info->gfx_chip_name = pciidlist[i].chip_index;
+
+	/* Check revision of CLE266 Chip */
+	if (viaparinfo->chip_info->gfx_chip_name == UNICHROME_CLE266) {
+		/* CR4F only define in CLE266.CX chip */
+		tmp = viafb_read_reg(VIACR, CR4F);
+		viafb_write_reg(CR4F, VIACR, 0x55);
+		if (viafb_read_reg(VIACR, CR4F) != 0x55)
+			viaparinfo->chip_info->gfx_chip_revision =
+			CLE266_REVISION_AX;
+		else
+			viaparinfo->chip_info->gfx_chip_revision =
+			CLE266_REVISION_CX;
+		/* restore orignal CR4F value */
+		viafb_write_reg(CR4F, VIACR, tmp);
+	}
+
+	if (viaparinfo->chip_info->gfx_chip_name == UNICHROME_CX700) {
+		tmp = viafb_read_reg(VIASR, SR43);
+		DEBUG_MSG(KERN_INFO "SR43:%X\n", tmp);
+		if (tmp & 0x02) {
+			viaparinfo->chip_info->gfx_chip_revision =
+				CX700_REVISION_700M2;
+		} else if (tmp & 0x40) {
+			viaparinfo->chip_info->gfx_chip_revision =
+				CX700_REVISION_700M;
+		} else {
+			viaparinfo->chip_info->gfx_chip_revision =
+				CX700_REVISION_700;
+		}
+	}
+
+	pci_dev_put(pdev);
+}
+
+static void init_tmds_chip_info(void)
+{
+	viafb_tmds_trasmitter_identify();
+
+	if (INTERFACE_NONE == viaparinfo->chip_info->tmds_chip_info.
+		output_interface) {
+		switch (viaparinfo->chip_info->gfx_chip_name) {
+		case UNICHROME_CX700:
+			{
+				/* we should check support by hardware layout.*/
+				if ((viafb_display_hardware_layout ==
+				     HW_LAYOUT_DVI_ONLY)
+				    || (viafb_display_hardware_layout ==
+					HW_LAYOUT_LCD_DVI)) {
+					viaparinfo->chip_info->tmds_chip_info.
+					    output_interface = INTERFACE_TMDS;
+				} else {
+					viaparinfo->chip_info->tmds_chip_info.
+						output_interface =
+						INTERFACE_NONE;
+				}
+				break;
+			}
+		case UNICHROME_K8M890:
+		case UNICHROME_P4M900:
+		case UNICHROME_P4M890:
+			/* TMDS on PCIE, we set DFPLOW as default. */
+			viaparinfo->chip_info->tmds_chip_info.output_interface =
+			    INTERFACE_DFP_LOW;
+			break;
+		default:
+			{
+				/* set DVP1 default for DVI */
+				viaparinfo->chip_info->tmds_chip_info
+				.output_interface = INTERFACE_DVP1;
+			}
+		}
+	}
+
+	DEBUG_MSG(KERN_INFO "TMDS Chip = %d\n",
+		  viaparinfo->chip_info->tmds_chip_info.tmds_chip_name);
+	viaparinfo->tmds_setting_info->get_dvi_size_method =
+		GET_DVI_SIZE_BY_VGA_BIOS;
+	viafb_init_dvi_size();
+}
+
+static void init_lvds_chip_info(void)
+{
+	if (viafb_lcd_panel_id > LCD_PANEL_ID_MAXIMUM)
+		viaparinfo->lvds_setting_info->get_lcd_size_method =
+		    GET_LCD_SIZE_BY_VGA_BIOS;
+	else
+		viaparinfo->lvds_setting_info->get_lcd_size_method =
+		    GET_LCD_SIZE_BY_USER_SETTING;
+
+	viafb_lvds_trasmitter_identify();
+	viafb_init_lcd_size();
+	viafb_init_lvds_output_interface(&viaparinfo->chip_info->lvds_chip_info,
+				   viaparinfo->lvds_setting_info);
+	if (viaparinfo->chip_info->lvds_chip_info2.lvds_chip_name) {
+		viafb_init_lvds_output_interface(&viaparinfo->chip_info->
+			lvds_chip_info2, viaparinfo->lvds_setting_info2);
+	}
+	/*If CX700,two singel LCD, we need to reassign
+	   LCD interface to different LVDS port */
+	if ((UNICHROME_CX700 == viaparinfo->chip_info->gfx_chip_name)
+	    && (HW_LAYOUT_LCD1_LCD2 == viafb_display_hardware_layout)) {
+		if ((INTEGRATED_LVDS == viaparinfo->chip_info->lvds_chip_info.
+			lvds_chip_name) && (INTEGRATED_LVDS ==
+			viaparinfo->chip_info->
+			lvds_chip_info2.lvds_chip_name)) {
+			viaparinfo->chip_info->lvds_chip_info.output_interface =
+				INTERFACE_LVDS0;
+			viaparinfo->chip_info->lvds_chip_info2.
+				output_interface =
+			    INTERFACE_LVDS1;
+		}
+	}
+
+	DEBUG_MSG(KERN_INFO "LVDS Chip = %d\n",
+		  viaparinfo->chip_info->lvds_chip_info.lvds_chip_name);
+	DEBUG_MSG(KERN_INFO "LVDS1 output_interface = %d\n",
+		  viaparinfo->chip_info->lvds_chip_info.output_interface);
+	DEBUG_MSG(KERN_INFO "LVDS2 output_interface = %d\n",
+		  viaparinfo->chip_info->lvds_chip_info.output_interface);
+}
+
+void viafb_init_dac(int set_iga)
+{
+	int i;
+	u8 tmp;
+
+	if (set_iga == IGA1) {
+		/* access Primary Display's LUT */
+		viafb_write_reg_mask(SR1A, VIASR, 0x00, BIT0);
+		/* turn off LCK */
+		viafb_write_reg_mask(SR1B, VIASR, 0x00, BIT7 + BIT6);
+		for (i = 0; i < 256; i++) {
+			write_dac_reg(i, palLUT_table[i].red,
+				      palLUT_table[i].green,
+				      palLUT_table[i].blue);
+		}
+		/* turn on LCK */
+		viafb_write_reg_mask(SR1B, VIASR, 0xC0, BIT7 + BIT6);
+	} else {
+		tmp = viafb_read_reg(VIACR, CR6A);
+		/* access Secondary Display's LUT */
+		viafb_write_reg_mask(CR6A, VIACR, 0x40, BIT6);
+		viafb_write_reg_mask(SR1A, VIASR, 0x01, BIT0);
+		for (i = 0; i < 256; i++) {
+			write_dac_reg(i, palLUT_table[i].red,
+				      palLUT_table[i].green,
+				      palLUT_table[i].blue);
+		}
+		/* set IGA1 DAC for default */
+		viafb_write_reg_mask(SR1A, VIASR, 0x00, BIT0);
+		viafb_write_reg(CR6A, VIACR, tmp);
+	}
+}
+
+static void device_screen_off(void)
+{
+	/* turn off CRT screen (IGA1) */
+	viafb_write_reg_mask(SR01, VIASR, 0x20, BIT5);
+}
+
+static void device_screen_on(void)
+{
+	/* turn on CRT screen (IGA1) */
+	viafb_write_reg_mask(SR01, VIASR, 0x00, BIT5);
+}
+
+static void set_display_channel(void)
+{
+	/*If viafb_LCD2_ON, on cx700, internal lvds's information
+	is keeped on lvds_setting_info2 */
+	if (viafb_LCD2_ON &&
+		viaparinfo->lvds_setting_info2->device_lcd_dualedge) {
+		/* For dual channel LCD: */
+		/* Set to Dual LVDS channel. */
+		viafb_write_reg_mask(CRD2, VIACR, 0x20, BIT4 + BIT5);
+	} else if (viafb_LCD_ON && viafb_DVI_ON) {
+		/* For LCD+DFP: */
+		/* Set to LVDS1 + TMDS channel. */
+		viafb_write_reg_mask(CRD2, VIACR, 0x10, BIT4 + BIT5);
+	} else if (viafb_DVI_ON) {
+		/* Set to single TMDS channel. */
+		viafb_write_reg_mask(CRD2, VIACR, 0x30, BIT4 + BIT5);
+	} else if (viafb_LCD_ON) {
+		if (viaparinfo->lvds_setting_info->device_lcd_dualedge) {
+			/* For dual channel LCD: */
+			/* Set to Dual LVDS channel. */
+			viafb_write_reg_mask(CRD2, VIACR, 0x20, BIT4 + BIT5);
+		} else {
+			/* Set to LVDS0 + LVDS1 channel. */
+			viafb_write_reg_mask(CRD2, VIACR, 0x00, BIT4 + BIT5);
+		}
+	}
+}
+
+int viafb_setmode(int vmode_index, int hor_res, int ver_res, int video_bpp,
+	int vmode_index1, int hor_res1, int ver_res1, int video_bpp1)
+{
+	int i, j;
+	int port;
+	u8 value, index, mask;
+	struct VideoModeTable *vmode_tbl;
+	struct crt_mode_table *crt_timing;
+	struct VideoModeTable *vmode_tbl1 = NULL;
+	struct crt_mode_table *crt_timing1 = NULL;
+
+	DEBUG_MSG(KERN_INFO "Set Mode!!\n");
+	DEBUG_MSG(KERN_INFO
+		  "vmode_index=%d hor_res=%d ver_res=%d video_bpp=%d\n",
+		  vmode_index, hor_res, ver_res, video_bpp);
+
+	device_screen_off();
+	vmode_tbl = &CLE266Modes[search_mode_setting(vmode_index)];
+	crt_timing = vmode_tbl->crtc;
+
+	if (viafb_SAMM_ON == 1) {
+		vmode_tbl1 = &CLE266Modes[search_mode_setting(vmode_index1)];
+		crt_timing1 = vmode_tbl1->crtc;
+	}
+
+	inb(VIAStatus);
+	outb(0x00, VIAAR);
+
+	/* Write Common Setting for Video Mode */
+	switch (viaparinfo->chip_info->gfx_chip_name) {
+	case UNICHROME_CLE266:
+		viafb_write_regx(CLE266_ModeXregs, NUM_TOTAL_CLE266_ModeXregs);
+		break;
+
+	case UNICHROME_K400:
+		viafb_write_regx(KM400_ModeXregs, NUM_TOTAL_KM400_ModeXregs);
+		break;
+
+	case UNICHROME_K800:
+	case UNICHROME_PM800:
+		viafb_write_regx(CN400_ModeXregs, NUM_TOTAL_CN400_ModeXregs);
+		break;
+
+	case UNICHROME_CN700:
+	case UNICHROME_K8M890:
+	case UNICHROME_P4M890:
+	case UNICHROME_P4M900:
+		viafb_write_regx(CN700_ModeXregs, NUM_TOTAL_CN700_ModeXregs);
+		break;
+
+	case UNICHROME_CX700:
+		viafb_write_regx(CX700_ModeXregs, NUM_TOTAL_CX700_ModeXregs);
+
+	case UNICHROME_VX800:
+		viafb_write_regx(VX800_ModeXregs, NUM_TOTAL_VX800_ModeXregs);
+
+		break;
+	}
+
+	device_off();
+
+	/* Fill VPIT Parameters */
+	/* Write Misc Register */
+	outb(VPIT.Misc, VIAWMisc);
+
+	/* Write Sequencer */
+	for (i = 1; i <= StdSR; i++) {
+		outb(i, VIASR);
+		outb(VPIT.SR[i - 1], VIASR + 1);
+	}
+
+	viafb_set_start_addr();
+	viafb_set_iga_path();
+
+	/* Write CRTC */
+	viafb_fill_crtc_timing(crt_timing, vmode_index, video_bpp / 8, IGA1);
+
+	/* Write Graphic Controller */
+	for (i = 0; i < StdGR; i++) {
+		outb(i, VIAGR);
+		outb(VPIT.GR[i], VIAGR + 1);
+	}
+
+	/* Write Attribute Controller */
+	for (i = 0; i < StdAR; i++) {
+		inb(VIAStatus);
+		outb(i, VIAAR);
+		outb(VPIT.AR[i], VIAAR);
+	}
+
+	inb(VIAStatus);
+	outb(0x20, VIAAR);
+
+	/* Update Patch Register */
+
+	if ((viaparinfo->chip_info->gfx_chip_name == UNICHROME_CLE266)
+	    || (viaparinfo->chip_info->gfx_chip_name == UNICHROME_K400)) {
+		for (i = 0; i < NUM_TOTAL_PATCH_MODE; i++) {
+			if (res_patch_table[i].mode_index == vmode_index) {
+				for (j = 0;
+				     j < res_patch_table[i].table_length; j++) {
+					index =
+					    res_patch_table[i].
+					    io_reg_table[j].index;
+					port =
+					    res_patch_table[i].
+					    io_reg_table[j].port;
+					value =
+					    res_patch_table[i].
+					    io_reg_table[j].value;
+					mask =
+					    res_patch_table[i].
+					    io_reg_table[j].mask;
+					viafb_write_reg_mask(index, port, value,
+						       mask);
+				}
+			}
+		}
+	}
+
+	if (viafb_SAMM_ON == 1) {
+		if ((viaparinfo->chip_info->gfx_chip_name == UNICHROME_CLE266)
+		    || (viaparinfo->chip_info->gfx_chip_name ==
+		    UNICHROME_K400)) {
+			for (i = 0; i < NUM_TOTAL_PATCH_MODE; i++) {
+				if (res_patch_table[i].mode_index ==
+				    vmode_index1) {
+					for (j = 0;
+					     j <
+					     res_patch_table[i].
+					     table_length; j++) {
+						index =
+						    res_patch_table[i].
+						    io_reg_table[j].index;
+						port =
+						    res_patch_table[i].
+						    io_reg_table[j].port;
+						value =
+						    res_patch_table[i].
+						    io_reg_table[j].value;
+						mask =
+						    res_patch_table[i].
+						    io_reg_table[j].mask;
+						viafb_write_reg_mask(index,
+							port, value, mask);
+					}
+				}
+			}
+		}
+	}
+
+	/* Update Refresh Rate Setting */
+
+	/* Clear On Screen */
+
+	/* CRT set mode */
+	if (viafb_CRT_ON) {
+		if (viafb_SAMM_ON && (viaparinfo->crt_setting_info->iga_path ==
+			IGA2)) {
+			viafb_fill_crtc_timing(crt_timing1, vmode_index1,
+				video_bpp1 / 8,
+				viaparinfo->crt_setting_info->iga_path);
+		} else {
+			viafb_fill_crtc_timing(crt_timing, vmode_index,
+				video_bpp / 8,
+				viaparinfo->crt_setting_info->iga_path);
+		}
+
+		set_crt_output_path(viaparinfo->crt_setting_info->iga_path);
+
+		/* Patch if set_hres is not 8 alignment (1366) to viafb_setmode
+		to 8 alignment (1368),there is several pixels (2 pixels)
+		on right side of screen. */
+		if (hor_res % 8) {
+			viafb_unlock_crt();
+			viafb_write_reg(CR02, VIACR,
+				viafb_read_reg(VIACR, CR02) - 1);
+			viafb_lock_crt();
+		}
+	}
+
+	if (viafb_DVI_ON) {
+		if (viafb_SAMM_ON &&
+			(viaparinfo->tmds_setting_info->iga_path == IGA2)) {
+			viafb_dvi_set_mode(viafb_get_mode_index
+				     (viaparinfo->tmds_setting_info->h_active,
+				      viaparinfo->tmds_setting_info->
+				      v_active, 1),
+				     video_bpp1, viaparinfo->
+				     tmds_setting_info->iga_path);
+		} else {
+			viafb_dvi_set_mode(viafb_get_mode_index
+				     (viaparinfo->tmds_setting_info->h_active,
+				      viaparinfo->
+				      tmds_setting_info->v_active, 0),
+				     video_bpp, viaparinfo->
+				     tmds_setting_info->iga_path);
+		}
+	}
+
+	if (viafb_LCD_ON) {
+		if (viafb_SAMM_ON &&
+			(viaparinfo->lvds_setting_info->iga_path == IGA2)) {
+			viaparinfo->lvds_setting_info->bpp = video_bpp1;
+			viafb_lcd_set_mode(crt_timing1, viaparinfo->
+				lvds_setting_info,
+				     &viaparinfo->chip_info->lvds_chip_info);
+		} else {
+			/* IGA1 doesn't have LCD scaling, so set it center. */
+			if (viaparinfo->lvds_setting_info->iga_path == IGA1) {
+				viaparinfo->lvds_setting_info->display_method =
+				    LCD_CENTERING;
+			}
+			viaparinfo->lvds_setting_info->bpp = video_bpp;
+			viafb_lcd_set_mode(crt_timing, viaparinfo->
+				lvds_setting_info,
+				     &viaparinfo->chip_info->lvds_chip_info);
+		}
+	}
+	if (viafb_LCD2_ON) {
+		if (viafb_SAMM_ON &&
+			(viaparinfo->lvds_setting_info2->iga_path == IGA2)) {
+			viaparinfo->lvds_setting_info2->bpp = video_bpp1;
+			viafb_lcd_set_mode(crt_timing1, viaparinfo->
+				lvds_setting_info2,
+				     &viaparinfo->chip_info->lvds_chip_info2);
+		} else {
+			/* IGA1 doesn't have LCD scaling, so set it center. */
+			if (viaparinfo->lvds_setting_info2->iga_path == IGA1) {
+				viaparinfo->lvds_setting_info2->display_method =
+				    LCD_CENTERING;
+			}
+			viaparinfo->lvds_setting_info2->bpp = video_bpp;
+			viafb_lcd_set_mode(crt_timing, viaparinfo->
+				lvds_setting_info2,
+				     &viaparinfo->chip_info->lvds_chip_info2);
+		}
+	}
+
+	if ((viaparinfo->chip_info->gfx_chip_name == UNICHROME_CX700)
+	    && (viafb_LCD_ON || viafb_DVI_ON))
+		set_display_channel();
+
+	/* If set mode normally, save resolution information for hot-plug . */
+	if (!viafb_hotplug) {
+		viafb_hotplug_Xres = hor_res;
+		viafb_hotplug_Yres = ver_res;
+		viafb_hotplug_bpp = video_bpp;
+		viafb_hotplug_refresh = viafb_refresh;
+
+		if (viafb_DVI_ON)
+			viafb_DeviceStatus = DVI_Device;
+		else
+			viafb_DeviceStatus = CRT_Device;
+	}
+	device_on();
+
+	if (viafb_SAMM_ON == 1)
+		viafb_write_reg_mask(CR6A, VIACR, 0xC0, BIT6 + BIT7);
+
+	device_screen_on();
+	return 1;
+}
+
+int viafb_get_pixclock(int hres, int vres, int vmode_refresh)
+{
+	int i;
+
+	for (i = 0; i < NUM_TOTAL_RES_MAP_REFRESH; i++) {
+		if ((hres == res_map_refresh_tbl[i].hres)
+		    && (vres == res_map_refresh_tbl[i].vres)
+		    && (vmode_refresh == res_map_refresh_tbl[i].vmode_refresh))
+			return res_map_refresh_tbl[i].pixclock;
+	}
+	return RES_640X480_60HZ_PIXCLOCK;
+
+}
+
+int viafb_get_refresh(int hres, int vres, u32 long_refresh)
+{
+#define REFRESH_TOLERANCE 3
+	int i, nearest = -1, diff = REFRESH_TOLERANCE;
+	for (i = 0; i < NUM_TOTAL_RES_MAP_REFRESH; i++) {
+		if ((hres == res_map_refresh_tbl[i].hres)
+		    && (vres == res_map_refresh_tbl[i].vres)
+		    && (diff > (abs(long_refresh -
+		    res_map_refresh_tbl[i].vmode_refresh)))) {
+			diff = abs(long_refresh - res_map_refresh_tbl[i].
+				vmode_refresh);
+			nearest = i;
+		}
+	}
+#undef REFRESH_TOLERANCE
+	if (nearest > 0)
+		return res_map_refresh_tbl[nearest].vmode_refresh;
+	return 60;
+}
+
+static void device_off(void)
+{
+	viafb_crt_disable();
+	viafb_dvi_disable();
+	viafb_lcd_disable();
+}
+
+static void device_on(void)
+{
+	if (viafb_CRT_ON == 1)
+		viafb_crt_enable();
+	if (viafb_DVI_ON == 1)
+		viafb_dvi_enable();
+	if (viafb_LCD_ON == 1)
+		viafb_lcd_enable();
+}
+
+void viafb_crt_disable(void)
+{
+	viafb_write_reg_mask(CR36, VIACR, BIT5 + BIT4, BIT5 + BIT4);
+}
+
+void viafb_crt_enable(void)
+{
+	viafb_write_reg_mask(CR36, VIACR, 0x0, BIT5 + BIT4);
+}
+
+void viafb_get_mmio_info(unsigned long *mmio_base,
+	unsigned long *mmio_len)
+{
+	struct pci_dev *pdev = NULL;
+	u32 vendor, device;
+	u32 i;
+
+	for (i = 0; pciidlist[i].vendor != 0; i++)
+		if (viaparinfo->chip_info->gfx_chip_name ==
+			pciidlist[i].chip_index)
+			break;
+
+	if (!pciidlist[i].vendor)
+		return ;
+
+	vendor = pciidlist[i].vendor;
+	device = pciidlist[i].device;
+
+	pdev = pci_get_device(vendor, device, NULL);
+
+	if (!pdev) {
+		*mmio_base = 0;
+		*mmio_len = 0;
+		return ;
+	}
+
+	*mmio_base = pci_resource_start(pdev, 1);
+	*mmio_len = pci_resource_len(pdev, 1);
+
+	pci_dev_put(pdev);
+}
+
+static void enable_second_display_channel(void)
+{
+	/* to enable second display channel. */
+	viafb_write_reg_mask(CR6A, VIACR, 0x00, BIT6);
+	viafb_write_reg_mask(CR6A, VIACR, BIT7, BIT7);
+	viafb_write_reg_mask(CR6A, VIACR, BIT6, BIT6);
+}
+
+static void disable_second_display_channel(void)
+{
+	/* to disable second display channel. */
+	viafb_write_reg_mask(CR6A, VIACR, 0x00, BIT6);
+	viafb_write_reg_mask(CR6A, VIACR, 0x00, BIT7);
+	viafb_write_reg_mask(CR6A, VIACR, BIT6, BIT6);
+}
+
+void viafb_get_fb_info(unsigned int *fb_base, unsigned int *fb_len)
+{
+	struct pci_dev *pdev = NULL;
+	u32 vendor, device;
+	u32 i;
+
+	for (i = 0; pciidlist[i].vendor != 0; i++)
+		if (viaparinfo->chip_info->gfx_chip_name ==
+			pciidlist[i].chip_index)
+			break;
+
+	if (!pciidlist[i].vendor)
+		return ;
+
+	vendor = pciidlist[i].vendor;
+	device = pciidlist[i].device;
+
+	pdev = pci_get_device(vendor, device, NULL);
+
+	if (!pdev) {
+		*fb_base = viafb_read_reg(VIASR, SR30) << 24;
+		*fb_len = viafb_get_memsize();
+		DEBUG_MSG(KERN_INFO "Get FB info from SR30!\n");
+		DEBUG_MSG(KERN_INFO "fb_base = %08x\n", *fb_base);
+		DEBUG_MSG(KERN_INFO "fb_len = %08x\n", *fb_len);
+		return ;
+	}
+
+	*fb_base = (unsigned int)pci_resource_start(pdev, 0);
+	*fb_len = get_fb_size_from_pci();
+	DEBUG_MSG(KERN_INFO "Get FB info from PCI system!\n");
+	DEBUG_MSG(KERN_INFO "fb_base = %08x\n", *fb_base);
+	DEBUG_MSG(KERN_INFO "fb_len = %08x\n", *fb_len);
+
+	pci_dev_put(pdev);
+}
+
+static int get_fb_size_from_pci(void)
+{
+	unsigned long configid, deviceid, FBSize = 0;
+	int VideoMemSize;
+	int DeviceFound = false;
+
+	for (configid = 0x80000000; configid < 0x80010800; configid += 0x100) {
+		outl(configid, (unsigned long)0xCF8);
+		deviceid = (inl((unsigned long)0xCFC) >> 16) & 0xffff;
+
+		switch (deviceid) {
+		case CLE266:
+		case KM400:
+			outl(configid + 0xE0, (unsigned long)0xCF8);
+			FBSize = inl((unsigned long)0xCFC);
+			DeviceFound = true;	/* Found device id */
+			break;
+
+		case CN400_FUNCTION3:
+		case CN700_FUNCTION3:
+		case CX700_FUNCTION3:
+		case KM800_FUNCTION3:
+		case KM890_FUNCTION3:
+		case P4M890_FUNCTION3:
+		case P4M900_FUNCTION3:
+		case VX800_FUNCTION3:
+			/*case CN750_FUNCTION3: */
+			outl(configid + 0xA0, (unsigned long)0xCF8);
+			FBSize = inl((unsigned long)0xCFC);
+			DeviceFound = true;	/* Found device id */
+			break;
+
+		default:
+			break;
+		}
+
+		if (DeviceFound)
+			break;
+	}
+
+	DEBUG_MSG(KERN_INFO "Device ID = %lx\n", deviceid);
+
+	FBSize = FBSize & 0x00007000;
+	DEBUG_MSG(KERN_INFO "FB Size = %x\n", FBSize);
+
+	if (viaparinfo->chip_info->gfx_chip_name < UNICHROME_CX700) {
+		switch (FBSize) {
+		case 0x00004000:
+			VideoMemSize = (16 << 20);	/*16M */
+			break;
+
+		case 0x00005000:
+			VideoMemSize = (32 << 20);	/*32M */
+			break;
+
+		case 0x00006000:
+			VideoMemSize = (64 << 20);	/*64M */
+			break;
+
+		default:
+			VideoMemSize = (32 << 20);	/*32M */
+			break;
+		}
+	} else {
+		switch (FBSize) {
+		case 0x00001000:
+			VideoMemSize = (8 << 20);	/*8M */
+			break;
+
+		case 0x00002000:
+			VideoMemSize = (16 << 20);	/*16M */
+			break;
+
+		case 0x00003000:
+			VideoMemSize = (32 << 20);	/*32M */
+			break;
+
+		case 0x00004000:
+			VideoMemSize = (64 << 20);	/*64M */
+			break;
+
+		case 0x00005000:
+			VideoMemSize = (128 << 20);	/*128M */
+			break;
+
+		case 0x00006000:
+			VideoMemSize = (256 << 20);	/*256M */
+			break;
+
+		default:
+			VideoMemSize = (32 << 20);	/*32M */
+			break;
+		}
+	}
+
+	return VideoMemSize;
+}
+
+void viafb_set_dpa_gfx(int output_interface, struct GFX_DPA_SETTING\
+					*p_gfx_dpa_setting)
+{
+	switch (output_interface) {
+	case INTERFACE_DVP0:
+		{
+			/* DVP0 Clock Polarity and Adjust: */
+			viafb_write_reg_mask(CR96, VIACR,
+				       p_gfx_dpa_setting->DVP0, 0x0F);
+
+			/* DVP0 Clock and Data Pads Driving: */
+			viafb_write_reg_mask(SR1E, VIASR,
+				       p_gfx_dpa_setting->DVP0ClockDri_S, BIT2);
+			viafb_write_reg_mask(SR2A, VIASR,
+				       p_gfx_dpa_setting->DVP0ClockDri_S1,
+				       BIT4);
+			viafb_write_reg_mask(SR1B, VIASR,
+				       p_gfx_dpa_setting->DVP0DataDri_S, BIT1);
+			viafb_write_reg_mask(SR2A, VIASR,
+				       p_gfx_dpa_setting->DVP0DataDri_S1, BIT5);
+			break;
+		}
+
+	case INTERFACE_DVP1:
+		{
+			/* DVP1 Clock Polarity and Adjust: */
+			viafb_write_reg_mask(CR9B, VIACR,
+				       p_gfx_dpa_setting->DVP1, 0x0F);
+
+			/* DVP1 Clock and Data Pads Driving: */
+			viafb_write_reg_mask(SR65, VIASR,
+				       p_gfx_dpa_setting->DVP1Driving, 0x0F);
+			break;
+		}
+
+	case INTERFACE_DFP_HIGH:
+		{
+			viafb_write_reg_mask(CR97, VIACR,
+				       p_gfx_dpa_setting->DFPHigh, 0x0F);
+			break;
+		}
+
+	case INTERFACE_DFP_LOW:
+		{
+			viafb_write_reg_mask(CR99, VIACR,
+				       p_gfx_dpa_setting->DFPLow, 0x0F);
+			break;
+		}
+
+	case INTERFACE_DFP:
+		{
+			viafb_write_reg_mask(CR97, VIACR,
+				       p_gfx_dpa_setting->DFPHigh, 0x0F);
+			viafb_write_reg_mask(CR99, VIACR,
+				       p_gfx_dpa_setting->DFPLow, 0x0F);
+			break;
+		}
+	}
+}
+
+void viafb_memory_pitch_patch(struct fb_info *info)
+{
+	if (info->var.xres != info->var.xres_virtual) {
+		viafb_load_offset_reg(info->var.xres_virtual,
+				info->var.bits_per_pixel >> 3, IGA1);
+
+		if (viafb_SAMM_ON) {
+			viafb_load_offset_reg(viafb_second_virtual_xres,
+				viafb_bpp1 >> 3,
+					IGA2);
+		} else {
+			viafb_load_offset_reg(info->var.xres_virtual,
+					info->var.bits_per_pixel >> 3, IGA2);
+		}
+
+	}
+}
+
+/*According var's xres, yres fill var's other timing information*/
+void viafb_fill_var_timing_info(struct fb_var_screeninfo *var, int refresh,
+			  int mode_index)
+{
+	struct VideoModeTable *vmode_tbl = NULL;
+	struct crt_mode_table *crt_timing = NULL;
+	struct display_timing crt_reg;
+	int i = 0, index = 0;
+	vmode_tbl = &CLE266Modes[search_mode_setting(mode_index)];
+	crt_timing = vmode_tbl->crtc;
+	for (i = 0; i < vmode_tbl->mode_array; i++) {
+		index = i;
+		if (crt_timing[i].refresh_rate == refresh)
+			break;
+	}
+
+	crt_reg = crt_timing[index].crtc;
+	switch (var->bits_per_pixel) {
+	case 8:
+		var->red.offset = 0;
+		var->green.offset = 0;
+		var->blue.offset = 0;
+		var->red.length = 6;
+		var->green.length = 6;
+		var->blue.length = 6;
+		break;
+	case 16:
+		var->red.offset = 11;
+		var->green.offset = 5;
+		var->blue.offset = 0;
+		var->red.length = 5;
+		var->green.length = 6;
+		var->blue.length = 5;
+		break;
+	case 32:
+		var->red.offset = 16;
+		var->green.offset = 8;
+		var->blue.offset = 0;
+		var->red.length = 8;
+		var->green.length = 8;
+		var->blue.length = 8;
+		break;
+	default:
+		/* never happed, put here to keep consistent */
+		break;
+	}
+
+	var->pixclock = viafb_get_pixclock(var->xres, var->yres, refresh);
+	var->left_margin =
+	    crt_reg.hor_total - (crt_reg.hor_sync_start + crt_reg.hor_sync_end);
+	var->right_margin = crt_reg.hor_sync_start - crt_reg.hor_addr;
+	var->hsync_len = crt_reg.hor_sync_end;
+	var->upper_margin =
+	    crt_reg.ver_total - (crt_reg.ver_sync_start + crt_reg.ver_sync_end);
+	var->lower_margin = crt_reg.ver_sync_start - crt_reg.ver_addr;
+	var->vsync_len = crt_reg.ver_sync_end;
+}
--- /dev/null
+++ b/drivers/video/via/hw.h
@@ -0,0 +1,933 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __HW_H__
+#define __HW_H__
+
+#include "global.h"
+
+/***************************************************
+* Definition IGA1 Design Method of CRTC Registers *
+****************************************************/
+#define IGA1_HOR_TOTAL_FORMULA(x)           (((x)/8)-5)
+#define IGA1_HOR_ADDR_FORMULA(x)            (((x)/8)-1)
+#define IGA1_HOR_BLANK_START_FORMULA(x)     (((x)/8)-1)
+#define IGA1_HOR_BLANK_END_FORMULA(x, y)     (((x+y)/8)-1)
+#define IGA1_HOR_SYNC_START_FORMULA(x)      ((x)/8)
+#define IGA1_HOR_SYNC_END_FORMULA(x, y)      ((x+y)/8)
+
+#define IGA1_VER_TOTAL_FORMULA(x)           ((x)-2)
+#define IGA1_VER_ADDR_FORMULA(x)            ((x)-1)
+#define IGA1_VER_BLANK_START_FORMULA(x)     ((x)-1)
+#define IGA1_VER_BLANK_END_FORMULA(x, y)     ((x+y)-1)
+#define IGA1_VER_SYNC_START_FORMULA(x)      ((x)-1)
+#define IGA1_VER_SYNC_END_FORMULA(x, y)      ((x+y)-1)
+
+/***************************************************
+** Definition IGA2 Design Method of CRTC Registers *
+****************************************************/
+#define IGA2_HOR_TOTAL_FORMULA(x)           ((x)-1)
+#define IGA2_HOR_ADDR_FORMULA(x)            ((x)-1)
+#define IGA2_HOR_BLANK_START_FORMULA(x)     ((x)-1)
+#define IGA2_HOR_BLANK_END_FORMULA(x, y)     ((x+y)-1)
+#define IGA2_HOR_SYNC_START_FORMULA(x)      ((x)-1)
+#define IGA2_HOR_SYNC_END_FORMULA(x, y)      ((x+y)-1)
+
+#define IGA2_VER_TOTAL_FORMULA(x)           ((x)-1)
+#define IGA2_VER_ADDR_FORMULA(x)            ((x)-1)
+#define IGA2_VER_BLANK_START_FORMULA(x)     ((x)-1)
+#define IGA2_VER_BLANK_END_FORMULA(x, y)     ((x+y)-1)
+#define IGA2_VER_SYNC_START_FORMULA(x)      ((x)-1)
+#define IGA2_VER_SYNC_END_FORMULA(x, y)      ((x+y)-1)
+
+/**********************************************************/
+/* Definition IGA2 Design Method of CRTC Shadow Registers */
+/**********************************************************/
+#define IGA2_HOR_TOTAL_SHADOW_FORMULA(x)           ((x/8)-5)
+#define IGA2_HOR_BLANK_END_SHADOW_FORMULA(x, y)     (((x+y)/8)-1)
+#define IGA2_VER_TOTAL_SHADOW_FORMULA(x)           ((x)-2)
+#define IGA2_VER_ADDR_SHADOW_FORMULA(x)            ((x)-1)
+#define IGA2_VER_BLANK_START_SHADOW_FORMULA(x)     ((x)-1)
+#define IGA2_VER_BLANK_END_SHADOW_FORMULA(x, y)     ((x+y)-1)
+#define IGA2_VER_SYNC_START_SHADOW_FORMULA(x)      (x)
+#define IGA2_VER_SYNC_END_SHADOW_FORMULA(x, y)      (x+y)
+
+/* Define Register Number for IGA1 CRTC Timing */
+
+/* location: {CR00,0,7},{CR36,3,3} */
+#define IGA1_HOR_TOTAL_REG_NUM		2
+/* location: {CR01,0,7} */
+#define IGA1_HOR_ADDR_REG_NUM		1
+/* location: {CR02,0,7} */
+#define IGA1_HOR_BLANK_START_REG_NUM    1
+/* location: {CR03,0,4},{CR05,7,7},{CR33,5,5} */
+#define IGA1_HOR_BLANK_END_REG_NUM	3
+/* location: {CR04,0,7},{CR33,4,4} */
+#define IGA1_HOR_SYNC_START_REG_NUM	2
+/* location: {CR05,0,4} */
+#define IGA1_HOR_SYNC_END_REG_NUM       1
+/* location: {CR06,0,7},{CR07,0,0},{CR07,5,5},{CR35,0,0} */
+#define IGA1_VER_TOTAL_REG_NUM          4
+/* location: {CR12,0,7},{CR07,1,1},{CR07,6,6},{CR35,2,2} */
+#define IGA1_VER_ADDR_REG_NUM           4
+/* location: {CR15,0,7},{CR07,3,3},{CR09,5,5},{CR35,3,3} */
+#define IGA1_VER_BLANK_START_REG_NUM    4
+/* location: {CR16,0,7} */
+#define IGA1_VER_BLANK_END_REG_NUM      1
+/* location: {CR10,0,7},{CR07,2,2},{CR07,7,7},{CR35,1,1} */
+#define IGA1_VER_SYNC_START_REG_NUM     4
+/* location: {CR11,0,3} */
+#define IGA1_VER_SYNC_END_REG_NUM       1
+
+/* Define Register Number for IGA2 Shadow CRTC Timing */
+
+/* location: {CR6D,0,7},{CR71,3,3} */
+#define IGA2_SHADOW_HOR_TOTAL_REG_NUM       2
+/* location: {CR6E,0,7} */
+#define IGA2_SHADOW_HOR_BLANK_END_REG_NUM   1
+/* location: {CR6F,0,7},{CR71,0,2} */
+#define IGA2_SHADOW_VER_TOTAL_REG_NUM       2
+/* location: {CR70,0,7},{CR71,4,6} */
+#define IGA2_SHADOW_VER_ADDR_REG_NUM        2
+/* location: {CR72,0,7},{CR74,4,6} */
+#define IGA2_SHADOW_VER_BLANK_START_REG_NUM 2
+/* location: {CR73,0,7},{CR74,0,2} */
+#define IGA2_SHADOW_VER_BLANK_END_REG_NUM   2
+/* location: {CR75,0,7},{CR76,4,6} */
+#define IGA2_SHADOW_VER_SYNC_START_REG_NUM  2
+/* location: {CR76,0,3} */
+#define IGA2_SHADOW_VER_SYNC_END_REG_NUM    1
+
+/* Define Register Number for IGA2 CRTC Timing */
+
+/* location: {CR50,0,7},{CR55,0,3} */
+#define IGA2_HOR_TOTAL_REG_NUM          2
+/* location: {CR51,0,7},{CR55,4,6} */
+#define IGA2_HOR_ADDR_REG_NUM           2
+/* location: {CR52,0,7},{CR54,0,2} */
+#define IGA2_HOR_BLANK_START_REG_NUM    2
+/* location: CLE266: {CR53,0,7},{CR54,3,5} => CLE266's CR5D[6]
+is reserved, so it may have problem to set 1600x1200 on IGA2. */
+/*         	Others: {CR53,0,7},{CR54,3,5},{CR5D,6,6} */
+#define IGA2_HOR_BLANK_END_REG_NUM      3
+/* location: {CR56,0,7},{CR54,6,7},{CR5C,7,7} */
+/* VT3314 and Later: {CR56,0,7},{CR54,6,7},{CR5C,7,7}, {CR5D,7,7} */
+#define IGA2_HOR_SYNC_START_REG_NUM     4
+
+/* location: {CR57,0,7},{CR5C,6,6} */
+#define IGA2_HOR_SYNC_END_REG_NUM       2
+/* location: {CR58,0,7},{CR5D,0,2} */
+#define IGA2_VER_TOTAL_REG_NUM          2
+/* location: {CR59,0,7},{CR5D,3,5} */
+#define IGA2_VER_ADDR_REG_NUM           2
+/* location: {CR5A,0,7},{CR5C,0,2} */
+#define IGA2_VER_BLANK_START_REG_NUM    2
+/* location: {CR5E,0,7},{CR5C,3,5} */
+#define IGA2_VER_BLANK_END_REG_NUM      2
+/* location: {CR5E,0,7},{CR5F,5,7} */
+#define IGA2_VER_SYNC_START_REG_NUM     2
+/* location: {CR5F,0,4} */
+#define IGA2_VER_SYNC_END_REG_NUM       1
+
+/* Define Offset and Fetch Count Register*/
+
+/* location: {CR13,0,7},{CR35,5,7} */
+#define IGA1_OFFSET_REG_NUM             2
+/* 8 bytes alignment. */
+#define IGA1_OFFSER_ALIGN_BYTE          8
+/* x: H resolution, y: color depth */
+#define IGA1_OFFSET_FORMULA(x, y)        ((x*y)/IGA1_OFFSER_ALIGN_BYTE)
+/* location: {SR1C,0,7},{SR1D,0,1} */
+#define IGA1_FETCH_COUNT_REG_NUM        2
+/* 16 bytes alignment. */
+#define IGA1_FETCH_COUNT_ALIGN_BYTE     16
+/* x: H resolution, y: color depth */
+#define IGA1_FETCH_COUNT_PATCH_VALUE    4
+#define IGA1_FETCH_COUNT_FORMULA(x, y)   \
+	(((x*y)/IGA1_FETCH_COUNT_ALIGN_BYTE) + IGA1_FETCH_COUNT_PATCH_VALUE)
+
+/* location: {CR66,0,7},{CR67,0,1} */
+#define IGA2_OFFSET_REG_NUM             2
+#define IGA2_OFFSET_ALIGN_BYTE          8
+/* x: H resolution, y: color depth */
+#define IGA2_OFFSET_FORMULA(x, y)        ((x*y)/IGA2_OFFSET_ALIGN_BYTE)
+/* location: {CR65,0,7},{CR67,2,3} */
+#define IGA2_FETCH_COUNT_REG_NUM        2
+#define IGA2_FETCH_COUNT_ALIGN_BYTE     16
+#define IGA2_FETCH_COUNT_PATCH_VALUE    0
+#define IGA2_FETCH_COUNT_FORMULA(x, y)   \
+	(((x*y)/IGA2_FETCH_COUNT_ALIGN_BYTE) + IGA2_FETCH_COUNT_PATCH_VALUE)
+
+/* Staring Address*/
+
+/* location: {CR0C,0,7},{CR0D,0,7},{CR34,0,7},{CR48,0,1} */
+#define IGA1_STARTING_ADDR_REG_NUM      4
+/* location: {CR62,1,7},{CR63,0,7},{CR64,0,7} */
+#define IGA2_STARTING_ADDR_REG_NUM      3
+
+/* Define Display OFFSET*/
+/* These value are by HW suggested value*/
+/* location: {SR17,0,7} */
+#define K800_IGA1_FIFO_MAX_DEPTH                384
+/* location: {SR16,0,5},{SR16,7,7} */
+#define K800_IGA1_FIFO_THRESHOLD                328
+/* location: {SR18,0,5},{SR18,7,7} */
+#define K800_IGA1_FIFO_HIGH_THRESHOLD           296
+/* location: {SR22,0,4}. (128/4) =64, K800 must be set zero, */
+				/* because HW only 5 bits */
+#define K800_IGA1_DISPLAY_QUEUE_EXPIRE_NUM      0
+
+/* location: {CR68,4,7},{CR94,7,7},{CR95,7,7} */
+#define K800_IGA2_FIFO_MAX_DEPTH                384
+/* location: {CR68,0,3},{CR95,4,6} */
+#define K800_IGA2_FIFO_THRESHOLD                328
+/* location: {CR92,0,3},{CR95,0,2} */
+#define K800_IGA2_FIFO_HIGH_THRESHOLD           296
+/* location: {CR94,0,6} */
+#define K800_IGA2_DISPLAY_QUEUE_EXPIRE_NUM      128
+
+/* location: {SR17,0,7} */
+#define P880_IGA1_FIFO_MAX_DEPTH                192
+/* location: {SR16,0,5},{SR16,7,7} */
+#define P880_IGA1_FIFO_THRESHOLD                128
+/* location: {SR18,0,5},{SR18,7,7} */
+#define P880_IGA1_FIFO_HIGH_THRESHOLD           64
+/* location: {SR22,0,4}. (128/4) =64, K800 must be set zero, */
+				/* because HW only 5 bits */
+#define P880_IGA1_DISPLAY_QUEUE_EXPIRE_NUM      0
+
+/* location: {CR68,4,7},{CR94,7,7},{CR95,7,7} */
+#define P880_IGA2_FIFO_MAX_DEPTH                96
+/* location: {CR68,0,3},{CR95,4,6} */
+#define P880_IGA2_FIFO_THRESHOLD                64
+/* location: {CR92,0,3},{CR95,0,2} */
+#define P880_IGA2_FIFO_HIGH_THRESHOLD           32
+/* location: {CR94,0,6} */
+#define P880_IGA2_DISPLAY_QUEUE_EXPIRE_NUM      128
+
+/* VT3314 chipset*/
+
+/* location: {SR17,0,7} */
+#define CN700_IGA1_FIFO_MAX_DEPTH               96
+/* location: {SR16,0,5},{SR16,7,7} */
+#define CN700_IGA1_FIFO_THRESHOLD               80
+/* location: {SR18,0,5},{SR18,7,7} */
+#define CN700_IGA1_FIFO_HIGH_THRESHOLD          64
+/* location: {SR22,0,4}. (128/4) =64, P800 must be set zero,
+				because HW only 5 bits */
+#define CN700_IGA1_DISPLAY_QUEUE_EXPIRE_NUM     0
+/* location: {CR68,4,7},{CR94,7,7},{CR95,7,7} */
+#define CN700_IGA2_FIFO_MAX_DEPTH               96
+/* location: {CR68,0,3},{CR95,4,6} */
+#define CN700_IGA2_FIFO_THRESHOLD               80
+/* location: {CR92,0,3},{CR95,0,2} */
+#define CN700_IGA2_FIFO_HIGH_THRESHOLD          32
+/* location: {CR94,0,6} */
+#define CN700_IGA2_DISPLAY_QUEUE_EXPIRE_NUM     128
+
+/* For VT3324, these values are suggested by HW */
+/* location: {SR17,0,7} */
+#define CX700_IGA1_FIFO_MAX_DEPTH               192
+/* location: {SR16,0,5},{SR16,7,7} */
+#define CX700_IGA1_FIFO_THRESHOLD               128
+/* location: {SR18,0,5},{SR18,7,7} */
+#define CX700_IGA1_FIFO_HIGH_THRESHOLD          128
+/* location: {SR22,0,4} */
+#define CX700_IGA1_DISPLAY_QUEUE_EXPIRE_NUM     124
+
+/* location: {CR68,4,7},{CR94,7,7},{CR95,7,7} */
+#define CX700_IGA2_FIFO_MAX_DEPTH               96
+/* location: {CR68,0,3},{CR95,4,6} */
+#define CX700_IGA2_FIFO_THRESHOLD               64
+/* location: {CR92,0,3},{CR95,0,2} */
+#define CX700_IGA2_FIFO_HIGH_THRESHOLD          32
+/* location: {CR94,0,6} */
+#define CX700_IGA2_DISPLAY_QUEUE_EXPIRE_NUM     128
+
+/* VT3336 chipset*/
+/* location: {SR17,0,7} */
+#define K8M890_IGA1_FIFO_MAX_DEPTH               360
+/* location: {SR16,0,5},{SR16,7,7} */
+#define K8M890_IGA1_FIFO_THRESHOLD               328
+/* location: {SR18,0,5},{SR18,7,7} */
+#define K8M890_IGA1_FIFO_HIGH_THRESHOLD          296
+/* location: {SR22,0,4}. */
+#define K8M890_IGA1_DISPLAY_QUEUE_EXPIRE_NUM     124
+
+/* location: {CR68,4,7},{CR94,7,7},{CR95,7,7} */
+#define K8M890_IGA2_FIFO_MAX_DEPTH               360
+/* location: {CR68,0,3},{CR95,4,6} */
+#define K8M890_IGA2_FIFO_THRESHOLD               328
+/* location: {CR92,0,3},{CR95,0,2} */
+#define K8M890_IGA2_FIFO_HIGH_THRESHOLD          296
+/* location: {CR94,0,6} */
+#define K8M890_IGA2_DISPLAY_QUEUE_EXPIRE_NUM     124
+
+/* VT3327 chipset*/
+/* location: {SR17,0,7} */
+#define P4M890_IGA1_FIFO_MAX_DEPTH               96
+/* location: {SR16,0,5},{SR16,7,7} */
+#define P4M890_IGA1_FIFO_THRESHOLD               76
+/* location: {SR18,0,5},{SR18,7,7} */
+#define P4M890_IGA1_FIFO_HIGH_THRESHOLD          64
+/* location: {SR22,0,4}. (32/4) =8 */
+#define P4M890_IGA1_DISPLAY_QUEUE_EXPIRE_NUM     32
+/* location: {CR68,4,7},{CR94,7,7},{CR95,7,7} */
+#define P4M890_IGA2_FIFO_MAX_DEPTH               96
+/* location: {CR68,0,3},{CR95,4,6} */
+#define P4M890_IGA2_FIFO_THRESHOLD               76
+/* location: {CR92,0,3},{CR95,0,2} */
+#define P4M890_IGA2_FIFO_HIGH_THRESHOLD          64
+/* location: {CR94,0,6} */
+#define P4M890_IGA2_DISPLAY_QUEUE_EXPIRE_NUM     32
+
+/* VT3364 chipset*/
+/* location: {SR17,0,7} */
+#define P4M900_IGA1_FIFO_MAX_DEPTH               96
+/* location: {SR16,0,5},{SR16,7,7} */
+#define P4M900_IGA1_FIFO_THRESHOLD               76
+/* location: {SR18,0,5},{SR18,7,7} */
+#define P4M900_IGA1_FIFO_HIGH_THRESHOLD          76
+/* location: {SR22,0,4}. */
+#define P4M900_IGA1_DISPLAY_QUEUE_EXPIRE_NUM     32
+/* location: {CR68,4,7},{CR94,7,7},{CR95,7,7} */
+#define P4M900_IGA2_FIFO_MAX_DEPTH               96
+/* location: {CR68,0,3},{CR95,4,6} */
+#define P4M900_IGA2_FIFO_THRESHOLD               76
+/* location: {CR92,0,3},{CR95,0,2} */
+#define P4M900_IGA2_FIFO_HIGH_THRESHOLD          76
+/* location: {CR94,0,6} */
+#define P4M900_IGA2_DISPLAY_QUEUE_EXPIRE_NUM     32
+
+/* For VT3353, these values are suggested by HW */
+/* location: {SR17,0,7} */
+#define VX800_IGA1_FIFO_MAX_DEPTH               192
+/* location: {SR16,0,5},{SR16,7,7} */
+#define VX800_IGA1_FIFO_THRESHOLD               152
+/* location: {SR18,0,5},{SR18,7,7} */
+#define VX800_IGA1_FIFO_HIGH_THRESHOLD          152
+/* location: {SR22,0,4} */
+#define VX800_IGA1_DISPLAY_QUEUE_EXPIRE_NUM      64
+/* location: {CR68,4,7},{CR94,7,7},{CR95,7,7} */
+#define VX800_IGA2_FIFO_MAX_DEPTH               96
+/* location: {CR68,0,3},{CR95,4,6} */
+#define VX800_IGA2_FIFO_THRESHOLD               64
+/* location: {CR92,0,3},{CR95,0,2} */
+#define VX800_IGA2_FIFO_HIGH_THRESHOLD          32
+/* location: {CR94,0,6} */
+#define VX800_IGA2_DISPLAY_QUEUE_EXPIRE_NUM     128
+
+#define IGA1_FIFO_DEPTH_SELECT_REG_NUM          1
+#define IGA1_FIFO_THRESHOLD_REG_NUM             2
+#define IGA1_FIFO_HIGH_THRESHOLD_REG_NUM        2
+#define IGA1_DISPLAY_QUEUE_EXPIRE_NUM_REG_NUM   1
+
+#define IGA2_FIFO_DEPTH_SELECT_REG_NUM          3
+#define IGA2_FIFO_THRESHOLD_REG_NUM             2
+#define IGA2_FIFO_HIGH_THRESHOLD_REG_NUM        2
+#define IGA2_DISPLAY_QUEUE_EXPIRE_NUM_REG_NUM   1
+
+#define IGA1_FIFO_DEPTH_SELECT_FORMULA(x)                   ((x/2)-1)
+#define IGA1_FIFO_THRESHOLD_FORMULA(x)                      (x/4)
+#define IGA1_DISPLAY_QUEUE_EXPIRE_NUM_FORMULA(x)            (x/4)
+#define IGA1_FIFO_HIGH_THRESHOLD_FORMULA(x)                 (x/4)
+#define IGA2_FIFO_DEPTH_SELECT_FORMULA(x)                   (((x/2)/4)-1)
+#define IGA2_FIFO_THRESHOLD_FORMULA(x)                      (x/4)
+#define IGA2_DISPLAY_QUEUE_EXPIRE_NUM_FORMULA(x)            (x/4)
+#define IGA2_FIFO_HIGH_THRESHOLD_FORMULA(x)                 (x/4)
+
+/************************************************************************/
+/*  LCD Timing                                                          */
+/************************************************************************/
+
+/* 500 ms = 500000 us */
+#define LCD_POWER_SEQ_TD0               500000
+/* 50 ms = 50000 us */
+#define LCD_POWER_SEQ_TD1               50000
+/* 0 us */
+#define LCD_POWER_SEQ_TD2               0
+/* 210 ms = 210000 us */
+#define LCD_POWER_SEQ_TD3               210000
+/* 2^10 * (1/14.31818M) = 71.475 us (K400.revA) */
+#define CLE266_POWER_SEQ_UNIT           71
+/* 2^11 * (1/14.31818M) = 142.95 us (K400.revB) */
+#define K800_POWER_SEQ_UNIT             142
+/* 2^13 * (1/14.31818M) = 572.1 us */
+#define P880_POWER_SEQ_UNIT             572
+
+#define CLE266_POWER_SEQ_FORMULA(x)     ((x)/CLE266_POWER_SEQ_UNIT)
+#define K800_POWER_SEQ_FORMULA(x)       ((x)/K800_POWER_SEQ_UNIT)
+#define P880_POWER_SEQ_FORMULA(x)       ((x)/P880_POWER_SEQ_UNIT)
+
+/* location: {CR8B,0,7},{CR8F,0,3} */
+#define LCD_POWER_SEQ_TD0_REG_NUM       2
+/* location: {CR8C,0,7},{CR8F,4,7} */
+#define LCD_POWER_SEQ_TD1_REG_NUM       2
+/* location: {CR8D,0,7},{CR90,0,3} */
+#define LCD_POWER_SEQ_TD2_REG_NUM       2
+/* location: {CR8E,0,7},{CR90,4,7} */
+#define LCD_POWER_SEQ_TD3_REG_NUM       2
+
+/* LCD Scaling factor*/
+/* x: indicate setting horizontal size*/
+/* y: indicate panel horizontal size*/
+
+/* Horizontal scaling factor 10 bits (2^10) */
+#define CLE266_LCD_HOR_SCF_FORMULA(x, y)   (((x-1)*1024)/(y-1))
+/* Vertical scaling factor 10 bits (2^10) */
+#define CLE266_LCD_VER_SCF_FORMULA(x, y)   (((x-1)*1024)/(y-1))
+/* Horizontal scaling factor 10 bits (2^12) */
+#define K800_LCD_HOR_SCF_FORMULA(x, y)     (((x-1)*4096)/(y-1))
+/* Vertical scaling factor 10 bits (2^11) */
+#define K800_LCD_VER_SCF_FORMULA(x, y)     (((x-1)*2048)/(y-1))
+
+/* location: {CR9F,0,1},{CR77,0,7},{CR79,4,5} */
+#define LCD_HOR_SCALING_FACTOR_REG_NUM  3
+/* location: {CR79,3,3},{CR78,0,7},{CR79,6,7} */
+#define LCD_VER_SCALING_FACTOR_REG_NUM  3
+/* location: {CR77,0,7},{CR79,4,5} */
+#define LCD_HOR_SCALING_FACTOR_REG_NUM_CLE  2
+/* location: {CR78,0,7},{CR79,6,7} */
+#define LCD_VER_SCALING_FACTOR_REG_NUM_CLE  2
+
+/************************************************
+ *****     Define IGA1 Display Timing       *****
+ ************************************************/
+struct io_register {
+	u8 io_addr;
+	u8 start_bit;
+	u8 end_bit;
+};
+
+/* IGA1 Horizontal Total */
+struct iga1_hor_total {
+	int reg_num;
+	struct io_register reg[IGA1_HOR_TOTAL_REG_NUM];
+};
+
+/* IGA1 Horizontal Addressable Video */
+struct iga1_hor_addr {
+	int reg_num;
+	struct io_register reg[IGA1_HOR_ADDR_REG_NUM];
+};
+
+/* IGA1 Horizontal Blank Start */
+struct iga1_hor_blank_start {
+	int reg_num;
+	struct io_register reg[IGA1_HOR_BLANK_START_REG_NUM];
+};
+
+/* IGA1 Horizontal Blank End */
+struct iga1_hor_blank_end {
+	int reg_num;
+	struct io_register reg[IGA1_HOR_BLANK_END_REG_NUM];
+};
+
+/* IGA1 Horizontal Sync Start */
+struct iga1_hor_sync_start {
+	int reg_num;
+	struct io_register reg[IGA1_HOR_SYNC_START_REG_NUM];
+};
+
+/* IGA1 Horizontal Sync End */
+struct iga1_hor_sync_end {
+	int reg_num;
+	struct io_register reg[IGA1_HOR_SYNC_END_REG_NUM];
+};
+
+/* IGA1 Vertical Total */
+struct iga1_ver_total {
+	int reg_num;
+	struct io_register reg[IGA1_VER_TOTAL_REG_NUM];
+};
+
+/* IGA1 Vertical Addressable Video */
+struct iga1_ver_addr {
+	int reg_num;
+	struct io_register reg[IGA1_VER_ADDR_REG_NUM];
+};
+
+/* IGA1 Vertical Blank Start */
+struct iga1_ver_blank_start {
+	int reg_num;
+	struct io_register reg[IGA1_VER_BLANK_START_REG_NUM];
+};
+
+/* IGA1 Vertical Blank End */
+struct iga1_ver_blank_end {
+	int reg_num;
+	struct io_register reg[IGA1_VER_BLANK_END_REG_NUM];
+};
+
+/* IGA1 Vertical Sync Start */
+struct iga1_ver_sync_start {
+	int reg_num;
+	struct io_register reg[IGA1_VER_SYNC_START_REG_NUM];
+};
+
+/* IGA1 Vertical Sync End */
+struct iga1_ver_sync_end {
+	int reg_num;
+	struct io_register reg[IGA1_VER_SYNC_END_REG_NUM];
+};
+
+/*****************************************************
+**      Define IGA2 Shadow Display Timing         ****
+*****************************************************/
+
+/* IGA2 Shadow Horizontal Total */
+struct iga2_shadow_hor_total {
+	int reg_num;
+	struct io_register reg[IGA2_SHADOW_HOR_TOTAL_REG_NUM];
+};
+
+/* IGA2 Shadow Horizontal Blank End */
+struct iga2_shadow_hor_blank_end {
+	int reg_num;
+	struct io_register reg[IGA2_SHADOW_HOR_BLANK_END_REG_NUM];
+};
+
+/* IGA2 Shadow Vertical Total */
+struct iga2_shadow_ver_total {
+	int reg_num;
+	struct io_register reg[IGA2_SHADOW_VER_TOTAL_REG_NUM];
+};
+
+/* IGA2 Shadow Vertical Addressable Video */
+struct iga2_shadow_ver_addr {
+	int reg_num;
+	struct io_register reg[IGA2_SHADOW_VER_ADDR_REG_NUM];
+};
+
+/* IGA2 Shadow Vertical Blank Start */
+struct iga2_shadow_ver_blank_start {
+	int reg_num;
+	struct io_register reg[IGA2_SHADOW_VER_BLANK_START_REG_NUM];
+};
+
+/* IGA2 Shadow Vertical Blank End */
+struct iga2_shadow_ver_blank_end {
+	int reg_num;
+	struct io_register reg[IGA2_SHADOW_VER_BLANK_END_REG_NUM];
+};
+
+/* IGA2 Shadow Vertical Sync Start */
+struct iga2_shadow_ver_sync_start {
+	int reg_num;
+	struct io_register reg[IGA2_SHADOW_VER_SYNC_START_REG_NUM];
+};
+
+/* IGA2 Shadow Vertical Sync End */
+struct iga2_shadow_ver_sync_end {
+	int reg_num;
+	struct io_register reg[IGA2_SHADOW_VER_SYNC_END_REG_NUM];
+};
+
+/*****************************************************
+**      Define IGA2 Display Timing                ****
+******************************************************/
+
+/* IGA2 Horizontal Total */
+struct iga2_hor_total {
+	int reg_num;
+	struct io_register reg[IGA2_HOR_TOTAL_REG_NUM];
+};
+
+/* IGA2 Horizontal Addressable Video */
+struct iga2_hor_addr {
+	int reg_num;
+	struct io_register reg[IGA2_HOR_ADDR_REG_NUM];
+};
+
+/* IGA2 Horizontal Blank Start */
+struct iga2_hor_blank_start {
+	int reg_num;
+	struct io_register reg[IGA2_HOR_BLANK_START_REG_NUM];
+};
+
+/* IGA2 Horizontal Blank End */
+struct iga2_hor_blank_end {
+	int reg_num;
+	struct io_register reg[IGA2_HOR_BLANK_END_REG_NUM];
+};
+
+/* IGA2 Horizontal Sync Start */
+struct iga2_hor_sync_start {
+	int reg_num;
+	struct io_register reg[IGA2_HOR_SYNC_START_REG_NUM];
+};
+
+/* IGA2 Horizontal Sync End */
+struct iga2_hor_sync_end {
+	int reg_num;
+	struct io_register reg[IGA2_HOR_SYNC_END_REG_NUM];
+};
+
+/* IGA2 Vertical Total */
+struct iga2_ver_total {
+	int reg_num;
+	struct io_register reg[IGA2_VER_TOTAL_REG_NUM];
+};
+
+/* IGA2 Vertical Addressable Video */
+struct iga2_ver_addr {
+	int reg_num;
+	struct io_register reg[IGA2_VER_ADDR_REG_NUM];
+};
+
+/* IGA2 Vertical Blank Start */
+struct iga2_ver_blank_start {
+	int reg_num;
+	struct io_register reg[IGA2_VER_BLANK_START_REG_NUM];
+};
+
+/* IGA2 Vertical Blank End */
+struct iga2_ver_blank_end {
+	int reg_num;
+	struct io_register reg[IGA2_VER_BLANK_END_REG_NUM];
+};
+
+/* IGA2 Vertical Sync Start */
+struct iga2_ver_sync_start {
+	int reg_num;
+	struct io_register reg[IGA2_VER_SYNC_START_REG_NUM];
+};
+
+/* IGA2 Vertical Sync End */
+struct iga2_ver_sync_end {
+	int reg_num;
+	struct io_register reg[IGA2_VER_SYNC_END_REG_NUM];
+};
+
+/* IGA1 Offset Register */
+struct iga1_offset {
+	int reg_num;
+	struct io_register reg[IGA1_OFFSET_REG_NUM];
+};
+
+/* IGA2 Offset Register */
+struct iga2_offset {
+	int reg_num;
+	struct io_register reg[IGA2_OFFSET_REG_NUM];
+};
+
+struct offset {
+	struct iga1_offset iga1_offset_reg;
+	struct iga2_offset iga2_offset_reg;
+};
+
+/* IGA1 Fetch Count Register */
+struct iga1_fetch_count {
+	int reg_num;
+	struct io_register reg[IGA1_FETCH_COUNT_REG_NUM];
+};
+
+/* IGA2 Fetch Count Register */
+struct iga2_fetch_count {
+	int reg_num;
+	struct io_register reg[IGA2_FETCH_COUNT_REG_NUM];
+};
+
+struct fetch_count {
+	struct iga1_fetch_count iga1_fetch_count_reg;
+	struct iga2_fetch_count iga2_fetch_count_reg;
+};
+
+/* Starting Address Register */
+struct iga1_starting_addr {
+	int reg_num;
+	struct io_register reg[IGA1_STARTING_ADDR_REG_NUM];
+};
+
+struct iga2_starting_addr {
+	int reg_num;
+	struct io_register reg[IGA2_STARTING_ADDR_REG_NUM];
+};
+
+struct starting_addr {
+	struct iga1_starting_addr iga1_starting_addr_reg;
+	struct iga2_starting_addr iga2_starting_addr_reg;
+};
+
+/* LCD Power Sequence Timer */
+struct lcd_pwd_seq_td0 {
+	int reg_num;
+	struct io_register reg[LCD_POWER_SEQ_TD0_REG_NUM];
+};
+
+struct lcd_pwd_seq_td1 {
+	int reg_num;
+	struct io_register reg[LCD_POWER_SEQ_TD1_REG_NUM];
+};
+
+struct lcd_pwd_seq_td2 {
+	int reg_num;
+	struct io_register reg[LCD_POWER_SEQ_TD2_REG_NUM];
+};
+
+struct lcd_pwd_seq_td3 {
+	int reg_num;
+	struct io_register reg[LCD_POWER_SEQ_TD3_REG_NUM];
+};
+
+struct _lcd_pwd_seq_timer {
+	struct lcd_pwd_seq_td0 td0;
+	struct lcd_pwd_seq_td1 td1;
+	struct lcd_pwd_seq_td2 td2;
+	struct lcd_pwd_seq_td3 td3;
+};
+
+/* LCD Scaling Factor */
+struct _lcd_hor_scaling_factor {
+	int reg_num;
+	struct io_register reg[LCD_HOR_SCALING_FACTOR_REG_NUM];
+};
+
+struct _lcd_ver_scaling_factor {
+	int reg_num;
+	struct io_register reg[LCD_VER_SCALING_FACTOR_REG_NUM];
+};
+
+struct _lcd_scaling_factor {
+	struct _lcd_hor_scaling_factor lcd_hor_scaling_factor;
+	struct _lcd_ver_scaling_factor lcd_ver_scaling_factor;
+};
+
+struct pll_map {
+	u32 clk;
+	u32 cle266_pll;
+	u32 k800_pll;
+	u32 cx700_pll;
+};
+
+struct rgbLUT {
+	u8 red;
+	u8 green;
+	u8 blue;
+};
+
+struct lcd_pwd_seq_timer {
+	u16 td0;
+	u16 td1;
+	u16 td2;
+	u16 td3;
+};
+
+/* Display FIFO Relation Registers*/
+struct iga1_fifo_depth_select {
+	int reg_num;
+	struct io_register reg[IGA1_FIFO_DEPTH_SELECT_REG_NUM];
+};
+
+struct iga1_fifo_threshold_select {
+	int reg_num;
+	struct io_register reg[IGA1_FIFO_THRESHOLD_REG_NUM];
+};
+
+struct iga1_fifo_high_threshold_select {
+	int reg_num;
+	struct io_register reg[IGA1_FIFO_HIGH_THRESHOLD_REG_NUM];
+};
+
+struct iga1_display_queue_expire_num {
+	int reg_num;
+	struct io_register reg[IGA1_DISPLAY_QUEUE_EXPIRE_NUM_REG_NUM];
+};
+
+struct iga2_fifo_depth_select {
+	int reg_num;
+	struct io_register reg[IGA2_FIFO_DEPTH_SELECT_REG_NUM];
+};
+
+struct iga2_fifo_threshold_select {
+	int reg_num;
+	struct io_register reg[IGA2_FIFO_THRESHOLD_REG_NUM];
+};
+
+struct iga2_fifo_high_threshold_select {
+	int reg_num;
+	struct io_register reg[IGA2_FIFO_HIGH_THRESHOLD_REG_NUM];
+};
+
+struct iga2_display_queue_expire_num {
+	int reg_num;
+	struct io_register reg[IGA2_DISPLAY_QUEUE_EXPIRE_NUM_REG_NUM];
+};
+
+struct fifo_depth_select {
+	struct iga1_fifo_depth_select iga1_fifo_depth_select_reg;
+	struct iga2_fifo_depth_select iga2_fifo_depth_select_reg;
+};
+
+struct fifo_threshold_select {
+	struct iga1_fifo_threshold_select iga1_fifo_threshold_select_reg;
+	struct iga2_fifo_threshold_select iga2_fifo_threshold_select_reg;
+};
+
+struct fifo_high_threshold_select {
+	struct iga1_fifo_high_threshold_select
+	 iga1_fifo_high_threshold_select_reg;
+	struct iga2_fifo_high_threshold_select
+	 iga2_fifo_high_threshold_select_reg;
+};
+
+struct display_queue_expire_num {
+	struct iga1_display_queue_expire_num
+	 iga1_display_queue_expire_num_reg;
+	struct iga2_display_queue_expire_num
+	 iga2_display_queue_expire_num_reg;
+};
+
+struct iga1_crtc_timing {
+	struct iga1_hor_total hor_total;
+	struct iga1_hor_addr hor_addr;
+	struct iga1_hor_blank_start hor_blank_start;
+	struct iga1_hor_blank_end hor_blank_end;
+	struct iga1_hor_sync_start hor_sync_start;
+	struct iga1_hor_sync_end hor_sync_end;
+	struct iga1_ver_total ver_total;
+	struct iga1_ver_addr ver_addr;
+	struct iga1_ver_blank_start ver_blank_start;
+	struct iga1_ver_blank_end ver_blank_end;
+	struct iga1_ver_sync_start ver_sync_start;
+	struct iga1_ver_sync_end ver_sync_end;
+};
+
+struct iga2_shadow_crtc_timing {
+	struct iga2_shadow_hor_total hor_total_shadow;
+	struct iga2_shadow_hor_blank_end hor_blank_end_shadow;
+	struct iga2_shadow_ver_total ver_total_shadow;
+	struct iga2_shadow_ver_addr ver_addr_shadow;
+	struct iga2_shadow_ver_blank_start ver_blank_start_shadow;
+	struct iga2_shadow_ver_blank_end ver_blank_end_shadow;
+	struct iga2_shadow_ver_sync_start ver_sync_start_shadow;
+	struct iga2_shadow_ver_sync_end ver_sync_end_shadow;
+};
+
+struct iga2_crtc_timing {
+	struct iga2_hor_total hor_total;
+	struct iga2_hor_addr hor_addr;
+	struct iga2_hor_blank_start hor_blank_start;
+	struct iga2_hor_blank_end hor_blank_end;
+	struct iga2_hor_sync_start hor_sync_start;
+	struct iga2_hor_sync_end hor_sync_end;
+	struct iga2_ver_total ver_total;
+	struct iga2_ver_addr ver_addr;
+	struct iga2_ver_blank_start ver_blank_start;
+	struct iga2_ver_blank_end ver_blank_end;
+	struct iga2_ver_sync_start ver_sync_start;
+	struct iga2_ver_sync_end ver_sync_end;
+};
+
+/* device ID */
+#define CLE266              0x3123
+#define KM400               0x3205
+#define CN400_FUNCTION2     0x2259
+#define CN400_FUNCTION3     0x3259
+/* support VT3314 chipset */
+#define CN700_FUNCTION2     0x2314
+#define CN700_FUNCTION3     0x3208
+/* VT3324 chipset */
+#define CX700_FUNCTION2     0x2324
+#define CX700_FUNCTION3     0x3324
+/* VT3204 chipset*/
+#define KM800_FUNCTION3      0x3204
+/* VT3336 chipset*/
+#define KM890_FUNCTION3      0x3336
+/* VT3327 chipset*/
+#define P4M890_FUNCTION3     0x3327
+/* VT3293 chipset*/
+#define CN750_FUNCTION3     0x3208
+/* VT3364 chipset*/
+#define P4M900_FUNCTION3    0x3364
+/* VT3353 chipset*/
+#define VX800_FUNCTION3     0x3353
+
+#define NUM_TOTAL_PLL_TABLE ARRAY_SIZE(pll_value)
+
+struct IODATA {
+	u8 Index;
+	u8 Mask;
+	u8 Data;
+};
+
+struct pci_device_id_info {
+	u32 vendor;
+	u32 device;
+	u32 chip_index;
+};
+
+extern unsigned int viafb_second_virtual_xres;
+extern unsigned int viafb_second_offset;
+extern int viafb_second_size;
+extern int viafb_SAMM_ON;
+extern int viafb_dual_fb;
+extern int viafb_LCD2_ON;
+extern int viafb_LCD_ON;
+extern int viafb_DVI_ON;
+extern int viafb_accel;
+extern int viafb_hotplug;
+
+void viafb_write_reg_mask(u8 index, int io_port, u8 data, u8 mask);
+void viafb_set_output_path(int device, int set_iga,
+	int output_interface);
+void viafb_fill_crtc_timing(struct crt_mode_table *crt_table,
+		      int mode_index, int bpp_byte, int set_iga);
+
+void viafb_set_vclock(u32 CLK, int set_iga);
+void viafb_load_reg(int timing_value, int viafb_load_reg_num,
+	struct io_register *reg,
+	      int io_type);
+void viafb_crt_disable(void);
+void viafb_crt_enable(void);
+void init_ad9389(void);
+/* Access I/O Function */
+void viafb_write_reg(u8 index, u16 io_port, u8 data);
+u8 viafb_read_reg(int io_port, u8 index);
+void viafb_lock_crt(void);
+void viafb_unlock_crt(void);
+void viafb_load_offset_reg(int h_addr, int bpp_byte, int set_iga);
+void viafb_load_fetch_count_reg(int h_addr, int bpp_byte, int set_iga);
+void viafb_write_regx(struct io_reg RegTable[], int ItemNum);
+struct VideoModeTable *viafb_get_modetbl_pointer(int Index);
+u32 viafb_get_clk_value(int clk);
+void viafb_load_FIFO_reg(int set_iga, int hor_active, int ver_active);
+void viafb_set_color_depth(int bpp_byte, int set_iga);
+void viafb_set_dpa_gfx(int output_interface, struct GFX_DPA_SETTING\
+					*p_gfx_dpa_setting);
+
+int viafb_setmode(int vmode_index, int hor_res, int ver_res,
+	    int video_bpp, int vmode_index1, int hor_res1,
+	    int ver_res1, int video_bpp1);
+void viafb_init_chip_info(void);
+void viafb_init_dac(int set_iga);
+int viafb_get_pixclock(int hres, int vres, int vmode_refresh);
+int viafb_get_refresh(int hres, int vres, u32 float_refresh);
+void viafb_update_device_setting(int hres, int vres, int bpp,
+			   int vmode_refresh, int flag);
+void viafb_get_mmio_info(unsigned long *mmio_base,
+	unsigned long *mmio_len);
+
+void viafb_set_iga_path(void);
+void viafb_set_start_addr(void);
+void viafb_get_fb_info(unsigned int *fb_base, unsigned int *fb_len);
+
+#endif /* __HW_H__ */
--- /dev/null
+++ b/drivers/video/via/iface.c
@@ -0,0 +1,78 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "global.h"
+
+/* Get frame buffer size from VGA BIOS */
+
+unsigned int viafb_get_memsize(void)
+{
+	unsigned int m;
+
+	/* If memory size provided by user */
+	if (viafb_memsize)
+		m = viafb_memsize * Mb;
+	else {
+		m = (unsigned int)viafb_read_reg(VIASR, SR39);
+		m = m * (4 * Mb);
+
+		if ((m < (16 * Mb)) || (m > (64 * Mb)))
+			m = 16 * Mb;
+	}
+	DEBUG_MSG(KERN_INFO "framebuffer size = %d Mb\n", m / Mb);
+	return m;
+}
+
+/* Get Video Buffer Starting Physical Address(back door)*/
+
+unsigned long viafb_get_videobuf_addr(void)
+{
+	struct pci_dev *pdev = NULL;
+	unsigned char sys_mem;
+	unsigned char video_mem;
+	unsigned long sys_mem_size;
+	unsigned long video_mem_size;
+	/*system memory = 256 MB, video memory 64 MB */
+	unsigned long vmem_starting_adr = 0x0C000000;
+
+	pdev =
+	    (struct pci_dev *)pci_get_device(VIA_K800_BRIDGE_VID,
+					     VIA_K800_BRIDGE_DID, NULL);
+	if (pdev != NULL) {
+		pci_read_config_byte(pdev, VIA_K800_SYSTEM_MEMORY_REG,
+				     &sys_mem);
+		pci_read_config_byte(pdev, VIA_K800_VIDEO_MEMORY_REG,
+				     &video_mem);
+		video_mem = (video_mem & 0x70) >> 4;
+		sys_mem_size = ((unsigned long)sys_mem) << 24;
+		if (video_mem != 0)
+			video_mem_size = (1 << (video_mem)) * 1024 * 1024;
+		else
+			video_mem_size = 0;
+
+		vmem_starting_adr = sys_mem_size - video_mem_size;
+		pci_dev_put(pdev);
+	}
+
+	DEBUG_MSG(KERN_INFO "Video Memory Starting Address = %lx \n",
+		  vmem_starting_adr);
+	return vmem_starting_adr;
+}
--- /dev/null
+++ b/drivers/video/via/iface.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __IFACE_H__
+#define __IFACE_H__
+
+#define Kb  (1024)
+#define Mb  (Kb*Kb)
+
+#define VIA_K800_BRIDGE_VID         0x1106
+#define VIA_K800_BRIDGE_DID         0x3204
+
+#define VIA_K800_SYSTEM_MEMORY_REG  0x47
+#define VIA_K800_VIDEO_MEMORY_REG   0xA1
+
+extern int viafb_memsize;
+unsigned int viafb_get_memsize(void);
+unsigned long viafb_get_videobuf_addr(void);
+
+#endif /* __IFACE_H__ */
--- /dev/null
+++ b/drivers/video/via/ioctl.c
@@ -0,0 +1,112 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "global.h"
+
+int viafb_ioctl_get_viafb_info(u_long arg)
+{
+	struct viafb_ioctl_info viainfo;
+
+	viainfo.viafb_id = VIAID;
+	viainfo.vendor_id = PCI_VIA_VENDOR_ID;
+
+	switch (viaparinfo->chip_info->gfx_chip_name) {
+	case UNICHROME_CLE266:
+		viainfo.device_id = UNICHROME_CLE266_DID;
+		break;
+
+	case UNICHROME_K400:
+		viainfo.device_id = UNICHROME_K400_DID;
+		break;
+
+	case UNICHROME_K800:
+		viainfo.device_id = UNICHROME_K800_DID;
+		break;
+
+	case UNICHROME_PM800:
+		viainfo.device_id = UNICHROME_PM800_DID;
+		break;
+
+	case UNICHROME_CN700:
+		viainfo.device_id = UNICHROME_CN700_DID;
+		break;
+
+	case UNICHROME_CX700:
+		viainfo.device_id = UNICHROME_CX700_DID;
+		break;
+
+	case UNICHROME_K8M890:
+		viainfo.device_id = UNICHROME_K8M890_DID;
+		break;
+
+	case UNICHROME_P4M890:
+		viainfo.device_id = UNICHROME_P4M890_DID;
+		break;
+
+	case UNICHROME_P4M900:
+		viainfo.device_id = UNICHROME_P4M900_DID;
+		break;
+	}
+
+	viainfo.version = VERSION_MAJOR;
+	viainfo.revision = VERSION_MINOR;
+
+	if (copy_to_user((void __user *)arg, &viainfo, sizeof(viainfo)))
+		return -EFAULT;
+
+	return 0;
+}
+
+/* Hot-Plug Priority: DVI > CRT*/
+int viafb_ioctl_hotplug(int hres, int vres, int bpp)
+{
+	int DVIsense, status = 0;
+	DEBUG_MSG(KERN_INFO "viafb_ioctl_hotplug!!\n");
+
+	if (viaparinfo->chip_info->tmds_chip_info.tmds_chip_name !=
+		NON_TMDS_TRANSMITTER) {
+		DVIsense = viafb_dvi_sense();
+
+		if (DVIsense) {
+			DEBUG_MSG(KERN_INFO "DVI Attached...\n");
+			if (viafb_DeviceStatus != DVI_Device) {
+				viafb_DVI_ON = 1;
+				viafb_CRT_ON = 0;
+				viafb_LCD_ON = 0;
+				viafb_DeviceStatus = DVI_Device;
+				return viafb_DeviceStatus;
+			}
+			status = 1;
+		} else
+			DEBUG_MSG(KERN_INFO "DVI De-attached...\n");
+	}
+
+	if ((viafb_DeviceStatus != CRT_Device) && (status == 0)) {
+		viafb_CRT_ON = 1;
+		viafb_DVI_ON = 0;
+		viafb_LCD_ON = 0;
+
+		viafb_DeviceStatus = CRT_Device;
+		return viafb_DeviceStatus;
+	}
+
+	return 0;
+}
--- /dev/null
+++ b/drivers/video/via/ioctl.h
@@ -0,0 +1,210 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __IOCTL_H__
+#define __IOCTL_H__
+
+#ifndef __user
+#define __user
+#endif
+
+/* VIAFB IOCTL definition */
+#define VIAFB_GET_INFO_SIZE		0x56494101	/* 'VIA\01' */
+#define VIAFB_GET_INFO			0x56494102	/* 'VIA\02' */
+#define VIAFB_HOTPLUG			0x56494103	/* 'VIA\03' */
+#define VIAFB_SET_HOTPLUG_FLAG		0x56494104	/* 'VIA\04' */
+#define VIAFB_GET_RESOLUTION		0x56494105	/* 'VIA\05' */
+#define VIAFB_GET_SAMM_INFO		0x56494107	/* 'VIA\07' */
+#define VIAFB_TURN_ON_OUTPUT_DEVICE     0x56494108	/* 'VIA\08' */
+#define VIAFB_TURN_OFF_OUTPUT_DEVICE    0x56494109	/* 'VIA\09' */
+#define VIAFB_SET_DEVICE		0x5649410A
+#define VIAFB_GET_DEVICE		0x5649410B
+#define VIAFB_GET_DRIVER_VERSION	0x56494112	/* 'VIA\12' */
+#define VIAFB_GET_CHIP_INFO		0x56494113	/* 'VIA\13' */
+#define VIAFB_SET_DEVICE_INFO           0x56494114
+#define VIAFB_GET_DEVICE_INFO           0x56494115
+
+#define VIAFB_GET_DEVICE_SUPPORT	0x56494118
+#define VIAFB_GET_DEVICE_CONNECT	0x56494119
+#define VIAFB_GET_PANEL_SUPPORT_EXPAND	0x5649411A
+#define VIAFB_GET_DRIVER_NAME		0x56494122
+#define VIAFB_GET_DEVICE_SUPPORT_STATE	0x56494123
+#define VIAFB_GET_GAMMA_LUT		0x56494124
+#define VIAFB_SET_GAMMA_LUT		0x56494125
+#define VIAFB_GET_GAMMA_SUPPORT_STATE	0x56494126
+#define VIAFB_SET_VIDEO_DEVICE		0x56494127
+#define VIAFB_GET_VIDEO_DEVICE		0x56494128
+#define VIAFB_SET_SECOND_MODE		0x56494129
+#define VIAFB_SYNC_SURFACE		0x56494130
+#define VIAFB_GET_DRIVER_CAPS		0x56494131
+#define VIAFB_GET_IGA_SCALING_INFO	0x56494132
+#define VIAFB_GET_PANEL_MAX_SIZE	0x56494133
+#define VIAFB_GET_PANEL_MAX_POSITION	0x56494134
+#define VIAFB_SET_PANEL_SIZE		0x56494135
+#define VIAFB_SET_PANEL_POSITION        0x56494136
+#define VIAFB_GET_PANEL_POSITION        0x56494137
+#define VIAFB_GET_PANEL_SIZE		0x56494138
+
+#define None_Device 0x00
+#define CRT_Device  0x01
+#define LCD_Device  0x02
+#define DVI_Device  0x08
+#define CRT2_Device 0x10
+#define LCD2_Device 0x40
+
+#define OP_LCD_CENTERING   0x01
+#define OP_LCD_PANEL_ID    0x02
+#define OP_LCD_MODE        0x03
+
+/*SAMM operation flag*/
+#define OP_SAMM            0x80
+
+#define LCD_PANEL_ID_MAXIMUM	22
+
+#define STATE_ON            0x1
+#define STATE_OFF           0x0
+#define STATE_DEFAULT       0xFFFF
+
+#define MAX_ACTIVE_DEV_NUM  2
+
+struct device_t {
+	unsigned short crt:1;
+	unsigned short dvi:1;
+	unsigned short lcd:1;
+	unsigned short samm:1;
+	unsigned short lcd_dsp_cent:1;
+	unsigned char lcd_mode:1;
+	unsigned short epia_dvi:1;
+	unsigned short lcd_dual_edge:1;
+	unsigned short lcd2:1;
+
+	unsigned short primary_dev;
+	unsigned char lcd_panel_id;
+	unsigned short xres, yres;
+	unsigned short xres1, yres1;
+	unsigned short refresh;
+	unsigned short bpp;
+	unsigned short refresh1;
+	unsigned short bpp1;
+	unsigned short sequence;
+	unsigned short bus_width;
+};
+
+struct viafb_ioctl_info {
+	u32 viafb_id;		/* for identifying viafb */
+#define VIAID       0x56494146	/* Identify myself with 'VIAF' */
+	u16 vendor_id;
+	u16 device_id;
+	u8 version;
+	u8 revision;
+	u8 reserved[246];	/* for future use */
+};
+
+struct viafb_ioctl_mode {
+	u32 xres;
+	u32 yres;
+	u32 refresh;
+	u32 bpp;
+	u32 xres_sec;
+	u32 yres_sec;
+	u32 virtual_xres_sec;
+	u32 virtual_yres_sec;
+	u32 refresh_sec;
+	u32 bpp_sec;
+};
+struct viafb_ioctl_samm {
+	u32 samm_status;
+	u32 size_prim;
+	u32 size_sec;
+	u32 mem_base;
+	u32 offset_sec;
+};
+
+struct viafb_driver_version {
+	int iMajorNum;
+	int iKernelNum;
+	int iOSNum;
+	int iMinorNum;
+};
+
+struct viafb_ioctl_lcd_attribute {
+	unsigned int panel_id;
+	unsigned int display_center;
+	unsigned int lcd_mode;
+};
+
+struct viafb_ioctl_setting {
+	/* Enable or disable active devices */
+	unsigned short device_flag;
+	/* Indicate which device should be turn on or turn off. */
+	unsigned short device_status;
+	unsigned int reserved;
+	/* Indicate which LCD's attribute can be changed. */
+	unsigned short lcd_operation_flag;
+	/* 1: SAMM ON  0: SAMM OFF */
+	unsigned short samm_status;
+	/* horizontal resolution of first device */
+	unsigned short first_dev_hor_res;
+	/* vertical resolution of first device */
+	unsigned short first_dev_ver_res;
+	/* horizontal resolution of second device */
+	unsigned short second_dev_hor_res;
+	/* vertical resolution of second device */
+	unsigned short second_dev_ver_res;
+	/* refresh rate of first device */
+	unsigned short first_dev_refresh;
+	/* bpp of first device */
+	unsigned short first_dev_bpp;
+	/* refresh rate of second device */
+	unsigned short second_dev_refresh;
+	/* bpp of second device */
+	unsigned short second_dev_bpp;
+	/* Indicate which device are primary display device. */
+	unsigned int primary_device;
+	/* Indicate which device will show video. only valid in duoview mode */
+	unsigned int video_device_status;
+	unsigned int struct_reserved[34];
+	struct viafb_ioctl_lcd_attribute lcd_attributes;
+};
+
+struct _UTFunctionCaps {
+	unsigned int dw3DScalingState;
+	unsigned int reserved[31];
+};
+
+struct _POSITIONVALUE {
+	unsigned int dwX;
+	unsigned int dwY;
+};
+
+struct _panel_size_pos_info {
+	unsigned int device_type;
+	int x;
+	int y;
+};
+
+extern int viafb_LCD_ON;
+extern int viafb_DVI_ON;
+
+int viafb_ioctl_get_viafb_info(u_long arg);
+int viafb_ioctl_hotplug(int hres, int vres, int bpp);
+
+#endif /* __IOCTL_H__ */
--- /dev/null
+++ b/drivers/video/via/lcd.c
@@ -0,0 +1,1821 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "global.h"
+#include "lcdtbl.h"
+
+static struct iga2_shadow_crtc_timing iga2_shadow_crtc_reg = {
+	/* IGA2 Shadow Horizontal Total */
+	{IGA2_SHADOW_HOR_TOTAL_REG_NUM, {{CR6D, 0, 7}, {CR71, 3, 3} } },
+	/* IGA2 Shadow Horizontal Blank End */
+	{IGA2_SHADOW_HOR_BLANK_END_REG_NUM, {{CR6E, 0, 7} } },
+	/* IGA2 Shadow Vertical Total */
+	{IGA2_SHADOW_VER_TOTAL_REG_NUM, {{CR6F, 0, 7}, {CR71, 0, 2} } },
+	/* IGA2 Shadow Vertical Addressable Video */
+	{IGA2_SHADOW_VER_ADDR_REG_NUM, {{CR70, 0, 7}, {CR71, 4, 6} } },
+	/* IGA2 Shadow Vertical Blank Start */
+	{IGA2_SHADOW_VER_BLANK_START_REG_NUM,
+	 {{CR72, 0, 7}, {CR74, 4, 6} } },
+	/* IGA2 Shadow Vertical Blank End */
+	{IGA2_SHADOW_VER_BLANK_END_REG_NUM, {{CR73, 0, 7}, {CR74, 0, 2} } },
+	/* IGA2 Shadow Vertical Sync Start */
+	{IGA2_SHADOW_VER_SYNC_START_REG_NUM, {{CR75, 0, 7}, {CR76, 4, 6} } },
+	/* IGA2 Shadow Vertical Sync End */
+	{IGA2_SHADOW_VER_SYNC_END_REG_NUM, {{CR76, 0, 3} } }
+};
+
+static struct _lcd_scaling_factor lcd_scaling_factor = {
+	/* LCD Horizontal Scaling Factor Register */
+	{LCD_HOR_SCALING_FACTOR_REG_NUM,
+	 {{CR9F, 0, 1}, {CR77, 0, 7}, {CR79, 4, 5} } },
+	/* LCD Vertical Scaling Factor Register */
+	{LCD_VER_SCALING_FACTOR_REG_NUM,
+	 {{CR79, 3, 3}, {CR78, 0, 7}, {CR79, 6, 7} } }
+};
+static struct _lcd_scaling_factor lcd_scaling_factor_CLE = {
+	/* LCD Horizontal Scaling Factor Register */
+	{LCD_HOR_SCALING_FACTOR_REG_NUM_CLE, {{CR77, 0, 7}, {CR79, 4, 5} } },
+	/* LCD Vertical Scaling Factor Register */
+	{LCD_VER_SCALING_FACTOR_REG_NUM_CLE, {{CR78, 0, 7}, {CR79, 6, 7} } }
+};
+
+static int check_lvds_chip(int device_id_subaddr, int device_id);
+static bool lvds_identify_integratedlvds(void);
+static int fp_id_to_vindex(int panel_id);
+static int lvds_register_read(int index);
+static void load_lcd_scaling(int set_hres, int set_vres, int panel_hres,
+		      int panel_vres);
+static void load_lcd_k400_patch_tbl(int set_hres, int set_vres,
+	int panel_id);
+static void load_lcd_p880_patch_tbl(int set_hres, int set_vres,
+	int panel_id);
+static void load_lcd_patch_regs(int set_hres, int set_vres,
+	int panel_id, int set_iga);
+static void via_pitch_alignment_patch_lcd(
+	struct lvds_setting_information *plvds_setting_info,
+				   struct lvds_chip_information
+				   *plvds_chip_info);
+static void lcd_patch_skew_dvp0(struct lvds_setting_information
+			 *plvds_setting_info,
+			 struct lvds_chip_information *plvds_chip_info);
+static void lcd_patch_skew_dvp1(struct lvds_setting_information
+			 *plvds_setting_info,
+			 struct lvds_chip_information *plvds_chip_info);
+static void lcd_patch_skew(struct lvds_setting_information
+	*plvds_setting_info, struct lvds_chip_information *plvds_chip_info);
+
+static void integrated_lvds_disable(struct lvds_setting_information
+			     *plvds_setting_info,
+			     struct lvds_chip_information *plvds_chip_info);
+static void integrated_lvds_enable(struct lvds_setting_information
+			    *plvds_setting_info,
+			    struct lvds_chip_information *plvds_chip_info);
+static void lcd_powersequence_off(void);
+static void lcd_powersequence_on(void);
+static void fill_lcd_format(void);
+static void check_diport_of_integrated_lvds(
+	struct lvds_chip_information *plvds_chip_info,
+				     struct lvds_setting_information
+				     *plvds_setting_info);
+static struct display_timing lcd_centering_timging(struct display_timing
+					    mode_crt_reg,
+					   struct display_timing panel_crt_reg);
+static void load_crtc_shadow_timing(struct display_timing mode_timing,
+			     struct display_timing panel_timing);
+static void viafb_load_scaling_factor_for_p4m900(int set_hres,
+	int set_vres, int panel_hres, int panel_vres);
+
+static int check_lvds_chip(int device_id_subaddr, int device_id)
+{
+	if (lvds_register_read(device_id_subaddr) == device_id)
+		return OK;
+	else
+		return FAIL;
+}
+
+void viafb_init_lcd_size(void)
+{
+	DEBUG_MSG(KERN_INFO "viafb_init_lcd_size()\n");
+	DEBUG_MSG(KERN_INFO
+		"viaparinfo->lvds_setting_info->get_lcd_size_method %d\n",
+		viaparinfo->lvds_setting_info->get_lcd_size_method);
+
+	switch (viaparinfo->lvds_setting_info->get_lcd_size_method) {
+	case GET_LCD_SIZE_BY_SYSTEM_BIOS:
+		break;
+	case GET_LCD_SZIE_BY_HW_STRAPPING:
+		break;
+	case GET_LCD_SIZE_BY_VGA_BIOS:
+		DEBUG_MSG(KERN_INFO "Get LCD Size method by VGA BIOS !!\n");
+		viaparinfo->lvds_setting_info->lcd_panel_size =
+		    fp_id_to_vindex(viafb_lcd_panel_id);
+		DEBUG_MSG(KERN_INFO "LCD Panel_ID = %d\n",
+			  viaparinfo->lvds_setting_info->lcd_panel_id);
+		DEBUG_MSG(KERN_INFO "LCD Panel Size = %d\n",
+			  viaparinfo->lvds_setting_info->lcd_panel_size);
+		break;
+	case GET_LCD_SIZE_BY_USER_SETTING:
+		DEBUG_MSG(KERN_INFO "Get LCD Size method by user setting !!\n");
+		viaparinfo->lvds_setting_info->lcd_panel_size =
+		    fp_id_to_vindex(viafb_lcd_panel_id);
+		DEBUG_MSG(KERN_INFO "LCD Panel_ID = %d\n",
+			  viaparinfo->lvds_setting_info->lcd_panel_id);
+		DEBUG_MSG(KERN_INFO "LCD Panel Size = %d\n",
+			  viaparinfo->lvds_setting_info->lcd_panel_size);
+		break;
+	default:
+		DEBUG_MSG(KERN_INFO "viafb_init_lcd_size fail\n");
+		viaparinfo->lvds_setting_info->lcd_panel_id =
+			LCD_PANEL_ID1_800X600;
+		viaparinfo->lvds_setting_info->lcd_panel_size =
+		    fp_id_to_vindex(LCD_PANEL_ID1_800X600);
+	}
+	viaparinfo->lvds_setting_info2->lcd_panel_id =
+		viaparinfo->lvds_setting_info->lcd_panel_id;
+	viaparinfo->lvds_setting_info2->lcd_panel_size =
+		viaparinfo->lvds_setting_info->lcd_panel_size;
+	viaparinfo->lvds_setting_info2->lcd_panel_hres =
+		viaparinfo->lvds_setting_info->lcd_panel_hres;
+	viaparinfo->lvds_setting_info2->lcd_panel_vres =
+		viaparinfo->lvds_setting_info->lcd_panel_vres;
+	viaparinfo->lvds_setting_info2->device_lcd_dualedge =
+	    viaparinfo->lvds_setting_info->device_lcd_dualedge;
+	viaparinfo->lvds_setting_info2->LCDDithering =
+		viaparinfo->lvds_setting_info->LCDDithering;
+}
+
+static bool lvds_identify_integratedlvds(void)
+{
+	if (viafb_display_hardware_layout == HW_LAYOUT_LCD_EXTERNAL_LCD2) {
+		/* Two dual channel LCD (Internal LVDS + External LVDS): */
+		/* If we have an external LVDS, such as VT1636, we should
+		   have its chip ID already. */
+		if (viaparinfo->chip_info->lvds_chip_info.lvds_chip_name) {
+			viaparinfo->chip_info->lvds_chip_info2.lvds_chip_name =
+			    INTEGRATED_LVDS;
+			DEBUG_MSG(KERN_INFO "Support two dual channel LVDS!\
+				  (Internal LVDS + External LVDS)\n");
+		} else {
+			viaparinfo->chip_info->lvds_chip_info.lvds_chip_name =
+			    INTEGRATED_LVDS;
+			DEBUG_MSG(KERN_INFO "Not found external LVDS,\
+				  so can't support two dual channel LVDS!\n");
+		}
+	} else if (viafb_display_hardware_layout == HW_LAYOUT_LCD1_LCD2) {
+		/* Two single channel LCD (Internal LVDS + Internal LVDS): */
+		viaparinfo->chip_info->lvds_chip_info.lvds_chip_name =
+		INTEGRATED_LVDS;
+		viaparinfo->chip_info->lvds_chip_info2.lvds_chip_name =
+			INTEGRATED_LVDS;
+		DEBUG_MSG(KERN_INFO "Support two single channel LVDS!\
+			  (Internal LVDS + Internal LVDS)\n");
+	} else if (viafb_display_hardware_layout != HW_LAYOUT_DVI_ONLY) {
+		/* If we have found external LVDS, just use it,
+		   otherwise, we will use internal LVDS as default. */
+		if (!viaparinfo->chip_info->lvds_chip_info.lvds_chip_name) {
+			viaparinfo->chip_info->lvds_chip_info.lvds_chip_name =
+			    INTEGRATED_LVDS;
+			DEBUG_MSG(KERN_INFO "Found Integrated LVDS!\n");
+		}
+	} else {
+		viaparinfo->chip_info->lvds_chip_info.lvds_chip_name =
+			NON_LVDS_TRANSMITTER;
+		DEBUG_MSG(KERN_INFO "Do not support LVDS!\n");
+		return false;
+	}
+
+	return true;
+}
+
+int viafb_lvds_trasmitter_identify(void)
+{
+	viaparinfo->i2c_stuff.i2c_port = I2CPORTINDEX;
+	if (viafb_lvds_identify_vt1636()) {
+		viaparinfo->chip_info->lvds_chip_info.i2c_port = I2CPORTINDEX;
+		DEBUG_MSG(KERN_INFO
+			  "Found VIA VT1636 LVDS on port i2c 0x31 \n");
+	} else {
+		viaparinfo->i2c_stuff.i2c_port = GPIOPORTINDEX;
+		if (viafb_lvds_identify_vt1636()) {
+			viaparinfo->chip_info->lvds_chip_info.i2c_port =
+				GPIOPORTINDEX;
+			DEBUG_MSG(KERN_INFO
+				  "Found VIA VT1636 LVDS on port gpio 0x2c \n");
+		}
+	}
+
+	if (viaparinfo->chip_info->gfx_chip_name == UNICHROME_CX700)
+		lvds_identify_integratedlvds();
+
+	if (viaparinfo->chip_info->lvds_chip_info.lvds_chip_name)
+		return true;
+	/* Check for VT1631: */
+	viaparinfo->chip_info->lvds_chip_info.lvds_chip_name = VT1631_LVDS;
+	viaparinfo->chip_info->lvds_chip_info.lvds_chip_slave_addr =
+		VT1631_LVDS_I2C_ADDR;
+
+	if (check_lvds_chip(VT1631_DEVICE_ID_REG, VT1631_DEVICE_ID) != FAIL) {
+		DEBUG_MSG(KERN_INFO "\n VT1631 LVDS ! \n");
+		DEBUG_MSG(KERN_INFO "\n %2d",
+			  viaparinfo->chip_info->lvds_chip_info.lvds_chip_name);
+		DEBUG_MSG(KERN_INFO "\n %2d",
+			  viaparinfo->chip_info->lvds_chip_info.lvds_chip_name);
+		return OK;
+	}
+
+	viaparinfo->chip_info->lvds_chip_info.lvds_chip_name =
+		NON_LVDS_TRANSMITTER;
+	viaparinfo->chip_info->lvds_chip_info.lvds_chip_slave_addr =
+		VT1631_LVDS_I2C_ADDR;
+	return FAIL;
+}
+
+static int fp_id_to_vindex(int panel_id)
+{
+	DEBUG_MSG(KERN_INFO "fp_get_panel_id()\n");
+
+	if (panel_id > LCD_PANEL_ID_MAXIMUM)
+		viafb_lcd_panel_id = panel_id =
+		viafb_read_reg(VIACR, CR3F) & 0x0F;
+
+	switch (panel_id) {
+	case 0x0:
+		viaparinfo->lvds_setting_info->lcd_panel_hres = 640;
+		viaparinfo->lvds_setting_info->lcd_panel_vres = 480;
+		viaparinfo->lvds_setting_info->lcd_panel_id =
+			LCD_PANEL_ID0_640X480;
+		viaparinfo->lvds_setting_info->device_lcd_dualedge = 0;
+		viaparinfo->lvds_setting_info->LCDDithering = 1;
+		return VIA_RES_640X480;
+		break;
+	case 0x1:
+		viaparinfo->lvds_setting_info->lcd_panel_hres = 800;
+		viaparinfo->lvds_setting_info->lcd_panel_vres = 600;
+		viaparinfo->lvds_setting_info->lcd_panel_id =
+			LCD_PANEL_ID1_800X600;
+		viaparinfo->lvds_setting_info->device_lcd_dualedge = 0;
+		viaparinfo->lvds_setting_info->LCDDithering = 1;
+		return VIA_RES_800X600;
+		break;
+	case 0x2:
+		viaparinfo->lvds_setting_info->lcd_panel_hres = 1024;
+		viaparinfo->lvds_setting_info->lcd_panel_vres = 768;
+		viaparinfo->lvds_setting_info->lcd_panel_id =
+			LCD_PANEL_ID2_1024X768;
+		viaparinfo->lvds_setting_info->device_lcd_dualedge = 0;
+		viaparinfo->lvds_setting_info->LCDDithering = 1;
+		return VIA_RES_1024X768;
+		break;
+	case 0x3:
+		viaparinfo->lvds_setting_info->lcd_panel_hres = 1280;
+		viaparinfo->lvds_setting_info->lcd_panel_vres = 768;
+		viaparinfo->lvds_setting_info->lcd_panel_id =
+			LCD_PANEL_ID3_1280X768;
+		viaparinfo->lvds_setting_info->device_lcd_dualedge = 0;
+		viaparinfo->lvds_setting_info->LCDDithering = 1;
+		return VIA_RES_1280X768;
+		break;
+	case 0x4:
+		viaparinfo->lvds_setting_info->lcd_panel_hres = 1280;
+		viaparinfo->lvds_setting_info->lcd_panel_vres = 1024;
+		viaparinfo->lvds_setting_info->lcd_panel_id =
+			LCD_PANEL_ID4_1280X1024;
+		viaparinfo->lvds_setting_info->device_lcd_dualedge = 1;
+		viaparinfo->lvds_setting_info->LCDDithering = 1;
+		return VIA_RES_1280X1024;
+		break;
+	case 0x5:
+		viaparinfo->lvds_setting_info->lcd_panel_hres = 1400;
+		viaparinfo->lvds_setting_info->lcd_panel_vres = 1050;
+		viaparinfo->lvds_setting_info->lcd_panel_id =
+			LCD_PANEL_ID5_1400X1050;
+		viaparinfo->lvds_setting_info->device_lcd_dualedge = 1;
+		viaparinfo->lvds_setting_info->LCDDithering = 1;
+		return VIA_RES_1400X1050;
+		break;
+	case 0x6:
+		viaparinfo->lvds_setting_info->lcd_panel_hres = 1600;
+		viaparinfo->lvds_setting_info->lcd_panel_vres = 1200;
+		viaparinfo->lvds_setting_info->lcd_panel_id =
+			LCD_PANEL_ID6_1600X1200;
+		viaparinfo->lvds_setting_info->device_lcd_dualedge = 1;
+		viaparinfo->lvds_setting_info->LCDDithering = 1;
+		return VIA_RES_1600X1200;
+		break;
+	case 0x8:
+		viaparinfo->lvds_setting_info->lcd_panel_hres = 800;
+		viaparinfo->lvds_setting_info->lcd_panel_vres = 480;
+		viaparinfo->lvds_setting_info->lcd_panel_id =
+			LCD_PANEL_IDA_800X480;
+		viaparinfo->lvds_setting_info->device_lcd_dualedge = 0;
+		viaparinfo->lvds_setting_info->LCDDithering = 1;
+		return VIA_RES_800X480;
+		break;
+	case 0x9:
+		viaparinfo->lvds_setting_info->lcd_panel_hres = 1024;
+		viaparinfo->lvds_setting_info->lcd_panel_vres = 768;
+		viaparinfo->lvds_setting_info->lcd_panel_id =
+			LCD_PANEL_ID2_1024X768;
+		viaparinfo->lvds_setting_info->device_lcd_dualedge = 1;
+		viaparinfo->lvds_setting_info->LCDDithering = 1;
+		return VIA_RES_1024X768;
+		break;
+	case 0xA:
+		viaparinfo->lvds_setting_info->lcd_panel_hres = 1024;
+		viaparinfo->lvds_setting_info->lcd_panel_vres = 768;
+		viaparinfo->lvds_setting_info->lcd_panel_id =
+			LCD_PANEL_ID2_1024X768;
+		viaparinfo->lvds_setting_info->device_lcd_dualedge = 0;
+		viaparinfo->lvds_setting_info->LCDDithering = 0;
+		return VIA_RES_1024X768;
+		break;
+	case 0xB:
+		viaparinfo->lvds_setting_info->lcd_panel_hres = 1024;
+		viaparinfo->lvds_setting_info->lcd_panel_vres = 768;
+		viaparinfo->lvds_setting_info->lcd_panel_id =
+			LCD_PANEL_ID2_1024X768;
+		viaparinfo->lvds_setting_info->device_lcd_dualedge = 1;
+		viaparinfo->lvds_setting_info->LCDDithering = 0;
+		return VIA_RES_1024X768;
+		break;
+	case 0xC:
+		viaparinfo->lvds_setting_info->lcd_panel_hres = 1280;
+		viaparinfo->lvds_setting_info->lcd_panel_vres = 768;
+		viaparinfo->lvds_setting_info->lcd_panel_id =
+			LCD_PANEL_ID3_1280X768;
+		viaparinfo->lvds_setting_info->device_lcd_dualedge = 0;
+		viaparinfo->lvds_setting_info->LCDDithering = 0;
+		return VIA_RES_1280X768;
+		break;
+	case 0xD:
+		viaparinfo->lvds_setting_info->lcd_panel_hres = 1280;
+		viaparinfo->lvds_setting_info->lcd_panel_vres = 1024;
+		viaparinfo->lvds_setting_info->lcd_panel_id =
+			LCD_PANEL_ID4_1280X1024;
+		viaparinfo->lvds_setting_info->device_lcd_dualedge = 1;
+		viaparinfo->lvds_setting_info->LCDDithering = 0;
+		return VIA_RES_1280X1024;
+		break;
+	case 0xE:
+		viaparinfo->lvds_setting_info->lcd_panel_hres = 1400;
+		viaparinfo->lvds_setting_info->lcd_panel_vres = 1050;
+		viaparinfo->lvds_setting_info->lcd_panel_id =
+			LCD_PANEL_ID5_1400X1050;
+		viaparinfo->lvds_setting_info->device_lcd_dualedge = 1;
+		viaparinfo->lvds_setting_info->LCDDithering = 0;
+		return VIA_RES_1400X1050;
+		break;
+	case 0xF:
+		viaparinfo->lvds_setting_info->lcd_panel_hres = 1600;
+		viaparinfo->lvds_setting_info->lcd_panel_vres = 1200;
+		viaparinfo->lvds_setting_info->lcd_panel_id =
+			LCD_PANEL_ID6_1600X1200;
+		viaparinfo->lvds_setting_info->device_lcd_dualedge = 1;
+		viaparinfo->lvds_setting_info->LCDDithering = 0;
+		return VIA_RES_1600X1200;
+		break;
+	case 0x10:
+		viaparinfo->lvds_setting_info->lcd_panel_hres = 1366;
+		viaparinfo->lvds_setting_info->lcd_panel_vres = 768;
+		viaparinfo->lvds_setting_info->lcd_panel_id =
+			LCD_PANEL_ID7_1366X768;
+		viaparinfo->lvds_setting_info->device_lcd_dualedge = 0;
+		viaparinfo->lvds_setting_info->LCDDithering = 0;
+		return VIA_RES_1368X768;
+		break;
+	case 0x11:
+		viaparinfo->lvds_setting_info->lcd_panel_hres = 1024;
+		viaparinfo->lvds_setting_info->lcd_panel_vres = 600;
+		viaparinfo->lvds_setting_info->lcd_panel_id =
+			LCD_PANEL_ID8_1024X600;
+		viaparinfo->lvds_setting_info->device_lcd_dualedge = 0;
+		viaparinfo->lvds_setting_info->LCDDithering = 1;
+		return VIA_RES_1024X600;
+		break;
+	case 0x12:
+		viaparinfo->lvds_setting_info->lcd_panel_hres = 1280;
+		viaparinfo->lvds_setting_info->lcd_panel_vres = 768;
+		viaparinfo->lvds_setting_info->lcd_panel_id =
+			LCD_PANEL_ID3_1280X768;
+		viaparinfo->lvds_setting_info->device_lcd_dualedge = 1;
+		viaparinfo->lvds_setting_info->LCDDithering = 1;
+		return VIA_RES_1280X768;
+		break;
+	case 0x13:
+		viaparinfo->lvds_setting_info->lcd_panel_hres = 1280;
+		viaparinfo->lvds_setting_info->lcd_panel_vres = 800;
+		viaparinfo->lvds_setting_info->lcd_panel_id =
+			LCD_PANEL_ID9_1280X800;
+		viaparinfo->lvds_setting_info->device_lcd_dualedge = 0;
+		viaparinfo->lvds_setting_info->LCDDithering = 1;
+		return VIA_RES_1280X800;
+		break;
+	case 0x14:
+		viaparinfo->lvds_setting_info->lcd_panel_hres = 1360;
+		viaparinfo->lvds_setting_info->lcd_panel_vres = 768;
+		viaparinfo->lvds_setting_info->lcd_panel_id =
+			LCD_PANEL_IDB_1360X768;
+		viaparinfo->lvds_setting_info->device_lcd_dualedge = 0;
+		viaparinfo->lvds_setting_info->LCDDithering = 0;
+		return VIA_RES_1360X768;
+		break;
+	case 0x15:
+		viaparinfo->lvds_setting_info->lcd_panel_hres = 1280;
+		viaparinfo->lvds_setting_info->lcd_panel_vres = 768;
+		viaparinfo->lvds_setting_info->lcd_panel_id =
+			LCD_PANEL_ID3_1280X768;
+		viaparinfo->lvds_setting_info->device_lcd_dualedge = 1;
+		viaparinfo->lvds_setting_info->LCDDithering = 0;
+		return VIA_RES_1280X768;
+		break;
+	case 0x16:
+		viaparinfo->lvds_setting_info->lcd_panel_hres = 480;
+		viaparinfo->lvds_setting_info->lcd_panel_vres = 640;
+		viaparinfo->lvds_setting_info->lcd_panel_id =
+			LCD_PANEL_IDC_480X640;
+		viaparinfo->lvds_setting_info->device_lcd_dualedge = 0;
+		viaparinfo->lvds_setting_info->LCDDithering = 1;
+		return VIA_RES_480X640;
+		break;
+	default:
+		viaparinfo->lvds_setting_info->lcd_panel_hres = 800;
+		viaparinfo->lvds_setting_info->lcd_panel_vres = 600;
+		viaparinfo->lvds_setting_info->lcd_panel_id =
+			LCD_PANEL_ID1_800X600;
+		viaparinfo->lvds_setting_info->device_lcd_dualedge = 0;
+		viaparinfo->lvds_setting_info->LCDDithering = 1;
+		return VIA_RES_800X600;
+	}
+}
+
+static int lvds_register_read(int index)
+{
+	u8 data;
+
+	viaparinfo->i2c_stuff.i2c_port = GPIOPORTINDEX;
+	viafb_i2c_readbyte((u8) viaparinfo->chip_info->
+	    lvds_chip_info.lvds_chip_slave_addr,
+			(u8) index, &data);
+	return data;
+}
+
+static void load_lcd_scaling(int set_hres, int set_vres, int panel_hres,
+		      int panel_vres)
+{
+	int reg_value = 0;
+	int viafb_load_reg_num;
+	struct io_register *reg = NULL;
+
+	DEBUG_MSG(KERN_INFO "load_lcd_scaling()!!\n");
+
+	/* LCD Scaling Enable */
+	viafb_write_reg_mask(CR79, VIACR, 0x07, BIT0 + BIT1 + BIT2);
+	if (UNICHROME_P4M900 == viaparinfo->chip_info->gfx_chip_name) {
+		viafb_load_scaling_factor_for_p4m900(set_hres, set_vres,
+					       panel_hres, panel_vres);
+		return;
+	}
+
+	/* Check if expansion for horizontal */
+	if (set_hres != panel_hres) {
+		/* Load Horizontal Scaling Factor */
+		switch (viaparinfo->chip_info->gfx_chip_name) {
+		case UNICHROME_CLE266:
+		case UNICHROME_K400:
+			reg_value =
+			    CLE266_LCD_HOR_SCF_FORMULA(set_hres, panel_hres);
+			viafb_load_reg_num =
+			    lcd_scaling_factor_CLE.lcd_hor_scaling_factor.
+			    reg_num;
+			reg = lcd_scaling_factor_CLE.lcd_hor_scaling_factor.reg;
+			viafb_load_reg(reg_value,
+				viafb_load_reg_num, reg, VIACR);
+			break;
+		case UNICHROME_K800:
+		case UNICHROME_PM800:
+		case UNICHROME_CN700:
+		case UNICHROME_CX700:
+		case UNICHROME_K8M890:
+		case UNICHROME_P4M890:
+			reg_value =
+			    K800_LCD_HOR_SCF_FORMULA(set_hres, panel_hres);
+			/* Horizontal scaling enabled */
+			viafb_write_reg_mask(CRA2, VIACR, 0xC0, BIT7 + BIT6);
+			viafb_load_reg_num =
+			    lcd_scaling_factor.lcd_hor_scaling_factor.reg_num;
+			reg = lcd_scaling_factor.lcd_hor_scaling_factor.reg;
+			viafb_load_reg(reg_value,
+				viafb_load_reg_num, reg, VIACR);
+			break;
+		}
+
+		DEBUG_MSG(KERN_INFO "Horizontal Scaling value = %d", reg_value);
+	} else {
+		/* Horizontal scaling disabled */
+		viafb_write_reg_mask(CRA2, VIACR, 0x00, BIT7);
+	}
+
+	/* Check if expansion for vertical */
+	if (set_vres != panel_vres) {
+		/* Load Vertical Scaling Factor */
+		switch (viaparinfo->chip_info->gfx_chip_name) {
+		case UNICHROME_CLE266:
+		case UNICHROME_K400:
+			reg_value =
+			    CLE266_LCD_VER_SCF_FORMULA(set_vres, panel_vres);
+			viafb_load_reg_num =
+			    lcd_scaling_factor_CLE.lcd_ver_scaling_factor.
+			    reg_num;
+			reg = lcd_scaling_factor_CLE.lcd_ver_scaling_factor.reg;
+			viafb_load_reg(reg_value,
+				viafb_load_reg_num, reg, VIACR);
+			break;
+		case UNICHROME_K800:
+		case UNICHROME_PM800:
+		case UNICHROME_CN700:
+		case UNICHROME_CX700:
+		case UNICHROME_K8M890:
+		case UNICHROME_P4M890:
+			reg_value =
+			    K800_LCD_VER_SCF_FORMULA(set_vres, panel_vres);
+			/* Vertical scaling enabled */
+			viafb_write_reg_mask(CRA2, VIACR, 0x08, BIT3);
+			viafb_load_reg_num =
+			    lcd_scaling_factor.lcd_ver_scaling_factor.reg_num;
+			reg = lcd_scaling_factor.lcd_ver_scaling_factor.reg;
+			viafb_load_reg(reg_value,
+				viafb_load_reg_num, reg, VIACR);
+			break;
+		}
+
+		DEBUG_MSG(KERN_INFO "Vertical Scaling value = %d", reg_value);
+	} else {
+		/* Vertical scaling disabled */
+		viafb_write_reg_mask(CRA2, VIACR, 0x00, BIT3);
+	}
+}
+
+static void load_lcd_k400_patch_tbl(int set_hres, int set_vres,
+	int panel_id)
+{
+	int vmode_index;
+	int reg_num = 0;
+	struct io_reg *lcd_patch_reg = NULL;
+
+	if (viaparinfo->lvds_setting_info->iga_path == IGA2)
+		vmode_index = viafb_get_mode_index(set_hres, set_vres, 1);
+	else
+		vmode_index = viafb_get_mode_index(set_hres, set_vres, 0);
+	switch (panel_id) {
+		/* LCD 800x600 */
+	case LCD_PANEL_ID1_800X600:
+		switch (vmode_index) {
+		case VIA_RES_640X400:
+		case VIA_RES_640X480:
+			reg_num = NUM_TOTAL_K400_LCD_RES_6X4_8X6;
+			lcd_patch_reg = K400_LCD_RES_6X4_8X6;
+			break;
+		case VIA_RES_720X480:
+		case VIA_RES_720X576:
+			reg_num = NUM_TOTAL_K400_LCD_RES_7X4_8X6;
+			lcd_patch_reg = K400_LCD_RES_7X4_8X6;
+			break;
+		}
+		break;
+
+		/* LCD 1024x768 */
+	case LCD_PANEL_ID2_1024X768:
+		switch (vmode_index) {
+		case VIA_RES_640X400:
+		case VIA_RES_640X480:
+			reg_num = NUM_TOTAL_K400_LCD_RES_6X4_10X7;
+			lcd_patch_reg = K400_LCD_RES_6X4_10X7;
+			break;
+		case VIA_RES_720X480:
+		case VIA_RES_720X576:
+			reg_num = NUM_TOTAL_K400_LCD_RES_7X4_10X7;
+			lcd_patch_reg = K400_LCD_RES_7X4_10X7;
+			break;
+		case VIA_RES_800X600:
+			reg_num = NUM_TOTAL_K400_LCD_RES_8X6_10X7;
+			lcd_patch_reg = K400_LCD_RES_8X6_10X7;
+			break;
+		}
+		break;
+
+		/* LCD 1280x1024 */
+	case LCD_PANEL_ID4_1280X1024:
+		switch (vmode_index) {
+		case VIA_RES_640X400:
+		case VIA_RES_640X480:
+			reg_num = NUM_TOTAL_K400_LCD_RES_6X4_12X10;
+			lcd_patch_reg = K400_LCD_RES_6X4_12X10;
+			break;
+		case VIA_RES_720X480:
+		case VIA_RES_720X576:
+			reg_num = NUM_TOTAL_K400_LCD_RES_7X4_12X10;
+			lcd_patch_reg = K400_LCD_RES_7X4_12X10;
+			break;
+		case VIA_RES_800X600:
+			reg_num = NUM_TOTAL_K400_LCD_RES_8X6_12X10;
+			lcd_patch_reg = K400_LCD_RES_8X6_12X10;
+			break;
+		case VIA_RES_1024X768:
+			reg_num = NUM_TOTAL_K400_LCD_RES_10X7_12X10;
+			lcd_patch_reg = K400_LCD_RES_10X7_12X10;
+			break;
+
+		}
+		break;
+
+		/* LCD 1400x1050 */
+	case LCD_PANEL_ID5_1400X1050:
+		switch (vmode_index) {
+		case VIA_RES_640X480:
+			reg_num = NUM_TOTAL_K400_LCD_RES_6X4_14X10;
+			lcd_patch_reg = K400_LCD_RES_6X4_14X10;
+			break;
+		case VIA_RES_800X600:
+			reg_num = NUM_TOTAL_K400_LCD_RES_8X6_14X10;
+			lcd_patch_reg = K400_LCD_RES_8X6_14X10;
+			break;
+		case VIA_RES_1024X768:
+			reg_num = NUM_TOTAL_K400_LCD_RES_10X7_14X10;
+			lcd_patch_reg = K400_LCD_RES_10X7_14X10;
+			break;
+		case VIA_RES_1280X768:
+		case VIA_RES_1280X800:
+		case VIA_RES_1280X960:
+		case VIA_RES_1280X1024:
+			reg_num = NUM_TOTAL_K400_LCD_RES_12X10_14X10;
+			lcd_patch_reg = K400_LCD_RES_12X10_14X10;
+			break;
+		}
+		break;
+
+		/* LCD 1600x1200 */
+	case LCD_PANEL_ID6_1600X1200:
+		switch (vmode_index) {
+		case VIA_RES_640X400:
+		case VIA_RES_640X480:
+			reg_num = NUM_TOTAL_K400_LCD_RES_6X4_16X12;
+			lcd_patch_reg = K400_LCD_RES_6X4_16X12;
+			break;
+		case VIA_RES_720X480:
+		case VIA_RES_720X576:
+			reg_num = NUM_TOTAL_K400_LCD_RES_7X4_16X12;
+			lcd_patch_reg = K400_LCD_RES_7X4_16X12;
+			break;
+		case VIA_RES_800X600:
+			reg_num = NUM_TOTAL_K400_LCD_RES_8X6_16X12;
+			lcd_patch_reg = K400_LCD_RES_8X6_16X12;
+			break;
+		case VIA_RES_1024X768:
+			reg_num = NUM_TOTAL_K400_LCD_RES_10X7_16X12;
+			lcd_patch_reg = K400_LCD_RES_10X7_16X12;
+			break;
+		case VIA_RES_1280X768:
+		case VIA_RES_1280X800:
+		case VIA_RES_1280X960:
+		case VIA_RES_1280X1024:
+			reg_num = NUM_TOTAL_K400_LCD_RES_12X10_16X12;
+			lcd_patch_reg = K400_LCD_RES_12X10_16X12;
+			break;
+		}
+		break;
+
+		/* LCD 1366x768 */
+	case LCD_PANEL_ID7_1366X768:
+		switch (vmode_index) {
+		case VIA_RES_640X480:
+			reg_num = NUM_TOTAL_K400_LCD_RES_6X4_1366X7;
+			lcd_patch_reg = K400_LCD_RES_6X4_1366X7;
+			break;
+		case VIA_RES_720X480:
+		case VIA_RES_720X576:
+			reg_num = NUM_TOTAL_K400_LCD_RES_7X4_1366X7;
+			lcd_patch_reg = K400_LCD_RES_7X4_1366X7;
+			break;
+		case VIA_RES_800X600:
+			reg_num = NUM_TOTAL_K400_LCD_RES_8X6_1366X7;
+			lcd_patch_reg = K400_LCD_RES_8X6_1366X7;
+			break;
+		case VIA_RES_1024X768:
+			reg_num = NUM_TOTAL_K400_LCD_RES_10X7_1366X7;
+			lcd_patch_reg = K400_LCD_RES_10X7_1366X7;
+			break;
+		case VIA_RES_1280X768:
+		case VIA_RES_1280X800:
+		case VIA_RES_1280X960:
+		case VIA_RES_1280X1024:
+			reg_num = NUM_TOTAL_K400_LCD_RES_12X10_1366X7;
+			lcd_patch_reg = K400_LCD_RES_12X10_1366X7;
+			break;
+		}
+		break;
+
+		/* LCD 1360x768 */
+	case LCD_PANEL_IDB_1360X768:
+		break;
+	}
+	if (reg_num != 0) {
+		/* H.W. Reset : ON */
+		viafb_write_reg_mask(CR17, VIACR, 0x00, BIT7);
+
+		viafb_write_regx(lcd_patch_reg, reg_num);
+
+		/* H.W. Reset : OFF */
+		viafb_write_reg_mask(CR17, VIACR, 0x80, BIT7);
+
+		/* Reset PLL */
+		viafb_write_reg_mask(SR40, VIASR, 0x02, BIT1);
+		viafb_write_reg_mask(SR40, VIASR, 0x00, BIT1);
+
+		/* Fire! */
+		outb(inb(VIARMisc) | (BIT2 + BIT3), VIAWMisc);
+	}
+}
+
+static void load_lcd_p880_patch_tbl(int set_hres, int set_vres,
+	int panel_id)
+{
+	int vmode_index;
+	int reg_num = 0;
+	struct io_reg *lcd_patch_reg = NULL;
+
+	if (viaparinfo->lvds_setting_info->iga_path == IGA2)
+		vmode_index = viafb_get_mode_index(set_hres, set_vres, 1);
+	else
+		vmode_index = viafb_get_mode_index(set_hres, set_vres, 0);
+
+	switch (panel_id) {
+	case LCD_PANEL_ID5_1400X1050:
+		switch (vmode_index) {
+		case VIA_RES_640X480:
+			reg_num = NUM_TOTAL_P880_LCD_RES_6X4_14X10;
+			lcd_patch_reg = P880_LCD_RES_6X4_14X10;
+			break;
+		case VIA_RES_800X600:
+			reg_num = NUM_TOTAL_P880_LCD_RES_8X6_14X10;
+			lcd_patch_reg = P880_LCD_RES_8X6_14X10;
+			break;
+		}
+		break;
+	case LCD_PANEL_ID6_1600X1200:
+		switch (vmode_index) {
+		case VIA_RES_640X400:
+		case VIA_RES_640X480:
+			reg_num = NUM_TOTAL_P880_LCD_RES_6X4_16X12;
+			lcd_patch_reg = P880_LCD_RES_6X4_16X12;
+			break;
+		case VIA_RES_720X480:
+		case VIA_RES_720X576:
+			reg_num = NUM_TOTAL_P880_LCD_RES_7X4_16X12;
+			lcd_patch_reg = P880_LCD_RES_7X4_16X12;
+			break;
+		case VIA_RES_800X600:
+			reg_num = NUM_TOTAL_P880_LCD_RES_8X6_16X12;
+			lcd_patch_reg = P880_LCD_RES_8X6_16X12;
+			break;
+		case VIA_RES_1024X768:
+			reg_num = NUM_TOTAL_P880_LCD_RES_10X7_16X12;
+			lcd_patch_reg = P880_LCD_RES_10X7_16X12;
+			break;
+		case VIA_RES_1280X768:
+		case VIA_RES_1280X960:
+		case VIA_RES_1280X1024:
+			reg_num = NUM_TOTAL_P880_LCD_RES_12X10_16X12;
+			lcd_patch_reg = P880_LCD_RES_12X10_16X12;
+			break;
+		}
+		break;
+
+	}
+	if (reg_num != 0) {
+		/* H.W. Reset : ON */
+		viafb_write_reg_mask(CR17, VIACR, 0x00, BIT7);
+
+		viafb_write_regx(lcd_patch_reg, reg_num);
+
+		/* H.W. Reset : OFF */
+		viafb_write_reg_mask(CR17, VIACR, 0x80, BIT7);
+
+		/* Reset PLL */
+		viafb_write_reg_mask(SR40, VIASR, 0x02, BIT1);
+		viafb_write_reg_mask(SR40, VIASR, 0x00, BIT1);
+
+		/* Fire! */
+		outb(inb(VIARMisc) | (BIT2 + BIT3), VIAWMisc);
+	}
+}
+
+static void load_lcd_patch_regs(int set_hres, int set_vres,
+	int panel_id, int set_iga)
+{
+	int vmode_index;
+
+	if (viaparinfo->lvds_setting_info->iga_path == IGA2)
+		vmode_index = viafb_get_mode_index(set_hres, set_vres, 1);
+	else
+		vmode_index = viafb_get_mode_index(set_hres, set_vres, 0);
+
+	viafb_unlock_crt();
+
+	/* Patch for simultaneous & Expansion */
+	if ((set_iga == IGA1_IGA2) &&
+		(viaparinfo->lvds_setting_info->display_method ==
+	    LCD_EXPANDSION)) {
+		switch (viaparinfo->chip_info->gfx_chip_name) {
+		case UNICHROME_CLE266:
+		case UNICHROME_K400:
+			load_lcd_k400_patch_tbl(set_hres, set_vres, panel_id);
+			break;
+		case UNICHROME_K800:
+			break;
+		case UNICHROME_PM800:
+		case UNICHROME_CN700:
+		case UNICHROME_CX700:
+			load_lcd_p880_patch_tbl(set_hres, set_vres, panel_id);
+		}
+	}
+
+	viafb_lock_crt();
+}
+
+static void via_pitch_alignment_patch_lcd(
+	struct lvds_setting_information *plvds_setting_info,
+				   struct lvds_chip_information
+				   *plvds_chip_info)
+{
+	unsigned char cr13, cr35, cr65, cr66, cr67;
+	unsigned long dwScreenPitch = 0;
+	unsigned long dwPitch;
+
+	dwPitch = plvds_setting_info->h_active * (plvds_setting_info->bpp >> 3);
+	if (dwPitch & 0x1F) {
+		dwScreenPitch = ((dwPitch + 31) & ~31) >> 3;
+		if (plvds_setting_info->iga_path == IGA2) {
+			if (plvds_setting_info->bpp > 8) {
+				cr66 = (unsigned char)(dwScreenPitch & 0xFF);
+				viafb_write_reg(CR66, VIACR, cr66);
+				cr67 = viafb_read_reg(VIACR, CR67) & 0xFC;
+				cr67 |=
+				    (unsigned
+				     char)((dwScreenPitch & 0x300) >> 8);
+				viafb_write_reg(CR67, VIACR, cr67);
+			}
+
+			/* Fetch Count */
+			cr67 = viafb_read_reg(VIACR, CR67) & 0xF3;
+			cr67 |= (unsigned char)((dwScreenPitch & 0x600) >> 7);
+			viafb_write_reg(CR67, VIACR, cr67);
+			cr65 = (unsigned char)((dwScreenPitch >> 1) & 0xFF);
+			cr65 += 2;
+			viafb_write_reg(CR65, VIACR, cr65);
+		} else {
+			if (plvds_setting_info->bpp > 8) {
+				cr13 = (unsigned char)(dwScreenPitch & 0xFF);
+				viafb_write_reg(CR13, VIACR, cr13);
+				cr35 = viafb_read_reg(VIACR, CR35) & 0x1F;
+				cr35 |=
+				    (unsigned
+				     char)((dwScreenPitch & 0x700) >> 3);
+				viafb_write_reg(CR35, VIACR, cr35);
+			}
+		}
+	}
+}
+static void lcd_patch_skew_dvp0(struct lvds_setting_information
+			 *plvds_setting_info,
+			 struct lvds_chip_information *plvds_chip_info)
+{
+	if (VT1636_LVDS == plvds_chip_info->lvds_chip_name) {
+		switch (viaparinfo->chip_info->gfx_chip_name) {
+		case UNICHROME_P4M900:
+			viafb_vt1636_patch_skew_on_vt3364(plvds_setting_info,
+						    plvds_chip_info);
+			break;
+		case UNICHROME_P4M890:
+			viafb_vt1636_patch_skew_on_vt3327(plvds_setting_info,
+						    plvds_chip_info);
+			break;
+		}
+	}
+}
+static void lcd_patch_skew_dvp1(struct lvds_setting_information
+			 *plvds_setting_info,
+			 struct lvds_chip_information *plvds_chip_info)
+{
+	if (VT1636_LVDS == plvds_chip_info->lvds_chip_name) {
+		switch (viaparinfo->chip_info->gfx_chip_name) {
+		case UNICHROME_CX700:
+			viafb_vt1636_patch_skew_on_vt3324(plvds_setting_info,
+						    plvds_chip_info);
+			break;
+		}
+	}
+}
+static void lcd_patch_skew(struct lvds_setting_information
+	*plvds_setting_info, struct lvds_chip_information *plvds_chip_info)
+{
+	DEBUG_MSG(KERN_INFO "lcd_patch_skew\n");
+	switch (plvds_chip_info->output_interface) {
+	case INTERFACE_DVP0:
+		lcd_patch_skew_dvp0(plvds_setting_info, plvds_chip_info);
+		break;
+	case INTERFACE_DVP1:
+		lcd_patch_skew_dvp1(plvds_setting_info, plvds_chip_info);
+		break;
+	case INTERFACE_DFP_LOW:
+		if (UNICHROME_P4M900 == viaparinfo->chip_info->gfx_chip_name) {
+			viafb_write_reg_mask(CR99, VIACR, 0x08,
+				       BIT0 + BIT1 + BIT2 + BIT3);
+		}
+		break;
+	}
+}
+
+/* LCD Set Mode */
+void viafb_lcd_set_mode(struct crt_mode_table *mode_crt_table,
+		  struct lvds_setting_information *plvds_setting_info,
+		  struct lvds_chip_information *plvds_chip_info)
+{
+	int video_index = plvds_setting_info->lcd_panel_size;
+	int set_iga = plvds_setting_info->iga_path;
+	int mode_bpp = plvds_setting_info->bpp;
+	int viafb_load_reg_num = 0;
+	int reg_value = 0;
+	int set_hres, set_vres;
+	int panel_hres, panel_vres;
+	u32 pll_D_N;
+	int offset;
+	struct io_register *reg = NULL;
+	struct display_timing mode_crt_reg, panel_crt_reg;
+	struct crt_mode_table *panel_crt_table = NULL;
+	struct VideoModeTable *vmode_tbl = NULL;
+
+	DEBUG_MSG(KERN_INFO "viafb_lcd_set_mode!!\n");
+	/* Get mode table */
+	mode_crt_reg = mode_crt_table->crtc;
+	/* Get panel table Pointer */
+	vmode_tbl = viafb_get_modetbl_pointer(video_index);
+	panel_crt_table = vmode_tbl->crtc;
+	panel_crt_reg = panel_crt_table->crtc;
+	DEBUG_MSG(KERN_INFO "bellow viafb_lcd_set_mode!!\n");
+	set_hres = plvds_setting_info->h_active;
+	set_vres = plvds_setting_info->v_active;
+	panel_hres = plvds_setting_info->lcd_panel_hres;
+	panel_vres = plvds_setting_info->lcd_panel_vres;
+	if (VT1636_LVDS == plvds_chip_info->lvds_chip_name)
+		viafb_init_lvds_vt1636(plvds_setting_info, plvds_chip_info);
+	plvds_setting_info->vclk = panel_crt_table->clk;
+	if (set_iga == IGA1) {
+		/* IGA1 doesn't have LCD scaling, so set it as centering. */
+		viafb_load_crtc_timing(lcd_centering_timging
+				 (mode_crt_reg, panel_crt_reg), IGA1);
+	} else {
+		/* Expansion */
+		if ((plvds_setting_info->display_method ==
+		     LCD_EXPANDSION) & ((set_hres != panel_hres)
+					|| (set_vres != panel_vres))) {
+			/* expansion timing IGA2 loaded panel set timing*/
+			viafb_load_crtc_timing(panel_crt_reg, IGA2);
+			DEBUG_MSG(KERN_INFO "viafb_load_crtc_timing!!\n");
+			load_lcd_scaling(set_hres, set_vres, panel_hres,
+					 panel_vres);
+			DEBUG_MSG(KERN_INFO "load_lcd_scaling!!\n");
+		} else {	/* Centering */
+			/* centering timing IGA2 always loaded panel
+			   and mode releative timing */
+			viafb_load_crtc_timing(lcd_centering_timging
+					 (mode_crt_reg, panel_crt_reg), IGA2);
+			viafb_write_reg_mask(CR79, VIACR, 0x00,
+				BIT0 + BIT1 + BIT2);
+			/* LCD scaling disabled */
+		}
+	}
+
+	if (set_iga == IGA1_IGA2) {
+		load_crtc_shadow_timing(mode_crt_reg, panel_crt_reg);
+		/* Fill shadow registers */
+
+		switch (plvds_setting_info->lcd_panel_id) {
+		case LCD_PANEL_ID0_640X480:
+			offset = 80;
+			break;
+		case LCD_PANEL_ID1_800X600:
+		case LCD_PANEL_IDA_800X480:
+			offset = 110;
+			break;
+		case LCD_PANEL_ID2_1024X768:
+			offset = 150;
+			break;
+		case LCD_PANEL_ID3_1280X768:
+		case LCD_PANEL_ID4_1280X1024:
+		case LCD_PANEL_ID5_1400X1050:
+		case LCD_PANEL_ID9_1280X800:
+			offset = 190;
+			break;
+		case LCD_PANEL_ID6_1600X1200:
+			offset = 250;
+			break;
+		case LCD_PANEL_ID7_1366X768:
+		case LCD_PANEL_IDB_1360X768:
+			offset = 212;
+			break;
+		default:
+			offset = 140;
+			break;
+		}
+
+		/* Offset for simultaneous */
+		reg_value = offset;
+		viafb_load_reg_num = offset_reg.iga2_offset_reg.reg_num;
+		reg = offset_reg.iga2_offset_reg.reg;
+		viafb_load_reg(reg_value, viafb_load_reg_num, reg, VIACR);
+		DEBUG_MSG(KERN_INFO "viafb_load_reg!!\n");
+		viafb_load_fetch_count_reg(set_hres, 4, IGA2);
+		/* Fetch count for simultaneous */
+	} else {		/* SAMM */
+		/* Offset for IGA2 only */
+		viafb_load_offset_reg(set_hres, mode_bpp / 8, set_iga);
+		/* Fetch count for IGA2 only */
+		viafb_load_fetch_count_reg(set_hres, mode_bpp / 8, set_iga);
+
+		if ((viaparinfo->chip_info->gfx_chip_name != UNICHROME_CLE266)
+		    && (viaparinfo->chip_info->gfx_chip_name != UNICHROME_K400))
+			viafb_load_FIFO_reg(set_iga, set_hres, set_vres);
+
+		viafb_set_color_depth(mode_bpp / 8, set_iga);
+	}
+
+	fill_lcd_format();
+
+	pll_D_N = viafb_get_clk_value(panel_crt_table[0].clk);
+	DEBUG_MSG(KERN_INFO "PLL=0x%x", pll_D_N);
+	viafb_set_vclock(pll_D_N, set_iga);
+
+	viafb_set_output_path(DEVICE_LCD, set_iga,
+		plvds_chip_info->output_interface);
+	lcd_patch_skew(plvds_setting_info, plvds_chip_info);
+
+	/* If K8M800, enable LCD Prefetch Mode. */
+	if ((viaparinfo->chip_info->gfx_chip_name == UNICHROME_K800)
+	    || (UNICHROME_K8M890 == viaparinfo->chip_info->gfx_chip_name))
+		viafb_write_reg_mask(CR6A, VIACR, 0x01, BIT0);
+
+	load_lcd_patch_regs(set_hres, set_vres,
+			    plvds_setting_info->lcd_panel_id, set_iga);
+
+	DEBUG_MSG(KERN_INFO "load_lcd_patch_regs!!\n");
+
+	/* Patch for non 32bit alignment mode */
+	via_pitch_alignment_patch_lcd(plvds_setting_info, plvds_chip_info);
+}
+
+static void integrated_lvds_disable(struct lvds_setting_information
+			     *plvds_setting_info,
+			     struct lvds_chip_information *plvds_chip_info)
+{
+	bool turn_off_first_powersequence = false;
+	bool turn_off_second_powersequence = false;
+	if (INTERFACE_LVDS0LVDS1 == plvds_chip_info->output_interface)
+		turn_off_first_powersequence = true;
+	if (INTERFACE_LVDS0 == plvds_chip_info->output_interface)
+		turn_off_first_powersequence = true;
+	if (INTERFACE_LVDS1 == plvds_chip_info->output_interface)
+		turn_off_second_powersequence = true;
+	if (turn_off_second_powersequence) {
+		/* Use second power sequence control: */
+
+		/* Turn off power sequence. */
+		viafb_write_reg_mask(CRD4, VIACR, 0, BIT1);
+
+		/* Turn off back light. */
+		viafb_write_reg_mask(CRD3, VIACR, 0xC0, BIT6 + BIT7);
+	}
+	if (turn_off_first_powersequence) {
+		/* Use first power sequence control: */
+
+		/* Turn off power sequence. */
+		viafb_write_reg_mask(CR6A, VIACR, 0, BIT3);
+
+		/* Turn off back light. */
+		viafb_write_reg_mask(CR91, VIACR, 0xC0, BIT6 + BIT7);
+	}
+
+	/* Turn DFP High/Low Pad off. */
+	viafb_write_reg_mask(SR2A, VIASR, 0, BIT0 + BIT1 + BIT2 + BIT3);
+
+	/* Power off LVDS channel. */
+	switch (plvds_chip_info->output_interface) {
+	case INTERFACE_LVDS0:
+		{
+			viafb_write_reg_mask(CRD2, VIACR, 0x80, BIT7);
+			break;
+		}
+
+	case INTERFACE_LVDS1:
+		{
+			viafb_write_reg_mask(CRD2, VIACR, 0x40, BIT6);
+			break;
+		}
+
+	case INTERFACE_LVDS0LVDS1:
+		{
+			viafb_write_reg_mask(CRD2, VIACR, 0xC0, BIT6 + BIT7);
+			break;
+		}
+	}
+}
+
+static void integrated_lvds_enable(struct lvds_setting_information
+			    *plvds_setting_info,
+			    struct lvds_chip_information *plvds_chip_info)
+{
+	bool turn_on_first_powersequence = false;
+	bool turn_on_second_powersequence = false;
+
+	DEBUG_MSG(KERN_INFO "integrated_lvds_enable, out_interface:%d\n",
+		  plvds_chip_info->output_interface);
+	if (plvds_setting_info->lcd_mode == LCD_SPWG)
+		viafb_write_reg_mask(CRD2, VIACR, 0x00, BIT0 + BIT1);
+	 else
+		viafb_write_reg_mask(CRD2, VIACR, 0x03, BIT0 + BIT1);
+	if (INTERFACE_LVDS0LVDS1 == plvds_chip_info->output_interface)
+		turn_on_first_powersequence = true;
+	if (INTERFACE_LVDS0 == plvds_chip_info->output_interface)
+		turn_on_first_powersequence = true;
+	if (INTERFACE_LVDS1 == plvds_chip_info->output_interface)
+		turn_on_second_powersequence = true;
+
+	if (turn_on_second_powersequence) {
+		/* Use second power sequence control: */
+
+		/* Use hardware control power sequence. */
+		viafb_write_reg_mask(CRD3, VIACR, 0, BIT0);
+
+		/* Turn on back light. */
+		viafb_write_reg_mask(CRD3, VIACR, 0, BIT6 + BIT7);
+
+		/* Turn on hardware power sequence. */
+		viafb_write_reg_mask(CRD4, VIACR, 0x02, BIT1);
+	}
+	if (turn_on_first_powersequence) {
+		/* Use first power sequence control: */
+
+		/* Use hardware control power sequence. */
+		viafb_write_reg_mask(CR91, VIACR, 0, BIT0);
+
+		/* Turn on back light. */
+		viafb_write_reg_mask(CR91, VIACR, 0, BIT6 + BIT7);
+
+		/* Turn on hardware power sequence. */
+		viafb_write_reg_mask(CR6A, VIACR, 0x08, BIT3);
+	}
+
+	/* Turn DFP High/Low pad on. */
+	viafb_write_reg_mask(SR2A, VIASR, 0x0F, BIT0 + BIT1 + BIT2 + BIT3);
+
+	/* Power on LVDS channel. */
+	switch (plvds_chip_info->output_interface) {
+	case INTERFACE_LVDS0:
+		{
+			viafb_write_reg_mask(CRD2, VIACR, 0, BIT7);
+			break;
+		}
+
+	case INTERFACE_LVDS1:
+		{
+			viafb_write_reg_mask(CRD2, VIACR, 0, BIT6);
+			break;
+		}
+
+	case INTERFACE_LVDS0LVDS1:
+		{
+			viafb_write_reg_mask(CRD2, VIACR, 0, BIT6 + BIT7);
+			break;
+		}
+	}
+}
+
+void viafb_lcd_disable(void)
+{
+
+	if (viaparinfo->chip_info->gfx_chip_name == UNICHROME_CLE266) {
+		lcd_powersequence_off();
+		/* DI1 pad off */
+		viafb_write_reg_mask(SR1E, VIASR, 0x00, 0x30);
+	} else if (viaparinfo->chip_info->gfx_chip_name == UNICHROME_CX700) {
+		if (viafb_LCD2_ON
+		    && (INTEGRATED_LVDS ==
+			viaparinfo->chip_info->lvds_chip_info2.lvds_chip_name))
+			integrated_lvds_disable(viaparinfo->lvds_setting_info,
+				&viaparinfo->chip_info->lvds_chip_info2);
+		if (INTEGRATED_LVDS ==
+			viaparinfo->chip_info->lvds_chip_info.lvds_chip_name)
+			integrated_lvds_disable(viaparinfo->lvds_setting_info,
+				&viaparinfo->chip_info->lvds_chip_info);
+		if (VT1636_LVDS == viaparinfo->chip_info->
+			lvds_chip_info.lvds_chip_name)
+			viafb_disable_lvds_vt1636(viaparinfo->lvds_setting_info,
+				&viaparinfo->chip_info->lvds_chip_info);
+	} else if (VT1636_LVDS ==
+	viaparinfo->chip_info->lvds_chip_info.lvds_chip_name) {
+		viafb_disable_lvds_vt1636(viaparinfo->lvds_setting_info,
+				    &viaparinfo->chip_info->lvds_chip_info);
+	} else {
+		/* DFP-HL pad off          */
+		viafb_write_reg_mask(SR2A, VIASR, 0x00, 0x0F);
+		/* Backlight off           */
+		viafb_write_reg_mask(SR3D, VIASR, 0x00, 0x20);
+		/* 24 bit DI data paht off */
+		viafb_write_reg_mask(CR91, VIACR, 0x80, 0x80);
+		/* Simultaneout disabled   */
+		viafb_write_reg_mask(CR6B, VIACR, 0x00, 0x08);
+	}
+
+	/* Disable expansion bit   */
+	viafb_write_reg_mask(CR79, VIACR, 0x00, 0x01);
+	/* CRT path set to IGA1    */
+	viafb_write_reg_mask(SR16, VIASR, 0x00, 0x40);
+	/* Simultaneout disabled   */
+	viafb_write_reg_mask(CR6B, VIACR, 0x00, 0x08);
+	/* IGA2 path disabled      */
+	viafb_write_reg_mask(CR6A, VIACR, 0x00, 0x80);
+
+}
+
+void viafb_lcd_enable(void)
+{
+	if (viaparinfo->chip_info->gfx_chip_name == UNICHROME_CLE266) {
+		/* DI1 pad on */
+		viafb_write_reg_mask(SR1E, VIASR, 0x30, 0x30);
+		lcd_powersequence_on();
+	} else if (viaparinfo->chip_info->gfx_chip_name == UNICHROME_CX700) {
+		if (viafb_LCD2_ON && (INTEGRATED_LVDS ==
+			viaparinfo->chip_info->lvds_chip_info2.lvds_chip_name))
+			integrated_lvds_enable(viaparinfo->lvds_setting_info2, \
+				&viaparinfo->chip_info->lvds_chip_info2);
+		if (INTEGRATED_LVDS ==
+			viaparinfo->chip_info->lvds_chip_info.lvds_chip_name)
+			integrated_lvds_enable(viaparinfo->lvds_setting_info,
+				&viaparinfo->chip_info->lvds_chip_info);
+		if (VT1636_LVDS == viaparinfo->chip_info->
+			lvds_chip_info.lvds_chip_name)
+			viafb_enable_lvds_vt1636(viaparinfo->
+			lvds_setting_info, &viaparinfo->chip_info->
+			lvds_chip_info);
+	} else if (VT1636_LVDS ==
+	viaparinfo->chip_info->lvds_chip_info.lvds_chip_name) {
+		viafb_enable_lvds_vt1636(viaparinfo->lvds_setting_info,
+				   &viaparinfo->chip_info->lvds_chip_info);
+	} else {
+		/* DFP-HL pad on           */
+		viafb_write_reg_mask(SR2A, VIASR, 0x0F, 0x0F);
+		/* Backlight on            */
+		viafb_write_reg_mask(SR3D, VIASR, 0x20, 0x20);
+		/* 24 bit DI data paht on  */
+		viafb_write_reg_mask(CR91, VIACR, 0x00, 0x80);
+
+		/* Set data source selection bit by iga path */
+		if (viaparinfo->lvds_setting_info->iga_path == IGA1) {
+			/* DFP-H set to IGA1       */
+			viafb_write_reg_mask(CR97, VIACR, 0x00, 0x10);
+			/* DFP-L set to IGA1       */
+			viafb_write_reg_mask(CR99, VIACR, 0x00, 0x10);
+		} else {
+			/* DFP-H set to IGA2       */
+			viafb_write_reg_mask(CR97, VIACR, 0x10, 0x10);
+			/* DFP-L set to IGA2       */
+			viafb_write_reg_mask(CR99, VIACR, 0x10, 0x10);
+		}
+		/* LCD enabled             */
+		viafb_write_reg_mask(CR6A, VIACR, 0x48, 0x48);
+	}
+
+	if ((viaparinfo->lvds_setting_info->iga_path == IGA1)
+	    || (viaparinfo->lvds_setting_info->iga_path == IGA1_IGA2)) {
+		/* CRT path set to IGA2    */
+		viafb_write_reg_mask(SR16, VIASR, 0x40, 0x40);
+		/* IGA2 path disabled      */
+		viafb_write_reg_mask(CR6A, VIACR, 0x00, 0x80);
+		/* IGA2 path enabled       */
+	} else {		/* IGA2 */
+		viafb_write_reg_mask(CR6A, VIACR, 0x80, 0x80);
+	}
+
+}
+
+static void lcd_powersequence_off(void)
+{
+	int i, mask, data;
+
+	/* Software control power sequence */
+	viafb_write_reg_mask(CR91, VIACR, 0x11, 0x11);
+
+	for (i = 0; i < 3; i++) {
+		mask = PowerSequenceOff[0][i];
+		data = PowerSequenceOff[1][i] & mask;
+		viafb_write_reg_mask(CR91, VIACR, (u8) data, (u8) mask);
+		udelay(PowerSequenceOff[2][i]);
+	}
+
+	/* Disable LCD */
+	viafb_write_reg_mask(CR6A, VIACR, 0x00, 0x08);
+}
+
+static void lcd_powersequence_on(void)
+{
+	int i, mask, data;
+
+	/* Software control power sequence */
+	viafb_write_reg_mask(CR91, VIACR, 0x11, 0x11);
+
+	/* Enable LCD */
+	viafb_write_reg_mask(CR6A, VIACR, 0x08, 0x08);
+
+	for (i = 0; i < 3; i++) {
+		mask = PowerSequenceOn[0][i];
+		data = PowerSequenceOn[1][i] & mask;
+		viafb_write_reg_mask(CR91, VIACR, (u8) data, (u8) mask);
+		udelay(PowerSequenceOn[2][i]);
+	}
+
+	udelay(1);
+}
+
+static void fill_lcd_format(void)
+{
+	u8 bdithering = 0, bdual = 0;
+
+	if (viaparinfo->lvds_setting_info->device_lcd_dualedge)
+		bdual = BIT4;
+	if (viaparinfo->lvds_setting_info->LCDDithering)
+		bdithering = BIT0;
+	/* Dual & Dithering */
+	viafb_write_reg_mask(CR88, VIACR, (bdithering | bdual), BIT4 + BIT0);
+}
+
+static void check_diport_of_integrated_lvds(
+	struct lvds_chip_information *plvds_chip_info,
+				     struct lvds_setting_information
+				     *plvds_setting_info)
+{
+	/* Determine LCD DI Port by hardware layout. */
+	switch (viafb_display_hardware_layout) {
+	case HW_LAYOUT_LCD_ONLY:
+		{
+			if (plvds_setting_info->device_lcd_dualedge) {
+				plvds_chip_info->output_interface =
+				    INTERFACE_LVDS0LVDS1;
+			} else {
+				plvds_chip_info->output_interface =
+				    INTERFACE_LVDS0;
+			}
+
+			break;
+		}
+
+	case HW_LAYOUT_DVI_ONLY:
+		{
+			plvds_chip_info->output_interface = INTERFACE_NONE;
+			break;
+		}
+
+	case HW_LAYOUT_LCD1_LCD2:
+	case HW_LAYOUT_LCD_EXTERNAL_LCD2:
+		{
+			plvds_chip_info->output_interface =
+			    INTERFACE_LVDS0LVDS1;
+			break;
+		}
+
+	case HW_LAYOUT_LCD_DVI:
+		{
+			plvds_chip_info->output_interface = INTERFACE_LVDS1;
+			break;
+		}
+
+	default:
+		{
+			plvds_chip_info->output_interface = INTERFACE_LVDS1;
+			break;
+		}
+	}
+
+	DEBUG_MSG(KERN_INFO
+		  "Display Hardware Layout: 0x%x, LCD DI Port: 0x%x\n",
+		  viafb_display_hardware_layout,
+		  plvds_chip_info->output_interface);
+}
+
+void viafb_init_lvds_output_interface(struct lvds_chip_information
+				*plvds_chip_info,
+				struct lvds_setting_information
+				*plvds_setting_info)
+{
+	if (INTERFACE_NONE != plvds_chip_info->output_interface) {
+		/*Do nothing, lcd port is specified by module parameter */
+		return;
+	}
+
+	switch (plvds_chip_info->lvds_chip_name) {
+
+	case VT1636_LVDS:
+		switch (viaparinfo->chip_info->gfx_chip_name) {
+		case UNICHROME_CX700:
+			plvds_chip_info->output_interface = INTERFACE_DVP1;
+			break;
+		case UNICHROME_CN700:
+			plvds_chip_info->output_interface = INTERFACE_DFP_LOW;
+			break;
+		default:
+			plvds_chip_info->output_interface = INTERFACE_DVP0;
+			break;
+		}
+		break;
+
+	case INTEGRATED_LVDS:
+		check_diport_of_integrated_lvds(plvds_chip_info,
+						plvds_setting_info);
+		break;
+
+	default:
+		switch (viaparinfo->chip_info->gfx_chip_name) {
+		case UNICHROME_K8M890:
+		case UNICHROME_P4M900:
+		case UNICHROME_P4M890:
+			plvds_chip_info->output_interface = INTERFACE_DFP_LOW;
+			break;
+		default:
+			plvds_chip_info->output_interface = INTERFACE_DFP;
+			break;
+		}
+		break;
+	}
+}
+
+static struct display_timing lcd_centering_timging(struct display_timing
+					    mode_crt_reg,
+					    struct display_timing panel_crt_reg)
+{
+	struct display_timing crt_reg;
+
+	crt_reg.hor_total = panel_crt_reg.hor_total;
+	crt_reg.hor_addr = mode_crt_reg.hor_addr;
+	crt_reg.hor_blank_start =
+	    (panel_crt_reg.hor_addr - mode_crt_reg.hor_addr) / 2 +
+	    crt_reg.hor_addr;
+	crt_reg.hor_blank_end = panel_crt_reg.hor_blank_end;
+	crt_reg.hor_sync_start =
+	    (panel_crt_reg.hor_sync_start -
+	     panel_crt_reg.hor_blank_start) + crt_reg.hor_blank_start;
+	crt_reg.hor_sync_end = panel_crt_reg.hor_sync_end;
+
+	crt_reg.ver_total = panel_crt_reg.ver_total;
+	crt_reg.ver_addr = mode_crt_reg.ver_addr;
+	crt_reg.ver_blank_start =
+	    (panel_crt_reg.ver_addr - mode_crt_reg.ver_addr) / 2 +
+	    crt_reg.ver_addr;
+	crt_reg.ver_blank_end = panel_crt_reg.ver_blank_end;
+	crt_reg.ver_sync_start =
+	    (panel_crt_reg.ver_sync_start -
+	     panel_crt_reg.ver_blank_start) + crt_reg.ver_blank_start;
+	crt_reg.ver_sync_end = panel_crt_reg.ver_sync_end;
+
+	return crt_reg;
+}
+
+static void load_crtc_shadow_timing(struct display_timing mode_timing,
+			     struct display_timing panel_timing)
+{
+	struct io_register *reg = NULL;
+	int i;
+	int viafb_load_reg_Num = 0;
+	int reg_value = 0;
+
+	if (viaparinfo->lvds_setting_info->display_method == LCD_EXPANDSION) {
+		/* Expansion */
+		for (i = 12; i < 20; i++) {
+			switch (i) {
+			case H_TOTAL_SHADOW_INDEX:
+				reg_value =
+				    IGA2_HOR_TOTAL_SHADOW_FORMULA
+				    (panel_timing.hor_total);
+				viafb_load_reg_Num =
+				    iga2_shadow_crtc_reg.hor_total_shadow.
+				    reg_num;
+				reg = iga2_shadow_crtc_reg.hor_total_shadow.reg;
+				break;
+			case H_BLANK_END_SHADOW_INDEX:
+				reg_value =
+				    IGA2_HOR_BLANK_END_SHADOW_FORMULA
+				    (panel_timing.hor_blank_start,
+				     panel_timing.hor_blank_end);
+				viafb_load_reg_Num =
+				    iga2_shadow_crtc_reg.
+				    hor_blank_end_shadow.reg_num;
+				reg =
+				    iga2_shadow_crtc_reg.
+				    hor_blank_end_shadow.reg;
+				break;
+			case V_TOTAL_SHADOW_INDEX:
+				reg_value =
+				    IGA2_VER_TOTAL_SHADOW_FORMULA
+				    (panel_timing.ver_total);
+				viafb_load_reg_Num =
+				    iga2_shadow_crtc_reg.ver_total_shadow.
+				    reg_num;
+				reg = iga2_shadow_crtc_reg.ver_total_shadow.reg;
+				break;
+			case V_ADDR_SHADOW_INDEX:
+				reg_value =
+				    IGA2_VER_ADDR_SHADOW_FORMULA
+				    (panel_timing.ver_addr);
+				viafb_load_reg_Num =
+				    iga2_shadow_crtc_reg.ver_addr_shadow.
+				    reg_num;
+				reg = iga2_shadow_crtc_reg.ver_addr_shadow.reg;
+				break;
+			case V_BLANK_SATRT_SHADOW_INDEX:
+				reg_value =
+				    IGA2_VER_BLANK_START_SHADOW_FORMULA
+				    (panel_timing.ver_blank_start);
+				viafb_load_reg_Num =
+				    iga2_shadow_crtc_reg.
+				    ver_blank_start_shadow.reg_num;
+				reg =
+				    iga2_shadow_crtc_reg.
+				    ver_blank_start_shadow.reg;
+				break;
+			case V_BLANK_END_SHADOW_INDEX:
+				reg_value =
+				    IGA2_VER_BLANK_END_SHADOW_FORMULA
+				    (panel_timing.ver_blank_start,
+				     panel_timing.ver_blank_end);
+				viafb_load_reg_Num =
+				    iga2_shadow_crtc_reg.
+				    ver_blank_end_shadow.reg_num;
+				reg =
+				    iga2_shadow_crtc_reg.
+				    ver_blank_end_shadow.reg;
+				break;
+			case V_SYNC_SATRT_SHADOW_INDEX:
+				reg_value =
+				    IGA2_VER_SYNC_START_SHADOW_FORMULA
+				    (panel_timing.ver_sync_start);
+				viafb_load_reg_Num =
+				    iga2_shadow_crtc_reg.
+				    ver_sync_start_shadow.reg_num;
+				reg =
+				    iga2_shadow_crtc_reg.
+				    ver_sync_start_shadow.reg;
+				break;
+			case V_SYNC_END_SHADOW_INDEX:
+				reg_value =
+				    IGA2_VER_SYNC_END_SHADOW_FORMULA
+				    (panel_timing.ver_sync_start,
+				     panel_timing.ver_sync_end);
+				viafb_load_reg_Num =
+				    iga2_shadow_crtc_reg.
+				    ver_sync_end_shadow.reg_num;
+				reg =
+				    iga2_shadow_crtc_reg.
+				    ver_sync_end_shadow.reg;
+				break;
+			}
+			viafb_load_reg(reg_value,
+				viafb_load_reg_Num, reg, VIACR);
+		}
+	} else {		/* Centering */
+		for (i = 12; i < 20; i++) {
+			switch (i) {
+			case H_TOTAL_SHADOW_INDEX:
+				reg_value =
+				    IGA2_HOR_TOTAL_SHADOW_FORMULA
+				    (panel_timing.hor_total);
+				viafb_load_reg_Num =
+				    iga2_shadow_crtc_reg.hor_total_shadow.
+				    reg_num;
+				reg = iga2_shadow_crtc_reg.hor_total_shadow.reg;
+				break;
+			case H_BLANK_END_SHADOW_INDEX:
+				reg_value =
+				    IGA2_HOR_BLANK_END_SHADOW_FORMULA
+				    (panel_timing.hor_blank_start,
+				     panel_timing.hor_blank_end);
+				viafb_load_reg_Num =
+				    iga2_shadow_crtc_reg.
+				    hor_blank_end_shadow.reg_num;
+				reg =
+				    iga2_shadow_crtc_reg.
+				    hor_blank_end_shadow.reg;
+				break;
+			case V_TOTAL_SHADOW_INDEX:
+				reg_value =
+				    IGA2_VER_TOTAL_SHADOW_FORMULA
+				    (panel_timing.ver_total);
+				viafb_load_reg_Num =
+				    iga2_shadow_crtc_reg.ver_total_shadow.
+				    reg_num;
+				reg = iga2_shadow_crtc_reg.ver_total_shadow.reg;
+				break;
+			case V_ADDR_SHADOW_INDEX:
+				reg_value =
+				    IGA2_VER_ADDR_SHADOW_FORMULA
+				    (mode_timing.ver_addr);
+				viafb_load_reg_Num =
+				    iga2_shadow_crtc_reg.ver_addr_shadow.
+				    reg_num;
+				reg = iga2_shadow_crtc_reg.ver_addr_shadow.reg;
+				break;
+			case V_BLANK_SATRT_SHADOW_INDEX:
+				reg_value =
+				    IGA2_VER_BLANK_START_SHADOW_FORMULA
+				    (mode_timing.ver_blank_start);
+				viafb_load_reg_Num =
+				    iga2_shadow_crtc_reg.
+				    ver_blank_start_shadow.reg_num;
+				reg =
+				    iga2_shadow_crtc_reg.
+				    ver_blank_start_shadow.reg;
+				break;
+			case V_BLANK_END_SHADOW_INDEX:
+				reg_value =
+				    IGA2_VER_BLANK_END_SHADOW_FORMULA
+				    (panel_timing.ver_blank_start,
+				     panel_timing.ver_blank_end);
+				viafb_load_reg_Num =
+				    iga2_shadow_crtc_reg.
+				    ver_blank_end_shadow.reg_num;
+				reg =
+				    iga2_shadow_crtc_reg.
+				    ver_blank_end_shadow.reg;
+				break;
+			case V_SYNC_SATRT_SHADOW_INDEX:
+				reg_value =
+				    IGA2_VER_SYNC_START_SHADOW_FORMULA(
+				    (panel_timing.ver_sync_start -
+				    panel_timing.ver_blank_start) +
+				    (panel_timing.ver_addr -
+				    mode_timing.ver_addr) / 2 +
+				    mode_timing.ver_addr);
+				viafb_load_reg_Num =
+				    iga2_shadow_crtc_reg.ver_sync_start_shadow.
+				    reg_num;
+				reg =
+				    iga2_shadow_crtc_reg.ver_sync_start_shadow.
+				    reg;
+				break;
+			case V_SYNC_END_SHADOW_INDEX:
+				reg_value =
+				    IGA2_VER_SYNC_END_SHADOW_FORMULA(
+				    (panel_timing.ver_sync_start -
+				    panel_timing.ver_blank_start) +
+				    (panel_timing.ver_addr -
+				    mode_timing.ver_addr) / 2 +
+				    mode_timing.ver_addr,
+				    panel_timing.ver_sync_end);
+				viafb_load_reg_Num =
+				    iga2_shadow_crtc_reg.ver_sync_end_shadow.
+				    reg_num;
+				reg =
+				    iga2_shadow_crtc_reg.ver_sync_end_shadow.
+				    reg;
+				break;
+			}
+			viafb_load_reg(reg_value,
+				viafb_load_reg_Num, reg, VIACR);
+		}
+	}
+}
+
+bool viafb_lcd_get_mobile_state(bool *mobile)
+{
+	unsigned char *romptr, *tableptr;
+	u8 core_base;
+	unsigned char *biosptr;
+	/* Rom address */
+	u32 romaddr = 0x000C0000;
+	u16 start_pattern = 0;
+
+	biosptr = ioremap(romaddr, 0x10000);
+
+	memcpy(&start_pattern, biosptr, 2);
+	/* Compare pattern */
+	if (start_pattern == 0xAA55) {
+		/* Get the start of Table */
+		/* 0x1B means BIOS offset position */
+		romptr = biosptr + 0x1B;
+		tableptr = biosptr + *((u16 *) romptr);
+
+		/* Get the start of biosver structure */
+		/* 18 means BIOS version position. */
+		romptr = tableptr + 18;
+		romptr = biosptr + *((u16 *) romptr);
+
+		/* The offset should be 44, but the
+		   actual image is less three char. */
+		/* pRom += 44; */
+		romptr += 41;
+
+		core_base = *romptr++;
+
+		if (core_base & 0x8)
+			*mobile = false;
+		else
+			*mobile = true;
+		/* release memory */
+		iounmap(biosptr);
+
+		return true;
+	} else {
+		iounmap(biosptr);
+		return false;
+	}
+}
+
+static void viafb_load_scaling_factor_for_p4m900(int set_hres,
+	int set_vres, int panel_hres, int panel_vres)
+{
+	int h_scaling_factor;
+	int v_scaling_factor;
+	u8 cra2 = 0;
+	u8 cr77 = 0;
+	u8 cr78 = 0;
+	u8 cr79 = 0;
+	u8 cr9f = 0;
+	/* Check if expansion for horizontal */
+	if (set_hres < panel_hres) {
+		/* Load Horizontal Scaling Factor */
+
+		/* For VIA_K8M800 or later chipsets. */
+		h_scaling_factor =
+		    K800_LCD_HOR_SCF_FORMULA(set_hres, panel_hres);
+		/* HSCaleFactor[1:0] at CR9F[1:0] */
+		cr9f = h_scaling_factor & 0x0003;
+		/* HSCaleFactor[9:2] at CR77[7:0] */
+		cr77 = (h_scaling_factor & 0x03FC) >> 2;
+		/* HSCaleFactor[11:10] at CR79[5:4] */
+		cr79 = (h_scaling_factor & 0x0C00) >> 10;
+		cr79 <<= 4;
+
+		/* Horizontal scaling enabled */
+		cra2 = 0xC0;
+
+		DEBUG_MSG(KERN_INFO "Horizontal Scaling value = %d\n",
+			  h_scaling_factor);
+	} else {
+		/* Horizontal scaling disabled */
+		cra2 = 0x00;
+	}
+
+	/* Check if expansion for vertical */
+	if (set_vres < panel_vres) {
+		/* Load Vertical Scaling Factor */
+
+		/* For VIA_K8M800 or later chipsets. */
+		v_scaling_factor =
+		    K800_LCD_VER_SCF_FORMULA(set_vres, panel_vres);
+
+		/* Vertical scaling enabled */
+		cra2 |= 0x08;
+		/* VSCaleFactor[0] at CR79[3] */
+		cr79 |= ((v_scaling_factor & 0x0001) << 3);
+		/* VSCaleFactor[8:1] at CR78[7:0] */
+		cr78 |= (v_scaling_factor & 0x01FE) >> 1;
+		/* VSCaleFactor[10:9] at CR79[7:6] */
+		cr79 |= ((v_scaling_factor & 0x0600) >> 9) << 6;
+
+		DEBUG_MSG(KERN_INFO "Vertical Scaling value = %d\n",
+			  v_scaling_factor);
+	} else {
+		/* Vertical scaling disabled */
+		cra2 |= 0x00;
+	}
+
+	viafb_write_reg_mask(CRA2, VIACR, cra2, BIT3 + BIT6 + BIT7);
+	viafb_write_reg_mask(CR77, VIACR, cr77, 0xFF);
+	viafb_write_reg_mask(CR78, VIACR, cr78, 0xFF);
+	viafb_write_reg_mask(CR79, VIACR, cr79, 0xF8);
+	viafb_write_reg_mask(CR9F, VIACR, cr9f, BIT0 + BIT1);
+}
--- /dev/null
+++ b/drivers/video/via/lcd.h
@@ -0,0 +1,94 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#ifndef __LCD_H__
+#define __LCD_H__
+
+/*Definition TMDS Device ID register*/
+#define     VT1631_DEVICE_ID_REG        0x02
+#define     VT1631_DEVICE_ID            0x92
+
+#define     VT3271_DEVICE_ID_REG        0x02
+#define     VT3271_DEVICE_ID            0x71
+
+#define     GET_LCD_SIZE_BY_SYSTEM_BIOS     0x01
+#define     GET_LCD_SIZE_BY_VGA_BIOS        0x02
+#define     GET_LCD_SZIE_BY_HW_STRAPPING    0x03
+#define     GET_LCD_SIZE_BY_USER_SETTING    0x04
+
+/* Definition DVI Panel ID*/
+/* Resolution: 640x480,   Channel: single, Dithering: Enable */
+#define     LCD_PANEL_ID0_640X480       0x00
+/* Resolution: 800x600,   Channel: single, Dithering: Enable */
+#define     LCD_PANEL_ID1_800X600       0x01
+/* Resolution: 1024x768,  Channel: single, Dithering: Enable */
+#define     LCD_PANEL_ID2_1024X768      0x02
+/* Resolution: 1280x768,  Channel: single, Dithering: Enable */
+#define     LCD_PANEL_ID3_1280X768      0x03
+/* Resolution: 1280x1024, Channel: dual,   Dithering: Enable */
+#define     LCD_PANEL_ID4_1280X1024     0x04
+/* Resolution: 1400x1050, Channel: dual,   Dithering: Enable */
+#define     LCD_PANEL_ID5_1400X1050     0x05
+/* Resolution: 1600x1200, Channel: dual,   Dithering: Enable */
+#define     LCD_PANEL_ID6_1600X1200     0x06
+/* Resolution: 1366x768,  Channel: single, Dithering: Disable */
+#define     LCD_PANEL_ID7_1366X768      0x07
+/* Resolution: 1024x600,  Channel: single, Dithering: Enable*/
+#define     LCD_PANEL_ID8_1024X600      0x08
+/* Resolution: 1280x800,  Channel: single, Dithering: Enable*/
+#define     LCD_PANEL_ID9_1280X800      0x09
+/* Resolution: 800x480,   Channel: single, Dithering: Enable*/
+#define     LCD_PANEL_IDA_800X480       0x0A
+/* Resolution: 1360x768,   Channel: single, Dithering: Disable*/
+#define     LCD_PANEL_IDB_1360X768     0x0B
+/* Resolution: 480x640,  Channel: single, Dithering: Enable */
+#define     LCD_PANEL_IDC_480X640      0x0C
+
+
+extern int viafb_LCD2_ON;
+extern int viafb_LCD_ON;
+extern int viafb_DVI_ON;
+
+void viafb_disable_lvds_vt1636(struct lvds_setting_information
+			 *plvds_setting_info,
+			 struct lvds_chip_information *plvds_chip_info);
+void viafb_enable_lvds_vt1636(struct lvds_setting_information
+			*plvds_setting_info,
+			struct lvds_chip_information *plvds_chip_info);
+void viafb_lcd_disable(void);
+void viafb_lcd_enable(void);
+void viafb_init_lcd_size(void);
+void viafb_init_lvds_output_interface(struct lvds_chip_information
+				*plvds_chip_info,
+				struct lvds_setting_information
+				*plvds_setting_info);
+void viafb_lcd_set_mode(struct crt_mode_table *mode_crt_table,
+		  struct lvds_setting_information *plvds_setting_info,
+		  struct lvds_chip_information *plvds_chip_info);
+int viafb_lvds_trasmitter_identify(void);
+void viafb_init_lvds_output_interface(struct lvds_chip_information
+				*plvds_chip_info,
+				struct lvds_setting_information
+				*plvds_setting_info);
+bool viafb_lcd_get_mobile_state(bool *mobile);
+void viafb_load_crtc_timing(struct display_timing device_timing,
+	int set_iga);
+
+#endif /* __LCD_H__ */
--- /dev/null
+++ b/drivers/video/via/lcdtbl.h
@@ -0,0 +1,591 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#ifndef __LCDTBL_H__
+#define __LCDTBL_H__
+
+#include "share.h"
+
+/* CLE266 Software Power Sequence */
+/* {Mask}, {Data}, {Delay} */
+int PowerSequenceOn[3][3] =
+    { {0x10, 0x08, 0x06}, {0x10, 0x08, 0x06}, {0x19, 0x1FE, 0x01} };
+int PowerSequenceOff[3][3] =
+    { {0x06, 0x08, 0x10}, {0x00, 0x00, 0x00}, {0xD2, 0x19, 0x01} };
+
+/* ++++++ P880 ++++++ */
+/*   Panel 1600x1200   */
+struct io_reg P880_LCD_RES_6X4_16X12[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x73}, {VIACR, CR55, 0x0F, 0x08},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x73}, {VIACR, CR54, 0x38, 0x00},
+	{VIACR, CR5D, 0x40, 0x40},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0x5A}, {VIACR, CR71, 0x08, 0x00},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x5E},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0xD6}, {VIACR, CR67, 0x03, 0x00},
+	 /*VCLK*/ {VIASR, SR44, 0xFF, 0x7D}, {VIASR, SR45, 0xFF, 0x8C},
+	{VIASR, SR46, 0xFF, 0x02}
+
+};
+
+#define NUM_TOTAL_P880_LCD_RES_6X4_16X12 ARRAY_SIZE(P880_LCD_RES_6X4_16X12)
+
+struct io_reg P880_LCD_RES_7X4_16X12[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x67}, {VIACR, CR55, 0x0F, 0x08},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x67}, {VIACR, CR54, 0x38, 0x00},
+	{VIACR, CR5D, 0x40, 0x40},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0x74}, {VIACR, CR71, 0x08, 0x00},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x78},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0xF5}, {VIACR, CR67, 0x03, 0x00},
+	 /*VCLK*/ {VIASR, SR44, 0xFF, 0x78}, {VIASR, SR45, 0xFF, 0x8C},
+	{VIASR, SR46, 0xFF, 0x01}
+
+};
+
+#define NUM_TOTAL_P880_LCD_RES_7X4_16X12 ARRAY_SIZE(P880_LCD_RES_7X4_16X12)
+
+struct io_reg P880_LCD_RES_8X6_16X12[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x65}, {VIACR, CR55, 0x0F, 0x08},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x65}, {VIACR, CR54, 0x38, 0x00},
+	{VIACR, CR5D, 0x40, 0x40},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0x7F}, {VIACR, CR71, 0x08, 0x00},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x83},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0xE1}, {VIACR, CR67, 0x03, 0x00},
+	 /*VCLK*/ {VIASR, SR44, 0xFF, 0x6D}, {VIASR, SR45, 0xFF, 0x88},
+	{VIASR, SR46, 0xFF, 0x03}
+
+};
+
+#define NUM_TOTAL_P880_LCD_RES_8X6_16X12 ARRAY_SIZE(P880_LCD_RES_8X6_16X12)
+
+struct io_reg P880_LCD_RES_10X7_16X12[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x65}, {VIACR, CR55, 0x0F, 0x08},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x65}, {VIACR, CR54, 0x38, 0x00},
+	{VIACR, CR5D, 0x40, 0x40},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0xAB}, {VIACR, CR71, 0x08, 0x00},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0xAF},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0xF0}, {VIACR, CR67, 0x03, 0x00},
+	 /*VCLK*/ {VIASR, SR44, 0xFF, 0x92}, {VIASR, SR45, 0xFF, 0x88},
+	{VIASR, SR46, 0xFF, 0x03}
+
+};
+
+#define NUM_TOTAL_P880_LCD_RES_10X7_16X12 ARRAY_SIZE(P880_LCD_RES_10X7_16X12)
+
+struct io_reg P880_LCD_RES_12X10_16X12[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x7D}, {VIACR, CR55, 0x0F, 0x08},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x7D}, {VIACR, CR54, 0x38, 0x00},
+	{VIACR, CR5D, 0x40, 0x40},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0xD0}, {VIACR, CR71, 0x08, 0x00},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0xD4},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0xFA}, {VIACR, CR67, 0x03, 0x00},
+	 /*VCLK*/ {VIASR, SR44, 0xFF, 0xF6}, {VIASR, SR45, 0xFF, 0x88},
+	{VIASR, SR46, 0xFF, 0x05}
+
+};
+
+#define NUM_TOTAL_P880_LCD_RES_12X10_16X12 ARRAY_SIZE(P880_LCD_RES_12X10_16X12)
+
+/*   Panel 1400x1050   */
+struct io_reg P880_LCD_RES_6X4_14X10[] = {
+	/* 640x480                          */
+	/* IGA2 Horizontal Total            */
+	{VIACR, CR50, 0xFF, 0x9D}, {VIACR, CR55, 0x0F, 0x56},
+	/* IGA2 Horizontal Blank End        */
+	{VIACR, CR53, 0xFF, 0x9D}, {VIACR, CR54, 0x38, 0x75},
+	{VIACR, CR5D, 0x40, 0x24},
+	/* IGA2 Horizontal Total Shadow     */
+	{VIACR, CR6D, 0xFF, 0x5F}, {VIACR, CR71, 0x08, 0x44},
+	/* IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x63},
+	/* IGA2 Offset                      */
+	{VIACR, CR66, 0xFF, 0xB4}, {VIACR, CR67, 0x03, 0x00},
+	/* VCLK                             */
+	{VIASR, SR44, 0xFF, 0xC6}, {VIASR, SR45, 0xFF, 0x8C},
+	{VIASR, SR46, 0xFF, 0x05}
+};
+
+#define NUM_TOTAL_P880_LCD_RES_6X4_14X10 ARRAY_SIZE(P880_LCD_RES_6X4_14X10)
+
+struct io_reg P880_LCD_RES_8X6_14X10[] = {
+	/* 800x600                          */
+	/* IGA2 Horizontal Total            */
+	{VIACR, CR50, 0xFF, 0x9D}, {VIACR, CR55, 0x0F, 0x56},
+	/* IGA2 Horizontal Blank End        */
+	{VIACR, CR53, 0xFF, 0x9D}, {VIACR, CR54, 0x38, 0x75},
+	{VIACR, CR5D, 0x40, 0x24},
+	/* IGA2 Horizontal Total Shadow     */
+	{VIACR, CR6D, 0xFF, 0x7F}, {VIACR, CR71, 0x08, 0x44},
+	/* IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x83},
+	/* IGA2 Offset                      */
+	{VIACR, CR66, 0xFF, 0xBE}, {VIACR, CR67, 0x03, 0x00},
+	/* VCLK                             */
+	{VIASR, SR44, 0xFF, 0x06}, {VIASR, SR45, 0xFF, 0x8D},
+	{VIASR, SR46, 0xFF, 0x05}
+};
+
+#define NUM_TOTAL_P880_LCD_RES_8X6_14X10 ARRAY_SIZE(P880_LCD_RES_8X6_14X10)
+
+/* ++++++ K400 ++++++ */
+/*   Panel 1600x1200   */
+struct io_reg K400_LCD_RES_6X4_16X12[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x73}, {VIACR, CR55, 0x0F, 0x08},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x73}, {VIACR, CR54, 0x38, 0x00},
+	{VIACR, CR5D, 0x40, 0x40},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0x5A}, {VIACR, CR71, 0x08, 0x00},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x5E},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0xDA}, {VIACR, CR67, 0x03, 0x00},
+	 /*VCLK*/ {VIASR, SR46, 0xFF, 0xC4}, {VIASR, SR47, 0xFF, 0x7F}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_6X4_16X12 ARRAY_SIZE(K400_LCD_RES_6X4_16X12)
+
+struct io_reg K400_LCD_RES_7X4_16X12[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x67}, {VIACR, CR55, 0x0F, 0x08},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x67}, {VIACR, CR54, 0x38, 0x00},
+	{VIACR, CR5D, 0x40, 0x40},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0x74}, {VIACR, CR71, 0x08, 0x00},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x78},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0xF5}, {VIACR, CR67, 0x03, 0x00},
+	 /*VCLK*/ {VIASR, SR46, 0xFF, 0x46}, {VIASR, SR47, 0xFF, 0x3D}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_7X4_16X12 ARRAY_SIZE(K400_LCD_RES_7X4_16X12)
+
+struct io_reg K400_LCD_RES_8X6_16X12[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x65}, {VIACR, CR55, 0x0F, 0x08},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x65}, {VIACR, CR54, 0x38, 0x00},
+	{VIACR, CR5D, 0x40, 0x40},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0x7F}, {VIACR, CR71, 0x08, 0x00},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x83},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0xE1}, {VIACR, CR67, 0x03, 0x00},
+	 /*VCLK*/ {VIASR, SR46, 0xFF, 0x85}, {VIASR, SR47, 0xFF, 0x6F}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_8X6_16X12 ARRAY_SIZE(K400_LCD_RES_8X6_16X12)
+
+struct io_reg K400_LCD_RES_10X7_16X12[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x65}, {VIACR, CR55, 0x0F, 0x08},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x65}, {VIACR, CR54, 0x38, 0x00},
+	{VIACR, CR5D, 0x40, 0x40},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0xAB}, {VIACR, CR71, 0x08, 0x00},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0xAF},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0xF0}, {VIACR, CR67, 0x03, 0x00},
+	 /*VCLK*/ {VIASR, SR46, 0xFF, 0x45}, {VIASR, SR47, 0xFF, 0x4A}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_10X7_16X12 ARRAY_SIZE(K400_LCD_RES_10X7_16X12)
+
+struct io_reg K400_LCD_RES_12X10_16X12[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x7D}, {VIACR, CR55, 0x0F, 0x08},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x7D}, {VIACR, CR54, 0x38, 0x00},
+	{VIACR, CR5D, 0x40, 0x40},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0xD0}, {VIACR, CR71, 0x08, 0x00},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0xD4},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0xFA}, {VIACR, CR67, 0x03, 0x00},
+	 /*VCLK*/ {VIASR, SR46, 0xFF, 0x47}, {VIASR, SR47, 0xFF, 0x7C}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_12X10_16X12 ARRAY_SIZE(K400_LCD_RES_12X10_16X12)
+
+/*   Panel 1400x1050   */
+struct io_reg K400_LCD_RES_6X4_14X10[] = {
+	/* 640x400                          */
+	/* IGA2 Horizontal Total            */
+	{VIACR, CR50, 0xFF, 0x9D}, {VIACR, CR55, 0x0F, 0x56},
+	/* IGA2 Horizontal Blank End        */
+	{VIACR, CR53, 0xFF, 0x9D}, {VIACR, CR54, 0x38, 0x75},
+	{VIACR, CR5D, 0x40, 0x24},
+	/* IGA2 Horizontal Total Shadow     */
+	{VIACR, CR6D, 0xFF, 0x5F}, {VIACR, CR71, 0x08, 0x44},
+	/* IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x63},
+	/* IGA2 Offset                      */
+	{VIACR, CR66, 0xFF, 0xB4}, {VIACR, CR67, 0x03, 0x00},
+	/* VCLK                             */
+	{VIASR, SR46, 0xFF, 0x07}, {VIASR, SR47, 0xFF, 0x19}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_6X4_14X10 ARRAY_SIZE(K400_LCD_RES_6X4_14X10)
+
+struct io_reg K400_LCD_RES_8X6_14X10[] = {
+	/* 800x600                          */
+	/* IGA2 Horizontal Total            */
+	{VIACR, CR50, 0xFF, 0x9D}, {VIACR, CR55, 0x0F, 0x56},
+	/* IGA2 Horizontal Blank End        */
+	{VIACR, CR53, 0xFF, 0x9D}, {VIACR, CR54, 0x38, 0x75},
+	{VIACR, CR5D, 0x40, 0x24},
+	/* IGA2 Horizontal Total Shadow     */
+	{VIACR, CR6D, 0xFF, 0x7F}, {VIACR, CR71, 0x08, 0x44},
+	/* IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x83},
+	/* IGA2 Offset                      */
+	{VIACR, CR66, 0xFF, 0xBE}, {VIACR, CR67, 0x03, 0x00},
+	/* VCLK                             */
+	{VIASR, SR46, 0xFF, 0x07}, {VIASR, SR47, 0xFF, 0x21}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_8X6_14X10 ARRAY_SIZE(K400_LCD_RES_8X6_14X10)
+
+struct io_reg K400_LCD_RES_10X7_14X10[] = {
+	/* 1024x768                         */
+	/* IGA2 Horizontal Total            */
+	{VIACR, CR50, 0xFF, 0x9D}, {VIACR, CR55, 0x0F, 0x56},
+	/* IGA2 Horizontal Blank End        */
+	{VIACR, CR53, 0xFF, 0x9D}, {VIACR, CR54, 0x38, 0x75},
+	{VIACR, CR5D, 0x40, 0x24},
+	/* IGA2 Horizontal Total Shadow     */
+	{VIACR, CR6D, 0xFF, 0xA3}, {VIACR, CR71, 0x08, 0x44},
+	/* IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0xA7},
+	/* IGA2 Offset                      */
+	{VIACR, CR66, 0xFF, 0xC3}, {VIACR, CR67, 0x03, 0x04},
+	/* VCLK                             */
+	{VIASR, SR46, 0xFF, 0x05}, {VIASR, SR47, 0xFF, 0x1E}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_10X7_14X10 ARRAY_SIZE(K400_LCD_RES_10X7_14X10)
+
+struct io_reg K400_LCD_RES_12X10_14X10[] = {
+	/* 1280x768, 1280x960, 1280x1024    */
+	/* IGA2 Horizontal Total            */
+	{VIACR, CR50, 0xFF, 0x97}, {VIACR, CR55, 0x0F, 0x56},
+	/* IGA2 Horizontal Blank End        */
+	{VIACR, CR53, 0xFF, 0x97}, {VIACR, CR54, 0x38, 0x75},
+	{VIACR, CR5D, 0x40, 0x24},
+	/* IGA2 Horizontal Total Shadow     */
+	{VIACR, CR6D, 0xFF, 0xCE}, {VIACR, CR71, 0x08, 0x44},
+	/* IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0xD2},
+	/* IGA2 Offset                      */
+	{VIACR, CR66, 0xFF, 0xC9}, {VIACR, CR67, 0x03, 0x04},
+	/* VCLK                             */
+	{VIASR, SR46, 0xFF, 0x84}, {VIASR, SR47, 0xFF, 0x79}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_12X10_14X10 ARRAY_SIZE(K400_LCD_RES_12X10_14X10)
+
+/* ++++++ K400 ++++++ */
+/*   Panel 1366x768   */
+struct io_reg K400_LCD_RES_6X4_1366X7[] = {
+	/* 640x400                          */
+	/* IGA2 Horizontal Total            */
+	{VIACR, CR50, 0xFF, 0x47}, {VIACR, CR55, 0x0F, 0x35},
+	/* IGA2 Horizontal Blank End        */
+	{VIACR, CR53, 0xFF, 0x47}, {VIACR, CR54, 0x38, 0x2B},
+	{VIACR, CR5D, 0x40, 0x13},
+	/* IGA2 Horizontal Total Shadow     */
+	{VIACR, CR6D, 0xFF, 0x60}, {VIACR, CR71, 0x08, 0x23},
+	/* IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x64},
+	/* IGA2 Offset                      */
+	{VIACR, CR66, 0xFF, 0x8C}, {VIACR, CR67, 0x03, 0x00},
+	/* VCLK                             */
+	{VIASR, SR46, 0xFF, 0x87}, {VIASR, SR47, 0xFF, 0x4C}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_6X4_1366X7 ARRAY_SIZE(K400_LCD_RES_6X4_1366X7)
+
+struct io_reg K400_LCD_RES_7X4_1366X7[] = {
+	/* IGA2 Horizontal Total            */
+	{VIACR, CR50, 0xFF, 0x3B}, {VIACR, CR55, 0x0F, 0x35},
+	/* IGA2 Horizontal Blank End        */
+	{VIACR, CR53, 0xFF, 0x3B}, {VIACR, CR54, 0x38, 0x2B},
+	{VIACR, CR5D, 0x40, 0x13},
+	/* IGA2 Horizontal Total Shadow     */
+	{VIACR, CR6D, 0xFF, 0x71}, {VIACR, CR71, 0x08, 0x23},
+	/* IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x75},
+	/* IGA2 Offset                      */
+	{VIACR, CR66, 0xFF, 0x96}, {VIACR, CR67, 0x03, 0x00},
+	/* VCLK                             */
+	{VIASR, SR46, 0xFF, 0x05}, {VIASR, SR47, 0xFF, 0x10}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_7X4_1366X7 ARRAY_SIZE(K400_LCD_RES_7X4_1366X7)
+
+struct io_reg K400_LCD_RES_8X6_1366X7[] = {
+	/* 800x600                          */
+	/* IGA2 Horizontal Total            */
+	{VIACR, CR50, 0xFF, 0x37}, {VIACR, CR55, 0x0F, 0x35},
+	/* IGA2 Horizontal Blank End        */
+	{VIACR, CR53, 0xFF, 0x37}, {VIACR, CR54, 0x38, 0x2B},
+	{VIACR, CR5D, 0x40, 0x13},
+	/* IGA2 Horizontal Total Shadow     */
+	{VIACR, CR6D, 0xFF, 0x7E}, {VIACR, CR71, 0x08, 0x23},
+	/* IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x82},
+	/* IGA2 Offset                      */
+	{VIACR, CR66, 0xFF, 0x8C}, {VIACR, CR67, 0x03, 0x00},
+	/* VCLK                             */
+	{VIASR, SR46, 0xFF, 0x84}, {VIASR, SR47, 0xFF, 0xB9}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_8X6_1366X7 ARRAY_SIZE(K400_LCD_RES_8X6_1366X7)
+
+struct io_reg K400_LCD_RES_10X7_1366X7[] = {
+	/* 1024x768                         */
+	/* IGA2 Horizontal Total            */
+	{VIACR, CR50, 0xFF, 0x9D}, {VIACR, CR55, 0x0F, 0x56},
+	/* IGA2 Horizontal Blank End        */
+	{VIACR, CR53, 0xFF, 0x9D}, {VIACR, CR54, 0x38, 0x75},
+	{VIACR, CR5D, 0x40, 0x24},
+	/* IGA2 Horizontal Total Shadow     */
+	{VIACR, CR6D, 0xFF, 0xA3}, {VIACR, CR71, 0x08, 0x44},
+	/* IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0xA7},
+	/* IGA2 Offset                      */
+	{VIACR, CR66, 0xFF, 0xC3}, {VIACR, CR67, 0x03, 0x04},
+	/* VCLK                             */
+	{VIASR, SR46, 0xFF, 0x05}, {VIASR, SR47, 0xFF, 0x1E}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_10X7_1366X7 ARRAY_SIZE(K400_LCD_RES_10X7_1366X7)
+
+struct io_reg K400_LCD_RES_12X10_1366X7[] = {
+	/* 1280x768, 1280x960, 1280x1024    */
+	/* IGA2 Horizontal Total            */
+	{VIACR, CR50, 0xFF, 0x97}, {VIACR, CR55, 0x0F, 0x56},
+	/* IGA2 Horizontal Blank End        */
+	{VIACR, CR53, 0xFF, 0x97}, {VIACR, CR54, 0x38, 0x75},
+	{VIACR, CR5D, 0x40, 0x24},
+	/* IGA2 Horizontal Total Shadow     */
+	{VIACR, CR6D, 0xFF, 0xCE}, {VIACR, CR71, 0x08, 0x44},
+	/* IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0xD2},
+	/* IGA2 Offset                      */
+	{VIACR, CR66, 0xFF, 0xC9}, {VIACR, CR67, 0x03, 0x04},
+	/* VCLK                             */
+	{VIASR, SR46, 0xFF, 0x84}, {VIASR, SR47, 0xFF, 0x79}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_12X10_1366X7\
+			ARRAY_SIZE(K400_LCD_RES_12X10_1366X7)
+
+/* ++++++ K400 ++++++ */
+/*   Panel 1280x1024   */
+struct io_reg K400_LCD_RES_6X4_12X10[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x9D}, {VIACR, CR55, 0x0F, 0x46},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x9D}, {VIACR, CR54, 0x38, 0x74},
+	{VIACR, CR5D, 0x40, 0x1C},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0x5F}, {VIACR, CR71, 0x08, 0x34},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x63},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0xAA}, {VIACR, CR67, 0x03, 0x00},
+	 /*VCLK*/ {VIASR, SR46, 0xFF, 0x07}, {VIASR, SR47, 0xFF, 0x19}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_6X4_12X10 ARRAY_SIZE(K400_LCD_RES_6X4_12X10)
+
+struct io_reg K400_LCD_RES_7X4_12X10[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x9D}, {VIACR, CR55, 0x0F, 0x46},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x9D}, {VIACR, CR54, 0x38, 0x74},
+	{VIACR, CR5D, 0x40, 0x1C},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0x68}, {VIACR, CR71, 0x08, 0x34},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x6C},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0xA8}, {VIACR, CR67, 0x03, 0x00},
+	 /*VCLK*/ {VIASR, SR46, 0xFF, 0x87}, {VIASR, SR47, 0xFF, 0xED}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_7X4_12X10 ARRAY_SIZE(K400_LCD_RES_7X4_12X10)
+
+struct io_reg K400_LCD_RES_8X6_12X10[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x9D}, {VIACR, CR55, 0x0F, 0x46},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x9D}, {VIACR, CR54, 0x38, 0x74},
+	{VIACR, CR5D, 0x40, 0x1C},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0x7F}, {VIACR, CR71, 0x08, 0x34},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x83},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0xBE}, {VIACR, CR67, 0x03, 0x00},
+	 /*VCLK*/ {VIASR, SR46, 0xFF, 0x07}, {VIASR, SR47, 0xFF, 0x21}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_8X6_12X10 ARRAY_SIZE(K400_LCD_RES_8X6_12X10)
+
+struct io_reg K400_LCD_RES_10X7_12X10[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x9D}, {VIACR, CR55, 0x0F, 0x46},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x9D}, {VIACR, CR54, 0x38, 0x74},
+	{VIACR, CR5D, 0x40, 0x1C},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0xA3}, {VIACR, CR71, 0x08, 0x34},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0xA7},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0xBE}, {VIACR, CR67, 0x03, 0x04},
+	 /*VCLK*/ {VIASR, SR46, 0xFF, 0x05}, {VIASR, SR47, 0xFF, 0x1E}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_10X7_12X10 ARRAY_SIZE(K400_LCD_RES_10X7_12X10)
+
+/* ++++++ K400 ++++++ */
+/*   Panel 1024x768    */
+struct io_reg K400_LCD_RES_6X4_10X7[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x47}, {VIACR, CR55, 0x0F, 0x35},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x47}, {VIACR, CR54, 0x38, 0x2B},
+	{VIACR, CR5D, 0x40, 0x13},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0x60}, {VIACR, CR71, 0x08, 0x23},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x64},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0x8C}, {VIACR, CR67, 0x03, 0x00},
+	 /*VCLK*/ {VIASR, SR46, 0xFF, 0x87}, {VIASR, SR47, 0xFF, 0x4C}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_6X4_10X7 ARRAY_SIZE(K400_LCD_RES_6X4_10X7)
+
+struct io_reg K400_LCD_RES_7X4_10X7[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x3B}, {VIACR, CR55, 0x0F, 0x35},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x3B}, {VIACR, CR54, 0x38, 0x2B},
+	{VIACR, CR5D, 0x40, 0x13},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0x71}, {VIACR, CR71, 0x08, 0x23},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x75},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0x96}, {VIACR, CR67, 0x03, 0x00},
+	 /*VCLK*/ {VIASR, SR46, 0xFF, 0x05}, {VIASR, SR47, 0xFF, 0x10}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_7X4_10X7 ARRAY_SIZE(K400_LCD_RES_7X4_10X7)
+
+struct io_reg K400_LCD_RES_8X6_10X7[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x37}, {VIACR, CR55, 0x0F, 0x35},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x37}, {VIACR, CR54, 0x38, 0x2B},
+	{VIACR, CR5D, 0x40, 0x13},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0x7E}, {VIACR, CR71, 0x08, 0x23},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x82},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0x8C}, {VIACR, CR67, 0x03, 0x00},
+	 /*VCLK*/ {VIASR, SR46, 0xFF, 0x84}, {VIASR, SR47, 0xFF, 0xB9}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_8X6_10X7 ARRAY_SIZE(K400_LCD_RES_8X6_10X7)
+
+/* ++++++ K400 ++++++ */
+/*   Panel 800x600     */
+struct io_reg K400_LCD_RES_6X4_8X6[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x1A}, {VIACR, CR55, 0x0F, 0x34},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x1A}, {VIACR, CR54, 0x38, 0xE3},
+	{VIACR, CR5D, 0x40, 0x12},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0x5F}, {VIACR, CR71, 0x08, 0x22},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x63},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0x6E}, {VIACR, CR67, 0x03, 0x00},
+	 /*VCLK*/ {VIASR, SR46, 0xFF, 0x86}, {VIASR, SR47, 0xFF, 0xB3}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_6X4_8X6 ARRAY_SIZE(K400_LCD_RES_6X4_8X6)
+
+struct io_reg K400_LCD_RES_7X4_8X6[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x1F}, {VIACR, CR55, 0x0F, 0x34},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x1F}, {VIACR, CR54, 0x38, 0xE3},
+	{VIACR, CR5D, 0x40, 0x12},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0x7F}, {VIACR, CR71, 0x08, 0x22},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x83},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0x78}, {VIACR, CR67, 0x03, 0x00},
+	 /*VCLK*/ {VIASR, SR46, 0xFF, 0xC4}, {VIASR, SR47, 0xFF, 0x59}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_7X4_8X6 ARRAY_SIZE(K400_LCD_RES_7X4_8X6)
+
+#endif /* __LCDTBL_H__ */
--- /dev/null
+++ b/drivers/video/via/Makefile
@@ -0,0 +1,7 @@
+#
+# Makefile for the VIA framebuffer driver (for Linux Kernel 2.6)
+#
+
+obj-$(CONFIG_FB_VIA) += viafb.o
+
+viafb-y	:=viafbdev.o hw.o iface.o  via_i2c.o dvi.o lcd.o ioctl.o accel.o via_utility.o vt1636.o global.o tblDPASetting.o viamode.o tbl1636.o
--- /dev/null
+++ b/drivers/video/via/share.h
@@ -0,0 +1,1105 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __SHARE_H__
+#define __SHARE_H__
+
+/* Define Return Value */
+#define FAIL        -1
+#define OK          1
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+/* Define Bit Field */
+#define BIT0    0x01
+#define BIT1    0x02
+#define BIT2    0x04
+#define BIT3    0x08
+#define BIT4    0x10
+#define BIT5    0x20
+#define BIT6    0x40
+#define BIT7    0x80
+
+/* Video Memory Size */
+#define VIDEO_MEMORY_SIZE_16M    0x1000000
+
+/* Definition Mode Index
+*/
+#define     VIA_RES_640X480                 	0
+#define     VIA_RES_800X600                 	1
+#define     VIA_RES_1024X768                	2
+#define     VIA_RES_1152X864                	3
+#define     VIA_RES_1280X1024               	4
+#define     VIA_RES_1600X1200               	5
+#define     VIA_RES_1440X1050               	6
+#define     VIA_RES_1280X768                	7
+#define     VIA_RES_1280X960                	8
+#define     VIA_RES_1920X1440               	9
+#define     VIA_RES_848X480                 	10
+#define     VIA_RES_1400X1050               	11
+#define     VIA_RES_720X480                 	12
+#define     VIA_RES_720X576                 	13
+#define     VIA_RES_1024X512                	14
+#define     VIA_RES_856X480                 	15
+#define     VIA_RES_1024X576                	16
+#define     VIA_RES_640X400                 	17
+#define     VIA_RES_1280X720                	18
+#define     VIA_RES_1920X1080               	19
+#define     VIA_RES_800X480                 	20
+#define     VIA_RES_1368X768                	21
+#define     VIA_RES_1024X600                	22
+#define     VIA_RES_1280X800                	23
+#define     VIA_RES_1680X1050               	24
+#define     VIA_RES_960X600			25
+#define     VIA_RES_1000X600               	26
+#define     VIA_RES_1088X612               	27
+#define     VIA_RES_1152X720               	28
+#define     VIA_RES_1200X720               	29
+#define     VIA_RES_1280X600               	30
+#define     VIA_RES_1360X768               	31
+#define     VIA_RES_1366X768               	32
+#define     VIA_RES_1440X900               	33
+#define     VIA_RES_1600X900               	34
+#define     VIA_RES_1600X1024              	35
+#define     VIA_RES_1792X1344              	36
+#define     VIA_RES_1856X1392              	37
+#define     VIA_RES_1920X1200              	38
+#define     VIA_RES_2048X1536              	39
+#define     VIA_RES_480X640                  	40
+
+/*Reduce Blanking*/
+#define     VIA_RES_1360X768_RB          	131
+#define     VIA_RES_1440X900_RB          	133
+#define     VIA_RES_1400X1050_RB        	111
+#define     VIA_RES_1600X900_RB          	134
+#define     VIA_RES_1680X1050_RB        	124
+#define     VIA_RES_1920X1080_RB        	119
+#define     VIA_RES_1920X1200_RB        	138
+
+#define     VIA_RES_INVALID                 	255
+
+/* standard VGA IO port
+*/
+#define VIARMisc    0x3CC
+#define VIAWMisc    0x3C2
+#define VIAStatus   0x3DA
+#define VIACR       0x3D4
+#define VIASR       0x3C4
+#define VIAGR       0x3CE
+#define VIAAR       0x3C0
+
+#define StdCR       0x19
+#define StdSR       0x04
+#define StdGR       0x09
+#define StdAR       0x14
+
+#define PatchCR     11
+
+/* Display path */
+#define IGA1        1
+#define IGA2        2
+#define IGA1_IGA2   3
+
+/* Define Color Depth  */
+#define MODE_8BPP       1
+#define MODE_16BPP      2
+#define MODE_32BPP      4
+
+#define GR20    0x20
+#define GR21    0x21
+#define GR22    0x22
+
+/* Sequencer Registers */
+#define SR01    0x01
+#define SR10    0x10
+#define SR12    0x12
+#define SR15    0x15
+#define SR16    0x16
+#define SR17    0x17
+#define SR18    0x18
+#define SR1B    0x1B
+#define SR1A    0x1A
+#define SR1C    0x1C
+#define SR1D    0x1D
+#define SR1E    0x1E
+#define SR1F    0x1F
+#define SR20    0x20
+#define SR21    0x21
+#define SR22    0x22
+#define SR2A    0x2A
+#define SR2D    0x2D
+#define SR2E    0x2E
+
+#define SR30    0x30
+#define SR39    0x39
+#define SR3D    0x3D
+#define SR3E    0x3E
+#define SR3F    0x3F
+#define SR40    0x40
+#define SR43    0x43
+#define SR44    0x44
+#define SR45    0x45
+#define SR46    0x46
+#define SR47    0x47
+#define SR48    0x48
+#define SR49    0x49
+#define SR4A    0x4A
+#define SR4B    0x4B
+#define SR4C    0x4C
+#define SR52    0x52
+#define SR5E    0x5E
+#define SR65    0x65
+
+/* CRT Controller Registers */
+#define CR00    0x00
+#define CR01    0x01
+#define CR02    0x02
+#define CR03    0x03
+#define CR04    0x04
+#define CR05    0x05
+#define CR06    0x06
+#define CR07    0x07
+#define CR08    0x08
+#define CR09    0x09
+#define CR0A    0x0A
+#define CR0B    0x0B
+#define CR0C    0x0C
+#define CR0D    0x0D
+#define CR0E    0x0E
+#define CR0F    0x0F
+#define CR10    0x10
+#define CR11    0x11
+#define CR12    0x12
+#define CR13    0x13
+#define CR14    0x14
+#define CR15    0x15
+#define CR16    0x16
+#define CR17    0x17
+#define CR18    0x18
+
+/* Extend CRT Controller Registers */
+#define CR30    0x30
+#define CR31    0x31
+#define CR32    0x32
+#define CR33    0x33
+#define CR34    0x34
+#define CR35    0x35
+#define CR36    0x36
+#define CR37    0x37
+#define CR38    0x38
+#define CR39    0x39
+#define CR3A    0x3A
+#define CR3B    0x3B
+#define CR3C    0x3C
+#define CR3D    0x3D
+#define CR3E    0x3E
+#define CR3F    0x3F
+#define CR40    0x40
+#define CR41    0x41
+#define CR42    0x42
+#define CR43    0x43
+#define CR44    0x44
+#define CR45    0x45
+#define CR46    0x46
+#define CR47    0x47
+#define CR48    0x48
+#define CR49    0x49
+#define CR4A    0x4A
+#define CR4B    0x4B
+#define CR4C    0x4C
+#define CR4D    0x4D
+#define CR4E    0x4E
+#define CR4F    0x4F
+#define CR50    0x50
+#define CR51    0x51
+#define CR52    0x52
+#define CR53    0x53
+#define CR54    0x54
+#define CR55    0x55
+#define CR56    0x56
+#define CR57    0x57
+#define CR58    0x58
+#define CR59    0x59
+#define CR5A    0x5A
+#define CR5B    0x5B
+#define CR5C    0x5C
+#define CR5D    0x5D
+#define CR5E    0x5E
+#define CR5F    0x5F
+#define CR60    0x60
+#define CR61    0x61
+#define CR62    0x62
+#define CR63    0x63
+#define CR64    0x64
+#define CR65    0x65
+#define CR66    0x66
+#define CR67    0x67
+#define CR68    0x68
+#define CR69    0x69
+#define CR6A    0x6A
+#define CR6B    0x6B
+#define CR6C    0x6C
+#define CR6D    0x6D
+#define CR6E    0x6E
+#define CR6F    0x6F
+#define CR70    0x70
+#define CR71    0x71
+#define CR72    0x72
+#define CR73    0x73
+#define CR74    0x74
+#define CR75    0x75
+#define CR76    0x76
+#define CR77    0x77
+#define CR78    0x78
+#define CR79    0x79
+#define CR7A    0x7A
+#define CR7B    0x7B
+#define CR7C    0x7C
+#define CR7D    0x7D
+#define CR7E    0x7E
+#define CR7F    0x7F
+#define CR80    0x80
+#define CR81    0x81
+#define CR82    0x82
+#define CR83    0x83
+#define CR84    0x84
+#define CR85    0x85
+#define CR86    0x86
+#define CR87    0x87
+#define CR88    0x88
+#define CR89    0x89
+#define CR8A    0x8A
+#define CR8B    0x8B
+#define CR8C    0x8C
+#define CR8D    0x8D
+#define CR8E    0x8E
+#define CR8F    0x8F
+#define CR90    0x90
+#define CR91    0x91
+#define CR92    0x92
+#define CR93    0x93
+#define CR94    0x94
+#define CR95    0x95
+#define CR96    0x96
+#define CR97    0x97
+#define CR98    0x98
+#define CR99    0x99
+#define CR9A    0x9A
+#define CR9B    0x9B
+#define CR9C    0x9C
+#define CR9D    0x9D
+#define CR9E    0x9E
+#define CR9F    0x9F
+#define CRA0    0xA0
+#define CRA1    0xA1
+#define CRA2    0xA2
+#define CRA3    0xA3
+#define CRD2    0xD2
+#define CRD3    0xD3
+#define CRD4    0xD4
+
+/* LUT Table*/
+#define LUT_DATA             0x3C9	/* DACDATA */
+#define LUT_INDEX_READ       0x3C7	/* DACRX */
+#define LUT_INDEX_WRITE      0x3C8	/* DACWX */
+#define DACMASK              0x3C6
+
+/* Definition Device */
+#define DEVICE_CRT  0x01
+#define DEVICE_DVI  0x03
+#define DEVICE_LCD  0x04
+
+/* Device output interface */
+#define INTERFACE_NONE          0x00
+#define INTERFACE_ANALOG_RGB    0x01
+#define INTERFACE_DVP0          0x02
+#define INTERFACE_DVP1          0x03
+#define INTERFACE_DFP_HIGH      0x04
+#define INTERFACE_DFP_LOW       0x05
+#define INTERFACE_DFP           0x06
+#define INTERFACE_LVDS0         0x07
+#define INTERFACE_LVDS1         0x08
+#define INTERFACE_LVDS0LVDS1    0x09
+#define INTERFACE_TMDS          0x0A
+
+#define HW_LAYOUT_LCD_ONLY      0x01
+#define HW_LAYOUT_DVI_ONLY      0x02
+#define HW_LAYOUT_LCD_DVI       0x03
+#define HW_LAYOUT_LCD1_LCD2     0x04
+#define HW_LAYOUT_LCD_EXTERNAL_LCD2 0x10
+
+/* Definition Refresh Rate */
+#define REFRESH_50      50
+#define REFRESH_60      60
+#define REFRESH_75      75
+#define REFRESH_85      85
+#define REFRESH_100     100
+#define REFRESH_120     120
+
+/* Definition Sync Polarity*/
+#define NEGATIVE        1
+#define POSITIVE        0
+
+/*480x640@60 Sync Polarity (GTF)
+*/
+#define M480X640_R60_HSP        NEGATIVE
+#define M480X640_R60_VSP        POSITIVE
+
+/*640x480@60 Sync Polarity (VESA Mode)
+*/
+#define M640X480_R60_HSP        NEGATIVE
+#define M640X480_R60_VSP        NEGATIVE
+
+/*640x480@75 Sync Polarity (VESA Mode)
+*/
+#define M640X480_R75_HSP        NEGATIVE
+#define M640X480_R75_VSP        NEGATIVE
+
+/*640x480@85 Sync Polarity (VESA Mode)
+*/
+#define M640X480_R85_HSP        NEGATIVE
+#define M640X480_R85_VSP        NEGATIVE
+
+/*640x480@100 Sync Polarity (GTF Mode)
+*/
+#define M640X480_R100_HSP       NEGATIVE
+#define M640X480_R100_VSP       POSITIVE
+
+/*640x480@120 Sync Polarity (GTF Mode)
+*/
+#define M640X480_R120_HSP       NEGATIVE
+#define M640X480_R120_VSP       POSITIVE
+
+/*720x480@60 Sync Polarity  (GTF Mode)
+*/
+#define M720X480_R60_HSP        NEGATIVE
+#define M720X480_R60_VSP        POSITIVE
+
+/*720x576@60 Sync Polarity  (GTF Mode)
+*/
+#define M720X576_R60_HSP        NEGATIVE
+#define M720X576_R60_VSP        POSITIVE
+
+/*800x600@60 Sync Polarity (VESA Mode)
+*/
+#define M800X600_R60_HSP        POSITIVE
+#define M800X600_R60_VSP        POSITIVE
+
+/*800x600@75 Sync Polarity (VESA Mode)
+*/
+#define M800X600_R75_HSP        POSITIVE
+#define M800X600_R75_VSP        POSITIVE
+
+/*800x600@85 Sync Polarity (VESA Mode)
+*/
+#define M800X600_R85_HSP        POSITIVE
+#define M800X600_R85_VSP        POSITIVE
+
+/*800x600@100 Sync Polarity (GTF Mode)
+*/
+#define M800X600_R100_HSP       NEGATIVE
+#define M800X600_R100_VSP       POSITIVE
+
+/*800x600@120 Sync Polarity (GTF Mode)
+*/
+#define M800X600_R120_HSP       NEGATIVE
+#define M800X600_R120_VSP       POSITIVE
+
+/*800x480@60 Sync Polarity  (CVT Mode)
+*/
+#define M800X480_R60_HSP        NEGATIVE
+#define M800X480_R60_VSP        POSITIVE
+
+/*848x480@60 Sync Polarity  (CVT Mode)
+*/
+#define M848X480_R60_HSP        NEGATIVE
+#define M848X480_R60_VSP        POSITIVE
+
+/*852x480@60 Sync Polarity  (GTF Mode)
+*/
+#define M852X480_R60_HSP        NEGATIVE
+#define M852X480_R60_VSP        POSITIVE
+
+/*1024x512@60 Sync Polarity (GTF Mode)
+*/
+#define M1024X512_R60_HSP       NEGATIVE
+#define M1024X512_R60_VSP       POSITIVE
+
+/*1024x600@60 Sync Polarity (GTF Mode)
+*/
+#define M1024X600_R60_HSP       NEGATIVE
+#define M1024X600_R60_VSP       POSITIVE
+
+/*1024x768@60 Sync Polarity (VESA Mode)
+*/
+#define M1024X768_R60_HSP       NEGATIVE
+#define M1024X768_R60_VSP       NEGATIVE
+
+/*1024x768@75 Sync Polarity (VESA Mode)
+*/
+#define M1024X768_R75_HSP       POSITIVE
+#define M1024X768_R75_VSP       POSITIVE
+
+/*1024x768@85 Sync Polarity (VESA Mode)
+*/
+#define M1024X768_R85_HSP       POSITIVE
+#define M1024X768_R85_VSP       POSITIVE
+
+/*1024x768@100 Sync Polarity (GTF Mode)
+*/
+#define M1024X768_R100_HSP      NEGATIVE
+#define M1024X768_R100_VSP      POSITIVE
+
+/*1152x864@75 Sync Polarity (VESA Mode)
+*/
+#define M1152X864_R75_HSP       POSITIVE
+#define M1152X864_R75_VSP       POSITIVE
+
+/*1280x720@60 Sync Polarity  (GTF Mode)
+*/
+#define M1280X720_R60_HSP       NEGATIVE
+#define M1280X720_R60_VSP       POSITIVE
+
+/* 1280x768@50 Sync Polarity  (GTF Mode) */
+#define M1280X768_R50_HSP       NEGATIVE
+#define M1280X768_R50_VSP       POSITIVE
+
+/*1280x768@60 Sync Polarity  (GTF Mode)
+*/
+#define M1280X768_R60_HSP       NEGATIVE
+#define M1280X768_R60_VSP       POSITIVE
+
+/*1280x800@60 Sync Polarity  (CVT Mode)
+*/
+#define M1280X800_R60_HSP       NEGATIVE
+#define M1280X800_R60_VSP       POSITIVE
+
+/*1280x960@60 Sync Polarity (VESA Mode)
+*/
+#define M1280X960_R60_HSP       POSITIVE
+#define M1280X960_R60_VSP       POSITIVE
+
+/*1280x1024@60 Sync Polarity (VESA Mode)
+*/
+#define M1280X1024_R60_HSP      POSITIVE
+#define M1280X1024_R60_VSP      POSITIVE
+
+/* 1360x768@60 Sync Polarity (CVT Mode) */
+#define M1360X768_R60_HSP       POSITIVE
+#define M1360X768_R60_VSP       POSITIVE
+
+/* 1360x768@60 Sync Polarity (CVT Reduce Blanking Mode) */
+#define M1360X768_RB_R60_HSP       POSITIVE
+#define M1360X768_RB_R60_VSP       NEGATIVE
+
+/* 1368x768@50 Sync Polarity (GTF Mode) */
+#define M1368X768_R50_HSP       NEGATIVE
+#define M1368X768_R50_VSP       POSITIVE
+
+/* 1368x768@60 Sync Polarity (VESA Mode) */
+#define M1368X768_R60_HSP       NEGATIVE
+#define M1368X768_R60_VSP       POSITIVE
+
+/*1280x1024@75 Sync Polarity (VESA Mode)
+*/
+#define M1280X1024_R75_HSP      POSITIVE
+#define M1280X1024_R75_VSP      POSITIVE
+
+/*1280x1024@85 Sync Polarity (VESA Mode)
+*/
+#define M1280X1024_R85_HSP      POSITIVE
+#define M1280X1024_R85_VSP      POSITIVE
+
+/*1440x1050@60 Sync Polarity (GTF Mode)
+*/
+#define M1440X1050_R60_HSP      NEGATIVE
+#define M1440X1050_R60_VSP      POSITIVE
+
+/*1600x1200@60 Sync Polarity (VESA Mode)
+*/
+#define M1600X1200_R60_HSP      POSITIVE
+#define M1600X1200_R60_VSP      POSITIVE
+
+/*1600x1200@75 Sync Polarity (VESA Mode)
+*/
+#define M1600X1200_R75_HSP      POSITIVE
+#define M1600X1200_R75_VSP      POSITIVE
+
+/* 1680x1050@60 Sync Polarity (CVT Mode) */
+#define M1680x1050_R60_HSP      NEGATIVE
+#define M1680x1050_R60_VSP      NEGATIVE
+
+/* 1680x1050@60 Sync Polarity (CVT Reduce Blanking Mode) */
+#define M1680x1050_RB_R60_HSP      POSITIVE
+#define M1680x1050_RB_R60_VSP      NEGATIVE
+
+/* 1680x1050@75 Sync Polarity (CVT Mode) */
+#define M1680x1050_R75_HSP      NEGATIVE
+#define M1680x1050_R75_VSP      POSITIVE
+
+/*1920x1080@60 Sync Polarity (CVT Mode)
+*/
+#define M1920X1080_R60_HSP      NEGATIVE
+#define M1920X1080_R60_VSP      POSITIVE
+
+/* 1920x1080@60 Sync Polarity (CVT Reduce Blanking Mode) */
+#define M1920X1080_RB_R60_HSP  POSITIVE
+#define M1920X1080_RB_R60_VSP  NEGATIVE
+
+/*1920x1440@60 Sync Polarity (VESA Mode)
+*/
+#define M1920X1440_R60_HSP      NEGATIVE
+#define M1920X1440_R60_VSP      POSITIVE
+
+/*1920x1440@75 Sync Polarity (VESA Mode)
+*/
+#define M1920X1440_R75_HSP      NEGATIVE
+#define M1920X1440_R75_VSP      POSITIVE
+
+#if 0
+/* 1400x1050@60 Sync Polarity (VESA Mode) */
+#define M1400X1050_R60_HSP      NEGATIVE
+#define M1400X1050_R60_VSP      NEGATIVE
+#endif
+
+/* 1400x1050@60 Sync Polarity (CVT Mode) */
+#define M1400X1050_R60_HSP      NEGATIVE
+#define M1400X1050_R60_VSP      POSITIVE
+
+/* 1400x1050@60 Sync Polarity (CVT Reduce Blanking Mode) */
+#define M1400X1050_RB_R60_HSP      POSITIVE
+#define M1400X1050_RB_R60_VSP      NEGATIVE
+
+/* 1400x1050@75 Sync Polarity (CVT Mode) */
+#define M1400X1050_R75_HSP      NEGATIVE
+#define M1400X1050_R75_VSP      POSITIVE
+
+/* 960x600@60 Sync Polarity (CVT Mode) */
+#define M960X600_R60_HSP        NEGATIVE
+#define M960X600_R60_VSP        POSITIVE
+
+/* 1000x600@60 Sync Polarity (GTF Mode) */
+#define M1000X600_R60_HSP       NEGATIVE
+#define M1000X600_R60_VSP       POSITIVE
+
+/* 1024x576@60 Sync Polarity (GTF Mode) */
+#define M1024X576_R60_HSP       NEGATIVE
+#define M1024X576_R60_VSP       POSITIVE
+
+/*1024x600@60 Sync Polarity (GTF Mode)*/
+#define M1024X600_R60_HSP       NEGATIVE
+#define M1024X600_R60_VSP       POSITIVE
+
+/* 1088x612@60 Sync Polarity (CVT Mode) */
+#define M1088X612_R60_HSP       NEGATIVE
+#define M1088X612_R60_VSP       POSITIVE
+
+/* 1152x720@60 Sync Polarity (CVT Mode) */
+#define M1152X720_R60_HSP       NEGATIVE
+#define M1152X720_R60_VSP       POSITIVE
+
+/* 1200x720@60 Sync Polarity (GTF Mode) */
+#define M1200X720_R60_HSP       NEGATIVE
+#define M1200X720_R60_VSP       POSITIVE
+
+/* 1280x600@60 Sync Polarity (GTF Mode) */
+#define M1280x600_R60_HSP       NEGATIVE
+#define M1280x600_R60_VSP       POSITIVE
+
+/* 1280x720@50 Sync Polarity  (GTF Mode) */
+#define M1280X720_R50_HSP       NEGATIVE
+#define M1280X720_R50_VSP       POSITIVE
+
+/* 1280x720@60 Sync Polarity  (CEA Mode) */
+#define M1280X720_CEA_R60_HSP       POSITIVE
+#define M1280X720_CEA_R60_VSP       POSITIVE
+
+/* 1440x900@60 Sync Polarity (CVT Mode) */
+#define M1440X900_R60_HSP       NEGATIVE
+#define M1440X900_R60_VSP       POSITIVE
+
+/* 1440x900@75 Sync Polarity (CVT Mode) */
+#define M1440X900_R75_HSP       NEGATIVE
+#define M1440X900_R75_VSP       POSITIVE
+
+/* 1440x900@60 Sync Polarity (CVT Reduce Blanking Mode) */
+#define M1440X900_RB_R60_HSP       POSITIVE
+#define M1440X900_RB_R60_VSP       NEGATIVE
+
+/* 1600x900@60 Sync Polarity (CVT Mode) */
+#define M1600X900_R60_HSP       NEGATIVE
+#define M1600X900_R60_VSP       POSITIVE
+
+/* 1600x900@60 Sync Polarity (CVT Reduce Blanking Mode) */
+#define M1600X900_RB_R60_HSP       POSITIVE
+#define M1600X900_RB_R60_VSP       NEGATIVE
+
+/* 1600x1024@60 Sync Polarity (GTF Mode) */
+#define M1600X1024_R60_HSP      NEGATIVE
+#define M1600X1024_R60_VSP      POSITIVE
+
+/* 1792x1344@60 Sync Polarity (DMT Mode) */
+#define M1792x1344_R60_HSP      NEGATIVE
+#define M1792x1344_R60_VSP      POSITIVE
+
+/* 1856x1392@60 Sync Polarity (DMT Mode) */
+#define M1856x1392_R60_HSP      NEGATIVE
+#define M1856x1392_R60_VSP      POSITIVE
+
+/* 1920x1200@60 Sync Polarity (CVT Mode) */
+#define M1920X1200_R60_HSP      NEGATIVE
+#define M1920X1200_R60_VSP      POSITIVE
+
+/* 1920x1200@60 Sync Polarity (CVT Reduce Blanking Mode) */
+#define M1920X1200_RB_R60_HSP  POSITIVE
+#define M1920X1200_RB_R60_VSP  NEGATIVE
+
+/* 1920x1080@60 Sync Polarity  (CEA Mode) */
+#define M1920X1080_CEA_R60_HSP       POSITIVE
+#define M1920X1080_CEA_R60_VSP       POSITIVE
+
+/* 2048x1536@60 Sync Polarity (CVT Mode) */
+#define M2048x1536_R60_HSP      NEGATIVE
+#define M2048x1536_R60_VSP      POSITIVE
+
+/* define PLL index: */
+#define CLK_25_175M     25175000
+#define CLK_26_880M     26880000
+#define CLK_29_581M     29581000
+#define CLK_31_490M     31490000
+#define CLK_31_500M     31500000
+#define CLK_31_728M     31728000
+#define CLK_32_668M     32688000
+#define CLK_36_000M     36000000
+#define CLK_40_000M     40000000
+#define CLK_41_291M     41291000
+#define CLK_43_163M     43163000
+#define CLK_45_250M     45250000	/* 45.46MHz */
+#define CLK_46_000M     46000000
+#define CLK_46_996M     46996000
+#define CLK_48_000M     48000000
+#define CLK_48_875M     48875000
+#define CLK_49_500M     49500000
+#define CLK_52_406M     52406000
+#define CLK_52_977M     52977000
+#define CLK_56_250M     56250000
+#define CLK_60_466M     60466000
+#define CLK_61_500M     61500000
+#define CLK_65_000M     65000000
+#define CLK_65_178M     65178000
+#define CLK_66_750M     66750000	/* 67.116MHz */
+#define CLK_68_179M     68179000
+#define CLK_69_924M     69924000
+#define CLK_70_159M     70159000
+#define CLK_72_000M     72000000
+#define CLK_74_270M     74270000
+#define CLK_78_750M     78750000
+#define CLK_80_136M     80136000
+#define CLK_83_375M     83375000
+#define CLK_83_950M     83950000
+#define CLK_84_750M     84750000	/* 84.537Mhz */
+#define CLK_85_860M     85860000
+#define CLK_88_750M     88750000
+#define CLK_94_500M     94500000
+#define CLK_97_750M     97750000
+#define CLK_101_000M    101000000
+#define CLK_106_500M    106500000
+#define CLK_108_000M    108000000
+#define CLK_113_309M    113309000
+#define CLK_118_840M    118840000
+#define CLK_119_000M    119000000
+#define CLK_121_750M    121750000	/* 121.704MHz */
+#define CLK_125_104M    125104000
+#define CLK_133_308M    133308000
+#define CLK_135_000M    135000000
+#define CLK_136_700M    136700000
+#define CLK_138_400M    138400000
+#define CLK_146_760M    146760000
+#define CLK_148_500M    148500000
+
+#define CLK_153_920M    153920000
+#define CLK_156_000M    156000000
+#define CLK_157_500M    157500000
+#define CLK_162_000M    162000000
+#define CLK_187_000M    187000000
+#define CLK_193_295M    193295000
+#define CLK_202_500M    202500000
+#define CLK_204_000M    204000000
+#define CLK_218_500M    218500000
+#define CLK_234_000M    234000000
+#define CLK_267_250M    267250000
+#define CLK_297_500M    297500000
+#define CLK_74_481M     74481000
+#define CLK_172_798M    172798000
+#define CLK_122_614M    122614000
+
+/* CLE266 PLL value
+*/
+#define CLE266_PLL_25_175M     0x0000C763
+#define CLE266_PLL_26_880M     0x0000440F
+#define CLE266_PLL_29_581M     0x00008421
+#define CLE266_PLL_31_490M     0x00004721
+#define CLE266_PLL_31_500M     0x0000C3B5
+#define CLE266_PLL_31_728M     0x0000471F
+#define CLE266_PLL_32_668M     0x0000C449
+#define CLE266_PLL_36_000M     0x0000C5E5
+#define CLE266_PLL_40_000M     0x0000C459
+#define CLE266_PLL_41_291M     0x00004417
+#define CLE266_PLL_43_163M     0x0000C579
+#define CLE266_PLL_45_250M     0x0000C57F	/* 45.46MHz */
+#define CLE266_PLL_46_000M     0x0000875A
+#define CLE266_PLL_46_996M     0x0000C4E9
+#define CLE266_PLL_48_000M     0x00001443
+#define CLE266_PLL_48_875M     0x00001D63
+#define CLE266_PLL_49_500M     0x00008653
+#define CLE266_PLL_52_406M     0x0000C475
+#define CLE266_PLL_52_977M     0x00004525
+#define CLE266_PLL_56_250M     0x000047B7
+#define CLE266_PLL_60_466M     0x0000494C
+#define CLE266_PLL_61_500M     0x00001456
+#define CLE266_PLL_65_000M     0x000086ED
+#define CLE266_PLL_65_178M     0x0000855B
+#define CLE266_PLL_66_750M     0x0000844B	/* 67.116MHz */
+#define CLE266_PLL_68_179M     0x00000413
+#define CLE266_PLL_69_924M     0x00001153
+#define CLE266_PLL_70_159M     0x00001462
+#define CLE266_PLL_72_000M     0x00001879
+#define CLE266_PLL_74_270M     0x00004853
+#define CLE266_PLL_78_750M     0x00004321
+#define CLE266_PLL_80_136M     0x0000051C
+#define CLE266_PLL_83_375M     0x0000C25D
+#define CLE266_PLL_83_950M     0x00000729
+#define CLE266_PLL_84_750M     0x00008576	/* 84.537MHz */
+#define CLE266_PLL_85_860M     0x00004754
+#define CLE266_PLL_88_750M     0x0000051F
+#define CLE266_PLL_94_500M     0x00000521
+#define CLE266_PLL_97_750M     0x00004652
+#define CLE266_PLL_101_000M    0x0000497F
+#define CLE266_PLL_106_500M    0x00008477	/* 106.491463 MHz */
+#define CLE266_PLL_108_000M    0x00008479
+#define CLE266_PLL_113_309M    0x00000C5F
+#define CLE266_PLL_118_840M    0x00004553
+#define CLE266_PLL_119_000M    0x00000D6C
+#define CLE266_PLL_121_750M    0x00004555	/* 121.704MHz */
+#define CLE266_PLL_125_104M    0x000006B5
+#define CLE266_PLL_133_308M    0x0000465F
+#define CLE266_PLL_135_000M    0x0000455E
+#define CLE266_PLL_136_700M    0x00000C73
+#define CLE266_PLL_138_400M    0x00000957
+#define CLE266_PLL_146_760M    0x00004567
+#define CLE266_PLL_148_500M    0x00000853
+#define CLE266_PLL_153_920M    0x00000856
+#define CLE266_PLL_156_000M    0x0000456D
+#define CLE266_PLL_157_500M    0x000005B7
+#define CLE266_PLL_162_000M    0x00004571
+#define CLE266_PLL_187_000M    0x00000976
+#define CLE266_PLL_193_295M    0x0000086C
+#define CLE266_PLL_202_500M    0x00000763
+#define CLE266_PLL_204_000M    0x00000764
+#define CLE266_PLL_218_500M    0x0000065C
+#define CLE266_PLL_234_000M    0x00000662
+#define CLE266_PLL_267_250M    0x00000670
+#define CLE266_PLL_297_500M    0x000005E6
+#define CLE266_PLL_74_481M     0x0000051A
+#define CLE266_PLL_172_798M    0x00004579
+#define CLE266_PLL_122_614M    0x0000073C
+
+/* K800 PLL value
+*/
+#define K800_PLL_25_175M     0x00539001
+#define K800_PLL_26_880M     0x001C8C80
+#define K800_PLL_29_581M     0x00409080
+#define K800_PLL_31_490M     0x006F9001
+#define K800_PLL_31_500M     0x008B9002
+#define K800_PLL_31_728M     0x00AF9003
+#define K800_PLL_32_668M     0x00909002
+#define K800_PLL_36_000M     0x009F9002
+#define K800_PLL_40_000M     0x00578C02
+#define K800_PLL_41_291M     0x00438C01
+#define K800_PLL_43_163M     0x00778C03
+#define K800_PLL_45_250M     0x007D8C83	/* 45.46MHz */
+#define K800_PLL_46_000M     0x00658C02
+#define K800_PLL_46_996M     0x00818C83
+#define K800_PLL_48_000M     0x00848C83
+#define K800_PLL_48_875M     0x00508C81
+#define K800_PLL_49_500M     0x00518C01
+#define K800_PLL_52_406M     0x00738C02
+#define K800_PLL_52_977M     0x00928C83
+#define K800_PLL_56_250M     0x007C8C02
+#define K800_PLL_60_466M     0x00A78C83
+#define K800_PLL_61_500M     0x00AA8C83
+#define K800_PLL_65_000M     0x006B8C01
+#define K800_PLL_65_178M     0x00B48C83
+#define K800_PLL_66_750M     0x00948C82	/* 67.116MHz */
+#define K800_PLL_68_179M     0x00708C01
+#define K800_PLL_69_924M     0x00C18C83
+#define K800_PLL_70_159M     0x00C28C83
+#define K800_PLL_72_000M     0x009F8C82
+#define K800_PLL_74_270M     0x00ce0c03
+#define K800_PLL_78_750M     0x00408801
+#define K800_PLL_80_136M     0x00428801
+#define K800_PLL_83_375M     0x005B0882
+#define K800_PLL_83_950M     0x00738803
+#define K800_PLL_84_750M     0x00748883	/* 84.477MHz */
+#define K800_PLL_85_860M     0x00768883
+#define K800_PLL_88_750M     0x007A8883
+#define K800_PLL_94_500M     0x00828803
+#define K800_PLL_97_750M     0x00878883
+#define K800_PLL_101_000M    0x008B8883
+#define K800_PLL_106_500M    0x00758882	/* 106.491463 MHz */
+#define K800_PLL_108_000M    0x00778882
+#define K800_PLL_113_309M    0x005D8881
+#define K800_PLL_118_840M    0x00A48883
+#define K800_PLL_119_000M    0x00838882
+#define K800_PLL_121_750M    0x00A88883	/* 121.704MHz */
+#define K800_PLL_125_104M    0x00688801
+#define K800_PLL_133_308M    0x005D8801
+#define K800_PLL_135_000M    0x001A4081
+#define K800_PLL_136_700M    0x00BD8883
+#define K800_PLL_138_400M    0x00728881
+#define K800_PLL_146_760M    0x00CC8883
+#define K800_PLL_148_500M    0x00ce0803
+#define K800_PLL_153_920M    0x00548482
+#define K800_PLL_156_000M    0x006B8483
+#define K800_PLL_157_500M    0x00142080
+#define K800_PLL_162_000M    0x006F8483
+#define K800_PLL_187_000M    0x00818483
+#define K800_PLL_193_295M    0x004F8481
+#define K800_PLL_202_500M    0x00538481
+#define K800_PLL_204_000M    0x008D8483
+#define K800_PLL_218_500M    0x00978483
+#define K800_PLL_234_000M    0x00608401
+#define K800_PLL_267_250M    0x006E8481
+#define K800_PLL_297_500M    0x00A48402
+#define K800_PLL_74_481M     0x007B8C81
+#define K800_PLL_172_798M    0x00778483
+#define K800_PLL_122_614M    0x00878882
+
+/* PLL for VT3324 */
+#define CX700_25_175M     0x008B1003
+#define CX700_26_719M     0x00931003
+#define CX700_26_880M     0x00941003
+#define CX700_29_581M     0x00A49003
+#define CX700_31_490M     0x00AE1003
+#define CX700_31_500M     0x00AE1003
+#define CX700_31_728M     0x00AF1003
+#define CX700_32_668M     0x00B51003
+#define CX700_36_000M     0x00C81003
+#define CX700_40_000M     0x006E0C03
+#define CX700_41_291M     0x00710C03
+#define CX700_43_163M     0x00770C03
+#define CX700_45_250M     0x007D0C03	/* 45.46MHz */
+#define CX700_46_000M     0x007F0C03
+#define CX700_46_996M     0x00818C83
+#define CX700_48_000M     0x00840C03
+#define CX700_48_875M     0x00508C81
+#define CX700_49_500M     0x00880C03
+#define CX700_52_406M     0x00730C02
+#define CX700_52_977M     0x00920C03
+#define CX700_56_250M     0x009B0C03
+#define CX700_60_466M     0x00460C00
+#define CX700_61_500M     0x00AA0C03
+#define CX700_65_000M     0x006B0C01
+#define CX700_65_178M     0x006B0C01
+#define CX700_66_750M     0x00940C02	/*67.116MHz */
+#define CX700_68_179M     0x00BC0C03
+#define CX700_69_924M     0x00C10C03
+#define CX700_70_159M     0x00C20C03
+#define CX700_72_000M     0x009F0C02
+#define CX700_74_270M     0x00CE0C03
+#define CX700_74_481M     0x00CE0C03
+#define CX700_78_750M     0x006C0803
+#define CX700_80_136M     0x006E0803
+#define CX700_83_375M     0x005B0882
+#define CX700_83_950M     0x00730803
+#define CX700_84_750M     0x00740803	/* 84.537Mhz */
+#define CX700_85_860M     0x00760803
+#define CX700_88_750M     0x00AC8885
+#define CX700_94_500M     0x00820803
+#define CX700_97_750M     0x00870803
+#define CX700_101_000M    0x008B0803
+#define CX700_106_500M    0x00750802
+#define CX700_108_000M    0x00950803
+#define CX700_113_309M    0x005D0801
+#define CX700_118_840M    0x00A40803
+#define CX700_119_000M    0x00830802
+#define CX700_121_750M    0x00420800	/* 121.704MHz */
+#define CX700_125_104M    0x00AD0803
+#define CX700_133_308M    0x00930802
+#define CX700_135_000M    0x00950802
+#define CX700_136_700M    0x00BD0803
+#define CX700_138_400M    0x00720801
+#define CX700_146_760M    0x00CC0803
+#define CX700_148_500M    0x00a40802
+#define CX700_153_920M    0x00540402
+#define CX700_156_000M    0x006B0403
+#define CX700_157_500M    0x006C0403
+#define CX700_162_000M    0x006F0403
+#define CX700_172_798M    0x00770403
+#define CX700_187_000M    0x00810403
+#define CX700_193_295M    0x00850403
+#define CX700_202_500M    0x008C0403
+#define CX700_204_000M    0x008D0403
+#define CX700_218_500M    0x00970403
+#define CX700_234_000M    0x00600401
+#define CX700_267_250M    0x00B90403
+#define CX700_297_500M    0x00CE0403
+#define CX700_122_614M    0x00870802
+
+/* Definition CRTC Timing Index */
+#define H_TOTAL_INDEX               0
+#define H_ADDR_INDEX                1
+#define H_BLANK_START_INDEX         2
+#define H_BLANK_END_INDEX           3
+#define H_SYNC_START_INDEX          4
+#define H_SYNC_END_INDEX            5
+#define V_TOTAL_INDEX               6
+#define V_ADDR_INDEX                7
+#define V_BLANK_START_INDEX         8
+#define V_BLANK_END_INDEX           9
+#define V_SYNC_START_INDEX          10
+#define V_SYNC_END_INDEX            11
+#define H_TOTAL_SHADOW_INDEX        12
+#define H_BLANK_END_SHADOW_INDEX    13
+#define V_TOTAL_SHADOW_INDEX        14
+#define V_ADDR_SHADOW_INDEX         15
+#define V_BLANK_SATRT_SHADOW_INDEX  16
+#define V_BLANK_END_SHADOW_INDEX    17
+#define V_SYNC_SATRT_SHADOW_INDEX   18
+#define V_SYNC_END_SHADOW_INDEX     19
+
+/* Definition Video Mode Pixel Clock (picoseconds)
+*/
+#define RES_480X640_60HZ_PIXCLOCK    39722
+#define RES_640X480_60HZ_PIXCLOCK    39722
+#define RES_640X480_75HZ_PIXCLOCK    31747
+#define RES_640X480_85HZ_PIXCLOCK    27777
+#define RES_640X480_100HZ_PIXCLOCK   23168
+#define RES_640X480_120HZ_PIXCLOCK   19081
+#define RES_720X480_60HZ_PIXCLOCK    37020
+#define RES_720X576_60HZ_PIXCLOCK    30611
+#define RES_800X600_60HZ_PIXCLOCK    25000
+#define RES_800X600_75HZ_PIXCLOCK    20203
+#define RES_800X600_85HZ_PIXCLOCK    17777
+#define RES_800X600_100HZ_PIXCLOCK   14667
+#define RES_800X600_120HZ_PIXCLOCK   11912
+#define RES_800X480_60HZ_PIXCLOCK    33805
+#define RES_848X480_60HZ_PIXCLOCK    31756
+#define RES_856X480_60HZ_PIXCLOCK    31518
+#define RES_1024X512_60HZ_PIXCLOCK   24218
+#define RES_1024X600_60HZ_PIXCLOCK   20460
+#define RES_1024X768_60HZ_PIXCLOCK   15385
+#define RES_1024X768_75HZ_PIXCLOCK   12699
+#define RES_1024X768_85HZ_PIXCLOCK   10582
+#define RES_1024X768_100HZ_PIXCLOCK  8825
+#define RES_1152X864_75HZ_PIXCLOCK   9259
+#define RES_1280X768_60HZ_PIXCLOCK   12480
+#define RES_1280X800_60HZ_PIXCLOCK   11994
+#define RES_1280X960_60HZ_PIXCLOCK   9259
+#define RES_1280X1024_60HZ_PIXCLOCK  9260
+#define RES_1280X1024_75HZ_PIXCLOCK  7408
+#define RES_1280X768_85HZ_PIXCLOCK   6349
+#define RES_1440X1050_60HZ_PIXCLOCK  7993
+#define RES_1600X1200_60HZ_PIXCLOCK  6172
+#define RES_1600X1200_75HZ_PIXCLOCK  4938
+#define RES_1280X720_60HZ_PIXCLOCK   13426
+#define RES_1920X1080_60HZ_PIXCLOCK  5787
+#define RES_1400X1050_60HZ_PIXCLOCK  8214
+#define RES_1400X1050_75HZ_PIXCLOCK  6410
+#define RES_1368X768_60HZ_PIXCLOCK   11647
+#define RES_960X600_60HZ_PIXCLOCK      22099
+#define RES_1000X600_60HZ_PIXCLOCK    20834
+#define RES_1024X576_60HZ_PIXCLOCK    21278
+#define RES_1088X612_60HZ_PIXCLOCK    18877
+#define RES_1152X720_60HZ_PIXCLOCK    14981
+#define RES_1200X720_60HZ_PIXCLOCK    14253
+#define RES_1280X600_60HZ_PIXCLOCK    16260
+#define RES_1280X720_50HZ_PIXCLOCK    16538
+#define RES_1280X768_50HZ_PIXCLOCK    15342
+#define RES_1366X768_50HZ_PIXCLOCK    14301
+#define RES_1366X768_60HZ_PIXCLOCK    11646
+#define RES_1360X768_60HZ_PIXCLOCK    11799
+#define RES_1440X900_60HZ_PIXCLOCK    9390
+#define RES_1440X900_75HZ_PIXCLOCK    7315
+#define RES_1600X900_60HZ_PIXCLOCK    8415
+#define RES_1600X1024_60HZ_PIXCLOCK   7315
+#define RES_1680X1050_60HZ_PIXCLOCK   6814
+#define RES_1680X1050_75HZ_PIXCLOCK   5348
+#define RES_1792X1344_60HZ_PIXCLOCK   4902
+#define RES_1856X1392_60HZ_PIXCLOCK   4577
+#define RES_1920X1200_60HZ_PIXCLOCK   5173
+#define RES_1920X1440_60HZ_PIXCLOCK   4274
+#define RES_1920X1440_75HZ_PIXCLOCK   3367
+#define RES_2048X1536_60HZ_PIXCLOCK   3742
+
+#define RES_1360X768_RB_60HZ_PIXCLOCK 13889
+#define RES_1400X1050_RB_60HZ_PIXCLOCK 9901
+#define RES_1440X900_RB_60HZ_PIXCLOCK   11268
+#define RES_1600X900_RB_60HZ_PIXCLOCK   10230
+#define RES_1680X1050_RB_60HZ_PIXCLOCK 8403
+#define RES_1920X1080_RB_60HZ_PIXCLOCK 7225
+#define RES_1920X1200_RB_60HZ_PIXCLOCK 6497
+
+/* LCD display method
+*/
+#define     LCD_EXPANDSION              0x00
+#define     LCD_CENTERING               0x01
+
+/* LCD mode
+*/
+#define     LCD_OPENLDI               0x00
+#define     LCD_SPWG                  0x01
+
+/* Define display timing
+*/
+struct display_timing {
+	u16 hor_total;
+	u16 hor_addr;
+	u16 hor_blank_start;
+	u16 hor_blank_end;
+	u16 hor_sync_start;
+	u16 hor_sync_end;
+	u16 ver_total;
+	u16 ver_addr;
+	u16 ver_blank_start;
+	u16 ver_blank_end;
+	u16 ver_sync_start;
+	u16 ver_sync_end;
+};
+
+struct crt_mode_table {
+	int refresh_rate;
+	unsigned long clk;
+	int h_sync_polarity;
+	int v_sync_polarity;
+	struct display_timing crtc;
+};
+
+struct io_reg {
+	int port;
+	u8 index;
+	u8 mask;
+	u8 value;
+};
+
+#endif /* __SHARE_H__ */
--- /dev/null
+++ b/drivers/video/via/tbl1636.c
@@ -0,0 +1,71 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "global.h"
+struct IODATA COMMON_INIT_TBL_VT1636[] = {
+/*  Index, Mask, Value */
+	/* Set panel power sequence timing */
+	{0x10, 0xC0, 0x00},
+	/* T1: VDD on - Data on. Each increment is 1 ms. (50ms = 031h) */
+	{0x0B, 0xFF, 0x40},
+	/* T2: Data on - Backlight on. Each increment is 2 ms. (210ms = 068h) */
+	{0x0C, 0xFF, 0x31},
+	/* T3: Backlight off -Data off. Each increment is 2 ms. (210ms = 068h)*/
+	{0x0D, 0xFF, 0x31},
+	/* T4: Data off - VDD off. Each increment is 1 ms. (50ms = 031h) */
+	{0x0E, 0xFF, 0x68},
+	/* T5: VDD off - VDD on. Each increment is 100 ms. (500ms = 04h) */
+	{0x0F, 0xFF, 0x68},
+	/* LVDS output power up */
+	{0x09, 0xA0, 0xA0},
+	/* turn on back light */
+	{0x10, 0x33, 0x13}
+};
+
+struct IODATA DUAL_CHANNEL_ENABLE_TBL_VT1636[] = {
+/*  Index, Mask, Value */
+	{0x08, 0xF0, 0xE0}	/* Input Data Mode Select */
+};
+
+struct IODATA SINGLE_CHANNEL_ENABLE_TBL_VT1636[] = {
+/*  Index, Mask, Value */
+	{0x08, 0xF0, 0x00}	/* Input Data Mode Select */
+};
+
+struct IODATA DITHERING_ENABLE_TBL_VT1636[] = {
+/*  Index, Mask, Value */
+	{0x0A, 0x70, 0x50}
+};
+
+struct IODATA DITHERING_DISABLE_TBL_VT1636[] = {
+/*  Index, Mask, Value */
+	{0x0A, 0x70, 0x00}
+};
+
+struct IODATA VDD_ON_TBL_VT1636[] = {
+/*  Index, Mask, Value */
+	{0x10, 0x20, 0x20}
+};
+
+struct IODATA VDD_OFF_TBL_VT1636[] = {
+/*  Index, Mask, Value */
+	{0x10, 0x20, 0x00}
+};
--- /dev/null
+++ b/drivers/video/via/tbl1636.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _TBL1636_H_
+#define _TBL1636_H_
+#include "hw.h"
+
+extern struct IODATA COMMON_INIT_TBL_VT1636[8];
+extern struct IODATA DUAL_CHANNEL_ENABLE_TBL_VT1636[1];
+extern struct IODATA SINGLE_CHANNEL_ENABLE_TBL_VT1636[1];
+extern struct IODATA DITHERING_ENABLE_TBL_VT1636[1];
+extern struct IODATA DITHERING_DISABLE_TBL_VT1636[1];
+extern struct IODATA VDD_ON_TBL_VT1636[1];
+extern struct IODATA VDD_OFF_TBL_VT1636[1];
+
+#endif /* _VIA_TBL1636_H_ */
--- /dev/null
+++ b/drivers/video/via/tblDPASetting.c
@@ -0,0 +1,109 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "global.h"
+/* For VT3324: */
+struct VT1636_DPA_SETTING VT1636_DPA_SETTING_TBL_VT3324[] = {
+	/* Panel ID,       CLK_SEL_ST1[09],    CLK_SEL_ST2[08] */
+	{LCD_PANEL_ID0_640X480, 0x00, 0x00},	/* For 640x480   */
+	{LCD_PANEL_ID1_800X600, 0x00, 0x00},	/* For 800x600   */
+	{LCD_PANEL_ID2_1024X768, 0x00, 0x00},	/* For 1024x768  */
+	{LCD_PANEL_ID3_1280X768, 0x00, 0x00},	/* For 1280x768  */
+	{LCD_PANEL_ID4_1280X1024, 0x00, 0x00},	/* For 1280x1024 */
+	{LCD_PANEL_ID5_1400X1050, 0x00, 0x00},	/* For 1400x1050 */
+	{LCD_PANEL_ID6_1600X1200, 0x0B, 0x03}	/* For 1600x1200 */
+};
+
+struct GFX_DPA_SETTING GFX_DPA_SETTING_TBL_VT3324[] = {
+/*  ClkRange, DVP0, DVP0DataDriving,  DVP0ClockDriving, DVP1,
+					DVP1Driving, DFPHigh, DFPLow */
+/*  CR96, SR2A[5], SR1B[1], SR2A[4], SR1E[2], CR9B,
+					SR65,        CR97,    CR99   */
+	/* LCK/VCK < 30000000 will use this value */
+	{DPA_CLK_RANGE_30M, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
+	 0x00},
+	/* 30000000 < LCK/VCK < 50000000 will use this value */
+	{DPA_CLK_RANGE_30_50M, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
+	 0x00},
+	/* 50000000 < LCK/VCK < 70000000 will use this value */
+	{DPA_CLK_RANGE_50_70M, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
+	 0x00},
+	/* 70000000 < LCK/VCK < 100000000 will use this value */
+	{DPA_CLK_RANGE_70_100M, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
+	 0x00},
+	/* 100000000 < LCK/VCK < 15000000 will use this value */
+	{DPA_CLK_RANGE_100_150M, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
+	 0x00},
+	/* 15000000 < LCK/VCK will use this value */
+	{DPA_CLK_RANGE_150M, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0E, 0x00,
+	 0x00},
+};
+
+/* For VT3327: */
+struct VT1636_DPA_SETTING VT1636_DPA_SETTING_TBL_VT3327[] = {
+	/* Panel ID,       CLK_SEL_ST1[09],    CLK_SEL_ST2[08] */
+	{LCD_PANEL_ID0_640X480, 0x00, 0x00},	/* For 640x480   */
+	{LCD_PANEL_ID1_800X600, 0x00, 0x00},	/* For 800x600   */
+	{LCD_PANEL_ID2_1024X768, 0x00, 0x00},	/* For 1024x768  */
+	{LCD_PANEL_ID3_1280X768, 0x00, 0x00},	/* For 1280x768  */
+	{LCD_PANEL_ID4_1280X1024, 0x00, 0x00},	/* For 1280x1024 */
+	{LCD_PANEL_ID5_1400X1050, 0x00, 0x00},	/* For 1400x1050 */
+	{LCD_PANEL_ID6_1600X1200, 0x00, 0x00}	/* For 1600x1200 */
+};
+
+struct GFX_DPA_SETTING GFX_DPA_SETTING_TBL_VT3327[] = {
+/*  ClkRange,DVP0, DVP0DataDriving,  DVP0ClockDriving, DVP1,
+					DVP1Driving, DFPHigh,   DFPLow */
+/*   CR96, SR2A[5], SR1B[1], SR2A[4], SR1E[2], CR9B,
+					SR65,        CR97,      CR99   */
+/* LCK/VCK < 30000000 will use this value */
+{DPA_CLK_RANGE_30M, 0x07, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x08, 0x01},
+/* 30000000 < LCK/VCK < 50000000 will use this value */
+{DPA_CLK_RANGE_30_50M, 0x07, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x08, 0x01},
+/* 50000000 < LCK/VCK < 70000000 will use this value */
+{DPA_CLK_RANGE_50_70M, 0x06, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x08, 0x01},
+/* 70000000 < LCK/VCK < 100000000 will use this value */
+{DPA_CLK_RANGE_70_100M, 0x03, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x08, 0x03},
+/* 100000000 < LCK/VCK < 15000000 will use this value */
+{DPA_CLK_RANGE_100_150M, 0x03, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x02},
+/* 15000000 < LCK/VCK will use this value */
+{DPA_CLK_RANGE_150M, 0x00, 0x20, 0x00, 0x10, 0x00, 0x03, 0x00, 0x0D, 0x03},
+};
+
+/* For VT3364: */
+struct GFX_DPA_SETTING GFX_DPA_SETTING_TBL_VT3364[] = {
+/*  ClkRange,DVP0, DVP0DataDriving,  DVP0ClockDriving, DVP1,
+					DVP1Driving, DFPHigh,   DFPLow */
+/*   CR96, SR2A[5], SR1B[1], SR2A[4], SR1E[2], CR9B,
+					SR65,        CR97,      CR99   */
+/* LCK/VCK < 30000000 will use this value */
+{DPA_CLK_RANGE_30M, 0x07, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x08},
+/* 30000000 < LCK/VCK < 50000000 will use this value */
+{DPA_CLK_RANGE_30_50M, 0x07, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x08},
+/* 50000000 < LCK/VCK < 70000000 will use this value */
+{DPA_CLK_RANGE_50_70M, 0x07, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x08},
+/* 70000000 < LCK/VCK < 100000000 will use this value */
+{DPA_CLK_RANGE_70_100M, 0x07, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x08},
+/* 100000000 < LCK/VCK < 15000000 will use this value */
+{DPA_CLK_RANGE_100_150M, 0x03, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x08},
+/* 15000000 < LCK/VCK will use this value */
+{DPA_CLK_RANGE_150M, 0x01, 0x00, 0x02, 0x10, 0x00, 0x03, 0x00, 0x00, 0x08},
+};
--- /dev/null
+++ b/drivers/video/via/tblDPASetting.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _TBLDPASETTING_H_
+#define _TBLDPASETTING_H_
+#include "global.h"
+
+#define DPA_CLK_30M       30000000
+#define DPA_CLK_50M       50000000
+#define DPA_CLK_70M       70000000
+#define DPA_CLK_100M      100000000
+#define DPA_CLK_150M      150000000
+
+enum DPA_RANGE {
+	DPA_CLK_RANGE_30M,
+	DPA_CLK_RANGE_30_50M,
+	DPA_CLK_RANGE_50_70M,
+	DPA_CLK_RANGE_70_100M,
+	DPA_CLK_RANGE_100_150M,
+	DPA_CLK_RANGE_150M
+};
+
+extern struct VT1636_DPA_SETTING VT1636_DPA_SETTING_TBL_VT3324[7];
+extern struct GFX_DPA_SETTING GFX_DPA_SETTING_TBL_VT3324[6];
+extern struct VT1636_DPA_SETTING VT1636_DPA_SETTING_TBL_VT3327[7];
+extern struct GFX_DPA_SETTING GFX_DPA_SETTING_TBL_VT3327[];
+extern struct GFX_DPA_SETTING GFX_DPA_SETTING_TBL_VT3364[6];
+
+#endif
--- /dev/null
+++ b/drivers/video/via/viafbdev.c
@@ -0,0 +1,2571 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/module.h>
+#define _MASTER_FILE
+
+#include "global.h"
+
+static int MAX_CURS = 32;
+static struct fb_var_screeninfo default_var;
+static char *viafb_name = "Via";
+static u32 pseudo_pal[17];
+
+/* video mode */
+static char *viafb_mode = "640x480";
+static char *viafb_mode1 = "640x480";
+static int viafb_resMode = VIA_RES_640X480;
+
+/* Added for specifying active devices.*/
+char *viafb_active_dev = "";
+
+/* Added for specifying video on devices.*/
+char *viafb_video_dev = "";
+
+/*Added for specify lcd output port*/
+char *viafb_lcd_port = "";
+char *viafb_dvi_port = "";
+
+static void viafb_set_device(struct device_t active_dev);
+static int apply_device_setting(struct viafb_ioctl_setting setting_info,
+			 struct fb_info *info);
+static void apply_second_mode_setting(struct fb_var_screeninfo
+	*sec_var);
+static void retrieve_device_setting(struct viafb_ioctl_setting
+	*setting_info);
+static void viafb_set_video_device(u32 video_dev_info);
+static void viafb_get_video_device(u32 *video_dev_info);
+
+/* Mode information */
+static const struct viafb_modeinfo viafb_modentry[] = {
+	{480, 640, VIA_RES_480X640, "480x640"},
+	{640, 480, VIA_RES_640X480, "640x480"},
+	{800, 480, VIA_RES_800X480, "800x480"},
+	{800, 600, VIA_RES_800X600, "800x600"},
+	{1024, 768, VIA_RES_1024X768, "1024x768"},
+	{1152, 864, VIA_RES_1152X864, "1152x864"},
+	{1280, 1024, VIA_RES_1280X1024, "1280x1024"},
+	{1600, 1200, VIA_RES_1600X1200, "1600x1200"},
+	{1440, 1050, VIA_RES_1440X1050, "1440x1050"},
+	{1280, 768, VIA_RES_1280X768, "1280x768"},
+	{1280, 800, VIA_RES_1280X800, "1280x800"},
+	{1280, 960, VIA_RES_1280X960, "1280x960"},
+	{1920, 1440, VIA_RES_1920X1440, "1920x1440"},
+	{848, 480, VIA_RES_848X480, "848x480"},
+	{1400, 1050, VIA_RES_1400X1050, "1400x1050"},
+	{720, 480, VIA_RES_720X480, "720x480"},
+	{720, 576, VIA_RES_720X576, "720x576"},
+	{1024, 512, VIA_RES_1024X512, "1024x512"},
+	{1024, 576, VIA_RES_1024X576, "1024x576"},
+	{1024, 600, VIA_RES_1024X600, "1024x600"},
+	{1280, 720, VIA_RES_1280X720, "1280x720"},
+	{1920, 1080, VIA_RES_1920X1080, "1920x1080"},
+	{1366, 768, VIA_RES_1368X768, "1368x768"},
+	{1680, 1050, VIA_RES_1680X1050, "1680x1050"},
+	{960, 600, VIA_RES_960X600, "960x600"},
+	{1000, 600, VIA_RES_1000X600, "1000x600"},
+	{1024, 576, VIA_RES_1024X576, "1024x576"},
+	{1024, 600, VIA_RES_1024X600, "1024x600"},
+	{1088, 612, VIA_RES_1088X612, "1088x612"},
+	{1152, 720, VIA_RES_1152X720, "1152x720"},
+	{1200, 720, VIA_RES_1200X720, "1200x720"},
+	{1280, 600, VIA_RES_1280X600, "1280x600"},
+	{1360, 768, VIA_RES_1360X768, "1360x768"},
+	{1440, 900, VIA_RES_1440X900, "1440x900"},
+	{1600, 900, VIA_RES_1600X900, "1600x900"},
+	{1600, 1024, VIA_RES_1600X1024, "1600x1024"},
+	{1792, 1344, VIA_RES_1792X1344, "1792x1344"},
+	{1856, 1392, VIA_RES_1856X1392, "1856x1392"},
+	{1920, 1200, VIA_RES_1920X1200, "1920x1200"},
+	{2048, 1536, VIA_RES_2048X1536, "2048x1536"},
+	{0, 0, VIA_RES_INVALID, "640x480"}
+};
+
+static struct fb_ops viafb_ops;
+
+static int viafb_update_fix(struct fb_fix_screeninfo *fix, struct fb_info *info)
+{
+	struct viafb_par *ppar;
+	ppar = info->par;
+
+	DEBUG_MSG(KERN_INFO "viafb_update_fix!\n");
+
+	fix->visual =
+	    ppar->bpp == 8 ? FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;
+	fix->line_length = ppar->linelength;
+
+	return 0;
+}
+
+
+static void viafb_setup_fixinfo(struct fb_fix_screeninfo *fix,
+	struct viafb_par *viaparinfo)
+{
+	memset(fix, 0, sizeof(struct fb_fix_screeninfo));
+	strcpy(fix->id, viafb_name);
+
+	fix->smem_start = viaparinfo->fbmem;
+	fix->smem_len = viaparinfo->fbmem_free;
+	fix->mmio_start = viaparinfo->mmio_base;
+	fix->mmio_len = viaparinfo->mmio_len;
+
+	fix->type = FB_TYPE_PACKED_PIXELS;
+	fix->type_aux = 0;
+
+	fix->xpanstep = fix->ywrapstep = 0;
+	fix->ypanstep = 1;
+
+	/* Just tell the accel name */
+	viafbinfo->fix.accel = FB_ACCEL_VIA_UNICHROME;
+}
+static int viafb_open(struct fb_info *info, int user)
+{
+	DEBUG_MSG(KERN_INFO "viafb_open!\n");
+	return 0;
+}
+
+static int viafb_release(struct fb_info *info, int user)
+{
+	DEBUG_MSG(KERN_INFO "viafb_release!\n");
+	return 0;
+}
+
+static void viafb_update_viafb_par(struct fb_info *info)
+{
+	struct viafb_par *ppar;
+
+	ppar = info->par;
+	ppar->bpp = info->var.bits_per_pixel;
+	ppar->linelength = ((info->var.xres_virtual + 7) & ~7) * ppar->bpp / 8;
+	ppar->hres = info->var.xres;
+	ppar->vres = info->var.yres;
+	ppar->xoffset = info->var.xoffset;
+	ppar->yoffset = info->var.yoffset;
+}
+
+static int viafb_check_var(struct fb_var_screeninfo *var,
+	struct fb_info *info)
+{
+	int vmode_index, htotal, vtotal;
+	struct viafb_par *ppar;
+	u32 long_refresh;
+	struct viafb_par *p_viafb_par;
+	ppar = info->par;
+
+
+	DEBUG_MSG(KERN_INFO "viafb_check_var!\n");
+	/* Sanity check */
+	/* HW neither support interlacte nor double-scaned mode */
+	if (var->vmode & FB_VMODE_INTERLACED || var->vmode & FB_VMODE_DOUBLE)
+		return -EINVAL;
+
+	vmode_index = viafb_get_mode_index(var->xres, var->yres, 0);
+	if (vmode_index == VIA_RES_INVALID) {
+		DEBUG_MSG(KERN_INFO
+			  "viafb: Mode %dx%dx%d not supported!!\n",
+			  var->xres, var->yres, var->bits_per_pixel);
+		return -EINVAL;
+	}
+
+	if (24 == var->bits_per_pixel)
+		var->bits_per_pixel = 32;
+
+	if (var->bits_per_pixel != 8 && var->bits_per_pixel != 16 &&
+		var->bits_per_pixel != 32)
+		return -EINVAL;
+
+	if ((var->xres_virtual * (var->bits_per_pixel >> 3)) & 0x1F)
+		/*32 pixel alignment */
+		var->xres_virtual = (var->xres_virtual + 31) & ~31;
+	if (var->xres_virtual * var->yres_virtual * var->bits_per_pixel / 8 >
+		ppar->memsize)
+		return -EINVAL;
+
+	/* Based on var passed in to calculate the refresh,
+	 * because our driver use some modes special.
+	 */
+	htotal = var->xres + var->left_margin +
+	var->right_margin + var->hsync_len;
+	vtotal = var->yres + var->upper_margin +
+		var->lower_margin + var->vsync_len;
+	long_refresh = 1000000000UL / var->pixclock * 1000;
+	long_refresh /= (htotal * vtotal);
+
+	viafb_refresh = viafb_get_refresh(var->xres, var->yres, long_refresh);
+
+	/* Adjust var according to our driver's own table */
+	viafb_fill_var_timing_info(var, viafb_refresh, vmode_index);
+
+	/* This is indeed a patch for VT3353 */
+	if (!info->par)
+		return -1;
+	p_viafb_par = (struct viafb_par *)info->par;
+	if (p_viafb_par->chip_info->gfx_chip_name == UNICHROME_VX800)
+		var->accel_flags = 0;
+
+	return 0;
+}
+
+static int viafb_set_par(struct fb_info *info)
+{
+	int vmode_index;
+	int vmode_index1 = 0;
+	DEBUG_MSG(KERN_INFO "viafb_set_par!\n");
+
+	viafb_update_device_setting(info->var.xres, info->var.yres,
+			      info->var.bits_per_pixel, viafb_refresh, 0);
+
+	vmode_index = viafb_get_mode_index(info->var.xres, info->var.yres, 0);
+
+	if (viafb_SAMM_ON == 1) {
+		DEBUG_MSG(KERN_INFO
+		"viafb_second_xres = %d, viafb_second_yres = %d, bpp = %d\n",
+			  viafb_second_xres, viafb_second_yres, viafb_bpp1);
+		vmode_index1 = viafb_get_mode_index(viafb_second_xres,
+			viafb_second_yres, 1);
+		DEBUG_MSG(KERN_INFO "->viafb_SAMM_ON: index=%d\n",
+			vmode_index1);
+
+		viafb_update_device_setting(viafb_second_xres,
+			viafb_second_yres, viafb_bpp1, viafb_refresh1, 1);
+	}
+
+	if (vmode_index != VIA_RES_INVALID) {
+		viafb_setmode(vmode_index, info->var.xres, info->var.yres,
+			info->var.bits_per_pixel, vmode_index1,
+			viafb_second_xres, viafb_second_yres, viafb_bpp1);
+
+		/*We should set memory offset according virtual_x */
+		/*Fix me:put this function into viafb_setmode */
+		viafb_memory_pitch_patch(info);
+
+		/* Update ***fb_par information */
+		viafb_update_viafb_par(info);
+
+		/* Update other fixed information */
+		viafb_update_fix(&info->fix, info);
+		viafb_bpp = info->var.bits_per_pixel;
+		/* Update viafb_accel, it is necessary to our 2D accelerate */
+		viafb_accel = info->var.accel_flags;
+
+		if (viafb_accel)
+			viafb_set_2d_color_depth(info->var.bits_per_pixel);
+	}
+
+	return 0;
+}
+
+/* Set one color register */
+static int viafb_setcolreg(unsigned regno, unsigned red, unsigned green,
+unsigned blue, unsigned transp, struct fb_info *info)
+{
+	u8 sr1a, sr1b, cr67, cr6a, rev = 0, shift = 10;
+	unsigned cmap_entries = (info->var.bits_per_pixel == 8) ? 256 : 16;
+	DEBUG_MSG(KERN_INFO "viafb_setcolreg!\n");
+	if (regno >= cmap_entries)
+		return 1;
+	if (UNICHROME_CLE266 == viaparinfo->chip_info->gfx_chip_name) {
+		/*
+		 * Read PCI bus 0,dev 0,function 0,index 0xF6 to get chip rev.
+		 */
+		outl(0x80000000 | (0xf6 & ~3), (unsigned long)0xCF8);
+		rev = (inl((unsigned long)0xCFC) >> ((0xf6 & 3) * 8)) & 0xff;
+	}
+	switch (info->var.bits_per_pixel) {
+	case 8:
+		outb(0x1A, 0x3C4);
+		sr1a = inb(0x3C5);
+		outb(0x1B, 0x3C4);
+		sr1b = inb(0x3C5);
+		outb(0x67, 0x3D4);
+		cr67 = inb(0x3D5);
+		outb(0x6A, 0x3D4);
+		cr6a = inb(0x3D5);
+
+		/* Map the 3C6/7/8/9 to the IGA2 */
+		outb(0x1A, 0x3C4);
+		outb(sr1a | 0x01, 0x3C5);
+		/* Second Display Engine colck always on */
+		outb(0x1B, 0x3C4);
+		outb(sr1b | 0x80, 0x3C5);
+		/* Second Display Color Depth 8 */
+		outb(0x67, 0x3D4);
+		outb(cr67 & 0x3F, 0x3D5);
+		outb(0x6A, 0x3D4);
+		/* Second Display Channel Reset CR6A[6]) */
+		outb(cr6a & 0xBF, 0x3D5);
+		/* Second Display Channel Enable CR6A[7] */
+		outb(cr6a | 0x80, 0x3D5);
+		/* Second Display Channel stop reset) */
+		outb(cr6a | 0x40, 0x3D5);
+
+		/* Bit mask of palette */
+		outb(0xFF, 0x3c6);
+		/* Write one register of IGA2 */
+		outb(regno, 0x3C8);
+		if (UNICHROME_CLE266 == viaparinfo->chip_info->gfx_chip_name &&
+			rev >= 15) {
+			shift = 8;
+			viafb_write_reg_mask(CR6A, VIACR, BIT5, BIT5);
+			viafb_write_reg_mask(SR15, VIASR, BIT7, BIT7);
+		} else {
+			shift = 10;
+			viafb_write_reg_mask(CR6A, VIACR, 0, BIT5);
+			viafb_write_reg_mask(SR15, VIASR, 0, BIT7);
+		}
+		outb(red >> shift, 0x3C9);
+		outb(green >> shift, 0x3C9);
+		outb(blue >> shift, 0x3C9);
+
+		/* Map the 3C6/7/8/9 to the IGA1 */
+		outb(0x1A, 0x3C4);
+		outb(sr1a & 0xFE, 0x3C5);
+		/* Bit mask of palette */
+		outb(0xFF, 0x3c6);
+		/* Write one register of IGA1 */
+		outb(regno, 0x3C8);
+		outb(red >> shift, 0x3C9);
+		outb(green >> shift, 0x3C9);
+		outb(blue >> shift, 0x3C9);
+
+		outb(0x1A, 0x3C4);
+		outb(sr1a, 0x3C5);
+		outb(0x1B, 0x3C4);
+		outb(sr1b, 0x3C5);
+		outb(0x67, 0x3D4);
+		outb(cr67, 0x3D5);
+		outb(0x6A, 0x3D4);
+		outb(cr6a, 0x3D5);
+		break;
+	case 16:
+		((u32 *) info->pseudo_palette)[regno] = (red & 0xF800) |
+		    ((green & 0xFC00) >> 5) | ((blue & 0xF800) >> 11);
+		break;
+	case 32:
+		((u32 *) info->pseudo_palette)[regno] =
+		    ((transp & 0xFF00) << 16) |
+		    ((red & 0xFF00) << 8) |
+		    ((green & 0xFF00)) | ((blue & 0xFF00) >> 8);
+		break;
+	}
+
+	return 0;
+
+}
+
+/*CALLED BY: fb_set_cmap */
+/*           fb_set_var, pass 256 colors */
+/*CALLED BY: fb_set_cmap */
+/*           fbcon_set_palette, pass 16 colors */
+static int viafb_setcmap(struct fb_cmap *cmap, struct fb_info *info)
+{
+	u32 len = cmap->len;
+	u32 i;
+	u16 *pred = cmap->red;
+	u16 *pgreen = cmap->green;
+	u16 *pblue = cmap->blue;
+	u16 *ptransp = cmap->transp;
+	u8 sr1a, sr1b, cr67, cr6a, rev = 0, shift = 10;
+	if (len > 256)
+		return 1;
+	if (UNICHROME_CLE266 == viaparinfo->chip_info->gfx_chip_name) {
+		/*
+		 * Read PCI bus 0, dev 0, function 0, index 0xF6 to get chip
+		 * rev.
+		 */
+		outl(0x80000000 | (0xf6 & ~3), (unsigned long)0xCF8);
+		rev = (inl((unsigned long)0xCFC) >> ((0xf6 & 3) * 8)) & 0xff;
+	}
+	switch (info->var.bits_per_pixel) {
+	case 8:
+		outb(0x1A, 0x3C4);
+		sr1a = inb(0x3C5);
+		outb(0x1B, 0x3C4);
+		sr1b = inb(0x3C5);
+		outb(0x67, 0x3D4);
+		cr67 = inb(0x3D5);
+		outb(0x6A, 0x3D4);
+		cr6a = inb(0x3D5);
+		/* Map the 3C6/7/8/9 to the IGA2 */
+		outb(0x1A, 0x3C4);
+		outb(sr1a | 0x01, 0x3C5);
+		outb(0x1B, 0x3C4);
+		/* Second Display Engine colck always on */
+		outb(sr1b | 0x80, 0x3C5);
+		outb(0x67, 0x3D4);
+		/* Second Display Color Depth 8 */
+		outb(cr67 & 0x3F, 0x3D5);
+		outb(0x6A, 0x3D4);
+		/* Second Display Channel Reset CR6A[6]) */
+		outb(cr6a & 0xBF, 0x3D5);
+		/* Second Display Channel Enable CR6A[7] */
+		outb(cr6a | 0x80, 0x3D5);
+		/* Second Display Channel stop reset) */
+		outb(cr6a | 0xC0, 0x3D5);
+
+		/* Bit mask of palette */
+		outb(0xFF, 0x3c6);
+		outb(0x00, 0x3C8);
+		if (UNICHROME_CLE266 == viaparinfo->chip_info->gfx_chip_name &&
+			rev >= 15) {
+			shift = 8;
+			viafb_write_reg_mask(CR6A, VIACR, BIT5, BIT5);
+			viafb_write_reg_mask(SR15, VIASR, BIT7, BIT7);
+		} else {
+			shift = 10;
+			viafb_write_reg_mask(CR6A, VIACR, 0, BIT5);
+			viafb_write_reg_mask(SR15, VIASR, 0, BIT7);
+		}
+		for (i = 0; i < len; i++) {
+			outb((*(pred + i)) >> shift, 0x3C9);
+			outb((*(pgreen + i)) >> shift, 0x3C9);
+			outb((*(pblue + i)) >> shift, 0x3C9);
+		}
+
+		outb(0x1A, 0x3C4);
+		/* Map the 3C6/7/8/9 to the IGA1 */
+		outb(sr1a & 0xFE, 0x3C5);
+		/* Bit mask of palette */
+		outb(0xFF, 0x3c6);
+		outb(0x00, 0x3C8);
+		for (i = 0; i < len; i++) {
+			outb((*(pred + i)) >> shift, 0x3C9);
+			outb((*(pgreen + i)) >> shift, 0x3C9);
+			outb((*(pblue + i)) >> shift, 0x3C9);
+		}
+
+		outb(0x1A, 0x3C4);
+		outb(sr1a, 0x3C5);
+		outb(0x1B, 0x3C4);
+		outb(sr1b, 0x3C5);
+		outb(0x67, 0x3D4);
+		outb(cr67, 0x3D5);
+		outb(0x6A, 0x3D4);
+		outb(cr6a, 0x3D5);
+		break;
+	case 16:
+		if (len > 17)
+			return 0;	/* Because static u32 pseudo_pal[17]; */
+		for (i = 0; i < len; i++)
+			((u32 *) info->pseudo_palette)[i] =
+			    (*(pred + i) & 0xF800) |
+			    ((*(pgreen + i) & 0xFC00) >> 5) |
+			    ((*(pblue + i) & 0xF800) >> 11);
+		break;
+	case 32:
+		if (len > 17)
+			return 0;
+		if (ptransp) {
+			for (i = 0; i < len; i++)
+				((u32 *) info->pseudo_palette)[i] =
+				    ((*(ptransp + i) & 0xFF00) << 16) |
+				    ((*(pred + i) & 0xFF00) << 8) |
+				    ((*(pgreen + i) & 0xFF00)) |
+				    ((*(pblue + i) & 0xFF00) >> 8);
+		} else {
+			for (i = 0; i < len; i++)
+				((u32 *) info->pseudo_palette)[i] =
+				    0x00000000 |
+				    ((*(pred + i) & 0xFF00) << 8) |
+				    ((*(pgreen + i) & 0xFF00)) |
+				    ((*(pblue + i) & 0xFF00) >> 8);
+		}
+		break;
+	}
+	return 0;
+}
+
+static int viafb_pan_display(struct fb_var_screeninfo *var,
+	struct fb_info *info)
+{
+	unsigned int offset;
+
+	DEBUG_MSG(KERN_INFO "viafb_pan_display!\n");
+
+	offset = (var->xoffset + (var->yoffset * var->xres_virtual)) *
+	    var->bits_per_pixel / 16;
+
+	DEBUG_MSG(KERN_INFO "\nviafb_pan_display,offset =%d ", offset);
+
+	viafb_write_reg_mask(0x48, 0x3d4, ((offset >> 24) & 0x3), 0x3);
+	viafb_write_reg_mask(0x34, 0x3d4, ((offset >> 16) & 0xff), 0xff);
+	viafb_write_reg_mask(0x0c, 0x3d4, ((offset >> 8) & 0xff), 0xff);
+	viafb_write_reg_mask(0x0d, 0x3d4, (offset & 0xff), 0xff);
+
+	return 0;
+}
+
+static int viafb_blank(int blank_mode, struct fb_info *info)
+{
+	DEBUG_MSG(KERN_INFO "viafb_blank!\n");
+	/* clear DPMS setting */
+
+	switch (blank_mode) {
+	case FB_BLANK_UNBLANK:
+		/* Screen: On, HSync: On, VSync: On */
+		/* control CRT monitor power management */
+		viafb_write_reg_mask(CR36, VIACR, 0x00, BIT4 + BIT5);
+		break;
+	case FB_BLANK_HSYNC_SUSPEND:
+		/* Screen: Off, HSync: Off, VSync: On */
+		/* control CRT monitor power management */
+		viafb_write_reg_mask(CR36, VIACR, 0x10, BIT4 + BIT5);
+		break;
+	case FB_BLANK_VSYNC_SUSPEND:
+		/* Screen: Off, HSync: On, VSync: Off */
+		/* control CRT monitor power management */
+		viafb_write_reg_mask(CR36, VIACR, 0x20, BIT4 + BIT5);
+		break;
+	case FB_BLANK_POWERDOWN:
+		/* Screen: Off, HSync: Off, VSync: Off */
+		/* control CRT monitor power management */
+		viafb_write_reg_mask(CR36, VIACR, 0x30, BIT4 + BIT5);
+		break;
+	}
+
+	return 0;
+}
+
+static int viafb_ioctl(struct fb_info *info, u_int cmd, u_long arg)
+{
+	struct viafb_ioctl_mode viamode;
+	struct viafb_ioctl_samm viasamm;
+	struct viafb_driver_version driver_version;
+	struct fb_var_screeninfo sec_var;
+	struct _panel_size_pos_info panel_pos_size_para;
+	u32 state_info = 0;
+	u32 viainfo_size = sizeof(struct viafb_ioctl_info);
+	u32 *viafb_gamma_table;
+	char driver_name[] = "viafb";
+
+	u32 __user *argp = (u32 __user *) arg;
+	u32 gpu32;
+	u32 video_dev_info = 0;
+	struct viafb_ioctl_setting viafb_setting = {};
+	struct device_t active_dev = {};
+
+	DEBUG_MSG(KERN_INFO "viafb_ioctl: 0x%X !!\n", cmd);
+
+	switch (cmd) {
+	case VIAFB_GET_CHIP_INFO:
+		if (copy_to_user(argp, viaparinfo->chip_info,
+				sizeof(struct chip_information)))
+			return -EFAULT;
+		break;
+	case VIAFB_GET_INFO_SIZE:
+		return put_user(viainfo_size, argp);
+	case VIAFB_GET_INFO:
+		return viafb_ioctl_get_viafb_info(arg);
+	case VIAFB_HOTPLUG:
+		return put_user(viafb_ioctl_hotplug(info->var.xres,
+					      info->var.yres,
+					      info->var.bits_per_pixel), argp);
+	case VIAFB_SET_HOTPLUG_FLAG:
+		if (copy_from_user(&gpu32, argp, sizeof(gpu32)))
+			return -EFAULT;
+		viafb_hotplug = (gpu32) ? 1 : 0;
+		break;
+	case VIAFB_GET_RESOLUTION:
+		viamode.xres = (u32) viafb_hotplug_Xres;
+		viamode.yres = (u32) viafb_hotplug_Yres;
+		viamode.refresh = (u32) viafb_hotplug_refresh;
+		viamode.bpp = (u32) viafb_hotplug_bpp;
+		if (viafb_SAMM_ON == 1) {
+			viamode.xres_sec = viafb_second_xres;
+			viamode.yres_sec = viafb_second_yres;
+			viamode.virtual_xres_sec = viafb_second_virtual_xres;
+			viamode.virtual_yres_sec = viafb_second_virtual_yres;
+			viamode.refresh_sec = viafb_refresh1;
+			viamode.bpp_sec = viafb_bpp1;
+		} else {
+			viamode.xres_sec = 0;
+			viamode.yres_sec = 0;
+			viamode.virtual_xres_sec = 0;
+			viamode.virtual_yres_sec = 0;
+			viamode.refresh_sec = 0;
+			viamode.bpp_sec = 0;
+		}
+		if (copy_to_user(argp, &viamode, sizeof(viamode)))
+			return -EFAULT;
+		break;
+	case VIAFB_GET_SAMM_INFO:
+		viasamm.samm_status = viafb_SAMM_ON;
+
+		if (viafb_SAMM_ON == 1) {
+			if (viafb_dual_fb) {
+				viasamm.size_prim = viaparinfo->fbmem_free;
+				viasamm.size_sec = viaparinfo1->fbmem_free;
+			} else {
+				if (viafb_second_size) {
+					viasamm.size_prim =
+					    viaparinfo->fbmem_free -
+					    viafb_second_size * 1024 * 1024;
+					viasamm.size_sec =
+					    viafb_second_size * 1024 * 1024;
+				} else {
+					viasamm.size_prim =
+					    viaparinfo->fbmem_free >> 1;
+					viasamm.size_sec =
+					    (viaparinfo->fbmem_free >> 1);
+				}
+			}
+			viasamm.mem_base = viaparinfo->fbmem;
+			viasamm.offset_sec = viafb_second_offset;
+		} else {
+			viasamm.size_prim =
+			    viaparinfo->memsize - viaparinfo->fbmem_used;
+			viasamm.size_sec = 0;
+			viasamm.mem_base = viaparinfo->fbmem;
+			viasamm.offset_sec = 0;
+		}
+
+		if (copy_to_user(argp, &viasamm, sizeof(viasamm)))
+			return -EFAULT;
+
+		break;
+	case VIAFB_TURN_ON_OUTPUT_DEVICE:
+		if (copy_from_user(&gpu32, argp, sizeof(gpu32)))
+			return -EFAULT;
+		if (gpu32 & CRT_Device)
+			viafb_crt_enable();
+		if (gpu32 & DVI_Device)
+			viafb_dvi_enable();
+		if (gpu32 & LCD_Device)
+			viafb_lcd_enable();
+		break;
+	case VIAFB_TURN_OFF_OUTPUT_DEVICE:
+		if (copy_from_user(&gpu32, argp, sizeof(gpu32)))
+			return -EFAULT;
+		if (gpu32 & CRT_Device)
+			viafb_crt_disable();
+		if (gpu32 & DVI_Device)
+			viafb_dvi_disable();
+		if (gpu32 & LCD_Device)
+			viafb_lcd_disable();
+		break;
+	case VIAFB_SET_DEVICE:
+		if (copy_from_user(&active_dev, (void *)argp,
+			sizeof(active_dev)))
+			return -EFAULT;
+		viafb_set_device(active_dev);
+		viafb_set_par(info);
+		break;
+	case VIAFB_GET_DEVICE:
+		active_dev.crt = viafb_CRT_ON;
+		active_dev.dvi = viafb_DVI_ON;
+		active_dev.lcd = viafb_LCD_ON;
+		active_dev.samm = viafb_SAMM_ON;
+		active_dev.primary_dev = viafb_primary_dev;
+
+		active_dev.lcd_dsp_cent = viafb_lcd_dsp_method;
+		active_dev.lcd_panel_id = viafb_lcd_panel_id;
+		active_dev.lcd_mode = viafb_lcd_mode;
+
+		active_dev.xres = viafb_hotplug_Xres;
+		active_dev.yres = viafb_hotplug_Yres;
+
+		active_dev.xres1 = viafb_second_xres;
+		active_dev.yres1 = viafb_second_yres;
+
+		active_dev.bpp = viafb_bpp;
+		active_dev.bpp1 = viafb_bpp1;
+		active_dev.refresh = viafb_refresh;
+		active_dev.refresh1 = viafb_refresh1;
+
+		active_dev.epia_dvi = viafb_platform_epia_dvi;
+		active_dev.lcd_dual_edge = viafb_device_lcd_dualedge;
+		active_dev.bus_width = viafb_bus_width;
+
+		if (copy_to_user(argp, &active_dev, sizeof(active_dev)))
+			return -EFAULT;
+		break;
+
+	case VIAFB_GET_DRIVER_VERSION:
+		driver_version.iMajorNum = VERSION_MAJOR;
+		driver_version.iKernelNum = VERSION_KERNEL;
+		driver_version.iOSNum = VERSION_OS;
+		driver_version.iMinorNum = VERSION_MINOR;
+
+		if (copy_to_user(argp, &driver_version,
+			sizeof(driver_version)))
+			return -EFAULT;
+
+		break;
+
+	case VIAFB_SET_DEVICE_INFO:
+		if (copy_from_user(&viafb_setting,
+			argp, sizeof(viafb_setting)))
+			return -EFAULT;
+		if (apply_device_setting(viafb_setting, info) < 0)
+			return -EINVAL;
+
+		break;
+
+	case VIAFB_SET_SECOND_MODE:
+		if (copy_from_user(&sec_var, argp, sizeof(sec_var)))
+			return -EFAULT;
+		apply_second_mode_setting(&sec_var);
+		break;
+
+	case VIAFB_GET_DEVICE_INFO:
+
+		retrieve_device_setting(&viafb_setting);
+
+		if (copy_to_user(argp, &viafb_setting, sizeof(viafb_setting)))
+			return -EFAULT;
+
+		break;
+
+	case VIAFB_GET_DEVICE_SUPPORT:
+		viafb_get_device_support_state(&state_info);
+		if (put_user(state_info, argp))
+			return -EFAULT;
+		break;
+
+	case VIAFB_GET_DEVICE_CONNECT:
+		viafb_get_device_connect_state(&state_info);
+		if (put_user(state_info, argp))
+			return -EFAULT;
+		break;
+
+	case VIAFB_GET_PANEL_SUPPORT_EXPAND:
+		state_info =
+		    viafb_lcd_get_support_expand_state(info->var.xres,
+						 info->var.yres);
+		if (put_user(state_info, argp))
+			return -EFAULT;
+		break;
+
+	case VIAFB_GET_DRIVER_NAME:
+		if (copy_to_user(argp, driver_name, sizeof(driver_name)))
+			return -EFAULT;
+		break;
+
+	case VIAFB_SET_GAMMA_LUT:
+		viafb_gamma_table = kmalloc(256 * sizeof(u32), GFP_KERNEL);
+		if (!viafb_gamma_table)
+			return -ENOMEM;
+		if (copy_from_user(viafb_gamma_table, argp,
+				sizeof(viafb_gamma_table))) {
+			kfree(viafb_gamma_table);
+			return -EFAULT;
+		}
+		viafb_set_gamma_table(viafb_bpp, viafb_gamma_table);
+		kfree(viafb_gamma_table);
+		break;
+
+	case VIAFB_GET_GAMMA_LUT:
+		viafb_gamma_table = kmalloc(256 * sizeof(u32), GFP_KERNEL);
+		if (!viafb_gamma_table)
+			return -ENOMEM;
+		viafb_get_gamma_table(viafb_gamma_table);
+		if (copy_to_user(argp, viafb_gamma_table,
+			sizeof(viafb_gamma_table))) {
+			kfree(viafb_gamma_table);
+			return -EFAULT;
+		}
+		kfree(viafb_gamma_table);
+		break;
+
+	case VIAFB_GET_GAMMA_SUPPORT_STATE:
+		viafb_get_gamma_support_state(viafb_bpp, &state_info);
+		if (put_user(state_info, argp))
+			return -EFAULT;
+		break;
+	case VIAFB_SET_VIDEO_DEVICE:
+		get_user(video_dev_info, argp);
+		viafb_set_video_device(video_dev_info);
+		break;
+	case VIAFB_GET_VIDEO_DEVICE:
+		viafb_get_video_device(&video_dev_info);
+		if (put_user(video_dev_info, argp))
+			return -EFAULT;
+		break;
+	case VIAFB_SYNC_SURFACE:
+		DEBUG_MSG(KERN_INFO "lobo VIAFB_SYNC_SURFACE\n");
+		break;
+	case VIAFB_GET_DRIVER_CAPS:
+		break;
+
+	case VIAFB_GET_PANEL_MAX_SIZE:
+		if (copy_from_user
+		    (&panel_pos_size_para, argp, sizeof(panel_pos_size_para)))
+			return -EFAULT;
+		panel_pos_size_para.x = panel_pos_size_para.y = 0;
+		if (copy_to_user(argp, &panel_pos_size_para,
+		     sizeof(panel_pos_size_para)))
+			return -EFAULT;
+		break;
+	case VIAFB_GET_PANEL_MAX_POSITION:
+		if (copy_from_user
+		    (&panel_pos_size_para, argp, sizeof(panel_pos_size_para)))
+			return -EFAULT;
+		panel_pos_size_para.x = panel_pos_size_para.y = 0;
+		if (copy_to_user(argp, &panel_pos_size_para,
+		     sizeof(panel_pos_size_para)))
+			return -EFAULT;
+		break;
+
+	case VIAFB_GET_PANEL_POSITION:
+		if (copy_from_user
+		    (&panel_pos_size_para, argp, sizeof(panel_pos_size_para)))
+			return -EFAULT;
+		panel_pos_size_para.x = panel_pos_size_para.y = 0;
+		if (copy_to_user(argp, &panel_pos_size_para,
+		     sizeof(panel_pos_size_para)))
+			return -EFAULT;
+		break;
+	case VIAFB_GET_PANEL_SIZE:
+		if (copy_from_user
+		    (&panel_pos_size_para, argp, sizeof(panel_pos_size_para)))
+			return -EFAULT;
+		panel_pos_size_para.x = panel_pos_size_para.y = 0;
+		if (copy_to_user(argp, &panel_pos_size_para,
+		     sizeof(panel_pos_size_para)))
+			return -EFAULT;
+		break;
+
+	case VIAFB_SET_PANEL_POSITION:
+		if (copy_from_user
+		    (&panel_pos_size_para, argp, sizeof(panel_pos_size_para)))
+			return -EFAULT;
+		break;
+	case VIAFB_SET_PANEL_SIZE:
+		if (copy_from_user
+		    (&panel_pos_size_para, argp, sizeof(panel_pos_size_para)))
+			return -EFAULT;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void viafb_fillrect(struct fb_info *info,
+	const struct fb_fillrect *rect)
+{
+	u32 col = 0, rop = 0;
+	int pitch;
+
+	if (!viafb_accel)
+		return cfb_fillrect(info, rect);
+
+	if (!rect->width || !rect->height)
+		return;
+
+	switch (rect->rop) {
+	case ROP_XOR:
+		rop = 0x5A;
+		break;
+	case ROP_COPY:
+	default:
+		rop = 0xF0;
+		break;
+	}
+
+	switch (info->var.bits_per_pixel) {
+	case 8:
+		col = rect->color;
+		break;
+	case 16:
+		col = ((u32 *) (info->pseudo_palette))[rect->color];
+		break;
+	case 32:
+		col = ((u32 *) (info->pseudo_palette))[rect->color];
+		break;
+	}
+
+	/* BitBlt Source Address */
+	writel(0x0, viaparinfo->io_virt + VIA_REG_SRCPOS);
+	/* Source Base Address */
+	writel(0x0, viaparinfo->io_virt + VIA_REG_SRCBASE);
+	/* Destination Base Address */
+	writel(((unsigned long) (info->screen_base) -
+		   (unsigned long) viafb_FB_MM) >> 3,
+		   viaparinfo->io_virt + VIA_REG_DSTBASE);
+	/* Pitch */
+	pitch = (info->var.xres_virtual + 7) & ~7;
+	writel(VIA_PITCH_ENABLE |
+		   (((pitch *
+		      info->var.bits_per_pixel >> 3) >> 3) |
+		      (((pitch * info->
+		      var.bits_per_pixel >> 3) >> 3) << 16)),
+		      viaparinfo->io_virt + VIA_REG_PITCH);
+	/* BitBlt Destination Address */
+	writel(((rect->dy << 16) | rect->dx),
+		viaparinfo->io_virt + VIA_REG_DSTPOS);
+	/* Dimension: width & height */
+	writel((((rect->height - 1) << 16) | (rect->width - 1)),
+		viaparinfo->io_virt + VIA_REG_DIMENSION);
+	/* Forground color or Destination color */
+	writel(col, viaparinfo->io_virt + VIA_REG_FGCOLOR);
+	/* GE Command */
+	writel((0x01 | 0x2000 | (rop << 24)),
+		viaparinfo->io_virt + VIA_REG_GECMD);
+
+}
+
+static void viafb_copyarea(struct fb_info *info,
+	const struct fb_copyarea *area)
+{
+	u32 dy = area->dy, sy = area->sy, direction = 0x0;
+	u32 sx = area->sx, dx = area->dx, width = area->width;
+	int pitch;
+
+	DEBUG_MSG(KERN_INFO "viafb_copyarea!!\n");
+
+	if (!viafb_accel)
+		return cfb_copyarea(info, area);
+
+	if (!area->width || !area->height)
+		return;
+
+	if (sy < dy) {
+		dy += area->height - 1;
+		sy += area->height - 1;
+		direction |= 0x4000;
+	}
+
+	if (sx < dx) {
+		dx += width - 1;
+		sx += width - 1;
+		direction |= 0x8000;
+	}
+
+	/* Source Base Address */
+	writel(((unsigned long) (info->screen_base) -
+		   (unsigned long) viafb_FB_MM) >> 3,
+		   viaparinfo->io_virt + VIA_REG_SRCBASE);
+	/* Destination Base Address */
+	writel(((unsigned long) (info->screen_base) -
+		   (unsigned long) viafb_FB_MM) >> 3,
+		   viaparinfo->io_virt + VIA_REG_DSTBASE);
+	/* Pitch */
+	pitch = (info->var.xres_virtual + 7) & ~7;
+	/* VIA_PITCH_ENABLE can be omitted now. */
+	writel(VIA_PITCH_ENABLE |
+		   (((pitch *
+		      info->var.bits_per_pixel >> 3) >> 3) | (((pitch *
+								info->var.
+								bits_per_pixel
+								>> 3) >> 3)
+							      << 16)),
+				viaparinfo->io_virt + VIA_REG_PITCH);
+	/* BitBlt Source Address */
+	writel(((sy << 16) | sx), viaparinfo->io_virt + VIA_REG_SRCPOS);
+	/* BitBlt Destination Address */
+	writel(((dy << 16) | dx), viaparinfo->io_virt + VIA_REG_DSTPOS);
+	/* Dimension: width & height */
+	writel((((area->height - 1) << 16) | (area->width - 1)),
+		   viaparinfo->io_virt + VIA_REG_DIMENSION);
+	/* GE Command */
+	writel((0x01 | direction | (0xCC << 24)),
+		viaparinfo->io_virt + VIA_REG_GECMD);
+
+}
+
+static void viafb_imageblit(struct fb_info *info,
+	const struct fb_image *image)
+{
+	u32 size, bg_col = 0, fg_col = 0, *udata;
+	int i;
+	int pitch;
+
+	if (!viafb_accel)
+		return cfb_imageblit(info, image);
+
+	udata = (u32 *) image->data;
+
+	switch (info->var.bits_per_pixel) {
+	case 8:
+		bg_col = image->bg_color;
+		fg_col = image->fg_color;
+		break;
+	case 16:
+		bg_col = ((u32 *) (info->pseudo_palette))[image->bg_color];
+		fg_col = ((u32 *) (info->pseudo_palette))[image->fg_color];
+		break;
+	case 32:
+		bg_col = ((u32 *) (info->pseudo_palette))[image->bg_color];
+		fg_col = ((u32 *) (info->pseudo_palette))[image->fg_color];
+		break;
+	}
+	size = image->width * image->height;
+
+	/* Source Base Address */
+	writel(0x0, viaparinfo->io_virt + VIA_REG_SRCBASE);
+	/* Destination Base Address */
+	writel(((unsigned long) (info->screen_base) -
+		   (unsigned long) viafb_FB_MM) >> 3,
+		   viaparinfo->io_virt + VIA_REG_DSTBASE);
+	/* Pitch */
+	pitch = (info->var.xres_virtual + 7) & ~7;
+	writel(VIA_PITCH_ENABLE |
+		   (((pitch *
+		      info->var.bits_per_pixel >> 3) >> 3) | (((pitch *
+								info->var.
+								bits_per_pixel
+								>> 3) >> 3)
+							      << 16)),
+				viaparinfo->io_virt + VIA_REG_PITCH);
+	/* BitBlt Source Address */
+	writel(0x0, viaparinfo->io_virt + VIA_REG_SRCPOS);
+	/* BitBlt Destination Address */
+	writel(((image->dy << 16) | image->dx),
+		viaparinfo->io_virt + VIA_REG_DSTPOS);
+	/* Dimension: width & height */
+	writel((((image->height - 1) << 16) | (image->width - 1)),
+		   viaparinfo->io_virt + VIA_REG_DIMENSION);
+	/* fb color */
+	writel(fg_col, viaparinfo->io_virt + VIA_REG_FGCOLOR);
+	/* bg color */
+	writel(bg_col, viaparinfo->io_virt + VIA_REG_BGCOLOR);
+	/* GE Command */
+	writel(0xCC020142, viaparinfo->io_virt + VIA_REG_GECMD);
+
+	for (i = 0; i < size / 4; i++) {
+		writel(*udata, viaparinfo->io_virt + VIA_MMIO_BLTBASE);
+		udata++;
+	}
+
+}
+
+static int viafb_cursor(struct fb_info *info, struct fb_cursor *cursor)
+{
+	u8 data[CURSOR_SIZE / 8];
+	u32 data_bak[CURSOR_SIZE / 32];
+	u32 temp, xx, yy, bg_col = 0, fg_col = 0;
+	int size, i, j = 0;
+	static int hw_cursor;
+	struct viafb_par *p_viafb_par;
+
+	if (viafb_accel)
+		hw_cursor = 1;
+
+	if (!viafb_accel) {
+		if (hw_cursor) {
+			viafb_show_hw_cursor(info, HW_Cursor_OFF);
+			hw_cursor = 0;
+		}
+		return -ENODEV;
+	}
+
+	if ((((struct viafb_par *)(info->par))->iga_path == IGA2)
+	    && (viaparinfo->chip_info->gfx_chip_name == UNICHROME_CLE266))
+		return -ENODEV;
+
+	/* When duoview and using lcd , use soft cursor */
+	if (viafb_LCD_ON || ((struct viafb_par *)(info->par))->duoview)
+		return -ENODEV;
+
+	viafb_show_hw_cursor(info, HW_Cursor_OFF);
+	viacursor = *cursor;
+
+	if (cursor->set & FB_CUR_SETHOT) {
+		viacursor.hot = cursor->hot;
+		temp = ((viacursor.hot.x) << 16) + viacursor.hot.y;
+		writel(temp, viaparinfo->io_virt + VIA_REG_CURSOR_ORG);
+	}
+
+	if (cursor->set & FB_CUR_SETPOS) {
+		viacursor.image.dx = cursor->image.dx;
+		viacursor.image.dy = cursor->image.dy;
+		yy = cursor->image.dy - info->var.yoffset;
+		xx = cursor->image.dx - info->var.xoffset;
+		temp = yy & 0xFFFF;
+		temp |= (xx << 16);
+		writel(temp, viaparinfo->io_virt + VIA_REG_CURSOR_POS);
+	}
+
+	if (cursor->set & FB_CUR_SETSIZE) {
+		temp = readl(viaparinfo->io_virt + VIA_REG_CURSOR_MODE);
+
+		if ((cursor->image.width <= 32)
+		    && (cursor->image.height <= 32)) {
+			MAX_CURS = 32;
+			temp |= 0x2;
+		} else if ((cursor->image.width <= 64)
+			   && (cursor->image.height <= 64)) {
+			MAX_CURS = 64;
+			temp &= 0xFFFFFFFD;
+		} else {
+			DEBUG_MSG(KERN_INFO
+			"The cursor image is biger than 64x64 bits...\n");
+			return -ENXIO;
+		}
+		writel(temp, viaparinfo->io_virt + VIA_REG_CURSOR_MODE);
+
+		viacursor.image.height = cursor->image.height;
+		viacursor.image.width = cursor->image.width;
+	}
+
+	if (cursor->set & FB_CUR_SETCMAP) {
+		viacursor.image.fg_color = cursor->image.fg_color;
+		viacursor.image.bg_color = cursor->image.bg_color;
+
+		switch (info->var.bits_per_pixel) {
+		case 8:
+		case 16:
+		case 32:
+			bg_col =
+			    (0xFF << 24) |
+			    (((info->cmap.red)[viacursor.image.bg_color] &
+			    0xFF00) << 8) |
+			    ((info->cmap.green)[viacursor.image.bg_color] &
+			    0xFF00) |
+			    (((info->cmap.blue)[viacursor.image.bg_color] &
+			    0xFF00) >> 8);
+			fg_col =
+			    (0xFF << 24) |
+			    (((info->cmap.red)[viacursor.image.fg_color] &
+			    0xFF00) << 8) |
+			    ((info->cmap.green)[viacursor.image.fg_color] &
+			    0xFF00) |
+			    (((info->cmap.blue)[viacursor.image.fg_color] &
+			    0xFF00) >> 8);
+			break;
+		default:
+			return 0;
+		}
+
+		/* This is indeed a patch for VT3324/VT3353 */
+		if (!info->par)
+			return 0;
+		p_viafb_par = (struct viafb_par *)info->par;
+
+		if ((p_viafb_par->chip_info->gfx_chip_name ==
+			UNICHROME_CX700) ||
+			((p_viafb_par->chip_info->gfx_chip_name ==
+			UNICHROME_VX800))) {
+			bg_col =
+			    (((info->cmap.red)[viacursor.image.bg_color] &
+			    0xFFC0) << 14) |
+			    (((info->cmap.green)[viacursor.image.bg_color] &
+			    0xFFC0) << 4) |
+			    (((info->cmap.blue)[viacursor.image.bg_color] &
+			    0xFFC0) >> 6);
+			fg_col =
+			    (((info->cmap.red)[viacursor.image.fg_color] &
+			    0xFFC0) << 14) |
+			    (((info->cmap.green)[viacursor.image.fg_color] &
+			    0xFFC0) << 4) |
+			    (((info->cmap.blue)[viacursor.image.fg_color] &
+			    0xFFC0) >> 6);
+		}
+
+		writel(bg_col, viaparinfo->io_virt + VIA_REG_CURSOR_BG);
+		writel(fg_col, viaparinfo->io_virt + VIA_REG_CURSOR_FG);
+	}
+
+	if (cursor->set & FB_CUR_SETSHAPE) {
+		size =
+		    ((viacursor.image.width + 7) >> 3) *
+		    viacursor.image.height;
+
+		if (MAX_CURS == 32) {
+			for (i = 0; i < (CURSOR_SIZE / 32); i++) {
+				data_bak[i] = 0x0;
+				data_bak[i + 1] = 0xFFFFFFFF;
+				i += 1;
+			}
+		} else if (MAX_CURS == 64) {
+			for (i = 0; i < (CURSOR_SIZE / 32); i++) {
+				data_bak[i] = 0x0;
+				data_bak[i + 1] = 0x0;
+				data_bak[i + 2] = 0xFFFFFFFF;
+				data_bak[i + 3] = 0xFFFFFFFF;
+				i += 3;
+			}
+		}
+
+		switch (viacursor.rop) {
+		case ROP_XOR:
+			for (i = 0; i < size; i++)
+				data[i] = viacursor.mask[i];
+			break;
+		case ROP_COPY:
+
+			for (i = 0; i < size; i++)
+				data[i] = viacursor.mask[i];
+			break;
+		default:
+			break;
+		}
+
+		if (MAX_CURS == 32) {
+			for (i = 0; i < size; i++) {
+				data_bak[j] = (u32) data[i];
+				data_bak[j + 1] = ~data_bak[j];
+				j += 2;
+			}
+		} else if (MAX_CURS == 64) {
+			for (i = 0; i < size; i++) {
+				data_bak[j] = (u32) data[i];
+				data_bak[j + 1] = 0x0;
+				data_bak[j + 2] = ~data_bak[j];
+				data_bak[j + 3] = ~data_bak[j + 1];
+				j += 4;
+			}
+		}
+
+		memcpy(((struct viafb_par *)(info->par))->fbmem_virt +
+		       ((struct viafb_par *)(info->par))->cursor_start,
+		       data_bak, CURSOR_SIZE);
+	}
+
+	if (viacursor.enable)
+		viafb_show_hw_cursor(info, HW_Cursor_ON);
+
+	return 0;
+}
+
+static int viafb_sync(struct fb_info *info)
+{
+	if (viafb_accel)
+		viafb_wait_engine_idle();
+	return 0;
+}
+
+int viafb_get_mode_index(int hres, int vres, int flag)
+{
+	u32 i;
+	DEBUG_MSG(KERN_INFO "viafb_get_mode_index!\n");
+
+	for (i = 0; viafb_modentry[i].mode_index != VIA_RES_INVALID; i++)
+		if (viafb_modentry[i].xres == hres &&
+			viafb_modentry[i].yres == vres)
+			break;
+
+	viafb_resMode = viafb_modentry[i].mode_index;
+	if (flag)
+		viafb_mode1 = viafb_modentry[i].mode_res;
+	else
+		viafb_mode = viafb_modentry[i].mode_res;
+
+	return viafb_resMode;
+}
+
+static void check_available_device_to_enable(int device_id)
+{
+	int device_num = 0;
+
+	/* Initialize: */
+	viafb_CRT_ON = STATE_OFF;
+	viafb_DVI_ON = STATE_OFF;
+	viafb_LCD_ON = STATE_OFF;
+	viafb_LCD2_ON = STATE_OFF;
+	viafb_DeviceStatus = None_Device;
+
+	if ((device_id & CRT_Device) && (device_num < MAX_ACTIVE_DEV_NUM)) {
+		viafb_CRT_ON = STATE_ON;
+		device_num++;
+		viafb_DeviceStatus |= CRT_Device;
+	}
+
+	if ((device_id & DVI_Device) && (device_num < MAX_ACTIVE_DEV_NUM)) {
+		viafb_DVI_ON = STATE_ON;
+		device_num++;
+		viafb_DeviceStatus |= DVI_Device;
+	}
+
+	if ((device_id & LCD_Device) && (device_num < MAX_ACTIVE_DEV_NUM)) {
+		viafb_LCD_ON = STATE_ON;
+		device_num++;
+		viafb_DeviceStatus |= LCD_Device;
+	}
+
+	if ((device_id & LCD2_Device) && (device_num < MAX_ACTIVE_DEV_NUM)) {
+		viafb_LCD2_ON = STATE_ON;
+		device_num++;
+		viafb_DeviceStatus |= LCD2_Device;
+	}
+
+	if (viafb_DeviceStatus == None_Device) {
+		/* Use CRT as default active device: */
+		viafb_CRT_ON = STATE_ON;
+		viafb_DeviceStatus = CRT_Device;
+	}
+	DEBUG_MSG(KERN_INFO "Device Status:%x", viafb_DeviceStatus);
+}
+
+static void viafb_set_device(struct device_t active_dev)
+{
+	/* Check available device to enable: */
+	int device_id = None_Device;
+	if (active_dev.crt)
+		device_id |= CRT_Device;
+	if (active_dev.dvi)
+		device_id |= DVI_Device;
+	if (active_dev.lcd)
+		device_id |= LCD_Device;
+
+	check_available_device_to_enable(device_id);
+
+	/* Check property of LCD: */
+	if (viafb_LCD_ON) {
+		if (active_dev.lcd_dsp_cent) {
+			viaparinfo->lvds_setting_info->display_method =
+				viafb_lcd_dsp_method = LCD_CENTERING;
+		} else {
+			viaparinfo->lvds_setting_info->display_method =
+				viafb_lcd_dsp_method = LCD_EXPANDSION;
+		}
+
+		if (active_dev.lcd_mode == LCD_SPWG) {
+			viaparinfo->lvds_setting_info->lcd_mode =
+				viafb_lcd_mode = LCD_SPWG;
+		} else {
+			viaparinfo->lvds_setting_info->lcd_mode =
+				viafb_lcd_mode = LCD_OPENLDI;
+		}
+
+		if (active_dev.lcd_panel_id <= LCD_PANEL_ID_MAXIMUM) {
+			viafb_lcd_panel_id = active_dev.lcd_panel_id;
+			viafb_init_lcd_size();
+		}
+	}
+
+	/* Check property of mode: */
+	if (!active_dev.xres1)
+		viafb_second_xres = 640;
+	else
+		viafb_second_xres = active_dev.xres1;
+	if (!active_dev.yres1)
+		viafb_second_yres = 480;
+	else
+		viafb_second_yres = active_dev.yres1;
+	if (active_dev.bpp != 0)
+		viafb_bpp = active_dev.bpp;
+	if (active_dev.bpp1 != 0)
+		viafb_bpp1 = active_dev.bpp1;
+	if (active_dev.refresh != 0)
+		viafb_refresh = active_dev.refresh;
+	if (active_dev.refresh1 != 0)
+		viafb_refresh1 = active_dev.refresh1;
+	if ((active_dev.samm == STATE_OFF) || (active_dev.samm == STATE_ON))
+		viafb_SAMM_ON = active_dev.samm;
+	viafb_primary_dev = active_dev.primary_dev;
+
+	viafb_set_start_addr();
+	viafb_set_iga_path();
+}
+
+static void viafb_set_video_device(u32 video_dev_info)
+{
+	viaparinfo->video_on_crt = STATE_OFF;
+	viaparinfo->video_on_dvi = STATE_OFF;
+	viaparinfo->video_on_lcd = STATE_OFF;
+
+	/* Check available device to enable: */
+	if ((video_dev_info & CRT_Device) == CRT_Device)
+		viaparinfo->video_on_crt = STATE_ON;
+	else if ((video_dev_info & DVI_Device) == DVI_Device)
+		viaparinfo->video_on_dvi = STATE_ON;
+	else if ((video_dev_info & LCD_Device) == LCD_Device)
+		viaparinfo->video_on_lcd = STATE_ON;
+}
+
+static void viafb_get_video_device(u32 *video_dev_info)
+{
+	*video_dev_info = None_Device;
+	if (viaparinfo->video_on_crt == STATE_ON)
+		*video_dev_info |= CRT_Device;
+	else if (viaparinfo->video_on_dvi == STATE_ON)
+		*video_dev_info |= DVI_Device;
+	else if (viaparinfo->video_on_lcd == STATE_ON)
+		*video_dev_info |= LCD_Device;
+}
+
+static int get_primary_device(void)
+{
+	int primary_device = 0;
+	/* Rule: device on iga1 path are the primary device. */
+	if (viafb_SAMM_ON) {
+		if (viafb_CRT_ON) {
+			if (viaparinfo->crt_setting_info->iga_path == IGA1) {
+				DEBUG_MSG(KERN_INFO "CRT IGA Path:%d\n",
+					viaparinfo->
+					crt_setting_info->iga_path);
+				primary_device = CRT_Device;
+			}
+		}
+		if (viafb_DVI_ON) {
+			if (viaparinfo->tmds_setting_info->iga_path == IGA1) {
+				DEBUG_MSG(KERN_INFO "DVI IGA Path:%d\n",
+					viaparinfo->
+					tmds_setting_info->iga_path);
+				primary_device = DVI_Device;
+			}
+		}
+		if (viafb_LCD_ON) {
+			if (viaparinfo->lvds_setting_info->iga_path == IGA1) {
+				DEBUG_MSG(KERN_INFO "LCD IGA Path:%d\n",
+					viaparinfo->
+					lvds_setting_info->iga_path);
+				primary_device = LCD_Device;
+			}
+		}
+		if (viafb_LCD2_ON) {
+			if (viaparinfo->lvds_setting_info2->iga_path == IGA1) {
+				DEBUG_MSG(KERN_INFO "LCD2 IGA Path:%d\n",
+					viaparinfo->
+					lvds_setting_info2->iga_path);
+				primary_device = LCD2_Device;
+			}
+		}
+	}
+	return primary_device;
+}
+
+static u8 is_duoview(void)
+{
+	if (0 == viafb_SAMM_ON) {
+		if (viafb_LCD_ON + viafb_LCD2_ON +
+			viafb_DVI_ON + viafb_CRT_ON == 2)
+			return true;
+		return false;
+	} else {
+		return false;
+	}
+}
+
+static void apply_second_mode_setting(struct fb_var_screeninfo
+	*sec_var)
+{
+	u32 htotal, vtotal, long_refresh;
+
+	htotal = sec_var->xres + sec_var->left_margin +
+		sec_var->right_margin + sec_var->hsync_len;
+	vtotal = sec_var->yres + sec_var->upper_margin +
+		sec_var->lower_margin + sec_var->vsync_len;
+	if ((sec_var->xres_virtual * (sec_var->bits_per_pixel >> 3)) & 0x1F) {
+		/*Is 32 bytes alignment? */
+		/*32 pixel alignment */
+		sec_var->xres_virtual = (sec_var->xres_virtual + 31) & ~31;
+	}
+
+	htotal = sec_var->xres + sec_var->left_margin +
+		sec_var->right_margin + sec_var->hsync_len;
+	vtotal = sec_var->yres + sec_var->upper_margin +
+		sec_var->lower_margin + sec_var->vsync_len;
+	long_refresh = 1000000000UL / sec_var->pixclock * 1000;
+	long_refresh /= (htotal * vtotal);
+
+	viafb_second_xres = sec_var->xres;
+	viafb_second_yres = sec_var->yres;
+	viafb_second_virtual_xres = sec_var->xres_virtual;
+	viafb_second_virtual_yres = sec_var->yres_virtual;
+	viafb_bpp1 = sec_var->bits_per_pixel;
+	viafb_refresh1 = viafb_get_refresh(sec_var->xres, sec_var->yres,
+		long_refresh);
+}
+
+static int apply_device_setting(struct viafb_ioctl_setting setting_info,
+	struct fb_info *info)
+{
+	int need_set_mode = 0;
+	DEBUG_MSG(KERN_INFO "apply_device_setting\n");
+
+	if (setting_info.device_flag) {
+		need_set_mode = 1;
+		check_available_device_to_enable(setting_info.device_status);
+	}
+
+	/* Unlock LCD's operation according to LCD flag
+	   and check if the setting value is valid. */
+	/* If the value is valid, apply the new setting value to the device. */
+	if (viafb_LCD_ON) {
+		if (setting_info.lcd_operation_flag & OP_LCD_CENTERING) {
+			need_set_mode = 1;
+			if (setting_info.lcd_attributes.display_center) {
+				/* Centering */
+				viaparinfo->lvds_setting_info->display_method =
+				    LCD_CENTERING;
+				viafb_lcd_dsp_method = LCD_CENTERING;
+				viaparinfo->lvds_setting_info2->display_method =
+				    viafb_lcd_dsp_method = LCD_CENTERING;
+			} else {
+				/* expandsion */
+				viaparinfo->lvds_setting_info->display_method =
+				    LCD_EXPANDSION;
+				viafb_lcd_dsp_method = LCD_EXPANDSION;
+				viaparinfo->lvds_setting_info2->display_method =
+				    LCD_EXPANDSION;
+				viafb_lcd_dsp_method = LCD_EXPANDSION;
+			}
+		}
+
+		if (setting_info.lcd_operation_flag & OP_LCD_MODE) {
+			need_set_mode = 1;
+			if (setting_info.lcd_attributes.lcd_mode ==
+				LCD_SPWG) {
+				viaparinfo->lvds_setting_info->lcd_mode =
+					viafb_lcd_mode = LCD_SPWG;
+			} else {
+				viaparinfo->lvds_setting_info->lcd_mode =
+					viafb_lcd_mode = LCD_OPENLDI;
+			}
+			viaparinfo->lvds_setting_info2->lcd_mode =
+			    viaparinfo->lvds_setting_info->lcd_mode;
+		}
+
+		if (setting_info.lcd_operation_flag & OP_LCD_PANEL_ID) {
+			need_set_mode = 1;
+			if (setting_info.lcd_attributes.panel_id <=
+			    LCD_PANEL_ID_MAXIMUM) {
+				viafb_lcd_panel_id =
+				    setting_info.lcd_attributes.panel_id;
+				viafb_init_lcd_size();
+			}
+		}
+	}
+
+	if (0 != (setting_info.samm_status & OP_SAMM)) {
+		setting_info.samm_status =
+		    setting_info.samm_status & (~OP_SAMM);
+		if (setting_info.samm_status == 0
+		    || setting_info.samm_status == 1) {
+			viafb_SAMM_ON = setting_info.samm_status;
+
+			if (viafb_SAMM_ON)
+				viafb_primary_dev = setting_info.primary_device;
+
+			viafb_set_start_addr();
+			viafb_set_iga_path();
+		}
+		need_set_mode = 1;
+	}
+
+	viaparinfo->duoview = is_duoview();
+
+	if (!need_set_mode) {
+		;
+	} else {
+		viafb_set_iga_path();
+		viafb_set_par(info);
+	}
+	return true;
+}
+
+static void retrieve_device_setting(struct viafb_ioctl_setting
+	*setting_info)
+{
+
+	/* get device status */
+	if (viafb_CRT_ON == 1)
+		setting_info->device_status = CRT_Device;
+	if (viafb_DVI_ON == 1)
+		setting_info->device_status |= DVI_Device;
+	if (viafb_LCD_ON == 1)
+		setting_info->device_status |= LCD_Device;
+	if (viafb_LCD2_ON == 1)
+		setting_info->device_status |= LCD2_Device;
+	if ((viaparinfo->video_on_crt == 1) && (viafb_CRT_ON == 1)) {
+		setting_info->video_device_status =
+			viaparinfo->crt_setting_info->iga_path;
+	} else if ((viaparinfo->video_on_dvi == 1) && (viafb_DVI_ON == 1)) {
+		setting_info->video_device_status =
+			viaparinfo->tmds_setting_info->iga_path;
+	} else if ((viaparinfo->video_on_lcd == 1) && (viafb_LCD_ON == 1)) {
+		setting_info->video_device_status =
+			viaparinfo->lvds_setting_info->iga_path;
+	} else {
+		setting_info->video_device_status = 0;
+	}
+
+	setting_info->samm_status = viafb_SAMM_ON;
+	setting_info->primary_device = get_primary_device();
+
+	setting_info->first_dev_bpp = viafb_bpp;
+	setting_info->second_dev_bpp = viafb_bpp1;
+
+	setting_info->first_dev_refresh = viafb_refresh;
+	setting_info->second_dev_refresh = viafb_refresh1;
+
+	setting_info->first_dev_hor_res = viafb_hotplug_Xres;
+	setting_info->first_dev_ver_res = viafb_hotplug_Yres;
+	setting_info->second_dev_hor_res = viafb_second_xres;
+	setting_info->second_dev_ver_res = viafb_second_yres;
+
+	/* Get lcd attributes */
+	setting_info->lcd_attributes.display_center = viafb_lcd_dsp_method;
+	setting_info->lcd_attributes.panel_id = viafb_lcd_panel_id;
+	setting_info->lcd_attributes.lcd_mode = viafb_lcd_mode;
+}
+
+static void parse_active_dev(void)
+{
+	viafb_CRT_ON = STATE_OFF;
+	viafb_DVI_ON = STATE_OFF;
+	viafb_LCD_ON = STATE_OFF;
+	viafb_LCD2_ON = STATE_OFF;
+	/* 1. Modify the active status of devices. */
+	/* 2. Keep the order of devices, so we can set corresponding
+	   IGA path to devices in SAMM case. */
+	/*    Note: The previous of active_dev is primary device,
+	   and the following is secondary device. */
+	if (!strncmp(viafb_active_dev, "CRT+DVI", 7)) {
+		/* CRT+DVI */
+		viafb_CRT_ON = STATE_ON;
+		viafb_DVI_ON = STATE_ON;
+		viafb_primary_dev = CRT_Device;
+	} else if (!strncmp(viafb_active_dev, "DVI+CRT", 7)) {
+		/* DVI+CRT */
+		viafb_CRT_ON = STATE_ON;
+		viafb_DVI_ON = STATE_ON;
+		viafb_primary_dev = DVI_Device;
+	} else if (!strncmp(viafb_active_dev, "CRT+LCD", 7)) {
+		/* CRT+LCD */
+		viafb_CRT_ON = STATE_ON;
+		viafb_LCD_ON = STATE_ON;
+		viafb_primary_dev = CRT_Device;
+	} else if (!strncmp(viafb_active_dev, "LCD+CRT", 7)) {
+		/* LCD+CRT */
+		viafb_CRT_ON = STATE_ON;
+		viafb_LCD_ON = STATE_ON;
+		viafb_primary_dev = LCD_Device;
+	} else if (!strncmp(viafb_active_dev, "DVI+LCD", 7)) {
+		/* DVI+LCD */
+		viafb_DVI_ON = STATE_ON;
+		viafb_LCD_ON = STATE_ON;
+		viafb_primary_dev = DVI_Device;
+	} else if (!strncmp(viafb_active_dev, "LCD+DVI", 7)) {
+		/* LCD+DVI */
+		viafb_DVI_ON = STATE_ON;
+		viafb_LCD_ON = STATE_ON;
+		viafb_primary_dev = LCD_Device;
+	} else if (!strncmp(viafb_active_dev, "LCD+LCD2", 8)) {
+		viafb_LCD_ON = STATE_ON;
+		viafb_LCD2_ON = STATE_ON;
+		viafb_primary_dev = LCD_Device;
+	} else if (!strncmp(viafb_active_dev, "LCD2+LCD", 8)) {
+		viafb_LCD_ON = STATE_ON;
+		viafb_LCD2_ON = STATE_ON;
+		viafb_primary_dev = LCD2_Device;
+	} else if (!strncmp(viafb_active_dev, "CRT", 3)) {
+		/* CRT only */
+		viafb_CRT_ON = STATE_ON;
+		viafb_SAMM_ON = STATE_OFF;
+	} else if (!strncmp(viafb_active_dev, "DVI", 3)) {
+		/* DVI only */
+		viafb_DVI_ON = STATE_ON;
+		viafb_SAMM_ON = STATE_OFF;
+	} else if (!strncmp(viafb_active_dev, "LCD", 3)) {
+		/* LCD only */
+		viafb_LCD_ON = STATE_ON;
+		viafb_SAMM_ON = STATE_OFF;
+	} else {
+		viafb_CRT_ON = STATE_ON;
+		viafb_SAMM_ON = STATE_OFF;
+	}
+	viaparinfo->duoview = is_duoview();
+}
+
+static void parse_video_dev(void)
+{
+	viaparinfo->video_on_crt = STATE_OFF;
+	viaparinfo->video_on_dvi = STATE_OFF;
+	viaparinfo->video_on_lcd = STATE_OFF;
+
+	if (!strncmp(viafb_video_dev, "CRT", 3)) {
+		/* Video on CRT */
+		viaparinfo->video_on_crt = STATE_ON;
+	} else if (!strncmp(viafb_video_dev, "DVI", 3)) {
+		/* Video on DVI */
+		viaparinfo->video_on_dvi = STATE_ON;
+	} else if (!strncmp(viafb_video_dev, "LCD", 3)) {
+		/* Video on LCD */
+		viaparinfo->video_on_lcd = STATE_ON;
+	}
+}
+
+static int parse_port(char *opt_str, int *output_interface)
+{
+	if (!strncmp(opt_str, "DVP0", 4))
+		*output_interface = INTERFACE_DVP0;
+	else if (!strncmp(opt_str, "DVP1", 4))
+		*output_interface = INTERFACE_DVP1;
+	else if (!strncmp(opt_str, "DFP_HIGHLOW", 11))
+		*output_interface = INTERFACE_DFP;
+	else if (!strncmp(opt_str, "DFP_HIGH", 8))
+		*output_interface = INTERFACE_DFP_HIGH;
+	else if (!strncmp(opt_str, "DFP_LOW", 7))
+		*output_interface = INTERFACE_DFP_LOW;
+	else
+		*output_interface = INTERFACE_NONE;
+	return 0;
+}
+
+static void parse_lcd_port(void)
+{
+	parse_port(viafb_lcd_port, &viaparinfo->chip_info->lvds_chip_info.
+		output_interface);
+	/*Initialize to avoid unexpected behavior */
+	viaparinfo->chip_info->lvds_chip_info2.output_interface =
+	INTERFACE_NONE;
+
+	DEBUG_MSG(KERN_INFO "parse_lcd_port: viafb_lcd_port:%s,interface:%d\n",
+		  viafb_lcd_port, viaparinfo->chip_info->lvds_chip_info.
+		  output_interface);
+}
+
+static void parse_dvi_port(void)
+{
+	parse_port(viafb_dvi_port, &viaparinfo->chip_info->tmds_chip_info.
+		output_interface);
+
+	DEBUG_MSG(KERN_INFO "parse_dvi_port: viafb_dvi_port:%s,interface:%d\n",
+		  viafb_dvi_port, viaparinfo->chip_info->tmds_chip_info.
+		  output_interface);
+}
+
+/*
+ * The proc filesystem read/write function, a simple proc implement to
+ * get/set the value of DPA  DVP0,   DVP0DataDriving,  DVP0ClockDriving, DVP1,
+ * DVP1Driving, DFPHigh, DFPLow CR96,   SR2A[5], SR1B[1], SR2A[4], SR1E[2],
+ * CR9B,    SR65,    CR97,    CR99
+ */
+static int viafb_dvp0_proc_read(char *buf, char **start, off_t offset,
+int count, int *eof, void *data)
+{
+	int len = 0;
+	u8 dvp0_data_dri = 0, dvp0_clk_dri = 0, dvp0 = 0;
+	dvp0_data_dri =
+	    (viafb_read_reg(VIASR, SR2A) & BIT5) >> 4 |
+	    (viafb_read_reg(VIASR, SR1B) & BIT1) >> 1;
+	dvp0_clk_dri =
+	    (viafb_read_reg(VIASR, SR2A) & BIT4) >> 3 |
+	    (viafb_read_reg(VIASR, SR1E) & BIT2) >> 2;
+	dvp0 = viafb_read_reg(VIACR, CR96) & 0x0f;
+	len +=
+	    sprintf(buf + len, "%x %x %x\n", dvp0, dvp0_data_dri, dvp0_clk_dri);
+	*eof = 1;		/*Inform kernel end of data */
+	return len;
+}
+static int viafb_dvp0_proc_write(struct file *file,
+	const char __user *buffer, unsigned long count, void *data)
+{
+	char buf[20], *value, *pbuf;
+	u8 reg_val = 0;
+	unsigned long length, i;
+	if (count < 1)
+		return -EINVAL;
+	length = count > 20 ? 20 : count;
+	if (copy_from_user(&buf[0], buffer, length))
+		return -EFAULT;
+	buf[length - 1] = '\0';	/*Ensure end string */
+	pbuf = &buf[0];
+	for (i = 0; i < 3; i++) {
+		value = strsep(&pbuf, " ");
+		if (value != NULL) {
+			strict_strtoul(value, 0, (unsigned long *)&reg_val);
+			DEBUG_MSG(KERN_INFO "DVP0:reg_val[%l]=:%x\n", i,
+				  reg_val);
+			switch (i) {
+			case 0:
+				viafb_write_reg_mask(CR96, VIACR,
+					reg_val, 0x0f);
+				break;
+			case 1:
+				viafb_write_reg_mask(SR2A, VIASR,
+					reg_val << 4, BIT5);
+				viafb_write_reg_mask(SR1B, VIASR,
+					reg_val << 1, BIT1);
+				break;
+			case 2:
+				viafb_write_reg_mask(SR2A, VIASR,
+					reg_val << 3, BIT4);
+				viafb_write_reg_mask(SR1E, VIASR,
+					reg_val << 2, BIT2);
+				break;
+			default:
+				break;
+			}
+		} else {
+			break;
+		}
+	}
+	return count;
+}
+static int viafb_dvp1_proc_read(char *buf, char **start, off_t offset,
+	int count, int *eof, void *data)
+{
+	int len = 0;
+	u8 dvp1 = 0, dvp1_data_dri = 0, dvp1_clk_dri = 0;
+	dvp1 = viafb_read_reg(VIACR, CR9B) & 0x0f;
+	dvp1_data_dri = (viafb_read_reg(VIASR, SR65) & 0x0c) >> 2;
+	dvp1_clk_dri = viafb_read_reg(VIASR, SR65) & 0x03;
+	len +=
+	    sprintf(buf + len, "%x %x %x\n", dvp1, dvp1_data_dri, dvp1_clk_dri);
+	*eof = 1;		/*Inform kernel end of data */
+	return len;
+}
+static int viafb_dvp1_proc_write(struct file *file,
+	const char __user *buffer, unsigned long count, void *data)
+{
+	char buf[20], *value, *pbuf;
+	u8 reg_val = 0;
+	unsigned long length, i;
+	if (count < 1)
+		return -EINVAL;
+	length = count > 20 ? 20 : count;
+	if (copy_from_user(&buf[0], buffer, length))
+		return -EFAULT;
+	buf[length - 1] = '\0';	/*Ensure end string */
+	pbuf = &buf[0];
+	for (i = 0; i < 3; i++) {
+		value = strsep(&pbuf, " ");
+		if (value != NULL) {
+			strict_strtoul(value, 0, (unsigned long *)&reg_val);
+			switch (i) {
+			case 0:
+				viafb_write_reg_mask(CR9B, VIACR,
+					reg_val, 0x0f);
+				break;
+			case 1:
+				viafb_write_reg_mask(SR65, VIASR,
+					reg_val << 2, 0x0c);
+				break;
+			case 2:
+				viafb_write_reg_mask(SR65, VIASR,
+					reg_val, 0x03);
+				break;
+			default:
+				break;
+			}
+		} else {
+			break;
+		}
+	}
+	return count;
+}
+
+static int viafb_dfph_proc_read(char *buf, char **start, off_t offset,
+	int count, int *eof, void *data)
+{
+	int len = 0;
+	u8 dfp_high = 0;
+	dfp_high = viafb_read_reg(VIACR, CR97) & 0x0f;
+	len += sprintf(buf + len, "%x\n", dfp_high);
+	*eof = 1;		/*Inform kernel end of data */
+	return len;
+}
+static int viafb_dfph_proc_write(struct file *file,
+	const char __user *buffer, unsigned long count, void *data)
+{
+	char buf[20];
+	u8 reg_val = 0;
+	unsigned long length;
+	if (count < 1)
+		return -EINVAL;
+	length = count > 20 ? 20 : count;
+	if (copy_from_user(&buf[0], buffer, length))
+		return -EFAULT;
+	buf[length - 1] = '\0';	/*Ensure end string */
+	strict_strtoul(&buf[0], 0, (unsigned long *)&reg_val);
+	viafb_write_reg_mask(CR97, VIACR, reg_val, 0x0f);
+	return count;
+}
+static int viafb_dfpl_proc_read(char *buf, char **start, off_t offset,
+	int count, int *eof, void *data)
+{
+	int len = 0;
+	u8 dfp_low = 0;
+	dfp_low = viafb_read_reg(VIACR, CR99) & 0x0f;
+	len += sprintf(buf + len, "%x\n", dfp_low);
+	*eof = 1;		/*Inform kernel end of data */
+	return len;
+}
+static int viafb_dfpl_proc_write(struct file *file,
+	const char __user *buffer, unsigned long count, void *data)
+{
+	char buf[20];
+	u8 reg_val = 0;
+	unsigned long length;
+	if (count < 1)
+		return -EINVAL;
+	length = count > 20 ? 20 : count;
+	if (copy_from_user(&buf[0], buffer, length))
+		return -EFAULT;
+	buf[length - 1] = '\0';	/*Ensure end string */
+	strict_strtoul(&buf[0], 0, (unsigned long *)&reg_val);
+	viafb_write_reg_mask(CR99, VIACR, reg_val, 0x0f);
+	return count;
+}
+static int viafb_vt1636_proc_read(char *buf, char **start,
+	off_t offset, int count, int *eof, void *data)
+{
+	int len = 0;
+	u8 vt1636_08 = 0, vt1636_09 = 0;
+	switch (viaparinfo->chip_info->lvds_chip_info.lvds_chip_name) {
+	case VT1636_LVDS:
+		vt1636_08 =
+		    viafb_gpio_i2c_read_lvds(viaparinfo->lvds_setting_info,
+		    &viaparinfo->chip_info->lvds_chip_info, 0x08) & 0x0f;
+		vt1636_09 =
+		    viafb_gpio_i2c_read_lvds(viaparinfo->lvds_setting_info,
+		    &viaparinfo->chip_info->lvds_chip_info, 0x09) & 0x1f;
+		len += sprintf(buf + len, "%x %x\n", vt1636_08, vt1636_09);
+		break;
+	default:
+		break;
+	}
+	switch (viaparinfo->chip_info->lvds_chip_info2.lvds_chip_name) {
+	case VT1636_LVDS:
+		vt1636_08 =
+		    viafb_gpio_i2c_read_lvds(viaparinfo->lvds_setting_info2,
+			&viaparinfo->chip_info->lvds_chip_info2, 0x08) & 0x0f;
+		vt1636_09 =
+		    viafb_gpio_i2c_read_lvds(viaparinfo->lvds_setting_info2,
+			&viaparinfo->chip_info->lvds_chip_info2, 0x09) & 0x1f;
+		len += sprintf(buf + len, " %x %x\n", vt1636_08, vt1636_09);
+		break;
+	default:
+		break;
+	}
+	*eof = 1;		/*Inform kernel end of data */
+	return len;
+}
+static int viafb_vt1636_proc_write(struct file *file,
+	const char __user *buffer, unsigned long count, void *data)
+{
+	char buf[30], *value, *pbuf;
+	struct IODATA reg_val;
+	unsigned long length, i;
+	if (count < 1)
+		return -EINVAL;
+	length = count > 30 ? 30 : count;
+	if (copy_from_user(&buf[0], buffer, length))
+		return -EFAULT;
+	buf[length - 1] = '\0';	/*Ensure end string */
+	pbuf = &buf[0];
+	switch (viaparinfo->chip_info->lvds_chip_info.lvds_chip_name) {
+	case VT1636_LVDS:
+		for (i = 0; i < 2; i++) {
+			value = strsep(&pbuf, " ");
+			if (value != NULL) {
+				strict_strtoul(value, 0,
+					(unsigned long *)&reg_val.Data);
+				switch (i) {
+				case 0:
+					reg_val.Index = 0x08;
+					reg_val.Mask = 0x0f;
+					viafb_gpio_i2c_write_mask_lvds
+					    (viaparinfo->lvds_setting_info,
+					    &viaparinfo->
+					    chip_info->lvds_chip_info,
+					     reg_val);
+					break;
+				case 1:
+					reg_val.Index = 0x09;
+					reg_val.Mask = 0x1f;
+					viafb_gpio_i2c_write_mask_lvds
+					    (viaparinfo->lvds_setting_info,
+					    &viaparinfo->
+					    chip_info->lvds_chip_info,
+					     reg_val);
+					break;
+				default:
+					break;
+				}
+			} else {
+				break;
+			}
+		}
+		break;
+	default:
+		break;
+	}
+	switch (viaparinfo->chip_info->lvds_chip_info2.lvds_chip_name) {
+	case VT1636_LVDS:
+		for (i = 0; i < 2; i++) {
+			value = strsep(&pbuf, " ");
+			if (value != NULL) {
+				strict_strtoul(value, 0,
+					(unsigned long *)&reg_val.Data);
+				switch (i) {
+				case 0:
+					reg_val.Index = 0x08;
+					reg_val.Mask = 0x0f;
+					viafb_gpio_i2c_write_mask_lvds
+					    (viaparinfo->lvds_setting_info2,
+					    &viaparinfo->
+					    chip_info->lvds_chip_info2,
+					     reg_val);
+					break;
+				case 1:
+					reg_val.Index = 0x09;
+					reg_val.Mask = 0x1f;
+					viafb_gpio_i2c_write_mask_lvds
+					    (viaparinfo->lvds_setting_info2,
+					    &viaparinfo->
+					    chip_info->lvds_chip_info2,
+					     reg_val);
+					break;
+				default:
+					break;
+				}
+			} else {
+				break;
+			}
+		}
+		break;
+	default:
+		break;
+	}
+	return count;
+}
+
+static void viafb_init_proc(struct proc_dir_entry *viafb_entry)
+{
+	struct proc_dir_entry *entry;
+	viafb_entry = proc_mkdir("viafb", NULL);
+	if (viafb_entry) {
+		entry = create_proc_entry("dvp0", 0, viafb_entry);
+		if (entry) {
+			entry->owner = THIS_MODULE;
+			entry->read_proc = viafb_dvp0_proc_read;
+			entry->write_proc = viafb_dvp0_proc_write;
+		}
+		entry = create_proc_entry("dvp1", 0, viafb_entry);
+		if (entry) {
+			entry->owner = THIS_MODULE;
+			entry->read_proc = viafb_dvp1_proc_read;
+			entry->write_proc = viafb_dvp1_proc_write;
+		}
+		entry = create_proc_entry("dfph", 0, viafb_entry);
+		if (entry) {
+			entry->owner = THIS_MODULE;
+			entry->read_proc = viafb_dfph_proc_read;
+			entry->write_proc = viafb_dfph_proc_write;
+		}
+		entry = create_proc_entry("dfpl", 0, viafb_entry);
+		if (entry) {
+			entry->owner = THIS_MODULE;
+			entry->read_proc = viafb_dfpl_proc_read;
+			entry->write_proc = viafb_dfpl_proc_write;
+		}
+		if (VT1636_LVDS == viaparinfo->chip_info->lvds_chip_info.
+			lvds_chip_name || VT1636_LVDS ==
+		    viaparinfo->chip_info->lvds_chip_info2.lvds_chip_name) {
+			entry = create_proc_entry("vt1636", 0, viafb_entry);
+			if (entry) {
+				entry->owner = THIS_MODULE;
+				entry->read_proc = viafb_vt1636_proc_read;
+				entry->write_proc = viafb_vt1636_proc_write;
+			}
+		}
+
+	}
+}
+static void viafb_remove_proc(struct proc_dir_entry *viafb_entry)
+{
+	/* no problem if it was not registered */
+	remove_proc_entry("dvp0", viafb_entry);/* parent dir */
+	remove_proc_entry("dvp1", viafb_entry);
+	remove_proc_entry("dfph", viafb_entry);
+	remove_proc_entry("dfpl", viafb_entry);
+	remove_proc_entry("vt1636", viafb_entry);
+	remove_proc_entry("vt1625", viafb_entry);
+}
+
+static int __devinit via_pci_probe(void)
+{
+	unsigned int default_xres, default_yres;
+	char *tmpc, *tmpm;
+	char *tmpc_sec, *tmpm_sec;
+	int vmode_index;
+	u32 tmds_length, lvds_length, crt_length, chip_length, viafb_par_length;
+
+	DEBUG_MSG(KERN_INFO "VIAFB PCI Probe!!\n");
+
+	viafb_par_length = ALIGN(sizeof(struct viafb_par), BITS_PER_LONG/8);
+	tmds_length = ALIGN(sizeof(struct tmds_setting_information),
+		BITS_PER_LONG/8);
+	lvds_length = ALIGN(sizeof(struct lvds_setting_information),
+		BITS_PER_LONG/8);
+	crt_length = ALIGN(sizeof(struct lvds_setting_information),
+		BITS_PER_LONG/8);
+	chip_length = ALIGN(sizeof(struct chip_information), BITS_PER_LONG/8);
+
+	/* Allocate fb_info and ***_par here, also including some other needed
+	 * variables
+	*/
+	viafbinfo = framebuffer_alloc(viafb_par_length + 2 * lvds_length +
+	tmds_length + crt_length + chip_length, NULL);
+	if (!viafbinfo) {
+		printk(KERN_ERR"Could not allocate memory for viafb_info.\n");
+		return -ENODEV;
+	}
+
+	viaparinfo = (struct viafb_par *)viafbinfo->par;
+	viaparinfo->tmds_setting_info = (struct tmds_setting_information *)
+		((unsigned long)viaparinfo + viafb_par_length);
+	viaparinfo->lvds_setting_info = (struct lvds_setting_information *)
+		((unsigned long)viaparinfo->tmds_setting_info + tmds_length);
+	viaparinfo->lvds_setting_info2 = (struct lvds_setting_information *)
+		((unsigned long)viaparinfo->lvds_setting_info + lvds_length);
+	viaparinfo->crt_setting_info = (struct crt_setting_information *)
+		((unsigned long)viaparinfo->lvds_setting_info2 + lvds_length);
+	viaparinfo->chip_info = (struct chip_information *)
+		((unsigned long)viaparinfo->crt_setting_info + crt_length);
+
+	if (viafb_dual_fb)
+		viafb_SAMM_ON = 1;
+	parse_active_dev();
+	parse_video_dev();
+	parse_lcd_port();
+	parse_dvi_port();
+
+	/* for dual-fb must viafb_SAMM_ON=1 and viafb_dual_fb=1 */
+	if (!viafb_SAMM_ON)
+		viafb_dual_fb = 0;
+
+	/* Set up I2C bus stuff */
+	viafb_create_i2c_bus(viaparinfo);
+
+	viafb_init_chip_info();
+	viafb_get_fb_info(&viaparinfo->fbmem, &viaparinfo->memsize);
+	viaparinfo->fbmem_free = viaparinfo->memsize;
+	viaparinfo->fbmem_used = 0;
+	viaparinfo->fbmem_virt = ioremap_nocache(viaparinfo->fbmem,
+		viaparinfo->memsize);
+	viafbinfo->screen_base = (char *)viaparinfo->fbmem_virt;
+
+	if (!viaparinfo->fbmem_virt) {
+		printk(KERN_INFO "ioremap failed\n");
+		return -1;
+	}
+
+	viafb_get_mmio_info(&viaparinfo->mmio_base, &viaparinfo->mmio_len);
+	viaparinfo->io_virt = ioremap_nocache(viaparinfo->mmio_base,
+		viaparinfo->mmio_len);
+
+	viafbinfo->node = 0;
+	viafbinfo->fbops = &viafb_ops;
+	viafbinfo->flags = FBINFO_DEFAULT | FBINFO_HWACCEL_YPAN;
+
+	viafbinfo->pseudo_palette = pseudo_pal;
+	if (viafb_accel) {
+		viafb_init_accel();
+		viafb_init_2d_engine();
+		viafb_hw_cursor_init();
+	}
+
+	if (viafb_second_size && (viafb_second_size < 8)) {
+		viafb_second_offset = viaparinfo->fbmem_free -
+			viafb_second_size * 1024 * 1024;
+	} else {
+		viafb_second_size = 8;
+		viafb_second_offset = viaparinfo->fbmem_free -
+			viafb_second_size * 1024 * 1024;
+	}
+
+	viafb_FB_MM = viaparinfo->fbmem_virt;
+	tmpm = viafb_mode;
+	tmpc = strsep(&tmpm, "x");
+	strict_strtoul(tmpc, 0, (unsigned long *)&default_xres);
+	strict_strtoul(tmpm, 0, (unsigned long *)&default_yres);
+
+	vmode_index = viafb_get_mode_index(default_xres, default_yres, 0);
+	DEBUG_MSG(KERN_INFO "0->index=%d\n", vmode_index);
+
+	if (viafb_SAMM_ON == 1) {
+		if (strcmp(viafb_mode, viafb_mode1)) {
+			tmpm_sec = viafb_mode1;
+			tmpc_sec = strsep(&tmpm_sec, "x");
+			strict_strtoul(tmpc_sec, 0,
+				(unsigned long *)&viafb_second_xres);
+			strict_strtoul(tmpm_sec, 0,
+				(unsigned long *)&viafb_second_yres);
+		} else {
+			viafb_second_xres = default_xres;
+			viafb_second_yres = default_yres;
+		}
+		if (0 == viafb_second_virtual_xres) {
+			switch (viafb_second_xres) {
+			case 1400:
+				viafb_second_virtual_xres = 1408;
+				break;
+			default:
+				viafb_second_virtual_xres = viafb_second_xres;
+				break;
+			}
+		}
+		if (0 == viafb_second_virtual_yres)
+			viafb_second_virtual_yres = viafb_second_yres;
+	}
+
+	switch (viafb_bpp) {
+	case 0 ... 8:
+		viafb_bpp = 8;
+		break;
+	case 9 ... 16:
+		viafb_bpp = 16;
+		break;
+	case 17 ... 32:
+		viafb_bpp = 32;
+		break;
+	default:
+		viafb_bpp = 8;
+	}
+	default_var.xres = default_xres;
+	default_var.yres = default_yres;
+	switch (default_xres) {
+	case 1400:
+		default_var.xres_virtual = 1408;
+		break;
+	default:
+		default_var.xres_virtual = default_xres;
+		break;
+	}
+	default_var.yres_virtual = default_yres;
+	default_var.bits_per_pixel = viafb_bpp;
+	if (default_var.bits_per_pixel == 15)
+		default_var.bits_per_pixel = 16;
+	default_var.pixclock =
+	    viafb_get_pixclock(default_xres, default_yres, viafb_refresh);
+	default_var.left_margin = (default_xres >> 3) & 0xf8;
+	default_var.right_margin = 32;
+	default_var.upper_margin = 16;
+	default_var.lower_margin = 4;
+	default_var.hsync_len = default_var.left_margin;
+	default_var.vsync_len = 4;
+	default_var.accel_flags = 0;
+
+	if (viafb_accel) {
+		viafbinfo->flags |=
+		    (FBINFO_HWACCEL_COPYAREA | FBINFO_HWACCEL_FILLRECT |
+		     FBINFO_HWACCEL_IMAGEBLIT);
+		default_var.accel_flags |= FB_ACCELF_TEXT;
+	} else
+		viafbinfo->flags |= FBINFO_HWACCEL_DISABLED;
+
+	if (viafb_dual_fb) {
+		viafbinfo1 = framebuffer_alloc(viafb_par_length, NULL);
+		if (!viafbinfo1) {
+			printk(KERN_ERR
+			"allocate the second framebuffer struct error\n");
+			framebuffer_release(viafbinfo);
+			return -ENOMEM;
+		}
+		viaparinfo1 = viafbinfo1->par;
+		memcpy(viaparinfo1, viaparinfo, viafb_par_length);
+		viaparinfo1->memsize = viaparinfo->memsize -
+			viafb_second_offset;
+		viaparinfo->memsize = viafb_second_offset;
+		viaparinfo1->fbmem_virt = viaparinfo->fbmem_virt +
+			viafb_second_offset;
+		viaparinfo1->fbmem = viaparinfo->fbmem + viafb_second_offset;
+
+		viaparinfo1->fbmem_used = viaparinfo->fbmem_used;
+		viaparinfo1->fbmem_free = viaparinfo1->memsize -
+			viaparinfo1->fbmem_used;
+		viaparinfo->fbmem_free = viaparinfo->memsize;
+		viaparinfo->fbmem_used = 0;
+		if (viafb_accel) {
+			viaparinfo1->cursor_start =
+			    viaparinfo->cursor_start - viafb_second_offset;
+			viaparinfo1->VQ_start = viaparinfo->VQ_start -
+				viafb_second_offset;
+			viaparinfo1->VQ_end = viaparinfo->VQ_end -
+				viafb_second_offset;
+		}
+
+		memcpy(viafbinfo1, viafbinfo, sizeof(struct fb_info));
+		viafbinfo1->screen_base = viafbinfo->screen_base +
+			viafb_second_offset;
+		viafbinfo1->fix.smem_start = viaparinfo1->fbmem;
+		viafbinfo1->fix.smem_len = viaparinfo1->fbmem_free;
+
+		default_var.xres = viafb_second_xres;
+		default_var.yres = viafb_second_yres;
+		default_var.xres_virtual = viafb_second_virtual_xres;
+		default_var.yres_virtual = viafb_second_virtual_yres;
+		if (viafb_bpp1 != viafb_bpp)
+			viafb_bpp1 = viafb_bpp;
+		default_var.bits_per_pixel = viafb_bpp1;
+		default_var.pixclock =
+		    viafb_get_pixclock(viafb_second_xres, viafb_second_yres,
+		    viafb_refresh);
+		default_var.left_margin = (viafb_second_xres >> 3) & 0xf8;
+		default_var.right_margin = 32;
+		default_var.upper_margin = 16;
+		default_var.lower_margin = 4;
+		default_var.hsync_len = default_var.left_margin;
+		default_var.vsync_len = 4;
+
+		viafb_setup_fixinfo(&viafbinfo1->fix, viaparinfo1);
+		viafb_check_var(&default_var, viafbinfo1);
+		viafbinfo1->var = default_var;
+		viafb_update_viafb_par(viafbinfo);
+		viafb_update_fix(&viafbinfo1->fix, viafbinfo1);
+	}
+
+	viafb_setup_fixinfo(&viafbinfo->fix, viaparinfo);
+	viafb_check_var(&default_var, viafbinfo);
+	viafbinfo->var = default_var;
+	viafb_update_viafb_par(viafbinfo);
+	viafb_update_fix(&viafbinfo->fix, viafbinfo);
+	default_var.activate = FB_ACTIVATE_NOW;
+	fb_alloc_cmap(&viafbinfo->cmap, 256, 0);
+
+	if (viafb_dual_fb && (viafb_primary_dev == LCD_Device)
+	    && (viaparinfo->chip_info->gfx_chip_name == UNICHROME_CLE266)) {
+		if (register_framebuffer(viafbinfo1) < 0)
+			return -EINVAL;
+	}
+	if (register_framebuffer(viafbinfo) < 0)
+		return -EINVAL;
+
+	if (viafb_dual_fb && ((viafb_primary_dev != LCD_Device)
+			|| (viaparinfo->chip_info->gfx_chip_name !=
+			UNICHROME_CLE266))) {
+		if (register_framebuffer(viafbinfo1) < 0)
+			return -EINVAL;
+	}
+	DEBUG_MSG(KERN_INFO "fb%d: %s frame buffer device %dx%d-%dbpp\n",
+		  viafbinfo->node, viafbinfo->fix.id, default_var.xres,
+		  default_var.yres, default_var.bits_per_pixel);
+
+	viafb_init_proc(viaparinfo->proc_entry);
+	viafb_init_dac(IGA2);
+	return 0;
+}
+
+static void __devexit via_pci_remove(void)
+{
+	DEBUG_MSG(KERN_INFO "via_pci_remove!\n");
+	fb_dealloc_cmap(&viafbinfo->cmap);
+	unregister_framebuffer(viafbinfo);
+	if (viafb_dual_fb)
+		unregister_framebuffer(viafbinfo1);
+	iounmap((void *)viaparinfo->fbmem_virt);
+	iounmap(viaparinfo->io_virt);
+
+	viafb_delete_i2c_buss(viaparinfo);
+
+	framebuffer_release(viafbinfo);
+	if (viafb_dual_fb)
+		framebuffer_release(viafbinfo1);
+
+	viafb_remove_proc(viaparinfo->proc_entry);
+}
+
+#ifndef MODULE
+static int __init viafb_setup(char *options)
+{
+	char *this_opt;
+	DEBUG_MSG(KERN_INFO "viafb_setup!\n");
+
+	if (!options || !*options)
+		return 0;
+
+	while ((this_opt = strsep(&options, ",")) != NULL) {
+		if (!*this_opt)
+			continue;
+
+		if (!strncmp(this_opt, "viafb_mode1=", 12))
+			viafb_mode1 = kstrdup(this_opt + 12, GFP_KERNEL);
+		else if (!strncmp(this_opt, "viafb_mode=", 11))
+			viafb_mode = kstrdup(this_opt + 11, GFP_KERNEL);
+		else if (!strncmp(this_opt, "viafb_bpp1=", 11))
+			strict_strtoul(this_opt + 11, 0,
+				(unsigned long *)&viafb_bpp1);
+		else if (!strncmp(this_opt, "viafb_bpp=", 10))
+			strict_strtoul(this_opt + 10, 0,
+				(unsigned long *)&viafb_bpp);
+		else if (!strncmp(this_opt, "viafb_refresh1=", 15))
+			strict_strtoul(this_opt + 15, 0,
+				(unsigned long *)&viafb_refresh1);
+		else if (!strncmp(this_opt, "viafb_refresh=", 14))
+			strict_strtoul(this_opt + 14, 0,
+				(unsigned long *)&viafb_refresh);
+		else if (!strncmp(this_opt, "viafb_lcd_dsp_method=", 21))
+			strict_strtoul(this_opt + 21, 0,
+				(unsigned long *)&viafb_lcd_dsp_method);
+		else if (!strncmp(this_opt, "viafb_lcd_panel_id=", 19))
+			strict_strtoul(this_opt + 19, 0,
+				(unsigned long *)&viafb_lcd_panel_id);
+		else if (!strncmp(this_opt, "viafb_accel=", 12))
+			strict_strtoul(this_opt + 12, 0,
+				(unsigned long *)&viafb_accel);
+		else if (!strncmp(this_opt, "viafb_SAMM_ON=", 14))
+			strict_strtoul(this_opt + 14, 0,
+				(unsigned long *)&viafb_SAMM_ON);
+		else if (!strncmp(this_opt, "viafb_active_dev=", 17))
+			viafb_active_dev = kstrdup(this_opt + 17, GFP_KERNEL);
+		else if (!strncmp(this_opt,
+			"viafb_display_hardware_layout=", 30))
+			strict_strtoul(this_opt + 30, 0,
+			(unsigned long *)&viafb_display_hardware_layout);
+		else if (!strncmp(this_opt, "viafb_second_size=", 18))
+			strict_strtoul(this_opt + 18, 0,
+				(unsigned long *)&viafb_second_size);
+		else if (!strncmp(this_opt,
+			"viafb_platform_epia_dvi=", 24))
+			strict_strtoul(this_opt + 24, 0,
+				(unsigned long *)&viafb_platform_epia_dvi);
+		else if (!strncmp(this_opt,
+			"viafb_device_lcd_dualedge=", 26))
+			strict_strtoul(this_opt + 26, 0,
+				(unsigned long *)&viafb_device_lcd_dualedge);
+		else if (!strncmp(this_opt, "viafb_bus_width=", 16))
+			strict_strtoul(this_opt + 16, 0,
+				(unsigned long *)&viafb_bus_width);
+		else if (!strncmp(this_opt, "viafb_lcd_mode=", 15))
+			strict_strtoul(this_opt + 15, 0,
+				(unsigned long *)&viafb_lcd_mode);
+		else if (!strncmp(this_opt, "viafb_video_dev=", 16))
+			viafb_video_dev = kstrdup(this_opt + 16, GFP_KERNEL);
+		else if (!strncmp(this_opt, "viafb_lcd_port=", 15))
+			viafb_lcd_port = kstrdup(this_opt + 15, GFP_KERNEL);
+		else if (!strncmp(this_opt, "viafb_dvi_port=", 15))
+			viafb_dvi_port = kstrdup(this_opt + 15, GFP_KERNEL);
+	}
+	return 0;
+}
+#endif
+
+static int __init viafb_init(void)
+{
+#ifndef MODULE
+	char *option = NULL;
+	if (fb_get_options("viafb", &option))
+		return -ENODEV;
+	viafb_setup(option);
+#endif
+	printk(KERN_INFO
+       "VIA Graphics Intergration Chipset framebuffer %d.%d initializing\n",
+	       VERSION_MAJOR, VERSION_MINOR);
+	return via_pci_probe();
+}
+
+static void __exit viafb_exit(void)
+{
+	DEBUG_MSG(KERN_INFO "viafb_exit!\n");
+	via_pci_remove();
+}
+
+static struct fb_ops viafb_ops = {
+	.owner = THIS_MODULE,
+	.fb_open = viafb_open,
+	.fb_release = viafb_release,
+	.fb_check_var = viafb_check_var,
+	.fb_set_par = viafb_set_par,
+	.fb_setcolreg = viafb_setcolreg,
+	.fb_pan_display = viafb_pan_display,
+	.fb_blank = viafb_blank,
+	.fb_fillrect = viafb_fillrect,
+	.fb_copyarea = viafb_copyarea,
+	.fb_imageblit = viafb_imageblit,
+	.fb_cursor = viafb_cursor,
+	.fb_ioctl = viafb_ioctl,
+	.fb_sync = viafb_sync,
+	.fb_setcmap = viafb_setcmap,
+};
+
+module_init(viafb_init);
+module_exit(viafb_exit);
+
+#ifdef MODULE
+module_param(viafb_memsize, int, 0);
+
+module_param(viafb_mode, charp, 0);
+MODULE_PARM_DESC(viafb_mode, "Set resolution (default=640x480)");
+
+module_param(viafb_mode1, charp, 0);
+MODULE_PARM_DESC(viafb_mode1, "Set resolution (default=640x480)");
+
+module_param(viafb_bpp, int, 0);
+MODULE_PARM_DESC(viafb_bpp, "Set color depth (default=32bpp)");
+
+module_param(viafb_bpp1, int, 0);
+MODULE_PARM_DESC(viafb_bpp1, "Set color depth (default=32bpp)");
+
+module_param(viafb_refresh, int, 0);
+MODULE_PARM_DESC(viafb_refresh,
+	"Set CRT viafb_refresh rate (default = 60)");
+
+module_param(viafb_refresh1, int, 0);
+MODULE_PARM_DESC(viafb_refresh1,
+	"Set CRT refresh rate (default = 60)");
+
+module_param(viafb_lcd_panel_id, int, 0);
+MODULE_PARM_DESC(viafb_lcd_panel_id,
+	"Set Flat Panel type(Default=1024x768)");
+
+module_param(viafb_lcd_dsp_method, int, 0);
+MODULE_PARM_DESC(viafb_lcd_dsp_method,
+	"Set Flat Panel display scaling method.(Default=Expandsion)");
+
+module_param(viafb_SAMM_ON, int, 0);
+MODULE_PARM_DESC(viafb_SAMM_ON,
+	"Turn on/off flag of SAMM(Default=OFF)");
+
+module_param(viafb_accel, int, 0);
+MODULE_PARM_DESC(viafb_accel,
+	"Set 2D Hardware Acceleration.(Default = OFF)");
+
+module_param(viafb_active_dev, charp, 0);
+MODULE_PARM_DESC(viafb_active_dev, "Specify active devices.");
+
+module_param(viafb_display_hardware_layout, int, 0);
+MODULE_PARM_DESC(viafb_display_hardware_layout,
+	"Display Hardware Layout (LCD Only, DVI Only...,etc)");
+
+module_param(viafb_second_size, int, 0);
+MODULE_PARM_DESC(viafb_second_size,
+	"Set secondary device memory size");
+
+module_param(viafb_dual_fb, int, 0);
+MODULE_PARM_DESC(viafb_dual_fb,
+	"Turn on/off flag of dual framebuffer devices.(Default = OFF)");
+
+module_param(viafb_platform_epia_dvi, int, 0);
+MODULE_PARM_DESC(viafb_platform_epia_dvi,
+	"Turn on/off flag of DVI devices on EPIA board.(Default = OFF)");
+
+module_param(viafb_device_lcd_dualedge, int, 0);
+MODULE_PARM_DESC(viafb_device_lcd_dualedge,
+	"Turn on/off flag of dual edge panel.(Default = OFF)");
+
+module_param(viafb_bus_width, int, 0);
+MODULE_PARM_DESC(viafb_bus_width,
+	"Set bus width of panel.(Default = 12)");
+
+module_param(viafb_lcd_mode, int, 0);
+MODULE_PARM_DESC(viafb_lcd_mode,
+	"Set Flat Panel mode(Default=OPENLDI)");
+
+module_param(viafb_video_dev, charp, 0);
+MODULE_PARM_DESC(viafb_video_dev, "Specify video devices.");
+
+module_param(viafb_lcd_port, charp, 0);
+MODULE_PARM_DESC(viafb_lcd_port, "Specify LCD output port.");
+
+module_param(viafb_dvi_port, charp, 0);
+MODULE_PARM_DESC(viafb_dvi_port, "Specify DVI output port.");
+
+MODULE_LICENSE("GPL");
+#endif
--- /dev/null
+++ b/drivers/video/via/viafbdev.h
@@ -0,0 +1,112 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __VIAFBDEV_H__
+#define __VIAFBDEV_H__
+
+#include <linux/proc_fs.h>
+#include <linux/fb.h>
+
+#include "ioctl.h"
+#include "share.h"
+#include "chip.h"
+#include "hw.h"
+#include "via_i2c.h"
+
+#define VERSION_MAJOR       2
+#define VERSION_KERNEL      6	/* For kernel 2.6 */
+
+#define VERSION_OS          0	/* 0: for 32 bits OS, 1: for 64 bits OS */
+#define VERSION_MINOR       4
+
+struct viafb_par {
+	int bpp;
+	int hres;
+	int vres;
+	int linelength;
+	u32 xoffset;
+	u32 yoffset;
+
+	void __iomem *fbmem_virt;	/*framebuffer virtual memory address */
+	void __iomem *io_virt;	/*iospace virtual memory address */
+	unsigned int fbmem;	/*framebuffer physical memory address */
+	unsigned int memsize;	/*size of fbmem */
+	unsigned int io;	/*io space address */
+	unsigned long mmio_base;	/*mmio base address */
+	unsigned long mmio_len;	/*mmio base length */
+	u32 fbmem_free;		/* Free FB memory */
+	u32 fbmem_used;		/* Use FB memory size */
+	u32 cursor_start;	/* Cursor Start Address */
+	u32 VQ_start;		/* Virtual Queue Start Address */
+	u32 VQ_end;		/* Virtual Queue End Address */
+	u32 iga_path;
+	struct proc_dir_entry *proc_entry;	/*viafb proc entry */
+	u8 duoview;		/*Is working in duoview mode? */
+
+	/* I2C stuff */
+	struct via_i2c_stuff i2c_stuff;
+
+	/* All the information will be needed to set engine */
+	struct tmds_setting_information *tmds_setting_info;
+	struct crt_setting_information *crt_setting_info;
+	struct lvds_setting_information *lvds_setting_info;
+	struct lvds_setting_information *lvds_setting_info2;
+	struct chip_information *chip_info;
+
+	/* some information related to video playing */
+	int video_on_crt;
+	int video_on_dvi;
+	int video_on_lcd;
+
+};
+struct viafb_modeinfo {
+	u32 xres;
+	u32 yres;
+	int mode_index;
+	char *mode_res;
+};
+extern unsigned int viafb_second_virtual_yres;
+extern unsigned int viafb_second_virtual_xres;
+extern unsigned int viafb_second_offset;
+extern int viafb_second_size;
+extern int viafb_SAMM_ON;
+extern int viafb_dual_fb;
+extern int viafb_LCD2_ON;
+extern int viafb_LCD_ON;
+extern int viafb_DVI_ON;
+extern int viafb_accel;
+extern int viafb_hotplug;
+extern int viafb_memsize;
+
+extern int strict_strtoul(const char *cp, unsigned int base,
+	unsigned long *res);
+
+void viafb_memory_pitch_patch(struct fb_info *info);
+void viafb_fill_var_timing_info(struct fb_var_screeninfo *var, int refresh,
+			  int mode_index);
+int viafb_get_mode_index(int hres, int vres, int flag);
+u8 viafb_gpio_i2c_read_lvds(struct lvds_setting_information
+	*plvds_setting_info, struct lvds_chip_information
+	*plvds_chip_info, u8 index);
+void viafb_gpio_i2c_write_mask_lvds(struct lvds_setting_information
+			      *plvds_setting_info, struct lvds_chip_information
+			      *plvds_chip_info, struct IODATA io_data);
+#endif /* __VIAFBDEV_H__ */
--- /dev/null
+++ b/drivers/video/via/via_i2c.c
@@ -0,0 +1,177 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "global.h"
+
+static void via_i2c_setscl(void *data, int state)
+{
+	u8 val;
+	struct via_i2c_stuff *via_i2c_chan = (struct via_i2c_stuff *)data;
+
+	val = viafb_read_reg(VIASR, via_i2c_chan->i2c_port) & 0xF0;
+	if (state)
+		val |= 0x20;
+	else
+		val &= ~0x20;
+	switch (via_i2c_chan->i2c_port) {
+	case I2CPORTINDEX:
+		val |= 0x01;
+		break;
+	case GPIOPORTINDEX:
+		val |= 0x80;
+		break;
+	default:
+		DEBUG_MSG("via_i2c: specify wrong i2c port.\n");
+	}
+	viafb_write_reg(via_i2c_chan->i2c_port, VIASR, val);
+}
+
+static int via_i2c_getscl(void *data)
+{
+	struct via_i2c_stuff *via_i2c_chan = (struct via_i2c_stuff *)data;
+
+	if (viafb_read_reg(VIASR, via_i2c_chan->i2c_port) & 0x08)
+		return 1;
+	return 0;
+}
+
+static int via_i2c_getsda(void *data)
+{
+	struct via_i2c_stuff *via_i2c_chan = (struct via_i2c_stuff *)data;
+
+	if (viafb_read_reg(VIASR, via_i2c_chan->i2c_port) & 0x04)
+		return 1;
+	return 0;
+}
+
+static void via_i2c_setsda(void *data, int state)
+{
+	u8 val;
+	struct via_i2c_stuff *via_i2c_chan = (struct via_i2c_stuff *)data;
+
+	val = viafb_read_reg(VIASR, via_i2c_chan->i2c_port) & 0xF0;
+	if (state)
+		val |= 0x10;
+	else
+		val &= ~0x10;
+	switch (via_i2c_chan->i2c_port) {
+	case I2CPORTINDEX:
+		val |= 0x01;
+		break;
+	case GPIOPORTINDEX:
+		val |= 0x40;
+		break;
+	default:
+		DEBUG_MSG("via_i2c: specify wrong i2c port.\n");
+	}
+	viafb_write_reg(via_i2c_chan->i2c_port, VIASR, val);
+}
+
+int viafb_i2c_readbyte(u8 slave_addr, u8 index, u8 *pdata)
+{
+	u8 mm1[] = {0x00};
+	struct i2c_msg msgs[2];
+
+	*pdata = 0;
+	msgs[0].flags = 0;
+	msgs[1].flags = I2C_M_RD;
+	msgs[0].addr = msgs[1].addr = slave_addr / 2;
+	mm1[0] = index;
+	msgs[0].len = 1; msgs[1].len = 1;
+	msgs[0].buf = mm1; msgs[1].buf = pdata;
+	i2c_transfer(&viaparinfo->i2c_stuff.adapter, msgs, 2);
+
+	return 0;
+}
+
+int viafb_i2c_writebyte(u8 slave_addr, u8 index, u8 data)
+{
+	u8 msg[2] = { index, data };
+	struct i2c_msg msgs;
+
+	msgs.flags = 0;
+	msgs.addr = slave_addr / 2;
+	msgs.len = 2;
+	msgs.buf = msg;
+	return i2c_transfer(&viaparinfo->i2c_stuff.adapter, &msgs, 1);
+}
+
+int viafb_i2c_readbytes(u8 slave_addr, u8 index, u8 *buff, int buff_len)
+{
+	u8 mm1[] = {0x00};
+	struct i2c_msg msgs[2];
+
+	msgs[0].flags = 0;
+	msgs[1].flags = I2C_M_RD;
+	msgs[0].addr = msgs[1].addr = slave_addr / 2;
+	mm1[0] = index;
+	msgs[0].len = 1; msgs[1].len = buff_len;
+	msgs[0].buf = mm1; msgs[1].buf = buff;
+	i2c_transfer(&viaparinfo->i2c_stuff.adapter, msgs, 2);
+	return 0;
+}
+
+int viafb_create_i2c_bus(void *viapar)
+{
+	int ret;
+	struct viafb_par *par = (struct viafb_par *)viapar;
+
+	strcpy(par->i2c_stuff.adapter.name, "via_i2c");
+	par->i2c_stuff.i2c_port = 0x0;
+	par->i2c_stuff.adapter.owner = THIS_MODULE;
+	par->i2c_stuff.adapter.id = 0x01FFFF;
+	par->i2c_stuff.adapter.class = 0;
+	par->i2c_stuff.adapter.algo_data = &par->i2c_stuff.algo;
+	par->i2c_stuff.adapter.dev.parent = NULL;
+	par->i2c_stuff.algo.setsda = via_i2c_setsda;
+	par->i2c_stuff.algo.setscl = via_i2c_setscl;
+	par->i2c_stuff.algo.getsda = via_i2c_getsda;
+	par->i2c_stuff.algo.getscl = via_i2c_getscl;
+	par->i2c_stuff.algo.udelay = 40;
+	par->i2c_stuff.algo.timeout = 20;
+	par->i2c_stuff.algo.data = &par->i2c_stuff;
+
+	i2c_set_adapdata(&par->i2c_stuff.adapter, &par->i2c_stuff);
+
+	/* Raise SCL and SDA */
+	par->i2c_stuff.i2c_port = I2CPORTINDEX;
+	via_i2c_setsda(&par->i2c_stuff, 1);
+	via_i2c_setscl(&par->i2c_stuff, 1);
+
+	par->i2c_stuff.i2c_port = GPIOPORTINDEX;
+	via_i2c_setsda(&par->i2c_stuff, 1);
+	via_i2c_setscl(&par->i2c_stuff, 1);
+	udelay(20);
+
+	ret = i2c_bit_add_bus(&par->i2c_stuff.adapter);
+	if (ret == 0)
+		DEBUG_MSG("I2C bus %s registered.\n",
+		par->i2c_stuff.adapter.name);
+	else
+		DEBUG_MSG("Failed to register I2C bus %s.\n",
+			par->i2c_stuff.adapter.name);
+	return ret;
+}
+
+void viafb_delete_i2c_buss(void *par)
+{
+	i2c_del_adapter(&((struct viafb_par *)par)->i2c_stuff.adapter);
+}
--- /dev/null
+++ b/drivers/video/via/via_i2c.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#ifndef __VIA_I2C_H__
+#define __VIA_I2C_H__
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+
+struct via_i2c_stuff {
+	u16 i2c_port;			/* GPIO or I2C port */
+	struct i2c_adapter adapter;
+	struct i2c_algo_bit_data algo;
+};
+
+#define I2CPORT           0x3c4
+#define I2CPORTINDEX      0x31
+#define GPIOPORT          0x3C4
+#define GPIOPORTINDEX     0x2C
+#define I2C_BUS             1
+#define GPIO_BUS            2
+#define DELAYPORT           0x3C3
+
+int viafb_i2c_readbyte(u8 slave_addr, u8 index, u8 *pdata);
+int viafb_i2c_writebyte(u8 slave_addr, u8 index, u8 data);
+int viafb_i2c_readbytes(u8 slave_addr, u8 index, u8 *buff, int buff_len);
+int viafb_create_i2c_bus(void *par);
+void viafb_delete_i2c_buss(void *par);
+#endif /* __VIA_I2C_H__ */
--- /dev/null
+++ b/drivers/video/via/viamode.c
@@ -0,0 +1,1086 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "global.h"
+struct res_map_refresh res_map_refresh_tbl[] = {
+/*hres, vres, vclock, vmode_refresh*/
+	{480, 640, RES_480X640_60HZ_PIXCLOCK, 60},
+	{640, 480, RES_640X480_60HZ_PIXCLOCK, 60},
+	{640, 480, RES_640X480_75HZ_PIXCLOCK, 75},
+	{640, 480, RES_640X480_85HZ_PIXCLOCK, 85},
+	{640, 480, RES_640X480_100HZ_PIXCLOCK, 100},
+	{640, 480, RES_640X480_120HZ_PIXCLOCK, 120},
+	{720, 480, RES_720X480_60HZ_PIXCLOCK, 60},
+	{720, 576, RES_720X576_60HZ_PIXCLOCK, 60},
+	{800, 480, RES_800X480_60HZ_PIXCLOCK, 60},
+	{800, 600, RES_800X600_60HZ_PIXCLOCK, 60},
+	{800, 600, RES_800X600_75HZ_PIXCLOCK, 75},
+	{800, 600, RES_800X600_85HZ_PIXCLOCK, 85},
+	{800, 600, RES_800X600_100HZ_PIXCLOCK, 100},
+	{800, 600, RES_800X600_120HZ_PIXCLOCK, 120},
+	{848, 480, RES_848X480_60HZ_PIXCLOCK, 60},
+	{856, 480, RES_856X480_60HZ_PIXCLOCK, 60},
+	{1024, 512, RES_1024X512_60HZ_PIXCLOCK, 60},
+	{1024, 600, RES_1024X600_60HZ_PIXCLOCK, 60},
+	{1024, 768, RES_1024X768_60HZ_PIXCLOCK, 60},
+	{1024, 768, RES_1024X768_75HZ_PIXCLOCK, 75},
+	{1024, 768, RES_1024X768_85HZ_PIXCLOCK, 85},
+	{1024, 768, RES_1024X768_100HZ_PIXCLOCK, 100},
+/*  {1152,864, RES_1152X864_70HZ_PIXCLOCK,  70},*/
+	{1152, 864, RES_1152X864_75HZ_PIXCLOCK, 75},
+	{1280, 768, RES_1280X768_60HZ_PIXCLOCK, 60},
+	{1280, 800, RES_1280X800_60HZ_PIXCLOCK, 60},
+	{1280, 960, RES_1280X960_60HZ_PIXCLOCK, 60},
+	{1280, 1024, RES_1280X1024_60HZ_PIXCLOCK, 60},
+	{1280, 1024, RES_1280X1024_75HZ_PIXCLOCK, 75},
+	{1280, 1024, RES_1280X768_85HZ_PIXCLOCK, 85},
+	{1440, 1050, RES_1440X1050_60HZ_PIXCLOCK, 60},
+	{1600, 1200, RES_1600X1200_60HZ_PIXCLOCK, 60},
+	{1600, 1200, RES_1600X1200_75HZ_PIXCLOCK, 75},
+	{1280, 720, RES_1280X720_60HZ_PIXCLOCK, 60},
+	{1920, 1080, RES_1920X1080_60HZ_PIXCLOCK, 60},
+	{1400, 1050, RES_1400X1050_60HZ_PIXCLOCK, 60},
+	{1400, 1050, RES_1400X1050_75HZ_PIXCLOCK, 75},
+	{1368, 768, RES_1368X768_60HZ_PIXCLOCK, 60},
+	{960, 600, RES_960X600_60HZ_PIXCLOCK, 60},
+	{1000, 600, RES_1000X600_60HZ_PIXCLOCK, 60},
+	{1024, 576, RES_1024X576_60HZ_PIXCLOCK, 60},
+	{1088, 612, RES_1088X612_60HZ_PIXCLOCK, 60},
+	{1152, 720, RES_1152X720_60HZ_PIXCLOCK, 60},
+	{1200, 720, RES_1200X720_60HZ_PIXCLOCK, 60},
+	{1280, 600, RES_1280X600_60HZ_PIXCLOCK, 60},
+	{1280, 720, RES_1280X720_50HZ_PIXCLOCK, 50},
+	{1280, 768, RES_1280X768_50HZ_PIXCLOCK, 50},
+	{1360, 768, RES_1360X768_60HZ_PIXCLOCK, 60},
+	{1366, 768, RES_1366X768_50HZ_PIXCLOCK, 50},
+	{1366, 768, RES_1366X768_60HZ_PIXCLOCK, 60},
+	{1440, 900, RES_1440X900_60HZ_PIXCLOCK, 60},
+	{1440, 900, RES_1440X900_75HZ_PIXCLOCK, 75},
+	{1600, 900, RES_1600X900_60HZ_PIXCLOCK, 60},
+	{1600, 1024, RES_1600X1024_60HZ_PIXCLOCK, 60},
+	{1680, 1050, RES_1680X1050_60HZ_PIXCLOCK, 60},
+	{1680, 1050, RES_1680X1050_75HZ_PIXCLOCK, 75},
+	{1792, 1344, RES_1792X1344_60HZ_PIXCLOCK, 60},
+	{1856, 1392, RES_1856X1392_60HZ_PIXCLOCK, 60},
+	{1920, 1200, RES_1920X1200_60HZ_PIXCLOCK, 60},
+	{1920, 1440, RES_1920X1440_60HZ_PIXCLOCK, 60},
+	{1920, 1440, RES_1920X1440_75HZ_PIXCLOCK, 75},
+	{2048, 1536, RES_2048X1536_60HZ_PIXCLOCK, 60}
+};
+
+struct io_reg CN400_ModeXregs[] = { {VIASR, SR10, 0xFF, 0x01},
+{VIASR, SR15, 0x02, 0x02},
+{VIASR, SR16, 0xBF, 0x08},
+{VIASR, SR17, 0xFF, 0x1F},
+{VIASR, SR18, 0xFF, 0x4E},
+{VIASR, SR1A, 0xFB, 0x08},
+{VIASR, SR1E, 0x0F, 0x01},
+{VIASR, SR2A, 0xFF, 0x00},
+{VIACR, CR0A, 0xFF, 0x1E},	/* Cursor Start                        */
+{VIACR, CR0B, 0xFF, 0x00},	/* Cursor End                          */
+{VIACR, CR0E, 0xFF, 0x00},	/* Cursor Location High                */
+{VIACR, CR0F, 0xFF, 0x00},	/* Cursor Localtion Low                */
+{VIACR, CR32, 0xFF, 0x00},
+{VIACR, CR33, 0xFF, 0x00},
+{VIACR, CR34, 0xFF, 0x00},
+{VIACR, CR35, 0xFF, 0x00},
+{VIACR, CR36, 0x08, 0x00},
+{VIACR, CR62, 0xFF, 0x00},	/* Secondary Display Starting Address  */
+{VIACR, CR63, 0xFF, 0x00},	/* Secondary Display Starting Address  */
+{VIACR, CR64, 0xFF, 0x00},	/* Secondary Display Starting Address  */
+{VIACR, CR69, 0xFF, 0x00},
+{VIACR, CR6A, 0xFF, 0x40},
+{VIACR, CR6B, 0xFF, 0x00},
+{VIACR, CR6C, 0xFF, 0x00},
+{VIACR, CR7A, 0xFF, 0x01},	/* LCD Scaling Parameter 1             */
+{VIACR, CR7B, 0xFF, 0x02},	/* LCD Scaling Parameter 2             */
+{VIACR, CR7C, 0xFF, 0x03},	/* LCD Scaling Parameter 3             */
+{VIACR, CR7D, 0xFF, 0x04},	/* LCD Scaling Parameter 4             */
+{VIACR, CR7E, 0xFF, 0x07},	/* LCD Scaling Parameter 5             */
+{VIACR, CR7F, 0xFF, 0x0A},	/* LCD Scaling Parameter 6             */
+{VIACR, CR80, 0xFF, 0x0D},	/* LCD Scaling Parameter 7             */
+{VIACR, CR81, 0xFF, 0x13},	/* LCD Scaling Parameter 8             */
+{VIACR, CR82, 0xFF, 0x16},	/* LCD Scaling Parameter 9             */
+{VIACR, CR83, 0xFF, 0x19},	/* LCD Scaling Parameter 10            */
+{VIACR, CR84, 0xFF, 0x1C},	/* LCD Scaling Parameter 11            */
+{VIACR, CR85, 0xFF, 0x1D},	/* LCD Scaling Parameter 12            */
+{VIACR, CR86, 0xFF, 0x1E},	/* LCD Scaling Parameter 13            */
+{VIACR, CR87, 0xFF, 0x1F},	/* LCD Scaling Parameter 14            */
+{VIACR, CR88, 0xFF, 0x40},	/* LCD Panel Type                      */
+{VIACR, CR89, 0xFF, 0x00},	/* LCD Timing Control 0                */
+{VIACR, CR8A, 0xFF, 0x88},	/* LCD Timing Control 1                */
+{VIACR, CR8B, 0xFF, 0x69},	/* LCD Power Sequence Control 0        */
+{VIACR, CR8C, 0xFF, 0x57},	/* LCD Power Sequence Control 1        */
+{VIACR, CR8D, 0xFF, 0x00},	/* LCD Power Sequence Control 2        */
+{VIACR, CR8E, 0xFF, 0x7B},	/* LCD Power Sequence Control 3        */
+{VIACR, CR8F, 0xFF, 0x03},	/* LCD Power Sequence Control 4        */
+{VIACR, CR90, 0xFF, 0x30},	/* LCD Power Sequence Control 5        */
+{VIACR, CR91, 0xFF, 0xA0},	/* 24/12 bit LVDS Data off             */
+{VIACR, CR96, 0xFF, 0x00},
+{VIACR, CR97, 0xFF, 0x00},
+{VIACR, CR99, 0xFF, 0x00},
+{VIACR, CR9B, 0xFF, 0x00}
+};
+
+/* Video Mode Table for VT3314 chipset*/
+/* Common Setting for Video Mode */
+struct io_reg CN700_ModeXregs[] = { {VIASR, SR10, 0xFF, 0x01},
+{VIASR, SR15, 0x02, 0x02},
+{VIASR, SR16, 0xBF, 0x08},
+{VIASR, SR17, 0xFF, 0x1F},
+{VIASR, SR18, 0xFF, 0x4E},
+{VIASR, SR1A, 0xFB, 0x82},
+{VIASR, SR1B, 0xFF, 0xF0},
+{VIASR, SR1F, 0xFF, 0x00},
+{VIASR, SR1E, 0xFF, 0x01},
+{VIASR, SR22, 0xFF, 0x1F},
+{VIASR, SR2A, 0x0F, 0x00},
+{VIASR, SR2E, 0xFF, 0xFF},
+{VIASR, SR3F, 0xFF, 0xFF},
+{VIASR, SR40, 0xF7, 0x00},
+{VIASR, CR30, 0xFF, 0x04},
+{VIACR, CR32, 0xFF, 0x00},
+{VIACR, CR33, 0x7F, 0x00},
+{VIACR, CR34, 0xFF, 0x00},
+{VIACR, CR35, 0xFF, 0x00},
+{VIACR, CR36, 0xFF, 0x31},
+{VIACR, CR41, 0xFF, 0x80},
+{VIACR, CR42, 0xFF, 0x00},
+{VIACR, CR55, 0x80, 0x00},
+{VIACR, CR5D, 0x80, 0x00},	/*Horizontal Retrace Start bit[11] should be 0*/
+{VIACR, CR62, 0xFF, 0x00},	/* Secondary Display Starting Address */
+{VIACR, CR63, 0xFF, 0x00},	/* Secondary Display Starting Address */
+{VIACR, CR64, 0xFF, 0x00},	/* Secondary Display Starting Address */
+{VIACR, CR68, 0xFF, 0x67},	/* Default FIFO For IGA2 */
+{VIACR, CR69, 0xFF, 0x00},
+{VIACR, CR6A, 0xFD, 0x40},
+{VIACR, CR6B, 0xFF, 0x00},
+{VIACR, CR6C, 0xFF, 0x00},
+{VIACR, CR77, 0xFF, 0x00},	/* LCD scaling Factor */
+{VIACR, CR78, 0xFF, 0x00},	/* LCD scaling Factor */
+{VIACR, CR79, 0xFF, 0x00},	/* LCD scaling Factor */
+{VIACR, CR9F, 0x03, 0x00},	/* LCD scaling Factor */
+{VIACR, CR7A, 0xFF, 0x01},	/* LCD Scaling Parameter 1 */
+{VIACR, CR7B, 0xFF, 0x02},	/* LCD Scaling Parameter 2 */
+{VIACR, CR7C, 0xFF, 0x03},	/* LCD Scaling Parameter 3 */
+{VIACR, CR7D, 0xFF, 0x04},	/* LCD Scaling Parameter 4 */
+{VIACR, CR7E, 0xFF, 0x07},	/* LCD Scaling Parameter 5 */
+{VIACR, CR7F, 0xFF, 0x0A},	/* LCD Scaling Parameter 6 */
+{VIACR, CR80, 0xFF, 0x0D},	/* LCD Scaling Parameter 7 */
+{VIACR, CR81, 0xFF, 0x13},	/* LCD Scaling Parameter 8 */
+{VIACR, CR82, 0xFF, 0x16},	/* LCD Scaling Parameter 9 */
+{VIACR, CR83, 0xFF, 0x19},	/* LCD Scaling Parameter 10 */
+{VIACR, CR84, 0xFF, 0x1C},	/* LCD Scaling Parameter 11 */
+{VIACR, CR85, 0xFF, 0x1D},	/* LCD Scaling Parameter 12 */
+{VIACR, CR86, 0xFF, 0x1E},	/* LCD Scaling Parameter 13 */
+{VIACR, CR87, 0xFF, 0x1F},	/* LCD Scaling Parameter 14 */
+{VIACR, CR88, 0xFF, 0x40},	/* LCD Panel Type */
+{VIACR, CR89, 0xFF, 0x00},	/* LCD Timing Control 0 */
+{VIACR, CR8A, 0xFF, 0x88},	/* LCD Timing Control 1 */
+{VIACR, CR8B, 0xFF, 0x5D},	/* LCD Power Sequence Control 0 */
+{VIACR, CR8C, 0xFF, 0x2B},	/* LCD Power Sequence Control 1 */
+{VIACR, CR8D, 0xFF, 0x6F},	/* LCD Power Sequence Control 2 */
+{VIACR, CR8E, 0xFF, 0x2B},	/* LCD Power Sequence Control 3 */
+{VIACR, CR8F, 0xFF, 0x01},	/* LCD Power Sequence Control 4 */
+{VIACR, CR90, 0xFF, 0x01},	/* LCD Power Sequence Control 5 */
+{VIACR, CR91, 0xFF, 0xA0},	/* 24/12 bit LVDS Data off */
+{VIACR, CR96, 0xFF, 0x00},
+{VIACR, CR97, 0xFF, 0x00},
+{VIACR, CR99, 0xFF, 0x00},
+{VIACR, CR9B, 0xFF, 0x00},
+{VIACR, CR9D, 0xFF, 0x80},
+{VIACR, CR9E, 0xFF, 0x80}
+};
+
+struct io_reg KM400_ModeXregs[] = {
+	{VIASR, SR10, 0xFF, 0x01},	/* Unlock Register                 */
+	{VIASR, SR16, 0xFF, 0x08},	/* Display FIFO threshold Control  */
+	{VIASR, SR17, 0xFF, 0x1F},	/* Display FIFO Control            */
+	{VIASR, SR18, 0xFF, 0x4E},	/* GFX PREQ threshold              */
+	{VIASR, SR1A, 0xFF, 0x0a},	/* GFX PREQ threshold              */
+	{VIASR, SR1F, 0xFF, 0x00},	/* Memory Control 0                */
+	{VIASR, SR1B, 0xFF, 0xF0},	/* Power Management Control 0      */
+	{VIASR, SR1E, 0xFF, 0x01},	/* Power Management Control        */
+	{VIASR, SR20, 0xFF, 0x00},	/* Sequencer Arbiter Control 0     */
+	{VIASR, SR21, 0xFF, 0x00},	/* Sequencer Arbiter Control 1     */
+	{VIASR, SR22, 0xFF, 0x1F},	/* Display Arbiter Control 1       */
+	{VIASR, SR2A, 0xFF, 0x00},	/* Power Management Control 5      */
+	{VIASR, SR2D, 0xFF, 0xFF},	/* Power Management Control 1      */
+	{VIASR, SR2E, 0xFF, 0xFF},	/* Power Management Control 2      */
+	{VIACR, CR0A, 0xFF, 0x1E},	/* Cursor Start                    */
+	{VIACR, CR0B, 0xFF, 0x00},	/* Cursor End                      */
+	{VIACR, CR0E, 0xFF, 0x00},	/* Cursor Location High            */
+	{VIACR, CR0F, 0xFF, 0x00},	/* Cursor Localtion Low            */
+	{VIACR, CR33, 0xFF, 0x00},
+	{VIACR, CR55, 0x80, 0x00},
+	{VIACR, CR5D, 0x80, 0x00},
+	{VIACR, CR36, 0xFF, 0x01},	/* Power Mangement 3                  */
+	{VIACR, CR62, 0xFF, 0x00},	/* Secondary Display Starting Address */
+	{VIACR, CR63, 0xFF, 0x00},	/* Secondary Display Starting Address */
+	{VIACR, CR64, 0xFF, 0x00},	/* Secondary Display Starting Address */
+	{VIACR, CR68, 0xFF, 0x67},	/* Default FIFO For IGA2              */
+	{VIACR, CR6A, 0x20, 0x20},	/* Extended FIFO On                   */
+	{VIACR, CR7A, 0xFF, 0x01},	/* LCD Scaling Parameter 1            */
+	{VIACR, CR7B, 0xFF, 0x02},	/* LCD Scaling Parameter 2            */
+	{VIACR, CR7C, 0xFF, 0x03},	/* LCD Scaling Parameter 3            */
+	{VIACR, CR7D, 0xFF, 0x04},	/* LCD Scaling Parameter 4            */
+	{VIACR, CR7E, 0xFF, 0x07},	/* LCD Scaling Parameter 5            */
+	{VIACR, CR7F, 0xFF, 0x0A},	/* LCD Scaling Parameter 6            */
+	{VIACR, CR80, 0xFF, 0x0D},	/* LCD Scaling Parameter 7            */
+	{VIACR, CR81, 0xFF, 0x13},	/* LCD Scaling Parameter 8            */
+	{VIACR, CR82, 0xFF, 0x16},	/* LCD Scaling Parameter 9            */
+	{VIACR, CR83, 0xFF, 0x19},	/* LCD Scaling Parameter 10           */
+	{VIACR, CR84, 0xFF, 0x1C},	/* LCD Scaling Parameter 11           */
+	{VIACR, CR85, 0xFF, 0x1D},	/* LCD Scaling Parameter 12           */
+	{VIACR, CR86, 0xFF, 0x1E},	/* LCD Scaling Parameter 13           */
+	{VIACR, CR87, 0xFF, 0x1F},	/* LCD Scaling Parameter 14           */
+	{VIACR, CR88, 0xFF, 0x40},	/* LCD Panel Type                     */
+	{VIACR, CR89, 0xFF, 0x00},	/* LCD Timing Control 0               */
+	{VIACR, CR8A, 0xFF, 0x88},	/* LCD Timing Control 1               */
+	{VIACR, CR8B, 0xFF, 0x2D},	/* LCD Power Sequence Control 0       */
+	{VIACR, CR8C, 0xFF, 0x2D},	/* LCD Power Sequence Control 1       */
+	{VIACR, CR8D, 0xFF, 0xC8},	/* LCD Power Sequence Control 2       */
+	{VIACR, CR8E, 0xFF, 0x36},	/* LCD Power Sequence Control 3       */
+	{VIACR, CR8F, 0xFF, 0x00},	/* LCD Power Sequence Control 4       */
+	{VIACR, CR90, 0xFF, 0x10},	/* LCD Power Sequence Control 5       */
+	{VIACR, CR91, 0xFF, 0xA0},	/* 24/12 bit LVDS Data off            */
+	{VIACR, CR96, 0xFF, 0x03},	/* DVP0        ; DVP0 Clock Skew */
+	{VIACR, CR97, 0xFF, 0x03},	/* DFP high    ; DFPH Clock Skew */
+	{VIACR, CR99, 0xFF, 0x03},	/* DFP low           ; DFPL Clock Skew*/
+	{VIACR, CR9B, 0xFF, 0x07}	/* DVI on DVP1       ; DVP1 Clock Skew*/
+};
+
+/* For VT3324: Common Setting for Video Mode */
+struct io_reg CX700_ModeXregs[] = { {VIASR, SR10, 0xFF, 0x01},
+{VIASR, SR15, 0x02, 0x02},
+{VIASR, SR16, 0xBF, 0x08},
+{VIASR, SR17, 0xFF, 0x1F},
+{VIASR, SR18, 0xFF, 0x4E},
+{VIASR, SR1A, 0xFB, 0x08},
+{VIASR, SR1B, 0xFF, 0xF0},
+{VIASR, SR1E, 0xFF, 0x01},
+{VIASR, SR2A, 0xFF, 0x00},
+{VIASR, SR2D, 0xFF, 0xFF},	/* VCK and LCK PLL power on.           */
+{VIACR, CR0A, 0xFF, 0x1E},	/* Cursor Start                        */
+{VIACR, CR0B, 0xFF, 0x00},	/* Cursor End                          */
+{VIACR, CR0E, 0xFF, 0x00},	/* Cursor Location High                */
+{VIACR, CR0F, 0xFF, 0x00},	/* Cursor Localtion Low                */
+{VIACR, CR32, 0xFF, 0x00},
+{VIACR, CR33, 0xFF, 0x00},
+{VIACR, CR34, 0xFF, 0x00},
+{VIACR, CR35, 0xFF, 0x00},
+{VIACR, CR36, 0x08, 0x00},
+{VIACR, CR47, 0xC8, 0x00},	/* Clear VCK Plus. */
+{VIACR, CR62, 0xFF, 0x00},	/* Secondary Display Starting Address  */
+{VIACR, CR63, 0xFF, 0x00},	/* Secondary Display Starting Address  */
+{VIACR, CR64, 0xFF, 0x00},	/* Secondary Display Starting Address  */
+{VIACR, CRA3, 0xFF, 0x00},	/* Secondary Display Starting Address  */
+{VIACR, CR69, 0xFF, 0x00},
+{VIACR, CR6A, 0xFF, 0x40},
+{VIACR, CR6B, 0xFF, 0x00},
+{VIACR, CR6C, 0xFF, 0x00},
+{VIACR, CR7A, 0xFF, 0x01},	/* LCD Scaling Parameter 1             */
+{VIACR, CR7B, 0xFF, 0x02},	/* LCD Scaling Parameter 2             */
+{VIACR, CR7C, 0xFF, 0x03},	/* LCD Scaling Parameter 3             */
+{VIACR, CR7D, 0xFF, 0x04},	/* LCD Scaling Parameter 4             */
+{VIACR, CR7E, 0xFF, 0x07},	/* LCD Scaling Parameter 5             */
+{VIACR, CR7F, 0xFF, 0x0A},	/* LCD Scaling Parameter 6             */
+{VIACR, CR80, 0xFF, 0x0D},	/* LCD Scaling Parameter 7             */
+{VIACR, CR81, 0xFF, 0x13},	/* LCD Scaling Parameter 8             */
+{VIACR, CR82, 0xFF, 0x16},	/* LCD Scaling Parameter 9             */
+{VIACR, CR83, 0xFF, 0x19},	/* LCD Scaling Parameter 10            */
+{VIACR, CR84, 0xFF, 0x1C},	/* LCD Scaling Parameter 11            */
+{VIACR, CR85, 0xFF, 0x1D},	/* LCD Scaling Parameter 12            */
+{VIACR, CR86, 0xFF, 0x1E},	/* LCD Scaling Parameter 13            */
+{VIACR, CR87, 0xFF, 0x1F},	/* LCD Scaling Parameter 14            */
+{VIACR, CR88, 0xFF, 0x40},	/* LCD Panel Type                      */
+{VIACR, CR89, 0xFF, 0x00},	/* LCD Timing Control 0                */
+{VIACR, CR8A, 0xFF, 0x88},	/* LCD Timing Control 1                */
+{VIACR, CRD4, 0xFF, 0x81},	/* Second power sequence control       */
+{VIACR, CR8B, 0xFF, 0x5D},	/* LCD Power Sequence Control 0        */
+{VIACR, CR8C, 0xFF, 0x2B},	/* LCD Power Sequence Control 1        */
+{VIACR, CR8D, 0xFF, 0x6F},	/* LCD Power Sequence Control 2        */
+{VIACR, CR8E, 0xFF, 0x2B},	/* LCD Power Sequence Control 3        */
+{VIACR, CR8F, 0xFF, 0x01},	/* LCD Power Sequence Control 4        */
+{VIACR, CR90, 0xFF, 0x01},	/* LCD Power Sequence Control 5        */
+{VIACR, CR91, 0xFF, 0x80},	/* 24/12 bit LVDS Data off             */
+{VIACR, CR96, 0xFF, 0x00},
+{VIACR, CR97, 0xFF, 0x00},
+{VIACR, CR99, 0xFF, 0x00},
+{VIACR, CR9B, 0xFF, 0x00},
+{VIACR, CRD2, 0xFF, 0xFF}	/* TMDS/LVDS control register.         */
+};
+
+/* For VT3353: Common Setting for Video Mode */
+struct io_reg VX800_ModeXregs[] = { {VIASR, SR10, 0xFF, 0x01},
+{VIASR, SR15, 0x02, 0x02},
+{VIASR, SR16, 0xBF, 0x08},
+{VIASR, SR17, 0xFF, 0x1F},
+{VIASR, SR18, 0xFF, 0x4E},
+{VIASR, SR1A, 0xFB, 0x08},
+{VIASR, SR1B, 0xFF, 0xF0},
+{VIASR, SR1E, 0xFF, 0x01},
+{VIASR, SR2A, 0xFF, 0x00},
+{VIASR, SR2D, 0xFF, 0xFF},	/* VCK and LCK PLL power on.           */
+{VIACR, CR0A, 0xFF, 0x1E},	/* Cursor Start                        */
+{VIACR, CR0B, 0xFF, 0x00},	/* Cursor End                          */
+{VIACR, CR0E, 0xFF, 0x00},	/* Cursor Location High                */
+{VIACR, CR0F, 0xFF, 0x00},	/* Cursor Localtion Low                */
+{VIACR, CR32, 0xFF, 0x00},
+{VIACR, CR33, 0xFF, 0x00},
+{VIACR, CR34, 0xFF, 0x00},
+{VIACR, CR35, 0xFF, 0x00},
+{VIACR, CR36, 0x08, 0x00},
+{VIACR, CR47, 0xC8, 0x00},	/* Clear VCK Plus. */
+{VIACR, CR62, 0xFF, 0x00},	/* Secondary Display Starting Address  */
+{VIACR, CR63, 0xFF, 0x00},	/* Secondary Display Starting Address  */
+{VIACR, CR64, 0xFF, 0x00},	/* Secondary Display Starting Address  */
+{VIACR, CRA3, 0xFF, 0x00},	/* Secondary Display Starting Address  */
+{VIACR, CR69, 0xFF, 0x00},
+{VIACR, CR6A, 0xFF, 0x40},
+{VIACR, CR6B, 0xFF, 0x00},
+{VIACR, CR6C, 0xFF, 0x00},
+{VIACR, CR7A, 0xFF, 0x01},	/* LCD Scaling Parameter 1             */
+{VIACR, CR7B, 0xFF, 0x02},	/* LCD Scaling Parameter 2             */
+{VIACR, CR7C, 0xFF, 0x03},	/* LCD Scaling Parameter 3             */
+{VIACR, CR7D, 0xFF, 0x04},	/* LCD Scaling Parameter 4             */
+{VIACR, CR7E, 0xFF, 0x07},	/* LCD Scaling Parameter 5             */
+{VIACR, CR7F, 0xFF, 0x0A},	/* LCD Scaling Parameter 6             */
+{VIACR, CR80, 0xFF, 0x0D},	/* LCD Scaling Parameter 7             */
+{VIACR, CR81, 0xFF, 0x13},	/* LCD Scaling Parameter 8             */
+{VIACR, CR82, 0xFF, 0x16},	/* LCD Scaling Parameter 9             */
+{VIACR, CR83, 0xFF, 0x19},	/* LCD Scaling Parameter 10            */
+{VIACR, CR84, 0xFF, 0x1C},	/* LCD Scaling Parameter 11            */
+{VIACR, CR85, 0xFF, 0x1D},	/* LCD Scaling Parameter 12            */
+{VIACR, CR86, 0xFF, 0x1E},	/* LCD Scaling Parameter 13            */
+{VIACR, CR87, 0xFF, 0x1F},	/* LCD Scaling Parameter 14            */
+{VIACR, CR88, 0xFF, 0x40},	/* LCD Panel Type                      */
+{VIACR, CR89, 0xFF, 0x00},	/* LCD Timing Control 0                */
+{VIACR, CR8A, 0xFF, 0x88},	/* LCD Timing Control 1                */
+{VIACR, CRD4, 0xFF, 0x81},	/* Second power sequence control       */
+{VIACR, CR8B, 0xFF, 0x5D},	/* LCD Power Sequence Control 0        */
+{VIACR, CR8C, 0xFF, 0x2B},	/* LCD Power Sequence Control 1        */
+{VIACR, CR8D, 0xFF, 0x6F},	/* LCD Power Sequence Control 2        */
+{VIACR, CR8E, 0xFF, 0x2B},	/* LCD Power Sequence Control 3        */
+{VIACR, CR8F, 0xFF, 0x01},	/* LCD Power Sequence Control 4        */
+{VIACR, CR90, 0xFF, 0x01},	/* LCD Power Sequence Control 5        */
+{VIACR, CR91, 0xFF, 0x80},	/* 24/12 bit LVDS Data off             */
+{VIACR, CR96, 0xFF, 0x00},
+{VIACR, CR97, 0xFF, 0x00},
+{VIACR, CR99, 0xFF, 0x00},
+{VIACR, CR9B, 0xFF, 0x00},
+{VIACR, CRD2, 0xFF, 0xFF}	/* TMDS/LVDS control register.         */
+};
+
+/* Video Mode Table */
+/* Common Setting for Video Mode */
+struct io_reg CLE266_ModeXregs[] = { {VIASR, SR1E, 0xF0, 0x00},
+{VIASR, SR2A, 0x0F, 0x00},
+{VIASR, SR15, 0x02, 0x02},
+{VIASR, SR16, 0xBF, 0x08},
+{VIASR, SR17, 0xFF, 0x1F},
+{VIASR, SR18, 0xFF, 0x4E},
+{VIASR, SR1A, 0xFB, 0x08},
+
+{VIACR, CR32, 0xFF, 0x00},
+{VIACR, CR34, 0xFF, 0x00},
+{VIACR, CR35, 0xFF, 0x00},
+{VIACR, CR36, 0x08, 0x00},
+{VIACR, CR6A, 0xFF, 0x80},
+{VIACR, CR6A, 0xFF, 0xC0},
+
+{VIACR, CR55, 0x80, 0x00},
+{VIACR, CR5D, 0x80, 0x00},
+
+{VIAGR, GR20, 0xFF, 0x00},
+{VIAGR, GR21, 0xFF, 0x00},
+{VIAGR, GR22, 0xFF, 0x00},
+	/* LCD Parameters */
+{VIACR, CR7A, 0xFF, 0x01},	/* LCD Parameter 1 */
+{VIACR, CR7B, 0xFF, 0x02},	/* LCD Parameter 2 */
+{VIACR, CR7C, 0xFF, 0x03},	/* LCD Parameter 3 */
+{VIACR, CR7D, 0xFF, 0x04},	/* LCD Parameter 4 */
+{VIACR, CR7E, 0xFF, 0x07},	/* LCD Parameter 5 */
+{VIACR, CR7F, 0xFF, 0x0A},	/* LCD Parameter 6 */
+{VIACR, CR80, 0xFF, 0x0D},	/* LCD Parameter 7 */
+{VIACR, CR81, 0xFF, 0x13},	/* LCD Parameter 8 */
+{VIACR, CR82, 0xFF, 0x16},	/* LCD Parameter 9 */
+{VIACR, CR83, 0xFF, 0x19},	/* LCD Parameter 10 */
+{VIACR, CR84, 0xFF, 0x1C},	/* LCD Parameter 11 */
+{VIACR, CR85, 0xFF, 0x1D},	/* LCD Parameter 12 */
+{VIACR, CR86, 0xFF, 0x1E},	/* LCD Parameter 13 */
+{VIACR, CR87, 0xFF, 0x1F},	/* LCD Parameter 14 */
+
+};
+
+/* Mode:1024X768 */
+struct io_reg PM1024x768[] = { {VIASR, 0x16, 0xBF, 0x0C},
+{VIASR, 0x18, 0xFF, 0x4C}
+};
+
+struct patch_table res_patch_table[] = {
+	{VIA_RES_1024X768, ARRAY_SIZE(PM1024x768), PM1024x768}
+};
+
+/* struct VPITTable {
+	unsigned char  Misc;
+	unsigned char  SR[StdSR];
+	unsigned char  CR[StdCR];
+	unsigned char  GR[StdGR];
+	unsigned char  AR[StdAR];
+ };*/
+
+struct VPITTable VPIT = {
+	/* Msic */
+	0xC7,
+	/* Sequencer */
+	{0x01, 0x0F, 0x00, 0x0E},
+	/* Graphic Controller */
+	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x0F, 0xFF},
+	/* Attribute Controller */
+	{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+	 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
+	 0x01, 0x00, 0x0F, 0x00}
+};
+
+/********************/
+/* Mode Table       */
+/********************/
+
+/* 480x640 */
+struct crt_mode_table CRTM480x640[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_25_175M, M480X640_R60_HSP, M480X640_R60_VSP,
+	 {624, 480, 480, 144, 504, 48, 663, 640, 640, 23, 641, 3} }	/* GTF*/
+};
+
+/* 640x480*/
+struct crt_mode_table CRTM640x480[] = {
+	/*r_rate,vclk,hsp,vsp */
+	/*HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_25_175M, M640X480_R60_HSP, M640X480_R60_VSP,
+	 {800, 640, 648, 144, 656, 96, 525, 480, 480, 45, 490, 2} },
+	{REFRESH_75, CLK_31_500M, M640X480_R75_HSP, M640X480_R75_VSP,
+	 {840, 640, 640, 200, 656, 64, 500, 480, 480, 20, 481, 3} },
+	{REFRESH_85, CLK_36_000M, M640X480_R85_HSP, M640X480_R85_VSP,
+	 {832, 640, 640, 192, 696, 56, 509, 480, 480, 29, 481, 3} },
+	{REFRESH_100, CLK_43_163M, M640X480_R100_HSP, M640X480_R100_VSP,
+	 {848, 640, 640, 208, 680, 64, 509, 480, 480, 29, 481, 3} }, /*GTF*/
+	    {REFRESH_120, CLK_52_406M, M640X480_R120_HSP,
+	     M640X480_R120_VSP,
+	     {848, 640, 640, 208, 680, 64, 515, 480, 480, 35, 481,
+	      3} } /*GTF*/
+};
+
+/*720x480 (GTF)*/
+struct crt_mode_table CRTM720x480[] = {
+	/*r_rate,vclk,hsp,vsp      */
+	/*HT, HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_26_880M, M720X480_R60_HSP, M720X480_R60_VSP,
+	 {896, 720, 720, 176, 736, 72, 497, 480, 480, 17, 481, 3} }
+
+};
+
+/*720x576 (GTF)*/
+struct crt_mode_table CRTM720x576[] = {
+	/*r_rate,vclk,hsp,vsp */
+	/*HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_32_668M, M720X576_R60_HSP, M720X576_R60_VSP,
+	 {912, 720, 720, 192, 744, 72, 597, 576, 576, 21, 577, 3} }
+};
+
+/* 800x480 (CVT) */
+struct crt_mode_table CRTM800x480[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_29_581M, M800X480_R60_HSP, M800X480_R60_VSP,
+	 {992, 800, 800, 192, 824, 72, 500, 480, 480, 20, 483, 7} }
+};
+
+/* 800x600*/
+struct crt_mode_table CRTM800x600[] = {
+	/*r_rate,vclk,hsp,vsp     */
+	/*HT,   HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_40_000M, M800X600_R60_HSP, M800X600_R60_VSP,
+	 {1056, 800, 800, 256, 840, 128, 628, 600, 600, 28, 601, 4} },
+	{REFRESH_75, CLK_49_500M, M800X600_R75_HSP, M800X600_R75_VSP,
+	 {1056, 800, 800, 256, 816, 80, 625, 600, 600, 25, 601, 3} },
+	{REFRESH_85, CLK_56_250M, M800X600_R85_HSP, M800X600_R85_VSP,
+	 {1048, 800, 800, 248, 832, 64, 631, 600, 600, 31, 601, 3} },
+	{REFRESH_100, CLK_68_179M, M800X600_R100_HSP, M800X600_R100_VSP,
+	 {1072, 800, 800, 272, 848, 88, 636, 600, 600, 36, 601, 3} },
+	{REFRESH_120, CLK_83_950M, M800X600_R120_HSP,
+		  M800X600_R120_VSP,
+		  {1088, 800, 800, 288, 856, 88, 643, 600, 600, 43, 601,
+		   3} }
+};
+
+/* 848x480 (CVT) */
+struct crt_mode_table CRTM848x480[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_31_500M, M848X480_R60_HSP, M848X480_R60_VSP,
+	 {1056, 848, 848, 208, 872, 80, 500, 480, 480, 20, 483, 5} }
+};
+
+/*856x480 (GTF) convert to 852x480*/
+struct crt_mode_table CRTM852x480[] = {
+	/*r_rate,vclk,hsp,vsp     */
+	/*HT,   HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_31_728M, M852X480_R60_HSP, M852X480_R60_VSP,
+	{1064, 856, 856, 208, 872, 88, 497, 480, 480, 17, 481, 3} }
+};
+
+/*1024x512 (GTF)*/
+struct crt_mode_table CRTM1024x512[] = {
+	/*r_rate,vclk,hsp,vsp     */
+	/*HT,   HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_41_291M, M1024X512_R60_HSP, M1024X512_R60_VSP,
+	 {1296, 1024, 1024, 272, 1056, 104, 531, 512, 512, 19, 513, 3} }
+
+};
+
+/* 1024x600*/
+struct crt_mode_table CRTM1024x600[] = {
+	/*r_rate,vclk,hsp,vsp */
+	/*HT,  HA,   HBS,  HBE, HSS,  HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_48_875M, M1024X600_R60_HSP, M1024X600_R60_VSP,
+	 {1312, 1024, 1024, 288, 1064, 104, 622, 600, 600, 22, 601, 3} },
+};
+
+/* 1024x768*/
+struct crt_mode_table CRTM1024x768[] = {
+	/*r_rate,vclk,hsp,vsp */
+	/*HT,  HA,   HBS,  HBE, HSS,  HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_65_000M, M1024X768_R60_HSP, M1024X768_R60_VSP,
+	{1344, 1024, 1024, 320, 1048, 136, 806, 768, 768, 38, 771, 6} },
+	{REFRESH_75, CLK_78_750M, M1024X768_R75_HSP, M1024X768_R75_VSP,
+	{1312, 1024, 1024, 288, 1040, 96, 800, 768, 768, 32, 769, 3} },
+	{REFRESH_85, CLK_94_500M, M1024X768_R85_HSP, M1024X768_R85_VSP,
+	{1376, 1024, 1024, 352, 1072, 96, 808, 768, 768, 40, 769, 3} },
+	{REFRESH_100, CLK_113_309M, M1024X768_R100_HSP, M1024X768_R100_VSP,
+	{1392, 1024, 1024, 368, 1096, 112, 814, 768, 768, 46, 769, 3} }
+};
+
+/* 1152x864*/
+struct crt_mode_table CRTM1152x864[] = {
+	/*r_rate,vclk,hsp,vsp      */
+	/*HT,  HA,   HBS,  HBE, HSS,  HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_75, CLK_108_000M, M1152X864_R75_HSP, M1152X864_R75_VSP,
+	 {1600, 1152, 1152, 448, 1216, 128, 900, 864, 864, 36, 865, 3} }
+
+};
+
+/* 1280x720 (HDMI 720P)*/
+struct crt_mode_table CRTM1280x720[] = {
+	/*r_rate,vclk,hsp,vsp */
+	/*HT,  HA,   HBS,  HBE, HSS,  HSE, VT,  VA,  VBS, VBE, VSS, VSE      */
+	{REFRESH_60, CLK_74_481M, M1280X720_R60_HSP, M1280X720_R60_VSP,
+	 {1648, 1280, 1280, 368, 1392, 40, 750, 720, 720, 30, 725, 5} },
+	{REFRESH_50, CLK_60_466M, M1280X720_R50_HSP, M1280X720_R50_VSP,
+	 {1632, 1280, 1280, 352, 1328, 128, 741, 720, 720, 21, 721, 3} }
+};
+
+/*1280x768 (GTF)*/
+struct crt_mode_table CRTM1280x768[] = {
+	/*r_rate,vclk,hsp,vsp     */
+	/*HT,  HA,   HBS,  HBE, HSS,  HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_80_136M, M1280X768_R60_HSP, M1280X768_R60_VSP,
+	 {1680, 1280, 1280, 400, 1344, 136, 795, 768, 768, 27, 769, 3} },
+	{REFRESH_50, CLK_65_178M, M1280X768_R50_HSP, M1280X768_R50_VSP,
+	 {1648, 1280, 1280, 368, 1336, 128, 791, 768, 768, 23, 769, 3} }
+};
+
+/* 1280x800 (CVT) */
+struct crt_mode_table CRTM1280x800[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_83_375M, M1280X800_R60_HSP, M1280X800_R60_VSP,
+	 {1680, 1280, 1280, 400, 1352, 128, 831, 800, 800, 31, 803, 6} }
+};
+
+/*1280x960*/
+struct crt_mode_table CRTM1280x960[] = {
+	/*r_rate,vclk,hsp,vsp */
+	/*HT,  HA,   HBS,  HBE, HSS,  HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_108_000M, M1280X960_R60_HSP, M1280X960_R60_VSP,
+	 {1800, 1280, 1280, 520, 1376, 112, 1000, 960, 960, 40, 961, 3} }
+};
+
+/* 1280x1024*/
+struct crt_mode_table CRTM1280x1024[] = {
+	/*r_rate,vclk,,hsp,vsp */
+	/*HT,  HA,   HBS,  HBE, HSS,  HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_108_000M, M1280X1024_R60_HSP, M1280X1024_R60_VSP,
+	 {1688, 1280, 1280, 408, 1328, 112, 1066, 1024, 1024, 42, 1025,
+	  3} },
+	{REFRESH_75, CLK_135_000M, M1280X1024_R75_HSP, M1280X1024_R75_VSP,
+	 {1688, 1280, 1280, 408, 1296, 144, 1066, 1024, 1024, 42, 1025,
+	  3} },
+	{REFRESH_85, CLK_157_500M, M1280X1024_R85_HSP, M1280X1024_R85_VSP,
+	 {1728, 1280, 1280, 448, 1344, 160, 1072, 1024, 1024, 48, 1025, 3} }
+};
+
+/* 1368x768 (GTF) */
+struct crt_mode_table CRTM1368x768[] = {
+	/* r_rate,  vclk, hsp, vsp */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_85_860M, M1368X768_R60_HSP, M1368X768_R60_VSP,
+	 {1800, 1368, 1368, 432, 1440, 144, 795, 768, 768, 27, 769, 3} }
+};
+
+/*1440x1050 (GTF)*/
+struct crt_mode_table CRTM1440x1050[] = {
+	/*r_rate,vclk,hsp,vsp      */
+	/*HT,  HA,   HBS,  HBE, HSS,  HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_125_104M, M1440X1050_R60_HSP, M1440X1050_R60_VSP,
+	 {1936, 1440, 1440, 496, 1536, 152, 1077, 1040, 1040, 37, 1041, 3} }
+};
+
+/* 1600x1200*/
+struct crt_mode_table CRTM1600x1200[] = {
+	/*r_rate,vclk,hsp,vsp */
+	/*HT,  HA,   HBS,  HBE, HSS,  HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_162_000M, M1600X1200_R60_HSP, M1600X1200_R60_VSP,
+	 {2160, 1600, 1600, 560, 1664, 192, 1250, 1200, 1200, 50, 1201,
+	  3} },
+	{REFRESH_75, CLK_202_500M, M1600X1200_R75_HSP, M1600X1200_R75_VSP,
+	 {2160, 1600, 1600, 560, 1664, 192, 1250, 1200, 1200, 50, 1201, 3} }
+
+};
+
+/* 1680x1050 (CVT) */
+struct crt_mode_table CRTM1680x1050[] = {
+	/* r_rate,          vclk,              hsp,             vsp  */
+	/* HT,  HA,  HBS, HBE, HSS, HSE,    VT,  VA,  VBS, VBE,  VSS, VSE */
+	{REFRESH_60, CLK_146_760M, M1680x1050_R60_HSP, M1680x1050_R60_VSP,
+	 {2240, 1680, 1680, 560, 1784, 176, 1089, 1050, 1050, 39, 1053,
+	  6} },
+	{REFRESH_75, CLK_187_000M, M1680x1050_R75_HSP, M1680x1050_R75_VSP,
+	 {2272, 1680, 1680, 592, 1800, 176, 1099, 1050, 1050, 49, 1053, 6} }
+};
+
+/* 1680x1050 (CVT Reduce Blanking) */
+struct crt_mode_table CRTM1680x1050_RB[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE,    VT,  VA,  VBS, VBE,  VSS, VSE */
+	{REFRESH_60, CLK_119_000M, M1680x1050_RB_R60_HSP,
+	 M1680x1050_RB_R60_VSP,
+	 {1840, 1680, 1680, 160, 1728, 32, 1080, 1050, 1050, 30, 1053, 6} }
+};
+
+/* 1920x1080 (CVT)*/
+struct crt_mode_table CRTM1920x1080[] = {
+	/*r_rate,vclk,hsp,vsp */
+	/*HT,  HA,   HBS,  HBE, HSS,  HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_172_798M, M1920X1080_R60_HSP, M1920X1080_R60_VSP,
+	 {2576, 1920, 1920, 656, 2048, 200, 1120, 1080, 1080, 40, 1083, 5} }
+};
+
+/* 1920x1080 (CVT with Reduce Blanking) */
+struct crt_mode_table CRTM1920x1080_RB[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_138_400M, M1920X1080_RB_R60_HSP,
+	 M1920X1080_RB_R60_VSP,
+	 {2080, 1920, 1920, 160, 1968, 32, 1111, 1080, 1080, 31, 1083, 5} }
+};
+
+/* 1920x1440*/
+struct crt_mode_table CRTM1920x1440[] = {
+	/*r_rate,vclk,hsp,vsp */
+	/*HT,  HA,   HBS,  HBE, HSS,  HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_234_000M, M1920X1440_R60_HSP, M1920X1440_R60_VSP,
+	 {2600, 1920, 1920, 680, 2048, 208, 1500, 1440, 1440, 60, 1441,
+	  3} },
+	{REFRESH_75, CLK_297_500M, M1920X1440_R75_HSP, M1920X1440_R75_VSP,
+	 {2640, 1920, 1920, 720, 2064, 224, 1500, 1440, 1440, 60, 1441, 3} }
+};
+
+/* 1400x1050 (CVT) */
+struct crt_mode_table CRTM1400x1050[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE,  HSS, HSE,   VT,  VA,  VBS, VBE,  VSS, VSE */
+	{REFRESH_60, CLK_121_750M, M1400X1050_R60_HSP, M1400X1050_R60_VSP,
+	 {1864, 1400, 1400, 464, 1488, 144, 1089, 1050, 1050, 39, 1053,
+	  4} },
+	{REFRESH_75, CLK_156_000M, M1400X1050_R75_HSP, M1400X1050_R75_VSP,
+	 {1896, 1400, 1400, 496, 1504, 144, 1099, 1050, 1050, 49, 1053, 4} }
+};
+
+/* 1400x1050 (CVT Reduce Blanking) */
+struct crt_mode_table CRTM1400x1050_RB[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE,  HSS, HSE,   VT,  VA,  VBS, VBE,  VSS, VSE */
+	{REFRESH_60, CLK_101_000M, M1400X1050_RB_R60_HSP,
+	 M1400X1050_RB_R60_VSP,
+	 {1560, 1400, 1400, 160, 1448, 32, 1080, 1050, 1050, 30, 1053, 4} }
+};
+
+/* 960x600 (CVT) */
+struct crt_mode_table CRTM960x600[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_45_250M, M960X600_R60_HSP, M960X600_R60_VSP,
+	 {1216, 960, 960, 256, 992, 96, 624, 600, 600, 24, 603, 6} }
+};
+
+/* 1000x600 (GTF) */
+struct crt_mode_table CRTM1000x600[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_48_000M, M1000X600_R60_HSP, M1000X600_R60_VSP,
+	 {1288, 1000, 1000, 288, 1040, 104, 622, 600, 600, 22, 601, 3} }
+};
+
+/* 1024x576 (GTF) */
+struct crt_mode_table CRTM1024x576[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_46_996M, M1024X576_R60_HSP, M1024X576_R60_VSP,
+	 {1312, 1024, 1024, 288, 1064, 104, 597, 576, 576, 21, 577, 3} }
+};
+
+/* 1088x612 (CVT) */
+struct crt_mode_table CRTM1088x612[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_52_977M, M1088X612_R60_HSP, M1088X612_R60_VSP,
+	 {1392, 1088, 1088, 304, 1136, 104, 636, 612, 612, 24, 615, 5} }
+};
+
+/* 1152x720 (CVT) */
+struct crt_mode_table CRTM1152x720[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_66_750M, M1152X720_R60_HSP, M1152X720_R60_VSP,
+	 {1488, 1152, 1152, 336, 1208, 112, 748, 720, 720, 28, 723, 6} }
+};
+
+/* 1200x720 (GTF) */
+struct crt_mode_table CRTM1200x720[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_70_159M, M1200X720_R60_HSP, M1200X720_R60_VSP,
+	 {1568, 1200, 1200, 368, 1256, 128, 746, 720, 720, 26, 721, 3} }
+};
+
+/* 1280x600 (GTF) */
+struct crt_mode_table CRTM1280x600[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE,  HSS, HSE, VT,  VA,  VBS, VBE,  VSS, VSE */
+	{REFRESH_60, CLK_61_500M, M1280x600_R60_HSP, M1280x600_R60_VSP,
+	 {1648, 1280, 1280, 368, 1336, 128, 622, 600, 600, 22, 601, 3} }
+};
+
+/* 1360x768 (CVT) */
+struct crt_mode_table CRTM1360x768[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_84_750M, M1360X768_R60_HSP, M1360X768_R60_VSP,
+	 {1776, 1360, 1360, 416, 1432, 136, 798, 768, 768, 30, 771, 5} }
+};
+
+/* 1360x768 (CVT Reduce Blanking) */
+struct crt_mode_table CRTM1360x768_RB[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_72_000M, M1360X768_RB_R60_HSP,
+	 M1360X768_RB_R60_VSP,
+	 {1520, 1360, 1360, 160, 1408, 32, 790, 768, 768, 22, 771, 5} }
+};
+
+/* 1366x768 (GTF) */
+struct crt_mode_table CRTM1366x768[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_85_860M, M1368X768_R60_HSP, M1368X768_R60_VSP,
+	 {1800, 1368, 1368, 432, 1440, 144, 795, 768, 768, 27, 769, 3} },
+	{REFRESH_50, CLK_69_924M, M1368X768_R50_HSP, M1368X768_R50_VSP,
+	 {1768, 1368, 1368, 400, 1424, 144, 791, 768, 768, 23, 769, 3} }
+};
+
+/* 1440x900 (CVT) */
+struct crt_mode_table CRTM1440x900[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_106_500M, M1440X900_R60_HSP, M1440X900_R60_VSP,
+	 {1904, 1440, 1440, 464, 1520, 152, 934, 900, 900, 34, 903, 6} },
+	{REFRESH_75, CLK_136_700M, M1440X900_R75_HSP, M1440X900_R75_VSP,
+	 {1936, 1440, 1440, 496, 1536, 152, 942, 900, 900, 42, 903, 6} }
+};
+
+/* 1440x900 (CVT Reduce Blanking) */
+struct crt_mode_table CRTM1440x900_RB[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_88_750M, M1440X900_RB_R60_HSP,
+	 M1440X900_RB_R60_VSP,
+	 {1600, 1440, 1440, 160, 1488, 32, 926, 900, 900, 26, 903, 6} }
+};
+
+/* 1600x900 (CVT) */
+struct crt_mode_table CRTM1600x900[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_118_840M, M1600X900_R60_HSP, M1600X900_R60_VSP,
+	 {2112, 1600, 1600, 512, 1688, 168, 934, 900, 900, 34, 903, 5} }
+};
+
+/* 1600x900 (CVT Reduce Blanking) */
+struct crt_mode_table CRTM1600x900_RB[] = {
+	/* r_rate,        vclk,           hsp,        vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_97_750M, M1600X900_RB_R60_HSP,
+	 M1600X900_RB_R60_VSP,
+	 {1760, 1600, 1600, 160, 1648, 32, 926, 900, 900, 26, 903, 5} }
+};
+
+/* 1600x1024 (GTF) */
+struct crt_mode_table CRTM1600x1024[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE,  HSS, HSE,   VT,  VA,  VBS, VBE,  VSS, VSE */
+	{REFRESH_60, CLK_136_700M, M1600X1024_R60_HSP, M1600X1024_R60_VSP,
+	 {2144, 1600, 1600, 544, 1704, 168, 1060, 1024, 1024, 36, 1025, 3} }
+};
+
+/* 1792x1344 (DMT) */
+struct crt_mode_table CRTM1792x1344[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE,  HSS, HSE,   VT,  VA,  VBS, VBE,  VSS, VSE */
+	{REFRESH_60, CLK_204_000M, M1792x1344_R60_HSP, M1792x1344_R60_VSP,
+	 {2448, 1792, 1792, 656, 1920, 200, 1394, 1344, 1344, 50, 1345, 3} }
+};
+
+/* 1856x1392 (DMT) */
+struct crt_mode_table CRTM1856x1392[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE,  HSS, HSE,   VT,  VA,  VBS, VBE,  VSS, VSE */
+	{REFRESH_60, CLK_218_500M, M1856x1392_R60_HSP, M1856x1392_R60_VSP,
+	 {2528, 1856, 1856, 672, 1952, 224, 1439, 1392, 1392, 47, 1393, 3} }
+};
+
+/* 1920x1200 (CVT) */
+struct crt_mode_table CRTM1920x1200[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_193_295M, M1920X1200_R60_HSP, M1920X1200_R60_VSP,
+	 {2592, 1920, 1920, 672, 2056, 200, 1245, 1200, 1200, 45, 1203, 6} }
+};
+
+/* 1920x1200 (CVT with Reduce Blanking) */
+struct crt_mode_table CRTM1920x1200_RB[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_153_920M, M1920X1200_RB_R60_HSP,
+	 M1920X1200_RB_R60_VSP,
+	 {2080, 1920, 1920, 160, 1968, 32, 1235, 1200, 1200, 35, 1203, 6} }
+};
+
+/* 2048x1536 (CVT) */
+struct crt_mode_table CRTM2048x1536[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE,  HSS, HSE,   VT,  VA,  VBS, VBE,  VSS, VSE */
+	{REFRESH_60, CLK_267_250M, M2048x1536_R60_HSP, M2048x1536_R60_VSP,
+	 {2800, 2048, 2048, 752, 2200, 224, 1592, 1536, 1536, 56, 1539, 4} }
+};
+
+/* Video Mode Table */
+/* struct VideoModeTable {*/
+/*  int                               ModeIndex;*/
+/*  struct crt_mode_table             *crtc;*/
+/*  int                               mode_array;*/
+/* };*/
+struct VideoModeTable CLE266Modes[] = {
+	/* Display : 480x640 (GTF) */
+	{VIA_RES_480X640, CRTM480x640, ARRAY_SIZE(CRTM480x640)},
+
+	/* Display : 640x480 */
+	{VIA_RES_640X480, CRTM640x480, ARRAY_SIZE(CRTM640x480)},
+
+	/* Display : 720x480 (GTF) */
+	{VIA_RES_720X480, CRTM720x480, ARRAY_SIZE(CRTM720x480)},
+
+	/* Display : 720x576 (GTF) */
+	{VIA_RES_720X576, CRTM720x576, ARRAY_SIZE(CRTM720x576)},
+
+	/* Display : 800x600 */
+	{VIA_RES_800X600, CRTM800x600, ARRAY_SIZE(CRTM800x600)},
+
+	/* Display : 800x480 (CVT) */
+	{VIA_RES_800X480, CRTM800x480, ARRAY_SIZE(CRTM800x480)},
+
+	/* Display : 848x480 (CVT) */
+	{VIA_RES_848X480, CRTM848x480, ARRAY_SIZE(CRTM848x480)},
+
+	/* Display : 852x480 (GTF) */
+	{VIA_RES_856X480, CRTM852x480, ARRAY_SIZE(CRTM852x480)},
+
+	/* Display : 1024x512 (GTF) */
+	{VIA_RES_1024X512, CRTM1024x512, ARRAY_SIZE(CRTM1024x512)},
+
+	/* Display : 1024x600 */
+	{VIA_RES_1024X600, CRTM1024x600, ARRAY_SIZE(CRTM1024x600)},
+
+	/* Display : 1024x576 (GTF) */
+	/*{ VIA_RES_1024X576, CRTM1024x576, ARRAY_SIZE(CRTM1024x576)}, */
+
+	/* Display : 1024x768 */
+	{VIA_RES_1024X768, CRTM1024x768, ARRAY_SIZE(CRTM1024x768)},
+
+	/* Display : 1152x864 */
+	{VIA_RES_1152X864, CRTM1152x864, ARRAY_SIZE(CRTM1152x864)},
+
+	/* Display : 1280x768 (GTF) */
+	{VIA_RES_1280X768, CRTM1280x768, ARRAY_SIZE(CRTM1280x768)},
+
+	/* Display : 960x600 (CVT) */
+	{VIA_RES_960X600, CRTM960x600, ARRAY_SIZE(CRTM960x600)},
+
+	/* Display : 1000x600 (GTF) */
+	{VIA_RES_1000X600, CRTM1000x600, ARRAY_SIZE(CRTM1000x600)},
+
+	/* Display : 1024x576 (GTF) */
+	{VIA_RES_1024X576, CRTM1024x576, ARRAY_SIZE(CRTM1024x576)},
+
+	/* Display : 1088x612 (GTF) */
+	{VIA_RES_1088X612, CRTM1088x612, ARRAY_SIZE(CRTM1088x612)},
+
+	/* Display : 1152x720 (CVT) */
+	{VIA_RES_1152X720, CRTM1152x720, ARRAY_SIZE(CRTM1152x720)},
+
+	/* Display : 1200x720 (GTF) */
+	{VIA_RES_1200X720, CRTM1200x720, ARRAY_SIZE(CRTM1200x720)},
+
+	/* Display : 1280x600 (GTF) */
+	{VIA_RES_1280X600, CRTM1280x600, ARRAY_SIZE(CRTM1280x600)},
+
+	/* Display : 1280x800 (CVT) */
+	{VIA_RES_1280X800, CRTM1280x800, ARRAY_SIZE(CRTM1280x800)},
+
+	/* Display : 1280x800 (GTF) */
+	/*{ M1280x800, CRTM1280x800, ARRAY_SIZE(CRTM1280x800)}, */
+
+	/* Display : 1280x960 */
+	{VIA_RES_1280X960, CRTM1280x960, ARRAY_SIZE(CRTM1280x960)},
+
+	/* Display : 1280x1024 */
+	{VIA_RES_1280X1024, CRTM1280x1024, ARRAY_SIZE(CRTM1280x1024)},
+
+	/* Display : 1360x768 (CVT) */
+	{VIA_RES_1360X768, CRTM1360x768, ARRAY_SIZE(CRTM1360x768)},
+
+	/* Display : 1360x768 (CVT Reduce Blanking) */
+	{VIA_RES_1360X768_RB, CRTM1360x768_RB,
+	 ARRAY_SIZE(CRTM1360x768_RB)},
+
+	/* Display : 1366x768 */
+	{VIA_RES_1366X768, CRTM1366x768, ARRAY_SIZE(CRTM1366x768)},
+
+	/* Display : 1368x768 (GTF) */
+	/*{ M1368x768,CRTM1368x768,ARRAY_SIZE(CRTM1368x768)}, */
+	/* Display : 1368x768 (GTF) */
+	{VIA_RES_1368X768, CRTM1368x768, ARRAY_SIZE(CRTM1368x768)},
+
+	/* Display : 1440x900 (CVT) */
+	{VIA_RES_1440X900, CRTM1440x900, ARRAY_SIZE(CRTM1440x900)},
+
+	/* Display : 1440x900 (CVT Reduce Blanking) */
+	{VIA_RES_1440X900_RB, CRTM1440x900_RB,
+	 ARRAY_SIZE(CRTM1440x900_RB)},
+
+	/* Display : 1440x1050 (GTF) */
+	{VIA_RES_1440X1050, CRTM1440x1050, ARRAY_SIZE(CRTM1440x1050)},
+
+	/* Display : 1400x1050 (CVT Reduce Blanking) */
+	{VIA_RES_1400X1050_RB, CRTM1400x1050_RB,
+	 ARRAY_SIZE(CRTM1400x1050_RB)},
+
+	/* Display : 1600x900 (CVT) */
+	{VIA_RES_1600X900, CRTM1600x900, ARRAY_SIZE(CRTM1600x900)},
+
+	/* Display : 1600x900 (CVT Reduce Blanking) */
+	{VIA_RES_1600X900_RB, CRTM1600x900_RB,
+	 ARRAY_SIZE(CRTM1600x900_RB)},
+
+	/* Display : 1600x1024 (GTF) */
+	{VIA_RES_1600X1024, CRTM1600x1024, ARRAY_SIZE(CRTM1600x1024)},
+
+	/* Display : 1600x1200 */
+	{VIA_RES_1600X1200, CRTM1600x1200, ARRAY_SIZE(CRTM1600x1200)},
+
+	/* Display : 1680x1050 (CVT) */
+	{VIA_RES_1680X1050, CRTM1680x1050, ARRAY_SIZE(CRTM1680x1050)},
+
+	/* Display : 1680x1050 (CVT Reduce Blanking) */
+	{VIA_RES_1680X1050_RB, CRTM1680x1050_RB,
+	 ARRAY_SIZE(CRTM1680x1050_RB)},
+
+	/* Display : 1792x1344 (DMT) */
+	{VIA_RES_1792X1344, CRTM1792x1344, ARRAY_SIZE(CRTM1792x1344)},
+
+	/* Display : 1856x1392 (DMT) */
+	{VIA_RES_1856X1392, CRTM1856x1392, ARRAY_SIZE(CRTM1856x1392)},
+
+	/* Display : 1920x1440 */
+	{VIA_RES_1920X1440, CRTM1920x1440, ARRAY_SIZE(CRTM1920x1440)},
+
+	/* Display : 2048x1536 */
+	{VIA_RES_2048X1536, CRTM2048x1536, ARRAY_SIZE(CRTM2048x1536)},
+
+	/* Display : 1280x720 */
+	{VIA_RES_1280X720, CRTM1280x720, ARRAY_SIZE(CRTM1280x720)},
+
+	/* Display : 1920x1080 (CVT) */
+	{VIA_RES_1920X1080, CRTM1920x1080, ARRAY_SIZE(CRTM1920x1080)},
+
+	/* Display : 1920x1080 (CVT Reduce Blanking) */
+	{VIA_RES_1920X1080_RB, CRTM1920x1080_RB,
+	 ARRAY_SIZE(CRTM1920x1080_RB)},
+
+	/* Display : 1920x1200 (CVT) */
+	{VIA_RES_1920X1200, CRTM1920x1200, ARRAY_SIZE(CRTM1920x1200)},
+
+	/* Display : 1920x1200 (CVT Reduce Blanking) */
+	{VIA_RES_1920X1200_RB, CRTM1920x1200_RB,
+	 ARRAY_SIZE(CRTM1920x1200_RB)},
+
+	/* Display : 1400x1050 (CVT) */
+	{VIA_RES_1400X1050, CRTM1400x1050, ARRAY_SIZE(CRTM1400x1050)}
+};
+struct crt_mode_table CEAM1280x720[] = {
+	{REFRESH_60, CLK_74_270M, M1280X720_CEA_R60_HSP,
+	 M1280X720_CEA_R60_VSP,
+	 /* HT,    HA,   HBS,  HBE,  HSS, HSE,  VT,   VA,  VBS, VBE, VSS, VSE */
+	 {1650, 1280, 1280, 370, 1390, 40, 750, 720, 720, 30, 725, 5} }
+};
+struct crt_mode_table CEAM1920x1080[] = {
+	{REFRESH_60, CLK_148_500M, M1920X1080_CEA_R60_HSP,
+	 M1920X1080_CEA_R60_VSP,
+	 /* HT,    HA,   HBS,  HBE,  HSS, HSE,  VT,  VA, VBS, VBE,  VSS, VSE */
+	 {2200, 1920, 1920, 300, 2008, 44, 1125, 1080, 1080, 45, 1084, 5} }
+};
+struct VideoModeTable CEA_HDMI_Modes[] = {
+	/* Display : 1280x720 */
+	{VIA_RES_1280X720, CEAM1280x720, ARRAY_SIZE(CEAM1280x720)},
+	{VIA_RES_1920X1080, CEAM1920x1080, ARRAY_SIZE(CEAM1920x1080)}
+};
--- /dev/null
+++ b/drivers/video/via/viamode.h
@@ -0,0 +1,177 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __VIAMODE_H__
+#define __VIAMODE_H__
+
+#include "global.h"
+
+struct VPITTable {
+	unsigned char Misc;
+	unsigned char SR[StdSR];
+	unsigned char GR[StdGR];
+	unsigned char AR[StdAR];
+};
+
+struct VideoModeTable {
+	int ModeIndex;
+	struct crt_mode_table *crtc;
+	int mode_array;
+};
+
+struct patch_table {
+	int mode_index;
+	int table_length;
+	struct io_reg *io_reg_table;
+};
+
+struct res_map_refresh {
+	int hres;
+	int vres;
+	int pixclock;
+	int vmode_refresh;
+};
+
+#define NUM_TOTAL_RES_MAP_REFRESH ARRAY_SIZE(res_map_refresh_tbl)
+#define NUM_TOTAL_CEA_MODES  ARRAY_SIZE(CEA_HDMI_Modes)
+#define NUM_TOTAL_CN400_ModeXregs ARRAY_SIZE(CN400_ModeXregs)
+#define NUM_TOTAL_CN700_ModeXregs ARRAY_SIZE(CN700_ModeXregs)
+#define NUM_TOTAL_KM400_ModeXregs ARRAY_SIZE(KM400_ModeXregs)
+#define NUM_TOTAL_CX700_ModeXregs ARRAY_SIZE(CX700_ModeXregs)
+#define NUM_TOTAL_VX800_ModeXregs ARRAY_SIZE(VX800_ModeXregs)
+#define NUM_TOTAL_CLE266_ModeXregs ARRAY_SIZE(CLE266_ModeXregs)
+#define NUM_TOTAL_PATCH_MODE ARRAY_SIZE(res_patch_table)
+#define NUM_TOTAL_MODETABLE ARRAY_SIZE(CLE266Modes)
+
+/********************/
+/* Mode Table       */
+/********************/
+
+/* 480x640 */
+extern struct crt_mode_table CRTM480x640[1];
+/* 640x480*/
+extern struct crt_mode_table CRTM640x480[5];
+/*720x480 (GTF)*/
+extern struct crt_mode_table CRTM720x480[1];
+/*720x576 (GTF)*/
+extern struct crt_mode_table CRTM720x576[1];
+/* 800x480 (CVT) */
+extern struct crt_mode_table CRTM800x480[1];
+/* 800x600*/
+extern struct crt_mode_table CRTM800x600[5];
+/* 848x480 (CVT) */
+extern struct crt_mode_table CRTM848x480[1];
+/*856x480 (GTF) convert to 852x480*/
+extern struct crt_mode_table CRTM852x480[1];
+/*1024x512 (GTF)*/
+extern struct crt_mode_table CRTM1024x512[1];
+/* 1024x600*/
+extern struct crt_mode_table CRTM1024x600[1];
+/* 1024x768*/
+extern struct crt_mode_table CRTM1024x768[4];
+/* 1152x864*/
+extern struct crt_mode_table CRTM1152x864[1];
+/* 1280x720 (HDMI 720P)*/
+extern struct crt_mode_table CRTM1280x720[2];
+/*1280x768 (GTF)*/
+extern struct crt_mode_table CRTM1280x768[2];
+/* 1280x800 (CVT) */
+extern struct crt_mode_table CRTM1280x800[1];
+/*1280x960*/
+extern struct crt_mode_table CRTM1280x960[1];
+/* 1280x1024*/
+extern struct crt_mode_table CRTM1280x1024[3];
+/* 1368x768 (GTF) */
+extern struct crt_mode_table CRTM1368x768[1];
+/*1440x1050 (GTF)*/
+extern struct crt_mode_table CRTM1440x1050[1];
+/* 1600x1200*/
+extern struct crt_mode_table CRTM1600x1200[2];
+/* 1680x1050 (CVT) */
+extern struct crt_mode_table CRTM1680x1050[2];
+/* 1680x1050 (CVT Reduce Blanking) */
+extern struct crt_mode_table CRTM1680x1050_RB[1];
+/* 1920x1080 (CVT)*/
+extern struct crt_mode_table CRTM1920x1080[1];
+/* 1920x1080 (CVT with Reduce Blanking) */
+extern struct crt_mode_table CRTM1920x1080_RB[1];
+/* 1920x1440*/
+extern struct crt_mode_table CRTM1920x1440[2];
+/* 1400x1050 (CVT) */
+extern struct crt_mode_table CRTM1400x1050[2];
+/* 1400x1050 (CVT Reduce Blanking) */
+extern struct crt_mode_table CRTM1400x1050_RB[1];
+/* 960x600 (CVT) */
+extern struct crt_mode_table CRTM960x600[1];
+/* 1000x600 (GTF) */
+extern struct crt_mode_table CRTM1000x600[1];
+/* 1024x576 (GTF) */
+extern struct crt_mode_table CRTM1024x576[1];
+/* 1088x612 (CVT) */
+extern struct crt_mode_table CRTM1088x612[1];
+/* 1152x720 (CVT) */
+extern struct crt_mode_table CRTM1152x720[1];
+/* 1200x720 (GTF) */
+extern struct crt_mode_table CRTM1200x720[1];
+/* 1280x600 (GTF) */
+extern struct crt_mode_table CRTM1280x600[1];
+/* 1360x768 (CVT) */
+extern struct crt_mode_table CRTM1360x768[1];
+/* 1360x768 (CVT Reduce Blanking) */
+extern struct crt_mode_table CRTM1360x768_RB[1];
+/* 1366x768 (GTF) */
+extern struct crt_mode_table CRTM1366x768[2];
+/* 1440x900 (CVT) */
+extern struct crt_mode_table CRTM1440x900[2];
+/* 1440x900 (CVT Reduce Blanking) */
+extern struct crt_mode_table CRTM1440x900_RB[1];
+/* 1600x900 (CVT) */
+extern struct crt_mode_table CRTM1600x900[1];
+/* 1600x900 (CVT Reduce Blanking) */
+extern struct crt_mode_table CRTM1600x900_RB[1];
+/* 1600x1024 (GTF) */
+extern struct crt_mode_table CRTM1600x1024[1];
+/* 1792x1344 (DMT) */
+extern struct crt_mode_table CRTM1792x1344[1];
+/* 1856x1392 (DMT) */
+extern struct crt_mode_table CRTM1856x1392[1];
+/* 1920x1200 (CVT) */
+extern struct crt_mode_table CRTM1920x1200[1];
+/* 1920x1200 (CVT with Reduce Blanking) */
+extern struct crt_mode_table CRTM1920x1200_RB[1];
+/* 2048x1536 (CVT) */
+extern struct crt_mode_table CRTM2048x1536[1];
+extern struct VideoModeTable CLE266Modes[47];
+extern struct crt_mode_table CEAM1280x720[1];
+extern struct crt_mode_table CEAM1920x1080[1];
+extern struct VideoModeTable CEA_HDMI_Modes[2];
+
+extern struct res_map_refresh res_map_refresh_tbl[61];
+extern struct io_reg CN400_ModeXregs[52];
+extern struct io_reg CN700_ModeXregs[66];
+extern struct io_reg KM400_ModeXregs[55];
+extern struct io_reg CX700_ModeXregs[58];
+extern struct io_reg VX800_ModeXregs[58];
+extern struct io_reg CLE266_ModeXregs[32];
+extern struct io_reg PM1024x768[2];
+extern struct patch_table res_patch_table[1];
+extern struct VPITTable VPIT;
+#endif /* __VIAMODE_H__ */
--- /dev/null
+++ b/drivers/video/via/via_utility.c
@@ -0,0 +1,253 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "global.h"
+
+void viafb_get_device_support_state(u32 *support_state)
+{
+	*support_state = CRT_Device;
+
+	if (viaparinfo->chip_info->tmds_chip_info.tmds_chip_name == VT1632_TMDS)
+		*support_state |= DVI_Device;
+
+	if (viaparinfo->chip_info->lvds_chip_info.lvds_chip_name == VT1631_LVDS)
+		*support_state |= LCD_Device;
+}
+
+void viafb_get_device_connect_state(u32 *connect_state)
+{
+	bool mobile = false;
+
+	*connect_state = CRT_Device;
+
+	if (viafb_dvi_sense())
+		*connect_state |= DVI_Device;
+
+	viafb_lcd_get_mobile_state(&mobile);
+	if (mobile)
+		*connect_state |= LCD_Device;
+}
+
+bool viafb_lcd_get_support_expand_state(u32 xres, u32 yres)
+{
+	unsigned int support_state = 0;
+
+	switch (viafb_lcd_panel_id) {
+	case LCD_PANEL_ID0_640X480:
+		if ((xres < 640) && (yres < 480))
+			support_state = true;
+		break;
+
+	case LCD_PANEL_ID1_800X600:
+		if ((xres < 800) && (yres < 600))
+			support_state = true;
+		break;
+
+	case LCD_PANEL_ID2_1024X768:
+		if ((xres < 1024) && (yres < 768))
+			support_state = true;
+		break;
+
+	case LCD_PANEL_ID3_1280X768:
+		if ((xres < 1280) && (yres < 768))
+			support_state = true;
+		break;
+
+	case LCD_PANEL_ID4_1280X1024:
+		if ((xres < 1280) && (yres < 1024))
+			support_state = true;
+		break;
+
+	case LCD_PANEL_ID5_1400X1050:
+		if ((xres < 1400) && (yres < 1050))
+			support_state = true;
+		break;
+
+	case LCD_PANEL_ID6_1600X1200:
+		if ((xres < 1600) && (yres < 1200))
+			support_state = true;
+		break;
+
+	case LCD_PANEL_ID7_1366X768:
+		if ((xres < 1366) && (yres < 768))
+			support_state = true;
+		break;
+
+	case LCD_PANEL_ID8_1024X600:
+		if ((xres < 1024) && (yres < 600))
+			support_state = true;
+		break;
+
+	case LCD_PANEL_ID9_1280X800:
+		if ((xres < 1280) && (yres < 800))
+			support_state = true;
+		break;
+
+	case LCD_PANEL_IDA_800X480:
+		if ((xres < 800) && (yres < 480))
+			support_state = true;
+		break;
+
+	case LCD_PANEL_IDB_1360X768:
+		if ((xres < 1360) && (yres < 768))
+			support_state = true;
+		break;
+
+	case LCD_PANEL_IDC_480X640:
+		if ((xres < 480) && (yres < 640))
+			support_state = true;
+		break;
+
+	default:
+		support_state = false;
+		break;
+	}
+
+	return support_state;
+}
+
+/*====================================================================*/
+/*                      Gamma Function Implementation*/
+/*====================================================================*/
+
+void viafb_set_gamma_table(int bpp, unsigned int *gamma_table)
+{
+	int i, sr1a;
+	int active_device_amount = 0;
+	int device_status = viafb_DeviceStatus;
+
+	for (i = 0; i < sizeof(viafb_DeviceStatus) * 8; i++) {
+		if (device_status & 1)
+			active_device_amount++;
+		device_status >>= 1;
+	}
+
+	/* 8 bpp mode can't adjust gamma */
+	if (bpp == 8)
+		return ;
+
+	/* Enable Gamma */
+	switch (viaparinfo->chip_info->gfx_chip_name) {
+	case UNICHROME_CLE266:
+	case UNICHROME_K400:
+		viafb_write_reg_mask(SR16, VIASR, 0x80, BIT7);
+		break;
+
+	case UNICHROME_K800:
+	case UNICHROME_PM800:
+	case UNICHROME_CN700:
+	case UNICHROME_CX700:
+	case UNICHROME_K8M890:
+	case UNICHROME_P4M890:
+	case UNICHROME_P4M900:
+		viafb_write_reg_mask(CR33, VIACR, 0x80, BIT7);
+		break;
+	}
+	sr1a = (unsigned int)viafb_read_reg(VIASR, SR1A);
+	viafb_write_reg_mask(SR1A, VIASR, 0x0, BIT0);
+
+	/* Fill IGA1 Gamma Table */
+	outb(0, LUT_INDEX_WRITE);
+	for (i = 0; i < 256; i++) {
+		outb(gamma_table[i] >> 16, LUT_DATA);
+		outb(gamma_table[i] >> 8 & 0xFF, LUT_DATA);
+		outb(gamma_table[i] & 0xFF, LUT_DATA);
+	}
+
+	/* If adjust Gamma value in SAMM, fill IGA1,
+	   IGA2 Gamma table simultanous. */
+	/* Switch to IGA2 Gamma Table */
+	if ((active_device_amount > 1) &&
+		!((viaparinfo->chip_info->gfx_chip_name ==
+		UNICHROME_CLE266) &&
+		(viaparinfo->chip_info->gfx_chip_revision < 15))) {
+		viafb_write_reg_mask(SR1A, VIASR, 0x01, BIT0);
+		viafb_write_reg_mask(CR6A, VIACR, 0x02, BIT1);
+
+		/* Fill IGA2 Gamma Table */
+		outb(0, LUT_INDEX_WRITE);
+		for (i = 0; i < 256; i++) {
+			outb(gamma_table[i] >> 16, LUT_DATA);
+			outb(gamma_table[i] >> 8 & 0xFF, LUT_DATA);
+			outb(gamma_table[i] & 0xFF, LUT_DATA);
+		}
+	}
+	viafb_write_reg(SR1A, VIASR, sr1a);
+}
+
+void viafb_get_gamma_table(unsigned int *gamma_table)
+{
+	unsigned char color_r, color_g, color_b;
+	unsigned char sr1a = 0;
+	int i;
+
+	/* Enable Gamma */
+	switch (viaparinfo->chip_info->gfx_chip_name) {
+	case UNICHROME_CLE266:
+	case UNICHROME_K400:
+		viafb_write_reg_mask(SR16, VIASR, 0x80, BIT7);
+		break;
+
+	case UNICHROME_K800:
+	case UNICHROME_PM800:
+	case UNICHROME_CN700:
+	case UNICHROME_CX700:
+	case UNICHROME_K8M890:
+	case UNICHROME_P4M890:
+	case UNICHROME_P4M900:
+		viafb_write_reg_mask(CR33, VIACR, 0x80, BIT7);
+		break;
+	}
+	sr1a = viafb_read_reg(VIASR, SR1A);
+	viafb_write_reg_mask(SR1A, VIASR, 0x0, BIT0);
+
+	/* Reading gamma table to get color value */
+	outb(0, LUT_INDEX_READ);
+	for (i = 0; i < 256; i++) {
+		color_r = inb(LUT_DATA);
+		color_g = inb(LUT_DATA);
+		color_b = inb(LUT_DATA);
+		gamma_table[i] =
+		    ((((u32) color_r) << 16) |
+		     (((u16) color_g) << 8)) | color_b;
+	}
+	viafb_write_reg(SR1A, VIASR, sr1a);
+}
+
+void viafb_get_gamma_support_state(int bpp, unsigned int *support_state)
+{
+	if (bpp == 8)
+		*support_state = None_Device;
+	else
+		*support_state = CRT_Device | DVI_Device | LCD_Device;
+}
+
+int viafb_input_parameter_converter(int parameter_value)
+{
+	int result;
+
+	if (parameter_value >= 1 && parameter_value <= 9)
+		result = 1 << (parameter_value - 1);
+	else
+		result = 1;
+
+	return result;
+}
--- /dev/null
+++ b/drivers/video/via/via_utility.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#ifndef __VIAUTILITY_H__
+#define __VIAUTILITY_H__
+
+/* These functions are used to get infomation about device's state */
+void viafb_get_device_support_state(u32 *support_state);
+void viafb_get_device_connect_state(u32 *connect_state);
+bool viafb_lcd_get_support_expand_state(u32 xres, u32 yres);
+
+/* These function are used to access gamma table */
+void viafb_set_gamma_table(int bpp, unsigned int *gamma_table);
+void viafb_get_gamma_table(unsigned int *gamma_table);
+void viafb_get_gamma_support_state(int bpp, unsigned int *support_state);
+int viafb_input_parameter_converter(int parameter_value);
+
+#endif /* __VIAUTILITY_H__ */
--- /dev/null
+++ b/drivers/video/via/vt1636.c
@@ -0,0 +1,306 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "global.h"
+
+u8 viafb_gpio_i2c_read_lvds(struct lvds_setting_information
+	*plvds_setting_info, struct lvds_chip_information *plvds_chip_info,
+	u8 index)
+{
+	u8 data;
+
+	viaparinfo->i2c_stuff.i2c_port = plvds_chip_info->i2c_port;
+	viafb_i2c_readbyte(plvds_chip_info->lvds_chip_slave_addr, index, &data);
+
+	return data;
+}
+
+void viafb_gpio_i2c_write_mask_lvds(struct lvds_setting_information
+			      *plvds_setting_info, struct lvds_chip_information
+			      *plvds_chip_info, struct IODATA io_data)
+{
+	int index, data;
+
+	viaparinfo->i2c_stuff.i2c_port = plvds_chip_info->i2c_port;
+
+	index = io_data.Index;
+	data = viafb_gpio_i2c_read_lvds(plvds_setting_info, plvds_chip_info,
+		index);
+	data = (data & (~io_data.Mask)) | io_data.Data;
+
+	viafb_i2c_writebyte(plvds_chip_info->lvds_chip_slave_addr, index, data);
+}
+
+void viafb_init_lvds_vt1636(struct lvds_setting_information
+	*plvds_setting_info, struct lvds_chip_information *plvds_chip_info)
+{
+	int reg_num, i;
+
+	/* Common settings: */
+	reg_num = ARRAY_SIZE(COMMON_INIT_TBL_VT1636);
+
+	for (i = 0; i < reg_num; i++) {
+		viafb_gpio_i2c_write_mask_lvds(plvds_setting_info,
+					 plvds_chip_info,
+					 COMMON_INIT_TBL_VT1636[i]);
+	}
+
+	/* Input Data Mode Select */
+	if (plvds_setting_info->device_lcd_dualedge) {
+		viafb_gpio_i2c_write_mask_lvds(plvds_setting_info,
+					 plvds_chip_info,
+					 DUAL_CHANNEL_ENABLE_TBL_VT1636[0]);
+	} else {
+		viafb_gpio_i2c_write_mask_lvds(plvds_setting_info,
+					 plvds_chip_info,
+					 SINGLE_CHANNEL_ENABLE_TBL_VT1636[0]);
+	}
+
+	if (plvds_setting_info->LCDDithering) {
+		viafb_gpio_i2c_write_mask_lvds(plvds_setting_info,
+					 plvds_chip_info,
+					 DITHERING_ENABLE_TBL_VT1636[0]);
+	} else {
+		viafb_gpio_i2c_write_mask_lvds(plvds_setting_info,
+					 plvds_chip_info,
+					 DITHERING_DISABLE_TBL_VT1636[0]);
+	}
+}
+
+void viafb_enable_lvds_vt1636(struct lvds_setting_information
+			*plvds_setting_info,
+			struct lvds_chip_information *plvds_chip_info)
+{
+
+	viafb_gpio_i2c_write_mask_lvds(plvds_setting_info, plvds_chip_info,
+				 VDD_ON_TBL_VT1636[0]);
+
+	/* Pad on: */
+	switch (plvds_chip_info->output_interface) {
+	case INTERFACE_DVP0:
+		{
+			viafb_write_reg_mask(SR1E, VIASR, 0xC0, 0xC0);
+			break;
+		}
+
+	case INTERFACE_DVP1:
+		{
+			viafb_write_reg_mask(SR1E, VIASR, 0x30, 0x30);
+			break;
+		}
+
+	case INTERFACE_DFP_LOW:
+		{
+			viafb_write_reg_mask(SR2A, VIASR, 0x03, 0x03);
+			break;
+		}
+
+	case INTERFACE_DFP_HIGH:
+		{
+			viafb_write_reg_mask(SR2A, VIASR, 0x03, 0x0C);
+			break;
+		}
+
+	}
+}
+
+void viafb_disable_lvds_vt1636(struct lvds_setting_information
+			 *plvds_setting_info,
+			 struct lvds_chip_information *plvds_chip_info)
+{
+
+	viafb_gpio_i2c_write_mask_lvds(plvds_setting_info, plvds_chip_info,
+				 VDD_OFF_TBL_VT1636[0]);
+
+	/* Pad off: */
+	switch (plvds_chip_info->output_interface) {
+	case INTERFACE_DVP0:
+		{
+			viafb_write_reg_mask(SR1E, VIASR, 0x00, 0xC0);
+			break;
+		}
+
+	case INTERFACE_DVP1:
+		{
+			viafb_write_reg_mask(SR1E, VIASR, 0x00, 0x30);
+			break;
+		}
+
+	case INTERFACE_DFP_LOW:
+		{
+			viafb_write_reg_mask(SR2A, VIASR, 0x00, 0x03);
+			break;
+		}
+
+	case INTERFACE_DFP_HIGH:
+		{
+			viafb_write_reg_mask(SR2A, VIASR, 0x00, 0x0C);
+			break;
+		}
+
+	}
+}
+
+bool viafb_lvds_identify_vt1636(void)
+{
+	u8 Buffer[2];
+
+	DEBUG_MSG(KERN_INFO "viafb_lvds_identify_vt1636.\n");
+
+	/* Sense VT1636 LVDS Transmiter */
+	viaparinfo->chip_info->lvds_chip_info.lvds_chip_slave_addr =
+	VT1636_LVDS_I2C_ADDR;
+
+	/* Check vendor ID first: */
+	viafb_i2c_readbyte((u8) viaparinfo->chip_info->lvds_chip_info.
+	lvds_chip_slave_addr,
+		    0x00, &Buffer[0]);
+	viafb_i2c_readbyte((u8) viaparinfo->chip_info->lvds_chip_info.
+		lvds_chip_slave_addr,
+		    0x01, &Buffer[1]);
+
+	if (!((Buffer[0] == 0x06) && (Buffer[1] == 0x11)))
+		return false;
+
+	/* Check Chip ID: */
+	viafb_i2c_readbyte((u8) viaparinfo->chip_info->lvds_chip_info.
+	lvds_chip_slave_addr,
+		    0x02, &Buffer[0]);
+	viafb_i2c_readbyte((u8) viaparinfo->chip_info->lvds_chip_info.
+		lvds_chip_slave_addr,
+		    0x03, &Buffer[1]);
+	if ((Buffer[0] == 0x45) && (Buffer[1] == 0x33)) {
+		viaparinfo->chip_info->lvds_chip_info.lvds_chip_name =
+			VT1636_LVDS;
+		return true;
+	}
+
+	return false;
+}
+
+static int get_clk_range_index(u32 Clk)
+{
+	if (Clk < DPA_CLK_30M)
+		return DPA_CLK_RANGE_30M;
+	else if (Clk < DPA_CLK_50M)
+		return DPA_CLK_RANGE_30_50M;
+	else if (Clk < DPA_CLK_70M)
+		return DPA_CLK_RANGE_50_70M;
+	else if (Clk < DPA_CLK_100M)
+		return DPA_CLK_RANGE_70_100M;
+	else if (Clk < DPA_CLK_150M)
+		return DPA_CLK_RANGE_100_150M;
+	else
+		return DPA_CLK_RANGE_150M;
+}
+
+static int get_lvds_dpa_setting_index(int panel_size_id,
+			     struct VT1636_DPA_SETTING *p_vt1636_dpasetting_tbl,
+			       int tbl_size)
+{
+	int i;
+
+	for (i = 0; i < tbl_size; i++) {
+		if (panel_size_id == p_vt1636_dpasetting_tbl->PanelSizeID)
+			return i;
+
+		p_vt1636_dpasetting_tbl++;
+	}
+
+	return 0;
+}
+
+static void set_dpa_vt1636(struct lvds_setting_information
+	*plvds_setting_info, struct lvds_chip_information *plvds_chip_info,
+		    struct VT1636_DPA_SETTING *p_vt1636_dpa_setting)
+{
+	struct IODATA io_data;
+
+	io_data.Index = 0x09;
+	io_data.Mask = 0x1F;
+	io_data.Data = p_vt1636_dpa_setting->CLK_SEL_ST1;
+	viafb_gpio_i2c_write_mask_lvds(plvds_setting_info,
+		plvds_chip_info, io_data);
+
+	io_data.Index = 0x08;
+	io_data.Mask = 0x0F;
+	io_data.Data = p_vt1636_dpa_setting->CLK_SEL_ST2;
+	viafb_gpio_i2c_write_mask_lvds(plvds_setting_info, plvds_chip_info,
+		io_data);
+}
+
+void viafb_vt1636_patch_skew_on_vt3324(
+	struct lvds_setting_information *plvds_setting_info,
+	struct lvds_chip_information *plvds_chip_info)
+{
+	int index, size;
+
+	DEBUG_MSG(KERN_INFO "viafb_vt1636_patch_skew_on_vt3324.\n");
+
+	/* Graphics DPA settings: */
+	index = get_clk_range_index(plvds_setting_info->vclk);
+	viafb_set_dpa_gfx(plvds_chip_info->output_interface,
+		    &GFX_DPA_SETTING_TBL_VT3324[index]);
+
+	/* LVDS Transmitter DPA settings: */
+	size = ARRAY_SIZE(VT1636_DPA_SETTING_TBL_VT3324);
+	index =
+	    get_lvds_dpa_setting_index(plvds_setting_info->lcd_panel_id,
+				       VT1636_DPA_SETTING_TBL_VT3324, size);
+	set_dpa_vt1636(plvds_setting_info, plvds_chip_info,
+		       &VT1636_DPA_SETTING_TBL_VT3324[index]);
+}
+
+void viafb_vt1636_patch_skew_on_vt3327(
+	struct lvds_setting_information *plvds_setting_info,
+	struct lvds_chip_information *plvds_chip_info)
+{
+	int index, size;
+
+	DEBUG_MSG(KERN_INFO "viafb_vt1636_patch_skew_on_vt3327.\n");
+
+	/* Graphics DPA settings: */
+	index = get_clk_range_index(plvds_setting_info->vclk);
+	viafb_set_dpa_gfx(plvds_chip_info->output_interface,
+		    &GFX_DPA_SETTING_TBL_VT3327[index]);
+
+	/* LVDS Transmitter DPA settings: */
+	size = ARRAY_SIZE(VT1636_DPA_SETTING_TBL_VT3327);
+	index =
+	    get_lvds_dpa_setting_index(plvds_setting_info->lcd_panel_id,
+				       VT1636_DPA_SETTING_TBL_VT3327, size);
+	set_dpa_vt1636(plvds_setting_info, plvds_chip_info,
+		       &VT1636_DPA_SETTING_TBL_VT3327[index]);
+}
+
+void viafb_vt1636_patch_skew_on_vt3364(
+	struct lvds_setting_information *plvds_setting_info,
+	struct lvds_chip_information *plvds_chip_info)
+{
+	int index;
+
+	DEBUG_MSG(KERN_INFO "viafb_vt1636_patch_skew_on_vt3364.\n");
+
+	/* Graphics DPA settings: */
+	index = get_clk_range_index(plvds_setting_info->vclk);
+	viafb_set_dpa_gfx(plvds_chip_info->output_interface,
+		    &GFX_DPA_SETTING_TBL_VT3364[index]);
+}
--- /dev/null
+++ b/drivers/video/via/vt1636.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _VT1636_H_
+#define _VT1636_H_
+#include "chip.h"
+bool viafb_lvds_identify_vt1636(void);
+void viafb_init_lvds_vt1636(struct lvds_setting_information
+	*plvds_setting_info, struct lvds_chip_information *plvds_chip_info);
+void viafb_enable_lvds_vt1636(struct lvds_setting_information
+			*plvds_setting_info,
+			struct lvds_chip_information *plvds_chip_info);
+void viafb_disable_lvds_vt1636(struct lvds_setting_information
+			 *plvds_setting_info,
+			 struct lvds_chip_information *plvds_chip_info);
+void viafb_vt1636_patch_skew_on_vt3324(
+	struct lvds_setting_information *plvds_setting_info,
+	struct lvds_chip_information *plvds_chip_info);
+void viafb_vt1636_patch_skew_on_vt3327(
+	struct lvds_setting_information *plvds_setting_info,
+	struct lvds_chip_information *plvds_chip_info);
+void viafb_vt1636_patch_skew_on_vt3364(
+	struct lvds_setting_information *plvds_setting_info,
+	struct lvds_chip_information *plvds_chip_info);
+
+#endif

diff -purN linux-2.5/CREDITS usb-2.5/CREDITS
--- linux-2.5/CREDITS	2003-09-30 10:03:37.000000000 +0000
+++ usb-2.5/CREDITS	2003-10-08 20:53:47.000000000 +0000
@@ -2669,6 +2669,13 @@ S: Kasarmikatu 11 A4
 S: 70110 Kuopio
 S: Finland
 
+N: Luca Risolia
+E: luca_ing@libero.it
+D: V4L driver for W996[87]CF JPEG USB Dual Mode Camera Chip
+S: Via Libertà 41/a
+S: Osio Sotto, 24046, Bergamo
+S: Italy
+
 N: William E. Roadcap
 E: roadcapw@cfw.com
 W: http://www.cfw.com/~roadcapw
@@ -3569,4 +3576,4 @@ S: France
 # alphabetically. Leonard used to be very proud of being the 
 # last entry, and he'll get positively pissed if he can't even
 # be second-to-last.  (and this file really _is_ supposed to be
-# in alphabetic order) 
+# in alphabetic order)
diff -purN linux-2.5/Documentation/devices.txt usb-2.5/Documentation/devices.txt
--- linux-2.5/Documentation/devices.txt	2003-03-27 00:34:38.000000000 +0000
+++ usb-2.5/Documentation/devices.txt	2003-10-08 17:57:24.000000000 +0000
@@ -2165,16 +2165,27 @@ Your cooperation is appreciated.
 		  0 = /dev/usb/lp0	First USB printer
 		    ...
 		 15 = /dev/usb/lp15	16th USB printer
-		 16 = /dev/usb/mouse0	First USB mouse
-		    ...
-		 31 = /dev/usb/mouse15	16th USB mouse
-		 32 = /dev/usb/ez0	First USB firmware loader
-		    ...
-		 47 = /dev/usb/ez15	16th USB firmware loader
+		 32 = /dev/usb/mdc800	MDC800 USB camera
 		 48 = /dev/usb/scanner0	First USB scanner
 		    ...
 		 63 = /dev/usb/scanner15 16th USB scanner
 		 64 = /dev/usb/rio500	Diamond Rio 500
+		 96 = /dev/usb/hiddev0	1st USB HID device
+		    ...
+		111 = /dev/usb/hiddev15	16th USB HID device
+		112 = /dev/usb/auer0	1st auerswald ISDN device
+		    ...
+		127 = /dev/usb/auer15	16th auerswald ISDN device
+		128 = /dev/usb/brlvgr0	First Braille Voyager device
+		    ...
+		131 = /dev/usb/brlvgr3	Fourth Braille Voyager device
+		144 = /dev/usb/lcd	USB LCD device
+		160 = /dev/usb/legousbtower0	1st USB Legotower device
+		    ...
+		175 = /dev/usb/legousbtower15	16th USB Legotower device
+		240 = /dev/usb/dabusb0	First daubusb device
+		    ...
+		243 = /dev/usb/dabusb3	Fourth dabusb device
 
 181 char	Conrad Electronic parallel port radio clocks
 		  0 = /dev/pcfclock0	First Conrad radio clock
diff -purN linux-2.5/Documentation/i2c/porting-clients usb-2.5/Documentation/i2c/porting-clients
--- linux-2.5/Documentation/i2c/porting-clients	1970-01-01 00:00:00.000000000 +0000
+++ usb-2.5/Documentation/i2c/porting-clients	2003-10-04 18:05:51.000000000 +0000
@@ -0,0 +1,121 @@
+Revision 3, 2003-10-04
+Jean Delvare <khali@linux-fr.org>
+Greg KH <greg@kroah.com>
+
+This is a guide on how to convert I2C chip drivers from Linux 2.4 to
+Linux 2.6. I have been using existing drivers (lm75, lm78) as examples.
+Then I converted a driver myself (lm83) and updated this document.
+
+There are two sets of points below. The first set concerns technical
+changes. The second set concerns coding policy. Both are mandatory.
+
+Although reading this guide will help you porting drivers, I suggest
+you keep an eye on an already ported driver while porting your own
+driver. This will help you a lot understanding what this guide
+exactly means. Choose the chip driver that is the more similar to
+yours for best results.
+
+Technical changes:
+
+* [Includes] Get rid of "version.h". Replace <linux/i2c-proc.h> with
+  <linux/i2c-sensor.h>. Includes typically look like that:
+  #include <linux/module.h>
+  #include <linux/init.h>
+  #include <linux/slab.h>
+  #include <linux/i2c.h>
+  #include <linux/i2c-sensor.h>
+  #include <linux/i2c-vid.h>     /* if you need VRM support */
+  #include <asm/io.h>            /* if you have I/O operations */
+  Some extra headers may be required for a given driver.
+
+* [Addresses] SENSORS_I2C_END becomes I2C_CLIENT_END, SENSORS_ISA_END
+  becomes I2C_CLIENT_ISA_END.
+
+* [Client data] Get rid of sysctl_id. Try using standard names for
+  register values (for example, temp_os becomes temp_max). You're
+  still relatively free here, but you *have* to follow the standard
+  names for sysfs files (see the Sysctl section below).
+
+* [Function prototypes] The detect functions loses its flags
+  parameter. Sysctl (e.g. lm75_temp) and miscellaneous (e.g.
+  swap_bytes) functions are off the list of prototypes. This
+  usually leaves five prototypes:
+  static int lm75_attach_adapter(struct i2c_adapter *adapter);
+  static int lm75_detect(struct i2c_adapter *adapter, int address,
+      int kind);
+  static void lm75_init_client(struct i2c_client *client);
+  static int lm75_detach_client(struct i2c_client *client);
+  static void lm75_update_client(struct i2c_client *client);
+
+* [Sysctl] All sysctl stuff is of course gone (defines, ctl_table
+  and functions). Instead, right after the static id definition
+  line, you have to define show and set functions for each sysfs
+  file. Only define set for writable values. Take a look at an
+  existing 2.6 driver for details (lm78 for example). Don't forget
+  to define the attributes for each file (this is that step that
+  links callback functions). Use the file names specified in
+  Documentation/i2c/sysfs-interface for the individual files. Also
+  convert the units these files read and write to the specified ones.
+  If you need to add a new type of file, please discuss it on the
+  sensors mailing list <sensors@stimpy.netroedge.com> by providing a
+  patch to the Documentation/i2c/sysfs-interface file.
+
+* [Attach] For I2C drivers, the attach function should make sure
+  that the adapter's class has I2C_ADAP_CLASS_SMBUS, using the
+  following construct:
+  if (!(adapter->class & I2C_ADAP_CLASS_SMBUS))
+          return 0;
+  ISA-only drivers of course don't need this.
+
+* [Detect] As mentioned earlier, the flags parameter is gone.
+  The type_name and client_name strings are replaced by a single
+  name string, which will be filled with a lowercase, short string
+  (typically the driver name, e.g. "lm75"). The errorN labels are
+  reduced to the number needed. If that number is 2 (i2c-only
+  drivers), it is advised that the labels are named exit and
+  exit_free. For i2c+isa drivers, labels should be named ERROR0,
+  ERROR1 and ERROR2. Don't forget to properly set err before
+  jumping to error labels. By the way, labels should be
+  left-aligned.
+  Use memset to fill the client and data area with 0x00.
+  Use i2c_set_clientdata to set the client data (as opposed to
+  a direct access to client->data).
+  Use strlcpy instead of strcpy to copy the client name.
+  Replace the sysctl directory registration by calls to
+  device_create_file. Move the driver initialization before any
+  sysfs file creation.
+
+* [Detach] Get rid of data, remove the call to
+  i2c_deregister_entry.
+
+* [Update] Don't access client->data directly, use
+  i2c_get_clientdata(client) instead.
+
+* [Interface] Init function should not print anything. Make sure
+  there is a MODULE_LICENSE() line.
+
+Coding policy:
+
+* [Copyright] Use (C), not (c), for copyright.
+
+* [Debug/log] Get rid of #ifdef DEBUG/#endif constructs whenever you
+  can. Calls to printk/pr_debug for debugging purposes are replaced
+  by calls to dev_dbg. Here is an example on how to call it (taken
+  from lm75_detect):
+  dev_dbg(&adapter->dev,
+          "lm75_detect called for an ISA bus adapter?!?\n");
+  Replace other printk calls with the dev_info, dev_err or dev_warn
+  function, as appropriate.
+
+* [Constants] Constants defines (registers, conversions, initial
+  values) should be aligned. This greatly improves readability.
+  Same goes for variables declarations. Alignments are achieved by the
+  means of tabs, not spaces. Remember that tabs are set to 8 in the
+  Linux kernel code.
+
+* [Structure definition] The name field should be standardized. All
+  lowercase and as simple as the driver name itself (e.g. "lm75").
+
+* [Layout] Avoid extra empty lines between comments and what they
+  comment. Respect the coding style (see Documentation/CodingStyle),
+  in particular when it comes to placing curly braces.
diff -purN linux-2.5/Documentation/i2c/sysfs-interface usb-2.5/Documentation/i2c/sysfs-interface
--- linux-2.5/Documentation/i2c/sysfs-interface	2003-09-23 16:14:19.000000000 +0000
+++ usb-2.5/Documentation/i2c/sysfs-interface	2003-11-16 19:57:41.000000000 +0000
@@ -68,9 +68,7 @@ curr_max[1-n]	Current max value
 		Fixed point XXXXX, divide by 1000 to get Amps.
 		Read/Write.
 
-curr_min[1-n]	Current min or hysteresis value.
-		Preferably a hysteresis value, reported as a absolute
-		current, NOT a delta from the max value.
+curr_min[1-n]	Current min value.
 		Fixed point XXXXX, divide by 1000 to get Amps.
 		Read/Write.
 
@@ -144,25 +142,38 @@ sensor[1-3]	Sensor type selection.
 		Integers 1,2,3, or thermistor Beta value (3435)
 		Read/Write.
 
-temp_max[1-3]	Temperature max value.
+temp_max[1-4]	Temperature max value.
 		Fixed point value in form XXXXX and should be divided by
 		1000 to get degrees Celsius.
 		Read/Write value.
 
-temp_min[1-3]	Temperature min or hysteresis value.
+temp_min[1-3]	Temperature min value.
 		Fixed point value in form XXXXX and should be divided by
-		1000 to get degrees Celsius.  This is preferably a
-		hysteresis value, reported as a absolute temperature,
-		NOT a delta from the max value.
+		1000 to get degrees Celsius.
 		Read/Write value.
 
-temp_input[1-3] Temperature input value.
+temp_hyst[1-3]	Temperature hysteresis value.
+		Fixed point value in form XXXXX and should be divided by
+		1000 to get degrees Celsius.  Must be reported as an
+		absolute temperature, NOT a delta from the max value.
+		Read/Write value.
+
+temp_input[1-4] Temperature input value.
+		Fixed point value in form XXXXX and should be divided by
+		1000 to get degrees Celsius.
 		Read only value.
 
+temp_crit	Temperature critical value, typically greater than all
+		temp_max values.
+		Fixed point value in form XXXXX and should be divided by
+		1000 to get degrees Celsius.
+		Common to all temperature channels.
+		Read/Write value.
+
 		If there are multiple temperature sensors, temp_*1 is
 		generally the sensor inside the chip itself, generally
-		reported as "motherboard temperature".  temp_*2 and
-		temp_*3 are generally sensors external to the chip
+		reported as "motherboard temperature".  temp_*2 to
+		temp_*4 are generally sensors external to the chip
 		itself, for example the thermal diode inside the CPU or
 		a thermistor nearby.
 
diff -purN linux-2.5/Documentation/i2c/writing-clients usb-2.5/Documentation/i2c/writing-clients
--- linux-2.5/Documentation/i2c/writing-clients	2003-02-04 20:58:09.000000000 +0000
+++ usb-2.5/Documentation/i2c/writing-clients	2003-11-09 14:19:12.000000000 +0000
@@ -24,16 +24,14 @@ all clients from it. Remember, a driver 
 routines, a client structure specific information like the actual I2C
 address.
 
-  struct i2c_driver foo_driver
-  {  
-    /* name           */  "Foo version 2.3 and later driver",
-    /* id             */  I2C_DRIVERID_FOO,
-    /* flags          */  I2C_DF_NOTIFY,
-    /* attach_adapter */  &foo_attach_adapter,
-    /* detach_client  */  &foo_detach_client,
-    /* command        */  &foo_command,   /* May be NULL */
-    /* inc_use        */  &foo_inc_use,   /* May be NULL */
-    /* dec_use        */  &foo_dec_use    /* May be NULL */
+  static struct i2c_driver foo_driver = {
+    .owner          = THIS_MODULE,
+    .name           = "Foo version 2.3 driver",
+    .id             = I2C_DRIVERID_FOO, /* usually from i2c-id.h */
+    .flags          = I2C_DF_NOTIFY,
+    .attach_adapter = &foo_attach_adapter,
+    .detach_client  = &foo_detach_client,
+    .command        = &foo_command /* may be NULL */
   }
  
 The name can be chosen freely, and may be upto 40 characters long. Please
@@ -50,43 +48,8 @@ This is almost always what you want.
 All other fields are for call-back functions which will be explained 
 below.
 
-
-Module usage count
-==================
-
-If your driver can also be compiled as a module, there are moments at 
-which the module can not be removed from memory. For example, when you
-are doing a lengthy transaction, or when you create a /proc directory,
-and some process has entered that directory (this last case is the
-main reason why these call-backs were introduced).
-
-To increase or decrease the module usage count, you can use the
-MOD_{INC,DEC}_USE_COUNT macros. They must be called from the module
-which needs to get its usage count changed; that is why each driver
-module has to implement its own callback.
-
-  void foo_inc_use (struct i2c_client *client)
-  {
-  #ifdef MODULE
-    MOD_INC_USE_COUNT;
-  #endif
-  }
-
-  void foo_dec_use (struct i2c_client *client)
-  {
-  #ifdef MODULE
-    MOD_DEC_USE_COUNT;
-  #endif
-  }
-
-Do not call these call-back functions directly; instead, use one of the
-following functions defined in i2c.h:
-  void i2c_inc_use_client(struct i2c_client *);
-  void i2c_dec_use_client(struct i2c_client *);
-
-You should *not* increase the module count just because a device is
-detected and a client created. This would make it impossible to remove
-an adapter driver! 
+There use to be two additional fields in this structure, inc_use et dec_use,
+for module usage count, but these fields were obsoleted and removed.
 
 
 Extra client data
diff -purN linux-2.5/Documentation/usb/w9968cf.txt usb-2.5/Documentation/usb/w9968cf.txt
--- linux-2.5/Documentation/usb/w9968cf.txt	1970-01-01 00:00:00.000000000 +0000
+++ usb-2.5/Documentation/usb/w9968cf.txt	2003-10-04 10:02:10.000000000 +0000
@@ -0,0 +1,463 @@
+
+         W996[87]CF JPEG USB Dual Mode Camera Chip driver for Linux 2.6
+         ==============================================================
+
+                               - Documentation -
+
+
+Index
+=====
+1. Copyright
+2. License
+3. Overview
+4. Supported devices
+5. Kernel configuration and third-part module compilation
+6. Module loading
+7. Module paramaters
+8. Credits
+
+
+1. Copyright
+============
+Copyright (C) 2002 2003 by Luca Risolia <luca_ing@libero.it>
+
+
+2. License
+==========
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+
+3. Overview
+===========
+This driver supports the video streaming capabilities of the devices mounting
+Winbond W9967CF and Winbond W9968CF JPEG USB Dual Mode Camera Chips, when they
+are being commanded by USB.
+
+The driver relies on the Video4Linux, USB and I2C core modules of the Linux
+kernel, version 2.6.0 or greater, and is not compatible in any way with
+previous versions. It has been designed to run properly on SMP systems
+as well. At the moment, an additional module, "ovcamchip", is mandatory; it
+provides support for some OmniVision CMOS sensors connected to the W996[87]CF
+chips.
+
+The driver is split into two modules: the basic one, "w9968cf", is needed for
+the supported devices to work; the second one, "w9968cf-vpp", is an optional
+module, which provides some useful video post-processing functions like video
+decoding, up-scaling and colour conversions. These routines can't be included
+into official kernels for performance purposes. Once the driver is installed,
+every time an application tries to open a recognized device, "w9968cf" checks
+the presence of the "w9968cf-vpp" module and loads it automatically by default.
+
+Up to 32 cameras can be handled at the same time. They can be connected and
+disconnected from the host many times without turning off the computer, if
+your system supports the hotplug facility.
+
+To change the default settings for each camera, many paramaters can be passed
+through command line when the module is loaded into memory.
+
+The latest and full featured version of the W996[87]CF driver can be found at:
+http://go.lamarinapunto.com/
+
+The "ovcamchip" module is part of the OV511 driver, version 2.25, which can be
+downloaded from internet:
+http://alpha.dyndns.org/ov511/
+To know how to patch, compile and load it, read the paragraphs below.
+
+
+4. Supported devices
+====================
+At the moment, known W996[87]CF based devices are:
+- Aroma Digi Pen ADG-5000 Refurbished
+- AVerTV USB
+- Creative Labs Video Blaster WebCam Go
+- Creative Labs Video Blaster WebCam Go Plus
+- Die Lebon LDC-D35A Digital Kamera
+- Ezonics EZ-802 EZMega Cam
+- OPCOM Digi Pen VGA Dual Mode Pen Camera
+
+If you know any other W996[87]CF based cameras, please contact me.
+
+The list above does NOT imply that all those devices work with this driver: up
+until now only webcams that have a CMOS sensor supported by the "ovcamchip"
+module work. 
+For a list of supported CMOS sensors, please visit the module author homepage:
+http://alpha.dyndns.org/ov511/
+
+Possible external microcontrollers of those webcams are not supported: this
+means that still images can't be downloaded from the device memory.
+
+Furthermore, it's worth to note that I was only able to run tests on my
+"Creative Labs Video Blaster WebCam Go". Donations of other models, for
+additional testing and full support, would be much appreciated.
+
+
+5. Kernel configuration and third-part module compilation
+=========================================================
+As noted above, kernel 2.6.0 is the minimum for this driver; for it to work
+properly, the driver needs kernel support for Video4Linux, USB and I2C, and a
+third-part module for the CMOS sensor.
+
+The following options of the kernel configuration file must be enabled and
+corresponding modules must be compiled:
+
+	# Multimedia devices
+	#
+	CONFIG_VIDEO_DEV=m
+
+	# I2C support
+	#
+	CONFIG_I2C=m
+
+The I2C core module can be compiled statically in the kernel as well.
+
+	# USB support
+	#
+	CONFIG_USB=m
+
+In addition, depending on the hardware being used, just one of the modules
+below is necessary:
+
+	# USB Host Controller Drivers
+	#
+	CONFIG_USB_EHCI_HCD=m
+	CONFIG_USB_UHCI_HCD=m
+	CONFIG_USB_OHCI_HCD=m
+
+Also, make sure "Enforce bandwidth allocation" is NOT enabled.
+
+	# USB Multimedia devices
+	#
+	CONFIG_USB_W9968CF=m
+
+The last module we need is "ovcamchip.o". To obtain it, you have to download
+the OV511 driver, version 2.25 - don't use other versions - which is available
+at http://alpha.dyndns.org/ov511/ . Then you have to download the latest 
+version of the full featured W996[87]CF driver, which contains a patch for the
+"ovcamchip" module; it is available at http://go.lamarinapunto.com .
+Once you have obtained the packages, decompress, patch and compile the 
+"ovcamchip" module. In other words:
+
+	[user@localhost home]$ tar xvzf w9968cf-x.x.tar.gz
+	[user@localhost home]$ tar xvjf ov511-2.25.tar.bz2
+	[user@localhost home]$ cd ov511-2.25
+	[user@localhost ov511-2.25]$ patch -p1 <                              \
+	                             /path/to/w9968cf-x.x/ov511-2.25.patch
+	[user@localhost ov511-2.25]$ make
+
+It's worth to note that the full featured version of the W996[87]CF driver
+can also be installed overwriting the one in the kernel; in this case, read the
+documentation included in the package.
+
+If everything went well, the W996[87]CF driver can be immediatly used (see next
+paragraph).
+
+
+6. Module loading
+=================
+To use the driver, it is necessary to load the "w9968cf" module into memory
+after every other module required.
+
+For example, loading can be done this way, as root:
+
+	[root@localhost home]# modprobe usbcore
+	[root@localhost home]# modprobe i2c-core
+	[root@localhost ov511-x.xx]# insmod ./ovcamchip.ko
+	[root@localhost home]# modprobe w9968cf
+
+At this point the devices should be recognized: "dmesg" can be used to analyze
+kernel messages:
+
+	[user@localhost home]$ dmesg
+
+There are a lot of parameters the module can use to change the default
+settings for each device. To list every possible parameter with a brief
+explanation about them and which syntax to use, it is recommended to run the
+"modinfo" command:
+
+	[root@locahost home]# modinfo w9968cf
+
+
+7. Module paramaters
+====================
+
+Module paramaters are listed below:
+-------------------------------------------------------------------------------
+Name:           vppmod_load
+Type:           int
+Syntax:         <0|1>
+Description:    Automatic 'w9968cf-vpp' module loading: 0 disabled, 1 enabled.
+                If enabled, every time an application attempts to open a
+                camera, 'insmod' searches for the video post-processing module
+                in the system and loads it automatically (if present).
+                The 'w9968cf-vpp' module adds extra image manipulation 
+                capabilities to the 'w9968cf' module,like software up-scaling,
+                colour conversions and video decoding.
+Default:        1
+-------------------------------------------------------------------------------
+Name:           simcams 
+Type:           int 
+Syntax:         <n> 
+Description:    Number of cameras allowed to stream simultaneously.
+                n may vary from 0 to 32.
+Default:        32
+-------------------------------------------------------------------------------
+Name:           video_nr
+Type:           int array (min = 0, max = 32)
+Syntax:         <-1|n[,...]> 
+Description:    Specify V4L minor mode number.
+                -1 = use next available
+                 n = use minor number n
+                You can specify 32 cameras this way.
+                For example:
+                video_nr=-1,2,-1 would assign minor number 2 to the second
+                recognized camera and use auto for the first one and for every
+                other camera.
+Default:        -1
+-------------------------------------------------------------------------------
+Name:           packet_size
+Type:           int array (min = 0, max = 32)
+Syntax:         <n[,...]> 
+Description:    Specify the maximum data payload size in bytes for alternate
+                settings, for each device. n is scaled between 63 and 1023.
+Default:        1023
+-------------------------------------------------------------------------------
+Name:           max_buffers
+Type:           int array (min = 0, max = 32)
+Syntax:         <n[,...]>
+Description:    Only for advanced users.
+                Specify the maximum number of video frame buffers to allocate
+                for each device, from 2 to 32.
+Default:        2
+-------------------------------------------------------------------------------
+Name:           double_buffer
+Type:           int array (min = 0, max = 32)
+Syntax:         <0|1[,...]> 
+Description:    Hardware double buffering: 0 disabled, 1 enabled.
+                It should be enabled if you want smooth video output: if you
+                obtain out of sync. video, disable it at all, or try to
+                decrease the 'clockdiv' module paramater value.
+Default:        1 for every device.
+-------------------------------------------------------------------------------
+Name:           clamping
+Type:           int array (min = 0, max = 32)
+Syntax:         <0|1[,...]> 
+Description:    Video data clamping: 0 disabled, 1 enabled.
+Default:        0 for every device.
+-------------------------------------------------------------------------------
+Name:           filter_type
+Type:           int array (min = 0, max = 32)
+Syntax:         <0|1|2[,...]> 
+Description:    Video filter type.
+                0 none, 1 (1-2-1) 3-tap filter, 2 (2-3-6-3-2) 5-tap filter.
+                The filter is used to reduce noise and aliasing artifacts
+                produced by the CCD or CMOS sensor.
+Default:        0 for every device.
+-------------------------------------------------------------------------------
+Name:           largeview
+Type:           int array (min = 0, max = 32)
+Syntax:         <0|1[,...]> 
+Description:    Large view: 0 disabled, 1 enabled.
+Default:        1 for every device.
+-------------------------------------------------------------------------------
+Name:           upscaling
+Type:           int array (min = 0, max = 32)
+Syntax:         <0|1[,...]> 
+Description:    Software scaling (for non-compressed video only):
+                0 disabled, 1 enabled.
+                Disable it if you have a slow CPU or you don't have enough
+                memory.
+Default:        0 for every device.
+Note:           If 'w9968cf-vpp' is not loaded, this paramater is set to 0.
+-------------------------------------------------------------------------------
+Name:           decompression
+Type:           int array (min = 0, max = 32)
+Syntax:         <0|1|2[,...]>
+Description:    Software video decompression:
+                0 = disables decompression
+                    (doesn't allow formats needing decompression).
+                1 = forces decompression
+                    (allows formats needing decompression only).
+                2 = allows any permitted formats.
+                Formats supporting (de)compressed video are YUV422P and
+                YUV420P/YUV420 in any resolutions where width and height are
+                multiples of 16.
+Default:        2 for every device.
+Note:           If 'w9968cf-vpp' is not loaded, forcing decompression is not
+                allowed; in this case this paramater is set to 2.
+-------------------------------------------------------------------------------
+Name:           force_palette
+Type:           int array (min = 0, max = 32)
+Syntax:         <0|9|10|13|15|8|7|1|6|3|4|5[,...]>
+Description:    Force picture palette.
+                In order:
+                 0 = Off - allows any of the following formats:
+                 9 = UYVY    16 bpp - Original video, compression disabled
+                10 = YUV420  12 bpp - Original video, compression enabled
+                13 = YUV422P 16 bpp - Original video, compression enabled
+                15 = YUV420P 12 bpp - Original video, compression enabled
+                 8 = YUVY    16 bpp - Software conversion from UYVY
+                 7 = YUV422  16 bpp - Software conversion from UYVY
+                 1 = GREY     8 bpp - Software conversion from UYVY
+                 6 = RGB555  16 bpp - Software conversion from UYVY
+                 3 = RGB565  16 bpp - Software conversion from UYVY
+                 4 = RGB24   24 bpp - Software conversion from UYVY
+                 5 = RGB32   32 bpp - Software conversion from UYVY
+                When not 0, this paramater will override 'decompression'.
+Default:        0 for every device. Initial palette is 9 (UYVY).
+Note:           If 'w9968cf-vpp' is not loaded, this paramater is set to 9.
+-------------------------------------------------------------------------------
+Name:           force_rgb
+Type:           int array (min = 0, max = 32)
+Syntax:         <0|1[,...]>
+Description:    Read RGB video data instead of BGR:
+                1 = use RGB component ordering.
+                0 = use BGR component ordering.
+                This parameter has effect when using RGBX palettes only.
+Default:        0 for every device.
+-------------------------------------------------------------------------------
+Name:           autobright
+Type:           long array (min = 0, max = 32)
+Syntax:         <0|1[,...]>
+Description:    CMOS sensor automatically changes brightness:
+                0 = no, 1 = yes
+Default:        0 for every device.
+-------------------------------------------------------------------------------
+Name:           autoexp
+Type:           long array (min = 0, max = 32)
+Syntax:         <0|1[,...]>
+Description:    CMOS sensor automatically changes exposure:
+                0 = no, 1 = yes
+Default:        1 for every device.
+-------------------------------------------------------------------------------
+Name:           lightfreq
+Type:           long array (min = 0, max = 32)
+Syntax:         <50|60[,...]>
+Description:    Light frequency in Hz:
+                50 for European and Asian lighting, 60 for American lighting.
+Default:        50 for every device.
+-------------------------------------------------------------------------------
+Name:           bandingfilter
+Type:           long array (min = 0, max = 32)
+Syntax:         <0|1[,...]> 
+Description:    Banding filter to reduce effects of fluorescent 
+                lighting:
+                0 disabled, 1 enabled.
+                This filter tries to reduce the pattern of horizontal
+                light/dark bands caused by some (usually fluorescent) lighting.
+Default:        0 for every device.
+-------------------------------------------------------------------------------
+Name:           clockdiv
+Type:           long array (min = 0, max = 32)
+Syntax:         <-1|n[,...]>
+Description:    Force pixel clock divisor to a specific value (for experts):
+                n may vary from 0 to 127.
+                -1 for automatic value.
+                See also the 'double_buffer' module paramater.
+Default:        -1 for every device.
+-------------------------------------------------------------------------------
+Name:           backlight
+Type:           long array (min = 0, max = 32)
+Syntax:         <0|1[,...]>
+Description:    Objects are lit from behind:
+                0 = no, 1 = yes
+Default:        0 for every device.
+-------------------------------------------------------------------------------
+Name:           mirror
+Type:           long array (min = 0, max = 32)
+Syntax:         <0|1[,...]>
+Description:    Reverse image horizontally:
+                0 = no, 1 = yes
+Default:        0 for every device.
+-------------------------------------------------------------------------------
+Name:           sensor_mono
+Type:           long array (min = 0, max = 32)
+Syntax:         <0|1[,...]> 
+Description:    The CMOS sensor is monochrome:
+                0 = no, 1 = yes
+Default:        0 for every device.
+-------------------------------------------------------------------------------
+Name:           brightness
+Type:           long array (min = 0, max = 32)
+Syntax:         <n[,...]>
+Description:    Set picture brightness (0-65535).
+                This parameter has no effect if 'autobright' is enabled.
+Default:        31000 for every device.
+-------------------------------------------------------------------------------
+Name:           hue
+Type:           long array (min = 0, max = 32)
+Syntax:         <n[,...]>
+Description:    Set picture hue (0-65535).
+Default:        32768 for every device.
+-------------------------------------------------------------------------------
+Name:           colour
+Type:           long array (min = 0, max = 32)
+Syntax:         <n[,...]>
+Description:    Set picture saturation (0-65535).
+Default:        32768 for every device.
+-------------------------------------------------------------------------------
+Name:           contrast
+Type:           long array (min = 0, max = 32)
+Syntax:         <n[,...]> 
+Description:    Set picture contrast (0-65535).
+Default:        50000 for every device.
+-------------------------------------------------------------------------------
+Name:           whiteness
+Type:           long array (min = 0, max = 32)
+Syntax:         <n[,...]> 
+Description:    Set picture whiteness (0-65535).
+Default:        32768 for every device.
+-------------------------------------------------------------------------------
+Name:           debug
+Type:           int
+Syntax:         <n> 
+Description:    Debugging information level, from 0 to 6:
+                0 = none (be cautious)
+                1 = critical errors
+                2 = significant informations
+                3 = configuration or general messages
+                4 = warnings
+                5 = called functions
+                6 = function internals
+                Level 5 and 6 are useful for testing only, when just one
+                device is used.
+Default:        2
+-------------------------------------------------------------------------------
+Name:           specific_debug
+Type:           int
+Syntax:         <0|1>
+Description:    Enable or disable specific debugging messages:
+                0 = print messages concerning every level <= 'debug' level.
+                1 = print messages concerning the level indicated by 'debug'.
+Default:        0
+-------------------------------------------------------------------------------
+
+
+8. Credits
+==========
+The development would not have proceed much further without having looked at
+the source code of other drivers and without the help of several persons; in
+particular:
+
+- the I2C interface to kernel and high-level CMOS sensor control routines have
+  been taken from the OV511 driver by Mark McClelland;
+
+- memory management code has been copied from the bttv driver by Ralph Metzler,
+  Marcus Metzler and Gerd Knorr;
+
+- the low-level I2C read function has been written by Frédéric Jouault, who
+  also gave me commented logs about sniffed USB traffic taken from another
+  driver for another system;
+
+- the low-level I2C fast write function has been written by Piotr Czerczak;
diff -purN linux-2.5/MAINTAINERS usb-2.5/MAINTAINERS
--- linux-2.5/MAINTAINERS	2003-11-11 00:50:25.000000000 +0000
+++ usb-2.5/MAINTAINERS	2003-11-12 16:54:36.000000000 +0000
@@ -2218,6 +2218,13 @@ M:	dbrownell@users.sourceforge.net
 L:	linux-usb-devel@lists.sourceforge.net
 S:	Maintained
 
+USB W996[87]CF DRIVER
+P:	Luca Risolia
+M:	luca_ing@libero.it
+L:	linux-usb-devel@lists.sourceforge.net
+W:	http://go.lamarinapunto.com
+S:	Maintained
+
 USER-MODE LINUX
 P:	Jeff Dike
 M:	jdike@karaya.com
diff -purN linux-2.5/arch/i386/Kconfig usb-2.5/arch/i386/Kconfig
--- linux-2.5/arch/i386/Kconfig	2003-10-08 21:33:36.000000000 +0000
+++ usb-2.5/arch/i386/Kconfig	2003-10-08 20:53:47.000000000 +0000
@@ -1203,6 +1203,13 @@ config DEBUG_INFO
 	  Say Y here only if you plan to use gdb to debug the kernel.
 	  If you don't debug the kernel, you can say N.
 	  
+config DEBUG_DEV_PRINTK
+	bool "Debug dev_printk"
+	depends on DEBUG_KERNEL
+	help
+	  If you say Y here, all dev_printk() parameters will be checked before
+	  dev_printk() is called.  This is useful when debugging new drivers.
+
 config DEBUG_SPINLOCK_SLEEP
 	bool "Sleep-inside-spinlock checking"
 	help
diff -purN linux-2.5/drivers/base/bus.c usb-2.5/drivers/base/bus.c
--- linux-2.5/drivers/base/bus.c	2003-09-30 15:59:35.000000000 +0000
+++ usb-2.5/drivers/base/bus.c	2003-10-10 20:44:38.000000000 +0000
@@ -8,7 +8,7 @@
  *
  */
 
-#undef DEBUG
+#define DEBUG 1
 
 #include <linux/device.h>
 #include <linux/module.h>
diff -purN linux-2.5/drivers/base/class.c usb-2.5/drivers/base/class.c
--- linux-2.5/drivers/base/class.c	2003-11-07 14:48:28.000000000 +0000
+++ usb-2.5/drivers/base/class.c	2003-11-11 22:51:23.000000000 +0000
@@ -10,7 +10,7 @@
  *
  */
 
-#undef DEBUG
+#define DEBUG 1
 
 #include <linux/device.h>
 #include <linux/module.h>
diff -purN linux-2.5/drivers/base/core.c usb-2.5/drivers/base/core.c
--- linux-2.5/drivers/base/core.c	2003-09-29 21:20:44.000000000 +0000
+++ usb-2.5/drivers/base/core.c	2003-10-10 20:44:38.000000000 +0000
@@ -8,7 +8,7 @@
  *
  */
 
-#undef DEBUG
+#define DEBUG 1
 
 #include <linux/device.h>
 #include <linux/err.h>
diff -purN linux-2.5/drivers/base/driver.c usb-2.5/drivers/base/driver.c
--- linux-2.5/drivers/base/driver.c	2003-06-03 23:19:52.000000000 +0000
+++ usb-2.5/drivers/base/driver.c	2003-06-09 17:37:02.000000000 +0000
@@ -8,7 +8,7 @@
  *
  */
 
-#undef DEBUG
+#define DEBUG 1
 
 #include <linux/device.h>
 #include <linux/module.h>
diff -purN linux-2.5/drivers/char/Kconfig usb-2.5/drivers/char/Kconfig
--- linux-2.5/drivers/char/Kconfig	2003-10-22 05:10:32.000000000 +0000
+++ usb-2.5/drivers/char/Kconfig	2003-10-24 18:53:35.000000000 +0000
@@ -963,6 +963,13 @@ config SCx200_GPIO
 
 	  If compiled as a module, it will be called scx200_gpio.
 
+config FJKEYINFO
+	tristate "Fujitsu Lifebook Application Key Support"
+	help
+	  Provide support for Fujitsu Lifebook application keys.
+
+	  If compiled as a module, it will be called fjkeyinf.
+
 config RAW_DRIVER
 	tristate "RAW driver (/dev/raw/rawN)"
 	help
diff -purN linux-2.5/drivers/char/Makefile usb-2.5/drivers/char/Makefile
--- linux-2.5/drivers/char/Makefile	2003-10-22 05:10:32.000000000 +0000
+++ usb-2.5/drivers/char/Makefile	2003-10-24 18:53:35.000000000 +0000
@@ -71,6 +71,7 @@ obj-$(CONFIG_DZ) += dz.o
 obj-$(CONFIG_NWBUTTON) += nwbutton.o
 obj-$(CONFIG_NWFLASH) += nwflash.o
 obj-$(CONFIG_SCx200_GPIO) += scx200_gpio.o
+obj-$(CONFIG_FJKEYINFO) += fjkeyinf.o
 
 obj-$(CONFIG_WATCHDOG)	+= watchdog/
 obj-$(CONFIG_MWAVE) += mwave/
diff -purN linux-2.5/drivers/char/fjkeyinf.c usb-2.5/drivers/char/fjkeyinf.c
--- linux-2.5/drivers/char/fjkeyinf.c	1970-01-01 00:00:00.000000000 +0000
+++ usb-2.5/drivers/char/fjkeyinf.c	2003-08-12 16:04:01.000000000 +0000
@@ -0,0 +1,590 @@
+/*
+    SMBus client for the Fujitsu Siemens Lifebook C-6535 Application Panel
+    
+    Copyright (C) 2001 Jochen Eisinger <jochen.eisinger@gmx.net>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/ioport.h>
+#include <linux/types.h>
+#include <linux/mm.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <linux/i2c.h>
+#include <linux/i2c-id.h>
+#include <linux/miscdevice.h>
+
+/* Pulled what was needed from the userspace apanel.h file here */
+/* Make sure they match what the userspace tools were build against */
+
+/* Describes to which subsystem the ioctl applies. 'P' for proprietary? */
+#define APANEL_IOCTL_GROUP      'P'
+
+
+
+/*
+ * Use one ioctl for all devices
+ * This has the advantage that one interface is defined
+ * for all devices. The caps can tell what is possible on
+ * a certain device (with some defaults for each device
+ * of course which the programmer doesn't have to check
+ * explicitly like on/off for led and read for buttons).
+ */
+
+struct apanelcmd {
+	int device;           /* Device to operate command on (APANEL_DEV_GEN_*) */
+	int cmd;              /* Command to execute (APANEL_CMD_*) */
+	int data;             /* Data for command */
+};
+
+
+struct fj_device {
+	__u8	type;
+	__u8	access_method;
+	__u8	chip_type;
+	__u8	number;
+} __attribute__((packed));
+
+#define DEVICE_APPLICATION_BUTTONS	1
+#define DEVICE_CD_BUTTONS		2
+#define DEVICE_LCD			3
+#define DEVICE_LED_1			4
+#define DEVICE_LED_2			6
+#define DEVICE_APPLICATION_3_BUTTONS	7
+
+
+#define IOCTL_APANEL_CMD        _IOR(APANEL_IOCTL_GROUP,202,struct apanelcmd)
+
+
+/* Devices */
+#define APANEL_DEV_LED          1
+#define APANEL_DEV_LCD          2
+#define APANEL_DEV_CDBTN        3
+#define APANEL_DEV_APPBTN       4
+
+/*
+ * Commands
+ */
+
+/* Device capabilities */
+#define APANEL_CAP_ONOFF        1       /* Turn on/off */
+#define APANEL_CAP_GET          2       /* General get command */
+#define APANEL_CAP_SET          4       /* General set command */
+#define APANEL_CAP_BLINK        8       /* Blinking */
+#define APANEL_CAP_DUTY         0x10    /* Duty cycle of blinking */
+#define APANEL_CAP_RESET        0x20    /* Reset device */
+#define APANEL_CAP_MAX          0x40    /* Get highest possible value for */
+                                        /* set/get */
+#define APANEL_CAP_MIN          0x80    /* Get lowest possible value */
+#define APANEL_CMD_ONOFF        2
+#define APANEL_ONOFF_ON         1       /* Or is APANEL_ON nicer? */
+#define APANEL_ONOFF_OFF        0
+
+#define APANEL_CMD_SET          3
+#define APANEL_CMD_GET          4
+
+#define APANEL_CMD_BLINK        5       /* data=Blink frequency *0.01Hz or so */
+#define APANEL_CMD_DUTY         6       /* data=percentage high */
+
+#define APANEL_CMD_RESET        7       /* If this is useful at all */
+
+#define APANEL_CMD_MAX          8
+#define APANEL_CMD_MIN          9
+
+/*
+ * Button masks
+ */
+/* Masks for application buttons */
+#define APANEL_APPBTN_A         1
+#define APANEL_APPBTN_B         2
+#define APANEL_APPBTN_INTERNET  4
+#define APANEL_APPBTN_EMAIL     8
+
+/* Masks for cd buttons */
+#define APANEL_CDBTN_STOP       1
+#define APANEL_CDBTN_EJECT      2
+#define APANEL_CDBTN_PLAY       4
+#define APANEL_CDBTN_PAUSE      8
+#define APANEL_CDBTN_BACK       0x10
+#define APANEL_CDBTN_FORW       0x20
+
+
+
+/* print lots of useless debug infos */
+#define DEBUG
+
+#define MY_NAME	"fjkeyinf"
+
+#define dbg(format, arg...)					\
+	do {							\
+		if (debug)					\
+			printk(KERN_DEBUG "%s: " format,	\
+				MY_NAME , ## arg);		\
+	} while (0)
+
+static int debug = 1;
+
+/*
+ * this is the internal driver version number. There is no direct relationship
+ * between the hardware, the apanel protocol, or the driver versions
+ * However, this version number should be increased for every change
+ */
+/* current driver version */
+#define FJKEYINF_VERSION_MAJOR	0
+#define FJKEYINF_VERSION_MINOR	4
+
+/*
+ * This is the apanel version this driver implements. This _must_ be the
+ * same as your apanel.h file
+ */
+/* protocol version */
+#define FJKEYINF_APANEL_MAJOR	1
+#define FJKEYINF_APANEL_MINOR	0
+
+/*
+ * Some real leet m4cr0s
+ */
+#define STRINGIFY1(x)	#x
+#define STRINGIFY(x)	STRINGIFY1(x)
+
+#define PASTE1(x,y)	x##y
+#define PASTE(x,y)	PASTE1(x,y)
+
+/*
+ * This is the version of the driver as a string
+ */
+#define FJKEYINF_VERSION_STRING	PASTE("v",				\
+				PASTE(STRINGIFY(FJKEYINF_VERSION_MAJOR),\
+				PASTE(".",STRINGIFY(FJKEYINF_VERSION_MINOR))))
+
+/*
+ * This is the version of the protocol as a string
+ */
+#define FJKEYINF_APANEL_VERSION_STRING	PASTE("v",			\
+					PASTE(STRINGIFY(FJKEYINF_APANEL_MAJOR),\
+					PASTE(".",			\
+					STRINGIFY(FJKEYINF_APANEL_MINOR))))
+
+/* 
+ * every i2c device has to register to the i2c sub-system. Therefor it needs
+ * a driver id. We should be I2C_DRIVERID_FJKEYINF. However, if this isn't
+ * defined in i2c-id.h, we'll use a generic id.
+ */
+#ifndef I2C_DRIVERID_FJKEYINF
+#define I2C_DRIVERID_FJKEYINF	0xF000
+#endif
+
+/*
+ * Yes, it's unbelievable, but me crappy driver has an official devices
+ * entry. It's register as a misc-device (char-major-10) minor 216. The
+ * location should be /dev/fujitsu/apanel... after all, it seems to be
+ * a quite c00l driver ;>
+ */
+#define FJKEYINF_CHAR_MINOR	216
+
+/*
+ * Modules can store nice extra infos...
+ */
+MODULE_AUTHOR("Jochen Eisinger <jochen.eisinger@gmx.net>");
+MODULE_DESCRIPTION("Application Panel driver for Lifebook C-series");
+MODULE_LICENSE("GPL");
+
+/*
+ * So, let's start the hackin'
+ *
+ * we first define the interface for the i2c driver, cuz the misc device
+ * part uses the struct fjkeyinf_client. also note that this struct is
+ * static where it would be better to dynamically allocate one... but what
+ * fsck, more than one apanel your crappy laptop won't have...
+ */
+
+/* definitions for i2c (smbus) interface */
+
+/* forward declaration of the interface procedures */
+
+/* detach removes the smbus driver from the system */
+	static int fjkeyinf_detach(struct i2c_client *client);
+/* attach tries to attach to a given smbus */
+	static int fjkeyinf_attach(struct i2c_adapter *adap);
+
+/* this structur defines the interface to the i2c sub-system */
+static struct i2c_driver fjkeyinf_driver = {
+	.owner		= THIS_MODULE,
+	.name		= "fujitsu_panel" /* FJKEYINF_VERSION_STRING */,
+	.id		= I2C_DRIVERID_FJKEYINF,
+	.flags		= I2C_DF_NOTIFY,
+	.attach_adapter	= &fjkeyinf_attach,
+	.detach_client	= &fjkeyinf_detach,
+	.command	= NULL,
+};
+
+
+/* Addresses to scan. afaik the device is at id 0x18. so we only scan this */
+static unsigned short normal_i2c[] = {0x18,I2C_CLIENT_END};
+static unsigned short normal_i2c_range[] = {I2C_CLIENT_END};
+
+/* 
+ * generate some stupid additional structures. we don't really care about
+ * this
+ */
+I2C_CLIENT_INSMOD;
+
+
+/*
+ * If we've found the device, we have to provide an i2c_client structure
+ * to the i2c subsystem with which this devices can be accessed. as I stated
+ * above, there's max. 1 device, so I use _one static_ entry
+ */
+static struct i2c_client fjkeyinf_client = 
+{
+	.id =		-1,
+	.flags =	0,
+	.addr =		0,
+	.adapter =	NULL,
+	.driver =	&fjkeyinf_driver,
+	.name =		"fjkeyinf",
+};
+
+
+/*
+ * luckily, the c-series laptops have a configuration block in there BIOS.
+ * so we can use it to detect the presence of the apanel device. There's
+ * also a checksum somewhere, but we don't care about it.
+ *
+ * Note the first 8 characters. that's where this strange driver name comes
+ * from.
+ *
+ * The configuration block can be found at 0x000FFA30
+ *
+ * There should also be an access method 3, but I don't know much about it.
+ * Basically there should also be an LCD device. but my notebook hasn't one
+ * so I don't know what the configuration block looks like
+ *
+ * type 1 is LED type 4 ist BUTTONS, probably 2 is LCD.
+ */
+static const unsigned char fjkeyinf_info[16] = {
+	'F', 'J', 'K', 'E', 'Y', 'I', 'N', 'F',
+	/* device 0 */	/* type		*/	1,
+			/* access method*/	1,
+			/* enabled	*/	1,
+			/* smbus device	*/	0x30,
+	/* device 1 */	/* type		*/	4,
+			/* access method*/	1,
+			/* enabled	*/	1,
+			/* smbus device */	0x30};
+
+#define FJKEYINF_INFO_ADDR	0x000FFA30
+#define FJKEYINF_INFO_ADDR	0x000F6f20	/* Address for the P2120 */
+
+/*
+ * the following functions implement the ioctls. Note however, that not
+ * much is implemented yet.
+ */
+
+/* turn a device on or off */
+
+int fjkeyinf_onoff(int dev, int state)
+{
+
+	switch (dev) {
+
+		case APANEL_DEV_LED:
+
+			if (state) {
+				dbg("turning LED on...\n");
+
+				i2c_smbus_write_word_data(&fjkeyinf_client,
+					       0x10, 0x8080);
+				i2c_smbus_write_word_data(&fjkeyinf_client,
+					       0x0f, 0x100);
+				i2c_smbus_write_word_data(&fjkeyinf_client,
+					       0x11, 1);
+
+			} else {
+				
+				dbg("turning LED off...\n");
+
+				i2c_smbus_write_word_data(&fjkeyinf_client,
+					       0x10, 0);
+				i2c_smbus_write_word_data(&fjkeyinf_client,
+					       0x0f, 0x100);
+				i2c_smbus_write_word_data(&fjkeyinf_client,
+					       0x11, 0);
+
+
+			}
+
+			return state;
+
+		default:
+
+			printk(KERN_NOTICE
+				"fjkeyinf: ONOFF called for invalid device"
+				" (dev %d, state %d)\n", dev, state);
+
+			return -EINVAL;
+
+	}
+
+}
+
+/* gets the current value from a device */
+int fjkeyinf_get(int dev)
+{
+	switch (dev) {
+		case APANEL_DEV_LED:
+			return ((i2c_smbus_read_word_data
+					(&fjkeyinf_client, 0x00) >> 7) & 1);
+
+		case APANEL_DEV_APPBTN:
+			{
+				int state;
+
+				state = i2c_smbus_read_word_data
+					(&fjkeyinf_client, 0x00);
+
+				state = (state >> 8) & 0x0f;
+
+				state ^= 0x0f;
+
+				return (((state & 1) ? APANEL_APPBTN_EMAIL : 0)
+					+ ((state & 2) ? APANEL_APPBTN_INTERNET : 0)
+					+ ((state & 4) ? APANEL_APPBTN_A : 0)
+					+ ((state & 8) ? APANEL_APPBTN_B : 0));
+			}
+
+		default:
+			printk(KERN_NOTICE "fjkeyinf: GET called for invalid"
+					" device (dev %d)\n", dev);
+			return -EINVAL;
+	}
+}
+
+
+
+/* 
+ * file operations for /dev/fujitsu/apanel
+ * 
+ * That what the name says: file operation. pretty basic stuff follows
+ */
+			
+/*
+ * if somebody opens us, we just realize and let him pass
+ */
+static int fjkeyinf_open (struct inode *inode, struct file *filp)
+{
+	dbg("open called for /dev/fujitsu/apanel\n");
+	return 0;
+}
+
+/* same with close */
+static int fjkeyinf_close (struct inode *inode, struct file *filp)
+{
+	dbg("close called for /dev/fujitsu/apanel\n");
+	return 0;
+}
+
+/* all commands are passed using the ioctl interface. so we have to decide
+ * here, what we have to do */
+int fjkeyinf_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+		unsigned long args)
+{
+	struct apanelcmd *acmd;
+
+	dbg("ioctl (cmd: %u, args: 0x%08lx)\n", cmd, args);
+
+	/* Let's see, what they want from us... */
+	
+	switch (cmd) {
+		case IOCTL_APANEL_CMD:
+			/* the actual command is passed in a apanelcmd
+			 * structure */
+
+			if (!(args)) {
+
+				printk(KERN_NOTICE "fjkeyinf: invalid apanel command "
+						"(NULL pointer)\n");
+				return -EINVAL;
+
+			}
+
+			acmd = (struct apanelcmd *)args;
+
+			/* although not all commands are implemented, we
+			 * understand all... */
+
+			dbg("apanel command %d\n", acmd->cmd);
+
+
+			switch (acmd->cmd) {
+				case APANEL_CMD_ONOFF:
+					return fjkeyinf_onoff(acmd->device,
+							acmd->data);
+
+				case APANEL_CMD_GET:
+					return fjkeyinf_get(acmd->device);
+
+				default:
+					printk(KERN_NOTICE "fjkeyinf: unknown "
+						"device/command %d/%d\n",
+						acmd->device, acmd->cmd);
+					return -EINVAL;
+			}
+
+		default:
+			printk(KERN_NOTICE "fjkeyinf: unknown ioctl code %u\n", cmd);
+			return -EINVAL;
+	}
+}
+
+/* now we tell the misc_device what nice functions we've implemented */
+static struct file_operations fjkeyinf_fops = {
+	.owner =	THIS_MODULE,
+	.ioctl =	fjkeyinf_ioctl,
+	.open =		fjkeyinf_open,
+	.release =	fjkeyinf_close,
+};
+
+/* misc dev entry. We need this to register to the misc dev driver */
+static struct miscdevice fjkeyinf_dev = {
+	FJKEYINF_CHAR_MINOR,
+	"apanel",
+	&fjkeyinf_fops
+};
+
+
+/* Now comes the i2c driver stuff. This is pretty straight forward, just as they
+ * described it in their docu.
+ */
+
+/* basically this function should probe the i2c client, but we know that it has
+ * to be the one we're looking for - and I have no idea how I should probe for
+ * it, so we just register... */
+static int fjkeyinf_probe(struct i2c_adapter *adap, int addr, int kind)
+{
+	int result;
+        fjkeyinf_client.adapter = adap;
+        fjkeyinf_client.addr = addr;
+
+	dbg("%s\n", __FUNCTION__);
+	if ((result = misc_register(&fjkeyinf_dev)) < 0) {
+		printk(KERN_NOTICE "fjkeyinf: could not register misc device (%d)\n",
+				result);
+		return result;
+	}
+
+        i2c_attach_client(&fjkeyinf_client);
+
+	printk(KERN_INFO "fjkeyinf: Application Panel Driver "
+		       	/*FJKEYINF_VERSION_STRING*/ "\n");
+	printk(KERN_INFO "fjkeyinf: Copyright (c) 2001 by "
+		"Jochen Eisinger <jochen.eisinger@gmx.net>\n");
+
+	
+	dbg("driver loaded at address 0x%02x...\n", addr);
+	
+	return 0;
+}
+
+
+/* this function is invoked, when we should release our resource... */
+static int fjkeyinf_detach(struct i2c_client *client)
+{
+	dbg("driver detached...\n");
+
+	misc_deregister(&fjkeyinf_dev);
+		
+	i2c_detach_client(client);
+	
+	return 0;
+}
+
+/* this function is invoked for every i2c adapter, that has a device at the
+ * address we've specified */
+static int fjkeyinf_attach(struct i2c_adapter *adap)
+{
+	dbg("%s\n", __FUNCTION__);
+	return i2c_probe(adap, &addr_data, fjkeyinf_probe);
+}
+
+
+
+/* startup */
+static int __init fjkeyinf_init(void)
+{
+	unsigned char *fujitsu_bios = __va(FJKEYINF_INFO_ADDR);
+//	int ctr;
+	struct fj_device	*dev;
+	
+	if (__pa(high_memory) < (FJKEYINF_INFO_ADDR - 16)) {
+		dbg("Fujitsu BIOS not found...\n");
+		return -ENODEV;
+	}
+
+	dbg("Configuration block [%c%c%c%c%c%c%c%c] "
+		"(%d, %d, %d, 0x%02x) (%d, %d, %d, 0x%02x)\n",
+		fujitsu_bios[0],
+		fujitsu_bios[1],
+		fujitsu_bios[2],
+		fujitsu_bios[3],
+		fujitsu_bios[4],
+		fujitsu_bios[5],
+		fujitsu_bios[6],
+		fujitsu_bios[7],
+		(int)fujitsu_bios[8],
+		(int)fujitsu_bios[9],
+		(int)fujitsu_bios[10],
+		(int)fujitsu_bios[11],
+		(int)fujitsu_bios[12],
+		(int)fujitsu_bios[13],
+		(int)fujitsu_bios[14],
+		(int)fujitsu_bios[15]);
+
+	dev = (struct fj_device *)&fujitsu_bios[8];
+	while (1) {
+		if (dev->type == 0)
+			break;
+		dbg("type = %d, access_method = %d, chip_type = %d, number = %d\n",
+		    dev->type, dev->access_method, dev->chip_type, dev->number);
+		++dev;
+	}
+	
+//	for (ctr=0 ; ctr<16 ; ctr++)
+//		if (fujitsu_bios[ctr] != fjkeyinf_info[ctr]) {
+//			dbg("device not found...\n");
+//			return -ENODEV;
+//		}
+
+	dbg("device found...\n");
+	
+	i2c_add_driver(&fjkeyinf_driver);
+	return 0;
+}
+
+static void __exit fjkeyinf_exit(void)
+{
+	i2c_del_driver(&fjkeyinf_driver);
+}
+
+module_init(fjkeyinf_init);
+module_exit(fjkeyinf_exit);
+
diff -purN linux-2.5/drivers/char/mem.c usb-2.5/drivers/char/mem.c
--- linux-2.5/drivers/char/mem.c	2003-10-22 05:10:25.000000000 +0000
+++ usb-2.5/drivers/char/mem.c	2003-10-24 18:53:35.000000000 +0000
@@ -24,6 +24,7 @@
 #include <linux/smp_lock.h>
 #include <linux/devfs_fs_kernel.h>
 #include <linux/ptrace.h>
+#include <linux/device.h>
 
 #include <asm/uaccess.h>
 #include <asm/io.h>
@@ -657,7 +658,7 @@ static struct file_operations memory_fop
 	.open		= memory_open,	/* just a selector for the real open */
 };
 
-static const struct {
+static const struct mem_dev {
 	unsigned int		minor;
 	char			*name;
 	umode_t			mode;
@@ -676,6 +677,23 @@ static const struct {
 	{11,"kmsg",    S_IRUGO | S_IWUSR,           &kmsg_fops},
 };
 
+static void release_mem_dev(struct class_device *class_dev)
+{
+	kfree(class_dev);
+}
+
+static struct class mem_class = {
+	.name		= "mem",
+	.release	= &release_mem_dev,
+};
+
+static ssize_t show_dev(struct class_device *class_dev, char *buf)
+{
+	struct mem_dev *mem_dev = class_get_devdata(class_dev);
+	return print_dev_t(buf, MKDEV(MEM_MAJOR, mem_dev->minor));
+}
+static CLASS_DEVICE_ATTR(dev, S_IRUGO, show_dev, NULL);
+
 static int __init chr_dev_init(void)
 {
 	int i;
@@ -683,7 +701,20 @@ static int __init chr_dev_init(void)
 	if (register_chrdev(MEM_MAJOR,"mem",&memory_fops))
 		printk("unable to get major %d for memory devs\n", MEM_MAJOR);
 
+	class_register(&mem_class);
 	for (i = 0; i < ARRAY_SIZE(devlist); i++) {
+		struct class_device *class_dev;
+
+		class_dev = kmalloc(sizeof(*class_dev), GFP_KERNEL);
+		if (class_dev) {
+			memset(class_dev, 0x00, sizeof(*class_dev));
+			class_dev->class = &mem_class;
+			strncpy(class_dev->class_id, devlist[i].name, BUS_ID_SIZE);
+			class_set_devdata(class_dev, (void *)&devlist[i]);
+			if (!class_device_register(class_dev));
+				class_device_create_file(class_dev, &class_device_attr_dev);
+		}
+
 		devfs_mk_cdev(MKDEV(MEM_MAJOR, devlist[i].minor),
 				S_IFCHR | devlist[i].mode, devlist[i].name);
 	}
diff -purN linux-2.5/drivers/char/misc.c usb-2.5/drivers/char/misc.c
--- linux-2.5/drivers/char/misc.c	2003-10-04 12:55:45.000000000 +0000
+++ usb-2.5/drivers/char/misc.c	2003-12-10 01:44:11.000000000 +0000
@@ -47,7 +47,7 @@
 #include <linux/devfs_fs_kernel.h>
 #include <linux/stat.h>
 #include <linux/init.h>
-
+#include <linux/device.h>
 #include <linux/tty.h>
 #include <linux/kmod.h>
 
@@ -180,6 +180,91 @@ fail:
 	return err;
 }
 
+/* Misc class implementation */
+
+/* 
+ * TODO for 2.7:
+ *  - add a struct class_device to struct miscdevice and make all usages of
+ *    them dynamic.  This will let us get rid of struct misc_dev below.
+ */
+struct misc_dev {
+	struct list_head node;
+	dev_t dev;
+	struct class_device class_dev;
+};
+#define to_misc_dev(d) container_of(d, struct misc_dev, class_dev)
+
+static LIST_HEAD(misc_dev_list);
+static spinlock_t misc_dev_list_lock = SPIN_LOCK_UNLOCKED;
+
+static void release_misc_dev(struct class_device *class_dev)
+{
+	struct misc_dev *misc_dev = to_misc_dev(class_dev);
+	kfree(misc_dev);
+}
+
+static struct class misc_class = {
+	.name		= "misc",
+	.release	= &release_misc_dev,
+};
+
+static ssize_t show_dev(struct class_device *class_dev, char *buf)
+{
+	struct misc_dev *misc_dev = to_misc_dev(class_dev);
+	return print_dev_t(buf, misc_dev->dev);
+}
+static CLASS_DEVICE_ATTR(dev, S_IRUGO, show_dev, NULL);
+
+static void misc_add_class_device(struct miscdevice *misc)
+{
+	struct misc_dev *misc_dev = NULL;
+	int retval;
+
+	misc_dev = kmalloc(sizeof(*misc_dev), GFP_KERNEL);
+	if (!misc_dev)
+		return;
+	memset(misc_dev, 0x00, sizeof(*misc_dev));
+
+	misc_dev->dev = MKDEV(MISC_MAJOR, misc->minor);
+	misc_dev->class_dev.dev = misc->dev;
+	misc_dev->class_dev.class = &misc_class;
+	snprintf(misc_dev->class_dev.class_id, BUS_ID_SIZE, "%s", misc->name);
+	retval = class_device_register(&misc_dev->class_dev);
+	if (retval)
+		goto error;
+	class_device_create_file(&misc_dev->class_dev, &class_device_attr_dev);
+	spin_lock(&misc_dev_list_lock);
+	list_add(&misc_dev->node, &misc_dev_list);
+	spin_unlock(&misc_dev_list_lock);
+	return;
+error:
+	kfree(misc_dev);
+}
+
+static void misc_remove_class_device(struct miscdevice *misc)
+{
+	struct misc_dev *misc_dev = NULL;
+	struct list_head *tmp;
+	int found = 0;
+
+	spin_lock(&misc_dev_list_lock);
+	list_for_each(tmp, &misc_dev_list) {
+		misc_dev = list_entry(tmp, struct misc_dev, node);
+		if ((MINOR(misc_dev->dev) == misc->minor)) {
+			found = 1;
+			break;
+		}
+	}
+	if (found) {
+		list_del(&misc_dev->node);
+		spin_unlock(&misc_dev_list_lock);
+		class_device_unregister(&misc_dev->class_dev);
+	} else {
+		spin_unlock(&misc_dev_list_lock);
+	}
+}
+
+
 static struct file_operations misc_fops = {
 	.owner		= THIS_MODULE,
 	.open		= misc_open,
@@ -236,6 +321,7 @@ int misc_register(struct miscdevice * mi
 
 	devfs_mk_cdev(MKDEV(MISC_MAJOR, misc->minor),
 			S_IFCHR|S_IRUSR|S_IWUSR|S_IRGRP, misc->devfs_name);
+	misc_add_class_device(misc);
 
 	/*
 	 * Add it to the front, so that later devices can "override"
@@ -265,6 +351,7 @@ int misc_deregister(struct miscdevice * 
 
 	down(&misc_sem);
 	list_del(&misc->list);
+	misc_remove_class_device(misc);
 	devfs_remove(misc->devfs_name);
 	if (i < DYNAMIC_MINORS && i>0) {
 		misc_minors[i>>3] &= ~(1 << (misc->minor & 7));
@@ -285,6 +372,7 @@ static int __init misc_init(void)
 	if (ent)
 		ent->proc_fops = &misc_proc_fops;
 #endif
+	class_register(&misc_class);
 #ifdef CONFIG_MVME16x
 	rtc_MK48T08_init();
 #endif
@@ -319,4 +407,4 @@ static int __init misc_init(void)
 	}
 	return 0;
 }
-module_init(misc_init);
+subsys_initcall(misc_init);
diff -purN linux-2.5/drivers/char/sysrq.c usb-2.5/drivers/char/sysrq.c
--- linux-2.5/drivers/char/sysrq.c	2003-09-24 06:09:46.000000000 +0000
+++ usb-2.5/drivers/char/sysrq.c	2003-09-26 16:37:41.000000000 +0000
@@ -266,7 +266,7 @@ static struct sysrq_key_op *sysrq_key_ta
 /* v */	NULL, /* May be assigned at init time by SMP VOYAGER */
 /* w */	NULL,
 /* x */	NULL,
-/* y */	NULL,
+/* y */	&sysrq_mountro_op,	/* stupid fujitsu laptop, can't hit the U key */
 /* z */	NULL
 };
 
diff -purN linux-2.5/drivers/char/vc_screen.c usb-2.5/drivers/char/vc_screen.c
--- linux-2.5/drivers/char/vc_screen.c	2003-08-26 16:25:41.000000000 +0000
+++ usb-2.5/drivers/char/vc_screen.c	2003-12-09 00:49:27.000000000 +0000
@@ -36,6 +36,7 @@
 #include <linux/kbd_kern.h>
 #include <linux/console.h>
 #include <linux/smp_lock.h>
+#include <linux/device.h>
 #include <asm/uaccess.h>
 #include <asm/byteorder.h>
 #include <asm/unaligned.h>
@@ -469,6 +470,85 @@ static struct file_operations vcs_fops =
 	.open		= vcs_open,
 };
 
+/* vc class implementation */
+
+struct vc_dev {
+	struct list_head node;
+	dev_t dev;
+	struct class_device class_dev;
+};
+#define to_vc_dev(d) container_of(d, struct vc_dev, class_dev)
+
+static LIST_HEAD(vc_dev_list);
+static spinlock_t vc_dev_list_lock = SPIN_LOCK_UNLOCKED;
+
+static void release_vc_dev(struct class_device *class_dev)
+{
+	struct vc_dev *vc_dev = to_vc_dev(class_dev);
+	kfree(vc_dev);
+}
+
+static struct class vc_class = {
+	.name		= "vc",
+	.release	= &release_vc_dev,
+};
+
+static ssize_t show_dev(struct class_device *class_dev, char *buf)
+{
+	struct vc_dev *vc_dev = to_vc_dev(class_dev);
+	return print_dev_t(buf, vc_dev->dev);
+}
+static CLASS_DEVICE_ATTR(dev, S_IRUGO, show_dev, NULL);
+
+static int vc_add_class_device(dev_t dev, char *name, int minor)
+{
+	struct vc_dev *vc_dev = NULL;
+	int retval;
+
+	vc_dev = kmalloc(sizeof(*vc_dev), GFP_KERNEL);
+	if (!vc_dev)
+		return -ENOMEM;
+	memset(vc_dev, 0x00, sizeof(*vc_dev));
+
+	vc_dev->dev = dev;
+	vc_dev->class_dev.class = &vc_class;
+	snprintf(vc_dev->class_dev.class_id, BUS_ID_SIZE, name, minor);
+	retval = class_device_register(&vc_dev->class_dev);
+	if (retval)
+		goto error;
+	class_device_create_file(&vc_dev->class_dev, &class_device_attr_dev);
+	spin_lock(&vc_dev_list_lock);
+	list_add(&vc_dev->node, &vc_dev_list);
+	spin_unlock(&vc_dev_list_lock);
+	return 0;
+error:
+	kfree(vc_dev);
+	return retval;
+}
+
+static void vc_remove_class_device(int minor)
+{
+	struct vc_dev *vc_dev = NULL;
+	struct list_head *tmp;
+	int found = 0;
+
+	spin_lock(&vc_dev_list_lock);
+	list_for_each(tmp, &vc_dev_list) {
+		vc_dev = list_entry(tmp, struct vc_dev, node);
+		if (MINOR(vc_dev->dev) == minor) {
+			found = 1;
+			break;
+		}
+	}
+	if (found) {
+		list_del(&vc_dev->node);
+		spin_unlock(&vc_dev_list_lock);
+		class_device_unregister(&vc_dev->class_dev);
+	} else {
+		spin_unlock(&vc_dev_list_lock);
+	}
+}
+
 void vcs_make_devfs(struct tty_struct *tty)
 {
 	devfs_mk_cdev(MKDEV(VCS_MAJOR, tty->index + 1),
@@ -477,19 +557,26 @@ void vcs_make_devfs(struct tty_struct *t
 	devfs_mk_cdev(MKDEV(VCS_MAJOR, tty->index + 129),
 			S_IFCHR|S_IRUSR|S_IWUSR,
 			"vcc/a%u", tty->index + 1);
+	vc_add_class_device(MKDEV(VCS_MAJOR, tty->index + 1), "vcs%u", tty->index + 1);
+	vc_add_class_device(MKDEV(VCS_MAJOR, tty->index + 129), "vcsa%u", tty->index + 1);
 }
 void vcs_remove_devfs(struct tty_struct *tty)
 {
 	devfs_remove("vcc/%u", tty->index + 1);
 	devfs_remove("vcc/a%u", tty->index + 1);
+	vc_remove_class_device(tty->index + 1);
+	vc_remove_class_device(tty->index + 129);
 }
 
 int __init vcs_init(void)
 {
 	if (register_chrdev(VCS_MAJOR, "vcs", &vcs_fops))
 		panic("unable to get major %d for vcs device", VCS_MAJOR);
+	class_register(&vc_class);
 
 	devfs_mk_cdev(MKDEV(VCS_MAJOR, 0), S_IFCHR|S_IRUSR|S_IWUSR, "vcc/0");
 	devfs_mk_cdev(MKDEV(VCS_MAJOR, 128), S_IFCHR|S_IRUSR|S_IWUSR, "vcc/a0");
+	vc_add_class_device(MKDEV(VCS_MAJOR, 0), "vcs", 0);
+	vc_add_class_device(MKDEV(VCS_MAJOR, 128), "vcsa", 128);
 	return 0;
 }
diff -purN linux-2.5/drivers/i2c/algos/i2c-algo-bit.c usb-2.5/drivers/i2c/algos/i2c-algo-bit.c
--- linux-2.5/drivers/i2c/algos/i2c-algo-bit.c	2003-09-23 13:29:27.000000000 +0000
+++ usb-2.5/drivers/i2c/algos/i2c-algo-bit.c	2003-11-15 15:42:51.000000000 +0000
@@ -18,10 +18,8 @@
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.		     */
 /* ------------------------------------------------------------------------- */
 
-/* With some changes from Kysti Mlkki <kmalkki@cc.hut.fi> and even
-   Frodo Looijaard <frodol@dds.nl> */
-
-/* $Id: i2c-algo-bit.c,v 1.44 2003/01/21 08:08:16 kmalkki Exp $ */
+/* With some changes from Frodo Looijaard <frodol@dds.nl>, Kysti Mlkki
+   <kmalkki@cc.hut.fi> and Jean Delvare <khali@linux-fr.org> */
 
 /* #define DEBUG 1 */
 
@@ -87,8 +85,10 @@ static inline int sclhi(struct i2c_algo_
 	setscl(adap,1);
 
 	/* Not all adapters have scl sense line... */
-	if (adap->getscl == NULL )
+	if (adap->getscl == NULL ) {
+		udelay(adap->udelay);
 		return 0;
+	}
 
 	start=jiffies;
 	while (! getscl(adap) ) {	
@@ -222,68 +222,72 @@ static int i2c_inb(struct i2c_adapter *i
  */
 static int test_bus(struct i2c_algo_bit_data *adap, char* name) {
 	int scl,sda;
+
+	if (adap->getscl==NULL)
+		printk(KERN_INFO "i2c-algo-bit.o: Testing SDA only, "
+			"SCL is not readable.\n");
+
 	sda=getsda(adap);
-	if (adap->getscl==NULL) {
-		printk(KERN_WARNING "i2c-algo-bit.o: Warning: Adapter can't read from clock line - skipping test.\n");
-		return 0;		
-	}
-	scl=getscl(adap);
-	printk(KERN_INFO "i2c-algo-bit.o: Adapter: %s scl: %d  sda: %d -- testing...\n",
-	       name,getscl(adap),getsda(adap));
+	scl=(adap->getscl==NULL?1:getscl(adap));
+	printk(KERN_DEBUG "i2c-algo-bit.o: (0) scl=%d, sda=%d\n",scl,sda);
 	if (!scl || !sda ) {
-		printk(KERN_INFO " i2c-algo-bit.o: %s seems to be busy.\n",name);
+		printk(KERN_WARNING "i2c-algo-bit.o: %s seems to be busy.\n", name);
 		goto bailout;
 	}
+
 	sdalo(adap);
-	printk(KERN_DEBUG "i2c-algo-bit.o:1 scl: %d  sda: %d \n",getscl(adap),
-	       getsda(adap));
-	if ( 0 != getsda(adap) ) {
-		printk(KERN_WARNING "i2c-algo-bit.o: %s SDA stuck high!\n",name);
-		sdahi(adap);
+	sda=getsda(adap);
+	scl=(adap->getscl==NULL?1:getscl(adap));
+	printk(KERN_DEBUG "i2c-algo-bit.o: (1) scl=%d, sda=%d\n",scl,sda);
+	if ( 0 != sda ) {
+		printk(KERN_WARNING "i2c-algo-bit.o: SDA stuck high!\n");
 		goto bailout;
 	}
-	if ( 0 == getscl(adap) ) {
-		printk(KERN_WARNING "i2c-algo-bit.o: %s SCL unexpected low while pulling SDA low!\n",
-			name);
+	if ( 0 == scl ) {
+		printk(KERN_WARNING "i2c-algo-bit.o: SCL unexpected low "
+			"while pulling SDA low!\n");
 		goto bailout;
 	}		
+
 	sdahi(adap);
-	printk(KERN_DEBUG "i2c-algo-bit.o:2 scl: %d  sda: %d \n",getscl(adap),
-	       getsda(adap));
-	if ( 0 == getsda(adap) ) {
-		printk(KERN_WARNING "i2c-algo-bit.o: %s SDA stuck low!\n",name);
-		sdahi(adap);
+	sda=getsda(adap);
+	scl=(adap->getscl==NULL?1:getscl(adap));
+	printk(KERN_DEBUG "i2c-algo-bit.o: (2) scl=%d, sda=%d\n",scl,sda);
+	if ( 0 == sda ) {
+		printk(KERN_WARNING "i2c-algo-bit.o: SDA stuck low!\n");
 		goto bailout;
 	}
-	if ( 0 == getscl(adap) ) {
-		printk(KERN_WARNING "i2c-algo-bit.o: %s SCL unexpected low while SDA high!\n",
-		       name);
-	goto bailout;
+	if ( 0 == scl ) {
+		printk(KERN_WARNING "i2c-algo-bit.o: SCL unexpected low "
+			"while pulling SDA high!\n");
+		goto bailout;
 	}
+
 	scllo(adap);
-	printk(KERN_DEBUG "i2c-algo-bit.o:3 scl: %d  sda: %d \n",getscl(adap),
-	       getsda(adap));
-	if ( 0 != getscl(adap) ) {
-		printk(KERN_WARNING "i2c-algo-bit.o: %s SCL stuck high!\n",name);
-		sclhi(adap);
+	sda=getsda(adap);
+	scl=(adap->getscl==NULL?0:getscl(adap));
+	printk(KERN_DEBUG "i2c-algo-bit.o: (3) scl=%d, sda=%d\n",scl,sda);
+	if ( 0 != scl ) {
+		printk(KERN_WARNING "i2c-algo-bit.o: SCL stuck high!\n");
 		goto bailout;
 	}
-	if ( 0 == getsda(adap) ) {
-		printk(KERN_WARNING "i2c-algo-bit.o: %s SDA unexpected low while pulling SCL low!\n",
-			name);
+	if ( 0 == sda ) {
+		printk(KERN_WARNING "i2c-algo-bit.o: SDA unexpected low "
+			"while pulling SCL low!\n");
 		goto bailout;
 	}
+	
 	sclhi(adap);
-	printk(KERN_DEBUG "i2c-algo-bit.o:4 scl: %d  sda: %d \n",getscl(adap),
-	       getsda(adap));
-	if ( 0 == getscl(adap) ) {
-		printk(KERN_WARNING "i2c-algo-bit.o: %s SCL stuck low!\n",name);
-		sclhi(adap);
+	sda=getsda(adap);
+	scl=(adap->getscl==NULL?1:getscl(adap));
+	printk(KERN_DEBUG "i2c-algo-bit.o: (4) scl=%d, sda=%d\n",scl,sda);
+	if ( 0 == scl ) {
+		printk(KERN_WARNING "i2c-algo-bit.o: SCL stuck low!\n");
 		goto bailout;
 	}
-	if ( 0 == getsda(adap) ) {
-		printk(KERN_WARNING "i2c-algo-bit.o: %s SDA unexpected low while SCL high!\n",
-			name);
+	if ( 0 == sda ) {
+		printk(KERN_WARNING "i2c-algo-bit.o: SDA unexpected low "
+			"while pulling SCL high!\n");
 		goto bailout;
 	}
 	printk(KERN_INFO "i2c-algo-bit.o: %s passed test.\n",name);
diff -purN linux-2.5/drivers/i2c/busses/Kconfig usb-2.5/drivers/i2c/busses/Kconfig
--- linux-2.5/drivers/i2c/busses/Kconfig	2003-10-10 11:14:48.000000000 +0000
+++ usb-2.5/drivers/i2c/busses/Kconfig	2003-11-29 17:31:41.000000000 +0000
@@ -161,11 +161,12 @@ config I2C_PIIX4
 	help
 	  If you say yes to this option, support will be included for the Intel
 	  PIIX4 family of mainboard I2C interfaces.  Specifically, the following
-	  versions of the chipset is supported:
+	  versions of the chipset are supported:
 	    Intel PIIX4
 	    Intel 440MX
 	    Serverworks OSB4
 	    Serverworks CSB5
+	    Serverworks CSB6
 	    SMSC Victory66
 
 	  This driver can also be built as a module.  If so, the module
@@ -309,6 +310,7 @@ config I2C_VIAPRO
 	  8233
 	  8233A
 	  8235
+	  8237
 
 	  This driver can also be built as a module.  If so, the module
 	  will be called i2c-viapro.
diff -purN linux-2.5/drivers/i2c/busses/i2c-amd756.c usb-2.5/drivers/i2c/busses/i2c-amd756.c
--- linux-2.5/drivers/i2c/busses/i2c-amd756.c	2003-09-12 00:52:12.000000000 +0000
+++ usb-2.5/drivers/i2c/busses/i2c-amd756.c	2003-12-13 18:01:40.000000000 +0000
@@ -28,10 +28,12 @@
     2002-04-08: Added nForce support. (Csaba Halasz)
     2002-10-03: Fixed nForce PnP I/O port. (Michael Steil)
     2002-12-28: Rewritten into something that resembles a Linux driver (hch)
+    2003-11-29: Added back AMD8111 removed by the previous rewrite.
+                (Philip Pokorny)
 */
 
 /*
-   Supports AMD756, AMD766, AMD768 and nVidia nForce
+   Supports AMD756, AMD766, AMD768, AMD8111 and nVidia nForce
    Note: we assume there can only be one device, with one SMBus interface.
 */
 
@@ -213,9 +215,8 @@ static s32 amd756_access(struct i2c_adap
 	case I2C_SMBUS_BYTE:
 		outw_p(((addr & 0x7f) << 1) | (read_write & 0x01),
 		       SMB_HOST_ADDRESS);
-		/* TODO: Why only during write? */
 		if (read_write == I2C_SMBUS_WRITE)
-			outb_p(command, SMB_HOST_COMMAND);
+			outb_p(command, SMB_HOST_DATA);
 		size = AMD756_BYTE;
 		break;
 	case I2C_SMBUS_BYTE_DATA:
@@ -308,12 +309,13 @@ static struct i2c_adapter amd756_adapter
 	.name		= "unset",
 };
 
-enum chiptype { AMD756, AMD766, AMD768, NFORCE };
+enum chiptype { AMD756, AMD766, AMD768, NFORCE, AMD8111 };
 
 static struct pci_device_id amd756_ids[] = {
 	{PCI_VENDOR_ID_AMD, 0x740B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, AMD756 },
 	{PCI_VENDOR_ID_AMD, 0x7413, PCI_ANY_ID, PCI_ANY_ID, 0, 0, AMD766 },
 	{PCI_VENDOR_ID_AMD, 0x7443, PCI_ANY_ID, PCI_ANY_ID, 0, 0, AMD768 },
+	{PCI_VENDOR_ID_AMD, 0x746B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, AMD8111 },
 	{PCI_VENDOR_ID_NVIDIA, 0x01B4, PCI_ANY_ID, PCI_ANY_ID, 0, 0, NFORCE },
 	{ 0, }
 };
@@ -321,7 +323,8 @@ static struct pci_device_id amd756_ids[]
 static int __devinit amd756_probe(struct pci_dev *pdev,
 				  const struct pci_device_id *id)
 {
-	int nforce = (id->driver_data == NFORCE), error;
+	int nforce = (id->driver_data == NFORCE);
+	int error;
 	u8 temp;
 	
 	if (amd756_ioport) {
@@ -368,7 +371,7 @@ static int __devinit amd756_probe(struct
 	amd756_adapter.dev.parent = &pdev->dev;
 
 	snprintf(amd756_adapter.name, I2C_NAME_SIZE,
-		"SMBus AMD75x adapter at %04x", amd756_ioport);
+		"SMBus AMD756 adapter at %04x", amd756_ioport);
 
 	error = i2c_add_adapter(&amd756_adapter);
 	if (error) {
@@ -391,7 +394,7 @@ static void __devexit amd756_remove(stru
 }
 
 static struct pci_driver amd756_driver = {
-	.name		= "amd75x smbus",
+	.name		= "amd756 smbus",
 	.id_table	= amd756_ids,
 	.probe		= amd756_probe,
 	.remove		= __devexit_p(amd756_remove),
@@ -408,7 +411,7 @@ static void __exit amd756_exit(void)
 }
 
 MODULE_AUTHOR("Merlin Hughes <merlin@merlin.org>");
-MODULE_DESCRIPTION("AMD756/766/768/nVidia nForce SMBus driver");
+MODULE_DESCRIPTION("AMD756/766/768/8111 and nVidia nForce SMBus driver");
 MODULE_LICENSE("GPL");
 
 module_init(amd756_init)
diff -purN linux-2.5/drivers/i2c/busses/i2c-amd8111.c usb-2.5/drivers/i2c/busses/i2c-amd8111.c
--- linux-2.5/drivers/i2c/busses/i2c-amd8111.c	2003-09-12 16:55:09.000000000 +0000
+++ usb-2.5/drivers/i2c/busses/i2c-amd8111.c	2003-12-01 21:06:43.000000000 +0000
@@ -192,7 +192,7 @@ s32 amd8111_access(struct i2c_adapter * 
 
 		case I2C_SMBUS_BYTE:
 			if (read_write == I2C_SMBUS_WRITE)
-				amd_ec_write(smbus, AMD_SMB_DATA, data->byte);
+				amd_ec_write(smbus, AMD_SMB_CMD, command);
 			protocol |= AMD_SMB_PRTCL_BYTE;
 			break;
 
diff -purN linux-2.5/drivers/i2c/busses/i2c-elektor.c usb-2.5/drivers/i2c/busses/i2c-elektor.c
--- linux-2.5/drivers/i2c/busses/i2c-elektor.c	2003-09-23 13:29:27.000000000 +0000
+++ usb-2.5/drivers/i2c/busses/i2c-elektor.c	2003-09-26 16:37:42.000000000 +0000
@@ -119,12 +119,16 @@ static void pcf_isa_waitforpin(void) {
 	int timeout = 2;
 
 	if (irq > 0) {
-		cli();
+		/* This cli() stuff has to get cleaned up */
+		#if defined(CONFIG_SMP)
+		WARN_ON(1);
+		#endif
+		/* cli(); */
 		if (pcf_pending == 0) {
 			interruptible_sleep_on_timeout(&pcf_wait, timeout*HZ );
 		} else
 			pcf_pending = 0;
-		sti();
+		/* sti(); */
 	} else {
 		udelay(100);
 	}
diff -purN linux-2.5/drivers/i2c/busses/i2c-ite.c usb-2.5/drivers/i2c/busses/i2c-ite.c
--- linux-2.5/drivers/i2c/busses/i2c-ite.c	2003-09-22 14:58:42.000000000 +0000
+++ usb-2.5/drivers/i2c/busses/i2c-ite.c	2003-09-23 20:07:56.000000000 +0000
@@ -45,7 +45,6 @@
 #include <linux/i2c.h>
 #include <linux/i2c-algo-ite.h>
 #include <linux/i2c-adap-ite.h>
-#include "../i2c-ite.h"
 
 #define DEFAULT_BASE  0x14014030
 #define ITE_IIC_IO_SIZE	0x40
diff -purN linux-2.5/drivers/i2c/busses/i2c-piix4.c usb-2.5/drivers/i2c/busses/i2c-piix4.c
--- linux-2.5/drivers/i2c/busses/i2c-piix4.c	2003-09-22 16:02:10.000000000 +0000
+++ usb-2.5/drivers/i2c/busses/i2c-piix4.c	2003-12-17 15:48:42.000000000 +0000
@@ -22,7 +22,7 @@
 /*
    Supports:
 	Intel PIIX4, 440MX
-	Serverworks OSB4, CSB5
+	Serverworks OSB4, CSB5, CSB6
 	SMSC Victory66
 
    Note: we assume there can only be one device, with one SMBus interface.
@@ -161,14 +161,6 @@ static int piix4_setup(struct pci_dev *P
 
 	pci_read_config_byte(PIIX4_dev, SMBHSTCFG, &temp);
 
-	/* Some BIOS will set up the chipset incorrectly and leave a register
-	   in an undefined state (causing I2C to act very strangely). */
-	if (temp & 0x02) {
-		dev_info(&PIIX4_dev->dev, "Worked around buggy BIOS (I2C)\n");
-		temp = temp & 0xfd;
-		pci_write_config_byte(PIIX4_dev, SMBHSTCFG, temp);
-	}
- 
 	/* If force_addr is set, we program the new address here. Just to make
 	   sure, we disable the PIIX4 first. */
 	if (force_addr) {
@@ -423,6 +415,13 @@ static struct pci_device_id piix4_ids[] 
 		.driver_data =	0,
 	},
 	{
+		.vendor =	PCI_VENDOR_ID_SERVERWORKS,
+		.device =	PCI_DEVICE_ID_SERVERWORKS_CSB6,
+		.subvendor =	PCI_ANY_ID,
+		.subdevice =	PCI_ANY_ID,
+		.driver_data =	0,
+	},
+	{
 		.vendor =	PCI_VENDOR_ID_INTEL,
 		.device =	PCI_DEVICE_ID_INTEL_82443MX_3,
 		.subvendor =	PCI_ANY_ID,
diff -purN linux-2.5/drivers/i2c/busses/i2c-savage4.c usb-2.5/drivers/i2c/busses/i2c-savage4.c
--- linux-2.5/drivers/i2c/busses/i2c-savage4.c	2003-09-23 12:20:12.000000000 +0000
+++ usb-2.5/drivers/i2c/busses/i2c-savage4.c	2003-11-28 20:40:24.000000000 +0000
@@ -1,13 +1,11 @@
 /*
     i2c-savage4.c - Part of lm_sensors, Linux kernel modules for hardware
               monitoring
-    Copyright (c) 1998, 1999  Frodo Looijaard <frodol@dds.nl>,
-    Philip Edelbrock <phil@netroedge.com>,
-    Ralph Metzler <rjkm@thp.uni-koeln.de>, and
+    Copyright (C) 1998-2003  The LM Sensors Team
+    Alexander Wold <awold@bigfoot.com>
     Mark D. Studebaker <mdsxyz123@yahoo.com>
     
-    Based on code written by Ralph Metzler <rjkm@thp.uni-koeln.de> and
-    Simon Vogl
+    Based on i2c-voodoo3.c.
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
@@ -195,9 +193,7 @@ static void __exit i2c_savage4_exit(void
 	pci_unregister_driver(&savage4_driver);
 }
 
-MODULE_AUTHOR("Frodo Looijaard <frodol@dds.nl>, "
-		"Philip Edelbrock <phil@netroedge.com>, "
-		"Ralph Metzler <rjkm@thp.uni-koeln.de>, "
+MODULE_AUTHOR("Alexander Wold <awold@bigfoot.com> "
 		"and Mark D. Studebaker <mdsxyz123@yahoo.com>");
 MODULE_DESCRIPTION("Savage4 I2C/SMBus driver");
 MODULE_LICENSE("GPL");
diff -purN linux-2.5/drivers/i2c/busses/i2c-viapro.c usb-2.5/drivers/i2c/busses/i2c-viapro.c
--- linux-2.5/drivers/i2c/busses/i2c-viapro.c	2003-09-12 16:55:09.000000000 +0000
+++ usb-2.5/drivers/i2c/busses/i2c-viapro.c	2003-11-29 17:02:37.000000000 +0000
@@ -29,6 +29,7 @@
 	8233
 	8233A (0x3147 and 0x3177)
 	8235
+	8237
    Note: we assume there can only be one device, with one SMBus interface.
 */
 
@@ -436,6 +437,13 @@ static struct pci_device_id vt596_ids[] 
 	},
 	{
 		.vendor		= PCI_VENDOR_ID_VIA,
+		.device 	= PCI_DEVICE_ID_VIA_8237,
+		.subvendor	= PCI_ANY_ID,
+		.subdevice	= PCI_ANY_ID,
+		.driver_data	= SMBBA3
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_VIA,
 		.device 	= PCI_DEVICE_ID_VIA_8231_4,
 		.subvendor	= PCI_ANY_ID,
 		.subdevice	= PCI_ANY_ID,
diff -purN linux-2.5/drivers/i2c/chips/Kconfig usb-2.5/drivers/i2c/chips/Kconfig
--- linux-2.5/drivers/i2c/chips/Kconfig	2003-10-03 19:38:36.000000000 +0000
+++ usb-2.5/drivers/i2c/chips/Kconfig	2003-10-17 16:35:41.000000000 +0000
@@ -68,6 +68,17 @@ config SENSORS_LM78
 	  This driver can also be built as a module.  If so, the module
 	  will be called lm78.
 
+config SENSORS_LM83
+	tristate "National Semiconductor LM83"
+	depends on I2C && EXPERIMENTAL
+	select I2C_SENSOR
+	help
+	  If you say yes here you get support for National Semiconductor
+	  LM83 sensor chips.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called lm83.
+
 config SENSORS_LM85
 	tristate "National Semiconductor LM85 and compatibles"
 	depends on I2C && EXPERIMENTAL
@@ -99,7 +110,12 @@ config SENSORS_W83781D
 	  of sensor chips: the W83781D, W83782D, W83783S and W83682HF,
 	  and the similar Asus AS99127F.
 	  
-	  This driver can also be built as a module.  If so, the module
-	  will be called w83781d.
+
+
+config SENSORS_SMBUS_ARP
+	tristate "SMBus ARP 2.0 support"
+	depends on I2C && EXPERIMENTAL
+	select I2C_SENSOR
+	  
 
 endmenu
diff -purN linux-2.5/drivers/i2c/chips/Makefile usb-2.5/drivers/i2c/chips/Makefile
--- linux-2.5/drivers/i2c/chips/Makefile	2003-09-23 16:14:19.000000000 +0000
+++ usb-2.5/drivers/i2c/chips/Makefile	2003-09-28 17:52:41.000000000 +0000
@@ -10,5 +10,10 @@ obj-$(CONFIG_SENSORS_EEPROM)	+= eeprom.o
 obj-$(CONFIG_SENSORS_IT87)	+= it87.o
 obj-$(CONFIG_SENSORS_LM75)	+= lm75.o
 obj-$(CONFIG_SENSORS_LM78)	+= lm78.o
+obj-$(CONFIG_SENSORS_LM83)	+= lm83.o
 obj-$(CONFIG_SENSORS_LM85)	+= lm85.o
 obj-$(CONFIG_SENSORS_VIA686A)	+= via686a.o
+
+
+
+obj-$(CONFIG_SENSORS_SMBUS_ARP)	+= smbus-arp.o
diff -purN linux-2.5/drivers/i2c/chips/it87.c usb-2.5/drivers/i2c/chips/it87.c
--- linux-2.5/drivers/i2c/chips/it87.c	2003-10-04 13:45:29.000000000 +0000
+++ usb-2.5/drivers/i2c/chips/it87.c	2003-11-21 21:22:20.000000000 +0000
@@ -343,7 +343,6 @@ static ssize_t show_temp(struct device *
 	it87_update_client(client);
 	return sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp[nr])*100 );
 }
-/* more like overshoot temperature */
 static ssize_t show_temp_max(struct device *dev, char *buf, int nr)
 {
 	struct i2c_client *client = to_i2c_client(dev);
@@ -351,7 +350,6 @@ static ssize_t show_temp_max(struct devi
 	it87_update_client(client);
 	return sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp_high[nr])*100);
 }
-/* more like hysteresis temperature */
 static ssize_t show_temp_min(struct device *dev, char *buf, int nr)
 {
 	struct i2c_client *client = to_i2c_client(dev);
@@ -414,7 +412,6 @@ show_temp_offset(1);
 show_temp_offset(2);
 show_temp_offset(3);
 
-/* more like overshoot temperature */
 static ssize_t show_sensor(struct device *dev, char *buf, int nr)
 {
 	struct i2c_client *client = to_i2c_client(dev);
@@ -563,15 +560,15 @@ show_fan_offset(1);
 show_fan_offset(2);
 show_fan_offset(3);
 
-/* Alarm */
-static ssize_t show_alarm(struct device *dev, char *buf)
+/* Alarms */
+static ssize_t show_alarms(struct device *dev, char *buf)
 {
 	struct i2c_client *client = to_i2c_client(dev);
 	struct it87_data *data = i2c_get_clientdata(client);
 	it87_update_client(client);
 	return sprintf(buf,"%d\n", ALARMS_FROM_REG(data->alarms));
 }
-static DEVICE_ATTR(alarm, S_IRUGO | S_IWUSR, show_alarm, NULL);
+static DEVICE_ATTR(alarms, S_IRUGO | S_IWUSR, show_alarms, NULL);
 
 /* This function is called when:
      * it87_driver is inserted (when this module is loaded), for each
@@ -751,7 +748,7 @@ int it87_detect(struct i2c_adapter *adap
 	device_create_file(&new_client->dev, &dev_attr_fan_div1);
 	device_create_file(&new_client->dev, &dev_attr_fan_div2);
 	device_create_file(&new_client->dev, &dev_attr_fan_div3);
-	device_create_file(&new_client->dev, &dev_attr_alarm);
+	device_create_file(&new_client->dev, &dev_attr_alarms);
 
 	return 0;
 
diff -purN linux-2.5/drivers/i2c/chips/lm75.c usb-2.5/drivers/i2c/chips/lm75.c
--- linux-2.5/drivers/i2c/chips/lm75.c	2003-10-04 13:45:05.000000000 +0000
+++ usb-2.5/drivers/i2c/chips/lm75.c	2003-12-15 00:28:08.000000000 +0000
@@ -25,6 +25,7 @@
 #include <linux/slab.h>
 #include <linux/i2c.h>
 #include <linux/i2c-sensor.h>
+#include "lm75.h"
 
 
 /* Addresses to scan */
@@ -44,17 +45,6 @@ SENSORS_INSMOD_1(lm75);
 #define LM75_REG_TEMP_HYST	0x02
 #define LM75_REG_TEMP_OS	0x03
 
-/* Conversions. Rounding and limit checking is only done on the TO_REG
-   variants. Note that you should be a bit careful with which arguments
-   these macros are called: arguments may be evaluated more than once.
-   Fixing this is just not worth it. */
-#define TEMP_FROM_REG(val)	((((val & 0x7fff) >> 7) * 5) | ((val & 0x8000)?-256:0))
-#define TEMP_TO_REG(val)	(SENSORS_LIMIT((val<0?(0x200+((val)/5))<<7:(((val) + 2) / 5) << 7),0,0xffff))
-
-/* Initial values */
-#define LM75_INIT_TEMP_OS	600
-#define LM75_INIT_TEMP_HYST	500
-
 /* Each client has this additional data */
 struct lm75_data {
 	struct semaphore	update_lock;
@@ -87,15 +77,12 @@ static struct i2c_driver lm75_driver = {
 static int lm75_id = 0;
 
 #define show(value)	\
-static ssize_t show_##value(struct device *dev, char *buf)	\
-{								\
-	struct i2c_client *client = to_i2c_client(dev);		\
-	struct lm75_data *data = i2c_get_clientdata(client);	\
-	int temp;						\
-								\
-	lm75_update_client(client);				\
-	temp = TEMP_FROM_REG(data->value);			\
-	return sprintf(buf, "%d\n", temp * 100);		\
+static ssize_t show_##value(struct device *dev, char *buf)		\
+{									\
+	struct i2c_client *client = to_i2c_client(dev);			\
+	struct lm75_data *data = i2c_get_clientdata(client);		\
+	lm75_update_client(client);					\
+	return sprintf(buf, "%d\n", LM75_TEMP_FROM_REG(data->value));	\
 }
 show(temp_max);
 show(temp_hyst);
@@ -106,9 +93,8 @@ static ssize_t set_##value(struct device
 {								\
 	struct i2c_client *client = to_i2c_client(dev);		\
 	struct lm75_data *data = i2c_get_clientdata(client);	\
-	int temp = simple_strtoul(buf, NULL, 10) / 100;		\
-								\
-	data->value = TEMP_TO_REG(temp);			\
+	int temp = simple_strtoul(buf, NULL, 10);		\
+	data->value = LM75_TEMP_TO_REG(temp);			\
 	lm75_write_value(client, reg, data->value);		\
 	return count;						\
 }
@@ -116,7 +102,7 @@ set(temp_max, LM75_REG_TEMP_OS);
 set(temp_hyst, LM75_REG_TEMP_HYST);
 
 static DEVICE_ATTR(temp_max, S_IWUSR | S_IRUGO, show_temp_max, set_temp_max);
-static DEVICE_ATTR(temp_min, S_IWUSR | S_IRUGO, show_temp_hyst, set_temp_hyst);
+static DEVICE_ATTR(temp_hyst, S_IWUSR | S_IRUGO, show_temp_hyst, set_temp_hyst);
 static DEVICE_ATTR(temp_input, S_IRUGO, show_temp_input, NULL);
 
 static int lm75_attach_adapter(struct i2c_adapter *adapter)
@@ -209,7 +195,7 @@ static int lm75_detect(struct i2c_adapte
 	
 	/* Register sysfs hooks */
 	device_create_file(&new_client->dev, &dev_attr_temp_max);
-	device_create_file(&new_client->dev, &dev_attr_temp_min);
+	device_create_file(&new_client->dev, &dev_attr_temp_hyst);
 	device_create_file(&new_client->dev, &dev_attr_temp_input);
 
 	return 0;
@@ -258,10 +244,6 @@ static int lm75_write_value(struct i2c_c
 static void lm75_init_client(struct i2c_client *client)
 {
 	/* Initialize the LM75 chip */
-	lm75_write_value(client, LM75_REG_TEMP_OS,
-			 TEMP_TO_REG(LM75_INIT_TEMP_OS));
-	lm75_write_value(client, LM75_REG_TEMP_HYST,
-			 TEMP_TO_REG(LM75_INIT_TEMP_HYST));
 	lm75_write_value(client, LM75_REG_CONF, 0);
 }
 
diff -purN linux-2.5/drivers/i2c/chips/lm75.h usb-2.5/drivers/i2c/chips/lm75.h
--- linux-2.5/drivers/i2c/chips/lm75.h	1970-01-01 00:00:00.000000000 +0000
+++ usb-2.5/drivers/i2c/chips/lm75.h	2003-12-14 23:32:46.000000000 +0000
@@ -0,0 +1,49 @@
+/*
+    lm75.h - Part of lm_sensors, Linux kernel modules for hardware
+             monitoring
+    Copyright (c) 2003 Mark M. Hoffman <mhoffman@lightlink.com>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+/*
+    This file contains common code for encoding/decoding LM75 type
+    temperature readings, which are emulated by many of the chips
+    we support.  As the user is unlikely to load more than one driver
+    which contains this code, we don't worry about the wasted space.
+*/
+
+#include <linux/i2c-sensor.h>
+
+/* straight from the datasheet */
+#define LM75_TEMP_MIN (-55000)
+#define LM75_TEMP_MAX 125000
+
+/* TEMP: 0.001C/bit (-55C to +125C)
+   REG: (0.5C/bit, two's complement) << 7 */
+static inline u16 LM75_TEMP_TO_REG(int temp)
+{
+	int ntemp = SENSORS_LIMIT(temp, LM75_TEMP_MIN, LM75_TEMP_MAX);
+	ntemp += (ntemp<0 ? -250 : 250);
+	return (u16)((ntemp / 500) << 7);
+}
+
+static inline int LM75_TEMP_FROM_REG(u16 reg)
+{
+	/* use integer division instead of equivalent right shift to
+	   guarantee arithmetic shift and preserve the sign */
+	return ((s16)reg / 128) * 500;
+}
+
diff -purN linux-2.5/drivers/i2c/chips/lm78.c usb-2.5/drivers/i2c/chips/lm78.c
--- linux-2.5/drivers/i2c/chips/lm78.c	2003-10-04 13:44:29.000000000 +0000
+++ usb-2.5/drivers/i2c/chips/lm78.c	2003-11-16 18:30:19.000000000 +0000
@@ -367,7 +367,7 @@ static ssize_t set_temp_hyst(struct devi
 static DEVICE_ATTR(temp_input, S_IRUGO, show_temp, NULL)
 static DEVICE_ATTR(temp_max, S_IRUGO | S_IWUSR,
 		show_temp_over, set_temp_over)
-static DEVICE_ATTR(temp_min, S_IRUGO | S_IWUSR,
+static DEVICE_ATTR(temp_hyst, S_IRUGO | S_IWUSR,
 		show_temp_hyst, set_temp_hyst)
 
 /* 3 Fans */
@@ -674,8 +674,8 @@ int lm78_detect(struct i2c_adapter *adap
 	device_create_file(&new_client->dev, &dev_attr_in_min6);
 	device_create_file(&new_client->dev, &dev_attr_in_max6);
 	device_create_file(&new_client->dev, &dev_attr_temp_input);
-	device_create_file(&new_client->dev, &dev_attr_temp_min);
 	device_create_file(&new_client->dev, &dev_attr_temp_max);
+	device_create_file(&new_client->dev, &dev_attr_temp_hyst);
 	device_create_file(&new_client->dev, &dev_attr_fan_input1);
 	device_create_file(&new_client->dev, &dev_attr_fan_min1);
 	device_create_file(&new_client->dev, &dev_attr_fan_div1);
diff -purN linux-2.5/drivers/i2c/chips/lm83.c usb-2.5/drivers/i2c/chips/lm83.c
--- linux-2.5/drivers/i2c/chips/lm83.c	1970-01-01 00:00:00.000000000 +0000
+++ usb-2.5/drivers/i2c/chips/lm83.c	2003-10-04 15:05:41.000000000 +0000
@@ -0,0 +1,413 @@
+/*
+ * lm83.c - Part of lm_sensors, Linux kernel modules for hardware
+ *          monitoring
+ * Copyright (C) 2003  Jean Delvare <khali@linux-fr.org>
+ *
+ * Heavily inspired from the lm78, lm75 and adm1021 drivers. The LM83 is
+ * a sensor chip made by National Semiconductor. It reports up to four
+ * temperatures (its own plus up to three external ones) with a 1 deg
+ * resolution and a 3-4 deg accuracy. Complete datasheet can be obtained
+ * from National's website at:
+ *   http://www.national.com/pf/LM/LM83.html
+ * Since the datasheet omits to give the chip stepping code, I give it
+ * here: 0x03 (at register 0xff).
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/i2c-sensor.h>
+
+/*
+ * Addresses to scan
+ * Address is selected using 2 three-level pins, resulting in 9 possible
+ * addresses.
+ */
+
+static unsigned short normal_i2c[] = { I2C_CLIENT_END };
+static unsigned short normal_i2c_range[] = { 0x18, 0x1a, 0x29, 0x2b,
+    0x4c, 0x4e, I2C_CLIENT_END };
+static unsigned int normal_isa[] = { I2C_CLIENT_ISA_END };
+static unsigned int normal_isa_range[] = { I2C_CLIENT_ISA_END };
+
+/*
+ * Insmod parameters
+ */
+
+SENSORS_INSMOD_1(lm83);
+
+/*
+ * The LM83 registers
+ * Manufacturer ID is 0x01 for National Semiconductor.
+ */
+
+#define LM83_REG_R_MAN_ID		0xFE
+#define LM83_REG_R_CHIP_ID		0xFF
+#define LM83_REG_R_CONFIG		0x03
+#define LM83_REG_W_CONFIG		0x09
+#define LM83_REG_R_STATUS1		0x02
+#define LM83_REG_R_STATUS2		0x35
+#define LM83_REG_R_LOCAL_TEMP		0x00
+#define LM83_REG_R_LOCAL_HIGH		0x05
+#define LM83_REG_W_LOCAL_HIGH		0x0B
+#define LM83_REG_R_REMOTE1_TEMP		0x30
+#define LM83_REG_R_REMOTE1_HIGH		0x38
+#define LM83_REG_W_REMOTE1_HIGH		0x50
+#define LM83_REG_R_REMOTE2_TEMP		0x01
+#define LM83_REG_R_REMOTE2_HIGH		0x07
+#define LM83_REG_W_REMOTE2_HIGH		0x0D
+#define LM83_REG_R_REMOTE3_TEMP		0x31
+#define LM83_REG_R_REMOTE3_HIGH		0x3A
+#define LM83_REG_W_REMOTE3_HIGH		0x52
+#define LM83_REG_R_TCRIT		0x42
+#define LM83_REG_W_TCRIT		0x5A
+
+/*
+ * Conversions, initial values and various macros
+ * The LM83 uses signed 8-bit values.
+ */
+
+#define TEMP_FROM_REG(val)	((val > 127 ? val-256 : val) * 1000)
+#define TEMP_TO_REG(val)	((val < 0 ? val+256 : val) / 1000)
+
+#define LM83_INIT_HIGH		100
+#define LM83_INIT_CRIT		120
+
+static const u8 LM83_REG_R_TEMP[] = {
+	LM83_REG_R_LOCAL_TEMP,
+	LM83_REG_R_REMOTE1_TEMP,
+	LM83_REG_R_REMOTE2_TEMP,
+	LM83_REG_R_REMOTE3_TEMP
+};
+
+static const u8 LM83_REG_R_HIGH[] = {
+	LM83_REG_R_LOCAL_HIGH,
+	LM83_REG_R_REMOTE1_HIGH,
+	LM83_REG_R_REMOTE2_HIGH,
+	LM83_REG_R_REMOTE3_HIGH
+};
+
+static const u8 LM83_REG_W_HIGH[] = {
+	LM83_REG_W_LOCAL_HIGH,
+	LM83_REG_W_REMOTE1_HIGH,
+	LM83_REG_W_REMOTE2_HIGH,
+	LM83_REG_W_REMOTE3_HIGH
+};
+
+/*
+ * Functions declaration
+ */
+
+static int lm83_attach_adapter(struct i2c_adapter *adapter);
+static int lm83_detect(struct i2c_adapter *adapter, int address,
+    int kind);
+static void lm83_init_client(struct i2c_client *client);
+static int lm83_detach_client(struct i2c_client *client);
+static void lm83_update_client(struct i2c_client *client);
+
+/*
+ * Driver data (common to all clients)
+ */
+ 
+static struct i2c_driver lm83_driver = {
+	.owner		= THIS_MODULE,
+	.name		= "lm83",
+	.id		= I2C_DRIVERID_LM83,
+	.flags		= I2C_DF_NOTIFY,
+	.attach_adapter	= lm83_attach_adapter,
+	.detach_client	= lm83_detach_client,
+};
+
+/*
+ * Client data (each client gets its own)
+ */
+
+struct lm83_data
+{
+	struct semaphore update_lock;
+	char valid; /* zero until following fields are valid */
+	unsigned long last_updated; /* in jiffies */
+
+	/* registers values */
+	u8 temp_input[4];
+	u8 temp_high[4];
+	u8 temp_crit;
+	u16 alarms; /* bitvector, combined */
+};
+
+/*
+ * Internal variables
+ */
+
+static int lm83_id = 0;
+
+/*
+ * Sysfs stuff
+ */
+
+#define show_temp(suffix, value) \
+static ssize_t show_temp_##suffix(struct device *dev, char *buf) \
+{ \
+	struct i2c_client *client = to_i2c_client(dev); \
+	struct lm83_data *data = i2c_get_clientdata(client); \
+	lm83_update_client(client); \
+	return sprintf(buf, "%d\n", TEMP_FROM_REG(data->value)); \
+}
+show_temp(input1, temp_input[0]);
+show_temp(input2, temp_input[1]);
+show_temp(input3, temp_input[2]);
+show_temp(input4, temp_input[3]);
+show_temp(high1, temp_high[0]);
+show_temp(high2, temp_high[1]);
+show_temp(high3, temp_high[2]);
+show_temp(high4, temp_high[3]);
+show_temp(crit, temp_crit);
+
+#define set_temp(suffix, value, reg) \
+static ssize_t set_temp_##suffix(struct device *dev, const char *buf, \
+	size_t count) \
+{ \
+	struct i2c_client *client = to_i2c_client(dev); \
+	struct lm83_data *data = i2c_get_clientdata(client); \
+	data->value = TEMP_TO_REG(simple_strtoul(buf, NULL, 10)); \
+	i2c_smbus_write_byte_data(client, reg, data->value); \
+	return count; \
+}
+set_temp(high1, temp_high[0], LM83_REG_W_LOCAL_HIGH);
+set_temp(high2, temp_high[1], LM83_REG_W_REMOTE1_HIGH);
+set_temp(high3, temp_high[2], LM83_REG_W_REMOTE2_HIGH);
+set_temp(high4, temp_high[3], LM83_REG_W_REMOTE3_HIGH);
+set_temp(crit, temp_crit, LM83_REG_W_TCRIT);
+
+static ssize_t show_alarms(struct device *dev, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct lm83_data *data = i2c_get_clientdata(client);
+	lm83_update_client(client);
+	return sprintf(buf, "%d\n", data->alarms);
+}
+
+static DEVICE_ATTR(temp_input1, S_IRUGO, show_temp_input1, NULL);
+static DEVICE_ATTR(temp_input2, S_IRUGO, show_temp_input2, NULL);
+static DEVICE_ATTR(temp_input3, S_IRUGO, show_temp_input3, NULL);
+static DEVICE_ATTR(temp_input4, S_IRUGO, show_temp_input4, NULL);
+static DEVICE_ATTR(temp_max1, S_IWUSR | S_IRUGO, show_temp_high1,
+    set_temp_high1);
+static DEVICE_ATTR(temp_max2, S_IWUSR | S_IRUGO, show_temp_high2,
+    set_temp_high2);
+static DEVICE_ATTR(temp_max3, S_IWUSR | S_IRUGO, show_temp_high3,
+    set_temp_high3);
+static DEVICE_ATTR(temp_max4, S_IWUSR | S_IRUGO, show_temp_high4,
+    set_temp_high4);
+static DEVICE_ATTR(temp_crit, S_IWUSR | S_IRUGO, show_temp_crit,
+    set_temp_crit);
+static DEVICE_ATTR(alarms, S_IRUGO, show_alarms, NULL);
+
+/*
+ * Real code
+ */
+
+static int lm83_attach_adapter(struct i2c_adapter *adapter)
+{
+	if (!(adapter->class & I2C_ADAP_CLASS_SMBUS))
+		return 0;
+	return i2c_detect(adapter, &addr_data, lm83_detect);
+}
+
+/*
+ * The following function does more than just detection. If detection
+ * succeeds, it also registers the new chip.
+ */
+static int lm83_detect(struct i2c_adapter *adapter, int address,
+    int kind)
+{
+	struct i2c_client *new_client;
+	struct lm83_data *data;
+	int err = 0;
+	const char *name = "";
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))
+		goto exit;
+
+	if (!(new_client = kmalloc(sizeof(struct i2c_client) +
+	    sizeof(struct lm83_data), GFP_KERNEL))) {
+		err = -ENOMEM;
+		goto exit;
+	}
+	memset(new_client, 0x00, sizeof(struct i2c_client) +
+	    sizeof(struct lm83_data));
+
+	/* The LM83-specific data is placed right after the common I2C
+	 * client data. */
+	data = (struct lm83_data *) (new_client + 1);
+	i2c_set_clientdata(new_client, data);
+	new_client->addr = address;
+	new_client->adapter = adapter;
+	new_client->driver = &lm83_driver;
+	new_client->flags = 0;
+
+	/* Now we do the detection and identification. A negative kind
+	 * means that the driver was loaded with no force parameter
+	 * (default), so we must both detect and identify the chip
+	 * (actually there is only one possible kind of chip for now, LM83).
+	 * A zero kind means that the driver was loaded with the force
+	 * parameter, the detection step shall be skipped. A positive kind
+	 * means that the driver was loaded with the force parameter and a
+	 * given kind of chip is requested, so both the detection and the
+	 * identification steps are skipped. */
+	if (kind < 0) { /* detection */
+		if (((i2c_smbus_read_byte_data(new_client, LM83_REG_R_STATUS1)
+		    & 0xA8) != 0x00) ||
+		    ((i2c_smbus_read_byte_data(new_client, LM83_REG_R_STATUS2)
+		    & 0x48) != 0x00) ||
+		    ((i2c_smbus_read_byte_data(new_client, LM83_REG_R_CONFIG)
+		    & 0x41) != 0x00)) {
+			dev_dbg(&client->dev,
+			    "LM83 detection failed at 0x%02x.\n", address);
+			goto exit_free;
+		}
+	}
+
+	if (kind <= 0) { /* identification */
+		u8 man_id, chip_id;
+
+		man_id = i2c_smbus_read_byte_data(new_client,
+		    LM83_REG_R_MAN_ID);
+		chip_id = i2c_smbus_read_byte_data(new_client,
+		    LM83_REG_R_CHIP_ID);
+		if (man_id == 0x01) { /* National Semiconductor */
+			if (chip_id == 0x03) {
+				kind = lm83;
+				name = "lm83";
+			}
+		}
+
+		if (kind <= 0) { /* identification failed */
+			dev_info(&adapter->dev,
+			    "Unsupported chip (man_id=0x%02X, "
+			    "chip_id=0x%02X).\n", man_id, chip_id);
+			goto exit_free;
+		}
+	}
+
+	/* We can fill in the remaining client fields */
+	strlcpy(new_client->name, name, I2C_NAME_SIZE);
+	new_client->id = lm83_id++;
+	data->valid = 0;
+	init_MUTEX(&data->update_lock);
+
+	/* Tell the I2C layer a new client has arrived */
+	if ((err = i2c_attach_client(new_client)))
+		goto exit_free;
+
+	/* Initialize the LM83 chip */
+	lm83_init_client(new_client);
+
+	/* Register sysfs hooks */
+	device_create_file(&new_client->dev, &dev_attr_temp_input1);
+	device_create_file(&new_client->dev, &dev_attr_temp_input2);
+	device_create_file(&new_client->dev, &dev_attr_temp_input3);
+	device_create_file(&new_client->dev, &dev_attr_temp_input4);
+	device_create_file(&new_client->dev, &dev_attr_temp_max1);
+	device_create_file(&new_client->dev, &dev_attr_temp_max2);
+	device_create_file(&new_client->dev, &dev_attr_temp_max3);
+	device_create_file(&new_client->dev, &dev_attr_temp_max4);
+	device_create_file(&new_client->dev, &dev_attr_temp_crit);
+	device_create_file(&new_client->dev, &dev_attr_alarms);
+
+	return 0;
+
+exit_free:
+	kfree(new_client);
+exit:
+	return err;
+}
+
+static void lm83_init_client(struct i2c_client *client)
+{
+	int nr;
+
+	for (nr = 0; nr < 4; nr++)
+		i2c_smbus_write_byte_data(client, LM83_REG_W_HIGH[nr],
+	            TEMP_TO_REG(LM83_INIT_HIGH));
+	i2c_smbus_write_byte_data(client, LM83_REG_W_TCRIT,
+	    TEMP_TO_REG(LM83_INIT_CRIT));
+}
+
+static int lm83_detach_client(struct i2c_client *client)
+{
+	int err;
+
+	if ((err = i2c_detach_client(client))) {
+		dev_err(&client->dev,
+		    "Client deregistration failed, client not detached.\n");
+		return err;
+	}
+
+	kfree(client);
+	return 0;
+}
+
+static void lm83_update_client(struct i2c_client *client)
+{
+	struct lm83_data *data = i2c_get_clientdata(client);
+
+	down(&data->update_lock);
+
+	if ((jiffies - data->last_updated > HZ * 2) ||
+	    (jiffies < data->last_updated) ||
+	    !data->valid) {
+		int nr;
+		dev_dbg(&client->dev, "Updating lm83 data.\n");
+		for (nr = 0; nr < 4 ; nr++) {
+			data->temp_input[nr] =
+			    i2c_smbus_read_byte_data(client,
+			    LM83_REG_R_TEMP[nr]);
+			data->temp_high[nr] =
+			    i2c_smbus_read_byte_data(client,
+			    LM83_REG_R_HIGH[nr]);
+		}
+		data->temp_crit =
+		    i2c_smbus_read_byte_data(client, LM83_REG_R_TCRIT);
+		data->alarms =
+		    i2c_smbus_read_byte_data(client, LM83_REG_R_STATUS1)
+		    + (i2c_smbus_read_byte_data(client, LM83_REG_R_STATUS2)
+		    << 8);
+		data->last_updated = jiffies;
+		data->valid = 1;
+	}
+
+	up(&data->update_lock);
+}
+
+static int __init sensors_lm83_init(void)
+{
+	return i2c_add_driver(&lm83_driver);
+}
+
+static void __exit sensors_lm83_exit(void)
+{
+	i2c_del_driver(&lm83_driver);
+}
+
+MODULE_AUTHOR("Jean Delvare <khali@linux-fr.org>");
+MODULE_DESCRIPTION("LM83 driver");
+MODULE_LICENSE("GPL");
+
+module_init(sensors_lm83_init);
+module_exit(sensors_lm83_exit);
diff -purN linux-2.5/drivers/i2c/chips/lm85.c usb-2.5/drivers/i2c/chips/lm85.c
--- linux-2.5/drivers/i2c/chips/lm85.c	2003-10-04 13:43:13.000000000 +0000
+++ usb-2.5/drivers/i2c/chips/lm85.c	2003-10-17 16:35:42.000000000 +0000
@@ -433,14 +433,11 @@ static ssize_t set_fan_min(struct device
 		size_t count, int nr)
 {
 	struct i2c_client *client = to_i2c_client(dev);
-	struct lm85_data *data = i2c_get_clientdata(client);
 	int	val;
 
-	down(&data->update_lock);
 	val = simple_strtol(buf, NULL, 10);
-	data->fan_min[nr] = FAN_TO_REG(val);
-	lm85_write_value(client, LM85_REG_FAN_MIN(nr), data->fan_min[nr]);
-	up(&data->update_lock);
+	val = FAN_TO_REG(val);
+	lm85_write_value(client, LM85_REG_FAN_MIN(nr), val);
 	return count;
 }
 
@@ -527,14 +524,11 @@ static ssize_t set_pwm(struct device *de
 		size_t count, int nr)
 {
 	struct i2c_client *client = to_i2c_client(dev);
-	struct lm85_data *data = i2c_get_clientdata(client);
 	int	val;
 
-	down(&data->update_lock);
 	val = simple_strtol(buf, NULL, 10);
-	data->pwm[nr] = PWM_TO_REG(val);
-	lm85_write_value(client, LM85_REG_PWM(nr), data->pwm[nr]);
-	up(&data->update_lock);
+	val = PWM_TO_REG(val);
+	lm85_write_value(client, LM85_REG_PWM(nr), val);
 	return count;
 }
 static ssize_t show_pwm_enable(struct device *dev, char *buf, int nr)
@@ -592,14 +586,11 @@ static ssize_t set_in_min(struct device 
 		size_t count, int nr)
 {
 	struct i2c_client *client = to_i2c_client(dev);
-	struct lm85_data *data = i2c_get_clientdata(client);
 	int	val;
 
-	down(&data->update_lock);
 	val = simple_strtol(buf, NULL, 10);
-	data->in_min[nr] = INS_TO_REG(nr, val);
-	lm85_write_value(client, LM85_REG_IN_MIN(nr), data->in_min[nr]);
-	up(&data->update_lock);
+	val = INS_TO_REG(nr, val);
+	lm85_write_value(client, LM85_REG_IN_MIN(nr), val);
 	return count;
 }
 static ssize_t show_in_max(struct device *dev, char *buf, int nr)
@@ -614,14 +605,11 @@ static ssize_t set_in_max(struct device 
 		size_t count, int nr)
 {
 	struct i2c_client *client = to_i2c_client(dev);
-	struct lm85_data *data = i2c_get_clientdata(client);
 	int	val;
 
-	down(&data->update_lock);
 	val = simple_strtol(buf, NULL, 10);
-	data->in_max[nr] = INS_TO_REG(nr, val);
-	lm85_write_value(client, LM85_REG_IN_MAX(nr), data->in_max[nr]);
-	up(&data->update_lock);
+	val = INS_TO_REG(nr, val);
+	lm85_write_value(client, LM85_REG_IN_MAX(nr), val);
 	return count;
 }
 #define show_in_reg(offset)						\
@@ -681,14 +669,11 @@ static ssize_t set_temp_min(struct devic
 		size_t count, int nr)
 {
 	struct i2c_client *client = to_i2c_client(dev);
-	struct lm85_data *data = i2c_get_clientdata(client);
 	int	val;
 
-	down(&data->update_lock);
 	val = simple_strtol(buf, NULL, 10);
-	data->temp_min[nr] = TEMP_TO_REG(val);
-	lm85_write_value(client, LM85_REG_TEMP_MIN(nr), data->temp_min[nr]);
-	up(&data->update_lock);
+	val = TEMP_TO_REG(val);
+	lm85_write_value(client, LM85_REG_TEMP_MIN(nr), val);
 	return count;
 }
 static ssize_t show_temp_max(struct device *dev, char *buf, int nr)
@@ -703,14 +688,11 @@ static ssize_t set_temp_max(struct devic
 		size_t count, int nr)
 {
 	struct i2c_client *client = to_i2c_client(dev);
-	struct lm85_data *data = i2c_get_clientdata(client);
 	int	val;
 
-	down(&data->update_lock);
 	val = simple_strtol(buf, NULL, 10);
-	data->temp_max[nr] = TEMP_TO_REG(val);
-	lm85_write_value(client, LM85_REG_TEMP_MAX(nr), data->temp_max[nr]);
-	up(&data->update_lock);
+	val = TEMP_TO_REG(val);
+	lm85_write_value(client, LM85_REG_TEMP_MAX(nr), val);
 	return count;
 }
 #define show_temp_reg(offset)						\
@@ -953,8 +935,12 @@ int lm85_detach_client(struct i2c_client
 
 int lm85_read_value(struct i2c_client *client, u8 reg)
 {
+	struct lm85_data *data = i2c_get_clientdata(client);
 	int res;
 
+	/* serialize access to the hardware */
+	down(&data->update_lock);
+
 	/* What size location is it? */
 	switch( reg ) {
 	case LM85_REG_FAN(0) :  /* Read WORD data */
@@ -978,14 +964,19 @@ int lm85_read_value(struct i2c_client *c
 		res = i2c_smbus_read_byte_data(client, reg);
 		break ;
 	}
+	up(&data->update_lock);
 
 	return res ;
 }
 
 int lm85_write_value(struct i2c_client *client, u8 reg, int value)
 {
+	struct lm85_data *data = i2c_get_clientdata(client);
 	int res ;
 
+	/* serialize access to the hardware */
+	down(&data->update_lock);
+
 	switch( reg ) {
 	case LM85_REG_FAN(0) :  /* Write WORD data */
 	case LM85_REG_FAN(1) :
@@ -1007,6 +998,7 @@ int lm85_write_value(struct i2c_client *
 		res = i2c_smbus_write_byte_data(client, reg, value);
 		break ;
 	}
+	up(&data->update_lock);
 
 	return res ;
 }
@@ -1068,8 +1060,6 @@ void lm85_update_client(struct i2c_clien
 	struct lm85_data *data = i2c_get_clientdata(client);
 	int i;
 
-	down(&data->update_lock);
-
 	if ( !data->valid ||
 	     (jiffies - data->last_reading > LM85_DATA_INTERVAL ) ) {
 		/* Things that change quickly */
@@ -1207,8 +1197,6 @@ void lm85_update_client(struct i2c_clien
 	};  /* last_config */
 
 	data->valid = 1;
-
-	up(&data->update_lock);
 }
 
 
diff -purN linux-2.5/drivers/i2c/chips/sensors_vid.h usb-2.5/drivers/i2c/chips/sensors_vid.h
--- linux-2.5/drivers/i2c/chips/sensors_vid.h	1970-01-01 00:00:00.000000000 +0000
+++ usb-2.5/drivers/i2c/chips/sensors_vid.h	2003-03-07 16:20:32.000000000 +0000
@@ -0,0 +1,62 @@
+/*
+    vrm.c - Part of lm_sensors, Linux kernel modules for hardware
+               monitoring
+    Copyright (c) 2002 Mark D. Studebaker <mdsxyz123@yahoo.com>
+    With assistance from Trent Piepho <xyzzy@speakeasy.org>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+/*
+    This file contains common code for decoding VID pins.
+    This file is #included in various chip drivers in this directory.
+    As the user is unlikely to load more than one driver which
+    includes this code we don't worry about the wasted space.
+    Reference: VRM x.y DC-DC Converter Design Guidelines,
+    available at http://developer.intel.com
+*/
+
+/*
+    Legal val values 00 - 1F.
+    vrm is the Intel VRM document version.
+    Note: vrm version is scaled by 10 and the return value is scaled by 1000
+    to avoid floating point in the kernel.
+*/
+
+#define DEFAULT_VRM	82
+
+static inline int vid_from_reg(int val, int vrm)
+{
+	switch(vrm) {
+
+	case 91:		/* VRM 9.1 */
+	case 90:		/* VRM 9.0 */
+		return(val == 0x1f ? 0 :
+		                       1850 - val * 25);
+
+	case 85:		/* VRM 8.5 */
+		return((val & 0x10  ? 25 : 0) +
+		       ((val & 0x0f) > 0x04 ? 2050 : 1250) -
+		       ((val & 0x0f) * 50));
+
+	case 84:		/* VRM 8.4 */
+		val &= 0x0f;
+				/* fall through */
+	default:		/* VRM 8.2 */
+		return(val == 0x1f ? 0 :
+		       val & 0x10  ? 5100 - (val) * 100 :
+		                     2050 - (val) * 50);
+	}
+}
diff -purN linux-2.5/drivers/i2c/chips/smbus-arp.c usb-2.5/drivers/i2c/chips/smbus-arp.c
--- linux-2.5/drivers/i2c/chips/smbus-arp.c	1970-01-01 00:00:00.000000000 +0000
+++ usb-2.5/drivers/i2c/chips/smbus-arp.c	2003-08-08 22:47:15.000000000 +0000
@@ -0,0 +1,435 @@
+/*
+    smbus-arp.c - Part of lm_sensors, Linux kernel modules for hardware
+               monitoring
+    Copyright (c) 2002  Mark D. Studebaker <mdsxyz123@yahoo.com>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/i2c-sensor.h>
+#include <linux/init.h>
+
+#define DEBUG 1
+
+/* Addresses to scan */
+#define	ARP_ADDRESS	0x61
+static unsigned short normal_i2c[] = { ARP_ADDRESS, I2C_CLIENT_END };
+static unsigned short normal_i2c_range[] = { I2C_CLIENT_END };
+static unsigned int normal_isa[] = { I2C_CLIENT_ISA_END };
+static unsigned int normal_isa_range[] = { I2C_CLIENT_ISA_END };
+
+/* Insmod parameters */
+SENSORS_INSMOD_1(arp);
+
+/* ARP Commands */
+#define	ARP_PREPARE		0x01
+#define	ARP_RESET_DEV		0x02
+#define	ARP_GET_UDID_GEN	0x03
+#define	ARP_ASSIGN_ADDR		0x04
+
+/* UDID Fields */
+#define ARP_CAPAB	0
+#define ARP_VER		1
+#define ARP_VEND	2
+#define ARP_DEV		4
+#define ARP_INT		6
+#define ARP_SUBVEND	8
+#define ARP_SUBDEV	10
+#define ARP_SPECID	12
+
+#define UDID_LENGTH	0x11
+
+static u8 reserved[] =
+/* As defined by SMBus Spec. Appendix C */
+			{0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x28,
+                        0x37, ARP_ADDRESS,
+/* As defined by SMBus Spec. Sect. 5.2 */
+			0x01, 0x02, 0x03, 0x04, 0x05,
+			0x06, 0x07, 0x78, 0x79, 0x7a, 0x7b,
+			0x7c, 0x7d, 0x7e, 0x7f,
+/* Common PC addresses (bad idea) */
+			0x2d, 0x48, 0x49, /* sensors */
+			0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, /* eeproms */
+			0x69, /* clock chips */
+/* Must end in 0 which is also reserved */
+			0x00};
+
+#define SMBUS_ADDRESS_SIZE	0x80
+#define ARP_FREE		0	
+#define ARP_RESERVED		1
+#define ARP_BUSY		2
+
+#define ARP_MAX_DEVICES		8
+struct arp_device {
+	int status;
+	u8 udid[UDID_LENGTH];
+	u8 dev_cap;
+	u8 dev_ver;
+	u16 dev_vid;
+	u16 dev_did;
+	u16 dev_int;
+	u16 dev_svid;
+	u16 dev_sdid;
+	u32 dev_vsid;
+	u8 saddr;
+};
+
+/* Each client has this additional data */
+struct arp_data {
+	struct semaphore update_lock;
+	char valid;			/* !=0 if following fields are valid */
+	unsigned long last_updated;	/* In jiffies */
+
+	u8 address_pool[SMBUS_ADDRESS_SIZE];
+	struct arp_device dev[ARP_MAX_DEVICES];
+};
+
+
+static int smbusarp_attach_adapter(struct i2c_adapter *adapter);
+static int smbusarp_detect(struct i2c_adapter *adapter, int address, int kind);
+static int smbusarp_detach_client(struct i2c_client *client);
+
+static int smbusarp_init_client(struct i2c_client *client);
+
+static struct i2c_driver smbusarp_driver = {
+	.owner		= THIS_MODULE,
+	.name		= "SMBus_ARP",
+	.id		= I2C_DRIVERID_ARP,
+	.flags		= I2C_DF_NOTIFY,
+	.attach_adapter	= smbusarp_attach_adapter,
+	.detach_client	= smbusarp_detach_client,
+};
+
+#if 0
+/* -- SENSORS SYSCTL START -- */
+#define ARP_SYSCTL1	1000
+#define ARP_SYSCTL2	1001
+#define ARP_SYSCTL3	1002
+#define ARP_SYSCTL4	1003
+#define ARP_SYSCTL5	1004
+#define ARP_SYSCTL6	1005
+#define ARP_SYSCTL7	1006
+#define ARP_SYSCTL8	1007
+
+/* -- SENSORS SYSCTL END -- */
+static ctl_table smbusarp_dir_table_template[] = {
+	{ARP_SYSCTL1, "0", NULL, 0, 0644, NULL, &i2c_proc_real,
+	 &i2c_sysctl_real, NULL, &smbusarp_contents},
+	{ARP_SYSCTL2, "1", NULL, 0, 0644, NULL, &i2c_proc_real,
+	 &i2c_sysctl_real, NULL, &smbusarp_contents},
+	{ARP_SYSCTL3, "2", NULL, 0, 0644, NULL, &i2c_proc_real,
+	 &i2c_sysctl_real, NULL, &smbusarp_contents},
+	{ARP_SYSCTL4, "3", NULL, 0, 0644, NULL, &i2c_proc_real,
+	 &i2c_sysctl_real, NULL, &smbusarp_contents},
+	{ARP_SYSCTL5, "4", NULL, 0, 0644, NULL, &i2c_proc_real,
+	 &i2c_sysctl_real, NULL, &smbusarp_contents},
+	{ARP_SYSCTL6, "5", NULL, 0, 0644, NULL, &i2c_proc_real,
+	 &i2c_sysctl_real, NULL, &smbusarp_contents},
+	{ARP_SYSCTL7, "6", NULL, 0, 0644, NULL, &i2c_proc_real,
+	 &i2c_sysctl_real, NULL, &smbusarp_contents},
+	{ARP_SYSCTL8, "7", NULL, 0, 0644, NULL, &i2c_proc_real,
+	 &i2c_sysctl_real, NULL, &smbusarp_contents},
+	{0}
+};
+#endif
+
+static int smbusarp_id = 0;
+
+static int smbusarp_attach_adapter(struct i2c_adapter *adapter)
+{
+	return i2c_detect(adapter, &addr_data, smbusarp_detect);
+}
+
+/* This function is called by i2c_detect */
+static int smbusarp_detect(struct i2c_adapter *adapter, int address, int kind)
+{
+	struct i2c_client *new_client;
+	struct arp_data *data;
+	int err = 0;
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BLOCK_DATA))
+		return(0);
+
+	if (!(new_client = kmalloc(sizeof(struct i2c_client) +
+				   sizeof(struct arp_data),
+				   GFP_KERNEL))) {
+		return(-ENOMEM);
+	}
+	memset(new_client, 0x00, sizeof(struct i2c_client) +
+				 sizeof(struct arp_data));
+
+	data = (struct arp_data *) (new_client + 1);
+	new_client->addr = address;
+	i2c_set_clientdata(new_client, data);
+	new_client->adapter = adapter;
+	new_client->driver = &smbusarp_driver;
+	new_client->flags = I2C_CLIENT_PEC;
+
+	strcpy(new_client->name, "arp");
+
+	new_client->id = smbusarp_id++;
+	data->valid = 0;
+	init_MUTEX(&data->update_lock);
+
+	if ((err = i2c_attach_client(new_client)))
+		goto error;
+
+	smbusarp_init_client(new_client);
+	return 0;
+
+error:
+	kfree(new_client);
+	return err;
+}
+
+static int smbusarp_detach_client(struct i2c_client *client)
+{
+	int err;
+
+	err = i2c_detach_client(client);
+	if (err) {
+		dev_err(&client->dev, "Client deregistration failed, client not detached.\n");
+		return err;
+	}
+
+	kfree(client);
+
+	return 0;
+}
+
+
+static u8 choose_addr(u8 * pool)
+{
+	int i;
+
+	for (i = 0; i < 0x7f; i++) {
+		if (pool[i] == ARP_FREE)
+			return (u8)i;
+	}
+	return 0xff;
+}
+
+static int smbusarp_init_client(struct i2c_client *client)
+{
+	int ret = -1;
+	struct arp_data *data = i2c_get_clientdata(client);
+	struct list_head *item;
+	u8 blk[I2C_SMBUS_BLOCK_MAX];
+	u8 *r;
+	u8 addr;
+	int i;
+	int found = 0;
+	int newdev = 0;
+	
+	for(i = 0; i < ARP_MAX_DEVICES; i++)
+		data->dev[i].status = ARP_FREE;
+
+	for(i = 0; i < SMBUS_ADDRESS_SIZE; i++)
+		data->address_pool[i] = ARP_FREE;
+
+	r = reserved;
+	do {
+		data->address_pool[*r] = ARP_RESERVED;
+	} while(*r++);
+
+	list_for_each(item, &client->adapter->clients) {
+		struct i2c_client *c = list_entry(item, struct i2c_client, list);
+		data->address_pool[c->addr] = ARP_BUSY;
+	}
+
+	ret = i2c_smbus_write_byte(client, ARP_PREPARE);
+	if (ret < 0) {
+		dev_dbg(client->dev, "No ARP response on adapter 0x%X\n", client->adapter->id);
+		return(-1);	/* Packet wasn't acked */
+	}
+	while(1) {
+		ret = i2c_smbus_read_block_data(client, ARP_GET_UDID_GEN, blk);
+		if(ret != UDID_LENGTH) {
+			dev_dbg(&client->dev, "No/Bad UDID response %d on adapter 0x%X\n", ret, client->adapter->id);
+			if(found)
+				return found;
+			else
+				return -1;	/* Bad response */
+		}
+		dev_dbg(&client->dev, "Good UDID response on adapter 0x%X\n", client->adapter->id);
+		dev_dbg(&client->dev, "Cap. 0x%02x  Rev. 0x%02x  Vend. 0x%02x%02x  Dev. 0x%02x%02x\n", blk[0], blk[1], blk[2], blk[3], blk[4], blk[5]);
+		dev_dbg(&client->dev, "Int. 0x%02x%02x  Subvend. 0x%02x%02x  Subdev. 0x%02x%02x  Spec. 0x%02x%02x%02x%02x\n", blk[6], blk[7], blk[8], blk[9], blk[10], blk[11], blk[12], blk[13], blk[14], blk[15]);
+
+		/* clean up this... */
+		found++;
+		do {
+			if (data->dev[newdev].status == ARP_FREE)
+				break;
+		} while(++newdev < ARP_MAX_DEVICES);
+		if (newdev == ARP_MAX_DEVICES) {
+			printk(KERN_WARNING "smbus-arp.o: No more slots available\n");
+			return -1;
+		}
+
+		/* check device slave addr */ 		
+		addr = blk[16];
+		if(addr != 0xFF) {
+			addr >>= 1;
+			if(blk[0] & 0xC0) {
+				if(data->address_pool[addr] == ARP_FREE) {
+					dev_dbg(&client->dev, "Requested free Non-fixed Address 0x%02x\n", addr);
+				} else {
+					dev_dbg(&client->dev, "Requested busy Non-fixed Address 0x%02x\n", addr);
+					addr = choose_addr(data->address_pool);
+					if (addr == 0xff) {
+						dev_warn(&client->dev, "Address pool exhausted\n");
+						return -1;
+					}
+				}
+			} else {
+				dev_dbg(&client->dev, "Fixed Address 0x%02x\n", addr);
+			}
+		} else {
+			dev_dbg(&client->dev, "No Address\n");
+			addr = choose_addr(data->address_pool);
+			if (addr == 0xff) {
+				dev_warn(&client->dev, "Address pool exhausted\n");
+				return -1;
+			}
+		}
+		/* store things both ways */
+		for (i = 0; i < UDID_LENGTH; i++)
+			data->dev[newdev].udid[i] = blk[i];
+		data->dev[newdev].saddr = addr;
+		data->dev[newdev].status = ARP_BUSY;
+		data->dev[newdev].dev_cap = blk[0];
+		data->dev[newdev].dev_ver = blk[1];
+		data->dev[newdev].dev_vid = (blk[2] << 8) | blk[3];
+		data->dev[newdev].dev_did = (blk[4] << 8) | blk[5];
+		data->dev[newdev].dev_int = (blk[6] << 8) | blk[7];
+		data->dev[newdev].dev_svid = (blk[8] << 8) | blk[9];
+		data->dev[newdev].dev_sdid = (blk[10] << 8) | blk[11];
+		data->dev[newdev].dev_vsid = (blk[12] << 24) | (blk[13] << 16) |
+		                             (blk[14] << 8) | blk[15] ;
+
+		blk[16] = addr << 1;
+		ret = i2c_smbus_write_block_data(client, ARP_ASSIGN_ADDR, UDID_LENGTH, blk);
+		if (ret) {
+			dev_dbg(&client->dev, "Bad response, address 0x%02x not assigned\n", addr);
+		} else {
+			data->address_pool[addr] = ARP_BUSY;
+			dev_dbg(&client->dev, "Assigned address 0x%02x\n", addr);
+		}
+			/* retry? */
+
+	} /* while 1  */
+
+	return ret;
+}
+
+#define show(value)	\
+static ssize_t show_slot_##value(struct device *dev, char *buf, int slot)	\
+{								\
+	struct i2c_client *client = to_i2c_client(dev);		\
+	struct arp_data *data = i2c_get_clientdata(client);	\
+								\
+	return sprintf(buf, "%d\n", data->dev[slot].value);	\
+}
+show(saddr);
+show(dev_cap);
+show(dev_ver);
+show(dev_vid);
+
+#define X(num)	\
+static ssize_t show_slot_saddr_##num(struct device *dev, char *buf)	\
+{									\
+	return show_slot_saddr(dev, buf, num);				\
+}									\
+static DEVICE_ATTR(slot_##num, S_IWUSR | S_IRUGO, show_slot_saddr_##num, NULL);
+
+X(0);
+
+#if 0
+/* reassign address on writex */
+static void smbusarp_contents(struct i2c_client *client, int operation,
+		     int ctl_name, int *nrels_mag, long *results)
+{
+	int nr = ctl_name - ARP_SYSCTL1;
+	struct arp_data *data = i2c_get_clientdata(client);
+	int ret;
+	u8 save;
+	u8 a;
+
+	if (operation == SENSORS_PROC_REAL_INFO)
+		*nrels_mag = 0;
+	else if (operation == SENSORS_PROC_REAL_READ) {
+		if(data->dev[nr].status == ARP_BUSY) {
+			results[0] = data->dev[nr].saddr;
+			results[1] = data->dev[nr].dev_cap;
+			results[2] = data->dev[nr].dev_ver;
+			results[3] = data->dev[nr].dev_vid;
+			results[4] = data->dev[nr].dev_did;
+			results[5] = data->dev[nr].dev_int;
+			results[6] = data->dev[nr].dev_svid;
+			results[7] = data->dev[nr].dev_sdid;
+			results[8] = data->dev[nr].dev_vsid;
+			*nrels_mag = 9;
+		} else {
+			*nrels_mag = 0;
+		}
+	} else if (operation == SENSORS_PROC_REAL_WRITE) {
+		a = results[0];
+		if ((*nrels_mag >= 1) &&
+		    (a < SMBUS_ADDRESS_SIZE) &&
+		    (data->dev[nr].status == ARP_BUSY) &&
+		    (data->address_pool[a] == ARP_FREE)) {
+			save = data->dev[nr].udid[16];
+			data->dev[nr].udid[16] = a << 1;
+			ret = i2c_smbus_write_block_data(client, ARP_ASSIGN_ADDR, UDID_LENGTH, data->dev[nr].udid);
+			if (ret) {
+				data->dev[nr].udid[16] = save;
+				dev_dbg(&client->dev, "smbus-arp Bad response, address 0x%02x not assigned\n", a);
+			} else {
+				data->dev[nr].saddr = a;
+				data->address_pool[a] = ARP_BUSY;
+				dev_dbg(&client->dev, "smbus-arp Assigned address 0x%02x\n", a);
+			}
+		} else {
+			dev_warn(&client->dev, "smbus-arp Bad address 0x%02x\n", a);
+		}
+	}
+}
+#endif
+
+static int __init sm_smbusarp_init(void)
+{
+	printk(KERN_INFO "smbus-arp\n");
+
+	/* magic force invocation */
+	force_arp[0] = -1;
+	force_arp[1] = ARP_ADDRESS;
+	return i2c_add_driver(&smbusarp_driver);
+}
+
+static void __exit sm_smbusarp_exit(void)
+{
+	i2c_del_driver(&smbusarp_driver);
+}
+
+
+MODULE_AUTHOR("Mark D. Studebaker <mdsxyz123@yahoo.com>");
+MODULE_DESCRIPTION("SMBUS ARP Driver");
+MODULE_LICENSE("GPL");
+
+module_init(sm_smbusarp_init);
+module_exit(sm_smbusarp_exit);
diff -purN linux-2.5/drivers/i2c/chips/via686a.c usb-2.5/drivers/i2c/chips/via686a.c
--- linux-2.5/drivers/i2c/chips/via686a.c	2003-10-04 13:43:22.000000000 +0000
+++ usb-2.5/drivers/i2c/chips/via686a.c	2003-11-21 21:26:04.000000000 +0000
@@ -496,21 +496,19 @@ static ssize_t show_temp(struct device *
 	via686a_update_client(client);
 	return sprintf(buf, "%ld\n", TEMP_FROM_REG10(data->temp[nr])*100 );
 }
-/* more like overshoot temperature */
-static ssize_t show_temp_max(struct device *dev, char *buf, int nr) {
+static ssize_t show_temp_over(struct device *dev, char *buf, int nr) {
 	struct i2c_client *client = to_i2c_client(dev);
 	struct via686a_data *data = i2c_get_clientdata(client);
 	via686a_update_client(client);
 	return sprintf(buf, "%ld\n", TEMP_FROM_REG(data->temp_over[nr])*100);
 }
-/* more like hysteresis temperature */
-static ssize_t show_temp_min(struct device *dev, char *buf, int nr) {
+static ssize_t show_temp_hyst(struct device *dev, char *buf, int nr) {
 	struct i2c_client *client = to_i2c_client(dev);
 	struct via686a_data *data = i2c_get_clientdata(client);
 	via686a_update_client(client);
 	return sprintf(buf, "%ld\n", TEMP_FROM_REG(data->temp_hyst[nr])*100);
 }
-static ssize_t set_temp_max(struct device *dev, const char *buf, 
+static ssize_t set_temp_over(struct device *dev, const char *buf, 
 		size_t count, int nr) {
 	struct i2c_client *client = to_i2c_client(dev);
 	struct via686a_data *data = i2c_get_clientdata(client);
@@ -519,7 +517,7 @@ static ssize_t set_temp_max(struct devic
 	via686a_write_value(client, VIA686A_REG_TEMP_OVER(nr), data->temp_over[nr]);
 	return count;
 }
-static ssize_t set_temp_min(struct device *dev, const char *buf, 
+static ssize_t set_temp_hyst(struct device *dev, const char *buf, 
 		size_t count, int nr) {
 	struct i2c_client *client = to_i2c_client(dev);
 	struct via686a_data *data = i2c_get_clientdata(client);
@@ -534,30 +532,30 @@ static ssize_t show_temp_##offset (struc
 	return show_temp(dev, buf, 0x##offset - 1);			\
 }									\
 static ssize_t								\
-show_temp_##offset##_max (struct device *dev, char *buf)		\
+show_temp_##offset##_over (struct device *dev, char *buf)		\
 {									\
-	return show_temp_max(dev, buf, 0x##offset - 1);			\
+	return show_temp_over(dev, buf, 0x##offset - 1);			\
 }									\
 static ssize_t								\
-show_temp_##offset##_min (struct device *dev, char *buf)		\
+show_temp_##offset##_hyst (struct device *dev, char *buf)		\
 {									\
-	return show_temp_min(dev, buf, 0x##offset - 1);			\
+	return show_temp_hyst(dev, buf, 0x##offset - 1);			\
 }									\
-static ssize_t set_temp_##offset##_max (struct device *dev, 		\
+static ssize_t set_temp_##offset##_over (struct device *dev, 		\
 		const char *buf, size_t count) 				\
 {									\
-	return set_temp_max(dev, buf, count, 0x##offset - 1);		\
+	return set_temp_over(dev, buf, count, 0x##offset - 1);		\
 }									\
-static ssize_t set_temp_##offset##_min (struct device *dev, 		\
+static ssize_t set_temp_##offset##_hyst (struct device *dev, 		\
 		const char *buf, size_t count) 				\
 {									\
-	return set_temp_min(dev, buf, count, 0x##offset - 1);		\
+	return set_temp_hyst(dev, buf, count, 0x##offset - 1);		\
 }									\
 static DEVICE_ATTR(temp_input##offset, S_IRUGO, show_temp_##offset, NULL) \
 static DEVICE_ATTR(temp_max##offset, S_IRUGO | S_IWUSR, 		\
-		show_temp_##offset##_max, set_temp_##offset##_max) 	\
-static DEVICE_ATTR(temp_min##offset, S_IRUGO | S_IWUSR, 		\
-		show_temp_##offset##_min, set_temp_##offset##_min)	
+		show_temp_##offset##_over, set_temp_##offset##_over) 	\
+static DEVICE_ATTR(temp_hyst##offset, S_IRUGO | S_IWUSR, 		\
+		show_temp_##offset##_hyst, set_temp_##offset##_hyst)	
 
 show_temp_offset(1);
 show_temp_offset(2);
@@ -637,14 +635,14 @@ static DEVICE_ATTR(fan_div##offset, S_IR
 show_fan_offset(1);
 show_fan_offset(2);
 
-/* Alarm */
-static ssize_t show_alarm(struct device *dev, char *buf) {
+/* Alarms */
+static ssize_t show_alarms(struct device *dev, char *buf) {
 	struct i2c_client *client = to_i2c_client(dev);
 	struct via686a_data *data = i2c_get_clientdata(client);
 	via686a_update_client(client);
 	return sprintf(buf,"%d\n", ALARMS_FROM_REG(data->alarms));
 }
-static DEVICE_ATTR(alarm, S_IRUGO | S_IWUSR, show_alarm, NULL);
+static DEVICE_ATTR(alarms, S_IRUGO | S_IWUSR, show_alarms, NULL);
 
 /* The driver. I choose to use type i2c_driver, as at is identical to both
    smbus_driver and isa_driver, and clients could be of either kind */
@@ -760,16 +758,16 @@ static int via686a_detect(struct i2c_ada
 	device_create_file(&new_client->dev, &dev_attr_temp_max1);
 	device_create_file(&new_client->dev, &dev_attr_temp_max2);
 	device_create_file(&new_client->dev, &dev_attr_temp_max3);
-	device_create_file(&new_client->dev, &dev_attr_temp_min1);
-	device_create_file(&new_client->dev, &dev_attr_temp_min2);
-	device_create_file(&new_client->dev, &dev_attr_temp_min3);
+	device_create_file(&new_client->dev, &dev_attr_temp_hyst1);
+	device_create_file(&new_client->dev, &dev_attr_temp_hyst2);
+	device_create_file(&new_client->dev, &dev_attr_temp_hyst3);
 	device_create_file(&new_client->dev, &dev_attr_fan_input1);
 	device_create_file(&new_client->dev, &dev_attr_fan_input2);
 	device_create_file(&new_client->dev, &dev_attr_fan_min1);
 	device_create_file(&new_client->dev, &dev_attr_fan_min2);
 	device_create_file(&new_client->dev, &dev_attr_fan_div1);
 	device_create_file(&new_client->dev, &dev_attr_fan_div2);
-	device_create_file(&new_client->dev, &dev_attr_alarm);
+	device_create_file(&new_client->dev, &dev_attr_alarms);
 
 	return 0;
 
diff -purN linux-2.5/drivers/i2c/chips/w83781d.c usb-2.5/drivers/i2c/chips/w83781d.c
--- linux-2.5/drivers/i2c/chips/w83781d.c	2003-10-14 13:22:22.000000000 +0000
+++ usb-2.5/drivers/i2c/chips/w83781d.c	2003-12-14 22:20:35.000000000 +0000
@@ -24,10 +24,11 @@
     Supports following chips:
 
     Chip	#vin	#fanin	#pwm	#temp	wchipid	vendid	i2c	ISA
-    as99127f	7	3	1?	3	0x30	0x12c3	yes	no
-    asb100 "bach" (type_name = as99127f)	0x30	0x0694	yes	no
-    w83781d	7	3	0	3	0x10	0x5ca3	yes	yes
-    w83627hf	9	3	2	3	0x20	0x5ca3	yes	yes(LPC)
+    as99127f	7	3	1?	3	0x31	0x12c3	yes	no
+    as99127f rev.2 (type_name = 1299127f)	0x31	0x5ca3	yes	no
+    asb100 "bach" (type_name = as99127f)	0x31	0x0694	yes	no
+    w83781d	7	3	0	3	0x10-1	0x5ca3	yes	yes
+    w83627hf	9	3	2	3	0x21	0x5ca3	yes	yes(LPC)
     w83627thf	9	3	2	3	0x90	0x5ca3	no	yes(LPC)
     w83782d	9	3	2-4	3	0x30	0x5ca3	yes	yes
     w83783s	5-6	3	2	1-2	0x40	0x5ca3	yes	no
@@ -207,72 +208,6 @@ DIV_TO_REG(long val, enum chips type)
 	return ((u8) i);
 }
 
-/* Initial limits */
-#define W83781D_INIT_IN_0		(vid == 3500 ? 280 : vid / 10)
-#define W83781D_INIT_IN_1		(vid == 3500 ? 280 : vid / 10)
-#define W83781D_INIT_IN_2		330
-#define W83781D_INIT_IN_3		(((500)   * 100) / 168)
-#define W83781D_INIT_IN_4		(((1200)  * 10) / 38)
-#define W83781D_INIT_IN_5		(((-1200) * -604) / 2100)
-#define W83781D_INIT_IN_6		(((-500)  * -604) / 909)
-#define W83781D_INIT_IN_7		(((500)   * 100) / 168)
-#define W83781D_INIT_IN_8		300
-/* Initial limits for 782d/783s negative voltages */
-/* Note level shift. Change min/max below if you change these. */
-#define W83782D_INIT_IN_5		((((-1200) + 1491) * 100)/514)
-#define W83782D_INIT_IN_6		((( (-500)  + 771) * 100)/314)
-
-#define W83781D_INIT_IN_PERCENTAGE	10
-#define W83781D_INIT_IN_MIN(val)	(val - val * W83781D_INIT_IN_PERCENTAGE / 100)
-#define W83781D_INIT_IN_MAX(val)	(val + val * W83781D_INIT_IN_PERCENTAGE / 100)
-
-#define W83781D_INIT_IN_MIN_0		W83781D_INIT_IN_MIN(W83781D_INIT_IN_0)
-#define W83781D_INIT_IN_MAX_0		W83781D_INIT_IN_MAX(W83781D_INIT_IN_0)
-#define W83781D_INIT_IN_MIN_1		W83781D_INIT_IN_MIN(W83781D_INIT_IN_1)
-#define W83781D_INIT_IN_MAX_1		W83781D_INIT_IN_MAX(W83781D_INIT_IN_1)
-#define W83781D_INIT_IN_MIN_2		W83781D_INIT_IN_MIN(W83781D_INIT_IN_2)
-#define W83781D_INIT_IN_MAX_2		W83781D_INIT_IN_MAX(W83781D_INIT_IN_2)
-#define W83781D_INIT_IN_MIN_3		W83781D_INIT_IN_MIN(W83781D_INIT_IN_3)
-#define W83781D_INIT_IN_MAX_3		W83781D_INIT_IN_MAX(W83781D_INIT_IN_3)
-#define W83781D_INIT_IN_MIN_4		W83781D_INIT_IN_MIN(W83781D_INIT_IN_4)
-#define W83781D_INIT_IN_MAX_4		W83781D_INIT_IN_MAX(W83781D_INIT_IN_4)
-#define W83781D_INIT_IN_MIN_5		W83781D_INIT_IN_MIN(W83781D_INIT_IN_5)
-#define W83781D_INIT_IN_MAX_5		W83781D_INIT_IN_MAX(W83781D_INIT_IN_5)
-#define W83781D_INIT_IN_MIN_6		W83781D_INIT_IN_MIN(W83781D_INIT_IN_6)
-#define W83781D_INIT_IN_MAX_6		W83781D_INIT_IN_MAX(W83781D_INIT_IN_6)
-#define W83781D_INIT_IN_MIN_7		W83781D_INIT_IN_MIN(W83781D_INIT_IN_7)
-#define W83781D_INIT_IN_MAX_7		W83781D_INIT_IN_MAX(W83781D_INIT_IN_7)
-#define W83781D_INIT_IN_MIN_8		W83781D_INIT_IN_MIN(W83781D_INIT_IN_8)
-#define W83781D_INIT_IN_MAX_8		W83781D_INIT_IN_MAX(W83781D_INIT_IN_8)
-
-/* Initial limits for 782d/783s negative voltages */
-/* These aren't direct multiples because of level shift */
-/* Beware going negative - check */
-#define W83782D_INIT_IN_MIN_5_TMP \
-	(((-1200 * (100 + W83781D_INIT_IN_PERCENTAGE)) + (1491 * 100))/514)
-#define W83782D_INIT_IN_MIN_5 \
-	((W83782D_INIT_IN_MIN_5_TMP > 0) ? W83782D_INIT_IN_MIN_5_TMP : 0)
-#define W83782D_INIT_IN_MAX_5 \
-	(((-1200 * (100 - W83781D_INIT_IN_PERCENTAGE)) + (1491 * 100))/514)
-#define W83782D_INIT_IN_MIN_6_TMP \
-	((( -500 * (100 + W83781D_INIT_IN_PERCENTAGE)) +  (771 * 100))/314)
-#define W83782D_INIT_IN_MIN_6 \
-	((W83782D_INIT_IN_MIN_6_TMP > 0) ? W83782D_INIT_IN_MIN_6_TMP : 0)
-#define W83782D_INIT_IN_MAX_6 \
-	((( -500 * (100 - W83781D_INIT_IN_PERCENTAGE)) +  (771 * 100))/314)
-
-#define W83781D_INIT_FAN_MIN_1		3000
-#define W83781D_INIT_FAN_MIN_2		3000
-#define W83781D_INIT_FAN_MIN_3		3000
-
-/* temp = value / 100 */
-#define W83781D_INIT_TEMP_OVER		6000
-#define W83781D_INIT_TEMP_HYST		12700	/* must be 127 for ALARM to work */
-#define W83781D_INIT_TEMP2_OVER		6000
-#define W83781D_INIT_TEMP2_HYST		5000
-#define W83781D_INIT_TEMP3_OVER		6000
-#define W83781D_INIT_TEMP3_HYST		5000
-
 /* There are some complications in a module like this. First off, W83781D chips
    may be both present on the SMBus and the ISA bus, and we have to handle
    those cases separately at some places. Second, there might be several
@@ -309,11 +244,11 @@ struct w83781d_data {
 	u8 fan[3];		/* Register value */
 	u8 fan_min[3];		/* Register value */
 	u8 temp;
-	u8 temp_min;		/* Register value */
 	u8 temp_max;		/* Register value */
+	u8 temp_hyst;		/* Register value */
 	u16 temp_add[2];	/* Register value */
 	u16 temp_max_add[2];	/* Register value */
-	u16 temp_min_add[2];	/* Register value */
+	u16 temp_hyst_add[2];	/* Register value */
 	u8 fan_div[3];		/* Register encoding, shifted right */
 	u8 vid;			/* Register encoding, combined */
 	u32 alarms;		/* Register encoding, combined */
@@ -510,8 +445,8 @@ static ssize_t show_##reg (struct device
 	} \
 }
 show_temp_reg(temp);
-show_temp_reg(temp_min);
 show_temp_reg(temp_max);
+show_temp_reg(temp_hyst);
 
 #define store_temp_reg(REG, reg) \
 static ssize_t store_temp_##reg (struct device *dev, const char *buf, size_t count, int nr) \
@@ -538,8 +473,8 @@ static ssize_t store_temp_##reg (struct 
 	 \
 	return count; \
 }
-store_temp_reg(OVER, min);
-store_temp_reg(HYST, max);
+store_temp_reg(OVER, max);
+store_temp_reg(HYST, hyst);
 
 #define sysfs_temp_offset(offset) \
 static ssize_t \
@@ -562,8 +497,8 @@ static DEVICE_ATTR(temp_##reg##offset, S
 
 #define sysfs_temp_offsets(offset) \
 sysfs_temp_offset(offset); \
-sysfs_temp_reg_offset(min, offset); \
-sysfs_temp_reg_offset(max, offset);
+sysfs_temp_reg_offset(max, offset); \
+sysfs_temp_reg_offset(hyst, offset);
 
 sysfs_temp_offsets(1);
 sysfs_temp_offsets(2);
@@ -573,7 +508,7 @@ sysfs_temp_offsets(3);
 do { \
 device_create_file(&client->dev, &dev_attr_temp_input##offset); \
 device_create_file(&client->dev, &dev_attr_temp_max##offset); \
-device_create_file(&client->dev, &dev_attr_temp_min##offset); \
+device_create_file(&client->dev, &dev_attr_temp_hyst##offset); \
 } while (0)
 
 static ssize_t
@@ -1264,7 +1199,7 @@ w83781d_detect(struct i2c_adapter *adapt
 			goto ERROR2;
 		}
 		/* If Winbond SMBus, check address at 0x48.
-		   Asus doesn't support */
+		   Asus doesn't support, except for as99127f rev.2 */
 		if ((!is_isa) && (((!(val1 & 0x80)) && (val2 == 0xa3)) ||
 				  ((val1 & 0x80) && (val2 == 0x5c)))) {
 			if (w83781d_read_value
@@ -1295,18 +1230,17 @@ w83781d_detect(struct i2c_adapter *adapt
 			goto ERROR2;
 		}
 
-		/* mask off lower bit, not reliable */
-		val1 =
-		    w83781d_read_value(new_client, W83781D_REG_WCHIPID) & 0xfe;
-		if (val1 == 0x10 && vendid == winbond)
+		val1 = w83781d_read_value(new_client, W83781D_REG_WCHIPID);
+		if ((val1 == 0x10 || val1 == 0x11) && vendid == winbond)
 			kind = w83781d;
 		else if (val1 == 0x30 && vendid == winbond)
 			kind = w83782d;
-		else if (val1 == 0x40 && vendid == winbond && !is_isa)
+		else if (val1 == 0x40 && vendid == winbond && !is_isa
+				&& address == 0x2d)
 			kind = w83783s;
-		else if ((val1 == 0x20 || val1 == 0x90) && vendid == winbond)
+		else if ((val1 == 0x21 || val1 == 0x90) && vendid == winbond)
 			kind = w83627hf;
-		else if (val1 == 0x30 && vendid == asus && !is_isa)
+		else if (val1 == 0x31 && !is_isa && address >= 0x28)
 			kind = as99127f;
 		else if (val1 == 0x60 && vendid == winbond && is_isa)
 			kind = w83697hf;
@@ -1688,113 +1622,6 @@ w83781d_init_client(struct i2c_client *c
 #endif				/* W83781D_RT */
 
 	if (init) {
-		w83781d_write_value(client, W83781D_REG_IN_MIN(0),
-				    IN_TO_REG(W83781D_INIT_IN_MIN_0));
-		w83781d_write_value(client, W83781D_REG_IN_MAX(0),
-				    IN_TO_REG(W83781D_INIT_IN_MAX_0));
-		if (type != w83783s && type != w83697hf) {
-			w83781d_write_value(client, W83781D_REG_IN_MIN(1),
-					    IN_TO_REG(W83781D_INIT_IN_MIN_1));
-			w83781d_write_value(client, W83781D_REG_IN_MAX(1),
-					    IN_TO_REG(W83781D_INIT_IN_MAX_1));
-		}
-
-		w83781d_write_value(client, W83781D_REG_IN_MIN(2),
-				    IN_TO_REG(W83781D_INIT_IN_MIN_2));
-		w83781d_write_value(client, W83781D_REG_IN_MAX(2),
-				    IN_TO_REG(W83781D_INIT_IN_MAX_2));
-		w83781d_write_value(client, W83781D_REG_IN_MIN(3),
-				    IN_TO_REG(W83781D_INIT_IN_MIN_3));
-		w83781d_write_value(client, W83781D_REG_IN_MAX(3),
-				    IN_TO_REG(W83781D_INIT_IN_MAX_3));
-		w83781d_write_value(client, W83781D_REG_IN_MIN(4),
-				    IN_TO_REG(W83781D_INIT_IN_MIN_4));
-		w83781d_write_value(client, W83781D_REG_IN_MAX(4),
-				    IN_TO_REG(W83781D_INIT_IN_MAX_4));
-		if (type == w83781d || type == as99127f) {
-			w83781d_write_value(client, W83781D_REG_IN_MIN(5),
-					    IN_TO_REG(W83781D_INIT_IN_MIN_5));
-			w83781d_write_value(client, W83781D_REG_IN_MAX(5),
-					    IN_TO_REG(W83781D_INIT_IN_MAX_5));
-		} else {
-			w83781d_write_value(client, W83781D_REG_IN_MIN(5),
-					    IN_TO_REG(W83782D_INIT_IN_MIN_5));
-			w83781d_write_value(client, W83781D_REG_IN_MAX(5),
-					    IN_TO_REG(W83782D_INIT_IN_MAX_5));
-		}
-		if (type == w83781d || type == as99127f) {
-			w83781d_write_value(client, W83781D_REG_IN_MIN(6),
-					    IN_TO_REG(W83781D_INIT_IN_MIN_6));
-			w83781d_write_value(client, W83781D_REG_IN_MAX(6),
-					    IN_TO_REG(W83781D_INIT_IN_MAX_6));
-		} else {
-			w83781d_write_value(client, W83781D_REG_IN_MIN(6),
-					    IN_TO_REG(W83782D_INIT_IN_MIN_6));
-			w83781d_write_value(client, W83781D_REG_IN_MAX(6),
-					    IN_TO_REG(W83782D_INIT_IN_MAX_6));
-		}
-		if ((type == w83782d) || (type == w83627hf) ||
-		    (type == w83697hf)) {
-			w83781d_write_value(client, W83781D_REG_IN_MIN(7),
-					    IN_TO_REG(W83781D_INIT_IN_MIN_7));
-			w83781d_write_value(client, W83781D_REG_IN_MAX(7),
-					    IN_TO_REG(W83781D_INIT_IN_MAX_7));
-			w83781d_write_value(client, W83781D_REG_IN_MIN(8),
-					    IN_TO_REG(W83781D_INIT_IN_MIN_8));
-			w83781d_write_value(client, W83781D_REG_IN_MAX(8),
-					    IN_TO_REG(W83781D_INIT_IN_MAX_8));
-			w83781d_write_value(client, W83781D_REG_VBAT,
-					    (w83781d_read_value
-					     (client,
-					      W83781D_REG_VBAT) | 0x01));
-		}
-		w83781d_write_value(client, W83781D_REG_FAN_MIN(1),
-				    FAN_TO_REG(W83781D_INIT_FAN_MIN_1, 2));
-		w83781d_write_value(client, W83781D_REG_FAN_MIN(2),
-				    FAN_TO_REG(W83781D_INIT_FAN_MIN_2, 2));
-		if (type != w83697hf) {
-			w83781d_write_value(client, W83781D_REG_FAN_MIN(3),
-					    FAN_TO_REG(W83781D_INIT_FAN_MIN_3,
-						       2));
-		}
-
-		w83781d_write_value(client, W83781D_REG_TEMP_OVER(1),
-				    TEMP_TO_REG(W83781D_INIT_TEMP_OVER));
-		w83781d_write_value(client, W83781D_REG_TEMP_HYST(1),
-				    TEMP_TO_REG(W83781D_INIT_TEMP_HYST));
-
-		if (type == as99127f) {
-			w83781d_write_value(client, W83781D_REG_TEMP_OVER(2),
-					    AS99127_TEMP_ADD_TO_REG
-					    (W83781D_INIT_TEMP2_OVER));
-			w83781d_write_value(client, W83781D_REG_TEMP_HYST(2),
-					    AS99127_TEMP_ADD_TO_REG
-					    (W83781D_INIT_TEMP2_HYST));
-		} else {
-			w83781d_write_value(client, W83781D_REG_TEMP_OVER(2),
-					    TEMP_ADD_TO_REG
-					    (W83781D_INIT_TEMP2_OVER));
-			w83781d_write_value(client, W83781D_REG_TEMP_HYST(2),
-					    TEMP_ADD_TO_REG
-					    (W83781D_INIT_TEMP2_HYST));
-		}
-		w83781d_write_value(client, W83781D_REG_TEMP2_CONFIG, 0x00);
-
-		if (type == as99127f) {
-			w83781d_write_value(client, W83781D_REG_TEMP_OVER(3),
-					    AS99127_TEMP_ADD_TO_REG
-					    (W83781D_INIT_TEMP3_OVER));
-			w83781d_write_value(client, W83781D_REG_TEMP_HYST(3),
-					    AS99127_TEMP_ADD_TO_REG
-					    (W83781D_INIT_TEMP3_HYST));
-		} else if (type != w83783s && type != w83697hf) {
-			w83781d_write_value(client, W83781D_REG_TEMP_OVER(3),
-					    TEMP_ADD_TO_REG
-					    (W83781D_INIT_TEMP3_OVER));
-			w83781d_write_value(client, W83781D_REG_TEMP_HYST(3),
-					    TEMP_ADD_TO_REG
-					    (W83781D_INIT_TEMP3_HYST));
-		}
 		if (type != w83783s && type != w83697hf) {
 			w83781d_write_value(client, W83781D_REG_TEMP3_CONFIG,
 					    0x00);
@@ -1865,15 +1692,15 @@ w83781d_update_client(struct i2c_client 
 		}
 
 		data->temp = w83781d_read_value(client, W83781D_REG_TEMP(1));
-		data->temp_min =
-		    w83781d_read_value(client, W83781D_REG_TEMP_OVER(1));
 		data->temp_max =
+		    w83781d_read_value(client, W83781D_REG_TEMP_OVER(1));
+		data->temp_hyst =
 		    w83781d_read_value(client, W83781D_REG_TEMP_HYST(1));
 		data->temp_add[0] =
 		    w83781d_read_value(client, W83781D_REG_TEMP(2));
 		data->temp_max_add[0] =
 		    w83781d_read_value(client, W83781D_REG_TEMP_OVER(2));
-		data->temp_min_add[0] =
+		data->temp_hyst_add[0] =
 		    w83781d_read_value(client, W83781D_REG_TEMP_HYST(2));
 		if (data->type != w83783s && data->type != w83697hf) {
 			data->temp_add[1] =
@@ -1881,7 +1708,7 @@ w83781d_update_client(struct i2c_client 
 			data->temp_max_add[1] =
 			    w83781d_read_value(client,
 					       W83781D_REG_TEMP_OVER(3));
-			data->temp_min_add[1] =
+			data->temp_hyst_add[1] =
 			    w83781d_read_value(client,
 					       W83781D_REG_TEMP_HYST(3));
 		}
diff -purN linux-2.5/drivers/pci/bus.c usb-2.5/drivers/pci/bus.c
--- linux-2.5/drivers/pci/bus.c	2003-06-19 23:10:39.000000000 +0000
+++ usb-2.5/drivers/pci/bus.c	2003-10-15 14:50:22.000000000 +0000
@@ -116,6 +116,8 @@ void __devinit pci_bus_add_devices(struc
 			list_add_tail(&dev->subordinate->node, &dev->bus->children);
 			spin_unlock(&pci_bus_lock);
 			pci_bus_add_devices(dev->subordinate);
+
+			sysfs_create_link(&dev->subordinate->class_dev.kobj, &dev->dev.kobj, "bridge");
 		}
 	}
 }
diff -purN linux-2.5/drivers/pci/hotplug/Kconfig usb-2.5/drivers/pci/hotplug/Kconfig
--- linux-2.5/drivers/pci/hotplug/Kconfig	2003-10-08 22:33:16.000000000 +0000
+++ usb-2.5/drivers/pci/hotplug/Kconfig	2003-10-10 20:44:39.000000000 +0000
@@ -88,6 +88,10 @@ config HOTPLUG_PCI_ACPI
 
 	  When in doubt, say N.
 
+config HOTPLUG_PCI_AMD
+	tristate "AMD Standard Hot Plug Controller (SHPC) driver"
+	depends on HOTPLUG_PCI
+
 config HOTPLUG_PCI_CPCI
 	bool "CompactPCI Hotplug driver"
 	depends on HOTPLUG_PCI
diff -purN linux-2.5/drivers/pci/hotplug/Makefile usb-2.5/drivers/pci/hotplug/Makefile
--- linux-2.5/drivers/pci/hotplug/Makefile	2003-06-26 00:24:41.000000000 +0000
+++ usb-2.5/drivers/pci/hotplug/Makefile	2003-06-26 16:51:45.000000000 +0000
@@ -7,8 +7,10 @@ obj-$(CONFIG_HOTPLUG_PCI_FAKE)		+= fakep
 obj-$(CONFIG_HOTPLUG_PCI_COMPAQ)	+= cpqphp.o
 obj-$(CONFIG_HOTPLUG_PCI_IBM)		+= ibmphp.o
 obj-$(CONFIG_HOTPLUG_PCI_ACPI)		+= acpiphp.o
+obj-$(CONFIG_HOTPLUG_PCI_AMD)		+= amdshpc.o
 obj-$(CONFIG_HOTPLUG_PCI_CPCI_ZT5550)	+= cpcihp_zt5550.o
 obj-$(CONFIG_HOTPLUG_PCI_CPCI_GENERIC)	+= cpcihp_generic.o
+obj-$(CONFIG_HOTPLUG_PCI_FAKE)		+= fakephp.o 
 
 pci_hotplug-objs	:=	pci_hotplug_core.o
 
@@ -33,6 +35,15 @@ acpiphp-objs		:=	acpiphp_core.o	\
 				acpiphp_pci.o	\
 				acpiphp_res.o
 
+amdshpc-objs		:=	amdshpc_core.o  \
+				amdshpc_ctrl.o  \
+				amdshpc_pci.o   \
+				amdshpc_ddi.o   \
+				amdshpc_int.o   \
+				amdshpc_led.o   \
+				amdshpc_enb.o   \
+				amdshpc_dsb.o
+
 ifdef CONFIG_HOTPLUG_PCI_ACPI
   EXTRA_CFLAGS  += -D_LINUX -I$(TOPDIR)/drivers/acpi
   ifdef CONFIG_ACPI_DEBUG
diff -purN linux-2.5/drivers/pci/hotplug/acpiphp_glue.c usb-2.5/drivers/pci/hotplug/acpiphp_glue.c
--- linux-2.5/drivers/pci/hotplug/acpiphp_glue.c	2003-08-27 14:44:50.000000000 +0000
+++ usb-2.5/drivers/pci/hotplug/acpiphp_glue.c	2003-12-13 15:57:46.000000000 +0000
@@ -974,6 +974,21 @@ static void handle_hotplug_event_bridge 
 		dbg("%s: Device eject notify on %s\n", __FUNCTION__, objname);
 		break;
 
+	case ACPI_NOTIFY_FREQUENCY_MISMATCH:
+		printk(KERN_ERR "Device %s cannot be configured due"
+				" to a frequency mismatch\n", objname);
+		break;
+
+	case ACPI_NOTIFY_BUS_MODE_MISMATCH:
+		printk(KERN_ERR "Device %s cannot be configured due"
+				" to a bus mode mismatch\n", objname);
+		break;
+
+	case ACPI_NOTIFY_POWER_FAULT:
+		printk(KERN_ERR "Device %s has suffered a power fault\n",
+				objname);
+		break;
+
 	default:
 		warn("notify_handler: unknown event type 0x%x for %s\n", type, objname);
 		break;
diff -purN linux-2.5/drivers/pci/hotplug/amdshpc.h usb-2.5/drivers/pci/hotplug/amdshpc.h
--- linux-2.5/drivers/pci/hotplug/amdshpc.h	1970-01-01 00:00:00.000000000 +0000
+++ usb-2.5/drivers/pci/hotplug/amdshpc.h	2003-08-28 23:06:29.000000000 +0000
@@ -0,0 +1,1265 @@
+/*
+ * Copyright (C) 2001,2003 Greg Kroah-Hartman (greg@kroah.com)
+ * Copyright (C) 2001,2003 IBM Corp.
+ * Copyright (C) 2002-2003 Advanced Micro Devices
+ *
+ * YOUR USE OF THIS CODE IS SUBJECT TO THE TERMS
+ * AND CONDITIONS OF THE GNU GENERAL PUBLIC
+ * LICENSE FOUND IN THE "GPL.TXT" FILE THAT IS
+ * INCLUDED WITH THIS FILE AND POSTED AT
+ * http://www.gnu.org/licenses/gpl.html
+ *
+ * Send feedback to <greg@kroah.com> <david.keck@amd.com>
+ *
+ */
+
+#ifndef _SHPC_H_
+#define _SHPC_H_
+
+
+#include <linux/types.h>
+#include <linux/wait.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/timer.h>
+#include <linux/sched.h>
+#include <asm/semaphore.h>
+#include "pci_hotplug.h"
+
+//
+// Timeouts
+//
+#define ONE_TENTH_SEC_TIMEOUT   	10		// 0.1 sec
+#define ONE_SEC_TIMEOUT                 HZ * 1          // 1 sec
+#define FIVE_SEC_TIMEOUT                HZ * 5          // 5 secs
+#define TEN_SEC_TIMEOUT                 HZ * 10         // 10 secs
+#define FIFTEEN_SEC_TIMEOUT             HZ * 15         // 15 secs
+#define QUIESCE_QUIET_TIMEOUT           HZ * 30         // 30 secs
+#define QUIESCE_TIMEOUT                 HZ * 60         // 60 secs
+#define ONE_SEC_INCREMENT               HZ * 1          // 1 sec
+
+#define SLOT_MAGIC      0x67267322
+struct slot {
+	u32 magic;
+	struct slot *next;
+	struct list_head slot_list;
+	u8 bus;
+	u8 device;
+	u8 number;
+	u8 is_a_board;
+	u8 configured;
+	u8 state;
+	u8 switch_save;
+	u8 presence_save;
+	u32 capabilities;
+	u16 reserved2;
+	struct timer_list task_event;
+	u8 hp_slot;
+	struct controller *ctrl;
+	void *p_sm_slot;
+	struct hotplug_slot *hotplug_slot;
+	void* private;
+};
+
+struct controller {
+	struct controller *next;
+	void *shpc_context;
+	u32 ctrl_int_comp;
+	void *hpc_reg;		/* cookie for our pci controller location */
+	struct pci_resource *mem_head;
+	struct pci_resource *p_mem_head;
+	struct pci_resource *io_head;
+	struct pci_resource *bus_head;
+	struct pci_dev *pci_dev;
+	struct pci_bus *pci_bus;
+	struct slot *slot;
+	u8 interrupt;
+	u8 bus;
+	u8 device;
+	u8 function;
+	u8 slot_device_offset;
+	u8 first_slot;
+	u8 add_support;
+	u16 vendor_id;
+};
+
+
+static LIST_HEAD(slot_list);
+
+#if !defined(CONFIG_HOTPLUG_PCI_AMD_MODULE)
+	#define MY_NAME "amd_shpc.o"
+#else
+	#define MY_NAME THIS_MODULE->name
+#endif
+
+//
+// Debug Facilities
+//
+#define debug 0
+#define dbg(format, arg...)                                     \
+	do {                                                    \
+		if (debug)                                      \
+		    printk (KERN_DEBUG "%s: " format "\n",      \
+		    MY_NAME , ## arg);          \
+	} while (0)
+
+#define err(format, arg...) printk(KERN_ERR "%s: " format "\n", MY_NAME , ## arg)
+#define info(format, arg...) printk(KERN_INFO "%s: " format "\n", MY_NAME , ## arg)
+#define warn(format, arg...) printk(KERN_WARNING "%s: " format "\n", MY_NAME , ## arg)
+
+#define msg_initialization_err  "Initialization failure, error=%d\n"
+#define msg_HPC_rev_error       "Unsupported revision of the PCI hot plug controller found.\n"
+#define msg_HPC_non_amd         "Non-AMD PCI hot plug controller is not supported by this driver.\n"
+#define msg_HPC_not_amd_hp	"Device is not a hot plug controller.\n"
+#define msg_HPC_not_supported   "This system is not supported by this version of amdshpc. Upgrade to a newer version of amdshpc\n"
+#define msg_unable_to_save      "Unable to store PCI hot plug add resource information. This system must be rebooted before adding any PCI devices.\n"
+
+struct hrt {
+	char sig0;
+	char sig1;
+	char sig2;
+	char sig3;
+	u16 unused_IRQ;
+	u16 PCIIRQ;
+	u8 number_of_entries;
+	u8 revision;
+	u16 reserved1;
+	u32 reserved2;
+} __attribute__ ((packed));
+
+/* offsets to the hotplug resource table registers based on the above structure layout */
+enum hrt_offsets {
+	SIG0 =			offsetof(struct hrt, sig0),
+	SIG1 =                  offsetof(struct hrt, sig1),
+	SIG2 =                  offsetof(struct hrt, sig2),
+	SIG3 =                  offsetof(struct hrt, sig3),
+	UNUSED_IRQ =            offsetof(struct hrt, unused_IRQ),
+	PCIIRQ =                offsetof(struct hrt, PCIIRQ),
+	NUMBER_OF_ENTRIES = 	offsetof(struct hrt, number_of_entries),
+	REVISION =              offsetof(struct hrt, revision),
+	HRT_RESERVED1 =         offsetof(struct hrt, reserved1),
+	HRT_RESERVED2 =         offsetof(struct hrt, reserved2),
+};
+
+struct slot_rt {
+	u8 dev_func;
+	u8 primary_bus;
+	u8 secondary_bus;
+	u8 max_bus;
+	u16 io_base;
+	u16 io_length;
+	u16 mem_base;
+	u16 mem_length;
+	u16 pre_mem_base;
+	u16 pre_mem_length;
+} __attribute__ ((packed));
+
+/* offsets to the hotplug slot resource table registers based on the above structure layout */
+enum slot_rt_offsets {
+	DEV_FUNC =	offsetof(struct slot_rt, dev_func),
+	PRIMARY_BUS =   offsetof(struct slot_rt, primary_bus),
+	SECONDARY_BUS = offsetof(struct slot_rt, secondary_bus),
+	MAX_BUS =       offsetof(struct slot_rt, max_bus),
+	IO_BASE =       offsetof(struct slot_rt, io_base),
+	IO_LENGTH =     offsetof(struct slot_rt, io_length),
+	MEM_BASE =      offsetof(struct slot_rt, mem_base),
+	MEM_LENGTH =    offsetof(struct slot_rt, mem_length),
+	PRE_MEM_BASE =	offsetof(struct slot_rt, pre_mem_base),
+	PRE_MEM_LENGTH = offsetof(struct slot_rt, pre_mem_length),
+};
+
+struct pci_func {
+	struct pci_func *next;
+	u8 bus;
+	u8 device;
+	u8 function;
+	u8 is_a_board;
+	u16 status;
+	u8 configured;
+	u8 switch_save;
+	u8 presence_save;
+	u32 base_length[0x06];
+	u8 base_type[0x06];
+	u16 reserved2;
+	u32 config_space[0x20];
+	struct pci_resource *mem_head;
+	struct pci_resource *p_mem_head;
+	struct pci_resource *io_head;
+	struct pci_resource *bus_head;
+	struct timer_list *p_task_event;
+	struct pci_dev* pci_dev;
+};
+
+
+#ifndef FALSE
+	#define FALSE 0
+	#define TRUE 1
+#endif
+
+#define IN
+#define OUT
+
+enum mutex_action {
+	ACQUIRE,
+	RELEASE,
+};
+
+enum hp_boolean {
+	HP_FALSE = 0,
+	HP_TRUE = 1,
+};
+
+// card power requirements
+enum hp_power_requirements {
+	POWER_LOW,		// low power requirements
+	POWER_MEDIUM,		// medium power requirements
+	POWER_HIGH,		// high power requirements
+};
+
+//
+// slot event masks
+//
+#define ATTN_BUTTON_EVENT               0x00000001
+#define ALERT_EVENT     		0x00000002
+#define BUS_REBALANCE_EVENT             0x00000004
+#define QUIESCE_EVENT                   0x00000008
+#define ATTN_LED_PROBLEM_EVENT          0x00000010
+#define ATTN_LED_REQUEST_EVENT          0x00000020
+#define SLOT_REQUEST_EVENT              0x00000040
+#define SLOT_TIMER1_EVENT               0x00000080
+#define SLOT_TIMER2_EVENT               0x00000100
+#define SLOT_TIMER3_EVENT               0x00000200
+#define SLOT_TIMER4_EVENT               0x00000400
+#define SLOT_TIMER5_EVENT               0x00000800
+#define SLOT_TIMER6_EVENT               0x00001000
+#define SLOT_TIMER7_EVENT               0x00002000
+#define SLOT_TIMER8_EVENT               0x00004000
+#define SLOT_TIMER9_EVENT               0x00008000
+#define SLOT_TIMER10_EVENT              0x00010000
+#define LED_TIMER1_EVENT                0x00020000
+#define LED_TIMER2_EVENT                0x00040000
+#define LED_TIMER3_EVENT                0x00080000
+#define LED_TIMER4_EVENT                0x00100000
+#define CMD_ACQUIRE_EVENT               0x00200000
+#define CMD_RELEASE_EVENT               0x00400000
+#define LED_CMD_ACQUIRE_EVENT           0x00800000
+#define LED_CMD_RELEASE_EVENT           0x01000000
+#define BUS_RELEASE_EVENT               0x02000000
+#define BUS_ACQUIRE_EVENT               0x04000000
+
+//
+// controller event masks
+//
+#define BUS_COMPLETE_EVENT              0x00000001
+#define SUSPEND_EVENT                   0x00000002
+#define RESUME_EVENT                    0x00000004
+#define REMOVE_EVENT                    0x00000008
+#define EXIT_REQUEST_EVENT              0x00000010
+#define CTRL_TIMER_EVENT                0x00000020
+#define CMD_COMPLETION_EVENT            0x00000040
+#define CMD_AVAILABLE_MUTEX_EVENT       0x00000080
+#define BUS_AVAILABLE_MUTEX_EVENT       0x00000100
+#define LED_CMD_AVAILABLE_MUTEX_EVENT   0x00000200
+
+
+#define PCI_TO_PCI_BRIDGE_CLASS         0x00060400
+#define SLOT_MASK                       0x28
+
+
+#define ADD_NOT_SUPPORTED               0x00000003
+#define ADAPTER_NOT_SAME                0x00000006
+#define NO_ADAPTER_PRESENT              0x00000009
+
+#define REMOVE_NOT_SUPPORTED            0x00000003
+
+
+
+// slot states
+enum hp_states {
+	SLOT_DISABLE,		// slot disable
+	SLOT_ENABLE,		// slot enable
+};
+
+// indicator values
+enum mode_frequency {
+	MODE_PCI_33,		// PCI 33Mhz
+	MODE_PCI_66,		// PCI 66Mhz
+	MODE_PCIX_66,		// PCI-X 66Mhz
+	MODE_PCIX_100,		// PCI-X 100Mhz
+	MODE_PCIX_133,		// PCI-X 133Mhz
+};
+
+enum hp_indicators {
+	INDICATOR_OFF,		// Indicator off state
+	INDICATOR_ON,		// Indicator on state
+	INDICATOR_BLINK,	// Indicator blink state
+	INDICATOR_NORMAL,	// Indicator normal state
+};
+
+struct pci_resource {
+	struct pci_resource * next;
+	u32 base;
+	u32 length;
+};
+
+struct resource_descriptor {
+	u32 base;
+	u32 limit;
+};
+
+struct irq_mapping {
+	u8 barber_pole;
+	u8 valid_INT;
+	u8 interrupt[4];
+};
+
+struct resource_lists {
+	struct pci_resource *mem_head;
+	struct pci_resource *p_mem_head;
+	struct pci_resource *io_head;
+	struct pci_resource *bus_head;
+	struct irq_mapping *irqs;
+};
+
+#define ROM_PHY_ADDR                    0x0F0000
+#define ROM_PHY_LEN                     0x00ffff
+
+#define NOT_ENOUGH_RESOURCES            0x0000000B
+#define DEVICE_TYPE_NOT_SUPPORTED       0x0000000C
+
+//
+// Prototypes
+//
+extern int  amdshpc_resource_sort_and_combine (struct pci_resource **head);
+
+//
+// State-Machine Function
+//
+typedef long ( *SLOT_STATE_FUNCTION )(
+				     void* shpc_context,
+				     void* slot_context);
+
+//
+// SHPC Constants
+//
+#define SHPC_MAX_NUM_SLOTS      4
+
+
+#define arraysize(p) (sizeof(p)/sizeof((p)[0]))
+
+
+//
+// SHPC Register Offsets
+//
+enum shpc_register_offset {
+	SHPC_SLOTS_AVAILABLE1_REG_OFFSET        = 0x04,
+	SHPC_SLOTS_AVAILABLE2_REG_OFFSET        = 0x08,
+	SHPC_SLOT_CONFIG_REG_OFFSET             = 0x0C,
+	SHPC_SEC_BUS_CONFIG_REG_OFFSET          = 0x10,
+	SHPC_COMMAND_REG_OFFSET                 = 0x14,
+	SHPC_STATUS_REG_OFFSET                  = 0x16,
+	SHPC_INT_LOCATOR_REG_OFFSET             = 0x18,
+	SHPC_SERR_LOCATOR_REG_OFFSET            = 0x1C,
+	SHPC_SERR_INT_REG_OFFSET                = 0x20,
+	SHPC_LOGICAL_SLOT_REG_OFFSET            = 0x24,
+};
+
+
+//
+// SHPC Slots Available Register I
+//
+union SHPC_SLOTS_AVAILABLE1_DWREG {
+	struct {
+		u32 N_33CONV    :5;	// 4:0
+		u32 reserved1   :3;	// 7:5
+		u32 N_66PCIX    :5;	// 12:8
+		u32 reserved2   :3;	// 15:13
+		u32 N_100PCIX   :5;	// 20:16
+		u32 reserved3   :3;	// 23:21
+		u32 N_133PCIX   :5;	// 28:24
+		u32 reserved4   :3;	// 31:29
+	}x;
+	u32 AsDWord;
+};
+
+
+//
+// SHPC Slots Available Register II
+//
+union SHPC_SLOTS_AVAILABLE2_DWREG {
+	struct {
+		u32 N_66CONV    :5;	// 4:0
+		u32 reserved4   :27;	// 31:5
+	}x;
+	u32 AsDWord;
+};
+
+
+//
+// SHPC Slot Configuration Register
+//
+union SHPC_SLOT_CONFIG_DWREG {
+	struct {
+		u32 NSI         :5;	// 4:0
+		u32 reserved1   :3;	// 7:5
+		u32 FDN         :5;	// 12:8
+		u32 reserved2   :3;	// 15:13
+		u32 PSN         :11;	// 26:16
+		u32 reserved3   :2;	// 28:27
+		u32 PSN_UP      :1;	// 29
+		u32 MRLSI       :1;	// 30
+		u32 ABI         :1;	// 31
+	}x;
+	u32 AsDWord;
+};
+
+
+//
+// SHPC Secondary Bus Configuration Register
+//
+union SHPC_SEC_BUS_CONFIG_DWREG {
+	struct {
+		u32 MODE        :3;	// 2:0
+		u32 reserved    :21;	// 23:3
+		u32 format      :8;	// 31:24
+	}x;
+	u32 AsDWord;
+};
+
+
+//
+// SHPC Command Register
+//
+union SHPC_COMMAND_WREG {
+	struct {
+		u16 state               : 2;	// 1:0
+		u16 power_led           : 2;	// 3:2
+		u16 attention_led       : 2;	// 5:4
+		u16 code                : 2;	// 7:6
+		u16 TGT                 : 5;	// 12:8
+		u16 reserved            : 3;	// 15:13
+	} Slot;
+	struct {
+		u16 speed_mode          : 3;	// 2:0
+		u16 code                : 5;	// 7:3
+		u16 reserved            : 8;	// 15:8
+	} Bus;
+	struct {
+		u16 code                : 8;	// 7:0
+		u16 reserved            : 8;	// 15:8
+	}x;
+	u16 AsWord;
+};
+
+
+//
+// SHPC Status Register
+//
+union SHPC_STATUS_WREG {
+	struct {
+		u16 BSY         :1;	// 0
+		u16 MRLO_ERR    :1;	// 1
+		u16 INVCMD_ERR  :1;	// 2
+		u16 INVSM_ERR   :1;	// 3
+		u16 reserved    :12;	// 15:4
+	}x;
+	u16 AsWord;
+};
+
+
+//
+// SHPC Interrupt Locator Register
+//
+union SHPC_INT_LOCATOR_DWREG {
+	struct {
+		u32 CC_IP       :1;	// 0
+		u32 SLOT_IP     :4;	// 4:1
+		u32 reserved    :27;	// 31:5
+	}x;
+	u32 AsDWord;
+};
+
+
+//
+// SHPC SERR Locator Register
+//
+union SHPC_SERR_LOCATOR_DWREG {
+	struct {
+		u32 A_SERRP     :1;	// 0
+		u32 SLOT_SERRP  :4;	// 4:1
+		u32 reserved    :27;	// 31:5
+	}x;
+	u32 AsDWord;
+};
+
+
+//
+// SHPC SERR-INT Register
+//
+union SHPC_SERR_INT_DWREG {
+	struct {
+		u32 GIM         :1;	// 0
+		u32 GSERRM      :1;	// 1
+		u32 CC_IM       :1;	// 2
+		u32 A_SERRM     :1;	// 3
+		u32 reserved1   :12;	// 15:4
+		u32 CC_STS      :1;	// 16
+		u32 ATOUT_STS   :1;	// 17
+		u32 reserved2   :14;	// 31:18
+	}x;
+	u32 AsDWord;
+};
+
+
+//
+// SHPC Logical Slot Register
+//
+union SHPC_LOGICAL_SLOT_DWREG {
+	struct {
+		u32 S_STATE     :2;	// 1:0
+		u32 PIS         :2;	// 3:2
+		u32 AIS         :2;	// 5:4
+		u32 PF          :1;	// 6
+		u32 AB          :1;	// 7
+		u32 MRLS        :1;	// 8
+		u32 M66_CAP     :1;	// 9
+		u32 PRSNT1_2    :2;	// 11:10
+		u32 PCIX_CAP    :2;	// 13:12
+		u32 reserved1   :2;	// 15:14
+		u32 CPC_STS     :1;	// 16
+		u32 IPF_STS     :1;	// 17
+		u32 ABP_STS     :1;	// 18
+		u32 MRLSC_STS   :1;	// 19
+		u32 CPF_STS     :1;	// 20
+		u32 reserved2   :3;	// 23:21
+		u32 CP_IM       :1;	// 24
+		u32 IPF_IM      :1;	// 25
+		u32 AB_IM       :1;	// 26
+		u32 MRLS_IM     :1;	// 27
+		u32 CPF_IM      :1;	// 28
+		u32 MRLS_SERRM  :1;	// 29
+		u32 CPF_SERRM   :1;	// 30
+		u32 reserved3   :1;	// 31
+	}x;
+	u32 AsDWord;
+};
+
+
+//
+// Bus Speed/Mode
+//
+enum shpc_speed_mode {
+	SHPC_BUS_CONV_33        = 0,
+	SHPC_BUS_CONV_66        = 1,
+	SHPC_BUS_PCIX_66        = 2,
+	SHPC_BUS_PCIX_100       = 3,
+	SHPC_BUS_PCIX_133       = 4,
+};
+
+
+//
+// Slot PCIX Capability
+//
+enum shpc_slot_pcix_cap {
+	SHPC_SLOT_CONV          = 0,
+	SHPC_SLOT_PCIX_66       = 1,
+	SHPC_SLOT_PCIX_133      = 3,
+};
+
+
+//
+// Slot LEDs
+//
+enum shpc_slot_led {
+	SHPC_led_NO_CHANGE      = 0,
+	SHPC_LED_ON             = 1,
+	SHPC_LED_BLINK          = 2,
+	SHPC_LED_OFF            = 3,
+};
+
+
+//
+// Slot State
+//
+enum shpc_slot_state {
+	SHPC_SLOT_NO_CHANGE     = 0,
+	SHPC_POWER_ONLY         = 1,
+	SHPC_ENABLE_SLOT        = 2,
+	SHPC_DISABLE_SLOT       = 3,
+};
+
+
+//
+// Command Code
+//
+#define SHPC_SLOT_OPERATION             0x00    // 7:6  (00xxxxxxb)
+#define SHPC_SET_BUS_SPEED_MODE         0x08    // 7:3  (01000xxxb)
+#define SHPC_POWER_ONLY_ALL_SLOTS       0x48    // 7:0  (01001000b)
+#define SHPC_ENABLE_ALL_SLOTS           0x49    // 7:0  (01001001b)
+
+
+//
+// SHPC Status
+//
+enum shpc_status {
+	SHPC_STATUS_CLEARED     = 0,
+	SHPC_STATUS_SET         = 1,
+};
+
+
+//
+// SHPC Mask
+//
+enum shpc_mask {
+	SHPC_UNMASKED   = 0,
+	SHPC_MASKED     = 1,
+};
+
+
+//
+// Slot MRL Sensor
+//
+enum shpc_slot_mrl {
+	SHPC_MRL_CLOSED = 0,
+	SHPC_MRL_OPEN   = 1,
+};
+
+
+//
+// Slot Attn Button
+//
+enum shpc_slot_attn_button {
+	SHPC_ATTN_BUTTON_RELEASED  = 0,
+	SHPC_ATTN_BUTTON_PRESSED   = 1,
+};
+
+
+//
+// Card Power Requirements
+//
+enum shpc_card_power {
+	SHPC_CARD_PRESENT_7_5W  = 0,
+	SHPC_CARD_PRESENT_15W   = 1,
+	SHPC_CARD_PRESENT_25W   = 2,
+	SHPC_SLOT_EMPTY         = 3,
+};
+
+
+// slot config structure
+union SLOT_CONFIG_INFO {
+	struct {
+		u32             lu_slots_implemented    : 5;	// [ 4:0 ]Number of slots implemented
+		u32             lu_reserved1            : 3;	// [ 7:5 ]Reserved
+		u32             lu_base_FDN             : 5;	// [ 12:8 ]First Device Number
+		u32             lu_reserved2            : 3;	// [ 15:13 ]Reserved
+		u32             lu_base_PSN             : 11;	// [ 26:16 ]Physical Slot Number
+		u32             lu_reserved3            : 2;	// [ 28:27 ]Reserved
+		u32             lu_PSN_up               : 1;	// [ 29 ]PSN Up (1=TRUE, 0=FALSE)
+		u32             lu_reserved4            : 2;	// [ 31:30 ]Reserved
+	}x;
+	u32     AsDWord;
+};
+
+
+// logical slot information
+union SLOT_STATUS_INFO {
+	struct {
+		u32     lu_slot_state           : 1;	// [ 0 ]Slot state (1=Enabled, 0=Disabled)
+		u32     lu_power_fault          : 1;	// [ 1 ]Power-Fault? (1=TRUE, 0=FALSE)
+		u32     lu_card_present         : 1;	// [ 2 ]Card Present? (1=TRUE, 0=FALSE)
+		u32     lu_card_power           : 2;	// [ 4:3 ]Card Power Requirements (low/medium/high)
+		u32     lu_card_mode_freq_cap   : 3;	// [ 7:5 ]Card Speed/mode capability
+		u32     lu_mrl_implemented      : 1;	// [ 8 ]MRL Implemented? (1=TRUE, 0=FALSE)
+		u32     lu_mrl_opened           : 1;	// [ 9 ]MRL State (if implemented: 1=TRUE, 0=FALSE)
+		u32     lu_ai_state             : 2;	// [ 11:10 ]Attn Indicator State (Blink/On/Off)
+		u32     lu_pi_state             : 2;	// [ 13:12 ]Power Indicator State (Blink/On/Off)
+		u32     lu_reserved1            : 2;	// [ 14 ]Reserved
+		u32	lu_card_pci66_capable   : 1;	// [ 15 ]Card PCI66 capability (1=TRUE, 0=FALSE)
+		u32     lu_bus_mode_freq        : 3;	// [ 18:16 ]Current Bus speed/mode
+		u32     lu_max_bus_mode_freq    : 3;	// [ 21:19 ]Maximum Bus speed/mode
+		u32     lu_reserved2            : 9;	// [ 30:22 ]Reserved
+		u32     lu_request_failed       : 1;	// [ 31 ]Request Failed? (1=TRUE, 0=FALSE)
+	}x;
+	u32     AsDWord;
+};
+
+enum return_status {
+	STATUS_UNSUCCESSFUL,
+	STATUS_SUCCESS
+};
+
+//
+// Async Request
+//
+enum shpc_async_request {
+	SHPC_ASYNC_ENABLE_SLOT,
+	SHPC_ASYNC_DISABLE_SLOT,
+	SHPC_ASYNC_SURPRISE_REMOVE,
+	SHPC_ASYNC_QUIESCE_DEVNODE,
+	SHPC_ASYNC_QUIESCE_DEVNODE_QUIET,
+	SHPC_ASYNC_QUIESCE_DEVNODE_NOTIFY,
+	SHPC_ASYNC_CANCEL_QUIESCE_DEVNODE,
+	SHPC_ASYNC_LED_LOCATE,
+	SHPC_ASYNC_LED_NORMAL
+};
+
+
+//
+// Async Request
+//
+struct async_request {
+	enum shpc_async_request type;
+	wait_queue_head_t       event;
+	unsigned long           timeout;
+	void                    *request_context;
+};
+
+
+//
+// Async Completion
+//
+struct async_completion {
+	enum shpc_async_request type;
+	unsigned long                   timeout;
+	u8                              hw_initiated;
+	u8                              done;
+	enum hp_boolean                 failed;
+	void                            *request_context;
+};
+
+// ****************************************************************************
+//
+// async_callback() @ PASSIVE_LEVEL
+//
+// Parameters
+//      driver_context - Pointer provided in hp_AddDevice()
+//      slot_id - Zero-based slot number (0..n-1).
+//      Request - Async request completed.  For example: Slot Enable/Disable, AttnLED Attn/Normal.
+//      Status - Slot status at completion
+//      request_context - Pointer provided in hp_StartAsyncRequest(), NULL for
+//              completions on hardware-initiated requests.
+//
+// Return Value
+//      For QUIESCE_DEVNODE request: #DevNodes associated with a particular slot, else 0.
+//
+// ****************************************************************************
+typedef unsigned long ( *SHPC_ASYNC_CALLBACK )( void* driver_context,
+						u8 slot_id,
+						enum shpc_async_request Request,
+						union SLOT_STATUS_INFO Status,
+						void* request_context );
+
+//
+// Slot Context
+//
+struct slot_context {
+
+	spinlock_t		slot_spinlock;
+	struct semaphore        slot_event_bits_semaphore;
+	struct semaphore        cmd_acquire_mutex;
+	struct semaphore        bus_acquire_mutex;
+	u32                     *logical_slot_addr;
+	u8                      slot_number;
+	u8                      slot_psn;
+	u32                     quiesce_requests;
+	u32                     quiesce_replies;
+	u8                      slot_enabled;
+	enum shpc_speed_mode    card_speed_mode;
+	u8                      card_pci66_capable;
+	u8                      in_bus_speed_mode_contention;
+	u8                      problem_detected;
+	u8                      slot_quiesced;
+	u8                      slot_occupied;
+	struct tasklet_struct   attn_button_dpc;
+	struct tasklet_struct   mrl_sensor_dpc;
+	struct tasklet_struct   card_presence_dpc;
+	struct tasklet_struct   isolated_power_fault_dpc;
+	struct tasklet_struct   connected_power_fault_dpc;
+	wait_queue_head_t       slot_event;
+	wait_queue_head_t       led_cmd_acquire_event;
+	wait_queue_head_t       led_cmd_release_event;
+	wait_queue_head_t       cmd_acquire_event;
+	wait_queue_head_t       cmd_release_event;
+	wait_queue_head_t       bus_acquire_event;
+	wait_queue_head_t       bus_release_event;
+	u32                     slot_event_bits;
+	void                    *slot_thread;
+	void                    *attn_led_thread;
+	SLOT_STATE_FUNCTION     slot_function;
+	SLOT_STATE_FUNCTION     attn_led_function;
+	struct async_request    slot_request;
+	struct async_completion slot_completion;
+	struct async_request    attn_led_request;
+	struct async_completion attn_led_completion;
+	void                    *shpc_context;
+	struct timer_list       slot_timer1;
+	struct timer_list       slot_timer2;
+	struct timer_list       slot_timer3;
+	struct timer_list       slot_timer4;
+	struct timer_list       slot_timer5;
+	struct timer_list       slot_timer6;
+	struct timer_list       slot_timer7;
+	struct timer_list       slot_timer8;
+	struct timer_list       slot_timer9;
+	struct timer_list       slot_timer10;
+	struct timer_list       led_timer1;
+	struct timer_list       led_timer2;
+	struct timer_list       led_timer3;
+	struct timer_list       led_timer4;
+};
+
+//
+// SHPC Context
+//
+struct shpc_context {
+	spinlock_t		shpc_spinlock;
+	struct semaphore        shpc_event_bits_semaphore;
+	void                    *mmio_base_addr;
+	struct shpc_context     *next;
+	u8                      first_slot;
+	u8                      number_of_slots;
+	u8                      slots_enabled;
+	u8                      at_power_device_d0;
+	u8                      bus_released;
+	enum shpc_speed_mode    max_speed_mode;
+	enum shpc_speed_mode    bus_speed_mode;
+	struct semaphore        cmd_available_mutex;
+	struct tasklet_struct   cmd_completion_dpc;
+	struct semaphore        bus_available_mutex;
+	wait_queue_head_t       *user_event_pointer;
+	u32                     shpc_event_bits;
+	void                    *driver_context;
+	SHPC_ASYNC_CALLBACK     async_callback;
+	u32                     shpc_instance;
+	struct slot_context     slot_context[ SHPC_MAX_NUM_SLOTS ];
+	void                    *hpc_reg;		// cookie for our pci controller location
+	struct pci_ops          *pci_ops;
+	struct pci_resource     *mem_head;
+	struct pci_resource     *p_mem_head;
+	struct pci_resource     *io_head;
+	struct pci_resource     *bus_head;
+	struct pci_dev          *pci_dev;
+	u8                      interrupt;
+	u8                      bus;
+	u8                      device;
+	u8                      function;
+	u16                     vendor_id;
+	u32                     ctrl_int_comp;
+	u8                      add_support;
+};
+
+//
+// Function Prototypes
+//
+int amdshpc_get_bus_dev (struct controller  *ctrl, u8 * bus_num, u8 * dev_num, u8 slot);
+int amdshpc_process_SI (struct controller *ctrl, struct pci_func *func);
+int amdshpc_process_SS (struct controller *ctrl, struct pci_func *func);
+int amdshpc_find_available_resources (struct controller *ctrl, void *rom_start);
+int amdshpc_save_config(struct controller *ctrl, int busnumber, union SLOT_CONFIG_INFO * is_hot_plug);
+struct pci_func *amdshpc_slot_create(u8 busnumber);
+
+
+void hp_clear_shpc_event_bit(struct shpc_context * shpc_context, u32 mask);
+void hp_set_shpc_event_bit(struct shpc_context * shpc_context, u32 mask);
+
+void hp_clear_slot_event_bit(struct slot_context * slot_context, u32 mask);
+void hp_set_slot_event_bit(struct slot_context * slot_context, u32 mask);
+
+void hp_send_event_to_all_slots(struct shpc_context *shpc_context, u32 mask);
+void hp_send_slot_event(struct slot_context *slot_context, u32 mask);
+
+int hp_get_led_cmd_available_mutex_thread(void *slot_context);
+int hp_get_cmd_available_mutex_thread    (void *slot_context);
+int hp_get_bus_available_mutex_thread(void *slot_context);
+int hp_cmd_available_mutex_thread(void * slot_context);
+int hp_bus_available_mutex_thread(void * slot_context);
+int hp_led_cmd_available_mutex_thread(void * slot_context);
+
+void hp_slot_timer1_func(unsigned long data);
+void hp_slot_timer2_func(unsigned long data);
+void hp_slot_timer3_func(unsigned long data);
+void hp_slot_timer4_func(unsigned long data);
+void hp_slot_timer5_func(unsigned long data);
+void hp_slot_timer6_func(unsigned long data);
+void hp_slot_timer7_func(unsigned long data);
+void hp_slot_timer8_func(unsigned long data);
+void hp_slot_timer9_func(unsigned long data);
+void hp_slot_timer10_func(unsigned long data);
+void hp_led_timer1_func(unsigned long data);
+void hp_led_timer2_func(unsigned long data);
+void hp_led_timer3_func(unsigned long data);
+void hp_led_timer4_func(unsigned long data);
+
+irqreturn_t hp_interrupt_service(int IRQ, void *v, struct pt_regs *regs);
+
+u32 board_replaced(struct pci_func * func, struct controller  * ctrl);
+struct pci_func *amdshpc_slot_find(u8 bus, u8 device, u8 index);
+int amdshpc_save_base_addr_length(struct controller  *ctrl, struct pci_func * func);
+int amdshpc_save_used_resources (struct controller  *ctrl, struct pci_func * func);
+int amdshpc_return_board_resources(struct pci_func * func, struct resource_lists * resources);
+int amdshpc_save_slot_config (struct controller  *ctrl, struct pci_func * new_slot);
+int amdshpc_configure_device (struct controller * ctrl, struct pci_func* func);
+int amdshpc_unconfigure_device(struct pci_func* func);
+
+
+
+void
+hp_attn_button_dpc(
+			  unsigned long deferred_context
+			  );
+
+void
+hp_mrl_sensor_dpc(
+			 unsigned long deferred_context
+			 );
+
+void
+hp_card_presence_dpc(
+			    unsigned long deferred_context
+			    );
+
+void
+hp_isolated_power_fault_dpc(
+				   unsigned long deferred_context
+				   );
+
+void
+hp_connected_power_fault_dpc(
+			    unsigned long deferred_context
+			    );
+
+void
+hp_cmd_completion_dpc(
+		     unsigned long deferred_context
+		     );
+
+int
+hp_slot_thread(
+	      void* slot_context
+	      );
+
+long
+hp_at_slot_disabled_wait_for_slot_request(
+					 struct shpc_context* shpc_context,
+					 struct slot_context* slot_context
+						 );
+
+long
+hp_at_slot_disabled_wait_for_led_cmd_available(
+					      struct shpc_context* shpc_context,
+					      struct slot_context* slot_context
+					      );
+
+long
+hp_at_slot_disabled_wait_for_led_cmd_completion(
+					       struct shpc_context* shpc_context,
+					       struct slot_context* slot_context
+					       );
+
+long
+hp_at_slot_disabled_wait_for_timeout(
+				    struct shpc_context* shpc_context,
+				    struct slot_context* slot_context
+				    );
+
+long
+hp_at_slot_disabled_wait_for_power_cmd_available(
+						struct shpc_context* shpc_context,
+						struct slot_context* slot_context
+						);
+
+long
+hp_at_slot_disabled_wait_for_power_cmd_timeout(
+					      struct shpc_context* shpc_context,
+					      struct slot_context* slot_context
+					      );
+
+long
+hp_at_slot_disabled_wait_for_power_cmd_completion(
+						 struct shpc_context* shpc_context,
+						 struct slot_context* slot_context
+						 );
+
+long
+hp_at_slot_disabled_wait_for_bus_available(
+					  struct shpc_context* shpc_context,
+					  struct slot_context* slot_context
+					  );
+
+long
+hp_at_slot_disabled_wait_for_bus_released(
+					 struct shpc_context* shpc_context,
+					 struct slot_context* slot_context
+					 );
+
+long
+hp_at_slot_disabled_wait_for_speed_mode_cmd_available(
+						     struct shpc_context* shpc_context,
+						     struct slot_context* slot_context
+						     );
+
+long
+hp_at_slot_disabled_wait_for_speed_mode_cmd_completion(
+						      struct shpc_context* shpc_context,
+						      struct slot_context* slot_context
+						      );
+
+long
+hp_at_slot_disabled_wait_for_enable_cmd_available(
+						 struct shpc_context* shpc_context,
+						 struct slot_context* slot_context
+						 );
+
+long
+hp_at_slot_disabled_wait_for_enable_cmd_completion(
+						  struct shpc_context* shpc_context,
+						  struct slot_context* slot_context
+						  );
+
+long
+hp_at_slot_disabled_wait_for_enable_timeout(
+					   struct shpc_context* shpc_context,
+					   struct slot_context* slot_context
+					   );
+
+long
+hp_to_slot_disabled_wait_for_led_cmd_available(
+					      struct shpc_context* shpc_context,
+					      struct slot_context* slot_context
+					      );
+
+long
+hp_to_slot_disabled_wait_for_led_cmd_completion(
+					       struct shpc_context* shpc_context,
+					       struct slot_context* slot_context
+					       );
+
+long
+hp_to_slot_disabled_wait_for_disable_cmd_available(
+						  struct shpc_context* shpc_context,
+						  struct slot_context* slot_context
+						  );
+
+long
+hp_to_slot_disabled_wait_for_disable_cmd_completion(
+						   struct shpc_context* shpc_context,
+						   struct slot_context* slot_context
+						   );
+
+long
+hp_to_slot_disabled_wait_for_disable_timeout(
+					    struct shpc_context* shpc_context,
+					    struct slot_context* slot_context
+					    );
+
+long
+hp_to_slot_disabled_wait_for_bus_available(
+					  struct shpc_context* shpc_context,
+					  struct slot_context* slot_context
+					  );
+
+long
+hp_at_slot_enabled_wait_for_slot_request(
+					struct shpc_context* shpc_context,
+					struct slot_context* slot_context
+					);
+
+long
+hp_at_slot_enabled_wait_for_stop_on_bus_rebalance(
+						 struct shpc_context* shpc_context,
+						 struct slot_context* slot_context
+						 );
+
+long
+hp_at_slot_enabled_wait_for_power_cmd_available(
+					       struct shpc_context* shpc_context,
+					       struct slot_context* slot_context
+					       );
+
+long
+hp_at_slot_enabled_wait_for_power_cmd_completion(
+						struct shpc_context* shpc_context,
+						struct slot_context* slot_context
+						);
+
+long
+hp_at_slot_enabled_wait_for_led_cmd_available(
+					     struct shpc_context* shpc_context,
+					     struct slot_context* slot_context
+					     );
+
+long
+hp_at_slot_enabled_wait_for_led_cmd_completion(
+					      struct shpc_context* shpc_context,
+					      struct slot_context* slot_context
+					      );
+
+long
+hp_at_slot_enabled_wait_for_timeout(
+				   struct shpc_context* shpc_context,
+				   struct slot_context* slot_context
+				   );
+
+long
+hp_at_slot_enabled_wait_for_stop_on_slot_disable(
+						struct shpc_context* shpc_context,
+						struct slot_context* slot_context
+						);
+
+long
+hp_at_slot_enabled_wait_for_stop_on_slot_disable_quiet(
+						      struct shpc_context* shpc_context,
+						      struct slot_context* slot_context
+						      );
+
+long
+hp_to_slot_enabled_wait_for_led_cmd_available(
+					     struct shpc_context* shpc_context,
+					     struct slot_context* slot_context
+					     );
+
+long
+hp_to_slot_enabled_wait_for_led_cmd_completion(
+					      struct shpc_context* shpc_context,
+					      struct slot_context* slot_context
+					      );
+
+void
+hp_get_slot_configuration(
+			 struct shpc_context* shpc_context
+			 );
+
+void
+hp_enable_slot_interrupts(
+			 struct slot_context* slot_context
+			 );
+
+void
+hp_disable_slot_interrupts(
+			  struct slot_context* slot_context
+			  );
+
+void
+hp_enable_global_interrupts(
+			   struct shpc_context* shpc_context
+			   );
+
+void
+hp_disable_global_interrupts(
+			    struct shpc_context* shpc_context
+			    );
+
+enum shpc_speed_mode
+hp_get_bus_speed_mode(
+		     struct shpc_context* shpc_context
+		     );
+
+enum shpc_speed_mode
+hp_get_card_speed_mode(
+		      struct slot_context* slot_context
+		      );
+
+enum mode_frequency
+hp_translate_speed_mode(
+		       enum shpc_speed_mode shpc_speed_mode
+		       );
+
+enum hp_power_requirements
+hp_translate_card_power(
+		       enum shpc_card_power ShpcCardPower
+			       );
+
+enum hp_indicators
+hp_translate_indicator(
+		      enum shpc_slot_led ShpcIndicator
+			      );
+
+u8
+hp_flag_slot_as_enabled(
+		       struct shpc_context* shpc_context,
+		       struct slot_context* slot_context
+		       );
+
+u8
+hp_flag_slot_as_disabled(
+			struct shpc_context* shpc_context,
+			struct slot_context* slot_context
+			);
+
+u8
+hp_signal_enabled_slots_to_rebalance_bus(
+					struct shpc_context* shpc_context
+					);
+
+enum shpc_speed_mode
+hp_get_max_speed_mode(
+		     struct shpc_context* shpc_context,
+		     enum shpc_speed_mode From_speed_mode
+		     );
+
+void
+hp_signal_user_event(
+		    struct shpc_context* shpc_context
+		    );
+
+void
+hp_signal_user_event_at_dpc_level(
+				 struct shpc_context* shpc_context
+				 );
+
+int
+hp_attn_led_thread(
+		  void* slot_context
+		  );
+
+long
+hp_wait_for_attn_led_request(
+			    struct shpc_context* shpc_context,
+			    struct slot_context* slot_context
+			    );
+
+long
+hp_wait_for_attn_led_blink_cmd_available(
+					struct shpc_context* shpc_context,
+					struct slot_context* slot_context
+					);
+
+long
+hp_wait_for_attn_led_blink_cmd_completion(
+					 struct shpc_context* shpc_context,
+					 struct slot_context* slot_context
+					 );
+
+long
+hp_wait_for_attn_led_blink_timeout(
+				  struct shpc_context* shpc_context,
+				  struct slot_context* slot_context
+				  );
+
+long
+hp_wait_for_attn_led_normal_cmd_available(
+					 struct shpc_context* shpc_context,
+					 struct slot_context* slot_context
+					 );
+
+long
+hp_wait_for_attn_led_normal_cmd_completion(
+					  struct shpc_context* shpc_context,
+					  struct slot_context* slot_context
+					  );
+
+long
+hp_wait_for_attn_led_back_to_normal_cmd_available(
+						 struct shpc_context* shpc_context,
+						 struct slot_context* slot_context
+						 );
+
+long
+hp_wait_for_attn_led_back_to_normal_cmd_completion(
+						  struct shpc_context* shpc_context,
+						  struct slot_context* slot_context
+						  );
+
+
+
+#endif  // _SHPC_H_
diff -purN linux-2.5/drivers/pci/hotplug/amdshpc_core.c usb-2.5/drivers/pci/hotplug/amdshpc_core.c
--- linux-2.5/drivers/pci/hotplug/amdshpc_core.c	1970-01-01 00:00:00.000000000 +0000
+++ usb-2.5/drivers/pci/hotplug/amdshpc_core.c	2003-08-28 23:06:29.000000000 +0000
@@ -0,0 +1,915 @@
+/*
+ * Copyright (C) 2001,2003 Greg Kroah-Hartman (greg@kroah.com)
+ * Copyright (C) 2001,2003 IBM Corp.
+ * Copyright (C) 2002-2003 Advanced Micro Devices
+ *
+ * YOUR USE OF THIS CODE IS SUBJECT TO THE TERMS
+ * AND CONDITIONS OF THE GNU GENERAL PUBLIC
+ * LICENSE FOUND IN THE "GPL.TXT" FILE THAT IS
+ * INCLUDED WITH THIS FILE AND POSTED AT
+ * http://www.gnu.org/licenses/gpl.html
+ *
+ *
+ * Send feedback to <greg@kroah.com> <david.keck@amd.com>
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <asm/uaccess.h>
+#include <linux/slab.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include "amdshpc.h"
+#include "amdshpc_ddi.h"
+#include "pci_hotplug.h"
+#include "../../../arch/i386/pci/pci.h"
+
+/* Global variables */
+int amdshpc_debug;
+struct shpc_context *amdshpc_ctrl_list; // used for the shpc state machine
+struct controller *ctrl_list;	 	  // used only for resource management
+struct pci_func *amdshpc_slot_list[256];
+
+static int num_slots;
+static void *amdshpc_rom_start;
+static unsigned long shpc_instance;
+
+#define DRIVER_VERSION	"1.03"
+#define DRIVER_AUTHOR	"Dave Keck <david.keck@amd.com>"
+#define DRIVER_DESC	"AMD Standard Hot Plug Controller Driver"
+#define PCI_DEVICE_ID_AMD_GOLAM_7450	0x7450
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
+//MODULE_PARM(debug, "i");
+//MODULE_PARM_DESC(debug, "Debugging mode enabled or not");
+
+static int enable_slot		(struct hotplug_slot *slot);
+static int disable_slot		(struct hotplug_slot *slot);
+static int set_attention_status (struct hotplug_slot *slot, u8 value);
+static int hardware_test	(struct hotplug_slot *slot, u32 value);
+static int get_power_status	(struct hotplug_slot *slot, u8 *value);
+static int get_attention_status	(struct hotplug_slot *slot, u8 *value);
+static int get_latch_status	(struct hotplug_slot *slot, u8 *value);
+static int get_adapter_status	(struct hotplug_slot *slot, u8 *value);
+
+// values to be returned to the PCI Hotplug Core
+#define CORE_SLOT_DISABLED		0
+#define CORE_SLOT_ENABLED		1
+
+#define	CORE_INDICATOR_OFF		0
+#define	CORE_INDICATOR_ON		1
+#define	CORE_INDICATOR_BLINK		2
+
+#define CORE_LATCH_CLOSED		1
+#define CORE_LATCH_OPENED		0
+
+static int init_slots (	struct controller *ctrl, int num_slots );
+static void translate_slot_info (struct hotplug_slot_info *info,
+								 union SLOT_STATUS_INFO *query);
+
+static struct hotplug_slot_ops skel_hotplug_slot_ops = {
+	.owner =		THIS_MODULE,
+	.enable_slot =		enable_slot,
+	.disable_slot =		disable_slot,
+	.set_attention_status =	set_attention_status,
+	.hardware_test =	hardware_test,
+	.get_power_status =	get_power_status,
+	.get_attention_status =	get_attention_status,
+	.get_latch_status =	get_latch_status,
+	.get_adapter_status =	get_adapter_status,
+};
+
+/* Inline functions to check the sanity of a pointer that is passed to us */
+static inline int slot_paranoia_check (struct slot *slot, const char *function)
+{
+	if (!slot) {
+		dbg("-->%s - slot == NULL", function);
+		return -1;
+	}
+	if (slot->magic != SLOT_MAGIC) {
+		dbg("-->%s - bad magic number for slot", function);
+		return -1;
+	}
+	if (!slot->hotplug_slot) {
+		dbg("-->%s - slot->hotplug_slot == NULL!", function);
+		return -1;
+	}
+	return 0;
+}
+
+static inline struct slot *get_slot (struct hotplug_slot *hotplug_slot, const char *function)
+{
+	struct slot *slot;
+
+	if (!hotplug_slot) {
+		dbg("-->%s - hotplug_slot == NULL\n", function);
+		return NULL;
+	}
+
+	slot = (struct slot *)hotplug_slot->private;
+	if (slot_paranoia_check (slot, function))
+				return NULL;
+	return slot;
+}
+
+static int enable_slot (struct hotplug_slot *hotplug_slot)
+{
+	struct slot *slot = get_slot (hotplug_slot, __FUNCTION__);
+	struct shpc_context *shpc_context;
+	union SLOT_STATUS_INFO query;
+	long status;
+	int retval = 0;
+
+
+	if (slot == NULL)
+		return -ENODEV;
+
+	dbg ("%s - physical_slot = %s\n", __FUNCTION__, hotplug_slot->name);
+
+	/*
+	 *  enable the specified slot
+	 */
+	shpc_context = ( struct shpc_context * )slot->private;
+	status = hp_StartAsyncRequest(shpc_context, slot->number,
+		SHPC_ASYNC_ENABLE_SLOT, 0, slot );
+
+	//
+	// pretend async request was completed (we're not queuing slot requests)
+	//
+	hp_QuerySlotStatus( shpc_context, slot->number, &query );
+	if( status == STATUS_SUCCESS ) {
+		query.x.lu_slot_state = SLOT_ENABLE;
+		query.x.lu_pi_state = INDICATOR_BLINK;
+		if( query.x.lu_card_present &&
+			( query.x.lu_mrl_implemented == HP_FALSE ||
+			query.x.lu_mrl_opened == HP_FALSE ) &&
+			query.x.lu_power_fault == HP_FALSE ) {
+				query.x.lu_request_failed = HP_FALSE;
+		}
+		else {
+			query.x.lu_request_failed = HP_TRUE;
+		}
+	}
+	else {
+		query.x.lu_request_failed = HP_TRUE;
+	}
+
+	//
+	// translate the slot info to PCI HOTPLUG CORE values
+	//
+	translate_slot_info (hotplug_slot->info, &query);
+
+	retval = ( query.x.lu_request_failed == HP_TRUE ) ? 0 : -1;
+	return retval;
+}
+
+
+static int disable_slot (struct hotplug_slot *hotplug_slot)
+{
+	struct slot *slot = get_slot (hotplug_slot, __FUNCTION__);
+	struct shpc_context *shpc_context;
+	union SLOT_STATUS_INFO query;
+	long status;
+	int retval = 0;
+
+	if (slot == NULL)
+		return -ENODEV;
+
+	dbg ("%s - physical_slot = %s\n", __FUNCTION__, hotplug_slot->name);
+
+	/*
+	 *  disable the specified slot
+	 */
+	shpc_context = ( struct shpc_context * )slot->private;
+	status = hp_StartAsyncRequest(shpc_context, slot->number,
+		SHPC_ASYNC_DISABLE_SLOT, 0, slot );
+
+	//
+	// pretend async request was completed (we're not queuing slot requests)
+	//
+	hp_QuerySlotStatus( shpc_context, slot->number, &query );
+	if( status == STATUS_SUCCESS ) {
+		query.x.lu_slot_state = SLOT_DISABLE;
+		query.x.lu_pi_state = INDICATOR_BLINK;
+		query.x.lu_request_failed = HP_FALSE;
+	}
+	else {
+		query.x.lu_request_failed = HP_TRUE;
+	}
+
+	//
+	// translate the slot info to CORE values
+	//
+	translate_slot_info (hotplug_slot->info, &query);
+
+	retval = ( query.x.lu_request_failed == HP_TRUE ) ? 0 : -1;
+	return retval;
+}
+
+static int set_attention_status (struct hotplug_slot *hotplug_slot, u8 status)
+{
+	struct slot *slot = get_slot (hotplug_slot, __FUNCTION__);
+	struct shpc_context *shpc_context;
+	int retval = 0;
+
+	if (slot == NULL)
+		return -ENODEV;
+
+	dbg (" %s - physical_slot = %s  state = %d",__FUNCTION__, hotplug_slot->name, status);
+
+	/*
+	 *  turn light on/off
+	 */
+	shpc_context = (struct shpc_context *)slot->private;
+
+	status = hp_StartAsyncRequest(shpc_context, slot->number,
+		((status == CORE_INDICATOR_OFF) ? SHPC_ASYNC_LED_NORMAL : SHPC_ASYNC_LED_LOCATE), 10, slot);
+	hotplug_slot->info->attention_status  = status;
+
+	return retval;
+}
+
+static int get_power_status (struct hotplug_slot *hotplug_slot, u8 *value)
+{
+	struct slot *slot = get_slot (hotplug_slot, __FUNCTION__);
+	struct shpc_context *shpc_context;
+	union SLOT_STATUS_INFO query;
+	int retval = 0;
+
+	if (slot == NULL)
+		return -ENODEV;
+
+	dbg("%s - physical_slot = %s\n",__FUNCTION__, hotplug_slot->name);
+
+	/*
+	 * get the current power status of the specific
+	 * slot and store it in the *value location.
+	 */
+	shpc_context = (struct shpc_context *)slot->private;
+	hp_QuerySlotStatus(shpc_context, slot->number, &query);
+	translate_slot_info (hotplug_slot->info, &query);
+	*value = hotplug_slot->info->power_status;
+
+	return retval;
+}
+
+static int get_attention_status (struct hotplug_slot *hotplug_slot, u8 *value)
+{
+	struct slot *slot = get_slot (hotplug_slot, __FUNCTION__);
+	struct shpc_context *shpc_context;
+	union SLOT_STATUS_INFO query;
+	int retval = 0;
+
+	if (slot == NULL)
+		return -ENODEV;
+
+	dbg("%s - physical_slot = %s\n",__FUNCTION__, hotplug_slot->name);
+
+	/*
+	 * get the current attention status of the specific
+	 * slot and store it in the *value location.
+	 */
+	shpc_context = (struct shpc_context *)slot->private;
+	hp_QuerySlotStatus(shpc_context, slot->number, &query);
+	translate_slot_info (hotplug_slot->info, &query);
+	*value = hotplug_slot->info->attention_status;
+
+	return retval;
+}
+
+static int get_latch_status (struct hotplug_slot *hotplug_slot, u8 *value)
+{
+	struct slot *slot = get_slot (hotplug_slot, __FUNCTION__);
+	struct shpc_context *shpc_context;
+	union SLOT_STATUS_INFO query;
+	int retval = 0;
+
+	if (slot == NULL)
+		return -ENODEV;
+
+	dbg("%s - physical_slot = %s\n",__FUNCTION__, hotplug_slot->name);
+
+	/*
+	 * get the current latch status of the specific
+	 * slot and store it in the *value location.
+	 */
+	shpc_context = (struct shpc_context *)slot->private;
+	hp_QuerySlotStatus(shpc_context, slot->number, &query);
+	translate_slot_info (hotplug_slot->info, &query);
+	*value = hotplug_slot->info->latch_status;
+
+	return retval;
+}
+
+static int get_adapter_status (struct hotplug_slot *hotplug_slot, u8 *value)
+{
+	struct slot *slot = get_slot (hotplug_slot, __FUNCTION__);
+	struct shpc_context *shpc_context;
+	union SLOT_STATUS_INFO query;
+	int retval = 0;
+
+	if (slot == NULL)
+		return -ENODEV;
+
+	dbg("%s - physical_slot = %s\n",__FUNCTION__, hotplug_slot->name);
+
+	/*
+	 * get the current adapter status of the specific
+	 * slot and store it in the *value location.
+	 */
+	shpc_context = (struct shpc_context *)slot->private;
+	hp_QuerySlotStatus(shpc_context, slot->number, &query);
+	translate_slot_info (hotplug_slot->info, &query);
+	*value = hotplug_slot->info->adapter_status;
+
+	return retval;
+}
+
+static void translate_slot_info (struct hotplug_slot_info *info,
+				 union SLOT_STATUS_INFO *query)
+{
+	// power indicator
+	if( query->x.lu_pi_state == INDICATOR_OFF ) {
+		info->power_status = CORE_INDICATOR_OFF;
+	}
+	else if( query->x.lu_pi_state == INDICATOR_ON ) {
+		info->power_status = CORE_INDICATOR_ON;
+	}
+	else {
+		info->power_status = CORE_INDICATOR_BLINK;
+	}
+
+	// attention indicator
+	if( query->x.lu_ai_state == INDICATOR_OFF ) {
+		info->attention_status = CORE_INDICATOR_OFF;
+	}
+	else if( query->x.lu_ai_state == INDICATOR_ON ) {
+		info->attention_status = CORE_INDICATOR_ON;
+	}
+	else {
+		info->attention_status = CORE_INDICATOR_BLINK;
+	}
+
+	// retention latch
+	if( query->x.lu_mrl_implemented == HP_TRUE &&
+		query->x.lu_mrl_opened == HP_TRUE ) {
+		info->latch_status = CORE_LATCH_OPENED;
+	}
+	else {
+		info->latch_status = CORE_LATCH_CLOSED;
+	}
+
+	// adapter status
+	if( query->x.lu_slot_state == SLOT_ENABLE ) {
+		info->adapter_status = CORE_SLOT_ENABLED;
+	}
+	else {
+		info->adapter_status = CORE_SLOT_DISABLED;
+	}
+}
+
+static int hardware_test (struct hotplug_slot *hotplug_slot, u32 value)
+{
+	struct slot *slot = get_slot (hotplug_slot, __FUNCTION__);
+	int retval = 0;
+
+	if (slot == NULL)
+		return -ENODEV;
+
+	dbg ("%s - physical_slot = %s\n", __FUNCTION__, hotplug_slot->name);
+
+	err ("No hardware tests are defined for this driver");
+	retval = -ENODEV;
+
+	/* Or you can specify a test if you want to */
+	/* AMD driver does not have a test */
+	return retval;
+}
+
+#define SLOT_NAME_SIZE	10
+static void make_slot_name (struct slot *slot)
+{
+	unsigned long slot_psn;
+	struct shpc_context *shpc_context;
+
+	shpc_context = ( struct shpc_context * )slot->private;
+
+	//
+	// Get physical slot number
+	//
+	hp_Queryslot_psn(shpc_context, slot->number, &slot_psn);
+
+	snprintf (slot->hotplug_slot->name, SLOT_NAME_SIZE, "%d", (char)slot_psn);
+}
+
+static void release_slot(struct hotplug_slot *hotplug_slot)
+{
+	struct slot *slot = get_slot (hotplug_slot, __FUNCTION__);
+
+	if (slot == NULL)
+		return;
+
+	dbg ("%s - physical_slot = %s\n", __FUNCTION__, hotplug_slot->name);
+
+	kfree(slot->hotplug_slot->info);
+	kfree(slot->hotplug_slot->name);
+	kfree(slot->hotplug_slot);
+	kfree(slot);
+}
+
+static int init_slots (struct controller *ctrl, int num_slots)
+{
+	struct slot *slot;
+	struct hotplug_slot *hotplug_slot;
+	struct hotplug_slot_info *info;
+	char *name;
+	int retval = 0;
+	int i;
+	u8 value;
+
+	/*
+	 * Create a structure for each slot, and register that slot
+	 * with the pci_hotplug subsystem.
+	 */
+	for (i = 0; i < num_slots; ++i) {
+		slot = kmalloc (sizeof (struct slot), GFP_KERNEL);
+		if (!slot)
+			return -ENOMEM;
+		memset(slot, 0, sizeof(struct slot));
+
+		hotplug_slot = kmalloc (sizeof (struct hotplug_slot), GFP_KERNEL);
+		if (!hotplug_slot) {
+			kfree (slot);
+			return -ENOMEM;
+		}
+		memset(hotplug_slot, 0, sizeof (struct hotplug_slot));
+		slot->hotplug_slot = hotplug_slot;
+
+		info = kmalloc (sizeof (struct hotplug_slot_info), GFP_KERNEL);
+		if (!info) {
+			kfree (hotplug_slot);
+			kfree (slot);
+			return -ENOMEM;
+		}
+		memset(info, 0, sizeof (struct hotplug_slot_info));
+		hotplug_slot->info = info;
+
+		name = kmalloc (SLOT_NAME_SIZE, GFP_KERNEL);
+		if (!name) {
+			kfree (info);
+			kfree (hotplug_slot);
+			kfree (slot);
+			return -ENOMEM;
+		}
+		hotplug_slot->name = name;
+
+		slot->magic = SLOT_MAGIC;
+		slot->number = i;
+		slot->private = (void*) ctrl->shpc_context;
+
+		hotplug_slot->private = slot;
+		hotplug_slot->release = &release_slot;
+		make_slot_name (slot);
+		hotplug_slot->ops = &skel_hotplug_slot_ops;
+
+		/*
+		 * Initilize the slot info structure with some known
+		 * good values.
+		 */
+		get_power_status(hotplug_slot, &value);
+		info->power_status = value;
+		get_attention_status(hotplug_slot, &value);
+		info->attention_status = value;
+		get_latch_status(hotplug_slot, &value);
+		info->latch_status = value;
+		get_adapter_status(hotplug_slot, &value);
+		info->adapter_status = value;
+
+		dbg ("registering slot %d\n", i);
+		retval = pci_hp_register (slot->hotplug_slot);
+		if (retval) {
+			err ("pci_hp_register failed with error %d\n", retval);
+			kfree (info);
+			kfree (name);
+			kfree (hotplug_slot);
+			kfree (slot);
+			return retval;
+		}
+
+		/* add slot to our internal list */
+		list_add (&slot->slot_list, &slot_list);
+	}
+
+	return retval;
+}
+
+static int amdshpc_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	int retval;
+	int loop;
+	u16 vendor_id;
+	u16 device_id;
+	u32 rc;
+	long status = STATUS_SUCCESS;
+	struct controller *ctrl;
+	struct shpc_context *shpc_context;
+	union SLOT_CONFIG_INFO slot_config;
+
+	rc = pci_read_config_word(pdev, PCI_VENDOR_ID, &vendor_id);
+	dbg( "%s-->Vendor ID: %x\n",__FUNCTION__, vendor_id);
+	if (rc || (vendor_id != PCI_VENDOR_ID_AMD)) {
+		err(msg_HPC_non_amd);
+		return -ENODEV;
+	}
+
+	rc = pci_read_config_word(pdev, PCI_DEVICE_ID, &device_id);
+	dbg( "%s-->Device ID: %x\n",__FUNCTION__, device_id);
+	if (rc || (device_id != PCI_DEVICE_ID_AMD_GOLAM_7450)) {
+		err(msg_HPC_not_amd_hp);
+		return -ENODEV;
+	}
+
+	if (vendor_id == PCI_VENDOR_ID_AMD) {
+
+		shpc_context = (struct shpc_context *)kmalloc(sizeof(struct shpc_context), GFP_KERNEL);
+		if (!shpc_context) {
+			err("%s : out of memory\n",__FUNCTION__);
+			return -ENOMEM;
+		}
+		memset(shpc_context, 0, sizeof(struct shpc_context));
+
+		ctrl = (struct controller *)kmalloc(sizeof(struct controller), GFP_KERNEL);
+		if (!ctrl) {
+			err("%s : out of memory\n", __FUNCTION__);
+			rc =  -ENOMEM;
+			goto err_free_shpc_context;
+		}
+		memset(ctrl, 0, sizeof(struct controller));
+
+		/* Set Vendor ID, so it can be accessed later from other functions */
+		ctrl->vendor_id = vendor_id;
+
+	} else {
+		err(msg_HPC_not_supported);
+		return -ENODEV;
+	}
+
+	ctrl->shpc_context = shpc_context;
+	ctrl->pci_dev = pdev;
+	ctrl->interrupt = pdev->irq;
+	ctrl->device = PCI_SLOT(pdev->devfn);
+	ctrl->function = PCI_FUNC(pdev->devfn);
+
+	//
+	// the AMD hotplug bus is behind a bridge
+	//
+//	ctrl->pci_ops = pdev->subordinate->ops;
+	ctrl->pci_bus = pdev->subordinate;
+	ctrl->bus = pdev->subordinate->number;
+
+	dbg( "%s-->bus = %d   device = %d   function = %d\n",__FUNCTION__, ctrl->bus, ctrl->device, ctrl->function);
+
+	info("Found PCI hot plug controller on bus %d\n", pdev->bus->number);
+	info("Checking if MMIO region available for this HP controller...\n");
+		    
+	//
+	// Get memory mapped I/O region
+	//
+	dbg( "%s-->pdev = %p\n",__FUNCTION__, pdev);
+	dbg("%s -->pci resource start %lx\n",__FUNCTION__, pci_resource_start(pdev, 0));
+	dbg("%s -->pci resource len   %lx\n",__FUNCTION__, pci_resource_len  (pdev, 0));
+	if (!request_mem_region(pci_resource_start(pdev, 0), pci_resource_len(pdev, 0), MY_NAME)) {
+		err("MMIO region not available, skipping\n");
+		rc = -ENOMEM;
+		goto err_free_ctrl;
+	}
+
+	//
+	// Get linear address to put in controller structure
+	//
+	shpc_context->mmio_base_addr = ioremap(pci_resource_start(pdev, 0), pci_resource_len(pdev, 0));
+	if (!shpc_context->mmio_base_addr) {
+		err("cannot remap MMIO region %lx @ %lx\n", pci_resource_len(pdev, 0), pci_resource_start(pdev, 0));
+		rc = -ENODEV;
+		goto err_free_mem_region;
+	}
+
+	dbg("%s -->shpc_context->mmio_base_addr = %p",__FUNCTION__, (unsigned long*)shpc_context->mmio_base_addr);
+
+	hp_AddDevice(shpc_context, ctrl, shpc_context->async_callback, shpc_instance++);
+
+	// Initialize controller
+	shpc_context->interrupt = pdev->irq;
+	dbg("%s -->shpc_context->interrupt = %d", __FUNCTION__,pdev->irq);
+	if (!hp_StartDevice(shpc_context)){
+		rc = -ENODEV;
+		goto err_iounmap;
+	}
+
+	//
+	// initialize this array only once
+	//
+	if (shpc_context->shpc_instance == 0 ) {
+		dbg("%s  Initialize slot lists\n",__FUNCTION__);
+		for (loop = 0; loop < 256; loop++) {
+			amdshpc_slot_list[loop] = NULL;
+		}
+	}
+
+	if (!amdshpc_ctrl_list) {
+		amdshpc_ctrl_list = shpc_context;
+		shpc_context->next = NULL;
+	} else {
+		amdshpc_ctrl_list->next = shpc_context;
+		shpc_context->next = NULL;
+	}
+
+	if (!ctrl_list) {
+		ctrl_list = ctrl;
+		ctrl->next = NULL;
+	} else {
+		ctrl_list->next = ctrl;
+		ctrl->next = NULL;
+	}
+
+	// Map rom address so we can get the HPRT table
+	amdshpc_rom_start = ioremap(ROM_PHY_ADDR, ROM_PHY_LEN);
+	if (!amdshpc_rom_start) {
+		err ("Could not ioremap memory region for ROM\n");
+		retval = -EIO;;
+		iounmap(amdshpc_rom_start);
+		return retval;
+	}
+
+	//**************************************************
+	//
+	//	Save configuration headers for this and
+	//	subordinate PCI buses
+	//
+	//**************************************************
+
+	// find the physical slot number of the first hot plug slot
+	status = hp_QuerySlots(shpc_context, &slot_config);
+	// first slot on a bridged bus is always #1
+	ctrl->first_slot = 1;
+	dbg("%s  hp_QuerySlots: first_slot = %d, FDN = %d PSN_UP = %d\n",__FUNCTION__,
+						ctrl->first_slot, slot_config.x.lu_base_FDN, slot_config.x.lu_PSN_up);
+
+	if (rc) {
+		err(msg_initialization_err, rc);
+		goto err_iounmap;
+	}
+
+	if (!status) {
+		err(msg_initialization_err, (int)status);
+		goto err_iounmap;
+	}
+
+	// Store PCI Config Space for all devices on this bus
+	rc = amdshpc_save_config(ctrl, ctrl->bus, &slot_config);
+	if (rc) {
+		err("%s: unable to save PCI configuration data, error %d",__FUNCTION__, rc);
+		goto err_iounmap;
+	}
+
+	//
+	// Get IO, memory, and IRQ resources for new PCI devices
+	//
+	rc = amdshpc_find_available_resources(ctrl, amdshpc_rom_start);
+	if (rc) {
+		dbg("%s -->amdshpc_find_available_resources = 0x%x\n",__FUNCTION__, rc);
+		err("unable to locate PCI configuration resources for hot plug.\n");
+		goto err_iounmap;
+	}
+	
+	//
+	// set global variable num_slots
+	//
+	num_slots = shpc_context->number_of_slots;
+
+	dbg("%s   about to call init_slots()",__FUNCTION__);
+	rc = init_slots(ctrl, num_slots);
+	if (rc){
+		goto err_iounmap;
+	}
+
+	return 0;
+
+err_iounmap:
+	iounmap((void *)shpc_context->mmio_base_addr);
+err_free_mem_region:
+	release_mem_region(pci_resource_start(pdev, 0), pci_resource_len(pdev, 0));
+err_free_shpc_context:
+	kfree(shpc_context);
+err_free_ctrl:
+	kfree(ctrl);
+	return rc;
+}
+
+static void cleanup_slots (void)
+{
+	struct list_head *tmp;
+	struct list_head *next;
+	struct slot *slot;
+
+	/*
+	 * Unregister all of our slots with the pci_hotplug subsystem.
+	 * The memory will be freed in the release_slot() callback.
+	 */
+	list_for_each_safe(tmp, next, &slot_list) {
+		slot = list_entry(tmp, struct slot, slot_list);
+		list_del(&slot->slot_list);
+		pci_hp_deregister(slot->hotplug_slot);
+	}
+
+	return;
+}
+static void unload_amdshpc(void)
+{
+	struct pci_func *next;
+	struct pci_func *TempSlot;
+	int loop;
+	struct shpc_context *shpc_context;
+	struct shpc_context *tshpc_context;
+	struct controller *ctrl;
+	struct controller *tctrl;
+	struct pci_resource *res;
+	struct pci_resource *tres;
+
+	ctrl = ctrl_list;
+
+	while (ctrl) {
+		//reclaim PCI mem
+		release_mem_region(pci_resource_start(ctrl->pci_dev, 0),
+				   pci_resource_len(ctrl->pci_dev, 0));
+
+		res = ctrl->io_head;
+		while (res) {
+			tres = res;
+			res = res->next;
+			kfree(tres);
+		}
+
+		res = ctrl->mem_head;
+		while (res) {
+			tres = res;
+			res = res->next;
+			kfree(tres);
+		}
+
+		res = ctrl->p_mem_head;
+		while (res) {
+			tres = res;
+			res = res->next;
+			kfree(tres);
+		}
+
+		res = ctrl->bus_head;
+		while (res) {
+			tres = res;
+			res = res->next;
+			kfree(tres);
+		}
+
+		tctrl = ctrl;
+		ctrl = ctrl->next;
+		kfree(tctrl);
+	}
+
+	for (loop = 0; loop < 256; loop++) {
+		next = amdshpc_slot_list[loop];
+		while (next != NULL) {
+			res = next->io_head;
+			while (res) {
+				tres = res;
+				res = res->next;
+				kfree(tres);
+			}
+
+			res = next->mem_head;
+			while (res) {
+				tres = res;
+				res = res->next;
+				kfree(tres);
+			}
+
+			res = next->p_mem_head;
+			while (res) {
+				tres = res;
+				res = res->next;
+				kfree(tres);
+			}
+
+			res = next->bus_head;
+			while (res) {
+				tres = res;
+				res = res->next;
+				kfree(tres);
+			}
+
+			TempSlot = next;
+			next = next->next;
+			kfree(TempSlot);
+		}
+	}
+
+	shpc_context = amdshpc_ctrl_list;
+
+	while(shpc_context){
+
+		dbg("%s -->shpc_context = %p",__FUNCTION__ , shpc_context);
+		dbg("%s -->kill_amdshpc() instance = %d", __FUNCTION__ ,shpc_context->shpc_instance);
+		hp_StopDevice(shpc_context);
+
+		//Free IRQ associated with hot plug device
+		free_irq(shpc_context->interrupt, shpc_context);
+
+		//Unmap the memory
+		iounmap(shpc_context->mmio_base_addr);
+
+		// free the controller memory
+		tshpc_context = shpc_context;
+		shpc_context = shpc_context->next;
+		kfree(tshpc_context);
+	}
+
+	//unmap the rom address
+	if (amdshpc_rom_start)
+		iounmap(amdshpc_rom_start);
+}
+
+
+static struct pci_device_id hpcd_pci_tbl[] = {
+	{
+	/* handle AMD Standard Hotplug controller */
+
+//    class:          ((PCI_CLASS_SYSTEM_PCI_HOTPLUG << 8) | 0x00),
+	class:	 ((PCI_CLASS_BRIDGE_PCI << 8) | 0x00),
+	class_mask:	~0,
+
+	/* AMD makes it */
+	vendor:	 	PCI_VENDOR_ID_AMD,
+	device:	 	PCI_DEVICE_ID_AMD_GOLAM_7450,
+	subvendor:	PCI_ANY_ID,
+	subdevice:	PCI_ANY_ID,
+
+	}, { /* end: all zeroes */ }
+};
+
+MODULE_DEVICE_TABLE(pci, hpcd_pci_tbl);
+
+
+
+static struct pci_driver amdshpc_driver = {
+	name:		"pci_hotplug",
+	id_table:	hpcd_pci_tbl,
+	probe:		amdshpc_probe,
+	/* remove:	amdshpc_remove_one, */
+};
+
+
+static int __init amdshpc_init(void)
+{
+	int result;
+
+	amdshpc_debug = debug;
+	/*
+	 * Do specific initialization stuff for your driver here
+	 * Like initilizing your controller hardware (if any) and
+	 * determining the number of slots you have in the system
+	 * right now.
+	 */
+
+	result = pci_module_init(&amdshpc_driver);
+	dbg("%s -->pci_module_init = %d\n",__FUNCTION__ , result);
+	if (result)
+		return result;
+
+
+	info (DRIVER_DESC " version: " DRIVER_VERSION "\n");
+	return 0;
+}
+
+static void __exit amdshpc_exit(void)
+{
+	//
+	// Clean everything up.
+	//
+	dbg("%s -->unload_amdshpc()\n",__FUNCTION__ );
+	unload_amdshpc();
+
+	cleanup_slots();
+
+	dbg("%s -->pci_unregister_driver\n",__FUNCTION__ );
+	pci_unregister_driver(&amdshpc_driver);
+
+}
+
+module_init(amdshpc_init);
+module_exit(amdshpc_exit);
diff -purN linux-2.5/drivers/pci/hotplug/amdshpc_ctrl.c usb-2.5/drivers/pci/hotplug/amdshpc_ctrl.c
--- linux-2.5/drivers/pci/hotplug/amdshpc_ctrl.c	1970-01-01 00:00:00.000000000 +0000
+++ usb-2.5/drivers/pci/hotplug/amdshpc_ctrl.c	2003-10-24 18:52:49.000000000 +0000
@@ -0,0 +1,969 @@
+/*
+ * Copyright (C) 2001,2003 Greg Kroah-Hartman (greg@kroah.com)
+ * Copyright (C) 2001,2003 IBM Corp.
+ * Copyright (C) 2002-2003 Advanced Micro Devices
+ *
+ * YOUR USE OF THIS CODE IS SUBJECT TO THE TERMS
+ * AND CONDITIONS OF THE GNU GENERAL PUBLIC
+ * LICENSE FOUND IN THE "GPL.TXT" FILE THAT IS
+ * INCLUDED WITH THIS FILE AND POSTED AT
+ * http://www.gnu.org/licenses/gpl.html
+ *
+ *
+ * Send feedback to <david.keck@amd.com>
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/smp_lock.h>
+#include "amdshpc_ddi.h"
+#include "amdshpc.h"
+
+
+// ****************************************************************************
+//
+// hp_slot_thread() @ PASSIVE_LEVEL
+//
+// ****************************************************************************
+int hp_slot_thread(void* ptr)
+{
+	unsigned long		old_irq_flags;
+	long status = STATUS_SUCCESS;
+	struct shpc_context* shpc_context;
+	struct slot_context* slot_context;
+	union SLOT_STATUS_INFO slot_status;
+	
+	lock_kernel ();
+	daemonize ("amdshpc_slot");
+	unlock_kernel ();
+
+	slot_context = (struct slot_context*) ptr;
+	shpc_context = (struct shpc_context*) slot_context->shpc_context;
+
+	//
+	// Insertion/Removal State Machine (loops until requested to exit)
+	//
+	do {
+		status = slot_context->slot_function( shpc_context, slot_context );
+		//
+		// Suspend?
+		//
+		if(!status) {
+			spin_lock_irqsave(&shpc_context->shpc_spinlock, old_irq_flags);
+			if(shpc_context->shpc_event_bits & SUSPEND_EVENT ) {
+				status = STATUS_SUCCESS;
+			}
+			spin_unlock_irqrestore( &shpc_context->shpc_spinlock, old_irq_flags );
+
+			if(status) {
+				dbg( "%s-->SUSPEND: slot_id[ %d:%d ]",__FUNCTION__,
+					(int)shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+				do {
+					interruptible_sleep_on(&slot_context->slot_event);
+				}while(!((shpc_context->shpc_event_bits & RESUME_EVENT) ||
+					(shpc_context->shpc_event_bits & REMOVE_EVENT)));
+
+				if(shpc_context->shpc_event_bits & REMOVE_EVENT ) {
+					status = STATUS_UNSUCCESSFUL;
+				}
+				else {
+					dbg("%s-->RESUME: slot_id[ %d:%d ]",__FUNCTION__,
+						shpc_context->shpc_instance, slot_context->slot_number-1 );
+				}
+			}
+		}
+	} while(status);
+
+	//
+	// We're exiting, most likely due to an exit_request_event.  So, let's cleanup!
+	//
+	dbg("%s-->Slot Thread Termination: slot_id[ %d:%d ]",__FUNCTION__,
+		shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Pending SW-initiated slot request?
+	//
+	if(slot_context->slot_event_bits & SLOT_REQUEST_EVENT ) {
+		//
+		// Complete it with failure code
+		//
+		hp_QuerySlotStatus(	shpc_context, slot_context->slot_number - 1, &slot_status );
+		slot_status.x.lu_request_failed = HP_TRUE;
+		shpc_context->async_callback(
+			shpc_context->driver_context,
+			slot_context->slot_number - 1,
+			slot_context->slot_request.type,
+			slot_status,
+			slot_context->slot_request.request_context );
+
+		//
+		// Signal registered user EVENT
+		//
+		hp_signal_user_event( shpc_context );
+	}
+	return(status);
+}
+
+
+// ****************************************************************************
+//
+// hp_attn_led_thread() @ PASSIVE_LEVEL
+//
+// ****************************************************************************
+int
+hp_attn_led_thread(
+	void* ptr
+)
+{
+	unsigned long		old_irq_flags;
+	long status = STATUS_SUCCESS;
+	struct shpc_context* shpc_context;
+	struct slot_context* slot_context;
+	union SLOT_STATUS_INFO slot_status;
+	
+	lock_kernel ();
+	daemonize ("amdshpc_led");
+	unlock_kernel ();
+
+	slot_context = (struct slot_context*) ptr;
+	shpc_context = (struct shpc_context*) slot_context->shpc_context;
+
+	//
+	// Attention LED State Machine (loops until requested to exit)
+	//
+	do {
+		status = slot_context->attn_led_function(shpc_context, slot_context);
+		//
+		// Suspend?
+		//
+		if(!status) {
+			spin_lock_irqsave(&shpc_context->shpc_spinlock, old_irq_flags);
+			if(shpc_context->shpc_event_bits & SUSPEND_EVENT ) {
+				status = STATUS_SUCCESS;
+			}
+			spin_unlock_irqrestore( &shpc_context->shpc_spinlock, old_irq_flags );
+
+			if(status) {
+				dbg("%s-->SUSPEND: slot_id[ %d:%d ]",__FUNCTION__,
+					shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+				do {
+					interruptible_sleep_on(&slot_context->slot_event);
+				}while(!((shpc_context->shpc_event_bits & RESUME_EVENT) ||
+					(shpc_context->shpc_event_bits & REMOVE_EVENT)));
+
+				if(shpc_context->shpc_event_bits & REMOVE_EVENT ) {
+					status = STATUS_UNSUCCESSFUL;
+				}
+				else {
+					dbg("%s-->RESUME: slot_id[ %d:%d ]",__FUNCTION__,
+						shpc_context->shpc_instance, slot_context->slot_number-1 );
+				}
+			}
+		}
+	} while(status);
+
+	//
+	// We're exiting, most likely due to an exit_request_event.  So, let's cleanup!
+	//
+	dbg("%s-->LED Thread Termination: slot_id[ %d:%d ]",__FUNCTION__,
+		shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Pending SW-initiated AttnLED request?
+	//
+	if(slot_context->slot_event_bits & ATTN_LED_REQUEST_EVENT ) {
+		//
+		// Complete it with failure code
+		//
+		hp_QuerySlotStatus(	shpc_context, slot_context->slot_number - 1, &slot_status );
+		slot_status.x.lu_request_failed = HP_TRUE;
+		shpc_context->async_callback(
+			shpc_context->driver_context,
+			slot_context->slot_number - 1,
+			slot_context->attn_led_request.type,
+			slot_status,
+			slot_context->attn_led_request.request_context );
+
+		//
+		// Signal registered user EVENT
+		//
+		hp_signal_user_event( shpc_context );
+	}
+	return(status);
+}
+
+
+// ****************************************************************************
+//
+// hp_get_slot_configuration() @ Any IRQL
+//
+// ****************************************************************************
+void
+hp_get_slot_configuration(
+	struct shpc_context* shpc_context
+)
+{
+	struct slot_context* slot_context;
+	union SHPC_SLOTS_AVAILABLE1_DWREG SlotAvail1Reg;
+	union SHPC_SLOTS_AVAILABLE2_DWREG SlotAvail2Reg;
+	union SHPC_SLOT_CONFIG_DWREG SlotConfigReg;
+	union SHPC_LOGICAL_SLOT_DWREG logical_slot_reg;
+	enum shpc_speed_mode max_speed_mode;
+	u8 i;
+
+	//
+	// Get max number of slots available
+	//
+	SlotAvail1Reg.AsDWord = readl(shpc_context->mmio_base_addr + SHPC_SLOTS_AVAILABLE1_REG_OFFSET);
+	SlotAvail2Reg.AsDWord = readl(shpc_context->mmio_base_addr + SHPC_SLOTS_AVAILABLE2_REG_OFFSET);
+	//
+	// Get slot configuration
+	//
+	SlotConfigReg.AsDWord = readl(shpc_context->mmio_base_addr + SHPC_SLOT_CONFIG_REG_OFFSET);
+
+	//
+	// Get number of available slots per speed/mode
+	//
+	shpc_context->slots_enabled = 0;
+	shpc_context->number_of_slots = 0;
+	if( SlotAvail1Reg.x.N_133PCIX ) {
+		shpc_context->number_of_slots = ( u8 )SlotAvail1Reg.x.N_133PCIX;
+		shpc_context->max_speed_mode = SHPC_BUS_PCIX_133;
+	}
+	else if( SlotAvail1Reg.x.N_100PCIX ) {
+		shpc_context->number_of_slots = ( u8 )SlotAvail1Reg.x.N_100PCIX;
+		shpc_context->max_speed_mode = SHPC_BUS_PCIX_100;
+	}
+	else if( SlotAvail1Reg.x.N_66PCIX ) {
+		shpc_context->number_of_slots = ( u8 )SlotAvail1Reg.x.N_66PCIX;
+		shpc_context->max_speed_mode = SHPC_BUS_PCIX_66;
+	}
+	else if( SlotAvail2Reg.x.N_66CONV ) {
+		shpc_context->number_of_slots = ( u8 )SlotAvail2Reg.x.N_66CONV;
+		shpc_context->max_speed_mode = SHPC_BUS_CONV_66;
+	}
+	else if( SlotAvail1Reg.x.N_33CONV ) {
+		shpc_context->number_of_slots = ( u8 )SlotAvail1Reg.x.N_33CONV;
+		shpc_context->max_speed_mode = SHPC_BUS_CONV_33;
+	}
+
+	if( shpc_context->number_of_slots ) {
+		//
+		// Be sure NSI field is not exceeded (this should not happen!)
+		//
+		if( shpc_context->number_of_slots > SlotConfigReg.x.NSI ) {
+			shpc_context->number_of_slots = ( u8 )SlotConfigReg.x.NSI;
+		}
+
+		//
+		// Limit slot count to what we're prepared to support
+		//
+		if( shpc_context->number_of_slots > SHPC_MAX_NUM_SLOTS ) {
+			shpc_context->number_of_slots = SHPC_MAX_NUM_SLOTS;
+		}
+
+		//
+		// Get current Bus speed/mode
+		//
+		shpc_context->bus_speed_mode = hp_get_bus_speed_mode( shpc_context );
+
+		//
+		// Initialize slot state based on HW disposition
+		//
+		for( i=0; i< shpc_context->number_of_slots; ++i ) {
+			slot_context = &shpc_context->slot_context[ i ];
+
+			//
+			// Get Physical Slot Number (PSN-based)
+			//
+			if( SlotConfigReg.x.PSN_UP ) {
+				slot_context->slot_psn = ( u8 )SlotConfigReg.x.PSN + i;
+			}
+			else {
+				slot_context->slot_psn = ( u8 )SlotConfigReg.x.PSN - i;
+			}
+
+			//
+			// Assign Logical Slot Number (1-based)
+			//
+			slot_context->slot_number = ( u8 )i+1;
+
+			//
+			// Get Card's speed/mode capabilities
+			//
+			hp_get_card_speed_mode( slot_context );
+
+			//
+			// Check current HW state
+			//
+			logical_slot_reg.AsDWord = readl( slot_context->logical_slot_addr );
+
+			//
+			// Already enabled: Card Present, MRL closed, Slot Enabled, No Power-Fault?
+			//
+			if( logical_slot_reg.x.PRSNT1_2 != SHPC_SLOT_EMPTY &&
+				( logical_slot_reg.x.MRLS_IM == SHPC_MASKED ||
+				logical_slot_reg.x.MRLS == SHPC_MRL_CLOSED ) &&
+				logical_slot_reg.x.PF == SHPC_STATUS_CLEARED &&
+				logical_slot_reg.x.S_STATE == SHPC_ENABLE_SLOT ) {
+				//
+				// Treat it as a SUCCESSFUL "Slot Enabled" HW-initiated request
+				//
+				slot_context->slot_completion.hw_initiated = TRUE;
+				slot_context->slot_completion.type = SHPC_ASYNC_ENABLE_SLOT;
+				slot_context->slot_completion.failed = HP_FALSE;
+				slot_context->slot_completion.request_context = NULL;
+				slot_context->slot_completion.done = TRUE;
+
+				//
+				// Flag as "Slot Enabled"
+				//
+				++shpc_context->slots_enabled;
+				slot_context->slot_enabled = TRUE;
+				slot_context->in_bus_speed_mode_contention = TRUE;
+				if( logical_slot_reg.x.PIS == SHPC_LED_ON ) {
+					slot_context->slot_function = (SLOT_STATE_FUNCTION) hp_at_slot_enabled_wait_for_slot_request;
+				}
+				else {
+					slot_context->slot_function = (SLOT_STATE_FUNCTION) hp_to_slot_enabled_wait_for_led_cmd_available;
+				}
+			}
+			else {
+				//
+				// Treat it as a SUCCESSFUL "Slot Disable" HW-initiated request
+				//
+				slot_context->slot_completion.hw_initiated = TRUE;
+				slot_context->slot_completion.type = SHPC_ASYNC_DISABLE_SLOT;
+				slot_context->slot_completion.failed = HP_FALSE;
+				slot_context->slot_completion.request_context = NULL;
+				slot_context->slot_completion.done = TRUE;
+
+				//
+				// Flag as "Slot Disabled"
+				//
+				slot_context->slot_enabled = FALSE;
+				slot_context->in_bus_speed_mode_contention = FALSE;
+				if( logical_slot_reg.x.S_STATE == SHPC_DISABLE_SLOT ) {
+					slot_context->slot_function = (SLOT_STATE_FUNCTION) hp_at_slot_disabled_wait_for_slot_request;
+				}
+				else {
+					slot_context->slot_function = (SLOT_STATE_FUNCTION) hp_to_slot_disabled_wait_for_disable_cmd_available;
+				}
+			}
+
+			//
+			// Set Attention LED function
+			//
+			if( logical_slot_reg.x.PF == SHPC_STATUS_SET ) {
+				//
+				// Turn it ON
+				//
+				slot_context->problem_detected = TRUE;
+				slot_context->attn_led_function = (SLOT_STATE_FUNCTION) hp_wait_for_attn_led_back_to_normal_cmd_available;
+			}
+			else {
+				//
+				// Make sure it is turned OFF
+				//
+				slot_context->problem_detected = FALSE;
+				if( logical_slot_reg.x.AIS == SHPC_LED_OFF ) {
+					slot_context->attn_led_function = (SLOT_STATE_FUNCTION) hp_wait_for_attn_led_request;
+				}
+				else {
+					slot_context->attn_led_function = (SLOT_STATE_FUNCTION) hp_wait_for_attn_led_back_to_normal_cmd_available;
+				}
+			}
+		}
+
+		//
+		// Enabled slots running at maximum speed/mode?
+		//
+		if( shpc_context->slots_enabled ) {
+			max_speed_mode = hp_get_max_speed_mode( shpc_context, shpc_context->max_speed_mode );
+
+			//
+			// Signal enabled slots to release the bus, then change bus speed/mode
+			//
+			if( shpc_context->bus_speed_mode != max_speed_mode ) {
+				hp_signal_enabled_slots_to_rebalance_bus( shpc_context );
+			}
+		}
+	}
+}
+
+
+// ****************************************************************************
+//
+// hp_enable_slot_interrupts() @ Any IRQL
+//
+// ****************************************************************************
+void
+hp_enable_slot_interrupts(
+	struct slot_context* slot_context
+)
+{
+	struct shpc_context* shpc_context = ( struct shpc_context* )slot_context->shpc_context;
+	union SHPC_SLOT_CONFIG_DWREG SlotConfigReg;
+	union SHPC_LOGICAL_SLOT_DWREG logical_slot_reg;
+
+	//
+	// Get HW implementation: Attention Button, MRL Sensor
+	//
+	SlotConfigReg.AsDWord = readl(shpc_context->mmio_base_addr + SHPC_SLOT_CONFIG_REG_OFFSET);
+
+	//
+	// Attention Button: Enabled only if implemented
+	//
+	logical_slot_reg.x.AB_IM = ( SlotConfigReg.x.ABI == SHPC_STATUS_SET ) ?
+		SHPC_UNMASKED : SHPC_MASKED;
+	logical_slot_reg.x.ABP_STS = SHPC_STATUS_SET;
+
+	//
+	// MRL Sensor: Enabled only if implemented (System Error Disabled)
+	//
+	logical_slot_reg.x.MRLS_IM = ( SlotConfigReg.x.MRLSI == SHPC_STATUS_SET ) ?
+		SHPC_UNMASKED : SHPC_MASKED;
+	logical_slot_reg.x.MRLS_SERRM = SHPC_MASKED;
+	logical_slot_reg.x.MRLSC_STS = SHPC_STATUS_SET;
+
+	//
+	// Card Presence: Enabled
+	//
+	logical_slot_reg.x.CP_IM = SHPC_UNMASKED;
+	logical_slot_reg.x.CPC_STS = SHPC_STATUS_SET;
+
+	//
+	// Isolated Power-Fault: Enabled
+	//
+	logical_slot_reg.x.IPF_IM = SHPC_UNMASKED;
+	logical_slot_reg.x.IPF_STS = SHPC_STATUS_SET;
+
+	//
+	// Connected Power-Fault: Enabled (System Error Disabled)
+	//
+	logical_slot_reg.x.CPF_IM = SHPC_UNMASKED;
+	logical_slot_reg.x.CPF_SERRM = SHPC_MASKED;
+	logical_slot_reg.x.CPF_STS = SHPC_STATUS_SET;
+
+	//
+	// Update Mask and Status bits
+	//
+	writel(logical_slot_reg.AsDWord, slot_context->logical_slot_addr);
+}
+
+
+// ****************************************************************************
+//
+// hp_disable_slot_interrupts() @ Any IRQL
+//
+// ****************************************************************************
+void
+hp_disable_slot_interrupts(
+	struct slot_context* slot_context
+)
+{
+	union SHPC_LOGICAL_SLOT_DWREG logical_slot_reg;
+
+	//
+	// Get HW implementation: Attention Button, MRL Sensor
+	//
+	logical_slot_reg.AsDWord = readl(slot_context->logical_slot_addr);
+
+	//
+	// Attention Button: Disabled
+	//
+	logical_slot_reg.x.AB_IM = SHPC_MASKED;
+	logical_slot_reg.x.ABP_STS = SHPC_STATUS_SET;
+
+	//
+	// MRL Sensor: Disabled
+	//
+	logical_slot_reg.x.MRLS_IM = SHPC_MASKED;
+	logical_slot_reg.x.MRLS_SERRM = SHPC_MASKED;
+	logical_slot_reg.x.MRLSC_STS = SHPC_STATUS_SET;
+
+	//
+	// Card Presence: Disabled
+	//
+	logical_slot_reg.x.CP_IM = SHPC_MASKED;
+	logical_slot_reg.x.CPC_STS = SHPC_STATUS_SET;
+
+	//
+	// Isolated Power-Fault: Disabled
+	//
+	logical_slot_reg.x.IPF_IM = SHPC_MASKED;
+	logical_slot_reg.x.IPF_STS = SHPC_STATUS_SET;
+
+	//
+	// Connected Power-Fault: Enabled (System Error Disabled)
+	//
+	logical_slot_reg.x.CPF_IM = SHPC_MASKED;
+	logical_slot_reg.x.CPF_SERRM = SHPC_MASKED;
+	logical_slot_reg.x.CPF_STS = SHPC_STATUS_SET;
+
+	//
+	// Update Mask and Status bits
+	//
+	writel(logical_slot_reg.AsDWord, slot_context->logical_slot_addr);
+}
+
+
+// ****************************************************************************
+//
+// hp_enable_global_interrupts() @ Any IRQL
+//
+// ****************************************************************************
+void
+hp_enable_global_interrupts(
+	struct shpc_context* shpc_context
+)
+{
+	union SHPC_SERR_INT_DWREG SerrIntReg;
+
+	SerrIntReg.AsDWord = readl(shpc_context->mmio_base_addr + SHPC_SERR_INT_REG_OFFSET);
+
+	//
+	// Arbiter timeout: System Error Disabled
+	//
+	SerrIntReg.x.A_SERRM = SHPC_MASKED;
+	SerrIntReg.x.ATOUT_STS = SHPC_STATUS_SET;
+
+	//
+	// Command Completion: Enabled
+	//
+	SerrIntReg.x.CC_IM = SHPC_UNMASKED;
+	SerrIntReg.x.CC_STS = SHPC_STATUS_SET;
+
+	//
+	// Global: Interrputs Enabled, System Error Disabled
+	//
+	SerrIntReg.x.GIM = SHPC_UNMASKED;
+	SerrIntReg.x.GSERRM = SHPC_MASKED;
+
+	//
+	// Update Mask and Status bits
+	//
+	writel(SerrIntReg.AsDWord, shpc_context->mmio_base_addr + SHPC_SERR_INT_REG_OFFSET);
+}
+
+
+// ****************************************************************************
+//
+// hp_disable_global_interrupts() @ Any IRQL
+//
+// ****************************************************************************
+void
+hp_disable_global_interrupts(
+	struct shpc_context* shpc_context
+)
+{
+	union SHPC_SERR_INT_DWREG SerrIntReg;
+
+	SerrIntReg.AsDWord = readl(shpc_context->mmio_base_addr + SHPC_SERR_INT_REG_OFFSET);
+	//
+	// Arbiter timeout: System Error Disabled
+	//
+	SerrIntReg.x.A_SERRM = SHPC_MASKED;
+	SerrIntReg.x.ATOUT_STS = SHPC_STATUS_SET;
+
+	//
+	// Command Completion: Disabled
+	//
+	SerrIntReg.x.CC_IM = SHPC_MASKED;
+	SerrIntReg.x.CC_STS = SHPC_STATUS_SET;
+
+	//
+	// Global: Interrputs Disabled, System Error Disabled
+	//
+	SerrIntReg.x.GIM = SHPC_MASKED;
+	SerrIntReg.x.GSERRM = SHPC_MASKED;
+
+	//
+	// Update Mask and Status bits
+	//
+	writel(SerrIntReg.AsDWord, shpc_context->mmio_base_addr + SHPC_SERR_INT_REG_OFFSET);
+}
+
+
+// ****************************************************************************
+//
+// hp_get_card_speed_mode() @ Any IRQL
+//
+// ****************************************************************************
+enum shpc_speed_mode
+hp_get_card_speed_mode(
+	struct slot_context* slot_context
+)
+{
+	union SHPC_LOGICAL_SLOT_DWREG logical_slot_reg;
+
+	//
+	// Slot powered-up?
+	//
+	logical_slot_reg.AsDWord = readl( slot_context->logical_slot_addr );
+	if(( logical_slot_reg.x.PRSNT1_2 != SHPC_SLOT_EMPTY ) &&
+		( logical_slot_reg.x.S_STATE == SHPC_POWER_ONLY ||
+		logical_slot_reg.x.S_STATE == SHPC_ENABLE_SLOT )) {
+		//
+		// Get Card's maximum speed/mode
+		//
+		if( logical_slot_reg.x.PCIX_CAP == SHPC_SLOT_PCIX_133 ) {
+			slot_context->card_speed_mode = SHPC_BUS_PCIX_133;
+		}
+		else if( logical_slot_reg.x.PCIX_CAP == SHPC_SLOT_PCIX_66 ) {
+			slot_context->card_speed_mode = SHPC_BUS_PCIX_66;
+		}
+		else if( logical_slot_reg.x.M66_CAP == SHPC_STATUS_SET ) {
+			slot_context->card_speed_mode = SHPC_BUS_CONV_66;
+		}
+		else {
+			slot_context->card_speed_mode = SHPC_BUS_CONV_33;
+		}
+
+		//
+		// Get Card's PCI-66 capability
+		//
+		if( logical_slot_reg.x.M66_CAP == SHPC_STATUS_SET ) {
+			slot_context->card_pci66_capable = TRUE;
+		}
+	}
+	else {
+		//
+		// Slot is not powered-up, use PCI-33 as default
+		//
+		slot_context->card_speed_mode = SHPC_BUS_CONV_33;
+		slot_context->card_pci66_capable = FALSE;
+	}
+
+	return slot_context->card_speed_mode;
+}
+
+// ****************************************************************************
+//
+// hp_get_bus_speed_mode() @ Any IRQL
+//
+// ****************************************************************************
+enum shpc_speed_mode
+hp_get_bus_speed_mode(
+	struct shpc_context* shpc_context
+)
+{
+	union SHPC_SEC_BUS_CONFIG_DWREG bus_config_reg;
+	enum shpc_speed_mode bus_speed_mode;
+
+	bus_config_reg.AsDWord = readl(shpc_context->mmio_base_addr + SHPC_SEC_BUS_CONFIG_REG_OFFSET);
+
+	bus_speed_mode = ( enum shpc_speed_mode )bus_config_reg.x.MODE;
+	if( bus_speed_mode > SHPC_BUS_PCIX_133 ) {
+		bus_speed_mode = SHPC_BUS_CONV_33;
+	}
+
+	return bus_speed_mode;
+}
+
+
+// ****************************************************************************
+//
+// hp_translate_speed_mode() @ Any IRQL
+//
+// ****************************************************************************
+enum mode_frequency
+hp_translate_speed_mode(
+	enum shpc_speed_mode shpc_speed_mode
+)
+{
+	enum mode_frequency translated_speed_mode;
+
+	switch( shpc_speed_mode ) {
+	case SHPC_BUS_PCIX_133:
+		translated_speed_mode = MODE_PCIX_133;
+		break;
+
+	case SHPC_BUS_PCIX_100:
+		translated_speed_mode = MODE_PCIX_100;
+		break;
+
+	case SHPC_BUS_PCIX_66:
+		translated_speed_mode = MODE_PCIX_66;
+		break;
+
+	case SHPC_BUS_CONV_66:
+		translated_speed_mode = MODE_PCI_66;
+		break;
+
+	case SHPC_BUS_CONV_33:
+	default:
+		translated_speed_mode = MODE_PCI_33;
+		break;
+	}
+
+	return translated_speed_mode;
+}
+
+
+// ****************************************************************************
+//
+// hp_translate_card_power() @ Any IRQL
+//
+// ****************************************************************************
+enum hp_power_requirements
+hp_translate_card_power(
+	enum shpc_card_power ShpcCardPower
+)
+{
+	enum hp_states TranslatedCardPower;
+
+	switch( ShpcCardPower ) {
+	case SHPC_CARD_PRESENT_25W:
+		TranslatedCardPower = POWER_HIGH;
+		break;
+
+	case SHPC_CARD_PRESENT_15W:
+		TranslatedCardPower = POWER_MEDIUM;
+		break;
+
+	case SHPC_CARD_PRESENT_7_5W:
+	default:
+		TranslatedCardPower = POWER_LOW;
+		break;
+	}
+
+	return TranslatedCardPower;
+}
+
+
+// ****************************************************************************
+//
+// hp_translate_indicator() @ Any IRQL
+//
+// ****************************************************************************
+enum hp_indicators
+hp_translate_indicator(
+	enum shpc_slot_led ShpcIndicator
+)
+{
+	enum hp_indicators TranslatedIndicator;
+
+	switch( ShpcIndicator ) {
+	case SHPC_LED_ON:
+		TranslatedIndicator = INDICATOR_ON;
+		break;
+
+	case SHPC_LED_BLINK:
+		TranslatedIndicator = INDICATOR_BLINK;
+		break;
+
+	case SHPC_LED_OFF:
+	default:
+		TranslatedIndicator =INDICATOR_OFF;
+		break;
+	}
+
+	return TranslatedIndicator;
+}
+
+
+// ****************************************************************************
+//
+// hp_flag_slot_as_enabled() @ <= DISPATCH_LEVEL
+//
+// ****************************************************************************
+u8
+hp_flag_slot_as_enabled(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+)
+{
+	unsigned long		old_irq_flags;
+	u8 SlotFlagged = FALSE;
+
+	spin_lock_irqsave( &shpc_context->shpc_spinlock, old_irq_flags );
+	if( !slot_context->slot_enabled ) {
+		//
+		// Slot just coming on-line
+		//
+		SlotFlagged = TRUE;
+		++shpc_context->slots_enabled;
+		slot_context->slot_enabled = TRUE;
+		hp_clear_shpc_event_bit(shpc_context, BUS_REBALANCE_EVENT);
+	}
+	spin_unlock_irqrestore( &shpc_context->shpc_spinlock, old_irq_flags );
+
+	return SlotFlagged;
+}
+
+
+// ****************************************************************************
+//
+// hp_flag_slot_as_disabled() @ <= DISPATCH_LEVEL
+//
+// ****************************************************************************
+u8
+hp_flag_slot_as_disabled(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+)
+{
+	unsigned long		old_irq_flags;
+	u8 SlotFlagged = FALSE;
+
+	spin_lock_irqsave( &shpc_context->shpc_spinlock, old_irq_flags );
+	if( slot_context->slot_enabled ) {
+		if( --shpc_context->slots_enabled == 0 ) {
+			//
+			// This was the last enabled slot, signal waiting thread that bus is released,
+			//
+			shpc_context->bus_released = TRUE;
+			hp_send_event_to_all_slots(shpc_context, BUS_COMPLETE_EVENT);
+		}
+		SlotFlagged = TRUE;
+		slot_context->slot_enabled = FALSE;
+	}
+	spin_unlock_irqrestore( &shpc_context->shpc_spinlock, old_irq_flags );
+
+	return SlotFlagged;
+}
+
+
+// ****************************************************************************
+//
+// hp_signal_enabled_slots_to_rebalance_bus() @ <= DISPATCH_LEVEL
+//
+// Comments:
+//	Assumes shpc_spinlock is already held.
+//
+// ****************************************************************************
+u8
+hp_signal_enabled_slots_to_rebalance_bus(
+	struct shpc_context* shpc_context
+)
+{
+	struct slot_context* SlotArray[ SHPC_MAX_NUM_SLOTS ];
+	struct slot_context* Slot;
+	u8 i, j, n;
+
+	//
+	// Initialize array of slot pointers
+	//
+	n = shpc_context->number_of_slots;
+	for( i=0, j=0; i<n; ++i ) {
+		Slot = &shpc_context->slot_context[ i ];
+		if( Slot->slot_enabled ) {
+			SlotArray[ j++ ] = Slot;
+		}
+	}
+	//
+	// Found slots enabled?
+	//
+	if( j ) {
+		//
+		// Bubble-sort enabled slots in order of increasing card speed/mode
+		//
+		n = j;
+		for( i=0; i<n-1; i++ ) {
+			for( j=0; j<n-1-i; j++ ) {
+				if( SlotArray[ j+1 ]->card_speed_mode < SlotArray[ j ]->card_speed_mode ) {
+					Slot = SlotArray[ j ];
+					SlotArray[ j ] = SlotArray[ j+1 ];
+					SlotArray[ j+1 ] = Slot;
+				}
+			}
+		}
+		//
+		// Signal enabled slots in sorted order as an attempt to re-enable slower cards first
+		//
+		hp_set_shpc_event_bit(shpc_context, BUS_REBALANCE_EVENT);
+		for( i=0; i<n; i++ ) {
+			wake_up_interruptible( &SlotArray[ i ]->slot_event);
+		}
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+
+// ****************************************************************************
+//
+// hp_get_max_speed_mode() @ <= DISPATCH_LEVEL
+//
+// Comments:
+//	Assumes shpc_spinlock is already held.
+//
+// ****************************************************************************
+enum shpc_speed_mode
+hp_get_max_speed_mode(
+	struct shpc_context* shpc_context,
+	enum shpc_speed_mode From_speed_mode
+)
+{
+	struct slot_context* slot_context;
+	enum shpc_speed_mode max_speed_mode;
+	u8 i;
+
+	max_speed_mode = From_speed_mode;
+	for( i=0; i< shpc_context->number_of_slots; ++i ) {
+		slot_context = &shpc_context->slot_context[ i ];
+		if( slot_context->in_bus_speed_mode_contention &&
+			slot_context->card_speed_mode < max_speed_mode ) {
+			//
+			// Can only go as fast as the slowest card
+			//
+			max_speed_mode = slot_context->card_speed_mode;
+		}
+	}
+
+	//
+	// Make sure all cards support conventional PCI-66 speed/mode
+	//
+	if( max_speed_mode == SHPC_BUS_CONV_66 ) {
+		for( i=0; i< shpc_context->number_of_slots; ++i ) {
+			slot_context = &shpc_context->slot_context[ i ];
+			if( slot_context->in_bus_speed_mode_contention &&
+				!slot_context->card_pci66_capable ) {
+				//
+				// Fall back to slower common denominator
+				//
+				max_speed_mode = SHPC_BUS_CONV_33;
+			}
+		}
+	}
+
+	return max_speed_mode;
+}
+
+
+// ****************************************************************************
+//
+// hp_signal_user_event() @ <= DISPATCH_LEVEL
+//
+// ****************************************************************************
+void hp_signal_user_event(struct shpc_context* shpc_context)
+{
+	unsigned long		old_irq_flags;
+return;
+	spin_lock_irqsave( &shpc_context->shpc_spinlock, old_irq_flags );
+	if( shpc_context->user_event_pointer ) {
+		wake_up_interruptible( shpc_context->user_event_pointer);
+	}
+	spin_unlock_irqrestore( &shpc_context->shpc_spinlock, old_irq_flags );
+}
+
+
+// ****************************************************************************
+//
+// hp_signal_user_event_at_dpc_level() @ DISPATCH_LEVEL
+//
+// ****************************************************************************
+void hp_signal_user_event_at_dpc_level(struct shpc_context* shpc_context)
+{
+return;
+	spin_lock_bh( &shpc_context->shpc_spinlock );
+	if( shpc_context->user_event_pointer ) {
+		wake_up_interruptible( shpc_context->user_event_pointer);
+	}
+	spin_unlock_bh( &shpc_context->shpc_spinlock );
+}
diff -purN linux-2.5/drivers/pci/hotplug/amdshpc_ddi.c usb-2.5/drivers/pci/hotplug/amdshpc_ddi.c
--- linux-2.5/drivers/pci/hotplug/amdshpc_ddi.c	1970-01-01 00:00:00.000000000 +0000
+++ usb-2.5/drivers/pci/hotplug/amdshpc_ddi.c	2003-10-24 18:52:49.000000000 +0000
@@ -0,0 +1,1660 @@
+/*
+ * Copyright (C) 2001,2003 Greg Kroah-Hartman (greg@kroah.com)
+ * Copyright (C) 2001,2003 IBM Corp.
+ * Copyright (C) 2002-2003 Advanced Micro Devices
+ *
+ * YOUR USE OF THIS CODE IS SUBJECT TO THE TERMS
+ * AND CONDITIONS OF THE GNU GENERAL PUBLIC
+ * LICENSE FOUND IN THE "GPL.TXT" FILE THAT IS
+ * INCLUDED WITH THIS FILE AND POSTED AT
+ * http://www.gnu.org/licenses/gpl.html
+ *
+ *
+ * Send feedback to <david.keck@amd.com>
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/smp_lock.h>
+#include "amdshpc_ddi.h"
+#include "amdshpc.h"
+
+static unsigned long async_callback (void* driver_context,
+					 u8 slot_number,
+					 enum shpc_async_request async_request,
+					 union SLOT_STATUS_INFO slot_tatus,
+					 void* request_context );
+
+// ****************************************************************************
+//
+// hp_AddDevice() 
+//
+// Parameters
+//	shpc_context - Caller provided storage for SHPC context data (per hardware-instance).
+//	driver_context - Caller provided pointer to be returned upon completion.
+//	Callback - Caller provided function to be called upon completion of async requests.
+//  shpc_instance - Zero-based hardware instance.
+//
+// Return Value
+//  Status returned by any system calls made within hp_AddDevice().
+//
+// ****************************************************************************
+long
+hp_AddDevice(
+	struct shpc_context* shpc_context,
+	void* driver_context,
+	SHPC_ASYNC_CALLBACK Callback,
+	unsigned long shpc_instance
+	)
+
+{
+	struct slot_context* slot_context;
+	u8 i;
+	DECLARE_TASKLET(mrl_sensor_dpc0, hp_mrl_sensor_dpc, (unsigned long) &shpc_context->slot_context[0] );
+	DECLARE_TASKLET(attn_button_dpc0, hp_attn_button_dpc, (unsigned long) &shpc_context->slot_context[0]);
+	DECLARE_TASKLET(card_presence_dpc0, hp_card_presence_dpc, (unsigned long) &shpc_context->slot_context[0]);
+	DECLARE_TASKLET(isolated_power_fault_dpc0, hp_isolated_power_fault_dpc, (unsigned long) &shpc_context->slot_context[0]);
+	DECLARE_TASKLET(connected_power_fault_dpc0, hp_connected_power_fault_dpc, (unsigned long) &shpc_context->slot_context[0]);
+
+	DECLARE_TASKLET(mrl_sensor_dpc1, hp_mrl_sensor_dpc, (unsigned long) &shpc_context->slot_context[1] );
+	DECLARE_TASKLET(attn_button_dpc1, hp_attn_button_dpc, (unsigned long) &shpc_context->slot_context[1]);
+	DECLARE_TASKLET(card_presence_dpc1, hp_card_presence_dpc, (unsigned long) &shpc_context->slot_context[1]);
+	DECLARE_TASKLET(isolated_power_fault_dpc1, hp_isolated_power_fault_dpc, (unsigned long) &shpc_context->slot_context[1]);
+	DECLARE_TASKLET(connected_power_fault_dpc1, hp_connected_power_fault_dpc, (unsigned long) &shpc_context->slot_context[1]);
+
+	DECLARE_TASKLET(mrl_sensor_dpc2, hp_mrl_sensor_dpc, (unsigned long) &shpc_context->slot_context[2] );
+	DECLARE_TASKLET(attn_button_dpc2, hp_attn_button_dpc, (unsigned long) &shpc_context->slot_context[2]);
+	DECLARE_TASKLET(card_presence_dpc2, hp_card_presence_dpc, (unsigned long) &shpc_context->slot_context[2]);
+	DECLARE_TASKLET(isolated_power_fault_dpc2, hp_isolated_power_fault_dpc, (unsigned long) &shpc_context->slot_context[2]);
+	DECLARE_TASKLET(connected_power_fault_dpc2, hp_connected_power_fault_dpc, (unsigned long) &shpc_context->slot_context[2]);
+
+	DECLARE_TASKLET(mrl_sensor_dpc3, hp_mrl_sensor_dpc, (unsigned long) &shpc_context->slot_context[3] );
+	DECLARE_TASKLET(attn_button_dpc3, hp_attn_button_dpc, (unsigned long) &shpc_context->slot_context[3]);
+	DECLARE_TASKLET(card_presence_dpc3, hp_card_presence_dpc, (unsigned long) &shpc_context->slot_context[3]);
+	DECLARE_TASKLET(isolated_power_fault_dpc3, hp_isolated_power_fault_dpc, (unsigned long) &shpc_context->slot_context[3]);
+	DECLARE_TASKLET(connected_power_fault_dpc3, hp_connected_power_fault_dpc, (unsigned long) &shpc_context->slot_context[3]);
+
+
+	DECLARE_TASKLET(cmd_completion_dpc, hp_cmd_completion_dpc, (unsigned long) shpc_context );
+
+	//
+	// Init common resources
+	//
+	shpc_context->cmd_completion_dpc = cmd_completion_dpc;
+	shpc_context->driver_context = driver_context;
+	shpc_context->async_callback = (SHPC_ASYNC_CALLBACK)async_callback;
+	shpc_context->shpc_instance = shpc_instance;
+	shpc_context->slots_enabled = 0;
+	shpc_context->number_of_slots = 0;
+	shpc_context->at_power_device_d0 = FALSE;
+	shpc_context->bus_released = FALSE;
+	shpc_context->user_event_pointer = NULL;
+	spin_lock_init( &shpc_context->shpc_spinlock );
+	sema_init( &shpc_context->cmd_available_mutex, 1);
+	sema_init( &shpc_context->bus_available_mutex, 1);
+	sema_init( &shpc_context->shpc_event_bits_semaphore, 1);
+
+	shpc_context->shpc_event_bits=0;	// all shpc events cleared
+
+	dbg("%s -->HwInstance[ %d ]", __FUNCTION__ ,shpc_context->shpc_instance );
+
+	//
+	// Init slot resources
+	//
+	for( i=0; i< SHPC_MAX_NUM_SLOTS; ++i ) {
+		slot_context = &shpc_context->slot_context[ i ];
+		slot_context->shpc_context = ( void* )shpc_context;
+		slot_context->slot_number = ( u8 )i+1;
+		slot_context->slot_enabled = FALSE;
+		slot_context->in_bus_speed_mode_contention = FALSE;
+		slot_context->problem_detected = FALSE;
+		slot_context->slot_quiesced = FALSE;
+		slot_context->slot_thread = NULL;
+		slot_context->slot_function = NULL;
+		slot_context->attn_led_thread = NULL;
+		slot_context->attn_led_function = NULL;
+
+		//
+		// Slot SpinLocks and semaphores
+		//
+		spin_lock_init( &slot_context->slot_spinlock);
+		sema_init(&slot_context->slot_event_bits_semaphore, 1);
+		sema_init(&slot_context->cmd_acquire_mutex, 1);
+		sema_init(&slot_context->bus_acquire_mutex, 1);
+
+		//
+		// Slot timers
+		//
+		init_timer(&slot_context->slot_timer1);
+		init_timer(&slot_context->slot_timer2);
+		init_timer(&slot_context->slot_timer3);
+		init_timer(&slot_context->slot_timer4);
+		init_timer(&slot_context->slot_timer5);
+		init_timer(&slot_context->slot_timer6);
+		init_timer(&slot_context->slot_timer7);
+		init_timer(&slot_context->slot_timer8);
+		init_timer(&slot_context->slot_timer9);
+		init_timer(&slot_context->slot_timer10);
+		init_timer(&slot_context->led_timer1);
+		init_timer(&slot_context->led_timer2);
+		init_timer(&slot_context->led_timer3);
+		init_timer(&slot_context->led_timer4);
+
+		//
+		// Interrupt Service
+		//
+		switch (i) {
+		case 0:
+			slot_context->attn_button_dpc           = attn_button_dpc0;
+			slot_context->mrl_sensor_dpc            = mrl_sensor_dpc0;
+			slot_context->card_presence_dpc         = card_presence_dpc0;
+			slot_context->isolated_power_fault_dpc  = isolated_power_fault_dpc0;
+			slot_context->connected_power_fault_dpc = connected_power_fault_dpc0;
+			break;
+		case 1:
+			slot_context->attn_button_dpc           = attn_button_dpc1;
+			slot_context->mrl_sensor_dpc            = mrl_sensor_dpc1;
+			slot_context->card_presence_dpc         = card_presence_dpc1;
+			slot_context->isolated_power_fault_dpc  = isolated_power_fault_dpc1;
+			slot_context->connected_power_fault_dpc = connected_power_fault_dpc1;
+			break;
+		case 2:
+			slot_context->attn_button_dpc           = attn_button_dpc2;
+			slot_context->mrl_sensor_dpc            = mrl_sensor_dpc2;
+			slot_context->card_presence_dpc         = card_presence_dpc2;
+			slot_context->isolated_power_fault_dpc  = isolated_power_fault_dpc2;
+			slot_context->connected_power_fault_dpc = connected_power_fault_dpc2;
+			break;
+		case 3:
+			slot_context->attn_button_dpc           = attn_button_dpc3;
+			slot_context->mrl_sensor_dpc            = mrl_sensor_dpc3;
+			slot_context->card_presence_dpc         = card_presence_dpc3;
+			slot_context->isolated_power_fault_dpc  = isolated_power_fault_dpc3;
+			slot_context->connected_power_fault_dpc = connected_power_fault_dpc3;
+			break;
+		}
+
+
+		//
+		// Slot Events
+		//
+		slot_context->slot_event_bits=0;	// all slot events cleared
+
+		dbg("%s -->Init slot wait queues",__FUNCTION__ );
+
+		init_waitqueue_head(&slot_context->slot_event);
+		init_waitqueue_head(&slot_context->led_cmd_acquire_event);
+		init_waitqueue_head(&slot_context->led_cmd_release_event);
+		init_waitqueue_head(&slot_context->cmd_acquire_event);
+		init_waitqueue_head(&slot_context->cmd_release_event);
+		init_waitqueue_head(&slot_context->bus_acquire_event);
+		init_waitqueue_head(&slot_context->bus_release_event);
+	}
+	return STATUS_SUCCESS;
+}
+
+
+// ****************************************************************************
+//
+// hp_StartDevice()
+//
+// Parameters
+//	shpc_context - Caller provided storage for SHPC context data.
+//
+// Return Value
+//  Status returned by any system calls made within hp_StartDevice().
+//
+//
+// ****************************************************************************
+long
+hp_StartDevice(
+	struct shpc_context* shpc_context
+	)
+{
+	struct slot_context* slot_context;
+	long status = STATUS_SUCCESS;
+	u32 *logical_slot_addr;
+	u8 i;
+	int pid;
+
+	dbg("%s -->From hp_StartDevice:  MmioBase[ %p ]",__FUNCTION__ , (unsigned long*)shpc_context->mmio_base_addr);
+
+	//
+	// Disable Global Interrupts
+	//
+	dbg("%s -->hp_disable_global_interrupts( shpc_context=%p );",__FUNCTION__ , shpc_context);
+	hp_disable_global_interrupts( shpc_context );
+
+	//
+	// Reset common resources
+	//
+	shpc_context->at_power_device_d0 = TRUE;
+	shpc_context->bus_released = FALSE;
+
+	//
+	// Reset slot resources
+	//
+	logical_slot_addr = shpc_context->mmio_base_addr + SHPC_LOGICAL_SLOT_REG_OFFSET;
+	for( i=0; i< SHPC_MAX_NUM_SLOTS; ++i ) {
+		slot_context = &shpc_context->slot_context[ i ];
+
+		//
+		// Assign Logical Slot Register Address
+		//
+		slot_context->logical_slot_addr = logical_slot_addr++;
+
+		//
+		// Disable Slot Interrupts
+		//
+		dbg("%s -->hp_disable_slot_interrupts(slot_context)=%p",__FUNCTION__ , slot_context);
+		hp_disable_slot_interrupts(slot_context);
+
+		//
+		// Reset slot flags and pointers
+		//
+		slot_context->slot_enabled = FALSE;
+		slot_context->in_bus_speed_mode_contention = FALSE;
+		slot_context->problem_detected = FALSE;
+		slot_context->slot_quiesced = FALSE;
+		slot_context->slot_thread = NULL;
+		slot_context->slot_function = NULL;
+		slot_context->attn_led_thread = NULL;
+		slot_context->attn_led_function = NULL;
+		slot_context->slot_occupied = 0;
+	}
+
+	//
+	// Get initial slot configuration: number_of_slots, slots_enabled, SlotStateFunction
+	//
+	shpc_context->slots_enabled = 0;
+	shpc_context->number_of_slots = 0;
+	hp_get_slot_configuration( shpc_context );
+	dbg("%s -->from hp_StartDevice() number_of_slots = %d", __FUNCTION__ ,shpc_context->number_of_slots);
+	if( shpc_context->number_of_slots == 0 ) {
+		status = STATUS_UNSUCCESSFUL;
+	}
+
+	//
+	//  Hook Interrupt
+	//
+	dbg("%s -->HPC interrupt = %d \n", __FUNCTION__ ,shpc_context->interrupt);
+
+	if (request_irq(shpc_context->interrupt, hp_interrupt_service, SA_SHIRQ, MY_NAME, shpc_context)) {
+		err("Can't get irq %d for the PCI hotplug controller\n", shpc_context->interrupt);
+		status = STATUS_UNSUCCESSFUL;
+		return(status);
+	}
+
+	//
+	// Set slot operation in motion
+	//
+	for( i=0; i<shpc_context->number_of_slots && status; ++i ) {
+
+		slot_context = &shpc_context->slot_context[ i ];
+
+		//
+		// Launch slot command and bus completion mutex threads
+		//
+		// get led cmd available thread
+		pid = kernel_thread(hp_get_led_cmd_available_mutex_thread, slot_context, CLONE_SIGHAND);
+		if (pid < 0) {
+			err ("Can't start up our get_led_cmd_available_mutex thread\n");
+			status = STATUS_UNSUCCESSFUL;
+		}
+		dbg("%s -->Our hp_get_led_cmd_available_mutex thread pid = %d",__FUNCTION__ , pid);
+
+		// get cmd available thread
+		pid = kernel_thread(hp_get_cmd_available_mutex_thread, slot_context, CLONE_SIGHAND);
+		if (pid < 0) {
+			err ("Can't start up our get_cmd_available_mutex thread\n");
+			status = STATUS_UNSUCCESSFUL;
+		}
+		dbg("%s -->Our hp_get_cmd_available_mutex thread pid = %d",__FUNCTION__ , pid);
+
+		// get bus available thread
+		pid = kernel_thread(hp_get_bus_available_mutex_thread, slot_context, CLONE_SIGHAND);
+		if (pid < 0) {
+			err ("Can't start up our get_bus_available_mutex thread\n");
+			status = STATUS_UNSUCCESSFUL;
+		}
+		dbg("%s \n\n\n-->Our get_bus_available_mutex thread pid = %d",__FUNCTION__ , pid);
+
+		//
+		// Launch slot thread
+		//
+		pid = kernel_thread(hp_slot_thread, slot_context, CLONE_SIGHAND);
+		if (pid < 0) {
+			err ("Can't start up our event thread\n");
+			status = STATUS_UNSUCCESSFUL;
+		}
+		dbg("%s -->Our slot event thread pid = %d\n",__FUNCTION__ , pid);
+
+		//
+		// Launch Attention LED Thread
+		//
+		pid = kernel_thread(hp_attn_led_thread, slot_context, CLONE_SIGHAND);
+		if (pid < 0) {
+			err ("Can't start up our event thread\n");
+			status = STATUS_UNSUCCESSFUL;
+		}
+		dbg("%s -->Our LED event thread pid = %d\n",__FUNCTION__ , pid);
+
+		//
+		// Enable Slot Interrupts: Attn Button, MRL Sensor, Card Presence, Power-Fault
+		//
+		if(status) {
+			dbg("%s -->hpStartDevice() Enabling slot interrupts...",__FUNCTION__ );
+			hp_enable_slot_interrupts( slot_context );
+		}
+	}
+
+	//
+	// Enable Global Interrupts: Command Completion
+	//
+	if(status) {
+		dbg("%s -->hpStartDevice() Enabling global interrupts...",__FUNCTION__ );
+		hp_enable_global_interrupts( shpc_context );
+	} else {
+		//
+		// Bail out, we're hosed!
+		//
+		hp_StopDevice( shpc_context );
+		status = STATUS_UNSUCCESSFUL;
+	}
+	dbg("%s -->status = %d\n",__FUNCTION__ , (u32)status);
+
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_StopDevice()
+//
+// Parameters
+//	shpc_context - Caller provided storage for SHPC context data.
+//
+// Return Value
+//  Status returned by any system calls made within hp_StopDevice().
+//
+// Comments:
+//	The caller is responsible for unmapping mmio_base_addr, via MmUnmapIoSpace(),
+//  after calling hp_StopDevice() for resource re-balancing or device removal.
+//
+// ****************************************************************************
+long
+hp_StopDevice(
+	struct shpc_context* shpc_context
+	)
+{
+	struct slot_context* slot_context;
+	long status = STATUS_SUCCESS;
+	unsigned long	old_irq_flags;
+	u8 i;
+
+	//
+	// Already stopped or never started ?
+	//
+	if( shpc_context->mmio_base_addr == 0 ) {
+		return STATUS_UNSUCCESSFUL;
+	}
+	//
+	// Disable Global Interrupts
+	//
+	hp_disable_global_interrupts( shpc_context );
+
+	//
+	// Signal EXIT request to slot threads
+	//
+
+	spin_lock_irqsave(&shpc_context->shpc_spinlock, old_irq_flags);
+	hp_clear_shpc_event_bit(shpc_context, SUSPEND_EVENT);
+	hp_send_event_to_all_slots(shpc_context,
+				   RESUME_EVENT || REMOVE_EVENT || EXIT_REQUEST_EVENT);
+	spin_unlock_irqrestore( &shpc_context->shpc_spinlock, old_irq_flags );
+
+	for( i=0; i<SHPC_MAX_NUM_SLOTS; ++i ) {
+		slot_context = &shpc_context->slot_context[ i ];
+
+		//
+		// Disable Slot Interrupts
+		//
+		hp_disable_slot_interrupts( slot_context );
+
+		//
+		// Remove scheduled slot DPCs
+		//
+		tasklet_kill( &slot_context->attn_button_dpc );
+		tasklet_kill( &slot_context->card_presence_dpc );
+		tasklet_kill( &slot_context->isolated_power_fault_dpc );
+		tasklet_kill( &slot_context->connected_power_fault_dpc );
+
+		//
+		// Send events to kill all threads
+		//
+		//
+		// Set event bits to send to running threads
+		//
+		hp_set_shpc_event_bit(shpc_context,
+				      (RESUME_EVENT | REMOVE_EVENT | EXIT_REQUEST_EVENT));
+
+		
+		
+		wake_up_interruptible(&slot_context->led_cmd_acquire_event);
+		wake_up_interruptible(&slot_context->cmd_acquire_event);
+		wake_up_interruptible(&slot_context->bus_acquire_event);
+		wake_up_interruptible(&slot_context->led_cmd_release_event);
+		wake_up_interruptible(&slot_context->cmd_release_event);
+		wake_up_interruptible(&slot_context->bus_release_event);
+		//
+		// Reset slot pointers and flags
+		//
+		slot_context->slot_enabled = FALSE;
+		slot_context->slot_thread = NULL;
+		slot_context->slot_function = NULL;
+		slot_context->attn_led_thread = NULL;
+		slot_context->attn_led_function = NULL;
+	}
+
+	//
+	// Remove scheduled common DPC
+	//
+	tasklet_kill(&shpc_context->cmd_completion_dpc );
+
+	//
+	// Reset common resources
+	//
+	shpc_context->number_of_slots = 0;
+	shpc_context->slots_enabled = 0;
+	shpc_context->at_power_device_d0 = FALSE;
+
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_SuspendDevice()
+//
+// Parameters
+//	shpc_context - Caller provided storage for SHPC context data.
+//
+// Return Value
+//  Status returned by any system calls made within hp_SuspendDevice().
+//
+// Comments:
+//	hp_SuspendDevice() must be called before transitioning away from PowerDeviceD0.
+//
+// ****************************************************************************
+long
+hp_SuspendDevice(
+	struct shpc_context* shpc_context
+	)
+{
+	long status = STATUS_SUCCESS;
+	unsigned long	old_irq_flags;
+
+	dbg("%s -->HwInstance[ %d ]", __FUNCTION__ ,shpc_context->shpc_instance );
+
+	spin_lock_irqsave( &shpc_context->shpc_spinlock, old_irq_flags );
+
+	if(shpc_context->mmio_base_addr &&
+		(!shpc_context->shpc_event_bits & SUSPEND_EVENT) &&
+		(!shpc_context->shpc_event_bits & REMOVE_EVENT)) {
+		hp_clear_shpc_event_bit(shpc_context, RESUME_EVENT);
+
+		hp_send_event_to_all_slots(shpc_context, SUSPEND_EVENT);
+		hp_send_event_to_all_slots(shpc_context, EXIT_REQUEST_EVENT);
+
+		shpc_context->at_power_device_d0 = FALSE;
+	}
+	spin_unlock_irqrestore( &shpc_context->shpc_spinlock, old_irq_flags );
+
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_ResumeDevice() 
+//
+// Parameters
+//	shpc_context - Caller provided storage for SHPC context data.
+//
+// Return Value
+//  Status returned by any system calls made within hp_ResumeDevice().
+//
+// Comments:
+//	hp_SuspendDevice() must be called after transitioning back to PowerDeviceD0.
+//
+// ****************************************************************************
+long
+hp_ResumeDevice(
+	struct shpc_context* shpc_context
+	)
+{
+	long status = STATUS_SUCCESS;
+	unsigned long		old_irq_flags;
+
+	dbg("%s -->HwInstance[ %d ]", __FUNCTION__ ,shpc_context->shpc_instance );
+
+	spin_lock_irqsave( &shpc_context->shpc_spinlock, old_irq_flags );
+	if(shpc_context->mmio_base_addr &&
+		(shpc_context->shpc_event_bits & SUSPEND_EVENT) &&
+		(!shpc_context->shpc_event_bits & REMOVE_EVENT)) {
+		hp_clear_shpc_event_bit(shpc_context, SUSPEND_EVENT);
+		hp_clear_shpc_event_bit(shpc_context, EXIT_REQUEST_EVENT);
+		hp_send_event_to_all_slots(shpc_context, RESUME_EVENT);
+		shpc_context->at_power_device_d0 = TRUE;
+	}
+
+	spin_unlock_irqrestore( &shpc_context->shpc_spinlock, old_irq_flags );
+
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_QuerySlots() 
+//
+// Parameters
+//	shpc_context - Caller provided storage for SHPC context data.
+//	slot_config - Caller provided storage for slots configuration info.
+//
+// Return Value
+//  Status returned by any system calls made within hp_QuerySlots().
+//
+// ****************************************************************************
+long
+hp_QuerySlots(
+	struct shpc_context* shpc_context,
+	union SLOT_CONFIG_INFO* slot_config
+	)
+{
+	long status = STATUS_SUCCESS;
+	union SHPC_SLOT_CONFIG_DWREG slot_config_reg;
+
+	dbg("%s -->HwInstance[ %d ]  Slots[ %d ]",__FUNCTION__ ,
+		shpc_context->shpc_instance, shpc_context->number_of_slots );
+
+	//
+	// Get slot configuration
+	//
+	slot_config_reg.AsDWord = readl(shpc_context->mmio_base_addr + SHPC_SLOT_CONFIG_REG_OFFSET);
+
+	slot_config->AsDWord = 0;
+	slot_config->x.lu_slots_implemented = slot_config_reg.x.NSI;
+	slot_config->x.lu_base_PSN = slot_config_reg.x.PSN;
+	slot_config->x.lu_PSN_up = slot_config_reg.x.PSN_UP;
+	slot_config->x.lu_base_FDN = slot_config_reg.x.FDN;
+
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_QuerySlotStatus()
+//
+// Parameters
+//	shpc_context - Caller provided storage for SHPC context data.
+//	slot_id - Zero-based slot number (0..n-1).
+//	Query - Pointer to Slot Status Structure
+//
+// Return Value
+//  Status returned by any system calls made within hp_QuerySlotStatus().
+//
+// ****************************************************************************
+long
+hp_QuerySlotStatus(
+	struct shpc_context* shpc_context,
+	u8 slot_id,
+	union SLOT_STATUS_INFO* Query
+	)
+{
+	struct slot_context* slot_context;
+	long status = STATUS_SUCCESS;
+	union SHPC_LOGICAL_SLOT_DWREG logical_slot_reg;
+
+	dbg("%s -->slot_id[ %d:%d ]",__FUNCTION__ , shpc_context->shpc_instance, slot_id );
+
+	//
+	// Valid slot_id?
+	//
+	if( slot_id >= shpc_context->number_of_slots ) {
+		status = STATUS_UNSUCCESSFUL;
+	}
+	else {
+		//
+		// Which slot?
+		//
+		slot_context = &shpc_context->slot_context[ slot_id ];
+
+		//
+		// Get Max Speed/Mode from common context
+		//
+		Query->x.lu_max_bus_mode_freq = hp_translate_speed_mode( shpc_context->max_speed_mode );
+
+		//
+		// Get Bus Speed/Mode from HW
+		//
+		Query->x.lu_bus_mode_freq = hp_translate_speed_mode( hp_get_bus_speed_mode( shpc_context ));
+
+		//
+		// Get Card Speed/Mode from HW
+		//
+		Query->x.lu_card_mode_freq_cap = hp_translate_speed_mode( hp_get_card_speed_mode( slot_context ));
+
+		//
+		// Get current slot info from HW
+		//
+		logical_slot_reg.AsDWord = readl( slot_context->logical_slot_addr );
+
+		//
+		// Card Present?
+		//
+		Query->x.lu_card_present = ( logical_slot_reg.x.PRSNT1_2 != SHPC_SLOT_EMPTY ) ?
+			HP_TRUE : HP_FALSE;
+
+		//
+		// Get Card PCI-66 capability
+		//
+		Query->x.lu_card_pci66_capable = (( logical_slot_reg.x.PRSNT1_2 != SHPC_SLOT_EMPTY ) &&
+			( logical_slot_reg.x.S_STATE == SHPC_POWER_ONLY || logical_slot_reg.x.S_STATE == SHPC_ENABLE_SLOT ) &&
+			( logical_slot_reg.x.M66_CAP == SHPC_STATUS_SET )) ?
+			HP_TRUE : HP_FALSE;
+
+		//
+		// Power-Fault?
+		//
+		Query->x.lu_power_fault = ( logical_slot_reg.x.PF == SHPC_STATUS_SET ) ?
+			HP_TRUE : HP_FALSE;
+
+		//
+		//  Card Power Requirements
+		//
+		Query->x.lu_card_power = hp_translate_card_power( logical_slot_reg.x.PRSNT1_2 );
+
+		//
+		//  Attention Indicator
+		//
+		Query->x.lu_ai_state = hp_translate_indicator( logical_slot_reg.x.AIS );
+
+		//
+		//  Power Indicator
+		//
+		Query->x.lu_pi_state = hp_translate_indicator( logical_slot_reg.x.PIS );
+
+		//
+		// MRL Implemented?
+		//
+		Query->x.lu_mrl_implemented = ( logical_slot_reg.x.MRLS_IM == SHPC_UNMASKED ) ?
+			HP_TRUE : HP_FALSE;
+
+		//
+		// MRL Opened?
+		//
+		Query->x.lu_mrl_opened = (( logical_slot_reg.x.MRLS == SHPC_MRL_OPEN ) &&
+			( logical_slot_reg.x.MRLS_IM == SHPC_UNMASKED )) ? HP_TRUE : HP_FALSE;
+
+		//
+		// Slot State: Card Present, MRL closed, No Power-Fault, Enabled?
+		//
+		if( logical_slot_reg.x.PRSNT1_2 != SHPC_SLOT_EMPTY &&
+			( logical_slot_reg.x.MRLS_IM == SHPC_MASKED ||
+			logical_slot_reg.x.MRLS == SHPC_MRL_CLOSED ) &&
+			logical_slot_reg.x.PF == SHPC_STATUS_CLEARED &&
+			logical_slot_reg.x.S_STATE == SHPC_ENABLE_SLOT ) {
+			Query->x.lu_slot_state = SLOT_ENABLE;
+		}
+		else {
+			Query->x.lu_slot_state = SLOT_DISABLE;
+		}
+
+		//
+		// OK, it's all there!
+		//
+		Query->x.lu_reserved1 = 0;
+		Query->x.lu_reserved2 = 0;
+		Query->x.lu_request_failed = HP_FALSE;
+	}
+
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_StartAsyncRequest()
+//
+// Parameters
+//	shpc_context - Caller provided storage for SHPC context data.
+//	slot_id - Zero-based slot number (0..n-1).
+//	Request - Async request: Slot "Enable/Disable", AttnLED "Attn/Normal").
+//	timeout - For AttnLED "Attn" requests (in seconds)
+//	request_context - Caller provided pointer to be returned upon completion.
+//
+// Return Value
+//	STATUS_SUCCESS if the request is accepted.  The Callback() is later invoked with a completion status.
+//  STATUS_UNSUCCESSFUL if the request is rejected (invalid parameters, or similar request in progress),
+//
+// Comment:
+//	For AttnLED "Attn" requests, the completion Callback() function is invoked as soon as the hardware
+//	completes (Blink) execution.  When the timeout period expires, the AttnLED is brought back to
+//  its "Normal" (On/Off) state, and the Callback() is invoked once again.
+//
+// ****************************************************************************
+long
+hp_StartAsyncRequest(
+	struct shpc_context* shpc_context,
+	u8 slot_id,
+	enum shpc_async_request request,
+	u32 timeout,
+	void* request_context
+	)
+{
+	unsigned long		old_irq_flags;
+	struct slot_context* slot_context;
+	long status = STATUS_SUCCESS;
+
+	dbg("%s -->slot_id[ %d:%d ]  Request[ %d ]",__FUNCTION__ ,
+		shpc_context->shpc_instance, slot_id, request );
+
+	//
+	// Valid slot_id?
+	//
+	if( slot_id >= shpc_context->number_of_slots ) {
+		status = STATUS_UNSUCCESSFUL;
+	}
+	else {
+		slot_context = &shpc_context->slot_context[ slot_id ];
+
+		switch( request ) {
+		case SHPC_ASYNC_ENABLE_SLOT:
+			dbg("%s SHPC_ASYNC_ENABLE_SLOT",__FUNCTION__);
+		case SHPC_ASYNC_DISABLE_SLOT:
+			dbg("%s SHPC_ASYNC_DISABLE_SLOT",__FUNCTION__);
+			//
+			// Slot Request Pending?
+			//
+			spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+			down_interruptible(&slot_context->slot_event_bits_semaphore);
+			down_interruptible(&shpc_context->shpc_event_bits_semaphore);
+			if((slot_context->slot_event_bits & SLOT_REQUEST_EVENT) ||
+				(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)) {
+				status = STATUS_UNSUCCESSFUL;
+				up(&slot_context->slot_event_bits_semaphore);
+				up(&shpc_context->shpc_event_bits_semaphore);
+			}
+			else {
+				up(&slot_context->slot_event_bits_semaphore);
+				up(&shpc_context->shpc_event_bits_semaphore);
+				slot_context->slot_request.type = request;
+				slot_context->slot_request.request_context = request_context;
+				hp_send_slot_event(slot_context, SLOT_REQUEST_EVENT);
+			}
+			spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+			break;
+
+		case SHPC_ASYNC_LED_LOCATE:
+			dbg("%s SHPC_ASYNC_LED_LOCATE",__FUNCTION__);
+		case SHPC_ASYNC_LED_NORMAL:
+			dbg("%s SHPC_ASYNC_LED_NORMAL",__FUNCTION__);
+			//
+			// AttnLED Request Pending?
+			//
+			spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+			down_interruptible(&slot_context->slot_event_bits_semaphore);
+			down_interruptible(&shpc_context->shpc_event_bits_semaphore);
+			if((slot_context->slot_event_bits & ATTN_LED_REQUEST_EVENT) ||
+				(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)) {
+				dbg("%s  LED--STATUS_UNSUCCESSFUL  slot_event_bits = %08X", __FUNCTION__ ,slot_context->slot_event_bits);
+				status = STATUS_UNSUCCESSFUL;
+				up(&slot_context->slot_event_bits_semaphore);
+				up(&shpc_context->shpc_event_bits_semaphore);
+			}
+			else {
+				up(&slot_context->slot_event_bits_semaphore);
+				up(&shpc_context->shpc_event_bits_semaphore);
+				slot_context->attn_led_request.type = request;
+				slot_context->attn_led_request.timeout = timeout;
+				slot_context->attn_led_request.request_context = request_context;
+				hp_send_slot_event(slot_context, ATTN_LED_REQUEST_EVENT);
+			}
+			spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+			break;
+
+		case SHPC_ASYNC_QUIESCE_DEVNODE_NOTIFY:
+			dbg("%s SHPC_ASYNC_QUIESCE_DEVNODE_NOTIFY",__FUNCTION__);
+			//
+			// HP library notification: DevNode is quiesced
+			//
+			spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+			++slot_context->quiesce_replies;
+			if( slot_context->quiesce_requests &&
+				slot_context->quiesce_replies >= slot_context->quiesce_requests ) {
+				slot_context->slot_quiesced = TRUE;
+				hp_send_slot_event(slot_context, QUIESCE_EVENT);
+			}
+			spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+			break;
+
+		case SHPC_ASYNC_CANCEL_QUIESCE_DEVNODE:
+			dbg("%s SHPC_ASYNC_CANCEL_QUIESCE_DEVNODE",__FUNCTION__);
+			//
+			// HP library notification: could not quiesce DevNode
+			//
+			spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+			slot_context->slot_quiesced = FALSE;
+			hp_send_slot_event(slot_context, QUIESCE_EVENT);
+			spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+			//
+			// Abort bus-rebalancing
+			//
+			spin_lock_irqsave( &shpc_context->shpc_spinlock, old_irq_flags );
+			shpc_context->bus_released = FALSE;
+			hp_send_event_to_all_slots(shpc_context, BUS_COMPLETE_EVENT);
+			spin_unlock_irqrestore( &shpc_context->shpc_spinlock, old_irq_flags );
+			break;
+
+		default:
+			status = STATUS_UNSUCCESSFUL;
+			break;
+		}
+	}
+
+	return status;
+}
+
+// ****************************************************************************
+//
+// hp_Queryslot_psn() 
+//
+// Parameters
+//          shpc_context - Caller provided storage for SHPC context data.
+//          SlotID - Zero-based slot number (0..n-1).
+//          slot_psn - Pointer to Physical Slot Number
+//
+// Return Value
+//  STATUS_SUCCESS, or STATUS_UNSUCCESSFUL for invalid SlotID.
+//
+// ****************************************************************************
+long hp_Queryslot_psn(struct shpc_context *shpc_context, unsigned char slot_ID, unsigned long *slot_psn)
+{
+	struct slot_context *slot_context;
+	long status = STATUS_SUCCESS;
+	dbg("%s slot_ID[ %d:%d ]",__FUNCTION__ , shpc_context->shpc_instance, slot_ID);
+	//
+	// Valid SlotID?
+	//
+	if( slot_ID >= shpc_context->number_of_slots || slot_psn == NULL ) {
+				status = STATUS_UNSUCCESSFUL;
+	}
+	else {
+		//
+		// Which slot?
+		//
+		slot_context = &shpc_context->slot_context[ slot_ID ];
+		//
+		// Get slot PSN
+		//
+		*slot_psn = slot_context->slot_psn;
+	}
+	return status;
+}
+
+// ****************************************************************************
+//
+// hp_slot_timers1-10func(): Function passed to timer to send event
+//
+// Parameters
+//	slot_context - Caller provided storage for SHPC context data.
+//
+// Return Value
+//	void
+//
+// ****************************************************************************
+void hp_slot_timer1_func(unsigned long data){
+
+	struct slot_context *slot_context;
+	slot_context = (struct slot_context*) data;
+
+	dbg("%s", __FUNCTION__);
+	hp_set_slot_event_bit(slot_context, SLOT_TIMER1_EVENT);
+
+	wake_up_interruptible(&slot_context->slot_event);
+}
+
+void hp_slot_timer2_func(unsigned long data){
+
+	struct slot_context *slot_context;
+	slot_context = (struct slot_context*) data;
+
+	dbg("%s", __FUNCTION__);
+	hp_set_slot_event_bit(slot_context, SLOT_TIMER2_EVENT);
+
+	wake_up_interruptible(&slot_context->slot_event);
+}
+
+void hp_slot_timer3_func(unsigned long data){
+
+	struct slot_context *slot_context;
+	slot_context = (struct slot_context*) data;
+
+	dbg("%s", __FUNCTION__);
+	hp_set_slot_event_bit(slot_context, SLOT_TIMER3_EVENT);
+
+	wake_up_interruptible(&slot_context->slot_event);
+}
+
+void hp_slot_timer4_func(unsigned long data){
+
+	struct slot_context *slot_context;
+	slot_context = (struct slot_context*) data;
+
+	dbg("%s", __FUNCTION__);
+	hp_set_slot_event_bit(slot_context, SLOT_TIMER4_EVENT);
+
+	wake_up_interruptible(&slot_context->slot_event);
+}
+
+void hp_slot_timer5_func(unsigned long data){
+
+	struct slot_context *slot_context;
+	slot_context = (struct slot_context*) data;
+
+	dbg("%s", __FUNCTION__);
+	hp_set_slot_event_bit(slot_context, SLOT_TIMER5_EVENT);
+
+	wake_up_interruptible(&slot_context->slot_event);
+}
+
+void hp_slot_timer6_func(unsigned long data){
+
+	struct slot_context *slot_context;
+	slot_context = (struct slot_context*) data;
+
+	dbg("%s", __FUNCTION__);
+	hp_set_slot_event_bit(slot_context, SLOT_TIMER6_EVENT);
+
+	wake_up_interruptible(&slot_context->slot_event);
+}
+
+void hp_slot_timer7_func(unsigned long data){
+
+	struct slot_context *slot_context;
+	slot_context = (struct slot_context*) data;
+
+	dbg("%s", __FUNCTION__);
+	hp_set_slot_event_bit(slot_context, SLOT_TIMER7_EVENT);
+
+	wake_up_interruptible(&slot_context->slot_event);
+}
+
+void hp_slot_timer8_func(unsigned long data){
+
+	struct slot_context *slot_context;
+	slot_context = (struct slot_context*) data;
+
+	dbg("%s", __FUNCTION__);
+	hp_set_slot_event_bit(slot_context, SLOT_TIMER8_EVENT);
+
+	wake_up_interruptible(&slot_context->slot_event);
+}
+
+void hp_slot_timer9_func(unsigned long data){
+
+	struct slot_context *slot_context;
+	slot_context = (struct slot_context*) data;
+
+	dbg("%s", __FUNCTION__);
+	hp_set_slot_event_bit(slot_context, SLOT_TIMER9_EVENT);
+
+	wake_up_interruptible(&slot_context->slot_event);
+}
+
+void hp_slot_timer10_func(unsigned long data){
+
+	struct slot_context *slot_context;
+	slot_context = (struct slot_context*) data;
+
+	dbg("%s", __FUNCTION__);
+	hp_set_slot_event_bit(slot_context, SLOT_TIMER10_EVENT);
+
+	wake_up_interruptible(&slot_context->slot_event);
+}
+
+// ****************************************************************************
+//
+// hp_led_timers1-4_func(): Function passed to timer to send event
+//
+// Parameters
+//	slot_context - Caller provided storage for SHPC context data.
+//
+// Return Value
+//	void
+//
+// ****************************************************************************
+void hp_led_timer1_func(unsigned long data){
+
+	struct slot_context *slot_context;
+	slot_context = (struct slot_context*) data;
+
+	dbg("%s", __FUNCTION__);
+	hp_set_slot_event_bit(slot_context, LED_TIMER1_EVENT);
+
+	wake_up_interruptible(&slot_context->slot_event);
+}
+
+void hp_led_timer2_func(unsigned long data){
+
+	struct slot_context *slot_context;
+	slot_context = (struct slot_context*) data;
+
+	dbg("%s", __FUNCTION__);
+	hp_set_slot_event_bit(slot_context, LED_TIMER2_EVENT);
+
+	wake_up_interruptible(&slot_context->slot_event);
+}
+
+void hp_led_timer3_func(unsigned long data){
+
+	struct slot_context *slot_context;
+	slot_context = (struct slot_context*) data;
+
+	dbg("%s", __FUNCTION__);
+	hp_set_slot_event_bit(slot_context, LED_TIMER3_EVENT);
+
+	wake_up_interruptible(&slot_context->slot_event);
+}
+
+void hp_led_timer4_func(unsigned long data){
+
+	struct slot_context *slot_context;
+	slot_context = (struct slot_context*) data;
+
+	dbg("%s", __FUNCTION__);
+	hp_set_slot_event_bit(slot_context, LED_TIMER4_EVENT);
+
+	wake_up_interruptible(&slot_context->slot_event);
+}
+
+// ****************************************************************************
+//
+// hp_clear_slot_event_bit():
+//
+// Parameters
+//	slot_context - Caller provided storage for SHPC context data.
+//
+// Return Value
+//	void
+//
+// ****************************************************************************
+void hp_clear_slot_event_bit(struct slot_context * slot_context, u32 mask)
+{
+//	dbg("%s -->slot bits %08X   MASK=%08X",__FUNCTION__ ,slot_context->slot_event_bits, mask);
+
+	down_interruptible(&slot_context->slot_event_bits_semaphore);
+	// cleareventbit
+	slot_context->slot_event_bits &= ~mask;
+	up(&slot_context->slot_event_bits_semaphore);
+}
+
+// ****************************************************************************
+//
+// hp_set_slot_event_bit():
+//
+// Parameters
+//	slot_context - Caller provided storage for SHPC context data.
+//
+// Return Value
+//	void
+//
+// ****************************************************************************
+void hp_set_slot_event_bit(struct slot_context * slot_context, u32 mask)
+{
+//	dbg("%s -->slot bits %08X   MASK=%08X",__FUNCTION__ ,slot_context->slot_event_bits, mask);
+
+	down_interruptible(&slot_context->slot_event_bits_semaphore);
+	// cleareventbit
+	slot_context->slot_event_bits |= mask;
+	up(&slot_context->slot_event_bits_semaphore);
+}
+
+// ****************************************************************************
+//
+// hp_clear_shpc_event_bit():
+//
+// Parameters
+//	slot_context - Caller provided storage for SHPC context data.
+//
+// Return Value
+//	void
+//
+// ****************************************************************************
+void hp_clear_shpc_event_bit(struct shpc_context * shpc_context, u32 mask)
+{
+	down_interruptible(&shpc_context->shpc_event_bits_semaphore);
+	// cleareventbit
+	shpc_context->shpc_event_bits &= ~mask;
+	up(&shpc_context->shpc_event_bits_semaphore);
+}
+
+// ****************************************************************************
+//
+// hp_set_shpc_event_bit():
+//
+// Parameters
+//	slot_context - Caller provided storage for SHPC context data.
+//
+// Return Value
+//	void
+//
+// ****************************************************************************
+void hp_set_shpc_event_bit(struct shpc_context * shpc_context, u32 mask)
+{
+	down_interruptible(&shpc_context->shpc_event_bits_semaphore);
+	// set event bit
+	shpc_context->shpc_event_bits |= mask;
+	up(&shpc_context->shpc_event_bits_semaphore);
+}
+
+// ****************************************************************************
+//
+// hp_send_event_to_all_slots():
+//
+// Parameters
+//	slot_context - Caller provided storage for SHPC context data.
+//
+// Return Value
+//	void
+//
+// ****************************************************************************
+void hp_send_event_to_all_slots(struct shpc_context *shpc_context, u32 mask)
+{
+	u8 i;
+	struct slot_context * slot_context;
+
+	down_interruptible(&shpc_context->shpc_event_bits_semaphore);
+	// set event bit
+	shpc_context->shpc_event_bits |= mask;
+	// send event to each slot thread
+	for( i=0; i<shpc_context->number_of_slots; ++i ) {
+		slot_context = &shpc_context->slot_context[ i ];
+		wake_up_interruptible(&slot_context->slot_event);
+	}
+	up(&shpc_context->shpc_event_bits_semaphore);
+}
+
+// ****************************************************************************
+//
+// hp_send_slot_event():
+//
+// Parameters
+//	slot_context - Caller provided storage for SHPC context data.
+//
+// Return Value
+//	void
+//
+// ****************************************************************************
+void hp_send_slot_event(struct slot_context * slot_context, u32 mask)
+{
+	// set event bit
+	hp_set_slot_event_bit(slot_context, mask);
+	wake_up_interruptible( &slot_context->slot_event);
+}
+
+
+// ****************************************************************************
+//
+// hp_get_led_cmd_available_mutex_thread():  run as a thread per each slot
+//
+// Parameters
+//	slot_context - Caller provided storage for slot context data.
+//
+// Return Value
+//	void
+//
+// ****************************************************************************
+int hp_get_led_cmd_available_mutex_thread(void *ptr)
+{
+	long status = STATUS_SUCCESS;
+	struct shpc_context* shpc_context;
+	struct slot_context* slot_context;
+	int pid;
+	
+	lock_kernel ();
+	daemonize ("amdshpc_getledcmd_av_mutex");
+	unlock_kernel ();
+
+	slot_context = (struct slot_context* ) ptr;
+	shpc_context = (struct shpc_context* ) slot_context->shpc_context;
+	do {
+		interruptible_sleep_on(&slot_context->led_cmd_acquire_event);
+		if (slot_context->slot_event_bits & LED_CMD_ACQUIRE_EVENT){
+			hp_clear_slot_event_bit(slot_context, LED_CMD_ACQUIRE_EVENT);
+			pid = kernel_thread(hp_led_cmd_available_mutex_thread, slot_context, CLONE_SIGHAND);
+			if (pid < 0) {
+				err ("Can't start up our hp_led_cmd_available_mutex_thread\n");
+				status = STATUS_UNSUCCESSFUL;
+				break;
+			}
+		} else {
+			dbg("%s terminating return 0  slot_id[ %d:%d ]",__FUNCTION__,
+				shpc_context->shpc_instance, slot_context->slot_number-1);
+			return 0;
+		}
+	} while (1);
+	return(status);
+}
+
+// ****************************************************************************
+//
+// hp_led_cmd_available_mutex_thread():  run as a thread per each request for cmd
+//
+// Parameters
+//	slot_context - Caller provided storage for SHPC context data.
+//
+// Return Value
+//	void
+//
+// ****************************************************************************
+int hp_led_cmd_available_mutex_thread(void *ptr)
+{
+	struct shpc_context* shpc_context;
+	struct slot_context* slot_context;
+	
+	lock_kernel ();
+	daemonize ("amdshpc_ledcmd_av_mutex");
+	unlock_kernel ();
+
+	slot_context = (struct slot_context* ) ptr;
+	shpc_context = (struct shpc_context* ) slot_context->shpc_context;
+
+	//
+	// acquire the main mutex for all slots exclusion
+	//
+	down_interruptible(&shpc_context->cmd_available_mutex);
+	if ((shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)||
+		(shpc_context->shpc_event_bits & RESUME_EVENT)||
+		(shpc_context->shpc_event_bits & REMOVE_EVENT)){
+		dbg("%s return 0  slot_id[ %d:%d ]",__FUNCTION__,
+			shpc_context->shpc_instance, slot_context->slot_number-1);
+		up(&shpc_context->cmd_available_mutex);
+		return 0;
+	}
+
+	//
+	// now tell our slot thread that it has the mutex
+	//
+	hp_set_shpc_event_bit(shpc_context, LED_CMD_AVAILABLE_MUTEX_EVENT);
+	wake_up_interruptible(&slot_context->slot_event);
+
+	//
+	// wait for our slot thread to release the mutex
+	//
+	interruptible_sleep_on(&slot_context->led_cmd_release_event);
+	if ((shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)||
+		(shpc_context->shpc_event_bits & RESUME_EVENT)||
+		(shpc_context->shpc_event_bits & REMOVE_EVENT)){
+		dbg("%s return 0  slot_id[ %d:%d ]",__FUNCTION__,
+			shpc_context->shpc_instance, slot_context->slot_number-1);
+		up(&shpc_context->cmd_available_mutex);
+		return 0;
+	}
+	hp_clear_slot_event_bit(slot_context, LED_CMD_RELEASE_EVENT);
+
+	hp_clear_shpc_event_bit(shpc_context, LED_CMD_AVAILABLE_MUTEX_EVENT);
+	up(&shpc_context->cmd_available_mutex);
+	dbg("%s cmd_available_mutex RELEASED",__FUNCTION__);
+	return(0);
+}
+
+// ****************************************************************************
+//
+// hp_get_cmd_available_mutex_thread():  run as a thread per each slot
+//
+// Parameters
+//	slot_context - Caller provided storage for slot context data.
+//
+// Return Value
+//	void
+//
+// ****************************************************************************
+int hp_get_cmd_available_mutex_thread(void *ptr)
+{
+	long status = STATUS_SUCCESS;
+	struct shpc_context* shpc_context;
+	struct slot_context* slot_context;
+	int pid;
+	
+	lock_kernel ();
+	daemonize ("amdshpc_getcmd_av_mutex");
+	unlock_kernel ();
+
+	slot_context = (struct slot_context* ) ptr;
+	shpc_context = (struct shpc_context* ) slot_context->shpc_context;
+
+	do {
+		interruptible_sleep_on(&slot_context->cmd_acquire_event);
+		if ((slot_context->slot_event_bits & CMD_ACQUIRE_EVENT) || 
+		    (slot_context->slot_event_bits & CMD_RELEASE_EVENT)){
+			hp_clear_slot_event_bit(slot_context,CMD_ACQUIRE_EVENT);
+			pid = kernel_thread(hp_cmd_available_mutex_thread, slot_context, CLONE_SIGHAND);
+			if (pid < 0) {
+				err ("Can't start up our hp_get_cmd_available_mutex_thread\n");
+				status = STATUS_UNSUCCESSFUL;
+				break;
+			}
+		} else {
+			dbg("%s terminating return 0  slot_id[ %d:%d ]",__FUNCTION__,
+				shpc_context->shpc_instance, slot_context->slot_number-1);
+			return 0;
+		}
+	} while (1);
+	return(status);
+}
+
+// ****************************************************************************
+//
+// hp_cmd_available_mutex_thread():  run as a thread per each request for cmd
+//
+// Parameters
+//	slot_context - Caller provided storage for SHPC context data.
+//
+// Return Value
+//	void
+//
+// ****************************************************************************
+int hp_cmd_available_mutex_thread(void *ptr)
+{
+	struct shpc_context* shpc_context;
+	struct slot_context* slot_context;
+	
+	lock_kernel ();
+	daemonize ("amdshpc_cmd_av_mutex");
+	unlock_kernel ();
+
+	slot_context = (struct slot_context* ) ptr;
+	shpc_context = (struct shpc_context* ) slot_context->shpc_context;
+
+	//
+	// acquire the main mutex for all slots exclusion
+	//
+	down_interruptible(&shpc_context->cmd_available_mutex);
+	if ((shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)||
+		(shpc_context->shpc_event_bits & RESUME_EVENT)||
+		(shpc_context->shpc_event_bits & REMOVE_EVENT)){
+		dbg("%s return 0  slot_id[ %d:%d ]",__FUNCTION__,
+			shpc_context->shpc_instance, slot_context->slot_number-1);
+		up(&shpc_context->cmd_available_mutex);
+		return 0;
+	}
+
+	//
+	// now tell our slot thread that it has the mutex
+	//
+	hp_set_shpc_event_bit(shpc_context, CMD_AVAILABLE_MUTEX_EVENT);
+	wake_up_interruptible(&slot_context->slot_event);
+
+	//
+	// wait for our slot thread to release the mutex
+	//
+	interruptible_sleep_on(&slot_context->cmd_release_event);
+	if ((shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)||
+		(shpc_context->shpc_event_bits & RESUME_EVENT)||
+		(shpc_context->shpc_event_bits & REMOVE_EVENT)){
+		dbg("%s return 0  slot_id[ %d:%d ]",__FUNCTION__,
+			shpc_context->shpc_instance, slot_context->slot_number-1);
+		up(&shpc_context->cmd_available_mutex);
+		return 0;
+	}
+	hp_clear_slot_event_bit(slot_context,CMD_RELEASE_EVENT);
+	hp_clear_shpc_event_bit(shpc_context, CMD_AVAILABLE_MUTEX_EVENT);
+	up(&shpc_context->cmd_available_mutex);
+	return(0);
+}
+
+// ****************************************************************************
+//
+// hp_get_bus_available_mutex_thread():  run as a thread per each slot
+//
+// Parameters
+//	slot_context - Caller provided storage for slot context data.
+//
+// Return Value
+//	void
+//
+// ****************************************************************************
+int hp_get_bus_available_mutex_thread(void *ptr)
+{
+	long status = STATUS_SUCCESS;
+	struct shpc_context* shpc_context;
+	struct slot_context* slot_context;
+	int pid;
+	
+	lock_kernel ();
+	daemonize ("amdshpc_getbus_av_mutex");
+	unlock_kernel ();
+
+	slot_context = (struct slot_context* ) ptr;
+	shpc_context = (struct shpc_context* ) slot_context->shpc_context;
+
+	do {
+		interruptible_sleep_on(&slot_context->bus_acquire_event);
+		if (slot_context->slot_event_bits & BUS_ACQUIRE_EVENT) {
+			hp_clear_slot_event_bit(slot_context, BUS_ACQUIRE_EVENT);
+			pid = kernel_thread(hp_bus_available_mutex_thread, slot_context, CLONE_SIGHAND);
+			if (pid < 0) {
+				err ("Can't start up our hp_get_bus_available_mutex_thread\n");
+				status = STATUS_UNSUCCESSFUL;
+				break;
+			}
+		} else {
+			dbg("%s terminating return 0  slot_id[ %d:%d ]",__FUNCTION__,
+				shpc_context->shpc_instance, slot_context->slot_number-1);
+			return 0;
+		}
+	} while (1);
+	return(status);
+}
+
+// ****************************************************************************
+//
+// hp_bus_available_mutex_thread():
+//
+// Parameters
+//	slot_context - Caller provided storage for SHPC context data.
+//
+// Return Value
+//	void
+//
+// ****************************************************************************
+int hp_bus_available_mutex_thread(void *ptr)
+{
+	struct shpc_context* shpc_context;
+	struct slot_context* slot_context;
+	
+	lock_kernel ();
+	daemonize ("amdshpc_bus_av_mutex");
+	//  New name
+	unlock_kernel ();
+
+	slot_context = (struct slot_context* ) ptr;
+	shpc_context = (struct shpc_context* ) slot_context->shpc_context;
+
+	//
+	// acquire the main mutex for all slots exclusion
+	//
+	down_interruptible(&shpc_context->bus_available_mutex);
+	if ((shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)||
+		(shpc_context->shpc_event_bits & RESUME_EVENT)||
+		(shpc_context->shpc_event_bits & REMOVE_EVENT)){
+		dbg("%s return 0  slot_id[ %d:%d ]",__FUNCTION__,
+			shpc_context->shpc_instance, slot_context->slot_number-1);
+		up(&shpc_context->bus_available_mutex);
+		return 0;
+	}
+
+	//
+	// now tell our slot thread that it has the mutex
+	//
+	hp_set_shpc_event_bit(shpc_context, BUS_AVAILABLE_MUTEX_EVENT);
+	wake_up_interruptible(&slot_context->slot_event);
+
+	//
+	// wait for our slot thread to release the mutex
+	//
+	interruptible_sleep_on(&slot_context->bus_release_event);
+	if ((shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)||
+		(shpc_context->shpc_event_bits & RESUME_EVENT)||
+		(shpc_context->shpc_event_bits & REMOVE_EVENT)){
+		dbg("%s return 0  slot_id[ %d:%d ]",__FUNCTION__,
+			shpc_context->shpc_instance, slot_context->slot_number-1);
+		up(&shpc_context->bus_available_mutex);
+		return 0;
+	}
+	hp_clear_slot_event_bit(slot_context, BUS_RELEASE_EVENT);
+
+	hp_clear_shpc_event_bit(shpc_context, BUS_AVAILABLE_MUTEX_EVENT);
+	up(&shpc_context->bus_available_mutex);
+	return(0);
+}
+
+// ****************************************************************************
+//
+// call_back_routine():
+//
+// Parameters
+//	slot_context - Caller provided storage for SHPC context data.
+//
+// Return Value
+//	void
+//
+// ****************************************************************************
+static unsigned long async_callback (void* driver_context,
+				     u8 slot_id,
+				     enum shpc_async_request async_request,
+				     union SLOT_STATUS_INFO slot_status,
+				     void* request_context )
+{
+	u8 phys_slot_num;
+	long rc=0;
+	struct pci_func *slot_func;
+	struct controller *ctrl;
+	struct shpc_context *shpc_context;
+	u8 bus=0;
+	u8 device=0;
+	u8 function=0;
+	unsigned long devices_still_quiescing = 0;
+
+	dbg("%s slot_id = %d",__FUNCTION__, slot_id);
+
+	ctrl = ((struct controller*) driver_context);
+	if (ctrl == NULL){
+		return -ENODEV;
+	}
+
+	shpc_context = (struct shpc_context* ) ctrl->shpc_context;
+	phys_slot_num = shpc_context->slot_context[slot_id].slot_psn;
+	
+	bus		= ctrl->bus;
+	device 	= slot_id + 1;
+	
+	dbg("%s - physical_slot = %d  instance = %d",__FUNCTION__, phys_slot_num, shpc_context->shpc_instance);
+
+	switch( async_request ) {
+	case SHPC_ASYNC_ENABLE_SLOT:
+		dbg("%s SHPC_ASYNC_ENABLE_SLOT",__FUNCTION__);
+		dbg("%s slot occupied = %d",__FUNCTION__,shpc_context->slot_context[slot_id].slot_occupied);
+		if (shpc_context->slot_context[slot_id].slot_occupied == 1) {
+			return 0;
+		}
+		//
+		// Force pci-bus re-enumeration (probe), to load drivers on behalf on enabled device(s) on this slot.
+		//
+		dbg("%s   In callback routine processing enable slot",__FUNCTION__ );
+
+		dbg("%s   CALLING amdshpc_slot_find  bus, dev, fn = %d, %d, %d\n",__FUNCTION__ ,
+			bus, device, function);
+		slot_func = amdshpc_slot_find(bus, device, function);
+		dbg("%s  slot_func = %p ",__FUNCTION__ , slot_func);
+		if (!slot_func) {
+			dbg("%s --> slot_func not found",__FUNCTION__ );
+			return -ENODEV;
+		}
+
+		slot_func->bus = bus;
+		slot_func->device = device;
+		slot_func->function = function;
+		slot_func->configured = 0;
+		dbg("%s   CALLING amdshpc_process_SI(ctrl=%p slot_func=%p)\n",__FUNCTION__ , ctrl, slot_func);
+		rc = amdshpc_process_SI(ctrl, slot_func);
+		if (!rc ) {
+			shpc_context->slot_context[slot_id].slot_occupied = 1;
+		}
+		dbg("%s   amdshpc_process_SI returned  rc=%d",__FUNCTION__ , (int)rc);
+		break;
+
+	case SHPC_ASYNC_SURPRISE_REMOVE:
+		dbg("%s SHPC_ASYNC_SURPRISE_REMOVE",__FUNCTION__);
+		//
+		// Something went wrong with the slot (eg, power-fault), and loaded drivers must be removed.
+		//
+	case SHPC_ASYNC_QUIESCE_DEVNODE:
+		dbg("%s SHPC_ASYNC_QUIESCE_DEVNODE",__FUNCTION__);
+		//
+		// Friendly opportunity to quiesce (remove) drivers, prior to disabling the slot.
+		// After device drivers are removed, it's OK to show messages to that effect.
+		//
+		// If device quiecing will complete at a later time (from a separate thread),
+		// then set "devices_still_quiescing" accordingly, and upon quiecing-completion,
+		// call hp_StartAsyncRequest() with a "SHPC_ASYNC_QUIESCE_DEVNODE_NOTIFY" request.
+		//
+	case SHPC_ASYNC_QUIESCE_DEVNODE_QUIET:
+		dbg("%s SHPC_ASYNC_QUIESCE_DEVNODE_QUIET",__FUNCTION__);
+		//
+		// Friendly opportunity to quiesce (remove) drivers, prior to disabling the slot.
+		// After device drivers are removed, don't show messages to that effect.
+		//
+		// If device quiecing will complete at a later time (from a separate thread),
+		// then set "devices_still_quiescing" accordingly, and upon quiecing-completion,
+		// call hp_StartAsyncRequest() with a "SHPC_ASYNC_QUIESCE_DEVNODE_NOTIFY" request.
+		//
+		dbg("%s   Processing disable slot",__FUNCTION__ );
+		
+		dbg("%s   CALLING amdshpc_slot_find  bus, dev, fn = %d, %d, %d\n",__FUNCTION__ ,
+			bus, device, function);
+
+		slot_func = amdshpc_slot_find(bus, device, function);
+		dbg("%s  slot_func = %p ",__FUNCTION__ , slot_func);
+		if (!slot_func) {
+			dbg("%s --> slot_func not found",__FUNCTION__ );
+			return -ENODEV;
+		}
+
+		dbg("%s   CALLING amdshpc_process_SS(ctrl=%p slot_func=%p)\n",__FUNCTION__ , ctrl, slot_func);
+		rc = amdshpc_process_SS(ctrl, slot_func);
+		if (!rc ) {
+			shpc_context->slot_context[slot_id].slot_occupied = 0;
+		}
+		dbg("%s   amdshpc_process_SS returned  rc=%d",__FUNCTION__ , (int)rc);
+
+		break;
+
+	case SHPC_ASYNC_DISABLE_SLOT:
+		dbg("%s SHPC_ASYNC_DISABLE_SLOT",__FUNCTION__);
+		//
+		// Just a notification, may be used to update some interested GUI application.
+		//
+		break;
+
+	default:
+		break;
+	}
+	return devices_still_quiescing;
+}
+
diff -purN linux-2.5/drivers/pci/hotplug/amdshpc_ddi.h usb-2.5/drivers/pci/hotplug/amdshpc_ddi.h
--- linux-2.5/drivers/pci/hotplug/amdshpc_ddi.h	1970-01-01 00:00:00.000000000 +0000
+++ usb-2.5/drivers/pci/hotplug/amdshpc_ddi.h	2003-08-28 23:06:29.000000000 +0000
@@ -0,0 +1,235 @@
+/*
+* Copyright (C) 2002,2003 Advanced Micro Devices, Inc.
+* YOUR USE OF THIS CODE IS SUBJECT TO THE TERMS
+* AND CONDITIONS OF THE GNU GENERAL PUBLIC
+* LICENSE FOUND IN THE "GPL.TXT" FILE THAT IS
+* INCLUDED WITH THIS FILE AND POSTED AT
+* http://www.gnu.org/licenses/gpl.html
+*
+*
+* This driver is to be used as a skeleton driver to be show how to interface
+* with the pci hotplug core easily.
+*
+* Send feedback to <david.keck@amd.com>
+*
+*/
+
+
+#ifndef _SHPC_DDI_H_
+#define _SHPC_DDI_H_
+
+#include "amdshpc.h"
+//
+// SHPC Constants
+//
+#define	SHPC_MAX_NUM_SLOTS		4
+
+
+// ****************************************************************************
+//
+// hp_AddDevice()
+//
+// Parameters
+//	shpc_context - Caller provided storage for SHPC context data (per hardware-instance).
+//	driver_context - Caller provided pointer to be returned upon completion.
+//	Callback - Caller provided function to be called upon completion of async requests.
+//  shpc_instance - Zero-based hardware instance.
+//
+// Return Value
+//  Status returned by any system calls made within hp_AddDevice().
+//
+// ****************************************************************************
+long
+	hp_AddDevice(
+			struct shpc_context *shpc_context,
+			void* driver_context,
+			SHPC_ASYNC_CALLBACK Callback,
+			unsigned long shpc_instance
+			);
+
+
+// ****************************************************************************
+//
+// hp_StartDevice()
+//
+// Parameters
+//	shpc_context - Caller provided storage for SHPC context data.
+//  mmio_base_addr - from u.Memory member of CmResourceTypeMemory
+//	IntVector - from u.Interrupt.Vector member of CmResourceTypeInterrupt
+//	IntMode - from Flags member of CmResourceTypeInterrupt
+//	IntShared - from ShareDisposition member of CmResourceTypeInterrupt
+//	IntAffinity - from u.Interrupt.Affinity member of CmResourceTypeInterrupt
+//
+// Return Value
+//  Status returned by any system calls made within hp_StartDevice().
+//
+// Comments:
+//	The caller is responsible for mapping mmio_base_addr, via MmMapIoSpace(),
+//	before calling hp_StartDevice().
+//
+// ****************************************************************************
+long
+	hp_StartDevice(
+		      struct shpc_context* shpc_context
+		      );
+
+
+// ****************************************************************************
+//
+// hp_StopDevice() 
+//
+// Parameters
+//	shpc_context - Caller provided storage for SHPC context data.
+//
+// Return Value
+//  Status returned by any system calls made within hp_StopDevice().
+//
+// Comments:
+//	The caller is responsible for unmapping mmio_base_addr, via MmUnmapIoSpace(),
+//  after calling hp_StopDevice() for resource re-balancing or device removal.
+//
+// ****************************************************************************
+long hp_StopDevice(struct shpc_context *shpc_context);
+
+// ****************************************************************************
+//
+// hp_SuspendDevice()
+//
+// Parameters
+//	shpc_context - Caller provided storage for SHPC context data.
+//
+// Return Value
+//  Status returned by any system calls made within hp_SuspendDevice().
+//
+// Comments:
+//	hp_SuspendDevice() must be called before transitioning away from PowerDeviceD0.
+//
+// ****************************************************************************
+long hp_SuspendDevice(struct shpc_context *shpc_context);
+
+// ****************************************************************************
+//
+// hp_ResumeDevice() 
+//
+// Parameters
+//	shpc_context - Caller provided storage for SHPC context data.
+//
+// Return Value
+//  Status returned by any system calls made within hp_ResumeDevice().
+//
+// Comments:
+//	hp_SuspendDevice() must be called after transitioning back to PowerDeviceD0.
+//
+// ****************************************************************************
+long hp_ResumeDevice(struct shpc_context *shpc_context);
+
+// ****************************************************************************
+//
+// hp_QuerySlots() 
+//
+// Parameters
+//	shpc_context - Caller provided storage for SHPC context data.
+//	SlotConfig - Caller provided storage for slots configuration info.
+//
+// Return Value
+//  Status returned by any system calls made within hp_QuerySlots().
+//
+// ****************************************************************************
+long hp_QuerySlots(struct shpc_context *shpc_context, union SLOT_CONFIG_INFO* SlotConfig);
+
+
+// ****************************************************************************
+//
+// hp_QuerySlotStatus()
+//
+// Parameters
+//	shpc_context - Caller provided storage for SHPC context data.
+//	slot_id - Zero-based slot number (0..n-1).
+//	Query - Pointer to Slot Status Structure
+//
+// Return Value
+//  Status returned by any system calls made within hp_QuerySlotStatus().
+//
+// ****************************************************************************
+long hp_QuerySlotStatus(struct shpc_context *shpc_context, u8 slot_id, union SLOT_STATUS_INFO* Query);
+
+// ****************************************************************************
+//
+// hp_Queryslot_psn()
+//
+// Parameters
+//          shpc_context - Caller provided storage for SHPC context data.
+//          SlotID - Zero-based slot number (0..n-1).
+//          slot_psn - Pointer to Physical Slot Number
+//
+// Return Value
+//  STATUS_SUCCESS, or STATUS_UNSUCCESSFUL for invalid SlotID.
+//
+// ****************************************************************************
+long hp_Queryslot_psn(struct shpc_context *shpc_context, unsigned char slot_ID, unsigned long *slot_psn);
+
+// ****************************************************************************
+//
+// hp_StartAsyncRequest()
+//
+// Parameters
+//	shpc_context - Caller provided storage for SHPC context data.
+//	slot_id - Zero-based slot number (0..n-1).
+//	Request - Async request: Slot "Enable/Disable", AttnLED "Attn/Normal").
+//	timeout - For AttnLED "Attn" requests (in seconds)
+//	request_context - Caller provided pointer to be returned upon completion.
+//
+// Return Value
+//	STATUS_SUCCESS if the request is accepted.  The Callback() is later invoked with a completion status.
+//  STATUS_UNSUCCESSFUL if the request is rejected (invalid parameters, or similar request in progress),
+//
+// Comment:
+//	For AttnLED "Attn" requests, the completion Callback() function is invoked as soon as the hardware
+//	completes (Blink) execution.  When the timeout period expires, the AttnLED is brought back to
+//  its "Normal" (On/Off) state, and the Callback() is invoked once again.
+//
+// ****************************************************************************
+long hp_StartAsyncRequest(
+			 struct shpc_context *shpc_context,
+			 u8 slot_id,     
+			 enum shpc_async_request Request,
+			 u32 timeout,                            
+			 void* request_context                           
+			 );
+
+
+// ****************************************************************************
+//
+// hp_RegisterUserEvent()
+//
+// Parameters
+//	shpc_context - Caller provided storage for SHPC context data.
+//	user_event_pointer - Pointer to caller's provided EVENT object.
+//
+// Return Value
+//	STATUS_SUCCESS if the request is accepted.
+//  STATUS_UNSUCCESSFUL if the request is rejected (EVENT already registered).
+//
+// ****************************************************************************
+long hp_RegisterUserEvent(
+			 struct shpc_context *shpc_context,
+			 wait_queue_head_t *user_event_pointer
+			 );
+
+
+// ****************************************************************************
+//
+// hp_UnRegisterUserEvent()
+//
+// Parameters
+//	shpc_context - Caller provided storage for SHPC context data.
+//
+// Return Value
+//	STATUS_SUCCESS if the request is accepted.
+//  STATUS_UNSUCCESSFUL if the request is rejected (EVENT not previously registered).
+//
+// ****************************************************************************
+long hp_UnRegisterUserEvent(struct shpc_context *shpc_context);
+
+#endif	// _SHPC_DDI_H_
+
diff -purN linux-2.5/drivers/pci/hotplug/amdshpc_dsb.c usb-2.5/drivers/pci/hotplug/amdshpc_dsb.c
--- linux-2.5/drivers/pci/hotplug/amdshpc_dsb.c	1970-01-01 00:00:00.000000000 +0000
+++ usb-2.5/drivers/pci/hotplug/amdshpc_dsb.c	2003-08-28 23:06:29.000000000 +0000
@@ -0,0 +1,1502 @@
+/*
+ * Copyright (C) 2001,2003 Greg Kroah-Hartman (greg@kroah.com)
+ * Copyright (C) 2001,2003 IBM Corp.
+ * Copyright (C) 2002-2003 Advanced Micro Devices
+ * 
+ * YOUR USE OF THIS CODE IS SUBJECT TO THE TERMS
+ * AND CONDITIONS OF THE GNU GENERAL PUBLIC
+ * LICENSE FOUND IN THE "GPL.TXT" FILE THAT IS
+ * INCLUDED WITH THIS FILE AND POSTED AT
+ * http://www.gnu.org/licenses/gpl.html
+ *
+ * Send feedback to <david.keck@amd.com>
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/sched.h>
+#include "amdshpc_ddi.h"
+#include "amdshpc.h"
+
+
+// ****************************************************************************
+//
+// hp_at_slot_enabled_wait_for_slot_request()
+//
+// ****************************************************************************
+long
+hp_at_slot_enabled_wait_for_slot_request(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+)
+{
+	unsigned long		old_irq_flags;
+	long status = STATUS_SUCCESS;
+	union SLOT_STATUS_INFO slot_status;
+	unsigned long  DevNodes;
+
+	dbg("%s -->slot_id[ %d:%d ]",__FUNCTION__ , shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Slot Enabled: complete pending slot request
+	//
+	if( slot_context->slot_completion.done ) {
+		dbg("%s -->ENABLE_DONE: slot_id[ %d:%d ]  card_speed_mode[ %d+%d ]  bus_speed_mode[ %d ]",__FUNCTION__ ,
+			shpc_context->shpc_instance, slot_context->slot_number-1,
+			slot_context->card_speed_mode, slot_context->card_pci66_capable,
+			shpc_context->bus_speed_mode );
+		//
+		// Call Completion Callback()
+		//
+		hp_QuerySlotStatus(	shpc_context, slot_context->slot_number - 1, &slot_status );
+		slot_status.x.lu_request_failed = slot_context->slot_completion.failed;
+		shpc_context->async_callback(
+			shpc_context->driver_context,
+			slot_context->slot_number - 1,
+			slot_context->slot_completion.type,
+			slot_status,
+			slot_context->slot_completion.request_context );
+
+		//
+		// Signal registered user EVENT
+		//
+		hp_signal_user_event( shpc_context );
+
+		//
+		// Clear completion flag
+		//
+		slot_context->slot_completion.done = FALSE;
+	}
+
+	//
+	// Clear Button EVENT before waiting
+	//
+	spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+	hp_clear_slot_event_bit(slot_context, ATTN_BUTTON_EVENT);
+	spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+	//
+	// Wait for slot request
+	//
+	shpc_context->shpc_event_bits = 0;slot_context->slot_event_bits = 0;
+
+	wait_event_interruptible(slot_context->slot_event,
+		((slot_context->slot_event_bits & ATTN_BUTTON_EVENT) ||
+		(slot_context->slot_event_bits & SLOT_REQUEST_EVENT) ||
+		(slot_context->slot_event_bits & BUS_REBALANCE_EVENT) ||
+		(slot_context->slot_event_bits & ALERT_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	//
+	// Alert: MRL Opened, Card Removed, Power-Fault?
+	//
+	if(slot_context->slot_event_bits & ALERT_EVENT) {
+		//
+		// Update attn_led_problem_event LED
+		//
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		slot_context->problem_detected = TRUE;
+		hp_send_slot_event(slot_context, ATTN_LED_PROBLEM_EVENT);
+		spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+		//
+		// Notify unrequested removal
+		//
+		slot_context->slot_completion.hw_initiated = TRUE;
+		slot_context->slot_completion.type = SHPC_ASYNC_SURPRISE_REMOVE;
+		slot_context->slot_completion.failed = HP_FALSE;
+		slot_context->slot_completion.request_context = NULL;
+		slot_context->slot_completion.done = TRUE;
+
+		//
+		// Grab Command MUTEX to disable slot
+		//
+		dbg("%s -->ALERT: slot_id[ %d:%d ]  LSR_13:0[ %X ]",__FUNCTION__ ,
+			shpc_context->shpc_instance, slot_context->slot_number-1,
+			readl( slot_context->logical_slot_addr ) & 0x3F );
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_disable_cmd_available;
+	}
+	//
+	// bus_rebalance_event
+	//
+	else if(slot_context->slot_event_bits & BUS_REBALANCE_EVENT) {
+		//
+		// Clear Quiesced EVENT before invoking Callback()
+		//
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		slot_context->quiesce_requests = 0;
+		slot_context->quiesce_replies = 0;
+		slot_context->slot_quiesced = FALSE;
+		hp_clear_slot_event_bit(slot_context, QUIESCE_EVENT);
+		spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+		//
+		// Call Completion Callback() to quiesce DevNode(s)
+		//
+		slot_status.AsDWord = 0;
+		DevNodes = shpc_context->async_callback(
+			shpc_context->driver_context,
+			slot_context->slot_number - 1,
+			SHPC_ASYNC_QUIESCE_DEVNODE_QUIET,
+			slot_status,
+			( void* )(unsigned long)slot_context->slot_psn );
+
+		//
+		// Update request count
+		//
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		slot_context->quiesce_requests = DevNodes;
+		if( slot_context->quiesce_requests == 0 ||
+			slot_context->quiesce_replies >= slot_context->quiesce_requests ) {
+			slot_context->slot_quiesced = TRUE;
+			hp_send_slot_event(slot_context, QUIESCE_EVENT);
+		}
+		spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+		//
+		// Wait for DevNode quiescing
+		//
+		dbg("%s -->BUS_REBALANCE: slot_id[ %d:%d ]",__FUNCTION__ ,
+			shpc_context->shpc_instance, slot_context->slot_number-1 );
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_at_slot_enabled_wait_for_stop_on_bus_rebalance;
+	}
+	//
+	// attn_button_event
+	//
+	else if(slot_context->slot_event_bits & ATTN_BUTTON_EVENT) {
+		//
+		// Set completion info for HW-initiated request
+		//
+		slot_context->slot_completion.hw_initiated = TRUE;
+		slot_context->slot_completion.type = SHPC_ASYNC_DISABLE_SLOT;
+		slot_context->slot_completion.request_context = NULL;
+
+		//
+		// Grab Command MUTEX to blink Power LED
+		//
+		dbg("%s -->DISABLE_REQ: slot_id[ %d:%d ]",__FUNCTION__ ,
+			shpc_context->shpc_instance, slot_context->slot_number-1 );
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_at_slot_enabled_wait_for_led_cmd_available;
+	}
+	//
+	// SlotRequestEvent
+	//
+	else if(slot_context->slot_event_bits & SLOT_REQUEST_EVENT) {
+		//
+		// Set completion info for SW-initiated request
+		//
+		slot_context->slot_completion.hw_initiated = FALSE;
+		slot_context->slot_completion.type = slot_context->slot_request.type;
+		slot_context->slot_completion.request_context = slot_context->slot_request.request_context;
+
+		//
+		// Request to disable slot?
+		//
+		if( slot_context->slot_request.type == SHPC_ASYNC_DISABLE_SLOT ) {
+			//
+			// Grab Command MUTEX to blink Power LED
+			//
+			dbg("%s -->DISABLE_REQ: slot_id[ %d:%d ]",__FUNCTION__ ,
+				shpc_context->shpc_instance, slot_context->slot_number-1 );
+			slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_at_slot_enabled_wait_for_led_cmd_available;
+		}
+		else {
+			//
+			// Slot already enabled, just complete the request
+			//
+			dbg("%s -->ENABLE_REQ: slot_id[ %d:%d ]",__FUNCTION__ ,
+				shpc_context->shpc_instance, slot_context->slot_number-1 );
+			slot_context->slot_completion.failed = HP_FALSE;
+			slot_context->slot_completion.done = TRUE;
+		}
+
+		//
+		// Allow next SW-initiated slot request while processing this one
+		//
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		hp_clear_slot_event_bit(slot_context, SLOT_REQUEST_EVENT);
+		spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+	}
+	//
+	// exit_request_event
+	//
+	else {
+		status = STATUS_UNSUCCESSFUL;
+	}
+
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_at_slot_enabled_wait_for_stop_on_bus_rebalance()
+//
+// ****************************************************************************
+long
+hp_at_slot_enabled_wait_for_stop_on_bus_rebalance(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+)
+{
+	unsigned long		old_irq_flags;
+	long status = STATUS_SUCCESS;
+
+	dbg("%s -->slot_id[ %d:%d ]",__FUNCTION__ , shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Setup our timer
+	//
+	hp_clear_slot_event_bit(slot_context, SLOT_TIMER1_EVENT);
+	slot_context->slot_timer1.data = (unsigned long)slot_context;
+	slot_context->slot_timer1.function = hp_slot_timer1_func;
+	slot_context->slot_timer1.expires = jiffies + QUIESCE_QUIET_TIMEOUT;
+	add_timer(&slot_context->slot_timer1);
+
+	//
+	// Wait for Quiescing EVENT
+	//
+	wait_event_interruptible(slot_context->slot_event,
+		((slot_context->slot_event_bits & QUIESCE_EVENT) ||
+		(slot_context->slot_event_bits & ALERT_EVENT) ||
+		(slot_context->slot_event_bits & SLOT_TIMER1_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	if (!(slot_context->slot_event_bits & SLOT_TIMER1_EVENT)) {
+		//
+		// delete the timer because we got an event other than the timer
+		//
+		del_timer_sync(&slot_context->slot_timer1);
+	}
+
+	//
+	// Alert: MRL Opened, Card Removed, Power-Fault?
+	//
+	if(slot_context->slot_event_bits & ALERT_EVENT) {
+		//
+		// Update attn_led_problem_event LED
+		//
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		slot_context->problem_detected = TRUE;
+		hp_send_slot_event(slot_context, ATTN_LED_PROBLEM_EVENT);
+		spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+		//
+		// Notify unrequested removal
+		//
+		slot_context->slot_completion.hw_initiated = TRUE;
+		slot_context->slot_completion.type = SHPC_ASYNC_SURPRISE_REMOVE;
+		slot_context->slot_completion.failed = HP_FALSE;
+		slot_context->slot_completion.request_context = NULL;
+		slot_context->slot_completion.done = TRUE;
+
+		//
+		// Grab Command MUTEX to disable slot
+		//
+		dbg("%s -->ALERT: slot_id[ %d:%d ]  LSR_13:0[ %X ]",__FUNCTION__ ,
+			shpc_context->shpc_instance, slot_context->slot_number-1,
+			readl( slot_context->logical_slot_addr ) & 0x3F );
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_disable_cmd_available;
+	}
+	//
+	// quiesce_event, timeout
+	//
+	else if((slot_context->slot_event_bits & QUIESCE_EVENT) || (slot_context->slot_event_bits & SLOT_TIMER1_EVENT)) {
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		if((slot_context->slot_event_bits & SLOT_TIMER1_EVENT) || slot_context->slot_quiesced ) {
+			spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+			//
+			// Grab Command MUTEX to set slot at power-only
+			//
+			if((slot_context->slot_event_bits & SLOT_TIMER1_EVENT)) {
+				dbg("%s -->BUS_REBALANCE: slot_id[ %d:%d ] Quiesce timeout",__FUNCTION__ ,
+					shpc_context->shpc_instance, slot_context->slot_number-1 );
+			}
+			else {
+				dbg("%s -->BUS_REBALANCE: slot_id[ %d:%d ] Slot Quiesced",__FUNCTION__ ,
+					shpc_context->shpc_instance, slot_context->slot_number-1 );
+			}
+			slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_at_slot_enabled_wait_for_power_cmd_available;
+		}
+		else {
+			spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+			//
+			// Cancel bus re-balancing and treat it as a "Slot Enabled" request
+			//
+			slot_context->slot_completion.hw_initiated = TRUE;
+			slot_context->slot_completion.type = SHPC_ASYNC_ENABLE_SLOT;
+			slot_context->slot_completion.request_context = NULL;
+			slot_context->slot_completion.failed = HP_FALSE;
+			slot_context->slot_completion.done = TRUE;
+
+			dbg("%s -->BUS_REBALANCE: slot_id[ %d:%d ] Cancelled: BUSY DevNode",__FUNCTION__ ,
+				shpc_context->shpc_instance, slot_context->slot_number-1 );
+			slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_at_slot_enabled_wait_for_slot_request;
+		}
+	}
+	//
+	// exit_request_event
+	//
+	else {
+		status = STATUS_UNSUCCESSFUL;
+	}
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_at_slot_enabled_wait_for_power_cmd_available() 
+//
+// ****************************************************************************
+long
+hp_at_slot_enabled_wait_for_power_cmd_available(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+)
+{
+	struct task_struct;
+	union SHPC_COMMAND_WREG command_reg;
+	unsigned long	old_irq_flags;
+	long status = STATUS_SUCCESS;
+
+	dbg("%s -->slot_id[ %d:%d ]",__FUNCTION__ , shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Wait for Command Available MUTEX
+	//
+	hp_set_slot_event_bit(slot_context, CMD_ACQUIRE_EVENT);
+	wake_up_interruptible(&slot_context->cmd_acquire_event);
+
+	wait_event_interruptible(slot_context->slot_event,
+		((shpc_context->shpc_event_bits & CMD_AVAILABLE_MUTEX_EVENT) ||
+		(slot_context->slot_event_bits & ALERT_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	//
+	// Alert: MRL Opened, Card Removed, Power-Fault?
+	//
+	if(slot_context->slot_event_bits & ALERT_EVENT) {
+		//
+		// Update attn_led_problem_event LED
+		//
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		slot_context->problem_detected = TRUE;
+		hp_send_slot_event(slot_context, ATTN_LED_PROBLEM_EVENT);
+		spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+		//
+		// Release Command MUTEX
+		//
+		hp_set_slot_event_bit(slot_context, CMD_RELEASE_EVENT);
+		wake_up_interruptible(&slot_context->cmd_release_event);
+
+		//
+		// Notify unrequested removal
+		//
+		slot_context->slot_completion.hw_initiated = TRUE;
+		slot_context->slot_completion.type = SHPC_ASYNC_SURPRISE_REMOVE;
+		slot_context->slot_completion.failed = HP_FALSE;
+		slot_context->slot_completion.request_context = NULL;
+		slot_context->slot_completion.done = TRUE;
+
+		//
+		// Grab Command MUTEX to disable slot
+		//
+		dbg("%s -->ALERT: slot_id[ %d:%d ]  LSR_13:0[ %X ]",__FUNCTION__ ,
+			shpc_context->shpc_instance, slot_context->slot_number-1,
+			readl( slot_context->logical_slot_addr ) & 0x3F );
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_disable_cmd_available;
+	}
+	//
+	// cmd_available_mutex
+	//
+	else if(shpc_context->shpc_event_bits & CMD_AVAILABLE_MUTEX_EVENT) {
+		//
+		// Clear Completion EVENT before issuing next command
+		//
+		spin_lock_irqsave( &shpc_context->shpc_spinlock, old_irq_flags );
+		hp_clear_shpc_event_bit(shpc_context, CMD_COMPLETION_EVENT);
+		spin_unlock_irqrestore( &shpc_context->shpc_spinlock, old_irq_flags );
+
+		//
+		// Set slot to "Disable" and blink Power LED
+		//
+		command_reg.Slot.code = SHPC_SLOT_OPERATION;
+		command_reg.Slot.power_led = SHPC_LED_BLINK;
+		command_reg.Slot.attention_led = SHPC_led_NO_CHANGE;
+		command_reg.Slot.state = SHPC_DISABLE_SLOT;
+		command_reg.Slot.TGT = slot_context->slot_number;
+		writew(command_reg.AsWord, shpc_context->mmio_base_addr + SHPC_COMMAND_REG_OFFSET);
+
+		//
+		// Wait for command to complete (while holding MUTEX)
+		//
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_at_slot_enabled_wait_for_power_cmd_completion;
+	}
+	//
+	// exit_request_event
+	//
+	else {
+		//
+		// Release Command MUTEX
+		//
+		hp_set_slot_event_bit(slot_context, CMD_RELEASE_EVENT);
+		wake_up_interruptible(&slot_context->cmd_release_event);
+		status = STATUS_UNSUCCESSFUL;
+	}
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_at_slot_enabled_wait_for_power_cmd_completion()
+//
+// ****************************************************************************
+long
+hp_at_slot_enabled_wait_for_power_cmd_completion(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+)
+{
+	unsigned long		old_irq_flags;
+	long status = STATUS_SUCCESS;
+	union SLOT_STATUS_INFO slot_status;
+	union SHPC_STATUS_WREG status_reg;
+
+	dbg("%s -->slot_id[ %d:%d ]",__FUNCTION__ , shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Setup our timer
+	//
+	hp_clear_slot_event_bit(slot_context, SLOT_TIMER2_EVENT);
+	slot_context->slot_timer2.data = (unsigned long)slot_context;
+	slot_context->slot_timer2.function = hp_slot_timer2_func;
+	slot_context->slot_timer2.expires = jiffies + FIFTEEN_SEC_TIMEOUT;
+	add_timer(&slot_context->slot_timer2);
+
+	//
+	// Wait for Command Completion EVENT while holding MUTEX
+	//
+	wait_event_interruptible(slot_context->slot_event,
+		((shpc_context->shpc_event_bits & CMD_COMPLETION_EVENT) ||
+		(slot_context->slot_event_bits & ALERT_EVENT) ||
+		(slot_context->slot_event_bits & SLOT_TIMER2_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	if (!(slot_context->slot_event_bits & SLOT_TIMER2_EVENT)) {
+		//
+		// delete the timer because we got an event other than the timer
+		//
+		del_timer_sync(&slot_context->slot_timer2);
+	}
+
+	//
+	// Alert: MRL Opened, Card Removed, Power-Fault?
+	//
+	if(slot_context->slot_event_bits & ALERT_EVENT) {
+		//
+		// Update attn_led_problem_event LED
+		//
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		slot_context->problem_detected = TRUE;
+		hp_send_slot_event(slot_context, ATTN_LED_PROBLEM_EVENT);
+		spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+		//
+		// Notify unrequested removal
+		//
+		slot_context->slot_completion.hw_initiated = TRUE;
+		slot_context->slot_completion.type = SHPC_ASYNC_SURPRISE_REMOVE;
+		slot_context->slot_completion.failed = HP_FALSE;
+		slot_context->slot_completion.request_context = NULL;
+		slot_context->slot_completion.done = TRUE;
+
+		//
+		// Grab Command MUTEX to disable slot
+		//
+		dbg("%s -->ALERT: slot_id[ %d:%d ]  LSR_13:0[ %X ]",__FUNCTION__ ,
+			shpc_context->shpc_instance, slot_context->slot_number-1,
+			readl( slot_context->logical_slot_addr ) & 0x3F );
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_disable_cmd_available;
+	}
+	//
+	// cmd_completion_event, timeout
+	//
+		else if((shpc_context->shpc_event_bits & CMD_COMPLETION_EVENT) ||
+				(slot_context->slot_event_bits & SLOT_TIMER2_EVENT)) {
+		//
+		// Command completed OK?
+		//
+		status_reg.AsWord = readw(shpc_context->mmio_base_addr + SHPC_STATUS_REG_OFFSET);
+
+		if( status_reg.x.BSY == SHPC_STATUS_CLEARED &&
+			status_reg.x.MRLO_ERR == SHPC_STATUS_CLEARED &&
+			status_reg.x.INVCMD_ERR == SHPC_STATUS_CLEARED ) {
+			//
+			// Flag this slot as DISABLED
+			//
+			hp_flag_slot_as_disabled( shpc_context, slot_context );
+
+			//
+			// Call Completion Callback(): slot disabled
+			//
+			hp_QuerySlotStatus(	shpc_context, slot_context->slot_number - 1, &slot_status );
+			slot_status.x.lu_request_failed = HP_FALSE;
+			shpc_context->async_callback(
+				shpc_context->driver_context,
+				slot_context->slot_number - 1,
+				SHPC_ASYNC_DISABLE_SLOT,
+				slot_status,
+				NULL );
+
+			//
+			// Signal registered user EVENT
+			//
+			hp_signal_user_event( shpc_context );
+
+			//
+			// Treat it as an on-going ENABLE request
+			//
+			slot_context->slot_completion.hw_initiated = TRUE;
+			slot_context->slot_completion.type = SHPC_ASYNC_ENABLE_SLOT;
+			slot_context->slot_completion.request_context = NULL;
+
+			//
+			// Grab Command MUTEX to power-on the slot
+			//
+			slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_at_slot_disabled_wait_for_power_cmd_available;
+		}
+		else {
+			//
+			// Treat it as a HW-initiated DISABLE request
+			//
+			slot_context->slot_completion.hw_initiated = TRUE;
+			slot_context->slot_completion.type = SHPC_ASYNC_DISABLE_SLOT;
+			slot_context->slot_completion.failed = HP_FALSE;
+			slot_context->slot_completion.request_context = NULL;
+			slot_context->slot_completion.done = TRUE;
+
+			//
+			// Grab Command MUTEX to disable slot
+			//
+			dbg("%s -->CMD_ERROR: slot_id[ %d:%d ]  Cmd[ %X ]",__FUNCTION__ ,
+				shpc_context->shpc_instance, slot_context->slot_number-1, status_reg.AsWord );
+			slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_disable_cmd_available;
+		}
+	}
+	//
+	// exit_request_event
+	//
+	else {
+		status = STATUS_UNSUCCESSFUL;
+	}
+	//
+	// Release Command MUTEX
+	//
+	hp_set_slot_event_bit(slot_context, CMD_RELEASE_EVENT);
+	wake_up_interruptible(&slot_context->cmd_release_event);
+
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_at_slot_enabled_wait_for_led_cmd_available()
+//
+// ****************************************************************************
+long
+hp_at_slot_enabled_wait_for_led_cmd_available(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+)
+{
+	unsigned long		old_irq_flags;
+	long status = STATUS_SUCCESS;
+	union SHPC_COMMAND_WREG command_reg;
+
+	dbg("%s -->slot_id[ %d:%d ]",__FUNCTION__ , shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Wait for Command Available MUTEX
+	//
+	hp_set_slot_event_bit(slot_context, CMD_RELEASE_EVENT);
+	wake_up_interruptible(&slot_context->cmd_acquire_event);
+
+	wait_event_interruptible(slot_context->slot_event,
+		((shpc_context->shpc_event_bits & CMD_AVAILABLE_MUTEX_EVENT) ||
+		(slot_context->slot_event_bits & ALERT_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	//
+	// Alert: MRL Opened, Card Removed, Power-Fault?
+	//
+	if(slot_context->slot_event_bits & ALERT_EVENT) {
+		//
+		// Update attn_led_problem_event LED
+		//
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		slot_context->problem_detected = TRUE;
+		hp_send_slot_event(slot_context, ATTN_LED_PROBLEM_EVENT);
+		spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+		//
+		// Release Command MUTEX
+		//
+		hp_set_slot_event_bit(slot_context, CMD_RELEASE_EVENT);
+		wake_up_interruptible(&slot_context->cmd_release_event);
+
+		//
+		// Fail on-going request
+		//
+		slot_context->slot_completion.failed = HP_TRUE;
+		slot_context->slot_completion.done = TRUE;
+
+		//
+		// Grab Command MUTEX to disable slot
+		//
+		dbg("%s -->ALERT: slot_id[ %d:%d ]  LSR_13:0[ %X ]",__FUNCTION__ ,
+			shpc_context->shpc_instance, slot_context->slot_number-1,
+			readl( slot_context->logical_slot_addr ) & 0x3F );
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_disable_cmd_available;
+	}
+	//
+	// cmd_available_mutex
+	//
+	else if(shpc_context->shpc_event_bits & CMD_AVAILABLE_MUTEX_EVENT) {
+		//
+		// Clear Completion EVENT before issuing next command
+		//
+		spin_lock_irqsave( &shpc_context->shpc_spinlock, old_irq_flags );
+		hp_clear_shpc_event_bit(shpc_context, CMD_COMPLETION_EVENT);
+		spin_unlock_irqrestore( &shpc_context->shpc_spinlock, old_irq_flags );
+
+		//
+		// Blink Power LED
+		//
+		command_reg.Slot.code = SHPC_SLOT_OPERATION;
+		command_reg.Slot.power_led = SHPC_LED_BLINK;
+		command_reg.Slot.attention_led = SHPC_led_NO_CHANGE;
+		command_reg.Slot.state = SHPC_SLOT_NO_CHANGE;
+		command_reg.Slot.TGT = slot_context->slot_number;
+		writew(command_reg.AsWord, shpc_context->mmio_base_addr + SHPC_COMMAND_REG_OFFSET);
+
+		//
+		// Wait for command to complete (while holding MUTEX)
+		//
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_at_slot_enabled_wait_for_led_cmd_completion;
+	}
+	//
+	// exit_request_event
+	//
+	else {
+		//
+		// Release Command MUTEX
+		//
+		hp_set_slot_event_bit(slot_context, CMD_RELEASE_EVENT);
+		wake_up_interruptible(&slot_context->cmd_release_event);
+		status =STATUS_UNSUCCESSFUL;
+	}
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_at_slot_enabled_wait_for_led_cmd_completion()
+//
+// ****************************************************************************
+long
+hp_at_slot_enabled_wait_for_led_cmd_completion(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+)
+{
+	unsigned long		old_irq_flags;
+	long status = STATUS_SUCCESS;
+	union SLOT_STATUS_INFO slot_status;
+	union SHPC_STATUS_WREG status_reg;
+	unsigned long  DevNodes;
+
+	dbg("%s -->slot_id[ %d:%d ]",__FUNCTION__ , shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Setup our timer
+	//
+	hp_clear_slot_event_bit(slot_context, SLOT_TIMER3_EVENT);
+	slot_context->slot_timer3.data = (unsigned long)slot_context;
+	slot_context->slot_timer3.function = hp_slot_timer3_func;
+	slot_context->slot_timer3.expires = jiffies + ONE_SEC_TIMEOUT;
+	add_timer(&slot_context->slot_timer3);
+
+	//
+	// Wait for Command Completion EVENT while holding MUTEX
+	//
+	wait_event_interruptible(slot_context->slot_event,
+		((shpc_context->shpc_event_bits & CMD_COMPLETION_EVENT) ||
+		 (slot_context->slot_event_bits & ALERT_EVENT) ||
+		 (slot_context->slot_event_bits & SLOT_TIMER3_EVENT) ||
+		 (shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	if (!(slot_context->slot_event_bits & SLOT_TIMER3_EVENT)) {
+		//
+		// delete the timer because we got an event other than the timer
+		//
+		del_timer_sync(&slot_context->slot_timer3);
+	}
+	dbg("%s -->slot bits %08X   shpc bits  %08X",__FUNCTION__ ,
+		slot_context->slot_event_bits,shpc_context->shpc_event_bits);
+
+	//
+	// Alert: MRL Opened, Card Removed, Power-Fault?
+	//
+	if(slot_context->slot_event_bits & ALERT_EVENT) {
+		//
+		// Update attn_led_problem_event LED
+		//
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		slot_context->problem_detected = TRUE;
+		hp_send_slot_event(slot_context, ATTN_LED_PROBLEM_EVENT);
+		spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+		//
+		// Fail on-going request
+		//
+		slot_context->slot_completion.failed = HP_TRUE;
+		slot_context->slot_completion.done = TRUE;
+
+		//
+		// Grab Command MUTEX to disable slot
+		//
+		dbg("%s -->ALERT: slot_id[ %d:%d ]  LSR_13:0[ %X ]",__FUNCTION__ ,
+			shpc_context->shpc_instance, slot_context->slot_number-1,
+			readl( slot_context->logical_slot_addr ) & 0x3F );
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_disable_cmd_available;
+	}
+	//
+	// cmd_completion_event, timeout
+	//
+	else if((shpc_context->shpc_event_bits & CMD_COMPLETION_EVENT) ||
+			(slot_context->slot_event_bits & SLOT_TIMER3_EVENT)) {
+		//
+		// Command completed OK?
+		//
+		status_reg.AsWord = readw(shpc_context->mmio_base_addr + SHPC_STATUS_REG_OFFSET);
+
+		if( status_reg.x.BSY == SHPC_STATUS_CLEARED &&
+			status_reg.x.MRLO_ERR == SHPC_STATUS_CLEARED &&
+			status_reg.x.INVCMD_ERR == SHPC_STATUS_CLEARED ) {
+			//
+			// Allow cancellation of operation?
+			//
+			if( slot_context->slot_completion.hw_initiated ) {
+				//
+				// Wait for 5 sec timeout
+				//
+				slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_at_slot_enabled_wait_for_timeout;
+			}
+			else {
+				//
+				// Clear Quiesced EVENT before invoking Callback()
+				//
+				spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+				slot_context->quiesce_requests = 0;
+				slot_context->quiesce_replies = 0;
+				slot_context->slot_quiesced = FALSE;
+				hp_clear_slot_event_bit(slot_context, QUIESCE_EVENT);
+				spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+				//
+				// Call Completion Callback() to quiesce DevNode(s)
+				//
+				slot_status.AsDWord = 0;
+				DevNodes = shpc_context->async_callback(
+					shpc_context->driver_context,
+					slot_context->slot_number - 1,
+					SHPC_ASYNC_QUIESCE_DEVNODE,
+					slot_status,
+					( void* )(unsigned long)slot_context->slot_psn );
+
+				//
+				// Update request count
+				//
+				spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+				slot_context->quiesce_requests = DevNodes;
+				if( slot_context->quiesce_requests == 0 ||
+					slot_context->quiesce_replies >= slot_context->quiesce_requests ) {
+					slot_context->slot_quiesced = TRUE;
+					hp_send_slot_event(slot_context, QUIESCE_EVENT);
+				}
+				spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+				//
+				// Wait for DevNode quiescing
+				//
+				slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_at_slot_enabled_wait_for_stop_on_slot_disable;
+			}
+		}
+		else {
+			//
+			// Fail on-going request
+			//
+			slot_context->slot_completion.failed = HP_TRUE;
+			slot_context->slot_completion.done = TRUE;
+
+			//
+			// Grab Command MUTEX to disable slot
+			//
+			dbg("%s -->CMD_ERROR: slot_id[ %d:%d ]  Cmd[ %X ]",__FUNCTION__ ,
+				shpc_context->shpc_instance, slot_context->slot_number-1, status_reg.AsWord );
+			slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_disable_cmd_available;
+		}
+	}
+	//
+	// exit_request_event
+	//
+	else {
+		status = STATUS_UNSUCCESSFUL;
+	}
+	//
+	// Release Command MUTEX
+	//
+	hp_set_slot_event_bit(slot_context, CMD_RELEASE_EVENT);
+	wake_up_interruptible(&slot_context->cmd_release_event);
+
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_at_slot_enabled_wait_for_timeout()
+//
+// ****************************************************************************
+long
+hp_at_slot_enabled_wait_for_timeout(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+)
+{
+	unsigned long		old_irq_flags;
+	long status = STATUS_SUCCESS;
+	union SLOT_STATUS_INFO slot_status;
+	unsigned long  DevNodes;
+
+	dbg("%s -->slot_id[ %d:%d ]",__FUNCTION__ , shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Clear Button EVENT before waiting
+	//
+	spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+	down_interruptible(&slot_context->slot_event_bits_semaphore);
+	slot_context->slot_event_bits &= ~ATTN_BUTTON_EVENT;
+	up(&slot_context->slot_event_bits_semaphore);
+	spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+	//
+	// Setup our timer
+	//
+	hp_clear_slot_event_bit(slot_context, SLOT_TIMER7_EVENT);
+	slot_context->slot_timer7.data = (unsigned long)slot_context;
+	slot_context->slot_timer7.function = hp_slot_timer7_func;
+	slot_context->slot_timer7.expires = jiffies + FIVE_SEC_TIMEOUT;
+	add_timer(&slot_context->slot_timer7);
+
+	//
+	// Wait for 5 sec timeout
+	//
+	wait_event_interruptible(slot_context->slot_event,
+		((slot_context->slot_event_bits & ATTN_BUTTON_EVENT) ||
+		(slot_context->slot_event_bits & ALERT_EVENT) ||
+		(slot_context->slot_event_bits & SLOT_TIMER7_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	if (!(slot_context->slot_event_bits & SLOT_TIMER7_EVENT)) {
+		//
+		// delete the timer because we got an event other than the timer
+		//
+		del_timer_sync(&slot_context->slot_timer7);
+	}
+
+	//
+	// Alert: MRL Opened, Card Removed, Power-Fault?
+	//
+	if(slot_context->slot_event_bits & ALERT_EVENT) {
+		//
+		// Update attn_led_problem_event LED
+		//
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		slot_context->problem_detected = TRUE;
+		hp_send_slot_event(slot_context, ATTN_LED_PROBLEM_EVENT);
+		spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+		//
+		// Fail on-going request
+		//
+		slot_context->slot_completion.failed = HP_TRUE;
+		slot_context->slot_completion.done = TRUE;
+
+		//
+		// Grab Command MUTEX to disable slot
+		//
+		dbg("%s -->ALERT: slot_id[ %d:%d ]  LSR_13:0[ %X ]",__FUNCTION__ ,
+			shpc_context->shpc_instance, slot_context->slot_number-1,
+			readl( slot_context->logical_slot_addr ) & 0x3F );
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_disable_cmd_available;
+	}
+	//
+	// attn_button_event
+	//
+	else if(slot_context->slot_event_bits & ATTN_BUTTON_EVENT) {
+		//
+		// Cancel request, grab Command MUTEX to Power LED back ON
+		//
+		dbg("%s -->DISABLE_REQ: slot_id[ %d:%d ] Cancelled: Attn Button",__FUNCTION__ ,
+			shpc_context->shpc_instance, slot_context->slot_number-1 );
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_enabled_wait_for_led_cmd_available;
+	}
+	//
+	// timeout
+	//
+	else if(slot_context->slot_event_bits & SLOT_TIMER7_EVENT) {
+		//
+		// Clear Quiesced EVENT before invoking Callback()
+		//
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		slot_context->quiesce_requests = 0;
+		slot_context->quiesce_replies = 0;
+		slot_context->slot_quiesced = FALSE;
+		hp_clear_slot_event_bit(slot_context, QUIESCE_EVENT);
+		spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+		//
+		// Call Completion Callback() to quiesce DevNode(s)
+		//
+		slot_status.AsDWord = 0;
+		DevNodes = shpc_context->async_callback(
+			shpc_context->driver_context,
+			slot_context->slot_number - 1,
+			SHPC_ASYNC_QUIESCE_DEVNODE,
+			slot_status,
+			( void* )(unsigned long)slot_context->slot_psn );
+
+		//
+		// Update request count
+		//
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		slot_context->quiesce_requests = DevNodes;
+		if( slot_context->quiesce_requests == 0 ||
+			slot_context->quiesce_replies == slot_context->quiesce_requests ) {
+			slot_context->slot_quiesced = TRUE;
+			hp_send_slot_event(slot_context, QUIESCE_EVENT);
+		}
+		spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+		//
+		// Wait for DevNode quiescing
+		//
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_at_slot_enabled_wait_for_stop_on_slot_disable;
+	}
+	//
+	// exit_request_event
+	//
+	else {
+		status = STATUS_UNSUCCESSFUL;
+	}
+
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_at_slot_enabled_wait_for_stop_on_slot_disable()
+//
+// ****************************************************************************
+long
+hp_at_slot_enabled_wait_for_stop_on_slot_disable(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+)
+{
+	unsigned long		old_irq_flags;
+	long status = STATUS_SUCCESS;
+	union SLOT_STATUS_INFO slot_status;
+	unsigned long  DevNodes;
+
+	dbg("%s -->slot_id[ %d:%d ]", __FUNCTION__ ,shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Setup our timer
+	//
+	hp_clear_slot_event_bit(slot_context, SLOT_TIMER4_EVENT);
+	slot_context->slot_timer4.data = (unsigned long)slot_context;
+	slot_context->slot_timer4.function = hp_slot_timer4_func;
+	slot_context->slot_timer4.expires = jiffies + QUIESCE_QUIET_TIMEOUT;
+	add_timer(&slot_context->slot_timer4);
+
+	//
+	// Wait for Quiescing EVENT
+	//
+	wait_event_interruptible(slot_context->slot_event,
+		((slot_context->slot_event_bits & QUIESCE_EVENT) ||
+		(slot_context->slot_event_bits & ALERT_EVENT) ||
+		(slot_context->slot_event_bits & SLOT_TIMER4_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	if (!(slot_context->slot_event_bits & SLOT_TIMER4_EVENT)) {
+	//
+	// delete the timer because we got an event other than the timer
+	//
+		del_timer_sync(&slot_context->slot_timer4);
+	}
+
+	//
+	// Alert: MRL Opened, Card Removed, Power-Fault?
+	//
+	if(slot_context->slot_event_bits & ALERT_EVENT) {
+		//
+		// Update attn_led_problem_event LED
+		//
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		slot_context->problem_detected = TRUE;
+		hp_send_slot_event(slot_context, ATTN_LED_PROBLEM_EVENT);
+		spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+		//
+		// Fail on-going request
+		//
+		slot_context->slot_completion.failed = HP_TRUE;
+		slot_context->slot_completion.done = TRUE;
+
+		//
+		// Grab Command MUTEX to disable slot
+		//
+		dbg("%s -->ALERT: slot_id[ %d:%d ]  LSR_13:0[ %X ]",__FUNCTION__ ,
+			shpc_context->shpc_instance, slot_context->slot_number-1,
+			readl( slot_context->logical_slot_addr ) & 0x3F );
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_disable_cmd_available;
+	}
+	//
+	// quiesce_event
+	//
+	else if(slot_context->slot_event_bits & QUIESCE_EVENT) {
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		if( slot_context->slot_quiesced ) {
+			spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+			//
+			// Complete succesful DISABLE request
+			//
+			slot_context->slot_completion.failed = HP_FALSE;
+			slot_context->slot_completion.done = TRUE;
+
+			//
+			// Grab Command MUTEX to disable slot
+			//
+			//
+			dbg("%s -->DISABLE_REQ: slot_id[ %d:%d ] Slot Quiesced",__FUNCTION__ ,
+				shpc_context->shpc_instance, slot_context->slot_number-1 );
+			slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_disable_cmd_available;
+		}
+		else {
+			spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+			//
+			// Cancel request, grab Command MUTEX to turn Power LED back ON
+			//
+			slot_context->slot_completion.hw_initiated = TRUE;
+			slot_context->slot_completion.type = SHPC_ASYNC_ENABLE_SLOT;
+			slot_context->slot_completion.request_context = NULL;
+			slot_context->slot_completion.failed = HP_FALSE;
+			slot_context->slot_completion.done = TRUE;
+
+			dbg("%s -->DISABLE_REQ: slot_id[ %d:%d ] Cancelled: BUSY DevNode",__FUNCTION__ ,
+				shpc_context->shpc_instance, slot_context->slot_number-1 );
+			slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_enabled_wait_for_led_cmd_available;
+		}
+	}
+	//
+	// timeout
+	//
+	else if(slot_context->slot_event_bits & SLOT_TIMER4_EVENT) {
+		//
+		// Clear Quiesced EVENT before invoking Callback()
+		//
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		slot_context->quiesce_requests = 0;
+		slot_context->quiesce_replies = 0;
+		slot_context->slot_quiesced = FALSE;
+		hp_clear_slot_event_bit(slot_context, QUIESCE_EVENT);
+		spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+		//
+		// Call Completion Callback() to quiesce DevNode(s)
+		//
+		slot_status.AsDWord = 0;
+		DevNodes = shpc_context->async_callback(
+			shpc_context->driver_context,
+			slot_context->slot_number - 1,
+			SHPC_ASYNC_QUIESCE_DEVNODE_QUIET,
+			slot_status,
+			( void* )(unsigned long)slot_context->slot_psn );
+
+		//
+		// Update request count
+		//
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		slot_context->quiesce_requests = DevNodes;
+		if( slot_context->quiesce_requests == 0 ||
+			slot_context->quiesce_replies == slot_context->quiesce_requests ) {
+			slot_context->slot_quiesced = TRUE;
+			hp_send_slot_event(slot_context, QUIESCE_EVENT);
+		}
+		spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+		//
+		// Wait for DevNode quiescing
+		//
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_at_slot_enabled_wait_for_stop_on_slot_disable_quiet;
+	}
+	//
+	// exit_request_event
+	//
+	else {
+		status = STATUS_UNSUCCESSFUL;
+	}
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_at_slot_enabled_wait_for_stop_on_slot_disable_quiet()
+//
+// ****************************************************************************
+long
+hp_at_slot_enabled_wait_for_stop_on_slot_disable_quiet(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+)
+{
+	unsigned long		old_irq_flags;
+	long status = STATUS_SUCCESS;
+
+	dbg("%s -->slot_id[ %d:%d ]", __FUNCTION__ ,shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Setup our timer
+	//
+	hp_clear_slot_event_bit(slot_context, SLOT_TIMER5_EVENT);
+	slot_context->slot_timer5.data = (unsigned long)slot_context;
+	slot_context->slot_timer5.function = hp_slot_timer5_func;
+	slot_context->slot_timer5.expires = jiffies + QUIESCE_QUIET_TIMEOUT;
+	add_timer(&slot_context->slot_timer5);
+
+	//
+	// Wait for Quiescing EVENT
+	//
+	wait_event_interruptible(slot_context->slot_event,
+		((slot_context->slot_event_bits & QUIESCE_EVENT) ||
+		(slot_context->slot_event_bits & ALERT_EVENT) ||
+		(slot_context->slot_event_bits & SLOT_TIMER5_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	if (!(slot_context->slot_event_bits & SLOT_TIMER5_EVENT)) {
+		//
+		// delete the timer because we got an event other than the timer
+		//
+		del_timer_sync(&slot_context->slot_timer5);
+	}
+
+	//
+	// Alert: MRL Opened, Card Removed, Power-Fault?
+	//
+	if(slot_context->slot_event_bits & ALERT_EVENT) {
+		//
+		// Update attn_led_problem_event LED
+		//
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		slot_context->problem_detected = TRUE;
+		hp_send_slot_event(slot_context, ATTN_LED_PROBLEM_EVENT);
+		spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+		//
+		// Fail on-going request
+		//
+		slot_context->slot_completion.failed = HP_TRUE;
+		slot_context->slot_completion.done = TRUE;
+
+		//
+		// Grab Command MUTEX to disable slot
+		//
+		dbg("%s -->ALERT: slot_id[ %d:%d ]  LSR_13:0[ %X ]",__FUNCTION__ ,
+			shpc_context->shpc_instance, slot_context->slot_number-1,
+			readl( slot_context->logical_slot_addr ) & 0x3F );
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_disable_cmd_available;
+	}
+	//
+	// quiesce_event, timeout
+	//
+	else if((slot_context->slot_event_bits & QUIESCE_EVENT) ||
+			(slot_context->slot_event_bits & SLOT_TIMER5_EVENT)) {
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		if((slot_context->slot_event_bits & SLOT_TIMER5_EVENT) || slot_context->slot_quiesced ) {
+			spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+			//
+			// Complete succesful DISABLE request
+			//
+			slot_context->slot_completion.failed = HP_FALSE;
+			slot_context->slot_completion.done = TRUE;
+
+			//
+			// Grab Command MUTEX to disable slot
+			//
+			//
+			if(slot_context->slot_event_bits & SLOT_TIMER5_EVENT) {
+				dbg("%s -->DISABLE_REQ: slot_id[ %d:%d ] Quiesce timeout",__FUNCTION__ ,
+					shpc_context->shpc_instance, slot_context->slot_number-1 );
+			}
+			else {
+				dbg("%s -->DISABLE_REQ: slot_id[ %d:%d ] Slot Quiesced",__FUNCTION__ ,
+					shpc_context->shpc_instance, slot_context->slot_number-1 );
+			}
+			slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_disable_cmd_available;
+		}
+		else {
+			spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+			//
+			// Cancel request, grab Command MUTEX to turn Power LED back ON
+			//
+			dbg("%s -->DISABLE_REQ: slot_id[ %d:%d ] Cancelled: BUSY DevNode",__FUNCTION__ ,
+				shpc_context->shpc_instance, slot_context->slot_number-1 );
+			slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_enabled_wait_for_led_cmd_available;
+		}
+	}
+	//
+	// exit_request_event
+	//
+	else {
+		status = STATUS_UNSUCCESSFUL;
+	}
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_to_slot_enabled_wait_for_led_cmd_available()
+//
+// ****************************************************************************
+long
+hp_to_slot_enabled_wait_for_led_cmd_available(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+)
+{
+	unsigned long		old_irq_flags;
+	long status = STATUS_SUCCESS;
+	union SHPC_COMMAND_WREG command_reg;
+
+	dbg("%s -->slot_id[ %d:%d ]", __FUNCTION__ ,shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Wait for Command Available MUTEX
+	//
+	hp_set_slot_event_bit(slot_context, CMD_ACQUIRE_EVENT);
+	wake_up_interruptible(&slot_context->cmd_acquire_event);
+
+	wait_event_interruptible(slot_context->slot_event,
+		((shpc_context->shpc_event_bits & CMD_AVAILABLE_MUTEX_EVENT) ||
+		(slot_context->slot_event_bits & ALERT_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	//
+	// Alert: MRL Opened, Card Removed, Power-Fault?
+	//
+	if(slot_context->slot_event_bits & ALERT_EVENT) {
+		//
+		// Update attn_led_problem_event LED
+		//
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		slot_context->problem_detected = TRUE;
+		hp_send_slot_event(slot_context, ATTN_LED_PROBLEM_EVENT);
+		spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+		//
+		// Release Command MUTEX
+		//
+		hp_set_slot_event_bit(slot_context, CMD_RELEASE_EVENT);
+		wake_up_interruptible(&slot_context->cmd_release_event);
+
+		//
+		// Fail on-going request
+		//
+		slot_context->slot_completion.failed = HP_TRUE;
+		slot_context->slot_completion.done = TRUE;
+
+		//
+		// Grab Command MUTEX to disable slot
+		//
+		dbg("%s -->ALERT: slot_id[ %d:%d ]  LSR_13:0[ %X ]",__FUNCTION__ ,
+			shpc_context->shpc_instance, slot_context->slot_number-1,
+			readl( slot_context->logical_slot_addr ) & 0x3F );
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_disable_cmd_available;
+	}
+	//
+	// cmd_available_mutex
+	//
+	else if(shpc_context->shpc_event_bits & CMD_AVAILABLE_MUTEX_EVENT) {
+		//
+		// Clear Completion EVENT before issuing next command
+		//
+		spin_lock_irqsave( &shpc_context->shpc_spinlock, old_irq_flags );
+		hp_clear_shpc_event_bit(shpc_context, CMD_COMPLETION_EVENT);
+		spin_unlock_irqrestore( &shpc_context->shpc_spinlock, old_irq_flags );
+
+		//
+		// Turn Power LED back ON
+		//
+		command_reg.Slot.code = SHPC_SLOT_OPERATION;
+		command_reg.Slot.power_led = SHPC_LED_ON;
+		command_reg.Slot.attention_led = SHPC_led_NO_CHANGE;
+		command_reg.Slot.state = SHPC_SLOT_NO_CHANGE;
+		command_reg.Slot.TGT = slot_context->slot_number;
+		writew(command_reg.AsWord, shpc_context->mmio_base_addr + SHPC_COMMAND_REG_OFFSET);
+
+		//
+		// Wait for command to complete (while holding MUTEX)
+		//
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_enabled_wait_for_led_cmd_completion;
+	}
+	//
+	// exit_request_event
+	//
+	else {
+		//
+		// Release Command MUTEX
+		//
+		hp_set_slot_event_bit(slot_context, CMD_RELEASE_EVENT);
+		wake_up_interruptible(&slot_context->cmd_release_event);
+		status = STATUS_UNSUCCESSFUL;
+	}
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_to_slot_enabled_wait_for_led_cmd_completion()
+//
+// ****************************************************************************
+long
+hp_to_slot_enabled_wait_for_led_cmd_completion(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+)
+{
+	unsigned long		old_irq_flags;
+	long status = STATUS_SUCCESS;
+	union SHPC_STATUS_WREG status_reg;
+
+	dbg("%s -->slot_id[ %d:%d ]",__FUNCTION__ , (int)shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Setup our timer
+	//
+	hp_clear_slot_event_bit(slot_context, SLOT_TIMER6_EVENT);
+	slot_context->slot_timer6.data = (unsigned long)slot_context;
+	slot_context->slot_timer6.function = hp_slot_timer6_func;
+	slot_context->slot_timer6.expires = jiffies + ONE_SEC_TIMEOUT;
+	add_timer(&slot_context->slot_timer6);
+
+	//
+	// Wait for Command Completion EVENT while holding MUTEX
+	//
+	wait_event_interruptible(slot_context->slot_event,
+		((shpc_context->shpc_event_bits & CMD_COMPLETION_EVENT) ||
+		(slot_context->slot_event_bits & ALERT_EVENT) ||
+		(slot_context->slot_event_bits & SLOT_TIMER6_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	if (!(slot_context->slot_event_bits & SLOT_TIMER6_EVENT)) {
+	//
+	// delete the timer because we got an event other than the timer
+	//
+		del_timer_sync(&slot_context->slot_timer6);
+	}
+
+	//
+	// Alert: MRL Opened, Card Removed, Power-Fault?
+	//
+	if(slot_context->slot_event_bits & ALERT_EVENT) {
+		//
+		// Update attn_led_problem_event LED
+		//
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		slot_context->problem_detected = TRUE;
+		hp_send_slot_event(slot_context, ATTN_LED_PROBLEM_EVENT);
+		spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+		//
+		// Fail on-going request
+		//
+		slot_context->slot_completion.failed = HP_TRUE;
+		slot_context->slot_completion.done = TRUE;
+
+		//
+		// Grab Command MUTEX to disable slot
+		//
+		dbg("%s -->ALERT: slot_id[ %d:%d ]  LSR_13:0[ %X ]",__FUNCTION__ ,
+			shpc_context->shpc_instance, slot_context->slot_number-1,
+			readl( slot_context->logical_slot_addr ) & 0x3F );
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_disable_cmd_available;
+	}
+	//
+	// cmd_completion_event, timeout
+	//
+		else if((shpc_context->shpc_event_bits & CMD_COMPLETION_EVENT) ||
+				(slot_context->slot_event_bits & SLOT_TIMER6_EVENT)) {
+		//
+		// Command completed OK?
+		//
+		status_reg.AsWord = readw(shpc_context->mmio_base_addr + SHPC_STATUS_REG_OFFSET);
+
+		if( status_reg.x.BSY == SHPC_STATUS_CLEARED &&
+			status_reg.x.MRLO_ERR == SHPC_STATUS_CLEARED &&
+			status_reg.x.INVCMD_ERR == SHPC_STATUS_CLEARED ) {
+			//
+			// Wait for next request
+			//
+			slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_at_slot_enabled_wait_for_slot_request;
+		}
+		else {
+			//
+			// Fail on-going request
+			//
+			slot_context->slot_completion.failed = HP_TRUE;
+			slot_context->slot_completion.done = TRUE;
+
+			//
+			// Grab Command MUTEX to disable slot
+			//
+			dbg("%s -->CMD_ERROR: slot_id[ %d:%d ]  Cmd[ %X ]",__FUNCTION__ ,
+				shpc_context->shpc_instance, slot_context->slot_number-1, status_reg.AsWord );
+			slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_disable_cmd_available;
+		}
+	}
+	//
+	// exit_request_event
+	//
+	else {
+		status = STATUS_UNSUCCESSFUL;
+	}
+	//
+	// Release Command MUTEX
+	//
+	hp_set_slot_event_bit(slot_context, CMD_RELEASE_EVENT);
+	wake_up_interruptible(&slot_context->cmd_release_event);
+
+	return status;
+}
+
diff -purN linux-2.5/drivers/pci/hotplug/amdshpc_enb.c usb-2.5/drivers/pci/hotplug/amdshpc_enb.c
--- linux-2.5/drivers/pci/hotplug/amdshpc_enb.c	1970-01-01 00:00:00.000000000 +0000
+++ usb-2.5/drivers/pci/hotplug/amdshpc_enb.c	2003-08-28 23:06:29.000000000 +0000
@@ -0,0 +1,2112 @@
+/*
+ * Copyright (C) 2001,2003 Greg Kroah-Hartman (greg@kroah.com)
+ * Copyright (C) 2001,2003 IBM Corp.
+ * Copyright (C) 2002-2003 Advanced Micro Devices
+ *
+ * YOUR USE OF THIS CODE IS SUBJECT TO THE TERMS
+ * AND CONDITIONS OF THE GNU GENERAL PUBLIC
+ * LICENSE FOUND IN THE "GPL.TXT" FILE THAT IS
+ * INCLUDED WITH THIS FILE AND POSTED AT
+ * http://www.gnu.org/licenses/gpl.html
+ *
+ * Send feedback to <david.keck@amd.com>
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/sched.h>
+#include "amdshpc_ddi.h"
+#include "amdshpc.h"
+
+
+// ****************************************************************************
+//
+// hp_at_slot_disabled_wait_for_slot_request()
+//
+// ****************************************************************************
+long
+hp_at_slot_disabled_wait_for_slot_request(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+	)
+{
+	unsigned long		old_irq_flags;
+	long status = STATUS_SUCCESS;
+	union SLOT_STATUS_INFO slot_status;
+	union SHPC_LOGICAL_SLOT_DWREG logical_slot_reg;
+
+	dbg("%s -->slot_id[ %d:%d ]", __FUNCTION__ ,shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Slot Disabled: complete pending slot request
+	//
+	if( slot_context->slot_completion.done ) {
+		dbg("%s -->DISABLE_DONE: slot_id[ %d:%d ]",__FUNCTION__ ,
+			shpc_context->shpc_instance, slot_context->slot_number-1 );
+		//
+		// Call Completion Callback()
+		//
+		hp_QuerySlotStatus(	shpc_context, slot_context->slot_number - 1, &slot_status );
+		slot_status.x.lu_request_failed = slot_context->slot_completion.failed;
+		shpc_context->async_callback(
+			shpc_context->driver_context,
+			slot_context->slot_number - 1,
+			slot_context->slot_completion.type,
+			slot_status,
+			slot_context->slot_completion.request_context );
+
+		//
+		// Signal registered user EVENT
+		//
+		hp_signal_user_event( shpc_context );
+
+		//
+		// Clear completion flag
+		//
+		slot_context->slot_completion.done = FALSE;
+	}
+
+	//
+	// Clear Button EVENT before waiting
+	//
+	spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+	hp_clear_slot_event_bit(slot_context, ATTN_BUTTON_EVENT);
+	spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+	//
+	// Wait for slot request
+	//
+	wait_event_interruptible(slot_context->slot_event,
+		((slot_context->slot_event_bits & ATTN_BUTTON_EVENT) ||
+		(slot_context->slot_event_bits & SLOT_REQUEST_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	//
+	// attn_button_event
+	//
+	if(slot_context->slot_event_bits & ATTN_BUTTON_EVENT) {
+		//
+		// Set completion info for HW-initiated request
+		//
+		slot_context->slot_completion.hw_initiated = TRUE;
+		slot_context->slot_completion.type = SHPC_ASYNC_ENABLE_SLOT;
+		slot_context->slot_completion.request_context = NULL;
+
+		//
+		// Get current HW disposition
+		//
+		logical_slot_reg.AsDWord = readl( slot_context->logical_slot_addr );
+		//
+		// Card present, MRL closed, and no Power-Fault?
+		//
+		if( logical_slot_reg.x.PRSNT1_2 != SHPC_SLOT_EMPTY &&
+			( logical_slot_reg.x.MRLS_IM == SHPC_MASKED ||
+			logical_slot_reg.x.MRLS == SHPC_MRL_CLOSED ) &&
+			logical_slot_reg.x.PF == SHPC_STATUS_CLEARED ) {
+			//
+			// Clear Alert EVENT and Attention LED
+			//
+			spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+			hp_clear_slot_event_bit(slot_context, ALERT_EVENT);
+			slot_context->problem_detected = FALSE;
+			hp_send_slot_event(slot_context, ATTN_LED_PROBLEM_EVENT);
+			spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+			//
+			// Grab Command MUTEX to blink Power LED
+			//
+			dbg("%s -->ENABLE_REQ: slot_id[ %d:%d ]",__FUNCTION__ ,
+				shpc_context->shpc_instance, slot_context->slot_number-1 );
+			slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_at_slot_disabled_wait_for_led_cmd_available;
+		}
+		//
+		// Alert: MRL Opened, Power-Fault?
+		//
+		else if( logical_slot_reg.x.PRSNT1_2 != SHPC_SLOT_EMPTY ) {
+			//
+			// Update Attention LED
+			//
+			spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+			slot_context->problem_detected = TRUE;
+			hp_send_slot_event(slot_context, ATTN_LED_PROBLEM_EVENT);
+			spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+			//
+			// Fail on-going request
+			//
+			slot_context->slot_completion.failed = HP_TRUE;
+			slot_context->slot_completion.done = TRUE;
+			dbg("%s -->ALERT: slot_id[ %d:%d ]  LSR_13:0[ %X ]",__FUNCTION__ ,
+				shpc_context->shpc_instance, slot_context->slot_number-1,
+				logical_slot_reg.AsDWord & 0x3F );
+		}
+	}
+	//
+	// SlotRequestEvent
+	//
+	else if(slot_context->slot_event_bits & SLOT_REQUEST_EVENT) {
+		//
+		// Set completion info for SW-initiated request
+		//
+		slot_context->slot_completion.hw_initiated = FALSE;
+		slot_context->slot_completion.type = slot_context->slot_request.type;
+		slot_context->slot_completion.request_context = slot_context->slot_request.request_context;
+
+		//
+		// Request to enable slot?
+		//
+		if( slot_context->slot_request.type == SHPC_ASYNC_ENABLE_SLOT ) {
+			//
+			// Update alert events based on current HW disposition
+			//
+			logical_slot_reg.AsDWord = readl( slot_context->logical_slot_addr );
+			//
+			// Card present, MRL closed, and no Power-Fault?
+			//
+			if( logical_slot_reg.x.PRSNT1_2 != SHPC_SLOT_EMPTY &&
+				(logical_slot_reg.x.MRLS_IM == SHPC_MASKED ||
+				logical_slot_reg.x.MRLS == SHPC_MRL_CLOSED ) &&
+				logical_slot_reg.x.PF == SHPC_STATUS_CLEARED ) {
+				//
+				// Clear Alert EVENT and Attention LED
+				//
+				spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+				slot_context->problem_detected = FALSE;
+				hp_clear_slot_event_bit(slot_context, ALERT_EVENT);
+				hp_send_slot_event(slot_context, ATTN_LED_PROBLEM_EVENT);
+				spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+				//
+				// Grab Command MUTEX to blink Power LED
+				//
+				dbg("%s -->ENABLE_REQ: slot_id[ %d:%d ]",__FUNCTION__ ,
+					shpc_context->shpc_instance, slot_context->slot_number-1 );
+				slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_at_slot_disabled_wait_for_led_cmd_available;
+			}
+			//
+			// Alert: MRL Opened, Power-Fault?
+			//
+			else if( logical_slot_reg.x.PRSNT1_2 != SHPC_SLOT_EMPTY ) {
+				//
+				// Update Attention LED
+				//
+				spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+				slot_context->problem_detected = TRUE;
+				hp_send_slot_event(slot_context, ATTN_LED_PROBLEM_EVENT);
+				spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+				//
+				// Fail on-going request
+				//
+				slot_context->slot_completion.failed = HP_TRUE;
+				slot_context->slot_completion.done = TRUE;
+				dbg("%s -->ALERT: slot_id[ %d:%d ]  LSR_13:0[ %X ]",__FUNCTION__ ,
+					shpc_context->shpc_instance, slot_context->slot_number-1,
+					logical_slot_reg.AsDWord & 0x3F );
+			}
+		}
+		else {
+			//
+			// Slot already disabled, just complete the request
+			//
+			dbg("%s -->DISABLE_REQ: slot_id[ %d:%d ]",__FUNCTION__ ,
+				shpc_context->shpc_instance, slot_context->slot_number-1 );
+			slot_context->slot_completion.failed = HP_FALSE;
+			slot_context->slot_completion.done = TRUE;
+		}
+
+		//
+		// Allow next SW-initiated slot request while processing this one
+		//
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		hp_clear_slot_event_bit(slot_context, SLOT_REQUEST_EVENT);
+		spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+	}
+	//
+	// exit_request_event
+	//
+	else {
+		status = STATUS_UNSUCCESSFUL;
+	}
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_at_slot_disabled_wait_for_led_cmd_available()
+//
+// ****************************************************************************
+long
+hp_at_slot_disabled_wait_for_led_cmd_available(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+	)
+{
+	unsigned long		old_irq_flags;
+	long status = STATUS_SUCCESS;
+	union SHPC_COMMAND_WREG command_reg;
+
+	dbg("%s -->slot_id[ %d:%d ]",__FUNCTION__ , shpc_context->shpc_instance, slot_context->slot_number-1 );
+	//
+	// Wait for Command Available MUTEX
+	//
+	hp_set_slot_event_bit(slot_context, CMD_ACQUIRE_EVENT);
+	wake_up_interruptible(&slot_context->cmd_acquire_event);
+
+	wait_event_interruptible(slot_context->slot_event,
+		((shpc_context->shpc_event_bits & CMD_AVAILABLE_MUTEX_EVENT) ||
+		(slot_context->slot_event_bits & ALERT_EVENT) ||
+		(slot_context->slot_event_bits & SLOT_REQUEST_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	//
+	// Alert: MRL Opened, Card Removed, Power-Fault?
+	//
+	if(slot_context->slot_event_bits & ALERT_EVENT) {
+
+		//
+		// Update attn_led_problem_event LED
+		//
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		slot_context->problem_detected = TRUE;
+		hp_send_slot_event(slot_context, ATTN_LED_PROBLEM_EVENT);
+		spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+		//
+		// Release Command MUTEX
+		//
+		hp_set_slot_event_bit(slot_context, CMD_RELEASE_EVENT);
+		wake_up_interruptible(&slot_context->cmd_release_event);
+
+		//
+		// Fail on-going request
+		//
+		slot_context->slot_completion.failed = HP_TRUE;
+		slot_context->slot_completion.done = TRUE;
+
+		//
+		// Wait for next request
+		//
+		dbg("%s -->ALERT: slot_id[ %d:%d ]  LSR_13:0[ %X ]",__FUNCTION__ ,
+			shpc_context->shpc_instance, slot_context->slot_number-1,
+			(readl( slot_context->logical_slot_addr ) & 0x3F ));
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_at_slot_disabled_wait_for_slot_request;
+	}
+	//
+	// cmd_available_mutex
+	//
+	else if(shpc_context->shpc_event_bits & CMD_AVAILABLE_MUTEX_EVENT) {
+		//
+		// Clear Completion EVENT before issuing next command
+		//
+		spin_lock_irqsave( &shpc_context->shpc_spinlock, old_irq_flags );
+		hp_clear_shpc_event_bit(shpc_context, CMD_COMPLETION_EVENT);
+		spin_unlock_irqrestore( &shpc_context->shpc_spinlock, old_irq_flags );
+
+		//
+		// Blink Power LED
+		//
+		command_reg.Slot.code = SHPC_SLOT_OPERATION;
+		command_reg.Slot.power_led = SHPC_LED_BLINK;
+		command_reg.Slot.attention_led = SHPC_led_NO_CHANGE;
+		command_reg.Slot.state = SHPC_SLOT_NO_CHANGE;
+		command_reg.Slot.TGT = slot_context->slot_number;
+		writew(command_reg.AsWord ,shpc_context->mmio_base_addr + SHPC_COMMAND_REG_OFFSET);
+
+		//
+		// Wait for command to complete (while holding MUTEX)
+		//
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_at_slot_disabled_wait_for_led_cmd_completion;
+	}
+	//
+	// exit_request_event
+	//
+	else {
+		//
+		// Release Command MUTEX
+		//
+		hp_set_slot_event_bit(slot_context, CMD_RELEASE_EVENT);
+		wake_up_interruptible(&slot_context->cmd_release_event);
+		status = STATUS_UNSUCCESSFUL;
+	}
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_at_slot_disabled_wait_for_led_cmd_completion()
+//
+// ****************************************************************************
+long
+hp_at_slot_disabled_wait_for_led_cmd_completion(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+	)
+{
+	unsigned long	old_irq_flags;
+	long status = STATUS_SUCCESS;
+	union SHPC_STATUS_WREG status_reg;
+
+	dbg( "%s -->slot_id[ %d:%d ]",__FUNCTION__ , shpc_context->shpc_instance, slot_context->slot_number-1 );
+	//
+	// Setup our timer
+	//
+	hp_clear_slot_event_bit(slot_context, SLOT_TIMER1_EVENT);
+	slot_context->slot_timer1.data = (unsigned long)slot_context;
+	slot_context->slot_timer1.function = hp_slot_timer1_func;
+	slot_context->slot_timer1.expires = jiffies + ONE_SEC_TIMEOUT;
+	add_timer(&slot_context->slot_timer1);
+
+	//
+	// Wait for Command Completion EVENT while holding MUTEX
+	//
+	wait_event_interruptible(slot_context->slot_event,
+		((shpc_context->shpc_event_bits & CMD_COMPLETION_EVENT) ||
+		(slot_context->slot_event_bits & ALERT_EVENT) ||
+		(slot_context->slot_event_bits & SLOT_TIMER1_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	if (!(slot_context->slot_event_bits & SLOT_TIMER1_EVENT)) {
+		//
+		// delete the timer because we got an event other than the timer
+		//
+		del_timer_sync(&slot_context->slot_timer1);
+	}
+	//
+	// Alert: MRL Opened, Card Removed, Power-Fault?
+	//
+	if(slot_context->slot_event_bits & ALERT_EVENT) {
+
+		//
+		// Update attn_led_problem_event LED
+		//
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		slot_context->problem_detected = TRUE;
+		hp_send_slot_event(slot_context, ATTN_LED_PROBLEM_EVENT);
+		spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+		//
+		// Fail on-going request
+		//
+		slot_context->slot_completion.failed = HP_TRUE;
+		slot_context->slot_completion.done = TRUE;
+
+		//
+		// Grab Command MUTEX to make sure Power LED is OFF
+		//
+		dbg("%s -->ALERT: slot_id[ %d:%d ]  LSR_13:0[ %X ]",__FUNCTION__ ,
+			shpc_context->shpc_instance, slot_context->slot_number-1,
+			readl( slot_context->logical_slot_addr ) & 0x3F );
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_led_cmd_available;
+	}
+	//
+	// cmd_completion_event, timeout
+	//
+	else if((shpc_context->shpc_event_bits & CMD_COMPLETION_EVENT) ||
+			(slot_context->slot_event_bits & SLOT_TIMER1_EVENT)) {
+		//
+		// Command completed OK?
+		//
+		status_reg.AsWord = readw(shpc_context->mmio_base_addr + SHPC_STATUS_REG_OFFSET);
+
+		if( status_reg.x.BSY == SHPC_STATUS_CLEARED &&
+			status_reg.x.INVCMD_ERR == SHPC_STATUS_CLEARED ) {
+			//
+			// Allow cancellation of operation?
+			//
+			if( slot_context->slot_completion.hw_initiated ) {
+				//
+				// Wait for 5 sec timeout
+				//
+				slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_at_slot_disabled_wait_for_timeout;
+			}
+			else {
+				//
+				// Grab Command MUTEX to power-on the slot
+				//
+				slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_at_slot_disabled_wait_for_power_cmd_available;
+			}
+		}
+		else {
+			//
+			// Fail on-going request
+			//
+			slot_context->slot_completion.failed = HP_TRUE;
+			slot_context->slot_completion.done = TRUE;
+
+			//
+			// Grab Command MUTEX to make sure Power LED is OFF
+			//
+			dbg("%s -->CMD_ERROR: slot_id[ %d:%d ]  Cmd[ %X ]",__FUNCTION__ ,
+				shpc_context->shpc_instance, slot_context->slot_number-1, status_reg.AsWord );
+			slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_led_cmd_available;
+		}
+	}
+	//
+	// exit_request_event
+	//
+	else {
+		status = STATUS_UNSUCCESSFUL;
+	}
+	//
+	// Release Command MUTEX
+	//
+	hp_set_slot_event_bit(slot_context, CMD_RELEASE_EVENT);
+	wake_up_interruptible(&slot_context->cmd_release_event);
+
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_at_slot_disabled_wait_for_timeout()
+//
+// ****************************************************************************
+long
+hp_at_slot_disabled_wait_for_timeout(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+	)
+{
+	unsigned long		old_irq_flags;
+	long status = STATUS_SUCCESS;
+
+	dbg("%s -->slot_id[ %d:%d ]", __FUNCTION__ ,shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Clear Button EVENT before waiting
+	//
+	spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+	hp_clear_slot_event_bit(slot_context, ATTN_BUTTON_EVENT);
+	spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+	//
+	// Setup our timer
+	//
+	hp_clear_slot_event_bit(slot_context, SLOT_TIMER2_EVENT);
+	slot_context->slot_timer2.data = (unsigned long)slot_context;
+	slot_context->slot_timer2.function = hp_slot_timer2_func;
+	slot_context->slot_timer2.expires = jiffies + FIVE_SEC_TIMEOUT;
+	add_timer(&slot_context->slot_timer2);
+
+	//
+	// Wait for 5 sec timeout
+	//
+	wait_event_interruptible(slot_context->slot_event,
+		((slot_context->slot_event_bits & ATTN_BUTTON_EVENT) ||
+		(slot_context->slot_event_bits & ALERT_EVENT) ||
+		(slot_context->slot_event_bits & SLOT_TIMER2_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	if (!(slot_context->slot_event_bits & SLOT_TIMER2_EVENT)) {
+		//
+		// delete the timer because we got an event other than the timer
+		//
+		del_timer_sync(&slot_context->slot_timer2);
+	}
+
+	//
+	// Alert: MRL Opened, Card Removed, Power-Fault?
+	//
+	if(slot_context->slot_event_bits & ALERT_EVENT) {
+
+		//
+		// Update attn_led_problem_event LED
+		//
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		slot_context->problem_detected = TRUE;
+		hp_send_slot_event(slot_context, ATTN_LED_PROBLEM_EVENT);
+		spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+		//
+		// Fail on-going request
+		//
+		slot_context->slot_completion.failed = HP_TRUE;
+		slot_context->slot_completion.done = TRUE;
+
+		//
+		// Grab Command MUTEX to turn OFF Power LED
+		//
+		dbg("%s -->ALERT: slot_id[ %d:%d ]  LSR_13:0[ %X ]",__FUNCTION__ ,
+			shpc_context->shpc_instance, slot_context->slot_number-1,
+			readl( slot_context->logical_slot_addr ) & 0x3F );
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_led_cmd_available;
+	}
+	//
+	// attn_button_event
+	//
+	else if(slot_context->slot_event_bits & ATTN_BUTTON_EVENT) {
+		//
+		// Cancel request, grab Command MUTEX to turn OFF Power LED
+		//
+		dbg("%s -->ENABLE_REQ: slot_id[ %d:%d ] Cancelled: Attn Button",__FUNCTION__ ,
+			shpc_context->shpc_instance, slot_context->slot_number-1 );
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_led_cmd_available;
+	}
+	//
+	// timeout
+	//
+	else if(slot_context->slot_event_bits & SLOT_TIMER2_EVENT) {
+		//
+		// Grab Command MUTEX to set slot at Power-Only state
+		//
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_at_slot_disabled_wait_for_power_cmd_available;
+	}
+	//
+	// exit_request_event
+	//
+	else {
+		status = STATUS_UNSUCCESSFUL;
+	}
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_at_slot_disabled_wait_for_power_cmd_available()
+//
+// ****************************************************************************
+long
+hp_at_slot_disabled_wait_for_power_cmd_available(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+	)
+{
+	unsigned long		old_irq_flags;
+	long status = STATUS_SUCCESS;
+	union SHPC_COMMAND_WREG command_reg;
+
+	dbg("%s -->slot_id[ %d:%d ]",__FUNCTION__ , shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Wait for Command Available MUTEX
+	//
+	hp_set_slot_event_bit(slot_context, CMD_ACQUIRE_EVENT);
+	wake_up_interruptible(&slot_context->cmd_acquire_event);
+
+	wait_event_interruptible(slot_context->slot_event,
+		((shpc_context->shpc_event_bits & CMD_AVAILABLE_MUTEX_EVENT) ||
+		(slot_context->slot_event_bits & ALERT_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	//
+	// Alert: MRL Opened, Card Removed, Power-Fault?
+	//
+	if(slot_context->slot_event_bits & ALERT_EVENT) {
+
+		//
+		// Update attn_led_problem_event LED
+		//
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		slot_context->problem_detected = TRUE;
+		hp_send_slot_event(slot_context, ATTN_LED_PROBLEM_EVENT);
+		spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+		//
+		// Release Command MUTEX
+		//
+		hp_set_slot_event_bit(slot_context, CMD_RELEASE_EVENT);
+		wake_up_interruptible(&slot_context->cmd_release_event);
+
+		//
+		// Fail on-going request
+		//
+		slot_context->slot_completion.failed = HP_TRUE;
+		slot_context->slot_completion.done = TRUE;
+
+		//
+		// Grab Command MUTEX to turn OFF Power LED
+		//
+		dbg("%s -->ALERT: slot_id[ %d:%d ]  LSR_13:0[ %X ]",__FUNCTION__ ,
+			shpc_context->shpc_instance, slot_context->slot_number-1,
+			readl( slot_context->logical_slot_addr ) & 0x3F );
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_led_cmd_available;
+	}
+	//
+	// cmd_available_mutex
+	//
+	else if(shpc_context->shpc_event_bits & CMD_AVAILABLE_MUTEX_EVENT) {
+		//
+		// Clear Completion EVENT before issuing next command
+		//
+		spin_lock_irqsave( &shpc_context->shpc_spinlock, old_irq_flags );
+		hp_clear_shpc_event_bit(shpc_context, CMD_COMPLETION_EVENT);
+		spin_unlock_irqrestore( &shpc_context->shpc_spinlock, old_irq_flags );
+
+		//
+		// Power-on the slot
+		//
+		command_reg.Slot.code = SHPC_SLOT_OPERATION;
+		command_reg.Slot.power_led = SHPC_led_NO_CHANGE;
+		command_reg.Slot.attention_led = SHPC_led_NO_CHANGE;
+		command_reg.Slot.state = SHPC_POWER_ONLY;
+		command_reg.Slot.TGT = slot_context->slot_number;
+		writew(command_reg.AsWord, shpc_context->mmio_base_addr + SHPC_COMMAND_REG_OFFSET);
+
+		//
+		// Wait for 100ms completion pre-amble on RevB-Errata (while holding MUTEX)
+		//
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_at_slot_disabled_wait_for_power_cmd_timeout;
+	}
+	//
+	// exit_request_event
+	//
+	else {
+		//
+		// Release Command MUTEX
+		//
+		hp_set_slot_event_bit(slot_context, CMD_RELEASE_EVENT);
+		wake_up_interruptible(&slot_context->cmd_release_event);
+		status = STATUS_UNSUCCESSFUL;
+	}
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_at_slot_disabled_wait_for_power_cmd_timeout()
+//
+// ****************************************************************************
+long
+hp_at_slot_disabled_wait_for_power_cmd_timeout(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+	)
+{
+	unsigned long		old_irq_flags;
+	long status = STATUS_SUCCESS;
+
+	dbg("%s -->slot_id[ %d:%d ]",__FUNCTION__ , shpc_context->shpc_instance, slot_context->slot_number-1 );
+	//
+	// Setup our timer
+	//
+	hp_clear_slot_event_bit(slot_context, SLOT_TIMER3_EVENT);
+	slot_context->slot_timer3.data = (unsigned long)slot_context;
+	slot_context->slot_timer3.function = hp_slot_timer3_func;
+	slot_context->slot_timer3.expires = jiffies + ONE_TENTH_SEC_TIMEOUT;
+	add_timer(&slot_context->slot_timer3);
+
+	//
+	// Wait for 100ms completion pre-amble on RevB-Errata (while holding MUTEX)
+	//
+	wait_event_interruptible(slot_context->slot_event,
+		((slot_context->slot_event_bits & ALERT_EVENT) ||
+		(slot_context->slot_event_bits & SLOT_TIMER3_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	if (!(slot_context->slot_event_bits & SLOT_TIMER3_EVENT)) {
+		//
+		// delete the timer because we got an event other than the timer
+		//
+		del_timer_sync(&slot_context->slot_timer3);
+	}
+
+	//
+	// Alert: MRL Opened, Card Removed, Power-Fault?
+	//
+	if(slot_context->slot_event_bits & ALERT_EVENT) {
+
+		//
+		// Update attn_led_problem_event LED
+		//
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		slot_context->problem_detected = TRUE;
+		hp_send_slot_event(slot_context, ATTN_LED_PROBLEM_EVENT);
+		spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+		//
+		// Release Command MUTEX
+		//
+		hp_set_slot_event_bit(slot_context, CMD_RELEASE_EVENT);
+		wake_up_interruptible(&slot_context->cmd_release_event);
+
+		//
+		// Fail on-going request
+		//
+		slot_context->slot_completion.failed = HP_TRUE;
+		slot_context->slot_completion.done = TRUE;
+
+		//
+		// Grab Command MUTEX to disable slot
+		//
+		dbg("%s -->ALERT: slot_id[ %d:%d ]  LSR_13:0[ %X ]",__FUNCTION__ ,
+			shpc_context->shpc_instance, slot_context->slot_number-1,
+			readl( slot_context->logical_slot_addr ) & 0x3F );
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_disable_cmd_available;
+	}
+	//
+	// timeout
+	//
+	else if(slot_context->slot_event_bits & SLOT_TIMER3_EVENT) {
+		//
+		// Wait for command to complete (while holding MUTEX)
+		//
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_at_slot_disabled_wait_for_power_cmd_completion;
+	}
+	//
+	// exit_request_event
+	//
+	else {
+		//
+		// Release Command MUTEX
+		//
+		hp_set_slot_event_bit(slot_context, CMD_RELEASE_EVENT);
+		wake_up_interruptible(&slot_context->cmd_release_event);
+		status = STATUS_UNSUCCESSFUL;
+	}
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_at_slot_disabled_wait_for_power_cmd_completion()
+//
+// ****************************************************************************
+long
+hp_at_slot_disabled_wait_for_power_cmd_completion(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+	)
+{
+	unsigned long		old_irq_flags;
+	long status = STATUS_SUCCESS;
+	union SHPC_STATUS_WREG status_reg;
+
+	dbg("%s -->slot_id[ %d:%d ]",__FUNCTION__ , shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Setup our timer
+	//
+	hp_clear_slot_event_bit(slot_context, SLOT_TIMER4_EVENT);
+	slot_context->slot_timer4.data = (unsigned long)slot_context;
+	slot_context->slot_timer4.function = hp_slot_timer4_func;
+	slot_context->slot_timer4.expires = jiffies + FIFTEEN_SEC_TIMEOUT;
+	add_timer(&slot_context->slot_timer4);
+
+	//
+	// Wait for Command Completion EVENT while holding MUTEX
+	//
+	wait_event_interruptible(slot_context->slot_event,
+		((shpc_context->shpc_event_bits & CMD_COMPLETION_EVENT) ||
+		(slot_context->slot_event_bits & ALERT_EVENT) ||
+		(slot_context->slot_event_bits & SLOT_TIMER4_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	if (!(slot_context->slot_event_bits & SLOT_TIMER4_EVENT)) {
+		//
+		// delete the timer because we got an event other than the timer
+		//
+		del_timer_sync(&slot_context->slot_timer4);
+	}
+
+	//
+	// Alert: MRL Opened, Card Removed, Power-Fault?
+	//
+	if(slot_context->slot_event_bits & ALERT_EVENT) {
+
+		//
+		// Update attn_led_problem_event LED
+		//
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		slot_context->problem_detected = TRUE;
+		hp_send_slot_event(slot_context, ATTN_LED_PROBLEM_EVENT);
+		spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+		//
+		// Fail on-going request
+		//
+		slot_context->slot_completion.failed = HP_TRUE;
+		slot_context->slot_completion.done = TRUE;
+
+		//
+		// Grab Command MUTEX to disable slot
+		//
+		dbg("%s -->ALERT: slot_id[ %d:%d ]  LSR_13:0[ %X ]",__FUNCTION__ ,
+			shpc_context->shpc_instance, slot_context->slot_number-1,
+			readl( slot_context->logical_slot_addr ) & 0x3F );
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_disable_cmd_available;
+	}
+	//
+	// cmd_completion_event, timeout
+	//
+	else if((shpc_context->shpc_event_bits & CMD_COMPLETION_EVENT) ||
+			(slot_context->slot_event_bits & SLOT_TIMER4_EVENT)) {
+		//
+		// Command completed OK?
+		//
+		status_reg.AsWord = readw(shpc_context->mmio_base_addr + SHPC_STATUS_REG_OFFSET);
+
+		if( status_reg.x.BSY == SHPC_STATUS_CLEARED &&
+			status_reg.x.MRLO_ERR == SHPC_STATUS_CLEARED &&
+			status_reg.x.INVCMD_ERR == SHPC_STATUS_CLEARED ) {
+			//
+			// Grab Bus MUTEX to validate speed/mode
+			//
+			slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_at_slot_disabled_wait_for_bus_available;
+		}
+		else {
+			//
+			// Fail on-going request
+			//
+			slot_context->slot_completion.failed = HP_TRUE;
+			slot_context->slot_completion.done = TRUE;
+
+			//
+			// Grab Command MUTEX to disable slot
+			//
+			dbg("%s -->CMD_ERROR: slot_id[ %d:%d ]  Cmd[ %X ]",__FUNCTION__ ,
+				shpc_context->shpc_instance, slot_context->slot_number-1, status_reg.AsWord );
+			slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_disable_cmd_available;
+		}
+	}
+	//
+	// exit_request_event
+	//
+	else {
+		status = STATUS_UNSUCCESSFUL;
+	}
+
+	//
+	// Release Command MUTEX
+	//
+	hp_set_slot_event_bit(slot_context, CMD_RELEASE_EVENT);
+	wake_up_interruptible(&slot_context->cmd_release_event);
+
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_at_slot_disabled_wait_for_bus_available()
+//
+// ****************************************************************************
+long
+hp_at_slot_disabled_wait_for_bus_available(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+	)
+{
+	unsigned long		old_irq_flags;
+	long status = STATUS_SUCCESS;
+	enum shpc_speed_mode max_speed_mode, bus_speed_mode;
+
+	dbg("%s -->slot_id[ %d:%d ]",__FUNCTION__ , shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Wait for Bus Available MUTEX
+	//
+	hp_set_slot_event_bit(slot_context, BUS_ACQUIRE_EVENT);
+	wake_up_interruptible(&slot_context->bus_acquire_event);
+
+	wait_event_interruptible(slot_context->slot_event,
+		((shpc_context->shpc_event_bits & BUS_AVAILABLE_MUTEX_EVENT) ||
+		(slot_context->slot_event_bits & ALERT_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	//
+	// Alert: MRL Opened, Card Removed, Power-Fault?
+	//
+	if(slot_context->slot_event_bits & ALERT_EVENT) {
+
+		//
+		// Update attn_led_problem_event LED
+		//
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		slot_context->problem_detected = TRUE;
+		hp_send_slot_event(slot_context, ATTN_LED_PROBLEM_EVENT);
+		spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+		//
+		// Release Bus MUTEX
+		//
+		hp_set_slot_event_bit(slot_context, BUS_RELEASE_EVENT);
+		wake_up_interruptible(&slot_context->bus_release_event);
+
+		//
+		// Fail on-going request
+		//
+		slot_context->slot_completion.failed = HP_TRUE;
+		slot_context->slot_completion.done = TRUE;
+
+		//
+		// Grab Command MUTEX to disable slot
+		//
+		dbg("%s -->ALERT: slot_id[ %d:%d ]  LSR_13:0[ %X ]",__FUNCTION__ ,
+			shpc_context->shpc_instance, slot_context->slot_number-1,
+			readl( slot_context->logical_slot_addr ) & 0x3F );
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_disable_cmd_available;
+	}
+	//
+	// bus_available_mutex
+	//
+	else if(shpc_context->shpc_event_bits & BUS_AVAILABLE_MUTEX_EVENT) {
+		//
+		// Get current HW speed/mode
+		//
+		bus_speed_mode = hp_get_bus_speed_mode( shpc_context );
+		max_speed_mode = hp_get_card_speed_mode( slot_context );
+		if( max_speed_mode > shpc_context->max_speed_mode ) {
+			//
+			// Can only go as fast as the controller allows
+			//
+			max_speed_mode = shpc_context->max_speed_mode;
+		}
+
+		//
+		// Grab global spinlock to check current speed/mode settings
+		//
+		spin_lock_irqsave( &shpc_context->shpc_spinlock, old_irq_flags );
+
+		//
+		// Other slots in contetion for bus speed/mode changes?
+		//
+		slot_context->in_bus_speed_mode_contention = FALSE;
+		max_speed_mode = hp_get_max_speed_mode( shpc_context, max_speed_mode );
+
+		//
+		// Make this card can handle PCI-66 speed/mode
+		//
+		if( max_speed_mode == SHPC_BUS_CONV_66 && !slot_context->card_pci66_capable ) {
+			//
+			// Fall back to slower common denominator
+			//
+			max_speed_mode = SHPC_BUS_CONV_33;
+		}
+
+		//
+		// Bus running at incompatible speed/mode?
+		//
+		if( bus_speed_mode != max_speed_mode ) {
+			//
+			// Other slots already enabled?
+			//
+			if( hp_signal_enabled_slots_to_rebalance_bus( shpc_context )) {
+				//
+				// Wait for enabled slots to release the bus, then change bus speed/mode
+				//
+				shpc_context->bus_speed_mode = max_speed_mode;
+				shpc_context->bus_released = FALSE;
+				hp_clear_shpc_event_bit(shpc_context, BUS_COMPLETE_EVENT);
+				slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_at_slot_disabled_wait_for_bus_released;
+			}
+			else {
+				//
+				// Change bus speed/mode to enable this slot
+				//
+				shpc_context->bus_speed_mode = max_speed_mode;
+				slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_at_slot_disabled_wait_for_speed_mode_cmd_available;
+			}
+		}
+		else {
+			//
+			// Enable slot at current bus speed/mode
+			//
+			shpc_context->bus_speed_mode = bus_speed_mode;
+			slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_at_slot_disabled_wait_for_enable_cmd_available;
+		}
+
+		//
+		// Flag this slot in contention for bus speed/mode validation
+		//
+		slot_context->in_bus_speed_mode_contention = TRUE;
+
+		//
+		// Release global spinlock since we're done checking speed/mode
+		//
+		spin_unlock_irqrestore( &shpc_context->shpc_spinlock, old_irq_flags );
+
+		dbg("%s -->ENABLE_IN_PROGRESS: slot_id[ %d:%d ]  card_speed_mode[ %d+%d ]  bus_speed_mode[ %d=>%d ]",__FUNCTION__ ,
+			shpc_context->shpc_instance, slot_context->slot_number-1,
+			slot_context->card_speed_mode, slot_context->card_pci66_capable,
+			bus_speed_mode, shpc_context->bus_speed_mode );
+	}
+	//
+	// exit_request_event
+	//
+	else {
+		//
+		// Release Bus MUTEX
+		//
+		hp_set_slot_event_bit(slot_context, BUS_RELEASE_EVENT);
+		wake_up_interruptible(&slot_context->bus_release_event);
+		status = STATUS_UNSUCCESSFUL;
+	}
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_at_slot_disabled_wait_for_bus_released() 
+//
+// ****************************************************************************
+long
+hp_at_slot_disabled_wait_for_bus_released(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+	)
+{
+	unsigned long		old_irq_flags;
+	long status = STATUS_SUCCESS;
+
+	dbg("%s -->slot_id[ %d:%d ]",__FUNCTION__ , shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Wait for Bus Release EVENT while holding MUTEX
+	//
+	shpc_context->shpc_event_bits = 0;slot_context->slot_event_bits = 0;
+
+	wait_event_interruptible(slot_context->slot_event,
+		((shpc_context->shpc_event_bits & BUS_RELEASE_EVENT) ||
+		(slot_context->slot_event_bits & ALERT_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	//
+	// Alert: MRL Opened, Card Removed, Power-Fault?
+	//
+	if(slot_context->slot_event_bits & ALERT_EVENT) {
+
+		//
+		// Update attn_led_problem_event LED
+		//
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		slot_context->problem_detected = TRUE;
+		hp_send_slot_event(slot_context, ATTN_LED_PROBLEM_EVENT);
+		spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+		//
+		// Release Bus MUTEX
+		//
+		hp_set_slot_event_bit(slot_context, BUS_RELEASE_EVENT);
+		wake_up_interruptible(&slot_context->bus_release_event);
+
+		//
+		// Fail on-going request
+		//
+		slot_context->slot_completion.failed = HP_TRUE;
+		slot_context->slot_completion.done = TRUE;
+
+		//
+		// Grab Command MUTEX to disable slot
+		//
+		dbg("%s -->ALERT: slot_id[ %d:%d ]  LSR_13:0[ %X ]",__FUNCTION__ ,
+			shpc_context->shpc_instance, slot_context->slot_number-1,
+			readl( slot_context->logical_slot_addr ) & 0x3F );
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_disable_cmd_available;
+	}
+	//
+	// bus_release_event
+	//
+	else if(shpc_context->shpc_event_bits & BUS_RELEASE_EVENT) {
+		spin_lock_irqsave( &shpc_context->shpc_spinlock, old_irq_flags );
+		if( shpc_context->bus_released ) {
+			spin_unlock_irqrestore( &shpc_context->shpc_spinlock, old_irq_flags );
+			//
+			// Grab Command MUTEX to set Bus speed/mode
+			//
+			slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_at_slot_disabled_wait_for_speed_mode_cmd_available;
+		}
+		else {
+			spin_unlock_irqrestore( &shpc_context->shpc_spinlock, old_irq_flags );
+			//
+			// Release Bus MUTEX
+			//
+			hp_set_slot_event_bit(slot_context, BUS_RELEASE_EVENT);
+			wake_up_interruptible(&slot_context->bus_release_event);
+
+			//
+			// Fail on-going request
+			//
+			slot_context->slot_completion.failed = HP_TRUE;
+			slot_context->slot_completion.done = TRUE;
+
+			//
+			// Grab Command MUTEX to disable slot
+			//
+			dbg("%s -->ENABLE_REQ: slot_id[ %d:%d ] Cancelled: BUSY DevNode",__FUNCTION__ ,
+				shpc_context->shpc_instance, slot_context->slot_number-1 );
+			slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_disable_cmd_available;
+		}
+	}
+	//
+	// exit_request_event
+	//
+	else {
+		//
+		// Release Bus MUTEX
+		//
+		hp_set_slot_event_bit(slot_context, BUS_RELEASE_EVENT);
+		wake_up_interruptible(&slot_context->bus_release_event);
+		status =STATUS_UNSUCCESSFUL;
+	}
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_at_slot_disabled_wait_for_speed_mode_cmd_available()
+//
+// ****************************************************************************
+long
+hp_at_slot_disabled_wait_for_speed_mode_cmd_available(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+	)
+{
+	unsigned long		old_irq_flags;
+	long status = STATUS_SUCCESS;
+	union SHPC_COMMAND_WREG command_reg;
+
+	dbg("%s -->slot_id[ %d:%d ]",__FUNCTION__ , shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Wait for Command Available MUTEX
+	//
+	hp_set_slot_event_bit(slot_context, CMD_ACQUIRE_EVENT);
+	wake_up_interruptible(&slot_context->cmd_acquire_event);
+
+	wait_event_interruptible(slot_context->slot_event,
+		((shpc_context->shpc_event_bits & CMD_AVAILABLE_MUTEX_EVENT) ||
+		(slot_context->slot_event_bits & ALERT_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	//
+	// Alert: MRL Opened, Card Removed, Power-Fault?
+	//
+	if(slot_context->slot_event_bits & ALERT_EVENT) {
+
+		//
+		// Update attn_led_problem_event LED
+		//
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		slot_context->problem_detected = TRUE;
+		hp_send_slot_event(slot_context, ATTN_LED_PROBLEM_EVENT);
+		spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+		//
+		// Release Bus, Command MUTEX
+		//
+		hp_set_slot_event_bit(slot_context, CMD_RELEASE_EVENT);
+		wake_up_interruptible(&slot_context->cmd_release_event);
+		hp_set_slot_event_bit(slot_context, BUS_RELEASE_EVENT);
+		wake_up_interruptible(&slot_context->bus_release_event);
+
+		//
+		// Fail on-going request
+		//
+		slot_context->slot_completion.failed = HP_TRUE;
+		slot_context->slot_completion.done = TRUE;
+
+		//
+		// Grab Command MUTEX to disable slot
+		//
+		dbg("%s -->ALERT: slot_id[ %d:%d ]  LSR_13:0[ %X ]",__FUNCTION__ ,
+			shpc_context->shpc_instance, slot_context->slot_number-1,
+			readl( slot_context->logical_slot_addr ) & 0x3F );
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_disable_cmd_available;
+	}
+	//
+	// cmd_available_mutex
+	//
+	else if(shpc_context->shpc_event_bits & CMD_AVAILABLE_MUTEX_EVENT) {
+		//
+		// Clear Completion EVENT before issuing next command
+		//
+		spin_lock_irqsave( &shpc_context->shpc_spinlock, old_irq_flags );
+		hp_clear_shpc_event_bit(shpc_context, CMD_COMPLETION_EVENT);
+		spin_unlock_irqrestore( &shpc_context->shpc_spinlock, old_irq_flags );
+
+		//
+		// Set Bus speed/mode
+		//
+		command_reg.Bus.code = SHPC_SET_BUS_SPEED_MODE;
+		command_reg.Bus.speed_mode = shpc_context->bus_speed_mode;
+		writew(command_reg.AsWord, shpc_context->mmio_base_addr + SHPC_COMMAND_REG_OFFSET);
+
+		//
+		// Wait for command to complete (while holding MUTEX)
+		//
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_at_slot_disabled_wait_for_speed_mode_cmd_completion;
+	}
+	//
+	// exit_request_event
+	//
+	else {
+		//
+		// Release Bus, Command MUTEX
+		//
+		hp_set_slot_event_bit(slot_context, CMD_RELEASE_EVENT);
+		wake_up_interruptible(&slot_context->cmd_release_event);
+		hp_set_slot_event_bit(slot_context, BUS_RELEASE_EVENT);
+		wake_up_interruptible(&slot_context->bus_release_event);
+		status =STATUS_UNSUCCESSFUL;
+	}
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_at_slot_disabled_wait_for_speed_mode_cmd_completion()
+//
+// ****************************************************************************
+long
+hp_at_slot_disabled_wait_for_speed_mode_cmd_completion(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+	)
+{
+	unsigned long		old_irq_flags;
+	long status = STATUS_SUCCESS;
+	union SHPC_STATUS_WREG status_reg;
+
+	dbg("%s -->slot_id[ %d:%d ]",__FUNCTION__ , shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Setup our timer
+	//
+	hp_clear_slot_event_bit(slot_context, SLOT_TIMER5_EVENT);
+	slot_context->slot_timer5.data = (unsigned long)slot_context;
+	slot_context->slot_timer5.function = hp_slot_timer5_func;
+	slot_context->slot_timer5.expires = jiffies + FIFTEEN_SEC_TIMEOUT;
+	add_timer(&slot_context->slot_timer5);
+
+	//
+	// Wait for Command Completion EVENT while holding MUTEX
+	//
+	wait_event_interruptible(slot_context->slot_event,
+		((shpc_context->shpc_event_bits & CMD_COMPLETION_EVENT) ||
+		(slot_context->slot_event_bits & ALERT_EVENT) ||
+		(slot_context->slot_event_bits & SLOT_TIMER5_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	if (!(slot_context->slot_event_bits & SLOT_TIMER5_EVENT)) {
+		//
+		// delete the timer because we got an event other than the timer
+		//
+		del_timer_sync(&slot_context->slot_timer5);
+	}
+
+	//
+	// Alert: MRL Opened, Card Removed, Power-Fault?
+	//
+	if(slot_context->slot_event_bits & ALERT_EVENT) {
+
+		//
+		// Update attn_led_problem_event LED
+		//
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		slot_context->problem_detected = TRUE;
+		hp_send_slot_event(slot_context, ATTN_LED_PROBLEM_EVENT);
+		spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+		//
+		// Release Bus MUTEX
+		//
+		hp_set_slot_event_bit(slot_context, BUS_RELEASE_EVENT);
+		wake_up_interruptible(&slot_context->bus_release_event);
+
+		//
+		// Fail on-going request
+		//
+		slot_context->slot_completion.failed = HP_TRUE;
+		slot_context->slot_completion.done = TRUE;
+
+		//
+		// Grab Command MUTEX to disable slot
+		//
+		dbg("%s -->ALERT: slot_id[ %d:%d ]  LSR_13:0[ %X ]",__FUNCTION__ ,
+			shpc_context->shpc_instance, slot_context->slot_number-1,
+			readl( slot_context->logical_slot_addr ) & 0x3F );
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_disable_cmd_available;
+	}
+	//
+	// cmd_completion_event, timeout
+	//
+	else if((shpc_context->shpc_event_bits & CMD_COMPLETION_EVENT) ||
+			(slot_context->slot_event_bits & SLOT_TIMER5_EVENT)) {
+
+		//
+		// Command completed OK?
+		//
+		status_reg.AsWord = readw(shpc_context->mmio_base_addr + SHPC_STATUS_REG_OFFSET);
+
+		if( status_reg.x.BSY == SHPC_STATUS_CLEARED &&
+			status_reg.x.MRLO_ERR == SHPC_STATUS_CLEARED &&
+			status_reg.x.INVCMD_ERR == SHPC_STATUS_CLEARED &&
+			status_reg.x.INVSM_ERR == SHPC_STATUS_CLEARED ) {
+			//
+			// Grab Command MUTEX to enable slot
+			//
+			slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_at_slot_disabled_wait_for_enable_cmd_available;
+		}
+		else {
+			//
+			// Release Bus MUTEX
+			//
+			hp_set_slot_event_bit(slot_context, BUS_RELEASE_EVENT);
+			wake_up_interruptible(&slot_context->bus_release_event);
+
+			//
+			// Fail on-going request
+			//
+			slot_context->slot_completion.failed = HP_TRUE;
+			slot_context->slot_completion.done = TRUE;
+
+			//
+			// Grab Command MUTEX to disable slot
+			//
+			dbg("%s -->CMD_ERROR: slot_id[ %d:%d ]  Cmd[ %X ]",__FUNCTION__ ,
+				shpc_context->shpc_instance, slot_context->slot_number-1, status_reg.AsWord );
+			slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_disable_cmd_available;
+		}
+	}
+	//
+	// exit_request_event
+	//
+	else {
+		//
+		// Release Bus MUTEX
+		//
+		hp_set_slot_event_bit(slot_context, BUS_RELEASE_EVENT);
+		wake_up_interruptible(&slot_context->bus_release_event);
+		status =STATUS_UNSUCCESSFUL;
+	}
+	//
+	// Release Command MUTEX
+	//
+	hp_set_slot_event_bit(slot_context, CMD_RELEASE_EVENT);
+	wake_up_interruptible(&slot_context->cmd_release_event);
+
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_at_slot_disabled_wait_for_enable_cmd_available() 
+//
+// ****************************************************************************
+long
+hp_at_slot_disabled_wait_for_enable_cmd_available(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+	)
+{
+	unsigned long		old_irq_flags;
+	long status = STATUS_SUCCESS;
+	union SHPC_COMMAND_WREG command_reg;
+
+	dbg("%s -->slot_id[ %d:%d ]",__FUNCTION__ , shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Wait for Command Available MUTEX
+	//
+	hp_set_slot_event_bit(slot_context, CMD_ACQUIRE_EVENT);
+	wake_up_interruptible(&slot_context->cmd_acquire_event);
+
+	 wait_event_interruptible(slot_context->slot_event,
+		((shpc_context->shpc_event_bits & CMD_AVAILABLE_MUTEX_EVENT) ||
+		(slot_context->slot_event_bits & ALERT_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	//
+	// Alert: MRL Opened, Card Removed, Power-Fault?
+	//
+	if(slot_context->slot_event_bits & ALERT_EVENT) {
+
+		//
+		// Update attn_led_problem_event LED
+		//
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		slot_context->problem_detected = TRUE;
+		hp_send_slot_event(slot_context, ATTN_LED_PROBLEM_EVENT);
+		spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+		//
+		// Release Bus, Command MUTEX
+		//
+		hp_set_slot_event_bit(slot_context, BUS_RELEASE_EVENT);
+		wake_up_interruptible(&slot_context->bus_release_event);
+		hp_set_slot_event_bit(slot_context, CMD_RELEASE_EVENT);
+		wake_up_interruptible(&slot_context->cmd_release_event);
+
+		//
+		// Fail on-going request
+		//
+		slot_context->slot_completion.failed = HP_TRUE;
+		slot_context->slot_completion.done = TRUE;
+
+		//
+		// Grab Command MUTEX to disable slot
+		//
+		dbg("%s -->ALERT: slot_id[ %d:%d ]  LSR_13:0[ %X ]",__FUNCTION__ ,
+			shpc_context->shpc_instance, slot_context->slot_number-1,
+			readl( slot_context->logical_slot_addr ) & 0x3F );
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_disable_cmd_available;
+	}
+	//
+	// cmd_available_mutex
+	//
+	else if(shpc_context->shpc_event_bits & CMD_AVAILABLE_MUTEX_EVENT) {
+		//
+		// Clear Completion EVENT before issuing next command
+		//
+		spin_lock_irqsave( &shpc_context->shpc_spinlock, old_irq_flags );
+		hp_clear_shpc_event_bit(shpc_context, CMD_COMPLETION_EVENT);
+		spin_unlock_irqrestore( &shpc_context->shpc_spinlock, old_irq_flags );
+
+		//
+		// Enable the slot
+		//
+		dbg("%s  ENABLING SLOT...",__FUNCTION__ );
+		command_reg.Slot.code = SHPC_SLOT_OPERATION;
+		command_reg.Slot.power_led = SHPC_LED_ON;
+		command_reg.Slot.attention_led = SHPC_led_NO_CHANGE;
+		command_reg.Slot.state = SHPC_ENABLE_SLOT;
+		command_reg.Slot.TGT = slot_context->slot_number;
+		writew(command_reg.AsWord, shpc_context->mmio_base_addr + SHPC_COMMAND_REG_OFFSET);
+
+		//
+		// Wait for command to complete (while holding Bus,Command MUTEX)
+		//
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_at_slot_disabled_wait_for_enable_cmd_completion;
+	}
+	//
+	// exit_request_event
+	//
+	else {
+		//
+		// Release Bus, Command MUTEX
+		//
+		hp_set_slot_event_bit(slot_context, BUS_RELEASE_EVENT);
+		wake_up_interruptible(&slot_context->bus_release_event);
+		hp_set_slot_event_bit(slot_context, CMD_RELEASE_EVENT);
+		wake_up_interruptible(&slot_context->cmd_release_event);
+		status = STATUS_UNSUCCESSFUL;
+	}
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_at_slot_disabled_wait_for_enable_cmd_completion()
+//
+// ****************************************************************************
+long
+hp_at_slot_disabled_wait_for_enable_cmd_completion(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+	)
+{
+	unsigned long		old_irq_flags;
+	long status = STATUS_SUCCESS;
+	union SHPC_STATUS_WREG status_reg;
+
+	dbg("%s -->slot_id[ %d:%d ]",__FUNCTION__ , shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Setup our timer
+	//
+	hp_clear_slot_event_bit(slot_context, SLOT_TIMER6_EVENT);
+	slot_context->slot_timer6.data = (unsigned long)slot_context;
+	slot_context->slot_timer6.function = hp_slot_timer6_func;
+	slot_context->slot_timer6.expires = jiffies + FIFTEEN_SEC_TIMEOUT;
+	add_timer(&slot_context->slot_timer6);
+
+	//
+	// Wait for Command Completion EVENT while holding MUTEX
+	//
+	wait_event_interruptible(slot_context->slot_event,
+		((shpc_context->shpc_event_bits & CMD_COMPLETION_EVENT) ||
+		(slot_context->slot_event_bits & ALERT_EVENT) ||
+		(slot_context->slot_event_bits & SLOT_TIMER6_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	if (!(slot_context->slot_event_bits & SLOT_TIMER6_EVENT)) {
+		//
+		// delete the timer because we got an event other than the timer
+		//
+		del_timer_sync(&slot_context->slot_timer6);
+	}
+
+	//
+	// Alert: MRL Opened, Card Removed, Power-Fault?
+	//
+	if(slot_context->slot_event_bits & ALERT_EVENT) {
+
+		//
+		// Update attn_led_problem_event LED
+		//
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		slot_context->problem_detected = TRUE;
+		hp_send_slot_event(slot_context, ATTN_LED_PROBLEM_EVENT);
+		spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+		//
+		// Release Bus MUTEX
+		//
+		hp_set_slot_event_bit(slot_context, BUS_RELEASE_EVENT);
+		wake_up_interruptible(&slot_context->bus_release_event);
+
+		//
+		// Fail on-going request
+		//
+		slot_context->slot_completion.failed = HP_TRUE;
+		slot_context->slot_completion.done = TRUE;
+
+		//
+		// Grab Command MUTEX to disable slot
+		//
+		dbg("%s -->ALERT: slot_id[ %d:%d ]  LSR_13:0[ %X ]", __FUNCTION__,
+			shpc_context->shpc_instance, slot_context->slot_number-1,
+			readl( slot_context->logical_slot_addr ) & 0x3F );
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_disable_cmd_available;
+	}
+	//
+	// cmd_completion_event, timeout
+	//
+	else if((shpc_context->shpc_event_bits & CMD_COMPLETION_EVENT) ||
+			(slot_context->slot_event_bits & SLOT_TIMER6_EVENT)) {
+		//
+		// Command completed OK?
+		//
+		status_reg.AsWord = readw(shpc_context->mmio_base_addr + SHPC_STATUS_REG_OFFSET);
+
+		if( status_reg.x.BSY == SHPC_STATUS_CLEARED &&
+			status_reg.x.MRLO_ERR == SHPC_STATUS_CLEARED &&
+			status_reg.x.INVCMD_ERR == SHPC_STATUS_CLEARED &&
+			status_reg.x.INVSM_ERR == SHPC_STATUS_CLEARED ) {
+			//
+			// Wait for settling time
+			//
+			slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_at_slot_disabled_wait_for_enable_timeout;
+		}
+		else {
+			//
+			// Release Bus MUTEX
+			//
+			hp_set_slot_event_bit(slot_context, BUS_RELEASE_EVENT);
+			wake_up_interruptible(&slot_context->bus_release_event);
+
+			//
+			// Fail on-going request
+			//
+			slot_context->slot_completion.failed = HP_TRUE;
+			slot_context->slot_completion.done = TRUE;
+
+			//
+			// Grab Command MUTEX to disable slot
+			//
+			dbg("%s -->CMD_ERROR: slot_id[ %d:%d ]  Cmd[ %X ]", __FUNCTION__,
+				shpc_context->shpc_instance, slot_context->slot_number-1, status_reg.AsWord );
+			slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_disable_cmd_available;
+		}
+	}
+	//
+	// exit_request_event
+	//
+	else {
+		//
+		// Release Bus MUTEX
+		//
+		hp_set_slot_event_bit(slot_context, BUS_RELEASE_EVENT);
+		wake_up_interruptible(&slot_context->bus_release_event);
+		status = STATUS_UNSUCCESSFUL;
+	}
+	//
+	// Release Command MUTEX
+	//
+	up( &shpc_context->cmd_available_mutex);
+
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_at_slot_disabled_wait_for_enable_timeout()
+//
+// ****************************************************************************
+long
+hp_at_slot_disabled_wait_for_enable_timeout(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+	)
+{
+	unsigned long		old_irq_flags;
+	long status = STATUS_SUCCESS;
+
+	dbg("%s -->slot_id[ %d:%d ]", __FUNCTION__, shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Setup our timer
+	//
+	hp_clear_slot_event_bit(slot_context, SLOT_TIMER7_EVENT);
+	slot_context->slot_timer7.data = (unsigned long)slot_context;
+	slot_context->slot_timer7.function = hp_slot_timer7_func;
+	slot_context->slot_timer7.expires = jiffies + ONE_SEC_TIMEOUT;
+	add_timer(&slot_context->slot_timer7);
+
+	//
+	// Wait for timeout
+	//
+	wait_event_interruptible(slot_context->slot_event,
+		((slot_context->slot_event_bits & ALERT_EVENT) ||
+		(slot_context->slot_event_bits & SLOT_TIMER7_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	if (!(slot_context->slot_event_bits & SLOT_TIMER7_EVENT)) {
+		//
+		// delete the timer because we got an event other than the timer
+		//
+		del_timer_sync(&slot_context->slot_timer7);
+	}
+	//
+	// Alert: MRL Opened, Card Removed, Power-Fault?
+	//
+	if(slot_context->slot_event_bits & ALERT_EVENT) {
+
+		//
+		// Update attn_led_problem_event LED
+		//
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		slot_context->problem_detected = TRUE;
+		hp_send_slot_event(slot_context, ATTN_LED_PROBLEM_EVENT);
+		spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+		//
+		// Fail on-going request
+		//
+		slot_context->slot_completion.failed = HP_TRUE;
+		slot_context->slot_completion.done = TRUE;
+
+		//
+		// Grab Command MUTEX to disable slot
+		//
+		dbg("%s -->ALERT: slot_id[ %d:%d ]  LSR_13:0[ %X ]", __FUNCTION__,
+			shpc_context->shpc_instance, slot_context->slot_number-1,
+			readl( slot_context->logical_slot_addr ) & 0x3F );
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_disable_cmd_available;
+	}
+	//
+	// timeout
+	//
+	else if(slot_context->slot_event_bits & SLOT_TIMER7_EVENT) {
+		//
+		// Flag this slot as ENABLED
+		//
+		hp_flag_slot_as_enabled( shpc_context, slot_context );
+
+		//
+		// Complete succesful ENABLE request
+		//
+		slot_context->slot_completion.failed = HP_FALSE;
+		slot_context->slot_completion.done = TRUE;
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_at_slot_enabled_wait_for_slot_request;
+	}
+	//
+	// exit_request_event
+	//
+	else {
+		status =STATUS_UNSUCCESSFUL;
+	}
+	//
+	// Release Bus MUTEX
+	//
+	hp_set_slot_event_bit(slot_context, BUS_RELEASE_EVENT);
+	wake_up_interruptible(&slot_context->bus_release_event);
+
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_to_slot_disabled_wait_for_led_cmd_available()
+//
+// ****************************************************************************
+long
+hp_to_slot_disabled_wait_for_led_cmd_available(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+	)
+{
+	unsigned long		old_irq_flags;
+	long status = STATUS_SUCCESS;
+	union SHPC_COMMAND_WREG command_reg;
+
+	dbg("%s -->slot_id[ %d:%d ]", __FUNCTION__, shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Wait for Command Available MUTEX
+	//
+	hp_set_slot_event_bit(slot_context, CMD_ACQUIRE_EVENT);
+	wake_up_interruptible(&slot_context->cmd_acquire_event);
+
+	wait_event_interruptible(slot_context->slot_event,
+		((shpc_context->shpc_event_bits & CMD_AVAILABLE_MUTEX_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	if (shpc_context->shpc_event_bits & CMD_AVAILABLE_MUTEX_EVENT) {
+		//
+		// Clear Completion EVENT before issuing next command
+		//
+		spin_lock_irqsave( &shpc_context->shpc_spinlock, old_irq_flags );
+		hp_clear_shpc_event_bit(shpc_context, CMD_COMPLETION_EVENT);
+		spin_unlock_irqrestore( &shpc_context->shpc_spinlock, old_irq_flags );
+
+		//
+		// Turn OFF Power LED
+		//
+		command_reg.Slot.code = SHPC_SLOT_OPERATION;
+		command_reg.Slot.power_led = SHPC_LED_OFF;
+		command_reg.Slot.attention_led = SHPC_led_NO_CHANGE;
+		command_reg.Slot.state = SHPC_SLOT_NO_CHANGE;
+		command_reg.Slot.TGT = slot_context->slot_number;
+		writew(command_reg.AsWord, shpc_context->mmio_base_addr + SHPC_COMMAND_REG_OFFSET);
+
+		//
+		// Wait for Power LED command to complete
+		//
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_led_cmd_completion;
+	}
+	else {				// exit_request_event
+		//
+		// Release Command MUTEX
+		//
+		hp_set_slot_event_bit(slot_context, CMD_RELEASE_EVENT);
+		wake_up_interruptible(&slot_context->cmd_release_event);
+		status = STATUS_UNSUCCESSFUL;
+	}
+	return status;
+}
+
+// ****************************************************************************
+//
+// hp_to_slot_disabled_wait_for_led_cmd_completion()
+//
+// ****************************************************************************
+long
+hp_to_slot_disabled_wait_for_led_cmd_completion(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+	)
+{
+	long status = STATUS_SUCCESS;
+
+	dbg("%s -->slot_id[ %d:%d ]", __FUNCTION__, shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Setup our timer
+	//
+	hp_clear_slot_event_bit(slot_context, SLOT_TIMER8_EVENT);
+	slot_context->slot_timer8.data = (unsigned long)slot_context;
+	slot_context->slot_timer8.function = hp_slot_timer8_func;
+	slot_context->slot_timer8.expires = jiffies + ONE_SEC_TIMEOUT;
+	add_timer(&slot_context->slot_timer8);
+
+	//
+	// Wait for Command Completion EVENT while holding MUTEX
+	//
+	wait_event_interruptible(slot_context->slot_event,
+		((shpc_context->shpc_event_bits & CMD_COMPLETION_EVENT) ||
+		(slot_context->slot_event_bits & SLOT_TIMER8_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	if (!(slot_context->slot_event_bits & SLOT_TIMER8_EVENT)) {
+		//
+		// delete the timer because we got an event other than the timer
+		//
+		del_timer_sync(&slot_context->slot_timer8);
+	}
+
+	if((shpc_context->shpc_event_bits & CMD_COMPLETION_EVENT) ||
+	   (slot_context->slot_event_bits & SLOT_TIMER8_EVENT)) {
+		//
+		// Wait for next request
+		//
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_at_slot_disabled_wait_for_slot_request;
+
+	}else{				// exit_request_event
+		status = STATUS_UNSUCCESSFUL;
+	}
+
+	//
+	// Release command MUTEX
+	//
+	hp_set_slot_event_bit(slot_context, CMD_RELEASE_EVENT);
+	wake_up_interruptible(&slot_context->cmd_release_event);
+
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_to_slot_disabled_wait_for_disable_cmd_available()
+//
+// ****************************************************************************
+long
+hp_to_slot_disabled_wait_for_disable_cmd_available(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+	)
+{
+	unsigned long		old_irq_flags;
+	long status = STATUS_SUCCESS;
+	union SHPC_COMMAND_WREG command_reg;
+
+	dbg("%s -->slot_id[ %d:%d ]", __FUNCTION__, shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Wait for Command Available MUTEX
+	//
+	hp_set_slot_event_bit(slot_context, CMD_ACQUIRE_EVENT);
+	wake_up_interruptible(&slot_context->cmd_acquire_event);
+
+	wait_event_interruptible(slot_context->slot_event,
+		((shpc_context->shpc_event_bits & CMD_AVAILABLE_MUTEX_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	if(shpc_context->shpc_event_bits & CMD_AVAILABLE_MUTEX_EVENT) {
+		//
+		// Clear Completion EVENT before issuing next command
+		//
+		spin_lock_irqsave( &shpc_context->shpc_spinlock, old_irq_flags );
+		hp_clear_shpc_event_bit(shpc_context, CMD_COMPLETION_EVENT);
+		spin_unlock_irqrestore( &shpc_context->shpc_spinlock, old_irq_flags );
+
+		//
+		// Disable slot and turn OFF Power LED
+		//
+		command_reg.Slot.code = SHPC_SLOT_OPERATION;
+		command_reg.Slot.power_led = SHPC_LED_OFF;
+		command_reg.Slot.attention_led = SHPC_led_NO_CHANGE;
+		command_reg.Slot.state = SHPC_DISABLE_SLOT;
+		command_reg.Slot.TGT = slot_context->slot_number;
+		writew(command_reg.AsWord, shpc_context->mmio_base_addr + SHPC_COMMAND_REG_OFFSET);
+
+		//
+		// Wait for command to complete
+		//
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_disable_cmd_completion;
+	}
+	else {
+		//
+		// Release Command MUTEX
+		//
+		hp_set_slot_event_bit(slot_context, CMD_RELEASE_EVENT);
+		wake_up_interruptible(&slot_context->cmd_release_event);
+		status = STATUS_UNSUCCESSFUL;
+	}
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_to_slot_disabled_wait_for_disable_cmd_completion()
+//
+// ****************************************************************************
+long
+hp_to_slot_disabled_wait_for_disable_cmd_completion(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+	)
+{
+	long status = STATUS_SUCCESS;
+
+	dbg("%s -->slot_id[ %d:%d ]", __FUNCTION__, shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Setup our timer
+	//
+	hp_clear_slot_event_bit(slot_context, SLOT_TIMER9_EVENT);
+	slot_context->slot_timer9.data = (unsigned long)slot_context;
+	slot_context->slot_timer9.function = hp_slot_timer9_func;
+	slot_context->slot_timer9.expires = jiffies + FIFTEEN_SEC_TIMEOUT;
+	add_timer(&slot_context->slot_timer9);
+
+	//
+	// Wait for Command Completion EVENT while holding MUTEX
+	//
+	wait_event_interruptible(slot_context->slot_event,
+		((shpc_context->shpc_event_bits & CMD_COMPLETION_EVENT) ||
+		(slot_context->slot_event_bits & SLOT_TIMER9_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	if (!(slot_context->slot_event_bits & SLOT_TIMER9_EVENT)) {
+		//
+		// delete the timer because we got an event other than the timer
+		//
+		del_timer_sync(&slot_context->slot_timer9);
+	}
+
+	if((shpc_context->shpc_event_bits & CMD_COMPLETION_EVENT) ||
+	   (slot_context->slot_event_bits & SLOT_TIMER9_EVENT)) {
+		//
+		// Flag this slot as DISABLED (if enabled)
+		//
+		if( hp_flag_slot_as_disabled( shpc_context, slot_context )) {
+			//
+			// Wait for settling time
+			//
+			slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_disable_timeout;
+		}
+		else {
+			//
+			// Wait for next request
+			//
+			slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_at_slot_disabled_wait_for_slot_request;
+		}
+	}
+	else {				// exit_request_event
+		status = STATUS_UNSUCCESSFUL;
+	}
+	//
+	// Release command MUTEX
+	//
+	hp_set_slot_event_bit(slot_context, CMD_RELEASE_EVENT);
+	wake_up_interruptible(&slot_context->cmd_release_event);
+
+	return status;
+}
+
+// ****************************************************************************
+//
+// hp_to_slot_disabled_wait_for_DisableTimeout()
+//
+// ****************************************************************************
+long
+hp_to_slot_disabled_wait_for_disable_timeout(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+	)
+{
+	long status = STATUS_SUCCESS;
+
+	dbg("%s -->slot_id[ %d:%d ]", __FUNCTION__, shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Setup our timer
+	//
+	hp_clear_slot_event_bit(slot_context, SLOT_TIMER10_EVENT);
+	slot_context->slot_timer10.data = (unsigned long)slot_context;
+	slot_context->slot_timer10.function = hp_slot_timer10_func;
+	slot_context->slot_timer10.expires = jiffies + ONE_SEC_TIMEOUT;
+	add_timer(&slot_context->slot_timer10);
+
+	//
+	// Wait for timeout
+	//
+	wait_event_interruptible(slot_context->slot_event,
+		((slot_context->slot_event_bits & SLOT_TIMER10_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	if (!(slot_context->slot_event_bits & SLOT_TIMER10_EVENT)) {
+		//
+		// delete the timer because we got an event other than the timer
+		//
+		del_timer_sync(&slot_context->slot_timer10);
+	}
+
+	//
+	// timeout
+	//
+	if(slot_context->slot_event_bits & SLOT_TIMER10_EVENT) {
+		slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_to_slot_disabled_wait_for_bus_available;
+	}
+	//
+	// exit_request_event
+	//
+	else {
+		status = STATUS_UNSUCCESSFUL;
+	}
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_to_slot_disabled_wait_for_bus_available() 
+//
+// ****************************************************************************
+long
+hp_to_slot_disabled_wait_for_bus_available(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+	)
+{
+	unsigned long		old_irq_flags;
+	long status = STATUS_SUCCESS;
+	enum shpc_speed_mode max_speed_mode;
+
+	dbg("%s -->slot_id[ %d:%d ]",  __FUNCTION__, shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Wait for Bus Available MUTEX
+	//
+	hp_set_slot_event_bit(slot_context, BUS_ACQUIRE_EVENT);
+	wake_up_interruptible(&slot_context->bus_acquire_event);
+
+	wait_event_interruptible(slot_context->slot_event,
+		((shpc_context->shpc_event_bits & BUS_AVAILABLE_MUTEX_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	if(shpc_context->shpc_event_bits & BUS_AVAILABLE_MUTEX_EVENT) {
+			//
+			// Grab global spinlock to check current speed/mode settings
+			//
+			spin_lock_irqsave( &shpc_context->shpc_spinlock, old_irq_flags );
+
+			//
+			// Flag this slot out of contetion for bus speed/mode changes
+			//
+			slot_context->in_bus_speed_mode_contention = FALSE;
+
+			//
+			// Enabled slots running at maximum speed/mode?
+			//
+			if( shpc_context->slots_enabled ) {
+				max_speed_mode = hp_get_max_speed_mode( shpc_context, shpc_context->max_speed_mode );
+
+				//
+				// Signal enabled slots to release the bus, then change bus speed/mode
+				//
+				if( shpc_context->bus_speed_mode != max_speed_mode ) {
+					hp_signal_enabled_slots_to_rebalance_bus( shpc_context );
+				}
+			}
+
+			//
+			// Release global spinlock since we're done checking speed/mode
+			//
+			spin_unlock_irqrestore( &shpc_context->shpc_spinlock, old_irq_flags );
+
+			//
+			// Wait for next request on this slot
+			//
+			slot_context->slot_function = (SLOT_STATE_FUNCTION)hp_at_slot_disabled_wait_for_slot_request;
+	}
+	else {				// exit_request_event
+		status = STATUS_UNSUCCESSFUL;
+	}
+
+	//
+	// Release Bus MUTEX
+	//
+	hp_set_slot_event_bit(slot_context, BUS_RELEASE_EVENT);
+	wake_up_interruptible(&slot_context->bus_release_event);
+
+	return status;
+}
+
diff -purN linux-2.5/drivers/pci/hotplug/amdshpc_int.c usb-2.5/drivers/pci/hotplug/amdshpc_int.c
--- linux-2.5/drivers/pci/hotplug/amdshpc_int.c	1970-01-01 00:00:00.000000000 +0000
+++ usb-2.5/drivers/pci/hotplug/amdshpc_int.c	2003-08-28 23:06:29.000000000 +0000
@@ -0,0 +1,374 @@
+/*
+ * Copyright (C) 2003 Greg Kroah-Hartman (greg@kroah.com)
+ * Copyright (C) 2003 IBM Corp.
+ * Copyright (C) 2002-2003 Advanced Micro Devices
+ *
+ * YOUR USE OF THIS CODE IS SUBJECT TO THE TERMS
+ * AND CONDITIONS OF THE GNU GENERAL PUBLIC
+ * LICENSE FOUND IN THE "GPL.TXT" FILE THAT IS
+ * INCLUDED WITH THIS FILE AND POSTED AT
+ * http://www.gnu.org/licenses/gpl.html
+ *
+ * Send feedback to <david.keck@amd.com>
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/sched.h>
+#include "amdshpc_ddi.h"
+#include "amdshpc.h"
+
+
+// ****************************************************************************
+//
+// hp_interrupt_service()
+//
+// ****************************************************************************
+irqreturn_t hp_interrupt_service(int IRQ, void *v, struct pt_regs *regs)
+{
+	struct shpc_context *shpc_context = v;
+	struct slot_context *slot_context;
+	union SHPC_SERR_INT_DWREG	SerrIntReg;
+	union SHPC_INT_LOCATOR_DWREG	IntLocatorReg, SlotIndex;
+	union SHPC_LOGICAL_SLOT_DWREG logical_slot_reg;
+	u8 IsShpcInterrupt = FALSE;
+	u8 i;
+
+	//
+	// Device at PowerDeviceD0?
+	//
+	if( !shpc_context->at_power_device_d0 ) {
+		return IRQ_HANDLED;
+	}
+
+	//
+	// Read Interrupt Locator Register ( Pending Interrupts )
+	//
+	IntLocatorReg.AsDWord = readl(shpc_context->mmio_base_addr + SHPC_INT_LOCATOR_REG_OFFSET);
+
+	//
+	// Read SERR-INT Register ( Global Mask, Command Completion )
+	//
+	SerrIntReg.AsDWord = readl(shpc_context->mmio_base_addr + SHPC_SERR_INT_REG_OFFSET);
+
+	//
+	// Global Interrupts Disabled?
+	//
+//	if( SerrIntReg.x.GIM == SHPC_MASKED ) {
+//		return FALSE;
+//	}
+
+	//
+	// Command Completion?
+	//
+	if( IntLocatorReg.x.CC_IP ) {
+		if(( SerrIntReg.x.CC_STS == SHPC_STATUS_SET ) &&
+			( SerrIntReg.x.CC_IM == SHPC_UNMASKED )) {
+			//
+			// Schedule Dpc
+			//
+			IsShpcInterrupt = TRUE;
+			tasklet_schedule(&shpc_context->cmd_completion_dpc);
+
+			//
+			// Clear Interrput (Write-back 1 to STS bits)
+			//
+			writel(SerrIntReg.AsDWord, shpc_context->mmio_base_addr + SHPC_SERR_INT_REG_OFFSET);
+		}
+	}
+
+	//
+	// Slot Interrupts?
+	//
+	if( IntLocatorReg.x.SLOT_IP ) {
+		//
+		// Walk a "1" thru each bit position (one bit per slot)
+		//
+		for( i=0, SlotIndex.x.SLOT_IP = 1; i< SHPC_MAX_NUM_SLOTS; ++i, SlotIndex.x.SLOT_IP <<= 1 ) {
+			slot_context = &shpc_context->slot_context[ i ];
+
+			//
+			// Interrupt from this slot?
+			//
+			if( IntLocatorReg.x.SLOT_IP & SlotIndex.x.SLOT_IP ) {
+				//
+				//  Read Logical Slot Register
+				//
+				logical_slot_reg.AsDWord = readl( slot_context->logical_slot_addr );
+
+				//
+				// Attention Button?
+				//
+				if(( logical_slot_reg.x.ABP_STS == SHPC_STATUS_SET ) &&
+					( logical_slot_reg.x.AB_IM == SHPC_UNMASKED )) {
+					//
+					// Schedule Dpc
+					//
+					IsShpcInterrupt = TRUE;
+					tasklet_schedule(&slot_context->attn_button_dpc);
+				}
+
+				//
+				// MRL Sensor?
+				//
+				if(( logical_slot_reg.x.MRLSC_STS == SHPC_STATUS_SET ) &&
+					( logical_slot_reg.x.MRLS_IM == SHPC_UNMASKED )) {
+					//
+					// Schedule Dpc
+					//
+					IsShpcInterrupt = TRUE;
+					tasklet_schedule(&slot_context->mrl_sensor_dpc);
+				}
+
+				//
+				// Card Presence Change?
+				//
+				if(( logical_slot_reg.x.CPC_STS == SHPC_STATUS_SET ) &&
+					( logical_slot_reg.x.CP_IM == SHPC_UNMASKED )) {
+					//
+					// Schedule Dpc
+					//
+					IsShpcInterrupt = TRUE;
+					tasklet_schedule(&slot_context->card_presence_dpc);
+				}
+
+				//
+				// Isolated Power Fault?
+				//
+				if(( logical_slot_reg.x.IPF_STS == SHPC_STATUS_SET ) &&
+					( logical_slot_reg.x.IPF_IM == SHPC_UNMASKED )) {
+					//
+					// Schedule Dpc
+					//
+					IsShpcInterrupt = TRUE;
+					tasklet_schedule(&slot_context->isolated_power_fault_dpc);
+				}
+
+				//
+				// Connected Power Fault?
+				//
+				if(( logical_slot_reg.x.CPF_STS == SHPC_STATUS_SET ) &&
+					( logical_slot_reg.x.CPF_IM == SHPC_UNMASKED )) {
+					//
+					// Schedule Dpc
+					//
+					IsShpcInterrupt = TRUE;
+					tasklet_schedule(&slot_context->connected_power_fault_dpc);
+				}
+
+				//
+				// Clear Interrputs for this slot (Write-back 1 to STS bits)
+				//
+				writel(logical_slot_reg.AsDWord, slot_context->logical_slot_addr);
+			}
+		}
+	}
+	return IRQ_HANDLED;
+}
+
+
+// ****************************************************************************
+//
+// hp_attn_button_dpc() @ DISPATCH_LEVEL
+//
+// ****************************************************************************
+void
+hp_attn_button_dpc(
+	unsigned long deferred_context	// struct slot_context*
+	)
+{
+	struct slot_context* slot_context = ( struct slot_context* )deferred_context;
+	struct shpc_context* shpc_context = slot_context->shpc_context;
+
+	dbg("%s ->slot_id[ %d:%d ]", __FUNCTION__, shpc_context->shpc_instance, (slot_context->slot_number-1) );
+	//
+	// Notification Event: Attention Button pressed
+	//
+	spin_lock( &slot_context->slot_spinlock );
+	hp_send_slot_event(slot_context, ATTN_BUTTON_EVENT);
+	spin_unlock( &slot_context->slot_spinlock );
+}
+
+
+// ****************************************************************************
+//
+// hp_card_presence_dpc() @ DISPATCH_LEVEL
+//
+// ****************************************************************************
+void
+hp_card_presence_dpc(
+	unsigned long deferred_context	// struct slot_context*
+	)
+{
+	struct slot_context* slot_context = ( struct slot_context* )deferred_context;
+	struct shpc_context* shpc_context = slot_context->shpc_context;
+	union SHPC_LOGICAL_SLOT_DWREG logical_slot_reg;
+
+	dbg("%s -->slot_id[ %d:%d ]", __FUNCTION__, shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Signal registered user EVENT
+	//
+	hp_signal_user_event_at_dpc_level( shpc_context );
+
+	//
+	// Card Removed?
+	//
+	logical_slot_reg.AsDWord = readl( slot_context->logical_slot_addr );
+	if( logical_slot_reg.x.PRSNT1_2 == SHPC_SLOT_EMPTY ) {
+		//
+		// Signal Alert EVENT
+		//
+		spin_lock( &slot_context->slot_spinlock );
+		hp_send_slot_event(slot_context, ALERT_EVENT);
+		spin_unlock( &slot_context->slot_spinlock );
+	}
+}
+
+
+// ****************************************************************************
+//
+// hp_mrl_sensor_dpc() @ DISPATCH_LEVEL
+//
+// ****************************************************************************
+void
+hp_mrl_sensor_dpc(
+	unsigned long deferred_context	// struct slot_context*
+	)
+{
+	struct slot_context* slot_context = ( struct slot_context* )deferred_context;
+	struct shpc_context* shpc_context = slot_context->shpc_context;
+	union SHPC_LOGICAL_SLOT_DWREG logical_slot_reg;
+
+	dbg("%s -->slot_id[ %d:%d ]", __FUNCTION__, shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Signal registered user EVENT
+	//
+	hp_signal_user_event_at_dpc_level( shpc_context );
+
+	//
+	// MRL Sensor opened?
+	//
+	logical_slot_reg.AsDWord = readl( slot_context->logical_slot_addr );
+	if( logical_slot_reg.x.MRLS == SHPC_MRL_OPEN ) {
+		//
+		// Card Present?
+		//
+		if( logical_slot_reg.x.PRSNT1_2 != SHPC_SLOT_EMPTY ) {
+			//
+			// Signal Alert EVENT
+			//
+			spin_lock( &slot_context->slot_spinlock );
+			hp_send_slot_event(slot_context, ALERT_EVENT);
+			spin_unlock( &slot_context->slot_spinlock );
+		}
+	}
+	else {
+		//
+		// Power Fault detected whith MRL closed?
+		// Note: Golem A0 may not generate power-fault interrupt
+		if( logical_slot_reg.x.PF == SHPC_STATUS_SET ) {
+			//
+			// Signal Alert EVENT
+			//
+			spin_lock( &slot_context->slot_spinlock );
+			hp_send_slot_event(slot_context, ALERT_EVENT);
+			spin_unlock( &slot_context->slot_spinlock );
+		}
+	}
+}
+
+// ****************************************************************************
+//
+// isolated_power_fault_dpc() @ DISPATCH_LEVEL
+//
+// ****************************************************************************
+void
+hp_isolated_power_fault_dpc(
+	unsigned long deferred_context	// struct slot_context*
+	)
+{
+	struct slot_context* slot_context = ( struct slot_context* )deferred_context;
+	struct shpc_context* shpc_context = slot_context->shpc_context;
+	union SHPC_LOGICAL_SLOT_DWREG logical_slot_reg;
+
+	dbg("%s -->slot_id[ %d:%d ]", __FUNCTION__, shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Signal registered user EVENT
+	//
+	hp_signal_user_event_at_dpc_level( shpc_context );
+
+	//
+	// Power Fault detected?
+	//
+	logical_slot_reg.AsDWord = readl( slot_context->logical_slot_addr );
+	if( logical_slot_reg.x.PF == SHPC_STATUS_SET ) {
+		//
+		// Signal Alert EVENT
+		//
+		spin_lock( &slot_context->slot_spinlock );
+		hp_send_slot_event(slot_context, ALERT_EVENT);
+		spin_unlock( &slot_context->slot_spinlock );
+	}
+}
+
+
+// ****************************************************************************
+//
+// connected_power_fault_dpc() @ DISPATCH_LEVEL
+//
+// ****************************************************************************
+void
+hp_connected_power_fault_dpc(
+	unsigned long deferred_context	// struct slot_context*
+	)
+{
+	struct slot_context* slot_context = ( struct slot_context* )deferred_context;
+	struct shpc_context* shpc_context = slot_context->shpc_context;
+	union SHPC_LOGICAL_SLOT_DWREG logical_slot_reg;
+
+	dbg("%s -->slot_id[ %d:%d ]", __FUNCTION__, shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Signal registered user EVENT
+	//
+	hp_signal_user_event_at_dpc_level( shpc_context );
+
+	//
+	// Power Fault detected?
+	//
+	logical_slot_reg.AsDWord = readl( slot_context->logical_slot_addr );
+	if( logical_slot_reg.x.PF == SHPC_STATUS_SET ) {
+		//
+		// Signal Alert EVENT
+		//
+		spin_lock( &slot_context->slot_spinlock );
+		hp_send_slot_event(slot_context, ALERT_EVENT);
+		spin_unlock( &slot_context->slot_spinlock );
+	}
+}
+
+
+// ****************************************************************************
+//
+// hp_cmd_completion_dpc() @ DISPATCH_LEVEL
+//
+// ****************************************************************************
+void
+hp_cmd_completion_dpc(
+	unsigned long deferred_context	// struct shpc_context*
+	)
+{
+	struct shpc_context* shpc_context = ( struct shpc_context* )deferred_context;
+
+	dbg("%s -->HwInstance[ %d ]", __FUNCTION__, shpc_context->shpc_instance );
+
+	//
+	// Notification Event: Command Completion
+	//
+	spin_lock( &shpc_context->shpc_spinlock );
+	hp_send_event_to_all_slots(shpc_context, CMD_COMPLETION_EVENT);
+	spin_unlock( &shpc_context->shpc_spinlock );
+}
diff -purN linux-2.5/drivers/pci/hotplug/amdshpc_led.c usb-2.5/drivers/pci/hotplug/amdshpc_led.c
--- linux-2.5/drivers/pci/hotplug/amdshpc_led.c	1970-01-01 00:00:00.000000000 +0000
+++ usb-2.5/drivers/pci/hotplug/amdshpc_led.c	2003-08-28 23:06:29.000000000 +0000
@@ -0,0 +1,742 @@
+/*
+ * Copyright (C) 2001,2003 Greg Kroah-Hartman (greg@kroah.com)
+ * Copyright (C) 2001,2003 IBM Corp.
+ * Copyright (C) 2002-2003 Advanced Micro Devices
+ *
+ * YOUR USE OF THIS CODE IS SUBJECT TO THE TERMS
+ * AND CONDITIONS OF THE GNU GENERAL PUBLIC
+ * LICENSE FOUND IN THE "GPL.TXT" FILE THAT IS
+ * INCLUDED WITH THIS FILE AND POSTED AT
+ * http://www.gnu.org/licenses/gpl.html
+ *
+ * Send feedback to <david.keck@amd.com>
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/sched.h>
+#include "amdshpc_ddi.h"
+#include "amdshpc.h"
+
+
+// ****************************************************************************
+//
+// hp_wait_for_attn_led_request() @ PASSIVE_LEVEL
+//
+// ****************************************************************************
+long
+hp_wait_for_attn_led_request(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+	)
+{
+	unsigned long old_irq_flags;
+	long status = STATUS_SUCCESS;
+	union SLOT_STATUS_INFO slot_status;
+	union SHPC_LOGICAL_SLOT_DWREG logical_slot_reg;
+
+	dbg("%s -->slot_id[ %d:%d ]", __FUNCTION__, shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+ 	//
+ 	// LED "Normal": complete pending request
+ 	//
+ 	if( slot_context->attn_led_completion.done ) {
+ 		//
+ 		// Call Completion Callback()
+ 		//
+ 		hp_QuerySlotStatus(	shpc_context, slot_context->slot_number - 1, &slot_status );
+ 		slot_status.x.lu_request_failed = slot_context->slot_completion.failed;
+ 		shpc_context->async_callback(
+ 			shpc_context->driver_context,
+ 			slot_context->slot_number - 1,
+ 			slot_context->attn_led_completion.type,
+ 			slot_status,
+ 			slot_context->attn_led_completion.request_context );
+ 
+ 		//
+ 		// Signal registered user EVENT
+ 		//
+ 		hp_signal_user_event( shpc_context );
+ 
+ 		//
+ 		// Clear completion flag
+ 		//
+ 		slot_context->attn_led_completion.done = FALSE;
+ 	}
+ 
+	//
+	// Wait for slot request
+	//
+	wait_event_interruptible(slot_context->slot_event,
+		((slot_context->slot_event_bits & ATTN_LED_REQUEST_EVENT) ||
+		(slot_context->slot_event_bits & ATTN_LED_PROBLEM_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	// AttnLEDRequestEvent
+	if(slot_context->slot_event_bits & ATTN_LED_REQUEST_EVENT) {
+		//
+		// Set completion info for SW-initiated request
+		//
+		slot_context->attn_led_completion.hw_initiated = FALSE;
+		slot_context->attn_led_completion.type = slot_context->attn_led_request.type;
+		slot_context->attn_led_completion.timeout = slot_context->attn_led_request.timeout;
+		slot_context->attn_led_completion.request_context = slot_context->attn_led_request.request_context;
+
+		//
+		// Request to locate slot?
+		//
+		if( slot_context->attn_led_request.type == SHPC_ASYNC_LED_LOCATE ) {
+			dbg("%s -->LED_LOCATE_REQ: slot_id[ %d:%d ]", __FUNCTION__,
+				shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+			//
+			// Grab Command MUTEX to blink Attn LED
+			//
+			slot_context->attn_led_function = (SLOT_STATE_FUNCTION)hp_wait_for_attn_led_blink_cmd_available;
+		}
+		else {
+			dbg("%s -->LED_NORMAL_REQ: slot_id[ %d:%d ]", __FUNCTION__,
+				shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+			logical_slot_reg.AsDWord = readl( slot_context->logical_slot_addr );
+			if( logical_slot_reg.x.AIS == SHPC_LED_ON || logical_slot_reg.x.AIS == SHPC_LED_OFF ) {
+				//
+				// Already "Normal", just complete the request
+				//
+				slot_context->attn_led_completion.failed = HP_FALSE;
+				slot_context->attn_led_completion.done = TRUE;
+			}
+			//
+			// While waitimg on a request here, the Attn LED should already be On/Off, but...
+			//
+			else {
+				//
+				// Grab Command MUTEX to set Attn LED to "Normal" (On/Off) state
+				//
+				slot_context->attn_led_function = (SLOT_STATE_FUNCTION)hp_wait_for_attn_led_normal_cmd_available;
+			}
+		}
+
+		//
+		// Allow next SW-initiated request while processing this one
+		//
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		hp_clear_slot_event_bit(slot_context, ATTN_LED_REQUEST_EVENT);
+		spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+	}
+	// attn_led_problem_event: Detected, Resolved
+	else if (slot_context->slot_event_bits & ATTN_LED_PROBLEM_EVENT){
+		//
+		// Set completion info for HW-initiated request
+		//
+		slot_context->attn_led_completion.hw_initiated = TRUE;
+		slot_context->attn_led_completion.type = SHPC_ASYNC_LED_NORMAL;
+		slot_context->attn_led_completion.timeout = 0;
+		slot_context->attn_led_completion.request_context = NULL;
+
+		//
+		// Grab Command MUTEX to update Attention LED (On/Off)
+		//
+		slot_context->attn_led_function = (SLOT_STATE_FUNCTION)hp_wait_for_attn_led_normal_cmd_available;
+	}
+	else {	// exit_request_event
+		status = STATUS_UNSUCCESSFUL;
+		dbg("%s -->EXIT_REQUEST: slot_id[ %d:%d ]", __FUNCTION__,
+			shpc_context->shpc_instance, slot_context->slot_number-1 );
+	}
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_wait_for_attn_led_blink_cmd_available() @ PASSIVE_LEVEL
+//
+// ****************************************************************************
+long
+hp_wait_for_attn_led_blink_cmd_available(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+	)
+{
+	unsigned long old_irq_flags;
+	long status = STATUS_SUCCESS;
+	union SHPC_COMMAND_WREG command_reg;
+
+	dbg("%s -->slot_id[ %d:%d ]", __FUNCTION__, shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Wait for Command Available MUTEX
+	//
+	//down_interruptible(&slot_context->cmd_acquire_mutex);
+	hp_set_slot_event_bit(slot_context, LED_CMD_ACQUIRE_EVENT);
+	wake_up_interruptible(&slot_context->led_cmd_acquire_event);
+
+	wait_event_interruptible(slot_context->slot_event,
+		((shpc_context->shpc_event_bits & LED_CMD_AVAILABLE_MUTEX_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	// cmd_available_mutex
+	if(shpc_context->shpc_event_bits & LED_CMD_AVAILABLE_MUTEX_EVENT) {
+		//
+		// Clear Completion EVENT before issuing next command
+		//
+		spin_lock_irqsave( &shpc_context->shpc_spinlock, old_irq_flags );
+		hp_clear_shpc_event_bit(shpc_context, CMD_COMPLETION_EVENT);
+		spin_unlock_irqrestore( &shpc_context->shpc_spinlock, old_irq_flags );
+
+		//
+		// Blink Attention LED
+		//
+		command_reg.Slot.code = SHPC_SLOT_OPERATION;
+		command_reg.Slot.power_led = SHPC_led_NO_CHANGE;
+		command_reg.Slot.attention_led = SHPC_LED_BLINK;
+		command_reg.Slot.state = SHPC_SLOT_NO_CHANGE;
+		command_reg.Slot.TGT = slot_context->slot_number;
+		writew(command_reg.AsWord, shpc_context->mmio_base_addr + SHPC_COMMAND_REG_OFFSET);
+
+		//
+		// Wait for command to complete (while holding MUTEX)
+		//
+		slot_context->attn_led_function = (SLOT_STATE_FUNCTION)hp_wait_for_attn_led_blink_cmd_completion;
+	}
+	// exit_request_event
+	else {
+		//
+		// Release Command MUTEX
+		//
+		hp_set_slot_event_bit(slot_context, LED_CMD_RELEASE_EVENT);
+		wake_up_interruptible(&slot_context->led_cmd_release_event);
+		status = STATUS_UNSUCCESSFUL;
+	}
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_wait_for_attn_led_blink_cmd_completion() @ PASSIVE_LEVEL
+//
+// ****************************************************************************
+long
+hp_wait_for_attn_led_blink_cmd_completion(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+	)
+{
+	long status = STATUS_SUCCESS;
+	union SLOT_STATUS_INFO slot_status;
+	union SHPC_STATUS_WREG status_reg;
+
+	dbg("%s -->slot_id[ %d:%d ]", __FUNCTION__, shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Setup our timer
+	//
+	hp_clear_slot_event_bit(slot_context, LED_TIMER1_EVENT);
+	slot_context->led_timer1.data = (unsigned long)slot_context;
+	slot_context->led_timer1.function = hp_led_timer1_func;
+	slot_context->led_timer1.expires = jiffies + ONE_SEC_TIMEOUT;
+	add_timer(&slot_context->led_timer1);
+
+	//
+	// Wait for Command Completion EVENT while holding MUTEX
+	//
+	wait_event_interruptible(slot_context->slot_event,
+		((shpc_context->shpc_event_bits & CMD_COMPLETION_EVENT) ||
+		(slot_context->slot_event_bits & LED_TIMER1_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	if (!(slot_context->slot_event_bits & LED_TIMER1_EVENT)) {
+		//
+		// delete the timer because we got an event other than the timer
+		//
+		del_timer_sync(&slot_context->led_timer1);
+	}
+
+	if(shpc_context->shpc_event_bits & CMD_COMPLETION_EVENT) {
+		// cmd_completion_event, timeout
+		if ((shpc_context->shpc_event_bits & CMD_COMPLETION_EVENT) || (slot_context->slot_event_bits & LED_TIMER1_EVENT)) {
+			//
+			// Command completed OK?
+			//
+			status_reg.AsWord = readw(shpc_context->mmio_base_addr + SHPC_STATUS_REG_OFFSET);
+
+			if( status_reg.x.BSY == SHPC_STATUS_CLEARED &&
+				status_reg.x.INVCMD_ERR == SHPC_STATUS_CLEARED ) {
+				//
+				// Call Completion Callback()
+				//
+				hp_QuerySlotStatus(	shpc_context, slot_context->slot_number - 1, &slot_status );
+				slot_status.x.lu_request_failed = HP_FALSE;
+				shpc_context->async_callback(
+					shpc_context->driver_context,
+					slot_context->slot_number - 1,
+					SHPC_ASYNC_LED_LOCATE,
+					slot_status,
+					slot_context->attn_led_completion.request_context );
+
+				//
+				// Signal registered user EVENT
+				//
+				hp_signal_user_event( shpc_context );
+
+				//
+				// Wait for specified timeout (in seconds)
+				//
+				slot_context->attn_led_function = (SLOT_STATE_FUNCTION)hp_wait_for_attn_led_blink_timeout;
+			}
+			else {
+				//
+				// Fail on-going request
+				//
+				slot_context->attn_led_completion.failed = HP_TRUE;
+				slot_context->attn_led_completion.done = TRUE;
+
+				//
+				// Grab Command MUTEX to make sure Attn LED gets back to "Normal" (On/Off)
+				//
+				dbg("%s -->CMD_ERROR: slot_id[ %d:%d ]  Cmd[ %X ]", __FUNCTION__,
+					shpc_context->shpc_instance, slot_context->slot_number-1, status_reg.AsWord );
+				slot_context->attn_led_function = (SLOT_STATE_FUNCTION)hp_wait_for_attn_led_back_to_normal_cmd_available;
+			}
+
+		// exit_request_event
+		}
+		else {
+			status = STATUS_UNSUCCESSFUL;
+		}
+	}
+	//
+	// Release Command MUTEX
+	//
+	hp_set_slot_event_bit(slot_context, LED_CMD_RELEASE_EVENT);
+	wake_up_interruptible(&slot_context->led_cmd_release_event);
+
+	return status;
+}
+
+// ****************************************************************************
+//
+// hp_wait_for_attn_led_blink_timeout() @ PASSIVE_LEVEL
+//
+// ****************************************************************************
+long
+hp_wait_for_attn_led_blink_timeout(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+	)
+{
+	unsigned long old_irq_flags;
+	long status = STATUS_SUCCESS;
+	union SLOT_STATUS_INFO slot_status;
+
+	dbg("%s -->slot_id[ %d:%d ]", __FUNCTION__, shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Setup our timer
+	//
+	hp_clear_slot_event_bit(slot_context, LED_TIMER2_EVENT);
+	slot_context->led_timer2.data = (unsigned long)slot_context;
+	slot_context->led_timer2.function = hp_led_timer2_func;
+	slot_context->led_timer2.expires = jiffies + (ONE_SEC_INCREMENT * slot_context->attn_led_completion.timeout);
+	add_timer(&slot_context->led_timer2);
+
+	//
+	// Wait for specified timeout ( in seconds )
+	//
+	wait_event_interruptible(slot_context->slot_event,
+		((slot_context->slot_event_bits & ATTN_LED_REQUEST_EVENT) ||
+		(slot_context->slot_event_bits & LED_TIMER2_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	if (!(slot_context->slot_event_bits & LED_TIMER2_EVENT)) {
+		//
+		// delete the timer because we got an event other than the timer
+		//
+		hp_clear_slot_event_bit(slot_context, LED_TIMER2_EVENT);
+		del_timer_sync(&slot_context->led_timer2);
+	}
+
+	// AttnLEDRequestEvent
+	if(slot_context->slot_event_bits & ATTN_LED_REQUEST_EVENT) {
+		//
+		// Set completion info for SW-initiated request
+		//
+		slot_context->attn_led_completion.hw_initiated = FALSE;
+		slot_context->attn_led_completion.type = slot_context->attn_led_request.type;
+		slot_context->attn_led_completion.timeout = slot_context->attn_led_request.timeout;
+		slot_context->attn_led_completion.request_context = slot_context->attn_led_request.request_context;
+
+		//
+		// Request to cancel locate?
+		//
+		if( slot_context->attn_led_request.type == SHPC_ASYNC_LED_NORMAL ) {
+			dbg("%s -->LED_NORMAL_REQ: slot_id[ %d:%d ]", __FUNCTION__,
+				shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+			//
+			// Grab Command MUTEX to set Attn LED at "Normal" (On/Off) state
+			//
+			slot_context->attn_led_function = (SLOT_STATE_FUNCTION)&hp_wait_for_attn_led_normal_cmd_available;
+
+			//
+			// Allow next SW-initiated request while processing this one
+			//
+			spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+			hp_clear_slot_event_bit(slot_context, ATTN_LED_REQUEST_EVENT);
+			spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+		}
+		//
+		// Already located (Attn LED blinking), just re-start timeout
+		//
+		else {
+			dbg("%s -->LED_LOCATE_REQ: slot_id[ %d:%d ]", __FUNCTION__,
+				shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+			//
+			// Allow next SW-initiated request before invoking callback, since next
+			// request may be sent in the context of this thread.
+			//
+			spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+			hp_clear_slot_event_bit(slot_context, ATTN_LED_REQUEST_EVENT);
+			spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+
+			//
+			// Call Completion Callback()
+			//
+			hp_QuerySlotStatus(	shpc_context, slot_context->slot_number - 1, &slot_status );
+			slot_status.x.lu_request_failed = HP_FALSE;
+			shpc_context->async_callback(
+				shpc_context->driver_context,
+				slot_context->slot_number - 1,
+				SHPC_ASYNC_LED_LOCATE,
+				slot_status,
+				slot_context->attn_led_completion.request_context );
+
+			//
+			// Signal registered user EVENT
+			//
+			hp_signal_user_event( shpc_context );
+		}
+	}
+	// timeout
+	else if (slot_context->slot_event_bits & LED_TIMER2_EVENT) {
+		//
+		// Set completion info for HW-initiated request
+		//
+		slot_context->attn_led_completion.hw_initiated = TRUE;
+		slot_context->attn_led_completion.type = SHPC_ASYNC_LED_NORMAL;
+		slot_context->attn_led_completion.timeout = 0;
+		slot_context->attn_led_completion.request_context = NULL;
+
+		//
+		// Grab Command MUTEX to set Attn LED at "Normal" (On/Off) state
+		//
+		slot_context->attn_led_function = (SLOT_STATE_FUNCTION)hp_wait_for_attn_led_normal_cmd_available;
+
+	}
+	// exit_request_event
+	else {
+	status = STATUS_UNSUCCESSFUL;
+	}
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_wait_for_attn_led_normal_cmd_available() @ PASSIVE_LEVEL
+//
+// ****************************************************************************
+long
+hp_wait_for_attn_led_normal_cmd_available(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+	)
+{
+	unsigned long old_irq_flags;
+	long status = STATUS_SUCCESS;
+	union SHPC_COMMAND_WREG command_reg;
+
+	dbg("%s -->slot_id[ %d:%d ]", __FUNCTION__, shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Wait for Command Available MUTEX
+	//
+	//down_interruptible(&slot_context->cmd_acquire_mutex);
+	hp_set_slot_event_bit(slot_context, LED_CMD_ACQUIRE_EVENT);
+	wake_up_interruptible(&slot_context->led_cmd_acquire_event);
+
+	wait_event_interruptible(slot_context->slot_event,
+		((shpc_context->shpc_event_bits & LED_CMD_AVAILABLE_MUTEX_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	//
+	// cmd_available_mutex
+	//
+	if(shpc_context->shpc_event_bits & LED_CMD_AVAILABLE_MUTEX_EVENT) {
+		//
+		// Clear Completion EVENT before issuing next command
+		//
+		spin_lock_irqsave( &shpc_context->shpc_spinlock, old_irq_flags );
+		hp_clear_shpc_event_bit(shpc_context, CMD_COMPLETION_EVENT);
+		spin_unlock_irqrestore( &shpc_context->shpc_spinlock, old_irq_flags );
+
+		//
+		// Update Attention LED
+		//
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		command_reg.Slot.attention_led = slot_context->problem_detected ?
+			SHPC_LED_ON : SHPC_LED_OFF;
+		hp_clear_slot_event_bit(slot_context, ATTN_LED_PROBLEM_EVENT);
+		spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+		command_reg.Slot.code = SHPC_SLOT_OPERATION;
+		command_reg.Slot.power_led = SHPC_led_NO_CHANGE;
+		command_reg.Slot.state = SHPC_SLOT_NO_CHANGE;
+		command_reg.Slot.TGT = slot_context->slot_number;
+		writew(command_reg.AsWord, shpc_context->mmio_base_addr + SHPC_COMMAND_REG_OFFSET);
+
+		//
+		// Wait for command to complete (while holding MUTEX)
+		//
+		slot_context->attn_led_function = (SLOT_STATE_FUNCTION)hp_wait_for_attn_led_normal_cmd_completion;
+	}
+	//
+	// exit_request_event
+	//
+	else {
+		//
+		// Release Command MUTEX
+		//
+		hp_set_slot_event_bit(slot_context, LED_CMD_RELEASE_EVENT);
+		wake_up_interruptible(&slot_context->led_cmd_release_event);
+		status = STATUS_UNSUCCESSFUL;
+	}
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_wait_for_attn_led_normal_cmd_completion() @ PASSIVE_LEVEL
+//
+// ****************************************************************************
+long
+hp_wait_for_attn_led_normal_cmd_completion(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+	)
+{
+	long status = STATUS_SUCCESS;
+	union SHPC_STATUS_WREG status_reg;
+
+	dbg("%s -->slot_id[ %d:%d ]", __FUNCTION__, shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Setup our timer
+	//
+	hp_clear_slot_event_bit(slot_context, LED_TIMER3_EVENT);
+	slot_context->led_timer3.data = (unsigned long)slot_context;
+	slot_context->led_timer3.function = hp_led_timer3_func;
+	slot_context->led_timer3.expires = jiffies + ONE_SEC_TIMEOUT;
+	add_timer(&slot_context->led_timer3);
+
+	//
+	// Wait for Command Completion EVENT while holding MUTEX
+	//
+	wait_event_interruptible(slot_context->slot_event,
+		((shpc_context->shpc_event_bits & CMD_COMPLETION_EVENT) ||
+		(slot_context->slot_event_bits & LED_TIMER3_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	if (!(slot_context->slot_event_bits & LED_TIMER3_EVENT)) {
+		//
+		// delete the timer because we got an event other than the timer
+		//
+		del_timer_sync(&slot_context->led_timer3);
+	}
+
+	//
+	// cmd_completion_event, timeout
+	//
+	if((shpc_context->shpc_event_bits & CMD_COMPLETION_EVENT) ||
+	   (slot_context->slot_event_bits & LED_TIMER3_EVENT)) {
+		//
+		// Command completed OK?
+		//
+		status_reg.AsWord = readw(shpc_context->mmio_base_addr + SHPC_STATUS_REG_OFFSET);
+
+		if( status_reg.x.BSY == SHPC_STATUS_CLEARED &&
+			status_reg.x.INVCMD_ERR == SHPC_STATUS_CLEARED ) {
+			//
+			// Complete succesful ENABLE request
+			//
+			slot_context->attn_led_completion.failed = HP_FALSE;
+			slot_context->attn_led_completion.done = TRUE;
+			slot_context->attn_led_function = (SLOT_STATE_FUNCTION)hp_wait_for_attn_led_request;
+		}
+		else {
+			//
+			// Fail on-going request
+			//
+			slot_context->attn_led_completion.failed = HP_TRUE;
+			slot_context->attn_led_completion.done = TRUE;
+
+			//
+			// Grab Command MUTEX to make sure Attn LED gets back to "Normal" (On/Off)
+			//
+			dbg("%s -->CMD_ERROR: slot_id[ %d:%d ]  Cmd[ %X ]", __FUNCTION__,
+				shpc_context->shpc_instance, slot_context->slot_number-1, status_reg.AsWord );
+			slot_context->attn_led_function = (SLOT_STATE_FUNCTION)hp_wait_for_attn_led_back_to_normal_cmd_available;
+		}
+	}
+	//
+	// exit_request_event
+	//
+	else {
+		status = STATUS_UNSUCCESSFUL;
+	}
+	//
+	// Release Command MUTEX
+	//
+	hp_set_slot_event_bit(slot_context, LED_CMD_RELEASE_EVENT);
+   	wake_up_interruptible(&slot_context->led_cmd_release_event);
+
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_wait_for_attn_led_back_to_normal_cmd_available() @ PASSIVE_LEVEL
+//
+// ****************************************************************************
+long
+hp_wait_for_attn_led_back_to_normal_cmd_available(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+	)
+{
+	unsigned long old_irq_flags;
+	long status = STATUS_SUCCESS;
+	union SHPC_COMMAND_WREG command_reg;
+
+	dbg("%s -->slot_id[ %d:%d ]", __FUNCTION__, shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Wait for Command Available MUTEX
+	//
+	//down_interruptible(&slot_context->cmd_acquire_mutex);
+	hp_set_slot_event_bit(slot_context, LED_CMD_ACQUIRE_EVENT);
+	wake_up_interruptible(&slot_context->led_cmd_acquire_event);
+
+	wait_event_interruptible(slot_context->slot_event,
+		((shpc_context->shpc_event_bits & LED_CMD_AVAILABLE_MUTEX_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	//
+	// cmd_available_mutex
+	//
+	if(shpc_context->shpc_event_bits & LED_CMD_AVAILABLE_MUTEX_EVENT) {
+		//
+		// Clear Completion EVENT before issuing next command
+		//
+		spin_lock_irqsave( &shpc_context->shpc_spinlock, old_irq_flags );
+		hp_clear_shpc_event_bit(shpc_context, CMD_COMPLETION_EVENT);
+		spin_unlock_irqrestore( &shpc_context->shpc_spinlock, old_irq_flags );
+
+		//
+		// Update Attention LED
+		//
+		spin_lock_irqsave( &slot_context->slot_spinlock, old_irq_flags );
+		command_reg.Slot.attention_led = slot_context->problem_detected ?
+			SHPC_LED_ON : SHPC_LED_OFF;
+		hp_clear_slot_event_bit(slot_context, ATTN_LED_PROBLEM_EVENT);
+		spin_unlock_irqrestore( &slot_context->slot_spinlock, old_irq_flags );
+		command_reg.Slot.code = SHPC_SLOT_OPERATION;
+		command_reg.Slot.power_led = SHPC_led_NO_CHANGE;
+		command_reg.Slot.state = SHPC_SLOT_NO_CHANGE;
+		command_reg.Slot.TGT = slot_context->slot_number;
+		writew(command_reg.AsWord, shpc_context->mmio_base_addr + SHPC_COMMAND_REG_OFFSET);
+
+		//
+		// Wait for command to complete (while holding MUTEX)
+		//
+		slot_context->attn_led_function = (SLOT_STATE_FUNCTION)hp_wait_for_attn_led_back_to_normal_cmd_completion;
+	}
+	//
+	// exit_request_event
+	//
+	else {
+		//
+		// Release Command MUTEX
+		//
+		hp_set_slot_event_bit(slot_context, LED_CMD_RELEASE_EVENT);
+		wake_up_interruptible(&slot_context->led_cmd_release_event);
+		status = STATUS_UNSUCCESSFUL;
+	}
+	return status;
+}
+
+
+// ****************************************************************************
+//
+// hp_wait_for_attn_led_back_to_normal_cmd_completion() @ PASSIVE_LEVEL
+//
+// ****************************************************************************
+long
+hp_wait_for_attn_led_back_to_normal_cmd_completion(
+	struct shpc_context* shpc_context,
+	struct slot_context* slot_context
+	)
+{
+	long status = STATUS_SUCCESS;
+
+	dbg("%s -->slot_id[ %d:%d ]", __FUNCTION__, shpc_context->shpc_instance, slot_context->slot_number-1 );
+
+	//
+	// Setup our timer
+	//
+	hp_clear_slot_event_bit(slot_context, LED_TIMER4_EVENT);
+	slot_context->led_timer4.data = (unsigned long)slot_context;
+	slot_context->led_timer4.function = hp_led_timer4_func;
+	slot_context->led_timer4.expires = jiffies + ONE_SEC_TIMEOUT;
+	add_timer(&slot_context->led_timer4);
+
+	//
+	// Wait for Command Completion EVENT while holding MUTEX
+	//
+	wait_event_interruptible(slot_context->slot_event,
+		((shpc_context->shpc_event_bits & CMD_COMPLETION_EVENT) ||
+		(slot_context->slot_event_bits & LED_TIMER4_EVENT) ||
+		(shpc_context->shpc_event_bits & EXIT_REQUEST_EVENT)));
+
+	if (!(slot_context->slot_event_bits & LED_TIMER4_EVENT)) {
+		//
+		// delete the timer because we got an event other than the timer
+		//
+		del_timer_sync(&slot_context->led_timer4);
+	}
+
+	//
+	// cmd_completion_event, timeout
+	//
+	if((shpc_context->shpc_event_bits & CMD_COMPLETION_EVENT) ||
+	   (slot_context->slot_event_bits & LED_TIMER4_EVENT)) {
+		slot_context->attn_led_function = (SLOT_STATE_FUNCTION)hp_wait_for_attn_led_request;
+	}
+	//
+	// exit_request_event
+	//
+	else {
+		status = STATUS_UNSUCCESSFUL;
+	}
+	//
+	// Release Command MUTEX
+	//
+	hp_set_slot_event_bit(slot_context, LED_CMD_RELEASE_EVENT);
+	wake_up_interruptible(&slot_context->led_cmd_release_event);
+
+	return status;
+}
diff -purN linux-2.5/drivers/pci/hotplug/amdshpc_pci.c usb-2.5/drivers/pci/hotplug/amdshpc_pci.c
--- linux-2.5/drivers/pci/hotplug/amdshpc_pci.c	1970-01-01 00:00:00.000000000 +0000
+++ usb-2.5/drivers/pci/hotplug/amdshpc_pci.c	2003-08-28 23:06:29.000000000 +0000
@@ -0,0 +1,3513 @@
+/* 
+ * Copyright (C) 2001,2003 Greg Kroah-Hartman (greg@kroah.com)
+ * Copyright (C) 2001,2003 IBM Corp.
+ * Copyright (C) 2002-2003 Advanced Micro Devices
+ *
+ * YOUR USE OF THIS CODE IS SUBJECT TO THE TERMS
+ * AND CONDITIONS OF THE GNU GENERAL PUBLIC
+ * LICENSE FOUND IN THE "GPL.TXT" FILE THAT IS
+ * INCLUDED WITH THIS FILE AND POSTED AT
+ * http://www.gnu.org/licenses/gpl.html
+ *
+ * Send feedback to <greg@kroah.com> <david.keck@amd.com>
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/proc_fs.h>
+#include <linux/pci.h>
+#include "amdshpc.h"
+#include "../pci.h"
+#include "../../../arch/i386/pci/pci.h"
+
+u8 amdshpc_nic_irq;
+u8 amdshpc_disk_irq;
+
+static u16 unused_IRQ;
+
+extern struct controller *amdshpc_ctrl_list;	/* = NULL */
+extern struct pci_func *amdshpc_slot_list[256];
+
+static int bridge_slot_remove(struct pci_func *bridge);
+static int is_bridge(struct pci_func * func);
+static int update_slot_info (struct controller  *ctrl, struct slot *slot);
+static int slot_remove(struct pci_func * old_slot);
+static u32 configure_new_device(struct controller * ctrl, struct pci_func *func,u8 behind_bridge, struct resource_lists *resources);
+static int configure_new_function(struct controller * ctrl, struct pci_func *func,u8 behind_bridge, struct resource_lists *resources);
+int amdshpc_process_SI (struct controller *ctrl, struct pci_func *func);
+
+static u16 unused_IRQ;
+
+/**
+ * board_added - Called after a board has been added to the system.
+ *
+ * Turns power on for the board
+ * Configures board
+ *
+ */
+static u32 board_added(struct pci_func * func, struct controller * ctrl)
+{
+	int index;
+	u32 temp_register = 0xFFFFFFFF;
+	u32 rc = 0;
+	struct pci_func *new_slot = NULL;
+	struct resource_lists res_lists;
+
+	dbg("%s: func->device, slot_offset = %d, %d \n",__FUNCTION__,
+		func->device, ctrl->slot_device_offset);
+
+	// Get vendor/device ID u32
+	rc = pci_bus_read_config_dword(ctrl->pci_bus, PCI_DEVFN(func->device, func->function), PCI_VENDOR_ID, &temp_register);
+	dbg("%s: pci_bus_read_config_dword returns %d\n",__FUNCTION__, rc);
+	dbg("%s: temp_register is %x\n",__FUNCTION__, temp_register);
+
+	if (rc != 0) {
+		// Something's wrong here
+		temp_register = 0xFFFFFFFF;
+		dbg("%s: temp register set to %x by error\n",__FUNCTION__, temp_register);
+	}
+	// Preset return code.  It will be changed later if things go okay.
+	rc = NO_ADAPTER_PRESENT;
+
+	// All F's is an empty slot or an invalid board
+	if (temp_register != 0xFFFFFFFF) {	  // Check for a board in the slot
+		res_lists.io_head 	= ctrl->io_head;
+		res_lists.mem_head 	= ctrl->mem_head;
+		res_lists.p_mem_head = ctrl->p_mem_head;
+		res_lists.bus_head 	= ctrl->bus_head;
+		res_lists.irqs = NULL;
+
+		rc = configure_new_device(ctrl, func, 0, &res_lists);
+
+		dbg("%s: back from configure_new_device\n",__FUNCTION__);
+		ctrl->io_head 	= res_lists.io_head;
+		ctrl->mem_head 	= res_lists.mem_head;
+		ctrl->p_mem_head = res_lists.p_mem_head;
+		ctrl->bus_head 	= res_lists.bus_head;
+
+		amdshpc_resource_sort_and_combine(&(ctrl->mem_head));
+		amdshpc_resource_sort_and_combine(&(ctrl->p_mem_head));
+		amdshpc_resource_sort_and_combine(&(ctrl->io_head));
+		amdshpc_resource_sort_and_combine(&(ctrl->bus_head));
+
+		if (rc) {
+			// Something went wrong; disable slot
+//			TO_DO_amd_disable_slot();
+			return(rc);
+		} else {
+			amdshpc_save_slot_config(ctrl, func);
+		}
+
+
+		func->status = 0;
+		func->switch_save = 0x10;
+		func->is_a_board = 0x01;
+
+		//next, we will instantiate the linux pci_dev structures (with appropriate driver notification, if already present)
+		dbg("%s: configure linux pci_dev structure\n",__FUNCTION__);
+		index = 0;
+		do {
+			new_slot = amdshpc_slot_find(ctrl->bus, func->device, index++);
+			if (new_slot && !new_slot->pci_dev) {
+				amdshpc_configure_device(ctrl, new_slot);
+			}
+		} while (new_slot);
+	} else {
+		// Something went wrong; disable slot
+//		TO_DO_amd_disable_slot();
+		return(rc);
+	}
+	return 0;
+}
+
+
+/**
+ * remove_board - Returns resources
+ */
+static u32 remove_board(struct pci_func * func, u32 replace_flag, struct controller  * ctrl)
+{
+	int index;
+	u8 skip = 0;
+	u8 device;
+	u8 hp_slot;
+	u32 rc;
+	struct resource_lists res_lists;
+	struct pci_func *temp_func;
+
+	if (func == NULL)
+		return(1);
+
+	if (amdshpc_unconfigure_device(func))
+		return(1);
+
+	device = func->device;
+
+	hp_slot = func->device - ctrl->slot_device_offset;
+	dbg("In %s, hp_slot = %d\n",__FUNCTION__, hp_slot);
+
+	// When we get here, it is safe to change base Address Registers.
+	// We will attempt to save the base Address Register Lengths
+	if (replace_flag || !ctrl->add_support)
+		rc = amdshpc_save_base_addr_length(ctrl, func);
+	else if (!func->bus_head && !func->mem_head &&
+		 !func->p_mem_head && !func->io_head) {
+		// Here we check to see if we've saved any of the board's
+		// resources already.  If so, we'll skip the attempt to
+		// determine what's being used.
+		index = 0;
+		temp_func = amdshpc_slot_find(func->bus, func->device, index++);
+		while (temp_func) {
+			if (temp_func->bus_head || temp_func->mem_head
+				|| temp_func->p_mem_head || temp_func->io_head) {
+				skip = 1;
+				break;
+			}
+			temp_func = amdshpc_slot_find(temp_func->bus, temp_func->device, index++);
+		}
+
+		if (!skip)
+			rc = amdshpc_save_used_resources(ctrl, func);
+	}
+	// Change status to shutdown
+	if (func->is_a_board)
+		func->status = 0x01;
+	func->configured = 0;
+
+//	TO_DO_amd_disable_slot(ctrl, hp_slot);
+
+	if (!replace_flag && ctrl->add_support) {
+		while (func) {
+			res_lists.io_head = ctrl->io_head;
+			res_lists.mem_head = ctrl->mem_head;
+			res_lists.p_mem_head = ctrl->p_mem_head;
+			res_lists.bus_head = ctrl->bus_head;
+
+			amdshpc_return_board_resources(func, &res_lists);
+
+			ctrl->io_head = res_lists.io_head;
+			ctrl->mem_head = res_lists.mem_head;
+			ctrl->p_mem_head = res_lists.p_mem_head;
+			ctrl->bus_head = res_lists.bus_head;
+
+			amdshpc_resource_sort_and_combine(&(ctrl->mem_head));
+			amdshpc_resource_sort_and_combine(&(ctrl->p_mem_head));
+			amdshpc_resource_sort_and_combine(&(ctrl->io_head));
+			amdshpc_resource_sort_and_combine(&(ctrl->bus_head));
+
+			if (is_bridge(func)) {
+				bridge_slot_remove(func);
+			} else
+				slot_remove(func);
+
+			func = amdshpc_slot_find(ctrl->bus, device, 0);
+		}
+
+		// Setup slot structure with entry for empty slot
+		func = amdshpc_slot_create(ctrl->bus);
+
+		if (func == NULL) {
+			// Out of memory
+			return(1);
+		}
+
+		func->bus = ctrl->bus;
+		func->device = device;
+		func->function = 0;
+		func->configured = 0;
+		func->switch_save = 0x10;
+		func->is_a_board = 0;
+		func->p_task_event = NULL;
+	}
+	return 0;
+}
+
+
+/*
+ * find_slot
+ */
+static inline struct slot* find_slot (struct controller* ctrl, u8 device)
+{
+	struct slot *slot;
+
+	dbg("%s", __FUNCTION__);
+	if (!ctrl)
+		return NULL;
+
+	slot = ctrl->slot;
+
+	while (slot && (slot->device != device)) {
+		slot = slot->next;
+	}
+
+	return slot;
+}
+
+// board insertion
+int amdshpc_process_SI (struct controller *ctrl, struct pci_func *func)
+{
+	u8 device, hp_slot;
+	u16 temp_word;
+	u32 tempdword;
+	int rc;
+	struct slot* p_slot;
+	int physical_slot = 0;
+
+	dbg("%s  0", __FUNCTION__);
+	if (!ctrl)
+		return(1);
+
+	tempdword = 0;
+
+	device = func->device;
+	hp_slot = device - ctrl->slot_device_offset;
+	p_slot = find_slot(ctrl, device);
+	if (p_slot) {
+		physical_slot = p_slot->number;
+	}
+
+	if (tempdword & (0x01 << hp_slot)) {
+		dbg("%s  1", __FUNCTION__);
+		return(1);
+	}
+
+	// add board
+	slot_remove(func);
+
+	func = amdshpc_slot_create(ctrl->bus);
+	dbg("%s  2",__FUNCTION__);
+	if (func == NULL) {
+		dbg("%s 3",__FUNCTION__);
+		return(1);
+	}
+
+	func->bus = ctrl->bus;
+	func->device = device;
+	func->function = 0;
+	func->configured = 0;
+	func->is_a_board = 1;
+
+	// We have to save the presence info for these slots
+	temp_word = ctrl->ctrl_int_comp >> 16;
+	func->presence_save = (temp_word >> hp_slot) & 0x01;
+	func->presence_save |= (temp_word >> (hp_slot + 7)) & 0x02;
+
+	dbg("%s 4",__FUNCTION__);
+	if (ctrl->ctrl_int_comp & (0x1L << hp_slot)) {
+		dbg("%s 5",__FUNCTION__);
+		func->switch_save = 0;
+	} else {
+		dbg("%s 6",__FUNCTION__);
+		func->switch_save = 0x10;
+	}
+
+	rc = board_added(func, ctrl);
+	dbg("%s 7 rc=%d",__FUNCTION__,rc);
+	if (rc) {
+		dbg("%s 8",__FUNCTION__);
+		if (is_bridge(func)) {
+			dbg("%s 9",__FUNCTION__);
+			bridge_slot_remove(func);
+		} else {
+			dbg("%s 10",__FUNCTION__);
+			slot_remove(func);
+		}
+
+		// Setup slot structure with entry for empty slot
+		func = amdshpc_slot_create(ctrl->bus);
+
+		dbg("%s 11",__FUNCTION__);
+		if (func == NULL) {
+			// Out of memory
+			return(1);
+		}
+
+		func->bus = ctrl->bus;
+		func->device = device;
+		func->function = 0;
+		func->configured = 0;
+		func->is_a_board = 0;
+
+		// We have to save the presence info for these slots
+		temp_word = ctrl->ctrl_int_comp >> 16;
+		func->presence_save = (temp_word >> hp_slot) & 0x01;
+		func->presence_save |=
+		(temp_word >> (hp_slot + 7)) & 0x02;
+
+		if (ctrl->ctrl_int_comp & (0x1L << hp_slot)) {
+			dbg("%s 12",__FUNCTION__);
+			func->switch_save = 0;
+		} else {
+			dbg("%s 13",__FUNCTION__);
+			func->switch_save = 0x10;
+		}
+	}
+
+	if (rc) {
+		dbg("%s: rc = %d\n",__FUNCTION__, rc);
+	}
+
+	if (p_slot){
+		dbg("%s 14",__FUNCTION__);
+		update_slot_info(ctrl, p_slot);
+	}
+
+	return rc;
+}
+
+// Disable Slot
+int amdshpc_process_SS (struct controller *ctrl, struct pci_func *func)
+{
+	u8 device, class_code, header_type, BCR;
+	u8 index = 0;
+	u8 replace_flag;
+	u32 rc = 0;
+	struct slot* p_slot;
+	int physical_slot=0;
+
+	dbg("%s 0",__FUNCTION__);
+	device = func->device;
+	func = amdshpc_slot_find(ctrl->bus, device, index++);
+	p_slot = find_slot(ctrl, device);
+	if (p_slot) {
+		physical_slot = p_slot->number;
+	}
+
+	// Make sure there are no video controllers here
+	while (func && !rc) {
+		dbg("%s 1..",__FUNCTION__);
+		// Check the Class Code
+		rc = pci_bus_read_config_byte(ctrl->pci_bus, PCI_DEVFN(func->device, func->function), 0x0B, &class_code);
+		dbg("%s 1.1 rc = %d  class_code = %02x",__FUNCTION__, rc, class_code);
+		if (rc){
+			dbg("%s 2",__FUNCTION__);
+			return rc;
+		}
+
+		if (class_code == PCI_BASE_CLASS_DISPLAY) {
+			/* Display/Video adapter (not supported) */
+			dbg("%s 3",__FUNCTION__);
+			rc = REMOVE_NOT_SUPPORTED;
+		} else {
+			dbg("%s 3.5",__FUNCTION__);
+			// See if it's a bridge
+			rc = pci_bus_read_config_byte(ctrl->pci_bus, PCI_DEVFN(func->device, func->function), PCI_HEADER_TYPE, &header_type);
+			if (rc){
+				dbg("%s 4",__FUNCTION__);
+				return rc;
+			}
+
+			// If it's a bridge, check the VGA Enable bit
+			if ((header_type & 0x7F) == PCI_HEADER_TYPE_BRIDGE) {
+				dbg("%s 4.5",__FUNCTION__);
+				rc = pci_bus_read_config_byte(ctrl->pci_bus, PCI_DEVFN(func->device, func->function), PCI_BRIDGE_CONTROL, &BCR);
+				if (rc){
+					dbg("%s 5",__FUNCTION__);
+					return rc;
+				}
+
+				dbg("%s 5.5",__FUNCTION__);
+				// If the VGA Enable bit is set, remove isn't supported
+				if (BCR & PCI_BRIDGE_CTL_VGA) {
+					dbg("%s 6",__FUNCTION__);
+					rc = REMOVE_NOT_SUPPORTED;
+				}
+			}
+		}
+
+		func = amdshpc_slot_find(ctrl->bus, device, index++);
+		dbg("%s 7",__FUNCTION__);
+	}
+
+	func = amdshpc_slot_find(ctrl->bus, device, 0);
+	dbg("%s 8",__FUNCTION__);
+	if ((func != NULL) && !rc) {
+		dbg("%s 9",__FUNCTION__);
+		//FIXME: Replace flag should be passed into process_SS
+		replace_flag = !(ctrl->add_support);
+		rc = remove_board(func, replace_flag, ctrl);
+	} else if (!rc) {
+		dbg("%s 10",__FUNCTION__);
+		rc = 1;
+	}
+
+	if (p_slot){
+		dbg("%s 11",__FUNCTION__);
+		update_slot_info(ctrl, p_slot);
+	}
+
+	dbg("%s 12",__FUNCTION__);
+	return(rc);
+}
+
+
+/*
+ * detect_HRT_floating_pointer
+ *
+ * find the Hot Plug Resource Table in the specified region of memory.
+ *
+ */
+static void *detect_HRT_floating_pointer(void *begin, void *end)
+{
+	void *fp;
+	void *endp;
+	u8 temp1, temp2, temp3, temp4;
+	int status = 0;
+
+	endp = (end - sizeof(struct hrt) + 1);
+
+	for (fp = begin; fp <= endp; fp += 16) {
+		temp1 = readb(fp + SIG0);
+		temp2 = readb(fp + SIG1);
+		temp3 = readb(fp + SIG2);
+		temp4 = readb(fp + SIG3);
+		if (temp1 == '$' &&
+			temp2 == 'H' &&
+			temp3 == 'R' &&
+			temp4 == 'T') {
+			status = 1;
+			dbg("%s -->temp string----> %c%c%c%c  at----->  %p\n", __FUNCTION__, temp1,temp2,temp3,temp4,fp);
+			break;
+		}
+	}
+
+	if (!status) {
+		fp = NULL;
+		dbg("%s -->Did not discover Hotplug Resource Table between start:%p  end:%p\n", __FUNCTION__, begin, end);
+		return fp;
+	}
+
+	dbg("%s -->Discovered Hotplug Resource Table at %p\n", __FUNCTION__, fp);
+	return fp;
+}
+
+/**
+ * amdshpc_slot_find - Looks for a node by bus, and device, multiple functions accessed
+ * @bus: bus to find
+ * @device: device to find
+ * @index: is 0 for first function found, 1 for the second...
+ *
+ * Returns pointer to the node if successful, %NULL otherwise.
+ */
+struct pci_func *amdshpc_slot_find(u8 bus, u8 device, u8 index) {
+	int found = -1;
+	struct pci_func *func;
+
+	func = amdshpc_slot_list[bus];
+	dbg("%s  amdshpc_slot_list[%02x] = %p", __FUNCTION__, bus, amdshpc_slot_list[bus]);
+	dbg("%s  bus, device, index  %x %d %d", __FUNCTION__, bus, device, index);
+
+	if ((func == NULL) || ((func->device == device) && (index == 0)))
+		return(func);
+
+	if (func->device == device)
+		found++;
+
+	while (func->next != NULL) {
+		func = func->next;
+
+		if (func->device == device)
+			found++;
+
+		if (found == index)
+			return(func);
+	}
+
+	return(NULL);
+}
+
+
+/*
+ * amdshpc_resource_sort_and_combine
+ *
+ * Sorts all of the nodes in the list in ascending order by
+ * their base addresses.  Also does garbage collection by
+ * combining adjacent nodes.
+ *
+ * returns 0 if success
+ */
+int amdshpc_resource_sort_and_combine(struct pci_resource **head)
+{
+	struct pci_resource *node1;
+	struct pci_resource *node2;
+	int out_of_order = 1;
+
+	dbg("%s: head = %p, *head = %p\n",__FUNCTION__, head, *head);
+
+	if (!(*head))
+		return(1);
+
+	dbg("%s -->*head->next = %p\n", __FUNCTION__,(*head)->next);
+
+	if (!(*head)->next)
+		return(0);	/* only one item on the list, already sorted! */
+
+	dbg("%s -->*head->base = 0x%x\n", __FUNCTION__,(*head)->base);
+	dbg("%s -->*head->next->base = 0x%x\n", __FUNCTION__,(*head)->next->base);
+	while (out_of_order) {
+		out_of_order = 0;
+
+		// Special case for swapping list head
+		if (((*head)->next) &&
+			((*head)->base > (*head)->next->base)) {
+			node1 = *head;
+			(*head) = (*head)->next;
+			node1->next = (*head)->next;
+			(*head)->next = node1;
+			out_of_order++;
+		}
+
+		node1 = (*head);
+
+		while (node1->next && node1->next->next) {
+			if (node1->next->base > node1->next->next->base) {
+				out_of_order++;
+				node2 = node1->next;
+				node1->next = node1->next->next;
+				node1 = node1->next;
+				node2->next = node1->next;
+				node1->next = node2;
+			} else
+				node1 = node1->next;
+		}
+	}  // End of out_of_order loop
+
+	node1 = *head;
+
+	while (node1 && node1->next) {
+		if ((node1->base + node1->length) == node1->next->base) {
+			// Combine
+			dbg("%s -->8..\n", __FUNCTION__);
+			node1->length += node1->next->length;
+			node2 = node1->next;
+			node1->next = node1->next->next;
+			kfree(node2);
+		} else
+			node1 = node1->next;
+	}
+
+	return(0);
+}
+
+
+/*
+ * amdshpc_find_available_resources
+ *
+ * Finds available memory, IO, and IRQ resources for programming
+ * devices which may be added to the system
+ * this function is for hot plug ADD!
+ *
+ * returns 0 if success
+ */
+int amdshpc_find_available_resources (struct controller *ctrl, void *rom_start)
+{
+	u8 temp;
+	u8 populated_slot=0;
+	u8 bridged_slot;
+	u8 slot_index;
+	void *one_slot;
+	struct pci_func *func = NULL;
+	int i = 10, index;
+	u32 temp_dword, rc;
+	struct pci_resource *mem_node;
+	struct pci_resource *p_mem_node;
+	struct pci_resource *io_node;
+	struct pci_resource *bus_node;
+	void *rom_resource_table;
+	struct shpc_context *shpc_context;
+
+	slot_index=0;
+
+	shpc_context = (struct shpc_context* ) ctrl->shpc_context;
+	rom_resource_table = detect_HRT_floating_pointer(rom_start, rom_start+0xffff);
+	dbg("%s -->rom_resource_table = %p\n", __FUNCTION__, rom_resource_table);
+
+	if (rom_resource_table == NULL) {
+		return -ENODEV;
+	}
+	// Sum all resources and setup resource maps
+	unused_IRQ = readl(rom_resource_table + UNUSED_IRQ);
+	dbg("%s -->unused_IRQ = %x\n", __FUNCTION__, unused_IRQ);
+	dbg("%s -->PCI_IRQ = %x\n", __FUNCTION__, readl(rom_resource_table + PCIIRQ));
+
+	temp = 0;
+
+	while (unused_IRQ) {
+		if (unused_IRQ & 1) {
+			amdshpc_disk_irq = temp;
+			break;
+		}
+		unused_IRQ = unused_IRQ >> 1;
+		temp++;
+	}
+
+	dbg("%s -->amdshpc_disk_irq= %d\n", __FUNCTION__, amdshpc_disk_irq);
+	unused_IRQ = unused_IRQ >> 1;
+	temp++;
+
+	while (unused_IRQ) {
+		if (unused_IRQ & 1) {
+			amdshpc_nic_irq = temp;
+			break;
+		}
+		unused_IRQ = unused_IRQ >> 1;
+		temp++;
+	}
+
+	dbg("%s -->amdshpc_nic_irq= %d\n", __FUNCTION__, amdshpc_nic_irq);
+	unused_IRQ = readl(rom_resource_table + PCIIRQ);
+
+	temp = 0;
+
+	if (!amdshpc_nic_irq) {
+		amdshpc_nic_irq = ctrl->interrupt;
+	}
+
+	if (!amdshpc_disk_irq) {
+		amdshpc_disk_irq = ctrl->interrupt;
+	}
+
+	dbg("%s -->amdshpc_disk_irq, amdshpc_nic_irq= %d, %d\n", __FUNCTION__, amdshpc_disk_irq, amdshpc_nic_irq);
+
+	one_slot = rom_resource_table + sizeof (struct hrt);
+
+	i = readb(rom_resource_table + NUMBER_OF_ENTRIES);
+	dbg("%s -->number_of_entries = %d\n", __FUNCTION__, i);
+
+	if (!readb(one_slot + SECONDARY_BUS)) {
+		return(1);
+	}
+
+	dbg("%s -->dev|IO base|length|Mem base|length|Pre base|length|PB SB MB\n", __FUNCTION__);
+
+	while (i && readb(one_slot + SECONDARY_BUS)) {
+		u8 dev_func = 		readb(one_slot + DEV_FUNC);
+		u8 primary_bus = 	readb(one_slot + PRIMARY_BUS);
+		u8 secondary_bus = 	readb(one_slot + SECONDARY_BUS);
+		u8 max_bus = 		readb(one_slot + MAX_BUS);
+		u16 io_base = 		readw(one_slot + IO_BASE);
+		u16 io_length = 	readw(one_slot + IO_LENGTH);
+		u16 mem_base = 		readw(one_slot + MEM_BASE);
+		u16 mem_length = 	readw(one_slot + MEM_LENGTH);
+		u16 pre_mem_base = 	readw(one_slot + PRE_MEM_BASE);
+		u16 pre_mem_length = readw(one_slot + PRE_MEM_LENGTH);
+
+		dbg("%s -->%2.2x | %4.4x  | %4.4x | %4.4x   | %4.4x | %4.4x   | %4.4x |%2.2x %2.2x %2.2x\n", __FUNCTION__,
+			dev_func, io_base, io_length, mem_base, mem_length, pre_mem_base, pre_mem_length,
+			primary_bus, secondary_bus, max_bus);
+
+		// If this entry isn't for our controller's bus, ignore it
+		if (primary_bus != ctrl->bus) {
+			i--;
+			one_slot += sizeof (struct slot_rt);
+			continue;
+		}
+		
+		// find out if this entry is for an occupied slot
+		pci_bus_read_config_dword(ctrl->pci_bus, dev_func, PCI_VENDOR_ID, &temp_dword);
+		dbg("bus %p, pri-bus %08x, slot %d, function %d, vend ID %d, tempDW %p\n",
+			ctrl->pci_bus, primary_bus, PCI_SLOT(dev_func), PCI_FUNC(dev_func), PCI_VENDOR_ID, &temp_dword);
+
+		dbg("%s -->temp_D_word = %08X\n", __FUNCTION__, temp_dword);
+
+		if (temp_dword != 0xFFFFFFFF) {
+			index = 0;
+			func = amdshpc_slot_find(primary_bus, dev_func >> 3, 0);
+			dbg("%s -->func = %p",__FUNCTION__, (unsigned long*)func);
+			while (func && (func->function != PCI_FUNC(dev_func))) {
+				dbg("%s -->func = %p (bus, dev, fun) = (%d, %d, %d)\n",__FUNCTION__, func, primary_bus, dev_func >> 3, index);
+				func = amdshpc_slot_find(primary_bus, PCI_SLOT(dev_func), index++);
+			}
+
+			// If we can't find a match, skip this table entry
+			if (!func) {
+				i--;
+				one_slot += sizeof (struct slot_rt);
+				continue;
+			}
+			// this may not work and shouldn't be used
+			if (secondary_bus != primary_bus){
+				bridged_slot = 1;
+	 	   }
+			else{
+				bridged_slot = 0;
+	 	   }
+			shpc_context->slot_context[slot_index].slot_occupied = 1;
+		} else {
+
+			populated_slot = 0;
+			bridged_slot = 0;
+		}
+	    slot_index++;
+	    
+		// If we've got a valid IO base, use it
+
+		temp_dword = io_base + io_length;
+		dbg("%s -->temp_D_word for io base = %08x",__FUNCTION__, temp_dword);
+
+		if ((io_base) && (temp_dword < 0x10000)) {
+			io_node = (struct pci_resource *) kmalloc(sizeof(struct pci_resource), GFP_KERNEL);
+			if (!io_node)
+				return -ENOMEM;
+
+			io_node->base = io_base;
+			io_node->length = io_length;
+
+			dbg("%s -->found io_node(base, length) = %x, %x\n",__FUNCTION__, io_node->base, io_node->length);
+			dbg("%s -->populated slot =%d \n",__FUNCTION__, populated_slot);
+			if (!populated_slot) {
+				io_node->next = ctrl->io_head;
+				ctrl->io_head = io_node;
+			} else {
+				io_node->next = func->io_head;
+				func->io_head = io_node;
+			}
+		}
+
+		// If we've got a valid memory base, use it
+		temp_dword = mem_base + mem_length;
+		dbg("%s -->temp_D_word for mem base = %08x",__FUNCTION__, temp_dword);
+		if ((mem_base) && (temp_dword < 0x10000)) {
+			mem_node = (struct pci_resource *) kmalloc(sizeof(struct pci_resource), GFP_KERNEL);
+			if (!mem_node)
+				return -ENOMEM;
+
+			mem_node->base = mem_base << 16;
+
+			mem_node->length = mem_length << 16;
+
+			dbg("%s -->found mem_node(base, length) = %08x, %08x\n",__FUNCTION__, mem_node->base, mem_node->length);
+			dbg("%s -->populated slot =%d \n",__FUNCTION__, populated_slot);
+			if (!populated_slot) {
+				mem_node->next = ctrl->mem_head;
+				ctrl->mem_head = mem_node;
+			} else {
+				mem_node->next = func->mem_head;
+				func->mem_head = mem_node;
+			}
+		}
+
+		// If we've got a valid prefetchable memory base, and
+		// the base + length isn't greater than 0xFFFF
+		temp_dword = pre_mem_base + pre_mem_length;
+		dbg("%s -->temp_D_word for pre mem base = %08x",__FUNCTION__, temp_dword);
+		if ((pre_mem_base) && (temp_dword < 0x10000)) {
+			p_mem_node = (struct pci_resource *) kmalloc(sizeof(struct pci_resource), GFP_KERNEL);
+			if (!p_mem_node)
+				return -ENOMEM;
+
+			p_mem_node->base = pre_mem_base << 16;
+
+			p_mem_node->length = pre_mem_length << 16;
+			dbg("%s -->found p_mem_node(base, length) = %08x, %08x\n",__FUNCTION__, p_mem_node->base, p_mem_node->length);
+			dbg("%s -->populated slot =%d \n",__FUNCTION__, populated_slot);
+
+			if (!populated_slot) {
+				p_mem_node->next = ctrl->p_mem_head;
+				ctrl->p_mem_head = p_mem_node;
+			} else {
+				p_mem_node->next = func->p_mem_head;
+				func->p_mem_head = p_mem_node;
+			}
+		}
+
+		// If we've got a valid bus number, use it
+		// The second condition is to ignore bus numbers on
+		// populated slots that don't have PCI-PCI bridges
+		if (secondary_bus && (secondary_bus != primary_bus)) {
+			bus_node = (struct pci_resource *) kmalloc(sizeof(struct pci_resource), GFP_KERNEL);
+			if (!bus_node)
+				return -ENOMEM;
+
+			bus_node->base = secondary_bus;
+			bus_node->length = max_bus - secondary_bus + 1;
+			dbg("%s -->found bus_node(base, length) = %08x, %08x\n",__FUNCTION__, bus_node->base, bus_node->length);
+			dbg("%s -->populated slot =%d \n",__FUNCTION__, populated_slot);
+			if (!populated_slot) {
+				bus_node->next = ctrl->bus_head;
+				ctrl->bus_head = bus_node;
+			} else {
+				bus_node->next = func->bus_head;
+				func->bus_head = bus_node;
+			}
+		}
+
+		i--;
+		one_slot += sizeof (struct slot_rt);
+	}
+
+	// If all of the following fail, we don't have any resources for
+	// hot plug add
+	rc = 1;
+	rc &= amdshpc_resource_sort_and_combine(&(ctrl->mem_head));
+	dbg("%s -->rc =%d \n",__FUNCTION__, rc);
+	rc &= amdshpc_resource_sort_and_combine(&(ctrl->p_mem_head));
+	dbg("%s -->rc =%d \n",__FUNCTION__, rc);
+	rc &= amdshpc_resource_sort_and_combine(&(ctrl->io_head));
+	dbg("%s -->rc =%d \n",__FUNCTION__, rc);
+	rc &= amdshpc_resource_sort_and_combine(&(ctrl->bus_head));
+	dbg("%s -->rc =%d \n",__FUNCTION__, rc);
+
+	return(rc);
+}
+
+
+
+/*
+ * amdshpc_save_config
+ *
+ * Reads configuration for all slots in a PCI bus and saves info.
+ *
+ * Note:  For non-hot plug busses, the slot # saved is the device #
+ *
+ * returns 0 if success
+ */
+int amdshpc_save_config(struct controller *ctrl, int busnumber, union SLOT_CONFIG_INFO* is_hot_plug)
+ {
+	long rc;
+	u8 class_code;
+	u8 header_type;
+	u32 ID;
+	u8 secondary_bus;
+	struct pci_func *new_slot;
+	int sub_bus;
+	int FirstSupported;
+	int LastSupported;
+	int max_functions;
+	int function;
+	u8 DevError;
+	int device = 0;
+	int cloop = 0;
+	int stop_it;
+	int index;
+
+	//  Decide which slots are supported
+	if (is_hot_plug) {
+		FirstSupported 	= ctrl->first_slot;
+		LastSupported = (FirstSupported + is_hot_plug->x.lu_slots_implemented) - 1;
+	} else {
+		FirstSupported = 0;
+		LastSupported = 0x1F;
+	}
+
+	// Save PCI configuration space for all devices in supported slots
+	for (device = FirstSupported; device <= LastSupported; device++) {
+		int devfn = PCI_DEVFN(device, 0);
+
+		ID = 0xFFFFFFFF;
+		rc = pci_bus_read_config_dword(ctrl->pci_bus, devfn, PCI_VENDOR_ID, &ID);
+		if (rc)
+			return rc;
+
+		if (ID != 0xFFFFFFFF) {	  //  device in slot
+			rc = pci_bus_read_config_byte(ctrl->pci_bus, devfn, 0x0B, &class_code);
+			if (rc)
+				return rc;
+
+			rc = pci_bus_read_config_byte(ctrl->pci_bus, devfn, PCI_HEADER_TYPE, &header_type);
+			if (rc)
+				return rc;
+
+			// If multi-function device, set max_functions to 8
+			if (header_type & 0x80)
+				max_functions = 8;
+			else
+				max_functions = 1;
+
+			function = 0;
+
+			do {
+				DevError = 0;
+
+				if ((header_type & 0x7F) == PCI_HEADER_TYPE_BRIDGE) {   // P-P Bridge
+					//  Recurse the subordinate bus
+					//  get the subordinate bus number
+					rc = pci_bus_read_config_byte(ctrl->pci_bus, PCI_DEVFN(device, function), PCI_SECONDARY_BUS, &secondary_bus);
+					if (rc) {
+						return rc;
+					} else {
+						sub_bus = (int) secondary_bus;
+
+						// Save secondary bus cfg spc
+						// with this recursive call.
+						rc = amdshpc_save_config(ctrl, sub_bus, 0);
+
+						if (rc)
+							return rc;
+					}
+				}
+
+				index = 0;
+				new_slot = amdshpc_slot_find(busnumber, device, index++);
+				while (new_slot &&
+				       (new_slot->function != (u8) function))
+					new_slot = amdshpc_slot_find(busnumber, device, index++);
+
+				if (!new_slot) {
+					// Setup slot structure.
+					new_slot = amdshpc_slot_create(busnumber);
+
+					if (new_slot == NULL)
+						return(1);
+				}
+
+				new_slot->bus = (u8) busnumber;
+				new_slot->device = (u8) device;
+				new_slot->function = (u8) function;
+				new_slot->is_a_board = 1;
+				new_slot->switch_save = 0x10;
+				// In case of unsupported board
+				new_slot->status = DevError;
+				new_slot->pci_dev = pci_find_slot(new_slot->bus, (new_slot->device << 3) | new_slot->function);
+				dbg("%s EXISTING SLOT", __FUNCTION__);
+				dbg("%s ns->bus         = %d", __FUNCTION__, new_slot->bus);
+				dbg("%s ns->device      = %d", __FUNCTION__, new_slot->device);
+				dbg("%s ns->function    = %d", __FUNCTION__, new_slot->function);
+				dbg("%s ns->is_a_board  = %d", __FUNCTION__, new_slot->is_a_board);
+				dbg("%s ns->switch_save = %02x", __FUNCTION__, new_slot->switch_save);
+				dbg("%s ns->pci_dev     = %p", __FUNCTION__, new_slot->pci_dev);
+
+				for (cloop = 0; cloop < 0x20; cloop++) {
+					rc = pci_bus_read_config_dword(ctrl->pci_bus, PCI_DEVFN(device, function), cloop << 2, (u32 *) & (new_slot-> config_space [cloop]));
+					if (rc)
+						return rc;
+				}
+
+				function++;
+				stop_it = 0;
+
+				//  this loop skips to the next present function
+				//  reading in Class Code and Header type.
+				while ((function < max_functions)&&(!stop_it)) {
+					rc = pci_bus_read_config_dword(ctrl->pci_bus, PCI_DEVFN(device, function), PCI_VENDOR_ID, &ID);
+					if (ID == 0xFFFFFFFF) {	 // nothing there.
+						function++;
+					} else {  // Something there
+						rc = pci_bus_read_config_byte(ctrl->pci_bus, PCI_DEVFN(device, function), 0x0B, &class_code);
+						if (rc)
+							return rc;
+
+						rc = pci_bus_read_config_byte(ctrl->pci_bus, PCI_DEVFN(device, function), PCI_HEADER_TYPE, &header_type);
+						if (rc)
+							return rc;
+
+						stop_it++;
+					}
+				}
+
+			} while (function < max_functions);
+		}		// End of IF (device in slot?)
+		else if (is_hot_plug) {
+			// Setup slot structure with entry for empty slot
+			new_slot = amdshpc_slot_create(busnumber);
+
+			if (new_slot == NULL) {
+				return(1);
+			}
+
+			new_slot->bus = (u8) busnumber;
+			new_slot->device = (u8) device;
+			new_slot->function = 0;
+			new_slot->is_a_board = 0;
+			new_slot->presence_save = 0;
+			new_slot->switch_save = 0;
+			dbg("%s NEW SLOT", __FUNCTION__);
+			dbg("%s ns->bus         = %d", __FUNCTION__, new_slot->bus);
+			dbg("%s ns->device      = %d", __FUNCTION__, new_slot->function);
+			dbg("%s ns->function    = %d", __FUNCTION__, new_slot->function);
+		}
+	}// End of FOR loop
+
+	return 0;
+}
+
+
+/*
+ * amdshpc_set_irq
+ *
+ * @bus_num: bus number of PCI device
+ * @dev_num: device number of PCI device
+ */
+/*
+int amdshpc_set_irq (u8 bus_num, u8 dev_num, u8 int_pin, u8 irq_num)
+{
+	int rc;
+	u16 temp_word;
+	struct pci_dev fakedev;
+	struct pci_bus fakebus;
+
+	fakedev.devfn = dev_num << 3;
+	fakedev.bus = &fakebus;
+	fakebus.number = bus_num;
+	dbg("%s : dev %d, bus %d, pin %d, num %d\n",__FUNCTION__,
+		dev_num, bus_num, int_pin, irq_num);
+	rc = pcibios_set_irq_routing(&fakedev, int_pin - 0x0a, irq_num);
+	dbg("%s:rc %d\n",__FUNCTION__, rc);
+	if (rc)
+		return rc;
+
+	// set the Edge Level Control Register (ELCR)
+	temp_word = inb(0x4d0);
+	temp_word |= inb(0x4d1) << 8;
+
+	temp_word |= 0x01 << irq_num;
+
+	// This should only be for x86 as it sets the Edge Level Control Register
+	outb((u8) (temp_word & 0xFF), 0x4d0);
+	outb((u8) ((temp_word & 0xFF00) >> 8), 0x4d1);
+
+	return 0;
+}
+*/
+
+/*
+ * do_pre_bridge_resource_split
+ *
+ *	Returns zero or one node of resources that aren't in use
+ *
+ */
+static struct pci_resource *do_pre_bridge_resource_split (struct pci_resource **head, struct pci_resource **orig_head, u32 alignment) {
+	struct pci_resource *prevnode = NULL;
+	struct pci_resource *node;
+	struct pci_resource *split_node;
+	u32 rc;
+	u32 temp_dword;
+	dbg("%s -->do_pre_bridge_resource_split\n",__FUNCTION__);
+
+	if (!(*head) || !(*orig_head))
+		return(NULL);
+
+	rc = amdshpc_resource_sort_and_combine(head);
+
+	if (rc)
+		return(NULL);
+
+	if ((*head)->base != (*orig_head)->base)
+		return(NULL);
+
+	if ((*head)->length == (*orig_head)->length)
+		return(NULL);
+
+
+	// If we got here, there the bridge requires some of the resource, but
+	// we may be able to split some off of the front
+
+	node = *head;
+
+	if (node->length & (alignment -1)) {
+		// this one isn't an aligned length, so we'll make a new entry
+		// and split it up.
+		split_node = (struct pci_resource*) kmalloc(sizeof(struct pci_resource), GFP_KERNEL);
+
+		if (!split_node)
+			return(NULL);
+
+		temp_dword = (node->length | (alignment-1)) + 1 - alignment;
+
+		split_node->base = node->base;
+		split_node->length = temp_dword;
+
+		node->length -= temp_dword;
+		node->base += split_node->length;
+
+		// Put it in the list
+		*head = split_node;
+		split_node->next = node;
+	}
+
+	if (node->length < alignment) {
+		return(NULL);
+	}
+
+	// Now unlink it
+	if (*head == node) {
+		*head = node->next;
+		node->next = NULL;
+	} else {
+		prevnode = *head;
+		while (prevnode->next != node)
+			prevnode = prevnode->next;
+
+		prevnode->next = node->next;
+		node->next = NULL;
+	}
+
+	return(node);
+}
+
+
+/*
+ * do_bridge_resource_split
+ *
+ *	Returns zero or one node of resources that aren't in use
+ *
+ */
+static struct pci_resource *do_bridge_resource_split (struct pci_resource **head, u32 alignment) {
+	struct pci_resource *prevnode = NULL;
+	struct pci_resource *node;
+	u32 rc;
+	u32 temp_dword;
+
+	if (!(*head))
+		return(NULL);
+
+	rc = amdshpc_resource_sort_and_combine(head);
+
+	if (rc)
+		return(NULL);
+
+	node = *head;
+
+	while (node->next) {
+		prevnode = node;
+		node = node->next;
+		kfree(prevnode);
+	}
+
+	if (node->length < alignment) {
+		kfree(node);
+		return(NULL);
+	}
+
+	if (node->base & (alignment - 1)) {
+		// Short circuit if adjusted size is too small
+		temp_dword = (node->base | (alignment-1)) + 1;
+		if ((node->length - (temp_dword - node->base)) < alignment) {
+			kfree(node);
+			return(NULL);
+		}
+
+		node->length -= (temp_dword - node->base);
+		node->base = temp_dword;
+	}
+
+	if (node->length & (alignment - 1)) {
+		// There's stuff in use after this node
+		kfree(node);
+		return(NULL);
+	}
+
+	return(node);
+}
+
+
+/*
+ * sort_by_size
+ *
+ * Sorts nodes on the list by their length.
+ * Smallest first.
+ *
+ */
+static int sort_by_size(struct pci_resource **head)
+{
+	struct pci_resource *current_res;
+	struct pci_resource *next_res;
+	int out_of_order = 1;
+
+	if (!(*head))
+		return(1);
+
+	if (!((*head)->next))
+		return(0);
+
+	while (out_of_order) {
+		out_of_order = 0;
+
+		// Special case for swapping list head
+		if (((*head)->next) &&
+			((*head)->length > (*head)->next->length)) {
+			out_of_order++;
+			current_res = *head;
+			*head = (*head)->next;
+			current_res->next = (*head)->next;
+			(*head)->next = current_res;
+		}
+
+		current_res = *head;
+
+		while (current_res->next && current_res->next->next) {
+			if (current_res->next->length > current_res->next->next->length) {
+				out_of_order++;
+				next_res = current_res->next;
+				current_res->next = current_res->next->next;
+				current_res = current_res->next;
+				next_res->next = current_res->next;
+				current_res->next = next_res;
+			} else
+				current_res	= current_res->next;
+		}
+	}  // End of out_of_order loop
+
+	return(0);
+}
+
+/**
+ * amdshpc_slot_create - Creates a node and adds it to the proper bus.
+ * @busnumber - bus where new node is to be located
+ *
+ * Returns pointer to the new node or NULL if unsuccessful
+ */
+struct pci_func *amdshpc_slot_create(u8 busnumber) {
+	struct pci_func *new_slot;
+	struct pci_func *next;
+
+	dbg("%s  busnumber = %02xh",__FUNCTION__, busnumber);
+	new_slot = (struct pci_func *) kmalloc(sizeof(struct pci_func), GFP_KERNEL);
+
+	if (new_slot == NULL) {
+		// I'm not dead yet!
+		// You will be.
+		return(new_slot);
+	}
+
+	memset(new_slot, 0, sizeof(struct pci_func));
+
+	new_slot->next = NULL;
+	new_slot->configured = 1;
+
+	if (amdshpc_slot_list[busnumber] == NULL) {
+		amdshpc_slot_list[busnumber] = new_slot;
+		dbg("%s   created new slot in amdshpc_slot_list  amdshpc_slot_list[%02X] = %p", __FUNCTION__,
+							busnumber, amdshpc_slot_list[busnumber]);
+	} else {
+		next = amdshpc_slot_list[busnumber];
+		while (next->next != NULL)
+			next = next->next;
+		next->next = new_slot;
+	}
+	return(new_slot);
+}
+
+
+/*
+ * return_resource
+ *
+ * Puts node back in the resource list pointed to by head
+ *
+ */
+static inline void return_resource (struct pci_resource **head, struct pci_resource *node)
+{
+	dbg("%s",__FUNCTION__);
+	if (!node || !head)
+		return;
+	node->next = *head;
+	*head = node;
+}
+
+
+/*
+ * sort_by_max_size
+ *
+ * Sorts nodes on the list by their length.
+ * Largest first.
+ *
+ */
+static int sort_by_max_size(struct pci_resource **head)
+{
+	struct pci_resource *current_res;
+	struct pci_resource *next_res;
+	int out_of_order = 1;
+
+	if (!(*head))
+		return(1);
+
+	if (!((*head)->next))
+		return(0);
+
+	while (out_of_order) {
+		out_of_order = 0;
+
+		// Special case for swapping list head
+		if (((*head)->next) &&
+			((*head)->length < (*head)->next->length)) {
+			out_of_order++;
+			current_res = *head;
+			*head = (*head)->next;
+			current_res->next = (*head)->next;
+			(*head)->next = current_res;
+		}
+
+		current_res = *head;
+
+		while (current_res->next && current_res->next->next) {
+			if (current_res->next->length < current_res->next->next->length) {
+				out_of_order++;
+				next_res = current_res->next;
+				current_res->next = current_res->next->next;
+				current_res = current_res->next;
+				next_res->next = current_res->next;
+				current_res->next = next_res;
+			} else
+				current_res	= current_res->next;
+		}
+	}  // End of out_of_order loop
+
+	return(0);
+}
+
+
+/*
+ * get_max_resource
+ *
+ * Gets the largest node that is at least "size" big from the
+ * list pointed to by head.  It aligns the node on top and bottom
+ * to "size" alignment before returning it.
+ */
+static struct pci_resource *get_max_resource (struct pci_resource **head, u32 size) {
+	struct pci_resource *max;
+	struct pci_resource *temp;
+	struct pci_resource *split_node;
+	u32 temp_dword;
+
+	if (!(*head))
+		return(NULL);
+
+	if (amdshpc_resource_sort_and_combine(head))
+		return(NULL);
+
+	if (sort_by_max_size(head))
+		return(NULL);
+
+	for (max = *head;max; max = max->next) {
+
+		// If not big enough we could probably just bail,
+		// instead we'll continue to the next.
+		if (max->length < size)
+			continue;
+
+		if (max->base & (size - 1)) {
+			// this one isn't base aligned properly
+			// so we'll make a new entry and split it up
+			temp_dword = (max->base | (size-1)) + 1;
+
+			// Short circuit if adjusted size is too small
+			if ((max->length - (temp_dword - max->base)) < size)
+				continue;
+
+			split_node = (struct pci_resource*) kmalloc(sizeof(struct pci_resource), GFP_KERNEL);
+
+			if (!split_node)
+				return(NULL);
+
+			split_node->base = max->base;
+			split_node->length = temp_dword - max->base;
+			max->base = temp_dword;
+			max->length -= split_node->length;
+
+			// Put it next in the list
+			split_node->next = max->next;
+			max->next = split_node;
+		}
+
+		if ((max->base + max->length) & (size - 1)) {
+			// this one isn't end aligned properly at the top
+			// so we'll make a new entry and split it up
+			split_node = (struct pci_resource*) kmalloc(sizeof(struct pci_resource), GFP_KERNEL);
+
+			if (!split_node)
+				return(NULL);
+			temp_dword = ((max->base + max->length) & ~(size - 1));
+			split_node->base = temp_dword;
+			split_node->length = max->length + max->base
+								 - split_node->base;
+			max->length -= split_node->length;
+
+			// Put it in the list
+			split_node->next = max->next;
+			max->next = split_node;
+		}
+
+		// Make sure it didn't shrink too much when we aligned it
+		if (max->length < size)
+			continue;
+
+		// Now take it out of the list
+		temp = (struct pci_resource*) *head;
+		if (temp == max) {
+			*head = max->next;
+		} else {
+			while (temp && temp->next != max) {
+				temp = temp->next;
+			}
+
+			temp->next = max->next;
+		}
+
+		max->next = NULL;
+		return(max);
+	}
+
+	// If we get here, we couldn't find one
+	return(NULL);
+}
+
+
+/*
+ * get_io_resource
+ *
+ * this function sorts the resource list by size and then
+ * returns the first node of "size" length that is not in the
+ * ISA aliasing window.  If it finds a node larger than "size"
+ * it will split it up.
+ *
+ * size must be a power of two.
+ */
+static struct pci_resource *get_io_resource (struct pci_resource **head, u32 size) {
+	struct pci_resource *prevnode;
+	struct pci_resource *node;
+	struct pci_resource *split_node;
+	u32 temp_dword;
+
+	if (!(*head))
+		return(NULL);
+
+	if ( amdshpc_resource_sort_and_combine(head) )
+		return(NULL);
+
+	if ( sort_by_size(head) )
+		return(NULL);
+
+	for (node = *head; node; node = node->next) {
+		if (node->length < size)
+			continue;
+
+		if (node->base & (size - 1)) {
+			// this one isn't base aligned properly
+			// so we'll make a new entry and split it up
+			temp_dword = (node->base | (size-1)) + 1;
+
+			// Short circuit if adjusted size is too small
+			if ((node->length - (temp_dword - node->base)) < size)
+				continue;
+
+			split_node = (struct pci_resource*) kmalloc(sizeof(struct pci_resource), GFP_KERNEL);
+
+			if (!split_node)
+				return(NULL);
+
+			split_node->base = node->base;
+			split_node->length = temp_dword - node->base;
+			node->base = temp_dword;
+			node->length -= split_node->length;
+
+			// Put it in the list
+			split_node->next = node->next;
+			node->next = split_node;
+		} // End of non-aligned base
+
+		// Don't need to check if too small since we already did
+		if (node->length > size) {
+			// this one is longer than we need
+			// so we'll make a new entry and split it up
+			split_node = (struct pci_resource*) kmalloc(sizeof(struct pci_resource), GFP_KERNEL);
+
+			if (!split_node)
+				return(NULL);
+
+			split_node->base = node->base + size;
+			split_node->length = node->length - size;
+			node->length = size;
+
+			// Put it in the list
+			split_node->next = node->next;
+			node->next = split_node;
+		}  // End of too big on top end
+
+		// For IO make sure it's not in the ISA aliasing space
+		if (node->base & 0x300L)
+			continue;
+
+		// If we got here, then it is the right size
+		// Now take it out of the list
+		if (*head == node) {
+			*head = node->next;
+		} else {
+			prevnode = *head;
+			while (prevnode->next != node)
+				prevnode = prevnode->next;
+
+			prevnode->next = node->next;
+		}
+		node->next = NULL;
+		// Stop looping
+		break;
+	}
+
+	return(node);
+}
+
+
+/*
+ * get_resource
+ *
+ * this function sorts the resource list by size and then
+ * returns the first node of "size" length.  If it finds a node
+ * larger than "size" it will split it up.
+ *
+ * size must be a power of two.
+ */
+static struct pci_resource *get_resource (struct pci_resource **head, u32 size) {
+	struct pci_resource *prevnode;
+	struct pci_resource *node;
+	struct pci_resource *split_node;
+	u32 temp_dword;
+
+	if (!(*head))
+		return(NULL);
+
+	if ( amdshpc_resource_sort_and_combine(head) )
+		return(NULL);
+
+	if ( sort_by_size(head) )
+		return(NULL);
+
+	for (node = *head; node; node = node->next) {
+		dbg("%s: req_size =%x node=%p, base=%x, length=%x\n",__FUNCTION__,
+			size, node, node->base, node->length);
+		if (node->length < size)
+			continue;
+
+		if (node->base & (size - 1)) {
+			dbg("%s: not aligned\n",__FUNCTION__);
+			// this one isn't base aligned properly
+			// so we'll make a new entry and split it up
+			temp_dword = (node->base | (size-1)) + 1;
+
+			// Short circuit if adjusted size is too small
+			if ((node->length - (temp_dword - node->base)) < size)
+				continue;
+
+			split_node = (struct pci_resource*) kmalloc(sizeof(struct pci_resource), GFP_KERNEL);
+
+			if (!split_node)
+				return(NULL);
+
+			split_node->base = node->base;
+			split_node->length = temp_dword - node->base;
+			node->base = temp_dword;
+			node->length -= split_node->length;
+
+			// Put it in the list
+			split_node->next = node->next;
+			node->next = split_node;
+		} // End of non-aligned base
+
+		// Don't need to check if too small since we already did
+		if (node->length > size) {
+			dbg("%s: too big\n",__FUNCTION__);
+			// this one is longer than we need
+			// so we'll make a new entry and split it up
+			split_node = (struct pci_resource*) kmalloc(sizeof(struct pci_resource), GFP_KERNEL);
+
+			if (!split_node)
+				return(NULL);
+
+			split_node->base = node->base + size;
+			split_node->length = node->length - size;
+			node->length = size;
+
+			// Put it in the list
+			split_node->next = node->next;
+			node->next = split_node;
+		}  // End of too big on top end
+
+		dbg("%s: got one!!!\n",__FUNCTION__);
+		// If we got here, then it is the right size
+		// Now take it out of the list
+		if (*head == node) {
+			*head = node->next;
+		} else {
+			prevnode = *head;
+			while (prevnode->next != node)
+				prevnode = prevnode->next;
+
+			prevnode->next = node->next;
+		}
+		node->next = NULL;
+		// Stop looping
+		break;
+	}
+	return(node);
+}
+
+/*
+ * amdshpc_return_board_resources
+ *
+ * this routine returns all resources allocated to a board to
+ * the available pool.
+ *
+ * returns 0 if success
+ */
+int amdshpc_return_board_resources(struct pci_func * func, struct resource_lists * resources)
+{
+	int rc = 1;
+	struct pci_resource *node;
+	struct pci_resource *t_node;
+	dbg("%s",__FUNCTION__);
+
+	if (!func)
+		return(1);
+
+	node = func->io_head;
+	func->io_head = NULL;
+	while (node) {
+		t_node = node->next;
+		return_resource(&(resources->io_head), node);
+		node = t_node;
+	}
+
+	node = func->mem_head;
+	func->mem_head = NULL;
+	while (node) {
+		t_node = node->next;
+		return_resource(&(resources->mem_head), node);
+		node = t_node;
+	}
+
+	node = func->p_mem_head;
+	func->p_mem_head = NULL;
+	while (node) {
+		t_node = node->next;
+		return_resource(&(resources->p_mem_head), node);
+		node = t_node;
+	}
+
+	node = func->bus_head;
+	func->bus_head = NULL;
+	while (node) {
+		t_node = node->next;
+		return_resource(&(resources->bus_head), node);
+		node = t_node;
+	}
+
+	rc |= amdshpc_resource_sort_and_combine(&(resources->mem_head));
+	rc |= amdshpc_resource_sort_and_combine(&(resources->p_mem_head));
+	rc |= amdshpc_resource_sort_and_combine(&(resources->io_head));
+	rc |= amdshpc_resource_sort_and_combine(&(resources->bus_head));
+
+	return(rc);
+}
+
+
+/*
+ * amdshpc_destroy_resource_list
+ *
+ * Puts node back in the resource list pointed to by head
+ */
+void amdshpc_destroy_resource_list (struct resource_lists * resources)
+{
+	struct pci_resource *res, *tres;
+
+	res = resources->io_head;
+	resources->io_head = NULL;
+
+	while (res) {
+		tres = res;
+		res = res->next;
+		kfree(tres);
+	}
+
+	res = resources->mem_head;
+	resources->mem_head = NULL;
+
+	while (res) {
+		tres = res;
+		res = res->next;
+		kfree(tres);
+	}
+
+	res = resources->p_mem_head;
+	resources->p_mem_head = NULL;
+
+	while (res) {
+		tres = res;
+		res = res->next;
+		kfree(tres);
+	}
+
+	res = resources->bus_head;
+	resources->bus_head = NULL;
+
+	while (res) {
+		tres = res;
+		res = res->next;
+		kfree(tres);
+	}
+}
+
+
+/*
+ * amdshpc_destroy_board_resources
+ *
+ * Puts node back in the resource list pointed to by head
+ */
+void amdshpc_destroy_board_resources (struct pci_func * func)
+{
+	struct pci_resource *res, *tres;
+
+	res = func->io_head;
+	func->io_head = NULL;
+
+	while (res) {
+		tres = res;
+		res = res->next;
+		kfree(tres);
+	}
+
+	res = func->mem_head;
+	func->mem_head = NULL;
+
+	while (res) {
+		tres = res;
+		res = res->next;
+		kfree(tres);
+	}
+
+	res = func->p_mem_head;
+	func->p_mem_head = NULL;
+
+	while (res) {
+		tres = res;
+		res = res->next;
+		kfree(tres);
+	}
+
+	res = func->bus_head;
+	func->bus_head = NULL;
+
+	while (res) {
+		tres = res;
+		res = res->next;
+		kfree(tres);
+	}
+}
+
+/**
+ * configure_new_device - Configures the PCI header information of one board.
+ *
+ * @ctrl: pointer to controller structure
+ * @func: pointer to function structure
+ * @behind_bridge: 1 if this is a recursive call, 0 if not
+ * @resources: pointer to set of resource lists
+ *
+ * Returns 0 if success
+ *
+ */
+static u32 configure_new_device (struct controller * ctrl, struct pci_func * func,
+								 u8 behind_bridge, struct resource_lists * resources)
+{
+	u8 temp_byte, function, max_functions, stop_it;
+	int rc;
+	u32 ID;
+	struct pci_func *new_slot;
+	int index;
+
+	new_slot = func;
+
+	dbg("%s",__FUNCTION__);
+	// Check for Multi-function device
+	rc = pci_bus_read_config_byte(ctrl->pci_bus, PCI_DEVFN(func->device, func->function), 0x0E, &temp_byte);
+	if (rc) {
+		dbg("%s: rc = %d\n",__FUNCTION__, rc);
+		return rc;
+	}
+
+	if (temp_byte & 0x80)	// Multi-function device
+		max_functions = 8;
+	else
+		max_functions = 1;
+
+	function = 0;
+
+	do {
+		rc = configure_new_function(ctrl, new_slot, behind_bridge, resources);
+
+		if (rc) {
+			dbg("%s -->configure_new_function failed %d\n",__FUNCTION__,rc);
+			index = 0;
+
+			while (new_slot) {
+				new_slot = amdshpc_slot_find(new_slot->bus, new_slot->device, index++);
+
+				if (new_slot)
+					amdshpc_return_board_resources(new_slot, resources);
+			}
+
+			return(rc);
+		}
+
+		function++;
+
+		stop_it = 0;
+
+		//  The following loop skips to the next present function
+		//  and creates a board structure
+
+		while ((function < max_functions) && (!stop_it)) {
+			pci_bus_read_config_dword(ctrl->pci_bus, PCI_DEVFN(func->device, function), 0x00, &ID);
+
+			if (ID == 0xFFFFFFFF) {	  // There's nothing there.
+				function++;
+			} else {  // There's something there
+				// Setup slot structure.
+				new_slot = amdshpc_slot_create(func->bus);
+
+				if (new_slot == NULL) {
+					// Out of memory
+					return(1);
+				}
+
+				new_slot->bus = func->bus;
+				new_slot->device = func->device;
+				new_slot->function = function;
+				new_slot->is_a_board = 1;
+				new_slot->status = 0;
+
+				stop_it++;
+			}
+		}
+
+	} while (function < max_functions);
+	dbg("%s -->returning from configure_new_device\n",__FUNCTION__);
+
+	return 0;
+}
+
+
+/*
+  Configuration logic that involves the hotplug data structures and
+  their bookkeeping
+ */
+
+
+/**
+ * configure_new_function - Configures the PCI header information of one device
+ *
+ * @ctrl: pointer to controller structure
+ * @func: pointer to function structure
+ * @behind_bridge: 1 if this is a recursive call, 0 if not
+ * @resources: pointer to set of resource lists
+ *
+ * Calls itself recursively for bridged devices.
+ * Returns 0 if success
+ *
+ */
+static int configure_new_function (struct controller * ctrl, struct pci_func * func,
+								   u8 behind_bridge, struct resource_lists * resources)
+{
+	int cloop;
+	u8 IRQ;
+	u8 temp_byte;
+	u8 device;
+	u8 class_code;
+	u16 command;
+	u16 temp_word;
+	u32 temp_dword;
+	u32 rc;
+	u32 temp_register;
+	u32 base;
+	u32 ID;
+	struct pci_resource *mem_node;
+	struct pci_resource *p_mem_node;
+	struct pci_resource *io_node;
+	struct pci_resource *bus_node;
+	struct pci_resource *hold_mem_node;
+	struct pci_resource *hold_p_mem_node;
+	struct pci_resource *hold_IO_node;
+	struct pci_resource *hold_bus_node;
+	struct irq_mapping irqs;
+	struct pci_func *new_slot;
+	struct resource_lists temp_resources;
+	int devfn = PCI_DEVFN(func->device, func->function);
+
+	dbg("%s", __FUNCTION__);
+	// Check for Bridge
+	rc = pci_bus_read_config_byte(ctrl->pci_bus, devfn, PCI_HEADER_TYPE, &temp_byte);
+	if (rc)
+		return rc;
+
+	if ((temp_byte & 0x7F) == PCI_HEADER_TYPE_BRIDGE) {	// PCI-PCI Bridge
+		// set Primary bus
+		dbg("%s -->set Primary bus = %d\n",__FUNCTION__, func->bus);
+		rc = pci_bus_write_config_byte(ctrl->pci_bus, devfn, PCI_PRIMARY_BUS, func->bus);
+		if (rc)
+			return rc;
+
+		// find range of busses to use
+		dbg("%s -->find ranges of buses to use\n",__FUNCTION__);
+		bus_node = get_max_resource(&resources->bus_head, 1);
+
+		// If we don't have any busses to allocate, we can't continue
+		if (!bus_node)
+			return -ENOMEM;
+
+		// set Secondary bus
+		temp_byte = bus_node->base;
+		dbg("%s -->set Secondary bus = %d\n",__FUNCTION__, bus_node->base);
+		rc = pci_bus_write_config_byte(ctrl->pci_bus, devfn, PCI_SECONDARY_BUS, temp_byte);
+		if (rc)
+			return rc;
+
+		// set subordinate bus
+		temp_byte = bus_node->base + bus_node->length - 1;
+		dbg("%s -->set subordinate bus = %d\n",__FUNCTION__, bus_node->base + bus_node->length - 1);
+		rc = pci_bus_write_config_byte(ctrl->pci_bus, devfn, PCI_SUBORDINATE_BUS, temp_byte);
+		if (rc)
+			return rc;
+
+		// set subordinate Latency Timer and base Latency Timer
+		temp_byte = 0x40;
+		rc = pci_bus_write_config_byte(ctrl->pci_bus, devfn, PCI_SEC_LATENCY_TIMER, temp_byte);
+		if (rc)
+			return rc;
+		rc = pci_bus_write_config_byte(ctrl->pci_bus, devfn, PCI_LATENCY_TIMER, temp_byte);
+		if (rc)
+			return rc;
+
+		// set Cache Line size
+		temp_byte = 0x08;
+		rc = pci_bus_write_config_byte(ctrl->pci_bus, devfn, PCI_CACHE_LINE_SIZE, temp_byte);
+		if (rc)
+			return rc;
+
+		// Setup the IO, memory, and prefetchable windows
+
+		io_node = get_max_resource(&(resources->io_head), 0x1000);
+		mem_node = get_max_resource(&(resources->mem_head), 0x100000);
+		p_mem_node = get_max_resource(&(resources->p_mem_head), 0x100000);
+		dbg("%s -->Setup the IO, memory, and prefetchable windows\n",__FUNCTION__);
+		dbg("%s -->io_node\n",__FUNCTION__);
+		dbg("%s -->(base, len, next) (%x, %x, %p)\n",__FUNCTION__, io_node->base, io_node->length, io_node->next);
+		dbg("%s -->mem_node\n",__FUNCTION__);
+		dbg("%s -->(base, len, next) (%x, %x, %p)\n",__FUNCTION__, mem_node->base, mem_node->length, mem_node->next);
+		dbg("%s -->p_mem_node\n",__FUNCTION__);
+		dbg("%s -->(base, len, next) (%x, %x, %p)\n",__FUNCTION__, p_mem_node->base, p_mem_node->length, p_mem_node->next);
+
+		// set up the IRQ info
+		if (!resources->irqs) {
+			irqs.barber_pole = 0;
+			irqs.interrupt[0] = 0;
+			irqs.interrupt[1] = 0;
+			irqs.interrupt[2] = 0;
+			irqs.interrupt[3] = 0;
+			irqs.valid_INT = 0;
+		} else {
+			irqs.barber_pole = resources->irqs->barber_pole;
+			irqs.interrupt[0] = resources->irqs->interrupt[0];
+			irqs.interrupt[1] = resources->irqs->interrupt[1];
+			irqs.interrupt[2] = resources->irqs->interrupt[2];
+			irqs.interrupt[3] = resources->irqs->interrupt[3];
+			irqs.valid_INT = resources->irqs->valid_INT;
+		}
+
+		// set up resource lists that are now aligned on top and bottom
+		// for anything behind the bridge.
+		temp_resources.bus_head = bus_node;
+		temp_resources.io_head = io_node;
+		temp_resources.mem_head = mem_node;
+		temp_resources.p_mem_head = p_mem_node;
+		temp_resources.irqs = &irqs;
+
+		// Make copies of the nodes we are going to pass down so that
+		// if there is a problem,we can just use these to free resources
+		hold_bus_node = (struct pci_resource *) kmalloc(sizeof(struct pci_resource), GFP_KERNEL);
+		hold_IO_node = (struct pci_resource *) kmalloc(sizeof(struct pci_resource), GFP_KERNEL);
+		hold_mem_node = (struct pci_resource *) kmalloc(sizeof(struct pci_resource), GFP_KERNEL);
+		hold_p_mem_node = (struct pci_resource *) kmalloc(sizeof(struct pci_resource), GFP_KERNEL);
+
+		if (!hold_bus_node || !hold_IO_node || !hold_mem_node || !hold_p_mem_node) {
+			if (hold_bus_node)
+				kfree(hold_bus_node);
+			if (hold_IO_node)
+				kfree(hold_IO_node);
+			if (hold_mem_node)
+				kfree(hold_mem_node);
+			if (hold_p_mem_node)
+				kfree(hold_p_mem_node);
+
+			return(1);
+		}
+
+		memcpy(hold_bus_node, bus_node, sizeof(struct pci_resource));
+
+		bus_node->base += 1;
+		bus_node->length -= 1;
+		bus_node->next = NULL;
+
+		// If we have IO resources copy them and fill in the bridge's
+		// IO range registers
+		if (io_node) {
+			memcpy(hold_IO_node, io_node, sizeof(struct pci_resource));
+			io_node->next = NULL;
+
+			// set IO base and Limit registers
+			temp_byte = io_node->base >> 8;
+			rc = pci_bus_write_config_byte(ctrl->pci_bus, devfn, PCI_IO_BASE, temp_byte);
+
+			temp_byte = (io_node->base + io_node->length - 1) >> 8;
+			rc = pci_bus_write_config_byte(ctrl->pci_bus, devfn, PCI_IO_LIMIT, temp_byte);
+		} else {
+			kfree(hold_IO_node);
+			hold_IO_node = NULL;
+		}
+
+		// If we have memory resources copy them and fill in the bridge's
+		// memory range registers.  Otherwise, fill in the range
+		// registers with values that disable them.
+		if (mem_node) {
+			memcpy(hold_mem_node, mem_node, sizeof(struct pci_resource));
+			mem_node->next = NULL;
+
+			// set Mem base and Limit registers
+			temp_word = mem_node->base >> 16;
+			pci_bus_write_config_word(ctrl->pci_bus, devfn, PCI_MEMORY_BASE, temp_word);
+
+			temp_word = (mem_node->base + mem_node->length - 1) >> 16;
+			pci_bus_write_config_word(ctrl->pci_bus, devfn, PCI_MEMORY_LIMIT, temp_word);
+		} else {
+			temp_word = 0xFFFF;
+			pci_bus_write_config_word(ctrl->pci_bus, devfn, PCI_MEMORY_BASE, temp_word);
+
+			temp_word = 0x0000;
+			pci_bus_write_config_word(ctrl->pci_bus, devfn, PCI_MEMORY_LIMIT, temp_word);
+
+			kfree(hold_mem_node);
+			hold_mem_node = NULL;
+		}
+
+		// If we have prefetchable memory resources copy them and
+		// fill in the bridge's memory range registers.  Otherwise,
+		// fill in the range registers with values that disable them.
+		if (p_mem_node) {
+			memcpy(hold_p_mem_node, p_mem_node, sizeof(struct pci_resource));
+			p_mem_node->next = NULL;
+
+			// set Pre Mem base and Limit registers
+			temp_word = p_mem_node->base >> 16;
+			pci_bus_write_config_word(ctrl->pci_bus, devfn, PCI_PREF_MEMORY_BASE, temp_word);
+
+			temp_word = (p_mem_node->base + p_mem_node->length - 1) >> 16;
+			pci_bus_write_config_word(ctrl->pci_bus, devfn, PCI_PREF_MEMORY_LIMIT, temp_word);
+		} else {
+			temp_word = 0xFFFF;
+			pci_bus_write_config_word(ctrl->pci_bus, devfn, PCI_PREF_MEMORY_BASE, temp_word);
+
+			temp_word = 0x0000;
+			pci_bus_write_config_word(ctrl->pci_bus, devfn, PCI_PREF_MEMORY_LIMIT, temp_word);
+
+			kfree(hold_p_mem_node);
+			hold_p_mem_node = NULL;
+		}
+
+		// Adjust this to compensate for extra adjustment in first loop
+		irqs.barber_pole--;
+
+		rc = 0;
+
+		// Here we actually find the devices and configure them
+		for (device = 0; (device <= 0x1F) && !rc; device++) {
+			irqs.barber_pole = (irqs.barber_pole + 1) & 0x03;
+
+			ID = 0xFFFFFFFF;
+			pci_bus_read_config_dword(ctrl->pci_bus, PCI_DEVFN(device, 0), 0x00, &ID);
+
+			if (ID != 0xFFFFFFFF) {	  //  device Present
+				// Setup slot structure.
+				new_slot = amdshpc_slot_create(hold_bus_node->base);
+
+				if (new_slot == NULL) {
+					// Out of memory
+					rc = -ENOMEM;
+					continue;
+				}
+
+				new_slot->bus = hold_bus_node->base;
+				new_slot->device = device;
+				new_slot->function = 0;
+				new_slot->is_a_board = 1;
+				new_slot->status = 0;
+
+				rc = configure_new_device(ctrl, new_slot, 1, &temp_resources);
+				dbg("%s -->configure_new_device rc=0x%x\n",__FUNCTION__,rc);
+			}	// End of IF (device in slot?)
+		}		// End of FOR loop
+
+		if (rc) {
+			amdshpc_destroy_resource_list(&temp_resources);
+
+			return_resource(&(resources->bus_head), hold_bus_node);
+			return_resource(&(resources->io_head), hold_IO_node);
+			return_resource(&(resources->mem_head), hold_mem_node);
+			return_resource(&(resources->p_mem_head), hold_p_mem_node);
+			return(rc);
+		}
+		// save the interrupt routing information
+		if (resources->irqs) {
+			resources->irqs->interrupt[0] = irqs.interrupt[0];
+			resources->irqs->interrupt[1] = irqs.interrupt[1];
+			resources->irqs->interrupt[2] = irqs.interrupt[2];
+			resources->irqs->interrupt[3] = irqs.interrupt[3];
+			resources->irqs->valid_INT = irqs.valid_INT;
+		} else if (!behind_bridge) {
+			// We need to hook up the interrupts here
+			for (cloop = 0; cloop < 4; cloop++) {
+				if (irqs.valid_INT & (0x01 << cloop)) {
+rc=0;
+//					rc = amdshpc_set_irq(func->bus, func->device,
+//									   0x0A + cloop, irqs.interrupt[cloop]);
+					if (rc) {
+						amdshpc_destroy_resource_list (&temp_resources);
+
+						return_resource(&(resources-> bus_head), hold_bus_node);
+						return_resource(&(resources-> io_head), hold_IO_node);
+						return_resource(&(resources-> mem_head), hold_mem_node);
+						return_resource(&(resources-> p_mem_head), hold_p_mem_node);
+						return rc;
+					}
+				}
+			}	// end of for loop
+		}
+		// Return unused bus resources
+		// First use the temporary node to store information for the board
+		if (hold_bus_node && bus_node && temp_resources.bus_head) {
+			hold_bus_node->length = bus_node->base - hold_bus_node->base;
+
+			hold_bus_node->next = func->bus_head;
+			func->bus_head = hold_bus_node;
+
+			temp_byte = temp_resources.bus_head->base - 1;
+
+			// set subordinate bus
+			pci_bus_write_config_byte(ctrl->pci_bus, devfn, PCI_SUBORDINATE_BUS, temp_byte);
+
+			if (temp_resources.bus_head->length == 0) {
+				kfree(temp_resources.bus_head);
+				temp_resources.bus_head = NULL;
+			} else {
+				return_resource(&(resources->bus_head), temp_resources.bus_head);
+			}
+		}
+
+		// If we have IO space available and there is some left,
+		// return the unused portion
+		if (hold_IO_node && temp_resources.io_head) {
+			io_node = do_pre_bridge_resource_split(&(temp_resources.io_head),
+												   &hold_IO_node, 0x1000);
+
+			// Check if we were able to split something off
+			if (io_node) {
+				hold_IO_node->base = io_node->base + io_node->length;
+
+				temp_byte = (hold_IO_node->base) >> 8;
+				pci_bus_write_config_word(ctrl->pci_bus, devfn, PCI_IO_BASE, temp_byte);
+
+				return_resource(&(resources->io_head), io_node);
+			}
+
+			io_node = do_bridge_resource_split(&(temp_resources.io_head), 0x1000);
+
+			// Check if we were able to split something off
+			if (io_node) {
+				// First use the temporary node to store information for the board
+				hold_IO_node->length = io_node->base - hold_IO_node->base;
+
+				// If we used any, add it to the board's list
+				if (hold_IO_node->length) {
+					hold_IO_node->next = func->io_head;
+					func->io_head = hold_IO_node;
+
+					temp_byte = (io_node->base - 1) >> 8;
+					pci_bus_write_config_byte(ctrl->pci_bus, devfn, PCI_IO_LIMIT, temp_byte);
+
+					return_resource(&(resources->io_head), io_node);
+				} else {
+					// it doesn't need any IO
+					temp_word = 0x0000;
+					pci_bus_write_config_word(ctrl->pci_bus, devfn, PCI_IO_LIMIT, temp_word);
+
+					return_resource(&(resources->io_head), io_node);
+					kfree(hold_IO_node);
+				}
+			} else {
+				// it used most of the range
+				hold_IO_node->next = func->io_head;
+				func->io_head = hold_IO_node;
+			}
+		} else if (hold_IO_node) {
+			// it used the whole range
+			hold_IO_node->next = func->io_head;
+			func->io_head = hold_IO_node;
+		}
+		// If we have memory space available and there is some left,
+		// return the unused portion
+		if (hold_mem_node && temp_resources.mem_head) {
+			mem_node = do_pre_bridge_resource_split(&(temp_resources.  mem_head),
+													&hold_mem_node, 0x100000);
+
+			// Check if we were able to split something off
+			if (mem_node) {
+				hold_mem_node->base = mem_node->base + mem_node->length;
+
+				temp_word = (hold_mem_node->base) >> 16;
+				pci_bus_write_config_word(ctrl->pci_bus, devfn, PCI_MEMORY_BASE, temp_word);
+
+				return_resource(&(resources->mem_head), mem_node);
+			}
+
+			mem_node = do_bridge_resource_split(&(temp_resources.mem_head), 0x100000);
+
+			// Check if we were able to split something off
+			if (mem_node) {
+				// First use the temporary node to store information for the board
+				hold_mem_node->length = mem_node->base - hold_mem_node->base;
+
+				if (hold_mem_node->length) {
+					hold_mem_node->next = func->mem_head;
+					func->mem_head = hold_mem_node;
+
+					// configure end address
+					temp_word = (mem_node->base - 1) >> 16;
+					pci_bus_write_config_word(ctrl->pci_bus, devfn, PCI_MEMORY_LIMIT, temp_word);
+
+					// Return unused resources to the pool
+					return_resource(&(resources->mem_head), mem_node);
+				} else {
+					// it doesn't need any Mem
+					temp_word = 0x0000;
+					pci_bus_write_config_word(ctrl->pci_bus, devfn, PCI_MEMORY_LIMIT, temp_word);
+
+					return_resource(&(resources->mem_head), mem_node);
+					kfree(hold_mem_node);
+				}
+			} else {
+				// it used most of the range
+				hold_mem_node->next = func->mem_head;
+				func->mem_head = hold_mem_node;
+			}
+		} else if (hold_mem_node) {
+			// it used the whole range
+			hold_mem_node->next = func->mem_head;
+			func->mem_head = hold_mem_node;
+		}
+		// If we have prefetchable memory space available and there is some
+		// left at the end, return the unused portion
+		if (hold_p_mem_node && temp_resources.p_mem_head) {
+			p_mem_node = do_pre_bridge_resource_split(&(temp_resources.p_mem_head),
+													  &hold_p_mem_node, 0x100000);
+
+			// Check if we were able to split something off
+			if (p_mem_node) {
+				hold_p_mem_node->base = p_mem_node->base + p_mem_node->length;
+
+				temp_word = (hold_p_mem_node->base) >> 16;
+				pci_bus_write_config_word(ctrl->pci_bus, devfn, PCI_PREF_MEMORY_BASE, temp_word);
+
+				return_resource(&(resources->p_mem_head), p_mem_node);
+			}
+
+			p_mem_node = do_bridge_resource_split(&(temp_resources.p_mem_head), 0x100000);
+
+			// Check if we were able to split something off
+			if (p_mem_node) {
+				// First use the temporary node to store information for the board
+				hold_p_mem_node->length = p_mem_node->base - hold_p_mem_node->base;
+
+				// If we used any, add it to the board's list
+				if (hold_p_mem_node->length) {
+					hold_p_mem_node->next = func->p_mem_head;
+					func->p_mem_head = hold_p_mem_node;
+
+					temp_word = (p_mem_node->base - 1) >> 16;
+					pci_bus_write_config_word(ctrl->pci_bus, devfn, PCI_PREF_MEMORY_LIMIT, temp_word);
+
+					return_resource(&(resources->p_mem_head), p_mem_node);
+				} else {
+					// it doesn't need any PMem
+					temp_word = 0x0000;
+					pci_bus_write_config_word(ctrl->pci_bus, devfn, PCI_PREF_MEMORY_LIMIT, temp_word);
+
+					return_resource(&(resources->p_mem_head), p_mem_node);
+					kfree(hold_p_mem_node);
+				}
+			} else {
+				// it used the most of the range
+				hold_p_mem_node->next = func->p_mem_head;
+				func->p_mem_head = hold_p_mem_node;
+			}
+		} else if (hold_p_mem_node) {
+			// it used the whole range
+			hold_p_mem_node->next = func->p_mem_head;
+			func->p_mem_head = hold_p_mem_node;
+		}
+		// We should be configuring an IRQ and the bridge's base address
+		// registers if it needs them.  Although we have never seen such
+		// a device
+
+		// enable card
+		command = 0x0157;	// = PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER |  PCI_COMMAND_INVALIDATE | PCI_COMMAND_PARITY | PCI_COMMAND_SERR
+		pci_bus_write_config_word(ctrl->pci_bus, devfn, PCI_COMMAND, command);
+
+		// set Bridge Control Register
+		command = 0x07;		// = PCI_BRIDGE_CTL_PARITY | PCI_BRIDGE_CTL_SERR | PCI_BRIDGE_CTL_NO_ISA
+		pci_bus_write_config_word(ctrl->pci_bus, devfn, PCI_BRIDGE_CONTROL, command);
+	} else if ((temp_byte & 0x7F) == PCI_HEADER_TYPE_NORMAL) {
+		// Standard device
+		pci_bus_read_config_byte(ctrl->pci_bus, devfn, 0x0B, &class_code);
+
+		if (class_code == PCI_BASE_CLASS_DISPLAY) {
+			// Display (video) adapter (not supported)
+			return(DEVICE_TYPE_NOT_SUPPORTED);
+		}
+		// Figure out IO and memory needs
+		for (cloop = 0x10; cloop <= 0x24; cloop += 4) {
+			temp_register = 0xFFFFFFFF;
+
+			dbg("%s -->CND: devfn=%x, offset=%d\n",__FUNCTION__, devfn, cloop);
+			pci_bus_write_config_dword(ctrl->pci_bus, devfn, cloop, temp_register);
+			pci_bus_read_config_dword(ctrl->pci_bus, devfn, cloop, &temp_register);
+			dbg("%s -->CND: base = 0x%x\n",__FUNCTION__, temp_register);
+
+			if (temp_register) {	  // If this register is implemented
+				if ((temp_register & 0x03L) == 0x01) {
+					// Map IO
+
+					// set base = amount of IO space
+					base = temp_register & 0xFFFFFFFC;
+					base = ~base + 1;
+
+					dbg("%s -->CND:      length = 0x%x\n",__FUNCTION__, base);
+					io_node = get_io_resource(&(resources->io_head), base);
+					dbg("%s -->Got io_node start = %8.8x, length = %8.8x next (%p)\n",__FUNCTION__,
+						io_node->base, io_node->length, io_node->next);
+					dbg("%s -->func (%p) io_head (%p)\n",__FUNCTION__, func, func->io_head);
+
+					// allocate the resource to the board
+					if (io_node) {
+						base = io_node->base;
+
+						io_node->next = func->io_head;
+						func->io_head = io_node;
+					} else
+						return -ENOMEM;
+				} else if ((temp_register & 0x0BL) == 0x08) {
+					// Map prefetchable memory
+					base = temp_register & 0xFFFFFFF0;
+					base = ~base + 1;
+
+					dbg("%s -->CND:      length = 0x%x\n",__FUNCTION__, base);
+					p_mem_node = get_resource(&(resources->p_mem_head), base);
+
+					// allocate the resource to the board
+					if (p_mem_node) {
+						base = p_mem_node->base;
+
+						p_mem_node->next = func->p_mem_head;
+						func->p_mem_head = p_mem_node;
+					} else
+						return -ENOMEM;
+				} else if ((temp_register & 0x0BL) == 0x00) {
+					// Map memory
+					base = temp_register & 0xFFFFFFF0;
+					base = ~base + 1;
+
+					dbg("%s -->CND:      length = 0x%x\n",__FUNCTION__, base);
+					mem_node = get_resource(&(resources->mem_head), base);
+
+					// allocate the resource to the board
+					if (mem_node) {
+						base = mem_node->base;
+
+						mem_node->next = func->mem_head;
+						func->mem_head = mem_node;
+					} else
+						return -ENOMEM;
+				} else if ((temp_register & 0x0BL) == 0x04) {
+					// Map memory
+					base = temp_register & 0xFFFFFFF0;
+					base = ~base + 1;
+
+					dbg("%s -->CND:      length = 0x%x\n",__FUNCTION__, base);
+					mem_node = get_resource(&(resources->mem_head), base);
+
+					// allocate the resource to the board
+					if (mem_node) {
+						base = mem_node->base;
+
+						mem_node->next = func->mem_head;
+						func->mem_head = mem_node;
+					} else
+						return -ENOMEM;
+				} else if ((temp_register & 0x0BL) == 0x06) {
+					// Those bits are reserved, we can't handle this
+					return(1);
+				} else {
+					// Requesting space below 1M
+					return(NOT_ENOUGH_RESOURCES);
+				}
+
+				pci_bus_write_config_dword(ctrl->pci_bus, devfn, cloop, base);
+
+				// Check for 64-bit base
+				if ((temp_register & 0x07L) == 0x04) {
+					cloop += 4;
+
+					// Upper 32 bits of address always zero on today's systems
+					// FIXME this is probably not true on Alpha and ia64???
+					base = 0;
+					pci_bus_write_config_dword(ctrl->pci_bus, devfn, cloop, base);
+				}
+			}
+		}		// End of base register loop
+
+		// Figure out which interrupt pin this function uses
+		pci_bus_read_config_byte(ctrl->pci_bus, devfn, PCI_INTERRUPT_PIN, &temp_byte);
+		dbg("%s temp_byte for interrupt pin = %x", __FUNCTION__, temp_byte);
+		// If this function needs an interrupt and we are behind a bridge
+		// and the pin is tied to something that's already mapped,
+		// set this one the same
+		if (temp_byte && resources->irqs &&
+			(resources->irqs->valid_INT &
+			 (0x01 << ((temp_byte + resources->irqs->barber_pole - 1) & 0x03)))) {
+			// We have to share with something already set up
+			IRQ = resources->irqs->interrupt[(temp_byte + resources->irqs->barber_pole - 1) & 0x03];
+			dbg("%s We're sharing the IRQ from some other device = %02x", __FUNCTION__, IRQ);
+		} else {
+			// Program IRQ based on card type
+			pci_bus_read_config_byte(ctrl->pci_bus, devfn, 0x0B, &class_code);
+			if (class_code == PCI_BASE_CLASS_STORAGE) {
+				dbg("%s We're sharing the disk IRQ (maybe)", __FUNCTION__);
+				IRQ = amdshpc_disk_irq;
+			} else {
+				dbg("%s We're sharing the NIC IRQ (maybe)", __FUNCTION__);
+				IRQ = amdshpc_nic_irq;
+			}
+		}
+
+		// IRQ Line
+		pci_bus_write_config_byte(ctrl->pci_bus, devfn, PCI_INTERRUPT_LINE, IRQ);
+		if (!behind_bridge) {
+//			rc = amdshpc_set_irq(func->bus, func->device, temp_byte + 0x09, IRQ);
+//			rc = amdshpc_set_irq(func->bus, func->device, temp_byte + 20, IRQ);
+			rc = 0;
+			if (rc)
+				return 1;
+		} else {
+			//TBD - this code may also belong in the other clause of this If statement
+			resources->irqs->interrupt[(temp_byte + resources->irqs->barber_pole - 1) & 0x03] = IRQ;
+			resources->irqs->valid_INT |= 0x01 << (temp_byte + resources->irqs->barber_pole - 1) & 0x03;
+		}
+
+		// Latency Timer
+		temp_byte = 0x40;
+		pci_bus_write_config_byte(ctrl->pci_bus, devfn, PCI_LATENCY_TIMER, temp_byte);
+
+		// Cache Line size
+		temp_byte = 0x08;
+		pci_bus_write_config_byte(ctrl->pci_bus, devfn, PCI_CACHE_LINE_SIZE, temp_byte);
+
+		// disable ROM base Address
+		temp_dword = 0x00L;
+		pci_bus_write_config_word(ctrl->pci_bus, devfn, PCI_ROM_ADDRESS, temp_dword);
+
+		// enable card
+		temp_word = 0x0157;	// = PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER |  PCI_COMMAND_INVALIDATE | PCI_COMMAND_PARITY | PCI_COMMAND_SERR
+		pci_bus_write_config_word(ctrl->pci_bus, devfn, PCI_COMMAND, temp_word);
+	}			// End of Not-A-Bridge else
+	else {
+		// It's some strange type of PCI adapter (Cardbus?)
+		return DEVICE_TYPE_NOT_SUPPORTED;
+	}
+
+	func->configured = 1;
+
+	return 0;
+}
+
+int amdshpc_configure_device (struct controller * ctrl, struct pci_func* func)
+{
+	unsigned char bus;
+	struct pci_dev dev0;
+	struct pci_bus *child;
+	int num;
+
+	memset(&dev0, 0, sizeof(struct pci_dev));
+	dbg("%s", __FUNCTION__);
+
+	if (func->pci_dev == NULL)
+		func->pci_dev = pci_find_slot(func->bus, PCI_DEVFN(func->device, func->function));
+
+	//Still NULL ? Well then scan for it !
+	if (func->pci_dev == NULL) {
+		num = pci_scan_slot(ctrl->pci_dev->bus, PCI_DEVFN(func->device, func->function));
+		if (num)
+			pci_bus_add_devices(ctrl->pci_dev->bus);
+
+		func->pci_dev = pci_find_slot(func->bus, PCI_DEVFN(func->device, func->function));
+		if (func->pci_dev == NULL) {
+			dbg("ERROR: pci_dev still null\n");
+			return 0;
+		}
+	}
+
+	if (func->pci_dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {
+		pci_read_config_byte(func->pci_dev, PCI_SECONDARY_BUS, &bus);
+		child = (struct pci_bus*) pci_add_new_bus(func->pci_dev->bus, (func->pci_dev), bus);
+		pci_do_scan_bus(child);
+
+	}
+
+	return 0;
+}
+
+
+int amdshpc_unconfigure_device(struct pci_func* func)
+{
+	int j;
+
+	dbg("%s: bus/dev/func = %x/%x/%x\n",__FUNCTION__,func->bus, func->device, func->function);
+
+	for (j=0; j<8 ; j++) {
+		struct pci_dev* temp = pci_find_slot(func->bus, (func->device << 3) | j);
+		if (temp)
+			pci_remove_bus_device(temp);
+	}
+	return 0;
+}
+
+/*
+static int PCI_RefinedAccessConfig(struct pci_ops *ops, u8 bus, u8 device, u8 function, u8 offset, u32 *value)
+{
+	u32 vendID = 0;
+
+	dbg("%s", __FUNCTION__);
+	if (pci_read_config_dword_nodev (ops, bus, device, function, PCI_VENDOR_ID, &vendID) == -1)
+		return -1;
+	if (vendID == 0xffffffff)
+		return -1;
+	return pci_read_config_dword_nodev (ops, bus, device, function, offset, value);
+}
+
+
+//
+// WTF??? This function isn't in the code, yet a function calls it, but the
+// compiler optimizes it away?  strange.  Here as a placeholder to keep the
+// compiler happy.
+//
+static int PCI_ScanBusNonBridge (u8 bus, u8 device)
+{
+	return 0;
+}
+
+static int PCI_ScanBusForNonBridge(struct controller  *ctrl, u8 bus_num, u8 * dev_num)
+{
+	u8 tdevice;
+	u32 work;
+	u8 tbus;
+
+	dbg("%s", __FUNCTION__);
+	for (tdevice = 0; tdevice < 0x100; tdevice++) {
+		//Scan for access first
+		if (PCI_RefinedAccessConfig(ctrl->pci_ops, bus_num, tdevice >> 3, tdevice & 0x7, 0x08, &work) == -1)
+			continue;
+		dbg("Looking for nonbridge bus_num %d dev_num %d\n", bus_num, tdevice);
+		//Yep we got one. Not a bridge ?
+		if ((work >> 8) != PCI_TO_PCI_BRIDGE_CLASS) {
+			*dev_num = tdevice;
+			dbg("found it !\n");
+			return 0;
+		}
+	}
+	for (tdevice = 0; tdevice < 0x100; tdevice++) {
+		//Scan for access first
+		if (PCI_RefinedAccessConfig(ctrl->pci_ops, bus_num, tdevice >> 3, tdevice & 0x7, 0x08, &work) == -1)
+			continue;
+		dbg("Looking for bridge bus_num %d dev_num %d\n", bus_num, tdevice);
+		//Yep we got one. bridge ?
+		if ((work >> 8) == PCI_TO_PCI_BRIDGE_CLASS) {
+			pci_read_config_byte_nodev (ctrl->pci_ops, tbus, tdevice, 0, PCI_SECONDARY_BUS, &tbus);
+			dbg("Recurse on bus_num %d tdevice %d\n", tbus, tdevice);
+			if (PCI_ScanBusNonBridge(tbus, tdevice) == 0)
+				return 0;
+		}
+	}
+
+	return -1;
+}
+
+static int PCI_GetBusDevHelper(struct controller  *ctrl, u8 *bus_num, u8 *dev_num, u8 slot, u8 nobridge)
+{
+	struct irq_routing_table *PCIIRQRoutingInfoLength;
+	long len;
+	long loop;
+	u32 work;
+
+	u8 tbus, tdevice, tslot;
+
+	PCIIRQRoutingInfoLength = pcibios_get_irq_routing_table();
+
+	len = (PCIIRQRoutingInfoLength->size -
+	       sizeof(struct irq_routing_table)) / sizeof(struct irq_info);
+	dbg("%s  len = %d",__FUNCTION__, (int)len);
+	// Make sure I got at least one entry
+	if (len == 0) {
+		if (PCIIRQRoutingInfoLength != NULL)
+			kfree(PCIIRQRoutingInfoLength );
+		return -1;
+	}
+
+	for (loop = 0; loop < len; ++loop) {
+		tbus = PCIIRQRoutingInfoLength->slots[loop].bus;
+		tdevice = PCIIRQRoutingInfoLength->slots[loop].devfn;
+		tslot = PCIIRQRoutingInfoLength->slots[loop].slot;
+		dbg("%s  tbus = %02Xh  tdevice = %02Xh  device = %02Xh function = %d  tslot = %d",__FUNCTION__,
+							tbus, tdevice, tdevice >>3, tdevice & 0x7, tslot);
+		if (tslot == slot) {
+			*bus_num = tbus;
+			*dev_num = tdevice;
+			pci_read_config_dword_nodev (ctrl->pci_ops, *bus_num, *dev_num >> 3, *dev_num & 0x7, PCI_VENDOR_ID, &work);
+			if (!nobridge || (work == 0xffffffff)) {
+				if (PCIIRQRoutingInfoLength != NULL)
+					dbg("%s PCIIRQRoutingInfoLength != NULL  returning 0",__FUNCTION__);
+					kfree(PCIIRQRoutingInfoLength );
+				return 0;
+			}
+
+			dbg("bus_num %d dev_num %d func_num %d\n", *bus_num, *dev_num >> 3, *dev_num & 0x7);
+			pci_read_config_dword_nodev (ctrl->pci_ops, *bus_num, *dev_num >> 3, *dev_num & 0x7, PCI_CLASS_REVISION, &work);
+			dbg("work >> 8 (%x) = BRIDGE (%x)\n", work >> 8, PCI_TO_PCI_BRIDGE_CLASS);
+
+			if ((work >> 8) == PCI_TO_PCI_BRIDGE_CLASS) {
+				pci_read_config_byte_nodev (ctrl->pci_ops, *bus_num, *dev_num >> 3, *dev_num & 0x7, PCI_SECONDARY_BUS, &tbus);
+				dbg("Scan bus for Non Bridge: bus %d\n", tbus);
+				if (PCI_ScanBusForNonBridge(ctrl, tbus, dev_num) == 0) {
+					*bus_num = tbus;
+					if (PCIIRQRoutingInfoLength != NULL)
+						kfree(PCIIRQRoutingInfoLength );
+					return 0;
+				}
+			} else {
+				if (PCIIRQRoutingInfoLength != NULL)
+					kfree(PCIIRQRoutingInfoLength );
+				return 0;
+			}
+
+		}
+	}
+	if (PCIIRQRoutingInfoLength != NULL)
+		kfree(PCIIRQRoutingInfoLength );
+	return -1;
+}
+
+
+int amdshpc_get_bus_dev (struct controller  *ctrl, u8 * bus_num, u8 * dev_num, u8 slot)
+{
+	dbg("%s", __FUNCTION__);
+	return PCI_GetBusDevHelper(ctrl, bus_num, dev_num, slot, 0);	//plain (bridges allowed)
+}
+*/
+
+/* More PCI configuration routines; this time centered around hotplug controller */
+
+
+/*
+ * amdshpc_save_slot_config
+ *
+ * Saves configuration info for all PCI devices in a given slot
+ * including subordinate busses.
+ *
+ * returns 0 if success
+ */
+int amdshpc_save_slot_config (struct controller  *ctrl, struct pci_func * new_slot)
+{
+	long rc;
+	u8 class_code;
+	u8 header_type;
+	u32 ID;
+	u8 secondary_bus;
+	int sub_bus;
+	int max_functions;
+	int function;
+	int cloop = 0;
+	int stop_it;
+
+	ID = 0xFFFFFFFF;
+
+	dbg("%s", __FUNCTION__);
+	pci_bus_read_config_dword(ctrl->pci_bus, PCI_DEVFN(new_slot->device, 0), PCI_VENDOR_ID, &ID);
+
+	if (ID != 0xFFFFFFFF) {	  //  device in slot
+		pci_bus_read_config_byte(ctrl->pci_bus, PCI_DEVFN(new_slot->device, 0), 0x0B, &class_code);
+		pci_bus_read_config_byte(ctrl->pci_bus, PCI_DEVFN(new_slot->device, 0), PCI_HEADER_TYPE, &header_type);
+
+		if (header_type & 0x80)	// Multi-function device
+			max_functions = 8;
+		else
+			max_functions = 1;
+
+		function = 0;
+
+		do {
+			if ((header_type & 0x7F) == PCI_HEADER_TYPE_BRIDGE) {	  // PCI-PCI Bridge
+				//  Recurse the subordinate bus
+				pci_bus_read_config_byte(ctrl->pci_bus, PCI_DEVFN(new_slot->device, function), PCI_SECONDARY_BUS, &secondary_bus);
+
+				sub_bus = (int) secondary_bus;
+
+				// Save the config headers for the secondary bus.
+				rc = amdshpc_save_config(ctrl, sub_bus, 0);
+
+				if (rc)
+					return(rc);
+
+			}	// End of IF
+
+			new_slot->status = 0;
+
+			for (cloop = 0; cloop < 0x20; cloop++) {
+				pci_bus_read_config_dword(ctrl->pci_bus, PCI_DEVFN(new_slot->device, function), cloop << 2, (u32 *) & (new_slot-> config_space [cloop]));
+			}
+
+			function++;
+
+			stop_it = 0;
+
+			//  this loop skips to the next present function
+			//  reading in the Class Code and the Header type.
+
+			while ((function < max_functions) && (!stop_it)) {
+				pci_bus_read_config_dword(ctrl->pci_bus, PCI_DEVFN(new_slot->device, function), PCI_VENDOR_ID, &ID);
+
+				if (ID == 0xFFFFFFFF) {	 // nothing there.
+					function++;
+				} else {  // Something there
+					pci_bus_read_config_byte(ctrl->pci_bus, PCI_DEVFN(new_slot->device, function), 0x0B, &class_code);
+					pci_bus_read_config_byte(ctrl->pci_bus, PCI_DEVFN(new_slot->device, function), PCI_HEADER_TYPE, &header_type);
+
+					stop_it++;
+				}
+			}
+
+		} while (function < max_functions);
+	}			// End of IF (device in slot?)
+	else {
+		return(2);
+	}
+
+	return(0);
+}
+
+
+/*
+ * amdshpc_save_base_addr_length
+ *
+ * Saves the length of all base address registers for the
+ * specified slot.  this is for hot plug REPLACE
+ *
+ * returns 0 if success
+ */
+int amdshpc_save_base_addr_length(struct controller  *ctrl, struct pci_func * func)
+{
+	u8 cloop;
+	u8 header_type;
+	u8 secondary_bus;
+	u8 type;
+	int sub_bus;
+	u32 temp_register;
+	u32 base;
+	u32 rc;
+	struct pci_func *next;
+	int index = 0;
+
+	dbg("%s", __FUNCTION__);
+	func = amdshpc_slot_find(func->bus, func->device, index++);
+
+	while (func != NULL) {
+		int devfn = PCI_DEVFN(func->device, func->function);
+
+		// Check for Bridge
+		pci_bus_read_config_byte(ctrl->pci_bus, devfn, PCI_HEADER_TYPE, &header_type);
+
+		if ((header_type & 0x7F) == PCI_HEADER_TYPE_BRIDGE) {
+			// PCI-PCI Bridge
+			pci_bus_read_config_byte(ctrl->pci_bus, devfn, PCI_SECONDARY_BUS, &secondary_bus);
+
+			sub_bus = (int) secondary_bus;
+
+			next = amdshpc_slot_list[sub_bus];
+
+			while (next != NULL) {
+				rc = amdshpc_save_base_addr_length(ctrl, next);
+
+				if (rc)
+					return(rc);
+
+				next = next->next;
+			}
+
+			//FIXME: this loop is duplicated in the non-bridge case.  The two could be rolled together
+			// Figure out IO and memory base lengths
+			for (cloop = 0x10; cloop <= 0x14; cloop += 4) {
+				temp_register = 0xFFFFFFFF;
+				pci_bus_write_config_dword(ctrl->pci_bus, devfn, cloop, temp_register);
+				pci_bus_read_config_dword(ctrl->pci_bus, devfn, cloop, &base);
+
+				if (base) {  // If this register is implemented
+					if (base & 0x01L) {
+						// IO base
+						// set base = amount of IO space requested
+						base = base & 0xFFFFFFFE;
+						base = (~base) + 1;
+
+						type = 1;
+					} else {
+						// memory base
+						base = base & 0xFFFFFFF0;
+						base = (~base) + 1;
+
+						type = 0;
+					}
+				} else {
+					base = 0x0L;
+					type = 0;
+				}
+
+				// Save information in slot structure
+				func->base_length[(cloop - 0x10) >> 2] = base;
+				func->base_type[(cloop - 0x10) >> 2] = type;
+
+			}	// End of base register loop
+
+
+		} else if ((header_type & 0x7F) == 0x00) {	  // PCI-PCI Bridge
+			// Figure out IO and memory base lengths
+			for (cloop = 0x10; cloop <= 0x24; cloop += 4) {
+				temp_register = 0xFFFFFFFF;
+				pci_bus_write_config_dword(ctrl->pci_bus, devfn, cloop, temp_register);
+				pci_bus_read_config_dword(ctrl->pci_bus, devfn, cloop, &base);
+
+				if (base) {  // If this register is implemented
+					if (base & 0x01L) {
+						// IO base
+						// base = amount of IO space requested
+						base = base & 0xFFFFFFFE;
+						base = (~base) + 1;
+
+						type = 1;
+					} else {
+						// memory base
+						// base = amount of memory space requested
+						base = base & 0xFFFFFFF0;
+						base = (~base) + 1;
+
+						type = 0;
+					}
+				} else {
+					base = 0x0L;
+					type = 0;
+				}
+
+				// Save information in slot structure
+				func->base_length[(cloop - 0x10) >> 2] = base;
+				func->base_type[(cloop - 0x10) >> 2] = type;
+
+			}	// End of base register loop
+
+		} else {	  // Some other unknown header type
+		}
+
+		// find the next device in this slot
+		func = amdshpc_slot_find(func->bus, func->device, index++);
+	}
+
+	return(0);
+}
+
+
+/*
+ * amdshpc_save_used_resources
+ *
+ * Stores used resource information for existing boards.  this is
+ * for boards that were in the system when this driver was loaded.
+ * this function is for hot plug ADD
+ *
+ * returns 0 if success
+ */
+int amdshpc_save_used_resources (struct controller  *ctrl, struct pci_func * func)
+{
+	u8 cloop;
+	u8 header_type;
+	u8 secondary_bus;
+	u8 temp_byte;
+	u8 b_base;
+	u8 b_length;
+	u16 command;
+	u16 save_command;
+	u16 w_base;
+	u16 w_length;
+	u32 temp_register;
+	u32 save_base;
+	u32 base;
+	int index = 0;
+	struct pci_resource *mem_node;
+	struct pci_resource *p_mem_node;
+	struct pci_resource *io_node;
+	struct pci_resource *bus_node;
+
+	dbg("%s", __FUNCTION__);
+	func = amdshpc_slot_find(func->bus, func->device, index++);
+
+	while ((func != NULL) && func->is_a_board) {
+		int devfn = PCI_DEVFN(func->device, func->function);
+
+		// Save the command register
+		pci_bus_read_config_word(ctrl->pci_bus, devfn, PCI_COMMAND, &save_command);
+
+		// disable card
+		command = 0x00;
+		pci_bus_write_config_word(ctrl->pci_bus, devfn, PCI_COMMAND, command);
+
+		// Check for Bridge
+		pci_bus_read_config_byte(ctrl->pci_bus, devfn, PCI_HEADER_TYPE, &header_type);
+
+		if ((header_type & 0x7F) == PCI_HEADER_TYPE_BRIDGE) {	  // PCI-PCI Bridge
+			// Clear Bridge Control Register
+			command = 0x00;
+			pci_bus_write_config_word(ctrl->pci_bus, devfn, PCI_BRIDGE_CONTROL, command);
+			pci_bus_read_config_byte(ctrl->pci_bus, devfn, PCI_SECONDARY_BUS, &secondary_bus);
+			pci_bus_read_config_byte(ctrl->pci_bus, devfn, PCI_SUBORDINATE_BUS, &temp_byte);
+
+			bus_node =(struct pci_resource *) kmalloc(sizeof(struct pci_resource), GFP_KERNEL);
+			if (!bus_node)
+				return -ENOMEM;
+
+			bus_node->base = secondary_bus;
+			bus_node->length = temp_byte - secondary_bus + 1;
+
+			bus_node->next = func->bus_head;
+			func->bus_head = bus_node;
+
+			// Save IO base and Limit registers
+			pci_bus_read_config_byte(ctrl->pci_bus, devfn, PCI_IO_BASE, &b_base);
+			pci_bus_read_config_byte(ctrl->pci_bus, devfn, PCI_IO_LIMIT, &b_length);
+
+			if ((b_base <= b_length) && (save_command & 0x01)) {
+				io_node = (struct pci_resource *) kmalloc(sizeof(struct pci_resource), GFP_KERNEL);
+				if (!io_node)
+					return -ENOMEM;
+
+				io_node->base = (b_base & 0xF0) << 8;
+				io_node->length = (b_length - b_base + 0x10) << 8;
+
+				io_node->next = func->io_head;
+				func->io_head = io_node;
+			}
+			// Save memory base and Limit registers
+			pci_bus_read_config_word(ctrl->pci_bus, devfn, PCI_MEMORY_BASE, &w_base);
+			pci_bus_read_config_word(ctrl->pci_bus, devfn, PCI_MEMORY_LIMIT, &w_length);
+
+			if ((w_base <= w_length) && (save_command & 0x02)) {
+				mem_node = (struct pci_resource *) kmalloc(sizeof(struct pci_resource), GFP_KERNEL);
+				if (!mem_node)
+					return -ENOMEM;
+
+				mem_node->base = w_base << 16;
+				mem_node->length = (w_length - w_base + 0x10) << 16;
+
+				mem_node->next = func->mem_head;
+				func->mem_head = mem_node;
+			}
+			// Save prefetchable memory base and Limit registers
+			pci_bus_read_config_word(ctrl->pci_bus, devfn, PCI_PREF_MEMORY_BASE, &w_base);
+			pci_bus_read_config_word(ctrl->pci_bus, devfn, PCI_PREF_MEMORY_LIMIT, &w_length);
+
+			if ((w_base <= w_length) && (save_command & 0x02)) {
+				p_mem_node = (struct pci_resource *) kmalloc(sizeof(struct pci_resource), GFP_KERNEL);
+				if (!p_mem_node)
+					return -ENOMEM;
+
+				p_mem_node->base = w_base << 16;
+				p_mem_node->length = (w_length - w_base + 0x10) << 16;
+
+				p_mem_node->next = func->p_mem_head;
+				func->p_mem_head = p_mem_node;
+			}
+			// Figure out IO and memory base lengths
+			for (cloop = 0x10; cloop <= 0x14; cloop += 4) {
+				pci_bus_read_config_dword(ctrl->pci_bus, devfn, cloop, &save_base);
+
+				temp_register = 0xFFFFFFFF;
+				pci_bus_write_config_dword(ctrl->pci_bus, devfn, cloop, temp_register);
+				pci_bus_read_config_dword(ctrl->pci_bus, devfn, cloop, &base);
+
+				temp_register = base;
+
+				if (base) {  // If this register is implemented
+					if (((base & 0x03L) == 0x01)
+					    && (save_command & 0x01)) {
+						// IO base
+						// set temp_register = amount of IO space requested
+						temp_register = base & 0xFFFFFFFE;
+						temp_register = (~temp_register) + 1;
+
+						io_node = (struct pci_resource *) kmalloc(sizeof(struct pci_resource), GFP_KERNEL);
+						if (!io_node)
+							return -ENOMEM;
+
+						io_node->base =
+						save_base & (~0x03L);
+						io_node->length = temp_register;
+
+						io_node->next = func->io_head;
+						func->io_head = io_node;
+					} else
+						if (((base & 0x0BL) == 0x08)
+						    && (save_command & 0x02)) {
+						// prefetchable memory base
+						temp_register = base & 0xFFFFFFF0;
+						temp_register = (~temp_register) + 1;
+
+						p_mem_node = (struct pci_resource *) kmalloc(sizeof(struct pci_resource), GFP_KERNEL);
+						if (!p_mem_node)
+							return -ENOMEM;
+
+						p_mem_node->base = save_base & (~0x0FL);
+						p_mem_node->length = temp_register;
+
+						p_mem_node->next = func->p_mem_head;
+						func->p_mem_head = p_mem_node;
+					} else
+						if (((base & 0x0BL) == 0x00)
+						    && (save_command & 0x02)) {
+						// prefetchable memory base
+						temp_register = base & 0xFFFFFFF0;
+						temp_register = (~temp_register) + 1;
+
+						mem_node = (struct pci_resource *) kmalloc(sizeof(struct pci_resource), GFP_KERNEL);
+						if (!mem_node)
+							return -ENOMEM;
+
+						mem_node->base = save_base & (~0x0FL);
+						mem_node->length = temp_register;
+
+						mem_node->next = func->mem_head;
+						func->mem_head = mem_node;
+					} else
+						return(1);
+				}
+			}	// End of base register loop
+		} else if ((header_type & 0x7F) == 0x00) {	  // Standard header
+			// Figure out IO and memory base lengths
+			for (cloop = 0x10; cloop <= 0x24; cloop += 4) {
+				pci_bus_read_config_dword(ctrl->pci_bus, devfn, cloop, &save_base);
+
+				temp_register = 0xFFFFFFFF;
+				pci_bus_write_config_dword(ctrl->pci_bus, devfn, cloop, temp_register);
+				pci_bus_read_config_dword(ctrl->pci_bus, devfn, cloop, &base);
+
+				temp_register = base;
+
+				if (base) {	  // If this register is implemented
+					if (((base & 0x03L) == 0x01)
+					    && (save_command & 0x01)) {
+						// IO base
+						// set temp_register = amount of IO space requested
+						temp_register = base & 0xFFFFFFFE;
+						temp_register = (~temp_register) + 1;
+
+						io_node = (struct pci_resource *) kmalloc(sizeof(struct pci_resource), GFP_KERNEL);
+						if (!io_node)
+							return -ENOMEM;
+
+						io_node->base = save_base & (~0x01L);
+						io_node->length = temp_register;
+
+						io_node->next = func->io_head;
+						func->io_head = io_node;
+					} else
+						if (((base & 0x0BL) == 0x08)
+						    && (save_command & 0x02)) {
+						// prefetchable memory base
+						temp_register = base & 0xFFFFFFF0;
+						temp_register = (~temp_register) + 1;
+
+						p_mem_node = (struct pci_resource *) kmalloc(sizeof(struct pci_resource), GFP_KERNEL);
+						if (!p_mem_node)
+							return -ENOMEM;
+
+						p_mem_node->base = save_base & (~0x0FL);
+						p_mem_node->length = temp_register;
+
+						p_mem_node->next = func->p_mem_head;
+						func->p_mem_head = p_mem_node;
+					} else
+						if (((base & 0x0BL) == 0x00)
+						    && (save_command & 0x02)) {
+						// prefetchable memory base
+						temp_register = base & 0xFFFFFFF0;
+						temp_register = (~temp_register) + 1;
+
+						mem_node = (struct pci_resource *) kmalloc(sizeof(struct pci_resource), GFP_KERNEL);
+						if (!mem_node)
+							return -ENOMEM;
+
+						mem_node->base = save_base & (~0x0FL);
+						mem_node->length = temp_register;
+
+						mem_node->next = func->mem_head;
+						func->mem_head = mem_node;
+					} else
+						return(1);
+				}
+			}	// End of base register loop
+		} else {	  // Some other unknown header type
+		}
+
+		// find the next device in this slot
+		func = amdshpc_slot_find(func->bus, func->device, index++);
+	}
+
+	return(0);
+}
+
+
+/*
+ * amdshpc_configure_board
+ *
+ * Copies saved configuration information to one slot.
+ * this is called recursively for bridge devices.
+ * this is for hot plug REPLACE!
+ *
+ * returns 0 if success
+ */
+int amdshpc_configure_board(struct controller  *ctrl, struct pci_func * func)
+{
+	int cloop;
+	u8 header_type;
+	u8 secondary_bus;
+	int sub_bus;
+	struct pci_func *next;
+	u32 temp;
+	u32 rc;
+	int index = 0;
+
+	dbg("%s", __FUNCTION__);
+	func = amdshpc_slot_find(func->bus, func->device, index++);
+
+	while (func != NULL) {
+		int devfn = PCI_DEVFN(func->device, func->function);
+
+		// Start at the top of config space so that the control
+		// registers are programmed last
+		for (cloop = 0x3C; cloop > 0; cloop -= 4) {
+			pci_bus_write_config_dword(ctrl->pci_bus, devfn, cloop, func->config_space[cloop >> 2]);
+		}
+
+		pci_bus_read_config_byte(ctrl->pci_bus, devfn, PCI_HEADER_TYPE, &header_type);
+
+		// If this is a bridge device, restore subordinate devices
+		if ((header_type & 0x7F) == PCI_HEADER_TYPE_BRIDGE) {	  // PCI-PCI Bridge
+			pci_bus_read_config_byte(ctrl->pci_bus, devfn, PCI_SECONDARY_BUS, &secondary_bus);
+
+			sub_bus = (int) secondary_bus;
+
+			next = amdshpc_slot_list[sub_bus];
+
+			while (next != NULL) {
+				rc = amdshpc_configure_board(ctrl, next);
+				if (rc)
+					return rc;
+
+				next = next->next;
+			}
+		} else {
+			// Check all the base Address Registers to make sure
+			// they are the same.  If not, the board is different.
+			for (cloop = 16; cloop < 40; cloop += 4) {
+				pci_bus_read_config_dword(ctrl->pci_bus, devfn, cloop, &temp);
+				if (temp != func->config_space[cloop >> 2]) {
+					dbg("Config space compare failure!!! offset = %x\n", cloop);
+					dbg("bus = %x, device = %x, function = %x\n", func->bus, func->device, func->function);
+					dbg("temp = %x, config space = %x\n\n", temp, func->config_space[cloop]);
+					return 1;
+				}
+			}
+		}
+
+		func->configured = 1;
+
+		func = amdshpc_slot_find(func->bus, func->device, index++);
+	}
+
+	return 0;
+}
+
+
+/*
+ * amdshpc_valid_replace
+ *
+ * this function checks to see if a board is the same as the
+ * one it is replacing.  this check will detect if the device's
+ * vendor or device id's are the same
+ *
+ * returns 0 if the board is the same nonzero otherwise
+ */
+int amdshpc_valid_replace(struct controller  *ctrl, struct pci_func * func)
+{
+	u8 cloop;
+	u8 header_type;
+	u8 secondary_bus;
+	u8 type;
+	u32 temp_register = 0;
+	u32 base;
+	u32 rc;
+	struct pci_func *next;
+	int index = 0;
+
+	dbg("%s", __FUNCTION__);
+	if (!func->is_a_board)
+		return(ADD_NOT_SUPPORTED);
+
+	func = amdshpc_slot_find(func->bus, func->device, index++);
+
+	while (func != NULL) {
+		int devfn = PCI_DEVFN(func->device, func->function);
+
+		pci_bus_read_config_dword(ctrl->pci_bus, devfn, PCI_VENDOR_ID, &temp_register);
+
+		// No adapter present
+		if (temp_register == 0xFFFFFFFF)
+			return(NO_ADAPTER_PRESENT);
+
+		if (temp_register != func->config_space[0])
+			return(ADAPTER_NOT_SAME);
+
+		// Check for same revision number and class code
+		pci_bus_read_config_dword(ctrl->pci_bus, devfn, PCI_CLASS_REVISION, &temp_register);
+
+		// Adapter not the same
+		if (temp_register != func->config_space[0x08 >> 2])
+			return(ADAPTER_NOT_SAME);
+
+		// Check for Bridge
+		pci_bus_read_config_byte(ctrl->pci_bus, devfn, PCI_HEADER_TYPE, &header_type);
+
+		if ((header_type & 0x7F) == PCI_HEADER_TYPE_BRIDGE) {	  // PCI-PCI Bridge
+			// In order to continue checking, we must program the
+			// bus registers in the bridge to respond to accesses
+			// for it's subordinate bus(es)
+
+			temp_register = func->config_space[0x18 >> 2];
+			pci_bus_write_config_dword(ctrl->pci_bus, devfn, PCI_PRIMARY_BUS, temp_register);
+
+			secondary_bus = (temp_register >> 8) & 0xFF;
+
+			next = amdshpc_slot_list[secondary_bus];
+
+			while (next != NULL) {
+				rc = amdshpc_valid_replace(ctrl, next);
+				if (rc)
+					return(rc);
+
+				next = next->next;
+			}
+
+		}
+		// Check to see if it is a standard config header
+		else if ((header_type & 0x7F) == PCI_HEADER_TYPE_NORMAL) {
+			// Check subsystem vendor and ID
+			pci_bus_read_config_dword(ctrl->pci_bus, devfn, PCI_SUBSYSTEM_VENDOR_ID, &temp_register);
+
+			if (temp_register != func->config_space[0x2C >> 2]) {
+				// If it's a SMART-2 and the register isn't filled
+				// in, ignore the difference because
+				// they just have an old rev of the firmware
+
+				if (!((func->config_space[0] == 0xAE100E11)
+				      && (temp_register == 0x00L)))
+					return(ADAPTER_NOT_SAME);
+			}
+			// Figure out IO and memory base lengths
+			for (cloop = 0x10; cloop <= 0x24; cloop += 4) {
+				temp_register = 0xFFFFFFFF;
+				pci_bus_write_config_dword(ctrl->pci_bus, devfn, cloop, temp_register);
+				pci_bus_read_config_dword(ctrl->pci_bus, devfn, cloop, &base);
+
+				if (base) {	  // If this register is implemented
+					if (base & 0x01L) {
+						// IO base
+						// set base = amount of IO space requested
+						base = base & 0xFFFFFFFE;
+						base = (~base) + 1;
+
+						type = 1;
+					} else {
+						// memory base
+						base = base & 0xFFFFFFF0;
+						base = (~base) + 1;
+
+						type = 0;
+					}
+				} else {
+					base = 0x0L;
+					type = 0;
+				}
+
+				// Check information in slot structure
+				if (func->base_length[(cloop - 0x10) >> 2] != base)
+					return(ADAPTER_NOT_SAME);
+
+				if (func->base_type[(cloop - 0x10) >> 2] != type)
+					return(ADAPTER_NOT_SAME);
+
+			}	// End of base register loop
+
+		}		// End of (type 0 config space) else
+		else {
+			// this is not a type 0 or 1 config space header so
+			// we don't know how to do it
+			return(DEVICE_TYPE_NOT_SUPPORTED);
+		}
+
+		// Get the next function
+		func = amdshpc_slot_find(func->bus, func->device, index++);
+	}
+
+	return(0);
+}
+
+
+
+static int update_slot_info (struct controller  *ctrl, struct slot *slot)
+{
+//	TO_DO_amd_update_slot_info();
+	dbg("%s   THIS FUNCTION IS STUBBED OUT!!!!!!!!!!!",__FUNCTION__);
+	return 0;
+	/*	struct hotplug_slot_info *info;
+	char buffer[SLOT_NAME_SIZE];
+	int result;
+
+	info = kmalloc (sizeof (struct hotplug_slot_info), GFP_KERNEL);
+	if (!info)
+		return -ENOMEM;
+
+	make_slot_name (&buffer[0], SLOT_NAME_SIZE, slot);
+	info->power_status = get_slot_enabled(ctrl, slot);
+	info->attention_status = cpq_get_attention_status(ctrl, slot);
+	info->latch_status = cpq_get_latch_status(ctrl, slot);
+	info->adapter_status = get_presence_status(ctrl, slot);
+	result = pci_hp_change_slot_info(buffer, info);
+	kfree (info);
+	return result;
+*/
+}
+
+
+/*
+ * slot_remove - Removes a node from the linked list of slots.
+ * @old_slot: slot to remove
+ *
+ * Returns 0 if successful, !0 otherwise.
+ */
+static int slot_remove(struct pci_func * old_slot)
+{
+	struct pci_func *next;
+
+	dbg("%s", __FUNCTION__);
+	if (old_slot == NULL)
+		return(1);
+
+	next = amdshpc_slot_list[old_slot->bus];
+
+	if (next == NULL) {
+		return(1);
+	}
+
+	if (next == old_slot) {
+		amdshpc_slot_list[old_slot->bus] = old_slot->next;
+		amdshpc_destroy_board_resources(old_slot);
+		kfree(old_slot);
+		return(0);
+	}
+
+	while ((next->next != old_slot) && (next->next != NULL)) {
+		next = next->next;
+	}
+
+	if (next->next == old_slot) {
+		next->next = old_slot->next;
+		amdshpc_destroy_board_resources(old_slot);
+		kfree(old_slot);
+		return(0);
+	} else
+		return(2);
+}
+
+// DJZ: I don't think is_bridge will work as is.
+//FIXME
+static int is_bridge(struct pci_func * func)
+{
+	dbg("%s", __FUNCTION__);
+	// Check the header type
+	if (((func->config_space[0x03] >> 16) & 0xFF) == 0x01)
+		return 1;
+	else
+		return 0;
+}
+
+
+/**
+ * bridge_slot_remove - Removes a node from the linked list of slots.
+ * @bridge: bridge to remove
+ *
+ * Returns 0 if successful, !0 otherwise.
+ */
+static int bridge_slot_remove(struct pci_func *bridge)
+{
+	u8 subordinateBus, secondaryBus;
+	u8 tempBus;
+	struct pci_func *next;
+
+	dbg("%s", __FUNCTION__);
+	if (bridge == NULL)
+		return(1);
+
+	secondaryBus = (bridge->config_space[0x06] >> 8) & 0xFF;
+	subordinateBus = (bridge->config_space[0x06] >> 16) & 0xFF;
+
+	for (tempBus = secondaryBus; tempBus <= subordinateBus; tempBus++) {
+		next = amdshpc_slot_list[tempBus];
+
+		while (!slot_remove(next)) {
+			next = amdshpc_slot_list[tempBus];
+		}
+	}
+
+	next = amdshpc_slot_list[bridge->bus];
+
+	if (next == NULL) {
+		return(1);
+	}
+
+	if (next == bridge) {
+		amdshpc_slot_list[bridge->bus] = bridge->next;
+		kfree(bridge);
+		return(0);
+	}
+
+	while ((next->next != bridge) && (next->next != NULL)) {
+		next = next->next;
+	}
+
+	if (next->next == bridge) {
+		next->next = bridge->next;
+		kfree(bridge);
+		return(0);
+	} else
+		return(2);
+}
+
+
diff -purN linux-2.5/drivers/pci/hotplug/dummyphp.c usb-2.5/drivers/pci/hotplug/dummyphp.c
--- linux-2.5/drivers/pci/hotplug/dummyphp.c	1970-01-01 00:00:00.000000000 +0000
+++ usb-2.5/drivers/pci/hotplug/dummyphp.c	2003-08-28 23:06:29.000000000 +0000
@@ -0,0 +1,295 @@
+/*
+ * Dummy PCI Hot Plug Controller Driver
+ *
+ * Copyright (C) 1995,2001 Compaq Computer Corporation
+ * Copyright (C) 2001,2003 Greg Kroah-Hartman (greg@kroah.com)
+ * Copyright (C) 2001,2003 IBM Corp.
+ * Copyright (C) 2002 Hiroshi Aono (h-aono@ap.jp.nec.com)
+ * Copyright (C) 2002 Takayoshi Kochi (t-kouchi@cq.jp.nec.com)
+ * Copyright (C) 2002 NEC Corporation
+ * Copyright (C) 2002 Vladimir Kondratiev (vladimir.kondratiev@intel.com)
+ * Copyright (C) 2003 Rolf Eike Beer (eike-kernel@sf-tec.de)
+ *
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+ * NON INFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Send feedback to <eike-kernel@sf-tec.de>
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include "pci_hotplug.h"
+#include "../pci.h"
+
+#if !defined(CONFIG_HOTPLUG_PCI_DUMMY_MODULE)
+	#define MY_NAME	"dummyphp"
+#else
+	#define MY_NAME	THIS_MODULE->name
+#endif
+
+#define dbg(format, arg...)					\
+	do {							\
+		if (debug)					\
+			printk(KERN_DEBUG "%s: " format,	\
+				MY_NAME , ## arg); 		\
+	} while (0)
+#define err(format, arg...) printk(KERN_ERR "%s: " format, MY_NAME , ## arg)
+#define info(format, arg...) printk(KERN_INFO "%s: " format, MY_NAME , ## arg)
+
+/* name size which is used for entries in pcihpfs */
+#define SLOT_NAME_SIZE	32		/* DUMMY-{BUS}:{DEV} */
+
+struct dummy_slot {
+	struct pci_bus	*bus;
+	int		devfn;
+};
+
+static int debug;
+
+#define DRIVER_VERSION	"0.1"
+#define DRIVER_AUTHOR	"Rolf Eike Beer <eike-kernel@sf-tec.de>"
+#define DRIVER_DESC	"Dummy PCI Hot Plug Controller Driver"
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
+MODULE_PARM(debug, "i");
+MODULE_PARM_DESC(debug, "Debugging mode enabled or not");
+
+static int enable_slot		(struct hotplug_slot *slot);
+static int disable_slot		(struct hotplug_slot *slot);
+
+/*
+   This is a dummy driver, so we make us live as easy as possible:
+   -if there is an adapter registered in the linux PCI system, then it is present
+   -if there is an adapter present, the power is on (and vice versa!)
+   -if the power is on, the latch is closed (and vice versa)
+   -the attention LED is always off
+
+   So:
+   => latch_status = adapter_status = power_status
+ */
+
+static struct hotplug_slot_ops dummy_hotplug_slot_ops = {
+	.owner			= THIS_MODULE,
+	.enable_slot		= enable_slot,
+	.disable_slot		= disable_slot,
+};
+
+/**
+ * enable_slot - power on and enable a slot
+ * @hotplug_slot: slot to enable
+ */
+static int
+enable_slot(struct hotplug_slot *hotplug_slot)
+{
+	struct dummy_slot *slot;
+
+	if (!hotplug_slot)
+		return -ENODEV;
+
+	dbg("%s - physical_slot = %s\n", __FUNCTION__, hotplug_slot->name);
+
+	/* enable the specified slot */
+	slot = (struct dummy_slot *) hotplug_slot->private;
+
+	if (pci_scan_slot(slot->bus, slot->devfn)) {
+		hotplug_slot->info->power_status = 1;
+		hotplug_slot->info->adapter_status = 1;
+		hotplug_slot->info->latch_status = 1;
+		return 0;
+	}
+	return -ENODEV;
+}
+
+
+/**
+ * disable_slot - disable any adapter in this slot
+ * @hotplug_slot: slot to disable
+ */
+static int
+disable_slot(struct hotplug_slot *hotplug_slot)
+{
+	struct pci_dev* old_dev;
+	int func;
+	struct dummy_slot *slot;
+
+	if (!hotplug_slot)
+		return -ENODEV;
+
+	slot = (struct dummy_slot *) hotplug_slot->private;
+
+	dbg("%s - physical_slot = %s\n", __FUNCTION__, hotplug_slot->name);
+
+	/* disable the specified slot */
+
+	for (func=0; func<8; func++) {
+		old_dev = pci_find_slot(slot->bus->number, slot->devfn+func);
+		if (old_dev) {
+			printk(KERN_INFO "Slot %s removed\n", old_dev->slot_name);
+			pci_remove_device_safe(old_dev);
+		}
+	}
+	hotplug_slot->info->power_status = 0;
+	hotplug_slot->info->adapter_status = 0;
+	hotplug_slot->info->latch_status = 0;
+
+
+	return 0;
+}
+
+
+/**
+ * dummyphp_get_power_status - look if an adapter is configured in this slot
+ * @slot: the slot to test
+ */
+static int dummyphp_get_power_status(struct dummy_slot *slot)
+{
+	struct pci_dev* old_dev;
+	int func;
+
+	for (func = 0; func < 8; func++) {
+		old_dev = pci_find_slot(slot->bus->number, slot->devfn+func);
+		if (old_dev)
+			return 1;
+	}
+
+	return 0;
+}
+
+/**
+ * scan_pci_bus - add an entry for every slot on this bus
+ * @bus: bus to scan
+ */
+static int __init
+scan_pci_bus(const struct pci_bus *bus)
+{
+	struct dummy_slot *dslot;
+	struct hotplug_slot *hp;
+	int retval = 0;
+	unsigned int devfn;
+	struct pci_dev dev0;
+
+	memset(&dev0, 0, sizeof(dev0));
+	dev0.bus = (struct pci_bus*)bus;
+	dev0.sysdata = bus->sysdata;
+	for (devfn = 0; devfn < 0x100; devfn += 8) {
+		hp = kmalloc(sizeof(struct hotplug_slot), GFP_KERNEL);
+		if (!hp) {
+			return -ENOMEM;
+		}
+		memset(hp, 0, sizeof(struct hotplug_slot));
+
+		hp->info = kmalloc(sizeof(struct hotplug_slot_info), GFP_KERNEL);
+		if (!hp->info) {
+			kfree(hp);
+			return -ENOMEM;
+		}
+		memset(hp->info, 0, sizeof(struct hotplug_slot_info));
+
+		hp->name = kmalloc(SLOT_NAME_SIZE, GFP_KERNEL);
+		dslot = kmalloc(sizeof(struct dummy_slot), GFP_KERNEL);
+		if ( (!hp->name) || (!dslot) ) {
+			kfree(hp->info);
+			kfree(hp->name);
+			kfree(dslot);
+			kfree(hp);
+			return -ENOMEM;
+		}
+		dslot->bus = (struct pci_bus *) bus;
+		dslot->devfn = devfn;
+
+		hp->ops = &dummy_hotplug_slot_ops;
+		hp->private = (void *) dslot;
+
+		hp->info->power_status = dummyphp_get_power_status(dslot);
+		hp->info->latch_status = hp->info->power_status;
+		hp->info->adapter_status = hp->info->power_status;
+
+		/* set fixed values so we do not need callbacks for these */
+		hp->info->attention_status = 0;
+		hp->info->cur_bus_speed = PCI_SPEED_UNKNOWN;
+		hp->info->max_bus_speed = PCI_SPEED_UNKNOWN;
+
+		snprintf(hp->name, SLOT_NAME_SIZE, "DUMMY-%02x:%02x",
+			dslot->bus->number,
+			dslot->devfn / 8);
+
+		retval = pci_hp_register(hp);
+		if (retval) {
+			err("pci_hp_register failed with error %d\n", retval);
+			kfree(hp->info);
+			kfree(hp->name);
+			kfree(hp);
+			kfree(dslot);
+			return retval;
+		}
+
+	}
+	return 0;
+}
+
+/**
+ * scan_pci_buses - scan this bus and all child buses for slots
+ * @list: list of buses to scan
+ */
+static int __init
+pci_scan_buses(const struct list_head *list)
+{
+	int retval;
+	const struct list_head *l;
+
+	list_for_each(l,list) {
+		const struct pci_bus *b = pci_bus_b(l);
+		retval = scan_pci_bus(b);
+		if (retval)
+			return retval;
+		retval = pci_scan_buses(&b->children);
+		if (retval)
+			return retval;
+	}
+	return 0;
+}
+
+static void __exit
+cleanup_slots (void)
+{
+/*FIXME: look at every hotplug_slot if name begins with "DUMMY-" an kick them*/
+}
+
+
+static int __init
+dummyphp_init(void)
+{
+	info(DRIVER_DESC " version: " DRIVER_VERSION "\n");
+
+	return pci_scan_buses(&pci_root_buses);
+}
+
+
+static void __exit
+dummyphp_exit(void)
+{
+	cleanup_slots();
+}
+
+module_init(dummyphp_init);
+module_exit(dummyphp_exit);
diff -purN linux-2.5/drivers/pci/hotplug/pcihp_skeleton.c usb-2.5/drivers/pci/hotplug/pcihp_skeleton.c
--- linux-2.5/drivers/pci/hotplug/pcihp_skeleton.c	2003-08-27 14:44:50.000000000 +0000
+++ usb-2.5/drivers/pci/hotplug/pcihp_skeleton.c	2003-10-04 13:47:39.000000000 +0000
@@ -370,10 +370,10 @@ static int init_slots (void)
 		 * Initilize the slot info structure with some known
 		 * good values.
 		 */
-		info->power_status = get_skel_power_status(slot);
-		info->attention_status = get_skel_attention_status(slot);
-		info->latch_status = get_skel_latch_status(slot);
-		info->adapter_status = get_skel_adapter_status(slot);
+		info->power_status = get_power_status(slot);
+		info->attention_status = get_attention_status(slot);
+		info->latch_status = get_latch_status(slot);
+		info->adapter_status = get_adapter_status(slot);
 		
 		dbg ("registering slot %d\n", i);
 		retval = pci_hp_register (slot->hotplug_slot);
diff -purN linux-2.5/drivers/pci/probe.c usb-2.5/drivers/pci/probe.c
--- linux-2.5/drivers/pci/probe.c	2003-08-06 15:34:30.000000000 +0000
+++ usb-2.5/drivers/pci/probe.c	2003-10-15 14:17:37.000000000 +0000
@@ -25,6 +25,39 @@ EXPORT_SYMBOL(pci_root_buses);
 LIST_HEAD(pci_devices);
 
 /*
+ * PCI Bus Class
+ */
+static void release_pcibus_dev(struct class_device *class_dev)
+{
+	struct pci_bus *pci_bus = to_pci_bus(class_dev);
+	if (pci_bus->bridge)
+		put_device(pci_bus->bridge);
+	kfree(pci_bus);
+}
+
+static struct class pcibus_class = {
+	.name		= "pci_bus",
+	.release	= &release_pcibus_dev,
+};
+
+static int __init pcibus_class_init(void)
+{
+	return class_register(&pcibus_class);
+}
+postcore_initcall(pcibus_class_init);
+
+/*
+ * PCI Bus Class Devices
+ */
+static ssize_t pci_bus_show_cpuaffinity(struct class_device *class_dev, char *buf)
+{
+	struct pci_bus *pcibus = to_pci_bus(class_dev);
+
+	return sprintf(buf, "%lx\n", (unsigned long)pcibus_to_cpumask(pcibus->number));
+}
+static CLASS_DEVICE_ATTR(cpuaffinity, S_IRUGO, pci_bus_show_cpuaffinity, NULL);
+
+/*
  * Translate the low bits of the PCI base
  * to the resource type
  */
@@ -238,37 +271,40 @@ static struct pci_bus * __devinit
 pci_alloc_child_bus(struct pci_bus *parent, struct pci_dev *bridge, int busnr)
 {
 	struct pci_bus *child;
+	int i;
 
 	/*
 	 * Allocate a new bus, and inherit stuff from the parent..
 	 */
 	child = pci_alloc_bus();
+	if (!child)
+		return NULL;
 
-	if (child) {
-		int i;
-
-		child->self = bridge;
-		child->parent = parent;
-		child->ops = parent->ops;
-		child->sysdata = parent->sysdata;
-		child->dev = &bridge->dev;
+	child->self = bridge;
+	child->parent = parent;
+	child->ops = parent->ops;
+	child->sysdata = parent->sysdata;
+	child->bridge = get_device(&bridge->dev);
+
+	child->class_dev.class = &pcibus_class;
+	sprintf(child->class_dev.class_id, "%04x:%02x", pci_domain_nr(child), busnr);
+	class_device_register(&child->class_dev);
+	class_device_create_file(&child->class_dev, &class_device_attr_cpuaffinity);
 
-		/*
-		 * Set up the primary, secondary and subordinate
-		 * bus numbers.
-		 */
-		child->number = child->secondary = busnr;
-		child->primary = parent->secondary;
-		child->subordinate = 0xff;
-
-		/* Set up default resource pointers and names.. */
-		for (i = 0; i < 4; i++) {
-			child->resource[i] = &bridge->resource[PCI_BRIDGE_RESOURCES+i];
-			child->resource[i]->name = child->name;
-		}
-
-		bridge->subordinate = child;
+	/*
+	 * Set up the primary, secondary and subordinate
+	 * bus numbers.
+	 */
+	child->number = child->secondary = busnr;
+	child->primary = parent->secondary;
+	child->subordinate = 0xff;
+
+	/* Set up default resource pointers and names.. */
+	for (i = 0; i < 4; i++) {
+		child->resource[i] = &bridge->resource[PCI_BRIDGE_RESOURCES+i];
+		child->resource[i]->name = child->name;
 	}
+	bridge->subordinate = child;
 
 	return child;
 }
@@ -307,18 +343,17 @@ int __devinit pci_scan_bridge(struct pci
 	    pci_name(dev), buses & 0xffffff, pass);
 
 	if ((buses & 0xffff00) && !pcibios_assign_all_busses() && !is_cardbus) {
-		unsigned int cmax;
+		unsigned int cmax, busnr;
 		/*
 		 * Bus already configured by firmware, process it in the first
 		 * pass and just note the configuration.
 		 */
 		if (pass)
 			return max;
-		child = pci_alloc_child_bus(bus, dev, 0);
+		busnr = (buses >> 8) & 0xFF;
+		child = pci_alloc_child_bus(bus, dev, busnr);
 		child->primary = buses & 0xFF;
-		child->secondary = (buses >> 8) & 0xFF;
 		child->subordinate = (buses >> 16) & 0xFF;
-		child->number = child->secondary;
 		cmax = pci_scan_child_bus(child);
 		if (cmax > max) max = cmax;
 	} else {
@@ -508,7 +543,7 @@ pci_scan_device(struct pci_bus *bus, int
 	memset(dev, 0, sizeof(struct pci_dev));
 	dev->bus = bus;
 	dev->sysdata = bus->sysdata;
-	dev->dev.parent = bus->dev;
+	dev->dev.parent = bus->bridge;
 	dev->dev.bus = &pci_bus_type;
 	dev->devfn = devfn;
 	dev->hdr_type = hdr_type & 0x7f;
@@ -634,13 +669,14 @@ unsigned int __devinit pci_do_scan_bus(s
 struct pci_bus * __devinit pci_scan_bus_parented(struct device *parent, int bus, struct pci_ops *ops, void *sysdata)
 {
 	struct pci_bus *b;
+	struct device *dev;
 
 	b = pci_alloc_bus();
 	if (!b)
 		return NULL;
 
-	b->dev = kmalloc(sizeof(*(b->dev)),GFP_KERNEL);
-	if (!b->dev){
+	dev = kmalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev){
 		kfree(b);
 		return NULL;
 	}
@@ -651,17 +687,24 @@ struct pci_bus * __devinit pci_scan_bus_
 	if (pci_find_bus(pci_domain_nr(b), bus)) {
 		/* If we already got to this bus through a different bridge, ignore it */
 		DBG("PCI: Bus %02x already known\n", bus);
-		kfree(b->dev);
+		kfree(dev);
 		kfree(b);
 		return NULL;
 	}
-
 	list_add_tail(&b->node, &pci_root_buses);
 
-	memset(b->dev,0,sizeof(*(b->dev)));
-	b->dev->parent = parent;
-	sprintf(b->dev->bus_id,"pci%04x:%02x", pci_domain_nr(b), bus);
-	device_register(b->dev);
+	memset(dev, 0, sizeof(*dev));
+	dev->parent = parent;
+	sprintf(dev->bus_id, "pci%04x:%02x", pci_domain_nr(b), bus);
+	device_register(dev);
+	b->bridge = get_device(dev);
+
+	b->class_dev.class = &pcibus_class;
+	sprintf(b->class_dev.class_id, "%04x:%02x", pci_domain_nr(b), bus);
+	class_device_register(&b->class_dev);
+	class_device_create_file(&b->class_dev, &class_device_attr_cpuaffinity);
+
+	sysfs_create_link(&b->class_dev.kobj, &b->bridge->kobj, "bridge");
 
 	b->number = b->secondary = bus;
 	b->resource[0] = &ioport_resource;
diff -purN linux-2.5/drivers/pci/search.c usb-2.5/drivers/pci/search.c
--- linux-2.5/drivers/pci/search.c	2003-07-03 15:09:17.000000000 +0000
+++ usb-2.5/drivers/pci/search.c	2003-10-15 18:18:28.000000000 +0000
@@ -104,6 +104,41 @@ pci_find_slot(unsigned int bus, unsigned
 }
 
 /**
+ * pci_get_slot - locate PCI device for a given PCI slot
+ * @bus: PCI bus on which desired PCI device resides
+ * @devfn: encodes number of PCI slot in which the desired PCI 
+ * device resides and the logical device number within that slot 
+ * in case of multi-function devices.
+ *
+ * Given a PCI bus and slot/function number, the desired PCI device 
+ * is located in the list of PCI devices.
+ * If the device is found, its reference count is increased and this
+ * function returns a pointer to its data structure.  The caller must
+ * decrement the reference count by calling pci_dev_put().
+ * If no device is found, %NULL is returned.
+ */
+struct pci_dev * pci_get_slot(struct pci_bus *bus, unsigned int devfn)
+{
+	struct list_head *tmp;
+	struct pci_dev *dev;
+
+	WARN_ON(in_interrupt());
+	spin_lock(&pci_bus_lock);
+
+	list_for_each(tmp, &bus->children) {
+		dev = pci_dev_b(tmp);
+		if (dev->devfn == devfn)
+			goto out;
+	}
+
+	dev = NULL;
+ out:
+	pci_dev_get(dev);
+	spin_unlock(&pci_bus_lock);
+	return dev;
+}
+
+/**
  * pci_find_subsys - begin or continue searching for a PCI device by vendor/subvendor/device/subdevice id
  * @vendor: PCI vendor id to match, or %PCI_ANY_ID to match all vendor ids
  * @device: PCI device id to match, or %PCI_ANY_ID to match all device ids
@@ -319,3 +354,4 @@ EXPORT_SYMBOL(pci_find_slot);
 EXPORT_SYMBOL(pci_find_subsys);
 EXPORT_SYMBOL(pci_get_device);
 EXPORT_SYMBOL(pci_get_subsys);
+EXPORT_SYMBOL(pci_get_slot);
diff -purN linux-2.5/drivers/usb/Makefile usb-2.5/drivers/usb/Makefile
--- linux-2.5/drivers/usb/Makefile	2003-09-24 22:41:05.000000000 +0000
+++ usb-2.5/drivers/usb/Makefile	2003-10-08 17:40:10.000000000 +0000
@@ -34,6 +34,7 @@ obj-$(CONFIG_USB_PWC)		+= media/
 obj-$(CONFIG_USB_SE401)		+= media/
 obj-$(CONFIG_USB_STV680)	+= media/
 obj-$(CONFIG_USB_VICAM)		+= media/
+obj-$(CONFIG_USB_W9968CF)	+= media/
 
 obj-$(CONFIG_USB_CATC)		+= net/
 obj-$(CONFIG_USB_KAWETH)	+= net/
@@ -58,4 +59,4 @@ obj-$(CONFIG_USB_SPEEDTOUCH)	+= misc/
 obj-$(CONFIG_USB_TEST)		+= misc/
 obj-$(CONFIG_USB_TIGL)		+= misc/
 obj-$(CONFIG_USB_USS720)	+= misc/
-
+obj-$(CONFIG_USB_LEGOTOWER)	+= misc/
diff -purN linux-2.5/drivers/usb/class/audio.h usb-2.5/drivers/usb/class/audio.h
--- linux-2.5/drivers/usb/class/audio.h	2002-04-04 22:33:04.000000000 +0000
+++ usb-2.5/drivers/usb/class/audio.h	2003-10-06 08:49:06.000000000 +0000
@@ -1,9 +1,3 @@
-#define USB_DT_CS_DEVICE                0x21
-#define USB_DT_CS_CONFIG                0x22
-#define USB_DT_CS_STRING                0x23
-#define USB_DT_CS_INTERFACE             0x24
-#define USB_DT_CS_ENDPOINT              0x25
-
 #define CS_AUDIO_UNDEFINED		0x20
 #define CS_AUDIO_DEVICE			0x21
 #define CS_AUDIO_CONFIGURATION		0x22
diff -purN linux-2.5/drivers/usb/class/cdc-acm.c usb-2.5/drivers/usb/class/cdc-acm.c
--- linux-2.5/drivers/usb/class/cdc-acm.c	2003-10-19 07:37:15.000000000 +0000
+++ usb-2.5/drivers/usb/class/cdc-acm.c	2003-10-31 10:21:54.000000000 +0000
@@ -1,5 +1,5 @@
 /*
- * acm.c  Version 0.22
+ * cdc-acm.c
  *
  * Copyright (c) 1999 Armin Fuerst	<fuerst@in.tum.de>
  * Copyright (c) 1999 Pavel Machek	<pavel@suse.cz>
@@ -26,6 +26,7 @@
  *	v0.21 - revert to probing on device for devices with multiple configs
  *	v0.22 - probe only the control interface. if usbcore doesn't choose the
  *		config we want, sysadmin changes bConfigurationValue in sysfs.
+ *	v0.23 - use softirq for rx processing, as needed by tty layer
  */
 
 /*
@@ -44,6 +45,8 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  */
 
+#undef DEBUG
+
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/init.h>
@@ -54,14 +57,13 @@
 #include <linux/module.h>
 #include <linux/smp_lock.h>
 #include <asm/uaccess.h>
-#undef DEBUG
 #include <linux/usb.h>
 #include <asm/byteorder.h>
 
 /*
  * Version Information
  */
-#define DRIVER_VERSION "v0.21"
+#define DRIVER_VERSION "v0.23"
 #define DRIVER_AUTHOR "Armin Fuerst, Pavel Machek, Johannes Erdfelt, Vojtech Pavlik"
 #define DRIVER_DESC "USB Abstract Control Model driver for USB modems and ISDN adapters"
 
@@ -146,7 +148,8 @@ struct acm {
 	struct tty_struct *tty;				/* the corresponding tty */
 	struct urb *ctrlurb, *readurb, *writeurb;	/* urbs */
 	struct acm_line line;				/* line coding (bits, stop, parity) */
-	struct work_struct work;					/* work queue entry for line discipline waking up */
+	struct work_struct work;			/* work queue entry for line discipline waking up */
+	struct tasklet_struct bh;			/* rx processing */
 	unsigned int ctrlin;				/* input control lines (DCD, DSR, RI, break, overruns) */
 	unsigned int ctrlout;				/* output control lines (DTR, RTS) */
 	unsigned int writesize;				/* max packet size for the output bulk endpoint */
@@ -184,9 +187,10 @@ static int acm_ctrl_msg(struct acm *acm,
 #define acm_send_break(acm, ms)		acm_ctrl_msg(acm, ACM_REQ_SEND_BREAK, ms, NULL, 0)
 
 /*
- * Interrupt handler for various ACM control events
+ * Interrupt handlers for various ACM device responses
  */
 
+/* control interface reports status changes with "interrupt" transfers */
 static void acm_ctrl_irq(struct urb *urb, struct pt_regs *regs)
 {
 	struct acm *acm = urb->context;
@@ -251,20 +255,30 @@ exit:
 		     __FUNCTION__, status);
 }
 
+/* data interface returns incoming bytes, or we got unthrottled */
 static void acm_read_bulk(struct urb *urb, struct pt_regs *regs)
 {
 	struct acm *acm = urb->context;
-	struct tty_struct *tty = acm->tty;
-	unsigned char *data = urb->transfer_buffer;
-	int i = 0;
 
 	if (!ACM_READY(acm))
 		return;
 
 	if (urb->status)
-		dbg("nonzero read bulk status received: %d", urb->status);
+		dev_dbg(&acm->data->dev, "bulk rx status %d\n", urb->status);
+
+	/* calling tty_flip_buffer_push() in_irq() isn't allowed */
+	tasklet_schedule(&acm->bh);
+}
+
+static void acm_rx_tasklet(unsigned long _acm)
+{
+	struct acm *acm = (void *)_acm;
+	struct urb *urb = acm->readurb;
+	struct tty_struct *tty = acm->tty;
+	unsigned char *data = urb->transfer_buffer;
+	int i = 0;
 
-	if (!urb->status && !acm->throttle)  {
+	if (urb->actual_length > 0 && !acm->throttle)  {
 		for (i = 0; i < urb->actual_length && !acm->throttle; i++) {
 			/* if we insert more than TTY_FLIPBUF_SIZE characters,
 			 * we drop them. */
@@ -285,10 +299,12 @@ static void acm_read_bulk(struct urb *ur
 	urb->actual_length = 0;
 	urb->dev = acm->dev;
 
-	if (usb_submit_urb(urb, GFP_ATOMIC))
-		dbg("failed resubmitting read urb");
+	i = usb_submit_urb(urb, GFP_ATOMIC);
+	if (i)
+		dev_dbg(&acm->data->dev, "bulk rx resubmit %d\n", i);
 }
 
+/* data interface wrote those outgoing bytes */
 static void acm_write_bulk(struct urb *urb, struct pt_regs *regs)
 {
 	struct acm *acm = (struct acm *)urb->context;
@@ -621,6 +637,8 @@ static int acm_probe (struct usb_interfa
 			acm->minor = minor;
 			acm->dev = dev;
 
+			acm->bh.func = acm_rx_tasklet;
+			acm->bh.data = (unsigned long) acm;
 			INIT_WORK(&acm->work, acm_softint, acm);
 
 			if (!(buf = kmalloc(ctrlsize + readsize + acm->writesize, GFP_KERNEL))) {
diff -purN linux-2.5/drivers/usb/class/usb-midi.h usb-2.5/drivers/usb/class/usb-midi.h
--- linux-2.5/drivers/usb/class/usb-midi.h	2003-03-05 11:07:27.000000000 +0000
+++ usb-2.5/drivers/usb/class/usb-midi.h	2003-10-06 08:49:06.000000000 +0000
@@ -28,12 +28,6 @@
 #define USB_SUBCLASS_MIDISTREAMING	3
 #endif
 
-#define USB_DT_CS_DEVICE		0x21
-#define USB_DT_CS_CONFIG		0x22
-#define USB_DT_CS_STRING		0x23
-#define USB_DT_CS_INTERFACE		0x24
-#define USB_DT_CS_ENDPOINT		0x25
-
 /* ------------------------------------------------------------------------- */
 /* Roland MIDI Devices */
 
diff -purN linux-2.5/drivers/usb/class/usblp.c usb-2.5/drivers/usb/class/usblp.c
--- linux-2.5/drivers/usb/class/usblp.c	2003-09-16 20:48:02.000000000 +0000
+++ usb-2.5/drivers/usb/class/usblp.c	2003-12-09 17:50:25.000000000 +0000
@@ -610,7 +610,7 @@ static ssize_t usblp_write(struct file *
 		if (!usblp->wcomplete) {
 			barrier();
 			if (file->f_flags & O_NONBLOCK)
-				return -EAGAIN;
+				return writecount ? writecount : -EAGAIN;
 
 			timeout = USBLP_WRITE_TIMEOUT;
 			add_wait_queue(&usblp->wait, &wait);
@@ -673,8 +673,12 @@ static ssize_t usblp_write(struct file *
 
 		usblp->writeurb->dev = usblp->dev;
 		usblp->wcomplete = 0;
-		if (usb_submit_urb(usblp->writeurb, GFP_KERNEL)) {
-			count = -EIO;
+		err = usb_submit_urb(usblp->writeurb, GFP_KERNEL);
+		if (err) {
+			if (err != -ENOMEM)
+				count = -EIO;
+			else
+				count = writecount ? writecount : -ENOMEM;
 			up (&usblp->sem);
 			break;
 		}
@@ -706,8 +710,6 @@ static ssize_t usblp_read(struct file *f
 			goto done;
 		}
 
-		// FIXME:  only use urb->status inside completion
-		// callbacks; this way is racey...
 		add_wait_queue(&usblp->wait, &wait);
 		while (1==1) {
 			if (signal_pending(current)) {
@@ -1093,7 +1095,7 @@ static int usblp_cache_device_id_string(
 	/* First two bytes are length in big-endian.
 	 * They count themselves, and we copy them into
 	 * the user's buffer. */
-	length = (usblp->device_id_string[0] << 8) + usblp->device_id_string[1];
+	length = be16_to_cpu(*((u16 *)usblp->device_id_string));
 	if (length < 2)
 		length = 2;
 	else if (length >= USBLP_DEVICE_ID_SIZE)
diff -purN linux-2.5/drivers/usb/core/hcd.c usb-2.5/drivers/usb/core/hcd.c
--- linux-2.5/drivers/usb/core/hcd.c	2003-08-29 18:16:13.000000000 +0000
+++ usb-2.5/drivers/usb/core/hcd.c	2003-12-07 12:29:05.000000000 +0000
@@ -1165,6 +1165,7 @@ static int hcd_unlink_urb (struct urb *u
 	struct device			*sys = 0;
 	unsigned long			flags;
 	struct completion_splice	splice;
+	struct list_head		*tmp;
 	int				retval;
 
 	if (!urb)
@@ -1203,7 +1204,12 @@ static int hcd_unlink_urb (struct urb *u
 	 */
 	WARN_ON (!HCD_IS_RUNNING (hcd->state) && hcd->state != USB_STATE_HALT);
 
-	if (!urb->hcpriv) {
+	/* insist the urb is still queued */
+	list_for_each(tmp, &dev->urb_list) {
+		if (tmp == &urb->urb_list)
+			break;
+	}
+	if (tmp != &urb->urb_list) {
 		retval = -EINVAL;
 		goto done;
 	}
diff -purN linux-2.5/drivers/usb/core/hub.c usb-2.5/drivers/usb/core/hub.c
--- linux-2.5/drivers/usb/core/hub.c	2003-11-30 07:44:40.000000000 +0000
+++ usb-2.5/drivers/usb/core/hub.c	2003-12-16 18:01:23.000000000 +0000
@@ -126,14 +126,20 @@ static int get_port_status(struct usb_de
 static void hub_irq(struct urb *urb, struct pt_regs *regs)
 {
 	struct usb_hub *hub = (struct usb_hub *)urb->context;
-	unsigned long flags;
 	int status;
 
+	spin_lock(&hub_event_lock);
+	hub->urb_active = 0;
+	if (hub->urb_complete) {	/* disconnect or rmmod */
+		complete(hub->urb_complete);
+		goto done;
+	}
+
 	switch (urb->status) {
 	case -ENOENT:		/* synchronous unlink */
 	case -ECONNRESET:	/* async unlink */
 	case -ESHUTDOWN:	/* hardware going away */
-		return;
+		goto done;
 
 	default:		/* presumably an error */
 		/* Cause a hub reset after 10 consecutive errors */
@@ -151,18 +157,20 @@ static void hub_irq(struct urb *urb, str
 	hub->nerrors = 0;
 
 	/* Something happened, let khubd figure it out */
-	spin_lock_irqsave(&hub_event_lock, flags);
 	if (list_empty(&hub->event_list)) {
 		list_add(&hub->event_list, &hub_event_list);
 		wake_up(&khubd_wait);
 	}
-	spin_unlock_irqrestore(&hub_event_lock, flags);
 
 resubmit:
 	if ((status = usb_submit_urb (hub->urb, GFP_ATOMIC)) != 0
 			/* ENODEV means we raced disconnect() */
 			&& status != -ENODEV)
 		dev_err (&hub->intf->dev, "resubmit --> %d\n", urb->status);
+	if (status == 0)
+		hub->urb_active = 1;
+done:
+	spin_unlock(&hub_event_lock);
 }
 
 /* USB 2.0 spec Section 11.24.2.3 */
@@ -467,7 +475,8 @@ static int hub_configure(struct usb_hub 
 		message = "couldn't submit status urb";
 		goto fail;
 	}
-		
+	hub->urb_active = 1;
+
 	/* Wake up khubd */
 	wake_up(&khubd_wait);
 
@@ -485,6 +494,7 @@ fail:
 static void hub_disconnect(struct usb_interface *intf)
 {
 	struct usb_hub *hub = usb_get_intfdata (intf);
+	DECLARE_COMPLETION(urb_complete);
 	unsigned long flags;
 
 	if (!hub)
@@ -492,12 +502,11 @@ static void hub_disconnect(struct usb_in
 
 	usb_set_intfdata (intf, NULL);
 	spin_lock_irqsave(&hub_event_lock, flags);
+	hub->urb_complete = &urb_complete;
 
 	/* Delete it and then reset it */
-	list_del(&hub->event_list);
-	INIT_LIST_HEAD(&hub->event_list);
-	list_del(&hub->hub_list);
-	INIT_LIST_HEAD(&hub->hub_list);
+	list_del_init(&hub->event_list);
+	list_del_init(&hub->hub_list);
 
 	spin_unlock_irqrestore(&hub_event_lock, flags);
 
@@ -510,6 +519,8 @@ static void hub_disconnect(struct usb_in
 
 	if (hub->urb) {
 		usb_unlink_urb(hub->urb);
+		if (hub->urb_active)
+			wait_for_completion(&urb_complete);
 		usb_free_urb(hub->urb);
 		hub->urb = NULL;
 	}
diff -purN linux-2.5/drivers/usb/core/hub.h usb-2.5/drivers/usb/core/hub.h
--- linux-2.5/drivers/usb/core/hub.h	2003-06-09 12:15:48.000000000 +0000
+++ usb-2.5/drivers/usb/core/hub.h	2003-12-08 17:01:59.000000000 +0000
@@ -172,6 +172,8 @@ extern void usb_hub_tt_clear_buffer (str
 struct usb_hub {
 	struct usb_interface	*intf;		/* the "real" device */
 	struct urb		*urb;		/* for interrupt polling pipe */
+	struct completion	*urb_complete;	/* wait for urb to end */
+	unsigned int		urb_active:1;
 
 	/* buffer for urb ... 1 bit each for hub and children, rounded up */
 	char			(*buffer)[(USB_MAXCHILDREN + 1 + 7) / 8];
diff -purN linux-2.5/drivers/usb/core/message.c usb-2.5/drivers/usb/core/message.c
--- linux-2.5/drivers/usb/core/message.c	2003-10-22 15:49:15.000000000 +0000
+++ usb-2.5/drivers/usb/core/message.c	2003-10-26 22:51:28.000000000 +0000
@@ -1086,6 +1086,11 @@ int usb_set_configuration(struct usb_dev
 		ret = -EINVAL;
 		goto out;
 	}
+
+	/* The USB spec says configuration 0 means unconfigured.
+	 * But if a device includes a configuration numbered 0,
+	 * we will accept it as a correctly configured state.
+	 */
 	if (cp && configuration == 0)
 		dev_warn(&dev->dev, "config 0 descriptor??\n");
 
@@ -1101,7 +1106,7 @@ int usb_set_configuration(struct usb_dev
 		goto out;
 
 	dev->actconfig = cp;
-	if (!configuration)
+	if (!cp)
 		dev->state = USB_STATE_ADDRESS;
 	else {
 		dev->state = USB_STATE_CONFIGURED;
diff -purN linux-2.5/drivers/usb/core/usb.c usb-2.5/drivers/usb/core/usb.c
--- linux-2.5/drivers/usb/core/usb.c	2003-11-14 08:18:31.000000000 +0000
+++ usb-2.5/drivers/usb/core/usb.c	2003-12-16 18:16:50.000000000 +0000
@@ -80,7 +80,7 @@ static struct device_driver usb_generic_
 
 static int usb_generic_driver_data;
 
-/* needs to be called with BKL held */
+/* called from driver core with usb_bus_type.subsys writelock */
 int usb_probe_interface(struct device *dev)
 {
 	struct usb_interface * intf = to_usb_interface(dev);
@@ -93,12 +93,14 @@ int usb_probe_interface(struct device *d
 	if (!driver->probe)
 		return error;
 
+	/* driver claim() doesn't yet affect dev->driver... */
+	if (intf->driver)
+		return error;
+
 	id = usb_match_id (intf, driver->id_table);
 	if (id) {
 		dev_dbg (dev, "%s - got id\n", __FUNCTION__);
-		down (&driver->serialize);
 		error = driver->probe (intf, id);
-		up (&driver->serialize);
 	}
 	if (!error)
 		intf->driver = driver;
@@ -106,23 +108,24 @@ int usb_probe_interface(struct device *d
 	return error;
 }
 
+/* called from driver core with usb_bus_type.subsys writelock */
 int usb_unbind_interface(struct device *dev)
 {
 	struct usb_interface *intf = to_usb_interface(dev);
-	struct usb_driver *driver = to_usb_driver(dev->driver);
-
-	down(&driver->serialize);
+	struct usb_driver *driver = intf->driver;
 
 	/* release all urbs for this interface */
 	usb_disable_interface(interface_to_usbdev(intf), intf);
 
-	if (intf->driver && intf->driver->disconnect)
-		intf->driver->disconnect(intf);
-
-	/* force a release and re-initialize the interface */
-	usb_driver_release_interface(driver, intf);
+	if (driver && driver->disconnect)
+		driver->disconnect(intf);
 
-	up(&driver->serialize);
+	/* reset other interface state */
+	usb_set_interface(interface_to_usbdev(intf),
+			intf->altsetting[0].desc.bInterfaceNumber,
+			0);
+	usb_set_intfdata(intf, NULL);
+	intf->driver = NULL;
 
 	return 0;
 }
@@ -152,8 +155,6 @@ int usb_register(struct usb_driver *new_
 	new_driver->driver.probe = usb_probe_interface;
 	new_driver->driver.remove = usb_unbind_interface;
 
-	init_MUTEX(&new_driver->serialize);
-
 	retval = driver_register(&new_driver->driver);
 
 	if (!retval) {
@@ -170,7 +171,7 @@ int usb_register(struct usb_driver *new_
 /**
  * usb_deregister - unregister a USB driver
  * @driver: USB operations of the driver to unregister
- * Context: !in_interrupt (), must be called with BKL held
+ * Context: must be able to sleep
  *
  * Unlinks the specified driver from the internal USB driver list.
  * 
@@ -264,26 +265,22 @@ usb_epnum_to_ep_desc(struct usb_device *
  * Few drivers should need to use this routine, since the most natural
  * way to bind to an interface is to return the private data from
  * the driver's probe() method.
+ *
+ * Callers must own the driver model's usb bus writelock.  So driver
+ * probe() entries don't need extra locking, but other call contexts
+ * may need to explicitly claim that lock.
  */
 int usb_driver_claim_interface(struct usb_driver *driver, struct usb_interface *iface, void* priv)
 {
 	if (!iface || !driver)
 		return -EINVAL;
 
-	/* this is mainly to lock against usbfs */
-	lock_kernel();
-	if (iface->driver) {
-		unlock_kernel();
-		err ("%s driver booted %s off interface %p",
-			driver->name, iface->driver->name, iface);
+	if (iface->driver)
 		return -EBUSY;
-	} else {
-	    dbg("%s driver claimed interface %p", driver->name, iface);
-	}
 
+	/* FIXME should device_bind_driver() */
 	iface->driver = driver;
 	usb_set_intfdata(iface, priv);
-	unlock_kernel();
 	return 0;
 }
 
@@ -323,13 +320,22 @@ int usb_interface_claimed(struct usb_int
  * usually won't need to call this.
  *
  * This call is synchronous, and may not be used in an interrupt context.
+ * Callers must own the driver model's usb bus writelock.  So driver
+ * disconnect() entries don't need extra locking, but other call contexts
+ * may need to explicitly claim that lock.
  */
 void usb_driver_release_interface(struct usb_driver *driver, struct usb_interface *iface)
 {
 	/* this should never happen, don't release something that's not ours */
-	if (iface->driver && iface->driver != driver)
+	if (!iface || !iface->driver || iface->driver != driver)
 		return;
 
+	if (iface->dev.driver) {
+		/* FIXME should be the ONLY case here */
+		device_release_driver(&iface->dev);
+		return;
+	}
+
 	usb_set_interface(interface_to_usbdev(iface),
 			iface->altsetting[0].desc.bInterfaceNumber,
 			0);
@@ -991,6 +997,7 @@ int usb_new_device(struct usb_device *de
 	int err = -EINVAL;
 	int i;
 	int j;
+	int config;
 
 	/*
 	 * Set the driver for the usb device to point to the "generic" driver.
@@ -1108,18 +1115,30 @@ int usb_new_device(struct usb_device *de
 
 	/* choose and set the configuration. that registers the interfaces
 	 * with the driver core, and lets usb device drivers bind to them.
+	 * NOTE:  should interact with hub power budgeting.
 	 */
+	config = dev->config[0].desc.bConfigurationValue;
 	if (dev->descriptor.bNumConfigurations != 1) {
+		for (i = 0; i < dev->descriptor.bNumConfigurations; i++) {
+			/* heuristic:  Linux is more likely to have class
+			 * drivers, so avoid vendor-specific interfaces.
+			 */
+			if (dev->config[i].interface[0]->altsetting
+						->desc.bInterfaceClass
+					== USB_CLASS_VENDOR_SPEC)
+				continue;
+			config = dev->config[i].desc.bConfigurationValue;
+			break;
+		}
 		dev_info(&dev->dev,
 			"configuration #%d chosen from %d choices\n",
-			dev->config[0].desc.bConfigurationValue,
+			config,
 			dev->descriptor.bNumConfigurations);
 	}
-	err = usb_set_configuration(dev,
-			dev->config[0].desc.bConfigurationValue);
+	err = usb_set_configuration(dev, config);
 	if (err) {
 		dev_err(&dev->dev, "can't set config #%d, error %d\n",
-			dev->config[0].desc.bConfigurationValue, err);
+			config, err);
 		device_del(&dev->dev);
 		goto fail;
 	}
diff -purN linux-2.5/drivers/usb/gadget/Kconfig usb-2.5/drivers/usb/gadget/Kconfig
--- linux-2.5/drivers/usb/gadget/Kconfig	2003-10-08 04:12:15.000000000 +0000
+++ usb-2.5/drivers/usb/gadget/Kconfig	2003-10-17 16:35:51.000000000 +0000
@@ -177,6 +177,27 @@ config USB_GADGETFS_PXA2XX
 	depends on USB_GADGETFS && USB_PXA2XX
 	default y
 
+config USB_G_SERIAL
+	tristate "serial Gadget"
+	depends on USB_GADGET && (USB_DUMMY_HCD || USB_NET2280 || USB_PXA2XX || USB_SA1100)
+
+config USB_G_SERIAL_NET2280
+	bool
+	# for now, treat the "dummy" hcd as if it were a net2280
+	depends on USB_G_SERIAL && (USB_NET2280 || USB_DUMMY_HCD)
+	default y
+
+config USB_G_SERIAL_PXA2XX
+	bool
+	depends on USB_G_SERIAL && USB_PXA2XX
+	default y
+
+config USB_G_SERIAL_SA1100
+	bool
+	depends on USB_G_SERIAL && USB_SA1100
+	default y
+
+
 endchoice
 
 # endmenuconfig
diff -purN linux-2.5/drivers/usb/gadget/Makefile usb-2.5/drivers/usb/gadget/Makefile
--- linux-2.5/drivers/usb/gadget/Makefile	2003-09-03 10:38:36.000000000 +0000
+++ usb-2.5/drivers/usb/gadget/Makefile	2003-10-08 00:31:16.000000000 +0000
@@ -8,9 +8,10 @@ obj-$(CONFIG_USB_NET2280)	+= net2280.o
 #
 g_zero-objs			:= zero.o usbstring.o
 g_ether-objs			:= ether.o usbstring.o
+g_serial-objs			:= serial.o usbstring.o
 gadgetfs-objs			:= inode.o usbstring.o
  
 obj-$(CONFIG_USB_ZERO)		+= g_zero.o
 obj-$(CONFIG_USB_ETH)		+= g_ether.o
 obj-$(CONFIG_USB_GADGETFS)	+= gadgetfs.o
-
+obj-$(CONFIG_USB_G_SERIAL)	+= g_serial.o
diff -purN linux-2.5/drivers/usb/gadget/serial.c usb-2.5/drivers/usb/gadget/serial.c
--- linux-2.5/drivers/usb/gadget/serial.c	1970-01-01 00:00:00.000000000 +0000
+++ usb-2.5/drivers/usb/gadget/serial.c	2003-10-09 01:36:45.000000000 +0000
@@ -0,0 +1,2329 @@
+/*
+ * g_serial.c -- USB gadget serial driver
+ *
+ * $Id: gserial.c,v 1.17 2003/10/01 06:31:57 borchers Exp $
+ *
+ * Copyright 2003 (c) Al Borchers (alborchers@steinerpoint.com)
+ *
+ * This code is based in part on the Gadget Zero driver, which
+ * is Copyright (C) 2003 by David Brownell, all rights reserved.
+ *
+ * This code also borrows from usbserial.c, which is
+ * Copyright (C) 1999 - 2002 Greg Kroah-Hartman (greg@kroah.com)
+ * Copyright (c) 2000 Peter Berger (pberger@brimson.com)
+ * Copyright (c) 2000 Al Borchers (alborchers@steinerpoint.com)
+ *
+ * This software is distributed under the terms of the GNU General
+ * Public License ("GPL") as published by the Free Software Foundation,
+ * either version 2 of that License or (at your option) any later version.
+ *
+ */
+
+/* Includes */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/uts.h>
+#include <linux/version.h>
+#include <linux/wait.h>
+#include <linux/list.h>
+#include <linux/proc_fs.h>
+#include <linux/device.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+
+#include <asm/byteorder.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/unaligned.h>
+#include <asm/uaccess.h>
+
+#include <linux/usb_ch9.h>
+#include <linux/usb_gadget.h>
+
+
+/* Wait Cond */
+
+#define __wait_cond_interruptible(wq, condition, lock, flags, ret)	\
+do {									\
+	wait_queue_t __wait;						\
+	init_waitqueue_entry(&__wait, current);				\
+									\
+	add_wait_queue(&wq, &__wait);					\
+	for (;;) {							\
+		set_current_state(TASK_INTERRUPTIBLE);			\
+		if (condition)						\
+			break;						\
+		if (!signal_pending(current)) {				\
+			spin_unlock_irqrestore(lock, flags);		\
+			schedule();					\
+			spin_lock_irqsave(lock, flags);			\
+			continue;					\
+		}							\
+		ret = -ERESTARTSYS;					\
+		break;							\
+	}								\
+	current->state = TASK_RUNNING;					\
+	remove_wait_queue(&wq, &__wait);				\
+} while (0)
+	
+#define wait_cond_interruptible(wq, condition, lock, flags)		\
+({									\
+	int __ret = 0;							\
+	if (!(condition))						\
+		__wait_cond_interruptible(wq, condition, lock, flags,	\
+						__ret);			\
+	__ret;								\
+})
+
+#define __wait_cond_interruptible_timeout(wq, condition, lock, flags, 	\
+						timeout, ret)		\
+do {									\
+	signed long __timeout = timeout;				\
+	wait_queue_t __wait;						\
+	init_waitqueue_entry(&__wait, current);				\
+									\
+	add_wait_queue(&wq, &__wait);					\
+	for (;;) {							\
+		set_current_state(TASK_INTERRUPTIBLE);			\
+		if (__timeout == 0)					\
+			break;						\
+		if (condition)						\
+			break;						\
+		if (!signal_pending(current)) {				\
+			spin_unlock_irqrestore(lock, flags);		\
+			__timeout = schedule_timeout(__timeout);	\
+			spin_lock_irqsave(lock, flags);			\
+			continue;					\
+		}							\
+		ret = -ERESTARTSYS;					\
+		break;							\
+	}								\
+	current->state = TASK_RUNNING;					\
+	remove_wait_queue(&wq, &__wait);				\
+} while (0)
+	
+#define wait_cond_interruptible_timeout(wq, condition, lock, flags,	\
+						timeout)		\
+({									\
+	int __ret = 0;							\
+	if (!(condition))						\
+		__wait_cond_interruptible_timeout(wq, condition, lock,	\
+						flags, timeout, __ret);	\
+	__ret;								\
+})
+
+
+/* Defines */
+
+#define GS_VERSION_STR			"v0.1"
+#define GS_VERSION_NUM			0x0001
+
+#define GS_LONG_NAME			"Gadget Serial"
+#define GS_SHORT_NAME			"g_serial"
+
+#define GS_MAJOR			127
+#define GS_MINOR_START			0
+
+#define GS_NUM_PORTS			16
+
+#define GS_VENDOR_ID			0x05F9
+#define GS_PRODUCT_ID			0xFFFF
+
+#define GS_NUM_CONFIGS			1
+#define GS_NO_CONFIG_ID			0
+#define GS_BULK_CONFIG_ID		2
+
+#define GS_NUM_INTERFACES		1
+#define GS_INTERFACE_ID			0
+#define GS_ALT_INTERFACE_ID		0
+
+#define GS_NUM_ENDPOINTS		2
+
+#define GS_MAX_DESC_LEN			256
+
+#define GS_DEFAULT_READ_Q_SIZE		32
+#define GS_DEFAULT_WRITE_Q_SIZE		32
+
+#define GS_DEFAULT_WRITE_BUF_SIZE	8192
+#define GS_TMP_BUF_SIZE			8192
+
+#define GS_CLOSE_TIMEOUT		15
+
+/* debug macro */
+#if G_SERIAL_DEBUG
+
+static int debug = G_SERIAL_DEBUG;
+
+#define gs_debug(format, arg...) \
+	do { if(debug) printk( KERN_DEBUG format, ## arg ); } while(0)
+#define gs_debug_level(level, format, arg...) \
+	do { if(debug>=level) printk( KERN_DEBUG format, ## arg ); } while(0)
+
+#else
+
+#define gs_debug(format, arg...) \
+	do { } while(0)
+#define gs_debug_level(level, format, arg...) \
+	do { } while(0)
+
+#endif /* G_SERIAL_DEBUG */
+
+
+/* USB Controllers */
+
+/*
+ * NetChip 2280, PCI based.
+ *
+ * This has half a dozen configurable endpoints, four with dedicated
+ * DMA channels to manage their FIFOs.  It supports high speed.
+ * Those endpoints can be arranged in any desired configuration.
+ */
+#ifdef	CONFIG_USB_G_SERIAL_NET2280
+#define CHIP				"net2280"
+#define EP0_MAXPACKET			64
+static const char EP_OUT_NAME[] =	"ep-a";
+#define EP_OUT_NUM			2
+static const char EP_IN_NAME[] =	"ep-b";
+#define EP_IN_NUM			2
+#define HIGHSPEED
+#define SELFPOWER			USB_CONFIG_ATT_SELFPOWER
+
+extern int net2280_set_fifo_mode( struct usb_gadget *gadget, int mode );
+
+static inline void hw_optimize( struct usb_gadget *gadget )
+{
+	/* we can have bigger ep-a/ep-b fifos (2KB each, 4 packets
+	 * for highspeed bulk) because we're not using ep-c/ep-d.
+	 */
+	net2280_set_fifo_mode (gadget, 1);
+}
+#endif
+
+
+/*
+ * PXA-2xx UDC:  widely used in second gen Linux-capable PDAs.
+ *
+ * This has fifteen fixed-function full speed endpoints, and it
+ * can support all USB transfer types.
+ *
+ * These supports three or four configurations, with fixed numbers.
+ * The hardware interprets SET_INTERFACE, net effect is that you
+ * can't use altsettings or reset the interfaces independently.
+ * So stick to a single interface.
+ */
+#ifdef	CONFIG_USB_G_SERIAL_PXA2XX
+#define CHIP				"pxa2xx"
+#define EP0_MAXPACKET			16
+static const char EP_OUT_NAME[] =	"ep12out-bulk";
+#define EP_OUT_NUM			12
+static const char EP_IN_NAME[] =	"ep11in-bulk";
+#define EP_IN_NUM			11
+#define SELFPOWER 			USB_CONFIG_ATT_SELFPOWER
+
+/* no hw optimizations to apply */
+#define hw_optimize(g)			do {} while (0)
+#endif
+
+
+/*
+ * SA-1100 UDC:  widely used in first gen Linux-capable PDAs.
+ *
+ * This has only two fixed function endpoints, which can only
+ * be used for bulk (or interrupt) transfers.  (Plus control.)
+ *
+ * Since it can't flush its TX fifos without disabling the UDC,
+ * the current configuration or altsettings can't change except
+ * in special situations.  So this is a case of "choose it right
+ * during enumeration" ...
+ */
+#ifdef	CONFIG_USB_G_SERIAL_SA1100
+#define CHIP				"sa1100"
+#define EP0_MAXPACKET			8
+static const char EP_OUT_NAME[] =	"ep1out-bulk";
+#define EP_OUT_NUM			1
+static const char EP_IN_NAME [] =	"ep2in-bulk";
+#define EP_IN_NUM			2
+#define SELFPOWER			USB_CONFIG_ATT_SELFPOWER
+
+/* no hw optimizations to apply */
+#define hw_optimize(g)			do {} while (0)
+#endif
+
+
+/*
+ * Toshiba TC86C001 ("Goku-S") UDC
+ *
+ * This has three semi-configurable full speed bulk/interrupt endpoints.
+ */
+#ifdef	CONFIG_USB_G_SERIAL_GOKU
+#define CHIP				"goku"
+#define DRIVER_VERSION_NUM		0x0116
+#define EP0_MAXPACKET			8
+static const char EP_OUT_NAME [] =	"ep1-bulk";
+#define EP_OUT_NUM			1
+static const char EP_IN_NAME [] =	"ep2-bulk";
+#define EP_IN_NUM			2
+#define SELFPOWER			USB_CONFIG_ATT_SELFPOWER
+
+/* no hw optimizations to apply */
+#define hw_optimize(g)			do {} while (0)
+#endif
+
+/*
+ * USB Controller Defaults
+ */
+#ifndef EP0_MAXPACKET
+#error Configure some USB peripheral controller for g_serial!
+#endif
+
+#ifndef SELFPOWER
+/* default: say we rely on bus power */
+#define SELFPOWER   			0
+/* else value must be USB_CONFIG_ATT_SELFPOWER */
+#endif
+
+#ifndef	MAX_USB_POWER
+/* any hub supports this steady state bus power consumption */
+#define MAX_USB_POWER			100	/* mA */
+#endif
+
+#ifndef	WAKEUP
+/* default: this driver won't do remote wakeup */
+#define WAKEUP				0
+/* else value must be USB_CONFIG_ATT_WAKEUP */
+#endif
+
+
+/* Structures */
+
+struct gs_dev;
+
+/* circular buffer */
+struct gs_buf {
+	unsigned int		buf_size;
+	char			*buf_buf;
+	char			*buf_get;
+	char			*buf_put;
+};
+
+/* list of requests */
+struct gs_req_entry {
+	struct list_head	re_entry;
+	struct usb_request	*re_req;
+};
+
+/* the port structure holds info for each port, one for each minor number */
+struct gs_port {
+	struct gs_dev 		*port_dev;	/* pointer to device struct */
+	struct tty_struct	*port_tty;	/* pointer to tty struct */
+	spinlock_t		port_lock;
+	int 			port_num;
+	int			port_open_count;
+	int			port_in_use;	/* open/close in progress */
+	wait_queue_head_t	port_write_wait;/* waiting to write */
+	struct gs_buf		*port_write_buf;
+};
+
+/* the device structure holds info for the USB device */
+struct gs_dev {
+	struct usb_gadget	*dev_gadget;	/* gadget device pointer */
+	spinlock_t		dev_lock;	/* lock for set/reset config */
+	int			dev_config;	/* configuration number */
+	struct usb_ep		*dev_in_ep;	/* address of in endpoint */
+	struct usb_ep		*dev_out_ep;	/* address of out endpoint */
+	struct usb_request	*dev_ctrl_req;	/* control request */
+	struct list_head	dev_req_list;	/* list of write requests */
+	int			dev_sched_port;	/* round robin port scheduled */
+	struct gs_port		*dev_port[GS_NUM_PORTS]; /* the ports */
+};
+
+
+/* Functions */
+
+/* module */
+static int __init gs_module_init( void );
+static void __exit gs_module_exit( void );
+
+/* tty driver */
+static int gs_open( struct tty_struct *tty, struct file *file );
+static void gs_close( struct tty_struct *tty, struct file *file );
+static int gs_write( struct tty_struct *tty, int from_user,
+	const unsigned char *buf, int count );
+static void gs_put_char( struct tty_struct *tty, unsigned char ch );
+static void gs_flush_chars( struct tty_struct *tty );
+static int gs_write_room( struct tty_struct *tty );
+static int gs_chars_in_buffer( struct tty_struct *tty );
+static void gs_throttle( struct tty_struct * tty );
+static void gs_unthrottle( struct tty_struct * tty );
+static void gs_break( struct tty_struct *tty, int break_state );
+static int  gs_ioctl( struct tty_struct *tty, struct file *file,
+	unsigned int cmd, unsigned long arg );
+static void gs_set_termios( struct tty_struct *tty, struct termios *old );
+static int gs_read_proc( char *page, char **start, off_t off, int count,
+	int *eof, void *data );
+
+static int gs_send( struct gs_dev *dev );
+static int gs_send_packet( struct gs_dev *dev, char *packet,
+	unsigned int size );
+static int gs_recv_packet( struct gs_dev *dev, char *packet,
+	unsigned int size );
+static void gs_read_complete( struct usb_ep *ep, struct usb_request *req );
+static void gs_write_complete( struct usb_ep *ep, struct usb_request *req );
+
+/* gadget driver */
+static int gs_bind( struct usb_gadget *gadget );
+static void gs_unbind( struct usb_gadget *gadget );
+static int gs_setup( struct usb_gadget *gadget,
+	const struct usb_ctrlrequest *ctrl );
+static void gs_setup_complete( struct usb_ep *ep, struct usb_request *req );
+static void gs_disconnect( struct usb_gadget *gadget );
+static int gs_set_config( struct gs_dev *dev, unsigned config );
+static void gs_reset_config( struct gs_dev *dev );
+static int gs_build_config_desc( u8 *buf, enum usb_device_speed speed,
+		u8 type, unsigned int index );
+
+static struct usb_request *gs_alloc_req( struct usb_ep *ep, unsigned int len,
+	int kmalloc_flags );
+static void gs_free_req( struct usb_ep *ep, struct usb_request *req );
+
+static struct gs_req_entry *gs_alloc_req_entry( struct usb_ep *ep, unsigned len,
+	int kmalloc_flags );
+static void gs_free_req_entry( struct usb_ep *ep, struct gs_req_entry *req );
+
+static int gs_alloc_ports( struct gs_dev *dev, int kmalloc_flags );
+static void gs_free_ports( struct gs_dev *dev );
+
+/* circular buffer */
+static struct gs_buf *gs_buf_alloc( unsigned int size, int kmalloc_flags );
+static void gs_buf_free( struct gs_buf *gb );
+static void gs_buf_clear( struct gs_buf *gb );
+static unsigned int gs_buf_data_avail( struct gs_buf *gb );
+static unsigned int gs_buf_space_avail( struct gs_buf *gb );
+static unsigned int gs_buf_put( struct gs_buf *gb, const char *buf,
+	unsigned int count );
+static unsigned int gs_buf_get( struct gs_buf *gb, char *buf,
+	unsigned int count );
+
+
+/* Globals */
+
+static struct gs_dev *gs_device;
+
+static struct semaphore	gs_open_close_sem[GS_NUM_PORTS];
+
+static unsigned int read_q_size = GS_DEFAULT_READ_Q_SIZE;
+static unsigned int write_q_size = GS_DEFAULT_WRITE_Q_SIZE;
+
+static unsigned int write_buf_size = GS_DEFAULT_WRITE_BUF_SIZE;
+
+static unsigned char gs_tmp_buf[GS_TMP_BUF_SIZE];
+static struct semaphore	gs_tmp_buf_sem;
+
+/* tty driver struct */
+static struct tty_operations gs_tty_ops = {
+	.open =			gs_open,
+	.close =		gs_close,
+	.write =		gs_write,
+	.put_char =		gs_put_char,
+	.flush_chars =		gs_flush_chars,
+	.write_room =		gs_write_room,
+	.ioctl =		gs_ioctl,
+	.set_termios =		gs_set_termios,
+	.throttle =		gs_throttle,
+	.unthrottle =		gs_unthrottle,
+	.break_ctl =		gs_break,
+	.chars_in_buffer =	gs_chars_in_buffer,
+	.read_proc =		gs_read_proc,
+};
+static struct tty_driver *gs_tty_driver;
+
+/* gadget driver struct */
+static struct usb_gadget_driver gs_gadget_driver = {
+#ifdef HIGHSPEED
+	.speed =		USB_SPEED_HIGH,
+#else
+	.speed =		USB_SPEED_FULL,
+#endif
+	.function =		GS_LONG_NAME,
+	.bind =			gs_bind,
+	.unbind =		gs_unbind,
+	.setup =		gs_setup,
+	.disconnect =		gs_disconnect,
+	.driver = {
+		.name =		GS_SHORT_NAME,
+		/* .shutdown = ... */
+		/* .suspend = ...  */
+		/* .resume = ...   */
+	},
+};
+
+
+/* USB descriptors */
+
+#define GS_MANUFACTURER_STR_ID	1
+#define GS_PRODUCT_STR_ID	2
+#define GS_SERIAL_STR_ID	3
+#define GS_CONFIG_STR_ID	4
+
+/* static strings, in iso 8859/1 */
+static struct usb_string gs_strings[] = {
+	{ GS_MANUFACTURER_STR_ID, UTS_SYSNAME " " UTS_RELEASE " with " CHIP },
+	{ GS_PRODUCT_STR_ID, GS_LONG_NAME },
+	{ GS_SERIAL_STR_ID, "0" },
+	{ GS_CONFIG_STR_ID, "Bulk" },
+	{  } /* end of list */
+};
+
+static struct usb_gadget_strings gs_string_table = {
+	.language =		0x0409,	/* en-us */
+	.strings =		gs_strings,
+};
+
+static const struct usb_device_descriptor gs_device_desc = {
+	.bLength =		USB_DT_DEVICE_SIZE,
+	.bDescriptorType =	USB_DT_DEVICE,
+	.bcdUSB =		__constant_cpu_to_le16(0x0200),
+	.bDeviceClass =		USB_CLASS_VENDOR_SPEC,
+	.bMaxPacketSize0 =	EP0_MAXPACKET,
+	.idVendor =		__constant_cpu_to_le16(GS_VENDOR_ID),
+	.idProduct =		__constant_cpu_to_le16(GS_PRODUCT_ID),
+	.bcdDevice =		__constant_cpu_to_le16(GS_VERSION_NUM),
+	.iManufacturer =	GS_MANUFACTURER_STR_ID,
+	.iProduct =		GS_PRODUCT_STR_ID,
+	.iSerialNumber =	GS_SERIAL_STR_ID,
+	.bNumConfigurations =	GS_NUM_CONFIGS,
+};
+
+static const struct usb_config_descriptor gs_config_desc = {
+	.bLength =		USB_DT_CONFIG_SIZE,
+	.bDescriptorType =	USB_DT_CONFIG,
+	/* .wTotalLength set by gs_build_config_desc */
+	.bNumInterfaces =	GS_NUM_INTERFACES,
+	.bConfigurationValue =	GS_BULK_CONFIG_ID,
+	.iConfiguration =	GS_CONFIG_STR_ID,
+	.bmAttributes =		USB_CONFIG_ATT_ONE | SELFPOWER | WAKEUP,
+	.bMaxPower =		(MAX_USB_POWER + 1) / 2,
+};
+
+static const struct usb_interface_descriptor gs_interface_desc = {
+	.bLength =		USB_DT_INTERFACE_SIZE,
+	.bDescriptorType =	USB_DT_INTERFACE,
+	.bNumEndpoints =	GS_NUM_ENDPOINTS,
+	.bInterfaceClass =	USB_CLASS_VENDOR_SPEC,
+	.iInterface =		GS_CONFIG_STR_ID,
+};
+
+static const struct usb_endpoint_descriptor gs_fullspeed_in_desc = {
+	.bLength =		USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+	.bEndpointAddress =	EP_IN_NUM | USB_DIR_IN,
+	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize =	__constant_cpu_to_le16(64),
+};
+
+static const struct usb_endpoint_descriptor gs_fullspeed_out_desc = {
+	.bLength =		USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+	.bEndpointAddress =	EP_OUT_NUM | USB_DIR_OUT,
+	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize =	__constant_cpu_to_le16(64),
+};
+
+static const struct usb_endpoint_descriptor gs_highspeed_in_desc = {
+	.bLength =		USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+	.bEndpointAddress =	EP_IN_NUM | USB_DIR_IN,
+	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize =	__constant_cpu_to_le16(512),
+};
+
+static const struct usb_endpoint_descriptor gs_highspeed_out_desc = {
+	.bLength =		USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+	.bEndpointAddress =	EP_OUT_NUM | USB_DIR_OUT,
+	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize =	__constant_cpu_to_le16(512),
+};
+
+#ifdef HIGHSPEED
+static const struct usb_qualifier_descriptor gs_qualifier_desc = {
+	.bLength =		sizeof(struct usb_qualifier_descriptor),
+	.bDescriptorType =	USB_DT_DEVICE_QUALIFIER,
+	.bcdUSB =		__constant_cpu_to_le16 (0x0200),
+	.bDeviceClass =		USB_CLASS_VENDOR_SPEC,
+	/* assumes ep0 uses the same value for both speeds ... */
+	.bMaxPacketSize0 =	EP0_MAXPACKET,
+	.bNumConfigurations =	GS_NUM_CONFIGS,
+};
+#endif
+
+
+/* Module */
+
+MODULE_DESCRIPTION( GS_LONG_NAME );
+MODULE_AUTHOR( "Al Borchers" );
+MODULE_LICENSE( "GPL" );
+
+MODULE_PARM( debug, "i" );
+MODULE_PARM_DESC( debug, "Enable debugging, 0=off, 1=on" );
+
+MODULE_PARM( read_q_size, "i" );
+MODULE_PARM_DESC( read_q_size, "Read request queue size, default=32" );
+
+MODULE_PARM( write_q_size, "i" );
+MODULE_PARM_DESC( write_q_size, "Write request queue size, default=32" );
+
+MODULE_PARM( write_buf_size, "i" );
+MODULE_PARM_DESC( write_buf_size, "Write buffer size, default=8192" );
+
+module_init( gs_module_init );
+module_exit( gs_module_exit );
+
+/*
+*  gs_module_init
+*
+*  Register as a USB gadget driver and a tty driver.
+*/
+
+static int __init gs_module_init(void)
+{
+	int i;
+	int retval;
+
+	retval = usb_gadget_register_driver(&gs_gadget_driver);
+	if (retval) {
+		printk(KERN_ERR "gs_module_init: cannot register gadget driver, ret=%d\n", retval);
+		return retval;
+	}
+
+	gs_tty_driver = alloc_tty_driver(GS_NUM_PORTS);
+	if (!gs_tty_driver)
+		return -ENOMEM;
+	gs_tty_driver->owner = THIS_MODULE;
+	gs_tty_driver->driver_name = GS_SHORT_NAME;
+	gs_tty_driver->name = "ttygs";
+	gs_tty_driver->devfs_name = "usb/ttygs/";
+	gs_tty_driver->major = GS_MAJOR;
+	gs_tty_driver->minor_start = GS_MINOR_START;
+	gs_tty_driver->type = TTY_DRIVER_TYPE_SERIAL;
+	gs_tty_driver->subtype = SERIAL_TYPE_NORMAL;
+	gs_tty_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_NO_DEVFS;
+	gs_tty_driver->init_termios = tty_std_termios;
+	gs_tty_driver->init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;
+	tty_set_operations(gs_tty_driver, &gs_tty_ops);
+
+	for (i=0; i < GS_NUM_PORTS; i++)
+		sema_init(&gs_open_close_sem[i], 1);
+
+	sema_init(&gs_tmp_buf_sem, 1);
+
+	retval = tty_register_driver(gs_tty_driver);
+	if (retval) {
+		usb_gadget_unregister_driver(&gs_gadget_driver);
+		put_tty_driver(gs_tty_driver);
+		printk(KERN_ERR "gs_module_init: cannot register tty driver, ret=%d\n", retval);
+		return retval;
+	}
+
+	printk(KERN_INFO "gs_module_init: %s %s loaded\n", GS_LONG_NAME, GS_VERSION_STR);
+	return 0;
+}
+
+
+/*
+* gs_module_exit
+*
+* Unregister as a tty driver and a USB gadget driver.
+*/
+
+static void __exit gs_module_exit(void)
+{
+	tty_unregister_driver(gs_tty_driver);
+	put_tty_driver(gs_tty_driver);
+	usb_gadget_unregister_driver(&gs_gadget_driver);
+
+	printk(KERN_INFO "gs_module_exit: %s %s unloaded\n", GS_LONG_NAME, GS_VERSION_STR);
+}
+
+
+/* TTY Driver */
+
+/*
+ * gs_open
+ */
+
+static int gs_open( struct tty_struct *tty, struct file *file )
+{
+
+	int port_num;
+	unsigned long flags;
+	struct gs_port *port;
+	struct gs_dev *dev;
+	struct gs_buf *buf;
+	struct semaphore *sem;
+
+
+	port_num = tty->index;
+
+	gs_debug( "gs_open: (%d,%p,%p)\n", port_num, tty, file );
+
+	tty->driver_data = NULL;
+
+	if( port_num < 0 || port_num >= GS_NUM_PORTS ) {
+		printk( KERN_ERR "gs_open: (%d,%p,%p) invalid port number\n",
+			port_num, tty, file );
+		return( -ENODEV );
+	}
+
+	dev = gs_device;
+
+	if( dev == NULL ) {
+		printk( KERN_ERR "gs_open: (%d,%p,%p) NULL device pointer\n",
+			port_num, tty, file );
+		return( -ENODEV );
+	}
+
+	sem = &gs_open_close_sem[port_num];
+	if( down_interruptible( sem ) ) {
+		printk( KERN_ERR
+		"gs_open: (%d,%p,%p) interrupted waiting for semaphore\n",
+			port_num, tty, file );
+		return( -ERESTARTSYS );
+	}
+
+	spin_lock_irqsave(&dev->dev_lock, flags );
+
+	if( dev->dev_config == GS_NO_CONFIG_ID ) {
+		printk( KERN_ERR
+			"gs_open: (%d,%p,%p) device is not connected\n",
+			port_num, tty, file );
+		spin_unlock_irqrestore( &dev->dev_lock, flags );
+		up( sem );
+		return( -ENODEV );
+	}
+
+	port = dev->dev_port[port_num];
+
+	if( port == NULL ) {
+		printk( KERN_ERR "gs_open: (%d,%p,%p) NULL port pointer\n",
+			port_num, tty, file );
+		spin_unlock_irqrestore( &dev->dev_lock, flags );
+		up( sem );
+		return( -ENODEV );
+	}
+
+	spin_lock( &port->port_lock );
+	spin_unlock( &dev->dev_lock );
+
+	if( port->port_dev == NULL ) {
+		printk( KERN_ERR "gs_open: (%d,%p,%p) port disconnected (1)\n",
+			port_num, tty, file );
+		spin_unlock_irqrestore( &port->port_lock, flags );
+		up( sem );
+		return( -EIO );
+	}
+
+	if( port->port_open_count > 0 ) {
+		++port->port_open_count;
+		spin_unlock_irqrestore( &port->port_lock, flags );
+		gs_debug( "gs_open: (%d,%p,%p) already open\n",
+			port_num, tty, file );
+		up( sem );
+		return( 0 );
+	}
+
+	/* mark port as in use, we can drop port lock and sleep if necessary */
+	port->port_in_use = 1;
+
+	/* allocate write buffer on first open */
+	if( port->port_write_buf == NULL ) {
+
+		spin_unlock_irqrestore( &port->port_lock, flags );
+		buf = gs_buf_alloc( write_buf_size, GFP_KERNEL );
+		spin_lock_irqsave( &port->port_lock, flags );
+
+		/* might have been disconnected while asleep, check */
+		if( port->port_dev == NULL ) {
+			printk( KERN_ERR
+				"gs_open: (%d,%p,%p) port disconnected (2)\n",
+				port_num, tty, file );
+			port->port_in_use = 0;
+			spin_unlock_irqrestore( &port->port_lock, flags );
+			up( sem );
+			return( -EIO );
+		}
+
+		if( (port->port_write_buf=buf) == NULL ) {
+			printk( KERN_ERR "gs_open: (%d,%p,%p) cannot allocate port write buffer\n",
+				port_num, tty, file );
+			port->port_in_use = 0;
+			spin_unlock_irqrestore( &port->port_lock, flags );
+			up( sem );
+			return( -ENOMEM );
+		}
+
+	}
+
+	/* wait for carrier detect (not implemented) */
+
+	/* might have been disconnected while asleep, check */
+	if( port->port_dev == NULL ) {
+		printk( KERN_ERR "gs_open: (%d,%p,%p) port disconnected (3)\n",
+			port_num, tty, file );
+		port->port_in_use = 0;
+		spin_unlock_irqrestore( &port->port_lock, flags );
+		up( sem );
+		return( -EIO );
+	}
+
+	tty->driver_data = port;
+	port->port_tty = tty;
+	port->port_open_count = 1;
+	port->port_in_use = 0;
+
+	spin_unlock_irqrestore( &port->port_lock, flags );
+	up( sem );
+
+	gs_debug( "gs_open: (%d,%p,%p) completed\n", port_num, tty, file );
+
+	return( 0 ); 
+
+}
+
+
+/*
+ * gs_close
+ */
+
+static void gs_close( struct tty_struct *tty, struct file *file )
+{
+
+	unsigned long flags;
+	struct gs_port *port = tty->driver_data;
+	struct semaphore *sem;
+
+
+	if( port == NULL ) {
+		printk( KERN_ERR "gs_close: NULL port pointer\n" );
+		return;
+	}
+
+	gs_debug( "gs_close: (%d,%p,%p)\n", port->port_num, tty, file );
+
+	sem = &gs_open_close_sem[port->port_num];
+	down( sem );
+
+	spin_lock_irqsave( &port->port_lock, flags );
+
+	if( port->port_open_count == 0 ) {
+		printk( KERN_ERR
+			"gs_close: (%d,%p,%p) port is already closed\n",
+			port->port_num, tty, file );
+		spin_unlock_irqrestore( &port->port_lock, flags );
+		up( sem );
+		return;
+	}
+
+	if( port->port_open_count > 0 ) {
+		--port->port_open_count;
+		spin_unlock_irqrestore( &port->port_lock, flags );
+		up( sem );
+		return;
+	}
+
+	/* free disconnected port on final close */
+	if( port->port_dev == NULL ) {
+		kfree( port );
+		spin_unlock_irqrestore( &port->port_lock, flags );
+		up( sem );
+		return;
+	}
+
+	/* mark port as closed but in use, we can drop port lock */
+	/* and sleep if necessary */
+	port->port_in_use = 1;
+	port->port_open_count = 0;
+
+	/* wait for write buffer to drain, or */
+	/* at most GS_CLOSE_TIMEOUT seconds */
+	if( gs_buf_data_avail( port->port_write_buf ) > 0 ) {
+		wait_cond_interruptible_timeout( port->port_write_wait,
+		port->port_dev == NULL
+		|| gs_buf_data_avail(port->port_write_buf) == 0,
+		&port->port_lock, flags, GS_CLOSE_TIMEOUT * HZ );
+	}
+
+	/* free disconnected port on final close */
+	/* (might have happened during the above sleep) */
+	if( port->port_dev == NULL ) {
+		kfree( port );
+		spin_unlock_irqrestore( &port->port_lock, flags );
+		up( sem );
+		return;
+	}
+
+	gs_buf_clear( port->port_write_buf );
+
+	tty->driver_data = NULL;
+	port->port_tty = NULL;
+	port->port_in_use = 0;
+
+	spin_unlock_irqrestore( &port->port_lock, flags );
+	up( sem );
+
+	gs_debug( "gs_close: (%d,%p,%p) completed\n",
+		port->port_num, tty, file );
+
+}
+
+
+/*
+ * gs_write
+ */
+
+static int gs_write( struct tty_struct *tty, int from_user,
+	const unsigned char *buf, int count )
+{
+
+	unsigned long flags;
+	struct gs_port *port = tty->driver_data;
+
+
+	if( port == NULL ) {
+		printk( KERN_ERR "gs_write: NULL port pointer\n" );
+		return( -EIO );
+	}
+
+	gs_debug( "gs_write: (%d,%p) writing %d bytes\n", port->port_num, tty,
+		count );
+
+	if( count == 0 )
+		return( 0 );
+
+	/* copy from user into tmp buffer, get tmp_buf semaphore */
+	if( from_user ) {
+		if( count > GS_TMP_BUF_SIZE )
+			count = GS_TMP_BUF_SIZE;
+		down( &gs_tmp_buf_sem );
+		if( copy_from_user( gs_tmp_buf, buf, count ) != 0 ) {
+			up( &gs_tmp_buf_sem );
+			printk( KERN_ERR
+			"gs_write: (%d,%p) cannot copy from user space\n",
+				port->port_num, tty );
+			return( -EFAULT );
+		}
+		buf = gs_tmp_buf;
+	}
+
+	spin_lock_irqsave( &port->port_lock, flags );
+
+	if( port->port_dev == NULL ) {
+		printk( KERN_ERR "gs_write: (%d,%p) port is not connected\n",
+			port->port_num, tty );
+		spin_unlock_irqrestore( &port->port_lock, flags );
+		if( from_user )
+			up( &gs_tmp_buf_sem );
+		return( -EIO );
+	}
+
+	if( port->port_open_count == 0 ) {
+		printk( KERN_ERR "gs_write: (%d,%p) port is closed\n",
+			port->port_num, tty );
+		spin_unlock_irqrestore( &port->port_lock, flags );
+		if( from_user )
+			up( &gs_tmp_buf_sem );
+		return( -EBADF );
+	}
+
+	count = gs_buf_put( port->port_write_buf, buf, count );
+
+	spin_unlock_irqrestore( &port->port_lock, flags );
+
+	if( from_user )
+		up( &gs_tmp_buf_sem );
+
+	gs_send( gs_device );
+
+	gs_debug( "gs_write: (%d,%p) wrote %d bytes\n", port->port_num, tty,
+		count );
+
+	return( count );
+
+}
+
+
+/*
+ * gs_put_char
+ */
+
+static void gs_put_char( struct tty_struct *tty, unsigned char ch )
+{
+
+	unsigned long flags;
+	struct gs_port *port = tty->driver_data;
+
+
+	if( port == NULL ) {
+		printk( KERN_ERR "gs_put_char: NULL port pointer\n" );
+		return;
+	}
+
+	gs_debug( "gs_put_char: (%d,%p) char=0x%x, called from %p, %p, %p\n", port->port_num, tty, ch, __builtin_return_address(0), __builtin_return_address(1), __builtin_return_address(2) );
+
+	spin_lock_irqsave( &port->port_lock, flags );
+
+	if( port->port_dev == NULL ) {
+		printk( KERN_ERR "gs_put_char: (%d,%p) port is not connected\n",
+			port->port_num, tty );
+		spin_unlock_irqrestore( &port->port_lock, flags );
+		return;
+	}
+
+	if( port->port_open_count == 0 ) {
+		printk( KERN_ERR "gs_put_char: (%d,%p) port is closed\n",
+			port->port_num, tty );
+		spin_unlock_irqrestore( &port->port_lock, flags );
+		return;
+	}
+
+	gs_buf_put( port->port_write_buf, &ch, 1 );
+
+	spin_unlock_irqrestore( &port->port_lock, flags );
+
+}
+
+
+/*
+ * gs_flush_chars
+ */
+
+static void gs_flush_chars( struct tty_struct *tty )
+{
+
+	unsigned long flags;
+	struct gs_port *port = tty->driver_data;
+
+
+	if( port == NULL ) {
+		printk( KERN_ERR "gs_flush_chars: NULL port pointer\n" );
+		return;
+	}
+
+	gs_debug( "gs_flush_chars: (%d,%p)\n", port->port_num, tty );
+
+	spin_lock_irqsave( &port->port_lock, flags );
+
+	if( port->port_dev == NULL ) {
+		printk( KERN_ERR
+			"gs_flush_chars: (%d,%p) port is not connected\n",
+			port->port_num, tty );
+		spin_unlock_irqrestore( &port->port_lock, flags );
+		return;
+	}
+
+	if( port->port_open_count == 0 ) {
+		printk( KERN_ERR "gs_flush_chars: (%d,%p) port is closed\n",
+			port->port_num, tty );
+		spin_unlock_irqrestore( &port->port_lock, flags );
+		return;
+	}
+
+	spin_unlock_irqrestore( &port->port_lock, flags );
+
+	gs_send( gs_device );
+
+}
+
+
+/*
+ * gs_write_room
+ */
+
+static int gs_write_room( struct tty_struct *tty )
+{
+
+	int room = 0;
+	unsigned long flags;
+	struct gs_port *port = tty->driver_data;
+
+
+	if( port == NULL )
+		return( 0 );
+
+	spin_lock_irqsave( &port->port_lock, flags );
+
+	if( port->port_dev != NULL && port->port_open_count > 0
+	&& port->port_write_buf != NULL )
+		room = gs_buf_space_avail( port->port_write_buf );
+
+	spin_unlock_irqrestore( &port->port_lock, flags );
+
+	gs_debug( "gs_write_room: (%d,%p) room=%d\n",
+		port->port_num, tty, room );
+
+	return( room );
+
+}
+
+
+/*
+ * gs_chars_in_buffer
+ */
+
+static int gs_chars_in_buffer( struct tty_struct *tty )
+{
+
+	int chars = 0;
+	unsigned long flags;
+	struct gs_port *port = tty->driver_data;
+
+
+	if( port == NULL )
+		return( 0 );
+
+	spin_lock_irqsave( &port->port_lock, flags );
+
+	if( port->port_dev != NULL && port->port_open_count > 0
+	&& port->port_write_buf != NULL )
+		chars = gs_buf_data_avail( port->port_write_buf );
+
+	spin_unlock_irqrestore( &port->port_lock, flags );
+
+	gs_debug( "gs_chars_in_buffer: (%d,%p) chars=%d\n",
+		port->port_num, tty, chars );
+
+	return( chars );
+
+}
+
+
+/*
+ * gs_throttle
+ */
+
+static void gs_throttle( struct tty_struct *tty )
+{
+
+}
+
+
+/*
+ * gs_unthrottle
+ */
+
+static void gs_unthrottle( struct tty_struct *tty )
+{
+
+}
+
+
+/*
+ * gs_break
+ */
+
+static void gs_break( struct tty_struct *tty, int break_state )
+{
+
+}
+
+
+/*
+ * gs_ioctl
+ */
+
+static int  gs_ioctl( struct tty_struct *tty, struct file *file,
+	unsigned int cmd, unsigned long arg )
+{
+
+	struct gs_port *port = tty->driver_data;
+
+
+	if( port == NULL ) {
+		printk( KERN_ERR "gs_ioctl: NULL port pointer\n" );
+		return( -EIO );
+	}
+
+	gs_debug( "gs_ioctl: (%d,%p,%p) cmd=0x%4.4x, arg=%lu\n",
+		port->port_num, tty, file, cmd, arg );
+
+	/* handle ioctls */
+
+	/* could not handle ioctl */
+	return( -ENOIOCTLCMD );
+
+}
+
+
+/*
+ * gs_set_termios
+ */
+
+static void gs_set_termios( struct tty_struct *tty, struct termios *old )
+{
+
+}
+
+
+/*
+ * gs_read_proc
+ */
+
+static int gs_read_proc( char *page, char **start, off_t off, int count,
+	int *eof, void *data )
+{
+
+	return( 0 );
+
+}
+
+
+/*
+* gs_send
+*
+* This function finds available write requests, calls
+* gs_send_packet to fill these packets with data, and
+* continues until either there are no more write requests
+* available or no more data to send.  This function is
+* run whenever data arrives or write requests are available.
+*/
+
+static int gs_send( struct gs_dev *dev )
+{
+
+	int ret,len;
+	unsigned long flags;
+	struct usb_ep *ep;
+	struct usb_request *req;
+	struct gs_req_entry *req_entry;
+
+
+	if( dev == NULL ) {
+		printk( KERN_ERR "gs_send: NULL device pointer\n" );
+		return( -ENODEV );
+	}
+
+	spin_lock_irqsave( &dev->dev_lock, flags );
+
+	ep = dev->dev_in_ep;
+
+	while( !list_empty( &dev->dev_req_list ) ) {
+
+		req_entry = list_entry( dev->dev_req_list.next,
+			struct gs_req_entry, re_entry );
+
+		req = req_entry->re_req;
+
+		len = gs_send_packet( dev, req->buf, ep->maxpacket );
+
+		if( len > 0 ) {
+gs_debug_level( 3, "gs_send: len=%d, 0x%2.2x 0x%2.2x 0x%2.2x ...\n", len, *((unsigned char *)req->buf), *((unsigned char *)req->buf+1), *((unsigned char *)req->buf+2) );
+			list_del( &req_entry->re_entry );
+			req->length = len;
+			if( (ret=usb_ep_queue( ep, req, GFP_ATOMIC )) ) {
+				printk( KERN_ERR
+				"gs_send: cannot queue read request, ret=%d\n",
+					ret );
+				break;
+			}
+		} else {
+			break;
+		}
+
+	}
+
+	spin_unlock_irqrestore( &dev->dev_lock, flags );
+
+	return( 0 );
+
+}
+
+
+/*
+ * gs_send_packet
+ *
+ * If there is data to send, a packet is built in the given
+ * buffer and the size is returned.  If there is no data to
+ * send, 0 is returned.  If there is any error a negative
+ * error number is returned.
+ *
+ * Called during USB completion routine, on interrupt time.
+ *
+ * We assume that disconnect will not happen until all completion
+ * routines have completed, so we can assume that the dev_port
+ * array does not change during the lifetime of this function.
+ */
+
+static int gs_send_packet( struct gs_dev *dev, char *packet, unsigned int size )
+{
+
+	unsigned int len;
+	struct gs_port *port;
+
+
+	/* TEMPORARY -- only port 0 is supported right now */
+	port = dev->dev_port[0];
+
+	if( port == NULL ) {
+		printk( KERN_ERR
+			"gs_send_packet: port=%d, NULL port pointer\n",
+			0 );
+		return( -EIO );
+	}
+
+	spin_lock( &port->port_lock );
+
+	len = gs_buf_data_avail( port->port_write_buf );
+	if( len < size )
+		size = len;
+
+	if( size == 0 ) {
+		spin_unlock( &port->port_lock );
+		return( 0 );
+	}
+
+	size = gs_buf_get( port->port_write_buf, packet, size );
+
+	wake_up_interruptible( &port->port_tty->write_wait );
+
+	spin_unlock( &port->port_lock );
+
+	return( size );
+
+}
+
+
+/*
+ * gs_recv_packet
+ *
+ * Called for each USB packet received.  Reads the packet
+ * header and stuffs the data in the appropriate tty buffer.
+ * Returns 0 if successful, or a negative error number.
+ *
+ * Called during USB completion routine, on interrupt time.
+ *
+ * We assume that disconnect will not happen until all completion
+ * routines have completed, so we can assume that the dev_port
+ * array does not change during the lifetime of this function.
+ */
+
+static int gs_recv_packet( struct gs_dev *dev, char *packet, unsigned int size )
+{
+
+	unsigned int len;
+	struct gs_port *port;
+
+
+	/* TEMPORARY -- only port 0 is supported right now */
+	port = dev->dev_port[0];
+
+	if( port == NULL ) {
+		printk( KERN_ERR "gs_recv_packet: port=%d, NULL port pointer\n",
+			port->port_num );
+		return( -EIO );
+	}
+
+	spin_lock( &port->port_lock );
+
+	if( port->port_tty == NULL ) {
+		printk( KERN_ERR "gs_recv_packet: port=%d, NULL tty pointer\n",
+			port->port_num );
+		spin_unlock( &port->port_lock );
+		return( -EIO );
+	}
+
+	if( port->port_tty->magic != TTY_MAGIC ) {
+		printk( KERN_ERR "gs_recv_packet: port=%d, bad tty magic\n",
+			port->port_num );
+		spin_unlock( &port->port_lock );
+		return( -EIO );
+	}
+
+	len = (unsigned int)(TTY_FLIPBUF_SIZE - port->port_tty->flip.count);
+	if( len < size )
+		size = len;
+
+	if( size > 0 ) {
+		memcpy( port->port_tty->flip.char_buf_ptr, packet, size );
+		port->port_tty->flip.char_buf_ptr += size;
+		port->port_tty->flip.count += size;
+		tty_flip_buffer_push( port->port_tty );
+		wake_up_interruptible( &port->port_tty->read_wait );
+	}
+
+	spin_unlock( &port->port_lock );
+
+	return( 0 );
+
+}
+
+
+/*
+* gs_read_complete
+*/
+
+static void gs_read_complete( struct usb_ep *ep, struct usb_request *req )
+{
+
+	int ret;
+	struct gs_dev *dev = ep->driver_data;
+
+
+	if( dev == NULL ) {
+		printk( KERN_ERR "gs_read_complete: NULL device pointer\n" );
+		return;
+	}
+
+	switch( req->status ) {
+
+	case 0:
+ 		/* normal completion */
+		gs_recv_packet( dev, req->buf, req->actual );
+requeue:
+		req->length = ep->maxpacket;
+		if( (ret=usb_ep_queue( ep, req, GFP_ATOMIC )) ) {
+			printk( KERN_ERR
+			"gs_read_complete: cannot queue read request, ret=%d\n",
+				ret );
+		}
+		break;
+
+	case -ESHUTDOWN:
+		/* disconnect */
+		gs_debug( "gs_read_complete: shutdown\n" );
+		gs_free_req( ep, req );
+		break;
+
+	default:
+		/* unexpected */
+		printk( KERN_ERR
+		"gs_read_complete: unexpected status error, status=%d\n",
+			req->status );
+		goto requeue;
+		break;
+
+	}
+
+}
+
+
+/*
+* gs_write_complete
+*/
+
+static void gs_write_complete( struct usb_ep *ep, struct usb_request *req )
+{
+
+	struct gs_dev *dev = ep->driver_data;
+	struct gs_req_entry *gs_req = req->context;
+
+
+	if( dev == NULL ) {
+		printk( KERN_ERR "gs_write_complete: NULL device pointer\n" );
+		return;
+	}
+
+	switch( req->status ) {
+
+	case 0:
+		/* normal completion */
+requeue:
+		if( gs_req == NULL ) {
+			printk( KERN_ERR
+				"gs_write_complete: NULL request pointer\n" );
+			return;
+		}
+
+		spin_lock( &dev->dev_lock );
+		list_add( &gs_req->re_entry, &dev->dev_req_list );
+		spin_unlock( &dev->dev_lock );
+
+		gs_send( dev );
+
+		break;
+
+	case -ESHUTDOWN:
+		/* disconnect */
+		gs_debug( "gs_write_complete: shutdown\n" );
+		gs_free_req( ep, req );
+		break;
+
+	default:
+		printk( KERN_ERR
+		"gs_write_complete: unexpected status error, status=%d\n",
+			req->status );
+		goto requeue;
+		break;
+
+	}
+
+}
+
+
+/* Gadget Driver */
+
+/*
+ * gs_bind
+ *
+ * Called on module load.  Allocates and initializes the device
+ * structure and a control request.
+ */
+
+static int gs_bind( struct usb_gadget *gadget )
+{
+
+	int ret;
+	struct gs_dev *dev;
+
+
+	gs_device = dev = kmalloc( sizeof(struct gs_dev), GFP_KERNEL );
+	if( dev == NULL )
+		return( -ENOMEM );
+
+	set_gadget_data( gadget, dev );
+
+	memset( dev, 0, sizeof(struct gs_dev) );
+	dev->dev_gadget = gadget;
+	spin_lock_init( &dev->dev_lock );
+    INIT_LIST_HEAD( &dev->dev_req_list );
+
+	if( (ret=gs_alloc_ports( dev, GFP_KERNEL )) != 0 ) {
+		printk( KERN_ERR "gs_bind: cannot allocate ports\n" );
+		gs_unbind( gadget );
+		return( ret );
+	}
+
+	/* preallocate control response and buffer */
+	dev->dev_ctrl_req = gs_alloc_req( gadget->ep0, GS_MAX_DESC_LEN,
+		GFP_KERNEL );
+	if( dev->dev_ctrl_req == NULL ) {
+		gs_unbind( gadget );
+		return( -ENOMEM );
+	}
+	dev->dev_ctrl_req->complete = gs_setup_complete;
+
+	gadget->ep0->driver_data = dev;
+
+	printk( KERN_INFO "gs_bind: %s %s bound\n",
+		GS_LONG_NAME, GS_VERSION_STR );
+
+	return( 0 );
+
+}
+
+
+/*
+ * gs_unbind
+ *
+ * Called on module unload.  Frees the control request and device
+ * structure.
+ */
+
+static void gs_unbind( struct usb_gadget *gadget )
+{
+
+	struct gs_dev *dev = get_gadget_data( gadget );
+
+
+	gs_device = NULL;
+
+	/* read/write requests already freed, only control request remains */
+	if( dev != NULL ) {
+		if( dev->dev_ctrl_req != NULL )
+			gs_free_req( gadget->ep0, dev->dev_ctrl_req );
+		gs_free_ports( dev );
+		kfree( dev );
+		set_gadget_data( gadget, NULL );
+	}
+
+	printk( KERN_INFO "gs_unbind: %s %s unbound\n", GS_LONG_NAME,
+		GS_VERSION_STR );
+
+}
+
+
+/*
+ * gs_setup
+ *
+ * Implements all the control endpoint functionality that's not
+ * handled in hardware or the hardware driver.
+ *
+ * Returns the size of the data sent to the host, or a negative
+ * error number.
+ */
+
+static int gs_setup( struct usb_gadget *gadget,
+	const struct usb_ctrlrequest *ctrl )
+{
+
+	int ret = -EOPNOTSUPP;
+	unsigned int sv_config;
+	struct gs_dev *dev = get_gadget_data( gadget );
+	struct usb_request *req = dev->dev_ctrl_req;
+
+
+	switch (ctrl->bRequest) {
+
+	case USB_REQ_GET_DESCRIPTOR:
+
+		if( ctrl->bRequestType != USB_DIR_IN )
+			break;
+
+		switch (ctrl->wValue >> 8) {
+
+		case USB_DT_DEVICE:
+			ret = min( ctrl->wLength,
+				(u16)sizeof(struct usb_device_descriptor) );
+			memcpy( req->buf, &gs_device_desc, ret );
+			break;
+
+#ifdef HIGHSPEED
+		case USB_DT_DEVICE_QUALIFIER:
+			ret = min( ctrl->wLength,
+				(u16)sizeof(struct usb_qualifier_descriptor) );
+			memcpy( req->buf, &gs_qualifier_desc, ret );
+			break;
+
+		case USB_DT_OTHER_SPEED_CONFIG:
+#endif /* HIGHSPEED */
+		case USB_DT_CONFIG:
+			ret = gs_build_config_desc( req->buf, gadget->speed,
+				ctrl->wValue >> 8, ctrl->wValue & 0xff );
+			if( ret >= 0 )
+				ret = min( ctrl->wLength, (u16)ret );
+			break;
+
+		case USB_DT_STRING:
+			/* wIndex == language code. */
+			ret = usb_gadget_get_string( &gs_string_table,
+				ctrl->wValue & 0xff, req->buf );
+			if( ret >= 0 )
+				ret = min( ctrl->wLength, (u16)ret );
+			break;
+		}
+		break;
+
+	case USB_REQ_SET_CONFIGURATION:
+		if( ctrl->bRequestType != 0 )
+			break;
+		spin_lock( &dev->dev_lock );
+		ret = gs_set_config( dev, ctrl->wValue );
+		spin_unlock( &dev->dev_lock );
+		break;
+
+	case USB_REQ_GET_CONFIGURATION:
+		if( ctrl->bRequestType != USB_DIR_IN )
+			break;
+		*(u8 *)req->buf = dev->dev_config;
+		ret = min( ctrl->wLength, (u16)1 );
+		break;
+
+	case USB_REQ_SET_INTERFACE:
+		if( ctrl->bRequestType != USB_RECIP_INTERFACE )
+			break;
+		spin_lock( &dev->dev_lock );
+		if( dev->dev_config == GS_BULK_CONFIG_ID
+		&& ctrl->wIndex == GS_INTERFACE_ID
+		&& ctrl->wValue == GS_ALT_INTERFACE_ID ) {
+			sv_config = dev->dev_config;
+			/* since there is only one interface, setting the */
+			/* interface is equivalent to setting the config */
+			gs_reset_config( dev );
+			gs_set_config( dev, sv_config );
+			ret = 0;
+		}
+		spin_unlock( &dev->dev_lock );
+		break;
+
+	case USB_REQ_GET_INTERFACE:
+		if( ctrl->bRequestType != (USB_DIR_IN|USB_RECIP_INTERFACE) )
+			break;
+		if( dev->dev_config == GS_NO_CONFIG_ID )
+			break;
+		if( ctrl->wIndex != GS_INTERFACE_ID ) {
+			ret = -EDOM;
+			break;
+		}
+		*(u8 *)req->buf = GS_ALT_INTERFACE_ID;
+		ret = min( ctrl->wLength, (u16)1 );
+		break;
+
+	default:
+		printk( KERN_ERR "gs_setup: unknown request, type=%02x, request=%02x, value=%04x, index=%04x, length=%d\n",
+			ctrl->bRequestType, ctrl->bRequest, ctrl->wValue,
+			ctrl->wIndex, ctrl->wLength );
+		break;
+
+	}
+
+	/* respond with data transfer before status phase? */
+	if( ret >= 0 ) {
+		req->length = ret;
+		ret = usb_ep_queue( gadget->ep0, req, GFP_ATOMIC );
+		if( ret < 0 ) {
+			printk( KERN_ERR
+				"gs_setup: cannot queue response, ret=%d\n",
+				ret );
+			req->status = 0;
+			gs_setup_complete( gadget->ep0, req );
+		}
+	}
+
+	/* device either stalls (ret < 0) or reports success */
+	return( ret );
+
+}
+
+
+/*
+ * gs_setup_complete
+ */
+
+static void gs_setup_complete( struct usb_ep *ep, struct usb_request *req )
+{
+	if( req->status || req->actual != req->length ) {
+		printk( KERN_ERR "gs_setup_complete: status error, status=%d, actual=%d, length=%d\n",
+			req->status, req->actual, req->length );
+	}
+}
+
+
+/*
+ * gs_disconnect
+ *
+ * Called when the device is disconnected.  Frees the closed
+ * ports and disconnects open ports.  Open ports will be freed
+ * on close.  Then reallocates the ports for the next connection.
+ */
+
+static void gs_disconnect( struct usb_gadget *gadget )
+{
+
+	unsigned long flags;
+	struct gs_dev *dev = get_gadget_data( gadget );
+
+
+	spin_lock_irqsave( &dev->dev_lock, flags );
+
+	gs_reset_config( dev );
+
+	/* free closed ports and disconnect open ports */
+	/* (open ports will be freed when closed) */
+	gs_free_ports( dev );
+
+	/* re-allocate ports for the next connection */
+	if( gs_alloc_ports( dev, GFP_ATOMIC ) != 0 )
+		printk( KERN_ERR "gs_disconnect: cannot re-allocate ports\n" );
+
+	spin_unlock_irqrestore( &dev->dev_lock, flags );
+
+	printk( KERN_INFO "gs_disconnect: %s disconnected\n", GS_LONG_NAME );
+
+}
+
+
+/*
+ * gs_set_config
+ *
+ * Configures the device by enabling device specific
+ * optimizations, setting up the endpoints, allocating
+ * read and write requests and queuing read requests.
+ *
+ * The device lock must be held when calling this function.
+ */
+
+static int gs_set_config( struct gs_dev *dev, unsigned config )
+{
+
+	int i;
+	int ret = 0;
+	struct usb_gadget *gadget = dev->dev_gadget;
+	struct usb_ep *ep;
+	struct usb_request *req;
+	struct gs_req_entry *req_entry;
+
+
+	if( dev == NULL ) {
+		printk( KERN_ERR "gs_set_config: NULL device pointer\n" );
+		return( 0 );
+	}
+
+	if( config == dev->dev_config )
+		return( 0 );
+
+	gs_reset_config( dev );
+
+	if( config == GS_NO_CONFIG_ID )
+		return( 0 );
+
+	if( config != GS_BULK_CONFIG_ID )
+		return( -EINVAL );
+
+	hw_optimize( gadget );
+
+	gadget_for_each_ep( ep, gadget ) {
+
+		if( strcmp( ep->name, EP_IN_NAME ) == 0 ) {
+			ret = usb_ep_enable( ep,
+				gadget->speed == USB_SPEED_HIGH ?
+ 				&gs_highspeed_in_desc : &gs_fullspeed_in_desc );
+			if( ret == 0 ) {
+				ep->driver_data = dev;
+				dev->dev_in_ep = ep;
+			} else {
+				printk( KERN_ERR "gs_set_config: cannot enable in endpoint %s, ret=%d\n",
+					ep->name, ret );
+				gs_reset_config( dev );
+				return( ret );
+			}
+		}
+
+		else if( strcmp( ep->name, EP_OUT_NAME ) == 0 ) {
+			ret = usb_ep_enable( ep,
+				gadget->speed == USB_SPEED_HIGH ?
+				&gs_highspeed_out_desc :
+				&gs_fullspeed_out_desc );
+			if( ret == 0 ) {
+				ep->driver_data = dev;
+				dev->dev_out_ep = ep;
+			} else {
+				printk( KERN_ERR "gs_set_config: cannot enable out endpoint %s, ret=%d\n",
+					ep->name, ret );
+				gs_reset_config( dev );
+				return( ret );
+			}
+		}
+
+	}
+
+	if( dev->dev_in_ep == NULL || dev->dev_out_ep == NULL ) {
+		gs_reset_config( dev );
+		printk( KERN_ERR "gs_set_config: cannot find endpoints\n" );
+		return( -ENODEV );
+	}
+
+	/* allocate and queue read requests */
+	ep = dev->dev_out_ep;
+	for( i=0; i<read_q_size && ret == 0; i++ ) {
+		if( (req=gs_alloc_req( ep, ep->maxpacket, GFP_ATOMIC )) ) {
+			req->complete = gs_read_complete;
+			if( (ret=usb_ep_queue( ep, req, GFP_ATOMIC )) ) {
+				printk( KERN_ERR "gs_set_config: cannot queue read request, ret=%d\n",
+					ret );
+			}
+		} else {
+			gs_reset_config( dev );
+			printk( KERN_ERR
+			"gs_set_config: cannot allocate read requests\n" );
+			return( -ENOMEM );
+		}
+	}
+
+	/* allocate write requests, and put on free list */
+	ep = dev->dev_in_ep;
+	for( i=0; i<write_q_size; i++ ) {
+		if( (req_entry=gs_alloc_req_entry( ep, ep->maxpacket,
+		GFP_ATOMIC )) ) {
+			req_entry->re_req->complete = gs_write_complete;
+			list_add( &req_entry->re_entry, &dev->dev_req_list );
+		} else {
+			gs_reset_config( dev );
+			printk( KERN_ERR
+			"gs_set_config: cannot allocate write requests\n" );
+			return( -ENOMEM );
+		}
+	}
+
+	dev->dev_config = config;
+
+	printk( KERN_INFO "gs_set_config: %s configured for %s speed\n",
+		GS_LONG_NAME,
+		gadget->speed == USB_SPEED_HIGH ? "high" : "full" );
+
+	return( 0 );
+
+}
+
+
+/*
+ * gs_reset_config
+ *
+ * Mark the device as not configured, disable all endpoints,
+ * which forces completion of pending I/O and frees queued
+ * requests, and free the remaining write requests on the
+ * free list.
+ *
+ * The device lock must be held when calling this function.
+ */
+
+static void gs_reset_config( struct gs_dev *dev )
+{
+
+	struct gs_req_entry *req_entry;
+
+
+	if( dev == NULL ) {
+		printk( KERN_ERR "gs_reset_config: NULL device pointer\n" );
+		return;
+	}
+
+	if( dev->dev_config == GS_NO_CONFIG_ID )
+		return;
+
+	dev->dev_config = GS_NO_CONFIG_ID;
+
+	/* free write requests on the free list */
+	while( !list_empty( &dev->dev_req_list ) ) {
+		req_entry = list_entry( dev->dev_req_list.next,
+			struct gs_req_entry, re_entry );
+		list_del( &req_entry->re_entry );
+		gs_free_req_entry( dev->dev_in_ep, req_entry );
+	}
+
+	/* disable endpoints, forcing completion of pending i/o; */
+	/* completion handlers free their requests in this case */
+	if( dev->dev_in_ep ) {
+		usb_ep_disable( dev->dev_in_ep );
+		dev->dev_in_ep = NULL;
+	}
+	if( dev->dev_out_ep ) {
+		usb_ep_disable( dev->dev_out_ep );
+		dev->dev_out_ep = NULL;
+	}
+
+}
+
+
+/*
+ * gs_build_config_desc
+ *
+ * Builds a config descriptor in the given buffer and returns the
+ * length, or a negative error number.
+ */
+
+static int gs_build_config_desc( u8 *buf, enum usb_device_speed speed,
+		u8 type, unsigned int index )
+{
+
+	int high_speed;
+	int len = USB_DT_CONFIG_SIZE + USB_DT_INTERFACE_SIZE
+				+ GS_NUM_ENDPOINTS * USB_DT_ENDPOINT_SIZE;
+
+
+	/* only one config */
+	if( index != 0 )
+		return( -EINVAL );
+
+	memcpy( buf, &gs_config_desc, USB_DT_CONFIG_SIZE );
+	((struct usb_config_descriptor *)buf)->bDescriptorType = type;
+	((struct usb_config_descriptor *)buf)->wTotalLength =
+		__constant_cpu_to_le16( len );
+	buf += USB_DT_CONFIG_SIZE;
+
+	memcpy( buf, &gs_interface_desc, USB_DT_INTERFACE_SIZE );
+	buf += USB_DT_INTERFACE_SIZE;
+
+	/* other speed switches high and full speed */
+	high_speed = (speed == USB_SPEED_HIGH);
+	if( type == USB_DT_OTHER_SPEED_CONFIG )
+		high_speed = !high_speed;
+
+	memcpy( buf,
+		high_speed ? &gs_highspeed_in_desc : &gs_fullspeed_in_desc,
+		USB_DT_ENDPOINT_SIZE );
+	buf += USB_DT_ENDPOINT_SIZE;
+	memcpy( buf,
+		high_speed ? &gs_highspeed_out_desc : &gs_fullspeed_out_desc,
+		USB_DT_ENDPOINT_SIZE );
+
+	return( len );
+
+}
+
+
+/*
+ * gs_alloc_req
+ *
+ * Allocate a usb_request and its buffer.  Returns a pointer to the
+ * usb_request or NULL if there is an error.
+ */
+
+static struct usb_request *gs_alloc_req( struct usb_ep *ep, unsigned int len,
+	int kmalloc_flags )
+{
+
+	struct usb_request *req;
+
+
+	if( ep == NULL )
+		return( NULL );
+
+	req = usb_ep_alloc_request( ep, kmalloc_flags );
+
+	if( req != NULL ) {
+		req->length = len;
+		req->buf = usb_ep_alloc_buffer( ep, len, &req->dma,
+			kmalloc_flags );
+		if( req->buf == NULL ) {
+			usb_ep_free_request( ep, req );
+			return( NULL );
+		}
+	}
+
+	return( req );
+
+}
+
+
+/*
+ * gs_free_req
+ *
+ * Free a usb_request and its buffer.
+ */
+
+static void gs_free_req( struct usb_ep *ep, struct usb_request *req )
+{
+	if( ep != NULL && req != NULL ) {
+		if( req->buf != NULL )
+			usb_ep_free_buffer( ep, req->buf, req->dma,
+				req->length );
+		usb_ep_free_request( ep, req );
+	}
+}
+
+
+/*
+ * gs_alloc_req_entry
+ *
+ * Allocates a request and its buffer, using the given
+ * endpoint, buffer len, and kmalloc flags.
+ */
+
+static struct gs_req_entry *gs_alloc_req_entry( struct usb_ep *ep,
+	unsigned len, int kmalloc_flags )
+{
+
+	struct gs_req_entry	*req;
+
+
+	req = kmalloc( sizeof(struct gs_req_entry), kmalloc_flags );
+	if( req == NULL )
+		return( NULL );
+
+	req->re_req = gs_alloc_req( ep, len, kmalloc_flags );
+	if( req->re_req == NULL ) {
+		kfree( req );
+		return( NULL );
+	}
+
+	req->re_req->context = req;
+
+	return( req );
+
+}
+
+
+/*
+ * gs_free_req_entry
+ *
+ * Frees a request and its buffer.
+ */
+
+static void gs_free_req_entry( struct usb_ep *ep, struct gs_req_entry *req )
+{
+	if( ep != NULL && req != NULL ) {
+		if( req->re_req != NULL )
+			gs_free_req( ep, req->re_req );
+		kfree( req );
+	}
+}
+
+
+/*
+ * gs_alloc_ports
+ *
+ * Allocate all ports and set the gs_dev struct to point to them.
+ * Return 0 if successful, or a negative error number.
+ *
+ * The device lock is normally held when calling this function.
+ */
+
+static int gs_alloc_ports( struct gs_dev *dev, int kmalloc_flags )
+{
+
+	int i;
+	struct gs_port *port;
+
+
+	if( dev == NULL )
+		return( -EIO );
+
+	for( i=0; i<GS_NUM_PORTS; i++ ) {
+
+		if( (port=(struct gs_port *)kmalloc( sizeof(struct gs_port),
+		kmalloc_flags )) == NULL )
+			return( -ENOMEM );
+
+		memset( port, 0, sizeof( struct gs_port ) );
+		port->port_dev = dev;
+		port->port_num = i;
+		spin_lock_init( &port->port_lock );
+    	init_waitqueue_head( &port->port_write_wait );
+
+		dev->dev_port[i] = port;
+
+	}
+
+	return( 0 );
+
+}
+
+
+/*
+ * gs_free_ports
+ *
+ * Free all closed ports.  Open ports are disconnected by
+ * freeing their write buffers, setting their device pointers
+ * and the pointers to them in the device to NULL.  These
+ * ports will be freed when closed.
+ *
+ * The device lock is normally held when calling this function.
+ */
+
+static void gs_free_ports( struct gs_dev *dev )
+{
+
+	int i;
+	unsigned long flags;
+	struct gs_port *port;
+
+
+	if( dev == NULL )
+		return;
+
+	for( i=0; i<GS_NUM_PORTS; i++ ) {
+
+		if( (port=dev->dev_port[i]) != NULL ) {
+
+			dev->dev_port[i] = NULL;
+
+			spin_lock_irqsave( &port->port_lock, flags );
+
+			if( port->port_write_buf != NULL ) {
+				gs_buf_free( port->port_write_buf );
+				port->port_write_buf = NULL;
+			}
+
+			if( port->port_open_count > 0 || port->port_in_use ) {
+				port->port_dev = NULL;
+				wake_up_interruptible( &port->port_write_wait );
+				wake_up_interruptible( &port->port_tty->read_wait );
+				wake_up_interruptible( &port->port_tty->write_wait );
+			} else {
+				kfree( port );
+			}
+
+			spin_unlock_irqrestore( &port->port_lock, flags );
+
+		}
+
+	}
+
+}
+
+
+/* Circular Buffer */
+
+/*
+ * gs_buf_alloc
+ *
+ * Allocate a circular buffer and all associated memory.
+ */
+
+static struct gs_buf *gs_buf_alloc( unsigned int size, int kmalloc_flags )
+{
+
+	struct gs_buf *gb;
+
+
+	if( size == 0 )
+		return( NULL );
+
+	gb = (struct gs_buf *)kmalloc( sizeof(struct gs_buf), kmalloc_flags );
+	if( gb == NULL )
+		return( NULL );
+
+	gb->buf_buf = kmalloc( size, kmalloc_flags );
+	if( gb->buf_buf == NULL ) {
+		kfree( gb );
+		return( NULL );
+	}
+
+	gb->buf_size = size;
+	gb->buf_get = gb->buf_put = gb->buf_buf;
+
+	return( gb );
+
+}
+
+
+/*
+ * gs_buf_free
+ *
+ * Free the buffer and all associated memory.
+ */
+
+void gs_buf_free( struct gs_buf *gb )
+{
+	if( gb != NULL ) {
+		if( gb->buf_buf != NULL )
+			kfree( gb->buf_buf );
+		kfree( gb );
+	}
+}
+
+
+/*
+ * gs_buf_clear
+ *
+ * Clear out all data in the circular buffer.
+ */
+
+void gs_buf_clear( struct gs_buf *gb )
+{
+	if( gb != NULL )
+		gb->buf_get = gb->buf_put;
+		/* equivalent to a get of all data available */
+}
+
+
+/*
+ * gs_buf_data_avail
+ *
+ * Return the number of bytes of data available in the circular
+ * buffer.
+ */
+
+unsigned int gs_buf_data_avail( struct gs_buf *gb )
+{
+	if( gb != NULL )
+		return( (gb->buf_size + gb->buf_put - gb->buf_get)
+			% gb->buf_size );
+	else
+		return( 0 );
+}
+
+
+/*
+ * gs_buf_space_avail
+ *
+ * Return the number of bytes of space available in the circular
+ * buffer.
+ */
+
+unsigned int gs_buf_space_avail( struct gs_buf *gb )
+{
+	if( gb != NULL )
+		return( (gb->buf_size + gb->buf_get - gb->buf_put - 1)
+			% gb->buf_size );
+	else
+		return( 0 );
+}
+
+
+/*
+ * gs_buf_put
+ *
+ * Copy data data from a user buffer and put it into the circular buffer.
+ * Restrict to the amount of space available.
+ *
+ * Return the number of bytes copied.
+ */
+
+unsigned int gs_buf_put( struct gs_buf *gb, const char *buf,
+	unsigned int count )
+{
+
+	unsigned int len;
+
+
+	if( gb == NULL )
+		return( 0 );
+
+	len  = gs_buf_space_avail( gb );
+	if( count > len )
+		count = len;
+
+	if( count == 0 )
+		return( 0 );
+
+	len = gb->buf_buf + gb->buf_size - gb->buf_put;
+	if( count > len ) {
+		memcpy( gb->buf_put, buf, len );
+		memcpy( gb->buf_buf, buf+len, count - len );
+		gb->buf_put = gb->buf_buf + count - len;
+	} else {
+		memcpy( gb->buf_put, buf, count );
+		if( count < len )
+			gb->buf_put += count;
+		else /* count == len */
+			gb->buf_put = gb->buf_buf;
+	}
+
+	return( count );
+
+}
+
+
+/*
+ * gs_buf_get
+ *
+ * Get data from the circular buffer and copy to the given buffer.
+ * Restrict to the amount of data available.
+ *
+ * Return the number of bytes copied.
+ */
+
+unsigned int gs_buf_get( struct gs_buf *gb, char *buf, unsigned int count )
+{
+
+	unsigned int len;
+
+
+	if( gb == NULL )
+		return( 0 );
+
+	len = gs_buf_data_avail( gb );
+	if( count > len )
+		count = len;
+
+	if( count == 0 )
+		return( 0 );
+
+	len = gb->buf_buf + gb->buf_size - gb->buf_get;
+	if( count > len ) {
+		memcpy( buf, gb->buf_get, len );
+		memcpy( buf+len, gb->buf_buf, count - len );
+		gb->buf_get = gb->buf_buf + count - len;
+	} else {
+		memcpy( buf, gb->buf_get, count );
+		if( count < len )
+			gb->buf_get += count;
+		else /* count == len */
+			gb->buf_get = gb->buf_buf;
+	}
+
+	return( count );
+
+}
diff -purN linux-2.5/drivers/usb/host/ohci-dbg.c usb-2.5/drivers/usb/host/ohci-dbg.c
--- linux-2.5/drivers/usb/host/ohci-dbg.c	2003-07-01 13:25:48.000000000 +0000
+++ usb-2.5/drivers/usb/host/ohci-dbg.c	2003-12-04 11:56:15.000000000 +0000
@@ -269,18 +269,19 @@ static void ohci_dump (struct ohci_hcd *
 	ohci_dump_status (controller, NULL, 0);
 	if (controller->hcca)
 		ohci_dbg (controller,
-			"hcca frame #%04x\n", controller->hcca->frame_no);
+			"hcca frame #%04x\n", OHCI_FRAME_NO(controller->hcca));
 	ohci_dump_roothub (controller, 1, NULL, 0);
 }
 
 static const char data0 [] = "DATA0";
 static const char data1 [] = "DATA1";
 
-static void ohci_dump_td (struct ohci_hcd *ohci, char *label, struct td *td)
+static void ohci_dump_td (const struct ohci_hcd *ohci, const char *label,
+		const struct td *td)
 {
 	u32	tmp = le32_to_cpup (&td->hwINFO);
 
-	ohci_dbg (ohci, "%s td %p%s; urb %p index %d; hw next td %08x",
+	ohci_dbg (ohci, "%s td %p%s; urb %p index %d; hw next td %08x\n",
 		label, td,
 		(tmp & TD_DONE) ? " (DONE)" : "",
 		td->urb, td->index,
@@ -301,28 +302,28 @@ static void ohci_dump_td (struct ohci_hc
 		case TD_DP_OUT: pid = "OUT"; break;
 		default: pid = "(bad pid)"; break;
 		}
-		ohci_dbg (ohci, "     info %08x CC=%x %s DI=%d %s %s", tmp,
+		ohci_dbg (ohci, "     info %08x CC=%x %s DI=%d %s %s\n", tmp,
 			TD_CC_GET(tmp), /* EC, */ toggle,
 			(tmp & TD_DI) >> 21, pid,
 			(tmp & TD_R) ? "R" : "");
 		cbp = le32_to_cpup (&td->hwCBP);
 		be = le32_to_cpup (&td->hwBE);
-		ohci_dbg (ohci, "     cbp %08x be %08x (len %d)", cbp, be,
+		ohci_dbg (ohci, "     cbp %08x be %08x (len %d)\n", cbp, be,
 			cbp ? (be + 1 - cbp) : 0);
 	} else {
 		unsigned	i;
-		ohci_dbg (ohci, "     info %08x CC=%x FC=%d DI=%d SF=%04x", tmp,
+		ohci_dbg (ohci, "  info %08x CC=%x FC=%d DI=%d SF=%04x\n", tmp,
 			TD_CC_GET(tmp),
 			(tmp >> 24) & 0x07,
 			(tmp & TD_DI) >> 21,
 			tmp & 0x0000ffff);
-		ohci_dbg (ohci, "     bp0 %08x be %08x",
+		ohci_dbg (ohci, "  bp0 %08x be %08x\n",
 			le32_to_cpup (&td->hwCBP) & ~0x0fff,
 			le32_to_cpup (&td->hwBE));
 		for (i = 0; i < MAXPSW; i++) {
 			u16	psw = le16_to_cpup (&td->hwPSW [i]);
 			int	cc = (psw >> 12) & 0x0f;
-			ohci_dbg (ohci, "       psw [%d] = %2x, CC=%x %s=%d", i,
+			ohci_dbg (ohci, "    psw [%d] = %2x, CC=%x %s=%d\n", i,
 				psw, cc,
 				(cc >= 0x0e) ? "OFFSET" : "SIZE",
 				psw & 0x0fff);
@@ -332,12 +333,13 @@ static void ohci_dump_td (struct ohci_hc
 
 /* caller MUST own hcd spinlock if verbose is set! */
 static void __attribute__((unused))
-ohci_dump_ed (struct ohci_hcd *ohci, char *label, struct ed *ed, int verbose)
+ohci_dump_ed (const struct ohci_hcd *ohci, const char *label,
+		const struct ed *ed, int verbose)
 {
 	u32	tmp = ed->hwINFO;
 	char	*type = "";
 
-	ohci_dbg (ohci, "%s, ed %p state 0x%x type %s; next ed %08x",
+	ohci_dbg (ohci, "%s, ed %p state 0x%x type %s; next ed %08x\n",
 		label,
 		ed, ed->state, edstring (ed->type),
 		le32_to_cpup (&ed->hwNextED));
@@ -347,7 +349,7 @@ ohci_dump_ed (struct ohci_hcd *ohci, cha
 	/* else from TDs ... control */
 	}
 	ohci_dbg (ohci,
-		"  info %08x MAX=%d%s%s%s%s EP=%d%s DEV=%d", le32_to_cpu (tmp),
+		"  info %08x MAX=%d%s%s%s%s EP=%d%s DEV=%d\n", le32_to_cpu (tmp),
 		0x03ff & (le32_to_cpu (tmp) >> 16),
 		(tmp & ED_DEQUEUE) ? " DQ" : "",
 		(tmp & ED_ISO) ? " ISO" : "",
@@ -356,7 +358,7 @@ ohci_dump_ed (struct ohci_hcd *ohci, cha
 		0x000f & (le32_to_cpu (tmp) >> 7),
 		type,
 		0x007f & le32_to_cpu (tmp));
-	ohci_dbg (ohci, "  tds: head %08x %s%s tail %08x%s",
+	ohci_dbg (ohci, "  tds: head %08x %s%s tail %08x%s\n",
 		tmp = le32_to_cpup (&ed->hwHeadP),
 		(ed->hwHeadP & ED_C) ? data1 : data0,
 		(ed->hwHeadP & ED_H) ? " HALT" : "",
@@ -541,24 +543,29 @@ show_periodic (struct class_device *clas
 			if (temp == seen_count) {
 				u32	info = ed->hwINFO;
 				u32	scratch = cpu_to_le32p (&ed->hwINFO);
+				struct list_head	*entry;
+				unsigned		qlen = 0;
+
+				/* qlen measured here in TDs, not urbs */
+				list_for_each (entry, &ed->td_list)
+					qlen++;
 
 				temp = snprintf (next, size,
-					" (%cs dev%d%s ep%d%s"
+					" (%cs dev%d ep%d%s-%s qlen %u"
 					" max %d %08x%s%s)",
 					(info & ED_LOWSPEED) ? 'l' : 'f',
 					scratch & 0x7f,
-					(info & ED_ISO) ? " iso" : "",
 					(scratch >> 7) & 0xf,
 					(info & ED_IN) ? "in" : "out",
+					(info & ED_ISO) ? "iso" : "int",
+					qlen,
 					0x03ff & (scratch >> 16),
 					scratch,
-					(info & ED_SKIP) ? " s" : "",
+					(info & ED_SKIP) ? " K" : "",
 					(ed->hwHeadP & ED_H) ? " H" : "");
 				size -= temp;
 				next += temp;
 
-				// FIXME some TD info too
-
 				if (seen_count < DBG_SCHED_LIMIT)
 					seen [seen_count++] = ed;
 
@@ -617,7 +624,7 @@ show_registers (struct class_device *cla
 	/* hcca */
 	if (ohci->hcca)
 		ohci_dbg_sw (ohci, &next, &size,
-			"hcca frame 0x%04x\n", ohci->hcca->frame_no);
+			"hcca frame 0x%04x\n", OHCI_FRAME_NO(ohci->hcca));
 
 	/* other registers mostly affect frame timings */
 	rdata = readl (&regs->fminterval);
diff -purN linux-2.5/drivers/usb/host/ohci-hcd.c usb-2.5/drivers/usb/host/ohci-hcd.c
--- linux-2.5/drivers/usb/host/ohci-hcd.c	2003-10-13 14:12:52.000000000 +0000
+++ usb-2.5/drivers/usb/host/ohci-hcd.c	2003-12-03 19:35:19.000000000 +0000
@@ -226,7 +226,7 @@ static int ohci_urb_enqueue (
 		if (retval < 0)
 			goto fail;
 		if (ed->type == PIPE_ISOCHRONOUS) {
-			u16	frame = le16_to_cpu (ohci->hcca->frame_no);
+			u16	frame = OHCI_FRAME_NO(ohci->hcca);
 
 			/* delay a few frames before the first TD */
 			frame += max_t (u16, 8, ed->interval);
@@ -281,7 +281,7 @@ static int ohci_urb_dequeue (struct usb_
 		urb_priv = urb->hcpriv;
 		if (urb_priv) {
 			if (urb_priv->ed->state == ED_OPER)
-				start_urb_unlink (ohci, urb_priv->ed);
+				start_ed_unlink (ohci, urb_priv->ed);
 		}
 	} else {
 		/*
@@ -363,7 +363,7 @@ static int ohci_get_frame (struct usb_hc
 {
 	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
 
-	return le16_to_cpu (ohci->hcca->frame_no);
+	return OHCI_FRAME_NO(ohci->hcca);
 }
 
 /*-------------------------------------------------------------------------*
@@ -591,7 +591,7 @@ static void ohci_irq (struct usb_hcd *hc
 	 */
 	spin_lock (&ohci->lock);
 	if (ohci->ed_rm_list)
-		finish_unlinks (ohci, le16_to_cpu (ohci->hcca->frame_no),
+		finish_unlinks (ohci, OHCI_FRAME_NO(ohci->hcca),
 				ptregs);
 	if ((ints & OHCI_INTR_SF) != 0 && !ohci->ed_rm_list
 			&& HCD_IS_RUNNING(ohci->hcd.state))
diff -purN linux-2.5/drivers/usb/host/ohci-q.c usb-2.5/drivers/usb/host/ohci-q.c
--- linux-2.5/drivers/usb/host/ohci-q.c	2003-10-13 13:48:24.000000000 +0000
+++ usb-2.5/drivers/usb/host/ohci-q.c	2003-12-04 11:14:32.000000000 +0000
@@ -430,7 +430,7 @@ done:
  * put the ep on the rm_list
  * real work is done at the next start frame (SF) hardware interrupt
  */
-static void start_urb_unlink (struct ohci_hcd *ohci, struct ed *ed)
+static void start_ed_unlink (struct ohci_hcd *ohci, struct ed *ed)
 {    
 	ed->hwINFO |= ED_DEQUEUE;
 	ed->state = ED_UNLINK;
@@ -441,7 +441,7 @@ static void start_urb_unlink (struct ohc
 	 * behave.  frame_no wraps every 2^16 msec, and changes right before
 	 * SF is triggered.
 	 */
-	ed->tick = le16_to_cpu (ohci->hcca->frame_no) + 1;
+	ed->tick = OHCI_FRAME_NO(ohci->hcca) + 1;
 
 	/* rm_list is just singly linked, for simplicity */
 	ed->ed_next = ohci->ed_rm_list;
@@ -479,7 +479,8 @@ td_fill (struct ohci_hcd *ohci, u32 info
 	 * and iso; other urbs rarely need more than one TD per urb.
 	 * this way, only final tds (or ones with an error) cause IRQs.
 	 * at least immediately; use DI=6 in case any control request is
-	 * tempted to die part way through.
+	 * tempted to die part way through.  (and to force the hc to flush
+	 * its donelist soonish, even on unlink paths.)
 	 *
 	 * NOTE: could delay interrupts even for the last TD, and get fewer
 	 * interrupts ... increasing per-urb latency by sharing interrupts.
@@ -879,12 +880,27 @@ rescan_all:
 		u32			*prev;
 
 		/* only take off EDs that the HC isn't using, accounting for
-		 * frame counter wraps.
+		 * frame counter wraps and EDs with partially retired TDs
 		 */
-		if (tick_before (tick, ed->tick)
-				&& HCD_IS_RUNNING(ohci->hcd.state)) {
-			last = &ed->ed_next;
-			continue;
+		if (likely (HCD_IS_RUNNING(ohci->hcd.state))) {
+			if (tick_before (tick, ed->tick)) {
+skip_ed:
+				last = &ed->ed_next;
+				continue;
+			}
+
+			if (!list_empty (&ed->td_list)) {
+				struct td	*td;
+				u32		head;
+
+				td = list_entry (ed->td_list.next, struct td,
+							td_list);
+				head = cpu_to_le32 (ed->hwHeadP) & TD_MASK;
+
+				/* INTR_WDH may need to clean up first */
+				if (td->td_dma != head)
+					goto skip_ed;
+			}
 		}
 
 		/* reentrancy:  if we drop the schedule lock, someone might
diff -purN linux-2.5/drivers/usb/host/ohci.h usb-2.5/drivers/usb/host/ohci.h
--- linux-2.5/drivers/usb/host/ohci.h	2003-10-13 13:24:06.000000000 +0000
+++ usb-2.5/drivers/usb/host/ohci.h	2003-12-04 11:45:46.000000000 +0000
@@ -172,8 +172,14 @@ static const int cc_to_error [16] = { 
 struct ohci_hcca {
 #define NUM_INTS 32
 	__u32	int_table [NUM_INTS];	/* periodic schedule */
-	__u16	frame_no;		/* current frame number */
-	__u16	pad1;			/* set to 0 on each frame_no change */
+
+	/* 
+	 * OHCI defines u16 frame_no, followed by u16 zero pad.
+	 * Since some processors can't do 16 bit bus accesses,
+	 * portable access must be a 32 bit byteswapped access.
+	 */
+	u32	frame_no;		/* current frame number */
+#define OHCI_FRAME_NO(hccap) ((u16)le32_to_cpup(&(hccap)->frame_no))
 	__u32	done_head;		/* info returned for an interrupt */
 	u8	reserved_for_hc [116];
 	u8	what [4];		/* spec only identifies 252 bytes :) */
diff -purN linux-2.5/drivers/usb/image/scanner.c usb-2.5/drivers/usb/image/scanner.c
--- linux-2.5/drivers/usb/image/scanner.c	2003-09-22 19:51:23.000000000 +0000
+++ usb-2.5/drivers/usb/image/scanner.c	2003-11-04 11:11:18.000000000 +0000
@@ -380,6 +380,10 @@
  *      Visioneer scanners.
  *    - Added test for USB_CLASS_CDC_DATA which is used by some fingerprint scanners.
  *
+ * 0.4.16  2003-11-04
+ *    - Added vendor/product ids for Epson, Genius, Microtek, Plustek, Reflecta, and
+ *      Visioneer scanners. Removed ids for HP PSC devices as these are supported by
+ *      the hpoj userspace driver.
  *
  * TODO
  *    - Performance
diff -purN linux-2.5/drivers/usb/image/scanner.h usb-2.5/drivers/usb/image/scanner.h
--- linux-2.5/drivers/usb/image/scanner.h	2003-09-22 09:25:44.000000000 +0000
+++ usb-2.5/drivers/usb/image/scanner.h	2003-11-04 10:59:45.000000000 +0000
@@ -43,7 +43,7 @@
 
 // #define DEBUG
 
-#define DRIVER_VERSION "0.4.15"
+#define DRIVER_VERSION "0.4.16"
 #define DRIVER_DESC "USB Scanner Driver"
 
 #include <linux/usb.h>
@@ -146,7 +146,12 @@ static struct usb_device_id scanner_devi
 	{ USB_DEVICE(0x0458, 0x2015) }, /* ColorPage HR7LE */
 	{ USB_DEVICE(0x0458, 0x2016) }, /* ColorPage HR6X */
 	{ USB_DEVICE(0x0458, 0x2018) },	/* ColorPage HR7X */
+	{ USB_DEVICE(0x0458, 0x201b) },	/* Colorpage Vivid 4x */
 	/* Hewlett Packard */
+	/* IMPORTANT: Hewlett-Packard multi-function peripherals (OfficeJet, 
+	   Printer/Scanner/Copier (PSC), LaserJet, or PhotoSmart printer)
+	   should not be added to this table because they are accessed by a
+	   userspace driver (hpoj) */
 	{ USB_DEVICE(0x03f0, 0x0101) },	/* ScanJet 4100C */
 	{ USB_DEVICE(0x03f0, 0x0102) },	/* PhotoSmart S20 */
 	{ USB_DEVICE(0x03f0, 0x0105) },	/* ScanJet 4200C */
@@ -168,10 +173,10 @@ static struct usb_device_id scanner_devi
 	{ USB_DEVICE(0x03F0, 0x1105) },	/* ScanJet 5470C */
 	{ USB_DEVICE(0x03f0, 0x1205) }, /* ScanJet 5550C */
 	{ USB_DEVICE(0x03f0, 0x1305) },	/* Scanjet 4570c */
-	{ USB_DEVICE(0x03f0, 0x1411) }, /* PSC 750 */
+	//	{ USB_DEVICE(0x03f0, 0x1411) }, /* PSC 750 - NOT SUPPORTED - use hpoj userspace driver */
 	{ USB_DEVICE(0x03f0, 0x2005) },	/* ScanJet 3570c */
 	{ USB_DEVICE(0x03f0, 0x2205) },	/* ScanJet 3500c */
-	{ USB_DEVICE(0x03f0, 0x2f11) }, /* PSC 1210 */
+	//	{ USB_DEVICE(0x03f0, 0x2f11) }, /* PSC 1210 - NOT SUPPORTED - use hpoj userspace driver */
 	/* Lexmark */
 	{ USB_DEVICE(0x043d, 0x002d) }, /* X70/X73 */
 	{ USB_DEVICE(0x043d, 0x003d) }, /* X83 */
@@ -187,6 +192,7 @@ static struct usb_device_id scanner_devi
 	{ USB_DEVICE(0x05da, 0x30ce) },	/* ScanMaker 3800 */
 	{ USB_DEVICE(0x05da, 0x30cf) },	/* ScanMaker 4800 */
 	{ USB_DEVICE(0x05da, 0x30d4) },	/* ScanMaker 3830 + 3840 */
+	{ USB_DEVICE(0x05da, 0x30d8) },	/* ScanMaker 5900 */
 	{ USB_DEVICE(0x04a7, 0x0224) },	/* Scanport 3000 (actually Visioneer?)*/
 	/* The following SCSI-over-USB Microtek devices are supported by the
 	   microtek driver: Enable SCSI and USB Microtek in kernel config */
@@ -245,6 +251,7 @@ static struct usb_device_id scanner_devi
 	{ USB_DEVICE(0x07b3, 0x0400) }, /* OpticPro 1248U */
 	{ USB_DEVICE(0x07b3, 0x0401) }, /* OpticPro 1248U (another one) */
 	{ USB_DEVICE(0x07b3, 0x0403) },	/* U16B */
+	{ USB_DEVICE(0x07b3, 0x0413) },	/* OpticSlim 1200 */
 	/* Primax/Colorado */
 	{ USB_DEVICE(0x0461, 0x0300) },	/* G2-300 #1 */
 	{ USB_DEVICE(0x0461, 0x0301) },	/* G2E-300 #1 */
@@ -261,6 +268,8 @@ static struct usb_device_id scanner_devi
 	{ USB_DEVICE(0x0461, 0x0383) },	/* G2E-600 */
 	/* Prolink */
 	{ USB_DEVICE(0x06dc, 0x0014) }, /* Winscan Pro 2448U */
+	/* Reflecta  */
+	{ USB_DEVICE(0x05e3, 0x0120) },	/* iScan 1800 */
 	/* Relisis */
 	// { USB_DEVICE(0x0475, 0x0103) },	/* Episode - undetected endpoint */
 	{ USB_DEVICE(0x0475, 0x0210) }, /* Scorpio Ultra 3 */
@@ -285,6 +294,7 @@ static struct usb_device_id scanner_devi
 	{ USB_DEVICE(0x04b8, 0x011c) }, /* Perfection 3200 */
 	{ USB_DEVICE(0x04b8, 0x011d) }, /* Perfection 1260 */
 	{ USB_DEVICE(0x04b8, 0x011e) }, /* Perfection 1660 Photo */
+	{ USB_DEVICE(0x04b8, 0x011f) },	/* Perfection 1670 */
 	{ USB_DEVICE(0x04b8, 0x0801) }, /* Stylus CX5200 */
 	{ USB_DEVICE(0x04b8, 0x0802) }, /* Stylus CX3200 */
 	/* Siemens */
@@ -309,6 +319,7 @@ static struct usb_device_id scanner_devi
 	{ USB_DEVICE(0x04a7, 0x0221) },	/* OneTouch 5300 USB */
 	{ USB_DEVICE(0x04a7, 0x0224) },	/* OneTouch 4800 USB */
 	{ USB_DEVICE(0x04a7, 0x0226) },	/* OneTouch 5800 USB */
+	{ USB_DEVICE(0x04a7, 0x0229) }, /* OneTouch 7100 USB */
 	{ USB_DEVICE(0x04a7, 0x022c) },	/* OneTouch 9020 USB */
 	{ USB_DEVICE(0x04a7, 0x0231) },	/* 6100 USB */
 	{ USB_DEVICE(0x04a7, 0x0311) },	/* 6200 EPP/USB */
diff -purN linux-2.5/drivers/usb/media/Kconfig usb-2.5/drivers/usb/media/Kconfig
--- linux-2.5/drivers/usb/media/Kconfig	2003-09-25 03:39:20.000000000 +0000
+++ usb-2.5/drivers/usb/media/Kconfig	2003-10-18 00:01:48.000000000 +0000
@@ -113,16 +113,17 @@ config USB_PWC
           webcams:
            * Philips PCA645, PCA646
            * Philips PCVC675, PCVC680, PCVC690
-           * Philips PCVC730, PCVC740, PCVC750
+           * Philips PCVC720/40, PCVC730, PCVC740, PCVC750
 	   * Askey VC010
-	   * Logitech QuickCam Pro 3000, 4000, 'Zoom' and 'Notebook'
-	   * Samsung MPC-C10, MPC-C30
-	   * Creative Webcam 5
-	   * SOTECT Afina Eye
+	   * Logitech QuickCam Pro 3000, 4000, 'Zoom', 'Notebook Pro' 
+             and 'Orbit'/'Sphere'
+           * Samsung MPC-C10, MPC-C30
+	   * Creative Webcam 5, Pro Ex
+	   * SOTEC Afina Eye
 	   * Visionite VCS-UC300, VCS-UM100
 	   
-	  The PCA635, PCVC665 and PCVC720 are not supported by this driver
-	  and never will be, but the 665 and 720 are supported by other 
+	  The PCA635, PCVC665 and PCVC720/20 are not supported by this driver
+	  and never will be, but the 665 and 720/20 are supported by other 
 	  drivers.
 
 	  This driver has an optional plugin (called PWCX), which is 
@@ -177,3 +178,30 @@ config USB_STV680
 	  To compile this driver as a module, choose M here: the
 	  module will be called stv680.
 
+config USB_W9968CF
+	tristate "USB W996[87]CF JPEG Dual Mode Camera support"
+	depends on USB && VIDEO_DEV && I2C
+	---help---
+	  Say Y here if you want support for cameras based on
+	  Winbond W9967CF/W9968CF JPEG USB Dual Mode Camera Chips.
+	
+	  This driver has an optional plugin, which is distributed as a
+	  separate module only (released under GPL). It contains code that 
+	  allows you to use higher resolutions and framerates, and can't
+	  be included into the official Linux kernel for performance 
+	  purposes.
+	  At the moment the driver needs a third-part module for the CMOS 
+	  sensors, which is available on internet: it is recommended to read
+	  <file:Documentation/usb/w9968cf.txt> for more informations and for
+	  a list of supported cameras.
+	
+	  This driver uses the Video For Linux and the I2C APIs. 
+	  You must say Y or M to both "Video For Linux" and 
+	  "I2C Support" to use this driver.
+	  Information on this API and pointers to "v4l" programs may be found
+	  on the WWW at <http://roadrunner.swansea.uk.linux.org/v4l.shtml>.
+	
+	  This code is also available as a module ( = code which can be
+	  inserted in and removed from the running kernel whenever you want).
+	  The module will be called w9968cf.o. If you want to compile it as a
+	  module, say M here and read <file:Documentation/modules.txt>.
diff -purN linux-2.5/drivers/usb/media/Makefile usb-2.5/drivers/usb/media/Makefile
--- linux-2.5/drivers/usb/media/Makefile	2003-02-03 22:19:38.000000000 +0000
+++ usb-2.5/drivers/usb/media/Makefile	2003-10-04 10:18:40.000000000 +0000
@@ -13,3 +13,4 @@ obj-$(CONFIG_USB_PWC)		+= pwc.o
 obj-$(CONFIG_USB_SE401)		+= se401.o
 obj-$(CONFIG_USB_STV680)	+= stv680.o
 obj-$(CONFIG_USB_VICAM)		+= vicam.o usbvideo.o
+obj-$(CONFIG_USB_W9968CF)	+= w9968cf.o
diff -purN linux-2.5/drivers/usb/media/pwc-ctrl.c usb-2.5/drivers/usb/media/pwc-ctrl.c
--- linux-2.5/drivers/usb/media/pwc-ctrl.c	2003-07-27 01:53:13.000000000 +0000
+++ usb-2.5/drivers/usb/media/pwc-ctrl.c	2003-10-18 00:19:08.000000000 +0000
@@ -44,6 +44,8 @@
 #define GET_STATUS_CTL			0x06
 #define SET_EP_STREAM_CTL		0x07
 #define GET_EP_STREAM_CTL		0x08
+#define SET_MPT_CTL			0x0D
+#define GET_MPT_CTL			0x0E
 
 /* Selectors for the Luminance controls [GS]ET_LUM_CTL */
 #define AGC_MODE_FORMATTER			0x2000
@@ -88,6 +90,11 @@
 /* Formatters for the Video Endpoint controls [GS]ET_EP_STREAM_CTL */
 #define VIDEO_OUTPUT_CONTROL_FORMATTER		0x0100
 
+/* Formatters for the motorized pan & tilt [GS]ET_MPT_CTL */
+#define PT_RELATIVE_CONTROL_FORMATTER		0x01
+#define PT_RESET_CONTROL_FORMATTER		0x02
+#define PT_STATUS_FORMATTER			0x03
+
 static char *size2name[PSZ_MAX] =
 {
 	"subQCIF",
@@ -435,6 +442,7 @@ int pwc_set_video_mode(struct pwc_device
 		ret = set_video_mode_Timon(pdev, size, frames, compression, snapshot);
 		break;
 		
+	case 720:
 	case 730:
 	case 740:
 	case 750:
@@ -745,6 +753,7 @@ static inline int pwc_set_shutter_speed(
 			buf[1] = speed >> 8;
 			buf[0] = speed & 0xff;
 			break;
+		case 720:
 		case 730:
 		case 740:
 		case 750:
@@ -1243,6 +1252,46 @@ static inline int pwc_get_dynamic_noise(
 	return buf;
 }
 
+int pwc_mpt_reset(struct pwc_device *pdev, int flags)
+{
+	unsigned char buf;
+	
+	buf = flags & 0x03; // only lower two bits are currently used 
+	return SendControlMsg(SET_MPT_CTL, PT_RESET_CONTROL_FORMATTER, 1);
+}
+
+static inline int pwc_mpt_set_angle(struct pwc_device *pdev, int pan, int tilt)
+{
+	unsigned char buf[4];
+	
+	/* set new relative angle; angles are expressed in degrees * 100,
+	   but cam as .5 degree resolution, hence devide by 200. Also
+	   the angle must be multiplied by 64 before it's send to
+	   the cam (??)
+	 */
+	pan  =  64 * pan  / 100;
+	tilt = -64 * tilt / 100; /* positive tilt is down, which is not what the user would expect */
+	buf[0] = pan & 0xFF;
+	buf[1] = (pan >> 8) & 0xFF;
+	buf[2] = tilt & 0xFF;
+	buf[3] = (tilt >> 8) & 0xFF;
+	return SendControlMsg(SET_MPT_CTL, PT_RELATIVE_CONTROL_FORMATTER, 4);
+}
+
+static inline int pwc_mpt_get_status(struct pwc_device *pdev, struct pwc_mpt_status *status)
+{
+	int ret;
+	unsigned char buf[5];
+	
+	ret = RecvControlMsg(GET_MPT_CTL, PT_STATUS_FORMATTER, 5);
+	if (ret < 0)
+		return ret;
+	status->status = buf[0] & 0x7; // 3 bits are used for reporting
+	status->time_pan = (buf[1] << 8) + buf[2];
+	status->time_tilt = (buf[3] << 8) + buf[4];
+	return 0;
+}
+
 
 int pwc_get_cmos_sensor(struct pwc_device *pdev)
 {
@@ -1512,8 +1561,128 @@ int pwc_ioctl(struct pwc_device *pdev, u
 		size->width = pdev->image.x;
 		size->height = pdev->image.y;
 		break;
-	}	
-
+ 	}
+ 	
+ 	case VIDIOCPWCMPTRESET:
+ 	{
+ 		int *flags = arg;
+ 		
+ 		if (pdev->features & FEATURE_MOTOR_PANTILT)
+ 		{
+			ret = pwc_mpt_reset(pdev, *flags);
+ 			if (ret >= 0)
+ 			{
+ 				pdev->pan_angle = 0;
+ 				pdev->tilt_angle = 0;
+ 			}
+ 		}
+ 		else
+ 		{
+ 			ret = -ENXIO;
+ 		}
+ 		break;		
+ 	}
+ 	case VIDIOCPWCMPTGRANGE:
+ 	{
+ 		if (pdev->features & FEATURE_MOTOR_PANTILT)
+ 		{
+ 			memcpy(arg, &pdev->angle_range, sizeof(struct pwc_mpt_range));
+ 		}
+ 		else
+ 		{	
+ 			ret = -ENXIO;
+ 		}
+ 		break;
+ 	}
+ 	
+ 	case VIDIOCPWCMPTSANGLE:
+ 	{
+ 		struct pwc_mpt_angles *angles = arg;
+ 		int new_pan, new_tilt;
+ 		
+ 		if (pdev->features & FEATURE_MOTOR_PANTILT)
+ 		{
+			/* The camera can only set relative angles, so
+			   do some calculations when getting an absolute angle .
+			 */
+			if (angles->absolute)
+			{
+ 				new_pan  = angles->pan; 
+ 				new_tilt = angles->tilt;
+ 			}
+ 			else
+ 			{
+ 				new_pan  = pdev->pan_angle  + angles->pan;
+ 				new_tilt = pdev->tilt_angle + angles->tilt;
+			}
+			/* check absolute ranges */
+			if (new_pan  < pdev->angle_range.pan_min  ||
+			    new_pan  > pdev->angle_range.pan_max  ||
+			    new_tilt < pdev->angle_range.tilt_min ||
+			    new_tilt > pdev->angle_range.tilt_max)
+			{
+				ret = -ERANGE;
+			}
+			else
+			{
+				/* go to relative range, check again */
+				new_pan  -= pdev->pan_angle;
+				new_tilt -= pdev->tilt_angle;
+				/* angles are specified in degrees * 100, thus the limit = 36000 */
+				if (new_pan < -36000 || new_pan > 36000 || new_tilt < -36000 || new_tilt > 36000)
+					ret = -ERANGE;
+			}
+			if (ret == 0) /* no errors so far */
+			{
+				ret = pwc_mpt_set_angle(pdev, new_pan, new_tilt);
+				if (ret >= 0)
+				{
+					pdev->pan_angle  += new_pan;
+					pdev->tilt_angle += new_tilt;
+				}
+				if (ret == -EPIPE) /* stall -> out of range */
+					ret = -ERANGE;				
+			}
+ 		}
+ 		else
+ 		{
+ 			ret = -ENXIO;
+ 		}
+ 		break;
+ 	} 
+ 	
+ 	case VIDIOCPWCMPTGANGLE:
+ 	{
+ 		struct pwc_mpt_angles *angles = arg;
+ 		
+ 		if (pdev->features & FEATURE_MOTOR_PANTILT)
+ 		{
+ 			angles->absolute = 1;
+ 			angles->pan  = pdev->pan_angle;
+ 			angles->tilt = pdev->tilt_angle;
+ 		}
+ 		else
+ 		{
+ 			ret = -ENXIO;
+ 		}
+ 		break;
+ 	}
+ 
+ 	case VIDIOCPWCMPTSTATUS:
+ 	{
+ 		struct pwc_mpt_status *status = arg;
+ 	
+ 		if (pdev->features & FEATURE_MOTOR_PANTILT)
+ 		{
+ 			ret = pwc_mpt_get_status(pdev, status);
+ 		}
+ 		else
+ 		{
+ 			ret = -ENXIO;
+ 		}
+  		break;
+  	}
+  	
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff -purN linux-2.5/drivers/usb/media/pwc-if.c usb-2.5/drivers/usb/media/pwc-if.c
--- linux-2.5/drivers/usb/media/pwc-if.c	2003-08-27 12:44:03.000000000 +0000
+++ usb-2.5/drivers/usb/media/pwc-if.c	2003-10-18 01:52:53.000000000 +0000
@@ -79,9 +79,9 @@ static struct usb_device_id pwc_device_t
 	{ USB_DEVICE(0x046D, 0x08B0) }, /* Logitech QuickCam Pro 3000 */
 	{ USB_DEVICE(0x046D, 0x08B1) }, /* Logitech QuickCam Notebook Pro */
 	{ USB_DEVICE(0x046D, 0x08B2) }, /* Logitech QuickCam Pro 4000 */
-	{ USB_DEVICE(0x046D, 0x08B3) }, /* Logitech QuickCam Zoom */
-	{ USB_DEVICE(0x046D, 0x08B4) }, /* Logitech (reserved) */
-	{ USB_DEVICE(0x046D, 0x08B5) }, /* Logitech (reserved) */
+	{ USB_DEVICE(0x046D, 0x08B3) }, /* Logitech QuickCam Zoom (old model) */
+	{ USB_DEVICE(0x046D, 0x08B4) }, /* Logitech QuickCam Zoom (new model) */
+	{ USB_DEVICE(0x046D, 0x08B5) }, /* Logitech QuickCam Orbit/Sphere */
 	{ USB_DEVICE(0x046D, 0x08B6) }, /* Logitech (reserved) */
 	{ USB_DEVICE(0x046D, 0x08B7) }, /* Logitech (reserved) */
 	{ USB_DEVICE(0x046D, 0x08B8) }, /* Logitech (reserved) */
@@ -129,6 +129,7 @@ static struct {
 
 static int pwc_video_open(struct inode *inode, struct file *file);
 static int pwc_video_close(struct inode *inode, struct file *file);
+static int pwc_video_release(struct video_device *);			  
 static ssize_t pwc_video_read(struct file *file, char *buf,
 			  size_t count, loff_t *ppos);
 static unsigned int pwc_video_poll(struct file *file, poll_table *wait);
@@ -918,21 +919,32 @@ static void pwc_isoc_cleanup(struct pwc_
 
 int pwc_try_video_mode(struct pwc_device *pdev, int width, int height, int new_fps, int new_compression, int new_snapshot)
 {
-	int ret;
+	int ret, start;
 
 	/* Stop isoc stuff */
 	pwc_isoc_cleanup(pdev);
 	/* Reset parameters */
 	pwc_reset_buffers(pdev);
 	/* Try to set video mode... */
-	ret = pwc_set_video_mode(pdev, width, height, new_fps, new_compression, new_snapshot);
-	if (ret) /* That failed... restore old mode (we know that worked) */
-		ret = pwc_set_video_mode(pdev, pdev->view.x, pdev->view.y, pdev->vframes, pdev->vcompression, pdev->vsnapshot);
-	if (!ret)
-		if (pwc_isoc_init(pdev) < 0)
-			Info("Failed to restart ISOC transfer in pwc_try_video_mode.\n");
+	start = ret = pwc_set_video_mode(pdev, width, height, new_fps, new_compression, new_snapshot);
+	if (ret) { 
+	        Trace(TRACE_FLOW, "pwc_set_video_mode attempt 1 failed.\n");
+		/* That failed... restore old mode (we know that worked) */
+		start = pwc_set_video_mode(pdev, pdev->view.x, pdev->view.y, pdev->vframes, pdev->vcompression, pdev->vsnapshot);
+		if (start) {
+		        Trace(TRACE_FLOW, "pwc_set_video_mode attempt 2 failed.\n");
+		}
+	}
+	if (start == 0) 
+	{
+		if (pwc_isoc_init(pdev) < 0) 
+		{
+			Info("Failed to restart ISOC transfers in pwc_try_video_mode.\n");
+			ret = -EAGAIN; /* let's try again, who knows if it works a second time */
+		}
+	}
 	pdev->drop_frames++; /* try to avoid garbage during switch */
-	return ret;
+	return ret; /* Return original error code */
 }
 
 
@@ -997,6 +1009,7 @@ static int pwc_video_open(struct inode *
 #if PWC_DEBUG	
 	Debug("Found decompressor for %d at 0x%p\n", pdev->type, pdev->decompressor);
 #endif
+	pwc_construct(pdev); /* set min/max sizes correct */
 
 	/* So far, so good. Allocate memory. */
 	i = pwc_allocate_buffers(pdev);
@@ -1018,6 +1031,7 @@ static int pwc_video_open(struct inode *
 #if PWC_DEBUG
 	pdev->sequence = 0;
 #endif
+	pwc_construct(pdev); /* set min/max sizes correct */
 
 	/* Set some defaults */
 	pdev->vsnapshot = 0;
@@ -1104,6 +1118,12 @@ static int pwc_video_close(struct inode 
 	return 0;
 }
 
+static int pwc_video_release(struct video_device *vfd)
+{
+	Trace(TRACE_OPEN, "pwc_video_release() called. Now what?\n");
+}
+		
+
 /*
  *	FIXME: what about two parallel reads ????
  *      ANSWER: Not supported. You can't open the device more than once,
@@ -1124,7 +1144,7 @@ static ssize_t pwc_video_read(struct fil
 	int noblock = file->f_flags & O_NONBLOCK;
 	DECLARE_WAITQUEUE(wait, current);
 
-	Trace(TRACE_READ, "video_read(0x%p, %p, %Zd) called.\n", vdev, buf, count);
+	Trace(TRACE_READ, "video_read(0x%p, %p, %d) called.\n", vdev, buf, count);
 	if (vdev == NULL)
 		return -EFAULT;
 	pdev = vdev->priv;
@@ -1568,6 +1588,7 @@ static int usb_pwc_probe(struct usb_inte
 	struct pwc_device *pdev = NULL;
 	int vendor_id, product_id, type_id;
 	int i, hint;
+	int features = 0;
 	int video_nr = -1; /* default: use next available device */
 	char serial_number[30], *name;
 
@@ -1677,8 +1698,17 @@ static int usb_pwc_probe(struct usb_inte
 			name = "Logitech QuickCam Zoom";
 			type_id = 740; /* CCD sensor */
 			break;
-		case 0x08b4:
+		case 0x08B4:
+			Info("Logitech QuickCam Zoom (new model) USB webcam detected.\n");
+			name = "Logitech QuickCam Zoom";
+			type_id = 740; /* CCD sensor */
+			break;
 		case 0x08b5:
+			Info("Logitech QuickCam Orbit/Sphere USB webcam detected.\n");
+			name = "Logitech QuickCam Orbit";
+			type_id = 740; /* CCD sensor */
+			features |= FEATURE_MOTOR_PANTILT;
+			break;
 		case 0x08b6:
 		case 0x08b7:
 		case 0x08b8:
@@ -1776,9 +1806,22 @@ static int usb_pwc_probe(struct usb_inte
 	}
 	memset(pdev, 0, sizeof(struct pwc_device));
 	pdev->type = type_id;
-	pwc_construct(pdev);
 	pdev->vsize = default_size;
 	pdev->vframes = default_fps;
+	pdev->features = features;
+	if (vendor_id == 0x046D && product_id == 0x08B5)
+	{
+		/* Logitech QuickCam Orbit
+	           The ranges have been determined experimentally; they may differ from cam to cam.
+	           Also, the exact ranges left-right and up-down are different for my cam
+	          */
+		pdev->angle_range.pan_min  = -7000;
+		pdev->angle_range.pan_max  =  7000;
+		pdev->angle_range.tilt_min = -3000;
+		pdev->angle_range.tilt_max =  2500;
+		pdev->angle_range.zoom_min = -1;
+		pdev->angle_range.zoom_max = -1;
+	}
 
 	init_MUTEX(&pdev->modlock);
 	pdev->ptrlock = SPIN_LOCK_UNLOCKED;
@@ -1791,7 +1834,7 @@ static int usb_pwc_probe(struct usb_inte
 	strcpy(pdev->vdev.name, name);
 	pdev->vdev.owner = THIS_MODULE;
 	pdev->vdev.priv = pdev;
-
+	
 	pdev->release = udev->descriptor.bcdDevice;
 	Trace(TRACE_PROBE, "Release: %04x\n", pdev->release);
 
@@ -1809,6 +1852,7 @@ static int usb_pwc_probe(struct usb_inte
 		}
 	}
 
+	pdev->vdev.release = pwc_video_release;
 	i = video_register_device(&pdev->vdev, VFL_TYPE_GRABBER, video_nr);
 	if (i < 0) {
 		Err("Failed to register as video device (%d).\n", i);
@@ -1818,6 +1862,7 @@ static int usb_pwc_probe(struct usb_inte
 	else {
 		Info("Registered as /dev/video%d.\n", pdev->vdev.minor & 0x3F);
 	}
+
 	/* occupy slot */
 	if (hint < MAX_DEV_HINTS) 
 		device_hint[hint].pdev = pdev;
diff -purN linux-2.5/drivers/usb/media/pwc-ioctl.h usb-2.5/drivers/usb/media/pwc-ioctl.h
--- linux-2.5/drivers/usb/media/pwc-ioctl.h	2003-07-26 00:23:27.000000000 +0000
+++ usb-2.5/drivers/usb/media/pwc-ioctl.h	2003-10-17 21:01:04.000000000 +0000
@@ -112,6 +112,43 @@ struct pwc_imagesize
 	int height;
 };
 
+/* Defines and structures for Motorized Pan & Tilt */
+#define PWC_MPT_PAN		0x01
+#define PWC_MPT_TILT		0x02
+#define PWC_MPT_TIMEOUT		0x04 /* for status */
+
+/* Set angles; when absolute = 1, the angle is absolute and the 
+   driver calculates the relative offset for you. This can only
+   be used with VIDIOCPWCSANGLE; VIDIOCPWCGANGLE always returns
+   absolute angles.
+ */   
+struct pwc_mpt_angles
+{
+	int absolute;		/* write-only */
+	int pan;		/* degrees * 100 */
+	int tilt;		/* degress * 100 */
+	int zoom;		/* N/A, set to -1 */
+};
+
+/* Range of angles of the camera, both horizontally and vertically.
+   The zoom is not used, maybe in the future...
+
+ */
+struct pwc_mpt_range
+{
+	int pan_min, pan_max;		/* degrees * 100 */
+	int tilt_min, tilt_max;
+	int zoom_min, zoom_max;		/* -1, -1 */
+};
+
+struct pwc_mpt_status
+{
+	int status;
+	int time_pan;
+	int time_tilt;
+};
+
+
  /* Restore user settings */
 #define VIDIOCPWCRUSER		_IO('v', 192)
  /* Save user settings */
@@ -181,5 +218,12 @@ struct pwc_imagesize
 
  /* Real image size as used by the camera; tells you whether or not there's a gray border around the image */
 #define VIDIOCPWCGREALSIZE	_IOR('v', 210, struct pwc_imagesize)
+
+ /* Motorized pan & tilt functions */ 
+#define VIDIOCPWCMPTRESET	_IOW('v', 211, int)
+#define VIDIOCPWCMPTGRANGE	_IOR('v', 211, struct pwc_mpt_range)
+#define VIDIOCPWCMPTSANGLE	_IOW('v', 212, struct pwc_mpt_angles)
+#define VIDIOCPWCMPTGANGLE	_IOR('v', 212, struct pwc_mpt_angles)
+#define VIDIOCPWCMPTSTATUS	_IOR('v', 213, struct pwc_mpt_status)
  
 #endif
diff -purN linux-2.5/drivers/usb/media/pwc-misc.c usb-2.5/drivers/usb/media/pwc-misc.c
--- linux-2.5/drivers/usb/media/pwc-misc.c	2003-07-26 01:52:08.000000000 +0000
+++ usb-2.5/drivers/usb/media/pwc-misc.c	2003-09-24 22:08:28.000000000 +0000
@@ -52,7 +52,7 @@ int pwc_decode_size(struct pwc_device *p
 	return find;
 }
 
-/* initialize variables depending on type */
+/* initialize variables depending on type and decompressor*/
 void pwc_construct(struct pwc_device *pdev)
 {
 	switch(pdev->type) {
@@ -73,9 +73,17 @@ void pwc_construct(struct pwc_device *pd
 	case 690:
 		pdev->view_min.x = 128;
 		pdev->view_min.y =  96;
-		pdev->view_max.x = 640;
-		pdev->view_max.y = 480;
-		pdev->image_mask = 1 << PSZ_SQCIF | 1 << PSZ_QSIF | 1 << PSZ_QCIF | 1 << PSZ_SIF | 1 << PSZ_CIF | 1 << PSZ_VGA;
+		/* Anthill bug #38: PWC always reports max size, even without PWCX */
+		if (pdev->decompressor != NULL) {
+			pdev->view_max.x = 640;
+			pdev->view_max.y = 480;
+			pdev->image_mask = 1 << PSZ_SQCIF | 1 << PSZ_QSIF | 1 << PSZ_QCIF | 1 << PSZ_SIF | 1 << PSZ_CIF | 1 << PSZ_VGA;
+		}
+		else {
+			pdev->view_max.x = 352;
+			pdev->view_max.y = 288;
+			pdev->image_mask = 1 << PSZ_SQCIF | 1 << PSZ_QSIF | 1 << PSZ_QCIF | 1 << PSZ_SIF | 1 << PSZ_CIF;
+		}
 		pdev->vcinterface = 3;
 		pdev->vendpoint = 4;
 		pdev->frame_header_size = 0;
@@ -87,9 +95,18 @@ void pwc_construct(struct pwc_device *pd
 	case 750:
 		pdev->view_min.x = 160;
 		pdev->view_min.y = 120;
-		pdev->view_max.x = 640;
-		pdev->view_max.y = 480;
-		pdev->image_mask = 1 << PSZ_QSIF | 1 << PSZ_SIF | 1 << PSZ_VGA;
+		/* Anthill bug #38: PWC always reports max size, even without PWCX */
+		if (pdev->decompressor != NULL) {
+			pdev->view_max.x = 640;
+			pdev->view_max.y = 480;
+			pdev->image_mask = 1 << PSZ_QSIF | 1 << PSZ_SIF | 1 << PSZ_VGA;
+		}
+		else {
+			/* Tell CIF, even though SIF really is the maximum, but some tools really need CIF */
+			pdev->view_max.x = 352;
+			pdev->view_max.y = 288;
+			pdev->image_mask = 1 << PSZ_QSIF | 1 << PSZ_SIF;
+		}
 		pdev->vcinterface = 3;
 		pdev->vendpoint = 5;
 		pdev->frame_header_size = TOUCAM_HEADER_SIZE;
diff -purN linux-2.5/drivers/usb/media/pwc.h usb-2.5/drivers/usb/media/pwc.h
--- linux-2.5/drivers/usb/media/pwc.h	2003-07-27 01:51:46.000000000 +0000
+++ usb-2.5/drivers/usb/media/pwc.h	2003-10-17 23:11:54.000000000 +0000
@@ -18,17 +18,21 @@
 #ifndef PWC_H
 #define PWC_H
 
+#include <linux/version.h>
+
 #include <linux/config.h>
 #include <linux/module.h>
-#include <linux/usb.h>
+#include <linux/smp_lock.h>
 #include <linux/spinlock.h>
+#include <linux/usb.h>
 #include <linux/videodev.h>
 #include <linux/wait.h>
-#include <linux/smp_lock.h>
 
 #include <asm/semaphore.h>
 #include <asm/errno.h>
 
+#include "pwc-ioctl.h"
+
 /* Defines and structures for the Philips webcam */
 /* Used for checking memory corruption/pointer validation */
 #define PWC_MAGIC 0x89DC10ABUL
@@ -58,10 +62,12 @@
 #define TOUCAM_HEADER_SIZE		8
 #define TOUCAM_TRAILER_SIZE		4
 
+#define FEATURE_MOTOR_PANTILT		0x0001
+
 /* Version block */
 #define PWC_MAJOR	8
-#define PWC_MINOR	11
-#define PWC_VERSION 	"8.11"
+#define PWC_MINOR	12
+#define PWC_VERSION 	"8.12"
 #define PWC_NAME 	"pwc"
 
 /* Turn certain features on/off */
@@ -119,8 +125,9 @@ struct pwc_device
    /* Pointer to our usb_device */
    struct usb_device *udev;
    
-   int type;                    /* type of cam (645, 646, 675, 680, 690) */
+   int type;                    /* type of cam (645, 646, 675, 680, 690, 720, 730, 740, 750) */
    int release;			/* release number */
+   int features;		/* feature bits */
    int error_status;		/* set when something goes wrong with the cam (unplugged, USB errors) */
    int usb_init;		/* set when the cam has been initialized over USB */
 
@@ -194,6 +201,11 @@ struct pwc_device
    struct semaphore modlock;		/* to prevent races in video_open(), etc */
    spinlock_t ptrlock;			/* for manipulating the buffer pointers */
 
+   /*** motorized pan/tilt feature */
+   struct pwc_mpt_range angle_range;
+   int pan_angle;			/* in degrees * 100 */
+   int tilt_angle;			/* absolute angle; 0,0 is home position */
+
    /*** Misc. data ***/
    wait_queue_head_t frameq;		/* When waiting for a frame to finish... */
 #if PWC_INT_PIPE
diff -purN linux-2.5/drivers/usb/media/w9968cf.c usb-2.5/drivers/usb/media/w9968cf.c
--- linux-2.5/drivers/usb/media/w9968cf.c	1970-01-01 00:00:00.000000000 +0000
+++ usb-2.5/drivers/usb/media/w9968cf.c	2003-10-04 10:02:10.000000000 +0000
@@ -0,0 +1,3712 @@
+/***************************************************************************
+ * Video4Linux driver for W996[87]CF JPEG USB Dual Mode Camera Chip.       *
+ *                                                                         *
+ * Copyright (C) 2002 2003 by Luca Risolia <luca_ing@libero.it>            *
+ *                                                                         *
+ * - Memory management code from bttv driver by Ralph Metzler,             *
+ *   Marcus Metzler and Gerd Knorr.                                        *
+ * - I2C interface to kernel, high-level CMOS sensor control routines and  *
+ *   some symbolic names from OV511 driver by Mark W. McClelland.          *
+ * - Low-level I2C fast write function by Piotr Czerczak.                  *
+ * - Low-level I2C read function by Frédéric Jouault.                      *
+ *                                                                         *
+ * This program is free software; you can redistribute it and/or modify    *
+ * it under the terms of the GNU General Public License as published by    *
+ * the Free Software Foundation; either version 2 of the License, or       *
+ * (at your option) any later version.                                     *
+ *                                                                         *
+ * This program is distributed in the hope that it will be useful,         *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of          *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *
+ * GNU General Public License for more details.                            *
+ *                                                                         *
+ * You should have received a copy of the GNU General Public License       *
+ * along with this program; if not, write to the Free Software             *
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.               *
+ ***************************************************************************/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/vmalloc.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/ioctl.h>
+#include <linux/delay.h>
+#include <asm/page.h>
+#include <asm/uaccess.h>
+
+#include "w9968cf.h"
+#include "w9968cf_decoder.h"
+
+
+
+/****************************************************************************
+ * Modules paramaters                                                       *
+ ****************************************************************************/
+
+static u8 vppmod_load = W9968CF_VPPMOD_LOAD;
+static u8 simcams = W9968CF_SIMCAMS;
+static int video_nr[]={[0 ... W9968CF_MAX_DEVICES-1] = -1}; /* -1=first free */
+static u16 packet_size[] = {[0 ... W9968CF_MAX_DEVICES-1]=W9968CF_PACKET_SIZE};
+static u8 max_buffers[] = {[0 ... W9968CF_MAX_DEVICES-1] = W9968CF_BUFFERS};
+static u8 double_buffer[] = {[0 ... W9968CF_MAX_DEVICES-1] = 
+                             W9968CF_DOUBLE_BUFFER};
+static u8 clamping[] = {[0 ... W9968CF_MAX_DEVICES-1] = W9968CF_CLAMPING};
+static u8 filter_type[]= {[0 ... W9968CF_MAX_DEVICES-1] = W9968CF_FILTER_TYPE};
+static u8 largeview[]= {[0 ... W9968CF_MAX_DEVICES-1] = W9968CF_LARGEVIEW};
+static u8 decompression[] = {[0 ... W9968CF_MAX_DEVICES-1] = 
+                             W9968CF_DECOMPRESSION};
+static u8 upscaling[]= {[0 ... W9968CF_MAX_DEVICES-1] = W9968CF_UPSCALING};
+static u8 force_palette[] = {[0 ... W9968CF_MAX_DEVICES-1] = 0};
+static u8 force_rgb[] = {[0 ... W9968CF_MAX_DEVICES-1] = W9968CF_FORCE_RGB};
+static u8 autobright[] = {[0 ... W9968CF_MAX_DEVICES-1] = W9968CF_AUTOBRIGHT};
+static u8 autoexp[] = {[0 ... W9968CF_MAX_DEVICES-1] = W9968CF_AUTOEXP};
+static u8 lightfreq[] = {[0 ... W9968CF_MAX_DEVICES-1] = W9968CF_LIGHTFREQ};
+static u8 bandingfilter[] = {[0 ... W9968CF_MAX_DEVICES-1]=
+                             W9968CF_BANDINGFILTER};
+static int clockdiv[] = {[0 ... W9968CF_MAX_DEVICES-1] = W9968CF_CLOCKDIV};
+static u8 backlight[] = {[0 ... W9968CF_MAX_DEVICES-1] = W9968CF_BACKLIGHT};
+static u8 mirror[] = {[0 ... W9968CF_MAX_DEVICES-1] = W9968CF_MIRROR};
+static u8 sensor_mono[] = {[0 ... W9968CF_MAX_DEVICES-1]=W9968CF_SENSOR_MONO};
+static u16 brightness[] = {[0 ... W9968CF_MAX_DEVICES-1] = W9968CF_BRIGHTNESS};
+static u16 hue[] = {[0 ... W9968CF_MAX_DEVICES-1] = W9968CF_HUE};
+static u16 colour[] = {[0 ... W9968CF_MAX_DEVICES-1] = W9968CF_COLOUR};
+static u16 contrast[] = {[0 ... W9968CF_MAX_DEVICES-1] = W9968CF_CONTRAST};
+static u16 whiteness[] = {[0 ... W9968CF_MAX_DEVICES-1] = W9968CF_WHITENESS};
+#ifdef W9968CF_DEBUG
+static u8 debug = W9968CF_DEBUG_LEVEL;
+static u8 specific_debug = W9968CF_SPECIFIC_DEBUG;
+#endif
+
+MODULE_AUTHOR("Luca Risolia <luca_ing@libero.it>");
+
+MODULE_DESCRIPTION("Video4Linux driver for "
+                   "W996[87]CF JPEG USB Dual Mode Camera Chip");
+
+MODULE_SUPPORTED_DEVICE("Video");
+
+MODULE_LICENSE("GPL");
+
+MODULE_PARM(vppmod_load, "i");
+MODULE_PARM(simcams, "i");
+MODULE_PARM(video_nr, "0-" __MODULE_STRING(W9968CF_MAX_DEVICES) "i");
+MODULE_PARM(packet_size, "0-" __MODULE_STRING(W9968CF_MAX_DEVICES) "i");
+MODULE_PARM(max_buffers, "0-" __MODULE_STRING(W9968CF_MAX_DEVICES) "i");
+MODULE_PARM(double_buffer, "0-" __MODULE_STRING(W9968CF_MAX_DEVICES) "i");
+MODULE_PARM(clamping, "0-" __MODULE_STRING(W9968CF_MAX_DEVICES) "i");
+MODULE_PARM(filter_type, "0-" __MODULE_STRING(W9968CF_MAX_DEVICES) "i");
+MODULE_PARM(largeview, "0-" __MODULE_STRING(W9968CF_MAX_DEVICES) "i");
+MODULE_PARM(decompression, "0-" __MODULE_STRING(W9968CF_MAX_DEVICES) "i");
+MODULE_PARM(upscaling, "0-" __MODULE_STRING(W9968CF_MAX_DEVICES) "i");
+MODULE_PARM(force_palette, "0-" __MODULE_STRING(W9968CF_MAX_DEVICES) "i");
+MODULE_PARM(force_rgb, "0-" __MODULE_STRING(W9968CF_MAX_DEVICES) "i");
+MODULE_PARM(autobright, "0-" __MODULE_STRING(W9968CF_MAX_DEVICES) "l");
+MODULE_PARM(autoexp, "0-" __MODULE_STRING(W9968CF_MAX_DEVICES) "l");
+MODULE_PARM(lightfreq, "0-" __MODULE_STRING(W9968CF_MAX_DEVICES) "l");
+MODULE_PARM(bandingfilter, "0-" __MODULE_STRING(W9968CF_MAX_DEVICES) "l");
+MODULE_PARM(clockdiv, "0-" __MODULE_STRING(W9968CF_MAX_DEVICES) "l");
+MODULE_PARM(backlight, "0-" __MODULE_STRING(W9968CF_MAX_DEVICES) "l");
+MODULE_PARM(mirror, "0-" __MODULE_STRING(W9968CF_MAX_DEVICES) "l");
+MODULE_PARM(sensor_mono, "0-" __MODULE_STRING(W9968CF_MAX_DEVICES) "l");
+MODULE_PARM(brightness, "0-" __MODULE_STRING(W9968CF_MAX_DEVICES) "l");
+MODULE_PARM(hue, "0-" __MODULE_STRING(W9968CF_MAX_DEVICES) "l");
+MODULE_PARM(colour, "0-" __MODULE_STRING(W9968CF_MAX_DEVICES) "l");
+MODULE_PARM(contrast, "0-" __MODULE_STRING(W9968CF_MAX_DEVICES) "l");
+MODULE_PARM(whiteness, "0-" __MODULE_STRING(W9968CF_MAX_DEVICES) "l");
+#ifdef W9968CF_DEBUG
+MODULE_PARM(debug, "i");
+MODULE_PARM(specific_debug, "i");
+#endif
+
+MODULE_PARM_DESC(vppmod_load, 
+                 "\n<0|1> Automatic 'w9968cf-vpp' module loading."
+                 "\n0 disable, 1 enable."
+                 "\nIf enabled, every time an application attempts to open a"
+                 "\ncamera, 'insmod' searches for the video post-processing"
+                 "\nmodule in the system and loads it automatically (if"
+                 "\npresent). The 'w9968cf-vpp' module adds extra image"
+                 "\nmanipulation functions to the 'w9968cf' module, like"
+                 "\nsoftware up-scaling,colour conversions and video decoding."
+                 "\nDefault value is "__MODULE_STRING(W9968CF_VPPMOD_LOAD)"."
+                 "\n");
+MODULE_PARM_DESC(simcams, 
+                 "\n<n> Number of cameras allowed to stream simultaneously."
+                 "\nn may vary from 0 to "
+                 __MODULE_STRING(W9968CF_MAX_DEVICES)"."
+                 "\nDefault value is "__MODULE_STRING(W9968CF_SIMCAMS)"."
+                 "\n");
+MODULE_PARM_DESC(video_nr,
+                 "\n<-1|n[,...]> Specify V4L minor mode number."
+                 "\n -1 = use next available (default)"
+                 "\n  n = use minor number n (integer >= 0)"
+                 "\nYou can specify " __MODULE_STRING(W9968CF_MAX_DEVICES)
+                 " cameras this way."
+                 "\nFor example:"
+                 "\nvideo_nr=-1,2,-1 would assign minor number 2 to"
+                 "\nthe second camera and use auto for the first"
+                 "\none and for every other camera."
+                 "\n");
+MODULE_PARM_DESC(packet_size,
+                 "\n<n[,...]> Specify the maximum data payload"
+                 "\nsize in bytes for alternate settings, for each device."
+                 "\nn is scaled between 63 and 1023 "
+                 "(default is "__MODULE_STRING(W9968CF_PACKET_SIZE)")."
+                 "\n");
+MODULE_PARM_DESC(max_buffers,
+                 "\n<n[,...]> Only for advanced users."
+                 "\nSpecify the maximum number of video frame buffers"
+                 "\nto allocate for each device, from 2 to "
+                 __MODULE_STRING(W9968CF_MAX_BUFFERS)
+                 ". (default is "__MODULE_STRING(W9968CF_BUFFERS)")."
+                 "\n");
+MODULE_PARM_DESC(double_buffer, 
+                 "\n<0|1[,...]> "
+                 "Hardware double buffering: 0 disabled, 1 enabled."
+                 "\nIt should be enabled if you want smooth video output: if"
+                 "\nyou obtain out of sync. video, disable it at all, or try"
+                 "\nto decrease the 'clockdiv' module paramater value."
+                 "\nDefault value is "__MODULE_STRING(W9968CF_DOUBLE_BUFFER)
+                 " for every device."
+                 "\n");
+MODULE_PARM_DESC(clamping, 
+                 "\n<0|1[,...]> Video data clamping: 0 disabled, 1 enabled."
+                 "\nDefault value is "__MODULE_STRING(W9968CF_CLAMPING)
+                 " for every device."
+                 "\n");
+MODULE_PARM_DESC(filter_type, 
+                 "\n<0|1|2[,...]> Video filter type."
+                 "\n0 none, 1 (1-2-1) 3-tap filter, "
+                 "2 (2-3-6-3-2) 5-tap filter."
+                 "\nDefault value is "__MODULE_STRING(W9968CF_FILTER_TYPE)
+                 " for every device."
+                 "\nThe filter is used to reduce noise and aliasing artifacts"
+                 "\nproduced by the CCD or CMOS sensor, and the scaling"
+                 " process."
+                 "\n");
+MODULE_PARM_DESC(largeview, 
+                 "\n<0|1[,...]> Large view: 0 disabled, 1 enabled."
+                 "\nDefault value is "__MODULE_STRING(W9968CF_LARGEVIEW)
+                 " for every device."
+                 "\n");
+MODULE_PARM_DESC(upscaling, 
+                 "\n<0|1[,...]> Software scaling (for non-compressed video):"
+                 "\n0 disabled, 1 enabled."
+                 "\nDisable it if you have a slow CPU or you don't have"
+                 " enough memory."
+                 "\nDefault value is "__MODULE_STRING(W9968CF_UPSCALING)
+                 " for every device."
+                 "\nIf 'w9968cf-vpp' is not loaded, this paramater is"
+                 " set to 0.");
+MODULE_PARM_DESC(decompression,
+                 "\n<0|1|2[,...]> Software video decompression:"
+                 "\n- 0 disables decompression (doesn't allow formats needing"
+                 " decompression)"
+                 "\n- 1 forces decompression (allows formats needing"
+                 " decompression only);"
+                 "\n- 2 allows any permitted formats."
+                 "\nFormats supporting compressed video are YUV422P and"
+                 " YUV420P/YUV420 "
+                 "\nin any resolutions where both width and height are "
+                 "a multiple of 16."
+                 "\nDefault value is "__MODULE_STRING(W9968CF_DECOMPRESSION)
+                 " for every device."
+                 "\nIf 'w9968cf-vpp' is not loaded, forcing decompression is "
+                 "\nnot allowed; in this case this paramater is set to 2.");
+MODULE_PARM_DESC(force_palette,
+                 "\n<0"
+                 "|" __MODULE_STRING(VIDEO_PALETTE_UYVY)
+                 "|" __MODULE_STRING(VIDEO_PALETTE_YUV420)
+                 "|" __MODULE_STRING(VIDEO_PALETTE_YUV422P)
+                 "|" __MODULE_STRING(VIDEO_PALETTE_YUV420P)
+                 "|" __MODULE_STRING(VIDEO_PALETTE_YUYV)
+                 "|" __MODULE_STRING(VIDEO_PALETTE_YUV422)
+                 "|" __MODULE_STRING(VIDEO_PALETTE_GREY)
+                 "|" __MODULE_STRING(VIDEO_PALETTE_RGB555)
+                 "|" __MODULE_STRING(VIDEO_PALETTE_RGB565)
+                 "|" __MODULE_STRING(VIDEO_PALETTE_RGB24)
+                 "|" __MODULE_STRING(VIDEO_PALETTE_RGB32)
+                 "[,...]>"
+                 " Force picture palette."
+                 "\nIn order:"
+                 "\n- 0 allows any of the following formats:"
+                 "\n- UYVY    16 bpp - Original video, compression disabled"
+                 "\n- YUV420  12 bpp - Original video, compression enabled"
+                 "\n- YUV422P 16 bpp - Original video, compression enabled"
+                 "\n- YUV420P 12 bpp - Original video, compression enabled"
+                 "\n- YUVY    16 bpp - Software conversion from UYVY"
+                 "\n- YUV422  16 bpp - Software conversion from UYVY"
+                 "\n- GREY     8 bpp - Software conversion from UYVY"
+                 "\n- RGB555  16 bpp - Software conversion from UYVY"
+                 "\n- RGB565  16 bpp - Software conversion from UYVY"
+                 "\n- RGB24   24 bpp - Software conversion from UYVY"
+                 "\n- RGB32   32 bpp - Software conversion from UYVY"
+                 "\nWhen not 0, this paramater will override 'decompression'."
+                 "\nDefault value is 0 for every device."
+                 "\nInitial palette is "
+                 __MODULE_STRING(W9968CF_PALETTE_DECOMP_ON)"."
+                 "\nIf 'w9968cf-vpp' is not loaded, this paramater is"
+                 " set to 9 (UYVY).");
+MODULE_PARM_DESC(force_rgb, 
+                 "\n<0|1[,...]> Read RGB video data instead of BGR:"
+                 "\n 1 = use RGB component ordering."
+                 "\n 0 = use BGR component ordering."
+                 "\nThis parameter has effect when using RGBX palettes only."
+                 "\nDefault value is "__MODULE_STRING(W9968CF_FORCE_RGB)
+                 " for every device."
+                 "\n");
+MODULE_PARM_DESC(autobright,
+                 "\n<0|1[,...]> CMOS sensor automatically changes brightness:"
+                 "\n 0 = no, 1 = yes"
+                 "\nDefault value is "__MODULE_STRING(W9968CF_AUTOBRIGHT)
+                 " for every device."
+                 "\n");
+MODULE_PARM_DESC(autoexp,
+                 "\n<0|1[,...]> CMOS sensor automatically changes exposure:"
+                 "\n 0 = no, 1 = yes"
+                 "\nDefault value is "__MODULE_STRING(W9968CF_AUTOEXP)
+                 " for every device."
+                 "\n");
+MODULE_PARM_DESC(lightfreq,
+                 "\n<50|60[,...]> Light frequency in Hz:"
+                 "\n 50 for European and Asian lighting,"
+                 " 60 for American lighting."
+                 "\nDefault value is "__MODULE_STRING(W9968CF_LIGHTFREQ)
+                 " for every device."
+                 "\n");
+MODULE_PARM_DESC(bandingfilter,
+                 "\n<0|1[,...]> Banding filter to reduce effects of"
+                 " fluorescent lighting:"
+                 "\n 0 disabled, 1 enabled."
+                 "\nThis filter tries to reduce the pattern of horizontal"
+                 "\nlight/dark bands caused by some (usually fluorescent)"
+                 " lighting."
+                 "\nDefault value is "__MODULE_STRING(W9968CF_BANDINGFILTER)
+                 " for every device."
+                 "\n");
+MODULE_PARM_DESC(clockdiv,
+                 "\n<-1|n[,...]> "
+                 "Force pixel clock divisor to a specific value (for experts):"
+                 "\n  n may vary from 0 to 127."
+                 "\n -1 for automatic value."
+                 "\nSee also the 'double_buffer' module paramater."
+                 "\nDefault value is "__MODULE_STRING(W9968CF_CLOCKDIV)
+                 " for every device."
+                 "\n");
+MODULE_PARM_DESC(backlight,
+                 "\n<0|1[,...]> Objects are lit from behind:"
+                 "\n 0 = no, 1 = yes"
+                 "\nDefault value is "__MODULE_STRING(W9968CF_BACKLIGHT)
+                 " for every device."
+                 "\n");
+MODULE_PARM_DESC(mirror,
+                 "\n<0|1[,...]> Reverse image horizontally:"
+                 "\n 0 = no, 1 = yes"
+                 "\nDefault value is "__MODULE_STRING(W9968CF_MIRROR)
+                 " for every device."
+                 "\n");
+MODULE_PARM_DESC(sensor_mono,
+                 "\n<0|1[,...]> The OV CMOS sensor is monochrome:"
+                 "\n 0 = no, 1 = yes"
+                 "\nDefault value is "__MODULE_STRING(W9968CF_SENSOR_MONO)
+                 " for every device."
+                 "\n");
+MODULE_PARM_DESC(brightness, 
+                 "\n<n[,...]> Set picture brightness (0-65535)."
+                 "\nDefault value is "__MODULE_STRING(W9968CF_BRIGHTNESS)
+                 " for every device."
+                 "\nThis parameter has no effect if 'autobright' is enabled."
+                 "\n");
+MODULE_PARM_DESC(hue, 
+                 "\n<n[,...]> Set picture hue (0-65535)."
+                 "\nDefault value is "__MODULE_STRING(W9968CF_HUE)
+                 " for every device."
+                 "\n");
+MODULE_PARM_DESC(colour, 
+                 "\n<n[,...]> Set picture saturation (0-65535)."
+                 "\nDefault value is "__MODULE_STRING(W9968CF_COLOUR)
+                 " for every device."
+                 "\n");
+MODULE_PARM_DESC(contrast, 
+                 "\n<n[,...]> Set picture contrast (0-65535)."
+                 "\nDefault value is "__MODULE_STRING(W9968CF_CONTRAST)
+                 " for every device."
+                 "\n");
+MODULE_PARM_DESC(whiteness, 
+                 "\n<n[,...]> Set picture whiteness (0-65535)."
+                 "\nDefault value is "__MODULE_STRING(W9968CF_WHITENESS)
+                 " for every device."
+                 "\n");
+#ifdef W9968CF_DEBUG
+MODULE_PARM_DESC(debug,
+                 "\n<n> Debugging information level, from 0 to 6:"
+                 "\n0 = none (be cautious)"
+                 "\n1 = critical errors"
+                 "\n2 = significant informations"
+                 "\n3 = configuration or general messages"
+                 "\n4 = warnings"
+                 "\n5 = called functions"
+                 "\n6 = function internals"
+                 "\nLevel 5 and 6 are useful for testing only, when just "
+                 "one device is used."
+                 "\nDefault value is "__MODULE_STRING(W9968CF_DEBUG_LEVEL)"."
+                 "\n");
+MODULE_PARM_DESC(specific_debug,
+                 "\n<0|1> Enable or disable specific debugging messages:"
+                 "\n0 = print messages concerning every level"
+                 " <= 'debug' level."
+                 "\n1 = print messages concerning the level"
+                 " indicated by 'debug'."
+                 "\nDefault value is "
+                 __MODULE_STRING(W9968CF_SPECIFIC_DEBUG)"."
+                 "\n");
+#endif /* W9968CF_DEBUG */
+
+
+
+/****************************************************************************
+ * Some prototypes                                                          *
+ ****************************************************************************/
+
+/* Video4linux interface */
+static struct file_operations w9968cf_fops;
+static int w9968cf_open(struct inode*, struct file*);
+static int w9968cf_release(struct inode*, struct file*);
+static ssize_t w9968cf_read(struct file*, char*, size_t, loff_t*);
+static int w9968cf_mmap(struct file*, struct vm_area_struct*);
+static int w9968cf_ioctl(struct inode*, struct file*,
+                         unsigned int, unsigned long);
+static int w9968cf_do_ioctl(struct w9968cf_device*, unsigned int, void*);
+
+/* USB-specific */
+static void w9968cf_urb_complete(struct urb *urb, struct pt_regs *regs);
+static int w9968cf_start_transfer(struct w9968cf_device*);
+static int w9968cf_stop_transfer(struct w9968cf_device*);
+static int w9968cf_write_reg(struct w9968cf_device*, u16 value, u16 index);
+static int w9968cf_read_reg(struct w9968cf_device*, u16 index);
+static int w9968cf_write_fsb(struct w9968cf_device*, u16* data);
+static int w9968cf_write_sb(struct w9968cf_device*, u16 value);
+static int w9968cf_read_sb(struct w9968cf_device*);
+static int w9968cf_upload_quantizationtables(struct w9968cf_device*);
+
+/* Low-level I2C (SMBus) I/O */
+static int w9968cf_smbus_start(struct w9968cf_device*);
+static int w9968cf_smbus_stop(struct w9968cf_device*);
+static int w9968cf_smbus_write_byte(struct w9968cf_device*, u8 v);
+static int w9968cf_smbus_read_byte(struct w9968cf_device*, u8* v);
+static int w9968cf_smbus_write_ack(struct w9968cf_device*);
+static int w9968cf_smbus_read_ack(struct w9968cf_device*);
+static int w9968cf_i2c_adap_read_byte(struct w9968cf_device* cam,
+                                      u16 address, u8* value);
+static int w9968cf_i2c_adap_read_byte_data(struct w9968cf_device*, u16 address, 
+                                           u8 subaddress, u8* value);
+static int w9968cf_i2c_adap_write_byte(struct w9968cf_device*,
+                                       u16 address, u8 subaddress);
+static int w9968cf_i2c_adap_fastwrite_byte_data(struct w9968cf_device*,
+                                                u16 address, u8 subaddress,
+                                                u8 value);
+
+/* I2C interface to kernel */
+static int w9968cf_i2c_init(struct w9968cf_device*);
+static int w9968cf_i2c_smbus_xfer(struct i2c_adapter*, u16 addr, 
+                                  unsigned short flags, char read_write, 
+                                  u8 command, int size, union i2c_smbus_data*);
+static u32 w9968cf_i2c_func(struct i2c_adapter*);
+static int w9968cf_i2c_attach_inform(struct i2c_client*);
+static int w9968cf_i2c_detach_inform(struct i2c_client*);
+static int w9968cf_i2c_control(struct i2c_adapter*, unsigned int cmd,
+                               unsigned long arg);
+
+/* Memory management */
+static inline unsigned long kvirt_to_pa(unsigned long adr);
+static void* rvmalloc(unsigned long size);
+static void rvfree(void *mem, unsigned long size);
+static void w9968cf_deallocate_memory(struct w9968cf_device*);
+static int  w9968cf_allocate_memory(struct w9968cf_device*);
+static inline unsigned long w9968cf_get_max_bufsize(struct w9968cf_device*);
+
+/* High-level CMOS sensor control functions */
+static int w9968cf_sensor_set_control(struct w9968cf_device*,int cid,int val);
+static int w9968cf_sensor_get_control(struct w9968cf_device*,int cid,int *val);
+static inline int w9968cf_sensor_cmd(struct w9968cf_device*, 
+                                     unsigned int cmd, void *arg);
+static void w9968cf_sensor_configure(struct w9968cf_device*);
+static int w9968cf_sensor_change_settings(struct w9968cf_device*);
+static int w9968cf_sensor_get_picture(struct w9968cf_device*, 
+                                      struct video_picture*);
+static int w9968cf_sensor_set_picture(struct w9968cf_device*, 
+                                      struct video_picture pict);
+
+/* Other helper functions */
+static void w9968cf_configure_camera(struct w9968cf_device*,struct usb_device*,
+                                     enum w9968cf_model_id, 
+                                     const unsigned short dev_nr);
+static int w9968cf_turn_on_led(struct w9968cf_device*);
+static int w9968cf_init_chip(struct w9968cf_device*);
+static int w9968cf_set_picture(struct w9968cf_device*, struct video_picture);
+static int w9968cf_set_window(struct w9968cf_device*, struct video_window);
+static inline u16 w9968cf_valid_palette(u16 palette);
+static inline u16 w9968cf_valid_depth(u16 palette);
+static inline u8 w9968cf_need_decompression(u16 palette);
+static int w9968cf_postprocess_frame(struct w9968cf_device*, 
+                                     struct w9968cf_frame_t*);
+static int w9968cf_adjust_window_size(struct w9968cf_device*, u16* w, u16* h);
+static void w9968cf_init_framelist(struct w9968cf_device*);
+static void w9968cf_push_frame(struct w9968cf_device*, u8 f_num);
+static void w9968cf_pop_frame(struct w9968cf_device*,struct w9968cf_frame_t**);
+static void w9968cf_release_resources(struct w9968cf_device*);
+
+/* Intermodule communication */
+static int w9968cf_vppmod_detect(void);
+static void w9968cf_vppmod_release(void);
+
+/* Pointers to registered video post-processing functions */
+static void (*w9968cf_vpp_init_decoder)(void);
+static int (*w9968cf_vpp_check_headers)(const unsigned char*,
+                                        const unsigned long);
+static int (*w9968cf_vpp_decode)(const char*, const unsigned, 
+                                 const unsigned, const unsigned, char*);
+static void (*w9968cf_vpp_swap_yuvbytes)(void*, unsigned long);
+static void (*w9968cf_vpp_uyvy_to_rgbx)(u8*, unsigned long, u8*, u16, u8);
+static void (*w9968cf_vpp_scale_up)(u8*, u8*, u16, u16, u16, u16, u16);
+
+
+
+/****************************************************************************
+ * Symbolic names                                                           *
+ ****************************************************************************/
+
+/* Used to represent a list of values and their respective symbolic names */
+struct w9968cf_symbolic_list {
+	const int num;
+	const char *name;
+};
+
+/*-------------------------------------------------------------------------- 
+  Returns the name of the matching element in the symbolic_list array. The
+  end of the list must be marked with an element that has a NULL name.
+  --------------------------------------------------------------------------*/
+static inline const char * 
+symbolic(struct w9968cf_symbolic_list list[], const int num)
+{
+	int i;
+
+	for (i = 0; list[i].name != NULL; i++)
+		if (list[i].num == num)
+			return (list[i].name);
+
+	return "Unknown";
+}
+
+static struct w9968cf_symbolic_list camlist[] = {
+	{ W9968CF_MOD_GENERIC, "W996[87]CF JPEG USB Dual Mode Camera" },
+	{ W9968CF_MOD_CLVBWGP, "Creative Labs Video Blaster WebCam Go Plus" },
+
+	/* Other cameras (having the same descriptors as Generic W996[87]CF) */
+	{ W9968CF_MOD_ADPA5R, "Aroma Digi Pen ADG-5000 Refurbished" },
+	{ W9986CF_MOD_AU, "AVerTV USB" },
+	{ W9968CF_MOD_CLVBWG, "Creative Labs Video Blaster WebCam Go" },
+	{ W9968CF_MOD_DLLDK, "Die Lebon LDC-D35A Digital Kamera" },
+	{ W9968CF_MOD_EEEMC, "Ezonics EZ-802 EZMega Cam" },
+	{ W9968CF_MOD_ODPVDMPC, "OPCOM Digi Pen VGA Dual Mode Pen Camera" },
+
+	{  -1, NULL }
+};
+
+static struct w9968cf_symbolic_list senlist[] = {
+	{ CC_OV76BE,   "OV76BE" },
+	{ CC_OV7610,   "OV7610" },
+	{ CC_OV7620,   "OV7620" },
+	{ CC_OV7620AE, "OV7620AE" },
+	{ CC_OV6620,   "OV6620" },
+	{ CC_OV6630,   "OV6630" },
+	{ CC_OV6630AE, "OV6630AE" },
+	{ CC_OV6630AF, "OV6630AF" },
+	{ -1, NULL }
+};
+
+/* Video4Linux1 palettes */
+static struct w9968cf_symbolic_list v4l1_plist[] = {
+	{ VIDEO_PALETTE_GREY,    "GREY" },
+	{ VIDEO_PALETTE_HI240,   "HI240" },
+	{ VIDEO_PALETTE_RGB565,  "RGB565" },
+	{ VIDEO_PALETTE_RGB24,   "RGB24" },
+	{ VIDEO_PALETTE_RGB32,   "RGB32" },
+	{ VIDEO_PALETTE_RGB555,  "RGB555" },
+	{ VIDEO_PALETTE_YUV422,  "YUV422" },
+	{ VIDEO_PALETTE_YUYV,    "YUYV" },
+	{ VIDEO_PALETTE_UYVY,    "UYVY" },
+	{ VIDEO_PALETTE_YUV420,  "YUV420" },
+	{ VIDEO_PALETTE_YUV411,  "YUV411" },
+	{ VIDEO_PALETTE_RAW,     "RAW" },
+	{ VIDEO_PALETTE_YUV422P, "YUV422P" },
+	{ VIDEO_PALETTE_YUV411P, "YUV411P" },
+	{ VIDEO_PALETTE_YUV420P, "YUV420P" },
+	{ VIDEO_PALETTE_YUV410P, "YUV410P" },
+	{ -1, NULL }
+};
+
+/* Decoder error codes: */
+static struct w9968cf_symbolic_list decoder_errlist[] = {
+	{ W9968CF_DEC_ERR_CORRUPTED_DATA, "Corrupted data" },
+	{ W9968CF_DEC_ERR_BUF_OVERFLOW,   "Buffer overflow" },
+	{ W9968CF_DEC_ERR_NO_SOI,         "SOI marker not found" },     
+	{ W9968CF_DEC_ERR_NO_SOF0,        "SOF0 marker not found" },
+	{ W9968CF_DEC_ERR_NO_SOS,         "SOS marker not found" },
+	{ W9968CF_DEC_ERR_NO_EOI,         "EOI marker not found" },
+	{ -1, NULL }
+};
+
+/* URB error codes: */
+static struct w9968cf_symbolic_list urb_errlist[] = {
+	{ -ENOMEM,    "No memory for allocation of internal structures" },
+	{ -ENOSPC,    "The host controller's bandwidth is already consumed" },
+	{ -ENOENT,    "URB was canceled by unlink_urb" },
+	{ -EXDEV,     "ISO transfer only partially completed" },
+	{ -EAGAIN,    "Too match scheduled for the future" },
+	{ -ENXIO,     "URB already queued" },
+	{ -EFBIG,     "Too much ISO frames requested" },
+	{ -ENOSR,     "Buffer error (overrun)" },
+	{ -EPIPE,     "Specified endpoint is stalled (device not responding)"},
+	{ -EOVERFLOW, "Babble (bad cable?)" },
+	{ -EPROTO,    "Bit-stuff error (bad cable?)" },
+	{ -EILSEQ,    "CRC/Timeout" },
+	{ -ETIMEDOUT, "NAK (device does not respond)" },
+	{ -1, NULL }
+};
+
+
+
+/****************************************************************************
+ * Memory management functions                                              *
+ ****************************************************************************/
+
+/* Shameless copy from bttv-driver.c */
+
+/* Here we want the physical address of the memory.
+   This is used when initializing the contents of the area. */
+static inline unsigned long kvirt_to_pa(unsigned long adr)
+{
+	unsigned long kva, ret;
+
+	kva = (unsigned long) page_address(vmalloc_to_page((void *)adr));
+	kva |= adr & (PAGE_SIZE-1); /* restore the offset */
+	ret = __pa(kva);
+	return ret;
+}
+
+
+static void* rvmalloc(unsigned long size)
+{
+	void* mem;
+	unsigned long adr;
+
+	size = PAGE_ALIGN(size);
+	mem = vmalloc_32(size);
+	if (!mem)
+		return NULL;
+
+	memset(mem, 0, size); /* Clear the ram out, no junk to the user */
+	adr = (unsigned long) mem;
+	while (size > 0) {
+		SetPageReserved(vmalloc_to_page((void *)adr));
+		adr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+
+	return mem;
+}
+
+
+static void rvfree(void* mem, unsigned long size)
+{
+	unsigned long adr;
+
+	if (!mem)
+		return;
+
+	adr = (unsigned long) mem;
+	while ((long) size > 0) {
+		ClearPageReserved(vmalloc_to_page((void *)adr));
+		adr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+	vfree(mem);
+}
+/* End of shameless copy */
+
+
+/*--------------------------------------------------------------------------
+  Return the maximum size (in bytes) of a frame buffer.
+  --------------------------------------------------------------------------*/
+static inline unsigned long w9968cf_get_max_bufsize(struct w9968cf_device* cam)
+{
+	u8 bpp = (w9968cf_vppmod_present) ? 4 : 2;
+	return (cam->upscaling) ? W9968CF_MAX_WIDTH*W9968CF_MAX_HEIGHT*bpp :
+	                          cam->maxwidth*cam->maxheight*bpp;
+}
+
+
+/*--------------------------------------------------------------------------
+  Deallocate previously allocated memory.
+  --------------------------------------------------------------------------*/
+static void w9968cf_deallocate_memory(struct w9968cf_device* cam)
+{
+	u8 i;
+
+	/* Free the isochronous transfer buffers */
+	for (i = 0; i < W9968CF_URBS; i++) {
+		kfree(cam->transfer_buffer[i]);
+		cam->transfer_buffer[i] = NULL;
+	}
+
+	/* Free temporary frame buffer */
+	if (cam->frame_tmp.buffer) {
+		rvfree(cam->frame_tmp.buffer, W9968CF_HW_BUF_SIZE);
+		cam->frame_tmp.buffer = NULL;
+	}
+
+	/* Free helper buffer */
+	if (cam->vpp_buffer) {
+		rvfree(cam->vpp_buffer, w9968cf_get_max_bufsize(cam));
+		cam->vpp_buffer = NULL;
+	}
+	
+	/* Free video frame buffers */
+	if (cam->frame[0].buffer) {
+		rvfree(cam->frame[0].buffer, 
+		       cam->nbuffers * w9968cf_get_max_bufsize(cam));
+		cam->frame[0].buffer = NULL;
+	}
+
+	cam->nbuffers = 0;
+
+	DBG(5, "Memory successfully deallocated.")
+}
+
+
+/*--------------------------------------------------------------------------
+  Allocate memory buffers for USB transfers and video frames.
+  This function is called by open() only.
+  Return 0 on success, a negative number otherwise.
+  --------------------------------------------------------------------------*/
+static int w9968cf_allocate_memory(struct w9968cf_device* cam)
+{
+	const unsigned long bufsize = w9968cf_get_max_bufsize(cam);
+	const u16 p_size = wMaxPacketSize[cam->altsetting-1];
+	void* buff = NULL;
+	u8 i;
+
+	/* NOTE: Deallocation is done elsewhere in case of error */
+
+	/* Allocate memory for the isochronous transfer buffers */
+	for (i = 0; i < W9968CF_URBS; i++) {
+		if (!(cam->transfer_buffer[i] =
+		      kmalloc(W9968CF_ISO_PACKETS*p_size, GFP_KERNEL))) {
+			DBG(1, "Couldn't allocate memory for the isochronous "
+			       "transfer buffers (%d bytes).", 
+			    p_size * W9968CF_ISO_PACKETS)
+			return -ENOMEM;
+		}
+		memset(cam->transfer_buffer[i], 0, W9968CF_ISO_PACKETS*p_size);
+	}
+
+	/* Allocate memory for the temporary frame buffer */
+	if (!(cam->frame_tmp.buffer = rvmalloc(W9968CF_HW_BUF_SIZE))) {
+		DBG(1, "Couldn't allocate memory for the temporary "
+		       "video frame buffer (%i bytes).", W9968CF_HW_BUF_SIZE)
+		return -ENOMEM;
+	}
+
+	/* Allocate memory for the helper buffer */
+	if (w9968cf_vppmod_present) {
+		if (!(cam->vpp_buffer = rvmalloc(bufsize))) {
+			DBG(1, "Couldn't allocate memory for the helper buffer"
+			       " (%li bytes).", bufsize)
+			return -ENOMEM;
+		}
+	} else
+		cam->vpp_buffer = NULL;
+
+	/* Allocate memory for video frame buffers */	
+	cam->nbuffers = cam->max_buffers;
+	while (cam->nbuffers >= 2) {
+		if ((buff = rvmalloc(cam->nbuffers * bufsize)))
+			break;
+		else
+			cam->nbuffers--;
+	}
+
+	if (!buff) {
+		DBG(1, "Couldn't allocate memory for the video frame buffers.")
+		cam->nbuffers = 0;
+		return -ENOMEM;
+	}
+
+	if (cam->nbuffers != cam->max_buffers)
+		DBG(2, "Couldn't allocate memory for %d video frame buffers. "
+		       "Only memory for %d buffers has been allocated.",
+		    cam->max_buffers, cam->nbuffers)
+
+	for (i = 0; i < cam->nbuffers; i++) {
+		cam->frame[i].buffer = buff + i*bufsize;
+		/* Circular list */
+		if (i != cam->nbuffers-1)
+			cam->frame[i].next = &cam->frame[i+1];
+		else
+			cam->frame[i].next = &cam->frame[0];
+		cam->frame[i].status = F_UNUSED;
+	}
+
+	DBG(5, "Memory successfully allocated.")
+	return 0;
+}
+
+
+
+/****************************************************************************
+ * USB-specific functions                                                   *
+ ****************************************************************************/
+
+/*--------------------------------------------------------------------------
+  This is an handler function which is called after the URBs are completed.
+  It collects multiple data packets coming from the camera by putting them
+  into frame buffers: one or more zero data length data packets are used to
+  mark the end of a video frame; the first non-zero data packet is the start
+  of the next video frame; if an error is encountered in a packet, the entire
+  video frame is discarded and grabbed again.
+  If there are no requested frames in the FIFO list, packets are collected into
+  a temporary buffer. 
+  --------------------------------------------------------------------------*/
+static void w9968cf_urb_complete(struct urb *urb, struct pt_regs *regs)
+{
+	struct w9968cf_device* cam = (struct w9968cf_device*)urb->context;
+	struct w9968cf_frame_t** f;
+	unsigned long maxbufsize;
+	unsigned int len, status;
+	void* pos;
+	u8 i;
+	int err = 0;
+
+	if ((!cam->streaming) || cam->disconnected) {
+		DBG(4, "Got interrupt, but not streaming.")
+		return;
+	}
+
+	maxbufsize = min( (unsigned long)W9968CF_HW_BUF_SIZE, 
+	                  w9968cf_get_max_bufsize(cam) );
+
+	/* "(*f)" will be used instead of "cam->frame_current" */
+	f = &cam->frame_current;
+
+	/* If a frame has been requested and we are grabbing into  
+	   the temporary frame, we'll switch to that requested frame */
+	if ((*f) == &cam->frame_tmp && *cam->requested_frame) {
+		if (cam->frame_tmp.status == F_GRABBING) {
+			w9968cf_pop_frame(cam, &cam->frame_current);
+			(*f)->status = F_GRABBING;
+			(*f)->length = cam->frame_tmp.length;
+			memcpy((*f)->buffer, cam->frame_tmp.buffer,
+			       (*f)->length);
+			DBG(6, "Switched from temp. frame to frame #%d", 
+			    (*f) - &cam->frame[0])
+		}
+	}
+
+	for (i = 0; i < urb->number_of_packets; i++) {
+		len    = urb->iso_frame_desc[i].actual_length;
+		status = urb->iso_frame_desc[i].status;
+		pos    = urb->iso_frame_desc[i].offset + urb->transfer_buffer;
+
+		if (status && len != 0) {
+			DBG(4, "URB failed, error in data packet "
+			       "(error #%d, %s).",
+			    status, symbolic(urb_errlist, status))
+			(*f)->status = F_ERROR;
+			continue;
+		}
+
+		if (len) { /* start of frame */
+
+			if ((*f)->status == F_UNUSED) {
+				(*f)->status = F_GRABBING;
+				(*f)->length = 0;
+			}
+
+			/* Buffer overflows shouldn't happen, however...*/
+			if ((*f)->length + len > maxbufsize) {
+				DBG(4, "Buffer overflow: bad data packets.")
+				(*f)->status = F_ERROR;
+			}
+
+			if ((*f)->status == F_GRABBING) {
+				memcpy((*f)->buffer + (*f)->length, pos, len);
+				(*f)->length += len;
+			}
+
+		} else if ((*f)->status == F_GRABBING) { /* end of frame */
+
+			DBG(6, "Frame #%d successfully grabbed.",
+			    ((*f)==&cam->frame_tmp ? -1 : (*f)-&cam->frame[0]))
+
+			if (cam->vpp_flag & VPP_DECOMPRESSION) {
+				err=(*w9968cf_vpp_check_headers)((*f)->buffer,
+				                                 (*f)->length);
+				if (err) {
+					DBG(4, "Skip corrupted frame: %s",
+					    symbolic(decoder_errlist, err))
+					(*f)->status = F_UNUSED;
+					continue; /* grab this frame again */
+				}
+			}
+
+			(*f)->status = F_READY;
+			(*f)->queued = 0;
+
+			/* Take a pointer to the new frame from the FIFO list.
+			   If the list is empty,we'll use the temporary frame*/
+			if (*cam->requested_frame)
+				w9968cf_pop_frame(cam, &cam->frame_current);
+			else {
+				cam->frame_current = &cam->frame_tmp;
+				(*f)->status = F_UNUSED;
+			}
+
+		} else if ((*f)->status == F_ERROR)
+			(*f)->status = F_UNUSED; /* grab it again */
+
+		PDBGG("Frame length %li | pack.#%d | pack.len. %d | state %d",
+		      (unsigned long)(*f)->length, i, len, (*f)->status)
+
+	} /* end for */
+
+	/* Resubmit this URB */
+	urb->dev = cam->usbdev;
+	urb->status = 0;
+	spin_lock(&cam->urb_lock);
+	if (cam->streaming)
+		if ((err = usb_submit_urb(urb, GFP_ATOMIC))) {
+			cam->misconfigured = 1;
+			DBG(1, "Couldn't resubmit the URB: error %d, %s",
+			    err, symbolic(urb_errlist, err));
+		}
+	spin_unlock(&cam->urb_lock);
+
+	/* Wake up the user process */
+	if (waitqueue_active(&cam->wait_queue))
+		wake_up_interruptible(&cam->wait_queue);
+}
+
+
+/*---------------------------------------------------------------------------
+  Setup the URB structures for the isochronous transfer.
+  Submit the URBs so that the data transfer begins.
+  Return 0 on success, a negative number otherwise.
+  ---------------------------------------------------------------------------*/
+static int w9968cf_start_transfer(struct w9968cf_device* cam)
+{
+	struct usb_device *udev = cam->usbdev;
+	struct urb* urb;
+	const u16 p_size = wMaxPacketSize[cam->altsetting-1];
+	u16 w, h, d;
+	int vidcapt;
+	u32 t_size;
+	int err = 0;
+	s8 i, j;
+
+	for (i = 0; i < W9968CF_URBS; i++) {
+		urb = usb_alloc_urb(W9968CF_ISO_PACKETS, GFP_KERNEL);
+		cam->urb[i] = urb;
+
+		if (!urb) {
+			for (j = 0; j < i; j++)
+				usb_free_urb(cam->urb[j]);
+			DBG(1, "Couldn't allocate the URB structures.")
+			return -ENOMEM;
+		}
+
+		urb->dev = udev;
+		urb->context = (void*)cam;
+		urb->pipe = usb_rcvisocpipe(udev, 1);
+		urb->transfer_flags = URB_ISO_ASAP;
+		urb->number_of_packets = W9968CF_ISO_PACKETS;
+		urb->complete = w9968cf_urb_complete;
+		urb->transfer_buffer = cam->transfer_buffer[i];
+		urb->transfer_buffer_length = p_size*W9968CF_ISO_PACKETS;
+		urb->interval = 1;
+		for (j = 0; j < W9968CF_ISO_PACKETS; j++) {
+			urb->iso_frame_desc[j].offset = p_size*j;
+			urb->iso_frame_desc[j].length = p_size;
+		}
+	}
+
+	/* Transfer size per frame, in WORD ! */
+	d = cam->hw_depth;
+	w = cam->hw_width;
+	h = cam->hw_height;
+
+	t_size = (w*h*d)/16;
+
+	err = w9968cf_write_reg(cam, 0xbf17, 0x00); /* reset  everything */
+	err += w9968cf_write_reg(cam, 0xbf10, 0x00); /* normal operation */
+
+	/* Transfer size */
+	err += w9968cf_write_reg(cam, t_size & 0xffff, 0x3d); /* low bits */
+	err += w9968cf_write_reg(cam, t_size >> 16, 0x3e);    /* high bits */
+
+	if (cam->vpp_flag & VPP_DECOMPRESSION)
+		err += w9968cf_upload_quantizationtables(cam);
+
+	vidcapt = w9968cf_read_reg(cam, 0x16); /* read picture settings */
+	err += w9968cf_write_reg(cam, vidcapt|0x8000, 0x16); /* capt. enable */
+
+	err += usb_set_interface(udev, 0, cam->altsetting);
+	err += w9968cf_write_reg(cam, 0x8a05, 0x3c); /* USB FIFO enable */
+
+	if (err || (vidcapt < 0)) {
+		for (i = 0; i < W9968CF_URBS; i++)
+			usb_free_urb(cam->urb[i]);
+		DBG(1, "Couldn't tell the camera to start the data transfer.")
+		return err;
+	}
+
+	w9968cf_init_framelist(cam);
+
+	/* Begin to grab into the temporary buffer */
+	cam->frame_tmp.status = F_UNUSED;
+	cam->frame_tmp.queued = 0;
+	cam->frame_current = &cam->frame_tmp;
+
+	if (!(cam->vpp_flag & VPP_DECOMPRESSION))
+		DBG(5, "Isochronous transfer size: %li bytes/frame.",
+		    (unsigned long)t_size*2)
+
+	DBG(5, "Starting the isochronous transfer...")
+
+	/* Submit the URBs */
+	for (i = 0; i < W9968CF_URBS; i++) {
+		err = usb_submit_urb(cam->urb[i], GFP_KERNEL);
+		if (err) {
+			for (j = i-1; j >= 0; j--)
+				if (!usb_unlink_urb(cam->urb[j]))
+					usb_free_urb(cam->urb[j]);
+			DBG(1, "Couldn't send a transfer request to the "
+			       "USB core (error #%d, %s).", err, 
+			    symbolic(urb_errlist, err))
+		}
+	}
+
+	cam->streaming = 1;
+
+	return 0;
+}
+
+
+/*--------------------------------------------------------------------------
+  Stop the isochronous transfer and set alternate setting to 0 (0Mb/s).
+  Return 0 on success, a negative number otherwise.
+  --------------------------------------------------------------------------*/
+static int w9968cf_stop_transfer(struct w9968cf_device* cam)
+{
+	struct usb_device *udev = cam->usbdev;
+	unsigned long lock_flags;
+	int err = 0;
+	s8 i;
+
+	/* This avoids race conditions with usb_submit_urb() 
+	   in the URB completition handler */
+	spin_lock_irqsave(&cam->urb_lock, lock_flags);
+	cam->streaming = 0;
+	spin_unlock_irqrestore(&cam->urb_lock, lock_flags);
+
+	for (i = W9968CF_URBS-1; i >= 0; i--)
+		if (cam->urb[i])
+			if (!usb_unlink_urb(cam->urb[i])) {
+				usb_free_urb(cam->urb[i]);
+				cam->urb[i] = NULL;
+			}
+
+	if (cam->disconnected)
+		goto exit;
+
+	err = w9968cf_write_reg(cam, 0x0a05, 0x3c); /* stop USB transfer */
+	err += usb_set_interface(udev, 0, 0); /* 0 Mb/s */
+	err += w9968cf_write_reg(cam, 0x0000, 0x39); /* disable JPEG encoder */
+	err += w9968cf_write_reg(cam, 0x0000, 0x16); /* stop video capture */
+
+	if (err) {
+		DBG(2, "Failed to tell the camera to stop the isochronous "
+		       "transfer. However this is not a critical error.")
+		return -EIO;
+	}
+
+exit:
+	DBG(5, "Isochronous transfer stopped.")
+	return 0;
+}
+
+
+/*--------------------------------------------------------------------------
+  Write a W9968CF register. 
+  Return 0 on success, -1 otherwise.
+  --------------------------------------------------------------------------*/
+static int w9968cf_write_reg(struct w9968cf_device* cam, u16 value, u16 index)
+{
+	struct usb_device* udev = cam->usbdev;
+	int res;
+
+	res = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0,
+	                      USB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_DEVICE,
+	                      value, index, NULL, 0, W9968CF_USB_CTRL_TIMEOUT);
+
+	if (res < 0)
+		DBG(4, "Failed to write a register "
+		       "(value 0x%04X, index 0x%02X, error #%d, %s).",
+		    value, index, res, symbolic(urb_errlist, res))
+
+	return (res >= 0) ? 0 : -1;
+}
+
+
+/*--------------------------------------------------------------------------
+  Read a W9968CF register. 
+  Return the register value on success, -1 otherwise.
+  --------------------------------------------------------------------------*/
+static int w9968cf_read_reg(struct w9968cf_device* cam, u16 index)
+{
+	struct usb_device* udev = cam->usbdev;
+	u16* buff = cam->control_buffer;
+	int res;
+
+	res = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), 1,
+	                      USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+	                      0, index, (void*)buff,
+	                      2, W9968CF_USB_CTRL_TIMEOUT);
+
+	if (res < 0)
+		DBG(4, "Failed to read a register "
+		       "(index 0x%02X, error #%d, %s).",
+		    index, res, symbolic(urb_errlist, res))
+
+	return (res >= 0) ? (int)(*buff) : -1;
+}
+
+
+/*--------------------------------------------------------------------------
+  Write data to the fast serial bus registers.
+  Return 0 on success, -1 otherwise.
+  --------------------------------------------------------------------------*/
+static int w9968cf_write_fsb(struct w9968cf_device* cam, u16* data)
+{
+	struct usb_device* udev = cam->usbdev;
+	u16 value;
+	int res;
+
+	value = *data++;
+
+	res = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0,
+	                      USB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_DEVICE,
+	                      value, 0x06, (void*)data, 6,
+	                      W9968CF_USB_CTRL_TIMEOUT);
+
+	if (res < 0)
+		DBG(4, "Failed to write the FSB registers "
+		       "(error #%d, %s).", res, symbolic(urb_errlist, res))
+
+	return (res >= 0) ? 0 : -1;
+}
+
+
+/*--------------------------------------------------------------------------
+  Write data to the serial bus control register.
+  Return 0 on success, a negative number otherwise.
+  --------------------------------------------------------------------------*/
+static int w9968cf_write_sb(struct w9968cf_device* cam, u16 value)
+{
+	int err = 0;
+
+	err = w9968cf_write_reg(cam, value, 0x01);
+	udelay(W9968CF_I2C_BUS_DELAY);
+
+	return err;
+}
+
+
+/*--------------------------------------------------------------------------
+  Read data from the serial bus control register.
+  Return 0 on success, a negative number otherwise.
+  --------------------------------------------------------------------------*/
+static int w9968cf_read_sb(struct w9968cf_device* cam)
+{
+	int v = 0;
+
+	v = w9968cf_read_reg(cam, 0x01);
+	udelay(W9968CF_I2C_BUS_DELAY);
+
+	return v;
+}
+
+
+/*--------------------------------------------------------------------------
+  Upload quantization tables for the JPEG compression.
+  This function is called by w9968cf_start_transfer().
+  Return 0 on success, a negative number otherwise.
+  --------------------------------------------------------------------------*/
+static int w9968cf_upload_quantizationtables(struct w9968cf_device* cam)
+{
+	u16 a, b;
+	int err = 0, i, j;
+
+	err += w9968cf_write_reg(cam, 0x0010, 0x39); /* JPEG clock enable */
+
+	for (i = 0, j = 0; i < 32; i++, j += 2) {
+		a = Y_QUANTABLE[j] | ((unsigned)(Y_QUANTABLE[j+1]) << 8);
+		b = UV_QUANTABLE[j] | ((unsigned)(UV_QUANTABLE[j+1]) << 8);
+		err += w9968cf_write_reg(cam, a, 0x40+i);
+		err += w9968cf_write_reg(cam, b, 0x60+i);
+	}
+	err += w9968cf_write_reg(cam, 0x0012, 0x39); /* JPEG encoder enable */
+
+	return err;
+}
+
+
+
+/****************************************************************************
+ * Low-level I2C I/O functions.                                             *
+ * The adapter supports the following I2C transfer functions:               *
+ * i2c_adap_fastwrite_byte_data() (at 400 kHz bit frequency only)           *
+ * i2c_adap_read_byte_data()                                                *
+ * i2c_adap_read_byte()                                                     *
+ ****************************************************************************/
+
+static int w9968cf_smbus_start(struct w9968cf_device* cam)
+{
+	int err = 0;
+
+	err += w9968cf_write_sb(cam, 0x0011); /* SDE=1, SDA=0, SCL=1 */
+	err += w9968cf_write_sb(cam, 0x0010); /* SDE=1, SDA=0, SCL=0 */
+
+	return err;
+}
+
+
+static int w9968cf_smbus_stop(struct w9968cf_device* cam)
+{
+	int err = 0;
+
+	err += w9968cf_write_sb(cam, 0x0011); /* SDE=1, SDA=0, SCL=1 */
+	err += w9968cf_write_sb(cam, 0x0013); /* SDE=1, SDA=1, SCL=1 */
+
+	return err;
+}
+
+
+static int w9968cf_smbus_write_byte(struct w9968cf_device* cam, u8 v)
+{
+	u8 bit;
+	int err = 0, sda;
+
+	for (bit = 0 ; bit < 8 ; bit++) {
+		sda = (v & 0x80) ? 2 : 0;
+		v <<= 1;
+		/* SDE=1, SDA=sda, SCL=0 */
+		err += w9968cf_write_sb(cam, 0x10 | sda);
+		/* SDE=1, SDA=sda, SCL=1 */
+		err += w9968cf_write_sb(cam, 0x11 | sda);
+		/* SDE=1, SDA=sda, SCL=0 */
+		err += w9968cf_write_sb(cam, 0x10 | sda);
+	}
+
+	return err;
+}
+
+
+static int w9968cf_smbus_read_byte(struct w9968cf_device* cam, u8* v)
+{
+	u8 bit;
+	int err = 0;
+
+	*v = 0;
+	for (bit = 0 ; bit < 8 ; bit++) {
+		*v <<= 1;
+		err += w9968cf_write_sb(cam, 0x0013);
+		*v |= (w9968cf_read_sb(cam) & 0x0008) ? 1 : 0;
+		err += w9968cf_write_sb(cam, 0x0012);
+	}
+
+	return err;
+}
+
+
+static int w9968cf_smbus_write_ack(struct w9968cf_device* cam)
+{
+	int err = 0;
+
+	err += w9968cf_write_sb(cam, 0x0010); /* SDE=1, SDA=0, SCL=0 */
+	err += w9968cf_write_sb(cam, 0x0011); /* SDE=1, SDA=0, SCL=1 */
+	err += w9968cf_write_sb(cam, 0x0010); /* SDE=1, SDA=0, SCL=0 */
+
+	return err;
+}
+
+
+static int w9968cf_smbus_read_ack(struct w9968cf_device* cam)
+{
+	int err = 0, sda;
+
+	err += w9968cf_write_sb(cam, 0x0013); /* SDE=1, SDA=1, SCL=1 */
+	sda = (w9968cf_read_sb(cam) & 0x08) ? 1 : 0; /* sda = SDA */
+	err += w9968cf_write_sb(cam, 0x0012); /* SDE=1, SDA=1, SCL=0 */
+	if (sda < 0)
+		err += sda;
+	if (sda == 1) {
+		DBG(6, "Couldn't receive the ACK.")
+		err += -1;
+	}
+
+	return err;
+}
+
+
+/* SMBus protocol: S Addr Wr [A] Subaddr [A] Value [A] P */
+static int 
+w9968cf_i2c_adap_fastwrite_byte_data(struct w9968cf_device* cam, 
+                                     u16 address, u8 subaddress,u8 value)
+{
+	u16* data = cam->data_buffer;
+	int err = 0;
+
+	 /* Enable SBUS outputs */
+	err += w9968cf_write_reg(cam, 0x0020, 0x01);
+
+	data[0] = 0x082f | ((address & 0x80) ? 0x1500 : 0x0);
+	data[0] |= (address & 0x40) ? 0x4000 : 0x0;
+	data[1] = 0x2082 | ((address & 0x40) ? 0x0005 : 0x0);
+	data[1] |= (address & 0x20) ? 0x0150 : 0x0;
+	data[1] |= (address & 0x10) ? 0x5400 : 0x0;
+	data[2] = 0x8208 | ((address & 0x08) ? 0x0015 : 0x0);
+	data[2] |= (address & 0x04) ? 0x0540 : 0x0;
+	data[2] |= (address & 0x02) ? 0x5000 : 0x0;
+	data[3] = 0x1d20 | ((address & 0x02) ? 0x0001 : 0x0);
+	data[3] |= (address & 0x01) ? 0x0054 : 0x0;
+
+	err += w9968cf_write_fsb(cam, data);
+
+	data[0] = 0x8208 | ((subaddress & 0x80) ? 0x0015 : 0x0);
+	data[0] |= (subaddress & 0x40) ? 0x0540 : 0x0;
+	data[0] |= (subaddress & 0x20) ? 0x5000 : 0x0;
+	data[1] = 0x0820 | ((subaddress & 0x20) ? 0x0001 : 0x0);
+	data[1] |= (subaddress & 0x10) ? 0x0054 : 0x0;
+	data[1] |= (subaddress & 0x08) ? 0x1500 : 0x0;
+	data[1] |= (subaddress & 0x04) ? 0x4000 : 0x0;
+	data[2] = 0x2082 | ((subaddress & 0x04) ? 0x0005 : 0x0);
+	data[2] |= (subaddress & 0x02) ? 0x0150 : 0x0;
+	data[2] |= (subaddress & 0x01) ? 0x5400 : 0x0;
+	data[3] = 0x001d;
+
+	err += w9968cf_write_fsb(cam, data);
+
+	data[0] = 0x8208 | ((value & 0x80) ? 0x0015 : 0x0);
+	data[0] |= (value & 0x40) ? 0x0540 : 0x0;
+	data[0] |= (value & 0x20) ? 0x5000 : 0x0;
+	data[1] = 0x0820 | ((value & 0x20) ? 0x0001 : 0x0);
+	data[1] |= (value & 0x10) ? 0x0054 : 0x0;
+	data[1] |= (value & 0x08) ? 0x1500 : 0x0;
+	data[1] |= (value & 0x04) ? 0x4000 : 0x0;
+	data[2] = 0x2082 | ((value & 0x04) ? 0x0005 : 0x0);
+	data[2] |= (value & 0x02) ? 0x0150 : 0x0;
+	data[2] |= (value & 0x01) ? 0x5400 : 0x0;
+	data[3] = 0xfe1d;
+
+	err += w9968cf_write_fsb(cam, data);
+
+	/* Disable SBUS outputs */
+	err += w9968cf_write_reg(cam, 0x0000, 0x01);
+
+	if (!err)
+		DBG(5, "I2C write byte data done, addr.0x%04X, subaddr.0x%02X "
+		       "value 0x%02X.", address, subaddress, value)
+	else
+		DBG(5, "I2C write byte data failed, addr.0x%04X, "
+		       "subaddr.0x%02X, value 0x%02X.", 
+	            address, subaddress, value)
+
+	return err;
+}
+
+
+/* SMBus protocol: S Addr Wr [A] Subaddr [A] P S Addr+1 Rd [A] [Value] NA P */
+static int 
+w9968cf_i2c_adap_read_byte_data(struct w9968cf_device* cam, 
+                                u16 address, u8 subaddress, 
+                                u8* value)
+{
+	int err = 0;
+
+	/* Serial data enable */
+	err += w9968cf_write_sb(cam, 0x0013); /* don't change ! */
+
+	err += w9968cf_smbus_start(cam);
+	err += w9968cf_smbus_write_byte(cam, address);
+	err += w9968cf_smbus_read_ack(cam);
+	err += w9968cf_smbus_write_byte(cam, subaddress);
+	err += w9968cf_smbus_read_ack(cam);
+	err += w9968cf_smbus_stop(cam);
+	err += w9968cf_smbus_start(cam);
+	err += w9968cf_smbus_write_byte(cam, address + 1);
+	err += w9968cf_smbus_read_ack(cam);
+	err += w9968cf_smbus_read_byte(cam, value);
+	err += w9968cf_smbus_write_ack(cam);
+	err += w9968cf_smbus_stop(cam);
+ 
+	/* Serial data disable */
+	err += w9968cf_write_sb(cam, 0x0000);
+
+	if (!err)
+		DBG(5, "I2C read byte data done, addr.0x%04X, "
+		       "subaddr.0x%02X, value 0x%02X.", 
+		    address, subaddress, *value)
+	else
+		DBG(5, "I2C read byte data failed, addr.0x%04X, "
+		       "subaddr.0x%02X, wrong value 0x%02X.",
+		    address, subaddress, *value)
+
+	return err;
+}
+
+
+/* SMBus protocol: S Addr+1 Rd [A] [Value] NA P */
+static int 
+w9968cf_i2c_adap_read_byte(struct w9968cf_device* cam,
+                           u16 address, u8* value)
+{
+	int err = 0;
+
+	/* Serial data enable */
+	err += w9968cf_write_sb(cam, 0x0013);
+
+	err += w9968cf_smbus_start(cam);
+	err += w9968cf_smbus_write_byte(cam, address + 1);
+	err += w9968cf_smbus_read_ack(cam);
+	err += w9968cf_smbus_read_byte(cam, value);
+	err += w9968cf_smbus_write_ack(cam);
+	err += w9968cf_smbus_stop(cam);
+ 
+	/* Serial data disable */
+	err += w9968cf_write_sb(cam, 0x0000);
+
+	if (!err)
+		DBG(5, "I2C read byte done, addr.0x%04X."
+		       "value 0x%02X.", address, *value)
+	else
+		DBG(5, "I2C read byte failed, addr.0x%04X."
+		       "wrong value 0x%02X.", address, *value)
+
+	return err;
+}
+
+
+/* SMBus protocol: S Addr Wr [A] Value [A] P */
+static int 
+w9968cf_i2c_adap_write_byte(struct w9968cf_device* cam,
+                            u16 address, u8 value)
+{
+	DBG(4, "i2c_write_byte() is an unsupported transfer mode.")
+	return -EINVAL;
+}
+
+
+
+/****************************************************************************
+ * I2C interface to kernel                                                  *
+ ****************************************************************************/
+
+static int
+w9968cf_i2c_smbus_xfer(struct i2c_adapter *adapter, u16 addr, 
+                       unsigned short flags, char read_write, u8 command,
+                       int size, union i2c_smbus_data *data)
+{
+	struct w9968cf_device* cam = i2c_get_adapdata(adapter);
+	u8 i, j;
+	int rc = 0, err = 0; 
+
+	switch (addr) {
+		case OV6xx0_SID:
+		case OV7xx0_SID:
+			break;
+		default:
+			DBG(4, "Rejected slave ID 0x%04X", addr)
+			return -EINVAL;
+	}
+
+	if (size == I2C_SMBUS_BYTE) {
+		/* Why addr <<= 1? See OVXXX0_SID defines in ovcamchip.h */
+		addr <<= 1;
+
+		if (read_write == I2C_SMBUS_WRITE)
+ 			rc = w9968cf_i2c_adap_write_byte(cam, addr, command);
+		else if (read_write == I2C_SMBUS_READ) 
+			rc = w9968cf_i2c_adap_read_byte(cam,addr, &data->byte);
+
+	} else if (size == I2C_SMBUS_BYTE_DATA) {
+		addr <<= 1;
+
+		if (read_write == I2C_SMBUS_WRITE)
+ 			rc = w9968cf_i2c_adap_fastwrite_byte_data(cam, addr,
+			                                  command, data->byte);
+		else if (read_write == I2C_SMBUS_READ) {
+			for (i = 1; i <= W9968CF_I2C_RW_RETRIES; i++) {
+				rc = w9968cf_i2c_adap_read_byte_data(cam, addr, 
+				                         command, &data->byte);
+				if (rc < 0) {
+					/* Work around: this seems to wake up  
+					   the EEPROM from the stall state */
+					for (j = 0; j <= 10; j++) {
+					   err += w9968cf_write_sb(cam,0x0020);
+					   err += w9968cf_write_sb(cam,0x0000);
+					   if (err)
+					   	break;
+					}
+				}
+				else
+					break;
+			}
+
+		} else
+			return -EINVAL;
+
+	} else {
+		DBG(4, "Unsupported I2C transfer mode (%d)", size)
+		return -EINVAL;
+	}
+
+	/* This works around a bug in the I2C core */
+	if (rc > 0)
+		rc = 0;
+
+	return rc;
+}
+
+
+static u32 w9968cf_i2c_func(struct i2c_adapter* adap)
+{
+	return I2C_FUNC_SMBUS_READ_BYTE |
+	       I2C_FUNC_SMBUS_READ_BYTE_DATA  |
+	       I2C_FUNC_SMBUS_WRITE_BYTE_DATA;
+}
+
+
+static int w9968cf_i2c_attach_inform(struct i2c_client* client)
+{
+	struct w9968cf_device* cam = i2c_get_adapdata(client->adapter);
+	const char* clientname = i2c_clientname(client);
+	int id = client->driver->id;
+
+	if (id == I2C_DRIVERID_OVCAMCHIP) {
+		int rc = 0;
+
+		cam->sensor_client = client;
+
+		rc = w9968cf_sensor_cmd(cam, OVCAMCHIP_CMD_INITIALIZE, 
+		                        &cam->sensor_mono);
+		if (rc < 0) {
+			DBG(1, "CMOS sensor initialization failed (rc=%d)",rc);
+			cam->sensor_client = NULL;
+			return rc;
+		}
+
+		if (w9968cf_sensor_cmd(cam, OVCAMCHIP_CMD_Q_SUBTYPE, 
+		                       &cam->sensor) < 0)
+			rc = -EIO;
+		else if (client->addr==OV7xx0_SID || client->addr==OV6xx0_SID)
+			w9968cf_sensor_configure(cam);
+		else
+			rc = -EINVAL;
+
+		if (rc < 0) {
+			cam->sensor_client = NULL;
+			cam->sensor = CC_UNKNOWN;
+			return rc;
+		}
+	} else	{
+		DBG(4, "Rejected client [%s] with [%s]", 
+		    clientname, client->driver->name)
+		return -1;
+	}
+
+	DBG(2, "I2C attach client [%s] with [%s]",
+	    clientname, client->driver->name)
+
+	return 0;
+}
+
+
+static int w9968cf_i2c_detach_inform(struct i2c_client* client)
+{
+	struct w9968cf_device* cam = i2c_get_adapdata(client->adapter);
+	const char* clientname = i2c_clientname(client);
+
+	if (cam->sensor_client == client) {
+		cam->sensor_client = NULL;
+	}
+
+	DBG(2, "I2C detach [%s]", clientname)
+
+	return 0;
+}
+
+
+static int 
+w9968cf_i2c_control(struct i2c_adapter* adapter, unsigned int cmd,
+                    unsigned long arg)
+{
+	return 0;
+}
+
+
+static int w9968cf_i2c_init(struct w9968cf_device* cam)
+{
+	int rc = 0;
+
+	static struct i2c_algorithm algo = {
+		.name =          "W996[87]CF algorithm",
+		.id =            I2C_ALGO_SMBUS,
+		.smbus_xfer =    w9968cf_i2c_smbus_xfer,
+		.algo_control =  w9968cf_i2c_control,
+		.functionality = w9968cf_i2c_func,
+	};
+
+	static struct i2c_adapter adap = {
+		.id =                I2C_ALGO_SMBUS | I2C_HW_SMBUS_W9968CF,
+		.class =             I2C_ADAP_CLASS_CAM_DIGITAL,
+		.owner =             THIS_MODULE,
+		.client_register =   w9968cf_i2c_attach_inform,
+		.client_unregister = w9968cf_i2c_detach_inform,
+		.algo =              &algo,
+	};
+
+	memcpy(&cam->i2c_adapter, &adap, sizeof(struct i2c_adapter));
+	strcpy(cam->i2c_adapter.name, "w9968cf");
+	i2c_set_adapdata(&cam->i2c_adapter, cam);
+
+	DBG(6, "Registering I2C bus with kernel...")
+
+	rc = i2c_add_adapter(&cam->i2c_adapter);
+	if (rc)
+		DBG(5, "Failed to register the I2C bus.")
+	else
+		DBG(5, "I2C bus registered.")
+
+	return rc;
+}
+
+
+
+/****************************************************************************
+ * Helper functions                                                         *
+ ****************************************************************************/
+
+/*--------------------------------------------------------------------------
+  Turn on the LED on some webcams. A beep should be heard too.
+  Return 0 on success, a negative number otherwise.
+  --------------------------------------------------------------------------*/
+static int w9968cf_turn_on_led(struct w9968cf_device* cam)
+{
+	int err = 0;
+
+	err += w9968cf_write_reg(cam, 0xff00, 0x00); /* power-down */
+	err += w9968cf_write_reg(cam, 0xbf17, 0x00); /* reset everything */
+	err += w9968cf_write_reg(cam, 0xbf10, 0x00); /* normal operation */
+	err += w9968cf_write_reg(cam, 0x0010, 0x01); /* serial bus, SDS high */
+	err += w9968cf_write_reg(cam, 0x0000, 0x01); /* serial bus, SDS low */
+	err += w9968cf_write_reg(cam, 0x0010, 0x01); /* ..high 'beep-beep' */
+
+	if (err)
+		DBG(2, "Couldn't turn on the LED.")
+
+	DBG(5, "LED turned on.")
+
+	return err;
+}
+
+
+/*--------------------------------------------------------------------------
+  Write some registers for the device initialization.
+  This function is called once on open().
+  Return 0 on success, a negative number otherwise.
+  --------------------------------------------------------------------------*/
+static int w9968cf_init_chip(struct w9968cf_device* cam)
+{
+	int err = 0, rc = 0;
+
+	err += w9968cf_write_reg(cam, 0xff00, 0x00); /* power off */
+	err += w9968cf_write_reg(cam, 0xbf10, 0x00); /* power on */
+
+	err += w9968cf_write_reg(cam, 0x405d, 0x03); /* DRAM timings */
+	err += w9968cf_write_reg(cam, 0x0030, 0x04); /* SDRAM timings */
+
+	err += w9968cf_write_reg(cam, 0x0000, 0x20); /* Y frame buf.0, low */
+	err += w9968cf_write_reg(cam, 0x0000, 0x21); /* Y frame buf.0, high */
+	err += w9968cf_write_reg(cam, 0xb000, 0x22); /* Y frame buf.1, low */
+	err += w9968cf_write_reg(cam, 0x0004, 0x23); /* Y frame buf.1, high */
+	err += w9968cf_write_reg(cam, 0x5800, 0x24); /* U frame buf.0, low */
+	err += w9968cf_write_reg(cam, 0x0002, 0x25); /* U frame buf.0, high */
+	err += w9968cf_write_reg(cam, 0x0800, 0x26); /* U frame buf.1, low */
+	err += w9968cf_write_reg(cam, 0x0007, 0x27); /* U frame buf.1, high */
+	err += w9968cf_write_reg(cam, 0x8400, 0x28); /* V frame buf.0, low */
+	err += w9968cf_write_reg(cam, 0x0003, 0x29); /* V frame buf.0, high */
+	err += w9968cf_write_reg(cam, 0x3400, 0x2a); /* V frame buf.1, low */
+	err += w9968cf_write_reg(cam, 0x0008, 0x2b); /* V frame buf.1, high */
+
+	err += w9968cf_write_reg(cam, 0x6000, 0x32); /* JPEG bitstream buf 0 */
+	err += w9968cf_write_reg(cam, 0x0009, 0x33); /* JPEG bitstream buf 0 */
+	err += w9968cf_write_reg(cam, 0x2000, 0x34); /* JPEG bitstream buf 1 */
+	err += w9968cf_write_reg(cam, 0x000d, 0x35); /* JPEG bitstream buf 1 */
+
+	err += w9968cf_write_reg(cam, 0x0000, 0x36);/* JPEG restart interval */
+	err += w9968cf_write_reg(cam, 0x0804, 0x37);/*JPEG VLE FIFO threshold*/
+	err += w9968cf_write_reg(cam, 0x0000, 0x38);/* disable hw up-scaling */
+	err += w9968cf_write_reg(cam, 0x0000, 0x3f); /* JPEG/MCTL test data */
+
+	err += w9968cf_set_picture(cam, cam->picture); /* this before */
+	err += w9968cf_set_window(cam, cam->window);
+
+	if (err)
+		goto error;
+
+	rc = w9968cf_sensor_change_settings(cam);
+	if (rc)
+		goto error;
+
+	DBG(5, "Chip successfully initialized.");
+	
+	return 0;
+
+error:
+	DBG(1, "Chip initialization failed.")
+	if (err)
+		return err;
+	else
+		return rc;
+}
+
+
+/*--------------------------------------------------------------------------
+  Change the picture settings of the camera.
+  Return 0 on success, a negative number otherwise.
+  --------------------------------------------------------------------------*/
+static int
+w9968cf_set_picture(struct w9968cf_device* cam, struct video_picture pict)
+{
+	u16 fmt, hw_depth, hw_palette, reg_v = 0x0000;
+	int err = 0, rc = 0;
+
+	/* Make sure we are using a valid depth */
+	pict.depth = w9968cf_valid_depth(pict.palette);
+
+	fmt = pict.palette;
+
+	hw_depth = pict.depth; /* depth used by the winbond chip */
+	hw_palette = pict.palette; /* palette used by the winbond chip */
+
+	/* VS & HS polarities */
+	reg_v = (cam->vs_polarity << 12) | (cam->hs_polarity << 11);
+
+	switch (fmt)
+	{
+		case VIDEO_PALETTE_UYVY:
+			reg_v |= 0x0000;
+			cam->vpp_flag = VPP_NONE;
+			break;
+		case VIDEO_PALETTE_YUV422P:
+			reg_v |= 0x0002;
+			cam->vpp_flag = VPP_DECOMPRESSION;
+			break;
+		case VIDEO_PALETTE_YUV420:
+		case VIDEO_PALETTE_YUV420P:
+			reg_v |= 0x0003;
+			cam->vpp_flag = VPP_DECOMPRESSION;
+			break;
+		case VIDEO_PALETTE_YUYV:
+		case VIDEO_PALETTE_YUV422:
+			reg_v |= 0x0000;
+			cam->vpp_flag = VPP_SWAP_YUV_BYTES;
+			hw_palette = VIDEO_PALETTE_UYVY;
+			break;
+		/* Original video is used instead of RGBX palettes. 
+		   Software conversion later. */
+		case VIDEO_PALETTE_GREY:
+		case VIDEO_PALETTE_RGB555:
+		case VIDEO_PALETTE_RGB565:
+		case VIDEO_PALETTE_RGB24:
+		case VIDEO_PALETTE_RGB32:
+			reg_v |= 0x0000; /* UYVY 16 bit is used */
+			hw_depth = 16;
+			hw_palette = VIDEO_PALETTE_UYVY;
+			cam->vpp_flag = VPP_UYVY_TO_RGBX;
+			break;
+	}
+
+	/* FIXME: 'hardware double buffer' doesn't work when compressed video
+	          is enabled (corrupted frames). */
+	if (cam->double_buffer && !(cam->vpp_flag & VPP_DECOMPRESSION))
+		reg_v |= 0x0080;
+
+	if (cam->clamping)
+		reg_v |= 0x0020;
+
+	if (cam->filter_type == 1)
+		reg_v |= 0x0008;
+	else if (cam->filter_type == 2)
+		reg_v |= 0x000c;
+
+	err = w9968cf_write_reg(cam, reg_v, 0x16);
+	if (err)
+		goto error;
+
+	rc = w9968cf_sensor_set_picture(cam, pict);
+	if (rc)
+		goto error;
+
+	/* If all went well, update the device data structure */
+	memcpy(&cam->picture, &pict, sizeof(pict));
+	cam->hw_depth = hw_depth;
+	cam->hw_palette = hw_palette;
+
+	/* Settings changed, so we clear the frame buffers */
+	memset(cam->frame[0].buffer, 0, 
+	       cam->nbuffers*w9968cf_get_max_bufsize(cam));
+
+	DBG(4, "Palette is %s, depth is %d bpp.",
+	    symbolic(v4l1_plist, pict.palette), pict.depth)
+
+	return 0;
+
+error:
+	DBG(1, "Failed to change picture settings.")
+	if (err)
+		return err;
+	else 
+		return rc;
+}
+
+
+/*--------------------------------------------------------------------------
+  Change the capture area size of the camera.
+  This function _must_ be called _after_ w9968cf_set_picture().
+  Return 0 on success, a negative number otherwise.
+  --------------------------------------------------------------------------*/
+static int
+w9968cf_set_window(struct w9968cf_device* cam, struct video_window win)
+{
+	u16 x, y, w, h, scx, scy, cw, ch, ax, ay;
+	unsigned long fw, fh;
+	struct ovcamchip_window s_win;
+	int err=0, rc=0;
+
+	/* Work around to avoid FP arithmetics */
+	#define __SC(x) ((x) << 10)
+	#define __UNSC(x) ((x) >> 10)
+
+	/* Make sure we are using a supported resolution */
+	if ((err = w9968cf_adjust_window_size(cam, (u16*)&win.width, 
+	                                      (u16*)&win.height)))
+		goto error;
+
+	/* Scaling factors */
+	fw = __SC(win.width) / cam->maxwidth;
+	fh = __SC(win.height) / cam->maxheight;
+
+	/* Set up the width and height values used by the chip */
+	if ((win.width > cam->maxwidth) || (win.height > cam->maxheight)) {
+		cam->vpp_flag |= VPP_UPSCALE;
+		/* Calculate largest w,h mantaining the same w/h ratio */
+		w = (fw >= fh) ? cam->maxwidth : __SC(win.width)/fh;
+		h = (fw >= fh) ? __SC(win.height)/fw : cam->maxheight;
+		if (w < cam->minwidth) /* just in case */
+			w = cam->minwidth;
+		if (h < cam->minheight) /* just in case */
+			h = cam->minheight;
+	} else {
+		cam->vpp_flag &= ~VPP_UPSCALE;
+		w = win.width;
+		h = win.height;
+	}
+
+	/* x,y offsets of the cropped area */
+	scx = cam->start_cropx;
+	scy = cam->start_cropy;
+
+	/* Calculate cropped area manteining the right w/h ratio */
+	if (cam->largeview && !(cam->vpp_flag & VPP_UPSCALE)) {
+		cw = (fw >= fh) ? cam->maxwidth : __SC(win.width)/fh;
+		ch = (fw >= fh) ? __SC(win.height)/fw : cam->maxheight;
+	} else {
+		cw = w;
+		ch = h;
+	}
+
+	/* Setup the sensor window */
+	s_win.format = SENSOR_FORMAT;
+	s_win.width = cam->maxwidth;
+	s_win.height = cam->maxheight;
+	s_win.quarter = 0; /* full progressive video */
+
+	/* Center it */
+	s_win.x = (s_win.width - cw) / 2;
+	s_win.y = (s_win.height - ch) / 2;
+
+	/* Clock divisor */
+	if (cam->clockdiv >= 0)
+		s_win.clockdiv = cam->clockdiv; /* manual override */
+	else
+		switch (cam->sensor) {
+			case CC_OV6620:
+				s_win.clockdiv = 0;
+				break;
+			case CC_OV6630:
+				s_win.clockdiv = 0;
+				break;
+			case CC_OV76BE:
+			case CC_OV7610:
+			case CC_OV7620:
+				s_win.clockdiv = 0;
+				break;
+			default:
+				s_win.clockdiv = W9968CF_DEF_CLOCKDIVISOR;
+		}
+
+	/* We have to scale win.x and win.y offsets */	
+	if ( (cam->largeview && !(cam->vpp_flag & VPP_UPSCALE))
+	     || (cam->vpp_flag & VPP_UPSCALE) ) {
+		ax = __SC(win.x)/fw;
+		ay = __SC(win.y)/fh;
+	} else {
+		ax = win.x;
+		ay = win.y;
+	}
+
+	if ((ax + cw) > cam->maxwidth)
+		ax = cam->maxwidth - cw;
+
+	if ((ay + ch) > cam->maxheight)
+		ay = cam->maxheight - ch;
+
+	/* Adjust win.x, win.y */
+	if ( (cam->largeview && !(cam->vpp_flag & VPP_UPSCALE))
+	     || (cam->vpp_flag & VPP_UPSCALE) ) {
+		win.x = __UNSC(ax*fw);
+		win.y = __UNSC(ay*fh);
+	} else {
+		win.x = ax;
+		win.y = ay;
+	}
+
+	/* Offsets used by the chip */
+	x = ax + s_win.x;
+	y = ay + s_win.y;
+
+	/* Go ! */
+	if ((rc = w9968cf_sensor_cmd(cam, OVCAMCHIP_CMD_S_MODE, &s_win)))
+		goto error;
+
+	err += w9968cf_write_reg(cam, scx + x, 0x10);
+	err += w9968cf_write_reg(cam, scy + y, 0x11);
+	err += w9968cf_write_reg(cam, scx + x + cw, 0x12);
+	err += w9968cf_write_reg(cam, scy + y + ch, 0x13);
+	err += w9968cf_write_reg(cam, w, 0x14);
+	err += w9968cf_write_reg(cam, h, 0x15);
+
+	/* JPEG width & height */
+	err += w9968cf_write_reg(cam, w, 0x30);
+	err += w9968cf_write_reg(cam, h, 0x31);
+
+	/* Y & UV frame buffer strides (in WORD) */
+	if (cam->vpp_flag & VPP_DECOMPRESSION) {
+		err += w9968cf_write_reg(cam, w/2, 0x2c);
+		err += w9968cf_write_reg(cam, w/4, 0x2d);
+	} else
+		err += w9968cf_write_reg(cam, w, 0x2c);
+
+	if (err)
+		goto error;
+
+	/* If all went well, update the device data structure */
+	memcpy(&cam->window, &win, sizeof(win));
+	cam->hw_width = w;
+	cam->hw_height = h;
+
+	/* Settings changed, so we clear the frame buffers */
+	memset(cam->frame[0].buffer, 0, 
+	       cam->nbuffers*w9968cf_get_max_bufsize(cam));
+
+	DBG(4, "The capture area is %dx%d, Offset (x,y)=(%d,%d).", 
+	    win.width, win.height, win.x, win.y)
+
+	PDBGG("x=%d ,y=%d, w=%d, h=%d, ax=%d, ay=%d, s_win.x=%d, s_win.y=%d, "
+	      "cw=%d, ch=%d, win.x=%d ,win.y=%d, win.width=%d, win.height=%d",
+	      x, y, w, h, ax, ay, s_win.x, s_win.y, cw, ch, win.x, win.y,
+	      win.width, win.height)
+
+	return 0;
+
+error:
+	DBG(1, "Failed to change the capture area size.")
+	if (err)
+		return err;
+	else
+		return rc;
+}
+
+
+/*--------------------------------------------------------------------------
+  Return non-zero if the palette is supported, 0 otherwise.
+  --------------------------------------------------------------------------*/
+static inline u16 w9968cf_valid_palette(u16 palette)
+{
+	u8 i = 0;
+	while (w9968cf_formatlist[i].palette != 0) {
+		if (palette == w9968cf_formatlist[i].palette)
+			return palette;
+		i++;
+	}
+	return 0;
+}
+
+
+/*--------------------------------------------------------------------------
+  Return the depth corresponding to the given palette.
+  Palette _must_ be supported !
+  --------------------------------------------------------------------------*/
+static inline u16 w9968cf_valid_depth(u16 palette)
+{
+	u8 i=0;
+	while (w9968cf_formatlist[i].palette != palette)
+		i++;
+
+	return w9968cf_formatlist[i].depth;
+}
+
+
+/*--------------------------------------------------------------------------
+  Return non-zero if the format requires decompression, 0 otherwise.
+  --------------------------------------------------------------------------*/
+static inline u8 w9968cf_need_decompression(u16 palette)
+{
+	u8 i = 0;
+	while (w9968cf_formatlist[i].palette != 0) {
+		if (palette == w9968cf_formatlist[i].palette)
+			return w9968cf_formatlist[i].compression;
+		i++;
+	}
+	return 0;
+}
+
+
+/*-------------------------------------------------------------------------- 
+  Adjust the asked values for window width and height.
+  Return 0 on success, -1 otherwise.
+  --------------------------------------------------------------------------*/
+static int 
+w9968cf_adjust_window_size(struct w9968cf_device* cam, u16* width, u16* height)
+{
+	u16 maxw, maxh;
+
+	if ((*width < cam->minwidth) || (*height < cam->minheight))
+		return -ERANGE;
+
+	maxw = cam->upscaling && !(cam->vpp_flag & VPP_DECOMPRESSION)
+	       && w9968cf_vppmod_present ? W9968CF_MAX_WIDTH : cam->maxwidth;
+	maxh = cam->upscaling && !(cam->vpp_flag & VPP_DECOMPRESSION)
+	       && w9968cf_vppmod_present ? W9968CF_MAX_HEIGHT : cam->maxheight;
+
+	if (*width > maxw)
+		*width = maxw;
+	if (*height > maxh)
+		*height = maxh;
+
+	if (cam->vpp_flag & VPP_DECOMPRESSION) {
+		*width  &= ~15L; /* multiple of 16 */
+		*height &= ~15L;
+	}
+
+	PDBGG("Window size adjusted w=%d, h=%d ", *width, *height)
+
+	return 0;
+}
+
+
+/*--------------------------------------------------------------------------
+  Initialize the FIFO list of requested frames.
+  --------------------------------------------------------------------------*/
+static void w9968cf_init_framelist(struct w9968cf_device* cam)
+{
+	u8 i;
+
+	for (i = 0; i < cam->nbuffers; i++) {
+		cam->requested_frame[i] = NULL;
+		cam->frame[i].queued = 0;
+		cam->frame[i].status = F_UNUSED;
+	}
+}
+
+
+/*--------------------------------------------------------------------------
+  Add a frame in the FIFO list of requested frames.
+  This function is called in process context.
+  --------------------------------------------------------------------------*/
+static void w9968cf_push_frame(struct w9968cf_device* cam, u8 f_num)
+{
+	u8 f;
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&cam->flist_lock, lock_flags);
+
+	for (f=0; cam->requested_frame[f] != NULL; f++);
+	cam->requested_frame[f] = &cam->frame[f_num];
+	cam->frame[f_num].queued = 1;
+	cam->frame[f_num].status = F_UNUSED; /* clear the status */
+
+	spin_unlock_irqrestore(&cam->flist_lock, lock_flags);
+
+	DBG(6, "Frame #%d pushed into the FIFO list. Position %d.", f_num, f)
+}
+
+
+/*--------------------------------------------------------------------------
+  Read, store and remove the first pointer in the FIFO list of requested
+  frames. This function is called in interrupt context.
+  --------------------------------------------------------------------------*/
+static void 
+w9968cf_pop_frame(struct w9968cf_device* cam, struct w9968cf_frame_t** framep)
+{
+	u8 i;
+
+	spin_lock(&cam->flist_lock);
+
+	*framep = cam->requested_frame[0];
+
+	/* Shift the list of pointers */
+	for (i = 0; i < cam->nbuffers-1; i++)
+		cam->requested_frame[i] = cam->requested_frame[i+1];
+	cam->requested_frame[i] = NULL;
+
+	spin_unlock(&cam->flist_lock);
+
+	DBG(6,"Popped frame #%d from the list.",*framep-&cam->frame[0])
+}
+
+
+/*--------------------------------------------------------------------------
+  High-level video post-processing routine on grabbed frames.
+  Return 0 on success, a negative number otherwise.
+  --------------------------------------------------------------------------*/
+static int 
+w9968cf_postprocess_frame(struct w9968cf_device* cam, 
+                          struct w9968cf_frame_t* fr)
+{
+	void *pIn = fr->buffer, *pOut = cam->vpp_buffer, *tmp;
+	u16 w = cam->window.width,
+	    h = cam->window.height,
+	    d = cam->picture.depth,
+	    fmt = cam->picture.palette,
+	    rgb = cam->force_rgb,
+	    hw_w = cam->hw_width,
+	    hw_h = cam->hw_height,
+	    hw_d = cam->hw_depth;
+	int err = 0;
+
+	#define _PSWAP(pIn, pOut) {tmp = (pIn); (pIn) = (pOut); (pOut) = tmp;}
+
+	if (cam->vpp_flag & VPP_DECOMPRESSION) {
+		memcpy(pOut, pIn, fr->length);
+		_PSWAP(pIn, pOut)
+		err = (*w9968cf_vpp_decode)(pIn, fr->length, hw_w, hw_h, pOut);
+		PDBGG("Compressed frame length: %li",(unsigned long)fr->length)
+		fr->length = (hw_w*hw_h*hw_d)/8;
+		_PSWAP(pIn, pOut)
+		if (err) {
+			DBG(4, "An error occurred while decoding the frame: "
+			       "%s.", symbolic(decoder_errlist, err))
+			return err;
+		} else
+			DBG(6, "Frame decoded")
+	}
+
+	if (cam->vpp_flag & VPP_SWAP_YUV_BYTES) {
+		(*w9968cf_vpp_swap_yuvbytes)(pIn, fr->length);
+		DBG(6, "Original UYVY component ordering changed.")
+	}
+
+	if (cam->vpp_flag & VPP_UPSCALE) {
+		(*w9968cf_vpp_scale_up)(pIn, pOut, hw_w, hw_h, hw_d, w, h);
+		fr->length = (w*h*hw_d)/8;
+		_PSWAP(pIn, pOut)
+		DBG(6, "Vertical up-scaling done: %d,%d,%dbpp->%d,%d",
+		    hw_w, hw_h, hw_d, w, h)
+	}
+
+	if (cam->vpp_flag & VPP_UYVY_TO_RGBX) {
+		(*w9968cf_vpp_uyvy_to_rgbx)(pIn, fr->length, pOut, fmt, rgb);
+		fr->length = (w*h*d)/8;
+		_PSWAP(pIn, pOut)
+		DBG(6, "UYVY-16bit to %s conversion done.", 
+		    symbolic(v4l1_plist, fmt))
+	}
+
+	if (pOut == fr->buffer)
+		memcpy(fr->buffer, cam->vpp_buffer, fr->length);
+
+	return 0;
+}
+
+
+
+/****************************************************************************
+ * CMOS sensor control routines                                             *
+ ****************************************************************************/
+
+static int 
+w9968cf_sensor_set_control(struct w9968cf_device* cam, int cid, int val)
+{
+	struct ovcamchip_control ctl;
+	int rc;
+
+	ctl.id = cid;
+	ctl.value = val;
+
+	rc = w9968cf_sensor_cmd(cam, OVCAMCHIP_CMD_S_CTRL, &ctl);
+
+	return rc;
+}
+
+static int 
+w9968cf_sensor_get_control(struct w9968cf_device* cam, int cid, int *val)
+{
+	struct ovcamchip_control ctl;
+	int rc;
+
+	ctl.id = cid;
+
+	rc = w9968cf_sensor_cmd(cam, OVCAMCHIP_CMD_G_CTRL, &ctl);
+	if (rc >= 0)
+		*val = ctl.value;
+
+	return rc;
+}
+
+
+static inline int
+w9968cf_sensor_cmd(struct w9968cf_device* cam, unsigned int cmd, void *arg)
+{
+	struct i2c_client* c = cam->sensor_client;
+
+	DBG(6, "Executing CMOS sensor command...")
+
+	if (c && c->driver->command)
+		return c->driver->command(cam->sensor_client, cmd, arg);
+	else
+		return -ENODEV;
+}
+
+
+/*--------------------------------------------------------------------------
+  Change some settings of the CMOS sensor.
+  Returns: 0 for success, a negative number otherwise.
+  --------------------------------------------------------------------------*/
+static int w9968cf_sensor_change_settings(struct w9968cf_device* cam)
+{
+	int rc;
+
+	/* Auto brightness */
+	rc = w9968cf_sensor_set_control(cam, OVCAMCHIP_CID_AUTOBRIGHT, 
+	                                cam->auto_brt);
+	if (SENSOR_FATAL_ERROR(rc))
+		return rc;
+
+	/* Auto exposure */
+	rc = w9968cf_sensor_set_control(cam, OVCAMCHIP_CID_AUTOEXP, 
+	                                cam->auto_exp);
+	if (SENSOR_FATAL_ERROR(rc))
+		return rc;
+
+	/* Banding filter */
+	rc = w9968cf_sensor_set_control(cam, OVCAMCHIP_CID_BANDFILT, 
+	                                cam->bandfilt);
+	if (SENSOR_FATAL_ERROR(rc))
+		return rc;
+
+	/* Light frequency */
+	rc = w9968cf_sensor_set_control(cam, OVCAMCHIP_CID_FREQ,
+	                                cam->lightfreq);
+	if (SENSOR_FATAL_ERROR(rc))
+		return rc;
+
+	/* Back light */
+	rc = w9968cf_sensor_set_control(cam, OVCAMCHIP_CID_BACKLIGHT,
+	                                cam->backlight);
+	if (SENSOR_FATAL_ERROR(rc))
+		return rc;
+
+	/* Mirror */
+	rc = w9968cf_sensor_set_control(cam, OVCAMCHIP_CID_MIRROR,
+	                                cam->mirror);
+	if (SENSOR_FATAL_ERROR(rc))
+		return rc;
+
+	return 0;
+}
+
+
+/*--------------------------------------------------------------------------
+  Get some current picture settings from the CMOS sensor.
+  Returns: 0 for success, a negative number otherwise.
+  --------------------------------------------------------------------------*/
+static int
+w9968cf_sensor_get_picture(struct w9968cf_device* cam, 
+                           struct video_picture* pict)
+{
+	int rc, v;
+
+	/* Don't return error if a setting is unsupported, or rest of settings
+	   will not be performed */
+
+	rc = w9968cf_sensor_get_control(cam, OVCAMCHIP_CID_CONT, &v);
+	if (SENSOR_FATAL_ERROR(rc))
+		return rc;
+	pict->contrast = v;
+
+	rc = w9968cf_sensor_get_control(cam, OVCAMCHIP_CID_BRIGHT, &v);
+	if (SENSOR_FATAL_ERROR(rc))
+		return rc;
+	pict->brightness = v;
+
+	rc = w9968cf_sensor_get_control(cam, OVCAMCHIP_CID_SAT, &v);
+	if (SENSOR_FATAL_ERROR(rc))
+		return rc;
+	pict->colour = v;
+
+	rc = w9968cf_sensor_get_control(cam, OVCAMCHIP_CID_HUE, &v);
+	if (SENSOR_FATAL_ERROR(rc))
+		return rc;
+	pict->hue = v;
+
+	pict->whiteness = W9968CF_WHITENESS; /* to do! */
+
+	DBG(5, "Got picture settings from the CMOS sensor.")
+
+	PDBGG("Brightness, contrast, hue, colour, whiteness are "
+	      "%d,%d,%d,%d,%d.", pict->brightness, pict->contrast,
+	      pict->hue, pict->colour, pict->whiteness)
+
+	return 0;
+}
+
+
+/*--------------------------------------------------------------------------
+  Change picture settings of the CMOS sensor.
+  Returns: 0 for success, a negative number otherwise.
+  --------------------------------------------------------------------------*/
+static int
+w9968cf_sensor_set_picture(struct w9968cf_device* cam, 
+                           struct video_picture pict)
+{
+	int rc;
+
+	rc = w9968cf_sensor_set_control(cam,OVCAMCHIP_CID_CONT, pict.contrast);
+	if (SENSOR_FATAL_ERROR(rc))
+		return rc;
+
+	if (!cam->auto_brt) {
+		rc = w9968cf_sensor_set_control(cam, OVCAMCHIP_CID_BRIGHT, 
+	                                        pict.brightness);
+		if (SENSOR_FATAL_ERROR(rc))
+			return rc;
+	}
+
+	rc = w9968cf_sensor_set_control(cam, OVCAMCHIP_CID_SAT, pict.colour);
+	if (SENSOR_FATAL_ERROR(rc))
+		return rc;
+
+	rc = w9968cf_sensor_set_control(cam, OVCAMCHIP_CID_HUE, pict.hue);
+	if (SENSOR_FATAL_ERROR(rc))
+		return rc;
+
+	PDBGG("Brightness, contrast, hue, colour, whiteness are "
+	      "%d,%d,%d,%d,%d.", pict.brightness, pict.contrast,
+	      pict.hue, pict.colour, pict.whiteness)
+
+	return 0;
+}
+
+
+
+/****************************************************************************
+ * Camera configuration                                                     *
+ ****************************************************************************/
+
+/*--------------------------------------------------------------------------
+  This function is called when the CMOS sensor is detected.
+  --------------------------------------------------------------------------*/
+static void w9968cf_sensor_configure(struct w9968cf_device* cam)
+{
+	/* NOTE: Make sure width and height are a multiple of 16 */
+
+	switch (cam->sensor_client->addr) {
+		case OV6xx0_SID:
+			cam->maxwidth = 352;
+			cam->maxheight = 288;
+			cam->minwidth = 64;
+			cam->minheight = 48;
+			break;
+		case OV7xx0_SID:
+			cam->maxwidth = 640;
+			cam->maxheight = 480;
+			cam->minwidth = 64;
+			cam->minheight = 48;
+			break;
+	}
+
+	/* These values depend on the ones in the ovxxx0.c sources */
+	switch (cam->sensor) {
+		case CC_OV7620:
+			cam->start_cropx = 287;
+			cam->start_cropy = 35;
+			/* Seems to work around a bug in the CMOS sensor */
+			cam->vs_polarity = 1;
+			cam->hs_polarity = 1;
+			break;
+		default:
+			cam->start_cropx = 320;
+			cam->start_cropy = 35;
+			cam->vs_polarity = 1;
+			cam->hs_polarity = 0;
+	}
+
+	DBG(5, "CMOS sensor %s configured.", symbolic(senlist, cam->sensor))
+}
+
+
+/*--------------------------------------------------------------------------
+  Fill some basic fields in the main device data structure.
+  This function is called once on w9968cf_usb_probe() for each recognized 
+  camera.
+  --------------------------------------------------------------------------*/
+static void
+w9968cf_configure_camera(struct w9968cf_device* cam,
+                         struct usb_device* udev,
+                         enum w9968cf_model_id mod_id,
+                         const unsigned short dev_nr)
+{
+	init_MUTEX(&cam->fileop_sem);
+	init_waitqueue_head(&cam->open);
+	spin_lock_init(&cam->urb_lock);
+	spin_lock_init(&cam->flist_lock);
+
+	cam->users = 0;
+	cam->disconnected = 0;
+	cam->usbdev = udev;
+	cam->id = mod_id;
+	cam->sensor = CC_UNKNOWN;
+
+	strcpy(cam->v4ldev.name, symbolic(camlist, mod_id));
+	cam->v4ldev.type = VID_TYPE_CAPTURE | VID_TYPE_SCALES;
+	cam->v4ldev.hardware = VID_HARDWARE_W9968CF;
+	cam->v4ldev.fops = &w9968cf_fops;
+	cam->v4ldev.priv = (void*)cam;
+	cam->v4ldev.minor = video_nr[dev_nr];
+
+	/* Calculate the alternate setting number (from 1 to 16)
+	   according to the 'packet_size' module parameter */
+	if (packet_size[dev_nr] < W9968CF_MIN_PACKET_SIZE)
+		packet_size[dev_nr] = W9968CF_MIN_PACKET_SIZE;
+	for (cam->altsetting = 1;
+	     packet_size[dev_nr] < wMaxPacketSize[cam->altsetting-1];
+	     cam->altsetting++);
+
+	cam->max_buffers = (max_buffers[dev_nr] < 2 || 
+	                    max_buffers[dev_nr] > W9968CF_MAX_BUFFERS)
+	                   ? W9968CF_BUFFERS : max_buffers[dev_nr];
+
+	cam->double_buffer = (double_buffer[dev_nr] == 0 || 
+	                      double_buffer[dev_nr] == 1)
+	                     ? double_buffer[dev_nr] : W9968CF_DOUBLE_BUFFER;
+
+	cam->clamping = (clamping[dev_nr] == 0 || clamping[dev_nr] == 1)
+	                ? clamping[dev_nr] : W9968CF_CLAMPING;
+	
+	cam->filter_type = (filter_type[dev_nr] == 0 ||
+	                    filter_type[dev_nr] == 1 ||
+	                    filter_type[dev_nr] == 2)
+	                   ? filter_type[dev_nr] : W9968CF_FILTER_TYPE;
+
+	cam->capture = 1;
+
+	cam->largeview = (largeview[dev_nr] == 0 || largeview[dev_nr] == 1)
+	                 ? largeview[dev_nr] : W9968CF_LARGEVIEW;
+
+	cam->decompression = (decompression[dev_nr] == 0 || 
+	                      decompression[dev_nr] == 1 ||
+	                      decompression[dev_nr] == 2)
+	                     ? decompression[dev_nr] : W9968CF_DECOMPRESSION;
+
+	cam->upscaling = (upscaling[dev_nr] == 0 || 
+	                  upscaling[dev_nr] == 1)
+	                 ? upscaling[dev_nr] : W9968CF_UPSCALING;
+
+	cam->auto_brt = (autobright[dev_nr] == 0 || autobright[dev_nr] == 1)
+	                ? autobright[dev_nr] : W9968CF_AUTOBRIGHT;
+
+	cam->auto_exp = (autoexp[dev_nr] == 0 || autoexp[dev_nr] == 1)
+	                ? autoexp[dev_nr] : W9968CF_AUTOEXP;
+
+	cam->lightfreq = (lightfreq[dev_nr] == 50 || lightfreq[dev_nr] == 60)
+	                 ? lightfreq[dev_nr] : W9968CF_LIGHTFREQ;
+
+	cam->bandfilt = (bandingfilter[dev_nr] == 0 || 
+	                 bandingfilter[dev_nr] == 1)
+	                ? bandingfilter[dev_nr] : W9968CF_BANDINGFILTER;
+
+	cam->backlight = (backlight[dev_nr] == 0 || backlight[dev_nr] == 1)
+	                 ? backlight[dev_nr] : W9968CF_BACKLIGHT;
+
+	cam->clockdiv = (clockdiv[dev_nr] == -1 || clockdiv[dev_nr] >= 0)
+	                ? clockdiv[dev_nr] : W9968CF_CLOCKDIV;
+
+	cam->mirror = (mirror[dev_nr] == 0 || mirror[dev_nr] == 1)
+	              ? mirror[dev_nr] : W9968CF_MIRROR;
+
+	cam->sensor_mono = (sensor_mono[dev_nr]==0 || sensor_mono[dev_nr]==1)
+	                   ? sensor_mono[dev_nr] : W9968CF_SENSOR_MONO;
+
+	cam->picture.brightness = brightness[dev_nr];
+	cam->picture.hue = hue[dev_nr];
+	cam->picture.colour = colour[dev_nr];
+	cam->picture.contrast = contrast[dev_nr];
+	cam->picture.whiteness = whiteness[dev_nr];
+	if (w9968cf_valid_palette(force_palette[dev_nr])) {
+		cam->picture.palette = force_palette[dev_nr];
+		cam->force_palette = 1;
+	} else {
+		cam->force_palette = 0;
+		if (cam->decompression == 0)
+			cam->picture.palette = W9968CF_PALETTE_DECOMP_OFF;
+		else if (cam->decompression == 1)
+			cam->picture.palette = W9968CF_PALETTE_DECOMP_FORCE;
+		else
+			cam->picture.palette = W9968CF_PALETTE_DECOMP_ON;
+	}
+
+	cam->force_rgb = (force_rgb[dev_nr] == 0 || force_rgb[dev_nr] == 1)
+	                 ? force_rgb[dev_nr] : W9968CF_FORCE_RGB;
+
+	cam->window.x = 0;
+	cam->window.y = 0;
+	cam->window.width = W9968CF_WIDTH;
+	cam->window.height = W9968CF_HEIGHT;
+	cam->window.chromakey = 0;
+	cam->window.clipcount = 0;
+	cam->window.flags = 0;
+
+	/* If the video post-processing module is not present, some paramaters
+	   must be overridden: */
+	if (!w9968cf_vppmod_present) {
+		if (cam->decompression == 1)
+			cam->decompression = 2;
+		cam->upscaling = 0;
+		if (cam->picture.palette != VIDEO_PALETTE_UYVY)
+			cam->force_palette = 0;
+		cam->picture.palette = VIDEO_PALETTE_UYVY;
+	}
+
+	cam->picture.depth = w9968cf_valid_depth(cam->picture.palette);
+
+	DBG(3, "%s configured with settings #%d:", 
+	    symbolic(camlist, cam->id), dev_nr)
+	
+	DBG(3, "- Data packet size for USB isochrnous transfer: %d bytes.",
+	    wMaxPacketSize[cam->altsetting-1])
+	
+	DBG(3, "- Number of requested video frame buffers: %d", 
+	    cam->max_buffers)
+
+	if (cam->double_buffer)
+		DBG(3, "- Hardware double buffering enabled.")
+	else 
+		DBG(3, "- Hardware double buffering disabled.")
+
+	if (cam->filter_type == 0)
+		DBG(3, "- Video filtering disabled.")
+	else if (cam->filter_type == 1)
+		DBG(3, "- Video filtering enabled: type 1-2-1.")
+	else if (cam->filter_type == 2)
+		DBG(3, "- Video filtering enabled: type 2-3-6-3-2.")
+
+	if (cam->clamping)
+		DBG(3, "- Video data clamping (CCIR-601 format) enabled.")
+	else
+		DBG(3, "- Video data clamping (CCIR-601 format) disabled.")
+
+	if (cam->largeview)
+		DBG(3, "- Large view enabled.")
+	else
+		DBG(3, "- Large view disabled.")
+
+	if ((cam->decompression) == 0 && (!cam->force_palette))
+		DBG(3, "- Decompression disabled.")
+	else if ((cam->decompression) == 1 && (!cam->force_palette))
+		DBG(3, "- Decompression forced.")
+	else if ((cam->decompression) == 2 && (!cam->force_palette))
+		DBG(3, "- Decompression allowed.")
+
+	if (cam->upscaling)
+		DBG(3, "- Software image scaling enabled.")
+	else
+		DBG(3, "- Software image scaling disabled.")
+
+	if (cam->force_palette)
+		DBG(3, "- Image palette forced to %s.",
+		    symbolic(v4l1_plist, cam->picture.palette))
+
+	if (cam->force_rgb)
+		DBG(3, "- RGB component ordering will be used instead of BGR.")
+
+	if (cam->auto_brt)
+		DBG(3, "- Auto brightness enabled.")
+	else
+		DBG(3, "- Auto brightness disabled.")
+
+	if (cam->auto_exp)
+		DBG(3, "- Auto exposure enabled.")
+	else
+		DBG(3, "- Auto exposure disabled.")
+
+	if (cam->backlight)
+		DBG(3, "- Backlight exposure algorithm enabled.")
+	else
+		DBG(3, "- Backlight exposure algorithm disabled.")
+
+	if (cam->mirror)
+		DBG(3, "- Mirror enabled.")
+	else
+		DBG(3, "- Mirror disabled.")
+
+	if (cam->bandfilt)
+		DBG(3, "- Banding filter enabled.")
+	else
+		DBG(3, "- Banding filter disabled.")
+
+	DBG(3, "- Power lighting frequency: %d", cam->lightfreq)
+
+	if (cam->clockdiv == -1)
+		DBG(3, "- Automatic clock divisor enabled.")
+	else
+		DBG(3, "- Clock divisor: %d", cam->clockdiv)
+
+	if (cam->sensor_mono)
+		DBG(3, "- CMOS sensor used as monochrome.")
+	else
+		DBG(3, "- CMOS sensor not used as monochrome.")
+}
+
+
+/*--------------------------------------------------------------------------
+  Release the resources used by the driver.
+  This function is called on disconnect 
+  (or on close if deallocation has been deferred)
+  --------------------------------------------------------------------------*/
+static void w9968cf_release_resources(struct w9968cf_device* cam)
+{
+	down(&w9968cf_devlist_sem);
+
+	DBG(2, "V4L device deregistered: /dev/video%d", cam->v4ldev.minor)
+
+	video_unregister_device(&cam->v4ldev);
+	list_del(&cam->v4llist);
+	i2c_del_adapter(&cam->i2c_adapter);
+	w9968cf_deallocate_memory(cam);
+	kfree(cam->control_buffer);
+	kfree(cam->data_buffer);
+
+	up(&w9968cf_devlist_sem);
+
+	DBG(5, "Resources released.")
+}
+
+
+
+/****************************************************************************
+ * Video4Linux interface                                                    *
+ ****************************************************************************/
+
+static int w9968cf_open(struct inode* inode, struct file* filp)
+{
+	struct w9968cf_device* cam =
+	  (struct w9968cf_device*)video_devdata(filp)->priv;    
+	int err;
+
+	down(&cam->dev_sem);
+
+	if (cam->sensor == CC_UNKNOWN) {
+		DBG(2, "No supported CMOS sensor has been detected by the "
+		       "'ovcamchip' module for the %s (/dev/video%d). Make "
+		       "sure it is loaded *before* the 'w9968cf' module.", 
+		    symbolic(camlist, cam->id),cam->v4ldev.minor)
+		up(&cam->dev_sem);
+		return -ENODEV;
+	}
+
+	if (cam->users) {
+		DBG(2, "%s (/dev/video%d) has been already occupied by '%s'.",
+		    symbolic(camlist, cam->id),cam->v4ldev.minor, cam->command)
+		if ((filp->f_flags & O_NONBLOCK)||(filp->f_flags & O_NDELAY)) {
+			up(&cam->dev_sem);
+			return -EWOULDBLOCK;
+		}
+		up(&cam->dev_sem);
+		err = wait_event_interruptible(cam->open, cam->disconnected ||
+		                               (cam->users == 0));
+		if (err)
+			return err;
+		if (cam->disconnected)
+			return -ENODEV;
+		down(&cam->dev_sem);
+	}
+
+	DBG(5, "Opening the %s, /dev/video%d ...",
+	    symbolic(camlist, cam->id), cam->v4ldev.minor)
+
+	cam->streaming = 0;
+	cam->misconfigured = 0;
+
+	if (!w9968cf_vppmod_present)
+		w9968cf_vppmod_detect();
+
+	if ((err = w9968cf_allocate_memory(cam)))
+		goto deallocate_memory;
+
+	if ((err = w9968cf_init_chip(cam)))
+		goto deallocate_memory;
+
+	if ((err = w9968cf_start_transfer(cam)))
+		goto deallocate_memory;
+
+	filp->private_data = (void*)cam;
+
+	cam->users++;
+	strcpy(cam->command, current->comm);
+
+	init_waitqueue_head(&cam->wait_queue);
+
+	up(&cam->dev_sem);
+
+	DBG(5, "Video device is open.")
+	return 0;
+
+deallocate_memory:
+	w9968cf_deallocate_memory(cam);
+	DBG(2, "Failed to open the video device.")
+	up(&cam->dev_sem);
+	return err;
+}
+
+
+static int w9968cf_release(struct inode* inode, struct file* filp)
+{
+	struct w9968cf_device* cam = 
+	  (struct w9968cf_device*)video_devdata(filp)->priv;
+
+	down(&cam->dev_sem); /* prevent disconnect() to be called */
+
+	w9968cf_stop_transfer(cam);
+
+	if (cam->disconnected) {
+		w9968cf_release_resources(cam);
+		up(&cam->dev_sem);
+		kfree(cam);
+		return 0;
+	}
+
+	cam->users--;
+	w9968cf_deallocate_memory(cam);
+
+	if (waitqueue_active(&cam->open))
+		wake_up_interruptible(&cam->open);
+
+	DBG(5, "Video device closed.")
+	up(&cam->dev_sem);
+	return 0;
+}
+
+
+static ssize_t
+w9968cf_read(struct file* filp, char* buf, size_t count, loff_t* f_pos)
+{
+	struct w9968cf_device* cam =
+	  (struct w9968cf_device*)video_devdata(filp)->priv;
+	struct w9968cf_frame_t* fr;
+	int err = 0;
+
+	if (filp->f_flags & O_NONBLOCK)
+		return -EWOULDBLOCK;
+
+	if (down_interruptible(&cam->fileop_sem))
+		return -ERESTARTSYS;
+
+	if (cam->disconnected) {
+		DBG(2, "Device not present.")
+		up(&cam->fileop_sem);
+		return -ENODEV;
+	}
+
+	if (cam->misconfigured) {
+		DBG(2, "The camera is misconfigured. Close and open it again.")
+		up(&cam->fileop_sem);
+		return -EIO;
+	}
+
+	if (!cam->frame[0].queued)
+		w9968cf_push_frame(cam, 0);
+
+	if (!cam->frame[1].queued)
+		w9968cf_push_frame(cam, 1);
+
+	err = wait_event_interruptible(cam->wait_queue,
+	                               cam->frame[0].status == F_READY ||
+	                               cam->frame[1].status == F_READY ||
+	                               cam->disconnected);
+	if (err) {
+		up(&cam->fileop_sem);
+		return err;
+	}
+	if (cam->disconnected) {
+		up(&cam->fileop_sem);
+		return -ENODEV;
+	}
+
+	fr = (cam->frame[0].status == F_READY) ? &cam->frame[0]:&cam->frame[1];
+
+	if (w9968cf_vppmod_present)
+		w9968cf_postprocess_frame(cam, fr);
+
+	if (count > fr->length)
+		count = fr->length;
+
+	if (copy_to_user(buf, fr->buffer, count)) {
+		fr->status = F_UNUSED;
+		up(&cam->fileop_sem);
+		return -EFAULT;
+	}
+	*f_pos += count;
+
+	fr->status = F_UNUSED;
+
+	DBG(5, "%d bytes read.", count)
+
+	up(&cam->fileop_sem);
+	return count;
+}
+
+
+static int w9968cf_mmap(struct file* filp, struct vm_area_struct *vma)
+{
+	struct w9968cf_device* cam =
+	  (struct w9968cf_device*)video_devdata(filp)->priv;
+
+	unsigned long vsize = vma->vm_end - vma->vm_start,
+	              psize = cam->nbuffers * w9968cf_get_max_bufsize(cam),
+	              start = vma->vm_start,
+	              pos = (unsigned long)cam->frame[0].buffer,
+	              page;
+
+	if (cam->disconnected) {
+		DBG(2, "Device not present.")
+		return -ENODEV;
+	}
+
+	if (cam->misconfigured) {
+		DBG(2, "The camera is misconfigured. Close and open it again.")
+		return -EIO;
+	}
+
+	PDBGG("mmapping %li bytes...", vsize)
+
+        if (vsize > psize - (vma->vm_pgoff << PAGE_SHIFT))
+		return -EAGAIN;
+
+	while (vsize > 0) {
+		page = kvirt_to_pa(pos) + vma->vm_pgoff;
+		if (remap_page_range(vma, start, page, PAGE_SIZE, 
+		                     vma->vm_page_prot))
+			return -EAGAIN;
+		start += PAGE_SIZE;
+		pos += PAGE_SIZE;
+		vsize = (vsize > PAGE_SIZE) ? vsize-PAGE_SIZE : 0;
+	}
+
+	DBG(5, "mmap method successfully called.")
+	return 0;
+}
+
+
+static int
+w9968cf_ioctl(struct inode* inode, struct file* filp,
+              unsigned int cmd, unsigned long arg)
+{
+	struct w9968cf_device* cam =
+	  (struct w9968cf_device*)video_devdata(filp)->priv;
+	int err;
+
+	if (down_interruptible(&cam->fileop_sem))
+		return -ERESTARTSYS;
+
+	if (cam->disconnected) {
+		DBG(2, "Device not present.")
+		up(&cam->fileop_sem);
+		return -ENODEV;
+	}
+
+	if (cam->misconfigured) {
+		DBG(2, "The camera is misconfigured. Close and open it again.")
+		up(&cam->fileop_sem);
+		return -EIO;
+	}
+
+	err = w9968cf_do_ioctl(cam, cmd, (void*)arg);
+
+	up(&cam->fileop_sem);
+	return err;
+}
+
+
+static int 
+w9968cf_do_ioctl(struct w9968cf_device* cam, unsigned cmd, void* arg)
+{
+	const char* v4l1_ioctls[] = {
+		"?", "CGAP", "GCHAN", "SCHAN", "GTUNER", "STUNER", 
+		"GPICT", "SPICT", "CCAPTURE", "GWIN", "SWIN", "GFBUF",
+		"SFBUF", "KEY", "GFREQ", "SFREQ", "GAUDIO", "SAUDIO",
+		"SYNC", "MCAPTURE", "GMBUF", "GUNIT", "GCAPTURE", "SCAPTURE",
+		"SPLAYMODE", "SWRITEMODE", "GPLAYINFO", "SMICROCODE", 
+		"GVBIFMT", "SVBIFMT" 
+	};
+
+	#define V4L1_IOCTL(cmd) \
+	        ((_IOC_NR((cmd)) < sizeof(v4l1_ioctls)/sizeof(char*)) ? \
+	        v4l1_ioctls[_IOC_NR((cmd))] : "???")
+
+	switch (cmd) {
+
+	case VIDIOCGCAP: /* get video capability */
+	{
+		struct video_capability cap = {
+			.type = VID_TYPE_CAPTURE | VID_TYPE_SCALES,
+			.channels = 1,
+			.audios = 0,
+			.minwidth = cam->minwidth,
+			.minheight = cam->minheight,
+		};
+		sprintf(cap.name, "W996[87]CF USB Camera #%d", 
+		        cam->v4ldev.minor);
+		cap.maxwidth = (cam->upscaling && w9968cf_vppmod_present)
+		               ? W9968CF_MAX_WIDTH : cam->maxwidth;
+		cap.maxheight = (cam->upscaling && w9968cf_vppmod_present)
+		                ? W9968CF_MAX_HEIGHT : cam->maxheight;
+
+		if (copy_to_user(arg, &cap, sizeof(cap)))
+			return -EFAULT;
+
+		DBG(5, "VIDIOCGCAP successfully called.")
+		return 0;
+	}
+
+	case VIDIOCGCHAN: /* get video channel informations */
+	{
+		struct video_channel chan;
+		if (copy_from_user(&chan, arg, sizeof(chan)))
+			return -EFAULT;
+
+		if (chan.channel != 0)
+			return -EINVAL;
+
+		strcpy(chan.name, "Camera");
+		chan.tuners = 0;
+		chan.flags = 0;
+		chan.type = VIDEO_TYPE_CAMERA;
+		chan.norm = VIDEO_MODE_AUTO;
+
+		if (copy_to_user(arg, &chan, sizeof(chan)))
+			return -EFAULT;
+
+		DBG(5, "VIDIOCGCHAN successfully called.")
+		return 0;
+	}
+
+	case VIDIOCSCHAN: /* set active channel */
+	{
+		struct video_channel chan;
+
+		if (copy_from_user(&chan, arg, sizeof(chan)))
+			return -EFAULT;
+
+		if (chan.channel != 0)
+			return -EINVAL;
+
+		DBG(5, "VIDIOCSCHAN successfully called.")
+		return 0;
+	}
+
+	case VIDIOCGPICT: /* get image properties of the picture */
+	{
+		struct video_picture pict;
+
+		if (w9968cf_sensor_get_picture(cam, &pict))
+			return -EIO;
+
+		pict.depth = cam->picture.depth;
+		pict.palette = cam->picture.palette;
+
+		if (copy_to_user(arg, &pict, sizeof(pict)))
+			return -EFAULT;
+
+		DBG(5, "VIDIOCGPICT successfully called.")
+		return 0;
+	}
+
+	case VIDIOCSPICT: /* change picture settings */
+	{
+		struct video_picture pict;
+		int err = 0;
+
+		if (copy_from_user(&pict, arg, sizeof(pict)))
+			return -EFAULT;
+
+		if ( (cam->force_palette || !w9968cf_vppmod_present) 
+		     && pict.palette != cam->picture.palette ) {
+			DBG(4, "Palette %s rejected. Only %s is allowed.",
+			    symbolic(v4l1_plist, pict.palette),
+			    symbolic(v4l1_plist, cam->picture.palette))
+			return -EINVAL;
+		}
+
+		if (!w9968cf_valid_palette(pict.palette)) {
+			DBG(4, "Palette %s not supported. VIDIOCSPICT failed.",
+			    symbolic(v4l1_plist, pict.palette))
+			return -EINVAL;
+		}
+
+		if (pict.depth != w9968cf_valid_depth(pict.palette)) {
+			DBG(4, "Depth %d bpp is not supported for %s palette. "
+			       "VIDIOCSPICT failed.", 
+			    pict.depth, symbolic(v4l1_plist, pict.palette))
+			return -EINVAL;
+		}
+
+		if (!cam->force_palette) {
+		   if (cam->decompression == 0) {
+		      if (w9968cf_need_decompression(pict.palette)) {
+		         DBG(4, "Decompression disabled: palette %s is not "
+		                "allowed. VIDIOCSPICT failed.",
+		             symbolic(v4l1_plist, pict.palette))
+		         return -EINVAL;
+		      }
+		   } else if (cam->decompression == 1) {
+		      if (!w9968cf_need_decompression(pict.palette)) {
+		         DBG(4, "Decompression forced: palette %s is not "
+		                "allowed. VIDIOCSPICT failed.",
+		             symbolic(v4l1_plist, pict.palette))
+		         return -EINVAL;
+		      }
+		   }
+		}
+
+		if (pict.palette != cam->picture.palette ||
+		    pict.depth   != cam->picture.depth)
+		{
+			if(*cam->requested_frame
+			   || cam->frame_current->queued) {
+				err = wait_event_interruptible
+				      ( cam->wait_queue,
+				        cam->disconnected ||
+				        (!*cam->requested_frame &&
+				         !cam->frame_current->queued) );
+				if (err)
+					return err;
+				if (cam->disconnected)
+					return -ENODEV;
+			}
+
+			if (w9968cf_stop_transfer(cam))
+				goto ioctl_fail;
+
+			if (w9968cf_set_picture(cam, pict))
+				goto ioctl_fail;
+
+			if (w9968cf_start_transfer(cam))
+				goto ioctl_fail;
+
+		} else if ( ((pict.brightness != cam->picture.brightness) &&
+		            (!cam->auto_brt)) ||
+		            pict.hue != cam->picture.hue ||
+		            pict.colour != cam->picture.colour ||
+		            pict.contrast != cam->picture.contrast ||
+		            pict.whiteness != cam->picture.whiteness ) {
+			if (w9968cf_sensor_set_picture(cam, pict))
+				return -EIO;
+		}
+
+		DBG(5, "VIDIOCSPICT successfully called.")
+		return 0;
+	}
+
+	case VIDIOCSWIN: /* set capture area */
+	{
+		struct video_window win;
+		int err = 0;
+
+		if (copy_from_user(&win, arg, sizeof(win)))
+			return -EFAULT;
+
+		DBG(6, "VIDIOCSWIN called: clipcount=%d, flags=%d, "
+		       "x=%d, y=%d, %dx%d", win.clipcount, win.flags,
+		    win.x, win.y, win.width, win.height)
+
+		if (win.clipcount != 0 || win.flags != 0)
+			return -EINVAL;
+
+		if ((err = w9968cf_adjust_window_size(cam, (u16*)&win.width,
+		                                      (u16*)&win.height))) {
+			DBG(4, "Resolution not supported (%dx%d)."
+			       "VIDIOCSWIN failed.", win.width, win.height)
+			return err;
+		}
+
+		if (win.x != cam->window.x ||
+		    win.y != cam->window.y ||
+		    win.width != cam->window.width ||
+		    win.height != cam->window.height) {
+
+			if(*cam->requested_frame
+			   || cam->frame_current->queued) {
+				err = wait_event_interruptible
+				      ( cam->wait_queue,
+				        cam->disconnected ||
+				        (!*cam->requested_frame &&
+				         !cam->frame_current->queued) );
+				if (err)
+					return err;
+				if (cam->disconnected)
+					return -ENODEV;
+			}
+
+			if (w9968cf_stop_transfer(cam))
+				goto ioctl_fail;
+
+			/* This _must_ be called before set_window() */
+			if (w9968cf_set_picture(cam, cam->picture))
+				goto ioctl_fail;
+
+			if (w9968cf_set_window(cam, win))
+				goto ioctl_fail;
+
+			if (w9968cf_start_transfer(cam))
+				goto ioctl_fail;
+		}
+
+		DBG(5, "VIDIOCSWIN successfully called. ")
+		return 0;
+	}
+
+	case VIDIOCGWIN: /* get current window properties */
+	{
+		if (copy_to_user(arg,&cam->window,sizeof(struct video_window)))
+			return -EFAULT;
+
+		DBG(5, "VIDIOCGWIN successfully called.")
+		return 0;
+	}
+
+	case VIDIOCGMBUF: /* request for memory (mapped) buffer */
+	{
+		struct video_mbuf mbuf;
+		u8 i;
+
+		mbuf.size = cam->nbuffers * w9968cf_get_max_bufsize(cam);
+		mbuf.frames = cam->nbuffers;
+		for (i = 0; i < cam->nbuffers; i++)
+			mbuf.offsets[i] = (unsigned long)cam->frame[i].buffer -
+			                  (unsigned long)cam->frame[0].buffer;
+
+		if (copy_to_user(arg, &mbuf, sizeof(mbuf)))
+			return -EFAULT;
+
+		DBG(5, "VIDIOCGMBUF successfully called.")
+		return 0;
+	}
+
+	case VIDIOCMCAPTURE: /* start the capture to a frame */
+	{
+		struct video_mmap mmap;
+		struct w9968cf_frame_t* fr;
+		int err = 0;
+
+		if (copy_from_user(&mmap, arg, sizeof(mmap)))
+			return -EFAULT;
+
+		DBG(6, "VIDIOCMCAPTURE called: frame #%d, format=%s, %dx%d",
+		    mmap.frame, symbolic(v4l1_plist, mmap.format), 
+		    mmap.width, mmap.height)
+
+		if (mmap.frame >= cam->nbuffers) {
+			DBG(4, "Invalid frame number (%d). "
+			       "VIDIOCMCAPTURE failed.", mmap.frame)
+			return -EINVAL;
+		}
+
+		if (mmap.format!=cam->picture.palette && 
+		    (cam->force_palette || !w9968cf_vppmod_present)) {
+			DBG(4, "Palette %s rejected. Only %s is allowed.",
+			    symbolic(v4l1_plist, mmap.format),
+			    symbolic(v4l1_plist, cam->picture.palette))
+			return -EINVAL;
+		}
+
+		if (!w9968cf_valid_palette(mmap.format)) {
+			DBG(4, "Palette %s not supported. "
+			       "VIDIOCMCAPTURE failed.", 
+			    symbolic(v4l1_plist, mmap.format))
+			return -EINVAL;
+		}
+
+		if (!cam->force_palette) {
+		   if (cam->decompression == 0) {
+		      if (w9968cf_need_decompression(mmap.format)) {
+		         DBG(4, "Decompression disabled: palette %s is not "
+		                "allowed. VIDIOCSPICT failed.",
+		             symbolic(v4l1_plist, mmap.format))
+		         return -EINVAL;
+		      }
+		   } else if (cam->decompression == 1) {
+		      if (!w9968cf_need_decompression(mmap.format)) {
+		         DBG(4, "Decompression forced: palette %s is not "
+		                "allowed. VIDIOCSPICT failed.",
+		             symbolic(v4l1_plist, mmap.format))
+		         return -EINVAL;
+		      }
+		   }
+		}
+
+		if (w9968cf_adjust_window_size(cam, (u16*)&mmap.width, 
+		                               (u16*)&mmap.height)) {
+			DBG(4, "Resolution not supported (%dx%d). "
+			       "VIDIOCMCAPTURE failed.",
+			    mmap.width, mmap.height)
+			return -EINVAL;
+		}
+
+		fr = &cam->frame[mmap.frame];
+
+		if (mmap.width  != cam->window.width ||
+		    mmap.height != cam->window.height ||
+		    mmap.format != cam->picture.palette) {
+
+			struct video_window win;
+			struct video_picture pict;
+
+			if(*cam->requested_frame
+			   || cam->frame_current->queued) {
+				DBG(6, "VIDIOCMCAPTURE. Change settings for "
+				       "frame #%d: %dx%d, format %s. Wait...",
+				    mmap.frame, mmap.width, mmap.height,
+			            symbolic(v4l1_plist, mmap.format))
+				err = wait_event_interruptible
+				      ( cam->wait_queue,
+				        cam->disconnected ||
+				        (!*cam->requested_frame &&
+				         !cam->frame_current->queued) );
+				if (err)
+					return err;
+				if (cam->disconnected)
+					return -ENODEV;
+			}
+
+			memcpy(&win, &cam->window, sizeof(win));
+			memcpy(&pict, &cam->picture, sizeof(pict));
+			win.width = mmap.width;
+			win.height = mmap.height;
+			pict.palette = mmap.format;
+
+			if (w9968cf_stop_transfer(cam))
+				goto ioctl_fail;
+
+			/* This before set_window */
+			if (w9968cf_set_picture(cam, pict)) 
+				goto ioctl_fail;
+
+			if (w9968cf_set_window(cam, win))
+				goto ioctl_fail;
+
+			if (w9968cf_start_transfer(cam))
+				goto ioctl_fail;
+
+		} else 	if (fr->queued) {
+
+			DBG(6, "Wait until frame #%d is free.", mmap.frame)
+			
+			err = wait_event_interruptible(cam->wait_queue, 
+			                               cam->disconnected ||
+			                               (!fr->queued));
+			if (err)
+				return err;
+			if (cam->disconnected)
+				return -ENODEV;
+		}
+
+		w9968cf_push_frame(cam, mmap.frame);
+		DBG(5, "VIDIOCMCAPTURE(%d): successfully called.", mmap.frame)
+		return 0;
+	}
+
+	case VIDIOCSYNC: /* wait until the capture of a frame is finished */
+	{
+		unsigned int f_num = *((unsigned int *) arg);
+		struct w9968cf_frame_t* fr;
+		int err = 0;
+
+		if (f_num >= cam->nbuffers) {
+			DBG(4, "Invalid frame number (%d). "
+			       "VIDIOCMCAPTURE failed.", f_num)
+			return -EINVAL;
+		}
+
+		DBG(6, "VIDIOCSYNC called for frame #%d", f_num)
+
+		fr = &cam->frame[f_num];
+
+		switch (fr->status) {
+		case F_UNUSED:
+			if (!fr->queued) {
+				DBG(4, "VIDIOSYNC: Frame #%d not requested!",
+				    f_num)
+				return -EFAULT;
+			}
+		case F_ERROR:
+		case F_GRABBING:
+			err = wait_event_interruptible(cam->wait_queue, 
+			                               (fr->status == F_READY)
+			                               || cam->disconnected);
+			if (err)
+				return err;
+			if (cam->disconnected)
+				return -ENODEV;
+			break;
+		case F_READY:
+			break;
+		}
+
+		if (w9968cf_vppmod_present)
+			w9968cf_postprocess_frame(cam, fr);
+
+		fr->status = F_UNUSED;
+
+		DBG(5, "VIDIOCSYNC(%d) successfully called.", f_num)
+		return 0;
+	}
+
+	case VIDIOCGUNIT:/* report the unit numbers of the associated devices*/
+	{
+		struct video_unit unit = {
+			.video = cam->v4ldev.minor,
+			.vbi = VIDEO_NO_UNIT,
+			.radio = VIDEO_NO_UNIT,
+			.audio = VIDEO_NO_UNIT,
+			.teletext = VIDEO_NO_UNIT,
+		};
+
+		if (copy_to_user(arg, &unit, sizeof(unit)))
+			return -EFAULT;
+
+		DBG(5, "VIDIOCGUNIT successfully called.")
+		return 0;
+	}
+
+	case VIDIOCKEY:
+		return 0;
+
+	case VIDIOCGFBUF:
+	{
+		struct video_buffer* buffer = (struct video_buffer*)arg;
+
+		memset(buffer, 0, sizeof(struct video_buffer));
+
+		DBG(5, "VIDIOCGFBUF successfully called.")
+		return 0;
+	}
+
+	case VIDIOCGTUNER:
+	{
+		struct video_tuner tuner;
+		if (copy_from_user(&tuner, arg, sizeof(tuner)))
+			return -EFAULT;
+
+		if (tuner.tuner != 0);
+			return -EINVAL;
+
+		strcpy(tuner.name, "no_tuner");
+		tuner.rangelow = 0;
+		tuner.rangehigh = 0;
+		tuner.flags = VIDEO_TUNER_NORM;
+		tuner.mode = VIDEO_MODE_AUTO;
+		tuner.signal = 0xffff;
+
+		if (copy_to_user(arg, &tuner, sizeof(tuner)))
+			return -EFAULT;
+
+		DBG(5, "VIDIOCGTUNER successfully called.")
+		return 0;
+	}
+
+	case VIDIOCSTUNER:
+	{
+		struct video_tuner tuner;
+		if (copy_from_user(&tuner, arg, sizeof(tuner)))
+			return -EFAULT;
+
+		if (tuner.tuner != 0)
+			return -EINVAL;
+
+		if (tuner.mode != VIDEO_MODE_AUTO)
+			return -EINVAL;
+
+		DBG(5, "VIDIOCSTUNER successfully called.")
+		return 0;
+	}
+
+	case VIDIOCSFBUF:
+	case VIDIOCCAPTURE:
+	case VIDIOCGFREQ:
+	case VIDIOCSFREQ:
+	case VIDIOCGAUDIO:
+	case VIDIOCSAUDIO:
+	case VIDIOCSPLAYMODE:
+	case VIDIOCSWRITEMODE:
+	case VIDIOCGPLAYINFO:
+	case VIDIOCSMICROCODE:
+	case VIDIOCGVBIFMT:
+	case VIDIOCSVBIFMT:
+		DBG(4, "Unsupported V4L1 IOCtl: VIDIOC%s "
+		       "(type 0x%01X, "
+		       "n. 0x%01X, "
+		       "dir. 0x%01X, " 
+		       "size 0x%02X).",
+		    V4L1_IOCTL(cmd),
+		    _IOC_TYPE(cmd),_IOC_NR(cmd),_IOC_DIR(cmd),_IOC_SIZE(cmd))
+
+		return -EINVAL;
+
+	default:
+		DBG(4, "Invalid V4L1 IOCtl: VIDIOC%s "
+		       "type 0x%01X, "
+		       "n. 0x%01X, "
+		       "dir. 0x%01X, "
+		       "size 0x%02X.",
+		    V4L1_IOCTL(cmd),
+		    _IOC_TYPE(cmd),_IOC_NR(cmd),_IOC_DIR(cmd),_IOC_SIZE(cmd))
+
+		return -ENOIOCTLCMD;
+
+	} /* end of switch */
+
+ioctl_fail:
+	cam->misconfigured = 1;
+	DBG(1, "VIDIOC%s failed because of hardware problems. "
+	       "To use the camera, close and open it again.", V4L1_IOCTL(cmd))
+	return -EFAULT;
+}
+
+
+static struct file_operations w9968cf_fops = {
+	.owner =   THIS_MODULE,
+	.open =    w9968cf_open,
+	.release = w9968cf_release,
+	.read =    w9968cf_read,
+	.ioctl =   w9968cf_ioctl,
+	.mmap =    w9968cf_mmap,
+	.llseek =  no_llseek,
+};
+
+
+
+/****************************************************************************
+ * USB probe and V4L registration, disconnect and id_table[] definition     *
+ ****************************************************************************/
+
+static int
+w9968cf_usb_probe(struct usb_interface* intf, const struct usb_device_id* id)
+{
+	struct usb_device *udev = interface_to_usbdev(intf);
+	struct w9968cf_device* cam;
+	int err = 0;
+	enum w9968cf_model_id mod_id;
+	struct list_head* ptr;
+	u8 sc = 0; /* number of simultaneous cameras */
+	static unsigned short dev_nr = 0; /* we are handling device number n */
+
+	if (udev->descriptor.idVendor  == winbond_id_table[0].idVendor &&
+	    udev->descriptor.idProduct == winbond_id_table[0].idProduct)
+		mod_id = W9968CF_MOD_CLVBWGP; /* see camlist[] table */
+
+	else if (udev->descriptor.idVendor  == winbond_id_table[1].idVendor &&
+	         udev->descriptor.idProduct == winbond_id_table[1].idProduct)
+		mod_id = W9968CF_MOD_GENERIC; /* see camlist[] table */
+
+	else
+		return -ENODEV;
+
+	/* We don't handle multi-config cameras */
+	if (udev->descriptor.bNumConfigurations != 1)
+		return -ENODEV;
+
+	DBG(2, "%s detected.", symbolic(camlist, mod_id))
+
+	if (simcams > W9968CF_MAX_DEVICES)
+		simcams = W9968CF_SIMCAMS;
+
+	/* How many cameras are connected ? */
+	down(&w9968cf_devlist_sem);
+	list_for_each(ptr, &w9968cf_dev_list)
+		sc++;
+	up(&w9968cf_devlist_sem);
+
+	if (sc >= simcams) {
+		DBG(2, "Device rejected: too many connected cameras "
+		       "(max. %d)", simcams)
+		return -EPERM;
+	}
+
+	err = usb_set_configuration(udev, 1);
+	err += usb_set_interface(udev, 0, 0);
+
+	if (err) {
+		DBG(1, "Device configuration failed.")
+		return -EIO;
+	}
+
+	cam = (struct w9968cf_device*)
+	          kmalloc(sizeof(struct w9968cf_device), GFP_KERNEL);
+
+	if (!cam) {
+		DBG(1, "Couldn't allocate %d bytes of kernel memory.",
+		    sizeof(struct w9968cf_device))
+		err = -ENOMEM;
+		goto fail;
+	}
+	memset(cam, 0, sizeof(*cam));
+
+	init_MUTEX(&cam->dev_sem);
+	down(&cam->dev_sem);
+
+	/* Allocate 2 bytes of memory for camera control USB transfers */
+	if (!(cam->control_buffer = (u16*)kmalloc(2, GFP_KERNEL))) {
+		DBG(1,"Couldn't allocate memory for camera control transfers.")
+		err = -ENOMEM;
+		goto fail;
+	}
+	memset(cam->control_buffer, 0, 2);
+
+	/* Allocate 8 bytes of memory for USB data transfers to the FSB */
+	if (!(cam->data_buffer = (u16*)kmalloc(8, GFP_KERNEL))) {
+		DBG(1, "Couldn't allocate memory for data "
+		       "transfers to the FSB.")
+		err = -ENOMEM;
+		goto fail;
+	}
+	memset(cam->data_buffer, 0, 8);
+
+	/* Set some basic constants */
+	w9968cf_configure_camera(cam, udev, mod_id, dev_nr);
+
+	err = video_register_device(&cam->v4ldev, VFL_TYPE_GRABBER,
+	                            video_nr[dev_nr]);
+	if (err) {
+		DBG(1, "V4L device registration failed.")
+		if (err == -ENFILE && video_nr[dev_nr] == -1)
+			DBG(2, "Couldn't find a free /dev/videoX node.")
+		video_nr[dev_nr] = -1;
+		dev_nr = (dev_nr < W9968CF_MAX_DEVICES-1) ? dev_nr+1 : 0;
+		goto fail;
+	}
+
+	DBG(2, "V4L device registered as /dev/video%d", cam->v4ldev.minor)
+
+	/* Ok, add a new entry into the list of V4L registered devices */
+	down(&w9968cf_devlist_sem);
+	list_add(&cam->v4llist, &w9968cf_dev_list);
+	up(&w9968cf_devlist_sem);
+
+	dev_nr = (dev_nr < W9968CF_MAX_DEVICES-1) ? dev_nr+1 : 0;
+
+	w9968cf_turn_on_led(cam);
+
+	w9968cf_i2c_init(cam);
+
+	up(&cam->dev_sem);
+
+	dev_set_drvdata(&intf->dev, (void*)cam);
+
+	return 0;
+
+fail: /* Free unused memory */
+	if (cam) {
+		if (cam->control_buffer)
+			kfree(cam->control_buffer);
+		if (cam->data_buffer)
+			kfree(cam->data_buffer);
+		up(&cam->dev_sem);
+		kfree(cam);
+	}
+	return err;
+}
+
+
+static void w9968cf_usb_disconnect(struct usb_interface* intf)
+{
+	struct w9968cf_device* cam = 
+	   (struct w9968cf_device*)dev_get_drvdata(&intf->dev);
+
+	dev_set_drvdata(&intf->dev, NULL);
+
+	if (cam) {
+		/* Prevent concurrent accesses to data */
+		down(&cam->dev_sem); 
+
+		cam->streaming = 0;
+		cam->disconnected = 1;
+
+		DBG(2, "Disconnecting %s...", symbolic(camlist, cam->id))
+
+		if (waitqueue_active(&cam->open))
+			wake_up_interruptible(&cam->open);
+
+		if (cam->users) {
+			DBG(2, "The device is open (/dev/video%d)! "
+			       "Process name: %s. Deregistration and memory "
+			       "deallocation are deferred on close.",
+			    cam->v4ldev.minor, cam->command)
+
+			cam->misconfigured = 1;
+
+			if (waitqueue_active(&cam->wait_queue))
+				wake_up_interruptible(&cam->wait_queue);
+		} else
+			w9968cf_release_resources(cam);
+
+		up(&cam->dev_sem);
+
+		if (!cam->users)
+			kfree(cam);
+	}
+}
+
+
+static struct usb_driver w9968cf_usb_driver = {
+	.owner =      THIS_MODULE,
+	.name =       "w9968cf",
+	.id_table =   winbond_id_table,
+	.probe =      w9968cf_usb_probe,
+	.disconnect = w9968cf_usb_disconnect,
+};
+
+
+
+/****************************************************************************
+ * Module init, exit and intermodule communication                          *
+ ****************************************************************************/
+
+static int w9968cf_vppmod_detect(void)
+{
+	w9968cf_vpp_init_decoder = inter_module_get("w9968cf_init_decoder");
+
+	if (!w9968cf_vpp_init_decoder) {
+		if (vppmod_load)
+			w9968cf_vpp_init_decoder = inter_module_get_request
+		                                  ( "w9968cf_init_decoder",
+			                            "w9968cf-vpp" );
+		if (!w9968cf_vpp_init_decoder) {
+			w9968cf_vppmod_present = 0;
+			DBG(4, "Video post-processing module not detected.")
+			return -ENODEV;
+		}
+	}
+
+	w9968cf_vpp_check_headers = inter_module_get("w9968cf_check_headers");
+	w9968cf_vpp_decode = inter_module_get("w9968cf_decode");
+	w9968cf_vpp_swap_yuvbytes = inter_module_get("w9968cf_swap_yuvbytes");
+	w9968cf_vpp_uyvy_to_rgbx = inter_module_get("w9968cf_uyvy_to_rgbx");
+	w9968cf_vpp_scale_up = inter_module_get("w9968cf_scale_up");
+
+	w9968cf_vppmod_present = 1;
+
+	/* Initialization */
+	(*w9968cf_vpp_init_decoder)();
+
+	DBG(2, "Video post-processing module detected.")
+	return 0;
+}
+
+
+static void w9968cf_vppmod_release(void)
+{
+	inter_module_put("w9968cf_init_decoder");
+	inter_module_put("w9968cf_check_headers");
+	inter_module_put("w9968cf_decode");
+	inter_module_put("w9968cf_swap_yuvbytes");
+	inter_module_put("w9968cf_uyvy_to_rgbx");
+	inter_module_put("w9968cf_scale_up");
+
+	DBG(2, "Video post-processing module released.")
+}
+
+
+static int __init w9968cf_module_init(void)
+{
+	int err;
+
+	DBG(2, W9968CF_MODULE_NAME" "W9968CF_MODULE_VERSION)
+	DBG(3, W9968CF_MODULE_AUTHOR)
+
+	init_MUTEX(&w9968cf_devlist_sem);
+
+	w9968cf_vppmod_detect();
+
+	if ((err = usb_register(&w9968cf_usb_driver))) {
+		if (w9968cf_vppmod_present)
+			w9968cf_vppmod_release();
+		return err;
+	}
+
+	return 0;
+}
+
+
+static void __exit w9968cf_module_exit(void)
+{
+	/* w9968cf_usb_disconnect() will be called */
+	usb_deregister(&w9968cf_usb_driver);
+
+	if (w9968cf_vppmod_present)
+		w9968cf_vppmod_release();
+
+	DBG(2, W9968CF_MODULE_NAME" deregistered.")
+}
+
+
+module_init(w9968cf_module_init);
+module_exit(w9968cf_module_exit);
diff -purN linux-2.5/drivers/usb/media/w9968cf.h usb-2.5/drivers/usb/media/w9968cf.h
--- linux-2.5/drivers/usb/media/w9968cf.h	1970-01-01 00:00:00.000000000 +0000
+++ usb-2.5/drivers/usb/media/w9968cf.h	2003-10-04 10:02:10.000000000 +0000
@@ -0,0 +1,312 @@
+/***************************************************************************
+ * Video4Linux driver for W996[87]CF JPEG USB Dual Mode Camera Chip.       *
+ *                                                                         *
+ * Copyright (C) 2002 2003 by Luca Risolia <luca_ing@libero.it>            *
+ *                                                                         *
+ * This program is free software; you can redistribute it and/or modify    *
+ * it under the terms of the GNU General Public License as published by    *
+ * the Free Software Foundation; either version 2 of the License, or       *
+ * (at your option) any later version.                                     *
+ *                                                                         *
+ * This program is distributed in the hope that it will be useful,         *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of          *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *
+ * GNU General Public License for more details.                            *
+ *                                                                         *
+ * You should have received a copy of the GNU General Public License       *
+ * along with this program; if not, write to the Free Software             *
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.               *
+ ***************************************************************************/
+
+#ifndef _W9968CF_H_
+#define _W9968CF_H_
+
+#include <linux/videodev.h>
+#include <linux/usb.h>
+#include <linux/i2c.h>
+#include <linux/spinlock.h>
+#include <linux/list.h>
+#include <linux/wait.h>
+#include <linux/config.h>
+#include <asm/semaphore.h>
+#include <asm/types.h>
+
+#include "w9968cf_externaldef.h"
+
+
+/****************************************************************************
+ * Default values                                                           *
+ ****************************************************************************/
+
+#define W9968CF_VPPMOD_LOAD     1  /* automatic 'w9968cf-vpp' module loading */
+
+/* Comment/uncomment the following line to enable/disable debugging messages */
+#define W9968CF_DEBUG
+
+/* These have effect only if W9968CF_DEBUG is defined */
+#define W9968CF_DEBUG_LEVEL    2 /* from 0 to 6. 0 for no debug informations */
+#define W9968CF_SPECIFIC_DEBUG 0 /* 0 or 1 */
+
+#define W9968CF_MAX_DEVICES    32
+#define W9968CF_SIMCAMS        W9968CF_MAX_DEVICES /* simultaneous cameras */
+
+#define W9968CF_MAX_BUFFERS   32
+#define W9968CF_BUFFERS       2 /* n. of frame buffers from 2 to MAX_BUFFERS */
+
+/* Maximum data payload sizes in bytes for alternate settings */
+static const u16 wMaxPacketSize[] = {1023, 959, 895, 831, 767, 703, 639, 575,
+                                      511, 447, 383, 319, 255, 191, 127,  63};
+#define W9968CF_PACKET_SIZE      1023 /* according to wMaxPacketSizes[] */
+#define W9968CF_MIN_PACKET_SIZE  63 /* minimum value */
+#define W9968CF_ISO_PACKETS      5 /* n.of packets for isochronous transfers */
+#define W9968CF_USB_CTRL_TIMEOUT HZ /* timeout for usb control commands */
+#define W9968CF_URBS             2 /* n. of scheduled URBs for ISO transfer */
+
+#define W9968CF_I2C_BUS_DELAY    4 /* delay in us for I2C bit r/w operations */
+#define W9968CF_I2C_RW_RETRIES   15 /* number of max I2C r/w retries */
+
+/* Available video formats */
+struct w9968cf_format {
+	const u16 palette;
+	const u16 depth;
+	const u8 compression;
+};
+
+static const struct w9968cf_format w9968cf_formatlist[] = {
+	{ VIDEO_PALETTE_UYVY,    16, 0 }, /* original video */
+	{ VIDEO_PALETTE_YUV422P, 16, 1 }, /* with JPEG compression */
+	{ VIDEO_PALETTE_YUV420P, 12, 1 }, /* with JPEG compression */
+	{ VIDEO_PALETTE_YUV420,  12, 1 }, /* same as YUV420P */
+	{ VIDEO_PALETTE_YUYV,    16, 0 }, /* software conversion */
+	{ VIDEO_PALETTE_YUV422,  16, 0 }, /* software conversion */
+	{ VIDEO_PALETTE_GREY,     8, 0 }, /* software conversion */
+	{ VIDEO_PALETTE_RGB555,  16, 0 }, /* software conversion */
+	{ VIDEO_PALETTE_RGB565,  16, 0 }, /* software conversion */
+	{ VIDEO_PALETTE_RGB24,   24, 0 }, /* software conversion */
+	{ VIDEO_PALETTE_RGB32,   32, 0 }, /* software conversion */
+	{ 0,                      0, 0 }  /* 0 is a terminating entry */
+};
+
+#define W9968CF_DECOMPRESSION    2 /* decomp:0=disable,1=force,2=any formats */
+#define W9968CF_PALETTE_DECOMP_OFF   VIDEO_PALETTE_UYVY    /* when decomp=0 */
+#define W9968CF_PALETTE_DECOMP_FORCE VIDEO_PALETTE_YUV420P /* when decomp=1 */
+#define W9968CF_PALETTE_DECOMP_ON    VIDEO_PALETTE_UYVY    /* when decomp=2 */
+
+#define W9968CF_FORCE_RGB        0  /* read RGB instead of BGR, yes=1/no=0 */
+
+#define W9968CF_MAX_WIDTH      800 /* should be >= 640 */
+#define W9968CF_MAX_HEIGHT     600 /* should be >= 480 */
+#define W9968CF_WIDTH          320 /* from 128 to 352, multiple of 16 */
+#define W9968CF_HEIGHT         240 /* from  96 to 288, multiple of 16 */
+
+#define W9968CF_CLAMPING       0 /* 0 disable, 1 enable video data clamping */
+#define W9968CF_FILTER_TYPE    0 /* 0 disable  1 (1-2-1), 2 (2-3-6-3-2) */
+#define W9968CF_DOUBLE_BUFFER  1 /* 0 disable, 1 enable double buffer */
+#define W9968CF_LARGEVIEW      1 /* 0 disable, 1 enable */
+#define W9968CF_UPSCALING      0 /* 0 disable, 1 enable */
+
+#define W9968CF_SENSOR_MONO    0 /* 0 not monochrome, 1 monochrome sensor */
+#define W9968CF_BRIGHTNESS     31000 /* from 0 to 65535 */
+#define W9968CF_HUE            32768 /* from 0 to 65535 */
+#define W9968CF_COLOUR         32768 /* from 0 to 65535 */
+#define W9968CF_CONTRAST       50000 /* from 0 to 65535 */
+#define W9968CF_WHITENESS      32768 /* from 0 to 65535 */
+
+#define W9968CF_AUTOBRIGHT     0 /* 0 disable, 1 enable automatic brightness */
+#define W9968CF_AUTOEXP        1 /* 0 disable, 1 enable automatic exposure */
+#define W9968CF_LIGHTFREQ      50 /* light frequency. 50Hz (Europe) or 60Hz */
+#define W9968CF_BANDINGFILTER  0 /* 0 disable, 1 enable banding filter */
+#define W9968CF_BACKLIGHT      0 /* 0 or 1, 1=object is lit from behind */
+#define W9968CF_MIRROR         0 /* 0 or 1 [don't] reverse image horizontally*/
+
+#define W9968CF_CLOCKDIV         -1 /* -1 = automatic clock divisor */
+#define W9968CF_DEF_CLOCKDIVISOR  0 /* default sensor clock divisor value */
+
+
+/****************************************************************************
+ * Globals                                                                  *
+ ****************************************************************************/
+
+#define W9968CF_MODULE_NAME     "V4L driver for W996[87]CF JPEG USB " \
+                                "Dual Mode Camera Chip"
+#define W9968CF_MODULE_VERSION  "v1.22"
+#define W9968CF_MODULE_AUTHOR   "(C) 2002 2003 Luca Risolia"
+#define W9968CF_AUTHOR_EMAIL    "<luca_ing@libero.it>"
+
+static u8 w9968cf_vppmod_present; /* status flag: yes=1, no=0 */
+
+static const struct usb_device_id winbond_id_table[] = {
+	{
+		/* Creative Labs Video Blaster WebCam Go Plus */
+		USB_DEVICE(0x041e, 0x4003),
+		.driver_info = (unsigned long)"w9968cf",
+	},
+	{
+		/* Generic W996[87]CF JPEG USB Dual Mode Camera */
+		USB_DEVICE(0x1046, 0x9967),
+		.driver_info = (unsigned long)"w9968cf",
+	},
+	{ } /* terminating entry */
+};
+
+MODULE_DEVICE_TABLE(usb, winbond_id_table);
+
+/* W996[87]CF camera models, internal ids: */
+enum w9968cf_model_id {
+	W9968CF_MOD_GENERIC = 1, /* Generic W996[87]CF based device */
+	W9968CF_MOD_CLVBWGP = 11,/*Creative Labs Video Blaster WebCam Go Plus*/
+	W9968CF_MOD_ADPA5R = 21, /* Aroma Digi Pen ADG-5000 Refurbished */
+	W9986CF_MOD_AU = 31,     /* AVerTV USB */
+	W9968CF_MOD_CLVBWG = 34, /* Creative Labs Video Blaster WebCam Go */
+	W9968CF_MOD_DLLDK = 37,  /* Die Lebon LDC-D35A Digital Kamera */
+	W9968CF_MOD_EEEMC = 40,   /* Ezonics EZ-802 EZMega Cam */
+	W9968CF_MOD_ODPVDMPC = 43,/* OPCOM Digi Pen VGA Dual Mode Pen Camera */
+};
+
+enum w9968cf_frame_status {
+	F_READY,            /* finished grabbing & ready to be read/synced */
+	F_GRABBING,         /* in the process of being grabbed into */
+	F_ERROR,            /* something bad happened while processing */
+	F_UNUSED            /* unused (no VIDIOCMCAPTURE) */
+};
+
+struct w9968cf_frame_t {
+	void* buffer;
+	u32 length;
+	enum w9968cf_frame_status status;
+	struct w9968cf_frame_t* next;
+	u8 queued;
+};
+
+enum w9968cf_vpp_flag {
+	VPP_NONE = 0x00,
+	VPP_UPSCALE = 0x01,
+	VPP_SWAP_YUV_BYTES = 0x02,
+	VPP_DECOMPRESSION = 0x04,
+	VPP_UYVY_TO_RGBX = 0x08,
+};
+
+struct list_head w9968cf_dev_list; /* head of V4L registered cameras list */
+LIST_HEAD(w9968cf_dev_list);
+struct semaphore w9968cf_devlist_sem; /* semaphore for list traversal */
+
+/* Main device driver structure */
+struct w9968cf_device {
+	enum w9968cf_model_id id;   /* private device identifier */
+
+	struct video_device v4ldev; /* V4L structure */
+	struct list_head v4llist;   /* entry of the list of V4L cameras */
+
+	struct usb_device* usbdev;           /* -> main USB structure */
+	struct urb* urb[W9968CF_URBS];       /* -> USB request block structs */
+	void* transfer_buffer[W9968CF_URBS]; /* -> ISO transfer buffers */
+	u16* control_buffer;                 /* -> buffer for control req.*/
+	u16* data_buffer;                    /* -> data to send to the FSB */
+
+	struct w9968cf_frame_t frame[W9968CF_MAX_BUFFERS];
+	struct w9968cf_frame_t frame_tmp;  /* temporary frame */
+	struct w9968cf_frame_t* frame_current; /* -> frame being grabbed */
+	struct w9968cf_frame_t* requested_frame[W9968CF_MAX_BUFFERS];
+	void* vpp_buffer; /* -> helper buffer for post-processing routines */
+
+	u8 max_buffers,   /* number of requested buffers */	   
+	   force_palette, /* yes=1/no=0 */
+	   force_rgb,     /* read RGB instead of BGR, yes=1, no=0 */
+	   double_buffer, /* hardware double buffering yes=1/no=0 */
+	   clamping,      /* video data clamping yes=1/no=0 */
+	   filter_type,   /* 0=disabled, 1=3 tap, 2=5 tap filter */
+	   capture,       /* 0=disabled, 1=enabled */
+	   largeview,     /* 0=disabled, 1=enabled */
+	   decompression, /* 0=disabled, 1=forced, 2=allowed */
+	   upscaling;     /* software image scaling, 0=enabled, 1=disabled */
+
+	struct video_picture picture; /* current window settings */
+	struct video_window window;   /* current picture settings */
+
+	u16 hw_depth,    /* depth (used by the chip) */
+	    hw_palette,  /* palette (used by the chip) */
+	    hw_width,    /* width (used by the chip) */
+	    hw_height,   /* height (used by the chip) */
+	    hs_polarity, /* 0=negative sync pulse, 1=positive sync pulse */
+	    vs_polarity; /* 0=negative sync pulse, 1=positive sync pulse */
+
+	enum w9968cf_vpp_flag vpp_flag; /* post-processing routines in use */
+
+	u8 nbuffers,      /* number of allocated frame buffers */
+	   altsetting,    /* camera alternate setting */
+	   disconnected,  /* flag: yes=1, no=0 */
+	   misconfigured, /* flag: yes=1, no=0 */
+	   users,         /* flag: number of users holding the device */
+	   streaming;     /* flag: yes=1, no=0 */
+
+	int sensor; /* type of image CMOS sensor chip (CC_*) */
+
+	/* Determined by CMOS sensor type */
+	u16 maxwidth,
+	    maxheight,
+	    minwidth,
+	    minheight,
+	    start_cropx,
+	    start_cropy;
+
+	u8  auto_brt,     /* auto brightness enabled flag */
+	    auto_exp,     /* auto exposure enabled flag */
+	    backlight,    /* backlight exposure algorithm flag */
+	    mirror,       /* image is reversed horizontally */
+	    lightfreq,    /* power (lighting) frequency */
+	    bandfilt;     /* banding filter enabled flag */
+	s8  clockdiv;     /* clock divisor */
+	int sensor_mono;  /* CMOS sensor is (probably) monochrome */
+
+	/* I2C interface to kernel */
+	struct i2c_adapter i2c_adapter;
+	struct i2c_client* sensor_client;
+
+	/* Locks */
+	struct semaphore dev_sem,    /* for probe, disconnect,open and close */
+	                 fileop_sem; /* for read and ioctl */
+	spinlock_t urb_lock,   /* for submit_urb() and unlink_urb() */
+	           flist_lock; /* for requested frame list accesses */
+	char command[16]; /* name of the program holding the device */
+	wait_queue_head_t open, wait_queue;
+};
+
+#define W9968CF_HW_BUF_SIZE 640*480*2 /* buf. size for original video frames */
+
+#define SENSOR_FORMAT          VIDEO_PALETTE_UYVY
+#define SENSOR_FATAL_ERROR(rc) ((rc) < 0 && (rc) != -EPERM)
+
+
+/****************************************************************************
+ * Macros and other constants                                               *
+ ****************************************************************************/
+
+#undef DBG
+#ifdef W9968CF_DEBUG
+#	define DBG(level, fmt, args...) \
+{ \
+if ( ((specific_debug) && (debug == (level))) || \
+     ((!specific_debug) && (debug >= (level))) ) { \
+	if ((level) == 1) \
+		err(fmt, ## args); \
+	else if ((level) == 2 || (level) == 3) \
+		info(fmt, ## args); \
+	else if ((level) == 4) \
+		warn(fmt, ## args); \
+	else if ((level) >= 5) \
+		info("[%s,%d] " fmt, \
+		     __PRETTY_FUNCTION__, __LINE__ , ## args); \
+} \
+}
+#else
+	/* Not debugging: nothing */
+#	define DBG(level, fmt, args...) do {;} while(0);
+#endif
+
+#undef PDBG
+#undef PDBGG
+#define PDBG(fmt, args...) info("[%s, %d] "fmt, \
+	                        __PRETTY_FUNCTION__, __LINE__ , ## args);
+#define PDBGG(fmt, args...) do {;} while(0); /* nothing: it's a placeholder */
+
+#endif /* _W9968CF_H_ */
diff -purN linux-2.5/drivers/usb/media/w9968cf_decoder.h usb-2.5/drivers/usb/media/w9968cf_decoder.h
--- linux-2.5/drivers/usb/media/w9968cf_decoder.h	1970-01-01 00:00:00.000000000 +0000
+++ usb-2.5/drivers/usb/media/w9968cf_decoder.h	2003-10-04 10:02:10.000000000 +0000
@@ -0,0 +1,86 @@
+/***************************************************************************
+ * Video decoder for the W996[87]CF driver for Linux.                      *
+ *                                                                         *
+ * Copyright (C) 2003 by Luca Risolia <luca_ing@libero.it>                 *
+ *                                                                         *
+ * This program is free software; you can redistribute it and/or modify    *
+ * it under the terms of the GNU General Public License as published by    *
+ * the Free Software Foundation; either version 2 of the License, or       *
+ * (at your option) any later version.                                     *
+ *                                                                         *
+ * This program is distributed in the hope that it will be useful,         *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of          *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *
+ * GNU General Public License for more details.                            *
+ *                                                                         *
+ * You should have received a copy of the GNU General Public License       *
+ * along with this program; if not, write to the Free Software             *
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.               *
+ ***************************************************************************/
+
+#ifndef _W9968CF_DECODER_H_
+#define _W9968CF_DECODER_H_
+
+/* Comment/uncomment this for high/low quality of compressed video */
+#define W9968CF_DEC_FAST_LOWQUALITY_VIDEO
+
+#ifdef W9968CF_DEC_FAST_LOWQUALITY_VIDEO
+static const unsigned char Y_QUANTABLE[64] = {
+	16,  11,  10,  16,  24,  40,  51,  61,
+	12,  12,  14,  19,  26,  58,  60,  55,
+	14,  13,  16,  24,  40,  57,  69,  56,
+	14,  17,  22,  29,  51,  87,  80,  62,
+	18,  22,  37,  56,  68, 109, 103,  77,
+	24,  35,  55,  64,  81, 104, 113,  92,
+	49,  64,  78,  87, 103, 121, 120, 101,
+	72,  92,  95,  98, 112, 100, 103,  99
+};
+
+static const unsigned char UV_QUANTABLE[64] = {
+	17,  18,  24,  47,  99,  99,  99,  99,
+	18,  21,  26,  66,  99,  99,  99,  99,
+	24,  26,  56,  99,  99,  99,  99,  99,
+	47,  66,  99,  99,  99,  99,  99,  99,
+	99,  99,  99,  99,  99,  99,  99,  99,
+	99,  99,  99,  99,  99,  99,  99,  99,
+	99,  99,  99,  99,  99,  99,  99,  99,
+	99,  99,  99,  99,  99,  99,  99,  99
+};
+#else
+static const unsigned char Y_QUANTABLE[64] = {
+	 8,   5,   5,   8,  12,  20,  25,  30,
+	 6,   6,   7,   9,  13,  29,  30,  27,
+	 7,   6,   8,  12,  20,  28,  34,  28,
+	 7,   8,  11,  14,  25,  43,  40,  31,
+	 9,  11,  18,  28,  34,  54,  51,  38,
+	12,  17,  27,  32,  40,  52,  56,  46,
+	24,  32,  39,  43,  51,  60,  60,  50,
+	36,  46,  47,  49,  56,  50,  51,  49
+};
+
+static const unsigned char UV_QUANTABLE[64] = {
+	 8,   9,  12,  23,  49,  49,  49,  49,
+	 9,  10,  13,  33,  49,  49,  49,  49,
+	12,  13,  28,  49,  49,  49,  49,  49,
+	23,  33,  49,  49,  49,  49,  49,  49,
+	49,  49,  49,  49,  49,  49,  49,  49,
+	49,  49,  49,  49,  49,  49,  49,  49,
+	49,  49,  49,  49,  49,  49,  49,  49,
+	49,  49,  49,  49,  49,  49,  49,  49
+};
+#endif
+
+#define W9968CF_DEC_ERR_CORRUPTED_DATA  -1
+#define W9968CF_DEC_ERR_BUF_OVERFLOW    -2
+#define W9968CF_DEC_ERR_NO_SOI          -3
+#define W9968CF_DEC_ERR_NO_SOF0         -4
+#define W9968CF_DEC_ERR_NO_SOS          -5
+#define W9968CF_DEC_ERR_NO_EOI          -6
+
+extern void w9968cf_init_decoder(void);
+extern int w9968cf_check_headers(const unsigned char* Pin, 
+                                 const unsigned long BUF_SIZE);
+extern int w9968cf_decode(const char* Pin, const unsigned long BUF_SIZE, 
+                          const unsigned W, const unsigned H, char* Pout);
+
+#endif /* _W9968CF_DECODER_H_ */
diff -purN linux-2.5/drivers/usb/media/w9968cf_externaldef.h usb-2.5/drivers/usb/media/w9968cf_externaldef.h
--- linux-2.5/drivers/usb/media/w9968cf_externaldef.h	1970-01-01 00:00:00.000000000 +0000
+++ usb-2.5/drivers/usb/media/w9968cf_externaldef.h	2003-10-04 10:02:10.000000000 +0000
@@ -0,0 +1,95 @@
+/***************************************************************************
+ * Various definitions for compatibility with external modules.            *
+ * This file is part of the W996[87]CF driver for Linux.                   *
+ *                                                                         *
+ * Copyright (C) 2002 2003 by Luca Risolia <luca_ing@libero.it>            *
+ *                                                                         *
+ * This program is free software; you can redistribute it and/or modify    *
+ * it under the terms of the GNU General Public License as published by    *
+ * the Free Software Foundation; either version 2 of the License, or       *
+ * (at your option) any later version.                                     *
+ *                                                                         *
+ * This program is distributed in the hope that it will be useful,         *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of          *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *
+ * GNU General Public License for more details.                            *
+ *                                                                         *
+ * You should have received a copy of the GNU General Public License       *
+ * along with this program; if not, write to the Free Software             *
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.               *
+ ***************************************************************************/
+
+#ifndef _W9968CF_EXTERNALDEF_H_
+#define _W9968CF_EXTERNALDEF_H_
+
+#include <linux/videodev.h>
+#include <linux/i2c.h>
+#include <asm/ioctl.h>
+#include <asm/types.h>
+
+/* The following values have been copied from the "ovcamchip" module. */
+
+#ifndef I2C_DRIVERID_OVCAMCHIP
+#	define I2C_DRIVERID_OVCAMCHIP   0xf00f
+#endif
+
+/* Controls */
+enum {
+	OVCAMCHIP_CID_CONT,       /* Contrast */
+	OVCAMCHIP_CID_BRIGHT,     /* Brightness */
+	OVCAMCHIP_CID_SAT,        /* Saturation */
+	OVCAMCHIP_CID_HUE,        /* Hue */
+	OVCAMCHIP_CID_EXP,        /* Exposure */
+	OVCAMCHIP_CID_FREQ,       /* Light frequency */
+	OVCAMCHIP_CID_BANDFILT,   /* Banding filter */
+	OVCAMCHIP_CID_AUTOBRIGHT, /* Auto brightness */
+	OVCAMCHIP_CID_AUTOEXP,    /* Auto exposure */
+	OVCAMCHIP_CID_BACKLIGHT,  /* Back light compensation */
+	OVCAMCHIP_CID_MIRROR,     /* Mirror horizontally */
+};
+
+/* I2C addresses */
+#define OV7xx0_SID   (0x42 >> 1)
+#define OV6xx0_SID   (0xC0 >> 1)
+
+/* Sensor types */
+enum {
+	CC_UNKNOWN,
+	CC_OV76BE,
+	CC_OV7610,
+	CC_OV7620,
+	CC_OV7620AE,
+	CC_OV6620,
+	CC_OV6630,
+	CC_OV6630AE,
+	CC_OV6630AF,
+};
+
+/* API */
+struct ovcamchip_control {
+	__u32 id;
+	__s32 value;
+};
+
+struct ovcamchip_window {
+	int x;
+	int y;
+	int width;
+	int height;
+	int format;
+	int quarter;   /* Scale width and height down 2x */
+
+	/* This stuff will be removed eventually */
+	int clockdiv;  /* Clock divisor setting */
+};
+
+/* Commands. 
+   You must call OVCAMCHIP_CMD_INITIALIZE before any of other commands */
+#define OVCAMCHIP_CMD_Q_SUBTYPE  _IOR  (0x88, 0x00, int)
+#define OVCAMCHIP_CMD_INITIALIZE _IOW  (0x88, 0x01, int)
+#define OVCAMCHIP_CMD_S_CTRL     _IOW  (0x88, 0x02, struct ovcamchip_control)
+#define OVCAMCHIP_CMD_G_CTRL     _IOWR (0x88, 0x03, struct ovcamchip_control)
+#define OVCAMCHIP_CMD_S_MODE     _IOW  (0x88, 0x04, struct ovcamchip_window)
+#define OVCAMCHIP_MAX_CMD        _IO   (0x88, 0x3f)
+
+#endif /* _W9968CF_EXTERNALDEF_H_ */
diff -purN linux-2.5/drivers/usb/misc/Kconfig usb-2.5/drivers/usb/misc/Kconfig
--- linux-2.5/drivers/usb/misc/Kconfig	2003-10-09 10:20:33.000000000 +0000
+++ usb-2.5/drivers/usb/misc/Kconfig	2003-10-17 16:35:52.000000000 +0000
@@ -58,6 +58,18 @@ config USB_RIO500
 	  To compile this driver as a module, choose M here: the
 	  module will be called rio500.
 
+config USB_LEGOTOWER
+	tristate "USB Lego Infrared Tower support (EXPERIMENTAL)"
+	depends on USB && EXPERIMENTAL
+	help
+	  Say Y here if you want to connect a USB Lego Infrared Tower to your
+	  computer's USB port.
+
+	  This code is also available as a module ( = code which can be
+	  inserted in and removed from the running kernel whenever you want).
+	  The module will be called legousbtower. If you want to compile it as
+	  a module, say M here and read <file:Documentation/modules.txt>.
+
 config USB_BRLVGER
 	tristate "Tieman Voyager USB Braille display support (EXPERIMENTAL)"
 	depends on USB && EXPERIMENTAL
diff -purN linux-2.5/drivers/usb/misc/Makefile usb-2.5/drivers/usb/misc/Makefile
--- linux-2.5/drivers/usb/misc/Makefile	2003-03-18 12:15:55.000000000 +0000
+++ usb-2.5/drivers/usb/misc/Makefile	2003-09-03 05:18:46.000000000 +0000
@@ -12,3 +12,4 @@ obj-$(CONFIG_USB_SPEEDTOUCH)	+= speedtch
 obj-$(CONFIG_USB_TEST)		+= usbtest.o
 obj-$(CONFIG_USB_TIGL)		+= tiglusb.o
 obj-$(CONFIG_USB_USS720)	+= uss720.o
+obj-$(CONFIG_USB_LEGOTOWER)	+= legousbtower.o
diff -purN linux-2.5/drivers/usb/misc/legousbtower.c usb-2.5/drivers/usb/misc/legousbtower.c
--- linux-2.5/drivers/usb/misc/legousbtower.c	1970-01-01 00:00:00.000000000 +0000
+++ usb-2.5/drivers/usb/misc/legousbtower.c	2003-10-16 19:29:05.000000000 +0000
@@ -0,0 +1,878 @@
+/*
+ * LEGO USB Tower driver
+ *
+ * Copyright (C) 2003 David Glance <davidgsf@sourceforge.net> 
+ *               2001 Juergen Stuber <stuber@loria.fr>
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation; either version 2 of
+ *	the License, or (at your option) any later version.
+ *
+ * derived from USB Skeleton driver - 0.5
+ * Copyright (C) 2001 Greg Kroah-Hartman (greg@kroah.com)
+ *
+ * History:
+ *
+ * 2001-10-13 - 0.1 js
+ *   - first version
+ * 2001-11-03 - 0.2 js
+ *   - simplified buffering, one-shot URBs for writing
+ * 2001-11-10 - 0.3 js
+ *   - removed IOCTL (setting power/mode is more complicated, postponed)
+ * 2001-11-28 - 0.4 js
+ *   - added vendor commands for mode of operation and power level in open
+ * 2001-12-04 - 0.5 js
+ *   - set IR mode by default (by oversight 0.4 set VLL mode)
+ * 2002-01-11 - 0.5? pcchan
+ *   - make read buffer reusable and work around bytes_to_write issue between
+ *     uhci and legusbtower
+ * 2002-09-23 - 0.52 david (david@csse.uwa.edu.au)
+ *   - imported into lejos project
+ *   - changed wake_up to wake_up_interruptible
+ *   - changed to use lego0 rather than tower0
+ *   - changed dbg() to use __func__ rather than deprecated __FUNCTION__
+ * 2003-01-12 - 0.53 david (david@csse.uwa.edu.au)
+ *   - changed read and write to write everything or timeout (from a patch by Chris Riesen and 
+ *     Brett Thaeler driver)
+ *   - added ioctl functionality to set timeouts
+ * 2003-07-18 - 0.54 davidgsf (david@csse.uwa.edu.au) 
+ *   - initial import into LegoUSB project
+ *   - merge of existing LegoUSB.c driver
+ * 2003-07-18 - 0.56 davidgsf (david@csse.uwa.edu.au) 
+ *   - port to 2.6 style driver
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/smp_lock.h>
+#include <linux/completion.h>
+#include <asm/uaccess.h>
+#include <linux/usb.h>
+
+
+#ifdef CONFIG_USB_DEBUG
+	static int debug = 4;
+#else
+	static int debug = 1;
+#endif
+
+/* Use our own dbg macro */
+#undef dbg
+#define dbg(lvl, format, arg...) do { if (debug >= lvl) printk(KERN_DEBUG  __FILE__ " : " format " \n", ## arg); } while (0)
+
+
+/* Version Information */
+#define DRIVER_VERSION "v0.56"
+#define DRIVER_AUTHOR "David Glance, davidgsf@sourceforge.net"
+#define DRIVER_DESC "LEGO USB Tower Driver"
+
+/* Module paramaters */
+MODULE_PARM(debug, "i");
+MODULE_PARM_DESC(debug, "Debug enabled or not");
+
+
+/* Define these values to match your device */
+#define LEGO_USB_TOWER_VENDOR_ID	0x0694
+#define LEGO_USB_TOWER_PRODUCT_ID	0x0001
+
+/* table of devices that work with this driver */
+static struct usb_device_id tower_table [] = {
+	{ USB_DEVICE(LEGO_USB_TOWER_VENDOR_ID, LEGO_USB_TOWER_PRODUCT_ID) },
+	{ }					/* Terminating entry */
+};
+
+MODULE_DEVICE_TABLE (usb, tower_table);
+
+#define LEGO_USB_TOWER_MINOR_BASE	160
+
+/* we can have up to this number of device plugged in at once */
+#define MAX_DEVICES		16
+
+#define COMMAND_TIMEOUT		(2*HZ)  /* 2 second timeout for a command */
+
+/* Structure to hold all of our device specific stuff */
+struct lego_usb_tower {
+	struct semaphore	sem;		/* locks this structure */
+	struct usb_device* 	udev;		/* save off the usb device pointer */
+	struct usb_interface*   interface;
+	unsigned char		minor;		/* the starting minor number for this device */
+
+	int			open_count;	/* number of times this port has been opened */
+
+	char*			read_buffer;
+	int			read_buffer_length;
+
+	wait_queue_head_t	read_wait;
+	wait_queue_head_t	write_wait;
+
+	char*			interrupt_in_buffer;
+	struct usb_endpoint_descriptor* interrupt_in_endpoint;
+	struct urb*		interrupt_in_urb;
+
+	char*			interrupt_out_buffer;
+	struct usb_endpoint_descriptor* interrupt_out_endpoint;
+	struct urb*		interrupt_out_urb;
+
+};
+
+/* Note that no locking is needed:
+ * read_buffer is arbitrated by read_buffer_length == 0
+ * interrupt_out_buffer is arbitrated by interrupt_out_urb->status == -EINPROGRESS
+ * interrupt_in_buffer belongs to urb alone and is overwritten on overflow
+ */
+
+/* local function prototypes */
+static ssize_t tower_read	(struct file *file, char *buffer, size_t count, loff_t *ppos);
+static ssize_t tower_write	(struct file *file, const char *buffer, size_t count, loff_t *ppos);
+static inline void tower_delete (struct lego_usb_tower *dev);
+static int tower_open		(struct inode *inode, struct file *file);
+static int tower_release	(struct inode *inode, struct file *file);
+static int tower_release_internal (struct lego_usb_tower *dev);
+static void tower_abort_transfers (struct lego_usb_tower *dev);
+static void tower_interrupt_in_callback (struct urb *urb, struct pt_regs *regs);
+static void tower_interrupt_out_callback (struct urb *urb, struct pt_regs *regs);
+
+static int  tower_probe	(struct usb_interface *interface, const struct usb_device_id *id);
+static void tower_disconnect	(struct usb_interface *interface);
+
+
+/* prevent races between open() and disconnect */
+static DECLARE_MUTEX (disconnect_sem);
+
+/* file operations needed when we register this driver */
+static struct file_operations tower_fops = {
+	.owner = 	THIS_MODULE,
+	.read  = 	tower_read,
+	.write =	tower_write,
+	.open =		tower_open,
+	.release = 	tower_release,
+};
+
+/* 
+ * usb class driver info in order to get a minor number from the usb core,
+ * and to have the device registered with devfs and the driver core
+ */
+static struct usb_class_driver tower_class = {
+	.name =		"usb/legousbtower%d",
+	.fops =		&tower_fops,
+	.mode =		S_IFCHR | S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH,
+	.minor_base =	LEGO_USB_TOWER_MINOR_BASE,
+};
+
+
+/* usb specific object needed to register this driver with the usb subsystem */
+static struct usb_driver tower_driver = {
+	.owner =        THIS_MODULE,
+	.name =	        "legousbtower",
+	.probe = 	tower_probe,
+	.disconnect = 	tower_disconnect,
+	.id_table = 	tower_table,
+};
+
+
+/**
+ *	lego_usb_tower_debug_data
+ */
+static inline void lego_usb_tower_debug_data (int level, const char *function, int size, const unsigned char *data)
+{
+	int i;
+
+	if (debug < level)
+		return; 
+	
+	printk (KERN_DEBUG __FILE__": %s - length = %d, data = ", function, size);
+	for (i = 0; i < size; ++i) {
+		printk ("%.2x ", data[i]);
+	}
+	printk ("\n");
+}
+
+
+/**
+ *	tower_delete
+ */
+static inline void tower_delete (struct lego_usb_tower *dev)
+{
+	dbg(2, "%s enter", __func__);
+
+	tower_abort_transfers (dev);
+
+	/* free data structures */
+	if (dev->interrupt_in_urb != NULL) {
+		usb_free_urb (dev->interrupt_in_urb);
+	}
+	if (dev->interrupt_out_urb != NULL) {
+		usb_free_urb (dev->interrupt_out_urb);
+	}
+	kfree (dev->read_buffer);
+	kfree (dev->interrupt_in_buffer);
+	kfree (dev->interrupt_out_buffer);
+	kfree (dev);
+
+	dbg(2, "%s : leave", __func__);
+}
+
+
+/**
+ *	tower_open
+ */
+static int tower_open (struct inode *inode, struct file *file)
+{
+	struct lego_usb_tower *dev = NULL;
+	int subminor;
+	int retval = 0;
+	struct usb_interface *interface;
+
+	dbg(2,"%s : enter", __func__);
+
+	subminor = iminor(inode);
+
+	down (&disconnect_sem);
+
+	interface = usb_find_interface (&tower_driver, subminor);
+
+	if (!interface) {
+		err ("%s - error, can't find device for minor %d",
+		     __FUNCTION__, subminor);
+		retval = -ENODEV;
+		goto exit_no_device;
+	}
+
+	dev = usb_get_intfdata(interface);
+
+	if (!dev) {
+		retval = -ENODEV;
+		goto exit_no_device;
+	}
+
+	/* lock this device */
+	down (&dev->sem);
+
+	
+	/* increment our usage count for the device */
+	++dev->open_count;
+
+	/* save device in the file's private structure */
+	file->private_data = dev;
+
+
+	/* initialize in direction */
+	dev->read_buffer_length = 0;
+
+	up (&dev->sem);
+
+exit_no_device:
+
+	up (&disconnect_sem);
+
+	dbg(2,"%s : leave, return value %d ", __func__, retval);
+
+	return retval;
+}
+
+/**
+ *	tower_release
+ */
+static int tower_release (struct inode *inode, struct file *file)
+{
+	struct lego_usb_tower *dev;
+	int retval = 0;
+
+	dbg(2," %s : enter", __func__);
+
+	dev = (struct lego_usb_tower *)file->private_data;
+
+	if (dev == NULL) {
+		dbg(1," %s : object is NULL", __func__);
+		retval = -ENODEV;
+		goto exit;
+	}
+
+
+	/* lock our device */
+	down (&dev->sem);
+
+ 	if (dev->open_count <= 0) {
+		dbg(1," %s : device not opened", __func__);
+		retval = -ENODEV;
+		goto exit;
+	}
+
+	/* do the work */
+	retval = tower_release_internal (dev);
+
+exit:
+	up (&dev->sem);
+	dbg(2," %s : leave, return value %d", __func__, retval);
+	return retval;
+}
+
+
+/**
+ *	tower_release_internal
+ */
+static int tower_release_internal (struct lego_usb_tower *dev)
+{
+	int retval = 0;
+
+	dbg(2," %s : enter", __func__);
+
+	if (dev->udev == NULL) {
+		/* the device was unplugged before the file was released */
+		tower_delete (dev);
+		goto exit;
+	}
+
+	/* decrement our usage count for the device */
+	--dev->open_count;
+	if (dev->open_count <= 0) {
+		tower_abort_transfers (dev);
+		dev->open_count = 0;
+	}
+
+exit:
+	dbg(2," %s : leave", __func__);
+	return retval;
+}
+
+
+/**
+ *	tower_abort_transfers
+ *      aborts transfers and frees associated data structures
+ */
+static void tower_abort_transfers (struct lego_usb_tower *dev)
+{
+	dbg(2," %s : enter", __func__);
+
+	if (dev == NULL) {
+		dbg(1," %s : dev is null", __func__);
+	        goto exit;
+	}
+
+	/* shutdown transfer */
+	if (dev->interrupt_in_urb != NULL) {
+		usb_unlink_urb (dev->interrupt_in_urb);
+	}
+	if (dev->interrupt_out_urb != NULL) {
+		usb_unlink_urb (dev->interrupt_out_urb);
+	}
+
+exit:
+	dbg(2," %s : leave", __func__);
+}
+
+
+/**
+ *	tower_read
+ */
+static ssize_t tower_read (struct file *file, char *buffer, size_t count, loff_t *ppos)
+{
+	struct lego_usb_tower *dev;
+	size_t bytes_read = 0;
+	size_t bytes_to_read;
+	int i;
+	int retval = 0;
+	int timeout = 0;
+
+	dbg(2," %s : enter, count = %Zd", __func__, count);
+
+	dev = (struct lego_usb_tower *)file->private_data;
+	
+	/* lock this object */
+	down (&dev->sem);
+
+	/* verify that the device wasn't unplugged */
+	if (dev->udev == NULL) {
+		retval = -ENODEV;
+		err("No device or device unplugged %d", retval);
+		goto exit;
+	}
+
+	/* verify that we actually have some data to read */
+	if (count == 0) {
+		dbg(1," %s : read request of 0 bytes", __func__);
+		goto exit;
+	}
+
+
+	timeout = COMMAND_TIMEOUT;
+
+	while (1) {
+		if (dev->read_buffer_length == 0) {
+
+			/* start reading */
+			usb_fill_int_urb (dev->interrupt_in_urb,dev->udev,
+					  usb_rcvintpipe(dev->udev, dev->interrupt_in_endpoint->bEndpointAddress),
+					  dev->interrupt_in_buffer,
+					  dev->interrupt_in_endpoint->wMaxPacketSize,
+					  tower_interrupt_in_callback,
+					  dev,
+					  dev->interrupt_in_endpoint->bInterval);
+			
+			retval = usb_submit_urb (dev->interrupt_in_urb, GFP_KERNEL);
+			
+			if (retval < 0) {
+				err("Couldn't submit interrupt_in_urb");
+				goto exit;
+			}
+
+			if (timeout <= 0) {
+			        retval = -ETIMEDOUT;
+			        goto exit;
+			}
+
+			if (signal_pending(current)) {
+				retval = -EINTR;
+				goto exit;
+			}
+
+			up (&dev->sem);
+			timeout = interruptible_sleep_on_timeout (&dev->read_wait, timeout);
+			down (&dev->sem);
+
+		} else {
+			/* copy the data from read_buffer into userspace */
+			bytes_to_read = count > dev->read_buffer_length ? dev->read_buffer_length : count;
+			if (copy_to_user (buffer, dev->read_buffer, bytes_to_read) != 0) {
+				retval = -EFAULT;
+				goto exit;
+			}
+			dev->read_buffer_length -= bytes_to_read;
+			for (i=0; i<dev->read_buffer_length; i++) {
+				dev->read_buffer[i] = dev->read_buffer[i+bytes_to_read];
+			}
+
+			buffer += bytes_to_read;
+			count -= bytes_to_read;
+			bytes_read += bytes_to_read;
+			if (count == 0) {
+				break;
+			}
+		}
+	}
+
+	retval = bytes_read;
+
+exit:
+	/* unlock the device */
+	up (&dev->sem);
+
+	dbg(2," %s : leave, return value %d", __func__, retval);
+	return retval;
+}
+
+
+/**
+ *	tower_write
+ */
+static ssize_t tower_write (struct file *file, const char *buffer, size_t count, loff_t *ppos)
+{
+	struct lego_usb_tower *dev;
+	size_t bytes_written = 0;
+	size_t bytes_to_write;
+	size_t buffer_size;
+	int retval = 0;
+	int timeout = 0;
+
+	dbg(2," %s : enter, count = %Zd", __func__, count);
+
+	dev = (struct lego_usb_tower *)file->private_data;
+
+	/* lock this object */
+	down (&dev->sem);
+
+	/* verify that the device wasn't unplugged */
+	if (dev->udev == NULL) {
+		retval = -ENODEV;
+		err("No device or device unplugged %d", retval);
+		goto exit;
+	}
+
+	/* verify that we actually have some data to write */
+	if (count == 0) {
+		dbg(1," %s : write request of 0 bytes", __func__);
+		goto exit;
+	}
+
+
+	while (count > 0) {
+		if (dev->interrupt_out_urb->status == -EINPROGRESS) {
+			timeout = COMMAND_TIMEOUT;
+
+			while (timeout > 0) {
+				if (signal_pending(current)) {
+					dbg(1," %s : interrupted", __func__);
+					retval = -EINTR;
+					goto exit;
+				}
+				up (&dev->sem);
+				timeout = interruptible_sleep_on_timeout (&dev->write_wait, timeout);
+				down (&dev->sem);
+				if (timeout > 0) {
+					break;
+				}
+				dbg(1," %s : interrupted timeout: %d", __func__, timeout);
+			}
+
+
+			dbg(1," %s : final timeout: %d", __func__, timeout);
+
+			if (timeout == 0) {
+				dbg(1, "%s - command timed out.", __func__);
+				retval = -ETIMEDOUT;
+				goto exit;
+			}
+
+			dbg(4," %s : in progress, count = %Zd", __func__, count);
+		} else {
+			dbg(4," %s : sending, count = %Zd", __func__, count);
+
+			/* write the data into interrupt_out_buffer from userspace */
+			buffer_size = dev->interrupt_out_endpoint->wMaxPacketSize;
+			bytes_to_write = count > buffer_size ? buffer_size : count;
+			dbg(4," %s : buffer_size = %Zd, count = %Zd, bytes_to_write = %Zd", __func__, buffer_size, count, bytes_to_write);
+
+			if (copy_from_user (dev->interrupt_out_buffer, buffer, bytes_to_write) != 0) {
+				retval = -EFAULT;
+				goto exit;
+			}
+
+			/* send off the urb */
+			usb_fill_int_urb(dev->interrupt_out_urb,
+					dev->udev, 
+					usb_sndintpipe(dev->udev, dev->interrupt_out_endpoint->bEndpointAddress),
+					dev->interrupt_out_buffer,
+					bytes_to_write,
+					tower_interrupt_out_callback,
+					dev,
+					dev->interrupt_in_endpoint->bInterval);
+
+			dev->interrupt_out_urb->actual_length = bytes_to_write;
+			retval = usb_submit_urb (dev->interrupt_out_urb, GFP_KERNEL);
+
+			if (retval < 0) {
+				err("Couldn't submit interrupt_out_urb %d", retval);
+				goto exit;
+			}
+
+			buffer += bytes_to_write;
+			count -= bytes_to_write;
+
+			bytes_written += bytes_to_write;
+		}
+	}
+
+	retval = bytes_written;
+
+exit:
+	/* unlock the device */
+	up (&dev->sem);
+
+	dbg(2," %s : leave, return value %d", __func__, retval);
+
+	return retval;
+}
+
+
+/**
+ *	tower_interrupt_in_callback
+ */
+static void tower_interrupt_in_callback (struct urb *urb, struct pt_regs *regs)
+{
+	struct lego_usb_tower *dev = (struct lego_usb_tower *)urb->context;
+
+	dbg(4," %s : enter, status %d", __func__, urb->status);
+
+	lego_usb_tower_debug_data(5,__func__, urb->actual_length, urb->transfer_buffer);
+
+	if (urb->status != 0) {
+		if ((urb->status != -ENOENT) && (urb->status != -ECONNRESET)) {
+			dbg(1," %s : nonzero status received: %d", __func__, urb->status);
+		}
+		goto exit;
+	}
+
+	down (&dev->sem);
+
+	if (urb->actual_length > 0) {
+		if (dev->read_buffer_length < (4 * dev->interrupt_in_endpoint->wMaxPacketSize) - (urb->actual_length)) {
+
+			memcpy (dev->read_buffer+dev->read_buffer_length, dev->interrupt_in_buffer, urb->actual_length);
+
+			dev->read_buffer_length += urb->actual_length;
+			dbg(1," %s reading  %d ", __func__, urb->actual_length);
+			wake_up_interruptible (&dev->read_wait);
+
+		} else {
+			dbg(1," %s : read_buffer overflow", __func__);
+		}
+	}
+
+	up (&dev->sem);
+
+exit:
+	lego_usb_tower_debug_data(5,__func__, urb->actual_length, urb->transfer_buffer);
+	dbg(4," %s : leave, status %d", __func__, urb->status);
+}
+
+
+/**
+ *	tower_interrupt_out_callback
+ */
+static void tower_interrupt_out_callback (struct urb *urb, struct pt_regs *regs)
+{
+	struct lego_usb_tower *dev = (struct lego_usb_tower *)urb->context;
+
+	dbg(4," %s : enter, status %d", __func__, urb->status);
+	lego_usb_tower_debug_data(5,__func__, urb->actual_length, urb->transfer_buffer);
+
+	if (urb->status != 0) {
+		if ((urb->status != -ENOENT) && 
+		    (urb->status != -ECONNRESET)) {
+			dbg(1, " %s :nonzero status received: %d", __func__, urb->status);
+		}
+		goto exit;
+	}                        
+
+	wake_up_interruptible(&dev->write_wait);
+exit:
+
+	lego_usb_tower_debug_data(5,__func__, urb->actual_length, urb->transfer_buffer);
+	dbg(4," %s : leave, status %d", __func__, urb->status);
+}
+
+
+/**
+ *	tower_probe
+ *
+ *	Called by the usb core when a new device is connected that it thinks
+ *	this driver might be interested in.
+ */
+static int tower_probe (struct usb_interface *interface, const struct usb_device_id *id)
+{
+	struct usb_device *udev = interface_to_usbdev(interface);
+	struct lego_usb_tower *dev = NULL;
+	struct usb_host_interface *iface_desc;
+	struct usb_endpoint_descriptor* endpoint;
+	int i;
+	int retval = -ENOMEM;
+
+	dbg(2," %s : enter", __func__);
+
+	if (udev == NULL) {
+		info ("udev is NULL.");
+	}
+	
+	/* See if the device offered us matches what we can accept */
+	if ((udev->descriptor.idVendor != LEGO_USB_TOWER_VENDOR_ID) ||
+	    (udev->descriptor.idProduct != LEGO_USB_TOWER_PRODUCT_ID)) {
+		return -ENODEV;
+	}
+
+
+	/* allocate memory for our device state and intialize it */
+
+	dev = kmalloc (sizeof(struct lego_usb_tower), GFP_KERNEL);
+
+	if (dev == NULL) {
+		err ("Out of memory");
+		goto exit;
+	}
+
+	init_MUTEX (&dev->sem);
+
+	dev->udev = udev;
+	dev->open_count = 0;
+
+	dev->read_buffer = NULL;
+	dev->read_buffer_length = 0;
+
+	init_waitqueue_head (&dev->read_wait);
+	init_waitqueue_head (&dev->write_wait);
+
+	dev->interrupt_in_buffer = NULL;
+	dev->interrupt_in_endpoint = NULL;
+	dev->interrupt_in_urb = NULL;
+
+	dev->interrupt_out_buffer = NULL;
+	dev->interrupt_out_endpoint = NULL;
+	dev->interrupt_out_urb = NULL;
+
+
+	iface_desc = &interface->altsetting[0];
+
+	/* set up the endpoint information */
+	for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {
+		endpoint = &iface_desc->endpoint[i].desc;
+
+		if (((endpoint->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN) &&
+		    ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_INT)) {
+			dev->interrupt_in_endpoint = endpoint;
+		}
+		
+		if (((endpoint->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT) &&
+		    ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_INT)) {
+			dev->interrupt_out_endpoint = endpoint;
+		}
+	}
+	if(dev->interrupt_in_endpoint == NULL) {
+		err("interrupt in endpoint not found");
+		goto error;
+	}
+	if (dev->interrupt_out_endpoint == NULL) {
+		err("interrupt out endpoint not found");
+		goto error;
+	}
+
+	dev->read_buffer = kmalloc ((4*dev->interrupt_in_endpoint->wMaxPacketSize), GFP_KERNEL);
+	if (!dev->read_buffer) {
+		err("Couldn't allocate read_buffer");
+		goto error;
+	}
+	dev->interrupt_in_buffer = kmalloc (dev->interrupt_in_endpoint->wMaxPacketSize, GFP_KERNEL);
+	if (!dev->interrupt_in_buffer) {
+		err("Couldn't allocate interrupt_in_buffer");
+		goto error;
+	}
+	dev->interrupt_in_urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (!dev->interrupt_in_urb) {
+		err("Couldn't allocate interrupt_in_urb");
+		goto error;
+	}
+	dev->interrupt_out_buffer = kmalloc (dev->interrupt_out_endpoint->wMaxPacketSize, GFP_KERNEL);
+	if (!dev->interrupt_out_buffer) {
+		err("Couldn't allocate interrupt_out_buffer");
+		goto error;
+	}
+	dev->interrupt_out_urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (!dev->interrupt_out_urb) {
+		err("Couldn't allocate interrupt_out_urb");
+		goto error;
+	}                
+
+	/* we can register the device now, as it is ready */
+	usb_set_intfdata (interface, dev);
+
+	retval = usb_register_dev (interface, &tower_class);
+
+	if (retval) {
+		/* something prevented us from registering this driver */
+		err ("Not able to get a minor for this device.");
+		usb_set_intfdata (interface, NULL);
+		goto error;
+	}
+
+	dev->minor = interface->minor;
+
+	/* let the user know what node this device is now attached to */
+	info ("LEGO USB Tower device now attached to /dev/usb/lego%d", (dev->minor - LEGO_USB_TOWER_MINOR_BASE));
+
+
+
+exit:
+	dbg(2," %s : leave, return value 0x%.8lx (dev)", __func__, (long) dev);
+
+	return retval;
+
+error:
+	tower_delete(dev);
+	return retval;
+}
+
+
+/**
+ *	tower_disconnect
+ *
+ *	Called by the usb core when the device is removed from the system.
+ */
+static void tower_disconnect (struct usb_interface *interface)
+{
+	struct lego_usb_tower *dev;
+	int minor;
+
+	dbg(2," %s : enter", __func__);
+
+	down (&disconnect_sem);
+
+	dev = usb_get_intfdata (interface);
+	usb_set_intfdata (interface, NULL);
+
+
+	down (&dev->sem);
+
+	minor = dev->minor;
+
+	/* give back our minor */
+	usb_deregister_dev (interface, &tower_class);
+
+	/* if the device is not opened, then we clean up right now */
+	if (!dev->open_count) {
+		up (&dev->sem);
+		tower_delete (dev);
+	} else {
+		dev->udev = NULL;
+		up (&dev->sem);
+	}
+
+	up (&disconnect_sem);
+
+	info("LEGO USB Tower #%d now disconnected", (minor - LEGO_USB_TOWER_MINOR_BASE));
+
+	dbg(2," %s : leave", __func__);
+}
+
+
+
+/**
+ *	lego_usb_tower_init
+ */
+static int __init lego_usb_tower_init(void)
+{
+	int result;
+	int retval = 0;
+
+	dbg(2," %s : enter", __func__);
+
+	/* register this driver with the USB subsystem */
+	result = usb_register(&tower_driver);
+	if (result < 0) {
+		err("usb_register failed for the "__FILE__" driver. Error number %d", result);
+		retval = -1;
+		goto exit;
+	}
+
+	info(DRIVER_DESC " " DRIVER_VERSION);
+
+exit:
+	dbg(2," %s : leave, return value %d", __func__, retval);
+
+	return retval;
+}
+
+
+/**
+ *	lego_usb_tower_exit
+ */
+static void __exit lego_usb_tower_exit(void)
+{
+	dbg(2," %s : enter", __func__);
+
+	/* deregister this driver with the USB subsystem */
+	usb_deregister (&tower_driver);
+
+	dbg(2," %s : leave", __func__);
+}
+
+module_init (lego_usb_tower_init);
+module_exit (lego_usb_tower_exit);
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+#ifdef MODULE_LICENSE
+MODULE_LICENSE("GPL");
+#endif
diff -purN linux-2.5/drivers/usb/net/Kconfig usb-2.5/drivers/usb/net/Kconfig
--- linux-2.5/drivers/usb/net/Kconfig	2003-09-27 10:23:06.000000000 +0000
+++ usb-2.5/drivers/usb/net/Kconfig	2003-12-12 12:27:30.000000000 +0000
@@ -247,7 +247,7 @@ comment "USB Network Adapters"
 
 config USB_AX8817X
 	boolean "ASIX AX88172 Based USB 2.0 Ethernet Devices"
-	depends on USB_USBNET && EXPERIMENTAL
+	depends on USB_USBNET
 	default y
 	help
 
diff -purN linux-2.5/drivers/usb/net/pegasus.h usb-2.5/drivers/usb/net/pegasus.h
--- linux-2.5/drivers/usb/net/pegasus.h	2003-06-10 22:21:55.000000000 +0000
+++ usb-2.5/drivers/usb/net/pegasus.h	2003-12-12 10:30:58.000000000 +0000
@@ -137,6 +137,7 @@ struct usb_eth_dev {
 #define	VENDOR_MELCO		0x0411
 #define	VENDOR_MOBILITY		0x1342
 #define	VENDOR_NETGEAR		0x0846
+#define	VENDOR_OCT		0x0b39
 #define	VENDOR_SMARTBRIDGES	0x08d1
 #define	VENDOR_SMC		0x0707
 #define	VENDOR_SOHOWARE		0x15e8
@@ -173,7 +174,7 @@ PEGASUS_DEV( "SpeedStream USB 10/100 Eth
 		DEFAULT_GPIO_RESET | PEGASUS_II )
 PEGASUS_DEV( "ADMtek ADM8511 \"Pegasus II\" USB Ethernet",
 		VENDOR_ADMTEK, 0x8511,
-		DEFAULT_GPIO_RESET | PEGASUS_II )
+		DEFAULT_GPIO_RESET | PEGASUS_II | HAS_HOME_PNA )
 PEGASUS_DEV( "ADMtek ADM8513 \"Pegasus II\" USB Ethernet",
 		VENDOR_ADMTEK, 0x8513,
 		DEFAULT_GPIO_RESET | PEGASUS_II )
@@ -260,6 +261,8 @@ PEGASUS_DEV( "MELCO/BUFFALO LUA2-TX", VE
 		DEFAULT_GPIO_RESET | PEGASUS_II )
 PEGASUS_DEV( "NETGEAR FA101", VENDOR_NETGEAR, 0x1020,
 		DEFAULT_GPIO_RESET | PEGASUS_II )
+PEGASUS_DEV( "OCT Inc.", VENDOR_OCT, 0x0109,
+		DEFAULT_GPIO_RESET | PEGASUS_II )
 PEGASUS_DEV( "smartNIC 2 PnP Adapter", VENDOR_SMARTBRIDGES, 0x0003,
 		DEFAULT_GPIO_RESET | PEGASUS_II )
 PEGASUS_DEV( "SMC 202 USB Ethernet", VENDOR_SMC, 0x0200,
diff -purN linux-2.5/drivers/usb/net/usbnet.c usb-2.5/drivers/usb/net/usbnet.c
--- linux-2.5/drivers/usb/net/usbnet.c	2003-11-03 13:05:44.000000000 +0000
+++ usb-2.5/drivers/usb/net/usbnet.c	2003-11-11 00:44:27.000000000 +0000
@@ -909,8 +909,7 @@ static int cdc_bind (struct usbnet *dev,
 	memset (info, 0, sizeof *info);
 	info->control = intf;
 	while (len > 3) {
-		/* ignore bDescriptorType != CS_INTERFACE */
-		if (buf [1] != 0x24)
+		if (buf [1] != USB_DT_CS_INTERFACE)
 			goto next_desc;
 
 		/* bDescriptorSubType identifies three "must have" descriptors;
diff -purN linux-2.5/drivers/usb/serial/cyberjack.c usb-2.5/drivers/usb/serial/cyberjack.c
--- linux-2.5/drivers/usb/serial/cyberjack.c	2003-08-25 10:18:48.000000000 +0000
+++ usb-2.5/drivers/usb/serial/cyberjack.c	2003-12-02 19:58:58.000000000 +0000
@@ -295,7 +295,6 @@ static void cyberjack_read_int_callback(
 {
 	struct usb_serial_port *port = (struct usb_serial_port *)urb->context;
 	struct cyberjack_private *priv = usb_get_serial_port_data(port);
-	unsigned long flags;
 	struct usb_serial *serial;
 	unsigned char *data = urb->transfer_buffer;
 	int result;
@@ -323,13 +322,13 @@ static void cyberjack_read_int_callback(
 		/* This is a announcement of coming bulk_ins. */
 		unsigned short size = ((unsigned short)data[3]<<8)+data[2]+3;
 
-		spin_lock_irqsave(&priv->lock, flags);
+		spin_lock(&priv->lock);
 
 		old_rdtodo = priv->rdtodo;
 
 		if( (old_rdtodo+size)<(old_rdtodo) ) {
 			dbg( "To many bulk_in urbs to do." );
-			spin_unlock_irqrestore(&priv->lock, flags);
+			spin_unlock(&priv->lock);
 			goto resubmit;
 		}
 
@@ -338,11 +337,11 @@ static void cyberjack_read_int_callback(
 
 		dbg("%s - rdtodo: %d", __FUNCTION__, priv->rdtodo);
 
-		spin_unlock_irqrestore(&priv->lock, flags);
+		spin_unlock(&priv->lock);
 
 		if( !old_rdtodo ) {
 			port->read_urb->dev = port->serial->dev;
-			result = usb_submit_urb(port->read_urb, GFP_KERNEL);
+			result = usb_submit_urb(port->read_urb, GFP_ATOMIC);
 			if( result )
 				err("%s - failed resubmitting read urb, error %d", __FUNCTION__, result);
 			dbg("%s - usb_submit_urb(read urb)", __FUNCTION__);
@@ -351,7 +350,7 @@ static void cyberjack_read_int_callback(
 
 resubmit:
 	port->interrupt_in_urb->dev = port->serial->dev;
-	result = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
+	result = usb_submit_urb(port->interrupt_in_urb, GFP_ATOMIC);
 	if (result)
 		err(" usb_submit_urb(read int) failed");
 	dbg("%s - usb_submit_urb(int urb)", __FUNCTION__);
@@ -361,7 +360,6 @@ static void cyberjack_read_bulk_callback
 {
 	struct usb_serial_port *port = (struct usb_serial_port *)urb->context;
 	struct cyberjack_private *priv = usb_get_serial_port_data(port);
-	unsigned long flags;
 	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
 	struct tty_struct *tty;
 	unsigned char *data = urb->transfer_buffer;
@@ -397,7 +395,7 @@ static void cyberjack_read_bulk_callback
 	  	tty_flip_buffer_push(tty);
 	}
 
-	spin_lock_irqsave(&priv->lock, flags);
+	spin_lock(&priv->lock);
 
 	/* Reduce urbs to do by one. */
 	priv->rdtodo-=urb->actual_length;
@@ -405,14 +403,14 @@ static void cyberjack_read_bulk_callback
 	if ( priv->rdtodo<0 ) priv->rdtodo = 0;
 	todo = priv->rdtodo;
 
-	spin_unlock_irqrestore(&priv->lock, flags);
+	spin_unlock(&priv->lock);
 
 	dbg("%s - rdtodo: %d", __FUNCTION__, todo);
 
 	/* Continue to read if we have still urbs to do. */
 	if( todo /* || (urb->actual_length==port->bulk_in_endpointAddress)*/ ) {
 		port->read_urb->dev = port->serial->dev;
-		result = usb_submit_urb(port->read_urb, GFP_KERNEL);
+		result = usb_submit_urb(port->read_urb, GFP_ATOMIC);
 		if (result)
 			err("%s - failed resubmitting read urb, error %d", __FUNCTION__, result);
 		dbg("%s - usb_submit_urb(read urb)", __FUNCTION__);
@@ -423,7 +421,6 @@ static void cyberjack_write_bulk_callbac
 {
 	struct usb_serial_port *port = (struct usb_serial_port *)urb->context;
 	struct cyberjack_private *priv = usb_get_serial_port_data(port);
-	unsigned long flags;
 	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
 
 	dbg("%s - port %d", __FUNCTION__, port->number);
@@ -438,7 +435,7 @@ static void cyberjack_write_bulk_callbac
 		return;
 	}
 
-	spin_lock_irqsave(&priv->lock, flags);
+	spin_lock(&priv->lock);
 
 	/* only do something if we have more data to send */
 	if( priv->wrfilled ) {
@@ -446,7 +443,7 @@ static void cyberjack_write_bulk_callbac
 
 		if (port->write_urb->status == -EINPROGRESS) {
 			dbg("%s - already writing", __FUNCTION__);
-			spin_unlock_irqrestore(&priv->lock, flags);
+			spin_unlock(&priv->lock);
 			return;
 		}
 
@@ -492,7 +489,7 @@ static void cyberjack_write_bulk_callbac
 	}
 
 exit:
-	spin_unlock_irqrestore(&priv->lock, flags);
+	spin_unlock(&priv->lock);
 	schedule_work(&port->work);
 }
 
diff -purN linux-2.5/drivers/usb/serial/ftdi_sio.c usb-2.5/drivers/usb/serial/ftdi_sio.c
--- linux-2.5/drivers/usb/serial/ftdi_sio.c	2003-10-21 13:19:15.000000000 +0000
+++ usb-2.5/drivers/usb/serial/ftdi_sio.c	2003-10-28 21:43:44.000000000 +0000
@@ -342,6 +342,10 @@ static struct usb_device_id id_table_8U2
 	{ USB_DEVICE_VER(SEALEVEL_VID, SEALEVEL_2803_8_PID, 0, 0x3ff) },
 	{ USB_DEVICE_VER(IDTECH_VID, IDTECH_IDT1221U_PID, 0, 0x3ff) },
 	{ USB_DEVICE_VER(OCT_VID, OCT_US101_PID, 0, 0x3ff) },
+	{ USB_DEVICE_VER(FTDI_VID, PROTEGO_SPECIAL_1, 0, 0x3ff) },
+	{ USB_DEVICE_VER(FTDI_VID, PROTEGO_R2X0, 0, 0x3ff) },
+	{ USB_DEVICE_VER(FTDI_VID, PROTEGO_SPECIAL_3, 0, 0x3ff) },
+	{ USB_DEVICE_VER(FTDI_VID, PROTEGO_SPECIAL_4, 0, 0x3ff) },
 	{ }						/* Terminating entry */
 };
 
@@ -416,6 +420,10 @@ static struct usb_device_id id_table_FT2
 	{ USB_DEVICE_VER(SEALEVEL_VID, SEALEVEL_2803_8_PID, 0x400, 0xffff) },
 	{ USB_DEVICE_VER(IDTECH_VID, IDTECH_IDT1221U_PID, 0x400, 0xffff) },
 	{ USB_DEVICE_VER(OCT_VID, OCT_US101_PID, 0x400, 0xffff) },
+	{ USB_DEVICE_VER(FTDI_VID, PROTEGO_SPECIAL_1, 0x400, 0xffff) },
+	{ USB_DEVICE_VER(FTDI_VID, PROTEGO_R2X0, 0x400, 0xffff) },
+	{ USB_DEVICE_VER(FTDI_VID, PROTEGO_SPECIAL_3, 0x400, 0xffff) },
+	{ USB_DEVICE_VER(FTDI_VID, PROTEGO_SPECIAL_4, 0x400, 0xffff) },
 	{ }						/* Terminating entry */
 };
 
@@ -505,6 +513,10 @@ static struct usb_device_id id_table_com
 	{ USB_DEVICE(OCT_VID, OCT_US101_PID) },
 	{ USB_DEVICE_VER(FTDI_VID, FTDI_HE_TIRA1_PID, 0x400, 0xffff) },
 	{ USB_DEVICE(FTDI_VID, FTDI_USB_UIRT_PID) },
+	{ USB_DEVICE(FTDI_VID, PROTEGO_SPECIAL_1) },
+	{ USB_DEVICE(FTDI_VID, PROTEGO_R2X0) },
+	{ USB_DEVICE(FTDI_VID, PROTEGO_SPECIAL_3) },
+	{ USB_DEVICE(FTDI_VID, PROTEGO_SPECIAL_4) },
 	{ }						/* Terminating entry */
 };
 
diff -purN linux-2.5/drivers/usb/serial/ftdi_sio.h usb-2.5/drivers/usb/serial/ftdi_sio.h
--- linux-2.5/drivers/usb/serial/ftdi_sio.h	2003-10-21 13:19:15.000000000 +0000
+++ usb-2.5/drivers/usb/serial/ftdi_sio.h	2003-10-28 21:43:44.000000000 +0000
@@ -145,6 +145,14 @@
 /* Note: OCT US101 is also rebadged as Dick Smith Electronics (NZ) XH6381 */
 #define OCT_US101_PID		0x0421	/* OCT US101 USB to RS-232 */
 
+/*
+ * Protego product ids
+ */
+#define PROTEGO_SPECIAL_1	0xFC70	/* special/unknown device */
+#define PROTEGO_R2X0		0xFC71	/* R200-USB TRNG unit (R210, R220, and R230) */
+#define PROTEGO_SPECIAL_3	0xFC72	/* special/unknown device */
+#define PROTEGO_SPECIAL_4	0xFC73	/* special/unknown device */ 
+
 /* Commands */
 #define FTDI_SIO_RESET 		0 /* Reset the port */
 #define FTDI_SIO_MODEM_CTRL 	1 /* Set the modem control register */
diff -purN linux-2.5/drivers/usb/serial/io_edgeport.c usb-2.5/drivers/usb/serial/io_edgeport.c
--- linux-2.5/drivers/usb/serial/io_edgeport.c	2003-10-23 13:13:25.000000000 +0000
+++ usb-2.5/drivers/usb/serial/io_edgeport.c	2003-12-12 10:33:27.000000000 +0000
@@ -1488,16 +1488,20 @@ static void send_more_port_data(struct e
 		       usb_sndbulkpipe(edge_serial->serial->dev, edge_serial->bulk_out_endpoint),
 		       buffer, count+2, edge_bulk_out_data_callback, edge_port);
 
+	/* decrement the number of credits we have by the number we just sent */
+	edge_port->txCredits -= count;
+	edge_port->icount.tx += count;
+
 	urb->dev = edge_serial->serial->dev;
 	status = usb_submit_urb(urb, GFP_ATOMIC);
 	if (status) {
 		/* something went wrong */
 		dbg("%s - usb_submit_urb(write bulk) failed", __FUNCTION__);
 		edge_port->write_in_progress = FALSE;
-	} else {
-		/* decrement the number of credits we have by the number we just sent */
-		edge_port->txCredits -= count;
-		edge_port->icount.tx += count;
+
+		/* revert the credits as something bad happened. */
+		edge_port->txCredits += count;
+		edge_port->icount.tx -= count;
 	}
 	dbg("%s wrote %d byte(s) TxCredit %d, Fifo %d", __FUNCTION__, count, edge_port->txCredits, fifo->count);
 }
diff -purN linux-2.5/drivers/usb/serial/io_fw_boot.h usb-2.5/drivers/usb/serial/io_fw_boot.h
--- linux-2.5/drivers/usb/serial/io_fw_boot.h	2003-08-27 11:45:13.000000000 +0000
+++ usb-2.5/drivers/usb/serial/io_fw_boot.h	2003-10-21 10:14:55.000000000 +0000
@@ -17,7 +17,7 @@
 		unsigned short Addr;
 		unsigned short Len;
 		unsigned char  Data[0];
-	};
+	} __attribute__ ((packed));
 
 	struct edge_firmware_version_info {
 		unsigned char	 MajorVersion;
diff -purN linux-2.5/drivers/usb/serial/io_fw_boot2.h usb-2.5/drivers/usb/serial/io_fw_boot2.h
--- linux-2.5/drivers/usb/serial/io_fw_boot2.h	2003-08-27 11:45:14.000000000 +0000
+++ usb-2.5/drivers/usb/serial/io_fw_boot2.h	2003-10-21 10:15:09.000000000 +0000
@@ -17,7 +17,7 @@
 		unsigned short Addr;
 		unsigned short Len;
 		unsigned char  Data[0];
-	};
+	} __attribute__ ((packed));
 
 	struct edge_firmware_version_info {
 		unsigned char	 MajorVersion;
diff -purN linux-2.5/drivers/usb/serial/io_fw_down.h usb-2.5/drivers/usb/serial/io_fw_down.h
--- linux-2.5/drivers/usb/serial/io_fw_down.h	2003-08-27 11:45:14.000000000 +0000
+++ usb-2.5/drivers/usb/serial/io_fw_down.h	2003-10-21 10:15:18.000000000 +0000
@@ -17,7 +17,7 @@
 		unsigned short	Addr;
 		unsigned short	Len;
 		unsigned char	Data[0];
-	};
+	} __attribute ((packed));
 
 	struct edge_firmware_version_info {
 		unsigned char	MajorVersion;
diff -purN linux-2.5/drivers/usb/serial/io_fw_down2.h usb-2.5/drivers/usb/serial/io_fw_down2.h
--- linux-2.5/drivers/usb/serial/io_fw_down2.h	2003-08-27 11:45:14.000000000 +0000
+++ usb-2.5/drivers/usb/serial/io_fw_down2.h	2003-10-21 10:15:30.000000000 +0000
@@ -17,7 +17,7 @@
 		unsigned short Addr;
 		unsigned short Len;
 		unsigned char  Data[0];
-	};
+	} __attribute__ ((packed));
 
 	struct edge_firmware_version_info {
 		unsigned char  MajorVersion;
diff -purN linux-2.5/drivers/usb/serial/pl2303.c usb-2.5/drivers/usb/serial/pl2303.c
--- linux-2.5/drivers/usb/serial/pl2303.c	2003-09-03 11:44:09.000000000 +0000
+++ usb-2.5/drivers/usb/serial/pl2303.c	2003-12-12 18:00:42.000000000 +0000
@@ -71,6 +71,7 @@ static struct usb_device_id id_table [] 
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_RSAQ2) },
 	{ USB_DEVICE(IODATA_VENDOR_ID, IODATA_PRODUCT_ID) },
 	{ USB_DEVICE(ATEN_VENDOR_ID, ATEN_PRODUCT_ID) },
+	{ USB_DEVICE(ATEN_VENDOR_ID2, ATEN_PRODUCT_ID) },
 	{ USB_DEVICE(ELCOM_VENDOR_ID, ELCOM_PRODUCT_ID) },
 	{ USB_DEVICE(ITEGNO_VENDOR_ID, ITEGNO_PRODUCT_ID) },
 	{ USB_DEVICE(MA620_VENDOR_ID, MA620_PRODUCT_ID) },
@@ -78,6 +79,7 @@ static struct usb_device_id id_table [] 
 	{ USB_DEVICE(TRIPP_VENDOR_ID, TRIPP_PRODUCT_ID) },
 	{ USB_DEVICE(RADIOSHACK_VENDOR_ID, RADIOSHACK_PRODUCT_ID) },
 	{ USB_DEVICE(DCU10_VENDOR_ID, DCU10_PRODUCT_ID) },
+	{ USB_DEVICE(SITECOM_VENDOR_ID, SITECOM_PRODUCT_ID) },
 	{ }					/* Terminating entry */
 };
 
@@ -169,6 +171,7 @@ static struct usb_serial_device_type pl2
 
 struct pl2303_private {
 	spinlock_t lock;
+	wait_queue_head_t delta_msr_wait;
 	u8 line_control;
 	u8 line_status;
 	u8 termios_initialized;
@@ -186,6 +189,7 @@ static int pl2303_startup (struct usb_se
 			return -ENOMEM;
 		memset (priv, 0x00, sizeof (struct pl2303_private));
 		spin_lock_init(&priv->lock);
+		init_waitqueue_head(&priv->delta_msr_wait);
 		usb_set_serial_port_data(serial->port[i], priv);
 	}
 	return 0;
@@ -556,11 +560,51 @@ static int pl2303_tiocmget (struct usb_s
 	return result;
 }
 
+static int wait_modem_info(struct usb_serial_port *port, unsigned int arg)
+{
+	struct pl2303_private *priv = usb_get_serial_port_data(port);
+	unsigned long flags;
+	unsigned int prevstatus;
+	unsigned int status;
+	unsigned int changed;
+
+	spin_lock_irqsave (&priv->lock, flags);
+	prevstatus = priv->line_status;
+	spin_unlock_irqrestore (&priv->lock, flags);
+
+	while (1) {
+		interruptible_sleep_on(&priv->delta_msr_wait);
+		/* see if a signal did it */
+		if (signal_pending(current))
+			return -ERESTARTSYS;
+		
+		spin_lock_irqsave (&priv->lock, flags);
+		status = priv->line_status;
+		spin_unlock_irqrestore (&priv->lock, flags);
+		
+		changed=prevstatus^status;
+		
+		if (((arg & TIOCM_RNG) && (changed & UART_RING)) ||
+		    ((arg & TIOCM_DSR) && (changed & UART_DSR)) ||
+		    ((arg & TIOCM_CD)  && (changed & UART_DCD)) ||
+		    ((arg & TIOCM_CTS) && (changed & UART_CTS)) ) {
+			return 0;
+		}
+		prevstatus = status;
+	}
+	/* NOTREACHED */
+	return 0;
+}
+
 static int pl2303_ioctl (struct usb_serial_port *port, struct file *file, unsigned int cmd, unsigned long arg)
 {
 	dbg("%s (%d) cmd = 0x%04x", __FUNCTION__, port->number, cmd);
 
 	switch (cmd) {
+		case TIOCMIWAIT:
+			dbg("%s (%d) TIOCMIWAIT", __FUNCTION__,  port->number);
+			return wait_modem_info(port, arg);
+
 		default:
 			dbg("%s not supported = 0x%04x", __FUNCTION__, cmd);
 			break;
@@ -703,6 +747,7 @@ static void pl2303_read_bulk_callback (s
 	spin_lock_irqsave(&priv->lock, flags);
 	status = priv->line_status;
 	spin_unlock_irqrestore(&priv->lock, flags);
+	wake_up_interruptible (&priv->delta_msr_wait);
 
 	/* break takes precedence over parity, */
 	/* which takes precedence over framing errors */
diff -purN linux-2.5/drivers/usb/serial/pl2303.h usb-2.5/drivers/usb/serial/pl2303.h
--- linux-2.5/drivers/usb/serial/pl2303.h	2003-03-14 14:58:12.000000000 +0000
+++ usb-2.5/drivers/usb/serial/pl2303.h	2003-12-12 18:00:42.000000000 +0000
@@ -12,6 +12,7 @@
 #define PL2303_PRODUCT_ID_RSAQ2	0x04bb
 
 #define ATEN_VENDOR_ID		0x0557
+#define ATEN_VENDOR_ID2		0x0547
 #define ATEN_PRODUCT_ID		0x2008
 
 #define IODATA_VENDOR_ID	0x04bb
@@ -37,3 +38,6 @@
 
 #define DCU10_VENDOR_ID		0x0731
 #define DCU10_PRODUCT_ID	0x0528
+
+#define SITECOM_VENDOR_ID	0x6189
+#define SITECOM_PRODUCT_ID	0x2068
diff -purN linux-2.5/drivers/usb/serial/visor.c usb-2.5/drivers/usb/serial/visor.c
--- linux-2.5/drivers/usb/serial/visor.c	2003-10-13 12:45:25.000000000 +0000
+++ usb-2.5/drivers/usb/serial/visor.c	2003-12-12 21:10:37.000000000 +0000
@@ -231,6 +231,8 @@ static struct usb_device_id id_table [] 
 		.driver_info = (kernel_ulong_t)&palm_os_4_probe },
 	{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_NX60_ID),
 		.driver_info = (kernel_ulong_t)&palm_os_4_probe },
+	{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_UX50_ID),
+		.driver_info = (kernel_ulong_t)&palm_os_4_probe },
 	{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_NZ90V_ID),
 		.driver_info = (kernel_ulong_t)&palm_os_4_probe },
 	{ USB_DEVICE(SAMSUNG_VENDOR_ID, SAMSUNG_SCH_I330_ID), 
@@ -266,6 +268,7 @@ static struct usb_device_id id_table_com
 	{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_4_1_ID) },
 	{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_NX60_ID) },
 	{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_NZ90V_ID) },
+	{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_UX50_ID) },
 	{ USB_DEVICE(SAMSUNG_VENDOR_ID, SAMSUNG_SCH_I330_ID) },
 	{ USB_DEVICE(GARMIN_VENDOR_ID, GARMIN_IQUE_3600_ID) },
 	{ },					/* optional parameter entry */
diff -purN linux-2.5/drivers/usb/serial/visor.h usb-2.5/drivers/usb/serial/visor.h
--- linux-2.5/drivers/usb/serial/visor.h	2003-10-09 19:26:22.000000000 +0000
+++ usb-2.5/drivers/usb/serial/visor.h	2003-12-12 21:10:37.000000000 +0000
@@ -41,6 +41,7 @@
 #define SONY_CLIE_4_1_ID		0x009A
 #define SONY_CLIE_NX60_ID		0x00DA
 #define SONY_CLIE_NZ90V_ID		0x00E9
+#define SONY_CLIE_UX50_ID		0x0144
 
 #define SAMSUNG_VENDOR_ID		0x04E8
 #define SAMSUNG_SCH_I330_ID		0x8001
diff -purN linux-2.5/drivers/usb/storage/Makefile usb-2.5/drivers/usb/storage/Makefile
--- linux-2.5/drivers/usb/storage/Makefile	2002-12-14 12:38:56.000000000 +0000
+++ usb-2.5/drivers/usb/storage/Makefile	2003-12-01 10:56:45.000000000 +0000
@@ -10,14 +10,14 @@ EXTRA_CFLAGS	:= -Idrivers/scsi
 obj-$(CONFIG_USB_STORAGE)	+= usb-storage.o
 
 usb-storage-obj-$(CONFIG_USB_STORAGE_DEBUG)	+= debug.o
-usb-storage-obj-$(CONFIG_USB_STORAGE_HP8200e)	+= shuttle_usbat.o raw_bulk.o
-usb-storage-obj-$(CONFIG_USB_STORAGE_SDDR09)	+= sddr09.o raw_bulk.o
-usb-storage-obj-$(CONFIG_USB_STORAGE_SDDR55)	+= sddr55.o raw_bulk.o
+usb-storage-obj-$(CONFIG_USB_STORAGE_HP8200e)	+= shuttle_usbat.o
+usb-storage-obj-$(CONFIG_USB_STORAGE_SDDR09)	+= sddr09.o
+usb-storage-obj-$(CONFIG_USB_STORAGE_SDDR55)	+= sddr55.o
 usb-storage-obj-$(CONFIG_USB_STORAGE_FREECOM)	+= freecom.o
 usb-storage-obj-$(CONFIG_USB_STORAGE_DPCM)	+= dpcm.o
 usb-storage-obj-$(CONFIG_USB_STORAGE_ISD200)	+= isd200.o
-usb-storage-obj-$(CONFIG_USB_STORAGE_DATAFAB)	+= datafab.o raw_bulk.o
-usb-storage-obj-$(CONFIG_USB_STORAGE_JUMPSHOT)	+= jumpshot.o raw_bulk.o
+usb-storage-obj-$(CONFIG_USB_STORAGE_DATAFAB)	+= datafab.o
+usb-storage-obj-$(CONFIG_USB_STORAGE_JUMPSHOT)	+= jumpshot.o
 
 usb-storage-objs :=	scsiglue.o protocol.o transport.o usb.o \
 			initializers.o $(usb-storage-obj-y)
diff -purN linux-2.5/drivers/usb/storage/datafab.c usb-2.5/drivers/usb/storage/datafab.c
--- linux-2.5/drivers/usb/storage/datafab.c	2003-11-22 17:37:54.000000000 +0000
+++ usb-2.5/drivers/usb/storage/datafab.c	2003-12-16 18:01:23.000000000 +0000
@@ -51,7 +51,6 @@
  */
 
 #include "transport.h"
-#include "raw_bulk.h"
 #include "protocol.h"
 #include "usb.h"
 #include "debug.h"
@@ -91,16 +90,14 @@ static int datafab_read_data(struct us_d
 			     struct datafab_info *info,
 			     u32 sector,
 			     u32 sectors, 
-			     unsigned char *dest, 
+			     unsigned char *buffer, 
 			     int use_sg)
 {
 	unsigned char *command = us->iobuf;
-	unsigned char *buffer = NULL;
-	unsigned char *ptr;
 	unsigned char  thistime;
-	int totallen, len, result;
-	int sg_idx = 0, sg_offset = 0;
-	int rc;
+	unsigned int totallen, alloclen;
+	int len, result;
+	unsigned int sg_idx = 0, sg_offset = 0;
 
 	// we're working in LBA mode.  according to the ATA spec, 
 	// we can support up to 28-bit addressing.  I don't know if Datafab
@@ -111,23 +108,32 @@ static int datafab_read_data(struct us_d
 		return USB_STOR_TRANSPORT_ERROR;
 
 	if (info->lun == -1) {
-		rc = datafab_determine_lun(us, info);
-		if (rc != USB_STOR_TRANSPORT_GOOD)
-			return rc;
+		result = datafab_determine_lun(us, info);
+		if (result != USB_STOR_TRANSPORT_GOOD)
+			return result;
 	}
 
 	totallen = sectors * info->ssize;
 
+	// Since we don't read more than 64 KB at a time, we have to create
+	// a bounce buffer if the transfer uses scatter-gather.  We will
+	// move the data a piece at a time between the bounce buffer and
+	// the actual transfer buffer.  If we're not using scatter-gather,
+	// we can simply update the transfer buffer pointer to get the
+	// same effect.
+
+	alloclen = min(totallen, 65536u);
+	if (use_sg) {
+		buffer = kmalloc(alloclen, GFP_NOIO);
+		if (buffer == NULL)
+			return USB_STOR_TRANSPORT_ERROR;
+	}
+
 	do {
 		// loop, never allocate or transfer more than 64k at once
 		// (min(128k, 255*info->ssize) is the real limit)
 
-		len = min_t(int, totallen, 65536);
-
-		ptr = buffer = (use_sg ? kmalloc(len, GFP_NOIO) : dest);
-		if (buffer == NULL)
-			return USB_STOR_TRANSPORT_ERROR;
-
+		len = min(totallen, alloclen);
 		thistime = (len / info->ssize) & 0xff;
 
 		command[0] = 0;
@@ -135,7 +141,7 @@ static int datafab_read_data(struct us_d
 		command[2] = sector & 0xFF;
 		command[3] = (sector >> 8) & 0xFF;
 		command[4] = (sector >> 16) & 0xFF;
-	
+
 		command[5] = 0xE0 + (info->lun << 4);
 		command[5] |= (sector >> 24) & 0x0F;
 		command[6] = 0x20;
@@ -147,24 +153,23 @@ static int datafab_read_data(struct us_d
 			goto leave;
 
 		// read the result
-		result = datafab_bulk_read(us, ptr, len);
+		result = datafab_bulk_read(us, buffer, len);
 		if (result != USB_STOR_XFER_GOOD)
 			goto leave;
 
-		sectors -= thistime;
-		sector  += thistime;
-
-		if (use_sg) {
-			us_copy_to_sgbuf(buffer, len, dest,
-					 &sg_idx, &sg_offset, use_sg);
-			kfree(buffer);
-		} else {
-			dest += len;
-		}
+		// Store the data (s-g) or update the pointer (!s-g)
+		if (use_sg)
+			usb_stor_access_xfer_buf(buffer, len, us->srb,
+					 &sg_idx, &sg_offset, TO_XFER_BUF);
+		else
+			buffer += len;
 
+		sector += thistime;
 		totallen -= len;
 	} while (totallen > 0);
 
+	if (use_sg)
+		kfree(buffer);
 	return USB_STOR_TRANSPORT_GOOD;
 
  leave:
@@ -178,16 +183,15 @@ static int datafab_write_data(struct us_
 			      struct datafab_info *info,
 			      u32 sector,
 			      u32 sectors, 
-			      unsigned char *src, 
+			      unsigned char *buffer, 
 			      int use_sg)
 {
 	unsigned char *command = us->iobuf;
 	unsigned char *reply = us->iobuf;
-	unsigned char *buffer = NULL;
-	unsigned char *ptr;
 	unsigned char thistime;
-	int totallen, len, result, rc;
-	int sg_idx = 0, sg_offset = 0;
+	unsigned int totallen, alloclen;
+	int len, result;
+	unsigned int sg_idx = 0, sg_offset = 0;
 
 	// we're working in LBA mode.  according to the ATA spec, 
 	// we can support up to 28-bit addressing.  I don't know if Datafab
@@ -198,38 +202,39 @@ static int datafab_write_data(struct us_
 		return USB_STOR_TRANSPORT_ERROR;
 
 	if (info->lun == -1) {
-		rc = datafab_determine_lun(us, info);
-		if (rc != USB_STOR_TRANSPORT_GOOD)
-			return rc;
+		result = datafab_determine_lun(us, info);
+		if (result != USB_STOR_TRANSPORT_GOOD)
+			return result;
 	}
 
-	// If we're using scatter-gather, we have to create a new
-	// buffer to read all of the data in first, since a
-	// scatter-gather buffer could in theory start in the middle
-	// of a page, which would be bad. A developer who wants a
-	// challenge might want to write a limited-buffer
-	// version of this code.
-
 	totallen = sectors * info->ssize;
 
-	do {
-		// loop, never allocate or transfer more than 64k at once
-		// (min(128k, 255*info->ssize) is the real limit)
-
-		len = min_t(int, totallen, 65536);
-
-		// if we are using scatter-gather,
-		// first copy all to one big buffer
-
-		buffer = us_copy_from_sgbuf(src, len, &sg_idx,
-					    &sg_offset, use_sg);
+	// Since we don't write more than 64 KB at a time, we have to create
+	// a bounce buffer if the transfer uses scatter-gather.  We will
+	// move the data a piece at a time between the bounce buffer and
+	// the actual transfer buffer.  If we're not using scatter-gather,
+	// we can simply update the transfer buffer pointer to get the
+	// same effect.
+
+	alloclen = min(totallen, 65536u);
+	if (use_sg) {
+		buffer = kmalloc(alloclen, GFP_NOIO);
 		if (buffer == NULL)
 			return USB_STOR_TRANSPORT_ERROR;
+	}
 
-		ptr = buffer;
+	do {
+		// loop, never allocate or transfer more than 64k at once
+		// (min(128k, 255*info->ssize) is the real limit)
 
+		len = min(totallen, alloclen);
 		thistime = (len / info->ssize) & 0xff;
 
+		// Get the data from the transfer buffer (s-g)
+		if (use_sg)
+			usb_stor_access_xfer_buf(buffer, len, us->srb,
+					&sg_idx, &sg_offset, FROM_XFER_BUF);
+
 		command[0] = 0;
 		command[1] = thistime;
 		command[2] = sector & 0xFF;
@@ -247,7 +252,7 @@ static int datafab_write_data(struct us_
 			goto leave;
 
 		// send the data
-		result = datafab_bulk_write(us, ptr, len);
+		result = datafab_bulk_write(us, buffer, len);
 		if (result != USB_STOR_XFER_GOOD)
 			goto leave;
 
@@ -264,17 +269,16 @@ static int datafab_write_data(struct us_
 			goto leave;
 		}
 
-		sectors -= thistime;
-		sector  += thistime;
-
-		if (use_sg)
-			kfree(buffer);
-		else
-			src += len;
+		// Update the transfer buffer pointer (!s-g)
+		if (!use_sg)
+			buffer += len;
 
+		sector += thistime;
 		totallen -= len;
 	} while (totallen > 0);
 
+	if (use_sg)
+		kfree(buffer);
 	return USB_STOR_TRANSPORT_GOOD;
 
  leave:
@@ -435,7 +439,7 @@ static int datafab_handle_mode_sense(str
 	// datafab reader doesn't present a SCSI interface so we
 	// fudge the SCSI commands...
 	//
-	
+
 	if (sense_6)
 		param_len = srb->cmnd[4];
 	else
diff -purN linux-2.5/drivers/usb/storage/debug.c usb-2.5/drivers/usb/storage/debug.c
--- linux-2.5/drivers/usb/storage/debug.c	2003-01-12 18:01:39.000000000 +0000
+++ usb-2.5/drivers/usb/storage/debug.c	2003-11-21 11:26:33.000000000 +0000
@@ -150,65 +150,6 @@ void usb_stor_show_command(Scsi_Cmnd *sr
 	US_DEBUGPX("\n");
 }
 
-void usb_stor_print_Scsi_Cmnd(Scsi_Cmnd *cmd)
-{
-	int i=0, bufferSize = cmd->request_bufflen;
-	u8 *buffer = cmd->request_buffer;
-	struct scatterlist *sg = (struct scatterlist*)cmd->request_buffer;
-
-	US_DEBUGP("Dumping information about %p.\n", cmd);
-	US_DEBUGP("cmd->cmnd[0] value is %d.\n", cmd->cmnd[0]);
-	US_DEBUGP("(MODE_SENSE is %d and MODE_SENSE_10 is %d)\n",
-		  MODE_SENSE, MODE_SENSE_10);
-
-	US_DEBUGP("buffer is %p with length %d.\n", buffer, bufferSize);
-	for (i=0; i<bufferSize; i+=16) {
-		US_DEBUGP("%02x %02x %02x %02x %02x %02x %02x %02x\n"
-			  "%02x %02x %02x %02x %02x %02x %02x %02x\n",
-			  buffer[i],
-			  buffer[i+1],
-			  buffer[i+2],
-			  buffer[i+3],
-			  buffer[i+4],
-			  buffer[i+5],
-			  buffer[i+6],
-			  buffer[i+7],
-			  buffer[i+8],
-			  buffer[i+9],
-			  buffer[i+10],
-			  buffer[i+11],
-			  buffer[i+12],
-			  buffer[i+13],
-			  buffer[i+14],
-			  buffer[i+15] );
-	}
-
-	US_DEBUGP("Buffer has %d scatterlists.\n", cmd->use_sg );
-	for (i=0; i<cmd->use_sg; i++) {
-		char *adr = sg_address(sg[i]);
-		
-		US_DEBUGP("Length of scatterlist %d is %d.\n",i,sg[i].length);
-		US_DEBUGP("%02x %02x %02x %02x %02x %02x %02x %02x\n"
-			  "%02x %02x %02x %02x %02x %02x %02x %02x\n",
-			  adr[0],
-			  adr[1],
-			  adr[2],
-			  adr[3],
-			  adr[4],
-			  adr[5],
-			  adr[6],
-			  adr[7],
-			  adr[8],
-			  adr[9],
-			  adr[10],
-			  adr[11],
-			  adr[12],
-			  adr[13],
-			  adr[14],
-			  adr[15]);
-	}
-}
-
 void usb_stor_show_sense(
 		unsigned char key,
 		unsigned char asc,
diff -purN linux-2.5/drivers/usb/storage/debug.h usb-2.5/drivers/usb/storage/debug.h
--- linux-2.5/drivers/usb/storage/debug.h	2003-05-02 17:46:13.000000000 +0000
+++ usb-2.5/drivers/usb/storage/debug.h	2003-11-21 11:26:45.000000000 +0000
@@ -53,7 +53,6 @@
 
 #ifdef CONFIG_USB_STORAGE_DEBUG
 void usb_stor_show_command(Scsi_Cmnd *srb);
-void usb_stor_print_Scsi_Cmnd( Scsi_Cmnd* cmd );
 void usb_stor_show_sense( unsigned char key,
 		unsigned char asc, unsigned char ascq );
 #define US_DEBUGP(x...) printk( KERN_DEBUG USB_STORAGE x )
diff -purN linux-2.5/drivers/usb/storage/isd200.c usb-2.5/drivers/usb/storage/isd200.c
--- linux-2.5/drivers/usb/storage/isd200.c	2003-09-02 17:47:41.000000000 +0000
+++ usb-2.5/drivers/usb/storage/isd200.c	2003-11-24 14:26:04.000000000 +0000
@@ -543,7 +543,6 @@ void isd200_invoke_transport( struct us_
 	int result;
 
 	/* send the command to the transport layer */
-	srb->resid = 0;
 	memcpy(srb->cmnd, ataCdb, sizeof(ataCdb->generic));
 	srb->cmd_len = sizeof(ataCdb->generic);
 	transferStatus = usb_stor_Bulk_transport(srb, us);
@@ -1117,60 +1116,6 @@ int isd200_get_inquiry_data( struct us_d
 
 
 /**************************************************************************
- * isd200_data_copy
- *									 
- * Copy data into the srb request buffer.  Use scatter gather if required.
- *
- * RETURNS:
- *    void
- */
-void isd200_data_copy(Scsi_Cmnd *srb, char * src, int length)
-{
-	unsigned int len = length;
-	struct scatterlist *sg;
-
-	if (srb->use_sg) {
-		int i;
-		unsigned int total = 0;
-
-		/* Add up the sizes of all the sg segments */
-		sg = (struct scatterlist *) srb->request_buffer;
-		for (i = 0; i < srb->use_sg; i++)
-			total += sg[i].length;
-
-		if (length > total)
-			len = total;
-
-		total = 0;
-
-		/* Copy data into sg buffer(s) */
-		for (i = 0; i < srb->use_sg; i++) {
-			if ((len > total) && (len > 0)) {
-				/* transfer the lesser of the next buffer or the
-				 * remaining data */
-				if (len - total >= sg[i].length) {
-					memcpy(sg_address(sg[i]), src + total, sg[i].length);
-					total += sg[i].length;
-				} else {
-					memcpy(sg_address(sg[i]), src + total, len - total);
-					total = len;
-				}
-			} 
-			else
-				break;
-		}
-	} else	{
-		/* Make sure length does not exceed buffer length */
-		if (length > srb->request_bufflen)
-			len = srb->request_bufflen;
-
-		if (len > 0)
-			memcpy(srb->request_buffer, src, len);
-	}
-}
-
-
-/**************************************************************************
  * isd200_scsi_to_ata
  *									 
  * Translate SCSI commands to ATA commands.
@@ -1198,11 +1143,9 @@ int isd200_scsi_to_ata(Scsi_Cmnd *srb, s
 	case INQUIRY:
 		US_DEBUGP("   ATA OUT - INQUIRY\n");
 
-		if (srb->request_bufflen > sizeof(struct inquiry_data))
-			srb->request_bufflen = sizeof(struct inquiry_data);
-
 		/* copy InquiryData */
-		isd200_data_copy(srb, (char *) &info->InquiryData, srb->request_bufflen);
+		usb_stor_set_xfer_buf((unsigned char *) &info->InquiryData,
+				sizeof(info->InquiryData), srb);
 		srb->result = SAM_STAT_GOOD;
 		sendToTransport = FALSE;
 		break;
@@ -1211,7 +1154,7 @@ int isd200_scsi_to_ata(Scsi_Cmnd *srb, s
 		US_DEBUGP("   ATA OUT - SCSIOP_MODE_SENSE\n");
 
 		/* Initialize the return buffer */
-		isd200_data_copy(srb, (char *) &senseData, 8);
+		usb_stor_set_xfer_buf(senseData, sizeof(senseData), srb);
 
 		if (info->DeviceFlags & DF_MEDIA_STATUS_ENABLED)
 		{
@@ -1231,9 +1174,6 @@ int isd200_scsi_to_ata(Scsi_Cmnd *srb, s
 	case TEST_UNIT_READY:
 		US_DEBUGP("   ATA OUT - SCSIOP_TEST_UNIT_READY\n");
 
-		/* Initialize the return buffer */
-		isd200_data_copy(srb, (char *) &senseData, 8);
-
 		if (info->DeviceFlags & DF_MEDIA_STATUS_ENABLED)
 		{
 			ataCdb->generic.SignatureByte0 = info->ConfigData.ATAMajorCommand;
@@ -1266,10 +1206,8 @@ int isd200_scsi_to_ata(Scsi_Cmnd *srb, s
 		readCapacityData.LogicalBlockAddress = cpu_to_be32(capacity);
 		readCapacityData.BytesPerBlock = cpu_to_be32(0x200);
 
-		if (srb->request_bufflen > sizeof(struct read_capacity_data))
-			srb->request_bufflen = sizeof(struct read_capacity_data);
-
-		isd200_data_copy(srb, (char *) &readCapacityData, srb->request_bufflen);
+		usb_stor_set_xfer_buf((unsigned char *) &readCapacityData,
+				sizeof(readCapacityData), srb);
 		srb->result = SAM_STAT_GOOD;
 		sendToTransport = FALSE;
 	}
@@ -1363,9 +1301,6 @@ int isd200_scsi_to_ata(Scsi_Cmnd *srb, s
 		US_DEBUGP("   ATA OUT - SCSIOP_START_STOP_UNIT\n");
 		US_DEBUGP("   srb->cmnd[4] = 0x%X\n", srb->cmnd[4]);
 
-		/* Initialize the return buffer */
-		isd200_data_copy(srb, (char *) &senseData, 8);
-
 		if ((srb->cmnd[4] & 0x3) == 0x2) {
 			US_DEBUGP("   Media Eject\n");
 			ataCdb->generic.SignatureByte0 = info->ConfigData.ATAMajorCommand;
@@ -1500,6 +1435,7 @@ void isd200_ata_command(Scsi_Cmnd *srb, 
 		US_DEBUGP("ERROR Driver not initialized\n");
 
 	/* Convert command */
+	srb->resid = 0;
 	sendToTransport = isd200_scsi_to_ata(srb, us, &ataCdb);
 
 	/* send the command to the transport layer */
diff -purN linux-2.5/drivers/usb/storage/jumpshot.c usb-2.5/drivers/usb/storage/jumpshot.c
--- linux-2.5/drivers/usb/storage/jumpshot.c	2003-11-22 17:38:08.000000000 +0000
+++ usb-2.5/drivers/usb/storage/jumpshot.c	2003-12-16 18:01:24.000000000 +0000
@@ -48,7 +48,6 @@
   */
 
 #include "transport.h"
-#include "raw_bulk.h"
 #include "protocol.h"
 #include "usb.h"
 #include "debug.h"
@@ -111,15 +110,14 @@ static int jumpshot_read_data(struct us_
 			      struct jumpshot_info *info,
 			      u32 sector,
 			      u32 sectors, 
-			      unsigned char *dest, 
+			      unsigned char *buffer, 
 			      int use_sg)
 {
 	unsigned char *command = us->iobuf;
-	unsigned char *buffer = NULL;
-	unsigned char *ptr;
 	unsigned char  thistime;
-	int totallen, len, result;
-	int sg_idx = 0, current_sg_offset = 0;
+	unsigned int totallen, alloclen;
+	int len, result;
+	unsigned int sg_idx = 0, sg_offset = 0;
 
 	// we're working in LBA mode.  according to the ATA spec, 
 	// we can support up to 28-bit addressing.  I don't know if Jumpshot
@@ -131,20 +129,24 @@ static int jumpshot_read_data(struct us_
 
 	totallen = sectors * info->ssize;
 
+	// Since we don't read more than 64 KB at a time, we have to create
+	// a bounce buffer if the transfer uses scatter-gather.  We will
+	// move the data a piece at a time between the bounce buffer and
+	// the actual transfer buffer.  If we're not using scatter-gather,
+	// we can simply update the transfer buffer pointer to get the
+	// same effect.
+
+	alloclen = min(totallen, 65536u);
+	if (use_sg) {
+		buffer = kmalloc(alloclen, GFP_NOIO);
+		if (buffer == NULL)
+			return USB_STOR_TRANSPORT_ERROR;
+	}
+
 	do {
 		// loop, never allocate or transfer more than 64k at once
 		// (min(128k, 255*info->ssize) is the real limit)
-		len = min_t(int, totallen, 65536);
-
-		if (use_sg) {
-			buffer = kmalloc(len, GFP_NOIO);
-			if (buffer == NULL)
-				return USB_STOR_TRANSPORT_ERROR;
-			ptr = buffer;
-		} else {
-			ptr = dest;
-		}
-
+		len = min(totallen, alloclen);
 		thistime = (len / info->ssize) & 0xff;
 
 		command[0] = 0;
@@ -163,26 +165,25 @@ static int jumpshot_read_data(struct us_
 			goto leave;
 
 		// read the result
-		result = jumpshot_bulk_read(us, ptr, len);
+		result = jumpshot_bulk_read(us, buffer, len);
 		if (result != USB_STOR_XFER_GOOD)
 			goto leave;
 
 		US_DEBUGP("jumpshot_read_data:  %d bytes\n", len);
-	
-		sectors -= thistime;
-		sector  += thistime;
-
-		if (use_sg) {
-			us_copy_to_sgbuf(buffer, len, dest,
-					 &sg_idx, &current_sg_offset, use_sg);
-			kfree(buffer);
-		} else {
-			dest += len;
-		}
 
+		// Store the data (s-g) or update the pointer (!s-g)
+		if (use_sg)
+			usb_stor_access_xfer_buf(buffer, len, us->srb,
+					 &sg_idx, &sg_offset, TO_XFER_BUF);
+		else
+			buffer += len;
+
+		sector += thistime;
 		totallen -= len;
 	} while (totallen > 0);
 
+	if (use_sg)
+		kfree(buffer);
 	return USB_STOR_TRANSPORT_GOOD;
 
  leave:
@@ -196,15 +197,14 @@ static int jumpshot_write_data(struct us
 			       struct jumpshot_info *info,
 			       u32 sector,
 			       u32 sectors, 
-			       unsigned char *src, 
+			       unsigned char *buffer, 
 			       int use_sg)
 {
 	unsigned char *command = us->iobuf;
-	unsigned char *buffer = NULL;
-	unsigned char *ptr;
 	unsigned char  thistime;
-	int totallen, len, result, waitcount;
-	int sg_idx = 0, sg_offset = 0;
+	unsigned int totallen, alloclen;
+	int len, result, waitcount;
+	unsigned int sg_idx = 0, sg_offset = 0;
 
 	// we're working in LBA mode.  according to the ATA spec, 
 	// we can support up to 28-bit addressing.  I don't know if Jumpshot
@@ -216,24 +216,32 @@ static int jumpshot_write_data(struct us
 
 	totallen = sectors * info->ssize;
 
-	do {
-		// loop, never allocate or transfer more than 64k at once
-		// (min(128k, 255*info->ssize) is the real limit)
-
-		len = min_t(int, totallen, 65536);
-
-		// if we are using scatter-gather,
-		// first copy all to one big buffer
-
-		buffer = us_copy_from_sgbuf(src, len, &sg_idx,
-					    &sg_offset, use_sg);
+	// Since we don't write more than 64 KB at a time, we have to create
+	// a bounce buffer if the transfer uses scatter-gather.  We will
+	// move the data a piece at a time between the bounce buffer and
+	// the actual transfer buffer.  If we're not using scatter-gather,
+	// we can simply update the transfer buffer pointer to get the
+	// same effect.
+
+	alloclen = min(totallen, 65536u);
+	if (use_sg) {
+		buffer = kmalloc(alloclen, GFP_NOIO);
 		if (buffer == NULL)
 			return USB_STOR_TRANSPORT_ERROR;
+	}
 
-		ptr = buffer;
+	do {
+		// loop, never allocate or transfer more than 64k at once
+		// (min(128k, 255*info->ssize) is the real limit)
 
+		len = min(totallen, alloclen);
 		thistime = (len / info->ssize) & 0xff;
 
+		// Get the data from the transfer buffer (s-g)
+		if (use_sg)
+			usb_stor_access_xfer_buf(buffer, len, us->srb,
+					&sg_idx, &sg_offset, FROM_XFER_BUF);
+
 		command[0] = 0;
 		command[1] = thistime;
 		command[2] = sector & 0xFF;
@@ -250,7 +258,7 @@ static int jumpshot_write_data(struct us
 			goto leave;
 
 		// send the data
-		result = jumpshot_bulk_write(us, ptr, len);
+		result = jumpshot_bulk_write(us, buffer, len);
 		if (result != USB_STOR_XFER_GOOD)
 			goto leave;
 
@@ -269,18 +277,17 @@ static int jumpshot_write_data(struct us
 
 		if (result != USB_STOR_TRANSPORT_GOOD)
 			US_DEBUGP("jumpshot_write_data:  Gah!  Waitcount = 10.  Bad write!?\n");
-		
-		sectors -= thistime;
-		sector  += thistime;
 
-		if (use_sg)
-			kfree(buffer);
-		else
-			src += len;
+		// Update the transfer buffer pointer (!s-g)
+		if (!use_sg)
+			buffer += len;
 
+		sector += thistime;
 		totallen -= len;
 	} while (totallen > 0);
 
+	if (use_sg)
+		kfree(buffer);
 	return result;
 
  leave:
@@ -605,14 +612,14 @@ int jumpshot_transport(Scsi_Cmnd * srb, 
 		US_DEBUGP("jumpshot_transport:  MODE_SENSE_10 detected\n");
 		return jumpshot_handle_mode_sense(us, srb, ptr, FALSE);
 	}
-	
+
 	if (srb->cmnd[0] == ALLOW_MEDIUM_REMOVAL) {
 		// sure.  whatever.  not like we can stop the user from popping
 		// the media out of the device (no locking doors, etc)
 		//
 		return USB_STOR_TRANSPORT_GOOD;
 	}
-	
+
 	if (srb->cmnd[0] == START_STOP) {
 		/* this is used by sd.c'check_scsidisk_media_change to detect
 		   media change */
diff -purN linux-2.5/drivers/usb/storage/protocol.c usb-2.5/drivers/usb/storage/protocol.c
--- linux-2.5/drivers/usb/storage/protocol.c	2003-07-14 01:02:14.000000000 +0000
+++ usb-2.5/drivers/usb/storage/protocol.c	2003-12-02 17:02:16.000000000 +0000
@@ -44,6 +44,7 @@
  * 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
+#include <linux/highmem.h>
 #include "protocol.h"
 #include "usb.h"
 #include "debug.h"
@@ -54,48 +55,36 @@
  * Helper routines
  ***********************************************************************/
 
-static void *
-find_data_location(Scsi_Cmnd *srb) {
-	if (srb->use_sg) {
-		/*
-		 * This piece of code only works if the first page is
-		 * big enough to hold more than 3 bytes -- which is
-		 * _very_ likely.
-		 */
-		struct scatterlist *sg;
-
-		sg = (struct scatterlist *) srb->request_buffer;
-		return (void *) sg_address(sg[0]);
-	} else
-		return (void *) srb->request_buffer;
-}
-
 /*
  * Fix-up the return data from an INQUIRY command to show 
  * ANSI SCSI rev 2 so we don't confuse the SCSI layers above us
  */
 static void fix_inquiry_data(Scsi_Cmnd *srb)
 {
-	unsigned char *data_ptr;
+	unsigned char databuf[3];
+	unsigned int index, offset;
 
 	/* verify that it's an INQUIRY command */
 	if (srb->cmnd[0] != INQUIRY)
 		return;
 
-	/* oddly short buffer -- bail out */
-	if (srb->request_bufflen < 3)
+	index = offset = 0;
+	if (usb_stor_access_xfer_buf(databuf, sizeof(databuf), srb,
+			&index, &offset, FROM_XFER_BUF) != sizeof(databuf))
 		return;
 
-	data_ptr = find_data_location(srb);
-
-	if ((data_ptr[2] & 7) == 2)
+	if ((databuf[2] & 7) == 2)
 		return;
 
 	US_DEBUGP("Fixing INQUIRY data to show SCSI rev 2 - was %d\n",
-		  data_ptr[2] & 7);
+		  databuf[2] & 7);
 
 	/* Change the SCSI revision number */
-	data_ptr[2] = (data_ptr[2] & ~7) | 2;
+	databuf[2] = (databuf[2] & ~7) | 2;
+
+	index = offset = 0;
+	usb_stor_access_xfer_buf(databuf, sizeof(databuf), srb,
+			&index, &offset, TO_XFER_BUF);
 }
 
 /*
@@ -104,23 +93,27 @@ static void fix_inquiry_data(Scsi_Cmnd *
  */
 static void fix_read_capacity(Scsi_Cmnd *srb)
 {
-	unsigned char *dp;
+	unsigned int index, offset;
+	u32 c;
 	unsigned long capacity;
 
 	/* verify that it's a READ CAPACITY command */
 	if (srb->cmnd[0] != READ_CAPACITY)
 		return;
 
-	dp = find_data_location(srb);
+	index = offset = 0;
+	if (usb_stor_access_xfer_buf((unsigned char *) &c, 4, srb,
+			&index, &offset, FROM_XFER_BUF) != 4)
+		return;
 
-	capacity = (dp[0]<<24) + (dp[1]<<16) + (dp[2]<<8) + (dp[3]);
+	capacity = be32_to_cpu(c);
 	US_DEBUGP("US: Fixing capacity: from %ld to %ld\n",
 	       capacity+1, capacity);
-	capacity--;
-	dp[0] = (capacity >> 24);
-	dp[1] = (capacity >> 16);
-	dp[2] = (capacity >> 8);
-	dp[3] = (capacity);
+	c = cpu_to_be32(capacity - 1);
+
+	index = offset = 0;
+	usb_stor_access_xfer_buf((unsigned char *) &c, 4, srb,
+			&index, &offset, TO_XFER_BUF);
 }
 
 /***********************************************************************
@@ -234,3 +227,112 @@ void usb_stor_transparent_scsi_command(S
 			fix_read_capacity(srb);
 	}
 }
+
+/***********************************************************************
+ * Scatter-gather transfer buffer access routines
+ ***********************************************************************/
+
+/* Copy a buffer of length buflen to/from the srb's transfer buffer.
+ * (Note: for scatter-gather transfers (srb->use_sg > 0), srb->request_buffer
+ * points to a list of s-g entries and we ignore srb->request_bufflen.
+ * For non-scatter-gather transfers, srb->request_buffer points to the
+ * transfer buffer itself and srb->request_bufflen is the buffer's length.)
+ * Update the *index and *offset variables so that the next copy will
+ * pick up from where this one left off. */
+
+unsigned int usb_stor_access_xfer_buf(unsigned char *buffer,
+	unsigned int buflen, Scsi_Cmnd *srb, unsigned int *index,
+	unsigned int *offset, enum xfer_buf_dir dir)
+{
+	unsigned int cnt;
+
+	/* If not using scatter-gather, just transfer the data directly.
+	 * Make certain it will fit in the available buffer space. */
+	if (srb->use_sg == 0) {
+		if (*offset >= srb->request_bufflen)
+			return 0;
+		cnt = min(buflen, srb->request_bufflen - *offset);
+		if (dir == TO_XFER_BUF)
+			memcpy((unsigned char *) srb->request_buffer + *offset,
+					buffer, cnt);
+		else
+			memcpy(buffer, (unsigned char *) srb->request_buffer +
+					*offset, cnt);
+		*offset += cnt;
+
+	/* Using scatter-gather.  We have to go through the list one entry
+	 * at a time.  Each s-g entry contains some number of pages, and
+	 * each page has to be kmap()'ed separately.  If the page is already
+	 * in kernel-addressable memory then kmap() will return its address.
+	 * If the page is not directly accessible -- such as a user buffer
+	 * located in high memory -- then kmap() will map it to a temporary
+	 * position in the kernel's virtual address space. */
+	} else {
+		struct scatterlist *sg =
+				(struct scatterlist *) srb->request_buffer
+				+ *index;
+
+		/* This loop handles a single s-g list entry, which may
+		 * include multiple pages.  Find the initial page structure
+		 * and the starting offset within the page, and update
+		 * the *offset and *index values for the next loop. */
+		cnt = 0;
+		while (cnt < buflen && *index < srb->use_sg) {
+			struct page *page = sg->page +
+					((sg->offset + *offset) >> PAGE_SHIFT);
+			unsigned int poff =
+					(sg->offset + *offset) & (PAGE_SIZE-1);
+			unsigned int sglen = sg->length - *offset;
+
+			if (sglen > buflen - cnt) {
+
+				/* Transfer ends within this s-g entry */
+				sglen = buflen - cnt;
+				*offset += sglen;
+			} else {
+
+				/* Transfer continues to next s-g entry */
+				*offset = 0;
+				++*index;
+				++sg;
+			}
+
+			/* Transfer the data for all the pages in this
+			 * s-g entry.  For each page: call kmap(), do the
+			 * transfer, and call kunmap() immediately after. */
+			while (sglen > 0) {
+				unsigned int plen = min(sglen, (unsigned int)
+						PAGE_SIZE - poff);
+				unsigned char *ptr = kmap(page);
+
+				if (dir == TO_XFER_BUF)
+					memcpy(ptr + poff, buffer + cnt, plen);
+				else
+					memcpy(buffer + cnt, ptr + poff, plen);
+				kunmap(page);
+
+				/* Start at the beginning of the next page */
+				poff = 0;
+				++page;
+				cnt += plen;
+				sglen -= plen;
+			}
+		}
+	}
+
+	/* Return the amount actually transferred */
+	return cnt;
+}
+
+/* Store the contents of buffer into srb's transfer buffer and set the
+ * SCSI residue. */
+void usb_stor_set_xfer_buf(unsigned char *buffer,
+	unsigned int buflen, Scsi_Cmnd *srb)
+{
+	unsigned int index = 0, offset = 0;
+
+	usb_stor_access_xfer_buf(buffer, buflen, srb, &index, &offset,
+			TO_XFER_BUF);
+	if (buflen < srb->request_bufflen)
+		srb->resid = srb->request_bufflen - buflen;
+}
diff -purN linux-2.5/drivers/usb/storage/protocol.h usb-2.5/drivers/usb/storage/protocol.h
--- linux-2.5/drivers/usb/storage/protocol.h	2003-05-02 20:18:55.000000000 +0000
+++ usb-2.5/drivers/usb/storage/protocol.h	2003-11-24 14:03:45.000000000 +0000
@@ -59,9 +59,19 @@
 
 #define US_SC_DEVICE	0xff		/* Use device's value */
 
+/* Protocol handling routines */
 extern void usb_stor_ATAPI_command(Scsi_Cmnd*, struct us_data*);
 extern void usb_stor_qic157_command(Scsi_Cmnd*, struct us_data*);
 extern void usb_stor_ufi_command(Scsi_Cmnd*, struct us_data*);
 extern void usb_stor_transparent_scsi_command(Scsi_Cmnd*, struct us_data*);
 
+/* Scsi_Cmnd transfer buffer access utilities */
+enum xfer_buf_dir	{TO_XFER_BUF, FROM_XFER_BUF};
+
+extern unsigned int usb_stor_access_xfer_buf(unsigned char *buffer,
+	unsigned int buflen, Scsi_Cmnd *srb, unsigned int *index,
+	unsigned int *offset, enum xfer_buf_dir dir);
+
+extern void usb_stor_set_xfer_buf(unsigned char *buffer,
+	unsigned int buflen, Scsi_Cmnd *srb);
 #endif
diff -purN linux-2.5/drivers/usb/storage/raw_bulk.c usb-2.5/drivers/usb/storage/raw_bulk.c
--- linux-2.5/drivers/usb/storage/raw_bulk.c	2002-11-10 17:49:52.000000000 +0000
+++ usb-2.5/drivers/usb/storage/raw_bulk.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,116 +0,0 @@
-/*
- * Common routines for a handful of drivers.
- * Unrelated to CF/SM - just scatter-gather stuff.
- */
-
-#include "usb.h"
-#include "raw_bulk.h"
-
-/*
- * The routines below convert scatter-gather to single buffer.
- * Some drivers claim this is necessary.
- * Nothing is done when use_sg is zero.
- */
-
-/*
- * Copy from scatter-gather buffer into a newly allocated single buffer,
- * starting at a given index and offset.
- * When done, update index and offset.
- * Return a pointer to the single buffer.
- */
-unsigned char *
-us_copy_from_sgbuf(unsigned char *content, int len,
-		   int *index, int *offset, int use_sg) {
-	struct scatterlist *sg;
-	unsigned char *buffer;
-	int transferred, i;
-
-	if (!use_sg)
-		return content;
-
-	sg = (struct scatterlist *)content;
-	buffer = kmalloc(len, GFP_NOIO);
-	if (buffer == NULL)
-		return NULL;
-
-	transferred = 0;
-	i = *index;
-	while (i < use_sg && transferred < len) {
-		unsigned char *ptr;
-		unsigned int length, room;
-
-		ptr = sg_address(sg[i]) + *offset;
-
-		room = sg[i].length - *offset;
-		length = len - transferred;
-		if (length > room)
-			length = room;
-
-		memcpy(buffer+transferred, ptr, length);
-		transferred += length;
-		*offset += length;
-		if (length == room) {
-			i++;
-			*offset = 0;
-		}
-	}
-	*index = i;
-
-	return buffer;
-}
-
-unsigned char *
-us_copy_from_sgbuf_all(unsigned char *content, int len, int use_sg) {
-	int index, offset;
-
-	index = offset = 0;
-	return us_copy_from_sgbuf(content, len, &index, &offset, use_sg);
-}
-
-/*
- * Copy from a single buffer into a scatter-gather buffer,
- * starting at a given index and offset.
- * When done, update index and offset.
- */
-void
-us_copy_to_sgbuf(unsigned char *buffer, int buflen,
-		 void *content, int *index, int *offset, int use_sg) {
-	struct scatterlist *sg;
-	int i, transferred;
-
-	if (!use_sg)
-		return;
-
-	transferred = 0;
-	sg = content;
-	i = *index;
-	while (i < use_sg && transferred < buflen) {
-		unsigned char *ptr;
-		unsigned int length, room;
-
-		ptr = sg_address(sg[i]) + *offset;
-
-		room = sg[i].length - *offset;
-		length = buflen - transferred;
-		if (length > room)
-			length = room;
-		
-		memcpy(ptr, buffer+transferred, length);
-		transferred += sg[i].length;
-		*offset += length;
-		if (length == room) {
-			i++;
-			*offset = 0;
-		}
-	}
-	*index = i;
-}
-
-void
-us_copy_to_sgbuf_all(unsigned char *buffer, int buflen,
-		     void *content, int use_sg) {
-	int index, offset;
-
-	index = offset = 0;
-	us_copy_to_sgbuf(buffer, buflen, content, &index, &offset, use_sg);
-}
diff -purN linux-2.5/drivers/usb/storage/raw_bulk.h usb-2.5/drivers/usb/storage/raw_bulk.h
--- linux-2.5/drivers/usb/storage/raw_bulk.h	2002-10-12 20:57:48.000000000 +0000
+++ usb-2.5/drivers/usb/storage/raw_bulk.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,20 +0,0 @@
-#ifndef _USB_STORAGE_RAW_BULK_H_
-#define _USB_STORAGE_RAW_BULK_H_
-
-/* scatter-gather */
-extern unsigned char *us_copy_from_sgbuf(
-	unsigned char *content, int buflen,
-	int *index, int *offset, int use_sg);
-
-extern unsigned char *us_copy_from_sgbuf_all(
-	unsigned char *content, int len, int use_sg);
-
-extern void us_copy_to_sgbuf(
-	unsigned char *buffer, int buflen,
-	void *content, int *index, int *offset, int use_sg);
-
-extern void us_copy_to_sgbuf_all(
-	unsigned char *buffer, int buflen,
-	void *content, int use_sg);
-
-#endif
diff -purN linux-2.5/drivers/usb/storage/scsiglue.c usb-2.5/drivers/usb/storage/scsiglue.c
--- linux-2.5/drivers/usb/storage/scsiglue.c	2003-11-21 23:34:15.000000000 +0000
+++ usb-2.5/drivers/usb/storage/scsiglue.c	2003-11-14 09:15:20.000000000 +0000
@@ -325,7 +325,8 @@ struct scsi_host_template usb_stor_host_
 	.emulated =			TRUE,
 
 	/* modify scsi_device bits on probe */
-	.flags = (BLIST_MS_SKIP_PAGE_08 | BLIST_USE_10_BYTE_MS),
+	.flags = (BLIST_MS_SKIP_PAGE_08 | BLIST_MS_SKIP_PAGE_3F |
+		  BLIST_USE_10_BYTE_MS),
 
 	/* module management */
 	.module =			THIS_MODULE
diff -purN linux-2.5/drivers/usb/storage/sddr09.c usb-2.5/drivers/usb/storage/sddr09.c
--- linux-2.5/drivers/usb/storage/sddr09.c	2003-08-22 03:31:46.000000000 +0000
+++ usb-2.5/drivers/usb/storage/sddr09.c	2003-12-02 16:28:49.000000000 +0000
@@ -28,7 +28,6 @@
  */
 
 #include "transport.h"
-#include "raw_bulk.h"
 #include "protocol.h"
 #include "usb.h"
 #include "debug.h"
@@ -66,7 +65,7 @@ struct nand_flash_dev {
  * NAND Flash Manufacturer ID Codes
  */
 #define NAND_MFR_AMD		0x01
-#define NAND_MFR_NS		0x8f
+#define NAND_MFR_NATSEMI	0x8f
 #define NAND_MFR_TOSHIBA	0x98
 #define NAND_MFR_SAMSUNG	0xec
 
@@ -74,8 +73,8 @@ static inline char *nand_flash_manufactu
 	switch(manuf_id) {
 	case NAND_MFR_AMD:
 		return "AMD";
-	case NAND_MFR_NS:
-		return "NS";
+	case NAND_MFR_NATSEMI:
+		return "NATSEMI";
 	case NAND_MFR_TOSHIBA:
 		return "Toshiba";
 	case NAND_MFR_SAMSUNG:
@@ -302,8 +301,7 @@ sddr09_request_sense(struct us_data *us,
 	if (result != USB_STOR_XFER_GOOD) {
 		US_DEBUGP("request sense bulk in failed\n");
 		return USB_STOR_TRANSPORT_ERROR;
-	}
-	else {
+	} else {
 		US_DEBUGP("request sense worked\n");
 		return USB_STOR_TRANSPORT_GOOD;
 	}
@@ -469,6 +467,8 @@ sddr09_erase(struct us_data *us, unsigne
 	unsigned char *command = us->iobuf;
 	int result;
 
+	US_DEBUGP("sddr09_erase: erase address %lu\n", Eaddress);
+
 	memset(command, 0, 12);
 	command[0] = 0xEA;
 	command[1] = LUNBITS;
@@ -663,30 +663,31 @@ static int
 sddr09_read_data(struct us_data *us,
 		 unsigned long address,
 		 unsigned int sectors,
-		 unsigned char *content,
+		 unsigned char *buffer,
 		 int use_sg) {
 
 	struct sddr09_card_info *info = (struct sddr09_card_info *) us->extra;
 	unsigned int lba, maxlba, pba;
 	unsigned int page, pages;
-	unsigned char *buffer = NULL;
-	unsigned char *ptr;
-	int result, len;
-
-	// If we're using scatter-gather, we have to create a new
-	// buffer to read all of the data in first, since a
-	// scatter-gather buffer could in theory start in the middle
-	// of a page, which would be bad. A developer who wants a
-	// challenge might want to write a limited-buffer
-	// version of this code.
-
-	len = sectors*info->pagesize;
-
-	buffer = (use_sg ? kmalloc(len, GFP_NOIO) : content);
-	if (buffer == NULL)
-		return USB_STOR_TRANSPORT_ERROR;
+	unsigned int len, index, offset;
+	int result;
 
-	ptr = buffer;
+	// Since we only read in one block at a time, we have to create
+	// a bounce buffer if the transfer uses scatter-gather.  We will
+	// move the data a piece at a time between the bounce buffer and
+	// the actual transfer buffer.  If we're not using scatter-gather,
+	// we can simply update the transfer buffer pointer to get the
+	// same effect.
+
+	if (use_sg) {
+		len = min(sectors, (unsigned int) info->blocksize) *
+				info->pagesize;
+		buffer = kmalloc(len, GFP_NOIO);
+		if (buffer == NULL) {
+			printk("sddr09_read_data: Out of memory\n");
+			return USB_STOR_TRANSPORT_ERROR;
+		}
+	}
 
 	// Figure out the initial LBA and page
 	lba = address >> info->blockshift;
@@ -697,13 +698,13 @@ sddr09_read_data(struct us_data *us,
 	// contiguous LBA's. Another exercise left to the student.
 
 	result = USB_STOR_TRANSPORT_GOOD;
+	index = offset = 0;
 
 	while (sectors > 0) {
 
 		/* Find number of pages we can read in this block */
-		pages = info->blocksize - page;
-		if (pages > sectors)
-			pages = sectors;
+		pages = min(sectors, info->blocksize - page);
+		len = pages << info->pageshift;
 
 		/* Not overflowing capacity? */
 		if (lba >= maxlba) {
@@ -726,7 +727,7 @@ sddr09_read_data(struct us_data *us,
 			   Instead of returning USB_STOR_TRANSPORT_ERROR
 			   it is better to return all zero data. */
 
-			memset(ptr, 0, pages << info->pageshift);
+			memset(buffer, 0, len);
 
 		} else {
 			US_DEBUGP("Read %d pages, from PBA %d"
@@ -737,37 +738,50 @@ sddr09_read_data(struct us_data *us,
 				info->pageshift;
 
 			result = sddr09_read20(us, address>>1,
-					       pages, info->pageshift, ptr, 0);
+					pages, info->pageshift, buffer, 0);
 			if (result != USB_STOR_TRANSPORT_GOOD)
 				break;
 		}
 
+		// Store the data (s-g) or update the pointer (!s-g)
+		if (use_sg)
+			usb_stor_access_xfer_buf(buffer, len, us->srb,
+					&index, &offset, TO_XFER_BUF);
+		else
+			buffer += len;
+
 		page = 0;
 		lba++;
 		sectors -= pages;
-		ptr += (pages << info->pageshift);
 	}
 
-	if (use_sg && result == USB_STOR_TRANSPORT_GOOD)
-		us_copy_to_sgbuf_all(buffer, len, content, use_sg);
-
 	if (use_sg)
 		kfree(buffer);
 
 	return result;
 }
 
-/* we never free blocks, so lastpba can only increase */
 static unsigned int
-sddr09_find_unused_pba(struct sddr09_card_info *info) {
+sddr09_find_unused_pba(struct sddr09_card_info *info, unsigned int lba) {
 	static unsigned int lastpba = 1;
-	int numblocks = info->capacity >> (info->blockshift + info->pageshift);
-	int i;
+	int zonestart, end, i;
 
-	for (i = lastpba+1; i < numblocks; i++) {
-		if (info->pba_to_lba[i] == UNDEF) {
+	zonestart = (lba/1000) << 10;
+	end = info->capacity >> (info->blockshift + info->pageshift);
+	end -= zonestart;
+	if (end > 1024)
+		end = 1024;
+
+	for (i = lastpba+1; i < end; i++) {
+		if (info->pba_to_lba[zonestart+i] == UNDEF) {
+			lastpba = i;
+			return zonestart+i;
+		}
+	}
+	for (i = 0; i <= lastpba; i++) {
+		if (info->pba_to_lba[zonestart+i] == UNDEF) {
 			lastpba = i;
-			return i;
+			return zonestart+i;
 		}
 	}
 	return 0;
@@ -776,29 +790,31 @@ sddr09_find_unused_pba(struct sddr09_car
 static int
 sddr09_write_lba(struct us_data *us, unsigned int lba,
 		 unsigned int page, unsigned int pages,
-		 unsigned char *ptr) {
+		 unsigned char *ptr, unsigned char *blockbuffer) {
 
 	struct sddr09_card_info *info = (struct sddr09_card_info *) us->extra;
 	unsigned long address;
 	unsigned int pba, lbap;
-	unsigned int pagelen, blocklen;
-	unsigned char *blockbuffer, *bptr, *cptr, *xptr;
+	unsigned int pagelen;
+	unsigned char *bptr, *cptr, *xptr;
 	unsigned char ecc[3];
-	int i, result;
+	int i, result, isnew;
 
-	lbap = ((lba & 0x3ff) << 1) | 0x1000;
+	lbap = ((lba % 1000) << 1) | 0x1000;
 	if (parity[MSB_of(lbap) ^ LSB_of(lbap)])
 		lbap ^= 1;
 	pba = info->lba_to_pba[lba];
+	isnew = 0;
 
 	if (pba == UNDEF) {
-		pba = sddr09_find_unused_pba(info);
+		pba = sddr09_find_unused_pba(info, lba);
 		if (!pba) {
 			printk("sddr09_write_lba: Out of unused blocks\n");
 			return USB_STOR_TRANSPORT_ERROR;
 		}
 		info->pba_to_lba[pba] = lba;
 		info->lba_to_pba[lba] = pba;
+		isnew = 1;
 	}
 
 	if (pba == 1) {
@@ -809,22 +825,16 @@ sddr09_write_lba(struct us_data *us, uns
 	}
 
 	pagelen = (1 << info->pageshift) + (1 << CONTROL_SHIFT);
-	blocklen = (pagelen << info->blockshift);
-	blockbuffer = kmalloc(blocklen, GFP_NOIO);
-	if (!blockbuffer) {
-		printk("sddr09_write_lba: Out of memory\n");
-		return USB_STOR_TRANSPORT_ERROR;
-	}
 
 	/* read old contents */
 	address = (pba << (info->pageshift + info->blockshift));
 	result = sddr09_read22(us, address>>1, info->blocksize,
 			       info->pageshift, blockbuffer, 0);
 	if (result != USB_STOR_TRANSPORT_GOOD)
-		goto err;
+		return result;
 
-	/* check old contents */
-	for (i = 0; i < info->blockshift; i++) {
+	/* check old contents and fill lba */
+	for (i = 0; i < info->blocksize; i++) {
 		bptr = blockbuffer + i*pagelen;
 		cptr = bptr + info->pagesize;
 		nand_compute_ecc(bptr, ecc);
@@ -839,6 +849,8 @@ sddr09_write_lba(struct us_data *us, uns
 				  i, pba);
 			nand_store_ecc(cptr+8, ecc);
 		}
+		cptr[6] = cptr[11] = MSB_of(lbap);
+		cptr[7] = cptr[12] = LSB_of(lbap);
 	}
 
 	/* copy in new stuff and compute ECC */
@@ -852,8 +864,6 @@ sddr09_write_lba(struct us_data *us, uns
 		nand_store_ecc(cptr+13, ecc);
 		nand_compute_ecc(bptr+(info->pagesize / 2), ecc);
 		nand_store_ecc(cptr+8, ecc);
-		cptr[6] = cptr[11] = MSB_of(lbap);
-		cptr[7] = cptr[12] = LSB_of(lbap);
 	}
 
 	US_DEBUGP("Rewrite PBA %d (LBA %d)\n", pba, lba);
@@ -880,11 +890,6 @@ sddr09_write_lba(struct us_data *us, uns
 		int result2 = sddr09_test_unit_ready(us);
 	}
 #endif
- err:
-	kfree(blockbuffer);
-
-	/* TODO: instead of doing kmalloc/kfree for each block,
-	   add a bufferpointer to the info structure */
 
 	return result;
 }
@@ -893,49 +898,84 @@ static int
 sddr09_write_data(struct us_data *us,
 		  unsigned long address,
 		  unsigned int sectors,
-		  unsigned char *content,
+		  unsigned char *buffer,
 		  int use_sg) {
 
 	struct sddr09_card_info *info = (struct sddr09_card_info *) us->extra;
 	unsigned int lba, page, pages;
-	unsigned char *buffer = NULL;
-	unsigned char *ptr;
-	int result, len;
+	unsigned int pagelen, blocklen;
+	unsigned char *blockbuffer;
+	unsigned int len, index, offset;
+	int result;
 
-	len = sectors*info->pagesize;
+	// blockbuffer is used for reading in the old data, overwriting
+	// with the new data, and performing ECC calculations
 
-	buffer = us_copy_from_sgbuf_all(content, len, use_sg);
-	if (buffer == NULL)
+	/* TODO: instead of doing kmalloc/kfree for each write,
+	   add a bufferpointer to the info structure */
+
+	pagelen = (1 << info->pageshift) + (1 << CONTROL_SHIFT);
+	blocklen = (pagelen << info->blockshift);
+	blockbuffer = kmalloc(blocklen, GFP_NOIO);
+	if (!blockbuffer) {
+		printk("sddr09_write_data: Out of memory\n");
 		return USB_STOR_TRANSPORT_ERROR;
+	}
 
-	ptr = buffer;
+	// Since we don't write the user data directly to the device,
+	// we have to create a bounce buffer if the transfer uses
+	// scatter-gather.  We will move the data a piece at a time
+	// between the bounce buffer and the actual transfer buffer.
+	// If we're not using scatter-gather, we can simply update
+	// the transfer buffer pointer to get the same effect.
+
+	if (use_sg) {
+		len = min(sectors, (unsigned int) info->blocksize) *
+				info->pagesize;
+		buffer = kmalloc(len, GFP_NOIO);
+		if (buffer == NULL) {
+			printk("sddr09_write_data: Out of memory\n");
+			kfree(blockbuffer);
+			return USB_STOR_TRANSPORT_ERROR;
+		}
+	}
 
 	// Figure out the initial LBA and page
 	lba = address >> info->blockshift;
 	page = (address & info->blockmask);
 
 	result = USB_STOR_TRANSPORT_GOOD;
+	index = offset = 0;
 
 	while (sectors > 0) {
 
 		// Write as many sectors as possible in this block
 
-		pages = info->blocksize - page;
-		if (pages > sectors)
-			pages = sectors;
+		pages = min(sectors, info->blocksize - page);
+		len = (pages << info->pageshift);
+
+		// Get the data from the transfer buffer (s-g)
+		if (use_sg)
+			usb_stor_access_xfer_buf(buffer, len, us->srb,
+					&index, &offset, FROM_XFER_BUF);
 
-		result = sddr09_write_lba(us, lba, page, pages, ptr);
+		result = sddr09_write_lba(us, lba, page, pages,
+				buffer, blockbuffer);
 		if (result != USB_STOR_TRANSPORT_GOOD)
 			break;
 
+		// Update the transfer buffer pointer (!s-g)
+		if (!use_sg)
+			buffer += len;
+
 		page = 0;
 		lba++;
 		sectors -= pages;
-		ptr += (pages << info->pageshift);
 	}
 
 	if (use_sg)
 		kfree(buffer);
+	kfree(blockbuffer);
 
 	return result;
 }
@@ -947,10 +987,11 @@ sddr09_read_control(struct us_data *us,
 		unsigned char *content,
 		int use_sg) {
 
-	US_DEBUGP("Read control address %08lX blocks %04X\n",
+	US_DEBUGP("Read control address %lu, blocks %d\n",
 		address, blocks);
 
-	return sddr09_read21(us, address, blocks, CONTROL_SHIFT, content, use_sg);
+	return sddr09_read21(us, address, blocks,
+			     CONTROL_SHIFT, content, use_sg);
 }
 
 /*
@@ -997,7 +1038,7 @@ sddr09_get_wp(struct us_data *us, struct
 		US_DEBUGP("sddr09_get_wp: read_status fails\n");
 		return result;
 	}
-	US_DEBUGP("sddr09_get_wp: status %02X", status);
+	US_DEBUGP("sddr09_get_wp: status 0x%02X", status);
 	if ((status & 0x80) == 0) {
 		info->flags |= SDDR09_WP;	/* write protected */
 		US_DEBUGP(" WP");
@@ -1092,69 +1133,36 @@ sddr09_get_cardinfo(struct us_data *us, 
 static int
 sddr09_read_map(struct us_data *us) {
 
-	struct scatterlist *sg;
 	struct sddr09_card_info *info = (struct sddr09_card_info *) us->extra;
 	int numblocks, alloc_len, alloc_blocks;
 	int i, j, result;
-	unsigned char *ptr;
+	unsigned char *buffer, *buffer_end, *ptr;
 	unsigned int lba, lbact;
 
 	if (!info->capacity)
 		return -1;
 
-	// read 64 (1<<6) bytes for every block 
-	// ( 1 << ( blockshift + pageshift ) bytes)
-	//	 of capacity:
-	// (1<<6)*capacity/(1<<(b+p)) =
-	// ((1<<6)*capacity)>>(b+p) =
-	// capacity>>(b+p-6)
-
-	alloc_len = info->capacity >> 
-		(info->blockshift + info->pageshift - CONTROL_SHIFT);
-
-	// Allocate a number of scatterlist structures according to
-	// the number of 128k blocks in the alloc_len. Adding 128k-1
-	// and then dividing by 128k gives the correct number of blocks.
-	// 128k = 1<<17
-
-	alloc_blocks = (alloc_len + (1<<17) - 1) >> 17;
-	sg = kmalloc(alloc_blocks*sizeof(struct scatterlist),
-		     GFP_NOIO);
-	if (sg == NULL)
-		return 0;
-
-	for (i=0; i<alloc_blocks; i++) {
-		int alloc_req = (i < alloc_blocks-1 ? 1 << 17 : alloc_len);
-		char *vaddr = kmalloc(alloc_req, GFP_NOIO);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,3)
-		sg[i].page = virt_to_page(vaddr);
-		sg[i].offset = offset_in_page(vaddr);
-#else
-		sg[i].address = vaddr;
-#endif
-		sg[i].length = alloc_req;
-		alloc_len -= alloc_req;
-	}
-
-	for (i=0; i<alloc_blocks; i++)
-		if (sg[i].page == NULL) {
-			for (i=0; i<alloc_blocks; i++)
-				if (sg[i].page != NULL)
-					kfree(sg_address(sg[i]));
-			kfree(sg);
-			return 0;
-		}
+	// size of a block is 1 << (blockshift + pageshift) bytes
+	// divide into the total capacity to get the number of blocks
 
 	numblocks = info->capacity >> (info->blockshift + info->pageshift);
 
-	result = sddr09_read_control(us, 0, numblocks,
-				     (unsigned char *)sg, alloc_blocks);
-	if (result != USB_STOR_TRANSPORT_GOOD) {
-		for (i=0; i<alloc_blocks; i++)
-			kfree(sg_address(sg[i]));
-		kfree(sg);
-		return -1;
+	// read 64 bytes for every block (actually 1 << CONTROL_SHIFT)
+	// but only use a 64 KB buffer
+	// buffer size used must be a multiple of (1 << CONTROL_SHIFT)
+#define SDDR09_READ_MAP_BUFSZ 65536
+
+	alloc_blocks = min(numblocks, SDDR09_READ_MAP_BUFSZ >> CONTROL_SHIFT);
+	alloc_len = (alloc_blocks << CONTROL_SHIFT);
+	buffer = kmalloc(alloc_len, GFP_NOIO);
+	if (buffer == NULL) {
+		printk("sddr09_read_map: out of memory\n");
+		result = -1;
+		goto done;
 	}
+	buffer_end = buffer + alloc_len;
+
+#undef SDDR09_READ_MAP_BUFSZ
 
 	kfree(info->lba_to_pba);
 	kfree(info->pba_to_lba);
@@ -1162,29 +1170,35 @@ sddr09_read_map(struct us_data *us) {
 	info->pba_to_lba = kmalloc(numblocks*sizeof(int), GFP_NOIO);
 
 	if (info->lba_to_pba == NULL || info->pba_to_lba == NULL) {
-		kfree(info->lba_to_pba);
-		kfree(info->pba_to_lba);
-		info->lba_to_pba = NULL;
-		info->pba_to_lba = NULL;
-		for (i=0; i<alloc_blocks; i++)
-			kfree(sg_address(sg[i]));
-		kfree(sg);
-		return 0;
+		printk("sddr09_read_map: out of memory\n");
+		result = -1;
+		goto done;
 	}
 
 	for (i = 0; i < numblocks; i++)
 		info->lba_to_pba[i] = info->pba_to_lba[i] = UNDEF;
 
-	ptr = sg_address(sg[0]);
-
 	/*
 	 * Define lba-pba translation table
 	 */
-	// Each block is 64 bytes of control data, so block i is located in
-	// scatterlist block i*64/128k = i*(2^6)*(2^-17) = i*(2^-11)
 
-	for (i=0; i<numblocks; i++) {
-		ptr = sg_address(sg[i>>11]) + ((i&0x7ff)<<6);
+	ptr = buffer_end;
+	for (i = 0; i < numblocks; i++) {
+		ptr += (1 << CONTROL_SHIFT);
+		if (ptr >= buffer_end) {
+			unsigned long address;
+
+			address = i << (info->pageshift + info->blockshift);
+			result = sddr09_read_control(
+				us, address>>1,
+				min(alloc_blocks, numblocks - i),
+				buffer, 0);
+			if (result != USB_STOR_TRANSPORT_GOOD) {
+				result = -1;
+				goto done;
+			}
+			ptr = buffer;
+		}
 
 		if (i == 0 || i == 1) {
 			info->pba_to_lba[i] = UNUSABLE;
@@ -1196,7 +1210,7 @@ sddr09_read_map(struct us_data *us) {
 			if (ptr[j] != 0)
 				goto nonz;
 		info->pba_to_lba[i] = UNUSABLE;
-		printk("sddr09: PBA %04X has no logical mapping\n", i);
+		printk("sddr09: PBA %d has no logical mapping\n", i);
 		continue;
 
 	nonz:
@@ -1209,7 +1223,7 @@ sddr09_read_map(struct us_data *us) {
 	nonff:
 		/* normal PBAs start with six FFs */
 		if (j < 6) {
-			printk("sddr09: PBA %04X has no logical mapping: "
+			printk("sddr09: PBA %d has no logical mapping: "
 			       "reserved area = %02X%02X%02X%02X "
 			       "data status %02X block status %02X\n",
 			       i, ptr[0], ptr[1], ptr[2], ptr[3],
@@ -1219,7 +1233,7 @@ sddr09_read_map(struct us_data *us) {
 		}
 
 		if ((ptr[6] >> 4) != 0x01) {
-			printk("sddr09: PBA %04X has invalid address field "
+			printk("sddr09: PBA %d has invalid address field "
 			       "%02X%02X/%02X%02X\n",
 			       i, ptr[6], ptr[7], ptr[11], ptr[12]);
 			info->pba_to_lba[i] = UNUSABLE;
@@ -1228,7 +1242,7 @@ sddr09_read_map(struct us_data *us) {
 
 		/* check even parity */
 		if (parity[ptr[6] ^ ptr[7]]) {
-			printk("sddr09: Bad parity in LBA for block %04X"
+			printk("sddr09: Bad parity in LBA for block %d"
 			       " (%02X %02X)\n", i, ptr[6], ptr[7]);
 			info->pba_to_lba[i] = UNUSABLE;
 			continue;
@@ -1247,27 +1261,32 @@ sddr09_read_map(struct us_data *us) {
 		 */
 
 		if (lba >= 1000) {
-			unsigned long address;
-
-			printk("sddr09: Bad LBA %04X for block %04X\n",
+			printk("sddr09: Bad low LBA %d for block %d\n",
 			       lba, i);
-			info->pba_to_lba[i] = UNDEF /* UNUSABLE */;
-			if (erase_bad_lba_entries) {
-				/* some cameras cannot erase a card if it has
-				   bad entries, so we supply this function */
-				address = (i << (info->pageshift + info->blockshift));
-				sddr09_erase(us, address>>1);
-			}
-			continue;
+			goto possibly_erase;
 		}
 
 		lba += 1000*(i/0x400);
 
-		if (lba<0x10 || (lba >= 0x3E0 && lba < 0x3EF))
-			US_DEBUGP("LBA %04X <-> PBA %04X\n", lba, i);
+		if (info->lba_to_pba[lba] != UNDEF) {
+			printk("sddr09: LBA %d seen for PBA %d and %d\n",
+			       lba, info->lba_to_pba[lba], i);
+			goto possibly_erase;
+		}
 
 		info->pba_to_lba[i] = lba;
 		info->lba_to_pba[lba] = i;
+		continue;
+
+	possibly_erase:
+		if (erase_bad_lba_entries) {
+			unsigned long address;
+
+			address = (i << (info->pageshift + info->blockshift));
+			sddr09_erase(us, address>>1);
+			info->pba_to_lba[i] = UNDEF;
+		} else
+			info->pba_to_lba[i] = UNUSABLE;
 	}
 
 	/*
@@ -1292,11 +1311,17 @@ sddr09_read_map(struct us_data *us) {
 	}
 	info->lbact = lbact;
 	US_DEBUGP("Found %d LBA's\n", lbact);
+	result = 0;
 
-	for (i=0; i<alloc_blocks; i++)
-		kfree(sg_address(sg[i]));
-	kfree(sg);
-	return 0;
+ done:
+	if (result != 0) {
+		kfree(info->lba_to_pba);
+		kfree(info->pba_to_lba);
+		info->lba_to_pba = NULL;
+		info->pba_to_lba = NULL;
+	}
+	kfree(buffer);
+	return result;
 }
 
 static void
@@ -1438,6 +1463,7 @@ int sddr09_transport(Scsi_Cmnd *srb, str
 		cardinfo = sddr09_get_cardinfo(us, info->flags);
 		if (!cardinfo) {
 			/* probably no media */
+		init_error:
 			sensekey = 0x02;	/* not ready */
 			sensecode = 0x3a;	/* medium not present */
 			return USB_STOR_TRANSPORT_FAILED;
@@ -1451,7 +1477,10 @@ int sddr09_transport(Scsi_Cmnd *srb, str
 		info->blockmask = info->blocksize - 1;
 
 		// map initialization, must follow get_cardinfo()
-		sddr09_read_map(us);
+		if (sddr09_read_map(us)) {
+			/* probably out of memory */
+			goto init_error;
+		}
 
 		// Report capacity
 
@@ -1472,12 +1501,13 @@ int sddr09_transport(Scsi_Cmnd *srb, str
 		return USB_STOR_TRANSPORT_GOOD;
 	}
 
-	if (srb->cmnd[0] == MODE_SENSE) {
+	if (srb->cmnd[0] == MODE_SENSE || srb->cmnd[0] == MODE_SENSE_10) {
 		int modepage = (srb->cmnd[2] & 0x3F);
 		int len;
 
 		/* They ask for the Read/Write error recovery page,
 		   or for all pages. Give as much as they have room for. */
+		/* %% We should check DBD %% */
 		if (modepage == 0x01 || modepage == 0x3F) {
 
 			US_DEBUGP("SDDR09: Dummy up request for "
@@ -1496,20 +1526,14 @@ int sddr09_transport(Scsi_Cmnd *srb, str
 			return USB_STOR_TRANSPORT_GOOD;
 		}
 
-		return USB_STOR_TRANSPORT_ERROR;
+		sensekey = 0x05;	/* illegal request */
+		sensecode = 0x24;	/* invalid field in CDB */
+		return USB_STOR_TRANSPORT_FAILED;
 	}
 
-	if (srb->cmnd[0] == ALLOW_MEDIUM_REMOVAL) {
-
-		US_DEBUGP(
-			"SDDR09: %s medium removal. Not that I can do"
-			" anything about it...\n",
-			(srb->cmnd[4]&0x03) ? "Prevent" : "Allow");
-
+	if (srb->cmnd[0] == ALLOW_MEDIUM_REMOVAL)
 		return USB_STOR_TRANSPORT_GOOD;
 
-	}
-
 	havefakesense = 0;
 
 	if (srb->cmnd[0] == READ_10) {
@@ -1542,8 +1566,10 @@ int sddr09_transport(Scsi_Cmnd *srb, str
 
 	if (srb->cmnd[0] != TEST_UNIT_READY &&
 	    srb->cmnd[0] != REQUEST_SENSE) {
+		sensekey = 0x05;	/* illegal request */
+		sensecode = 0x20;	/* invalid command */
 		havefakesense = 1;
-		return USB_STOR_TRANSPORT_ERROR;
+		return USB_STOR_TRANSPORT_FAILED;
 	}
 
 	for (; srb->cmd_len<12; srb->cmd_len++)
@@ -1555,8 +1581,7 @@ int sddr09_transport(Scsi_Cmnd *srb, str
 	for (i=0; i<12; i++)
 		sprintf(string+strlen(string), "%02X ", srb->cmnd[i]);
 
-	US_DEBUGP("SDDR09: Send control for command %s\n",
-		  string);
+	US_DEBUGP("SDDR09: Send control for command %s\n", string);
 
 	result = sddr09_send_scsi_command(us, srb->cmnd, 12);
 	if (result != USB_STOR_TRANSPORT_GOOD) {
diff -purN linux-2.5/drivers/usb/storage/sddr55.c usb-2.5/drivers/usb/storage/sddr55.c
--- linux-2.5/drivers/usb/storage/sddr55.c	2003-07-09 15:49:51.000000000 +0000
+++ usb-2.5/drivers/usb/storage/sddr55.c	2003-12-02 16:29:43.000000000 +0000
@@ -25,7 +25,6 @@
  */
 
 #include "transport.h"
-#include "raw_bulk.h"
 #include "protocol.h"
 #include "usb.h"
 #include "debug.h"
@@ -155,7 +154,7 @@ static int sddr55_read_data(struct us_da
 		unsigned int lba,
 		unsigned int page,
 		unsigned short sectors,
-		unsigned char *content,
+		unsigned char *buffer,
 		int use_sg) {
 
 	int result = USB_STOR_TRANSPORT_GOOD;
@@ -167,17 +166,24 @@ static int sddr55_read_data(struct us_da
 	unsigned long address;
 
 	unsigned short pages;
-	unsigned char *buffer = NULL;
-	unsigned char *ptr;
-	int len;
-
-	len = sectors * PAGESIZE;
-
-	buffer = (use_sg ? kmalloc(len, GFP_NOIO) : content);
-	if (buffer == NULL)
-		return USB_STOR_TRANSPORT_ERROR; /* out of memory */
+	unsigned int len, index, offset;
 
-	ptr = buffer;
+	// Since we only read in one block at a time, we have to create
+	// a bounce buffer if the transfer uses scatter-gather.  We will
+	// move the data a piece at a time between the bounce buffer and
+	// the actual transfer buffer.  If we're not using scatter-gather,
+	// we can simply update the transfer buffer pointer to get the
+	// same effect.
+
+	if (use_sg) {
+		len = min((unsigned int) sectors,
+				(unsigned int) info->blocksize >>
+					info->smallpageshift) * PAGESIZE;
+		buffer = kmalloc(len, GFP_NOIO);
+		if (buffer == NULL)
+			return USB_STOR_TRANSPORT_ERROR; /* out of memory */
+	}
+	index = offset = 0;
 
 	while (sectors>0) {
 
@@ -189,9 +195,9 @@ static int sddr55_read_data(struct us_da
 
 		// Read as many sectors as possible in this block
 
-		pages = info->blocksize - page;
-		if (pages > (sectors << info->smallpageshift))
-			pages = (sectors << info->smallpageshift);
+		pages = min((unsigned int) sectors << info->smallpageshift,
+				info->blocksize - page);
+		len = pages << info->pageshift;
 
 		US_DEBUGP("Read %02X pages, from PBA %04X"
 			" (LBA %04X) page %02X\n",
@@ -199,7 +205,7 @@ static int sddr55_read_data(struct us_da
 
 		if (pba == NOT_ALLOCATED) {
 			/* no pba for this lba, fill with zeroes */
-			memset (ptr, 0, pages << info->pageshift);
+			memset (buffer, 0, len);
 		} else {
 
 			address = (pba << info->blockshift) + page;
@@ -228,8 +234,7 @@ static int sddr55_read_data(struct us_da
 
 			/* read data */
 			result = sddr55_bulk_transport(us,
-				SCSI_DATA_READ, ptr,
-				pages<<info->pageshift);
+				SCSI_DATA_READ, buffer, len);
 
 			if (result != USB_STOR_XFER_GOOD) {
 				result = USB_STOR_TRANSPORT_ERROR;
@@ -253,13 +258,18 @@ static int sddr55_read_data(struct us_da
 			}
 		}
 
+		// Store the data (s-g) or update the pointer (!s-g)
+		if (use_sg)
+			usb_stor_access_xfer_buf(buffer, len, us->srb,
+					&index, &offset, TO_XFER_BUF);
+		else
+			buffer += len;
+
 		page = 0;
 		lba++;
 		sectors -= pages >> info->smallpageshift;
-		ptr += (pages << info->pageshift);
 	}
 
-	us_copy_to_sgbuf_all(buffer, len, content, use_sg);
 	result = USB_STOR_TRANSPORT_GOOD;
 
 leave:
@@ -273,7 +283,7 @@ static int sddr55_write_data(struct us_d
 		unsigned int lba,
 		unsigned int page,
 		unsigned short sectors,
-		unsigned char *content,
+		unsigned char *buffer,
 		int use_sg) {
 
 	int result = USB_STOR_TRANSPORT_GOOD;
@@ -286,9 +296,8 @@ static int sddr55_write_data(struct us_d
 	unsigned long address;
 
 	unsigned short pages;
-	unsigned char *buffer = NULL;
-	unsigned char *ptr;
-	int i, len;
+	int i;
+	unsigned int len, index, offset;
 
 	/* check if we are allowed to write */
 	if (info->read_only || info->force_read_only) {
@@ -296,13 +305,22 @@ static int sddr55_write_data(struct us_d
 		return USB_STOR_TRANSPORT_FAILED;
 	}
 
-	len = sectors * PAGESIZE;
-
-	buffer = us_copy_from_sgbuf_all(content, len, use_sg);
-	if (buffer == NULL)
-		return USB_STOR_TRANSPORT_ERROR;
-
-	ptr = buffer;
+	// Since we only write one block at a time, we have to create
+	// a bounce buffer if the transfer uses scatter-gather.  We will
+	// move the data a piece at a time between the bounce buffer and
+	// the actual transfer buffer.  If we're not using scatter-gather,
+	// we can simply update the transfer buffer pointer to get the
+	// same effect.
+
+	if (use_sg) {
+		len = min((unsigned int) sectors,
+				(unsigned int) info->blocksize >>
+					info->smallpageshift) * PAGESIZE;
+		buffer = kmalloc(len, GFP_NOIO);
+		if (buffer == NULL)
+			return USB_STOR_TRANSPORT_ERROR;
+	}
+	index = offset = 0;
 
 	while (sectors > 0) {
 
@@ -314,9 +332,14 @@ static int sddr55_write_data(struct us_d
 
 		// Write as many sectors as possible in this block
 
-		pages = info->blocksize - page;
-		if (pages > (sectors << info->smallpageshift))
-			pages = (sectors << info->smallpageshift);
+		pages = min((unsigned int) sectors << info->smallpageshift,
+				info->blocksize - page);
+		len = pages << info->pageshift;
+
+		// Get the data from the transfer buffer (s-g)
+		if (use_sg)
+			usb_stor_access_xfer_buf(buffer, len, us->srb,
+					&index, &offset, FROM_XFER_BUF);
 
 		US_DEBUGP("Write %02X pages, to PBA %04X"
 			" (LBA %04X) page %02X\n",
@@ -400,8 +423,7 @@ static int sddr55_write_data(struct us_d
 
 		/* send the data */
 		result = sddr55_bulk_transport(us,
-			SCSI_DATA_WRITE, ptr,
-			pages<<info->pageshift);
+			SCSI_DATA_WRITE, buffer, len);
 
 		if (result != USB_STOR_XFER_GOOD) {
 			US_DEBUGP("Result for send_data in write_data %d\n",
@@ -458,10 +480,12 @@ static int sddr55_write_data(struct us_d
 		/* update the pba<->lba maps for new_pba */
 		info->pba_to_lba[new_pba] = lba % 1000;
 
+		// Update the transfer buffer pointer (!s-g)
+		if (!use_sg)
+			buffer += len;
 		page = 0;
 		lba++;
 		sectors -= pages >> info->smallpageshift;
-		ptr += (pages << info->pageshift);
 	}
 	result = USB_STOR_TRANSPORT_GOOD;
 
diff -purN linux-2.5/drivers/usb/storage/shuttle_usbat.c usb-2.5/drivers/usb/storage/shuttle_usbat.c
--- linux-2.5/drivers/usb/storage/shuttle_usbat.c	2003-07-30 10:11:51.000000000 +0000
+++ usb-2.5/drivers/usb/storage/shuttle_usbat.c	2003-12-02 16:29:00.000000000 +0000
@@ -40,7 +40,6 @@
  */
 
 #include "transport.h"
-#include "raw_bulk.h"
 #include "protocol.h"
 #include "usb.h"
 #include "debug.h"
@@ -529,9 +528,8 @@ int usbat_handle_read10(struct us_data *
 	unsigned char *buffer;
 	unsigned int len;
 	unsigned int sector;
-	struct scatterlist *sg = NULL;
-	int sg_segment = 0;
-	int sg_offset = 0;
+	unsigned int sg_segment = 0;
+	unsigned int sg_offset = 0;
 
 	US_DEBUGP("handle_read10: transfersize %d\n",
 		srb->transfersize);
@@ -570,21 +568,29 @@ int usbat_handle_read10(struct us_data *
 			srb->transfersize);
 	}
 
+	// Since we only read in one block at a time, we have to create
+	// a bounce buffer if the transfer uses scatter-gather.  We will
+	// move the data a piece at a time between the bounce buffer and
+	// the actual transfer buffer.  If we're not using scatter-gather,
+	// we can simply update the transfer buffer pointer to get the
+	// same effect.
+
 	len = (65535/srb->transfersize) * srb->transfersize;
 	US_DEBUGP("Max read is %d bytes\n", len);
-	buffer = kmalloc(len, GFP_NOIO);
-	if (buffer == NULL) // bloody hell!
-		return USB_STOR_TRANSPORT_FAILED;
+	len = min(len, srb->request_bufflen);
+	if (srb->use_sg) {
+		buffer = kmalloc(len, GFP_NOIO);
+		if (buffer == NULL) // bloody hell!
+			return USB_STOR_TRANSPORT_FAILED;
+	} else
+		buffer = srb->request_buffer;
 	sector = short_pack(data[7+3], data[7+2]);
 	sector <<= 16;
 	sector |= short_pack(data[7+5], data[7+4]);
 	transferred = 0;
 
-	if (srb->use_sg) {
-		sg = (struct scatterlist *)srb->request_buffer;
-		sg_segment = 0; // for keeping track of where we are in
-		sg_offset = 0;  // the scatter/gather list
-	}
+	sg_segment = 0; // for keeping track of where we are in
+	sg_offset = 0;  // the scatter/gather list
 
 	while (transferred != srb->request_bufflen) {
 
@@ -615,13 +621,12 @@ int usbat_handle_read10(struct us_data *
 		if (result != USB_STOR_TRANSPORT_GOOD)
 			break;
 
-		// Transfer the received data into the srb buffer
-
+		// Store the data (s-g) or update the pointer (!s-g)
 		if (srb->use_sg)
-			us_copy_to_sgbuf(buffer, len, sg,
-					 &sg_segment, &sg_offset, srb->use_sg);
+			usb_stor_access_xfer_buf(buffer, len, srb,
+					 &sg_segment, &sg_offset, TO_XFER_BUF);
 		else
-			memcpy(srb->request_buffer+transferred, buffer, len);
+			buffer += len;
 
 		// Update the amount transferred and the sector number
 
@@ -630,7 +635,8 @@ int usbat_handle_read10(struct us_data *
 
 	} // while transferred != srb->request_bufflen
 
-	kfree(buffer);
+	if (srb->use_sg)
+		kfree(buffer);
 	return result;
 }
 
diff -purN linux-2.5/drivers/usb/storage/transport.c usb-2.5/drivers/usb/storage/transport.c
--- linux-2.5/drivers/usb/storage/transport.c	2003-09-21 21:11:40.000000000 +0000
+++ usb-2.5/drivers/usb/storage/transport.c	2003-10-24 15:05:36.000000000 +0000
@@ -760,6 +760,7 @@ void usb_stor_stop_transport(struct us_d
 int usb_stor_CBI_transport(Scsi_Cmnd *srb, struct us_data *us)
 {
 	unsigned int transfer_length = srb->request_bufflen;
+	unsigned int pipe = 0;
 	int result;
 
 	/* COMMAND STAGE */
@@ -785,7 +786,7 @@ int usb_stor_CBI_transport(Scsi_Cmnd *sr
 	/* DATA STAGE */
 	/* transfer the data payload for this command, if one exists*/
 	if (transfer_length) {
-		unsigned int pipe = srb->sc_data_direction == SCSI_DATA_READ ? 
+		pipe = srb->sc_data_direction == SCSI_DATA_READ ? 
 				us->recv_bulk_pipe : us->send_bulk_pipe;
 		result = usb_stor_bulk_transfer_sg(us, pipe,
 					srb->request_buffer, transfer_length,
@@ -813,12 +814,9 @@ int usb_stor_CBI_transport(Scsi_Cmnd *sr
 		if (srb->cmnd[0] == REQUEST_SENSE ||
 		    srb->cmnd[0] == INQUIRY)
 			return USB_STOR_TRANSPORT_GOOD;
-		else {
-			if (us->iobuf[0])
-				return USB_STOR_TRANSPORT_FAILED;
-			else
-				return USB_STOR_TRANSPORT_GOOD;
-		}
+		if (us->iobuf[0])
+			goto Failed;
+		return USB_STOR_TRANSPORT_GOOD;
 	}
 
 	/* If not UFI, we interpret the data as a result code 
@@ -835,13 +833,17 @@ int usb_stor_CBI_transport(Scsi_Cmnd *sr
 		case 0x00: 
 			return USB_STOR_TRANSPORT_GOOD;
 		case 0x01: 
-			return USB_STOR_TRANSPORT_FAILED;
-		default: 
-			return USB_STOR_TRANSPORT_ERROR;
+			goto Failed;
 	}
-
-	/* we should never get here, but if we do, we're in trouble */
 	return USB_STOR_TRANSPORT_ERROR;
+
+	/* the CBI spec requires that the bulk pipe must be cleared
+	 * following any data-in/out command failure (section 2.4.3.1.3)
+	 */
+  Failed:
+	if (pipe)
+		usb_stor_clear_halt(us, pipe);
+	return USB_STOR_TRANSPORT_FAILED;
 }
 
 /*
@@ -924,6 +926,7 @@ int usb_stor_Bulk_transport(Scsi_Cmnd *s
 	struct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;
 	struct bulk_cs_wrap *bcs = (struct bulk_cs_wrap *) us->iobuf;
 	unsigned int transfer_length = srb->request_bufflen;
+	unsigned int residue;
 	int result;
 	int fake_sense = 0;
 
@@ -999,9 +1002,10 @@ int usb_stor_Bulk_transport(Scsi_Cmnd *s
 		return USB_STOR_TRANSPORT_ERROR;
 
 	/* check bulk status */
-	US_DEBUGP("Bulk Status S 0x%x T 0x%x R %d Stat 0x%x\n",
+	residue = le32_to_cpu(bcs->Residue);
+	US_DEBUGP("Bulk Status S 0x%x T 0x%x R %u Stat 0x%x\n",
 			le32_to_cpu(bcs->Signature), bcs->Tag, 
-			bcs->Residue, bcs->Status);
+			residue, bcs->Status);
 	if ((bcs->Signature != cpu_to_le32(US_BULK_CS_SIGN) &&
 		    bcs->Signature != cpu_to_le32(US_BULK_CS_OLYMPUS_SIGN)) ||
 			bcs->Tag != srb->serial_number || 
@@ -1010,6 +1014,11 @@ int usb_stor_Bulk_transport(Scsi_Cmnd *s
 		return USB_STOR_TRANSPORT_ERROR;
 	}
 
+	/* try to compute the actual residue, based on how much data
+	 * was really transferred and what the device tells us */
+	residue = min(residue, transfer_length);
+	srb->resid = max(srb->resid, (int) residue);
+
 	/* based on the status code, we report good or bad */
 	switch (bcs->Status) {
 		case US_BULK_STAT_OK:
diff -purN linux-2.5/drivers/usb/storage/unusual_devs.h usb-2.5/drivers/usb/storage/unusual_devs.h
--- linux-2.5/drivers/usb/storage/unusual_devs.h	2003-10-20 14:17:35.000000000 +0000
+++ usb-2.5/drivers/usb/storage/unusual_devs.h	2003-12-04 10:18:54.000000000 +0000
@@ -45,6 +45,13 @@
  *
  */
 
+/* Patch submitted by Martin Berentsen <berentsen at sent5 dot uni-duisburg dot de> */
+#define US_FL_START_STOP  0x00000004   /* ignore START_STOP commands     */
+UNUSUAL_DEV(  0x0686, 0x4014, 0x0001, 0x0001, 
+		"Minolta",
+		"Dimage S414",
+		US_SC_SCSI, US_PR_BULK, NULL, US_FL_START_STOP), 
+
 UNUSUAL_DEV(  0x03ee, 0x0000, 0x0000, 0x0245, 
 		"Mitsumi",
 		"CD-R/RW Drive",
@@ -53,7 +60,7 @@ UNUSUAL_DEV(  0x03ee, 0x0000, 0x0000, 0x
 UNUSUAL_DEV(  0x03ee, 0x6901, 0x0000, 0x0100,
 		"Mitsumi",
 		"USB FDD",
-		US_SC_UFI, US_PR_CBI, NULL,
+		US_SC_DEVICE, US_PR_DEVICE, NULL,
 		US_FL_SINGLE_LUN ),
 
 UNUSUAL_DEV(  0x03f0, 0x0107, 0x0200, 0x0200, 
@@ -102,6 +109,12 @@ UNUSUAL_DEV(  0x0482, 0x0101, 0x0100, 0x
 		"Finecam S4",
 		US_SC_8070, US_PR_CB, NULL, US_FL_FIX_INQUIRY),
 
+/* Patch submitted by Stephane Galles <stephane.galles@free.fr> */
+UNUSUAL_DEV(  0x0482, 0x0103, 0x0100, 0x0100,
+		"Kyocera",
+		"Finecam S5",
+		US_SC_DEVICE, US_PR_DEVICE, NULL, US_FL_FIX_INQUIRY),
+
 /* Reported by Paul Stewart <stewart@wetlogic.net>
  * This entry is needed because the device reports Sub=ff */
 UNUSUAL_DEV(  0x04a4, 0x0004, 0x0001, 0x0001,
@@ -257,7 +270,7 @@ UNUSUAL_DEV(  0x054c, 0x002b, 0x0100, 0x
 UNUSUAL_DEV(  0x054c, 0x002d, 0x0100, 0x0100, 
 		"Sony",
 		"Memorystick MSAC-US1",
-		US_SC_UFI, US_PR_CB, NULL,
+		US_SC_DEVICE, US_PR_DEVICE, NULL,
 		US_FL_SINGLE_LUN ),
 
 /* Submitted by Klaus Mueller <k.mueller@intershop.de> */
@@ -354,6 +367,13 @@ UNUSUAL_DEV(  0x05e3, 0x0700, 0x0000, 0x
 		US_SC_DEVICE, US_PR_DEVICE, NULL,
 		US_FL_FIX_INQUIRY ),
 
+/* Submitted Alexander Oltu <alexander@all-2.com> */
+UNUSUAL_DEV(  0x05e3, 0x0701, 0x0000, 0xffff, 
+		"", 
+		"USB TO IDE",
+		US_SC_SCSI, US_PR_BULK, NULL,
+		US_FL_MODE_XLATE ), 
+
 /* Reported by Peter Marks <peter.marks@turner.com>
  * Like the SIIG unit above, this unit needs an INQUIRY to ask for exactly
  * 36 bytes of data.  No more, no less. That is the only reason this entry
@@ -400,6 +420,28 @@ UNUSUAL_DEV(  0x0686, 0x4017, 0x0001, 0x
                 "DIMAGE E223",
                 US_SC_SCSI, US_PR_DEVICE, NULL, 0 ),
 
+/* Following three Minolta cameras reported by Martin Pool
+ * <mbp@sourcefrog.net>.  Originally discovered by Kedar Petankar,
+ * Matthew Geier, Mikael Lofj"ard, Marcel de Boer.
+ */
+UNUSUAL_DEV( 0x0686, 0x4006, 0x0001, 0x0001,
+             "Minolta",
+             "DiMAGE 7",
+             US_SC_SCSI, US_PR_DEVICE, NULL,
+             0 ),
+
+UNUSUAL_DEV( 0x0686, 0x400b, 0x0001, 0x0001,
+             "Minolta",
+             "DiMAGE 7i",
+             US_SC_SCSI, US_PR_DEVICE, NULL,
+             0 ),
+
+UNUSUAL_DEV( 0x0686, 0x400f, 0x0001, 0x0001,
+             "Minolta",
+             "DiMAGE 7Hi",
+             US_SC_SCSI, US_PR_DEVICE, NULL,
+             0 ),
+
 UNUSUAL_DEV(  0x0693, 0x0002, 0x0100, 0x0100, 
 		"Hagiwara",
 		"FlashGate SmartMedia",
@@ -441,6 +483,11 @@ UNUSUAL_DEV(  0x07ab, 0xfc01, 0x0000, 0x
 		"Freecom",
 		"USB-IDE",
 		US_SC_QIC, US_PR_FREECOM, freecom_init, 0),
+
+UNUSUAL_DEV(  0x07ab, 0xfc84, 0x0000, 0x9999,
+		"Freecom",
+		"FX-5/FX-50",
+		US_SC_QIC, US_PR_FREECOM, freecom_init, 0),
 #endif
 
 UNUSUAL_DEV(  0x07af, 0x0004, 0x0100, 0x0133, 
@@ -528,6 +575,14 @@ UNUSUAL_DEV(  0x07c4, 0xa109, 0x0000, 0x
 		US_SC_SCSI, US_PR_DATAFAB, NULL,
 		US_FL_MODE_XLATE ),
 #endif
+#ifdef CONFIG_USB_STORAGE_SDDR55
+/* SM part - aeb <Andries.Brouwer@cwi.nl> */
+UNUSUAL_DEV(  0x07c4, 0xa109, 0x0000, 0xffff,
+		"Datafab Systems, Inc.",
+		"USB to CF + SM Combo (LC1)",
+		US_SC_SCSI, US_PR_SDDR55, NULL,
+		US_FL_SINGLE_LUN ),
+#endif
 
 /* Datafab KECF-USB / Sagatek DCS-CF / Simpletech Flashlink UCF-100
  * Only revision 1.13 tested (same for all of the above devices,
@@ -570,6 +625,14 @@ UNUSUAL_DEV(  0x08ca, 0x2011, 0x0000, 0x
 		US_SC_DEVICE, US_PR_DEVICE, NULL,
 		US_FL_MODE_XLATE ),
 
+/*Medion 6047 Digital Camera
+Davide Andrian <_nessuno_@katamail.com>
+*/
+UNUSUAL_DEV( 0x08ca, 0x2011, 0x0001, 0x0001,
+		"3MegaCam",
+		"3MegaCam",
+		US_SC_DEVICE, US_PR_BULK, NULL,
+		US_FL_MODE_XLATE ),
 /* aeb */
 UNUSUAL_DEV( 0x090c, 0x1132, 0x0000, 0xffff,
 		"Feiya",
@@ -605,8 +668,8 @@ UNUSUAL_DEV( 0x0a17, 0x0004, 0x1000, 0x1
 /* Submitted by Per Winkvist <per.winkvist@uk.com> */
 UNUSUAL_DEV( 0x0a17, 0x006, 0x1000, 0x9009,
                 "Pentax",
-                "Optio S",
-                US_SC_8070, US_PR_CBI, NULL,
+                "Optio S/S4",
+                US_SC_DEVICE, US_PR_DEVICE, NULL,
                 US_FL_FIX_INQUIRY ),
 		
 #ifdef CONFIG_USB_STORAGE_ISD200
@@ -617,13 +680,6 @@ UNUSUAL_DEV(  0x0bf6, 0xa001, 0x0100, 0x
 		0 ),
 #endif
 
-/* Submitted by Antoine Mairesse <antoine.mairesse@free.fr> */
-UNUSUAL_DEV( 0x0ed1, 0x6660, 0x0100, 0x0300,
-		"USB",
-		"Solid state disk",
-		US_SC_DEVICE, US_PR_DEVICE, NULL,
-		US_FL_FIX_INQUIRY ),
-
 /* Submitted by Joris Struyve <joris@struyve.be> */
 UNUSUAL_DEV( 0x0d96, 0x410a, 0x0001, 0xffff,
 		"Medion",
@@ -640,6 +696,13 @@ UNUSUAL_DEV(  0x0d96, 0x5200, 0x0001, 0x
 		"Jenoptik",
 		"JD 5200 z3",
 		US_SC_DEVICE, US_PR_DEVICE, NULL, US_FL_FIX_INQUIRY),
+
+/* Submitted by Antoine Mairesse <antoine.mairesse@free.fr> */
+UNUSUAL_DEV( 0x0ed1, 0x6660, 0x0100, 0x0300,
+		"USB",
+		"Solid state disk",
+		US_SC_DEVICE, US_PR_DEVICE, NULL,
+		US_FL_FIX_INQUIRY ),
 		
 /* Reported by Kevin Cernekee <kpc-usbdev@gelato.uiuc.edu>
  * Tested on hardware version 1.10.
diff -purN linux-2.5/drivers/usb/storage/usb.c usb-2.5/drivers/usb/storage/usb.c
--- linux-2.5/drivers/usb/storage/usb.c	2003-11-02 10:57:01.000000000 +0000
+++ usb-2.5/drivers/usb/storage/usb.c	2003-11-24 14:07:20.000000000 +0000
@@ -234,16 +234,8 @@ struct usb_driver usb_storage_driver = {
  */
 
 void fill_inquiry_response(struct us_data *us, unsigned char *data,
-		unsigned int data_len) {
-
-	int i;
-	struct scatterlist *sg;
-	int len =
-		us->srb->request_bufflen > data_len ? data_len :
-		us->srb->request_bufflen;
-	int transferred;
-	int amt;
-
+		unsigned int data_len)
+{
 	if (data_len<36) // You lose.
 		return;
 
@@ -270,22 +262,7 @@ void fill_inquiry_response(struct us_dat
 		data[35] = 0x30 + ((us->pusb_dev->descriptor.bcdDevice) & 0x0F);
 	}
 
-	if (us->srb->use_sg) {
-		sg = (struct scatterlist *)us->srb->request_buffer;
-		for (i=0; i<us->srb->use_sg; i++)
-			memset(sg_address(sg[i]), 0, sg[i].length);
-		for (i=0, transferred=0; 
-				i<us->srb->use_sg && transferred < len;
-				i++) {
-			amt = sg[i].length > len-transferred ? 
-					len-transferred : sg[i].length;
-			memcpy(sg_address(sg[i]), data+transferred, amt);
-			transferred -= amt;
-		}
-	} else {
-		memset(us->srb->request_buffer, 0, us->srb->request_bufflen);
-		memcpy(us->srb->request_buffer, data, len);
-	}
+	usb_stor_set_xfer_buf(data, data_len, us->srb);
 }
 
 static int usb_stor_control_thread(void * __us)
diff -purN linux-2.5/drivers/video/aty/aty128fb.c usb-2.5/drivers/video/aty/aty128fb.c
--- linux-2.5/drivers/video/aty/aty128fb.c	2003-10-09 03:05:40.000000000 +0000
+++ usb-2.5/drivers/video/aty/aty128fb.c	2003-10-10 20:44:39.000000000 +0000
@@ -1536,6 +1536,7 @@ aty128_init(struct pci_dev *pdev, const 
 	/* fill in info */
 	info->fbops = &aty128fb_ops;
 	info->flags = FBINFO_FLAG_DEFAULT;
+	info->dev = &pdev->dev;
 
 #ifdef CONFIG_PMAC_PBOOK
 	par->lcd_on = default_lcd_on;
diff -purN linux-2.5/drivers/video/cirrusfb.c usb-2.5/drivers/video/cirrusfb.c
--- linux-2.5/drivers/video/cirrusfb.c	2003-06-04 05:56:15.000000000 +0000
+++ usb-2.5/drivers/video/cirrusfb.c	2003-08-20 18:40:45.000000000 +0000
@@ -2787,6 +2787,7 @@ int __init clgenfb_init(void)
 	fb_info->gen.info.switch_con = &fbgen_switch;
 	fb_info->gen.info.updatevar = &fbgen_update_var;
 	fb_info->gen.info.flags = FBINFO_FLAG_DEFAULT;
+	fb_info->gen.info.dev = fb_info->pdev;
 
 	for (j = 0; j < 256; j++) {
 		if (j < 16) {
diff -purN linux-2.5/drivers/video/cyber2000fb.c usb-2.5/drivers/video/cyber2000fb.c
--- linux-2.5/drivers/video/cyber2000fb.c	2003-07-31 15:58:45.000000000 +0000
+++ usb-2.5/drivers/video/cyber2000fb.c	2003-08-20 18:40:45.000000000 +0000
@@ -1366,6 +1366,7 @@ static int __devinit cyberpro_common_pro
 	cfb->fb.fix.smem_len   = smem_size;
 	cfb->fb.fix.mmio_len   = MMIO_SIZE;
 	cfb->fb.screen_base    = cfb->region;
+	cfb->fb.dev            = &cfb->dev->dev;
 
 	err = -EINVAL;
 	if (!fb_find_mode(&cfb->fb.var, &cfb->fb, NULL, NULL, 0,
diff -purN linux-2.5/drivers/video/fbmem.c usb-2.5/drivers/video/fbmem.c
--- linux-2.5/drivers/video/fbmem.c	2003-08-26 16:25:41.000000000 +0000
+++ usb-2.5/drivers/video/fbmem.c	2003-09-02 06:15:44.000000000 +0000
@@ -31,6 +31,7 @@
 #include <linux/kmod.h>
 #endif
 #include <linux/devfs_fs_kernel.h>
+#include <linux/device.h>
 
 #if defined(__mc68000__) || defined(CONFIG_APUS)
 #include <asm/setup.h>
@@ -1199,6 +1200,83 @@ static struct file_operations fb_fops = 
 #endif
 };
 
+struct fb_dev {
+	struct list_head node;
+	dev_t dev;
+	struct class_device class_dev;
+};
+#define to_fb_dev(d) container_of(d, struct fb_dev, class_dev)
+
+static void release_fb_dev(struct class_device *class_dev)
+{
+	struct fb_dev *fb_dev = to_fb_dev(class_dev);
+	kfree(fb_dev);
+}
+
+static struct class fb_class = {
+	.name		= "video",
+	.release	= &release_fb_dev,
+};
+
+static LIST_HEAD(fb_dev_list);
+static spinlock_t fb_dev_list_lock = SPIN_LOCK_UNLOCKED;
+
+static ssize_t show_dev(struct class_device *class_dev, char *buf)
+{
+	struct fb_dev *fb_dev = to_fb_dev(class_dev);
+	return print_dev_t(buf, fb_dev->dev);
+}
+static CLASS_DEVICE_ATTR(dev, S_IRUGO, show_dev, NULL);
+
+static void fb_add_class_device(int minor, struct device *device)
+{
+	struct fb_dev *fb_dev = NULL;
+	int retval;
+
+	fb_dev = kmalloc(sizeof(*fb_dev), GFP_KERNEL);
+	if (!fb_dev)
+		return;
+	memset(fb_dev, 0x00, sizeof(*fb_dev));
+
+	fb_dev->dev = MKDEV(FB_MAJOR, minor);
+	fb_dev->class_dev.dev = device;
+	fb_dev->class_dev.class = &fb_class;
+	snprintf(fb_dev->class_dev.class_id, BUS_ID_SIZE, "fb%d", minor);
+	retval = class_device_register(&fb_dev->class_dev);
+	if (retval)
+		goto error;
+	class_device_create_file(&fb_dev->class_dev, &class_device_attr_dev);
+	spin_lock(&fb_dev_list_lock);
+	list_add(&fb_dev->node, &fb_dev_list);
+	spin_unlock(&fb_dev_list_lock);
+	return;
+error:
+	kfree(fb_dev);
+}
+
+void fb_remove_class_device(int minor)
+{
+	struct fb_dev *fb_dev = NULL;
+	struct list_head *tmp;
+	int found = 0;
+
+	spin_lock(&fb_dev_list_lock);
+	list_for_each(tmp, &fb_dev_list) {
+		fb_dev = list_entry(tmp, struct fb_dev, node);
+		if ((MINOR(fb_dev->dev) == minor)) {
+			found = 1;
+			break;
+		}
+	}
+	if (found) {
+		list_del(&fb_dev->node);
+		spin_unlock(&fb_dev_list_lock);
+		class_device_unregister(&fb_dev->class_dev);
+	} else {
+		spin_unlock(&fb_dev_list_lock);
+	}
+}
+
 /**
  *	register_framebuffer - registers a frame buffer device
  *	@fb_info: frame buffer info structure
@@ -1242,6 +1320,8 @@ register_framebuffer(struct fb_info *fb_
 
 	devfs_mk_cdev(MKDEV(FB_MAJOR, i),
 			S_IFCHR | S_IRUGO | S_IWUGO, "fb/%d", i);
+
+	fb_add_class_device(i, fb_info->dev);
 	return 0;
 }
 
@@ -1270,6 +1350,7 @@ unregister_framebuffer(struct fb_info *f
 		kfree(fb_info->pixmap.addr);
 	registered_fb[i]=NULL;
 	num_registered_fb--;
+	fb_remove_class_device(i);
 	return 0;
 }
 
@@ -1294,6 +1375,8 @@ fbmem_init(void)
 	if (register_chrdev(FB_MAJOR,"fb",&fb_fops))
 		printk("unable to get major %d for fb devs\n", FB_MAJOR);
 
+	class_register(&fb_class);
+
 #ifdef CONFIG_FB_OF
 	if (ofonly) {
 		offb_init();
diff -purN linux-2.5/drivers/video/i810/i810_main.c usb-2.5/drivers/video/i810/i810_main.c
--- linux-2.5/drivers/video/i810/i810_main.c	2003-09-11 22:46:11.000000000 +0000
+++ usb-2.5/drivers/video/i810/i810_main.c	2003-09-15 15:47:56.000000000 +0000
@@ -1880,6 +1880,7 @@ static int __devinit i810fb_init_pci (st
 	info->fbops = &par->i810fb_ops;
 	info->pseudo_palette = par->pseudo_palette;
 	info->flags = FBINFO_FLAG_DEFAULT;
+	info->dev = &dev->dev;
 	
 	fb_alloc_cmap(&info->cmap, 256, 0);
 
diff -purN linux-2.5/drivers/video/igafb.c usb-2.5/drivers/video/igafb.c
--- linux-2.5/drivers/video/igafb.c	2003-11-26 01:52:00.000000000 +0000
+++ usb-2.5/drivers/video/igafb.c	2003-11-26 23:52:56.000000000 +0000
@@ -332,7 +332,7 @@ static struct fb_ops igafb_ops = {
 #endif
 };
 
-static int __init iga_init(struct fb_info *info, struct iga_par *par)
+static int __init iga_init(struct fb_info *info, struct iga_par *par, struct pci_dev *dev)
 {
         char vramsz = iga_inb(par, IGA_EXT_CNTRL, IGA_IDX_EXT_BUS_CNTL) 
 		                                         & MEM_SIZE_ALIAS;
@@ -358,6 +358,7 @@ static int __init iga_init(struct fb_inf
 
 	info->fbops = &igafb_ops;
 	info->flags = FBINFO_FLAG_DEFAULT;
+	info->dev = &dev->dev;
 
 	fb_alloc_cmap(&info->cmap, video_cmap_len, 0);
 
@@ -529,7 +530,7 @@ int __init igafb_init(void)
 	info->fix = igafb_fix;
 	info->pseudo_palette = (void *)(par + 1);
 
-	if (!iga_init(info, par)) {
+	if (!iga_init(info, par, pdev)) {
 		iounmap((void *)par->io_base);
 		iounmap(info->screen_base);
 		if (par->mmap_map)
diff -purN linux-2.5/drivers/video/imsttfb.c usb-2.5/drivers/video/imsttfb.c
--- linux-2.5/drivers/video/imsttfb.c	2003-10-11 14:01:29.000000000 +0000
+++ usb-2.5/drivers/video/imsttfb.c	2003-10-17 16:35:53.000000000 +0000
@@ -1348,7 +1348,7 @@ static struct fb_ops imsttfb_ops = {
 };
 
 static void __init 
-init_imstt(struct fb_info *info)
+init_imstt(struct fb_info *info, struct pci_dev *pdev)
 {
 	struct imstt_par *par = (struct imstt_par *) info->par;
 	__u32 i, tmp, *ip, *end;
@@ -1442,6 +1442,7 @@ init_imstt(struct fb_info *info)
 
 	info->fbops = &imsttfb_ops;
 	info->flags = FBINFO_FLAG_DEFAULT;
+	info->dev = &pdev->dev;
 
 	fb_alloc_cmap(&info->cmap, 0, 0);
 
@@ -1520,7 +1521,7 @@ imsttfb_probe(struct pci_dev *pdev, cons
 	par->cmap_regs = (__u8 *)ioremap(addr + 0x840000, 0x1000);
 	info->par = par;
 	info->pseudo_palette = (void *) (par + 1);
-	init_imstt(info);
+	init_imstt(info, pdev);
 
 	pci_set_drvdata(pdev, info);
 	return 0;
diff -purN linux-2.5/drivers/video/matrox/matroxfb_crtc2.c usb-2.5/drivers/video/matrox/matroxfb_crtc2.c
--- linux-2.5/drivers/video/matrox/matroxfb_crtc2.c	2003-08-06 17:06:59.000000000 +0000
+++ usb-2.5/drivers/video/matrox/matroxfb_crtc2.c	2003-08-20 18:40:45.000000000 +0000
@@ -605,6 +605,7 @@ static int matroxfb_dh_regit(CPMINFO str
 	m2info->fbcon.flags = FBINFO_FLAG_DEFAULT;
 	m2info->fbcon.currcon = -1;
 	m2info->fbcon.pseudo_palette = m2info->cmap;
+	m2info->fbcon.dev = &m2info->primary_dev->pcidev->dev;
 	fb_alloc_cmap(&m2info->fbcon.cmap, 256, 1);
 
 	if (mem < 64)
diff -purN linux-2.5/drivers/video/neofb.c usb-2.5/drivers/video/neofb.c
--- linux-2.5/drivers/video/neofb.c	2003-07-31 15:58:45.000000000 +0000
+++ usb-2.5/drivers/video/neofb.c	2003-08-20 18:40:45.000000000 +0000
@@ -1943,6 +1943,7 @@ static struct fb_info *__devinit neo_all
 	info->flags = FBINFO_FLAG_DEFAULT;
 	info->par = par;
 	info->pseudo_palette = (void *) (par + 1);
+	info->dev = &dev->dev;
 
 	fb_alloc_cmap(&info->cmap, NR_PALETTE, 0);
 
diff -purN linux-2.5/drivers/video/radeonfb.c usb-2.5/drivers/video/radeonfb.c
--- linux-2.5/drivers/video/radeonfb.c	2003-11-06 15:46:27.000000000 +0000
+++ usb-2.5/drivers/video/radeonfb.c	2003-11-07 19:16:48.000000000 +0000
@@ -3033,6 +3033,7 @@ static int radeonfb_pci_register (struct
 	pci_set_drvdata(pdev, rinfo);
 	rinfo->next = board_list;
 	board_list = rinfo;
+	rinfo->info.dev = &pdev->dev;
 
 	if (register_framebuffer ((struct fb_info *) rinfo) < 0) {
 		printk ("radeonfb: could not register framebuffer\n");
diff -purN linux-2.5/drivers/video/riva/fbdev.c usb-2.5/drivers/video/riva/fbdev.c
--- linux-2.5/drivers/video/riva/fbdev.c	2003-09-11 22:46:11.000000000 +0000
+++ usb-2.5/drivers/video/riva/fbdev.c	2003-09-15 15:47:56.000000000 +0000
@@ -1751,6 +1751,7 @@ static int __devinit rivafb_probe(struct
 	if (info->pixmap.addr == NULL)
 		goto err_out_kfree1;
 	memset(info->pixmap.addr, 0, 64 * 1024);
+	info->dev = &pd->dev;
 
 	strcat(rivafb_fix.id, rci->name);
 	default_par->riva.Architecture = rci->arch_rev;
diff -purN linux-2.5/drivers/video/sis/sis_main.c usb-2.5/drivers/video/sis/sis_main.c
--- linux-2.5/drivers/video/sis/sis_main.c	2003-06-04 12:28:33.000000000 +0000
+++ usb-2.5/drivers/video/sis/sis_main.c	2003-08-20 18:40:45.000000000 +0000
@@ -4507,6 +4507,7 @@ int __init sisfb_init(void)
 		sis_fb_info.par = &ivideo;
 		sis_fb_info.screen_base = ivideo.video_vbase;
 		sis_fb_info.fbops = &sisfb_ops;
+		sis_fb_info.dev = &pdev->dev;
 		sisfb_get_fix(&sis_fb_info.fix, -1, &sis_fb_info);
 		sis_fb_info.pseudo_palette = pseudo_palette;
 		
diff -purN linux-2.5/drivers/video/sstfb.c usb-2.5/drivers/video/sstfb.c
--- linux-2.5/drivers/video/sstfb.c	2003-09-30 00:23:11.000000000 +0000
+++ usb-2.5/drivers/video/sstfb.c	2003-10-06 17:46:13.000000000 +0000
@@ -1477,6 +1477,7 @@ static int __devinit sstfb_probe(struct 
 	info->fbops	= &sstfb_ops;
 	info->currcon	= -1;
 	info->pseudo_palette = &all->pseudo_palette;
+	info->dev	= &pdev->dev;
 
 	fix->type	= FB_TYPE_PACKED_PIXELS;
 	fix->visual	= FB_VISUAL_TRUECOLOR;
diff -purN linux-2.5/drivers/video/tdfxfb.c usb-2.5/drivers/video/tdfxfb.c
--- linux-2.5/drivers/video/tdfxfb.c	2003-08-01 16:58:23.000000000 +0000
+++ usb-2.5/drivers/video/tdfxfb.c	2003-08-20 18:40:46.000000000 +0000
@@ -1248,6 +1248,7 @@ static int __devinit tdfxfb_probe(struct
 	info->par		= default_par;
 	info->pseudo_palette	= (void *)(default_par + 1); 
 	info->flags		= FBINFO_FLAG_DEFAULT;
+	info->dev		= &pdev->dev;
 
 #ifndef MODULE
 	if (!mode_option)
@@ -1357,3 +1358,5 @@ void tdfxfb_setup(char *options, int *in
 }
 #endif
 
+
+
diff -purN linux-2.5/drivers/video/tgafb.c usb-2.5/drivers/video/tgafb.c
--- linux-2.5/drivers/video/tgafb.c	2003-05-26 00:00:00.000000000 +0000
+++ usb-2.5/drivers/video/tgafb.c	2003-08-20 18:40:46.000000000 +0000
@@ -1430,6 +1430,7 @@ tgafb_pci_register(struct pci_dev *pdev,
 	all->info.currcon = -1;
 	all->info.par = &all->par;
 	all->info.pseudo_palette = all->pseudo_palette;
+	all->info.dev = &pdev->dev;
 
 	/* This should give a reasonable default video mode.  */
 
diff -purN linux-2.5/drivers/video/tridentfb.c usb-2.5/drivers/video/tridentfb.c
--- linux-2.5/drivers/video/tridentfb.c	2003-12-02 16:14:36.000000000 +0000
+++ usb-2.5/drivers/video/tridentfb.c	2003-10-10 20:44:39.000000000 +0000
@@ -1156,6 +1156,7 @@ static int __devinit trident_pci_probe(s
 		default_var.accel_flags &= ~FB_ACCELF_TEXT;
 	default_var.activate |= FB_ACTIVATE_NOW;
 	fb_info.var = default_var;
+	fb_info.dev = &dev->dev;
 	if (register_framebuffer(&fb_info) < 0) {
 		output("Could not register Trident framebuffer\n");
 		return -EINVAL;
diff -purN linux-2.5/fs/sysfs/dir.c usb-2.5/fs/sysfs/dir.c
--- linux-2.5/fs/sysfs/dir.c	2003-09-12 14:01:07.000000000 +0000
+++ usb-2.5/fs/sysfs/dir.c	2003-12-06 01:36:20.000000000 +0000
@@ -83,7 +83,8 @@ static void remove_dir(struct dentry * d
 	struct dentry * parent = dget(d->d_parent);
 	down(&parent->d_inode->i_sem);
 	d_delete(d);
-	simple_rmdir(parent->d_inode,d);
+	if (d->d_inode)
+		simple_rmdir(parent->d_inode,d);
 
 	pr_debug(" o %s removing done (%d)\n",d->d_name.name,
 		 atomic_read(&d->d_count));
diff -purN linux-2.5/include/linux/device.h usb-2.5/include/linux/device.h
--- linux-2.5/include/linux/device.h	2003-09-29 21:20:44.000000000 +0000
+++ usb-2.5/include/linux/device.h	2003-10-10 20:44:39.000000000 +0000
@@ -383,8 +383,20 @@ extern int firmware_register(struct subs
 extern void firmware_unregister(struct subsystem *);
 
 /* debugging and troubleshooting/diagnostic helpers. */
+#ifdef CONFIG_DEBUG_DEV_PRINTK
+#define dev_printk(level, dev, format, arg...)			\
+	do {							\
+		if (!(dev) || !(dev)->driver)			\
+			WARN_ON(1);				\
+		else						\
+			printk(level "%s %s: " format , 	\
+				(dev)->driver->name , 		\
+				(dev)->bus_id , ## arg);	\
+	} while (0)
+#else
 #define dev_printk(level, dev, format, arg...)	\
 	printk(level "%s %s: " format , (dev)->driver->name , (dev)->bus_id , ## arg)
+#endif
 
 #ifdef DEBUG
 #define dev_dbg(dev, format, arg...)		\
diff -purN linux-2.5/include/linux/fb.h usb-2.5/include/linux/fb.h
--- linux-2.5/include/linux/fb.h	2003-04-24 10:30:41.000000000 +0000
+++ usb-2.5/include/linux/fb.h	2003-08-20 18:40:46.000000000 +0000
@@ -352,6 +352,7 @@ struct fb_pixmap {
 struct fb_info;
 struct vm_area_struct;
 struct file;
+struct device;
 
     /*
      *  Frame buffer operations
@@ -412,6 +413,7 @@ struct fb_info {
    struct vc_data *display_fg;		/* Console visible on this display */
    int currcon;				/* Current VC. */	
    void *pseudo_palette;                /* Fake palette of 16 colors */ 
+   struct device *dev;                  /* pointer to the device for this fb */
    /* From here on everything is device dependent */
    void *par;	
 };
diff -purN linux-2.5/include/linux/i2c-id.h usb-2.5/include/linux/i2c-id.h
--- linux-2.5/include/linux/i2c-id.h	2003-08-27 15:23:17.000000000 +0000
+++ usb-2.5/include/linux/i2c-id.h	2003-09-28 22:54:01.000000000 +0000
@@ -153,6 +153,7 @@
 #define I2C_DRIVERID_FS451 1037
 #define I2C_DRIVERID_W83627HF 1038
 #define I2C_DRIVERID_LM85 1039
+#define I2C_DRIVERID_LM83 1040
 
 /*
  * ---- Adapter types ----------------------------------------------------
@@ -258,6 +259,7 @@
 #define I2C_HW_SMBUS_AMD8111	0x0a
 #define I2C_HW_SMBUS_SCX200	0x0b
 #define I2C_HW_SMBUS_NFORCE2	0x0c
+#define I2C_HW_SMBUS_W9968CF	0x0d
 
 /* --- ISA pseudo-adapter						*/
 #define I2C_HW_ISA 0x00
diff -purN linux-2.5/include/linux/miscdevice.h usb-2.5/include/linux/miscdevice.h
--- linux-2.5/include/linux/miscdevice.h	2003-09-21 21:50:34.000000000 +0000
+++ usb-2.5/include/linux/miscdevice.h	2003-09-22 16:41:46.000000000 +0000
@@ -36,12 +36,15 @@
 
 #define TUN_MINOR	     200
 
+struct device;
+
 struct miscdevice 
 {
 	int minor;
 	const char *name;
 	struct file_operations *fops;
 	struct list_head list;
+	struct device *dev;
 	char devfs_name[64];
 };
 
diff -purN linux-2.5/include/linux/pci.h usb-2.5/include/linux/pci.h
--- linux-2.5/include/linux/pci.h	2003-09-26 16:18:37.000000000 +0000
+++ usb-2.5/include/linux/pci.h	2003-10-13 13:13:04.000000000 +0000
@@ -468,10 +468,12 @@ struct pci_bus {
 
 	char		name[48];
 
-	struct	device	* dev;
+	struct device		*bridge;
+	struct class_device	class_dev;
 };
 
-#define pci_bus_b(n) list_entry(n, struct pci_bus, node)
+#define pci_bus_b(n)	list_entry(n, struct pci_bus, node)
+#define to_pci_bus(n)	container_of(n, struct pci_bus, class_dev)
 
 /*
  * Error values that may be returned by PCI functions.
@@ -607,6 +609,8 @@ struct pci_dev *pci_get_device (unsigned
 struct pci_dev *pci_get_subsys (unsigned int vendor, unsigned int device,
 				unsigned int ss_vendor, unsigned int ss_device,
 				struct pci_dev *from);
+struct pci_dev *pci_get_slot (struct pci_bus *bus, unsigned int devfn);
+
 int pci_bus_read_config_byte (struct pci_bus *bus, unsigned int devfn, int where, u8 *val);
 int pci_bus_read_config_word (struct pci_bus *bus, unsigned int devfn, int where, u16 *val);
 int pci_bus_read_config_dword (struct pci_bus *bus, unsigned int devfn, int where, u32 *val);
@@ -768,26 +772,7 @@ static inline int pci_module_init(struct
 {
 	int rc = pci_register_driver (drv);
 
-	if (rc > 0)
-		return 0;
-
-	/* iff CONFIG_HOTPLUG and built into kernel, we should
-	 * leave the driver around for future hotplug events.
-	 * For the module case, a hotplug daemon of some sort
-	 * should load a module in response to an insert event. */
-#if defined(CONFIG_HOTPLUG) && !defined(MODULE)
-	if (rc == 0)
-		return 0;
-#else
-	if (rc == 0)
-		rc = -ENODEV;		
-#endif
-
-	/* if we get here, we need to clean up pci driver instance
-	 * and return some sort of error */
-	pci_unregister_driver (drv);
-	
-	return rc;
+	return rc < 0 ? rc : 0;
 }
 
 /*
diff -purN linux-2.5/include/linux/usb.h usb-2.5/include/linux/usb.h
--- linux-2.5/include/linux/usb.h	2003-09-30 18:35:19.000000000 +0000
+++ usb-2.5/include/linux/usb.h	2003-12-08 17:39:26.000000000 +0000
@@ -414,9 +414,6 @@ static inline int usb_make_path (struct 
  *	Export this with MODULE_DEVICE_TABLE(usb,...).  This must be set
  *	or your driver's probe function will never get called.
  * @driver: the driver model core driver structure.
- * @serialize: a semaphore used to serialize access to this driver.  Used
- * 	in the probe and disconnect functions.  Only the USB core should use
- * 	this lock.
  *
  * USB drivers must provide a name, probe() and disconnect() methods,
  * and an id_table.  Other driver fields are optional.
@@ -451,8 +448,6 @@ struct usb_driver {
 	const struct usb_device_id *id_table;
 
 	struct device_driver driver;
-
-	struct semaphore serialize;
 };
 #define	to_usb_driver(d) container_of(d, struct usb_driver, driver)
 
diff -purN linux-2.5/include/linux/usb_ch9.h usb-2.5/include/linux/usb_ch9.h
--- linux-2.5/include/linux/usb_ch9.h	2003-03-05 15:28:25.000000000 +0000
+++ usb-2.5/include/linux/usb_ch9.h	2003-10-06 08:49:06.000000000 +0000
@@ -116,6 +116,17 @@ struct usb_ctrlrequest {
 #define USB_DT_DEVICE_QUALIFIER		0x06
 #define USB_DT_OTHER_SPEED_CONFIG	0x07
 #define USB_DT_INTERFACE_POWER		0x08
+/* these are from a minor usb 2.0 revision (ECN) */
+#define USB_DT_OTG			0x09
+#define USB_DT_DEBUG			0x0a
+#define USB_DT_INTERFACE_ASSOCIATION	0x0b
+
+/* conventional codes for class-specific descriptors */
+#define USB_DT_CS_DEVICE		0x21
+#define USB_DT_CS_CONFIG		0x22
+#define USB_DT_CS_STRING		0x23
+#define USB_DT_CS_INTERFACE		0x24
+#define USB_DT_CS_ENDPOINT		0x25
 
 /* All standard descriptors have these 2 fields at the beginning */
 struct usb_descriptor_header {
@@ -165,6 +176,7 @@ struct usb_device_descriptor {
 #define USB_CLASS_CDC_DATA		0x0a
 #define USB_CLASS_CSCID			0x0b	/* chip+ smart card */
 #define USB_CLASS_CONTENT_SEC		0x0d	/* content security */
+#define USB_CLASS_VIDEO			0x0e
 #define USB_CLASS_APP_SPEC		0xfe
 #define USB_CLASS_VENDOR_SPEC		0xff
 
@@ -283,6 +295,36 @@ struct usb_qualifier_descriptor {
 
 /*-------------------------------------------------------------------------*/
 
+/* USB_DT_OTG (from OTG 1.0a supplement) */
+struct usb_otg_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+
+	__u8  bmAttributes;	/* support for HNP, SRP, etc */
+} __attribute__ ((packed));
+
+/* from usb_otg_descriptor.bmAttributes */
+#define USB_OTG_SRP		(1 << 0)
+#define USB_OTG_HNP		(1 << 1)	/* swap host/device roles */
+
+/*-------------------------------------------------------------------------*/
+
+/* USB_DT_INTERFACE_ASSOCIATION: groups interfaces */
+struct usb_interface_assoc_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+
+	__u8  bFirstInterface;
+	__u8  bInterfaceCount;
+	__u8  bFunctionClass;
+	__u8  bFunctionSubClass;
+	__u8  bFunctionProtocol;
+	__u8  iFunction;
+} __attribute__ ((packed));
+
+
+/*-------------------------------------------------------------------------*/
+
 /* USB 2.0 defines three speeds, here's how Linux identifies them */
 
 enum usb_device_speed {
diff -purN linux-2.5/include/linux/videodev.h usb-2.5/include/linux/videodev.h
--- linux-2.5/include/linux/videodev.h	2003-08-22 15:51:55.000000000 +0000
+++ usb-2.5/include/linux/videodev.h	2003-10-04 10:22:19.000000000 +0000
@@ -429,6 +429,7 @@ struct video_code
 #define VID_HARDWARE_CPIA2	33
 #define VID_HARDWARE_VICAM      34
 #define VID_HARDWARE_SF16FMR2	35
+#define VID_HARDWARE_W9968CF	36	/* W996[87]CF JPEG USB Dual Mode Cam */
 #endif /* __LINUX_VIDEODEV_H */
 
 /*
diff -purN linux-2.5/lib/kobject.c usb-2.5/lib/kobject.c
--- linux-2.5/lib/kobject.c	2003-12-11 17:49:17.000000000 +0000
+++ usb-2.5/lib/kobject.c	2003-12-16 18:01:24.000000000 +0000
@@ -10,7 +10,7 @@
  * about using the kobject interface.
  */
 
-#undef DEBUG
+#define DEBUG
 
 #include <linux/kobject.h>
 #include <linux/string.h>
@@ -185,8 +185,8 @@ static void kset_hotplug(const char *act
 		}
 	}
 
-	pr_debug ("%s: %s %s %s %s %s %s\n", __FUNCTION__, argv[0], argv[1],
-		  envp[0], envp[1], envp[2], envp[3]);
+	pr_debug ("%s: %s %s %s %s %s %s %s\n", __FUNCTION__, argv[0], argv[1],
+		  envp[0], envp[1], envp[2], envp[3], envp[4]);
 	retval = call_usermodehelper (argv[0], argv, envp, 0);
 	if (retval)
 		pr_debug ("%s - call_usermodehelper returned %d\n",
@@ -213,6 +213,7 @@ static void kset_hotplug(const char *act
 
 void kobject_init(struct kobject * kobj)
 {
+	WARN_ON(atomic_read(&kobj->refcount));
 	atomic_set(&kobj->refcount,1);
 	INIT_LIST_HEAD(&kobj->entry);
 	kobj->kset = kset_get(kobj->kset);
@@ -440,6 +441,7 @@ struct kobject * kobject_get(struct kobj
 		atomic_inc(&kobj->refcount);
 	} else
 		ret = NULL;
+	WARN_ON((kobj != NULL) && (ret==NULL));
 	return ret;
 }
 
@@ -460,6 +462,13 @@ void kobject_cleanup(struct kobject * ko
 	kobj->k_name = NULL;
 	if (t && t->release)
 		t->release(kobj);
+	else {
+		printk(KERN_ERR "kobject '%s' does not have a release() function, "
+			"it is broken and must be fixed.\n",
+			kobj->name);
+		WARN_ON(1);
+	}
+
 	if (s)
 		kset_put(s);
 	if (parent) 
diff -purN linux-2.5/net/ipv4/esp4.c usb-2.5/net/ipv4/esp4.c
--- linux-2.5/net/ipv4/esp4.c	2003-08-18 11:14:38.000000000 +0000
+++ usb-2.5/net/ipv4/esp4.c	2003-12-17 19:44:53.000000000 +0000
@@ -10,6 +10,7 @@
 #include <linux/random.h>
 #include <net/icmp.h>
 #include <net/udp.h>
+#include <asm/checksum.h>
 
 #define MAX_SG_ONSTACK 4
 
@@ -325,7 +326,15 @@ int esp_input(struct xfrm_state *x, stru
 		skb->h.raw = skb_pull(skb, sizeof(struct ip_esp_hdr) + esp->conf.ivlen);
 		skb->nh.raw += encap_len + sizeof(struct ip_esp_hdr) + esp->conf.ivlen;
 		memcpy(skb->nh.raw, workbuf, iph->ihl*4);
-		skb->nh.iph->tot_len = htons(skb->len);
+		iph = skb->nh.iph;
+		iph->tot_len = htons(skb->len + (skb->data - skb->nh.raw));
+		iph->check = 0;
+		iph->check = ip_fast_csum(skb->nh.raw, iph->ihl);
+		{
+			unsigned char *oldmac = skb->mac.raw;
+			skb->mac.raw += encap_len + sizeof(struct ip_esp_hdr) + esp -> conf.ivlen;
+			memmove(skb->mac.raw, oldmac, skb->nh.raw - skb->mac.raw);
+		}
 	}
 
 	return 0;
diff -purN linux-2.5/net/ipv4/xfrm4_input.c usb-2.5/net/ipv4/xfrm4_input.c
--- linux-2.5/net/ipv4/xfrm4_input.c	2003-08-08 04:17:15.000000000 +0000
+++ usb-2.5/net/ipv4/xfrm4_input.c	2003-12-17 19:44:53.000000000 +0000
@@ -93,6 +93,19 @@ int xfrm4_rcv_encap(struct sk_buff *skb,
 		iph = skb->nh.iph;
 
 		if (x->props.mode) {
+			if (iph->protocol == 0xfe) {
+				skb_push(skb, skb->data - skb->nh.raw);
+				if (!(skb->dev->flags&IFF_LOOPBACK)){
+					dst_release(skb->dst);
+					skb->dst = NULL;
+				}
+				if (skb->sp) {
+					secpath_put(skb->sp);
+					skb->sp = NULL;
+				}
+			netif_rx(skb);
+			return 0;
+			}
 			if (iph->protocol != IPPROTO_IPIP)
 				goto drop;
 			skb->nh.raw = skb->data;
diff -purN linux-2.5/scripts/lxdialog/textbox.c usb-2.5/scripts/lxdialog/textbox.c
--- linux-2.5/scripts/lxdialog/textbox.c	2003-07-31 23:52:11.000000000 +0000
+++ usb-2.5/scripts/lxdialog/textbox.c	2001-11-25 04:10:24.000000000 +0000
@@ -27,8 +27,8 @@ static void print_line (WINDOW * win, in
 static char *get_line (void);
 static void print_position (WINDOW * win, int height, int width);
 
-static int hscroll, fd, file_size, bytes_read;
-static int begin_reached = 1, end_reached, page_length;
+static int hscroll = 0, fd, file_size, bytes_read;
+static int begin_reached = 1, end_reached = 0, page_length;
 static char *buf, *page;
 
 /*

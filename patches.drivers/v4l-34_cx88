34_cx88
diff -u linux-2.6.1/drivers/media/Kconfig linux/drivers/media/Kconfig
--- linux-2.6.1/drivers/media/Kconfig	2004-01-14 14:51:47.856692471 +0100
+++ linux/drivers/media/Kconfig	2004-01-14 14:53:21.653902040 +0100
@@ -34,19 +34,20 @@
 
 config VIDEO_TUNER
 	tristate
-	default y if VIDEO_BT848=y || VIDEO_SAA7134=y || VIDEO_MXB=y
-	default m if VIDEO_BT848=m || VIDEO_SAA7134=m || VIDEO_MXB=m
+	default y if VIDEO_BT848=y || VIDEO_SAA7134=y || VIDEO_MXB=y || VIDEO_CX88=y
+	default m if VIDEO_BT848=m || VIDEO_SAA7134=m || VIDEO_MXB=m || VIDEO_CX88=m
 	depends on VIDEO_DEV
 
 config VIDEO_BUF
 	tristate
-	default y if VIDEO_BT848=y || VIDEO_SAA7134=y || VIDEO_SAA7146=y
-	default m if VIDEO_BT848=m || VIDEO_SAA7134=m || VIDEO_SAA7146=m
+	default y if VIDEO_BT848=y || VIDEO_SAA7134=y || VIDEO_SAA7146=y || VIDEO_CX88=y
+	default m if VIDEO_BT848=m || VIDEO_SAA7134=m || VIDEO_SAA7146=m || VIDEO_CX88=m
 	depends on VIDEO_DEV
 
 config VIDEO_BTCX
 	tristate
-	default VIDEO_BT848
+	default y if VIDEO_BT848=y || VIDEO_CX88=y
+	default m if VIDEO_BT848=m || VIDEO_CX88=m
 	depends on VIDEO_DEV
 
 config VIDEO_IR
diff -u linux-2.6.1/drivers/media/video/Kconfig linux/drivers/media/video/Kconfig
--- linux-2.6.1/drivers/media/video/Kconfig	2004-01-14 14:43:28.004217077 +0100
+++ linux/drivers/media/video/Kconfig	2004-01-14 14:47:56.452608083 +0100
@@ -274,5 +274,15 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called hexium_gemini.
 
+config VIDEO_CX88
+	tristate "Conexant 2388x (bt878 successor) support"
+	depends on VIDEO_DEV && PCI && I2C_ALGOBIT && EXPERIMENTAL
+	---help---
+	  This is a video4linux driver for Conexant 2388x based
+	  TV cards.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called cx8800
+
 endmenu
 
diff -u linux-2.6.1/drivers/media/video/Makefile linux/drivers/media/video/Makefile
--- linux-2.6.1/drivers/media/video/Makefile	2004-01-14 14:48:17.365095063 +0100
+++ linux/drivers/media/video/Makefile	2004-01-14 14:48:55.300726039 +0100
@@ -35,6 +35,7 @@
 obj-$(CONFIG_VIDEO_CPIA_USB) += cpia_usb.o
 obj-$(CONFIG_VIDEO_MEYE) += meye.o
 obj-$(CONFIG_VIDEO_SAA7134) += saa7134/
+obj-$(CONFIG_VIDEO_CX88) += cx88/
 obj-$(CONFIG_VIDEO_MXB) += saa7111.o tuner.o tda9840.o tea6415c.o tea6420.o mxb.o
 obj-$(CONFIG_VIDEO_HEXIUM_ORION) += hexium_orion.o
 obj-$(CONFIG_VIDEO_HEXIUM_GEMINI) += hexium_gemini.o
diff -u linux-2.6.1/drivers/media/video/cx88/Makefile linux/drivers/media/video/cx88/Makefile
--- linux-2.6.1/drivers/media/video/cx88/Makefile	2004-01-14 14:49:31.733598172 +0100
+++ linux/drivers/media/video/cx88/Makefile	2004-01-14 14:55:14.258925839 +0100
@@ -0,0 +1,6 @@
+cx88xx-objs	:= cx88-cards.o cx88-core.o
+cx8800-objs	:= cx88-video.o cx88-tvaudio.o cx88-i2c.o
+
+obj-$(CONFIG_VIDEO_CX88) += cx88xx.o cx8800.o
+
+EXTRA_CFLAGS = -I$(src)/..
diff -u linux-2.6.1/drivers/media/video/cx88/cx88-cards.c linux/drivers/media/video/cx88/cx88-cards.c
--- linux-2.6.1/drivers/media/video/cx88/cx88-cards.c	2004-01-14 14:36:15.455001816 +0100
+++ linux/drivers/media/video/cx88/cx88-cards.c	2004-01-14 14:58:22.723192335 +0100
@@ -0,0 +1,396 @@
+/*
+ * device driver for Conexant 2388x based TV cards
+ * card-specific stuff.
+ *
+ * (c) 2003 Gerd Knorr <kraxel@bytesex.org> [SuSE Labs]
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+
+#include "cx88.h"
+
+/* ------------------------------------------------------------------ */
+/* board config info                                                  */
+
+struct cx88_board cx88_boards[] = {
+	[CX88_BOARD_UNKNOWN] = {
+		.name		= "UNKNOWN/GENERIC",
+		.tuner_type     = UNSET,
+		.input          = {{
+			.type   = CX88_VMUX_COMPOSITE1,
+			.vmux   = 0,
+		},{
+			.type   = CX88_VMUX_COMPOSITE2,
+			.vmux   = 1,
+		},{
+			.type   = CX88_VMUX_COMPOSITE3,
+			.vmux   = 2,
+		},{
+			.type   = CX88_VMUX_COMPOSITE4,
+			.vmux   = 3,
+		}},
+	},
+	[CX88_BOARD_HAUPPAUGE] = {
+		.name		= "Hauppauge WinTV 34xxx models",
+		.tuner_type     = UNSET,
+		.input          = {{
+			.type   = CX88_VMUX_TELEVISION,
+			.vmux   = 0,
+			//.gpio0  = 0xff03,
+			.gpio0  = 0xff01,
+		},{
+			.type   = CX88_VMUX_DEBUG,
+			.vmux   = 0,
+			.gpio0  = 0xff00,
+		},{
+			.type   = CX88_VMUX_COMPOSITE1,
+			.vmux   = 1,
+			.gpio0  = 0xff02,
+		}},
+		.radio = {
+			.type   = CX88_RADIO,
+			.gpio0  = 0xff01,
+		},
+	},
+	[CX88_BOARD_GDI] = {
+		.name		= "GDI Black Gold",
+		.tuner_type     = UNSET,
+		.input          = {{
+			.type   = CX88_VMUX_TELEVISION,
+			.vmux   = 0,
+		}},
+	},
+	[CX88_BOARD_PIXELVIEW] = {
+		.name           = "PixelView",
+		.tuner_type     = UNSET,
+		.input          = {{
+			.type   = CX88_VMUX_TELEVISION,
+			.vmux   = 0,
+		},{
+			.type   = CX88_VMUX_COMPOSITE1,
+			.vmux   = 1,
+		},{
+			.type   = CX88_VMUX_SVIDEO,
+			.vmux   = 2,
+		}},
+	},
+	[CX88_BOARD_ATI_WONDER_PRO] = {
+		.name           = "ATI TV Wonder Pro",
+		.tuner_type     = UNSET,
+		.input          = {{
+			.type   = CX88_VMUX_TELEVISION,
+			.vmux   = 0,
+		}},
+	},
+        [CX88_BOARD_WINFAST2000XP] = {
+                .name           = "Leadtek Winfast 2000XP Expert",
+                .tuner_type     = 38,
+                .input          = {{
+                        .type   = CX88_VMUX_TELEVISION,
+                        .vmux   = 0,
+                }},
+                .radio = {
+                        .type   = CX88_RADIO,
+                },
+        },
+	[CX88_BOARD_AVERTV_303] = {
+		.name           = "AverTV Studio 303 (M126)",
+		.tuner_type     = TUNER_PHILIPS_PAL_DK,
+		.input          = {{
+			.type   = CX88_VMUX_TELEVISION,
+			.vmux   = 0,
+		}},
+	},
+	[CX88_BOARD_MSI_TVANYWHERE] = {
+		.name           = "MSI TV-@nywhere Master",
+		.tuner_type     = 33,
+		.input          = {{
+			.type   = CX88_VMUX_TELEVISION,
+			.vmux   = 0,
+		},{
+                        .type   = CX88_VMUX_COMPOSITE1,
+                        .vmux   = 1,
+		},{
+                        .type   = CX88_VMUX_SVIDEO,
+                        .vmux   = 2,
+                }},
+                .radio = {
+                        .type   = CX88_RADIO,
+                },
+	},
+	[CX88_BOARD_WINFAST_DV2000] = {
+                .name           = "Leadtek Winfast DV2000",
+                .tuner_type     = 38,
+                .input          = {{
+                        .type   = CX88_VMUX_TELEVISION,
+                        .vmux   = 0,
+                }},
+                .radio = {
+                        .type   = CX88_RADIO,
+                },
+        },
+
+};
+const unsigned int cx88_bcount = ARRAY_SIZE(cx88_boards);
+
+/* ------------------------------------------------------------------ */
+/* PCI subsystem IDs                                                  */
+
+struct cx88_subid cx88_subids[] = {
+	{
+		.subvendor = 0x0070,
+		.subdevice = 0x3400,
+		.card      = CX88_BOARD_HAUPPAUGE,
+	},{
+		.subvendor = 0x0070,
+		.subdevice = 0x3401,
+		.card      = CX88_BOARD_HAUPPAUGE,
+	},{
+		.subvendor = 0x14c7,
+		.subdevice = 0x0106,
+		.card      = CX88_BOARD_GDI,
+	},{
+		.subvendor = 0x14c7,
+		.subdevice = 0x0107, /* with mpeg encoder */
+		.card      = CX88_BOARD_GDI,
+	},{
+		.subvendor = PCI_VENDOR_ID_ATI,
+		.subdevice = 0x00f8,
+		.card      = CX88_BOARD_ATI_WONDER_PRO,
+	},{
+                .subvendor = 0x107d,
+                .subdevice = 0x6611,
+                .card      = CX88_BOARD_WINFAST2000XP,
+	},{
+		.subvendor = 0x107d,
+                .subdevice = 0x6620,
+                .card      = CX88_BOARD_WINFAST_DV2000,
+        },{
+		.subvendor = 0x1461,
+		.subdevice = 0x000b,
+		.card      = CX88_BOARD_AVERTV_303,
+	},{
+		.subvendor = 0x1462,
+		.subdevice = 0x8606,
+		.card      = CX88_BOARD_MSI_TVANYWHERE,
+	}
+};
+const unsigned int cx88_idcount = ARRAY_SIZE(cx88_subids);
+
+/* ----------------------------------------------------------------------- */
+/* some hauppauge specific stuff                                           */
+
+static struct {
+        int  id;
+        char *name;
+} hauppauge_tuner[] __devinitdata = {
+        { TUNER_ABSENT,        "" },
+        { TUNER_ABSENT,        "External" },
+        { TUNER_ABSENT,        "Unspecified" },
+        { TUNER_PHILIPS_PAL,   "Philips FI1216" },
+        { TUNER_PHILIPS_SECAM, "Philips FI1216MF" },
+        { TUNER_PHILIPS_NTSC,  "Philips FI1236" },
+        { TUNER_PHILIPS_PAL_I, "Philips FI1246" },
+        { TUNER_PHILIPS_PAL_DK,"Philips FI1256" },
+        { TUNER_PHILIPS_PAL,   "Philips FI1216 MK2" },
+        { TUNER_PHILIPS_SECAM, "Philips FI1216MF MK2" },
+        { TUNER_PHILIPS_NTSC,  "Philips FI1236 MK2" },
+        { TUNER_PHILIPS_PAL_I, "Philips FI1246 MK2" },
+        { TUNER_PHILIPS_PAL_DK,"Philips FI1256 MK2" },
+        { TUNER_TEMIC_NTSC,    "Temic 4032FY5" },
+        { TUNER_TEMIC_PAL,     "Temic 4002FH5" },
+        { TUNER_TEMIC_PAL_I,   "Temic 4062FY5" },
+        { TUNER_PHILIPS_PAL,   "Philips FR1216 MK2" },
+        { TUNER_PHILIPS_SECAM, "Philips FR1216MF MK2" },
+        { TUNER_PHILIPS_NTSC,  "Philips FR1236 MK2" },
+        { TUNER_PHILIPS_PAL_I, "Philips FR1246 MK2" },
+        { TUNER_PHILIPS_PAL_DK,"Philips FR1256 MK2" },
+        { TUNER_PHILIPS_PAL,   "Philips FM1216" },
+        { TUNER_PHILIPS_SECAM, "Philips FM1216MF" },
+        { TUNER_PHILIPS_NTSC,  "Philips FM1236" },
+        { TUNER_PHILIPS_PAL_I, "Philips FM1246" },
+        { TUNER_PHILIPS_PAL_DK,"Philips FM1256" },
+        { TUNER_TEMIC_4036FY5_NTSC, "Temic 4036FY5" },
+        { TUNER_ABSENT,        "Samsung TCPN9082D" },
+        { TUNER_ABSENT,        "Samsung TCPM9092P" },
+        { TUNER_TEMIC_4006FH5_PAL, "Temic 4006FH5" },
+        { TUNER_ABSENT,        "Samsung TCPN9085D" },
+        { TUNER_ABSENT,        "Samsung TCPB9085P" },
+        { TUNER_ABSENT,        "Samsung TCPL9091P" },
+        { TUNER_TEMIC_4039FR5_NTSC, "Temic 4039FR5" },
+        { TUNER_PHILIPS_FQ1216ME,   "Philips FQ1216 ME" },
+        { TUNER_TEMIC_4066FY5_PAL_I, "Temic 4066FY5" },
+        { TUNER_PHILIPS_NTSC,        "Philips TD1536" },
+        { TUNER_PHILIPS_NTSC,        "Philips TD1536D" },
+	{ TUNER_PHILIPS_NTSC,  "Philips FMR1236" }, /* mono radio */
+        { TUNER_ABSENT,        "Philips FI1256MP" },
+        { TUNER_ABSENT,        "Samsung TCPQ9091P" },
+        { TUNER_TEMIC_4006FN5_MULTI_PAL, "Temic 4006FN5" },
+        { TUNER_TEMIC_4009FR5_PAL, "Temic 4009FR5" },
+        { TUNER_TEMIC_4046FM5,     "Temic 4046FM5" },
+	{ TUNER_TEMIC_4009FN5_MULTI_PAL_FM, "Temic 4009FN5" },
+	{ TUNER_ABSENT,        "Philips TD1536D_FH_44"},
+	{ TUNER_LG_NTSC_FM,    "LG TPI8NSR01F"},
+	{ TUNER_LG_PAL_FM,     "LG TPI8PSB01D"},
+	{ TUNER_LG_PAL,        "LG TPI8PSB11D"},	
+	{ TUNER_LG_PAL_I_FM,   "LG TAPC-I001D"},
+	{ TUNER_LG_PAL_I,      "LG TAPC-I701D"}
+};
+
+static void __devinit hauppauge_eeprom(struct cx8800_dev *dev, u8 *eeprom_data)
+{
+	unsigned int blk2,tuner,radio,model;
+
+	if (eeprom_data[0] != 0x84 || eeprom_data[2] != 0) {
+		printk(KERN_WARNING "%s: Hauppauge eeprom: invalid\n",
+		       dev->name);
+		return;
+	}
+
+	/* Block 2 starts after len+3 bytes header */
+	blk2 = eeprom_data[1] + 3;
+
+	/* decode + use some config infos */
+	model = eeprom_data[12] << 8 | eeprom_data[11];
+	tuner = eeprom_data[9];
+	radio = eeprom_data[blk2-1] & 0x01;
+	
+        if (tuner < ARRAY_SIZE(hauppauge_tuner))
+                dev->tuner_type = hauppauge_tuner[tuner].id;
+	if (radio)
+		dev->has_radio = 1;
+	
+	printk(KERN_INFO "%s: hauppauge eeprom: model=%d, "
+	       "tuner=%s (%d), radio=%s\n",
+	       dev->name, model, hauppauge_tuner[tuner].name,
+	       dev->tuner_type, radio ? "yes" : "no");
+}
+
+/* ----------------------------------------------------------------------- */
+/* some GDI (was: Modular Technology) specific stuff                       */
+
+static struct {
+	int  id;
+	int  fm;
+	char *name;
+} gdi_tuner[] = {
+	[ 0x01 ] = { .id   = TUNER_ABSENT,
+		     .name = "NTSC_M" },
+	[ 0x02 ] = { .id   = TUNER_ABSENT,
+		     .name = "PAL_B" },
+	[ 0x03 ] = { .id   = TUNER_ABSENT,
+		     .name = "BAL_I" },
+	[ 0x04 ] = { .id   = TUNER_ABSENT,
+		     .name = "PAL_D" },
+	[ 0x05 ] = { .id   = TUNER_ABSENT,
+		     .name = "SECAM" },
+
+	[ 0x10 ] = { .id   = TUNER_ABSENT, .fm = 1, 
+		     .name = "TEMIC_4049" },
+	[ 0x11 ] = { .id   = TUNER_TEMIC_4136FY5,
+		     .name = "TEMIC_4136" },
+	[ 0x12 ] = { .id   = TUNER_ABSENT,
+		     .name = "TEMIC_4146" },
+
+	[ 0x20 ] = { .id   = TUNER_PHILIPS_FQ1216ME, .fm = 1,
+		     .name = "PHILIPS_FQ1216_MK3" },
+	[ 0x21 ] = { .id   = TUNER_ABSENT, .fm = 1,
+		     .name = "PHILIPS_FQ1236_MK3" },
+	[ 0x22 ] = { .id   = TUNER_ABSENT,
+		     .name = "PHILIPS_FI1236_MK3" },
+	[ 0x23 ] = { .id   = TUNER_ABSENT,
+		     .name = "PHILIPS_FI1216_MK3" },
+};
+
+static void __devinit gdi_eeprom(struct cx8800_dev *dev, u8 *eeprom_data)
+{
+	char *name = (eeprom_data[0x0d] < ARRAY_SIZE(gdi_tuner))
+		? gdi_tuner[eeprom_data[0x0d]].name : NULL;
+
+	printk(KERN_INFO "%s: GDI: tuner=%s\n", dev->name,
+	       name ? name : "unknown");
+	if (NULL == name)
+		return;
+	dev->tuner_type = gdi_tuner[eeprom_data[0x0d]].id;
+	dev->has_radio  = gdi_tuner[eeprom_data[0x0d]].fm;
+}
+
+/* ----------------------------------------------------------------------- */
+
+static int
+i2c_eeprom(struct i2c_client *c, unsigned char *eedata, int len)
+{
+	unsigned char buf;
+	int err;
+
+	c->addr = 0xa0 >> 1;
+	buf = 0;
+	if (1 != (err = i2c_master_send(c,&buf,1))) {
+		printk(KERN_INFO "cx88: Huh, no eeprom present (err=%d)?\n",
+		       err);
+		return -1;
+	}
+	if (len != (err = i2c_master_recv(c,eedata,len))) {
+		printk(KERN_WARNING "cx88: i2c eeprom read error (err=%d)\n",
+		       err);
+		return -1;
+	}
+#if 0
+	for (i = 0; i < len; i++) {
+		if (0 == (i % 16))
+			printk(KERN_INFO "cx88 ee: %02x:",i);
+		printk(" %02x",eedata[i]);
+		if (15 == (i % 16))
+			printk("\n");
+	}
+#endif
+	return 0;
+}
+
+void __devinit cx88_card_setup(struct cx8800_dev *dev)
+{
+	static u8 eeprom[128];
+		
+	switch (dev->board) {
+	case CX88_BOARD_HAUPPAUGE:
+		if (0 == dev->i2c_rc)
+			i2c_eeprom(&dev->i2c_client,eeprom,sizeof(eeprom));
+		hauppauge_eeprom(dev,eeprom+8);
+		break;
+	case CX88_BOARD_GDI:
+		if (0 == dev->i2c_rc)
+			i2c_eeprom(&dev->i2c_client,eeprom,sizeof(eeprom));
+		gdi_eeprom(dev,eeprom);
+		break;
+	}
+}
+
+/* ------------------------------------------------------------------ */
+
+EXPORT_SYMBOL(cx88_boards);
+EXPORT_SYMBOL(cx88_bcount);
+EXPORT_SYMBOL(cx88_subids);
+EXPORT_SYMBOL(cx88_idcount);
+EXPORT_SYMBOL(cx88_card_setup);
+
+/*
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
diff -u linux-2.6.1/drivers/media/video/cx88/cx88-core.c linux/drivers/media/video/cx88/cx88-core.c
--- linux-2.6.1/drivers/media/video/cx88/cx88-core.c	2004-01-14 14:36:15.458001360 +0100
+++ linux/drivers/media/video/cx88/cx88-core.c	2004-01-14 14:36:15.458001360 +0100
@@ -0,0 +1,613 @@
+/*
+ * device driver for Conexant 2388x based TV cards
+ * driver core
+ *
+ * (c) 2003 Gerd Knorr <kraxel@bytesex.org> [SuSE Labs]
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/kmod.h>
+#include <linux/sound.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/videodev.h>
+
+#include "cx88.h"
+
+MODULE_DESCRIPTION("v4l2 driver module for cx2388x based TV cards");
+MODULE_AUTHOR("Gerd Knorr <kraxel@bytesex.org> [SuSE Labs]");
+MODULE_LICENSE("GPL");
+
+/* ------------------------------------------------------------------ */
+
+#if 0
+static unsigned int gpio_tracking = 0;
+MODULE_PARM(gpio_tracking,"i");
+MODULE_PARM_DESC(gpio_tracking,"enable debug messages [gpio]");
+
+static unsigned int ts_nr = -1;
+MODULE_PARM(ts_nr,"i");
+MODULE_PARM_DESC(ts_nr,"ts device number");
+
+static unsigned int vbi_nr = -1;
+MODULE_PARM(vbi_nr,"i");
+MODULE_PARM_DESC(vbi_nr,"vbi device number");
+
+static unsigned int radio_nr = -1;
+MODULE_PARM(radio_nr,"i");
+MODULE_PARM_DESC(radio_nr,"radio device number");
+
+static unsigned int oss = 0;
+MODULE_PARM(oss,"i");
+MODULE_PARM_DESC(oss,"register oss devices (default: no)");
+
+static unsigned int dsp_nr = -1;
+MODULE_PARM(dsp_nr,"i");
+MODULE_PARM_DESC(dsp_nr,"oss dsp device number");
+
+static unsigned int mixer_nr = -1;
+MODULE_PARM(mixer_nr,"i");
+MODULE_PARM_DESC(mixer_nr,"oss mixer device number");
+#endif
+
+static unsigned int core_debug = 0;
+MODULE_PARM(core_debug,"i");
+MODULE_PARM_DESC(core_debug,"enable debug messages [core]");
+
+#define dprintk(fmt, arg...)	if (core_debug) \
+	printk(KERN_DEBUG "%s/core: " fmt, dev->name , ## arg)
+
+/* ------------------------------------------------------------------ */
+/* debug help functions                                               */
+
+static const char *v4l1_ioctls[] = {
+	"0", "CGAP", "GCHAN", "SCHAN", "GTUNER", "STUNER", "GPICT", "SPICT",
+	"CCAPTURE", "GWIN", "SWIN", "GFBUF", "SFBUF", "KEY", "GFREQ",
+	"SFREQ", "GAUDIO", "SAUDIO", "SYNC", "MCAPTURE", "GMBUF", "GUNIT",
+	"GCAPTURE", "SCAPTURE", "SPLAYMODE", "SWRITEMODE", "GPLAYINFO",
+	"SMICROCODE", "GVBIFMT", "SVBIFMT" };
+#define V4L1_IOCTLS ARRAY_SIZE(v4l1_ioctls)
+
+static const char *v4l2_ioctls[] = {
+	"QUERYCAP", "1", "ENUM_PIXFMT", "ENUM_FBUFFMT", "G_FMT", "S_FMT",
+	"G_COMP", "S_COMP", "REQBUFS", "QUERYBUF", "G_FBUF", "S_FBUF",
+	"G_WIN", "S_WIN", "PREVIEW", "QBUF", "16", "DQBUF", "STREAMON",
+	"STREAMOFF", "G_PERF", "G_PARM", "S_PARM", "G_STD", "S_STD",
+	"ENUMSTD", "ENUMINPUT", "G_CTRL", "S_CTRL", "G_TUNER", "S_TUNER",
+	"G_FREQ", "S_FREQ", "G_AUDIO", "S_AUDIO", "35", "QUERYCTRL",
+	"QUERYMENU", "G_INPUT", "S_INPUT", "ENUMCVT", "41", "42", "43",
+	"44", "45",  "G_OUTPUT", "S_OUTPUT", "ENUMOUTPUT", "G_AUDOUT",
+	"S_AUDOUT", "ENUMFX", "G_EFFECT", "S_EFFECT", "G_MODULATOR",
+	"S_MODULATOR"
+};
+#define V4L2_IOCTLS ARRAY_SIZE(v4l2_ioctls)
+
+static const char *osspcm_ioctls[] = {
+	"RESET", "SYNC", "SPEED", "STEREO", "GETBLKSIZE", "SETFMT",
+	"CHANNELS", "?", "POST", "SUBDIVIDE", "SETFRAGMENT", "GETFMTS",
+	"GETOSPACE", "GETISPACE", "NONBLOCK", "GETCAPS", "GET/SETTRIGGER",
+	"GETIPTR", "GETOPTR", "MAPINBUF", "MAPOUTBUF", "SETSYNCRO",
+	"SETDUPLEX", "GETODELAY"
+};
+#define OSSPCM_IOCTLS ARRAY_SIZE(v4l2_ioctls)
+
+void cx88_print_ioctl(char *name, unsigned int cmd)
+{
+	char *dir;
+
+	switch (_IOC_DIR(cmd)) {
+	case _IOC_NONE:              dir = "--"; break;
+	case _IOC_READ:              dir = "r-"; break;
+	case _IOC_WRITE:             dir = "-w"; break;
+	case _IOC_READ | _IOC_WRITE: dir = "rw"; break;
+	default:                     dir = "??"; break;
+	}
+	switch (_IOC_TYPE(cmd)) {
+	case 'v':
+		printk(KERN_DEBUG "%s: ioctl 0x%08x (v4l1, %s, VIDIOC%s)\n",
+		       name, cmd, dir, (_IOC_NR(cmd) < V4L1_IOCTLS) ?
+		       v4l1_ioctls[_IOC_NR(cmd)] : "???");
+		break;
+	case 'V':
+		printk(KERN_DEBUG "%s: ioctl 0x%08x (v4l2, %s, VIDIOC_%s)\n",
+		       name, cmd, dir, (_IOC_NR(cmd) < V4L2_IOCTLS) ?
+		       v4l2_ioctls[_IOC_NR(cmd)] : "???");
+		break;
+	case 'P':
+		printk(KERN_DEBUG "%s: ioctl 0x%08x (oss dsp, %s, SNDCTL_DSP_%s)\n",
+		       name, cmd, dir, (_IOC_NR(cmd) < OSSPCM_IOCTLS) ?
+		       osspcm_ioctls[_IOC_NR(cmd)] : "???");
+		break;
+	case 'M':
+		printk(KERN_DEBUG "%s: ioctl 0x%08x (oss mixer, %s, #%d)\n",
+		       name, cmd, dir, _IOC_NR(cmd));
+		break;
+	default:
+		printk(KERN_DEBUG "%s: ioctl 0x%08x (???, %s, #%d)\n",
+		       name, cmd, dir, _IOC_NR(cmd));
+	}
+}
+
+/* ------------------------------------------------------------------ */
+
+static u32* cx88_risc_field(u32 *rp, struct scatterlist *sglist,
+			    unsigned int offset, u32 sync_line,
+			    unsigned int bpl, unsigned int padding,
+			    unsigned int lines)
+{
+	struct scatterlist *sg;
+	unsigned int line,todo;
+
+	/* sync instruction */
+	*(rp++) = cpu_to_le32(RISC_RESYNC | sync_line);
+	
+	/* scan lines */
+	sg = sglist;
+	for (line = 0; line < lines; line++) {
+		while (offset && offset >= sg_dma_len(sg)) {
+			offset -= sg_dma_len(sg);
+			sg++;
+		}
+		if (bpl <= sg_dma_len(sg)-offset) {
+			/* fits into current chunk */
+                        *(rp++)=cpu_to_le32(RISC_WRITE|RISC_SOL|RISC_EOL|bpl);
+                        *(rp++)=cpu_to_le32(sg_dma_address(sg)+offset);
+                        offset+=bpl;
+		} else {
+			/* scanline needs to be splitted */
+                        todo = bpl;
+                        *(rp++)=cpu_to_le32(RISC_WRITE|RISC_SOL|
+					    (sg_dma_len(sg)-offset));
+                        *(rp++)=cpu_to_le32(sg_dma_address(sg)+offset);
+                        todo -= (sg_dma_len(sg)-offset);
+                        offset = 0;
+                        sg++;
+                        while (todo > sg_dma_len(sg)) {
+                                *(rp++)=cpu_to_le32(RISC_WRITE|
+						    sg_dma_len(sg));
+                                *(rp++)=cpu_to_le32(sg_dma_address(sg));
+				todo -= sg_dma_len(sg);
+				sg++;
+			}
+                        *(rp++)=cpu_to_le32(RISC_WRITE|RISC_EOL|todo);
+			*(rp++)=cpu_to_le32(sg_dma_address(sg));
+			offset += todo;
+		}
+		offset += padding;
+	}
+
+	return rp;
+}
+
+int cx88_risc_buffer(struct pci_dev *pci, struct btcx_riscmem *risc,
+		     struct scatterlist *sglist,
+		     unsigned int top_offset, unsigned int bottom_offset,
+		     unsigned int bpl, unsigned int padding, unsigned int lines)
+{
+	u32 instructions,fields;
+	u32 *rp;
+	int rc;
+
+	fields = 0;
+	if (UNSET != top_offset)
+		fields++;
+	if (UNSET != bottom_offset)
+		fields++;
+
+	/* estimate risc mem: worst case is one write per page border +
+	   one write per scan line + syncs + jump (all 2 dwords) */
+	instructions  = (bpl * lines * fields) / PAGE_SIZE + lines * fields;
+	instructions += 3 + 4;
+	if ((rc = btcx_riscmem_alloc(pci,risc,instructions*8)) < 0)
+		return rc;
+
+	/* write risc instructions */
+	rp = risc->cpu;
+	if (UNSET != top_offset)
+		rp = cx88_risc_field(rp, sglist, top_offset, 0,
+				     bpl, padding, lines);
+	if (UNSET != bottom_offset)
+		rp = cx88_risc_field(rp, sglist, bottom_offset, 0x200,
+				     bpl, padding, lines);
+
+	/* save pointer to jmp instruction address */
+	risc->jmp = rp;
+	return 0;
+}
+
+int cx88_risc_stopper(struct pci_dev *pci, struct btcx_riscmem *risc,
+		      u32 reg, u32 mask, u32 value)
+{
+	u32 *rp;
+	int rc;
+
+	if ((rc = btcx_riscmem_alloc(pci, risc, 4*16)) < 0)
+		return rc;
+
+	/* write risc instructions */
+	rp = risc->cpu;
+	*(rp++) = cpu_to_le32(RISC_WRITECR  | RISC_IRQ2 | RISC_IMM);
+	*(rp++) = cpu_to_le32(reg);
+	*(rp++) = cpu_to_le32(value);
+	*(rp++) = cpu_to_le32(mask);
+	*(rp++) = cpu_to_le32(RISC_JUMP);
+	*(rp++) = cpu_to_le32(risc->dma);
+	return 0;
+}
+
+void
+cx88_free_buffer(struct pci_dev *pci, struct cx88_buffer *buf)
+{
+	if (in_interrupt())
+		BUG();
+	videobuf_waiton(&buf->vb,0,0);
+	videobuf_dma_pci_unmap(pci, &buf->vb.dma);
+	videobuf_dma_free(&buf->vb.dma);
+	btcx_riscmem_free(pci, &buf->risc);
+	buf->vb.state = STATE_NEEDS_INIT;
+}
+
+/* ------------------------------------------------------------------ */
+/* our SRAM memory layout                                             */
+
+/* we are going to put all thr risc programs into host memory, so we
+ * can use the whole SDRAM for the DMA fifos.  To simplify things, we
+ * use a static memory layout.  That surely will waste memory in case
+ * we don't use all DMA channels at the same time (which will be the
+ * case most of the time).  But that still gives us enougth FIFO space
+ * to be able to deal with insane long pci latencies ...
+ *
+ * FIFO space allocations:
+ *    channel  21    (y video)  - 10.0k
+ *    channel  24    (vbi)      -  4.0k
+ *    channels 25+26 (audio)    -  0.5k
+ *    everything else           -  2.0k
+ *    TOTAL                     = 29.0k
+ *
+ * Every channel has 160 bytes control data (64 bytes instruction
+ * queue and 6 CDT entries), which is close to 2k total.
+ * 
+ * Address layout:
+ *    0x0000 - 0x03ff    CMDs / reserved
+ *    0x0400 - 0x0bff    instruction queues + CDs
+ *    0x0c00 -           FIFOs
+ */
+
+struct sram_channel cx88_sram_channels[] = {
+	[SRAM_CH21] = {
+		.name       = "video y / packed",
+		.cmds_start = 0x180040,
+		.ctrl_start = 0x180400,
+		.fifo_start = 0x180c00,
+		.fifo_size  = 0x002800,
+		.ptr1_reg   = MO_DMA21_PTR1,
+		.ptr2_reg   = MO_DMA21_PTR2,
+		.cnt1_reg   = MO_DMA21_CNT1,
+		.cnt2_reg   = MO_DMA21_CNT2,
+	},
+	[SRAM_CH22] = {
+		.name       = "video u",
+		.cmds_start = 0x180080,
+		.ctrl_start = 0x1804a0,
+		.fifo_start = 0x183400,
+		.fifo_size  = 0x000800,
+		.ptr1_reg   = MO_DMA22_PTR1,
+		.ptr2_reg   = MO_DMA22_PTR2,
+		.cnt1_reg   = MO_DMA22_CNT1,
+		.cnt2_reg   = MO_DMA22_CNT2,
+	},
+	[SRAM_CH23] = {
+		.name       = "video v",
+		.cmds_start = 0x1800c0,
+		.ctrl_start = 0x180540,
+		.fifo_start = 0x183c00,
+		.fifo_size  = 0x000800,
+		.ptr1_reg   = MO_DMA23_PTR1,
+		.ptr2_reg   = MO_DMA23_PTR2,
+		.cnt1_reg   = MO_DMA23_CNT1,
+		.cnt2_reg   = MO_DMA23_CNT2,
+	},
+	[SRAM_CH24] = {
+		.name       = "vbi",
+		.cmds_start = 0x180100,
+		.ctrl_start = 0x1805e0,
+		.fifo_start = 0x184400,
+		.fifo_size  = 0x001000,
+		.ptr1_reg   = MO_DMA24_PTR1,
+		.ptr2_reg   = MO_DMA24_PTR2,
+		.cnt1_reg   = MO_DMA24_CNT1,
+		.cnt2_reg   = MO_DMA24_CNT2,
+	},
+	[SRAM_CH25] = {
+		.name       = "audio from",
+		.cmds_start = 0x180140,
+		.ctrl_start = 0x180680,
+		.fifo_start = 0x185400,
+		.fifo_size  = 0x000200,
+		.ptr1_reg   = MO_DMA25_PTR1,
+		.ptr2_reg   = MO_DMA25_PTR2,
+		.cnt1_reg   = MO_DMA25_CNT1,
+		.cnt2_reg   = MO_DMA25_CNT2,
+	},
+	[SRAM_CH26] = {
+		.name       = "audio to",
+		.cmds_start = 0x180180,
+		.ctrl_start = 0x180720,
+		.fifo_start = 0x185600,
+		.fifo_size  = 0x000200,
+		.ptr1_reg   = MO_DMA26_PTR1,
+		.ptr2_reg   = MO_DMA26_PTR2,
+		.cnt1_reg   = MO_DMA26_CNT1,
+		.cnt2_reg   = MO_DMA26_CNT2,
+	},
+};
+
+int cx88_sram_channel_setup(struct cx8800_dev *dev,
+			    struct sram_channel *ch,
+			    unsigned int bpl, u32 risc)
+{
+	unsigned int i,lines;
+	u32 cdt;
+
+	bpl   = (bpl + 7) & ~7; /* alignment */
+	cdt   = ch->ctrl_start + 64;
+	lines = ch->fifo_size / bpl;
+	if (lines > 6)
+		lines = 6;
+	BUG_ON(lines < 2);
+
+	/* write CDT */
+	for (i = 0; i < lines; i++)
+		cx_write(cdt + 16*i, ch->fifo_start + bpl*i);
+
+	/* write CMDS */
+	cx_write(ch->cmds_start +  0, risc);
+	cx_write(ch->cmds_start +  4, cdt);
+	cx_write(ch->cmds_start +  8, (lines*16) >> 3);
+	cx_write(ch->cmds_start + 12, ch->ctrl_start);
+	cx_write(ch->cmds_start + 16, 64 >> 2);
+	for (i = 20; i < 64; i += 4)
+		cx_write(ch->cmds_start + i, 0);
+
+	/* fill registers */
+	cx_write(ch->ptr1_reg, ch->fifo_start);
+	cx_write(ch->ptr2_reg, cdt);
+	cx_write(ch->cnt1_reg, bpl >> 3);
+	cx_write(ch->cnt2_reg, (lines*16) >> 3);
+
+	dprintk("sram setup %s: bpl=%d lines=%d\n", ch->name, bpl, lines);
+	return 0;
+}
+
+/* ------------------------------------------------------------------ */
+/* debug helper code                                                  */
+
+int cx88_risc_decode(u32 risc)
+{
+	static char *instr[16] = {
+		[ 0 ... 15 ]           = "INVALID",
+		[ RISC_SYNC    >> 28 ] = "sync",
+		[ RISC_WRITE   >> 28 ] = "write",
+		[ RISC_WRITEC  >> 28 ] = "writec",
+		[ RISC_READ    >> 28 ] = "read",
+		[ RISC_READC   >> 28 ] = "readc",
+		[ RISC_JUMP    >> 28 ] = "jump",
+		[ RISC_SKIP    >> 28 ] = "skip",
+		[ RISC_WRITERM >> 28 ] = "writerm",
+		[ RISC_WRITECM >> 28 ] = "writecm",
+		[ RISC_WRITECR >> 28 ] = "writecr",
+	};
+	static int incr[16] = {
+		[ 0 ... 15 ]           = 1,
+		[ RISC_WRITE   >> 28 ] = 2,
+		[ RISC_JUMP    >> 28 ] = 2,
+		[ RISC_WRITERM >> 28 ] = 3,
+		[ RISC_WRITECM >> 28 ] = 3,
+		[ RISC_WRITECR >> 28 ] = 4,
+	};
+	static char *bits[] = {
+		"12",   "13",   "14",   "resync",
+		"cnt0", "cnt1", "18",   "19",
+		"20",   "21",   "22",   "23",
+		"irq1", "irq2", "eol",  "sol",
+	};
+	int i;
+
+	printk("0x%08x [ %s", risc, instr[risc >> 28]);
+	for (i = ARRAY_SIZE(bits)-1; i >= 0; i--)
+		if (risc & (1 << (i + 12)))
+			printk(" %s",bits[i]);
+	printk(" count=%d ]\n", risc & 0xfff);
+	return incr[risc >> 28];
+}
+
+void cx88_risc_disasm(struct cx8800_dev *dev,
+		      struct btcx_riscmem *risc)
+{
+	unsigned int i,j,n;
+	
+	printk("%s: risc disasm: %p [dma=0x%08lx]\n",
+	       dev->name, risc->cpu, (unsigned long)risc->dma);
+	for (i = 0; i < (risc->size >> 2); i += n) {
+		printk("%s:   %04d: ", dev->name, i);
+		n = cx88_risc_decode(risc->cpu[i]);
+		for (j = 1; j < n; j++)
+			printk("%s:   %04d: 0x%08x [ arg #%d ]\n",
+			       dev->name, i+j, risc->cpu[i+j], j);
+		if (risc->cpu[i] == RISC_JUMP)
+			break;
+	}
+}
+
+void cx88_sram_channel_dump(struct cx8800_dev *dev,
+			    struct sram_channel *ch)
+{
+	static char *name[] = {
+		"initial risc",
+		"cdt base",
+		"cdt size",
+		"iq base",
+		"iq size",
+		"risc pc",
+		"iq wr ptr",
+		"iq rd ptr",
+		"cdt current",
+		"pci target",
+		"line / byte",
+	};
+	u32 risc;
+	unsigned int i,j,n;
+
+	printk("%s: %s - dma channel status dump\n",dev->name,ch->name);
+	for (i = 0; i < ARRAY_SIZE(name); i++)
+		printk("%s:   cmds: %-12s: 0x%08x\n",
+		       dev->name,name[i],
+		       cx_read(ch->cmds_start + 4*i));
+	for (i = 0; i < 4; i++) {
+		risc = cx_read(ch->cmds_start + 4 * (i+11));
+		printk("%s:   risc%d: ", dev->name, i);
+		cx88_risc_decode(risc);
+	}
+	for (i = 0; i < 16; i += n) {
+		risc = cx_read(ch->ctrl_start + 4 * i);
+		printk("%s:   iq %x: ", dev->name, i);
+		n = cx88_risc_decode(risc);
+		for (j = 1; j < n; j++) {
+			risc = cx_read(ch->ctrl_start + 4 * (i+j));
+			printk("%s:   iq %x: 0x%08x [ arg #%d ]\n",
+			       dev->name, i+j, risc, j);
+		}
+	}
+
+	printk("%s: fifo: 0x%08x -> 0x%x\n",
+	       dev->name, ch->fifo_start, ch->fifo_start+ch->fifo_size);
+	printk("%s: ctrl: 0x%08x -> 0x%x\n",
+	       dev->name, ch->ctrl_start, ch->ctrl_start+6*16);
+	printk("%s:   ptr1_reg: 0x%08x\n",
+	       dev->name,cx_read(ch->ptr1_reg));
+	printk("%s:   ptr2_reg: 0x%08x\n",
+	       dev->name,cx_read(ch->ptr2_reg));
+	printk("%s:   cnt1_reg: 0x%08x\n",
+	       dev->name,cx_read(ch->cnt1_reg));
+	printk("%s:   cnt2_reg: 0x%08x\n",
+	       dev->name,cx_read(ch->cnt2_reg));
+}
+
+char *cx88_pci_irqs[32] = {
+	"vid", "aud", "ts", "vip", "hst", "5", "6", "tm1", 
+	"src_dma", "dst_dma", "risc_rd_err", "risc_wr_err",
+	"brdg_err", "src_dma_err", "dst_dma_err", "ipb_dma_err",
+	"i2c", "i2c_rack", "ir_smp", "gpio0", "gpio1"
+};
+char *cx88_vid_irqs[32] = {
+	"y_risci1", "u_risci1", "v_risci1", "vbi_risc1", 
+	"y_risci2", "u_risci2", "v_risci2", "vbi_risc2",
+	"y_oflow",  "u_oflow",  "v_oflow",  "vbi_oflow",
+	"y_sync",   "u_sync",   "v_sync",   "vbi_sync",
+	"opc_err",  "par_err",  "rip_err",  "pci_abort",
+};
+
+void cx88_print_irqbits(char *name, char *tag, char **strings,
+			u32 bits, u32 mask)
+{
+	unsigned int i;
+
+	printk(KERN_DEBUG "%s: %s [0x%x]", name, tag, bits);
+	for (i = 0; i < 32; i++) {
+		if (!(bits & (1 << i)))
+			continue;
+		printk(" %s",strings[i]);
+		if (!(mask & (1 << i)))
+			continue;
+		printk("*");
+	}
+	printk("\n");
+}
+
+/* ------------------------------------------------------------------ */
+
+int cx88_pci_quirks(char *name, struct pci_dev *pci, unsigned int *latency)
+{
+	u8 ctrl = 0;
+	u8 value;
+
+	if (0 == pci_pci_problems)
+		return 0;
+
+	if (pci_pci_problems & PCIPCI_TRITON) {
+		printk(KERN_INFO "%s: quirk: PCIPCI_TRITON -- set TBFX\n",
+		       name);
+		ctrl |= CX88X_EN_TBFX;
+	}
+	if (pci_pci_problems & PCIPCI_NATOMA) {
+		printk(KERN_INFO "%s: quirk: PCIPCI_NATOMA -- set TBFX\n",
+		       name);
+		ctrl |= CX88X_EN_TBFX;
+	}
+	if (pci_pci_problems & PCIPCI_VIAETBF) {
+		printk(KERN_INFO "%s: quirk: PCIPCI_VIAETBF -- set TBFX\n",
+		       name);
+		ctrl |= CX88X_EN_TBFX;
+	}
+	if (pci_pci_problems & PCIPCI_VSFX) {
+		printk(KERN_INFO "%s: quirk: PCIPCI_VSFX -- set VSFX\n",
+		       name);
+		ctrl |= CX88X_EN_VSFX;
+	}
+#ifdef PCIPCI_ALIMAGIK
+	if (pci_pci_problems & PCIPCI_ALIMAGIK) {
+		printk(KERN_INFO "%s: quirk: PCIPCI_ALIMAGIK -- latency fixup\n",
+		       name);
+		*latency = 0x0A;
+	}
+#endif
+	if (ctrl) {
+		pci_read_config_byte(pci, CX88X_DEVCTRL, &value);
+		value |= ctrl;
+		pci_write_config_byte(pci, CX88X_DEVCTRL, value);
+	}
+	return 0;
+}
+
+/* ------------------------------------------------------------------ */
+
+EXPORT_SYMBOL(cx88_print_ioctl);
+EXPORT_SYMBOL(cx88_pci_irqs);
+EXPORT_SYMBOL(cx88_vid_irqs);
+EXPORT_SYMBOL(cx88_print_irqbits);
+
+EXPORT_SYMBOL(cx88_risc_buffer);
+EXPORT_SYMBOL(cx88_risc_stopper);
+EXPORT_SYMBOL(cx88_free_buffer);
+
+EXPORT_SYMBOL(cx88_risc_disasm);
+
+EXPORT_SYMBOL(cx88_sram_channels);
+EXPORT_SYMBOL(cx88_sram_channel_setup);
+EXPORT_SYMBOL(cx88_sram_channel_dump);
+
+EXPORT_SYMBOL(cx88_pci_quirks);
+
+/*
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
diff -u linux-2.6.1/drivers/media/video/cx88/cx88-i2c.c linux/drivers/media/video/cx88/cx88-i2c.c
--- linux-2.6.1/drivers/media/video/cx88/cx88-i2c.c	2004-01-14 14:36:15.460001056 +0100
+++ linux/drivers/media/video/cx88/cx88-i2c.c	2004-01-14 14:36:15.460001056 +0100
@@ -0,0 +1,172 @@
+/*
+    cx88-i2c.c  --  all the i2c code is here
+
+    Copyright (C) 1996,97,98 Ralph  Metzler (rjkm@thp.uni-koeln.de)
+                           & Marcus Metzler (mocm@thp.uni-koeln.de)
+    (c) 2002 Yurij Sysoev <yurij@naturesoft.net>
+    (c) 1999-2003 Gerd Knorr <kraxel@bytesex.org>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+    
+*/
+
+#define __NO_VERSION__ 1
+
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include <asm/io.h>
+
+#include "cx88.h"
+
+/* ----------------------------------------------------------------------- */
+
+void cx8800_bit_setscl(void *data, int state)
+{
+	struct cx8800_dev *dev = data;
+
+	if (state)
+		dev->i2c_state |= 0x02;
+	else
+		dev->i2c_state &= ~0x02;
+	cx_write(MO_I2C, dev->i2c_state);
+	cx_read(MO_I2C);
+}
+
+void cx8800_bit_setsda(void *data, int state)
+{
+	struct cx8800_dev *dev = data;
+
+	if (state)
+		dev->i2c_state |= 0x01;
+	else
+		dev->i2c_state &= ~0x01;
+	cx_write(MO_I2C, dev->i2c_state);
+	cx_read(MO_I2C);
+}
+
+static int cx8800_bit_getscl(void *data)
+{
+	struct cx8800_dev *dev = data;
+	u32 state;
+	
+	state = cx_read(MO_I2C);
+	return state & 0x02 ? 1 : 0;
+}
+
+static int cx8800_bit_getsda(void *data)
+{
+	struct cx8800_dev *dev = data;
+	u32 state;
+
+	state = cx_read(MO_I2C);
+	return state & 0x01;
+}
+
+/* ----------------------------------------------------------------------- */
+
+#ifndef I2C_PEC
+static void cx8800_inc_use(struct i2c_adapter *adap)
+{
+	MOD_INC_USE_COUNT;
+}
+
+static void cx8800_dec_use(struct i2c_adapter *adap)
+{
+	MOD_DEC_USE_COUNT;
+}
+#endif
+
+static int attach_inform(struct i2c_client *client)
+{
+        struct cx8800_dev *dev = i2c_get_adapdata(client->adapter);
+
+	if (dev->tuner_type != UNSET)
+		cx8800_call_i2c_clients(dev,TUNER_SET_TYPE,&dev->tuner_type);
+
+        if (1 /* fixme: debug */)
+		printk("%s: i2c attach [client=%s]\n",
+		       dev->name, i2c_clientname(client));
+        return 0;
+}
+
+void cx8800_call_i2c_clients(struct cx8800_dev *dev, unsigned int cmd, void *arg)
+{
+	if (0 != dev->i2c_rc)
+		return;
+	i2c_clients_command(&dev->i2c_adap, cmd, arg);
+}
+
+static struct i2c_algo_bit_data cx8800_i2c_algo_template = {
+	.setsda  = cx8800_bit_setsda,
+	.setscl  = cx8800_bit_setscl,
+	.getsda  = cx8800_bit_getsda,
+	.getscl  = cx8800_bit_getscl,
+	.udelay  = 16,
+	.mdelay  = 10,
+	.timeout = 200,
+};
+
+/* ----------------------------------------------------------------------- */
+
+static struct i2c_adapter cx8800_i2c_adap_template = {
+#ifdef I2C_PEC
+	.owner             = THIS_MODULE,
+#else
+	.inc_use           = cx8800_inc_use,
+	.dec_use           = cx8800_dec_use,
+#endif
+#ifdef I2C_ADAP_CLASS_TV_ANALOG
+	.class             = I2C_ADAP_CLASS_TV_ANALOG,
+#endif
+	I2C_DEVNAME("cx2388x"),
+	.id                = I2C_HW_B_BT848,
+	.client_register   = attach_inform,
+};
+
+static struct i2c_client cx8800_i2c_client_template = {
+        I2C_DEVNAME("cx88xx internal"),
+        .id   = -1,
+};
+
+/* init + register i2c algo-bit adapter */
+int __devinit cx8800_i2c_init(struct cx8800_dev *dev)
+{
+	memcpy(&dev->i2c_adap, &cx8800_i2c_adap_template,
+	       sizeof(dev->i2c_adap));
+	memcpy(&dev->i2c_algo, &cx8800_i2c_algo_template,
+	       sizeof(dev->i2c_algo));
+	memcpy(&dev->i2c_client, &cx8800_i2c_client_template,
+	       sizeof(dev->i2c_client));
+
+	dev->i2c_adap.dev.parent = &dev->pci->dev;
+	strcpy(dev->i2c_adap.name,dev->name);
+        dev->i2c_algo.data = dev;
+        i2c_set_adapdata(&dev->i2c_adap,dev);
+        dev->i2c_adap.algo_data = &dev->i2c_algo;
+        dev->i2c_client.adapter = &dev->i2c_adap;
+
+	cx8800_bit_setscl(dev,1);
+	cx8800_bit_setsda(dev,1);
+
+	dev->i2c_rc = i2c_bit_add_bus(&dev->i2c_adap);
+	return dev->i2c_rc;
+}
+
+/*
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
diff -u linux-2.6.1/drivers/media/video/cx88/cx88-reg.h linux/drivers/media/video/cx88/cx88-reg.h
--- linux-2.6.1/drivers/media/video/cx88/cx88-reg.h	2004-01-14 14:36:15.452002272 +0100
+++ linux/drivers/media/video/cx88/cx88-reg.h	2004-01-14 14:36:15.453002120 +0100
@@ -0,0 +1,770 @@
+/* 
+    cx88x-hw.h - CX2388x register offsets
+
+    Copyright (C) 1996,97,98 Ralph Metzler (rjkm@thp.uni-koeln.de)
+                  2001 Michael Eskin
+                  2002 Yurij Sysoev <yurij@naturesoft.net>
+                  2003 Gerd Knorr <kraxel@bytesex.org>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#ifndef _CX88_REG_H_
+#define _CX88_REG_H_
+
+/* ---------------------------------------------------------------------- */
+/* PCI IDs and config space                                               */
+
+#ifndef PCI_VENDOR_ID_CONEXANT
+# define PCI_VENDOR_ID_CONEXANT		0x14F1
+#endif
+#ifndef PCI_DEVICE_ID_CX2300_VID
+# define PCI_DEVICE_ID_CX2300_VID	0x8800
+#endif
+
+#define CX88X_DEVCTRL 0x40
+#define CX88X_EN_TBFX 0x02
+#define CX88X_EN_VSFX 0x04
+
+
+/* ---------------------------------------------------------------------- */
+/* DMA Controller registers                                               */
+
+#define MO_PDMA_STHRSH      0x200000 // Source threshold
+#define MO_PDMA_STADRS      0x200004 // Source target address
+#define MO_PDMA_SIADRS      0x200008 // Source internal address
+#define MO_PDMA_SCNTRL      0x20000C // Source control
+#define MO_PDMA_DTHRSH      0x200010 // Destination threshold
+#define MO_PDMA_DTADRS      0x200014 // Destination target address
+#define MO_PDMA_DIADRS      0x200018 // Destination internal address
+#define MO_PDMA_DCNTRL      0x20001C // Destination control
+#define MO_LD_SSID          0x200030 // Load subsystem ID
+#define MO_DEV_CNTRL2       0x200034 // Device control
+#define MO_PCI_INTMSK       0x200040 // PCI interrupt mask
+#define MO_PCI_INTSTAT      0x200044 // PCI interrupt status
+#define MO_PCI_INTMSTAT     0x200048 // PCI interrupt masked status
+#define MO_VID_INTMSK       0x200050 // Video interrupt mask
+#define MO_VID_INTSTAT      0x200054 // Video interrupt status
+#define MO_VID_INTMSTAT     0x200058 // Video interrupt masked status
+#define MO_VID_INTSSTAT     0x20005C // Video interrupt set status
+#define MO_AUD_INTMSK       0x200060 // Audio interrupt mask
+#define MO_AUD_INTSTAT      0x200064 // Audio interrupt status
+#define MO_AUD_INTMSTAT     0x200068 // Audio interrupt masked status
+#define MO_AUD_INTSSTAT     0x20006C // Audio interrupt set status
+#define MO_TS_INTMSK        0x200070 // Transport stream interrupt mask
+#define MO_TS_INTSTAT       0x200074 // Transport stream interrupt status
+#define MO_TS_INTMSTAT      0x200078 // Transport stream interrupt mask status
+#define MO_TS_INTSSTAT      0x20007C // Transport stream interrupt set status
+#define MO_VIP_INTMSK       0x200080 // VIP interrupt mask
+#define MO_VIP_INTSTAT      0x200084 // VIP interrupt status
+#define MO_VIP_INTMSTAT     0x200088 // VIP interrupt masked status
+#define MO_VIP_INTSSTAT     0x20008C // VIP interrupt set status
+#define MO_GPHST_INTMSK     0x200090 // Host interrupt mask
+#define MO_GPHST_INTSTAT    0x200094 // Host interrupt status
+#define MO_GPHST_INTMSTAT   0x200098 // Host interrupt masked status
+#define MO_GPHST_INTSSTAT   0x20009C // Host interrupt set status
+
+// DMA Channels 1-6 belong to SPIPE
+#define MO_DMA7_PTR1        0x300018 // {24}RW* DMA Current Ptr : Ch#7
+#define MO_DMA8_PTR1        0x30001C // {24}RW* DMA Current Ptr : Ch#8
+
+// DMA Channels 9-20 belong to SPIPE
+#define MO_DMA21_PTR1       0x300080 // {24}R0* DMA Current Ptr : Ch#21
+#define MO_DMA22_PTR1       0x300084 // {24}R0* DMA Current Ptr : Ch#22
+#define MO_DMA23_PTR1       0x300088 // {24}R0* DMA Current Ptr : Ch#23
+#define MO_DMA24_PTR1       0x30008C // {24}R0* DMA Current Ptr : Ch#24
+#define MO_DMA25_PTR1       0x300090 // {24}R0* DMA Current Ptr : Ch#25
+#define MO_DMA26_PTR1       0x300094 // {24}R0* DMA Current Ptr : Ch#26
+#define MO_DMA27_PTR1       0x300098 // {24}R0* DMA Current Ptr : Ch#27
+#define MO_DMA28_PTR1       0x30009C // {24}R0* DMA Current Ptr : Ch#28
+#define MO_DMA29_PTR1       0x3000A0 // {24}R0* DMA Current Ptr : Ch#29
+#define MO_DMA30_PTR1       0x3000A4 // {24}R0* DMA Current Ptr : Ch#30
+#define MO_DMA31_PTR1       0x3000A8 // {24}R0* DMA Current Ptr : Ch#31
+#define MO_DMA32_PTR1       0x3000AC // {24}R0* DMA Current Ptr : Ch#32
+
+#define MO_DMA21_PTR2       0x3000C0 // {24}RW* DMA Tab Ptr : Ch#21
+#define MO_DMA22_PTR2       0x3000C4 // {24}RW* DMA Tab Ptr : Ch#22
+#define MO_DMA23_PTR2       0x3000C8 // {24}RW* DMA Tab Ptr : Ch#23
+#define MO_DMA24_PTR2       0x3000CC // {24}RW* DMA Tab Ptr : Ch#24
+#define MO_DMA25_PTR2       0x3000D0 // {24}RW* DMA Tab Ptr : Ch#25
+#define MO_DMA26_PTR2       0x3000D4 // {24}RW* DMA Tab Ptr : Ch#26
+#define MO_DMA27_PTR2       0x3000D8 // {24}RW* DMA Tab Ptr : Ch#27
+#define MO_DMA28_PTR2       0x3000DC // {24}RW* DMA Tab Ptr : Ch#28
+#define MO_DMA29_PTR2       0x3000E0 // {24}RW* DMA Tab Ptr : Ch#29
+#define MO_DMA30_PTR2       0x3000E4 // {24}RW* DMA Tab Ptr : Ch#30
+#define MO_DMA31_PTR2       0x3000E8 // {24}RW* DMA Tab Ptr : Ch#31
+#define MO_DMA32_PTR2       0x3000EC // {24}RW* DMA Tab Ptr : Ch#32
+
+#define MO_DMA21_CNT1       0x300100 // {11}RW* DMA Buffer Size : Ch#21
+#define MO_DMA22_CNT1       0x300104 // {11}RW* DMA Buffer Size : Ch#22
+#define MO_DMA23_CNT1       0x300108 // {11}RW* DMA Buffer Size : Ch#23
+#define MO_DMA24_CNT1       0x30010C // {11}RW* DMA Buffer Size : Ch#24
+#define MO_DMA25_CNT1       0x300110 // {11}RW* DMA Buffer Size : Ch#25
+#define MO_DMA26_CNT1       0x300114 // {11}RW* DMA Buffer Size : Ch#26
+#define MO_DMA27_CNT1       0x300118 // {11}RW* DMA Buffer Size : Ch#27
+#define MO_DMA28_CNT1       0x30011C // {11}RW* DMA Buffer Size : Ch#28
+#define MO_DMA29_CNT1       0x300120 // {11}RW* DMA Buffer Size : Ch#29
+#define MO_DMA30_CNT1       0x300124 // {11}RW* DMA Buffer Size : Ch#30
+#define MO_DMA31_CNT1       0x300128 // {11}RW* DMA Buffer Size : Ch#31
+#define MO_DMA32_CNT1       0x30012C // {11}RW* DMA Buffer Size : Ch#32
+
+#define MO_DMA21_CNT2       0x300140 // {11}RW* DMA Table Size : Ch#21
+#define MO_DMA22_CNT2       0x300144 // {11}RW* DMA Table Size : Ch#22
+#define MO_DMA23_CNT2       0x300148 // {11}RW* DMA Table Size : Ch#23
+#define MO_DMA24_CNT2       0x30014C // {11}RW* DMA Table Size : Ch#24
+#define MO_DMA25_CNT2       0x300150 // {11}RW* DMA Table Size : Ch#25
+#define MO_DMA26_CNT2       0x300154 // {11}RW* DMA Table Size : Ch#26
+#define MO_DMA27_CNT2       0x300158 // {11}RW* DMA Table Size : Ch#27
+#define MO_DMA28_CNT2       0x30015C // {11}RW* DMA Table Size : Ch#28
+#define MO_DMA29_CNT2       0x300160 // {11}RW* DMA Table Size : Ch#29
+#define MO_DMA30_CNT2       0x300164 // {11}RW* DMA Table Size : Ch#30
+#define MO_DMA31_CNT2       0x300168 // {11}RW* DMA Table Size : Ch#31
+#define MO_DMA32_CNT2       0x30016C // {11}RW* DMA Table Size : Ch#32
+
+
+/* ---------------------------------------------------------------------- */
+/* Video registers                                                        */
+
+#define MO_VIDY_DMA         0x310000 // {64}RWp Video Y
+#define MO_VIDU_DMA         0x310008 // {64}RWp Video U
+#define MO_VIDV_DMA         0x310010 // {64}RWp Video V
+#define MO_VBI_DMA          0x310018 // {64}RWp VBI (Vertical blanking interval)
+
+#define MO_DEVICE_STATUS    0x310100
+#define MO_INPUT_FORMAT     0x310104
+#define MO_AGC_BURST        0x31010c
+#define MO_CONTR_BRIGHT     0x310110
+#define MO_HTOTAL           0x310120
+#define MO_HDELAY_EVEN      0x310124
+#define MO_HDELAY_ODD       0x310128
+#define MO_VDELAY_ODD       0x31012c
+#define MO_VDELAY_EVEN      0x310130
+#define MO_HACTIVE_EVEN     0x31013c
+#define MO_HACTIVE_ODD      0x310140
+#define MO_VACTIVE_EVEN     0x310144
+#define MO_VACTIVE_ODD      0x310148
+#define MO_HSCALE_EVEN      0x31014c
+#define MO_HSCALE_ODD       0x310150
+#define MO_VSCALE_EVEN      0x310154
+#define MO_FILTER_EVEN      0x31015c
+#define MO_VSCALE_ODD       0x310158
+#define MO_FILTER_ODD       0x310160
+#define MO_OUTPUT_FORMAT    0x310164
+
+#define MO_PLL_REG          0x310168 // PLL register
+#define MO_PLL_ADJ_CTRL     0x31016c // PLL adjust control register
+#define MO_SCONV_REG        0x310170 // sample rate conversion register
+#define MO_SCONV_FIFO       0x310174 // sample rate conversion fifo
+#define MO_SUB_STEP         0x310178 // subcarrier step size
+#define MO_SUB_STEP_DR      0x31017c // subcarrier step size for DR line
+
+#define MO_CAPTURE_CTRL     0x310180 // capture control
+#define MO_COLOR_CTRL       0x310184
+#define MO_VBI_PACKET       0x310188 // vbi packet size / delay
+#define MO_FIELD_COUNT      0x310190 // field counter
+#define MO_VIP_CONFIG       0x310194
+
+#define MO_AGC_BACK_VBI     0x310200
+#define MO_AGC_SYNC_TIP1    0x310208
+
+#define MO_VIDY_GPCNT       0x31C020 // {16}RO Video Y general purpose counter
+#define MO_VIDU_GPCNT       0x31C024 // {16}RO Video U general purpose counter
+#define MO_VIDV_GPCNT       0x31C028 // {16}RO Video V general purpose counter
+#define MO_VBI_GPCNT        0x31C02C // {16}RO VBI general purpose counter
+#define MO_VIDY_GPCNTRL     0x31C030 // {2}WO Video Y general purpose control
+#define MO_VIDU_GPCNTRL     0x31C034 // {2}WO Video U general purpose control
+#define MO_VIDV_GPCNTRL     0x31C038 // {2}WO Video V general purpose control
+#define MO_VBI_GPCNTRL      0x31C03C // {2}WO VBI general purpose counter
+#define MO_VID_DMACNTRL     0x31C040 // {8}RW Video DMA control
+#define MO_VID_XFR_STAT     0x31C044 // {1}RO Video transfer status
+
+
+/* ---------------------------------------------------------------------- */
+/* audio registers                                                        */
+
+#define MO_AUDD_DMA         0x320000 // {64}RWp Audio downstream
+#define MO_AUDU_DMA         0x320008 // {64}RWp Audio upstream
+#define MO_AUDR_DMA         0x320010 // {64}RWp Audio RDS (downstream)
+#define MO_AUDD_GPCNT       0x32C020 // {16}RO Audio down general purpose counter
+#define MO_AUDU_GPCNT       0x32C024 // {16}RO Audio up general purpose counter
+#define MO_AUDR_GPCNT       0x32C028 // {16}RO Audio RDS general purpose counter
+#define MO_AUDD_GPCNTRL     0x32C030 // {2}WO Audio down general purpose control
+#define MO_AUDU_GPCNTRL     0x32C034 // {2}WO Audio up general purpose control
+#define MO_AUDR_GPCNTRL     0x32C038 // {2}WO Audio RDS general purpose control
+#define MO_AUD_DMACNTRL     0x32C040 // {6}RW Audio DMA control
+#define MO_AUD_XFR_STAT     0x32C044 // {1}RO Audio transfer status
+#define MO_AUDD_LNGTH       0x32C048 // {12}RW Audio down line length
+#define MO_AUDR_LNGTH       0x32C04C // {12}RW Audio RDS line length
+
+#define AUD_INIT                 0x320100
+#define AUD_INIT_LD              0x320104
+#define AUD_SOFT_RESET           0x320108
+#define AUD_I2SINPUTCNTL         0x320120
+#define AUD_BAUDRATE             0x320124
+#define AUD_I2SOUTPUTCNTL        0x320128
+#define AAGC_HYST                0x320134
+#define AAGC_GAIN                0x320138
+#define AAGC_DEF                 0x32013c
+#define AUD_IIR1_0_SEL           0x320150
+#define AUD_IIR1_0_SHIFT         0x320154
+#define AUD_IIR1_1_SEL           0x320158
+#define AUD_IIR1_1_SHIFT         0x32015c
+#define AUD_IIR1_2_SEL           0x320160
+#define AUD_IIR1_2_SHIFT         0x320164
+#define AUD_IIR1_3_SEL           0x320168
+#define AUD_IIR1_3_SHIFT         0x32016c
+#define AUD_IIR1_4_SEL           0x320170
+#define AUD_IIR1_4_SHIFT         0x32017c
+#define AUD_IIR1_5_SEL           0x320180
+#define AUD_IIR1_5_SHIFT         0x320184
+#define AUD_IIR2_0_SEL           0x320190
+#define AUD_IIR2_0_SHIFT         0x320194
+#define AUD_IIR2_1_SEL           0x320198
+#define AUD_IIR2_1_SHIFT         0x32019c
+#define AUD_IIR2_2_SEL           0x3201a0
+#define AUD_IIR2_2_SHIFT         0x3201a4
+#define AUD_IIR2_3_SEL           0x3201a8
+#define AUD_IIR2_3_SHIFT         0x3201ac
+#define AUD_IIR3_0_SEL           0x3201c0
+#define AUD_IIR3_0_SHIFT         0x3201c4
+#define AUD_IIR3_1_SEL           0x3201c8
+#define AUD_IIR3_1_SHIFT         0x3201cc
+#define AUD_IIR3_2_SEL           0x3201d0
+#define AUD_IIR3_2_SHIFT         0x3201d4
+#define AUD_IIR4_0_SEL           0x3201e0
+#define AUD_IIR4_0_SHIFT         0x3201e4
+#define AUD_IIR4_1_SEL           0x3201e8
+#define AUD_IIR4_1_SHIFT         0x3201ec
+#define AUD_IIR4_2_SEL           0x3201f0
+#define AUD_IIR4_2_SHIFT         0x3201f4
+#define AUD_IIR4_0_CA0           0x320200
+#define AUD_IIR4_0_CA1           0x320204
+#define AUD_IIR4_0_CA2           0x320208
+#define AUD_IIR4_0_CB0           0x32020c
+#define AUD_IIR4_0_CB1           0x320210
+#define AUD_IIR4_1_CA0           0x320214
+#define AUD_IIR4_1_CA1           0x320218
+#define AUD_IIR4_1_CA2           0x32021c
+#define AUD_IIR4_1_CB0           0x320220
+#define AUD_IIR4_1_CB1           0x320224
+#define AUD_IIR4_2_CA0           0x320228
+#define AUD_IIR4_2_CA1           0x32022c
+#define AUD_IIR4_2_CA2           0x320230
+#define AUD_IIR4_2_CB0           0x320234
+#define AUD_IIR4_2_CB1           0x320238
+#define AUD_HP_MD_IIR4_1         0x320250
+#define AUD_HP_PROG_IIR4_1       0x320254
+#define AUD_FM_MODE_ENABLE       0x320258
+#define AUD_POLY0_DDS_CONSTANT   0x320270
+#define AUD_DN0_FREQ             0x320274
+#define AUD_DN1_FREQ             0x320278
+#define AUD_DN1_FREQ_SHIFT       0x32027c
+#define AUD_DN1_AFC              0x320280
+#define AUD_DN1_SRC_SEL          0x320284
+#define AUD_DN1_SHFT             0x320288
+#define AUD_DN2_FREQ             0x32028c
+#define AUD_DN2_FREQ_SHIFT       0x320290
+#define AUD_DN2_AFC              0x320294
+#define AUD_DN2_SRC_SEL          0x320298
+#define AUD_DN2_SHFT             0x32029c
+#define AUD_CRDC0_SRC_SEL        0x320300
+#define AUD_CRDC0_SHIFT          0x320304
+#define AUD_CORDIC_SHIFT_0       0x320308
+#define AUD_CRDC1_SRC_SEL        0x32030c
+#define AUD_CRDC1_SHIFT          0x320310
+#define AUD_CORDIC_SHIFT_1       0x320314
+#define AUD_DCOC_0_SRC           0x320320
+#define AUD_DCOC0_SHIFT          0x320324
+#define AUD_DCOC_0_SHIFT_IN0     0x320328
+#define AUD_DCOC_0_SHIFT_IN1     0x32032c
+#define AUD_DCOC_1_SRC           0x320330
+#define AUD_DCOC1_SHIFT          0x320334
+#define AUD_DCOC_1_SHIFT_IN0     0x320338
+#define AUD_DCOC_1_SHIFT_IN1     0x32033c
+#define AUD_DCOC_2_SRC           0x320340
+#define AUD_DCOC2_SHIFT          0x320344
+#define AUD_DCOC_2_SHIFT_IN0     0x320348
+#define AUD_DCOC_2_SHIFT_IN1     0x32034c
+#define AUD_DCOC_PASS_IN         0x320350
+#define AUD_PDET_SRC             0x320370
+#define AUD_PDET_SHIFT           0x320374
+#define AUD_PILOT_BQD_1_K0       0x320380
+#define AUD_PILOT_BQD_1_K1       0x320384
+#define AUD_PILOT_BQD_1_K2       0x320388
+#define AUD_PILOT_BQD_1_K3       0x32038c
+#define AUD_PILOT_BQD_1_K4       0x320390
+#define AUD_PILOT_BQD_2_K0       0x320394
+#define AUD_PILOT_BQD_2_K1       0x320398
+#define AUD_PILOT_BQD_2_K2       0x32039c
+#define AUD_PILOT_BQD_2_K3       0x3203a0
+#define AUD_PILOT_BQD_2_K4       0x3203a4
+#define AUD_THR_FR               0x3203c0
+#define AUD_X_PROG               0x3203c4
+#define AUD_Y_PROG               0x3203c8
+#define AUD_HARMONIC_MULT        0x3203cc
+#define AUD_C1_UP_THR            0x3203d0
+#define AUD_C1_LO_THR            0x3203d4
+#define AUD_C2_UP_THR            0x3203d8
+#define AUD_C2_LO_THR            0x3203dc
+#define AUD_PLL_EN               0x320400
+#define AUD_PLL_SRC              0x320404
+#define AUD_PLL_SHIFT            0x320408
+#define AUD_PLL_IF_SEL           0x32040c
+#define AUD_PLL_IF_SHIFT         0x320410
+#define AUD_BIQUAD_PLL_K0        0x320414
+#define AUD_BIQUAD_PLL_K1        0x320418
+#define AUD_BIQUAD_PLL_K2        0x32041c
+#define AUD_BIQUAD_PLL_K3        0x320420
+#define AUD_BIQUAD_PLL_K4        0x320424
+#define AUD_DEEMPH0_SRC_SEL      0x320440
+#define AUD_DEEMPH0_SHIFT        0x320444
+#define AUD_DEEMPH0_G0           0x320448
+#define AUD_DEEMPH0_A0           0x32044c
+#define AUD_DEEMPH0_B0           0x320450
+#define AUD_DEEMPH0_A1           0x320454
+#define AUD_DEEMPH0_B1           0x320458
+#define AUD_DEEMPH1_SRC_SEL      0x32045c
+#define AUD_DEEMPH1_SHIFT        0x320460
+#define AUD_DEEMPH1_G0           0x320464
+#define AUD_DEEMPH1_A0           0x320468
+#define AUD_DEEMPH1_B0           0x32046c
+#define AUD_DEEMPH1_A1           0x320470
+#define AUD_DEEMPH1_B1           0x320474
+#define AUD_OUT0_SEL             0x320490
+#define AUD_OUT0_SHIFT           0x320494
+#define AUD_OUT1_SEL             0x320498
+#define AUD_OUT1_SHIFT           0x32049c
+#define AUD_RDSI_SEL             0x3204a0
+#define AUD_RDSI_SHIFT           0x3204a4
+#define AUD_RDSQ_SEL             0x3204a8
+#define AUD_RDSQ_SHIFT           0x3204ac
+#define AUD_DBX_IN_GAIN          0x320500
+#define AUD_DBX_WBE_GAIN         0x320504
+#define AUD_DBX_SE_GAIN          0x320508
+#define AUD_DBX_RMS_WBE          0x32050c
+#define AUD_DBX_RMS_SE           0x320510
+#define AUD_DBX_SE_BYPASS        0x320514
+#define AUD_FAWDETCTL            0x320530
+#define AUD_FAWDETWINCTL         0x320534
+#define AUD_DEEMPHGAIN_R         0x320538
+#define AUD_DEEMPHNUMER1_R       0x32053c
+#define AUD_DEEMPHNUMER2_R       0x320540
+#define AUD_DEEMPHDENOM1_R       0x320544
+#define AUD_DEEMPHDENOM2_R       0x320548
+#define AUD_ERRLOGPERIOD_R       0x32054c
+#define AUD_ERRINTRPTTHSHLD1_R   0x320550
+#define AUD_ERRINTRPTTHSHLD2_R   0x320554
+#define AUD_ERRINTRPTTHSHLD3_R   0x320558
+#define AUD_NICAM_STATUS1        0x32055c
+#define AUD_NICAM_STATUS2        0x320560
+#define AUD_ERRLOG1              0x320564
+#define AUD_ERRLOG2              0x320568
+#define AUD_ERRLOG3              0x32056c
+#define AUD_DAC_BYPASS_L         0x320580
+#define AUD_DAC_BYPASS_R         0x320584
+#define AUD_DAC_BYPASS_CTL       0x320588
+#define AUD_CTL                  0x32058c
+#define AUD_STATUS               0x320590
+#define AUD_VOL_CTL              0x320594
+#define AUD_BAL_CTL              0x320598
+#define AUD_START_TIMER          0x3205b0
+#define AUD_MODE_CHG_TIMER       0x3205b4
+#define AUD_POLYPH80SCALEFAC     0x3205b8
+#define AUD_DMD_RA_DDS           0x3205bc
+#define AUD_I2S_RA_DDS           0x3205c0
+#define AUD_RATE_THRES_DMD       0x3205d0
+#define AUD_RATE_THRES_I2S       0x3205d4
+#define AUD_RATE_ADJ1            0x3205d8
+#define AUD_RATE_ADJ2            0x3205dc
+#define AUD_RATE_ADJ3            0x3205e0
+#define AUD_RATE_ADJ4            0x3205e4
+#define AUD_RATE_ADJ5            0x3205e8
+#define AUD_APB_IN_RATE_ADJ      0x3205ec
+#define AUD_PHASE_FIX_CTL        0x3205f0
+#define AUD_PLL_PRESCALE         0x320600
+#define AUD_PLL_DDS              0x320604
+#define AUD_PLL_INT              0x320608
+#define AUD_PLL_FRAC             0x32060c
+#define AUD_PLL_JTAG             0x320620
+#define AUD_PLL_SPMP             0x320624
+#define AUD_AFE_12DB_EN          0x320628
+
+// Audio QAM Register Addresses
+#define AUD_PDF_DDS_CNST_BYTE2   0x320d01
+#define AUD_PDF_DDS_CNST_BYTE1   0x320d02
+#define AUD_PDF_DDS_CNST_BYTE0   0x320d03
+#define AUD_PHACC_FREQ_8MSB      0x320d2a
+#define AUD_PHACC_FREQ_8LSB      0x320d23
+#define AUD_QAM_MODE             0x320d04
+
+
+/* ---------------------------------------------------------------------- */
+/* transport stream registers                                             */
+
+#define MO_TS_DMA           0x330000 // {64}RWp Transport stream downstream
+#define MO_TS_GPCNT         0x33C020 // {16}RO TS general purpose counter
+#define MO_TS_GPCNTRL       0x33C030 // {2}WO TS general purpose control
+#define MO_TS_DMACNTRL      0x33C040 // {6}RW TS DMA control
+#define MO_TS_XFR_STAT      0x33C044 // {1}RO TS transfer status
+#define MO_TS_LNGTH         0x33C048 // {12}RW TS line length
+
+#define TS_HW_SOP_CNTRL     0x33C04C
+#define TS_GEN_CNTRL        0x33C050
+#define TS_BD_PKT_STAT      0x33C054
+#define TS_SOP_STAT         0x33C058
+#define TS_FIFO_OVFL_STAT   0x33C05C
+#define TS_VALERR_CNTRL     0x33C060
+
+
+/* ---------------------------------------------------------------------- */
+/* VIP registers                                                          */
+
+#define MO_VIPD_DMA         0x340000 // {64}RWp VIP downstream
+#define MO_VIPU_DMA         0x340008 // {64}RWp VIP upstream
+#define MO_VIPD_GPCNT       0x34C020 // {16}RO VIP down general purpose counter
+#define MO_VIPU_GPCNT       0x34C024 // {16}RO VIP up general purpose counter
+#define MO_VIPD_GPCNTRL     0x34C030 // {2}WO VIP down general purpose control
+#define MO_VIPU_GPCNTRL     0x34C034 // {2}WO VIP up general purpose control
+#define MO_VIP_DMACNTRL     0x34C040 // {6}RW VIP DMA control
+#define MO_VIP_XFR_STAT     0x34C044 // {1}RO VIP transfer status
+#define MO_VIP_CFG          0x340048 // VIP configuration
+#define MO_VIPU_CNTRL       0x34004C // VIP upstream control #1
+#define MO_VIPD_CNTRL       0x340050 // VIP downstream control #2
+#define MO_VIPD_LNGTH       0x340054 // VIP downstream line length
+#define MO_VIP_BRSTLN       0x340058 // VIP burst length
+#define MO_VIP_INTCNTRL     0x34C05C // VIP Interrupt Control
+#define MO_VIP_XFTERM       0x340060 // VIP transfer terminate
+
+
+/* ---------------------------------------------------------------------- */
+/* misc registers                                                         */
+
+#define MO_M2M_DMA          0x350000 // {64}RWp Mem2Mem DMA Bfr
+#define MO_GP0_IO           0x350010 // {32}RW* GPIOoutput enablesdata I/O
+#define MO_GP1_IO           0x350014 // {32}RW* GPIOoutput enablesdata I/O
+#define MO_GP2_IO           0x350018 // {32}RW* GPIOoutput enablesdata I/O
+#define MO_GP3_IO           0x35001C // {32}RW* GPIO Mode/Ctrloutput enables
+#define MO_GPIO             0x350020 // {32}RW* GPIO I2C Ctrldata I/O
+#define MO_GPOE             0x350024 // {32}RW  GPIO I2C Ctrloutput enables
+#define MO_GP_ISM           0x350028 // {16}WO  GPIO Intr Sens/Pol
+
+#define MO_PLL_B            0x35C008 // {32}RW* PLL Control for ASB bus clks
+#define MO_M2M_CNT          0x35C024 // {32}RW  Mem2Mem DMA Cnt
+#define MO_M2M_XSUM         0x35C028 // {32}RO  M2M XOR-Checksum
+#define MO_CRC              0x35C02C // {16}RW  CRC16 init/result
+#define MO_CRC_D            0x35C030 // {32}WO  CRC16 new data in
+#define MO_TM_CNT_LDW       0x35C034 // {32}RO  Timer : Counter low dword
+#define MO_TM_CNT_UW        0x35C038 // {16}RO  Timer : Counter high word
+#define MO_TM_LMT_LDW       0x35C03C // {32}RW  Timer : Limit low dword
+#define MO_TM_LMT_UW        0x35C040 // {32}RW  Timer : Limit high word
+#define MO_PINMUX_IO        0x35C044 // {8}RW  Pin Mux Control
+#define MO_TSTSEL_IO        0x35C048 // {2}RW  Pin Mux Control
+#define MO_AFECFG_IO        0x35C04C // AFE configuration reg
+#define MO_DDS_IO           0x35C050 // DDS Increment reg
+#define MO_DDSCFG_IO        0x35C054 // DDS Configuration reg
+#define MO_SAMPLE_IO        0x35C058 // IRIn sample reg
+#define MO_SRST_IO          0x35C05C // Output system reset reg
+
+#define MO_INT1_MSK         0x35C060 // DMA RISC interrupt mask
+#define MO_INT1_STAT        0x35C064 // DMA RISC interrupt status
+#define MO_INT1_MSTAT       0x35C068 // DMA RISC interrupt masked status
+
+
+/* ---------------------------------------------------------------------- */
+/* i2c bus registers                                                      */
+
+#define MO_I2C              0x368000 // I2C data/control
+#define MO_I2C_DIV          (0xf<<4)
+#define MO_I2C_SYNC         (1<<3)
+#define MO_I2C_W3B          (1<<2)
+#define MO_I2C_SCL          (1<<1)
+#define MO_I2C_SDA          (1<<0)
+
+
+/* ---------------------------------------------------------------------- */
+/* general purpose host registers                                         */
+/* FIXME: tyops?  s/0x35/0x38/ ??                                         */
+
+#define MO_GPHSTD_DMA       0x350000 // {64}RWp Host downstream
+#define MO_GPHSTU_DMA       0x350008 // {64}RWp Host upstream
+#define MO_GPHSTD_GPCNT     0x35C020 // Host down general purpose counter
+#define MO_GPHSTU_GPCNT     0x35C024 // Host up general purpose counter
+#define MO_GPHSTD_GPCNTRL   0x38C030 // Host down general purpose control
+#define MO_GPHSTU_GPCNTRL   0x38C034 // Host up general purpose control
+#define MO_GPHST_DMACNTRL   0x38C040 // Host DMA control
+#define MO_GPHST_XFR_STAT   0x38C044 // Host transfer status
+#define MO_GPHSTU_CNTRL     0x380048 // Host upstream control #1
+#define MO_GPHSTD_CNTRL     0x38004C // Host downstream control #2
+#define MO_GPHSTD_LNGTH     0x380050 // Host downstream line length
+#define MO_GPHST_WSC        0x380054 // Host wait state control
+#define MO_GPHST_XFR        0x380058 // Host transfer control
+#define MO_GPHST_WDTH       0x38005C // Host interface width
+#define MO_GPHST_HDSHK      0x380060 // Host peripheral handshake
+#define MO_GPHST_MUX16      0x380064 // Host muxed 16-bit transfer parameters
+#define MO_GPHST_MODE       0x380068 // Host mode select
+
+
+/* ---------------------------------------------------------------------- */
+/* RISC instructions                                                      */
+
+#define RISC_SYNC		 0x80000000
+#define RISC_SYNC_ODD		 0x80000000
+#define RISC_SYNC_EVEN		 0x80000200
+#define RISC_RESYNC		 0x80008000
+#define RISC_RESYNC_ODD		 0x80008000
+#define RISC_RESYNC_EVEN	 0x80008200
+#define RISC_WRITE		 0x10000000
+#define RISC_WRITEC		 0x50000000
+#define RISC_READ		 0x90000000
+#define RISC_READC		 0xA0000000
+#define RISC_JUMP		 0x70000000
+#define RISC_SKIP		 0x20000000
+#define RISC_WRITERM		 0xB0000000
+#define RISC_WRITECM		 0xC0000000
+#define RISC_WRITECR		 0xD0000000
+#define RISC_IMM		 0x00000001
+
+#define RISC_SOL		 0x08000000
+#define RISC_EOL		 0x04000000
+
+#define RISC_IRQ2		 0x02000000
+#define RISC_IRQ1		 0x01000000
+
+#define RISC_CNT_NONE		 0x00000000
+#define RISC_CNT_INC		 0x00010000
+#define RISC_CNT_RSVR		 0x00020000
+#define RISC_CNT_RESET		 0x00030000
+#define RISC_JMP_SRP         	 0x01
+
+
+/* ---------------------------------------------------------------------- */
+/* various constants                                                      */
+
+#define SEL_BTSC     0x01 
+#define SEL_EIAJ     0x02 
+#define SEL_A2       0x04 
+#define SEL_SAP      0x08
+#define SEL_NICAM    0x10 
+#define SEL_FMRADIO  0x20
+
+// AUD_CTL
+#define EN_BTSC_FORCE_MONO      0
+#define EN_BTSC_FORCE_STEREO    1
+#define EN_BTSC_FORCE_SAP       2
+#define EN_BTSC_AUTO_STEREO     3
+#define EN_BTSC_AUTO_SAP        4
+
+#define EN_A2_FORCE_MONO1       8
+#define EN_A2_FORCE_MONO2       9
+#define EN_A2_FORCE_STEREO      10
+#define EN_A2_AUTO_MONO2        11
+#define EN_A2_AUTO_STEREO       12
+
+#define EN_EIAJ_FORCE_MONO1     16
+#define EN_EIAJ_FORCE_MONO2     17
+#define EN_EIAJ_FORCE_STEREO    18
+#define EN_EIAJ_AUTO_MONO2      19
+#define EN_EIAJ_AUTO_STEREO     20
+
+#define EN_NICAM_FORCE_MONO1    32
+#define EN_NICAM_FORCE_MONO2    33
+#define EN_NICAM_FORCE_STEREO   34
+#define EN_NICAM_AUTO_MONO2     35
+#define EN_NICAM_AUTO_STEREO    36
+
+#define EN_FMRADIO_FORCE_MONO   24
+#define EN_FMRADIO_FORCE_STEREO 25
+#define EN_FMRADIO_AUTO_STEREO  26
+
+#define EN_NICAM_AUTO_FALLBACK  0x00000040
+#define EN_FMRADIO_EN_RDS       0x00000200
+#define EN_NICAM_TRY_AGAIN_BIT  0x00000400
+#define EN_DAC_ENABLE           0x00001000
+#define EN_I2SOUT_ENABLE        0x00002000
+#define EN_I2SIN_STR2DAC        0x00004000
+#define EN_I2SIN_ENABLE         0x00008000
+
+#define EN_DMTRX_SUMDIFF        0x00000800
+#define EN_DMTRX_SUMR           0x00000880
+#define EN_DMTRX_LR             0x00000900
+#define EN_DMTRX_MONO           0x00000980
+
+// Video 
+#define VID_CAPTURE_CONTROL		0x310180
+
+#define CX23880_CAP_CTL_CAPTURE_VBI_ODD  (1<<3)
+#define CX23880_CAP_CTL_CAPTURE_VBI_EVEN (1<<2)
+#define CX23880_CAP_CTL_CAPTURE_ODD      (1<<1)
+#define CX23880_CAP_CTL_CAPTURE_EVEN     (1<<0)
+
+#define VideoInputMux0		 0x0
+#define VideoInputMux1		 0x1
+#define VideoInputMux2		 0x2
+#define VideoInputMux3		 0x3
+#define VideoInputTuner		 0x0 
+#define VideoInputComposite	 0x1 
+#define VideoInputSVideo	 0x2
+#define VideoInputOther		 0x3 
+
+#define Xtal0		 0x1
+#define Xtal1		 0x2
+#define XtalAuto	 0x3
+
+#define VideoFormatAuto		 0x0
+#define VideoFormatNTSC		 0x1
+#define VideoFormatNTSCJapan	 0x2
+#define VideoFormatNTSC443	 0x3
+#define VideoFormatPAL		 0x4
+#define VideoFormatPALB		 0x4 
+#define VideoFormatPALD		 0x4 
+#define VideoFormatPALG		 0x4 
+#define VideoFormatPALH		 0x4 
+#define VideoFormatPALI		 0x4 
+#define VideoFormatPALBDGHI	 0x4 
+#define VideoFormatPALM		 0x5
+#define VideoFormatPALN		 0x6
+#define VideoFormatPALNC	 0x7
+#define VideoFormatPAL60	 0x8
+#define VideoFormatSECAM	 0x9
+
+#define VideoFormatAuto27MHz		 0x10
+#define VideoFormatNTSC27MHz		 0x11
+#define VideoFormatNTSCJapan27MHz	 0x12
+#define VideoFormatNTSC44327MHz		 0x13
+#define VideoFormatPAL27MHz		 0x14
+#define VideoFormatPALB27MHz		 0x14 
+#define VideoFormatPALD27MHz		 0x14 
+#define VideoFormatPALG27MHz		 0x14 
+#define VideoFormatPALH27MHz		 0x14 
+#define VideoFormatPALI27MHz		 0x14 
+#define VideoFormatPALBDGHI27MHz	 0x14 
+#define VideoFormatPALM27MHz		 0x15
+#define VideoFormatPALN27MHz		 0x16
+#define VideoFormatPALNC27MHz		 0x17
+#define VideoFormatPAL6027MHz		 0x18
+#define VideoFormatSECAM27MHz		 0x19
+
+#define NominalUSECAM	 0x87
+#define NominalVSECAM	 0x85
+#define NominalUNTSC	 0xFE
+#define NominalVNTSC	 0xB4
+
+#define NominalContrast  0xD8
+
+#define HFilterAutoFormat	 0x0
+#define HFilterCIF		 0x1
+#define HFilterQCIF		 0x2
+#define HFilterICON		 0x3
+
+#define VFilter2TapInterpolate  0
+#define VFilter3TapInterpolate  1
+#define VFilter4TapInterpolate  2
+#define VFilter5TapInterpolate  3
+#define VFilter2TapNoInterpolate  4
+#define VFilter3TapNoInterpolate  5
+#define VFilter4TapNoInterpolate  6
+#define VFilter5TapNoInterpolate  7
+
+#define ColorFormatRGB32	 0x0000
+#define ColorFormatRGB24	 0x0011
+#define ColorFormatRGB16	 0x0022
+#define ColorFormatRGB15	 0x0033
+#define ColorFormatYUY2		 0x0044
+#define ColorFormatBTYUV	 0x0055
+#define ColorFormatY8		 0x0066
+#define ColorFormatRGB8		 0x0077
+#define ColorFormatPL422	 0x0088
+#define ColorFormatPL411	 0x0099
+#define ColorFormatYUV12	 0x00AA
+#define ColorFormatYUV9		 0x00BB
+#define ColorFormatRAW		 0x00EE
+#define ColorFormatBSWAP         0x0300
+#define ColorFormatWSWAP         0x0c00
+#define ColorFormatEvenMask      0x050f
+#define ColorFormatOddMask       0x0af0
+#define ColorFormatGamma         0x1000
+
+#define Interlaced		 0x1
+#define NonInterlaced	 	 0x0
+
+#define FieldEven		 0x1
+#define FieldOdd		 0x0
+
+#define TGReadWriteMode	 	 0x0
+#define TGEnableMode	 	 0x1
+
+#define DV_CbAlign		 0x0
+#define DV_Y0Align		 0x1
+#define DV_CrAlign		 0x2
+#define DV_Y1Align		 0x3
+
+#define DVF_Analog		 0x0
+#define DVF_CCIR656		 0x1
+#define DVF_ByteStream		 0x2
+#define DVF_ExtVSYNC		 0x4
+#define DVF_ExtField		 0x5
+
+#define CHANNEL_VID_Y		 0x1
+#define CHANNEL_VID_U		 0x2
+#define CHANNEL_VID_V		 0x3
+#define CHANNEL_VID_VBI		 0x4
+#define CHANNEL_AUD_DN		 0x5
+#define CHANNEL_AUD_UP		 0x6
+#define CHANNEL_AUD_RDS_DN	 0x7
+#define CHANNEL_MPEG_DN		 0x8
+#define CHANNEL_VIP_DN		 0x9
+#define CHANNEL_VIP_UP		 0xA
+#define CHANNEL_HOST_DN		 0xB
+#define CHANNEL_HOST_UP		 0xC
+#define CHANNEL_FIRST		 0x1 
+#define CHANNEL_LAST		 0xC 
+
+#define GP_COUNT_CONTROL_NONE		 0x0
+#define GP_COUNT_CONTROL_INC		 0x1
+#define GP_COUNT_CONTROL_RESERVED	 0x2
+#define GP_COUNT_CONTROL_RESET		 0x3
+
+#define PLL_PRESCALE_BY_2  2
+#define PLL_PRESCALE_BY_3  3
+#define PLL_PRESCALE_BY_4  4
+#define PLL_PRESCALE_BY_5  5
+
+#define HLNotchFilter4xFsc	 0
+#define HLNotchFilterSquare	 1
+#define HLNotchFilter135NTSC	 2
+#define HLNotchFilter135PAL	 3
+
+#define NTSC_8x_SUB_CARRIER  28.63636E6
+#define PAL_8x_SUB_CARRIER  35.46895E6
+
+// Default analog settings
+#define DEFAULT_HUE_NTSC			0x00
+#define DEFAULT_BRIGHTNESS_NTSC			0x00
+#define DEFAULT_CONTRAST_NTSC			0x39
+#define DEFAULT_SAT_U_NTSC			0x7F
+#define DEFAULT_SAT_V_NTSC			0x5A
+
+typedef enum                                                                          
+{                                                                                     
+	SOURCE_TUNER = 0,                                                             
+	SOURCE_COMPOSITE,                                                             
+	SOURCE_SVIDEO,                                                                
+	SOURCE_OTHER1,                                                                
+	SOURCE_OTHER2,                                                                
+	SOURCE_COMPVIASVIDEO,                                                         
+	SOURCE_CCIR656                                                                    
+} VIDEOSOURCETYPE;
+
+#endif /* _CX88_REG_H_ */
diff -u linux-2.6.1/drivers/media/video/cx88/cx88-tvaudio.c linux/drivers/media/video/cx88/cx88-tvaudio.c
--- linux-2.6.1/drivers/media/video/cx88/cx88-tvaudio.c	2004-01-14 14:36:15.463000600 +0100
+++ linux/drivers/media/video/cx88/cx88-tvaudio.c	2004-01-14 14:36:15.463000600 +0100
@@ -0,0 +1,472 @@
+/*
+    cx88x-audio.c - Conexant CX23880/23881 audio downstream driver driver
+
+     (c) 2001 Michael Eskin, Tom Zakrajsek [Windows version]
+     (c) 2002 Yurij Sysoev <yurij@naturesoft.net>
+     (c) 2003 Gerd Knorr <kraxel@bytesex.org>
+
+    -----------------------------------------------------------------------
+
+    Lot of voodoo here.  Even the data sheet doesn't help to
+    understand what is going on here, the documentation for the audio
+    part of the cx2388x chip is *very* bad.
+
+    Some of this comes from party done linux driver sources I got from
+    [undocumented].
+
+    Some comes from the dscaler sources, the dscaler driver guy works
+    for Conexant ...
+    
+    -----------------------------------------------------------------------
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/poll.h>
+#include <linux/pci.h>
+#include <linux/signal.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/vmalloc.h>
+#include <linux/init.h>
+
+#include "cx88.h"
+
+static unsigned int audio_debug = UNSET;
+MODULE_PARM(audio_debug,"i");
+MODULE_PARM_DESC(audio_debug,"enable debug messages [audio]");
+
+#define dprintk(fmt, arg...)	if (audio_debug) \
+	printk(KERN_DEBUG "%s: " fmt, dev->name , ## arg)
+
+/* ----------------------------------------------------------- */
+
+struct rlist {
+	u32 reg;
+	u32 val;
+};
+
+static void set_audio_registers(struct cx8800_dev *dev,
+				const struct rlist *l)
+{
+	int i;
+
+	for (i = 0; l[i].reg; i++)
+		cx_write(l[i].reg, l[i].val);
+}
+
+static void set_audio_standard_BTSC(struct cx8800_dev *dev, unsigned int sap)
+{
+	dprintk("set_audio_standard_BTSC() [TODO]\n");
+}
+
+static void set_audio_standard_NICAM(struct cx8800_dev *dev)
+{
+	static const struct rlist nicam[] = {
+		//  increase level of input by 12dB
+		{ AUD_AFE_12DB_EN,         0x00000001 },
+
+    		// initialize NICAM                 
+    		{ AUD_INIT,                0x00000010 },
+    		{ AUD_INIT_LD,             0x00000001 },
+    		{ AUD_SOFT_RESET,          0x00000001 },
+    
+   		// WARNING!!!! Stereo mode is FORCED!!!!
+    		{ AUD_CTL,                 EN_DAC_ENABLE | EN_DMTRX_LR | EN_NICAM_FORCE_STEREO },
+    
+    		{ AUD_SOFT_RESET,          0x00000001 },
+    		{ AUD_RATE_ADJ1,           0x00000010 },
+    		{ AUD_RATE_ADJ2,           0x00000040 },
+    		{ AUD_RATE_ADJ3,           0x00000100 },
+    		{ AUD_RATE_ADJ4,           0x00000400 },
+    		{ AUD_RATE_ADJ5,           0x00001000 },
+    //		{ AUD_DMD_RA_DDS,          0x00c0d5ce },
+
+                { /* end of list */ },
+        };
+
+        printk("set_audio_standard_NICAM()\n");
+        set_audio_registers(dev, nicam);
+
+    	// setup QAM registers
+    	cx_write(0x320d01,                0x06);
+    	cx_write(0x320d02,                0x82);
+    	cx_write(0x320d03,                0x16);
+    	cx_write(0x320d04,                0x05);
+    	cx_write(0x320d2a,                0x34);
+    	cx_write(0x320d2b,                0x4c);
+
+    	// setup Audio PLL
+    	//cx_write(AUD_PLL_PRESCALE,        0x0002);
+    	//cx_write(AUD_PLL_INT,             0x001f);
+
+    	// de-assert Audio soft reset
+    	cx_write(AUD_SOFT_RESET,          0x00000000);  // Causes a pop every time
+}
+
+static void set_audio_standard_A2(struct cx8800_dev *dev)
+{
+	static const struct rlist a2[] = {
+		//  increase level of input by 12dB
+		{ AUD_AFE_12DB_EN,         0x00000001 },
+
+		//  initialize A2
+		{ AUD_INIT,                0x00000004 },
+		{ AUD_INIT_LD,             0x00000001 },
+		{ AUD_SOFT_RESET,          0x00000001 },
+    
+		// ; WARNING!!! A2 STEREO DEMATRIX HAS TO BE
+		// ; SET MANUALLY!!!  Value sould be 0x100c
+		{ AUD_CTL, EN_DAC_ENABLE | EN_DMTRX_SUMR | EN_A2_AUTO_STEREO },
+
+		{ AUD_DN0_FREQ,            0x0000312b },
+		{ AUD_POLY0_DDS_CONSTANT,  0x000a62b4 },
+		{ AUD_IIR1_0_SEL,          0x00000000 },
+		{ AUD_IIR1_1_SEL,          0x00000001 },
+		{ AUD_IIR1_2_SEL,          0x0000001f },
+		{ AUD_IIR1_3_SEL,          0x00000020 },
+		{ AUD_IIR1_4_SEL,          0x00000023 },
+		{ AUD_IIR1_5_SEL,          0x00000007 },
+		{ AUD_IIR1_0_SHIFT,        0x00000000 },
+		{ AUD_IIR1_1_SHIFT,        0x00000000 },
+		{ AUD_IIR1_2_SHIFT,        0x00000007 },
+		{ AUD_IIR1_3_SHIFT,        0x00000007 },
+		{ AUD_IIR1_4_SHIFT,        0x00000007 },
+		{ AUD_IIR1_5_SHIFT,        0x00000000 },
+		{ AUD_IIR2_0_SEL,          0x00000002 },
+		{ AUD_IIR2_1_SEL,          0x00000003 },
+		{ AUD_IIR2_2_SEL,          0x00000004 },
+		{ AUD_IIR2_3_SEL,          0x00000005 },
+		{ AUD_IIR3_0_SEL,          0x00000021 },
+		{ AUD_IIR3_1_SEL,          0x00000023 },
+		{ AUD_IIR3_2_SEL,          0x00000016 },
+		{ AUD_IIR3_0_SHIFT,        0x00000000 },
+		{ AUD_IIR3_1_SHIFT,        0x00000000 },
+		{ AUD_IIR3_2_SHIFT,        0x00000000 },
+		{ AUD_IIR4_0_SEL,          0x0000001d },
+		{ AUD_IIR4_1_SEL,          0x00000019 },
+		{ AUD_IIR4_2_SEL,          0x00000008 },
+		{ AUD_IIR4_0_SHIFT,        0x00000000 },
+		{ AUD_IIR4_1_SHIFT,        0x00000000 },
+		{ AUD_IIR4_2_SHIFT,        0x00000001 },
+		{ AUD_IIR4_0_CA0,          0x0003e57e },
+		{ AUD_IIR4_0_CA1,          0x00005e11 },
+		{ AUD_IIR4_0_CA2,          0x0003a7cf },
+		{ AUD_IIR4_0_CB0,          0x00002368 },
+		{ AUD_IIR4_0_CB1,          0x0003bf1b },
+		{ AUD_IIR4_1_CA0,          0x00006349 },
+		{ AUD_IIR4_1_CA1,          0x00006f27 },
+		{ AUD_IIR4_1_CA2,          0x0000e7a3 },
+		{ AUD_IIR4_1_CB0,          0x00005653 },
+		{ AUD_IIR4_1_CB1,          0x0000cf97 },
+		{ AUD_IIR4_2_CA0,          0x00006349 },
+		{ AUD_IIR4_2_CA1,          0x00006f27 },
+		{ AUD_IIR4_2_CA2,          0x0000e7a3 },
+		{ AUD_IIR4_2_CB0,          0x00005653 },
+		{ AUD_IIR4_2_CB1,          0x0000cf97 },
+		{ AUD_HP_MD_IIR4_1,        0x00000001 },
+		{ AUD_HP_PROG_IIR4_1,      0x00000017 },
+		{ AUD_DN1_FREQ,            0x00003618 },
+		{ AUD_DN1_SRC_SEL,         0x00000017 },
+		{ AUD_DN1_SHFT,            0x00000007 },
+		{ AUD_DN1_AFC,             0x00000000 },
+		{ AUD_DN1_FREQ_SHIFT,      0x00000000 },
+		{ AUD_DN2_SRC_SEL,         0x00000040 },
+		{ AUD_DN2_SHFT,            0x00000000 },
+		{ AUD_DN2_AFC,             0x00000002 },
+		{ AUD_DN2_FREQ,            0x0000caaf },
+		{ AUD_DN2_FREQ_SHIFT,      0x00000000 },
+		{ AUD_PDET_SRC,            0x00000014 },
+		{ AUD_PDET_SHIFT,          0x00000000 },
+		{ AUD_DEEMPH0_SRC_SEL,     0x00000011 },
+		{ AUD_DEEMPH1_SRC_SEL,     0x00000013 },
+		{ AUD_DEEMPH0_SHIFT,       0x00000000 },
+		{ AUD_DEEMPH1_SHIFT,       0x00000000 },
+		{ AUD_DEEMPH0_G0,          0x000004da },
+		{ AUD_DEEMPH0_A0,          0x0000777a },
+		{ AUD_DEEMPH0_B0,          0x00000000 },
+		{ AUD_DEEMPH0_A1,          0x0003f062 },
+		{ AUD_DEEMPH0_B1,          0x00000000 },
+		{ AUD_DEEMPH1_G0,          0x000004da },
+		{ AUD_DEEMPH1_A0,          0x0000777a },
+		{ AUD_DEEMPH1_B0,          0x00000000 },
+		{ AUD_DEEMPH1_A1,          0x0003f062 },
+		{ AUD_DEEMPH1_B1,          0x00000000 },
+		{ AUD_PLL_EN,              0x00000000 },
+		{ AUD_DMD_RA_DDS,          0x002a4efb },
+		{ AUD_RATE_ADJ1,           0x00001000 },
+		{ AUD_RATE_ADJ2,           0x00002000 },
+		{ AUD_RATE_ADJ3,           0x00003000 },
+		{ AUD_RATE_ADJ4,           0x00004000 },
+		{ AUD_RATE_ADJ5,           0x00005000 },
+		{ AUD_C2_UP_THR,           0x0000ffff },
+		{ AUD_C2_LO_THR,           0x0000e800 },
+		{ AUD_C1_UP_THR,           0x00008c00 },
+		{ AUD_C1_LO_THR,           0x00006c00 },
+
+		//   ; Completely ditch AFC feedback
+		{ AUD_DCOC_0_SRC,          0x00000021 },
+		{ AUD_DCOC_1_SRC,          0x0000001a },
+		{ AUD_DCOC1_SHIFT,         0x00000000 },
+		{ AUD_DCOC_1_SHIFT_IN0,    0x0000000a },
+		{ AUD_DCOC_1_SHIFT_IN1,    0x00000008 },
+		{ AUD_DCOC_PASS_IN,        0x00000000 },
+		{ AUD_IIR4_0_SEL,          0x00000023 },
+
+		//  ; Completely ditc FM-2 AFC feedback
+		{ AUD_DN1_AFC,             0x00000000 },
+		{ AUD_DCOC_2_SRC,          0x0000001b },
+		{ AUD_IIR4_1_SEL,          0x00000025 },
+
+		// ; WARNING!!! THIS CHANGE WAS NOT EXPECTED!!!
+		// ; Swap I & Q inputs into second rotator
+		// ; to reverse frequency and therefor invert
+		// ; phase from the cordic FM demodulator
+		// ; (frequency rotation must also be reversed
+		{ AUD_DN2_SRC_SEL,         0x00000001 },
+		{ AUD_DN2_FREQ,            0x00003551 },
+
+
+		//  setup Audio PLL
+		{ AUD_PLL_PRESCALE,        0x00000002 },
+		{ AUD_PLL_INT,             0x0000001f },
+
+		//  de-assert Audio soft reset
+		{ AUD_SOFT_RESET,          0x00000000 },
+
+		{ /* end of list */ },
+	};
+
+	dprintk("set_audio_standard_A2()\n");
+	set_audio_registers(dev, a2);
+}
+
+static void set_audio_standard_EIAJ(struct cx8800_dev *dev)
+{
+	dprintk("set_audio_standard_EIAJ() [TODO]\n");
+}
+
+static void set_audio_standard_FM(struct cx8800_dev *dev)
+{
+	dprintk("set_audio_standard_FM\n");
+
+	// initialize FM Radio
+	cx_write(AUD_INIT,0x0020);
+	cx_write(AUD_INIT_LD,0x0001);
+	cx_write(AUD_SOFT_RESET,0x0001);
+
+#if 0 /* FIXME */
+	switch (dev->audio_properties.FM_deemphasis)
+	{
+		case WW_FM_DEEMPH_50:
+			//Set De-emphasis filter coefficients for 50 usec
+			cx_write(AUD_DEEMPH0_G0, 0x0C45);
+			cx_write(AUD_DEEMPH0_A0, 0x6262);
+			cx_write(AUD_DEEMPH0_B0, 0x1C29);
+			cx_write(AUD_DEEMPH0_A1, 0x3FC66);
+			cx_write(AUD_DEEMPH0_B1, 0x399A);
+
+			cx_write(AUD_DEEMPH1_G0, 0x0D80);
+			cx_write(AUD_DEEMPH1_A0, 0x6262);
+			cx_write(AUD_DEEMPH1_B0, 0x1C29);
+			cx_write(AUD_DEEMPH1_A1, 0x3FC66);
+			cx_write(AUD_DEEMPH1_B1, 0x399A);
+			
+			break;
+
+		case WW_FM_DEEMPH_75:
+			//Set De-emphasis filter coefficients for 75 usec
+			cx_write(AUD_DEEMPH0_G0, 0x91B );
+			cx_write(AUD_DEEMPH0_A0, 0x6B68);
+			cx_write(AUD_DEEMPH0_B0, 0x11EC);
+			cx_write(AUD_DEEMPH0_A1, 0x3FC66);
+			cx_write(AUD_DEEMPH0_B1, 0x399A);
+
+			cx_write(AUD_DEEMPH1_G0, 0xAA0 );
+			cx_write(AUD_DEEMPH1_A0, 0x6B68);
+			cx_write(AUD_DEEMPH1_B0, 0x11EC);
+			cx_write(AUD_DEEMPH1_A1, 0x3FC66);
+			cx_write(AUD_DEEMPH1_B1, 0x399A);
+
+			break;
+	}
+#endif
+
+	// de-assert Audio soft reset
+	cx_write(AUD_SOFT_RESET,0x0000);
+
+	// AB: 10/2/01: this register is not being reset appropriately on occasion.
+	cx_write(AUD_POLYPH80SCALEFAC,3);
+}
+
+/* ----------------------------------------------------------- */
+
+void cx88_set_tvaudio(struct cx8800_dev *dev)
+{
+	cx_write(AUD_CTL, 0x00);
+
+	switch (dev->tvaudio) {
+	case WW_BTSC:
+		set_audio_standard_BTSC(dev,0);
+		break;
+	case WW_NICAM_I:
+	case WW_NICAM_BGDKL:
+		set_audio_standard_NICAM(dev);
+		break;
+	case WW_A2_BG:
+	case WW_A2_DK:
+	case WW_A2_M:
+		set_audio_standard_A2(dev);
+		break;
+	case WW_EIAJ:
+		set_audio_standard_EIAJ(dev);
+		break;
+	case WW_FM:
+		set_audio_standard_FM(dev);
+		break;
+	case WW_NONE:
+	default:
+		printk("%s: unknown tv audio mode [%d]\n",
+		       dev->name, dev->tvaudio);
+		break;
+	}
+
+	// unmute
+	cx_set(AUD_CTL, EN_DAC_ENABLE);
+	cx_write(AUD_VOL_CTL, 0x00);
+	return;
+}
+
+void cx88_get_stereo(struct cx8800_dev *dev, struct v4l2_tuner *t)
+{
+	static char *m[] = {"mono", "dual mono", "stereo", "sap"};
+	static char *p[] = {"no pilot", "pilot c1", "pilot c2", "?"};
+	u32 reg,mode,pilot;
+
+	reg   = cx_read(AUD_STATUS);
+	mode  = reg & 0x03;
+	pilot = (reg >> 2) & 0x03;
+	dprintk("AUD_STATUS: %s / %s [status=0x%x,ctl=0x%x,vol=0x%x]\n",
+		m[mode], p[pilot], reg,
+		cx_read(AUD_CTL), cx_read(AUD_VOL_CTL));
+
+	t->capability = V4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_SAP |
+		V4L2_TUNER_CAP_LANG1 | V4L2_TUNER_CAP_LANG2;
+	t->rxsubchans = V4L2_TUNER_SUB_MONO;
+	t->audmode    = V4L2_TUNER_MODE_MONO;
+
+	switch (dev->tvaudio) {
+	case WW_A2_BG:
+ 		if (2 == pilot) {
+			/* stereo */
+			t->rxsubchans = V4L2_TUNER_SUB_MONO | V4L2_TUNER_SUB_STEREO;
+			if (2 == mode)
+				t->audmode = V4L2_TUNER_MODE_STEREO;
+		}
+ 		if (1 == pilot) {
+			/* dual language -- FIXME */
+			t->rxsubchans = V4L2_TUNER_SUB_LANG1 | V4L2_TUNER_SUB_LANG2;
+			t->audmode = V4L2_TUNER_MODE_LANG1;
+		}
+		break;
+	case WW_NICAM_BGDKL:
+		if (2 == mode)
+			t->audmode = V4L2_TUNER_MODE_STEREO;
+		break;
+	default:
+		t->rxsubchans = V4L2_TUNER_SUB_MONO;
+		t->audmode    = V4L2_TUNER_MODE_MONO;
+		break;
+	}
+	return;
+}
+
+void cx88_set_stereo(struct cx8800_dev *dev, u32 mode)
+{
+	u32 ctl  = UNSET;
+	u32 mask = UNSET;
+
+	switch (dev->tvaudio) {
+	case WW_A2_BG:
+		switch (mode) {
+		case V4L2_TUNER_MODE_MONO:   
+		case V4L2_TUNER_MODE_LANG1:
+			ctl  = EN_A2_FORCE_MONO1;
+			mask = 0x3f;
+			break;
+		case V4L2_TUNER_MODE_LANG2:
+			ctl  = EN_A2_AUTO_MONO2;
+			mask = 0x3f;
+			break;
+		case V4L2_TUNER_MODE_STEREO:
+			ctl  = EN_A2_AUTO_STEREO | EN_DMTRX_SUMR;
+			mask = 0x8bf;
+			break;
+		}
+		break;
+	case WW_NICAM_BGDKL:
+		switch (mode) {
+		case V4L2_TUNER_MODE_MONO:   
+			ctl  = EN_NICAM_FORCE_MONO1;
+			mask = 0x3f;
+			break;
+		case V4L2_TUNER_MODE_LANG1:
+			ctl  = EN_NICAM_AUTO_MONO2;
+			mask = 0x3f;
+			break;
+		case V4L2_TUNER_MODE_STEREO:
+			ctl  = EN_NICAM_FORCE_STEREO | EN_DMTRX_LR;
+			mask = 0x93f;
+			break;
+		}
+		break;	
+	case WW_FM:
+		switch (mode) {
+		case V4L2_TUNER_MODE_MONO:   
+			ctl  = EN_FMRADIO_FORCE_MONO;
+			mask = 0x3f;
+			break;
+		case V4L2_TUNER_MODE_STEREO:
+			ctl  = EN_FMRADIO_AUTO_STEREO;
+			mask = 0x3f;
+			break;
+		}
+		break;	
+	}
+
+	if (UNSET != ctl) {
+		cx_write(AUD_SOFT_RESET, 0x0001);
+		cx_andor(AUD_CTL, mask, ctl);
+		cx_write(AUD_SOFT_RESET, 0x0000);
+		dprintk("cx88_set_stereo: mask 0x%x, ctl 0x%x "
+			"[status=0x%x,ctl=0x%x,vol=0x%x]\n",
+			mask, ctl, cx_read(AUD_STATUS),
+			cx_read(AUD_CTL), cx_read(AUD_VOL_CTL));
+	}
+	return;
+}
+
+/*
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
diff -u linux-2.6.1/drivers/media/video/cx88/cx88-video.c linux/drivers/media/video/cx88/cx88-video.c
--- linux-2.6.1/drivers/media/video/cx88/cx88-video.c	2004-01-14 14:36:15.467999840 +0100
+++ linux/drivers/media/video/cx88/cx88-video.c	2004-01-14 14:57:57.684390110 +0100
@@ -0,0 +1,2238 @@
+/*
+ * device driver for Conexant 2388x based TV cards
+ * video4linux video interface
+ *
+ * (c) 2003 Gerd Knorr <kraxel@bytesex.org> [SuSE Labs]
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#define __NO_VERSION__ 1
+
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/kmod.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <asm/div64.h>
+
+#include "cx88.h"
+
+MODULE_DESCRIPTION("v4l2 driver module for cx2388x based TV cards");
+MODULE_AUTHOR("Gerd Knorr <kraxel@bytesex.org> [SuSE Labs]");
+MODULE_LICENSE("GPL");
+
+/* ------------------------------------------------------------------ */
+
+static unsigned int video_nr[] = {[0 ... (CX88_MAXBOARDS - 1)] = UNSET };
+MODULE_PARM(video_nr,"1-" __stringify(CX88_MAXBOARDS) "i");
+MODULE_PARM_DESC(video_nr,"video device numbers");
+
+static unsigned int radio_nr[] = {[0 ... (CX88_MAXBOARDS - 1)] = UNSET };
+MODULE_PARM(radio_nr,"1-" __stringify(CX88_MAXBOARDS) "i");
+MODULE_PARM_DESC(radio_nr,"radio device numbers");
+
+static unsigned int latency = UNSET;
+MODULE_PARM(latency,"i");
+MODULE_PARM_DESC(latency,"pci latency timer");
+
+static unsigned int video_debug = 0;
+MODULE_PARM(video_debug,"i");
+MODULE_PARM_DESC(video_debug,"enable debug messages [video]");
+
+static unsigned int irq_debug = 0;
+MODULE_PARM(irq_debug,"i");
+MODULE_PARM_DESC(irq_debug,"enable debug messages [IRQ handler]");
+
+static unsigned int vid_limit = 16;
+MODULE_PARM(vid_limit,"i");
+MODULE_PARM_DESC(vid_limit,"capture memory limit in megabytes");
+
+static unsigned int tuner[] = {[0 ... (CX88_MAXBOARDS - 1)] = UNSET };
+MODULE_PARM(tuner,"1-" __stringify(CX88_MAXBOARDS) "i");
+MODULE_PARM_DESC(tuner,"tuner type");
+
+static unsigned int card[] = {[0 ... (CX88_MAXBOARDS - 1)] = UNSET };
+MODULE_PARM(card,"1-" __stringify(CX88_MAXBOARDS) "i");
+MODULE_PARM_DESC(card,"card type");
+
+static unsigned int nicam = 0;
+MODULE_PARM(nicam,"i");
+MODULE_PARM_DESC(nicam,"tv audio is nicam");
+
+#define dprintk(level,fmt, arg...)	if (video_debug >= level) \
+	printk(KERN_DEBUG "%s: " fmt, dev->name , ## arg)
+
+/* ------------------------------------------------------------------ */
+
+static struct list_head  cx8800_devlist;
+static unsigned int      cx8800_devcount;
+
+/* ------------------------------------------------------------------- */
+/* static data                                                         */
+
+static unsigned int inline norm_swidth(struct cx8800_tvnorm *norm)
+{
+	return (norm->id & V4L2_STD_625_50) ? 922 : 754;
+}
+
+static unsigned int inline norm_hdelay(struct cx8800_tvnorm *norm)
+{
+	return (norm->id & V4L2_STD_625_50) ? 186 : 135;
+}
+
+static unsigned int inline norm_vdelay(struct cx8800_tvnorm *norm)
+{
+	return (norm->id & V4L2_STD_625_50) ? 0x24 : 0x18;
+}
+
+static unsigned int inline norm_maxw(struct cx8800_tvnorm *norm)
+{
+	return (norm->id & V4L2_STD_625_50) ? 768 : 640;
+//	return (norm->id & V4L2_STD_625_50) ? 720 : 640;
+}
+
+static unsigned int inline norm_maxh(struct cx8800_tvnorm *norm)
+{
+	return (norm->id & V4L2_STD_625_50) ? 576 : 480;
+}
+
+static unsigned int inline norm_fsc8(struct cx8800_tvnorm *norm)
+{
+	static const unsigned int ntsc = 28636360;
+	static const unsigned int pal  = 35468950;
+	
+	return (norm->id & V4L2_STD_625_50) ? pal : ntsc;
+}
+
+static unsigned int inline norm_notchfilter(struct cx8800_tvnorm *norm)
+{
+	return (norm->id & V4L2_STD_625_50)
+		? HLNotchFilter135PAL
+		: HLNotchFilter135NTSC;
+}
+
+static unsigned int inline norm_htotal(struct cx8800_tvnorm *norm)
+{
+	return (norm->id & V4L2_STD_625_50) ? 1135 : 910;
+}
+
+static struct cx8800_tvnorm tvnorms[] = {
+	{
+		.name      = "NTSC-M",
+		.id        = V4L2_STD_NTSC_M,
+		.cxiformat = VideoFormatNTSC,
+	},{
+		.name      = "NTSC-JP",
+		.id        = V4L2_STD_NTSC_M_JP,
+		.cxiformat = VideoFormatNTSCJapan,
+#if 0
+	},{
+		.name      = "NTSC-4.43",
+		.id        = FIXME,
+		.cxiformat = VideoFormatNTSC443,
+#endif
+	},{
+		.name      = "PAL",
+		.id        = V4L2_STD_PAL,
+		.cxiformat = VideoFormatPAL,
+        },{
+		.name      = "PAL-M",
+		.id        = V4L2_STD_PAL_M,
+		.cxiformat = VideoFormatPALM,
+	},{
+		.name      = "PAL-N",
+		.id        = V4L2_STD_PAL_N,
+		.cxiformat = VideoFormatPALN,
+	},{
+		.name      = "PAL-Nc",
+		.id        = V4L2_STD_PAL_Nc,
+		.cxiformat = VideoFormatPALNC,
+	},{
+		.name      = "PAL-60",
+		.id        = V4L2_STD_PAL_60,
+		.cxiformat = VideoFormatPAL60,
+	},{
+		.name      = "SECAM",
+		.id        = V4L2_STD_SECAM,
+		.cxiformat = VideoFormatSECAM,
+	}
+};
+
+static struct cx8800_fmt formats[] = {
+	{
+		.name     = "8 bpp, gray",
+		.fourcc   = V4L2_PIX_FMT_GREY,
+		.cxformat = ColorFormatY8,
+		.depth    = 8,
+		.flags    = FORMAT_FLAGS_PACKED,
+	},{
+		.name     = "15 bpp RGB, le",
+		.fourcc   = V4L2_PIX_FMT_RGB555,
+		.cxformat = ColorFormatRGB15,
+		.depth    = 16,
+		.flags    = FORMAT_FLAGS_PACKED,
+	},{
+		.name     = "15 bpp RGB, be",
+		.fourcc   = V4L2_PIX_FMT_RGB555X,
+		.cxformat = ColorFormatRGB15 | ColorFormatBSWAP,
+		.depth    = 16,
+		.flags    = FORMAT_FLAGS_PACKED,
+	},{
+		.name     = "16 bpp RGB, le",
+		.fourcc   = V4L2_PIX_FMT_RGB565,
+		.cxformat = ColorFormatRGB16,
+		.depth    = 16,
+		.flags    = FORMAT_FLAGS_PACKED,
+	},{
+		.name     = "16 bpp RGB, be",
+		.fourcc   = V4L2_PIX_FMT_RGB565X,
+		.cxformat = ColorFormatRGB16 | ColorFormatBSWAP,
+		.depth    = 16,
+		.flags    = FORMAT_FLAGS_PACKED,
+	},{
+		.name     = "24 bpp RGB, le",
+		.fourcc   = V4L2_PIX_FMT_BGR24,
+		.cxformat = ColorFormatRGB24,
+		.depth    = 24,
+		.flags    = FORMAT_FLAGS_PACKED,
+	},{
+		.name     = "32 bpp RGB, le",
+		.fourcc   = V4L2_PIX_FMT_BGR32,
+		.cxformat = ColorFormatRGB32,
+		.depth    = 32,
+		.flags    = FORMAT_FLAGS_PACKED,
+	},{
+		.name     = "32 bpp RGB, be",
+		.fourcc   = V4L2_PIX_FMT_RGB32,
+		.cxformat = ColorFormatRGB32 | ColorFormatBSWAP | ColorFormatWSWAP,
+		.depth    = 32,
+		.flags    = FORMAT_FLAGS_PACKED,
+	},{
+		.name     = "4:2:2, packed, YUYV",
+		.fourcc   = V4L2_PIX_FMT_YUYV,
+		.cxformat = ColorFormatYUY2,
+		.depth    = 16,
+		.flags    = FORMAT_FLAGS_PACKED,
+	},{
+		.name     = "4:2:2, packed, UYVY",
+		.fourcc   = V4L2_PIX_FMT_UYVY,
+		.cxformat = ColorFormatYUY2 | ColorFormatBSWAP,
+		.depth    = 16,
+		.flags    = FORMAT_FLAGS_PACKED,
+	},
+};
+
+static struct cx8800_fmt* format_by_fourcc(unsigned int fourcc)
+{
+	unsigned int i;
+	
+	for (i = 0; i < ARRAY_SIZE(formats); i++)
+		if (formats[i].fourcc == fourcc)
+			return formats+i;
+	return NULL;
+}
+
+/* ------------------------------------------------------------------- */
+
+static const struct v4l2_queryctrl no_ctl = {
+	.name  = "42",
+	.flags = V4L2_CTRL_FLAG_DISABLED,
+};
+
+static struct cx88_ctrl cx8800_ctls[] = {
+	/* --- video --- */
+	{
+		.v.id            = V4L2_CID_BRIGHTNESS,
+		.v.name          = "Brightness",
+		.v.minimum       = 0x00,
+		.v.maximum       = 0xff,
+		.v.step          = 1,
+		.v.default_value = 0,
+		.v.type          = V4L2_CTRL_TYPE_INTEGER,
+		.off             = 128,
+		.reg             = MO_CONTR_BRIGHT,
+		.mask            = 0x00ff,
+		.shift           = 0,
+	},{
+		.v.id            = V4L2_CID_CONTRAST,
+		.v.name          = "Contrast",
+		.v.minimum       = 0,
+		.v.maximum       = 0xff,
+		.v.step          = 1,
+		.v.default_value = 0,
+		.v.type          = V4L2_CTRL_TYPE_INTEGER,
+		.reg             = MO_CONTR_BRIGHT,
+		.mask            = 0xff00,
+		.shift           = 8,
+	},{
+	/* --- audio --- */
+#if 0
+		.v.id            = V4L2_CID_AUDIO_MUTE,
+		.v.name          = "Mute",
+		.v.minimum       = 0,
+		.v.maximum       = 1,
+		.v.type          = V4L2_CTRL_TYPE_BOOLEAN,
+		.reg             = AUD_VOL_CTL,
+		.mask            = (1 << 6),
+		.shift           = 6,
+	},{
+#endif
+		.v.id            = V4L2_CID_AUDIO_VOLUME,
+		.v.name          = "Volume",
+		.v.minimum       = 0,
+		.v.maximum       = 0x3f,
+		.v.step          = 1,
+		.v.default_value = 0,
+		.v.type          = V4L2_CTRL_TYPE_INTEGER,
+		.reg             = AUD_VOL_CTL,
+		.mask            = 0x3f,
+		.shift           = 0,
+	}
+};
+const int CX8800_CTLS = ARRAY_SIZE(cx8800_ctls);
+
+/* ------------------------------------------------------------------- */
+/* resource management                                                 */
+
+static int res_get(struct cx8800_dev *dev, struct cx8800_fh *fh, unsigned int bit)
+{
+	if (fh->resources & bit)
+		/* have it already allocated */
+		return 1;
+
+	/* is it free? */
+	down(&dev->lock);
+	if (dev->resources & bit) {
+		/* no, someone else uses it */
+		up(&dev->lock);
+		return 0;
+	}
+	/* it's free, grab it */
+	fh->resources  |= bit;
+	dev->resources |= bit;
+	dprintk(1,"res: get %d\n",bit);
+	up(&dev->lock);
+	return 1;
+}
+
+static
+int res_check(struct cx8800_fh *fh, unsigned int bit)
+{
+	return (fh->resources & bit);
+}
+
+#if 0
+static
+int res_locked(struct cx8800_dev *dev, unsigned int bit)
+{
+	return (dev->resources & bit);
+}
+#endif
+
+static
+void res_free(struct cx8800_dev *dev, struct cx8800_fh *fh, unsigned int bits)
+{
+	if ((fh->resources & bits) != bits)
+		BUG();
+
+	down(&dev->lock);
+	fh->resources  &= ~bits;
+	dev->resources &= ~bits;
+	dprintk(1,"res: put %d\n",bits);
+	up(&dev->lock);
+}
+
+/* ------------------------------------------------------------------ */
+
+static const u32 xtal = 28636363;
+
+static int set_pll(struct cx8800_dev *dev, int prescale, u32 ofreq)
+{
+	static u32 pre[] = { 0, 0, 0, 3, 2, 1 };
+	u64 pll;
+	u32 reg;
+	int i;
+
+	if (prescale < 2)
+		prescale = 2;
+	if (prescale > 5)
+		prescale = 5;
+
+	pll = ofreq * 8 * prescale * (u64)(1 << 20);
+	do_div(pll,xtal);
+	reg = (pll & 0x3ffffff) | (pre[prescale] << 26);
+	if (((reg >> 20) & 0x3f) < 14) {
+		printk("%s: pll out of range\n",dev->name);
+		return -1;
+	}
+		
+	dprintk(1,"set_pll:    MO_PLL_REG       0x%08x [old=0x%08x,freq=%d]\n",
+		reg, cx_read(MO_PLL_REG), ofreq);
+	cx_write(MO_PLL_REG, reg);
+	for (i = 0; i < 10; i++) {
+		reg = cx_read(MO_DEVICE_STATUS);
+		if (reg & (1<<2)) {
+			dprintk(1,"pll locked [pre=%d,ofreq=%d]\n",
+				prescale,ofreq);
+			return 0;
+		}
+		dprintk(1,"pll not locked yet, waiting ...\n");
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(HZ/10);
+	}
+	dprintk(1,"pll NOT locked [pre=%d,ofreq=%d]\n",prescale,ofreq);
+	return -1;
+}
+
+static int set_tvaudio(struct cx8800_dev *dev)
+{
+	if (CX88_VMUX_TELEVISION != INPUT(dev->input)->type)
+		return 0;
+
+
+	dev->tvaudio = 0;
+	if (dev->tvnorm->id & V4L2_STD_PAL) {
+		if (nicam)
+			dev->tvaudio = WW_NICAM_BGDKL;
+		else
+			dev->tvaudio = WW_A2_BG;
+	}
+	if (0 == dev->tvaudio)
+		return 0;
+
+	cx_andor(MO_AFECFG_IO,    0x1f, 0x0);
+	cx88_set_tvaudio(dev);
+	//cx88_set_stereo(dev,norm->tvaudio, V4L2_TUNER_MODE_MONO);
+	//cx_write(MO_AUD_DMACNTRL, 0x03); /* need audio fifo */
+	return 0;
+}
+
+static int set_tvnorm(struct cx8800_dev *dev, struct cx8800_tvnorm *norm)
+{
+	u32 fsc8;
+	u32 adc_clock;
+	u32 vdec_clock;
+	u64 tmp64;
+	u32 bdelay,agcdelay,htotal;
+	struct video_channel c;
+	
+	dev->tvnorm = norm;
+	fsc8       = norm_fsc8(norm);
+	adc_clock  = xtal;
+	vdec_clock = fsc8;
+
+	dprintk(1,"set_tvnorm: \"%s\" fsc8=%d adc=%d vdec=%d\n",
+		norm->name, fsc8, adc_clock, vdec_clock);
+	set_pll(dev,2,vdec_clock);
+	
+	dprintk(1,"set_tvnorm: MO_INPUT_FORMAT  0x%08x [old=0x%08x]\n",
+		norm->cxiformat, cx_read(MO_INPUT_FORMAT) & 0x0f);
+	cx_andor(MO_INPUT_FORMAT, 0xf, norm->cxiformat);
+
+#if 1
+	// FIXME: as-is from DScaler
+	dprintk(1,"set_tvnorm: MO_OUTPUT_FORMAT 0x%08x [old=0x%08x]\n",
+		0x1c1f0008, cx_read(MO_OUTPUT_FORMAT));
+	cx_write(MO_OUTPUT_FORMAT, 0x1c1f0008);
+#endif
+
+	// MO_SCONV_REG = adc clock / video dec clock * 2^17
+	tmp64  = adc_clock * (u64)(1 << 17);
+	do_div(tmp64, vdec_clock);
+	dprintk(1,"set_tvnorm: MO_SCONV_REG     0x%08x [old=0x%08x]\n",
+		(u32)tmp64, cx_read(MO_SCONV_REG));
+	cx_write(MO_SCONV_REG, (u32)tmp64);
+
+	// MO_SUB_STEP = 8 * fsc / video dec clock * 2^22
+	tmp64  = fsc8 * (u64)(1 << 22);
+	do_div(tmp64, vdec_clock);
+	dprintk(1,"set_tvnorm: MO_SUB_STEP      0x%08x [old=0x%08x]\n",
+		(u32)tmp64, cx_read(MO_SUB_STEP));
+	cx_write(MO_SUB_STEP, (u32)tmp64);
+
+	// MO_SUB_STEP_DR = 8 * 4406250 / video dec clock * 2^22
+	tmp64  = 4406250 * 8 * (u64)(1 << 22);
+	do_div(tmp64, vdec_clock);
+	dprintk(1,"set_tvnorm: MO_SUB_STEP_DR   0x%08x [old=0x%08x]\n",
+		(u32)tmp64, cx_read(MO_SUB_STEP_DR));
+	cx_write(MO_SUB_STEP_DR, (u32)tmp64);
+
+	// bdelay + agcdelay
+	bdelay   = vdec_clock * 65 / 20000000 + 21;
+	agcdelay = vdec_clock * 68 / 20000000 + 15;
+	dprintk(1,"set_tvnorm: MO_AGC_BURST     0x%08x [old=0x%08x,bdelay=%d,agcdelay=%d]\n",
+		(bdelay << 8) | agcdelay, cx_read(MO_AGC_BURST), bdelay, agcdelay);
+	cx_write(MO_AGC_BURST, (bdelay << 8) | agcdelay);
+
+	// htotal
+	tmp64 = norm_htotal(norm) * (u64)vdec_clock;
+	do_div(tmp64, fsc8);
+	htotal = (u32)tmp64 | (norm_notchfilter(norm) << 11);
+	dprintk(1,"set_tvnorm: MO_HTOTAL        0x%08x [old=0x%08x,htotal=%d]\n",
+		htotal, cx_read(MO_HTOTAL), (u32)tmp64);
+	cx_write(MO_HTOTAL, htotal);
+	
+	// audio
+	set_tvaudio(dev);
+
+	// tell i2c chips
+	memset(&c,0,sizeof(c));
+	c.channel = dev->input;
+	c.norm = VIDEO_MODE_PAL;
+	if ((norm->id & (V4L2_STD_NTSC_M|V4L2_STD_NTSC_M_JP)))
+		c.norm = VIDEO_MODE_NTSC;
+	if (norm->id & V4L2_STD_SECAM)
+		c.norm = VIDEO_MODE_SECAM;
+	cx8800_call_i2c_clients(dev,VIDIOCSCHAN,&c);
+
+	// done
+	return 0;
+}
+
+static int set_scale(struct cx8800_dev *dev, unsigned int width, unsigned int height,
+		     int interlaced)
+{
+	unsigned int swidth  = norm_swidth(dev->tvnorm);
+	unsigned int sheight = norm_maxh(dev->tvnorm);
+	u32 value;
+
+	dprintk(1,"set_scale: %dx%d [%s]\n", width, height, dev->tvnorm->name);
+
+	// recalc H delay and scale registers
+	value = (width * norm_hdelay(dev->tvnorm)) / swidth;
+	cx_write(MO_HDELAY_EVEN,  value);
+	cx_write(MO_HDELAY_ODD,   value);
+	dprintk(1,"set_scale: hdelay  0x%04x\n", value);
+	
+	value = (swidth * 4096 / width) - 4096;
+	cx_write(MO_HSCALE_EVEN,  value);
+	cx_write(MO_HSCALE_ODD,   value);
+	dprintk(1,"set_scale: hscale  0x%04x\n", value);
+
+	cx_write(MO_HACTIVE_EVEN, width);
+	cx_write(MO_HACTIVE_ODD,  width);
+	dprintk(1,"set_scale: hactive 0x%04x\n", width);
+	
+	// recalc V scale Register (delay is constant)
+	cx_write(MO_VDELAY_EVEN, norm_vdelay(dev->tvnorm));
+	cx_write(MO_VDELAY_ODD,  norm_vdelay(dev->tvnorm));
+	dprintk(1,"set_scale: vdelay  0x%04x\n", norm_vdelay(dev->tvnorm));
+	
+	value = (0x10000 - (sheight * 512 / height - 512)) & 0x1fff;
+	cx_write(MO_VSCALE_EVEN,  value);
+	cx_write(MO_VSCALE_ODD,   value);
+	dprintk(1,"set_scale: vscale  0x%04x\n", value);
+
+	cx_write(MO_VACTIVE_EVEN, sheight);
+	cx_write(MO_VACTIVE_ODD,  sheight);
+	dprintk(1,"set_scale: vactive 0x%04x\n", sheight);
+
+	// setup filters
+	value = 0;
+	value |= (1 << 19);  // CFILT (default)
+	if (interlaced)
+		value |= (1 << 3); // VINT (interlaced vertical scaling)
+	cx_write(MO_FILTER_EVEN,  value);
+	cx_write(MO_FILTER_ODD,   value);
+	dprintk(1,"set_scale: filter  0x%04x\n", value);
+	
+	return 0;
+}
+
+static int video_mux(struct cx8800_dev *dev, unsigned int input)
+{
+	dprintk(1,"video_mux: %d [vmux=%d,gpio=0x%x]\n",
+		input, INPUT(input)->vmux, INPUT(input)->gpio0);
+	dev->input = input;
+	cx_andor(MO_INPUT_FORMAT, 0x03 << 14, INPUT(input)->vmux << 14);
+	cx_write(MO_GP0_IO, INPUT(input)->gpio0);
+	return 0;
+}
+
+/* ------------------------------------------------------------------ */
+
+static int start_video_dma(struct cx8800_dev    *dev,
+			   struct cx88_dmaqueue *q,
+			   struct cx88_buffer   *buf)
+{
+	/* setup fifo + format */
+	cx88_sram_channel_setup(dev, &cx88_sram_channels[SRAM_CH21],
+				buf->bpl, buf->risc.dma);
+	set_scale(dev, buf->vb.width, buf->vb.height, 1);
+	cx_write(MO_COLOR_CTRL, buf->fmt->cxformat | ColorFormatGamma);
+
+	/* reset counter */
+	cx_write(MO_VIDY_GPCNTRL,0x3);
+	q->count = 1;
+
+	/* enable irqs */
+	cx_set(MO_PCI_INTMSK, 0x00fc01);
+	cx_set(MO_VID_INTMSK, 0x0f0011);
+	
+	/* enable capture */
+	cx_set(VID_CAPTURE_CONTROL,0x06);
+	
+	/* start dma */
+	cx_set(MO_DEV_CNTRL2, (1<<5));
+	cx_set(MO_VID_DMACNTRL, 0x11);
+
+	return 0;
+}
+
+static int restart_video_queue(struct cx8800_dev    *dev,
+			       struct cx88_dmaqueue *q)
+{
+	struct cx88_buffer *buf, *prev;
+	struct list_head *item;
+	
+	if (!list_empty(&q->active)) {
+	        buf = list_entry(q->active.next, struct cx88_buffer, vb.queue);
+		dprintk(2,"restart_queue [%p/%d]: restart dma\n",
+			buf, buf->vb.i);
+		start_video_dma(dev, q, buf);
+		list_for_each(item,&q->active) {
+			buf = list_entry(item, struct cx88_buffer, vb.queue);
+			buf->count    = q->count++;
+		}
+		mod_timer(&q->timeout, jiffies+BUFFER_TIMEOUT);
+		return 0;
+	}
+
+	prev = NULL;
+	for (;;) {
+		if (list_empty(&q->queued))
+			return 0;
+	        buf = list_entry(q->queued.next, struct cx88_buffer, vb.queue);
+		if (NULL == prev) {
+			list_del(&buf->vb.queue);
+			list_add_tail(&buf->vb.queue,&q->active);
+			start_video_dma(dev, q, buf);
+			buf->vb.state = STATE_ACTIVE;
+			buf->count    = q->count++;
+			mod_timer(&q->timeout, jiffies+BUFFER_TIMEOUT);
+			dprintk(2,"[%p/%d] restart_queue - first active\n",
+				buf,buf->vb.i);
+
+		} else if (prev->vb.width  == buf->vb.width  &&
+			   prev->vb.height == buf->vb.height &&
+			   prev->fmt       == buf->fmt) {
+			list_del(&buf->vb.queue);
+			list_add_tail(&buf->vb.queue,&q->active);
+			buf->vb.state = STATE_ACTIVE;
+			buf->count    = q->count++;
+			prev->risc.jmp[1] = cpu_to_le32(buf->risc.dma);
+			dprintk(2,"[%p/%d] restart_queue - move to active\n",
+				buf,buf->vb.i);
+		} else {
+			return 0;
+		}
+		prev = buf;
+	}
+}
+
+/* ------------------------------------------------------------------ */
+
+static int
+buffer_setup(struct file *file, unsigned int *count, unsigned int *size)
+{
+	struct cx8800_fh *fh = file->private_data;
+	
+	*size = fh->fmt->depth*fh->width*fh->height >> 3;
+	if (0 == *count)
+		*count = 32;
+	while (*size * *count > vid_limit * 1024 * 1024)
+		(*count)--;
+	return 0;
+}
+
+static int
+buffer_prepare(struct file *file, struct videobuf_buffer *vb,
+	       enum v4l2_field field)
+{
+	struct cx8800_fh   *fh  = file->private_data;
+	struct cx8800_dev  *dev = fh->dev;
+	struct cx88_buffer *buf = (struct cx88_buffer*)vb;
+	int rc, init_buffer = 0;
+
+	BUG_ON(NULL == fh->fmt);
+	if (fh->width  < 48 || fh->width  > norm_maxw(dev->tvnorm) ||
+	    fh->height < 32 || fh->height > norm_maxh(dev->tvnorm))
+		return -EINVAL;
+	buf->vb.size = (fh->width * fh->height * fh->fmt->depth) >> 3;
+	if (0 != buf->vb.baddr  &&  buf->vb.bsize < buf->vb.size)
+		return -EINVAL;
+
+	if (buf->fmt       != fh->fmt    ||
+	    buf->vb.width  != fh->width  ||
+	    buf->vb.height != fh->height ||
+	    buf->vb.field  != field) {
+		buf->fmt       = fh->fmt;
+		buf->vb.width  = fh->width;
+		buf->vb.height = fh->height;
+		buf->vb.field  = field;
+		init_buffer = 1;
+	}
+
+	if (STATE_NEEDS_INIT == buf->vb.state) {
+		init_buffer = 1;
+		if (0 != (rc = videobuf_iolock(dev->pci,&buf->vb,NULL)))
+			goto fail;
+	}
+
+	if (init_buffer) {
+		buf->bpl = buf->vb.width * buf->fmt->depth >> 3;
+		switch (buf->vb.field) {
+		case V4L2_FIELD_TOP:
+			cx88_risc_buffer(dev->pci, &buf->risc,
+					 buf->vb.dma.sglist, 0, UNSET,
+					 buf->bpl, 0, buf->vb.height);
+			break;
+		case V4L2_FIELD_BOTTOM:
+			cx88_risc_buffer(dev->pci, &buf->risc,
+					 buf->vb.dma.sglist, UNSET, 0,
+					 buf->bpl, 0, buf->vb.height);
+			break;
+		case V4L2_FIELD_INTERLACED:
+			cx88_risc_buffer(dev->pci, &buf->risc,
+					 buf->vb.dma.sglist, 0, buf->bpl,
+					 buf->bpl, buf->bpl,
+					 buf->vb.height >> 1);
+			break;
+		default:
+			BUG();
+		}
+	}
+	dprintk(2,"[%p/%d] buffer_prepare - %dx%d %dbpp \"%s\" - dma=0x%08lx\n",
+		buf, buf->vb.i,
+		fh->width, fh->height, fh->fmt->depth, fh->fmt->name,
+		(unsigned long)buf->risc.dma);
+
+	buf->vb.state = STATE_PREPARED;
+	return 0;
+
+ fail:
+	cx88_free_buffer(dev->pci,buf);
+	return rc;
+}
+
+static void
+buffer_queue(struct file *file, struct videobuf_buffer *vb)
+{
+	struct cx88_buffer    *buf  = (struct cx88_buffer*)vb;
+	struct cx88_buffer    *prev;
+	struct cx8800_fh      *fh   = file->private_data;
+	struct cx8800_dev     *dev  = fh->dev;
+	struct cx88_dmaqueue  *q    = &dev->vidq;
+
+	/* add jump to stopper */
+	buf->risc.jmp[0] = cpu_to_le32(RISC_JUMP | RISC_IRQ1 | 0x10000);
+	buf->risc.jmp[1] = cpu_to_le32(q->stopper.dma);
+
+	if (!list_empty(&q->queued)) {
+		list_add_tail(&buf->vb.queue,&q->queued);
+		buf->vb.state = STATE_QUEUED;
+		dprintk(2,"[%p/%d] buffer_queue - append to queued\n",
+			buf, buf->vb.i);
+
+	} else if (list_empty(&q->active)) {
+		list_add_tail(&buf->vb.queue,&q->active);
+		start_video_dma(dev, q, buf);
+		buf->vb.state = STATE_ACTIVE;
+		buf->count    = q->count++;
+		mod_timer(&q->timeout, jiffies+BUFFER_TIMEOUT);
+		dprintk(2,"[%p/%d] buffer_queue - first active\n",
+			buf, buf->vb.i);
+
+	} else {
+		prev = list_entry(q->active.prev, struct cx88_buffer, vb.queue);
+		if (prev->vb.width  == buf->vb.width  &&
+		    prev->vb.height == buf->vb.height &&
+		    prev->fmt       == buf->fmt) {
+			list_add_tail(&buf->vb.queue,&q->active);
+			buf->vb.state = STATE_ACTIVE;
+			buf->count    = q->count++;
+			prev->risc.jmp[1] = cpu_to_le32(buf->risc.dma);
+			dprintk(2,"[%p/%d] buffer_queue - append to active\n",
+				buf, buf->vb.i);
+
+		} else {
+			list_add_tail(&buf->vb.queue,&q->queued);
+			buf->vb.state = STATE_QUEUED;
+			dprintk(2,"[%p/%d] buffer_queue - first queued\n",
+				buf, buf->vb.i);
+		}
+	}
+}
+
+static void buffer_release(struct file *file, struct videobuf_buffer *vb)
+{
+	struct cx88_buffer *buf = (struct cx88_buffer*)vb;
+	struct cx8800_fh   *fh  = file->private_data;
+
+	cx88_free_buffer(fh->dev->pci,buf);
+}
+
+static struct videobuf_queue_ops cx8800_video_qops = {
+	.buf_setup    = buffer_setup,
+	.buf_prepare  = buffer_prepare,
+	.buf_queue    = buffer_queue,
+	.buf_release  = buffer_release,
+};
+
+/* ------------------------------------------------------------------ */
+
+#if 0 /* overlay support not finished yet */
+static u32* ov_risc_field(struct cx8800_dev *dev, struct cx8800_fh *fh,
+			  u32 *rp, struct btcx_skiplist *skips,
+			  u32 sync_line, int skip_even, int skip_odd)
+{
+	int line,maxy,start,end,skip,nskips;
+	u32 ri,ra;
+	u32 addr;
+
+	/* sync instruction */
+	*(rp++) = cpu_to_le32(RISC_RESYNC | sync_line);
+
+	addr  = (unsigned long)dev->fbuf.base;
+	addr += dev->fbuf.fmt.bytesperline * fh->win.w.top;
+	addr += (fh->fmt->depth >> 3)      * fh->win.w.left;
+
+	/* scan lines */
+	for (maxy = -1, line = 0; line < fh->win.w.height;
+	     line++, addr += dev->fbuf.fmt.bytesperline) {
+		if ((line%2) == 0  &&  skip_even)
+			continue;
+		if ((line%2) == 1  &&  skip_odd)
+			continue;
+
+		/* calculate clipping */
+		if (line > maxy)
+			btcx_calc_skips(line, fh->win.w.width, &maxy,
+					skips, &nskips, fh->clips, fh->nclips);
+
+		/* write out risc code */
+		for (start = 0, skip = 0; start < fh->win.w.width; start = end) {
+			if (skip >= nskips) {
+				ri  = RISC_WRITE;
+				end = fh->win.w.width;
+			} else if (start < skips[skip].start) {
+				ri  = RISC_WRITE;
+				end = skips[skip].start;
+			} else {
+				ri  = RISC_SKIP;
+				end = skips[skip].end;
+				skip++;
+			}
+			if (RISC_WRITE == ri)
+				ra = addr + (fh->fmt->depth>>3)*start;
+			else
+				ra = 0;
+				
+			if (0 == start)
+				ri |= RISC_SOL;
+			if (fh->win.w.width == end)
+				ri |= RISC_EOL;
+			ri |= (fh->fmt->depth>>3) * (end-start);
+
+			*(rp++)=cpu_to_le32(ri);
+			if (0 != ra)
+				*(rp++)=cpu_to_le32(ra);
+		}
+	}
+	kfree(skips);
+	return rp;
+}
+
+static int ov_risc_frame(struct cx8800_dev *dev, struct cx8800_fh *fh,
+			 struct cx88_buffer *buf)
+{
+	struct btcx_skiplist *skips;
+	u32 instructions,fields;
+	u32 *rp;
+	int rc;
+	
+	/* skip list for window clipping */
+	if (NULL == (skips = kmalloc(sizeof(*skips) * fh->nclips,GFP_KERNEL)))
+		return -ENOMEM;
+	
+	fields = 0;
+	if (V4L2_FIELD_HAS_TOP(fh->win.field))
+		fields++;
+	if (V4L2_FIELD_HAS_BOTTOM(fh->win.field))
+		fields++;
+
+        /* estimate risc mem: worst case is (clip+1) * lines instructions
+           + syncs + jump (all 2 dwords) */
+	instructions  = (fh->nclips+1) * fh->win.w.height;
+	instructions += 3 + 4;
+	if ((rc = btcx_riscmem_alloc(dev->pci,&buf->risc,instructions*8)) < 0) {
+		kfree(skips);
+		return rc;
+	}
+
+	/* write risc instructions */
+	rp = buf->risc.cpu;
+	switch (fh->win.field) {
+	case V4L2_FIELD_TOP:
+		rp = ov_risc_field(dev, fh, rp, skips, 0,     0, 0);
+		break;
+	case V4L2_FIELD_BOTTOM:
+		rp = ov_risc_field(dev, fh, rp, skips, 0x200, 0, 0);
+		break;
+	case V4L2_FIELD_INTERLACED:
+		rp = ov_risc_field(dev, fh, rp, skips, 0,     0, 1);
+		rp = ov_risc_field(dev, fh, rp, skips, 0x200, 1, 0);
+		break;
+	default:
+		BUG();
+	}
+
+	/* save pointer to jmp instruction address */
+	buf->risc.jmp = rp;
+	kfree(skips);
+	return 0;
+}
+
+static int verify_window(struct cx8800_dev *dev, struct v4l2_window *win)
+{
+	enum v4l2_field field;
+	int maxw, maxh;
+
+	if (NULL == dev->fbuf.base)
+		return -EINVAL;
+	if (win->w.width < 48 || win->w.height <  32)
+		return -EINVAL;
+	if (win->clipcount > 2048)
+		return -EINVAL;
+
+	field = win->field;
+	maxw  = norm_maxw(dev->tvnorm);
+	maxh  = norm_maxh(dev->tvnorm);
+
+	if (V4L2_FIELD_ANY == field) {
+                field = (win->w.height > maxh/2)
+                        ? V4L2_FIELD_INTERLACED
+                        : V4L2_FIELD_TOP;
+        }
+        switch (field) {
+        case V4L2_FIELD_TOP:
+        case V4L2_FIELD_BOTTOM:
+                maxh = maxh / 2;
+                break;
+        case V4L2_FIELD_INTERLACED:
+                break;
+        default:
+                return -EINVAL;
+        }
+
+	win->field = field;
+	if (win->w.width > maxw)
+		win->w.width = maxw;
+	if (win->w.height > maxh)
+		win->w.height = maxh;
+	return 0;
+}
+
+static int setup_window(struct cx8800_dev *dev, struct cx8800_fh *fh,
+			struct v4l2_window *win)
+{
+	struct v4l2_clip *clips = NULL;
+	int n,size,retval = 0;
+
+	if (NULL == fh->fmt)
+		return -EINVAL;
+	retval = verify_window(dev,win);
+	if (0 != retval)
+		return retval;
+
+	/* copy clips  --  luckily v4l1 + v4l2 are binary
+	   compatible here ...*/
+	n = win->clipcount;
+	size = sizeof(*clips)*(n+4);
+	clips = kmalloc(size,GFP_KERNEL);
+	if (NULL == clips)
+		return -ENOMEM;
+	if (n > 0) {
+		if (copy_from_user(clips,win->clips,sizeof(struct v4l2_clip)*n)) {
+			kfree(clips);
+			return -EFAULT;
+		}
+	}
+
+	/* clip against screen */
+	if (NULL != dev->fbuf.base)
+		n = btcx_screen_clips(dev->fbuf.fmt.width, dev->fbuf.fmt.height,
+				      &win->w, clips, n);
+	btcx_sort_clips(clips,n);
+
+	/* 4-byte alignments */
+	switch (fh->fmt->depth) {
+	case 8:
+	case 24:
+		btcx_align(&win->w, clips, n, 3);
+		break;
+	case 16:
+		btcx_align(&win->w, clips, n, 1);
+		break;
+	case 32:
+		/* no alignment fixups needed */
+		break;
+	default:
+		BUG();
+	}
+	
+	down(&fh->vidq.lock);
+	if (fh->clips)
+		kfree(fh->clips);
+	fh->clips    = clips;
+	fh->nclips   = n;
+	fh->win      = *win;
+#if 0
+	fh->ov.setup_ok = 1;
+#endif
+	
+	/* update overlay if needed */
+	retval = 0;
+#if 0
+	if (check_btres(fh, RESOURCE_OVERLAY)) {
+		struct bttv_buffer *new;
+		
+		new = videobuf_alloc(sizeof(*new));
+		bttv_overlay_risc(btv, &fh->ov, fh->ovfmt, new);
+		retval = bttv_switch_overlay(btv,fh,new);
+	}
+#endif
+	up(&fh->vidq.lock);
+	return retval;
+}
+#endif
+
+/* ------------------------------------------------------------------ */
+
+static int video_open(struct inode *inode, struct file *file)
+{
+	int minor = iminor(inode);
+	struct cx8800_dev *h,*dev = NULL;
+	struct cx8800_fh *fh;
+	struct list_head *list;
+	enum v4l2_buf_type type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	int radio = 0;
+	
+	list_for_each(list,&cx8800_devlist) {
+		h = list_entry(list, struct cx8800_dev, devlist);
+		if (h->video_dev->minor == minor)
+			dev = h;
+		if (h->radio_dev &&
+		    h->radio_dev->minor == minor) {
+			radio = 1;
+			dev   = h;
+		}
+	}
+	if (NULL == dev)
+		return -ENODEV;
+
+	dprintk(1,"open minor=%d radio=%d type=%s\n",
+		minor,radio,v4l2_type_names[type]);
+
+	/* allocate + initialize per filehandle data */
+	fh = kmalloc(sizeof(*fh),GFP_KERNEL);
+	if (NULL == fh)
+		return -ENOMEM;
+	memset(fh,0,sizeof(*fh));
+	file->private_data = fh;
+	fh->dev      = dev;
+	fh->radio    = radio;
+	fh->type     = type;
+	fh->width    = 320;
+	fh->height   = 240;
+	fh->fmt      = format_by_fourcc(V4L2_PIX_FMT_BGR24);
+
+	videobuf_queue_init(&fh->vidq, &cx8800_video_qops,
+			    dev->pci, &dev->slock,
+			    V4L2_BUF_TYPE_VIDEO_CAPTURE,
+			    V4L2_FIELD_INTERLACED,
+			    sizeof(struct cx88_buffer));
+	init_MUTEX(&fh->vidq.lock);
+
+	if (fh->radio) {
+		dprintk(1,"video_open: setting radio device\n");
+		cx_write(MO_GP0_IO, cx88_boards[dev->board].radio.gpio0);
+		dev->tvaudio = WW_FM;
+		cx88_set_tvaudio(dev);
+		cx88_set_stereo(dev,V4L2_TUNER_MODE_STEREO);
+		cx8800_call_i2c_clients(dev,AUDC_SET_RADIO,NULL);
+	}
+
+        return 0;
+}
+
+static ssize_t
+video_read(struct file *file, char *data, size_t count, loff_t *ppos)
+{
+	struct cx8800_fh *fh = file->private_data;
+
+	return videobuf_read_one(file, &fh->vidq, data, count, ppos);
+}
+
+static unsigned int
+video_poll(struct file *file, struct poll_table_struct *wait)
+{
+	return POLLERR;
+}
+
+static int video_release(struct inode *inode, struct file *file)
+{
+	struct cx8800_fh  *fh  = file->private_data;
+	struct cx8800_dev *dev = fh->dev;
+
+	/* turn off overlay */
+	if (res_check(fh, RESOURCE_OVERLAY)) {
+		/* FIXME */
+		res_free(dev,fh,RESOURCE_OVERLAY);
+	}
+
+	/* stop video capture */
+	if (res_check(fh, RESOURCE_VIDEO)) {
+		videobuf_queue_cancel(file,&fh->vidq);
+		res_free(dev,fh,RESOURCE_VIDEO);
+	}
+	if (fh->vidq.read_buf) {
+		buffer_release(file,fh->vidq.read_buf);
+		kfree(fh->vidq.read_buf);
+	}
+
+	file->private_data = NULL;
+	kfree(fh);
+	return 0;
+}
+
+static int
+video_mmap(struct file *file, struct vm_area_struct * vma)
+{
+	struct cx8800_fh *fh = file->private_data;
+
+	return videobuf_mmap_mapper(vma,&fh->vidq);
+}
+
+/* ------------------------------------------------------------------ */
+
+static int get_control(struct cx8800_dev *dev, struct v4l2_control *ctl)
+{
+	struct cx88_ctrl *c = NULL;
+	u32 value;
+	int i;
+	
+	for (i = 0; i < CX8800_CTLS; i++)
+		if (cx8800_ctls[i].v.id == ctl->id)
+			c = &cx8800_ctls[i];
+	if (NULL == c)
+		return -EINVAL;
+
+	value = cx_read(c->reg);
+	ctl->value = ((value + (c->off << c->shift)) & c->mask) >> c->shift;
+	return 0;
+}
+
+static int set_control(struct cx8800_dev *dev, struct v4l2_control *ctl)
+{
+	struct cx88_ctrl *c = NULL;
+	u32 value;
+	int i;
+
+	for (i = 0; i < CX8800_CTLS; i++)
+		if (cx8800_ctls[i].v.id == ctl->id)
+			c = &cx8800_ctls[i];
+	if (NULL == c)
+		return -EINVAL;
+
+	if (ctl->value < c->v.minimum)
+		return -ERANGE;
+	if (ctl->value > c->v.maximum)
+		return -ERANGE;
+	value = ((ctl->value - c->off) << c->shift) & c->mask;
+	cx_andor(c->reg, c->mask, value);
+	return 0;
+}
+
+/* ------------------------------------------------------------------ */
+
+static int cx8800_g_fmt(struct cx8800_dev *dev, struct cx8800_fh *fh,
+			struct v4l2_format *f)
+{
+	switch (f->type) {
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		memset(&f->fmt.pix,0,sizeof(f->fmt.pix));
+		f->fmt.pix.width        = fh->width;
+		f->fmt.pix.height       = fh->height;
+		f->fmt.pix.field        = fh->vidq.field;
+		f->fmt.pix.pixelformat  = fh->fmt->fourcc;
+		f->fmt.pix.bytesperline =
+			(f->fmt.pix.width * fh->fmt->depth) >> 3;
+		f->fmt.pix.sizeimage =
+			f->fmt.pix.height * f->fmt.pix.bytesperline;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int cx8800_try_fmt(struct cx8800_dev *dev, struct cx8800_fh *fh,
+			  struct v4l2_format *f)
+{
+	switch (f->type) {
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+	{
+		struct cx8800_fmt *fmt;
+		enum v4l2_field field;
+		unsigned int maxw, maxh;
+
+		fmt = format_by_fourcc(f->fmt.pix.pixelformat);
+		if (NULL == fmt)
+			return -EINVAL;
+
+		field = f->fmt.pix.field;
+		maxw  = norm_maxw(dev->tvnorm);
+		maxh  = norm_maxh(dev->tvnorm);
+
+#if 0
+		if (V4L2_FIELD_ANY == field) {
+			field = (f->fmt.pix.height > maxh/2)
+				? V4L2_FIELD_INTERLACED
+				: V4L2_FIELD_BOTTOM;
+		}
+#else
+		field = V4L2_FIELD_INTERLACED;
+#endif
+		switch (field) {
+		case V4L2_FIELD_TOP:
+		case V4L2_FIELD_BOTTOM:
+			maxh = maxh / 2;
+			break;
+		case V4L2_FIELD_INTERLACED:
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		f->fmt.pix.field = field;
+		if (f->fmt.pix.width < 48)
+			f->fmt.pix.width = 48;
+		if (f->fmt.pix.height < 32)
+			f->fmt.pix.height = 32;
+		if (f->fmt.pix.width > maxw)
+			f->fmt.pix.width = maxw;
+		if (f->fmt.pix.height > maxh)
+			f->fmt.pix.height = maxh;
+		f->fmt.pix.bytesperline =
+			(f->fmt.pix.width * fmt->depth) >> 3;
+		f->fmt.pix.sizeimage =
+			f->fmt.pix.height * f->fmt.pix.bytesperline;
+
+		return 0;
+	}
+	default:
+		return -EINVAL;
+	}
+}
+
+static int cx8800_s_fmt(struct cx8800_dev *dev, struct cx8800_fh *fh,
+			struct v4l2_format *f)
+{
+	int err;
+	
+	switch (f->type) {
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		err = cx8800_try_fmt(dev,fh,f);
+		if (0 != err)
+			return err;
+
+		fh->fmt        = format_by_fourcc(f->fmt.pix.pixelformat);
+		fh->width      = f->fmt.pix.width;
+		fh->height     = f->fmt.pix.height;
+		fh->vidq.field = f->fmt.pix.field;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+/*
+ * This function is _not_ called directly, but from
+ * video_generic_ioctl (and maybe others).  userspace
+ * copying is done already, arg is a kernel pointer.
+ */
+static int video_do_ioctl(struct inode *inode, struct file *file,
+			  unsigned int cmd, void *arg)
+{
+	struct cx8800_fh  *fh  = file->private_data;
+	struct cx8800_dev *dev = fh->dev;
+#if 0
+	unsigned long flags;
+#endif
+	int err;
+
+	if (video_debug > 1)
+		cx88_print_ioctl(dev->name,cmd);
+	switch (cmd) {
+	case VIDIOC_QUERYCAP:
+	{
+		struct v4l2_capability *cap = arg;
+		
+		memset(cap,0,sizeof(*cap));
+                strcpy(cap->driver, "cx8800");
+		strlcpy(cap->card, cx88_boards[dev->board].name,
+			sizeof(cap->card));
+		sprintf(cap->bus_info,"PCI:%s",pci_name(dev->pci));
+		cap->version = CX88_VERSION_CODE;
+		cap->capabilities =
+			V4L2_CAP_VIDEO_CAPTURE |
+			V4L2_CAP_READWRITE     |
+			V4L2_CAP_STREAMING     |
+#if 0
+			V4L2_CAP_VIDEO_OVERLAY |
+			V4L2_CAP_VBI_CAPTURE   |
+#endif
+			0;
+		if (UNSET != dev->tuner_type)
+			cap->capabilities |= V4L2_CAP_TUNER;
+
+		return 0;
+	}
+
+	/* ---------- tv norms ---------- */
+	case VIDIOC_ENUMSTD:
+	{
+		struct v4l2_standard *e = arg;
+		unsigned int i;
+
+		i = e->index;
+		if (i >= ARRAY_SIZE(tvnorms))
+			return -EINVAL;
+		err = v4l2_video_std_construct(e, tvnorms[e->index].id,
+					       tvnorms[e->index].name);
+		e->index = i;
+		if (err < 0)
+			return err;
+		return 0;
+	}
+	case VIDIOC_G_STD:
+	{
+		v4l2_std_id *id = arg;
+
+		*id = dev->tvnorm->id;
+		return 0;
+	}
+	case VIDIOC_S_STD:
+	{
+		v4l2_std_id *id = arg;
+		unsigned int i;
+
+		for(i = 0; i < ARRAY_SIZE(tvnorms); i++)
+			if (*id & tvnorms[i].id)
+				break;
+		if (i == ARRAY_SIZE(tvnorms))
+			return -EINVAL;
+
+		down(&dev->lock);
+		set_tvnorm(dev,&tvnorms[i]);
+		up(&dev->lock);
+		return 0;
+	}
+
+	/* ------ input switching ---------- */
+	case VIDIOC_ENUMINPUT:
+	{
+		static const char *iname[] = {
+			[ CX88_VMUX_COMPOSITE1 ] = "Composite1",
+			[ CX88_VMUX_COMPOSITE2 ] = "Composite2",
+			[ CX88_VMUX_COMPOSITE3 ] = "Composite3",
+			[ CX88_VMUX_COMPOSITE4 ] = "Composite4",
+			[ CX88_VMUX_TELEVISION ] = "Television",
+			[ CX88_VMUX_SVIDEO     ] = "S-Video",
+			[ CX88_VMUX_DEBUG      ] = "for debug only",
+		};
+		struct v4l2_input *i = arg;
+		unsigned int n;
+
+		n = i->index;
+		if (n >= 4)
+			return -EINVAL;
+		if (0 == INPUT(n)->type)
+			return -EINVAL;
+		memset(i,0,sizeof(*i));
+		i->index = n;
+		i->type  = V4L2_INPUT_TYPE_CAMERA;
+		strcpy(i->name,iname[INPUT(n)->type]);
+		if (CX88_VMUX_TELEVISION == INPUT(n)->type)
+			i->type = V4L2_INPUT_TYPE_TUNER;
+		for (n = 0; n < ARRAY_SIZE(tvnorms); n++)
+			i->std |= tvnorms[n].id;
+		return 0;
+	}
+	case VIDIOC_G_INPUT:
+	{
+		unsigned int *i = arg;
+
+		*i = dev->input;
+		return 0;
+	}
+	case VIDIOC_S_INPUT:
+	{
+		unsigned int *i = arg;
+		
+		if (*i >= 4)
+			return -EINVAL;
+		down(&dev->lock);
+		video_mux(dev,*i);
+		up(&dev->lock);
+		return 0;
+	}
+
+	/* --- capture ioctls ---------------------------------------- */
+	case VIDIOC_ENUM_FMT:
+	{
+		struct v4l2_fmtdesc *f = arg;
+		enum v4l2_buf_type type;
+		unsigned int index;
+
+		index = f->index;
+		type  = f->type;
+		switch (type) {
+		case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+			if (index >= ARRAY_SIZE(formats))
+				return -EINVAL;
+			memset(f,0,sizeof(*f));
+			f->index = index;
+			f->type  = type;
+			strlcpy(f->description,formats[index].name,sizeof(f->description));
+			f->pixelformat = formats[index].fourcc;
+			break;
+		default:
+			return -EINVAL;
+		}
+		return 0;
+	}
+	case VIDIOC_G_FMT:
+	{
+		struct v4l2_format *f = arg;
+		return cx8800_g_fmt(dev,fh,f);
+	}
+	case VIDIOC_S_FMT:
+	{
+		struct v4l2_format *f = arg;
+		return cx8800_s_fmt(dev,fh,f);
+	}
+	case VIDIOC_TRY_FMT:
+	{
+		struct v4l2_format *f = arg;
+		return cx8800_try_fmt(dev,fh,f);
+	}
+
+	/* --- controls ---------------------------------------------- */
+	case VIDIOC_QUERYCTRL:
+	{
+		struct v4l2_queryctrl *c = arg;
+		int i;
+
+		if (c->id <  V4L2_CID_BASE ||
+		    c->id >= V4L2_CID_LASTP1)
+			return -EINVAL;
+		for (i = 0; i < CX8800_CTLS; i++)
+			if (cx8800_ctls[i].v.id == c->id)
+				break;
+		if (i == CX8800_CTLS) {
+			*c = no_ctl;
+			return 0;
+		}
+		*c = cx8800_ctls[i].v;
+		return 0;
+	}
+	case VIDIOC_G_CTRL:
+		return get_control(dev,arg);
+	case VIDIOC_S_CTRL:
+		return set_control(dev,arg);
+		
+	/* --- tuner ioctls ------------------------------------------ */
+	case VIDIOC_G_TUNER:
+	{
+		struct v4l2_tuner *t = arg;
+		u32 reg;
+		
+		if (UNSET == dev->tuner_type)
+			return -EINVAL;
+		if (0 != t->index)
+			return -EINVAL;
+
+		memset(t,0,sizeof(*t));
+		strcpy(t->name, "Television");
+		t->type       = V4L2_TUNER_ANALOG_TV;
+		t->capability = V4L2_TUNER_CAP_NORM;
+		t->rangehigh  = 0xffffffffUL;
+
+		cx88_get_stereo(dev ,t);
+		reg = cx_read(MO_DEVICE_STATUS);
+                t->signal = (reg & (1<<5)) ? 0xffff : 0x0000;
+		return 0;
+	}
+	case VIDIOC_S_TUNER:
+	{
+		struct v4l2_tuner *t = arg;
+
+		if (UNSET == dev->tuner_type)
+			return -EINVAL;
+		if (0 != t->index)
+			return -EINVAL;
+		cx88_set_stereo(dev,t->audmode);
+		return 0;
+	}
+	case VIDIOC_G_FREQUENCY:
+	{
+		struct v4l2_frequency *f = arg;
+
+		if (UNSET == dev->tuner_type)
+			return -EINVAL;
+		if (f->tuner != 0)
+			return -EINVAL;
+		memset(f,0,sizeof(*f));
+		f->type = fh->radio ? V4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV;
+		f->frequency = dev->freq;
+		return 0;
+	}
+	case VIDIOC_S_FREQUENCY:
+	{
+		struct v4l2_frequency *f = arg;
+
+		if (UNSET == dev->tuner_type)
+			return -EINVAL;
+		if (f->tuner != 0)
+			return -EINVAL;
+		if (0 == fh->radio && f->type != V4L2_TUNER_ANALOG_TV)
+			return -EINVAL;
+		if (1 == fh->radio && f->type != V4L2_TUNER_RADIO)
+			return -EINVAL;
+		down(&dev->lock);
+		dev->freq = f->frequency;
+		cx8800_call_i2c_clients(dev,VIDIOCSFREQ,&dev->freq);
+		up(&dev->lock);
+		return 0;
+	}
+
+	/* --- streaming capture ------------------------------------- */
+	case VIDIOC_REQBUFS:
+		return videobuf_reqbufs(file,&fh->vidq,arg);
+
+	case VIDIOC_QUERYBUF:
+		return videobuf_querybuf(&fh->vidq,arg);
+
+	case VIDIOC_QBUF:
+		return videobuf_qbuf(file,&fh->vidq,arg);
+
+	case VIDIOC_DQBUF:
+		return videobuf_dqbuf(file,&fh->vidq,arg);
+
+	case VIDIOC_STREAMON:
+	{
+                if (!res_get(dev,fh,RESOURCE_VIDEO))
+			return -EBUSY;
+		return videobuf_streamon(file,&fh->vidq);
+	}
+	case VIDIOC_STREAMOFF:
+	{
+		err = videobuf_streamoff(file,&fh->vidq);
+		if (err < 0)
+			return err;
+		res_free(dev,fh,RESOURCE_VIDEO);
+		return 0;
+	}
+
+	default:
+		return v4l_compat_translate_ioctl(inode,file,cmd,arg,
+						  video_do_ioctl);
+	}
+	return 0;
+}
+
+static int video_ioctl(struct inode *inode, struct file *file,
+		       unsigned int cmd, unsigned long arg)
+{
+	return video_usercopy(inode, file, cmd, arg, video_do_ioctl);
+}
+
+/* ----------------------------------------------------------- */
+
+static int radio_do_ioctl(struct inode *inode, struct file *file,
+			unsigned int cmd, void *arg)
+{
+	struct cx8800_fh *fh = file->private_data;
+	struct cx8800_dev *dev = fh->dev;
+	
+	if (video_debug > 1)
+		cx88_print_ioctl(dev->name,cmd);
+
+	switch (cmd) {
+	case VIDIOC_QUERYCAP:
+	{
+		struct v4l2_capability *cap = arg;
+		
+		memset(cap,0,sizeof(*cap));
+                strcpy(cap->driver, "cx8800");
+		strlcpy(cap->card, cx88_boards[dev->board].name,
+			sizeof(cap->card));
+		sprintf(cap->bus_info,"PCI:%s", pci_name(dev->pci));
+		cap->version = CX88_VERSION_CODE;
+		cap->capabilities = V4L2_CAP_TUNER;
+		return 0;
+	}
+	case VIDIOC_G_TUNER:
+	{
+		struct v4l2_tuner *t = arg;
+		struct video_tuner vt;
+
+		if (t->index > 0)
+			return -EINVAL;
+
+		memset(t,0,sizeof(*t));
+		strcpy(t->name, "Radio");
+                t->rangelow  = (int)(65*16);
+                t->rangehigh = (int)(108*16);
+		
+		memset(&vt,0,sizeof(vt));
+		cx8800_call_i2c_clients(dev,VIDIOCGTUNER,&vt);
+		t->signal = vt.signal;
+		return 0;
+	}
+	case VIDIOC_ENUMINPUT:
+	{
+		struct v4l2_input *i = arg;
+		
+		if (i->index != 0)
+			return -EINVAL;
+		strcpy(i->name,"Radio");
+		i->type = V4L2_INPUT_TYPE_TUNER;
+		return 0;
+	}
+	case VIDIOC_G_INPUT:
+	{
+		int *i = arg;
+		*i = 0;
+		return 0;
+	}
+	case VIDIOC_G_AUDIO:
+	{
+		struct v4l2_audio *a = arg;
+
+		memset(a,0,sizeof(*a));
+		strcpy(a->name,"Radio");
+		return 0;
+	}
+	case VIDIOC_G_STD:
+	{
+		v4l2_std_id *id = arg;
+		*id = 0;
+		return 0;
+	}
+	case VIDIOC_S_AUDIO:
+	case VIDIOC_S_TUNER:
+	case VIDIOC_S_INPUT:
+	case VIDIOC_S_STD:
+		return 0;
+
+	case VIDIOC_QUERYCTRL:
+	{
+		struct v4l2_queryctrl *c = arg;
+		int i;
+
+		if (c->id <  V4L2_CID_BASE ||
+		    c->id >= V4L2_CID_LASTP1)
+			return -EINVAL;
+		if (c->id == V4L2_CID_AUDIO_MUTE) {
+			for (i = 0; i < CX8800_CTLS; i++)
+				if (cx8800_ctls[i].v.id == c->id)
+					break;
+			*c = cx8800_ctls[i].v;
+		} else
+			*c = no_ctl;
+		return 0;
+	}
+
+
+	case VIDIOC_G_CTRL:
+	case VIDIOC_S_CTRL:
+	case VIDIOC_G_FREQUENCY:
+	case VIDIOC_S_FREQUENCY:
+		return video_do_ioctl(inode,file,cmd,arg);
+		
+	default:
+		return v4l_compat_translate_ioctl(inode,file,cmd,arg,
+						  radio_do_ioctl);
+	}
+	return 0;
+};
+
+static int radio_ioctl(struct inode *inode, struct file *file,
+			unsigned int cmd, unsigned long arg)
+{
+	return video_usercopy(inode, file, cmd, arg, radio_do_ioctl);
+};
+
+/* ----------------------------------------------------------- */
+
+static void cx8800_vid_timeout(unsigned long data)
+{
+	struct cx8800_dev *dev = (struct cx8800_dev*)data;
+	struct cx88_dmaqueue *q = &dev->vidq;
+	struct cx88_buffer *buf;
+	unsigned long flags;
+
+	cx88_sram_channel_dump(dev, &cx88_sram_channels[SRAM_CH21]);
+	//cx88_risc_disasm(dev,&dev->vidq.stopper);
+	
+	cx_clear(MO_VID_DMACNTRL, 0x11);
+	cx_clear(VID_CAPTURE_CONTROL, 0x06);
+
+	spin_lock_irqsave(&dev->slock,flags);
+	while (!list_empty(&q->active)) {
+		buf = list_entry(q->active.next, struct cx88_buffer, vb.queue);
+		list_del(&buf->vb.queue);
+		buf->vb.state = STATE_ERROR;
+		wake_up(&buf->vb.done);
+		printk("%s: [%p/%d] timeout - dma=0x%08lx\n", dev->name,
+		       buf, buf->vb.i, (unsigned long)buf->risc.dma);
+	}
+	restart_video_queue(dev,q);
+	spin_unlock_irqrestore(&dev->slock,flags);
+}
+
+static void cx8800_vid_irq(struct cx8800_dev *dev)
+{
+	struct cx88_buffer *buf;
+	u32 status, mask, count;
+
+	status = cx_read(MO_VID_INTSTAT);
+	mask   = cx_read(MO_VID_INTMSK);
+	if (0 == (status & mask))
+		return;
+	cx_write(MO_VID_INTSTAT, status);
+	if (irq_debug  ||  (status & mask & ~0xff))
+		cx88_print_irqbits(dev->name, "irq vid",
+				   cx88_vid_irqs, status, mask);
+
+	/* risc op code error */
+	if (status & (1 << 16)) {
+		printk(KERN_WARNING "%s: video risc op code error\n",dev->name);
+		cx_clear(MO_VID_DMACNTRL, 0x11);
+		cx_clear(VID_CAPTURE_CONTROL, 0x06);
+		cx88_sram_channel_dump(dev, &cx88_sram_channels[SRAM_CH21]);
+	}
+	
+	/* risc1 y */
+	if (status & 0x01) {
+		spin_lock(&dev->slock);
+		count = cx_read(MO_VIDY_GPCNT);
+		for (;;) {
+			if (list_empty(&dev->vidq.active))
+				break;
+			buf = list_entry(dev->vidq.active.next,
+					 struct cx88_buffer, vb.queue);
+			if (buf->count > count)
+				break;
+			do_gettimeofday(&buf->vb.ts);
+			dprintk(2,"[%p/%d] wakeup reg=%d buf=%d\n",buf,buf->vb.i,
+				count, buf->count);
+			buf->vb.state = STATE_DONE;
+			list_del(&buf->vb.queue);
+			wake_up(&buf->vb.done);
+		}
+		if (list_empty(&dev->vidq.active)) {
+			del_timer(&dev->vidq.timeout);
+		} else {
+			mod_timer(&dev->vidq.timeout, jiffies+BUFFER_TIMEOUT);
+		}
+		spin_unlock(&dev->slock);
+	}
+
+	/* risc2 y */
+	if (status & 0x10) {
+		dprintk(2,"stopper\n");
+		spin_lock(&dev->slock);
+		restart_video_queue(dev,&dev->vidq);
+		spin_unlock(&dev->slock);
+	}
+}
+
+static irqreturn_t cx8800_irq(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct cx8800_dev *dev = dev_id;
+	u32 status, mask;
+	int loop, handled = 0;
+
+	for (loop = 0; loop < 10; loop++) {
+		status = cx_read(MO_PCI_INTSTAT);
+		mask   = cx_read(MO_PCI_INTMSK);
+		if (0 == (status & mask))
+			goto out;
+		handled = 1;
+		cx_write(MO_PCI_INTSTAT, status);
+		if (irq_debug  ||  (status & mask & ~0x1f))
+			cx88_print_irqbits(dev->name, "irq pci",
+					   cx88_pci_irqs, status, mask);
+
+		if (status & 1)
+			cx8800_vid_irq(dev);
+	};
+	if (10 == loop) {
+		printk(KERN_WARNING "%s: irq loop -- clearing mask\n",
+		       dev->name);
+		cx_write(MO_PCI_INTMSK,0);
+	}
+	
+ out:
+	return IRQ_RETVAL(handled);
+}
+
+/* ----------------------------------------------------------- */
+/* exported stuff                                              */
+
+static struct file_operations video_fops =
+{
+	.owner	       = THIS_MODULE,
+	.open	       = video_open,
+	.release       = video_release,
+	.read	       = video_read,
+	.poll          = video_poll,
+	.mmap	       = video_mmap,
+	.ioctl	       = video_ioctl,
+	.llseek        = no_llseek,
+};
+
+struct video_device cx8800_video_template =
+{
+	.name          = "cx8800-video",
+	.type          = VID_TYPE_CAPTURE|VID_TYPE_TUNER|VID_TYPE_OVERLAY|
+	                 VID_TYPE_CLIPPING|VID_TYPE_SCALES,
+	.hardware      = 0,
+	.fops          = &video_fops,
+	.minor         = -1,
+};
+
+static struct file_operations radio_fops =
+{
+	.owner         = THIS_MODULE,
+	.open          = video_open,
+	.release       = video_release,
+	.ioctl         = radio_ioctl,
+	.llseek        = no_llseek,
+};
+
+struct video_device cx8800_radio_template =
+{
+	.name          = "cx8800-radio",
+	.type          = VID_TYPE_TUNER,
+	.hardware      = 0,
+	.fops          = &radio_fops,
+	.minor         = -1,
+};
+
+/* ----------------------------------------------------------- */
+
+static void cx8800_shutdown(struct cx8800_dev *dev)
+{
+	/* disable RISC controller + IRQs */
+	cx_write(MO_DEV_CNTRL2, 0);
+
+	/* stop dma transfers */
+	cx_write(MO_VID_DMACNTRL, 0x0);
+	cx_write(MO_AUD_DMACNTRL, 0x0);
+	cx_write(MO_TS_DMACNTRL, 0x0);
+	cx_write(MO_VIP_DMACNTRL, 0x0);
+	cx_write(MO_GPHST_DMACNTRL, 0x0);
+
+	/* stop interupts */
+	cx_write(MO_PCI_INTMSK, 0x0);
+	cx_write(MO_VID_INTMSK, 0x0);
+	cx_write(MO_AUD_INTMSK, 0x0);
+	cx_write(MO_TS_INTMSK, 0x0);
+	cx_write(MO_VIP_INTMSK, 0x0);
+	cx_write(MO_GPHST_INTMSK, 0x0);
+
+	/* stop capturing */
+	cx_write(VID_CAPTURE_CONTROL, 0);
+}
+
+static int cx8800_reset(struct cx8800_dev *dev)
+{
+	dprintk(1,"cx8800_reset\n");
+
+	cx8800_shutdown(dev);
+	
+	/* clear irq status */
+	cx_write(MO_VID_INTSTAT, 0xFFFFFFFF); // Clear PIV int
+	cx_write(MO_PCI_INTSTAT, 0xFFFFFFFF); // Clear PCI int
+	cx_write(MO_INT1_STAT,   0xFFFFFFFF); // Clear RISC int
+
+	/* wait a bit */
+	set_current_state(TASK_INTERRUPTIBLE);
+	schedule_timeout(HZ/10);
+	
+	/* init sram */
+	cx88_sram_channel_setup(dev, &cx88_sram_channels[SRAM_CH21], 720*4, 0);
+	cx88_sram_channel_setup(dev, &cx88_sram_channels[SRAM_CH22], 128, 0);
+	cx88_sram_channel_setup(dev, &cx88_sram_channels[SRAM_CH23], 128, 0);
+	cx88_sram_channel_setup(dev, &cx88_sram_channels[SRAM_CH24], 128, 0);
+	cx88_sram_channel_setup(dev, &cx88_sram_channels[SRAM_CH25], 128, 0);
+	cx88_sram_channel_setup(dev, &cx88_sram_channels[SRAM_CH26], 128, 0);
+	
+	/* misc init ... */
+	cx_write(MO_INPUT_FORMAT, ((1 << 13) |   // agc enable
+				   (1 << 12) |   // agc gain
+				   (1 << 11) |   // adaptibe agc
+				   (0 << 10) |   // chroma agc
+				   (0 <<  9) |   // ckillen
+				   (7)));
+
+	/* setup image format */
+	cx_andor(MO_COLOR_CTRL, 0x4000, 0x4000);
+
+	/* setup FIFO Threshholds */
+	cx_write(MO_PDMA_STHRSH,   0x0807);
+	cx_write(MO_PDMA_DTHRSH,   0x0807);
+
+	/* fixes flashing of image */
+	cx_write(MO_AGC_SYNC_TIP1, 0x0380000F);
+	cx_write(MO_AGC_BACK_VBI,  0x00E00555);
+	
+	cx_write(MO_VID_INTSTAT,   0xFFFFFFFF); // Clear PIV int
+	cx_write(MO_PCI_INTSTAT,   0xFFFFFFFF); // Clear PCI int
+	cx_write(MO_INT1_STAT,     0xFFFFFFFF); // Clear RISC int
+
+	return 0;
+}
+
+static struct video_device *vdev_init(struct cx8800_dev *dev,
+				      struct video_device *template,
+				      char *type)
+{
+	struct video_device *vfd;
+
+	vfd = video_device_alloc();
+	if (NULL == vfd)
+		return NULL;
+	*vfd = *template;
+	vfd->minor   = -1;
+	vfd->dev     = &dev->pci->dev;
+	vfd->release = video_device_release;
+	snprintf(vfd->name, sizeof(vfd->name), "%s %s (%s)",
+		 dev->name, type, cx88_boards[dev->board].name);
+	return vfd;
+}
+
+static void cx8800_unregister_video(struct cx8800_dev *dev)
+{
+	if (dev->radio_dev) {
+		if (-1 != dev->radio_dev->minor)
+			video_unregister_device(dev->radio_dev);
+		else
+			video_device_release(dev->radio_dev);
+		dev->radio_dev = NULL;
+	}
+	if (dev->video_dev) {
+		if (-1 != dev->video_dev->minor)
+			video_unregister_device(dev->video_dev);
+		else
+			video_device_release(dev->video_dev);
+		dev->video_dev = NULL;
+	}
+}
+
+static int __devinit cx8800_initdev(struct pci_dev *pci_dev,
+				    const struct pci_device_id *pci_id)
+{
+	struct cx8800_dev *dev;
+	unsigned int i;
+	int err;
+
+	dev = kmalloc(sizeof(*dev),GFP_KERNEL);
+	if (NULL == dev)
+		return -ENOMEM;
+	memset(dev,0,sizeof(*dev));
+
+	/* pci init */
+	dev->pci = pci_dev;
+	if (pci_enable_device(pci_dev)) {
+		err = -EIO;
+		goto fail1;
+	}
+	sprintf(dev->name,"cx%x[%d]",pci_dev->device,cx8800_devcount);
+
+	/* pci quirks */
+	cx88_pci_quirks(dev->name, dev->pci, &latency);
+	if (UNSET != latency) {
+		printk(KERN_INFO "%s: setting pci latency timer to %d\n",
+		       dev->name,latency);
+		pci_write_config_byte(pci_dev, PCI_LATENCY_TIMER, latency);
+	}
+
+	/* print pci info */
+	pci_read_config_byte(pci_dev, PCI_CLASS_REVISION, &dev->pci_rev);
+        pci_read_config_byte(pci_dev, PCI_LATENCY_TIMER,  &dev->pci_lat);
+        printk(KERN_INFO "%s: found at %s, rev: %d, irq: %d, "
+	       "latency: %d, mmio: 0x%lx\n", dev->name,
+	       pci_name(pci_dev), dev->pci_rev, pci_dev->irq,
+	       dev->pci_lat,pci_resource_start(pci_dev,0));
+
+	pci_set_master(pci_dev);
+	if (!pci_dma_supported(pci_dev,0xffffffff)) {
+		printk("%s: Oops: no 32bit PCI DMA ???\n",dev->name);
+		err = -EIO;
+		goto fail1;
+	}
+
+	/* board config */
+	dev->board = card[cx8800_devcount];
+	for (i = 0; UNSET == dev->board  &&  i < cx88_idcount; i++) 
+		if (pci_dev->subsystem_vendor == cx88_subids[i].subvendor &&
+		    pci_dev->subsystem_device == cx88_subids[i].subdevice)
+			dev->board = cx88_subids[i].card;
+	if (UNSET == dev->board)
+		dev->board = CX88_BOARD_UNKNOWN;
+        printk(KERN_INFO "%s: subsystem: %04x:%04x, board: %s [card=%d,%s]\n",
+	       dev->name,pci_dev->subsystem_vendor,
+	       pci_dev->subsystem_device,cx88_boards[dev->board].name,
+	       dev->board, card[cx8800_devcount] == dev->board ?
+	       "insmod option" : "autodetected");
+
+	dev->tuner_type = tuner[cx8800_devcount];
+	if (UNSET == dev->tuner_type)
+		dev->tuner_type = cx88_boards[dev->board].tuner_type;
+
+	/* get mmio */
+	if (!request_mem_region(pci_resource_start(pci_dev,0),
+				pci_resource_len(pci_dev,0),
+				dev->name)) {
+		err = -EBUSY;
+		printk(KERN_ERR "%s: can't get MMIO memory @ 0x%lx\n",
+		       dev->name,pci_resource_start(pci_dev,0));
+		goto fail1;
+	}
+	dev->lmmio = ioremap(pci_resource_start(pci_dev,0),
+			     pci_resource_len(pci_dev,0));
+
+	/* initialize driver struct */
+        init_MUTEX(&dev->lock);
+	dev->slock = SPIN_LOCK_UNLOCKED;
+	dev->tvnorm = tvnorms;
+
+	/* init dma queues */
+	INIT_LIST_HEAD(&dev->vidq.active);
+	INIT_LIST_HEAD(&dev->vidq.queued);
+	dev->vidq.timeout.function = cx8800_vid_timeout;
+	dev->vidq.timeout.data     = (unsigned long)dev;
+	init_timer(&dev->vidq.timeout);
+	cx88_risc_stopper(dev->pci,&dev->vidq.stopper,
+			  MO_VID_DMACNTRL,0x11,0x00);
+	
+	/* initialize hardware */
+	cx8800_reset(dev);
+
+	/* get irq */
+	err = request_irq(pci_dev->irq, cx8800_irq,
+			  SA_SHIRQ | SA_INTERRUPT, dev->name, dev);
+	if (err < 0) {
+		printk(KERN_ERR "%s: can't get IRQ %d\n",
+		       dev->name,pci_dev->irq);
+		goto fail2;
+	}
+
+	/* register i2c bus + load i2c helpers */
+	cx8800_i2c_init(dev);
+	cx88_card_setup(dev);
+
+	/* load and configure helper modules */
+	if (TUNER_ABSENT != dev->tuner_type)
+		request_module("tuner");
+	if (dev->tuner_type != UNSET)
+		cx8800_call_i2c_clients(dev,TUNER_SET_TYPE,&dev->tuner_type);
+
+	/* register v4l devices */
+	dev->video_dev = vdev_init(dev,&cx8800_video_template,"video");
+	err = video_register_device(dev->video_dev,VFL_TYPE_GRABBER,
+				    video_nr[cx8800_devcount]);
+	if (err < 0) {
+		printk(KERN_INFO "%s: can't register video device\n",
+		       dev->name);
+		goto fail3;
+	}
+	printk(KERN_INFO "%s: registered device video%d [v4l2]\n",
+	       dev->name,dev->video_dev->minor & 0x1f);
+
+	if (dev->has_radio) {
+		dev->radio_dev = vdev_init(dev,&cx8800_radio_template,"radio");
+		err = video_register_device(dev->radio_dev,VFL_TYPE_RADIO,
+					    radio_nr[cx8800_devcount]);
+		if (err < 0) {
+			printk(KERN_INFO "%s: can't register radio device\n",
+			       dev->name);
+			goto fail3;
+		}
+		printk(KERN_INFO "%s: registered device radio%d\n",
+		       dev->name,dev->radio_dev->minor & 0x1f);
+	}
+
+	/* everything worked */
+	list_add_tail(&dev->devlist,&cx8800_devlist);
+	pci_set_drvdata(pci_dev,dev);
+	cx8800_devcount++;
+
+	/* initial device configuration */
+	down(&dev->lock);
+	set_tvnorm(dev,tvnorms);
+	video_mux(dev,0);
+	up(&dev->lock);
+	return 0;
+
+ fail3:
+	cx8800_unregister_video(dev);
+	if (0 == dev->i2c_rc)
+		i2c_bit_del_bus(&dev->i2c_adap);
+	free_irq(pci_dev->irq, dev);
+ fail2:
+	release_mem_region(pci_resource_start(pci_dev,0),
+			   pci_resource_len(pci_dev,0));
+ fail1:
+	kfree(dev);
+	return err;
+}
+
+static void __devexit cx8800_finidev(struct pci_dev *pci_dev)
+{
+        struct cx8800_dev *dev = pci_get_drvdata(pci_dev);
+
+	cx8800_shutdown(dev);
+	pci_disable_device(pci_dev);
+
+	/* unregister stuff */	
+	if (0 == dev->i2c_rc)
+		i2c_bit_del_bus(&dev->i2c_adap);
+
+	free_irq(pci_dev->irq, dev);
+	release_mem_region(pci_resource_start(pci_dev,0),
+			   pci_resource_len(pci_dev,0));
+
+	cx8800_unregister_video(dev);
+	pci_set_drvdata(pci_dev, NULL);
+
+	/* free memory */
+	btcx_riscmem_free(dev->pci,&dev->vidq.stopper);
+	list_del(&dev->devlist);
+	cx8800_devcount--;
+	kfree(dev);
+}
+
+static int cx8800_suspend(struct pci_dev *pci_dev, u32 state)
+{
+        struct cx8800_dev *dev = pci_get_drvdata(pci_dev);
+
+	printk("%s: suspend %d\n", dev->name, state);
+
+	cx8800_shutdown(dev);
+	del_timer(&dev->vidq.timeout);
+	
+	pci_save_state(pci_dev, dev->state.pci_cfg);
+	if (0 != pci_set_power_state(pci_dev, state)) {
+		pci_disable_device(pci_dev);
+		dev->state.disabled = 1;
+	}
+	return 0;
+}
+
+static int cx8800_resume(struct pci_dev *pci_dev)
+{
+        struct cx8800_dev *dev = pci_get_drvdata(pci_dev);
+
+	printk("%s: resume\n", dev->name);
+
+	if (dev->state.disabled) {
+		pci_enable_device(pci_dev);
+		dev->state.disabled = 0;
+	}
+	pci_set_power_state(pci_dev, 0);
+	pci_restore_state(pci_dev, dev->state.pci_cfg);
+
+	/* re-initialize hardware */
+	cx8800_reset(dev);
+
+	/* restart video capture */
+	spin_lock(&dev->slock);
+	restart_video_queue(dev,&dev->vidq);
+	spin_unlock(&dev->slock);
+
+	return 0;
+}
+
+/* ----------------------------------------------------------- */
+
+struct pci_device_id cx8800_pci_tbl[] = {
+	{
+		.vendor       = 0x14f1,
+		.device       = 0x8800,
+                .subvendor    = PCI_ANY_ID,
+                .subdevice    = PCI_ANY_ID,
+	},{
+		/* --- end of list --- */
+	}
+};
+MODULE_DEVICE_TABLE(pci, cx8800_pci_tbl);
+
+static struct pci_driver cx8800_pci_driver = {
+        .name     = "cx8800",
+        .id_table = cx8800_pci_tbl,
+        .probe    = cx8800_initdev,
+        .remove   = cx8800_finidev,
+
+	.suspend  = cx8800_suspend,
+	.resume   = cx8800_resume,
+};
+
+static int cx8800_init(void)
+{
+	INIT_LIST_HEAD(&cx8800_devlist);
+	printk(KERN_INFO "cx2388x v4l2 driver version %d.%d.%d loaded\n",
+	       (CX88_VERSION_CODE >> 16) & 0xff,
+	       (CX88_VERSION_CODE >>  8) & 0xff,
+	       CX88_VERSION_CODE & 0xff);
+#ifdef SNAPSHOT
+	printk(KERN_INFO "cx2388x: snapshot date %04d-%02d-%02d\n",
+	       SNAPSHOT/10000, (SNAPSHOT/100)%100, SNAPSHOT%100);
+#endif
+	return pci_module_init(&cx8800_pci_driver);
+}
+
+static void cx8800_fini(void)
+{
+	pci_unregister_driver(&cx8800_pci_driver);
+}
+
+module_init(cx8800_init);
+module_exit(cx8800_fini);
+
+/* ----------------------------------------------------------- */
+/*
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
diff -u linux-2.6.1/drivers/media/video/cx88/cx88.h linux/drivers/media/video/cx88/cx88.h
--- linux-2.6.1/drivers/media/video/cx88/cx88.h	2004-01-14 14:36:15.449002728 +0100
+++ linux/drivers/media/video/cx88/cx88.h	2004-01-14 14:57:38.560600436 +0100
@@ -0,0 +1,342 @@
+/*
+ * v4l2 device driver for philips saa7134 based TV cards
+ *
+ * (c) 2001,02 Gerd Knorr <kraxel@bytesex.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/pci.h>
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+#include <linux/videodev.h>
+#include <linux/kdev_t.h>
+
+#include <media/video-buf.h>
+#include <media/tuner.h>
+#include <media/audiochip.h>
+#if __GNUC__ < 3
+# error gcc 3.x required, sorry.
+#endif
+
+#include "btcx-risc.h"
+#include "cx88-reg.h"
+
+#include <linux/version.h>
+#define CX88_VERSION_CODE KERNEL_VERSION(0,0,1)
+
+#ifndef TRUE
+# define TRUE (1==1)
+#endif
+#ifndef FALSE
+# define FALSE (1==0)
+#endif
+#define UNSET (-1U)
+
+#define CX88_MAXBOARDS 8
+
+/* ----------------------------------------------------------- */
+/* defines and enums                                           */
+
+#define FORMAT_FLAGS_PACKED       0x01
+#define FORMAT_FLAGS_PLANAR       0x02
+
+/* ----------------------------------------------------------- */
+/* static data                                                 */
+
+struct cx8800_tvnorm {
+	char                   *name;
+	v4l2_std_id            id;
+	u32                    cxiformat;
+	u32                    cxoformat;
+};
+
+struct cx8800_fmt {
+	char  *name;
+	u32   fourcc;          /* v4l2 format id */
+	int   depth;
+	int   flags;
+	u32   cxformat;
+};
+
+struct cx88_ctrl {
+	struct v4l2_queryctrl  v;
+	u32                    off;
+	u32                    reg;
+	u32                    mask;
+	u32                    shift;
+};
+
+/* ----------------------------------------------------------- */
+/* SRAM memory management data (see cx88-core.c)               */
+
+#define SRAM_CH21 0   /* video */
+#define SRAM_CH22 1
+#define SRAM_CH23 2
+#define SRAM_CH24 3   /* vbi   */
+#define SRAM_CH25 4   /* audio */
+#define SRAM_CH26 5
+/* more */
+
+struct sram_channel {
+	char *name;
+	u32  cmds_start;
+	u32  ctrl_start;
+	u32  fifo_start;
+	u32  fifo_size;
+	u32  ptr1_reg;
+	u32  ptr2_reg;
+	u32  cnt1_reg;
+	u32  cnt2_reg;
+};
+extern struct sram_channel cx88_sram_channels[];
+
+/* ----------------------------------------------------------- */
+/* card configuration                                          */
+
+#define CX88_BOARD_NOAUTO        UNSET
+#define CX88_BOARD_UNKNOWN           0
+#define CX88_BOARD_HAUPPAUGE         1
+#define CX88_BOARD_GDI               2
+#define CX88_BOARD_PIXELVIEW         3
+#define CX88_BOARD_ATI_WONDER_PRO    4
+#define CX88_BOARD_WINFAST2000XP     5
+#define CX88_BOARD_AVERTV_303        6
+#define CX88_BOARD_MSI_TVANYWHERE    7
+#define CX88_BOARD_WINFAST_DV2000    8
+
+
+enum cx88_itype {
+	CX88_VMUX_COMPOSITE1 = 1,
+	CX88_VMUX_COMPOSITE2 = 2,
+	CX88_VMUX_COMPOSITE3 = 3,
+	CX88_VMUX_COMPOSITE4 = 4,
+	CX88_VMUX_TELEVISION = 5,
+	CX88_VMUX_SVIDEO     = 6,
+	CX88_VMUX_DEBUG      = 7,
+	CX88_RADIO           = 8,
+};
+
+struct cx88_input {
+	enum cx88_itype type;
+	unsigned int    vmux;
+	u32             gpio0;
+};
+
+struct cx88_board {
+	char                    *name;
+	unsigned int            tuner_type;
+	struct cx88_input       input[8];
+	struct cx88_input       radio;
+};
+
+struct cx88_subid {
+	u16     subvendor;
+	u16     subdevice;
+	u32     card;
+};
+
+#define INPUT(nr) (&cx88_boards[dev->board].input[nr])
+
+/* ----------------------------------------------------------- */
+/* device / file handle status                                 */
+
+#define RESOURCE_OVERLAY       1
+#define RESOURCE_VIDEO         2
+#define RESOURCE_VBI           4
+
+//#define BUFFER_TIMEOUT     (HZ/2)  /* 0.5 seconds */
+#define BUFFER_TIMEOUT     (HZ*2)
+
+struct cx8800_dev;
+
+/* buffer for one video frame */
+struct cx88_buffer {
+	/* common v4l buffer stuff -- must be first */
+	struct videobuf_buffer vb;
+
+	/* cx88 specific */
+	unsigned int           bpl;
+	struct btcx_riscmem    risc;
+	struct cx8800_fmt      *fmt;
+	u32                    count;
+};
+
+struct cx88_dmaqueue {
+	struct list_head       active;
+	struct list_head       queued;
+	struct timer_list      timeout;
+	struct btcx_riscmem    stopper;
+	u32                    count;
+};
+
+/* video filehandle status */
+struct cx8800_fh {
+	struct cx8800_dev          *dev;
+	enum v4l2_buf_type         type;
+	int                        radio;
+	unsigned int               resources;
+
+	/* video overlay */
+	struct v4l2_window         win;
+	struct v4l2_clip           *clips;
+	unsigned int               nclips;
+
+	/* video capture */
+	struct cx8800_fmt          *fmt;
+	unsigned int               width,height;
+	struct videobuf_queue      vidq;
+};
+
+struct cx8800_suspend_state {
+	u32                        pci_cfg[64 / sizeof(u32)];
+	int                        disabled;
+};
+
+/* global device status */
+struct cx8800_dev {
+	struct list_head           devlist;
+        struct semaphore           lock;
+       	spinlock_t                 slock;
+
+	/* various device info */
+	unsigned int               resources;
+	struct video_device        *video_dev;
+	struct video_device        *radio_dev;
+
+	/* pci i/o */
+	char                       name[32];
+	struct pci_dev             *pci;
+	unsigned char              pci_rev,pci_lat;
+        u32                        *lmmio;
+
+	/* config info */
+	unsigned int               board;
+	unsigned int               tuner_type;
+	unsigned int               has_radio;
+
+	/* i2c i/o */
+	struct i2c_adapter         i2c_adap;
+	struct i2c_algo_bit_data   i2c_algo;
+	struct i2c_client          i2c_client;
+	u32                        i2c_state, i2c_rc;
+
+	/* video overlay */
+	struct v4l2_framebuffer    fbuf;
+	struct cx88_buffer         *screen;
+
+	/* capture queues */
+	struct cx88_dmaqueue       vidq;
+
+	/* various v4l controls */
+	struct cx8800_tvnorm       *tvnorm;
+	u32                        tvaudio;
+	u32                        input;
+	u32                        freq;
+
+	/* other global state info */
+	struct cx8800_suspend_state state;
+};
+
+/* ----------------------------------------------------------- */
+
+#define cx_read(reg)             readl(dev->lmmio + ((reg)>>2))
+#define cx_write(reg,value)      writel((value), dev->lmmio + ((reg)>>2));
+
+#define cx_andor(reg,mask,value) \
+  writel((readl(dev->lmmio+((reg)>>2)) & ~(mask)) |\
+  ((value) & (mask)), dev->lmmio+((reg)>>2))
+#define cx_set(reg,bit)          cx_andor((reg),(bit),(bit))
+#define cx_clear(reg,bit)        cx_andor((reg),(bit),0)
+
+#define cx_wait(d) { if (need_resched()) schedule(); else udelay(d);}
+
+
+/* ----------------------------------------------------------- */
+/* cx88-core.c                                                 */
+
+extern char *cx88_pci_irqs[32];
+extern char *cx88_vid_irqs[32];
+extern void cx88_print_irqbits(char *name, char *tag, char **strings,
+			       u32 bits, u32 mask);
+extern void cx88_print_ioctl(char *name, unsigned int cmd);
+
+extern int
+cx88_risc_buffer(struct pci_dev *pci, struct btcx_riscmem *risc,
+		 struct scatterlist *sglist,
+		 unsigned int top_offset, unsigned int bottom_offset,
+		 unsigned int bpl, unsigned int padding, unsigned int lines);
+extern int
+cx88_risc_stopper(struct pci_dev *pci, struct btcx_riscmem *risc,
+		  u32 reg, u32 mask, u32 value);
+extern void
+cx88_free_buffer(struct pci_dev *pci, struct cx88_buffer *buf);
+
+extern void cx88_risc_disasm(struct cx8800_dev *dev,
+			     struct btcx_riscmem *risc);
+
+extern int cx88_sram_channel_setup(struct cx8800_dev *dev,
+				   struct sram_channel *ch,
+				   unsigned int bpl, u32 risc);
+extern void cx88_sram_channel_dump(struct cx8800_dev *dev,
+				   struct sram_channel *ch);
+
+extern int cx88_pci_quirks(char *name, struct pci_dev *pci,
+			   unsigned int *latency);
+
+/* ----------------------------------------------------------- */
+/* cx88-i2c.c                                                  */
+
+extern int cx8800_i2c_init(struct cx8800_dev *dev);
+extern void cx8800_call_i2c_clients(struct cx8800_dev *dev,
+				    unsigned int cmd, void *arg);
+
+
+/* ----------------------------------------------------------- */
+/* cx88-cards.c                                                */
+
+extern struct cx88_board cx88_boards[];
+extern const unsigned int cx88_bcount;
+
+extern struct cx88_subid cx88_subids[];
+extern const unsigned int cx88_idcount;
+
+extern void cx88_card_setup(struct cx8800_dev *dev);
+
+/* ----------------------------------------------------------- */
+/* cx88-tvaudio.c                                              */
+
+#define WW_NONE		 1
+#define WW_BTSC		 2
+#define WW_NICAM_I	 3
+#define WW_NICAM_BGDKL	 4
+#define WW_A1		 5
+#define WW_A2_BG	 6
+#define WW_A2_DK	 7
+#define WW_A2_M		 8
+#define WW_EIAJ		 9
+#define WW_SYSTEM_L_AM	10
+#define WW_I2SPT	11
+#define WW_FM		12
+
+void cx88_set_tvaudio(struct cx8800_dev *dev);
+void cx88_get_stereo(struct cx8800_dev *dev, struct v4l2_tuner *t);
+void cx88_set_stereo(struct cx8800_dev *dev, u32 mode);
+
+/*
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */

From: Jing Huang <huangj@Brocade.COM>
Subject: Update bfa driver to version 2.1.2.1
References: bnc#561881

This patch updates the bfa driver to version 2.1.2.1.

Acked-by: Hannes Reinecke <hare@suse.de>

diff -uprN a/drivers/scsi/bfa/Makefile b/drivers/scsi/bfa/Makefile
--- a/drivers/scsi/bfa/Makefile	2009-12-18 18:16:22.511686000 -0800
+++ b/drivers/scsi/bfa/Makefile	2009-11-25 18:27:13.000000000 -0800
@@ -2,8 +2,8 @@ obj-$(CONFIG_SCSI_BFA_FC) := bfa.o
 
 bfa-y := bfad.o bfad_intr.o bfad_os.o bfad_im.o bfad_attr.o bfad_fwimg.o
 
-bfa-y += bfa_core.o bfa_ioc.o bfa_iocfc.o bfa_fcxp.o bfa_lps.o
-bfa-y += bfa_hw_cb.o bfa_hw_ct.o bfa_intr.o bfa_timer.o bfa_rport.o 
+bfa-y += bfa_core.o bfa_ioc.o bfa_ioc_ct.o bfa_ioc_cb.o bfa_iocfc.o bfa_fcxp.o
+bfa-y += bfa_lps.o bfa_hw_cb.o bfa_hw_ct.o bfa_intr.o bfa_timer.o bfa_rport.o 
 bfa-y += bfa_fcport.o bfa_port.o bfa_uf.o bfa_sgpg.o bfa_module.o bfa_ioim.o
 bfa-y += bfa_itnim.o bfa_fcpim.o bfa_tskim.o bfa_log.o bfa_log_module.o
 bfa-y += bfa_csdebug.o bfa_sm.o plog.o
@@ -12,4 +12,4 @@ bfa-y += fcbuild.o fabric.o fcpim.o vfap
 bfa-y += bfa_fcs_uf.o bfa_fcs_lport.o fab.o fdmi.o ms.o ns.o scn.o loop.o
 bfa-y += lport_api.o n2n.o rport.o rport_api.o rport_ftrs.o vport.o
 
-ccflags-y := -I$(obj) -I$(obj)/include -I$(obj)/include/cna
+ccflags-y := -I$(obj) -I$(obj)/include -I$(obj)/include/cna -DBFA_PERF_BUILD
diff -uprN a/drivers/scsi/bfa/bfa_cb_ioim_macros.h b/drivers/scsi/bfa/bfa_cb_ioim_macros.h
--- a/drivers/scsi/bfa/bfa_cb_ioim_macros.h	2009-12-18 18:16:22.508683000 -0800
+++ b/drivers/scsi/bfa/bfa_cb_ioim_macros.h	2009-11-25 18:06:50.000000000 -0800
@@ -51,7 +51,7 @@ bfad_int_to_lun(u32 luno)
 	lun.bfa_lun     = 0;
 	lun.scsi_lun[0] = bfa_os_htons(luno);
 
-	return (lun.bfa_lun);
+	return lun.bfa_lun;
 }
 
 /**
@@ -68,7 +68,7 @@ bfa_cb_ioim_get_cdb(struct bfad_ioim_s *
 {
 	struct scsi_cmnd *cmnd = (struct scsi_cmnd *)dio;
 
-	return ((u8 *) cmnd->cmnd);
+	return (u8 *) cmnd->cmnd;
 }
 
 /**
@@ -97,7 +97,7 @@ bfa_cb_ioim_get_size(struct bfad_ioim_s 
 {
 	struct scsi_cmnd *cmnd = (struct scsi_cmnd *)dio;
 
-	return (scsi_bufflen(cmnd));
+	return scsi_bufflen(cmnd);
 }
 
 /**
@@ -129,7 +129,7 @@ bfa_cb_ioim_get_sgaddr(struct bfad_ioim_
 	sge = (struct scatterlist *)scsi_sglist(cmnd) + sgeid;
 	addr = (u64) sg_dma_address(sge);
 
-	return (*(union bfi_addr_u *) &addr);
+	return *(union bfi_addr_u *) &addr;
 }
 
 static inline u32
@@ -197,7 +197,7 @@ bfa_cb_ioim_get_cdblen(struct bfad_ioim_
 {
 	struct scsi_cmnd *cmnd = (struct scsi_cmnd *)dio;
 
-	return (cmnd->cmd_len);
+	return cmnd->cmd_len;
 }
 
 
diff -uprN a/drivers/scsi/bfa/bfa_cee.c b/drivers/scsi/bfa/bfa_cee.c
--- a/drivers/scsi/bfa/bfa_cee.c	2009-12-18 18:16:22.506684000 -0800
+++ b/drivers/scsi/bfa/bfa_cee.c	2009-11-25 18:21:06.000000000 -0800
@@ -30,14 +30,13 @@ BFA_TRC_FILE(CNA, CEE);
 #define bfa_ioc_portid(__ioc) ((__ioc)->port_id)
 #define bfa_lpuid(__arg) bfa_ioc_portid(&(__arg)->ioc)
 
-static void     bfa_cee_format_lldp_cfg(struct bfa_cee_lldp_cfg_s *lldp_cfg);
-static void     bfa_cee_format_dcbcx_stats(struct bfa_cee_dcbx_stats_s
-					   *dcbcx_stats);
-static void     bfa_cee_format_lldp_stats(struct bfa_cee_lldp_stats_s
-					  *lldp_stats);
-static void     bfa_cee_format_cfg_stats(struct bfa_cee_cfg_stats_s *cfg_stats);
-static void     bfa_cee_format_cee_cfg(void *buffer);
-static void     bfa_cee_format_cee_stats(void *buffer);
+static void bfa_cee_format_lldp_cfg(struct bfa_cee_lldp_cfg_s *lldp_cfg);
+static void
+bfa_cee_format_dcbcx_stats(struct bfa_cee_dcbx_stats_s *dcbcx_stats);
+static void bfa_cee_format_lldp_stats(struct bfa_cee_lldp_stats_s *lldp_stats);
+static void bfa_cee_format_cfg_stats(struct bfa_cee_cfg_stats_s *cfg_stats);
+static void bfa_cee_format_cee_cfg(void *buffer);
+static void bfa_cee_format_cee_stats(void *buffer);
 
 static void
 bfa_cee_format_cee_stats(void *buffer)
@@ -55,57 +54,72 @@ bfa_cee_format_cee_cfg(void *buffer)
 	bfa_cee_format_lldp_cfg(&cee_cfg->lldp_remote);
 }
 
+
 static void
 bfa_cee_format_dcbcx_stats(struct bfa_cee_dcbx_stats_s *dcbcx_stats)
 {
-	dcbcx_stats->subtlvs_unrecognized =
-		bfa_os_ntohl(dcbcx_stats->subtlvs_unrecognized);
+	dcbcx_stats->subtlvs_unrecognized  =
+			bfa_os_ntohl(dcbcx_stats->subtlvs_unrecognized);
 	dcbcx_stats->negotiation_failed =
-		bfa_os_ntohl(dcbcx_stats->negotiation_failed);
+			bfa_os_ntohl(dcbcx_stats->negotiation_failed);
 	dcbcx_stats->remote_cfg_changed =
-		bfa_os_ntohl(dcbcx_stats->remote_cfg_changed);
-	dcbcx_stats->tlvs_received = bfa_os_ntohl(dcbcx_stats->tlvs_received);
-	dcbcx_stats->tlvs_invalid = bfa_os_ntohl(dcbcx_stats->tlvs_invalid);
-	dcbcx_stats->seqno = bfa_os_ntohl(dcbcx_stats->seqno);
-	dcbcx_stats->ackno = bfa_os_ntohl(dcbcx_stats->ackno);
-	dcbcx_stats->recvd_seqno = bfa_os_ntohl(dcbcx_stats->recvd_seqno);
-	dcbcx_stats->recvd_ackno = bfa_os_ntohl(dcbcx_stats->recvd_ackno);
+			bfa_os_ntohl(dcbcx_stats->remote_cfg_changed);
+	dcbcx_stats->tlvs_received =
+			bfa_os_ntohl(dcbcx_stats->tlvs_received);
+	dcbcx_stats->tlvs_invalid =
+			bfa_os_ntohl(dcbcx_stats->tlvs_invalid);
+	dcbcx_stats->seqno =
+			bfa_os_ntohl(dcbcx_stats->seqno);
+	dcbcx_stats->ackno =
+			bfa_os_ntohl(dcbcx_stats->ackno);
+	dcbcx_stats->recvd_seqno =
+			bfa_os_ntohl(dcbcx_stats->recvd_seqno);
+	dcbcx_stats->recvd_ackno =
+			bfa_os_ntohl(dcbcx_stats->recvd_ackno);
 }
 
 static void
 bfa_cee_format_lldp_stats(struct bfa_cee_lldp_stats_s *lldp_stats)
 {
 	lldp_stats->frames_transmitted =
-		bfa_os_ntohl(lldp_stats->frames_transmitted);
-	lldp_stats->frames_aged_out = bfa_os_ntohl(lldp_stats->frames_aged_out);
-	lldp_stats->frames_discarded =
-		bfa_os_ntohl(lldp_stats->frames_discarded);
-	lldp_stats->frames_in_error = bfa_os_ntohl(lldp_stats->frames_in_error);
-	lldp_stats->frames_rcvd = bfa_os_ntohl(lldp_stats->frames_rcvd);
-	lldp_stats->tlvs_discarded = bfa_os_ntohl(lldp_stats->tlvs_discarded);
-	lldp_stats->tlvs_unrecognized =
-		bfa_os_ntohl(lldp_stats->tlvs_unrecognized);
+			bfa_os_ntohl(lldp_stats->frames_transmitted);
+	lldp_stats->frames_aged_out    =
+			bfa_os_ntohl(lldp_stats->frames_aged_out);
+	lldp_stats->frames_discarded   =
+			bfa_os_ntohl(lldp_stats->frames_discarded);
+	lldp_stats->frames_in_error    =
+			bfa_os_ntohl(lldp_stats->frames_in_error);
+	lldp_stats->frames_rcvd        =
+			bfa_os_ntohl(lldp_stats->frames_rcvd);
+	lldp_stats->tlvs_discarded     =
+			bfa_os_ntohl(lldp_stats->tlvs_discarded);
+	lldp_stats->tlvs_unrecognized  =
+			bfa_os_ntohl(lldp_stats->tlvs_unrecognized);
 }
 
 static void
 bfa_cee_format_cfg_stats(struct bfa_cee_cfg_stats_s *cfg_stats)
 {
-	cfg_stats->cee_status_down = bfa_os_ntohl(cfg_stats->cee_status_down);
-	cfg_stats->cee_status_up = bfa_os_ntohl(cfg_stats->cee_status_up);
-	cfg_stats->cee_hw_cfg_changed =
-		bfa_os_ntohl(cfg_stats->cee_hw_cfg_changed);
-	cfg_stats->recvd_invalid_cfg =
-		bfa_os_ntohl(cfg_stats->recvd_invalid_cfg);
+	cfg_stats->cee_status_down         =
+			bfa_os_ntohl(cfg_stats->cee_status_down);
+	cfg_stats->cee_status_up           =
+			bfa_os_ntohl(cfg_stats->cee_status_up);
+	cfg_stats->cee_hw_cfg_changed      =
+			bfa_os_ntohl(cfg_stats->cee_hw_cfg_changed);
+	cfg_stats->recvd_invalid_cfg      =
+			bfa_os_ntohl(cfg_stats->recvd_invalid_cfg);
 }
 
 static void
 bfa_cee_format_lldp_cfg(struct bfa_cee_lldp_cfg_s *lldp_cfg)
 {
-	lldp_cfg->time_to_interval = bfa_os_ntohs(lldp_cfg->time_to_interval);
+	lldp_cfg->time_to_interval =
+			bfa_os_ntohs(lldp_cfg->time_to_interval);
 	lldp_cfg->enabled_system_cap =
-		bfa_os_ntohs(lldp_cfg->enabled_system_cap);
+			bfa_os_ntohs(lldp_cfg->enabled_system_cap);
 }
 
+
 /**
  * bfa_cee_attr_meminfo()
  *
@@ -114,12 +128,11 @@ bfa_cee_format_lldp_cfg(struct bfa_cee_l
  *
  * @return Size of DMA region
  */
-static          u32
+static u32
 bfa_cee_attr_meminfo(void)
 {
 	return BFA_ROUNDUP(sizeof(struct bfa_cee_attr_s), BFA_DMA_ALIGN_SZ);
 }
-
 /**
  * bfa_cee_stats_meminfo()
  *
@@ -128,7 +141,7 @@ bfa_cee_attr_meminfo(void)
  *
  * @return Size of DMA region
  */
-static          u32
+static u32
 bfa_cee_stats_meminfo(void)
 {
 	return BFA_ROUNDUP(sizeof(struct bfa_cee_stats_s), BFA_DMA_ALIGN_SZ);
@@ -150,12 +163,11 @@ bfa_cee_get_attr_isr(struct bfa_cee_s *c
 	bfa_trc(cee, 0);
 	if (status == BFA_STATUS_OK) {
 		bfa_trc(cee, 0);
-		/*
-		 * The requested data has been copied to the DMA area, *process
-		 * it.
+		/* The requested data has been copied to the DMA area,
+		 * process it.
 		 */
 		memcpy(cee->attr, cee->attr_dma.kva,
-		       sizeof(struct bfa_cee_attr_s));
+		    sizeof(struct bfa_cee_attr_s));
 		bfa_cee_format_cee_cfg(cee->attr);
 	}
 	cee->get_attr_pending = BFA_FALSE;
@@ -182,12 +194,11 @@ bfa_cee_get_stats_isr(struct bfa_cee_s *
 	bfa_trc(cee, 0);
 	if (status == BFA_STATUS_OK) {
 		bfa_trc(cee, 0);
-		/*
-		 * The requested data has been copied to the DMA area, process
-		 * it.
+		/* The requested data has been copied to the DMA area,
+		 * process it.
 		 */
 		memcpy(cee->stats, cee->stats_dma.kva,
-		       sizeof(struct bfa_cee_stats_s));
+					sizeof(struct bfa_cee_stats_s));
 		bfa_cee_format_cee_stats(cee->stats);
 	}
 	cee->get_stats_pending = BFA_FALSE;
@@ -216,7 +227,6 @@ bfa_cee_reset_stats_isr(struct bfa_cee_s
 	if (cee->cbfn.reset_stats_cbfn)
 		cee->cbfn.reset_stats_cbfn(cee->cbfn.reset_stats_cbarg, status);
 }
-
 /**
  * bfa_cee_meminfo()
  *
@@ -228,7 +238,7 @@ bfa_cee_reset_stats_isr(struct bfa_cee_s
 u32
 bfa_cee_meminfo(void)
 {
-	return (bfa_cee_attr_meminfo() + bfa_cee_stats_meminfo());
+	return bfa_cee_attr_meminfo() + bfa_cee_stats_meminfo();
 }
 
 /**
@@ -236,8 +246,8 @@ bfa_cee_meminfo(void)
  *
  *
  * @param[in] cee CEE module pointer
- * 	      dma_kva Kernel Virtual Address of CEE DMA Memory
- * 	      dma_pa  Physical Address of CEE DMA Memory
+ *	      dma_kva Kernel Virtual Address of CEE DMA Memory
+ *	      dma_pa  Physical Address of CEE DMA Memory
  *
  * @return void
  */
@@ -248,9 +258,9 @@ bfa_cee_mem_claim(struct bfa_cee_s *cee,
 	cee->attr_dma.pa = dma_pa;
 	cee->stats_dma.kva = dma_kva + bfa_cee_attr_meminfo();
 	cee->stats_dma.pa = dma_pa + bfa_cee_attr_meminfo();
-	cee->attr = (struct bfa_cee_attr_s *)dma_kva;
+	cee->attr = (struct bfa_cee_attr_s *) dma_kva;
 	cee->stats =
-		(struct bfa_cee_stats_s *)(dma_kva + bfa_cee_attr_meminfo());
+		(struct bfa_cee_stats_s *) (dma_kva + bfa_cee_attr_meminfo());
 }
 
 /**
@@ -265,7 +275,7 @@ bfa_cee_mem_claim(struct bfa_cee_s *cee,
 
 bfa_status_t
 bfa_cee_get_attr(struct bfa_cee_s *cee, struct bfa_cee_attr_s *attr,
-		 bfa_cee_get_attr_cbfn_t cbfn, void *cbarg)
+		     bfa_cee_get_attr_cbfn_t cbfn, void *cbarg)
 {
 	struct bfi_cee_get_req_s *cmd;
 
@@ -277,15 +287,15 @@ bfa_cee_get_attr(struct bfa_cee_s *cee, 
 	}
 	if (cee->get_attr_pending == BFA_TRUE) {
 		bfa_trc(cee, 0);
-		return BFA_STATUS_DEVBUSY;
+		return 	BFA_STATUS_DEVBUSY;
 	}
 	cee->get_attr_pending = BFA_TRUE;
-	cmd = (struct bfi_cee_get_req_s *)cee->get_cfg_mb.msg;
+	cmd = (struct bfi_cee_get_req_s *) cee->get_cfg_mb.msg;
 	cee->attr = attr;
 	cee->cbfn.get_attr_cbfn = cbfn;
 	cee->cbfn.get_attr_cbarg = cbarg;
 	bfi_h2i_set(cmd->mh, BFI_MC_CEE, BFI_CEE_H2I_GET_CFG_REQ,
-		    bfa_ioc_portid(cee->ioc));
+	    bfa_ioc_portid(cee->ioc));
 	bfa_dma_be_addr_set(cmd->dma_addr, cee->attr_dma.pa);
 	bfa_ioc_mbox_queue(cee->ioc, &cee->get_cfg_mb);
 	bfa_trc(cee, 0);
@@ -305,7 +315,7 @@ bfa_cee_get_attr(struct bfa_cee_s *cee, 
 
 bfa_status_t
 bfa_cee_get_stats(struct bfa_cee_s *cee, struct bfa_cee_stats_s *stats,
-		  bfa_cee_get_stats_cbfn_t cbfn, void *cbarg)
+		      bfa_cee_get_stats_cbfn_t cbfn, void *cbarg)
 {
 	struct bfi_cee_get_req_s *cmd;
 
@@ -317,15 +327,15 @@ bfa_cee_get_stats(struct bfa_cee_s *cee,
 	}
 	if (cee->get_stats_pending == BFA_TRUE) {
 		bfa_trc(cee, 0);
-		return BFA_STATUS_DEVBUSY;
+		return 	BFA_STATUS_DEVBUSY;
 	}
 	cee->get_stats_pending = BFA_TRUE;
-	cmd = (struct bfi_cee_get_req_s *)cee->get_stats_mb.msg;
+	cmd = (struct bfi_cee_get_req_s *) cee->get_stats_mb.msg;
 	cee->stats = stats;
 	cee->cbfn.get_stats_cbfn = cbfn;
 	cee->cbfn.get_stats_cbarg = cbarg;
 	bfi_h2i_set(cmd->mh, BFI_MC_CEE, BFI_CEE_H2I_GET_STATS_REQ,
-		    bfa_ioc_portid(cee->ioc));
+	    bfa_ioc_portid(cee->ioc));
 	bfa_dma_be_addr_set(cmd->dma_addr, cee->stats_dma.pa);
 	bfa_ioc_mbox_queue(cee->ioc, &cee->get_stats_mb);
 	bfa_trc(cee, 0);
@@ -344,7 +354,7 @@ bfa_cee_get_stats(struct bfa_cee_s *cee,
 
 bfa_status_t
 bfa_cee_reset_stats(struct bfa_cee_s *cee, bfa_cee_reset_stats_cbfn_t cbfn,
-		    void *cbarg)
+			void *cbarg)
 {
 	struct bfi_cee_reset_stats_s *cmd;
 
@@ -355,19 +365,20 @@ bfa_cee_reset_stats(struct bfa_cee_s *ce
 	}
 	if (cee->reset_stats_pending == BFA_TRUE) {
 		bfa_trc(cee, 0);
-		return BFA_STATUS_DEVBUSY;
+		return 	BFA_STATUS_DEVBUSY;
 	}
 	cee->reset_stats_pending = BFA_TRUE;
-	cmd = (struct bfi_cee_reset_stats_s *)cee->reset_stats_mb.msg;
+	cmd = (struct bfi_cee_reset_stats_s *) cee->reset_stats_mb.msg;
 	cee->cbfn.reset_stats_cbfn = cbfn;
 	cee->cbfn.reset_stats_cbarg = cbarg;
 	bfi_h2i_set(cmd->mh, BFI_MC_CEE, BFI_CEE_H2I_RESET_STATS,
-		    bfa_ioc_portid(cee->ioc));
+	    bfa_ioc_portid(cee->ioc));
 	bfa_ioc_mbox_queue(cee->ioc, &cee->reset_stats_mb);
 	bfa_trc(cee, 0);
 	return BFA_STATUS_OK;
 }
 
+
 /**
  * bfa_cee_isrs()
  *
@@ -382,9 +393,9 @@ bfa_cee_isr(void *cbarg, struct bfi_mbms
 {
 	union bfi_cee_i2h_msg_u *msg;
 	struct bfi_cee_get_rsp_s *get_rsp;
-	struct bfa_cee_s *cee = (struct bfa_cee_s *)cbarg;
-	msg = (union bfi_cee_i2h_msg_u *)m;
-	get_rsp = (struct bfi_cee_get_rsp_s *)m;
+	struct bfa_cee_s *cee = (struct bfa_cee_s *) cbarg;
+	msg = (union bfi_cee_i2h_msg_u *) m;
+	get_rsp = (struct bfi_cee_get_rsp_s *) m;
 	bfa_trc(cee, msg->mh.msg_id);
 	switch (msg->mh.msg_id) {
 	case BFI_CEE_I2H_GET_CFG_RSP:
@@ -415,30 +426,30 @@ void
 bfa_cee_hbfail(void *arg)
 {
 	struct bfa_cee_s *cee;
-	cee = (struct bfa_cee_s *)arg;
+	cee = (struct bfa_cee_s *) arg;
 
 	if (cee->get_attr_pending == BFA_TRUE) {
 		cee->get_attr_status = BFA_STATUS_FAILED;
-		cee->get_attr_pending = BFA_FALSE;
+		cee->get_attr_pending  = BFA_FALSE;
 		if (cee->cbfn.get_attr_cbfn) {
 			cee->cbfn.get_attr_cbfn(cee->cbfn.get_attr_cbarg,
-						BFA_STATUS_FAILED);
+			    BFA_STATUS_FAILED);
 		}
 	}
 	if (cee->get_stats_pending == BFA_TRUE) {
 		cee->get_stats_status = BFA_STATUS_FAILED;
-		cee->get_stats_pending = BFA_FALSE;
+		cee->get_stats_pending  = BFA_FALSE;
 		if (cee->cbfn.get_stats_cbfn) {
 			cee->cbfn.get_stats_cbfn(cee->cbfn.get_stats_cbarg,
-						 BFA_STATUS_FAILED);
+			    BFA_STATUS_FAILED);
 		}
 	}
 	if (cee->reset_stats_pending == BFA_TRUE) {
 		cee->reset_stats_status = BFA_STATUS_FAILED;
-		cee->reset_stats_pending = BFA_FALSE;
+		cee->reset_stats_pending  = BFA_FALSE;
 		if (cee->cbfn.reset_stats_cbfn) {
 			cee->cbfn.reset_stats_cbfn(cee->cbfn.reset_stats_cbarg,
-						   BFA_STATUS_FAILED);
+			    BFA_STATUS_FAILED);
 		}
 	}
 }
@@ -458,8 +469,10 @@ bfa_cee_hbfail(void *arg)
  * @return void
  */
 void
-bfa_cee_attach(struct bfa_cee_s *cee, struct bfa_ioc_s *ioc, void *dev,
-	       struct bfa_trc_mod_s *trcmod, struct bfa_log_mod_s *logmod)
+bfa_cee_attach(struct bfa_cee_s *cee, struct bfa_ioc_s *ioc,
+		void *dev,
+		struct bfa_trc_mod_s *trcmod,
+		struct bfa_log_mod_s *logmod)
 {
 	bfa_assert(cee != NULL);
 	cee->dev = dev;
@@ -484,9 +497,7 @@ bfa_cee_attach(struct bfa_cee_s *cee, st
 void
 bfa_cee_detach(struct bfa_cee_s *cee)
 {
-	/*
-	 * For now, just check if there is some ioctl pending and mark that as
-	 * failed?
-	 */
-	/* bfa_cee_hbfail(cee); */
+	/*For now, just check if there is some ioctl pending
+	 *and mark that as failed?*/
+	 /* bfa_cee_hbfail(cee); */
 }
diff -uprN a/drivers/scsi/bfa/bfa_core.c b/drivers/scsi/bfa/bfa_core.c
--- a/drivers/scsi/bfa/bfa_core.c	2009-12-18 18:16:22.504684000 -0800
+++ b/drivers/scsi/bfa/bfa_core.c	2009-11-25 18:21:06.000000000 -0800
@@ -385,6 +385,15 @@ bfa_debug_fwsave(struct bfa_s *bfa, void
 }
 
 /**
+ * Clear the saved firmware trace information of an IOC.
+ */
+void
+bfa_debug_fwsave_clear(struct bfa_s *bfa)
+{
+	bfa_ioc_debug_fwsave_clear(&bfa->ioc);
+}
+
+/**
  * 		Fetch firmware trace data.
  *
  * @param[in]		bfa			BFA instance
@@ -399,4 +408,16 @@ bfa_debug_fwtrc(struct bfa_s *bfa, void 
 {
 	return bfa_ioc_debug_fwtrc(&bfa->ioc, trcdata, trclen);
 }
+
+/**
+ * Reset hw semaphore & usage cnt regs and initialize.
+ */
+void
+bfa_chip_reset(struct bfa_s *bfa)
+{
+	bfa_ioc_ownership_reset(&bfa->ioc);
+	bfa_ioc_pll_init(&bfa->ioc);
+}
+
 #endif
+
diff -uprN a/drivers/scsi/bfa/bfa_csdebug.c b/drivers/scsi/bfa/bfa_csdebug.c
--- a/drivers/scsi/bfa/bfa_csdebug.c	2009-12-18 18:16:22.502684000 -0800
+++ b/drivers/scsi/bfa/bfa_csdebug.c	2009-11-25 18:21:06.000000000 -0800
@@ -47,12 +47,12 @@ bfa_q_is_on_q_func(struct list_head *q, 
 	tqe = bfa_q_next(q);
 	while (tqe != q) {
 		if (tqe == qe)
-			return (1);
+			return 1;
 		tqe = bfa_q_next(tqe);
 		if (tqe == NULL)
 			break;
 	}
-	return (0);
+	return 0;
 }
 
 
diff -uprN a/drivers/scsi/bfa/bfa_fcpim.c b/drivers/scsi/bfa/bfa_fcpim.c
--- a/drivers/scsi/bfa/bfa_fcpim.c	2009-12-18 18:16:22.500686000 -0800
+++ b/drivers/scsi/bfa/bfa_fcpim.c	2009-11-25 18:21:06.000000000 -0800
@@ -131,7 +131,7 @@ bfa_fcpim_path_tov_get(struct bfa_s *bfa
 {
 	struct bfa_fcpim_mod_s *fcpim = BFA_FCPIM_MOD(bfa);
 
-	return (fcpim->path_tov / 1000);
+	return fcpim->path_tov / 1000;
 }
 
 bfa_status_t
@@ -169,7 +169,7 @@ bfa_fcpim_qdepth_get(struct bfa_s *bfa)
 {
 	struct bfa_fcpim_mod_s *fcpim = BFA_FCPIM_MOD(bfa);
 
-	return (fcpim->q_depth);
+	return fcpim->q_depth;
 }
 
 
diff -uprN a/drivers/scsi/bfa/bfa_fcpim_priv.h b/drivers/scsi/bfa/bfa_fcpim_priv.h
--- a/drivers/scsi/bfa/bfa_fcpim_priv.h	2009-12-18 18:16:22.498686000 -0800
+++ b/drivers/scsi/bfa/bfa_fcpim_priv.h	2009-11-25 18:06:50.000000000 -0800
@@ -35,7 +35,7 @@
 #define BFA_FCPIM_PATHTOV_MAX	(90 * 1000)	/* in millisecs */
 
 #define bfa_fcpim_stats(__fcpim, __stats)   \
-    (__fcpim)->stats.__stats ++
+    ((__fcpim)->stats.__stats++)
 
 struct bfa_fcpim_mod_s {
 	struct bfa_s 	*bfa;
@@ -50,13 +50,13 @@ struct bfa_fcpim_mod_s {
 	u32		path_tov;
 	u16		q_depth;
 	u16		rsvd;
-	struct list_head 	itnim_q;        /*  queue of active itnim    */
-	struct list_head 	ioim_free_q;    /*  free IO resources        */
-	struct list_head 	ioim_resfree_q; /*  IOs waiting for f/w      */
-	struct list_head 	ioim_comp_q;    /*  IO global comp Q         */
-	struct list_head 	tskim_free_q;
-	u32	ios_active;	/*  current active IOs	      */
-	u32	delay_comp;
+	struct list_head 	itnim_q;        /*  queue of active itnim */
+	struct list_head 	ioim_free_q;    /*  free IO resources     */
+	struct list_head 	ioim_resfree_q; /*  IOs waiting for f/w   */
+	struct list_head 	ioim_comp_q;    /*  IO global comp Q      */
+	struct list_head	tskim_free_q;
+	u32		ios_active;	/*  current active IOs	*/
+	u32		delay_comp;
 	struct bfa_fcpim_stats_s stats;
 };
 
@@ -67,21 +67,21 @@ struct bfa_tskim_s;
  * BFA IO (initiator mode)
  */
 struct bfa_ioim_s {
-	struct list_head qe;		/*  queue elememt            */
-	bfa_sm_t		sm; 	/*  BFA ioim state machine   */
-	struct bfa_s 	        *bfa;	/*  BFA module               */
-	struct bfa_fcpim_mod_s	*fcpim;	/*  parent fcpim module      */
-	struct bfa_itnim_s 	*itnim;	/*  i-t-n nexus for this IO  */
-	struct bfad_ioim_s 	*dio;	/*  driver IO handle         */
-	u16	iotag;		/*  FWI IO tag               */
-	u16	abort_tag;	/*  unqiue abort request tag */
-	u16	nsges;		/*  number of SG elements    */
-	u16	nsgpgs;		/*  number of SG pages       */
-	struct bfa_sgpg_s *sgpg;	/*  first SG page            */
-	struct list_head sgpg_q;		/*  allocated SG pages       */
-	struct bfa_cb_qe_s hcb_qe;	/*  bfa callback qelem       */
-	bfa_cb_cbfn_t io_cbfn;		/*  IO completion handler    */
-	struct bfa_ioim_sp_s *iosp;	/*  slow-path IO handling    */
+	struct list_head 		qe;		/*  queue elememt */
+	bfa_sm_t		sm; 		/*  BFA ioim state machine   */
+	struct bfa_s 	        *bfa;		/*  BFA module               */
+	struct bfa_fcpim_mod_s	*fcpim;		/*  parent fcpim module      */
+	struct bfa_itnim_s 	*itnim;		/*  i-t-n nexus for this IO  */
+	struct bfad_ioim_s 	*dio;		/*  driver IO handle         */
+	u16		iotag;		/*  FWI IO tag               */
+	u16		abort_tag;	/*  unqiue abort request tag */
+	u16		nsges;		/*  number of SG elements    */
+	u16		nsgpgs;		/*  number of SG pages       */
+	struct bfa_sgpg_s	*sgpg;		/*  first SG page            */
+	struct list_head 		sgpg_q;	/*  allocated SG pages */
+	struct bfa_cb_qe_s	hcb_qe;		/*  bfa callback qelem       */
+	bfa_cb_cbfn_t		io_cbfn;	/*  IO completion handler    */
+	struct bfa_ioim_sp_s *iosp;		/*  slow-path IO handling    */
 };
 
 struct bfa_ioim_sp_s {
@@ -105,7 +105,7 @@ struct bfa_tskim_s {
 	struct bfad_tskim_s         *dtsk;   /*  driver task mgmt cmnd    */
 	bfa_boolean_t        notify;         /*  notify itnim on TM comp  */
 	lun_t                lun;            /*  lun if applicable        */
-	enum fcp_tm_cmnd        tm_cmnd;     /*  task management command  */
+	enum fcp_tm_cmnd     tm_cmnd;        /*  task management command  */
 	u16             tsk_tag;        /*  FWI IO tag               */
 	u8              tsecs;          /*  timeout in seconds       */
 	struct bfa_reqq_wait_s  reqq_wait;   /*  to wait for room in reqq */
@@ -143,7 +143,7 @@ struct bfa_itnim_s {
 	struct bfa_itnim_hal_stats_s	stats;
 };
 
-#define bfa_itnim_is_online(_itnim) (_itnim)->is_online
+#define bfa_itnim_is_online(_itnim) ((_itnim)->is_online)
 #define BFA_FCPIM_MOD(_hal) (&(_hal)->modules.fcpim_mod)
 #define BFA_IOIM_FROM_TAG(_fcpim, _iotag)	\
 	(&fcpim->ioim_arr[_iotag])
diff -uprN a/drivers/scsi/bfa/bfa_fcport.c b/drivers/scsi/bfa/bfa_fcport.c
--- a/drivers/scsi/bfa/bfa_fcport.c	2009-12-18 18:16:22.496687000 -0800
+++ b/drivers/scsi/bfa/bfa_fcport.c	2009-11-25 18:21:06.000000000 -0800
@@ -23,40 +23,33 @@
 #include <cs/bfa_plog.h>
 #include <aen/bfa_aen_port.h>
 
-BFA_TRC_FILE(HAL, PPORT);
-BFA_MODULE(pport);
-
-#define bfa_pport_callback(__pport, __event) do {			\
-	if ((__pport)->bfa->fcs) {      \
-		(__pport)->event_cbfn((__pport)->event_cbarg, (__event));      \
-	} else {							\
-		(__pport)->hcb_event = (__event);      \
-		bfa_cb_queue((__pport)->bfa, &(__pport)->hcb_qe,	\
-		__bfa_cb_port_event, (__pport));      \
-	}								\
-} while (0)
+BFA_TRC_FILE(HAL, FCPORT);
+BFA_MODULE(fcport);
 
 /*
  * The port is considered disabled if corresponding physical port or IOC are
  * disabled explicitly
  */
 #define BFA_PORT_IS_DISABLED(bfa) \
-	((bfa_pport_is_disabled(bfa) == BFA_TRUE) || \
+	((bfa_fcport_is_disabled(bfa) == BFA_TRUE) || \
 	(bfa_ioc_is_disabled(&bfa->ioc) == BFA_TRUE))
 
 /*
  * forward declarations
  */
-static bfa_boolean_t bfa_pport_send_enable(struct bfa_pport_s *port);
-static bfa_boolean_t bfa_pport_send_disable(struct bfa_pport_s *port);
-static void     bfa_pport_update_linkinfo(struct bfa_pport_s *pport);
-static void     bfa_pport_reset_linkinfo(struct bfa_pport_s *pport);
-static void     bfa_pport_set_wwns(struct bfa_pport_s *port);
-static void     __bfa_cb_port_event(void *cbarg, bfa_boolean_t complete);
-static void     __bfa_cb_port_stats(void *cbarg, bfa_boolean_t complete);
-static void     __bfa_cb_port_stats_clr(void *cbarg, bfa_boolean_t complete);
-static void     bfa_port_stats_timeout(void *cbarg);
-static void     bfa_port_stats_clr_timeout(void *cbarg);
+static bfa_boolean_t bfa_fcport_send_enable(struct bfa_fcport_s *fcport);
+static bfa_boolean_t bfa_fcport_send_disable(struct bfa_fcport_s *fcport);
+static void	bfa_fcport_update_linkinfo(struct bfa_fcport_s *fcport);
+static void	bfa_fcport_reset_linkinfo(struct bfa_fcport_s *fcport);
+static void	bfa_fcport_set_wwns(struct bfa_fcport_s *fcport);
+static void	__bfa_cb_fcport_event(void *cbarg, bfa_boolean_t complete);
+static void	bfa_fcport_callback(struct bfa_fcport_s *fcport,
+				enum bfa_pport_linkstate event);
+static void	bfa_fcport_queue_cb(struct bfa_fcport_ln_s *ln,
+				enum bfa_pport_linkstate event);
+static void	__bfa_cb_fcport_stats_clr(void *cbarg, bfa_boolean_t complete);
+static void	bfa_fcport_stats_get_timeout(void *cbarg);
+static void	bfa_fcport_stats_clr_timeout(void *cbarg);
 
 /**
  *  bfa_pport_private
@@ -65,111 +58,115 @@ static void     bfa_port_stats_clr_timeo
 /**
  * BFA port state machine events
  */
-enum bfa_pport_sm_event {
-	BFA_PPORT_SM_START = 1,	/*  start port state machine */
-	BFA_PPORT_SM_STOP = 2,	/*  stop port state machine */
-	BFA_PPORT_SM_ENABLE = 3,	/*  enable port */
-	BFA_PPORT_SM_DISABLE = 4,	/*  disable port state machine */
-	BFA_PPORT_SM_FWRSP = 5,	/*  firmware enable/disable rsp */
-	BFA_PPORT_SM_LINKUP = 6,	/*  firmware linkup event */
-	BFA_PPORT_SM_LINKDOWN = 7,	/*  firmware linkup down */
-	BFA_PPORT_SM_QRESUME = 8,	/*  CQ space available */
-	BFA_PPORT_SM_HWFAIL = 9,	/*  IOC h/w failure */
+enum bfa_fcport_sm_event {
+	BFA_FCPORT_SM_START	= 1,	/*  start port state machine	*/
+	BFA_FCPORT_SM_STOP	= 2,	/*  stop port state machine	*/
+	BFA_FCPORT_SM_ENABLE	= 3,	/*  enable port		*/
+	BFA_FCPORT_SM_DISABLE	= 4,	/*  disable port state machine */
+	BFA_FCPORT_SM_FWRSP	= 5,	/*  firmware enable/disable rsp */
+	BFA_FCPORT_SM_LINKUP	= 6,	/*  firmware linkup event	*/
+	BFA_FCPORT_SM_LINKDOWN	= 7,	/*  firmware linkup down	*/
+	BFA_FCPORT_SM_QRESUME	= 8,	/*  CQ space available	*/
+	BFA_FCPORT_SM_HWFAIL	= 9,	/*  IOC h/w failure		*/
+};
+
+/**
+ * BFA port link notification state machine events
+ */
+
+enum bfa_fcport_ln_sm_event {
+	BFA_FCPORT_LN_SM_LINKUP		= 1,	/*  linkup event */
+	BFA_FCPORT_LN_SM_LINKDOWN	= 2,	/*  linkdown event */
+	BFA_FCPORT_LN_SM_NOTIFICATION	= 3	/*  done notification */
 };
 
-static void     bfa_pport_sm_uninit(struct bfa_pport_s *pport,
-				    enum bfa_pport_sm_event event);
-static void     bfa_pport_sm_enabling_qwait(struct bfa_pport_s *pport,
-					    enum bfa_pport_sm_event event);
-static void     bfa_pport_sm_enabling(struct bfa_pport_s *pport,
-				      enum bfa_pport_sm_event event);
-static void     bfa_pport_sm_linkdown(struct bfa_pport_s *pport,
-				      enum bfa_pport_sm_event event);
-static void     bfa_pport_sm_linkup(struct bfa_pport_s *pport,
-				    enum bfa_pport_sm_event event);
-static void     bfa_pport_sm_disabling(struct bfa_pport_s *pport,
-				       enum bfa_pport_sm_event event);
-static void     bfa_pport_sm_disabling_qwait(struct bfa_pport_s *pport,
-					     enum bfa_pport_sm_event event);
-static void     bfa_pport_sm_disabled(struct bfa_pport_s *pport,
-				      enum bfa_pport_sm_event event);
-static void     bfa_pport_sm_stopped(struct bfa_pport_s *pport,
-				     enum bfa_pport_sm_event event);
-static void     bfa_pport_sm_iocdown(struct bfa_pport_s *pport,
-				     enum bfa_pport_sm_event event);
-static void     bfa_pport_sm_iocfail(struct bfa_pport_s *pport,
-				     enum bfa_pport_sm_event event);
+static void	bfa_fcport_sm_uninit(struct bfa_fcport_s *fcport,
+					enum bfa_fcport_sm_event event);
+static void	bfa_fcport_sm_enabling_qwait(struct bfa_fcport_s *fcport,
+						enum bfa_fcport_sm_event event);
+static void	bfa_fcport_sm_enabling(struct bfa_fcport_s *fcport,
+						enum bfa_fcport_sm_event event);
+static void	bfa_fcport_sm_linkdown(struct bfa_fcport_s *fcport,
+						enum bfa_fcport_sm_event event);
+static void	bfa_fcport_sm_linkup(struct bfa_fcport_s *fcport,
+						enum bfa_fcport_sm_event event);
+static void	bfa_fcport_sm_disabling(struct bfa_fcport_s *fcport,
+						enum bfa_fcport_sm_event event);
+static void	bfa_fcport_sm_disabling_qwait(struct bfa_fcport_s *fcport,
+						enum bfa_fcport_sm_event event);
+static void	bfa_fcport_sm_disabled(struct bfa_fcport_s *fcport,
+						enum bfa_fcport_sm_event event);
+static void	bfa_fcport_sm_stopped(struct bfa_fcport_s *fcport,
+					 enum bfa_fcport_sm_event event);
+static void	bfa_fcport_sm_iocdown(struct bfa_fcport_s *fcport,
+					 enum bfa_fcport_sm_event event);
+static void	bfa_fcport_sm_iocfail(struct bfa_fcport_s *fcport,
+					 enum bfa_fcport_sm_event event);
+
+static void	bfa_fcport_ln_sm_dn(struct bfa_fcport_ln_s *ln,
+					enum bfa_fcport_ln_sm_event event);
+static void	bfa_fcport_ln_sm_dn_nf(struct bfa_fcport_ln_s *ln,
+					enum bfa_fcport_ln_sm_event event);
+static void	bfa_fcport_ln_sm_dn_up_nf(struct bfa_fcport_ln_s *ln,
+					enum bfa_fcport_ln_sm_event event);
+static void	bfa_fcport_ln_sm_up(struct bfa_fcport_ln_s *ln,
+					enum bfa_fcport_ln_sm_event event);
+static void	bfa_fcport_ln_sm_up_nf(struct bfa_fcport_ln_s *ln,
+					enum bfa_fcport_ln_sm_event event);
+static void	bfa_fcport_ln_sm_up_dn_nf(struct bfa_fcport_ln_s *ln,
+					enum bfa_fcport_ln_sm_event event);
+static void	bfa_fcport_ln_sm_up_dn_up_nf(struct bfa_fcport_ln_s *ln,
+					enum bfa_fcport_ln_sm_event event);
 
 static struct bfa_sm_table_s hal_pport_sm_table[] = {
-	{BFA_SM(bfa_pport_sm_uninit), BFA_PPORT_ST_UNINIT},
-	{BFA_SM(bfa_pport_sm_enabling_qwait), BFA_PPORT_ST_ENABLING_QWAIT},
-	{BFA_SM(bfa_pport_sm_enabling), BFA_PPORT_ST_ENABLING},
-	{BFA_SM(bfa_pport_sm_linkdown), BFA_PPORT_ST_LINKDOWN},
-	{BFA_SM(bfa_pport_sm_linkup), BFA_PPORT_ST_LINKUP},
-	{BFA_SM(bfa_pport_sm_disabling_qwait),
-	 BFA_PPORT_ST_DISABLING_QWAIT},
-	{BFA_SM(bfa_pport_sm_disabling), BFA_PPORT_ST_DISABLING},
-	{BFA_SM(bfa_pport_sm_disabled), BFA_PPORT_ST_DISABLED},
-	{BFA_SM(bfa_pport_sm_stopped), BFA_PPORT_ST_STOPPED},
-	{BFA_SM(bfa_pport_sm_iocdown), BFA_PPORT_ST_IOCDOWN},
-	{BFA_SM(bfa_pport_sm_iocfail), BFA_PPORT_ST_IOCDOWN},
+	{BFA_SM(bfa_fcport_sm_uninit), BFA_PPORT_ST_UNINIT},
+	{BFA_SM(bfa_fcport_sm_enabling_qwait), BFA_PPORT_ST_ENABLING_QWAIT},
+	{BFA_SM(bfa_fcport_sm_enabling), BFA_PPORT_ST_ENABLING},
+	{BFA_SM(bfa_fcport_sm_linkdown), BFA_PPORT_ST_LINKDOWN},
+	{BFA_SM(bfa_fcport_sm_linkup), BFA_PPORT_ST_LINKUP},
+	{BFA_SM(bfa_fcport_sm_disabling_qwait), BFA_PPORT_ST_DISABLING_QWAIT},
+	{BFA_SM(bfa_fcport_sm_disabling), BFA_PPORT_ST_DISABLING},
+	{BFA_SM(bfa_fcport_sm_disabled), BFA_PPORT_ST_DISABLED},
+	{BFA_SM(bfa_fcport_sm_stopped), BFA_PPORT_ST_STOPPED},
+	{BFA_SM(bfa_fcport_sm_iocdown), BFA_PPORT_ST_IOCDOWN},
+	{BFA_SM(bfa_fcport_sm_iocfail), BFA_PPORT_ST_IOCDOWN},
 };
 
 static void
-bfa_pport_aen_post(struct bfa_pport_s *pport, enum bfa_port_aen_event event)
+bfa_fcport_aen_post(struct bfa_fcport_s *fcport, enum bfa_port_aen_event event)
 {
 	union bfa_aen_data_u aen_data;
-	struct bfa_log_mod_s *logmod = pport->bfa->logm;
-	wwn_t           pwwn = pport->pwwn;
-	char            pwwn_ptr[BFA_STRING_32];
-	struct bfa_ioc_attr_s ioc_attr;
+	struct bfa_log_mod_s *logmod = fcport->bfa->logm;
+	wwn_t pwwn = fcport->pwwn;
+	char pwwn_ptr[BFA_STRING_32];
 
+	memset(&aen_data, 0, sizeof(aen_data));
 	wwn2str(pwwn_ptr, pwwn);
-	switch (event) {
-	case BFA_PORT_AEN_ONLINE:
-		bfa_log(logmod, BFA_AEN_PORT_ONLINE, pwwn_ptr);
-		break;
-	case BFA_PORT_AEN_OFFLINE:
-		bfa_log(logmod, BFA_AEN_PORT_OFFLINE, pwwn_ptr);
-		break;
-	case BFA_PORT_AEN_ENABLE:
-		bfa_log(logmod, BFA_AEN_PORT_ENABLE, pwwn_ptr);
-		break;
-	case BFA_PORT_AEN_DISABLE:
-		bfa_log(logmod, BFA_AEN_PORT_DISABLE, pwwn_ptr);
-		break;
-	case BFA_PORT_AEN_DISCONNECT:
-		bfa_log(logmod, BFA_AEN_PORT_DISCONNECT, pwwn_ptr);
-		break;
-	case BFA_PORT_AEN_QOS_NEG:
-		bfa_log(logmod, BFA_AEN_PORT_QOS_NEG, pwwn_ptr);
-		break;
-	default:
-		break;
-	}
+	bfa_log(logmod, BFA_LOG_CREATE_ID(BFA_AEN_CAT_PORT, event), pwwn_ptr);
 
-	bfa_ioc_get_attr(&pport->bfa->ioc, &ioc_attr);
-	aen_data.port.ioc_type = ioc_attr.ioc_type;
-	aen_data.port.pwwn = pwwn;
+	aen_data.port.ioc_type = bfa_get_type(fcport->bfa);
+	aen_data.port.pwwn = pwwn;	/* Assert on FC/FCoE type? */
 }
 
 static void
-bfa_pport_sm_uninit(struct bfa_pport_s *pport, enum bfa_pport_sm_event event)
+bfa_fcport_sm_uninit(struct bfa_fcport_s *fcport,
+			enum bfa_fcport_sm_event event)
 {
-	bfa_trc(pport->bfa, event);
+	bfa_trc(fcport->bfa, event);
 
 	switch (event) {
-	case BFA_PPORT_SM_START:
+	case BFA_FCPORT_SM_START:
 		/**
 		 * Start event after IOC is configured and BFA is started.
 		 */
-		if (bfa_pport_send_enable(pport))
-			bfa_sm_set_state(pport, bfa_pport_sm_enabling);
+		if (bfa_fcport_send_enable(fcport))
+			bfa_sm_set_state(fcport, bfa_fcport_sm_enabling);
 		else
-			bfa_sm_set_state(pport, bfa_pport_sm_enabling_qwait);
+			bfa_sm_set_state(fcport,
+					 bfa_fcport_sm_enabling_qwait);
 		break;
 
-	case BFA_PPORT_SM_ENABLE:
+	case BFA_FCPORT_SM_ENABLE:
 		/**
 		 * Port is persistently configured to be in enabled state. Do
 		 * not change state. Port enabling is done when START event is
@@ -177,392 +174,418 @@ bfa_pport_sm_uninit(struct bfa_pport_s *
 		 */
 		break;
 
-	case BFA_PPORT_SM_DISABLE:
+	case BFA_FCPORT_SM_DISABLE:
 		/**
 		 * If a port is persistently configured to be disabled, the
 		 * first event will a port disable request.
 		 */
-		bfa_sm_set_state(pport, bfa_pport_sm_disabled);
+		bfa_sm_set_state(fcport, bfa_fcport_sm_disabled);
 		break;
 
-	case BFA_PPORT_SM_HWFAIL:
-		bfa_sm_set_state(pport, bfa_pport_sm_iocdown);
+	case BFA_FCPORT_SM_HWFAIL:
+		bfa_sm_set_state(fcport, bfa_fcport_sm_iocdown);
 		break;
 
 	default:
-		bfa_sm_fault(pport->bfa, event);
+		bfa_sm_fault(fcport->bfa, event);
 	}
 }
 
 static void
-bfa_pport_sm_enabling_qwait(struct bfa_pport_s *pport,
-			    enum bfa_pport_sm_event event)
+bfa_fcport_sm_enabling_qwait(struct bfa_fcport_s *fcport,
+				enum bfa_fcport_sm_event event)
 {
-	bfa_trc(pport->bfa, event);
+	bfa_trc(fcport->bfa, event);
 
 	switch (event) {
-	case BFA_PPORT_SM_QRESUME:
-		bfa_sm_set_state(pport, bfa_pport_sm_enabling);
-		bfa_pport_send_enable(pport);
+	case BFA_FCPORT_SM_QRESUME:
+		bfa_sm_set_state(fcport, bfa_fcport_sm_enabling);
+		bfa_fcport_send_enable(fcport);
 		break;
 
-	case BFA_PPORT_SM_STOP:
-		bfa_reqq_wcancel(&pport->reqq_wait);
-		bfa_sm_set_state(pport, bfa_pport_sm_stopped);
+	case BFA_FCPORT_SM_STOP:
+		bfa_reqq_wcancel(&fcport->reqq_wait);
+		bfa_sm_set_state(fcport, bfa_fcport_sm_stopped);
 		break;
 
-	case BFA_PPORT_SM_ENABLE:
+	case BFA_FCPORT_SM_ENABLE:
 		/**
 		 * Already enable is in progress.
 		 */
 		break;
 
-	case BFA_PPORT_SM_DISABLE:
+	case BFA_FCPORT_SM_DISABLE:
 		/**
 		 * Just send disable request to firmware when room becomes
 		 * available in request queue.
 		 */
-		bfa_sm_set_state(pport, bfa_pport_sm_disabled);
-		bfa_reqq_wcancel(&pport->reqq_wait);
-		bfa_plog_str(pport->bfa->plog, BFA_PL_MID_HAL,
-			     BFA_PL_EID_PORT_DISABLE, 0, "Port Disable");
-		bfa_pport_aen_post(pport, BFA_PORT_AEN_DISABLE);
+		bfa_sm_set_state(fcport, bfa_fcport_sm_disabled);
+		bfa_reqq_wcancel(&fcport->reqq_wait);
+		bfa_plog_str(fcport->bfa->plog, BFA_PL_MID_HAL,
+				BFA_PL_EID_PORT_DISABLE, 0, "Port Disable");
+		bfa_fcport_aen_post(fcport, BFA_PORT_AEN_DISABLE);
 		break;
 
-	case BFA_PPORT_SM_LINKUP:
-	case BFA_PPORT_SM_LINKDOWN:
+	case BFA_FCPORT_SM_LINKUP:
+	case BFA_FCPORT_SM_LINKDOWN:
 		/**
 		 * Possible to get link events when doing back-to-back
 		 * enable/disables.
 		 */
 		break;
 
-	case BFA_PPORT_SM_HWFAIL:
-		bfa_reqq_wcancel(&pport->reqq_wait);
-		bfa_sm_set_state(pport, bfa_pport_sm_iocdown);
+	case BFA_FCPORT_SM_HWFAIL:
+		bfa_reqq_wcancel(&fcport->reqq_wait);
+		bfa_sm_set_state(fcport, bfa_fcport_sm_iocdown);
 		break;
 
 	default:
-		bfa_sm_fault(pport->bfa, event);
+		bfa_sm_fault(fcport->bfa, event);
 	}
 }
 
 static void
-bfa_pport_sm_enabling(struct bfa_pport_s *pport, enum bfa_pport_sm_event event)
+bfa_fcport_sm_enabling(struct bfa_fcport_s *fcport,
+						enum bfa_fcport_sm_event event)
 {
-	bfa_trc(pport->bfa, event);
+	bfa_trc(fcport->bfa, event);
 
 	switch (event) {
-	case BFA_PPORT_SM_FWRSP:
-	case BFA_PPORT_SM_LINKDOWN:
-		bfa_sm_set_state(pport, bfa_pport_sm_linkdown);
+	case BFA_FCPORT_SM_FWRSP:
+	case BFA_FCPORT_SM_LINKDOWN:
+		bfa_sm_set_state(fcport, bfa_fcport_sm_linkdown);
 		break;
 
-	case BFA_PPORT_SM_LINKUP:
-		bfa_pport_update_linkinfo(pport);
-		bfa_sm_set_state(pport, bfa_pport_sm_linkup);
+	case BFA_FCPORT_SM_LINKUP:
+		bfa_fcport_update_linkinfo(fcport);
+		bfa_sm_set_state(fcport, bfa_fcport_sm_linkup);
 
-		bfa_assert(pport->event_cbfn);
-		bfa_pport_callback(pport, BFA_PPORT_LINKUP);
+		bfa_assert(fcport->event_cbfn);
+		bfa_fcport_callback(fcport, BFA_PPORT_LINKUP);
 		break;
 
-	case BFA_PPORT_SM_ENABLE:
+	case BFA_FCPORT_SM_ENABLE:
 		/**
 		 * Already being enabled.
 		 */
 		break;
 
-	case BFA_PPORT_SM_DISABLE:
-		if (bfa_pport_send_disable(pport))
-			bfa_sm_set_state(pport, bfa_pport_sm_disabling);
+	case BFA_FCPORT_SM_DISABLE:
+		if (bfa_fcport_send_disable(fcport))
+			bfa_sm_set_state(fcport, bfa_fcport_sm_disabling);
 		else
-			bfa_sm_set_state(pport, bfa_pport_sm_disabling_qwait);
+			bfa_sm_set_state(fcport,
+					 bfa_fcport_sm_disabling_qwait);
 
-		bfa_plog_str(pport->bfa->plog, BFA_PL_MID_HAL,
-			     BFA_PL_EID_PORT_DISABLE, 0, "Port Disable");
-		bfa_pport_aen_post(pport, BFA_PORT_AEN_DISABLE);
+		bfa_plog_str(fcport->bfa->plog, BFA_PL_MID_HAL,
+				BFA_PL_EID_PORT_DISABLE, 0, "Port Disable");
+		bfa_fcport_aen_post(fcport, BFA_PORT_AEN_DISABLE);
 		break;
 
-	case BFA_PPORT_SM_STOP:
-		bfa_sm_set_state(pport, bfa_pport_sm_stopped);
+	case BFA_FCPORT_SM_STOP:
+		bfa_sm_set_state(fcport, bfa_fcport_sm_stopped);
 		break;
 
-	case BFA_PPORT_SM_HWFAIL:
-		bfa_sm_set_state(pport, bfa_pport_sm_iocdown);
+	case BFA_FCPORT_SM_HWFAIL:
+		bfa_sm_set_state(fcport, bfa_fcport_sm_iocdown);
 		break;
 
 	default:
-		bfa_sm_fault(pport->bfa, event);
+		bfa_sm_fault(fcport->bfa, event);
 	}
 }
 
 static void
-bfa_pport_sm_linkdown(struct bfa_pport_s *pport, enum bfa_pport_sm_event event)
+bfa_fcport_sm_linkdown(struct bfa_fcport_s *fcport,
+						enum bfa_fcport_sm_event event)
 {
-	bfa_trc(pport->bfa, event);
+	struct bfi_fcport_event_s *pevent = fcport->event_arg.i2hmsg.event;
+
+	bfa_trc(fcport->bfa, event);
 
 	switch (event) {
-	case BFA_PPORT_SM_LINKUP:
-		bfa_pport_update_linkinfo(pport);
-		bfa_sm_set_state(pport, bfa_pport_sm_linkup);
-		bfa_assert(pport->event_cbfn);
-		bfa_plog_str(pport->bfa->plog, BFA_PL_MID_HAL,
-			     BFA_PL_EID_PORT_ST_CHANGE, 0, "Port Linkup");
-		bfa_pport_callback(pport, BFA_PPORT_LINKUP);
-		bfa_pport_aen_post(pport, BFA_PORT_AEN_ONLINE);
+	case BFA_FCPORT_SM_LINKUP:
+		bfa_fcport_update_linkinfo(fcport);
+		bfa_sm_set_state(fcport, bfa_fcport_sm_linkup);
+		bfa_assert(fcport->event_cbfn);
+		bfa_plog_str(fcport->bfa->plog, BFA_PL_MID_HAL,
+				BFA_PL_EID_PORT_ST_CHANGE, 0, "Port Linkup");
+		if (!bfa_ioc_get_fcmode(&fcport->bfa->ioc)) {
+
+			bfa_trc(fcport->bfa, pevent->link_state.fcf.fipenabled);
+			bfa_trc(fcport->bfa, pevent->link_state.fcf.fipfailed);
+
+			if (pevent->link_state.fcf.fipfailed)
+				bfa_plog_str(fcport->bfa->plog, BFA_PL_MID_HAL,
+					BFA_PL_EID_FIP_FCF_DISC, 0,
+					"FIP FCF Discovery Failed");
+			else
+				bfa_plog_str(fcport->bfa->plog, BFA_PL_MID_HAL,
+					BFA_PL_EID_FIP_FCF_DISC, 0,
+					"FIP FCF Discovered");
+		}
+
+		bfa_fcport_callback(fcport, BFA_PPORT_LINKUP);
+		bfa_fcport_aen_post(fcport, BFA_PORT_AEN_ONLINE);
 		/**
 		 * If QoS is enabled and it is not online,
 		 * Send a separate event.
 		 */
-		if ((pport->cfg.qos_enabled)
-		    && (bfa_os_ntohl(pport->qos_attr.state) != BFA_QOS_ONLINE))
-			bfa_pport_aen_post(pport, BFA_PORT_AEN_QOS_NEG);
+		if ((fcport->cfg.qos_enabled) &&
+		    (bfa_os_ntohl(fcport->qos_attr.state) != BFA_QOS_ONLINE))
+			bfa_fcport_aen_post(fcport, BFA_PORT_AEN_QOS_NEG);
 
 		break;
 
-	case BFA_PPORT_SM_LINKDOWN:
+	case BFA_FCPORT_SM_LINKDOWN:
 		/**
 		 * Possible to get link down event.
 		 */
 		break;
 
-	case BFA_PPORT_SM_ENABLE:
+	case BFA_FCPORT_SM_ENABLE:
 		/**
 		 * Already enabled.
 		 */
 		break;
 
-	case BFA_PPORT_SM_DISABLE:
-		if (bfa_pport_send_disable(pport))
-			bfa_sm_set_state(pport, bfa_pport_sm_disabling);
+	case BFA_FCPORT_SM_DISABLE:
+		if (bfa_fcport_send_disable(fcport))
+			bfa_sm_set_state(fcport, bfa_fcport_sm_disabling);
 		else
-			bfa_sm_set_state(pport, bfa_pport_sm_disabling_qwait);
+			bfa_sm_set_state(fcport,
+					 bfa_fcport_sm_disabling_qwait);
 
-		bfa_plog_str(pport->bfa->plog, BFA_PL_MID_HAL,
-			     BFA_PL_EID_PORT_DISABLE, 0, "Port Disable");
-		bfa_pport_aen_post(pport, BFA_PORT_AEN_DISABLE);
+		bfa_plog_str(fcport->bfa->plog, BFA_PL_MID_HAL,
+				BFA_PL_EID_PORT_DISABLE, 0, "Port Disable");
+		bfa_fcport_aen_post(fcport, BFA_PORT_AEN_DISABLE);
 		break;
 
-	case BFA_PPORT_SM_STOP:
-		bfa_sm_set_state(pport, bfa_pport_sm_stopped);
+	case BFA_FCPORT_SM_STOP:
+		bfa_sm_set_state(fcport, bfa_fcport_sm_stopped);
 		break;
 
-	case BFA_PPORT_SM_HWFAIL:
-		bfa_sm_set_state(pport, bfa_pport_sm_iocdown);
+	case BFA_FCPORT_SM_HWFAIL:
+		bfa_sm_set_state(fcport, bfa_fcport_sm_iocdown);
 		break;
 
 	default:
-		bfa_sm_fault(pport->bfa, event);
+		bfa_sm_fault(fcport->bfa, event);
 	}
 }
 
 static void
-bfa_pport_sm_linkup(struct bfa_pport_s *pport, enum bfa_pport_sm_event event)
+bfa_fcport_sm_linkup(struct bfa_fcport_s *fcport,
+	enum bfa_fcport_sm_event event)
 {
-	bfa_trc(pport->bfa, event);
+	bfa_trc(fcport->bfa, event);
 
 	switch (event) {
-	case BFA_PPORT_SM_ENABLE:
+	case BFA_FCPORT_SM_ENABLE:
 		/**
 		 * Already enabled.
 		 */
 		break;
 
-	case BFA_PPORT_SM_DISABLE:
-		if (bfa_pport_send_disable(pport))
-			bfa_sm_set_state(pport, bfa_pport_sm_disabling);
+	case BFA_FCPORT_SM_DISABLE:
+		if (bfa_fcport_send_disable(fcport))
+			bfa_sm_set_state(fcport, bfa_fcport_sm_disabling);
 		else
-			bfa_sm_set_state(pport, bfa_pport_sm_disabling_qwait);
+			bfa_sm_set_state(fcport,
+					 bfa_fcport_sm_disabling_qwait);
 
-		bfa_pport_reset_linkinfo(pport);
-		bfa_pport_callback(pport, BFA_PPORT_LINKDOWN);
-		bfa_plog_str(pport->bfa->plog, BFA_PL_MID_HAL,
-			     BFA_PL_EID_PORT_DISABLE, 0, "Port Disable");
-		bfa_pport_aen_post(pport, BFA_PORT_AEN_OFFLINE);
-		bfa_pport_aen_post(pport, BFA_PORT_AEN_DISABLE);
-		break;
-
-	case BFA_PPORT_SM_LINKDOWN:
-		bfa_sm_set_state(pport, bfa_pport_sm_linkdown);
-		bfa_pport_reset_linkinfo(pport);
-		bfa_pport_callback(pport, BFA_PPORT_LINKDOWN);
-		bfa_plog_str(pport->bfa->plog, BFA_PL_MID_HAL,
-			     BFA_PL_EID_PORT_ST_CHANGE, 0, "Port Linkdown");
-		if (BFA_PORT_IS_DISABLED(pport->bfa)) {
-			bfa_pport_aen_post(pport, BFA_PORT_AEN_OFFLINE);
-		} else {
-			bfa_pport_aen_post(pport, BFA_PORT_AEN_DISCONNECT);
-		}
+		bfa_fcport_reset_linkinfo(fcport);
+		bfa_fcport_callback(fcport, BFA_PPORT_LINKDOWN);
+		bfa_plog_str(fcport->bfa->plog, BFA_PL_MID_HAL,
+				BFA_PL_EID_PORT_DISABLE, 0, "Port Disable");
+		bfa_fcport_aen_post(fcport, BFA_PORT_AEN_OFFLINE);
+		bfa_fcport_aen_post(fcport, BFA_PORT_AEN_DISABLE);
+		break;
+
+	case BFA_FCPORT_SM_LINKDOWN:
+		bfa_sm_set_state(fcport, bfa_fcport_sm_linkdown);
+		bfa_fcport_reset_linkinfo(fcport);
+		bfa_fcport_callback(fcport, BFA_PPORT_LINKDOWN);
+		bfa_plog_str(fcport->bfa->plog, BFA_PL_MID_HAL,
+				BFA_PL_EID_PORT_ST_CHANGE, 0, "Port Linkdown");
+		if (BFA_PORT_IS_DISABLED(fcport->bfa))
+			bfa_fcport_aen_post(fcport, BFA_PORT_AEN_OFFLINE);
+		else
+			bfa_fcport_aen_post(fcport, BFA_PORT_AEN_DISCONNECT);
 		break;
 
-	case BFA_PPORT_SM_STOP:
-		bfa_sm_set_state(pport, bfa_pport_sm_stopped);
-		bfa_pport_reset_linkinfo(pport);
-		if (BFA_PORT_IS_DISABLED(pport->bfa)) {
-			bfa_pport_aen_post(pport, BFA_PORT_AEN_OFFLINE);
-		} else {
-			bfa_pport_aen_post(pport, BFA_PORT_AEN_DISCONNECT);
-		}
+	case BFA_FCPORT_SM_STOP:
+		bfa_sm_set_state(fcport, bfa_fcport_sm_stopped);
+		bfa_fcport_reset_linkinfo(fcport);
+		if (BFA_PORT_IS_DISABLED(fcport->bfa))
+			bfa_fcport_aen_post(fcport, BFA_PORT_AEN_OFFLINE);
+		else
+			bfa_fcport_aen_post(fcport, BFA_PORT_AEN_DISCONNECT);
 		break;
 
-	case BFA_PPORT_SM_HWFAIL:
-		bfa_sm_set_state(pport, bfa_pport_sm_iocdown);
-		bfa_pport_reset_linkinfo(pport);
-		bfa_pport_callback(pport, BFA_PPORT_LINKDOWN);
-		if (BFA_PORT_IS_DISABLED(pport->bfa)) {
-			bfa_pport_aen_post(pport, BFA_PORT_AEN_OFFLINE);
-		} else {
-			bfa_pport_aen_post(pport, BFA_PORT_AEN_DISCONNECT);
-		}
+	case BFA_FCPORT_SM_HWFAIL:
+		bfa_sm_set_state(fcport, bfa_fcport_sm_iocdown);
+		bfa_fcport_reset_linkinfo(fcport);
+		bfa_fcport_callback(fcport, BFA_PPORT_LINKDOWN);
+		if (BFA_PORT_IS_DISABLED(fcport->bfa))
+			bfa_fcport_aen_post(fcport, BFA_PORT_AEN_OFFLINE);
+		else
+			bfa_fcport_aen_post(fcport, BFA_PORT_AEN_DISCONNECT);
 		break;
 
 	default:
-		bfa_sm_fault(pport->bfa, event);
+		bfa_sm_fault(fcport->bfa, event);
 	}
 }
 
 static void
-bfa_pport_sm_disabling_qwait(struct bfa_pport_s *pport,
-			     enum bfa_pport_sm_event event)
+bfa_fcport_sm_disabling_qwait(struct bfa_fcport_s *fcport,
+				 enum bfa_fcport_sm_event event)
 {
-	bfa_trc(pport->bfa, event);
+	bfa_trc(fcport->bfa, event);
 
 	switch (event) {
-	case BFA_PPORT_SM_QRESUME:
-		bfa_sm_set_state(pport, bfa_pport_sm_disabling);
-		bfa_pport_send_disable(pport);
+	case BFA_FCPORT_SM_QRESUME:
+		bfa_sm_set_state(fcport, bfa_fcport_sm_disabling);
+		bfa_fcport_send_disable(fcport);
 		break;
 
-	case BFA_PPORT_SM_STOP:
-		bfa_sm_set_state(pport, bfa_pport_sm_stopped);
-		bfa_reqq_wcancel(&pport->reqq_wait);
+	case BFA_FCPORT_SM_STOP:
+		bfa_sm_set_state(fcport, bfa_fcport_sm_stopped);
+		bfa_reqq_wcancel(&fcport->reqq_wait);
 		break;
 
-	case BFA_PPORT_SM_DISABLE:
+	case BFA_FCPORT_SM_DISABLE:
 		/**
 		 * Already being disabled.
 		 */
 		break;
 
-	case BFA_PPORT_SM_LINKUP:
-	case BFA_PPORT_SM_LINKDOWN:
+	case BFA_FCPORT_SM_LINKUP:
+	case BFA_FCPORT_SM_LINKDOWN:
 		/**
 		 * Possible to get link events when doing back-to-back
 		 * enable/disables.
 		 */
 		break;
 
-	case BFA_PPORT_SM_HWFAIL:
-		bfa_sm_set_state(pport, bfa_pport_sm_iocfail);
-		bfa_reqq_wcancel(&pport->reqq_wait);
+	case BFA_FCPORT_SM_HWFAIL:
+		bfa_sm_set_state(fcport, bfa_fcport_sm_iocfail);
+		bfa_reqq_wcancel(&fcport->reqq_wait);
 		break;
 
 	default:
-		bfa_sm_fault(pport->bfa, event);
+		bfa_sm_fault(fcport->bfa, event);
 	}
 }
 
 static void
-bfa_pport_sm_disabling(struct bfa_pport_s *pport, enum bfa_pport_sm_event event)
+bfa_fcport_sm_disabling(struct bfa_fcport_s *fcport,
+						enum bfa_fcport_sm_event event)
 {
-	bfa_trc(pport->bfa, event);
+	bfa_trc(fcport->bfa, event);
 
 	switch (event) {
-	case BFA_PPORT_SM_FWRSP:
-		bfa_sm_set_state(pport, bfa_pport_sm_disabled);
+	case BFA_FCPORT_SM_FWRSP:
+		bfa_sm_set_state(fcport, bfa_fcport_sm_disabled);
 		break;
 
-	case BFA_PPORT_SM_DISABLE:
+	case BFA_FCPORT_SM_DISABLE:
 		/**
 		 * Already being disabled.
 		 */
 		break;
 
-	case BFA_PPORT_SM_ENABLE:
-		if (bfa_pport_send_enable(pport))
-			bfa_sm_set_state(pport, bfa_pport_sm_enabling);
+	case BFA_FCPORT_SM_ENABLE:
+		if (bfa_fcport_send_enable(fcport))
+			bfa_sm_set_state(fcport, bfa_fcport_sm_enabling);
 		else
-			bfa_sm_set_state(pport, bfa_pport_sm_enabling_qwait);
+			bfa_sm_set_state(fcport,
+					 bfa_fcport_sm_enabling_qwait);
 
-		bfa_plog_str(pport->bfa->plog, BFA_PL_MID_HAL,
-			     BFA_PL_EID_PORT_ENABLE, 0, "Port Enable");
-		bfa_pport_aen_post(pport, BFA_PORT_AEN_ENABLE);
+		bfa_plog_str(fcport->bfa->plog, BFA_PL_MID_HAL,
+				BFA_PL_EID_PORT_ENABLE, 0, "Port Enable");
+		bfa_fcport_aen_post(fcport, BFA_PORT_AEN_ENABLE);
 		break;
 
-	case BFA_PPORT_SM_STOP:
-		bfa_sm_set_state(pport, bfa_pport_sm_stopped);
+	case BFA_FCPORT_SM_STOP:
+		bfa_sm_set_state(fcport, bfa_fcport_sm_stopped);
 		break;
 
-	case BFA_PPORT_SM_LINKUP:
-	case BFA_PPORT_SM_LINKDOWN:
+	case BFA_FCPORT_SM_LINKUP:
+	case BFA_FCPORT_SM_LINKDOWN:
 		/**
 		 * Possible to get link events when doing back-to-back
 		 * enable/disables.
 		 */
 		break;
 
-	case BFA_PPORT_SM_HWFAIL:
-		bfa_sm_set_state(pport, bfa_pport_sm_iocfail);
+	case BFA_FCPORT_SM_HWFAIL:
+		bfa_sm_set_state(fcport, bfa_fcport_sm_iocfail);
 		break;
 
 	default:
-		bfa_sm_fault(pport->bfa, event);
+		bfa_sm_fault(fcport->bfa, event);
 	}
 }
 
 static void
-bfa_pport_sm_disabled(struct bfa_pport_s *pport, enum bfa_pport_sm_event event)
+bfa_fcport_sm_disabled(struct bfa_fcport_s *fcport,
+						enum bfa_fcport_sm_event event)
 {
-	bfa_trc(pport->bfa, event);
+	bfa_trc(fcport->bfa, event);
 
 	switch (event) {
-	case BFA_PPORT_SM_START:
+	case BFA_FCPORT_SM_START:
 		/**
 		 * Ignore start event for a port that is disabled.
 		 */
 		break;
 
-	case BFA_PPORT_SM_STOP:
-		bfa_sm_set_state(pport, bfa_pport_sm_stopped);
+	case BFA_FCPORT_SM_STOP:
+		bfa_sm_set_state(fcport, bfa_fcport_sm_stopped);
 		break;
 
-	case BFA_PPORT_SM_ENABLE:
-		if (bfa_pport_send_enable(pport))
-			bfa_sm_set_state(pport, bfa_pport_sm_enabling);
+	case BFA_FCPORT_SM_ENABLE:
+		if (bfa_fcport_send_enable(fcport))
+			bfa_sm_set_state(fcport, bfa_fcport_sm_enabling);
 		else
-			bfa_sm_set_state(pport, bfa_pport_sm_enabling_qwait);
+			bfa_sm_set_state(fcport,
+					 bfa_fcport_sm_enabling_qwait);
 
-		bfa_plog_str(pport->bfa->plog, BFA_PL_MID_HAL,
-			     BFA_PL_EID_PORT_ENABLE, 0, "Port Enable");
-		bfa_pport_aen_post(pport, BFA_PORT_AEN_ENABLE);
+		bfa_plog_str(fcport->bfa->plog, BFA_PL_MID_HAL,
+				BFA_PL_EID_PORT_ENABLE, 0, "Port Enable");
+		bfa_fcport_aen_post(fcport, BFA_PORT_AEN_ENABLE);
 		break;
 
-	case BFA_PPORT_SM_DISABLE:
+	case BFA_FCPORT_SM_DISABLE:
 		/**
 		 * Already disabled.
 		 */
 		break;
 
-	case BFA_PPORT_SM_HWFAIL:
-		bfa_sm_set_state(pport, bfa_pport_sm_iocfail);
+	case BFA_FCPORT_SM_HWFAIL:
+		bfa_sm_set_state(fcport, bfa_fcport_sm_iocfail);
 		break;
 
 	default:
-		bfa_sm_fault(pport->bfa, event);
+		bfa_sm_fault(fcport->bfa, event);
 	}
 }
 
 static void
-bfa_pport_sm_stopped(struct bfa_pport_s *pport, enum bfa_pport_sm_event event)
+bfa_fcport_sm_stopped(struct bfa_fcport_s *fcport,
+			 enum bfa_fcport_sm_event event)
 {
-	bfa_trc(pport->bfa, event);
+	bfa_trc(fcport->bfa, event);
 
 	switch (event) {
-	case BFA_PPORT_SM_START:
-		if (bfa_pport_send_enable(pport))
-			bfa_sm_set_state(pport, bfa_pport_sm_enabling);
+	case BFA_FCPORT_SM_START:
+		if (bfa_fcport_send_enable(fcport))
+			bfa_sm_set_state(fcport, bfa_fcport_sm_enabling);
 		else
-			bfa_sm_set_state(pport, bfa_pport_sm_enabling_qwait);
+			bfa_sm_set_state(fcport,
+					 bfa_fcport_sm_enabling_qwait);
 		break;
 
 	default:
@@ -577,16 +600,18 @@ bfa_pport_sm_stopped(struct bfa_pport_s 
  * Port is enabled. IOC is down/failed.
  */
 static void
-bfa_pport_sm_iocdown(struct bfa_pport_s *pport, enum bfa_pport_sm_event event)
+bfa_fcport_sm_iocdown(struct bfa_fcport_s *fcport,
+			 enum bfa_fcport_sm_event event)
 {
-	bfa_trc(pport->bfa, event);
+	bfa_trc(fcport->bfa, event);
 
 	switch (event) {
-	case BFA_PPORT_SM_START:
-		if (bfa_pport_send_enable(pport))
-			bfa_sm_set_state(pport, bfa_pport_sm_enabling);
+	case BFA_FCPORT_SM_START:
+		if (bfa_fcport_send_enable(fcport))
+			bfa_sm_set_state(fcport, bfa_fcport_sm_enabling);
 		else
-			bfa_sm_set_state(pport, bfa_pport_sm_enabling_qwait);
+			bfa_sm_set_state(fcport,
+					 bfa_fcport_sm_enabling_qwait);
 		break;
 
 	default:
@@ -601,17 +626,18 @@ bfa_pport_sm_iocdown(struct bfa_pport_s 
  * Port is disabled. IOC is down/failed.
  */
 static void
-bfa_pport_sm_iocfail(struct bfa_pport_s *pport, enum bfa_pport_sm_event event)
+bfa_fcport_sm_iocfail(struct bfa_fcport_s *fcport,
+			 enum bfa_fcport_sm_event event)
 {
-	bfa_trc(pport->bfa, event);
+	bfa_trc(fcport->bfa, event);
 
 	switch (event) {
-	case BFA_PPORT_SM_START:
-		bfa_sm_set_state(pport, bfa_pport_sm_disabled);
+	case BFA_FCPORT_SM_START:
+		bfa_sm_set_state(fcport, bfa_fcport_sm_disabled);
 		break;
 
-	case BFA_PPORT_SM_ENABLE:
-		bfa_sm_set_state(pport, bfa_pport_sm_iocdown);
+	case BFA_FCPORT_SM_ENABLE:
+		bfa_sm_set_state(fcport, bfa_fcport_sm_iocdown);
 		break;
 
 	default:
@@ -622,6 +648,164 @@ bfa_pport_sm_iocfail(struct bfa_pport_s 
 	}
 }
 
+/**
+ * Link state is down
+ */
+static void
+bfa_fcport_ln_sm_dn(struct bfa_fcport_ln_s *ln,
+		enum bfa_fcport_ln_sm_event event)
+{
+	bfa_trc(ln->fcport->bfa, event);
+
+	switch (event) {
+	case BFA_FCPORT_LN_SM_LINKUP:
+		bfa_sm_set_state(ln, bfa_fcport_ln_sm_up_nf);
+		bfa_fcport_queue_cb(ln, BFA_PPORT_LINKUP);
+		break;
+
+	default:
+		bfa_sm_fault(ln->fcport->bfa, event);
+	}
+}
+
+/**
+ * Link state is waiting for down notification
+ */
+static void
+bfa_fcport_ln_sm_dn_nf(struct bfa_fcport_ln_s *ln,
+		enum bfa_fcport_ln_sm_event event)
+{
+	bfa_trc(ln->fcport->bfa, event);
+
+	switch (event) {
+	case BFA_FCPORT_LN_SM_LINKUP:
+		bfa_sm_set_state(ln, bfa_fcport_ln_sm_dn_up_nf);
+		break;
+
+	case BFA_FCPORT_LN_SM_NOTIFICATION:
+		bfa_sm_set_state(ln, bfa_fcport_ln_sm_dn);
+		break;
+
+	default:
+		bfa_sm_fault(ln->fcport->bfa, event);
+	}
+}
+
+/**
+ * Link state is waiting for down notification and there is a pending up
+ */
+static void
+bfa_fcport_ln_sm_dn_up_nf(struct bfa_fcport_ln_s *ln,
+		enum bfa_fcport_ln_sm_event event)
+{
+	bfa_trc(ln->fcport->bfa, event);
+
+	switch (event) {
+	case BFA_FCPORT_LN_SM_LINKDOWN:
+		bfa_sm_set_state(ln, bfa_fcport_ln_sm_dn_nf);
+		break;
+
+	case BFA_FCPORT_LN_SM_NOTIFICATION:
+		bfa_sm_set_state(ln, bfa_fcport_ln_sm_up_nf);
+		bfa_fcport_queue_cb(ln, BFA_PPORT_LINKUP);
+		break;
+
+	default:
+		bfa_sm_fault(ln->fcport->bfa, event);
+	}
+}
+
+/**
+ * Link state is up
+ */
+static void
+bfa_fcport_ln_sm_up(struct bfa_fcport_ln_s *ln,
+		enum bfa_fcport_ln_sm_event event)
+{
+	bfa_trc(ln->fcport->bfa, event);
+
+	switch (event) {
+	case BFA_FCPORT_LN_SM_LINKDOWN:
+		bfa_sm_set_state(ln, bfa_fcport_ln_sm_dn_nf);
+		bfa_fcport_queue_cb(ln, BFA_PPORT_LINKDOWN);
+		break;
+
+	default:
+		bfa_sm_fault(ln->fcport->bfa, event);
+	}
+}
+
+/**
+ * Link state is waiting for up notification
+ */
+static void
+bfa_fcport_ln_sm_up_nf(struct bfa_fcport_ln_s *ln,
+		enum bfa_fcport_ln_sm_event event)
+{
+	bfa_trc(ln->fcport->bfa, event);
+
+	switch (event) {
+	case BFA_FCPORT_LN_SM_LINKDOWN:
+		bfa_sm_set_state(ln, bfa_fcport_ln_sm_up_dn_nf);
+		break;
+
+	case BFA_FCPORT_LN_SM_NOTIFICATION:
+		bfa_sm_set_state(ln, bfa_fcport_ln_sm_up);
+		break;
+
+	default:
+		bfa_sm_fault(ln->fcport->bfa, event);
+	}
+}
+
+/**
+ * Link state is waiting for up notification and there is a pending down
+ */
+static void
+bfa_fcport_ln_sm_up_dn_nf(struct bfa_fcport_ln_s *ln,
+		enum bfa_fcport_ln_sm_event event)
+{
+	bfa_trc(ln->fcport->bfa, event);
+
+	switch (event) {
+	case BFA_FCPORT_LN_SM_LINKUP:
+		bfa_sm_set_state(ln, bfa_fcport_ln_sm_up_dn_up_nf);
+		break;
+
+	case BFA_FCPORT_LN_SM_NOTIFICATION:
+		bfa_sm_set_state(ln, bfa_fcport_ln_sm_dn_nf);
+		bfa_fcport_queue_cb(ln, BFA_PPORT_LINKDOWN);
+		break;
+
+	default:
+		bfa_sm_fault(ln->fcport->bfa, event);
+	}
+}
+
+/**
+ * Link state is waiting for up notification and there are pending down and up
+ */
+static void
+bfa_fcport_ln_sm_up_dn_up_nf(struct bfa_fcport_ln_s *ln,
+			enum bfa_fcport_ln_sm_event event)
+{
+	bfa_trc(ln->fcport->bfa, event);
+
+	switch (event) {
+	case BFA_FCPORT_LN_SM_LINKDOWN:
+		bfa_sm_set_state(ln, bfa_fcport_ln_sm_up_dn_nf);
+		break;
+
+	case BFA_FCPORT_LN_SM_NOTIFICATION:
+		bfa_sm_set_state(ln, bfa_fcport_ln_sm_dn_up_nf);
+		bfa_fcport_queue_cb(ln, BFA_PPORT_LINKDOWN);
+		break;
+
+	default:
+		bfa_sm_fault(ln->fcport->bfa, event);
+	}
+}
+
 
 
 /**
@@ -629,47 +813,76 @@ bfa_pport_sm_iocfail(struct bfa_pport_s 
  */
 
 static void
-__bfa_cb_port_event(void *cbarg, bfa_boolean_t complete)
+__bfa_cb_fcport_event(void *cbarg, bfa_boolean_t complete)
 {
-	struct bfa_pport_s *pport = cbarg;
+	struct bfa_fcport_ln_s *ln = cbarg;
 
 	if (complete)
-		pport->event_cbfn(pport->event_cbarg, pport->hcb_event);
+		ln->fcport->event_cbfn(ln->fcport->event_cbarg, ln->ln_event);
+	else
+		bfa_sm_send_event(ln, BFA_FCPORT_LN_SM_NOTIFICATION);
 }
 
-#define PPORT_STATS_DMA_SZ (BFA_ROUNDUP(sizeof(union bfa_pport_stats_u), \
+static void
+bfa_fcport_callback(struct bfa_fcport_s *fcport, enum bfa_pport_linkstate event)
+{
+	if (fcport->bfa->fcs) {
+		fcport->event_cbfn(fcport->event_cbarg, event);
+		return;
+	}
+
+	switch (event) {
+	case BFA_PPORT_LINKUP:
+		bfa_sm_send_event(&fcport->ln, BFA_FCPORT_LN_SM_LINKUP);
+		break;
+	case BFA_PPORT_LINKDOWN:
+		bfa_sm_send_event(&fcport->ln, BFA_FCPORT_LN_SM_LINKDOWN);
+		break;
+	default:
+		bfa_assert(0);
+	}
+}
+
+static void
+bfa_fcport_queue_cb(struct bfa_fcport_ln_s *ln, enum bfa_pport_linkstate event)
+{
+	ln->ln_event = event;
+	bfa_cb_queue(ln->fcport->bfa, &ln->ln_qe, __bfa_cb_fcport_event, ln);
+}
+
+#define FCPORT_STATS_DMA_SZ (BFA_ROUNDUP(sizeof(union bfa_fcport_stats_u), \
 							BFA_CACHELINE_SZ))
 
 static void
-bfa_pport_meminfo(struct bfa_iocfc_cfg_s *cfg, u32 *ndm_len,
-		  u32 *dm_len)
+bfa_fcport_meminfo(struct bfa_iocfc_cfg_s *cfg, u32 *ndm_len,
+		u32 *dm_len)
 {
-	*dm_len += PPORT_STATS_DMA_SZ;
+	*dm_len += FCPORT_STATS_DMA_SZ;
 }
 
 static void
-bfa_pport_qresume(void *cbarg)
+bfa_fcport_qresume(void *cbarg)
 {
-	struct bfa_pport_s *port = cbarg;
+	struct bfa_fcport_s *fcport = cbarg;
 
-	bfa_sm_send_event(port, BFA_PPORT_SM_QRESUME);
+	bfa_sm_send_event(fcport, BFA_FCPORT_SM_QRESUME);
 }
 
 static void
-bfa_pport_mem_claim(struct bfa_pport_s *pport, struct bfa_meminfo_s *meminfo)
+bfa_fcport_mem_claim(struct bfa_fcport_s *fcport, struct bfa_meminfo_s *meminfo)
 {
-	u8        *dm_kva;
-	u64        dm_pa;
+	u8		*dm_kva;
+	u64	dm_pa;
 
 	dm_kva = bfa_meminfo_dma_virt(meminfo);
-	dm_pa = bfa_meminfo_dma_phys(meminfo);
+	dm_pa  = bfa_meminfo_dma_phys(meminfo);
 
-	pport->stats_kva = dm_kva;
-	pport->stats_pa = dm_pa;
-	pport->stats = (union bfa_pport_stats_u *)dm_kva;
+	fcport->stats_kva = dm_kva;
+	fcport->stats_pa  = dm_pa;
+	fcport->stats	  = (union bfa_fcport_stats_u *) dm_kva;
 
-	dm_kva += PPORT_STATS_DMA_SZ;
-	dm_pa += PPORT_STATS_DMA_SZ;
+	dm_kva += FCPORT_STATS_DMA_SZ;
+	dm_pa  += FCPORT_STATS_DMA_SZ;
 
 	bfa_meminfo_dma_virt(meminfo) = dm_kva;
 	bfa_meminfo_dma_phys(meminfo) = dm_pa;
@@ -679,18 +892,21 @@ bfa_pport_mem_claim(struct bfa_pport_s *
  * Memory initialization.
  */
 static void
-bfa_pport_attach(struct bfa_s *bfa, void *bfad, struct bfa_iocfc_cfg_s *cfg,
-		 struct bfa_meminfo_s *meminfo, struct bfa_pcidev_s *pcidev)
+bfa_fcport_attach(struct bfa_s *bfa, void *bfad, struct bfa_iocfc_cfg_s *cfg,
+		struct bfa_meminfo_s *meminfo, struct bfa_pcidev_s *pcidev)
 {
-	struct bfa_pport_s *pport = BFA_PORT_MOD(bfa);
-	struct bfa_pport_cfg_s *port_cfg = &pport->cfg;
+	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
+	struct bfa_pport_cfg_s *port_cfg = &fcport->cfg;
+	struct bfa_fcport_ln_s *ln = &fcport->ln;
 
-	bfa_os_memset(pport, 0, sizeof(struct bfa_pport_s));
-	pport->bfa = bfa;
+	bfa_os_memset(fcport, 0, sizeof(struct bfa_fcport_s));
+	fcport->bfa = bfa;
+	ln->fcport = fcport;
 
-	bfa_pport_mem_claim(pport, meminfo);
+	bfa_fcport_mem_claim(fcport, meminfo);
 
-	bfa_sm_set_state(pport, bfa_pport_sm_uninit);
+	bfa_sm_set_state(fcport, bfa_fcport_sm_uninit);
+	bfa_sm_set_state(ln, bfa_fcport_ln_sm_dn);
 
 	/**
 	 * initialize and set default configuration
@@ -702,30 +918,30 @@ bfa_pport_attach(struct bfa_s *bfa, void
 
 	port_cfg->trl_def_speed = BFA_PPORT_SPEED_1GBPS;
 
-	bfa_reqq_winit(&pport->reqq_wait, bfa_pport_qresume, pport);
+	bfa_reqq_winit(&fcport->reqq_wait, bfa_fcport_qresume, fcport);
 }
 
 static void
-bfa_pport_initdone(struct bfa_s *bfa)
+bfa_fcport_initdone(struct bfa_s *bfa)
 {
-	struct bfa_pport_s *pport = BFA_PORT_MOD(bfa);
+	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
 	/**
 	 * Initialize port attributes from IOC hardware data.
 	 */
-	bfa_pport_set_wwns(pport);
-	if (pport->cfg.maxfrsize == 0)
-		pport->cfg.maxfrsize = bfa_ioc_maxfrsize(&bfa->ioc);
-	pport->cfg.rx_bbcredit = bfa_ioc_rx_bbcredit(&bfa->ioc);
-	pport->speed_sup = bfa_ioc_speed_sup(&bfa->ioc);
+	bfa_fcport_set_wwns(fcport);
+	if (fcport->cfg.maxfrsize == 0)
+		fcport->cfg.maxfrsize = bfa_ioc_maxfrsize(&bfa->ioc);
+	fcport->cfg.rx_bbcredit = bfa_ioc_rx_bbcredit(&bfa->ioc);
+	fcport->speed_sup = bfa_ioc_speed_sup(&bfa->ioc);
 
-	bfa_assert(pport->cfg.maxfrsize);
-	bfa_assert(pport->cfg.rx_bbcredit);
-	bfa_assert(pport->speed_sup);
+	bfa_assert(fcport->cfg.maxfrsize);
+	bfa_assert(fcport->cfg.rx_bbcredit);
+	bfa_assert(fcport->speed_sup);
 }
 
 static void
-bfa_pport_detach(struct bfa_s *bfa)
+bfa_fcport_detach(struct bfa_s *bfa)
 {
 }
 
@@ -733,167 +949,321 @@ bfa_pport_detach(struct bfa_s *bfa)
  * Called when IOC is ready.
  */
 static void
-bfa_pport_start(struct bfa_s *bfa)
+bfa_fcport_start(struct bfa_s *bfa)
 {
-	bfa_sm_send_event(BFA_PORT_MOD(bfa), BFA_PPORT_SM_START);
+	bfa_sm_send_event(BFA_FCPORT_MOD(bfa), BFA_FCPORT_SM_START);
 }
 
 /**
  * Called before IOC is stopped.
  */
 static void
-bfa_pport_stop(struct bfa_s *bfa)
+bfa_fcport_stop(struct bfa_s *bfa)
 {
-	bfa_sm_send_event(BFA_PORT_MOD(bfa), BFA_PPORT_SM_STOP);
+	bfa_sm_send_event(BFA_FCPORT_MOD(bfa), BFA_FCPORT_SM_STOP);
 }
 
 /**
  * Called when IOC failure is detected.
  */
 static void
-bfa_pport_iocdisable(struct bfa_s *bfa)
+bfa_fcport_iocdisable(struct bfa_s *bfa)
 {
-	bfa_sm_send_event(BFA_PORT_MOD(bfa), BFA_PPORT_SM_HWFAIL);
+	bfa_sm_send_event(BFA_FCPORT_MOD(bfa), BFA_FCPORT_SM_HWFAIL);
 }
 
 static void
-bfa_pport_update_linkinfo(struct bfa_pport_s *pport)
+bfa_fcport_update_linkinfo(struct bfa_fcport_s *fcport)
 {
-	struct bfi_pport_event_s *pevent = pport->event_arg.i2hmsg.event;
+	struct bfi_fcport_event_s *pevent = fcport->event_arg.i2hmsg.event;
 
-	pport->speed = pevent->link_state.speed;
-	pport->topology = pevent->link_state.topology;
+	fcport->speed = pevent->link_state.speed;
+	fcport->topology = pevent->link_state.topology;
 
-	if (pport->topology == BFA_PPORT_TOPOLOGY_LOOP)
-		pport->myalpa = pevent->link_state.tl.loop_info.myalpa;
+	if (fcport->topology == BFA_PPORT_TOPOLOGY_LOOP)
+		fcport->myalpa =
+			pevent->link_state.tl.loop_info.myalpa;
 
-	/*
-	 * QoS Details
-	 */
-	bfa_os_assign(pport->qos_attr, pevent->link_state.qos_attr);
-	bfa_os_assign(pport->qos_vc_attr, pevent->link_state.qos_vc_attr);
+	/* QoS Details */
+	bfa_os_assign(fcport->qos_attr, pevent->link_state.qos_attr);
+	bfa_os_assign(fcport->qos_vc_attr, pevent->link_state.qos_vc_attr);
 
-	bfa_trc(pport->bfa, pport->speed);
-	bfa_trc(pport->bfa, pport->topology);
+	bfa_trc(fcport->bfa, fcport->speed);
+	bfa_trc(fcport->bfa, fcport->topology);
 }
 
 static void
-bfa_pport_reset_linkinfo(struct bfa_pport_s *pport)
+bfa_fcport_reset_linkinfo(struct bfa_fcport_s *fcport)
 {
-	pport->speed = BFA_PPORT_SPEED_UNKNOWN;
-	pport->topology = BFA_PPORT_TOPOLOGY_NONE;
+	fcport->speed = BFA_PPORT_SPEED_UNKNOWN;
+	fcport->topology = BFA_PPORT_TOPOLOGY_NONE;
 }
 
 /**
  * Send port enable message to firmware.
  */
-static          bfa_boolean_t
-bfa_pport_send_enable(struct bfa_pport_s *port)
+static bfa_boolean_t
+bfa_fcport_send_enable(struct bfa_fcport_s *fcport)
 {
-	struct bfi_pport_enable_req_s *m;
+	struct bfi_fcport_enable_req_s *m;
 
 	/**
 	 * Increment message tag before queue check, so that responses to old
 	 * requests are discarded.
 	 */
-	port->msgtag++;
+	fcport->msgtag++;
 
 	/**
 	 * check for room in queue to send request now
 	 */
-	m = bfa_reqq_next(port->bfa, BFA_REQQ_PORT);
+	m = bfa_reqq_next(fcport->bfa, BFA_REQQ_PORT);
 	if (!m) {
-		bfa_reqq_wait(port->bfa, BFA_REQQ_PORT, &port->reqq_wait);
+		bfa_reqq_wait(fcport->bfa, BFA_REQQ_PORT,
+							&fcport->reqq_wait);
 		return BFA_FALSE;
 	}
 
-	bfi_h2i_set(m->mh, BFI_MC_FC_PORT, BFI_PPORT_H2I_ENABLE_REQ,
-		    bfa_lpuid(port->bfa));
-	m->nwwn = port->nwwn;
-	m->pwwn = port->pwwn;
-	m->port_cfg = port->cfg;
-	m->msgtag = port->msgtag;
-	m->port_cfg.maxfrsize = bfa_os_htons(port->cfg.maxfrsize);
-	bfa_dma_be_addr_set(m->stats_dma_addr, port->stats_pa);
-	bfa_trc(port->bfa, m->stats_dma_addr.a32.addr_lo);
-	bfa_trc(port->bfa, m->stats_dma_addr.a32.addr_hi);
+	bfi_h2i_set(m->mh, BFI_MC_FCPORT, BFI_FCPORT_H2I_ENABLE_REQ,
+			bfa_lpuid(fcport->bfa));
+	m->nwwn = fcport->nwwn;
+	m->pwwn = fcport->pwwn;
+	m->port_cfg = fcport->cfg;
+	m->msgtag = fcport->msgtag;
+	m->port_cfg.maxfrsize = bfa_os_htons(fcport->cfg.maxfrsize);
+	bfa_dma_be_addr_set(m->stats_dma_addr, fcport->stats_pa);
+	bfa_trc(fcport->bfa, m->stats_dma_addr.a32.addr_lo);
+	bfa_trc(fcport->bfa, m->stats_dma_addr.a32.addr_hi);
 
 	/**
 	 * queue I/O message to firmware
 	 */
-	bfa_reqq_produce(port->bfa, BFA_REQQ_PORT);
+	bfa_reqq_produce(fcport->bfa, BFA_REQQ_PORT);
 	return BFA_TRUE;
 }
 
 /**
  * Send port disable message to firmware.
  */
-static          bfa_boolean_t
-bfa_pport_send_disable(struct bfa_pport_s *port)
+static	bfa_boolean_t
+bfa_fcport_send_disable(struct bfa_fcport_s *fcport)
 {
-	bfi_pport_disable_req_t *m;
+	struct bfi_fcport_req_s *m;
 
 	/**
 	 * Increment message tag before queue check, so that responses to old
 	 * requests are discarded.
 	 */
-	port->msgtag++;
+	fcport->msgtag++;
 
 	/**
 	 * check for room in queue to send request now
 	 */
-	m = bfa_reqq_next(port->bfa, BFA_REQQ_PORT);
+	m = bfa_reqq_next(fcport->bfa, BFA_REQQ_PORT);
 	if (!m) {
-		bfa_reqq_wait(port->bfa, BFA_REQQ_PORT, &port->reqq_wait);
+		bfa_reqq_wait(fcport->bfa, BFA_REQQ_PORT,
+							&fcport->reqq_wait);
 		return BFA_FALSE;
 	}
 
-	bfi_h2i_set(m->mh, BFI_MC_FC_PORT, BFI_PPORT_H2I_DISABLE_REQ,
-		    bfa_lpuid(port->bfa));
-	m->msgtag = port->msgtag;
+	bfi_h2i_set(m->mh, BFI_MC_FCPORT, BFI_FCPORT_H2I_DISABLE_REQ,
+			bfa_lpuid(fcport->bfa));
+	m->msgtag = fcport->msgtag;
 
 	/**
 	 * queue I/O message to firmware
 	 */
-	bfa_reqq_produce(port->bfa, BFA_REQQ_PORT);
+	bfa_reqq_produce(fcport->bfa, BFA_REQQ_PORT);
 
 	return BFA_TRUE;
 }
 
 static void
-bfa_pport_set_wwns(struct bfa_pport_s *port)
+bfa_fcport_set_wwns(struct bfa_fcport_s *fcport)
 {
-	port->pwwn = bfa_ioc_get_pwwn(&port->bfa->ioc);
-	port->nwwn = bfa_ioc_get_nwwn(&port->bfa->ioc);
+	fcport->pwwn = bfa_ioc_get_pwwn(&fcport->bfa->ioc);
+	fcport->nwwn = bfa_ioc_get_nwwn(&fcport->bfa->ioc);
 
-	bfa_trc(port->bfa, port->pwwn);
-	bfa_trc(port->bfa, port->nwwn);
+	bfa_trc(fcport->bfa, fcport->pwwn);
+	bfa_trc(fcport->bfa, fcport->nwwn);
 }
 
 static void
-bfa_port_send_txcredit(void *port_cbarg)
+bfa_fcport_send_txcredit(void *port_cbarg)
 {
 
-	struct bfa_pport_s *port = port_cbarg;
-	struct bfi_pport_set_svc_params_req_s *m;
+	struct bfa_fcport_s *fcport = port_cbarg;
+	struct bfi_fcport_set_svc_params_req_s *m;
 
 	/**
 	 * check for room in queue to send request now
 	 */
-	m = bfa_reqq_next(port->bfa, BFA_REQQ_PORT);
+	m = bfa_reqq_next(fcport->bfa, BFA_REQQ_PORT);
 	if (!m) {
-		bfa_trc(port->bfa, port->cfg.tx_bbcredit);
+		bfa_trc(fcport->bfa, fcport->cfg.tx_bbcredit);
 		return;
 	}
 
-	bfi_h2i_set(m->mh, BFI_MC_FC_PORT, BFI_PPORT_H2I_SET_SVC_PARAMS_REQ,
-		    bfa_lpuid(port->bfa));
-	m->tx_bbcredit = bfa_os_htons((u16) port->cfg.tx_bbcredit);
+	bfi_h2i_set(m->mh, BFI_MC_FCPORT, BFI_FCPORT_H2I_SET_SVC_PARAMS_REQ,
+			bfa_lpuid(fcport->bfa));
+	m->tx_bbcredit = bfa_os_htons((u16)fcport->cfg.tx_bbcredit);
 
 	/**
 	 * queue I/O message to firmware
 	 */
-	bfa_reqq_produce(port->bfa, BFA_REQQ_PORT);
+	bfa_reqq_produce(fcport->bfa, BFA_REQQ_PORT);
+}
+
+static void
+bfa_fcport_qos_stats_swap(struct bfa_qos_stats_s *d,
+	struct bfa_qos_stats_s *s)
+{
+	u32	*dip = (u32 *) d;
+	u32	*sip = (u32 *) s;
+	int		i;
+
+	/* Now swap the 32 bit fields */
+	for (i = 0; i < (sizeof(struct bfa_qos_stats_s)/sizeof(u32)); ++i)
+		dip[i] = bfa_os_ntohl(sip[i]);
+}
+
+static void
+bfa_fcport_fcoe_stats_swap(struct bfa_fcoe_stats_s *d,
+	struct bfa_fcoe_stats_s *s)
+{
+	u32	*dip = (u32 *) d;
+	u32	*sip = (u32 *) s;
+	int		i;
+
+	for (i = 0; i < ((sizeof(struct bfa_fcoe_stats_s))/sizeof(u32));
+	     i = i + 2) {
+#ifdef __BIGENDIAN
+		dip[i] = bfa_os_ntohl(sip[i]);
+		dip[i + 1] = bfa_os_ntohl(sip[i + 1]);
+#else
+		dip[i] = bfa_os_ntohl(sip[i + 1]);
+		dip[i + 1] = bfa_os_ntohl(sip[i]);
+#endif
+	}
+}
+
+static void
+__bfa_cb_fcport_stats_get(void *cbarg, bfa_boolean_t complete)
+{
+	struct bfa_fcport_s *fcport = cbarg;
+
+	if (complete) {
+		if (fcport->stats_status == BFA_STATUS_OK) {
+
+			/* Swap FC QoS or FCoE stats */
+			if (bfa_ioc_get_fcmode(&fcport->bfa->ioc))
+				bfa_fcport_qos_stats_swap(
+					&fcport->stats_ret->fcqos,
+					&fcport->stats->fcqos);
+			else
+				bfa_fcport_fcoe_stats_swap(
+					&fcport->stats_ret->fcoe,
+					&fcport->stats->fcoe);
+		}
+		fcport->stats_cbfn(fcport->stats_cbarg, fcport->stats_status);
+	} else {
+		fcport->stats_busy = BFA_FALSE;
+		fcport->stats_status = BFA_STATUS_OK;
+	}
+}
+
+static void
+bfa_fcport_stats_get_timeout(void *cbarg)
+{
+	struct bfa_fcport_s *fcport = (struct bfa_fcport_s *) cbarg;
+
+	bfa_trc(fcport->bfa, fcport->stats_qfull);
+
+	if (fcport->stats_qfull) {
+		bfa_reqq_wcancel(&fcport->stats_reqq_wait);
+		fcport->stats_qfull = BFA_FALSE;
+	}
+
+	fcport->stats_status = BFA_STATUS_ETIMER;
+	bfa_cb_queue(fcport->bfa, &fcport->hcb_qe, __bfa_cb_fcport_stats_get,
+		fcport);
+}
+
+static void
+bfa_fcport_send_stats_get(void *cbarg)
+{
+	struct bfa_fcport_s *fcport = (struct bfa_fcport_s *) cbarg;
+	struct bfi_fcport_req_s *msg;
+
+	msg = bfa_reqq_next(fcport->bfa, BFA_REQQ_PORT);
+
+	if (!msg) {
+		fcport->stats_qfull = BFA_TRUE;
+		bfa_reqq_winit(&fcport->stats_reqq_wait,
+				bfa_fcport_send_stats_get, fcport);
+		bfa_reqq_wait(fcport->bfa, BFA_REQQ_PORT,
+				&fcport->stats_reqq_wait);
+		return;
+	}
+	fcport->stats_qfull = BFA_FALSE;
+
+	bfa_os_memset(msg, 0, sizeof(struct bfi_fcport_req_s));
+	bfi_h2i_set(msg->mh, BFI_MC_FCPORT, BFI_FCPORT_H2I_STATS_GET_REQ,
+			bfa_lpuid(fcport->bfa));
+	bfa_reqq_produce(fcport->bfa, BFA_REQQ_PORT);
+}
+
+static void
+__bfa_cb_fcport_stats_clr(void *cbarg, bfa_boolean_t complete)
+{
+	struct bfa_fcport_s *fcport = cbarg;
+
+	if (complete) {
+		fcport->stats_cbfn(fcport->stats_cbarg, fcport->stats_status);
+	} else {
+		fcport->stats_busy = BFA_FALSE;
+		fcport->stats_status = BFA_STATUS_OK;
+	}
+}
+
+static void
+bfa_fcport_stats_clr_timeout(void *cbarg)
+{
+	struct bfa_fcport_s *fcport = (struct bfa_fcport_s *) cbarg;
+
+	bfa_trc(fcport->bfa, fcport->stats_qfull);
+
+	if (fcport->stats_qfull) {
+		bfa_reqq_wcancel(&fcport->stats_reqq_wait);
+		fcport->stats_qfull = BFA_FALSE;
+	}
+
+	fcport->stats_status = BFA_STATUS_ETIMER;
+	bfa_cb_queue(fcport->bfa, &fcport->hcb_qe,
+			__bfa_cb_fcport_stats_clr, fcport);
+}
+
+static void
+bfa_fcport_send_stats_clear(void *cbarg)
+{
+	struct bfa_fcport_s *fcport = (struct bfa_fcport_s *) cbarg;
+	struct bfi_fcport_req_s *msg;
+
+	msg = bfa_reqq_next(fcport->bfa, BFA_REQQ_PORT);
+
+	if (!msg) {
+		fcport->stats_qfull = BFA_TRUE;
+		bfa_reqq_winit(&fcport->stats_reqq_wait,
+				bfa_fcport_send_stats_clear, fcport);
+		bfa_reqq_wait(fcport->bfa, BFA_REQQ_PORT,
+						&fcport->stats_reqq_wait);
+		return;
+	}
+	fcport->stats_qfull = BFA_FALSE;
+
+	bfa_os_memset(msg, 0, sizeof(struct bfi_fcport_req_s));
+	bfi_h2i_set(msg->mh, BFI_MC_FCPORT, BFI_FCPORT_H2I_STATS_CLEAR_REQ,
+			bfa_lpuid(fcport->bfa));
+	bfa_reqq_produce(fcport->bfa, BFA_REQQ_PORT);
 }
 
 
@@ -906,32 +1276,32 @@ bfa_port_send_txcredit(void *port_cbarg)
  * Firmware message handler.
  */
 void
-bfa_pport_isr(struct bfa_s *bfa, struct bfi_msg_s *msg)
+bfa_fcport_isr(struct bfa_s *bfa, struct bfi_msg_s *msg)
 {
-	struct bfa_pport_s *pport = BFA_PORT_MOD(bfa);
-	union bfi_pport_i2h_msg_u i2hmsg;
+	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
+	union bfi_fcport_i2h_msg_u i2hmsg;
 
 	i2hmsg.msg = msg;
-	pport->event_arg.i2hmsg = i2hmsg;
+	fcport->event_arg.i2hmsg = i2hmsg;
 
 	switch (msg->mhdr.msg_id) {
-	case BFI_PPORT_I2H_ENABLE_RSP:
-		if (pport->msgtag == i2hmsg.enable_rsp->msgtag)
-			bfa_sm_send_event(pport, BFA_PPORT_SM_FWRSP);
+	case BFI_FCPORT_I2H_ENABLE_RSP:
+		if (fcport->msgtag == i2hmsg.penable_rsp->msgtag)
+			bfa_sm_send_event(fcport, BFA_FCPORT_SM_FWRSP);
 		break;
 
-	case BFI_PPORT_I2H_DISABLE_RSP:
-		if (pport->msgtag == i2hmsg.enable_rsp->msgtag)
-			bfa_sm_send_event(pport, BFA_PPORT_SM_FWRSP);
+	case BFI_FCPORT_I2H_DISABLE_RSP:
+		if (fcport->msgtag == i2hmsg.penable_rsp->msgtag)
+			bfa_sm_send_event(fcport, BFA_FCPORT_SM_FWRSP);
 		break;
 
-	case BFI_PPORT_I2H_EVENT:
+	case BFI_FCPORT_I2H_EVENT:
 		switch (i2hmsg.event->link_state.linkstate) {
 		case BFA_PPORT_LINKUP:
-			bfa_sm_send_event(pport, BFA_PPORT_SM_LINKUP);
+			bfa_sm_send_event(fcport, BFA_FCPORT_SM_LINKUP);
 			break;
 		case BFA_PPORT_LINKDOWN:
-			bfa_sm_send_event(pport, BFA_PPORT_SM_LINKDOWN);
+			bfa_sm_send_event(fcport, BFA_FCPORT_SM_LINKDOWN);
 			break;
 		case BFA_PPORT_TRUNK_LINKDOWN:
 			/** todo: event notification */
@@ -939,37 +1309,37 @@ bfa_pport_isr(struct bfa_s *bfa, struct 
 		}
 		break;
 
-	case BFI_PPORT_I2H_GET_STATS_RSP:
-	case BFI_PPORT_I2H_GET_QOS_STATS_RSP:
+	case BFI_FCPORT_I2H_STATS_GET_RSP:
 		/*
 		 * check for timer pop before processing the rsp
 		 */
-		if (pport->stats_busy == BFA_FALSE
-		    || pport->stats_status == BFA_STATUS_ETIMER)
+		if (fcport->stats_busy == BFA_FALSE ||
+		    fcport->stats_status == BFA_STATUS_ETIMER)
 			break;
 
-		bfa_timer_stop(&pport->timer);
-		pport->stats_status = i2hmsg.getstats_rsp->status;
-		bfa_cb_queue(pport->bfa, &pport->hcb_qe, __bfa_cb_port_stats,
-			     pport);
+		bfa_timer_stop(&fcport->timer);
+		fcport->stats_status = i2hmsg.pstatsget_rsp->status;
+		bfa_cb_queue(fcport->bfa, &fcport->hcb_qe,
+				__bfa_cb_fcport_stats_get, fcport);
 		break;
-	case BFI_PPORT_I2H_CLEAR_STATS_RSP:
-	case BFI_PPORT_I2H_CLEAR_QOS_STATS_RSP:
+
+	case BFI_FCPORT_I2H_STATS_CLEAR_RSP:
 		/*
 		 * check for timer pop before processing the rsp
 		 */
-		if (pport->stats_busy == BFA_FALSE
-		    || pport->stats_status == BFA_STATUS_ETIMER)
+		if (fcport->stats_busy == BFA_FALSE ||
+		    fcport->stats_status == BFA_STATUS_ETIMER)
 			break;
 
-		bfa_timer_stop(&pport->timer);
-		pport->stats_status = BFA_STATUS_OK;
-		bfa_cb_queue(pport->bfa, &pport->hcb_qe,
-			     __bfa_cb_port_stats_clr, pport);
+		bfa_timer_stop(&fcport->timer);
+		fcport->stats_status = BFA_STATUS_OK;
+		bfa_cb_queue(fcport->bfa, &fcport->hcb_qe,
+				__bfa_cb_fcport_stats_clr, fcport);
 		break;
 
 	default:
 		bfa_assert(0);
+	break;
 	}
 }
 
@@ -983,35 +1353,36 @@ bfa_pport_isr(struct bfa_s *bfa, struct 
  * Registered callback for port events.
  */
 void
-bfa_pport_event_register(struct bfa_s *bfa,
-			 void (*cbfn) (void *cbarg, bfa_pport_event_t event),
-			 void *cbarg)
+bfa_fcport_event_register(struct bfa_s *bfa,
+				void (*cbfn) (void *cbarg,
+				bfa_pport_event_t event),
+				void *cbarg)
 {
-	struct bfa_pport_s *pport = BFA_PORT_MOD(bfa);
+	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
-	pport->event_cbfn = cbfn;
-	pport->event_cbarg = cbarg;
+	fcport->event_cbfn = cbfn;
+	fcport->event_cbarg = cbarg;
 }
 
 bfa_status_t
-bfa_pport_enable(struct bfa_s *bfa)
+bfa_fcport_enable(struct bfa_s *bfa)
 {
-	struct bfa_pport_s *pport = BFA_PORT_MOD(bfa);
+	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
-	if (pport->diag_busy)
-		return (BFA_STATUS_DIAG_BUSY);
-	else if (bfa_sm_cmp_state
-		 (BFA_PORT_MOD(bfa), bfa_pport_sm_disabling_qwait))
-		return (BFA_STATUS_DEVBUSY);
+	if (fcport->diag_busy)
+		return BFA_STATUS_DIAG_BUSY;
+	else if (bfa_sm_cmp_state(BFA_FCPORT_MOD(bfa),
+					bfa_fcport_sm_disabling_qwait))
+		return BFA_STATUS_DEVBUSY;
 
-	bfa_sm_send_event(BFA_PORT_MOD(bfa), BFA_PPORT_SM_ENABLE);
+	bfa_sm_send_event(BFA_FCPORT_MOD(bfa), BFA_FCPORT_SM_ENABLE);
 	return BFA_STATUS_OK;
 }
 
 bfa_status_t
-bfa_pport_disable(struct bfa_s *bfa)
+bfa_fcport_disable(struct bfa_s *bfa)
 {
-	bfa_sm_send_event(BFA_PORT_MOD(bfa), BFA_PPORT_SM_DISABLE);
+	bfa_sm_send_event(BFA_FCPORT_MOD(bfa), BFA_FCPORT_SM_DISABLE);
 	return BFA_STATUS_OK;
 }
 
@@ -1019,43 +1390,43 @@ bfa_pport_disable(struct bfa_s *bfa)
  * Configure port speed.
  */
 bfa_status_t
-bfa_pport_cfg_speed(struct bfa_s *bfa, enum bfa_pport_speed speed)
+bfa_fcport_cfg_speed(struct bfa_s *bfa, enum bfa_pport_speed speed)
 {
-	struct bfa_pport_s *pport = BFA_PORT_MOD(bfa);
+	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
 	bfa_trc(bfa, speed);
 
-	if ((speed != BFA_PPORT_SPEED_AUTO) && (speed > pport->speed_sup)) {
-		bfa_trc(bfa, pport->speed_sup);
+	if ((speed != BFA_PPORT_SPEED_AUTO) && (speed > fcport->speed_sup)) {
+		bfa_trc(bfa, fcport->speed_sup);
 		return BFA_STATUS_UNSUPP_SPEED;
 	}
 
-	pport->cfg.speed = speed;
+	fcport->cfg.speed = speed;
 
-	return (BFA_STATUS_OK);
+	return BFA_STATUS_OK;
 }
 
 /**
  * Get current speed.
  */
 enum bfa_pport_speed
-bfa_pport_get_speed(struct bfa_s *bfa)
+bfa_fcport_get_speed(struct bfa_s *bfa)
 {
-	struct bfa_pport_s *port = BFA_PORT_MOD(bfa);
+	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
-	return port->speed;
+	return fcport->speed;
 }
 
 /**
  * Configure port topology.
  */
 bfa_status_t
-bfa_pport_cfg_topology(struct bfa_s *bfa, enum bfa_pport_topology topology)
+bfa_fcport_cfg_topology(struct bfa_s *bfa, enum bfa_pport_topology topology)
 {
-	struct bfa_pport_s *pport = BFA_PORT_MOD(bfa);
+	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
 	bfa_trc(bfa, topology);
-	bfa_trc(bfa, pport->cfg.topology);
+	bfa_trc(bfa, fcport->cfg.topology);
 
 	switch (topology) {
 	case BFA_PPORT_TOPOLOGY_P2P:
@@ -1067,120 +1438,116 @@ bfa_pport_cfg_topology(struct bfa_s *bfa
 		return BFA_STATUS_EINVAL;
 	}
 
-	pport->cfg.topology = topology;
-	return (BFA_STATUS_OK);
+	fcport->cfg.topology = topology;
+	return BFA_STATUS_OK;
 }
 
 /**
  * Get current topology.
  */
 enum bfa_pport_topology
-bfa_pport_get_topology(struct bfa_s *bfa)
+bfa_fcport_get_topology(struct bfa_s *bfa)
 {
-	struct bfa_pport_s *port = BFA_PORT_MOD(bfa);
+	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
-	return port->topology;
+	return fcport->topology;
 }
 
 bfa_status_t
-bfa_pport_cfg_hardalpa(struct bfa_s *bfa, u8 alpa)
+bfa_fcport_cfg_hardalpa(struct bfa_s *bfa, u8 alpa)
 {
-	struct bfa_pport_s *pport = BFA_PORT_MOD(bfa);
+	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
 	bfa_trc(bfa, alpa);
-	bfa_trc(bfa, pport->cfg.cfg_hardalpa);
-	bfa_trc(bfa, pport->cfg.hardalpa);
+	bfa_trc(bfa, fcport->cfg.cfg_hardalpa);
+	bfa_trc(bfa, fcport->cfg.hardalpa);
 
-	pport->cfg.cfg_hardalpa = BFA_TRUE;
-	pport->cfg.hardalpa = alpa;
+	fcport->cfg.cfg_hardalpa = BFA_TRUE;
+	fcport->cfg.hardalpa = alpa;
 
-	return (BFA_STATUS_OK);
+	return BFA_STATUS_OK;
 }
 
 bfa_status_t
-bfa_pport_clr_hardalpa(struct bfa_s *bfa)
+bfa_fcport_clr_hardalpa(struct bfa_s *bfa)
 {
-	struct bfa_pport_s *pport = BFA_PORT_MOD(bfa);
+	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
-	bfa_trc(bfa, pport->cfg.cfg_hardalpa);
-	bfa_trc(bfa, pport->cfg.hardalpa);
+	bfa_trc(bfa, fcport->cfg.cfg_hardalpa);
+	bfa_trc(bfa, fcport->cfg.hardalpa);
 
-	pport->cfg.cfg_hardalpa = BFA_FALSE;
-	return (BFA_STATUS_OK);
+	fcport->cfg.cfg_hardalpa = BFA_FALSE;
+	return BFA_STATUS_OK;
 }
 
 bfa_boolean_t
-bfa_pport_get_hardalpa(struct bfa_s *bfa, u8 *alpa)
+bfa_fcport_get_hardalpa(struct bfa_s *bfa, u8 *alpa)
 {
-	struct bfa_pport_s *port = BFA_PORT_MOD(bfa);
+	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
-	*alpa = port->cfg.hardalpa;
-	return port->cfg.cfg_hardalpa;
+	*alpa = fcport->cfg.hardalpa;
+	return fcport->cfg.cfg_hardalpa;
 }
 
 u8
-bfa_pport_get_myalpa(struct bfa_s *bfa)
+bfa_fcport_get_myalpa(struct bfa_s *bfa)
 {
-	struct bfa_pport_s *port = BFA_PORT_MOD(bfa);
+	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
-	return port->myalpa;
+	return fcport->myalpa;
 }
 
 bfa_status_t
-bfa_pport_cfg_maxfrsize(struct bfa_s *bfa, u16 maxfrsize)
+bfa_fcport_cfg_maxfrsize(struct bfa_s *bfa, u16 maxfrsize)
 {
-	struct bfa_pport_s *pport = BFA_PORT_MOD(bfa);
+	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
 	bfa_trc(bfa, maxfrsize);
-	bfa_trc(bfa, pport->cfg.maxfrsize);
+	bfa_trc(bfa, fcport->cfg.maxfrsize);
 
-	/*
-	 * with in range
-	 */
+	/* with in range */
 	if ((maxfrsize > FC_MAX_PDUSZ) || (maxfrsize < FC_MIN_PDUSZ))
-		return (BFA_STATUS_INVLD_DFSZ);
+		return BFA_STATUS_INVLD_DFSZ;
 
-	/*
-	 * power of 2, if not the max frame size of 2112
-	 */
+	/* power of 2, if not the max frame size of 2112 */
 	if ((maxfrsize != FC_MAX_PDUSZ) && (maxfrsize & (maxfrsize - 1)))
-		return (BFA_STATUS_INVLD_DFSZ);
+		return BFA_STATUS_INVLD_DFSZ;
 
-	pport->cfg.maxfrsize = maxfrsize;
-	return (BFA_STATUS_OK);
+	fcport->cfg.maxfrsize = maxfrsize;
+	return BFA_STATUS_OK;
 }
 
 u16
-bfa_pport_get_maxfrsize(struct bfa_s *bfa)
+bfa_fcport_get_maxfrsize(struct bfa_s *bfa)
 {
-	struct bfa_pport_s *port = BFA_PORT_MOD(bfa);
+	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
-	return port->cfg.maxfrsize;
+	return fcport->cfg.maxfrsize;
 }
 
 u32
-bfa_pport_mypid(struct bfa_s *bfa)
+bfa_fcport_mypid(struct bfa_s *bfa)
 {
-	struct bfa_pport_s *port = BFA_PORT_MOD(bfa);
+	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
-	return port->mypid;
+	return fcport->mypid;
 }
 
 u8
-bfa_pport_get_rx_bbcredit(struct bfa_s *bfa)
+bfa_fcport_get_rx_bbcredit(struct bfa_s *bfa)
 {
-	struct bfa_pport_s *port = BFA_PORT_MOD(bfa);
+	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
-	return port->cfg.rx_bbcredit;
+	return fcport->cfg.rx_bbcredit;
 }
 
 void
-bfa_pport_set_tx_bbcredit(struct bfa_s *bfa, u16 tx_bbcredit)
+bfa_fcport_set_tx_bbcredit(struct bfa_s *bfa, u16 tx_bbcredit)
 {
-	struct bfa_pport_s *port = BFA_PORT_MOD(bfa);
+	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
-	port->cfg.tx_bbcredit = (u8) tx_bbcredit;
-	bfa_port_send_txcredit(port);
+	fcport->cfg.tx_bbcredit = (u8)tx_bbcredit;
+	bfa_fcport_send_txcredit(fcport);
 }
 
 /**
@@ -1188,484 +1555,333 @@ bfa_pport_set_tx_bbcredit(struct bfa_s *
  */
 
 wwn_t
-bfa_pport_get_wwn(struct bfa_s *bfa, bfa_boolean_t node)
+bfa_fcport_get_wwn(struct bfa_s *bfa, bfa_boolean_t node)
 {
-	struct bfa_pport_s *pport = BFA_PORT_MOD(bfa);
+	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 	if (node)
-		return pport->nwwn;
+		return fcport->nwwn;
 	else
-		return pport->pwwn;
+		return fcport->pwwn;
 }
 
 void
-bfa_pport_get_attr(struct bfa_s *bfa, struct bfa_pport_attr_s *attr)
+bfa_fcport_get_attr(struct bfa_s *bfa, struct bfa_pport_attr_s *attr)
 {
-	struct bfa_pport_s *pport = BFA_PORT_MOD(bfa);
+	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
 	bfa_os_memset(attr, 0, sizeof(struct bfa_pport_attr_s));
 
-	attr->nwwn = pport->nwwn;
-	attr->pwwn = pport->pwwn;
+	attr->nwwn = fcport->nwwn;
+	attr->pwwn = fcport->pwwn;
 
-	bfa_os_memcpy(&attr->pport_cfg, &pport->cfg,
-		      sizeof(struct bfa_pport_cfg_s));
-	/*
-	 * speed attributes
-	 */
-	attr->pport_cfg.speed = pport->cfg.speed;
-	attr->speed_supported = pport->speed_sup;
-	attr->speed = pport->speed;
+	bfa_os_memcpy(&attr->pport_cfg, &fcport->cfg,
+		sizeof(struct bfa_pport_cfg_s));
+	/* speed attributes */
+	attr->pport_cfg.speed = fcport->cfg.speed;
+	attr->speed_supported = fcport->speed_sup;
+	attr->speed = fcport->speed;
 	attr->cos_supported = FC_CLASS_3;
 
-	/*
-	 * topology attributes
-	 */
-	attr->pport_cfg.topology = pport->cfg.topology;
-	attr->topology = pport->topology;
-
-	/*
-	 * beacon attributes
-	 */
-	attr->beacon = pport->beacon;
-	attr->link_e2e_beacon = pport->link_e2e_beacon;
-	attr->plog_enabled = bfa_plog_get_setting(pport->bfa->plog);
-
-	attr->pport_cfg.path_tov = bfa_fcpim_path_tov_get(bfa);
-	attr->pport_cfg.q_depth = bfa_fcpim_qdepth_get(bfa);
-	attr->port_state = bfa_sm_to_state(hal_pport_sm_table, pport->sm);
-	if (bfa_ioc_is_disabled(&pport->bfa->ioc))
+	/* topology attributes */
+	attr->pport_cfg.topology = fcport->cfg.topology;
+	attr->topology = fcport->topology;
+
+	/* beacon attributes */
+	attr->beacon = fcport->beacon;
+	attr->link_e2e_beacon = fcport->link_e2e_beacon;
+	attr->plog_enabled = bfa_plog_get_setting(fcport->bfa->plog);
+
+	attr->pport_cfg.path_tov  = bfa_fcpim_path_tov_get(bfa);
+	attr->pport_cfg.q_depth  = bfa_fcpim_qdepth_get(bfa);
+	attr->port_state = bfa_sm_to_state(hal_pport_sm_table, fcport->sm);
+	if (bfa_ioc_is_disabled(&fcport->bfa->ioc))
 		attr->port_state = BFA_PPORT_ST_IOCDIS;
-	else if (bfa_ioc_fw_mismatch(&pport->bfa->ioc))
+	else if (bfa_ioc_fw_mismatch(&fcport->bfa->ioc))
 		attr->port_state = BFA_PPORT_ST_FWMISMATCH;
 }
 
-static void
-bfa_port_stats_query(void *cbarg)
-{
-	struct bfa_pport_s *port = (struct bfa_pport_s *)cbarg;
-	bfi_pport_get_stats_req_t *msg;
+#define BFA_FCPORT_STATS_TOV	1000
 
-	msg = bfa_reqq_next(port->bfa, BFA_REQQ_PORT);
-
-	if (!msg) {
-		port->stats_qfull = BFA_TRUE;
-		bfa_reqq_winit(&port->stats_reqq_wait, bfa_port_stats_query,
-			       port);
-		bfa_reqq_wait(port->bfa, BFA_REQQ_PORT, &port->stats_reqq_wait);
-		return;
-	}
-	port->stats_qfull = BFA_FALSE;
-
-	bfa_os_memset(msg, 0, sizeof(bfi_pport_get_stats_req_t));
-	bfi_h2i_set(msg->mh, BFI_MC_FC_PORT, BFI_PPORT_H2I_GET_STATS_REQ,
-		    bfa_lpuid(port->bfa));
-	bfa_reqq_produce(port->bfa, BFA_REQQ_PORT);
-
-	return;
-}
-
-static void
-bfa_port_stats_clear(void *cbarg)
-{
-	struct bfa_pport_s *port = (struct bfa_pport_s *)cbarg;
-	bfi_pport_clear_stats_req_t *msg;
-
-	msg = bfa_reqq_next(port->bfa, BFA_REQQ_PORT);
-
-	if (!msg) {
-		port->stats_qfull = BFA_TRUE;
-		bfa_reqq_winit(&port->stats_reqq_wait, bfa_port_stats_clear,
-			       port);
-		bfa_reqq_wait(port->bfa, BFA_REQQ_PORT, &port->stats_reqq_wait);
-		return;
-	}
-	port->stats_qfull = BFA_FALSE;
-
-	bfa_os_memset(msg, 0, sizeof(bfi_pport_clear_stats_req_t));
-	bfi_h2i_set(msg->mh, BFI_MC_FC_PORT, BFI_PPORT_H2I_CLEAR_STATS_REQ,
-		    bfa_lpuid(port->bfa));
-	bfa_reqq_produce(port->bfa, BFA_REQQ_PORT);
-	return;
-}
-
-static void
-bfa_port_qos_stats_clear(void *cbarg)
+/**
+ * Fetch port statistics (FCQoS or FCoE).
+ */
+bfa_status_t
+bfa_fcport_get_stats(struct bfa_s *bfa, union bfa_fcport_stats_u *stats,
+	bfa_cb_pport_t cbfn, void *cbarg)
 {
-	struct bfa_pport_s *port = (struct bfa_pport_s *)cbarg;
-	bfi_pport_clear_qos_stats_req_t *msg;
-
-	msg = bfa_reqq_next(port->bfa, BFA_REQQ_PORT);
+	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
-	if (!msg) {
-		port->stats_qfull = BFA_TRUE;
-		bfa_reqq_winit(&port->stats_reqq_wait, bfa_port_qos_stats_clear,
-			       port);
-		bfa_reqq_wait(port->bfa, BFA_REQQ_PORT, &port->stats_reqq_wait);
-		return;
+	if (fcport->stats_busy) {
+		bfa_trc(bfa, fcport->stats_busy);
+		return BFA_STATUS_DEVBUSY;
 	}
-	port->stats_qfull = BFA_FALSE;
 
-	bfa_os_memset(msg, 0, sizeof(bfi_pport_clear_qos_stats_req_t));
-	bfi_h2i_set(msg->mh, BFI_MC_FC_PORT, BFI_PPORT_H2I_CLEAR_QOS_STATS_REQ,
-		    bfa_lpuid(port->bfa));
-	bfa_reqq_produce(port->bfa, BFA_REQQ_PORT);
-	return;
-}
+	fcport->stats_busy  = BFA_TRUE;
+	fcport->stats_ret   = stats;
+	fcport->stats_cbfn  = cbfn;
+	fcport->stats_cbarg = cbarg;
 
-static void
-bfa_pport_stats_swap(union bfa_pport_stats_u *d, union bfa_pport_stats_u *s)
-{
-	u32       *dip = (u32 *) d;
-	u32       *sip = (u32 *) s;
-	int             i;
+	bfa_fcport_send_stats_get(fcport);
 
-	/*
-	 * Do 64 bit fields swap first
-	 */
-	for (i = 0;
-	     i <
-	     ((sizeof(union bfa_pport_stats_u) -
-	       sizeof(struct bfa_qos_stats_s)) / sizeof(u32)); i = i + 2) {
-#ifdef __BIGENDIAN
-		dip[i] = bfa_os_ntohl(sip[i]);
-		dip[i + 1] = bfa_os_ntohl(sip[i + 1]);
-#else
-		dip[i] = bfa_os_ntohl(sip[i + 1]);
-		dip[i + 1] = bfa_os_ntohl(sip[i]);
-#endif
-	}
-
-	/*
-	 * Now swap the 32 bit fields
-	 */
-	for (; i < (sizeof(union bfa_pport_stats_u) / sizeof(u32)); ++i)
-		dip[i] = bfa_os_ntohl(sip[i]);
+	bfa_timer_start(bfa, &fcport->timer, bfa_fcport_stats_get_timeout,
+			fcport, BFA_FCPORT_STATS_TOV);
+	return BFA_STATUS_OK;
 }
 
-static void
-__bfa_cb_port_stats_clr(void *cbarg, bfa_boolean_t complete)
+/**
+ * Reset port statistics (FCQoS or FCoE).
+ */
+bfa_status_t
+bfa_fcport_clear_stats(struct bfa_s *bfa, bfa_cb_pport_t cbfn, void *cbarg)
 {
-	struct bfa_pport_s *port = cbarg;
+	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
-	if (complete) {
-		port->stats_cbfn(port->stats_cbarg, port->stats_status);
-	} else {
-		port->stats_busy = BFA_FALSE;
-		port->stats_status = BFA_STATUS_OK;
+	if (fcport->stats_busy) {
+		bfa_trc(bfa, fcport->stats_busy);
+		return BFA_STATUS_DEVBUSY;
 	}
-}
-
-static void
-bfa_port_stats_clr_timeout(void *cbarg)
-{
-	struct bfa_pport_s *port = (struct bfa_pport_s *)cbarg;
 
-	bfa_trc(port->bfa, port->stats_qfull);
+	fcport->stats_busy  = BFA_TRUE;
+	fcport->stats_cbfn  = cbfn;
+	fcport->stats_cbarg = cbarg;
 
-	if (port->stats_qfull) {
-		bfa_reqq_wcancel(&port->stats_reqq_wait);
-		port->stats_qfull = BFA_FALSE;
-	}
+	bfa_fcport_send_stats_clear(fcport);
 
-	port->stats_status = BFA_STATUS_ETIMER;
-	bfa_cb_queue(port->bfa, &port->hcb_qe, __bfa_cb_port_stats_clr, port);
+	bfa_timer_start(bfa, &fcport->timer, bfa_fcport_stats_clr_timeout,
+			fcport, BFA_FCPORT_STATS_TOV);
+	return BFA_STATUS_OK;
 }
 
-static void
-__bfa_cb_port_stats(void *cbarg, bfa_boolean_t complete)
+/**
+ * Fetch FCQoS port statistics
+ */
+bfa_status_t
+bfa_fcport_get_qos_stats(struct bfa_s *bfa, union bfa_fcport_stats_u *stats,
+	bfa_cb_pport_t cbfn, void *cbarg)
 {
-	struct bfa_pport_s *port = cbarg;
+	/* Meaningful only for FC mode */
+	bfa_assert(bfa_ioc_get_fcmode(&bfa->ioc));
 
-	if (complete) {
-		if (port->stats_status == BFA_STATUS_OK)
-			bfa_pport_stats_swap(port->stats_ret, port->stats);
-		port->stats_cbfn(port->stats_cbarg, port->stats_status);
-	} else {
-		port->stats_busy = BFA_FALSE;
-		port->stats_status = BFA_STATUS_OK;
-	}
+	return bfa_fcport_get_stats(bfa, stats, cbfn, cbarg);
 }
 
-static void
-bfa_port_stats_timeout(void *cbarg)
+/**
+ * Reset FCoE port statistics
+ */
+bfa_status_t
+bfa_fcport_clear_qos_stats(struct bfa_s *bfa, bfa_cb_pport_t cbfn, void *cbarg)
 {
-	struct bfa_pport_s *port = (struct bfa_pport_s *)cbarg;
-
-	bfa_trc(port->bfa, port->stats_qfull);
-
-	if (port->stats_qfull) {
-		bfa_reqq_wcancel(&port->stats_reqq_wait);
-		port->stats_qfull = BFA_FALSE;
-	}
+	/* Meaningful only for FC mode */
+	bfa_assert(bfa_ioc_get_fcmode(&bfa->ioc));
 
-	port->stats_status = BFA_STATUS_ETIMER;
-	bfa_cb_queue(port->bfa, &port->hcb_qe, __bfa_cb_port_stats, port);
+	return bfa_fcport_clear_stats(bfa, cbfn, cbarg);
 }
 
-#define BFA_PORT_STATS_TOV	1000
-
 /**
- * Fetch port attributes.
+ * Fetch FCQoS port statistics
  */
 bfa_status_t
-bfa_pport_get_stats(struct bfa_s *bfa, union bfa_pport_stats_u *stats,
-		    bfa_cb_pport_t cbfn, void *cbarg)
+bfa_fcport_get_fcoe_stats(struct bfa_s *bfa, union bfa_fcport_stats_u *stats,
+	bfa_cb_pport_t cbfn, void *cbarg)
 {
-	struct bfa_pport_s *port = BFA_PORT_MOD(bfa);
-
-	if (port->stats_busy) {
-		bfa_trc(bfa, port->stats_busy);
-		return (BFA_STATUS_DEVBUSY);
-	}
+	/* Meaningful only for FCoE mode */
+	bfa_assert(!bfa_ioc_get_fcmode(&bfa->ioc));
 
-	port->stats_busy = BFA_TRUE;
-	port->stats_ret = stats;
-	port->stats_cbfn = cbfn;
-	port->stats_cbarg = cbarg;
-
-	bfa_port_stats_query(port);
-
-	bfa_timer_start(bfa, &port->timer, bfa_port_stats_timeout, port,
-			BFA_PORT_STATS_TOV);
-	return (BFA_STATUS_OK);
+	return bfa_fcport_get_stats(bfa, stats, cbfn, cbarg);
 }
 
+/**
+ * Reset FCoE port statistics
+ */
 bfa_status_t
-bfa_pport_clear_stats(struct bfa_s *bfa, bfa_cb_pport_t cbfn, void *cbarg)
+bfa_fcport_clear_fcoe_stats(struct bfa_s *bfa, bfa_cb_pport_t cbfn, void *cbarg)
 {
-	struct bfa_pport_s *port = BFA_PORT_MOD(bfa);
-
-	if (port->stats_busy) {
-		bfa_trc(bfa, port->stats_busy);
-		return (BFA_STATUS_DEVBUSY);
-	}
-
-	port->stats_busy = BFA_TRUE;
-	port->stats_cbfn = cbfn;
-	port->stats_cbarg = cbarg;
-
-	bfa_port_stats_clear(port);
+	/* Meaningful only for FCoE mode */
+	bfa_assert(!bfa_ioc_get_fcmode(&bfa->ioc));
 
-	bfa_timer_start(bfa, &port->timer, bfa_port_stats_clr_timeout, port,
-			BFA_PORT_STATS_TOV);
-	return (BFA_STATUS_OK);
+	return bfa_fcport_clear_stats(bfa, cbfn, cbarg);
 }
 
 bfa_status_t
-bfa_pport_trunk_enable(struct bfa_s *bfa, u8 bitmap)
+bfa_fcport_trunk_enable(struct bfa_s *bfa, u8 bitmap)
 {
-	struct bfa_pport_s *pport = BFA_PORT_MOD(bfa);
+	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
 	bfa_trc(bfa, bitmap);
-	bfa_trc(bfa, pport->cfg.trunked);
-	bfa_trc(bfa, pport->cfg.trunk_ports);
+	bfa_trc(bfa, fcport->cfg.trunked);
+	bfa_trc(bfa, fcport->cfg.trunk_ports);
 
 	if (!bitmap || (bitmap & (bitmap - 1)))
 		return BFA_STATUS_EINVAL;
 
-	pport->cfg.trunked = BFA_TRUE;
-	pport->cfg.trunk_ports = bitmap;
+	fcport->cfg.trunked = BFA_TRUE;
+	fcport->cfg.trunk_ports = bitmap;
 
 	return BFA_STATUS_OK;
 }
 
 void
-bfa_pport_qos_get_attr(struct bfa_s *bfa, struct bfa_qos_attr_s *qos_attr)
+bfa_fcport_qos_get_attr(struct bfa_s *bfa, struct bfa_qos_attr_s *qos_attr)
 {
-	struct bfa_pport_s *pport = BFA_PORT_MOD(bfa);
+	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
-	qos_attr->state = bfa_os_ntohl(pport->qos_attr.state);
-	qos_attr->total_bb_cr = bfa_os_ntohl(pport->qos_attr.total_bb_cr);
+	qos_attr->state = bfa_os_ntohl(fcport->qos_attr.state);
+	qos_attr->total_bb_cr = bfa_os_ntohl(fcport->qos_attr.total_bb_cr);
 }
 
 void
-bfa_pport_qos_get_vc_attr(struct bfa_s *bfa,
-			  struct bfa_qos_vc_attr_s *qos_vc_attr)
+bfa_fcport_qos_get_vc_attr(struct bfa_s *bfa,
+	struct bfa_qos_vc_attr_s *qos_vc_attr)
 {
-	struct bfa_pport_s *pport = BFA_PORT_MOD(bfa);
-	struct bfa_qos_vc_attr_s *bfa_vc_attr = &pport->qos_vc_attr;
-	u32        i = 0;
+	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
+	struct bfa_qos_vc_attr_s *bfa_vc_attr = &fcport->qos_vc_attr;
+	u32 i = 0;
 
 	qos_vc_attr->total_vc_count = bfa_os_ntohs(bfa_vc_attr->total_vc_count);
-	qos_vc_attr->shared_credit = bfa_os_ntohs(bfa_vc_attr->shared_credit);
-	qos_vc_attr->elp_opmode_flags =
-		bfa_os_ntohl(bfa_vc_attr->elp_opmode_flags);
+	qos_vc_attr->shared_credit  = bfa_os_ntohs(bfa_vc_attr->shared_credit);
+	qos_vc_attr->elp_opmode_flags  =
+			bfa_os_ntohl(bfa_vc_attr->elp_opmode_flags);
 
-	/*
-	 * Individual VC info
-	 */
+	/* Individual VC info */
 	while (i < qos_vc_attr->total_vc_count) {
-		qos_vc_attr->vc_info[i].vc_credit =
-			bfa_vc_attr->vc_info[i].vc_credit;
-		qos_vc_attr->vc_info[i].borrow_credit =
-			bfa_vc_attr->vc_info[i].borrow_credit;
-		qos_vc_attr->vc_info[i].priority =
-			bfa_vc_attr->vc_info[i].priority;
+		qos_vc_attr->vc_info[i].vc_credit	=
+				bfa_vc_attr->vc_info[i].vc_credit;
+		qos_vc_attr->vc_info[i].borrow_credit	=
+				bfa_vc_attr->vc_info[i].borrow_credit;
+		qos_vc_attr->vc_info[i].priority	=
+				bfa_vc_attr->vc_info[i].priority;
 		++i;
 	}
 }
 
 /**
- * Fetch QoS Stats.
- */
-bfa_status_t
-bfa_pport_get_qos_stats(struct bfa_s *bfa, union bfa_pport_stats_u *stats,
-			bfa_cb_pport_t cbfn, void *cbarg)
-{
-	/*
-	 * QoS stats is embedded in port stats
-	 */
-	return (bfa_pport_get_stats(bfa, stats, cbfn, cbarg));
-}
-
-bfa_status_t
-bfa_pport_clear_qos_stats(struct bfa_s *bfa, bfa_cb_pport_t cbfn, void *cbarg)
-{
-	struct bfa_pport_s *port = BFA_PORT_MOD(bfa);
-
-	if (port->stats_busy) {
-		bfa_trc(bfa, port->stats_busy);
-		return (BFA_STATUS_DEVBUSY);
-	}
-
-	port->stats_busy = BFA_TRUE;
-	port->stats_cbfn = cbfn;
-	port->stats_cbarg = cbarg;
-
-	bfa_port_qos_stats_clear(port);
-
-	bfa_timer_start(bfa, &port->timer, bfa_port_stats_clr_timeout, port,
-			BFA_PORT_STATS_TOV);
-	return (BFA_STATUS_OK);
-}
-
-/**
  * Fetch port attributes.
  */
 bfa_status_t
-bfa_pport_trunk_disable(struct bfa_s *bfa)
+bfa_fcport_trunk_disable(struct bfa_s *bfa)
 {
-	return (BFA_STATUS_OK);
+	return BFA_STATUS_OK;
 }
 
 bfa_boolean_t
-bfa_pport_trunk_query(struct bfa_s *bfa, u32 *bitmap)
+bfa_fcport_trunk_query(struct bfa_s *bfa, u32 *bitmap)
 {
-	struct bfa_pport_s *port = BFA_PORT_MOD(bfa);
+	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
-	*bitmap = port->cfg.trunk_ports;
-	return port->cfg.trunked;
+	*bitmap = fcport->cfg.trunk_ports;
+	return fcport->cfg.trunked;
 }
 
 bfa_boolean_t
-bfa_pport_is_disabled(struct bfa_s *bfa)
+bfa_fcport_is_disabled(struct bfa_s *bfa)
 {
-	struct bfa_pport_s *port = BFA_PORT_MOD(bfa);
+	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
-	return (bfa_sm_to_state(hal_pport_sm_table, port->sm) ==
-		BFA_PPORT_ST_DISABLED);
+	return bfa_sm_to_state(hal_pport_sm_table, fcport->sm) ==
+		BFA_PPORT_ST_DISABLED;
 
 }
 
 bfa_boolean_t
-bfa_pport_is_ratelim(struct bfa_s *bfa)
+bfa_fcport_is_ratelim(struct bfa_s *bfa)
 {
-	struct bfa_pport_s *pport = BFA_PORT_MOD(bfa);
+	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
-return (pport->cfg.ratelimit ? BFA_TRUE : BFA_FALSE);
+	return fcport->cfg.ratelimit ? BFA_TRUE : BFA_FALSE;
 
 }
 
 void
-bfa_pport_cfg_qos(struct bfa_s *bfa, bfa_boolean_t on_off)
+bfa_fcport_cfg_qos(struct bfa_s *bfa, bfa_boolean_t on_off)
 {
-	struct bfa_pport_s *pport = BFA_PORT_MOD(bfa);
+	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
+	enum bfa_ioc_type_e ioc_type = bfa_get_type(bfa);
 
 	bfa_trc(bfa, on_off);
-	bfa_trc(bfa, pport->cfg.qos_enabled);
+	bfa_trc(bfa, fcport->cfg.qos_enabled);
+
+	bfa_trc(bfa, ioc_type);
 
-	pport->cfg.qos_enabled = on_off;
+	if (ioc_type == BFA_IOC_TYPE_FC)
+		fcport->cfg.qos_enabled = on_off;
 }
 
 void
-bfa_pport_cfg_ratelim(struct bfa_s *bfa, bfa_boolean_t on_off)
+bfa_fcport_cfg_ratelim(struct bfa_s *bfa, bfa_boolean_t on_off)
 {
-	struct bfa_pport_s *pport = BFA_PORT_MOD(bfa);
+	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
 	bfa_trc(bfa, on_off);
-	bfa_trc(bfa, pport->cfg.ratelimit);
+	bfa_trc(bfa, fcport->cfg.ratelimit);
 
-	pport->cfg.ratelimit = on_off;
-	if (pport->cfg.trl_def_speed == BFA_PPORT_SPEED_UNKNOWN)
-		pport->cfg.trl_def_speed = BFA_PPORT_SPEED_1GBPS;
+	fcport->cfg.ratelimit = on_off;
+	if (fcport->cfg.trl_def_speed == BFA_PPORT_SPEED_UNKNOWN)
+		fcport->cfg.trl_def_speed = BFA_PPORT_SPEED_1GBPS;
 }
 
 /**
  * Configure default minimum ratelim speed
  */
 bfa_status_t
-bfa_pport_cfg_ratelim_speed(struct bfa_s *bfa, enum bfa_pport_speed speed)
+bfa_fcport_cfg_ratelim_speed(struct bfa_s *bfa, enum bfa_pport_speed speed)
 {
-	struct bfa_pport_s *pport = BFA_PORT_MOD(bfa);
+	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
 	bfa_trc(bfa, speed);
 
-	/*
-	 * Auto and speeds greater than the supported speed, are invalid
-	 */
-	if ((speed == BFA_PPORT_SPEED_AUTO) || (speed > pport->speed_sup)) {
-		bfa_trc(bfa, pport->speed_sup);
+	/* Auto and speeds greater than the supported speed, are invalid */
+	if ((speed == BFA_PPORT_SPEED_AUTO) || (speed > fcport->speed_sup)) {
+		bfa_trc(bfa, fcport->speed_sup);
 		return BFA_STATUS_UNSUPP_SPEED;
 	}
 
-	pport->cfg.trl_def_speed = speed;
+	fcport->cfg.trl_def_speed = speed;
 
-	return (BFA_STATUS_OK);
+	return BFA_STATUS_OK;
 }
 
 /**
  * Get default minimum ratelim speed
  */
 enum bfa_pport_speed
-bfa_pport_get_ratelim_speed(struct bfa_s *bfa)
+bfa_fcport_get_ratelim_speed(struct bfa_s *bfa)
 {
-	struct bfa_pport_s *pport = BFA_PORT_MOD(bfa);
+	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
-	bfa_trc(bfa, pport->cfg.trl_def_speed);
-	return (pport->cfg.trl_def_speed);
+	bfa_trc(bfa, fcport->cfg.trl_def_speed);
+	return fcport->cfg.trl_def_speed;
 
 }
-
 void
-bfa_pport_busy(struct bfa_s *bfa, bfa_boolean_t status)
+bfa_fcport_busy(struct bfa_s *bfa, bfa_boolean_t status)
 {
-	struct bfa_pport_s *pport = BFA_PORT_MOD(bfa);
+	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
 	bfa_trc(bfa, status);
-	bfa_trc(bfa, pport->diag_busy);
+	bfa_trc(bfa, fcport->diag_busy);
 
-	pport->diag_busy = status;
+	fcport->diag_busy = status;
 }
 
 void
-bfa_pport_beacon(struct bfa_s *bfa, bfa_boolean_t beacon,
-		 bfa_boolean_t link_e2e_beacon)
+bfa_fcport_beacon(struct bfa_s *bfa, bfa_boolean_t beacon,
+	bfa_boolean_t link_e2e_beacon)
 {
-	struct bfa_pport_s *pport = BFA_PORT_MOD(bfa);
+	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
 	bfa_trc(bfa, beacon);
 	bfa_trc(bfa, link_e2e_beacon);
-	bfa_trc(bfa, pport->beacon);
-	bfa_trc(bfa, pport->link_e2e_beacon);
+	bfa_trc(bfa, fcport->beacon);
+	bfa_trc(bfa, fcport->link_e2e_beacon);
 
-	pport->beacon = beacon;
-	pport->link_e2e_beacon = link_e2e_beacon;
+	fcport->beacon = beacon;
+	fcport->link_e2e_beacon = link_e2e_beacon;
 }
 
 bfa_boolean_t
-bfa_pport_is_linkup(struct bfa_s *bfa)
+bfa_fcport_is_linkup(struct bfa_s *bfa)
 {
-	return bfa_sm_cmp_state(BFA_PORT_MOD(bfa), bfa_pport_sm_linkup);
+	return bfa_sm_cmp_state(BFA_FCPORT_MOD(bfa), bfa_fcport_sm_linkup);
 }
 
 
diff -uprN a/drivers/scsi/bfa/bfa_fcs.c b/drivers/scsi/bfa/bfa_fcs.c
--- a/drivers/scsi/bfa/bfa_fcs.c	2009-12-18 18:16:22.494686000 -0800
+++ b/drivers/scsi/bfa/bfa_fcs.c	2009-11-25 18:21:06.000000000 -0800
@@ -36,19 +36,18 @@
  * FCS sub-modules
  */
 struct bfa_fcs_mod_s {
-	void            (*modinit) (struct bfa_fcs_s *fcs);
-	void            (*modexit) (struct bfa_fcs_s *fcs);
+	void		(*attach) (struct bfa_fcs_s *fcs);
+	void		(*modinit) (struct bfa_fcs_s *fcs);
+	void		(*modexit) (struct bfa_fcs_s *fcs);
 };
 
 #define BFA_FCS_MODULE(_mod) { _mod ## _modinit, _mod ## _modexit }
 
 static struct bfa_fcs_mod_s fcs_modules[] = {
-	BFA_FCS_MODULE(bfa_fcs_pport),
-	BFA_FCS_MODULE(bfa_fcs_uf),
-	BFA_FCS_MODULE(bfa_fcs_fabric),
-	BFA_FCS_MODULE(bfa_fcs_vport),
-	BFA_FCS_MODULE(bfa_fcs_rport),
-	BFA_FCS_MODULE(bfa_fcs_fcpim),
+	{ bfa_fcs_pport_attach, NULL, NULL },
+	{ bfa_fcs_uf_attach, NULL, NULL },
+	{ bfa_fcs_fabric_attach, bfa_fcs_fabric_modinit,
+	  bfa_fcs_fabric_modexit },
 };
 
 /**
@@ -58,7 +57,7 @@ static struct bfa_fcs_mod_s fcs_modules[
 static void
 bfa_fcs_exit_comp(void *fcs_cbarg)
 {
-	struct bfa_fcs_s *fcs = fcs_cbarg;
+	struct bfa_fcs_s      *fcs = fcs_cbarg;
 	struct bfad_s *bfad = fcs->bfad;
 
 	complete(&bfad->comp);
@@ -71,19 +70,13 @@ bfa_fcs_exit_comp(void *fcs_cbarg)
  */
 
 /**
- * 		FCS instance initialization.
- *
- * 	param[in]		fcs		FCS instance
- * 	param[in]		bfa		BFA instance
- * 	param[in]		bfad		BFA driver instance
- *
- * 	return None
+ * fcs attach -- called once to initialize data structures at driver attach time
  */
 void
-bfa_fcs_init(struct bfa_fcs_s *fcs, struct bfa_s *bfa, struct bfad_s *bfad,
-			bfa_boolean_t min_cfg)
+bfa_fcs_attach(struct bfa_fcs_s *fcs, struct bfa_s *bfa, struct bfad_s *bfad,
+	       bfa_boolean_t min_cfg)
 {
-	int             i;
+	int		i;
 	struct bfa_fcs_mod_s  *mod;
 
 	fcs->bfa = bfa;
@@ -95,7 +88,24 @@ bfa_fcs_init(struct bfa_fcs_s *fcs, stru
 
 	for (i = 0; i < sizeof(fcs_modules) / sizeof(fcs_modules[0]); i++) {
 		mod = &fcs_modules[i];
-		mod->modinit(fcs);
+		if (mod->attach)
+			mod->attach(fcs);
+	}
+}
+
+/**
+ * fcs initialization, called once after bfa initialization is complete
+ */
+void
+bfa_fcs_init(struct bfa_fcs_s *fcs)
+{
+	int		i;
+	struct bfa_fcs_mod_s  *mod;
+
+	for (i = 0; i < sizeof(fcs_modules) / sizeof(fcs_modules[0]); i++) {
+		mod = &fcs_modules[i];
+		if (mod->modinit)
+			mod->modinit(fcs);
 	}
 }
 
@@ -109,16 +119,17 @@ bfa_fcs_start(struct bfa_fcs_s *fcs)
 }
 
 /**
- * 		FCS driver details initialization.
+ *	brief
+ *		FCS driver details initialization.
  *
- * 	param[in]		fcs		FCS instance
- * 	param[in]		driver_info	Driver Details
+ *	param[in]		fcs		FCS instance
+ *	param[in]		driver_info	Driver Details
  *
- * 	return None
+ *	return None
  */
 void
 bfa_fcs_driver_info_init(struct bfa_fcs_s *fcs,
-			struct bfa_fcs_driver_info_s *driver_info)
+				struct bfa_fcs_driver_info_s *driver_info)
 {
 
 	fcs->driver_info = *driver_info;
@@ -127,26 +138,45 @@ bfa_fcs_driver_info_init(struct bfa_fcs_
 }
 
 /**
- * 		FCS instance cleanup and exit.
+ *	brief
+ *		FCS FDMI Driver Parameter Initialization
+ *
+ *	param[in]		fcs		FCS instance
+ *	param[in]		fdmi_enable	TRUE/FALSE
+ *
+ *	return None
+ */
+void
+bfa_fcs_set_fdmi_param(struct bfa_fcs_s *fcs, bfa_boolean_t fdmi_enable)
+{
+
+	fcs->fdmi_enabled = fdmi_enable;
+
+}
+/**
+ *	brief
+ *		FCS instance cleanup and exit.
  *
- * 	param[in]		fcs			FCS instance
- * 	return None
+ *	param[in]		fcs			FCS instance
+ *	return None
  */
 void
 bfa_fcs_exit(struct bfa_fcs_s *fcs)
 {
 	struct bfa_fcs_mod_s  *mod;
-	int             nmods, i;
+	int		nmods, i;
 
 	bfa_wc_init(&fcs->wc, bfa_fcs_exit_comp, fcs);
 
 	nmods = sizeof(fcs_modules) / sizeof(fcs_modules[0]);
 
 	for (i = 0; i < nmods; i++) {
-		bfa_wc_up(&fcs->wc);
 
 		mod = &fcs_modules[i];
-		mod->modexit(fcs);
+		if (mod->modexit) {
+			bfa_wc_up(&fcs->wc);
+			mod->modexit(fcs);
+		}
 	}
 
 	bfa_wc_wait(&fcs->wc);
diff -uprN a/drivers/scsi/bfa/bfa_fcs_lport.c b/drivers/scsi/bfa/bfa_fcs_lport.c
--- a/drivers/scsi/bfa/bfa_fcs_lport.c	2009-12-18 18:16:22.492687000 -0800
+++ b/drivers/scsi/bfa/bfa_fcs_lport.c	2009-11-25 18:21:06.000000000 -0800
@@ -43,11 +43,11 @@ BFA_TRC_FILE(FCS, PORT);
 static void     bfa_fcs_port_aen_post(struct bfa_fcs_port_s *port,
 				      enum bfa_lport_aen_event event);
 static void     bfa_fcs_port_send_ls_rjt(struct bfa_fcs_port_s *port,
-			struct fchs_s *rx_fchs, u8 reason_code,
-			u8 reason_code_expl);
+					 struct fchs_s *rx_fchs, u8 reason_code,
+					 u8 reason_code_expl);
 static void     bfa_fcs_port_plogi(struct bfa_fcs_port_s *port,
-			struct fchs_s *rx_fchs,
-			struct fc_logi_s *plogi);
+				struct fchs_s *rx_fchs,
+				   struct fc_logi_s *plogi);
 static void     bfa_fcs_port_online_actions(struct bfa_fcs_port_s *port);
 static void     bfa_fcs_port_offline_actions(struct bfa_fcs_port_s *port);
 static void     bfa_fcs_port_unknown_init(struct bfa_fcs_port_s *port);
@@ -55,13 +55,14 @@ static void     bfa_fcs_port_unknown_onl
 static void     bfa_fcs_port_unknown_offline(struct bfa_fcs_port_s *port);
 static void     bfa_fcs_port_deleted(struct bfa_fcs_port_s *port);
 static void     bfa_fcs_port_echo(struct bfa_fcs_port_s *port,
-			struct fchs_s *rx_fchs,
-			struct fc_echo_s *echo, u16 len);
+					struct fchs_s *rx_fchs,
+				  struct fc_echo_s *echo, u16 len);
 static void     bfa_fcs_port_rnid(struct bfa_fcs_port_s *port,
-			struct fchs_s *rx_fchs,
-			struct fc_rnid_cmd_s *rnid, u16 len);
+					struct fchs_s *rx_fchs,
+				  struct fc_rnid_cmd_s *rnid, u16 len);
 static void     bfa_fs_port_get_gen_topo_data(struct bfa_fcs_port_s *port,
-			struct fc_rnid_general_topology_data_s *gen_topo_data);
+			struct fc_rnid_general_topology_data_s *
+					      gen_topo_data);
 
 static struct {
 	void            (*init) (struct bfa_fcs_port_s *port);
@@ -75,7 +76,7 @@ static struct {
 			bfa_fcs_port_fab_offline}, {
 	bfa_fcs_port_loop_init, bfa_fcs_port_loop_online,
 			bfa_fcs_port_loop_offline}, {
-bfa_fcs_port_n2n_init, bfa_fcs_port_n2n_online,
+	bfa_fcs_port_n2n_init, bfa_fcs_port_n2n_online,
 			bfa_fcs_port_n2n_offline},};
 
 /**
@@ -114,12 +115,13 @@ bfa_fcs_port_sm_uninit(struct bfa_fcs_po
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(port->fcs, event);
 	}
 }
 
 static void
-bfa_fcs_port_sm_init(struct bfa_fcs_port_s *port, enum bfa_fcs_port_event event)
+bfa_fcs_port_sm_init(struct bfa_fcs_port_s *port,
+			enum bfa_fcs_port_event event)
 {
 	bfa_trc(port->fcs, port->port_cfg.pwwn);
 	bfa_trc(port->fcs, event);
@@ -136,16 +138,16 @@ bfa_fcs_port_sm_init(struct bfa_fcs_port
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(port->fcs, event);
 	}
 }
 
 static void
 bfa_fcs_port_sm_online(struct bfa_fcs_port_s *port,
-			enum bfa_fcs_port_event event)
+				enum bfa_fcs_port_event event)
 {
 	struct bfa_fcs_rport_s *rport;
-	struct list_head *qe, *qen;
+	struct list_head        *qe, *qen;
 
 	bfa_trc(port->fcs, port->port_cfg.pwwn);
 	bfa_trc(port->fcs, event);
@@ -166,7 +168,7 @@ bfa_fcs_port_sm_online(struct bfa_fcs_po
 		} else {
 			bfa_sm_set_state(port, bfa_fcs_port_sm_deleting);
 			list_for_each_safe(qe, qen, &port->rport_q) {
-				rport = (struct bfa_fcs_rport_s *)qe;
+				rport = (struct bfa_fcs_rport_s *) qe;
 				bfa_fcs_rport_delete(rport);
 			}
 		}
@@ -176,7 +178,7 @@ bfa_fcs_port_sm_online(struct bfa_fcs_po
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(port->fcs, event);
 	}
 }
 
@@ -185,7 +187,7 @@ bfa_fcs_port_sm_offline(struct bfa_fcs_p
 			enum bfa_fcs_port_event event)
 {
 	struct bfa_fcs_rport_s *rport;
-	struct list_head *qe, *qen;
+	struct list_head        *qe, *qen;
 
 	bfa_trc(port->fcs, port->port_cfg.pwwn);
 	bfa_trc(port->fcs, event);
@@ -203,7 +205,7 @@ bfa_fcs_port_sm_offline(struct bfa_fcs_p
 		} else {
 			bfa_sm_set_state(port, bfa_fcs_port_sm_deleting);
 			list_for_each_safe(qe, qen, &port->rport_q) {
-				rport = (struct bfa_fcs_rport_s *)qe;
+				rport = (struct bfa_fcs_rport_s *) qe;
 				bfa_fcs_rport_delete(rport);
 			}
 		}
@@ -214,13 +216,13 @@ bfa_fcs_port_sm_offline(struct bfa_fcs_p
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(port->fcs, event);
 	}
 }
 
 static void
 bfa_fcs_port_sm_deleting(struct bfa_fcs_port_s *port,
-			 enum bfa_fcs_port_event event)
+			enum bfa_fcs_port_event event)
 {
 	bfa_trc(port->fcs, port->port_cfg.pwwn);
 	bfa_trc(port->fcs, event);
@@ -234,7 +236,7 @@ bfa_fcs_port_sm_deleting(struct bfa_fcs_
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(port->fcs, event);
 	}
 }
 
@@ -249,49 +251,26 @@ bfa_fcs_port_sm_deleting(struct bfa_fcs_
  */
 static void
 bfa_fcs_port_aen_post(struct bfa_fcs_port_s *port,
-		      enum bfa_lport_aen_event event)
+			enum bfa_lport_aen_event event)
 {
-	union bfa_aen_data_u aen_data;
+	union bfa_aen_data_u  aen_data;
 	struct bfa_log_mod_s *logmod = port->fcs->logm;
 	enum bfa_port_role role = port->port_cfg.roles;
-	wwn_t           lpwwn = bfa_fcs_port_get_pwwn(port);
-	char            lpwwn_ptr[BFA_STRING_32];
-	char           *role_str[BFA_PORT_ROLE_FCP_MAX / 2 + 1] =
-		{ "Initiator", "Target", "IPFC" };
+	wwn_t		lpwwn = bfa_fcs_port_get_pwwn(port);
+	char		lpwwn_ptr[BFA_STRING_32];
+	char		*role_str[BFA_PORT_ROLE_FCP_MAX/2 + 1] =
+				{"Initiator", "Target", "IPFC"};
 
 	wwn2str(lpwwn_ptr, lpwwn);
 
 	bfa_assert(role <= BFA_PORT_ROLE_FCP_MAX);
-
-	switch (event) {
-	case BFA_LPORT_AEN_ONLINE:
-		bfa_log(logmod, BFA_AEN_LPORT_ONLINE, lpwwn_ptr,
-			role_str[role / 2]);
-		break;
-	case BFA_LPORT_AEN_OFFLINE:
-		bfa_log(logmod, BFA_AEN_LPORT_OFFLINE, lpwwn_ptr,
-			role_str[role / 2]);
-		break;
-	case BFA_LPORT_AEN_NEW:
-		bfa_log(logmod, BFA_AEN_LPORT_NEW, lpwwn_ptr,
-			role_str[role / 2]);
-		break;
-	case BFA_LPORT_AEN_DELETE:
-		bfa_log(logmod, BFA_AEN_LPORT_DELETE, lpwwn_ptr,
-			role_str[role / 2]);
-		break;
-	case BFA_LPORT_AEN_DISCONNECT:
-		bfa_log(logmod, BFA_AEN_LPORT_DISCONNECT, lpwwn_ptr,
-			role_str[role / 2]);
-		break;
-	default:
-		break;
-	}
+	bfa_log(logmod, BFA_LOG_CREATE_ID(BFA_AEN_CAT_LPORT, event), lpwwn_ptr,
+			role_str[role/2]);
 
 	aen_data.lport.vf_id = port->fabric->vf_id;
 	aen_data.lport.roles = role;
 	aen_data.lport.ppwwn =
-		bfa_fcs_port_get_pwwn(bfa_fcs_get_base_port(port->fcs));
+			bfa_fcs_port_get_pwwn(bfa_fcs_get_base_port(port->fcs));
 	aen_data.lport.lpwwn = lpwwn;
 }
 
@@ -313,13 +292,13 @@ bfa_fcs_port_send_ls_rjt(struct bfa_fcs_
 	if (!fcxp)
 		return;
 
-	len = fc_ls_rjt_build(&fchs, bfa_fcxp_get_reqbuf(fcxp), rx_fchs->s_id,
-			      bfa_fcs_port_get_fcid(port), rx_fchs->ox_id,
-			      reason_code, reason_code_expl);
+	len = fc_ls_rjt_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),
+			      rx_fchs->s_id, bfa_fcs_port_get_fcid(port),
+			      rx_fchs->ox_id, reason_code, reason_code_expl);
 
 	bfa_fcxp_send(fcxp, bfa_rport, port->fabric->vf_id, port->lp_tag,
-		      BFA_FALSE, FC_CLASS_3, len, &fchs, NULL, NULL,
-		      FC_MAX_PDUSZ, 0);
+			  BFA_FALSE, FC_CLASS_3, len, &fchs, NULL, NULL,
+			  FC_MAX_PDUSZ, 0);
 }
 
 /**
@@ -354,23 +333,19 @@ bfa_fcs_port_plogi(struct bfa_fcs_port_s
 	}
 
 	/**
-* Direct Attach P2P mode : verify address assigned by the r-port.
+	 * Direct Attach P2P mode : verify address assigned by the r-port.
 	 */
-	if ((!bfa_fcs_fabric_is_switched(port->fabric))
-	    &&
-	    (memcmp
-	     ((void *)&bfa_fcs_port_get_pwwn(port), (void *)&plogi->port_name,
-	      sizeof(wwn_t)) < 0)) {
+	if ((!bfa_fcs_fabric_is_switched(port->fabric)) &&
+			(memcmp((void *)&bfa_fcs_port_get_pwwn(port),
+			   (void *)&plogi->port_name, sizeof(wwn_t)) < 0)) {
 		if (BFA_FCS_PID_IS_WKA(rx_fchs->d_id)) {
-			/*
-			 * Address assigned to us cannot be a WKA
-			 */
+			/* Address assigned to us cannot be a WKA */
 			bfa_fcs_port_send_ls_rjt(port, rx_fchs,
 					FC_LS_RJT_RSN_PROTOCOL_ERROR,
 					FC_LS_RJT_EXP_INVALID_NPORT_ID);
 			return;
 		}
-		port->pid = rx_fchs->d_id;
+		port->pid  = rx_fchs->d_id;
 	}
 
 	/**
@@ -379,15 +354,13 @@ bfa_fcs_port_plogi(struct bfa_fcs_port_s
 	rport = bfa_fcs_port_get_rport_by_pwwn(port, plogi->port_name);
 	if (rport) {
 		/**
-		 * Direct Attach P2P mode: handle address assigned by the rport.
+		 * Direct Attach P2P mode : handle address assigned by the r-port.
 		 */
-		if ((!bfa_fcs_fabric_is_switched(port->fabric))
-		    &&
-		    (memcmp
-		     ((void *)&bfa_fcs_port_get_pwwn(port),
-		      (void *)&plogi->port_name, sizeof(wwn_t)) < 0)) {
-			port->pid = rx_fchs->d_id;
-			rport->pid = rx_fchs->s_id;
+		if ((!bfa_fcs_fabric_is_switched(port->fabric)) &&
+			(memcmp((void *)&bfa_fcs_port_get_pwwn(port),
+			(void *)&plogi->port_name, sizeof(wwn_t)) < 0)) {
+				port->pid  = rx_fchs->d_id;
+				rport->pid = rx_fchs->s_id;
 		}
 		bfa_fcs_rport_plogi(rport, rx_fchs, plogi);
 		return;
@@ -436,7 +409,7 @@ bfa_fcs_port_plogi(struct bfa_fcs_port_s
  */
 static void
 bfa_fcs_port_echo(struct bfa_fcs_port_s *port, struct fchs_s *rx_fchs,
-			struct fc_echo_s *echo, u16 rx_len)
+		struct fc_echo_s *echo, u16 rx_len)
 {
 	struct fchs_s          fchs;
 	struct bfa_fcxp_s *fcxp;
@@ -451,8 +424,9 @@ bfa_fcs_port_echo(struct bfa_fcs_port_s 
 	if (!fcxp)
 		return;
 
-	len = fc_ls_acc_build(&fchs, bfa_fcxp_get_reqbuf(fcxp), rx_fchs->s_id,
-			      bfa_fcs_port_get_fcid(port), rx_fchs->ox_id);
+	len = fc_ls_acc_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),
+			      rx_fchs->s_id, bfa_fcs_port_get_fcid(port),
+			      rx_fchs->ox_id);
 
 	/*
 	 * Copy the payload (if any) from the echo frame
@@ -466,8 +440,8 @@ bfa_fcs_port_echo(struct bfa_fcs_port_s 
 		       (pyld_len - sizeof(struct fc_echo_s)));
 
 	bfa_fcxp_send(fcxp, bfa_rport, port->fabric->vf_id, port->lp_tag,
-		      BFA_FALSE, FC_CLASS_3, pyld_len, &fchs, NULL, NULL,
-		      FC_MAX_PDUSZ, 0);
+			  BFA_FALSE, FC_CLASS_3, pyld_len, &fchs, NULL, NULL,
+			  FC_MAX_PDUSZ, 0);
 }
 
 /*
@@ -517,13 +491,14 @@ bfa_fcs_port_rnid(struct bfa_fcs_port_s 
 	common_id_data.port_name = bfa_fcs_port_get_pwwn(port);
 	common_id_data.node_name = bfa_fcs_port_get_nwwn(port);
 
-	len = fc_rnid_acc_build(&fchs, bfa_fcxp_get_reqbuf(fcxp), rx_fchs->s_id,
-				bfa_fcs_port_get_fcid(port), rx_fchs->ox_id,
-				data_format, &common_id_data, &gen_topo_data);
+	len = fc_rnid_acc_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),
+				rx_fchs->s_id, bfa_fcs_port_get_fcid(port),
+				rx_fchs->ox_id, data_format, &common_id_data,
+				&gen_topo_data);
 
 	bfa_fcxp_send(fcxp, bfa_rport, port->fabric->vf_id, port->lp_tag,
-		      BFA_FALSE, FC_CLASS_3, len, &fchs, NULL, NULL,
-		      FC_MAX_PDUSZ, 0);
+			  BFA_FALSE, FC_CLASS_3, len, &fchs, NULL, NULL,
+			  FC_MAX_PDUSZ, 0);
 
 	return;
 }
@@ -533,7 +508,7 @@ bfa_fcs_port_rnid(struct bfa_fcs_port_s 
  */
 static void
 bfa_fs_port_get_gen_topo_data(struct bfa_fcs_port_s *port,
-			struct fc_rnid_general_topology_data_s *gen_topo_data)
+	struct fc_rnid_general_topology_data_s *gen_topo_data)
 {
 
 	bfa_os_memset(gen_topo_data, 0,
@@ -554,31 +529,33 @@ bfa_fcs_port_online_actions(struct bfa_f
 
 	bfa_fcs_port_aen_post(port, BFA_LPORT_AEN_ONLINE);
 	bfa_fcb_port_online(port->fcs->bfad, port->port_cfg.roles,
-			port->fabric->vf_drv, (port->vport == NULL) ?
-			NULL : port->vport->vport_drv);
+			    port->fabric->vf_drv,
+			    (port->vport == NULL) ?
+				 NULL : port->vport->vport_drv);
 }
 
 static void
 bfa_fcs_port_offline_actions(struct bfa_fcs_port_s *port)
 {
-	struct list_head *qe, *qen;
+	struct list_head        *qe, *qen;
 	struct bfa_fcs_rport_s *rport;
 
 	bfa_trc(port->fcs, port->fabric->oper_type);
 
 	__port_action[port->fabric->fab_type].offline(port);
 
-	if (bfa_fcs_fabric_is_online(port->fabric) == BFA_TRUE) {
+	if (bfa_fcs_fabric_is_online(port->fabric) == BFA_TRUE)
 		bfa_fcs_port_aen_post(port, BFA_LPORT_AEN_DISCONNECT);
-	} else {
+	else
 		bfa_fcs_port_aen_post(port, BFA_LPORT_AEN_OFFLINE);
-	}
+
 	bfa_fcb_port_offline(port->fcs->bfad, port->port_cfg.roles,
-			port->fabric->vf_drv,
-			(port->vport == NULL) ? NULL : port->vport->vport_drv);
+			     port->fabric->vf_drv,
+			     (port->vport == NULL) ?
+				 NULL : port->vport->vport_drv);
 
 	list_for_each_safe(qe, qen, &port->rport_q) {
-		rport = (struct bfa_fcs_rport_s *)qe;
+		rport = (struct bfa_fcs_rport_s *) qe;
 		bfa_fcs_rport_offline(rport);
 	}
 }
@@ -606,16 +583,14 @@ bfa_fcs_port_deleted(struct bfa_fcs_port
 {
 	bfa_fcs_port_aen_post(port, BFA_LPORT_AEN_DELETE);
 
-	/*
-	 * Base port will be deleted by the OS driver
-	 */
+	/* Base port will be deleted by the OS driver */
 	if (port->vport) {
 		bfa_fcb_port_delete(port->fcs->bfad, port->port_cfg.roles,
-			port->fabric->vf_drv,
-			port->vport ? port->vport->vport_drv : NULL);
+				port->fabric->vf_drv,
+				port->vport ? port->vport->vport_drv : NULL);
 		bfa_fcs_vport_delete_comp(port->vport);
 	} else {
-		bfa_fcs_fabric_port_delete_comp(port->fabric);
+		 bfa_fcs_fabric_port_delete_comp(port->fabric);
 	}
 }
 
@@ -647,7 +622,7 @@ bfa_fcs_port_modexit(struct bfa_fcs_s *f
  */
 void
 bfa_fcs_port_uf_recv(struct bfa_fcs_port_s *lport, struct fchs_s *fchs,
-			u16 len)
+				u16 len)
 {
 	u32        pid = fchs->s_id;
 	struct bfa_fcs_rport_s *rport = NULL;
@@ -677,7 +652,7 @@ bfa_fcs_port_uf_recv(struct bfa_fcs_port
 	 */
 	if ((fchs->type == FC_TYPE_ELS) && (els_cmd->els_code == FC_ELS_ECHO)) {
 		bfa_fcs_port_echo(lport, fchs,
-			(struct fc_echo_s *) els_cmd, len);
+					(struct fc_echo_s *) els_cmd, len);
 		return;
 	}
 
@@ -686,7 +661,7 @@ bfa_fcs_port_uf_recv(struct bfa_fcs_port
 	 */
 	if ((fchs->type == FC_TYPE_ELS) && (els_cmd->els_code == FC_ELS_RNID)) {
 		bfa_fcs_port_rnid(lport, fchs,
-			(struct fc_rnid_cmd_s *) els_cmd, len);
+					(struct fc_rnid_cmd_s *) els_cmd, len);
 		return;
 	}
 
@@ -749,10 +724,10 @@ struct bfa_fcs_rport_s *
 bfa_fcs_port_get_rport_by_pid(struct bfa_fcs_port_s *port, u32 pid)
 {
 	struct bfa_fcs_rport_s *rport;
-	struct list_head *qe;
+	struct list_head        *qe;
 
 	list_for_each(qe, &port->rport_q) {
-		rport = (struct bfa_fcs_rport_s *)qe;
+		rport = (struct bfa_fcs_rport_s *) qe;
 		if (rport->pid == pid)
 			return rport;
 	}
@@ -768,16 +743,16 @@ struct bfa_fcs_rport_s *
 bfa_fcs_port_get_rport_by_pwwn(struct bfa_fcs_port_s *port, wwn_t pwwn)
 {
 	struct bfa_fcs_rport_s *rport;
-	struct list_head *qe;
+	struct list_head        *qe;
 
 	list_for_each(qe, &port->rport_q) {
-		rport = (struct bfa_fcs_rport_s *)qe;
+		rport = (struct bfa_fcs_rport_s *) qe;
 		if (wwn_is_equal(rport->pwwn, pwwn))
 			return rport;
 	}
 
 	bfa_trc(port->fcs, pwwn);
-	return (NULL);
+	return NULL;
 }
 
 /**
@@ -787,16 +762,16 @@ struct bfa_fcs_rport_s *
 bfa_fcs_port_get_rport_by_nwwn(struct bfa_fcs_port_s *port, wwn_t nwwn)
 {
 	struct bfa_fcs_rport_s *rport;
-	struct list_head *qe;
+	struct list_head        *qe;
 
 	list_for_each(qe, &port->rport_q) {
-		rport = (struct bfa_fcs_rport_s *)qe;
+		rport = (struct bfa_fcs_rport_s *) qe;
 		if (wwn_is_equal(rport->nwwn, nwwn))
 			return rport;
 	}
 
 	bfa_trc(port->fcs, nwwn);
-	return (NULL);
+	return NULL;
 }
 
 /**
@@ -804,7 +779,7 @@ bfa_fcs_port_get_rport_by_nwwn(struct bf
  */
 void
 bfa_fcs_port_add_rport(struct bfa_fcs_port_s *port,
-		       struct bfa_fcs_rport_s *rport)
+			struct bfa_fcs_rport_s *rport)
 {
 	list_add_tail(&rport->qe, &port->rport_q);
 	port->num_rports++;
@@ -815,7 +790,7 @@ bfa_fcs_port_add_rport(struct bfa_fcs_po
  */
 void
 bfa_fcs_port_del_rport(struct bfa_fcs_port_s *port,
-		       struct bfa_fcs_rport_s *rport)
+			struct bfa_fcs_rport_s *rport)
 {
 	bfa_assert(bfa_q_is_on_q(&port->rport_q, rport));
 	list_del(&rport->qe);
@@ -870,32 +845,45 @@ bfa_fcs_port_lip(struct bfa_fcs_port_s *
 bfa_boolean_t
 bfa_fcs_port_is_online(struct bfa_fcs_port_s *port)
 {
-	return (bfa_sm_cmp_state(port, bfa_fcs_port_sm_online));
+	return bfa_sm_cmp_state(port, bfa_fcs_port_sm_online);
 }
 
 /**
- * Logical port initialization of base or virtual port.
- * Called by fabric for base port or by vport for virtual ports.
+  * Attach time initialization of logical ports.
  */
 void
-bfa_fcs_lport_init(struct bfa_fcs_port_s *lport, struct bfa_fcs_s *fcs,
-		   u16 vf_id, struct bfa_port_cfg_s *port_cfg,
-		   struct bfa_fcs_vport_s *vport)
+bfa_fcs_lport_attach(struct bfa_fcs_port_s *lport, struct bfa_fcs_s *fcs,
+		   u16 vf_id, struct bfa_fcs_vport_s *vport)
 {
 	lport->fcs = fcs;
 	lport->fabric = bfa_fcs_vf_lookup(fcs, vf_id);
-	bfa_os_assign(lport->port_cfg, *port_cfg);
 	lport->vport = vport;
 	lport->lp_tag = (vport) ? bfa_lps_get_tag(vport->lps) :
-			 bfa_lps_get_tag(lport->fabric->lps);
+				  bfa_lps_get_tag(lport->fabric->lps);
 
 	INIT_LIST_HEAD(&lport->rport_q);
 	lport->num_rports = 0;
+}
+
+/**
+ * Logical port initialization of base or virtual port.
+ * Called by fabric for base port or by vport for virtual ports.
+ */
+
+void
+bfa_fcs_lport_init(struct bfa_fcs_port_s *lport,
+					struct bfa_port_cfg_s *port_cfg)
+{
+
+	struct bfa_fcs_vport_s *vport = lport->vport;
+
+	bfa_os_assign(lport->port_cfg, *port_cfg);
+
+	lport->bfad_port = bfa_fcb_port_new(lport->fcs->bfad, lport,
+					lport->port_cfg.roles,
+					lport->fabric->vf_drv,
+					vport ? vport->vport_drv : NULL);
 
-	lport->bfad_port =
-		bfa_fcb_port_new(fcs->bfad, lport, lport->port_cfg.roles,
-				lport->fabric->vf_drv,
-				vport ? vport->vport_drv : NULL);
 	bfa_fcs_port_aen_post(lport, BFA_LPORT_AEN_NEW);
 
 	bfa_sm_set_state(lport, bfa_fcs_port_sm_uninit);
@@ -910,7 +898,7 @@ bfa_fcs_lport_init(struct bfa_fcs_port_s
 
 void
 bfa_fcs_port_get_attr(struct bfa_fcs_port_s *port,
-		      struct bfa_port_attr_s *port_attr)
+			struct bfa_port_attr_s *port_attr)
 {
 	if (bfa_sm_cmp_state(port, bfa_fcs_port_sm_online))
 		port_attr->pid = port->pid;
@@ -922,19 +910,25 @@ bfa_fcs_port_get_attr(struct bfa_fcs_por
 	if (port->fabric) {
 		port_attr->port_type = bfa_fcs_fabric_port_type(port->fabric);
 		port_attr->loopback = bfa_fcs_fabric_is_loopback(port->fabric);
-		port_attr->fabric_name = bfa_fcs_port_get_fabric_name(port);
+		port_attr->authfail =
+				bfa_fcs_fabric_is_auth_failed(port->fabric);
+		port_attr->fabric_name  = bfa_fcs_port_get_fabric_name(port);
 		memcpy(port_attr->fabric_ip_addr,
-		       bfa_fcs_port_get_fabric_ipaddr(port),
-		       BFA_FCS_FABRIC_IPADDR_SZ);
+			bfa_fcs_port_get_fabric_ipaddr(port),
+			BFA_FCS_FABRIC_IPADDR_SZ);
 
-		if (port->vport != NULL)
+		if (port->vport != NULL) {
 			port_attr->port_type = BFA_PPORT_TYPE_VPORT;
+			port_attr->fpma_mac =
+				bfa_lps_get_lp_mac(port->vport->lps);
+		} else
+			port_attr->fpma_mac =
+				bfa_lps_get_lp_mac(port->fabric->lps);
 
 	} else {
 		port_attr->port_type = BFA_PPORT_TYPE_UNKNOWN;
 		port_attr->state = BFA_PORT_UNINIT;
 	}
-
 }
 
 
diff -uprN a/drivers/scsi/bfa/bfa_fcs_port.c b/drivers/scsi/bfa/bfa_fcs_port.c
--- a/drivers/scsi/bfa/bfa_fcs_port.c	2009-12-18 18:16:22.490688000 -0800
+++ b/drivers/scsi/bfa/bfa_fcs_port.c	2009-11-25 18:21:06.000000000 -0800
@@ -55,14 +55,8 @@ bfa_fcs_pport_event_handler(void *cbarg,
 }
 
 void
-bfa_fcs_pport_modinit(struct bfa_fcs_s *fcs)
+bfa_fcs_pport_attach(struct bfa_fcs_s *fcs)
 {
-	bfa_pport_event_register(fcs->bfa, bfa_fcs_pport_event_handler,
-				     fcs);
+	bfa_fcport_event_register(fcs->bfa, bfa_fcs_pport_event_handler, fcs);
 }
 
-void
-bfa_fcs_pport_modexit(struct bfa_fcs_s *fcs)
-{
-	bfa_fcs_modexit_comp(fcs);
-}
diff -uprN a/drivers/scsi/bfa/bfa_fcs_uf.c b/drivers/scsi/bfa/bfa_fcs_uf.c
--- a/drivers/scsi/bfa/bfa_fcs_uf.c	2009-12-18 18:16:22.489684000 -0800
+++ b/drivers/scsi/bfa/bfa_fcs_uf.c	2009-11-25 18:21:06.000000000 -0800
@@ -30,7 +30,7 @@
 BFA_TRC_FILE(FCS, UF);
 
 /**
- * 		BFA callback for unsolicited frame receive handler.
+ *		BFA callback for unsolicited frame receive handler.
  *
  * @param[in]		cbarg		callback arg for receive handler
  * @param[in]		uf		unsolicited frame descriptor
@@ -41,8 +41,8 @@ static void
 bfa_fcs_uf_recv(void *cbarg, struct bfa_uf_s *uf)
 {
 	struct bfa_fcs_s      *fcs = (struct bfa_fcs_s *) cbarg;
-	struct fchs_s         *fchs = bfa_uf_get_frmbuf(uf);
-	u16        len = bfa_uf_get_frmlen(uf);
+	struct fchs_s	       *fchs = bfa_uf_get_frmbuf(uf);
+	u16	len = bfa_uf_get_frmlen(uf);
 	struct fc_vft_s       *vft;
 	struct bfa_fcs_fabric_s *fabric;
 
@@ -50,7 +50,7 @@ bfa_fcs_uf_recv(void *cbarg, struct bfa_
 	 * check for VFT header
 	 */
 	if (fchs->routing == FC_RTG_EXT_HDR &&
-		fchs->cat_info == FC_CAT_VFT_HDR) {
+	    fchs->cat_info == FC_CAT_VFT_HDR) {
 		bfa_stats(fcs, uf.tagged);
 		vft = bfa_uf_get_frmbuf(uf);
 		if (fcs->port_vfid == vft->vf_id)
@@ -93,13 +93,8 @@ bfa_fcs_uf_recv(void *cbarg, struct bfa_
 }
 
 void
-bfa_fcs_uf_modinit(struct bfa_fcs_s *fcs)
+bfa_fcs_uf_attach(struct bfa_fcs_s *fcs)
 {
 	bfa_uf_recv_register(fcs->bfa, bfa_fcs_uf_recv, fcs);
 }
 
-void
-bfa_fcs_uf_modexit(struct bfa_fcs_s *fcs)
-{
-	bfa_fcs_modexit_comp(fcs);
-}
diff -uprN a/drivers/scsi/bfa/bfa_fcxp.c b/drivers/scsi/bfa/bfa_fcxp.c
--- a/drivers/scsi/bfa/bfa_fcxp.c	2009-12-18 18:16:22.487684000 -0800
+++ b/drivers/scsi/bfa/bfa_fcxp.c	2009-11-25 18:21:06.000000000 -0800
@@ -199,7 +199,7 @@ bfa_fcxp_get(struct bfa_fcxp_mod_s *fm)
 	if (fcxp)
 		list_add_tail(&fcxp->qe, &fm->fcxp_active_q);
 
-	return (fcxp);
+	return fcxp;
 }
 
 static void
@@ -324,12 +324,15 @@ hal_fcxp_tx_plog(struct bfa_s *bfa, u32 
 				*((u32 *) BFA_FCXP_REQ_PLD(fcxp));
 
 			bfa_plog_fchdr_and_pl(bfa->plog, BFA_PL_MID_HAL_FCXP,
-				BFA_PL_EID_TX,
-				reqlen + sizeof(struct fchs_s), fchs, pld_w0);
+					      BFA_PL_EID_TX,
+					      reqlen + sizeof(struct fchs_s),
+						fchs,
+					      pld_w0);
 		} else {
 			bfa_plog_fchdr(bfa->plog, BFA_PL_MID_HAL_FCXP,
-				BFA_PL_EID_TX, reqlen + sizeof(struct fchs_s),
-				fchs);
+				       BFA_PL_EID_TX,
+					reqlen + sizeof(struct fchs_s),
+				       fchs);
 		}
 	} else {
 		bfa_plog_fchdr(bfa->plog, BFA_PL_MID_HAL_FCXP, BFA_PL_EID_TX,
@@ -386,7 +389,7 @@ bfa_fcxp_queue(struct bfa_fcxp_s *fcxp, 
 	struct bfa_s      		*bfa = fcxp->fcxp_mod->bfa;
 	struct bfa_fcxp_req_info_s	*reqi = &fcxp->req_info;
 	struct bfa_fcxp_rsp_info_s	*rspi = &fcxp->rsp_info;
-	struct bfa_rport_s		*rport = reqi->bfa_rport;
+	struct bfa_rport_s			*rport = reqi->bfa_rport;
 
 	bfi_h2i_set(send_req->mh, BFI_MC_FCXP, BFI_FCXP_H2I_SEND_REQ,
 			bfa_lpuid(bfa));
@@ -503,7 +506,7 @@ bfa_fcxp_alloc(void *caller, struct bfa_
 
 	fcxp = bfa_fcxp_get(BFA_FCXP_MOD(bfa));
 	if (fcxp == NULL)
-		return (NULL);
+		return NULL;
 
 	bfa_trc(bfa, fcxp->fcxp_tag);
 
@@ -568,7 +571,7 @@ bfa_fcxp_alloc(void *caller, struct bfa_
 		}
 	}
 
-	return (fcxp);
+	return fcxp;
 }
 
 /**
@@ -709,7 +712,7 @@ bfa_status_t
 bfa_fcxp_abort(struct bfa_fcxp_s *fcxp)
 {
 	bfa_assert(0);
-	return (BFA_STATUS_OK);
+	return BFA_STATUS_OK;
 }
 
 void
diff -uprN a/drivers/scsi/bfa/bfa_fcxp_priv.h b/drivers/scsi/bfa/bfa_fcxp_priv.h
--- a/drivers/scsi/bfa/bfa_fcxp_priv.h	2009-12-18 18:16:22.484690000 -0800
+++ b/drivers/scsi/bfa/bfa_fcxp_priv.h	2009-11-25 18:06:50.000000000 -0800
@@ -29,15 +29,15 @@
 
 struct bfa_fcxp_mod_s {
 	struct bfa_s      *bfa;		/*  backpointer to BFA */
-	struct bfa_fcxp_s *fcxp_list;	/*  array of FCXPs */
+	struct bfa_fcxp_s	*fcxp_list;	/*  array of FCXPs */
 	u16        num_fcxps;	/*  max num FCXP requests */
-	struct list_head fcxp_free_q;	/*  free FCXPs */
-	struct list_head fcxp_active_q;	/*  active FCXPs */
-	void	*req_pld_list_kva;	/*  list of FCXP req pld */
-	u64 req_pld_list_pa;	/*  list of FCXP req pld */
-	void *rsp_pld_list_kva;		/*  list of FCXP resp pld */
-	u64 rsp_pld_list_pa;	/*  list of FCXP resp pld */
-	struct list_head  wait_q;		/*  wait queue for free fcxp */
+	struct list_head         fcxp_free_q;	/*  free FCXPs */
+	struct list_head         fcxp_active_q;	/*  active FCXPs */
+	void		*req_pld_list_kva; /*  list of FCXP req pld */
+	u64        req_pld_list_pa;	/*  list of FCXP req pld */
+	void		*rsp_pld_list_kva; /*  list of FCXP resp pld */
+	u64        rsp_pld_list_pa;	/*  list of FCXP resp pld */
+	struct list_head         wait_q;	/*  wait queue for free fcxp */
 	u32	req_pld_sz;
 	u32	rsp_pld_sz;
 };
@@ -60,18 +60,18 @@ struct bfa_fcxp_req_info_s {
 					 *FCXP interactions before the rport
 					 *nexus is established
 					 */
-	struct fchs_s   fchs;	/*  request FC header structure */
-	u8 cts;		/*  continous sequence */
-	u8 class;		/*  FC class for the request/response */
-	u16 max_frmsz;	/*  max send frame size */
-	u16 vf_id;		/*  vsan tag if applicable */
-	u8	lp_tag;		/*  lport tag */
-	u32 req_tot_len;	/*  request payload total length */
+	struct fchs_s          fchs;	/*  request FC header structure */
+	u8         cts;	/*  continous sequence */
+	u8         class;	/*  FC class for the request/response */
+	u16        max_frmsz;	/*  max send frame size */
+	u16        vf_id;	/*  vsan tag if applicable */
+	u8		lp_tag;	/*  lport tag */
+	u32        req_tot_len;	/*  request payload total length */
 };
 
 struct bfa_fcxp_rsp_info_s {
-	struct fchs_s rsp_fchs;		/*  Response frame's FC header will
-					 * be *sent back in this field */
+	struct fchs_s          rsp_fchs;/*  Response frame's FC header will
+					 *be *sent back in this field */
 	u8         rsp_timeout;	/*  timeout in seconds, 0-no response
 					 */
 	u8         rsvd2[3];
diff -uprN a/drivers/scsi/bfa/bfa_hw_cb.c b/drivers/scsi/bfa/bfa_hw_cb.c
--- a/drivers/scsi/bfa/bfa_hw_cb.c	2009-12-18 18:16:22.481685000 -0800
+++ b/drivers/scsi/bfa/bfa_hw_cb.c	2009-11-25 18:21:06.000000000 -0800
@@ -23,7 +23,7 @@ bfa_hwcb_reginit(struct bfa_s *bfa)
 {
 	struct bfa_iocfc_regs_s	*bfa_regs = &bfa->iocfc.bfa_regs;
 	bfa_os_addr_t		kva = bfa_ioc_bar0(&bfa->ioc);
-	int             	i, q, fn = bfa_ioc_pcifn(&bfa->ioc);
+	int			i, q, fn = bfa_ioc_pcifn(&bfa->ioc);
 
 	if (fn == 0) {
 		bfa_regs->intr_status = (kva + HOSTFN0_INT_STATUS);
@@ -53,6 +53,18 @@ bfa_hwcb_reginit(struct bfa_s *bfa)
 }
 
 void
+bfa_hwcb_reqq_ack(struct bfa_s *bfa, int reqq)
+{
+}
+
+static void
+bfa_hwcb_reqq_ack_msix(struct bfa_s *bfa, int reqq)
+{
+	bfa_reg_write(bfa->iocfc.bfa_regs.intr_status,
+		__HFN_INT_CPE_Q0 << CPE_Q_NUM(bfa_ioc_pcifn(&bfa->ioc), reqq));
+}
+
+void
 bfa_hwcb_rspq_ack(struct bfa_s *bfa, int rspq)
 {
 }
@@ -136,6 +148,7 @@ bfa_hwcb_msix_uninstall(struct bfa_s *bf
 void
 bfa_hwcb_isr_mode_set(struct bfa_s *bfa, bfa_boolean_t msix)
 {
+	bfa->iocfc.hwif.hw_reqq_ack = bfa_hwcb_reqq_ack_msix;
 	bfa->iocfc.hwif.hw_rspq_ack = bfa_hwcb_rspq_ack_msix;
 }
 
diff -uprN a/drivers/scsi/bfa/bfa_hw_ct.c b/drivers/scsi/bfa/bfa_hw_ct.c
--- a/drivers/scsi/bfa/bfa_hw_ct.c	2009-12-18 18:16:22.479686000 -0800
+++ b/drivers/scsi/bfa/bfa_hw_ct.c	2009-11-25 18:21:06.000000000 -0800
@@ -53,7 +53,7 @@ bfa_hwct_reginit(struct bfa_s *bfa)
 {
 	struct bfa_iocfc_regs_s	*bfa_regs = &bfa->iocfc.bfa_regs;
 	bfa_os_addr_t		kva = bfa_ioc_bar0(&bfa->ioc);
-	int             	i, q, fn = bfa_ioc_pcifn(&bfa->ioc);
+	int			i, q, fn = bfa_ioc_pcifn(&bfa->ioc);
 
 	if (fn == 0) {
 		bfa_regs->intr_status = (kva + HOSTFN0_INT_STATUS);
@@ -85,6 +85,15 @@ bfa_hwct_reginit(struct bfa_s *bfa)
 }
 
 void
+bfa_hwct_reqq_ack(struct bfa_s *bfa, int reqq)
+{
+	u32	r32;
+
+	r32 = bfa_reg_read(bfa->iocfc.bfa_regs.cpe_q_ctrl[reqq]);
+	bfa_reg_write(bfa->iocfc.bfa_regs.cpe_q_ctrl[reqq], r32);
+}
+
+void
 bfa_hwct_rspq_ack(struct bfa_s *bfa, int rspq)
 {
 	u32	r32;
diff -uprN a/drivers/scsi/bfa/bfa_intr.c b/drivers/scsi/bfa/bfa_intr.c
--- a/drivers/scsi/bfa/bfa_intr.c	2009-12-18 18:16:22.477688000 -0800
+++ b/drivers/scsi/bfa/bfa_intr.c	2009-11-25 18:21:06.000000000 -0800
@@ -15,7 +15,7 @@
  * General Public License for more details.
  */
 #include <bfa.h>
-#include <bfi/bfi_cbreg.h>
+#include <bfi/bfi_ctreg.h>
 #include <bfa_port_priv.h>
 #include <bfa_intr_priv.h>
 #include <cs/bfa_debug.h>
@@ -34,6 +34,26 @@ bfa_msix_lpu(struct bfa_s *bfa)
 	bfa_ioc_mbox_isr(&bfa->ioc);
 }
 
+static void
+bfa_reqq_resume(struct bfa_s *bfa, int qid)
+{
+	struct list_head *waitq, *qe, *qen;
+	struct bfa_reqq_wait_s *wqe;
+
+	waitq = bfa_reqq(bfa, qid);
+	list_for_each_safe(qe, qen, waitq) {
+		/**
+		 * Callback only as long as there is room in request queue
+		 */
+		if (bfa_reqq_full(bfa, qid))
+			break;
+
+		list_del(qe);
+		wqe = (struct bfa_reqq_wait_s *) qe;
+		wqe->qresume(wqe->cbarg);
+	}
+}
+
 void
 bfa_msix_all(struct bfa_s *bfa, int vec)
 {
@@ -46,8 +66,8 @@ bfa_msix_all(struct bfa_s *bfa, int vec)
 bfa_boolean_t
 bfa_intx(struct bfa_s *bfa)
 {
-	u32        intr, qintr;
-	int             queue;
+	u32 intr, qintr;
+	int queue;
 
 	intr = bfa_reg_read(bfa->iocfc.bfa_regs.intr_status);
 	if (!intr)
@@ -59,7 +79,7 @@ bfa_intx(struct bfa_s *bfa)
 	qintr = intr & __HFN_INT_RME_MASK;
 	bfa_reg_write(bfa->iocfc.bfa_regs.intr_status, qintr);
 
-	for (queue = 0; queue < BFI_IOC_MAX_CQS_ASIC; queue ++) {
+	for (queue = 0; queue < BFI_IOC_MAX_CQS_ASIC; queue++) {
 		if (intr & (__HFN_INT_RME_Q0 << queue))
 			bfa_msix_rspq(bfa, queue & (BFI_IOC_MAX_CQS - 1));
 	}
@@ -89,14 +109,15 @@ bfa_intx(struct bfa_s *bfa)
 void
 bfa_isr_enable(struct bfa_s *bfa)
 {
-	u32        intr_unmask;
-	int             pci_func = bfa_ioc_pcifn(&bfa->ioc);
+	u32 intr_unmask;
+	int pci_func = bfa_ioc_pcifn(&bfa->ioc);
 
 	bfa_trc(bfa, pci_func);
 
 	bfa_msix_install(bfa);
 	intr_unmask = (__HFN_INT_ERR_EMC | __HFN_INT_ERR_LPU0 |
-		       __HFN_INT_ERR_LPU1 | __HFN_INT_ERR_PSS);
+		       __HFN_INT_ERR_LPU1 | __HFN_INT_ERR_PSS |
+		       __HFN_INT_LL_HALT);
 
 	if (pci_func == 0)
 		intr_unmask |= (__HFN_INT_CPE_Q0 | __HFN_INT_CPE_Q1 |
@@ -127,23 +148,18 @@ bfa_isr_disable(struct bfa_s *bfa)
 void
 bfa_msix_reqq(struct bfa_s *bfa, int qid)
 {
-	struct list_head 		*waitq, *qe, *qen;
-	struct bfa_reqq_wait_s	*wqe;
+	struct list_head *waitq;
 
 	qid &= (BFI_IOC_MAX_CQS - 1);
 
-	waitq = bfa_reqq(bfa, qid);
-	list_for_each_safe(qe, qen, waitq) {
-		/**
-		 * Callback only as long as there is room in request queue
-		 */
-		if (bfa_reqq_full(bfa, qid))
-			break;
+	bfa->iocfc.hwif.hw_reqq_ack(bfa, qid);
 
-		list_del(qe);
-		wqe = (struct bfa_reqq_wait_s *) qe;
-		wqe->qresume(wqe->cbarg);
-	}
+	/**
+	 * Resume any pending requests in the corresponding reqq.
+	 */
+	waitq = bfa_reqq(bfa, qid);
+	if (!list_empty(waitq))
+		bfa_reqq_resume(bfa, qid);
 }
 
 void
@@ -157,26 +173,27 @@ bfa_isr_unhandled(struct bfa_s *bfa, str
 }
 
 void
-bfa_msix_rspq(struct bfa_s *bfa, int rsp_qid)
+bfa_msix_rspq(struct bfa_s *bfa, int qid)
 {
-	struct bfi_msg_s      *m;
-	u32        pi, ci;
+	struct bfi_msg_s *m;
+	u32 pi, ci;
+	struct list_head *waitq;
 
-	bfa_trc_fp(bfa, rsp_qid);
+	bfa_trc_fp(bfa, qid);
 
-	rsp_qid &= (BFI_IOC_MAX_CQS - 1);
+	qid &= (BFI_IOC_MAX_CQS - 1);
 
-	bfa->iocfc.hwif.hw_rspq_ack(bfa, rsp_qid);
+	bfa->iocfc.hwif.hw_rspq_ack(bfa, qid);
 
-	ci = bfa_rspq_ci(bfa, rsp_qid);
-	pi = bfa_rspq_pi(bfa, rsp_qid);
+	ci = bfa_rspq_ci(bfa, qid);
+	pi = bfa_rspq_pi(bfa, qid);
 
 	bfa_trc_fp(bfa, ci);
 	bfa_trc_fp(bfa, pi);
 
 	if (bfa->rme_process) {
 		while (ci != pi) {
-			m = bfa_rspq_elem(bfa, rsp_qid, ci);
+			m = bfa_rspq_elem(bfa, qid, ci);
 			bfa_assert_fp(m->mhdr.msg_class < BFI_MC_MAX);
 
 			bfa_isrs[m->mhdr.msg_class] (bfa, m);
@@ -188,25 +205,59 @@ bfa_msix_rspq(struct bfa_s *bfa, int rsp
 	/**
 	 * update CI
 	 */
-	bfa_rspq_ci(bfa, rsp_qid) = pi;
-	bfa_reg_write(bfa->iocfc.bfa_regs.rme_q_ci[rsp_qid], pi);
+	bfa_rspq_ci(bfa, qid) = pi;
+	bfa_reg_write(bfa->iocfc.bfa_regs.rme_q_ci[qid], pi);
 	bfa_os_mmiowb();
+
+	/**
+	 * Resume any pending requests in the corresponding reqq.
+	 */
+	waitq = bfa_reqq(bfa, qid);
+	if (!list_empty(waitq))
+		bfa_reqq_resume(bfa, qid);
 }
 
 void
 bfa_msix_lpu_err(struct bfa_s *bfa, int vec)
 {
-	u32 intr;
+	u32 intr, curr_value;
 
 	intr = bfa_reg_read(bfa->iocfc.bfa_regs.intr_status);
 
 	if (intr & (__HFN_INT_MBOX_LPU0 | __HFN_INT_MBOX_LPU1))
 		bfa_msix_lpu(bfa);
 
-	if (intr & (__HFN_INT_ERR_EMC |
-		    __HFN_INT_ERR_LPU0 | __HFN_INT_ERR_LPU1 |
-		    __HFN_INT_ERR_PSS))
+	intr &= (__HFN_INT_ERR_EMC | __HFN_INT_ERR_LPU0 |
+		__HFN_INT_ERR_LPU1 | __HFN_INT_ERR_PSS | __HFN_INT_LL_HALT);
+
+	if (intr) {
+		if (intr & __HFN_INT_LL_HALT) {
+			/**
+			 * If LL_HALT bit is set then FW Init Halt LL Port
+			 * Register needs to be cleared as well so Interrupt
+			 * Status Register will be cleared.
+			 */
+			curr_value = bfa_reg_read(bfa->ioc.ioc_regs.ll_halt);
+			curr_value &= ~__FW_INIT_HALT_P;
+			bfa_reg_write(bfa->ioc.ioc_regs.ll_halt, curr_value);
+		}
+
+		if (intr & __HFN_INT_ERR_PSS) {
+			/**
+			 * ERR_PSS bit needs to be cleared as well in case
+			 * interrups are shared so driver's interrupt handler is
+			 * still called eventhough it is already masked out.
+			 */
+			curr_value = bfa_reg_read(
+					bfa->ioc.ioc_regs.pss_err_status_reg);
+			curr_value &= __PSS_ERR_STATUS_SET;
+			bfa_reg_write(bfa->ioc.ioc_regs.pss_err_status_reg,
+					curr_value);
+		}
+
+		bfa_reg_write(bfa->iocfc.bfa_regs.intr_status, intr);
 		bfa_msix_errint(bfa, intr);
+	}
 }
 
 void
diff -uprN a/drivers/scsi/bfa/bfa_intr_priv.h b/drivers/scsi/bfa/bfa_intr_priv.h
--- a/drivers/scsi/bfa/bfa_intr_priv.h	2009-12-18 18:16:22.476684000 -0800
+++ b/drivers/scsi/bfa/bfa_intr_priv.h	2009-11-25 18:06:50.000000000 -0800
@@ -26,9 +26,9 @@ void bfa_isr_unhandled(struct bfa_s *bfa
 void bfa_isr_bind(enum bfi_mclass mc, bfa_isr_func_t isr_func);
 
 
-#define bfa_reqq_pi(__bfa, __reqq)	(__bfa)->iocfc.req_cq_pi[__reqq]
+#define bfa_reqq_pi(__bfa, __reqq)	((__bfa)->iocfc.req_cq_pi[__reqq])
 #define bfa_reqq_ci(__bfa, __reqq)					\
-	*(u32 *)((__bfa)->iocfc.req_cq_shadow_ci[__reqq].kva)
+	(*(u32 *)((__bfa)->iocfc.req_cq_shadow_ci[__reqq].kva))
 
 #define bfa_reqq_full(__bfa, __reqq)				\
 	(((bfa_reqq_pi(__bfa, __reqq) + 1) &			\
@@ -50,14 +50,16 @@ void bfa_isr_bind(enum bfi_mclass mc, bf
 } while (0)
 
 #define bfa_rspq_pi(__bfa, __rspq)					\
-	*(u32 *)((__bfa)->iocfc.rsp_cq_shadow_pi[__rspq].kva)
+	(*(u32 *)((__bfa)->iocfc.rsp_cq_shadow_pi[__rspq].kva))
 
-#define bfa_rspq_ci(__bfa, __rspq)	(__bfa)->iocfc.rsp_cq_ci[__rspq]
+#define bfa_rspq_ci(__bfa, __rspq)	((__bfa)->iocfc.rsp_cq_ci[__rspq])
 #define bfa_rspq_elem(__bfa, __rspq, __ci)				\
-	&((struct bfi_msg_s *)((__bfa)->iocfc.rsp_cq_ba[__rspq].kva))[__ci]
+	(&((struct bfi_msg_s *)((__bfa)->iocfc.rsp_cq_ba[__rspq].kva))[__ci])
 
-#define CQ_INCR(__index, __size)					\
-			(__index)++; (__index) &= ((__size) - 1)
+#define CQ_INCR(__index, __size) do {					\
+			(__index)++;					\
+			(__index) &= ((__size) - 1);      \
+} while (0)
 
 /**
  * Queue element to wait for room in request queue. FIFO order is
@@ -94,7 +96,7 @@ bfa_reqq_winit(struct bfa_reqq_wait_s *w
 	wqe->cbarg = cbarg;
 }
 
-#define bfa_reqq(__bfa, __reqq)	&(__bfa)->reqq_waitq[__reqq]
+#define bfa_reqq(__bfa, __reqq)	(&(__bfa)->reqq_waitq[__reqq])
 
 /**
  * static inline void
diff -uprN a/drivers/scsi/bfa/bfa_ioc.c b/drivers/scsi/bfa/bfa_ioc.c
--- a/drivers/scsi/bfa/bfa_ioc.c	2009-12-18 18:16:22.466686000 -0800
+++ b/drivers/scsi/bfa/bfa_ioc.c	2009-11-25 18:21:07.000000000 -0800
@@ -18,7 +18,7 @@
 #include <bfa.h>
 #include <bfa_ioc.h>
 #include <bfa_fwimg_priv.h>
-#include <bfa_trcmod_priv.h>
+#include <cna/bfa_cna_trcmod.h>
 #include <cs/bfa_debug.h>
 #include <bfi/bfi_ioc.h>
 #include <bfi/bfi_ctreg.h>
@@ -27,18 +27,17 @@
 #include <log/bfa_log_hal.h>
 #include <defs/bfa_defs_pci.h>
 
-BFA_TRC_FILE(HAL, IOC);
+BFA_TRC_FILE(CNA, IOC);
 
 /**
  * IOC local definitions
  */
 #define BFA_IOC_TOV		2000	/* msecs */
-#define BFA_IOC_HB_TOV		1000	/* msecs */
-#define BFA_IOC_HB_FAIL_MAX	4
+#define BFA_IOC_HWSEM_TOV	500	/* msecs */
+#define BFA_IOC_HB_TOV		500	/* msecs */
 #define BFA_IOC_HWINIT_MAX	2
-#define BFA_IOC_FWIMG_MINSZ     (16 * 1024)
-#define BFA_IOC_TOV_RECOVER	(BFA_IOC_HB_FAIL_MAX * BFA_IOC_HB_TOV \
-				+ BFA_IOC_TOV)
+#define BFA_IOC_FWIMG_MINSZ	(16 * 1024)
+#define BFA_IOC_TOV_RECOVER	 BFA_IOC_HB_TOV
 
 #define bfa_ioc_timer_start(__ioc)					\
 	bfa_timer_begin((__ioc)->timer_mod, &(__ioc)->ioc_timer,	\
@@ -51,36 +50,46 @@ BFA_TRC_FILE(HAL, IOC);
 	 (sizeof(struct bfa_trc_mod_s) -			\
 	  BFA_TRC_MAX * sizeof(struct bfa_trc_s)))
 #define BFA_DBG_FWTRC_OFF(_fn)	(BFI_IOC_TRC_OFF + BFA_DBG_FWTRC_LEN * (_fn))
-#define bfa_ioc_stats(_ioc, _stats)	(_ioc)->stats._stats ++
 
-#define BFA_FLASH_CHUNK_NO(off)         (off / BFI_FLASH_CHUNK_SZ_WORDS)
-#define BFA_FLASH_OFFSET_IN_CHUNK(off)  (off % BFI_FLASH_CHUNK_SZ_WORDS)
-#define BFA_FLASH_CHUNK_ADDR(chunkno)   (chunkno * BFI_FLASH_CHUNK_SZ_WORDS)
-bfa_boolean_t   bfa_auto_recover = BFA_FALSE;
+/**
+ * Asic specific macros : see bfa_hw_cb.c and bfa_hw_ct.c for details.
+ */
+
+#define bfa_ioc_firmware_lock(__ioc)			\
+			((__ioc)->ioc_hwif->ioc_firmware_lock(__ioc))
+#define bfa_ioc_firmware_unlock(__ioc)			\
+			((__ioc)->ioc_hwif->ioc_firmware_unlock(__ioc))
+#define bfa_ioc_fwimg_get_chunk(__ioc, __off)		\
+			((__ioc)->ioc_hwif->ioc_fwimg_get_chunk(__ioc, __off))
+#define bfa_ioc_fwimg_get_size(__ioc)			\
+			((__ioc)->ioc_hwif->ioc_fwimg_get_size(__ioc))
+#define bfa_ioc_reg_init(__ioc) ((__ioc)->ioc_hwif->ioc_reg_init(__ioc))
+#define bfa_ioc_map_port(__ioc) ((__ioc)->ioc_hwif->ioc_map_port(__ioc))
+#define bfa_ioc_notify_hbfail(__ioc)			\
+			((__ioc)->ioc_hwif->ioc_notify_hbfail(__ioc))
+
+bfa_boolean_t bfa_auto_recover = BFA_TRUE;
 
 /*
  * forward declarations
  */
-static void     bfa_ioc_aen_post(struct bfa_ioc_s *bfa,
-				 enum bfa_ioc_aen_event event);
-static void     bfa_ioc_hw_sem_get(struct bfa_ioc_s *ioc);
-static void     bfa_ioc_hw_sem_release(struct bfa_ioc_s *ioc);
-static void     bfa_ioc_hw_sem_get_cancel(struct bfa_ioc_s *ioc);
-static void     bfa_ioc_hwinit(struct bfa_ioc_s *ioc, bfa_boolean_t force);
-static void     bfa_ioc_timeout(void *ioc);
-static void     bfa_ioc_send_enable(struct bfa_ioc_s *ioc);
-static void     bfa_ioc_send_disable(struct bfa_ioc_s *ioc);
-static void     bfa_ioc_send_getattr(struct bfa_ioc_s *ioc);
-static void     bfa_ioc_hb_monitor(struct bfa_ioc_s *ioc);
-static void     bfa_ioc_hb_stop(struct bfa_ioc_s *ioc);
-static void     bfa_ioc_reset(struct bfa_ioc_s *ioc, bfa_boolean_t force);
-static void     bfa_ioc_mbox_poll(struct bfa_ioc_s *ioc);
-static void     bfa_ioc_mbox_hbfail(struct bfa_ioc_s *ioc);
-static void     bfa_ioc_recover(struct bfa_ioc_s *ioc);
-static bfa_boolean_t bfa_ioc_firmware_lock(struct bfa_ioc_s *ioc);
-static void     bfa_ioc_firmware_unlock(struct bfa_ioc_s *ioc);
-static void     bfa_ioc_disable_comp(struct bfa_ioc_s *ioc);
-static void     bfa_ioc_lpu_stop(struct bfa_ioc_s *ioc);
+static void bfa_ioc_aen_post(struct bfa_ioc_s *bfa,
+			     enum bfa_ioc_aen_event event);
+static void bfa_ioc_hw_sem_get(struct bfa_ioc_s *ioc);
+static void bfa_ioc_hw_sem_get_cancel(struct bfa_ioc_s *ioc);
+static void bfa_ioc_hwinit(struct bfa_ioc_s *ioc, bfa_boolean_t force);
+static void bfa_ioc_timeout(void *ioc);
+static void bfa_ioc_send_enable(struct bfa_ioc_s *ioc);
+static void bfa_ioc_send_disable(struct bfa_ioc_s *ioc);
+static void bfa_ioc_send_getattr(struct bfa_ioc_s *ioc);
+static void bfa_ioc_hb_monitor(struct bfa_ioc_s *ioc);
+static void bfa_ioc_hb_stop(struct bfa_ioc_s *ioc);
+static void bfa_ioc_reset(struct bfa_ioc_s *ioc, bfa_boolean_t force);
+static void bfa_ioc_mbox_poll(struct bfa_ioc_s *ioc);
+static void bfa_ioc_mbox_hbfail(struct bfa_ioc_s *ioc);
+static void bfa_ioc_recover(struct bfa_ioc_s *ioc);
+static void bfa_ioc_disable_comp(struct bfa_ioc_s *ioc);
+static void bfa_ioc_lpu_stop(struct bfa_ioc_s *ioc);
 
 /**
  *  bfa_ioc_sm
@@ -90,19 +99,20 @@ static void     bfa_ioc_lpu_stop(struct 
  * IOC state machine events
  */
 enum ioc_event {
-	IOC_E_ENABLE = 1,	/*  IOC enable request */
-	IOC_E_DISABLE = 2,	/*  IOC disable request */
-	IOC_E_TIMEOUT = 3,	/*  f/w response timeout */
-	IOC_E_FWREADY = 4,	/*  f/w initialization done */
-	IOC_E_FWRSP_GETATTR = 5,	/*  IOC get attribute response */
-	IOC_E_FWRSP_ENABLE = 6,	/*  enable f/w response */
-	IOC_E_FWRSP_DISABLE = 7,	/*  disable f/w response */
-	IOC_E_HBFAIL = 8,	/*  heartbeat failure */
-	IOC_E_HWERROR = 9,	/*  hardware error interrupt */
-	IOC_E_SEMLOCKED = 10,	/*  h/w semaphore is locked */
-	IOC_E_DETACH = 11,	/*  driver detach cleanup */
+	IOC_E_ENABLE		= 1,	/*  IOC enable request		*/
+	IOC_E_DISABLE		= 2,	/*  IOC disable request	*/
+	IOC_E_TIMEOUT		= 3,	/*  f/w response timeout	*/
+	IOC_E_FWREADY		= 4,	/*  f/w initialization done	*/
+	IOC_E_FWRSP_GETATTR	= 5,	/*  IOC get attribute response	*/
+	IOC_E_FWRSP_ENABLE	= 6,	/*  enable f/w response	*/
+	IOC_E_FWRSP_DISABLE	= 7,	/*  disable f/w response	*/
+	IOC_E_HBFAIL		= 8,	/*  heartbeat failure		*/
+	IOC_E_HWERROR		= 9,	/*  hardware error interrupt	*/
+	IOC_E_SEMLOCKED		= 10,	/*  h/w semaphore is locked	*/
+	IOC_E_DETACH		= 11,	/*  driver detach cleanup	*/
 };
 
+
 bfa_fsm_state_decl(bfa_ioc, reset, struct bfa_ioc_s, enum ioc_event);
 bfa_fsm_state_decl(bfa_ioc, fwcheck, struct bfa_ioc_s, enum ioc_event);
 bfa_fsm_state_decl(bfa_ioc, mismatch, struct bfa_ioc_s, enum ioc_event);
@@ -196,9 +206,7 @@ bfa_ioc_sm_fwcheck(struct bfa_ioc_s *ioc
 
 	case IOC_E_DISABLE:
 		bfa_ioc_disable_comp(ioc);
-		/*
-		 * fall through
-		 */
+		/* fall through */
 
 	case IOC_E_DETACH:
 		bfa_ioc_hw_sem_get_cancel(ioc);
@@ -245,9 +253,7 @@ bfa_ioc_sm_mismatch(struct bfa_ioc_s *io
 
 	case IOC_E_DISABLE:
 		bfa_ioc_disable_comp(ioc);
-		/*
-		 * fall through
-		 */
+		/* fall through */
 
 	case IOC_E_DETACH:
 		bfa_ioc_timer_stop(ioc);
@@ -320,9 +326,7 @@ bfa_ioc_sm_hwinit(struct bfa_ioc_s *ioc,
 
 	case IOC_E_HWERROR:
 		bfa_ioc_timer_stop(ioc);
-		/*
-		 * fall through
-		 */
+		/* fall through */
 
 	case IOC_E_TIMEOUT:
 		ioc->retry_count++;
@@ -373,9 +377,7 @@ bfa_ioc_sm_enabling(struct bfa_ioc_s *io
 
 	case IOC_E_HWERROR:
 		bfa_ioc_timer_stop(ioc);
-		/*
-		 * fall through
-		 */
+		/* fall through */
 
 	case IOC_E_TIMEOUT:
 		ioc->retry_count++;
@@ -429,9 +431,7 @@ bfa_ioc_sm_getattr(struct bfa_ioc_s *ioc
 
 	case IOC_E_HWERROR:
 		bfa_ioc_timer_stop(ioc);
-		/*
-		 * fall through
-		 */
+		/* fall through */
 
 	case IOC_E_TIMEOUT:
 		bfa_fsm_set_state(ioc, bfa_ioc_sm_initfail);
@@ -477,9 +477,7 @@ bfa_ioc_sm_op(struct bfa_ioc_s *ioc, enu
 		 * Treat it same as heartbeat failure.
 		 */
 		bfa_ioc_hb_stop(ioc);
-		/*
-		 * !!! fall through !!!
-		 */
+		/* !!! fall through !!! */
 
 	case IOC_E_HBFAIL:
 		bfa_fsm_set_state(ioc, bfa_ioc_sm_hbfail);
@@ -508,14 +506,19 @@ bfa_ioc_sm_disabling(struct bfa_ioc_s *i
 	bfa_trc(ioc, event);
 
 	switch (event) {
-	case IOC_E_HWERROR:
 	case IOC_E_FWRSP_DISABLE:
 		bfa_ioc_timer_stop(ioc);
+		bfa_fsm_set_state(ioc, bfa_ioc_sm_disabled);
+		break;
+
+	case IOC_E_HWERROR:
+		bfa_ioc_timer_stop(ioc);
 		/*
 		 * !!! fall through !!!
 		 */
 
 	case IOC_E_TIMEOUT:
+		bfa_reg_write(ioc->ioc_regs.ioc_fwstate, BFI_IOC_FAIL);
 		bfa_fsm_set_state(ioc, bfa_ioc_sm_disabled);
 		break;
 
@@ -601,29 +604,26 @@ bfa_ioc_sm_initfail(struct bfa_ioc_s *io
 static void
 bfa_ioc_sm_hbfail_entry(struct bfa_ioc_s *ioc)
 {
-	struct list_head *qe;
-	struct bfa_ioc_hbfail_notify_s *notify;
+	struct list_head			*qe;
+	struct bfa_ioc_hbfail_notify_s	*notify;
 
 	/**
 	 * Mark IOC as failed in hardware and stop firmware.
 	 */
 	bfa_ioc_lpu_stop(ioc);
-	bfa_reg_write(ioc->ioc_regs.ioc_fwstate, BFI_IOC_HBFAIL);
+	bfa_reg_write(ioc->ioc_regs.ioc_fwstate, BFI_IOC_FAIL);
 
-	if (ioc->pcidev.device_id == BFA_PCI_DEVICE_ID_CT) {
-		bfa_reg_write(ioc->ioc_regs.ll_halt, __FW_INIT_HALT_P);
-		/*
-		 * Wait for halt to take effect
-		 */
-		bfa_reg_read(ioc->ioc_regs.ll_halt);
-	}
+	/**
+	 * Notify other functions on HB failure.
+	 */
+	bfa_ioc_notify_hbfail(ioc);
 
 	/**
 	 * Notify driver and common modules registered for notification.
 	 */
 	ioc->cbfn->hbfail_cbfn(ioc->bfa);
 	list_for_each(qe, &ioc->hb_notify_q) {
-		notify = (struct bfa_ioc_hbfail_notify_s *)qe;
+		notify = (struct bfa_ioc_hbfail_notify_s *) qe;
 		notify->cbfn(notify->cbarg);
 	}
 
@@ -672,6 +672,11 @@ bfa_ioc_sm_hbfail(struct bfa_ioc_s *ioc,
 		 */
 		break;
 
+	case IOC_E_HWERROR:
+		/*
+		 * HB failure notification, ignore.
+		 */
+		break;
 	default:
 		bfa_sm_fault(ioc, event);
 	}
@@ -686,8 +691,8 @@ bfa_ioc_sm_hbfail(struct bfa_ioc_s *ioc,
 static void
 bfa_ioc_disable_comp(struct bfa_ioc_s *ioc)
 {
-	struct list_head *qe;
-	struct bfa_ioc_hbfail_notify_s *notify;
+	struct list_head			*qe;
+	struct bfa_ioc_hbfail_notify_s	*notify;
 
 	ioc->cbfn->disable_cbfn(ioc->bfa);
 
@@ -695,7 +700,7 @@ bfa_ioc_disable_comp(struct bfa_ioc_s *i
 	 * Notify common modules registered for notification.
 	 */
 	list_for_each(qe, &ioc->hb_notify_q) {
-		notify = (struct bfa_ioc_hbfail_notify_s *)qe;
+		notify = (struct bfa_ioc_hbfail_notify_s *) qe;
 		notify->cbfn(notify->cbarg);
 	}
 }
@@ -703,41 +708,47 @@ bfa_ioc_disable_comp(struct bfa_ioc_s *i
 static void
 bfa_ioc_sem_timeout(void *ioc_arg)
 {
-	struct bfa_ioc_s *ioc = (struct bfa_ioc_s *)ioc_arg;
+	struct bfa_ioc_s  *ioc = (struct bfa_ioc_s *) ioc_arg;
 
 	bfa_ioc_hw_sem_get(ioc);
 }
 
-static void
-bfa_ioc_usage_sem_get(struct bfa_ioc_s *ioc)
+bfa_boolean_t
+bfa_ioc_sem_get(bfa_os_addr_t sem_reg)
 {
-	u32        r32;
-	int             cnt = 0;
-#define BFA_SEM_SPINCNT	1000
+	u32 r32;
+	int cnt = 0;
+#define BFA_SEM_SPINCNT	3000
 
-	do {
-		r32 = bfa_reg_read(ioc->ioc_regs.ioc_usage_sem_reg);
+	r32 = bfa_reg_read(sem_reg);
+
+	while (r32 && (cnt < BFA_SEM_SPINCNT)) {
 		cnt++;
-		if (cnt > BFA_SEM_SPINCNT)
-			break;
-	} while (r32 != 0);
+		bfa_os_udelay(2);
+		r32 = bfa_reg_read(sem_reg);
+	}
+
+	if (r32 == 0)
+		return BFA_TRUE;
+
 	bfa_assert(cnt < BFA_SEM_SPINCNT);
+	return BFA_FALSE;
 }
 
-static void
-bfa_ioc_usage_sem_release(struct bfa_ioc_s *ioc)
+void
+bfa_ioc_sem_release(bfa_os_addr_t sem_reg)
 {
-	bfa_reg_write(ioc->ioc_regs.ioc_usage_sem_reg, 1);
+	bfa_reg_write(sem_reg, 1);
 }
 
 static void
 bfa_ioc_hw_sem_get(struct bfa_ioc_s *ioc)
 {
-	u32        r32;
+	u32	r32;
 
 	/**
 	 * First read to the semaphore register will return 0, subsequent reads
-	 * will return 1. Semaphore is released by writing 0 to the register
+	 * will return 1. Semaphore is released by writing 1 to the register
 	 */
 	r32 = bfa_reg_read(ioc->ioc_regs.ioc_sem_reg);
 	if (r32 == 0) {
@@ -746,10 +757,10 @@ bfa_ioc_hw_sem_get(struct bfa_ioc_s *ioc
 	}
 
 	bfa_timer_begin(ioc->timer_mod, &ioc->sem_timer, bfa_ioc_sem_timeout,
-			ioc, BFA_IOC_TOV);
+			ioc, BFA_IOC_HWSEM_TOV);
 }
 
-static void
+void
 bfa_ioc_hw_sem_release(struct bfa_ioc_s *ioc)
 {
 	bfa_reg_write(ioc->ioc_regs.ioc_sem_reg, 1);
@@ -767,14 +778,18 @@ bfa_ioc_hw_sem_get_cancel(struct bfa_ioc
 static void
 bfa_ioc_lmem_init(struct bfa_ioc_s *ioc)
 {
-	u32        pss_ctl;
-	int             i;
+	u32	pss_ctl;
+	int		i;
 #define PSS_LMEM_INIT_TIME  10000
 
 	pss_ctl = bfa_reg_read(ioc->ioc_regs.pss_ctl_reg);
 	pss_ctl &= ~__PSS_LMEM_RESET;
 	pss_ctl |= __PSS_LMEM_INIT_EN;
-	pss_ctl |= __PSS_I2C_CLK_DIV(3UL); /* i2c workaround 12.5khz clock */
+
+	/*
+	 * i2c workaround 12.5khz clock
+	 */
+	pss_ctl |= __PSS_I2C_CLK_DIV(3UL);
 	bfa_reg_write(ioc->ioc_regs.pss_ctl_reg, pss_ctl);
 
 	/**
@@ -800,7 +815,7 @@ bfa_ioc_lmem_init(struct bfa_ioc_s *ioc)
 static void
 bfa_ioc_lpu_start(struct bfa_ioc_s *ioc)
 {
-	u32        pss_ctl;
+	u32	pss_ctl;
 
 	/**
 	 * Take processor out of reset.
@@ -814,7 +829,7 @@ bfa_ioc_lpu_start(struct bfa_ioc_s *ioc)
 static void
 bfa_ioc_lpu_stop(struct bfa_ioc_s *ioc)
 {
-	u32        pss_ctl;
+	u32	pss_ctl;
 
 	/**
 	 * Put processors in reset.
@@ -828,13 +843,13 @@ bfa_ioc_lpu_stop(struct bfa_ioc_s *ioc)
 /**
  * Get driver and firmware versions.
  */
-static void
+void
 bfa_ioc_fwver_get(struct bfa_ioc_s *ioc, struct bfi_ioc_image_hdr_s *fwhdr)
 {
-	u32        pgnum, pgoff;
-	u32        loff = 0;
-	int             i;
-	u32       *fwsig = (u32 *) fwhdr;
+	u32	pgnum, pgoff;
+	u32	loff = 0;
+	int		i;
+	u32	*fwsig = (u32 *) fwhdr;
 
 	pgnum = bfa_ioc_smem_pgnum(ioc, loff);
 	pgoff = bfa_ioc_smem_pgoff(ioc, loff);
@@ -842,36 +857,23 @@ bfa_ioc_fwver_get(struct bfa_ioc_s *ioc,
 
 	for (i = 0; i < (sizeof(struct bfi_ioc_image_hdr_s) / sizeof(u32));
 	     i++) {
-		fwsig[i] = bfa_mem_read(ioc->ioc_regs.smem_page_start, loff);
+		fwsig[i] =
+			bfa_mem_read(ioc->ioc_regs.smem_page_start, loff);
 		loff += sizeof(u32);
 	}
 }
 
-static u32 *
-bfa_ioc_fwimg_get_chunk(struct bfa_ioc_s *ioc, u32 off)
-{
-	if (ioc->ctdev)
-		return bfi_image_ct_get_chunk(off);
-	return bfi_image_cb_get_chunk(off);
-}
-
-static          u32
-bfa_ioc_fwimg_get_size(struct bfa_ioc_s *ioc)
-{
-return (ioc->ctdev) ? bfi_image_ct_size : bfi_image_cb_size;
-}
-
 /**
  * Returns TRUE if same.
  */
-static          bfa_boolean_t
+bfa_boolean_t
 bfa_ioc_fwver_cmp(struct bfa_ioc_s *ioc, struct bfi_ioc_image_hdr_s *fwhdr)
 {
 	struct bfi_ioc_image_hdr_s *drv_fwhdr;
-	int             i;
+	int i;
 
 	drv_fwhdr =
-		(struct bfi_ioc_image_hdr_s *)bfa_ioc_fwimg_get_chunk(ioc, 0);
+		(struct bfi_ioc_image_hdr_s *) bfa_ioc_fwimg_get_chunk(ioc, 0);
 
 	for (i = 0; i < BFI_IOC_MD5SUM_SZ; i++) {
 		if (fwhdr->md5sum[i] != drv_fwhdr->md5sum[i]) {
@@ -890,7 +892,7 @@ bfa_ioc_fwver_cmp(struct bfa_ioc_s *ioc,
  * Return true if current running version is valid. Firmware signature and
  * execution context (driver/bios) must match.
  */
-static          bfa_boolean_t
+static bfa_boolean_t
 bfa_ioc_fwver_valid(struct bfa_ioc_s *ioc)
 {
 	struct bfi_ioc_image_hdr_s fwhdr, *drv_fwhdr;
@@ -903,7 +905,7 @@ bfa_ioc_fwver_valid(struct bfa_ioc_s *io
 
 	bfa_ioc_fwver_get(ioc, &fwhdr);
 	drv_fwhdr =
-		(struct bfi_ioc_image_hdr_s *)bfa_ioc_fwimg_get_chunk(ioc, 0);
+		(struct bfi_ioc_image_hdr_s *) bfa_ioc_fwimg_get_chunk(ioc, 0);
 
 	if (fwhdr.signature != drv_fwhdr->signature) {
 		bfa_trc(ioc, fwhdr.signature);
@@ -921,101 +923,12 @@ bfa_ioc_fwver_valid(struct bfa_ioc_s *io
 }
 
 /**
- * Return true if firmware of current driver matches the running firmware.
- */
-static          bfa_boolean_t
-bfa_ioc_firmware_lock(struct bfa_ioc_s *ioc)
-{
-	enum bfi_ioc_state ioc_fwstate;
-	u32        usecnt;
-	struct bfi_ioc_image_hdr_s fwhdr;
-
-	/**
-	 * Firmware match check is relevant only for CNA.
-	 */
-	if (!ioc->cna)
-		return BFA_TRUE;
-
-	/**
-	 * If bios boot (flash based) -- do not increment usage count
-	 */
-	if (bfa_ioc_fwimg_get_size(ioc) < BFA_IOC_FWIMG_MINSZ)
-		return BFA_TRUE;
-
-	bfa_ioc_usage_sem_get(ioc);
-	usecnt = bfa_reg_read(ioc->ioc_regs.ioc_usage_reg);
-
-	/**
-	 * If usage count is 0, always return TRUE.
-	 */
-	if (usecnt == 0) {
-		bfa_reg_write(ioc->ioc_regs.ioc_usage_reg, 1);
-		bfa_ioc_usage_sem_release(ioc);
-		bfa_trc(ioc, usecnt);
-		return BFA_TRUE;
-	}
-
-	ioc_fwstate = bfa_reg_read(ioc->ioc_regs.ioc_fwstate);
-	bfa_trc(ioc, ioc_fwstate);
-
-	/**
-	 * Use count cannot be non-zero and chip in uninitialized state.
-	 */
-	bfa_assert(ioc_fwstate != BFI_IOC_UNINIT);
-
-	/**
-	 * Check if another driver with a different firmware is active
-	 */
-	bfa_ioc_fwver_get(ioc, &fwhdr);
-	if (!bfa_ioc_fwver_cmp(ioc, &fwhdr)) {
-		bfa_ioc_usage_sem_release(ioc);
-		bfa_trc(ioc, usecnt);
-		return BFA_FALSE;
-	}
-
-	/**
-	 * Same firmware version. Increment the reference count.
-	 */
-	usecnt++;
-	bfa_reg_write(ioc->ioc_regs.ioc_usage_reg, usecnt);
-	bfa_ioc_usage_sem_release(ioc);
-	bfa_trc(ioc, usecnt);
-	return BFA_TRUE;
-}
-
-static void
-bfa_ioc_firmware_unlock(struct bfa_ioc_s *ioc)
-{
-	u32        usecnt;
-
-	/**
-	 * Firmware lock is relevant only for CNA.
-	 * If bios boot (flash based) -- do not decrement usage count
-	 */
-	if (!ioc->cna || (bfa_ioc_fwimg_get_size(ioc) < BFA_IOC_FWIMG_MINSZ))
-		return;
-
-	/**
-	 * decrement usage count
-	 */
-	bfa_ioc_usage_sem_get(ioc);
-	usecnt = bfa_reg_read(ioc->ioc_regs.ioc_usage_reg);
-	bfa_assert(usecnt > 0);
-
-	usecnt--;
-	bfa_reg_write(ioc->ioc_regs.ioc_usage_reg, usecnt);
-	bfa_trc(ioc, usecnt);
-
-	bfa_ioc_usage_sem_release(ioc);
-}
-
-/**
  * Conditionally flush any pending message from firmware at start.
  */
 static void
 bfa_ioc_msgflush(struct bfa_ioc_s *ioc)
 {
-	u32        r32;
+	u32	r32;
 
 	r32 = bfa_reg_read(ioc->ioc_regs.lpu_mbox_cmd);
 	if (r32)
@@ -1027,7 +940,7 @@ static void
 bfa_ioc_hwinit(struct bfa_ioc_s *ioc, bfa_boolean_t force)
 {
 	enum bfi_ioc_state ioc_fwstate;
-	bfa_boolean_t   fwvalid;
+	bfa_boolean_t fwvalid;
 
 	ioc_fwstate = bfa_reg_read(ioc->ioc_regs.ioc_fwstate);
 
@@ -1040,7 +953,7 @@ bfa_ioc_hwinit(struct bfa_ioc_s *ioc, bf
 	 * check if firmware is valid
 	 */
 	fwvalid = (ioc_fwstate == BFI_IOC_UNINIT) ?
-			BFA_FALSE : bfa_ioc_fwver_valid(ioc);
+		BFA_FALSE : bfa_ioc_fwver_valid(ioc);
 
 	if (!fwvalid) {
 		bfa_ioc_boot(ioc, BFI_BOOT_TYPE_NORMAL, ioc->pcidev.device_id);
@@ -1083,7 +996,7 @@ bfa_ioc_hwinit(struct bfa_ioc_s *ioc, bf
 static void
 bfa_ioc_timeout(void *ioc_arg)
 {
-	struct bfa_ioc_s *ioc = (struct bfa_ioc_s *)ioc_arg;
+	struct bfa_ioc_s  *ioc = (struct bfa_ioc_s *) ioc_arg;
 
 	bfa_trc(ioc, 0);
 	bfa_fsm_send_event(ioc, IOC_E_TIMEOUT);
@@ -1092,8 +1005,8 @@ bfa_ioc_timeout(void *ioc_arg)
 void
 bfa_ioc_mbox_send(struct bfa_ioc_s *ioc, void *ioc_msg, int len)
 {
-	u32       *msgp = (u32 *) ioc_msg;
-	u32        i;
+	u32 *msgp = (u32 *) ioc_msg;
+	u32 i;
 
 	bfa_trc(ioc, msgp[0]);
 	bfa_trc(ioc, len);
@@ -1114,7 +1027,7 @@ bfa_ioc_mbox_send(struct bfa_ioc_s *ioc,
 	 * write 1 to mailbox CMD to trigger LPU event
 	 */
 	bfa_reg_write(ioc->ioc_regs.hfn_mbox_cmd, 1);
-	(void)bfa_reg_read(ioc->ioc_regs.hfn_mbox_cmd);
+	(void) bfa_reg_read(ioc->ioc_regs.hfn_mbox_cmd);
 }
 
 static void
@@ -1141,7 +1054,7 @@ bfa_ioc_send_disable(struct bfa_ioc_s *i
 static void
 bfa_ioc_send_getattr(struct bfa_ioc_s *ioc)
 {
-	struct bfi_ioc_getattr_req_s attr_req;
+	struct bfi_ioc_getattr_req_s	attr_req;
 
 	bfi_h2i_set(attr_req.mh, BFI_MC_IOC, BFI_IOC_H2I_GETATTR_REQ,
 		    bfa_ioc_portid(ioc));
@@ -1152,36 +1065,30 @@ bfa_ioc_send_getattr(struct bfa_ioc_s *i
 static void
 bfa_ioc_hb_check(void *cbarg)
 {
-	struct bfa_ioc_s *ioc = cbarg;
-	u32        hb_count;
+	struct bfa_ioc_s  *ioc = cbarg;
+	u32	hb_count;
 
 	hb_count = bfa_reg_read(ioc->ioc_regs.heartbeat);
 	if (ioc->hb_count == hb_count) {
-		ioc->hb_fail++;
-	} else {
-		ioc->hb_count = hb_count;
-		ioc->hb_fail = 0;
-	}
-
-	if (ioc->hb_fail >= BFA_IOC_HB_FAIL_MAX) {
-		bfa_log(ioc->logm, BFA_LOG_HAL_HEARTBEAT_FAILURE, hb_count);
-		ioc->hb_fail = 0;
+		bfa_log(ioc->logm, BFA_LOG_HAL_HEARTBEAT_FAILURE,
+			hb_count);
 		bfa_ioc_recover(ioc);
 		return;
+	} else {
+		ioc->hb_count = hb_count;
 	}
 
 	bfa_ioc_mbox_poll(ioc);
-	bfa_timer_begin(ioc->timer_mod, &ioc->ioc_timer, bfa_ioc_hb_check, ioc,
-			BFA_IOC_HB_TOV);
+	bfa_timer_begin(ioc->timer_mod, &ioc->ioc_timer, bfa_ioc_hb_check,
+			ioc, BFA_IOC_HB_TOV);
 }
 
 static void
 bfa_ioc_hb_monitor(struct bfa_ioc_s *ioc)
 {
-	ioc->hb_fail = 0;
 	ioc->hb_count = bfa_reg_read(ioc->ioc_regs.heartbeat);
-	bfa_timer_begin(ioc->timer_mod, &ioc->ioc_timer, bfa_ioc_hb_check, ioc,
-			BFA_IOC_HB_TOV);
+	bfa_timer_begin(ioc->timer_mod, &ioc->ioc_timer, bfa_ioc_hb_check,
+			ioc, BFA_IOC_HB_TOV);
 }
 
 static void
@@ -1190,124 +1097,19 @@ bfa_ioc_hb_stop(struct bfa_ioc_s *ioc)
 	bfa_timer_stop(&ioc->ioc_timer);
 }
 
-/**
- * Host to LPU mailbox message addresses
- */
-static struct {
-	u32        hfn_mbox, lpu_mbox, hfn_pgn;
-} iocreg_fnreg[] = {
-	{
-	HOSTFN0_LPU_MBOX0_0, LPU_HOSTFN0_MBOX0_0, HOST_PAGE_NUM_FN0}, {
-	HOSTFN1_LPU_MBOX0_8, LPU_HOSTFN1_MBOX0_8, HOST_PAGE_NUM_FN1}, {
-	HOSTFN2_LPU_MBOX0_0, LPU_HOSTFN2_MBOX0_0, HOST_PAGE_NUM_FN2}, {
-	HOSTFN3_LPU_MBOX0_8, LPU_HOSTFN3_MBOX0_8, HOST_PAGE_NUM_FN3}
-};
-
-/**
- * Host <-> LPU mailbox command/status registers - port 0
- */
-static struct {
-	u32        hfn, lpu;
-} iocreg_mbcmd_p0[] = {
-	{
-	HOSTFN0_LPU0_MBOX0_CMD_STAT, LPU0_HOSTFN0_MBOX0_CMD_STAT}, {
-	HOSTFN1_LPU0_MBOX0_CMD_STAT, LPU0_HOSTFN1_MBOX0_CMD_STAT}, {
-	HOSTFN2_LPU0_MBOX0_CMD_STAT, LPU0_HOSTFN2_MBOX0_CMD_STAT}, {
-	HOSTFN3_LPU0_MBOX0_CMD_STAT, LPU0_HOSTFN3_MBOX0_CMD_STAT}
-};
 
 /**
- * Host <-> LPU mailbox command/status registers - port 1
- */
-static struct {
-	u32        hfn, lpu;
-} iocreg_mbcmd_p1[] = {
-	{
-	HOSTFN0_LPU1_MBOX0_CMD_STAT, LPU1_HOSTFN0_MBOX0_CMD_STAT}, {
-	HOSTFN1_LPU1_MBOX0_CMD_STAT, LPU1_HOSTFN1_MBOX0_CMD_STAT}, {
-	HOSTFN2_LPU1_MBOX0_CMD_STAT, LPU1_HOSTFN2_MBOX0_CMD_STAT}, {
-	HOSTFN3_LPU1_MBOX0_CMD_STAT, LPU1_HOSTFN3_MBOX0_CMD_STAT}
-};
-
-/**
- * Shared IRQ handling in INTX mode
- */
-static struct {
-	u32        isr, msk;
-} iocreg_shirq_next[] = {
-	{
-	HOSTFN1_INT_STATUS, HOSTFN1_INT_MSK}, {
-	HOSTFN2_INT_STATUS, HOSTFN2_INT_MSK}, {
-	HOSTFN3_INT_STATUS, HOSTFN3_INT_MSK}, {
-HOSTFN0_INT_STATUS, HOSTFN0_INT_MSK},};
-
-static void
-bfa_ioc_reg_init(struct bfa_ioc_s *ioc)
-{
-	bfa_os_addr_t   rb;
-	int             pcifn = bfa_ioc_pcifn(ioc);
-
-	rb = bfa_ioc_bar0(ioc);
-
-	ioc->ioc_regs.hfn_mbox = rb + iocreg_fnreg[pcifn].hfn_mbox;
-	ioc->ioc_regs.lpu_mbox = rb + iocreg_fnreg[pcifn].lpu_mbox;
-	ioc->ioc_regs.host_page_num_fn = rb + iocreg_fnreg[pcifn].hfn_pgn;
-
-	if (ioc->port_id == 0) {
-		ioc->ioc_regs.heartbeat = rb + BFA_IOC0_HBEAT_REG;
-		ioc->ioc_regs.ioc_fwstate = rb + BFA_IOC0_STATE_REG;
-		ioc->ioc_regs.hfn_mbox_cmd = rb + iocreg_mbcmd_p0[pcifn].hfn;
-		ioc->ioc_regs.lpu_mbox_cmd = rb + iocreg_mbcmd_p0[pcifn].lpu;
-		ioc->ioc_regs.ll_halt = rb + FW_INIT_HALT_P0;
-	} else {
-		ioc->ioc_regs.heartbeat = (rb + BFA_IOC1_HBEAT_REG);
-		ioc->ioc_regs.ioc_fwstate = (rb + BFA_IOC1_STATE_REG);
-		ioc->ioc_regs.hfn_mbox_cmd = rb + iocreg_mbcmd_p1[pcifn].hfn;
-		ioc->ioc_regs.lpu_mbox_cmd = rb + iocreg_mbcmd_p1[pcifn].lpu;
-		ioc->ioc_regs.ll_halt = rb + FW_INIT_HALT_P1;
-	}
-
-	/**
-	 * Shared IRQ handling in INTX mode
-	 */
-	ioc->ioc_regs.shirq_isr_next = rb + iocreg_shirq_next[pcifn].isr;
-	ioc->ioc_regs.shirq_msk_next = rb + iocreg_shirq_next[pcifn].msk;
-
-	/*
-	 * PSS control registers
-	 */
-	ioc->ioc_regs.pss_ctl_reg = (rb + PSS_CTL_REG);
-	ioc->ioc_regs.app_pll_fast_ctl_reg = (rb + APP_PLL_425_CTL_REG);
-	ioc->ioc_regs.app_pll_slow_ctl_reg = (rb + APP_PLL_312_CTL_REG);
-
-	/*
-	 * IOC semaphore registers and serialization
-	 */
-	ioc->ioc_regs.ioc_sem_reg = (rb + HOST_SEM0_REG);
-	ioc->ioc_regs.ioc_usage_sem_reg = (rb + HOST_SEM1_REG);
-	ioc->ioc_regs.ioc_usage_reg = (rb + BFA_FW_USE_COUNT);
-
-	/**
-	 * sram memory access
-	 */
-	ioc->ioc_regs.smem_page_start = (rb + PSS_SMEM_PAGE_START);
-	ioc->ioc_regs.smem_pg0 = BFI_IOC_SMEM_PG0_CB;
-	if (ioc->pcidev.device_id == BFA_PCI_DEVICE_ID_CT)
-		ioc->ioc_regs.smem_pg0 = BFI_IOC_SMEM_PG0_CT;
-}
-
-/**
- *      Initiate a full firmware download.
+ *	Initiate a full firmware download.
  */
 static void
 bfa_ioc_download_fw(struct bfa_ioc_s *ioc, u32 boot_type,
 		    u32 boot_param)
 {
-	u32       *fwimg;
-	u32        pgnum, pgoff;
-	u32        loff = 0;
-	u32        chunkno = 0;
-	u32        i;
+	u32 *fwimg;
+	u32 pgnum, pgoff;
+	u32 loff = 0;
+	u32 chunkno = 0;
+	u32 i;
 
 	/**
 	 * Initialize LMEM first before code download
@@ -1321,9 +1123,6 @@ bfa_ioc_download_fw(struct bfa_ioc_s *io
 	if (bfa_ioc_fwimg_get_size(ioc) < BFA_IOC_FWIMG_MINSZ)
 		boot_type = BFI_BOOT_TYPE_FLASH;
 	fwimg = bfa_ioc_fwimg_get_chunk(ioc, chunkno);
-	fwimg[BFI_BOOT_TYPE_OFF / sizeof(u32)] = bfa_os_swap32(boot_type);
-	fwimg[BFI_BOOT_PARAM_OFF / sizeof(u32)] =
-		bfa_os_swap32(boot_param);
 
 	pgnum = bfa_ioc_smem_pgnum(ioc, loff);
 	pgoff = bfa_ioc_smem_pgoff(ioc, loff);
@@ -1332,17 +1131,17 @@ bfa_ioc_download_fw(struct bfa_ioc_s *io
 
 	for (i = 0; i < bfa_ioc_fwimg_get_size(ioc); i++) {
 
-		if (BFA_FLASH_CHUNK_NO(i) != chunkno) {
-			chunkno = BFA_FLASH_CHUNK_NO(i);
+		if (BFA_IOC_FLASH_CHUNK_NO(i) != chunkno) {
+			chunkno = BFA_IOC_FLASH_CHUNK_NO(i);
 			fwimg = bfa_ioc_fwimg_get_chunk(ioc,
-					BFA_FLASH_CHUNK_ADDR(chunkno));
+					BFA_IOC_FLASH_CHUNK_ADDR(chunkno));
 		}
 
 		/**
 		 * write smem
 		 */
 		bfa_mem_write(ioc->ioc_regs.smem_page_start, loff,
-			      fwimg[BFA_FLASH_OFFSET_IN_CHUNK(i)]);
+			      fwimg[BFA_IOC_FLASH_OFFSET_IN_CHUNK(i)]);
 
 		loff += sizeof(u32);
 
@@ -1352,12 +1151,21 @@ bfa_ioc_download_fw(struct bfa_ioc_s *io
 		loff = PSS_SMEM_PGOFF(loff);
 		if (loff == 0) {
 			pgnum++;
-			bfa_reg_write(ioc->ioc_regs.host_page_num_fn, pgnum);
+			bfa_reg_write(ioc->ioc_regs.host_page_num_fn,
+				      pgnum);
 		}
 	}
 
 	bfa_reg_write(ioc->ioc_regs.host_page_num_fn,
 		      bfa_ioc_smem_pgnum(ioc, 0));
+
+	/*
+	 * Set boot type and boot param at the end.
+	*/
+	bfa_mem_write(ioc->ioc_regs.smem_page_start, BFI_BOOT_TYPE_OFF,
+			bfa_os_swap32(boot_type));
+	bfa_mem_write(ioc->ioc_regs.smem_page_start, BFI_BOOT_PARAM_OFF,
+			bfa_os_swap32(boot_param));
 }
 
 static void
@@ -1372,10 +1180,10 @@ bfa_ioc_reset(struct bfa_ioc_s *ioc, bfa
 static void
 bfa_ioc_getattr_reply(struct bfa_ioc_s *ioc)
 {
-	struct bfi_ioc_attr_s *attr = ioc->attr;
+	struct bfi_ioc_attr_s	*attr = ioc->attr;
 
-	attr->adapter_prop = bfa_os_ntohl(attr->adapter_prop);
-	attr->maxfrsize = bfa_os_ntohs(attr->maxfrsize);
+	attr->adapter_prop  = bfa_os_ntohl(attr->adapter_prop);
+	attr->maxfrsize	    = bfa_os_ntohs(attr->maxfrsize);
 
 	bfa_fsm_send_event(ioc, IOC_E_FWRSP_GETATTR);
 }
@@ -1386,8 +1194,8 @@ bfa_ioc_getattr_reply(struct bfa_ioc_s *
 static void
 bfa_ioc_mbox_attach(struct bfa_ioc_s *ioc)
 {
-	struct bfa_ioc_mbox_mod_s *mod = &ioc->mbox_mod;
-	int             mc;
+	struct bfa_ioc_mbox_mod_s	*mod = &ioc->mbox_mod;
+	int	mc;
 
 	INIT_LIST_HEAD(&mod->cmd_q);
 	for (mc = 0; mc < BFI_MC_MAX; mc++) {
@@ -1402,9 +1210,9 @@ bfa_ioc_mbox_attach(struct bfa_ioc_s *io
 static void
 bfa_ioc_mbox_poll(struct bfa_ioc_s *ioc)
 {
-	struct bfa_ioc_mbox_mod_s *mod = &ioc->mbox_mod;
-	struct bfa_mbox_cmd_s *cmd;
-	u32        stat;
+	struct bfa_ioc_mbox_mod_s	*mod = &ioc->mbox_mod;
+	struct bfa_mbox_cmd_s		*cmd;
+	u32			stat;
 
 	/**
 	 * If no command pending, do nothing
@@ -1432,43 +1240,13 @@ bfa_ioc_mbox_poll(struct bfa_ioc_s *ioc)
 static void
 bfa_ioc_mbox_hbfail(struct bfa_ioc_s *ioc)
 {
-	struct bfa_ioc_mbox_mod_s *mod = &ioc->mbox_mod;
-	struct bfa_mbox_cmd_s *cmd;
+	struct bfa_ioc_mbox_mod_s	*mod = &ioc->mbox_mod;
+	struct bfa_mbox_cmd_s		*cmd;
 
 	while (!list_empty(&mod->cmd_q))
 		bfa_q_deq(&mod->cmd_q, &cmd);
 }
 
-/**
- * Initialize IOC to port mapping.
- */
-
-#define FNC_PERS_FN_SHIFT(__fn)	((__fn) * 8)
-static void
-bfa_ioc_map_port(struct bfa_ioc_s *ioc)
-{
-	bfa_os_addr_t   rb = ioc->pcidev.pci_bar_kva;
-	u32        r32;
-
-	/**
-	 * For crossbow, port id is same as pci function.
-	 */
-	if (ioc->pcidev.device_id != BFA_PCI_DEVICE_ID_CT) {
-		ioc->port_id = bfa_ioc_pcifn(ioc);
-		return;
-	}
-
-	/**
-	 * For catapult, base port id on personality register and IOC type
-	 */
-	r32 = bfa_reg_read(rb + FNC_PERS_REG);
-	r32 >>= FNC_PERS_FN_SHIFT(bfa_ioc_pcifn(ioc));
-	ioc->port_id = (r32 & __F0_PORT_MAP_MK) >> __F0_PORT_MAP_SH;
-
-	bfa_trc(ioc, bfa_ioc_pcifn(ioc));
-	bfa_trc(ioc, ioc->port_id);
-}
-
 
 
 /**
@@ -1476,139 +1254,13 @@ bfa_ioc_map_port(struct bfa_ioc_s *ioc)
  */
 
 /**
-* Set interrupt mode for a function: INTX or MSIX
- */
-void
-bfa_ioc_isr_mode_set(struct bfa_ioc_s *ioc, bfa_boolean_t msix)
-{
-	bfa_os_addr_t   rb = ioc->pcidev.pci_bar_kva;
-	u32        r32, mode;
-
-	r32 = bfa_reg_read(rb + FNC_PERS_REG);
-	bfa_trc(ioc, r32);
-
-	mode = (r32 >> FNC_PERS_FN_SHIFT(bfa_ioc_pcifn(ioc))) &
-		__F0_INTX_STATUS;
-
-	/**
-	 * If already in desired mode, do not change anything
-	 */
-	if (!msix && mode)
-		return;
-
-	if (msix)
-		mode = __F0_INTX_STATUS_MSIX;
-	else
-		mode = __F0_INTX_STATUS_INTA;
-
-	r32 &= ~(__F0_INTX_STATUS << FNC_PERS_FN_SHIFT(bfa_ioc_pcifn(ioc)));
-	r32 |= (mode << FNC_PERS_FN_SHIFT(bfa_ioc_pcifn(ioc)));
-	bfa_trc(ioc, r32);
-
-	bfa_reg_write(rb + FNC_PERS_REG, r32);
-}
-
-bfa_status_t
-bfa_ioc_pll_init(struct bfa_ioc_s *ioc)
-{
-	bfa_os_addr_t   rb = ioc->pcidev.pci_bar_kva;
-	u32        pll_sclk, pll_fclk, r32;
-
-	if (ioc->pcidev.device_id == BFA_PCI_DEVICE_ID_CT) {
-		pll_sclk =
-			__APP_PLL_312_ENABLE | __APP_PLL_312_LRESETN |
-			__APP_PLL_312_RSEL200500 | __APP_PLL_312_P0_1(0U) |
-			__APP_PLL_312_JITLMT0_1(3U) |
-			__APP_PLL_312_CNTLMT0_1(1U);
-		pll_fclk =
-			__APP_PLL_425_ENABLE | __APP_PLL_425_LRESETN |
-			__APP_PLL_425_RSEL200500 | __APP_PLL_425_P0_1(0U) |
-			__APP_PLL_425_JITLMT0_1(3U) |
-			__APP_PLL_425_CNTLMT0_1(1U);
-
-		/**
-		 * 	For catapult, choose operational mode FC/FCoE
-		 */
-		if (ioc->fcmode) {
-			bfa_reg_write((rb + OP_MODE), 0);
-			bfa_reg_write((rb + ETH_MAC_SER_REG),
-				      __APP_EMS_CMLCKSEL | __APP_EMS_REFCKBUFEN2
-				      | __APP_EMS_CHANNEL_SEL);
-		} else {
-			ioc->pllinit = BFA_TRUE;
-			bfa_reg_write((rb + OP_MODE), __GLOBAL_FCOE_MODE);
-			bfa_reg_write((rb + ETH_MAC_SER_REG),
-				      __APP_EMS_REFCKBUFEN1);
-		}
-	} else {
-		pll_sclk =
-			__APP_PLL_312_ENABLE | __APP_PLL_312_LRESETN |
-			__APP_PLL_312_P0_1(3U) | __APP_PLL_312_JITLMT0_1(3U) |
-			__APP_PLL_312_CNTLMT0_1(3U);
-		pll_fclk =
-			__APP_PLL_425_ENABLE | __APP_PLL_425_LRESETN |
-			__APP_PLL_425_RSEL200500 | __APP_PLL_425_P0_1(3U) |
-			__APP_PLL_425_JITLMT0_1(3U) |
-			__APP_PLL_425_CNTLMT0_1(3U);
-	}
-
-	bfa_reg_write((rb + BFA_IOC0_STATE_REG), BFI_IOC_UNINIT);
-	bfa_reg_write((rb + BFA_IOC1_STATE_REG), BFI_IOC_UNINIT);
-
-	bfa_reg_write((rb + HOSTFN0_INT_MSK), 0xffffffffU);
-	bfa_reg_write((rb + HOSTFN1_INT_MSK), 0xffffffffU);
-	bfa_reg_write((rb + HOSTFN0_INT_STATUS), 0xffffffffU);
-	bfa_reg_write((rb + HOSTFN1_INT_STATUS), 0xffffffffU);
-	bfa_reg_write((rb + HOSTFN0_INT_MSK), 0xffffffffU);
-	bfa_reg_write((rb + HOSTFN1_INT_MSK), 0xffffffffU);
-
-	bfa_reg_write(ioc->ioc_regs.app_pll_slow_ctl_reg,
-		      __APP_PLL_312_LOGIC_SOFT_RESET);
-	bfa_reg_write(ioc->ioc_regs.app_pll_slow_ctl_reg,
-		      __APP_PLL_312_BYPASS | __APP_PLL_312_LOGIC_SOFT_RESET);
-	bfa_reg_write(ioc->ioc_regs.app_pll_fast_ctl_reg,
-		      __APP_PLL_425_LOGIC_SOFT_RESET);
-	bfa_reg_write(ioc->ioc_regs.app_pll_fast_ctl_reg,
-		      __APP_PLL_425_BYPASS | __APP_PLL_425_LOGIC_SOFT_RESET);
-	bfa_os_udelay(2);
-	bfa_reg_write(ioc->ioc_regs.app_pll_slow_ctl_reg,
-		      __APP_PLL_312_LOGIC_SOFT_RESET);
-	bfa_reg_write(ioc->ioc_regs.app_pll_fast_ctl_reg,
-		      __APP_PLL_425_LOGIC_SOFT_RESET);
-
-	bfa_reg_write(ioc->ioc_regs.app_pll_slow_ctl_reg,
-		      pll_sclk | __APP_PLL_312_LOGIC_SOFT_RESET);
-	bfa_reg_write(ioc->ioc_regs.app_pll_fast_ctl_reg,
-		      pll_fclk | __APP_PLL_425_LOGIC_SOFT_RESET);
-
-	/**
-	 * Wait for PLLs to lock.
-	 */
-	bfa_os_udelay(2000);
-	bfa_reg_write((rb + HOSTFN0_INT_STATUS), 0xffffffffU);
-	bfa_reg_write((rb + HOSTFN1_INT_STATUS), 0xffffffffU);
-
-	bfa_reg_write(ioc->ioc_regs.app_pll_slow_ctl_reg, pll_sclk);
-	bfa_reg_write(ioc->ioc_regs.app_pll_fast_ctl_reg, pll_fclk);
-
-	if (ioc->pcidev.device_id == BFA_PCI_DEVICE_ID_CT) {
-		bfa_reg_write((rb + MBIST_CTL_REG), __EDRAM_BISTR_START);
-		bfa_os_udelay(1000);
-		r32 = bfa_reg_read((rb + MBIST_STAT_REG));
-		bfa_trc(ioc, r32);
-	}
-
-	return BFA_STATUS_OK;
-}
-
-/**
  * Interface used by diag module to do firmware boot with memory test
  * as the entry vector.
  */
 void
 bfa_ioc_boot(struct bfa_ioc_s *ioc, u32 boot_type, u32 boot_param)
 {
-	bfa_os_addr_t   rb;
+	bfa_os_addr_t	rb;
 
 	bfa_ioc_stats(ioc, ioc_boots);
 
@@ -1642,10 +1294,11 @@ bfa_ioc_boot(struct bfa_ioc_s *ioc, u32 
 void
 bfa_ioc_auto_recover(bfa_boolean_t auto_recover)
 {
-	bfa_auto_recover = BFA_FALSE;
+	bfa_auto_recover = auto_recover;
 }
 
 
+
 bfa_boolean_t
 bfa_ioc_is_operational(struct bfa_ioc_s *ioc)
 {
@@ -1655,9 +1308,9 @@ bfa_ioc_is_operational(struct bfa_ioc_s 
 void
 bfa_ioc_msgget(struct bfa_ioc_s *ioc, void *mbmsg)
 {
-	u32       *msgp = mbmsg;
-	u32        r32;
-	int             i;
+	u32	*msgp = mbmsg;
+	u32	r32;
+	int		i;
 
 	/**
 	 * read the MBOX msg
@@ -1679,9 +1332,9 @@ bfa_ioc_msgget(struct bfa_ioc_s *ioc, vo
 void
 bfa_ioc_isr(struct bfa_ioc_s *ioc, struct bfi_mbmsg_s *m)
 {
-	union bfi_ioc_i2h_msg_u *msg;
+	union bfi_ioc_i2h_msg_u	*msg;
 
-	msg = (union bfi_ioc_i2h_msg_u *)m;
+	msg = (union bfi_ioc_i2h_msg_u *) m;
 
 	bfa_ioc_stats(ioc, ioc_isrs);
 
@@ -1725,14 +1378,14 @@ bfa_ioc_attach(struct bfa_ioc_s *ioc, vo
 	       struct bfa_timer_mod_s *timer_mod, struct bfa_trc_mod_s *trcmod,
 	       struct bfa_aen_s *aen, struct bfa_log_mod_s *logm)
 {
-	ioc->bfa = bfa;
-	ioc->cbfn = cbfn;
-	ioc->timer_mod = timer_mod;
-	ioc->trcmod = trcmod;
-	ioc->aen = aen;
-	ioc->logm = logm;
-	ioc->fcmode = BFA_FALSE;
-	ioc->pllinit = BFA_FALSE;
+	ioc->bfa	= bfa;
+	ioc->cbfn	= cbfn;
+	ioc->timer_mod	= timer_mod;
+	ioc->trcmod	= trcmod;
+	ioc->aen	= aen;
+	ioc->logm	= logm;
+	ioc->fcmode	= BFA_FALSE;
+	ioc->pllinit	= BFA_FALSE;
 	ioc->dbg_fwsave_once = BFA_TRUE;
 
 	bfa_ioc_mbox_attach(ioc);
@@ -1759,10 +1412,18 @@ void
 bfa_ioc_pci_init(struct bfa_ioc_s *ioc, struct bfa_pcidev_s *pcidev,
 		 enum bfi_mclass mc)
 {
-	ioc->ioc_mc = mc;
-	ioc->pcidev = *pcidev;
-	ioc->ctdev = (ioc->pcidev.device_id == BFA_PCI_DEVICE_ID_CT);
-	ioc->cna = ioc->ctdev && !ioc->fcmode;
+	ioc->ioc_mc	= mc;
+	ioc->pcidev	= *pcidev;
+	ioc->ctdev	= (ioc->pcidev.device_id == BFA_PCI_DEVICE_ID_CT);
+	ioc->cna	= ioc->ctdev && !ioc->fcmode;
+
+	/**
+	 * Set asic specific interfaces. See bfa_ioc_cb.c and bfa_ioc_ct.c
+	 */
+	if (ioc->ctdev)
+		bfa_ioc_set_ct_hwif(ioc);
+	else
+		bfa_ioc_set_cb_hwif(ioc);
 
 	bfa_ioc_map_port(ioc);
 	bfa_ioc_reg_init(ioc);
@@ -1775,14 +1436,14 @@ bfa_ioc_pci_init(struct bfa_ioc_s *ioc, 
  * @param[in]	dm_pa	physical address of IOC dma memory
  */
 void
-bfa_ioc_mem_claim(struct bfa_ioc_s *ioc, u8 *dm_kva, u64 dm_pa)
+bfa_ioc_mem_claim(struct bfa_ioc_s *ioc,  u8 *dm_kva, u64 dm_pa)
 {
 	/**
 	 * dma memory for firmware attribute
 	 */
 	ioc->attr_dma.kva = dm_kva;
 	ioc->attr_dma.pa = dm_pa;
-	ioc->attr = (struct bfi_ioc_attr_s *)dm_kva;
+	ioc->attr = (struct bfi_ioc_attr_s *) dm_kva;
 }
 
 /**
@@ -1820,7 +1481,7 @@ bfa_ioc_disable(struct bfa_ioc_s *ioc)
 int
 bfa_ioc_debug_trcsz(bfa_boolean_t auto_recover)
 {
-return (auto_recover) ? BFA_DBG_FWTRC_LEN : 0;
+	return (auto_recover) ? BFA_DBG_FWTRC_LEN : 0;
 }
 
 /**
@@ -1830,8 +1491,7 @@ return (auto_recover) ? BFA_DBG_FWTRC_LE
 void
 bfa_ioc_debug_memclaim(struct bfa_ioc_s *ioc, void *dbg_fwsave)
 {
-	bfa_assert(ioc->auto_recover);
-	ioc->dbg_fwsave = dbg_fwsave;
+	ioc->dbg_fwsave	    = dbg_fwsave;
 	ioc->dbg_fwsave_len = bfa_ioc_debug_trcsz(ioc->auto_recover);
 }
 
@@ -1856,8 +1516,8 @@ bfa_ioc_smem_pgoff(struct bfa_ioc_s *ioc
 void
 bfa_ioc_mbox_register(struct bfa_ioc_s *ioc, bfa_ioc_mbox_mcfunc_t *mcfuncs)
 {
-	struct bfa_ioc_mbox_mod_s *mod = &ioc->mbox_mod;
-	int             mc;
+	struct bfa_ioc_mbox_mod_s	*mod = &ioc->mbox_mod;
+	int				mc;
 
 	for (mc = 0; mc < BFI_MC_MAX; mc++)
 		mod->mbhdlr[mc].cbfn = mcfuncs[mc];
@@ -1870,9 +1530,9 @@ void
 bfa_ioc_mbox_regisr(struct bfa_ioc_s *ioc, enum bfi_mclass mc,
 		    bfa_ioc_mbox_mcfunc_t cbfn, void *cbarg)
 {
-	struct bfa_ioc_mbox_mod_s *mod = &ioc->mbox_mod;
+	struct bfa_ioc_mbox_mod_s	*mod = &ioc->mbox_mod;
 
-	mod->mbhdlr[mc].cbfn = cbfn;
+	mod->mbhdlr[mc].cbfn	= cbfn;
 	mod->mbhdlr[mc].cbarg = cbarg;
 }
 
@@ -1886,8 +1546,8 @@ bfa_ioc_mbox_regisr(struct bfa_ioc_s *io
 void
 bfa_ioc_mbox_queue(struct bfa_ioc_s *ioc, struct bfa_mbox_cmd_s *cmd)
 {
-	struct bfa_ioc_mbox_mod_s *mod = &ioc->mbox_mod;
-	u32        stat;
+	struct bfa_ioc_mbox_mod_s	*mod = &ioc->mbox_mod;
+	u32			stat;
 
 	/**
 	 * If a previous command is pending, queue new command
@@ -1918,9 +1578,9 @@ bfa_ioc_mbox_queue(struct bfa_ioc_s *ioc
 void
 bfa_ioc_mbox_isr(struct bfa_ioc_s *ioc)
 {
-	struct bfa_ioc_mbox_mod_s *mod = &ioc->mbox_mod;
-	struct bfi_mbmsg_s m;
-	int             mc;
+	struct bfa_ioc_mbox_mod_s	*mod = &ioc->mbox_mod;
+	struct bfi_mbmsg_s		m;
+	int				mc;
 
 	bfa_ioc_msgget(ioc, &m);
 
@@ -1953,8 +1613,8 @@ bfa_ioc_error_isr(struct bfa_ioc_s *ioc)
 bfa_boolean_t
 bfa_ioc_is_disabled(struct bfa_ioc_s *ioc)
 {
-	return (bfa_fsm_cmp_state(ioc, bfa_ioc_sm_disabling)
-		|| bfa_fsm_cmp_state(ioc, bfa_ioc_sm_disabled));
+	return bfa_fsm_cmp_state(ioc, bfa_ioc_sm_disabling) ||
+		bfa_fsm_cmp_state(ioc, bfa_ioc_sm_disabled);
 }
 
 /**
@@ -1963,9 +1623,9 @@ bfa_ioc_is_disabled(struct bfa_ioc_s *io
 bfa_boolean_t
 bfa_ioc_fw_mismatch(struct bfa_ioc_s *ioc)
 {
-	return (bfa_fsm_cmp_state(ioc, bfa_ioc_sm_reset)
-		|| bfa_fsm_cmp_state(ioc, bfa_ioc_sm_fwcheck)
-		|| bfa_fsm_cmp_state(ioc, bfa_ioc_sm_mismatch));
+	return bfa_fsm_cmp_state(ioc, bfa_ioc_sm_reset) ||
+		bfa_fsm_cmp_state(ioc, bfa_ioc_sm_fwcheck) ||
+		bfa_fsm_cmp_state(ioc, bfa_ioc_sm_mismatch);
 }
 
 #define bfa_ioc_state_disabled(__sm)		\
@@ -1973,7 +1633,7 @@ bfa_ioc_fw_mismatch(struct bfa_ioc_s *io
 	 ((__sm) == BFI_IOC_INITING) ||		\
 	 ((__sm) == BFI_IOC_HWINIT) ||		\
 	 ((__sm) == BFI_IOC_DISABLED) ||	\
-	 ((__sm) == BFI_IOC_HBFAIL) ||		\
+	 ((__sm) == BFI_IOC_FAIL) ||		\
 	 ((__sm) == BFI_IOC_CFG_DISABLED))
 
 /**
@@ -1983,8 +1643,8 @@ bfa_ioc_fw_mismatch(struct bfa_ioc_s *io
 bfa_boolean_t
 bfa_ioc_adapter_is_disabled(struct bfa_ioc_s *ioc)
 {
-	u32        ioc_state;
-	bfa_os_addr_t   rb = ioc->pcidev.pci_bar_kva;
+	u32	ioc_state;
+	bfa_os_addr_t	rb = ioc->pcidev.pci_bar_kva;
 
 	if (!bfa_fsm_cmp_state(ioc, bfa_ioc_sm_disabled))
 		return BFA_FALSE;
@@ -2002,7 +1662,7 @@ bfa_ioc_adapter_is_disabled(struct bfa_i
 
 /**
  * Add to IOC heartbeat failure notification queue. To be used by common
- * modules such as
+ * modules such as cee, port, diag.
  */
 void
 bfa_ioc_hbfail_register(struct bfa_ioc_s *ioc,
@@ -2016,102 +1676,164 @@ void
 bfa_ioc_get_adapter_attr(struct bfa_ioc_s *ioc,
 			 struct bfa_adapter_attr_s *ad_attr)
 {
-	struct bfi_ioc_attr_s *ioc_attr;
-	char            model[BFA_ADAPTER_MODEL_NAME_LEN];
+	struct bfi_ioc_attr_s	*ioc_attr;
 
 	ioc_attr = ioc->attr;
-	bfa_os_memcpy((void *)&ad_attr->serial_num,
-		      (void *)ioc_attr->brcd_serialnum,
-		      BFA_ADAPTER_SERIAL_NUM_LEN);
 
-	bfa_os_memcpy(&ad_attr->fw_ver, ioc_attr->fw_version, BFA_VERSION_LEN);
-	bfa_os_memcpy(&ad_attr->optrom_ver, ioc_attr->optrom_version,
-		      BFA_VERSION_LEN);
-	bfa_os_memcpy(&ad_attr->manufacturer, BFA_MFG_NAME,
-		      BFA_ADAPTER_MFG_NAME_LEN);
+	bfa_ioc_get_adapter_serial_num(ioc, ad_attr->serial_num);
+	bfa_ioc_get_adapter_fw_ver(ioc, ad_attr->fw_ver);
+	bfa_ioc_get_adapter_optrom_ver(ioc, ad_attr->optrom_ver);
+	bfa_ioc_get_adapter_manufacturer(ioc, ad_attr->manufacturer);
 	bfa_os_memcpy(&ad_attr->vpd, &ioc_attr->vpd,
 		      sizeof(struct bfa_mfg_vpd_s));
 
-	ad_attr->nports = BFI_ADAPTER_GETP(NPORTS, ioc_attr->adapter_prop);
-	ad_attr->max_speed = BFI_ADAPTER_GETP(SPEED, ioc_attr->adapter_prop);
+	ad_attr->nports = bfa_ioc_get_nports(ioc);
+	ad_attr->max_speed = bfa_ioc_speed_sup(ioc);
 
-	/**
-	 * model name
-	 */
-	if (BFI_ADAPTER_GETP(SPEED, ioc_attr->adapter_prop) == 10) {
-		strcpy(model, "BR-10?0");
-		model[5] = '0' + ad_attr->nports;
-	} else {
-		strcpy(model, "Brocade-??5");
-		model[8] =
-			'0' + BFI_ADAPTER_GETP(SPEED, ioc_attr->adapter_prop);
-		model[9] = '0' + ad_attr->nports;
-	}
+	bfa_ioc_get_adapter_model(ioc, ad_attr->model);
+	/* For now, model descr uses same model string */
+	bfa_ioc_get_adapter_model(ioc, ad_attr->model_descr);
 
 	if (BFI_ADAPTER_IS_SPECIAL(ioc_attr->adapter_prop))
 		ad_attr->prototype = 1;
 	else
 		ad_attr->prototype = 0;
 
-	bfa_os_memcpy(&ad_attr->model, model, BFA_ADAPTER_MODEL_NAME_LEN);
-	bfa_os_memcpy(&ad_attr->model_descr, &ad_attr->model,
-		      BFA_ADAPTER_MODEL_NAME_LEN);
-
 	ad_attr->pwwn = bfa_ioc_get_pwwn(ioc);
-	ad_attr->mac = bfa_ioc_get_mac(ioc);
+	ad_attr->mac  = bfa_ioc_get_mac(ioc);
 
 	ad_attr->pcie_gen = ioc_attr->pcie_gen;
 	ad_attr->pcie_lanes = ioc_attr->pcie_lanes;
 	ad_attr->pcie_lanes_orig = ioc_attr->pcie_lanes_orig;
 	ad_attr->asic_rev = ioc_attr->asic_rev;
-	ad_attr->hw_ver[0] = 'R';
-	ad_attr->hw_ver[1] = 'e';
-	ad_attr->hw_ver[2] = 'v';
-	ad_attr->hw_ver[3] = '-';
-	ad_attr->hw_ver[4] = ioc_attr->asic_rev;
-	ad_attr->hw_ver[5] = '\0';
+
+	bfa_ioc_get_pci_chip_rev(ioc, ad_attr->hw_ver);
 
 	ad_attr->cna_capable = ioc->cna;
 }
 
+enum bfa_ioc_type_e
+bfa_ioc_get_type(struct bfa_ioc_s *ioc)
+{
+	if (!ioc->ctdev || ioc->fcmode)
+		return BFA_IOC_TYPE_FC;
+	else if (ioc->ioc_mc == BFI_MC_IOCFC)
+		return BFA_IOC_TYPE_FCoE;
+	else if (ioc->ioc_mc == BFI_MC_LL)
+		return BFA_IOC_TYPE_LL;
+	else {
+		bfa_assert(ioc->ioc_mc == BFI_MC_LL);
+		return BFA_IOC_TYPE_LL;
+	}
+}
+
+void
+bfa_ioc_get_adapter_serial_num(struct bfa_ioc_s *ioc, char *serial_num)
+{
+	bfa_os_memset((void *)serial_num, 0, BFA_ADAPTER_SERIAL_NUM_LEN);
+	bfa_os_memcpy((void *)serial_num,
+			(void *)ioc->attr->brcd_serialnum,
+			BFA_ADAPTER_SERIAL_NUM_LEN);
+}
+
+void
+bfa_ioc_get_adapter_fw_ver(struct bfa_ioc_s *ioc, char *fw_ver)
+{
+	bfa_os_memset((void *)fw_ver, 0, BFA_VERSION_LEN);
+	bfa_os_memcpy(fw_ver, ioc->attr->fw_version, BFA_VERSION_LEN);
+}
+
+void
+bfa_ioc_get_pci_chip_rev(struct bfa_ioc_s *ioc, char *chip_rev)
+{
+	bfa_assert(chip_rev);
+
+	bfa_os_memset((void *)chip_rev, 0, BFA_IOC_CHIP_REV_LEN);
+
+	chip_rev[0] = 'R';
+	chip_rev[1] = 'e';
+	chip_rev[2] = 'v';
+	chip_rev[3] = '-';
+	chip_rev[4] = ioc->attr->asic_rev;
+	chip_rev[5] = '\0';
+}
+
+void
+bfa_ioc_get_adapter_optrom_ver(struct bfa_ioc_s *ioc, char *optrom_ver)
+{
+	bfa_os_memset((void *)optrom_ver, 0, BFA_VERSION_LEN);
+	bfa_os_memcpy(optrom_ver, ioc->attr->optrom_version,
+		      BFA_VERSION_LEN);
+}
+
+void
+bfa_ioc_get_adapter_manufacturer(struct bfa_ioc_s *ioc, char *manufacturer)
+{
+	bfa_os_memset((void *)manufacturer, 0, BFA_ADAPTER_MFG_NAME_LEN);
+	bfa_os_memcpy(manufacturer, BFA_MFG_NAME, BFA_ADAPTER_MFG_NAME_LEN);
+}
+
+void
+bfa_ioc_get_adapter_model(struct bfa_ioc_s *ioc, char *model)
+{
+	struct bfi_ioc_attr_s	*ioc_attr;
+	u8		nports;
+	u8		max_speed;
+
+	bfa_assert(model);
+	bfa_os_memset((void *)model, 0, BFA_ADAPTER_MODEL_NAME_LEN);
+
+	ioc_attr = ioc->attr;
+
+	nports = bfa_ioc_get_nports(ioc);
+	max_speed = bfa_ioc_speed_sup(ioc);
+
+	/**
+	 * model name
+	 */
+	if (max_speed == 10) {
+		strcpy(model, "BR-10?0");
+		model[5] = '0' + nports;
+	} else {
+		strcpy(model, "Brocade-??5");
+		model[8] = '0' + max_speed;
+		model[9] = '0' + nports;
+	}
+}
+
+enum bfa_ioc_state
+bfa_ioc_get_state(struct bfa_ioc_s *ioc)
+{
+	return bfa_sm_to_state(ioc_sm_table, ioc->fsm);
+}
+
 void
 bfa_ioc_get_attr(struct bfa_ioc_s *ioc, struct bfa_ioc_attr_s *ioc_attr)
 {
 	bfa_os_memset((void *)ioc_attr, 0, sizeof(struct bfa_ioc_attr_s));
 
-	ioc_attr->state = bfa_sm_to_state(ioc_sm_table, ioc->fsm);
+	ioc_attr->state = bfa_ioc_get_state(ioc);
 	ioc_attr->port_id = ioc->port_id;
 
-	if (!ioc->ctdev)
-		ioc_attr->ioc_type = BFA_IOC_TYPE_FC;
-	else if (ioc->ioc_mc == BFI_MC_IOCFC)
-		ioc_attr->ioc_type = BFA_IOC_TYPE_FCoE;
-	else if (ioc->ioc_mc == BFI_MC_LL)
-		ioc_attr->ioc_type = BFA_IOC_TYPE_LL;
+	ioc_attr->ioc_type = bfa_ioc_get_type(ioc);
 
 	bfa_ioc_get_adapter_attr(ioc, &ioc_attr->adapter_attr);
 
 	ioc_attr->pci_attr.device_id = ioc->pcidev.device_id;
 	ioc_attr->pci_attr.pcifn = ioc->pcidev.pci_func;
-	ioc_attr->pci_attr.chip_rev[0] = 'R';
-	ioc_attr->pci_attr.chip_rev[1] = 'e';
-	ioc_attr->pci_attr.chip_rev[2] = 'v';
-	ioc_attr->pci_attr.chip_rev[3] = '-';
-	ioc_attr->pci_attr.chip_rev[4] = ioc_attr->adapter_attr.asic_rev;
-	ioc_attr->pci_attr.chip_rev[5] = '\0';
+	bfa_ioc_get_pci_chip_rev(ioc, ioc_attr->pci_attr.chip_rev);
 }
 
 /**
- *  hal_wwn_public
+ *  bfa_wwn_public
  */
 wwn_t
 bfa_ioc_get_pwwn(struct bfa_ioc_s *ioc)
 {
 	union {
-		wwn_t           wwn;
-		u8         byte[sizeof(wwn_t)];
-	}
-	w;
+		wwn_t	wwn;
+		u8	byte[sizeof(wwn_t)];
+	} w;
 
 	w.wwn = ioc->attr->mfg_wwn;
 
@@ -2125,10 +1847,9 @@ wwn_t
 bfa_ioc_get_nwwn(struct bfa_ioc_s *ioc)
 {
 	union {
-		wwn_t           wwn;
-		u8         byte[sizeof(wwn_t)];
-	}
-	w;
+		wwn_t	wwn;
+		u8	byte[sizeof(wwn_t)];
+	} w;
 
 	w.wwn = ioc->attr->mfg_wwn;
 
@@ -2144,10 +1865,9 @@ wwn_t
 bfa_ioc_get_wwn_naa5(struct bfa_ioc_s *ioc, u16 inst)
 {
 	union {
-		wwn_t           wwn;
-		u8         byte[sizeof(wwn_t)];
-	}
-	w              , w5;
+		wwn_t		wwn;
+		u8		byte[sizeof(wwn_t)];
+	} w, w5;
 
 	bfa_trc(ioc, inst);
 
@@ -2170,10 +1890,10 @@ bfa_ioc_get_adid(struct bfa_ioc_s *ioc)
 	return ioc->attr->mfg_wwn;
 }
 
-mac_t
+struct mac_s
 bfa_ioc_get_mac(struct bfa_ioc_s *ioc)
 {
-	mac_t           mac;
+	struct mac_s	mac;
 
 	mac = ioc->attr->mfg_mac;
 	mac.mac[MAC_ADDRLEN - 1] += bfa_ioc_pcifn(ioc);
@@ -2184,7 +1904,7 @@ bfa_ioc_get_mac(struct bfa_ioc_s *ioc)
 void
 bfa_ioc_set_fcmode(struct bfa_ioc_s *ioc)
 {
-	ioc->fcmode = BFA_TRUE;
+	ioc->fcmode  = BFA_TRUE;
 	ioc->port_id = bfa_ioc_pcifn(ioc);
 }
 
@@ -2195,63 +1915,22 @@ bfa_ioc_get_fcmode(struct bfa_ioc_s *ioc
 }
 
 /**
- * Return true if interrupt should be claimed.
- */
-bfa_boolean_t
-bfa_ioc_intx_claim(struct bfa_ioc_s *ioc)
-{
-	u32        isr, msk;
-
-	/**
-	 * Always claim if not catapult.
-	 */
-	if (!ioc->ctdev)
-		return BFA_TRUE;
-
-	/**
-	 * FALSE if next device is claiming interrupt.
-	 * TRUE if next device is not interrupting or not present.
-	 */
-	msk = bfa_reg_read(ioc->ioc_regs.shirq_msk_next);
-	isr = bfa_reg_read(ioc->ioc_regs.shirq_isr_next);
-	return !(isr & ~msk);
-}
-
-/**
  * Send AEN notification
  */
 static void
 bfa_ioc_aen_post(struct bfa_ioc_s *ioc, enum bfa_ioc_aen_event event)
 {
-	union bfa_aen_data_u aen_data;
+	union bfa_aen_data_u  aen_data;
 	struct bfa_log_mod_s *logmod = ioc->logm;
-	s32         inst_num = 0;
-	struct bfa_ioc_attr_s ioc_attr;
+	s32	inst_num = 0;
+	enum bfa_ioc_type_e ioc_type;
 
-	switch (event) {
-	case BFA_IOC_AEN_HBGOOD:
-		bfa_log(logmod, BFA_AEN_IOC_HBGOOD, inst_num);
-		break;
-	case BFA_IOC_AEN_HBFAIL:
-		bfa_log(logmod, BFA_AEN_IOC_HBFAIL, inst_num);
-		break;
-	case BFA_IOC_AEN_ENABLE:
-		bfa_log(logmod, BFA_AEN_IOC_ENABLE, inst_num);
-		break;
-	case BFA_IOC_AEN_DISABLE:
-		bfa_log(logmod, BFA_AEN_IOC_DISABLE, inst_num);
-		break;
-	case BFA_IOC_AEN_FWMISMATCH:
-		bfa_log(logmod, BFA_AEN_IOC_FWMISMATCH, inst_num);
-		break;
-	default:
-		break;
-	}
+	bfa_log(logmod, BFA_LOG_CREATE_ID(BFA_AEN_CAT_IOC, event), inst_num);
 
 	memset(&aen_data.ioc.pwwn, 0, sizeof(aen_data.ioc.pwwn));
 	memset(&aen_data.ioc.mac, 0, sizeof(aen_data.ioc.mac));
-	bfa_ioc_get_attr(ioc, &ioc_attr);
-	switch (ioc_attr.ioc_type) {
+	ioc_type = bfa_ioc_get_type(ioc);
+	switch (ioc_type) {
 	case BFA_IOC_TYPE_FC:
 		aen_data.ioc.pwwn = bfa_ioc_get_pwwn(ioc);
 		break;
@@ -2263,10 +1942,10 @@ bfa_ioc_aen_post(struct bfa_ioc_s *ioc, 
 		aen_data.ioc.mac = bfa_ioc_get_mac(ioc);
 		break;
 	default:
-		bfa_assert(ioc_attr.ioc_type == BFA_IOC_TYPE_FC);
+		bfa_assert(ioc_type == BFA_IOC_TYPE_FC);
 		break;
 	}
-	aen_data.ioc.ioc_type = ioc_attr.ioc_type;
+	aen_data.ioc.ioc_type = ioc_type;
 }
 
 /**
@@ -2275,7 +1954,7 @@ bfa_ioc_aen_post(struct bfa_ioc_s *ioc, 
 bfa_status_t
 bfa_ioc_debug_fwsave(struct bfa_ioc_s *ioc, void *trcdata, int *trclen)
 {
-	int             tlen;
+	int	tlen;
 
 	if (ioc->dbg_fwsave_len == 0)
 		return BFA_STATUS_ENOFSAVE;
@@ -2290,20 +1969,36 @@ bfa_ioc_debug_fwsave(struct bfa_ioc_s *i
 }
 
 /**
+ * Clear saved firmware trace
+ */
+void
+bfa_ioc_debug_fwsave_clear(struct bfa_ioc_s *ioc)
+{
+	ioc->dbg_fwsave_once = BFA_TRUE;
+}
+
+/**
  * Retrieve saved firmware trace from a prior IOC failure.
  */
 bfa_status_t
 bfa_ioc_debug_fwtrc(struct bfa_ioc_s *ioc, void *trcdata, int *trclen)
 {
-	u32        pgnum;
-	u32        loff = BFA_DBG_FWTRC_OFF(bfa_ioc_portid(ioc));
-	int             i, tlen;
-	u32       *tbuf = trcdata, r32;
+	u32 pgnum;
+	u32 loff = BFA_DBG_FWTRC_OFF(bfa_ioc_portid(ioc));
+	int i, tlen;
+	u32 *tbuf = trcdata, r32;
 
 	bfa_trc(ioc, *trclen);
 
 	pgnum = bfa_ioc_smem_pgnum(ioc, loff);
 	loff = bfa_ioc_smem_pgoff(ioc, loff);
+
+	/*
+	 *  Hold semaphore to serialize pll init and fwtrc.
+	 */
+	if (BFA_FALSE == bfa_ioc_sem_get(ioc->ioc_regs.ioc_init_sem_reg))
+		return BFA_STATUS_FAILED;
+
 	bfa_reg_write(ioc->ioc_regs.host_page_num_fn, pgnum);
 
 	tlen = *trclen;
@@ -2324,11 +2019,18 @@ bfa_ioc_debug_fwtrc(struct bfa_ioc_s *io
 		loff = PSS_SMEM_PGOFF(loff);
 		if (loff == 0) {
 			pgnum++;
-			bfa_reg_write(ioc->ioc_regs.host_page_num_fn, pgnum);
+			bfa_reg_write(ioc->ioc_regs.host_page_num_fn,
+				      pgnum);
 		}
 	}
 	bfa_reg_write(ioc->ioc_regs.host_page_num_fn,
 		      bfa_ioc_smem_pgnum(ioc, 0));
+
+	/*
+	 *  release semaphore.
+	 */
+	bfa_ioc_sem_release(ioc->ioc_regs.ioc_init_sem_reg);
+
 	bfa_trc(ioc, pgnum);
 
 	*trclen = tlen * sizeof(u32);
@@ -2341,7 +2043,7 @@ bfa_ioc_debug_fwtrc(struct bfa_ioc_s *io
 static void
 bfa_ioc_debug_save(struct bfa_ioc_s *ioc)
 {
-	int             tlen;
+	int		tlen;
 
 	if (ioc->dbg_fwsave_len) {
 		tlen = ioc->dbg_fwsave_len;
@@ -2368,8 +2070,7 @@ bfa_ioc_recover(struct bfa_ioc_s *ioc)
 
 static void
 bfa_ioc_aen_post(struct bfa_ioc_s *ioc, enum bfa_ioc_aen_event event)
-{
-}
+{ }
 
 static void
 bfa_ioc_recover(struct bfa_ioc_s *ioc)
diff -uprN a/drivers/scsi/bfa/bfa_ioc.h b/drivers/scsi/bfa/bfa_ioc.h
--- a/drivers/scsi/bfa/bfa_ioc.h	2009-12-18 18:16:22.463689000 -0800
+++ b/drivers/scsi/bfa/bfa_ioc.h	2009-11-25 18:06:50.000000000 -0800
@@ -28,8 +28,8 @@
  * PCI device information required by IOC
  */
 struct bfa_pcidev_s {
-	int             pci_slot;
-	u8         pci_func;
+	int		pci_slot;
+	u8		pci_func;
 	u16	device_id;
 	bfa_os_addr_t   pci_bar_kva;
 };
@@ -39,8 +39,8 @@ struct bfa_pcidev_s {
  * Address
  */
 struct bfa_dma_s {
-	void		*kva;	/*! Kernel virtual address	*/
-	u64	pa;	/*! Physical address		*/
+	void		*kva;	/* ! Kernel virtual address	*/
+	u64	pa;	/* ! Physical address		*/
 };
 
 #define BFA_DMA_ALIGN_SZ	256
@@ -74,15 +74,18 @@ struct bfa_ioc_regs_s {
 	bfa_os_addr_t   lpu_mbox_cmd;
 	bfa_os_addr_t   lpu_mbox;
 	bfa_os_addr_t   pss_ctl_reg;
+	bfa_os_addr_t   pss_err_status_reg;
 	bfa_os_addr_t   app_pll_fast_ctl_reg;
 	bfa_os_addr_t   app_pll_slow_ctl_reg;
 	bfa_os_addr_t   ioc_sem_reg;
 	bfa_os_addr_t   ioc_usage_sem_reg;
+	bfa_os_addr_t   ioc_init_sem_reg;
 	bfa_os_addr_t   ioc_usage_reg;
 	bfa_os_addr_t   host_page_num_fn;
 	bfa_os_addr_t   heartbeat;
 	bfa_os_addr_t   ioc_fwstate;
 	bfa_os_addr_t   ll_halt;
+	bfa_os_addr_t   err_set;
 	bfa_os_addr_t   shirq_isr_next;
 	bfa_os_addr_t   shirq_msk_next;
 	bfa_os_addr_t   smem_page_start;
@@ -98,7 +101,7 @@ struct bfa_ioc_regs_s {
  * IOC Mailbox structures
  */
 struct bfa_mbox_cmd_s {
-	struct list_head		qe;
+	struct list_head	qe;
 	u32	msg[BFI_IOC_MSGSZ];
 };
 
@@ -107,8 +110,8 @@ struct bfa_mbox_cmd_s {
  */
 typedef void (*bfa_ioc_mbox_mcfunc_t)(void *cbarg, struct bfi_mbmsg_s *m);
 struct bfa_ioc_mbox_mod_s {
-	struct list_head	cmd_q;		/*  pending mbox queue	*/
-	int		nmclass;	/*  number of handlers */
+	struct list_head		cmd_q;	/*  pending mbox queue	*/
+	int			nmclass;	/*  number of handlers */
 	struct {
 		bfa_ioc_mbox_mcfunc_t	cbfn;	/*  message handlers	*/
 		void			*cbarg;
@@ -154,7 +157,6 @@ struct bfa_ioc_s {
 	struct bfa_timer_s 	ioc_timer;
 	struct bfa_timer_s 	sem_timer;
 	u32		hb_count;
-	u32		hb_fail;
 	u32		retry_count;
 	struct list_head		hb_notify_q;
 	void			*dbg_fwsave;
@@ -177,20 +179,45 @@ struct bfa_ioc_s {
 	struct bfi_ioc_attr_s	*attr;
 	struct bfa_ioc_cbfn_s	*cbfn;
 	struct bfa_ioc_mbox_mod_s mbox_mod;
+	struct bfa_ioc_hwif_s	*ioc_hwif;
+};
+
+struct bfa_ioc_hwif_s {
+	bfa_status_t	(*ioc_pll_init)	(struct bfa_ioc_s *ioc);
+	bfa_boolean_t	(*ioc_firmware_lock)	(struct bfa_ioc_s *ioc);
+	void		(*ioc_firmware_unlock)	(struct bfa_ioc_s *ioc);
+	u32 *	(*ioc_fwimg_get_chunk)	(struct bfa_ioc_s *ioc,
+						u32 off);
+	u32	(*ioc_fwimg_get_size)	(struct bfa_ioc_s *ioc);
+	void		(*ioc_reg_init)	(struct bfa_ioc_s *ioc);
+	void		(*ioc_map_port)	(struct bfa_ioc_s *ioc);
+	void		(*ioc_isr_mode_set)	(struct bfa_ioc_s *ioc,
+					bfa_boolean_t msix);
+	void		(*ioc_notify_hbfail)	(struct bfa_ioc_s *ioc);
+	void		(*ioc_ownership_reset)	(struct bfa_ioc_s *ioc);
 };
 
-#define bfa_ioc_pcifn(__ioc)		(__ioc)->pcidev.pci_func
-#define bfa_ioc_devid(__ioc)		(__ioc)->pcidev.device_id
-#define bfa_ioc_bar0(__ioc)		(__ioc)->pcidev.pci_bar_kva
+#define bfa_ioc_pcifn(__ioc)		((__ioc)->pcidev.pci_func)
+#define bfa_ioc_devid(__ioc)		((__ioc)->pcidev.device_id)
+#define bfa_ioc_bar0(__ioc)		((__ioc)->pcidev.pci_bar_kva)
 #define bfa_ioc_portid(__ioc)		((__ioc)->port_id)
 #define bfa_ioc_fetch_stats(__ioc, __stats) \
-		((__stats)->drv_stats) = (__ioc)->stats
+		(((__stats)->drv_stats) = (__ioc)->stats)
 #define bfa_ioc_clr_stats(__ioc)	\
 		bfa_os_memset(&(__ioc)->stats, 0, sizeof((__ioc)->stats))
-#define bfa_ioc_maxfrsize(__ioc)	(__ioc)->attr->maxfrsize
-#define bfa_ioc_rx_bbcredit(__ioc)	(__ioc)->attr->rx_bbcredit
+#define bfa_ioc_maxfrsize(__ioc)	((__ioc)->attr->maxfrsize)
+#define bfa_ioc_rx_bbcredit(__ioc)	((__ioc)->attr->rx_bbcredit)
 #define bfa_ioc_speed_sup(__ioc)	\
 	BFI_ADAPTER_GETP(SPEED, (__ioc)->attr->adapter_prop)
+#define bfa_ioc_get_nports(__ioc)	\
+	BFI_ADAPTER_GETP(NPORTS, (__ioc)->attr->adapter_prop)
+
+#define bfa_ioc_stats(_ioc, _stats)	((_ioc)->stats._stats++)
+#define BFA_IOC_FWIMG_MINSZ	(16 * 1024)
+
+#define BFA_IOC_FLASH_CHUNK_NO(off)		(off / BFI_FLASH_CHUNK_SZ_WORDS)
+#define BFA_IOC_FLASH_OFFSET_IN_CHUNK(off)	(off % BFI_FLASH_CHUNK_SZ_WORDS)
+#define BFA_IOC_FLASH_CHUNK_ADDR(chunkno)  (chunkno * BFI_FLASH_CHUNK_SZ_WORDS)
 
 /**
  * IOC mailbox interface
@@ -207,6 +234,17 @@ void bfa_ioc_mbox_regisr(struct bfa_ioc_
 /**
  * IOC interfaces
  */
+
+#define bfa_ioc_pll_init(__ioc) ((__ioc)->ioc_hwif->ioc_pll_init(__ioc))
+#define	bfa_ioc_isr_mode_set(__ioc, __msix)			\
+			((__ioc)->ioc_hwif->ioc_isr_mode_set(__ioc, __msix))
+#define	bfa_ioc_ownership_reset(__ioc)				\
+			((__ioc)->ioc_hwif->ioc_ownership_reset(__ioc))
+
+
+void bfa_ioc_set_ct_hwif(struct bfa_ioc_s *ioc);
+void bfa_ioc_set_cb_hwif(struct bfa_ioc_s *ioc);
+
 void bfa_ioc_attach(struct bfa_ioc_s *ioc, void *bfa,
 		struct bfa_ioc_cbfn_s *cbfn, struct bfa_timer_mod_s *timer_mod,
 		struct bfa_trc_mod_s *trcmod,
@@ -220,16 +258,25 @@ void bfa_ioc_enable(struct bfa_ioc_s *io
 void bfa_ioc_disable(struct bfa_ioc_s *ioc);
 bfa_boolean_t bfa_ioc_intx_claim(struct bfa_ioc_s *ioc);
 
-void bfa_ioc_boot(struct bfa_ioc_s *ioc, u32 boot_type, u32 boot_param);
+void bfa_ioc_boot(struct bfa_ioc_s *ioc, u32 boot_type,
+		u32 boot_param);
 void bfa_ioc_isr(struct bfa_ioc_s *ioc, struct bfi_mbmsg_s *msg);
 void bfa_ioc_error_isr(struct bfa_ioc_s *ioc);
-void bfa_ioc_isr_mode_set(struct bfa_ioc_s *ioc, bfa_boolean_t intx);
-bfa_status_t bfa_ioc_pll_init(struct bfa_ioc_s *ioc);
 bfa_boolean_t bfa_ioc_is_operational(struct bfa_ioc_s *ioc);
 bfa_boolean_t bfa_ioc_is_disabled(struct bfa_ioc_s *ioc);
 bfa_boolean_t bfa_ioc_fw_mismatch(struct bfa_ioc_s *ioc);
 bfa_boolean_t bfa_ioc_adapter_is_disabled(struct bfa_ioc_s *ioc);
 void bfa_ioc_cfg_complete(struct bfa_ioc_s *ioc);
+enum bfa_ioc_type_e bfa_ioc_get_type(struct bfa_ioc_s *ioc);
+void bfa_ioc_get_adapter_serial_num(struct bfa_ioc_s *ioc, char *serial_num);
+void bfa_ioc_get_adapter_fw_ver(struct bfa_ioc_s *ioc, char *fw_ver);
+void bfa_ioc_get_adapter_optrom_ver(struct bfa_ioc_s *ioc, char *optrom_ver);
+void bfa_ioc_get_adapter_model(struct bfa_ioc_s *ioc, char *model);
+void bfa_ioc_get_adapter_manufacturer(struct bfa_ioc_s *ioc,
+		char *manufacturer);
+void bfa_ioc_get_pci_chip_rev(struct bfa_ioc_s *ioc, char *chip_rev);
+enum bfa_ioc_state bfa_ioc_get_state(struct bfa_ioc_s *ioc);
+
 void bfa_ioc_get_attr(struct bfa_ioc_s *ioc, struct bfa_ioc_attr_s *ioc_attr);
 void bfa_ioc_get_adapter_attr(struct bfa_ioc_s *ioc,
 		struct bfa_adapter_attr_s *ad_attr);
@@ -237,6 +284,7 @@ int bfa_ioc_debug_trcsz(bfa_boolean_t au
 void bfa_ioc_debug_memclaim(struct bfa_ioc_s *ioc, void *dbg_fwsave);
 bfa_status_t bfa_ioc_debug_fwsave(struct bfa_ioc_s *ioc, void *trcdata,
 		int *trclen);
+void bfa_ioc_debug_fwsave_clear(struct bfa_ioc_s *ioc);
 bfa_status_t bfa_ioc_debug_fwtrc(struct bfa_ioc_s *ioc, void *trcdata,
 				 int *trclen);
 u32 bfa_ioc_smem_pgnum(struct bfa_ioc_s *ioc, u32 fmaddr);
@@ -245,6 +293,13 @@ void bfa_ioc_set_fcmode(struct bfa_ioc_s
 bfa_boolean_t bfa_ioc_get_fcmode(struct bfa_ioc_s *ioc);
 void bfa_ioc_hbfail_register(struct bfa_ioc_s *ioc,
 	struct bfa_ioc_hbfail_notify_s *notify);
+bfa_boolean_t bfa_ioc_sem_get(bfa_os_addr_t sem_reg);
+void bfa_ioc_sem_release(bfa_os_addr_t sem_reg);
+void bfa_ioc_hw_sem_release(struct bfa_ioc_s *ioc);
+void bfa_ioc_fwver_get(struct bfa_ioc_s *ioc,
+			struct bfi_ioc_image_hdr_s *fwhdr);
+bfa_boolean_t bfa_ioc_fwver_cmp(struct bfa_ioc_s *ioc,
+			struct bfi_ioc_image_hdr_s *fwhdr);
 
 /*
  * bfa mfg wwn API functions
@@ -252,8 +307,7 @@ void bfa_ioc_hbfail_register(struct bfa_
 wwn_t bfa_ioc_get_pwwn(struct bfa_ioc_s *ioc);
 wwn_t bfa_ioc_get_nwwn(struct bfa_ioc_s *ioc);
 wwn_t bfa_ioc_get_wwn_naa5(struct bfa_ioc_s *ioc, u16 inst);
-mac_t bfa_ioc_get_mac(struct bfa_ioc_s *ioc);
+struct mac_s bfa_ioc_get_mac(struct bfa_ioc_s *ioc);
 u64 bfa_ioc_get_adid(struct bfa_ioc_s *ioc);
 
 #endif /* __BFA_IOC_H__ */
-
diff -uprN a/drivers/scsi/bfa/bfa_ioc_cb.c b/drivers/scsi/bfa/bfa_ioc_cb.c
--- a/drivers/scsi/bfa/bfa_ioc_cb.c	1969-12-31 16:00:00.000000000 -0800
+++ b/drivers/scsi/bfa/bfa_ioc_cb.c	2009-11-25 18:21:07.000000000 -0800
@@ -0,0 +1,281 @@
+/*
+ * Copyright (c) 2005-2009 Brocade Communications Systems, Inc.
+ * All rights reserved
+ * www.brocade.com
+ *
+ * Linux driver for Brocade Fibre Channel Host Bus Adapter.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License (GPL) Version 2 as
+ * published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+#include <bfa.h>
+#include <bfa_ioc.h>
+#include <bfa_fwimg_priv.h>
+#include <cna/bfa_cna_trcmod.h>
+#include <cs/bfa_debug.h>
+#include <bfi/bfi_ioc.h>
+#include <bfi/bfi_cbreg.h>
+#include <log/bfa_log_hal.h>
+#include <defs/bfa_defs_pci.h>
+
+BFA_TRC_FILE(CNA, IOC_CB);
+
+/*
+ * forward declarations
+ */
+static bfa_status_t bfa_ioc_cb_pll_init(struct bfa_ioc_s *ioc);
+static bfa_boolean_t bfa_ioc_cb_firmware_lock(struct bfa_ioc_s *ioc);
+static void bfa_ioc_cb_firmware_unlock(struct bfa_ioc_s *ioc);
+static u32  *bfa_ioc_cb_fwimg_get_chunk(struct bfa_ioc_s *ioc,
+						u32 off);
+static u32 bfa_ioc_cb_fwimg_get_size(struct bfa_ioc_s *ioc);
+static void bfa_ioc_cb_reg_init(struct bfa_ioc_s *ioc);
+static void bfa_ioc_cb_map_port(struct bfa_ioc_s *ioc);
+static void bfa_ioc_cb_isr_mode_set(struct bfa_ioc_s *ioc, bfa_boolean_t msix);
+static void bfa_ioc_cb_notify_hbfail(struct bfa_ioc_s *ioc);
+static void bfa_ioc_cb_ownership_reset(struct bfa_ioc_s *ioc);
+
+static struct bfa_ioc_hwif_s hwif_cb = {
+	bfa_ioc_cb_pll_init,
+	bfa_ioc_cb_firmware_lock,
+	bfa_ioc_cb_firmware_unlock,
+	bfa_ioc_cb_fwimg_get_chunk,
+	bfa_ioc_cb_fwimg_get_size,
+	bfa_ioc_cb_reg_init,
+	bfa_ioc_cb_map_port,
+	bfa_ioc_cb_isr_mode_set,
+	bfa_ioc_cb_notify_hbfail,
+	bfa_ioc_cb_ownership_reset,
+};
+
+/**
+ * Called from bfa_ioc_attach() to map asic specific calls.
+ */
+void
+bfa_ioc_set_cb_hwif(struct bfa_ioc_s *ioc)
+{
+	ioc->ioc_hwif = &hwif_cb;
+}
+
+static u32 *
+bfa_ioc_cb_fwimg_get_chunk(struct bfa_ioc_s *ioc, u32 off)
+{
+	return bfi_image_cb_get_chunk(off);
+}
+
+static u32
+bfa_ioc_cb_fwimg_get_size(struct bfa_ioc_s *ioc)
+{
+	return bfi_image_cb_size;
+}
+
+/**
+ * Return true if firmware of current driver matches the running firmware.
+ */
+static bfa_boolean_t
+bfa_ioc_cb_firmware_lock(struct bfa_ioc_s *ioc)
+{
+	return BFA_TRUE;
+}
+
+static void
+bfa_ioc_cb_firmware_unlock(struct bfa_ioc_s *ioc)
+{
+}
+
+/**
+ * Notify other functions on HB failure.
+ */
+static void
+bfa_ioc_cb_notify_hbfail(struct bfa_ioc_s *ioc)
+{
+
+	bfa_reg_write(ioc->ioc_regs.err_set, __PSS_ERR_STATUS_SET);
+	bfa_reg_read(ioc->ioc_regs.err_set);
+}
+
+/**
+ * Host to LPU mailbox message addresses
+ */
+static struct { u32 hfn_mbox, lpu_mbox, hfn_pgn; } iocreg_fnreg[] = {
+	{ HOSTFN0_LPU_MBOX0_0, LPU_HOSTFN0_MBOX0_0, HOST_PAGE_NUM_FN0 },
+	{ HOSTFN1_LPU_MBOX0_8, LPU_HOSTFN1_MBOX0_8, HOST_PAGE_NUM_FN1 }
+};
+
+/**
+ * Host <-> LPU mailbox command/status registers
+ */
+static struct { u32 hfn, lpu; } iocreg_mbcmd[] = {
+
+	{ HOSTFN0_LPU0_CMD_STAT, LPU0_HOSTFN0_CMD_STAT },
+	{ HOSTFN1_LPU1_CMD_STAT, LPU1_HOSTFN1_CMD_STAT }
+};
+
+static void
+bfa_ioc_cb_reg_init(struct bfa_ioc_s *ioc)
+{
+	bfa_os_addr_t	rb;
+	int		pcifn = bfa_ioc_pcifn(ioc);
+
+	rb = bfa_ioc_bar0(ioc);
+
+	ioc->ioc_regs.hfn_mbox = rb + iocreg_fnreg[pcifn].hfn_mbox;
+	ioc->ioc_regs.lpu_mbox = rb + iocreg_fnreg[pcifn].lpu_mbox;
+	ioc->ioc_regs.host_page_num_fn = rb + iocreg_fnreg[pcifn].hfn_pgn;
+
+	if (ioc->port_id == 0) {
+		ioc->ioc_regs.heartbeat = rb + BFA_IOC0_HBEAT_REG;
+		ioc->ioc_regs.ioc_fwstate = rb + BFA_IOC0_STATE_REG;
+	} else {
+		ioc->ioc_regs.heartbeat = (rb + BFA_IOC1_HBEAT_REG);
+		ioc->ioc_regs.ioc_fwstate = (rb + BFA_IOC1_STATE_REG);
+	}
+
+	/**
+	 * Host <-> LPU mailbox command/status registers
+	 */
+	ioc->ioc_regs.hfn_mbox_cmd = rb + iocreg_mbcmd[pcifn].hfn;
+	ioc->ioc_regs.lpu_mbox_cmd = rb + iocreg_mbcmd[pcifn].lpu;
+
+	/*
+	 * PSS control registers
+	 */
+	ioc->ioc_regs.pss_ctl_reg = (rb + PSS_CTL_REG);
+	ioc->ioc_regs.pss_err_status_reg = (rb + PSS_ERR_STATUS_REG);
+	ioc->ioc_regs.app_pll_fast_ctl_reg = (rb + APP_PLL_400_CTL_REG);
+	ioc->ioc_regs.app_pll_slow_ctl_reg = (rb + APP_PLL_212_CTL_REG);
+
+	/*
+	 * IOC semaphore registers and serialization
+	 */
+	ioc->ioc_regs.ioc_sem_reg = (rb + HOST_SEM0_REG);
+	ioc->ioc_regs.ioc_init_sem_reg = (rb + HOST_SEM2_REG);
+
+	/**
+	 * sram memory access
+	 */
+	ioc->ioc_regs.smem_page_start = (rb + PSS_SMEM_PAGE_START);
+	ioc->ioc_regs.smem_pg0 = BFI_IOC_SMEM_PG0_CB;
+
+	/*
+	 * err set reg : for notification of hb failure
+	 */
+	ioc->ioc_regs.err_set = (rb + ERR_SET_REG);
+}
+
+/**
+ * Initialize IOC to port mapping.
+ */
+
+static void
+bfa_ioc_cb_map_port(struct bfa_ioc_s *ioc)
+{
+	/**
+	 * For crossbow, port id is same as pci function.
+	 */
+	ioc->port_id = bfa_ioc_pcifn(ioc);
+
+	bfa_trc(ioc, ioc->port_id);
+}
+
+/**
+ * Set interrupt mode for a function: INTX or MSIX
+ */
+static void
+bfa_ioc_cb_isr_mode_set(struct bfa_ioc_s *ioc, bfa_boolean_t msix)
+{
+}
+
+static bfa_status_t
+bfa_ioc_cb_pll_init(struct bfa_ioc_s *ioc)
+{
+	bfa_os_addr_t	rb = ioc->pcidev.pci_bar_kva;
+	u32	pll_sclk, pll_fclk;
+
+	/*
+	 *  Hold semaphore so that nobody can access the chip during init.
+	 */
+	bfa_ioc_sem_get(ioc->ioc_regs.ioc_init_sem_reg);
+
+	pll_sclk = __APP_PLL_212_ENABLE | __APP_PLL_212_LRESETN |
+		__APP_PLL_212_P0_1(3U) |
+		__APP_PLL_212_JITLMT0_1(3U) |
+		__APP_PLL_212_CNTLMT0_1(3U);
+	pll_fclk = __APP_PLL_400_ENABLE | __APP_PLL_400_LRESETN |
+		__APP_PLL_400_RSEL200500 | __APP_PLL_400_P0_1(3U) |
+		__APP_PLL_400_JITLMT0_1(3U) |
+		__APP_PLL_400_CNTLMT0_1(3U);
+
+	bfa_reg_write((rb + BFA_IOC0_STATE_REG), BFI_IOC_UNINIT);
+	bfa_reg_write((rb + BFA_IOC1_STATE_REG), BFI_IOC_UNINIT);
+
+	bfa_reg_write((rb + HOSTFN0_INT_MSK), 0xffffffffU);
+	bfa_reg_write((rb + HOSTFN1_INT_MSK), 0xffffffffU);
+	bfa_reg_write((rb + HOSTFN0_INT_STATUS), 0xffffffffU);
+	bfa_reg_write((rb + HOSTFN1_INT_STATUS), 0xffffffffU);
+	bfa_reg_write((rb + HOSTFN0_INT_MSK), 0xffffffffU);
+	bfa_reg_write((rb + HOSTFN1_INT_MSK), 0xffffffffU);
+
+	bfa_reg_write(ioc->ioc_regs.app_pll_slow_ctl_reg,
+		      __APP_PLL_212_LOGIC_SOFT_RESET);
+	bfa_reg_write(ioc->ioc_regs.app_pll_slow_ctl_reg,
+		      __APP_PLL_212_BYPASS |
+		      __APP_PLL_212_LOGIC_SOFT_RESET);
+	bfa_reg_write(ioc->ioc_regs.app_pll_fast_ctl_reg,
+		      __APP_PLL_400_LOGIC_SOFT_RESET);
+	bfa_reg_write(ioc->ioc_regs.app_pll_fast_ctl_reg,
+		      __APP_PLL_400_BYPASS |
+		      __APP_PLL_400_LOGIC_SOFT_RESET);
+	bfa_os_udelay(2);
+	bfa_reg_write(ioc->ioc_regs.app_pll_slow_ctl_reg,
+		      __APP_PLL_212_LOGIC_SOFT_RESET);
+	bfa_reg_write(ioc->ioc_regs.app_pll_fast_ctl_reg,
+		      __APP_PLL_400_LOGIC_SOFT_RESET);
+
+	bfa_reg_write(ioc->ioc_regs.app_pll_slow_ctl_reg,
+		      pll_sclk | __APP_PLL_212_LOGIC_SOFT_RESET);
+	bfa_reg_write(ioc->ioc_regs.app_pll_fast_ctl_reg,
+		      pll_fclk | __APP_PLL_400_LOGIC_SOFT_RESET);
+
+	/**
+	 * Wait for PLLs to lock.
+	 */
+	bfa_os_udelay(2000);
+	bfa_reg_write((rb + HOSTFN0_INT_STATUS), 0xffffffffU);
+	bfa_reg_write((rb + HOSTFN1_INT_STATUS), 0xffffffffU);
+
+	bfa_reg_write(ioc->ioc_regs.app_pll_slow_ctl_reg, pll_sclk);
+	bfa_reg_write(ioc->ioc_regs.app_pll_fast_ctl_reg, pll_fclk);
+
+	/*
+	 *  release semaphore.
+	 */
+	bfa_ioc_sem_release(ioc->ioc_regs.ioc_init_sem_reg);
+
+	return BFA_STATUS_OK;
+}
+
+/**
+ * Cleanup hw semaphore and usecnt registers
+ */
+static void
+bfa_ioc_cb_ownership_reset(struct bfa_ioc_s *ioc)
+{
+
+	/*
+	 * Read the hw sem reg to make sure that it is locked
+	 * before we clear it. If it is not locked, writing 1
+	 * will lock it instead of clearing it.
+	 */
+	bfa_reg_read(ioc->ioc_regs.ioc_sem_reg);
+	bfa_ioc_hw_sem_release(ioc);
+}
+
+
diff -uprN a/drivers/scsi/bfa/bfa_ioc_ct.c b/drivers/scsi/bfa/bfa_ioc_ct.c
--- a/drivers/scsi/bfa/bfa_ioc_ct.c	1969-12-31 16:00:00.000000000 -0800
+++ b/drivers/scsi/bfa/bfa_ioc_ct.c	2009-11-25 18:21:07.000000000 -0800
@@ -0,0 +1,425 @@
+/*
+ * Copyright (c) 2005-2009 Brocade Communications Systems, Inc.
+ * All rights reserved
+ * www.brocade.com
+ *
+ * Linux driver for Brocade Fibre Channel Host Bus Adapter.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License (GPL) Version 2 as
+ * published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+#include <bfa.h>
+#include <bfa_ioc.h>
+#include <bfa_fwimg_priv.h>
+#include <cna/bfa_cna_trcmod.h>
+#include <cs/bfa_debug.h>
+#include <bfi/bfi_ioc.h>
+#include <bfi/bfi_ctreg.h>
+#include <log/bfa_log_hal.h>
+#include <defs/bfa_defs_pci.h>
+
+BFA_TRC_FILE(CNA, IOC_CT);
+
+/*
+ * forward declarations
+ */
+static bfa_status_t bfa_ioc_ct_pll_init(struct bfa_ioc_s *ioc);
+static bfa_boolean_t bfa_ioc_ct_firmware_lock(struct bfa_ioc_s *ioc);
+static void bfa_ioc_ct_firmware_unlock(struct bfa_ioc_s *ioc);
+static u32 *bfa_ioc_ct_fwimg_get_chunk(struct bfa_ioc_s *ioc,
+						u32 off);
+static u32 bfa_ioc_ct_fwimg_get_size(struct bfa_ioc_s *ioc);
+static void bfa_ioc_ct_reg_init(struct bfa_ioc_s *ioc);
+static void bfa_ioc_ct_map_port(struct bfa_ioc_s *ioc);
+static void bfa_ioc_ct_isr_mode_set(struct bfa_ioc_s *ioc, bfa_boolean_t msix);
+static void bfa_ioc_ct_notify_hbfail(struct bfa_ioc_s *ioc);
+static void bfa_ioc_ct_ownership_reset(struct bfa_ioc_s *ioc);
+
+static struct bfa_ioc_hwif_s hwif_ct = {
+	bfa_ioc_ct_pll_init,
+	bfa_ioc_ct_firmware_lock,
+	bfa_ioc_ct_firmware_unlock,
+	bfa_ioc_ct_fwimg_get_chunk,
+	bfa_ioc_ct_fwimg_get_size,
+	bfa_ioc_ct_reg_init,
+	bfa_ioc_ct_map_port,
+	bfa_ioc_ct_isr_mode_set,
+	bfa_ioc_ct_notify_hbfail,
+	bfa_ioc_ct_ownership_reset,
+};
+
+/**
+ * Called from bfa_ioc_attach() to map asic specific calls.
+ */
+void
+bfa_ioc_set_ct_hwif(struct bfa_ioc_s *ioc)
+{
+	ioc->ioc_hwif = &hwif_ct;
+}
+
+static u32 *
+bfa_ioc_ct_fwimg_get_chunk(struct bfa_ioc_s *ioc, u32 off)
+{
+	return bfi_image_ct_get_chunk(off);
+}
+
+static u32
+bfa_ioc_ct_fwimg_get_size(struct bfa_ioc_s *ioc)
+{
+	return bfi_image_ct_size;
+}
+
+/**
+ * Return true if firmware of current driver matches the running firmware.
+ */
+static bfa_boolean_t
+bfa_ioc_ct_firmware_lock(struct bfa_ioc_s *ioc)
+{
+	enum bfi_ioc_state ioc_fwstate;
+	u32 usecnt;
+	struct bfi_ioc_image_hdr_s fwhdr;
+
+	/**
+	 * Firmware match check is relevant only for CNA.
+	 */
+	if (!ioc->cna)
+		return BFA_TRUE;
+
+	/**
+	 * If bios boot (flash based) -- do not increment usage count
+	 */
+	if (bfa_ioc_ct_fwimg_get_size(ioc) < BFA_IOC_FWIMG_MINSZ)
+		return BFA_TRUE;
+
+	bfa_ioc_sem_get(ioc->ioc_regs.ioc_usage_sem_reg);
+	usecnt = bfa_reg_read(ioc->ioc_regs.ioc_usage_reg);
+
+	/**
+	 * If usage count is 0, always return TRUE.
+	 */
+	if (usecnt == 0) {
+		bfa_reg_write(ioc->ioc_regs.ioc_usage_reg, 1);
+		bfa_ioc_sem_release(ioc->ioc_regs.ioc_usage_sem_reg);
+		bfa_trc(ioc, usecnt);
+		return BFA_TRUE;
+	}
+
+	ioc_fwstate = bfa_reg_read(ioc->ioc_regs.ioc_fwstate);
+	bfa_trc(ioc, ioc_fwstate);
+
+	/**
+	 * Use count cannot be non-zero and chip in uninitialized state.
+	 */
+	bfa_assert(ioc_fwstate != BFI_IOC_UNINIT);
+
+	/**
+	 * Check if another driver with a different firmware is active
+	 */
+	bfa_ioc_fwver_get(ioc, &fwhdr);
+	if (!bfa_ioc_fwver_cmp(ioc, &fwhdr)) {
+		bfa_ioc_sem_release(ioc->ioc_regs.ioc_usage_sem_reg);
+		bfa_trc(ioc, usecnt);
+		return BFA_FALSE;
+	}
+
+	/**
+	 * Same firmware version. Increment the reference count.
+	 */
+	usecnt++;
+	bfa_reg_write(ioc->ioc_regs.ioc_usage_reg, usecnt);
+	bfa_ioc_sem_release(ioc->ioc_regs.ioc_usage_sem_reg);
+	bfa_trc(ioc, usecnt);
+	return BFA_TRUE;
+}
+
+static void
+bfa_ioc_ct_firmware_unlock(struct bfa_ioc_s *ioc)
+{
+	u32 usecnt;
+
+	/**
+	 * Firmware lock is relevant only for CNA.
+	 * If bios boot (flash based) -- do not decrement usage count
+	 */
+	if (!ioc->cna || bfa_ioc_ct_fwimg_get_size(ioc) < BFA_IOC_FWIMG_MINSZ)
+		return;
+
+	/**
+	 * decrement usage count
+	 */
+	bfa_ioc_sem_get(ioc->ioc_regs.ioc_usage_sem_reg);
+	usecnt = bfa_reg_read(ioc->ioc_regs.ioc_usage_reg);
+	bfa_assert(usecnt > 0);
+
+	usecnt--;
+	bfa_reg_write(ioc->ioc_regs.ioc_usage_reg, usecnt);
+	bfa_trc(ioc, usecnt);
+
+	bfa_ioc_sem_release(ioc->ioc_regs.ioc_usage_sem_reg);
+}
+
+/**
+ * Notify other functions on HB failure.
+ */
+static void
+bfa_ioc_ct_notify_hbfail(struct bfa_ioc_s *ioc)
+{
+	if (ioc->cna) {
+		bfa_reg_write(ioc->ioc_regs.ll_halt, __FW_INIT_HALT_P);
+		/* Wait for halt to take effect */
+		bfa_reg_read(ioc->ioc_regs.ll_halt);
+	} else {
+		bfa_reg_write(ioc->ioc_regs.err_set, __PSS_ERR_STATUS_SET);
+		bfa_reg_read(ioc->ioc_regs.err_set);
+	}
+}
+
+/**
+ * Host to LPU mailbox message addresses
+ */
+static struct { u32 hfn_mbox, lpu_mbox, hfn_pgn; } iocreg_fnreg[] = {
+	{ HOSTFN0_LPU_MBOX0_0, LPU_HOSTFN0_MBOX0_0, HOST_PAGE_NUM_FN0 },
+	{ HOSTFN1_LPU_MBOX0_8, LPU_HOSTFN1_MBOX0_8, HOST_PAGE_NUM_FN1 },
+	{ HOSTFN2_LPU_MBOX0_0, LPU_HOSTFN2_MBOX0_0, HOST_PAGE_NUM_FN2 },
+	{ HOSTFN3_LPU_MBOX0_8, LPU_HOSTFN3_MBOX0_8, HOST_PAGE_NUM_FN3 }
+};
+
+/**
+ * Host <-> LPU mailbox command/status registers - port 0
+ */
+static struct { u32 hfn, lpu; } iocreg_mbcmd_p0[] = {
+	{ HOSTFN0_LPU0_MBOX0_CMD_STAT, LPU0_HOSTFN0_MBOX0_CMD_STAT },
+	{ HOSTFN1_LPU0_MBOX0_CMD_STAT, LPU0_HOSTFN1_MBOX0_CMD_STAT },
+	{ HOSTFN2_LPU0_MBOX0_CMD_STAT, LPU0_HOSTFN2_MBOX0_CMD_STAT },
+	{ HOSTFN3_LPU0_MBOX0_CMD_STAT, LPU0_HOSTFN3_MBOX0_CMD_STAT }
+};
+
+/**
+ * Host <-> LPU mailbox command/status registers - port 1
+ */
+static struct { u32 hfn, lpu; } iocreg_mbcmd_p1[] = {
+	{ HOSTFN0_LPU1_MBOX0_CMD_STAT, LPU1_HOSTFN0_MBOX0_CMD_STAT },
+	{ HOSTFN1_LPU1_MBOX0_CMD_STAT, LPU1_HOSTFN1_MBOX0_CMD_STAT },
+	{ HOSTFN2_LPU1_MBOX0_CMD_STAT, LPU1_HOSTFN2_MBOX0_CMD_STAT },
+	{ HOSTFN3_LPU1_MBOX0_CMD_STAT, LPU1_HOSTFN3_MBOX0_CMD_STAT }
+};
+
+static void
+bfa_ioc_ct_reg_init(struct bfa_ioc_s *ioc)
+{
+	bfa_os_addr_t	rb;
+	int		pcifn = bfa_ioc_pcifn(ioc);
+
+	rb = bfa_ioc_bar0(ioc);
+
+	ioc->ioc_regs.hfn_mbox = rb + iocreg_fnreg[pcifn].hfn_mbox;
+	ioc->ioc_regs.lpu_mbox = rb + iocreg_fnreg[pcifn].lpu_mbox;
+	ioc->ioc_regs.host_page_num_fn = rb + iocreg_fnreg[pcifn].hfn_pgn;
+
+	if (ioc->port_id == 0) {
+		ioc->ioc_regs.heartbeat = rb + BFA_IOC0_HBEAT_REG;
+		ioc->ioc_regs.ioc_fwstate = rb + BFA_IOC0_STATE_REG;
+		ioc->ioc_regs.hfn_mbox_cmd = rb + iocreg_mbcmd_p0[pcifn].hfn;
+		ioc->ioc_regs.lpu_mbox_cmd = rb + iocreg_mbcmd_p0[pcifn].lpu;
+		ioc->ioc_regs.ll_halt = rb + FW_INIT_HALT_P0;
+	} else {
+		ioc->ioc_regs.heartbeat = (rb + BFA_IOC1_HBEAT_REG);
+		ioc->ioc_regs.ioc_fwstate = (rb + BFA_IOC1_STATE_REG);
+		ioc->ioc_regs.hfn_mbox_cmd = rb + iocreg_mbcmd_p1[pcifn].hfn;
+		ioc->ioc_regs.lpu_mbox_cmd = rb + iocreg_mbcmd_p1[pcifn].lpu;
+		ioc->ioc_regs.ll_halt = rb + FW_INIT_HALT_P1;
+	}
+
+	/*
+	 * PSS control registers
+	 */
+	ioc->ioc_regs.pss_ctl_reg = (rb + PSS_CTL_REG);
+	ioc->ioc_regs.pss_err_status_reg = (rb + PSS_ERR_STATUS_REG);
+	ioc->ioc_regs.app_pll_fast_ctl_reg = (rb + APP_PLL_425_CTL_REG);
+	ioc->ioc_regs.app_pll_slow_ctl_reg = (rb + APP_PLL_312_CTL_REG);
+
+	/*
+	 * IOC semaphore registers and serialization
+	 */
+	ioc->ioc_regs.ioc_sem_reg = (rb + HOST_SEM0_REG);
+	ioc->ioc_regs.ioc_usage_sem_reg = (rb + HOST_SEM1_REG);
+	ioc->ioc_regs.ioc_init_sem_reg = (rb + HOST_SEM2_REG);
+	ioc->ioc_regs.ioc_usage_reg = (rb + BFA_FW_USE_COUNT);
+
+	/**
+	 * sram memory access
+	 */
+	ioc->ioc_regs.smem_page_start = (rb + PSS_SMEM_PAGE_START);
+	ioc->ioc_regs.smem_pg0 = BFI_IOC_SMEM_PG0_CT;
+
+	/*
+	 * err set reg : for notification of hb failure in fcmode
+	 */
+	ioc->ioc_regs.err_set = (rb + ERR_SET_REG);
+}
+
+/**
+ * Initialize IOC to port mapping.
+ */
+
+#define FNC_PERS_FN_SHIFT(__fn)	((__fn) * 8)
+static void
+bfa_ioc_ct_map_port(struct bfa_ioc_s *ioc)
+{
+	bfa_os_addr_t	rb = ioc->pcidev.pci_bar_kva;
+	u32	r32;
+
+	/**
+	 * For catapult, base port id on personality register and IOC type
+	 */
+	r32 = bfa_reg_read(rb + FNC_PERS_REG);
+	r32 >>= FNC_PERS_FN_SHIFT(bfa_ioc_pcifn(ioc));
+	ioc->port_id = (r32 & __F0_PORT_MAP_MK) >> __F0_PORT_MAP_SH;
+
+	bfa_trc(ioc, bfa_ioc_pcifn(ioc));
+	bfa_trc(ioc, ioc->port_id);
+}
+
+/**
+ * Set interrupt mode for a function: INTX or MSIX
+ */
+static void
+bfa_ioc_ct_isr_mode_set(struct bfa_ioc_s *ioc, bfa_boolean_t msix)
+{
+	bfa_os_addr_t	rb = ioc->pcidev.pci_bar_kva;
+	u32	r32, mode;
+
+	r32 = bfa_reg_read(rb + FNC_PERS_REG);
+	bfa_trc(ioc, r32);
+
+	mode = (r32 >> FNC_PERS_FN_SHIFT(bfa_ioc_pcifn(ioc))) &
+		__F0_INTX_STATUS;
+
+	/**
+	 * If already in desired mode, do not change anything
+	 */
+	if (!msix && mode)
+		return;
+
+	if (msix)
+		mode = __F0_INTX_STATUS_MSIX;
+	else
+		mode = __F0_INTX_STATUS_INTA;
+
+	r32 &= ~(__F0_INTX_STATUS << FNC_PERS_FN_SHIFT(bfa_ioc_pcifn(ioc)));
+	r32 |= (mode << FNC_PERS_FN_SHIFT(bfa_ioc_pcifn(ioc)));
+	bfa_trc(ioc, r32);
+
+	bfa_reg_write(rb + FNC_PERS_REG, r32);
+}
+
+static bfa_status_t
+bfa_ioc_ct_pll_init(struct bfa_ioc_s *ioc)
+{
+	bfa_os_addr_t	rb = ioc->pcidev.pci_bar_kva;
+	u32	pll_sclk, pll_fclk, r32;
+
+	/*
+	 *  Hold semaphore so that nobody can access the chip during init.
+	 */
+	bfa_ioc_sem_get(ioc->ioc_regs.ioc_init_sem_reg);
+
+	pll_sclk = __APP_PLL_312_LRESETN | __APP_PLL_312_ENARST |
+		__APP_PLL_312_RSEL200500 | __APP_PLL_312_P0_1(3U) |
+		__APP_PLL_312_JITLMT0_1(3U) |
+		__APP_PLL_312_CNTLMT0_1(1U);
+	pll_fclk = __APP_PLL_425_LRESETN | __APP_PLL_425_ENARST |
+		__APP_PLL_425_RSEL200500 | __APP_PLL_425_P0_1(3U) |
+		__APP_PLL_425_JITLMT0_1(3U) |
+		__APP_PLL_425_CNTLMT0_1(1U);
+
+	/**
+	 *	For catapult, choose operational mode FC/FCoE
+	 */
+	if (ioc->fcmode) {
+		bfa_reg_write((rb + OP_MODE), 0);
+		bfa_reg_write((rb + ETH_MAC_SER_REG),
+			      __APP_EMS_CMLCKSEL |
+			      __APP_EMS_REFCKBUFEN2 |
+			      __APP_EMS_CHANNEL_SEL);
+	} else {
+		ioc->pllinit = BFA_TRUE;
+		bfa_reg_write((rb + OP_MODE), __GLOBAL_FCOE_MODE);
+		bfa_reg_write((rb + ETH_MAC_SER_REG),
+			      __APP_EMS_REFCKBUFEN1);
+	}
+
+	bfa_reg_write((rb + BFA_IOC0_STATE_REG), BFI_IOC_UNINIT);
+	bfa_reg_write((rb + BFA_IOC1_STATE_REG), BFI_IOC_UNINIT);
+
+	bfa_reg_write((rb + HOSTFN0_INT_MSK), 0xffffffffU);
+	bfa_reg_write((rb + HOSTFN1_INT_MSK), 0xffffffffU);
+	bfa_reg_write((rb + HOSTFN0_INT_STATUS), 0xffffffffU);
+	bfa_reg_write((rb + HOSTFN1_INT_STATUS), 0xffffffffU);
+	bfa_reg_write((rb + HOSTFN0_INT_MSK), 0xffffffffU);
+	bfa_reg_write((rb + HOSTFN1_INT_MSK), 0xffffffffU);
+
+	bfa_reg_write(ioc->ioc_regs.app_pll_slow_ctl_reg, pll_sclk |
+		__APP_PLL_312_LOGIC_SOFT_RESET);
+	bfa_reg_write(ioc->ioc_regs.app_pll_fast_ctl_reg, pll_fclk |
+		__APP_PLL_425_LOGIC_SOFT_RESET);
+	bfa_reg_write(ioc->ioc_regs.app_pll_slow_ctl_reg, pll_sclk |
+		__APP_PLL_312_LOGIC_SOFT_RESET | __APP_PLL_312_ENABLE);
+	bfa_reg_write(ioc->ioc_regs.app_pll_fast_ctl_reg, pll_fclk |
+		__APP_PLL_425_LOGIC_SOFT_RESET | __APP_PLL_425_ENABLE);
+
+	/**
+	 * Wait for PLLs to lock.
+	 */
+	bfa_reg_read(rb + HOSTFN0_INT_MSK);
+	bfa_os_udelay(2000);
+	bfa_reg_write((rb + HOSTFN0_INT_STATUS), 0xffffffffU);
+	bfa_reg_write((rb + HOSTFN1_INT_STATUS), 0xffffffffU);
+
+	bfa_reg_write(ioc->ioc_regs.app_pll_slow_ctl_reg, pll_sclk |
+		__APP_PLL_312_ENABLE);
+	bfa_reg_write(ioc->ioc_regs.app_pll_fast_ctl_reg, pll_fclk |
+		__APP_PLL_425_ENABLE);
+
+	bfa_reg_write((rb + MBIST_CTL_REG), __EDRAM_BISTR_START);
+	bfa_os_udelay(1000);
+	r32 = bfa_reg_read((rb + MBIST_STAT_REG));
+	bfa_trc(ioc, r32);
+	/*
+	 *  release semaphore.
+	 */
+	bfa_ioc_sem_release(ioc->ioc_regs.ioc_init_sem_reg);
+
+	return BFA_STATUS_OK;
+}
+
+/**
+ * Cleanup hw semaphore and usecnt registers
+ */
+static void
+bfa_ioc_ct_ownership_reset(struct bfa_ioc_s *ioc)
+{
+
+	if (ioc->cna) {
+		bfa_ioc_sem_get(ioc->ioc_regs.ioc_usage_sem_reg);
+		bfa_reg_write(ioc->ioc_regs.ioc_usage_reg, 0);
+		bfa_ioc_sem_release(ioc->ioc_regs.ioc_usage_sem_reg);
+	}
+
+	/*
+	 * Read the hw sem reg to make sure that it is locked
+	 * before we clear it. If it is not locked, writing 1
+	 * will lock it instead of clearing it.
+	 */
+	bfa_reg_read(ioc->ioc_regs.ioc_sem_reg);
+	bfa_ioc_hw_sem_release(ioc);
+}
+
+
diff -uprN a/drivers/scsi/bfa/bfa_iocfc.c b/drivers/scsi/bfa/bfa_iocfc.c
--- a/drivers/scsi/bfa/bfa_iocfc.c	2009-12-18 18:16:22.461686000 -0800
+++ b/drivers/scsi/bfa/bfa_iocfc.c	2009-11-25 18:21:07.000000000 -0800
@@ -49,7 +49,7 @@ static void bfa_iocfc_hbfail_cbfn(void *
 static void bfa_iocfc_reset_cbfn(void *bfa_arg);
 static void bfa_iocfc_stats_clear(void *bfa_arg);
 static void bfa_iocfc_stats_swap(struct bfa_fw_stats_s *d,
-			struct bfa_fw_stats_s *s);
+				 struct bfa_fw_stats_s *s);
 static void bfa_iocfc_stats_clr_cb(void *bfa_arg, bfa_boolean_t complete);
 static void bfa_iocfc_stats_clr_timeout(void *bfa_arg);
 static void bfa_iocfc_stats_cb(void *bfa_arg, bfa_boolean_t complete);
@@ -64,12 +64,12 @@ static struct bfa_ioc_cbfn_s bfa_iocfc_c
 static void
 bfa_iocfc_cqs_sz(struct bfa_iocfc_cfg_s *cfg, u32 *dm_len)
 {
-	int             i, per_reqq_sz, per_rspq_sz;
+	int		i, per_reqq_sz, per_rspq_sz;
 
 	per_reqq_sz = BFA_ROUNDUP((cfg->drvcfg.num_reqq_elems * BFI_LMSG_SZ),
-							BFA_DMA_ALIGN_SZ);
+				  BFA_DMA_ALIGN_SZ);
 	per_rspq_sz = BFA_ROUNDUP((cfg->drvcfg.num_rspq_elems * BFI_LMSG_SZ),
-							BFA_DMA_ALIGN_SZ);
+				  BFA_DMA_ALIGN_SZ);
 
 	/*
 	 * Calculate CQ size
@@ -107,8 +107,8 @@ bfa_iocfc_send_cfg(void *bfa_arg)
 	struct bfa_iocfc_s *iocfc = &bfa->iocfc;
 	struct bfi_iocfc_cfg_req_s cfg_req;
 	struct bfi_iocfc_cfg_s *cfg_info = iocfc->cfginfo;
-	struct bfa_iocfc_cfg_s  *cfg = &iocfc->cfg;
-	int             i;
+	struct bfa_iocfc_cfg_s	*cfg = &iocfc->cfg;
+	int		i;
 
 	bfa_assert(cfg->fwcfg.num_cqs <= BFI_IOC_MAX_CQS);
 	bfa_trc(bfa, cfg->fwcfg.num_cqs);
@@ -130,16 +130,16 @@ bfa_iocfc_send_cfg(void *bfa_arg)
 	 */
 	for (i = 0; i < cfg->fwcfg.num_cqs; i++) {
 		bfa_dma_be_addr_set(cfg_info->req_cq_ba[i],
-				       iocfc->req_cq_ba[i].pa);
+				    iocfc->req_cq_ba[i].pa);
 		bfa_dma_be_addr_set(cfg_info->req_shadow_ci[i],
-				       iocfc->req_cq_shadow_ci[i].pa);
+				    iocfc->req_cq_shadow_ci[i].pa);
 		cfg_info->req_cq_elems[i] =
 			bfa_os_htons(cfg->drvcfg.num_reqq_elems);
 
 		bfa_dma_be_addr_set(cfg_info->rsp_cq_ba[i],
-				       iocfc->rsp_cq_ba[i].pa);
+				    iocfc->rsp_cq_ba[i].pa);
 		bfa_dma_be_addr_set(cfg_info->rsp_shadow_pi[i],
-				       iocfc->rsp_cq_shadow_pi[i].pa);
+				    iocfc->rsp_cq_shadow_pi[i].pa);
 		cfg_info->rsp_cq_elems[i] =
 			bfa_os_htons(cfg->drvcfg.num_rspq_elems);
 	}
@@ -148,16 +148,16 @@ bfa_iocfc_send_cfg(void *bfa_arg)
 	 * dma map IOC configuration itself
 	 */
 	bfi_h2i_set(cfg_req.mh, BFI_MC_IOCFC, BFI_IOCFC_H2I_CFG_REQ,
-			bfa_lpuid(bfa));
+		    bfa_lpuid(bfa));
 	bfa_dma_be_addr_set(cfg_req.ioc_cfg_dma_addr, iocfc->cfg_info.pa);
 
 	bfa_ioc_mbox_send(&bfa->ioc, &cfg_req,
-			sizeof(struct bfi_iocfc_cfg_req_s));
+			  sizeof(struct bfi_iocfc_cfg_req_s));
 }
 
 static void
 bfa_iocfc_init_mem(struct bfa_s *bfa, void *bfad, struct bfa_iocfc_cfg_s *cfg,
-		    struct bfa_pcidev_s *pcidev)
+		   struct bfa_pcidev_s *pcidev)
 {
 	struct bfa_iocfc_s	*iocfc = &bfa->iocfc;
 
@@ -172,6 +172,7 @@ bfa_iocfc_init_mem(struct bfa_s *bfa, vo
 	 */
 	if (bfa_ioc_devid(&bfa->ioc) == BFA_PCI_DEVICE_ID_CT) {
 		iocfc->hwif.hw_reginit = bfa_hwct_reginit;
+		iocfc->hwif.hw_reqq_ack = bfa_hwct_reqq_ack;
 		iocfc->hwif.hw_rspq_ack = bfa_hwct_rspq_ack;
 		iocfc->hwif.hw_msix_init = bfa_hwct_msix_init;
 		iocfc->hwif.hw_msix_install = bfa_hwct_msix_install;
@@ -180,6 +181,7 @@ bfa_iocfc_init_mem(struct bfa_s *bfa, vo
 		iocfc->hwif.hw_msix_getvecs = bfa_hwct_msix_getvecs;
 	} else {
 		iocfc->hwif.hw_reginit = bfa_hwcb_reginit;
+		iocfc->hwif.hw_reqq_ack = bfa_hwcb_reqq_ack;
 		iocfc->hwif.hw_rspq_ack = bfa_hwcb_rspq_ack;
 		iocfc->hwif.hw_msix_init = bfa_hwcb_msix_init;
 		iocfc->hwif.hw_msix_install = bfa_hwcb_msix_install;
@@ -194,11 +196,11 @@ bfa_iocfc_init_mem(struct bfa_s *bfa, vo
 
 static void
 bfa_iocfc_mem_claim(struct bfa_s *bfa, struct bfa_iocfc_cfg_s *cfg,
-		      struct bfa_meminfo_s *meminfo)
+		    struct bfa_meminfo_s *meminfo)
 {
-	u8        *dm_kva;
-	u64        dm_pa;
-	int             i, per_reqq_sz, per_rspq_sz;
+	u8	       *dm_kva;
+	u64	dm_pa;
+	int		i, per_reqq_sz, per_rspq_sz;
 	struct bfa_iocfc_s  *iocfc = &bfa->iocfc;
 	int		dbgsz;
 
@@ -217,9 +219,9 @@ bfa_iocfc_mem_claim(struct bfa_s *bfa, s
 	 * ci/pi registers
 	 */
 	per_reqq_sz = BFA_ROUNDUP((cfg->drvcfg.num_reqq_elems * BFI_LMSG_SZ),
-							BFA_DMA_ALIGN_SZ);
+				  BFA_DMA_ALIGN_SZ);
 	per_rspq_sz = BFA_ROUNDUP((cfg->drvcfg.num_rspq_elems * BFI_LMSG_SZ),
-							BFA_DMA_ALIGN_SZ);
+				  BFA_DMA_ALIGN_SZ);
 
 	for (i = 0; i < cfg->fwcfg.num_cqs; i++) {
 		iocfc->req_cq_ba[i].kva = dm_kva;
@@ -294,7 +296,7 @@ bfa_iocfc_mem_claim(struct bfa_s *bfa, s
 static void
 bfa_iocfc_initdone_submod(struct bfa_s *bfa)
 {
-	int             i;
+	int		i;
 
 	for (i = 0; hal_mods[i]; i++)
 		hal_mods[i]->initdone(bfa);
@@ -306,7 +308,7 @@ bfa_iocfc_initdone_submod(struct bfa_s *
 static void
 bfa_iocfc_start_submod(struct bfa_s *bfa)
 {
-	int             i;
+	int		i;
 
 	bfa->rme_process = BFA_TRUE;
 
@@ -320,7 +322,7 @@ bfa_iocfc_start_submod(struct bfa_s *bfa
 static void
 bfa_iocfc_disable_submod(struct bfa_s *bfa)
 {
-	int             i;
+	int		i;
 
 	for (i = 0; hal_mods[i]; i++)
 		hal_mods[i]->iocdisable(bfa);
@@ -336,8 +338,10 @@ bfa_iocfc_init_cb(void *bfa_arg, bfa_boo
 			bfa_cb_init(bfa->bfad, BFA_STATUS_OK);
 		else
 			bfa_cb_init(bfa->bfad, BFA_STATUS_FAILED);
-	} else
-		bfa->iocfc.action = BFA_IOCFC_ACT_NONE;
+	} else {
+		if (bfa->iocfc.cfgdone)
+			bfa->iocfc.action = BFA_IOCFC_ACT_NONE;
+	}
 }
 
 static void
@@ -348,7 +352,6 @@ bfa_iocfc_stop_cb(void *bfa_arg, bfa_boo
 
 	if (compl)
 		complete(&bfad->comp);
-
 	else
 		bfa->iocfc.action = BFA_IOCFC_ACT_NONE;
 }
@@ -370,11 +373,11 @@ static void
 bfa_iocfc_cfgrsp(struct bfa_s *bfa)
 {
 	struct bfa_iocfc_s		*iocfc	 = &bfa->iocfc;
-	struct bfi_iocfc_cfgrsp_s	*cfgrsp  = iocfc->cfgrsp;
-	struct bfa_iocfc_fwcfg_s	*fwcfg   = &cfgrsp->fwcfg;
-	struct bfi_iocfc_cfg_s 		*cfginfo = iocfc->cfginfo;
+	struct bfi_iocfc_cfgrsp_s	*cfgrsp	 = iocfc->cfgrsp;
+	struct bfa_iocfc_fwcfg_s	*fwcfg	 = &cfgrsp->fwcfg;
+	struct bfi_iocfc_cfg_s		*cfginfo = iocfc->cfginfo;
 
-	fwcfg->num_cqs        = fwcfg->num_cqs;
+	fwcfg->num_cqs	      = fwcfg->num_cqs;
 	fwcfg->num_ioim_reqs  = bfa_os_ntohs(fwcfg->num_ioim_reqs);
 	fwcfg->num_tskim_reqs = bfa_os_ntohs(fwcfg->num_tskim_reqs);
 	fwcfg->num_fcxp_reqs  = bfa_os_ntohs(fwcfg->num_fcxp_reqs);
@@ -404,21 +407,21 @@ bfa_iocfc_stats_clear(void *bfa_arg)
 	struct bfi_iocfc_stats_req_s stats_req;
 
 	bfa_timer_start(bfa, &iocfc->stats_timer,
-			    bfa_iocfc_stats_clr_timeout, bfa,
-			    BFA_IOCFC_TOV);
+			bfa_iocfc_stats_clr_timeout, bfa,
+			BFA_IOCFC_TOV);
 
 	bfi_h2i_set(stats_req.mh, BFI_MC_IOCFC, BFI_IOCFC_H2I_CLEAR_STATS_REQ,
-		bfa_lpuid(bfa));
+		    bfa_lpuid(bfa));
 	bfa_ioc_mbox_send(&bfa->ioc, &stats_req,
-		sizeof(struct bfi_iocfc_stats_req_s));
+			  sizeof(struct bfi_iocfc_stats_req_s));
 }
 
 static void
 bfa_iocfc_stats_swap(struct bfa_fw_stats_s *d, struct bfa_fw_stats_s *s)
 {
-	u32       *dip = (u32 *) d;
-	u32       *sip = (u32 *) s;
-	int             i;
+	u32 *dip = (u32 *) d;
+	u32 *sip = (u32 *) s;
+	int i;
 
 	for (i = 0; i < (sizeof(struct bfa_fw_stats_s) / sizeof(u32)); i++)
 		dip[i] = bfa_os_ntohl(sip[i]);
@@ -460,9 +463,9 @@ bfa_iocfc_stats_cb(void *bfa_arg, bfa_bo
 	if (complete) {
 		if (iocfc->stats_status == BFA_STATUS_OK) {
 			bfa_os_memset(iocfc->stats_ret, 0,
-				sizeof(*iocfc->stats_ret));
+				      sizeof(*iocfc->stats_ret));
 			bfa_iocfc_stats_swap(&iocfc->stats_ret->fw_stats,
-				iocfc->fw_stats);
+					     iocfc->fw_stats);
 		}
 		iocfc->stats_cbfn(iocfc->stats_cbarg, iocfc->stats_status);
 	} else {
@@ -490,18 +493,18 @@ bfa_iocfc_stats_query(struct bfa_s *bfa)
 	struct bfi_iocfc_stats_req_s stats_req;
 
 	bfa_timer_start(bfa, &iocfc->stats_timer,
-			    bfa_iocfc_stats_timeout, bfa, BFA_IOCFC_TOV);
+			bfa_iocfc_stats_timeout, bfa, BFA_IOCFC_TOV);
 
 	bfi_h2i_set(stats_req.mh, BFI_MC_IOCFC, BFI_IOCFC_H2I_GET_STATS_REQ,
-			bfa_lpuid(bfa));
+		    bfa_lpuid(bfa));
 	bfa_ioc_mbox_send(&bfa->ioc, &stats_req,
-		sizeof(struct bfi_iocfc_stats_req_s));
+			  sizeof(struct bfi_iocfc_stats_req_s));
 }
 
 void
 bfa_iocfc_reset_queues(struct bfa_s *bfa)
 {
-	int             q;
+	int		q;
 
 	for (q = 0; q < BFI_IOC_MAX_CQS; q++) {
 		bfa_reqq_ci(bfa, q) = 0;
@@ -593,7 +596,7 @@ bfa_iocfc_reset_cbfn(void *bfa_arg)
  */
 void
 bfa_iocfc_meminfo(struct bfa_iocfc_cfg_s *cfg, u32 *km_len,
-		u32 *dm_len)
+		  u32 *dm_len)
 {
 	/* dma memory for IOC */
 	*dm_len += bfa_ioc_meminfo();
@@ -608,9 +611,9 @@ bfa_iocfc_meminfo(struct bfa_iocfc_cfg_s
  */
 void
 bfa_iocfc_attach(struct bfa_s *bfa, void *bfad, struct bfa_iocfc_cfg_s *cfg,
-		   struct bfa_meminfo_s *meminfo, struct bfa_pcidev_s *pcidev)
+		 struct bfa_meminfo_s *meminfo, struct bfa_pcidev_s *pcidev)
 {
-	int             i;
+	int		i;
 
 	bfa_iocfc_cbfn.enable_cbfn = bfa_iocfc_enable_cbfn;
 	bfa_iocfc_cbfn.disable_cbfn = bfa_iocfc_disable_cbfn;
@@ -618,9 +621,7 @@ bfa_iocfc_attach(struct bfa_s *bfa, void
 	bfa_iocfc_cbfn.reset_cbfn = bfa_iocfc_reset_cbfn;
 
 	bfa_ioc_attach(&bfa->ioc, bfa, &bfa_iocfc_cbfn, &bfa->timer_mod,
-		bfa->trcmod, bfa->aen, bfa->logm);
-	bfa_ioc_pci_init(&bfa->ioc, pcidev, BFI_MC_IOCFC);
-	bfa_ioc_mbox_register(&bfa->ioc, bfa_mbox_isrs);
+		       bfa->trcmod, bfa->aen, bfa->logm);
 
 	/**
 	 * Choose FC (ssid: 0x1C) v/s FCoE (ssid: 0x14) mode.
@@ -628,6 +629,9 @@ bfa_iocfc_attach(struct bfa_s *bfa, void
 	if (0)
 		bfa_ioc_set_fcmode(&bfa->ioc);
 
+	bfa_ioc_pci_init(&bfa->ioc, pcidev, BFI_MC_IOCFC);
+	bfa_ioc_mbox_register(&bfa->ioc, bfa_mbox_isrs);
+
 	bfa_iocfc_init_mem(bfa, bfad, cfg, pcidev);
 	bfa_iocfc_mem_claim(bfa, cfg, meminfo);
 	bfa_timer_init(&bfa->timer_mod);
@@ -654,7 +658,6 @@ bfa_iocfc_init(struct bfa_s *bfa)
 {
 	bfa->iocfc.action = BFA_IOCFC_ACT_INIT;
 	bfa_ioc_enable(&bfa->ioc);
-	bfa_msix_install(bfa);
 }
 
 /**
@@ -698,27 +701,27 @@ bfa_iocfc_isr(void *bfaarg, struct bfi_m
 		break;
 
 	case BFI_IOCFC_I2H_GET_STATS_RSP:
-		if (iocfc->stats_busy == BFA_FALSE
-		    || iocfc->stats_status == BFA_STATUS_ETIMER)
+		if (iocfc->stats_busy == BFA_FALSE ||
+		    iocfc->stats_status == BFA_STATUS_ETIMER)
 			break;
 
 		bfa_timer_stop(&iocfc->stats_timer);
 		iocfc->stats_status = BFA_STATUS_OK;
 		bfa_cb_queue(bfa, &iocfc->stats_hcb_qe, bfa_iocfc_stats_cb,
-			      bfa);
+			     bfa);
 		break;
 	case BFI_IOCFC_I2H_CLEAR_STATS_RSP:
 		/*
 		 * check for timer pop before processing the rsp
 		 */
-		if (iocfc->stats_busy == BFA_FALSE
-		    || iocfc->stats_status == BFA_STATUS_ETIMER)
+		if (iocfc->stats_busy == BFA_FALSE ||
+		    iocfc->stats_status == BFA_STATUS_ETIMER)
 			break;
 
 		bfa_timer_stop(&iocfc->stats_timer);
 		iocfc->stats_status = BFA_STATUS_OK;
 		bfa_cb_queue(bfa, &iocfc->stats_hcb_qe,
-			      bfa_iocfc_stats_clr_cb, bfa);
+			     bfa_iocfc_stats_clr_cb, bfa);
 		break;
 	case BFI_IOCFC_I2H_UPDATEQ_RSP:
 		iocfc->updateq_cbfn(iocfc->updateq_cbarg, BFA_STATUS_OK);
@@ -765,7 +768,7 @@ bfa_iocfc_israttr_set(struct bfa_s *bfa,
 		return BFA_STATUS_DEVBUSY;
 
 	bfi_h2i_set(m->mh, BFI_MC_IOCFC, BFI_IOCFC_H2I_SET_INTR_REQ,
-			bfa_lpuid(bfa));
+		    bfa_lpuid(bfa));
 	m->coalesce = attr->coalesce;
 	m->delay    = bfa_os_htons(attr->delay);
 	m->latency  = bfa_os_htons(attr->latency);
@@ -780,7 +783,7 @@ bfa_iocfc_israttr_set(struct bfa_s *bfa,
 void
 bfa_iocfc_set_snsbase(struct bfa_s *bfa, u64 snsbase_pa)
 {
-	struct bfa_iocfc_s      *iocfc = &bfa->iocfc;
+	struct bfa_iocfc_s	*iocfc = &bfa->iocfc;
 
 	iocfc->cfginfo->sense_buf_len = (BFI_IOIM_SNSLEN - 1);
 	bfa_dma_be_addr_set(iocfc->cfginfo->ioim_snsbase, snsbase_pa);
@@ -788,13 +791,18 @@ bfa_iocfc_set_snsbase(struct bfa_s *bfa,
 
 bfa_status_t
 bfa_iocfc_get_stats(struct bfa_s *bfa, struct bfa_iocfc_stats_s *stats,
-		      bfa_cb_ioc_t cbfn, void *cbarg)
+		    bfa_cb_ioc_t cbfn, void *cbarg)
 {
 	struct bfa_iocfc_s	*iocfc = &bfa->iocfc;
 
 	if (iocfc->stats_busy) {
 		bfa_trc(bfa, iocfc->stats_busy);
-		return (BFA_STATUS_DEVBUSY);
+		return BFA_STATUS_DEVBUSY;
+	}
+
+	if (!bfa_iocfc_is_operational(bfa)) {
+		bfa_trc(bfa, 0);
+		return BFA_STATUS_IOC_NON_OP;
 	}
 
 	iocfc->stats_busy = BFA_TRUE;
@@ -804,7 +812,7 @@ bfa_iocfc_get_stats(struct bfa_s *bfa, s
 
 	bfa_iocfc_stats_query(bfa);
 
-	return (BFA_STATUS_OK);
+	return BFA_STATUS_OK;
 }
 
 bfa_status_t
@@ -814,7 +822,12 @@ bfa_iocfc_clear_stats(struct bfa_s *bfa,
 
 	if (iocfc->stats_busy) {
 		bfa_trc(bfa, iocfc->stats_busy);
-		return (BFA_STATUS_DEVBUSY);
+		return BFA_STATUS_DEVBUSY;
+	}
+
+	if (!bfa_iocfc_is_operational(bfa)) {
+		bfa_trc(bfa, 0);
+		return BFA_STATUS_IOC_NON_OP;
 	}
 
 	iocfc->stats_busy = BFA_TRUE;
@@ -822,7 +835,7 @@ bfa_iocfc_clear_stats(struct bfa_s *bfa,
 	iocfc->stats_cbarg = cbarg;
 
 	bfa_iocfc_stats_clear(bfa);
-	return (BFA_STATUS_OK);
+	return BFA_STATUS_OK;
 }
 
 /**
@@ -861,7 +874,7 @@ void
 bfa_iocfc_get_bootwwns(struct bfa_s *bfa, u8 *nwwns, wwn_t **wwns)
 {
 	struct bfa_iocfc_s		*iocfc	 = &bfa->iocfc;
-	struct bfi_iocfc_cfgrsp_s	*cfgrsp  = iocfc->cfgrsp;
+	struct bfi_iocfc_cfgrsp_s	*cfgrsp	 = iocfc->cfgrsp;
 
 	*nwwns = cfgrsp->bootwwns.nwwns;
 	*wwns = cfgrsp->bootwwns.wwn;
diff -uprN a/drivers/scsi/bfa/bfa_iocfc.h b/drivers/scsi/bfa/bfa_iocfc.h
--- a/drivers/scsi/bfa/bfa_iocfc.h	2009-12-18 18:16:22.459687000 -0800
+++ b/drivers/scsi/bfa/bfa_iocfc.h	2009-11-25 18:06:50.000000000 -0800
@@ -54,6 +54,7 @@ struct bfa_msix_s {
  */
 struct bfa_hwif_s {
 	void (*hw_reginit)(struct bfa_s *bfa);
+	void (*hw_reqq_ack)(struct bfa_s *bfa, int reqq);
 	void (*hw_rspq_ack)(struct bfa_s *bfa, int rspq);
 	void (*hw_msix_init)(struct bfa_s *bfa, int nvecs);
 	void (*hw_msix_install)(struct bfa_s *bfa);
@@ -69,8 +70,8 @@ struct bfa_iocfc_s {
 	struct bfa_iocfc_cfg_s 	cfg;
 	int			action;
 
-	u32        	req_cq_pi[BFI_IOC_MAX_CQS];
-	u32        	rsp_cq_ci[BFI_IOC_MAX_CQS];
+	u32		req_cq_pi[BFI_IOC_MAX_CQS];
+	u32		rsp_cq_ci[BFI_IOC_MAX_CQS];
 
 	struct bfa_cb_qe_s	init_hcb_qe;
 	struct bfa_cb_qe_s	stop_hcb_qe;
@@ -92,7 +93,7 @@ struct bfa_iocfc_s {
 	bfa_status_t		stats_status;	/*  stats/statsclr status */
 	bfa_boolean_t   	stats_busy;	/*  outstanding stats */
 	bfa_cb_ioc_t		stats_cbfn;	/*  driver callback function */
-	void           		*stats_cbarg;	/*  user callback arg */
+	void			*stats_cbarg;	/*  user callback arg */
 
 	struct bfa_dma_s   	req_cq_ba[BFI_IOC_MAX_CQS];
 	struct bfa_dma_s   	req_cq_shadow_ci[BFI_IOC_MAX_CQS];
@@ -102,20 +103,21 @@ struct bfa_iocfc_s {
 	struct bfa_hwif_s	hwif;
 
 	bfa_cb_iocfc_t		updateq_cbfn; /*  bios callback function */
-	void				*updateq_cbarg;	/*  bios callback arg */
+	void			*updateq_cbarg;	/*  bios callback arg */
 };
 
 #define bfa_lpuid(__bfa)		bfa_ioc_portid(&(__bfa)->ioc)
 #define bfa_msix_init(__bfa, __nvecs)	\
-	(__bfa)->iocfc.hwif.hw_msix_init(__bfa, __nvecs)
+	((__bfa)->iocfc.hwif.hw_msix_init(__bfa, __nvecs))
 #define bfa_msix_install(__bfa)	\
-	(__bfa)->iocfc.hwif.hw_msix_install(__bfa)
+	((__bfa)->iocfc.hwif.hw_msix_install(__bfa))
 #define bfa_msix_uninstall(__bfa)	\
-	(__bfa)->iocfc.hwif.hw_msix_uninstall(__bfa)
+	((__bfa)->iocfc.hwif.hw_msix_uninstall(__bfa))
 #define bfa_isr_mode_set(__bfa, __msix)	\
-	(__bfa)->iocfc.hwif.hw_isr_mode_set(__bfa, __msix)
+	((__bfa)->iocfc.hwif.hw_isr_mode_set(__bfa, __msix))
 #define bfa_msix_getvecs(__bfa, __vecmap, __nvecs, __maxvec)	\
-	(__bfa)->iocfc.hwif.hw_msix_getvecs(__bfa, __vecmap, __nvecs, __maxvec)
+	((__bfa)->iocfc.hwif.hw_msix_getvecs(__bfa, __vecmap,	\
+					__nvecs, __maxvec))
 
 /*
  * FC specific IOC functions.
@@ -134,8 +136,7 @@ void bfa_iocfc_set_snsbase(struct bfa_s 
 bfa_boolean_t bfa_iocfc_is_operational(struct bfa_s *bfa);
 void bfa_iocfc_reset_queues(struct bfa_s *bfa);
 void bfa_iocfc_updateq(struct bfa_s *bfa, u32 reqq_ba, u32 rspq_ba,
-			u32 reqq_sci, u32 rspq_spi,
-			bfa_cb_iocfc_t cbfn, void *cbarg);
+	u32 reqq_sci, u32 rspq_spi, bfa_cb_iocfc_t cbfn, void *cbarg);
 
 void bfa_msix_all(struct bfa_s *bfa, int vec);
 void bfa_msix_reqq(struct bfa_s *bfa, int vec);
@@ -143,21 +144,23 @@ void bfa_msix_rspq(struct bfa_s *bfa, in
 void bfa_msix_lpu_err(struct bfa_s *bfa, int vec);
 
 void bfa_hwcb_reginit(struct bfa_s *bfa);
+void bfa_hwcb_reqq_ack(struct bfa_s *bfa, int rspq);
 void bfa_hwcb_rspq_ack(struct bfa_s *bfa, int rspq);
 void bfa_hwcb_msix_init(struct bfa_s *bfa, int nvecs);
 void bfa_hwcb_msix_install(struct bfa_s *bfa);
 void bfa_hwcb_msix_uninstall(struct bfa_s *bfa);
 void bfa_hwcb_isr_mode_set(struct bfa_s *bfa, bfa_boolean_t msix);
-void bfa_hwcb_msix_getvecs(struct bfa_s *bfa, u32 *vecmap,
-			u32 *nvecs, u32 *maxvec);
+void bfa_hwcb_msix_getvecs(struct bfa_s *bfa, u32 *vecmap, u32 *nvecs,
+	u32 *maxvec);
 void bfa_hwct_reginit(struct bfa_s *bfa);
+void bfa_hwct_reqq_ack(struct bfa_s *bfa, int rspq);
 void bfa_hwct_rspq_ack(struct bfa_s *bfa, int rspq);
 void bfa_hwct_msix_init(struct bfa_s *bfa, int nvecs);
 void bfa_hwct_msix_install(struct bfa_s *bfa);
 void bfa_hwct_msix_uninstall(struct bfa_s *bfa);
 void bfa_hwct_isr_mode_set(struct bfa_s *bfa, bfa_boolean_t msix);
-void bfa_hwct_msix_getvecs(struct bfa_s *bfa, u32 *vecmap,
-			u32 *nvecs, u32 *maxvec);
+void bfa_hwct_msix_getvecs(struct bfa_s *bfa, u32 *vecmap, u32 *nvecs,
+	u32 *maxvec);
 
 void bfa_com_meminfo(bfa_boolean_t mincfg, u32 *dm_len);
 void bfa_com_attach(struct bfa_s *bfa, struct bfa_meminfo_s *mi,
@@ -165,4 +168,3 @@ void bfa_com_attach(struct bfa_s *bfa, s
 void bfa_iocfc_get_bootwwns(struct bfa_s *bfa, u8 *nwwns, wwn_t **wwns);
 
 #endif /* __BFA_IOCFC_H__ */
-
diff -uprN a/drivers/scsi/bfa/bfa_ioim.c b/drivers/scsi/bfa/bfa_ioim.c
--- a/drivers/scsi/bfa/bfa_ioim.c	2009-12-18 18:16:22.456684000 -0800
+++ b/drivers/scsi/bfa/bfa_ioim.c	2009-11-25 18:21:07.000000000 -0800
@@ -43,24 +43,24 @@ static void __bfa_cb_ioim_pathtov(void *
  * IO state machine events
  */
 enum bfa_ioim_event {
-	BFA_IOIM_SM_START = 1,		/*  io start request from host */
-	BFA_IOIM_SM_COMP_GOOD = 2,	/*  io good comp, resource free */
-	BFA_IOIM_SM_COMP = 3,		/*  io comp, resource is free */
-	BFA_IOIM_SM_COMP_UTAG = 4,	/*  io comp, resource is free */
-	BFA_IOIM_SM_DONE = 5,		/*  io comp, resource not free */
-	BFA_IOIM_SM_FREE = 6,		/*  io resource is freed */
-	BFA_IOIM_SM_ABORT = 7,		/*  abort request from scsi stack */
+	BFA_IOIM_SM_START	   = 1,	/*  io start request from host */
+	BFA_IOIM_SM_COMP_GOOD  = 2,	/*  io good comp, resource free */
+	BFA_IOIM_SM_COMP	   = 3,	/*  io comp, resource is free */
+	BFA_IOIM_SM_COMP_UTAG  = 4,	/*  io comp, resource is free */
+	BFA_IOIM_SM_DONE	   = 5,	/*  io comp, resource not free */
+	BFA_IOIM_SM_FREE	   = 6,	/*  io resource is freed */
+	BFA_IOIM_SM_ABORT	   = 7,	/*  abort request from scsi stack */
 	BFA_IOIM_SM_ABORT_COMP = 8,	/*  abort from f/w */
 	BFA_IOIM_SM_ABORT_DONE = 9,	/*  abort completion from f/w */
-	BFA_IOIM_SM_QRESUME = 10,	/*  CQ space available to queue IO */
-	BFA_IOIM_SM_SGALLOCED = 11,	/*  SG page allocation successful */
-	BFA_IOIM_SM_SQRETRY = 12,	/*  sequence recovery retry */
-	BFA_IOIM_SM_HCB	= 13,		/*  bfa callback complete */
-	BFA_IOIM_SM_CLEANUP = 14,	/*  IO cleanup from itnim */
-	BFA_IOIM_SM_TMSTART = 15,	/*  IO cleanup from tskim */
-	BFA_IOIM_SM_TMDONE = 16,	/*  IO cleanup from tskim */
-	BFA_IOIM_SM_HWFAIL = 17,	/*  IOC h/w failure event */
-	BFA_IOIM_SM_IOTOV = 18,		/*  ITN offline TOV       */
+	BFA_IOIM_SM_QRESUME	   = 10,/*  CQ space available to queue IO */
+	BFA_IOIM_SM_SGALLOCED  = 11,/*  SG page allocation successful */
+	BFA_IOIM_SM_SQRETRY	   = 12,/*  sequence recovery retry */
+	BFA_IOIM_SM_HCB	   = 13,/*  bfa callback complete */
+	BFA_IOIM_SM_CLEANUP	   = 14,/*  IO cleanup from itnim */
+	BFA_IOIM_SM_TMSTART	   = 15,/*  IO cleanup from tskim */
+	BFA_IOIM_SM_TMDONE	   = 16,/*  IO cleanup from tskim */
+	BFA_IOIM_SM_HWFAIL	   = 17,/*  IOC h/w failure event */
+	BFA_IOIM_SM_IOTOV	   = 18,/*  ITN offline TOV       */
 };
 
 /*
@@ -105,13 +105,13 @@ bfa_ioim_sm_uninit(struct bfa_ioim_s *io
 				bfa_sm_set_state(ioim, bfa_ioim_sm_hcb);
 				list_del(&ioim->qe);
 				list_add_tail(&ioim->qe,
-					&ioim->fcpim->ioim_comp_q);
+						&ioim->fcpim->ioim_comp_q);
 				bfa_cb_queue(ioim->bfa, &ioim->hcb_qe,
 						__bfa_cb_ioim_pathtov, ioim);
 			} else {
 				list_del(&ioim->qe);
 				list_add_tail(&ioim->qe,
-					&ioim->itnim->pending_q);
+						&ioim->itnim->pending_q);
 			}
 			break;
 		}
@@ -144,12 +144,12 @@ bfa_ioim_sm_uninit(struct bfa_ioim_s *io
 		 */
 		bfa_sm_set_state(ioim, bfa_ioim_sm_hcb);
 		bfa_assert(bfa_q_is_on_q(&ioim->itnim->pending_q, ioim));
-		bfa_cb_queue(ioim->bfa, &ioim->hcb_qe, __bfa_cb_ioim_abort,
-				ioim);
+		bfa_cb_queue(ioim->bfa, &ioim->hcb_qe,
+				__bfa_cb_ioim_abort, ioim);
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ioim->bfa, event);
 	}
 }
 
@@ -194,7 +194,7 @@ bfa_ioim_sm_sgalloc(struct bfa_ioim_s *i
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ioim->bfa, event);
 	}
 }
 
@@ -259,7 +259,7 @@ bfa_ioim_sm_active(struct bfa_ioim_s *io
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ioim->bfa, event);
 	}
 }
 
@@ -317,7 +317,7 @@ bfa_ioim_sm_abort(struct bfa_ioim_s *ioi
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ioim->bfa, event);
 	}
 }
 
@@ -377,7 +377,7 @@ bfa_ioim_sm_cleanup(struct bfa_ioim_s *i
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ioim->bfa, event);
 	}
 }
 
@@ -419,7 +419,7 @@ bfa_ioim_sm_qfull(struct bfa_ioim_s *ioi
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ioim->bfa, event);
 	}
 }
 
@@ -467,7 +467,7 @@ bfa_ioim_sm_abort_qfull(struct bfa_ioim_
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ioim->bfa, event);
 	}
 }
 
@@ -516,7 +516,7 @@ bfa_ioim_sm_cleanup_qfull(struct bfa_ioi
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ioim->bfa, event);
 	}
 }
 
@@ -544,7 +544,7 @@ bfa_ioim_sm_hcb(struct bfa_ioim_s *ioim,
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ioim->bfa, event);
 	}
 }
 
@@ -577,7 +577,7 @@ bfa_ioim_sm_hcb_free(struct bfa_ioim_s *
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ioim->bfa, event);
 	}
 }
 
@@ -605,7 +605,7 @@ bfa_ioim_sm_resfree(struct bfa_ioim_s *i
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ioim->bfa, event);
 	}
 }
 
diff -uprN a/drivers/scsi/bfa/bfa_itnim.c b/drivers/scsi/bfa/bfa_itnim.c
--- a/drivers/scsi/bfa/bfa_itnim.c	2009-12-18 18:16:22.453686000 -0800
+++ b/drivers/scsi/bfa/bfa_itnim.c	2009-11-25 18:21:07.000000000 -0800
@@ -144,7 +144,7 @@ bfa_itnim_sm_uninit(struct bfa_itnim_s *
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(itnim->bfa, event);
 	}
 }
 
@@ -175,7 +175,7 @@ bfa_itnim_sm_created(struct bfa_itnim_s 
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(itnim->bfa, event);
 	}
 }
 
@@ -212,13 +212,13 @@ bfa_itnim_sm_fwcreate(struct bfa_itnim_s
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(itnim->bfa, event);
 	}
 }
 
 static void
 bfa_itnim_sm_fwcreate_qfull(struct bfa_itnim_s *itnim,
-			enum bfa_itnim_event event)
+					enum bfa_itnim_event event)
 {
 	bfa_trc(itnim->bfa, itnim->rport->rport_tag);
 	bfa_trc(itnim->bfa, event);
@@ -247,7 +247,7 @@ bfa_itnim_sm_fwcreate_qfull(struct bfa_i
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(itnim->bfa, event);
 	}
 }
 
@@ -275,7 +275,7 @@ bfa_itnim_sm_delete_pending(struct bfa_i
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(itnim->bfa, event);
 	}
 }
 
@@ -317,7 +317,7 @@ bfa_itnim_sm_online(struct bfa_itnim_s *
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(itnim->bfa, event);
 	}
 }
 
@@ -348,7 +348,7 @@ bfa_itnim_sm_sler(struct bfa_itnim_s *it
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(itnim->bfa, event);
 	}
 }
 
@@ -385,7 +385,7 @@ bfa_itnim_sm_cleanup_offline(struct bfa_
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(itnim->bfa, event);
 	}
 }
 
@@ -413,7 +413,7 @@ bfa_itnim_sm_cleanup_delete(struct bfa_i
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(itnim->bfa, event);
 	}
 }
 
@@ -442,13 +442,13 @@ bfa_itnim_sm_fwdelete(struct bfa_itnim_s
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(itnim->bfa, event);
 	}
 }
 
 static void
 bfa_itnim_sm_fwdelete_qfull(struct bfa_itnim_s *itnim,
-			enum bfa_itnim_event event)
+					enum bfa_itnim_event event)
 {
 	bfa_trc(itnim->bfa, itnim->rport->rport_tag);
 	bfa_trc(itnim->bfa, event);
@@ -470,7 +470,7 @@ bfa_itnim_sm_fwdelete_qfull(struct bfa_i
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(itnim->bfa, event);
 	}
 }
 
@@ -502,7 +502,7 @@ bfa_itnim_sm_offline(struct bfa_itnim_s 
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(itnim->bfa, event);
 	}
 }
 
@@ -538,7 +538,7 @@ bfa_itnim_sm_iocdisable(struct bfa_itnim
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(itnim->bfa, event);
 	}
 }
 
@@ -559,13 +559,13 @@ bfa_itnim_sm_deleting(struct bfa_itnim_s
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(itnim->bfa, event);
 	}
 }
 
 static void
 bfa_itnim_sm_deleting_qfull(struct bfa_itnim_s *itnim,
-			enum bfa_itnim_event event)
+					enum bfa_itnim_event event)
 {
 	bfa_trc(itnim->bfa, itnim->rport->rport_tag);
 	bfa_trc(itnim->bfa, event);
@@ -583,7 +583,7 @@ bfa_itnim_sm_deleting_qfull(struct bfa_i
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(itnim->bfa, event);
 	}
 }
 
@@ -1029,7 +1029,7 @@ bfa_itnim_create(struct bfa_s *bfa, stru
 	bfa_stats(itnim, creates);
 	bfa_sm_send_event(itnim, BFA_ITNIM_SM_CREATE);
 
-	return (itnim);
+	return itnim;
 }
 
 void
@@ -1061,7 +1061,7 @@ bfa_itnim_offline(struct bfa_itnim_s *it
 bfa_boolean_t
 bfa_itnim_hold_io(struct bfa_itnim_s *itnim)
 {
-	return (
+	return
 		itnim->fcpim->path_tov && itnim->iotov_active &&
 		(bfa_sm_cmp_state(itnim, bfa_itnim_sm_fwcreate) ||
 		 bfa_sm_cmp_state(itnim, bfa_itnim_sm_sler) ||
@@ -1069,7 +1069,7 @@ bfa_itnim_hold_io(struct bfa_itnim_s *it
 		 bfa_sm_cmp_state(itnim, bfa_itnim_sm_fwdelete) ||
 		 bfa_sm_cmp_state(itnim, bfa_itnim_sm_offline) ||
 		 bfa_sm_cmp_state(itnim, bfa_itnim_sm_iocdisable))
-);
+	;
 }
 
 void
diff -uprN a/drivers/scsi/bfa/bfa_log.c b/drivers/scsi/bfa/bfa_log.c
--- a/drivers/scsi/bfa/bfa_log.c	2009-12-18 18:16:22.451686000 -0800
+++ b/drivers/scsi/bfa/bfa_log.c	2009-11-25 18:21:07.000000000 -0800
@@ -231,9 +231,9 @@ bfa_log_get_level(struct bfa_log_mod_s *
 		return BFA_LOG_INVALID;
 
 	if (log_mod)
-		return (log_mod->log_level[mod_id]);
+		return log_mod->log_level[mod_id];
 	else
-		return (bfa_log_info[mod_id].level);
+		return bfa_log_info[mod_id].level;
 }
 
 enum bfa_log_severity
@@ -321,8 +321,9 @@ bfa_log(struct bfa_log_mod_s *log_mod, u
 
 	log_level = log_mod ? log_mod->log_level[mod] : bfa_log_info[mod].level;
 	if ((BFA_LOG_GET_SEVERITY(msg) > log_level) &&
-			(msg->attributes != BFA_LOG_ATTR_NONE))
+			(msg->attributes != BFA_LOG_ATTR_NONE)) {
 		return 0;
+	}
 
 	va_start(ap, msg_id);
 	bfa_os_vsprintf(buf, BFA_LOG_GET_MSG_FMT_STRING(msg), ap);
diff -uprN a/drivers/scsi/bfa/bfa_log_module.c b/drivers/scsi/bfa/bfa_log_module.c
--- a/drivers/scsi/bfa/bfa_log_module.c	2009-12-18 18:16:22.449685000 -0800
+++ b/drivers/scsi/bfa/bfa_log_module.c	2009-11-25 18:21:07.000000000 -0800
@@ -14,7 +14,26 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * General Public License for more details.
  */
-
+/*
+ *  Copyright (c) 2008 by Brocade Communications Systems, Inc.
+ *  All rights reserved.
+ *
+ *  File Name:      bfa_log_module.c
+ *
+ *  PLEASE DO NOT EDIT THIS FILE. THIS FILE IS AUTO GENERATED!!
+ *
+ *  Description:
+ *
+ *  The log messages defined in each XML files will be converted to a C code
+ *  style message file. The message file will be named the same as XML file.
+ *
+ *  These coded instructions and statements contain unpublished trade
+ *  secrets and proprietary information.  They are protected by federal
+ *  copyright law and by trade secret law, and may not be disclosed to
+ *  third parties or used, copied, or duplicated in any form, in whole
+ *  or in part, without the prior written consent of Brocade Communications.
+ *
+ */
 #include <cs/bfa_log.h>
 #include <aen/bfa_aen_adapter.h>
 #include <aen/bfa_aen_audit.h>
@@ -347,6 +366,21 @@ struct bfa_log_msgdef_s bfa_log_msg_arra
  ((BFA_LOG_S << BFA_LOG_ARG0) | (BFA_LOG_D << BFA_LOG_ARG1) |
   (BFA_LOG_D << BFA_LOG_ARG2) | 0), 3},
 
+{BFA_LOG_HAL_DRIVER_ERROR, BFA_LOG_ATTR_NONE | BFA_LOG_ATTR_LOG, BFA_LOG_INFO,
+ "HAL_DRIVER_ERROR",
+ "%s",
+ ((BFA_LOG_S << BFA_LOG_ARG0) | 0), 1},
+
+{BFA_LOG_HAL_DRIVER_CONFIG_ERROR, BFA_LOG_ATTR_NONE | BFA_LOG_ATTR_LOG,
+ BFA_LOG_INFO, "HAL_DRIVER_CONFIG_ERROR",
+ "%s",
+ ((BFA_LOG_S << BFA_LOG_ARG0) | 0), 1},
+
+{BFA_LOG_HAL_MBOX_ERROR, BFA_LOG_ATTR_NONE | BFA_LOG_ATTR_LOG, BFA_LOG_INFO,
+ "HAL_MBOX_ERROR",
+ "%s",
+ ((BFA_LOG_S << BFA_LOG_ARG0) | 0), 1},
+
 
 
 
@@ -412,6 +446,46 @@ struct bfa_log_msgdef_s bfa_log_msg_arra
  ((BFA_LOG_D << BFA_LOG_ARG0) | (BFA_LOG_P << BFA_LOG_ARG1) |
   (BFA_LOG_X << BFA_LOG_ARG2) | 0), 3},
 
+{BFA_LOG_LINUX_DRIVER_CONFIG_ERROR, BFA_LOG_ATTR_NONE | BFA_LOG_ATTR_LOG,
+ BFA_LOG_INFO, "LINUX_DRIVER_CONFIG_ERROR",
+ "%s",
+ ((BFA_LOG_S << BFA_LOG_ARG0) | 0), 1},
+
+{BFA_LOG_LINUX_BNA_STATE_MACHINE, BFA_LOG_ATTR_NONE | BFA_LOG_ATTR_LOG,
+ BFA_LOG_INFO, "LINUX_BNA_STATE_MACHINE",
+ "%s",
+ ((BFA_LOG_S << BFA_LOG_ARG0) | 0), 1},
+
+{BFA_LOG_LINUX_IOC_ERROR, BFA_LOG_ATTR_NONE | BFA_LOG_ATTR_LOG, BFA_LOG_INFO,
+ "LINUX_IOC_ERROR",
+ "%s",
+ ((BFA_LOG_S << BFA_LOG_ARG0) | 0), 1},
+
+{BFA_LOG_LINUX_RESOURCE_ALLOC_ERROR, BFA_LOG_ATTR_NONE | BFA_LOG_ATTR_LOG,
+ BFA_LOG_INFO, "LINUX_RESOURCE_ALLOC_ERROR",
+ "%s",
+ ((BFA_LOG_S << BFA_LOG_ARG0) | 0), 1},
+
+{BFA_LOG_LINUX_RING_BUFFER_ERROR, BFA_LOG_ATTR_NONE | BFA_LOG_ATTR_LOG,
+ BFA_LOG_INFO, "LINUX_RING_BUFFER_ERROR",
+ "%s",
+ ((BFA_LOG_S << BFA_LOG_ARG0) | 0), 1},
+
+{BFA_LOG_LINUX_DRIVER_ERROR, BFA_LOG_ATTR_NONE | BFA_LOG_ATTR_LOG,
+ BFA_LOG_INFO, "LINUX_DRIVER_ERROR",
+ "%s",
+ ((BFA_LOG_S << BFA_LOG_ARG0) | 0), 1},
+
+{BFA_LOG_LINUX_DRIVER_DIAG, BFA_LOG_ATTR_NONE | BFA_LOG_ATTR_LOG,
+ BFA_LOG_INFO, "LINUX_DRIVER_DIAG",
+ "%s",
+ ((BFA_LOG_S << BFA_LOG_ARG0) | 0), 1},
+
+{BFA_LOG_LINUX_DRIVER_AEN, BFA_LOG_ATTR_NONE | BFA_LOG_ATTR_LOG, BFA_LOG_INFO,
+ "LINUX_DRIVER_AEN",
+ "%s",
+ ((BFA_LOG_S << BFA_LOG_ARG0) | 0), 1},
+
 
 
 
diff -uprN a/drivers/scsi/bfa/bfa_lps.c b/drivers/scsi/bfa/bfa_lps.c
--- a/drivers/scsi/bfa/bfa_lps.c	2009-12-18 18:16:22.447686000 -0800
+++ b/drivers/scsi/bfa/bfa_lps.c	2009-11-25 18:21:07.000000000 -0800
@@ -18,6 +18,7 @@
 #include <bfa.h>
 #include <bfi/bfi_lps.h>
 #include <cs/bfa_debug.h>
+#include <defs/bfa_defs_pci.h>
 
 BFA_TRC_FILE(HAL, LPS);
 BFA_MODULE(lps);
@@ -25,6 +26,12 @@ BFA_MODULE(lps);
 #define BFA_LPS_MIN_LPORTS	(1)
 #define BFA_LPS_MAX_LPORTS	(256)
 
+/*
+ * Maximum Vports supported per physical port or vf.
+ */
+#define BFA_LPS_MAX_VPORTS_SUPP_CB  255
+#define BFA_LPS_MAX_VPORTS_SUPP_CT  190
+
 /**
  * forward declarations
  */
@@ -49,6 +56,7 @@ static void bfa_lps_send_login(struct bf
 static void bfa_lps_send_logout(struct bfa_lps_s *lps);
 static void bfa_lps_login_comp(struct bfa_lps_s *lps);
 static void bfa_lps_logout_comp(struct bfa_lps_s *lps);
+static void bfa_lps_cvl_event(struct bfa_lps_s *lps);
 
 
 /**
@@ -62,16 +70,17 @@ enum bfa_lps_event {
 	BFA_LPS_SM_RESUME	= 4,	/* space present in reqq queue	*/
 	BFA_LPS_SM_DELETE	= 5,	/* lps delete from user		*/
 	BFA_LPS_SM_OFFLINE	= 6,	/* Link is offline		*/
+	BFA_LPS_SM_RX_CVL	= 7, 	/* Rx clear virtual link	*/
 };
 
 static void bfa_lps_sm_init(struct bfa_lps_s *lps, enum bfa_lps_event event);
 static void bfa_lps_sm_login(struct bfa_lps_s *lps, enum bfa_lps_event event);
-static void bfa_lps_sm_loginwait(struct bfa_lps_s *lps,
-			enum bfa_lps_event event);
+static void bfa_lps_sm_loginwait(struct bfa_lps_s *lps, enum bfa_lps_event
+		event);
 static void bfa_lps_sm_online(struct bfa_lps_s *lps, enum bfa_lps_event event);
 static void bfa_lps_sm_logout(struct bfa_lps_s *lps, enum bfa_lps_event event);
-static void bfa_lps_sm_logowait(struct bfa_lps_s *lps,
-			enum bfa_lps_event event);
+static void bfa_lps_sm_logowait(struct bfa_lps_s *lps, enum bfa_lps_event
+		event);
 
 /**
  * Init state -- no login
@@ -91,6 +100,13 @@ bfa_lps_sm_init(struct bfa_lps_s *lps, e
 			bfa_sm_set_state(lps, bfa_lps_sm_login);
 			bfa_lps_send_login(lps);
 		}
+
+		if (lps->fdisc)
+			bfa_plog_str(lps->bfa->plog, BFA_PL_MID_LPS,
+				BFA_PL_EID_LOGIN, 0, "FDISC Request");
+		else
+			bfa_plog_str(lps->bfa->plog, BFA_PL_MID_LPS,
+				BFA_PL_EID_LOGIN, 0, "FLOGI Request");
 		break;
 
 	case BFA_LPS_SM_LOGOUT:
@@ -101,18 +117,20 @@ bfa_lps_sm_init(struct bfa_lps_s *lps, e
 		bfa_lps_free(lps);
 		break;
 
+	case BFA_LPS_SM_RX_CVL:
 	case BFA_LPS_SM_OFFLINE:
 		break;
 
 	case BFA_LPS_SM_FWRSP:
-		/* Could happen when fabric detects loopback and discards
+		/*
+		 * Could happen when fabric detects loopback and discards
 		 * the lps request. Fw will eventually sent out the timeout
 		 * Just ignore
 		 */
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(lps->bfa, event);
 	}
 }
 
@@ -127,10 +145,25 @@ bfa_lps_sm_login(struct bfa_lps_s *lps, 
 
 	switch (event) {
 	case BFA_LPS_SM_FWRSP:
-		if (lps->status == BFA_STATUS_OK)
+		if (lps->status == BFA_STATUS_OK) {
 			bfa_sm_set_state(lps, bfa_lps_sm_online);
-		else
+			if (lps->fdisc)
+				bfa_plog_str(lps->bfa->plog, BFA_PL_MID_LPS,
+					BFA_PL_EID_LOGIN, 0, "FDISC Accept");
+			else
+				bfa_plog_str(lps->bfa->plog, BFA_PL_MID_LPS,
+					BFA_PL_EID_LOGIN, 0, "FLOGI Accept");
+		} else {
 			bfa_sm_set_state(lps, bfa_lps_sm_init);
+			if (lps->fdisc)
+				bfa_plog_str(lps->bfa->plog, BFA_PL_MID_LPS,
+					BFA_PL_EID_LOGIN, 0,
+					"FDISC Fail (RJT or timeout)");
+			else
+				bfa_plog_str(lps->bfa->plog, BFA_PL_MID_LPS,
+					BFA_PL_EID_LOGIN, 0,
+					"FLOGI Fail (RJT or timeout)");
+		}
 		bfa_lps_login_comp(lps);
 		break;
 
@@ -139,7 +172,7 @@ bfa_lps_sm_login(struct bfa_lps_s *lps, 
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(lps->bfa, event);
 	}
 }
 
@@ -162,8 +195,16 @@ bfa_lps_sm_loginwait(struct bfa_lps_s *l
 		bfa_reqq_wcancel(&lps->wqe);
 		break;
 
+	case BFA_LPS_SM_RX_CVL:
+		/*
+		 * Login was not even sent out; so when getting out
+		 * of this state, it will appear like a login retry
+		 * after Clear virtual link
+		 */
+		break;
+
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(lps->bfa, event);
 	}
 }
 
@@ -185,6 +226,17 @@ bfa_lps_sm_online(struct bfa_lps_s *lps,
 			bfa_sm_set_state(lps, bfa_lps_sm_logout);
 			bfa_lps_send_logout(lps);
 		}
+		bfa_plog_str(lps->bfa->plog, BFA_PL_MID_LPS,
+			BFA_PL_EID_LOGO, 0, "Logout");
+		break;
+
+	case BFA_LPS_SM_RX_CVL:
+		bfa_sm_set_state(lps, bfa_lps_sm_init);
+
+		/* Let the vport module know about this event */
+		bfa_lps_cvl_event(lps);
+		bfa_plog_str(lps->bfa->plog, BFA_PL_MID_LPS,
+			BFA_PL_EID_FIP_FCF_CVL, 0, "FCF Clear Virt. Link Rx");
 		break;
 
 	case BFA_LPS_SM_OFFLINE:
@@ -193,7 +245,7 @@ bfa_lps_sm_online(struct bfa_lps_s *lps,
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(lps->bfa, event);
 	}
 }
 
@@ -217,7 +269,7 @@ bfa_lps_sm_logout(struct bfa_lps_s *lps,
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(lps->bfa, event);
 	}
 }
 
@@ -242,7 +294,7 @@ bfa_lps_sm_logowait(struct bfa_lps_s *lp
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(lps->bfa, event);
 	}
 }
 
@@ -256,7 +308,8 @@ bfa_lps_sm_logowait(struct bfa_lps_s *lp
  * return memory requirement
  */
 static void
-bfa_lps_meminfo(struct bfa_iocfc_cfg_s *cfg, u32 *ndm_len, u32 *dm_len)
+bfa_lps_meminfo(struct bfa_iocfc_cfg_s *cfg, u32 *ndm_len,
+	u32 *dm_len)
 {
 	if (cfg->drvcfg.min_cfg)
 		*ndm_len += sizeof(struct bfa_lps_s) * BFA_LPS_MIN_LPORTS;
@@ -269,7 +322,7 @@ bfa_lps_meminfo(struct bfa_iocfc_cfg_s *
  */
 static void
 bfa_lps_attach(struct bfa_s *bfa, void *bfad, struct bfa_iocfc_cfg_s *cfg,
-		struct bfa_meminfo_s *meminfo, struct bfa_pcidev_s *pcidev)
+	struct bfa_meminfo_s *meminfo, struct bfa_pcidev_s *pcidev)
 {
 	struct bfa_lps_mod_s	*mod = BFA_LPS_MOD(bfa);
 	struct bfa_lps_s	*lps;
@@ -396,6 +449,20 @@ bfa_lps_logout_rsp(struct bfa_s *bfa, st
 }
 
 /**
+ * Firmware received a Clear virtual link request (for FCoE)
+ */
+static void
+bfa_lps_rx_cvl_event(struct bfa_s *bfa, struct bfi_lps_cvl_event_s *cvl)
+{
+	struct bfa_lps_mod_s	*mod = BFA_LPS_MOD(bfa);
+	struct bfa_lps_s	*lps;
+
+	lps = BFA_LPS_FROM_TAG(mod, cvl->lp_tag);
+
+	bfa_sm_send_event(lps, BFA_LPS_SM_RX_CVL);
+}
+
+/**
  * Space is available in request queue, resume queueing request to firmware.
  */
 static void
@@ -414,6 +481,7 @@ bfa_lps_free(struct bfa_lps_s *lps)
 {
 	struct bfa_lps_mod_s	*mod = BFA_LPS_MOD(lps->bfa);
 
+	lps->lp_pid = 0;
 	list_del(&lps->qe);
 	list_add_tail(&lps->qe, &mod->lps_free_q);
 }
@@ -430,7 +498,7 @@ bfa_lps_send_login(struct bfa_lps_s *lps
 	bfa_assert(m);
 
 	bfi_h2i_set(m->mh, BFI_MC_LPS, BFI_LPS_H2I_LOGIN_REQ,
-			bfa_lpuid(lps->bfa));
+		bfa_lpuid(lps->bfa));
 
 	m->lp_tag	= lps->lp_tag;
 	m->alpa		= lps->alpa;
@@ -455,7 +523,7 @@ bfa_lps_send_logout(struct bfa_lps_s *lp
 	bfa_assert(m);
 
 	bfi_h2i_set(m->mh, BFI_MC_LPS, BFI_LPS_H2I_LOGOUT_REQ,
-			bfa_lpuid(lps->bfa));
+		bfa_lpuid(lps->bfa));
 
 	m->lp_tag    = lps->lp_tag;
 	m->port_name = lps->pwwn;
@@ -486,8 +554,8 @@ static void
 bfa_lps_login_comp(struct bfa_lps_s *lps)
 {
 	if (!lps->bfa->fcs) {
-		bfa_cb_queue(lps->bfa, &lps->hcb_qe,
-				bfa_lps_login_comp_cb, lps);
+		bfa_cb_queue(lps->bfa, &lps->hcb_qe, bfa_lps_login_comp_cb,
+			lps);
 		return;
 	}
 
@@ -521,8 +589,8 @@ static void
 bfa_lps_logout_comp(struct bfa_lps_s *lps)
 {
 	if (!lps->bfa->fcs) {
-		bfa_cb_queue(lps->bfa, &lps->hcb_qe,
-				bfa_lps_logout_comp_cb, lps);
+		bfa_cb_queue(lps->bfa, &lps->hcb_qe, bfa_lps_logout_comp_cb,
+			lps);
 		return;
 	}
 	if (lps->fdisc)
@@ -531,12 +599,55 @@ bfa_lps_logout_comp(struct bfa_lps_s *lp
 		bfa_cb_lps_flogo_comp(lps->bfa->bfad, lps->uarg);
 }
 
+/**
+ * Clear virtual link completion handler for non-fcs
+ */
+static void
+bfa_lps_cvl_event_cb(void *arg, bfa_boolean_t complete)
+{
+	struct bfa_lps_s *lps	= arg;
+
+	if (!complete)
+		return;
+
+	/* Clear virtual link to base port will result in link down */
+	if (lps->fdisc)
+		bfa_cb_lps_cvl_event(lps->bfa->bfad, lps->uarg);
+}
+
+/**
+ * Received Clear virtual link event --direct call for fcs,
+ * queue for others
+ */
+static void
+bfa_lps_cvl_event(struct bfa_lps_s *lps)
+{
+	if (!lps->bfa->fcs) {
+		bfa_cb_queue(lps->bfa, &lps->hcb_qe, bfa_lps_cvl_event_cb,
+			lps);
+		return;
+	}
+
+	/* Clear virtual link to base port will result in link down */
+	if (lps->fdisc)
+		bfa_cb_lps_cvl_event(lps->bfa->bfad, lps->uarg);
+}
+
 
 
 /**
  *  lps_public BFA LPS public functions
  */
 
+u32
+bfa_lps_get_max_vport(struct bfa_s *bfa)
+{
+	if (bfa_ioc_devid(&bfa->ioc) == BFA_PCI_DEVICE_ID_CT)
+		return BFA_LPS_MAX_VPORTS_SUPP_CT;
+	else
+		return BFA_LPS_MAX_VPORTS_SUPP_CB;
+}
+
 /**
  * Allocate a lport srvice tag.
  */
@@ -752,6 +863,14 @@ bfa_lps_get_lsrjt_expl(struct bfa_lps_s 
 	return lps->lsrjt_expl;
 }
 
+/**
+ * Return fpma/spma MAC for lport
+ */
+struct mac_s
+bfa_lps_get_lp_mac(struct bfa_lps_s *lps)
+{
+	return lps->lp_mac;
+}
 
 /**
  * LPS firmware message class handler.
@@ -773,6 +892,10 @@ bfa_lps_isr(struct bfa_s *bfa, struct bf
 		bfa_lps_logout_rsp(bfa, msg.logout_rsp);
 		break;
 
+	case BFI_LPS_H2I_CVL_EVENT:
+		bfa_lps_rx_cvl_event(bfa, msg.cvl_event);
+		break;
+
 	default:
 		bfa_trc(bfa, m->mhdr.msg_id);
 		bfa_assert(0);
diff -uprN a/drivers/scsi/bfa/bfa_module.c b/drivers/scsi/bfa/bfa_module.c
--- a/drivers/scsi/bfa/bfa_module.c	2009-12-18 18:16:22.437686000 -0800
+++ b/drivers/scsi/bfa/bfa_module.c	2009-11-25 18:21:07.000000000 -0800
@@ -24,7 +24,7 @@
  */
 struct bfa_module_s *hal_mods[] = {
 	&hal_mod_sgpg,
-	&hal_mod_pport,
+	&hal_mod_fcport,
 	&hal_mod_fcxp,
 	&hal_mod_lps,
 	&hal_mod_uf,
@@ -45,7 +45,7 @@ bfa_isr_func_t  bfa_isrs[BFI_MC_MAX] = {
 	bfa_isr_unhandled,	/* BFI_MC_DIAG */
 	bfa_isr_unhandled,	/* BFI_MC_FLASH */
 	bfa_isr_unhandled,	/* BFI_MC_CEE */
-	bfa_pport_isr,		/* BFI_MC_PORT */
+	bfa_fcport_isr,		/* BFI_MC_FCPORT */
 	bfa_isr_unhandled,	/* BFI_MC_IOCFC */
 	bfa_isr_unhandled,	/* BFI_MC_LL */
 	bfa_uf_isr,		/* BFI_MC_UF */
diff -uprN a/drivers/scsi/bfa/bfa_modules_priv.h b/drivers/scsi/bfa/bfa_modules_priv.h
--- a/drivers/scsi/bfa/bfa_modules_priv.h	2009-12-18 18:16:22.435689000 -0800
+++ b/drivers/scsi/bfa/bfa_modules_priv.h	2009-11-25 18:06:50.000000000 -0800
@@ -29,15 +29,15 @@
 
 
 struct bfa_modules_s {
-	struct bfa_pport_s	pport;	/*  physical port module	*/
-	struct bfa_fcxp_mod_s fcxp_mod; /*  fcxp module		*/
-	struct bfa_lps_mod_s lps_mod;   /*  fcxp module		*/
-	struct bfa_uf_mod_s uf_mod;	/*  unsolicited frame module	*/
-	struct bfa_rport_mod_s rport_mod; /*  remote port module	*/
-	struct bfa_fcpim_mod_s fcpim_mod; /*  FCP initiator module	*/
-	struct bfa_sgpg_mod_s sgpg_mod; /*  SG page module		*/
-	struct bfa_cee_s cee;   	/*  CEE Module                 */
-	struct bfa_port_s port;		/*  Physical port module	*/
+	struct bfa_fcport_s	fcport;		/*  fc port module	      */
+	struct bfa_fcxp_mod_s	fcxp_mod;	/*  fcxp module	      */
+	struct bfa_lps_mod_s	lps_mod;	/*  fcxp module	      */
+	struct bfa_uf_mod_s	uf_mod;		/*  unsolicited frame module */
+	struct bfa_rport_mod_s	rport_mod;	/*  remote port module	      */
+	struct bfa_fcpim_mod_s	fcpim_mod;	/*  FCP initiator module     */
+	struct bfa_sgpg_mod_s	sgpg_mod;	/*  SG page module	      */
+	struct bfa_cee_s        cee;            /*  CEE Module               */
+	struct bfa_port_s	port;		/*  Physical port module     */
 };
 
 #endif /* __BFA_MODULES_PRIV_H__ */
diff -uprN a/drivers/scsi/bfa/bfa_port.c b/drivers/scsi/bfa/bfa_port.c
--- a/drivers/scsi/bfa/bfa_port.c	2009-12-18 18:16:22.431687000 -0800
+++ b/drivers/scsi/bfa/bfa_port.c	2009-11-25 18:21:07.000000000 -0800
@@ -14,6 +14,12 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * General Public License for more details.
  */
+/*
+ *      Copyright (c) 2007-2009 Brocade Communications Systems, Inc.
+ *      All rights reserved.
+ *
+ *      @file bfa_port.c Port module source file.
+ */
 
 #include <defs/bfa_defs_port.h>
 #include <cs/bfa_trc.h>
@@ -33,12 +39,11 @@ BFA_TRC_FILE(CNA, PORT);
 static void
 bfa_port_stats_swap(struct bfa_port_s *port, union bfa_pport_stats_u *stats)
 {
-	u32       *dip = (u32 *) stats;
-	u32        t0, t1;
-	int             i;
+	u32    *dip = (u32 *) stats;
+	u32    t0, t1;
+	int         i;
 
-	for (i = 0; i < sizeof(union bfa_pport_stats_u) / sizeof(u32);
-	     i += 2) {
+	for (i = 0; i < sizeof(union bfa_pport_stats_u)/sizeof(u32); i += 2) {
 		t0 = dip[i];
 		t1 = dip[i + 1];
 #ifdef __BIGENDIAN
@@ -48,9 +53,9 @@ bfa_port_stats_swap(struct bfa_port_s *p
 		dip[i] = bfa_os_ntohl(t1);
 		dip[i + 1] = bfa_os_ntohl(t0);
 #endif
-	}
+    }
 
-    /** todo
+    /** @todo
      * QoS stats r also swapped as 64bit; that structure also
      * has to use 64 bit counters
      */
@@ -103,7 +108,7 @@ bfa_port_get_stats_isr(struct bfa_port_s
 
 	if (status == BFA_STATUS_OK) {
 		memcpy(port->stats, port->stats_dma.kva,
-		       sizeof(union bfa_pport_stats_u));
+				sizeof(union bfa_pport_stats_u));
 		bfa_port_stats_swap(port, port->stats);
 	}
 
@@ -126,7 +131,7 @@ static void
 bfa_port_clear_stats_isr(struct bfa_port_s *port, bfa_status_t status)
 {
 	port->stats_status = status;
-	port->stats_busy = BFA_FALSE;
+	port->stats_busy   = BFA_FALSE;
 
 	if (port->stats_cbfn) {
 		port->stats_cbfn(port->stats_cbarg, status);
@@ -145,10 +150,10 @@ bfa_port_clear_stats_isr(struct bfa_port
 static void
 bfa_port_isr(void *cbarg, struct bfi_mbmsg_s *m)
 {
-	struct bfa_port_s *port = (struct bfa_port_s *)cbarg;
+	struct bfa_port_s *port = (struct bfa_port_s *) cbarg;
 	union bfi_port_i2h_msg_u *i2hmsg;
 
-	i2hmsg = (union bfi_port_i2h_msg_u *)m;
+	i2hmsg = (union bfi_port_i2h_msg_u *) m;
 	bfa_trc(port, m->mh.msg_id);
 
 	switch (m->mh.msg_id) {
@@ -165,9 +170,7 @@ bfa_port_isr(void *cbarg, struct bfi_mbm
 		break;
 
 	case BFI_PORT_I2H_GET_STATS_RSP:
-		/*
-		 * Stats busy flag is still set? (may be cmd timed out)
-		 */
+		/* Stats busy flag is still set? (may be cmd timed out) */
 		if (port->stats_busy == BFA_FALSE)
 			break;
 		bfa_port_get_stats_isr(port, i2hmsg->getstats_rsp.status);
@@ -203,8 +206,8 @@ bfa_port_meminfo(void)
  *
  *
  * @param[in] port Port module pointer
- * 	      dma_kva Kernel Virtual Address of Port DMA Memory
- * 	      dma_pa  Physical Address of Port DMA Memory
+ *	      dma_kva Kernel Virtual Address of Port DMA Memory
+ *	      dma_pa  Physical Address of Port DMA Memory
  *
  * @return void
  */
@@ -212,7 +215,7 @@ void
 bfa_port_mem_claim(struct bfa_port_s *port, u8 *dma_kva, u64 dma_pa)
 {
 	port->stats_dma.kva = dma_kva;
-	port->stats_dma.pa = dma_pa;
+	port->stats_dma.pa  = dma_pa;
 }
 
 /**
@@ -226,11 +229,11 @@ bfa_port_mem_claim(struct bfa_port_s *po
  */
 bfa_status_t
 bfa_port_enable(struct bfa_port_s *port, bfa_port_endis_cbfn_t cbfn,
-		void *cbarg)
+		 void *cbarg)
 {
 	struct bfi_port_generic_req_s *m;
 
-	/** todo Not implemented */
+	/** @todo Not implemented */
 	bfa_assert(0);
 
 	if (!bfa_ioc_is_operational(port->ioc)) {
@@ -240,14 +243,14 @@ bfa_port_enable(struct bfa_port_s *port,
 
 	if (port->endis_pending) {
 		bfa_trc(port, BFA_STATUS_DEVBUSY);
-		return BFA_STATUS_DEVBUSY;
+		return 	BFA_STATUS_DEVBUSY;
 	}
 
-	m = (struct bfi_port_generic_req_s *)port->endis_mb.msg;
+	m = (struct bfi_port_generic_req_s *) port->endis_mb.msg;
 
 	port->msgtag++;
-	port->endis_cbfn = cbfn;
-	port->endis_cbarg = cbarg;
+	port->endis_cbfn    = cbfn;
+	port->endis_cbarg   = cbarg;
 	port->endis_pending = BFA_TRUE;
 
 	bfi_h2i_set(m->mh, BFI_MC_PORT, BFI_PORT_H2I_ENABLE_REQ,
@@ -268,11 +271,11 @@ bfa_port_enable(struct bfa_port_s *port,
  */
 bfa_status_t
 bfa_port_disable(struct bfa_port_s *port, bfa_port_endis_cbfn_t cbfn,
-		 void *cbarg)
+		  void *cbarg)
 {
 	struct bfi_port_generic_req_s *m;
 
-	/** todo Not implemented */
+	/** @todo Not implemented */
 	bfa_assert(0);
 
 	if (!bfa_ioc_is_operational(port->ioc)) {
@@ -282,14 +285,14 @@ bfa_port_disable(struct bfa_port_s *port
 
 	if (port->endis_pending) {
 		bfa_trc(port, BFA_STATUS_DEVBUSY);
-		return BFA_STATUS_DEVBUSY;
+		return 	BFA_STATUS_DEVBUSY;
 	}
 
-	m = (struct bfi_port_generic_req_s *)port->endis_mb.msg;
+	m = (struct bfi_port_generic_req_s *) port->endis_mb.msg;
 
 	port->msgtag++;
-	port->endis_cbfn = cbfn;
-	port->endis_cbarg = cbarg;
+	port->endis_cbfn    = cbfn;
+	port->endis_cbarg   = cbarg;
 	port->endis_pending = BFA_TRUE;
 
 	bfi_h2i_set(m->mh, BFI_MC_PORT, BFI_PORT_H2I_DISABLE_REQ,
@@ -310,7 +313,7 @@ bfa_port_disable(struct bfa_port_s *port
  */
 bfa_status_t
 bfa_port_get_stats(struct bfa_port_s *port, union bfa_pport_stats_u *stats,
-		   bfa_port_stats_cbfn_t cbfn, void *cbarg)
+		    bfa_port_stats_cbfn_t cbfn, void *cbarg)
 {
 	struct bfi_port_get_stats_req_s *m;
 
@@ -321,15 +324,15 @@ bfa_port_get_stats(struct bfa_port_s *po
 
 	if (port->stats_busy) {
 		bfa_trc(port, BFA_STATUS_DEVBUSY);
-		return BFA_STATUS_DEVBUSY;
+		return 	BFA_STATUS_DEVBUSY;
 	}
 
-	m = (struct bfi_port_get_stats_req_s *)port->stats_mb.msg;
+	m = (struct bfi_port_get_stats_req_s *) port->stats_mb.msg;
 
-	port->stats = stats;
-	port->stats_cbfn = cbfn;
+	port->stats	  = stats;
+	port->stats_cbfn  = cbfn;
 	port->stats_cbarg = cbarg;
-	port->stats_busy = BFA_TRUE;
+	port->stats_busy  = BFA_TRUE;
 	bfa_dma_be_addr_set(m->dma_addr, port->stats_dma.pa);
 
 	bfi_h2i_set(m->mh, BFI_MC_PORT, BFI_PORT_H2I_GET_STATS_REQ,
@@ -349,7 +352,7 @@ bfa_port_get_stats(struct bfa_port_s *po
  */
 bfa_status_t
 bfa_port_clear_stats(struct bfa_port_s *port, bfa_port_stats_cbfn_t cbfn,
-		     void *cbarg)
+		      void *cbarg)
 {
 	struct bfi_port_generic_req_s *m;
 
@@ -360,14 +363,14 @@ bfa_port_clear_stats(struct bfa_port_s *
 
 	if (port->stats_busy) {
 		bfa_trc(port, BFA_STATUS_DEVBUSY);
-		return BFA_STATUS_DEVBUSY;
+		return 	BFA_STATUS_DEVBUSY;
 	}
 
-	m = (struct bfi_port_generic_req_s *)port->stats_mb.msg;
+	m = (struct bfi_port_generic_req_s *) port->stats_mb.msg;
 
-	port->stats_cbfn = cbfn;
+	port->stats_cbfn  = cbfn;
 	port->stats_cbarg = cbarg;
-	port->stats_busy = BFA_TRUE;
+	port->stats_busy  = BFA_TRUE;
 
 	bfi_h2i_set(m->mh, BFI_MC_PORT, BFI_PORT_H2I_CLEAR_STATS_REQ,
 		    bfa_ioc_portid(port->ioc));
@@ -387,11 +390,9 @@ bfa_port_clear_stats(struct bfa_port_s *
 void
 bfa_port_hbfail(void *arg)
 {
-	struct bfa_port_s *port = (struct bfa_port_s *)arg;
+	struct bfa_port_s *port = (struct bfa_port_s *) arg;
 
-	/*
-	 * Fail any pending get_stats/clear_stats requests
-	 */
+	/* Fail any pending get_stats/clear_stats requests */
 	if (port->stats_busy) {
 		if (port->stats_cbfn)
 			port->stats_cbfn(port->dev, BFA_STATUS_FAILED);
@@ -399,9 +400,7 @@ bfa_port_hbfail(void *arg)
 		port->stats_busy = BFA_FALSE;
 	}
 
-	/*
-	 * Clear any enable/disable is pending
-	 */
+	/* Clear any enable/disable is pending */
 	if (port->endis_pending) {
 		if (port->endis_cbfn)
 			port->endis_cbfn(port->dev, BFA_STATUS_FAILED);
@@ -425,18 +424,21 @@ bfa_port_hbfail(void *arg)
  * @return void
  */
 void
-bfa_port_attach(struct bfa_port_s *port, struct bfa_ioc_s *ioc, void *dev,
-		struct bfa_trc_mod_s *trcmod, struct bfa_log_mod_s *logmod)
+bfa_port_attach(struct bfa_port_s *port, struct bfa_ioc_s *ioc,
+		 void *dev, struct bfa_trc_mod_s *trcmod,
+		 struct bfa_log_mod_s *logmod)
 {
 	bfa_assert(port);
 
-	port->dev = dev;
-	port->ioc = ioc;
+	port->dev    = dev;
+	port->ioc    = ioc;
 	port->trcmod = trcmod;
 	port->logmod = logmod;
 
-	port->stats_busy = port->endis_pending = BFA_FALSE;
-	port->stats_cbfn = port->endis_cbfn = NULL;
+	port->stats_busy =
+	port->endis_pending = BFA_FALSE;
+	port->stats_cbfn =
+	port->endis_cbfn = NULL;
 
 	bfa_ioc_mbox_regisr(port->ioc, BFI_MC_PORT, bfa_port_isr, port);
 	bfa_ioc_hbfail_init(&port->hbfail, bfa_port_hbfail, port);
diff -uprN a/drivers/scsi/bfa/bfa_port_priv.h b/drivers/scsi/bfa/bfa_port_priv.h
--- a/drivers/scsi/bfa/bfa_port_priv.h	2009-12-18 18:16:22.430684000 -0800
+++ b/drivers/scsi/bfa/bfa_port_priv.h	2009-11-25 18:06:50.000000000 -0800
@@ -23,9 +23,19 @@
 #include "bfa_intr_priv.h"
 
 /**
- * BFA physical port data structure
+ * Link notification data structure
  */
-struct bfa_pport_s {
+struct bfa_fcport_ln_s {
+	struct bfa_fcport_s	*fcport;
+	bfa_sm_t		sm;
+	struct bfa_cb_qe_s	ln_qe;	/*  BFA callback queue elem for ln */
+	enum bfa_pport_linkstate ln_event; /*  ln event for callback */
+};
+
+/**
+ * BFA FC port data structure
+ */
+struct bfa_fcport_s {
 	struct bfa_s 		*bfa;	/*  parent BFA instance */
 	bfa_sm_t		sm;	/*  port state machine */
 	wwn_t			nwwn;	/*  node wwn of physical port */
@@ -36,6 +46,8 @@ struct bfa_pport_s {
 	enum bfa_pport_topology topology;	/*  current topology */
 	u8			myalpa;	/*  my ALPA in LOOP topology */
 	u8			rsvd[3];
+	u32		mypid:24;
+	u32		rsvd_b:8;
 	struct bfa_pport_cfg_s	cfg;	/*  current port configuration */
 	struct bfa_qos_attr_s  qos_attr;   /* QoS Attributes */
 	struct bfa_qos_vc_attr_s qos_vc_attr;  /*  VC info from ELP */
@@ -49,42 +61,31 @@ struct bfa_pport_s {
 	void			(*event_cbfn) (void *cbarg,
 						bfa_pport_event_t event);
 	union {
-		union bfi_pport_i2h_msg_u i2hmsg;
+		union bfi_fcport_i2h_msg_u i2hmsg;
 	} event_arg;
 	void			*bfad;	/*  BFA driver handle */
-	struct bfa_cb_qe_s		hcb_qe;	/*  BFA callback queue elem */
-	enum bfa_pport_linkstate	hcb_event;
-					/*  link event for callback */
+	struct bfa_fcport_ln_s	ln; /*  Link Notification */
+	struct bfa_cb_qe_s	hcb_qe;	/*  BFA callback queue elem */
+	struct bfa_timer_s 	timer;	/*  timer */
 	u32		msgtag;	/*  fimrware msg tag for reply */
 	u8			*stats_kva;
 	u64		stats_pa;
-	union bfa_pport_stats_u *stats;	/*  pport stats */
-	u32		mypid : 24;
-	u32		rsvd_b : 8;
-	struct bfa_timer_s 	timer;	/*  timer */
-	union bfa_pport_stats_u 	*stats_ret;
-					/*  driver stats location */
-	bfa_status_t		stats_status;
-					/*  stats/statsclr status */
-	bfa_boolean_t   	stats_busy;
-					/*  outstanding stats/statsclr */
+	union bfa_fcport_stats_u *stats;
+	union bfa_fcport_stats_u *stats_ret; /*  driver stats location */
+	bfa_status_t		stats_status; /*  stats/statsclr status */
+	bfa_boolean_t   	stats_busy; /*  outstanding stats/statsclr */
 	bfa_boolean_t   	stats_qfull;
-	bfa_boolean_t   	diag_busy;
-					/*  diag busy status */
-	bfa_boolean_t   	beacon;
-					/*  port beacon status */
-	bfa_boolean_t   	link_e2e_beacon;
-					/*  link beacon status */
-	bfa_cb_pport_t		stats_cbfn;
-					/*  driver callback function */
-	void			*stats_cbarg;
-					/* *!< user callback arg */
+	bfa_cb_pport_t		stats_cbfn; /*  driver callback function */
+	void			*stats_cbarg; /* *!< user callback arg */
+	bfa_boolean_t   	diag_busy; /*  diag busy status */
+	bfa_boolean_t   	beacon; /*  port beacon status */
+	bfa_boolean_t   	link_e2e_beacon; /*  link beacon status */
 };
 
-#define BFA_PORT_MOD(__bfa)	(&(__bfa)->modules.pport)
+#define BFA_FCPORT_MOD(__bfa)	(&(__bfa)->modules.fcport)
 
 /*
  * public functions
  */
-void	bfa_pport_isr(struct bfa_s *bfa, struct bfi_msg_s *msg);
+void	bfa_fcport_isr(struct bfa_s *bfa, struct bfi_msg_s *msg);
 #endif /* __BFA_PORT_PRIV_H__ */
diff -uprN a/drivers/scsi/bfa/bfa_priv.h b/drivers/scsi/bfa/bfa_priv.h
--- a/drivers/scsi/bfa/bfa_priv.h	2009-12-18 18:16:22.428685000 -0800
+++ b/drivers/scsi/bfa/bfa_priv.h	2009-11-25 18:06:50.000000000 -0800
@@ -88,7 +88,7 @@ struct bfa_s {
 	struct bfa_iocfc_s	iocfc;		/*  IOCFC module	    */
 	struct bfa_timer_mod_s	timer_mod;	/*  timer module	    */
 	struct bfa_modules_s	modules;	/*  BFA modules	    */
-	struct list_head	comp_q;		/*  pending completions    */
+	struct list_head		comp_q;	/*  pending completions    */
 	bfa_boolean_t		rme_process;	/*  RME processing enabled */
 	struct list_head		reqq_waitq[BFI_IOC_MAX_CQS];
 	bfa_boolean_t		fcs;		/*  FCS is attached to BFA */
@@ -101,7 +101,7 @@ extern bfa_boolean_t bfa_auto_recover;
 extern struct bfa_module_s hal_mod_flash;
 extern struct bfa_module_s hal_mod_fcdiag;
 extern struct bfa_module_s hal_mod_sgpg;
-extern struct bfa_module_s hal_mod_pport;
+extern struct bfa_module_s hal_mod_fcport;
 extern struct bfa_module_s hal_mod_fcxp;
 extern struct bfa_module_s hal_mod_lps;
 extern struct bfa_module_s hal_mod_uf;
diff -uprN a/drivers/scsi/bfa/bfa_rport.c b/drivers/scsi/bfa/bfa_rport.c
--- a/drivers/scsi/bfa/bfa_rport.c	2009-12-18 18:16:22.426685000 -0800
+++ b/drivers/scsi/bfa/bfa_rport.c	2009-11-25 18:21:07.000000000 -0800
@@ -46,12 +46,14 @@ BFA_MODULE(rport);
  * forward declarations
  */
 static struct bfa_rport_s *bfa_rport_alloc(struct bfa_rport_mod_s *rp_mod);
-static void bfa_rport_free(struct bfa_rport_s *rport);
-static bfa_boolean_t bfa_rport_send_fwcreate(struct bfa_rport_s *rp);
-static bfa_boolean_t bfa_rport_send_fwdelete(struct bfa_rport_s *rp);
-static bfa_boolean_t bfa_rport_send_fwspeed(struct bfa_rport_s *rp);
-static void __bfa_cb_rport_online(void *cbarg, bfa_boolean_t complete);
-static void __bfa_cb_rport_offline(void *cbarg, bfa_boolean_t complete);
+static void		bfa_rport_free(struct bfa_rport_s *rport);
+static bfa_boolean_t 	bfa_rport_send_fwcreate(struct bfa_rport_s *rp);
+static bfa_boolean_t	bfa_rport_send_fwdelete(struct bfa_rport_s *rp);
+static bfa_boolean_t	bfa_rport_send_fwspeed(struct bfa_rport_s *rp);
+static void		__bfa_cb_rport_online(void *cbarg,
+							bfa_boolean_t complete);
+static void		__bfa_cb_rport_offline(void *cbarg,
+							bfa_boolean_t complete);
 
 /**
  *  bfa_rport_sm BFA rport state machine
@@ -114,7 +116,7 @@ bfa_rport_sm_uninit(struct bfa_rport_s *
 
 	default:
 		bfa_stats(rp, sm_un_unexp);
-		bfa_assert(0);
+		bfa_sm_fault(rp->bfa, event);
 	}
 }
 
@@ -146,7 +148,7 @@ bfa_rport_sm_created(struct bfa_rport_s 
 
 	default:
 		bfa_stats(rp, sm_cr_unexp);
-		bfa_assert(0);
+		bfa_sm_fault(rp->bfa, event);
 	}
 }
 
@@ -183,7 +185,7 @@ bfa_rport_sm_fwcreate(struct bfa_rport_s
 
 	default:
 		bfa_stats(rp, sm_fwc_unexp);
-		bfa_assert(0);
+		bfa_sm_fault(rp->bfa, event);
 	}
 }
 
@@ -224,7 +226,7 @@ bfa_rport_sm_fwcreate_qfull(struct bfa_r
 
 	default:
 		bfa_stats(rp, sm_fwc_unexp);
-		bfa_assert(0);
+		bfa_sm_fault(rp->bfa, event);
 	}
 }
 
@@ -296,7 +298,7 @@ bfa_rport_sm_online(struct bfa_rport_s *
 
 	default:
 		bfa_stats(rp, sm_on_unexp);
-		bfa_assert(0);
+		bfa_sm_fault(rp->bfa, event);
 	}
 }
 
@@ -329,7 +331,7 @@ bfa_rport_sm_fwdelete(struct bfa_rport_s
 
 	default:
 		bfa_stats(rp, sm_fwd_unexp);
-		bfa_assert(0);
+		bfa_sm_fault(rp->bfa, event);
 	}
 }
 
@@ -359,7 +361,7 @@ bfa_rport_sm_fwdelete_qfull(struct bfa_r
 
 	default:
 		bfa_stats(rp, sm_fwd_unexp);
-		bfa_assert(0);
+		bfa_sm_fault(rp->bfa, event);
 	}
 }
 
@@ -394,7 +396,7 @@ bfa_rport_sm_offline(struct bfa_rport_s 
 
 	default:
 		bfa_stats(rp, sm_off_unexp);
-		bfa_assert(0);
+		bfa_sm_fault(rp->bfa, event);
 	}
 }
 
@@ -421,7 +423,7 @@ bfa_rport_sm_deleting(struct bfa_rport_s
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(rp->bfa, event);
 	}
 }
 
@@ -446,7 +448,7 @@ bfa_rport_sm_deleting_qfull(struct bfa_r
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(rp->bfa, event);
 	}
 }
 
@@ -477,7 +479,7 @@ bfa_rport_sm_delete_pending(struct bfa_r
 
 	default:
 		bfa_stats(rp, sm_delp_unexp);
-		bfa_assert(0);
+		bfa_sm_fault(rp->bfa, event);
 	}
 }
 
@@ -512,7 +514,7 @@ bfa_rport_sm_offline_pending(struct bfa_
 
 	default:
 		bfa_stats(rp, sm_offp_unexp);
-		bfa_assert(0);
+		bfa_sm_fault(rp->bfa, event);
 	}
 }
 
@@ -550,7 +552,7 @@ bfa_rport_sm_iocdisable(struct bfa_rport
 
 	default:
 		bfa_stats(rp, sm_iocd_unexp);
-		bfa_assert(0);
+		bfa_sm_fault(rp->bfa, event);
 	}
 }
 
@@ -677,7 +679,7 @@ bfa_rport_alloc(struct bfa_rport_mod_s *
 	if (rport)
 		list_add_tail(&rport->qe, &mod->rp_active_q);
 
-	return (rport);
+	return rport;
 }
 
 static void
@@ -834,7 +836,7 @@ bfa_rport_create(struct bfa_s *bfa, void
 	rp = bfa_rport_alloc(BFA_RPORT_MOD(bfa));
 
 	if (rp == NULL)
-		return (NULL);
+		return NULL;
 
 	rp->bfa = bfa;
 	rp->rport_drv = rport_drv;
@@ -843,7 +845,7 @@ bfa_rport_create(struct bfa_s *bfa, void
 	bfa_assert(bfa_sm_cmp_state(rp, bfa_rport_sm_uninit));
 	bfa_sm_send_event(rp, BFA_RPORT_SM_CREATE);
 
-	return (rp);
+	return rp;
 }
 
 void
diff -uprN a/drivers/scsi/bfa/bfa_sgpg_priv.h b/drivers/scsi/bfa/bfa_sgpg_priv.h
--- a/drivers/scsi/bfa/bfa_sgpg_priv.h	2009-12-18 18:16:22.421683000 -0800
+++ b/drivers/scsi/bfa/bfa_sgpg_priv.h	2009-11-25 18:06:50.000000000 -0800
@@ -33,7 +33,7 @@
 			& ~(sizeof(struct bfi_sgpg_s) - 1))
 
 struct bfa_sgpg_wqe_s {
-	struct list_head qe;	/*  queue sg page element	*/
+	struct list_head qe;		/*  queue sg page element	*/
 	int	nsgpg;		/*  pages to be allocated	*/
 	int	nsgpg_total;	/*  total pages required	*/
 	void	(*cbfn) (void *cbarg);
@@ -44,7 +44,7 @@ struct bfa_sgpg_wqe_s {
 
 struct bfa_sgpg_s {
 	struct list_head 	qe;	/*  queue sg page element	*/
-	struct bfi_sgpg_s *sgpg; /*  va of SG page		*/
+	struct bfi_sgpg_s *sgpg;	/*  va of SG page		*/
 	union bfi_addr_u sgpg_pa;/*  pa of SG page		*/
 };
 
@@ -58,11 +58,11 @@ struct bfa_sgpg_mod_s {
 	struct bfa_s *bfa;
 	int		num_sgpgs;	/*  number of SG pages		*/
 	int		free_sgpgs;	/*  number of free SG pages	*/
-	struct bfa_sgpg_s *hsgpg_arr;	/*  BFA SG page array	*/
+	struct bfa_sgpg_s	*hsgpg_arr;	/*  BFA SG page array	*/
 	struct bfi_sgpg_s *sgpg_arr;	/*  actual SG page array	*/
 	u64	sgpg_arr_pa;	/*  SG page array DMA addr	*/
-	struct list_head sgpg_q;	/*  queue of free SG pages	*/
-	struct list_head sgpg_wait_q; /*  wait queue for SG pages	*/
+	struct list_head 	sgpg_q;		/*  queue of free SG pages */
+	struct list_head 	sgpg_wait_q;	/*  wait queue for SG pages */
 };
 #define BFA_SGPG_MOD(__bfa)	(&(__bfa)->modules.sgpg_mod)
 
diff -uprN a/drivers/scsi/bfa/bfa_trcmod_priv.h b/drivers/scsi/bfa/bfa_trcmod_priv.h
--- a/drivers/scsi/bfa/bfa_trcmod_priv.h	2009-12-18 18:16:22.415688000 -0800
+++ b/drivers/scsi/bfa/bfa_trcmod_priv.h	2009-11-25 18:06:50.000000000 -0800
@@ -29,38 +29,36 @@
  * !!! needed between trace utility and driver version
  */
 enum {
-	BFA_TRC_HAL_IOC		= 1,
-	BFA_TRC_HAL_INTR	= 2,
-	BFA_TRC_HAL_FCXP	= 3,
-	BFA_TRC_HAL_UF		= 4,
-	BFA_TRC_HAL_DIAG	= 5,
-	BFA_TRC_HAL_RPORT	= 6,
-	BFA_TRC_HAL_FCPIM	= 7,
-	BFA_TRC_HAL_IOIM	= 8,
-	BFA_TRC_HAL_TSKIM	= 9,
-	BFA_TRC_HAL_ITNIM	= 10,
-	BFA_TRC_HAL_PPORT	= 11,
-	BFA_TRC_HAL_SGPG	= 12,
-	BFA_TRC_HAL_FLASH	= 13,
-	BFA_TRC_HAL_DEBUG	= 14,
-	BFA_TRC_HAL_WWN		= 15,
-	BFA_TRC_HAL_FLASH_RAW	= 16,
-	BFA_TRC_HAL_SBOOT	= 17,
-	BFA_TRC_HAL_SBOOT_IO	= 18,
-	BFA_TRC_HAL_SBOOT_INTR	= 19,
-	BFA_TRC_HAL_SBTEST	= 20,
-	BFA_TRC_HAL_IPFC	= 21,
-	BFA_TRC_HAL_IOCFC	= 22,
-	BFA_TRC_HAL_FCPTM	= 23,
-	BFA_TRC_HAL_IOTM	= 24,
-	BFA_TRC_HAL_TSKTM	= 25,
-	BFA_TRC_HAL_TIN		= 26,
-	BFA_TRC_HAL_LPS		= 27,
-	BFA_TRC_HAL_FCDIAG	= 28,
-	BFA_TRC_HAL_PBIND	= 29,
-	BFA_TRC_HAL_IOCFC_CT	= 30,
-	BFA_TRC_HAL_IOCFC_CB	= 31,
-	BFA_TRC_HAL_IOCFC_Q	= 32,
+	BFA_TRC_HAL_INTR	= 1,
+	BFA_TRC_HAL_FCXP	= 2,
+	BFA_TRC_HAL_UF		= 3,
+	BFA_TRC_HAL_RPORT	= 4,
+	BFA_TRC_HAL_FCPIM	= 5,
+	BFA_TRC_HAL_IOIM	= 6,
+	BFA_TRC_HAL_TSKIM	= 7,
+	BFA_TRC_HAL_ITNIM	= 8,
+	BFA_TRC_HAL_FCPORT	= 9,
+	BFA_TRC_HAL_SGPG	= 10,
+	BFA_TRC_HAL_FLASH	= 11,
+	BFA_TRC_HAL_DEBUG	= 12,
+	BFA_TRC_HAL_WWN		= 13,
+	BFA_TRC_HAL_FLASH_RAW	= 14,
+	BFA_TRC_HAL_SBOOT	= 15,
+	BFA_TRC_HAL_SBOOT_IO	= 16,
+	BFA_TRC_HAL_SBOOT_INTR	= 17,
+	BFA_TRC_HAL_SBTEST	= 18,
+	BFA_TRC_HAL_IPFC	= 19,
+	BFA_TRC_HAL_IOCFC	= 20,
+	BFA_TRC_HAL_FCPTM	= 21,
+	BFA_TRC_HAL_IOTM	= 22,
+	BFA_TRC_HAL_TSKTM	= 23,
+	BFA_TRC_HAL_TIN		= 24,
+	BFA_TRC_HAL_LPS		= 25,
+	BFA_TRC_HAL_FCDIAG	= 26,
+	BFA_TRC_HAL_PBIND	= 27,
+	BFA_TRC_HAL_IOCFC_CT	= 28,
+	BFA_TRC_HAL_IOCFC_CB	= 29,
+	BFA_TRC_HAL_IOCFC_Q	= 30,
 };
 
 #endif /* __BFA_TRCMOD_PRIV_H__ */
diff -uprN a/drivers/scsi/bfa/bfa_tskim.c b/drivers/scsi/bfa/bfa_tskim.c
--- a/drivers/scsi/bfa/bfa_tskim.c	2009-12-18 18:16:22.413684000 -0800
+++ b/drivers/scsi/bfa/bfa_tskim.c	2009-11-25 18:21:07.000000000 -0800
@@ -23,13 +23,14 @@ BFA_TRC_FILE(HAL, TSKIM);
 /**
  * task management completion handling
  */
-#define bfa_tskim_qcomp(__tskim, __cbfn) do {			     \
-	bfa_cb_queue((__tskim)->bfa, &(__tskim)->hcb_qe, __cbfn, (__tskim)); \
+#define bfa_tskim_qcomp(__tskim, __cbfn) do {			\
+	bfa_cb_queue((__tskim)->bfa, &(__tskim)->hcb_qe,	\
+				__cbfn, (__tskim));      \
 	bfa_tskim_notify_comp(__tskim);      \
 } while (0)
 
-#define bfa_tskim_notify_comp(__tskim) do {				     \
-	if ((__tskim)->notify)					     	     \
+#define bfa_tskim_notify_comp(__tskim) do {			\
+	if ((__tskim)->notify)					\
 		bfa_itnim_tskdone((__tskim)->itnim);      \
 } while (0)
 
@@ -109,7 +110,7 @@ bfa_tskim_sm_uninit(struct bfa_tskim_s *
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(tskim->bfa, event);
 	}
 }
 
@@ -145,7 +146,7 @@ bfa_tskim_sm_active(struct bfa_tskim_s *
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(tskim->bfa, event);
 	}
 }
 
@@ -177,7 +178,7 @@ bfa_tskim_sm_cleanup(struct bfa_tskim_s 
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(tskim->bfa, event);
 	}
 }
 
@@ -206,7 +207,7 @@ bfa_tskim_sm_iocleanup(struct bfa_tskim_
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(tskim->bfa, event);
 	}
 }
 
@@ -241,7 +242,7 @@ bfa_tskim_sm_qfull(struct bfa_tskim_s *t
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(tskim->bfa, event);
 	}
 }
 
@@ -276,7 +277,7 @@ bfa_tskim_sm_cleanup_qfull(struct bfa_ts
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(tskim->bfa, event);
 	}
 }
 
@@ -302,7 +303,7 @@ bfa_tskim_sm_hcb(struct bfa_tskim_s *tsk
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(tskim->bfa, event);
 	}
 }
 
diff -uprN a/drivers/scsi/bfa/bfa_uf.c b/drivers/scsi/bfa/bfa_uf.c
--- a/drivers/scsi/bfa/bfa_uf.c	2009-12-18 18:16:22.411684000 -0800
+++ b/drivers/scsi/bfa/bfa_uf.c	2009-11-25 18:21:07.000000000 -0800
@@ -185,7 +185,7 @@ bfa_uf_get(struct bfa_uf_mod_s *uf_mod)
 	struct bfa_uf_s   *uf;
 
 	bfa_q_deq(&uf_mod->uf_free_q, &uf);
-	return (uf);
+	return uf;
 }
 
 static void
diff -uprN a/drivers/scsi/bfa/bfad.c b/drivers/scsi/bfa/bfad.c
--- a/drivers/scsi/bfa/bfad.c	2009-12-18 18:16:22.407686000 -0800
+++ b/drivers/scsi/bfa/bfad.c	2009-11-25 18:21:07.000000000 -0800
@@ -20,6 +20,7 @@
  */
 
 #include <linux/module.h>
+#include <linux/kthread.h>
 #include "bfad_drv.h"
 #include "bfad_im.h"
 #include "bfad_tm.h"
@@ -33,28 +34,29 @@
 BFA_TRC_FILE(LDRV, BFAD);
 static DEFINE_MUTEX(bfad_mutex);
 LIST_HEAD(bfad_list);
-static int      bfad_inst;
+static	int	bfad_inst;
 int bfad_supported_fc4s;
 
-static char     *host_name;
-static char     *os_name;
-static char     *os_patch;
-static int      num_rports;
-static int      num_ios;
-static int      num_tms;
-static int      num_fcxps;
-static int      num_ufbufs;
-static int      reqq_size;
-static int      rspq_size;
-static int      num_sgpgs;
-static int      rport_del_timeout = BFA_FCS_RPORT_DEF_DEL_TIMEOUT;
-static int      bfa_io_max_sge = BFAD_IO_MAX_SGE;
-static int      log_level = BFA_LOG_WARNING;
-static int      ioc_auto_recover = BFA_TRUE;
-static int      ipfc_enable = BFA_FALSE;
-static int      ipfc_mtu = -1;
-int 		bfa_lun_queue_depth = BFAD_LUN_QUEUE_DEPTH;
-int      	bfa_linkup_delay = -1;
+static char	*host_name;
+static char	*os_name;
+static char	*os_patch;
+static int	num_rports;
+static int	num_ios;
+static int	num_tms;
+static int	num_fcxps;
+static int	num_ufbufs;
+static int	reqq_size;
+static int	rspq_size;
+static int	num_sgpgs;
+static int	rport_del_timeout = BFA_FCS_RPORT_DEF_DEL_TIMEOUT;
+static int	bfa_io_max_sge = BFAD_IO_MAX_SGE;
+static int	log_level = BFA_LOG_WARNING;
+static int	ioc_auto_recover = BFA_TRUE;
+static int	ipfc_enable = BFA_FALSE;
+static int	ipfc_mtu = -1;
+static int	fdmi_enable = BFA_TRUE;
+int		bfa_lun_queue_depth = BFAD_LUN_QUEUE_DEPTH;
+int		bfa_linkup_delay = -1;
 
 module_param(os_name, charp, S_IRUGO | S_IWUSR);
 module_param(os_patch, charp, S_IRUGO | S_IWUSR);
@@ -74,18 +76,19 @@ module_param(log_level, int, S_IRUGO | S
 module_param(ioc_auto_recover, int, S_IRUGO | S_IWUSR);
 module_param(ipfc_enable, int, S_IRUGO | S_IWUSR);
 module_param(ipfc_mtu, int, S_IRUGO | S_IWUSR);
+module_param(fdmi_enable, int, S_IRUGO | S_IWUSR);
 module_param(bfa_linkup_delay, int, S_IRUGO | S_IWUSR);
 
 /*
  * Stores the module parm num_sgpgs value;
  * used to reset for bfad next instance.
  */
-static int num_sgpgs_parm;
+static int	num_sgpgs_parm;
 
 static bfa_status_t
 bfad_fc4_probe(struct bfad_s *bfad)
 {
-	int             rc;
+	int		rc;
 
 	rc = bfad_im_probe(bfad);
 	if (rc != BFA_STATUS_OK)
@@ -95,6 +98,9 @@ bfad_fc4_probe(struct bfad_s *bfad)
 
 	if (ipfc_enable)
 		bfad_ipfc_probe(bfad);
+
+	bfad->bfad_flags |= BFAD_FC4_PROBE_DONE;
+
 ext:
 	return rc;
 }
@@ -106,6 +112,8 @@ bfad_fc4_probe_undo(struct bfad_s *bfad)
 	bfad_tm_probe_undo(bfad);
 	if (ipfc_enable)
 		bfad_ipfc_probe_undo(bfad);
+
+	bfad->bfad_flags &= ~BFAD_FC4_PROBE_DONE;
 }
 
 static void
@@ -122,7 +130,7 @@ bfad_fc4_probe_post(struct bfad_s *bfad)
 static bfa_status_t
 bfad_fc4_port_new(struct bfad_s *bfad, struct bfad_port_s *port, int roles)
 {
-	int             rc = BFA_STATUS_FAILED;
+	int		rc = BFA_STATUS_FAILED;
 
 	if (roles & BFA_PORT_ROLE_FCP_IM)
 		rc = bfad_im_port_new(bfad, port);
@@ -171,16 +179,24 @@ bfad_hcb_comp(void *arg, bfa_status_t st
 void
 bfa_cb_init(void *drv, bfa_status_t init_status)
 {
-	struct bfad_s  *bfad = drv;
+	struct bfad_s	      *bfad = drv;
 
-	if (init_status == BFA_STATUS_OK)
+	if (init_status == BFA_STATUS_OK) {
 		bfad->bfad_flags |= BFAD_HAL_INIT_DONE;
 
+		/* If BFAD_HAL_INIT_FAIL flag is set:
+		 * Wake up the kernel thread to start
+		 * the bfad operations after HAL init done
+		 */
+		if ((bfad->bfad_flags & BFAD_HAL_INIT_FAIL)) {
+			bfad->bfad_flags &= ~BFAD_HAL_INIT_FAIL;
+			wake_up_process(bfad->bfad_tsk);
+		}
+	}
+
 	complete(&bfad->comp);
 }
 
-
-
 /**
  *  BFA_FCS callbacks
  */
@@ -188,8 +204,8 @@ static struct bfad_port_s *
 bfad_get_drv_port(struct bfad_s *bfad, struct bfad_vf_s *vf_drv,
 		  struct bfad_vport_s *vp_drv)
 {
-	return ((vp_drv) ? (&(vp_drv)->drv_port)
-		: ((vf_drv) ? (&(vf_drv)->base_port) : (&(bfad)->pport)));
+	return (vp_drv) ? (&(vp_drv)->drv_port)
+		: ((vf_drv) ? (&(vf_drv)->base_port) : (&(bfad)->pport));
 }
 
 struct bfad_port_s *
@@ -197,8 +213,8 @@ bfa_fcb_port_new(struct bfad_s *bfad, st
 		 enum bfa_port_role roles, struct bfad_vf_s *vf_drv,
 		 struct bfad_vport_s *vp_drv)
 {
-	bfa_status_t    rc;
-	struct bfad_port_s *port_drv;
+	bfa_status_t	rc;
+	struct bfad_port_s    *port_drv;
 
 	if (!vp_drv && !vf_drv) {
 		port_drv = &bfad->pport;
@@ -229,11 +245,9 @@ void
 bfa_fcb_port_delete(struct bfad_s *bfad, enum bfa_port_role roles,
 		    struct bfad_vf_s *vf_drv, struct bfad_vport_s *vp_drv)
 {
-	struct bfad_port_s *port_drv;
+	struct bfad_port_s    *port_drv;
 
-	/*
-	 * this will be only called from rmmod context
-	 */
+	/* this will be only called from rmmod context */
 	if (vp_drv && !vp_drv->comp_del) {
 		port_drv = bfad_get_drv_port(bfad, vf_drv, vp_drv);
 		bfa_trc(bfad, roles);
@@ -293,7 +307,7 @@ bfa_status_t
 bfa_fcb_rport_alloc(struct bfad_s *bfad, struct bfa_fcs_rport_s **rport,
 		    struct bfad_rport_s **rport_drv)
 {
-	bfa_status_t    rc = BFA_STATUS_OK;
+	bfa_status_t	rc = BFA_STATUS_OK;
 
 	*rport_drv = kzalloc(sizeof(struct bfad_rport_s), GFP_ATOMIC);
 	if (*rport_drv == NULL) {
@@ -307,12 +321,10 @@ ext:
 	return rc;
 }
 
-
-
 void
 bfad_hal_mem_release(struct bfad_s *bfad)
 {
-	int             i;
+	int		i;
 	struct bfa_meminfo_s *hal_meminfo = &bfad->meminfo;
 	struct bfa_mem_elem_s *meminfo_elem;
 
@@ -364,13 +376,13 @@ bfad_update_hal_cfg(struct bfa_iocfc_cfg
 	 * otherwise, the default values will be shown as 0 in sysfs
 	 */
 	num_rports = bfa_cfg->fwcfg.num_rports;
-	num_ios    = bfa_cfg->fwcfg.num_ioim_reqs;
-	num_tms	   = bfa_cfg->fwcfg.num_tskim_reqs;
-	num_fcxps  = bfa_cfg->fwcfg.num_fcxp_reqs;
+	num_ios = bfa_cfg->fwcfg.num_ioim_reqs;
+	num_tms = bfa_cfg->fwcfg.num_tskim_reqs;
+	num_fcxps = bfa_cfg->fwcfg.num_fcxp_reqs;
 	num_ufbufs = bfa_cfg->fwcfg.num_uf_bufs;
-	reqq_size  = bfa_cfg->drvcfg.num_reqq_elems;
-	rspq_size  = bfa_cfg->drvcfg.num_rspq_elems;
-	num_sgpgs  = bfa_cfg->drvcfg.num_sgpgs;
+	reqq_size = bfa_cfg->drvcfg.num_reqq_elems;
+	rspq_size = bfa_cfg->drvcfg.num_rspq_elems;
+	num_sgpgs = bfa_cfg->drvcfg.num_sgpgs;
 }
 
 bfa_status_t
@@ -390,7 +402,7 @@ bfad_hal_mem_alloc(struct bfad_s *bfad)
 
 retry:
 	bfad_update_hal_cfg(&bfad->ioc_cfg);
-	bfad->cfg_data.ioc_queue_depth = bfad->ioc_cfg.fwcfg.num_ioim_reqs;
+	bfad->cfg_data.ioc_queue_depth = bfad->ioc_cfg.fwcfg.num_ioim_reqs ;
 	bfa_cfg_get_meminfo(&bfad->ioc_cfg, hal_meminfo);
 
 	for (i = 0; i < BFA_MEM_TYPE_MAX; i++) {
@@ -417,14 +429,16 @@ retry:
 				 * num_sgpages try with half the value.
 				 */
 				if (num_sgpgs > min_num_sgpgs) {
-					printk(KERN_INFO "bfad[%d]: memory"
-						" allocation failed with"
-						" num_sgpgs: %d\n",
+					printk(KERN_INFO
+						"bfad[%d]: memory"
+						" allocation failed"
+						" with num_sgpgs: %d\n",
 						bfad->inst_no, num_sgpgs);
 					nextLowerInt(&num_sgpgs);
-					printk(KERN_INFO "bfad[%d]: trying to"
-						" allocate memory with"
-						" num_sgpgs: %d\n",
+					printk(KERN_INFO
+						"bfad[%d]: trying"
+						" to allocate memory"
+						" with num_sgpgs: %d\n",
 						bfad->inst_no, num_sgpgs);
 					retry_count++;
 					goto retry;
@@ -468,9 +482,9 @@ bfa_status_t
 bfad_vport_create(struct bfad_s *bfad, u16 vf_id,
 		  struct bfa_port_cfg_s *port_cfg)
 {
-	struct bfad_vport_s *vport;
-	int             rc = BFA_STATUS_OK;
-	unsigned long   flags;
+	struct bfad_vport_s   *vport;
+	int		rc = BFA_STATUS_OK;
+	unsigned long	flags;
 	struct completion fcomp;
 
 	vport = kzalloc(sizeof(struct bfad_vport_s), GFP_KERNEL);
@@ -520,8 +534,8 @@ bfa_status_t
 bfad_vf_create(struct bfad_s *bfad, u16 vf_id,
 	       struct bfa_port_cfg_s *port_cfg)
 {
-	struct bfad_vf_s *vf;
-	int             rc = BFA_STATUS_OK;
+	struct bfad_vf_s      *vf;
+	int		rc = BFA_STATUS_OK;
 
 	vf = kzalloc(sizeof(struct bfad_vf_s), GFP_KERNEL);
 	if (!vf) {
@@ -540,9 +554,9 @@ ext:
 void
 bfad_bfa_tmo(unsigned long data)
 {
-	struct bfad_s  *bfad = (struct bfad_s *)data;
-	unsigned long   flags;
-	struct list_head  doneq;
+	struct bfad_s	      *bfad = (struct bfad_s *) data;
+	unsigned long	flags;
+	struct list_head	       doneq;
 
 	spin_lock_irqsave(&bfad->bfad_lock, flags);
 
@@ -558,7 +572,8 @@ bfad_bfa_tmo(unsigned long data)
 		spin_unlock_irqrestore(&bfad->bfad_lock, flags);
 	}
 
-	mod_timer(&bfad->hal_tmo, jiffies + msecs_to_jiffies(BFA_TIMER_FREQ));
+	mod_timer(&bfad->hal_tmo,
+		  jiffies + msecs_to_jiffies(BFA_TIMER_FREQ));
 }
 
 void
@@ -568,14 +583,15 @@ bfad_init_timer(struct bfad_s *bfad)
 	bfad->hal_tmo.function = bfad_bfa_tmo;
 	bfad->hal_tmo.data = (unsigned long)bfad;
 
-	mod_timer(&bfad->hal_tmo, jiffies + msecs_to_jiffies(BFA_TIMER_FREQ));
+	mod_timer(&bfad->hal_tmo,
+		  jiffies + msecs_to_jiffies(BFA_TIMER_FREQ));
 }
 
 int
 bfad_pci_init(struct pci_dev *pdev, struct bfad_s *bfad)
 {
-	unsigned long   bar0_len;
-	int             rc = -ENODEV;
+	unsigned long	bar0_len;
+	int		rc = -ENODEV;
 
 	if (pci_enable_device(pdev)) {
 		BFA_PRINTF(BFA_ERR, "pci_enable_device fail %p\n", pdev);
@@ -587,7 +603,6 @@ bfad_pci_init(struct pci_dev *pdev, stru
 
 	pci_set_master(pdev);
 
-
 	if (pci_set_dma_mask(pdev, DMA_BIT_MASK(64)) != 0)
 		if (pci_set_dma_mask(pdev, DMA_BIT_MASK(32)) != 0) {
 			BFA_PRINTF(BFA_ERR, "pci_set_dma_mask fail %p\n", pdev);
@@ -642,13 +657,13 @@ bfad_pci_uninit(struct pci_dev *pdev, st
 void
 bfad_fcs_port_cfg(struct bfad_s *bfad)
 {
-	struct bfa_port_cfg_s port_cfg;
+	struct bfa_port_cfg_s  port_cfg;
 	struct bfa_pport_attr_s attr;
-	char            symname[BFA_SYMNAME_MAXLEN];
+	char		symname[BFA_SYMNAME_MAXLEN];
 
 	sprintf(symname, "%s-%d", BFAD_DRIVER_NAME, bfad->inst_no);
 	memcpy(port_cfg.sym_name.symname, symname, strlen(symname));
-	bfa_pport_get_attr(&bfad->bfa, &attr);
+	bfa_fcport_get_attr(&bfad->bfa, &attr);
 	port_cfg.nwwn = attr.nwwn;
 	port_cfg.pwwn = attr.pwwn;
 
@@ -658,10 +673,9 @@ bfad_fcs_port_cfg(struct bfad_s *bfad)
 bfa_status_t
 bfad_drv_init(struct bfad_s *bfad)
 {
-	bfa_status_t    rc;
-	unsigned long   flags;
+	bfa_status_t	rc;
+	unsigned long	flags;
 	struct bfa_fcs_driver_info_s driver_info;
-	int             i;
 
 	bfad->cfg_data.rport_del_timeout = rport_del_timeout;
 	bfad->cfg_data.lun_queue_depth = bfa_lun_queue_depth;
@@ -673,7 +687,7 @@ bfad_drv_init(struct bfad_s *bfad)
 		printk(KERN_WARNING "bfad%d bfad_hal_mem_alloc failure\n",
 		       bfad->inst_no);
 		printk(KERN_WARNING
-			"Not enough memory to attach all Brocade HBA ports,"
+		       "Not enough memory to attach all Brocade HBA ports,"
 			" System may need more memory.\n");
 		goto out_hal_mem_alloc_failure;
 	}
@@ -681,12 +695,7 @@ bfad_drv_init(struct bfad_s *bfad)
 	bfa_init_log(&bfad->bfa, bfad->logmod);
 	bfa_init_trc(&bfad->bfa, bfad->trcmod);
 	bfa_init_aen(&bfad->bfa, bfad->aen);
-	INIT_LIST_HEAD(&bfad->file_q);
-	INIT_LIST_HEAD(&bfad->file_free_q);
-	for (i = 0; i < BFAD_AEN_MAX_APPS; i++) {
-		bfa_q_qe_init(&bfad->file_buf[i].qe);
-		list_add_tail(&bfad->file_buf[i].qe, &bfad->file_free_q);
-	}
+	memset(bfad->file_map, 0, sizeof(bfad->file_map));
 	bfa_init_plog(&bfad->bfa, &bfad->plog_buf);
 	bfa_plog_init(&bfad->plog_buf);
 	bfa_plog_str(&bfad->plog_buf, BFA_PL_MID_DRVR, BFA_PL_EID_DRIVER_START,
@@ -697,9 +706,7 @@ bfad_drv_init(struct bfad_s *bfad)
 
 	init_completion(&bfad->comp);
 
-	/*
-	 * Enable Interrupt and wait bfa_init completion
-	 */
+	/* Enable Interrupt and wait bfa_init completion */
 	if (bfad_setup_intr(bfad)) {
 		printk(KERN_WARNING "bfad%d: bfad_setup_intr failed\n",
 		       bfad->inst_no);
@@ -710,13 +717,11 @@ bfad_drv_init(struct bfad_s *bfad)
 	bfa_init(&bfad->bfa);
 	spin_unlock_irqrestore(&bfad->bfad_lock, flags);
 
-	/*
-	 * Set up interrupt handler for each vectors
-	 */
-	if ((bfad->bfad_flags & BFAD_MSIX_ON)
-	    && bfad_install_msix_handler(bfad)) {
+	/* Set up interrupt handler for each vectors */
+	if ((bfad->bfad_flags & BFAD_MSIX_ON) &&
+	    bfad_install_msix_handler(bfad)) {
 		printk(KERN_WARNING "%s: install_msix failed, bfad%d\n",
-		       __FUNCTION__, bfad->inst_no);
+		       __func__, bfad->inst_no);
 	}
 
 	bfad_init_timer(bfad);
@@ -739,18 +744,25 @@ bfad_drv_init(struct bfad_s *bfad)
 	strncpy(driver_info.os_device_name, bfad->pci_name,
 		sizeof(driver_info.os_device_name - 1));
 
-	/*
-	 * FCS INIT
-	 */
+	/* FCS INIT */
 	spin_lock_irqsave(&bfad->bfad_lock, flags);
 	bfa_fcs_log_init(&bfad->bfa_fcs, bfad->logmod);
 	bfa_fcs_trc_init(&bfad->bfa_fcs, bfad->trcmod);
 	bfa_fcs_aen_init(&bfad->bfa_fcs, bfad->aen);
-	bfa_fcs_init(&bfad->bfa_fcs, &bfad->bfa, bfad, BFA_FALSE);
+	bfa_fcs_attach(&bfad->bfa_fcs, &bfad->bfa, bfad, BFA_FALSE);
+
+	/* Do FCS init only when HAL init is done */
+	if ((bfad->bfad_flags & BFAD_HAL_INIT_DONE)) {
+		bfa_fcs_init(&bfad->bfa_fcs);
+		bfad->bfad_flags |= BFAD_FCS_INIT_DONE;
+	}
+
 	bfa_fcs_driver_info_init(&bfad->bfa_fcs, &driver_info);
+	bfa_fcs_set_fdmi_param(&bfad->bfa_fcs, fdmi_enable);
 	spin_unlock_irqrestore(&bfad->bfad_lock, flags);
 
 	bfad->bfad_flags |= BFAD_DRV_INIT_DONE;
+
 	return BFA_STATUS_OK;
 
 out_setup_intr_failure:
@@ -763,18 +775,27 @@ out_hal_mem_alloc_failure:
 void
 bfad_drv_uninit(struct bfad_s *bfad)
 {
+	unsigned long   flags;
+
+	spin_lock_irqsave(&bfad->bfad_lock, flags);
+	init_completion(&bfad->comp);
+	bfa_stop(&bfad->bfa);
+	spin_unlock_irqrestore(&bfad->bfad_lock, flags);
+	wait_for_completion(&bfad->comp);
+
 	del_timer_sync(&bfad->hal_tmo);
 	bfa_isr_disable(&bfad->bfa);
 	bfa_detach(&bfad->bfa);
 	bfad_remove_intr(bfad);
-	bfa_assert(list_empty(&bfad->file_q));
 	bfad_hal_mem_release(bfad);
+
+	bfad->bfad_flags &= ~BFAD_DRV_INIT_DONE;
 }
 
 void
 bfad_drv_start(struct bfad_s *bfad)
 {
-	unsigned long   flags;
+	unsigned long	flags;
 
 	spin_lock_irqsave(&bfad->bfad_lock, flags);
 	bfa_start(&bfad->bfa);
@@ -788,7 +809,7 @@ bfad_drv_start(struct bfad_s *bfad)
 void
 bfad_drv_stop(struct bfad_s *bfad)
 {
-	unsigned long   flags;
+	unsigned long	flags;
 
 	spin_lock_irqsave(&bfad->bfad_lock, flags);
 	init_completion(&bfad->comp);
@@ -808,11 +829,9 @@ bfad_drv_stop(struct bfad_s *bfad)
 bfa_status_t
 bfad_cfg_pport(struct bfad_s *bfad, enum bfa_port_role role)
 {
-	int             rc = BFA_STATUS_OK;
+	int		rc = BFA_STATUS_OK;
 
-	/*
-	 * Allocate scsi_host for the physical port
-	 */
+	/* Allocate scsi_host for the physical port */
 	if ((bfad_supported_fc4s & BFA_PORT_ROLE_FCP_IM)
 	    && (role & BFA_PORT_ROLE_FCP_IM)) {
 		if (bfad->pport.im_port == NULL) {
@@ -836,6 +855,7 @@ out:
 void
 bfad_uncfg_pport(struct bfad_s *bfad)
 {
+
 	if ((bfad->pport.roles & BFA_PORT_ROLE_FCP_IPFC) && ipfc_enable) {
 		bfad_ipfc_port_delete(bfad, &bfad->pport);
 		bfad->pport.roles &= ~BFA_PORT_ROLE_FCP_IPFC;
@@ -859,9 +879,89 @@ bfad_drv_log_level_set(struct bfad_s *bf
 		bfa_log_set_level_all(&bfad->log_data, log_level);
 }
 
- /*
-  *  PCI_entry PCI driver entries * {
-  */
+bfa_status_t
+bfad_start_ops(struct bfad_s *bfad)
+{
+	int retval;
+
+	/* PPORT FCS config */
+	bfad_fcs_port_cfg(bfad);
+
+	retval = bfad_cfg_pport(bfad, BFA_PORT_ROLE_FCP_IM);
+	if (retval != BFA_STATUS_OK)
+		goto out_cfg_pport_failure;
+
+	/* BFAD level FC4 (IM/TM/IPFC) specific resource allocation */
+	retval = bfad_fc4_probe(bfad);
+	if (retval != BFA_STATUS_OK) {
+		printk(KERN_WARNING "bfad_fc4_probe failed\n");
+		goto out_fc4_probe_failure;
+	}
+
+	bfad_drv_start(bfad);
+
+	/*
+	 * If bfa_linkup_delay is set to -1 default; try to retrive the
+	 * value using the bfad_os_get_linkup_delay(); else use the
+	 * passed in module param value as the bfa_linkup_delay.
+	 */
+	if (bfa_linkup_delay < 0) {
+		bfa_linkup_delay = bfad_os_get_linkup_delay(bfad);
+		bfad_os_rport_online_wait(bfad);
+		bfa_linkup_delay = -1;
+
+	} else {
+		bfad_os_rport_online_wait(bfad);
+	}
+
+	bfa_log(bfad->logmod, BFA_LOG_LINUX_DEVICE_CLAIMED, bfad->pci_name);
+
+	return BFA_STATUS_OK;
+
+out_fc4_probe_failure:
+	bfad_fc4_probe_undo(bfad);
+	bfad_uncfg_pport(bfad);
+out_cfg_pport_failure:
+	return BFA_STATUS_FAILED;
+}
+
+int
+bfad_worker(void *ptr)
+{
+	struct bfad_s *bfad;
+	unsigned long   flags;
+
+	bfad = (struct bfad_s *)ptr;
+
+	while (!kthread_should_stop()) {
+
+		/* Check if the FCS init is done from bfad_drv_init;
+		 * if not done do FCS init and set the flag.
+		 */
+		if (!(bfad->bfad_flags & BFAD_FCS_INIT_DONE)) {
+			spin_lock_irqsave(&bfad->bfad_lock, flags);
+			bfa_fcs_init(&bfad->bfa_fcs);
+			bfad->bfad_flags |= BFAD_FCS_INIT_DONE;
+			spin_unlock_irqrestore(&bfad->bfad_lock, flags);
+		}
+
+		/* Start the bfad operations after HAL init done */
+		bfad_start_ops(bfad);
+
+		spin_lock_irqsave(&bfad->bfad_lock, flags);
+		bfad->bfad_tsk = NULL;
+		spin_unlock_irqrestore(&bfad->bfad_lock, flags);
+
+		break;
+	}
+
+	return 0;
+}
+
+
+/*
+ *  PCI_entry PCI driver entries * {
+ */
 
 /**
  * PCI probe entry.
@@ -869,13 +969,10 @@ bfad_drv_log_level_set(struct bfad_s *bf
 int
 bfad_pci_probe(struct pci_dev *pdev, const struct pci_device_id *pid)
 {
-	struct bfad_s  *bfad;
-	int             error = -ENODEV, retval;
-	char            buf[16];
+	struct bfad_s	*bfad;
+	int		error = -ENODEV, retval;
 
-	/*
-	 * For single port cards - only claim function 0
-	 */
+	/* For single port cards - only claim function 0 */
 	if ((pdev->device == BFA_PCI_DEVICE_ID_FC_8G1P)
 	    && (PCI_FUNC(pdev->devfn) != 0))
 		return -ENODEV;
@@ -895,15 +992,12 @@ bfad_pci_probe(struct pci_dev *pdev, con
 		goto out_alloc_trace_failure;
 	}
 
-	/*
-	 * LOG/TRACE INIT
-	 */
+	/* LOG/TRACE INIT */
 	bfa_trc_init(bfad->trcmod);
 	bfa_trc(bfad, bfad_inst);
 
 	bfad->logmod = &bfad->log_data;
-	sprintf(buf, "%d", bfad_inst);
-	bfa_log_init(bfad->logmod, buf, bfa_os_printf);
+	bfa_log_init(bfad->logmod, (char *)pci_name(pdev), bfa_os_printf);
 
 	bfad_drv_log_level_set(bfad);
 
@@ -933,57 +1027,40 @@ bfad_pci_probe(struct pci_dev *pdev, con
 	bfad->ref_count = 0;
 	bfad->pport.bfad = bfad;
 
+	bfad->bfad_tsk = kthread_create(bfad_worker, (void *) bfad, "%s",
+						"bfad_worker");
+	if (IS_ERR(bfad->bfad_tsk)) {
+		printk(KERN_INFO "bfad[%d]: Kernel thread"
+				  " creation failed!\n",
+				bfad->inst_no);
+		goto out_kthread_create_failure;
+	}
+
 	retval = bfad_drv_init(bfad);
 	if (retval != BFA_STATUS_OK)
 		goto out_drv_init_failure;
 	if (!(bfad->bfad_flags & BFAD_HAL_INIT_DONE)) {
-		printk(KERN_WARNING "bfad%d: hal init failed\n", bfad->inst_no);
+		bfad->bfad_flags |= BFAD_HAL_INIT_FAIL;
+		printk(KERN_WARNING "bfad%d: hal init failed\n",
+					bfad->inst_no);
 		goto ok;
 	}
 
-	/*
-	 * PPORT FCS config
-	 */
-	bfad_fcs_port_cfg(bfad);
-
-	retval = bfad_cfg_pport(bfad, BFA_PORT_ROLE_FCP_IM);
+	retval = bfad_start_ops(bfad);
 	if (retval != BFA_STATUS_OK)
-		goto out_cfg_pport_failure;
+		goto out_start_ops_failure;
 
-	/*
-	 * BFAD level FC4 (IM/TM/IPFC) specific resource allocation
-	 */
-	retval = bfad_fc4_probe(bfad);
-	if (retval != BFA_STATUS_OK) {
-		printk(KERN_WARNING "bfad_fc4_probe failed\n");
-		goto out_fc4_probe_failure;
-	}
-
-	bfad_drv_start(bfad);
-
-	/*
-	 * If bfa_linkup_delay is set to -1 default; try to retrive the
-	 * value using the bfad_os_get_linkup_delay(); else use the
-	 * passed in module param value as the bfa_linkup_delay.
-	 */
-	if (bfa_linkup_delay < 0) {
-		bfa_linkup_delay = bfad_os_get_linkup_delay(bfad);
-		bfad_os_rport_online_wait(bfad);
-		bfa_linkup_delay = -1;
-	} else {
-		bfad_os_rport_online_wait(bfad);
-	}
+	kthread_stop(bfad->bfad_tsk);
+	bfad->bfad_tsk = NULL;
 
-	bfa_log(bfad->logmod, BFA_LOG_LINUX_DEVICE_CLAIMED, bfad->pci_name);
 ok:
 	return 0;
 
-out_fc4_probe_failure:
-	bfad_fc4_probe_undo(bfad);
-	bfad_uncfg_pport(bfad);
-out_cfg_pport_failure:
+out_start_ops_failure:
 	bfad_drv_uninit(bfad);
 out_drv_init_failure:
+	kthread_stop(bfad->bfad_tsk);
+out_kthread_create_failure:
 	mutex_lock(&bfad_mutex);
 	bfad_inst--;
 	list_del(&bfad->list_entry);
@@ -1003,11 +1080,16 @@ out:
 void
 bfad_pci_remove(struct pci_dev *pdev)
 {
-	struct bfad_s  *bfad = pci_get_drvdata(pdev);
-	unsigned long   flags;
+	struct bfad_s	      *bfad = pci_get_drvdata(pdev);
+	unsigned long	flags;
 
 	bfa_trc(bfad, bfad->inst_no);
 
+	spin_lock_irqsave(&bfad->bfad_lock, flags);
+	if (bfad->bfad_tsk != NULL)
+		kthread_stop(bfad->bfad_tsk);
+	spin_unlock_irqrestore(&bfad->bfad_lock, flags);
+
 	if ((bfad->bfad_flags & BFAD_DRV_INIT_DONE)
 	    && !(bfad->bfad_flags & BFAD_HAL_INIT_DONE)) {
 
@@ -1024,13 +1106,25 @@ bfad_pci_remove(struct pci_dev *pdev)
 		goto remove_sysfs;
 	}
 
-	if (bfad->bfad_flags & BFAD_HAL_START_DONE)
+	if (bfad->bfad_flags & BFAD_HAL_START_DONE) {
 		bfad_drv_stop(bfad);
+	} else if (bfad->bfad_flags & BFAD_DRV_INIT_DONE) {
+		/* Invoking bfa_stop() before bfa_detach
+		 * when HAL and DRV init are success
+		 * but HAL start did not occur.
+		 */
+		spin_lock_irqsave(&bfad->bfad_lock, flags);
+		init_completion(&bfad->comp);
+		bfa_stop(&bfad->bfa);
+		spin_unlock_irqrestore(&bfad->bfad_lock, flags);
+		wait_for_completion(&bfad->comp);
+	}
 
 	bfad_remove_intr(bfad);
-
 	del_timer_sync(&bfad->hal_tmo);
-	bfad_fc4_probe_undo(bfad);
+
+	if (bfad->bfad_flags & BFAD_FC4_PROBE_DONE)
+		bfad_fc4_probe_undo(bfad);
 
 	if (bfad->bfad_flags & BFAD_CFG_PPORT_DONE)
 		bfad_uncfg_pport(bfad);
@@ -1041,7 +1135,6 @@ hal_detach:
 	spin_unlock_irqrestore(&bfad->bfad_lock, flags);
 	bfad_hal_mem_release(bfad);
 remove_sysfs:
-
 	mutex_lock(&bfad_mutex);
 	bfad_inst--;
 	list_del(&bfad->list_entry);
@@ -1052,28 +1145,27 @@ remove_sysfs:
 	kfree(bfad);
 }
 
-
 static struct pci_device_id bfad_id_table[] = {
 	{
-	 .vendor = BFA_PCI_VENDOR_ID_BROCADE,
-	 .device = BFA_PCI_DEVICE_ID_FC_8G2P,
-	 .subvendor = PCI_ANY_ID,
-	 .subdevice = PCI_ANY_ID,
-	 },
+		.vendor = BFA_PCI_VENDOR_ID_BROCADE,
+		.device = BFA_PCI_DEVICE_ID_FC_8G2P,
+		.subvendor = PCI_ANY_ID,
+		.subdevice = PCI_ANY_ID,
+	},
 	{
-	 .vendor = BFA_PCI_VENDOR_ID_BROCADE,
-	 .device = BFA_PCI_DEVICE_ID_FC_8G1P,
-	 .subvendor = PCI_ANY_ID,
-	 .subdevice = PCI_ANY_ID,
-	 },
+		.vendor = BFA_PCI_VENDOR_ID_BROCADE,
+		.device = BFA_PCI_DEVICE_ID_FC_8G1P,
+		.subvendor = PCI_ANY_ID,
+		.subdevice = PCI_ANY_ID,
+	},
 	{
-	 .vendor = BFA_PCI_VENDOR_ID_BROCADE,
-	 .device = BFA_PCI_DEVICE_ID_CT,
-	 .subvendor = PCI_ANY_ID,
-	 .subdevice = PCI_ANY_ID,
-	 .class = (PCI_CLASS_SERIAL_FIBER << 8),
-	 .class_mask = ~0,
-	 },
+		.vendor = BFA_PCI_VENDOR_ID_BROCADE,
+		.device = BFA_PCI_DEVICE_ID_CT,
+		.subvendor = PCI_ANY_ID,
+		.subdevice = PCI_ANY_ID,
+		.class = (PCI_CLASS_SERIAL_FIBER << 8),
+		.class_mask = ~0,
+	},
 
 	{0, 0},
 };
@@ -1090,10 +1182,11 @@ static struct pci_driver bfad_pci_driver
 /**
  *  Linux driver module functions
  */
+
 bfa_status_t
 bfad_fc4_module_init(void)
 {
-	int             rc;
+	int		rc;
 
 	rc = bfad_im_module_init();
 	if (rc != BFA_STATUS_OK)
@@ -1118,10 +1211,10 @@ bfad_fc4_module_exit(void)
 /**
  * Driver module init.
  */
-static int      __init
+static int __init
 bfad_init(void)
 {
-	int             error = 0;
+	int		error = 0;
 
 	printk(KERN_INFO "Brocade BFA FC/FCOE SCSI driver - version: %s\n",
 	       BFAD_DRIVER_VERSION);
@@ -1148,7 +1241,7 @@ bfad_init(void)
 	error = pci_register_driver(&bfad_pci_driver);
 
 	if (error) {
-		printk(KERN_WARNING "bfad pci_register_driver failure\n");
+		printk(KERN_WARNING "pci_register_driver failure\n");
 		goto ext;
 	}
 
@@ -1162,7 +1255,7 @@ ext:
 /**
  * Driver module exit.
  */
-static void     __exit
+static void __exit
 bfad_exit(void)
 {
 	pci_unregister_driver(&bfad_pci_driver);
@@ -1180,3 +1273,4 @@ MODULE_AUTHOR("Brocade Communications Sy
 MODULE_VERSION(BFAD_DRIVER_VERSION);
 
 
+
diff -uprN a/drivers/scsi/bfa/bfad_attr.c b/drivers/scsi/bfa/bfad_attr.c
--- a/drivers/scsi/bfa/bfad_attr.c	2009-12-18 18:16:22.405687000 -0800
+++ b/drivers/scsi/bfa/bfad_attr.c	2009-11-25 18:21:07.000000000 -0800
@@ -120,10 +120,6 @@ bfad_im_get_host_port_id(struct Scsi_Hos
 			bfa_os_hton3b(bfa_fcs_port_get_fcid(port->fcs_port));
 }
 
-
-
-
-
 struct Scsi_Host *
 bfad_os_starget_to_shost(struct scsi_target *starget)
 {
@@ -141,7 +137,7 @@ bfad_im_get_host_port_type(struct Scsi_H
 	struct bfad_s         *bfad = im_port->bfad;
 	struct bfa_pport_attr_s attr;
 
-	bfa_pport_get_attr(&bfad->bfa, &attr);
+	bfa_fcport_get_attr(&bfad->bfa, &attr);
 
 	switch (attr.port_type) {
 	case BFA_PPORT_TYPE_NPORT:
@@ -173,7 +169,7 @@ bfad_im_get_host_port_state(struct Scsi_
 	struct bfad_s         *bfad = im_port->bfad;
 	struct bfa_pport_attr_s attr;
 
-	bfa_pport_get_attr(&bfad->bfa, &attr);
+	bfa_fcport_get_attr(&bfad->bfa, &attr);
 
 	switch (attr.port_state) {
 	case BFA_PPORT_ST_LINKDOWN:
@@ -210,7 +206,7 @@ bfad_im_get_host_active_fc4s(struct Scsi
 	       sizeof(fc_host_active_fc4s(shost)));
 
 	if (port->supported_fc4s &
-		(BFA_PORT_ROLE_FCP_IM | BFA_PORT_ROLE_FCP_TM))
+			(BFA_PORT_ROLE_FCP_IM | BFA_PORT_ROLE_FCP_TM))
 		fc_host_active_fc4s(shost)[2] = 1;
 
 	if (port->supported_fc4s & BFA_PORT_ROLE_FCP_IPFC)
@@ -230,7 +226,7 @@ bfad_im_get_host_speed(struct Scsi_Host 
 	struct bfad_s         *bfad = im_port->bfad;
 	struct bfa_pport_attr_s attr;
 
-	bfa_pport_get_attr(&bfad->bfa, &attr);
+	bfa_fcport_get_attr(&bfad->bfa, &attr);
 	switch (attr.speed) {
 	case BFA_PPORT_SPEED_8GBPS:
 		fc_host_speed(shost) = FC_PORTSPEED_8GBIT;
@@ -285,7 +281,7 @@ bfad_im_get_stats(struct Scsi_Host *shos
 	init_completion(&fcomp.comp);
 	spin_lock_irqsave(&bfad->bfad_lock, flags);
 	memset(hstats, 0, sizeof(struct fc_host_statistics));
-	rc = bfa_pport_get_stats(&bfad->bfa,
+	rc = bfa_port_get_stats(BFA_FCPORT(&bfad->bfa),
 				     (union bfa_pport_stats_u *) hstats,
 				     bfad_hcb_comp, &fcomp);
 	spin_unlock_irqrestore(&bfad->bfad_lock, flags);
@@ -312,7 +308,8 @@ bfad_im_reset_stats(struct Scsi_Host *sh
 
 	init_completion(&fcomp.comp);
 	spin_lock_irqsave(&bfad->bfad_lock, flags);
-	rc = bfa_pport_clear_stats(&bfad->bfa, bfad_hcb_comp, &fcomp);
+	rc = bfa_port_clear_stats(BFA_FCPORT(&bfad->bfa), bfad_hcb_comp,
+					&fcomp);
 	spin_unlock_irqrestore(&bfad->bfad_lock, flags);
 
 	if (rc != BFA_STATUS_OK)
@@ -420,13 +417,11 @@ bfad_im_serial_num_show(struct device *d
 	struct Scsi_Host *shost = class_to_shost(dev);
 	struct bfad_im_port_s *im_port =
 			(struct bfad_im_port_s *) shost->hostdata[0];
-	struct bfad_s         *bfad = im_port->bfad;
-	struct bfa_ioc_attr_s  ioc_attr;
+	struct bfad_s *bfad = im_port->bfad;
+	char serial_num[BFA_ADAPTER_SERIAL_NUM_LEN];
 
-	memset(&ioc_attr, 0, sizeof(ioc_attr));
-	bfa_get_attr(&bfad->bfa, &ioc_attr);
-	return snprintf(buf, PAGE_SIZE, "%s\n",
-			ioc_attr.adapter_attr.serial_num);
+	bfa_get_adapter_serial_num(&bfad->bfa, serial_num);
+	return snprintf(buf, PAGE_SIZE, "%s\n", serial_num);
 }
 
 static ssize_t
@@ -436,12 +431,11 @@ bfad_im_model_show(struct device *dev, s
 	struct Scsi_Host *shost = class_to_shost(dev);
 	struct bfad_im_port_s *im_port =
 			(struct bfad_im_port_s *) shost->hostdata[0];
-	struct bfad_s         *bfad = im_port->bfad;
-	struct bfa_ioc_attr_s  ioc_attr;
+	struct bfad_s *bfad = im_port->bfad;
+	char model[BFA_ADAPTER_MODEL_NAME_LEN];
 
-	memset(&ioc_attr, 0, sizeof(ioc_attr));
-	bfa_get_attr(&bfad->bfa, &ioc_attr);
-	return snprintf(buf, PAGE_SIZE, "%s\n", ioc_attr.adapter_attr.model);
+	bfa_get_adapter_model(&bfad->bfa, model);
+	return snprintf(buf, PAGE_SIZE, "%s\n", model);
 }
 
 static ssize_t
@@ -451,13 +445,11 @@ bfad_im_model_desc_show(struct device *d
 	struct Scsi_Host *shost = class_to_shost(dev);
 	struct bfad_im_port_s *im_port =
 			(struct bfad_im_port_s *) shost->hostdata[0];
-	struct bfad_s         *bfad = im_port->bfad;
-	struct bfa_ioc_attr_s  ioc_attr;
+	struct bfad_s *bfad = im_port->bfad;
+	char model_descr[BFA_ADAPTER_MODEL_DESCR_LEN];
 
-	memset(&ioc_attr, 0, sizeof(ioc_attr));
-	bfa_get_attr(&bfad->bfa, &ioc_attr);
-	return snprintf(buf, PAGE_SIZE, "%s\n",
-			ioc_attr.adapter_attr.model_descr);
+	bfa_get_adapter_model(&bfad->bfa, model_descr);
+	return snprintf(buf, PAGE_SIZE, "%s\n", model_descr);
 }
 
 static ssize_t
@@ -481,15 +473,14 @@ bfad_im_symbolic_name_show(struct device
 	struct Scsi_Host *shost = class_to_shost(dev);
 	struct bfad_im_port_s *im_port =
 			(struct bfad_im_port_s *) shost->hostdata[0];
-	struct bfad_s         *bfad = im_port->bfad;
-	struct bfa_ioc_attr_s  ioc_attr;
-
-	memset(&ioc_attr, 0, sizeof(ioc_attr));
-	bfa_get_attr(&bfad->bfa, &ioc_attr);
+	struct bfad_s *bfad = im_port->bfad;
+	char model[BFA_ADAPTER_MODEL_NAME_LEN];
+	char fw_ver[BFA_VERSION_LEN];
 
+	bfa_get_adapter_model(&bfad->bfa, model);
+	bfa_get_adapter_fw_ver(&bfad->bfa, fw_ver);
 	return snprintf(buf, PAGE_SIZE, "Brocade %s FV%s DV%s\n",
-			ioc_attr.adapter_attr.model,
-			ioc_attr.adapter_attr.fw_ver, BFAD_DRIVER_VERSION);
+			model, fw_ver, BFAD_DRIVER_VERSION);
 }
 
 static ssize_t
@@ -499,12 +490,11 @@ bfad_im_hw_version_show(struct device *d
 	struct Scsi_Host *shost = class_to_shost(dev);
 	struct bfad_im_port_s *im_port =
 			(struct bfad_im_port_s *) shost->hostdata[0];
-	struct bfad_s         *bfad = im_port->bfad;
-	struct bfa_ioc_attr_s  ioc_attr;
+	struct bfad_s *bfad = im_port->bfad;
+	char hw_ver[BFA_VERSION_LEN];
 
-	memset(&ioc_attr, 0, sizeof(ioc_attr));
-	bfa_get_attr(&bfad->bfa, &ioc_attr);
-	return snprintf(buf, PAGE_SIZE, "%s\n", ioc_attr.adapter_attr.hw_ver);
+	bfa_get_pci_chip_rev(&bfad->bfa, hw_ver);
+	return snprintf(buf, PAGE_SIZE, "%s\n", hw_ver);
 }
 
 static ssize_t
@@ -521,13 +511,11 @@ bfad_im_optionrom_version_show(struct de
 	struct Scsi_Host *shost = class_to_shost(dev);
 	struct bfad_im_port_s *im_port =
 			(struct bfad_im_port_s *) shost->hostdata[0];
-	struct bfad_s         *bfad = im_port->bfad;
-	struct bfa_ioc_attr_s  ioc_attr;
+	struct bfad_s *bfad = im_port->bfad;
+	char optrom_ver[BFA_VERSION_LEN];
 
-	memset(&ioc_attr, 0, sizeof(ioc_attr));
-	bfa_get_attr(&bfad->bfa, &ioc_attr);
-	return snprintf(buf, PAGE_SIZE, "%s\n",
-			ioc_attr.adapter_attr.optrom_ver);
+	bfa_get_adapter_optrom_ver(&bfad->bfa, optrom_ver);
+	return snprintf(buf, PAGE_SIZE, "%s\n", optrom_ver);
 }
 
 static ssize_t
@@ -537,12 +525,11 @@ bfad_im_fw_version_show(struct device *d
 	struct Scsi_Host *shost = class_to_shost(dev);
 	struct bfad_im_port_s *im_port =
 			(struct bfad_im_port_s *) shost->hostdata[0];
-	struct bfad_s         *bfad = im_port->bfad;
-	struct bfa_ioc_attr_s  ioc_attr;
+	struct bfad_s *bfad = im_port->bfad;
+	char fw_ver[BFA_VERSION_LEN];
 
-	memset(&ioc_attr, 0, sizeof(ioc_attr));
-	bfa_get_attr(&bfad->bfa, &ioc_attr);
-	return snprintf(buf, PAGE_SIZE, "%s\n", ioc_attr.adapter_attr.fw_ver);
+	bfa_get_adapter_fw_ver(&bfad->bfa, fw_ver);
+	return snprintf(buf, PAGE_SIZE, "%s\n", fw_ver);
 }
 
 static ssize_t
@@ -552,12 +539,10 @@ bfad_im_num_of_ports_show(struct device 
 	struct Scsi_Host *shost = class_to_shost(dev);
 	struct bfad_im_port_s *im_port =
 			(struct bfad_im_port_s *) shost->hostdata[0];
-	struct bfad_s         *bfad = im_port->bfad;
-	struct bfa_ioc_attr_s  ioc_attr;
+	struct bfad_s *bfad = im_port->bfad;
 
-	memset(&ioc_attr, 0, sizeof(ioc_attr));
-	bfa_get_attr(&bfad->bfa, &ioc_attr);
-	return snprintf(buf, PAGE_SIZE, "%d\n", ioc_attr.adapter_attr.nports);
+	return snprintf(buf, PAGE_SIZE, "%d\n",
+			bfa_get_nports(&bfad->bfa));
 }
 
 static ssize_t
@@ -592,6 +577,106 @@ bfad_im_num_of_discovered_ports_show(str
 	return snprintf(buf, PAGE_SIZE, "%d\n", nrports);
 }
 
+static int
+bfad_im_parse_wwn(const char *buf, u8 *wwn)
+{
+	unsigned int i, j;
+	memset(wwn, 0, 8);
+
+	/* Validate and store the new name */
+	for (i = 0, j = 0; i < 16; i++) {
+		if ((*buf >= '0') && (*buf <= '9'))
+			j = ((j << 4) | (*buf++ - '0'));
+		else if ((*buf >= 'a') && (*buf <= 'f'))
+			j = ((j << 4) | ((*buf++ - 'a') + 10));
+		else if ((*buf >= 'A') && (*buf <= 'F'))
+			j = ((j << 4) | ((*buf++ - 'A') + 10));
+		else
+			return -EINVAL;
+		if (i % 2) {
+			wwn[i/2] = j & 0xff;
+			j = 0;
+		}
+	}
+
+	return 0;
+}
+
+static ssize_t
+bfad_im_vport_create(struct device *cdev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	struct Scsi_Host *shost = class_to_shost(cdev);
+	struct bfad_im_port_s *im_port =
+			(struct bfad_im_port_s *) shost->hostdata[0];
+	struct bfad_s *bfad = im_port->bfad;
+	struct bfa_port_cfg_s port_cfg;
+	u8 wwn[8];
+	int status;
+
+	memset(&port_cfg, 0, sizeof(port_cfg));
+	status = bfad_im_parse_wwn(&buf[0], wwn);
+	if (status)
+		return status;
+	memcpy(&port_cfg.pwwn, wwn, sizeof(wwn));
+
+	status = bfad_im_parse_wwn(&buf[17], wwn);
+	if (status)
+		return status;
+	memcpy(&port_cfg.nwwn, wwn, sizeof(wwn));
+
+	port_cfg.roles = BFA_PORT_ROLE_FCP_IM;
+	status = bfad_vport_create(bfad, 0, &port_cfg);
+	if (status != BFA_STATUS_OK)
+		return -EIO;
+
+	return count;
+}
+
+static ssize_t
+bfad_im_vport_delete(struct device *cdev, struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct Scsi_Host  *shost = class_to_shost(cdev);
+	struct bfad_im_port_s *im_port =
+		(struct bfad_im_port_s *) shost->hostdata[0];
+	struct bfad_s *bfad = im_port->bfad;
+	u8 wwn[8];
+	int status;
+	unsigned long flags;
+	struct bfa_fcs_vport_s *fcs_vport;
+	struct bfad_vport_s *bfad_vport;
+	struct completion fcomp;
+
+	status = bfad_im_parse_wwn(&buf[0], wwn);
+	if (status)
+		return status;
+
+	spin_lock_irqsave(&bfad->bfad_lock, flags);
+	fcs_vport = bfa_fcs_vport_lookup(&bfad->bfa_fcs, 0, *(wwn_t *)wwn);
+	if (fcs_vport == NULL) {
+		spin_unlock_irqrestore(&bfad->bfad_lock, flags);
+		return -EINVAL;
+	}
+
+	bfad_vport = fcs_vport->vport_drv;
+	bfad_vport->drv_port.flags |= BFAD_PORT_DELETE;
+	bfad_vport->comp_del = &fcomp;
+	init_completion(bfad_vport->comp_del);
+
+	status = bfa_fcs_vport_delete(fcs_vport);
+	spin_unlock_irqrestore(&bfad->bfad_lock, flags);
+
+	wait_for_completion(bfad_vport->comp_del);
+
+	if (status != BFA_STATUS_OK)
+		return -EIO;
+
+	bfad_os_scsi_host_free(bfad, bfad_vport->drv_port.im_port);
+	kfree(bfad_vport);
+	return count;
+}
+
 static          DEVICE_ATTR(serial_number, S_IRUGO,
 				bfad_im_serial_num_show, NULL);
 static          DEVICE_ATTR(model, S_IRUGO, bfad_im_model_show, NULL);
@@ -613,6 +698,8 @@ static          DEVICE_ATTR(number_of_po
 static          DEVICE_ATTR(driver_name, S_IRUGO, bfad_im_drv_name_show, NULL);
 static          DEVICE_ATTR(number_of_discovered_ports, S_IRUGO,
 				bfad_im_num_of_discovered_ports_show, NULL);
+static		DEVICE_ATTR(vport_create, S_IWUSR, NULL, bfad_im_vport_create);
+static		DEVICE_ATTR(vport_delete, S_IWUSR, NULL, bfad_im_vport_delete);
 
 struct device_attribute *bfad_im_host_attrs[] = {
 	&dev_attr_serial_number,
@@ -627,6 +714,8 @@ struct device_attribute *bfad_im_host_at
 	&dev_attr_number_of_ports,
 	&dev_attr_driver_name,
 	&dev_attr_number_of_discovered_ports,
+	&dev_attr_vport_create,
+	&dev_attr_vport_delete,
 	NULL,
 };
 
diff -uprN a/drivers/scsi/bfa/bfad_attr.h b/drivers/scsi/bfa/bfad_attr.h
--- a/drivers/scsi/bfa/bfad_attr.h	2009-12-18 18:16:22.403692000 -0800
+++ b/drivers/scsi/bfa/bfad_attr.h	2009-11-25 17:23:59.000000000 -0800
@@ -17,9 +17,6 @@
 
 #ifndef __BFAD_ATTR_H__
 #define __BFAD_ATTR_H__
-/**
- *  bfad_attr.h VMware driver configuration interface module.
- */
 
 /**
  *  FC_transport_template FC transport template
@@ -52,12 +49,6 @@ bfad_im_get_starget_port_name(struct scs
 void
 bfad_im_get_host_port_id(struct Scsi_Host *shost);
 
-/**
- * FC transport template entry, issue a LIP.
- */
-int
-bfad_im_issue_fc_host_lip(struct Scsi_Host *shost);
-
 struct Scsi_Host*
 bfad_os_starget_to_shost(struct scsi_target *starget);
 
diff -uprN a/drivers/scsi/bfa/bfad_drv.h b/drivers/scsi/bfa/bfad_drv.h
--- a/drivers/scsi/bfa/bfad_drv.h	2009-12-18 18:16:22.401688000 -0800
+++ b/drivers/scsi/bfa/bfad_drv.h	2009-11-25 17:23:59.000000000 -0800
@@ -46,10 +46,9 @@
 #ifdef BFA_DRIVER_VERSION
 #define BFAD_DRIVER_VERSION    BFA_DRIVER_VERSION
 #else
-#define BFAD_DRIVER_VERSION    "2.0.0.0"
+#define BFAD_DRIVER_VERSION    "2.1.2.1"
 #endif
 
-
 #define BFAD_IRQ_FLAGS IRQF_SHARED
 
 /*
@@ -62,6 +61,9 @@
 #define BFAD_HAL_START_DONE			0x00000010
 #define BFAD_PORT_ONLINE			0x00000020
 #define BFAD_RPORT_ONLINE			0x00000040
+#define BFAD_FCS_INIT_DONE			0x00000080
+#define BFAD_HAL_INIT_FAIL			0x00000100
+#define BFAD_FC4_PROBE_DONE			0x00000200
 
 #define BFAD_PORT_DELETE			0x00000001
 
@@ -137,12 +139,16 @@ struct bfad_cfg_param_s {
 	u32        binding_method;
 };
 
-#define BFAD_AEN_MAX_APPS 8
-struct bfad_aen_file_s {
-	struct list_head  qe;
-	struct bfad_s *bfad;
-	s32 ri;
-	s32 app_id;
+union bfad_tmp_buf {
+	/* From struct bfa_adapter_attr_s */
+	char            manufacturer[BFA_ADAPTER_MFG_NAME_LEN];
+	char            serial_num[BFA_ADAPTER_SERIAL_NUM_LEN];
+	char            model[BFA_ADAPTER_MODEL_NAME_LEN];
+	char            fw_ver[BFA_VERSION_LEN];
+	char            optrom_ver[BFA_VERSION_LEN];
+
+	/* From struct bfa_ioc_pci_attr_s */
+	u8         chip_rev[BFA_IOC_CHIP_REV_LEN];  /*  chip revision */
 };
 
 /*
@@ -168,6 +174,7 @@ struct bfad_s {
 	u32        inst_no;	/* BFAD instance number */
 	u32        bfad_flags;
 	spinlock_t      bfad_lock;
+	struct task_struct *bfad_tsk;
 	struct bfad_cfg_param_s cfg_data;
 	struct bfad_msix_s msix_tab[MAX_MSIX_ENTRY];
 	int             nvec;
@@ -183,18 +190,12 @@ struct bfad_s {
 	struct bfa_log_mod_s  *logmod;
 	struct bfa_aen_s      *aen;
 	struct bfa_aen_s       aen_buf;
-	struct bfad_aen_file_s file_buf[BFAD_AEN_MAX_APPS];
-	struct list_head         file_q;
-	struct list_head         file_free_q;
+	void		*file_map[BFA_AEN_MAX_APP];
 	struct bfa_plog_s      plog_buf;
 	int             ref_count;
 	bfa_boolean_t	ipfc_enabled;
+	union bfad_tmp_buf tmp_buf;
 	struct fc_host_statistics link_stats;
-
-	struct kobject *bfa_kobj;
-	struct kobject *ioc_kobj;
-	struct kobject *pport_kobj;
-	struct kobject *lport_kobj;
 };
 
 /*
@@ -245,7 +246,7 @@ struct bfad_hal_comp {
 do {                                            	\
 	int j;                                  	\
 	(*x)--;    		                	\
-	for (j = 1; j < (sizeof(int) * 8); j <<= 1)     \
+	for (j = 1; j < (sizeof(int) * 8); j <<= 1)	\
 		(*x) = (*x) | (*x) >> j;        	\
 	(*x)++;                  	        	\
 	(*x) = (*x) >> 1;                       	\
@@ -258,6 +259,7 @@ bfa_status_t    bfad_vf_create(struct bf
 			       struct bfa_port_cfg_s *port_cfg);
 bfa_status_t    bfad_cfg_pport(struct bfad_s *bfad, enum bfa_port_role role);
 bfa_status_t    bfad_drv_init(struct bfad_s *bfad);
+bfa_status_t	bfad_start_ops(struct bfad_s *bfad);
 void            bfad_drv_start(struct bfad_s *bfad);
 void            bfad_uncfg_pport(struct bfad_s *bfad);
 void            bfad_drv_stop(struct bfad_s *bfad);
@@ -280,6 +282,7 @@ void		bfad_drv_log_level_set(struct bfad
 bfa_status_t	bfad_fc4_module_init(void);
 void		bfad_fc4_module_exit(void);
 
+int bfad_worker(void *ptr);
 void bfad_pci_remove(struct pci_dev *pdev);
 int bfad_pci_probe(struct pci_dev *pdev, const struct pci_device_id *pid);
 void bfad_os_rport_online_wait(struct bfad_s *bfad);
diff -uprN a/drivers/scsi/bfa/bfad_fwimg.c b/drivers/scsi/bfa/bfad_fwimg.c
--- a/drivers/scsi/bfa/bfad_fwimg.c	2009-12-18 18:16:22.393686000 -0800
+++ b/drivers/scsi/bfa/bfad_fwimg.c	2009-11-25 18:21:07.000000000 -0800
@@ -65,10 +65,10 @@ bfad_read_firmware(struct pci_dev *pdev,
 	memcpy(*bfi_image, fw->data, fw->size);
 	*bfi_image_size = fw->size/sizeof(u32);
 
-	return(*bfi_image);
+	return *bfi_image;
 
 error:
-	return(NULL);
+	return NULL;
 }
 
 u32 *
@@ -78,12 +78,12 @@ bfad_get_firmware_buf(struct pci_dev *pd
 		if (bfi_image_ct_size == 0)
 			bfad_read_firmware(pdev, &bfi_image_ct,
 				&bfi_image_ct_size, BFAD_FW_FILE_CT);
-		return(bfi_image_ct);
+		return bfi_image_ct;
 	} else {
 		if (bfi_image_cb_size == 0)
 			bfad_read_firmware(pdev, &bfi_image_cb,
 				&bfi_image_cb_size, BFAD_FW_FILE_CB);
-		return(bfi_image_cb);
+		return bfi_image_cb;
 	}
 }
 
diff -uprN a/drivers/scsi/bfa/bfad_im.c b/drivers/scsi/bfa/bfad_im.c
--- a/drivers/scsi/bfa/bfad_im.c	2009-12-18 18:16:22.391684000 -0800
+++ b/drivers/scsi/bfa/bfad_im.c	2009-11-25 18:21:07.000000000 -0800
@@ -43,11 +43,11 @@ bfa_cb_ioim_done(void *drv, struct bfad_
 	struct bfad_s         *bfad = drv;
 	struct bfad_itnim_data_s *itnim_data;
 	struct bfad_itnim_s *itnim;
+	u8         host_status = DID_OK;
 
 	switch (io_status) {
 	case BFI_IOIM_STS_OK:
 		bfa_trc(bfad, scsi_status);
-		cmnd->result = ScsiResult(DID_OK, scsi_status);
 		scsi_set_resid(cmnd, 0);
 
 		if (sns_len > 0) {
@@ -56,8 +56,18 @@ bfa_cb_ioim_done(void *drv, struct bfad_
 				sns_len = SCSI_SENSE_BUFFERSIZE;
 			memcpy(cmnd->sense_buffer, sns_info, sns_len);
 		}
-		if (residue > 0)
+		if (residue > 0) {
+			bfa_trc(bfad, residue);
 			scsi_set_resid(cmnd, residue);
+			if (!sns_len && (scsi_status == SAM_STAT_GOOD) &&
+				(scsi_bufflen(cmnd) - residue) <
+					cmnd->underflow) {
+				bfa_trc(bfad, 0);
+				host_status = DID_ERROR;
+			}
+		}
+		cmnd->result = ScsiResult(host_status, scsi_status);
+
 		break;
 
 	case BFI_IOIM_STS_ABORTED:
@@ -167,17 +177,15 @@ bfad_im_info(struct Scsi_Host *shost)
 	static char     bfa_buf[256];
 	struct bfad_im_port_s *im_port =
 			(struct bfad_im_port_s *) shost->hostdata[0];
-	struct bfa_ioc_attr_s  ioc_attr;
-	struct bfad_s         *bfad = im_port->bfad;
+	struct bfad_s *bfad = im_port->bfad;
+	char model[BFA_ADAPTER_MODEL_NAME_LEN];
 
-	memset(&ioc_attr, 0, sizeof(ioc_attr));
-	bfa_get_attr(&bfad->bfa, &ioc_attr);
+	bfa_get_adapter_model(&bfad->bfa, model);
 
 	memset(bfa_buf, 0, sizeof(bfa_buf));
 	snprintf(bfa_buf, sizeof(bfa_buf),
 		 "Brocade FC/FCOE Adapter, " "model: %s hwpath: %s driver: %s",
-		 ioc_attr.adapter_attr.model, bfad->pci_name,
-		 BFAD_DRIVER_VERSION);
+		 model, bfad->pci_name, BFAD_DRIVER_VERSION);
 	return bfa_buf;
 }
 
@@ -501,16 +509,6 @@ void bfa_fcb_itnim_tov(struct bfad_itnim
 }
 
 /**
- * Path TOV processing begin notification -- dummy for linux
- */
-void
-bfa_fcb_itnim_tov_begin(struct bfad_itnim_s *itnim)
-{
-}
-
-
-
-/**
  * Allocate a Scsi_Host for a port.
  */
 int
@@ -691,9 +689,6 @@ bfad_im_probe_undo(struct bfad_s *bfad)
 	}
 }
 
-
-
-
 int
 bfad_os_scsi_add_host(struct Scsi_Host *shost, struct bfad_im_port_s *im_port,
 			struct bfad_s *bfad)
@@ -830,7 +825,6 @@ bfad_im_module_init(void)
 		fc_attach_transport(&bfad_im_fc_function_template);
 	if (!bfad_im_scsi_transport_template)
 		return BFA_STATUS_ENOMEM;
-
 	return BFA_STATUS_OK;
 }
 
@@ -893,8 +887,6 @@ bfad_os_handle_qfull(struct bfad_itnim_s
 }
 
 
-
-
 struct bfad_itnim_s *
 bfad_os_get_itnim(struct bfad_im_port_s *im_port, int id)
 {
@@ -931,10 +923,9 @@ bfad_os_fc_host_init(struct bfad_im_port
 	struct Scsi_Host *host = im_port->shost;
 	struct bfad_s         *bfad = im_port->bfad;
 	struct bfad_port_s    *port = im_port->port;
-	union attr {
-		struct bfa_pport_attr_s pattr;
-		struct bfa_ioc_attr_s  ioc_attr;
-	} attr;
+	struct bfa_pport_attr_s pattr;
+	char model[BFA_ADAPTER_MODEL_NAME_LEN];
+	char fw_ver[BFA_VERSION_LEN];
 
 	fc_host_node_name(host) =
 		bfa_os_htonll((bfa_fcs_port_get_nwwn(port->fcs_port)));
@@ -954,20 +945,18 @@ bfad_os_fc_host_init(struct bfad_im_port
 	/* For fibre channel services type 0x20 */
 	fc_host_supported_fc4s(host)[7] = 1;
 
-	memset(&attr.ioc_attr, 0, sizeof(attr.ioc_attr));
-	bfa_get_attr(&bfad->bfa, &attr.ioc_attr);
+	bfa_get_adapter_model(&bfad->bfa, model);
+	bfa_get_adapter_fw_ver(&bfad->bfa, fw_ver);
 	sprintf(fc_host_symbolic_name(host), "Brocade %s FV%s DV%s",
-		attr.ioc_attr.adapter_attr.model,
-		attr.ioc_attr.adapter_attr.fw_ver, BFAD_DRIVER_VERSION);
+		model, fw_ver, BFAD_DRIVER_VERSION);
 
 	fc_host_supported_speeds(host) = 0;
 	fc_host_supported_speeds(host) |=
 		FC_PORTSPEED_8GBIT | FC_PORTSPEED_4GBIT | FC_PORTSPEED_2GBIT |
 		FC_PORTSPEED_1GBIT;
 
-	memset(&attr.pattr, 0, sizeof(attr.pattr));
-	bfa_pport_get_attr(&bfad->bfa, &attr.pattr);
-	fc_host_maxframe_size(host) = attr.pattr.pport_cfg.maxfrsize;
+	bfa_fcport_get_attr(&bfad->bfa, &pattr);
+	fc_host_maxframe_size(host) = pattr.pport_cfg.maxfrsize;
 }
 
 static void
@@ -1050,7 +1039,7 @@ bfad_im_itnim_work_handler(struct work_s
 		} else {
 			printk(KERN_WARNING
 				"%s: itnim %llx is already in online state\n",
-				__FUNCTION__,
+				__func__,
 				bfa_fcs_itnim_get_pwwn(&itnim->fcs_itnim));
 		}
 
@@ -1155,7 +1144,7 @@ bfad_im_queuecommand(struct scsi_cmnd *c
 	hal_io = bfa_ioim_alloc(&bfad->bfa, (struct bfad_ioim_s *) cmnd,
 				    itnim->bfa_itnim, sg_cnt);
 	if (!hal_io) {
-		printk(KERN_WARNING "hal_io failure\n");
+		bfa_trc(bfad, 0);
 		spin_unlock_irqrestore(&bfad->bfad_lock, flags);
 		scsi_dma_unmap(cmnd);
 		return SCSI_MLQUEUE_HOST_BUSY;
@@ -1203,28 +1192,26 @@ int
 bfad_os_get_linkup_delay(struct bfad_s *bfad)
 {
 
-	u8         nwwns = 0;
+	uint8_t         nwwns = 0;
 	wwn_t           *wwns;
-	int             ldelay;
+	int 		linkup_delay;
 
 	/*
 	 * Querying for the boot target port wwns
 	 * -- read from boot information in flash.
 	 * If nwwns > 0 => boot over SAN and set bfa_linkup_delay = 30
-	 * else => local boot machine set bfa_linkup_delay = 10
+	 * else => local boot machine set bfa_linkup_delay = 0
 	 */
 
 	bfa_iocfc_get_bootwwns(&bfad->bfa, &nwwns, &wwns);
 
 	if (nwwns > 0) {
-		/* If boot over SAN; linkup_delay = 30sec */
-		ldelay = 30;
+		/* If Boot over SAN set linkup_delay = 30sec */
+		linkup_delay = 30;
 	} else {
-		/* If local boot; linkup_delay = 10sec */
-		ldelay = 0;
+		/* If local boot; no linkup_delay */
+		linkup_delay = 0;
 	}
 
-	return ldelay;
+	return linkup_delay;
 }
-
-
diff -uprN a/drivers/scsi/bfa/bfad_im.h b/drivers/scsi/bfa/bfad_im.h
--- a/drivers/scsi/bfa/bfad_im.h	2009-12-18 18:16:22.389684000 -0800
+++ b/drivers/scsi/bfa/bfad_im.h	2009-11-25 17:23:59.000000000 -0800
@@ -23,7 +23,6 @@
 
 #define FCPI_NAME " fcpim"
 
-void bfad_flags_set(struct bfad_s *bfad, u32 flags);
 bfa_status_t bfad_im_module_init(void);
 void bfad_im_module_exit(void);
 bfa_status_t bfad_im_probe(struct bfad_s *bfad);
@@ -117,7 +116,7 @@ struct bfad_fcp_binding {
 struct bfad_im_s {
 	struct bfad_s         *bfad;
 	struct workqueue_struct *drv_workq;
-	char   drv_workq_name[BFAD_KOBJ_NAME_LEN];
+	char            drv_workq_name[BFAD_KOBJ_NAME_LEN];
 };
 
 struct Scsi_Host *bfad_os_scsi_host_alloc(struct bfad_im_port_s *im_port,
@@ -126,7 +125,6 @@ bfa_status_t bfad_os_thread_workq(struct
 void bfad_os_destroy_workq(struct bfad_im_s *im);
 void bfad_os_itnim_process(struct bfad_itnim_s *itnim_drv);
 void bfad_os_fc_host_init(struct bfad_im_port_s *im_port);
-void bfad_os_init_work(struct bfad_im_port_s *im_port);
 void bfad_os_scsi_host_free(struct bfad_s *bfad,
 				 struct bfad_im_port_s *im_port);
 void bfad_os_ramp_up_qdepth(struct bfad_itnim_s *itnim,
@@ -136,9 +134,6 @@ struct bfad_itnim_s *bfad_os_get_itnim(s
 int bfad_os_scsi_add_host(struct Scsi_Host *shost,
 		struct bfad_im_port_s *im_port, struct bfad_s *bfad);
 
-/*
- * scsi_host_template entries
- */
 void bfad_im_itnim_unmap(struct bfad_im_port_s  *im_port,
 			 struct bfad_itnim_s *itnim);
 
diff -uprN a/drivers/scsi/bfa/bfad_im_compat.h b/drivers/scsi/bfa/bfad_im_compat.h
--- a/drivers/scsi/bfa/bfad_im_compat.h	2009-12-18 18:16:22.387687000 -0800
+++ b/drivers/scsi/bfa/bfad_im_compat.h	2009-11-25 17:23:59.000000000 -0800
@@ -31,7 +31,7 @@ u32 *bfad_read_firmware(struct pci_dev *
 static inline u32 *
 bfad_load_fwimg(struct pci_dev *pdev)
 {
-	return(bfad_get_firmware_buf(pdev));
+	return bfad_get_firmware_buf(pdev);
 }
 
 static inline void
diff -uprN a/drivers/scsi/bfa/bfad_intr.c b/drivers/scsi/bfa/bfad_intr.c
--- a/drivers/scsi/bfa/bfad_intr.c	2009-12-18 18:16:22.385689000 -0800
+++ b/drivers/scsi/bfa/bfad_intr.c	2009-11-25 18:21:07.000000000 -0800
@@ -23,13 +23,15 @@ BFA_TRC_FILE(LDRV, INTR);
 /**
  *  bfa_isr BFA driver interrupt functions
  */
-irqreturn_t bfad_intx(int irq, void *dev_id);
-static int msix_disable;
-module_param(msix_disable, int, S_IRUGO | S_IWUSR);
+static int msix_disable_cb;
+static int msix_disable_ct;
+module_param(msix_disable_cb, int, S_IRUGO | S_IWUSR);
+module_param(msix_disable_ct, int, S_IRUGO | S_IWUSR);
+
 /**
  * Line based interrupt handler.
  */
-irqreturn_t
+static irqreturn_t
 bfad_intx(int irq, void *dev_id)
 {
 	struct bfad_s         *bfad = dev_id;
@@ -142,6 +144,7 @@ bfad_setup_intr(struct bfad_s *bfad)
 	int error = 0;
 	u32 mask = 0, i, num_bit = 0, max_bit = 0;
 	struct msix_entry msix_entries[MAX_MSIX_ENTRY];
+	struct pci_dev *pdev = bfad->pcidev;
 
 	/* Call BFA to get the msix map for this PCI function.  */
 	bfa_msix_getvecs(&bfad->bfa, &mask, &num_bit, &max_bit);
@@ -149,7 +152,9 @@ bfad_setup_intr(struct bfad_s *bfad)
 	/* Set up the msix entry table */
 	bfad_init_msix_entry(bfad, msix_entries, mask, max_bit);
 
-	if (!msix_disable) {
+	if ((pdev->device == BFA_PCI_DEVICE_ID_CT && !msix_disable_ct) ||
+	    (pdev->device != BFA_PCI_DEVICE_ID_CT && !msix_disable_cb)) {
+
 		error = pci_enable_msix(bfad->pcidev, msix_entries, bfad->nvec);
 		if (error) {
 			/*
@@ -210,5 +215,3 @@ bfad_remove_intr(struct bfad_s *bfad)
 		free_irq(bfad->pcidev->irq, bfad);
 	}
 }
-
-
diff -uprN a/drivers/scsi/bfa/bfad_os.c b/drivers/scsi/bfa/bfad_os.c
--- a/drivers/scsi/bfa/bfad_os.c	2009-12-18 18:16:22.382684000 -0800
+++ b/drivers/scsi/bfa/bfad_os.c	2009-11-25 18:21:07.000000000 -0800
@@ -46,5 +46,3 @@ bfa_os_printf(struct bfa_log_mod_s *log_
 
 	printk(tmp);
 }
-
-
diff -uprN a/drivers/scsi/bfa/fabric.c b/drivers/scsi/bfa/fabric.c
--- a/drivers/scsi/bfa/fabric.c	2009-12-18 18:16:22.375684000 -0800
+++ b/drivers/scsi/bfa/fabric.c	2009-11-25 18:21:07.000000000 -0800
@@ -33,35 +33,36 @@
 
 BFA_TRC_FILE(FCS, FABRIC);
 
-#define BFA_FCS_FABRIC_RETRY_DELAY	(2000)	/* Milliseconds */
+#define BFA_FCS_FABRIC_RETRY_DELAY		(2000)	/* Milliseconds */
 #define BFA_FCS_FABRIC_CLEANUP_DELAY	(10000)	/* Milliseconds */
 
-#define bfa_fcs_fabric_set_opertype(__fabric) do {          \
-    if (bfa_pport_get_topology((__fabric)->fcs->bfa)    \
-				== BFA_PPORT_TOPOLOGY_P2P)   \
-	    (__fabric)->oper_type = BFA_PPORT_TYPE_NPORT;       \
-    else                                                    \
-	    (__fabric)->oper_type = BFA_PPORT_TYPE_NLPORT;      \
-} while (0)
+#define bfa_fcs_fabric_set_opertype(__fabric) do {			\
+		if (bfa_fcport_get_topology((__fabric)->fcs->bfa)	\
+		    == BFA_PPORT_TOPOLOGY_P2P)				\
+			(__fabric)->oper_type = BFA_PPORT_TYPE_NPORT;	\
+		else							\
+			(__fabric)->oper_type = BFA_PPORT_TYPE_NLPORT;	\
+	} while (0)
 
 /*
  * forward declarations
  */
-static void     bfa_fcs_fabric_init(struct bfa_fcs_fabric_s *fabric);
-static void     bfa_fcs_fabric_login(struct bfa_fcs_fabric_s *fabric);
-static void     bfa_fcs_fabric_notify_online(struct bfa_fcs_fabric_s *fabric);
-static void     bfa_fcs_fabric_notify_offline(struct bfa_fcs_fabric_s *fabric);
-static void     bfa_fcs_fabric_delay(void *cbarg);
-static void     bfa_fcs_fabric_delete(struct bfa_fcs_fabric_s *fabric);
-static void     bfa_fcs_fabric_delete_comp(void *cbarg);
-static void     bfa_fcs_fabric_process_uf(struct bfa_fcs_fabric_s *fabric,
+static void	bfa_fcs_fabric_init(struct bfa_fcs_fabric_s *fabric);
+static void	bfa_fcs_fabric_login(struct bfa_fcs_fabric_s *fabric);
+static void	bfa_fcs_fabric_notify_online(struct bfa_fcs_fabric_s *fabric);
+static void	bfa_fcs_fabric_notify_offline(struct bfa_fcs_fabric_s *fabric);
+static void	bfa_fcs_fabric_delay(void *cbarg);
+static void	bfa_fcs_fabric_delete(struct bfa_fcs_fabric_s *fabric);
+static void	bfa_fcs_fabric_delete_comp(void *cbarg);
+static void	bfa_fcs_fabric_process_uf(struct bfa_fcs_fabric_s *fabric,
 					  struct fchs_s *fchs, u16 len);
-static void     bfa_fcs_fabric_process_flogi(struct bfa_fcs_fabric_s *fabric,
+static void	bfa_fcs_fabric_process_flogi(struct bfa_fcs_fabric_s *fabric,
 					     struct fchs_s *fchs, u16 len);
-static void     bfa_fcs_fabric_send_flogi_acc(struct bfa_fcs_fabric_s *fabric);
-static void     bfa_fcs_fabric_flogiacc_comp(void *fcsarg,
+static void	bfa_fcs_fabric_send_flogi_acc(struct bfa_fcs_fabric_s *fabric);
+static void	bfa_fcs_fabric_flogiacc_comp(void *fcsarg,
 					     struct bfa_fcxp_s *fcxp,
-					     void *cbarg, bfa_status_t status,
+					     void *cbarg,
+					     bfa_status_t status,
 					     u32 rsp_len,
 					     u32 resid_len,
 					     struct fchs_s *rspfchs);
@@ -73,54 +74,51 @@ static void     bfa_fcs_fabric_flogiacc_
  * Fabric state machine events
  */
 enum bfa_fcs_fabric_event {
-	BFA_FCS_FABRIC_SM_CREATE = 1,	/*  fabric create from driver */
-	BFA_FCS_FABRIC_SM_DELETE = 2,	/*  fabric delete from driver */
-	BFA_FCS_FABRIC_SM_LINK_DOWN = 3,	/*  link down from port */
-	BFA_FCS_FABRIC_SM_LINK_UP = 4,	/*  link up from port */
-	BFA_FCS_FABRIC_SM_CONT_OP = 5,	/*  continue op from flogi/auth */
-	BFA_FCS_FABRIC_SM_RETRY_OP = 6,	/*  continue op from flogi/auth */
-	BFA_FCS_FABRIC_SM_NO_FABRIC = 7,	/*  no fabric from flogi/auth
-						 */
-	BFA_FCS_FABRIC_SM_PERF_EVFP = 8,	/*  perform EVFP from
-						 *flogi/auth */
-	BFA_FCS_FABRIC_SM_ISOLATE = 9,	/*  isolate from EVFP processing */
-	BFA_FCS_FABRIC_SM_NO_TAGGING = 10,/*  no VFT tagging from EVFP */
-	BFA_FCS_FABRIC_SM_DELAYED = 11,	/*  timeout delay event */
-	BFA_FCS_FABRIC_SM_AUTH_FAILED = 12,	/*  authentication failed */
-	BFA_FCS_FABRIC_SM_AUTH_SUCCESS = 13,	/*  authentication successful
-						 */
-	BFA_FCS_FABRIC_SM_DELCOMP = 14,	/*  all vports deleted event */
-	BFA_FCS_FABRIC_SM_LOOPBACK = 15,	/*  Received our own FLOGI */
-	BFA_FCS_FABRIC_SM_START = 16,	/*  fabric delete from driver */
+	BFA_FCS_FABRIC_SM_CREATE	= 1,  /*  fabric create from driver */
+	BFA_FCS_FABRIC_SM_DELETE	= 2,  /*  fabric delete from driver */
+	BFA_FCS_FABRIC_SM_LINK_DOWN	= 3,  /*  link down from port */
+	BFA_FCS_FABRIC_SM_LINK_UP	= 4,  /*  link up from port */
+	BFA_FCS_FABRIC_SM_CONT_OP	= 5,  /*  continue op from flogi/auth*/
+	BFA_FCS_FABRIC_SM_RETRY_OP	= 6,  /*  continue op from flogi/auth*/
+	BFA_FCS_FABRIC_SM_NO_FABRIC	= 7,  /*  no fabric from flogi/auth */
+	BFA_FCS_FABRIC_SM_PERF_EVFP	= 8, /*  perform EVFP from flogi/auth*/
+	BFA_FCS_FABRIC_SM_ISOLATE	= 9, /*  isolate from EVFP processing*/
+	BFA_FCS_FABRIC_SM_NO_TAGGING	= 10, /*  no VFT tagging from EVFP */
+	BFA_FCS_FABRIC_SM_DELAYED	= 11, /*  timeout delay event */
+	BFA_FCS_FABRIC_SM_AUTH_FAILED	= 12, /*  authentication failed */
+	BFA_FCS_FABRIC_SM_AUTH_SUCCESS	= 13, /*  authentication successful */
+	BFA_FCS_FABRIC_SM_DELCOMP	= 14, /*  all vports deleted event */
+	BFA_FCS_FABRIC_SM_LOOPBACK	= 15, /*  Received our own FLOGI */
+	BFA_FCS_FABRIC_SM_START		= 16, /*  fabric delete from driver */
 };
 
-static void     bfa_fcs_fabric_sm_uninit(struct bfa_fcs_fabric_s *fabric,
+static void	bfa_fcs_fabric_sm_uninit(struct bfa_fcs_fabric_s *fabric,
 					 enum bfa_fcs_fabric_event event);
-static void     bfa_fcs_fabric_sm_created(struct bfa_fcs_fabric_s *fabric,
+static void	bfa_fcs_fabric_sm_created(struct bfa_fcs_fabric_s *fabric,
 					  enum bfa_fcs_fabric_event event);
-static void     bfa_fcs_fabric_sm_linkdown(struct bfa_fcs_fabric_s *fabric,
+static void	bfa_fcs_fabric_sm_linkdown(struct bfa_fcs_fabric_s *fabric,
 					   enum bfa_fcs_fabric_event event);
-static void     bfa_fcs_fabric_sm_flogi(struct bfa_fcs_fabric_s *fabric,
+static void	bfa_fcs_fabric_sm_flogi(struct bfa_fcs_fabric_s *fabric,
 					enum bfa_fcs_fabric_event event);
-static void     bfa_fcs_fabric_sm_flogi_retry(struct bfa_fcs_fabric_s *fabric,
+static void	bfa_fcs_fabric_sm_flogi_retry(struct bfa_fcs_fabric_s *fabric,
 					      enum bfa_fcs_fabric_event event);
-static void     bfa_fcs_fabric_sm_auth(struct bfa_fcs_fabric_s *fabric,
+static void	bfa_fcs_fabric_sm_auth(struct bfa_fcs_fabric_s *fabric,
 				       enum bfa_fcs_fabric_event event);
-static void     bfa_fcs_fabric_sm_auth_failed(struct bfa_fcs_fabric_s *fabric,
+static void	bfa_fcs_fabric_sm_auth_failed(struct bfa_fcs_fabric_s *fabric,
 					      enum bfa_fcs_fabric_event event);
-static void     bfa_fcs_fabric_sm_loopback(struct bfa_fcs_fabric_s *fabric,
+static void	bfa_fcs_fabric_sm_loopback(struct bfa_fcs_fabric_s *fabric,
 					   enum bfa_fcs_fabric_event event);
-static void     bfa_fcs_fabric_sm_nofabric(struct bfa_fcs_fabric_s *fabric,
+static void	bfa_fcs_fabric_sm_nofabric(struct bfa_fcs_fabric_s *fabric,
 					   enum bfa_fcs_fabric_event event);
-static void     bfa_fcs_fabric_sm_online(struct bfa_fcs_fabric_s *fabric,
+static void	bfa_fcs_fabric_sm_online(struct bfa_fcs_fabric_s *fabric,
 					 enum bfa_fcs_fabric_event event);
-static void     bfa_fcs_fabric_sm_evfp(struct bfa_fcs_fabric_s *fabric,
+static void	bfa_fcs_fabric_sm_evfp(struct bfa_fcs_fabric_s *fabric,
 				       enum bfa_fcs_fabric_event event);
-static void     bfa_fcs_fabric_sm_evfp_done(struct bfa_fcs_fabric_s *fabric,
+static void	bfa_fcs_fabric_sm_evfp_done(struct bfa_fcs_fabric_s *fabric,
 					    enum bfa_fcs_fabric_event event);
-static void     bfa_fcs_fabric_sm_isolated(struct bfa_fcs_fabric_s *fabric,
+static void	bfa_fcs_fabric_sm_isolated(struct bfa_fcs_fabric_s *fabric,
 					   enum bfa_fcs_fabric_event event);
-static void     bfa_fcs_fabric_sm_deleting(struct bfa_fcs_fabric_s *fabric,
+static void	bfa_fcs_fabric_sm_deleting(struct bfa_fcs_fabric_s *fabric,
 					   enum bfa_fcs_fabric_event event);
 /**
  *   Beginning state before fabric creation.
@@ -136,8 +134,7 @@ bfa_fcs_fabric_sm_uninit(struct bfa_fcs_
 	case BFA_FCS_FABRIC_SM_CREATE:
 		bfa_sm_set_state(fabric, bfa_fcs_fabric_sm_created);
 		bfa_fcs_fabric_init(fabric);
-		bfa_fcs_lport_init(&fabric->bport, fabric->fcs, FC_VF_ID_NULL,
-				   &fabric->bport.port_cfg, NULL);
+		bfa_fcs_lport_init(&fabric->bport, &fabric->bport.port_cfg);
 		break;
 
 	case BFA_FCS_FABRIC_SM_LINK_UP:
@@ -161,7 +158,7 @@ bfa_fcs_fabric_sm_created(struct bfa_fcs
 
 	switch (event) {
 	case BFA_FCS_FABRIC_SM_START:
-		if (bfa_pport_is_linkup(fabric->fcs->bfa)) {
+		if (bfa_fcport_is_linkup(fabric->fcs->bfa)) {
 			bfa_sm_set_state(fabric, bfa_fcs_fabric_sm_flogi);
 			bfa_fcs_fabric_login(fabric);
 		} else
@@ -225,7 +222,8 @@ bfa_fcs_fabric_sm_flogi(struct bfa_fcs_f
 	switch (event) {
 	case BFA_FCS_FABRIC_SM_CONT_OP:
 
-		bfa_pport_set_tx_bbcredit(fabric->fcs->bfa, fabric->bb_credit);
+		bfa_fcport_set_tx_bbcredit(fabric->fcs->bfa,
+					  fabric->bb_credit);
 		fabric->fab_type = BFA_FCS_FABRIC_SWITCHED;
 
 		if (fabric->auth_reqd && fabric->is_auth) {
@@ -252,7 +250,8 @@ bfa_fcs_fabric_sm_flogi(struct bfa_fcs_f
 
 	case BFA_FCS_FABRIC_SM_NO_FABRIC:
 		fabric->fab_type = BFA_FCS_FABRIC_N2N;
-		bfa_pport_set_tx_bbcredit(fabric->fcs->bfa, fabric->bb_credit);
+		bfa_fcport_set_tx_bbcredit(fabric->fcs->bfa,
+					  fabric->bb_credit);
 		bfa_fcs_fabric_notify_online(fabric);
 		bfa_sm_set_state(fabric, bfa_fcs_fabric_sm_nofabric);
 		break;
@@ -308,7 +307,7 @@ bfa_fcs_fabric_sm_flogi_retry(struct bfa
  */
 static void
 bfa_fcs_fabric_sm_auth(struct bfa_fcs_fabric_s *fabric,
-		       enum bfa_fcs_fabric_event event)
+			enum bfa_fcs_fabric_event event)
 {
 	bfa_trc(fabric->fcs, fabric->bport.port_cfg.pwwn);
 	bfa_trc(fabric->fcs, event);
@@ -419,7 +418,8 @@ bfa_fcs_fabric_sm_nofabric(struct bfa_fc
 
 	case BFA_FCS_FABRIC_SM_NO_FABRIC:
 		bfa_trc(fabric->fcs, fabric->bb_credit);
-		bfa_pport_set_tx_bbcredit(fabric->fcs->bfa, fabric->bb_credit);
+		bfa_fcport_set_tx_bbcredit(fabric->fcs->bfa,
+					  fabric->bb_credit);
 		break;
 
 	default:
@@ -467,7 +467,7 @@ bfa_fcs_fabric_sm_online(struct bfa_fcs_
  */
 static void
 bfa_fcs_fabric_sm_evfp(struct bfa_fcs_fabric_s *fabric,
-		       enum bfa_fcs_fabric_event event)
+			enum bfa_fcs_fabric_event event)
 {
 	bfa_trc(fabric->fcs, fabric->bport.port_cfg.pwwn);
 	bfa_trc(fabric->fcs, event);
@@ -563,32 +563,24 @@ void
 bfa_fcs_fabric_psymb_init(struct bfa_fcs_fabric_s *fabric)
 {
 	struct bfa_port_cfg_s *port_cfg = &fabric->bport.port_cfg;
-	struct bfa_adapter_attr_s adapter_attr;
-	struct bfa_fcs_driver_info_s *driver_info = &fabric->fcs->driver_info;
+    char            model[BFA_ADAPTER_MODEL_NAME_LEN] = {0};
+	struct bfa_fcs_driver_info_s  *driver_info = &fabric->fcs->driver_info;
 
-	bfa_os_memset((void *)&adapter_attr, 0,
-		      sizeof(struct bfa_adapter_attr_s));
-	bfa_ioc_get_adapter_attr(&fabric->fcs->bfa->ioc, &adapter_attr);
+    bfa_ioc_get_adapter_model(&fabric->fcs->bfa->ioc, model);
 
-	/*
-	 * Model name/number
-	 */
-	strncpy((char *)&port_cfg->sym_name, adapter_attr.model,
+	/* Model name/number */
+	strncpy((char *)&port_cfg->sym_name, model,
 		BFA_FCS_PORT_SYMBNAME_MODEL_SZ);
 	strncat((char *)&port_cfg->sym_name, BFA_FCS_PORT_SYMBNAME_SEPARATOR,
 		sizeof(BFA_FCS_PORT_SYMBNAME_SEPARATOR));
 
-	/*
-	 * Driver Version
-	 */
+	/* Driver Version */
 	strncat((char *)&port_cfg->sym_name, (char *)driver_info->version,
 		BFA_FCS_PORT_SYMBNAME_VERSION_SZ);
 	strncat((char *)&port_cfg->sym_name, BFA_FCS_PORT_SYMBNAME_SEPARATOR,
 		sizeof(BFA_FCS_PORT_SYMBNAME_SEPARATOR));
 
-	/*
-	 * Host machine name
-	 */
+	/* Host machine name */
 	strncat((char *)&port_cfg->sym_name,
 		(char *)driver_info->host_machine_name,
 		BFA_FCS_PORT_SYMBNAME_MACHINENAME_SZ);
@@ -602,7 +594,8 @@ bfa_fcs_fabric_psymb_init(struct bfa_fcs
 	 */
 	if (driver_info->host_os_patch[0] == '\0') {
 		strncat((char *)&port_cfg->sym_name,
-			(char *)driver_info->host_os_name, BFA_FCS_OS_STR_LEN);
+			(char *)driver_info->host_os_name,
+			BFA_FCS_OS_STR_LEN);
 		strncat((char *)&port_cfg->sym_name,
 			BFA_FCS_PORT_SYMBNAME_SEPARATOR,
 			sizeof(BFA_FCS_PORT_SYMBNAME_SEPARATOR));
@@ -614,17 +607,13 @@ bfa_fcs_fabric_psymb_init(struct bfa_fcs
 			BFA_FCS_PORT_SYMBNAME_SEPARATOR,
 			sizeof(BFA_FCS_PORT_SYMBNAME_SEPARATOR));
 
-		/*
-		 * Append host OS Patch Info
-		 */
+		/* Append host OS Patch Info */
 		strncat((char *)&port_cfg->sym_name,
 			(char *)driver_info->host_os_patch,
 			BFA_FCS_PORT_SYMBNAME_OSPATCH_SZ);
 	}
 
-	/*
-	 * null terminate
-	 */
+	/* null terminate */
 	port_cfg->sym_name.symname[BFA_SYMNAME_MAXLEN - 1] = 0;
 }
 
@@ -645,9 +634,7 @@ bfa_cb_lps_flogi_comp(void *bfad, void *
 		break;
 
 	case BFA_STATUS_INVALID_MAC:
-		/*
-		 * Only for CNA
-		 */
+		/* Only for CNA */
 		fabric->stats.flogi_acc_err++;
 		bfa_sm_send_event(fabric, BFA_FCS_FABRIC_SM_RETRY_OP);
 
@@ -685,7 +672,7 @@ bfa_cb_lps_flogi_comp(void *bfad, void *
 	bfa_trc(fabric->fcs, fabric->bb_credit);
 
 	if (!bfa_lps_is_brcd_fabric(fabric->lps))
-		fabric->fabric_name = bfa_lps_get_peer_nwwn(fabric->lps);
+		fabric->fabric_name =  bfa_lps_get_peer_nwwn(fabric->lps);
 
 	/*
 	 * Check port type. It should be 1 = F-port.
@@ -708,21 +695,20 @@ bfa_cb_lps_flogi_comp(void *bfad, void *
 	bfa_trc(fabric->fcs, fabric->is_npiv);
 	bfa_trc(fabric->fcs, fabric->is_auth);
 }
-
 /**
- * 		Allocate and send FLOGI.
+ *		Allocate and send FLOGI.
  */
 static void
 bfa_fcs_fabric_login(struct bfa_fcs_fabric_s *fabric)
 {
-	struct bfa_s   *bfa = fabric->fcs->bfa;
-	struct bfa_port_cfg_s *pcfg = &fabric->bport.port_cfg;
-	u8         alpa = 0;
+	struct bfa_s		*bfa = fabric->fcs->bfa;
+	struct bfa_port_cfg_s	*pcfg = &fabric->bport.port_cfg;
+	u8			alpa = 0;
 
-	if (bfa_pport_get_topology(bfa) == BFA_PPORT_TOPOLOGY_LOOP)
-		alpa = bfa_pport_get_myalpa(bfa);
+	if (bfa_fcport_get_topology(bfa) == BFA_PPORT_TOPOLOGY_LOOP)
+		alpa = bfa_fcport_get_myalpa(bfa);
 
-	bfa_lps_flogi(fabric->lps, fabric, alpa, bfa_pport_get_maxfrsize(bfa),
+	bfa_lps_flogi(fabric->lps, fabric, alpa, bfa_fcport_get_maxfrsize(bfa),
 		      pcfg->pwwn, pcfg->nwwn, fabric->auth_reqd);
 
 	fabric->stats.flogi_sent++;
@@ -732,7 +718,7 @@ static void
 bfa_fcs_fabric_notify_online(struct bfa_fcs_fabric_s *fabric)
 {
 	struct bfa_fcs_vport_s *vport;
-	struct list_head *qe, *qen;
+	struct list_head	      *qe, *qen;
 
 	bfa_trc(fabric->fcs, fabric->fabric_name);
 
@@ -745,7 +731,7 @@ bfa_fcs_fabric_notify_online(struct bfa_
 	bfa_fcs_port_online(&fabric->bport);
 
 	list_for_each_safe(qe, qen, &fabric->vport_q) {
-		vport = (struct bfa_fcs_vport_s *)qe;
+		vport = (struct bfa_fcs_vport_s *) qe;
 		bfa_fcs_vport_online(vport);
 	}
 }
@@ -754,7 +740,7 @@ static void
 bfa_fcs_fabric_notify_offline(struct bfa_fcs_fabric_s *fabric)
 {
 	struct bfa_fcs_vport_s *vport;
-	struct list_head *qe, *qen;
+	struct list_head	      *qe, *qen;
 
 	bfa_trc(fabric->fcs, fabric->fabric_name);
 	fabric->stats.fabric_offlines++;
@@ -763,7 +749,7 @@ bfa_fcs_fabric_notify_offline(struct bfa
 	 * notify offline event first to vports and then base port.
 	 */
 	list_for_each_safe(qe, qen, &fabric->vport_q) {
-		vport = (struct bfa_fcs_vport_s *)qe;
+		vport = (struct bfa_fcs_vport_s *) qe;
 		bfa_fcs_vport_offline(vport);
 	}
 
@@ -788,10 +774,10 @@ static void
 bfa_fcs_fabric_delete(struct bfa_fcs_fabric_s *fabric)
 {
 	struct bfa_fcs_vport_s *vport;
-	struct list_head *qe, *qen;
+	struct list_head	      *qe, *qen;
 
 	list_for_each_safe(qe, qen, &fabric->vport_q) {
-		vport = (struct bfa_fcs_vport_s *)qe;
+		vport = (struct bfa_fcs_vport_s *) qe;
 		bfa_fcs_vport_delete(vport);
 	}
 
@@ -814,10 +800,10 @@ bfa_fcs_fabric_delete_comp(void *cbarg)
  */
 
 /**
- *   Module initialization
+ * Attach time initialization.
  */
 void
-bfa_fcs_fabric_modinit(struct bfa_fcs_s *fcs)
+bfa_fcs_fabric_attach(struct bfa_fcs_s *fcs)
 {
 	struct bfa_fcs_fabric_s *fabric;
 
@@ -834,14 +820,20 @@ bfa_fcs_fabric_modinit(struct bfa_fcs_s 
 	bfa_assert(fabric->lps);
 
 	/**
-	 * Initialize fabric delete completion handler. Fabric deletion is complete
-	 * when the last vport delete is complete.
+	 * Initialize fabric delete completion handler. Fabric deletion is
+	 * complete when the last vport delete is complete.
 	 */
 	bfa_wc_init(&fabric->wc, bfa_fcs_fabric_delete_comp, fabric);
-	bfa_wc_up(&fabric->wc);	/* For the base port */
+	bfa_wc_up(&fabric->wc); /* For the base port */
 
 	bfa_sm_set_state(fabric, bfa_fcs_fabric_sm_uninit);
-	bfa_sm_send_event(fabric, BFA_FCS_FABRIC_SM_CREATE);
+	bfa_fcs_lport_attach(&fabric->bport, fabric->fcs, FC_VF_ID_NULL, NULL);
+}
+
+void
+bfa_fcs_fabric_modinit(struct bfa_fcs_s *fcs)
+{
+	bfa_sm_send_event(&fcs->fabric, BFA_FCS_FABRIC_SM_CREATE);
 	bfa_trc(fcs, 0);
 }
 
@@ -887,7 +879,13 @@ bfa_fcs_fabric_modsusp(struct bfa_fcs_s 
 bfa_boolean_t
 bfa_fcs_fabric_is_loopback(struct bfa_fcs_fabric_s *fabric)
 {
-	return (bfa_sm_cmp_state(fabric, bfa_fcs_fabric_sm_loopback));
+	return bfa_sm_cmp_state(fabric, bfa_fcs_fabric_sm_loopback);
+}
+
+bfa_boolean_t
+bfa_fcs_fabric_is_auth_failed(struct bfa_fcs_fabric_s *fabric)
+{
+	return bfa_sm_cmp_state(fabric, bfa_fcs_fabric_sm_auth_failed);
 }
 
 enum bfa_pport_type
@@ -964,6 +962,7 @@ bfa_fcs_fabric_port_delete_comp(struct b
 	bfa_wc_down(&fabric->wc);
 }
 
+
 /**
  *    Check if fabric is online.
  *
@@ -974,14 +973,16 @@ bfa_fcs_fabric_port_delete_comp(struct b
 int
 bfa_fcs_fabric_is_online(struct bfa_fcs_fabric_s *fabric)
 {
-	return (bfa_sm_cmp_state(fabric, bfa_fcs_fabric_sm_online));
+	return bfa_sm_cmp_state(fabric, bfa_fcs_fabric_sm_online);
 }
 
-
+/**
+ *	brief
+ *
+ */
 bfa_status_t
 bfa_fcs_fabric_addvf(struct bfa_fcs_fabric_s *vf, struct bfa_fcs_s *fcs,
-		     struct bfa_port_cfg_s *port_cfg,
-		     struct bfad_vf_s *vf_drv)
+		     struct bfa_port_cfg_s *port_cfg, struct bfad_vf_s *vf_drv)
 {
 	bfa_sm_set_state(vf, bfa_fcs_fabric_sm_uninit);
 	return BFA_STATUS_OK;
@@ -994,10 +995,10 @@ struct bfa_fcs_vport_s *
 bfa_fcs_fabric_vport_lookup(struct bfa_fcs_fabric_s *fabric, wwn_t pwwn)
 {
 	struct bfa_fcs_vport_s *vport;
-	struct list_head *qe;
+	struct list_head	      *qe;
 
 	list_for_each(qe, &fabric->vport_q) {
-		vport = (struct bfa_fcs_vport_s *)qe;
+		vport = (struct bfa_fcs_vport_s *) qe;
 		if (bfa_fcs_port_get_pwwn(&vport->lport) == pwwn)
 			return vport;
 	}
@@ -1010,24 +1011,24 @@ bfa_fcs_fabric_vport_lookup(struct bfa_f
  *
  *   param[in] fabric - Fabric instance. This can be a base fabric or vf.
  *
-*    @return : 1 or more.
+ *   @return : 1 or more.
  */
 u16
 bfa_fcs_fabric_vport_count(struct bfa_fcs_fabric_s *fabric)
 {
-	return (fabric->num_vports);
+	return fabric->num_vports;
 }
 
 /**
- * 		Unsolicited frame receive handling.
+ *		Unsolicited frame receive handling.
  */
 void
 bfa_fcs_fabric_uf_recv(struct bfa_fcs_fabric_s *fabric, struct fchs_s *fchs,
-		       u16 len)
+					u16 len)
 {
-	u32        pid = fchs->d_id;
+	u32	pid = fchs->d_id;
 	struct bfa_fcs_vport_s *vport;
-	struct list_head *qe;
+	struct list_head	      *qe;
 	struct fc_els_cmd_s   *els_cmd = (struct fc_els_cmd_s *) (fchs + 1);
 	struct fc_logi_s     *flogi = (struct fc_logi_s *) els_cmd;
 
@@ -1075,7 +1076,7 @@ bfa_fcs_fabric_uf_recv(struct bfa_fcs_fa
 	 * look for a matching local port ID
 	 */
 	list_for_each(qe, &fabric->vport_q) {
-		vport = (struct bfa_fcs_vport_s *)qe;
+		vport = (struct bfa_fcs_vport_s *) qe;
 		if (vport->lport.pid == pid) {
 			bfa_fcs_port_uf_recv(&vport->lport, fchs, len);
 			return;
@@ -1086,7 +1087,7 @@ bfa_fcs_fabric_uf_recv(struct bfa_fcs_fa
 }
 
 /**
- * 		Unsolicited frames to be processed by fabric.
+ *		Unsolicited frames to be processed by fabric.
  */
 static void
 bfa_fcs_fabric_process_uf(struct bfa_fcs_fabric_s *fabric, struct fchs_s *fchs,
@@ -1110,11 +1111,11 @@ bfa_fcs_fabric_process_uf(struct bfa_fcs
 }
 
 /**
- * 	Process	incoming FLOGI
+ *	Process	incoming FLOGI
  */
 static void
 bfa_fcs_fabric_process_flogi(struct bfa_fcs_fabric_s *fabric,
-			struct fchs_s *fchs, u16 len)
+				struct fchs_s *fchs, u16 len)
 {
 	struct fc_logi_s     *flogi = (struct fc_logi_s *) (fchs + 1);
 	struct bfa_fcs_port_s *bport = &fabric->bport;
@@ -1150,10 +1151,10 @@ bfa_fcs_fabric_send_flogi_acc(struct bfa
 {
 	struct bfa_port_cfg_s *pcfg = &fabric->bport.port_cfg;
 	struct bfa_fcs_port_n2n_s *n2n_port = &fabric->bport.port_topo.pn2n;
-	struct bfa_s   *bfa = fabric->fcs->bfa;
+	struct bfa_s	  *bfa = fabric->fcs->bfa;
 	struct bfa_fcxp_s *fcxp;
-	u16        reqlen;
-	struct fchs_s          fchs;
+	u16	reqlen;
+	struct fchs_s		fchs;
 
 	fcxp = bfa_fcs_fcxp_alloc(fabric->fcs);
 	/**
@@ -1165,15 +1166,16 @@ bfa_fcs_fabric_send_flogi_acc(struct bfa
 	reqlen = fc_flogi_acc_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),
 				    bfa_os_hton3b(FC_FABRIC_PORT),
 				    n2n_port->reply_oxid, pcfg->pwwn,
-				    pcfg->nwwn, bfa_pport_get_maxfrsize(bfa),
-				    bfa_pport_get_rx_bbcredit(bfa));
+				    pcfg->nwwn,
+				    bfa_fcport_get_maxfrsize(bfa),
+				    bfa_fcport_get_rx_bbcredit(bfa));
 
 	bfa_fcxp_send(fcxp, NULL, fabric->vf_id, bfa_lps_get_tag(fabric->lps),
-			BFA_FALSE, FC_CLASS_3, reqlen, &fchs,
-			bfa_fcs_fabric_flogiacc_comp, fabric,
-			FC_MAX_PDUSZ, 0); /* Timeout 0 indicates no
-					   * response expected
-					   */
+		      BFA_FALSE, FC_CLASS_3,
+		      reqlen, &fchs, bfa_fcs_fabric_flogiacc_comp, fabric,
+		      FC_MAX_PDUSZ, 0);	/* Timeout 0 indicates no
+					 * response expected
+					 */
 }
 
 /**
@@ -1214,24 +1216,17 @@ static void
 bfa_fcs_fabric_aen_post(struct bfa_fcs_port_s *port,
 			enum bfa_port_aen_event event)
 {
-	union bfa_aen_data_u aen_data;
+	union bfa_aen_data_u  aen_data;
 	struct bfa_log_mod_s *logmod = port->fcs->logm;
-	wwn_t           pwwn = bfa_fcs_port_get_pwwn(port);
-	wwn_t           fwwn = bfa_fcs_port_get_fabric_name(port);
-	char            pwwn_ptr[BFA_STRING_32];
-	char            fwwn_ptr[BFA_STRING_32];
+	wwn_t pwwn = bfa_fcs_port_get_pwwn(port);
+	wwn_t fwwn = bfa_fcs_port_get_fabric_name(port);
+	char  pwwn_ptr[BFA_STRING_32];
+	char  fwwn_ptr[BFA_STRING_32];
 
 	wwn2str(pwwn_ptr, pwwn);
 	wwn2str(fwwn_ptr, fwwn);
-
-	switch (event) {
-	case BFA_PORT_AEN_FABRIC_NAME_CHANGE:
-		bfa_log(logmod, BFA_AEN_PORT_FABRIC_NAME_CHANGE, pwwn_ptr,
-			fwwn_ptr);
-		break;
-	default:
-		break;
-	}
+	bfa_log(logmod, BFA_LOG_CREATE_ID(BFA_AEN_CAT_PORT, event),
+			pwwn_ptr, fwwn_ptr);
 
 	aen_data.port.pwwn = pwwn;
 	aen_data.port.fwwn = fwwn;
@@ -1246,7 +1241,7 @@ bfa_fcs_fabric_aen_post(struct bfa_fcs_p
  */
 void
 bfa_fcs_fabric_set_fabric_name(struct bfa_fcs_fabric_s *fabric,
-			       wwn_t fabric_name)
+				wwn_t fabric_name)
 {
 	bfa_trc(fabric->fcs, fabric_name);
 
@@ -1258,15 +1253,12 @@ bfa_fcs_fabric_set_fabric_name(struct bf
 		fabric->fabric_name = fabric_name;
 	} else {
 		fabric->fabric_name = fabric_name;
-		/*
-		 * Generate a Event
-		 */
+		/* Generate a Event */
 		bfa_fcs_fabric_aen_post(&fabric->bport,
-					BFA_PORT_AEN_FABRIC_NAME_CHANGE);
+				BFA_PORT_AEN_FABRIC_NAME_CHANGE);
 	}
 
 }
-
 /**
  * Not used by FCS.
  */
diff -uprN a/drivers/scsi/bfa/fcbuild.c b/drivers/scsi/bfa/fcbuild.c
--- a/drivers/scsi/bfa/fcbuild.c	2009-12-18 18:16:22.373685000 -0800
+++ b/drivers/scsi/bfa/fcbuild.c	2009-11-25 18:21:07.000000000 -0800
@@ -24,10 +24,10 @@
 /*
  * static build functions
  */
-static void fc_els_rsp_build(struct fchs_s *fchs, u32 d_id, u32 s_id,
-			u16 ox_id);
-static void fc_bls_rsp_build(struct fchs_s *fchs, u32 d_id, u32 s_id,
-			u16 ox_id);
+static void     fc_els_rsp_build(struct fchs_s *fchs, u32 d_id, u32 s_id,
+				 u16 ox_id);
+static void     fc_bls_rsp_build(struct fchs_s *fchs, u32 d_id, u32 s_id,
+				 u16 ox_id);
 static struct fchs_s   fc_els_req_tmpl;
 static struct fchs_s   fc_els_rsp_tmpl;
 static struct fchs_s   fc_bls_req_tmpl;
@@ -123,7 +123,7 @@ fcbuild_init(void)
 	rrq_tmpl.els_cmd.els_code = FC_ELS_RRQ;
 
 	/*
-	 * fcp_fchs_tmpl
+	 * fcp_struct fchs_smpl
 	 */
 	fcp_fchs_tmpl.routing = FC_RTG_FC4_DEV_DATA;
 	fcp_fchs_tmpl.cat_info = FC_CAT_UNSOLICIT_CMD;
@@ -135,8 +135,7 @@ fcbuild_init(void)
 }
 
 static void
-fc_gs_fchdr_build(struct fchs_s *fchs, u32 d_id, u32 s_id,
-			u32 ox_id)
+fc_gs_fchdr_build(struct fchs_s *fchs, u32 d_id, u32 s_id, u32 ox_id)
 {
 	bfa_os_memset(fchs, 0, sizeof(struct fchs_s));
 
@@ -158,8 +157,7 @@ fc_gs_fchdr_build(struct fchs_s *fchs, u
 }
 
 void
-fc_els_req_build(struct fchs_s *fchs, u32 d_id, u32 s_id,
-			u16 ox_id)
+fc_els_req_build(struct fchs_s *fchs, u32 d_id, u32 s_id, u16 ox_id)
 {
 	bfa_os_memcpy(fchs, &fc_els_req_tmpl, sizeof(struct fchs_s));
 	fchs->d_id = (d_id);
@@ -168,8 +166,7 @@ fc_els_req_build(struct fchs_s *fchs, u3
 }
 
 static void
-fc_els_rsp_build(struct fchs_s *fchs, u32 d_id, u32 s_id,
-			u16 ox_id)
+fc_els_rsp_build(struct fchs_s *fchs, u32 d_id, u32 s_id, u16 ox_id)
 {
 	bfa_os_memcpy(fchs, &fc_els_rsp_tmpl, sizeof(struct fchs_s));
 	fchs->d_id = d_id;
@@ -188,19 +185,18 @@ fc_els_rsp_parse(struct fchs_s *fchs, in
 	switch (els_cmd->els_code) {
 	case FC_ELS_LS_RJT:
 		if (ls_rjt->reason_code == FC_LS_RJT_RSN_LOGICAL_BUSY)
-			return (FC_PARSE_BUSY);
+			return FC_PARSE_BUSY;
 		else
-			return (FC_PARSE_FAILURE);
+			return FC_PARSE_FAILURE;
 
 	case FC_ELS_ACC:
-		return (FC_PARSE_OK);
+		return FC_PARSE_OK;
 	}
-	return (FC_PARSE_OK);
+	return FC_PARSE_OK;
 }
 
 static void
-fc_bls_rsp_build(struct fchs_s *fchs, u32 d_id, u32 s_id,
-			u16 ox_id)
+fc_bls_rsp_build(struct fchs_s *fchs, u32 d_id, u32 s_id, u16 ox_id)
 {
 	bfa_os_memcpy(fchs, &fc_bls_rsp_tmpl, sizeof(struct fchs_s));
 	fchs->d_id = d_id;
@@ -228,7 +224,7 @@ fc_plogi_x_build(struct fchs_s *fchs, vo
 	bfa_os_memcpy(&plogi->port_name, &port_name, sizeof(wwn_t));
 	bfa_os_memcpy(&plogi->node_name, &node_name, sizeof(wwn_t));
 
-	return (sizeof(struct fc_logi_s));
+	return sizeof(struct fc_logi_s);
 }
 
 u16
@@ -267,7 +263,7 @@ fc_flogi_build(struct fchs_s *fchs, stru
 	flogi->csp.npiv_supp    = 1; /* @todo. field name is not correct */
 	vvl_info[0]	= bfa_os_htonl(FLOGI_VVL_BRCD);
 
-	return (sizeof(struct fc_logi_s));
+	return sizeof(struct fc_logi_s);
 }
 
 u16
@@ -287,7 +283,7 @@ fc_flogi_acc_build(struct fchs_s *fchs, 
 
 	flogi->csp.bbcred = bfa_os_htons(local_bb_credits);
 
-	return (sizeof(struct fc_logi_s));
+	return sizeof(struct fc_logi_s);
 }
 
 u16
@@ -306,7 +302,7 @@ fc_fdisc_build(struct fchs_s *fchs, stru
 	flogi->port_name = port_name;
 	flogi->node_name = node_name;
 
-	return (sizeof(struct fc_logi_s));
+	return sizeof(struct fc_logi_s);
 }
 
 u16
@@ -338,26 +334,26 @@ fc_plogi_rsp_parse(struct fchs_s *fchs, 
 	case FC_ELS_LS_RJT:
 		ls_rjt = (struct fc_ls_rjt_s *) (fchs + 1);
 		if (ls_rjt->reason_code == FC_LS_RJT_RSN_LOGICAL_BUSY)
-			return (FC_PARSE_BUSY);
+			return FC_PARSE_BUSY;
 		else
-			return (FC_PARSE_FAILURE);
+			return FC_PARSE_FAILURE;
 	case FC_ELS_ACC:
 		plogi = (struct fc_logi_s *) (fchs + 1);
 		if (len < sizeof(struct fc_logi_s))
-			return (FC_PARSE_FAILURE);
+			return FC_PARSE_FAILURE;
 
 		if (!wwn_is_equal(plogi->port_name, port_name))
-			return (FC_PARSE_FAILURE);
+			return FC_PARSE_FAILURE;
 
 		if (!plogi->class3.class_valid)
-			return (FC_PARSE_FAILURE);
+			return FC_PARSE_FAILURE;
 
 		if (bfa_os_ntohs(plogi->class3.rxsz) < (FC_MIN_PDUSZ))
-			return (FC_PARSE_FAILURE);
+			return FC_PARSE_FAILURE;
 
-		return (FC_PARSE_OK);
+		return FC_PARSE_OK;
 	default:
-		return (FC_PARSE_FAILURE);
+		return FC_PARSE_FAILURE;
 	}
 }
 
@@ -372,7 +368,7 @@ fc_plogi_parse(struct fchs_s *fchs)
 	if ((bfa_os_ntohs(plogi->class3.rxsz) < FC_MIN_PDUSZ)
 	    || (bfa_os_ntohs(plogi->class3.rxsz) > FC_MAX_PDUSZ)
 	    || (plogi->class3.rxsz == 0))
-		return (FC_PARSE_FAILURE);
+		return FC_PARSE_FAILURE;
 
 	return FC_PARSE_OK;
 }
@@ -393,7 +389,7 @@ fc_prli_build(struct fchs_s *fchs, void 
 	prli->parampage.servparams.task_retry_id = 0;
 	prli->parampage.servparams.confirm       = 1;
 
-	return (sizeof(struct fc_prli_s));
+	return sizeof(struct fc_prli_s);
 }
 
 u16
@@ -414,46 +410,46 @@ fc_prli_acc_build(struct fchs_s *fchs, v
 
 	prli->parampage.rspcode = FC_PRLI_ACC_XQTD;
 
-	return (sizeof(struct fc_prli_s));
+	return sizeof(struct fc_prli_s);
 }
 
 enum fc_parse_status
 fc_prli_rsp_parse(struct fc_prli_s *prli, int len)
 {
 	if (len < sizeof(struct fc_prli_s))
-		return (FC_PARSE_FAILURE);
+		return FC_PARSE_FAILURE;
 
 	if (prli->command != FC_ELS_ACC)
-		return (FC_PARSE_FAILURE);
+		return FC_PARSE_FAILURE;
 
 	if ((prli->parampage.rspcode != FC_PRLI_ACC_XQTD)
 	    && (prli->parampage.rspcode != FC_PRLI_ACC_PREDEF_IMG))
-		return (FC_PARSE_FAILURE);
+		return FC_PARSE_FAILURE;
 
 	if (prli->parampage.servparams.target != 1)
-		return (FC_PARSE_FAILURE);
+		return FC_PARSE_FAILURE;
 
-	return (FC_PARSE_OK);
+	return FC_PARSE_OK;
 }
 
 enum fc_parse_status
 fc_prli_parse(struct fc_prli_s *prli)
 {
 	if (prli->parampage.type != FC_TYPE_FCP)
-		return (FC_PARSE_FAILURE);
+		return FC_PARSE_FAILURE;
 
 	if (!prli->parampage.imagepair)
-		return (FC_PARSE_FAILURE);
+		return FC_PARSE_FAILURE;
 
 	if (!prli->parampage.servparams.initiator)
-		return (FC_PARSE_FAILURE);
+		return FC_PARSE_FAILURE;
 
-	return (FC_PARSE_OK);
+	return FC_PARSE_OK;
 }
 
 u16
-fc_logo_build(struct fchs_s *fchs, struct fc_logo_s *logo, u32 d_id,
-			u32 s_id, u16 ox_id, wwn_t port_name)
+fc_logo_build(struct fchs_s *fchs, struct fc_logo_s *logo, u32 d_id, u32 s_id,
+	      u16 ox_id, wwn_t port_name)
 {
 	fc_els_req_build(fchs, d_id, s_id, ox_id);
 
@@ -462,7 +458,7 @@ fc_logo_build(struct fchs_s *fchs, struc
 	logo->nport_id = (s_id);
 	logo->orig_port_name = port_name;
 
-	return (sizeof(struct fc_logo_s));
+	return sizeof(struct fc_logo_s);
 }
 
 static          u16
@@ -484,7 +480,7 @@ fc_adisc_x_build(struct fchs_s *fchs, st
 	adisc->orig_node_name = node_name;
 	adisc->nport_id = (s_id);
 
-	return (sizeof(struct fc_adisc_s));
+	return sizeof(struct fc_adisc_s);
 }
 
 u16
@@ -511,32 +507,32 @@ fc_adisc_rsp_parse(struct fc_adisc_s *ad
 {
 
 	if (len < sizeof(struct fc_adisc_s))
-		return (FC_PARSE_FAILURE);
+		return FC_PARSE_FAILURE;
 
 	if (adisc->els_cmd.els_code != FC_ELS_ACC)
-		return (FC_PARSE_FAILURE);
+		return FC_PARSE_FAILURE;
 
 	if (!wwn_is_equal(adisc->orig_port_name, port_name))
-		return (FC_PARSE_FAILURE);
+		return FC_PARSE_FAILURE;
 
-	return (FC_PARSE_OK);
+	return FC_PARSE_OK;
 }
 
 enum fc_parse_status
 fc_adisc_parse(struct fchs_s *fchs, void *pld, u32 host_dap,
-		 wwn_t node_name, wwn_t port_name)
+		wwn_t node_name, wwn_t port_name)
 {
 	struct fc_adisc_s     *adisc = (struct fc_adisc_s *) pld;
 
 	if (adisc->els_cmd.els_code != FC_ELS_ACC)
-		return (FC_PARSE_FAILURE);
+		return FC_PARSE_FAILURE;
 
 	if ((adisc->nport_id == (host_dap))
 	    && wwn_is_equal(adisc->orig_port_name, port_name)
 	    && wwn_is_equal(adisc->orig_node_name, node_name))
-		return (FC_PARSE_OK);
+		return FC_PARSE_OK;
 
-	return (FC_PARSE_FAILURE);
+	return FC_PARSE_FAILURE;
 }
 
 enum fc_parse_status
@@ -548,15 +544,15 @@ fc_pdisc_parse(struct fchs_s *fchs, wwn_
 		return FC_PARSE_FAILURE;
 
 	if ((bfa_os_ntohs(pdisc->class3.rxsz) <
-		 (FC_MIN_PDUSZ - sizeof(struct fchs_s)))
+			(FC_MIN_PDUSZ - sizeof(struct fchs_s)))
 	    || (pdisc->class3.rxsz == 0))
-		return (FC_PARSE_FAILURE);
+		return FC_PARSE_FAILURE;
 
 	if (!wwn_is_equal(pdisc->port_name, port_name))
-		return (FC_PARSE_FAILURE);
+		return FC_PARSE_FAILURE;
 
 	if (!wwn_is_equal(pdisc->node_name, node_name))
-		return (FC_PARSE_FAILURE);
+		return FC_PARSE_FAILURE;
 
 	return FC_PARSE_OK;
 }
@@ -570,7 +566,7 @@ fc_abts_build(struct fchs_s *fchs, u32 d
 	fchs->s_id = (s_id);
 	fchs->ox_id = bfa_os_htons(ox_id);
 
-	return (sizeof(struct fchs_s));
+	return sizeof(struct fchs_s);
 }
 
 enum fc_parse_status
@@ -578,14 +574,14 @@ fc_abts_rsp_parse(struct fchs_s *fchs, i
 {
 	if ((fchs->cat_info == FC_CAT_BA_ACC)
 	    || (fchs->cat_info == FC_CAT_BA_RJT))
-		return (FC_PARSE_OK);
+		return FC_PARSE_OK;
 
-	return (FC_PARSE_FAILURE);
+	return FC_PARSE_FAILURE;
 }
 
 u16
 fc_rrq_build(struct fchs_s *fchs, struct fc_rrq_s *rrq, u32 d_id,
-			 u32 s_id, u16 ox_id, u16 rrq_oxid)
+		u32 s_id, u16 ox_id, u16 rrq_oxid)
 {
 	fc_els_req_build(fchs, d_id, s_id, ox_id);
 
@@ -597,7 +593,7 @@ fc_rrq_build(struct fchs_s *fchs, struct
 	rrq->ox_id = bfa_os_htons(rrq_oxid);
 	rrq->rx_id = FC_RXID_ANY;
 
-	return (sizeof(struct fc_rrq_s));
+	return sizeof(struct fc_rrq_s);
 }
 
 u16
@@ -611,7 +607,7 @@ fc_logo_acc_build(struct fchs_s *fchs, v
 	memset(acc, 0, sizeof(struct fc_els_cmd_s));
 	acc->els_code = FC_ELS_ACC;
 
-	return (sizeof(struct fc_els_cmd_s));
+	return sizeof(struct fc_els_cmd_s);
 }
 
 u16
@@ -627,7 +623,7 @@ fc_ls_rjt_build(struct fchs_s *fchs, str
 	ls_rjt->reason_code_expl = reason_code_expl;
 	ls_rjt->vendor_unique = 0x00;
 
-	return (sizeof(struct fc_ls_rjt_s));
+	return sizeof(struct fc_ls_rjt_s);
 }
 
 u16
@@ -643,18 +639,18 @@ fc_ba_acc_build(struct fchs_s *fchs, str
 	ba_acc->ox_id = fchs->ox_id;
 	ba_acc->rx_id = fchs->rx_id;
 
-	return (sizeof(struct fc_ba_acc_s));
+	return sizeof(struct fc_ba_acc_s);
 }
 
 u16
-fc_ls_acc_build(struct fchs_s *fchs, struct fc_els_cmd_s *els_cmd,
-			u32 d_id, u32 s_id, u16 ox_id)
+fc_ls_acc_build(struct fchs_s *fchs, struct fc_els_cmd_s *els_cmd, u32 d_id,
+		u32 s_id, u16 ox_id)
 {
 	fc_els_rsp_build(fchs, d_id, s_id, ox_id);
 	memset(els_cmd, 0, sizeof(struct fc_els_cmd_s));
 	els_cmd->els_code = FC_ELS_ACC;
 
-	return (sizeof(struct fc_els_cmd_s));
+	return sizeof(struct fc_els_cmd_s);
 }
 
 int
@@ -676,8 +672,7 @@ fc_logout_params_pages(struct fchs_s *fc
 
 u16
 fc_tprlo_acc_build(struct fchs_s *fchs, struct fc_tprlo_acc_s *tprlo_acc,
-			u32 d_id, u32 s_id, u16 ox_id,
-			int num_pages)
+		u32 d_id, u32 s_id, u16 ox_id, int num_pages)
 {
 	int             page;
 
@@ -696,13 +691,12 @@ fc_tprlo_acc_build(struct fchs_s *fchs, 
 		tprlo_acc->tprlo_acc_params[page].orig_process_assc = 0;
 		tprlo_acc->tprlo_acc_params[page].resp_process_assc = 0;
 	}
-	return (bfa_os_ntohs(tprlo_acc->payload_len));
+	return bfa_os_ntohs(tprlo_acc->payload_len);
 }
 
 u16
 fc_prlo_acc_build(struct fchs_s *fchs, struct fc_prlo_acc_s *prlo_acc,
-			u32 d_id, u32 s_id, u16 ox_id,
-			int num_pages)
+		u32 d_id, u32 s_id, u16 ox_id, int num_pages)
 {
 	int             page;
 
@@ -721,12 +715,12 @@ fc_prlo_acc_build(struct fchs_s *fchs, s
 		prlo_acc->prlo_acc_params[page].resp_process_assc = 0;
 	}
 
-	return (bfa_os_ntohs(prlo_acc->payload_len));
+	return bfa_os_ntohs(prlo_acc->payload_len);
 }
 
 u16
 fc_rnid_build(struct fchs_s *fchs, struct fc_rnid_cmd_s *rnid, u32 d_id,
-			u32 s_id, u16 ox_id, u32 data_format)
+	u32 s_id, u16 ox_id, u32 data_format)
 {
 	fc_els_req_build(fchs, d_id, s_id, ox_id);
 
@@ -735,15 +729,15 @@ fc_rnid_build(struct fchs_s *fchs, struc
 	rnid->els_cmd.els_code = FC_ELS_RNID;
 	rnid->node_id_data_format = data_format;
 
-	return (sizeof(struct fc_rnid_cmd_s));
+	return sizeof(struct fc_rnid_cmd_s);
 }
 
 u16
 fc_rnid_acc_build(struct fchs_s *fchs, struct fc_rnid_acc_s *rnid_acc,
-			u32 d_id, u32 s_id, u16 ox_id,
-			u32 data_format,
-			struct fc_rnid_common_id_data_s *common_id_data,
-			struct fc_rnid_general_topology_data_s *gen_topo_data)
+		  u32 d_id, u32 s_id, u16 ox_id,
+		  u32 data_format,
+		  struct fc_rnid_common_id_data_s *common_id_data,
+		  struct fc_rnid_general_topology_data_s *gen_topo_data)
 {
 	memset(rnid_acc, 0, sizeof(struct fc_rnid_acc_s));
 
@@ -759,30 +753,29 @@ fc_rnid_acc_build(struct fchs_s *fchs, s
 		rnid_acc->specific_id_data_length =
 			sizeof(struct fc_rnid_general_topology_data_s);
 		bfa_os_assign(rnid_acc->gen_topology_data, *gen_topo_data);
-		return (sizeof(struct fc_rnid_acc_s));
+		return sizeof(struct fc_rnid_acc_s);
 	} else {
-		return (sizeof(struct fc_rnid_acc_s) -
-			sizeof(struct fc_rnid_general_topology_data_s));
+		return sizeof(struct fc_rnid_acc_s) -
+			sizeof(struct fc_rnid_general_topology_data_s);
 	}
 
 }
 
 u16
 fc_rpsc_build(struct fchs_s *fchs, struct fc_rpsc_cmd_s *rpsc, u32 d_id,
-			u32 s_id, u16 ox_id)
+		u32 s_id, u16 ox_id)
 {
 	fc_els_req_build(fchs, d_id, s_id, ox_id);
 
 	memset(rpsc, 0, sizeof(struct fc_rpsc_cmd_s));
 
 	rpsc->els_cmd.els_code = FC_ELS_RPSC;
-	return (sizeof(struct fc_rpsc_cmd_s));
+	return sizeof(struct fc_rpsc_cmd_s);
 }
 
 u16
-fc_rpsc2_build(struct fchs_s *fchs, struct fc_rpsc2_cmd_s *rpsc2,
-			u32 d_id, u32 s_id, u32 *pid_list,
-			u16 npids)
+fc_rpsc2_build(struct fchs_s *fchs, struct fc_rpsc2_cmd_s *rpsc2, u32 d_id,
+		u32 s_id, u32 *pid_list, u16 npids)
 {
 	u32 dctlr_id = FC_DOMAIN_CTRLR(bfa_os_hton3b(d_id));
 	int i = 0;
@@ -797,14 +790,13 @@ fc_rpsc2_build(struct fchs_s *fchs, stru
 	for (i = 0; i < npids; i++)
 		rpsc2->pid_list[i].pid = pid_list[i];
 
-	return (sizeof(struct fc_rpsc2_cmd_s) + ((npids - 1) *
-			(sizeof(u32))));
+	return sizeof(struct fc_rpsc2_cmd_s) + ((npids - 1) * (sizeof(u32)));
 }
 
 u16
 fc_rpsc_acc_build(struct fchs_s *fchs, struct fc_rpsc_acc_s *rpsc_acc,
-			u32 d_id, u32 s_id, u16 ox_id,
-			struct fc_rpsc_speed_info_s *oper_speed)
+		u32 d_id, u32 s_id, u16 ox_id,
+		  struct fc_rpsc_speed_info_s *oper_speed)
 {
 	memset(rpsc_acc, 0, sizeof(struct fc_rpsc_acc_s));
 
@@ -819,7 +811,7 @@ fc_rpsc_acc_build(struct fchs_s *fchs, s
 	rpsc_acc->speed_info[0].port_op_speed =
 		bfa_os_htons(oper_speed->port_op_speed);
 
-	return (sizeof(struct fc_rpsc_acc_s));
+	return sizeof(struct fc_rpsc_acc_s);
 
 }
 
@@ -842,8 +834,7 @@ fc_logo_rsp_parse(struct fchs_s *fchs, i
 
 u16
 fc_pdisc_build(struct fchs_s *fchs, u32 d_id, u32 s_id,
-			u16 ox_id, wwn_t port_name, wwn_t node_name,
-			u16 pdu_size)
+	u16 ox_id, wwn_t port_name, wwn_t node_name, u16 pdu_size)
 {
 	struct fc_logi_s     *pdisc = (struct fc_logi_s *) (fchs + 1);
 
@@ -856,7 +847,7 @@ fc_pdisc_build(struct fchs_s *fchs, u32 
 	pdisc->port_name = port_name;
 	pdisc->node_name = node_name;
 
-	return (sizeof(struct fc_logi_s));
+	return sizeof(struct fc_logi_s);
 }
 
 u16
@@ -865,21 +856,21 @@ fc_pdisc_rsp_parse(struct fchs_s *fchs, 
 	struct fc_logi_s     *pdisc = (struct fc_logi_s *) (fchs + 1);
 
 	if (len < sizeof(struct fc_logi_s))
-		return (FC_PARSE_LEN_INVAL);
+		return FC_PARSE_LEN_INVAL;
 
 	if (pdisc->els_cmd.els_code != FC_ELS_ACC)
-		return (FC_PARSE_ACC_INVAL);
+		return FC_PARSE_ACC_INVAL;
 
 	if (!wwn_is_equal(pdisc->port_name, port_name))
-		return (FC_PARSE_PWWN_NOT_EQUAL);
+		return FC_PARSE_PWWN_NOT_EQUAL;
 
 	if (!pdisc->class3.class_valid)
-		return (FC_PARSE_NWWN_NOT_EQUAL);
+		return FC_PARSE_NWWN_NOT_EQUAL;
 
 	if (bfa_os_ntohs(pdisc->class3.rxsz) < (FC_MIN_PDUSZ))
-		return (FC_PARSE_RXSZ_INVAL);
+		return FC_PARSE_RXSZ_INVAL;
 
-	return (FC_PARSE_OK);
+	return FC_PARSE_OK;
 }
 
 u16
@@ -903,7 +894,7 @@ fc_prlo_build(struct fchs_s *fchs, u32 d
 		prlo->prlo_params[page].resp_process_assc = 0;
 	}
 
-	return (bfa_os_ntohs(prlo->payload_len));
+	return bfa_os_ntohs(prlo->payload_len);
 }
 
 u16
@@ -916,7 +907,7 @@ fc_prlo_rsp_parse(struct fchs_s *fchs, i
 	len = len;
 
 	if (prlo->command != FC_ELS_ACC)
-		return (FC_PARSE_FAILURE);
+		return FC_PARSE_FAILURE;
 
 	num_pages = ((bfa_os_ntohs(prlo->payload_len)) - 4) / 16;
 
@@ -936,14 +927,14 @@ fc_prlo_rsp_parse(struct fchs_s *fchs, i
 		if (prlo->prlo_acc_params[page].resp_process_assc != 0)
 			return FC_PARSE_FAILURE;
 	}
-	return (FC_PARSE_OK);
+	return FC_PARSE_OK;
 
 }
 
 u16
 fc_tprlo_build(struct fchs_s *fchs, u32 d_id, u32 s_id,
-			u16 ox_id, int num_pages,
-			enum fc_tprlo_type tprlo_type, u32 tpr_id)
+	u16 ox_id, int num_pages, enum fc_tprlo_type tprlo_type,
+	u32 tpr_id)
 {
 	struct fc_tprlo_s     *tprlo = (struct fc_tprlo_s *) (fchs + 1);
 	int             page;
@@ -968,7 +959,7 @@ fc_tprlo_build(struct fchs_s *fchs, u32 
 		}
 	}
 
-	return (bfa_os_ntohs(tprlo->payload_len));
+	return bfa_os_ntohs(tprlo->payload_len);
 }
 
 u16
@@ -981,23 +972,23 @@ fc_tprlo_rsp_parse(struct fchs_s *fchs, 
 	len = len;
 
 	if (tprlo->command != FC_ELS_ACC)
-		return (FC_PARSE_ACC_INVAL);
+		return FC_PARSE_ACC_INVAL;
 
 	num_pages = (bfa_os_ntohs(tprlo->payload_len) - 4) / 16;
 
 	for (page = 0; page < num_pages; page++) {
 		if (tprlo->tprlo_acc_params[page].type != FC_TYPE_FCP)
-			return (FC_PARSE_NOT_FCP);
+			return FC_PARSE_NOT_FCP;
 		if (tprlo->tprlo_acc_params[page].opa_valid != 0)
-			return (FC_PARSE_OPAFLAG_INVAL);
+			return FC_PARSE_OPAFLAG_INVAL;
 		if (tprlo->tprlo_acc_params[page].rpa_valid != 0)
-			return (FC_PARSE_RPAFLAG_INVAL);
+			return FC_PARSE_RPAFLAG_INVAL;
 		if (tprlo->tprlo_acc_params[page].orig_process_assc != 0)
-			return (FC_PARSE_OPA_INVAL);
+			return FC_PARSE_OPA_INVAL;
 		if (tprlo->tprlo_acc_params[page].resp_process_assc != 0)
-			return (FC_PARSE_RPA_INVAL);
+			return FC_PARSE_RPA_INVAL;
 	}
-	return (FC_PARSE_OK);
+	return FC_PARSE_OK;
 }
 
 enum fc_parse_status
@@ -1014,8 +1005,7 @@ fc_rrq_rsp_parse(struct fchs_s *fchs, in
 
 u16
 fc_ba_rjt_build(struct fchs_s *fchs, u32 d_id, u32 s_id,
-			u16 ox_id, u32 reason_code,
-			u32 reason_expl)
+	u16 ox_id, u32 reason_code, u32 reason_expl)
 {
 	struct fc_ba_rjt_s    *ba_rjt = (struct fc_ba_rjt_s *) (fchs + 1);
 
@@ -1024,7 +1014,7 @@ fc_ba_rjt_build(struct fchs_s *fchs, u32
 	fchs->cat_info = FC_CAT_BA_RJT;
 	ba_rjt->reason_code = reason_code;
 	ba_rjt->reason_expl = reason_expl;
-	return (sizeof(struct fc_ba_rjt_s));
+	return sizeof(struct fc_ba_rjt_s);
 }
 
 static void
@@ -1064,8 +1054,7 @@ fc_gidpn_build(struct fchs_s *fchs, void
 {
 
 	struct ct_hdr_s       *cthdr = (struct ct_hdr_s *) pyld;
-	struct fcgs_gidpn_req_s *gidpn =
-			(struct fcgs_gidpn_req_s *) (cthdr + 1);
+	struct fcgs_gidpn_req_s *gidpn = (struct fcgs_gidpn_req_s *)(cthdr + 1);
 	u32        d_id = bfa_os_hton3b(FC_NAME_SERVER);
 
 	fc_gs_fchdr_build(fchs, d_id, s_id, ox_id);
@@ -1073,7 +1062,7 @@ fc_gidpn_build(struct fchs_s *fchs, void
 
 	bfa_os_memset(gidpn, 0, sizeof(struct fcgs_gidpn_req_s));
 	gidpn->port_name = port_name;
-	return (sizeof(struct fcgs_gidpn_req_s) + sizeof(struct ct_hdr_s));
+	return sizeof(struct fcgs_gidpn_req_s) + sizeof(struct ct_hdr_s);
 }
 
 u16
@@ -1090,7 +1079,7 @@ fc_gpnid_build(struct fchs_s *fchs, void
 
 	bfa_os_memset(gpnid, 0, sizeof(fcgs_gpnid_req_t));
 	gpnid->dap = port_id;
-	return (sizeof(fcgs_gpnid_req_t) + sizeof(struct ct_hdr_s));
+	return sizeof(fcgs_gpnid_req_t) + sizeof(struct ct_hdr_s);
 }
 
 u16
@@ -1107,7 +1096,7 @@ fc_gnnid_build(struct fchs_s *fchs, void
 
 	bfa_os_memset(gnnid, 0, sizeof(fcgs_gnnid_req_t));
 	gnnid->dap = port_id;
-	return (sizeof(fcgs_gnnid_req_t) + sizeof(struct ct_hdr_s));
+	return sizeof(fcgs_gnnid_req_t) + sizeof(struct ct_hdr_s);
 }
 
 u16
@@ -1125,7 +1114,7 @@ fc_ct_rsp_parse(struct ct_hdr_s *cthdr)
 
 u16
 fc_scr_build(struct fchs_s *fchs, struct fc_scr_s *scr, u8 set_br_reg,
-			u32 s_id, u16 ox_id)
+		u32 s_id, u16 ox_id)
 {
 	u32        d_id = bfa_os_hton3b(FC_FABRIC_CONTROLLER);
 
@@ -1137,12 +1126,12 @@ fc_scr_build(struct fchs_s *fchs, struct
 	if (set_br_reg)
 		scr->vu_reg_func = FC_VU_SCR_REG_FUNC_FABRIC_NAME_CHANGE;
 
-	return (sizeof(struct fc_scr_s));
+	return sizeof(struct fc_scr_s);
 }
 
 u16
 fc_rscn_build(struct fchs_s *fchs, struct fc_rscn_pl_s *rscn, u32 s_id,
-			u16 ox_id)
+		u16 ox_id)
 {
 	u32        d_id = bfa_os_hton3b(FC_FABRIC_CONTROLLER);
 	u16        payldlen;
@@ -1157,7 +1146,7 @@ fc_rscn_build(struct fchs_s *fchs, struc
 	rscn->event[0].format = FC_RSCN_FORMAT_PORTID;
 	rscn->event[0].portid = s_id;
 
-	return (sizeof(struct fc_rscn_pl_s));
+	return sizeof(struct fc_rscn_pl_s);
 }
 
 u16
@@ -1165,8 +1154,7 @@ fc_rftid_build(struct fchs_s *fchs, void
 	       enum bfa_port_role roles)
 {
 	struct ct_hdr_s       *cthdr = (struct ct_hdr_s *) pyld;
-	struct fcgs_rftid_req_s *rftid =
-			(struct fcgs_rftid_req_s *) (cthdr + 1);
+	struct fcgs_rftid_req_s *rftid = (struct fcgs_rftid_req_s *)(cthdr + 1);
 	u32        type_value, d_id = bfa_os_hton3b(FC_NAME_SERVER);
 	u8         index;
 
@@ -1188,17 +1176,15 @@ fc_rftid_build(struct fchs_s *fchs, void
 		rftid->fc4_type[index] |= bfa_os_htonl(type_value);
 	}
 
-	return (sizeof(struct fcgs_rftid_req_s) + sizeof(struct ct_hdr_s));
+	return sizeof(struct fcgs_rftid_req_s) + sizeof(struct ct_hdr_s);
 }
 
 u16
 fc_rftid_build_sol(struct fchs_s *fchs, void *pyld, u32 s_id,
-			u16 ox_id, u8 *fc4_bitmap,
-			u32 bitmap_size)
+	u16 ox_id, u8 *fc4_bitmap, u32 bitmap_size)
 {
 	struct ct_hdr_s       *cthdr = (struct ct_hdr_s *) pyld;
-	struct fcgs_rftid_req_s *rftid =
-			(struct fcgs_rftid_req_s *) (cthdr + 1);
+	struct fcgs_rftid_req_s *rftid = (struct fcgs_rftid_req_s *)(cthdr + 1);
 	u32        d_id = bfa_os_hton3b(FC_NAME_SERVER);
 
 	fc_gs_fchdr_build(fchs, d_id, s_id, ox_id);
@@ -1208,9 +1194,9 @@ fc_rftid_build_sol(struct fchs_s *fchs, 
 
 	rftid->dap = s_id;
 	bfa_os_memcpy((void *)rftid->fc4_type, (void *)fc4_bitmap,
-			(bitmap_size < 32 ? bitmap_size : 32));
+(bitmap_size < 32 ? bitmap_size : 32));
 
-	return (sizeof(struct fcgs_rftid_req_s) + sizeof(struct ct_hdr_s));
+	return sizeof(struct fcgs_rftid_req_s) + sizeof(struct ct_hdr_s);
 }
 
 u16
@@ -1218,8 +1204,7 @@ fc_rffid_build(struct fchs_s *fchs, void
 	       u8 fc4_type, u8 fc4_ftrs)
 {
 	struct ct_hdr_s         *cthdr = (struct ct_hdr_s *) pyld;
-	struct fcgs_rffid_req_s *rffid =
-			(struct fcgs_rffid_req_s *) (cthdr + 1);
+	struct fcgs_rffid_req_s *rffid = (struct fcgs_rffid_req_s *)(cthdr + 1);
 	u32         d_id = bfa_os_hton3b(FC_NAME_SERVER);
 
 	fc_gs_fchdr_build(fchs, d_id, s_id, ox_id);
@@ -1231,7 +1216,7 @@ fc_rffid_build(struct fchs_s *fchs, void
 	rffid->fc4ftr_bits  = fc4_ftrs;
 	rffid->fc4_type		= fc4_type;
 
-	return (sizeof(struct fcgs_rffid_req_s) + sizeof(struct ct_hdr_s));
+	return sizeof(struct fcgs_rffid_req_s) + sizeof(struct ct_hdr_s);
 }
 
 u16
@@ -1241,7 +1226,7 @@ fc_rspnid_build(struct fchs_s *fchs, voi
 
 	struct ct_hdr_s       *cthdr = (struct ct_hdr_s *) pyld;
 	struct fcgs_rspnid_req_s *rspnid =
-			(struct fcgs_rspnid_req_s *) (cthdr + 1);
+			(struct fcgs_rspnid_req_s *)(cthdr + 1);
 	u32        d_id = bfa_os_hton3b(FC_NAME_SERVER);
 
 	fc_gs_fchdr_build(fchs, d_id, s_id, ox_id);
@@ -1253,17 +1238,15 @@ fc_rspnid_build(struct fchs_s *fchs, voi
 	rspnid->spn_len = (u8) strlen((char *)name);
 	strncpy((char *)rspnid->spn, (char *)name, rspnid->spn_len);
 
-	return (sizeof(struct fcgs_rspnid_req_s) + sizeof(struct ct_hdr_s));
+	return sizeof(struct fcgs_rspnid_req_s) + sizeof(struct ct_hdr_s);
 }
 
 u16
-fc_gid_ft_build(struct fchs_s *fchs, void *pyld, u32 s_id,
-			u8 fc4_type)
+fc_gid_ft_build(struct fchs_s *fchs, void *pyld, u32 s_id, u8 fc4_type)
 {
 
 	struct ct_hdr_s       *cthdr = (struct ct_hdr_s *) pyld;
-	struct fcgs_gidft_req_s *gidft =
-			(struct fcgs_gidft_req_s *) (cthdr + 1);
+	struct fcgs_gidft_req_s *gidft = (struct fcgs_gidft_req_s *)(cthdr + 1);
 	u32        d_id = bfa_os_hton3b(FC_NAME_SERVER);
 
 	fc_gs_fchdr_build(fchs, d_id, s_id, 0);
@@ -1275,7 +1258,7 @@ fc_gid_ft_build(struct fchs_s *fchs, voi
 	gidft->domain_id = 0;
 	gidft->area_id = 0;
 
-	return (sizeof(struct fcgs_gidft_req_s) + sizeof(struct ct_hdr_s));
+	return sizeof(struct fcgs_gidft_req_s) + sizeof(struct ct_hdr_s);
 }
 
 u16
@@ -1283,8 +1266,7 @@ fc_rpnid_build(struct fchs_s *fchs, void
 	       wwn_t port_name)
 {
 	struct ct_hdr_s       *cthdr = (struct ct_hdr_s *) pyld;
-	struct fcgs_rpnid_req_s *rpnid =
-			(struct fcgs_rpnid_req_s *) (cthdr + 1);
+	struct fcgs_rpnid_req_s *rpnid = (struct fcgs_rpnid_req_s *)(cthdr + 1);
 	u32        d_id = bfa_os_hton3b(FC_NAME_SERVER);
 
 	fc_gs_fchdr_build(fchs, d_id, s_id, 0);
@@ -1294,7 +1276,7 @@ fc_rpnid_build(struct fchs_s *fchs, void
 	rpnid->port_id = port_id;
 	rpnid->port_name = port_name;
 
-	return (sizeof(struct fcgs_rpnid_req_s) + sizeof(struct ct_hdr_s));
+	return sizeof(struct fcgs_rpnid_req_s) + sizeof(struct ct_hdr_s);
 }
 
 u16
@@ -1302,8 +1284,7 @@ fc_rnnid_build(struct fchs_s *fchs, void
 	       wwn_t node_name)
 {
 	struct ct_hdr_s       *cthdr = (struct ct_hdr_s *) pyld;
-	struct fcgs_rnnid_req_s *rnnid =
-			(struct fcgs_rnnid_req_s *) (cthdr + 1);
+	struct fcgs_rnnid_req_s *rnnid = (struct fcgs_rnnid_req_s *)(cthdr + 1);
 	u32        d_id = bfa_os_hton3b(FC_NAME_SERVER);
 
 	fc_gs_fchdr_build(fchs, d_id, s_id, 0);
@@ -1313,7 +1294,7 @@ fc_rnnid_build(struct fchs_s *fchs, void
 	rnnid->port_id = port_id;
 	rnnid->node_name = node_name;
 
-	return (sizeof(struct fcgs_rnnid_req_s) + sizeof(struct ct_hdr_s));
+	return sizeof(struct fcgs_rnnid_req_s) + sizeof(struct ct_hdr_s);
 }
 
 u16
@@ -1321,8 +1302,7 @@ fc_rcsid_build(struct fchs_s *fchs, void
 	       u32 cos)
 {
 	struct ct_hdr_s       *cthdr = (struct ct_hdr_s *) pyld;
-	struct fcgs_rcsid_req_s *rcsid =
-			(struct fcgs_rcsid_req_s *) (cthdr + 1);
+	struct fcgs_rcsid_req_s *rcsid = (struct fcgs_rcsid_req_s *)(cthdr + 1);
 	u32        d_id = bfa_os_hton3b(FC_NAME_SERVER);
 
 	fc_gs_fchdr_build(fchs, d_id, s_id, 0);
@@ -1332,7 +1312,7 @@ fc_rcsid_build(struct fchs_s *fchs, void
 	rcsid->port_id = port_id;
 	rcsid->cos = cos;
 
-	return (sizeof(struct fcgs_rcsid_req_s) + sizeof(struct ct_hdr_s));
+	return sizeof(struct fcgs_rcsid_req_s) + sizeof(struct ct_hdr_s);
 }
 
 u16
@@ -1340,8 +1320,7 @@ fc_rptid_build(struct fchs_s *fchs, void
 	       u8 port_type)
 {
 	struct ct_hdr_s       *cthdr = (struct ct_hdr_s *) pyld;
-	struct fcgs_rptid_req_s *rptid =
-			(struct fcgs_rptid_req_s *) (cthdr + 1);
+	struct fcgs_rptid_req_s *rptid = (struct fcgs_rptid_req_s *)(cthdr + 1);
 	u32        d_id = bfa_os_hton3b(FC_NAME_SERVER);
 
 	fc_gs_fchdr_build(fchs, d_id, s_id, 0);
@@ -1351,15 +1330,14 @@ fc_rptid_build(struct fchs_s *fchs, void
 	rptid->port_id = port_id;
 	rptid->port_type = port_type;
 
-	return (sizeof(struct fcgs_rptid_req_s) + sizeof(struct ct_hdr_s));
+	return sizeof(struct fcgs_rptid_req_s) + sizeof(struct ct_hdr_s);
 }
 
 u16
 fc_ganxt_build(struct fchs_s *fchs, void *pyld, u32 s_id, u32 port_id)
 {
 	struct ct_hdr_s       *cthdr = (struct ct_hdr_s *) pyld;
-	struct fcgs_ganxt_req_s *ganxt =
-			(struct fcgs_ganxt_req_s *) (cthdr + 1);
+	struct fcgs_ganxt_req_s *ganxt = (struct fcgs_ganxt_req_s *)(cthdr + 1);
 	u32        d_id = bfa_os_hton3b(FC_NAME_SERVER);
 
 	fc_gs_fchdr_build(fchs, d_id, s_id, 0);
@@ -1368,7 +1346,7 @@ fc_ganxt_build(struct fchs_s *fchs, void
 	bfa_os_memset(ganxt, 0, sizeof(struct fcgs_ganxt_req_s));
 	ganxt->port_id = port_id;
 
-	return (sizeof(struct ct_hdr_s) + sizeof(struct fcgs_ganxt_req_s));
+	return sizeof(struct ct_hdr_s) + sizeof(struct fcgs_ganxt_req_s);
 }
 
 /*
@@ -1385,7 +1363,7 @@ fc_fdmi_reqhdr_build(struct fchs_s *fchs
 	fc_gs_fchdr_build(fchs, d_id, s_id, 0);
 	fc_gs_fdmi_cthdr_build(cthdr, s_id, cmd_code);
 
-	return (sizeof(struct ct_hdr_s));
+	return sizeof(struct ct_hdr_s);
 }
 
 /*
@@ -1420,12 +1398,12 @@ fc_gmal_req_build(struct fchs_s *fchs, v
 
 	fc_gs_fchdr_build(fchs, d_id, s_id, 0);
 	fc_gs_ms_cthdr_build(cthdr, s_id, GS_FC_GMAL_CMD,
-			CT_GSSUBTYPE_CFGSERVER);
+					CT_GSSUBTYPE_CFGSERVER);
 
 	bfa_os_memset(gmal, 0, sizeof(fcgs_gmal_req_t));
 	gmal->wwn = wwn;
 
-	return (sizeof(struct ct_hdr_s) + sizeof(fcgs_gmal_req_t));
+	return sizeof(struct ct_hdr_s) + sizeof(fcgs_gmal_req_t);
 }
 
 /*
@@ -1440,10 +1418,10 @@ fc_gfn_req_build(struct fchs_s *fchs, vo
 
 	fc_gs_fchdr_build(fchs, d_id, s_id, 0);
 	fc_gs_ms_cthdr_build(cthdr, s_id, GS_FC_GFN_CMD,
-			CT_GSSUBTYPE_CFGSERVER);
+					CT_GSSUBTYPE_CFGSERVER);
 
 	bfa_os_memset(gfn, 0, sizeof(fcgs_gfn_req_t));
 	gfn->wwn = wwn;
 
-	return (sizeof(struct ct_hdr_s) + sizeof(fcgs_gfn_req_t));
+	return sizeof(struct ct_hdr_s) + sizeof(fcgs_gfn_req_t);
 }
diff -uprN a/drivers/scsi/bfa/fcbuild.h b/drivers/scsi/bfa/fcbuild.h
--- a/drivers/scsi/bfa/fcbuild.h	2009-12-18 18:16:22.370686000 -0800
+++ b/drivers/scsi/bfa/fcbuild.h	2009-11-25 18:16:26.000000000 -0800
@@ -32,8 +32,8 @@
  * Utility Macros/functions
  */
 
-#define fcif_sof_set(_ifhdr, _sof)	(_ifhdr)->sof = FC_ ## _sof
-#define fcif_eof_set(_ifhdr, _eof)	(_ifhdr)->eof = FC_ ## _eof
+#define fcif_sof_set(_ifhdr, _sof)	((_ifhdr)->sof = FC_ ## _sof)
+#define fcif_eof_set(_ifhdr, _eof)	((_ifhdr)->eof = FC_ ## _eof)
 
 #define wwn_is_equal(_wwn1, _wwn2)		\
 	(memcmp(&(_wwn1), &(_wwn2), sizeof(wwn_t)) == 0)
@@ -49,13 +49,13 @@
 static inline   u32
 fc_get_ctresp_pyld_len(u32 resp_len)
 {
-	return (resp_len - sizeof(struct ct_hdr_s));
+	return resp_len - sizeof(struct ct_hdr_s);
 }
 
 /*
  * Convert bfa speed to rpsc speed value.
  */
-static inline enum bfa_pport_speed
+static inline  enum bfa_pport_speed
 fc_rpsc_operspeed_to_bfa_speed(enum fc_rpsc_op_speed_s speed)
 {
 	switch (speed) {
@@ -72,6 +72,9 @@ fc_rpsc_operspeed_to_bfa_speed(enum fc_r
 	case RPSC_OP_SPEED_8G:
 		return BFA_PPORT_SPEED_8GBPS;
 
+	case RPSC_OP_SPEED_10G:
+		return BFA_PPORT_SPEED_10GBPS;
+
 	default:
 		return BFA_PPORT_SPEED_UNKNOWN;
 	}
@@ -97,6 +100,9 @@ fc_bfa_speed_to_rpsc_operspeed(enum bfa_
 	case BFA_PPORT_SPEED_8GBPS:
 		return RPSC_OP_SPEED_8G;
 
+	case BFA_PPORT_SPEED_10GBPS:
+		return RPSC_OP_SPEED_10G;
+
 	default:
 		return RPSC_OP_SPEED_NOT_EST;
 	}
@@ -125,149 +131,204 @@ struct fc_templates_s {
 	struct fc_rrq_s        rrq;
 };
 
-void fcbuild_init(void);
+void            fcbuild_init(void);
+
+u16        fc_flogi_build(struct fchs_s *fchs, struct fc_logi_s *flogi,
+				u32 s_id, u16 ox_id, wwn_t port_name,
+				wwn_t node_name, u16 pdu_size,
+				u8 set_npiv, u8 set_auth,
+				u16 local_bb_credits);
+
+u16        fc_fdisc_build(struct fchs_s *buf, struct fc_logi_s *flogi,
+				u32 s_id, u16 ox_id, wwn_t port_name,
+				wwn_t node_name, u16 pdu_size);
+
+u16        fc_flogi_acc_build(struct fchs_s *fchs, struct fc_logi_s *flogi,
+				   u32 s_id, u16 ox_id,
+				   wwn_t port_name, wwn_t node_name,
+				   u16 pdu_size,
+				   u16 local_bb_credits);
+
+u16        fc_plogi_build(struct fchs_s *fchs, void *pld, u32 d_id,
+			       u32 s_id, u16 ox_id, wwn_t port_name,
+			       wwn_t node_name, u16 pdu_size);
 
-u16 fc_flogi_build(struct fchs_s *fchs, struct fc_logi_s *flogi,
-			u32 s_id, u16 ox_id, wwn_t port_name,
-			wwn_t node_name, u16 pdu_size, u8 set_npiv,
-			u8 set_auth, u16 local_bb_credits);
-u16 fc_fdisc_build(struct fchs_s *buf, struct fc_logi_s *flogi,
-			u32 s_id, u16 ox_id, wwn_t port_name,
-			wwn_t node_name, u16 pdu_size);
-u16 fc_flogi_acc_build(struct fchs_s *fchs, struct fc_logi_s *flogi,
-			u32 s_id, u16 ox_id, wwn_t port_name,
-			wwn_t node_name, u16 pdu_size,
-			u16 local_bb_credits);
-u16 fc_plogi_build(struct fchs_s *fchs, void *pld, u32 d_id,
-			u32 s_id, u16 ox_id, wwn_t port_name,
-			wwn_t node_name, u16 pdu_size);
 enum fc_parse_status fc_plogi_parse(struct fchs_s *fchs);
-u16 fc_abts_build(struct fchs_s *buf, u32 d_id, u32 s_id,
-			u16 ox_id);
+
+u16        fc_abts_build(struct fchs_s *buf, u32 d_id, u32 s_id,
+			      u16 ox_id);
+
 enum fc_parse_status fc_abts_rsp_parse(struct fchs_s *buf, int len);
-u16 fc_rrq_build(struct fchs_s *buf, struct fc_rrq_s *rrq, u32 d_id,
-			u32 s_id, u16 ox_id, u16 rrq_oxid);
+
+u16        fc_rrq_build(struct fchs_s *buf, struct fc_rrq_s *rrq,
+			u32 d_id, u32 s_id, u16 ox_id,
+			u16 rrq_oxid);
 enum fc_parse_status fc_rrq_rsp_parse(struct fchs_s *buf, int len);
-u16 fc_rspnid_build(struct fchs_s *fchs, void *pld, u32 s_id,
-			u16 ox_id, u8 *name);
-u16 fc_rftid_build(struct fchs_s *fchs, void *pld, u32 s_id,
-			u16 ox_id, enum bfa_port_role role);
-u16 fc_rftid_build_sol(struct fchs_s *fchs, void *pyld, u32 s_id,
-			u16 ox_id, u8 *fc4_bitmap,
-			u32 bitmap_size);
-u16 fc_rffid_build(struct fchs_s *fchs, void *pyld, u32 s_id,
+
+u16        fc_rspnid_build(struct fchs_s *fchs, void *pld, u32 s_id,
+				u16 ox_id, u8 *name);
+
+u16        fc_rftid_build(struct fchs_s *fchs, void *pld, u32 s_id,
+			       u16 ox_id, enum bfa_port_role role);
+
+u16       fc_rftid_build_sol(struct fchs_s *fchs, void *pyld,
+				u32 s_id, u16 ox_id,
+				u8 *fc4_bitmap, u32 bitmap_size);
+
+u16	fc_rffid_build(struct fchs_s *fchs, void *pyld, u32 s_id,
 			u16 ox_id, u8 fc4_type, u8 fc4_ftrs);
-u16 fc_gidpn_build(struct fchs_s *fchs, void *pyld, u32 s_id,
-			u16 ox_id, wwn_t port_name);
-u16 fc_gpnid_build(struct fchs_s *fchs, void *pld, u32 s_id,
-			u16 ox_id, u32 port_id);
-u16 fc_scr_build(struct fchs_s *fchs, struct fc_scr_s *scr,
+
+u16        fc_gidpn_build(struct fchs_s *fchs, void *pyld, u32 s_id,
+			       u16 ox_id, wwn_t port_name);
+
+u16        fc_gpnid_build(struct fchs_s *fchs, void *pld, u32 s_id,
+			       u16 ox_id, u32 port_id);
+
+u16        fc_scr_build(struct fchs_s *fchs, struct fc_scr_s *scr,
 			u8 set_br_reg, u32 s_id, u16 ox_id);
-u16 fc_plogi_acc_build(struct fchs_s *fchs, void *pld, u32 d_id,
-			u32 s_id, u16 ox_id,
-			wwn_t port_name, wwn_t node_name, u16 pdu_size);
 
-u16 fc_adisc_build(struct fchs_s *fchs, struct fc_adisc_s *adisc,
-			u32 d_id, u32 s_id, u16 ox_id,
-			wwn_t port_name, wwn_t node_name);
+u16        fc_plogi_acc_build(struct fchs_s *fchs, void *pld,
+				u32 d_id, u32 s_id,
+				u16 ox_id, wwn_t port_name,
+				wwn_t node_name, u16 pdu_size);
+
+u16        fc_adisc_build(struct fchs_s *fchs, struct fc_adisc_s *adisc,
+				u32 d_id, u32 s_id, u16 ox_id,
+				wwn_t port_name, wwn_t node_name);
+
 enum fc_parse_status fc_adisc_parse(struct fchs_s *fchs, void *pld,
-			u32 host_dap,
-			wwn_t node_name, wwn_t port_name);
+			u32 host_dap, wwn_t node_name, wwn_t port_name);
+
 enum fc_parse_status fc_adisc_rsp_parse(struct fc_adisc_s *adisc, int len,
-			wwn_t port_name, wwn_t node_name);
-u16 fc_adisc_acc_build(struct fchs_s *fchs, struct fc_adisc_s *adisc,
-			u32 d_id, u32 s_id, u16 ox_id,
-			wwn_t port_name, wwn_t node_name);
-u16 fc_ls_rjt_build(struct fchs_s *fchs, struct fc_ls_rjt_s *ls_rjt,
-			u32 d_id, u32 s_id, u16 ox_id,
-			u8 reason_code, u8 reason_code_expl);
-u16 fc_ls_acc_build(struct fchs_s *fchs, struct fc_els_cmd_s *els_cmd,
-			u32 d_id, u32 s_id, u16 ox_id);
-u16 fc_prli_build(struct fchs_s *fchs, void *pld, u32 d_id,
-			u32 s_id, u16 ox_id);
+				 wwn_t port_name, wwn_t node_name);
+
+u16        fc_adisc_acc_build(struct fchs_s *fchs,
+				struct fc_adisc_s *adisc, u32 d_id,
+				u32 s_id, u16 ox_id,
+				wwn_t port_name, wwn_t node_name);
+u16        fc_ls_rjt_build(struct fchs_s *fchs, struct fc_ls_rjt_s *ls_rjt,
+				u32 d_id, u32 s_id, u16 ox_id,
+				u8 reason_code, u8 reason_code_expl);
+u16        fc_ls_acc_build(struct fchs_s *fchs,
+				struct fc_els_cmd_s *els_cmd,
+				u32 d_id, u32 s_id, u16 ox_id);
+u16        fc_prli_build(struct fchs_s *fchs, void *pld, u32 d_id,
+			      u32 s_id, u16 ox_id);
+
 enum fc_parse_status fc_prli_rsp_parse(struct fc_prli_s *prli, int len);
 
-u16 fc_prli_acc_build(struct fchs_s *fchs, void *pld, u32 d_id,
-			u32 s_id, u16 ox_id,
-			enum bfa_port_role role);
-u16 fc_rnid_build(struct fchs_s *fchs, struct fc_rnid_cmd_s *rnid,
-			u32 d_id, u32 s_id, u16 ox_id,
-			u32 data_format);
-u16 fc_rnid_acc_build(struct fchs_s *fchs, struct fc_rnid_acc_s *rnid_acc,
-			u32 d_id, u32 s_id, u16 ox_id,
-			u32 data_format,
-			struct fc_rnid_common_id_data_s *common_id_data,
-			struct fc_rnid_general_topology_data_s *
-			gen_topo_data);
-u16 fc_rpsc2_build(struct fchs_s *fchs, struct fc_rpsc2_cmd_s *rps2c,
-			u32 d_id, u32 s_id,
-			u32 *pid_list, u16 npids);
-u16 fc_rpsc_build(struct fchs_s *fchs, struct fc_rpsc_cmd_s *rpsc,
-			u32 d_id, u32 s_id, u16 ox_id);
-u16 fc_rpsc_acc_build(struct fchs_s *fchs, struct fc_rpsc_acc_s *rpsc_acc,
-			u32 d_id, u32 s_id, u16 ox_id,
-			struct fc_rpsc_speed_info_s *oper_speed);
-u16 fc_gid_ft_build(struct fchs_s *fchs, void *pld, u32 s_id,
-			u8 fc4_type);
-u16 fc_rpnid_build(struct fchs_s *fchs, void *pyld, u32 s_id,
-			u32 port_id, wwn_t port_name);
-u16 fc_rnnid_build(struct fchs_s *fchs, void *pyld, u32 s_id,
-			u32 port_id, wwn_t node_name);
-u16 fc_rcsid_build(struct fchs_s *fchs, void *pyld, u32 s_id,
-			u32 port_id, u32 cos);
-u16 fc_rptid_build(struct fchs_s *fchs, void *pyld, u32 s_id,
-			u32 port_id, u8 port_type);
-u16 fc_ganxt_build(struct fchs_s *fchs, void *pyld, u32 s_id,
-			u32 port_id);
-u16 fc_logo_build(struct fchs_s *fchs, struct fc_logo_s *logo,
-			u32 d_id, u32 s_id, u16 ox_id,
-			wwn_t port_name);
-u16 fc_logo_acc_build(struct fchs_s *fchs, void *pld, u32 d_id,
-			u32 s_id, u16 ox_id);
-u16 fc_fdmi_reqhdr_build(struct fchs_s *fchs, void *pyld, u32 s_id,
-			u16 cmd_code);
-u16 fc_gmal_req_build(struct fchs_s *fchs, void *pyld, u32 s_id,
-			wwn_t wwn);
-u16 fc_gfn_req_build(struct fchs_s *fchs, void *pyld, u32 s_id,
-			wwn_t wwn);
-void fc_get_fc4type_bitmask(u8 fc4_type, u8 *bit_mask);
-void fc_els_req_build(struct fchs_s *fchs, u32 d_id, u32 s_id,
-			u16 ox_id);
-enum fc_parse_status fc_els_rsp_parse(struct fchs_s *fchs, int len);
-enum fc_parse_status fc_plogi_rsp_parse(struct fchs_s *fchs, int len,
-			 wwn_t port_name);
-enum fc_parse_status fc_prli_parse(struct fc_prli_s *prli);
-enum fc_parse_status fc_pdisc_parse(struct fchs_s *fchs, wwn_t node_name,
-			wwn_t port_name);
+u16        fc_prli_acc_build(struct fchs_s *fchs, void *pld, u32 d_id,
+				  u32 s_id, u16 ox_id,
+				  enum bfa_port_role role);
+
+u16        fc_rnid_build(struct fchs_s *fchs, struct fc_rnid_cmd_s *rnid,
+			      u32 d_id, u32 s_id, u16 ox_id,
+			      u32 data_format);
+
+u16        fc_rnid_acc_build(struct fchs_s *fchs,
+				struct fc_rnid_acc_s *rnid_acc, u32 d_id,
+				u32 s_id, u16 ox_id,
+				u32 data_format,
+				struct fc_rnid_common_id_data_s *common_id_data,
+			struct fc_rnid_general_topology_data_s *gen_topo_data);
+
+u16 	fc_rpsc2_build(struct fchs_s *fchs,
+				struct fc_rpsc2_cmd_s *rps2c,
+				u32 d_id, u32 s_id,
+				u32 *pid_list, u16 npids);
+u16        fc_rpsc_build(struct fchs_s *fchs, struct fc_rpsc_cmd_s *rpsc,
+			      u32 d_id, u32 s_id, u16 ox_id);
+u16        fc_rpsc_acc_build(struct fchs_s *fchs,
+				struct fc_rpsc_acc_s *rpsc_acc,
+				  u32 d_id, u32 s_id, u16 ox_id,
+				  struct fc_rpsc_speed_info_s *oper_speed);
+u16        fc_gid_ft_build(struct fchs_s *fchs, void *pld, u32 s_id,
+				u8 fc4_type);
+
+u16        fc_rpnid_build(struct fchs_s *fchs, void *pyld, u32 s_id,
+			       u32 port_id, wwn_t port_name);
+
+u16        fc_rnnid_build(struct fchs_s *fchs, void *pyld, u32 s_id,
+			       u32 port_id, wwn_t node_name);
+
+u16        fc_rcsid_build(struct fchs_s *fchs, void *pyld, u32 s_id,
+			       u32 port_id, u32 cos);
+
+u16        fc_rptid_build(struct fchs_s *fchs, void *pyld, u32 s_id,
+			       u32 port_id, u8 port_type);
+
+u16        fc_ganxt_build(struct fchs_s *fchs, void *pyld, u32 s_id,
+			       u32 port_id);
+
+u16        fc_logo_build(struct fchs_s *fchs, struct fc_logo_s *logo,
+				u32 d_id, u32 s_id, u16 ox_id,
+				wwn_t port_name);
+
+u16        fc_logo_acc_build(struct fchs_s *fchs, void *pld, u32 d_id,
+				  u32 s_id, u16 ox_id);
+
+u16        fc_fdmi_reqhdr_build(struct fchs_s *fchs, void *pyld,
+				u32 s_id, u16 cmd_code);
+u16 	fc_gmal_req_build(struct fchs_s *fchs, void *pyld,
+					u32 s_id, wwn_t wwn);
+u16 	fc_gfn_req_build(struct fchs_s *fchs, void *pyld,
+					u32 s_id, wwn_t wwn);
+
+void		fc_get_fc4type_bitmask(u8 fc4_type, u8 *bit_mask);
+
+void		fc_els_req_build(struct fchs_s *fchs, u32 d_id,
+				u32 s_id, u16 ox_id);
+
+enum fc_parse_status	fc_els_rsp_parse(struct fchs_s *fchs, int len);
+
+enum fc_parse_status	fc_plogi_rsp_parse(struct fchs_s *fchs, int len,
+					wwn_t port_name);
+
+enum fc_parse_status	fc_prli_parse(struct fc_prli_s *prli);
+
+enum fc_parse_status	fc_pdisc_parse(struct fchs_s *fchs, wwn_t node_name,
+					wwn_t port_name);
+
 u16 fc_ba_acc_build(struct fchs_s *fchs, struct fc_ba_acc_s *ba_acc,
 			u32 d_id, u32 s_id, u16 ox_id,
 			u16 rx_id);
+
 int fc_logout_params_pages(struct fchs_s *fc_frame, u8 els_code);
+
 u16 fc_tprlo_acc_build(struct fchs_s *fchs,
-			struct fc_tprlo_acc_s *tprlo_acc,
-			u32 d_id, u32 s_id, u16 ox_id,
-			int num_pages);
+			struct fc_tprlo_acc_s *tprlo_acc, u32 d_id,
+			u32 s_id, u16 ox_id, int num_pages);
+
 u16 fc_prlo_acc_build(struct fchs_s *fchs, struct fc_prlo_acc_s *prlo_acc,
-			u32 d_id, u32 s_id, u16 ox_id,
-			int num_pages);
+		u32 d_id, u32 s_id, u16 ox_id, int num_pages);
+
 u16 fc_logo_rsp_parse(struct fchs_s *fchs, int len);
+
 u16 fc_pdisc_build(struct fchs_s *fchs, u32 d_id, u32 s_id,
-			u16 ox_id, wwn_t port_name, wwn_t node_name,
-			u16 pdu_size);
+		u16 ox_id, wwn_t port_name, wwn_t node_name,
+		u16 pdu_size);
+
 u16 fc_pdisc_rsp_parse(struct fchs_s *fchs, int len, wwn_t port_name);
+
 u16 fc_prlo_build(struct fchs_s *fchs, u32 d_id, u32 s_id,
-			u16 ox_id, int num_pages);
+		u16 ox_id, int num_pages);
+
 u16 fc_prlo_rsp_parse(struct fchs_s *fchs, int len);
+
 u16 fc_tprlo_build(struct fchs_s *fchs, u32 d_id, u32 s_id,
-			u16 ox_id, int num_pages,
-			enum fc_tprlo_type tprlo_type, u32 tpr_id);
+		u16 ox_id, int num_pages, enum fc_tprlo_type tprlo_type,
+		u32 tpr_id);
+
 u16 fc_tprlo_rsp_parse(struct fchs_s *fchs, int len);
+
 u16 fc_ba_rjt_build(struct fchs_s *fchs, u32 d_id, u32 s_id,
-			u16 ox_id, u32 reason_code,
-			u32 reason_expl);
+		u16 ox_id, u32 reason_code, u32 reason_expl);
+
 u16 fc_gnnid_build(struct fchs_s *fchs, void *pyld, u32 s_id,
-			u16 ox_id, u32 port_id);
+		u16 ox_id, u32 port_id);
+
 u16 fc_ct_rsp_parse(struct ct_hdr_s *cthdr);
+
 u16 fc_rscn_build(struct fchs_s *fchs, struct fc_rscn_pl_s *rscn,
-			u32 s_id, u16 ox_id);
+		u32 s_id, u16 ox_id);
 #endif
diff -uprN a/drivers/scsi/bfa/fcpim.c b/drivers/scsi/bfa/fcpim.c
--- a/drivers/scsi/bfa/fcpim.c	2009-12-18 18:16:22.368686000 -0800
+++ b/drivers/scsi/bfa/fcpim.c	2009-11-25 18:21:07.000000000 -0800
@@ -36,18 +36,18 @@ BFA_TRC_FILE(FCS, FCPIM);
 /*
  * forward declarations
  */
-static void     bfa_fcs_itnim_timeout(void *arg);
-static void     bfa_fcs_itnim_free(struct bfa_fcs_itnim_s *itnim);
-static void     bfa_fcs_itnim_send_prli(void *itnim_cbarg,
+static void	bfa_fcs_itnim_timeout(void *arg);
+static void	bfa_fcs_itnim_free(struct bfa_fcs_itnim_s *itnim);
+static void	bfa_fcs_itnim_send_prli(void *itnim_cbarg,
 					struct bfa_fcxp_s *fcxp_alloced);
-static void     bfa_fcs_itnim_prli_response(void *fcsarg,
+static void	bfa_fcs_itnim_prli_response(void *fcsarg,
 					    struct bfa_fcxp_s *fcxp,
 					    void *cbarg,
 					    bfa_status_t req_status,
 					    u32 rsp_len,
 					    u32 resid_len,
 					    struct fchs_s *rsp_fchs);
-static void     bfa_fcs_itnim_aen_post(struct bfa_fcs_itnim_s *itnim,
+static void	bfa_fcs_itnim_aen_post(struct bfa_fcs_itnim_s *itnim,
 				       enum bfa_itnim_aen_event event);
 
 /**
@@ -61,28 +61,28 @@ enum bfa_fcs_itnim_event {
 	BFA_FCS_ITNIM_SM_RSP_OK = 4,	/*  good response */
 	BFA_FCS_ITNIM_SM_RSP_ERROR = 5,	/*  error response */
 	BFA_FCS_ITNIM_SM_TIMEOUT = 6,	/*  delay timeout */
-	BFA_FCS_ITNIM_SM_HCB_OFFLINE = 7,	/*  BFA online callback */
-	BFA_FCS_ITNIM_SM_HCB_ONLINE = 8,	/*  BFA offline callback */
+	BFA_FCS_ITNIM_SM_HCB_OFFLINE = 7, /*  BFA online callback */
+	BFA_FCS_ITNIM_SM_HCB_ONLINE = 8, /*  BFA offline callback */
 	BFA_FCS_ITNIM_SM_INITIATOR = 9,	/*  rport is initiator */
 	BFA_FCS_ITNIM_SM_DELETE = 10,	/*  delete event from rport */
 	BFA_FCS_ITNIM_SM_PRLO = 11,	/*  delete event from rport */
 };
 
-static void     bfa_fcs_itnim_sm_offline(struct bfa_fcs_itnim_s *itnim,
+static void	bfa_fcs_itnim_sm_offline(struct bfa_fcs_itnim_s *itnim,
 					 enum bfa_fcs_itnim_event event);
-static void     bfa_fcs_itnim_sm_prli_send(struct bfa_fcs_itnim_s *itnim,
+static void	bfa_fcs_itnim_sm_prli_send(struct bfa_fcs_itnim_s *itnim,
 					   enum bfa_fcs_itnim_event event);
-static void     bfa_fcs_itnim_sm_prli(struct bfa_fcs_itnim_s *itnim,
+static void	bfa_fcs_itnim_sm_prli(struct bfa_fcs_itnim_s *itnim,
 				      enum bfa_fcs_itnim_event event);
-static void     bfa_fcs_itnim_sm_prli_retry(struct bfa_fcs_itnim_s *itnim,
+static void	bfa_fcs_itnim_sm_prli_retry(struct bfa_fcs_itnim_s *itnim,
 					    enum bfa_fcs_itnim_event event);
-static void     bfa_fcs_itnim_sm_hcb_online(struct bfa_fcs_itnim_s *itnim,
+static void	bfa_fcs_itnim_sm_hcb_online(struct bfa_fcs_itnim_s *itnim,
 					    enum bfa_fcs_itnim_event event);
-static void     bfa_fcs_itnim_sm_online(struct bfa_fcs_itnim_s *itnim,
+static void	bfa_fcs_itnim_sm_online(struct bfa_fcs_itnim_s *itnim,
 					enum bfa_fcs_itnim_event event);
-static void     bfa_fcs_itnim_sm_hcb_offline(struct bfa_fcs_itnim_s *itnim,
+static void	bfa_fcs_itnim_sm_hcb_offline(struct bfa_fcs_itnim_s *itnim,
 					     enum bfa_fcs_itnim_event event);
-static void     bfa_fcs_itnim_sm_initiator(struct bfa_fcs_itnim_s *itnim,
+static void	bfa_fcs_itnim_sm_initiator(struct bfa_fcs_itnim_s *itnim,
 					   enum bfa_fcs_itnim_event event);
 
 static struct bfa_sm_table_s itnim_sm_table[] = {
@@ -102,7 +102,7 @@ static struct bfa_sm_table_s itnim_sm_ta
 
 static void
 bfa_fcs_itnim_sm_offline(struct bfa_fcs_itnim_s *itnim,
-			 enum bfa_fcs_itnim_event event)
+				enum bfa_fcs_itnim_event event)
 {
 	bfa_trc(itnim->fcs, itnim->rport->pwwn);
 	bfa_trc(itnim->fcs, event);
@@ -126,14 +126,14 @@ bfa_fcs_itnim_sm_offline(struct bfa_fcs_
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(itnim->fcs, event);
 	}
 
 }
 
 static void
 bfa_fcs_itnim_sm_prli_send(struct bfa_fcs_itnim_s *itnim,
-			   enum bfa_fcs_itnim_event event)
+				enum bfa_fcs_itnim_event event)
 {
 	bfa_trc(itnim->fcs, itnim->rport->pwwn);
 	bfa_trc(itnim->fcs, event);
@@ -161,13 +161,13 @@ bfa_fcs_itnim_sm_prli_send(struct bfa_fc
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(itnim->fcs, event);
 	}
 }
 
 static void
 bfa_fcs_itnim_sm_prli(struct bfa_fcs_itnim_s *itnim,
-		      enum bfa_fcs_itnim_event event)
+				enum bfa_fcs_itnim_event event)
 {
 	bfa_trc(itnim->fcs, itnim->rport->pwwn);
 	bfa_trc(itnim->fcs, event);
@@ -193,9 +193,7 @@ bfa_fcs_itnim_sm_prli(struct bfa_fcs_itn
 
 	case BFA_FCS_ITNIM_SM_INITIATOR:
 		bfa_sm_set_state(itnim, bfa_fcs_itnim_sm_initiator);
-		/*
-		 * dont discard fcxp. accept will reach same state
-		 */
+		/* dont discard fcxp. accept will reach same state*/
 		break;
 
 	case BFA_FCS_ITNIM_SM_DELETE:
@@ -205,7 +203,7 @@ bfa_fcs_itnim_sm_prli(struct bfa_fcs_itn
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(itnim->fcs, event);
 	}
 }
 
@@ -240,7 +238,7 @@ bfa_fcs_itnim_sm_prli_retry(struct bfa_f
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(itnim->fcs, event);
 	}
 }
 
@@ -270,13 +268,13 @@ bfa_fcs_itnim_sm_hcb_online(struct bfa_f
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(itnim->fcs, event);
 	}
 }
 
 static void
 bfa_fcs_itnim_sm_online(struct bfa_fcs_itnim_s *itnim,
-			enum bfa_fcs_itnim_event event)
+						enum bfa_fcs_itnim_event event)
 {
 	bfa_trc(itnim->fcs, itnim->rport->pwwn);
 	bfa_trc(itnim->fcs, event);
@@ -286,11 +284,10 @@ bfa_fcs_itnim_sm_online(struct bfa_fcs_i
 		bfa_sm_set_state(itnim, bfa_fcs_itnim_sm_hcb_offline);
 		bfa_fcb_itnim_offline(itnim->itnim_drv);
 		bfa_itnim_offline(itnim->bfa_itnim);
-		if (bfa_fcs_port_is_online(itnim->rport->port) == BFA_TRUE) {
+		if (bfa_fcs_port_is_online(itnim->rport->port) == BFA_TRUE)
 			bfa_fcs_itnim_aen_post(itnim, BFA_ITNIM_AEN_DISCONNECT);
-		} else {
+		else
 			bfa_fcs_itnim_aen_post(itnim, BFA_ITNIM_AEN_OFFLINE);
-		}
 		break;
 
 	case BFA_FCS_ITNIM_SM_DELETE:
@@ -299,7 +296,7 @@ bfa_fcs_itnim_sm_online(struct bfa_fcs_i
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(itnim->fcs, event);
 	}
 }
 
@@ -322,7 +319,7 @@ bfa_fcs_itnim_sm_hcb_offline(struct bfa_
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(itnim->fcs, event);
 	}
 }
 
@@ -333,7 +330,7 @@ bfa_fcs_itnim_sm_hcb_offline(struct bfa_
  */
 static void
 bfa_fcs_itnim_sm_initiator(struct bfa_fcs_itnim_s *itnim,
-			   enum bfa_fcs_itnim_event event)
+				enum bfa_fcs_itnim_event event)
 {
 	bfa_trc(itnim->fcs, itnim->rport->pwwn);
 	bfa_trc(itnim->fcs, event);
@@ -355,7 +352,7 @@ bfa_fcs_itnim_sm_initiator(struct bfa_fc
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(itnim->fcs, event);
 	}
 }
 
@@ -367,38 +364,24 @@ bfa_fcs_itnim_sm_initiator(struct bfa_fc
 
 static void
 bfa_fcs_itnim_aen_post(struct bfa_fcs_itnim_s *itnim,
-		       enum bfa_itnim_aen_event event)
+			enum bfa_itnim_aen_event event)
 {
 	struct bfa_fcs_rport_s *rport = itnim->rport;
-	union bfa_aen_data_u aen_data;
+	union bfa_aen_data_u  aen_data;
 	struct bfa_log_mod_s *logmod = rport->fcs->logm;
-	wwn_t           lpwwn = bfa_fcs_port_get_pwwn(rport->port);
-	wwn_t           rpwwn = rport->pwwn;
-	char            lpwwn_ptr[BFA_STRING_32];
-	char            rpwwn_ptr[BFA_STRING_32];
+	wwn_t		lpwwn = bfa_fcs_port_get_pwwn(rport->port);
+	wwn_t		rpwwn = rport->pwwn;
+	char		lpwwn_ptr[BFA_STRING_32];
+	char		rpwwn_ptr[BFA_STRING_32];
 
-	/*
-	 * Don't post events for well known addresses
-	 */
+	/* Don't post events for well known addresses */
 	if (BFA_FCS_PID_IS_WKA(rport->pid))
 		return;
 
 	wwn2str(lpwwn_ptr, lpwwn);
 	wwn2str(rpwwn_ptr, rpwwn);
-
-	switch (event) {
-	case BFA_ITNIM_AEN_ONLINE:
-		bfa_log(logmod, BFA_AEN_ITNIM_ONLINE, rpwwn_ptr, lpwwn_ptr);
-		break;
-	case BFA_ITNIM_AEN_OFFLINE:
-		bfa_log(logmod, BFA_AEN_ITNIM_OFFLINE, rpwwn_ptr, lpwwn_ptr);
-		break;
-	case BFA_ITNIM_AEN_DISCONNECT:
-		bfa_log(logmod, BFA_AEN_ITNIM_DISCONNECT, rpwwn_ptr, lpwwn_ptr);
-		break;
-	default:
-		break;
-	}
+	bfa_log(logmod, BFA_LOG_CREATE_ID(BFA_AEN_CAT_ITNIM, event),
+			rpwwn_ptr, lpwwn_ptr);
 
 	aen_data.itnim.vf_id = rport->port->fabric->vf_id;
 	aen_data.itnim.ppwwn =
@@ -413,9 +396,9 @@ bfa_fcs_itnim_send_prli(void *itnim_cbar
 	struct bfa_fcs_itnim_s *itnim = itnim_cbarg;
 	struct bfa_fcs_rport_s *rport = itnim->rport;
 	struct bfa_fcs_port_s *port = rport->port;
-	struct fchs_s          fchs;
+	struct fchs_s		fchs;
 	struct bfa_fcxp_s *fcxp;
-	int             len;
+	int		len;
 
 	bfa_trc(itnim->fcs, itnim->rport->pwwn);
 
@@ -428,13 +411,13 @@ bfa_fcs_itnim_send_prli(void *itnim_cbar
 	}
 	itnim->fcxp = fcxp;
 
-	len = fc_prli_build(&fchs, bfa_fcxp_get_reqbuf(fcxp), itnim->rport->pid,
-			    bfa_fcs_port_get_fcid(port), 0);
+	len = fc_prli_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),
+			    itnim->rport->pid, bfa_fcs_port_get_fcid(port), 0);
 
 	bfa_fcxp_send(fcxp, rport->bfa_rport, port->fabric->vf_id, port->lp_tag,
 		      BFA_FALSE, FC_CLASS_3, len, &fchs,
-		      bfa_fcs_itnim_prli_response, (void *)itnim, FC_MAX_PDUSZ,
-		      FC_RA_TOV);
+		      bfa_fcs_itnim_prli_response, (void *)itnim,
+		      FC_MAX_PDUSZ, FC_RA_TOV);
 
 	itnim->stats.prli_sent++;
 	bfa_sm_send_event(itnim, BFA_FCS_ITNIM_SM_FRMSENT);
@@ -445,7 +428,7 @@ bfa_fcs_itnim_prli_response(void *fcsarg
 			    bfa_status_t req_status, u32 rsp_len,
 			    u32 resid_len, struct fchs_s *rsp_fchs)
 {
-	struct bfa_fcs_itnim_s *itnim = (struct bfa_fcs_itnim_s *)cbarg;
+	struct bfa_fcs_itnim_s *itnim = (struct bfa_fcs_itnim_s *) cbarg;
 	struct fc_els_cmd_s   *els_cmd;
 	struct fc_prli_s      *prli_resp;
 	struct fc_ls_rjt_s    *ls_rjt;
@@ -476,7 +459,7 @@ bfa_fcs_itnim_prli_response(void *fcsarg
 			if (prli_resp->parampage.servparams.initiator) {
 				bfa_trc(itnim->fcs, prli_resp->parampage.type);
 				itnim->rport->scsi_function =
-					BFA_RPORT_INITIATOR;
+							BFA_RPORT_INITIATOR;
 				itnim->stats.prli_rsp_acc++;
 				bfa_sm_send_event(itnim,
 						  BFA_FCS_ITNIM_SM_INITIATOR);
@@ -489,10 +472,10 @@ bfa_fcs_itnim_prli_response(void *fcsarg
 		itnim->rport->scsi_function = BFA_RPORT_TARGET;
 
 		sparams = &prli_resp->parampage.servparams;
-		itnim->seq_rec = sparams->retry;
-		itnim->rec_support = sparams->rec_support;
+		itnim->seq_rec	     = sparams->retry;
+		itnim->rec_support   = sparams->rec_support;
 		itnim->task_retry_id = sparams->task_retry_id;
-		itnim->conf_comp = sparams->confirm;
+		itnim->conf_comp     = sparams->confirm;
 
 		itnim->stats.prli_rsp_acc++;
 		bfa_sm_send_event(itnim, BFA_FCS_ITNIM_SM_RSP_OK);
@@ -510,7 +493,7 @@ bfa_fcs_itnim_prli_response(void *fcsarg
 static void
 bfa_fcs_itnim_timeout(void *arg)
 {
-	struct bfa_fcs_itnim_s *itnim = (struct bfa_fcs_itnim_s *)arg;
+	struct bfa_fcs_itnim_s *itnim = (struct bfa_fcs_itnim_s *) arg;
 
 	itnim->stats.timeout++;
 	bfa_sm_send_event(itnim, BFA_FCS_ITNIM_SM_TIMEOUT);
@@ -530,7 +513,7 @@ bfa_fcs_itnim_free(struct bfa_fcs_itnim_
  */
 
 /**
- * 	Called by rport when a new rport is created.
+ *	Called by rport when a new rport is created.
  *
  * @param[in] rport	-  remote port.
  */
@@ -539,7 +522,7 @@ bfa_fcs_itnim_create(struct bfa_fcs_rpor
 {
 	struct bfa_fcs_port_s *port = rport->port;
 	struct bfa_fcs_itnim_s *itnim;
-	struct bfad_itnim_s *itnim_drv;
+	struct bfad_itnim_s   *itnim_drv;
 	struct bfa_itnim_s *bfa_itnim;
 
 	/*
@@ -561,7 +544,8 @@ bfa_fcs_itnim_create(struct bfa_fcs_rpor
 	/*
 	 * call BFA to create the itnim
 	 */
-	bfa_itnim = bfa_itnim_create(port->fcs->bfa, rport->bfa_rport, itnim);
+	bfa_itnim =
+		bfa_itnim_create(port->fcs->bfa, rport->bfa_rport, itnim);
 
 	if (bfa_itnim == NULL) {
 		bfa_trc(port->fcs, rport->pwwn);
@@ -570,10 +554,10 @@ bfa_fcs_itnim_create(struct bfa_fcs_rpor
 		return NULL;
 	}
 
-	itnim->bfa_itnim = bfa_itnim;
-	itnim->seq_rec = BFA_FALSE;
-	itnim->rec_support = BFA_FALSE;
-	itnim->conf_comp = BFA_FALSE;
+	itnim->bfa_itnim     = bfa_itnim;
+	itnim->seq_rec	     = BFA_FALSE;
+	itnim->rec_support   = BFA_FALSE;
+	itnim->conf_comp     = BFA_FALSE;
 	itnim->task_retry_id = BFA_FALSE;
 
 	/*
@@ -585,7 +569,7 @@ bfa_fcs_itnim_create(struct bfa_fcs_rpor
 }
 
 /**
- * 	Called by rport to delete  the instance of FCPIM.
+ *	Called by rport to delete  the instance of FCPIM.
  *
  * @param[in] rport	-  remote port.
  */
@@ -608,8 +592,8 @@ bfa_fcs_itnim_rport_online(struct bfa_fc
 		bfa_sm_send_event(itnim, BFA_FCS_ITNIM_SM_ONLINE);
 	} else {
 		/*
-		 * For well known addresses, we set the itnim to initiator
-		 * state
+		 * For well known addresses, we set the
+		 * itnim to initiator state
 		 */
 		itnim->stats.initiator++;
 		bfa_sm_send_event(itnim, BFA_FCS_ITNIM_SM_INITIATOR);
@@ -646,13 +630,12 @@ bfa_fcs_itnim_get_online_state(struct bf
 {
 	bfa_trc(itnim->fcs, itnim->rport->pid);
 	switch (bfa_sm_to_state(itnim_sm_table, itnim->sm)) {
-	case BFA_ITNIM_ONLINE:
-	case BFA_ITNIM_INITIATIOR:
+	case  BFA_ITNIM_ONLINE:
+	case  BFA_ITNIM_INITIATIOR:
 		return BFA_STATUS_OK;
 
 	default:
 		return BFA_STATUS_NO_FCPIM_NEXUS;
-
 	}
 }
 
@@ -662,7 +645,7 @@ bfa_fcs_itnim_get_online_state(struct bf
 void
 bfa_cb_itnim_online(void *cbarg)
 {
-	struct bfa_fcs_itnim_s *itnim = (struct bfa_fcs_itnim_s *)cbarg;
+	struct bfa_fcs_itnim_s *itnim = (struct bfa_fcs_itnim_s *) cbarg;
 
 	bfa_trc(itnim->fcs, itnim->rport->pwwn);
 	bfa_sm_send_event(itnim, BFA_FCS_ITNIM_SM_HCB_ONLINE);
@@ -674,7 +657,7 @@ bfa_cb_itnim_online(void *cbarg)
 void
 bfa_cb_itnim_offline(void *cb_arg)
 {
-	struct bfa_fcs_itnim_s *itnim = (struct bfa_fcs_itnim_s *)cb_arg;
+	struct bfa_fcs_itnim_s *itnim = (struct bfa_fcs_itnim_s *) cb_arg;
 
 	bfa_trc(itnim->fcs, itnim->rport->pwwn);
 	bfa_sm_send_event(itnim, BFA_FCS_ITNIM_SM_HCB_OFFLINE);
@@ -687,10 +670,9 @@ bfa_cb_itnim_offline(void *cb_arg)
 void
 bfa_cb_itnim_tov_begin(void *cb_arg)
 {
-	struct bfa_fcs_itnim_s *itnim = (struct bfa_fcs_itnim_s *)cb_arg;
+	struct bfa_fcs_itnim_s *itnim = (struct bfa_fcs_itnim_s *) cb_arg;
 
 	bfa_trc(itnim->fcs, itnim->rport->pwwn);
-	bfa_fcb_itnim_tov_begin(itnim->itnim_drv);
 }
 
 /**
@@ -699,14 +681,14 @@ bfa_cb_itnim_tov_begin(void *cb_arg)
 void
 bfa_cb_itnim_tov(void *cb_arg)
 {
-	struct bfa_fcs_itnim_s *itnim = (struct bfa_fcs_itnim_s *)cb_arg;
+	struct bfa_fcs_itnim_s *itnim = (struct bfa_fcs_itnim_s *) cb_arg;
 
 	bfa_trc(itnim->fcs, itnim->rport->pwwn);
 	bfa_fcb_itnim_tov(itnim->itnim_drv);
 }
 
 /**
- * 		BFA notification to FCS/driver for second level error recovery.
+ *		BFA notification to FCS/driver for second level error recovery.
  *
  * Atleast one I/O request has timedout and target is unresponsive to
  * repeated abort requests. Second level error recovery should be initiated
@@ -715,7 +697,7 @@ bfa_cb_itnim_tov(void *cb_arg)
 void
 bfa_cb_itnim_sler(void *cb_arg)
 {
-	struct bfa_fcs_itnim_s *itnim = (struct bfa_fcs_itnim_s *)cb_arg;
+	struct bfa_fcs_itnim_s *itnim = (struct bfa_fcs_itnim_s *) cb_arg;
 
 	itnim->stats.sler++;
 	bfa_trc(itnim->fcs, itnim->rport->pwwn);
@@ -732,7 +714,7 @@ bfa_fcs_itnim_lookup(struct bfa_fcs_port
 		return NULL;
 
 	bfa_assert(rport->itnim != NULL);
-	return (rport->itnim);
+	return rport->itnim;
 }
 
 bfa_status_t
@@ -746,10 +728,10 @@ bfa_fcs_itnim_attr_get(struct bfa_fcs_po
 	if (itnim == NULL)
 		return BFA_STATUS_NO_FCPIM_NEXUS;
 
-	attr->state = bfa_sm_to_state(itnim_sm_table, itnim->sm);
-	attr->retry = itnim->seq_rec;
-	attr->rec_support = itnim->rec_support;
-	attr->conf_comp = itnim->conf_comp;
+	attr->state	    = bfa_sm_to_state(itnim_sm_table, itnim->sm);
+	attr->retry	    = itnim->seq_rec;
+	attr->rec_support   = itnim->rec_support;
+	attr->conf_comp	    = itnim->conf_comp;
 	attr->task_retry_id = itnim->task_retry_id;
 
 	return BFA_STATUS_OK;
@@ -791,7 +773,7 @@ bfa_fcs_itnim_stats_clear(struct bfa_fcs
 
 void
 bfa_fcs_fcpim_uf_recv(struct bfa_fcs_itnim_s *itnim, struct fchs_s *fchs,
-		      u16 len)
+						u16 len)
 {
 	struct fc_els_cmd_s   *els_cmd;
 
@@ -824,21 +806,4 @@ bfa_fcs_itnim_resume(struct bfa_fcs_itni
 {
 }
 
-/**
- *   Module initialization
- */
-void
-bfa_fcs_fcpim_modinit(struct bfa_fcs_s *fcs)
-{
-}
-
-/**
- *   Module cleanup
- */
-void
-bfa_fcs_fcpim_modexit(struct bfa_fcs_s *fcs)
-{
-	bfa_fcs_modexit_comp(fcs);
-}
-
 
diff -uprN a/drivers/scsi/bfa/fcs.h b/drivers/scsi/bfa/fcs.h
--- a/drivers/scsi/bfa/fcs.h	2009-12-18 18:16:22.365684000 -0800
+++ b/drivers/scsi/bfa/fcs.h	2009-11-25 18:16:26.000000000 -0800
@@ -23,7 +23,7 @@
 #ifndef __FCS_H__
 #define __FCS_H__
 
-#define __fcs_min_cfg(__fcs)       (__fcs)->min_cfg
+#define __fcs_min_cfg(__fcs)       ((__fcs)->min_cfg)
 
 void bfa_fcs_modexit_comp(struct bfa_fcs_s *fcs);
 
diff -uprN a/drivers/scsi/bfa/fcs_fabric.h b/drivers/scsi/bfa/fcs_fabric.h
--- a/drivers/scsi/bfa/fcs_fabric.h	2009-12-18 18:16:22.361687000 -0800
+++ b/drivers/scsi/bfa/fcs_fabric.h	2009-11-25 18:16:26.000000000 -0800
@@ -27,35 +27,39 @@
 #include <fcs/bfa_fcs_lport.h>
 
 /*
-* fcs friend functions: only between fcs modules
+ * fcs friend functions: only between fcs modules
  */
-void            bfa_fcs_fabric_modinit(struct bfa_fcs_s *fcs);
-void            bfa_fcs_fabric_modexit(struct bfa_fcs_s *fcs);
-void            bfa_fcs_fabric_modsusp(struct bfa_fcs_s *fcs);
-void            bfa_fcs_fabric_link_up(struct bfa_fcs_fabric_s *fabric);
-void            bfa_fcs_fabric_link_down(struct bfa_fcs_fabric_s *fabric);
-void            bfa_fcs_fabric_addvport(struct bfa_fcs_fabric_s *fabric,
-					struct bfa_fcs_vport_s *vport);
-void            bfa_fcs_fabric_delvport(struct bfa_fcs_fabric_s *fabric,
-					struct bfa_fcs_vport_s *vport);
-int             bfa_fcs_fabric_is_online(struct bfa_fcs_fabric_s *fabric);
-struct bfa_fcs_vport_s *bfa_fcs_fabric_vport_lookup(
-			struct bfa_fcs_fabric_s *fabric, wwn_t pwwn);
-void            bfa_fcs_fabric_modstart(struct bfa_fcs_s *fcs);
-void            bfa_fcs_fabric_uf_recv(struct bfa_fcs_fabric_s *fabric,
+void bfa_fcs_fabric_attach(struct bfa_fcs_s *fcs);
+void bfa_fcs_fabric_modinit(struct bfa_fcs_s *fcs);
+void bfa_fcs_fabric_modexit(struct bfa_fcs_s *fcs);
+void bfa_fcs_fabric_modsusp(struct bfa_fcs_s *fcs);
+void bfa_fcs_fabric_link_up(struct bfa_fcs_fabric_s *fabric);
+void bfa_fcs_fabric_link_down(struct bfa_fcs_fabric_s *fabric);
+void bfa_fcs_fabric_addvport(struct bfa_fcs_fabric_s *fabric,
+	struct bfa_fcs_vport_s *vport);
+void bfa_fcs_fabric_delvport(struct bfa_fcs_fabric_s *fabric,
+	struct bfa_fcs_vport_s *vport);
+int bfa_fcs_fabric_is_online(struct bfa_fcs_fabric_s *fabric);
+struct bfa_fcs_vport_s*
+bfa_fcs_fabric_vport_lookup(struct bfa_fcs_fabric_s *fabric, wwn_t pwwn);
+void bfa_fcs_fabric_modstart(struct bfa_fcs_s *fcs);
+void bfa_fcs_fabric_uf_recv(struct bfa_fcs_fabric_s *fabric,
 			struct fchs_s *fchs, u16 len);
-u16        bfa_fcs_fabric_vport_count(struct bfa_fcs_fabric_s *fabric);
-bfa_boolean_t   bfa_fcs_fabric_is_loopback(struct bfa_fcs_fabric_s *fabric);
+u16	bfa_fcs_fabric_vport_count(struct bfa_fcs_fabric_s *fabric);
+bfa_boolean_t	bfa_fcs_fabric_is_loopback(struct bfa_fcs_fabric_s *fabric);
+bfa_boolean_t	bfa_fcs_fabric_is_auth_failed(struct bfa_fcs_fabric_s *fabric);
 enum bfa_pport_type bfa_fcs_fabric_port_type(struct bfa_fcs_fabric_s *fabric);
-void     	bfa_fcs_fabric_psymb_init(struct bfa_fcs_fabric_s *fabric);
-void bfa_fcs_fabric_port_delete_comp(struct bfa_fcs_fabric_s *fabric);
+void	bfa_fcs_fabric_psymb_init(struct bfa_fcs_fabric_s *fabric);
+void	bfa_fcs_fabric_port_delete_comp(struct bfa_fcs_fabric_s *fabric);
 
-bfa_status_t bfa_fcs_fabric_addvf(struct bfa_fcs_fabric_s *vf,
-			struct bfa_fcs_s *fcs, struct bfa_port_cfg_s *port_cfg,
-			struct bfad_vf_s *vf_drv);
+bfa_status_t	bfa_fcs_fabric_addvf(struct bfa_fcs_fabric_s *vf,
+				struct bfa_fcs_s *fcs,
+				struct bfa_port_cfg_s *port_cfg,
+				struct bfad_vf_s *vf_drv);
 void bfa_fcs_auth_finished(struct bfa_fcs_fabric_s *fabric,
-			enum auth_status status);
+	enum auth_status status);
 
 void bfa_fcs_fabric_set_fabric_name(struct bfa_fcs_fabric_s *fabric,
-			wwn_t fabric_name);
+	       wwn_t fabric_name);
+
 #endif /* __FCS_FABRIC_H__ */
diff -uprN a/drivers/scsi/bfa/fcs_fcpim.h b/drivers/scsi/bfa/fcs_fcpim.h
--- a/drivers/scsi/bfa/fcs_fcpim.h	2009-12-18 18:16:22.360684000 -0800
+++ b/drivers/scsi/bfa/fcs_fcpim.h	2009-11-25 18:16:26.000000000 -0800
@@ -34,11 +34,7 @@ void bfa_fcs_itnim_is_initiator(struct b
 void bfa_fcs_itnim_pause(struct bfa_fcs_itnim_s *itnim);
 void bfa_fcs_itnim_resume(struct bfa_fcs_itnim_s *itnim);
 
-/*
- * Modudle init/cleanup routines.
- */
-void bfa_fcs_fcpim_modinit(struct bfa_fcs_s *fcs);
-void bfa_fcs_fcpim_modexit(struct bfa_fcs_s *fcs);
 void bfa_fcs_fcpim_uf_recv(struct bfa_fcs_itnim_s *itnim, struct fchs_s *fchs,
-			u16 len);
+				u16 len);
+
 #endif /* __FCS_FCPIM_H__ */
diff -uprN a/drivers/scsi/bfa/fcs_fcptm.h b/drivers/scsi/bfa/fcs_fcptm.h
--- a/drivers/scsi/bfa/fcs_fcptm.h	2009-12-18 18:16:22.358685000 -0800
+++ b/drivers/scsi/bfa/fcs_fcptm.h	2009-11-25 18:16:26.000000000 -0800
@@ -26,20 +26,20 @@
  * Following routines are from FCPTM and will be called by rport.
  */
 struct bfa_fcs_tin_s *bfa_fcs_tin_create(struct bfa_fcs_rport_s *rport);
-void bfa_fcs_tin_rport_offline(struct bfa_fcs_tin_s *tin);
-void bfa_fcs_tin_rport_online(struct bfa_fcs_tin_s *tin);
-void bfa_fcs_tin_delete(struct bfa_fcs_tin_s *tin);
-void bfa_fcs_tin_rx_prli(struct bfa_fcs_tin_s *tin, struct fchs_s *fchs,
-			u16 len);
-void bfa_fcs_tin_pause(struct bfa_fcs_tin_s *tin);
-void bfa_fcs_tin_resume(struct bfa_fcs_tin_s *tin);
+void            bfa_fcs_tin_rport_offline(struct bfa_fcs_tin_s *tin);
+void            bfa_fcs_tin_rport_online(struct bfa_fcs_tin_s *tin);
+void            bfa_fcs_tin_delete(struct bfa_fcs_tin_s *tin);
+void            bfa_fcs_tin_rx_prli(struct bfa_fcs_tin_s *tin,
+						struct fchs_s *fchs, u16 len);
+void            bfa_fcs_tin_pause(struct bfa_fcs_tin_s *tin);
+void            bfa_fcs_tin_resume(struct bfa_fcs_tin_s *tin);
 
 /*
  * Modudle init/cleanup routines.
  */
-void bfa_fcs_fcptm_modinit(struct bfa_fcs_s *fcs);
-void bfa_fcs_fcptm_modexit(struct bfa_fcs_s *fcs);
-void bfa_fcs_fcptm_uf_recv(struct bfa_fcs_tin_s *tin, struct fchs_s *fchs,
-			u16 len);
+void            bfa_fcs_fcptm_modinit(struct bfa_fcs_s *fcs);
+void            bfa_fcs_fcptm_modexit(struct bfa_fcs_s *fcs);
+void            bfa_fcs_fcptm_uf_recv(struct bfa_fcs_tin_s *tin,
+						struct fchs_s *fchs, u16 len);
 
 #endif /* __FCS_FCPTM_H__ */
diff -uprN a/drivers/scsi/bfa/fcs_lport.h b/drivers/scsi/bfa/fcs_lport.h
--- a/drivers/scsi/bfa/fcs_lport.h	2009-12-18 18:16:22.343686000 -0800
+++ b/drivers/scsi/bfa/fcs_lport.h	2009-11-25 18:16:26.000000000 -0800
@@ -77,38 +77,38 @@
 /*
  * handler for unsolicied frames
  */
-void bfa_fcs_port_uf_recv(struct bfa_fcs_port_s *lport, struct fchs_s *fchs,
-			u16 len);
+void	bfa_fcs_port_uf_recv(struct bfa_fcs_port_s *lport, struct fchs_s *fchs,
+				     u16 len);
 
 /*
  * Following routines will be called by Fabric to indicate port
  * online/offline to vport.
  */
-void bfa_fcs_lport_init(struct bfa_fcs_port_s *lport, struct bfa_fcs_s *fcs,
-			u16 vf_id, struct bfa_port_cfg_s *port_cfg,
-			struct bfa_fcs_vport_s *vport);
-void bfa_fcs_port_online(struct bfa_fcs_port_s *port);
-void bfa_fcs_port_offline(struct bfa_fcs_port_s *port);
-void bfa_fcs_port_delete(struct bfa_fcs_port_s *port);
-bfa_boolean_t   bfa_fcs_port_is_online(struct bfa_fcs_port_s *port);
+void bfa_fcs_lport_attach(struct bfa_fcs_port_s *lport, struct bfa_fcs_s *fcs,
+			  u16 vf_id, struct bfa_fcs_vport_s *vport);
+void bfa_fcs_lport_init(struct bfa_fcs_port_s *lport,
+			struct bfa_port_cfg_s *port_cfg);
+void            bfa_fcs_port_online(struct bfa_fcs_port_s *port);
+void            bfa_fcs_port_offline(struct bfa_fcs_port_s *port);
+void            bfa_fcs_port_delete(struct bfa_fcs_port_s *port);
 
 /*
  * Lookup rport based on PID
  */
-struct bfa_fcs_rport_s *bfa_fcs_port_get_rport_by_pid(
-			struct bfa_fcs_port_s *port, u32 pid);
+struct bfa_fcs_rport_s*
+bfa_fcs_port_get_rport_by_pid(struct bfa_fcs_port_s *port, u32 pid);
 
 /*
  * Lookup rport based on PWWN
  */
-struct bfa_fcs_rport_s *bfa_fcs_port_get_rport_by_pwwn(
-			struct bfa_fcs_port_s *port, wwn_t pwwn);
-struct bfa_fcs_rport_s *bfa_fcs_port_get_rport_by_nwwn(
-			struct bfa_fcs_port_s *port, wwn_t nwwn);
-void bfa_fcs_port_add_rport(struct bfa_fcs_port_s *port,
-			struct bfa_fcs_rport_s *rport);
-void bfa_fcs_port_del_rport(struct bfa_fcs_port_s *port,
-			struct bfa_fcs_rport_s *rport);
+struct bfa_fcs_rport_s*
+bfa_fcs_port_get_rport_by_pwwn(struct bfa_fcs_port_s *port, wwn_t pwwn);
+struct bfa_fcs_rport_s*
+bfa_fcs_port_get_rport_by_nwwn(struct bfa_fcs_port_s *port, wwn_t nwwn);
+void            bfa_fcs_port_add_rport(struct bfa_fcs_port_s *port,
+				       struct bfa_fcs_rport_s *rport);
+void            bfa_fcs_port_del_rport(struct bfa_fcs_port_s *port,
+				       struct bfa_fcs_rport_s *rport);
 
 void bfa_fcs_port_modinit(struct bfa_fcs_s *fcs);
 void bfa_fcs_port_modexit(struct bfa_fcs_s *fcs);
diff -uprN a/drivers/scsi/bfa/fcs_port.h b/drivers/scsi/bfa/fcs_port.h
--- a/drivers/scsi/bfa/fcs_port.h	2009-12-18 18:16:22.339701000 -0800
+++ b/drivers/scsi/bfa/fcs_port.h	2009-11-25 18:16:26.000000000 -0800
@@ -26,7 +26,6 @@
 /*
  * fcs friend functions: only between fcs modules
  */
-void bfa_fcs_pport_modinit(struct bfa_fcs_s *fcs);
-void bfa_fcs_pport_modexit(struct bfa_fcs_s *fcs);
+void bfa_fcs_pport_attach(struct bfa_fcs_s *fcs);
 
 #endif /* __FCS_PPORT_H__ */
diff -uprN a/drivers/scsi/bfa/fcs_rport.h b/drivers/scsi/bfa/fcs_rport.h
--- a/drivers/scsi/bfa/fcs_rport.h	2009-12-18 18:16:22.338691000 -0800
+++ b/drivers/scsi/bfa/fcs_rport.h	2009-11-25 18:16:26.000000000 -0800
@@ -24,34 +24,29 @@
 
 #include <fcs/bfa_fcs_rport.h>
 
-void bfa_fcs_rport_modinit(struct bfa_fcs_s *fcs);
-void bfa_fcs_rport_modexit(struct bfa_fcs_s *fcs);
-
 void bfa_fcs_rport_uf_recv(struct bfa_fcs_rport_s *rport, struct fchs_s *fchs,
-			u16 len);
+				u16 len);
 void bfa_fcs_rport_scn(struct bfa_fcs_rport_s *rport);
 
 struct bfa_fcs_rport_s *bfa_fcs_rport_create(struct bfa_fcs_port_s *port,
-			u32 pid);
+						u32 pid);
 void bfa_fcs_rport_delete(struct bfa_fcs_rport_s *rport);
 void bfa_fcs_rport_online(struct bfa_fcs_rport_s *rport);
 void bfa_fcs_rport_offline(struct bfa_fcs_rport_s *rport);
 void bfa_fcs_rport_start(struct bfa_fcs_port_s *port, struct fchs_s *rx_fchs,
-			struct fc_logi_s *plogi_rsp);
+			 struct fc_logi_s *plogi_rsp);
 void bfa_fcs_rport_plogi_create(struct bfa_fcs_port_s *port,
-			struct fchs_s *rx_fchs,
-			struct fc_logi_s *plogi);
+			struct fchs_s *rx_fchs, struct fc_logi_s *plogi);
 void bfa_fcs_rport_plogi(struct bfa_fcs_rport_s *rport, struct fchs_s *fchs,
-			struct fc_logi_s *plogi);
+			 struct fc_logi_s *plogi);
 void bfa_fcs_rport_logo_imp(struct bfa_fcs_rport_s *rport);
+
 void bfa_fcs_rport_itnim_ack(struct bfa_fcs_rport_s *rport);
 void bfa_fcs_rport_itntm_ack(struct bfa_fcs_rport_s *rport);
-void bfa_fcs_rport_tin_ack(struct bfa_fcs_rport_s *rport);
 void bfa_fcs_rport_fcptm_offline_done(struct bfa_fcs_rport_s *rport);
 int  bfa_fcs_rport_get_state(struct bfa_fcs_rport_s *rport);
-struct bfa_fcs_rport_s *bfa_fcs_rport_create_by_wwn(struct bfa_fcs_port_s *port,
-			wwn_t wwn);
-
+struct bfa_fcs_rport_s *bfa_fcs_rport_create_by_wwn(
+			struct bfa_fcs_port_s *port, wwn_t wwn);
 
 /* Rport Features */
 void  bfa_fcs_rpf_init(struct bfa_fcs_rport_s *rport);
diff -uprN a/drivers/scsi/bfa/fcs_uf.h b/drivers/scsi/bfa/fcs_uf.h
--- a/drivers/scsi/bfa/fcs_uf.h	2009-12-18 18:16:22.334702000 -0800
+++ b/drivers/scsi/bfa/fcs_uf.h	2009-11-25 18:16:26.000000000 -0800
@@ -26,7 +26,6 @@
 /*
  * fcs friend functions: only between fcs modules
  */
-void bfa_fcs_uf_modinit(struct bfa_fcs_s *fcs);
-void bfa_fcs_uf_modexit(struct bfa_fcs_s *fcs);
+void bfa_fcs_uf_attach(struct bfa_fcs_s *fcs);
 
 #endif /* __FCS_UF_H__ */
diff -uprN a/drivers/scsi/bfa/fcs_vport.h b/drivers/scsi/bfa/fcs_vport.h
--- a/drivers/scsi/bfa/fcs_vport.h	2009-12-18 18:16:22.332705000 -0800
+++ b/drivers/scsi/bfa/fcs_vport.h	2009-11-25 18:16:26.000000000 -0800
@@ -22,18 +22,9 @@
 #include <fcs/bfa_fcs_vport.h>
 #include <defs/bfa_defs_pci.h>
 
-/*
- * Modudle init/cleanup routines.
- */
-
-void bfa_fcs_vport_modinit(struct bfa_fcs_s *fcs);
-void bfa_fcs_vport_modexit(struct bfa_fcs_s *fcs);
-
 void bfa_fcs_vport_cleanup(struct bfa_fcs_vport_s *vport);
 void bfa_fcs_vport_online(struct bfa_fcs_vport_s *vport);
 void bfa_fcs_vport_offline(struct bfa_fcs_vport_s *vport);
 void bfa_fcs_vport_delete_comp(struct bfa_fcs_vport_s *vport);
-u32 bfa_fcs_vport_get_max(struct bfa_fcs_s *fcs);
 
 #endif /* __FCS_VPORT_H__ */
-
diff -uprN a/drivers/scsi/bfa/fdmi.c b/drivers/scsi/bfa/fdmi.c
--- a/drivers/scsi/bfa/fdmi.c	2009-12-18 18:16:22.331699000 -0800
+++ b/drivers/scsi/bfa/fdmi.c	2009-11-25 18:21:07.000000000 -0800
@@ -64,18 +64,18 @@ static void     bfa_fcs_port_fdmi_rpa_re
 					       u32 resid_len,
 					       struct fchs_s *rsp_fchs);
 static void     bfa_fcs_port_fdmi_timeout(void *arg);
-static u16 bfa_fcs_port_fdmi_build_rhba_pyld(
-			struct bfa_fcs_port_fdmi_s *fdmi, u8 *pyld);
-static u16 bfa_fcs_port_fdmi_build_rprt_pyld(
-			struct bfa_fcs_port_fdmi_s *fdmi, u8 *pyld);
-static u16 bfa_fcs_port_fdmi_build_rpa_pyld(
-			struct bfa_fcs_port_fdmi_s *fdmi, u8 *pyld);
-static u16 bfa_fcs_port_fdmi_build_portattr_block(
-			struct bfa_fcs_port_fdmi_s *fdmi, u8 *pyld);
-void bfa_fcs_fdmi_get_hbaattr(struct bfa_fcs_port_fdmi_s *fdmi,
-			struct bfa_fcs_fdmi_hba_attr_s *hba_attr);
-void bfa_fcs_fdmi_get_portattr(struct bfa_fcs_port_fdmi_s *fdmi,
-			struct bfa_fcs_fdmi_port_attr_s *port_attr);
+static u16 bfa_fcs_port_fdmi_build_rhba_pyld(struct bfa_fcs_port_fdmi_s *fdmi,
+						  u8 *pyld);
+static u16 bfa_fcs_port_fdmi_build_rprt_pyld(struct bfa_fcs_port_fdmi_s *fdmi,
+						  u8 *pyld);
+static u16 bfa_fcs_port_fdmi_build_rpa_pyld(struct bfa_fcs_port_fdmi_s *fdmi,
+						 u8 *pyld);
+static u16 bfa_fcs_port_fdmi_build_portattr_block(struct bfa_fcs_port_fdmi_s *
+						       fdmi, u8 *pyld);
+static void     bfa_fcs_fdmi_get_hbaattr(struct bfa_fcs_port_fdmi_s *fdmi,
+				struct bfa_fcs_fdmi_hba_attr_s *hba_attr);
+static void	bfa_fcs_fdmi_get_portattr(struct bfa_fcs_port_fdmi_s *fdmi,
+				struct bfa_fcs_fdmi_port_attr_s *port_attr);
 /**
  *  fcs_fdmi_sm FCS FDMI state machine
  */
@@ -94,28 +94,46 @@ enum port_fdmi_event {
 	FDMISM_EVENT_RPA_SENT = 9,
 };
 
-static void bfa_fcs_port_fdmi_sm_offline(struct bfa_fcs_port_fdmi_s *fdmi,
-			enum port_fdmi_event event);
-static void bfa_fcs_port_fdmi_sm_sending_rhba(struct bfa_fcs_port_fdmi_s *fdmi,
-			enum port_fdmi_event event);
-static void bfa_fcs_port_fdmi_sm_rhba(struct bfa_fcs_port_fdmi_s *fdmi,
-			enum port_fdmi_event event);
-static void bfa_fcs_port_fdmi_sm_rhba_retry(struct bfa_fcs_port_fdmi_s *fdmi,
-			enum port_fdmi_event event);
-static void bfa_fcs_port_fdmi_sm_sending_rprt(struct bfa_fcs_port_fdmi_s *fdmi,
-			enum port_fdmi_event event);
-static void bfa_fcs_port_fdmi_sm_rprt(struct bfa_fcs_port_fdmi_s *fdmi,
-			enum port_fdmi_event event);
-static void bfa_fcs_port_fdmi_sm_rprt_retry(struct bfa_fcs_port_fdmi_s *fdmi,
-			enum port_fdmi_event event);
-static void bfa_fcs_port_fdmi_sm_sending_rpa(struct bfa_fcs_port_fdmi_s *fdmi,
-			enum port_fdmi_event event);
-static void     bfa_fcs_port_fdmi_sm_rpa(struct bfa_fcs_port_fdmi_s *fdmi,
-			enum port_fdmi_event event);
-static void     bfa_fcs_port_fdmi_sm_rpa_retry(struct bfa_fcs_port_fdmi_s *fdmi,
-			enum port_fdmi_event event);
-static void     bfa_fcs_port_fdmi_sm_online(struct bfa_fcs_port_fdmi_s *fdmi,
-			enum port_fdmi_event event);
+static void
+bfa_fcs_port_fdmi_sm_offline(struct bfa_fcs_port_fdmi_s *fdmi,
+			     enum port_fdmi_event event);
+static void
+bfa_fcs_port_fdmi_sm_sending_rhba(struct bfa_fcs_port_fdmi_s *fdmi,
+					enum port_fdmi_event event);
+static void
+bfa_fcs_port_fdmi_sm_rhba(struct bfa_fcs_port_fdmi_s *fdmi,
+			  enum port_fdmi_event event);
+static void
+bfa_fcs_port_fdmi_sm_rhba_retry(struct bfa_fcs_port_fdmi_s *fdmi,
+				enum port_fdmi_event event);
+
+static void
+bfa_fcs_port_fdmi_sm_sending_rprt(struct bfa_fcs_port_fdmi_s *fdmi,
+				  enum port_fdmi_event event);
+static void
+bfa_fcs_port_fdmi_sm_rprt(struct bfa_fcs_port_fdmi_s *fdmi,
+			  enum port_fdmi_event event);
+static void
+bfa_fcs_port_fdmi_sm_rprt_retry(struct bfa_fcs_port_fdmi_s *fdmi,
+				enum port_fdmi_event event);
+
+static void
+bfa_fcs_port_fdmi_sm_sending_rpa(struct bfa_fcs_port_fdmi_s *fdmi,
+				 enum port_fdmi_event event);
+static void
+bfa_fcs_port_fdmi_sm_rpa(struct bfa_fcs_port_fdmi_s *fdmi,
+			 enum port_fdmi_event event);
+static void
+bfa_fcs_port_fdmi_sm_rpa_retry(struct bfa_fcs_port_fdmi_s *fdmi,
+			       enum port_fdmi_event event);
+
+static void
+bfa_fcs_port_fdmi_sm_online(struct bfa_fcs_port_fdmi_s *fdmi,
+			    enum port_fdmi_event event);
+
+static void
+bfa_fcs_port_fdmi_sm_disabled(struct bfa_fcs_port_fdmi_s *fdmi,
+			    enum port_fdmi_event event);
 /**
  * 		Start in offline state - awaiting MS to send start.
  */
@@ -155,7 +173,7 @@ bfa_fcs_port_fdmi_sm_offline(struct bfa_
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(port->fcs, event);
 	}
 }
 
@@ -176,17 +194,17 @@ bfa_fcs_port_fdmi_sm_sending_rhba(struct
 	case FDMISM_EVENT_PORT_OFFLINE:
 		bfa_sm_set_state(fdmi, bfa_fcs_port_fdmi_sm_offline);
 		bfa_fcxp_walloc_cancel(BFA_FCS_GET_HAL_FROM_PORT(port),
-				       &fdmi->fcxp_wqe);
+					   &fdmi->fcxp_wqe);
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(port->fcs, event);
 	}
 }
 
 static void
 bfa_fcs_port_fdmi_sm_rhba(struct bfa_fcs_port_fdmi_s *fdmi,
-			  enum port_fdmi_event event)
+						enum port_fdmi_event event)
 {
 	struct bfa_fcs_port_s *port = fdmi->ms->port;
 
@@ -202,8 +220,9 @@ bfa_fcs_port_fdmi_sm_rhba(struct bfa_fcs
 		if (fdmi->retry_cnt++ < BFA_FCS_FDMI_CMD_MAX_RETRIES) {
 			bfa_sm_set_state(fdmi, bfa_fcs_port_fdmi_sm_rhba_retry);
 			bfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(port),
-					&fdmi->timer, bfa_fcs_port_fdmi_timeout,
-					fdmi, BFA_FCS_RETRY_TIMEOUT);
+					    &fdmi->timer,
+					    bfa_fcs_port_fdmi_timeout, fdmi,
+					    BFA_FCS_RETRY_TIMEOUT);
 		} else {
 			/*
 			 * set state to offline
@@ -227,7 +246,7 @@ bfa_fcs_port_fdmi_sm_rhba(struct bfa_fcs
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(port->fcs, event);
 	}
 }
 
@@ -255,7 +274,7 @@ bfa_fcs_port_fdmi_sm_rhba_retry(struct b
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(port->fcs, event);
 	}
 }
 
@@ -279,17 +298,17 @@ bfa_fcs_port_fdmi_sm_sending_rprt(struct
 	case FDMISM_EVENT_PORT_OFFLINE:
 		bfa_sm_set_state(fdmi, bfa_fcs_port_fdmi_sm_offline);
 		bfa_fcxp_walloc_cancel(BFA_FCS_GET_HAL_FROM_PORT(port),
-				       &fdmi->fcxp_wqe);
+					   &fdmi->fcxp_wqe);
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(port->fcs, event);
 	}
 }
 
 static void
 bfa_fcs_port_fdmi_sm_rprt(struct bfa_fcs_port_fdmi_s *fdmi,
-			  enum port_fdmi_event event)
+				enum port_fdmi_event event)
 {
 	struct bfa_fcs_port_s *port = fdmi->ms->port;
 
@@ -305,8 +324,9 @@ bfa_fcs_port_fdmi_sm_rprt(struct bfa_fcs
 		if (fdmi->retry_cnt++ < BFA_FCS_FDMI_CMD_MAX_RETRIES) {
 			bfa_sm_set_state(fdmi, bfa_fcs_port_fdmi_sm_rprt_retry);
 			bfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(port),
-					&fdmi->timer, bfa_fcs_port_fdmi_timeout,
-					fdmi, BFA_FCS_RETRY_TIMEOUT);
+					    &fdmi->timer,
+					    bfa_fcs_port_fdmi_timeout, fdmi,
+					    BFA_FCS_RETRY_TIMEOUT);
 
 		} else {
 			/*
@@ -328,7 +348,7 @@ bfa_fcs_port_fdmi_sm_rprt(struct bfa_fcs
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(port->fcs, event);
 	}
 }
 
@@ -356,7 +376,7 @@ bfa_fcs_port_fdmi_sm_rprt_retry(struct b
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(port->fcs, event);
 	}
 }
 
@@ -380,17 +400,17 @@ bfa_fcs_port_fdmi_sm_sending_rpa(struct 
 	case FDMISM_EVENT_PORT_OFFLINE:
 		bfa_sm_set_state(fdmi, bfa_fcs_port_fdmi_sm_offline);
 		bfa_fcxp_walloc_cancel(BFA_FCS_GET_HAL_FROM_PORT(port),
-				       &fdmi->fcxp_wqe);
+					   &fdmi->fcxp_wqe);
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(port->fcs, event);
 	}
 }
 
 static void
 bfa_fcs_port_fdmi_sm_rpa(struct bfa_fcs_port_fdmi_s *fdmi,
-			 enum port_fdmi_event event)
+			enum port_fdmi_event event)
 {
 	struct bfa_fcs_port_s *port = fdmi->ms->port;
 
@@ -406,8 +426,9 @@ bfa_fcs_port_fdmi_sm_rpa(struct bfa_fcs_
 		if (fdmi->retry_cnt++ < BFA_FCS_FDMI_CMD_MAX_RETRIES) {
 			bfa_sm_set_state(fdmi, bfa_fcs_port_fdmi_sm_rpa_retry);
 			bfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(port),
-					&fdmi->timer, bfa_fcs_port_fdmi_timeout,
-					fdmi, BFA_FCS_RETRY_TIMEOUT);
+					    &fdmi->timer,
+					    bfa_fcs_port_fdmi_timeout, fdmi,
+					    BFA_FCS_RETRY_TIMEOUT);
 		} else {
 			/*
 			 * set state to offline
@@ -428,7 +449,7 @@ bfa_fcs_port_fdmi_sm_rpa(struct bfa_fcs_
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(port->fcs, event);
 	}
 }
 
@@ -456,13 +477,13 @@ bfa_fcs_port_fdmi_sm_rpa_retry(struct bf
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(port->fcs, event);
 	}
 }
 
 static void
 bfa_fcs_port_fdmi_sm_online(struct bfa_fcs_port_fdmi_s *fdmi,
-			    enum port_fdmi_event event)
+				enum port_fdmi_event event)
 {
 	struct bfa_fcs_port_s *port = fdmi->ms->port;
 
@@ -475,13 +496,27 @@ bfa_fcs_port_fdmi_sm_online(struct bfa_f
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(port->fcs, event);
 	}
 }
+/**
+ *  FDMI is disabled state.
+ */
+static void
+bfa_fcs_port_fdmi_sm_disabled(struct bfa_fcs_port_fdmi_s *fdmi,
+			     enum port_fdmi_event event)
+{
+	struct bfa_fcs_port_s *port = fdmi->ms->port;
+
+	bfa_trc(port->fcs, port->port_cfg.pwwn);
+	bfa_trc(port->fcs, event);
+
+	/* No op State. It can only be enabled at Driver Init. */
+}
 
 
 /**
-*   RHBA : Register HBA Attributes.
+*  RHBA : Register HBA Attributes.
  */
 static void
 bfa_fcs_port_fdmi_send_rhba(void *fdmi_cbarg, struct bfa_fcxp_s *fcxp_alloced)
@@ -498,7 +533,7 @@ bfa_fcs_port_fdmi_send_rhba(void *fdmi_c
 	fcxp = fcxp_alloced ? fcxp_alloced : bfa_fcs_fcxp_alloc(port->fcs);
 	if (!fcxp) {
 		bfa_fcxp_alloc_wait(port->fcs->bfa, &fdmi->fcxp_wqe,
-				    bfa_fcs_port_fdmi_send_rhba, fdmi);
+					bfa_fcs_port_fdmi_send_rhba, fdmi);
 		return;
 	}
 	fdmi->fcxp = fcxp;
@@ -509,24 +544,25 @@ bfa_fcs_port_fdmi_send_rhba(void *fdmi_c
 	len = fc_fdmi_reqhdr_build(&fchs, pyld, bfa_fcs_port_get_fcid(port),
 				   FDMI_RHBA);
 
-	attr_len = bfa_fcs_port_fdmi_build_rhba_pyld(fdmi,
-			(u8 *) ((struct ct_hdr_s *) pyld + 1));
+	attr_len =
+		bfa_fcs_port_fdmi_build_rhba_pyld(fdmi,
+					(u8 *) ((struct ct_hdr_s *) pyld
+					       + 1));
 
 	bfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,
-		      FC_CLASS_3, (len + attr_len), &fchs,
-		      bfa_fcs_port_fdmi_rhba_response, (void *)fdmi,
-		      FC_MAX_PDUSZ, FC_RA_TOV);
+			  FC_CLASS_3, (len + attr_len), &fchs,
+			  bfa_fcs_port_fdmi_rhba_response, (void *)fdmi,
+			  FC_MAX_PDUSZ, FC_RA_TOV);
 
 	bfa_sm_send_event(fdmi, FDMISM_EVENT_RHBA_SENT);
 }
 
 static          u16
-bfa_fcs_port_fdmi_build_rhba_pyld(struct bfa_fcs_port_fdmi_s *fdmi,
-				  u8 *pyld)
+bfa_fcs_port_fdmi_build_rhba_pyld(struct bfa_fcs_port_fdmi_s *fdmi, u8 *pyld)
 {
 	struct bfa_fcs_port_s *port = fdmi->ms->port;
 	struct bfa_fcs_fdmi_hba_attr_s hba_attr;	/* @todo */
-	struct bfa_fcs_fdmi_hba_attr_s *fcs_hba_attr = &hba_attr; /* @todo */
+	struct bfa_fcs_fdmi_hba_attr_s *fcs_hba_attr = &hba_attr;  /* @todo */
 	struct fdmi_rhba_s    *rhba = (struct fdmi_rhba_s *) pyld;
 	struct fdmi_attr_s    *attr;
 	u8        *curr_ptr;
@@ -572,8 +608,10 @@ bfa_fcs_port_fdmi_build_rhba_pyld(struct
 	attr->type = bfa_os_htons(FDMI_HBA_ATTRIB_MANUFACTURER);
 	attr->len = (u16) strlen(fcs_hba_attr->manufacturer);
 	memcpy(attr->value, fcs_hba_attr->manufacturer, attr->len);
-	/* variable fields need to be 4 byte aligned */
-	attr->len = fc_roundup(attr->len, sizeof(u32));
+	attr->len = fc_roundup(attr->len, sizeof(u32));	/* variable
+							 * fields need
+							 * to be 4 byte
+							 * aligned */
 	curr_ptr += sizeof(attr->type) + sizeof(attr->len) + attr->len;
 	len += attr->len;
 	count++;
@@ -588,8 +626,10 @@ bfa_fcs_port_fdmi_build_rhba_pyld(struct
 	attr->type = bfa_os_htons(FDMI_HBA_ATTRIB_SERIALNUM);
 	attr->len = (u16) strlen(fcs_hba_attr->serial_num);
 	memcpy(attr->value, fcs_hba_attr->serial_num, attr->len);
-	/* variable fields need to be 4 byte aligned */
-	attr->len = fc_roundup(attr->len, sizeof(u32));
+	attr->len = fc_roundup(attr->len, sizeof(u32));	/* variable
+							 * fields need
+							 * to be 4 byte
+							 * aligned */
 	curr_ptr += sizeof(attr->type) + sizeof(attr->len) + attr->len;
 	len += attr->len;
 	count++;
@@ -604,8 +644,10 @@ bfa_fcs_port_fdmi_build_rhba_pyld(struct
 	attr->type = bfa_os_htons(FDMI_HBA_ATTRIB_MODEL);
 	attr->len = (u16) strlen(fcs_hba_attr->model);
 	memcpy(attr->value, fcs_hba_attr->model, attr->len);
-	/* variable fields need to be 4 byte aligned */
-	attr->len = fc_roundup(attr->len, sizeof(u32));
+	attr->len = fc_roundup(attr->len, sizeof(u32));	/* variable
+							 * fields need
+							 * to be 4 byte
+							 * aligned */
 	curr_ptr += sizeof(attr->type) + sizeof(attr->len) + attr->len;
 	len += attr->len;
 	count++;
@@ -620,8 +662,10 @@ bfa_fcs_port_fdmi_build_rhba_pyld(struct
 	attr->type = bfa_os_htons(FDMI_HBA_ATTRIB_MODEL_DESC);
 	attr->len = (u16) strlen(fcs_hba_attr->model_desc);
 	memcpy(attr->value, fcs_hba_attr->model_desc, attr->len);
-	/* variable fields need to be 4 byte aligned */
-	attr->len = fc_roundup(attr->len, sizeof(u32));
+	attr->len = fc_roundup(attr->len, sizeof(u32));	/* variable
+							 * fields need
+							 * to be 4 byte
+							 * aligned */
 	curr_ptr += sizeof(attr->type) + sizeof(attr->len) + attr->len;
 	len += attr->len;
 	count++;
@@ -637,14 +681,16 @@ bfa_fcs_port_fdmi_build_rhba_pyld(struct
 		attr->type = bfa_os_htons(FDMI_HBA_ATTRIB_HW_VERSION);
 		attr->len = (u16) strlen(fcs_hba_attr->hw_version);
 		memcpy(attr->value, fcs_hba_attr->hw_version, attr->len);
-		/* variable fields need to be 4 byte aligned */
-		attr->len = fc_roundup(attr->len, sizeof(u32));
+		attr->len = fc_roundup(attr->len, sizeof(u32));/* variable
+								* fields need
+								* to be 4 byte
+								* aligned */
 		curr_ptr += sizeof(attr->type) + sizeof(attr->len) + attr->len;
 		len += attr->len;
 		count++;
 		attr->len =
 			bfa_os_htons(attr->len + sizeof(attr->type) +
-				     sizeof(attr->len));
+					 sizeof(attr->len));
 	}
 
 	/*
@@ -654,8 +700,10 @@ bfa_fcs_port_fdmi_build_rhba_pyld(struct
 	attr->type = bfa_os_htons(FDMI_HBA_ATTRIB_DRIVER_VERSION);
 	attr->len = (u16) strlen(fcs_hba_attr->driver_version);
 	memcpy(attr->value, fcs_hba_attr->driver_version, attr->len);
-	/* variable fields need to be 4 byte aligned */
-	attr->len = fc_roundup(attr->len, sizeof(u32));
+	attr->len = fc_roundup(attr->len, sizeof(u32));	/* variable
+							 * fields need
+							 * to be 4 byte
+							 * aligned */
 	curr_ptr += sizeof(attr->type) + sizeof(attr->len) + attr->len;
 	len += attr->len;;
 	count++;
@@ -671,14 +719,16 @@ bfa_fcs_port_fdmi_build_rhba_pyld(struct
 		attr->type = bfa_os_htons(FDMI_HBA_ATTRIB_ROM_VERSION);
 		attr->len = (u16) strlen(fcs_hba_attr->option_rom_ver);
 		memcpy(attr->value, fcs_hba_attr->option_rom_ver, attr->len);
-		/* variable fields need to be 4 byte aligned */
-		attr->len = fc_roundup(attr->len, sizeof(u32));
+		attr->len = fc_roundup(attr->len, sizeof(u32));/* variable
+								* fields need
+								* to be 4 byte
+								* aligned */
 		curr_ptr += sizeof(attr->type) + sizeof(attr->len) + attr->len;
 		len += attr->len;
 		count++;
 		attr->len =
 			bfa_os_htons(attr->len + sizeof(attr->type) +
-				     sizeof(attr->len));
+					 sizeof(attr->len));
 	}
 
 	/*
@@ -688,8 +738,10 @@ bfa_fcs_port_fdmi_build_rhba_pyld(struct
 	attr->type = bfa_os_htons(FDMI_HBA_ATTRIB_FW_VERSION);
 	attr->len = (u16) strlen(fcs_hba_attr->driver_version);
 	memcpy(attr->value, fcs_hba_attr->driver_version, attr->len);
-	/* variable fields need to be 4 byte aligned */
-	attr->len = fc_roundup(attr->len, sizeof(u32));
+	attr->len = fc_roundup(attr->len, sizeof(u32));	/* variable
+							 * fields need
+							 * to be 4 byte
+							 * aligned */
 	curr_ptr += sizeof(attr->type) + sizeof(attr->len) + attr->len;
 	len += attr->len;
 	count++;
@@ -705,14 +757,14 @@ bfa_fcs_port_fdmi_build_rhba_pyld(struct
 		attr->type = bfa_os_htons(FDMI_HBA_ATTRIB_OS_NAME);
 		attr->len = (u16) strlen(fcs_hba_attr->os_name);
 		memcpy(attr->value, fcs_hba_attr->os_name, attr->len);
-		/* variable fields need to be 4 byte aligned */
+		/* variable fields need to b 4 byte aligned */
 		attr->len = fc_roundup(attr->len, sizeof(u32));
+
 		curr_ptr += sizeof(attr->type) + sizeof(attr->len) + attr->len;
 		len += attr->len;
 		count++;
-		attr->len =
-			bfa_os_htons(attr->len + sizeof(attr->type) +
-				     sizeof(attr->len));
+		attr->len = bfa_os_htons(attr->len + sizeof(attr->type) +
+				sizeof(attr->len));
 	}
 
 	/*
@@ -731,7 +783,8 @@ bfa_fcs_port_fdmi_build_rhba_pyld(struct
 	/*
 	 * Update size of payload
 	 */
-	len += ((sizeof(attr->type) + sizeof(attr->len)) * count);
+	len += ((sizeof(attr->type) +
+		 sizeof(attr->len)) * count);
 
 	rhba->hba_attr_blk.attr_count = bfa_os_htonl(count);
 	return len;
@@ -743,7 +796,7 @@ bfa_fcs_port_fdmi_rhba_response(void *fc
 				u32 rsp_len, u32 resid_len,
 				struct fchs_s *rsp_fchs)
 {
-	struct bfa_fcs_port_fdmi_s *fdmi = (struct bfa_fcs_port_fdmi_s *)cbarg;
+	struct bfa_fcs_port_fdmi_s *fdmi = (struct bfa_fcs_port_fdmi_s *) cbarg;
 	struct bfa_fcs_port_s *port = fdmi->ms->port;
 	struct ct_hdr_s       *cthdr = NULL;
 
@@ -772,7 +825,7 @@ bfa_fcs_port_fdmi_rhba_response(void *fc
 }
 
 /**
-*   RPRT : Register Port
+*  RPRT : Register Port
  */
 static void
 bfa_fcs_port_fdmi_send_rprt(void *fdmi_cbarg, struct bfa_fcxp_s *fcxp_alloced)
@@ -789,7 +842,7 @@ bfa_fcs_port_fdmi_send_rprt(void *fdmi_c
 	fcxp = fcxp_alloced ? fcxp_alloced : bfa_fcs_fcxp_alloc(port->fcs);
 	if (!fcxp) {
 		bfa_fcxp_alloc_wait(port->fcs->bfa, &fdmi->fcxp_wqe,
-				    bfa_fcs_port_fdmi_send_rprt, fdmi);
+					bfa_fcs_port_fdmi_send_rprt, fdmi);
 		return;
 	}
 	fdmi->fcxp = fcxp;
@@ -800,13 +853,15 @@ bfa_fcs_port_fdmi_send_rprt(void *fdmi_c
 	len = fc_fdmi_reqhdr_build(&fchs, pyld, bfa_fcs_port_get_fcid(port),
 				   FDMI_RPRT);
 
-	attr_len = bfa_fcs_port_fdmi_build_rprt_pyld(fdmi,
-			(u8 *) ((struct ct_hdr_s *) pyld + 1));
+	attr_len =
+		bfa_fcs_port_fdmi_build_rprt_pyld(fdmi,
+					(u8 *) ((struct ct_hdr_s *) pyld
+					       + 1));
 
 	bfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,
-		      FC_CLASS_3, len + attr_len, &fchs,
-		      bfa_fcs_port_fdmi_rprt_response, (void *)fdmi,
-		      FC_MAX_PDUSZ, FC_RA_TOV);
+			  FC_CLASS_3, len + attr_len, &fchs,
+			  bfa_fcs_port_fdmi_rprt_response, (void *)fdmi,
+			  FC_MAX_PDUSZ, FC_RA_TOV);
 
 	bfa_sm_send_event(fdmi, FDMISM_EVENT_RPRT_SENT);
 }
@@ -823,7 +878,7 @@ bfa_fcs_port_fdmi_build_portattr_block(s
 	struct fdmi_attr_s    *attr;
 	u8        *curr_ptr;
 	u16        len;
-	u8         count = 0;
+	u8		count = 0;
 
 	/*
 	 * get port attributes
@@ -901,15 +956,14 @@ bfa_fcs_port_fdmi_build_portattr_block(s
 		attr->type = bfa_os_htons(FDMI_PORT_ATTRIB_DEV_NAME);
 		attr->len = (u16) strlen(fcs_port_attr.os_device_name);
 		memcpy(attr->value, fcs_port_attr.os_device_name, attr->len);
-		/* variable fields need to be 4 byte aligned */
+		/* variable fields need to b 4 byte aligned */
 		attr->len = fc_roundup(attr->len, sizeof(u32));
+
 		curr_ptr += sizeof(attr->type) + sizeof(attr->len) + attr->len;
 		len += attr->len;
 		++count;
-		attr->len =
-			bfa_os_htons(attr->len + sizeof(attr->type) +
-				     sizeof(attr->len));
-
+		attr->len = bfa_os_htons(attr->len + sizeof(attr->type) +
+				sizeof(attr->len));
 	}
 	/*
 	 * Host Name
@@ -919,28 +973,28 @@ bfa_fcs_port_fdmi_build_portattr_block(s
 		attr->type = bfa_os_htons(FDMI_PORT_ATTRIB_HOST_NAME);
 		attr->len = (u16) strlen(fcs_port_attr.host_name);
 		memcpy(attr->value, fcs_port_attr.host_name, attr->len);
-		/* variable fields need to be 4 byte aligned */
+		/* variable fields need to b 4 byte aligned */
 		attr->len = fc_roundup(attr->len, sizeof(u32));
+
 		curr_ptr += sizeof(attr->type) + sizeof(attr->len) + attr->len;
 		len += attr->len;
 		++count;
-		attr->len =
-			bfa_os_htons(attr->len + sizeof(attr->type) +
-				     sizeof(attr->len));
-
+		attr->len = bfa_os_htons(attr->len + sizeof(attr->type) +
+				sizeof(attr->len));
 	}
 
 	/*
 	 * Update size of payload
 	 */
 	port_attrib->attr_count = bfa_os_htonl(count);
-	len += ((sizeof(attr->type) + sizeof(attr->len)) * count);
+	len += ((sizeof(attr->type) +
+		 sizeof(attr->len)) * count);
 	return len;
 }
 
 static          u16
 bfa_fcs_port_fdmi_build_rprt_pyld(struct bfa_fcs_port_fdmi_s *fdmi,
-				  u8 *pyld)
+					u8 *pyld)
 {
 	struct bfa_fcs_port_s *port = fdmi->ms->port;
 	struct fdmi_rprt_s    *rprt = (struct fdmi_rprt_s *) pyld;
@@ -950,7 +1004,7 @@ bfa_fcs_port_fdmi_build_rprt_pyld(struct
 	rprt->port_name = bfa_fcs_port_get_pwwn(port);
 
 	len = bfa_fcs_port_fdmi_build_portattr_block(fdmi,
-			(u8 *) &rprt->port_attr_blk);
+				(u8 *) &rprt->port_attr_blk);
 
 	len += sizeof(rprt->hba_id) + sizeof(rprt->port_name);
 
@@ -963,7 +1017,7 @@ bfa_fcs_port_fdmi_rprt_response(void *fc
 				u32 rsp_len, u32 resid_len,
 				struct fchs_s *rsp_fchs)
 {
-	struct bfa_fcs_port_fdmi_s *fdmi = (struct bfa_fcs_port_fdmi_s *)cbarg;
+	struct bfa_fcs_port_fdmi_s *fdmi = (struct bfa_fcs_port_fdmi_s *) cbarg;
 	struct bfa_fcs_port_s *port = fdmi->ms->port;
 	struct ct_hdr_s       *cthdr = NULL;
 
@@ -992,7 +1046,7 @@ bfa_fcs_port_fdmi_rprt_response(void *fc
 }
 
 /**
-*   RPA : Register Port Attributes.
+*  RPA : Register Port Attributes.
  */
 static void
 bfa_fcs_port_fdmi_send_rpa(void *fdmi_cbarg, struct bfa_fcxp_s *fcxp_alloced)
@@ -1009,7 +1063,7 @@ bfa_fcs_port_fdmi_send_rpa(void *fdmi_cb
 	fcxp = fcxp_alloced ? fcxp_alloced : bfa_fcs_fcxp_alloc(port->fcs);
 	if (!fcxp) {
 		bfa_fcxp_alloc_wait(port->fcs->bfa, &fdmi->fcxp_wqe,
-				    bfa_fcs_port_fdmi_send_rpa, fdmi);
+					bfa_fcs_port_fdmi_send_rpa, fdmi);
 		return;
 	}
 	fdmi->fcxp = fcxp;
@@ -1020,20 +1074,21 @@ bfa_fcs_port_fdmi_send_rpa(void *fdmi_cb
 	len = fc_fdmi_reqhdr_build(&fchs, pyld, bfa_fcs_port_get_fcid(port),
 				   FDMI_RPA);
 
-	attr_len = bfa_fcs_port_fdmi_build_rpa_pyld(fdmi,
-			(u8 *) ((struct ct_hdr_s *) pyld + 1));
+	attr_len =
+		bfa_fcs_port_fdmi_build_rpa_pyld(fdmi,
+					(u8 *) ((struct ct_hdr_s *) pyld
+					      + 1));
 
 	bfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,
-		      FC_CLASS_3, len + attr_len, &fchs,
-		      bfa_fcs_port_fdmi_rpa_response, (void *)fdmi,
-		      FC_MAX_PDUSZ, FC_RA_TOV);
+			  FC_CLASS_3, len + attr_len, &fchs,
+			  bfa_fcs_port_fdmi_rpa_response, (void *)fdmi,
+			  FC_MAX_PDUSZ, FC_RA_TOV);
 
 	bfa_sm_send_event(fdmi, FDMISM_EVENT_RPA_SENT);
 }
 
 static          u16
-bfa_fcs_port_fdmi_build_rpa_pyld(struct bfa_fcs_port_fdmi_s *fdmi,
-				 u8 *pyld)
+bfa_fcs_port_fdmi_build_rpa_pyld(struct bfa_fcs_port_fdmi_s *fdmi, u8 *pyld)
 {
 	struct bfa_fcs_port_s *port = fdmi->ms->port;
 	struct fdmi_rpa_s     *rpa = (struct fdmi_rpa_s *) pyld;
@@ -1042,7 +1097,7 @@ bfa_fcs_port_fdmi_build_rpa_pyld(struct 
 	rpa->port_name = bfa_fcs_port_get_pwwn(port);
 
 	len = bfa_fcs_port_fdmi_build_portattr_block(fdmi,
-			(u8 *) &rpa->port_attr_blk);
+				(u8 *) &rpa->port_attr_blk);
 
 	len += sizeof(rpa->port_name);
 
@@ -1051,11 +1106,11 @@ bfa_fcs_port_fdmi_build_rpa_pyld(struct 
 
 static void
 bfa_fcs_port_fdmi_rpa_response(void *fcsarg, struct bfa_fcxp_s *fcxp,
-			       void *cbarg, bfa_status_t req_status,
-			       u32 rsp_len, u32 resid_len,
-			       struct fchs_s *rsp_fchs)
+				void *cbarg,
+			       bfa_status_t req_status, u32 rsp_len,
+			       u32 resid_len, struct fchs_s *rsp_fchs)
 {
-	struct bfa_fcs_port_fdmi_s *fdmi = (struct bfa_fcs_port_fdmi_s *)cbarg;
+	struct bfa_fcs_port_fdmi_s *fdmi = (struct bfa_fcs_port_fdmi_s *) cbarg;
 	struct bfa_fcs_port_s *port = fdmi->ms->port;
 	struct ct_hdr_s       *cthdr = NULL;
 
@@ -1086,71 +1141,57 @@ bfa_fcs_port_fdmi_rpa_response(void *fcs
 static void
 bfa_fcs_port_fdmi_timeout(void *arg)
 {
-	struct bfa_fcs_port_fdmi_s *fdmi = (struct bfa_fcs_port_fdmi_s *)arg;
+	struct bfa_fcs_port_fdmi_s *fdmi = (struct bfa_fcs_port_fdmi_s *) arg;
 
 	bfa_sm_send_event(fdmi, FDMISM_EVENT_TIMEOUT);
 }
 
-void
+static void
 bfa_fcs_fdmi_get_hbaattr(struct bfa_fcs_port_fdmi_s *fdmi,
 			 struct bfa_fcs_fdmi_hba_attr_s *hba_attr)
 {
 	struct bfa_fcs_port_s *port = fdmi->ms->port;
-	struct bfa_fcs_driver_info_s *driver_info = &port->fcs->driver_info;
-	struct bfa_adapter_attr_s adapter_attr;
+	struct bfa_fcs_driver_info_s  *driver_info = &port->fcs->driver_info;
 
 	bfa_os_memset(hba_attr, 0, sizeof(struct bfa_fcs_fdmi_hba_attr_s));
-	bfa_os_memset(&adapter_attr, 0, sizeof(struct bfa_adapter_attr_s));
-
-	bfa_ioc_get_adapter_attr(&port->fcs->bfa->ioc, &adapter_attr);
-
-	strncpy(hba_attr->manufacturer, adapter_attr.manufacturer,
-		sizeof(adapter_attr.manufacturer));
-
-	strncpy(hba_attr->serial_num, adapter_attr.serial_num,
-		sizeof(adapter_attr.serial_num));
 
-	strncpy(hba_attr->model, adapter_attr.model, sizeof(hba_attr->model));
-
-	strncpy(hba_attr->model_desc, adapter_attr.model_descr,
-		sizeof(hba_attr->model_desc));
-
-	strncpy(hba_attr->hw_version, adapter_attr.hw_ver,
-		sizeof(hba_attr->hw_version));
+	bfa_ioc_get_adapter_manufacturer(&port->fcs->bfa->ioc,
+					hba_attr->manufacturer);
+	bfa_ioc_get_adapter_serial_num(&port->fcs->bfa->ioc, hba_attr->serial_num);
+	bfa_ioc_get_adapter_model(&port->fcs->bfa->ioc, hba_attr->model);
+	bfa_ioc_get_adapter_model(&port->fcs->bfa->ioc, hba_attr->model_desc);
+	bfa_ioc_get_pci_chip_rev(&port->fcs->bfa->ioc, hba_attr->hw_version);
+	bfa_ioc_get_adapter_optrom_ver(&port->fcs->bfa->ioc,
+					hba_attr->option_rom_ver);
+	bfa_ioc_get_adapter_fw_ver(&port->fcs->bfa->ioc, hba_attr->fw_version);
 
 	strncpy(hba_attr->driver_version, (char *)driver_info->version,
 		sizeof(hba_attr->driver_version));
 
-	strncpy(hba_attr->option_rom_ver, adapter_attr.optrom_ver,
-		sizeof(hba_attr->option_rom_ver));
-
-	strncpy(hba_attr->fw_version, adapter_attr.fw_ver,
-		sizeof(hba_attr->fw_version));
-
 	strncpy(hba_attr->os_name, driver_info->host_os_name,
 		sizeof(hba_attr->os_name));
 
-	/*
-	 * If there is a patch level, append it to the os name along with a
-	 * separator
+	/**
+	 * If there is a patch level, append it to
+	 * the os name along with a separator
 	 */
 	if (driver_info->host_os_patch[0] != '\0') {
 		strncat(hba_attr->os_name, BFA_FCS_PORT_SYMBNAME_SEPARATOR,
 			sizeof(BFA_FCS_PORT_SYMBNAME_SEPARATOR));
 		strncat(hba_attr->os_name, driver_info->host_os_patch,
-			sizeof(driver_info->host_os_patch));
+				sizeof(driver_info->host_os_patch));
 	}
 
 	hba_attr->max_ct_pyld = bfa_os_htonl(FC_MAX_PDUSZ);
 
 }
 
-void
+static void
 bfa_fcs_fdmi_get_portattr(struct bfa_fcs_port_fdmi_s *fdmi,
 			  struct bfa_fcs_fdmi_port_attr_s *port_attr)
 {
 	struct bfa_fcs_port_s *port = fdmi->ms->port;
-	struct bfa_fcs_driver_info_s *driver_info = &port->fcs->driver_info;
+	struct bfa_fcs_driver_info_s  *driver_info = &port->fcs->driver_info;
 	struct bfa_pport_attr_s pport_attr;
 
 	bfa_os_memset(port_attr, 0, sizeof(struct bfa_fcs_fdmi_port_attr_s));
@@ -1158,7 +1199,7 @@ bfa_fcs_fdmi_get_portattr(struct bfa_fcs
 	/*
 	 * get pport attributes from hal
 	 */
-	bfa_pport_get_attr(port->fcs->bfa, &pport_attr);
+	bfa_fcport_get_attr(port->fcs->bfa, &pport_attr);
 
 	/*
 	 * get FC4 type Bitmask
@@ -1201,7 +1242,10 @@ bfa_fcs_port_fdmi_init(struct bfa_fcs_po
 	struct bfa_fcs_port_fdmi_s *fdmi = &ms->fdmi;
 
 	fdmi->ms = ms;
-	bfa_sm_set_state(fdmi, bfa_fcs_port_fdmi_sm_offline);
+	if (ms->port->fcs->fdmi_enabled)
+		bfa_sm_set_state(fdmi, bfa_fcs_port_fdmi_sm_offline);
+	else
+		bfa_sm_set_state(fdmi, bfa_fcs_port_fdmi_sm_disabled);
 }
 
 void
diff -uprN a/drivers/scsi/bfa/include/aen/bfa_aen.h b/drivers/scsi/bfa/include/aen/bfa_aen.h
--- a/drivers/scsi/bfa/include/aen/bfa_aen.h	2009-12-18 18:16:22.006756000 -0800
+++ b/drivers/scsi/bfa/include/aen/bfa_aen.h	2009-11-25 18:23:57.000000000 -0800
@@ -18,21 +18,24 @@
 #define __BFA_AEN_H__
 
 #include "defs/bfa_defs_aen.h"
+#include "defs/bfa_defs_status.h"
+#include "cs/bfa_debug.h"
 
-#define BFA_AEN_MAX_ENTRY   512
+#define BFA_AEN_MAX_ENTRY	512
 
-extern s32 bfa_aen_max_cfg_entry;
+extern int bfa_aen_max_cfg_entry;
 struct bfa_aen_s {
 	void		*bfad;
-	s32		max_entry;
-	s32		write_index;
-	s32		read_index;
-	u32	bfad_num;
-	u32	seq_num;
+	int		max_entry;
+	int		write_index;
+	int		read_index;
+	int		bfad_num;
+	int		seq_num;
 	void		(*aen_cb_notify)(void *bfad);
 	void		(*gettimeofday)(struct bfa_timeval_s *tv);
-	struct bfa_trc_mod_s 	*trcmod;
-	struct bfa_aen_entry_s	list[BFA_AEN_MAX_ENTRY]; /* Must be the last */
+	struct bfa_trc_mod_s *trcmod;
+	int		app_ri[BFA_AEN_MAX_APP]; /* For multiclient support */
+	struct bfa_aen_entry_s list[BFA_AEN_MAX_ENTRY]; /* Must be the last */
 };
 
 
@@ -45,48 +48,49 @@ bfa_aen_set_max_cfg_entry(int max_entry)
 	bfa_aen_max_cfg_entry = max_entry;
 }
 
-static inline s32
+static inline int
 bfa_aen_get_max_cfg_entry(void)
 {
 	return bfa_aen_max_cfg_entry;
 }
 
-static inline s32
+static inline int
 bfa_aen_get_meminfo(void)
 {
-	return (sizeof(struct bfa_aen_entry_s) * bfa_aen_get_max_cfg_entry());
+	return sizeof(struct bfa_aen_entry_s) * bfa_aen_get_max_cfg_entry();
 }
 
-static inline s32
+static inline int
 bfa_aen_get_wi(struct bfa_aen_s *aen)
 {
 	return aen->write_index;
 }
 
-static inline s32
+static inline int
 bfa_aen_get_ri(struct bfa_aen_s *aen)
 {
 	return aen->read_index;
 }
 
-static inline s32
-bfa_aen_fetch_count(struct bfa_aen_s *aen, s32 read_index)
+static inline int
+bfa_aen_fetch_count(struct bfa_aen_s *aen, enum bfa_aen_app  app_id)
 {
-	return ((aen->write_index + aen->max_entry) - read_index)
+	bfa_assert((app_id < BFA_AEN_MAX_APP) && (app_id >= bfa_aen_app_bcu));
+	return ((aen->write_index + aen->max_entry) - aen->app_ri[app_id])
 		% aen->max_entry;
 }
 
-s32 bfa_aen_init(struct bfa_aen_s *aen, struct bfa_trc_mod_s *trcmod,
-		void *bfad, u32 inst_id, void (*aen_cb_notify)(void *),
+int bfa_aen_init(struct bfa_aen_s *aen, struct bfa_trc_mod_s *trcmod,
+		void *bfad, int bfad_num, void (*aen_cb_notify)(void *),
 		void (*gettimeofday)(struct bfa_timeval_s *));
 
-s32 bfa_aen_post(struct bfa_aen_s *aen, enum bfa_aen_category aen_category,
+void bfa_aen_post(struct bfa_aen_s *aen, enum bfa_aen_category aen_category,
 		     int aen_type, union bfa_aen_data_u *aen_data);
 
-s32 bfa_aen_fetch(struct bfa_aen_s *aen, struct bfa_aen_entry_s *aen_entry,
-		      s32 entry_space, s32 rii, s32 *ri_arr,
-		      s32 ri_arr_cnt);
+bfa_status_t bfa_aen_fetch(struct bfa_aen_s *aen,
+			struct bfa_aen_entry_s *aen_entry,
+			int entry_req, enum bfa_aen_app app_id, int *entry_ret);
 
-s32 bfa_aen_get_inst(struct bfa_aen_s *aen);
+int bfa_aen_get_inst(struct bfa_aen_s *aen);
 
 #endif /* __BFA_AEN_H__ */
diff -uprN a/drivers/scsi/bfa/include/bfa.h b/drivers/scsi/bfa/include/bfa.h
--- a/drivers/scsi/bfa/include/bfa.h	2009-12-18 18:16:22.294737000 -0800
+++ b/drivers/scsi/bfa/include/bfa.h	2009-11-25 18:23:57.000000000 -0800
@@ -38,12 +38,10 @@ struct bfa_pcidev_s;
  * PCI devices supported by the current BFA
  */
 struct bfa_pciid_s {
-	u16        device_id;
-	u16        vendor_id;
+	u16	device_id;
+	u16	vendor_id;
 };
 
-extern char     bfa_version[];
-
 /**
  * BFA Power Mgmt Commands
  */
@@ -58,36 +56,36 @@ enum bfa_pm_cmd {
  * BFA memory resources
  */
 enum bfa_mem_type {
-	BFA_MEM_TYPE_KVA = 1,	/*! Kernel Virtual Memory *(non-dma-able) */
-	BFA_MEM_TYPE_DMA = 2,	/*! DMA-able memory */
+	BFA_MEM_TYPE_KVA = 1,	/*  Kernel Virtual Memory *(non-dma-able) */
+	BFA_MEM_TYPE_DMA = 2,	/*  DMA-able memory */
 	BFA_MEM_TYPE_MAX = BFA_MEM_TYPE_DMA,
 };
 
 struct bfa_mem_elem_s {
 	enum bfa_mem_type mem_type;	/*  see enum bfa_mem_type 	*/
-	u32        mem_len;	/*  Total Length in Bytes	*/
-	u8       	*kva;		/*  kernel virtual address	*/
-	u64        dma;		/*  dma address if DMA memory	*/
-	u8       	*kva_curp;	/*  kva allocation cursor	*/
-	u64        dma_curp;	/*  dma allocation cursor	*/
+	u32	mem_len;	/*  Total Length in Bytes	*/
+	u8		*kva;		/*  kernel virtual address	*/
+	u64	dma;		/*  dma address if DMA memory	*/
+	u8		*kva_curp;	/*  kva allocation cursor	*/
+	u64	dma_curp;	/*  dma allocation cursor	*/
 };
 
 struct bfa_meminfo_s {
 	struct bfa_mem_elem_s meminfo[BFA_MEM_TYPE_MAX];
 };
 #define bfa_meminfo_kva(_m)	\
-	(_m)->meminfo[BFA_MEM_TYPE_KVA - 1].kva_curp
+	((_m)->meminfo[BFA_MEM_TYPE_KVA - 1].kva_curp)
 #define bfa_meminfo_dma_virt(_m)	\
-	(_m)->meminfo[BFA_MEM_TYPE_DMA - 1].kva_curp
+	((_m)->meminfo[BFA_MEM_TYPE_DMA - 1].kva_curp)
 #define bfa_meminfo_dma_phys(_m)	\
-	(_m)->meminfo[BFA_MEM_TYPE_DMA - 1].dma_curp
+	((_m)->meminfo[BFA_MEM_TYPE_DMA - 1].dma_curp)
 
 /**
  * Generic Scatter Gather Element used by driver
  */
 struct bfa_sge_s {
-	u32        sg_len;
-	void           *sg_addr;
+	u32	sg_len;
+	void		*sg_addr;
 };
 
 #define bfa_sge_to_be(__sge) do {                                          \
@@ -100,12 +98,32 @@ struct bfa_sge_s {
 /*
  * bfa stats interfaces
  */
-#define bfa_stats(_mod, _stats)	(_mod)->stats._stats ++
+#define bfa_stats(_mod, _stats)	((_mod)->stats._stats++)
 
 #define bfa_ioc_get_stats(__bfa, __ioc_stats)	\
 	bfa_ioc_fetch_stats(&(__bfa)->ioc, __ioc_stats)
 #define bfa_ioc_clear_stats(__bfa)	\
 	bfa_ioc_clr_stats(&(__bfa)->ioc)
+#define bfa_get_nports(__bfa)	\
+	bfa_ioc_get_nports(&(__bfa)->ioc)
+#define bfa_get_adapter_manufacturer(__bfa, __manufacturer)	\
+	bfa_ioc_get_adapter_manufacturer(&(__bfa)->ioc, __manufacturer)
+#define bfa_get_adapter_model(__bfa, __model)	\
+	bfa_ioc_get_adapter_model(&(__bfa)->ioc, __model)
+#define bfa_get_adapter_serial_num(__bfa, __serial_num)	\
+	bfa_ioc_get_adapter_serial_num(&(__bfa)->ioc, __serial_num)
+#define bfa_get_adapter_fw_ver(__bfa, __fw_ver)	\
+	bfa_ioc_get_adapter_fw_ver(&(__bfa)->ioc, __fw_ver)
+#define bfa_get_adapter_optrom_ver(__bfa, __optrom_ver)	\
+	bfa_ioc_get_adapter_optrom_ver(&(__bfa)->ioc, __optrom_ver)
+#define bfa_get_pci_chip_rev(__bfa, __chip_rev)	\
+	bfa_ioc_get_pci_chip_rev(&(__bfa)->ioc, __chip_rev)
+#define bfa_get_ioc_state(__bfa)	\
+	bfa_ioc_get_state(&(__bfa)->ioc)
+#define bfa_get_type(__bfa)	\
+	bfa_ioc_get_type(&(__bfa)->ioc)
+#define bfa_get_mac(__bfa)	\
+	bfa_ioc_get_mac(&(__bfa)->ioc)
 
 /*
  * bfa API functions
@@ -136,7 +154,7 @@ void bfa_isr_enable(struct bfa_s *bfa);
 void bfa_isr_disable(struct bfa_s *bfa);
 void bfa_msix_getvecs(struct bfa_s *bfa, u32 *msix_vecs_bmap,
 			u32 *num_vecs, u32 *max_vec_bit);
-#define bfa_msix(__bfa, __vec) (__bfa)->msix.handler[__vec](__bfa, __vec)
+#define bfa_msix(__bfa, __vec)	((__bfa)->msix.handler[__vec](__bfa, __vec))
 
 void bfa_comp_deq(struct bfa_s *bfa, struct list_head *comp_q);
 void bfa_comp_process(struct bfa_s *bfa, struct list_head *comp_q);
@@ -161,16 +179,17 @@ bfa_status_t bfa_iocfc_israttr_set(struc
 void bfa_iocfc_enable(struct bfa_s *bfa);
 void bfa_iocfc_disable(struct bfa_s *bfa);
 void bfa_ioc_auto_recover(bfa_boolean_t auto_recover);
+void bfa_chip_reset(struct bfa_s *bfa);
 void bfa_cb_ioc_disable(void *bfad);
 void bfa_timer_tick(struct bfa_s *bfa);
 #define bfa_timer_start(_bfa, _timer, _timercb, _arg, _timeout)	\
 	bfa_timer_begin(&(_bfa)->timer_mod, _timer, _timercb, _arg, _timeout)
-
 /*
  * BFA debug API functions
  */
 bfa_status_t bfa_debug_fwtrc(struct bfa_s *bfa, void *trcdata, int *trclen);
 bfa_status_t bfa_debug_fwsave(struct bfa_s *bfa, void *trcdata, int *trclen);
+void bfa_debug_fwsave_clear(struct bfa_s *bfa);
 
 #include "bfa_priv.h"
 
diff -uprN a/drivers/scsi/bfa/include/bfa_fcpim.h b/drivers/scsi/bfa/include/bfa_fcpim.h
--- a/drivers/scsi/bfa/include/bfa_fcpim.h	2009-12-18 18:16:22.292740000 -0800
+++ b/drivers/scsi/bfa/include/bfa_fcpim.h	2009-11-25 18:23:57.000000000 -0800
@@ -40,7 +40,7 @@ u16	bfa_fcpim_path_tov_get(struct bfa_s 
 void		bfa_fcpim_qdepth_set(struct bfa_s *bfa, u16 q_depth);
 u16	bfa_fcpim_qdepth_get(struct bfa_s *bfa);
 bfa_status_t bfa_fcpim_get_modstats(struct bfa_s *bfa,
-			struct bfa_fcpim_stats_s *modstats);
+				struct bfa_fcpim_stats_s *modstats);
 bfa_status_t bfa_fcpim_clr_modstats(struct bfa_s *bfa);
 
 /*
diff -uprN a/drivers/scsi/bfa/include/bfa_svc.h b/drivers/scsi/bfa/include/bfa_svc.h
--- a/drivers/scsi/bfa/include/bfa_svc.h	2009-12-18 18:16:22.289741000 -0800
+++ b/drivers/scsi/bfa/include/bfa_svc.h	2009-11-25 18:23:57.000000000 -0800
@@ -26,6 +26,7 @@ struct bfa_fcxp_s;
 #include <defs/bfa_defs_pport.h>
 #include <defs/bfa_defs_rport.h>
 #include <defs/bfa_defs_qos.h>
+#include <defs/bfa_defs_fcport.h>
 #include <cs/bfa_sm.h>
 #include <bfa.h>
 
@@ -33,14 +34,14 @@ struct bfa_fcxp_s;
  * 		BFA rport information.
  */
 struct bfa_rport_info_s {
-	u16        max_frmsz;	/*  max rcv pdu size               */
-	u32        pid : 24,	/*  remote port ID                 */
-			lp_tag : 8;
-	u32        local_pid : 24,	/*  local port ID		    */
-			cisc : 8;	/*  CIRO supported		    */
-	u8         fc_class;	/*  supported FC classes. enum fc_cos */
-	u8         vf_en;		/*  virtual fabric enable          */
-	u16        vf_id;		/*  virtual fabric ID              */
+	u16	max_frmsz;	/*  max rcv pdu size		    */
+	u32	pid:24,		/*  remote port ID		    */
+			lp_tag:8;	/*  tag			    */
+	u32	local_pid:24,	/*  local port ID		    */
+			cisc:8;		/*  CIRO supported		    */
+	u8		fc_class;	/*  supported FC classes. enum fc_cos */
+	u8		vf_en;		/*  virtual fabric enable	    */
+	u16	vf_id;		/*  virtual fabric ID		    */
 	enum bfa_pport_speed speed;	/*  Rport's current speed	    */
 };
 
@@ -48,20 +49,20 @@ struct bfa_rport_info_s {
  * BFA rport data structure
  */
 struct bfa_rport_s {
-	struct list_head        qe;	  /*  queue element */
-	bfa_sm_t	      sm; 	  /*  state machine */
-	struct bfa_s          *bfa;	  /*  backpointer to BFA */
-	void                  *rport_drv; /*  fcs/driver rport object */
-	u16              fw_handle; /*  firmware rport handle */
-	u16              rport_tag; /*  BFA rport tag */
-	struct bfa_rport_info_s rport_info; /*  rport info from *fcs/driver */
-	struct bfa_reqq_wait_s reqq_wait; /*  to wait for room in reqq */
-	struct bfa_cb_qe_s    hcb_qe;	 /*  BFA callback qelem */
-	struct bfa_rport_hal_stats_s stats; /*  BFA rport statistics  */
-	struct bfa_rport_qos_attr_s  qos_attr;
+	struct list_head	qe;		/*  queue element */
+	bfa_sm_t	sm; 		/*  state machine */
+	struct bfa_s	*bfa;		/*  backpointer to BFA		    */
+	void		*rport_drv;	/*  fcs/driver rport object	    */
+	u16	fw_handle;	/*  firmware rport handle	    */
+	u16	rport_tag;	/*  BFA rport tag		    */
+	struct bfa_rport_info_s rport_info; /*  rport info from fcs/driver */
+	struct bfa_reqq_wait_s reqq_wait; /*  to wait for room in reqq     */
+	struct bfa_cb_qe_s hcb_qe;	/*  BFA callback qelem		    */
+	struct bfa_rport_hal_stats_s stats; /*  BFA rport statistics	    */
+	struct bfa_rport_qos_attr_s qos_attr;
 	union a {
-		bfa_status_t    status;	 /*  f/w status */
-		void            *fw_msg; /*  QoS scn event */
+		bfa_status_t	status;	/*  f/w status */
+		void		*fw_msg; /*  QoS scn event		    */
 	} event_arg;
 };
 #define BFA_RPORT_FC_COS(_rport)	((_rport)->rport_info.fc_class)
@@ -80,9 +81,9 @@ typedef void (*bfa_cb_fcxp_send_t) (void
 typedef void (*bfa_fcxp_alloc_cbfn_t) (void *cbarg, struct bfa_fcxp_s *fcxp);
 
 struct bfa_fcxp_wqe_s {
-	struct list_head         qe;
-	bfa_fcxp_alloc_cbfn_t  alloc_cbfn;
-	void           *alloc_cbarg;
+	struct list_head		qe;
+	bfa_fcxp_alloc_cbfn_t	alloc_cbfn;
+	void			*alloc_cbarg;
 };
 
 typedef u64 (*bfa_fcxp_get_sgaddr_t) (void *bfad_fcxp, int sgeid);
@@ -94,24 +95,24 @@ typedef u32 (*bfa_fcxp_get_sglen_t) (voi
  * @todo private
  */
 struct bfa_uf_buf_s {
-	u8         d[BFA_UF_BUFSZ];
+	u8		d[BFA_UF_BUFSZ];
 };
 
 
 struct bfa_uf_s {
-	struct list_head	qe;		/*  queue element	  */
-	struct bfa_s	*bfa;		/*  bfa instance	  */
-	u16        uf_tag;		/*  identifying tag f/w messages */
-	u16        vf_id;
-	u16        src_rport_handle;
-	u16        rsvd;
-	u8        	*data_ptr;
-	u16        data_len;	/*  actual receive length	  */
-	u16        pb_len;		/*  posted buffer length	  */
-	void           	*buf_kva;	/*  buffer virtual address	  */
-	u64        buf_pa;		/*  buffer physical address	  */
-	struct bfa_cb_qe_s    hcb_qe;	/*  comp: BFA comp qelem	  */
-	struct bfa_sge_s   	sges[BFI_SGE_INLINE_MAX];
+	struct list_head	qe;		/*  queue element */
+	struct bfa_s	*bfa;		/*  bfa instance		*/
+	u16	uf_tag;		/*  identifying tag fw msgs	*/
+	u16	vf_id;
+	u16	src_rport_handle;
+	u16	rsvd;
+	u8		*data_ptr;
+	u16	data_len;	/*  actual receive length	*/
+	u16	pb_len;		/*  posted buffer length	*/
+	void		*buf_kva;	/*  buffer virtual address	*/
+	u64	buf_pa;		/*  buffer physical address	*/
+	struct bfa_cb_qe_s hcb_qe;	/*  comp: BFA comp qelem	*/
+	struct bfa_sge_s sges[BFI_SGE_INLINE_MAX];
 };
 
 typedef void (*bfa_cb_pport_t) (void *cbarg, enum bfa_status status);
@@ -127,12 +128,12 @@ struct bfa_lps_s {
 	u8		reqq;		/*  lport request queue	*/
 	u8		alpa;		/*  ALPA for loop topologies	*/
 	u32	lp_pid;		/*  lport port ID		*/
-	bfa_boolean_t	fdisc;		/*  send FDISC instead of FLOGI*/
+	bfa_boolean_t	fdisc;		/*  snd FDISC instead of FLOGI	*/
 	bfa_boolean_t	auth_en;	/*  enable authentication	*/
 	bfa_boolean_t	auth_req;	/*  authentication required	*/
 	bfa_boolean_t	npiv_en;	/*  NPIV is allowed by peer	*/
 	bfa_boolean_t	fport;		/*  attached peer is F_PORT	*/
-	bfa_boolean_t	brcd_switch;/*  attached peer is brcd switch	*/
+	bfa_boolean_t	brcd_switch;	/*  attached peer is brcd sw	*/
 	bfa_status_t	status;		/*  login status		*/
 	u16	pdusz;		/*  max receive PDU size 	*/
 	u16	pr_bbcred;	/*  BB_CREDIT from peer 	*/
@@ -142,69 +143,77 @@ struct bfa_lps_s {
 	wwn_t		nwwn;		/*  node wwn of lport		*/
 	wwn_t		pr_pwwn;	/*  port wwn of lport peer	*/
 	wwn_t		pr_nwwn;	/*  node wwn of lport peer	*/
-	mac_t		lp_mac;		/*  fpma/spma MAC for lport	*/
-	mac_t		fcf_mac;	/*  FCF MAC of lport		*/
+	struct mac_s	lp_mac;		/*  fpma/spma MAC for lport	*/
+	struct mac_s	fcf_mac;	/*  FCF MAC of lport		*/
 	struct bfa_reqq_wait_s	wqe;	/*  request wait queue element	*/
 	void		*uarg;		/*  user callback arg		*/
 	struct bfa_cb_qe_s hcb_qe;	/*  comp: callback qelem	*/
 	struct bfi_lps_login_rsp_s *loginrsp;
-	bfa_eproto_status_t	ext_status;
+	bfa_eproto_status_t ext_status;
 };
 
+#define BFA_FCPORT(_bfa)	(&((_bfa)->modules.port))
+
 /*
  * bfa pport API functions
  */
-bfa_status_t bfa_pport_enable(struct bfa_s *bfa);
-bfa_status_t bfa_pport_disable(struct bfa_s *bfa);
-bfa_status_t bfa_pport_cfg_speed(struct bfa_s *bfa,
+bfa_status_t bfa_fcport_enable(struct bfa_s *bfa);
+bfa_status_t bfa_fcport_disable(struct bfa_s *bfa);
+bfa_status_t bfa_fcport_cfg_speed(struct bfa_s *bfa,
 			enum bfa_pport_speed speed);
-enum bfa_pport_speed bfa_pport_get_speed(struct bfa_s *bfa);
-bfa_status_t bfa_pport_cfg_topology(struct bfa_s *bfa,
+enum bfa_pport_speed bfa_fcport_get_speed(struct bfa_s *bfa);
+bfa_status_t bfa_fcport_cfg_topology(struct bfa_s *bfa,
 			enum bfa_pport_topology topo);
-enum bfa_pport_topology bfa_pport_get_topology(struct bfa_s *bfa);
-bfa_status_t bfa_pport_cfg_hardalpa(struct bfa_s *bfa, u8 alpa);
-bfa_boolean_t bfa_pport_get_hardalpa(struct bfa_s *bfa, u8 *alpa);
-u8 bfa_pport_get_myalpa(struct bfa_s *bfa);
-bfa_status_t bfa_pport_clr_hardalpa(struct bfa_s *bfa);
-bfa_status_t bfa_pport_cfg_maxfrsize(struct bfa_s *bfa, u16 maxsize);
-u16 bfa_pport_get_maxfrsize(struct bfa_s *bfa);
-u32 bfa_pport_mypid(struct bfa_s *bfa);
-u8 bfa_pport_get_rx_bbcredit(struct bfa_s *bfa);
-bfa_status_t bfa_pport_trunk_enable(struct bfa_s *bfa, u8 bitmap);
-bfa_status_t bfa_pport_trunk_disable(struct bfa_s *bfa);
-bfa_boolean_t bfa_pport_trunk_query(struct bfa_s *bfa, u32 *bitmap);
-void bfa_pport_get_attr(struct bfa_s *bfa, struct bfa_pport_attr_s *attr);
-wwn_t bfa_pport_get_wwn(struct bfa_s *bfa, bfa_boolean_t node);
-bfa_status_t bfa_pport_get_stats(struct bfa_s *bfa,
-			union bfa_pport_stats_u *stats,
-			bfa_cb_pport_t cbfn, void *cbarg);
-bfa_status_t bfa_pport_clear_stats(struct bfa_s *bfa, bfa_cb_pport_t cbfn,
-			void *cbarg);
-void bfa_pport_event_register(struct bfa_s *bfa,
+enum bfa_pport_topology bfa_fcport_get_topology(struct bfa_s *bfa);
+bfa_status_t bfa_fcport_cfg_hardalpa(struct bfa_s *bfa, u8 alpa);
+bfa_boolean_t bfa_fcport_get_hardalpa(struct bfa_s *bfa, u8 *alpa);
+u8 bfa_fcport_get_myalpa(struct bfa_s *bfa);
+bfa_status_t bfa_fcport_clr_hardalpa(struct bfa_s *bfa);
+bfa_status_t bfa_fcport_cfg_maxfrsize(struct bfa_s *bfa, u16 maxsize);
+u16 bfa_fcport_get_maxfrsize(struct bfa_s *bfa);
+u32 bfa_fcport_mypid(struct bfa_s *bfa);
+u8 bfa_fcport_get_rx_bbcredit(struct bfa_s *bfa);
+bfa_status_t bfa_fcport_trunk_enable(struct bfa_s *bfa, u8 bitmap);
+bfa_status_t bfa_fcport_trunk_disable(struct bfa_s *bfa);
+bfa_boolean_t bfa_fcport_trunk_query(struct bfa_s *bfa, u32 *bitmap);
+void bfa_fcport_get_attr(struct bfa_s *bfa, struct bfa_pport_attr_s *attr);
+wwn_t bfa_fcport_get_wwn(struct bfa_s *bfa, bfa_boolean_t node);
+void bfa_fcport_event_register(struct bfa_s *bfa,
 			void (*event_cbfn) (void *cbarg,
 			bfa_pport_event_t event), void *event_cbarg);
-bfa_boolean_t bfa_pport_is_disabled(struct bfa_s *bfa);
-void bfa_pport_cfg_qos(struct bfa_s *bfa, bfa_boolean_t on_off);
-void bfa_pport_cfg_ratelim(struct bfa_s *bfa, bfa_boolean_t on_off);
-bfa_status_t bfa_pport_cfg_ratelim_speed(struct bfa_s *bfa,
+bfa_boolean_t bfa_fcport_is_disabled(struct bfa_s *bfa);
+void bfa_fcport_cfg_qos(struct bfa_s *bfa, bfa_boolean_t on_off);
+void bfa_fcport_cfg_ratelim(struct bfa_s *bfa, bfa_boolean_t on_off);
+bfa_status_t bfa_fcport_cfg_ratelim_speed(struct bfa_s *bfa,
 			enum bfa_pport_speed speed);
-enum bfa_pport_speed bfa_pport_get_ratelim_speed(struct bfa_s *bfa);
+enum bfa_pport_speed bfa_fcport_get_ratelim_speed(struct bfa_s *bfa);
 
-void bfa_pport_set_tx_bbcredit(struct bfa_s *bfa, u16 tx_bbcredit);
-void bfa_pport_busy(struct bfa_s *bfa, bfa_boolean_t status);
-void bfa_pport_beacon(struct bfa_s *bfa, bfa_boolean_t beacon,
+void bfa_fcport_set_tx_bbcredit(struct bfa_s *bfa, u16 tx_bbcredit);
+void bfa_fcport_busy(struct bfa_s *bfa, bfa_boolean_t status);
+void bfa_fcport_beacon(struct bfa_s *bfa, bfa_boolean_t beacon,
 			bfa_boolean_t link_e2e_beacon);
 void bfa_cb_pport_event(void *cbarg, bfa_pport_event_t event);
-void bfa_pport_qos_get_attr(struct bfa_s *bfa, struct bfa_qos_attr_s *qos_attr);
-void bfa_pport_qos_get_vc_attr(struct bfa_s *bfa,
+void bfa_fcport_qos_get_attr(struct bfa_s *bfa,
+			struct bfa_qos_attr_s *qos_attr);
+void bfa_fcport_qos_get_vc_attr(struct bfa_s *bfa,
 			struct bfa_qos_vc_attr_s *qos_vc_attr);
-bfa_status_t bfa_pport_get_qos_stats(struct bfa_s *bfa,
-			union bfa_pport_stats_u *stats,
+bfa_status_t bfa_fcport_get_qos_stats(struct bfa_s *bfa,
+			union bfa_fcport_stats_u *stats,
+			bfa_cb_pport_t cbfn, void *cbarg);
+bfa_status_t bfa_fcport_clear_qos_stats(struct bfa_s *bfa, bfa_cb_pport_t cbfn,
+			void *cbarg);
+bfa_status_t bfa_fcport_get_fcoe_stats(struct bfa_s *bfa,
+			union bfa_fcport_stats_u *stats,
 			bfa_cb_pport_t cbfn, void *cbarg);
-bfa_status_t bfa_pport_clear_qos_stats(struct bfa_s *bfa, bfa_cb_pport_t cbfn,
+bfa_status_t bfa_fcport_clear_fcoe_stats(struct bfa_s *bfa, bfa_cb_pport_t cbfn,
 			void *cbarg);
-bfa_boolean_t     bfa_pport_is_ratelim(struct bfa_s *bfa);
-bfa_boolean_t	bfa_pport_is_linkup(struct bfa_s *bfa);
+bfa_boolean_t     bfa_fcport_is_ratelim(struct bfa_s *bfa);
+bfa_boolean_t	bfa_fcport_is_linkup(struct bfa_s *bfa);
+bfa_status_t bfa_fcport_get_stats(struct bfa_s *bfa,
+		union bfa_fcport_stats_u *stats,
+		bfa_cb_pport_t cbfn, void *cbarg);
+bfa_status_t bfa_fcport_clear_stats(struct bfa_s *bfa, bfa_cb_pport_t cbfn,
+		void *cbarg);
 
 /*
  * bfa rport API functions
@@ -249,16 +258,16 @@ void *bfa_fcxp_get_rspbuf(struct bfa_fcx
 
 void bfa_fcxp_free(struct bfa_fcxp_s *fcxp);
 
-void bfa_fcxp_send(struct bfa_fcxp_s *fcxp,
-			struct bfa_rport_s *rport, u16 vf_id, u8 lp_tag,
+void bfa_fcxp_send(struct bfa_fcxp_s *fcxp, struct bfa_rport_s *rport,
+			u16 vf_id, u8 lp_tag,
 			bfa_boolean_t cts, enum fc_cos cos,
 			u32 reqlen, struct fchs_s *fchs,
 			bfa_cb_fcxp_send_t cbfn,
 			void *cbarg,
 			u32 rsp_maxlen, u8 rsp_timeout);
 bfa_status_t bfa_fcxp_abort(struct bfa_fcxp_s *fcxp);
-u32        bfa_fcxp_get_reqbufsz(struct bfa_fcxp_s *fcxp);
-u32	bfa_fcxp_get_maxrsp(struct bfa_s *bfa);
+u32 bfa_fcxp_get_reqbufsz(struct bfa_fcxp_s *fcxp);
+u32 bfa_fcxp_get_maxrsp(struct bfa_s *bfa);
 
 static inline void *
 bfa_uf_get_frmbuf(struct bfa_uf_s *uf)
@@ -293,13 +302,15 @@ void bfa_uf_free(struct bfa_uf_s *uf);
  * bfa lport service api
  */
 
+u32 bfa_lps_get_max_vport(struct bfa_s *bfa);
 struct bfa_lps_s *bfa_lps_alloc(struct bfa_s *bfa);
 void bfa_lps_delete(struct bfa_lps_s *lps);
 void bfa_lps_discard(struct bfa_lps_s *lps);
-void bfa_lps_flogi(struct bfa_lps_s *lps, void *uarg, u8 alpa, u16 pdusz,
-		   wwn_t pwwn, wwn_t nwwn, bfa_boolean_t auth_en);
-void bfa_lps_fdisc(struct bfa_lps_s *lps, void *uarg, u16 pdusz, wwn_t pwwn,
-		   wwn_t nwwn);
+void bfa_lps_flogi(struct bfa_lps_s *lps, void *uarg, u8 alpa,
+			u16 pdusz, wwn_t pwwn, wwn_t nwwn,
+			bfa_boolean_t auth_en);
+void bfa_lps_fdisc(struct bfa_lps_s *lps, void *uarg, u16 pdusz,
+			wwn_t pwwn, wwn_t nwwn);
 void bfa_lps_flogo(struct bfa_lps_s *lps);
 void bfa_lps_fdisclogo(struct bfa_lps_s *lps);
 u8 bfa_lps_get_tag(struct bfa_lps_s *lps);
@@ -315,10 +326,11 @@ wwn_t bfa_lps_get_peer_pwwn(struct bfa_l
 wwn_t bfa_lps_get_peer_nwwn(struct bfa_lps_s *lps);
 u8 bfa_lps_get_lsrjt_rsn(struct bfa_lps_s *lps);
 u8 bfa_lps_get_lsrjt_expl(struct bfa_lps_s *lps);
+struct mac_s bfa_lps_get_lp_mac(struct bfa_lps_s *lps);
 void bfa_cb_lps_flogi_comp(void *bfad, void *uarg, bfa_status_t status);
 void bfa_cb_lps_flogo_comp(void *bfad, void *uarg);
 void bfa_cb_lps_fdisc_comp(void *bfad, void *uarg, bfa_status_t status);
 void bfa_cb_lps_fdisclogo_comp(void *bfad, void *uarg);
+void bfa_cb_lps_cvl_event(void *bfad, void *uarg);
 
 #endif /* __BFA_SVC_H__ */
-
diff -uprN a/drivers/scsi/bfa/include/bfa_timer.h b/drivers/scsi/bfa/include/bfa_timer.h
--- a/drivers/scsi/bfa/include/bfa_timer.h	2009-12-18 18:16:22.287744000 -0800
+++ b/drivers/scsi/bfa/include/bfa_timer.h	2009-11-25 18:23:57.000000000 -0800
@@ -30,8 +30,8 @@ typedef void (*bfa_timer_cbfn_t)(void *)
 struct bfa_timer_s {
 	struct list_head	qe;
 	bfa_timer_cbfn_t timercb;
-	void            *arg;
-	int             timeout;	/**< in millisecs. */
+	void		*arg;
+	int		timeout;	/**< in millisecs. */
 };
 
 /**
@@ -41,7 +41,7 @@ struct bfa_timer_mod_s {
 	struct list_head timer_q;
 };
 
-#define BFA_TIMER_FREQ 500 /**< specified in millisecs */
+#define BFA_TIMER_FREQ 200 /**< specified in millisecs */
 
 void bfa_timer_beat(struct bfa_timer_mod_s *mod);
 void bfa_timer_init(struct bfa_timer_mod_s *mod);
diff -uprN a/drivers/scsi/bfa/include/bfi/bfi.h b/drivers/scsi/bfa/include/bfi/bfi.h
--- a/drivers/scsi/bfa/include/bfi/bfi.h	2009-12-18 18:16:22.043759000 -0800
+++ b/drivers/scsi/bfa/include/bfi/bfi.h	2009-11-25 18:23:57.000000000 -0800
@@ -27,14 +27,14 @@
  * Msg header common to all msgs
  */
 struct bfi_mhdr_s {
-	u8         msg_class;	/*  @ref bfi_mclass_t	    */
-	u8         msg_id;		/*  msg opcode with in the class   */
+	u8		msg_class;	/*  @ref bfi_mclass_t		    */
+	u8		msg_id;		/*  msg opcode with in the class   */
 	union {
 		struct {
-			u8         rsvd;
-			u8         lpu_id;	/*  msg destination	    */
+			u8	rsvd;
+			u8	lpu_id;	/*  msg destination		    */
 		} h2i;
-		u16        i2htok;	/*  token in msgs to host	    */
+		u16	i2htok;	/*  token in msgs to host	    */
 	} mtag;
 };
 
@@ -71,11 +71,11 @@ struct bfi_mhdr_s {
  * SG Flags
  */
 enum {
-	BFI_SGE_DATA	= 0,	/*  data address, not last	     */
+	BFI_SGE_DATA		= 0,	/*  data address, not last	     */
 	BFI_SGE_DATA_CPL	= 1,	/*  data addr, last in current page */
 	BFI_SGE_DATA_LAST	= 3,	/*  data address, last		     */
-	BFI_SGE_LINK	= 2,	/*  link address		     */
-	BFI_SGE_PGDLEN	= 2,	/*  cumulative data length for page */
+	BFI_SGE_LINK		= 2,	/*  link address		     */
+	BFI_SGE_PGDLEN		= 2,	/*  cumulative data length for page */
 };
 
 /**
@@ -83,8 +83,8 @@ enum {
  */
 union bfi_addr_u {
 	struct {
-		u32        addr_lo;
-		u32        addr_hi;
+		u32	addr_lo;
+		u32	addr_hi;
 	} a32;
 };
 
@@ -93,13 +93,13 @@ union bfi_addr_u {
  */
 struct bfi_sge_s {
 #ifdef __BIGENDIAN
-	u32        flags	: 2,
-			rsvd	: 2,
-			sg_len	: 28;
+	u32	flags:2,
+			rsvd:2,
+			sg_len:28;
 #else
-	u32        sg_len	: 28,
-			rsvd	: 2,
-			flags	: 2;
+	u32	sg_len:28,
+			rsvd:2,
+			flags:2;
 #endif
 	union bfi_addr_u sga;
 };
@@ -143,10 +143,10 @@ enum bfi_mclass {
 	BFI_MC_IOC		= 1,	/*  IO Controller (IOC)	    */
 	BFI_MC_DIAG		= 2,	/*  Diagnostic Msgs		    */
 	BFI_MC_FLASH		= 3,	/*  Flash message class	    */
-	BFI_MC_CEE		= 4,
-	BFI_MC_FC_PORT		= 5,	/*  FC port		   	    */
+	BFI_MC_CEE		= 4,	/*  CEE			    */
+	BFI_MC_FCPORT		= 5,	/*  FC port			    */
 	BFI_MC_IOCFC		= 6,	/*  FC - IO Controller (IOC)	    */
-	BFI_MC_LL		= 7,	/*  Link Layer		 	    */
+	BFI_MC_LL		= 7,	/*  Link Layer			    */
 	BFI_MC_UF		= 8,	/*  Unsolicited frame receive	    */
 	BFI_MC_FCXP		= 9,	/*  FC Transport		    */
 	BFI_MC_LPS		= 10,	/*  lport fc login services	    */
@@ -171,4 +171,3 @@ enum bfi_mclass {
 #pragma pack()
 
 #endif /* __BFI_H__ */
-
diff -uprN a/drivers/scsi/bfa/include/bfi/bfi_cbreg.h b/drivers/scsi/bfa/include/bfi/bfi_cbreg.h
--- a/drivers/scsi/bfa/include/bfi/bfi_cbreg.h	2009-12-18 18:16:22.040756000 -0800
+++ b/drivers/scsi/bfa/include/bfi/bfi_cbreg.h	2009-11-25 18:23:57.000000000 -0800
@@ -177,6 +177,21 @@
 #define __PSS_LMEM_INIT_EN               0x00000100
 #define __PSS_LPU1_RESET                 0x00000002
 #define __PSS_LPU0_RESET                 0x00000001
+#define PSS_ERR_STATUS_REG               0x00018810
+#define __PSS_LMEM1_CORR_ERR             0x00000800
+#define __PSS_LMEM0_CORR_ERR             0x00000400
+#define __PSS_LMEM1_UNCORR_ERR           0x00000200
+#define __PSS_LMEM0_UNCORR_ERR           0x00000100
+#define __PSS_BAL_PERR                   0x00000080
+#define __PSS_DIP_IF_ERR                 0x00000040
+#define __PSS_IOH_IF_ERR                 0x00000020
+#define __PSS_TDS_IF_ERR                 0x00000010
+#define __PSS_RDS_IF_ERR                 0x00000008
+#define __PSS_SGM_IF_ERR                 0x00000004
+#define __PSS_LPU1_RAM_ERR               0x00000002
+#define __PSS_LPU0_RAM_ERR               0x00000001
+#define ERR_SET_REG                      0x00018818
+#define __PSS_ERR_STATUS_SET             0x00000fff
 
 
 /*
diff -uprN a/drivers/scsi/bfa/include/bfi/bfi_ctreg.h b/drivers/scsi/bfa/include/bfi/bfi_ctreg.h
--- a/drivers/scsi/bfa/include/bfi/bfi_ctreg.h	2009-12-18 18:16:22.036756000 -0800
+++ b/drivers/scsi/bfa/include/bfi/bfi_ctreg.h	2009-11-25 18:23:57.000000000 -0800
@@ -430,6 +430,31 @@ enum {
 #define __PSS_LMEM_INIT_EN               0x00000100
 #define __PSS_LPU1_RESET                 0x00000002
 #define __PSS_LPU0_RESET                 0x00000001
+#define PSS_ERR_STATUS_REG               0x00018810
+#define __PSS_LPU1_TCM_READ_ERR          0x00200000
+#define __PSS_LPU0_TCM_READ_ERR          0x00100000
+#define __PSS_LMEM5_CORR_ERR             0x00080000
+#define __PSS_LMEM4_CORR_ERR             0x00040000
+#define __PSS_LMEM3_CORR_ERR             0x00020000
+#define __PSS_LMEM2_CORR_ERR             0x00010000
+#define __PSS_LMEM1_CORR_ERR             0x00008000
+#define __PSS_LMEM0_CORR_ERR             0x00004000
+#define __PSS_LMEM5_UNCORR_ERR           0x00002000
+#define __PSS_LMEM4_UNCORR_ERR           0x00001000
+#define __PSS_LMEM3_UNCORR_ERR           0x00000800
+#define __PSS_LMEM2_UNCORR_ERR           0x00000400
+#define __PSS_LMEM1_UNCORR_ERR           0x00000200
+#define __PSS_LMEM0_UNCORR_ERR           0x00000100
+#define __PSS_BAL_PERR                   0x00000080
+#define __PSS_DIP_IF_ERR                 0x00000040
+#define __PSS_IOH_IF_ERR                 0x00000020
+#define __PSS_TDS_IF_ERR                 0x00000010
+#define __PSS_RDS_IF_ERR                 0x00000008
+#define __PSS_SGM_IF_ERR                 0x00000004
+#define __PSS_LPU1_RAM_ERR               0x00000002
+#define __PSS_LPU0_RAM_ERR               0x00000001
+#define ERR_SET_REG                      0x00018818
+#define __PSS_ERR_STATUS_SET             0x003fffff
 #define HQM_QSET0_RXQ_DRBL_P0            0x00038000
 #define __RXQ0_ADD_VECTORS_P             0x80000000
 #define __RXQ0_STOP_P                    0x40000000
@@ -516,29 +541,29 @@ enum {
 #define RME_CI_PTR_Q(__n) \
 	(RME_CI_PTR_Q0 + (__n) * (RME_CI_PTR_Q1 - RME_CI_PTR_Q0))
 #define HQM_QSET_RXQ_DRBL_P0(__n) \
-	(HQM_QSET0_RXQ_DRBL_P0 + (__n) * (HQM_QSET1_RXQ_DRBL_P0 - \
-	HQM_QSET0_RXQ_DRBL_P0))
+	(HQM_QSET0_RXQ_DRBL_P0 +  \
+		(__n) * (HQM_QSET1_RXQ_DRBL_P0 - HQM_QSET0_RXQ_DRBL_P0))
 #define HQM_QSET_TXQ_DRBL_P0(__n) \
-	(HQM_QSET0_TXQ_DRBL_P0 + (__n) * (HQM_QSET1_TXQ_DRBL_P0 - \
-	HQM_QSET0_TXQ_DRBL_P0))
+	(HQM_QSET0_TXQ_DRBL_P0 +  \
+		(__n) * (HQM_QSET1_TXQ_DRBL_P0 - HQM_QSET0_TXQ_DRBL_P0))
 #define HQM_QSET_IB_DRBL_1_P0(__n) \
-	(HQM_QSET0_IB_DRBL_1_P0 + (__n) * (HQM_QSET1_IB_DRBL_1_P0 - \
-	HQM_QSET0_IB_DRBL_1_P0))
+	(HQM_QSET0_IB_DRBL_1_P0 +  \
+		(__n) * (HQM_QSET1_IB_DRBL_1_P0 - HQM_QSET0_IB_DRBL_1_P0))
 #define HQM_QSET_IB_DRBL_2_P0(__n) \
-	(HQM_QSET0_IB_DRBL_2_P0 + (__n) * (HQM_QSET1_IB_DRBL_2_P0 - \
-	HQM_QSET0_IB_DRBL_2_P0))
+	(HQM_QSET0_IB_DRBL_2_P0 +  \
+		(__n) * (HQM_QSET1_IB_DRBL_2_P0 - HQM_QSET0_IB_DRBL_2_P0))
 #define HQM_QSET_RXQ_DRBL_P1(__n) \
-	(HQM_QSET0_RXQ_DRBL_P1 + (__n) * (HQM_QSET1_RXQ_DRBL_P1 - \
-	HQM_QSET0_RXQ_DRBL_P1))
+	(HQM_QSET0_RXQ_DRBL_P1 +  \
+		(__n) * (HQM_QSET1_RXQ_DRBL_P1 - HQM_QSET0_RXQ_DRBL_P1))
 #define HQM_QSET_TXQ_DRBL_P1(__n) \
-	(HQM_QSET0_TXQ_DRBL_P1 + (__n) * (HQM_QSET1_TXQ_DRBL_P1 - \
-	HQM_QSET0_TXQ_DRBL_P1))
+	(HQM_QSET0_TXQ_DRBL_P1 +  \
+		(__n) * (HQM_QSET1_TXQ_DRBL_P1 - HQM_QSET0_TXQ_DRBL_P1))
 #define HQM_QSET_IB_DRBL_1_P1(__n) \
-	(HQM_QSET0_IB_DRBL_1_P1 + (__n) * (HQM_QSET1_IB_DRBL_1_P1 - \
-	HQM_QSET0_IB_DRBL_1_P1))
+	(HQM_QSET0_IB_DRBL_1_P1 +  \
+		(__n) * (HQM_QSET1_IB_DRBL_1_P1 - HQM_QSET0_IB_DRBL_1_P1))
 #define HQM_QSET_IB_DRBL_2_P1(__n) \
-	(HQM_QSET0_IB_DRBL_2_P1 + (__n) * (HQM_QSET1_IB_DRBL_2_P1 - \
-	HQM_QSET0_IB_DRBL_2_P1))
+	(HQM_QSET0_IB_DRBL_2_P1 +  \
+		(__n) * (HQM_QSET1_IB_DRBL_2_P1 - HQM_QSET0_IB_DRBL_2_P1))
 
 #define CPE_Q_NUM(__fn, __q)  (((__fn) << 2) + (__q))
 #define RME_Q_NUM(__fn, __q)  (((__fn) << 2) + (__q))
@@ -589,6 +614,7 @@ enum {
 #define __HFN_INT_MBOX_LPU1                0x00200000U
 #define __HFN_INT_MBOX1_LPU0               0x00400000U
 #define __HFN_INT_MBOX1_LPU1               0x00800000U
+#define __HFN_INT_LL_HALT                  0x01000000U
 #define __HFN_INT_CPE_MASK                 0x000000ffU
 #define __HFN_INT_RME_MASK                 0x0000ff00U
 
diff -uprN a/drivers/scsi/bfa/include/bfi/bfi_ioc.h b/drivers/scsi/bfa/include/bfi/bfi_ioc.h
--- a/drivers/scsi/bfa/include/bfi/bfi_ioc.h	2009-12-18 18:16:22.028756000 -0800
+++ b/drivers/scsi/bfa/include/bfi/bfi_ioc.h	2009-11-25 18:23:57.000000000 -0800
@@ -24,11 +24,11 @@
 #pragma pack(1)
 
 enum bfi_ioc_h2i_msgs {
-	BFI_IOC_H2I_ENABLE_REQ 		= 1,
-	BFI_IOC_H2I_DISABLE_REQ 	= 2,
-	BFI_IOC_H2I_GETATTR_REQ 	= 3,
-	BFI_IOC_H2I_DBG_SYNC	 	= 4,
-	BFI_IOC_H2I_DBG_DUMP	 	= 5,
+	BFI_IOC_H2I_ENABLE_REQ		= 1,
+	BFI_IOC_H2I_DISABLE_REQ		= 2,
+	BFI_IOC_H2I_GETATTR_REQ		= 3,
+	BFI_IOC_H2I_DBG_SYNC		= 4,
+	BFI_IOC_H2I_DBG_DUMP		= 5,
 };
 
 enum bfi_ioc_i2h_msgs {
@@ -48,30 +48,30 @@ struct bfi_ioc_getattr_req_s {
 };
 
 struct bfi_ioc_attr_s {
-	wwn_t           mfg_wwn;
-	mac_t		mfg_mac;
+	wwn_t		mfg_wwn;
+	struct mac_s	mfg_mac;
 	u16	rsvd_a;
-	char            brcd_serialnum[STRSZ(BFA_MFG_SERIALNUM_SIZE)];
-	u8         pcie_gen;
-	u8         pcie_lanes_orig;
-	u8         pcie_lanes;
-	u8         rx_bbcredit;	/*  receive buffer credits */
-	u32        adapter_prop;	/*  adapter properties     */
-	u16        maxfrsize;	/*  max receive frame size */
-	char         	asic_rev;
-	u8         rsvd_b;
-	char            fw_version[BFA_VERSION_LEN];
-	char            optrom_version[BFA_VERSION_LEN];
-	struct bfa_mfg_vpd_s	vpd;
+	char		brcd_serialnum[STRSZ(BFA_MFG_SERIALNUM_SIZE)];
+	u8		pcie_gen;
+	u8		pcie_lanes_orig;
+	u8		pcie_lanes;
+	u8		rx_bbcredit;	/*  receive buffer credits */
+	u32	adapter_prop;	/*  adapter properties     */
+	u16	maxfrsize;	/*  max receive frame size */
+	char		asic_rev;
+	u8		rsvd_b;
+	char		fw_version[BFA_VERSION_LEN];
+	char		optrom_version[BFA_VERSION_LEN];
+	struct		bfa_mfg_vpd_s	vpd;
 };
 
 /**
  * BFI_IOC_I2H_GETATTR_REPLY message
  */
 struct bfi_ioc_getattr_reply_s {
-	struct bfi_mhdr_s  mh;		/*  Common msg header          */
-	u8		status;	/*  cfg reply status           */
-	u8		rsvd[3];
+	struct	bfi_mhdr_s	mh;	/*  Common msg header		*/
+	u8			status;	/*  cfg reply status		*/
+	u8			rsvd[3];
 };
 
 /**
@@ -89,21 +89,21 @@ struct bfi_ioc_getattr_reply_s {
 #define BFI_IOC_FW_SIGNATURE	(0xbfadbfad)
 #define BFI_IOC_MD5SUM_SZ	4
 struct bfi_ioc_image_hdr_s {
-	u32        signature;	/*  constant signature */
-	u32        rsvd_a;
-	u32        exec;		/*  exec vector        */
-	u32        param;		/*  parameters         */
-	u32        rsvd_b[4];
-	u32        md5sum[BFI_IOC_MD5SUM_SZ];
+	u32	signature;	/*  constant signature */
+	u32	rsvd_a;
+	u32	exec;		/*  exec vector	*/
+	u32	param;		/*  parameters		*/
+	u32	rsvd_b[4];
+	u32	md5sum[BFI_IOC_MD5SUM_SZ];
 };
 
 /**
  *  BFI_IOC_I2H_READY_EVENT message
  */
 struct bfi_ioc_rdy_event_s {
-	struct bfi_mhdr_s  mh;			/*  common msg header */
-	u8         init_status;	/*  init event status */
-	u8         rsvd[3];
+	struct bfi_mhdr_s	mh;		/*  common msg header */
+	u8			init_status;	/*  init event status */
+	u8			rsvd[3];
 };
 
 struct bfi_ioc_hbeat_s {
@@ -115,46 +115,46 @@ struct bfi_ioc_hbeat_s {
  * IOC hardware/firmware state
  */
 enum bfi_ioc_state {
-	BFI_IOC_UNINIT 	 = 0,		/*  not initialized                 */
-	BFI_IOC_INITING 	 = 1,	/*  h/w is being initialized        */
-	BFI_IOC_HWINIT 	 = 2,		/*  h/w is initialized              */
-	BFI_IOC_CFG 	 = 3,		/*  IOC configuration in progress   */
-	BFI_IOC_OP 		 = 4,	/*  IOC is operational              */
-	BFI_IOC_DISABLING 	 = 5,	/*  IOC is being disabled           */
-	BFI_IOC_DISABLED 	 = 6,	/*  IOC is disabled                 */
-	BFI_IOC_CFG_DISABLED = 7,	/*  IOC is being disabled;transient */
-	BFI_IOC_HBFAIL       = 8,	/*  IOC heart-beat failure          */
-	BFI_IOC_MEMTEST      = 9,	/*  IOC is doing memtest            */
+	BFI_IOC_UNINIT		= 0,	/*  not initialized		     */
+	BFI_IOC_INITING		= 1,	/*  h/w is being initialized	     */
+	BFI_IOC_HWINIT		= 2,	/*  h/w is initialized		     */
+	BFI_IOC_CFG		= 3,	/*  IOC configuration in progress   */
+	BFI_IOC_OP		= 4,	/*  IOC is operational		     */
+	BFI_IOC_DISABLING	= 5,	/*  IOC is being disabled	     */
+	BFI_IOC_DISABLED	= 6,	/*  IOC is disabled		     */
+	BFI_IOC_CFG_DISABLED	= 7,	/*  IOC is being disabled;transient */
+	BFI_IOC_FAIL		= 8,	/*  IOC heart-beat failure	     */
+	BFI_IOC_MEMTEST		= 9,	/*  IOC is doing memtest	     */
 };
 
 #define BFI_IOC_ENDIAN_SIG  0x12345678
 
 enum {
-	BFI_ADAPTER_TYPE_FC   = 0x01,		/*  FC adapters           */
-	BFI_ADAPTER_TYPE_MK   = 0x0f0000,	/*  adapter type mask     */
-	BFI_ADAPTER_TYPE_SH   = 16,	        /*  adapter type shift    */
-	BFI_ADAPTER_NPORTS_MK = 0xff00,		/*  number of ports mask  */
-	BFI_ADAPTER_NPORTS_SH = 8,	        /*  number of ports shift */
-	BFI_ADAPTER_SPEED_MK  = 0xff,		/*  adapter speed mask    */
-	BFI_ADAPTER_SPEED_SH  = 0,	        /*  adapter speed shift   */
-	BFI_ADAPTER_PROTO     = 0x100000,	/*  prototype adapaters   */
-	BFI_ADAPTER_TTV       = 0x200000,	/*  TTV debug capable     */
-	BFI_ADAPTER_UNSUPP    = 0x400000,	/*  unknown adapter type  */
-};
-
-#define BFI_ADAPTER_GETP(__prop,__adap_prop)          		\
-    (((__adap_prop) & BFI_ADAPTER_ ## __prop ## _MK) >>         \
-     BFI_ADAPTER_ ## __prop ## _SH)
-#define BFI_ADAPTER_SETP(__prop, __val)         		\
-    ((__val) << BFI_ADAPTER_ ## __prop ## _SH)
-#define BFI_ADAPTER_IS_PROTO(__adap_type)   			\
-    ((__adap_type) & BFI_ADAPTER_PROTO)
-#define BFI_ADAPTER_IS_TTV(__adap_type)     			\
-    ((__adap_type) & BFI_ADAPTER_TTV)
-#define BFI_ADAPTER_IS_UNSUPP(__adap_type)  			\
-    ((__adap_type) & BFI_ADAPTER_UNSUPP)
-#define BFI_ADAPTER_IS_SPECIAL(__adap_type)                     \
-    ((__adap_type) & (BFI_ADAPTER_TTV | BFI_ADAPTER_PROTO |     \
+	BFI_ADAPTER_TYPE_FC	= 0x01,		/*  FC adapters	   */
+	BFI_ADAPTER_TYPE_MK	= 0x0f0000,	/*  adapter type mask     */
+	BFI_ADAPTER_TYPE_SH	= 16,	        /*  adapter type shift    */
+	BFI_ADAPTER_NPORTS_MK	= 0xff00,	/*  number of ports mask  */
+	BFI_ADAPTER_NPORTS_SH	= 8,	        /*  number of ports shift */
+	BFI_ADAPTER_SPEED_MK	= 0xff,		/*  adapter speed mask    */
+	BFI_ADAPTER_SPEED_SH	= 0,	        /*  adapter speed shift   */
+	BFI_ADAPTER_PROTO	= 0x100000,	/*  prototype adapaters   */
+	BFI_ADAPTER_TTV		= 0x200000,	/*  TTV debug capable     */
+	BFI_ADAPTER_UNSUPP	= 0x400000,	/*  unknown adapter type  */
+};
+
+#define BFI_ADAPTER_GETP(__prop, __adap_prop)			\
+	(((__adap_prop) & BFI_ADAPTER_ ## __prop ## _MK) >>	\
+		BFI_ADAPTER_ ## __prop ## _SH)
+#define BFI_ADAPTER_SETP(__prop, __val)				\
+	((__val) << BFI_ADAPTER_ ## __prop ## _SH)
+#define BFI_ADAPTER_IS_PROTO(__adap_type)			\
+	((__adap_type) & BFI_ADAPTER_PROTO)
+#define BFI_ADAPTER_IS_TTV(__adap_type)				\
+	((__adap_type) & BFI_ADAPTER_TTV)
+#define BFI_ADAPTER_IS_UNSUPP(__adap_type)			\
+	((__adap_type) & BFI_ADAPTER_UNSUPP)
+#define BFI_ADAPTER_IS_SPECIAL(__adap_type)			\
+	((__adap_type) & (BFI_ADAPTER_TTV | BFI_ADAPTER_PROTO |	\
 			BFI_ADAPTER_UNSUPP))
 
 /**
@@ -163,16 +163,16 @@ enum {
 struct bfi_ioc_ctrl_req_s {
 	struct bfi_mhdr_s	mh;
 	u8			ioc_class;
-	u8         	rsvd[3];
+	u8			rsvd[3];
 };
 
 /**
  * BFI_IOC_I2H_ENABLE_REPLY & BFI_IOC_I2H_DISABLE_REPLY messages
  */
 struct bfi_ioc_ctrl_reply_s {
-	struct bfi_mhdr_s  mh;		/*  Common msg header     */
-	u8         status;		/*  enable/disable status */
-	u8         rsvd[3];
+	struct bfi_mhdr_s	mh;		/*  Common msg header     */
+	u8			status;		/*  enable/disable status */
+	u8			rsvd[3];
 };
 
 #define BFI_IOC_MSGSZ   8
@@ -180,23 +180,22 @@ struct bfi_ioc_ctrl_reply_s {
  * H2I Messages
  */
 union bfi_ioc_h2i_msg_u {
-	struct bfi_mhdr_s 	mh;
-	struct bfi_ioc_ctrl_req_s enable_req;
-	struct bfi_ioc_ctrl_req_s disable_req;
-	struct bfi_ioc_getattr_req_s getattr_req;
-	u32       		mboxmsg[BFI_IOC_MSGSZ];
+	struct bfi_mhdr_s 		mh;
+	struct bfi_ioc_ctrl_req_s	enable_req;
+	struct bfi_ioc_ctrl_req_s	disable_req;
+	struct bfi_ioc_getattr_req_s	getattr_req;
+	u32			mboxmsg[BFI_IOC_MSGSZ];
 };
 
 /**
  * I2H Messages
  */
 union bfi_ioc_i2h_msg_u {
-	struct bfi_mhdr_s      	mh;
+	struct bfi_mhdr_s		mh;
 	struct bfi_ioc_rdy_event_s 	rdy_event;
-	u32       		mboxmsg[BFI_IOC_MSGSZ];
+	u32			mboxmsg[BFI_IOC_MSGSZ];
 };
 
 #pragma pack()
 
 #endif /* __BFI_IOC_H__ */
-
diff -uprN a/drivers/scsi/bfa/include/bfi/bfi_lps.h b/drivers/scsi/bfa/include/bfi/bfi_lps.h
--- a/drivers/scsi/bfa/include/bfi/bfi_lps.h	2009-12-18 18:16:22.023755000 -0800
+++ b/drivers/scsi/bfa/include/bfi/bfi_lps.h	2009-11-25 18:23:57.000000000 -0800
@@ -30,6 +30,7 @@ enum bfi_lps_h2i_msgs {
 enum bfi_lps_i2h_msgs {
 	BFI_LPS_H2I_LOGIN_RSP	= BFA_I2HM(1),
 	BFI_LPS_H2I_LOGOUT_RSP	= BFA_I2HM(2),
+	BFI_LPS_H2I_CVL_EVENT	= BFA_I2HM(3),
 };
 
 struct bfi_lps_login_req_s {
@@ -55,10 +56,10 @@ struct bfi_lps_login_rsp_s {
 	u16	bb_credit;
 	u8		f_port;
 	u8		npiv_en;
-	u32	lp_pid : 24;
-	u32	auth_req : 8;
-	mac_t		lp_mac;
-	mac_t		fcf_mac;
+	u32	lp_pid:24;
+	u32	auth_req:8;
+	struct mac_s	lp_mac;
+	struct mac_s	fcf_mac;
 	u8		ext_status;
 	u8  	brcd_switch;/*  attached peer is brcd switch	*/
 };
@@ -77,6 +78,12 @@ struct bfi_lps_logout_rsp_s {
 	u8		rsvd[2];
 };
 
+struct bfi_lps_cvl_event_s {
+	struct bfi_mhdr_s  mh;		/*  common msg header		*/
+	u8		lp_tag;
+	u8		rsvd[3];
+};
+
 union bfi_lps_h2i_msg_u {
 	struct bfi_mhdr_s		*msg;
 	struct bfi_lps_login_req_s	*login_req;
@@ -87,6 +94,7 @@ union bfi_lps_i2h_msg_u {
 	struct bfi_msg_s		*msg;
 	struct bfi_lps_login_rsp_s	*login_rsp;
 	struct bfi_lps_logout_rsp_s	*logout_rsp;
+	struct bfi_lps_cvl_event_s	*cvl_event;
 };
 
 #pragma pack()
diff -uprN a/drivers/scsi/bfa/include/bfi/bfi_pport.h b/drivers/scsi/bfa/include/bfi/bfi_pport.h
--- a/drivers/scsi/bfa/include/bfi/bfi_pport.h	2009-12-18 18:16:22.019758000 -0800
+++ b/drivers/scsi/bfa/include/bfi/bfi_pport.h	2009-11-25 18:23:57.000000000 -0800
@@ -22,163 +22,97 @@
 
 #pragma pack(1)
 
-enum bfi_pport_h2i {
-	BFI_PPORT_H2I_ENABLE_REQ		= (1),
-	BFI_PPORT_H2I_DISABLE_REQ		= (2),
-	BFI_PPORT_H2I_GET_STATS_REQ		= (3),
-	BFI_PPORT_H2I_CLEAR_STATS_REQ	= (4),
-	BFI_PPORT_H2I_SET_SVC_PARAMS_REQ	= (5),
-	BFI_PPORT_H2I_ENABLE_RX_VF_TAG_REQ	= (6),
-	BFI_PPORT_H2I_ENABLE_TX_VF_TAG_REQ	= (7),
-	BFI_PPORT_H2I_GET_QOS_STATS_REQ		= (8),
-	BFI_PPORT_H2I_CLEAR_QOS_STATS_REQ	= (9),
-};
-
-enum bfi_pport_i2h {
-	BFI_PPORT_I2H_ENABLE_RSP		= BFA_I2HM(1),
-	BFI_PPORT_I2H_DISABLE_RSP		= BFA_I2HM(2),
-	BFI_PPORT_I2H_GET_STATS_RSP		= BFA_I2HM(3),
-	BFI_PPORT_I2H_CLEAR_STATS_RSP	= BFA_I2HM(4),
-	BFI_PPORT_I2H_SET_SVC_PARAMS_RSP	= BFA_I2HM(5),
-	BFI_PPORT_I2H_ENABLE_RX_VF_TAG_RSP	= BFA_I2HM(6),
-	BFI_PPORT_I2H_ENABLE_TX_VF_TAG_RSP	= BFA_I2HM(7),
-	BFI_PPORT_I2H_EVENT			= BFA_I2HM(8),
-	BFI_PPORT_I2H_GET_QOS_STATS_RSP		= BFA_I2HM(9),
-	BFI_PPORT_I2H_CLEAR_QOS_STATS_RSP	= BFA_I2HM(10),
+enum bfi_fcport_h2i {
+	BFI_FCPORT_H2I_ENABLE_REQ		= (1),
+	BFI_FCPORT_H2I_DISABLE_REQ		= (2),
+	BFI_FCPORT_H2I_SET_SVC_PARAMS_REQ	= (3),
+	BFI_FCPORT_H2I_STATS_GET_REQ		= (4),
+	BFI_FCPORT_H2I_STATS_CLEAR_REQ		= (5),
+};
+
+enum bfi_fcport_i2h {
+	BFI_FCPORT_I2H_ENABLE_RSP		= BFA_I2HM(1),
+	BFI_FCPORT_I2H_DISABLE_RSP		= BFA_I2HM(2),
+	BFI_FCPORT_I2H_SET_SVC_PARAMS_RSP	= BFA_I2HM(3),
+	BFI_FCPORT_I2H_STATS_GET_RSP		= BFA_I2HM(4),
+	BFI_FCPORT_I2H_STATS_CLEAR_RSP		= BFA_I2HM(5),
+	BFI_FCPORT_I2H_EVENT			= BFA_I2HM(6),
 };
 
 /**
  * Generic REQ type
  */
-struct bfi_pport_generic_req_s {
+struct bfi_fcport_req_s {
 	struct bfi_mhdr_s  mh;		/*  msg header			    */
-	u32        msgtag;		/*  msgtag for reply		    */
+	u32	   msgtag;	/*  msgtag for reply		    */
 };
 
 /**
  * Generic RSP type
  */
-struct bfi_pport_generic_rsp_s {
+struct bfi_fcport_rsp_s {
 	struct bfi_mhdr_s  mh;		/*  common msg header		    */
-	u8         status;		/*  port enable status		    */
-	u8         rsvd[3];
-	u32        msgtag;		/*  msgtag for reply		    */
+	u8		   status;	/*  port enable status		    */
+	u8		   rsvd[3];
+	u32	   msgtag;	/*  msgtag for reply		    */
 };
 
 /**
- * BFI_PPORT_H2I_ENABLE_REQ
+ * BFI_FCPORT_H2I_ENABLE_REQ
  */
-struct bfi_pport_enable_req_s {
+struct bfi_fcport_enable_req_s {
 	struct bfi_mhdr_s  mh;		/*  msg header			    */
-	u32        rsvd1;
-	wwn_t           nwwn;		/*  node wwn of physical port	    */
-	wwn_t           pwwn;		/*  port wwn of physical port	    */
-	struct bfa_pport_cfg_s port_cfg;	/*  port configuration	    */
-	union bfi_addr_u  stats_dma_addr;	/*  DMA address for stats  */
-	u32        msgtag;		/*  msgtag for reply		    */
-	u32        rsvd2;
+	u32	   rsvd1;
+	wwn_t		   nwwn;	/*  node wwn of physical port	    */
+	wwn_t		   pwwn;	/*  port wwn of physical port	    */
+	struct bfa_pport_cfg_s port_cfg; /*  port configuration	    */
+	union bfi_addr_u   stats_dma_addr; /*  DMA address for stats	    */
+	u32	   msgtag;	/*  msgtag for reply		    */
+	u32	   rsvd2;
 };
 
 /**
- * BFI_PPORT_I2H_ENABLE_RSP
- */
-#define bfi_pport_enable_rsp_t struct bfi_pport_generic_rsp_s
-
-/**
- * BFI_PPORT_H2I_DISABLE_REQ
- */
-#define bfi_pport_disable_req_t struct bfi_pport_generic_req_s
-
-/**
- * BFI_PPORT_I2H_DISABLE_RSP
- */
-#define bfi_pport_disable_rsp_t struct bfi_pport_generic_rsp_s
-
-/**
- * BFI_PPORT_H2I_GET_STATS_REQ
+ * BFI_FCPORT_H2I_SET_SVC_PARAMS_REQ
  */
-#define bfi_pport_get_stats_req_t struct bfi_pport_generic_req_s
-
-/**
- * BFI_PPORT_I2H_GET_STATS_RSP
- */
-#define bfi_pport_get_stats_rsp_t struct bfi_pport_generic_rsp_s
-
-/**
- * BFI_PPORT_H2I_CLEAR_STATS_REQ
- */
-#define bfi_pport_clear_stats_req_t struct bfi_pport_generic_req_s
-
-/**
- * BFI_PPORT_I2H_CLEAR_STATS_RSP
- */
-#define bfi_pport_clear_stats_rsp_t struct bfi_pport_generic_rsp_s
-
-/**
- * BFI_PPORT_H2I_GET_QOS_STATS_REQ
- */
-#define bfi_pport_get_qos_stats_req_t struct bfi_pport_generic_req_s
-
-/**
- * BFI_PPORT_H2I_GET_QOS_STATS_RSP
- */
-#define bfi_pport_get_qos_stats_rsp_t struct bfi_pport_generic_rsp_s
-
-/**
- * BFI_PPORT_H2I_CLEAR_QOS_STATS_REQ
- */
-#define bfi_pport_clear_qos_stats_req_t struct bfi_pport_generic_req_s
-
-/**
- * BFI_PPORT_H2I_CLEAR_QOS_STATS_RSP
- */
-#define bfi_pport_clear_qos_stats_rsp_t struct bfi_pport_generic_rsp_s
-
-/**
- * BFI_PPORT_H2I_SET_SVC_PARAMS_REQ
- */
-struct bfi_pport_set_svc_params_req_s {
+struct bfi_fcport_set_svc_params_req_s {
 	struct bfi_mhdr_s  mh;		/*  msg header */
-	u16        tx_bbcredit;	/*  Tx credits */
-	u16        rsvd;
+	u16	   tx_bbcredit;	/*  Tx credits */
+	u16	   rsvd;
 };
 
 /**
- * BFI_PPORT_I2H_SET_SVC_PARAMS_RSP
- */
-
-/**
- * BFI_PPORT_I2H_EVENT
+ * BFI_FCPORT_I2H_EVENT
  */
-struct bfi_pport_event_s {
+struct bfi_fcport_event_s {
 	struct bfi_mhdr_s 	mh;	/*  common msg header */
 	struct bfa_pport_link_s	link_state;
 };
 
-union bfi_pport_h2i_msg_u {
+/**
+ * fcport H2I message
+ */
+union bfi_fcport_h2i_msg_u {
 	struct bfi_mhdr_s			*mhdr;
-	struct bfi_pport_enable_req_s		*penable;
-	struct bfi_pport_generic_req_s		*pdisable;
-	struct bfi_pport_generic_req_s		*pgetstats;
-	struct bfi_pport_generic_req_s		*pclearstats;
-	struct bfi_pport_set_svc_params_req_s	*psetsvcparams;
-	struct bfi_pport_get_qos_stats_req_s	*pgetqosstats;
-	struct bfi_pport_generic_req_s		*pclearqosstats;
+	struct bfi_fcport_enable_req_s		*penable;
+	struct bfi_fcport_req_s			*pdisable;
+	struct bfi_fcport_set_svc_params_req_s	*psetsvcparams;
+	struct bfi_fcport_req_s			*pstatsget;
+	struct bfi_fcport_req_s			*pstatsclear;
 };
 
-union bfi_pport_i2h_msg_u {
+/**
+ * fcport I2H message
+ */
+union bfi_fcport_i2h_msg_u {
 	struct bfi_msg_s			*msg;
-	struct bfi_pport_generic_rsp_s		*enable_rsp;
-	struct bfi_pport_disable_rsp_s		*disable_rsp;
-	struct bfi_pport_generic_rsp_s		*getstats_rsp;
-	struct bfi_pport_clear_stats_rsp_s	*clearstats_rsp;
-	struct bfi_pport_set_svc_params_rsp_s	*setsvcparasm_rsp;
-	struct bfi_pport_get_qos_stats_rsp_s	*getqosstats_rsp;
-	struct bfi_pport_clear_qos_stats_rsp_s	*clearqosstats_rsp;
-	struct bfi_pport_event_s		*event;
+	struct bfi_fcport_rsp_s			*penable_rsp;
+	struct bfi_fcport_rsp_s			*pdisable_rsp;
+	struct bfi_fcport_rsp_s			*psetsvcparams_rsp;
+	struct bfi_fcport_rsp_s			*pstatsget_rsp;
+	struct bfi_fcport_rsp_s			*pstatsclear_rsp;
+	struct bfi_fcport_event_s		*event;
 };
 
 #pragma pack()
 
 #endif /* __BFI_PPORT_H__ */
-
diff -uprN a/drivers/scsi/bfa/include/bfi/bfi_rport.h b/drivers/scsi/bfa/include/bfi/bfi_rport.h
--- a/drivers/scsi/bfa/include/bfi/bfi_rport.h	2009-12-18 18:16:22.017759000 -0800
+++ b/drivers/scsi/bfa/include/bfi/bfi_rport.h	2009-11-25 18:23:57.000000000 -0800
@@ -38,10 +38,10 @@ struct bfi_rport_create_req_s {
 	struct bfi_mhdr_s  mh;		/*  common msg header		*/
 	u16        bfa_handle;	/*  host rport handle		*/
 	u16        max_frmsz;	/*  max rcv pdu size		*/
-	u32        pid       : 24,	/*  remote port ID		*/
-			lp_tag    : 8;	/*  local port tag		*/
-	u32        local_pid : 24,	/*  local port ID		*/
-			cisc      : 8;
+	u32        pid:24,		/*  remote port ID		*/
+			lp_tag:8;	/*  local port tag		*/
+	u32        local_pid:24,	/*  local port ID		*/
+			cisc:8;
 	u8         fc_class;	/*  supported FC classes	*/
 	u8         vf_en;		/*  virtual fabric enable	*/
 	u16        vf_id;		/*  virtual fabric ID		*/
diff -uprN a/drivers/scsi/bfa/include/cna/bfa_cna_trcmod.h b/drivers/scsi/bfa/include/cna/bfa_cna_trcmod.h
--- a/drivers/scsi/bfa/include/cna/bfa_cna_trcmod.h	2009-12-18 18:16:22.075759000 -0800
+++ b/drivers/scsi/bfa/include/cna/bfa_cna_trcmod.h	2009-11-25 18:23:57.000000000 -0800
@@ -31,6 +31,10 @@
 enum {
 	BFA_TRC_CNA_CEE		= 1,
 	BFA_TRC_CNA_PORT	= 2,
+	BFA_TRC_CNA_IOC		= 3,
+	BFA_TRC_CNA_DIAG	= 4,
+	BFA_TRC_CNA_IOC_CB	= 5,
+	BFA_TRC_CNA_IOC_CT	= 6,
 };
 
 #endif /* __BFA_CNA_TRCMOD_H__ */
diff -uprN a/drivers/scsi/bfa/include/cna/cee/bfa_cee.h b/drivers/scsi/bfa/include/cna/cee/bfa_cee.h
--- a/drivers/scsi/bfa/include/cna/cee/bfa_cee.h	2009-12-18 18:16:22.048757000 -0800
+++ b/drivers/scsi/bfa/include/cna/cee/bfa_cee.h	2009-11-25 18:23:57.000000000 -0800
@@ -61,17 +61,15 @@ struct bfa_cee_s {
 
 u32 bfa_cee_meminfo(void);
 void bfa_cee_mem_claim(struct bfa_cee_s *cee, u8 *dma_kva,
-			 u64 dma_pa);
+    u64 dma_pa);
 void bfa_cee_attach(struct bfa_cee_s *cee, struct bfa_ioc_s *ioc, void *dev,
-			struct bfa_trc_mod_s *trcmod,
-			struct bfa_log_mod_s *logmod);
+    struct bfa_trc_mod_s *trcmod, struct bfa_log_mod_s *logmod);
 void bfa_cee_detach(struct bfa_cee_s *cee);
 bfa_status_t bfa_cee_get_attr(struct bfa_cee_s *cee,
-			 struct bfa_cee_attr_s *attr,
-			bfa_cee_get_attr_cbfn_t cbfn, void *cbarg);
+    struct bfa_cee_attr_s *attr, bfa_cee_get_attr_cbfn_t cbfn, void *cbarg);
 bfa_status_t bfa_cee_get_stats(struct bfa_cee_s *cee,
-			struct bfa_cee_stats_s *stats,
-			bfa_cee_get_stats_cbfn_t cbfn, void *cbarg);
+    struct bfa_cee_stats_s *stats, bfa_cee_get_stats_cbfn_t cbfn, void *cbarg);
 bfa_status_t bfa_cee_reset_stats(struct bfa_cee_s *cee,
-			bfa_cee_reset_stats_cbfn_t cbfn, void *cbarg);
+    bfa_cee_reset_stats_cbfn_t cbfn, void *cbarg);
+
 #endif /* __BFA_CEE_H__ */
diff -uprN a/drivers/scsi/bfa/include/cna/port/bfa_port.h b/drivers/scsi/bfa/include/cna/port/bfa_port.h
--- a/drivers/scsi/bfa/include/cna/port/bfa_port.h	2009-12-18 18:16:22.059759000 -0800
+++ b/drivers/scsi/bfa/include/cna/port/bfa_port.h	2009-11-25 18:23:57.000000000 -0800
@@ -23,47 +23,47 @@
 #include <cs/bfa_trc.h>
 #include <cs/bfa_log.h>
 
-typedef void    (*bfa_port_stats_cbfn_t) (void *dev, bfa_status_t status);
-typedef void    (*bfa_port_endis_cbfn_t) (void *dev, bfa_status_t status);
+typedef void (*bfa_port_stats_cbfn_t) (void *dev, bfa_status_t status);
+typedef void (*bfa_port_endis_cbfn_t) (void *dev, bfa_status_t status);
 
 struct bfa_port_s {
-	void           *dev;
-	struct bfa_ioc_s *ioc;
-	struct bfa_trc_mod_s *trcmod;
-	struct bfa_log_mod_s *logmod;
-	u32        msgtag;
-	bfa_boolean_t   stats_busy;
-	struct bfa_mbox_cmd_s stats_mb;
-	bfa_port_stats_cbfn_t stats_cbfn;
-	void           *stats_cbarg;
-	bfa_status_t    stats_status;
-	union bfa_pport_stats_u *stats;
-	struct bfa_dma_s stats_dma;
-	bfa_boolean_t   endis_pending;
-	struct bfa_mbox_cmd_s endis_mb;
-	bfa_port_endis_cbfn_t endis_cbfn;
-	void           *endis_cbarg;
-	bfa_status_t    endis_status;
-	struct bfa_ioc_hbfail_notify_s hbfail;
+	void				*dev;
+	struct bfa_ioc_s		*ioc;
+	struct bfa_trc_mod_s 		*trcmod;
+	struct bfa_log_mod_s		*logmod;
+	u32			msgtag;
+	bfa_boolean_t			stats_busy;
+	struct bfa_mbox_cmd_s 		stats_mb;
+	bfa_port_stats_cbfn_t		stats_cbfn;
+	void				*stats_cbarg;
+	bfa_status_t			stats_status;
+	union bfa_pport_stats_u		*stats;
+	struct bfa_dma_s		stats_dma;
+	bfa_boolean_t			endis_pending;
+	struct bfa_mbox_cmd_s		endis_mb;
+	bfa_port_endis_cbfn_t		endis_cbfn;
+	void				*endis_cbarg;
+	bfa_status_t			endis_status;
+	struct bfa_ioc_hbfail_notify_s	hbfail;
 };
 
-void            bfa_port_attach(struct bfa_port_s *port, struct bfa_ioc_s *ioc,
+void	     bfa_port_attach(struct bfa_port_s *port, struct bfa_ioc_s *ioc,
 				void *dev, struct bfa_trc_mod_s *trcmod,
 				struct bfa_log_mod_s *logmod);
-void            bfa_port_detach(struct bfa_port_s *port);
-void            bfa_port_hbfail(void *arg);
+void	     bfa_port_detach(struct bfa_port_s *port);
+void	     bfa_port_hbfail(void *arg);
 
-bfa_status_t    bfa_port_get_stats(struct bfa_port_s *port,
-				   union bfa_pport_stats_u *stats,
+bfa_status_t bfa_port_get_stats(struct bfa_port_s *port,
+				 union bfa_pport_stats_u *stats,
+				 bfa_port_stats_cbfn_t cbfn, void *cbarg);
+bfa_status_t bfa_port_clear_stats(struct bfa_port_s *port,
 				   bfa_port_stats_cbfn_t cbfn, void *cbarg);
-bfa_status_t    bfa_port_clear_stats(struct bfa_port_s *port,
-				     bfa_port_stats_cbfn_t cbfn, void *cbarg);
-bfa_status_t    bfa_port_enable(struct bfa_port_s *port,
-				bfa_port_endis_cbfn_t cbfn, void *cbarg);
-bfa_status_t    bfa_port_disable(struct bfa_port_s *port,
-				 bfa_port_endis_cbfn_t cbfn, void *cbarg);
-u32        bfa_port_meminfo(void);
-void            bfa_port_mem_claim(struct bfa_port_s *port, u8 *dma_kva,
-				   u64 dma_pa);
+bfa_status_t bfa_port_enable(struct bfa_port_s *port,
+			      bfa_port_endis_cbfn_t cbfn, void *cbarg);
+bfa_status_t bfa_port_disable(struct bfa_port_s *port,
+			       bfa_port_endis_cbfn_t cbfn, void *cbarg);
+u32     bfa_port_meminfo(void);
+void	     bfa_port_mem_claim(struct bfa_port_s *port,
+				 u8 *dma_kva, u64 dma_pa);
 
-#endif /* __BFA_PORT_H__ */
+#endif	/* __BFA_PORT_H__ */
diff -uprN a/drivers/scsi/bfa/include/cna/pstats/ethport_defs.h b/drivers/scsi/bfa/include/cna/pstats/ethport_defs.h
--- a/drivers/scsi/bfa/include/cna/pstats/ethport_defs.h	2009-12-18 18:16:22.073761000 -0800
+++ b/drivers/scsi/bfa/include/cna/pstats/ethport_defs.h	2009-11-25 18:23:57.000000000 -0800
@@ -27,7 +27,6 @@ struct bnad_drv_stats {
 	u64 udpcsum_offload;
 	u64 csum_help;
 	u64 csum_help_err;
-
 	u64 hw_stats_updates;
 	u64 netif_rx_schedule;
 	u64 netif_rx_complete;
diff -uprN a/drivers/scsi/bfa/include/cna/pstats/phyport_defs.h b/drivers/scsi/bfa/include/cna/pstats/phyport_defs.h
--- a/drivers/scsi/bfa/include/cna/pstats/phyport_defs.h	2009-12-18 18:16:22.072756000 -0800
+++ b/drivers/scsi/bfa/include/cna/pstats/phyport_defs.h	2009-11-25 18:23:57.000000000 -0800
@@ -20,199 +20,183 @@
 #define BNA_TXF_ID_MAX  	64
 #define BNA_RXF_ID_MAX  	64
 
-/*
- * Statistics
- */
-
-/*
- * TxF Frame Statistics
- */
+/* Statistics */
+
+/* TxF Frame Statistics */
 struct bna_stats_txf {
-	u64        ucast_octets;
-	u64        ucast;
-	u64        ucast_vlan;
-
-	u64        mcast_octets;
-	u64        mcast;
-	u64        mcast_vlan;
-
-	u64        bcast_octets;
-	u64        bcast;
-	u64        bcast_vlan;
-
-	u64        errors;
-	u64        filter_vlan;	/* frames filtered due to VLAN */
-	u64        filter_mac_sa;	/* frames filtered due to SA check */
-};
-
-/*
- * RxF Frame Statistics
- */
+	u64 ucast_octets;
+	u64 ucast;
+	u64 ucast_vlan;
+
+	u64 mcast_octets;
+	u64 mcast;
+	u64 mcast_vlan;
+
+	u64 bcast_octets;
+	u64 bcast;
+	u64 bcast_vlan;
+
+	u64 errors;
+	u64 filter_vlan;      /* frames filtered due to VLAN */
+	u64 filter_mac_sa;    /* frames filtered due to SA check */
+};
+
+
+/* RxF Frame Statistics */
 struct bna_stats_rxf {
-	u64        ucast_octets;
-	u64        ucast;
-	u64        ucast_vlan;
-
-	u64        mcast_octets;
-	u64        mcast;
-	u64        mcast_vlan;
-
-	u64        bcast_octets;
-	u64        bcast;
-	u64        bcast_vlan;
-	u64        frame_drops;
-};
-
-/*
- * FC Tx Frame Statistics
- */
+	u64 ucast_octets;
+	u64 ucast;
+	u64 ucast_vlan;
+
+	u64 mcast_octets;
+	u64 mcast;
+	u64 mcast_vlan;
+
+	u64 bcast_octets;
+	u64 bcast;
+	u64 bcast_vlan;
+	u64 frame_drops;
+};
+
+
+/* FC Tx Frame Statistics */
 struct bna_stats_fc_tx {
-	u64        txf_ucast_octets;
-	u64        txf_ucast;
-	u64        txf_ucast_vlan;
-
-	u64        txf_mcast_octets;
-	u64        txf_mcast;
-	u64        txf_mcast_vlan;
-
-	u64        txf_bcast_octets;
-	u64        txf_bcast;
-	u64        txf_bcast_vlan;
-
-	u64        txf_parity_errors;
-	u64        txf_timeout;
-	u64        txf_fid_parity_errors;
-};
-
-/*
- * FC Rx Frame Statistics
- */
+	u64 txf_ucast_octets;
+	u64 txf_ucast;
+	u64 txf_ucast_vlan;
+
+	u64 txf_mcast_octets;
+	u64 txf_mcast;
+	u64 txf_mcast_vlan;
+
+	u64 txf_bcast_octets;
+	u64 txf_bcast;
+	u64 txf_bcast_vlan;
+
+	u64 txf_parity_errors;
+	u64 txf_timeout;
+	u64 txf_fid_parity_errors;
+};
+
+
+/* FC Rx Frame Statistics */
 struct bna_stats_fc_rx {
-	u64        rxf_ucast_octets;
-	u64        rxf_ucast;
-	u64        rxf_ucast_vlan;
-
-	u64        rxf_mcast_octets;
-	u64        rxf_mcast;
-	u64        rxf_mcast_vlan;
-
-	u64        rxf_bcast_octets;
-	u64        rxf_bcast;
-	u64        rxf_bcast_vlan;
-};
-
-/*
- * RAD Frame Statistics
- */
+	u64 rxf_ucast_octets;
+	u64 rxf_ucast;
+	u64 rxf_ucast_vlan;
+
+	u64 rxf_mcast_octets;
+	u64 rxf_mcast;
+	u64 rxf_mcast_vlan;
+
+	u64 rxf_bcast_octets;
+	u64 rxf_bcast;
+	u64 rxf_bcast_vlan;
+};
+
+
+/* RAD Frame Statistics */
 struct cna_stats_rad {
-	u64        rx_frames;
-	u64        rx_octets;
-	u64        rx_vlan_frames;
+	u64 rx_frames;
+	u64 rx_octets;
+	u64 rx_vlan_frames;
 
-	u64        rx_ucast;
-	u64        rx_ucast_octets;
-	u64        rx_ucast_vlan;
+	u64 rx_ucast;
+	u64 rx_ucast_octets;
+	u64 rx_ucast_vlan;
 
-	u64        rx_mcast;
-	u64        rx_mcast_octets;
-	u64        rx_mcast_vlan;
+	u64 rx_mcast;
+	u64 rx_mcast_octets;
+	u64 rx_mcast_vlan;
 
-	u64        rx_bcast;
-	u64        rx_bcast_octets;
-	u64        rx_bcast_vlan;
+	u64 rx_bcast;
+	u64 rx_bcast_octets;
+	u64 rx_bcast_vlan;
 
-	u64        rx_drops;
+	u64 rx_drops;
 };
 
-/*
- * BPC Tx Registers
- */
+
+/* BPC Tx Registers */
 struct cna_stats_bpc_tx {
-	u64        tx_pause[8];
-	u64        tx_zero_pause[8];	/*  Pause cancellation */
-	u64        tx_first_pause[8];	/*  Pause initiation rather
-						 *than retention */
+	u64 tx_pause[8];
+	u64 tx_zero_pause[8]; /*  Pause cancellation */
+	u64 tx_first_pause[8];/*  Pause initiation rather than retention*/
 };
 
-/*
- * BPC Rx Registers
- */
+
+/* BPC Rx Registers */
 struct cna_stats_bpc_rx {
-	u64        rx_pause[8];
-	u64        rx_zero_pause[8];	/*  Pause cancellation */
-	u64        rx_first_pause[8];	/*  Pause initiation rather
-						 *than retention */
+	u64 rx_pause[8];
+	u64 rx_zero_pause[8]; /*  Pause cancellation */
+	u64 rx_first_pause[8];/*  Pause initiation rather than retention*/
 };
 
-/*
- * MAC Rx Statistics
- */
+
+/* MAC Rx Statistics */
 struct cna_stats_mac_rx {
-	u64        frame_64;	/* both rx and tx counter */
-	u64        frame_65_127;	/* both rx and tx counter */
-	u64        frame_128_255;	/* both rx and tx counter */
-	u64        frame_256_511;	/* both rx and tx counter */
-	u64        frame_512_1023;	/* both rx and tx counter */
-	u64        frame_1024_1518;	/* both rx and tx counter */
-	u64        frame_1518_1522;	/* both rx and tx counter */
-	u64        rx_bytes;
-	u64        rx_packets;
-	u64        rx_fcs_error;
-	u64        rx_multicast;
-	u64        rx_broadcast;
-	u64        rx_control_frames;
-	u64        rx_pause;
-	u64        rx_unknown_opcode;
-	u64        rx_alignment_error;
-	u64        rx_frame_length_error;
-	u64        rx_code_error;
-	u64        rx_carrier_sense_error;
-	u64        rx_undersize;
-	u64        rx_oversize;
-	u64        rx_fragments;
-	u64        rx_jabber;
-	u64        rx_drop;
-};
-
-/*
- * MAC Tx Statistics
- */
+	u64 frame_64;		/* both rx and tx counter */
+	u64 frame_65_127;		/* both rx and tx counter */
+	u64 frame_128_255;		/* both rx and tx counter */
+	u64 frame_256_511;		/* both rx and tx counter */
+	u64 frame_512_1023;	/* both rx and tx counter */
+	u64 frame_1024_1518;	/* both rx and tx counter */
+	u64 frame_1518_1522;	/* both rx and tx counter */
+	u64 rx_bytes;
+	u64 rx_packets;
+	u64 rx_fcs_error;
+	u64 rx_multicast;
+	u64 rx_broadcast;
+	u64 rx_control_frames;
+	u64 rx_pause;
+	u64 rx_unknown_opcode;
+	u64 rx_alignment_error;
+	u64 rx_frame_length_error;
+	u64 rx_code_error;
+	u64 rx_carrier_sense_error;
+	u64 rx_undersize;
+	u64 rx_oversize;
+	u64 rx_fragments;
+	u64 rx_jabber;
+	u64 rx_drop;
+};
+
+
+/* MAC Tx Statistics */
 struct cna_stats_mac_tx {
-	u64        tx_bytes;
-	u64        tx_packets;
-	u64        tx_multicast;
-	u64        tx_broadcast;
-	u64        tx_pause;
-	u64        tx_deferral;
-	u64        tx_excessive_deferral;
-	u64        tx_single_collision;
-	u64        tx_muliple_collision;
-	u64        tx_late_collision;
-	u64        tx_excessive_collision;
-	u64        tx_total_collision;
-	u64        tx_pause_honored;
-	u64        tx_drop;
-	u64        tx_jabber;
-	u64        tx_fcs_error;
-	u64        tx_control_frame;
-	u64        tx_oversize;
-	u64        tx_undersize;
-	u64        tx_fragments;
-};
-
-/*
- * Complete statistics
- */
+	u64 tx_bytes;
+	u64 tx_packets;
+	u64 tx_multicast;
+	u64 tx_broadcast;
+	u64 tx_pause;
+	u64 tx_deferral;
+	u64 tx_excessive_deferral;
+	u64 tx_single_collision;
+	u64 tx_muliple_collision;
+	u64 tx_late_collision;
+	u64 tx_excessive_collision;
+	u64 tx_total_collision;
+	u64 tx_pause_honored;
+	u64 tx_drop;
+	u64 tx_jabber;
+	u64 tx_fcs_error;
+	u64 tx_control_frame;
+	u64 tx_oversize;
+	u64 tx_undersize;
+	u64 tx_fragments;
+};
+
+/* Complete statistics */
 struct bna_stats {
-	struct cna_stats_mac_rx mac_rx_stats;
-	struct cna_stats_bpc_rx bpc_rx_stats;
-	struct cna_stats_rad rad_stats;
-	struct bna_stats_fc_rx fc_rx_stats;
-	struct cna_stats_mac_tx mac_tx_stats;
-	struct cna_stats_bpc_tx bpc_tx_stats;
-	struct bna_stats_fc_tx fc_tx_stats;
-	struct bna_stats_rxf rxf_stats[BNA_TXF_ID_MAX];
-	struct bna_stats_txf txf_stats[BNA_RXF_ID_MAX];
+	struct cna_stats_mac_rx	mac_rx_stats;
+	struct cna_stats_bpc_rx	bpc_rx_stats;
+	struct cna_stats_rad	rad_stats;
+	struct bna_stats_fc_rx	fc_rx_stats;
+	struct cna_stats_mac_tx	mac_tx_stats;
+	struct cna_stats_bpc_tx	bpc_tx_stats;
+	struct bna_stats_fc_tx	fc_tx_stats;
+	struct bna_stats_rxf	rxf_stats[BNA_TXF_ID_MAX];
+	struct bna_stats_txf	txf_stats[BNA_RXF_ID_MAX];
 };
 
 #endif
diff -uprN a/drivers/scsi/bfa/include/cs/bfa_checksum.h b/drivers/scsi/bfa/include/cs/bfa_checksum.h
--- a/drivers/scsi/bfa/include/cs/bfa_checksum.h	2009-12-18 18:16:22.104762000 -0800
+++ b/drivers/scsi/bfa/include/cs/bfa_checksum.h	2009-11-25 18:23:57.000000000 -0800
@@ -31,7 +31,7 @@ bfa_checksum_u32(u32 *buf, int sz)
 	for (i = 0; i < m; i++)
 		sum ^= buf[i];
 
-	return (sum);
+	return sum;
 }
 
 static inline u16
@@ -43,7 +43,7 @@ bfa_checksum_u16(u16 *buf, int sz)
 	for (i = 0; i < m; i++)
 		sum ^= buf[i];
 
-	return (sum);
+	return sum;
 }
 
 static inline u8
@@ -55,6 +55,6 @@ bfa_checksum_u8(u8 *buf, int sz)
 	for (i = 0; i < sz; i++)
 		sum ^= buf[i];
 
-	return (sum);
+	return sum;
 }
 #endif
diff -uprN a/drivers/scsi/bfa/include/cs/bfa_log.h b/drivers/scsi/bfa/include/cs/bfa_log.h
--- a/drivers/scsi/bfa/include/cs/bfa_log.h	2009-12-18 18:16:22.100757000 -0800
+++ b/drivers/scsi/bfa/include/cs/bfa_log.h	2009-11-25 18:23:57.000000000 -0800
@@ -157,7 +157,7 @@ typedef void (*bfa_log_cb_t)(struct bfa_
 
 
 struct bfa_log_mod_s {
-	char		instance_info[16];	/*  instance info */
+	char		instance_info[BFA_STRING_32];	/*  instance info */
 	int		log_level[BFA_LOG_MODULE_ID_MAX + 1];
 						/*  log level for modules */
 	bfa_log_cb_t	cbfn; 			/*  callback function */
diff -uprN a/drivers/scsi/bfa/include/cs/bfa_plog.h b/drivers/scsi/bfa/include/cs/bfa_plog.h
--- a/drivers/scsi/bfa/include/cs/bfa_plog.h	2009-12-18 18:16:22.096761000 -0800
+++ b/drivers/scsi/bfa/include/cs/bfa_plog.h	2009-11-25 18:23:57.000000000 -0800
@@ -80,7 +80,8 @@ enum bfa_plog_mid {
 	BFA_PL_MID_HAL_FCXP 	= 4,
 	BFA_PL_MID_HAL_UF 	= 5,
 	BFA_PL_MID_FCS 		= 6,
-	BFA_PL_MID_MAX 		= 7
+	BFA_PL_MID_LPS		= 7,
+	BFA_PL_MID_MAX 		= 8
 };
 
 #define BFA_PL_MID_STRLEN    8
@@ -118,7 +119,11 @@ enum bfa_plog_eid {
 	BFA_PL_EID_RSCN 		= 17,
 	BFA_PL_EID_DEBUG 		= 18,
 	BFA_PL_EID_MISC 		= 19,
-	BFA_PL_EID_MAX 			= 20
+	BFA_PL_EID_FIP_FCF_DISC		= 20,
+	BFA_PL_EID_FIP_FCF_CVL		= 21,
+	BFA_PL_EID_LOGIN		= 22,
+	BFA_PL_EID_LOGO			= 23,
+	BFA_PL_EID_MAX 			= 24
 };
 
 #define BFA_PL_ENAME_STRLEN    	8
diff -uprN a/drivers/scsi/bfa/include/cs/bfa_sm.h b/drivers/scsi/bfa/include/cs/bfa_sm.h
--- a/drivers/scsi/bfa/include/cs/bfa_sm.h	2009-12-18 18:16:22.093758000 -0800
+++ b/drivers/scsi/bfa/include/cs/bfa_sm.h	2009-11-25 18:23:57.000000000 -0800
@@ -24,8 +24,17 @@
 
 typedef void (*bfa_sm_t)(void *sm, int event);
 
-#define bfa_sm_set_state(_sm, _state)	(_sm)->sm = (bfa_sm_t)(_state)
-#define bfa_sm_send_event(_sm, _event)	(_sm)->sm((_sm), (_event))
+/**
+ * oc - object class eg. bfa_ioc
+ * st - state, eg. reset
+ * otype - object type, eg. struct bfa_ioc_s
+ * etype - object type, eg. enum ioc_event
+ */
+#define bfa_sm_state_decl(oc, st, otype, etype)		\
+	static void oc ## _sm_ ## st(otype * fsm, etype event)
+
+#define bfa_sm_set_state(_sm, _state)	((_sm)->sm = (bfa_sm_t)(_state))
+#define bfa_sm_send_event(_sm, _event)	((_sm)->sm((_sm), (_event)))
 #define bfa_sm_get_state(_sm)		((_sm)->sm)
 #define bfa_sm_cmp_state(_sm, _state)	((_sm)->sm == (bfa_sm_t)(_state))
 
@@ -62,7 +71,7 @@ typedef void (*bfa_fsm_t)(void *fsm, int
 } while (0)
 
 #define bfa_fsm_send_event(_fsm, _event)	\
-	(_fsm)->fsm((_fsm), (_event))
+	((_fsm)->fsm((_fsm), (_event)))
 #define bfa_fsm_cmp_state(_fsm, _state)		\
 	((_fsm)->fsm == (bfa_fsm_t)(_state))
 
diff -uprN a/drivers/scsi/bfa/include/cs/bfa_trc.h b/drivers/scsi/bfa/include/cs/bfa_trc.h
--- a/drivers/scsi/bfa/include/cs/bfa_trc.h	2009-12-18 18:16:22.091759000 -0800
+++ b/drivers/scsi/bfa/include/cs/bfa_trc.h	2009-11-25 18:23:57.000000000 -0800
@@ -24,7 +24,7 @@
 #endif
 
 #ifndef BFA_TRC_TS
-#define BFA_TRC_TS(_trcm)	((_trcm)->ticks ++)
+#define BFA_TRC_TS(_trcm)	((_trcm)->ticks++)
 #endif
 
 struct bfa_trc_s {
diff -uprN a/drivers/scsi/bfa/include/defs/bfa_defs_aen.h b/drivers/scsi/bfa/include/defs/bfa_defs_aen.h
--- a/drivers/scsi/bfa/include/defs/bfa_defs_aen.h	2009-12-18 18:16:22.168756000 -0800
+++ b/drivers/scsi/bfa/include/defs/bfa_defs_aen.h	2009-11-25 18:23:57.000000000 -0800
@@ -30,6 +30,16 @@
 #include <defs/bfa_defs_audit.h>
 #include <defs/bfa_defs_ethport.h>
 
+#define BFA_AEN_MAX_APP         5
+
+enum bfa_aen_app {
+	bfa_aen_app_bcu = 0,	/* No thread for bcu */
+	bfa_aen_app_hcm = 1,
+	bfa_aen_app_cim = 2,
+	bfa_aen_app_snia = 3,
+	bfa_aen_app_test = 4,	/* To be removed after unit test */
+};
+
 enum bfa_aen_category {
 	BFA_AEN_CAT_ADAPTER 	= 1,
 	BFA_AEN_CAT_PORT 	= 2,
diff -uprN a/drivers/scsi/bfa/include/defs/bfa_defs_auth.h b/drivers/scsi/bfa/include/defs/bfa_defs_auth.h
--- a/drivers/scsi/bfa/include/defs/bfa_defs_auth.h	2009-12-18 18:16:22.164759000 -0800
+++ b/drivers/scsi/bfa/include/defs/bfa_defs_auth.h	2009-11-25 18:23:57.000000000 -0800
@@ -23,6 +23,7 @@
 #define PRIVATE_KEY			19009
 #define KEY_LEN				32399
 #define BFA_AUTH_SECRET_STRING_LEN	256
+#define BFA_AUTH_FAIL_NO_PASSWORD	0xFE
 #define BFA_AUTH_FAIL_TIMEOUT		0xFF
 
 /**
@@ -41,6 +42,27 @@ enum bfa_auth_status {
 	BFA_AUTH_STATUS_UNKNOWN = 9,	/*  authentication status unknown */
 };
 
+enum bfa_auth_rej_code {
+	BFA_AUTH_RJT_CODE_AUTH_FAILURE   = 1, /* auth failure */
+	BFA_AUTH_RJT_CODE_LOGICAL_ERR    = 2, /* logical error */
+};
+
+/**
+ * Authentication reject codes
+ */
+enum bfa_auth_rej_code_exp {
+	BFA_AUTH_MECH_NOT_USABLE	= 1, /* auth. mechanism not usable */
+	BFA_AUTH_DH_GROUP_NOT_USABLE	= 2, /* DH Group not usable */
+	BFA_AUTH_HASH_FUNC_NOT_USABLE	= 3, /* hash Function not usable */
+	BFA_AUTH_AUTH_XACT_STARTED	= 4, /* auth xact started */
+	BFA_AUTH_AUTH_FAILED		= 5, /* auth failed */
+	BFA_AUTH_INCORRECT_PLD		= 6, /* incorrect payload */
+	BFA_AUTH_INCORRECT_PROTO_MSG	= 7, /* incorrect proto msg */
+	BFA_AUTH_RESTART_AUTH_PROTO	= 8, /* restart auth protocol */
+	BFA_AUTH_AUTH_CONCAT_NOT_SUPP	= 9, /* auth concat not supported */
+	BFA_AUTH_PROTO_VER_NOT_SUPP	= 10,/* proto version not supported */
+};
+
 struct auth_proto_stats_s {
 	u32        auth_rjts;
 	u32        auth_negs;
diff -uprN a/drivers/scsi/bfa/include/defs/bfa_defs_cee.h b/drivers/scsi/bfa/include/defs/bfa_defs_cee.h
--- a/drivers/scsi/bfa/include/defs/bfa_defs_cee.h	2009-12-18 18:16:22.161756000 -0800
+++ b/drivers/scsi/bfa/include/defs/bfa_defs_cee.h	2009-11-25 18:23:57.000000000 -0800
@@ -28,10 +28,6 @@
 
 #define BFA_CEE_LLDP_MAX_STRING_LEN (128)
 
-
-/* FIXME: this is coming from the protocol spec. Can the host & apps share the
-   protocol .h files ?
- */
 #define BFA_CEE_LLDP_SYS_CAP_OTHER       0x0001
 #define BFA_CEE_LLDP_SYS_CAP_REPEATER    0x0002
 #define BFA_CEE_LLDP_SYS_CAP_MAC_BRIDGE  0x0004
@@ -40,9 +36,9 @@
 #define BFA_CEE_LLDP_SYS_CAP_TELEPHONE 	 0x0020
 #define BFA_CEE_LLDP_SYS_CAP_DOCSIS_CD   0x0040
 #define BFA_CEE_LLDP_SYS_CAP_STATION     0x0080
-#define BFA_CEE_LLDP_SYS_CAP_CVLAN	     0x0100
-#define BFA_CEE_LLDP_SYS_CAP_SVLAN 	     0x0200
-#define BFA_CEE_LLDP_SYS_CAP_TPMR		 0x0400
+#define BFA_CEE_LLDP_SYS_CAP_CVLAN	 0x0100
+#define BFA_CEE_LLDP_SYS_CAP_SVLAN	 0x0200
+#define BFA_CEE_LLDP_SYS_CAP_TPMR	 0x0400
 
 
 /* LLDP string type */
@@ -72,8 +68,7 @@ enum bfa_cee_dcbx_version_e {
 };
 
 enum bfa_cee_lls_e {
-	CEE_LLS_DOWN_NO_TLV = 0, /* LLS is down because the TLV not sent by
-				  * the peer */
+	CEE_LLS_DOWN_NO_TLV = 0, /* LLS is down bcoz TLV not sent by the peer */
 	CEE_LLS_DOWN        = 1, /* LLS is down as advertised by the peer */
 	CEE_LLS_UP          = 2,
 };
@@ -83,20 +78,20 @@ struct bfa_cee_dcbx_cfg_s {
 	u8 pgid[8];
 	u8 pg_percentage[8];
 	u8 pfc_enabled;          /* bitmap of priorties with PFC enabled */
-	u8 fcoe_user_priority;   /* bitmap of priorities used for FcoE
-				       * traffic */
-	u8 dcbx_version;	/* operating version:CEE or preCEE */
-	u8 lls_fcoe;	/* FCoE Logical Link Status */
-	u8 lls_lan;	/* LAN Logical Link Status */
+	u8 fcoe_user_priority;  /* bitmap of priorities for FcoE traffic */
+	u8 dcbx_version;		  /* operating version:CEE or preCEE */
+	u8 lls_fcoe;			  /* FCoE Logical Link Status */
+	u8 lls_lan;			  /* LAN Logical Link Status */
 	u8 rsvd[3];
 };
 
 /* CEE status */
 /* Making this to tri-state for the benefit of port list command */
 enum bfa_cee_status_e {
-    CEE_PHY_DOWN = 0,
+    CEE_UP = 0,
     CEE_PHY_UP = 1,
-    CEE_UP = 2,
+	CEE_LOOPBACK = 2,
+    CEE_PHY_DOWN = 3,
 };
 
 /* CEE Query */
@@ -105,9 +100,10 @@ struct bfa_cee_attr_s {
 	u8                   error_reason;
 	struct bfa_cee_lldp_cfg_s lldp_remote;
 	struct bfa_cee_dcbx_cfg_s dcbx_remote;
-	mac_t src_mac;
+	struct mac_s src_mac;
 	u8 link_speed;
-	u8 filler[3];
+	u8 nw_priority;
+	u8 filler[2];
 };
 
 
diff -uprN a/drivers/scsi/bfa/include/defs/bfa_defs_driver.h b/drivers/scsi/bfa/include/defs/bfa_defs_driver.h
--- a/drivers/scsi/bfa/include/defs/bfa_defs_driver.h	2009-12-18 18:16:22.159756000 -0800
+++ b/drivers/scsi/bfa/include/defs/bfa_defs_driver.h	2009-11-25 18:23:57.000000000 -0800
@@ -34,6 +34,10 @@
     u64    output_req;
     u64    input_words;
     u64    output_words;
+	u16	link_up;
+	u16	link_down;
+	u16	bootlun_online;
+	u16	bootlun_offline;
 } bfa_driver_stats_t;
 
 
diff -uprN a/drivers/scsi/bfa/include/defs/bfa_defs_ethport.h b/drivers/scsi/bfa/include/defs/bfa_defs_ethport.h
--- a/drivers/scsi/bfa/include/defs/bfa_defs_ethport.h	2009-12-18 18:16:22.157758000 -0800
+++ b/drivers/scsi/bfa/include/defs/bfa_defs_ethport.h	2009-11-25 18:23:57.000000000 -0800
@@ -19,6 +19,7 @@
 #define __BFA_DEFS_ETHPORT_H__
 
 #include <defs/bfa_defs_status.h>
+#include <defs/bfa_defs_port.h>
 #include <protocol/types.h>
 #include <cna/pstats/phyport_defs.h>
 #include <cna/pstats/ethport_defs.h>
@@ -86,13 +87,21 @@ enum bfa_ethport_aen_event {
 	BFA_ETHPORT_AEN_LINKUP = 1, /*  Base Port Ethernet link up event */
 	BFA_ETHPORT_AEN_LINKDOWN = 2, /*  Base Port Ethernet link down event */
 	BFA_ETHPORT_AEN_ENABLE = 3, /*  Base Port Ethernet link enable event */
-	BFA_ETHPORT_AEN_DISABLE = 4, /*  Base Port Ethernet link disable
-				      * event */
+	BFA_ETHPORT_AEN_DISABLE = 4,/*  Base Port Ethernet link disable event*/
 };
 
 struct bfa_ethport_aen_data_s {
-	mac_t mac;	/*  MAC address of the physical port */
+	struct mac_s mac;	/*  MAC address of the physical port */
 };
 
+/**
+ * 		Ethernet port attribute values.
+ */
+struct bfa_ethport_attr_s {
+	u32 mtu; /*  maximum transfer unit */
+	enum bfa_pport_speed speed_supported; /*  supported speeds */
+	enum bfa_pport_states port_state; /*  current port state */
+	enum bfa_pport_speed speed; /*  current speed */
+};
 
 #endif /* __BFA_DEFS_ETHPORT_H__ */
diff -uprN a/drivers/scsi/bfa/include/defs/bfa_defs_fcport.h b/drivers/scsi/bfa/include/defs/bfa_defs_fcport.h
--- a/drivers/scsi/bfa/include/defs/bfa_defs_fcport.h	1969-12-31 16:00:00.000000000 -0800
+++ b/drivers/scsi/bfa/include/defs/bfa_defs_fcport.h	2009-11-25 18:23:57.000000000 -0800
@@ -0,0 +1,94 @@
+/*
+ * Copyright (c) 2005-2009 Brocade Communications Systems, Inc.
+ * All rights reserved
+ * www.brocade.com
+ *
+ *  bfa_defs_fcport.h
+ *
+ * Linux driver for Brocade Fibre Channel Host Bus Adapter.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License (GPL) Version 2 as
+ * published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+#ifndef __BFA_DEFS_FCPORT_H__
+#define __BFA_DEFS_FCPORT_H__
+
+#include <defs/bfa_defs_types.h>
+#include <protocol/types.h>
+
+#pragma pack(1)
+
+/**
+ * FCoE statistics
+ */
+struct bfa_fcoe_stats_s {
+	u64	secs_reset;	/*  Seconds since stats reset	     */
+	u64	cee_linkups;	/*  CEE link up		     */
+	u64	cee_linkdns;	/*  CEE link down		     */
+	u64	fip_linkups;	/*  FIP link up		     */
+	u64	fip_linkdns;	/*  FIP link down		     */
+	u64	fip_fails;	/*  FIP failures		     */
+	u64	mac_invalids;	/*  Invalid mac assignments	     */
+	u64	vlan_req;	/*  Vlan requests		     */
+	u64	vlan_notify;	/*  Vlan notifications		     */
+	u64	vlan_err;	/*  Vlan notification errors	     */
+	u64	vlan_timeouts;	/*  Vlan request timeouts	     */
+	u64	vlan_invalids;	/*  Vlan invalids		     */
+	u64	disc_req;	/*  Discovery requests		     */
+	u64	disc_rsp;	/*  Discovery responses	     */
+	u64	disc_err;	/*  Discovery error frames	     */
+	u64	disc_unsol;	/*  Discovery unsolicited	     */
+	u64	disc_timeouts;	/*  Discovery timeouts		     */
+	u64	disc_fcf_unavail; /*  Discovery FCF not avail	     */
+	u64	linksvc_unsupp;	/*  FIP link service req unsupp.    */
+	u64	linksvc_err;	/*  FIP link service req errors     */
+	u64	logo_req;	/*  FIP logo			     */
+	u64	clrvlink_req;	/*  Clear virtual link requests     */
+	u64	op_unsupp;	/*  FIP operation unsupp.	     */
+	u64	untagged;	/*  FIP untagged frames	     */
+	u64	txf_ucast;	/*  Tx FCoE unicast frames	     */
+	u64	txf_ucast_vlan;	/*  Tx FCoE unicast vlan frames     */
+	u64	txf_ucast_octets; /*  Tx FCoE unicast octets	     */
+	u64	txf_mcast;	/*  Tx FCoE mutlicast frames	     */
+	u64	txf_mcast_vlan;	/*  Tx FCoE mutlicast vlan frames   */
+	u64	txf_mcast_octets; /*  Tx FCoE multicast octets	     */
+	u64	txf_bcast;	/*  Tx FCoE broadcast frames	     */
+	u64	txf_bcast_vlan;	/*  Tx FCoE broadcast vlan frames   */
+	u64	txf_bcast_octets; /*  Tx FCoE broadcast octets	     */
+	u64	txf_timeout;	/*  Tx timeouts		     */
+	u64	txf_parity_errors; /*  Transmit parity err	     */
+	u64	txf_fid_parity_errors; /*  Transmit FID parity err  */
+	u64	tx_pause;	/*  Tx pause frames		     */
+	u64	tx_zero_pause;	/*  Tx zero pause frames	     */
+	u64	tx_first_pause;	/*  Tx first pause frames	     */
+	u64	rx_pause;	/*  Rx pause frames		     */
+	u64	rx_zero_pause;	/*  Rx zero pause frames	     */
+	u64	rx_first_pause;	/*  Rx first pause frames	     */
+	u64	rxf_ucast_octets; /*  Rx unicast octets	     */
+	u64	rxf_ucast;	/*  Rx unicast frames		     */
+	u64	rxf_ucast_vlan;	/*  Rx unicast vlan frames	     */
+	u64	rxf_mcast_octets; /*  Rx multicast octets	     */
+	u64	rxf_mcast;	/*  Rx multicast frames	     */
+	u64	rxf_mcast_vlan;	/*  Rx multicast vlan frames	     */
+	u64	rxf_bcast_octets; /*  Rx broadcast octests	     */
+	u64	rxf_bcast;	/*  Rx broadcast frames	     */
+	u64	rxf_bcast_vlan;	/*  Rx broadcast vlan frames	     */
+};
+
+/**
+ * QoS or FCoE stats (fcport stats excluding physical FC port stats)
+ */
+union bfa_fcport_stats_u {
+	struct bfa_qos_stats_s	fcqos;
+	struct bfa_fcoe_stats_s	fcoe;
+};
+
+#pragma pack()
+
+#endif  /* __BFA_DEFS_FCPORT_H__ */
diff -uprN a/drivers/scsi/bfa/include/defs/bfa_defs_im_common.h b/drivers/scsi/bfa/include/defs/bfa_defs_im_common.h
--- a/drivers/scsi/bfa/include/defs/bfa_defs_im_common.h	2009-12-18 18:16:22.154756000 -0800
+++ b/drivers/scsi/bfa/include/defs/bfa_defs_im_common.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,32 +0,0 @@
-/*
- * Copyright (c) 2005-2009 Brocade Communications Systems, Inc.
- * All rights reserved
- * www.brocade.com
- *
- * Linux driver for Brocade Fibre Channel Host Bus Adapter.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License (GPL) Version 2 as
- * published by the Free Software Foundation
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- */
-
-#ifndef __BFA_DEFS_IM_COMMON_H__
-#define __BFA_DEFS_IM_COMMON_H__
-
-#define	BFA_ADAPTER_NAME_LEN	256
-#define BFA_ADAPTER_GUID_LEN    256
-#define RESERVED_VLAN_NAME      L"PORT VLAN"
-#define PASSTHRU_VLAN_NAME      L"PASSTHRU VLAN"
-
-	u64	tx_pkt_cnt;
-	u64	rx_pkt_cnt;
-	u32	duration;
-	u8		status;
-} bfa_im_stats_t, *pbfa_im_stats_t;
-
-#endif /* __BFA_DEFS_IM_COMMON_H__ */
diff -uprN a/drivers/scsi/bfa/include/defs/bfa_defs_im_team.h b/drivers/scsi/bfa/include/defs/bfa_defs_im_team.h
--- a/drivers/scsi/bfa/include/defs/bfa_defs_im_team.h	2009-12-18 18:16:22.152756000 -0800
+++ b/drivers/scsi/bfa/include/defs/bfa_defs_im_team.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,72 +0,0 @@
-/*
- * Copyright (c) 2005-2009 Brocade Communications Systems, Inc.
- * All rights reserved
- * www.brocade.com
- *
- * Linux driver for Brocade Fibre Channel Host Bus Adapter.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License (GPL) Version 2 as
- * published by the Free Software Foundation
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- */
-
-#ifndef __BFA_DEFS_IM_TEAM_H__
-#define __BFA_DEFS_IM_TEAM_H__
-
-#include <protocol/types.h>
-
-#define	BFA_TEAM_MAX_PORTS	8
-#define	BFA_TEAM_NAME_LEN	256
-#define BFA_MAX_NUM_TEAMS	16
-#define BFA_TEAM_INVALID_DELAY -1
-
-	BFA_LACP_RATE_SLOW = 1,
-	BFA_LACP_RATE_FAST
-} bfa_im_lacp_rate_t;
-
-	BFA_TEAM_MODE_FAIL_OVER = 1,
-	BFA_TEAM_MODE_FAIL_BACK,
-	BFA_TEAM_MODE_LACP,
-	BFA_TEAM_MODE_NONE
-} bfa_im_team_mode_t;
-
-	BFA_XMIT_POLICY_L2 = 1,
-	BFA_XMIT_POLICY_L3_L4
-} bfa_im_xmit_policy_t;
-
-	bfa_im_team_mode_t     team_mode;
-	bfa_im_lacp_rate_t     lacp_rate;
-	bfa_im_xmit_policy_t   xmit_policy;
-	int   	          delay;
-	wchar_t    	  primary[BFA_ADAPTER_NAME_LEN];
-	wchar_t        	  preferred_primary[BFA_ADAPTER_NAME_LEN];
-	mac_t	          mac;
-	u16       	  num_ports;
-	u16          num_vlans;
-	u16 vlan_list[BFA_MAX_VLANS_PER_PORT];
-	wchar_t	 team_guid_list[BFA_TEAM_MAX_PORTS][BFA_ADAPTER_GUID_LEN];
-	wchar_t	 ioc_name_list[BFA_TEAM_MAX_PORTS][BFA_ADAPTER_NAME_LEN];
-} bfa_im_team_attr_t;
-
-	wchar_t		             team_name[BFA_TEAM_NAME_LEN];
-	bfa_im_xmit_policy_t	 xmit_policy;
-	int                 	 delay;
-	wchar_t                	 primary[BFA_ADAPTER_NAME_LEN];
-	wchar_t               	 preferred_primary[BFA_ADAPTER_NAME_LEN];
-} bfa_im_team_edit_t, *pbfa_im_team_edit_t;
-
-	wchar_t					team_name[BFA_TEAM_NAME_LEN];
-	bfa_im_team_mode_t      team_mode;
-	mac_t	               	mac;
-} bfa_im_team_info_t;
-
-	bfa_im_team_info_t 		team_info[BFA_MAX_NUM_TEAMS];
-	u16 				num_teams;
-} bfa_im_team_list_t, *pbfa_im_team_list_t;
-
-#endif /* __BFA_DEFS_IM_TEAM_H__ */
diff -uprN a/drivers/scsi/bfa/include/defs/bfa_defs_ioc.h b/drivers/scsi/bfa/include/defs/bfa_defs_ioc.h
--- a/drivers/scsi/bfa/include/defs/bfa_defs_ioc.h	2009-12-18 18:16:22.150758000 -0800
+++ b/drivers/scsi/bfa/include/defs/bfa_defs_ioc.h	2009-11-25 18:23:57.000000000 -0800
@@ -126,6 +126,7 @@ struct bfa_ioc_attr_s {
 	struct bfa_ioc_driver_attr_s 	driver_attr;	/*  driver attr    */
 	struct bfa_ioc_pci_attr_s	pci_attr;
 	u8				port_id;	/*  port number    */
+	u8				rsvd[7];	/*  64bit align    */
 };
 
 /**
@@ -143,9 +144,9 @@ enum bfa_ioc_aen_event {
  * BFA IOC level event data, now just a place holder
  */
 struct bfa_ioc_aen_data_s {
-	enum bfa_ioc_type_e ioc_type;
 	wwn_t	pwwn;
-	mac_t	mac;
+	s16 ioc_type;
+	struct mac_s	mac;
 };
 
 #endif /* __BFA_DEFS_IOC_H__ */
diff -uprN a/drivers/scsi/bfa/include/defs/bfa_defs_iocfc.h b/drivers/scsi/bfa/include/defs/bfa_defs_iocfc.h
--- a/drivers/scsi/bfa/include/defs/bfa_defs_iocfc.h	2009-12-18 18:16:22.148758000 -0800
+++ b/drivers/scsi/bfa/include/defs/bfa_defs_iocfc.h	2009-11-25 18:23:57.000000000 -0800
@@ -26,6 +26,8 @@
 
 #define BFA_IOCFC_INTR_DELAY	1125
 #define BFA_IOCFC_INTR_LATENCY	225
+#define BFA_IOCFCOE_INTR_DELAY	25
+#define BFA_IOCFCOE_INTR_LATENCY 5
 
 /**
  * Interrupt coalescing configuration.
@@ -50,7 +52,7 @@ struct bfa_iocfc_fwcfg_s {
 	u16        num_fcxp_reqs;	/*  unassisted FC exchanges	*/
 	u16        num_uf_bufs;	/*  unsolicited recv buffers	*/
 	u8		num_cqs;
-	u8		rsvd;
+	u8		rsvd[5];
 };
 
 struct bfa_iocfc_drvcfg_s {
@@ -224,18 +226,24 @@ struct bfa_fw_port_physm_stats_s {
 
 
 struct bfa_fw_fip_stats_s {
+    u32    vlan_req;           /*  vlan discovery requests             */
+    u32    vlan_notify;        /*  vlan notifications                  */
+    u32    vlan_err;           /*  vlan response error                 */
+    u32    vlan_timeouts;      /*  vlan disvoery timeouts              */
+    u32    vlan_invalids;      /*  invalid vlan in discovery advert.   */
     u32    disc_req;           /*  Discovery solicit requests          */
     u32    disc_rsp;           /*  Discovery solicit response          */
     u32    disc_err;           /*  Discovery advt. parse errors        */
     u32    disc_unsol;         /*  Discovery unsolicited               */
     u32    disc_timeouts;      /*  Discovery timeouts                  */
+    u32    disc_fcf_unavail;   /*  Discovery FCF Not Avail.            */
     u32    linksvc_unsupp;     /*  Unsupported link service req        */
     u32    linksvc_err;        /*  Parse error in link service req     */
     u32    logo_req;           /*  Number of FIP logos received        */
     u32    clrvlink_req;       /*  Clear virtual link req              */
     u32    op_unsupp;          /*  Unsupported FIP operation           */
     u32    untagged;           /*  Untagged frames (ignored)           */
-    u32    rsvd;
+    u32    invalid_version;    /*  Invalid FIP version                 */
 };
 
 
diff -uprN a/drivers/scsi/bfa/include/defs/bfa_defs_lport.h b/drivers/scsi/bfa/include/defs/bfa_defs_lport.h
--- a/drivers/scsi/bfa/include/defs/bfa_defs_lport.h	2009-12-18 18:16:22.141761000 -0800
+++ b/drivers/scsi/bfa/include/defs/bfa_defs_lport.h	2009-11-25 18:23:57.000000000 -0800
@@ -59,8 +59,8 @@ enum bfa_lport_aen_event {
  */
 struct bfa_lport_aen_data_s {
 	u16        vf_id;	/*  vf_id of this logical port */
-	u16        rsvd;
-	enum bfa_port_role roles;	/*  Logical port mode,IM/TM/IP etc */
+	s16         roles;	/*  Logical port mode,IM/TM/IP etc */
+	u32        rsvd;
 	wwn_t           ppwwn;	/*  WWN of its physical port */
 	wwn_t           lpwwn;	/*  WWN of this logical port */
 };
diff -uprN a/drivers/scsi/bfa/include/defs/bfa_defs_mfg.h b/drivers/scsi/bfa/include/defs/bfa_defs_mfg.h
--- a/drivers/scsi/bfa/include/defs/bfa_defs_mfg.h	2009-12-18 18:16:22.140755000 -0800
+++ b/drivers/scsi/bfa/include/defs/bfa_defs_mfg.h	2009-11-25 18:23:57.000000000 -0800
@@ -22,7 +22,47 @@
 /**
  * Manufacturing block version
  */
-#define BFA_MFG_VERSION				1
+#define BFA_MFG_VERSION				2
+
+/**
+ * Manufacturing block encrypted version
+ */
+#define BFA_MFG_ENC_VER				2
+
+/**
+ * Manufacturing block version 1 length
+ */
+#define BFA_MFG_VER1_LEN			128
+
+/**
+ * Manufacturing block header length
+ */
+#define BFA_MFG_HDR_LEN				4
+
+/**
+ * Checksum size
+ */
+#define BFA_MFG_CHKSUM_SIZE			16
+
+/**
+ * Manufacturing block encrypted version
+ */
+#define BFA_MFG_ENC_VER				2
+
+/**
+ * Manufacturing block version 1 length
+ */
+#define BFA_MFG_VER1_LEN			128
+
+/**
+ * Manufacturing block header length
+ */
+#define BFA_MFG_HDR_LEN				4
+
+/**
+ * Checksum size
+ */
+#define BFA_MFG_CHKSUM_SIZE			16
 
 /**
  * Manufacturing block format
@@ -30,29 +70,72 @@
 #define BFA_MFG_SERIALNUM_SIZE			11
 #define BFA_MFG_PARTNUM_SIZE			14
 #define BFA_MFG_SUPPLIER_ID_SIZE		10
-#define BFA_MFG_SUPPLIER_PARTNUM_SIZE	20
-#define BFA_MFG_SUPPLIER_SERIALNUM_SIZE	20
-#define BFA_MFG_SUPPLIER_REVISION_SIZE	4
+#define BFA_MFG_SUPPLIER_PARTNUM_SIZE		20
+#define BFA_MFG_SUPPLIER_SERIALNUM_SIZE		20
+#define BFA_MFG_SUPPLIER_REVISION_SIZE		4
 #define STRSZ(_n)	(((_n) + 4) & ~3)
 
 /**
+ * Manufacturing card type
+ */
+enum {
+	BFA_MFG_TYPE_CB_MAX  = 825,      /*  Crossbow card type max	*/
+	BFA_MFG_TYPE_FC8P2   = 825,      /*  8G 2port FC card		*/
+	BFA_MFG_TYPE_FC8P1   = 815,      /*  8G 1port FC card		*/
+	BFA_MFG_TYPE_FC4P2   = 425,      /*  4G 2port FC card		*/
+	BFA_MFG_TYPE_FC4P1   = 415,      /*  4G 1port FC card		*/
+	BFA_MFG_TYPE_CNA10P2 = 1020,     /*  10G 2port CNA card	*/
+	BFA_MFG_TYPE_CNA10P1 = 1010,     /*  10G 1port CNA card	*/
+};
+
+#pragma pack(1)
+
+/**
+ * Card type to port number conversion
+ */
+#define bfa_mfg_type2port_num(card_type) (((card_type) / 10) % 10)
+
+
+/**
+ * All numerical fields are in big-endian format.
+ */
+struct bfa_mfg_block_s {
+};
+
+/**
  * VPD data length
  */
-#define BFA_MFG_VPD_LEN     256
+#define BFA_MFG_VPD_LEN		512
+
+#define BFA_MFG_VPD_PCI_HDR_OFF		137
+#define BFA_MFG_VPD_PCI_VER_MASK	0x07	/*  version mask 3 bits */
+#define BFA_MFG_VPD_PCI_VDR_MASK	0xf8	/*  vendor mask 5 bits */
+
+/**
+ * VPD vendor tag
+ */
+enum {
+	BFA_MFG_VPD_UNKNOWN	= 0,     /*  vendor unknown 		*/
+	BFA_MFG_VPD_IBM 	= 1,     /*  vendor IBM 		*/
+	BFA_MFG_VPD_HP  	= 2,     /*  vendor HP  		*/
+	BFA_MFG_VPD_PCI_IBM 	= 0x08,  /*  PCI VPD IBM     		*/
+	BFA_MFG_VPD_PCI_HP  	= 0x10,  /*  PCI VPD HP		*/
+	BFA_MFG_VPD_PCI_BRCD 	= 0xf8,  /*  PCI VPD Brocade 		*/
+};
 
 /**
  * All numerical fields are in big-endian format.
  */
 struct bfa_mfg_vpd_s {
-    u8     version;    /*  vpd data version */
-    u8     vpd_sig[3]; /*  characters 'V', 'P', 'D' */
-    u8     chksum;     /*  u8 checksum */
-    u8     vendor;     /*  vendor */
-    u8     len;        /*  vpd data length excluding header */
-    u8     rsv;
-    u8     data[BFA_MFG_VPD_LEN];  /*  vpd data */
+	u8		version;	/*  vpd data version */
+	u8		vpd_sig[3];	/*  characters 'V', 'P', 'D' */
+	u8		chksum;		/*  u8 checksum */
+	u8		vendor;		/*  vendor */
+	u8 	len;		/*  vpd data length excluding header */
+	u8 	rsv;
+	u8		data[BFA_MFG_VPD_LEN];	/*  vpd data */
 };
 
-#pragma pack(1)
+#pragma pack()
 
 #endif /* __BFA_DEFS_MFG_H__ */
diff -uprN a/drivers/scsi/bfa/include/defs/bfa_defs_port.h b/drivers/scsi/bfa/include/defs/bfa_defs_port.h
--- a/drivers/scsi/bfa/include/defs/bfa_defs_port.h	2009-12-18 18:16:22.132761000 -0800
+++ b/drivers/scsi/bfa/include/defs/bfa_defs_port.h	2009-11-25 18:23:57.000000000 -0800
@@ -185,6 +185,8 @@ struct bfa_port_attr_s {
 	wwn_t		fabric_name; /*  attached switch's nwwn */
 	u8		fabric_ip_addr[BFA_FCS_FABRIC_IPADDR_SZ]; /*  attached
 							* fabric's ip addr */
+	struct mac_s    fpma_mac;	/*  Lport's FPMA Mac address */
+	u16	authfail;	/*  auth failed state */
 };
 
 /**
@@ -218,8 +220,7 @@ enum bfa_port_aen_event {
 	BFA_PORT_AEN_AUTH_OFF   = 10,	/*  Physical Port auth fail event */
 	BFA_PORT_AEN_DISCONNECT = 11,	/*  Physical Port disconnect event */
 	BFA_PORT_AEN_QOS_NEG    = 12,  	/*  Base Port QOS negotiation event */
-	BFA_PORT_AEN_FABRIC_NAME_CHANGE = 13, /*  Fabric Name/WWN change
-					       * event */
+	BFA_PORT_AEN_FABRIC_NAME_CHANGE = 13,/*  Fabric Name/WWN change event*/
 	BFA_PORT_AEN_SFP_ACCESS_ERROR = 14, /*  SFP read error event */
 	BFA_PORT_AEN_SFP_UNSUPPORT = 15, /*  Unsupported SFP event */
 };
@@ -232,14 +233,15 @@ enum bfa_port_aen_sfp_pom {
 };
 
 struct bfa_port_aen_data_s {
-	enum bfa_ioc_type_e ioc_type;
 	wwn_t           pwwn;	      /*  WWN of the physical port */
 	wwn_t           fwwn;	      /*  WWN of the fabric port */
-	mac_t           mac;	      /*  MAC addres of the ethernet port,
+	s32         phy_port_num; /*! For SFP related events */
+	s16         ioc_type;
+	s16         level;        /*  Only transitions will
+				       * be informed */
+	struct mac_s    mac;	      /*  MAC address of the ethernet port,
 				       * applicable to CNA port only */
-	int             phy_port_num; /*! For SFP related events */
-	enum bfa_port_aen_sfp_pom level; /*  Only transitions will
-					  * be informed */
+	s16         rsvd;
 };
 
 #endif /* __BFA_DEFS_PORT_H__ */
diff -uprN a/drivers/scsi/bfa/include/defs/bfa_defs_pport.h b/drivers/scsi/bfa/include/defs/bfa_defs_pport.h
--- a/drivers/scsi/bfa/include/defs/bfa_defs_pport.h	2009-12-18 18:16:22.124756000 -0800
+++ b/drivers/scsi/bfa/include/defs/bfa_defs_pport.h	2009-11-25 18:23:57.000000000 -0800
@@ -61,7 +61,7 @@ enum bfa_pport_speed {
  * 		Port operational type (in sync with SNIA port type).
  */
 enum bfa_pport_type {
-	BFA_PPORT_TYPE_UNKNOWN = 1,	/*  port type is unkown */
+	BFA_PPORT_TYPE_UNKNOWN = 1,	/*  port type is unknown */
 	BFA_PPORT_TYPE_TRUNKED = 2,	/*  Trunked mode */
 	BFA_PPORT_TYPE_NPORT   = 5,	/*  P2P with switched fabric */
 	BFA_PPORT_TYPE_NLPORT  = 6,	/*  public loop */
@@ -201,10 +201,10 @@ struct bfa_pport_attr_s {
 	/*
 	 * Static fields
 	 */
-	wwn_t           nwwn;		/*  node wwn */
-	wwn_t           pwwn;		/*  port wwn */
-	enum fc_cos     cos_supported;	/*  supported class of services */
-	u32        rsvd;
+	wwn_t       nwwn;		/*  node wwn */
+	wwn_t       pwwn;		/*  port wwn */
+	enum fc_cos cos_supported;	/*  supported class of services */
+	u32    rsvd;
 	struct fc_symname_s    port_symname;	/*  port symbolic name */
 	enum bfa_pport_speed speed_supported; /*  supported speeds */
 	bfa_boolean_t   pbind_enabled;	/*  Will be set if Persistent binding
@@ -232,81 +232,87 @@ struct bfa_pport_attr_s {
 	u32        	pid;		/*  port ID */
 	enum bfa_pport_type 	port_type;	/*  current topology */
 	u32        	loopback;	/*  external loopback */
-	u32		rsvd1;
+	u32		authfail;	/*  auth fail state */
 	u32		rsvd2;		/*  padding for 64 bit */
 };
 
 /**
- * 		FC Port statistics.
+ * FC physical port statistics.
  */
 struct bfa_pport_fc_stats_s {
-	u64        secs_reset;	/*  seconds since stats is reset */
-	u64        tx_frames;	/*  transmitted frames */
-	u64        tx_words;	/*  transmitted words */
-	u64        rx_frames;	/*  received frames */
-	u64        rx_words;	/*  received words */
-	u64        lip_count;	/*  LIPs seen */
-	u64        nos_count;	/*  NOS count */
-	u64        error_frames;	/*  errored frames (sent?) */
-	u64        dropped_frames;	/*  dropped frames */
-	u64        link_failures;	/*  link failure count */
-	u64        loss_of_syncs;	/*  loss of sync count */
-	u64        loss_of_signals;/*  loss of signal count */
-	u64        primseq_errs;	/*  primitive sequence protocol */
-	u64        bad_os_count;	/*  invalid ordered set */
-	u64        err_enc_out;	/*  Encoding error outside frame */
-	u64        invalid_crcs;	/*  frames received with invalid CRC*/
-	u64	undersized_frm; /*  undersized frames */
-	u64	oversized_frm;	/*  oversized frames */
-	u64	bad_eof_frm;	/*  frames with bad EOF */
-	struct bfa_qos_stats_s	qos_stats;	/*  QoS statistics */
+	u64	secs_reset;	/*  Seconds since stats is reset     */
+	u64	tx_frames;	/*  Tx frames			      */
+	u64	tx_words;	/*  Tx words			      */
+	u64	tx_lip;		/*  TX LIP			      */
+	u64	tx_nos;		/*  Tx NOS			      */
+	u64	tx_ols;		/*  Tx OLS			      */
+	u64	tx_lr;		/*  Tx LR			      */
+	u64	tx_lrr;		/*  Tx LRR			      */
+	u64	rx_frames;	/*  Rx frames			      */
+	u64	rx_words;	/*  Rx words			      */
+	u64	lip_count;	/*  Rx LIP 			      */
+	u64	nos_count;	/*  Rx NOS			      */
+	u64	ols_count;	/*  Rx OLS			      */
+	u64	lr_count;	/*  Rx LR			      */
+	u64	lrr_count;	/*  Rx LRR			      */
+	u64	invalid_crcs;	/*  Rx CRC err frames		      */
+	u64	invalid_crc_gd_eof; /*  Rx CRC err good EOF frames   */
+	u64	undersized_frm; /*  Rx undersized frames	      */
+	u64	oversized_frm;  /*  Rx oversized frames	      */
+	u64	bad_eof_frm;	/*  Rx frames with bad EOF	      */
+	u64	error_frames;	/*  Errored frames		      */
+	u64	dropped_frames;	/*  Dropped frames		      */
+	u64	link_failures;	/*  Link Failure (LF) count	      */
+	u64	loss_of_syncs;	/*  Loss of sync count		      */
+	u64	loss_of_signals;/*  Loss of signal count	      */
+	u64	primseq_errs;	/*  Primitive sequence protocol err. */
+	u64	bad_os_count;	/*  Invalid ordered sets	      */
+	u64	err_enc_out;	/*  Encoding err nonframe_8b10b      */
+	u64	err_enc;	/*  Encoding err frame_8b10b	      */
 };
 
 /**
- * 		Eth Port statistics.
+ * Eth Physical Port statistics.
  */
 struct bfa_pport_eth_stats_s {
-	u64	secs_reset;	/*  seconds since stats is reset */
-	u64	frame_64;      /*  both rx and tx counter */
-	u64	frame_65_127;      /* both rx and tx counter */
-	u64	frame_128_255;     /* both rx and tx counter */
-	u64	frame_256_511;     /* both rx and tx counter */
-	u64	frame_512_1023;    /* both rx and tx counter */
-	u64	frame_1024_1518;   /* both rx and tx counter */
-	u64	frame_1519_1522;   /* both rx and tx counter */
-
-	u64	tx_bytes;
-	u64	tx_packets;
-	u64	tx_mcast_packets;
-	u64	tx_bcast_packets;
-	u64	tx_control_frame;
-	u64	tx_drop;
-	u64	tx_jabber;
-	u64	tx_fcs_error;
-	u64	tx_fragments;
-
-	u64	rx_bytes;
-	u64	rx_packets;
-	u64	rx_mcast_packets;
-	u64	rx_bcast_packets;
-	u64	rx_control_frames;
-	u64	rx_unknown_opcode;
-	u64	rx_drop;
-	u64	rx_jabber;
-	u64	rx_fcs_error;
-	u64	rx_alignment_error;
-	u64	rx_frame_length_error;
-	u64	rx_code_error;
-	u64	rx_fragments;
-
-	u64	rx_pause; /* BPC */
-	u64	rx_zero_pause; /*  BPC Pause cancellation */
-	u64	tx_pause;      /* BPC */
-	u64	tx_zero_pause; /*  BPC Pause cancellation */
-	u64	rx_fcoe_pause; /* BPC */
-	u64	rx_fcoe_zero_pause; /*  BPC Pause cancellation */
-	u64	tx_fcoe_pause;      /* BPC */
-	u64	tx_fcoe_zero_pause; /*  BPC Pause cancellation */
+	u64	secs_reset;	  /*  Seconds since stats is reset   */
+	u64	frame_64;	  /*  Frames 64 bytes		      */
+	u64	frame_65_127;	  /*  Frames 65-127 bytes	      */
+	u64	frame_128_255;	  /*  Frames 128-255 bytes	      */
+	u64	frame_256_511;	  /*  Frames 256-511 bytes	      */
+	u64	frame_512_1023;	  /*  Frames 512-1023 bytes	      */
+	u64	frame_1024_1518;  /*  Frames 1024-1518 bytes	      */
+	u64	frame_1519_1522;  /*  Frames 1519-1522 bytes	      */
+	u64	tx_bytes;	  /*  Tx bytes			      */
+	u64	tx_packets;	  /*  Tx packets		      */
+	u64	tx_mcast_packets; /*  Tx multicast packets	      */
+	u64	tx_bcast_packets; /*  Tx broadcast packets	      */
+	u64	tx_control_frame; /*  Tx control frame		      */
+	u64	tx_drop;	  /*  Tx drops			      */
+	u64	tx_jabber;	  /*  Tx jabber		      */
+	u64	tx_fcs_error;	  /*  Tx FCS error		      */
+	u64	tx_fragments;	  /*  Tx fragments		      */
+	u64	rx_bytes;	  /*  Rx bytes			      */
+	u64	rx_packets;	  /*  Rx packets		      */
+	u64	rx_mcast_packets; /*  Rx multicast packets	      */
+	u64	rx_bcast_packets; /*  Rx broadcast packets	      */
+	u64	rx_control_frames; /*  Rx control frames	      */
+	u64	rx_unknown_opcode; /*  Rx unknown opcode	      */
+	u64	rx_drop;	  /*  Rx drops			      */
+	u64	rx_jabber;	  /*  Rx jabber		      */
+	u64	rx_fcs_error;	  /*  Rx FCS errors		      */
+	u64	rx_alignment_error; /*  Rx alignment errors	      */
+	u64	rx_frame_length_error; /*  Rx frame len errors       */
+	u64	rx_code_error;	  /*  Rx code errors		      */
+	u64	rx_fragments;	  /*  Rx fragments		      */
+	u64	rx_pause;	  /*  Rx pause			      */
+	u64	rx_zero_pause;	  /*  Rx zero pause		      */
+	u64	tx_pause;	  /*  Tx pause			      */
+	u64	tx_zero_pause;	  /*  Tx zero pause		      */
+	u64	rx_fcoe_pause;	  /*  Rx fcoe pause		      */
+	u64	rx_fcoe_zero_pause; /*  Rx FCoE zero pause	      */
+	u64	tx_fcoe_pause;	  /*  Tx FCoE pause		      */
+	u64	tx_fcoe_zero_pause; /*  Tx FCoE zero pause	      */
 };
 
 /**
@@ -314,7 +320,7 @@ struct bfa_pport_eth_stats_s {
  */
 union bfa_pport_stats_u {
 	struct bfa_pport_fc_stats_s	fc;
-	struct bfa_pport_eth_stats_s 	eth;
+	struct bfa_pport_eth_stats_s	eth;
 };
 
 /**
@@ -347,6 +353,23 @@ struct bfa_pport_rnid_s {
 	u16          topologydiscoveryflags;
 };
 
+struct bfa_fcport_fcf_s {
+	wwn_t           name;           /*  FCF name                 */
+	wwn_t           fabric_name;    /*  Fabric Name              */
+	u8		fipenabled;	/*  FIP enabled or not       */
+	u8		fipfailed;	/*  FIP failed or not        */
+	u8		resv[2];
+	u8         pri;            /*  FCF priority             */
+	u8         version;        /*  FIP version used         */
+	u8         available;      /*  Available  for  login    */
+	u8         fka_disabled;   /*  FKA is disabled          */
+	u8         maxsz_verified; /*  FCoE max size verified   */
+	u8         fc_map[3];      /*  FC map                   */
+	u16        vlan;           /*  FCoE vlan tag/priority   */
+	u32        fka_adv_per;    /*  FIP  ka advert. period   */
+	struct mac_s    mac;            /*  FCF mac                  */
+};
+
 /**
  * 		Link state information
  */
@@ -355,7 +378,7 @@ struct bfa_pport_link_s {
 	u8         linkstate_rsn;	/*  bfa_pport_linkstate_rsn_t */
 	u8         topology;	/*  P2P/LOOP bfa_pport_topology */
 	u8         speed;		/*  Link speed (1/2/4/8 G) */
-	u32        linkstate_opt;	/*  Linkstate optional data (debug) */
+	u32        linkstate_opt;  /*  Linkstate optional data (debug) */
 	u8         trunked;	/*  Trunked or not (1 or 0) */
 	u8         resvd[3];
 	struct bfa_qos_attr_s  qos_attr;   /* QoS Attributes */
@@ -378,6 +401,7 @@ struct bfa_pport_link_s {
 			struct fc_alpabm_s     alpabm;	   /*  alpa bitmap */
 		} loop_info;
 	} tl;
+	struct bfa_fcport_fcf_s fcf;	/*  FCF information (for FCoE) */
 };
 
 #endif /* __BFA_DEFS_PPORT_H__ */
diff -uprN a/drivers/scsi/bfa/include/defs/bfa_defs_rport.h b/drivers/scsi/bfa/include/defs/bfa_defs_rport.h
--- a/drivers/scsi/bfa/include/defs/bfa_defs_rport.h	2009-12-18 18:16:22.120759000 -0800
+++ b/drivers/scsi/bfa/include/defs/bfa_defs_rport.h	2009-11-25 18:23:57.000000000 -0800
@@ -146,8 +146,8 @@ struct bfa_rport_qos_attr_s {
  * FCS remote port attributes returned in queries
  */
 struct bfa_rport_attr_s {
-	wwn_t           	nwwn;	/*  node wwn */
-	wwn_t           	pwwn;	/*  port wwn */
+	wwn_t       nwwn;		/*  node wwn */
+	wwn_t       pwwn;		/*  port wwn */
 	enum fc_cos cos_supported;	/*  supported class of services */
 	u32        	pid;	/*  port ID */
 	u32        	df_sz;	/*  Max payload size */
diff -uprN a/drivers/scsi/bfa/include/defs/bfa_defs_status.h b/drivers/scsi/bfa/include/defs/bfa_defs_status.h
--- a/drivers/scsi/bfa/include/defs/bfa_defs_status.h	2009-12-18 18:16:22.118760000 -0800
+++ b/drivers/scsi/bfa/include/defs/bfa_defs_status.h	2009-11-25 18:23:57.000000000 -0800
@@ -178,10 +178,11 @@ enum bfa_status {
 	BFA_STATUS_IM_DUP_TEAM_NAME = 113, /*  Given team name already
 					    * exists */
 	BFA_STATUS_IM_ADAPT_ALREADY_IN_TEAM = 114, /*  Given adapter is part
-						    * of another team */
+						    * of another team or VLANS
+						    * exist */
 	BFA_STATUS_IM_ADAPT_HAS_VLANS = 115, /*  Adapter has VLANs configured.
-					      * Delete all VLANs before
-					      * creating team */
+					      * Delete all VLANs to become part
+					      * of team */
 	BFA_STATUS_IM_PVID_MISMATCH = 116, /*  Mismatching PVIDs configured
 					    * for adapters */
 	BFA_STATUS_IM_LINK_SPEED_MISMATCH = 117, /*  Mismatching link speeds
@@ -213,7 +214,8 @@ enum bfa_status {
 					     * loaded */
 	BFA_STATUS_CARD_TYPE_MISMATCH = 131, /*  Card type mismatch */
 	BFA_STATUS_BAD_ASICBLK = 132, /*  Bad ASIC block */
-	BFA_STATUS_NO_DRIVER = 133, /*  Storage/Ethernet driver not loaded */
+	BFA_STATUS_NO_DRIVER = 133, /*  Brocade adapter/driver not installed
+				     * or loaded */
 	BFA_STATUS_INVALID_MAC = 134, /*  Invalid mac address */
 	BFA_STATUS_IM_NO_VLAN = 135, /*  No VLANs configured on the adapter */
 	BFA_STATUS_IM_ETH_LB_FAILED = 136, /*  Ethernet loopback test failed */
@@ -228,8 +230,7 @@ enum bfa_status {
 	BFA_STATUS_IM_GET_INETCFG_FAILED = 142, /*  Acquiring Network Subsytem
 						 * handle Failed. Please try
 						 * after some time */
-	BFA_STATUS_IM_NOT_BOUND = 143, /*  Brocade 10G Ethernet Service is not
-					* Enabled on this port */
+	BFA_STATUS_IM_NOT_BOUND = 143, /*  IM driver is not active */
 	BFA_STATUS_INSUFFICIENT_PERMS = 144, /*  User doesn't have sufficient
 					      * permissions to execute the BCU
 					      * application */
@@ -242,6 +243,14 @@ enum bfa_status {
 					  * failed */
 	BFA_STATUS_IM_UNBIND_FAILED = 149, /* ! < IM Driver unbind operation
 					    * failed */
+	BFA_STATUS_IM_PORT_IN_TEAM = 150, /*  Port is already part of the
+					   * team */
+	BFA_STATUS_IM_VLAN_NOT_FOUND = 151, /*  VLAN ID doesn't exists */
+	BFA_STATUS_IM_TEAM_NOT_FOUND = 152, /*  Teaming configuration doesn't
+					     * exists */
+	BFA_STATUS_IM_TEAM_CFG_NOT_ALLOWED = 153, /*  Given settings are not
+						   * allowed for the current
+						   * Teaming mode */
 	BFA_STATUS_MAX_VAL		/*  Unknown error code */
 };
 #define bfa_status_t enum bfa_status
diff -uprN a/drivers/scsi/bfa/include/defs/bfa_defs_vf.h b/drivers/scsi/bfa/include/defs/bfa_defs_vf.h
--- a/drivers/scsi/bfa/include/defs/bfa_defs_vf.h	2009-12-18 18:16:22.109761000 -0800
+++ b/drivers/scsi/bfa/include/defs/bfa_defs_vf.h	2009-11-25 18:23:57.000000000 -0800
@@ -40,26 +40,21 @@ enum bfa_vf_state {
  * VF statistics
  */
 struct bfa_vf_stats_s {
-	u32        flogi_sent;	/*  Num FLOGIs sent 		*/
-	u32        flogi_rsp_err;	/*  FLOGI response errors 	*/
-	u32        flogi_acc_err;	/*  FLOGI accept errors 	*/
-	u32        flogi_accepts;	/*  FLOGI accepts received 	*/
-	u32        flogi_rejects;	/*  FLOGI rejects received 	*/
+	u32        flogi_sent;	/*  Num FLOGIs sent */
+	u32        flogi_rsp_err;	/*  FLOGI response errors */
+	u32        flogi_acc_err;	/*  FLOGI accept errors */
+	u32        flogi_accepts;	/*  FLOGI accepts received */
+	u32        flogi_rejects;	/*  FLOGI rejects received */
 	u32        flogi_unknown_rsp; /*  Unknown responses for FLOGI */
-	u32        flogi_alloc_wait; /*  Allocation waits prior to
-					   * sending FLOGI
-					   */
+	u32        flogi_alloc_wait;  /*  Allocation wait
+					    * prior to sending FLOGI */
 	u32        flogi_rcvd;	/*  FLOGIs received */
 	u32        flogi_rejected;	/*  Incoming FLOGIs rejected */
-	u32        fabric_onlines;	/*  Internal fabric online
-					 * notification sent to other
-					 * modules
-					 */
-	u32        fabric_offlines; /*  Internal fabric offline
-					  * notification sent to other
-					  * modules
-					  */
-	u32        resvd;
+	u32        fabric_onlines;	/*  Internal fabric online notification
+					 * sent to other modules */
+	u32        fabric_offlines; /*  Internal fabric offline notification
+					 * sent to other modules */
+	u32        resvd; /*  padding for 64 bit alignment */
 };
 
 /**
diff -uprN a/drivers/scsi/bfa/include/fcs/bfa_fcs.h b/drivers/scsi/bfa/include/fcs/bfa_fcs.h
--- a/drivers/scsi/bfa/include/fcs/bfa_fcs.h	2009-12-18 18:16:22.253757000 -0800
+++ b/drivers/scsi/bfa/include/fcs/bfa_fcs.h	2009-11-25 18:23:57.000000000 -0800
@@ -24,50 +24,53 @@
 #include <bfa.h>
 #include <fcs/bfa_fcs_fabric.h>
 
-#define BFA_FCS_OS_STR_LEN  		64
+#define BFA_FCS_OS_STR_LEN		64
 
 struct bfa_fcs_stats_s {
 	struct {
-		u32        untagged; /*  untagged receive frames */
-		u32        tagged;	/*  tagged receive frames */
-		u32        vfid_unknown;	/*  VF id is unknown */
+		u32	untagged; /*  untagged receive frames */
+		u32	tagged;	/*  tagged receive frames */
+		u32	vfid_unknown;	/*  VF id is unknown */
 	} uf;
 };
 
 struct bfa_fcs_driver_info_s {
-	u8  version[BFA_VERSION_LEN];		/*  Driver Version */
-	u8  host_machine_name[BFA_FCS_OS_STR_LEN];
-	u8  host_os_name[BFA_FCS_OS_STR_LEN]; /*  OS name and version */
-	u8  host_os_patch[BFA_FCS_OS_STR_LEN];/*  patch or service pack */
-	u8  os_device_name[BFA_FCS_OS_STR_LEN]; /*  Driver Device Name */
+	u8	 version[BFA_VERSION_LEN];		/*  Driver Version */
+	u8	 host_machine_name[BFA_FCS_OS_STR_LEN];
+	u8	 host_os_name[BFA_FCS_OS_STR_LEN]; /*  OS name and version */
+	u8	 host_os_patch[BFA_FCS_OS_STR_LEN]; /*  patch or service pack */
+	u8	 os_device_name[BFA_FCS_OS_STR_LEN]; /*  Driver Device Name */
 };
 
 struct bfa_fcs_s {
-	struct bfa_s      *bfa;	/*  corresponding BFA bfa instance */
-	struct bfad_s         *bfad; /*  corresponding BDA driver instance */
+	struct bfa_s	  *bfa;	/*  corresponding BFA bfa instance */
+	struct bfad_s	      *bfad; /*  corresponding BDA driver instance */
 	struct bfa_log_mod_s  *logm;	/*  driver logging module instance */
 	struct bfa_trc_mod_s  *trcmod;	/*  tracing module */
 	struct bfa_aen_s      *aen;	/*  aen component */
-	bfa_boolean_t   vf_enabled;	/*  VF mode is enabled */
+	bfa_boolean_t	vf_enabled;	/*  VF mode is enabled */
+	bfa_boolean_t	fdmi_enabled;	/*  FDMI is enabled */
 	bfa_boolean_t min_cfg;		/* min cfg enabled/disabled */
-	u16        port_vfid;	/*  port default VF ID */
+	u16	port_vfid;	/*  port default VF ID */
 	struct bfa_fcs_driver_info_s driver_info;
 	struct bfa_fcs_fabric_s fabric; /*  base fabric state machine */
 	struct bfa_fcs_stats_s	stats;	/*  FCS statistics */
-	struct bfa_wc_s       	wc;	/*  waiting counter */
+	struct bfa_wc_s		wc;	/*  waiting counter */
 };
 
 /*
  * bfa fcs API functions
  */
-void bfa_fcs_init(struct bfa_fcs_s *fcs, struct bfa_s *bfa, struct bfad_s *bfad,
-			bfa_boolean_t min_cfg);
+void bfa_fcs_attach(struct bfa_fcs_s *fcs, struct bfa_s *bfa,
+			struct bfad_s *bfad, bfa_boolean_t min_cfg);
+void bfa_fcs_init(struct bfa_fcs_s *fcs);
 void bfa_fcs_driver_info_init(struct bfa_fcs_s *fcs,
-			struct bfa_fcs_driver_info_s *driver_info);
+			      struct bfa_fcs_driver_info_s *driver_info);
+void bfa_fcs_set_fdmi_param(struct bfa_fcs_s *fcs, bfa_boolean_t fdmi_enable);
 void bfa_fcs_exit(struct bfa_fcs_s *fcs);
 void bfa_fcs_trc_init(struct bfa_fcs_s *fcs, struct bfa_trc_mod_s *trcmod);
 void bfa_fcs_log_init(struct bfa_fcs_s *fcs, struct bfa_log_mod_s *logmod);
 void bfa_fcs_aen_init(struct bfa_fcs_s *fcs, struct bfa_aen_s *aen);
-void 	  	bfa_fcs_start(struct bfa_fcs_s *fcs);
+void bfa_fcs_start(struct bfa_fcs_s *fcs);
 
 #endif /* __BFA_FCS_H__ */
diff -uprN a/drivers/scsi/bfa/include/fcs/bfa_fcs_fabric.h b/drivers/scsi/bfa/include/fcs/bfa_fcs_fabric.h
--- a/drivers/scsi/bfa/include/fcs/bfa_fcs_fabric.h	2009-12-18 18:16:22.249761000 -0800
+++ b/drivers/scsi/bfa/include/fcs/bfa_fcs_fabric.h	2009-11-25 18:23:57.000000000 -0800
@@ -70,12 +70,11 @@ struct bfa_fcs_fabric_s {
 	struct bfa_wc_s        wc;	/*  wait counter for delete	*/
 	struct bfa_vf_stats_s  stats; 	/*  fabric/vf stats		*/
 	struct bfa_lps_s	*lps;	/*  lport login services	*/
-	u8	fabric_ip_addr[BFA_FCS_FABRIC_IPADDR_SZ];  /*  attached
-							    * fabric's ip addr
-							    */
+	u8	fabric_ip_addr[BFA_FCS_FABRIC_IPADDR_SZ];
+					/*  attached fabric's ip addr  */
 };
 
-#define bfa_fcs_fabric_npiv_capable(__f)    (__f)->is_npiv
+#define bfa_fcs_fabric_npiv_capable(__f)    ((__f)->is_npiv)
 #define bfa_fcs_fabric_is_switched(__f)			\
 	((__f)->fab_type == BFA_FCS_FABRIC_SWITCHED)
 
diff -uprN a/drivers/scsi/bfa/include/fcs/bfa_fcs_lport.h b/drivers/scsi/bfa/include/fcs/bfa_fcs_lport.h
--- a/drivers/scsi/bfa/include/fcs/bfa_fcs_lport.h	2009-12-18 18:16:22.244759000 -0800
+++ b/drivers/scsi/bfa/include/fcs/bfa_fcs_lport.h	2009-11-25 18:23:57.000000000 -0800
@@ -35,13 +35,6 @@ struct bfa_fcs_fabric_s;
 
 /*
 * @todo : need to move to a global config file.
- * Maximum Vports supported per physical port or vf.
- */
-#define BFA_FCS_MAX_VPORTS_SUPP_CB  255
-#define BFA_FCS_MAX_VPORTS_SUPP_CT  191
-
-/*
-* @todo : need to move to a global config file.
  * Maximum Rports supported per port (physical/logical).
  */
 #define BFA_FCS_MAX_RPORTS_SUPP  256	/* @todo : tentative value */
@@ -128,10 +121,10 @@ struct bfa_fcs_port_s {
 	struct bfa_fcs_fabric_s *fabric;	/*  parent fabric */
 	struct bfa_port_cfg_s  port_cfg;	/*  port configuration */
 	struct bfa_timer_s link_timer;	/*  timer for link offline */
-	u32        pid : 24;	/*  FC address */
+	u32        pid:24;		/*  FC address */
 	u8         lp_tag;		/*  lport tag */
 	u16        num_rports;	/*  Num of r-ports */
-	struct list_head rport_q;	/*  queue of discovered r-ports */
+	struct list_head	rport_q;/*  queue of discovered r-ports */
 	struct bfa_fcs_s *fcs;	/*  FCS instance */
 	union bfa_fcs_port_topo_u port_topo;	/*  fabric/loop/n2n details */
 	struct bfad_port_s *bfad_port;	/*  driver peer instance */
@@ -188,17 +181,20 @@ bfa_fcs_port_get_drvport(struct bfa_fcs_
 }
 
 
-#define bfa_fcs_port_get_opertype(_lport)	(_lport)->fabric->oper_type
+#define bfa_fcs_port_get_opertype(_lport)	((_lport)->fabric->oper_type)
 
 
-#define bfa_fcs_port_get_fabric_name(_lport)	(_lport)->fabric->fabric_name
+#define bfa_fcs_port_get_fabric_name(_lport)	((_lport)->fabric->fabric_name)
 
 
-#define bfa_fcs_port_get_fabric_ipaddr(_lport)	(_lport)->fabric->fabric_ip_addr
+#define bfa_fcs_port_get_fabric_ipaddr(_lport) \
+		((_lport)->fabric->fabric_ip_addr)
 
 /**
  * bfa fcs port public functions
  */
+
+bfa_boolean_t   bfa_fcs_port_is_online(struct bfa_fcs_port_s *port);
 void bfa_fcs_cfg_base_port(struct bfa_fcs_s *fcs,
 			struct bfa_port_cfg_s *port_cfg);
 struct bfa_fcs_port_s *bfa_fcs_get_base_port(struct bfa_fcs_s *fcs);
@@ -218,8 +214,8 @@ void bfa_fcs_port_get_attr(struct bfa_fc
 void bfa_fcs_port_get_stats(struct bfa_fcs_port_s *fcs_port,
 			struct bfa_port_stats_s *port_stats);
 void bfa_fcs_port_clear_stats(struct bfa_fcs_port_s *fcs_port);
-enum bfa_pport_speed bfa_fcs_port_get_rport_max_speed(
-			struct bfa_fcs_port_s *port);
+enum bfa_pport_speed
+bfa_fcs_port_get_rport_max_speed(struct bfa_fcs_port_s *port);
 void bfa_fcs_port_enable_ipfc_roles(struct bfa_fcs_port_s *fcs_port);
 void bfa_fcs_port_disable_ipfc_roles(struct bfa_fcs_port_s *fcs_port);
 
diff -uprN a/drivers/scsi/bfa/include/fcs/bfa_fcs_rport.h b/drivers/scsi/bfa/include/fcs/bfa_fcs_rport.h
--- a/drivers/scsi/bfa/include/fcs/bfa_fcs_rport.h	2009-12-18 18:16:22.242759000 -0800
+++ b/drivers/scsi/bfa/include/fcs/bfa_fcs_rport.h	2009-11-25 18:23:57.000000000 -0800
@@ -99,6 +99,7 @@ struct bfa_fcs_rport_s *bfa_fcs_rport_lo
 struct bfa_fcs_rport_s *bfa_fcs_rport_lookup_by_nwwn(
 			struct bfa_fcs_port_s *port, wwn_t rnwwn);
 void bfa_fcs_rport_set_del_timeout(u8 rport_tmo);
+
 void bfa_fcs_rport_set_speed(struct bfa_fcs_rport_s *rport,
-			enum bfa_pport_speed speed);
+				enum bfa_pport_speed speed);
 #endif /* __BFA_FCS_RPORT_H__ */
diff -uprN a/drivers/scsi/bfa/include/fcs/bfa_fcs_vport.h b/drivers/scsi/bfa/include/fcs/bfa_fcs_vport.h
--- a/drivers/scsi/bfa/include/fcs/bfa_fcs_vport.h	2009-12-18 18:16:22.241756000 -0800
+++ b/drivers/scsi/bfa/include/fcs/bfa_fcs_vport.h	2009-11-25 18:23:57.000000000 -0800
@@ -29,13 +29,13 @@
 #include <fcb/bfa_fcb_vport.h>
 
 struct bfa_fcs_vport_s {
-	struct list_head		qe;		/*  queue elem	 */
+	struct list_head	qe;		/*  queue elem	*/
 	bfa_sm_t		sm;		/*  state machine	*/
 	bfa_fcs_lport_t		lport;		/*  logical port	*/
-	struct bfa_timer_s	timer;		/*  general purpose timer */
+	struct bfa_timer_s	timer;		/*  general purpose timer*/
 	struct bfad_vport_s	*vport_drv;	/*  Driver private	*/
 	struct bfa_vport_stats_s vport_stats;	/*  vport statistics	*/
-	struct bfa_lps_s	*lps;		/*  Lport login service */
+	struct bfa_lps_s	*lps;		/*  Lport login service*/
 	int			fdisc_retries;
 };
 
diff -uprN a/drivers/scsi/bfa/include/log/bfa_log_hal.h b/drivers/scsi/bfa/include/log/bfa_log_hal.h
--- a/drivers/scsi/bfa/include/log/bfa_log_hal.h	2009-12-18 18:16:22.260755000 -0800
+++ b/drivers/scsi/bfa/include/log/bfa_log_hal.h	2009-11-25 18:23:58.000000000 -0800
@@ -27,4 +27,10 @@
 	(((u32) BFA_LOG_HAL_ID << BFA_LOG_MODID_OFFSET) | 3)
 #define BFA_LOG_HAL_SM_ASSERT \
 	(((u32) BFA_LOG_HAL_ID << BFA_LOG_MODID_OFFSET) | 4)
+#define BFA_LOG_HAL_DRIVER_ERROR \
+	(((u32) BFA_LOG_HAL_ID << BFA_LOG_MODID_OFFSET) | 5)
+#define BFA_LOG_HAL_DRIVER_CONFIG_ERROR \
+	(((u32) BFA_LOG_HAL_ID << BFA_LOG_MODID_OFFSET) | 6)
+#define BFA_LOG_HAL_MBOX_ERROR \
+	(((u32) BFA_LOG_HAL_ID << BFA_LOG_MODID_OFFSET) | 7)
 #endif
diff -uprN a/drivers/scsi/bfa/include/log/bfa_log_linux.h b/drivers/scsi/bfa/include/log/bfa_log_linux.h
--- a/drivers/scsi/bfa/include/log/bfa_log_linux.h	2009-12-18 18:16:22.258756000 -0800
+++ b/drivers/scsi/bfa/include/log/bfa_log_linux.h	2009-11-25 18:23:58.000000000 -0800
@@ -20,25 +20,41 @@
 #define	__BFA_LOG_LINUX_H__
 #include  <cs/bfa_log.h>
 #define BFA_LOG_LINUX_DEVICE_CLAIMED \
-		(((u32) BFA_LOG_LINUX_ID << BFA_LOG_MODID_OFFSET) | 1)
+	(((u32) BFA_LOG_LINUX_ID << BFA_LOG_MODID_OFFSET) | 1)
 #define BFA_LOG_LINUX_HASH_INIT_FAILED \
-		(((u32) BFA_LOG_LINUX_ID << BFA_LOG_MODID_OFFSET) | 2)
+	(((u32) BFA_LOG_LINUX_ID << BFA_LOG_MODID_OFFSET) | 2)
 #define BFA_LOG_LINUX_SYSFS_FAILED \
-		(((u32) BFA_LOG_LINUX_ID << BFA_LOG_MODID_OFFSET) | 3)
+	(((u32) BFA_LOG_LINUX_ID << BFA_LOG_MODID_OFFSET) | 3)
 #define BFA_LOG_LINUX_MEM_ALLOC_FAILED \
-		(((u32) BFA_LOG_LINUX_ID << BFA_LOG_MODID_OFFSET) | 4)
+	(((u32) BFA_LOG_LINUX_ID << BFA_LOG_MODID_OFFSET) | 4)
 #define BFA_LOG_LINUX_DRIVER_REGISTRATION_FAILED \
-		(((u32) BFA_LOG_LINUX_ID << BFA_LOG_MODID_OFFSET) | 5)
+	(((u32) BFA_LOG_LINUX_ID << BFA_LOG_MODID_OFFSET) | 5)
 #define BFA_LOG_LINUX_ITNIM_FREE \
-		(((u32) BFA_LOG_LINUX_ID << BFA_LOG_MODID_OFFSET) | 6)
+	(((u32) BFA_LOG_LINUX_ID << BFA_LOG_MODID_OFFSET) | 6)
 #define BFA_LOG_LINUX_ITNIM_ONLINE \
-		(((u32) BFA_LOG_LINUX_ID << BFA_LOG_MODID_OFFSET) | 7)
+	(((u32) BFA_LOG_LINUX_ID << BFA_LOG_MODID_OFFSET) | 7)
 #define BFA_LOG_LINUX_ITNIM_OFFLINE \
-		(((u32) BFA_LOG_LINUX_ID << BFA_LOG_MODID_OFFSET) | 8)
+	(((u32) BFA_LOG_LINUX_ID << BFA_LOG_MODID_OFFSET) | 8)
 #define BFA_LOG_LINUX_SCSI_HOST_FREE \
-		(((u32) BFA_LOG_LINUX_ID << BFA_LOG_MODID_OFFSET) | 9)
+	(((u32) BFA_LOG_LINUX_ID << BFA_LOG_MODID_OFFSET) | 9)
 #define BFA_LOG_LINUX_SCSI_ABORT \
-		(((u32) BFA_LOG_LINUX_ID << BFA_LOG_MODID_OFFSET) | 10)
+	(((u32) BFA_LOG_LINUX_ID << BFA_LOG_MODID_OFFSET) | 10)
 #define BFA_LOG_LINUX_SCSI_ABORT_COMP \
-		(((u32) BFA_LOG_LINUX_ID << BFA_LOG_MODID_OFFSET) | 11)
+	(((u32) BFA_LOG_LINUX_ID << BFA_LOG_MODID_OFFSET) | 11)
+#define BFA_LOG_LINUX_DRIVER_CONFIG_ERROR \
+	(((u32) BFA_LOG_LINUX_ID << BFA_LOG_MODID_OFFSET) | 12)
+#define BFA_LOG_LINUX_BNA_STATE_MACHINE \
+	(((u32) BFA_LOG_LINUX_ID << BFA_LOG_MODID_OFFSET) | 13)
+#define BFA_LOG_LINUX_IOC_ERROR \
+	(((u32) BFA_LOG_LINUX_ID << BFA_LOG_MODID_OFFSET) | 14)
+#define BFA_LOG_LINUX_RESOURCE_ALLOC_ERROR \
+	(((u32) BFA_LOG_LINUX_ID << BFA_LOG_MODID_OFFSET) | 15)
+#define BFA_LOG_LINUX_RING_BUFFER_ERROR \
+	(((u32) BFA_LOG_LINUX_ID << BFA_LOG_MODID_OFFSET) | 16)
+#define BFA_LOG_LINUX_DRIVER_ERROR \
+	(((u32) BFA_LOG_LINUX_ID << BFA_LOG_MODID_OFFSET) | 17)
+#define BFA_LOG_LINUX_DRIVER_DIAG \
+	(((u32) BFA_LOG_LINUX_ID << BFA_LOG_MODID_OFFSET) | 18)
+#define BFA_LOG_LINUX_DRIVER_AEN \
+	(((u32) BFA_LOG_LINUX_ID << BFA_LOG_MODID_OFFSET) | 19)
 #endif
diff -uprN a/drivers/scsi/bfa/include/protocol/ct.h b/drivers/scsi/bfa/include/protocol/ct.h
--- a/drivers/scsi/bfa/include/protocol/ct.h	2009-12-18 18:16:22.285749000 -0800
+++ b/drivers/scsi/bfa/include/protocol/ct.h	2009-11-25 18:23:58.000000000 -0800
@@ -22,7 +22,7 @@
 
 #pragma pack(1)
 
-struct ct_hdr_s{
+struct ct_hdr_s {
 	u32	rev_id:8;	/* Revision of the CT */
 	u32	in_id:24;	/* Initiator Id */
 	u32	gs_type:8;	/* Generic service Type */
@@ -37,6 +37,7 @@ struct ct_hdr_s{
 	u32	vendor_unq:8;	/* vendor unique */
 };
 
+
 /*
  * defines for the Revision
  */
@@ -159,19 +160,20 @@ enum {
 	GS_RFF_ID	= 0x021F,	/* Register FC4 Feature		*/
 };
 
-struct fcgs_id_req_s{
+struct fcgs_id_req_s {
 	u32	rsvd:8;
 	u32	dap:24;	/* port identifier */
 };
+
 #define fcgs_gpnid_req_t struct fcgs_id_req_s
 #define fcgs_gnnid_req_t struct fcgs_id_req_s
 #define fcgs_gspnid_req_t struct fcgs_id_req_s
 
-struct fcgs_gidpn_req_s{
+struct fcgs_gidpn_req_s {
 	wwn_t	port_name;	/* port wwn */
 };
 
-struct fcgs_gidpn_resp_s{
+struct fcgs_gidpn_resp_s {
 	u32	rsvd:8;
 	u32	dap:24;	/* port identifier */
 };
@@ -192,23 +194,23 @@ struct fcgs_rftid_req_s {
 #define FC_GS_FCP_FC4_FEATURE_INITIATOR  0x02
 #define FC_GS_FCP_FC4_FEATURE_TARGET	 0x01
 
-struct fcgs_rffid_req_s{
-    u32    rsvd          :8;
-    u32    dap        	  :24;		/* port identifier	*/
-    u32    rsvd1         :16;
-    u32    fc4ftr_bits   :8;		/* fc4 feature bits	*/
-    u32    fc4_type      :8;		/* corresponding FC4 Type */
+struct fcgs_rffid_req_s {
+    u32    rsvd:8;
+    u32    dap:24;		/* port identifier	*/
+    u32    rsvd1:16;
+    u32    fc4ftr_bits:8;		/* fc4 feature bits	*/
+    u32    fc4_type:8;		/* corresponding FC4 Type */
 };
 
 /**
  * GID_FT Request
  */
-struct fcgs_gidft_req_s{
+struct fcgs_gidft_req_s {
 	u8	reserved;
 	u8	domain_id;	/* domain, 0 - all fabric */
 	u8	area_id;	/* area, 0 - whole domain */
 	u8	fc4_type;	/* FC_TYPE_FCP for SCSI devices */
-};				/* GID_FT Request */
+};						/* GID_FT Request */
 
 /**
  * GID_FT Response
@@ -217,12 +219,12 @@ struct fcgs_gidft_resp_s {
 	u8		last:1;	/* last port identifier flag */
 	u8		reserved:7;
 	u32	pid:24;	/* port identifier */
-};				/* GID_FT Response */
+};						/* GID_FT Response */
 
 /**
  * RSPN_ID
  */
-struct fcgs_rspnid_req_s{
+struct fcgs_rspnid_req_s {
 	u32	rsvd:8;
 	u32	dap:24;		/* port identifier */
 	u8		spn_len;	/* symbolic port name length */
@@ -232,7 +234,7 @@ struct fcgs_rspnid_req_s{
 /**
  * RPN_ID
  */
-struct fcgs_rpnid_req_s{
+struct fcgs_rpnid_req_s {
 	u32	rsvd:8;
 	u32	port_id:24;
 	wwn_t		port_name;
@@ -241,7 +243,7 @@ struct fcgs_rpnid_req_s{
 /**
  * RNN_ID
  */
-struct fcgs_rnnid_req_s{
+struct fcgs_rnnid_req_s {
 	u32	rsvd:8;
 	u32	port_id:24;
 	wwn_t		node_name;
@@ -250,7 +252,7 @@ struct fcgs_rnnid_req_s{
 /**
  * RCS_ID
  */
-struct fcgs_rcsid_req_s{
+struct fcgs_rcsid_req_s {
 	u32	rsvd:8;
 	u32	port_id:24;
 	u32	cos;
@@ -259,7 +261,7 @@ struct fcgs_rcsid_req_s{
 /**
  * RPT_ID
  */
-struct fcgs_rptid_req_s{
+struct fcgs_rptid_req_s {
 	u32	rsvd:8;
 	u32	port_id:24;
 	u32	port_type:8;
@@ -269,7 +271,7 @@ struct fcgs_rptid_req_s{
 /**
  * GA_NXT Request
  */
-struct fcgs_ganxt_req_s{
+struct fcgs_ganxt_req_s {
 	u32	rsvd:8;
 	u32	port_id:24;
 };
@@ -277,7 +279,7 @@ struct fcgs_ganxt_req_s{
 /**
  * GA_NXT Response
  */
-struct fcgs_ganxt_rsp_s{
+struct fcgs_ganxt_rsp_s {
 	u32	port_type:8;	/* Port Type */
 	u32	port_id:24;	/* Port Identifier */
 	wwn_t		port_name;	/* Port Name */
@@ -321,7 +323,7 @@ enum {
 /*
 * Port Value : Could be a Port id or wwn
  */
-union fcgs_port_val_u{
+union fcgs_port_val_u {
 	u32	nport_id;
 	wwn_t		nport_wwn;
 };
@@ -355,7 +357,7 @@ enum {
 /*
  * Ftrace Request
  */
-struct fcgs_ftrace_req_s{
+struct fcgs_ftrace_req_s {
 	u32	revision;
 	u16	src_port_tag;	/* Source Port tag */
 	u16	src_port_len;	/* Source Port len */
@@ -372,7 +374,7 @@ struct fcgs_ftrace_req_s{
 /*
  * Path info structure
  */
-struct fcgs_ftrace_path_info_s{
+struct fcgs_ftrace_path_info_s {
 	wwn_t		switch_name;		/* Switch WWN */
 	u32	domain_id;
 	wwn_t		ingress_port_name;	/* Ingress ports wwn */
@@ -388,7 +390,7 @@ struct fcgs_ftrace_path_info_s{
 /*
  * Ftrace Acc Response
  */
-struct fcgs_ftrace_resp_s{
+struct fcgs_ftrace_resp_s {
 	u32	revision;
 	u32	token;
 	u8		vendor_id[8];		/* T10 Vendor Identifier */
@@ -409,7 +411,7 @@ struct fcgs_ftrace_resp_s{
 /*
  * FC Ping Request
  */
-struct fcgs_fcping_req_s{
+struct fcgs_fcping_req_s {
 	u32	revision;
 	u16	port_tag;
 	u16	port_len;	/* Port len */
@@ -420,7 +422,7 @@ struct fcgs_fcping_req_s{
 /*
  * FC Ping Response
  */
-struct fcgs_fcping_resp_s{
+struct fcgs_fcping_resp_s {
 	u32	token;
 };
 
@@ -435,26 +437,26 @@ enum {
  * ZS GZME request
  */
 #define ZS_GZME_ZNAMELEN	32
-struct zs_gzme_req_s{
+struct zs_gzme_req_s {
 	u8	znamelen;
 	u8	rsvd[3];
 	u8	zname[ZS_GZME_ZNAMELEN];
 };
 
-enum zs_mbr_type{
+enum zs_mbr_type {
 	ZS_MBR_TYPE_PWWN	= 1,
 	ZS_MBR_TYPE_DOMPORT	= 2,
 	ZS_MBR_TYPE_PORTID	= 3,
 	ZS_MBR_TYPE_NWWN	= 4,
 };
 
-struct zs_mbr_wwn_s{
+struct  zs_mbr_wwn_s {
 	u8	mbr_type;
 	u8	rsvd[3];
 	wwn_t	wwn;
 };
 
-struct zs_query_resp_s{
+struct zs_query_resp_s {
 	u32	nmbrs;	/*  number of zone members */
 	struct zs_mbr_wwn_s	mbr[1];
 };
diff -uprN a/drivers/scsi/bfa/include/protocol/fc.h b/drivers/scsi/bfa/include/protocol/fc.h
--- a/drivers/scsi/bfa/include/protocol/fc.h	2009-12-18 18:16:22.283750000 -0800
+++ b/drivers/scsi/bfa/include/protocol/fc.h	2009-11-25 18:23:58.000000000 -0800
@@ -50,6 +50,11 @@ struct fchs_s {
 
 	u32        ro;		/* relative offset */
 };
+
+#define FC_SOF_LEN		4
+#define FC_EOF_LEN		4
+#define FC_CRC_LEN		4
+
 /*
  * Fibre Channel BB_E Header Structure
  */
@@ -138,7 +143,7 @@ enum {
 	FC_TYPE_MAX		= 256,	/* 256 FC-4 types */
 };
 
-struct fc_fc4types_s{
+struct fc_fc4types_s {
 	u8         bits[FC_TYPE_MAX / 8];
 };
 
@@ -196,9 +201,9 @@ enum {
 /*
  * generic ELS command
  */
-struct fc_els_cmd_s{
-	u32        els_code:8;	/* ELS Command Code */
-	u32        reserved:24;
+struct fc_els_cmd_s {
+u32        els_code:8;	/* ELS Command Code */
+u32        reserved:24;
 };
 
 /*
@@ -267,7 +272,7 @@ enum {
  * N_Port PLOGI Common Service Parameters.
  * FC-PH-x. Figure-76. pg. 308.
  */
-struct fc_plogi_csp_s{
+struct fc_plogi_csp_s {
 	u8         verhi;	/* FC-PH high version */
 	u8         verlo;	/* FC-PH low version */
 	u16        bbcred;	/* BB_Credit */
@@ -321,7 +326,7 @@ struct fc_plogi_csp_s{
  * N_Port PLOGI Class Specific Parameters.
  * FC-PH-x. Figure 78. pg. 318.
  */
-struct fc_plogi_clp_s{
+struct fc_plogi_clp_s {
 #ifdef __BIGENDIAN
 	u32        class_valid:1;
 	u32        intermix:1;	/* class intermix supported if set =1.
@@ -356,14 +361,15 @@ struct fc_plogi_clp_s{
 	u32        reserved8:16;
 };
 
-#define FLOGI_VVL_BRCD    0x42524344 /* ASCII value for each character in
-				      * string "BRCD" */
+#define FLOGI_VVL_BRCD    0x42524344 /* ASCII value for each character
+				      * in string "BRCD"
+				      */
 
 /*
  * PLOGI els command and reply payload
  */
-struct fc_logi_s{
-	struct fc_els_cmd_s els_cmd;	/* ELS command code */
+struct fc_logi_s {
+	struct fc_els_cmd_s    els_cmd;	/* ELS command code */
 	struct fc_plogi_csp_s  csp;		/* common service params */
 	wwn_t           port_name;
 	wwn_t           node_name;
@@ -377,7 +383,7 @@ struct fc_logi_s{
 /*
  * LOGO els command payload
  */
-struct fc_logo_s{
+struct fc_logo_s {
 	struct fc_els_cmd_s    els_cmd;	/* ELS command code */
 	u32        res1:8;
 	u32        nport_id:24;	/* N_Port identifier of source */
@@ -400,7 +406,7 @@ struct fc_adisc_s {
 /*
  * Exchange status block
  */
-struct fc_exch_status_blk_s{
+struct fc_exch_status_blk_s {
 	u32        oxid:16;
 	u32        rxid:16;
 	u32        res1:8;
@@ -429,9 +435,9 @@ struct fc_res_s {
 /*
  * RES els accept payload
  */
-struct fc_res_acc_s{
-	struct fc_els_cmd_s els_cmd;	/* ELS command code */
-	struct fc_exch_status_blk_s fc_exch_blk; /* Exchange status block */
+struct fc_res_acc_s {
+	struct fc_els_cmd_s	els_cmd;	/* ELS command code */
+	struct fc_exch_status_blk_s fc_exch_blk;/* Exchange status block */
 };
 
 /*
@@ -485,15 +491,15 @@ struct fc_rsi_s {
  * structure for PRLI paramater pages, both request & response
  * see FC-PH-X table 113 & 115 for explanation also FCP table 8
  */
-struct fc_prli_params_s{
-	u32        reserved: 16;
+struct fc_prli_params_s {
+	u32        reserved:16;
 #ifdef __BIGENDIAN
-	u32        reserved1: 5;
-	u32        rec_support : 1;
-	u32        task_retry_id : 1;
-	u32        retry : 1;
+	u32        reserved1:5;
+	u32        rec_support:1;
+	u32        task_retry_id:1;
+	u32        retry:1;
 
-	u32        confirm : 1;
+	u32        confirm:1;
 	u32        doverlay:1;
 	u32        initiator:1;
 	u32        target:1;
@@ -502,10 +508,10 @@ struct fc_prli_params_s{
 	u32        rxrdisab:1;
 	u32        wxrdisab:1;
 #else
-	u32        retry : 1;
-	u32        task_retry_id : 1;
-	u32        rec_support : 1;
-	u32        reserved1: 5;
+	u32        retry:1;
+	u32        task_retry_id:1;
+	u32        rec_support:1;
+	u32        reserved1:5;
 
 	u32        wxrdisab:1;
 	u32        rxrdisab:1;
@@ -514,7 +520,7 @@ struct fc_prli_params_s{
 	u32        target:1;
 	u32        initiator:1;
 	u32        doverlay:1;
-	u32        confirm : 1;
+	u32        confirm:1;
 #endif
 };
 
@@ -526,7 +532,7 @@ enum {
 	FC_PRLI_ACC_PREDEF_IMG = 0x5,	/* predefined image - no prli needed */
 };
 
-struct fc_prli_params_page_s{
+struct fc_prli_params_page_s {
 	u32        type:8;
 	u32        codext:8;
 #ifdef __BIGENDIAN
@@ -546,13 +552,13 @@ struct fc_prli_params_page_s{
 
 	u32        origprocas;
 	u32        rspprocas;
-	struct fc_prli_params_s  servparams;
+	struct fc_prli_params_s servparams;
 };
 
 /*
  * PRLI request and accept payload, FC-PH-X tables 112 & 114
  */
-struct fc_prli_s{
+struct fc_prli_s {
 	u32        command:8;
 	u32        pglen:8;
 	u32        pagebytes:16;
@@ -562,7 +568,7 @@ struct fc_prli_s{
 /*
  * PRLO logout params page
  */
-struct fc_prlo_params_page_s{
+struct fc_prlo_params_page_s {
 	u32        type:8;
 	u32        type_ext:8;
 #ifdef __BIGENDIAN
@@ -587,7 +593,7 @@ struct fc_prlo_params_page_s{
 /*
  * PRLO els command payload
  */
-struct fc_prlo_s{
+struct fc_prlo_s {
 	u32        	command:8;
 	u32        	page_len:8;
 	u32        	payload_len:16;
@@ -597,7 +603,7 @@ struct fc_prlo_s{
 /*
  * PRLO Logout response parameter page
  */
-struct fc_prlo_acc_params_page_s{
+struct fc_prlo_acc_params_page_s {
 	u32        type:8;
 	u32        type_ext:8;
 
@@ -623,7 +629,7 @@ struct fc_prlo_acc_params_page_s{
 /*
  * PRLO els command ACC payload
  */
-struct fc_prlo_acc_s{
+struct fc_prlo_acc_s {
 	u32        command:8;
 	u32        page_len:8;
 	u32        payload_len:16;
@@ -645,7 +651,7 @@ enum {
 	FC_VU_SCR_REG_FUNC_FABRIC_NAME_CHANGE = 0x01
 };
 
-struct fc_scr_s{
+struct fc_scr_s {
 	u32 command:8;
 	u32 res:24;
 	u32 vu_reg_func:8; /* Vendor Unique Registrations */
@@ -717,7 +723,7 @@ enum {
 /*
  * RRQ els command payload
  */
-struct fc_rrq_s{
+struct fc_rrq_s {
 	struct fc_els_cmd_s    els_cmd;	/* ELS command code */
 	u32        res1:8;
 	u32        s_id:24;	/* exchange originator S_ID */
@@ -731,7 +737,7 @@ struct fc_rrq_s{
 /*
  * ABTS BA_ACC reply payload
  */
-struct fc_ba_acc_s{
+struct fc_ba_acc_s {
 	u32        seq_id_valid:8;	/* set to 0x00 for Abort Exchange */
 	u32        seq_id:8;	/* invalid for Abort Exchange */
 	u32        res2:16;
@@ -744,7 +750,7 @@ struct fc_ba_acc_s{
 /*
  * ABTS BA_RJT reject payload
  */
-struct fc_ba_rjt_s{
+struct fc_ba_rjt_s {
 	u32        res1:8;		/* Reserved */
 	u32        reason_code:8;	/* reason code for reject */
 	u32        reason_expl:8;	/* reason code explanation */
@@ -754,9 +760,9 @@ struct fc_ba_rjt_s{
 /*
  * TPRLO logout parameter page
  */
-struct fc_tprlo_params_page_s{
-	u32        type:8;
-	u32        type_ext:8;
+struct fc_tprlo_params_page_s {
+u32        type:8;
+u32        type_ext:8;
 
 #ifdef __BIGENDIAN
 	u32        opa_valid:1;
@@ -782,7 +788,7 @@ struct fc_tprlo_params_page_s{
 /*
  * TPRLO ELS command payload
  */
-struct fc_tprlo_s{
+struct fc_tprlo_s {
 	u32        command:8;
 	u32        page_len:8;
 	u32        payload_len:16;
@@ -790,7 +796,7 @@ struct fc_tprlo_s{
 	struct fc_tprlo_params_page_s tprlo_params[1];
 };
 
-enum fc_tprlo_type{
+enum fc_tprlo_type {
 	FC_GLOBAL_LOGO = 1,
 	FC_TPR_LOGO
 };
@@ -798,7 +804,7 @@ enum fc_tprlo_type{
 /*
  * TPRLO els command ACC payload
  */
-struct fc_tprlo_acc_s{
+struct fc_tprlo_acc_s {
 	u32	command:8;
 	u32	page_len:8;
 	u32	payload_len:16;
@@ -810,21 +816,21 @@ struct fc_tprlo_acc_s{
  */
 #define FC_RSCN_PGLEN	0x4
 
-enum fc_rscn_format{
+enum fc_rscn_format {
 	FC_RSCN_FORMAT_PORTID	= 0x0,
 	FC_RSCN_FORMAT_AREA	= 0x1,
 	FC_RSCN_FORMAT_DOMAIN	= 0x2,
 	FC_RSCN_FORMAT_FABRIC	= 0x3,
 };
 
-struct fc_rscn_event_s{
+struct fc_rscn_event_s {
 	u32        format:2;
 	u32        qualifier:4;
 	u32        resvd:2;
 	u32        portid:24;
 };
 
-struct fc_rscn_pl_s{
+struct fc_rscn_pl_s {
 	u8         command;
 	u8         pagelen;
 	u16        payldlen;
@@ -863,7 +869,7 @@ struct fc_echo_s {
 /*
  * RNID els command payload
  */
-struct fc_rnid_cmd_s{
+struct fc_rnid_cmd_s {
 	struct fc_els_cmd_s    els_cmd;
 	u32        node_id_data_format:8;
 	u32        reserved:24;
@@ -873,12 +879,12 @@ struct fc_rnid_cmd_s{
  * RNID els response payload
  */
 
-struct fc_rnid_common_id_data_s{
+struct fc_rnid_common_id_data_s {
 	wwn_t           port_name;
 	wwn_t           node_name;
 };
 
-struct fc_rnid_general_topology_data_s{
+struct fc_rnid_general_topology_data_s {
 	u32        vendor_unique[4];
 	u32        asso_type;
 	u32        phy_port_num;
@@ -891,7 +897,7 @@ struct fc_rnid_general_topology_data_s{
 	u32        vendor_specific:16;
 };
 
-struct fc_rnid_acc_s{
+struct fc_rnid_acc_s {
 	struct fc_els_cmd_s    els_cmd;
 	u32        node_id_data_format:8;
 	u32        common_id_data_length:8;
@@ -915,7 +921,7 @@ struct fc_rnid_acc_s{
 #define RNID_ASSOCIATED_TYPE_VIRTUALIZATION_DEVICE      0x00000003
 #define RNID_ASSOCIATED_TYPE_MULTI_FUNCTION_DEVICE      0x000000FF
 
-enum fc_rpsc_speed_cap{
+enum fc_rpsc_speed_cap {
 	RPSC_SPEED_CAP_1G = 0x8000,
 	RPSC_SPEED_CAP_2G = 0x4000,
 	RPSC_SPEED_CAP_4G = 0x2000,
@@ -926,7 +932,7 @@ enum fc_rpsc_speed_cap{
 	RPSC_SPEED_CAP_UNKNOWN = 0x0001,
 };
 
-enum fc_rpsc_op_speed_s{
+enum fc_rpsc_op_speed_s {
 	RPSC_OP_SPEED_1G = 0x8000,
 	RPSC_OP_SPEED_2G = 0x4000,
 	RPSC_OP_SPEED_4G = 0x2000,
@@ -937,24 +943,24 @@ enum fc_rpsc_op_speed_s{
 	RPSC_OP_SPEED_NOT_EST = 0x0001,	/*! speed not established */
 };
 
-struct fc_rpsc_speed_info_s{
-	u16        port_speed_cap;	/*! see fc_rpsc_speed_cap_t */
-	u16        port_op_speed;	/*! see fc_rpsc_op_speed_t */
+struct fc_rpsc_speed_info_s {
+	u16        port_speed_cap;	/*! see struct fc_rpsc_speed_cap */
+	u16        port_op_speed;	/*! see enum fc_rpsc_op_speed_s */
 };
 
-enum link_e2e_beacon_subcmd{
+enum link_e2e_beacon_subcmd {
 	LINK_E2E_BEACON_ON = 1,
 	LINK_E2E_BEACON_OFF = 2
 };
 
-enum beacon_type{
+enum beacon_type {
 	BEACON_TYPE_NORMAL	= 1,	/*! Normal Beaconing. Green */
 	BEACON_TYPE_WARN	= 2,	/*! Warning Beaconing. Yellow/Amber */
 	BEACON_TYPE_CRITICAL	= 3	/*! Critical Beaconing. Red */
 };
 
 struct link_e2e_beacon_param_s {
-	u8         beacon_type;	/* Beacon Type. See beacon_type_t */
+	u8         beacon_type;	/* Beacon Type. See enum beacon_type */
 	u8         beacon_frequency;
 					/* Beacon frequency. Number of blinks
 					 * per 10 seconds
@@ -975,10 +981,10 @@ struct link_e2e_beacon_param_s {
 /*
  * Link E2E beacon request/good response format. For LS_RJTs use fc_ls_rjt_t
  */
-struct link_e2e_beacon_req_s{
+struct link_e2e_beacon_req_s {
 	u32        ls_code;	/*! FC_ELS_E2E_LBEACON in requests *
 					 *or FC_ELS_ACC in good replies */
-	u32        ls_sub_cmd;	/*! See link_e2e_beacon_subcmd_t */
+	u32        ls_sub_cmd;	/*! See enum link_e2e_beacon_subcmd */
 	struct link_e2e_beacon_param_s beacon_parm;
 };
 
@@ -987,14 +993,14 @@ struct link_e2e_beacon_req_s{
  * all the ports within that domain (TODO - I don't think FOS implements
  * this...).
  */
-struct fc_rpsc_cmd_s{
+struct fc_rpsc_cmd_s {
 	struct fc_els_cmd_s    els_cmd;
 };
 
 /*
  * RPSC Acc
  */
-struct fc_rpsc_acc_s{
+struct fc_rpsc_acc_s {
 	u32        command:8;
 	u32        rsvd:8;
 	u32        num_entries:16;
@@ -1007,7 +1013,7 @@ struct fc_rpsc_acc_s{
  */
 #define FC_BRCD_TOKEN    0x42524344
 
-struct fc_rpsc2_cmd_s{
+struct fc_rpsc2_cmd_s {
 	struct fc_els_cmd_s    els_cmd;
 	u32       	token;
 	u16     	resvd;
@@ -1018,18 +1024,17 @@ struct fc_rpsc2_cmd_s{
 	} pid_list[1];
 };
 
-enum fc_rpsc2_port_type{
+enum fc_rpsc2_port_type {
 	RPSC2_PORT_TYPE_UNKNOWN = 0,
 	RPSC2_PORT_TYPE_NPORT   = 1,
 	RPSC2_PORT_TYPE_NLPORT  = 2,
 	RPSC2_PORT_TYPE_NPIV_PORT  = 0x5f,
 	RPSC2_PORT_TYPE_NPORT_TRUNK  = 0x6f,
 };
-
 /*
  * RPSC2 portInfo entry structure
  */
-struct fc_rpsc2_port_info_s{
+struct fc_rpsc2_port_info_s {
     u32    pid;        /* PID */
     u16    resvd1;
     u16    index;      /* port number / index */
@@ -1041,17 +1046,17 @@ struct fc_rpsc2_port_info_s{
 /*
  * RPSC2 Accept payload
  */
-struct fc_rpsc2_acc_s{
+struct fc_rpsc2_acc_s {
 	u8        els_cmd;
 	u8        resvd;
-	u16       num_pids;  /* Number of pids in the request */
-	struct fc_rpsc2_port_info_s  port_info[1];    /* port information */
+    u16       num_pids;  /* Number of pids in the request */
+    struct fc_rpsc2_port_info_s  port_info[1];    /* port information */
 };
 
 /**
  * bit fields so that multiple classes can be specified
  */
-enum fc_cos{
+enum fc_cos {
 	FC_CLASS_2	= 0x04,
 	FC_CLASS_3	= 0x08,
 	FC_CLASS_2_3	= 0x0C,
@@ -1060,11 +1065,11 @@ enum fc_cos{
 /*
  * symbolic name
  */
-struct fc_symname_s{
+struct fc_symname_s {
 	u8         symname[FC_SYMNAME_MAX];
 };
 
-struct fc_alpabm_s{
+struct fc_alpabm_s {
 	u8         alpa_bm[FC_ALPA_MAX / 8];
 };
 
@@ -1088,7 +1093,7 @@ struct fc_alpabm_s{
  * Virtual Fabric Tagging header format
  * @caution This is defined only in BIG ENDIAN format.
  */
-struct fc_vft_s{
+struct fc_vft_s {
 	u32        r_ctl:8;
 	u32        ver:2;
 	u32        type:4;
diff -uprN a/drivers/scsi/bfa/include/protocol/fc_sp.h b/drivers/scsi/bfa/include/protocol/fc_sp.h
--- a/drivers/scsi/bfa/include/protocol/fc_sp.h	2009-12-18 18:16:22.281754000 -0800
+++ b/drivers/scsi/bfa/include/protocol/fc_sp.h	2009-11-25 18:23:58.000000000 -0800
@@ -22,7 +22,7 @@
 
 #pragma pack(1)
 
-enum auth_els_flags{
+enum auth_els_flags {
 	FC_AUTH_ELS_MORE_FRAGS_FLAG 	= 0x80,	/*! bit-7. More Fragments
 						 * Follow
 						 */
@@ -30,7 +30,7 @@ enum auth_els_flags{
 	FC_AUTH_ELS_SEQ_NUM_FLAG 	= 0x01 	/*! bit-0. Sequence Number */
 };
 
-enum auth_msg_codes{
+enum auth_msg_codes {
 	FC_AUTH_MC_AUTH_RJT		= 0x0A,	/*! Auth Reject */
 	FC_AUTH_MC_AUTH_NEG 		= 0x0B, /*! Auth Negotiate */
 	FC_AUTH_MC_AUTH_DONE 		= 0x0C, /*! Auth Done */
@@ -53,7 +53,7 @@ enum auth_msg_codes{
 	FC_AUTH_MC_IKE_INFO 		= 0x25, /*! IKE informational */
 };
 
-enum auth_proto_version{
+enum auth_proto_version {
 	FC_AUTH_PROTO_VER_1 	= 1,	/*! Protocol Version 1 */
 };
 
@@ -77,7 +77,7 @@ enum {
 	FC_START_TXN_ID         = 2,	/*! Starting transaction ID */
 };
 
-enum auth_proto_id{
+enum auth_proto_id {
 	FC_AUTH_PROTO_DHCHAP		= 0x00000001,
 	FC_AUTH_PROTO_FCAP 		= 0x00000002,
 	FC_AUTH_PROTO_FCPAP 		= 0x00000003,
@@ -85,20 +85,19 @@ enum auth_proto_id{
 	FC_AUTH_PROTO_IKEv2_AUTH 	= 0x00000005,
 };
 
-struct auth_name_s{
+struct auth_name_s {
 	u16	name_tag;	/*! Name Tag = 1 for Authentication */
 	u16	name_len;	/*! Name Length = 8 for Authentication
 					 */
 	wwn_t		name;  		/*! Name. TODO - is this PWWN */
 };
 
-
-enum auth_hash_func{
+enum auth_hash_func {
 	FC_AUTH_HASH_FUNC_MD5 		= 0x00000005,
 	FC_AUTH_HASH_FUNC_SHA_1 	= 0x00000006,
 };
 
-enum auth_dh_gid{
+enum auth_dh_gid {
 	FC_AUTH_DH_GID_0_DHG_NULL	= 0x00000000,
 	FC_AUTH_DH_GID_1_DHG_1024	= 0x00000001,
 	FC_AUTH_DH_GID_2_DHG_1280	= 0x00000002,
@@ -127,7 +126,6 @@ enum auth_neg_param_tags {
 	FC_AUTH_NEG_DHCHAP_DHG_ID_LIST 	= 0x0002,
 };
 
-
 struct dhchap_param_format_s {
 	u16	tag;		/*! Parameter Tag. See
 					 * auth_neg_param_tags_t
@@ -148,11 +146,11 @@ struct auth_proto_params_s {
 };
 
 struct auth_neg_msg_s {
-	struct auth_name_s	auth_ini_name;
+	struct auth_name_s		auth_ini_name;
 	u32		usable_auth_protos;
-	struct auth_proto_params_s proto_params[1]; /*! (1..usable_auth_proto)
-						     * protocol params
-						     */
+	struct auth_proto_params_s proto_params[1];/*! (1..usable_auth_proto)
+						    * protocol params
+						    */
 };
 
 struct auth_dh_val_s {
@@ -173,7 +171,6 @@ struct auth_dhchap_chal_msg_s {
 	/* ...followed by variable Challenge length/value and DH length/value */
 };
 
-
 enum auth_rjt_codes {
 	FC_AUTH_RJT_CODE_AUTH_FAILURE 	= 0x01,
 	FC_AUTH_RJT_CODE_LOGICAL_ERR	= 0x02,
@@ -184,7 +181,7 @@ enum auth_rjt_code_exps {
 	FC_AUTH_CEXP_DH_GROUP_NOT_USABLE 	= 0x02,
 	FC_AUTH_CEXP_HASH_FUNC_NOT_USABLE 	= 0x03,
 	FC_AUTH_CEXP_AUTH_XACT_STARTED		= 0x04,
-	FC_AUTH_CEXP_AUTH_FAILED 		= 0x05,
+	FC_AUTH_CEXP_AUTH_FAILED 			= 0x05,
 	FC_AUTH_CEXP_INCORRECT_PLD 		= 0x06,
 	FC_AUTH_CEXP_INCORRECT_PROTO_MSG 	= 0x07,
 	FC_AUTH_CEXP_RESTART_AUTH_PROTO 	= 0x08,
diff -uprN a/drivers/scsi/bfa/include/protocol/fcp.h b/drivers/scsi/bfa/include/protocol/fcp.h
--- a/drivers/scsi/bfa/include/protocol/fcp.h	2009-12-18 18:16:22.279758000 -0800
+++ b/drivers/scsi/bfa/include/protocol/fcp.h	2009-11-25 18:23:58.000000000 -0800
@@ -31,7 +31,7 @@ enum {
 /*
  * SRR FC-4 LS payload
  */
-struct fc_srr_s{
+struct fc_srr_s {
 	u32	ls_cmd;
 	u32        ox_id:16;	/* ox-id */
 	u32        rx_id:16;	/* rx-id */
@@ -40,14 +40,13 @@ struct fc_srr_s{
 	u32        res:24;
 };
 
-
 /*
  * FCP_CMND definitions
  */
 #define FCP_CMND_CDB_LEN    16
 #define FCP_CMND_LUN_LEN    8
 
-struct fcp_cmnd_s{
+struct fcp_cmnd_s {
 	lun_t           lun;		/* 64-bit LU number */
 	u8         crn;		/* command reference number */
 #ifdef __BIGENDIAN
@@ -81,7 +80,7 @@ struct fcp_cmnd_s{
 /*
  * fcp_cmnd_t.iodir field values
  */
-enum fcp_iodir{
+enum fcp_iodir {
 	FCP_IODIR_NONE	= 0,
 	FCP_IODIR_WRITE = 1,
 	FCP_IODIR_READ	= 2,
@@ -105,7 +104,7 @@ enum {
 #ifndef BIT
 #define BIT(_x)	(1 << (_x))
 #endif
-enum fcp_tm_cmnd{
+enum fcp_tm_cmnd {
 	FCP_TM_ABORT_TASK_SET	= BIT(1),
 	FCP_TM_CLEAR_TASK_SET	= BIT(2),
 	FCP_TM_LUN_RESET	= BIT(4),
@@ -116,7 +115,7 @@ enum fcp_tm_cmnd{
 /*
  * FCP_XFER_RDY IU defines
  */
-struct fcp_xfer_rdy_s{
+struct fcp_xfer_rdy_s {
 	u32        data_ro;
 	u32        burst_len;
 	u32        reserved;
@@ -125,7 +124,7 @@ struct fcp_xfer_rdy_s{
 /*
  * FCP_RSP residue flags
  */
-enum fcp_residue{
+enum fcp_residue {
 	FCP_NO_RESIDUE = 0,	/* no residue */
 	FCP_RESID_OVER = 1,	/* more data left that was not sent */
 	FCP_RESID_UNDER = 2,	/* less data than requested */
@@ -140,13 +139,13 @@ enum {
 	FCP_RSPINFO_TM_FAILED = 5,
 };
 
-struct fcp_rspinfo_s{
+struct fcp_rspinfo_s {
 	u32        res0:24;
 	u32        rsp_code:8;	/* response code (as above) */
 	u32        res1;
 };
 
-struct fcp_resp_s{
+struct fcp_resp_s {
 	u32        reserved[2];	/* 2 words reserved */
 	u16        reserved2;
 #ifdef __BIGENDIAN
@@ -176,7 +175,7 @@ struct fcp_resp_s{
 #define fcp_snsinfo(__fcprsp)	(((u8 *)fcp_rspinfo(__fcprsp)) + 	\
 						fcp_rsplen(__fcprsp))
 
-struct fcp_cmnd_fr_s{
+struct fcp_cmnd_fr_s {
 	struct fchs_s          fchs;
 	struct fcp_cmnd_s      fcp;
 };
diff -uprN a/drivers/scsi/bfa/include/protocol/fdmi.h b/drivers/scsi/bfa/include/protocol/fdmi.h
--- a/drivers/scsi/bfa/include/protocol/fdmi.h	2009-12-18 18:16:22.278751000 -0800
+++ b/drivers/scsi/bfa/include/protocol/fdmi.h	2009-11-25 18:23:58.000000000 -0800
@@ -112,7 +112,7 @@ struct fdmi_attr_s {
  * HBA Attribute Block
  */
 struct fdmi_hba_attr_s {
-	u32        attr_count;	/* # of attributes */
+	u32        attr_count;		/* # of attributes */
 	struct fdmi_attr_s     hba_attr;	/* n attributes */
 };
 
@@ -128,7 +128,7 @@ struct fdmi_port_list_s {
  * Port Attribute Block
  */
 struct fdmi_port_attr_s {
-	u32        attr_count;	/* # of attributes */
+	u32        attr_count;		/* # of attributes */
 	struct fdmi_attr_s     port_attr;	/* n attributes */
 };
 
@@ -136,7 +136,7 @@ struct fdmi_port_attr_s {
  * FDMI Register HBA Attributes
  */
 struct fdmi_rhba_s {
-	wwn_t           hba_id;		/* HBA Identifier */
+	wwn_t           hba_id;			/* HBA Identifier */
 	struct fdmi_port_list_s port_list;	/* Registered Port List */
 	struct fdmi_hba_attr_s hba_attr_blk;	/* HBA attribute block */
 };
@@ -145,8 +145,8 @@ struct fdmi_rhba_s {
  * FDMI Register Port
  */
 struct fdmi_rprt_s {
-	wwn_t           hba_id;		/* HBA Identifier */
-	wwn_t           port_name;	/* Port wwn */
+	wwn_t           hba_id;			/* HBA Identifier */
+	wwn_t           port_name;		/* Port wwn */
 	struct fdmi_port_attr_s port_attr_blk;	/* Port Attr Block */
 };
 
@@ -154,7 +154,7 @@ struct fdmi_rprt_s {
  * FDMI Register Port Attributes
  */
 struct fdmi_rpa_s {
-	wwn_t           port_name;	/* port wwn */
+	wwn_t           port_name;		/* port wwn */
 	struct fdmi_port_attr_s port_attr_blk;	/* Port Attr Block */
 };
 
diff -uprN a/drivers/scsi/bfa/include/protocol/pcifw.h b/drivers/scsi/bfa/include/protocol/pcifw.h
--- a/drivers/scsi/bfa/include/protocol/pcifw.h	2009-12-18 18:16:22.276754000 -0800
+++ b/drivers/scsi/bfa/include/protocol/pcifw.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,75 +0,0 @@
-/*
- * Copyright (c) 2005-2009 Brocade Communications Systems, Inc.
- * All rights reserved
- * www.brocade.com
- *
- * Linux driver for Brocade Fibre Channel Host Bus Adapter.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License (GPL) Version 2 as
- * published by the Free Software Foundation
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- */
-
-/**
- *  pcifw.h PCI FW related headers
- */
-
-#ifndef __PCIFW_H__
-#define __PCIFW_H__
-
-#pragma pack(1)
-
-struct pnp_hdr_s{
-  u32	signature;	/* "$PnP" */
-  u8	rev;		/* Struct revision */
-  u8 	len;		/* Header structure len in multiples
-				 * of 16 bytes */
-  u16  off;		/* Offset to next header 00 if none */
-  u8	rsvd;		/* Reserved byte */
-  u8	cksum;		/* 8-bit checksum for this header */
-  u32	pnp_dev_id;	/* PnP Device Id */
-  u16  mfstr;		/* Pointer to manufacturer string */
-  u16	prstr;		/* Pointer to product string */
-  u8	devtype[3];	/* Device Type Code */
-  u8	devind;		/* Device Indicator */
-  u16	bcventr;	/* Bootstrap entry vector */
-  u16	rsvd2;		/* Reserved */
-  u16  sriv;		/* Static resource information vector */
-};
-
-struct pci_3_0_ds_s{
- u32	sig;   		/* Signature "PCIR" */
- u16	vendid;		/* Vendor ID */
- u16	devid;		/* Device ID */
- u16	devlistoff;	/* Device List Offset */
- u16	len;		/* PCI Data Structure Length */
- u8	rev;		/* PCI Data Structure Revision */
- u8	clcode[3];	/* Class Code */
- u16	imglen;		/* Code image length in multiples of
-				 * 512 bytes */
- u16	coderev;	/* Revision level of code/data */
- u8	codetype;	/* Code type 0x00 - BIOS */
- u8	indr;		/* Last image indicator */
- u16	mrtimglen;	/* Max Run Time Image Length */
- u16	cuoff;		/* Config Utility Code Header Offset */
- u16	dmtfclp;	/* DMTF CLP entry point offset */
-};
-
-struct pci_optrom_hdr_s{
- u16	sig;		/* Signature 0x55AA */
- u8	len;		/* Option ROM length in units of 512 bytes */
- u8	inivec[3];	/* Initialization vector */
- u8	rsvd[16];	/* Reserved field */
- u16	verptr;		/* Pointer to version string - private */
- u16	pcids;		/* Pointer to PCI data structure */
- u16	pnphdr;		/* Pointer to PnP expansion header */
-};
-
-#pragma pack()
-
-#endif
diff -uprN a/drivers/scsi/bfa/include/protocol/scsi.h b/drivers/scsi/bfa/include/protocol/scsi.h
--- a/drivers/scsi/bfa/include/protocol/scsi.h	2009-12-18 18:16:22.274760000 -0800
+++ b/drivers/scsi/bfa/include/protocol/scsi.h	2009-11-25 18:23:58.000000000 -0800
@@ -26,7 +26,7 @@
  * generic SCSI cdb definition
  */
 #define SCSI_MAX_CDBLEN     16
-struct scsi_cdb_s{
+struct scsi_cdb_s {
 	u8         scsi_cdb[SCSI_MAX_CDBLEN];
 };
 
@@ -34,7 +34,7 @@ struct scsi_cdb_s{
  * scsi lun serial number definition
  */
 #define SCSI_LUN_SN_LEN     32
-struct scsi_lun_sn_s{
+struct scsi_lun_sn_s {
 	u8         lun_sn[SCSI_LUN_SN_LEN];
 };
 
@@ -81,7 +81,7 @@ enum {
 /*
  * SCSI START_STOP_UNIT command
  */
-struct scsi_start_stop_unit_s{
+struct scsi_start_stop_unit_s {
 	u8         opcode;
 #ifdef __BIGENDIAN
 	u8         lun:3;
@@ -111,7 +111,7 @@ struct scsi_start_stop_unit_s{
 /*
  * SCSI SEND_DIAGNOSTIC command
  */
-struct scsi_send_diagnostic_s{
+struct scsi_send_diagnostic_s {
 	u8         opcode;
 #ifdef __BIGENDIAN
 	u8         self_test_code:3;
@@ -138,7 +138,7 @@ struct scsi_send_diagnostic_s{
 /*
  * SCSI READ10/WRITE10 commands
  */
-struct scsi_rw10_s{
+struct scsi_rw10_s {
 	u8         opcode;
 #ifdef __BIGENDIAN
 	u8         lun:3;
@@ -184,7 +184,7 @@ struct scsi_rw10_s{
 /*
  * SCSI READ6/WRITE6 commands
  */
-struct scsi_rw6_s{
+struct scsi_rw6_s {
 	u8         opcode;
 #ifdef __BIGENDIAN
 	u8         lun:3;
@@ -211,7 +211,7 @@ struct scsi_rw6_s{
 /*
  * SCSI sequential (TAPE) wrtie command
  */
-struct scsi_tape_wr_s{
+struct scsi_tape_wr_s {
 	u8         opcode;
 #ifdef __BIGENDIAN
 	u8         rsvd:7;
@@ -244,7 +244,7 @@ struct scsi_tape_wr_s{
 /*
  * SCSI sense data format
  */
-struct scsi_sense_s{
+struct scsi_sense_s {
 #ifdef __BIGENDIAN
 	u8         valid:1;
 	u8         rsp_code:7;
@@ -386,7 +386,7 @@ struct scsi_sense_s{
  * SCSI INQUIRY
  * ------------------------------------------------------------*/
 
-struct scsi_inquiry_s{
+struct scsi_inquiry_s {
 	u8         opcode;
 #ifdef __BIGENDIAN
 	u8         lun:3;
@@ -405,19 +405,19 @@ struct scsi_inquiry_s{
 	u8         control;
 };
 
-struct scsi_inquiry_vendor_s{
+struct scsi_inquiry_vendor_s {
 	u8         vendor_id[8];
 };
 
-struct scsi_inquiry_prodid_s{
+struct scsi_inquiry_prodid_s {
 	u8         product_id[16];
 };
 
-struct scsi_inquiry_prodrev_s{
+struct scsi_inquiry_prodrev_s {
 	u8         product_rev[4];
 };
 
-struct scsi_inquiry_data_s{
+struct scsi_inquiry_data_s {
 #ifdef __BIGENDIAN
 	u8         peripheral_qual:3;	/* peripheral qualifier */
 	u8         device_type:5;		/* peripheral device type */
@@ -541,7 +541,7 @@ struct scsi_inquiry_data_s{
 /*
  * supported vital product data pages
  */
-struct scsi_inq_page_vpd_pages_s{
+struct scsi_inq_page_vpd_pages_s {
 #ifdef __BIGENDIAN
 	u8         peripheral_qual:3;
 	u8         device_type:5;
@@ -560,11 +560,11 @@ struct scsi_inq_page_vpd_pages_s{
  */
 #define SCSI_INQ_USN_LEN 32
 
-struct scsi_inq_usn_s{
+struct scsi_inq_usn_s {
 	char            usn[SCSI_INQ_USN_LEN];
 };
 
-struct scsi_inq_page_usn_s{
+struct scsi_inq_page_usn_s {
 #ifdef __BIGENDIAN
 	u8         peripheral_qual:3;
 	u8         device_type:5;
@@ -597,7 +597,7 @@ enum {
 	SCSI_INQ_ID_TYPE_OTHER = 4,
 };
 
-struct scsi_inq_dip_desc_s{
+struct scsi_inq_dip_desc_s {
 #ifdef __BIGENDIAN
 	u8         res0:4;
 	u8         code_set:4;
@@ -619,7 +619,7 @@ struct scsi_inq_dip_desc_s{
 /*
  * Device indentification page
  */
-struct scsi_inq_page_dev_ident_s{
+struct scsi_inq_page_dev_ident_s {
 #ifdef __BIGENDIAN
 	u8         peripheral_qual:3;
 	u8         device_type:5;
@@ -638,7 +638,7 @@ struct scsi_inq_page_dev_ident_s{
  * ------------------------------------------------------------
  */
 
-struct scsi_read_capacity_s{
+struct scsi_read_capacity_s {
 	u8         opcode;
 #ifdef __BIGENDIAN
 	u8         lun:3;
@@ -665,12 +665,12 @@ struct scsi_read_capacity_s{
 	u8         control;
 };
 
-struct scsi_read_capacity_data_s{
+struct scsi_read_capacity_data_s {
 	u32        max_lba;	/* maximum LBA available */
 	u32        block_length;	/* in bytes */
 };
 
-struct scsi_read_capacity16_data_s{
+struct scsi_read_capacity16_data_s {
 	u64        lba;	/* maximum LBA available */
 	u32        block_length;	/* in bytes */
 #ifdef __BIGENDIAN
@@ -678,18 +678,19 @@ struct scsi_read_capacity16_data_s{
 			p_type:3,
 			prot_en:1;
 	u8		reserved2:4,
-			lb_pbe:4;	/* logical blocks per physical block
-					 * exponent */
+			lb_pbe:4;	/* logical blocks per
+					 * physical block exponent */
 	u16	reserved3:2,
-			lba_align:14;	/* lowest aligned logical block
-					 * address */
+			lba_align:14;	/* lowest aligned logical
+					 * block address */
 #else
-	u16	lba_align:14,	/* lowest aligned logical block
-					 * address */
-			reserved3:2;
-	u8		lb_pbe:4,	/* logical blocks per physical block
-					 * exponent */
-			reserved2:4;
+	u16	lba_align:14,
+			reserved3:2;	/* lowest aligned logical
+					 * block address */
+
+	u8		lb_pbe:4,
+			reserved2:4;	/* logical blocks per
+					 * physical block exponent */
 	u8		prot_en:1,
 			p_type:3,
 			reserved1:4;
@@ -703,7 +704,7 @@ struct scsi_read_capacity16_data_s{
  * ------------------------------------------------------------
  */
 
-struct scsi_report_luns_s{
+struct scsi_report_luns_s {
 	u8         opcode;		/* A0h - REPORT LUNS opCode */
 	u8         reserved1[5];
 	u8         alloc_length[4];/* allocation length MSB first */
@@ -722,7 +723,7 @@ struct scsi_report_luns_s{
     (rl)->alloc_length[3] = (alloc_len) & 0xFF;     			\
 }
 
-struct scsi_report_luns_data_s{
+struct scsi_report_luns_data_s {
 	u32        lun_list_length;	/* length of LUN list length */
 	u32        reserved;
 	lun_t           lun[1];			/* first LUN in lun list */
@@ -741,7 +742,7 @@ enum {
 /*
  * SCSI Mode Select(6) cdb
  */
-struct scsi_mode_select6_s{
+struct scsi_mode_select6_s {
 	u8         opcode;
 #ifdef __BIGENDIAN
 	u8         reserved1:3;
@@ -762,7 +763,7 @@ struct scsi_mode_select6_s{
 /*
  * SCSI Mode Select(10) cdb
  */
-struct scsi_mode_select10_s{
+struct scsi_mode_select10_s {
 	u8         opcode;
 #ifdef __BIGENDIAN
 	u8         reserved1:3;
@@ -784,7 +785,7 @@ struct scsi_mode_select10_s{
 /*
  * SCSI Mode Sense(6) cdb
  */
-struct scsi_mode_sense6_s{
+struct scsi_mode_sense6_s {
 	u8         opcode;
 #ifdef __BIGENDIAN
 	u8         reserved1:4;
@@ -809,7 +810,7 @@ struct scsi_mode_sense6_s{
 /*
  * SCSI Mode Sense(10) cdb
  */
-struct scsi_mode_sense10_s{
+struct scsi_mode_sense10_s {
 	u8         opcode;
 #ifdef __BIGENDIAN
 	u8         reserved1:3;
@@ -877,7 +878,7 @@ struct scsi_mode_sense10_s{
 /*
  * mode parameter header
  */
-struct scsi_mode_param_header6_s{
+struct scsi_mode_param_header6_s {
 	u8         mode_datalen;
 	u8         medium_type;
 
@@ -901,7 +902,7 @@ struct scsi_mode_param_header6_s{
 	u8         block_desclen;
 };
 
-struct scsi_mode_param_header10_s{
+struct scsi_mode_param_header10_s {
 	u32        mode_datalen:16;
 	u32        medium_type:8;
 
@@ -936,7 +937,7 @@ struct scsi_mode_param_header10_s{
 /*
  * mode parameter block descriptor
  */
-struct scsi_mode_param_desc_s{
+struct scsi_mode_param_desc_s {
 	u32        nblks;
 	u32        density_code:8;
 	u32        block_length:24;
@@ -945,7 +946,7 @@ struct scsi_mode_param_desc_s{
 /*
  * Disconnect-reconnect mode page format
  */
-struct scsi_mp_disc_recn_s{
+struct scsi_mp_disc_recn_s {
 #ifdef __BIGENDIAN
 	u8         ps:1;
 	u8         reserved1:1;
@@ -991,7 +992,7 @@ struct scsi_mp_disc_recn_s{
 /*
  * SCSI format device mode page
  */
-struct scsi_mp_format_device_s{
+struct scsi_mp_format_device_s {
 #ifdef __BIGENDIAN
 	u32        ps:1;
 	u32        reserved1:1;
@@ -1035,7 +1036,7 @@ struct scsi_mp_format_device_s{
 /*
  * SCSI rigid disk device geometry page
  */
-struct scsi_mp_rigid_device_geometry_s{
+struct scsi_mp_rigid_device_geometry_s {
 #ifdef __BIGENDIAN
 	u32        ps:1;
 	u32        reserved1:1;
@@ -1081,7 +1082,7 @@ struct scsi_mp_rigid_device_geometry_s{
 /*
  * SCSI caching mode page
  */
-struct scsi_mp_caching_s{
+struct scsi_mp_caching_s {
 #ifdef __BIGENDIAN
 	u8         ps:1;
 	u8         res1:1;
@@ -1144,7 +1145,7 @@ struct scsi_mp_caching_s{
 /*
  * SCSI control mode page
  */
-struct scsi_mp_control_page_s{
+struct scsi_mp_control_page_s {
 #ifdef __BIGENDIAN
 u8         ps:1;
 u8         reserved1:1;
@@ -1211,7 +1212,7 @@ u8         ps:1;
 /*
  * SCSI medium types supported mode page
  */
-struct scsi_mp_medium_types_sup_s{
+struct scsi_mp_medium_types_sup_s {
 #ifdef __BIGENDIAN
 	u8         ps:1;
 	u8         reserved1:1;
@@ -1233,7 +1234,7 @@ struct scsi_mp_medium_types_sup_s{
 /*
  * SCSI informational exception control mode page
  */
-struct scsi_mp_info_excpt_cntl_s{
+struct scsi_mp_info_excpt_cntl_s {
 #ifdef __BIGENDIAN
 	u8         ps:1;
 	u8         reserved1:1;
@@ -1302,7 +1303,7 @@ struct scsi_mp_info_excpt_cntl_s{
 /*
  * SCSI flexible disk page
  */
-struct scsi_mp_flexible_disk_s{
+struct scsi_mp_flexible_disk_s {
 #ifdef __BIGENDIAN
 	u8         ps:1;
 	u8         reserved1:1;
@@ -1388,42 +1389,42 @@ struct scsi_mp_flexible_disk_s{
 	u8         reserved5[2];
 };
 
-struct scsi_mode_page_format_data6_s{
+struct scsi_mode_page_format_data6_s {
 	struct scsi_mode_param_header6_s mph;	/* mode page header */
 	struct scsi_mode_param_desc_s desc;	/* block descriptor */
 	struct scsi_mp_format_device_s format;	/* format device data */
 };
 
-struct scsi_mode_page_format_data10_s{
+struct scsi_mode_page_format_data10_s {
 	struct scsi_mode_param_header10_s mph;	/* mode page header */
 	struct scsi_mode_param_desc_s desc;	/* block descriptor */
 	struct scsi_mp_format_device_s format;	/* format device data */
 };
 
-struct scsi_mode_page_rdg_data6_s{
+struct scsi_mode_page_rdg_data6_s {
 	struct scsi_mode_param_header6_s mph;	/* mode page header */
 	struct scsi_mode_param_desc_s desc;	/* block descriptor */
 	struct scsi_mp_rigid_device_geometry_s rdg;
-					/* rigid geometry data */
+						/* rigid geometry data */
 };
 
-struct scsi_mode_page_rdg_data10_s{
+struct scsi_mode_page_rdg_data10_s {
 	struct scsi_mode_param_header10_s mph;	/* mode page header */
 	struct scsi_mode_param_desc_s desc;	/* block descriptor */
 	struct scsi_mp_rigid_device_geometry_s rdg;
-					/* rigid geometry data */
+						/* rigid geometry data */
 };
 
-struct scsi_mode_page_cache6_s{
+struct scsi_mode_page_cache6_s {
 	struct scsi_mode_param_header6_s mph;	/* mode page header */
 	struct scsi_mode_param_desc_s desc;	/* block descriptor */
-	struct scsi_mp_caching_s cache;	/* cache page data */
+	struct scsi_mp_caching_s cache;		/* cache page data */
 };
 
-struct scsi_mode_page_cache10_s{
+struct scsi_mode_page_cache10_s {
 	struct scsi_mode_param_header10_s mph;	/* mode page header */
 	struct scsi_mode_param_desc_s desc;	/* block descriptor */
-	struct scsi_mp_caching_s cache;	/* cache page data */
+	struct scsi_mp_caching_s cache;		/* cache page data */
 };
 
 /* --------------------------------------------------------------
@@ -1434,7 +1435,7 @@ struct scsi_mode_page_cache10_s{
 /*
  * Format Unit CDB
  */
-struct scsi_format_unit_s{
+struct scsi_format_unit_s {
 	u8         opcode;
 #ifdef __BIGENDIAN
 	u8         res1:3;
@@ -1464,7 +1465,7 @@ struct scsi_format_unit_s{
 /*
  * h
  */
-struct scsi_reserve6_s{
+struct scsi_reserve6_s {
 	u8         opcode;
 #ifdef __BIGENDIAN
 	u8         reserved:3;
@@ -1483,7 +1484,7 @@ struct scsi_reserve6_s{
 /*
  * h
  */
-struct scsi_release6_s{
+struct scsi_release6_s {
 	u8         opcode;
 #ifdef __BIGENDIAN
 	u8         reserved1:3;
@@ -1502,7 +1503,7 @@ struct scsi_release6_s{
 /*
  * h
  */
-struct scsi_reserve10_s{
+struct scsi_reserve10_s {
 	u8         opcode;
 #ifdef __BIGENDIAN
 	u8         reserved1:3;
@@ -1526,7 +1527,7 @@ struct scsi_reserve10_s{
 	u8         control;
 };
 
-struct scsi_release10_s{
+struct scsi_release10_s {
 	u8         opcode;
 #ifdef __BIGENDIAN
 	u8         reserved1:3;
@@ -1550,7 +1551,7 @@ struct scsi_release10_s{
 	u8         control;
 };
 
-struct scsi_verify10_s{
+struct scsi_verify10_s {
 	u8         opcode;
 #ifdef __BIGENDIAN
 	u8         lun:3;
@@ -1575,7 +1576,7 @@ struct scsi_verify10_s{
 	u8         control_byte;
 };
 
-struct scsi_request_sense_s{
+struct scsi_request_sense_s {
 	u8         opcode;
 #ifdef __BIGENDIAN
 	u8         lun:3;
@@ -1616,7 +1617,7 @@ struct scsi_request_sense_s{
 /*
  * SCSI WRITE-VERIFY(10) command
  */
-struct scsi_write_verify10_s{
+struct scsi_write_verify10_s {
 	u8         opcode;
 #ifdef __BIGENDIAN
 	u8         reserved1:3;
diff -uprN a/drivers/scsi/bfa/include/protocol/types.h b/drivers/scsi/bfa/include/protocol/types.h
--- a/drivers/scsi/bfa/include/protocol/types.h	2009-12-18 18:16:22.272756000 -0800
+++ b/drivers/scsi/bfa/include/protocol/types.h	2009-11-25 18:23:58.000000000 -0800
@@ -35,7 +35,6 @@
 
 #define MAC_ADDRLEN	(6)
 struct mac_s { u8 mac[MAC_ADDRLEN]; };
-#define mac_t struct mac_s
 
 #pragma pack()
 
diff -uprN a/drivers/scsi/bfa/loop.c b/drivers/scsi/bfa/loop.c
--- a/drivers/scsi/bfa/loop.c	2009-12-18 18:16:22.328703000 -0800
+++ b/drivers/scsi/bfa/loop.c	2009-11-25 18:21:07.000000000 -0800
@@ -58,10 +58,10 @@ static const u8   port_loop_alpa_map[] =
 /*
  * Local Functions
  */
-bfa_status_t    bfa_fcs_port_loop_send_plogi(struct bfa_fcs_port_s *port,
+static bfa_status_t    bfa_fcs_port_loop_send_plogi(struct bfa_fcs_port_s *port,
 					     u8 alpa);
 
-void            bfa_fcs_port_loop_plogi_response(void *fcsarg,
+static void            bfa_fcs_port_loop_plogi_response(void *fcsarg,
 						 struct bfa_fcxp_s *fcxp,
 						 void *cbarg,
 						 bfa_status_t req_status,
@@ -69,38 +69,6 @@ void            bfa_fcs_port_loop_plogi_
 						 u32 resid_len,
 						 struct fchs_s *rsp_fchs);
 
-bfa_status_t    bfa_fcs_port_loop_send_adisc(struct bfa_fcs_port_s *port,
-					     u8 alpa);
-
-void            bfa_fcs_port_loop_adisc_response(void *fcsarg,
-						 struct bfa_fcxp_s *fcxp,
-						 void *cbarg,
-						 bfa_status_t req_status,
-						 u32 rsp_len,
-						 u32 resid_len,
-						 struct fchs_s *rsp_fchs);
-
-bfa_status_t    bfa_fcs_port_loop_send_plogi_acc(struct bfa_fcs_port_s *port,
-						 u8 alpa);
-
-void            bfa_fcs_port_loop_plogi_acc_response(void *fcsarg,
-						     struct bfa_fcxp_s *fcxp,
-						     void *cbarg,
-						     bfa_status_t req_status,
-						     u32 rsp_len,
-						     u32 resid_len,
-						     struct fchs_s *rsp_fchs);
-
-bfa_status_t    bfa_fcs_port_loop_send_adisc_acc(struct bfa_fcs_port_s *port,
-						 u8 alpa);
-
-void            bfa_fcs_port_loop_adisc_acc_response(void *fcsarg,
-						     struct bfa_fcxp_s *fcxp,
-						     void *cbarg,
-						     bfa_status_t req_status,
-						     u32 rsp_len,
-						     u32 resid_len,
-						     struct fchs_s *rsp_fchs);
 /**
  *   Called by port to initializar in provate LOOP topology.
  */
@@ -179,7 +147,7 @@ bfa_fcs_port_loop_lip(struct bfa_fcs_por
 /**
  * Local Functions.
  */
-bfa_status_t
+static bfa_status_t
 bfa_fcs_port_loop_send_plogi(struct bfa_fcs_port_s *port, u8 alpa)
 {
 	struct fchs_s          fchs;
@@ -195,7 +163,7 @@ bfa_fcs_port_loop_send_plogi(struct bfa_
 	len = fc_plogi_build(&fchs, bfa_fcxp_get_reqbuf(fcxp), alpa,
 			     bfa_fcs_port_get_fcid(port), 0,
 			     port->port_cfg.pwwn, port->port_cfg.nwwn,
-				 bfa_pport_get_maxfrsize(port->fcs->bfa));
+				 bfa_fcport_get_maxfrsize(port->fcs->bfa));
 
 	bfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,
 			  FC_CLASS_3, len, &fchs,
@@ -208,7 +176,7 @@ bfa_fcs_port_loop_send_plogi(struct bfa_
 /**
  *   Called by fcxp to notify the Plogi response
  */
-void
+static void
 bfa_fcs_port_loop_plogi_response(void *fcsarg, struct bfa_fcxp_s *fcxp,
 				 void *cbarg, bfa_status_t req_status,
 				 u32 rsp_len, u32 resid_len,
@@ -244,179 +212,3 @@ bfa_fcs_port_loop_plogi_response(void *f
 		bfa_assert(0);
 	}
 }
-
-bfa_status_t
-bfa_fcs_port_loop_send_plogi_acc(struct bfa_fcs_port_s *port, u8 alpa)
-{
-	struct fchs_s          fchs;
-	struct bfa_fcxp_s *fcxp;
-	int             len;
-
-	bfa_trc(port->fcs, alpa);
-
-	fcxp = bfa_fcxp_alloc(NULL, port->fcs->bfa, 0, 0, NULL, NULL, NULL,
-				  NULL);
-	bfa_assert(fcxp);
-
-	len = fc_plogi_acc_build(&fchs, bfa_fcxp_get_reqbuf(fcxp), alpa,
-				 bfa_fcs_port_get_fcid(port), 0,
-				 port->port_cfg.pwwn, port->port_cfg.nwwn,
-				 bfa_pport_get_maxfrsize(port->fcs->bfa));
-
-	bfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,
-				 FC_CLASS_3, len, &fchs,
-				 bfa_fcs_port_loop_plogi_acc_response,
-				 (void *)port, FC_MAX_PDUSZ, 0); /* No response
-								  * expected
-								  */
-
-	return BFA_STATUS_OK;
-}
-
-/*
- *  Plogi Acc Response
- * We donot do any processing here.
- */
-void
-bfa_fcs_port_loop_plogi_acc_response(void *fcsarg, struct bfa_fcxp_s *fcxp,
-				     void *cbarg, bfa_status_t req_status,
-				     u32 rsp_len, u32 resid_len,
-				     struct fchs_s *rsp_fchs)
-{
-
-	struct bfa_fcs_port_s *port = (struct bfa_fcs_port_s *) cbarg;
-
-	bfa_trc(port->fcs, port->pid);
-
-	/*
-	 * Sanity Checks
-	 */
-	if (req_status != BFA_STATUS_OK) {
-		bfa_trc(port->fcs, req_status);
-		return;
-	}
-}
-
-bfa_status_t
-bfa_fcs_port_loop_send_adisc(struct bfa_fcs_port_s *port, u8 alpa)
-{
-	struct fchs_s          fchs;
-	struct bfa_fcxp_s *fcxp;
-	int             len;
-
-	bfa_trc(port->fcs, alpa);
-
-	fcxp = bfa_fcxp_alloc(NULL, port->fcs->bfa, 0, 0, NULL, NULL, NULL,
-				  NULL);
-	bfa_assert(fcxp);
-
-	len = fc_adisc_build(&fchs, bfa_fcxp_get_reqbuf(fcxp), alpa,
-			     bfa_fcs_port_get_fcid(port), 0,
-			     port->port_cfg.pwwn, port->port_cfg.nwwn);
-
-	bfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,
-			  FC_CLASS_3, len, &fchs,
-			  bfa_fcs_port_loop_adisc_response, (void *)port,
-			  FC_MAX_PDUSZ, FC_RA_TOV);
-
-	return BFA_STATUS_OK;
-}
-
-/**
- *   Called by fcxp to notify the ADISC response
- */
-void
-bfa_fcs_port_loop_adisc_response(void *fcsarg, struct bfa_fcxp_s *fcxp,
-				 void *cbarg, bfa_status_t req_status,
-				 u32 rsp_len, u32 resid_len,
-				 struct fchs_s *rsp_fchs)
-{
-	struct bfa_fcs_port_s *port = (struct bfa_fcs_port_s *) cbarg;
-	struct bfa_fcs_rport_s *rport;
-	struct fc_adisc_s     *adisc_resp;
-	struct fc_els_cmd_s   *els_cmd;
-	u32        pid = rsp_fchs->s_id;
-
-	bfa_trc(port->fcs, req_status);
-
-	/*
-	 * Sanity Checks
-	 */
-	if (req_status != BFA_STATUS_OK) {
-		/*
-		 * TBD : we may need to retry certain requests
-		 */
-		bfa_fcxp_free(fcxp);
-		return;
-	}
-
-	els_cmd = (struct fc_els_cmd_s *) BFA_FCXP_RSP_PLD(fcxp);
-	adisc_resp = (struct fc_adisc_s *) els_cmd;
-
-	if (els_cmd->els_code == FC_ELS_ACC) {
-	} else {
-		bfa_trc(port->fcs, adisc_resp->els_cmd.els_code);
-
-		/*
-		 * TBD: we may need to check for reject codes and retry
-		 */
-		rport = bfa_fcs_port_get_rport_by_pid(port, pid);
-		if (rport) {
-			list_del(&rport->qe);
-			bfa_fcs_rport_delete(rport);
-		}
-
-	}
-	return;
-}
-
-bfa_status_t
-bfa_fcs_port_loop_send_adisc_acc(struct bfa_fcs_port_s *port, u8 alpa)
-{
-	struct fchs_s          fchs;
-	struct bfa_fcxp_s *fcxp;
-	int             len;
-
-	bfa_trc(port->fcs, alpa);
-
-	fcxp = bfa_fcxp_alloc(NULL, port->fcs->bfa, 0, 0, NULL, NULL, NULL,
-				  NULL);
-	bfa_assert(fcxp);
-
-	len = fc_adisc_acc_build(&fchs, bfa_fcxp_get_reqbuf(fcxp), alpa,
-				 bfa_fcs_port_get_fcid(port), 0,
-				 port->port_cfg.pwwn, port->port_cfg.nwwn);
-
-	bfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,
-				FC_CLASS_3, len, &fchs,
-				bfa_fcs_port_loop_adisc_acc_response,
-				(void *)port, FC_MAX_PDUSZ, 0); /* no reponse
-								 * expected
-								 */
-
-	return BFA_STATUS_OK;
-}
-
-/*
- *  Adisc Acc Response
- * We donot do any processing here.
- */
-void
-bfa_fcs_port_loop_adisc_acc_response(void *fcsarg, struct bfa_fcxp_s *fcxp,
-				     void *cbarg, bfa_status_t req_status,
-				     u32 rsp_len, u32 resid_len,
-				     struct fchs_s *rsp_fchs)
-{
-
-	struct bfa_fcs_port_s *port = (struct bfa_fcs_port_s *) cbarg;
-
-	bfa_trc(port->fcs, port->pid);
-
-	/*
-	 * Sanity Checks
-	 */
-	if (req_status != BFA_STATUS_OK) {
-		bfa_trc(port->fcs, req_status);
-		return;
-	}
-}
diff -uprN a/drivers/scsi/bfa/lport_api.c b/drivers/scsi/bfa/lport_api.c
--- a/drivers/scsi/bfa/lport_api.c	2009-12-18 18:16:22.326706000 -0800
+++ b/drivers/scsi/bfa/lport_api.c	2009-11-25 18:21:07.000000000 -0800
@@ -43,17 +43,20 @@ bfa_fcs_cfg_base_port(struct bfa_fcs_s *
 struct bfa_fcs_port_s *
 bfa_fcs_get_base_port(struct bfa_fcs_s *fcs)
 {
-	return (&fcs->fabric.bport);
+	return &fcs->fabric.bport;
 }
 
 wwn_t
-bfa_fcs_port_get_rport(struct bfa_fcs_port_s *port, wwn_t wwn, int index,
-		       int nrports, bfa_boolean_t bwwn)
+bfa_fcs_port_get_rport(struct bfa_fcs_port_s *port,
+			wwn_t wwn,
+			int index,
+			int nrports,
+			bfa_boolean_t bwwn)
 {
-	struct list_head *qh, *qe;
+	struct list_head        *qh, *qe;
 	struct bfa_fcs_rport_s *rport = NULL;
 	int             i;
-	struct bfa_fcs_s *fcs;
+	struct bfa_fcs_s      *fcs;
 
 	if (port == NULL || nrports == 0)
 		return (wwn_t) 0;
@@ -66,7 +69,7 @@ bfa_fcs_port_get_rport(struct bfa_fcs_po
 	qe = bfa_q_first(qh);
 
 	while ((qe != qh) && (i < nrports)) {
-		rport = (struct bfa_fcs_rport_s *)qe;
+		rport = (struct bfa_fcs_rport_s *) qe;
 		if (bfa_os_ntoh3b(rport->pid) > 0xFFF000) {
 			qe = bfa_q_next(qe);
 			bfa_trc(fcs, (u32) rport->pwwn);
@@ -88,21 +91,21 @@ bfa_fcs_port_get_rport(struct bfa_fcs_po
 	}
 
 	bfa_trc(fcs, i);
-	if (rport) {
+
+	if (rport)
 		return rport->pwwn;
-	} else {
+	else
 		return (wwn_t) 0;
-	}
 }
 
 void
 bfa_fcs_port_get_rports(struct bfa_fcs_port_s *port, wwn_t rport_wwns[],
-			int *nrports)
+				int *nrports)
 {
-	struct list_head *qh, *qe;
+	struct list_head        *qh, *qe;
 	struct bfa_fcs_rport_s *rport = NULL;
 	int             i;
-	struct bfa_fcs_s *fcs;
+	struct bfa_fcs_s      *fcs;
 
 	if (port == NULL || rport_wwns == NULL || *nrports == 0)
 		return;
@@ -115,7 +118,7 @@ bfa_fcs_port_get_rports(struct bfa_fcs_p
 	qe = bfa_q_first(qh);
 
 	while ((qe != qh) && (i < *nrports)) {
-		rport = (struct bfa_fcs_rport_s *)qe;
+		rport = (struct bfa_fcs_rport_s *) qe;
 		if (bfa_os_ntoh3b(rport->pid) > 0xFFF000) {
 			qe = bfa_q_next(qe);
 			bfa_trc(fcs, (u32) rport->pwwn);
@@ -142,11 +145,11 @@ bfa_fcs_port_get_rports(struct bfa_fcs_p
 enum bfa_pport_speed
 bfa_fcs_port_get_rport_max_speed(struct bfa_fcs_port_s *port)
 {
-	struct list_head *qh, *qe;
+	struct list_head  *qh, *qe;
 	struct bfa_fcs_rport_s *rport = NULL;
-	struct bfa_fcs_s *fcs;
+	struct bfa_fcs_s      *fcs;
 	enum bfa_pport_speed max_speed = 0;
-	struct bfa_pport_attr_s pport_attr;
+	struct bfa_pport_attr_s  pport_attr;
 	enum bfa_pport_speed pport_speed;
 
 	if (port == NULL)
@@ -154,10 +157,8 @@ bfa_fcs_port_get_rport_max_speed(struct 
 
 	fcs = port->fcs;
 
-	/*
-	 * Get Physical port's current speed
-	 */
-	bfa_pport_get_attr(port->fcs->bfa, &pport_attr);
+	/* Get Physical port's current speed */
+	bfa_fcport_get_attr(port->fcs->bfa, &pport_attr);
 	pport_speed = pport_attr.speed;
 	bfa_trc(fcs, pport_speed);
 
@@ -165,15 +166,16 @@ bfa_fcs_port_get_rport_max_speed(struct 
 	qe = bfa_q_first(qh);
 
 	while (qe != qh) {
-		rport = (struct bfa_fcs_rport_s *)qe;
-		if ((bfa_os_ntoh3b(rport->pid) > 0xFFF000)
-		    || (bfa_fcs_rport_get_state(rport) == BFA_RPORT_OFFLINE)) {
+		rport = (struct bfa_fcs_rport_s *) qe;
+		if ((bfa_os_ntoh3b(rport->pid) > 0xFFF000) ||
+			(bfa_fcs_rport_get_state(rport) ==
+				BFA_RPORT_OFFLINE)) {
 			qe = bfa_q_next(qe);
 			continue;
 		}
 
-		if ((rport->rpf.rpsc_speed == BFA_PPORT_SPEED_8GBPS)
-		    || (rport->rpf.rpsc_speed > pport_speed)) {
+		if ((rport->rpf.rpsc_speed  == BFA_PPORT_SPEED_8GBPS) ||
+			(rport->rpf.rpsc_speed > pport_speed)) {
 			max_speed = rport->rpf.rpsc_speed;
 			break;
 		} else if (rport->rpf.rpsc_speed > max_speed) {
@@ -198,17 +200,17 @@ bfa_fcs_lookup_port(struct bfa_fcs_s *fc
 	vf = bfa_fcs_vf_lookup(fcs, vf_id);
 	if (vf == NULL) {
 		bfa_trc(fcs, vf_id);
-		return (NULL);
+		return NULL;
 	}
 
 	if (!lpwwn || (vf->bport.port_cfg.pwwn == lpwwn))
-		return (&vf->bport);
+		return &vf->bport;
 
 	vport = bfa_fcs_fabric_vport_lookup(vf, lpwwn);
 	if (vport)
-		return (&vport->lport);
+		return &vport->lport;
 
-	return (NULL);
+	return NULL;
 }
 
 /*
@@ -216,7 +218,7 @@ bfa_fcs_lookup_port(struct bfa_fcs_s *fc
  */
 void
 bfa_fcs_port_get_info(struct bfa_fcs_port_s *port,
-		      struct bfa_port_info_s *port_info)
+				struct bfa_port_info_s *port_info)
 {
 
 	bfa_trc(port->fcs, port->fabric->fabric_name);
@@ -236,7 +238,8 @@ bfa_fcs_port_get_info(struct bfa_fcs_por
 		port_info->port_wwn = bfa_fcs_port_get_pwwn(port);
 		port_info->node_wwn = bfa_fcs_port_get_nwwn(port);
 
-		port_info->max_vports_supp = bfa_fcs_vport_get_max(port->fcs);
+		port_info->max_vports_supp =
+			bfa_lps_get_max_vport(port->fcs->bfa);
 		port_info->num_vports_inuse =
 			bfa_fcs_fabric_vport_count(port->fabric);
 		port_info->max_rports_supp = BFA_FCS_MAX_RPORTS_SUPP;
@@ -260,10 +263,10 @@ bfa_fcs_port_get_info(struct bfa_fcs_por
 
 void
 bfa_fcs_port_get_stats(struct bfa_fcs_port_s *fcs_port,
-		       struct bfa_port_stats_s *port_stats)
+				struct bfa_port_stats_s *port_stats)
 {
 	bfa_os_memcpy(port_stats, &fcs_port->stats,
-		      sizeof(struct bfa_port_stats_s));
+				sizeof(struct bfa_port_stats_s));
 	return;
 }
 
diff -uprN a/drivers/scsi/bfa/ms.c b/drivers/scsi/bfa/ms.c
--- a/drivers/scsi/bfa/ms.c	2009-12-18 18:16:22.323707000 -0800
+++ b/drivers/scsi/bfa/ms.c	2009-11-25 18:21:07.000000000 -0800
@@ -41,24 +41,24 @@ static void     bfa_fcs_port_ms_plogi_re
 					       u32 resid_len,
 					       struct fchs_s *rsp_fchs);
 
-static void     bfa_fcs_port_ms_send_gmal(void *ms_cbarg,
-					  struct bfa_fcxp_s *fcxp_alloced);
+static void 	bfa_fcs_port_ms_send_gmal(void *ms_cbarg,
+					struct bfa_fcxp_s *fcxp_alloced);
 static void     bfa_fcs_port_ms_gmal_response(void *fcsarg,
-					      struct bfa_fcxp_s *fcxp,
-					      void *cbarg,
-					      bfa_status_t req_status,
-					      u32 rsp_len,
-					      u32 resid_len,
-					      struct fchs_s *rsp_fchs);
-static void     bfa_fcs_port_ms_send_gfn(void *ms_cbarg,
-					 struct bfa_fcxp_s *fcxp_alloced);
+					       struct bfa_fcxp_s *fcxp,
+					       void *cbarg,
+					       bfa_status_t req_status,
+					       u32 rsp_len,
+					       u32 resid_len,
+					       struct fchs_s *rsp_fchs);
+static void 	bfa_fcs_port_ms_send_gfn(void *ms_cbarg,
+					struct bfa_fcxp_s *fcxp_alloced);
 static void     bfa_fcs_port_ms_gfn_response(void *fcsarg,
-					     struct bfa_fcxp_s *fcxp,
-					     void *cbarg,
-					     bfa_status_t req_status,
-					     u32 rsp_len,
-					     u32 resid_len,
-					     struct fchs_s *rsp_fchs);
+					       struct bfa_fcxp_s *fcxp,
+					       void *cbarg,
+					       bfa_status_t req_status,
+					       u32 rsp_len,
+					       u32 resid_len,
+					       struct fchs_s *rsp_fchs);
 /**
  *  fcs_ms_sm FCS MS state machine
  */
@@ -85,17 +85,17 @@ static void     bfa_fcs_port_ms_sm_plogi
 static void     bfa_fcs_port_ms_sm_plogi_retry(struct bfa_fcs_port_ms_s *ms,
 					       enum port_ms_event event);
 static void     bfa_fcs_port_ms_sm_gmal_sending(struct bfa_fcs_port_ms_s *ms,
-						enum port_ms_event event);
+						 enum port_ms_event event);
 static void     bfa_fcs_port_ms_sm_gmal(struct bfa_fcs_port_ms_s *ms,
-					enum port_ms_event event);
+					 enum port_ms_event event);
 static void     bfa_fcs_port_ms_sm_gmal_retry(struct bfa_fcs_port_ms_s *ms,
-					      enum port_ms_event event);
-static void     bfa_fcs_port_ms_sm_gfn_sending(struct bfa_fcs_port_ms_s *ms,
 					       enum port_ms_event event);
+static void     bfa_fcs_port_ms_sm_gfn_sending(struct bfa_fcs_port_ms_s *ms,
+						 enum port_ms_event event);
 static void     bfa_fcs_port_ms_sm_gfn(struct bfa_fcs_port_ms_s *ms,
-				       enum port_ms_event event);
+					 enum port_ms_event event);
 static void     bfa_fcs_port_ms_sm_gfn_retry(struct bfa_fcs_port_ms_s *ms,
-					     enum port_ms_event event);
+					       enum port_ms_event event);
 static void     bfa_fcs_port_ms_sm_online(struct bfa_fcs_port_ms_s *ms,
 					  enum port_ms_event event);
 /**
@@ -103,7 +103,7 @@ static void     bfa_fcs_port_ms_sm_onlin
  */
 static void
 bfa_fcs_port_ms_sm_offline(struct bfa_fcs_port_ms_s *ms,
-			   enum port_ms_event event)
+				enum port_ms_event event)
 {
 	bfa_trc(ms->port->fcs, ms->port->port_cfg.pwwn);
 	bfa_trc(ms->port->fcs, event);
@@ -118,13 +118,13 @@ bfa_fcs_port_ms_sm_offline(struct bfa_fc
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ms->port->fcs, event);
 	}
 }
 
 static void
 bfa_fcs_port_ms_sm_plogi_sending(struct bfa_fcs_port_ms_s *ms,
-				 enum port_ms_event event)
+					enum port_ms_event event)
 {
 	bfa_trc(ms->port->fcs, ms->port->port_cfg.pwwn);
 	bfa_trc(ms->port->fcs, event);
@@ -137,11 +137,11 @@ bfa_fcs_port_ms_sm_plogi_sending(struct 
 	case MSSM_EVENT_PORT_OFFLINE:
 		bfa_sm_set_state(ms, bfa_fcs_port_ms_sm_offline);
 		bfa_fcxp_walloc_cancel(BFA_FCS_GET_HAL_FROM_PORT(ms->port),
-				       &ms->fcxp_wqe);
+					   &ms->fcxp_wqe);
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ms->port->fcs, event);
 	}
 }
 
@@ -157,9 +157,9 @@ bfa_fcs_port_ms_sm_plogi(struct bfa_fcs_
 		 * Start timer for a delayed retry
 		 */
 		bfa_sm_set_state(ms, bfa_fcs_port_ms_sm_plogi_retry);
-		bfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(ms->port), &ms->timer,
-				bfa_fcs_port_ms_timeout, ms,
-				BFA_FCS_RETRY_TIMEOUT);
+		bfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(ms->port),
+				    &ms->timer, bfa_fcs_port_ms_timeout, ms,
+				    BFA_FCS_RETRY_TIMEOUT);
 		break;
 
 	case MSSM_EVENT_RSP_OK:
@@ -190,13 +190,13 @@ bfa_fcs_port_ms_sm_plogi(struct bfa_fcs_
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ms->port->fcs, event);
 	}
 }
 
 static void
 bfa_fcs_port_ms_sm_plogi_retry(struct bfa_fcs_port_ms_s *ms,
-			       enum port_ms_event event)
+					enum port_ms_event event)
 {
 	bfa_trc(ms->port->fcs, ms->port->port_cfg.pwwn);
 	bfa_trc(ms->port->fcs, event);
@@ -216,13 +216,13 @@ bfa_fcs_port_ms_sm_plogi_retry(struct bf
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ms->port->fcs, event);
 	}
 }
 
 static void
 bfa_fcs_port_ms_sm_online(struct bfa_fcs_port_ms_s *ms,
-			  enum port_ms_event event)
+				enum port_ms_event event)
 {
 	bfa_trc(ms->port->fcs, ms->port->port_cfg.pwwn);
 	bfa_trc(ms->port->fcs, event);
@@ -230,10 +230,6 @@ bfa_fcs_port_ms_sm_online(struct bfa_fcs
 	switch (event) {
 	case MSSM_EVENT_PORT_OFFLINE:
 		bfa_sm_set_state(ms, bfa_fcs_port_ms_sm_offline);
-		/*
-		 * now invoke MS related sub-modules
-		 */
-		bfa_fcs_port_fdmi_offline(ms);
 		break;
 
 	case MSSM_EVENT_PORT_FABRIC_RSCN:
@@ -243,13 +239,13 @@ bfa_fcs_port_ms_sm_online(struct bfa_fcs
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ms->port->fcs, event);
 	}
 }
 
 static void
 bfa_fcs_port_ms_sm_gmal_sending(struct bfa_fcs_port_ms_s *ms,
-				enum port_ms_event event)
+					enum port_ms_event event)
 {
 	bfa_trc(ms->port->fcs, ms->port->port_cfg.pwwn);
 	bfa_trc(ms->port->fcs, event);
@@ -262,11 +258,11 @@ bfa_fcs_port_ms_sm_gmal_sending(struct b
 	case MSSM_EVENT_PORT_OFFLINE:
 		bfa_sm_set_state(ms, bfa_fcs_port_ms_sm_offline);
 		bfa_fcxp_walloc_cancel(BFA_FCS_GET_HAL_FROM_PORT(ms->port),
-				       &ms->fcxp_wqe);
+					   &ms->fcxp_wqe);
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ms->port->fcs, event);
 	}
 }
 
@@ -304,13 +300,13 @@ bfa_fcs_port_ms_sm_gmal(struct bfa_fcs_p
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ms->port->fcs, event);
 	}
 }
 
 static void
 bfa_fcs_port_ms_sm_gmal_retry(struct bfa_fcs_port_ms_s *ms,
-			      enum port_ms_event event)
+					enum port_ms_event event)
 {
 	bfa_trc(ms->port->fcs, ms->port->port_cfg.pwwn);
 	bfa_trc(ms->port->fcs, event);
@@ -330,10 +326,9 @@ bfa_fcs_port_ms_sm_gmal_retry(struct bfa
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ms->port->fcs, event);
 	}
 }
-
 /**
  *  ms_pvt MS local functions
  */
@@ -352,35 +347,36 @@ bfa_fcs_port_ms_send_gmal(void *ms_cbarg
 	fcxp = fcxp_alloced ? fcxp_alloced : bfa_fcs_fcxp_alloc(port->fcs);
 	if (!fcxp) {
 		bfa_fcxp_alloc_wait(port->fcs->bfa, &ms->fcxp_wqe,
-				    bfa_fcs_port_ms_send_gmal, ms);
+					bfa_fcs_port_ms_send_gmal, ms);
 		return;
 	}
 	ms->fcxp = fcxp;
 
 	len = fc_gmal_req_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),
-				bfa_fcs_port_get_fcid(port),
-				bfa_lps_get_peer_nwwn(port->fabric->lps));
+			     bfa_fcs_port_get_fcid(port),
+				 bfa_lps_get_peer_nwwn(port->fabric->lps));
 
 	bfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,
-		      FC_CLASS_3, len, &fchs, bfa_fcs_port_ms_gmal_response,
-		      (void *)ms, FC_MAX_PDUSZ, FC_RA_TOV);
+			  FC_CLASS_3, len, &fchs,
+			  bfa_fcs_port_ms_gmal_response, (void *)ms,
+			  FC_MAX_PDUSZ, FC_RA_TOV);
 
 	bfa_sm_send_event(ms, MSSM_EVENT_FCXP_SENT);
 }
 
 static void
 bfa_fcs_port_ms_gmal_response(void *fcsarg, struct bfa_fcxp_s *fcxp,
-			      void *cbarg, bfa_status_t req_status,
-			      u32 rsp_len, u32 resid_len,
-			      struct fchs_s *rsp_fchs)
+				void *cbarg, bfa_status_t req_status,
+				u32 rsp_len, u32 resid_len,
+				struct fchs_s *rsp_fchs)
 {
-	struct bfa_fcs_port_ms_s *ms = (struct bfa_fcs_port_ms_s *)cbarg;
+	struct bfa_fcs_port_ms_s *ms = (struct bfa_fcs_port_ms_s *) cbarg;
 	struct bfa_fcs_port_s *port = ms->port;
 	struct ct_hdr_s       *cthdr = NULL;
 	struct fcgs_gmal_resp_s *gmal_resp;
 	struct fc_gmal_entry_s *gmal_entry;
-	u32        num_entries;
-	u8        *rsp_str;
+	u32		num_entries;
+	u8 		*rsp_str;
 
 	bfa_trc(port->fcs, req_status);
 	bfa_trc(port->fcs, port->port_cfg.pwwn);
@@ -399,35 +395,34 @@ bfa_fcs_port_ms_gmal_response(void *fcsa
 
 	if (cthdr->cmd_rsp_code == CT_RSP_ACCEPT) {
 		gmal_resp = (struct fcgs_gmal_resp_s *)(cthdr + 1);
+
 		num_entries = bfa_os_ntohl(gmal_resp->ms_len);
 		if (num_entries == 0) {
 			bfa_sm_send_event(ms, MSSM_EVENT_RSP_ERROR);
 			return;
 		}
 		/*
-		 * The response could contain multiple Entries.
-		 * Entries for SNMP interface, etc.
-		 * We look for the entry with a telnet prefix.
-		 * First "http://" entry refers to IP addr
-		 */
+		* The response could contain multiple Entries.
+		* Entries for SNMP interface, etc.
+		* We look for the entry with a telnet prefix.
+		* First "http://" entry refers to IP addr
+		*/
 
 		gmal_entry = (struct fc_gmal_entry_s *)gmal_resp->ms_ma;
 		while (num_entries > 0) {
-			if (strncmp
-			    (gmal_entry->prefix, CT_GMAL_RESP_PREFIX_HTTP,
-			     sizeof(gmal_entry->prefix)) == 0) {
-
-				/*
-				 * if the IP address is terminating with a '/',
-				 * remove it. *Byte 0 consists of the length
+			if (strncmp(gmal_entry->prefix,
+					CT_GMAL_RESP_PREFIX_HTTP,
+					sizeof(gmal_entry->prefix)) == 0) {
+
+				/* If the IP address is terminating with a '/',
+				 * remove it. Byte 0 consists of the length
 				 * of the string.
 				 */
 				rsp_str = &(gmal_entry->prefix[0]);
-				if (rsp_str[gmal_entry->len - 1] == '/')
-					rsp_str[gmal_entry->len - 1] = 0;
-				/*
-				 * copy IP Address to fabric
-				 */
+				if (rsp_str[gmal_entry->len-1] == '/')
+					rsp_str[gmal_entry->len-1] = 0;
+
+				/* copy IP Address to fabric */
 				strncpy(bfa_fcs_port_get_fabric_ipaddr(port),
 					gmal_entry->ip_addr,
 					BFA_FCS_FABRIC_IPADDR_SZ);
@@ -449,7 +444,7 @@ bfa_fcs_port_ms_gmal_response(void *fcsa
 
 static void
 bfa_fcs_port_ms_sm_gfn_sending(struct bfa_fcs_port_ms_s *ms,
-			       enum port_ms_event event)
+					enum port_ms_event event)
 {
 	bfa_trc(ms->port->fcs, ms->port->port_cfg.pwwn);
 	bfa_trc(ms->port->fcs, event);
@@ -462,11 +457,11 @@ bfa_fcs_port_ms_sm_gfn_sending(struct bf
 	case MSSM_EVENT_PORT_OFFLINE:
 		bfa_sm_set_state(ms, bfa_fcs_port_ms_sm_offline);
 		bfa_fcxp_walloc_cancel(BFA_FCS_GET_HAL_FROM_PORT(ms->port),
-				       &ms->fcxp_wqe);
+					   &ms->fcxp_wqe);
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ms->port->fcs, event);
 	}
 }
 
@@ -484,8 +479,9 @@ bfa_fcs_port_ms_sm_gfn(struct bfa_fcs_po
 		if (ms->retry_cnt++ < BFA_FCS_MS_CMD_MAX_RETRIES) {
 			bfa_sm_set_state(ms, bfa_fcs_port_ms_sm_gfn_retry);
 			bfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(ms->port),
-					&ms->timer, bfa_fcs_port_ms_timeout, ms,
-					BFA_FCS_RETRY_TIMEOUT);
+						&ms->timer,
+						bfa_fcs_port_ms_timeout, ms,
+						BFA_FCS_RETRY_TIMEOUT);
 		} else {
 			bfa_sm_set_state(ms, bfa_fcs_port_ms_sm_online);
 			ms->retry_cnt = 0;
@@ -502,13 +498,13 @@ bfa_fcs_port_ms_sm_gfn(struct bfa_fcs_po
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ms->port->fcs, event);
 	}
 }
 
 static void
 bfa_fcs_port_ms_sm_gfn_retry(struct bfa_fcs_port_ms_s *ms,
-			     enum port_ms_event event)
+					enum port_ms_event event)
 {
 	bfa_trc(ms->port->fcs, ms->port->port_cfg.pwwn);
 	bfa_trc(ms->port->fcs, event);
@@ -528,10 +524,9 @@ bfa_fcs_port_ms_sm_gfn_retry(struct bfa_
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ms->port->fcs, event);
 	}
 }
-
 /**
  *  ms_pvt MS local functions
  */
@@ -550,31 +545,32 @@ bfa_fcs_port_ms_send_gfn(void *ms_cbarg,
 	fcxp = fcxp_alloced ? fcxp_alloced : bfa_fcs_fcxp_alloc(port->fcs);
 	if (!fcxp) {
 		bfa_fcxp_alloc_wait(port->fcs->bfa, &ms->fcxp_wqe,
-				    bfa_fcs_port_ms_send_gfn, ms);
+					bfa_fcs_port_ms_send_gfn, ms);
 		return;
 	}
 	ms->fcxp = fcxp;
 
 	len = fc_gfn_req_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),
-			       bfa_fcs_port_get_fcid(port),
-			       bfa_lps_get_peer_nwwn(port->fabric->lps));
+			     bfa_fcs_port_get_fcid(port),
+				 bfa_lps_get_peer_nwwn(port->fabric->lps));
 
 	bfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,
-		      FC_CLASS_3, len, &fchs, bfa_fcs_port_ms_gfn_response,
-		      (void *)ms, FC_MAX_PDUSZ, FC_RA_TOV);
+			  FC_CLASS_3, len, &fchs,
+			  bfa_fcs_port_ms_gfn_response, (void *)ms,
+			  FC_MAX_PDUSZ, FC_RA_TOV);
 
 	bfa_sm_send_event(ms, MSSM_EVENT_FCXP_SENT);
 }
 
 static void
 bfa_fcs_port_ms_gfn_response(void *fcsarg, struct bfa_fcxp_s *fcxp, void *cbarg,
-			     bfa_status_t req_status, u32 rsp_len,
+			       bfa_status_t req_status, u32 rsp_len,
 			       u32 resid_len, struct fchs_s *rsp_fchs)
 {
-	struct bfa_fcs_port_ms_s *ms = (struct bfa_fcs_port_ms_s *)cbarg;
+	struct bfa_fcs_port_ms_s *ms = (struct bfa_fcs_port_ms_s *) cbarg;
 	struct bfa_fcs_port_s *port = ms->port;
 	struct ct_hdr_s       *cthdr = NULL;
-	wwn_t          *gfn_resp;
+	wwn_t	       *gfn_resp;
 
 	bfa_trc(port->fcs, req_status);
 	bfa_trc(port->fcs, port->port_cfg.pwwn);
@@ -592,14 +588,12 @@ bfa_fcs_port_ms_gfn_response(void *fcsar
 	cthdr->cmd_rsp_code = bfa_os_ntohs(cthdr->cmd_rsp_code);
 
 	if (cthdr->cmd_rsp_code == CT_RSP_ACCEPT) {
-		gfn_resp = (wwn_t *) (cthdr + 1);
-		/*
-		 * check if it has actually changed
-		 */
-		if ((memcmp
-		     ((void *)&bfa_fcs_port_get_fabric_name(port), gfn_resp,
-		      sizeof(wwn_t)) != 0))
+		gfn_resp = (wwn_t *)(cthdr + 1);
+		/* check if it has actually changed */
+		if ((memcmp((void *)&bfa_fcs_port_get_fabric_name(port),
+				gfn_resp, sizeof(wwn_t)) != 0)) {
 			bfa_fcs_fabric_set_fabric_name(port->fabric, *gfn_resp);
+		}
 		bfa_sm_send_event(ms, MSSM_EVENT_RSP_OK);
 		return;
 	}
@@ -628,7 +622,7 @@ bfa_fcs_port_ms_send_plogi(void *ms_cbar
 	if (!fcxp) {
 		port->stats.ms_plogi_alloc_wait++;
 		bfa_fcxp_alloc_wait(port->fcs->bfa, &ms->fcxp_wqe,
-				    bfa_fcs_port_ms_send_plogi, ms);
+					bfa_fcs_port_ms_send_plogi, ms);
 		return;
 	}
 	ms->fcxp = fcxp;
@@ -637,11 +631,12 @@ bfa_fcs_port_ms_send_plogi(void *ms_cbar
 			     bfa_os_hton3b(FC_MGMT_SERVER),
 			     bfa_fcs_port_get_fcid(port), 0,
 			     port->port_cfg.pwwn, port->port_cfg.nwwn,
-			     bfa_pport_get_maxfrsize(port->fcs->bfa));
+				 bfa_fcport_get_maxfrsize(port->fcs->bfa));
 
 	bfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,
-		      FC_CLASS_3, len, &fchs, bfa_fcs_port_ms_plogi_response,
-		      (void *)ms, FC_MAX_PDUSZ, FC_RA_TOV);
+			  FC_CLASS_3, len, &fchs,
+			  bfa_fcs_port_ms_plogi_response, (void *)ms,
+			  FC_MAX_PDUSZ, FC_RA_TOV);
 
 	port->stats.ms_plogi_sent++;
 	bfa_sm_send_event(ms, MSSM_EVENT_FCXP_SENT);
@@ -649,12 +644,11 @@ bfa_fcs_port_ms_send_plogi(void *ms_cbar
 
 static void
 bfa_fcs_port_ms_plogi_response(void *fcsarg, struct bfa_fcxp_s *fcxp,
-			       void *cbarg, bfa_status_t req_status,
-			       u32 rsp_len, u32 resid_len,
-			       struct fchs_s *rsp_fchs)
+				void *cbarg, bfa_status_t req_status,
+				u32 rsp_len, u32 resid_len,
+				struct fchs_s *rsp_fchs)
 {
-	struct bfa_fcs_port_ms_s *ms = (struct bfa_fcs_port_ms_s *)cbarg;
-
+	struct bfa_fcs_port_ms_s *ms = (struct bfa_fcs_port_ms_s *) cbarg;
 	struct bfa_fcs_port_s *port = ms->port;
 	struct fc_els_cmd_s   *els_cmd;
 	struct fc_ls_rjt_s    *ls_rjt;
@@ -707,7 +701,7 @@ bfa_fcs_port_ms_plogi_response(void *fcs
 static void
 bfa_fcs_port_ms_timeout(void *arg)
 {
-	struct bfa_fcs_port_ms_s *ms = (struct bfa_fcs_port_ms_s *)arg;
+	struct bfa_fcs_port_ms_s *ms = (struct bfa_fcs_port_ms_s *) arg;
 
 	ms->port->stats.ms_timeouts++;
 	bfa_sm_send_event(ms, MSSM_EVENT_TIMEOUT);
@@ -735,6 +729,7 @@ bfa_fcs_port_ms_offline(struct bfa_fcs_p
 
 	ms->port = port;
 	bfa_sm_send_event(ms, MSSM_EVENT_PORT_OFFLINE);
+	bfa_fcs_port_fdmi_offline(ms);
 }
 
 void
@@ -745,15 +740,12 @@ bfa_fcs_port_ms_online(struct bfa_fcs_po
 	ms->port = port;
 	bfa_sm_send_event(ms, MSSM_EVENT_PORT_ONLINE);
 }
-
 void
 bfa_fcs_port_ms_fabric_rscn(struct bfa_fcs_port_s *port)
 {
 	struct bfa_fcs_port_ms_s *ms = BFA_FCS_GET_MS_FROM_PORT(port);
 
-	/*
-	 * @todo.  Handle this only when in Online state
-	 */
+	/* todo.  Handle this only  when in Online state */
 	if (bfa_sm_cmp_state(ms, bfa_fcs_port_ms_sm_online))
 		bfa_sm_send_event(ms, MSSM_EVENT_PORT_FABRIC_RSCN);
 }
diff -uprN a/drivers/scsi/bfa/n2n.c b/drivers/scsi/bfa/n2n.c
--- a/drivers/scsi/bfa/n2n.c	2009-12-18 18:16:22.321708000 -0800
+++ b/drivers/scsi/bfa/n2n.c	2009-11-25 18:21:07.000000000 -0800
@@ -63,7 +63,7 @@ bfa_fcs_port_n2n_online(struct bfa_fcs_p
 		 * First, check if we know the device by pwwn.
 		 */
 		rport = bfa_fcs_port_get_rport_by_pwwn(port,
-						       n2n_port->rem_port_wwn);
+							n2n_port->rem_port_wwn);
 		if (rport) {
 			bfa_trc(port->fcs, rport->pid);
 			bfa_trc(port->fcs, rport->pwwn);
@@ -73,8 +73,8 @@ bfa_fcs_port_n2n_online(struct bfa_fcs_p
 		}
 
 		/*
-		 * In n2n there can be only one rport. Delete the old one whose
-		 * pid should be zero, because it is offline.
+		 * In n2n there can be only one rport. Delete the old one
+		 * whose pid should be zero, because it is offline.
 		 */
 		if (port->num_rports > 0) {
 			rport = bfa_fcs_port_get_rport_by_pid(port, 0);
diff -uprN a/drivers/scsi/bfa/ns.c b/drivers/scsi/bfa/ns.c
--- a/drivers/scsi/bfa/ns.c	2009-12-18 18:16:22.319710000 -0800
+++ b/drivers/scsi/bfa/ns.c	2009-11-25 18:21:07.000000000 -0800
@@ -88,7 +88,7 @@ static void     bfa_fcs_port_ns_process_
 						   u32 *pid_buf,
 						   u32 n_pids);
 
-static void     bfa_fcs_port_ns_boot_target_disc(struct bfa_fcs_port_s *port);
+static void bfa_fcs_port_ns_boot_target_disc(struct bfa_fcs_port_s *port);
 /**
  *  fcs_ns_sm FCS nameserver interface state machine
  */
@@ -149,7 +149,7 @@ static void     bfa_fcs_port_ns_sm_onlin
  */
 static void
 bfa_fcs_port_ns_sm_offline(struct bfa_fcs_port_ns_s *ns,
-			   enum vport_ns_event event)
+			enum vport_ns_event event)
 {
 	bfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);
 	bfa_trc(ns->port->fcs, event);
@@ -164,13 +164,13 @@ bfa_fcs_port_ns_sm_offline(struct bfa_fc
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ns->port->fcs, event);
 	}
 }
 
 static void
 bfa_fcs_port_ns_sm_plogi_sending(struct bfa_fcs_port_ns_s *ns,
-				 enum vport_ns_event event)
+					enum vport_ns_event event)
 {
 	bfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);
 	bfa_trc(ns->port->fcs, event);
@@ -183,17 +183,17 @@ bfa_fcs_port_ns_sm_plogi_sending(struct 
 	case NSSM_EVENT_PORT_OFFLINE:
 		bfa_sm_set_state(ns, bfa_fcs_port_ns_sm_offline);
 		bfa_fcxp_walloc_cancel(BFA_FCS_GET_HAL_FROM_PORT(ns->port),
-				       &ns->fcxp_wqe);
+					   &ns->fcxp_wqe);
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ns->port->fcs, event);
 	}
 }
 
 static void
 bfa_fcs_port_ns_sm_plogi(struct bfa_fcs_port_ns_s *ns,
-			 enum vport_ns_event event)
+				enum vport_ns_event event)
 {
 	bfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);
 	bfa_trc(ns->port->fcs, event);
@@ -205,9 +205,9 @@ bfa_fcs_port_ns_sm_plogi(struct bfa_fcs_
 		 */
 		bfa_sm_set_state(ns, bfa_fcs_port_ns_sm_plogi_retry);
 		ns->port->stats.ns_retries++;
-		bfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(ns->port), &ns->timer,
-				bfa_fcs_port_ns_timeout, ns,
-				BFA_FCS_RETRY_TIMEOUT);
+		bfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(ns->port),
+				    &ns->timer, bfa_fcs_port_ns_timeout, ns,
+				    BFA_FCS_RETRY_TIMEOUT);
 		break;
 
 	case NSSM_EVENT_RSP_OK:
@@ -221,13 +221,13 @@ bfa_fcs_port_ns_sm_plogi(struct bfa_fcs_
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ns->port->fcs, event);
 	}
 }
 
 static void
 bfa_fcs_port_ns_sm_plogi_retry(struct bfa_fcs_port_ns_s *ns,
-			       enum vport_ns_event event)
+				enum vport_ns_event event)
 {
 	bfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);
 	bfa_trc(ns->port->fcs, event);
@@ -247,7 +247,7 @@ bfa_fcs_port_ns_sm_plogi_retry(struct bf
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ns->port->fcs, event);
 	}
 }
 
@@ -266,17 +266,17 @@ bfa_fcs_port_ns_sm_sending_rspn_id(struc
 	case NSSM_EVENT_PORT_OFFLINE:
 		bfa_sm_set_state(ns, bfa_fcs_port_ns_sm_offline);
 		bfa_fcxp_walloc_cancel(BFA_FCS_GET_HAL_FROM_PORT(ns->port),
-				       &ns->fcxp_wqe);
+					   &ns->fcxp_wqe);
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ns->port->fcs, event);
 	}
 }
 
 static void
 bfa_fcs_port_ns_sm_rspn_id(struct bfa_fcs_port_ns_s *ns,
-			   enum vport_ns_event event)
+				enum vport_ns_event event)
 {
 	bfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);
 	bfa_trc(ns->port->fcs, event);
@@ -288,9 +288,9 @@ bfa_fcs_port_ns_sm_rspn_id(struct bfa_fc
 		 */
 		bfa_sm_set_state(ns, bfa_fcs_port_ns_sm_rspn_id_retry);
 		ns->port->stats.ns_retries++;
-		bfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(ns->port), &ns->timer,
-				bfa_fcs_port_ns_timeout, ns,
-				BFA_FCS_RETRY_TIMEOUT);
+		bfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(ns->port),
+				    &ns->timer, bfa_fcs_port_ns_timeout, ns,
+				    BFA_FCS_RETRY_TIMEOUT);
 		break;
 
 	case NSSM_EVENT_RSP_OK:
@@ -304,13 +304,13 @@ bfa_fcs_port_ns_sm_rspn_id(struct bfa_fc
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ns->port->fcs, event);
 	}
 }
 
 static void
 bfa_fcs_port_ns_sm_rspn_id_retry(struct bfa_fcs_port_ns_s *ns,
-				 enum vport_ns_event event)
+					enum vport_ns_event event)
 {
 	bfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);
 	bfa_trc(ns->port->fcs, event);
@@ -330,7 +330,7 @@ bfa_fcs_port_ns_sm_rspn_id_retry(struct 
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ns->port->fcs, event);
 	}
 }
 
@@ -349,26 +349,24 @@ bfa_fcs_port_ns_sm_sending_rft_id(struct
 	case NSSM_EVENT_PORT_OFFLINE:
 		bfa_sm_set_state(ns, bfa_fcs_port_ns_sm_offline);
 		bfa_fcxp_walloc_cancel(BFA_FCS_GET_HAL_FROM_PORT(ns->port),
-				       &ns->fcxp_wqe);
+					   &ns->fcxp_wqe);
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ns->port->fcs, event);
 	}
 }
 
 static void
 bfa_fcs_port_ns_sm_rft_id(struct bfa_fcs_port_ns_s *ns,
-			  enum vport_ns_event event)
+					enum vport_ns_event event)
 {
 	bfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);
 	bfa_trc(ns->port->fcs, event);
 
 	switch (event) {
 	case NSSM_EVENT_RSP_OK:
-		/*
-		 * Now move to register FC4 Features
-		 */
+		/* Now move to register FC4 Features */
 		bfa_sm_set_state(ns, bfa_fcs_port_ns_sm_sending_rff_id);
 		bfa_fcs_port_ns_send_rff_id(ns, NULL);
 		break;
@@ -379,9 +377,9 @@ bfa_fcs_port_ns_sm_rft_id(struct bfa_fcs
 		 */
 		bfa_sm_set_state(ns, bfa_fcs_port_ns_sm_rft_id_retry);
 		ns->port->stats.ns_retries++;
-		bfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(ns->port), &ns->timer,
-				bfa_fcs_port_ns_timeout, ns,
-				BFA_FCS_RETRY_TIMEOUT);
+		bfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(ns->port),
+				    &ns->timer, bfa_fcs_port_ns_timeout, ns,
+				    BFA_FCS_RETRY_TIMEOUT);
 		break;
 
 	case NSSM_EVENT_PORT_OFFLINE:
@@ -390,13 +388,13 @@ bfa_fcs_port_ns_sm_rft_id(struct bfa_fcs
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ns->port->fcs, event);
 	}
 }
 
 static void
 bfa_fcs_port_ns_sm_rft_id_retry(struct bfa_fcs_port_ns_s *ns,
-				enum vport_ns_event event)
+					enum vport_ns_event event)
 {
 	bfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);
 	bfa_trc(ns->port->fcs, event);
@@ -413,7 +411,7 @@ bfa_fcs_port_ns_sm_rft_id_retry(struct b
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ns->port->fcs, event);
 	}
 }
 
@@ -432,17 +430,17 @@ bfa_fcs_port_ns_sm_sending_rff_id(struct
 	case NSSM_EVENT_PORT_OFFLINE:
 		bfa_sm_set_state(ns, bfa_fcs_port_ns_sm_offline);
 		bfa_fcxp_walloc_cancel(BFA_FCS_GET_HAL_FROM_PORT(ns->port),
-				       &ns->fcxp_wqe);
+					   &ns->fcxp_wqe);
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ns->port->fcs, event);
 	}
 }
 
 static void
 bfa_fcs_port_ns_sm_rff_id(struct bfa_fcs_port_ns_s *ns,
-			  enum vport_ns_event event)
+				enum vport_ns_event event)
 {
 	bfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);
 	bfa_trc(ns->port->fcs, event);
@@ -483,9 +481,9 @@ bfa_fcs_port_ns_sm_rff_id(struct bfa_fcs
 		 */
 		bfa_sm_set_state(ns, bfa_fcs_port_ns_sm_rff_id_retry);
 		ns->port->stats.ns_retries++;
-		bfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(ns->port), &ns->timer,
-				bfa_fcs_port_ns_timeout, ns,
-				BFA_FCS_RETRY_TIMEOUT);
+		bfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(ns->port),
+				    &ns->timer, bfa_fcs_port_ns_timeout, ns,
+				    BFA_FCS_RETRY_TIMEOUT);
 		break;
 
 	case NSSM_EVENT_PORT_OFFLINE:
@@ -494,7 +492,7 @@ bfa_fcs_port_ns_sm_rff_id(struct bfa_fcs
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ns->port->fcs, event);
 	}
 }
 
@@ -517,7 +515,7 @@ bfa_fcs_port_ns_sm_rff_id_retry(struct b
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ns->port->fcs, event);
 	}
 }
 static void
@@ -535,17 +533,17 @@ bfa_fcs_port_ns_sm_sending_gid_ft(struct
 	case NSSM_EVENT_PORT_OFFLINE:
 		bfa_sm_set_state(ns, bfa_fcs_port_ns_sm_offline);
 		bfa_fcxp_walloc_cancel(BFA_FCS_GET_HAL_FROM_PORT(ns->port),
-				       &ns->fcxp_wqe);
+					   &ns->fcxp_wqe);
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ns->port->fcs, event);
 	}
 }
 
 static void
 bfa_fcs_port_ns_sm_gid_ft(struct bfa_fcs_port_ns_s *ns,
-			  enum vport_ns_event event)
+					enum vport_ns_event event)
 {
 	bfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);
 	bfa_trc(ns->port->fcs, event);
@@ -564,9 +562,9 @@ bfa_fcs_port_ns_sm_gid_ft(struct bfa_fcs
 		 */
 		bfa_sm_set_state(ns, bfa_fcs_port_ns_sm_gid_ft_retry);
 		ns->port->stats.ns_retries++;
-		bfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(ns->port), &ns->timer,
-				bfa_fcs_port_ns_timeout, ns,
-				BFA_FCS_RETRY_TIMEOUT);
+		bfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(ns->port),
+				    &ns->timer, bfa_fcs_port_ns_timeout, ns,
+				    BFA_FCS_RETRY_TIMEOUT);
 		break;
 
 	case NSSM_EVENT_PORT_OFFLINE:
@@ -575,7 +573,7 @@ bfa_fcs_port_ns_sm_gid_ft(struct bfa_fcs
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ns->port->fcs, event);
 	}
 }
 
@@ -598,13 +596,13 @@ bfa_fcs_port_ns_sm_gid_ft_retry(struct b
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ns->port->fcs, event);
 	}
 }
 
 static void
 bfa_fcs_port_ns_sm_online(struct bfa_fcs_port_ns_s *ns,
-			  enum vport_ns_event event)
+				enum vport_ns_event event)
 {
 	bfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);
 	bfa_trc(ns->port->fcs, event);
@@ -626,7 +624,7 @@ bfa_fcs_port_ns_sm_online(struct bfa_fcs
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(ns->port->fcs, event);
 	}
 }
 
@@ -651,7 +649,7 @@ bfa_fcs_port_ns_send_plogi(void *ns_cbar
 	if (!fcxp) {
 		port->stats.ns_plogi_alloc_wait++;
 		bfa_fcxp_alloc_wait(port->fcs->bfa, &ns->fcxp_wqe,
-				    bfa_fcs_port_ns_send_plogi, ns);
+					bfa_fcs_port_ns_send_plogi, ns);
 		return;
 	}
 	ns->fcxp = fcxp;
@@ -660,11 +658,12 @@ bfa_fcs_port_ns_send_plogi(void *ns_cbar
 			     bfa_os_hton3b(FC_NAME_SERVER),
 			     bfa_fcs_port_get_fcid(port), 0,
 			     port->port_cfg.pwwn, port->port_cfg.nwwn,
-			     bfa_pport_get_maxfrsize(port->fcs->bfa));
+				 bfa_fcport_get_maxfrsize(port->fcs->bfa));
 
 	bfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,
-		      FC_CLASS_3, len, &fchs, bfa_fcs_port_ns_plogi_response,
-		      (void *)ns, FC_MAX_PDUSZ, FC_RA_TOV);
+			  FC_CLASS_3, len, &fchs,
+			  bfa_fcs_port_ns_plogi_response, (void *)ns,
+			  FC_MAX_PDUSZ, FC_RA_TOV);
 	port->stats.ns_plogi_sent++;
 
 	bfa_sm_send_event(ns, NSSM_EVENT_PLOGI_SENT);
@@ -672,11 +671,11 @@ bfa_fcs_port_ns_send_plogi(void *ns_cbar
 
 static void
 bfa_fcs_port_ns_plogi_response(void *fcsarg, struct bfa_fcxp_s *fcxp,
-			       void *cbarg, bfa_status_t req_status,
-			       u32 rsp_len, u32 resid_len,
-			       struct fchs_s *rsp_fchs)
+				void *cbarg, bfa_status_t req_status,
+				u32 rsp_len, u32 resid_len,
+				struct fchs_s *rsp_fchs)
 {
-	struct bfa_fcs_port_ns_s *ns = (struct bfa_fcs_port_ns_s *)cbarg;
+	struct bfa_fcs_port_ns_s *ns = (struct bfa_fcs_port_ns_s *) cbarg;
 	struct bfa_fcs_port_s *port = ns->port;
 	/* struct fc_logi_s *plogi_resp; */
 	struct fc_els_cmd_s   *els_cmd;
@@ -740,7 +739,7 @@ bfa_fcs_port_ns_send_rspn_id(void *ns_cb
 	int             len;
 	struct bfa_fcxp_s *fcxp;
 	u8         symbl[256];
-	u8        *psymbl = &symbl[0];
+	u8         *psymbl = &symbl[0];
 
 	bfa_os_memset(symbl, 0, sizeof(symbl));
 
@@ -750,7 +749,7 @@ bfa_fcs_port_ns_send_rspn_id(void *ns_cb
 	if (!fcxp) {
 		port->stats.ns_rspnid_alloc_wait++;
 		bfa_fcxp_alloc_wait(port->fcs->bfa, &ns->fcxp_wqe,
-				    bfa_fcs_port_ns_send_rspn_id, ns);
+					bfa_fcs_port_ns_send_rspn_id, ns);
 		return;
 	}
 	ns->fcxp = fcxp;
@@ -764,24 +763,21 @@ bfa_fcs_port_ns_send_rspn_id(void *ns_cb
 		 */
 
 		strncpy((char *)psymbl,
-			(char *)
-			&(bfa_fcs_port_get_psym_name
-			  (bfa_fcs_get_base_port(port->fcs))),
-			strlen((char *)
-			       &bfa_fcs_port_get_psym_name(bfa_fcs_get_base_port
-							   (port->fcs))));
-
-		/*
-		 * Ensure we have a null terminating string.
-		 */
-		((char *)
-		 psymbl)[strlen((char *)
-				&bfa_fcs_port_get_psym_name
-				(bfa_fcs_get_base_port(port->fcs)))] = 0;
+			(char *) &
+			(bfa_fcs_port_get_psym_name
+			 (bfa_fcs_get_base_port(port->fcs))),
+			strlen((char *) &
+			       bfa_fcs_port_get_psym_name(bfa_fcs_get_base_port
+							  (port->fcs))));
+
+	/* Ensure we have a null terminating string. */
+	((char *)psymbl)[strlen((char *) &
+			bfa_fcs_port_get_psym_name(bfa_fcs_get_base_port
+							  (port->fcs)))] = 0;
 
 		strncat((char *)psymbl,
-			(char *)&(bfa_fcs_port_get_psym_name(port)),
-			strlen((char *)&bfa_fcs_port_get_psym_name(port)));
+			(char *) &(bfa_fcs_port_get_psym_name(port)),
+			strlen((char *) &bfa_fcs_port_get_psym_name(port)));
 	} else {
 		psymbl = (u8 *) &(bfa_fcs_port_get_psym_name(port));
 	}
@@ -790,8 +786,9 @@ bfa_fcs_port_ns_send_rspn_id(void *ns_cb
 			      bfa_fcs_port_get_fcid(port), 0, psymbl);
 
 	bfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,
-		      FC_CLASS_3, len, &fchs, bfa_fcs_port_ns_rspn_id_response,
-		      (void *)ns, FC_MAX_PDUSZ, FC_RA_TOV);
+			  FC_CLASS_3, len, &fchs,
+			  bfa_fcs_port_ns_rspn_id_response, (void *)ns,
+			  FC_MAX_PDUSZ, FC_RA_TOV);
 
 	port->stats.ns_rspnid_sent++;
 
@@ -804,7 +801,7 @@ bfa_fcs_port_ns_rspn_id_response(void *f
 				 u32 rsp_len, u32 resid_len,
 				 struct fchs_s *rsp_fchs)
 {
-	struct bfa_fcs_port_ns_s *ns = (struct bfa_fcs_port_ns_s *)cbarg;
+	struct bfa_fcs_port_ns_s *ns = (struct bfa_fcs_port_ns_s *) cbarg;
 	struct bfa_fcs_port_s *port = ns->port;
 	struct ct_hdr_s       *cthdr = NULL;
 
@@ -854,18 +851,19 @@ bfa_fcs_port_ns_send_rft_id(void *ns_cba
 	if (!fcxp) {
 		port->stats.ns_rftid_alloc_wait++;
 		bfa_fcxp_alloc_wait(port->fcs->bfa, &ns->fcxp_wqe,
-				    bfa_fcs_port_ns_send_rft_id, ns);
+					bfa_fcs_port_ns_send_rft_id, ns);
 		return;
 	}
 	ns->fcxp = fcxp;
 
 	len = fc_rftid_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),
-			     bfa_fcs_port_get_fcid(port), 0,
-			     port->port_cfg.roles);
+				bfa_fcs_port_get_fcid(port), 0,
+				port->port_cfg.roles);
 
 	bfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,
-		      FC_CLASS_3, len, &fchs, bfa_fcs_port_ns_rft_id_response,
-		      (void *)ns, FC_MAX_PDUSZ, FC_RA_TOV);
+			  FC_CLASS_3, len, &fchs,
+			  bfa_fcs_port_ns_rft_id_response, (void *)ns,
+			  FC_MAX_PDUSZ, FC_RA_TOV);
 
 	port->stats.ns_rftid_sent++;
 	bfa_sm_send_event(ns, NSSM_EVENT_RFTID_SENT);
@@ -877,7 +875,7 @@ bfa_fcs_port_ns_rft_id_response(void *fc
 				u32 rsp_len, u32 resid_len,
 				struct fchs_s *rsp_fchs)
 {
-	struct bfa_fcs_port_ns_s *ns = (struct bfa_fcs_port_ns_s *)cbarg;
+	struct bfa_fcs_port_ns_s *ns = (struct bfa_fcs_port_ns_s *) cbarg;
 	struct bfa_fcs_port_s *port = ns->port;
 	struct ct_hdr_s       *cthdr = NULL;
 
@@ -909,7 +907,7 @@ bfa_fcs_port_ns_rft_id_response(void *fc
 }
 
 /**
-* Register FC4-Features : Should be done after RFT_ID
+ * Register FC4-Features : Should be done after RFT_ID
  */
 static void
 bfa_fcs_port_ns_send_rff_id(void *ns_cbarg, struct bfa_fcxp_s *fcxp_alloced)
@@ -919,7 +917,7 @@ bfa_fcs_port_ns_send_rff_id(void *ns_cba
 	struct fchs_s          fchs;
 	int             len;
 	struct bfa_fcxp_s *fcxp;
-	u8         fc4_ftrs = 0;
+	u8			fc4_ftrs = 0;
 
 	bfa_trc(port->fcs, port->port_cfg.pwwn);
 
@@ -927,24 +925,24 @@ bfa_fcs_port_ns_send_rff_id(void *ns_cba
 	if (!fcxp) {
 		port->stats.ns_rffid_alloc_wait++;
 		bfa_fcxp_alloc_wait(port->fcs->bfa, &ns->fcxp_wqe,
-				    bfa_fcs_port_ns_send_rff_id, ns);
+					bfa_fcs_port_ns_send_rff_id, ns);
 		return;
 	}
 	ns->fcxp = fcxp;
 
-	if (BFA_FCS_VPORT_IS_INITIATOR_MODE(ns->port)) {
+	if (BFA_FCS_VPORT_IS_INITIATOR_MODE(ns->port))
 		fc4_ftrs = FC_GS_FCP_FC4_FEATURE_INITIATOR;
-	} else if (BFA_FCS_VPORT_IS_TARGET_MODE(ns->port)) {
+	else if (BFA_FCS_VPORT_IS_TARGET_MODE(ns->port))
 		fc4_ftrs = FC_GS_FCP_FC4_FEATURE_TARGET;
-	}
 
 	len = fc_rffid_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),
-			     bfa_fcs_port_get_fcid(port), 0, FC_TYPE_FCP,
-			     fc4_ftrs);
+			     bfa_fcs_port_get_fcid(port), 0,
+				 FC_TYPE_FCP, fc4_ftrs);
 
 	bfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,
-		      FC_CLASS_3, len, &fchs, bfa_fcs_port_ns_rff_id_response,
-		      (void *)ns, FC_MAX_PDUSZ, FC_RA_TOV);
+			  FC_CLASS_3, len, &fchs,
+			  bfa_fcs_port_ns_rff_id_response, (void *)ns,
+			  FC_MAX_PDUSZ, FC_RA_TOV);
 
 	port->stats.ns_rffid_sent++;
 	bfa_sm_send_event(ns, NSSM_EVENT_RFFID_SENT);
@@ -956,7 +954,7 @@ bfa_fcs_port_ns_rff_id_response(void *fc
 				u32 rsp_len, u32 resid_len,
 				struct fchs_s *rsp_fchs)
 {
-	struct bfa_fcs_port_ns_s *ns = (struct bfa_fcs_port_ns_s *)cbarg;
+	struct bfa_fcs_port_ns_s *ns = (struct bfa_fcs_port_ns_s *) cbarg;
 	struct bfa_fcs_port_s *port = ns->port;
 	struct ct_hdr_s       *cthdr = NULL;
 
@@ -986,19 +984,16 @@ bfa_fcs_port_ns_rff_id_response(void *fc
 	bfa_trc(port->fcs, cthdr->exp_code);
 
 	if (cthdr->reason_code == CT_RSN_NOT_SUPP) {
-		/*
-		 * if this command is not supported, we don't retry
-		 */
+		/* if this command is not supported, we don't retry */
 		bfa_sm_send_event(ns, NSSM_EVENT_RSP_OK);
 	} else {
 		bfa_sm_send_event(ns, NSSM_EVENT_RSP_ERROR);
 	}
 }
-
 /**
  * Query Fabric for FC4-Types Devices.
  *
-*  TBD : Need to use a local (FCS private) response buffer, since the response
+* TBD : Need to use a local (FCS private) response buffer, since the response
  * can be larger than 2K.
  */
 static void
@@ -1016,7 +1011,7 @@ bfa_fcs_port_ns_send_gid_ft(void *ns_cba
 	if (!fcxp) {
 		port->stats.ns_gidft_alloc_wait++;
 		bfa_fcxp_alloc_wait(port->fcs->bfa, &ns->fcxp_wqe,
-				    bfa_fcs_port_ns_send_gid_ft, ns);
+					bfa_fcs_port_ns_send_gid_ft, ns);
 		return;
 	}
 	ns->fcxp = fcxp;
@@ -1024,13 +1019,13 @@ bfa_fcs_port_ns_send_gid_ft(void *ns_cba
 	/*
 	 * This query is only initiated for FCP initiator mode.
 	 */
-	len = fc_gid_ft_build(&fchs, bfa_fcxp_get_reqbuf(fcxp), ns->port->pid,
-			      FC_TYPE_FCP);
+	len = fc_gid_ft_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),
+			      ns->port->pid, FC_TYPE_FCP);
 
 	bfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,
-		      FC_CLASS_3, len, &fchs, bfa_fcs_port_ns_gid_ft_response,
-		      (void *)ns, bfa_fcxp_get_maxrsp(port->fcs->bfa),
-		      FC_RA_TOV);
+			  FC_CLASS_3, len, &fchs,
+			  bfa_fcs_port_ns_gid_ft_response, (void *)ns,
+			  bfa_fcxp_get_maxrsp(port->fcs->bfa), FC_RA_TOV);
 
 	port->stats.ns_gidft_sent++;
 
@@ -1043,7 +1038,7 @@ bfa_fcs_port_ns_gid_ft_response(void *fc
 				u32 rsp_len, u32 resid_len,
 				struct fchs_s *rsp_fchs)
 {
-	struct bfa_fcs_port_ns_s *ns = (struct bfa_fcs_port_ns_s *)cbarg;
+	struct bfa_fcs_port_ns_s *ns = (struct bfa_fcs_port_ns_s *) cbarg;
 	struct bfa_fcs_port_s *port = ns->port;
 	struct ct_hdr_s       *cthdr = NULL;
 	u32        n_pids;
@@ -1118,19 +1113,19 @@ bfa_fcs_port_ns_gid_ft_response(void *fc
 /**
  *     This routine will be called by bfa_timer on timer timeouts.
  *
- * 	param[in] 	port 	- pointer to bfa_fcs_port_t.
+ * 	param[in] 	port 	- pointer to struct bfa_fcs_port_s.
  *
  * 	return
  * 		void
  *
-* 	Special Considerations:
+ * 	Special Considerations:
  *
  * 	note
  */
 static void
 bfa_fcs_port_ns_timeout(void *arg)
 {
-	struct bfa_fcs_port_ns_s *ns = (struct bfa_fcs_port_ns_s *)arg;
+	struct bfa_fcs_port_ns_s *ns = (struct bfa_fcs_port_ns_s *) arg;
 
 	ns->port->stats.ns_timeouts++;
 	bfa_sm_send_event(ns, NSSM_EVENT_TIMEOUT);
@@ -1140,8 +1135,8 @@ bfa_fcs_port_ns_timeout(void *arg)
  * Process the PID list in GID_FT response
  */
 static void
-bfa_fcs_port_ns_process_gidft_pids(struct bfa_fcs_port_s *port,
-				   u32 *pid_buf, u32 n_pids)
+bfa_fcs_port_ns_process_gidft_pids(struct bfa_fcs_port_s *port, u32 *pid_buf,
+				   u32 n_pids)
 {
 	struct fcgs_gidft_resp_s *gidft_entry;
 	struct bfa_fcs_rport_s *rport;
@@ -1228,13 +1223,13 @@ bfa_fcs_port_ns_boot_target_disc(struct 
 {
 
 	struct bfa_fcs_rport_s *rport;
-	u8         nwwns;
-	wwn_t          *wwns;
-	int             ii;
+	u8 nwwns;
+	wwn_t  *wwns;
+	int ii;
 
 	bfa_iocfc_get_bootwwns(port->fcs->bfa, &nwwns, &wwns);
 
-	for (ii = 0; ii < nwwns; ++ii) {
+	for (ii = 0 ; ii < nwwns; ++ii) {
 		rport = bfa_fcs_rport_create_by_wwn(port, wwns[ii]);
 		bfa_assert(rport);
 	}
diff -uprN a/drivers/scsi/bfa/plog.c b/drivers/scsi/bfa/plog.c
--- a/drivers/scsi/bfa/plog.c	2009-12-18 18:16:22.316722000 -0800
+++ b/drivers/scsi/bfa/plog.c	2009-11-25 18:21:07.000000000 -0800
@@ -180,5 +180,5 @@ bfa_plog_disable(struct bfa_plog_s *plog
 bfa_boolean_t
 bfa_plog_get_setting(struct bfa_plog_s *plog)
 {
-	return((bfa_boolean_t)plog->plog_enabled);
+	return (bfa_boolean_t)plog->plog_enabled;
 }
diff -uprN a/drivers/scsi/bfa/rport.c b/drivers/scsi/bfa/rport.c
--- a/drivers/scsi/bfa/rport.c	2009-12-18 18:16:22.315715000 -0800
+++ b/drivers/scsi/bfa/rport.c	2009-11-25 18:21:07.000000000 -0800
@@ -37,131 +37,130 @@ BFA_TRC_FILE(FCS, RPORT);
 
 #define BFA_FCS_RPORT_MAX_RETRIES		(5)
 
-/* In millisecs */
-static u32 bfa_fcs_rport_del_timeout =
-			BFA_FCS_RPORT_DEF_DEL_TIMEOUT * 1000;
-
+static u32
+bfa_fcs_rport_del_timeout =
+		BFA_FCS_RPORT_DEF_DEL_TIMEOUT * 1000; /* In millisecs */
 /*
  * forward declarations
  */
-static struct bfa_fcs_rport_s *bfa_fcs_rport_alloc(struct bfa_fcs_port_s *port,
-						   wwn_t pwwn, u32 rpid);
-static void     bfa_fcs_rport_free(struct bfa_fcs_rport_s *rport);
-static void     bfa_fcs_rport_hal_online(struct bfa_fcs_rport_s *rport);
-static void     bfa_fcs_rport_online_action(struct bfa_fcs_rport_s *rport);
-static void     bfa_fcs_rport_offline_action(struct bfa_fcs_rport_s *rport);
-static void     bfa_fcs_rport_update(struct bfa_fcs_rport_s *rport,
+static struct bfa_fcs_rport_s*
+bfa_fcs_rport_alloc(struct bfa_fcs_port_s *port, wwn_t pwwn,
+			   u32 rpid);
+static void	bfa_fcs_rport_free(struct bfa_fcs_rport_s *rport);
+static void	bfa_fcs_rport_hal_online(struct bfa_fcs_rport_s *rport);
+static void	bfa_fcs_rport_online_action(struct bfa_fcs_rport_s *rport);
+static void	bfa_fcs_rport_offline_action(struct bfa_fcs_rport_s *rport);
+static void	bfa_fcs_rport_update(struct bfa_fcs_rport_s *rport,
 				     struct fc_logi_s *plogi);
-static void     bfa_fcs_rport_fc4_pause(struct bfa_fcs_rport_s *rport);
-static void     bfa_fcs_rport_fc4_resume(struct bfa_fcs_rport_s *rport);
-static void     bfa_fcs_rport_timeout(void *arg);
-static void     bfa_fcs_rport_send_plogi(void *rport_cbarg,
+static void	bfa_fcs_rport_fc4_pause(struct bfa_fcs_rport_s *rport);
+static void	bfa_fcs_rport_fc4_resume(struct bfa_fcs_rport_s *rport);
+static void	bfa_fcs_rport_timeout(void *arg);
+static void	bfa_fcs_rport_send_plogi(void *rport_cbarg,
 					 struct bfa_fcxp_s *fcxp_alloced);
-static void     bfa_fcs_rport_send_plogiacc(void *rport_cbarg,
+static void	bfa_fcs_rport_send_plogiacc(void *rport_cbarg,
 					    struct bfa_fcxp_s *fcxp_alloced);
-static void     bfa_fcs_rport_plogi_response(void *fcsarg,
-					     struct bfa_fcxp_s *fcxp,
-					     void *cbarg,
-					     bfa_status_t req_status,
-					     u32 rsp_len,
-					     u32 resid_len,
-					     struct fchs_s *rsp_fchs);
-static void     bfa_fcs_rport_send_adisc(void *rport_cbarg,
+static void	bfa_fcs_rport_plogi_response(void *fcsarg,
+					struct bfa_fcxp_s *fcxp, void *cbarg,
+					bfa_status_t req_status,
+					u32 rsp_len,
+					u32 resid_len,
+					struct fchs_s *rsp_fchs);
+static void	bfa_fcs_rport_send_adisc(void *rport_cbarg,
 					 struct bfa_fcxp_s *fcxp_alloced);
-static void     bfa_fcs_rport_adisc_response(void *fcsarg,
-					     struct bfa_fcxp_s *fcxp,
-					     void *cbarg,
-					     bfa_status_t req_status,
-					     u32 rsp_len,
-					     u32 resid_len,
-					     struct fchs_s *rsp_fchs);
-static void     bfa_fcs_rport_send_gidpn(void *rport_cbarg,
+static void	bfa_fcs_rport_adisc_response(void *fcsarg,
+					struct bfa_fcxp_s *fcxp,
+					void *cbarg,
+					bfa_status_t req_status,
+					u32 rsp_len,
+					u32 resid_len,
+					struct fchs_s *rsp_fchs);
+static void	bfa_fcs_rport_send_gidpn(void *rport_cbarg,
 					 struct bfa_fcxp_s *fcxp_alloced);
-static void     bfa_fcs_rport_gidpn_response(void *fcsarg,
-					     struct bfa_fcxp_s *fcxp,
-					     void *cbarg,
-					     bfa_status_t req_status,
-					     u32 rsp_len,
-					     u32 resid_len,
-					     struct fchs_s *rsp_fchs);
-static void     bfa_fcs_rport_send_logo(void *rport_cbarg,
+static void	bfa_fcs_rport_gidpn_response(void *fcsarg,
+					struct bfa_fcxp_s *fcxp,
+					void *cbarg,
+					bfa_status_t req_status,
+					u32 rsp_len,
+					u32 resid_len,
+					struct fchs_s *rsp_fchs);
+static void	bfa_fcs_rport_send_logo(void *rport_cbarg,
 					struct bfa_fcxp_s *fcxp_alloced);
-static void     bfa_fcs_rport_send_logo_acc(void *rport_cbarg);
-static void     bfa_fcs_rport_process_prli(struct bfa_fcs_rport_s *rport,
-			struct fchs_s *rx_fchs, u16 len);
-static void     bfa_fcs_rport_send_ls_rjt(struct bfa_fcs_rport_s *rport,
-			struct fchs_s *rx_fchs, u8 reason_code,
-			u8 reason_code_expl);
-static void     bfa_fcs_rport_process_adisc(struct bfa_fcs_rport_s *rport,
-			struct fchs_s *rx_fchs, u16 len);
+static void	bfa_fcs_rport_send_logo_acc(void *rport_cbarg);
+static void	bfa_fcs_rport_process_prli(struct bfa_fcs_rport_s *rport,
+					   struct fchs_s *rx_fchs, u16 len);
+static void	bfa_fcs_rport_send_ls_rjt(struct bfa_fcs_rport_s *rport,
+				struct fchs_s *rx_fchs, u8 reason_code,
+					  u8 reason_code_expl);
+static void	bfa_fcs_rport_process_adisc(struct bfa_fcs_rport_s *rport,
+					  struct fchs_s *rx_fchs, u16 len);
 /**
  *  fcs_rport_sm FCS rport state machine events
  */
 
 enum rport_event {
-	RPSM_EVENT_PLOGI_SEND = 1,	/*  new rport; start with PLOGI */
-	RPSM_EVENT_PLOGI_RCVD = 2,	/*  Inbound PLOGI from remote port */
-	RPSM_EVENT_PLOGI_COMP = 3,	/*  PLOGI completed to rport */
-	RPSM_EVENT_LOGO_RCVD = 4,	/*  LOGO from remote device */
-	RPSM_EVENT_LOGO_IMP = 5,	/*  implicit logo for SLER */
-	RPSM_EVENT_FCXP_SENT = 6,	/*  Frame from has been sent */
-	RPSM_EVENT_DELETE = 7,	/*  RPORT delete request */
-	RPSM_EVENT_SCN = 8,	/*  state change notification */
-	RPSM_EVENT_ACCEPTED = 9,/*  Good response from remote device */
-	RPSM_EVENT_FAILED = 10,	/*  Request to rport failed.  */
-	RPSM_EVENT_TIMEOUT = 11,	/*  Rport SM timeout event */
-	RPSM_EVENT_HCB_ONLINE = 12,	/*  BFA rport online callback */
-	RPSM_EVENT_HCB_OFFLINE = 13,	/*  BFA rport offline callback */
-	RPSM_EVENT_FC4_OFFLINE = 14,	/*  FC-4 offline complete */
-	RPSM_EVENT_ADDRESS_CHANGE = 15,	/*  Rport's PID has changed */
-	RPSM_EVENT_ADDRESS_DISC = 16	/*  Need to Discover rport's PID */
+	RPSM_EVENT_PLOGI_SEND  = 1,	 /*  new rport; start with PLOGI     */
+	RPSM_EVENT_PLOGI_RCVD  = 2,	 /*  Inbound PLOGI from remote port  */
+	RPSM_EVENT_PLOGI_COMP  = 3,	 /*  PLOGI completed to rport	      */
+	RPSM_EVENT_LOGO_RCVD   = 4,	 /*  LOGO from remote device	      */
+	RPSM_EVENT_LOGO_IMP    = 5,	 /*  implicit logo for SLER	      */
+	RPSM_EVENT_FCXP_SENT   = 6,	 /*  Frame from has been sent	      */
+	RPSM_EVENT_DELETE      = 7,	/*  RPORT delete request	      */
+	RPSM_EVENT_SCN	       = 8,	 /*  state change notification	      */
+	RPSM_EVENT_ACCEPTED    = 9,	 /*  Good response from remote device*/
+	RPSM_EVENT_FAILED      = 10,	 /*  Request to rport failed.	      */
+	RPSM_EVENT_TIMEOUT     = 11,	 /*  Rport SM timeout event	      */
+	RPSM_EVENT_HCB_ONLINE  = 12,	 /*  BFA rport online callback	      */
+	RPSM_EVENT_HCB_OFFLINE = 13,	 /*  BFA rport offline callback      */
+	RPSM_EVENT_FC4_OFFLINE = 14,	 /*  FC-4 offline complete	      */
+	RPSM_EVENT_ADDRESS_CHANGE = 15,	 /*  Rport's PID has changed	      */
+	RPSM_EVENT_ADDRESS_DISC = 16	/*  Need to Discover rport's PID     */
 };
 
-static void     bfa_fcs_rport_sm_uninit(struct bfa_fcs_rport_s *rport,
+static void	bfa_fcs_rport_sm_uninit(struct bfa_fcs_rport_s *rport,
 					enum rport_event event);
-static void     bfa_fcs_rport_sm_plogi_sending(struct bfa_fcs_rport_s *rport,
+static void	bfa_fcs_rport_sm_plogi_sending(struct bfa_fcs_rport_s *rport,
 					       enum rport_event event);
-static void     bfa_fcs_rport_sm_plogiacc_sending(struct bfa_fcs_rport_s *rport,
+static void	bfa_fcs_rport_sm_plogiacc_sending(struct bfa_fcs_rport_s *rport,
 						  enum rport_event event);
-static void     bfa_fcs_rport_sm_plogi_retry(struct bfa_fcs_rport_s *rport,
+static void	bfa_fcs_rport_sm_plogi_retry(struct bfa_fcs_rport_s *rport,
 					     enum rport_event event);
-static void     bfa_fcs_rport_sm_plogi(struct bfa_fcs_rport_s *rport,
+static void	bfa_fcs_rport_sm_plogi(struct bfa_fcs_rport_s *rport,
 				       enum rport_event event);
-static void     bfa_fcs_rport_sm_hal_online(struct bfa_fcs_rport_s *rport,
+static void	bfa_fcs_rport_sm_hal_online(struct bfa_fcs_rport_s *rport,
 					    enum rport_event event);
-static void     bfa_fcs_rport_sm_online(struct bfa_fcs_rport_s *rport,
+static void	bfa_fcs_rport_sm_online(struct bfa_fcs_rport_s *rport,
 					enum rport_event event);
-static void     bfa_fcs_rport_sm_nsquery_sending(struct bfa_fcs_rport_s *rport,
+static void	bfa_fcs_rport_sm_nsquery_sending(struct bfa_fcs_rport_s *rport,
 						 enum rport_event event);
-static void     bfa_fcs_rport_sm_nsquery(struct bfa_fcs_rport_s *rport,
+static void	bfa_fcs_rport_sm_nsquery(struct bfa_fcs_rport_s *rport,
 					 enum rport_event event);
-static void     bfa_fcs_rport_sm_adisc_sending(struct bfa_fcs_rport_s *rport,
+static void	bfa_fcs_rport_sm_adisc_sending(struct bfa_fcs_rport_s *rport,
 					       enum rport_event event);
-static void     bfa_fcs_rport_sm_adisc(struct bfa_fcs_rport_s *rport,
+static void	bfa_fcs_rport_sm_adisc(struct bfa_fcs_rport_s *rport,
 				       enum rport_event event);
-static void     bfa_fcs_rport_sm_fc4_logorcv(struct bfa_fcs_rport_s *rport,
+static void	bfa_fcs_rport_sm_fc4_logorcv(struct bfa_fcs_rport_s *rport,
 					     enum rport_event event);
-static void     bfa_fcs_rport_sm_fc4_logosend(struct bfa_fcs_rport_s *rport,
+static void	bfa_fcs_rport_sm_fc4_logosend(struct bfa_fcs_rport_s *rport,
 					      enum rport_event event);
-static void     bfa_fcs_rport_sm_fc4_offline(struct bfa_fcs_rport_s *rport,
+static void	bfa_fcs_rport_sm_fc4_offline(struct bfa_fcs_rport_s *rport,
 					     enum rport_event event);
-static void     bfa_fcs_rport_sm_hcb_offline(struct bfa_fcs_rport_s *rport,
+static void	bfa_fcs_rport_sm_hcb_offline(struct bfa_fcs_rport_s *rport,
 					     enum rport_event event);
-static void     bfa_fcs_rport_sm_hcb_logorcv(struct bfa_fcs_rport_s *rport,
+static void	bfa_fcs_rport_sm_hcb_logorcv(struct bfa_fcs_rport_s *rport,
 					     enum rport_event event);
-static void     bfa_fcs_rport_sm_hcb_logosend(struct bfa_fcs_rport_s *rport,
+static void	bfa_fcs_rport_sm_hcb_logosend(struct bfa_fcs_rport_s *rport,
 					      enum rport_event event);
-static void     bfa_fcs_rport_sm_logo_sending(struct bfa_fcs_rport_s *rport,
+static void	bfa_fcs_rport_sm_logo_sending(struct bfa_fcs_rport_s *rport,
 					      enum rport_event event);
-static void     bfa_fcs_rport_sm_offline(struct bfa_fcs_rport_s *rport,
+static void	bfa_fcs_rport_sm_offline(struct bfa_fcs_rport_s *rport,
 					 enum rport_event event);
-static void     bfa_fcs_rport_sm_nsdisc_sending(struct bfa_fcs_rport_s *rport,
+static void	bfa_fcs_rport_sm_nsdisc_sending(struct bfa_fcs_rport_s *rport,
 						enum rport_event event);
-static void     bfa_fcs_rport_sm_nsdisc_retry(struct bfa_fcs_rport_s *rport,
+static void	bfa_fcs_rport_sm_nsdisc_retry(struct bfa_fcs_rport_s *rport,
 					      enum rport_event event);
-static void     bfa_fcs_rport_sm_nsdisc_sent(struct bfa_fcs_rport_s *rport,
+static void	bfa_fcs_rport_sm_nsdisc_sent(struct bfa_fcs_rport_s *rport,
 					     enum rport_event event);
-static void     bfa_fcs_rport_sm_nsdisc_sent(struct bfa_fcs_rport_s *rport,
+static void	bfa_fcs_rport_sm_nsdisc_sent(struct bfa_fcs_rport_s *rport,
 					     enum rport_event event);
 
 static struct bfa_sm_table_s rport_sm_table[] = {
@@ -190,7 +189,7 @@ static struct bfa_sm_table_s rport_sm_ta
 };
 
 /**
- * 		Beginning state.
+ *		Beginning state.
  */
 static void
 bfa_fcs_rport_sm_uninit(struct bfa_fcs_rport_s *rport, enum rport_event event)
@@ -224,16 +223,16 @@ bfa_fcs_rport_sm_uninit(struct bfa_fcs_r
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(rport->fcs, event);
 	}
 }
 
 /**
- * 		PLOGI is being sent.
+ *		PLOGI is being sent.
  */
 static void
 bfa_fcs_rport_sm_plogi_sending(struct bfa_fcs_rport_s *rport,
-			       enum rport_event event)
+					enum rport_event event)
 {
 	bfa_trc(rport->fcs, rport->pwwn);
 	bfa_trc(rport->fcs, rport->pid);
@@ -276,16 +275,16 @@ bfa_fcs_rport_sm_plogi_sending(struct bf
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(rport->fcs, event);
 	}
 }
 
 /**
- * 		PLOGI is being sent.
+ *		PLOGI is being sent.
  */
 static void
 bfa_fcs_rport_sm_plogiacc_sending(struct bfa_fcs_rport_s *rport,
-				  enum rport_event event)
+					enum rport_event event)
 {
 	bfa_trc(rport->fcs, rport->pwwn);
 	bfa_trc(rport->fcs, rport->pid);
@@ -332,16 +331,16 @@ bfa_fcs_rport_sm_plogiacc_sending(struct
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(rport->fcs, event);
 	}
 }
 
 /**
- * 		PLOGI is sent.
+ *		PLOGI is sent.
  */
 static void
 bfa_fcs_rport_sm_plogi_retry(struct bfa_fcs_rport_s *rport,
-			enum rport_event event)
+				enum rport_event event)
 {
 	bfa_trc(rport->fcs, rport->pwwn);
 	bfa_trc(rport->fcs, rport->pid);
@@ -406,15 +405,16 @@ bfa_fcs_rport_sm_plogi_retry(struct bfa_
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(rport->fcs, event);
 	}
 }
 
 /**
- * 		PLOGI is sent.
+ *		PLOGI is sent.
  */
 static void
-bfa_fcs_rport_sm_plogi(struct bfa_fcs_rport_s *rport, enum rport_event event)
+bfa_fcs_rport_sm_plogi(struct bfa_fcs_rport_s *rport,
+				enum rport_event event)
 {
 	bfa_trc(rport->fcs, rport->pwwn);
 	bfa_trc(rport->fcs, rport->pid);
@@ -440,6 +440,7 @@ bfa_fcs_rport_sm_plogi(struct bfa_fcs_rp
 				BFA_FCS_RETRY_TIMEOUT);
 		break;
 
+
 	case RPSM_EVENT_LOGO_IMP:
 		rport->pid = 0;
 		bfa_sm_set_state(rport, bfa_fcs_rport_sm_offline);
@@ -481,17 +482,17 @@ bfa_fcs_rport_sm_plogi(struct bfa_fcs_rp
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(rport->fcs, event);
 	}
 }
 
 /**
- * 		PLOGI is complete. Awaiting BFA rport online callback. FC-4s
- * 		are offline.
+ *		PLOGI is complete. Awaiting BFA rport online callback. FC-4s
+ *		are offline.
  */
 static void
 bfa_fcs_rport_sm_hal_online(struct bfa_fcs_rport_s *rport,
-			enum rport_event event)
+					enum rport_event event)
 {
 	bfa_trc(rport->fcs, rport->pwwn);
 	bfa_trc(rport->fcs, rport->pid);
@@ -534,15 +535,16 @@ bfa_fcs_rport_sm_hal_online(struct bfa_f
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(rport->fcs, event);
 	}
 }
 
 /**
- * 		Rport is ONLINE. FC-4s active.
+ *		Rport is ONLINE. FC-4s active.
  */
 static void
-bfa_fcs_rport_sm_online(struct bfa_fcs_rport_s *rport, enum rport_event event)
+bfa_fcs_rport_sm_online(struct bfa_fcs_rport_s *rport,
+				enum rport_event event)
 {
 	bfa_trc(rport->fcs, rport->pwwn);
 	bfa_trc(rport->fcs, rport->pid);
@@ -589,17 +591,17 @@ bfa_fcs_rport_sm_online(struct bfa_fcs_r
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(rport->fcs, event);
 	}
 }
 
 /**
- * 		An SCN event is received in ONLINE state. NS query is being sent
- * 		prior to ADISC authentication with rport. FC-4s are paused.
+ *		An SCN event is received in ONLINE state. NS query is being sent
+ *		prior to ADISC authentication with rport. FC-4s are paused.
  */
 static void
 bfa_fcs_rport_sm_nsquery_sending(struct bfa_fcs_rport_s *rport,
-				 enum rport_event event)
+					enum rport_event event)
 {
 	bfa_trc(rport->fcs, rport->pwwn);
 	bfa_trc(rport->fcs, rport->pid);
@@ -646,13 +648,13 @@ bfa_fcs_rport_sm_nsquery_sending(struct 
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(rport->fcs, event);
 	}
 }
 
 /**
- * 	An SCN event is received in ONLINE state. NS query is sent to rport.
- * 	FC-4s are paused.
+ *	An SCN event is received in ONLINE state. NS query is sent to rport.
+ *	FC-4s are paused.
  */
 static void
 bfa_fcs_rport_sm_nsquery(struct bfa_fcs_rport_s *rport, enum rport_event event)
@@ -704,17 +706,17 @@ bfa_fcs_rport_sm_nsquery(struct bfa_fcs_
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(rport->fcs, event);
 	}
 }
 
 /**
- * 	An SCN event is received in ONLINE state. ADISC is being sent for
- * 	authenticating with rport. FC-4s are paused.
+ *	An SCN event is received in ONLINE state. ADISC is being sent for
+ *	authenticating with rport. FC-4s are paused.
  */
 static void
 bfa_fcs_rport_sm_adisc_sending(struct bfa_fcs_rport_s *rport,
-			       enum rport_event event)
+					enum rport_event event)
 {
 	bfa_trc(rport->fcs, rport->pwwn);
 	bfa_trc(rport->fcs, rport->pid);
@@ -754,13 +756,13 @@ bfa_fcs_rport_sm_adisc_sending(struct bf
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(rport->fcs, event);
 	}
 }
 
 /**
- * 		An SCN event is received in ONLINE state. ADISC is to rport.
- * 		FC-4s are paused.
+ *		An SCN event is received in ONLINE state. ADISC is to rport.
+ *		FC-4s are paused.
  */
 static void
 bfa_fcs_rport_sm_adisc(struct bfa_fcs_rport_s *rport, enum rport_event event)
@@ -816,16 +818,16 @@ bfa_fcs_rport_sm_adisc(struct bfa_fcs_rp
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(rport->fcs, event);
 	}
 }
 
 /**
- * 		Rport has sent LOGO. Awaiting FC-4 offline completion callback.
+ *		Rport has sent LOGO. Awaiting FC-4 offline completion callback.
  */
 static void
 bfa_fcs_rport_sm_fc4_logorcv(struct bfa_fcs_rport_s *rport,
-			enum rport_event event)
+				enum rport_event event)
 {
 	bfa_trc(rport->fcs, rport->pwwn);
 	bfa_trc(rport->fcs, rport->pid);
@@ -846,17 +848,17 @@ bfa_fcs_rport_sm_fc4_logorcv(struct bfa_
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(rport->fcs, event);
 	}
 }
 
 /**
- * 		LOGO needs to be sent to rport. Awaiting FC-4 offline completion
- * 		callback.
+ *		LOGO needs to be sent to rport. Awaiting FC-4 offline completion
+ *		callback.
  */
 static void
 bfa_fcs_rport_sm_fc4_logosend(struct bfa_fcs_rport_s *rport,
-			      enum rport_event event)
+					enum rport_event event)
 {
 	bfa_trc(rport->fcs, rport->pwwn);
 	bfa_trc(rport->fcs, rport->pid);
@@ -869,16 +871,16 @@ bfa_fcs_rport_sm_fc4_logosend(struct bfa
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(rport->fcs, event);
 	}
 }
 
 /**
- * 	Rport is going offline. Awaiting FC-4 offline completion callback.
+ *	Rport is going offline. Awaiting FC-4 offline completion callback.
  */
 static void
 bfa_fcs_rport_sm_fc4_offline(struct bfa_fcs_rport_s *rport,
-			enum rport_event event)
+					enum rport_event event)
 {
 	bfa_trc(rport->fcs, rport->pwwn);
 	bfa_trc(rport->fcs, rport->pid);
@@ -905,17 +907,17 @@ bfa_fcs_rport_sm_fc4_offline(struct bfa_
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(rport->fcs, event);
 	}
 }
 
 /**
- * 		Rport is offline. FC-4s are offline. Awaiting BFA rport offline
- * 		callback.
+ *		Rport is offline. FC-4s are offline. Awaiting BFA rport offline
+ *		callback.
  */
 static void
 bfa_fcs_rport_sm_hcb_offline(struct bfa_fcs_rport_s *rport,
-			enum rport_event event)
+				enum rport_event event)
 {
 	bfa_trc(rport->fcs, rport->pwwn);
 	bfa_trc(rport->fcs, rport->pid);
@@ -925,10 +927,17 @@ bfa_fcs_rport_sm_hcb_offline(struct bfa_
 	case RPSM_EVENT_HCB_OFFLINE:
 	case RPSM_EVENT_ADDRESS_CHANGE:
 		if (bfa_fcs_port_is_online(rport->port)) {
-			bfa_sm_set_state(rport,
-					 bfa_fcs_rport_sm_nsdisc_sending);
-			rport->ns_retries = 0;
-			bfa_fcs_rport_send_gidpn(rport, NULL);
+			if (bfa_fcs_fabric_is_switched(rport->port->fabric)) {
+				bfa_sm_set_state(rport,
+					bfa_fcs_rport_sm_nsdisc_sending);
+				rport->ns_retries = 0;
+				bfa_fcs_rport_send_gidpn(rport, NULL);
+			} else {
+			    bfa_sm_set_state(rport,
+					bfa_fcs_rport_sm_plogi_sending);
+			    rport->plogi_retries = 0;
+			    bfa_fcs_rport_send_plogi(rport, NULL);
+			}
 		} else {
 			rport->pid = 0;
 			bfa_sm_set_state(rport, bfa_fcs_rport_sm_offline);
@@ -951,17 +960,17 @@ bfa_fcs_rport_sm_hcb_offline(struct bfa_
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(rport->fcs, event);
 	}
 }
 
 /**
- * 		Rport is offline. FC-4s are offline. Awaiting BFA rport offline
- * 		callback to send LOGO accept.
+ *		Rport is offline. FC-4s are offline. Awaiting BFA rport offline
+ *		callback to send LOGO accept.
  */
 static void
 bfa_fcs_rport_sm_hcb_logorcv(struct bfa_fcs_rport_s *rport,
-			enum rport_event event)
+					enum rport_event event)
 {
 	bfa_trc(rport->fcs, rport->pwwn);
 	bfa_trc(rport->fcs, rport->pid);
@@ -973,19 +982,20 @@ bfa_fcs_rport_sm_hcb_logorcv(struct bfa_
 		if (rport->pid)
 			bfa_fcs_rport_send_logo_acc(rport);
 		/*
-		 * If the lport is online and if the rport is not a well known
-		 * address port, we try to re-discover the r-port.
+		 * If the lport is online and if the rport is not
+		 * a well known address port, we try to re-discover
+		 * the r-port.
 		 */
-		if (bfa_fcs_port_is_online(rport->port)
-		    && (!BFA_FCS_PID_IS_WKA(rport->pid))) {
+		if (bfa_fcs_port_is_online(rport->port) &&
+		    (!BFA_FCS_PID_IS_WKA(rport->pid))) {
 			bfa_sm_set_state(rport,
-					 bfa_fcs_rport_sm_nsdisc_sending);
+					bfa_fcs_rport_sm_nsdisc_sending);
 			rport->ns_retries = 0;
 			bfa_fcs_rport_send_gidpn(rport, NULL);
 		} else {
 			/*
-			 * if it is not a well known address, reset the pid to
-			 *
+			 * if it is not a well known address,
+			 * reset the pid to 0
 			 */
 			if (!BFA_FCS_PID_IS_WKA(rport->pid))
 				rport->pid = 0;
@@ -1011,17 +1021,17 @@ bfa_fcs_rport_sm_hcb_logorcv(struct bfa_
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(rport->fcs, event);
 	}
 }
 
 /**
- * Rport is being deleted. FC-4s are offline. Awaiting BFA rport offline
- * callback to send LOGO.
+ *	Rport is being deleted. FC-4s are offline. Awaiting BFA rport offline
+ *	callback to send LOGO.
  */
 static void
 bfa_fcs_rport_sm_hcb_logosend(struct bfa_fcs_rport_s *rport,
-			      enum rport_event event)
+				enum rport_event event)
 {
 	bfa_trc(rport->fcs, rport->pwwn);
 	bfa_trc(rport->fcs, rport->pid);
@@ -1038,16 +1048,16 @@ bfa_fcs_rport_sm_hcb_logosend(struct bfa
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(rport->fcs, event);
 	}
 }
 
 /**
- * 		Rport is being deleted. FC-4s are offline. LOGO is being sent.
+ *	Rport is being deleted. FC-4s are offline. LOGO is being sent.
  */
 static void
 bfa_fcs_rport_sm_logo_sending(struct bfa_fcs_rport_s *rport,
-			      enum rport_event event)
+				enum rport_event event)
 {
 	bfa_trc(rport->fcs, rport->pwwn);
 	bfa_trc(rport->fcs, rport->pid);
@@ -1055,9 +1065,7 @@ bfa_fcs_rport_sm_logo_sending(struct bfa
 
 	switch (event) {
 	case RPSM_EVENT_FCXP_SENT:
-		/*
-		 * Once LOGO is sent, we donot wait for the response
-		 */
+		/* Once LOGO is sent, we donot wait for the response */
 		bfa_sm_set_state(rport, bfa_fcs_rport_sm_uninit);
 		bfa_fcs_rport_free(rport);
 		break;
@@ -1073,16 +1081,17 @@ bfa_fcs_rport_sm_logo_sending(struct bfa
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(rport->fcs, event);
 	}
 }
 
 /**
- * 		Rport is offline. FC-4s are offline. BFA rport is offline.
- * 		Timer active to delete stale rport.
+ *	Rport is offline. FC-4s are offline. BFA rport is offline.
+ *	Timer active to delete stale rport.
  */
 static void
-bfa_fcs_rport_sm_offline(struct bfa_fcs_rport_s *rport, enum rport_event event)
+bfa_fcs_rport_sm_offline(struct bfa_fcs_rport_s *rport,
+				enum rport_event event)
 {
 	bfa_trc(rport->fcs, rport->pwwn);
 	bfa_trc(rport->fcs, rport->pid);
@@ -1132,12 +1141,12 @@ bfa_fcs_rport_sm_offline(struct bfa_fcs_
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(rport->fcs, event);
 	}
 }
 
 /**
- * 	Rport address has changed. Nameserver discovery request is being sent.
+ *	Rport address has changed. Nameserver discovery request is being sent.
  */
 static void
 bfa_fcs_rport_sm_nsdisc_sending(struct bfa_fcs_rport_s *rport,
@@ -1170,7 +1179,7 @@ bfa_fcs_rport_sm_nsdisc_sending(struct b
 		break;
 
 	case RPSM_EVENT_ADDRESS_CHANGE:
-		rport->ns_retries = 0;	/* reset the retry count */
+		rport->ns_retries = 0; /* reset the retry count */
 		break;
 
 	case RPSM_EVENT_LOGO_IMP:
@@ -1188,16 +1197,16 @@ bfa_fcs_rport_sm_nsdisc_sending(struct b
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(rport->fcs, event);
 	}
 }
 
 /**
- * 		Nameserver discovery failed. Waiting for timeout to retry.
+ *	Nameserver discovery failed. Waiting for timeout to retry.
  */
 static void
 bfa_fcs_rport_sm_nsdisc_retry(struct bfa_fcs_rport_s *rport,
-			      enum rport_event event)
+				enum rport_event event)
 {
 	bfa_trc(rport->fcs, rport->pwwn);
 	bfa_trc(rport->fcs, rport->pid);
@@ -1249,16 +1258,16 @@ bfa_fcs_rport_sm_nsdisc_retry(struct bfa
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(rport->fcs, event);
 	}
 }
 
 /**
- * Rport address has changed. Nameserver discovery request is sent.
+ *		Rport address has changed. Nameserver discovery request is sent.
  */
 static void
 bfa_fcs_rport_sm_nsdisc_sent(struct bfa_fcs_rport_s *rport,
-			enum rport_event event)
+					enum rport_event event)
 {
 	bfa_trc(rport->fcs, rport->pwwn);
 	bfa_trc(rport->fcs, rport->pid);
@@ -1272,7 +1281,7 @@ bfa_fcs_rport_sm_nsdisc_sent(struct bfa_
 			bfa_fcs_rport_send_plogi(rport, NULL);
 		} else {
 			bfa_sm_set_state(rport,
-					 bfa_fcs_rport_sm_nsdisc_sending);
+				bfa_fcs_rport_sm_nsdisc_sending);
 			rport->ns_retries = 0;
 			bfa_fcs_rport_send_gidpn(rport, NULL);
 		}
@@ -1282,7 +1291,7 @@ bfa_fcs_rport_sm_nsdisc_sent(struct bfa_
 		rport->ns_retries++;
 		if (rport->ns_retries < BFA_FCS_RPORT_MAX_RETRIES) {
 			bfa_sm_set_state(rport,
-					 bfa_fcs_rport_sm_nsdisc_sending);
+				bfa_fcs_rport_sm_nsdisc_sending);
 			bfa_fcs_rport_send_gidpn(rport, NULL);
 		} else {
 			rport->pid = 0;
@@ -1334,7 +1343,7 @@ bfa_fcs_rport_sm_nsdisc_sent(struct bfa_
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(rport->fcs, event);
 	}
 }
 
@@ -1349,8 +1358,8 @@ bfa_fcs_rport_send_plogi(void *rport_cba
 {
 	struct bfa_fcs_rport_s *rport = rport_cbarg;
 	struct bfa_fcs_port_s *port = rport->port;
-	struct fchs_s          fchs;
-	int             len;
+	struct fchs_s		fchs;
+	int		len;
 	struct bfa_fcxp_s *fcxp;
 
 	bfa_trc(rport->fcs, rport->pwwn);
@@ -1366,7 +1375,7 @@ bfa_fcs_rport_send_plogi(void *rport_cba
 	len = fc_plogi_build(&fchs, bfa_fcxp_get_reqbuf(fcxp), rport->pid,
 			     bfa_fcs_port_get_fcid(port), 0,
 			     port->port_cfg.pwwn, port->port_cfg.nwwn,
-			     bfa_pport_get_maxfrsize(port->fcs->bfa));
+			     bfa_fcport_get_maxfrsize(port->fcs->bfa));
 
 	bfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,
 		      FC_CLASS_3, len, &fchs, bfa_fcs_rport_plogi_response,
@@ -1381,11 +1390,11 @@ bfa_fcs_rport_plogi_response(void *fcsar
 			     bfa_status_t req_status, u32 rsp_len,
 			     u32 resid_len, struct fchs_s *rsp_fchs)
 {
-	struct bfa_fcs_rport_s *rport = (struct bfa_fcs_rport_s *)cbarg;
+	struct bfa_fcs_rport_s *rport = (struct bfa_fcs_rport_s *) cbarg;
 	struct fc_logi_s	*plogi_rsp;
 	struct fc_ls_rjt_s	*ls_rjt;
 	struct bfa_fcs_rport_s *twin;
-	struct list_head *qe;
+	struct list_head	*qe;
 
 	bfa_trc(rport->fcs, rport->pwwn);
 
@@ -1420,22 +1429,23 @@ bfa_fcs_rport_plogi_response(void *fcsar
 	 * device with a new FC port address.
 	 */
 	list_for_each(qe, &rport->port->rport_q) {
-		twin = (struct bfa_fcs_rport_s *)qe;
+		twin = (struct bfa_fcs_rport_s *) qe;
 		if (twin == rport)
 			continue;
 		if (!rport->pwwn && (plogi_rsp->port_name == twin->pwwn)) {
 			bfa_trc(rport->fcs, twin->pid);
 			bfa_trc(rport->fcs, rport->pid);
 
-			/*
-			 * Update plogi stats in twin
-			 */
-			twin->stats.plogis += rport->stats.plogis;
-			twin->stats.plogi_rejects += rport->stats.plogi_rejects;
+			/* Update plogi stats in twin */
+			twin->stats.plogis  += rport->stats.plogis;
+			twin->stats.plogi_rejects +=
+						rport->stats.plogi_rejects;
 			twin->stats.plogi_timeouts +=
-				rport->stats.plogi_timeouts;
-			twin->stats.plogi_failed += rport->stats.plogi_failed;
-			twin->stats.plogi_rcvd += rport->stats.plogi_rcvd;
+						rport->stats.plogi_timeouts;
+			twin->stats.plogi_failed +=
+						rport->stats.plogi_failed;
+			twin->stats.plogi_rcvd +=
+						rport->stats.plogi_rcvd;
 			twin->stats.plogi_accs++;
 
 			bfa_fcs_rport_delete(rport);
@@ -1460,8 +1470,8 @@ bfa_fcs_rport_send_plogiacc(void *rport_
 {
 	struct bfa_fcs_rport_s *rport = rport_cbarg;
 	struct bfa_fcs_port_s *port = rport->port;
-	struct fchs_s          fchs;
-	int             len;
+	struct fchs_s		fchs;
+	int		len;
 	struct bfa_fcxp_s *fcxp;
 
 	bfa_trc(rport->fcs, rport->pwwn);
@@ -1475,10 +1485,11 @@ bfa_fcs_rport_send_plogiacc(void *rport_
 	}
 	rport->fcxp = fcxp;
 
-	len = fc_plogi_acc_build(&fchs, bfa_fcxp_get_reqbuf(fcxp), rport->pid,
-				 bfa_fcs_port_get_fcid(port), rport->reply_oxid,
-				 port->port_cfg.pwwn, port->port_cfg.nwwn,
-				 bfa_pport_get_maxfrsize(port->fcs->bfa));
+	len = fc_plogi_acc_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),
+				 rport->pid, bfa_fcs_port_get_fcid(port),
+				 rport->reply_oxid, port->port_cfg.pwwn,
+				 port->port_cfg.nwwn,
+				 bfa_fcport_get_maxfrsize(port->fcs->bfa));
 
 	bfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,
 		      FC_CLASS_3, len, &fchs, NULL, NULL, FC_MAX_PDUSZ, 0);
@@ -1491,8 +1502,8 @@ bfa_fcs_rport_send_adisc(void *rport_cba
 {
 	struct bfa_fcs_rport_s *rport = rport_cbarg;
 	struct bfa_fcs_port_s *port = rport->port;
-	struct fchs_s          fchs;
-	int             len;
+	struct fchs_s		fchs;
+	int		len;
 	struct bfa_fcxp_s *fcxp;
 
 	bfa_trc(rport->fcs, rport->pwwn);
@@ -1522,8 +1533,8 @@ bfa_fcs_rport_adisc_response(void *fcsar
 			     bfa_status_t req_status, u32 rsp_len,
 			     u32 resid_len, struct fchs_s *rsp_fchs)
 {
-	struct bfa_fcs_rport_s *rport = (struct bfa_fcs_rport_s *)cbarg;
-	void           *pld = bfa_fcxp_get_rspbuf(fcxp);
+	struct bfa_fcs_rport_s *rport = (struct bfa_fcs_rport_s *) cbarg;
+	void	       *pld = bfa_fcxp_get_rspbuf(fcxp);
 	struct fc_ls_rjt_s    *ls_rjt;
 
 	if (req_status != BFA_STATUS_OK) {
@@ -1534,7 +1545,7 @@ bfa_fcs_rport_adisc_response(void *fcsar
 	}
 
 	if (fc_adisc_rsp_parse((struct fc_adisc_s *)pld, rsp_len, rport->pwwn,
-		rport->nwwn)  == FC_PARSE_OK) {
+			       rport->nwwn)  == FC_PARSE_OK) {
 		rport->stats.adisc_accs++;
 		bfa_sm_send_event(rport, RPSM_EVENT_ACCEPTED);
 		return;
@@ -1553,9 +1564,9 @@ bfa_fcs_rport_send_gidpn(void *rport_cba
 {
 	struct bfa_fcs_rport_s *rport = rport_cbarg;
 	struct bfa_fcs_port_s *port = rport->port;
-	struct fchs_s          fchs;
+	struct fchs_s		fchs;
 	struct bfa_fcxp_s *fcxp;
-	int             len;
+	int		len;
 
 	bfa_trc(rport->fcs, rport->pid);
 
@@ -1582,11 +1593,11 @@ bfa_fcs_rport_gidpn_response(void *fcsar
 			     bfa_status_t req_status, u32 rsp_len,
 			     u32 resid_len, struct fchs_s *rsp_fchs)
 {
-	struct bfa_fcs_rport_s *rport = (struct bfa_fcs_rport_s *)cbarg;
-	struct bfa_fcs_rport_s *twin;
-	struct list_head *qe;
-	struct ct_hdr_s       	*cthdr;
+	struct bfa_fcs_rport_s *rport = (struct bfa_fcs_rport_s *) cbarg;
+	struct ct_hdr_s	*cthdr;
 	struct fcgs_gidpn_resp_s	*gidpn_rsp;
+	struct bfa_fcs_rport_s	*twin;
+	struct list_head	*qe;
 
 	bfa_trc(rport->fcs, rport->pwwn);
 
@@ -1594,25 +1605,21 @@ bfa_fcs_rport_gidpn_response(void *fcsar
 	cthdr->cmd_rsp_code = bfa_os_ntohs(cthdr->cmd_rsp_code);
 
 	if (cthdr->cmd_rsp_code == CT_RSP_ACCEPT) {
-		/*
-		 * Check if the pid is the same as before.
-		 */
+		/* Check if the pid is the same as before.*/
 		gidpn_rsp = (struct fcgs_gidpn_resp_s *) (cthdr + 1);
 
 		if (gidpn_rsp->dap == rport->pid) {
-			/*
-			 * Device is online
-			 */
+			/* Device is online  */
 			bfa_sm_send_event(rport, RPSM_EVENT_ACCEPTED);
 		} else {
 			/*
-			 * Device's PID has changed. We need to cleanup and
-			 * re-login. If there is another device with the the
-			 * newly discovered pid, send an scn notice so that its
-			 * new pid can be discovered.
+			 * Device's PID has changed. We need to cleanup
+			 * and re-login. If there is another device with
+			 * the the newly discovered pid, send an scn notice
+			 * so that its new pid can be discovered.
 			 */
 			list_for_each(qe, &rport->port->rport_q) {
-				twin = (struct bfa_fcs_rport_s *)qe;
+				twin = (struct bfa_fcs_rport_s *) qe;
 				if (twin == rport)
 					continue;
 				if (gidpn_rsp->dap == twin->pid) {
@@ -1662,9 +1669,9 @@ bfa_fcs_rport_send_logo(void *rport_cbar
 {
 	struct bfa_fcs_rport_s *rport = rport_cbarg;
 	struct bfa_fcs_port_s *port;
-	struct fchs_s          fchs;
+	struct fchs_s		fchs;
 	struct bfa_fcxp_s *fcxp;
-	u16        len;
+	u16	len;
 
 	bfa_trc(rport->fcs, rport->pid);
 
@@ -1683,8 +1690,8 @@ bfa_fcs_rport_send_logo(void *rport_cbar
 			    bfa_fcs_port_get_pwwn(port));
 
 	bfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,
-		      FC_CLASS_3, len, &fchs, NULL, rport, FC_MAX_PDUSZ,
-		      FC_ED_TOV);
+		      FC_CLASS_3, len, &fchs, NULL,
+		      rport, FC_MAX_PDUSZ, FC_ED_TOV);
 
 	rport->stats.logos++;
 	bfa_fcxp_discard(rport->fcxp);
@@ -1699,9 +1706,9 @@ bfa_fcs_rport_send_logo_acc(void *rport_
 {
 	struct bfa_fcs_rport_s *rport = rport_cbarg;
 	struct bfa_fcs_port_s *port;
-	struct fchs_s          fchs;
+	struct fchs_s		fchs;
 	struct bfa_fcxp_s *fcxp;
-	u16        len;
+	u16	len;
 
 	bfa_trc(rport->fcs, rport->pid);
 
@@ -1712,30 +1719,32 @@ bfa_fcs_rport_send_logo_acc(void *rport_
 		return;
 
 	rport->stats.logo_rcvd++;
-	len = fc_logo_acc_build(&fchs, bfa_fcxp_get_reqbuf(fcxp), rport->pid,
-				bfa_fcs_port_get_fcid(port), rport->reply_oxid);
+	len = fc_logo_acc_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),
+				rport->pid, bfa_fcs_port_get_fcid(port),
+				rport->reply_oxid);
 
 	bfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,
 		      FC_CLASS_3, len, &fchs, NULL, NULL, FC_MAX_PDUSZ, 0);
 }
 
 /**
+ *	brief
  *     This routine will be called by bfa_timer on timer timeouts.
  *
- * 	param[in] 	rport 			- pointer to bfa_fcs_port_ns_t.
- * 	param[out]	rport_status 	- pointer to return vport status in
+ *	param[in]	rport			- pointer to bfa_fcs_port_ns_t.
+ *	param[out]	rport_status	- pointer to return vport status in
  *
- * 	return
- * 		void
+ *	return
+ *		void
  *
-*  	Special Considerations:
+ *	Special Considerations:
  *
- * 	note
+ *	note
  */
 static void
 bfa_fcs_rport_timeout(void *arg)
 {
-	struct bfa_fcs_rport_s *rport = (struct bfa_fcs_rport_s *)arg;
+	struct bfa_fcs_rport_s *rport = (struct bfa_fcs_rport_s *) arg;
 
 	rport->stats.plogi_timeouts++;
 	bfa_sm_send_event(rport, RPSM_EVENT_TIMEOUT);
@@ -1746,7 +1755,7 @@ bfa_fcs_rport_process_prli(struct bfa_fc
 			struct fchs_s *rx_fchs, u16 len)
 {
 	struct bfa_fcxp_s *fcxp;
-	struct fchs_s          fchs;
+	struct fchs_s		fchs;
 	struct bfa_fcs_port_s *port = rport->port;
 	struct fc_prli_s      *prli;
 
@@ -1784,9 +1793,9 @@ bfa_fcs_rport_process_prli(struct bfa_fc
 	if (!fcxp)
 		return;
 
-	len = fc_prli_acc_build(&fchs, bfa_fcxp_get_reqbuf(fcxp), rx_fchs->s_id,
-				bfa_fcs_port_get_fcid(port), rx_fchs->ox_id,
-				port->port_cfg.roles);
+	len = fc_prli_acc_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),
+				rx_fchs->s_id, bfa_fcs_port_get_fcid(port),
+				rx_fchs->ox_id, port->port_cfg.roles);
 
 	bfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,
 		      FC_CLASS_3, len, &fchs, NULL, NULL, FC_MAX_PDUSZ, 0);
@@ -1797,7 +1806,7 @@ bfa_fcs_rport_process_rpsc(struct bfa_fc
 			struct fchs_s *rx_fchs, u16 len)
 {
 	struct bfa_fcxp_s *fcxp;
-	struct fchs_s          fchs;
+	struct fchs_s		fchs;
 	struct bfa_fcs_port_s *port = rport->port;
 	struct fc_rpsc_speed_info_s speeds;
 	struct bfa_pport_attr_s pport_attr;
@@ -1813,7 +1822,7 @@ bfa_fcs_rport_process_rpsc(struct bfa_fc
 	/*
 	 * get curent speed from pport attributes from BFA
 	 */
-	bfa_pport_get_attr(port->fcs->bfa, &pport_attr);
+	bfa_fcport_get_attr(port->fcs->bfa, &pport_attr);
 
 	speeds.port_op_speed = fc_bfa_speed_to_rpsc_operspeed(pport_attr.speed);
 
@@ -1821,9 +1830,9 @@ bfa_fcs_rport_process_rpsc(struct bfa_fc
 	if (!fcxp)
 		return;
 
-	len = fc_rpsc_acc_build(&fchs, bfa_fcxp_get_reqbuf(fcxp), rx_fchs->s_id,
-				bfa_fcs_port_get_fcid(port), rx_fchs->ox_id,
-				&speeds);
+	len = fc_rpsc_acc_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),
+				rx_fchs->s_id, bfa_fcs_port_get_fcid(port),
+				rx_fchs->ox_id, &speeds);
 
 	bfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,
 		      FC_CLASS_3, len, &fchs, NULL, NULL, FC_MAX_PDUSZ, 0);
@@ -1834,9 +1843,9 @@ bfa_fcs_rport_process_adisc(struct bfa_f
 			struct fchs_s *rx_fchs, u16 len)
 {
 	struct bfa_fcxp_s *fcxp;
-	struct fchs_s          fchs;
+	struct fchs_s		fchs;
 	struct bfa_fcs_port_s *port = rport->port;
-	struct fc_adisc_s      *adisc;
+	struct fc_adisc_s	*adisc;
 
 	bfa_trc(port->fcs, rx_fchs->s_id);
 	bfa_trc(port->fcs, rx_fchs->d_id);
@@ -1844,9 +1853,7 @@ bfa_fcs_rport_process_adisc(struct bfa_f
 	rport->stats.adisc_rcvd++;
 
 	if (BFA_FCS_VPORT_IS_TARGET_MODE(port)) {
-		/*
-		 * @todo : Target Mode handling
-		 */
+		/* @todo :  Target Mode	 handling */
 		bfa_trc(port->fcs, rx_fchs->d_id);
 		bfa_assert(0);
 		return;
@@ -1855,7 +1862,8 @@ bfa_fcs_rport_process_adisc(struct bfa_f
 	adisc = (struct fc_adisc_s *) (rx_fchs + 1);
 
 	/*
-	 * Accept if the itnim for this rport is online. Else reject the ADISC
+	 * Accept if the itnim for this rport is online.
+	 * Else reject the ADISC
 	 */
 	if (bfa_fcs_itnim_get_online_state(rport->itnim) == BFA_STATUS_OK) {
 
@@ -1921,9 +1929,9 @@ bfa_fcs_rport_fc4_resume(struct bfa_fcs_
 static struct bfa_fcs_rport_s *
 bfa_fcs_rport_alloc(struct bfa_fcs_port_s *port, wwn_t pwwn, u32 rpid)
 {
-	struct bfa_fcs_s *fcs = port->fcs;
+	struct bfa_fcs_s      *fcs = port->fcs;
 	struct bfa_fcs_rport_s *rport;
-	struct bfad_rport_s *rport_drv;
+	struct bfad_rport_s   *rport_drv;
 
 	/**
 	 * allocate rport
@@ -1983,9 +1991,7 @@ bfa_fcs_rport_alloc(struct bfa_fcs_port_
 
 	bfa_sm_set_state(rport, bfa_fcs_rport_sm_uninit);
 
-	/*
-	 * Initialize the Rport Features(RPF) Sub Module
-	 */
+	/* Initialize the Rport Features(RPF) Sub Module  */
 	if (!BFA_FCS_PID_IS_WKA(rport->pid))
 		bfa_fcs_rpf_init(rport);
 
@@ -2016,29 +2022,26 @@ bfa_fcs_rport_free(struct bfa_fcs_rport_
 
 static void
 bfa_fcs_rport_aen_post(struct bfa_fcs_rport_s *rport,
-		       enum bfa_rport_aen_event event,
-		       struct bfa_rport_aen_data_s *data)
+			enum bfa_rport_aen_event event,
+			struct bfa_rport_aen_data_s *data)
 {
-	union bfa_aen_data_u aen_data;
+	union bfa_aen_data_u  aen_data;
 	struct bfa_log_mod_s *logmod = rport->fcs->logm;
-	wwn_t           lpwwn = bfa_fcs_port_get_pwwn(rport->port);
-	wwn_t           rpwwn = rport->pwwn;
-	char            lpwwn_ptr[BFA_STRING_32];
-	char            rpwwn_ptr[BFA_STRING_32];
-	char           *prio_str[] = { "unknown", "high", "medium", "low" };
+	wwn_t		lpwwn = bfa_fcs_port_get_pwwn(rport->port);
+	wwn_t		rpwwn = rport->pwwn;
+	char		lpwwn_ptr[BFA_STRING_32];
+	char		rpwwn_ptr[BFA_STRING_32];
+	char		*prio_str[] = { "unknown", "high", "medium", "low" };
 
 	wwn2str(lpwwn_ptr, lpwwn);
 	wwn2str(rpwwn_ptr, rpwwn);
 
 	switch (event) {
 	case BFA_RPORT_AEN_ONLINE:
-		bfa_log(logmod, BFA_AEN_RPORT_ONLINE, rpwwn_ptr, lpwwn_ptr);
-		break;
 	case BFA_RPORT_AEN_OFFLINE:
-		bfa_log(logmod, BFA_AEN_RPORT_OFFLINE, rpwwn_ptr, lpwwn_ptr);
-		break;
 	case BFA_RPORT_AEN_DISCONNECT:
-		bfa_log(logmod, BFA_AEN_RPORT_DISCONNECT, rpwwn_ptr, lpwwn_ptr);
+		bfa_log(logmod, BFA_LOG_CREATE_ID(BFA_AEN_CAT_RPORT, event),
+					rpwwn_ptr, lpwwn_ptr);
 		break;
 	case BFA_RPORT_AEN_QOS_PRIO:
 		aen_data.rport.priv.qos = data->priv.qos;
@@ -2049,8 +2052,8 @@ bfa_fcs_rport_aen_post(struct bfa_fcs_rp
 	case BFA_RPORT_AEN_QOS_FLOWID:
 		aen_data.rport.priv.qos = data->priv.qos;
 		bfa_log(logmod, BFA_AEN_RPORT_QOS_FLOWID,
-			aen_data.rport.priv.qos.qos_flow_id, rpwwn_ptr,
-			lpwwn_ptr);
+			aen_data.rport.priv.qos.qos_flow_id,
+			rpwwn_ptr, lpwwn_ptr);
 		break;
 	default:
 		break;
@@ -2079,9 +2082,7 @@ bfa_fcs_rport_online_action(struct bfa_f
 	if (bfa_fcs_port_is_target(port))
 		bfa_fcs_tin_rport_online(rport->tin);
 
-	/*
-	 * Don't post events for well known addresses
-	 */
+	/* Don't post events for well known addresses */
 	if (!BFA_FCS_PID_IS_WKA(rport->pid))
 		bfa_fcs_rport_aen_post(rport, BFA_RPORT_AEN_ONLINE, NULL);
 }
@@ -2093,17 +2094,14 @@ bfa_fcs_rport_offline_action(struct bfa_
 
 	rport->stats.offlines++;
 
-	/*
-	 * Don't post events for well known addresses
-	 */
+	/* Don't post events for well known addresses */
 	if (!BFA_FCS_PID_IS_WKA(rport->pid)) {
-		if (bfa_fcs_port_is_online(rport->port) == BFA_TRUE) {
-			bfa_fcs_rport_aen_post(rport, BFA_RPORT_AEN_DISCONNECT,
-					       NULL);
-		} else {
-			bfa_fcs_rport_aen_post(rport, BFA_RPORT_AEN_OFFLINE,
-					       NULL);
-		}
+		if (bfa_fcs_port_is_online(rport->port) == BFA_TRUE)
+			bfa_fcs_rport_aen_post(rport,
+					BFA_RPORT_AEN_DISCONNECT, NULL);
+		else
+			bfa_fcs_rport_aen_post(rport,
+					BFA_RPORT_AEN_OFFLINE, NULL);
 	}
 
 	if (bfa_fcs_port_is_initiator(port)) {
@@ -2152,19 +2150,20 @@ bfa_fcs_rport_update(struct bfa_fcs_rpor
 	bfa_trc(port->fcs, port->fabric->bb_credit);
 	/**
 	 * Direct Attach P2P mode :
-	 * This is to handle a bug (233476) in IBM targets in Direct Attach
-	 * Mode. Basically, in FLOGI Accept the target would have erroneously
-	 * set the BB Credit to the value used in the FLOGI sent by the HBA.
+	 * This is to handle a bug (233476) in IBM targets in
+	 * Direct Attach Mode. Basically, in FLOGI Accept the target
+	 * would have erroneously set the BB Credit to the value used
+	 * in the FLOGI sent by the HBA.
 	 * It uses the correct value (its own BB credit) in PLOGI.
 	 */
-	if ((!bfa_fcs_fabric_is_switched(port->fabric))
-	    && (bfa_os_ntohs(plogi->csp.bbcred) < port->fabric->bb_credit)) {
+	if ((!bfa_fcs_fabric_is_switched(port->fabric))	&&
+	    (bfa_os_ntohs(plogi->csp.bbcred) < port->fabric->bb_credit)) {
 
 		bfa_trc(port->fcs, bfa_os_ntohs(plogi->csp.bbcred));
 		bfa_trc(port->fcs, port->fabric->bb_credit);
 
 		port->fabric->bb_credit = bfa_os_ntohs(plogi->csp.bbcred);
-		bfa_pport_set_tx_bbcredit(port->fcs->bfa,
+		bfa_fcport_set_tx_bbcredit(port->fcs->bfa,
 					  port->fabric->bb_credit);
 	}
 
@@ -2190,8 +2189,8 @@ bfa_fcs_rport_process_logo(struct bfa_fc
  */
 
 /**
- * 	Called by bport/vport to create a remote port instance for a discovered
- * 	remote device.
+ *	Called by bport/vport to create a remote port instance for a discovered
+ *	remote device.
  *
  * @param[in] port	- base port or vport
  * @param[in] rpid	- remote port ID
@@ -2233,7 +2232,6 @@ bfa_fcs_rport_create_by_wwn(struct bfa_f
 	bfa_sm_send_event(rport, RPSM_EVENT_ADDRESS_DISC);
 	return rport;
 }
-
 /**
  * Called by bport in private loop topology to indicate that a
  * rport has been discovered and plogi has been completed.
@@ -2282,9 +2280,9 @@ bfa_fcs_rport_plogi_create(struct bfa_fc
 static int
 wwn_compare(wwn_t wwn1, wwn_t wwn2)
 {
-	u8        *b1 = (u8 *) &wwn1;
-	u8        *b2 = (u8 *) &wwn2;
-	int             i;
+	u8	       *b1 = (u8 *) &wwn1;
+	u8	       *b2 = (u8 *) &wwn2;
+	int		i;
 
 	for (i = 0; i < sizeof(wwn_t); i++) {
 		if (b1[i] < b2[i])
@@ -2297,7 +2295,7 @@ wwn_compare(wwn_t wwn1, wwn_t wwn2)
 
 /**
  *   Called by bport/vport to handle PLOGI received from an existing
- * 	 remote port.
+ *	 remote port.
  */
 void
 bfa_fcs_rport_plogi(struct bfa_fcs_rport_s *rport, struct fchs_s *rx_fchs,
@@ -2320,8 +2318,8 @@ bfa_fcs_rport_plogi(struct bfa_fcs_rport
 	 * this Plogi should be accepted.
 	 */
 	if ((wwn_compare(rport->port->port_cfg.pwwn, rport->pwwn) == -1)
-	    && (bfa_fcs_fabric_is_switched(rport->port->fabric))
-	    && (!BFA_FCS_PID_IS_WKA(rport->pid))) {
+	    && (bfa_fcs_fabric_is_switched(rport->port->fabric)) &&
+	    (!BFA_FCS_PID_IS_WKA(rport->pid))) {
 		bfa_trc(rport->fcs, rport->pid);
 		return;
 	}
@@ -2333,10 +2331,10 @@ bfa_fcs_rport_plogi(struct bfa_fcs_rport
 /**
  * Called by bport/vport to delete a remote port instance.
  *
-* Rport delete is called under the following conditions:
- * 		- vport is deleted
- * 		- vf is deleted
- * 		- explicit request from OS to delete rport (vmware)
+ * Rport delete is called under the following conditions:
+ *		- vport is deleted
+ *		- vf is deleted
+ *		- explicit request from OS to delete rport (vmware)
  */
 void
 bfa_fcs_rport_delete(struct bfa_fcs_rport_s *rport)
@@ -2363,20 +2361,18 @@ bfa_fcs_rport_online(struct bfa_fcs_rpor
 {
 	bfa_sm_send_event(rport, RPSM_EVENT_PLOGI_SEND);
 }
-
 /**
  *   Called by bport/vport to notify SCN for the remote port
  */
 void
 bfa_fcs_rport_scn(struct bfa_fcs_rport_s *rport)
 {
-
 	rport->stats.rscns++;
 	bfa_sm_send_event(rport, RPSM_EVENT_SCN);
 }
 
 /**
- *   Called by  fcpim to notify that the ITN cleanup is done.
+ *   Called by	fcpim to notify that the ITN cleanup is done.
  */
 void
 bfa_fcs_rport_itnim_ack(struct bfa_fcs_rport_s *rport)
@@ -2385,75 +2381,70 @@ bfa_fcs_rport_itnim_ack(struct bfa_fcs_r
 }
 
 /**
- *   Called by fcptm to notify that the ITN cleanup is done.
- */
-void
-bfa_fcs_rport_tin_ack(struct bfa_fcs_rport_s *rport)
-{
-	bfa_sm_send_event(rport, RPSM_EVENT_FC4_OFFLINE);
-}
-
-/**
+ *	brief
  *     This routine BFA callback for bfa_rport_online() call.
  *
- * 	param[in] 	cb_arg	-  rport struct.
+ *	param[in]	cb_arg	-  rport struct.
  *
- * 	return
- * 		void
+ *	return
+ *		void
  *
-* 	Special Considerations:
+ *	Special Considerations:
  *
- * 	note
+ *	note
  */
 void
 bfa_cb_rport_online(void *cbarg)
 {
 
-	struct bfa_fcs_rport_s *rport = (struct bfa_fcs_rport_s *)cbarg;
+	struct bfa_fcs_rport_s *rport = (struct bfa_fcs_rport_s *) cbarg;
 
 	bfa_trc(rport->fcs, rport->pwwn);
 	bfa_sm_send_event(rport, RPSM_EVENT_HCB_ONLINE);
 }
 
 /**
+ *	brief
  *     This routine BFA callback for bfa_rport_offline() call.
  *
- * 	param[in] 	rport 	-
+ *	param[in]	rport	-
  *
- * 	return
- * 		void
+ *	return
+ *		void
  *
- * 	Special Considerations:
+ *	Special Considerations:
  *
- * 	note
+ *	note
  */
 void
 bfa_cb_rport_offline(void *cbarg)
 {
-	struct bfa_fcs_rport_s *rport = (struct bfa_fcs_rport_s *)cbarg;
+	struct bfa_fcs_rport_s *rport = (struct bfa_fcs_rport_s *) cbarg;
 
 	bfa_trc(rport->fcs, rport->pwwn);
 	bfa_sm_send_event(rport, RPSM_EVENT_HCB_OFFLINE);
 }
 
 /**
- * This routine is a static BFA callback when there is a QoS flow_id
- * change notification
+ *	brief
+ *	This routine is a static BFA callback when there is a QoS flow_id
+ *	change notification
  *
- * @param[in] 	rport 	-
+ *	param[in]	rport	-
  *
- * @return  	void
+ *	return
+ *		void
  *
- * Special Considerations:
+ *	Special Considerations:
  *
- * @note
+ *	note
  */
 void
 bfa_cb_rport_qos_scn_flowid(void *cbarg,
-			    struct bfa_rport_qos_attr_s old_qos_attr,
-			    struct bfa_rport_qos_attr_s new_qos_attr)
+			struct bfa_rport_qos_attr_s old_qos_attr,
+			struct bfa_rport_qos_attr_s new_qos_attr)
 {
-	struct bfa_fcs_rport_s *rport = (struct bfa_fcs_rport_s *)cbarg;
+	struct bfa_fcs_rport_s *rport = (struct bfa_fcs_rport_s *) cbarg;
 	struct bfa_rport_aen_data_s aen_data;
 
 	bfa_trc(rport->fcs, rport->pwwn);
@@ -2462,22 +2453,24 @@ bfa_cb_rport_qos_scn_flowid(void *cbarg,
 }
 
 /**
- * This routine is a static BFA callback when there is a QoS priority
- * change notification
+ *	brief
+ *	This routine is a static BFA callback when there is a QoS priority
+ *	change notification
  *
- * @param[in] 	rport 	-
+ *	param[in]	rport	-
  *
- * @return 	void
+ *	return
+ *		void
  *
- * Special Considerations:
+ *	Special Considerations:
  *
- * @note
+ *	note
  */
 void
 bfa_cb_rport_qos_scn_prio(void *cbarg, struct bfa_rport_qos_attr_s old_qos_attr,
-			  struct bfa_rport_qos_attr_s new_qos_attr)
+			   struct bfa_rport_qos_attr_s new_qos_attr)
 {
-	struct bfa_fcs_rport_s *rport = (struct bfa_fcs_rport_s *)cbarg;
+	struct bfa_fcs_rport_s *rport = (struct bfa_fcs_rport_s *) cbarg;
 	struct bfa_rport_aen_data_s aen_data;
 
 	bfa_trc(rport->fcs, rport->pwwn);
@@ -2486,7 +2479,7 @@ bfa_cb_rport_qos_scn_prio(void *cbarg, s
 }
 
 /**
- * 		Called to process any unsolicted frames from this remote port
+ *		Called to process any unsolicted frames from this remote port
  */
 void
 bfa_fcs_rport_logo_imp(struct bfa_fcs_rport_s *rport)
@@ -2495,11 +2488,11 @@ bfa_fcs_rport_logo_imp(struct bfa_fcs_rp
 }
 
 /**
- * 		Called to process any unsolicted frames from this remote port
+ *		Called to process any unsolicted frames from this remote port
  */
 void
 bfa_fcs_rport_uf_recv(struct bfa_fcs_rport_s *rport, struct fchs_s *fchs,
-			u16 len)
+				u16 len)
 {
 	struct bfa_fcs_port_s *port = rport->port;
 	struct fc_els_cmd_s   *els_cmd;
@@ -2556,9 +2549,9 @@ bfa_fcs_rport_send_ls_rjt(struct bfa_fcs
 			  u8 reason_code, u8 reason_code_expl)
 {
 	struct bfa_fcs_port_s *port = rport->port;
-	struct fchs_s          fchs;
+	struct fchs_s		fchs;
 	struct bfa_fcxp_s *fcxp;
-	int             len;
+	int		len;
 
 	bfa_trc(rport->fcs, rx_fchs->s_id);
 
@@ -2566,29 +2559,13 @@ bfa_fcs_rport_send_ls_rjt(struct bfa_fcs
 	if (!fcxp)
 		return;
 
-	len = fc_ls_rjt_build(&fchs, bfa_fcxp_get_reqbuf(fcxp), rx_fchs->s_id,
-			      bfa_fcs_port_get_fcid(port), rx_fchs->ox_id,
-			      reason_code, reason_code_expl);
-
-	bfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,
-		      FC_CLASS_3, len, &fchs, NULL, NULL, FC_MAX_PDUSZ, 0);
-}
-
-/**
- *   Module initialization
- */
-void
-bfa_fcs_rport_modinit(struct bfa_fcs_s *fcs)
-{
-}
-
-/**
- *   Module cleanup
- */
-void
-bfa_fcs_rport_modexit(struct bfa_fcs_s *fcs)
-{
-	bfa_fcs_modexit_comp(fcs);
+	len = fc_ls_rjt_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),
+			      rx_fchs->s_id, bfa_fcs_port_get_fcid(port),
+			      rx_fchs->ox_id, reason_code, reason_code_expl);
+
+	bfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag,
+		      BFA_FALSE, FC_CLASS_3, len, &fchs, NULL, NULL,
+		      FC_MAX_PDUSZ, 0);
 }
 
 /**
@@ -2601,18 +2578,17 @@ bfa_fcs_rport_get_state(struct bfa_fcs_r
 }
 
 /**
- * 		 Called by the Driver to set rport delete/ageout timeout
+ *	brief
+ *		 Called by the Driver to set rport delete/ageout timeout
  *
- * 	param[in]		rport timeout value in seconds.
+ *	param[in]		rport timeout value in seconds.
  *
- * 	return None
+ *	return None
  */
 void
 bfa_fcs_rport_set_del_timeout(u8 rport_tmo)
 {
-	/*
-	 * convert to Millisecs
-	 */
+	/* convert to Millisecs */
 	if (rport_tmo > 0)
 		bfa_fcs_rport_del_timeout = rport_tmo * 1000;
 }
diff -uprN a/drivers/scsi/bfa/rport_api.c b/drivers/scsi/bfa/rport_api.c
--- a/drivers/scsi/bfa/rport_api.c	2009-12-18 18:16:22.312720000 -0800
+++ b/drivers/scsi/bfa/rport_api.c	2009-11-25 18:21:07.000000000 -0800
@@ -37,8 +37,7 @@ BFA_TRC_FILE(FCS, RPORT_API);
  */
 bfa_status_t
 bfa_fcs_rport_add(struct bfa_fcs_port_s *port, wwn_t *pwwn,
-			struct bfa_fcs_rport_s *rport,
-			struct bfad_rport_s *rport_drv)
+		struct bfa_fcs_rport_s *rport, struct bfad_rport_s *rport_drv)
 {
 	bfa_trc(port->fcs, *pwwn);
 
@@ -102,11 +101,12 @@ bfa_fcs_rport_get_attr(struct bfa_fcs_rp
 	rport_attr->qos_attr = qos_attr;
 
 	rport_attr->trl_enforced = BFA_FALSE;
-	if (bfa_pport_is_ratelim(port->fcs->bfa)) {
+	if (bfa_fcport_is_ratelim(port->fcs->bfa)) {
 		if ((rport->rpf.rpsc_speed == BFA_PPORT_SPEED_UNKNOWN) ||
 			(rport->rpf.rpsc_speed <
-			bfa_fcs_port_get_rport_max_speed(port)))
+				bfa_fcs_port_get_rport_max_speed(port))) {
 			rport_attr->trl_enforced = BFA_TRUE;
+		}
 	}
 
 	/*
diff -uprN a/drivers/scsi/bfa/rport_ftrs.c b/drivers/scsi/bfa/rport_ftrs.c
--- a/drivers/scsi/bfa/rport_ftrs.c	2009-12-18 18:16:22.310723000 -0800
+++ b/drivers/scsi/bfa/rport_ftrs.c	2009-11-25 18:21:07.000000000 -0800
@@ -34,12 +34,12 @@ BFA_TRC_FILE(FCS, RPORT_FTRS);
 #define BFA_FCS_RPF_RETRY_TIMEOUT  (1000) /* 1 sec (In millisecs) */
 
 static void     bfa_fcs_rpf_send_rpsc2(void *rport_cbarg,
-			struct bfa_fcxp_s *fcxp_alloced);
+					struct bfa_fcxp_s *fcxp_alloced);
 static void     bfa_fcs_rpf_rpsc2_response(void *fcsarg,
-			struct bfa_fcxp_s *fcxp, void *cbarg,
-			bfa_status_t req_status, u32 rsp_len,
-			u32 resid_len,
-			struct fchs_s *rsp_fchs);
+					struct bfa_fcxp_s *fcxp,
+					void *cbarg, bfa_status_t req_status,
+					u32 rsp_len, u32 resid_len,
+					struct fchs_s *rsp_fchs);
 static void     bfa_fcs_rpf_timeout(void *arg);
 
 /**
@@ -56,7 +56,7 @@ enum rpf_event {
 	RPFSM_EVENT_RPSC_ERROR     = 7,
 };
 
-static void	bfa_fcs_rpf_sm_uninit(struct bfa_fcs_rpf_s *rpf,
+static void		bfa_fcs_rpf_sm_uninit(struct bfa_fcs_rpf_s *rpf,
 					enum rpf_event event);
 static void     bfa_fcs_rpf_sm_rpsc_sending(struct bfa_fcs_rpf_s *rpf,
 					       enum rpf_event event);
@@ -79,7 +79,7 @@ bfa_fcs_rpf_sm_uninit(struct bfa_fcs_rpf
 	bfa_trc(rport->fcs, event);
 
 	switch (event) {
-	case RPFSM_EVENT_RPORT_ONLINE :
+	case RPFSM_EVENT_RPORT_ONLINE:
 		if (!BFA_FCS_PID_IS_WKA(rport->pid)) {
 			bfa_sm_set_state(rpf, bfa_fcs_rpf_sm_rpsc_sending);
 			rpf->rpsc_retries = 0;
@@ -87,11 +87,11 @@ bfa_fcs_rpf_sm_uninit(struct bfa_fcs_rpf
 			break;
 		};
 
-	case RPFSM_EVENT_RPORT_OFFLINE :
+	case RPFSM_EVENT_RPORT_OFFLINE:
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(rport->fcs, event);
 	}
 }
 
@@ -107,14 +107,14 @@ bfa_fcs_rpf_sm_rpsc_sending(struct bfa_f
 		bfa_sm_set_state(rpf, bfa_fcs_rpf_sm_rpsc);
 		break;
 
-	case RPFSM_EVENT_RPORT_OFFLINE :
+	case RPFSM_EVENT_RPORT_OFFLINE:
 		bfa_sm_set_state(rpf, bfa_fcs_rpf_sm_offline);
 		bfa_fcxp_walloc_cancel(rport->fcs->bfa, &rpf->fcxp_wqe);
 		rpf->rpsc_retries = 0;
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(rport->fcs, event);
 	}
 }
 
@@ -130,11 +130,11 @@ bfa_fcs_rpf_sm_rpsc(struct bfa_fcs_rpf_s
 	case RPFSM_EVENT_RPSC_COMP:
 		bfa_sm_set_state(rpf, bfa_fcs_rpf_sm_online);
 		/* Update speed info in f/w via BFA */
-		if (rpf->rpsc_speed != BFA_PPORT_SPEED_UNKNOWN) {
+		if (rpf->rpsc_speed != BFA_PPORT_SPEED_UNKNOWN)
 			bfa_rport_speed(rport->bfa_rport, rpf->rpsc_speed);
-		} else if (rpf->assigned_speed != BFA_PPORT_SPEED_UNKNOWN) {
+		else if (rpf->assigned_speed != BFA_PPORT_SPEED_UNKNOWN)
 			bfa_rport_speed(rport->bfa_rport, rpf->assigned_speed);
-		}
+
 		break;
 
 	case RPFSM_EVENT_RPSC_FAIL:
@@ -154,14 +154,14 @@ bfa_fcs_rpf_sm_rpsc(struct bfa_fcs_rpf_s
 		}
 		break;
 
-	case RPFSM_EVENT_RPORT_OFFLINE :
+	case RPFSM_EVENT_RPORT_OFFLINE:
 		bfa_sm_set_state(rpf, bfa_fcs_rpf_sm_offline);
 		bfa_fcxp_discard(rpf->fcxp);
 		rpf->rpsc_retries = 0;
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(rport->fcs, event);
 	}
 }
 
@@ -174,20 +174,20 @@ bfa_fcs_rpf_sm_rpsc_retry(struct bfa_fcs
 	bfa_trc(rport->fcs, event);
 
 	switch (event) {
-	case RPFSM_EVENT_TIMEOUT :
+	case RPFSM_EVENT_TIMEOUT:
 		/* re-send the RPSC */
 		bfa_sm_set_state(rpf, bfa_fcs_rpf_sm_rpsc_sending);
 		bfa_fcs_rpf_send_rpsc2(rpf, NULL);
 		break;
 
-	case RPFSM_EVENT_RPORT_OFFLINE :
+	case RPFSM_EVENT_RPORT_OFFLINE:
 		bfa_timer_stop(&rpf->timer);
 		bfa_sm_set_state(rpf, bfa_fcs_rpf_sm_offline);
 		rpf->rpsc_retries = 0;
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(rport->fcs, event);
 	}
 }
 
@@ -201,13 +201,13 @@ bfa_fcs_rpf_sm_online(struct bfa_fcs_rpf
 	bfa_trc(rport->fcs, event);
 
 	switch (event) {
-	case RPFSM_EVENT_RPORT_OFFLINE :
+	case RPFSM_EVENT_RPORT_OFFLINE:
 		bfa_sm_set_state(rpf, bfa_fcs_rpf_sm_offline);
 		rpf->rpsc_retries = 0;
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(rport->fcs, event);
 	}
 }
 
@@ -221,16 +221,16 @@ bfa_fcs_rpf_sm_offline(struct bfa_fcs_rp
 	bfa_trc(rport->fcs, event);
 
 	switch (event) {
-	case RPFSM_EVENT_RPORT_ONLINE :
+	case RPFSM_EVENT_RPORT_ONLINE:
 		bfa_sm_set_state(rpf, bfa_fcs_rpf_sm_rpsc_sending);
 		bfa_fcs_rpf_send_rpsc2(rpf, NULL);
 		break;
 
-	case RPFSM_EVENT_RPORT_OFFLINE :
+	case RPFSM_EVENT_RPORT_OFFLINE:
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(rport->fcs, event);
 	}
 }
 /**
@@ -366,10 +366,9 @@ bfa_fcs_rpf_rpsc2_response(void *fcsarg,
 		bfa_trc(rport->fcs, ls_rjt->reason_code);
 		bfa_trc(rport->fcs, ls_rjt->reason_code_expl);
 		rport->stats.rpsc_rejects++;
-		if (ls_rjt->reason_code == FC_LS_RJT_RSN_CMD_NOT_SUPP) {
+		if (ls_rjt->reason_code == FC_LS_RJT_RSN_CMD_NOT_SUPP)
 			bfa_sm_send_event(rpf, RPFSM_EVENT_RPSC_FAIL);
-		} else {
+		else
 			bfa_sm_send_event(rpf, RPFSM_EVENT_RPSC_ERROR);
-		}
 	}
 }
diff -uprN a/drivers/scsi/bfa/scn.c b/drivers/scsi/bfa/scn.c
--- a/drivers/scsi/bfa/scn.c	2009-12-18 18:16:22.308727000 -0800
+++ b/drivers/scsi/bfa/scn.c	2009-11-25 18:21:07.000000000 -0800
@@ -78,7 +78,7 @@ static void     bfa_fcs_port_scn_sm_onli
  */
 static void
 bfa_fcs_port_scn_sm_offline(struct bfa_fcs_port_scn_s *scn,
-			    enum port_scn_event event)
+				enum port_scn_event event)
 {
 	switch (event) {
 	case SCNSM_EVENT_PORT_ONLINE:
@@ -90,7 +90,7 @@ bfa_fcs_port_scn_sm_offline(struct bfa_f
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(scn->port->fcs, event);
 	}
 }
 
@@ -109,13 +109,13 @@ bfa_fcs_port_scn_sm_sending_scr(struct b
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(scn->port->fcs, event);
 	}
 }
 
 static void
 bfa_fcs_port_scn_sm_scr(struct bfa_fcs_port_scn_s *scn,
-			enum port_scn_event event)
+				enum port_scn_event event)
 {
 	struct bfa_fcs_port_s *port = scn->port;
 
@@ -127,8 +127,8 @@ bfa_fcs_port_scn_sm_scr(struct bfa_fcs_p
 	case SCNSM_EVENT_RSP_ERROR:
 		bfa_sm_set_state(scn, bfa_fcs_port_scn_sm_scr_retry);
 		bfa_timer_start(port->fcs->bfa, &scn->timer,
-				bfa_fcs_port_scn_timeout, scn,
-				BFA_FCS_RETRY_TIMEOUT);
+				    bfa_fcs_port_scn_timeout, scn,
+				    BFA_FCS_RETRY_TIMEOUT);
 		break;
 
 	case SCNSM_EVENT_PORT_OFFLINE:
@@ -137,13 +137,13 @@ bfa_fcs_port_scn_sm_scr(struct bfa_fcs_p
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(port->fcs, event);
 	}
 }
 
 static void
 bfa_fcs_port_scn_sm_scr_retry(struct bfa_fcs_port_scn_s *scn,
-			      enum port_scn_event event)
+				enum port_scn_event event)
 {
 	switch (event) {
 	case SCNSM_EVENT_TIMEOUT:
@@ -157,13 +157,13 @@ bfa_fcs_port_scn_sm_scr_retry(struct bfa
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(scn->port->fcs, event);
 	}
 }
 
 static void
 bfa_fcs_port_scn_sm_online(struct bfa_fcs_port_scn_s *scn,
-			   enum port_scn_event event)
+				enum port_scn_event event)
 {
 	switch (event) {
 	case SCNSM_EVENT_PORT_OFFLINE:
@@ -171,7 +171,7 @@ bfa_fcs_port_scn_sm_online(struct bfa_fc
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(scn->port->fcs, event);
 	}
 }
 
@@ -199,37 +199,34 @@ bfa_fcs_port_scn_send_scr(void *scn_cbar
 	fcxp = fcxp_alloced ? fcxp_alloced : bfa_fcs_fcxp_alloc(port->fcs);
 	if (!fcxp) {
 		bfa_fcxp_alloc_wait(port->fcs->bfa, &scn->fcxp_wqe,
-				    bfa_fcs_port_scn_send_scr, scn);
+					bfa_fcs_port_scn_send_scr, scn);
 		return;
 	}
 	scn->fcxp = fcxp;
 
-	/*
-	 * Handle VU registrations for Base port only
-	 */
+	/* Handle VU registrations for Base port only */
 	if ((!port->vport) && bfa_ioc_get_fcmode(&port->fcs->bfa->ioc)) {
 		len = fc_scr_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),
-				   bfa_lps_is_brcd_fabric(port->fabric->lps),
-				   port->pid, 0);
+				bfa_lps_is_brcd_fabric(port->fabric->lps),
+				port->pid, 0);
 	} else {
-		len = fc_scr_build(&fchs, bfa_fcxp_get_reqbuf(fcxp), BFA_FALSE,
-				   port->pid, 0);
+		len = fc_scr_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),
+				BFA_FALSE, port->pid, 0);
 	}
-
 	bfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,
-		      FC_CLASS_3, len, &fchs, bfa_fcs_port_scn_scr_response,
-		      (void *)scn, FC_MAX_PDUSZ, FC_RA_TOV);
+			  FC_CLASS_3, len, &fchs, bfa_fcs_port_scn_scr_response,
+			  (void *)scn, FC_MAX_PDUSZ, FC_RA_TOV);
 
 	bfa_sm_send_event(scn, SCNSM_EVENT_SCR_SENT);
 }
 
 static void
 bfa_fcs_port_scn_scr_response(void *fcsarg, struct bfa_fcxp_s *fcxp,
-			      void *cbarg, bfa_status_t req_status,
-			      u32 rsp_len, u32 resid_len,
-			      struct fchs_s *rsp_fchs)
+				void *cbarg, bfa_status_t req_status,
+				u32 rsp_len, u32 resid_len,
+				struct fchs_s *rsp_fchs)
 {
-	struct bfa_fcs_port_scn_s *scn = (struct bfa_fcs_port_scn_s *)cbarg;
+	struct bfa_fcs_port_scn_s *scn = (struct bfa_fcs_port_scn_s *) cbarg;
 	struct bfa_fcs_port_s *port = scn->port;
 	struct fc_els_cmd_s   *els_cmd;
 	struct fc_ls_rjt_s    *ls_rjt;
@@ -273,7 +270,7 @@ bfa_fcs_port_scn_scr_response(void *fcsa
  */
 static void
 bfa_fcs_port_scn_send_ls_acc(struct bfa_fcs_port_s *port,
-			struct fchs_s *rx_fchs)
+				struct fchs_s *rx_fchs)
 {
 	struct fchs_s          fchs;
 	struct bfa_fcxp_s *fcxp;
@@ -286,12 +283,13 @@ bfa_fcs_port_scn_send_ls_acc(struct bfa_
 	if (!fcxp)
 		return;
 
-	len = fc_ls_acc_build(&fchs, bfa_fcxp_get_reqbuf(fcxp), rx_fchs->s_id,
-			      bfa_fcs_port_get_fcid(port), rx_fchs->ox_id);
+	len = fc_ls_acc_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),
+			      rx_fchs->s_id, bfa_fcs_port_get_fcid(port),
+			      rx_fchs->ox_id);
 
 	bfa_fcxp_send(fcxp, bfa_rport, port->fabric->vf_id, port->lp_tag,
-		      BFA_FALSE, FC_CLASS_3, len, &fchs, NULL, NULL,
-		      FC_MAX_PDUSZ, 0);
+			  BFA_FALSE, FC_CLASS_3, len, &fchs, NULL, NULL,
+			  FC_MAX_PDUSZ, 0);
 }
 
 /**
@@ -303,14 +301,14 @@ bfa_fcs_port_scn_send_ls_acc(struct bfa_
  * 	return
  * 		void
  *
-*  	Special Considerations:
+ * 	Special Considerations:
  *
  * 	note
  */
 static void
 bfa_fcs_port_scn_timeout(void *arg)
 {
-	struct bfa_fcs_port_scn_s *scn = (struct bfa_fcs_port_scn_s *)arg;
+	struct bfa_fcs_port_scn_s *scn = (struct bfa_fcs_port_scn_s *) arg;
 
 	bfa_sm_send_event(scn, SCNSM_EVENT_TIMEOUT);
 }
@@ -381,17 +379,18 @@ bfa_fcs_port_scn_portid_rscn(struct bfa_
 #define __fc_pid_match(__c0, __c1, __fmt)		\
 	(((__fmt) == FC_RSCN_FORMAT_FABRIC) ||		\
 	 (((__fmt) == FC_RSCN_FORMAT_DOMAIN) &&		\
-	  ((__c0)[0] == (__c1)[0])) ||			\
+	  ((__c0)[0] == (__c1)[0])) ||				\
 	 (((__fmt) == FC_RSCN_FORMAT_AREA) &&		\
-	  ((__c0)[0] == (__c1)[0]) &&			\
+	  ((__c0)[0] == (__c1)[0]) &&				\
 	  ((__c0)[1] == (__c1)[1])))
 
 static void
 bfa_fcs_port_scn_multiport_rscn(struct bfa_fcs_port_s *port,
-			enum fc_rscn_format format, u32 rscn_pid)
+				enum fc_rscn_format format,
+				u32 rscn_pid)
 {
 	struct bfa_fcs_rport_s *rport;
-	struct list_head *qe, *qe_next;
+	struct list_head        *qe, *qe_next;
 	u8        *c0, *c1;
 
 	bfa_trc(port->fcs, format);
@@ -400,13 +399,14 @@ bfa_fcs_port_scn_multiport_rscn(struct b
 	c0 = (u8 *) &rscn_pid;
 
 	list_for_each_safe(qe, qe_next, &port->rport_q) {
-		rport = (struct bfa_fcs_rport_s *)qe;
+		rport = (struct bfa_fcs_rport_s *) qe;
 		c1 = (u8 *) &rport->pid;
 		if (__fc_pid_match(c0, c1, format))
 			bfa_fcs_rport_scn(rport);
 	}
 }
 
+
 void
 bfa_fcs_port_scn_process_rscn(struct bfa_fcs_port_s *port, struct fchs_s *fchs,
 			      u32 len)
@@ -438,24 +438,22 @@ bfa_fcs_port_scn_process_rscn(struct bfa
 			if (rscn->event[i].qualifier == FC_QOS_RSCN_EVENT) {
 				/*
 				 * Ignore this event. f/w would have processed
-				 * it
+				 * it.
 				 */
 				bfa_trc(port->fcs, rscn_pid);
 			} else {
 				port->stats.num_portid_rscn++;
 				bfa_fcs_port_scn_portid_rscn(port, rscn_pid);
 			}
-			break;
+		break;
 
 		case FC_RSCN_FORMAT_FABRIC:
 			if (rscn->event[i].qualifier ==
-			    FC_FABRIC_NAME_RSCN_EVENT) {
+					FC_FABRIC_NAME_RSCN_EVENT) {
 				bfa_fcs_port_ms_fabric_rscn(port);
 				break;
 			}
-			/*
-			 * !!!!!!!!! Fall Through !!!!!!!!!!!!!
-			 */
+			/* !!!!!!!!! Fall Through !!!!!!!!!!!!! */
 
 		case FC_RSCN_FORMAT_AREA:
 		case FC_RSCN_FORMAT_DOMAIN:
diff -uprN a/drivers/scsi/bfa/vfapi.c b/drivers/scsi/bfa/vfapi.c
--- a/drivers/scsi/bfa/vfapi.c	2009-12-18 18:16:22.306731000 -0800
+++ b/drivers/scsi/bfa/vfapi.c	2009-11-25 18:21:07.000000000 -0800
@@ -189,7 +189,7 @@ bfa_fcs_vf_lookup(struct bfa_fcs_s *fcs,
 {
 	bfa_trc(fcs, vf_id);
 	if (vf_id == FC_VF_ID_NULL)
-		return (&fcs->fabric);
+		return &fcs->fabric;
 
 	/**
 	 * @todo vf support
diff -uprN a/drivers/scsi/bfa/vport.c b/drivers/scsi/bfa/vport.c
--- a/drivers/scsi/bfa/vport.c	2009-12-18 18:16:22.304729000 -0800
+++ b/drivers/scsi/bfa/vport.c	2009-11-25 18:21:07.000000000 -0800
@@ -31,13 +31,13 @@
 
 BFA_TRC_FILE(FCS, VPORT);
 
-#define __vport_fcs(__vp)       (__vp)->lport.fcs
-#define __vport_pwwn(__vp)      (__vp)->lport.port_cfg.pwwn
-#define __vport_nwwn(__vp)      (__vp)->lport.port_cfg.nwwn
-#define __vport_bfa(__vp)       (__vp)->lport.fcs->bfa
-#define __vport_fcid(__vp)      (__vp)->lport.pid
-#define __vport_fabric(__vp)    (__vp)->lport.fabric
-#define __vport_vfid(__vp)      (__vp)->lport.fabric->vf_id
+#define __vport_fcs(__vp)       ((__vp)->lport.fcs)
+#define __vport_pwwn(__vp)      ((__vp)->lport.port_cfg.pwwn)
+#define __vport_nwwn(__vp)      ((__vp)->lport.port_cfg.nwwn)
+#define __vport_bfa(__vp)       ((__vp)->lport.fcs->bfa)
+#define __vport_fcid(__vp)      ((__vp)->lport.pid)
+#define __vport_fabric(__vp)    ((__vp)->lport.fabric)
+#define __vport_vfid(__vp)      ((__vp)->lport.fabric->vf_id)
 
 #define BFA_FCS_VPORT_MAX_RETRIES  5
 /*
@@ -67,7 +67,7 @@ enum bfa_fcs_vport_event {
 	BFA_FCS_VPORT_SM_RSP_ERROR = 9,	/*  error/bad response */
 	BFA_FCS_VPORT_SM_TIMEOUT = 10,	/*  delay timer event */
 	BFA_FCS_VPORT_SM_DELCOMP = 11,	/*  lport delete completion */
-	BFA_FCS_VPORT_SM_RSP_DUP_WWN = 12,	/*  Dup wnn error */
+	BFA_FCS_VPORT_SM_RSP_DUP_WWN = 12,	/*  Dup wnn error*/
 	BFA_FCS_VPORT_SM_RSP_FAILED = 13,	/*  non-retryable failure */
 };
 
@@ -90,9 +90,9 @@ static void     bfa_fcs_vport_sm_cleanup
 static void     bfa_fcs_vport_sm_logo(struct bfa_fcs_vport_s *vport,
 				      enum bfa_fcs_vport_event event);
 static void     bfa_fcs_vport_sm_error(struct bfa_fcs_vport_s *vport,
-				       enum bfa_fcs_vport_event event);
+				      enum bfa_fcs_vport_event event);
 
-static struct bfa_sm_table_s vport_sm_table[] = {
+static struct bfa_sm_table_s  vport_sm_table[] = {
 	{BFA_SM(bfa_fcs_vport_sm_uninit), BFA_FCS_VPORT_UNINIT},
 	{BFA_SM(bfa_fcs_vport_sm_created), BFA_FCS_VPORT_CREATED},
 	{BFA_SM(bfa_fcs_vport_sm_offline), BFA_FCS_VPORT_OFFLINE},
@@ -110,7 +110,7 @@ static struct bfa_sm_table_s vport_sm_ta
  */
 static void
 bfa_fcs_vport_sm_uninit(struct bfa_fcs_vport_s *vport,
-			enum bfa_fcs_vport_event event)
+				enum bfa_fcs_vport_event event)
 {
 	bfa_trc(__vport_fcs(vport), __vport_pwwn(vport));
 	bfa_trc(__vport_fcs(vport), event);
@@ -122,7 +122,7 @@ bfa_fcs_vport_sm_uninit(struct bfa_fcs_v
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(__vport_fcs(vport), event);
 	}
 }
 
@@ -131,7 +131,7 @@ bfa_fcs_vport_sm_uninit(struct bfa_fcs_v
  */
 static void
 bfa_fcs_vport_sm_created(struct bfa_fcs_vport_s *vport,
-			 enum bfa_fcs_vport_event event)
+				enum bfa_fcs_vport_event event)
 {
 	bfa_trc(__vport_fcs(vport), __vport_pwwn(vport));
 	bfa_trc(__vport_fcs(vport), event);
@@ -165,7 +165,7 @@ bfa_fcs_vport_sm_created(struct bfa_fcs_
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(__vport_fcs(vport), event);
 	}
 }
 
@@ -174,7 +174,7 @@ bfa_fcs_vport_sm_created(struct bfa_fcs_
  */
 static void
 bfa_fcs_vport_sm_offline(struct bfa_fcs_vport_s *vport,
-			 enum bfa_fcs_vport_event event)
+				enum bfa_fcs_vport_event event)
 {
 	bfa_trc(__vport_fcs(vport), __vport_pwwn(vport));
 	bfa_trc(__vport_fcs(vport), event);
@@ -202,16 +202,17 @@ bfa_fcs_vport_sm_offline(struct bfa_fcs_
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(__vport_fcs(vport), event);
 	}
 }
 
+
 /**
  * FDISC is sent and awaiting reply from fabric.
  */
 static void
 bfa_fcs_vport_sm_fdisc(struct bfa_fcs_vport_s *vport,
-		       enum bfa_fcs_vport_event event)
+				enum bfa_fcs_vport_event event)
 {
 	bfa_trc(__vport_fcs(vport), __vport_pwwn(vport));
 	bfa_trc(__vport_fcs(vport), event);
@@ -236,8 +237,8 @@ bfa_fcs_vport_sm_fdisc(struct bfa_fcs_vp
 	case BFA_FCS_VPORT_SM_RSP_ERROR:
 		bfa_sm_set_state(vport, bfa_fcs_vport_sm_fdisc_retry);
 		bfa_timer_start(__vport_bfa(vport), &vport->timer,
-				bfa_fcs_vport_timeout, vport,
-				BFA_FCS_RETRY_TIMEOUT);
+				    bfa_fcs_vport_timeout, vport,
+				    BFA_FCS_RETRY_TIMEOUT);
 		break;
 
 	case BFA_FCS_VPORT_SM_RSP_FAILED:
@@ -249,7 +250,7 @@ bfa_fcs_vport_sm_fdisc(struct bfa_fcs_vp
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(__vport_fcs(vport), event);
 	}
 }
 
@@ -283,7 +284,7 @@ bfa_fcs_vport_sm_fdisc_retry(struct bfa_
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(__vport_fcs(vport), event);
 	}
 }
 
@@ -292,7 +293,7 @@ bfa_fcs_vport_sm_fdisc_retry(struct bfa_
  */
 static void
 bfa_fcs_vport_sm_online(struct bfa_fcs_vport_s *vport,
-			enum bfa_fcs_vport_event event)
+				enum bfa_fcs_vport_event event)
 {
 	bfa_trc(__vport_fcs(vport), __vport_pwwn(vport));
 	bfa_trc(__vport_fcs(vport), event);
@@ -310,7 +311,7 @@ bfa_fcs_vport_sm_online(struct bfa_fcs_v
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(__vport_fcs(vport), event);
 	}
 }
 
@@ -320,7 +321,7 @@ bfa_fcs_vport_sm_online(struct bfa_fcs_v
  */
 static void
 bfa_fcs_vport_sm_deleting(struct bfa_fcs_vport_s *vport,
-			  enum bfa_fcs_vport_event event)
+				enum bfa_fcs_vport_event event)
 {
 	bfa_trc(__vport_fcs(vport), __vport_pwwn(vport));
 	bfa_trc(__vport_fcs(vport), event);
@@ -339,18 +340,19 @@ bfa_fcs_vport_sm_deleting(struct bfa_fcs
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(__vport_fcs(vport), event);
 	}
 }
 
 /**
- * Error State.
- * This state will be set when the Vport Creation fails due to errors like
- * Dup WWN. In this state only operation allowed is a Vport Delete.
+ *  Error State.
+ *  This state will be set when the Vport Creation fails due
+ *  to errors like Dup WWN.
+ *  In this state only operation allowed is a Vport Delete.
  */
 static void
 bfa_fcs_vport_sm_error(struct bfa_fcs_vport_s *vport,
-		       enum bfa_fcs_vport_event event)
+				enum bfa_fcs_vport_event event)
 {
 	bfa_trc(__vport_fcs(vport), __vport_pwwn(vport));
 	bfa_trc(__vport_fcs(vport), event);
@@ -372,7 +374,7 @@ bfa_fcs_vport_sm_error(struct bfa_fcs_vp
  */
 static void
 bfa_fcs_vport_sm_cleanup(struct bfa_fcs_vport_s *vport,
-			 enum bfa_fcs_vport_event event)
+				enum bfa_fcs_vport_event event)
 {
 	bfa_trc(__vport_fcs(vport), __vport_pwwn(vport));
 	bfa_trc(__vport_fcs(vport), event);
@@ -387,7 +389,7 @@ bfa_fcs_vport_sm_cleanup(struct bfa_fcs_
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(__vport_fcs(vport), event);
 	}
 }
 
@@ -397,7 +399,7 @@ bfa_fcs_vport_sm_cleanup(struct bfa_fcs_
  */
 static void
 bfa_fcs_vport_sm_logo(struct bfa_fcs_vport_s *vport,
-		      enum bfa_fcs_vport_event event)
+				enum bfa_fcs_vport_event event)
 {
 	bfa_trc(__vport_fcs(vport), __vport_pwwn(vport));
 	bfa_trc(__vport_fcs(vport), event);
@@ -419,7 +421,7 @@ bfa_fcs_vport_sm_logo(struct bfa_fcs_vpo
 		break;
 
 	default:
-		bfa_assert(0);
+		bfa_sm_fault(__vport_fcs(vport), event);
 	}
 }
 
@@ -435,34 +437,19 @@ bfa_fcs_vport_sm_logo(struct bfa_fcs_vpo
 static void
 bfa_fcs_vport_aen_post(bfa_fcs_lport_t *port, enum bfa_lport_aen_event event)
 {
-	union bfa_aen_data_u aen_data;
-	struct bfa_log_mod_s *logmod = port->fcs->logm;
+	union bfa_aen_data_u  aen_data;
+	struct bfa_log_mod_s   *logmod = port->fcs->logm;
 	enum bfa_port_role role = port->port_cfg.roles;
 	wwn_t           lpwwn = bfa_fcs_port_get_pwwn(port);
 	char            lpwwn_ptr[BFA_STRING_32];
-	char           *role_str[BFA_PORT_ROLE_FCP_MAX / 2 + 1] =
-		{ "Initiator", "Target", "IPFC" };
+	char            *role_str[BFA_PORT_ROLE_FCP_MAX/2 + 1] =
+				{"Initiator", "Target", "IPFC"};
 
 	wwn2str(lpwwn_ptr, lpwwn);
 
 	bfa_assert(role <= BFA_PORT_ROLE_FCP_MAX);
-
-	switch (event) {
-	case BFA_LPORT_AEN_NPIV_DUP_WWN:
-		bfa_log(logmod, BFA_AEN_LPORT_NPIV_DUP_WWN, lpwwn_ptr,
-			role_str[role / 2]);
-		break;
-	case BFA_LPORT_AEN_NPIV_FABRIC_MAX:
-		bfa_log(logmod, BFA_AEN_LPORT_NPIV_FABRIC_MAX, lpwwn_ptr,
-			role_str[role / 2]);
-		break;
-	case BFA_LPORT_AEN_NPIV_UNKNOWN:
-		bfa_log(logmod, BFA_AEN_LPORT_NPIV_UNKNOWN, lpwwn_ptr,
-			role_str[role / 2]);
-		break;
-	default:
-		break;
-	}
+	bfa_log(logmod, BFA_LOG_CREATE_ID(BFA_AEN_CAT_LPORT, event), lpwwn_ptr,
+			role_str[role/2]);
 
 	aen_data.lport.vf_id = port->fabric->vf_id;
 	aen_data.lport.roles = role;
@@ -478,36 +465,34 @@ static void
 bfa_fcs_vport_do_fdisc(struct bfa_fcs_vport_s *vport)
 {
 	bfa_lps_fdisc(vport->lps, vport,
-		      bfa_pport_get_maxfrsize(__vport_bfa(vport)),
-		      __vport_pwwn(vport), __vport_nwwn(vport));
+		bfa_fcport_get_maxfrsize(__vport_bfa(vport)),
+		__vport_pwwn(vport), __vport_nwwn(vport));
 	vport->vport_stats.fdisc_sent++;
 }
 
 static void
 bfa_fcs_vport_fdisc_rejected(struct bfa_fcs_vport_s *vport)
 {
-	u8         lsrjt_rsn = bfa_lps_get_lsrjt_rsn(vport->lps);
-	u8         lsrjt_expl = bfa_lps_get_lsrjt_expl(vport->lps);
+	u8		lsrjt_rsn = bfa_lps_get_lsrjt_rsn(vport->lps);
+	u8		lsrjt_expl = bfa_lps_get_lsrjt_expl(vport->lps);
 
 	bfa_trc(__vport_fcs(vport), lsrjt_rsn);
 	bfa_trc(__vport_fcs(vport), lsrjt_expl);
 
-	/*
-	 * For certain reason codes, we don't want to retry.
-	 */
+	/* For certain reason codes, we don't want to retry. */
 	switch (bfa_lps_get_lsrjt_expl(vport->lps)) {
-	case FC_LS_RJT_EXP_INV_PORT_NAME:	/* by brocade */
-	case FC_LS_RJT_EXP_INVALID_NPORT_ID:	/* by Cisco */
+	case  FC_LS_RJT_EXP_INV_PORT_NAME: /* by brocade */
+	case  FC_LS_RJT_EXP_INVALID_NPORT_ID: /* by Cisco */
 		if (vport->fdisc_retries < BFA_FCS_VPORT_MAX_RETRIES)
 			bfa_sm_send_event(vport, BFA_FCS_VPORT_SM_RSP_ERROR);
 		else {
 			bfa_fcs_vport_aen_post(&vport->lport,
-					       BFA_LPORT_AEN_NPIV_DUP_WWN);
+				BFA_LPORT_AEN_NPIV_DUP_WWN);
 			bfa_sm_send_event(vport, BFA_FCS_VPORT_SM_RSP_DUP_WWN);
 		}
 		break;
 
-	case FC_LS_RJT_EXP_INSUFF_RES:
+	case  FC_LS_RJT_EXP_INSUFF_RES:
 		/*
 		 * This means max logins per port/switch setting on the
 		 * switch was exceeded.
@@ -516,15 +501,15 @@ bfa_fcs_vport_fdisc_rejected(struct bfa_
 			bfa_sm_send_event(vport, BFA_FCS_VPORT_SM_RSP_ERROR);
 		else {
 			bfa_fcs_vport_aen_post(&vport->lport,
-					       BFA_LPORT_AEN_NPIV_FABRIC_MAX);
+				BFA_LPORT_AEN_NPIV_FABRIC_MAX);
 			bfa_sm_send_event(vport, BFA_FCS_VPORT_SM_RSP_FAILED);
 		}
 		break;
 
 	default:
-		if (vport->fdisc_retries == 0)	/* Print only once */
+		if (vport->fdisc_retries == 0) 	/* Print only once */
 			bfa_fcs_vport_aen_post(&vport->lport,
-					       BFA_LPORT_AEN_NPIV_UNKNOWN);
+					BFA_LPORT_AEN_NPIV_UNKNOWN);
 		bfa_sm_send_event(vport, BFA_FCS_VPORT_SM_RSP_ERROR);
 	}
 }
@@ -542,6 +527,7 @@ bfa_fcs_vport_do_logo(struct bfa_fcs_vpo
 	bfa_lps_fdisclogo(vport->lps);
 }
 
+
 /**
  *     This routine will be called by bfa_timer on timer timeouts.
  *
@@ -551,14 +537,14 @@ bfa_fcs_vport_do_logo(struct bfa_fcs_vpo
  * 	return
  * 		void
  *
-* 	Special Considerations:
+ * 	Special Considerations:
  *
  * 	note
  */
 static void
 bfa_fcs_vport_timeout(void *vport_arg)
 {
-	struct bfa_fcs_vport_s *vport = (struct bfa_fcs_vport_s *)vport_arg;
+	struct bfa_fcs_vport_s *vport = (struct bfa_fcs_vport_s *) vport_arg;
 
 	vport->vport_stats.fdisc_timeouts++;
 	bfa_sm_send_event(vport, BFA_FCS_VPORT_SM_TIMEOUT);
@@ -616,36 +602,6 @@ bfa_fcs_vport_delete_comp(struct bfa_fcs
 	bfa_sm_send_event(vport, BFA_FCS_VPORT_SM_DELCOMP);
 }
 
-/**
- *   Module initialization
- */
-void
-bfa_fcs_vport_modinit(struct bfa_fcs_s *fcs)
-{
-}
-
-/**
- *   Module cleanup
- */
-void
-bfa_fcs_vport_modexit(struct bfa_fcs_s *fcs)
-{
-	bfa_fcs_modexit_comp(fcs);
-}
-
-u32
-bfa_fcs_vport_get_max(struct bfa_fcs_s *fcs)
-{
-	struct bfa_ioc_attr_s ioc_attr;
-
-	bfa_get_attr(fcs->bfa, &ioc_attr);
-
-	if (ioc_attr.pci_attr.device_id == BFA_PCI_DEVICE_ID_CT)
-		return (BFA_FCS_MAX_VPORTS_SUPP_CT);
-	else
-		return (BFA_FCS_MAX_VPORTS_SUPP_CB);
-}
-
 
 
 /**
@@ -658,7 +614,7 @@ bfa_fcs_vport_get_max(struct bfa_fcs_s *
  * 	done in vport_start() call)
  *
  * 	param[in] vport	- 	pointer to bfa_fcs_vport_t. This space
- * 					needs to be allocated by the driver.
+ *					needs to be allocated by the driver.
  * 	param[in] fcs 		- 	FCS instance
  * 	param[in] vport_cfg	- 	vport configuration
  * 	param[in] vf_id    	- 	VF_ID if vport is created within a VF.
@@ -671,11 +627,11 @@ bfa_fcs_vport_get_max(struct bfa_fcs_s *
  */
 bfa_status_t
 bfa_fcs_vport_create(struct bfa_fcs_vport_s *vport, struct bfa_fcs_s *fcs,
-		     u16 vf_id, struct bfa_port_cfg_s *vport_cfg,
-		     struct bfad_vport_s *vport_drv)
+			u16 vf_id, struct bfa_port_cfg_s *vport_cfg,
+			struct bfad_vport_s *vport_drv)
 {
 	if (vport_cfg->pwwn == 0)
-		return (BFA_STATUS_INVALID_WWN);
+		return BFA_STATUS_INVALID_WWN;
 
 	if (bfa_fcs_port_get_pwwn(&fcs->fabric.bport) == vport_cfg->pwwn)
 		return BFA_STATUS_VPORT_WWN_BP;
@@ -684,7 +640,7 @@ bfa_fcs_vport_create(struct bfa_fcs_vpor
 		return BFA_STATUS_VPORT_EXISTS;
 
 	if (bfa_fcs_fabric_vport_count(&fcs->fabric) ==
-	    bfa_fcs_vport_get_max(fcs))
+			bfa_lps_get_max_vport(fcs->bfa))
 		return BFA_STATUS_VPORT_MAX;
 
 	vport->lps = bfa_lps_alloc(fcs->bfa);
@@ -693,9 +649,8 @@ bfa_fcs_vport_create(struct bfa_fcs_vpor
 
 	vport->vport_drv = vport_drv;
 	bfa_sm_set_state(vport, bfa_fcs_vport_sm_uninit);
-
-	bfa_fcs_lport_init(&vport->lport, fcs, vf_id, vport_cfg, vport);
-
+	bfa_fcs_lport_attach(&vport->lport, fcs, vf_id, vport);
+	bfa_fcs_lport_init(&vport->lport, vport_cfg);
 	bfa_sm_send_event(vport, BFA_FCS_VPORT_SM_CREATE);
 
 	return BFA_STATUS_OK;
@@ -759,7 +714,7 @@ bfa_fcs_vport_delete(struct bfa_fcs_vpor
  */
 void
 bfa_fcs_vport_get_attr(struct bfa_fcs_vport_s *vport,
-		       struct bfa_vport_attr_s *attr)
+			struct bfa_vport_attr_s *attr)
 {
 	if (vport == NULL || attr == NULL)
 		return;
@@ -842,9 +797,7 @@ bfa_cb_lps_fdisc_comp(void *bfad, void *
 		break;
 
 	case BFA_STATUS_INVALID_MAC:
-		/*
-		 * Only for CNA
-		 */
+		/* Only for CNA */
 		vport->vport_stats.fdisc_acc_bad++;
 		bfa_sm_send_event(vport, BFA_FCS_VPORT_SM_RSP_ERROR);
 
@@ -888,4 +841,17 @@ bfa_cb_lps_fdisclogo_comp(void *bfad, vo
 	bfa_sm_send_event(vport, BFA_FCS_VPORT_SM_RSP_OK);
 }
 
+/**
+ * Received clear virtual link
+ */
+void
+bfa_cb_lps_cvl_event(void *bfad, void *uarg)
+{
+	struct bfa_fcs_vport_s *vport = uarg;
+
+	/* Send an Offline followed by an ONLINE */
+	bfa_sm_send_event(vport, BFA_FCS_VPORT_SM_OFFLINE);
+	bfa_sm_send_event(vport, BFA_FCS_VPORT_SM_ONLINE);
+}
+
 

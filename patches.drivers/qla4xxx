From: Ravi Anand <ravi.anand@qlogic.com>
Subject: qla4xxx : Driver v5.00.05-d5
References: 155458 - LTC22173 - LDP 112936, 169991

This patch includes the qla4xxx driver v5.00-05-d5

Signed-off-by: David Wagner <david.wagner@qlogic.com>
Acked-by: Hannes Reinecke <hare@suse.de>

diff --git a/Documentation/scsi/LICENSE.qla4xxx b/Documentation/scsi/LICENSE.qla4xxx
new file mode 100644
index 0000000..b12cd7a
--- /dev/null
+++ b/Documentation/scsi/LICENSE.qla4xxx
@@ -0,0 +1,45 @@
+Copyright (c)  2003-2006 QLogic Corporation
+QLogic Linux iSCSI HBA Driver
+
+This program includes a device driver for Linux 2.6 that may be
+distributed with QLogic hardware specific firmware binary file.
+You may modify and redistribute the device driver code under the
+GNU General Public License as published by the Free Software
+Foundation (version 2 or a later version).
+
+You may redistribute the hardware specific firmware binary file
+under the following terms:
+
+	1. Redistribution of source code (only if applicable),
+	   must retain the above copyright notice, this list of
+	   conditions and the following disclaimer.
+
+	2. Redistribution in binary form must reproduce the above
+	   copyright notice, this list of conditions and the
+	   following disclaimer in the documentation and/or other
+	   materials provided with the distribution.
+
+	3. The name of QLogic Corporation may not be used to
+	   endorse or promote products derived from this software
+	   without specific prior written permission
+
+REGARDLESS OF WHAT LICENSING MECHANISM IS USED OR APPLICABLE,
+THIS PROGRAM IS PROVIDED BY QLOGIC CORPORATION "AS IS'' AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR
+BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+USER ACKNOWLEDGES AND AGREES THAT USE OF THIS PROGRAM WILL NOT
+CREATE OR GIVE GROUNDS FOR A LICENSE BY IMPLICATION, ESTOPPEL, OR
+OTHERWISE IN ANY INTELLECTUAL PROPERTY RIGHTS (PATENT, COPYRIGHT,
+TRADE SECRET, MASK WORK, OR OTHER PROPRIETARY RIGHT) EMBODIED IN
+ANY OTHER QLOGIC HARDWARE OR SOFTWARE EITHER SOLELY OR IN
+COMBINATION WITH THIS PROGRAM.
diff --git a/drivers/scsi/Kconfig b/drivers/scsi/Kconfig
index 3c606cf..2ca97cf 100644
--- a/drivers/scsi/Kconfig
+++ b/drivers/scsi/Kconfig
@@ -1340,6 +1340,7 @@ config SCSI_QLOGICPTI
 	  module will be called qlogicpti.
 
 source "drivers/scsi/qla2xxx/Kconfig"
+source "drivers/scsi/qla4xxx/Kconfig"
 
 config SCSI_LPFC
 	tristate "Emulex LightPulse Fibre Channel Support"
diff --git a/drivers/scsi/Makefile b/drivers/scsi/Makefile
index ebd1ca9..0f204e9 100644
--- a/drivers/scsi/Makefile
+++ b/drivers/scsi/Makefile
@@ -81,6 +81,7 @@ obj-$(CONFIG_PCMCIA_QLOGIC)	+= qlogicfas
 obj-$(CONFIG_SCSI_QLOGIC_FC)	+= qlogicfc.o 
 obj-$(CONFIG_SCSI_QLOGIC_1280)	+= qla1280.o 
 obj-$(CONFIG_SCSI_QLA_FC)	+= qla2xxx/
+obj-$(CONFIG_SCSI_QLA_ISCSI)	+= qla4xxx/
 obj-$(CONFIG_SCSI_LPFC)		+= lpfc/
 obj-$(CONFIG_SCSI_PAS16)	+= pas16.o
 obj-$(CONFIG_SCSI_SEAGATE)	+= seagate.o
diff --git a/drivers/scsi/qla4xxx/Kconfig b/drivers/scsi/qla4xxx/Kconfig
new file mode 100644
index 0000000..9dbe051
--- /dev/null
+++ b/drivers/scsi/qla4xxx/Kconfig
@@ -0,0 +1,6 @@
+config SCSI_QLA4XXX
+	tristate "QLogic ISP4XXX host adapter family support"
+        depends on PCI && SCSI
+	---help---
+	This driver supports the QLogic 40xx (ISP4XXX) host adapter family.
+
diff --git a/drivers/scsi/qla4xxx/Makefile b/drivers/scsi/qla4xxx/Makefile
new file mode 100644
index 0000000..95933c9
--- /dev/null
+++ b/drivers/scsi/qla4xxx/Makefile
@@ -0,0 +1,8 @@
+# --- Override settings until Kconfig embedded
+CONFIG_SCSI_QLA4XXX=m
+EXTRA_CFLAGS += -DCONFIG_SCSI_QLA4XXX -DCONFIG_SCSI_QLA4XXX_MODULE 
+
+qla4xxx-y = ql4_os.o ql4_init.o ql4_mbx.o ql4_iocb.o ql4_isr.o ql4_isns.o \
+		ql4_nvram.o ql4_dbg.o
+
+obj-$(CONFIG_SCSI_QLA4XXX) += qla4xxx.o
diff --git a/drivers/scsi/qla4xxx/ql4_dbg.c b/drivers/scsi/qla4xxx/ql4_dbg.c
new file mode 100644
index 0000000..4ef2c94
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_dbg.c
@@ -0,0 +1,710 @@
+/******************************************************************************
+ *     Copyright (C)  2003 -2005 QLogic Corporation
+ * QLogic ISP4xxx Device Driver
+ *
+ * This program includes a device driver for Linux 2.6.x that may be
+ * distributed with QLogic hardware specific firmware binary file.
+ * You may modify and redistribute the device driver code under the
+ * GNU General Public License as published by the Free Software Foundation
+ * (version 2 or a later version) and/or under the following terms,
+ * as applicable:
+ *
+ * 	1. Redistribution of source code must retain the above copyright
+ *         notice, this list of conditions and the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above copyright
+ *         notice, this list of conditions and the following disclaimer in
+ *         the documentation and/or other materials provided with the
+ *         distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ * 	
+ * You may redistribute the hardware specific firmware binary file under
+ * the following terms:
+ * 	1. Redistribution of source code (only if applicable), must
+ *         retain the above copyright notice, this list of conditions and
+ *         the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above
+ *         copyright notice, this list of conditions and the following
+ *         disclaimer in the documentation and/or other materials provided
+ *         with the distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ *
+ * REGARDLESS OF WHAT LICENSING MECHANISM IS USED OR APPLICABLE,
+ * THIS PROGRAM IS PROVIDED BY QLOGIC CORPORATION "AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * USER ACKNOWLEDGES AND AGREES THAT USE OF THIS PROGRAM WILL NOT CREATE
+ * OR GIVE GROUNDS FOR A LICENSE BY IMPLICATION, ESTOPPEL, OR OTHERWISE
+ * IN ANY INTELLECTUAL PROPERTY RIGHTS (PATENT, COPYRIGHT, TRADE SECRET,
+ * MASK WORK, OR OTHER PROPRIETARY RIGHT) EMBODIED IN ANY OTHER QLOGIC
+ * HARDWARE OR SOFTWARE EITHER SOLELY OR IN COMBINATION WITH THIS PROGRAM
+ *
+ ******************************************************************************
+ *             Please see release.txt for revision history.                   *
+ *                                                                            *
+ ******************************************************************************
+ * Function Table of Contents:
+ *	qla4xxx_get_debug_level
+ *	qla4xxx_set_debug_level
+ *	printchar
+ *	qla4xxx_dump_bytes
+ *	qla4xxx_dump_words
+ *	qla4xxx_dump_dwords
+ *	qla4xxx_print_scsi_cmd
+ *	qla4xxx_print_srb_info
+ *	qla4xxx_print_iocb_passthru
+ *	__dump_dwords
+ *	__dump_words
+ *	__dump_registers
+ *	qla4xxx_dump_registers
+ *	__dump_mailbox_registers
+ ****************************************************************************/
+
+#include "ql4_def.h"
+
+//#define QLP1	0x00000002  // Unrecoverable error messages
+//#define QLP2	0x00000004  // Unexpected completion path error messages
+//#define QLP3	0x00000008  // Function trace messages
+//#define QLP4	0x00000010  // IOCTL trace messages
+//#define QLP5	0x00000020  // I/O & Request/Response queue trace messages
+//#define QLP6	0x00000040  // Watchdog messages (current state)
+//#define QLP7	0x00000080  // Initialization
+//#define QLP8	0x00000100  // Internal command queue traces
+//#define QLP9	0x00000200  // Unused
+//#define QLP10	0x00000400  // Extra Debug messages (dump buffers)
+//#define QLP11	0x00000800  // Mailbox & ISR Details
+//#define QLP12	0x00001000  // Enter/Leave routine messages
+//#define QLP13 0x00002000  // Display data for Inquiry, TUR, ReqSense, RptLuns
+//#define QLP14 0x00004000
+//#define QLP15 0x00008000  // Display jiffies for IOCTL calls
+//#define QLP16 0x00010000  // Extended proc print statements (srb info)
+//#define QLP17 0x00020000  // Display NVRAM Accesses
+//#define QLP18 0x00040000  // unused
+//#define QLP19	0x00080000  // PDU info
+//#define QLP20 0x00100000  // iSNS info
+//#define QLP24 0x01000000  // Scatter/Gather info
+
+uint32_t ql_dbg_level = 0;
+
+/**************************************************************************
+ * qla4xxx_get_debug_level
+ *	This routine retrieves the driver's debug print level.
+ *
+ * Input:
+ *	dbg_level - driver's debug print level
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS - always
+ **************************************************************************/
+uint8_t
+qla4xxx_get_debug_level(uint32_t *dbg_level)
+{
+	*dbg_level = ql_dbg_level;
+	barrier();
+	return(QLA_SUCCESS);
+}
+
+/**************************************************************************
+ * qla4xxx_set_debug_level
+ *	This routine sets the driver's debug print level.
+ *
+ * Input:
+ *	dbg_level - driver's debug print level
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS - always
+ **************************************************************************/
+uint8_t
+qla4xxx_set_debug_level(uint32_t dbg_level)
+{
+	ql_dbg_level = dbg_level;
+	barrier();
+	return(QLA_SUCCESS);
+}
+
+/****************************************************************************/
+/*                      Debug Print Routines                          	    */
+/****************************************************************************/
+
+void printchar(char ch)
+{
+	if (ch>=32)
+		printk("%c", ch);
+	else
+		printk(".");
+}
+
+/**************************************************************************
+ * qla4xxx_dump_bytes
+ *	This routine displays bytes in hex format
+ *
+ * Input:
+ *	dbg_mask - this call's debug print mask
+ *	buffer   - data buffer to display
+ *	size     - number of bytes to display
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	None
+ **************************************************************************/
+void
+qla4xxx_dump_bytes(uint32_t dbg_mask, void *buffer, uint32_t size)
+{
+	uint32_t i;
+	uint8_t  *data = (uint8_t *)buffer;
+
+	if ((ql_dbg_level & dbg_mask) != 0) {
+		#if 0
+		  printk("        0  1  2  3  4  5  6  7 -  8  9  A  B  C  D  E  F\n");
+		  printk("---------------------------------------------------------\n");
+		#endif
+
+		for (i = 0; i < size; i++, data++) {
+			if (i % 0x10 == 0) {
+				printk("%04X:  %02X", i, *data);
+			}
+			else if (i % 0x10 == 0x08) {
+				printk(" - %02X", *data);
+			}
+			else if (i % 0x10 == 0xF) {
+				printk(" %02X:  ", *data);
+				printchar(*(data-15));
+				printchar(*(data-14));
+				printchar(*(data-13));
+				printchar(*(data-12));
+				printchar(*(data-11));
+				printchar(*(data-10));
+				printchar(*(data-9));
+				printchar(*(data-8));
+				printchar(*(data-7));
+				printchar(*(data-6));
+				printchar(*(data-5));
+				printchar(*(data-4));
+				printchar(*(data-3));
+				printchar(*(data-2));
+				printchar(*(data-1));
+				printchar(*data);
+				printk("\n");
+			}
+			else {
+				printk(" %02X", *data);
+			}
+		}
+
+		if ((i != 0) && (i % 0x10)) {
+			printk("\n");
+		}
+		printk("\n");
+	}
+}
+
+/**************************************************************************
+ * qla4xxx_dump_words
+ *	This routine displays words in hex format
+ *
+ * Input:
+ *	dbg_mask - this call's debug print mask
+ *	buffer   - data buffer to display
+ *	size     - number of bytes to display
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	None
+ **************************************************************************/
+void
+qla4xxx_dump_words(uint32_t dbg_mask, void *buffer, uint32_t size)
+{
+	if ((ql_dbg_level & dbg_mask) != 0)
+		__dump_words(buffer, size);
+}
+
+/**************************************************************************
+ * qla4xxx_dump_dwords
+ *	This routine displays double words in hex format
+ *
+ * Input:
+ *	dbg_mask - this call's debug print mask
+ *	buffer   - data buffer to display
+ *	size     - number of bytes to display
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	None
+ **************************************************************************/
+void
+qla4xxx_dump_dwords(uint32_t dbg_mask, void *buffer, uint32_t size)
+{
+	if ((ql_dbg_level & dbg_mask) != 0)
+		__dump_dwords(buffer, size);
+}
+
+/**************************************************************************
+ * qla4xxx_print_scsi_cmd
+ *	This routine displays the SCSI command
+ *
+ * Input:
+ *	dbg_mask - this call's debug print mask
+ *	cmd      - pointer to Linux kernel command structure
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	None
+ **************************************************************************/
+void
+qla4xxx_print_scsi_cmd(uint32_t dbg_mask, struct scsi_cmnd *cmd)
+{
+	if ((ql_dbg_level & dbg_mask) != 0) {
+		int   i;
+
+		printk("SCSI Command = 0x%p, Handle=0x%p\n",
+		       cmd, cmd->host_scribble);
+
+		printk("  b=%d, t=%02xh, l=%02xh, cmd_len = %02xh\n",
+		       cmd->device->channel, cmd->device->id, cmd->device->lun,
+		       cmd->cmd_len);
+
+		printk("  CDB = ");
+		for (i = 0; i < cmd->cmd_len; i++)
+			printk("%02x ", cmd->cmnd[i]);
+
+		printk("  seg_cnt = %d\n",cmd->use_sg);
+		printk("  request buffer = 0x%p, request buffer len = 0x%x\n",
+		       cmd->request_buffer,cmd->request_bufflen);
+
+		if (cmd->use_sg) {
+			struct scatterlist *sg;
+			sg = (struct scatterlist *) cmd->request_buffer;
+			printk("  SG buffer: \n");
+			qla4xxx_dump_bytes(dbg_mask, (caddr_t)sg,
+					   (cmd->use_sg *
+					    sizeof(struct scatterlist)));
+		}
+
+		printk("  tag = %d, transfersize = 0x%x \n",
+		       cmd->tag, cmd->transfersize);
+
+		printk("  Pid = %d, SP = 0x%p\n", (int)cmd->pid, CMD_SP(cmd));
+		printk("  underflow size = 0x%x, direction=0x%x\n",
+		       cmd->underflow, cmd->sc_data_direction);
+
+		printk("  Current time (jiffies) = 0x%lx, "
+		       "timeout expires = 0x%lx\n",
+		       jiffies, cmd->eh_timeout.expires);
+	}
+}
+
+void
+qla4xxx_dump_command(scsi_qla_host_t *ha, struct scsi_cmnd *cmd )
+{
+	if (host_byte(cmd->result) == DID_OK) {
+		switch (cmd->cmnd[0]) {
+		case TEST_UNIT_READY:
+			QL4PRINT(QLP13,
+				 printk("scsi%d:%d:%d:%d: %s: "
+					"TEST_UNIT_READY "
+					"status = 0x%x\n",
+					ha->host_no, cmd->device->channel,
+					cmd->device->id, cmd->device->lun,
+					__func__, cmd->result & 0xff));
+
+			if (driver_byte(cmd->result) & DRIVER_SENSE) {
+				QL4PRINT(QLP13,
+					 printk("REQUEST_SENSE data:  "
+						"(MAX 0x20 bytes displayed)\n"));
+
+				qla4xxx_dump_bytes(QLP13, cmd->sense_buffer,
+						   MIN(0x20, sizeof(cmd->sense_buffer)));
+			}
+			break;
+		case INQUIRY:
+			QL4PRINT(QLP13, printk("scsi%d:%d:%d:%d: %s: "
+					       "INQUIRY data: "
+					       "(MAX 0x30 bytes displayed)\n",
+					       ha->host_no,
+					       cmd->device->channel,
+					       cmd->device->id,
+					       cmd->device->lun, __func__));
+
+			qla4xxx_dump_bytes(QLP13, cmd->request_buffer,
+					   MIN(0x30, cmd->request_bufflen));
+
+			if (strncmp(cmd->request_buffer,
+				    "\7f\00\00\00\7f\00\00\00", 8) == 0) {
+				QL4PRINT(QLP2,
+					 printk("scsi%d:%d:%d:%d: %s: "
+						"Device not present.  "
+						"Possible connection "
+						"problem with iSCSI router\n",
+						ha->host_no,
+						cmd->device->channel,
+						cmd->device->id,
+						cmd->device->lun, __func__));
+			}
+			break;
+		case REQUEST_SENSE:
+			QL4PRINT(QLP13,
+				 printk("scsi%d:%d:%d:%d: %s: REQUEST_SENSE "
+					"data:  (MAX 0x20 bytes displayed)\n",
+					ha->host_no, cmd->device->channel,
+					cmd->device->id, cmd->device->lun, __func__));
+
+			qla4xxx_dump_bytes(QLP13, cmd->request_buffer,
+					   MIN(0x20, cmd->request_bufflen));
+			break;
+		case REPORT_LUNS:
+			QL4PRINT(QLP13,
+				 printk("scsi%d:%d:%d:%d: %s: "
+					"REPORT_LUNS data: "
+					"(MAX 0x40 bytes displayed)\n",
+					ha->host_no, cmd->device->channel,
+					cmd->device->id, cmd->device->lun,
+					__func__));
+
+			qla4xxx_dump_bytes(QLP13, cmd->request_buffer,
+					   MIN(0x40, cmd->request_bufflen));
+			break;
+		}
+
+	}
+
+}
+
+/**************************************************************************
+ * qla4xxx_print_srb_info
+ *	This routine displays the srb structure
+ *
+ * Input:
+ *	dbg_mask - this call's debug print mask
+ *	srb      - pointer to srb structure
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	None
+ **************************************************************************/
+void
+qla4xxx_print_srb_info(uint32_t dbg_mask, srb_t *srb)
+{
+	if ((ql_dbg_level & dbg_mask) != 0) {
+		printk("%s: srb = 0x%p, flags=0x%02x\n",
+		       __func__, srb, srb->flags);
+		printk("%s: entry_count = 0x%02x\n",
+		       __func__, srb->entry_count);
+		printk("%s: cmd = 0x%p, saved_dma_handle = 0x%x\n",
+		       __func__, srb->cmd, (uint32_t) srb->saved_dma_handle);
+		printk("%s: fw_ddb_index = %d, lun = %d\n",
+		       __func__, srb->fw_ddb_index, srb->lun);
+		printk("%s: os_tov = %d, iocb_tov = %d\n",
+		       __func__, srb->os_tov, srb->iocb_tov);
+		printk("%s: cc_stat = 0x%x, r_start = 0x%lx, u_start = 0x%lx\n\n",
+		       __func__, srb->cc_stat, srb->r_start, srb->u_start);
+	}
+}
+
+/* hardware_lock taken */
+void
+__dump_dwords(void *buffer, uint32_t size)
+{
+	uint32_t *data = (uint32_t *)buffer;
+	uint32_t i;
+
+	for (i = 0; i < size; i+=4, data++) {
+		if (i % 0x10 == 0) {
+			printk("%04X:  %08X", i, *data);
+		}
+		else if (i % 0x10 == 0x08) {
+			printk(" - %08X", *data);
+		}
+		else if (i % 0x10 == 0x0C) {
+			printk(" %08X\n", *data);
+		}
+		else {
+			printk(" %08X", *data);
+		}
+	}
+	if ((i != 0) && (i % 0x10 != 0)) {
+		printk("\n");
+	}
+}
+
+/* hardware_lock taken */
+void
+__dump_words(void *buffer, uint32_t size)
+{
+	uint16_t *data = (uint16_t *)buffer;
+	uint32_t i;
+
+	for (i = 0; i < size; i+=2, data++) {
+		if (i % 0x10 == 0) {
+			printk(KERN_INFO "%04X:  %04X", i, *data);
+		}
+		else if (i % 0x10 == 0x08) {
+			printk(KERN_INFO " - %04X", *data);
+		}
+		else if (i % 0x10 == 0x0E) {
+			uint8_t *bdata = (uint8_t *) data;
+			printk(KERN_INFO " %04X:  ", *data);
+			printchar(*(bdata-13));
+			printchar(*(bdata-14));
+			printchar(*(bdata-11));
+			printchar(*(bdata-12));
+			printchar(*(bdata-9));
+			printchar(*(bdata-10));
+			printchar(*(bdata-7));
+			printchar(*(bdata-8));
+			printchar(*(bdata-5));
+			printchar(*(bdata-6));
+			printchar(*(bdata-3));
+			printchar(*(bdata-4));
+			printchar(*(bdata-1));
+			printchar(*(bdata-2));
+			printchar(*(bdata+1));
+			printchar(*(bdata));
+			printk("\n");
+		}
+		else {
+			printk(KERN_INFO " %04X", *data);
+		}
+	}
+	if ((i != 0) && (i % 0x10 != 0)) {
+		printk(KERN_INFO "\n");
+	}
+}
+
+/* hardware_lock taken */
+void
+__dump_registers(uint32_t dbg_mask, scsi_qla_host_t *ha)
+{
+	uint8_t  i;
+
+	if ((ql_dbg_level & dbg_mask) == 0)
+		return;
+
+
+	for (i=0; i<MBOX_REG_COUNT; i++) {
+		printk(KERN_INFO "0x%02X mailbox[%d]      = 0x%08X\n",
+		       (uint8_t) offsetof(isp_reg_t, mailbox[i]), i,
+		       RD_REG_DWORD(&ha->reg->mailbox[i]));
+	}
+	printk(KERN_INFO "0x%02X flash_address   = 0x%08X\n",
+	       (uint8_t) offsetof(isp_reg_t, flash_address),
+	       RD_REG_DWORD(&ha->reg->flash_address));
+
+	printk(KERN_INFO "0x%02X flash_data      = 0x%08X\n",
+	       (uint8_t) offsetof(isp_reg_t, flash_data),
+	       RD_REG_DWORD(&ha->reg->flash_data));
+
+	printk(KERN_INFO "0x%02X ctrl_status     = 0x%08X\n",
+	       (uint8_t) offsetof(isp_reg_t, ctrl_status),
+	       RD_REG_DWORD(&ha->reg->ctrl_status));
+
+	if (IS_QLA4010(ha)) {
+
+		printk(KERN_INFO "0x%02X nvram           = 0x%08X\n",
+		       (uint8_t) offsetof(isp_reg_t, u1.isp4010.nvram),
+		       RD_REG_DWORD(&ha->reg->u1.isp4010.nvram));
+	}
+	else if (IS_QLA4022(ha)) {
+
+		printk(KERN_INFO "0x%02X intr_mask       = 0x%08X\n",
+		    (uint8_t) offsetof(isp_reg_t, u1.isp4022.intr_mask),
+		    RD_REG_DWORD(&ha->reg->u1.isp4022.intr_mask));
+		
+		printk(KERN_INFO "0x%02X nvram           = 0x%08X\n",
+		    (uint8_t) offsetof(isp_reg_t, u1.isp4022.nvram),
+		    RD_REG_DWORD(&ha->reg->u1.isp4022.nvram));
+		
+		printk(KERN_INFO "0x%02X semaphore       = 0x%08X\n",
+		    (uint8_t) offsetof(isp_reg_t, u1.isp4022.semaphore),
+		    RD_REG_DWORD(&ha->reg->u1.isp4022.semaphore));
+	}
+
+	printk(KERN_INFO "0x%02X req_q_in        = 0x%08X\n",
+	       (uint8_t) offsetof(isp_reg_t, req_q_in),
+	       RD_REG_DWORD(&ha->reg->req_q_in));
+
+	printk(KERN_INFO "0x%02X rsp_q_out       = 0x%08X\n",
+	       (uint8_t) offsetof(isp_reg_t, rsp_q_out),
+	       RD_REG_DWORD(&ha->reg->rsp_q_out));
+
+	if (IS_QLA4010(ha)) {
+
+		printk(KERN_INFO "0x%02X ext_hw_conf     = 0x%08X\n",
+		       (uint8_t) offsetof(isp_reg_t, u2.isp4010.ext_hw_conf),
+		       RD_REG_DWORD(&ha->reg->u2.isp4010.ext_hw_conf));
+
+		printk(KERN_INFO "0x%02X port_ctrl       = 0x%08X\n",
+		       (uint8_t) offsetof(isp_reg_t, u2.isp4010.port_ctrl),
+		       RD_REG_DWORD(&ha->reg->u2.isp4010.port_ctrl));
+
+		printk(KERN_INFO "0x%02X port_status     = 0x%08X\n",
+		       (uint8_t) offsetof(isp_reg_t, u2.isp4010.port_status),
+		       RD_REG_DWORD(&ha->reg->u2.isp4010.port_status));
+
+		printk(KERN_INFO "0x%02X req_q_out       = 0x%08X\n",
+		       (uint8_t) offsetof(isp_reg_t, u2.isp4010.req_q_out),
+		       RD_REG_DWORD(&ha->reg->u2.isp4010.req_q_out));
+
+		printk(KERN_INFO "0x%02X gp_out          = 0x%08X\n",
+		       (uint8_t) offsetof(isp_reg_t, u2.isp4010.gp_out),
+		       RD_REG_DWORD(&ha->reg->u2.isp4010.gp_out));
+
+		printk(KERN_INFO "0x%02X gp_in           = 0x%08X\n",
+		       (uint8_t) offsetof(isp_reg_t, u2.isp4010.gp_in),
+		       RD_REG_DWORD(&ha->reg->u2.isp4010.gp_in));
+
+		printk(KERN_INFO "0x%02X port_err_status = 0x%08X\n",
+		       (uint8_t) offsetof(isp_reg_t, u2.isp4010.port_err_status),
+		       RD_REG_DWORD(&ha->reg->u2.isp4010.port_err_status));
+	}
+	else if (IS_QLA4022(ha)) {
+
+		printk(KERN_INFO "Page 0 Registers:\n");
+	
+		printk(KERN_INFO "0x%02X ext_hw_conf     = 0x%08X\n",
+		    (uint8_t) offsetof(isp_reg_t, u2.isp4022.p0.ext_hw_conf),
+		    RD_REG_DWORD(&ha->reg->u2.isp4022.p0.ext_hw_conf));
+		
+		printk(KERN_INFO "0x%02X port_ctrl       = 0x%08X\n",
+		    (uint8_t) offsetof(isp_reg_t, u2.isp4022.p0.port_ctrl),
+		    RD_REG_DWORD(&ha->reg->u2.isp4022.p0.port_ctrl));
+		
+		printk(KERN_INFO "0x%02X port_status     = 0x%08X\n",
+		    (uint8_t) offsetof(isp_reg_t, u2.isp4022.p0.port_status),
+		    RD_REG_DWORD(&ha->reg->u2.isp4022.p0.port_status));
+		
+		printk(KERN_INFO "0x%02X gp_out          = 0x%08X\n",
+		    (uint8_t) offsetof(isp_reg_t, u2.isp4022.p0.gp_out),
+		    RD_REG_DWORD(&ha->reg->u2.isp4022.p0.gp_out));
+		
+		printk(KERN_INFO "0x%02X gp_in           = 0x%08X\n",
+		    (uint8_t) offsetof(isp_reg_t, u2.isp4022.p0.gp_in),
+		    RD_REG_DWORD(&ha->reg->u2.isp4022.p0.gp_in));
+		
+		printk(KERN_INFO "0x%02X port_err_status = 0x%08X\n",
+		    (uint8_t) offsetof(isp_reg_t, u2.isp4022.p0.port_err_status),
+		    RD_REG_DWORD(&ha->reg->u2.isp4022.p0.port_err_status));
+		
+		printk(KERN_INFO "Page 1 Registers:\n");
+		
+		WRT_REG_DWORD(&ha->reg->ctrl_status, HOST_MEM_CFG_PAGE &
+			   SET_RMASK(CSR_SCSI_PAGE_SELECT));
+		
+		printk(KERN_INFO "0x%02X req_q_out       = 0x%08X\n",
+		    (uint8_t) offsetof(isp_reg_t, u2.isp4022.p1.req_q_out),
+		    RD_REG_DWORD(&ha->reg->u2.isp4022.p1.req_q_out));
+		
+		WRT_REG_DWORD(&ha->reg->ctrl_status, PORT_CTRL_STAT_PAGE &
+			   SET_RMASK(CSR_SCSI_PAGE_SELECT));
+		
+	}
+}
+
+/**************************************************************************
+ * qla4xxx_dump_registers
+ *	This routine displays ISP registers
+ *
+ * Input:
+ *	dbg_mask - this call's debug print mask
+ *	ha       - adapter structure pointer
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	None
+ **************************************************************************/
+void
+qla4xxx_dump_registers(uint32_t dbg_mask, scsi_qla_host_t *ha)
+{
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	__dump_registers(dbg_mask, ha);
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+}
+
+void
+__dump_mailbox_registers(uint32_t dbg_mask, scsi_qla_host_t *ha)
+{
+	int i =  0;
+
+	if ((ql_dbg_level & dbg_mask) == 0)
+		return;
+
+	for (i = 1; i < MBOX_REG_COUNT; i++)
+		printk(KERN_INFO "  Mailbox[%d] = %08x\n", i,
+			RD_REG_DWORD(&ha->reg->mailbox[i]));
+}
+
+void
+qla4xxx_dump_buffer(uint8_t * b, uint32_t size)
+{
+	uint32_t cnt;
+	uint8_t c;
+
+	printk(" 0   1   2   3   4   5   6   7   8   9  "
+	    "Ah  Bh  Ch  Dh  Eh  Fh\n");
+	printk("----------------------------------------"
+	    "----------------------\n");
+
+	for (cnt = 0; cnt < size;) {
+		c = *b++;
+		printk("%02x",(uint32_t) c);
+		cnt++;
+		if (!(cnt % 16))
+			printk("\n");
+		else
+			printk("  ");
+	}
+	if (cnt % 16)
+		printk("\n");
+}
+
+/*
+ * Overrides for Emacs so that we almost follow Linus's tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 2
+ * c-brace-imaginary-offset: 0
+ * c-brace-offset: -2
+ * c-argdecl-indent: 2
+ * c-label-offset: -2
+ * c-continued-statement-offset: 2
+ * c-continued-brace-offset: 0
+ * indent-tabs-mode: nil
+ * tab-width: 8
+ * End:
+ */
+
+
diff --git a/drivers/scsi/qla4xxx/ql4_dbg.h b/drivers/scsi/qla4xxx/ql4_dbg.h
new file mode 100644
index 0000000..3b081f8
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_dbg.h
@@ -0,0 +1,176 @@
+/******************************************************************************
+ *     Copyright (C)  2003 -2005 QLogic Corporation
+ * QLogic ISP4xxx Device Driver
+ *
+ * This program includes a device driver for Linux 2.6.x that may be
+ * distributed with QLogic hardware specific firmware binary file.
+ * You may modify and redistribute the device driver code under the
+ * GNU General Public License as published by the Free Software Foundation
+ * (version 2 or a later version) and/or under the following terms,
+ * as applicable:
+ *
+ * 	1. Redistribution of source code must retain the above copyright
+ *         notice, this list of conditions and the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above copyright
+ *         notice, this list of conditions and the following disclaimer in
+ *         the documentation and/or other materials provided with the
+ *         distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ * 	
+ * You may redistribute the hardware specific firmware binary file under
+ * the following terms:
+ * 	1. Redistribution of source code (only if applicable), must
+ *         retain the above copyright notice, this list of conditions and
+ *         the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above
+ *         copyright notice, this list of conditions and the following
+ *         disclaimer in the documentation and/or other materials provided
+ *         with the distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ *
+ * REGARDLESS OF WHAT LICENSING MECHANISM IS USED OR APPLICABLE,
+ * THIS PROGRAM IS PROVIDED BY QLOGIC CORPORATION "AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * USER ACKNOWLEDGES AND AGREES THAT USE OF THIS PROGRAM WILL NOT CREATE
+ * OR GIVE GROUNDS FOR A LICENSE BY IMPLICATION, ESTOPPEL, OR OTHERWISE
+ * IN ANY INTELLECTUAL PROPERTY RIGHTS (PATENT, COPYRIGHT, TRADE SECRET,
+ * MASK WORK, OR OTHER PROPRIETARY RIGHT) EMBODIED IN ANY OTHER QLOGIC
+ * HARDWARE OR SOFTWARE EITHER SOLELY OR IN COMBINATION WITH THIS PROGRAM
+ *
+ ******************************************************************************
+ *             Please see release.txt for revision history.                   *
+ *                                                                            *
+ ******************************************************************************
+ * Function Table of Contents:
+ *
+ ****************************************************************************/
+
+/*
+ * Driver debug definitions.
+ */
+#define QLP1    0x00000002  // Unrecoverable error messages
+#define QLP2    0x00000004  // Unexpected completion path error messages
+#define QLP3    0x00000008  // Function trace messages
+#define QLP4    0x00000010  // IOCTL trace messages
+#define QLP5    0x00000020  // I/O & Request/Response queue trace messages
+#define QLP6    0x00000040  // Watchdog messages (current state)
+#define QLP7    0x00000080  // Initialization
+#define QLP8    0x00000100  // Internal command queue traces
+#define QLP9    0x00000200  // Unused
+#define QLP10   0x00000400  // Extra Debug messages (dump buffers)
+#define QLP11   0x00000800  // Mailbox & ISR Details
+#define QLP12   0x00001000  // Enter/Leave routine messages
+#define QLP13   0x00002000  // Display data for Inquiry, TUR, ReqSense, RptLuns
+#define QLP14   0x00004000  // Temporary
+#define QLP15   0x00008000  // Display jiffies for IOCTL calls
+#define QLP16   0x00010000  // Extended proc print statements (srb info)
+#define QLP17   0x00020000  // Display NVRAM Accesses
+#define QLP18   0x00040000  // unused
+#define QLP19	0x00080000  // PDU info
+#define QLP20   0x00100000  // iSNS info
+#define QLP24   0x01000000  // Scatter/Gather info
+
+extern uint32_t ql_dbg_level;
+
+/*
+ *  Debug Print Routine Prototypes.
+ */
+#define QL4PRINT(m,x) do {if(((m) & ql_dbg_level) != 0) (x);} while(0);
+#define ENTER(x) do {QL4PRINT(QLP12, printk("qla4xxx: Entering %s()\n", x));} while(0);
+#define LEAVE(x) do {QL4PRINT(QLP12, printk("qla4xxx: Leaving  %s()\n", x));} while(0);
+
+uint8_t qla4xxx_get_debug_level(uint32_t *dbg_level);
+uint8_t qla4xxx_set_debug_level(uint32_t dbg_level);
+
+void     qla4xxx_dump_bytes(uint32_t, void *, uint32_t);
+void     qla4xxx_dump_words(uint32_t, void *, uint32_t);
+void     qla4xxx_dump_dwords(uint32_t, void *, uint32_t);
+void     qla4xxx_print_scsi_cmd(uint32_t dbg_mask, struct scsi_cmnd *cmd);
+void     qla4xxx_print_srb_info(uint32_t dbg_mask, srb_t *srb);
+
+/*
+ * Driver debug definitions.
+ */
+/* #define QL_DEBUG_LEVEL_1  */	/* Output register accesses to COM1 */
+
+/* #define QL_DEBUG_LEVEL_3  */	/* Output function trace msgs to COM1 */
+/* #define QL_DEBUG_LEVEL_4  */	
+/* #define QL_DEBUG_LEVEL_5  */	
+/* #define QL_DEBUG_LEVEL_9  */	
+
+ #define QL_DEBUG_LEVEL_2   /* Output error msgs to COM1 */
+
+#define DEBUG(x)	do {} while (0);
+
+#if defined(QL_DEBUG_LEVEL_2)
+#define DEBUG2(x)      do {if(extended_error_logging == 2) x;} while (0);
+#define DEBUG2_3(x)   do {x;} while (0);
+#else
+#define DEBUG2(x)	do {} while (0);
+#endif
+
+#if defined(QL_DEBUG_LEVEL_3)
+#define DEBUG3(x)	do {x;} while (0);
+#else
+#define DEBUG3(x)	do {} while (0);
+  #if !defined(QL_DEBUG_LEVEL_2)
+  #define DEBUG2_3(x)	do {} while (0);
+  #endif
+#endif
+#if defined(QL_DEBUG_LEVEL_4)
+#define DEBUG4(x)	do {x;} while (0);
+#else
+#define DEBUG4(x)	do {} while (0);
+#endif
+
+#if defined(QL_DEBUG_LEVEL_5)
+#define DEBUG5(x)	do {x;} while (0);
+#else
+#define DEBUG5(x)	do {} while (0);
+#endif
+
+#if defined(QL_DEBUG_LEVEL_9)
+#define DEBUG9(x)	do {x;} while (0);
+#else
+#define DEBUG9(x)	do {} while (0);
+#endif
+
+void     __dump_dwords(void *, uint32_t);
+void     __dump_words(void *, uint32_t);
+void     __dump_mailbox_registers(uint32_t, scsi_qla_host_t *ha);
+void     __dump_registers(uint32_t, scsi_qla_host_t *ha);
+void     qla4xxx_dump_registers(uint32_t, scsi_qla_host_t *ha);
+
+/*
+ * Overrides for Emacs so that we almost follow Linus's tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 2
+ * c-brace-imaginary-offset: 0
+ * c-brace-offset: -2
+ * c-argdecl-indent: 2
+ * c-label-offset: -2
+ * c-continued-statement-offset: 2
+ * c-continued-brace-offset: 0
+ * indent-tabs-mode: nil
+ * tab-width: 8
+ * End:
+ */
+
diff --git a/drivers/scsi/qla4xxx/ql4_def.h b/drivers/scsi/qla4xxx/ql4_def.h
new file mode 100644
index 0000000..0e59a97
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_def.h
@@ -0,0 +1,1013 @@
+/******************************************************************************
+ *     Copyright (C)  2003 -2005 QLogic Corporation
+ * QLogic ISP4xxx Device Driver
+ *
+ * This program includes a device driver for Linux 2.6.x that may be
+ * distributed with QLogic hardware specific firmware binary file.
+ * You may modify and redistribute the device driver code under the
+ * GNU General Public License as published by the Free Software Foundation
+ * (version 2 or a later version) and/or under the following terms,
+ * as applicable:
+ *
+ * 	1. Redistribution of source code must retain the above copyright
+ *         notice, this list of conditions and the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above copyright
+ *         notice, this list of conditions and the following disclaimer in
+ *         the documentation and/or other materials provided with the
+ *         distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ * 	
+ * You may redistribute the hardware specific firmware binary file under
+ * the following terms:
+ * 	1. Redistribution of source code (only if applicable), must
+ *         retain the above copyright notice, this list of conditions and
+ *         the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above
+ *         copyright notice, this list of conditions and the following
+ *         disclaimer in the documentation and/or other materials provided
+ *         with the distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ *
+ * REGARDLESS OF WHAT LICENSING MECHANISM IS USED OR APPLICABLE,
+ * THIS PROGRAM IS PROVIDED BY QLOGIC CORPORATION "AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * USER ACKNOWLEDGES AND AGREES THAT USE OF THIS PROGRAM WILL NOT CREATE
+ * OR GIVE GROUNDS FOR A LICENSE BY IMPLICATION, ESTOPPEL, OR OTHERWISE
+ * IN ANY INTELLECTUAL PROPERTY RIGHTS (PATENT, COPYRIGHT, TRADE SECRET,
+ * MASK WORK, OR OTHER PROPRIETARY RIGHT) EMBODIED IN ANY OTHER QLOGIC
+ * HARDWARE OR SOFTWARE EITHER SOLELY OR IN COMBINATION WITH THIS PROGRAM
+ *
+ ******************************************************************************/
+
+#ifndef __QL4_DEF_H
+#define __QL4_DEF_H
+
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/pci.h>
+#include <linux/dma-mapping.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/dmapool.h>
+#include <linux/mempool.h>
+#include <linux/spinlock.h>
+#include <linux/completion.h>
+#include <asm/semaphore.h>
+
+#include <scsi/scsi.h>
+#include <scsi/scsi_host.h>
+#include <scsi/scsi_device.h>
+#include <scsi/scsi_cmnd.h>
+
+/* XXX(dg): move to pci_ids.h */
+#ifndef PCI_DEVICE_ID_QLOGIC_ISP4010
+#define PCI_DEVICE_ID_QLOGIC_ISP4010	0x4010
+#endif
+
+#ifndef PCI_DEVICE_ID_QLOGIC_ISP4022
+#define PCI_DEVICE_ID_QLOGIC_ISP4022	0x4022
+#endif
+
+#define IS_QLA4010(ha)	((ha)->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP4010)
+#define IS_QLA4022(ha)	((ha)->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP4022)
+
+#if defined(CONFIG_COMPAT) && !defined(CONFIG_IA64)
+#define QLA_CONFIG_COMPAT
+#endif
+
+/*
+ * This file set some defines that are required to compile the
+ * command source for 4000 module
+ *----------------------------------------------------------------------------*/
+#define QLA4010
+#define QLA4XXX_BOARD_PORTS		1
+#define QLA4XXX_PROC_NAME		"qla4010"
+
+#define MEMORY_MAPPED_IO		1 /* 1=Memory Mapped (preferred),
+					   * 0=I/O Mapped */
+
+#define LINESIZE		256
+#define MIN(x,y)		((x)<(y)?(x):(y))
+#define MAX(x,y)		((x)>(y)?(x):(y))
+
+/*
+ * Return status codes for internal routines
+ ********************************************/
+#define QLA_SUCCESS			0
+#define QLA_ERROR			1
+
+/*
+ * Data bit definitions
+ */
+#define BIT_0	0x1
+#define BIT_1	0x2
+#define BIT_2	0x4
+#define BIT_3	0x8
+#define BIT_4	0x10
+#define BIT_5	0x20
+#define BIT_6	0x40
+#define BIT_7	0x80
+#define BIT_8	0x100
+#define BIT_9	0x200
+#define BIT_10	0x400
+#define BIT_11	0x800
+#define BIT_12	0x1000
+#define BIT_13	0x2000
+#define BIT_14	0x4000
+#define BIT_15	0x8000
+#define BIT_16	0x10000
+#define BIT_17	0x20000
+#define BIT_18	0x40000
+#define BIT_19	0x80000
+#define BIT_20	0x100000
+#define BIT_21	0x200000
+#define BIT_22	0x400000
+#define BIT_23	0x800000
+#define BIT_24	0x1000000
+#define BIT_25	0x2000000
+#define BIT_26	0x4000000
+#define BIT_27	0x8000000
+#define BIT_28	0x10000000
+#define BIT_29	0x20000000
+#define BIT_30	0x40000000
+#define BIT_31	0x80000000
+
+/*
+ * Host adapter default definitions
+ ***********************************/
+#define MAX_HBAS			16
+#define MAX_BUSES       		1
+#define MAX_TARGETS     		MAX_PRST_DEV_DB_ENTRIES + MAX_DEV_DB_ENTRIES
+#define MAX_LUNS        		256
+#define MAX_AEN_ENTRIES 		256 /* should be > EXT_DEF_MAX_AEN_QUEUE */
+#define MAX_DDB_ENTRIES 		MAX_PRST_DEV_DB_ENTRIES + MAX_DEV_DB_ENTRIES
+#define MAX_PDU_ENTRIES                 32
+#define INVALID_ENTRY			0xFFFF
+#define MAX_CMDS_TO_RISC		1024
+#define MAX_SRBS			MAX_CMDS_TO_RISC
+#define MBOX_AEN_REG_COUNT		5
+#define MAX_INIT_RETRIES		5
+#define IOCB_HIWAT_CUSHION		16
+
+/*
+ * Buffer sizes
+ ***************/
+#define REQUEST_QUEUE_DEPTH       	MAX_CMDS_TO_RISC
+#define RESPONSE_QUEUE_DEPTH      	64
+#define QUEUE_SIZE			64
+#define DMA_BUFFER_SIZE 		512
+
+/*
+ * Misc
+ *******/
+#define MAC_ADDR_LEN			6 /* in bytes */
+#define IP_ADDR_LEN			4 /* in bytes */
+#define DRIVER_NAME			"qla4xxx"
+
+#define MAX_LINKED_CMDS_PER_LUN		3
+#define MAX_REQS_SERVICED_PER_INTR	16
+
+
+/* Number of seconds to subtract for internal command timer */
+#define QLA_CMD_TIMER_DELTA             5
+
+
+#define	ISCSI_IPADDR_SIZE		4	/* IP address size */
+#define	ISCSI_ALIAS_SIZE		32	/* ISCSI Alais name size */
+#define	ISCSI_NAME_SIZE			255	/* ISCSI Name size  - usually a string */
+
+#define SYS_DELAY(x)		do {udelay(x);barrier();} while(0);
+#define QLA4XXX_DELAY(sec)  	do {mdelay(sec * 1000);} while(0);
+#define NVRAM_DELAY() 		do {udelay(500);} while(0); /* 500 microsecond delay */
+
+/* delay 30 seconds */
+#define RESET_DELAY()		do {int delay; for(delay=30; delay!=0; delay--) \
+				{current->state = TASK_UNINTERRUPTIBLE; \
+				schedule_timeout(1 * HZ);}} while(0);
+
+#define TOPCAT_RESET_DELAY()	do {udelay(1);} while(0);
+#define TOPCAT_POST_RESET_DELAY() do {udelay(523);} while(0);
+
+
+#define LSB(x)	((uint8_t)(x))
+#define MSB(x)	((uint8_t)((uint16_t)(x) >> 8))
+#define LSW(x)	((uint16_t)(x))
+#define MSW(x)	((uint16_t)((uint32_t)(x) >> 16))
+#define LSDW(x)	((uint32_t)((uint64_t)(x)))
+#define MSDW(x)	((uint32_t)((((uint64_t)(x)) >> 16) >> 16))
+
+#define IPAddrIsZero( _X1_ )   ((_X1_)[0] == 0 && \
+                                (_X1_)[1] == 0 && \
+                                (_X1_)[2] == 0 && \
+                                (_X1_)[3] == 0)
+
+#define IPAddrIsEqual(_X1_, _X2_) ((_X1_)[0] == (_X2_)[0] && \
+                                   (_X1_)[1] == (_X2_)[1] && \
+                                   (_X1_)[2] == (_X2_)[2] && \
+                                   (_X1_)[3] == (_X2_)[3])
+
+#define IPAddr2Uint32(_X1_,_X2_) { \
+                                  *_X2_ = 0; \
+				  *_X2_ |= _X1_[3] << 24; \
+				  *_X2_ |= _X1_[2] << 16; \
+				  *_X2_ |= _X1_[1] << 8;  \
+				  *_X2_ |= _X1_[0];}
+
+/*
+ * I/O port access macros
+ *************************/
+#if MEMORY_MAPPED_IO
+#   define RD_REG_BYTE(addr)	     readb(addr)
+#   define RD_REG_WORD(addr)         readw(addr)
+#   define RD_REG_DWORD(addr)        readl(addr)
+#   define RD_REG_WORD_RELAXED(addr) 	readw_relaxed(addr)
+#   define RD_REG_DWORD_RELAXED(addr)	readl_relaxed(addr)
+#   define WRT_REG_BYTE(addr, data)  writeb(data, addr)
+#   define WRT_REG_WORD(addr, data)  writew(data, addr)
+#   define WRT_REG_DWORD(addr, data) writel(data, addr)
+#else
+#   define RD_REG_BYTE(addr)	     (inb((u_long)addr))
+#   define RD_REG_WORD(addr)         (inw((u_long)addr))
+#   define RD_REG_DWORD(addr)        (inl((u_long)addr))
+#   define WRT_REG_BYTE(addr, data)  (outb(data,(u_long)addr))
+#   define WRT_REG_WORD(addr, data)  (outw((data),(u_long)addr))
+#   define WRT_REG_DWORD(addr, data) (outl((data),(u_long)addr))
+#endif
+
+#define PCI_POSTING(a) (RD_REG_DWORD(a))
+
+#include "ql4_os.h"
+#include "ql4_fw.h"
+#include "ql4_nvram.h"
+
+/*---------------------------------------------------------------------------*/
+
+/*
+ * Retry & Timeout Values
+ *************************/
+#define MBOX_TOV			60
+#define SOFT_RESET_TOV			30
+#define RESET_INTR_TOV			3
+#define SEMAPHORE_TOV			10
+#define ADAPTER_INIT_TOV		120
+#define ADAPTER_RESET_TOV		180
+#define INTERNAL_PASSTHRU__TOV		60
+#define EXTEND_CMD_TOV			60
+#define WAIT_CMD_TOV			30
+#define EH_WAIT_CMD_TOV			120
+#define FIRMWARE_UP_TOV			60
+#define RESET_FIRMWARE_TOV        	30
+#define LOGOUT_TOV			10
+#define IOCB_TOV_MARGIN			10
+#define RELOGIN_TOV			18
+#define ISNS_DEREG_TOV			5
+#define MIN_CMD_TOV			25
+
+#define MAX_RESET_HA_RETRIES		2
+
+/*---------------------------------------------------------------------------*/
+/*
+ * SCSI Request Block structure  (srb)  that is placed
+ * on cmd->SCp location of every I/O     [We have 22 bytes available]
+ */
+typedef struct _srb_t {
+	struct list_head   list_entry;		/* (8)   */
+	struct scsi_qla_host *ha;	/* (4) HA the SP is queued on */
+
+	uint16_t     flags;		/* (2) Status flags. */
+	#define SRB_DMA_VALID		BIT_3	/* DMA Buffer mapped. */
+
+	#define SRB_GOT_SENSE		BIT_4	/* sense data recieved. */
+	#define SRB_IOCTL_CMD		BIT_5	/* generated from an IOCTL. */
+	#define SRB_BUSY		BIT_7	/* in busy retry state. */
+
+	#define SRB_RETRY		BIT_9	/* needs retrying. */
+	#define SRB_TAPE		BIT_10	/* FCP2 (Tape) command. */
+
+
+	uint8_t     state;		/* (1) Status flags. */
+	#define SRB_NO_QUEUE_STATE	 0	/* Request is in between states */
+	#define SRB_FREE_STATE		 1
+	#define SRB_PENDING_STATE	 2
+	#define SRB_ACTIVE_STATE	 3
+	#define SRB_ACTIVE_TIMEOUT_STATE 4
+	#define SRB_RETRY_STATE	 	 5
+	#define SRB_DONE_STATE	 	 6
+	#define SRB_SUSPENDED_STATE  	 7    /* Request in suspended state */
+
+	#define SRB_STATE_TBL()	  	  \
+	{	    			  \
+            "NO_QUEUE"	        	, \
+            "FREE"		        , \
+            "PENDING"	        	, \
+	    "ACTIVE"	        	, \
+	    "ACTIVE_TIMEOUT"        	, \
+	    "RETRY"	        	, \
+	    "DONE"	        	, \
+	    "SUSPENDED"	        	, \
+	    NULL			  \
+	}
+
+	uint8_t     entry_count;		/* (1) number of request queue
+						 *     entries used */
+	struct scsi_cmnd  *cmd;			/* (4) SCSI command block */
+	dma_addr_t  saved_dma_handle;		/* (4) for unmap of single transfers */
+	atomic_t    ref_count;		/* (4) reference count for this srb */
+	uint32_t    fw_ddb_index;	/* (4) */
+
+	/* Target/LUN queue pointers. */
+	struct os_tgt *tgt_queue;	/* (4) ptr to visible ha's target */
+	struct os_lun *lun_queue;	/* (4) ptr to visible ha's lun */
+	struct fc_lun *fclun;		/* (4) FC LUN context pointer. */
+	
+	/* Raw completion info for use by failover ? */
+	uint8_t rsvd1;
+	uint8_t err_id;			/* (1) error id */
+	#define SRB_ERR_PORT       1    /* Request failed because "port down" */
+	#define SRB_ERR_LOOP       2    /* Request failed because "loop down" */
+	#define SRB_ERR_DEVICE     3    /* Request failed because "device error" */
+	#define SRB_ERR_OTHER      4
+
+	uint16_t    rsvd2;		/* (2) */
+	uint32_t    lun;		/* (4) */
+	struct timer_list timer;	/* (32) used to timeout command */
+	uint16_t    os_tov;		/* (2) */
+	uint16_t    iocb_tov;           /* (2) */
+	uint16_t    iocb_cnt;		/* (2) Number of used iocbs */
+	uint16_t    cc_stat;            /* (2) */
+	u_long      r_start;	      	/* (4) Time we recieve a cmd from OS*/
+	u_long      u_start;	      	/* (4) Time when we handed the cmd to F/W */
+} srb_t;
+
+/*
+ * SCSI Target Queue structure
+ */
+typedef struct os_tgt {
+	struct os_lun		*olun[MAX_LUNS];	 /* LUN context pointer. */
+	struct scsi_qla_host	*ha;
+	uint32_t		down_timer;
+	struct fc_port		*fcport;		/* Current fcport for this target */
+	unsigned long		flags;
+	uint8_t			port_down_retry_count;
+	uint8_t			id;
+
+	/* Persistent binding information */
+	uint16_t		ddb_index;
+	uint8_t			iscsi_name[ISCSI_NAME_SIZE];
+	uint8_t			*name;
+} os_tgt_t;
+
+/*
+ * SCSI Target Queue flags
+ */
+#define TQF_ONLINE		0		/* Device online to OS. */
+#define TQF_SUSPENDED		1
+#define TQF_RETRY_CMDS		2
+
+/*
+ * LUN structure
+ */
+typedef struct os_lun {
+	struct fc_lun *fclun;		/* (4) FC LUN context pointer. */
+	struct list_head list_entry;	/* (8) For suspended lun list */
+	struct scsi_device *sdev;	/* (4) */
+	
+	spinlock_t lun_lock  ____cacheline_aligned; /* (4) For suspended lun list */
+	unsigned long flags;		/* 4 */
+	#define LF_LUN_DELAYED		0
+	#define LF_LUN_SUSPEND		1
+	#define LF_LUN_BLOCKED		2
+	#define LUN_MPIO_RESET_CNTS	3	/* Lun */
+
+	uint8_t lun_state;		/* (1) */
+	#define LS_LUN_READY		0   /* LUN is ready to accept commands */
+	#define LS_LUN_SUSPENDED	1   /* LUN is suspended */
+	#define LS_LUN_RETRY		2   /* LUN is retrying commands */
+	#define LS_LUN_TIMEOUT		3   /*  */
+	#define LUN_STATE_TBL()		  \
+	{				  \
+		"READY"			, \
+		"SUSPENDED"		, \
+		"RETRY"			, \
+		"TIMEOUT"		, \
+		NULL			  \
+	}
+
+	uint8_t out_count;		/* (1) Number of outstanding commands */
+	uint8_t lun;			/* (1) Lun number */
+
+	uint8_t retry_count;		/* (1) Number of times lun is suspended */
+	uint8_t max_retry_count;	/* (1) Max number of times lun can be */
+					/*        suspended before returning commands */
+	uint8_t reserved[3];		/* (3) */
+	uint32_t tot_io_count;		/* (4) Total num outstanding I/Os */
+	atomic_t suspend_timer;		/* (4) Timer for suspending lun */
+} os_lun_t;
+
+/* Never set this to Zero */
+#define SUSPEND_SECONDS	6		
+#define SUSPEND_RETRIES	1
+
+/* LUN BitMask structure definition, array of 32bit words,
+ * 1 bit per lun.  When bit == 1, the lun is masked.
+ * Most significant bit of mask[0] is lun 0, bit 24 is lun 7.
+ */
+typedef struct lun_bit_mask {
+	/* Must allocate at least enough bits to accomodate all LUNs */
+#if ((MAX_LUNS & 0x7) == 0)
+	UINT8   mask[MAX_LUNS >> 3];
+#else
+	uint8_t mask[(MAX_LUNS + 8) >> 3];
+#endif
+} lun_bit_mask_t;
+
+/*---------------------------------------------------------------------------*/
+
+/*
+ * Device Database (DDB) structure
+ */
+
+typedef struct ddb_entry {
+	struct list_head   list_entry;	/* 00 x00 */
+	uint16_t bus;			/* 08 x08 SCSI bus number */
+	uint16_t target;		/* 10 x0a SCSI target ID */
+	struct fc_port          *fcport;
+	uint16_t fw_ddb_index;		/* 12 x0c DDB index from firmware's DEV_DB structure */
+	uint16_t out_count;		/* 14 x0e Number of active commands */
+
+	uint8_t  num_valid_luns;	/* 16 x10 Number of valid luns */
+	uint8_t  reserved[3];		/* 17 x11 */
+
+	/* refer to MBOX_CMD_GET_DATABASE_ENTRY for fw_ddb_fw_ddb_device_state definitions   */
+	uint32_t fw_ddb_device_state;		/* 20 x14 Device State */
+	#define DDB_STATE_TBL(){	\
+                "UNASSIGNED",           \
+		"NO_CONNECTION_ACTIVE", \
+		"DISCOVERY",            \
+		"NO_SESSION_ACTIVE",    \
+		"SESSION_ACTIVE",       \
+		"LOGGING_OUT",          \
+		"SESSION_FAILED",       \
+		NULL                    \
+	}
+	uint32_t CmdSn;			/* 24 x18 */
+	uint16_t target_session_id;	/* 28 x1c */
+	uint16_t connection_id;		/* 30 x1e */
+	uint16_t exe_throttle;		/* 32 x20 Max mumber of cmds outstanding simultaneously */
+	uint16_t task_mgmt_timeout;		/* 34 x22 Min time for task mgmt cmds to complete */
+	uint16_t default_relogin_timeout; /* 36 x24 Max time to wait for relogin to complete */
+	uint16_t tcp_source_port_num;		/* 38 x26 */
+	uint32_t default_time2wait;		/* 40 x28 Default Min time between relogins (+aens) */
+	atomic_t port_down_timer;		/* 44 x2c Device down time */
+	atomic_t retry_relogin_timer;		/* 48 x30 Min Time between relogins (4000 only)*/
+	atomic_t relogin_timer;		/* 52 x34 Max Time to wait for relogin to complete */
+	atomic_t relogin_retry_count;		/* 56 x38 Num of times relogin has been retried */
+	atomic_t state;			/* 60 x3c Device State*/
+	#define DEV_STATE_DEAD		0 /* We can no longer talk to this device */
+	#define DEV_STATE_ONLINE	1 /* Device ready to accept commands */
+	#define DEV_STATE_MISSING	2 /* Device logged off, trying to re-login */
+	#define DEV_STATE_TBL(){	  \
+		"DEAD"			, \
+		"ONLINE"		, \
+		"MISSING"		, \
+		NULL			  \
+	}
+	unsigned long flags;			/* 64 x40 */
+	#define DF_RELOGIN		0  /* Relogin to device */
+	#define DF_NO_RELOGIN		1  /* Do not relogin if IOCTL logged it out */
+	#define DF_ISNS_DISCOVERED	2  /* Device was discovered via iSNS */
+
+	unsigned long dev_scan_wait_to_start_relogin;
+	unsigned long dev_scan_wait_to_complete_relogin;
+
+	uint8_t  ip_addr[ISCSI_IPADDR_SIZE];
+	uint8_t  iscsi_name[ISCSI_NAME_SIZE];	 /* 72 x48 */
+} ddb_entry_t;				 /*840 x348 */
+
+/*
+ * Fibre channel port type.
+ */
+typedef enum {
+	FCT_UNKNOWN,
+	FCT_RSCN,
+	FCT_SWITCH,
+	FCT_BROADCAST,
+	FCT_INITIATOR,
+	FCT_TARGET
+} fc_port_type_t;
+
+/*
+ * Fibre channel port structure.
+ */
+typedef struct fc_port {
+	struct list_head list;
+	struct list_head fcluns;
+
+	struct scsi_qla_host *ha;
+	struct scsi_qla_host *vis_ha;	/* only used when suspending lun */
+	ddb_entry_t     *ddbptr;
+
+	uint8_t  *iscsi_name;
+	fc_port_type_t port_type;
+
+	atomic_t state;
+	uint32_t flags;
+
+	os_tgt_t *tgt_queue;
+	uint16_t os_target_id;
+	uint8_t device_type;
+	uint8_t unused;
+
+	uint8_t mp_byte;		/* multi-path byte (not used) */
+	uint8_t cur_path;		/* current path id */
+
+	lun_bit_mask_t lun_mask;
+	int loop_id;
+} fc_port_t;
+
+
+/*
+ * Fibre channel port/lun states.
+ */
+#define FCS_UNCONFIGURED	1
+#define FCS_DEVICE_DEAD		2
+#define FCS_DEVICE_LOST		3
+#define FCS_ONLINE		4
+#define FCS_NOT_SUPPORTED	5
+#define FCS_FAILOVER		6
+#define FCS_FAILOVER_FAILED	7
+
+/*
+ * FC port flags.
+ */
+#define FCF_FABRIC_DEVICE	BIT_0
+#define	FCF_INITIATOR_DEVICE	BIT_1
+#define FCF_FO_MASKED		BIT_2
+#define FCF_FAILOVER_NEEDED	BIT_3
+#define FCF_RESET_NEEDED	BIT_4
+#define FCF_PERSISTENT_BOUND	BIT_5
+#define FCF_TAPE_PRESENT	BIT_6
+#define FCF_XP_DEVICE            BIT_7
+#define FCF_CONFIG_DEVICE        BIT_8
+#define FCF_MSA_DEVICE            BIT_9
+#define FCF_MSA_PORT_ACTIVE     BIT_10
+#define FCF_LOGIN_NEEDED		BIT_12
+#define FCF_EVA_DEVICE            BIT_13
+
+#define FCF_RLC_SUPPORT		BIT_14
+#define FCF_CONFIG		BIT_15	/* Needed? */
+#define FCF_RESCAN_NEEDED	BIT_16
+#define FCF_FAILBACK_DISABLE	BIT_17
+#define FCF_FAILOVER_DISABLE	BIT_18
+
+#define	FCF_VSA			BIT_19
+#define	FCF_HD_DEVICE		BIT_20
+#define FCF_NONFO_DEVICE	BIT_21	/* Non Failover device */
+
+
+/*
+ * Fibre channel LUN structure.
+ */
+typedef struct fc_lun {
+	struct list_head list;
+
+	fc_port_t *fcport;
+	atomic_t state;
+	uint16_t lun;
+	uint8_t device_type;
+	uint8_t flags;
+	#define	FLF_VISIBLE_LUN		BIT_0
+	#define	FLF_ACTIVE_LUN		BIT_1
+
+	uint8_t lun_state;		/* 00 x00 */
+	uint8_t resvd[3];
+	#define LS_LUN_RESET_MARKER_NEEDED 4   /* LUN Reset marker needed */
+
+} fc_lun_t, lun_entry_t;
+
+
+/*---------------------------------------------------------------------------*/
+
+/*
+ * Asynchronous Event Queue structure
+ */
+typedef struct {
+	uint32_t mbox_sts[MBOX_AEN_REG_COUNT];
+}aen_t;
+
+
+/*
+ * NOTE: This structure definition really belongs in the ql4isns.h file,
+ *       but it's easier to compile when the structure is defined here.
+ */
+typedef struct _ATTRIBUTE_LIST {
+	uint32_t isns_tag;
+	#define ISNS_ATTR_TYPE_EMPTY      1   /* Used for delimiter attr. & operating attr. for query. */
+	#define ISNS_ATTR_TYPE_STRING     2   /* UTF-8 encoded string */
+	#define ISNS_ATTR_TYPE_ULONG      3
+	#define ISNS_ATTR_TYPE_ADDRESS    4   /* 128-bit IPv6 */
+	uint32_t type;
+	unsigned long data;
+} ATTRIBUTE_LIST;
+
+/*
+ * Linux Host Adapter structure
+ */
+typedef struct scsi_qla_host {
+	struct list_head list;
+
+	/* Linux adapter configuration data */
+	struct Scsi_Host *host;		    /* pointer to host data */
+	struct scsi_qla_host *next;
+
+	uint32_t        tot_ddbs;
+
+	unsigned long   flags;
+	#define AF_ONLINE		      0 /* 0x00000001 */
+	#define AF_INIT_DONE		      1 /* 0x00000002 */
+	#define AF_MBOX_COMMAND 	      2 /* 0x00000004 */
+	#define AF_MBOX_COMMAND_DONE 	      3 /* 0x00000008 */
+	#define AF_DPC_SCHEDULED	      5 /* 0x00000020 */
+	#define AF_INTERRUPTS_ON	      6 /* 0x00000040 Not Used */
+	#define AF_GET_CRASH_RECORD	      7 /* 0x00000080 */
+	#define AF_LINK_UP		      8 /* 0x00000100 */
+	#define AF_TOPCAT_CHIP_PRESENT	      9 /* 0x00000200 */
+	#define AF_IRQ_ATTACHED	      	     10 /* 0x00000400 */
+	#define AF_64BIT_PCI_ADDR	     11 /* 0x00000800 */
+	#define AF_MSI_ENABLED	     	     13 /* 0x00002000 */
+
+	unsigned long   dpc_flags;
+	#define DPC_RESET_HA		      1 /* 0x00000002 */
+	#define DPC_RETRY_RESET_HA	      2 /* 0x00000004 */
+	#define DPC_RELOGIN_DEVICE	      3 /* 0x00000008 */
+	#define DPC_RESET_HA_DESTROY_DDB_LIST 4 /* 0x00000010 */
+	#define DPC_RESET_HA_INTR	      5 /* 0x00000020 */
+	#define DPC_IOCTL_ERROR_RECOVERY      6 /* 0x00000040 */
+	#define DPC_ISNS_RESTART	      7 /* 0x00000080 */
+	#define DPC_ISNS_RESTART_COMPLETION   8 /* 0x00000100 */
+	#define DPC_AEN			      9 /* 0x00000200 */
+
+	#define DPC_WAIT_TO_RELOGIN_DEVICE   13 /* 0x00002000 */
+	#define DPC_CHECK_LUN		     14 /* 0x00004000 */
+	#define DPC_GET_DHCP_IP_ADDR	     15 /* 0x00008000 */
+	#define DPC_RESET_NIC_TEST	     17 /* 0x00020000 */
+
+	uint16_t        iocb_cnt;
+	uint16_t        iocb_hiwat;
+	uint16_t        req_q_count;	/* Number of available request queue entries. */
+	uint16_t        resvd;
+
+	u_long          i_start;	/* jiffies at start of IOCTL */
+	u_long          i_end;		/* jiffies at end of IOCTL */
+	u_long          f_start;	/* jiffies at sending cmd to f/w */
+	u_long          f_end;		/* jiffies at receiving cmd from f/w */
+
+	/* pci information */
+	struct pci_dev  *pdev;
+	struct qla_board_info *brd_info;
+	unsigned long   pci_resource_flags;
+
+	uint8_t         marker_needed;
+	uint8_t         rsvd1;
+
+	/* adapter instance w.r.t. all scsi hosts in OS */
+	uint16_t        host_no;
+
+	/* adapter instance w.r.t. this driver */
+	uint16_t        instance;
+
+	uint16_t        resvd2;
+
+	void            *virt_mmapbase;
+
+	uint32_t        function_number;
+
+	/* ISP registers, Base Memory-mapped I/O address */
+	isp_reg_t       *reg;
+
+	/* temp only */
+	unsigned long io_addr;
+	unsigned long mem_addr;
+	unsigned long io_len;
+	unsigned long mem_len;
+	unsigned int irq;		 /* IRQ for adapter            */
+
+	uint8_t		driver_verstr[80];
+	uint8_t		driver_version[4];
+
+	/* NVRAM registers */
+	eeprom_data_t     *nvram;
+
+	/* Counters for general statistics */
+	uint64_t        adapter_error_count;
+	uint64_t        device_error_count;
+	uint64_t        total_io_count;
+	uint64_t        total_mbytes_xferred;
+	uint64_t        isr_count;	    /* Interrupt count */
+	uint64_t        link_failure_count;
+	uint64_t        invalid_crc_count;
+
+	uint32_t        spurious_int_count;
+	uint32_t        aborted_io_count;
+	uint32_t        io_timeout_count;
+	uint32_t        mailbox_timeout_count;
+	uint32_t        seconds_since_last_intr;
+	uint32_t        seconds_since_last_heartbeat;
+	uint32_t        mac_index;
+
+	/* Info Initialized at init time */
+	/* --- From GetFwVersion --- */
+	uint32_t        firmware_version[2];
+	uint32_t        patch_number;
+	uint32_t        build_number;
+	/* --- From Init_FW --- */
+	uint16_t        firmware_options;
+	uint16_t        tcp_options;
+	uint8_t         ip_address[IP_ADDR_LEN];
+	uint8_t         subnet_mask[IP_ADDR_LEN];
+	uint8_t         gateway[IP_ADDR_LEN];
+	uint8_t         isns_ip_address[IP_ADDR_LEN];
+	uint16_t        isns_server_port_number;
+	uint16_t        resvd7;
+	uint8_t         alias[32];
+	uint8_t         name_string[256];
+	uint8_t         heartbeat_interval;
+	uint8_t         rsvd;
+	/* --- From FlashSysInfo --- */
+	uint8_t         my_mac[MAC_ADDR_LEN];
+	uint8_t         serial_number[16];
+	/* --- From GetFwState --- */
+	uint32_t        firmware_state;
+	uint32_t        board_id;
+	uint32_t        addl_fw_state;
+
+	/* iSNS information */
+	unsigned long   isns_flags;
+	#define ISNS_FLAG_ISNS_ENABLED_IN_ISP   0  /* 0x00000001 */
+	#define ISNS_FLAG_ISNS_SRV_ENABLED   	1  /* 0x00000002 */
+	#define ISNS_FLAG_ISNS_SRV_REGISTERED   2  /* 0x00000004 */
+	#define ISNS_FLAG_ISNS_SCN_REGISTERED   4  /* 0x00000010 */
+	#define ISNS_FLAG_QUERY_SINGLE_OBJECT   5  /* 0x00000020 */
+	#define ISNS_FLAG_SCN_IN_PROGRESS       6  /* 0x00000040 */
+	#define ISNS_FLAG_SCN_RESTART           7  /* 0x00000080 */
+	#define ISNS_FLAG_DEV_SCAN_DONE         27 /* 0x08000000 */
+	#define ISNS_FLAG_REREGISTER            28 /* 0x10000000 */
+	#define ISNS_FLAG_RESTART_SERVICE       31 /* 0x80000000 */
+
+	uint16_t        isns_connection_id;
+	uint16_t        isns_scn_conn_id;
+	uint16_t        isns_esi_conn_id;
+	uint16_t        isns_nsh_conn_id;
+	uint16_t        isns_remote_port_num;
+	uint16_t        isns_scn_port_num;
+	uint16_t        isns_esi_port_num;
+	uint16_t        isns_nsh_port_num;
+	uint8_t         isns_entity_id[256];
+
+	atomic_t        isns_restart_timer;
+	uint16_t        isns_transaction_id;
+	uint16_t        isns_num_discovered_targets;
+
+	ATTRIBUTE_LIST  isns_reg_attr_list[13];
+	ATTRIBUTE_LIST  isns_dereg_attr_list[7];
+	ATTRIBUTE_LIST  isns_scn_reg_attr_list[5];
+	ATTRIBUTE_LIST  isns_scn_dereg_attr_list[3];
+	ATTRIBUTE_LIST  isns_dev_get_next_attr_list[5];
+	ATTRIBUTE_LIST  isns_dev_attr_qry_attr_list[13];
+
+	/* Linux kernel thread */
+	pid_t                   dpc_pid;
+	int                     dpc_should_die;
+	struct completion       dpc_inited;
+	struct completion       dpc_exited;
+	struct semaphore        *dpc_wait;
+	uint8_t dpc_active;		     /* DPC routine is active */
+	uint8_t resvd3[3];
+
+	/* Linux timer thread */
+	struct timer_list timer;
+	uint32_t        timer_active;
+
+	/* Recovery Timers */
+	uint32_t        port_down_retry_count;
+	uint32_t        discovery_wait;
+	atomic_t        check_relogin_timeouts;
+	uint32_t        retry_reset_ha_cnt;
+	uint32_t        isp_reset_timer;	 /* reset test timer */
+	uint32_t        nic_reset_timer;	 /* simulated nic reset test timer */
+	uint32_t        eh_display_timer;	 /* simulated nic reset test timer */
+
+	int             eh_start;		/* To wake up the mid layer error
+						 * handler thread */
+
+	/* This spinlock must be held with irqs disabled in order to access
+	 * the pending, retry and free srb queues.
+	 *
+	 * The list_lock spinlock is of lower priority than the io_request
+	 * lock.
+	 *-------------------------------------------------------------------*/
+	spinlock_t      list_lock  ____cacheline_aligned;
+
+	/* internal srb queues */
+	struct          list_head retry_srb_q;	      /* retry queue request list */
+	uint32_t        retry_srb_q_count;
+
+	struct          list_head free_srb_q;
+	uint16_t        free_srb_q_count;
+	uint16_t        num_srbs_allocated;
+
+	/* Done queue
+	 * In order to avoid deadlocks with the list_lock,
+	 * place all srbs to be returned to OS on this list.
+	 * After the list_lock is released, return all of
+	 * these commands to the OS */
+
+	struct list_head done_srb_q;
+	uint32_t         done_srb_q_count;
+
+	/* This spinlock is used to protect "io transactions", you must	
+	 * aquire it before doing any IO to the card, eg with RD_REG*() and
+	 * WRT_REG*() for the duration of your entire command transaction.
+	 * It is also used to protect the active_srb_array.
+	 *
+	 * The hardware_lock spinlock is of lower priority than the
+	 * io request lock.
+	 *-------------------------------------------------------------------*/
+	spinlock_t         hardware_lock  ____cacheline_aligned;
+
+	/* Active array */
+	srb_t           *active_srb_array[MAX_SRBS];
+	uint16_t        active_srb_count;
+	uint16_t        current_active_index;
+
+	int             mem_err;
+
+	/* DMA Memory Block */
+	void            *queues;
+	dma_addr_t      queues_dma;
+	unsigned long   queues_len;
+#define MEM_ALIGN_VALUE	\
+	((MAX(REQUEST_QUEUE_DEPTH, RESPONSE_QUEUE_DEPTH)) * \
+	 sizeof(QUEUE_ENTRY))
+
+	/* request and response queue variables */
+	dma_addr_t      request_dma;
+	QUEUE_ENTRY     *request_ring;
+	QUEUE_ENTRY     *request_ptr;
+
+	dma_addr_t      response_dma;
+	QUEUE_ENTRY     *response_ring;
+	QUEUE_ENTRY     *response_ptr;
+
+	dma_addr_t      shadow_regs_dma;
+	shadow_regs_t   *shadow_regs;
+
+	uint16_t        request_in;		/* Current indexes. */
+	uint16_t        request_out;
+	uint16_t        response_in;
+	uint16_t        response_out;
+
+	/* aen queue variables */
+	uint32_t	aen_reg_mask;
+	uint16_t        aen_report;	/* Number of aens reported to SDMAPI */
+	uint16_t        aen_count;	/* Total number of aens received */
+	uint16_t        aen_in;		/* Current indexes */
+	uint16_t        aen_out;
+	aen_t           aen_q[MAX_AEN_ENTRIES];
+
+	/* pdu variables */
+	uint16_t        pdu_count;		/* Number of available aen_q entries */
+	uint16_t        pdu_in;		/* Current indexes */
+	uint16_t        pdu_out;
+
+	uint16_t        pdu_active;
+	PDU_ENTRY       *free_pdu_top;
+	PDU_ENTRY       *free_pdu_bottom;
+	PDU_ENTRY       pdu_queue[MAX_PDU_ENTRIES];
+
+	/* This semaphore protects several threads to do mailbox commands
+	 * concurrently.
+	 *-------------------------------------------------------------------*/
+	struct semaphore  mbox_sem;
+	wait_queue_head_t mailbox_wait_queue;
+
+	/* temporary mailbox status registers */
+	volatile uint8_t  mbox_status_count;
+	uint8_t resvd5[3];
+	volatile uint32_t mbox_status[MBOX_REG_COUNT];
+
+	ISNS_DISCOVERED_TARGET *isns_disc_tgt_databasev;
+	dma_addr_t      isns_disc_tgt_databasep;
+	uint32_t        isns_disc_tgt_database_size;
+
+	/* local device database list (contains internal ddb entries)*/
+	struct list_head ddb_list;
+	/* Fibre Channel Device List. */
+	struct list_head        fcports;
+
+	/* OS target queue pointers. */
+	os_tgt_t        *otgt[MAX_TARGETS+1];
+
+	/* Map ddb_list entry by FW ddb index */
+	ddb_entry_t     *fw_ddb_index_map[MAX_DDB_ENTRIES];
+
+	/*
+	 * There are several Scsi_Host members that are RHEL3 specific
+	 * yet depend on the SCSI_HAS_HOST_LOCK define for visibility.
+	 * Unfortuantely, it seems several RH kernels have the define
+	 * set, but do not have a host_lock member.
+	 *
+	 * Use the SH_HAS_HOST_LOCK define determined during driver
+	 * compilation rather than SCSI_HAS_HOST_LOCK.
+	 */
+
+	/* Scsi midlayer lock */
+	#if defined(SH_HAS_HOST_LOCK)
+	spinlock_t      host_lock ____cacheline_aligned;
+	#endif
+}scsi_qla_host_t;
+
+#define ADAPTER_UP(ha) ((test_bit(AF_ONLINE, &ha->flags) != 0) && (test_bit(AF_LINK_UP, &ha->flags) != 0))
+
+typedef struct {
+	uint8_t ha_mac[MAX_HBAS][MAC_ADDR_LEN];
+} mac_cfgs_t;
+
+/*
+ * Other macros
+ */
+#define TGT_Q(ha, t) (ha->otgt[t])
+#define LUN_Q(ha, t, l)	(TGT_Q(ha, t)->olun[l])
+#define GET_LU_Q(ha, t, l) ((TGT_Q(ha,t) != NULL)? TGT_Q(ha, t)->olun[l] : NULL)
+
+#define to_qla_host(x)		((scsi_qla_host_t *) (x)->hostdata)
+
+#define ql4_printk(level, ha, format, arg...) \
+	dev_printk(level , &((ha)->pdev->dev) , format , ## arg)
+
+
+/*---------------------------------------------------------------------------*/
+
+/* Defines for qla4xxx_initialize_adapter() and qla4xxx_recover_adapter() */
+#define PRESERVE_DDB_LIST	0
+#define REBUILD_DDB_LIST	1
+
+/* Defines for process_aen() */
+#define PROCESS_ALL_AENS	 0
+#define FLUSH_DDB_CHANGED_AENS	 1
+#define RELOGIN_DDB_CHANGED_AENS 2
+
+/* Defines for qla4xxx_take_hw_semaphore */
+#define NO_WAIT		0
+#define WAIT_FOREVER	1
+#define TIMED_WAIT	2
+
+
+#ifndef __QIM_DEF_H__
+#include "ql4_version.h"
+#include "ql4_settings.h"
+#include "ql4_glbl.h"
+#include "ql4_dbg.h"
+#include "ql4_inline.h"
+#include "ql4_listops.h"
+#include "ql4_isns.h"
+#endif
+
+#endif /*_QLA4XXX_H */
+
+/*
+ * Overrides for Emacs so that we get a uniform tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 4
+ * c-brace-imaginary-offset: 0
+ * c-brace-offset: -4
+ * c-argdecl-indent: 4
+ * c-label-offset: -4
+ * c-continued-statement-offset: 4
+ * c-continued-brace-offset: 0
+ * indent-tabs-mode: nil
+ * tab-width: 8
+ * End:
+ */
diff --git a/drivers/scsi/qla4xxx/ql4_fw.h b/drivers/scsi/qla4xxx/ql4_fw.h
new file mode 100644
index 0000000..52032d9
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_fw.h
@@ -0,0 +1,1752 @@
+/******************************************************************************
+ *     Copyright (C)  2003 -2005 QLogic Corporation
+ * QLogic ISP4xxx Device Driver
+ *
+ * This program includes a device driver for Linux 2.6.x that may be
+ * distributed with QLogic hardware specific firmware binary file.
+ * You may modify and redistribute the device driver code under the
+ * GNU General Public License as published by the Free Software Foundation
+ * (version 2 or a later version) and/or under the following terms,
+ * as applicable:
+ *
+ * 	1. Redistribution of source code must retain the above copyright
+ *         notice, this list of conditions and the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above copyright
+ *         notice, this list of conditions and the following disclaimer in
+ *         the documentation and/or other materials provided with the
+ *         distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ * 	
+ * You may redistribute the hardware specific firmware binary file under
+ * the following terms:
+ * 	1. Redistribution of source code (only if applicable), must
+ *         retain the above copyright notice, this list of conditions and
+ *         the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above
+ *         copyright notice, this list of conditions and the following
+ *         disclaimer in the documentation and/or other materials provided
+ *         with the distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ *
+ * REGARDLESS OF WHAT LICENSING MECHANISM IS USED OR APPLICABLE,
+ * THIS PROGRAM IS PROVIDED BY QLOGIC CORPORATION "AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * USER ACKNOWLEDGES AND AGREES THAT USE OF THIS PROGRAM WILL NOT CREATE
+ * OR GIVE GROUNDS FOR A LICENSE BY IMPLICATION, ESTOPPEL, OR OTHERWISE
+ * IN ANY INTELLECTUAL PROPERTY RIGHTS (PATENT, COPYRIGHT, TRADE SECRET,
+ * MASK WORK, OR OTHER PROPRIETARY RIGHT) EMBODIED IN ANY OTHER QLOGIC
+ * HARDWARE OR SOFTWARE EITHER SOLELY OR IN COMBINATION WITH THIS PROGRAM
+ *
+ ******************************************************************************
+ *
+ * This file defines mailbox structures and definitions for the QLA4xxx
+ *  iSCSI HBA firmware.
+ */
+
+#ifndef _QLA4X_FW_H
+#define _QLA4X_FW_H
+
+#ifndef INT8
+#define INT8 __s8
+#endif
+#ifndef INT16
+#define INT16 __s16
+#endif
+#ifndef INT32
+#define INT32 __s32
+#endif
+#ifndef UINT8
+#define UINT8 __u8
+#endif
+#ifndef UINT16
+#define UINT16 __u16
+#endif
+#ifndef UINT32
+#define UINT32 __u32
+#endif
+#ifndef UINT64
+#define UINT64 __u64
+#endif
+
+
+#define QLA4XXX_VENDOR_ID   	0x1077
+#define QLA4000_DEVICE_ID  	0x4000
+#define QLA4010_DEVICE_ID  	0x4010
+
+#define QLA4040_SSDID_NIC  	0x011D	/* Uses QLA4010 PCI Device ID */
+#define QLA4040_SSDID_ISCSI  	0x011E
+#define QLA4040C_SSDID_NIC  	0x011F
+#define QLA4040C_SSDID_ISCSI  	0x0120
+
+#define MAX_PRST_DEV_DB_ENTRIES         64
+#define MIN_DISC_DEV_DB_ENTRY           MAX_PRST_DEV_DB_ENTRIES
+#define MAX_DEV_DB_ENTRIES              512
+#define MAX_ISNS_DISCOVERED_TARGETS     MAX_DEV_DB_ENTRIES
+
+/* ISP Maximum number of DSD per command */
+#define DSD_MAX                                 1024
+
+/* FW check */
+#define FW_UP(reg,stat)                         (((stat = RD_REG_DWORD(reg->mailbox[0])) != 0) && (stat != 0x0007))
+
+#define INVALID_REGISTER 			((UINT32)-1)
+
+#define ISP4010_NET_FUNCTION                            0
+#define ISP4010_ISCSI_FUNCTION                          1
+
+
+/*************************************************************************
+ *
+ * 		ISP 4010 I/O Register Set Structure and Definitions
+ *
+ *************************************************************************/
+
+typedef struct _PORT_CTRL_STAT_REGS {
+	UINT32  ext_hw_conf;      		/*  80 x50  R/W	*/
+	UINT32  intChipConfiguration;	        /*  84 x54   *  */
+	UINT32  port_ctrl;		        /*  88 x58   *  */
+	UINT32  port_status;		        /*  92 x5c   *  */
+	UINT32  HostPrimMACHi;		        /*  96 x60   *  */
+	UINT32  HostPrimMACLow;		        /* 100 x64   *  */
+	UINT32  HostSecMACHi;		        /* 104 x68   *  */
+	UINT32  HostSecMACLow;		        /* 108 x6c   *  */
+	UINT32  EPPrimMACHi;		        /* 112 x70   *  */
+	UINT32  EPPrimMACLow;		        /* 116 x74   *  */
+	UINT32  EPSecMACHi;		        /* 120 x78   *  */
+	UINT32  EPSecMACLow;		        /* 124 x7c   *  */
+	UINT32  HostPrimIPHi;		        /* 128 x80   *  */
+	UINT32  HostPrimIPMidHi;	        /* 132 x84   *  */
+	UINT32  HostPrimIPMidLow;	        /* 136 x88   *  */
+	UINT32  HostPrimIPLow;		        /* 140 x8c   *  */
+	UINT32  HostSecIPHi;		        /* 144 x90   *  */
+	UINT32  HostSecIPMidHi;		        /* 148 x94   *  */
+	UINT32  HostSecIPMidLow;	        /* 152 x98   *  */
+	UINT32  HostSecIPLow;		        /* 156 x9c   *  */
+	UINT32  EPPrimIPHi;		        /* 160 xa0   *  */
+	UINT32  EPPrimIPMidHi;		        /* 164 xa4   *  */
+	UINT32  EPPrimIPMidLow;		        /* 168 xa8   *  */
+	UINT32  EPPrimIPLow;		        /* 172 xac   *  */
+	UINT32  EPSecIPHi;		        /* 176 xb0   *  */
+	UINT32  EPSecIPMidHi;		        /* 180 xb4   *  */
+	UINT32  EPSecIPMidLow;		        /* 184 xb8   *  */
+	UINT32  EPSecIPLow;		        /* 188 xbc   *  */
+	UINT32  IPReassemblyTimeout;	        /* 192 xc0   *  */
+	UINT32  EthMaxFramePayload;	        /* 196 xc4   *  */
+	UINT32  TCPMaxWindowSize;	        /* 200 xc8   *  */
+	UINT32  TCPCurrentTimestampHi;	        /* 204 xcc   *  */
+	UINT32  TCPCurrentTimestampLow;	        /* 208 xd0   *  */
+	UINT32  LocalRAMAddress;	        /* 212 xd4   *  */
+	UINT32  LocalRAMData;		        /* 216 xd8   *  */
+	UINT32  PCSReserved1;		        /* 220 xdc   *  */
+	UINT32  gp_out;	       			/* 224 xe0   *  */
+	UINT32  gp_in;	       			/* 228 xe4   *  */
+	UINT32  ProbeMuxAddr;		       	/* 232 xe8   *  */
+	UINT32  ProbeMuxData;		       	/* 236 xec   *  */
+	UINT32  ERMQueueBaseAddr0;	       	/* 240 xf0   *  */
+	UINT32  ERMQueueBaseAddr1;	       	/* 244 xf4   *  */
+	UINT32  MACConfiguration;	       	/* 248 xf8   *  */
+	UINT32  port_err_status;	       	/* 252 xfc  COR */
+} PORT_CTRL_STAT_REGS, *PPORT_CTRL_STAT_REGS;
+
+typedef struct _HOST_MEM_CFG_REGS {
+	UINT32  NetRequestQueueOut;	       	   /*  80 x50   *  */
+	UINT32  NetRequestQueueOutAddrHi;      	   /*  84 x54   *  */
+	UINT32  NetRequestQueueOutAddrLow;     	   /*  88 x58   *  */
+	UINT32  NetRequestQueueBaseAddrHi;     	   /*  92 x5c   *  */
+	UINT32  NetRequestQueueBaseAddrLow;    	   /*  96 x60   *  */
+	UINT32  NetRequestQueueLength;	       	   /* 100 x64   *  */
+	UINT32  NetResponseQueueIn;	       	   /* 104 x68   *  */
+	UINT32  NetResponseQueueInAddrHi;      	   /* 108 x6c   *  */
+	UINT32  NetResponseQueueInAddrLow;     	   /* 112 x70   *  */
+	UINT32  NetResponseQueueBaseAddrHi;    	   /* 116 x74   *  */
+	UINT32  NetResponseQueueBaseAddrLow;   	   /* 120 x78   *  */
+	UINT32  NetResponseQueueLength;	       	   /* 124 x7c   *  */
+	UINT32  req_q_out;	       	       	   /* 128 x80   *  */
+	UINT32  RequestQueueOutAddrHi;	       	   /* 132 x84   *  */
+	UINT32  RequestQueueOutAddrLow;	       	   /* 136 x88   *  */
+	UINT32  RequestQueueBaseAddrHi;	       	   /* 140 x8c   *  */
+	UINT32  RequestQueueBaseAddrLow;       	   /* 144 x90   *  */
+	UINT32  RequestQueueLength;	       	   /* 148 x94   *  */
+	UINT32  ResponseQueueIn;	       	   /* 152 x98   *  */
+	UINT32  ResponseQueueInAddrHi;	       	   /* 156 x9c   *  */
+	UINT32  ResponseQueueInAddrLow;	       	   /* 160 xa0   *  */
+	UINT32  ResponseQueueBaseAddrHi;       	   /* 164 xa4   *  */
+	UINT32  ResponseQueueBaseAddrLow;      	   /* 168 xa8   *  */
+	UINT32  ResponseQueueLength;	       	   /* 172 xac   *  */
+	UINT32  NetRxLargeBufferQueueOut;      	   /* 176 xb0   *  */
+	UINT32  NetRxLargeBufferQueueBaseAddrHi;   /* 180 xb4   *  */
+	UINT32  NetRxLargeBufferQueueBaseAddrLow;  /* 184 xb8   *  */
+	UINT32  NetRxLargeBufferQueueLength;   	   /* 188 xbc   *  */
+	UINT32  NetRxLargeBufferLength;	       	   /* 192 xc0   *  */
+	UINT32  NetRxSmallBufferQueueOut;      	   /* 196 xc4   *  */
+	UINT32  NetRxSmallBufferQueueBaseAddrHi;   /* 200 xc8   *  */
+	UINT32  NetRxSmallBufferQueueBaseAddrLow;  /* 204 xcc   *  */
+	UINT32  NetRxSmallBufferQueueLength;   	   /* 208 xd0   *  */
+	UINT32  NetRxSmallBufferLength;	       	   /* 212 xd4   *  */
+	UINT32  HMCReserved0[10];	       	   /* 216 xd8   *  */
+} HOST_MEM_CFG_REGS, *PHOST_MEM_CFG_REGS;
+
+typedef struct _LOCAL_RAM_CFG_REGS {
+	UINT32  BufletSize;		       	/*  80 x50   *  */
+	UINT32  BufletMaxCount;		       	/*  84 x54   *  */
+	UINT32  BufletCurrCount;	       	/*  88 x58   *  */
+	UINT32  BufletPauseThresholdCount;     	/*  92 x5c   *  */
+	UINT32  BufletTCPWinThresholdHi;       	/*  96 x60   *  */
+	UINT32  BufletTCPWinThresholdLow;      	/* 100 x64   *  */
+	UINT32  IPHashTableBaseAddr;	       	/* 104 x68   *  */
+	UINT32  IPHashTableSize;	       	/* 108 x6c   *  */
+	UINT32  TCPHashTableBaseAddr;	       	/* 112 x70   *  */
+	UINT32  TCPHashTableSize;	       	/* 116 x74   *  */
+	UINT32  NCBAreaBaseAddr;	       	/* 120 x78   *  */
+	UINT32  NCBMaxCount;		       	/* 124 x7c   *  */
+	UINT32  NCBCurrCount;		       	/* 128 x80   *  */
+	UINT32  DRBAreaBaseAddr;	       	/* 132 x84   *  */
+	UINT32  DRBMaxCount;		       	/* 136 x88   *  */
+	UINT32  DRBCurrCount;		       	/* 140 x8c   *  */
+	UINT32  LRCReserved[28];	       	/* 144 x90   *  */
+} LOCAL_RAM_CFG_REGS, *PLOCAL_RAM_CFG_REGS;
+
+typedef struct _PROT_STAT_REGS {
+	UINT32  MACTxFrameCount;	       /*  80 x50   R   */
+	UINT32  MACTxByteCount;		       /*  84 x54   R   */
+	UINT32  MACRxFrameCount;	       /*  88 x58   R   */
+	UINT32  MACRxByteCount;		       /*  92 x5c   R   */
+	UINT32  MACCRCErrCount;		       /*  96 x60   R   */
+	UINT32  MACEncErrCount;		       /* 100 x64   R   */
+	UINT32  MACRxLengthErrCount;	       /* 104 x68   R   */
+	UINT32  IPTxPacketCount;	       /* 108 x6c   R   */
+	UINT32  IPTxByteCount;		       /* 112 x70   R   */
+	UINT32  IPTxFragmentCount;	       /* 116 x74   R   */
+	UINT32  IPRxPacketCount;	       /* 120 x78   R   */
+	UINT32  IPRxByteCount;		       /* 124 x7c   R   */
+	UINT32  IPRxFragmentCount;	       /* 128 x80   R   */
+	UINT32  IPDatagramReassemblyCount;     /* 132 x84   R   */
+	UINT32  IPV6RxPacketCount;	       /* 136 x88   R   */
+	UINT32  IPErrPacketCount;	       /* 140 x8c   R   */
+	UINT32  IPReassemblyErrCount;	       /* 144 x90   R   */
+	UINT32  TCPTxSegmentCount;	       /* 148 x94   R   */
+	UINT32  TCPTxByteCount;		       /* 152 x98   R   */
+	UINT32  TCPRxSegmentCount;	       /* 156 x9c   R   */
+	UINT32  TCPRxByteCount;		       /* 160 xa0   R   */
+	UINT32  TCPTimerExpCount;	       /* 164 xa4   R   */
+	UINT32  TCPRxAckCount;		       /* 168 xa8   R   */
+	UINT32  TCPTxAckCount;		       /* 172 xac   R   */
+	UINT32  TCPRxErrOOOCount;	       /* 176 xb0   R   */
+	UINT32  PSReserved0;		       /* 180 xb4   *   */
+	UINT32  TCPRxWindowProbeUpdateCount;   /* 184 xb8   R   */
+	UINT32  ECCErrCorrectionCount;	       /* 188 xbc   R   */
+	UINT32  PSReserved1[16];	       /* 192 xc0   *   */
+} PROT_STAT_REGS, *PPROT_STAT_REGS;
+
+#define MBOX_REG_COUNT                          8
+
+/* remote register set (access via PCI memory read/write) */
+typedef struct isp_reg_t {
+	uint32_t mailbox[MBOX_REG_COUNT];
+
+	uint32_t flash_address;				/* 0x20 */
+	uint32_t flash_data;
+	uint32_t ctrl_status;
+
+	union {
+		struct {
+			uint32_t nvram;
+			uint32_t reserved1[2];		/* 0x30 */
+		} __attribute__((packed)) isp4010;
+		struct {
+			uint32_t intr_mask;
+			uint32_t nvram;			/* 0x30 */
+			uint32_t semaphore;
+		} __attribute__((packed)) isp4022;
+	} u1;
+
+	
+	uint32_t req_q_in;  /* SCSI Request Queue Producer Index */
+	uint32_t rsp_q_out; /* SCSI Completion Queue Consumer Index */
+
+	uint32_t reserved2[4];				/* 0x40 */
+
+	union {
+		struct {
+			uint32_t ext_hw_conf;		/* 0x50 */
+			uint32_t flow_ctrl;
+			uint32_t port_ctrl;
+			uint32_t port_status;
+
+			uint32_t reserved3[8];		/* 0x60 */
+
+			uint32_t req_q_out;		/* 0x80 */
+
+			uint32_t reserved4[23];		/* 0x84 */
+
+			uint32_t gp_out;		/* 0xe0 */
+			uint32_t gp_in;
+
+			uint32_t reserved5[5];
+
+			uint32_t port_err_status;	/* 0xfc */
+		} __attribute__((packed)) isp4010;
+		struct {
+			union {
+				PORT_CTRL_STAT_REGS p0;
+				HOST_MEM_CFG_REGS   p1;
+				LOCAL_RAM_CFG_REGS  p2;
+				PROT_STAT_REGS	    p3;
+				uint32_t  r_union[44];
+			};
+
+		} __attribute__((packed)) isp4022;
+	} u2;
+} isp_reg_t;	/* 256 x100 */
+
+#define ISP_SEMAPHORE(ha) \
+	(IS_QLA4022(ha) ? \
+	 &ha->reg->u1.isp4022.semaphore : \
+	 &ha->reg->u1.isp4010.nvram)
+
+#define ISP_NVRAM(ha) \
+	(IS_QLA4022(ha) ? \
+	 &ha->reg->u1.isp4022.nvram : \
+	 &ha->reg->u1.isp4010.nvram)
+
+#define ISP_EXT_HW_CONF(ha) \
+	(IS_QLA4022(ha) ? \
+	 &ha->reg->u2.isp4022.p0.ext_hw_conf : \
+	 &ha->reg->u2.isp4010.ext_hw_conf)
+
+#define ISP_PORT_STATUS(ha) \
+	(IS_QLA4022(ha) ? \
+	 &ha->reg->u2.isp4022.p0.port_status : \
+	 &ha->reg->u2.isp4010.port_status)
+
+#define ISP_PORT_CTRL(ha) \
+	(IS_QLA4022(ha) ? \
+	 &ha->reg->u2.isp4022.p0.port_ctrl : \
+	 &ha->reg->u2.isp4010.port_ctrl)
+
+#define ISP_REQ_Q_OUT(ha) \
+	(IS_QLA4022(ha) ? \
+	 &ha->reg->u2.isp4022.p1.req_q_out : \
+	 &ha->reg->u2.isp4010.req_q_out)
+
+#define ISP_PORT_ERROR_STATUS(ha) \
+	(IS_QLA4022(ha) ? \
+	 &ha->reg->u2.isp4022.p0.port_err_status : \
+	 &ha->reg->u2.isp4010.port_err_status)
+
+#define ISP_GP_OUT(ha) \
+	(IS_QLA4022(ha) ? \
+	 &ha->reg->u2.isp4022.p0.gp_out : \
+	 &ha->reg->u2.isp4010.gp_out)
+
+#define ISP_GP_IN(ha) \
+	(IS_QLA4022(ha) ? \
+	 &ha->reg->u2.isp4022.p0.gp_in : \
+	 &ha->reg->u2.isp4010.gp_in)
+
+/* Semaphore Defines for 4010 */
+#define QL4010_DRVR_SEM_BITS    0x00000030
+#define QL4010_GPIO_SEM_BITS    0x000000c0
+#define QL4010_SDRAM_SEM_BITS   0x00000300
+#define QL4010_PHY_SEM_BITS     0x00000c00
+#define QL4010_NVRAM_SEM_BITS   0x00003000
+#define QL4010_FLASH_SEM_BITS   0x0000c000
+
+#define QL4010_DRVR_SEM_MASK    0x00300000
+#define QL4010_GPIO_SEM_MASK    0x00c00000
+#define QL4010_SDRAM_SEM_MASK   0x03000000
+#define QL4010_PHY_SEM_MASK     0x0c000000
+#define	QL4010_NVRAM_SEM_MASK	0x30000000
+#define QL4010_FLASH_SEM_MASK   0xc0000000
+
+
+/* Semaphore Defines for 4022 */
+#define QL4022_RESOURCE_MASK_BASE_CODE 0x7
+#define QL4022_RESOURCE_BITS_BASE_CODE 0x4
+
+#define QL4022_DRVR_SEM_BITS    (QL4022_RESOURCE_BITS_BASE_CODE << 1)
+#define QL4022_DDR_RAM_SEM_BITS (QL4022_RESOURCE_BITS_BASE_CODE << 4)
+#define QL4022_PHY_GIO_SEM_BITS (QL4022_RESOURCE_BITS_BASE_CODE << 7)
+#define QL4022_NVRAM_SEM_BITS   (QL4022_RESOURCE_BITS_BASE_CODE << 10)
+#define QL4022_FLASH_SEM_BITS   (QL4022_RESOURCE_BITS_BASE_CODE << 13)
+
+#define QL4022_DRVR_SEM_MASK    (QL4022_RESOURCE_MASK_BASE_CODE << (1+16))
+#define QL4022_DDR_RAM_SEM_MASK (QL4022_RESOURCE_MASK_BASE_CODE << (4+16))
+#define QL4022_PHY_GIO_SEM_MASK (QL4022_RESOURCE_MASK_BASE_CODE << (7+16))
+#define QL4022_NVRAM_SEM_MASK   (QL4022_RESOURCE_MASK_BASE_CODE << (10+16))
+#define QL4022_FLASH_SEM_MASK   (QL4022_RESOURCE_MASK_BASE_CODE << (13+16))
+
+
+#define QL4XXX_LOCK_FLASH(a)    \
+	(IS_QLA4022(a) ? \
+    ql4xxx_sem_spinlock(a, QL4022_FLASH_SEM_MASK, (QL4022_RESOURCE_BITS_BASE_CODE | (a->mac_index)) << 13) : \
+    ql4xxx_sem_spinlock(a, QL4010_FLASH_SEM_MASK, QL4010_FLASH_SEM_BITS) )
+
+#define QL4XXX_LOCK_NVRAM(a)    \
+	(IS_QLA4022(a) ? \
+	ql4xxx_sem_spinlock(a, QL4022_NVRAM_SEM_MASK, (QL4022_RESOURCE_BITS_BASE_CODE | (a->mac_index)) << 10) : \
+	ql4xxx_sem_spinlock(a, QL4010_NVRAM_SEM_MASK, QL4010_NVRAM_SEM_BITS) )
+
+#define QL4XXX_LOCK_GIO(a) \
+	(IS_QLA4022(a) ? \
+	ql4xxx_sem_spinlock(a, QL4022_PHY_GIO_SEM_MASK, (QL4022_RESOURCE_BITS_BASE_CODE | (a->mac_index)) << 7) : \
+	ql4xxx_sem_spinlock(a, QL4010_GPIO_SEM_MASK, QL4010_GPIO_SEM_BITS) )
+
+#define QL4XXX_LOCK_PHY(a) \
+	(IS_QLA4022(a) ? \
+	ql4xxx_sem_spinlock(a, QL4022_PHY_GIO_SEM_MASK, (QL4022_RESOURCE_BITS_BASE_CODE | (a->mac_index)) << 7) : \
+	ql4xxx_sem_spinlock(a, QL4010_PHY_SEM_MASK, QL4010_PHY_SEM_BITS) )
+
+#define QL4XXX_LOCK_DDR_RAM(a)  \
+	(IS_QLA4022(a) ? \
+	ql4xxx_sem_spinlock(a, QL4022_DDR_RAM_SEM_MASK, (QL4022_RESOURCE_BITS_BASE_CODE | (a->mac_index)) << 4) : \
+	ql4xxx_sem_spinlock(a, QL4010_SDRAM_SEM_MASK, QL4010_SDRAM_SEM_BITS) )
+
+#define QL4XXX_LOCK_DRVR(a)  \
+	(IS_QLA4022(a) ? \
+	ql4xxx_sem_lock(a, QL4022_DRVR_SEM_MASK, (QL4022_RESOURCE_BITS_BASE_CODE | (a->mac_index)) << 1) : \
+	ql4xxx_sem_lock(a, QL4010_DRVR_SEM_MASK, QL4010_DRVR_SEM_BITS) )
+
+#define QL4XXX_UNLOCK_DRVR(a) \
+	(IS_QLA4022(a) ? \
+	ql4xxx_sem_unlock(a, QL4022_DRVR_SEM_MASK) : \
+	ql4xxx_sem_unlock(a, QL4010_DRVR_SEM_MASK) )
+
+#define QL4XXX_UNLOCK_GIO(a) \
+	(IS_QLA4022(a) ? \
+	ql4xxx_sem_unlock(a, QL4022_PHY_GIO_SEM_MASK) : \
+	ql4xxx_sem_unlock(a, QL4010_GPIO_SEM_MASK) )
+
+#define QL4XXX_UNLOCK_DDR_RAM(a)  \
+	(IS_QLA4022(a) ? \
+	ql4xxx_sem_unlock(a, QL4022_DDR_RAM_SEM_MASK) : \
+	ql4xxx_sem_unlock(a, QL4010_SDRAM_SEM_MASK) )
+
+#define QL4XXX_UNLOCK_PHY(a) \
+	(IS_QLA4022(a) ? \
+	ql4xxx_sem_unlock(a, QL4022_PHY_GIO_SEM_MASK) : \
+	ql4xxx_sem_unlock(a, QL4010_PHY_SEM_MASK) )
+
+#define QL4XXX_UNLOCK_NVRAM(a) \
+	(IS_QLA4022(a) ? \
+	ql4xxx_sem_unlock(a, QL4022_NVRAM_SEM_MASK) : \
+	ql4xxx_sem_unlock(a, QL4010_NVRAM_SEM_MASK) )
+
+#define QL4XXX_UNLOCK_FLASH(a)  \
+	(IS_QLA4022(a) ? \
+	ql4xxx_sem_unlock(a, QL4022_FLASH_SEM_MASK) : \
+	ql4xxx_sem_unlock(a, QL4010_FLASH_SEM_MASK) )
+
+
+#define QL4XXX_LOCK_DRVR_WAIT(a)                                                           \
+{																					   \
+    int i = 0;																			   \
+    while(1) {																		   \
+        if(QL4XXX_LOCK_DRVR(a) == 0) {										               \
+	    set_current_state(TASK_UNINTERRUPTIBLE); \
+	    schedule_timeout(10); \
+            if(!i) {																   \
+                DEBUG2(printk("scsi%d: %s: Waiting for Global Init Semaphore...\n",a->host_no,__func__)); \
+                i++;																   \
+            }																		   \
+        }																			   \
+        else {																		   \
+            DEBUG2(printk("scsi%d: %s: Global Init Semaphore acquired.\n",a->host_no,__func__));		   \
+            break;																	   \
+        }																			   \
+    }																				   \
+}
+/* Page # defines for 4022 */
+#define PORT_CTRL_STAT_PAGE                     0 /* 4022 */
+#define HOST_MEM_CFG_PAGE                       1 /* 4022 */
+#define LOCAL_RAM_CFG_PAGE                      2 /* 4022 */
+#define PROT_STAT_PAGE                          3 /* 4022 */
+
+/* Register Mask - sets corresponding mask bits in the upper word */
+#define SET_RMASK(val)	((val & 0xffff) | (val << 16))
+#define CLR_RMASK(val)	(0 | (val << 16))
+
+/* ctrl_status definitions */
+#define CSR_SCSI_PAGE_SELECT                    0x00000003
+#define CSR_SCSI_INTR_ENABLE                    0x00000004 /* 4010 */
+#define CSR_SCSI_RESET_INTR                     0x00000008
+#define CSR_SCSI_COMPLETION_INTR                0x00000010
+#define CSR_SCSI_PROCESSOR_INTR                 0x00000020
+#define CSR_INTR_RISC                           0x00000040
+#define CSR_BOOT_ENABLE                         0x00000080
+#define CSR_NET_PAGE_SELECT                     0x00000300 /* 4010 */
+#define CSR_NET_INTR_ENABLE                     0x00000400 /* 4010 */
+#define CSR_FUNC_NUM                            0x00000700 /* 4022 */
+#define CSR_PCI_FUNC_NUM_MASK                   0x00000300 /* 4022 */
+#define CSR_NET_RESET_INTR                      0x00000800 /* 4010 */
+#define CSR_NET_COMPLETION_INTR                 0x00001000 /* 4010 */
+#define CSR_FORCE_SOFT_RESET                    0x00002000 /* 4022 */
+#define CSR_FATAL_ERROR                         0x00004000
+#define CSR_SOFT_RESET                          0x00008000
+#define ISP_CONTROL_FN_MASK     		CSR_FUNC_NUM
+#define ISP_CONTROL_FN0_NET     		0x0400
+#define ISP_CONTROL_FN0_SCSI    		0x0500
+#define ISP_CONTROL_FN1_NET     		0x0600
+#define ISP_CONTROL_FN1_SCSI    		0x0700
+
+#define INTR_PENDING                            (CSR_SCSI_COMPLETION_INTR | CSR_SCSI_PROCESSOR_INTR | CSR_SCSI_RESET_INTR)
+
+/* ISP InterruptMask definitions */
+#define IMR_SCSI_INTR_ENABLE                    0x00000004  /* 4022 */
+
+/* ISP 4022 nvram definitions */
+#define NVR_WRITE_ENABLE			0x00000010  /* 4022 */
+
+/* ISP port_ctrl definitions */
+#define PCR_CONFIG_COMPLETE			0x00008000  /* 4022 */
+#define PCR_BIOS_BOOTED_FIRMWARE		0x00008000  /* 4010 */
+#define PCR_ENABLE_SERIAL_DATA			0x00001000  /* 4010 */
+#define PCR_SERIAL_DATA_OUT			0x00000800  /* 4010 */
+#define PCR_ENABLE_SERIAL_CLOCK			0x00000400  /* 4010 */
+#define PCR_SERIAL_CLOCK			0x00000200  /* 4010 */
+
+/* ISP port_status definitions */
+#define PSR_CONFIG_COMPLETE			0x00000001  /* 4010 */
+#define PSR_INIT_COMPLETE			0x00000200
+
+/* ISP Semaphore definitions */
+#define SR_FIRWMARE_BOOTED			0x00000001
+
+/* ISP General Purpose Output definitions */
+#define GPOR_TOPCAT_RESET                  	0x00000004
+
+/* shadow registers (DMA'd from HA to system memory.  read only) */
+typedef struct {
+	/* SCSI Request Queue Consumer Index */
+	UINT32   req_q_out;	/* 0 x0   R  */
+
+	/* SCSI Completion Queue Producer Index */
+	UINT32   rsp_q_in;	/* 4 x4   R  */
+} shadow_regs_t;		/* 8 x8	     */
+
+#define EHWC_PROT_METHOD_NONE                         0
+#define EHWC_PROT_METHOD_BYTE_PARITY                  1
+#define EHWC_PROT_METHOD_ECC                          2
+#define EHWC_SDRAM_BANKS_1                            0
+#define EHWC_SDRAM_BANKS_2                            1
+#define EHWC_SDRAM_WIDTH_8_BIT                        0
+#define EHWC_SDRAM_WIDTH_16_BIT                       1
+#define EHWC_SDRAM_CHIP_SIZE_64MB                     0
+#define EHWC_SDRAM_CHIP_SIZE_128MB                    1
+#define EHWC_SDRAM_CHIP_SIZE_256MB                    2
+#define EHWC_MEM_TYPE_SYNC_FLOWTHROUGH                0
+#define EHWC_MEM_TYPE_SYNC_PIPELINE                   1
+#define EHWC_WRITE_BURST_512                          0
+#define EHWC_WRITE_BURST_1024                         1
+#define EHWC_WRITE_BURST_2048                         2
+#define EHWC_WRITE_BURST_4096                         3
+
+/* External hardware configuration register */
+typedef union _EXTERNAL_HW_CONFIG_REG {
+	struct {
+		UINT32  bReserved0                :1;
+		UINT32  bSDRAMProtectionMethod    :2;
+		UINT32  bSDRAMBanks               :1;
+		UINT32  bSDRAMChipWidth           :1;
+		UINT32  bSDRAMChipSize            :2;
+		UINT32  bParityDisable            :1;
+		UINT32  bExternalMemoryType       :1;
+		UINT32  bFlashBIOSWriteEnable     :1;
+		UINT32  bFlashUpperBankSelect     :1;
+		UINT32  bWriteBurst               :2;
+		UINT32  bReserved1                :3;
+		UINT32  bMask                     :16;
+	};
+	UINT32   AsUINT32;
+} EXTERNAL_HW_CONFIG_REG, *PEXTERNAL_HW_CONFIG_REG;
+
+/*************************************************************************
+ *
+ *		Mailbox Commands Structures and Definitions
+ *
+ *************************************************************************/
+
+/* Mailbox command definitions */
+#define MBOX_CMD_LOAD_RISC_RAM_EXT              0x0001
+#define MBOX_CMD_EXECUTE_FW                     0x0002
+#define MBOX_CMD_DUMP_RISC_RAM_EXT              0x0003
+#define MBOX_CMD_WRITE_RISC_RAM_EXT             0x0004
+#define MBOX_CMD_READ_RISC_RAM_EXT              0x0005
+#define MBOX_CMD_REGISTER_TEST                  0x0006
+#define MBOX_CMD_VERIFY_CHECKSUM                0x0007
+#define MBOX_CMD_ABOUT_FW                       0x0009
+#define MBOX_CMD_LOOPBACK_DIAG                  0x000A
+#define MBOX_CMD_PING                           0x000B
+#define MBOX_CMD_CHECKSUM_FW                    0x000E
+#define MBOX_CMD_RESET_FW                       0x0014
+#define MBOX_CMD_ABORT_TASK                     0x0015
+#define MBOX_CMD_LUN_RESET                      0x0016
+#define MBOX_CMD_TARGET_WARM_RESET              0x0017
+#define MBOX_CMD_TARGET_COLD_RESET              0x0018
+#define MBOX_CMD_ABORT_QUEUE                    0x001C
+#define MBOX_CMD_GET_QUEUE_STATUS               0x001D
+#define MBOX_CMD_GET_MANAGEMENT_DATA            0x001E
+#define MBOX_CMD_GET_FW_STATUS                  0x001F
+#define MBOX_CMD_SET_ISNS_SERVICE               0x0021
+		#define ISNS_DISABLE                            0
+		#define ISNS_ENABLE                             1
+		#define ISNS_STATUS                             2
+#define MBOX_CMD_COPY_FLASH                     0x0024
+		#define COPY_FLASH_OPTION_PRIM_TO_SEC           0
+		#define COPY_FLASH_OPTION_SEC_TO_PRIM           1
+#define MBOX_CMD_WRITE_FLASH                    0x0025
+		#define WRITE_FLASH_OPTION_HOLD_DATA            0
+		#define WRITE_FLASH_OPTION_COMMIT_DATA          2
+		#define WRITE_FLASH_OPTION_FLASH_DATA    	3
+#define MBOX_CMD_READ_FLASH                     0x0026
+#define MBOX_CMD_GET_QUEUE_PARAMS               0x0029
+#define MBOX_CMD_CLEAR_DATABASE_ENTRY           0x0031
+#define MBOX_CMD_SET_QUEUE_PARAMS               0x0039
+#define MBOX_CMD_CONN_CLOSE_SESS_LOGOUT         0x0056
+		#define LOGOUT_OPTION_CLOSE_SESSION             0x01
+		#define LOGOUT_OPTION_RELOGIN                   0x02
+#define MBOX_CMD_EXECUTE_IOCB_A64		0x005A
+#define MBOX_CMD_INITIALIZE_FIRMWARE            0x0060
+#define MBOX_CMD_GET_INIT_FW_CTRL_BLOCK         0x0061
+#define MBOX_CMD_REQUEST_DATABASE_ENTRY         0x0062
+#define MBOX_CMD_SET_DATABASE_ENTRY             0x0063					
+#define MBOX_CMD_GET_DATABASE_ENTRY             0x0064
+		#define DDB_DS_UNASSIGNED                       0x00
+		#define DDB_DS_NO_CONNECTION_ACTIVE             0x01
+		#define DDB_DS_DISCOVERY                        0x02
+		#define DDB_DS_NO_SESSION_ACTIVE                0x03
+		#define DDB_DS_SESSION_ACTIVE                   0x04
+		#define DDB_DS_LOGGING_OUT                      0x05
+		#define DDB_DS_SESSION_FAILED                   0x06
+		#define DDB_DS_LOGIN_IN_PROCESS                 0x07
+		#define DELETEABLE_DDB_DS(ds) ((ds == DDB_DS_UNASSIGNED) || \
+		                               (ds == DDB_DS_NO_CONNECTION_ACTIVE) || \
+					       (ds == DDB_DS_SESSION_FAILED))
+#define MBOX_CMD_CLEAR_ACA                      0x0065
+#define MBOX_CMD_CLEAR_TASK_SET                 0x0067
+#define MBOX_CMD_ABORT_TASK_SET                 0x0068
+#define MBOX_CMD_GET_FW_STATE                   0x0069
+
+/* Mailbox 1 */
+		#define FW_STATE_READY                          0x0000
+		#define FW_STATE_CONFIG_WAIT                    0x0001
+		#define FW_STATE_WAIT_LOGIN                     0x0002
+		#define FW_STATE_ERROR                          0x0004
+		#define FW_STATE_DHCP_IN_PROGRESS		0x0008
+		#define FW_STATE_ISNS_IN_PROGRESS               0x0010
+		#define FW_STATE_TOPCAT_INIT_IN_PROGRESS       	0x0040
+
+/* Mailbox 3 */
+		#define FW_ADDSTATE_COPPER_MEDIA                0x0000
+		#define FW_ADDSTATE_OPTICAL_MEDIA               0x0001
+		#define	FW_ADDSTATE_DHCP_ENABLED		0x0002
+		#define	FW_ADDSTATE_DHCP_LEASE_ACQUIRED		0x0004
+		#define	FW_ADDSTATE_DHCP_LEASE_EXPIRED		0x0008
+		#define FW_ADDSTATE_LINK_UP                     0x0010
+		#define FW_ADDSTATE_ISNS_SVC_ENABLED            0x0020
+		#define FW_ADDSTATE_TOPCAT_NOT_INITIALIZED     	0x0040
+#define MBOX_CMD_GET_INIT_FW_CTRL_BLOCK_DEFAULTS 0x006A
+#define MBOX_CMD_GET_DATABASE_ENTRY_DEFAULTS    0x006B
+#define MBOX_CMD_CONN_OPEN_SESS_LOGIN           0x0074
+#define MBOX_CMD_DIAGNOSTICS_TEST_RESULTS       0x0075	/* 4010 only */
+		#define DIAG_TEST_LOCAL_RAM_SIZE		0x0002
+		#define DIAG_TEST_LOCAL_RAM_READ_WRITE		0x0003
+		#define DIAG_TEST_RISC_RAM			0x0004
+		#define DIAG_TEST_NVRAM				0x0005
+		#define DIAG_TEST_FLASH_ROM			0x0006
+		#define DIAG_TEST_NW_INT_LOOPBACK		0x0007
+		#define DIAG_TEST_NW_EXT_LOOPBACK		0x0008
+#define MBOX_CMD_GET_CRASH_RECORD       	0x0076	/* 4010 only */
+#define MBOX_CMD_GET_CONN_EVENT_LOG       	0x0077
+#define MBOX_CMD_RESTORE_FACTORY_DEFAULTS      	0x0087
+#define MBOX_CMD_NOP                            0x00FF
+
+/* Mailbox status definitions */
+#define MBOX_COMPLETION_STATUS			4
+#define MBOX_STS_BUSY                           0x0007
+#define MBOX_STS_INTERMEDIATE_COMPLETION    	0x1000
+#define MBOX_STS_COMMAND_COMPLETE               0x4000
+#define MBOX_STS_INVALID_COMMAND                0x4001
+#define MBOX_STS_HOST_INTERFACE_ERROR           0x4002
+#define MBOX_STS_TEST_FAILED                    0x4003
+#define MBOX_STS_COMMAND_ERROR                  0x4005
+#define MBOX_STS_COMMAND_PARAMETER_ERROR        0x4006
+#define MBOX_STS_TARGET_MODE_INIT_FAIL          0x4007
+#define MBOX_STS_INITIATOR_MODE_INIT_FAIL       0x4008
+
+#define MBOX_ASYNC_EVENT_STATUS			8
+#define MBOX_ASTS_SYSTEM_ERROR                  0x8002
+#define MBOX_ASTS_REQUEST_TRANSFER_ERROR        0x8003
+#define MBOX_ASTS_RESPONSE_TRANSFER_ERROR       0x8004
+#define MBOX_ASTS_PROTOCOL_STATISTIC_ALARM      0x8005
+#define MBOX_ASTS_SCSI_COMMAND_PDU_REJECTED     0x8006
+#define MBOX_ASTS_LINK_UP  			0x8010
+#define MBOX_ASTS_LINK_DOWN			0x8011
+#define MBOX_ASTS_DATABASE_CHANGED              0x8014
+#define MBOX_ASTS_UNSOLICITED_PDU_RECEIVED      0x8015
+#define MBOX_ASTS_SELF_TEST_FAILED      	0x8016
+#define MBOX_ASTS_LOGIN_FAILED      		0x8017
+#define MBOX_ASTS_DNS      			0x8018
+#define MBOX_ASTS_HEARTBEAT      		0x8019
+#define MBOX_ASTS_NVRAM_INVALID      		0x801A
+#define MBOX_ASTS_MAC_ADDRESS_CHANGED      	0x801B
+#define MBOX_ASTS_IP_ADDRESS_CHANGED      	0x801C
+#define MBOX_ASTS_DHCP_LEASE_EXPIRED      	0x801D
+#define MBOX_ASTS_DHCP_LEASE_ACQUIRED           0x801F
+#define MBOX_ASTS_ISNS_UNSOLICITED_PDU_RECEIVED 0x8021
+		#define ISNS_EVENT_DATA_RECEIVED		0x0000
+		#define ISNS_EVENT_CONNECTION_OPENED		0x0001
+		#define ISNS_EVENT_CONNECTION_FAILED		0x0002
+#define MBOX_ASTS_IPSEC_SYSTEM_FATAL_ERROR	0x8022
+#define MBOX_ASTS_SUBNET_STATE_CHANGE		0x8027
+
+
+/*************************************************************************/
+
+/* Host Adapter Initialization Control Block (from host) */
+typedef struct _INIT_FW_CTRL_BLK {
+	UINT8   Version;			/* 00 */
+	UINT8   Control;			/* 01 */
+
+	UINT16  FwOptions;			/* 02-03 */
+   #define  FWOPT_HEARTBEAT_ENABLE           0x1000
+   #define  FWOPT_MARKER_DISABLE             0x0400
+   #define  FWOPT_PROTOCOL_STAT_ALARM_ENABLE 0x0200
+   #define  FWOPT_TARGET_ACCEPT_AEN_ENABLE   0x0100
+   #define  FWOPT_ACCESS_CONTROL_ENABLE      0x0080
+   #define  FWOPT_SESSION_MODE               0x0040
+   #define  FWOPT_INITIATOR_MODE             0x0020
+   #define  FWOPT_TARGET_MODE                0x0010
+   #define  FWOPT_FAST_POSTING               0x0008
+   #define  FWOPT_AUTO_TARGET_INFO_DISABLE   0x0004
+   #define  FWOPT_SENSE_BUFFER_DATA_ENABLE   0x0002
+
+	UINT16  ExecThrottle;			/* 04-05 */
+	UINT8   RetryCount;			/* 06 */
+	UINT8   RetryDelay;			/* 07 */
+	UINT16  MaxEthFrPayloadSize;		/* 08-09 */
+	UINT16  AddFwOptions;			/* 0A-0B */
+   #define  ADDFWOPT_AUTOCONNECT_DISABLE     0x0002
+   #define  ADDFWOPT_SUSPEND_ON_FW_ERROR     0x0001
+
+	UINT8   HeartbeatInterval;		/* 0C */
+	UINT8   InstanceNumber;			/* 0D */
+	UINT16  RES2;				/* 0E-0F */
+	UINT16  ReqQConsumerIndex;		/* 10-11 */
+	UINT16  ComplQProducerIndex;		/* 12-13 */
+	UINT16  ReqQLen;			/* 14-15 */
+	UINT16  ComplQLen;			/* 16-17 */
+	UINT32  ReqQAddrLo;			/* 18-1B */
+	UINT32  ReqQAddrHi;			/* 1C-1F */
+	UINT32  ComplQAddrLo;			/* 20-23 */
+	UINT32  ComplQAddrHi;			/* 24-27 */
+	UINT32  ShadowRegBufAddrLo;		/* 28-2B */
+	UINT32  ShadowRegBufAddrHi;		/* 2C-2F */
+
+	UINT16  iSCSIOptions;			/* 30-31 */
+   #define  IOPT_RCV_ISCSI_MARKER_ENABLE     0x8000
+   #define  IOPT_SEND_ISCSI_MARKER_ENABLE    0x4000
+   #define  IOPT_HEADER_DIGEST_ENABLE        0x2000
+   #define  IOPT_DATA_DIGEST_ENABLE          0x1000
+   #define  IOPT_IMMEDIATE_DATA_ENABLE       0x0800
+   #define  IOPT_INITIAL_R2T_ENABLE          0x0400
+   #define  IOPT_DATA_SEQ_IN_ORDER           0x0200
+   #define  IOPT_DATA_PDU_IN_ORDER           0x0100
+   #define  IOPT_CHAP_AUTH_ENABLE            0x0080
+   #define  IOPT_SNACK_REQ_ENABLE            0x0040
+   #define  IOPT_DISCOVERY_LOGOUT_ENABLE     0x0020
+   #define  IOPT_BIDIR_CHAP_ENABLE     	     0x0010
+
+	UINT16  TCPOptions;			/* 32-33 */
+   #define  TOPT_ISNS_ENABLE		     0x4000
+   #define  TOPT_SLP_USE_DA_ENABLE	     0x2000
+   #define  TOPT_AUTO_DISCOVERY_ENABLE       0x1000
+   #define  TOPT_SLP_UA_ENABLE               0x0800
+   #define  TOPT_SLP_SA_ENABLE               0x0400
+   #define  TOPT_DHCP_ENABLE                 0x0200
+   #define  TOPT_GET_DNS_VIA_DHCP_ENABLE     0x0100
+   #define  TOPT_GET_SLP_VIA_DHCP_ENABLE     0x0080
+   #define  TOPT_LEARN_ISNS_IP_ADDR_ENABLE   0x0040
+   #define  TOPT_NAGLE_DISABLE               0x0020
+   #define  TOPT_TIMER_SCALE_MASK            0x000E
+   #define  TOPT_TIME_STAMP_ENABLE           0x0001
+
+	UINT16  IPOptions;			/* 34-35 */
+   #define  IPOPT_FRAG_DISABLE               0x0010
+   #define  IPOPT_PAUSE_FRAME_ENABLE         0x0002
+   #define  IPOPT_IP_ADDRESS_VALID           0x0001
+
+	UINT16  MaxPDUSize;			/* 36-37 */
+	UINT16  RcvMarkerInt;			/* 38-39 */
+	UINT16  SndMarkerInt;			/* 3A-3B */
+	UINT16  InitMarkerlessInt;		/* 3C-3D */
+	UINT16  FirstBurstSize;			/* 3E-3F */
+	UINT16  DefaultTime2Wait;		/* 40-41 */
+	UINT16  DefaultTime2Retain;		/* 42-43 */
+	UINT16  MaxOutStndngR2T;		/* 44-45 */
+	UINT16  KeepAliveTimeout;		/* 46-47 */
+	UINT16  PortNumber;			/* 48-49 */
+	UINT16  MaxBurstSize;			/* 4A-4B */
+	UINT32  RES4;				/* 4C-4F */
+	UINT8   IPAddr[4];			/* 50-53 */
+	UINT8   RES5[12];			/* 54-5F */
+	UINT8   SubnetMask[4];			/* 60-63 */
+	UINT8   RES6[12];			/* 64-6F */
+	UINT8   GatewayIPAddr[4];		/* 70-73 */
+	UINT8   RES7[12];			/* 74-7F */
+	UINT8   PriDNSIPAddr[4];		/* 80-83 */
+	UINT8   SecDNSIPAddr[4];		/* 84-87 */
+	UINT8   RES8[8];			/* 88-8F */
+	UINT8   Alias[32];			/* 90-AF */
+	UINT8   TargAddr[8];			/* B0-B7 */
+	UINT8   CHAPNameSecretsTable[8];	/* B8-BF */
+	UINT8   EthernetMACAddr[6];		/* C0-C5 */
+	UINT16  TargetPortalGroup;		/* C6-C7 */
+	UINT8   SendScale;			/* C8    */
+	UINT8   RecvScale;			/* C9    */
+	UINT8   TypeOfService;			/* CA    */
+	UINT8   Time2Live;			/* CB    */
+	UINT16  VLANPriority;			/* CC-CD */
+	UINT16  Reserved8;			/* CE-CF */
+	UINT8   SecIPAddr[4];			/* D0-D3 */
+	UINT8   Reserved9[12];			/* D4-DF */
+	UINT8   iSNSIPAddr[4];			/* E0-E3 */
+	UINT16  iSNSServerPortNumber;		/* E4-E5 */
+	UINT8   Reserved10[10];			/* E6-EF */
+	UINT8   SLPDAIPAddr[4];			/* F0-F3 */
+	UINT8   Reserved11[12];			/* F4-FF */
+	UINT8   iSCSINameString[256];		/* 100-1FF */
+} INIT_FW_CTRL_BLK;
+
+typedef struct {
+	INIT_FW_CTRL_BLK init_fw_cb;
+	UINT32       Cookie;
+	#define INIT_FW_CTRL_BLK_COOKIE 	0x11BEAD5A
+} FLASH_INIT_FW_CTRL_BLK;
+
+/*************************************************************************/
+
+typedef struct _DEV_DB_ENTRY {
+	UINT8  options;	      /* 00 */
+   #define  DDB_OPT_DISABLE                  0x08  /* do not connect to device */
+   #define  DDB_OPT_ACCESSGRANTED            0x04
+   #define  DDB_OPT_TARGET                   0x02  /* device is a target */
+   #define  DDB_OPT_INITIATOR                0x01  /* device is an initiator */
+
+	UINT8  control;	      /* 01 */
+   #define  DDB_CTRL_DATABASE_ENTRY_STATE    0xC0
+   #define  DDB_CTRL_SESSION_RECOVERY        0x10
+   #define  DDB_CTRL_SENDING                 0x08
+   #define  DDB_CTRL_XFR_PENDING             0x04
+   #define  DDB_CTRL_QUEUE_ABORTED           0x02
+   #define  DDB_CTRL_LOGGED_IN               0x01
+
+	UINT16 exeThrottle;   /* 02-03 */
+	UINT16 exeCount;      /* 04-05 */
+	UINT8  retryCount;    /* 06    */
+	UINT8  retryDelay;    /* 07    */
+	UINT16 iSCSIOptions;  /* 08-09 */
+   #define DDB_IOPT_RECV_ISCSI_MARKER_ENABLE 0x8000
+   #define DDB_IOPT_SEND_ISCSI_MARKER_ENABLE 0x4000
+   #define DDB_IOPT_HEADER_DIGEST_ENABLE     0x2000
+   #define DDB_IOPT_DATA_DIGEST_ENABLE       0x1000
+   #define DDB_IOPT_IMMEDIATE_DATA_ENABLE    0x0800
+   #define DDB_IOPT_INITIAL_R2T_ENABLE       0x0400
+   #define DDB_IOPT_DATA_SEQUENCE_IN_ORDER   0x0200
+   #define DDB_IOPT_DATA_PDU_IN_ORDER        0x0100
+   #define DDB_IOPT_CHAP_AUTH_ENABLE         0x0080
+   #define DDB_IOPT_BIDIR_CHAP_CHAL_ENABLE   0x0010
+   #define DDB_IOPT_RESERVED2                0x007F
+
+	UINT16 TCPOptions;    /* 0A-0B */
+   #define DDB_TOPT_NAGLE_DISABLE            0x0020
+   #define DDB_TOPT_TIMER_SCALE_MASK         0x000E
+   #define DDB_TOPT_TIME_STAMP_ENABLE        0x0001
+
+	UINT16 IPOptions;     /* 0C-0D */
+   #define DDB_IPOPT_FRAG_DISABLE     	     0x0002
+   #define DDB_IPOPT_IP_ADDRESS_VALID        0x0001
+
+	UINT16 maxPDUSize;    /* 0E-0F */
+	UINT16 rcvMarkerInt;  /* 10-11 */
+	UINT16 sndMarkerInt;  /* 12-13 */
+	UINT16 iSCSIMaxSndDataSegLen;  /* 14-15 */
+	UINT16 firstBurstSize;	   /* 16-17 */
+	UINT16 minTime2Wait; /* 18-19 : RA :default_time2wait */
+	UINT16 maxTime2Retain; /* 1A-1B */
+	UINT16 maxOutstndngR2T;	   /* 1C-1D */
+	UINT16 keepAliveTimeout;   /* 1E-1F */
+	UINT8 ISID[6];	      /* 20-25 big-endian, must be converted to little-endian */
+	UINT16 TSID;	      /* 26-27 */
+	UINT16 portNumber;    /* 28-29 */
+	UINT16 maxBurstSize;  /* 2A-2B */
+	UINT16 taskMngmntTimeout;  /* 2C-2D */
+	UINT16 reserved1;     /* 2E-2F */
+	UINT8  ipAddr[0x10];  /* 30-3F */
+	UINT8  iSCSIAlias[0x20];   /* 40-5F */
+	UINT8  targetAddr[0x20];   /* 60-7F */
+	UINT8  userID[0x20];  /* 80-9F */
+	UINT8  password[0x20];	   /* A0-BF */
+	UINT8  iscsiName[0x100];   /* C0-1BF : xxzzy Make this a pointer to a string so we don't
+						     have to reserve soooo much RAM */
+	UINT16 ddbLink;	      /* 1C0-1C1 */
+	UINT16 CHAPTableIndex;	   /* 1C2-1C3 */
+	UINT16 TargetPortalGroup;  /* 1C4-1C5 */
+	UINT16 reserved2[2];		/* 1C6-1C7 */
+	UINT32 statSN;			/* 1C8-1CB */
+	UINT32 expStatSN;		/* 1CC-1CF */
+	UINT16 reserved3[0x2C];		/* 1D0-1FB */
+	UINT16 ddbValidCookie;		/* 1FC-1FD */
+	UINT16 ddbValidSize;		/* 1FE-1FF */
+} DEV_DB_ENTRY;
+
+
+/*************************************************************************/
+
+/* Flash definitions */
+#define FLASH_FW_IMG_PAGE_SIZE        0x20000
+#define FLASH_FW_IMG_PAGE(addr)       (0xfffe0000 & (addr))
+#define FLASH_STRUCTURE_TYPE_MASK     0x0f000000
+
+#define FLASH_OFFSET_FW_LOADER_IMG    0x00000000
+#define FLASH_OFFSET_SECONDARY_FW_IMG 0x01000000
+#define FLASH_OFFSET_SYS_INFO         0x02000000
+#define FLASH_OFFSET_DRIVER_BLK       0x03000000
+#define FLASH_OFFSET_INIT_FW_CTRL_BLK 0x04000000
+#define FLASH_OFFSET_DEV_DB_AREA      0x05000000
+#define FLASH_OFFSET_CHAP_AREA        0x06000000
+#define FLASH_OFFSET_PRIMARY_FW_IMG   0x07000000
+#define FLASH_READ_RAM_FLAG           0x10000000
+
+#define MAX_FLASH_SZ                  0x400000    /* 4M flash */
+#define FLASH_DEFAULTBLOCKSIZE        0x20000
+#define FLASH_EOF_OFFSET              FLASH_DEFAULTBLOCKSIZE - 8 /* 4 bytes for EOF signature */
+#define FLASH_FILESIZE_OFFSET         FLASH_EOF_OFFSET - 4       /* 4 bytes for file size */
+#define FLASH_CKSUM_OFFSET            FLASH_FILESIZE_OFFSET - 4  /* 4 bytes for chksum protection */
+
+typedef struct _SYS_INFO_PHYS_ADDR {
+	UINT8            address[6];		/* 00-05 */
+	UINT8            filler[2];		/* 06-07 */
+} SYS_INFO_PHYS_ADDR;
+
+typedef struct _FLASH_SYS_INFO {
+	UINT32           cookie;		/* 00-03 */
+	UINT32           physAddrCount;		/* 04-07 */
+	SYS_INFO_PHYS_ADDR physAddr[4];		/* 08-27 */
+	UINT8            vendorId[128];		/* 28-A7 */
+	UINT8            productId[128];	/* A8-127 */
+	UINT32           serialNumber;		/* 128-12B */
+
+	/* PCI Configuration values */
+	UINT32           pciDeviceVendor;	/* 12C-12F */
+	UINT32           pciDeviceId;		/* 130-133 */
+	UINT32           pciSubsysVendor;	/* 134-137 */
+	UINT32           pciSubsysId;		/* 138-13B */
+
+	/* This validates version 1. */
+	UINT32           crumbs;		/* 13C-13F */
+
+	UINT32           enterpriseNumber;	/* 140-143 */
+
+	UINT32           mtu;			/* 144-147 */
+	UINT32           reserved0;		/* 148-14b */
+	UINT32           crumbs2;		/* 14c-14f */
+	UINT8            acSerialNumber[16];	/* 150-15f */
+	UINT32           crumbs3;		/* 160-16f */
+
+	/* Leave this last in the struct so it is declared invalid if
+	 * any new items are added. */
+	UINT32           reserved1[39];		/* 170-1ff */
+} FLASH_SYS_INFO, *PFLASH_SYS_INFO;		/* 200 */
+
+typedef struct _FLASH_DRIVER_INFO {
+	UINT32          LinuxDriverCookie;
+	#define FLASH_LINUX_DRIVER_COOKIE		0x0A1B2C3D
+	UINT8       Pad[4];
+
+} FLASH_DRIVER_INFO, *PFLASH_DRIVER_INFO;
+
+typedef struct _CHAP_ENTRY {
+	UINT16 link;				  /*  0 x0   */
+   #define CHAP_FLAG_PEER_NAME		0x40
+   #define CHAP_FLAG_LOCAL_NAME    	0x80
+
+	UINT8 flags;				 /*  2 x2    */
+   #define MIN_CHAP_SECRET_LENGTH  	12
+   #define MAX_CHAP_SECRET_LENGTH  	100
+
+	UINT8 secretLength;			 /*  3 x3    */
+	UINT8 secret[MAX_CHAP_SECRET_LENGTH];	 /*  4 x4    */
+   #define MAX_CHAP_CHALLENGE_LENGTH       256
+
+	UINT8 user_name[MAX_CHAP_CHALLENGE_LENGTH]; /* 104 x68  */
+	UINT16 reserved;			    /* 360 x168 */
+   #define CHAP_COOKIE                     0x4092
+
+	UINT16 cookie;				    /* 362 x16a */
+} CHAP_ENTRY, *PCHAP_ENTRY;			    /* 364 x16c */
+
+
+/*************************************************************************/
+
+typedef struct _CRASH_RECORD {
+	UINT16  fw_major_version;	/* 00 - 01 */
+	UINT16  fw_minor_version;	/* 02 - 03 */
+	UINT16  fw_patch_version;	/* 04 - 05 */
+	UINT16  fw_build_version;	/* 06 - 07 */
+
+	UINT8   build_date[16];		/* 08 - 17 */
+	UINT8   build_time[16];		/* 18 - 27 */
+	UINT8   build_user[16];		/* 28 - 37 */
+	UINT8   card_serial_num[16];	/* 38 - 47 */
+
+	UINT32  time_of_crash_in_secs;	/* 48 - 4B */
+	UINT32  time_of_crash_in_ms;	/* 4C - 4F */
+
+	UINT16  out_RISC_sd_num_frames;	/* 50 - 51 */
+	UINT16  OAP_sd_num_words;	/* 52 - 53 */
+	UINT16  IAP_sd_num_frames;	/* 54 - 55 */
+	UINT16  in_RISC_sd_num_words;	/* 56 - 57 */
+
+	UINT8   reserved1[28];		/* 58 - 7F */
+
+	UINT8   out_RISC_reg_dump[256];	/* 80 -17F */
+	UINT8   in_RISC_reg_dump[256];	/*180 -27F */
+	UINT8   in_out_RISC_stack_dump[0]; /*280 - ??? */
+} CRASH_RECORD, *PCRASH_RECORD;
+
+
+/*************************************************************************/
+
+#define MAX_CONN_EVENT_LOG_ENTRIES	100
+
+typedef struct _CONN_EVENT_LOG_ENTRY {
+	UINT32  timestamp_sec;		/* 00 - 03 seconds since boot */
+	UINT32  timestamp_ms;		/* 04 - 07 milliseconds since boot */
+	UINT16  device_index;		/* 08 - 09  */
+	UINT16  fw_conn_state;		/* 0A - 0B  */
+	UINT8   event_type;		/* 0C - 0C  */
+	UINT8   error_code;		/* 0D - 0D  */
+	UINT16  error_code_detail;	/* 0E - 0F  */
+	UINT8   num_consecutive_events;	/* 10 - 10  */
+	UINT8   rsvd[3];		/* 11 - 13  */
+} CONN_EVENT_LOG_ENTRY, *PCONN_EVENT_LOG_ENTRY;
+
+
+/*************************************************************************
+ *
+ *				IOCB Commands Structures and Definitions
+ *
+ *************************************************************************/
+#define IOCB_MAX_CDB_LEN            16  /* Bytes in a CBD */
+#define IOCB_MAX_SENSEDATA_LEN      32  /* Bytes of sense data */
+#define IOCB_MAX_EXT_SENSEDATA_LEN  60  /* Bytes of extended sense data */
+#define IOCB_MAX_DSD_CNT             1  /* DSDs per noncontinuation type IOCB */
+#define IOCB_CONT_MAX_DSD_CNT        5  /* DSDs per Continuation */
+#define CTIO_MAX_SENSEDATA_LEN      24  /* Bytes of sense data in a CTIO*/
+
+#define RESERVED_BYTES_MARKER       40  /* Reserved Bytes at end of Marker */
+#define RESERVED_BYTES_INOT         28  /* Reserved Bytes at end of Immediate Notify */
+#define RESERVED_BYTES_NOTACK       28  /* Reserved Bytes at end of Notify Acknowledge */
+#define RESERVED_BYTES_CTIO          2  /* Reserved Bytes in middle of CTIO */
+
+#define MAX_MBX_COUNT               14  /* Maximum number of mailboxes in MBX IOCB */
+
+#define ISCSI_MAX_NAME_BYTECNT      256  /* Bytes in a target name */
+
+#define IOCB_ENTRY_SIZE       	    0x40
+
+
+/* IOCB header structure */
+typedef struct _HEADER {
+	UINT8 entryType;
+   #define ET_STATUS                0x03
+   #define ET_MARKER                0x04
+   #define ET_CONT_T1               0x0A
+   #define ET_INOT                  0x0D
+   #define ET_NACK                  0x0E
+   #define ET_STATUS_CONTINUATION   0x10
+   #define ET_CMND_T4               0x15
+   #define ET_ATIO                  0x16
+   #define ET_CMND_T3               0x19
+   #define ET_CTIO4                 0x1E
+   #define ET_CTIO3                 0x1F
+   #define ET_PERFORMANCE_STATUS    0x20
+   #define ET_MAILBOX_CMD           0x38
+   #define ET_MAILBOX_STATUS        0x39
+   #define ET_PASSTHRU0             0x3A
+   #define ET_PASSTHRU1             0x3B
+   #define ET_PASSTHRU_STATUS       0x3C
+   #define ET_ASYNCH_MSG            0x3D
+   #define ET_CTIO5                 0x3E
+   #define ET_CTIO6                 0x3F
+
+	UINT8 entryStatus;
+    #define ES_MASK                 0x3E
+    #define ES_SUPPRESS_COMPL_INT   0x01
+    #define ES_BUSY                 0x02
+    #define ES_INVALID_ENTRY_TYPE   0x04
+    #define ES_INVALID_ENTRY_PARAM  0x08
+    #define ES_INVALID_ENTRY_COUNT  0x10
+    #define ES_INVALID_ENTRY_ORDER  0x20
+	UINT8 systemDefined;
+	UINT8 entryCount;
+
+	/* SyetemDefined definition */
+    #define SD_PASSTHRU_IOCB        0x01
+} HEADER ;
+
+/* Genric queue entry structure*/
+typedef struct QUEUE_ENTRY {
+	UINT8  data[60];
+	UINT32 signature;
+
+} QUEUE_ENTRY;
+
+
+/* 64 bit addressing segment counts*/
+
+#define COMMAND_SEG_A64             1
+#define CONTINUE_SEG_A64            5
+#define CONTINUE_SEG_A64_MINUS1     4
+
+/* 64 bit addressing segment definition*/
+
+typedef struct DATA_SEG_A64 {
+	struct {
+		UINT32 addrLow;
+		UINT32 addrHigh;
+
+	} base;
+
+	UINT32 count;
+
+} DATA_SEG_A64;
+
+/* Command Type 3 entry structure*/
+
+typedef struct _COMMAND_T3_ENTRY {
+	HEADER  hdr;		   /* 00-03 */
+
+	UINT32  handle;		   /* 04-07 */
+	UINT16  target;		   /* 08-09 */
+	UINT16  connection_id;	   /* 0A-0B */
+
+	UINT8   control_flags;	   /* 0C */
+   #define CF_IMMEDIATE		   0x80
+
+	/* data direction  (bits 5-6)*/
+   #define CF_WRITE                0x20
+   #define CF_READ                 0x40
+   #define CF_NO_DATA              0x00
+   #define CF_DIRECTION_MASK       0x60
+
+	/* misc  (bits 4-3)*/
+   #define CF_DSD_PTR_ENABLE	   0x10	   /* 4010 only */
+   #define CF_CMD_PTR_ENABLE	   0x08    /* 4010 only */
+
+	/* task attributes (bits 2-0) */
+   #define CF_ACA_QUEUE            0x04
+   #define CF_HEAD_TAG             0x03
+   #define CF_ORDERED_TAG          0x02
+   #define CF_SIMPLE_TAG           0x01
+   #define CF_TAG_TYPE_MASK        0x07
+   #define CF_ATTRIBUTES_MASK      0x67
+
+	/* STATE FLAGS FIELD IS A PLACE HOLDER. THE FW WILL SET BITS IN THIS FIELD
+	   AS THE COMMAND IS PROCESSED. WHEN THE IOCB IS CHANGED TO AN IOSB THIS
+	   FIELD WILL HAVE THE STATE FLAGS SET PROPERLY.
+	*/
+	UINT8   state_flags;	   /* 0D */
+	UINT8   cmdRefNum;	   /* 0E */
+	UINT8   reserved1;	   /* 0F */
+	UINT8   cdb[IOCB_MAX_CDB_LEN];	/* 10-1F */
+	UINT8   lun[8];		   /* 20-27 */
+	UINT32  cmdSeqNum;	   /* 28-2B */
+	UINT16  timeout;	   /* 2C-2D */
+	UINT16  dataSegCnt;	   /* 2E-2F */
+	UINT32  ttlByteCnt;	   /* 30-33 */
+	DATA_SEG_A64 dataseg[COMMAND_SEG_A64];	/* 34-3F */
+
+} COMMAND_T3_ENTRY;
+
+typedef struct _COMMAND_T4_ENTRY {
+	HEADER  hdr;		  /* 00-03 */
+	UINT32  handle;		  /* 04-07 */
+	UINT16  target;		  /* 08-09 */
+	UINT16  connection_id;	  /* 0A-0B */
+	UINT8   control_flags;	  /* 0C */
+
+	/* STATE FLAGS FIELD IS A PLACE HOLDER. THE FW WILL SET BITS IN THIS FIELD
+	   AS THE COMMAND IS PROCESSED. WHEN THE IOCB IS CHANGED TO AN IOSB THIS
+	   FIELD WILL HAVE THE STATE FLAGS SET PROPERLY.
+	*/
+	UINT8   state_flags;	  /* 0D */
+	UINT8   cmdRefNum;	  /* 0E */
+	UINT8   reserved1;	  /* 0F */
+	UINT8   cdb[IOCB_MAX_CDB_LEN]; /* 10-1F */
+	UINT8   lun[8];		  /* 20-27 */
+	UINT32  cmdSeqNum;	  /* 28-2B */
+	UINT16  timeout;	  /* 2C-2D */
+	UINT16  dataSegCnt;	  /* 2E-2F */
+	UINT32  ttlByteCnt;	  /* 30-33 */
+
+	/* WE ONLY USE THE ADDRESS FIELD OF THE FOLLOWING STRUCT.
+	   THE COUNT FIELD IS RESERVED */
+	DATA_SEG_A64 dataseg[COMMAND_SEG_A64];	/* 34-3F */
+} COMMAND_T4_ENTRY;
+
+/* Continuation Type 1 entry structure*/
+typedef struct _CONTINUATION_T1_ENTRY {
+	HEADER  hdr;
+
+	DATA_SEG_A64 dataseg[CONTINUE_SEG_A64];
+
+}CONTINUATION_T1_ENTRY;
+
+/* Status Continuation Type entry structure*/
+typedef struct _STATUS_CONTINUATION_ENTRY {
+	HEADER  hdr;
+
+	UINT8 extSenseData[IOCB_MAX_EXT_SENSEDATA_LEN];
+
+}STATUS_CONTINUATION_ENTRY;
+
+/* Parameterize for 64 or 32 bits */
+    #define COMMAND_SEG     COMMAND_SEG_A64
+    #define CONTINUE_SEG    CONTINUE_SEG_A64
+
+    #define COMMAND_ENTRY   COMMAND_T3_ENTRY
+    #define CONTINUE_ENTRY  CONTINUATION_T1_ENTRY
+
+    #define ET_COMMAND      ET_CMND_T3
+    #define ET_CONTINUE     ET_CONT_T1
+
+
+
+/* Marker entry structure*/
+typedef struct _MARKER_ENTRY {
+	HEADER  hdr;		/* 00-03 */
+
+	UINT32  system_defined;	/* 04-07 */
+	UINT16  target;		/* 08-09 */
+	UINT16  modifier;	/* 0A-0B */
+   #define MM_LUN_RESET         0
+   #define MM_TARGET_WARM_RESET 1
+   #define MM_TARGET_COLD_RESET 2
+   #define MM_CLEAR_ACA    	3
+   #define MM_CLEAR_TASK_SET    4
+   #define MM_ABORT_TASK_SET    5
+
+	UINT16  flags;		/* 0C-0D */
+	UINT16  reserved1;	/* 0E-0F */
+	UINT8   lun[8];		/* 10-17 */
+	UINT64  reserved2;	/* 18-1F */
+	UINT64  reserved3;	/* 20-27 */
+	UINT64  reserved4;	/* 28-2F */
+	UINT64  reserved5;	/* 30-37 */
+	UINT64  reserved6;	/* 38-3F */
+}MARKER_ENTRY;
+
+/* Status entry structure*/
+typedef struct _STATUS_ENTRY {
+	HEADER  hdr;			     /* 00-03 */
+
+	UINT32  handle;			     /* 04-07 */
+
+	UINT8   scsiStatus;		     /* 08 */
+   #define SCSI_STATUS_MASK                  0xFF
+   #define SCSI_STATUS                       0xFF
+   #define SCSI_GOOD                         0x00
+
+	UINT8   iscsiFlags;		     /* 09 */
+   #define ISCSI_FLAG_RESIDUAL_UNDER         0x02
+   #define ISCSI_FLAG_RESIDUAL_OVER          0x04
+   #define ISCSI_FLAG_RESIDUAL_UNDER_BIREAD  0x08
+   #define ISCSI_FLAG_RESIDUAL_OVER_BIREAD   0x10
+
+	UINT8   iscsiResponse;		     /* 0A */
+   #define ISCSI_RSP_COMPLETE                    0x00
+   #define ISCSI_RSP_TARGET_FAILURE              0x01
+   #define ISCSI_RSP_DELIVERY_SUBSYS_FAILURE     0x02
+   #define ISCSI_RSP_UNSOLISITED_DATA_REJECT     0x03
+   #define ISCSI_RSP_NOT_ENOUGH_UNSOLISITED_DATA 0x04
+   #define ISCSI_RSP_CMD_IN_PROGRESS             0x05
+
+	UINT8   completionStatus;	     /* 0B */
+   #define SCS_COMPLETE                      0x00
+   #define SCS_INCOMPLETE                    0x01
+   #define SCS_DMA_ERROR                     0x02
+   #define SCS_TRANSPORT_ERROR               0x03
+   #define SCS_RESET_OCCURRED                0x04
+   #define SCS_ABORTED                       0x05
+   #define SCS_TIMEOUT                       0x06
+   #define SCS_DATA_OVERRUN                  0x07
+   #define SCS_DATA_DIRECTION_ERROR          0x08
+   #define SCS_DATA_UNDERRUN                 0x15
+   #define SCS_QUEUE_FULL                    0x1C
+   #define SCS_DEVICE_UNAVAILABLE            0x28
+   #define SCS_DEVICE_LOGGED_OUT             0x29
+   #define SCS_DEVICE_CONFIG_CHANGED         0x2A
+
+	UINT8   reserved1;		     /* 0C */
+
+	/* state_flags MUST be at the same location as state_flags in the
+	   Command_T3/4_Entry */
+	UINT8   state_flags;		     /* 0D */
+   #define STATE_FLAG_SENT_COMMAND           0x01
+   #define STATE_FLAG_TRANSFERRED_DATA       0x02
+   #define STATE_FLAG_GOT_STATUS             0x04
+   #define STATE_FLAG_LOGOUT_SENT            0x10
+
+	UINT16  senseDataByteCnt;	     /* 0E-0F */
+	UINT32  residualByteCnt;	     /* 10-13 */
+	UINT32  bidiResidualByteCnt;	     /* 14-17 */
+	UINT32  expSeqNum;		     /* 18-1B */
+	UINT32  maxCmdSeqNum;		     /* 1C-1F */
+	UINT8   senseData[IOCB_MAX_SENSEDATA_LEN]; /* 20-3F */
+
+}STATUS_ENTRY;
+
+/*
+ * Performance Status Entry where up to 30 handles can be posted in a
+ * single IOSB. Handles are of 16 bit value.
+ */
+typedef struct  _PERFORMANCE_STATUS_ENTRY {
+	UINT8  entryType;
+	UINT8  entryCount;
+	UINT16 handleCount;
+
+   #define MAX_STATUS_HANDLE  30
+	UINT16 handleArray[ MAX_STATUS_HANDLE ];
+
+} PERFORMANCE_STATUS_ENTRY;
+
+
+typedef struct _IMMEDIATE_NOTIFY_ENTRY {
+	HEADER  hdr;
+	UINT32  handle;
+	UINT16  initiator;
+	UINT16  InitSessionID;
+	UINT16  ConnectionID;
+	UINT16  TargSessionID;
+	UINT16  inotStatus;
+   #define INOT_STATUS_ABORT_TASK      0x0020
+   #define INOT_STATUS_LOGIN_RECVD     0x0021
+   #define INOT_STATUS_LOGOUT_RECVD    0x0022
+   #define INOT_STATUS_LOGGED_OUT      0x0029
+   #define INOT_STATUS_RESTART_RECVD   0x0030
+   #define INOT_STATUS_MSG_RECVD       0x0036
+   #define INOT_STATUS_TSK_REASSIGN    0x0037
+
+	UINT16  taskFlags;
+   #define TASK_FLAG_CLEAR_ACA         0x4000
+   #define TASK_FLAG_COLD_RESET        0x2000
+   #define TASK_FLAG_WARM_RESET        0x0800
+   #define TASK_FLAG_LUN_RESET         0x1000
+   #define TASK_FLAG_CLEAR_TASK_SET    0x0400
+   #define TASK_FLAG_ABORT_TASK_SET    0x0200
+
+
+	UINT32  refTaskTag;
+	UINT8   lun[8];
+	UINT32  inotTaskTag;
+	UINT8   res3[RESERVED_BYTES_INOT];
+} IMMEDIATE_NOTIFY_ENTRY ;
+
+typedef struct _NOTIFY_ACK_ENTRY {
+	HEADER  hdr;
+	UINT32  handle;
+	UINT16  initiator;
+	UINT16  res1;
+	UINT16  flags;
+	UINT8        responseCode;
+	UINT8        qualifier;
+	UINT16  notAckStatus;
+	UINT16  taskFlags;
+   #define NACK_FLAG_RESPONSE_CODE_VALID 0x0010
+
+	UINT32  refTaskTag;
+	UINT8   lun[8];
+	UINT32  inotTaskTag;
+	UINT8   res3[RESERVED_BYTES_NOTACK];
+} NOTIFY_ACK_ENTRY ;
+
+typedef struct _ATIO_ENTRY {
+	HEADER  hdr;			  /* 00-03 */
+	UINT32  handle;			  /* 04-07 */
+	UINT16  initiator;		  /* 08-09 */
+	UINT16  connectionID;		  /* 0A-0B */
+	UINT32  taskTag;		  /* 0C-0f */
+	UINT8   scsiCDB[IOCB_MAX_CDB_LEN];     /* 10-1F */
+	UINT8   LUN[8];			  /* 20-27 */
+	UINT8   cmdRefNum;		  /* 28 */
+
+	UINT8   pduType;		  /* 29 */
+   #define PDU_TYPE_NOPOUT                0x00
+   #define PDU_TYPE_SCSI_CMD              0x01
+   #define PDU_TYPE_SCSI_TASK_MNGMT_CMD   0x02
+   #define PDU_TYPE_LOGIN_CMD             0x03
+   #define PDU_TYPE_TEXT_CMD              0x04
+   #define PDU_TYPE_SCSI_DATA             0x05
+   #define PDU_TYPE_LOGOUT_CMD            0x06
+   #define PDU_TYPE_SNACK                 0x10
+
+	UINT16  atioStatus;		  /* 2A-2B */
+   #define ATIO_CDB_RECVD                 0x003d
+
+	UINT16  reserved1;		  /* 2C-2D */
+
+	UINT8   taskCode;		  /* 2E */
+   #define ATIO_TASK_CODE_UNTAGGED        0x00
+   #define ATIO_TASK_CODE_SIMPLE_QUEUE    0x01
+   #define ATIO_TASK_CODE_ORDERED_QUEUE   0x02
+   #define ATIO_TASK_CODE_HEAD_OF_QUEUE   0x03
+   #define ATIO_TASK_CODE_ACA_QUEUE       0x04
+
+	UINT8   reserved2;		  /* 2F */
+	UINT32  totalByteCnt;		  /* 30-33 */
+	UINT32  cmdSeqNum;		  /* 34-37 */
+	UINT64  immDataBufDesc;		  /* 38-3F */
+} ATIO_ENTRY ;
+
+typedef struct _CTIO3_ENTRY {
+	HEADER  hdr;			  /* 00-03 */
+	UINT32  handle;			  /* 04-07 */
+	UINT16  initiator;		  /* 08-09 */
+	UINT16  connectionID;		  /* 0A-0B */
+	UINT32  taskTag;		  /* 0C-0F */
+
+	UINT8   flags;			  /* 10 */
+   #define CTIO_FLAG_SEND_SCSI_STATUS     0x01
+   #define CTIO_FLAG_TERMINATE_COMMAND    0x10
+   #define CTIO_FLAG_FAST_POST            0x08
+   #define CTIO_FLAG_FINAL_CTIO           0x80
+
+	/*  NOTE:  Our firmware assumes that the CTIO_FLAG_SEND_DATA and
+		   CTIO_FLAG_GET_DATA flags are in the same bit positions
+		   as the R and W bits in SCSI Command PDUs, so their values
+		   should not be changed!
+	 */
+   #define CTIO_FLAG_SEND_DATA            0x0040   /* (see note) Read Data Flag, send data to initiator       */
+   #define CTIO_FLAG_GET_DATA             0x0020   /* (see note) Write Data Flag, get data from the initiator */
+
+	UINT8   scsiStatus;		  /* 11 */
+	UINT16  timeout;		  /* 12-13 */
+	UINT32  offset;			  /* 14-17 */
+	UINT32  r2tSN;			  /* 18-1B */
+	UINT32  expCmdSN;		  /* 1C-1F */
+	UINT32  maxCmdSN;		  /* 20-23 */
+	UINT32  dataSN;			  /* 24-27 */
+	UINT32  residualCount;		  /* 28-2B */
+	UINT16  reserved;		  /* 2C-2D */
+	UINT16  segmentCnt;		  /* 2E-2F */
+	UINT32  totalByteCnt;		  /* 30-33 */
+	DATA_SEG_A64 dataseg[COMMAND_SEG_A64]; /* 34-3F */
+} CTIO3_ENTRY ;
+
+typedef struct _CTIO4_ENTRY {
+	HEADER  hdr;			  /* 00-03 */
+	UINT32  handle;			  /* 04-07 */
+	UINT16  initiator;		  /* 08-09 */
+	UINT16  connectionID;		  /* 0A-0B */
+	UINT32  taskTag;		  /* 0C-0F */
+	UINT8   flags;			  /* 10 */
+	UINT8   scsiStatus;		  /* 11 */
+	UINT16  timeout;		  /* 12-13 */
+	UINT32  offset;			  /* 14-17 */
+	UINT32  r2tSN;			  /* 18-1B */
+	UINT32  expCmdSN;		  /* 1C-1F */
+	UINT32  maxCmdSN;		  /* 20-23 */
+	UINT32  dataSN;			  /* 24-27 */
+	UINT32  residualCount;		  /* 28-2B */
+	UINT16  reserved;		  /* 2C-2D */
+	UINT16  segmentCnt;		  /* 2E-2F */
+	UINT32  totalByteCnt;		  /* 30-33 */
+	/* WE ONLY USE THE ADDRESS FROM THE FOLLOWING STRUCTURE THE COUNT FIELD IS
+	   RESERVED */
+	DATA_SEG_A64 dataseg[COMMAND_SEG_A64]; /* 34-3F */
+} CTIO4_ENTRY ;
+
+typedef struct _CTIO5_ENTRY {
+	HEADER  hdr;			  /* 00-03 */
+	UINT32  handle;			  /* 04-07 */
+	UINT16  initiator;		  /* 08-09 */
+	UINT16  connectionID;		  /* 0A-0B */
+	UINT32  taskTag;		  /* 0C-0F */
+	UINT8   response;		  /* 10 */
+	UINT8   scsiStatus;		  /* 11 */
+	UINT16  timeout;		  /* 12-13 */
+	UINT32  reserved1;		  /* 14-17 */
+	UINT32  expR2TSn;		  /* 18-1B */
+	UINT32  expCmdSn;		  /* 1C-1F */
+	UINT32  MaxCmdSn;		  /* 20-23 */
+	UINT32  expDataSn;		  /* 24-27 */
+	UINT32  residualCnt;		  /* 28-2B */
+	UINT32  bidiResidualCnt;	  /* 2C-2F */
+	UINT32  reserved2;		  /* 30-33 */
+	DATA_SEG_A64 dataseg[1];	  /* 34-3F */
+} CTIO5_ENTRY ;
+
+typedef struct _CTIO6_ENTRY {
+	HEADER  hdr;			  /* 00-03 */
+	UINT32  handle;			  /* 04-07 */
+	UINT16  initiator;		  /* 08-09 */
+	UINT16  connection;		  /* 0A-0B */
+	UINT32  taskTag;		  /* 0C-0F */
+	UINT16  flags;			  /* 10-11 */
+	UINT16  timeout;		  /* 12-13 */
+	UINT32  reserved1;		  /* 14-17 */
+	UINT64  reserved2;		  /* 18-1F */
+	UINT64  reserved3;		  /* 20-27 */
+	UINT64  reserved4;		  /* 28-2F */
+	UINT32  reserved5;		  /* 30-33 */
+	DATA_SEG_A64 dataseg[1];	  /* 34-3F */
+} CTIO6_ENTRY ;
+
+typedef struct _CTIO_STATUS_ENTRY {
+	HEADER  hdr;			  /* 00-03 */
+	UINT32  handle;			  /* 04-07 */
+	UINT16  initiator;		  /* 08-09 */
+	UINT16  connectionID;		  /* 0A-0B */
+	UINT32  taskTag;		  /* 0C-0F */
+	UINT16  status;			  /* 10-11 */
+   #define CTIO_STATUS_COMPLETE           0x0001
+   #define CTIO_STATUS_ABORTED            0x0002
+   #define CTIO_STATUS_DMA_ERROR          0x0003
+   #define CTIO_STATUS_ERROR              0x0004
+   #define CTIO_STATUS_INVALID_TAG        0x0008
+   #define CTIO_STATUS_DATA_OVERRUN       0x0009
+   #define CTIO_STATUS_CMD_TIMEOUT        0x000B
+   #define CTIO_STATUS_PCI_ERROR          0x0010
+   #define CTIO_STATUS_DATA_UNDERRUN      0x0015
+   #define CTIO_STATUS_TARGET_RESET       0x0017
+   #define CTIO_STATUS_NO_CONNECTION      0x0028
+   #define CTIO_STATUS_LOGGED_OUT         0x0029
+   #define CTIO_STATUS_CONFIG_CHANGED     0x002A
+   #define CTIO_STATUS_UNACK_EVENT        0x0035
+   #define CTIO_STATUS_INVALID_DATA_XFER  0x0036
+
+	UINT16  timeout;		  /* 12-13 */
+	UINT32  reserved1;		  /* 14-17 */
+	UINT32  expR2TSN;		  /* 18-1B */
+	UINT32  reserved2;		  /* 1C-1F */
+	UINT32  reserved3;		  /* 20-23 */
+	UINT64  expDataSN;		  /* 24-27 */
+	UINT32  residualCount;		  /* 28-2B */
+	UINT32  reserved4;		  /* 2C-2F */
+	UINT64  reserved5;		  /* 30-37 */
+	UINT64  reserved6;		  /* 38-3F */
+} CTIO_STATUS_ENTRY ;
+
+typedef struct _MAILBOX_ENTRY {
+	HEADER  hdr;
+	UINT32  handle;
+	UINT32  mbx[MAX_MBX_COUNT];
+} MAILBOX_ENTRY ;
+
+typedef struct MAILBOX_STATUS_ENTRY {
+	HEADER  hdr;
+	UINT32  handle;
+	UINT32  mbx[MAX_MBX_COUNT];
+} MAILBOX_STATUS_ENTRY ;
+
+
+typedef struct _PDU_ENTRY {
+	UINT8       *Buff;
+	UINT32       BuffLen;
+	UINT32       SendBuffLen;
+	UINT32       RecvBuffLen;
+	struct _PDU_ENTRY *Next;
+	dma_addr_t DmaBuff;
+} PDU_ENTRY, *PPDU_ENTRY;
+
+typedef struct _ISNS_DISCOVERED_TARGET_PORTAL {
+	UINT8       IPAddr[4];
+	UINT16      PortNumber;
+	UINT16      Reserved;
+} ISNS_DISCOVERED_TARGET_PORTAL, *PISNS_DISCOVERED_TARGET_PORTAL;
+
+typedef struct _ISNS_DISCOVERED_TARGET {
+	UINT32      NumPortals;		  /*  00-03 */
+#define ISNS_MAX_PORTALS 4
+	ISNS_DISCOVERED_TARGET_PORTAL Portal[ISNS_MAX_PORTALS];	/* 04-23 */
+	UINT32      DDID;		  /*  24-27 */
+	UINT8       NameString[256];	  /*  28-127 */
+	UINT8       Alias[32];		  /* 128-147 */
+} ISNS_DISCOVERED_TARGET, *PISNS_DISCOVERED_TARGET;
+
+
+typedef struct _PASSTHRU0_ENTRY {
+	HEADER  hdr;			  /* 00-03 */
+	UINT32  handle;			  /* 04-07 */
+	UINT16  target;			  /* 08-09 */
+	UINT16  connectionID;		  /* 0A-0B */
+	#define ISNS_DEFAULT_SERVER_CONN_ID     ((uint16_t)0x8000)
+
+	UINT16  controlFlags;		  /* 0C-0D */
+	#define PT_FLAG_ETHERNET_FRAME   	0x8000
+	#define PT_FLAG_ISNS_PDU                0x8000
+	#define PT_FLAG_IP_DATAGRAM             0x4000
+	#define PT_FLAG_TCP_PACKET              0x2000
+	#define PT_FLAG_NETWORK_PDU             (PT_FLAG_ETHERNET_FRAME | PT_FLAG_IP_DATAGRAM | PT_FLAG_TCP_PACKET)
+	#define PT_FLAG_iSCSI_PDU               0x1000
+	#define PT_FLAG_SEND_BUFFER             0x0200
+	#define PT_FLAG_WAIT_4_RESPONSE         0x0100
+	#define PT_FLAG_NO_FAST_POST            0x0080
+
+	UINT16  timeout;		  /* 0E-0F */
+	#define PT_DEFAULT_TIMEOUT              30   /* seconds */
+
+	DATA_SEG_A64 outDataSeg64;	  /* 10-1B */
+	UINT32  res1;			  /* 1C-1F */
+	DATA_SEG_A64 inDataSeg64;	  /* 20-2B */
+	UINT8   res2[20];		  /* 2C-3F */
+} PASSTHRU0_ENTRY ;
+
+typedef struct _PASSTHRU1_ENTRY {
+	HEADER  hdr;			  /* 00-03 */
+	UINT32  handle;			  /* 04-07 */
+	UINT16  target;			  /* 08-09 */
+	UINT16  connectionID;		  /* 0A-0B */
+
+	UINT16  controlFlags;		  /* 0C-0D */
+   #define PT_FLAG_ETHERNET_FRAME         	0x8000
+   #define PT_FLAG_IP_DATAGRAM            	0x4000
+   #define PT_FLAG_TCP_PACKET             	0x2000
+   #define PT_FLAG_iSCSI_PDU              	0x1000
+   #define PT_FLAG_SEND_BUFFER            	0x0200
+   #define PT_FLAG_WAIT_4_REPONSE         	0x0100
+   #define PT_FLAG_NO_FAST_POST           	0x0080
+
+	UINT16  timeout;		  /* 0E-0F */
+	DATA_SEG_A64 outDSDList;	  /* 10-1B */
+	UINT32  outDSDCnt;		  /* 1C-1F */
+	DATA_SEG_A64 inDSDList;		  /* 20-2B */
+	UINT32  inDSDCnt;		  /* 2C-2F */
+	UINT8  res1;			  /* 30-3F */
+
+} PASSTHRU1_ENTRY ;
+
+typedef struct _PASSTHRU_STATUS_ENTRY {
+	HEADER  hdr;			  /* 00-03 */
+	UINT32  handle;			  /* 04-07 */
+	UINT16  target;			  /* 08-09 */
+	UINT16  connectionID;		  /* 0A-0B */
+
+	UINT8   completionStatus;	  /* 0C */
+   #define PASSTHRU_STATUS_COMPLETE       		0x01
+   #define PASSTHRU_STATUS_ERROR          		0x04
+   #define PASSTHRU_STATUS_INVALID_DATA_XFER            0x06
+   #define PASSTHRU_STATUS_CMD_TIMEOUT    		0x0B
+   #define PASSTHRU_STATUS_PCI_ERROR      		0x10
+   #define PASSTHRU_STATUS_NO_CONNECTION  		0x28
+
+	UINT8   residualFlags;		  /* 0D */
+   #define PASSTHRU_STATUS_DATAOUT_OVERRUN              0x01
+   #define PASSTHRU_STATUS_DATAOUT_UNDERRUN             0x02
+   #define PASSTHRU_STATUS_DATAIN_OVERRUN               0x04
+   #define PASSTHRU_STATUS_DATAIN_UNDERRUN              0x08
+
+	UINT16  timeout;		  /* 0E-0F */
+	UINT16  portNumber;		  /* 10-11 */
+	UINT8   res1[10];		  /* 12-1B */
+	UINT32  outResidual;		  /* 1C-1F */
+	UINT8   res2[12];		  /* 20-2B */
+	UINT32  inResidual;		  /* 2C-2F */
+	UINT8   res4[16];		  /* 30-3F */
+} PASSTHRU_STATUS_ENTRY ;
+
+typedef struct _ASYNCHMSG_ENTRY {
+	HEADER  hdr;
+	UINT32  handle;
+	UINT16  target;
+	UINT16  connectionID;
+	UINT8   lun[8];
+	UINT16  iSCSIEvent;
+   #define AMSG_iSCSI_EVENT_NO_EVENT                  0x0000
+   #define AMSG_iSCSI_EVENT_TARG_RESET                0x0001
+   #define AMSG_iSCSI_EVENT_TARGT_LOGOUT              0x0002
+   #define AMSG_iSCSI_EVENT_CONNECTION_DROPPED        0x0003
+   #define AMSG_ISCSI_EVENT_ALL_CONNECTIONS_DROPPED   0x0004
+
+	UINT16  SCSIEvent;
+   #define AMSG_NO_SCSI_EVENT                         0x0000
+   #define AMSG_SCSI_EVENT                            0x0001
+
+	UINT16  parameter1;
+	UINT16  parameter2;
+	UINT16  parameter3;
+	UINT32  expCmdSn;
+	UINT32  maxCmdSn;
+	UINT16  senseDataCnt;
+	UINT16  reserved;
+	UINT32  senseData[IOCB_MAX_SENSEDATA_LEN];
+} ASYNCHMSG_ENTRY ;
+
+/* Timer entry structure, this is an internal generated structure
+   which causes the QLA4000 initiator to send a NOP-OUT or the
+   QLA4000 target to send a NOP-IN */
+
+typedef struct _TIMER_ENTRY {
+	HEADER  hdr;		   /* 00-03 */
+
+	UINT32  handle;		   /* 04-07 */
+	UINT16  target;		   /* 08-09 */
+	UINT16  connection_id;	   /* 0A-0B */
+
+	UINT8   control_flags;	   /* 0C */
+
+	/* STATE FLAGS FIELD IS A PLACE HOLDER. THE FW WILL SET BITS IN THIS FIELD
+	   AS THE COMMAND IS PROCESSED. WHEN THE IOCB IS CHANGED TO AN IOSB THIS
+	   FIELD WILL HAVE THE STATE FLAGS SET PROPERLY.
+	*/
+	UINT8   state_flags;	   /* 0D */
+	UINT8   cmdRefNum;	   /* 0E */
+	UINT8   reserved1;	   /* 0F */
+	UINT8   cdb[IOCB_MAX_CDB_LEN];	   /* 10-1F */
+	UINT8   lun[8];		   /* 20-27 */
+	UINT32  cmdSeqNum;	   /* 28-2B */
+	UINT16  timeout;	   /* 2C-2D */
+	UINT16  dataSegCnt;	   /* 2E-2F */
+	UINT32  ttlByteCnt;	   /* 30-33 */
+	DATA_SEG_A64 dataseg[COMMAND_SEG_A64];	/* 34-3F */
+
+} TIMER_ENTRY;
+
+
+#endif /* _QLA4X_FW_H */
+
+/*
+ * Overrides for Emacs so that we almost follow Linus's tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 2
+ * c-brace-imaginary-offset: 0
+ * c-brace-offset: -2
+ * c-argdecl-indent: 2
+ * c-label-offset: -2
+ * c-continued-statement-offset: 2
+ * c-continued-brace-offset: 0
+ * indent-tabs-mode: nil
+ * tab-width: 8
+ * End:
+ */
+
diff --git a/drivers/scsi/qla4xxx/ql4_glbl.h b/drivers/scsi/qla4xxx/ql4_glbl.h
new file mode 100644
index 0000000..5ed7f27
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_glbl.h
@@ -0,0 +1,218 @@
+/******************************************************************************
+ *     Copyright (C)  2003 -2005 QLogic Corporation
+ * QLogic ISP4xxx Device Driver
+ *
+ * This program includes a device driver for Linux 2.6.x that may be
+ * distributed with QLogic hardware specific firmware binary file.
+ * You may modify and redistribute the device driver code under the
+ * GNU General Public License as published by the Free Software Foundation
+ * (version 2 or a later version) and/or under the following terms,
+ * as applicable:
+ *
+ * 	1. Redistribution of source code must retain the above copyright
+ *         notice, this list of conditions and the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above copyright
+ *         notice, this list of conditions and the following disclaimer in
+ *         the documentation and/or other materials provided with the
+ *         distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ * 	
+ * You may redistribute the hardware specific firmware binary file under
+ * the following terms:
+ * 	1. Redistribution of source code (only if applicable), must
+ *         retain the above copyright notice, this list of conditions and
+ *         the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above
+ *         copyright notice, this list of conditions and the following
+ *         disclaimer in the documentation and/or other materials provided
+ *         with the distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ *
+ * REGARDLESS OF WHAT LICENSING MECHANISM IS USED OR APPLICABLE,
+ * THIS PROGRAM IS PROVIDED BY QLOGIC CORPORATION "AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * USER ACKNOWLEDGES AND AGREES THAT USE OF THIS PROGRAM WILL NOT CREATE
+ * OR GIVE GROUNDS FOR A LICENSE BY IMPLICATION, ESTOPPEL, OR OTHERWISE
+ * IN ANY INTELLECTUAL PROPERTY RIGHTS (PATENT, COPYRIGHT, TRADE SECRET,
+ * MASK WORK, OR OTHER PROPRIETARY RIGHT) EMBODIED IN ANY OTHER QLOGIC
+ * HARDWARE OR SOFTWARE EITHER SOLELY OR IN COMBINATION WITH THIS PROGRAM
+ *
+ ******************************************************************************
+ * Global include file.
+ ****************************************************************************/
+#ifndef __QLA4x_GBL_H
+#define	__QLA4x_GBL_H
+
+#include <linux/interrupt.h>
+
+/*
+ * Defined in ql4_os.c
+ */
+
+extern void qla4xxx_start_io(scsi_qla_host_t *ha);
+extern srb_t *del_from_active_array(scsi_qla_host_t *ha, uint32_t index);
+extern uint8_t qla4xxx_complete_request(scsi_qla_host_t *ha, srb_t *srb);
+extern uint8_t qla4xxx_reset_lun(scsi_qla_host_t *ha, ddb_entry_t *ddb_entry, lun_entry_t *lun_entry);
+extern uint8_t qla4xxx_soft_reset(scsi_qla_host_t *);
+extern const char *host_sts_msg[];
+extern void qla4xxx_delete_timer_from_cmd(srb_t *srb);
+extern scsi_qla_host_t *qla4xxx_get_adapter_handle(uint16_t instance);
+extern uint32_t qla4xxx_get_hba_count(void);
+extern void qla4xxx_free_ddb_list(scsi_qla_host_t *ha);
+
+extern void qla4xxx_tgt_free(scsi_qla_host_t *ha, uint16_t t);
+extern os_tgt_t *qla4xxx_tgt_alloc(scsi_qla_host_t *, uint16_t);
+extern os_lun_t * qla4xxx_lun_alloc(scsi_qla_host_t *, uint16_t, uint16_t);
+extern void qla4xxx_extend_timeout(struct scsi_cmnd *cmd, int timeout);
+extern int qla4xxx_done(scsi_qla_host_t *old_ha);
+extern int qla4xxx_device_suspend( scsi_qla_host_t *, os_lun_t *, srb_t * );
+extern void qla4xxx_add_timer_to_cmd(srb_t *, int );
+extern int ql4xdontresethba;
+
+extern int extended_error_logging;
+/*
+ * Defined in  ql4_iocb.c
+ */
+extern uint8_t qla4xxx_send_marker(scsi_qla_host_t *ha, ddb_entry_t *ddb_entry, lun_entry_t *lun_entry);
+extern uint8_t qla4xxx_send_marker_iocb(scsi_qla_host_t *ha, ddb_entry_t *ddb_entry, lun_entry_t *lun_entry);
+
+extern uint8_t qla4xxx_get_req_pkt(scsi_qla_host_t *, QUEUE_ENTRY **);
+
+extern PDU_ENTRY *qla4xxx_get_pdu(scsi_qla_host_t *, uint32_t);
+extern void qla4xxx_free_pdu(scsi_qla_host_t *, PDU_ENTRY *);
+extern uint8_t qla4xxx_send_passthru0_iocb(scsi_qla_host_t *, uint16_t,
+    uint16_t, dma_addr_t, uint32_t, uint32_t, uint16_t, uint32_t);
+
+/*
+ * Defined in  ql4_isr.c
+ */
+
+extern irqreturn_t qla4xxx_intr_handler(int, void *, struct pt_regs *);
+extern void qla4xxx_interrupt_service_routine(scsi_qla_host_t *ha, uint32_t  intr_status);
+extern void __qla4xxx_suspend_lun(scsi_qla_host_t *ha, srb_t *srb, os_lun_t *lun_entry, uint16_t time,
+		    uint16_t retries, int delay);
+
+
+/*
+ * Defined in  ql4_init.c
+ */
+extern uint8_t qla4xxx_initialize_adapter(scsi_qla_host_t *ha, uint8_t renew_ddb_list);
+
+extern ddb_entry_t *qla4xxx_alloc_ddb(scsi_qla_host_t *ha, uint32_t fw_ddb_index);
+extern uint8_t qla4xxx_update_ddb_entry(scsi_qla_host_t *ha, ddb_entry_t
+    *ddb_entry, uint32_t fw_ddb_index);
+extern uint8_t qla4xxx_get_fwddb_entry(scsi_qla_host_t *ha, uint16_t fw_ddb_index, DEV_DB_ENTRY *fw_ddb_entry, dma_addr_t fw_ddb_entry_dma, uint32_t *num_valid_ddb_entries, uint32_t *next_ddb_index, uint32_t *fw_ddb_device_state, uint32_t *time2wait, uint16_t *tcp_source_port_num, uint16_t *connection_id);
+extern uint8_t qla4xxx_relogin_device(scsi_qla_host_t *ha, ddb_entry_t *ddb_entry);
+extern uint8_t qla4xxx_send_command_to_isp(scsi_qla_host_t *, srb_t *);
+extern int qla4xxx_get_prop_12chars(scsi_qla_host_t *ha, uint8_t *propname, uint8_t *propval, uint8_t *db);
+extern void qla4xxx_free_ddb(scsi_qla_host_t *ha, ddb_entry_t *ddb_entry);
+extern uint8_t qla4xxx_resize_ioctl_dma_buf(scsi_qla_host_t *ha, uint32_t size);
+extern uint8_t qla4xxx_set_ddb_entry(scsi_qla_host_t *ha, uint16_t fw_ddb_index, DEV_DB_ENTRY *fw_ddb_entry, dma_addr_t fw_ddb_entry_dma);
+extern uint8_t qla4xxx_conn_open_session_login(scsi_qla_host_t *ha,
+		      uint16_t        fw_ddb_index );
+extern uint8_t qla4xxx_process_ddb_changed(scsi_qla_host_t *ha, uint32_t fw_ddb_index, uint32_t state);
+extern uint8_t qla4xxx_init_rings(scsi_qla_host_t *ha);
+extern uint8_t qla4xxx_reinitialize_ddb_list(scsi_qla_host_t *ha);
+extern fc_lun_t * qla4xxx_add_fclun(fc_port_t *fcport, uint16_t lun);
+extern os_lun_t *
+qla4xxx_fclun_bind(scsi_qla_host_t *ha, fc_port_t *fcport, fc_lun_t *fclun);
+extern void qla4xxx_flush_all_srbs(scsi_qla_host_t *ha, ddb_entry_t *ddb_entry, os_lun_t *lun_entry);
+
+
+/*
+ * Defined in  ql4_mbx.c
+ */
+extern void qla4xxx_process_aen(scsi_qla_host_t *ha, uint8_t flush_ddb_chg_aens);
+extern uint8_t qla4xxx_mailbox_command(scsi_qla_host_t *ha, uint8_t inCount, uint8_t outCount, uint32_t *mbx_cmd, uint32_t *mbx_sts);
+extern uint8_t qla4xxx_issue_iocb(scsi_qla_host_t *ha, void*  buffer, dma_addr_t phys_addr, size_t size);
+
+extern uint8_t qla4xxx_isns_enable(scsi_qla_host_t *, uint32_t, uint16_t);
+extern uint8_t qla4xxx_isns_disable(scsi_qla_host_t *);
+
+extern uint8_t qla4xxx_get_flash(scsi_qla_host_t *, dma_addr_t, uint32_t,
+    uint32_t);
+
+extern uint8_t qla4xxx_initialize_fw_cb(scsi_qla_host_t *);
+
+extern uint8_t qla4xxx_get_dhcp_ip_address(scsi_qla_host_t *);
+
+extern uint8_t qla4xxx_get_firmware_state(scsi_qla_host_t *);
+
+extern void qla4xxx_get_crash_record(scsi_qla_host_t *);
+
+extern uint8_t qla4xxx_conn_close_sess_logout(scsi_qla_host_t *, uint16_t,
+    uint16_t, uint16_t);
+
+extern uint8_t qla4xxx_clear_database_entry(scsi_qla_host_t *, uint16_t);
+
+extern uint8_t qla4xxx_get_fw_version(scsi_qla_host_t *ha);
+
+extern uint8_t qla4xxx_restore_factory_defaults(scsi_qla_host_t *ha, uint32_t, uint32_t);
+
+extern uint8_t qla4xxx_get_firmware_status(scsi_qla_host_t *ha);
+
+extern void qla4xxx_get_conn_event_log(scsi_qla_host_t *ha);
+
+
+/*
+ * Defined in  ql4_inioct.c
+ */
+extern void qla4xxx_iocb_pass_done(scsi_qla_host_t *ha, PASSTHRU_STATUS_ENTRY *sts_entry);
+
+/*
+ * Defined in  ql4_xioct.c
+ */
+extern void qla4xxx_scsi_pass_done(struct scsi_cmnd *cmd);
+extern void qla4xxx_ioctl_sem_init (scsi_qla_host_t *ha);
+
+
+/*
+ * Defined in  ql4_isns.c
+ */
+extern uint8_t qla4xxx_isns_process_response(scsi_qla_host_t *ha, PASSTHRU_STATUS_ENTRY *sts_entry);
+
+extern uint8_t
+qla4xxx_isns_restart_service_completion(scsi_qla_host_t *ha,
+					uint32_t isns_ip_addr,
+					uint16_t isns_server_port_num);
+extern uint8_t qla4xxx_isns_restart_service(scsi_qla_host_t *);
+
+extern uint8_t qla4xxx_isns_init_attributes(scsi_qla_host_t *);
+
+extern uint8_t qla4xxx_isns_reenable(scsi_qla_host_t *, uint32_t, uint16_t);
+
+extern void qla4xxx_isns_enable_callback(scsi_qla_host_t *, uint32_t, uint32_t,
+    uint32_t, uint32_t);
+extern uint8_t qla4xxx_isns_get_server_request(scsi_qla_host_t *, uint32_t,
+    uint16_t);
+
+	/*
+ * Defined in  ql4_nvram.c
+	 */
+
+extern u16 RD_NVRAM_WORD(scsi_qla_host_t *, int);
+extern uint8_t qla4xxx_is_NVRAM_configuration_valid(scsi_qla_host_t *ha);
+extern int ql4xxx_sem_lock(scsi_qla_host_t *ha, u32 sem_mask, u32 sem_bits) ;
+extern void ql4xxx_sem_unlock(scsi_qla_host_t *ha, u32 sem_mask) ;
+extern int ql4xxx_sem_spinlock(scsi_qla_host_t *ha, u32 sem_mask, u32 sem_bits) ;
+
+/*
+ * Defined in  ql4_dbg.c
+ */
+extern void qla4xxx_dump_buffer(uint8_t *, uint32_t);
+
+#endif /* _QLA4x_GBL_H */
diff --git a/drivers/scsi/qla4xxx/ql4_init.c b/drivers/scsi/qla4xxx/ql4_init.c
new file mode 100644
index 0000000..d4053ed
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_init.c
@@ -0,0 +1,3013 @@
+/******************************************************************************
+ *     Copyright (C)  2003 -2005 QLogic Corporation
+ * QLogic ISP4xxx Device Driver
+ *
+ * This program includes a device driver for Linux 2.6.x that may be
+ * distributed with QLogic hardware specific firmware binary file.
+ * You may modify and redistribute the device driver code under the
+ * GNU General Public License as published by the Free Software Foundation
+ * (version 2 or a later version) and/or under the following terms,
+ * as applicable:
+ *
+ * 	1. Redistribution of source code must retain the above copyright
+ *         notice, this list of conditions and the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above copyright
+ *         notice, this list of conditions and the following disclaimer in
+ *         the documentation and/or other materials provided with the
+ *         distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ * 	
+ * You may redistribute the hardware specific firmware binary file under
+ * the following terms:
+ * 	1. Redistribution of source code (only if applicable), must
+ *         retain the above copyright notice, this list of conditions and
+ *         the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above
+ *         copyright notice, this list of conditions and the following
+ *         disclaimer in the documentation and/or other materials provided
+ *         with the distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ *
+ * REGARDLESS OF WHAT LICENSING MECHANISM IS USED OR APPLICABLE,
+ * THIS PROGRAM IS PROVIDED BY QLOGIC CORPORATION "AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * USER ACKNOWLEDGES AND AGREES THAT USE OF THIS PROGRAM WILL NOT CREATE
+ * OR GIVE GROUNDS FOR A LICENSE BY IMPLICATION, ESTOPPEL, OR OTHERWISE
+ * IN ANY INTELLECTUAL PROPERTY RIGHTS (PATENT, COPYRIGHT, TRADE SECRET,
+ * MASK WORK, OR OTHER PROPRIETARY RIGHT) EMBODIED IN ANY OTHER QLOGIC
+ * HARDWARE OR SOFTWARE EITHER SOLELY OR IN COMBINATION WITH THIS PROGRAM
+ *
+ ******************************************************************************
+ *             Please see release.txt for revision history.                   *
+ *                                                                            *
+ ******************************************************************************
+ * Function Table of Contents:
+ *      qla4xxx_alloc_dma_memory
+ *      qla4xxx_free_dma_memory
+ *      qla4xxx_free_lun
+ *      qla4xxx_free_ddb
+ *      qla4xxx_free_ddb_list
+ *      qla4xxx_init_rings
+ *      qla4xxx_validate_mac_address
+ *	qla4xxx_init_local_data
+ *      qla4xxx_init_firmware
+ *      qla4xxx_send_internal_scsi_passthru
+ *      qla4xxx_send_inquiry_cmd
+ *      qla4xxx_send_report_luns_cmd
+ *	qla4xxx_is_discovered_target
+ *      qla4xxx_update_ddb_entry
+ *      qla4xxx_alloc_lun
+ *      qla4xxx_discover_target_luns
+ *      qla4xxx_map_targets_to_ddbs
+ *      qla4xxx_alloc_ddb
+ *      qla4xxx_build_ddb_list
+ *      qla4xxx_initialize_ddb_list
+ *      qla4xxx_reinitialize_ddb_list
+ *      qla4xxx_relogin_device
+ *	qla4xxx_get_topcat_presence
+ *	qla4xxx_start_firmware
+ *      qla4xxx_initialize_adapter
+ *      qla4xxx_find_propname
+ *      qla4xxx_get_prop_12chars
+ *	qla4xxx_add_device_dynamically
+ *	qla4xxx_process_ddb_changed
+ *	qla4xxx_login_device
+ *	qla4xxx_logout_device
+ *	qla4xxx_flush_all_srbs
+ *	qla4xxx_delete_device
+ ****************************************************************************/
+
+#include "ql4_def.h"
+
+#include <linux/delay.h>
+
+/*
+ *  External Function Prototypes.
+ */
+extern int ql4xdiscoverywait;
+extern char *ql4xdevconf;
+
+/*
+ * Local routines
+ */
+static fc_port_t *
+qla4xxx_find_or_alloc_fcport(scsi_qla_host_t *ha, ddb_entry_t *ddb_entry);
+static void qla4xxx_config_os(scsi_qla_host_t *ha);
+static uint16_t
+qla4xxx_fcport_bind(scsi_qla_host_t *ha, fc_port_t *fcport);
+os_lun_t *
+qla4xxx_fclun_bind(scsi_qla_host_t *ha, fc_port_t *fcport, fc_lun_t *fclun);
+os_tgt_t *
+qla4xxx_tgt_alloc(scsi_qla_host_t *ha, uint16_t tgt);
+void
+qla4xxx_tgt_free(scsi_qla_host_t *ha, uint16_t tgt);
+os_lun_t *
+qla4xxx_lun_alloc(scsi_qla_host_t *ha, uint16_t tgt, uint16_t lun);
+static void
+qla4xxx_lun_free(scsi_qla_host_t *ha, uint16_t tgt, uint16_t lun);
+fc_lun_t *
+qla4xxx_add_fclun(fc_port_t *fcport, uint16_t lun);
+static ddb_entry_t *
+qla4xxx_get_ddb_entry(scsi_qla_host_t *ha, uint32_t fw_ddb_index);
+
+
+void ql4xxx_set_mac_number(scsi_qla_host_t * ha)
+{
+    uint32_t                     value;
+    uint8_t                      func_number;
+    unsigned long	flags;
+
+    /* Get the function number */
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	value = RD_REG_DWORD(&ha->reg->ctrl_status);
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+    	func_number = (uint8_t)((value >> 4) & 0x30);
+	switch (value & ISP_CONTROL_FN_MASK) {
+        case ISP_CONTROL_FN0_SCSI:
+            ha->mac_index = 1;
+            break;
+        case ISP_CONTROL_FN1_SCSI:
+            ha->mac_index = 3;
+            break;
+        default:
+            DEBUG2(printk("scsi%d: %s: Invalid function number, ispControlStatus = 0x%x\n",
+			  ha->host_no, __func__,value));
+            break;
+    }
+	DEBUG2(printk("scsi%d: %s: mac_index %d.\n",  ha->host_no,__func__,ha->mac_index)) ;
+}
+
+/**
+ * qla4xxx_alloc_fcport() - Allocate a generic fcport.
+ * @ha: HA context
+ * @flags: allocation flags
+ *
+ * Returns a pointer to the allocated fcport, or NULL, if none available.
+ */
+static fc_port_t *
+qla4xxx_alloc_fcport(scsi_qla_host_t *ha, int flags)
+{
+	fc_port_t *fcport;
+
+	fcport = kmalloc(sizeof(fc_port_t), flags);
+	if (fcport == NULL)
+		return(fcport);
+
+	/* Setup fcport template structure. */
+	memset(fcport, 0, sizeof (fc_port_t));
+	fcport->ha = ha;
+	fcport->port_type = FCT_UNKNOWN;
+	atomic_set(&fcport->state, FCS_DEVICE_DEAD);
+	fcport->flags = FCF_RLC_SUPPORT;
+	INIT_LIST_HEAD(&fcport->fcluns);
+
+	return(fcport);
+}
+
+/*
+* qla4xxx_init_tgt_map
+*      Initializes target map.
+*
+* Input:
+*      ha = adapter block pointer.
+*
+* Output:
+*      TGT_Q initialized
+*/
+static void
+qla4xxx_init_tgt_map(scsi_qla_host_t *ha)
+{
+	uint32_t t;
+
+	ENTER(__func__);
+
+	for (t = 0; t < MAX_TARGETS; t++)
+		TGT_Q(ha, t) = (os_tgt_t *) NULL;
+
+	LEAVE(__func__);
+}
+
+
+
+
+/*
+ * qla4xxx_update_fcport
+ *	Updates device on list.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	fcport = port structure pointer.
+ *
+ * Return:
+ *	0  - Success
+ *  BIT_0 - error
+ *
+ * Context:
+ *	Kernel context.
+ */
+static void
+qla4xxx_update_fcport(scsi_qla_host_t *ha, fc_port_t *fcport)
+{
+#if 0
+	uint16_t        index;
+	unsigned long flags;
+	srb_t *sp;
+#endif
+
+	if (fcport == NULL)
+		return;
+
+	ENTER(__func__);
+	fcport->ha = ha;
+
+	/* XXX need to get this info from option field of DDB entry */
+	fcport->port_type = FCT_TARGET;
+	fcport->iscsi_name = fcport->ddbptr->iscsi_name;
+
+	/*
+	 * Check for outstanding cmd on tape Bypass LUN discovery if active
+	 * command on tape.
+	 */
+#if 0
+	if (fcport->flags & FCF_TAPE_PRESENT) {
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+		for (index = 1; index < MAX_OUTSTANDING_COMMANDS; index++) {
+			if ((sp = ha->outstanding_cmds[index]) != 0) {
+				if (sp->fclun->fcport == fcport) {
+					atomic_set(&fcport->state, FCS_ONLINE);
+					spin_unlock_irqrestore(
+							      &ha->hardware_lock, flags);
+					return;
+				}
+			}
+		}
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+	}
+#endif
+
+	/* Always set online */
+	atomic_set(&fcport->state, FCS_ONLINE);
+	LEAVE(__func__);
+}
+
+
+
+/*
+ * qla4xxx_add_fclun
+ *	Adds LUN to database
+ *
+ * Input:
+ *	fcport:		FC port structure pointer.
+ *	lun:		LUN number.
+ *
+ * Context:
+ *	Kernel context.
+ */
+fc_lun_t *
+qla4xxx_add_fclun(fc_port_t *fcport, uint16_t lun)
+{
+	int             found;
+	fc_lun_t        *fclun;
+
+	if (fcport == NULL) {
+		DEBUG2(printk("scsi: %s: Unable to add lun to NULL port\n", __func__));
+		return(NULL);
+	}
+
+	/* Allocate LUN if not already allocated. */
+	found = 0;
+	list_for_each_entry(fclun, &fcport->fcluns, list) {
+		if (fclun->lun == lun) {
+			found++;
+			break;
+		}
+	}
+	if (found) {
+		return(fclun);
+	}
+
+	fclun = kmalloc(sizeof(fc_lun_t), GFP_ATOMIC);
+	if (fclun == NULL) {
+		printk(KERN_WARNING
+		       "%s(): Memory Allocation failed - FCLUN\n",
+		       __func__);
+		return(NULL);
+	}
+
+	/* Setup LUN structure. */
+	memset(fclun, 0, sizeof(fc_lun_t));
+	fclun->lun = lun;
+	fclun->fcport = fcport;
+	fclun->device_type = fcport->device_type;
+
+	list_add_tail(&fclun->list, &fcport->fcluns);
+
+	return(fclun);
+}
+
+
+
+
+/*
+ * qla4xxx_config_os
+ *	Setup OS target and LUN structures.
+ *
+ * Input:
+ *	ha = adapter state pointer.
+ *
+ * Context:
+ *	Kernel context.
+ */
+static void
+qla4xxx_config_os(scsi_qla_host_t *ha)
+{
+	fc_port_t       *fcport;
+	fc_lun_t        *fclun;
+	os_tgt_t        *tq;
+	uint16_t        tgt;
+
+
+	for (tgt = 0; tgt < MAX_TARGETS; tgt++) {
+		if ((tq = TGT_Q(ha, tgt)) == NULL)
+			continue;
+
+		tq->flags &= ~TQF_ONLINE;
+	}
+
+	list_for_each_entry(fcport, &ha->fcports, list)
+	{
+		if (atomic_read(&fcport->state) != FCS_ONLINE) {
+			fcport->os_target_id = MAX_TARGETS;
+			continue;
+		}
+
+		/* Bind FC port to OS target number. */
+		if (qla4xxx_fcport_bind(ha, fcport) == MAX_TARGETS) {
+			continue;
+		}
+
+		/* Bind FC LUN to OS LUN number. */
+		list_for_each_entry(fclun, &fcport->fcluns, list)
+		{
+			qla4xxx_fclun_bind(ha, fcport, fclun);
+		}
+	}
+}
+
+/*
+ * qla4xxx_fcport_bind
+ *	Locates a target number for FC port.
+ *
+ * Input:
+ *	ha = adapter state pointer.
+ *	fcport = FC port structure pointer.
+ *
+ * Returns:
+ *	target number
+ *
+ * Context:
+ *	Kernel context.
+ */
+static uint16_t
+qla4xxx_fcport_bind(scsi_qla_host_t *ha, fc_port_t *fcport)
+{
+	uint16_t        tgt;
+	os_tgt_t        *tq = NULL;
+
+	if (fcport->ddbptr == NULL)
+		return(MAX_TARGETS);
+
+	/* Check for persistent binding. */
+	for (tgt = 0; tgt < MAX_TARGETS; tgt++) {
+		if ((tq = TGT_Q(ha, tgt)) == NULL)
+			continue;
+
+		if (memcmp(fcport->ddbptr->iscsi_name, tq->iscsi_name,
+			   ISCSI_NAME_SIZE) == 0) {
+			break;
+		}
+	}
+	/* TODO: honor the ConfigRequired flag */
+	if (tgt == MAX_TARGETS) {
+		tgt = 0;
+
+		/* Check if targetID 0 available. */
+		if (TGT_Q(ha, tgt) != NULL) {
+			/* Locate first free target for device. */
+			for (tgt = 0; tgt < MAX_TARGETS; tgt++) {
+				if (TGT_Q(ha, tgt) == NULL) {
+					break;
+				}
+			}
+		}
+		if (tgt != MAX_TARGETS) {
+			if ((tq = qla4xxx_tgt_alloc(ha, tgt)) != NULL) {
+				memcpy(tq->iscsi_name, fcport->ddbptr->iscsi_name,
+				       ISCSI_NAME_SIZE);
+			}
+		}
+	}
+
+	/* Reset target numbers incase it changed. */
+	fcport->os_target_id = tgt;
+	if (tgt != MAX_TARGETS && tq != NULL) {
+		DEBUG2(printk("scsi%d: %s: Assigning target ID=%02d @ %p to "
+			      "ddb[%d], fcport %p, port state=0x%x, port down retry=%d\n",
+			      ha->host_no, __func__, tgt, tq,
+			      fcport->ddbptr->fw_ddb_index,
+			      fcport,
+			      atomic_read(&fcport->state),
+			      atomic_read(&fcport->ddbptr->port_down_timer)));
+
+		fcport->ddbptr->target = tgt;
+		fcport->tgt_queue = tq;
+		fcport->flags |= FCF_PERSISTENT_BOUND;
+		tq->fcport = fcport;
+		tq->flags |= TQF_ONLINE;
+		tq->id = tgt;
+	}
+
+	if (tgt == MAX_TARGETS) {
+		QL4PRINT(QLP2, printk(KERN_WARNING
+				      "Unable to bind fcport, loop_id=%x\n", fcport->loop_id));
+	}
+
+	return(tgt);
+}
+
+/*
+ * qla4xxx_fclun_bind
+ *	Binds all FC device LUNS to OS LUNS.
+ *
+ * Input:
+ *	ha:		adapter state pointer.
+ *	fcport:		FC port structure pointer.
+ *
+ * Returns:
+ *	target number
+ *
+ * Context:
+ *	Kernel context.
+ */
+os_lun_t *
+qla4xxx_fclun_bind(scsi_qla_host_t *ha, fc_port_t *fcport, fc_lun_t *fclun)
+{
+	os_lun_t        *lq;
+	uint16_t        tgt;
+	uint16_t        lun;
+
+	tgt = fcport->os_target_id;
+	lun = fclun->lun;
+
+	/* Allocate LUNs */
+	if (lun >= MAX_LUNS) {
+		DEBUG2(printk("scsi%d: %s: Unable to bind lun, invalid "
+			      "lun=(%x).\n", ha->host_no, __func__, lun));
+		return(NULL);
+	}
+
+	if ((lq = qla4xxx_lun_alloc(ha, tgt, lun)) == NULL) {
+		printk(KERN_WARNING "scso%d: %s: Unable to bind fclun, lun=%x\n",
+		       ha->host_no, __func__, lun);
+		return(NULL);
+	}
+
+	lq->fclun = fclun;
+
+	return(lq);
+}
+
+/*
+ * qla4xxx_tgt_alloc
+ *	Allocate and pre-initialize target queue.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	t = SCSI target number.
+ *
+ * Returns:
+ *	NULL = failure
+ *
+ * Context:
+ *	Kernel context.
+ */
+os_tgt_t *
+qla4xxx_tgt_alloc(scsi_qla_host_t *ha, uint16_t tgt)
+{
+	os_tgt_t        *tq;
+
+	/*
+	 * If SCSI addressing OK, allocate TGT queue and lock.
+	 */
+	if (tgt >= MAX_TARGETS) {
+		DEBUG2(printk("scsi%d: %s: Unable to allocate target, invalid "
+			      "target number %d.\n", ha->host_no, __func__, tgt));
+		return(NULL);
+	}
+
+	tq = TGT_Q(ha, tgt);
+	if (tq == NULL) {
+		tq = kmalloc(sizeof(os_tgt_t), GFP_ATOMIC);
+		if (tq != NULL) {
+			DEBUG3(printk("scsi%d: %s: Alloc Target %d @ %p\n",
+				      ha->host_no, __func__, tgt, tq));
+
+			memset(tq, 0, sizeof(os_tgt_t));
+			tq->ha = ha;
+
+			TGT_Q(ha, tgt) = tq;
+		}
+	}
+	if (tq != NULL) {
+		tq->port_down_retry_count = ha->port_down_retry_count;
+	}
+	else {
+		printk(KERN_WARNING "Unable to allocate target.\n");
+	}
+
+	return(tq);
+}
+
+/*
+ * qla4xxx_tgt_free
+ *	Frees target and LUN queues.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	t = SCSI target number.
+ *
+ * Context:
+ *	Kernel context.
+ */
+void
+qla4xxx_tgt_free(scsi_qla_host_t *ha, uint16_t tgt)
+{
+	os_tgt_t        *tq;
+	uint16_t        lun;
+
+	/*
+	 * If SCSI addressing OK, allocate TGT queue and lock.
+	 */
+	if (tgt >= MAX_TARGETS) {
+		DEBUG2(printk("scsi%d: %s: Unable to de-allocate target, "
+			      "invalid target number %d.\n", ha->host_no, __func__, tgt));
+
+		return;
+	}
+
+	tq = TGT_Q(ha, tgt);
+	if (tq != NULL) {
+		TGT_Q(ha, tgt) = NULL;
+
+		/* Free LUN structures. */
+		for (lun = 0; lun < MAX_LUNS; lun++)
+			qla4xxx_lun_free(ha, tgt, lun);
+
+		kfree(tq);
+	}
+
+	return;
+}
+
+/*
+ * qla4xxx_lun_alloc
+ *	Allocate and initialize LUN queue.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	t = SCSI target number.
+ *	l = LUN number.
+ *
+ * Returns:
+ *	NULL = failure
+ *
+ * Context:
+ *	Kernel context.
+ */
+os_lun_t *
+qla4xxx_lun_alloc(scsi_qla_host_t *ha, uint16_t tgt, uint16_t lun)
+{
+	os_lun_t        *lq;
+
+	/*
+	 * If SCSI addressing OK, allocate LUN queue.
+	 */
+	if (lun >= MAX_LUNS || TGT_Q(ha, tgt) == NULL) {
+		DEBUG2(printk("scsi%d: %s: Unable to allocate lun, invalid "
+			      "parameter.\n", ha->host_no, __func__));
+
+		return(NULL);
+	}
+
+	lq = LUN_Q(ha, tgt, lun);
+	if (lq == NULL) {
+		lq = kmalloc(sizeof(os_lun_t), GFP_ATOMIC);
+
+		if (lq != NULL) {
+			DEBUG3(printk("scsi%d: Alloc Lun %d @ tgt %d.\n",
+				      ha->host_no, lun, tgt));
+
+			memset(lq, 0, sizeof (os_lun_t));
+			LUN_Q(ha, tgt, lun) = lq;
+
+			/*
+			 * The following lun queue initialization code
+			 * must be duplicated in alloc_ioctl_mem function
+			 * for ioctl_lq.
+			 */
+			lq->lun_state = LS_LUN_READY;
+			spin_lock_init(&lq->lun_lock);
+			DEBUG2(printk("Allocating Lun %d @ %p \n",lun,lq);)
+		}
+	}
+
+	if (lq == NULL) {
+		printk(KERN_WARNING "Unable to allocate lun.\n");
+	}
+
+	return(lq);
+}
+
+/*
+ * qla4xxx_lun_free
+ *	Frees LUN queue.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	t = SCSI target number.
+ *
+ * Context:
+ *	Kernel context.
+ */
+static void
+qla4xxx_lun_free(scsi_qla_host_t *ha, uint16_t tgt, uint16_t lun)
+{
+	os_lun_t        *lq;
+
+	/*
+	 * If SCSI addressing OK, allocate TGT queue and lock.
+	 */
+	if (tgt >= MAX_TARGETS || lun >= MAX_LUNS) {
+		DEBUG2(printk("scsi%d: %s: Unable to deallocate lun, invalid "
+			      "parameter.\n", ha->host_no, __func__));
+
+		return;
+	}
+
+	if (TGT_Q(ha, tgt) != NULL && (lq = LUN_Q(ha, tgt, lun)) != NULL) {
+		LUN_Q(ha, tgt, lun) = NULL;
+		kfree(lq);
+	}
+
+	return;
+}
+
+/**************************************************************************
+ * qla4xxx_free_ddb
+ *	This routine deallocates and unlinks the specified ddb_entry from the
+ *	adapter's
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	ddb_entry - Pointer to device database entry
+ *
+ * Returns:
+ *	None
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+void
+qla4xxx_free_ddb(scsi_qla_host_t *ha, ddb_entry_t *ddb_entry)
+{
+	fc_port_t       *fcport;
+
+	ENTER("qla4xxx_free_ddb");
+
+	/* Remove device entry from list */
+	list_del_init(&ddb_entry->list_entry);
+
+	/* Remove device pointer from index mapping arrays */
+	ha->fw_ddb_index_map[ddb_entry->fw_ddb_index] = (ddb_entry_t *) INVALID_ENTRY;
+	ha->tot_ddbs--;
+
+	fcport = ddb_entry->fcport;
+	if (fcport) {
+		atomic_set(&fcport->state, FCS_DEVICE_DEAD);
+		fcport->ddbptr = NULL;
+	}
+
+	/* Free memory for device entry */
+	kfree(ddb_entry);
+	LEAVE("qla4xxx_free_ddb");
+}
+
+/**************************************************************************
+ * qla4xxx_free_ddb_list
+ *	This routine deallocates and removes all devices on the sppecified
+ *	adapter.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	None
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+void
+qla4xxx_free_ddb_list(scsi_qla_host_t *ha)
+{
+	struct list_head *ptr;
+	ddb_entry_t *ddb_entry;
+	fc_port_t       *fcport;
+
+	ENTER("qla4xxx_free_ddb_list");
+
+	while (!list_empty(&ha->ddb_list)) {
+		/* Remove device entry from head of list */
+		ptr = ha->ddb_list.next;
+		list_del_init(ptr);
+
+		/* Free memory for device entry */
+		ddb_entry = list_entry(ptr, ddb_entry_t, list_entry);
+		if (ddb_entry) {
+			fcport = ddb_entry->fcport;
+			if (fcport) {
+				atomic_set(&fcport->state, FCS_DEVICE_DEAD);
+				fcport->ddbptr = NULL;
+			}
+			kfree(ddb_entry);
+		}
+	}
+
+	LEAVE("qla4xxx_free_ddb_list");
+}
+
+/**************************************************************************
+ * qla4xxx_init_rings
+ *	This routine initializes the internal queues for the specified adapter.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Remarks:
+ *	The QLA4010 requires us to restart the queues at index 0.
+ *	The QLA4000 doesn't care, so just default to QLA4010's requirement.
+ * Returns:
+ *	QLA_SUCCESS - Always return success.
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_init_rings(scsi_qla_host_t *ha)
+{
+	uint16_t    i;
+	unsigned long flags = 0;
+
+	ENTER("qla4xxx_init_rings");
+
+	/* Initialize request queue. */
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	ha->request_out = 0;
+	ha->request_in = 0;
+	ha->request_ptr = &ha->request_ring[ha->request_in];
+	ha->req_q_count = REQUEST_QUEUE_DEPTH;
+
+	/* Initialize response queue. */
+	ha->response_in = 0;
+	ha->response_out = 0;
+	ha->response_ptr = &ha->response_ring[ha->response_out];
+
+	QL4PRINT(QLP7, printk("scsi%d: %s response_ptr=%p\n", ha->host_no,
+			      __func__, ha->response_ptr));
+
+	/*
+	 * Initialize DMA Shadow registers.  The firmware is really supposed to
+	 * take care of this, but on some uniprocessor systems, the shadow
+	 * registers aren't cleared-- causing the interrupt_handler to think
+	 * there are responses to be processed when there aren't.
+	 */
+	ha->shadow_regs->req_q_out = __constant_cpu_to_le32(0);
+	ha->shadow_regs->rsp_q_in = __constant_cpu_to_le32(0);
+	wmb();
+
+	WRT_REG_DWORD(&ha->reg->req_q_in, 0);
+	WRT_REG_DWORD(&ha->reg->rsp_q_out, 0);
+	PCI_POSTING(&ha->reg->rsp_q_out);
+
+	/* Initialize active array */
+	for (i = 0; i < MAX_SRBS; i++)
+		ha->active_srb_array[i] = 0;
+	ha->active_srb_count = 0;
+
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	LEAVE("qla4xxx_init_rings");
+
+	return(QLA_SUCCESS);
+}
+
+
+#define qla4xxx_mac_is_equal(mac1, mac2) (memcmp(mac1, mac2, MAC_ADDR_LEN) == 0)
+
+/**************************************************************************
+ * qla4xxx_validate_mac_address
+ *	This routine validates the M.A.C. Address(es) of the adapter
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully validated M.A.C. address
+ *	QLA_ERROR   - Failed to validate M.A.C. address
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static uint8_t
+qla4xxx_validate_mac_address(scsi_qla_host_t *ha)
+{
+	FLASH_SYS_INFO *sys_info = NULL;
+	dma_addr_t sys_info_dma;
+	uint8_t status = QLA_ERROR;
+
+	ENTER("qla4xxx_validate_mac_address");
+	sys_info = (FLASH_SYS_INFO *) pci_alloc_consistent(ha->pdev,
+							   sizeof(*sys_info),
+							   &sys_info_dma);
+	if (sys_info == NULL) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: Unable to allocate dma "
+				      "buffer.\n", ha->host_no, __func__));
+		goto exit_validate_mac;
+	}
+	memset(sys_info, 0, sizeof(*sys_info));
+
+	/* Get flash sys info */
+	if (qla4xxx_get_flash(ha, sys_info_dma, FLASH_OFFSET_SYS_INFO,
+			      sizeof(*sys_info)) != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: get_flash "
+				      "FLASH_OFFSET_SYS_INFO failed\n",
+				      ha->host_no, __func__));
+		goto exit_validate_mac;
+	}
+
+	/* Save M.A.C. address & serial_number */
+	memcpy(ha->my_mac, &sys_info->physAddr[0].address[0],
+	       MIN(sizeof(ha->my_mac), sizeof(sys_info->physAddr[0].address)));
+	memcpy(ha->serial_number, &sys_info->acSerialNumber,
+	       MIN(sizeof(ha->serial_number), sizeof(sys_info->acSerialNumber)));
+
+	/* Display Debug Print Info */
+	QL4PRINT(QLP10, printk("scsi%d: Flash Sys Info\n", ha->host_no));
+	qla4xxx_dump_bytes(QLP10, sys_info, sizeof(*sys_info));
+
+	/*
+	 * If configuration information was specified on the command line,
+	 * validate the mac address here.
+	 */
+	if (ql4xdevconf) {
+		char *propbuf;
+		uint8_t cfg_mac[MAC_ADDR_LEN];
+
+		propbuf = kmalloc(LINESIZE, GFP_ATOMIC);
+		if (propbuf == NULL) {
+			QL4PRINT(QLP2, printk("scsi%d: %s: Unable to "
+					      "allocate memory.\n",
+					      ha->host_no, __func__));
+			goto exit_validate_mac;
+		}
+
+		/* Get mac address from configuration file. */
+		sprintf(propbuf, "scsi-qla%d-mac", ha->instance);
+		qla4xxx_get_prop_12chars(ha, propbuf, &cfg_mac[0], ql4xdevconf);
+
+		if (qla4xxx_mac_is_equal(&ha->my_mac, cfg_mac)) {
+			QL4PRINT(QLP7, printk("scsi%d: %s: This is a "
+					      "registered adapter.\n",
+					      ha->host_no, __func__));
+			status = QLA_SUCCESS;
+		} else {
+			QL4PRINT(QLP7, printk("scsi%d: %s: This is NOT a "
+					      "registered adapter.\n",
+					      ha->host_no, __func__));
+		}
+		kfree(propbuf);
+	} else {
+		status = QLA_SUCCESS;
+	}
+
+	exit_validate_mac:
+	if (sys_info)
+		pci_free_consistent(ha->pdev, sizeof(*sys_info), sys_info,
+				    sys_info_dma);
+
+	LEAVE("qla4xxx_validate_mac_address");
+
+	return(status);
+}
+
+/**************************************************************************
+ * qla4xxx_init_local_data
+ *	This routine initializes the local data for the specified adapter.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully initialized local data
+ *	QLA_ERROR   - Failed to initialize local data
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static uint8_t
+qla4xxx_init_local_data(scsi_qla_host_t *ha)
+{
+	int i;
+
+	/* Initialize passthru PDU list */
+	for (i = 0; i < (MAX_PDU_ENTRIES - 1); i++) {
+		ha->pdu_queue[i].Next = &ha->pdu_queue[i+1];
+	}
+	ha->free_pdu_top = &ha->pdu_queue[0];
+	ha->free_pdu_bottom = &ha->pdu_queue[MAX_PDU_ENTRIES - 1];
+	ha->free_pdu_bottom->Next = NULL;
+	ha->pdu_active = 0;
+
+	/* Initilize aen queue */
+	ha->aen_count = 0;
+	ha->aen_report = 0;
+
+	/* Initialize local iSNS data */
+	qla4xxx_isns_init_attributes(ha);
+	ha->isns_flags = 0;
+	atomic_set(&ha->isns_restart_timer, 0);
+	ha->isns_connection_id = 0;
+	ha->isns_remote_port_num = 0;
+	ha->isns_scn_port_num = 0;
+	ha->isns_esi_port_num = 0;
+	ha->isns_nsh_port_num = 0;
+	memset(ha->isns_entity_id, 0, sizeof(ha->isns_entity_id));
+	ha->isns_num_discovered_targets = 0;
+
+	return(qla4xxx_get_firmware_status(ha));
+}
+
+static int
+qla4xxx_fw_ready ( scsi_qla_host_t *ha )
+{
+	uint32_t timeout_count;
+	int     ready = 0;
+
+	ql4_printk(KERN_INFO, ha,
+		   "Waiting for Firmware Ready..\n");
+	for (timeout_count = ADAPTER_INIT_TOV; timeout_count > 0;
+	    timeout_count--) {
+
+		if (test_and_clear_bit(DPC_GET_DHCP_IP_ADDR, &ha->dpc_flags))
+			qla4xxx_get_dhcp_ip_address(ha);
+
+		/* Get firmware state. */
+		if (qla4xxx_get_firmware_state(ha) != QLA_SUCCESS) {
+			DEBUG2(printk("scsi%d: %s: unable to get "
+				      "firmware state\n", ha->host_no, __func__));
+			LEAVE("qla4xxx_init_firmware");
+			break;
+
+		}
+
+		if (ha->firmware_state & FW_STATE_ERROR) {
+			DEBUG2(printk("scsi%d: %s: an unrecoverable "
+				      "error has occurred\n", ha->host_no, __func__));
+			LEAVE("qla4xxx_init_firmware");
+			break;
+
+		}
+		if (ha->firmware_state & FW_STATE_CONFIG_WAIT) {
+			/*
+			 * The firmware has not yet been issued an Initialize
+			 * Firmware command, so issue it now.
+			 */
+			if (qla4xxx_initialize_fw_cb(ha) == QLA_ERROR) {
+				LEAVE("qla4xxx_init_firmware");
+				break;
+			}
+
+			/* Go back and test for ready state - no wait. */
+			continue;
+		}
+
+		if (ha->firmware_state & FW_STATE_WAIT_LOGIN) {
+			QL4PRINT(QLP7, printk("scsi%d: %s: fwstate:"
+					      "LOGIN in progress\n", ha->host_no, __func__));
+		}
+
+		if (ha->firmware_state & FW_STATE_DHCP_IN_PROGRESS) {
+			QL4PRINT(QLP7, printk("scsi%d: %s: fwstate: DHCP in progress\n",
+					      ha->host_no, __func__));
+		}
+
+		if (ha->firmware_state == FW_STATE_READY) {
+			ql4_printk(KERN_INFO, ha, "Firmware Ready..\n");
+			/* The firmware is ready to process SCSI commands. */
+			QL4PRINT(QLP7, printk("scsi%d: %s: FW STATE - READY\n",
+					      ha->host_no, __func__));
+			QL4PRINT(QLP7, printk("scsi%d: %s: MEDIA TYPE - %s\n",
+					      ha->host_no, __func__,
+					      ((ha->addl_fw_state & FW_ADDSTATE_OPTICAL_MEDIA) !=
+					       0) ? "OPTICAL" : "COPPER"));
+			QL4PRINT(QLP7, printk("scsi%d: %s: DHCP STATE Enabled "
+					      "%s\n", ha->host_no, __func__,
+					      ((ha->addl_fw_state & FW_ADDSTATE_DHCP_ENABLED) !=
+					       0) ? "YES" : "NO"));
+			QL4PRINT(QLP7, printk("scsi%d: %s: DHCP STATE Lease "
+					      "Acquired  %s\n", ha->host_no, __func__,
+					      ((ha->addl_fw_state &
+						FW_ADDSTATE_DHCP_LEASE_ACQUIRED) != 0) ?
+					      "YES" : "NO"));
+			QL4PRINT(QLP7, printk("scsi%d: %s: DHCP STATE Lease "
+					      "Expired  %s\n", ha->host_no, __func__,
+					      ((ha->addl_fw_state &
+						FW_ADDSTATE_DHCP_LEASE_EXPIRED) != 0) ?
+					      "YES" : "NO"));
+			QL4PRINT(QLP7, printk("scsi%d: %s: LINK  %s\n",
+					      ha->host_no, __func__,
+					      ((ha->addl_fw_state & FW_ADDSTATE_LINK_UP) != 0) ?
+					      "UP" : "DOWN"));
+			QL4PRINT(QLP7, printk("scsi%d: %s: iSNS Service "
+					      "Started  %s\n", ha->host_no, __func__,
+					      ((ha->addl_fw_state &
+						FW_ADDSTATE_ISNS_SVC_ENABLED) != 0) ?
+					      "YES" : "NO"));
+			if (test_bit(AF_TOPCAT_CHIP_PRESENT, &ha->flags)) {
+				QL4PRINT(QLP7, printk("scsi%d: %s: QLA4040 TopCat "
+						      "Initialized  %s\n", ha->host_no, __func__,
+						      ((ha->addl_fw_state &
+							FW_ADDSTATE_TOPCAT_NOT_INITIALIZED) != 0) ?
+						      "NO" : "YES"));
+			}
+			ready = 1;
+
+			/* If iSNS is enabled, start the iSNS service now. */
+			if ((ha->tcp_options & TOPT_ISNS_ENABLE) &&
+			    !IPAddrIsZero(ha->isns_ip_address)) {
+				uint32_t ip_addr = 0;
+
+				IPAddr2Uint32(ha->isns_ip_address, &ip_addr);
+				ql4_printk(KERN_INFO, ha, "Initializing ISNS..\n");
+				qla4xxx_isns_reenable(ha, ip_addr, ha->isns_server_port_number);
+			}
+
+			break;
+		}
+
+		DEBUG2(printk("scsi%d: %s: waiting on fw, state=%x:%x - "
+			      "seconds expired= %d\n", ha->host_no,
+			      __func__, ha->firmware_state,
+			      ha->addl_fw_state, timeout_count));
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(1 * HZ);
+	} /* for */
+
+	if (timeout_count <= 0) {
+		DEBUG2(printk("scsi%d: %s: FW Initialization timed out!\n",
+			      ha->host_no, __func__));
+
+		if (ha->firmware_state & FW_STATE_DHCP_IN_PROGRESS) {
+			QL4PRINT(QLP2, printk("scsi%d: %s: FW is reporting its waiting to"
+						" grab an IP address from DHCP server\n",
+						      ha->host_no, __func__));
+			ready = 1;
+		}
+	}
+
+	return ready;
+}
+
+/**************************************************************************
+ * qla4xxx_init_firmware
+ *	This routine initializes the firmware.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully initialized firmware
+ *	QLA_ERROR   - Failed to initialize firmware
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static uint8_t
+qla4xxx_init_firmware(scsi_qla_host_t *ha)
+{
+	uint8_t  status = QLA_ERROR;
+
+	ENTER("qla4xxx_init_firmware");
+
+	ql4_printk(KERN_INFO, ha, "Initializing firmware..\n");
+	if (qla4xxx_initialize_fw_cb(ha) == QLA_ERROR) {
+		DEBUG2(printk("scsi%d: %s: Failed to initialize "
+			      "firmware control block\n", ha->host_no, __func__));
+		LEAVE("qla4xxx_init_firmware");
+		return(status);
+	}
+
+	if (!qla4xxx_fw_ready(ha))
+		return(status);
+
+	set_bit(AF_ONLINE, &ha->flags);
+	LEAVE("qla4xxx_init_firmware");
+
+	return(qla4xxx_get_firmware_status(ha));
+}
+
+
+/**************************************************************************
+ * qla4xxx_is_discovered_target
+ *	This routine locates a device handle given iSNS information.
+ *	If device doesn't exist, returns NULL.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *      ip_addr - Pointer to IP address
+ *      alias - Pointer to iSCSI alias
+ *
+ * Returns:
+ *	Pointer to the corresponding internal device database structure
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static inline uint8_t
+qla4xxx_is_discovered_target(scsi_qla_host_t *ha,
+			     uint8_t *ip_addr,
+			     uint8_t *alias,
+			     uint8_t *name_str)
+{
+	ISNS_DISCOVERED_TARGET *discovered_target = NULL;
+	int i,j;
+
+	for (i=0; i < ha->isns_num_discovered_targets; i++) {
+		discovered_target = &ha->isns_disc_tgt_databasev[i];
+
+		for (j = 0; j < discovered_target->NumPortals; j++) {
+			if (memcmp(discovered_target->Portal[j].IPAddr, ip_addr,
+				   MIN(sizeof(discovered_target->Portal[j].IPAddr),
+				       sizeof(*ip_addr)) == 0) &&
+			    memcmp(discovered_target->Alias, alias,
+				   MIN(sizeof(discovered_target->Alias),
+				       sizeof(*alias)) == 0) &&
+			    memcmp(discovered_target->NameString, name_str,
+				   MIN(sizeof(discovered_target->Alias),
+				       sizeof(*name_str)) == 0)) {
+
+				return(QLA_SUCCESS);
+			}
+		}
+	}
+
+	return(QLA_ERROR);
+}
+
+static ddb_entry_t *
+qla4xxx_get_ddb_entry(scsi_qla_host_t *ha, uint32_t fw_ddb_index)
+{
+	DEV_DB_ENTRY    *fw_ddb_entry = NULL;
+	dma_addr_t      fw_ddb_entry_dma;
+	ddb_entry_t     *ddb_entry = NULL;
+	int             found = 0;
+	uint32_t        device_state;
+
+
+	ENTER(__func__);
+
+	/* Make sure the dma buffer is valid */
+	fw_ddb_entry = pci_alloc_consistent(ha->pdev, sizeof(*fw_ddb_entry),
+					    &fw_ddb_entry_dma);
+	if (fw_ddb_entry == NULL) {
+		DEBUG2(printk("scsi%d: %s: Unable to allocate dma "
+			      "buffer.\n", ha->host_no, __func__));
+		LEAVE(__func__);
+		return NULL;
+	}
+
+	if (qla4xxx_get_fwddb_entry(ha, fw_ddb_index, fw_ddb_entry,
+				    fw_ddb_entry_dma, NULL, NULL, &device_state, NULL, NULL,
+				    NULL) == QLA_ERROR) {
+		DEBUG2(printk("scsi%d: %s: failed get_ddb_entry for "
+			      "fw_ddb_index %d\n", ha->host_no, __func__, fw_ddb_index));
+		LEAVE(__func__);
+		return NULL;
+	}
+
+	/* Allocate DDB if not already allocated. */
+	DEBUG2(printk("scsi%d: %s: Looking for ddb[%d]\n", ha->host_no,
+		      __func__, fw_ddb_index));
+	list_for_each_entry(ddb_entry, &ha->ddb_list, list_entry) {
+		if (memcmp(ddb_entry->iscsi_name, fw_ddb_entry->iscsiName,
+			   ISCSI_NAME_SIZE) == 0) {
+			found++;
+			break;
+		}
+	}
+
+	if (!found) {
+		DEBUG2(printk(
+			     "scsi%d: %s: ddb[%d] not found - allocating new ddb\n",
+			     ha->host_no, __func__, fw_ddb_index));
+		ddb_entry = qla4xxx_alloc_ddb(ha, fw_ddb_index);
+	}
+
+	/* if not found allocate new ddb */
+	if (fw_ddb_entry)
+		pci_free_consistent(ha->pdev, sizeof(*fw_ddb_entry),
+				    fw_ddb_entry, fw_ddb_entry_dma);
+
+	LEAVE(__func__);
+
+	return ddb_entry;
+}
+
+/**************************************************************************
+ * qla4xxx_update_ddb_entry
+ *	This routine updates the driver's internal device database entry
+ *	with information retrieved from the firmware's device database
+ *	entry for the specified device.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	ddb_entry - Pointer to device database entry
+ *
+ * Output:
+ *	ddb_entry - Structure filled in.
+ *
+ * Remarks:
+ *	The ddb_entry->fw_ddb_index field must be initialized prior to
+ *	calling this routine
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully update ddb_entry
+ *	QLA_ERROR   - Failed to update ddb_entry
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_update_ddb_entry(scsi_qla_host_t *ha, ddb_entry_t *ddb_entry,
+			 uint32_t fw_ddb_index)
+{
+	DEV_DB_ENTRY *fw_ddb_entry = NULL;
+	dma_addr_t   fw_ddb_entry_dma;
+	uint8_t      status = QLA_ERROR;
+
+	ENTER(__func__);
+
+	if (ddb_entry == NULL) {
+		DEBUG2(printk("scsi%d: %s: ddb_entry is NULL\n",
+			      ha->host_no, __func__));
+		goto exit_update_ddb;
+	}
+
+	/* Make sure the dma buffer is valid */
+	fw_ddb_entry = pci_alloc_consistent(ha->pdev, sizeof(*fw_ddb_entry),
+					    &fw_ddb_entry_dma);
+	if (fw_ddb_entry == NULL) {
+		DEBUG2(printk("scsi%d: %s: Unable to allocate dma "
+			      "buffer.\n", ha->host_no, __func__));
+
+		goto exit_update_ddb;
+	}
+
+	if (qla4xxx_get_fwddb_entry(ha, fw_ddb_index, fw_ddb_entry,
+				    fw_ddb_entry_dma, NULL, NULL,
+				    &ddb_entry->fw_ddb_device_state,
+				    NULL, &ddb_entry->tcp_source_port_num,
+				    &ddb_entry->connection_id) == QLA_ERROR) {
+		DEBUG2(printk("scsi%d: %s: failed get_ddb_entry for "
+			      "fw_ddb_index %d\n", ha->host_no, __func__, fw_ddb_index));
+
+		goto exit_update_ddb;
+	}
+
+	status = QLA_SUCCESS;
+
+	ddb_entry->target_session_id = le16_to_cpu(fw_ddb_entry->TSID);
+	ddb_entry->task_mgmt_timeout =
+	le16_to_cpu(fw_ddb_entry->taskMngmntTimeout);
+	ddb_entry->CmdSn = 0;
+	ddb_entry->exe_throttle =
+	le16_to_cpu(fw_ddb_entry->exeThrottle);
+	ddb_entry->default_relogin_timeout =
+	le16_to_cpu(fw_ddb_entry->taskMngmntTimeout);
+	ddb_entry->default_time2wait = le16_to_cpu(fw_ddb_entry->minTime2Wait);
+
+	/* Update index in case it changed */
+	ddb_entry->fw_ddb_index = fw_ddb_index;
+	ha->fw_ddb_index_map[fw_ddb_index] = ddb_entry;
+
+	memcpy(&ddb_entry->iscsi_name[0], &fw_ddb_entry->iscsiName[0],
+	       MIN(sizeof(ddb_entry->iscsi_name),
+		   sizeof(fw_ddb_entry->iscsiName)));
+	memcpy(&ddb_entry->ip_addr[0], &fw_ddb_entry->ipAddr[0],
+	       MIN(sizeof(ddb_entry->ip_addr),
+		   sizeof(fw_ddb_entry->ipAddr)));
+
+	if (qla4xxx_is_discovered_target(ha, fw_ddb_entry->ipAddr,
+					 fw_ddb_entry->iSCSIAlias,
+					 fw_ddb_entry->iscsiName) ==
+	    QLA_SUCCESS) {
+		set_bit(DF_ISNS_DISCOVERED, &ddb_entry->flags);
+	}
+
+
+	DEBUG2(printk("scsi%d: %s: ddb[%d] - State= %x status= %d.\n",
+		      ha->host_no, __func__, fw_ddb_index,
+		      ddb_entry->fw_ddb_device_state, status);)
+
+	exit_update_ddb:
+	if (fw_ddb_entry)
+		pci_free_consistent(ha->pdev, sizeof(*fw_ddb_entry),
+				    fw_ddb_entry, fw_ddb_entry_dma);
+
+	LEAVE(__func__);
+
+	return(status);
+}
+
+
+static  void
+qla4xxx_configure_fcports(scsi_qla_host_t *ha)
+{
+	fc_port_t       *fcport;
+
+	list_for_each_entry(fcport, &ha->fcports, list) {
+		qla4xxx_update_fcport(ha, fcport);
+	}
+}
+
+static fc_port_t *
+qla4xxx_find_or_alloc_fcport(scsi_qla_host_t *ha, ddb_entry_t *ddb_entry)
+{
+	fc_port_t       *fcport;
+	int     found;
+
+	ENTER(__func__);
+	/* Check for matching device in port list. */
+	found = 0;
+	fcport = NULL;
+	list_for_each_entry(fcport, &ha->fcports, list) {
+		if (fcport->ddbptr == ddb_entry) {
+			fcport->flags &= ~(FCF_PERSISTENT_BOUND);
+			found++;
+			break;
+		}
+	}
+
+	if (!found) {
+		/* Allocate a new replacement fcport. */
+		fcport = qla4xxx_alloc_fcport(ha, GFP_ATOMIC);
+		if (fcport != NULL) {
+			/* New device, add to fcports list. */
+			list_add_tail(&fcport->list, &ha->fcports);
+			fcport->ddbptr = ddb_entry;
+		}
+	}
+
+	LEAVE(__func__);
+
+	return(fcport);
+}
+
+
+/**************************************************************************
+ * qla4xxx_alloc_ddb
+ *	This routine allocates a ddb_entry, ititializes some values, and
+ *	inserts it into the ddb list.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *      fw_ddb_index - Firmware's device database index
+ *
+ * Returns:
+ *	Pointer to internal device database structure
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+ddb_entry_t *
+qla4xxx_alloc_ddb(scsi_qla_host_t *ha, uint32_t fw_ddb_index)
+{
+	ddb_entry_t *ddb_entry;
+
+	QL4PRINT(QLP12, printk("scsi%d: %s: fw_ddb_index [%d]\n", ha->host_no,
+			       __func__, fw_ddb_index));
+
+	ddb_entry = (ddb_entry_t *) kmalloc(sizeof(*ddb_entry), GFP_ATOMIC);
+	if (ddb_entry == NULL) {
+		DEBUG2(printk("scsi%d: %s: Unable to allocate memory "
+			      "to add fw_ddb_index [%d]\n", ha->host_no, __func__,
+			      fw_ddb_index));
+	} else {
+		memset(ddb_entry, 0, sizeof(*ddb_entry));
+		ddb_entry->fw_ddb_index = fw_ddb_index;
+		atomic_set(&ddb_entry->port_down_timer,
+			   ha->port_down_retry_count);
+		atomic_set(&ddb_entry->retry_relogin_timer, INVALID_ENTRY);
+		atomic_set(&ddb_entry->relogin_timer, 0);
+		atomic_set(&ddb_entry->relogin_retry_count, 0);
+		atomic_set(&ddb_entry->state, DEV_STATE_ONLINE);
+		list_add_tail(&ddb_entry->list_entry, &ha->ddb_list);
+		ha->fw_ddb_index_map[fw_ddb_index] = ddb_entry;
+		ha->tot_ddbs++;
+                ddb_entry->fcport = qla4xxx_find_or_alloc_fcport(ha, ddb_entry);
+	}
+	return(ddb_entry);
+}
+
+
+/**************************************************************************
+ * qla4xxx_build_ddb_list
+ *	This routine searches for all valid firmware ddb entries and builds
+ *	an internal ddb list.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Remarks:
+ *	Ddbs that are considered valid are those with a device state of
+ *	SESSION_ACTIVE.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully built internal ddb list, if targets available
+ *	QLA_ERROR   - Error on a mailbox command
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static uint8_t
+qla4xxx_build_ddb_list(scsi_qla_host_t *ha)
+{
+	uint8_t         status = QLA_SUCCESS;
+	uint32_t        fw_ddb_index = 0;
+	uint32_t        next_fw_ddb_index = 0;
+	uint32_t        ddb_state;
+	uint32_t        conn_err, err_code;
+	ddb_entry_t *ddb_entry;
+
+	ENTER("qla4xxx_build_ddb_list");
+
+	ql4_printk(KERN_INFO, ha, "Initializing DDBs ...\n");
+	for (fw_ddb_index = 0; fw_ddb_index < MAX_DDB_ENTRIES;
+	    fw_ddb_index = next_fw_ddb_index) {
+		/* First, let's see if a device exists here */
+		if (qla4xxx_get_fwddb_entry(ha, fw_ddb_index, NULL, 0, NULL,
+					    &next_fw_ddb_index, &ddb_state,
+				&conn_err, NULL, NULL) == QLA_ERROR) {
+			DEBUG2(printk("scsi%d: %s: get_ddb_entry, "
+				      "fw_ddb_index %d failed", ha->host_no, __func__,
+				      fw_ddb_index));
+			status = QLA_ERROR;
+			goto exit_build_ddb_list;
+		}
+
+		DEBUG2(printk("scsi%d: %s: Getting DDB[%d] ddbstate=0x%x, "
+			      "next_fw_ddb_index=%d.\n",
+			      ha->host_no, __func__, fw_ddb_index, ddb_state,
+			      next_fw_ddb_index));
+
+		/*
+		 * Add DDB to internal our ddb list.
+		 * --------------------------------
+		 */
+			ddb_entry = qla4xxx_get_ddb_entry(ha, fw_ddb_index);
+			if (ddb_entry == NULL) {
+				DEBUG2(printk("scsi%d: %s: Unable to "
+					      "allocate memory for device at "
+					      "fw_ddb_index %d\n", ha->host_no, __func__,
+					      fw_ddb_index));
+				status = QLA_ERROR;
+				goto exit_build_ddb_list;
+			}
+			/* Fill in the device structure */
+			if (qla4xxx_update_ddb_entry(ha, ddb_entry,
+						     fw_ddb_index) == QLA_ERROR) {
+				ha->fw_ddb_index_map[fw_ddb_index] =
+				(ddb_entry_t *) INVALID_ENTRY;
+
+				DEBUG2(printk("scsi%d: %s: "
+					      "update_ddb_entry failed for fw_ddb_index"
+					      "%d.\n",
+					      ha->host_no, __func__, fw_ddb_index));
+				status = QLA_ERROR;
+				goto exit_build_ddb_list;
+			}
+
+			/* if fw_ddb with session active state found,
+			 * add to ddb_list */
+			DEBUG2(printk("scsi%d: %s: DDB[%d] "
+				      "added to list\n", ha->host_no, __func__,
+				      fw_ddb_index));
+
+ 		/*
+ 		 * Issue relogin, if necessary
+ 		 * ---------------------------
+ 		 */
+ 		if (ddb_state == DDB_DS_SESSION_FAILED ||
+			 ddb_state == DDB_DS_NO_CONNECTION_ACTIVE) {
+
+ 			atomic_set(&ddb_entry->state, DEV_STATE_DEAD);
+
+			/* Try and login to device */
+			DEBUG2(printk("scsi%d: %s: Login to DDB[%d]\n",
+				      ha->host_no, __func__, fw_ddb_index));
+			err_code = ((conn_err & 0x00ff0000) >>16);
+			if (err_code == 0x1c || err_code == 0x06) {
+				DEBUG2(printk("scsi%d: %s send target completed"
+					" or access denied failure\n",
+					ha->host_no, __func__));
+			} else {
+			     qla4xxx_set_ddb_entry(ha, fw_ddb_index, NULL, 0);
+			}
+		}
+
+		/* We know we've reached the last device when
+		 * next_fw_ddb_index is 0 */
+		if (next_fw_ddb_index == 0)
+			break;
+	}
+
+	ql4_printk(KERN_INFO, ha, "DDB list done..\n");
+
+	exit_build_ddb_list:
+	LEAVE("qla4xxx_build_ddb_list");
+
+	return(status);
+}
+
+/**************************************************************************
+ * qla4xxx_devices_ready
+ *	This routine waits up to ql4xdiscoverywait seconds
+ *	F/W database during driver load time.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully (re)built internal ddb list
+ *	QLA_ERROR   - Failed to (re)build internal ddb list
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static uint8_t
+qla4xxx_devices_ready(scsi_qla_host_t *ha)
+{
+	uint8_t         halt_wait;
+	unsigned long   discovery_wtime;
+	ddb_entry_t     *ddb_entry;
+	uint32_t fw_ddb_index;
+	uint32_t        next_fw_ddb_index;
+	uint32_t fw_ddb_device_state;
+	uint32_t        conn_err;
+	uint32_t        err_code;
+
+	discovery_wtime = jiffies + (ql4xdiscoverywait * HZ);
+
+	DEBUG(printk("Waiting (%d) for devices ...\n", ql4xdiscoverywait));
+	QL4PRINT(QLP7, printk("scsi%d: Waiting (%d) for devices ...\n",
+			      ha->host_no, ql4xdiscoverywait));
+
+	do {
+		/* poll for AEN
+		 * ------------ */
+		qla4xxx_get_firmware_state(ha);
+		if (test_and_clear_bit(DPC_AEN, &ha->dpc_flags)) {
+			/* Set time-between-relogin timer */
+			qla4xxx_process_aen(ha, RELOGIN_DDB_CHANGED_AENS);
+		}
+
+		/* if no relogins active or needed, halt discvery wait */
+		halt_wait = 1;
+
+		/* scan for relogins
+		 * ----------------- */
+		for (fw_ddb_index = 0;
+		    fw_ddb_index < MAX_DDB_ENTRIES;
+		    fw_ddb_index = next_fw_ddb_index) {
+			if (qla4xxx_get_fwddb_entry(ha,
+						    fw_ddb_index,
+						    NULL, 0, NULL,
+						    &next_fw_ddb_index,
+						    &fw_ddb_device_state,
+						    &conn_err,
+						    NULL, NULL) == QLA_ERROR) {
+				QL4PRINT(QLP7,
+					 printk("scsi%d: %s: ERROR retrieving "
+						"get_ddb_entry for fw_ddb_index %d \n",
+						ha->host_no, __func__, fw_ddb_index));
+				return(QLA_ERROR);
+			}
+
+			
+			if (fw_ddb_device_state == DDB_DS_LOGIN_IN_PROCESS) {
+				QL4PRINT(QLP7,
+					 printk("scsi%d: %s: get_ddb_entry, "
+						"fw_ddb_index %d state=0x%x conn_err=0x%x\n",
+						ha->host_no, __func__, fw_ddb_index,
+						fw_ddb_device_state, conn_err));
+				halt_wait = 0;
+			}
+
+			if ((fw_ddb_device_state == DDB_DS_SESSION_FAILED) ||
+			    (fw_ddb_device_state == DDB_DS_NO_CONNECTION_ACTIVE)) {
+				QL4PRINT(QLP7,
+					 printk("scsi%d: %s: get_ddb_entry, "
+						"fw_ddb_index %d state=0x%x conn_err=0x%x\n",
+						ha->host_no, __func__, fw_ddb_index,
+						fw_ddb_device_state, conn_err));
+
+				/* Don't want to do a relogin if connection error is 0x1c */
+				err_code = ((conn_err & 0x00ff0000) >>16);
+				if (err_code == 0x1c || err_code == 0x06) {
+					DEBUG2(printk("scsi%d: %s send target completed"
+					       " or access denied failure\n",
+					       ha->host_no, __func__);)
+				}
+				else {
+					/* We either have a device that is in
+					 * the process of relogging in or a
+					 * device that is waiting to be
+					 * relogged in */
+					halt_wait = 0;
+
+					ddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, fw_ddb_index);
+					if (ddb_entry == NULL) {
+						QL4PRINT(QLP7,
+							 printk("scsi%d: %s: ERROR retrieving "
+								"ddb_entry for fw_ddb_index %d \n",
+								ha->host_no, __func__, fw_ddb_index));
+						return(QLA_ERROR);
+					}
+
+					#if 0
+					if (ddb_entry->dev_scan_wait_to_complete_relogin != 0 &&
+					    time_after_eq(jiffies, ddb_entry->dev_scan_wait_to_complete_relogin)) {
+						/* do nothing */
+					}
+					#endif
+
+					if (ddb_entry->dev_scan_wait_to_start_relogin != 0 &&
+					    time_after_eq(jiffies, ddb_entry->dev_scan_wait_to_start_relogin)) {
+						ddb_entry->dev_scan_wait_to_start_relogin = 0;
+						qla4xxx_set_ddb_entry(ha, fw_ddb_index, NULL, 0);
+					}
+				}
+			}
+
+			/* We know we've reached the last device when
+			 * next_fw_ddb_index is 0 */
+			if (next_fw_ddb_index == 0)
+				break;
+		}
+
+		if (halt_wait) {
+			DEBUG2( printk("scsi%d: %s: Delay halted.  Devices Ready.\n",
+				       ha->host_no, __func__));
+			return(QLA_SUCCESS);
+		}
+
+		/* delay */
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(HZ * 2);
+	} while (!time_after_eq(jiffies, discovery_wtime));
+
+	DEBUG2( printk("scsi%d: %s: Delay complete.\n",
+		       ha->host_no, __func__));
+
+	if (halt_wait == 0) {
+		DEBUG2( printk("scsi%d: %s: all devices not logged in\n",
+			       ha->host_no, __func__));
+	}
+
+	//DEBUG2(qla4xxx_get_conn_event_log(ha);)
+
+	return(QLA_SUCCESS);
+}
+
+static uint8_t
+qla4xxx_initialize_ddb_list(scsi_qla_host_t *ha)
+{
+	uint16_t fw_ddb_index;
+	uint8_t status = QLA_SUCCESS;
+	unsigned long   wtime;
+
+	ENTER("qla4xxx_initialize_ddb_list");
+
+	/* free the ddb list if is not empty */
+	if (!list_empty(&ha->ddb_list))
+		qla4xxx_free_ddb_list(ha);
+
+	/* Initialize internal DDB list and mappingss */
+	qla4xxx_init_tgt_map(ha);
+
+	for (fw_ddb_index = 0; fw_ddb_index < MAX_DDB_ENTRIES; fw_ddb_index++)
+		ha->fw_ddb_index_map[fw_ddb_index] =
+		(ddb_entry_t *) INVALID_ENTRY;
+
+	ha->tot_ddbs = 0;
+
+	/* Flush the 0x8014 AEN from the firmware as a result of
+ 	 * Auto connect. We are basically doing get_firmware_ddb()
+	 * to determine whether we need to log back in or not.
+	 *  Trying to do a set ddb before we have processed 0x8014
+	 *  will result in another set_ddb() for the same ddb. In other
+	 *  words there will be stale entries in the aen_q.	
+	 */
+	wtime = jiffies + (2 * HZ);
+	do {
+		if (qla4xxx_get_firmware_state(ha) == QLA_SUCCESS) {
+			/* error */
+			if (ha->firmware_state & (BIT_2|BIT_0)) {
+				return(QLA_ERROR);
+			}
+		}
+
+		if (test_and_clear_bit(DPC_AEN, &ha->dpc_flags)) {
+			qla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);
+		}
+		/* delay */
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(HZ * 1);
+
+	} while (!time_after_eq(jiffies,wtime));
+
+
+	/*
+	 * First perform device discovery for active
+	 * fw ddb indexes and build
+	 * ddb list.
+	 */
+	/* Retry for cases of fw_ddb_index mismatch and in cases of
+	 * memory alloc failure.
+	 */
+	if ((status = qla4xxx_build_ddb_list(ha)) == QLA_ERROR)
+		return(status);
+
+	/* Wait for an AEN */
+	qla4xxx_devices_ready(ha);
+
+
+	/*
+	 * Here we map a SCSI target to a fw_ddb_index and discover all
+	 * possible luns.
+	 */
+	qla4xxx_configure_fcports(ha);
+	qla4xxx_config_os(ha);
+
+	/*
+	 * Targets can come online after the inital discovery, so processing
+	 * the aens here will catch them.
+	 */
+	if (test_and_clear_bit(DPC_AEN, &ha->dpc_flags))
+		qla4xxx_process_aen(ha, PROCESS_ALL_AENS);
+#if 0
+	if (!ha->tot_ddbs)
+		status = QLA_ERROR;
+#endif
+
+	LEAVE("qla4xxx_initialize_ddb_list");
+
+	return(status);
+}
+
+/**************************************************************************
+ * qla4xxx_reinitialize_ddb_list
+ *	This routine obtains device information from the F/W database after
+ *	firmware or adapter resets.  The device table is preserved.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully updated internal ddb list
+ *	QLA_ERROR   - Failed to update internal ddb list
+ *
+* Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_reinitialize_ddb_list(scsi_qla_host_t *ha)
+{
+	uint8_t         status = QLA_SUCCESS;
+	ddb_entry_t     *ddb_entry, *detemp;
+
+	ENTER("qla4xxx_reinitialize_ddb_list");
+
+	/* Update the device information for all devices. */
+	list_for_each_entry_safe(ddb_entry, detemp, &ha->ddb_list, list_entry) {
+		qla4xxx_update_ddb_entry(ha, ddb_entry,
+					 ddb_entry->fw_ddb_index);
+		if (ddb_entry->fw_ddb_device_state == DDB_DS_SESSION_ACTIVE) {
+			atomic_set(&ddb_entry->state, DEV_STATE_ONLINE);
+			qla4xxx_update_fcport(ha, ddb_entry->fcport);
+
+			QL4PRINT(QLP3|QLP7, printk(
+						   "scsi%d:%d:%d: %s: index [%d] marked ONLINE\n",
+						   ha->host_no, ddb_entry->bus, ddb_entry->target,
+						   __func__, ddb_entry->fw_ddb_index));
+		} else if (atomic_read(&ddb_entry->state) == DEV_STATE_ONLINE)
+			qla4xxx_mark_device_missing(ha, ddb_entry);
+	}
+
+	LEAVE("qla4xxx_reinitialize_ddb_list");
+	return(status);
+}
+
+/**************************************************************************
+ * qla4xxx_relogin_device
+ *	This routine does a session relogin with the specified device.
+ *	The ddb entry must be assigned prior to making this call.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	ddb_entry - Pointer to device database entry
+ *
+ * Returns:
+ *    QLA_SUCCESS = Successfully relogged in device
+ *    QLA_ERROR   = Failed to relogin device
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_relogin_device(scsi_qla_host_t *ha, ddb_entry_t *ddb_entry)
+{
+	uint16_t relogin_timer;
+
+	ENTER("qla4xxx_relogin_device");
+
+	relogin_timer = MAX(ddb_entry->default_relogin_timeout, RELOGIN_TOV);
+	atomic_set(&ddb_entry->relogin_timer, relogin_timer);
+
+	QL4PRINT(QLP2, printk(KERN_WARNING
+			      "scsi%d:%d:%d: Relogin index [%d]. TOV=%d\n", ha->host_no,
+			      ddb_entry->bus, ddb_entry->target, ddb_entry->fw_ddb_index,
+			      relogin_timer));
+
+	qla4xxx_set_ddb_entry(ha, ddb_entry->fw_ddb_index, NULL, 0);
+
+	LEAVE("qla4xxx_relogin_device");
+
+	return(QLA_SUCCESS);
+}
+
+/**************************************************************************
+ * qla4010_topcat_soft_reset
+ *	This routine determines if the QLA4040 TopCat chip is present.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	None.
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static void
+qla4010_get_topcat_presence(scsi_qla_host_t *ha)
+{
+	unsigned long flags;
+	uint16_t topcat;
+
+	QL4XXX_LOCK_NVRAM(ha);
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	topcat = RD_NVRAM_WORD(ha, offsetof(eeprom_data_t, isp4010.topcat));
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	if ((topcat & TOPCAT_MASK) == TOPCAT_PRESENT)
+		set_bit(AF_TOPCAT_CHIP_PRESENT, &ha->flags);
+	else
+		clear_bit(AF_TOPCAT_CHIP_PRESENT, &ha->flags);
+
+	QL4XXX_UNLOCK_NVRAM(ha);
+}
+
+/**************************************************************************
+ * qla4xxx_start_firmware
+ *	This routine performs the neccessary steps to start the firmware for
+ *	the QLA4010 adapter.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully started QLA4xxx firmware
+ *	QLA_ERROR   - Failed to start QLA4xxx firmware
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static uint8_t
+qla4xxx_start_firmware(scsi_qla_host_t *ha)
+{
+	unsigned long flags = 0;
+	uint32_t mbox_status;
+	uint8_t status = QLA_ERROR;
+	uint8_t soft_reset = 1;
+	uint8_t boot_firmware = 0;
+	uint8_t config_chip = 0;
+
+	ENTER("qla4xxx_start_firmware");
+
+
+	if (IS_QLA4010(ha))
+		qla4010_get_topcat_presence(ha);
+
+	if (IS_QLA4022(ha))
+		ql4xxx_set_mac_number(ha);
+
+	QL4XXX_LOCK_DRVR_WAIT(ha);
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+
+	DEBUG2(printk("scsi%d: %s: port_ctrl   = 0x%08X\n", ha->host_no, __func__,
+    				RD_REG_DWORD(ISP_PORT_CTRL(ha)));)
+	DEBUG2(printk("scsi%d: %s: port_status = 0x%08X\n", ha->host_no, __func__,
+    				RD_REG_DWORD(ISP_PORT_STATUS(ha)));)
+
+	/* Is Hardware already initialized? */
+	if ((RD_REG_DWORD(ISP_PORT_CTRL(ha)) & 0x8000) != 0) {
+		QL4PRINT(QLP7, printk("scsi%d: %s: Hardware has already been "
+				      "initialized\n", ha->host_no, __func__));
+
+		/* Receive firmware boot acknowledgement */
+		mbox_status = RD_REG_DWORD(&ha->reg->mailbox[0]);
+
+		DEBUG2(printk("scsi%d: %s: H/W Config complete - mbox[0]= 0x%x\n",
+			      ha->host_no,  __func__, mbox_status);)
+
+		/* Is firmware already booted? */
+		if (mbox_status == 0) {
+			/* F/W not running, must be config by net driver */
+			config_chip = 1;
+			soft_reset = 0;
+		} else {
+			WRT_REG_DWORD(&ha->reg->ctrl_status, SET_RMASK(CSR_SCSI_PROCESSOR_INTR));
+			PCI_POSTING(&ha->reg->ctrl_status);
+			spin_unlock_irqrestore(&ha->hardware_lock, flags);
+			if (qla4xxx_get_firmware_state(ha) == QLA_SUCCESS) {
+				DEBUG2(printk("scsi%d: %s: "
+					      "Get firmware state "
+					      "-- state = 0x%x\n",
+					      ha->host_no, __func__,ha->firmware_state));
+				/* F/W is running */
+				if ((ha->firmware_state & FW_STATE_CONFIG_WAIT)) {
+					DEBUG2(printk("scsi%d: %s: "
+						      "Firmware in known state "
+						      "-- config and boot, state = 0x%x\n",
+						      ha->host_no, __func__,ha->firmware_state));
+					config_chip = 1;
+					soft_reset = 0;
+				}
+			} else {
+				DEBUG2(printk("scsi%d: %s: "
+					      "Firmware in unknown state "
+					      "-- resetting, state = 0x%x\n",
+					      ha->host_no, __func__,ha->firmware_state));
+			}
+			spin_lock_irqsave(&ha->hardware_lock, flags);
+		}
+	} else {
+		QL4PRINT(QLP7, printk("scsi%d: %s: H/W initialization hasn't been started "
+				      " - resetting\n", ha->host_no, __func__));
+	}
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	QL4PRINT(QLP7, printk("scsi%d: %s: Flags soft_rest=%d, config= %d\n"
+			      , ha->host_no, __func__,soft_reset,config_chip));
+	if (soft_reset) {
+		QL4PRINT(QLP7, printk("scsi%d: %s: Issue Soft Reset\n",
+				      ha->host_no, __func__));
+
+		status = qla4xxx_soft_reset(ha);
+		if (status == QLA_ERROR) {
+			QL4PRINT(QLP3|QLP7, printk("scsi%d: %s: Soft Reset "
+						   "failed!\n", ha->host_no, __func__));
+			QL4XXX_UNLOCK_DRVR(ha);
+			return QLA_ERROR;
+		}
+		
+		config_chip = 1;
+
+		/* Reset clears the semaphore, so aquire again */
+		QL4XXX_LOCK_DRVR_WAIT(ha);
+	}
+
+	if (config_chip) {
+		EXTERNAL_HW_CONFIG_REG  extHwConfig;
+
+		QL4PRINT(QLP7, printk("scsi%d: %s: Get EEProm parameters "
+				      "\n", ha->host_no, __func__));
+
+		QL4XXX_LOCK_FLASH(ha);
+		QL4XXX_LOCK_NVRAM(ha);
+
+		/* Get EEPRom Parameters  */
+		ql4_printk(KERN_INFO, ha, "Configuring NVRAM ...\n");
+		if (qla4xxx_is_NVRAM_configuration_valid(ha) == QLA_SUCCESS) {
+
+			spin_lock_irqsave(&ha->hardware_lock, flags);
+			extHwConfig.AsUINT32 = RD_NVRAM_WORD(ha,
+							     EEPROM_EXT_HW_CONF_OFFSET());
+			spin_unlock_irqrestore(&ha->hardware_lock, flags);
+		}
+		else {
+			/*
+			 * QLogic adapters should always have a valid NVRAM.
+			 * If not valid, do not load.
+			 */
+			printk(KERN_INFO "scsi%d: %s: EEProm checksum "
+			       "invalid.  Please update your EEPROM\n",
+			       ha->host_no, __func__);
+
+			/* set defaults */
+			if (IS_QLA4010(ha))
+				extHwConfig.AsUINT32 = 0x1912;
+			else if (IS_QLA4022(ha))
+				extHwConfig.AsUINT32 = 0x0023;
+
+		}
+
+		QL4PRINT(QLP7, printk("scsi%d: %s: Setting extHwConfig "
+				      "to 0xFFFF%04x\n", ha->host_no, __func__,
+				      extHwConfig.AsUINT32));
+
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+		WRT_REG_DWORD(ISP_EXT_HW_CONF(ha),
+			      ((0xFFFF << 16) | extHwConfig.AsUINT32));
+		PCI_POSTING(ISP_EXT_HW_CONF(ha));
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+		QL4XXX_UNLOCK_NVRAM(ha);
+		QL4XXX_UNLOCK_FLASH(ha);
+
+		status = QLA_SUCCESS;
+
+		boot_firmware = 1;
+	}
+
+	if (boot_firmware) {
+		uint32_t        max_wait_time;
+
+		/*
+		 * Start firmware from flash ROM
+		 *
+		 * WORKAROUND: Stuff a non-constant value that the firmware can
+		 * use as a seed for a random number generator in MB7 prior to
+		 * setting BOOT_ENABLE.  Fixes problem where the TCP
+		 * connections use the same TCP ports after each reboot,
+		 * causing some connections to not get re-established.
+		 */
+		QL4PRINT(QLP7, printk("scsi%d: %s: Start firmware from flash "
+				      "ROM\n", ha->host_no, __func__));
+
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+		WRT_REG_DWORD(&ha->reg->mailbox[7], jiffies);
+		if (IS_QLA4022(ha))
+			WRT_REG_DWORD(&ha->reg->u1.isp4022.nvram,
+				      SET_RMASK(NVR_WRITE_ENABLE));
+
+		WRT_REG_DWORD(&ha->reg->ctrl_status,
+			      SET_RMASK(CSR_BOOT_ENABLE));
+		PCI_POSTING(&ha->reg->ctrl_status);
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+		/* Wait for firmware to come UP. */
+		max_wait_time = FIRMWARE_UP_TOV * 4;
+		do {
+			uint32_t ctrl_status;
+
+			spin_lock_irqsave(&ha->hardware_lock, flags);
+			ctrl_status = RD_REG_DWORD(&ha->reg->ctrl_status);
+			mbox_status = RD_REG_DWORD(&ha->reg->mailbox[0]);
+			spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+			if (ctrl_status & SET_RMASK(CSR_SCSI_PROCESSOR_INTR))
+				break;
+			if (mbox_status == MBOX_STS_COMMAND_COMPLETE)
+				break;
+
+			DEBUG2(printk("scsi%d: %s: Waiting for "
+				      "boot firmware to complete... ctrl_sts=0x%x, "
+				      "remaining=%d\n", ha->host_no, __func__,
+				      ctrl_status, max_wait_time));
+
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			schedule_timeout(HZ/4);
+		} while ((max_wait_time--));
+
+		if (mbox_status == MBOX_STS_COMMAND_COMPLETE) {
+			QL4PRINT(QLP7, printk("scsi%d: %s: Firmware has "
+					      "started\n", ha->host_no, __func__));
+
+			spin_lock_irqsave(&ha->hardware_lock, flags);
+			WRT_REG_DWORD(&ha->reg->ctrl_status,
+				      SET_RMASK(CSR_SCSI_PROCESSOR_INTR));
+			PCI_POSTING(&ha->reg->ctrl_status);
+			spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+			status = QLA_SUCCESS;
+		} else {
+			QL4PRINT(QLP2, printk("scsi%d: %s: Boot firmware failed "
+					      "-  mbox status 0x%x\n",
+					      ha->host_no, __func__, mbox_status));
+
+			status = QLA_ERROR;
+		}
+	}
+	QL4XXX_UNLOCK_DRVR(ha);
+
+	if (status == QLA_SUCCESS) {
+		qla4xxx_get_fw_version(ha);
+
+		if (test_and_clear_bit(AF_GET_CRASH_RECORD, &ha->flags))
+			qla4xxx_get_crash_record(ha);
+	} else {
+		QL4PRINT(QLP7, printk("scsi%d: %s: Firmware has NOT started\n",
+				      ha->host_no, __func__));
+
+		qla4xxx_dump_registers(QLP7, ha);
+	}
+
+	LEAVE("qla4xxx_start_firmware");
+	return status;
+}
+
+static void
+qla4x00_pci_config(scsi_qla_host_t *ha)
+{
+	uint16_t        w, mwi;
+
+	ql4_printk(KERN_INFO, ha, "Configuring PCI space...\n");
+
+	pci_set_master(ha->pdev);
+	mwi = 0;
+	if (pci_set_mwi(ha->pdev))
+		mwi = PCI_COMMAND_INVALIDATE;
+
+	/*
+	 * We want to respect framework's setting of PCI configuration space
+	 * command register and also want to make sure that all bits of
+	 * interest to us are properly set in command register.
+	 */
+	pci_read_config_word(ha->pdev, PCI_COMMAND, &w);
+	w |= mwi | (PCI_COMMAND_PARITY | PCI_COMMAND_SERR);
+	w &= ~PCI_COMMAND_INTX_DISABLE;
+	pci_write_config_word(ha->pdev, PCI_COMMAND, w);
+}
+
+/**************************************************************************
+ * qla4xxx_initialize_adapter
+ *	This routine parforms all of the steps necessary to initialize the
+ *	adapter.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	renew_ddb_list - Indicates what to do with the adapter's ddb list
+ *			after adapter recovery has completed.
+ *			0=preserve ddb list, 1=destroy and rebuild ddb list
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully initialized adapter
+ *	QLA_ERROR   - Failed to initialize adapter
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+
+uint8_t
+qla4xxx_initialize_adapter(scsi_qla_host_t *ha, uint8_t renew_ddb_list)
+{
+	uint8_t      status = QLA_ERROR;
+
+	ENTER("qla4xxx_initialize_adapter");
+
+	qla4x00_pci_config(ha);
+
+	qla4xxx_disable_intrs(ha);
+	/* Initialize the Host adapter request/response queues and firmware */
+	if (qla4xxx_start_firmware(ha) == QLA_ERROR) {
+		QL4PRINT(QLP2, printk(
+				      "scsi%d: Failed to start QLA4xxx firmware\n",
+				      ha->host_no));
+		goto exit_init_hba;
+	}
+	if (qla4xxx_validate_mac_address(ha) == QLA_ERROR) {
+		QL4PRINT(QLP2, printk(
+				      "scsi%d: Failed to validate mac address\n",
+				      ha->host_no));
+		goto exit_init_hba;
+	}
+	if (qla4xxx_init_local_data(ha) == QLA_ERROR) {
+		QL4PRINT(QLP2, printk(
+				      "scsi%d: Failed to initialize local data\n",
+				      ha->host_no));
+		goto exit_init_hba;
+	}
+
+	status = qla4xxx_init_firmware(ha);
+	if (status == QLA_ERROR) {
+		QL4PRINT(QLP2, printk(
+				      "scsi%d: Failed to initialize firmware\n",
+				      ha->host_no));
+		goto exit_init_hba;
+	}
+
+	if (ha->firmware_state & FW_STATE_DHCP_IN_PROGRESS) {
+		QL4PRINT(QLP2, printk("%s(%d) FW is waiting to get an IP address"
+				      " from DHCP server: Skip building"
+				      " the ddb_list and wait for DHCP lease"
+				      " acquired aen to come in followed by 0x8014 aen"
+				      " to trigger the tgt discovery process\n",
+				      __func__, ha->host_no));
+		/* NOTE: status = QLA_SUCCESS */
+		goto exit_init_hba;
+	}
+
+	if (IPAddrIsZero(ha->ip_address) || IPAddrIsZero(ha->subnet_mask)) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: Null IP address and/or"
+				      " Subnet Mask.  Skip device discovery.\n",
+				      ha->host_no, __func__));
+		/* NOTE: status = QLA_SUCCESS */
+		goto exit_init_hba;
+	}
+
+	/* If iSNS Enabled, wait for iSNS targets */
+	if (test_bit(ISNS_FLAG_ISNS_ENABLED_IN_ISP, &ha->isns_flags)) {
+		unsigned long wait_cnt = jiffies + ql4xdiscoverywait * HZ;
+
+		QL4PRINT(QLP7,
+			 printk("scsi%d: Delay up "
+				"to %d seconds while iSNS targets "
+				"are being discovered.\n",
+				ha->host_no,
+				ql4xdiscoverywait));
+
+		while (!time_after_eq(jiffies,wait_cnt)) {
+			if (test_bit(ISNS_FLAG_DEV_SCAN_DONE,
+				     &ha->isns_flags))
+				break;
+			qla4xxx_get_firmware_state(ha);
+			QL4PRINT(QLP7, printk("."));
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(1 * HZ);
+		}
+
+		if (!test_bit(ISNS_FLAG_ISNS_SRV_ENABLED,
+			      &ha->isns_flags)) {
+			QL4PRINT(QLP2, printk(
+					      "scsi%d: iSNS service failed to start\n",
+					      ha->host_no));
+		}
+		else {
+			if (!ha->isns_num_discovered_targets) {
+				QL4PRINT(QLP2, printk(
+						      "scsi%d: Failed to "
+						      "discover iSNS targets\n",
+						      ha->host_no));
+			}
+		}
+	}
+
+	if (renew_ddb_list == PRESERVE_DDB_LIST) {
+		/*
+		 * We want to preserve lun states (i.e. suspended, etc.)
+		 * for recovery initiated by the driver.  So just update
+		 * the device states for the existing ddb_list
+		 */
+		qla4xxx_reinitialize_ddb_list(ha);
+	}
+	else if (renew_ddb_list == REBUILD_DDB_LIST) {
+		/*
+		 * We want to build the ddb_list from scratch during
+		 * driver initialization and recovery initiated by the
+		 * INT_HBA_RESET IOCTL.
+		 */
+		status = qla4xxx_initialize_ddb_list(ha);
+		if (status == QLA_ERROR) {
+			printk("%s(%d) Error occurred during build ddb list\n",
+			       __func__, ha->host_no);
+			goto exit_init_hba;
+		}
+
+	}
+
+	if (!ha->tot_ddbs) {
+			QL4PRINT(QLP2, printk("scsi%d:"
+				" Failed to initialize devices or none present"
+				" in Firmware device database\n",
+					      ha->host_no));
+	}
+
+	exit_init_hba:
+	LEAVE("qla4xxx_initialize_adapter");
+	return(status);
+}
+
+/**************************************************************************
+ * qla4xxx_find_propname
+ *	Get property in database.
+ *
+ * Input:
+ *	ha = adapter structure pointer.
+ *      db = pointer to database
+ *      propstr = pointer to dest array for string
+ *	propname = name of property to search for.
+ *	siz = size of property
+ *
+ * Returns:
+ *	0 = no property
+ *      size = index of property
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static uint8_t
+qla4xxx_find_propname(scsi_qla_host_t *ha,
+		      char *propname, char *propstr,
+		      char *db, int siz)
+{
+	char    *cp;
+
+	/* find the specified string */
+	if (db) {
+		/* find the property name */
+		if ((cp = strstr(db,propname)) != NULL) {
+			while ((*cp)  && *cp != '=')
+				cp++;
+			if (*cp) {
+				strncpy(propstr, cp, siz+1);
+				propstr[siz+1] = '\0';
+				QL4PRINT(QLP7, printk("scsi%d: %s: found "
+						      "property = {%s}\n",
+						      ha->host_no, __func__,
+						      propstr));
+				return(siz);	       /* match */
+			}
+		}
+	}
+
+	return(0);
+}
+
+
+/**************************************************************************
+ * qla4xxx_get_prop_12chars
+ *	Get a 6-byte property value for the specified property name by
+ *      converting from the property string found in the configuration file.
+ *      The resulting converted value is in big endian format (MSB at byte0).
+ *
+ * Input:
+ *	ha = adapter state pointer.
+ *	propname = property name pointer.
+ *	propval  = pointer to location for the converted property val.
+ *      db = pointer to database
+ *
+ * Returns:
+ *	0 = value returned successfully.
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+int
+qla4xxx_get_prop_12chars(scsi_qla_host_t *ha, uint8_t *propname,
+			 uint8_t *propval, uint8_t *db)
+{
+	char            *propstr;
+	int             i, k;
+	int             rval;
+	uint8_t         nval;
+	uint8_t         *pchar;
+	uint8_t         *ret_byte;
+	uint8_t         *tmp_byte;
+	uint8_t         *retval = (uint8_t*)propval;
+	uint8_t         tmpval[6] = {0, 0, 0, 0, 0, 0};
+	uint16_t        max_byte_cnt = 6;	  /* 12 chars = 6 bytes */
+	uint16_t        max_strlen = 12;
+	static char     buf[LINESIZE];
+
+	rval = qla4xxx_find_propname(ha, propname, buf, db, max_strlen);
+
+	propstr = &buf[0];
+	if (*propstr == '=')
+		propstr++;	     /* ignore equal sign */
+
+	if (rval == 0) {
+		return(1);
+	}
+
+	/* Convert string to numbers. */
+	pchar = (uint8_t *)propstr;
+	tmp_byte = (uint8_t *)tmpval;
+
+	rval = 0;
+	for (i = 0; i < max_strlen; i++) {
+		/*
+		 * Check for invalid character, two at a time,
+		 * then convert them starting with first byte.
+		 */
+
+		if ((pchar[i] >= '0') && (pchar[i] <= '9')) {
+			nval = pchar[i] - '0';
+		}
+		else if ((pchar[i] >= 'A') && (pchar[i] <= 'F')) {
+			nval = pchar[i] - 'A' + 10;
+		}
+		else if ((pchar[i] >= 'a') && (pchar[i] <= 'f')) {
+			nval = pchar[i] - 'a' + 10;
+		}
+		else {
+			/* invalid character */
+			rval = 1;
+			break;
+		}
+
+		if (i & 0x01) {
+			*tmp_byte = *tmp_byte | nval;
+			tmp_byte++;
+		}
+		else {
+			*tmp_byte = *tmp_byte | nval << 4;
+		}
+	}
+
+	if (rval != 0) {
+		/* Encountered invalid character. */
+		return(rval);
+	}
+
+	/* Copy over the converted value. */
+	ret_byte = retval;
+	tmp_byte = tmpval;
+
+	i = max_byte_cnt;
+	k = 0;
+	while (i--) {
+		*ret_byte++ = *tmp_byte++;
+	}
+
+	/* big endian retval[0]; */
+	return(QLA_SUCCESS);
+}
+
+/**************************************************************************
+ * qla4xxx_add_device_dynamically
+ *	This routine processes adds a device as a result of an 8014h AEN.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *      fw_ddb_index - Firmware's device database index
+ *
+ * Returns:
+ *	None
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static void
+qla4xxx_add_device_dynamically(scsi_qla_host_t *ha, uint32_t fw_ddb_index)
+{
+	ddb_entry_t *ddb_entry;
+
+	ENTER("qla4xxx_add_device_dynamically");
+
+	/* First allocate a device structure */
+	ddb_entry = qla4xxx_get_ddb_entry(ha, fw_ddb_index);
+	if (ddb_entry == NULL) {
+		QL4PRINT(QLP2, printk(KERN_WARNING
+				      "scsi%d: Unable to allocate memory to add fw_ddb_index "
+				      "%d\n", ha->host_no, fw_ddb_index));
+	} else if (qla4xxx_update_ddb_entry(ha, ddb_entry, fw_ddb_index) ==
+		 QLA_ERROR) {
+		ha->fw_ddb_index_map[fw_ddb_index] =
+		(ddb_entry_t *) INVALID_ENTRY;
+		QL4PRINT(QLP2, printk(KERN_WARNING
+				      "scsi%d: failed to add new device at index [%d]\n"
+				      "Unable to retrieve fw ddb entry\n", ha->host_no,
+				      fw_ddb_index));
+	} else {
+		/* New device. Let's add it to the database */
+		DEBUG2(printk("scsi%d: %s: new device at index [%d]\n",
+			      ha->host_no, __func__, fw_ddb_index));
+
+		qla4xxx_update_fcport(ha, ddb_entry->fcport);
+			qla4xxx_config_os(ha);
+
+	}
+
+	LEAVE("qla4xxx_add_device_dynamically");
+}
+
+
+/**************************************************************************
+ * qla4xxx_process_ddb_changed
+ *	This routine processes a Decive Database Changed AEN Event.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *      fw_ddb_index - Firmware's device database index
+ *      state - Device state
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully processed ddb_changed aen
+ *	QLA_ERROR   - Failed to process ddb_changed aen
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_process_ddb_changed(scsi_qla_host_t *ha, uint32_t fw_ddb_index,
+			    uint32_t state)
+{
+	ddb_entry_t *ddb_entry;
+	uint32_t    old_fw_ddb_device_state;
+
+	ENTER(__func__);
+
+	/* check for out of range index */
+	if (fw_ddb_index >= MAX_DDB_ENTRIES) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: device index [%d] out of "
+				      "range\n", ha->host_no, __func__, fw_ddb_index));
+
+		LEAVE(__func__);
+		return(QLA_ERROR);
+	}
+
+	/* Get the corresponging ddb entry */
+	ddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, fw_ddb_index);
+
+	/* Device does not currently exist in our database. */
+	if (ddb_entry == NULL) {
+		if (state == DDB_DS_SESSION_ACTIVE) {
+			qla4xxx_add_device_dynamically(ha, fw_ddb_index);
+		}
+		LEAVE(__func__);
+
+		return(QLA_SUCCESS);
+	}
+
+	/* Device already exists in our database. */
+	old_fw_ddb_device_state = ddb_entry->fw_ddb_device_state;
+	DEBUG2(printk("scsi%d: %s DDB - old state= 0x%x, "
+		      "new state=0x%x for index [%d]\n",
+		      ha->host_no, __func__, ddb_entry->fw_ddb_device_state,
+		      state,
+		      fw_ddb_index));
+
+	if ((old_fw_ddb_device_state == state) && (state == DDB_DS_SESSION_ACTIVE)) {
+		/* Do nothing, state not changed. */
+		LEAVE(__func__);
+		return(QLA_SUCCESS);
+	}
+
+	ddb_entry->fw_ddb_device_state = state;
+
+	/* Device is back online. */
+	if (ddb_entry->fw_ddb_device_state == DDB_DS_SESSION_ACTIVE) {
+		atomic_set(&ddb_entry->port_down_timer,
+			   ha->port_down_retry_count);
+		atomic_set(&ddb_entry->state, DEV_STATE_ONLINE);
+		atomic_set(&ddb_entry->relogin_retry_count, 0);
+		atomic_set(&ddb_entry->relogin_timer, 0);
+		clear_bit(DF_RELOGIN, &ddb_entry->flags);
+		clear_bit(DF_NO_RELOGIN, &ddb_entry->flags);
+		qla4xxx_update_fcport(ha, ddb_entry->fcport);
+
+/* XXX FIXUP LUN_READY/SUSPEND code -- dg */
+		/*
+		 * Change the lun state to READY in case the lun TIMEOUT before
+		 * the device came back.
+		 */
+		if (ddb_entry->fcport->vis_ha) {
+			int t, l;
+			unsigned long cpu_flags;
+			os_lun_t *lq;
+			scsi_qla_host_t *os_ha;
+
+			os_ha = ddb_entry->fcport->vis_ha;
+			for (t = 0; t < MAX_TARGETS; t++) {
+				for (l = 0; l < MAX_LUNS; l++) {
+					if (!(lq = GET_LU_Q(os_ha, t, l)))
+						continue;
+
+					spin_lock_irqsave(&lq->lun_lock,
+							  cpu_flags);
+					lq->lun_state = LS_LUN_READY;
+					ddb_entry->fcport->vis_ha = NULL;
+					spin_unlock_irqrestore(&lq->lun_lock,
+							       cpu_flags);
+
+				}
+			}
+		}
+
+	} else {		
+		/* Device went away, try to relogin. */
+		/* Mark device missing */
+		if (atomic_read(&ddb_entry->state) == DEV_STATE_ONLINE)
+			qla4xxx_mark_device_missing(ha, ddb_entry);
+
+		/*
+		 * Relogin if device state changed to a not active state.
+		 * However, do not relogin if this aen is a result of an IOCTL
+		 * logout (DF_NO_RELOGIN) or if this is a discovered device.
+		 */
+		if (ddb_entry->fw_ddb_device_state == DDB_DS_SESSION_FAILED &&
+		    (!test_bit(DF_RELOGIN, &ddb_entry->flags)) &&
+		    (!test_bit(DF_NO_RELOGIN, &ddb_entry->flags)) &&
+		    (!test_bit(DF_ISNS_DISCOVERED, &ddb_entry->flags))) {
+
+			/*
+			 * This triggers a relogin.  After the relogin_timer
+			 * expires, the relogin gets scheduled.  We must wait a
+			 * minimum amount of time since receiving an 0x8014 AEN
+			 * with failed device_state or a logout response before
+			 * we can issue another relogin.
+			 */
+			/* Firmware padds this timeout: (time2wait +1).
+			 * Driver retry to login should be longer than F/W.
+			 * Otherwise F/W will fail
+			 * set_ddb() mbx cmd with 0x4005 since it still
+			 * counting down its time2wait.
+			 */
+			atomic_set(&ddb_entry->relogin_timer, 0);
+			atomic_set(&ddb_entry->retry_relogin_timer,
+				   ddb_entry->default_time2wait + 4);
+			QL4PRINT(QLP2, printk("scsi%d:%d:%d: index [%d] "
+					      "initate relogin after %d seconds\n", ha->host_no,
+					      ddb_entry->bus, ddb_entry->target,
+					      ddb_entry->fw_ddb_index,
+					      ddb_entry->default_time2wait));
+		}
+	}
+
+	LEAVE(__func__);
+
+	return(QLA_SUCCESS);
+}
+
+
+/**************************************************************************
+ * qla4xxx_login_device
+ *	This routine is called by the login IOCTL to log in the specified
+ *	device.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ * 	fw_ddb_index - Index of the device to login
+ * 	connection_id - Connection ID of the device to login
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully logged in device
+ *	QLA_ERROR   - Failed to login device
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_login_device(scsi_qla_host_t *ha, uint16_t fw_ddb_index,
+		     uint16_t connection_id)
+{
+	ddb_entry_t *ddb_entry;
+	uint8_t status = QLA_ERROR;
+
+	ENTER("qla4xxx_login_device");
+
+	QL4PRINT(QLP3, printk("scsi%d: %s: Login index [%d]\n", ha->host_no,
+			      __func__, fw_ddb_index));
+
+	ddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, fw_ddb_index);
+	if (ddb_entry == NULL) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: Invalid index [%d]\n",
+				      ha->host_no, __func__, fw_ddb_index));
+		goto exit_login_device;
+	}
+
+	if (qla4xxx_get_fwddb_entry(ha, fw_ddb_index, NULL, 0, NULL, NULL,
+				    &ddb_entry->fw_ddb_device_state, NULL, NULL, NULL) == QLA_ERROR) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: 1st get ddb entry failed\n",
+				      ha->host_no, __func__));
+		goto exit_login_device;
+	}
+
+	if (ddb_entry->fw_ddb_device_state == DDB_DS_SESSION_ACTIVE) {
+		QL4PRINT(QLP3, printk("scsi%d: %s: login successful for index "
+				      "[%d]\n", ha->host_no, __func__, ddb_entry->fw_ddb_index));
+
+		status = QLA_SUCCESS;
+
+		goto exit_login_device;
+	}
+
+	if (qla4xxx_conn_close_sess_logout(ha, fw_ddb_index, connection_id,
+					   LOGOUT_OPTION_RELOGIN) != QLA_SUCCESS) {
+		goto exit_login_device;
+	}
+
+	status = QLA_SUCCESS;
+
+	exit_login_device:
+	LEAVE("qla4xxx_login_device");
+
+	return(status);
+}
+
+/**************************************************************************
+ * qla4xxx_logout_device
+ *	This support routine is called by the logout IOCTL to log out
+ *	the specified device.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ * 	fw_ddb_index - Index of the device to logout
+ * 	connection_id - Connection ID of the device to logout
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully logged out device
+ *	QLA_ERROR   - Failed to logout device
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_logout_device(scsi_qla_host_t *ha, uint16_t fw_ddb_index,
+		      uint16_t connection_id)
+{
+	uint8_t     status = QLA_ERROR;
+	ddb_entry_t *ddb_entry;
+	uint32_t    old_fw_ddb_device_state;
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+		 printk("scsi%d: %s: inst %d entered. index=%d.\n",
+			ha->host_no, __func__, ha->instance, fw_ddb_index));
+
+	ddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, fw_ddb_index);
+	if (ddb_entry == NULL) {
+		QL4PRINT(QLP2|QLP4,
+			 printk("scsi%d: %s: Invalid index [%d]\n",
+				ha->host_no, __func__, fw_ddb_index));
+		goto exit_logout_device;
+	}
+
+	if (qla4xxx_get_fwddb_entry(ha, fw_ddb_index, NULL, 0, NULL, NULL,
+				    &old_fw_ddb_device_state, NULL, NULL, NULL) != QLA_SUCCESS) {
+		QL4PRINT(QLP2|QLP4,
+			 printk("scsi%d: %s: get_ddb_entry failed\n",
+				ha->host_no, __func__));
+		goto exit_logout_device;
+	}
+
+	set_bit(DF_NO_RELOGIN, &ddb_entry->flags);
+
+	if (qla4xxx_conn_close_sess_logout(ha, fw_ddb_index, connection_id,
+					   LOGOUT_OPTION_CLOSE_SESSION) != QLA_SUCCESS) {
+		goto exit_logout_device;
+	}
+
+	status = QLA_SUCCESS;
+
+	exit_logout_device:
+	QL4PRINT(QLP4,
+		 printk("scsi%d: %s: inst %d exiting.\n",
+			ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return(status);
+}
+
+void
+qla4xxx_flush_all_srbs(scsi_qla_host_t *ha, ddb_entry_t *ddb_entry,
+		       os_lun_t *lun_entry)
+{
+	int         i;
+	unsigned long flags;
+	srb_t       *srb;
+
+	if (lun_entry == NULL || ddb_entry == NULL)
+		return;
+
+	/* free active commands */
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	if (lun_entry->out_count != 0) {
+		for (i = 1; i < MAX_SRBS; i++) {
+			srb = ha->active_srb_array[i];
+			if (!srb)
+				continue;
+
+			QL4PRINT(QLP3, printk("scsi%d:%d:%d:%d: %s: found srb "
+					      "%p in active_q\n", ha->host_no, ddb_entry->bus,
+					      ddb_entry->target, lun_entry->lun, __func__, srb));
+
+			if (srb->lun_queue != lun_entry)
+				continue;
+
+			del_from_active_array(ha, i);
+			srb->cmd->result = DID_NO_CONNECT << 16;
+			add_to_done_srb_q(ha,srb);
+		}
+	}
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	/* Send all srbs back to OS */
+	if (!list_empty(&ha->done_srb_q)) {
+		qla4xxx_done(ha);
+	}
+}
+
+
+/**************************************************************************
+ * qla4xxx_delete_device
+ *	This routine is called by the logout IOCTL to delete the specified
+ *      device.	 Send the LOGOUT and DELETE_DDB commands for the specified
+ *      target, even if it's not in our internal database.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ * 	fw_ddb_index - Index of the device to delete
+ * 	connection_id - Connection ID of the device to delete
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully deleted device
+ *	QLA_ERROR   - Failed to delete device
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_delete_device(scsi_qla_host_t *ha, uint16_t fw_ddb_index,
+		      uint16_t connection_id)
+{
+	uint8_t     status = QLA_ERROR;
+	uint32_t    fw_ddb_device_state = 0xFFFF;
+	u_long     wait_count;
+	ddb_entry_t *ddb_entry;
+
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+		 printk("scsi%d: %s: inst %d entered. index=%d.\n",
+			ha->host_no, __func__, ha->instance, fw_ddb_index));
+
+	/* If the device is in our internal tables, set the NO_RELOGIN bit. */
+	ddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, fw_ddb_index);
+	if (ddb_entry != NULL) {
+		QL4PRINT(QLP4,
+			 printk("scsi%d:%d:%d: %s:  setting NO_RELOGIN flag\n",
+				ha->host_no, ddb_entry->bus, ddb_entry->target, __func__));
+
+		set_bit(DF_NO_RELOGIN, &ddb_entry->flags);
+	}
+
+	/*
+	 * If the device state is already one that we can delete, bypass the
+	 * logout command.
+	 */
+	qla4xxx_get_fwddb_entry(ha, fw_ddb_index, NULL, 0, NULL, NULL,
+				&fw_ddb_device_state, NULL, NULL, NULL);
+	if (fw_ddb_device_state == DDB_DS_UNASSIGNED ||
+	    fw_ddb_device_state == DDB_DS_NO_CONNECTION_ACTIVE ||
+	    fw_ddb_device_state == DDB_DS_SESSION_FAILED)
+		goto delete_ddb;
+
+	/* First logout index */
+	if (qla4xxx_conn_close_sess_logout(ha, fw_ddb_index, connection_id,
+					   LOGOUT_OPTION_CLOSE_SESSION) != QLA_SUCCESS) {
+		QL4PRINT(QLP2|QLP4,
+			 printk("scsi%d: %s: LOGOUT_OPTION_CLOSE_SESSION "
+				"failed index [%d]\n", ha->host_no, __func__,
+				fw_ddb_index));
+		goto exit_delete_ddb;
+	}
+
+	/* Wait enough time to complete logout */
+	wait_count = jiffies + LOGOUT_TOV * HZ;
+	while (qla4xxx_get_fwddb_entry(ha, fw_ddb_index, NULL, 0, NULL, NULL,
+				       &fw_ddb_device_state, NULL, NULL, NULL) == QLA_SUCCESS) {
+		if (time_after_eq(jiffies, wait_count))
+			goto exit_delete_ddb;
+
+		if (fw_ddb_device_state == DDB_DS_UNASSIGNED ||
+		    fw_ddb_device_state == DDB_DS_NO_CONNECTION_ACTIVE ||
+		    fw_ddb_device_state == DDB_DS_SESSION_FAILED)
+			break;
+
+		udelay(50);
+	}
+
+	delete_ddb:
+	/* Now delete index */
+	if (qla4xxx_clear_database_entry(ha, fw_ddb_index) == QLA_SUCCESS) {
+		uint16_t lun;
+		os_lun_t *lun_entry;
+		os_tgt_t *tgt_entry;
+
+		status = QLA_SUCCESS;
+		if (!ddb_entry)
+			goto exit_delete_ddb;
+
+		atomic_set(&ddb_entry->state, DEV_STATE_DEAD);
+		atomic_set(&ddb_entry->fcport->state, FCS_DEVICE_DEAD);
+
+		tgt_entry = qla4xxx_lookup_target_by_fcport(ha,
+							    ddb_entry->fcport);
+		if (tgt_entry) {
+			for (lun = 0; lun < MAX_LUNS; lun++) {
+				lun_entry = tgt_entry->olun[lun];
+				if (lun_entry != NULL) {
+					unsigned long cpu_flags;
+
+					QL4PRINT(QLP4, printk(
+							     "scsi%d:%d:%d:%d: %s: flushing "
+							     "srbs, pendq_cnt=%d, retryq_cnt="
+							     "%d, activeq_cnt=%d\n", ha->host_no,
+							     ddb_entry->bus, tgt_entry->id, lun,
+							     __func__, 0 ,
+							     ha->retry_srb_q_count,
+							     ha->active_srb_count));
+
+					qla4xxx_flush_all_srbs(ha, ddb_entry,
+							       lun_entry);
+
+					spin_lock_irqsave(&lun_entry->lun_lock,
+							  cpu_flags);
+
+					if (lun_entry->lun_state ==
+					    LS_LUN_SUSPENDED) {
+						lun_entry->lun_state =
+						LS_LUN_READY;
+					}
+
+					spin_unlock_irqrestore(
+							      &lun_entry->lun_lock, cpu_flags);
+				}
+			}
+		}
+
+		QL4PRINT(QLP4,
+			 printk("scsi%d: %s: removing index %d.\n",
+				ha->host_no, __func__, fw_ddb_index));
+
+		ha->fw_ddb_index_map[fw_ddb_index] =
+		(ddb_entry_t *) INVALID_ENTRY;
+	}
+
+	exit_delete_ddb:
+	QL4PRINT(QLP4,
+		 printk("scsi%d: %s: inst %d exiting.\n",
+			ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return(status);
+}
+
+
+/*
+ * Overrides for Emacs so that we almost follow Linus's tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 2
+ * c-brace-imaginary-offset: 0
+ * c-brace-offset: -2
+ * c-argdecl-indent: 2
+ * c-label-offset: -2
+ * c-continued-statement-offset: 2
+ * c-continued-brace-offset: 0
+ * indent-tabs-mode: nil
+ * tab-width: 8
+ * End:
+ */
diff --git a/drivers/scsi/qla4xxx/ql4_inline.h b/drivers/scsi/qla4xxx/ql4_inline.h
new file mode 100644
index 0000000..c38276a
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_inline.h
@@ -0,0 +1,334 @@
+/******************************************************************************
+ *     Copyright (C)  2003 -2005 QLogic Corporation
+ * QLogic ISP4xxx Device Driver
+ *
+ * This program includes a device driver for Linux 2.6.x that may be
+ * distributed with QLogic hardware specific firmware binary file.
+ * You may modify and redistribute the device driver code under the
+ * GNU General Public License as published by the Free Software Foundation
+ * (version 2 or a later version) and/or under the following terms,
+ * as applicable:
+ *
+ * 	1. Redistribution of source code must retain the above copyright
+ *         notice, this list of conditions and the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above copyright
+ *         notice, this list of conditions and the following disclaimer in
+ *         the documentation and/or other materials provided with the
+ *         distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ * 	
+ * You may redistribute the hardware specific firmware binary file under
+ * the following terms:
+ * 	1. Redistribution of source code (only if applicable), must
+ *         retain the above copyright notice, this list of conditions and
+ *         the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above
+ *         copyright notice, this list of conditions and the following
+ *         disclaimer in the documentation and/or other materials provided
+ *         with the distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ *
+ * REGARDLESS OF WHAT LICENSING MECHANISM IS USED OR APPLICABLE,
+ * THIS PROGRAM IS PROVIDED BY QLOGIC CORPORATION "AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * USER ACKNOWLEDGES AND AGREES THAT USE OF THIS PROGRAM WILL NOT CREATE
+ * OR GIVE GROUNDS FOR A LICENSE BY IMPLICATION, ESTOPPEL, OR OTHERWISE
+ * IN ANY INTELLECTUAL PROPERTY RIGHTS (PATENT, COPYRIGHT, TRADE SECRET,
+ * MASK WORK, OR OTHER PROPRIETARY RIGHT) EMBODIED IN ANY OTHER QLOGIC
+ * HARDWARE OR SOFTWARE EITHER SOLELY OR IN COMBINATION WITH THIS PROGRAM
+ *
+ ******************************************************************************
+ *             Please see release.txt for revision history.                   *
+ *                                                                            *
+ ******************************************************************************
+ * Function Table of Contents:
+ *
+ ****************************************************************************/
+
+/**************************************************************************
+ * qla4xxx_lookup_lun_handle
+ *	This routine locates a lun handle given the device handle and lun
+ *	number.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	ddb_entry - Pointer to device database entry
+ *	lun - SCSI LUN
+ *
+ * Returns:
+ *	Pointer to corresponding lun_entry structure
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static inline os_lun_t *
+qla4xxx_lookup_lun_handle(scsi_qla_host_t *ha, os_tgt_t *tq, uint16_t lun)
+{
+	os_lun_t *lq = NULL;
+
+	if (tq && lun < MAX_LUNS)
+		lq = tq->olun[lun];
+	return lq;
+}
+
+/**************************************************************************
+ * qla4xxx_lookup_target_by_SCSIID
+ *	This routine locates a target handle given the SCSI bus and
+ *	target IDs.  If device doesn't exist, returns NULL.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	bus - SCSI bus number
+ *	target - SCSI target ID.
+ *
+ * Returns:
+ *	Pointer to the corresponding internal device database structure
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static inline os_tgt_t *
+qla4xxx_lookup_target_by_SCSIID(scsi_qla_host_t *ha, uint32_t bus,
+    uint32_t target)
+{
+	os_tgt_t *tq = NULL;
+
+	if (target < MAX_TARGETS)
+		tq = TGT_Q(ha, target);
+
+	QL4PRINT(QLP3, printk("scsi%d: %s: b%d:t%d, tgt = %p\n",
+	    ha->host_no, __func__, bus, target, tq));
+
+	return tq;
+}
+
+/**************************************************************************
+ * qla4xxx_lookup_target_by_fcport
+ *	This routine locates a target handle given the fcport
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	fcport - port handle
+ *
+ * Returns:
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static inline os_tgt_t *
+qla4xxx_lookup_target_by_fcport(scsi_qla_host_t *ha, fc_port_t  *fcport)
+{
+	int t;
+	os_tgt_t *tq = NULL;
+
+	for (t = 0; t < MAX_TARGETS; t++) {
+		if ((tq = TGT_Q(ha, t)) == NULL)
+			continue;
+
+		if (fcport == tq->fcport)
+			break;
+	}
+
+	return tq;
+}
+
+
+/**************************************************************************
+ * qla4xxx_lookup_ddb_by_fw_index
+ *	This routine locates a device handle given the firmware device
+ *	database index.  If device doesn't exist, returns NULL.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *      fw_ddb_index - Firmware's device database index
+ *
+ * Returns:
+ *	Pointer to the corresponding internal device database structure
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static inline ddb_entry_t *
+qla4xxx_lookup_ddb_by_fw_index(scsi_qla_host_t *ha, uint32_t fw_ddb_index)
+{
+	ddb_entry_t *ddb_entry = NULL;
+
+	if ((fw_ddb_index < MAX_DDB_ENTRIES) &&
+	    (ha->fw_ddb_index_map[fw_ddb_index] !=
+		(ddb_entry_t *) INVALID_ENTRY)) {
+		ddb_entry = ha->fw_ddb_index_map[fw_ddb_index];
+	}
+
+	DEBUG3(printk("scsi%d: %s: index [%d], ddb_entry = %p\n",
+	    ha->host_no, __func__, fw_ddb_index, ddb_entry));
+
+	return ddb_entry;
+}
+
+/**************************************************************************
+ * qla4xxx_mark_device_missing
+ *	This routine marks a device missing and resets the relogin retry count.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	ddb_entry - Pointer to device database entry
+ *
+ * Returns:
+ *	None
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static inline void
+qla4xxx_mark_device_missing(scsi_qla_host_t *ha, ddb_entry_t *ddb_entry)
+{
+	atomic_set(&ddb_entry->state, DEV_STATE_MISSING);
+	if (ddb_entry->fcport != NULL)
+		atomic_set(&ddb_entry->fcport->state, FCS_DEVICE_LOST);
+
+	QL4PRINT(QLP2, printk("scsi%d:%d:%d: index [%d] marked "
+	    "MISSING\n", ha->host_no, ddb_entry->bus, ddb_entry->target,
+	    ddb_entry->fw_ddb_index));
+}
+
+/**************************************************************************
+ * qla4xxx_enable_intrs
+ *	This routine enables the PCI interrupt request by clearing the
+ *	appropriate bit.
+ *
+ * qla4xxx_disable_intrs
+ *	This routine disables the PCI interrupt request by setting the
+ *	appropriate bit.
+ *
+ * Remarks:
+ *	The hardware_lock must be unlocked upon entry.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	None
+ *
+ * Context:
+ *	Kernel/Interrupt context.
+ **************************************************************************/
+static inline void __qla4xxx_enable_intrs(scsi_qla_host_t *ha)
+{
+	ENTER("qla4xxx_enable_intrs");
+	set_bit(AF_INTERRUPTS_ON, &ha->flags);
+
+	if( IS_QLA4022(ha) ) {
+		WRT_REG_DWORD(&ha->reg->u1.isp4022.intr_mask, SET_RMASK(IMR_SCSI_INTR_ENABLE));
+		PCI_POSTING(&ha->reg->u1.isp4022.intr_mask);
+	} else {
+		WRT_REG_DWORD(&ha->reg->ctrl_status, SET_RMASK(CSR_SCSI_INTR_ENABLE));
+		PCI_POSTING(&ha->reg->ctrl_status);
+		QL4PRINT(QLP7, printk("scsi%d: %s: intSET_RMASK = %08x\n",
+			      ha->host_no, __func__,
+			      RD_REG_DWORD(&ha->reg->ctrl_status)));
+	}
+	LEAVE("qla4xxx_enable_intrs");
+}
+
+static inline void __qla4xxx_disable_intrs(scsi_qla_host_t *ha)
+{
+
+	ENTER("qla4xxx_disable_intrs");
+	clear_bit(AF_INTERRUPTS_ON, &ha->flags);
+	
+	if( IS_QLA4022(ha) ) {
+		WRT_REG_DWORD(&ha->reg->u1.isp4022.intr_mask, CLR_RMASK(IMR_SCSI_INTR_ENABLE));
+		PCI_POSTING(&ha->reg->u1.isp4022.intr_mask);
+		QL4PRINT(QLP7, printk("scsi%d: %s: intr_mask = %08x\n",
+			      ha->host_no, __func__,
+			      RD_REG_DWORD(&ha->reg->u1.isp4022.intr_mask)));
+	} else {
+		WRT_REG_DWORD(&ha->reg->ctrl_status, CLR_RMASK(CSR_SCSI_INTR_ENABLE));
+		PCI_POSTING(&ha->reg->ctrl_status);
+		QL4PRINT(QLP7, printk("scsi%d: %s: intSET_RMASK = %08x\n",
+			      ha->host_no, __func__,
+			      RD_REG_DWORD(&ha->reg->ctrl_status)));
+	}
+	LEAVE("qla4xxx_disable_intrs");
+}
+static inline void qla4xxx_enable_intrs(scsi_qla_host_t *ha)
+{
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	__qla4xxx_enable_intrs(ha);
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+}
+
+static inline void qla4xxx_disable_intrs(scsi_qla_host_t *ha)
+{
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	__qla4xxx_disable_intrs(ha);
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+}
+
+static inline int
+qla4xxx_is_eh_active(struct Scsi_Host *shost)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,15)
+ if (shost->eh_active)
+ return 1;
+#else
+ if (shost->shost_state == SHOST_RECOVERY)
+ return 1;
+#endif
+ return 0;
+};
+
+static __inline__ void
+qla4xxx_suspend_lun(scsi_qla_host_t *, srb_t *sp, os_lun_t *, int, int);
+static __inline__ void
+qla4xxx_delay_lun(scsi_qla_host_t *, os_lun_t *, int);
+
+static __inline__ void
+qla4xxx_suspend_lun(scsi_qla_host_t *ha, srb_t *sp, os_lun_t *lq, int time, int count)
+{
+	return (__qla4xxx_suspend_lun(ha, sp, lq, time, count, 0));
+}
+
+static __inline__ void
+qla4xxx_delay_lun(scsi_qla_host_t *ha, os_lun_t *lq, int time)
+{
+	return (__qla4xxx_suspend_lun(ha, NULL, lq, time, 1, 1));
+}
+
+/*
+ * Overrides for Emacs so that we almost follow Linus's tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 2
+ * c-brace-imaginary-offset: 0
+ * c-brace-offset: -2
+ * c-argdecl-indent: 2
+ * c-label-offset: -2
+ * c-continued-statement-offset: 2
+ * c-continued-brace-offset: 0
+ * indent-tabs-mode: nil
+ * tab-width: 8
+ * End:
+ */
+
diff --git a/drivers/scsi/qla4xxx/ql4_iocb.c b/drivers/scsi/qla4xxx/ql4_iocb.c
new file mode 100644
index 0000000..5467a22
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_iocb.c
@@ -0,0 +1,412 @@
+/******************************************************************************
+ *     Copyright (C)  2003 -2005 QLogic Corporation
+ * QLogic ISP4xxx Device Driver
+ *
+ * This program includes a device driver for Linux 2.6.x that may be
+ * distributed with QLogic hardware specific firmware binary file.
+ * You may modify and redistribute the device driver code under the
+ * GNU General Public License as published by the Free Software Foundation
+ * (version 2 or a later version) and/or under the following terms,
+ * as applicable:
+ *
+ * 	1. Redistribution of source code must retain the above copyright
+ *         notice, this list of conditions and the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above copyright
+ *         notice, this list of conditions and the following disclaimer in
+ *         the documentation and/or other materials provided with the
+ *         distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ * 	
+ * You may redistribute the hardware specific firmware binary file under
+ * the following terms:
+ * 	1. Redistribution of source code (only if applicable), must
+ *         retain the above copyright notice, this list of conditions and
+ *         the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above
+ *         copyright notice, this list of conditions and the following
+ *         disclaimer in the documentation and/or other materials provided
+ *         with the distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ *
+ * REGARDLESS OF WHAT LICENSING MECHANISM IS USED OR APPLICABLE,
+ * THIS PROGRAM IS PROVIDED BY QLOGIC CORPORATION "AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * USER ACKNOWLEDGES AND AGREES THAT USE OF THIS PROGRAM WILL NOT CREATE
+ * OR GIVE GROUNDS FOR A LICENSE BY IMPLICATION, ESTOPPEL, OR OTHERWISE
+ * IN ANY INTELLECTUAL PROPERTY RIGHTS (PATENT, COPYRIGHT, TRADE SECRET,
+ * MASK WORK, OR OTHER PROPRIETARY RIGHT) EMBODIED IN ANY OTHER QLOGIC
+ * HARDWARE OR SOFTWARE EITHER SOLELY OR IN COMBINATION WITH THIS PROGRAM
+ *
+ ******************************************************************************
+ *             Please see release.txt for revision history.                   *
+ *                                                                            *
+ ******************************************************************************
+ * Function Table of Contents:
+ *      qla4xxx_get_req_pkt
+ *      qla4xxx_send_marker_iocb
+ *	qla4xxx_get_pdu
+ *	qla4xxx_free_pdu
+ *	qla4xxx_send_passthru0_iocb
+ ****************************************************************************/
+
+#include "ql4_def.h"
+
+/**************************************************************************
+ * qla4xxx_get_req_pkt
+ *	This routine performs the following tasks:
+ *	- returns the current request_in pointer (if queue not full)
+ *	- advances the request_in pointer
+ *	- checks for queue full
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	queue_entry - Pointer to pointer to queue entry structure
+ *
+ * Output:
+ *	queue_entry - Return pointer to next available request packet
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully retrieved request packet
+ *	QLA_ERROR   - Failed to retrieve request packet
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_get_req_pkt(scsi_qla_host_t *ha, QUEUE_ENTRY **queue_entry)
+{
+	uint16_t  request_in;
+	uint8_t   status = QLA_SUCCESS;
+
+	ENTER("qla4xxx_get_req_pkt");
+
+	*queue_entry = ha->request_ptr;
+
+	/* get the latest request_in and request_out index */
+	request_in = ha->request_in;
+	ha->request_out =
+	    (uint16_t) le32_to_cpu(ha->shadow_regs->req_q_out);
+
+	/* Advance request queue pointer and check for queue full */
+	if (request_in == (REQUEST_QUEUE_DEPTH - 1)) {
+		request_in = 0;
+		ha->request_ptr = ha->request_ring;
+		QL4PRINT(QLP10, printk("scsi%d: %s: wraparound -- new "
+		    "request_in = %04x, new request_ptr = %p\n", ha->host_no,
+		    __func__, request_in, ha->request_ptr));
+	} else {
+		request_in++;
+		ha->request_ptr++;
+		QL4PRINT(QLP10, printk("scsi%d: %s: new request_in = %04x, new "
+		    "request_ptr = %p\n", ha->host_no, __func__, request_in,
+		    ha->request_ptr));
+	}
+
+	/* request queue is full, try again later */
+	if ((ha->iocb_cnt + 1) >= ha->iocb_hiwat) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: request queue is full, "
+		    "iocb_cnt=%d, iocb_hiwat=%d\n", ha->host_no, __func__,
+		    ha->iocb_cnt, ha->iocb_hiwat));
+
+		/* restore request pointer */
+		ha->request_ptr = *queue_entry;
+		QL4PRINT(QLP2, printk("scsi%d: %s: restore request_ptr = %p, "
+		    "request_in = %04x, request_out = %04x\n", ha->host_no,
+		    __func__, ha->request_ptr, ha->request_in,
+		    ha->request_out));
+		status = QLA_ERROR;
+	} else {
+		ha->request_in = request_in;
+		memset(*queue_entry, 0, sizeof(**queue_entry));
+	}
+
+	LEAVE("qla4xxx_get_req_pkt");
+
+	return (status);
+}
+
+/**************************************************************************
+ * qla4xxx_send_marker_iocb
+ *	This routine issues a marker IOCB.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	ddb_entry - Pointer to device database entry
+ *	lun - SCSI LUN
+ *	marker_type - marker identifier
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully sent marker IOCB
+ *	QLA_ERROR   - Failed to send marker IOCB
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_send_marker_iocb(scsi_qla_host_t *ha, ddb_entry_t *ddb_entry,
+    fc_lun_t *lun_entry)
+{
+	MARKER_ENTRY *marker_entry;
+	unsigned long flags = 0;
+	uint8_t       status = QLA_SUCCESS;
+
+	ENTER("qla4xxx_send_marker_iocb");
+
+	/* Acquire hardware specific lock */
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+
+	/* Get pointer to the queue entry for the marker */
+	if (qla4xxx_get_req_pkt(ha, (QUEUE_ENTRY **) &marker_entry)
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: request queue full, try "
+		    "again later\n", ha->host_no, __func__));
+
+		status = QLA_ERROR;
+		goto exit_send_marker;
+	}
+
+	/* Put the marker in the request queue */
+	marker_entry->hdr.entryType = ET_MARKER;
+	marker_entry->hdr.entryCount = 1;
+	marker_entry->target = cpu_to_le16(ddb_entry->fw_ddb_index);
+	marker_entry->modifier = cpu_to_le16(MM_LUN_RESET);
+	marker_entry->lun[1] = LSB(lun_entry->lun);	 /*SAMII compliant lun*/
+	marker_entry->lun[2] = MSB(lun_entry->lun);
+	wmb();
+
+	QL4PRINT(QLP3, printk(
+	    "scsi%d:%d:%d:%d: LUN_RESET Marker sent\n", ha->host_no,
+	    ddb_entry->bus, ddb_entry->target, lun_entry->lun));
+
+	/* Tell ISP it's got a new I/O request */
+	WRT_REG_DWORD(&ha->reg->req_q_in, ha->request_in);
+	PCI_POSTING(&ha->reg->req_q_in);
+
+exit_send_marker:
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	LEAVE("qla4xxx_send_marker_iocb");
+
+	return (status);
+}
+
+PDU_ENTRY *
+qla4xxx_get_pdu(scsi_qla_host_t *ha, uint32_t length)
+{
+	PDU_ENTRY       *pdu;
+	PDU_ENTRY       *free_pdu_top;
+	PDU_ENTRY       *free_pdu_bottom;
+	uint16_t        pdu_active;
+
+	if (ha->free_pdu_top == NULL) {
+		QL4PRINT(QLP2|QLP19,
+			 printk("scsi%d: %s: Out of PDUs!\n",
+				ha->host_no, __func__));
+		return(NULL);
+	}
+
+	/* Save current state */
+	free_pdu_top    = ha->free_pdu_top;
+	free_pdu_bottom = ha->free_pdu_bottom;
+	pdu_active = ha->pdu_active + 1;
+
+	/* get next available pdu */
+	pdu = free_pdu_top;
+	free_pdu_top = pdu->Next;
+
+	if (free_pdu_top == NULL)
+		free_pdu_bottom = NULL;
+
+
+	/* round up to nearest page */
+	length = (length + (PAGE_SIZE-1)) & ~(PAGE_SIZE-1);
+
+
+	/* Allocate pdu buffer PDU */
+	pdu->Buff = pci_alloc_consistent(ha->pdev, length, &pdu->DmaBuff);
+	if (pdu->Buff == NULL) {
+		QL4PRINT(QLP2|QLP19,
+			 printk("scsi%d: %s: Unable to allocate memory "
+				"for PDU buffer\n",
+				ha->host_no, __func__));
+		return(NULL);
+	}
+	
+	memset(pdu->Buff, 0, length);
+	
+	/* Fill in remainder of PDU */
+	pdu->BuffLen = length;
+	pdu->SendBuffLen = 0;
+	pdu->RecvBuffLen = 0;
+	pdu->Next = NULL;
+
+	ha->free_pdu_top = free_pdu_top;
+	ha->free_pdu_bottom = free_pdu_bottom;
+	ha->pdu_active = pdu_active;
+
+	QL4PRINT(QLP19,
+		 printk("scsi%d: %s: Get PDU SUCCEEDED!  "
+			"Top %p Bot %p PDU %p Buf %p DmaBuf %lx Length %x "
+			"Active %d\n", ha->host_no, __func__, free_pdu_top,
+			free_pdu_bottom, pdu, pdu->Buff,
+			(unsigned long)pdu->DmaBuff, pdu->BuffLen,
+			pdu_active));
+	return(pdu);
+}
+
+void qla4xxx_free_pdu(scsi_qla_host_t *ha, PDU_ENTRY *pdu)
+{
+	if (ha->free_pdu_bottom == NULL) {
+		ha->free_pdu_top = pdu;
+		ha->free_pdu_bottom = pdu;
+	}
+	else {
+		ha->free_pdu_bottom->Next = pdu;
+		ha->free_pdu_bottom = pdu;
+	}
+
+	pci_free_consistent(ha->pdev, pdu->BuffLen, pdu->Buff, pdu->DmaBuff);
+	ha->pdu_active--;
+
+	QL4PRINT(QLP19,
+		 printk("scsi%d: %s: Top %p Bot %p PDU %p Buf %p DmaBuf %lx, "
+			"Length %x Active %d\n", ha->host_no, __func__,
+			ha->free_pdu_top,  ha->free_pdu_bottom, pdu, pdu->Buff,
+			(unsigned long) pdu->DmaBuff, pdu->BuffLen,
+			ha->pdu_active));
+
+	/* Clear PDU */
+	pdu->Buff = NULL;
+	pdu->BuffLen = 0;
+	pdu->SendBuffLen = 0;
+	pdu->RecvBuffLen = 0;
+	pdu->Next = NULL;
+	pdu->DmaBuff = 0;
+}
+
+/**************************************************************************
+ * qla4xxx_send_passthru0_iocb
+ *	This routine issues a passthru0 IOCB.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Remarks: hardware_lock acquired upon entry, interrupt context
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully sent marker IOCB
+ *	QLA_ERROR   - Failed to send marker IOCB
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_send_passthru0_iocb(scsi_qla_host_t *ha,
+			    uint16_t fw_ddb_index,
+			    uint16_t connection_id,
+			    dma_addr_t pdu_dma_data,
+			    uint32_t send_len,
+			    uint32_t recv_len,
+			    uint16_t control_flags,
+			    uint32_t handle)
+{
+	PASSTHRU0_ENTRY *passthru_entry;
+	uint8_t         status = QLA_SUCCESS;
+
+	ENTER("qla4xxx_send_passthru0_iocb");
+
+	/* Get pointer to the queue entry for the marker */
+	if (qla4xxx_get_req_pkt(ha, (QUEUE_ENTRY **) &passthru_entry)
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP5|QLP2|QLP19,
+			 printk("scsi%d: %s: request queue full, try again later\n",
+				ha->host_no, __func__));
+
+		status = QLA_ERROR;
+		goto exit_send_pt0;
+	}
+
+	/* Fill in the request queue */
+	passthru_entry->hdr.entryType  = ET_PASSTHRU0;
+	passthru_entry->hdr.entryCount = 1;
+	passthru_entry->handle         = cpu_to_le32(handle);
+	passthru_entry->target         = cpu_to_le16(fw_ddb_index);
+	passthru_entry->connectionID   = cpu_to_le16(connection_id);
+	passthru_entry->timeout        = __constant_cpu_to_le16(PT_DEFAULT_TIMEOUT);
+
+	if (send_len) {
+		control_flags |= PT_FLAG_SEND_BUFFER;
+		passthru_entry->outDataSeg64.base.addrHigh  =
+		cpu_to_le32(MSDW(pdu_dma_data));
+		passthru_entry->outDataSeg64.base.addrLow   =
+		cpu_to_le32(LSDW(pdu_dma_data));
+		passthru_entry->outDataSeg64.count          =
+		cpu_to_le32(send_len);
+
+		QL4PRINT(QLP19,
+			 printk("scsi%d: %s: sending 0x%X bytes, "
+				"pdu_dma_data = %lx\n",
+				ha->host_no, __func__, send_len,
+				(unsigned long)pdu_dma_data));
+	}
+
+	if (recv_len) {
+		passthru_entry->inDataSeg64.base.addrHigh = cpu_to_le32(MSDW(pdu_dma_data));
+		passthru_entry->inDataSeg64.base.addrLow  = cpu_to_le32(LSDW(pdu_dma_data));
+		passthru_entry->inDataSeg64.count         = cpu_to_le32(recv_len);
+		QL4PRINT(QLP19, printk("scsi%d: %s: receiving  0x%X bytes, pdu_dma_data = %lx\n",
+				       ha->host_no, __func__, recv_len, (unsigned long)pdu_dma_data));
+	}
+
+	passthru_entry->controlFlags   = cpu_to_le16(control_flags);
+
+	wmb();
+
+	QL4PRINT(QLP19, printk("scsi%d: Passthru0 IOCB type %x count %x In (%x) pt0 %p handle %x\n",
+			       ha->host_no, passthru_entry->hdr.entryType,
+			       passthru_entry->hdr.entryCount, ha->request_in, passthru_entry, handle));
+	qla4xxx_dump_bytes(QLP10, passthru_entry, sizeof(*passthru_entry));
+
+
+	/* Tell ISP it's got a new I/O request */
+	WRT_REG_DWORD(&ha->reg->req_q_in, ha->request_in);
+	PCI_POSTING(&ha->reg->req_q_in);
+
+	exit_send_pt0:
+	LEAVE("qla4xxx_send_passthru0_iocb");
+	return(status);
+}
+
+/*
+ * Overrides for Emacs so that we almost follow Linus's tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 2
+ * c-brace-imaginary-offset: 0
+ * c-brace-offset: -2
+ * c-argdecl-indent: 2
+ * c-label-offset: -2
+ * c-continued-statement-offset: 2
+ * c-continued-brace-offset: 0
+ * indent-tabs-mode: nil
+ * tab-width: 8
+ * End:
+ */
+
diff --git a/drivers/scsi/qla4xxx/ql4_ioctl.h b/drivers/scsi/qla4xxx/ql4_ioctl.h
new file mode 100644
index 0000000..be90748
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_ioctl.h
@@ -0,0 +1,138 @@
+/******************************************************************************
+ *     Copyright (C)  2003 -2005 QLogic Corporation
+ * QLogic ISP4xxx Device Driver
+ *
+ * This program includes a device driver for Linux 2.6.x that may be
+ * distributed with QLogic hardware specific firmware binary file.
+ * You may modify and redistribute the device driver code under the
+ * GNU General Public License as published by the Free Software Foundation
+ * (version 2 or a later version) and/or under the following terms,
+ * as applicable:
+ *
+ * 	1. Redistribution of source code must retain the above copyright
+ *         notice, this list of conditions and the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above copyright
+ *         notice, this list of conditions and the following disclaimer in
+ *         the documentation and/or other materials provided with the
+ *         distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ * 	
+ * You may redistribute the hardware specific firmware binary file under
+ * the following terms:
+ * 	1. Redistribution of source code (only if applicable), must
+ *         retain the above copyright notice, this list of conditions and
+ *         the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above
+ *         copyright notice, this list of conditions and the following
+ *         disclaimer in the documentation and/or other materials provided
+ *         with the distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ *
+ * REGARDLESS OF WHAT LICENSING MECHANISM IS USED OR APPLICABLE,
+ * THIS PROGRAM IS PROVIDED BY QLOGIC CORPORATION "AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * USER ACKNOWLEDGES AND AGREES THAT USE OF THIS PROGRAM WILL NOT CREATE
+ * OR GIVE GROUNDS FOR A LICENSE BY IMPLICATION, ESTOPPEL, OR OTHERWISE
+ * IN ANY INTELLECTUAL PROPERTY RIGHTS (PATENT, COPYRIGHT, TRADE SECRET,
+ * MASK WORK, OR OTHER PROPRIETARY RIGHT) EMBODIED IN ANY OTHER QLOGIC
+ * HARDWARE OR SOFTWARE EITHER SOLELY OR IN COMBINATION WITH THIS PROGRAM
+ *
+ ******************************************************************************/
+#ifndef _QL4_IOCTL_H_
+#define _QL4_IOCTL_H_
+
+#include <linux/blkdev.h>
+#include <asm/uaccess.h>
+
+/*---------------------------------------------------------------------------*/
+
+typedef struct {
+	int cmd;
+	char *s;
+} ioctl_tbl_row_t;
+
+#define	QL_KMEM_ZALLOC(siz)	ql4_kzmalloc((siz), GFP_ATOMIC)
+#define	QL_KMEM_FREE(ptr)	kfree((ptr))
+
+/* Defines for Passthru */
+#define IOCTL_INVALID_STATUS			0xffff
+#define IOCTL_PASSTHRU_TOV			60
+
+/*
+ * extern from ql4_xioctl.c
+ */
+extern void *
+Q64BIT_TO_PTR(uint64_t);
+
+extern inline void *
+ql4_kzmalloc(int, int);
+
+extern char *
+IOCTL_TBL_STR(int, int);
+
+extern int
+qla4xxx_alloc_ioctl_mem(scsi_qla_host_t *);
+
+extern void
+qla4xxx_free_ioctl_mem(scsi_qla_host_t *);
+
+extern int
+qla4xxx_get_ioctl_scrap_mem(scsi_qla_host_t *, void **, uint32_t);
+
+extern void
+qla4xxx_free_ioctl_scrap_mem(scsi_qla_host_t *);
+
+/*
+ * from ql4_inioct.c
+ */
+extern ioctl_tbl_row_t IOCTL_SCMD_IGET_DATA_TBL[];
+extern ioctl_tbl_row_t IOCTL_SCMD_ISET_DATA_TBL[];
+
+extern int
+qla4intioctl_logout_iscsi(scsi_qla_host_t *, EXT_IOCTL_ISCSI *);
+
+extern int
+qla4intioctl_copy_fw_flash(scsi_qla_host_t *, EXT_IOCTL_ISCSI *);
+
+extern int
+qla4intioctl_iocb_passthru(scsi_qla_host_t *, EXT_IOCTL_ISCSI *);
+
+extern int
+qla4intioctl_ping(scsi_qla_host_t *, EXT_IOCTL_ISCSI *);
+
+extern int
+qla4intioctl_get_data(scsi_qla_host_t *, EXT_IOCTL_ISCSI *);
+
+extern int
+qla4intioctl_set_data(scsi_qla_host_t *, EXT_IOCTL_ISCSI *);
+
+extern int
+qla4intioctl_hba_reset(scsi_qla_host_t *, EXT_IOCTL_ISCSI *);
+
+/*
+ * from ql4_init.c
+ */
+extern uint8_t
+qla4xxx_logout_device(scsi_qla_host_t *, uint16_t, uint16_t);
+
+extern uint8_t
+qla4xxx_login_device(scsi_qla_host_t *, uint16_t, uint16_t);
+
+extern uint8_t
+qla4xxx_delete_device(scsi_qla_host_t *, uint16_t, uint16_t);
+
+#endif
diff --git a/drivers/scsi/qla4xxx/ql4_isns.c b/drivers/scsi/qla4xxx/ql4_isns.c
new file mode 100644
index 0000000..e055188
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_isns.c
@@ -0,0 +1,2739 @@
+/******************************************************************************
+ *     Copyright (C)  2003 -2005 QLogic Corporation
+ * QLogic ISP4xxx Device Driver
+ *
+ * This program includes a device driver for Linux 2.6.x that may be
+ * distributed with QLogic hardware specific firmware binary file.
+ * You may modify and redistribute the device driver code under the
+ * GNU General Public License as published by the Free Software Foundation
+ * (version 2 or a later version) and/or under the following terms,
+ * as applicable:
+ *
+ * 	1. Redistribution of source code must retain the above copyright
+ *         notice, this list of conditions and the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above copyright
+ *         notice, this list of conditions and the following disclaimer in
+ *         the documentation and/or other materials provided with the
+ *         distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ * 	
+ * You may redistribute the hardware specific firmware binary file under
+ * the following terms:
+ * 	1. Redistribution of source code (only if applicable), must
+ *         retain the above copyright notice, this list of conditions and
+ *         the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above
+ *         copyright notice, this list of conditions and the following
+ *         disclaimer in the documentation and/or other materials provided
+ *         with the distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ *
+ * REGARDLESS OF WHAT LICENSING MECHANISM IS USED OR APPLICABLE,
+ * THIS PROGRAM IS PROVIDED BY QLOGIC CORPORATION "AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * USER ACKNOWLEDGES AND AGREES THAT USE OF THIS PROGRAM WILL NOT CREATE
+ * OR GIVE GROUNDS FOR A LICENSE BY IMPLICATION, ESTOPPEL, OR OTHERWISE
+ * IN ANY INTELLECTUAL PROPERTY RIGHTS (PATENT, COPYRIGHT, TRADE SECRET,
+ * MASK WORK, OR OTHER PROPRIETARY RIGHT) EMBODIED IN ANY OTHER QLOGIC
+ * HARDWARE OR SOFTWARE EITHER SOLELY OR IN COMBINATION WITH THIS PROGRAM
+ *
+ ******************************************************************************
+ *             Please see release.txt for revision history.                   *
+ *                                                                            *
+ ******************************************************************************
+ * Function Table of Contents:
+ *	qla4xxx_strtolower
+ *	qla4xxx_isns_build_entity_id
+ *	qla4xxx_isns_reenable
+ *	qla4xxx_isns_enable_callback
+ *	qla4xxx_isns_restart_service
+ *	qla4xxx_isns_restart_service_completion
+ *	qla4xxx_isns_init_isns_reg_attr_list
+ *	qla4xxx_isns_init_isns_dereg_attr_list
+ *	qla4xxx_isns_init_isns_scn_reg_attr_list
+ *	qla4xxx_isns_init_isns_scn_dereg_attr_list
+ *	qla4xxx_isns_init_isns_dev_get_next_attr_list
+ *	qla4xxx_isns_init_isns_dev_attr_qry_attr_list
+ *	qla4xxx_isns_init_attributes
+ *	qla4xxx_isns_append_attribute
+ *	qla4xxx_isns_build_iocb_handle
+ *	qla4xxx_isns_get_server_request
+ *	qla4xxx_isns_build_scn_registration_packet
+ *	qla4xxx_isns_build_scn_deregistration_packet
+ *	qla4xxx_isns_build_registration_packet
+ *	qla4xxx_isns_build_deregistration_packet
+ *	qla4xxx_isns_build_request_packet
+ *	qla4xxx_isns_build_server_request_response_packet
+ *	qla4xxx_isns_build_dev_get_next_packet
+ *	qla4xxx_isns_build_dev_attr_qry_packet
+ *	qla4xxx_isns_parse_get_next_response
+ *	qla4xxx_isns_parse_query_response
+ *	qla4xxx_isns_process_response
+ *	qla4xxx_isns_reassemble_pdu
+ *	qla4xxx_isns_scn
+ *	qla4xxx_isns_esi
+ *	qla4xxx_isns_server_request_error
+ *	qla4xxx_isns_parse_and_dispatch_server_request
+ *	qla4xxx_isns_parse_and_dispatch_server_response
+ *	qla4xxx_isns_dev_attr_reg
+ *	qla4xxx_isns_dev_attr_reg_rsp
+ *	qla4xxx_isns_scn_reg
+ *	qla4xxx_isns_scn_reg_rsp
+ *	qla4xxx_isns_dev_attr_qry
+ *	qla4xxx_isns_dev_attr_qry_rsp
+ *	qla4xxx_isns_dev_get_next
+ *	qla4xxx_isns_dev_get_next_rsp
+ *	qla4xxx_isns_dev_dereg
+ *	qla4xxx_isns_dev_dereg_rsp
+ *	qla4xxx_isns_scn_dereg
+ *	qla4xxx_isns_scn_dereg_rsp
+ ****************************************************************************/
+
+#include "ql4_def.h"
+
+void     qla4xxx_isns_enable_callback(scsi_qla_host_t *, uint32_t, uint32_t, uint32_t, uint32_t);
+uint8_t  qla4xxx_isns_restart_service(scsi_qla_host_t *);
+uint32_t qla4xxx_isns_build_iocb_handle(scsi_qla_host_t *, uint32_t, PDU_ENTRY *);
+uint8_t  qla4xxx_isns_get_server_request(scsi_qla_host_t *, uint32_t, uint16_t);
+uint8_t  qla4xxx_isns_reassemble_pdu(scsi_qla_host_t *, uint8_t *, uint32_t *);
+uint8_t  qla4xxx_isns_parse_and_dispatch_server_request(scsi_qla_host_t *, uint8_t *, uint32_t, uint16_t);
+uint8_t  qla4xxx_isns_parse_and_dispatch_server_response(scsi_qla_host_t *, uint8_t *, uint32_t);
+uint8_t  qla4xxx_isns_build_scn_registration_packet(scsi_qla_host_t *ha,
+							   uint8_t *buffer,
+							   uint32_t buffer_size,
+							   uint32_t *packet_size);
+uint8_t  qla4xxx_isns_build_scn_deregistration_packet(scsi_qla_host_t *ha,
+							     uint8_t *buffer,
+							     uint32_t buffer_size,
+							     uint32_t *packet_size);
+uint8_t  qla4xxx_isns_build_registration_packet(scsi_qla_host_t *ha,
+						       uint8_t *buff,
+						       uint32_t buff_size,
+						       uint8_t *isns_entity_id,
+						       uint8_t *ip_addr,
+						       uint32_t port_number,
+						       uint32_t scn_port,
+						       uint32_t esi_port,
+						       uint8_t *local_alias,
+						       uint32_t *packet_size);
+uint8_t  qla4xxx_isns_build_deregistration_packet(scsi_qla_host_t *ha,
+							 uint8_t *buff,
+							 uint32_t buff_size,
+							 uint8_t *isns_entity_id,
+							 uint8_t *ip_addr,
+							 uint32_t port_number,
+							 uint32_t *packet_size);
+uint8_t  qla4xxx_isns_build_request_packet(scsi_qla_host_t *ha,
+						  uint8_t *buff,
+						  uint32_t buff_size,
+						  uint16_t function_id,
+						  uint16_t tx_id,
+						  uint8_t  use_replace_flag,
+						  ATTRIBUTE_LIST *attr_list,
+						  uint32_t *packet_size);
+uint8_t  qla4xxx_isns_append_attribute(scsi_qla_host_t *ha,
+					      uint8_t **buffer,
+					      uint8_t *buffer_end,
+					      ATTRIBUTE_LIST *attr_list);
+uint8_t  qla4xxx_isns_dev_attr_reg(scsi_qla_host_t *);
+
+uint8_t  qla4xxx_isns_dev_attr_reg_rsp(scsi_qla_host_t *ha,
+					      uint8_t *buffer,
+					      uint32_t buffer_size);
+uint8_t  qla4xxx_isns_dev_attr_qry_rsp(scsi_qla_host_t *ha,
+					      uint8_t *buffer,
+					      uint32_t buffer_size);
+uint8_t  qla4xxx_isns_dev_get_next_rsp(scsi_qla_host_t *ha,
+					      uint8_t *buffer,
+					      uint32_t buffer_size);
+uint8_t  qla4xxx_isns_dev_dereg_rsp(scsi_qla_host_t *ha,
+					   uint8_t *buffer,
+					   uint32_t buffer_size);
+uint8_t  qla4xxx_isns_scn_reg_rsp(scsi_qla_host_t *ha,
+					 uint8_t *buffer,
+					 uint32_t buffer_size);
+uint8_t  qla4xxx_isns_scn_dereg_rsp(scsi_qla_host_t *ha,
+					   uint8_t *buffer,
+					   uint32_t buffer_size);
+
+uint8_t  qla4xxx_isns_scn_dereg(scsi_qla_host_t *);
+uint8_t  qla4xxx_isns_scn_reg(scsi_qla_host_t *ha);
+uint8_t  qla4xxx_isns_dev_get_next (scsi_qla_host_t *ha,
+					   uint8_t *last_iscsi_name);
+
+
+const char *isns_error_code_msg[] = ISNS_ERROR_CODE_TBL();
+
+static void
+qla4xxx_strtolower(uint8_t *str)
+{
+	uint8_t *tmp;
+	for (tmp = str; *tmp != '\0'; tmp++) {
+		if (*tmp >= 'A' && *tmp <= 'Z')
+			*tmp += 'a' - 'A';
+	}
+}
+
+void
+qla4xxx_isns_build_entity_id(scsi_qla_host_t *ha)
+{
+	sprintf(ha->isns_entity_id, "%s.%d", ha->serial_number, ha->function_number);
+	qla4xxx_strtolower(ha->isns_entity_id);
+}
+
+uint8_t
+qla4xxx_isns_reenable(scsi_qla_host_t *ha,
+		      uint32_t isns_ip_addr,
+		      uint16_t isns_server_port_num)
+{
+	set_bit(ISNS_FLAG_REREGISTER, &ha->isns_flags);
+	ISNS_CLEAR_FLAGS(ha);
+
+	if (qla4xxx_isns_enable(ha, isns_ip_addr, isns_server_port_num)
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: Failed!\n",
+				      ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+
+	return(QLA_SUCCESS);
+}
+
+/* interrupt context, hardware lock set */
+void
+qla4xxx_isns_enable_callback(scsi_qla_host_t *ha,
+			     uint32_t svr,
+			     uint32_t scn,
+			     uint32_t esi,
+			     uint32_t nsh)
+{
+	ha->isns_connection_id   = (uint16_t) svr & 0x0000FFFF;
+	ha->isns_scn_conn_id     = (uint16_t) scn & 0x0000FFFF;
+	ha->isns_esi_conn_id     = (uint16_t) esi & 0x0000FFFF;
+	ha->isns_nsh_conn_id     = (uint16_t) nsh & 0x0000FFFF;
+
+	ha->isns_remote_port_num = (uint16_t) (svr >> 16);
+	ha->isns_scn_port_num    = (uint16_t) (scn >> 16);
+	ha->isns_esi_port_num    = (uint16_t) (esi >> 16);
+	ha->isns_nsh_port_num    = (uint16_t) (nsh >> 16);
+
+	QL4PRINT(QLP20,
+		 printk("scsi%d: %s: iSNS Server TCP Connect succeeded %d\n",
+			ha->host_no, __func__, svr));
+	QL4PRINT(QLP20,
+		 printk("scsi%d: %s: Remote iSNS Server %d ConnID %x\n",
+			ha->host_no, __func__,
+			ha->isns_remote_port_num,
+			ha->isns_connection_id));
+	QL4PRINT(QLP20,
+		 printk("scsi%d: %s: Local  SCN  Listen %d ConnID %x\n",
+			ha->host_no, __func__,
+			ha->isns_scn_port_num,
+			ha->isns_scn_conn_id));
+	QL4PRINT(QLP20,
+		 printk("scsi%d: %s: Local  ESI  Listen %d ConnID %x\n",
+			ha->host_no, __func__,
+			ha->isns_esi_port_num,
+			ha->isns_esi_conn_id));
+	QL4PRINT(QLP20,
+		 printk("scsi%d: %s: Local  HSN  Listen %d ConnID %x\n",
+			ha->host_no, __func__,
+			ha->isns_nsh_port_num,
+			ha->isns_nsh_conn_id));
+
+	if (ha->isns_connection_id == (uint16_t)-1) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: iSNS server refused connection\n",
+				ha->host_no, __func__));
+
+		qla4xxx_isns_restart_service(ha);
+		return;
+	}
+
+	set_bit(ISNS_FLAG_ISNS_SRV_ENABLED, &ha->isns_flags);
+
+	if (test_bit(ISNS_FLAG_REREGISTER, &ha->isns_flags)) {
+		if (qla4xxx_isns_scn_dereg(ha) != QLA_SUCCESS) {
+			QL4PRINT(QLP2,
+				 printk("scsi%d: %s: qla4xxx_isns_scn_dereg failed!\n",
+					ha->host_no, __func__));
+			return;
+		}
+	}
+	else {
+		if (qla4xxx_isns_dev_attr_reg(ha) != QLA_SUCCESS) {
+			QL4PRINT(QLP2,
+				 printk("scsi%d: %s: qla4xxx_isns_dev_attr_reg failed!\n",
+					ha->host_no, __func__));
+			return;
+		}
+	}
+}
+
+
+uint8_t
+qla4xxx_isns_restart_service(scsi_qla_host_t *ha)
+{
+	qla4xxx_isns_disable(ha);
+	set_bit(ISNS_FLAG_RESTART_SERVICE, &ha->isns_flags);
+	ISNS_CLEAR_FLAGS(ha);
+
+	/* Set timer for restart to complete */
+	atomic_set(&ha->isns_restart_timer, ISNS_RESTART_TOV);
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_restart_service_completion(scsi_qla_host_t *ha,
+					uint32_t isns_ip_addr,
+					uint16_t isns_server_port_num)
+{
+	QL4PRINT(QLP20, printk("scsi%d: %s: isns_ip_addr %08x\n",
+			       ha->host_no, __func__, isns_ip_addr));
+
+	if (qla4xxx_isns_enable(ha, isns_ip_addr, isns_server_port_num)
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: failed!\n",
+				      ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+	else {
+		set_bit(ISNS_FLAG_REREGISTER, &ha->isns_flags);
+		ISNS_CLEAR_FLAGS(ha);
+		return(QLA_SUCCESS);
+	}
+}
+
+
+static void
+qla4xxx_isns_init_isns_reg_attr_list(scsi_qla_host_t *ha)
+{
+	ATTRIBUTE_LIST isns_reg_attr_list[] = {
+		/* Source attribute */
+		{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING,  (unsigned long) ha->name_string},
+		{ ISNS_ATTR_TAG_ENTITY_IDENTIFIER, ISNS_ATTR_TYPE_STRING,  -1},
+		/* Entity ID. */
+		{ ISNS_ATTR_TAG_DELIMITER,         ISNS_ATTR_TYPE_EMPTY,   0},
+		/* Operating attributes to register */
+		{ ISNS_ATTR_TAG_ENTITY_IDENTIFIER, ISNS_ATTR_TYPE_STRING,  -1},
+		{ ISNS_ATTR_TAG_ENTITY_PROTOCOL,   ISNS_ATTR_TYPE_ULONG,   cpu_to_be32(ENTITY_PROTOCOL_ISCSI)},
+		{ ISNS_ATTR_TAG_PORTAL_IP_ADDRESS, ISNS_ATTR_TYPE_ADDRESS, -1},
+		{ ISNS_ATTR_TAG_PORTAL_PORT,       ISNS_ATTR_TYPE_ULONG,   -1},
+		{ ISNS_ATTR_TAG_SCN_PORT,          ISNS_ATTR_TYPE_ULONG,   -1},
+		{ ISNS_ATTR_TAG_ESI_PORT,          ISNS_ATTR_TYPE_ULONG,   -1},
+		{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING,  (unsigned long) ha->name_string},
+		{ ISNS_ATTR_TAG_ISCSI_NODE_TYPE,   ISNS_ATTR_TYPE_ULONG,   cpu_to_be32(ISCSI_NODE_TYPE_INITIATOR)},
+		{ ISNS_ATTR_TAG_ISCSI_ALIAS,       ISNS_ATTR_TYPE_STRING,  -1},		// Friendly machine name?
+
+		{ 0, 0, 0}		// Terminating NULL entry
+	};
+
+	memcpy(ha->isns_reg_attr_list,          isns_reg_attr_list,          sizeof(isns_reg_attr_list));
+}
+
+static void
+qla4xxx_isns_init_isns_dereg_attr_list(scsi_qla_host_t *ha)
+{
+	ATTRIBUTE_LIST isns_dereg_attr_list[] = {
+		// Source attribute
+		{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING,  (unsigned long) ha->name_string},
+		// No key attribute for DevDereg
+		{ ISNS_ATTR_TAG_DELIMITER,         ISNS_ATTR_TYPE_EMPTY,    0},
+		// Operating attributes
+		{ ISNS_ATTR_TAG_ENTITY_IDENTIFIER, ISNS_ATTR_TYPE_STRING,  -1},		// FQDN
+#if 0
+		{ ISNS_ATTR_TAG_PORTAL_IP_ADDRESS, ISNS_ATTR_TYPE_ADDRESS, -1},
+		{ ISNS_ATTR_TAG_PORTAL_PORT,       ISNS_ATTR_TYPE_ULONG,   -1},
+		{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING,  (unsigned long) ha->name_string},
+#endif
+
+		{ 0, 0, 0}		// Terminating NULL entry
+	};
+
+	memcpy(ha->isns_dereg_attr_list,        isns_dereg_attr_list,        sizeof(isns_dereg_attr_list));
+}
+
+static void
+qla4xxx_isns_init_isns_scn_reg_attr_list(scsi_qla_host_t *ha)
+{
+	ATTRIBUTE_LIST isns_scn_reg_attr_list[] = {
+		// Source attribute
+		{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING,  (unsigned long) ha->name_string},
+		// Key attributes
+		{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING,  (unsigned long) ha->name_string},
+		// Required delimiter to indicate division between key and operating attrs.
+		{ ISNS_ATTR_TAG_DELIMITER,         ISNS_ATTR_TYPE_EMPTY,   0},
+		// Operating attributes
+		{ ISNS_ATTR_TAG_ISCSI_SCN_BITMAP,  ISNS_ATTR_TYPE_ULONG,   cpu_to_be32(ISCSI_SCN_OBJECT_UPDATED |
+										  ISCSI_SCN_OBJECT_ADDED |
+										  ISCSI_SCN_OBJECT_REMOVED |
+										  ISCSI_SCN_TARGET_AND_SELF_INFO_ONLY)},
+
+		{ 0, 0, 0}		// Terminating NULL entry
+	};
+
+	memcpy(ha->isns_scn_reg_attr_list,      isns_scn_reg_attr_list,      sizeof(isns_scn_reg_attr_list));
+}
+
+static void
+qla4xxx_isns_init_isns_scn_dereg_attr_list(scsi_qla_host_t *ha)
+{
+	ATTRIBUTE_LIST isns_scn_dereg_attr_list[] = {
+		// Source attribute
+		{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING, (unsigned long) ha->name_string},
+		// Key attributes
+		{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING, (unsigned long) ha->name_string},
+
+		{ 0, 0, 0}		// Terminating NULL entry
+	};
+
+	memcpy(ha->isns_scn_dereg_attr_list,    isns_scn_dereg_attr_list,    sizeof(isns_scn_dereg_attr_list));
+}
+
+static void
+qla4xxx_isns_init_isns_dev_get_next_attr_list(scsi_qla_host_t *ha)
+{
+	ATTRIBUTE_LIST isns_dev_get_next_attr_list[] = {
+		// Source attribute
+		{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING, (unsigned long) ha->name_string},
+		// Key attributes
+		{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING, -1},
+		// Required delimiter to indicate division between key and operating attrs.
+		{ ISNS_ATTR_TAG_DELIMITER,         ISNS_ATTR_TYPE_EMPTY,  0},
+		// Operating attributes (attributes of object matching key attribute to return)
+		{ ISNS_ATTR_TAG_ISCSI_NODE_TYPE,   ISNS_ATTR_TYPE_ULONG,  cpu_to_be32(ISCSI_NODE_TYPE_TARGET)},
+
+		{ 0, 0, 0}		// Terminating NULL entry
+	};
+
+	memcpy(ha->isns_dev_get_next_attr_list, isns_dev_get_next_attr_list, sizeof(isns_dev_get_next_attr_list));
+}
+
+static void
+qla4xxx_isns_init_isns_dev_attr_qry_attr_list(scsi_qla_host_t *ha)
+{
+	ATTRIBUTE_LIST isns_dev_attr_qry_attr_list[] = {
+		// Source attribute
+		{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING, (unsigned long) ha->name_string},
+		// Key attributes
+		{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING, -1},
+		// Required delimiter to indicate division between key and operating attrs.
+		{ ISNS_ATTR_TAG_DELIMITER,         ISNS_ATTR_TYPE_EMPTY,  0},
+		// Operating attributes (attributes of objects matching key attributes to return)
+		{ ISNS_ATTR_TAG_ENTITY_PROTOCOL,   ISNS_ATTR_TYPE_EMPTY,  0},
+		{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_EMPTY,  0},
+		{ ISNS_ATTR_TAG_ISCSI_NODE_TYPE,   ISNS_ATTR_TYPE_EMPTY,  0},
+		{ ISNS_ATTR_TAG_ISCSI_ALIAS,       ISNS_ATTR_TYPE_EMPTY,  0},	// Friendly name
+		{ ISNS_ATTR_TAG_PORTAL_SYMBOLIC_NAME, ISNS_ATTR_TYPE_EMPTY, 0},
+		{ ISNS_ATTR_TAG_PORTAL_IP_ADDRESS, ISNS_ATTR_TYPE_EMPTY,  0},
+		{ ISNS_ATTR_TAG_PORTAL_PORT,       ISNS_ATTR_TYPE_EMPTY,  0},
+		{ ISNS_ATTR_TAG_PORTAL_SECURITY_BITMAP, ISNS_ATTR_TYPE_EMPTY, 0},
+		{ ISNS_ATTR_TAG_DD_ID,             ISNS_ATTR_TYPE_EMPTY,  0},
+
+		{ 0, 0, 0}		// Terminating NULL entry
+	};
+
+	memcpy(ha->isns_dev_attr_qry_attr_list, isns_dev_attr_qry_attr_list, sizeof(isns_dev_attr_qry_attr_list));
+}
+
+uint8_t
+qla4xxx_isns_init_attributes (scsi_qla_host_t *ha)
+{
+	/* Separate these calls to minimize stack usage */
+
+	qla4xxx_isns_init_isns_reg_attr_list(ha);
+	qla4xxx_isns_init_isns_dereg_attr_list(ha);
+	qla4xxx_isns_init_isns_scn_reg_attr_list(ha);
+	qla4xxx_isns_init_isns_scn_dereg_attr_list(ha);
+	qla4xxx_isns_init_isns_dev_get_next_attr_list(ha);
+	qla4xxx_isns_init_isns_dev_attr_qry_attr_list(ha);
+
+#if 0
+	{
+		ATTRIBUTE_LIST asRegUpdateAddObjectsAttrList[] = {
+			// Source attribute
+			{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING, (unsigned long) ha->name_string},
+			// We are adding objects to an Entity so specify the Entity as the Key
+			{ ISNS_ATTR_TAG_ENTITY_IDENTIFIER, ISNS_ATTR_TYPE_STRING, -1},	// FQDN
+			{ ISNS_ATTR_TAG_DELIMITER,         ISNS_ATTR_TYPE_EMPTY,  0},
+			// Operating attributes to register
+			{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING, (unsigned long) ha->name_string},
+			{ ISNS_ATTR_TAG_ISCSI_NODE_TYPE,   ISNS_ATTR_TYPE_ULONG,  cpu_to_be32(ISCSI_NODE_TYPE_INITIATOR)},
+			{ ISNS_ATTR_TAG_ISCSI_ALIAS,       ISNS_ATTR_TYPE_STRING, -1},	    // Friendly machine name?
+
+			{ 0, 0, 0}	// Terminating NULL entry
+		};
+
+		ATTRIBUTE_LIST asRegUpdateNodeAttrList[] = {
+			// Source attribute
+			{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING, (unsigned long) ha->name_string},
+			// We updating attributes of a Node so specify the Node as the Key
+			{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING, (unsigned long) ha->name_string},
+			{ ISNS_ATTR_TAG_DELIMITER,         ISNS_ATTR_TYPE_EMPTY,  0},
+			// Operating attributes to update
+			{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING, (unsigned long) ha->name_string},
+			{ ISNS_ATTR_TAG_ISCSI_ALIAS,       ISNS_ATTR_TYPE_STRING, -1},	    // Friendly machine name?
+
+			{ 0, 0, 0}	// Terminating NULL entry
+		};
+
+		ATTRIBUTE_LIST asRegReplaceNodeAttrList[] = {
+			// Source attribute
+			{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING, (unsigned long) ha->name_string},
+			// We updating attributes of a Node so specify the Node as the Key
+			{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING, (unsigned long) ha->name_string},
+			{ ISNS_ATTR_TAG_DELIMITER,         ISNS_ATTR_TYPE_EMPTY,  0},
+			// Operating attributes to update
+			{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING, (unsigned long) ha->name_string},
+			{ ISNS_ATTR_TAG_ISCSI_NODE_TYPE,   ISNS_ATTR_TYPE_ULONG,  cpu_to_be32(ISCSI_NODE_TYPE_INITIATOR)},
+			{ ISNS_ATTR_TAG_ISCSI_ALIAS,       ISNS_ATTR_TYPE_STRING, -1},	    // Friendly machine name?
+
+			{ 0, 0, 0}	// Terminating NULL entry
+		};
+
+		ATTRIBUTE_LIST asRegUpdateEntityAttrList[] = {
+			// Source attribute
+			{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING,  (unsigned long) ha->name_string},
+			// We updating attributes of an Entity so specify the Entity as the Key
+			{ ISNS_ATTR_TAG_ENTITY_IDENTIFIER, ISNS_ATTR_TYPE_STRING,  -1},	 // FQDN
+			{ ISNS_ATTR_TAG_DELIMITER,         ISNS_ATTR_TYPE_EMPTY,   0},
+			// Operating attributes to update
+			{ ISNS_ATTR_TAG_ENTITY_IDENTIFIER, ISNS_ATTR_TYPE_STRING,  -1},	 // FQDN
+			{ ISNS_ATTR_TAG_MGMT_IP_ADDRESS,   ISNS_ATTR_TYPE_ADDRESS, -1},
+
+			{ 0, 0, 0}	// Terminating NULL entry
+		};
+
+		memcpy(ha->asRegUpdateAddObjectsAttrList, asRegUpdateAddObjectsAttrList, sizeof(asRegUpdateAddObjectsAttrList));
+		memcpy(ha->asRegUpdateNodeAttrList,       asRegUpdateNodeAttrList,       sizeof(asRegUpdateNodeAttrList));
+		memcpy(ha->asRegReplaceNodeAttrList,      asRegReplaceNodeAttrList,      sizeof(asRegReplaceNodeAttrList));
+		memcpy(ha->asRegUpdateEntityAttrList,     asRegUpdateEntityAttrList,     sizeof(asRegUpdateEntityAttrList));
+	}
+#endif
+
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_append_attribute(scsi_qla_host_t *ha,
+			      uint8_t **buffer,
+			      uint8_t *buffer_end,
+			      ATTRIBUTE_LIST *attribute)
+{
+
+	ISNS_ATTRIBUTE *isns_attr;
+	uint32_t data_len;
+	uint8_t *local;
+
+	isns_attr =  (ISNS_ATTRIBUTE *) *buffer;
+
+	switch (attribute->type) {
+	case ISNS_ATTR_TYPE_EMPTY:
+		data_len = 0;
+		if ((&isns_attr->value[0] + data_len) > buffer_end) {
+			return(QLA_ERROR);
+		}
+		isns_attr->tag = cpu_to_be32(attribute->isns_tag);
+		isns_attr->length = cpu_to_be32(data_len);
+		break;
+
+	case ISNS_ATTR_TYPE_STRING:
+		/*
+		 * Length must include NULL terminator.
+		 * Note also that all iSNS strings must be UTF-8 encoded.
+		 * You should encode your strings for UTF-8 before registering
+		 * them with the iSNS server.
+		 */
+		data_len = strlen ((uint8_t *) attribute->data) + sizeof(uint8_t);
+		if (data_len % 4) {
+			data_len += (4 - (data_len % 4)); // Pad to 4 byte boundary.
+		}
+
+		if ((&isns_attr->value[0] + data_len) > buffer_end) {
+			return(QLA_ERROR);
+		}
+		isns_attr->tag = cpu_to_be32(attribute->isns_tag);
+		isns_attr->length = cpu_to_be32(data_len);
+		memset(isns_attr->value, 0, data_len);
+		strcpy (&isns_attr->value[0], (uint8_t *) attribute->data);
+		break;
+
+	case ISNS_ATTR_TYPE_ULONG:
+		data_len = sizeof(uint32_t);
+		if ((isns_attr->value + data_len) > buffer_end) {
+			return(QLA_ERROR);
+		}
+		isns_attr->tag = cpu_to_be32(attribute->isns_tag);
+		isns_attr->length = cpu_to_be32(data_len);
+		*(uint32_t *) isns_attr->value = (uint32_t) attribute->data;
+		break;
+
+	case ISNS_ATTR_TYPE_ADDRESS:
+		local = (uint8_t *) attribute->data;
+		data_len = 16;	     // Size of an IPv6 address
+		if ((isns_attr->value + data_len) > buffer_end) {
+			return(QLA_ERROR);
+		}
+		isns_attr->tag = cpu_to_be32(attribute->isns_tag);
+		isns_attr->length = cpu_to_be32(data_len);
+		// Prepend IP Address with 0xFFFF to indicate this is an IPv4
+		// only address. IPv6 addresses not supported by driver.
+		memset(isns_attr->value, 0, 16);
+		isns_attr->value[10] = 0xFF;
+		isns_attr->value[11] = 0xFF;
+		isns_attr->value[12] = local[0];
+		isns_attr->value[13] = local[1];
+		isns_attr->value[14] = local[2];
+		isns_attr->value[15] = local[3];
+		break;
+
+	default:
+		return(QLA_ERROR);
+
+	}
+
+	*buffer = &isns_attr->value[0] + data_len;
+
+	return(QLA_SUCCESS);
+}
+
+
+uint32_t
+qla4xxx_isns_build_iocb_handle(scsi_qla_host_t *ha,
+			       uint32_t type,
+			       PDU_ENTRY *pdu_entry)
+{
+	uint32_t handle;
+
+	handle = (IOCB_ISNS_PT_PDU_TYPE(type) |
+		  (((uint8_t *)pdu_entry - (uint8_t *)ha->pdu_queue)
+		   / sizeof(PDU_ENTRY)));
+
+	QL4PRINT(QLP20, printk("scsi%d: %s: type %x PDU %p = handle %x\n",
+			       ha->host_no, __func__,
+			       type, pdu_entry, handle));
+	return(handle);
+}
+
+/*
+ * Remarks:
+ *      hardware_lock locked upon entry
+ */
+uint8_t
+qla4xxx_isns_get_server_request(scsi_qla_host_t *ha,
+				uint32_t pdu_buff_len,
+				uint16_t connection_id)
+{
+	PDU_ENTRY *pdu_entry;
+
+	pdu_entry = qla4xxx_get_pdu(ha, MAX(pdu_buff_len, PAGE_SIZE));
+	if (pdu_entry == NULL) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: get_pdu failed\n",
+				      ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+
+	pdu_entry->SendBuffLen = 0;
+	pdu_entry->RecvBuffLen = pdu_entry->BuffLen;
+
+	QL4PRINT(QLP19, printk("PDU (0x%p) 0x%x ->\n", pdu_entry->Buff, pdu_entry->SendBuffLen));
+	qla4xxx_dump_bytes(QLP19, pdu_entry->Buff, pdu_entry->SendBuffLen);
+
+	if (qla4xxx_send_passthru0_iocb(ha, ISNS_DEVICE_INDEX, connection_id,
+					pdu_entry->DmaBuff,
+					pdu_entry->SendBuffLen,
+					pdu_entry->RecvBuffLen,
+					PT_FLAG_ISNS_PDU | PT_FLAG_WAIT_4_RESPONSE,
+					qla4xxx_isns_build_iocb_handle(ha, /*ISNS_REQ_RSP_PDU*/ISNS_ASYNCH_REQ_PDU, pdu_entry))
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: send_passthru_iocb failed\n",
+				      ha->host_no, __func__));
+		qla4xxx_free_pdu(ha, pdu_entry);
+		return(QLA_ERROR);
+	}
+
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_build_scn_registration_packet(scsi_qla_host_t *ha,
+					   uint8_t *buffer,
+					   uint32_t buffer_size,
+					   uint32_t *packet_size)
+{
+	/*
+	 * Fill in all of the run time requested data in the attribute array
+	 * then call iSNSBuildRequestPacket to do the actual work.
+	 */
+
+	return(qla4xxx_isns_build_request_packet(ha, buffer, buffer_size,
+						 ISNS_FCID_SCNReg,
+						 ha->isns_transaction_id,
+						 0,
+						 ha->isns_scn_reg_attr_list,
+						 packet_size));
+}
+
+
+uint8_t
+qla4xxx_isns_build_scn_deregistration_packet(scsi_qla_host_t *ha,
+					     uint8_t *buffer,
+					     uint32_t buffer_size,
+					     uint32_t *packet_size)
+{
+	/*
+	 * Fill in all of the run time requested data in the attribute array
+	 * then call iSNSBuildRequestPacket to do the actual work.
+	 */
+
+	return(qla4xxx_isns_build_request_packet(ha, buffer, buffer_size,
+						 ISNS_FCID_SCNDereg,
+						 ha->isns_transaction_id,
+						 0,
+						 ha->isns_scn_dereg_attr_list,
+						 packet_size));
+}
+
+uint8_t
+qla4xxx_isns_build_registration_packet(scsi_qla_host_t *ha,
+				       uint8_t *buff,
+				       uint32_t buff_size,
+				       uint8_t *isns_entity_id,
+				       uint8_t *ip_addr,
+				       uint32_t port_number,
+				       uint32_t scn_port,
+				       uint32_t esi_port,
+				       uint8_t *local_alias,
+				       uint32_t *packet_size)
+{
+	/*
+	 * Fill in all of the run time requested data in the attribute array,
+	 * then call build_request_packet to do the actual work.
+	 */
+	ha->isns_reg_attr_list[1].data = (unsigned long) isns_entity_id;
+	ha->isns_reg_attr_list[3].data = (unsigned long) isns_entity_id;
+	ha->isns_reg_attr_list[5].data = (unsigned long) ip_addr;
+	ha->isns_reg_attr_list[6].data = cpu_to_be32(port_number);
+	ha->isns_reg_attr_list[7].data = cpu_to_be32(scn_port);
+	ha->isns_reg_attr_list[8].data = cpu_to_be32(esi_port);
+	if (local_alias && local_alias[0]) {
+		ha->isns_reg_attr_list[11].data = (unsigned long) local_alias;
+	}
+	else {
+		ha->isns_reg_attr_list[11].data = (unsigned long) "<No alias specified>";
+	}
+
+	return(qla4xxx_isns_build_request_packet(ha, buff, buff_size,
+						 ISNS_FCID_DevAttrReg,
+						 ha->isns_transaction_id,
+						 0,
+						 ha->isns_reg_attr_list,
+						 packet_size));
+}
+
+uint8_t
+qla4xxx_isns_build_deregistration_packet(scsi_qla_host_t *ha,
+					 uint8_t *buff,
+					 uint32_t buff_size,
+					 uint8_t *isns_entity_id,
+					 uint8_t *ip_addr,
+					 uint32_t port_number,
+					 uint32_t *packet_size)
+{
+	/*
+	 * Fill in all of the run time requested data in the attribute array,
+	 * then call build_request_packet to do the actual work.
+	 */
+	ha->isns_dereg_attr_list[2].data = (unsigned long) isns_entity_id;
+	#if 0
+	ha->isns_dereg_attr_list[3].data = (unsigned long) ip_addr;
+	ha->isns_dereg_attr_list[4].data = (unsigned long) cpu_to_be32(port_number);
+	#endif
+
+	return(qla4xxx_isns_build_request_packet(ha, buff, buff_size,
+						 ISNS_FCID_DevDereg,
+						 ha->isns_transaction_id,
+						 0,
+						 ha->isns_dereg_attr_list,
+						 packet_size));
+}
+
+uint8_t
+qla4xxx_isns_build_request_packet(scsi_qla_host_t *ha,
+				  uint8_t *buffer,
+				  uint32_t buffer_size,
+				  uint16_t function_id,
+				  uint16_t tx_id,
+				  uint8_t  use_replace_flag,
+				  ATTRIBUTE_LIST *attr_list,
+				  uint32_t *packet_size)
+{
+	ISNSP_MESSAGE_HEADER *isns_message;
+	uint8_t  *ptr;
+	uint8_t  *buffer_end;
+	uint8_t  *payload_start;
+	uint32_t i;
+	uint8_t  success;
+
+	/*
+	 * Ensure that the buffer size is at a minimum sufficient to hold the
+	 * message header plus at least one attribute.
+	 */
+	if (buffer_size < (sizeof(*isns_message) + sizeof(*attr_list))) {
+		QL4PRINT(QLP12, printk("scsi%d: %s: Insufficient buffer size "
+				       "%d, need %d\n",
+				       ha->host_no, __func__, buffer_size,
+				       (unsigned int) (sizeof(*isns_message) +
+						       sizeof(*attr_list))));
+
+		return(QLA_ERROR);
+	}
+
+	isns_message = (ISNSP_MESSAGE_HEADER *) buffer;
+	buffer_end = (uint8_t *) ((unsigned long) buffer + buffer_size);
+
+	/* Initialize message header contents */
+	isns_message->isnsp_version = cpu_to_be16(ISNSP_VERSION);
+	isns_message->function_id   = cpu_to_be16(function_id);
+	if (use_replace_flag) {
+		isns_message->flags = cpu_to_be16(ISNSP_CLIENT_SENDER |
+                                                  ISNSP_FIRST_PDU |
+						  ISNSP_LAST_PDU |
+						  ISNSP_REPLACE_FLAG);
+	}
+	else {
+		isns_message->flags = cpu_to_be16(ISNSP_CLIENT_SENDER |
+					    ISNSP_FIRST_PDU |
+					    ISNSP_LAST_PDU);
+	}
+
+	isns_message->transaction_id = cpu_to_be16(tx_id);
+	isns_message->sequence_id    = 0; // First and only packet in this message
+
+	ptr = payload_start = &isns_message->payload[0];
+
+	/*
+	 * Now that most of the message header has been initialized (we'll fill
+	 * in the size when we're finished), let's append the desired attributes
+	 * to the request packet.
+	 */
+	success = 1;
+	for (i = 0; attr_list[i].type && success; i++) {
+		success = (qla4xxx_isns_append_attribute (ha, &ptr, buffer_end,
+							  &attr_list[i])
+			   == QLA_SUCCESS);
+	}
+
+	if (!success) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: Ran out of buffer space\n",
+				      ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+
+	/*
+	 * We've successfully finished building the request packet.
+	 * Set the size field.
+	 */
+	isns_message->pdu_length = cpu_to_be16((unsigned long) ptr -
+                                               (unsigned long) payload_start);
+
+	*packet_size = (uint32_t) ((unsigned long) ptr -
+				   (unsigned long) buffer);
+
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_build_server_request_response_packet(scsi_qla_host_t *ha,
+						  uint8_t * buffer,
+						  uint32_t buffer_size,
+						  uint16_t function_id,	 //cpu
+						  uint32_t error_code,	 //cpu
+						  uint16_t transaction_id, //cpu
+						  uint32_t *packet_size)
+{
+	ISNSP_MESSAGE_HEADER * isns_message;
+	ISNSP_RESPONSE_HEADER * isns_response;
+	uint8_t *ptr;
+	uint8_t *buffer_end;
+	uint8_t *payload_start;
+
+	// Ensure that the buffer size is at a minimum sufficient to hold the
+	// message headers.
+
+	if (buffer_size < (sizeof(ISNSP_MESSAGE_HEADER) + sizeof(ISNSP_RESPONSE_HEADER))) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: Insufficient buffer size %x\n",
+				      ha->host_no, __func__, buffer_size));
+		return(QLA_ERROR);
+	}
+
+	isns_message = (ISNSP_MESSAGE_HEADER *) buffer;
+	isns_response = (ISNSP_RESPONSE_HEADER *) &isns_message->payload[0];
+	payload_start = ( uint8_t *) isns_response;
+	buffer_end = ( uint8_t *) (buffer + buffer_size);
+
+	// Initialize message header contents.
+
+	isns_message->isnsp_version = cpu_to_be16(ISNSP_VERSION);
+	isns_message->function_id = (function_id);
+	//isns_message->function_id = cpu_to_be16(function_id);
+	isns_message->flags = cpu_to_be16(ISNSP_CLIENT_SENDER |
+				    ISNSP_FIRST_PDU |
+				    ISNSP_LAST_PDU);
+	isns_message->transaction_id =(transaction_id);
+	//isns_message->transaction_id = cpu_to_be16(transaction_id);
+	isns_message->sequence_id = 0;	 // First and only packet in this message
+
+	isns_response->error_code = cpu_to_be32(error_code);
+
+	ptr = &isns_response->attributes[0];
+
+	// We've successfully finished building the request packet.
+	// Set the size field.
+
+	//QLASSERT (!((ptr - payload_start) % 4));
+
+	isns_message->pdu_length = cpu_to_be16((unsigned long) ptr -
+                                               (unsigned long) payload_start);
+
+	*packet_size = (unsigned long) ptr - (unsigned long) buffer;
+
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_build_dev_get_next_packet (scsi_qla_host_t *ha,
+					uint8_t * buffer,
+					uint32_t buffer_size,
+					uint8_t * last_iscsi_name,
+					uint32_t *packet_size)
+{
+	// Fill in all of the run time requested data in the attribute array
+	// then call qla4xxx_isns_build_request_packet to do the actual work.
+
+	if (last_iscsi_name && last_iscsi_name[0]) {
+		ha->isns_dev_get_next_attr_list[1].type = ISNS_ATTR_TYPE_STRING;
+		ha->isns_dev_get_next_attr_list[1].data = (unsigned long) last_iscsi_name;
+	}
+	else {
+		ha->isns_dev_get_next_attr_list[1].type = ISNS_ATTR_TYPE_EMPTY;
+		ha->isns_dev_get_next_attr_list[1].data = 0;
+	}
+
+	return(qla4xxx_isns_build_request_packet(ha, buffer, buffer_size,
+						 ISNS_FCID_DevGetNext,
+						 ha->isns_transaction_id,
+						 0,
+						 ha->isns_dev_get_next_attr_list,
+						 packet_size));
+}
+
+uint8_t
+qla4xxx_isns_build_dev_attr_qry_packet (scsi_qla_host_t *ha,
+					uint8_t *buffer,
+					uint32_t buffer_size,
+					uint8_t *object_iscsi_name,
+					uint32_t *packet_size)
+{
+	// Fill in all of the run time requested data in the attribute array
+	// then call qla4xxx_isns_build_request_packet to do the actual work.
+
+	ha->isns_dev_attr_qry_attr_list[1].data = (unsigned long) object_iscsi_name;
+
+	return(qla4xxx_isns_build_request_packet(ha, buffer, buffer_size,
+						 ISNS_FCID_DevAttrQry,
+						 ha->isns_transaction_id, 0,
+						 ha->isns_dev_attr_qry_attr_list,
+						 packet_size));
+}
+
+uint8_t
+qla4xxx_isns_parse_get_next_response(scsi_qla_host_t *ha,
+				     uint8_t *buffer,
+				     uint32_t buffer_size,
+				     uint32_t *isns_error, // cpu, w.r.t. PPC byte order
+				     uint8_t *last_iscsi_name,
+				     uint32_t last_iscsi_name_size,
+				     uint8_t *IsTarget)
+{
+	ISNSP_MESSAGE_HEADER *isns_message;
+	ISNSP_RESPONSE_HEADER *isns_response;
+	ISNS_ATTRIBUTE *isns_attr;
+	uint8_t *buffer_end;
+
+	*IsTarget = 0;
+
+	isns_message = (ISNSP_MESSAGE_HEADER *) buffer;
+	buffer_end = ( uint8_t *) (( uint8_t *) &isns_message->payload[0] +
+				   be16_to_cpu(isns_message->pdu_length));
+
+	// Validate pdu_length specified in the iSNS message header.
+
+	if (((unsigned long) buffer_end -
+	     (unsigned long) buffer) > buffer_size) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: Invalid length field in "
+				      "iSNS response from iSNS server\n",
+				      ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+
+	// It is safe to assume from this point on that the pdu_length value
+	// (and thus our idea about the end of the buffer) is valid.
+
+	// Ensure that we have the correct function_id.
+
+	if (be16_to_cpu(isns_message->function_id) != ISNS_FCID_DevGetNextRsp) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: Invalid Function ID (0x%04x) "
+				      "in iSNS response from iSNS server\n",
+				      ha->host_no, __func__,
+				      be16_to_cpu(isns_message->function_id)));
+		return(QLA_ERROR);
+	}
+
+	isns_response = (ISNSP_RESPONSE_HEADER *) &isns_message->payload[0];
+
+	*isns_error = be32_to_cpu(isns_response->error_code);
+	if (*isns_error) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: iSNS Error code: %d\n",
+				      ha->host_no, __func__, *isns_error));
+
+		if (*isns_error == ISNS_ERR_NO_SUCH_ENTRY) {
+			QL4PRINT(QLP2, printk("scsi%d: %s: No more targets.\n",
+					      ha->host_no, __func__));
+			set_bit(ISNS_FLAG_DEV_SCAN_DONE, &ha->isns_flags);
+		}
+		else {
+			QL4PRINT(QLP2, printk("scsi%d: %s: Get Next failed. Error code %x\n",
+					      ha->host_no, __func__, *isns_error));
+		}
+		return(QLA_ERROR);
+	}
+
+	isns_attr = (ISNS_ATTRIBUTE *) &isns_response->attributes[0];
+
+	// Save the returned key attribute for the next DevGetNext request.
+
+	if (VALIDATE_ATTR(isns_attr, buffer_end) &&
+	    be32_to_cpu(isns_attr->tag) == ISNS_ATTR_TAG_ISCSI_NAME) {
+		strncpy(last_iscsi_name, &isns_attr->value[0], last_iscsi_name_size);
+	}
+	else {
+		QL4PRINT(QLP2, printk("scsi%d: %s: Bad Key attribute in DevGetNextRsp\n",
+				      ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+
+	// Point to next attribute.
+
+	isns_attr = NEXT_ATTR(isns_attr);
+
+	if (VALIDATE_ATTR(isns_attr, buffer_end) &&
+	    be32_to_cpu(isns_attr->tag) == ISNS_ATTR_TAG_DELIMITER) {
+		;	// Do nothing.
+	}
+	else {
+		QL4PRINT(QLP2, printk("scsi%d: %s: No delimiter in DevGetNextRsp\n",
+				      ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+
+	*IsTarget = 1;
+
+	// Point to next attribute.
+
+	isns_attr = NEXT_ATTR(isns_attr);
+
+	if (VALIDATE_ATTR(isns_attr, buffer_end) &&
+	    be32_to_cpu(isns_attr->tag) == ISNS_ATTR_TAG_ISCSI_NODE_TYPE) {
+		if (be32_to_cpu(*(uint32_t *) &isns_attr->value[0]) & ISCSI_NODE_TYPE_TARGET) {
+			*IsTarget = 1;
+		}
+	}
+	#if 0
+	else {
+		QL4PRINT(QLP2, printk("scsi%d: %s: Bad operating attr in DevGetNextRsp (%d)\n",
+				      ha->host_no, __func__, be16_to_cpu(isns_attr->tag)));
+		return(QLA_ERROR);
+	}
+	#endif
+
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_parse_query_response (scsi_qla_host_t *ha,
+				   uint8_t *buffer,
+				   uint32_t buffer_size,
+				   uint32_t *isns_error,    // cpu
+				   ISNS_DISCOVERED_TARGET *isns_discovered_target,
+				   uint8_t *IsTarget,
+				   uint8_t *last_iscsi_name)
+{
+	ISNSP_MESSAGE_HEADER *isns_message;
+	ISNSP_RESPONSE_HEADER *isns_response;
+	ISNS_ATTRIBUTE *isns_attr;
+	uint8_t *buffer_end;
+	uint8_t *tmpptr;
+	uint16_t wTmp;
+	uint32_t ulTmp;
+	uint32_t i;
+
+	isns_message = (ISNSP_MESSAGE_HEADER *) buffer;
+	buffer_end = &isns_message->payload[0] +
+		be16_to_cpu(isns_message->pdu_length);
+
+	// Validate pdu_length specified in the iSNS message header.
+
+	if (((unsigned long) buffer_end -
+	     (unsigned long) buffer) > buffer_size) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: Invalid length field in "
+				      "iSNS response from iSNS server\n",
+				      ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+
+	// It is safe to assume from this point on that the pdu_length value
+	// (and thus our idea about the end of the buffer) is valid.
+
+	// Ensure that we have the correct function_id.
+
+	if (be16_to_cpu(isns_message->function_id) != ISNS_FCID_DevAttrQryRsp) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: Invalid Function ID %04x in iSNS response\n",
+				      ha->host_no, __func__,
+				      be16_to_cpu(isns_message->function_id)));
+		return(QLA_ERROR);
+	}
+
+	isns_response = (ISNSP_RESPONSE_HEADER *) &isns_message->payload[0];
+
+	QL4PRINT(QLP20, printk("-----------------------------\n"));
+	QL4PRINT(QLP20, printk("scsi%d: %s: DevAttrQry response from iSNS server:\n",
+			       ha->host_no, __func__));
+
+	*isns_error = be32_to_cpu(isns_response->error_code);
+	if (*isns_error) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: iSNS Query failed.  error_code %x.\n",
+				      ha->host_no, __func__, *isns_error));
+		return(QLA_ERROR);
+	}
+
+	QL4PRINT(QLP20, printk("scsi%d: %s: Attributes:\n", ha->host_no, __func__));
+
+	isns_attr = (ISNS_ATTRIBUTE *) &isns_response->attributes[0];
+
+	// Skip key and delimiter attributes.
+
+	while (VALIDATE_ATTR(isns_attr, buffer_end) &&
+	       be32_to_cpu(isns_attr->tag) != ISNS_ATTR_TAG_DELIMITER) {
+		// Point to next attribute.
+		if (be32_to_cpu(isns_attr->tag) == ISNS_ATTR_TAG_ISCSI_NAME) {
+			// Note that this string is in UTF-8 format.  In production code,
+			// it would be necessary to convert from UTF-8 before using the
+			// string.
+			QL4PRINT(QLP20, printk("scsi%d: %s: MsgTag iSCSI Name: \"%s\"\n",
+					       ha->host_no, __func__, &isns_attr->value[0]));
+			if (strlen (isns_attr->value) > 256)
+				return(QLA_ERROR);
+			strcpy (last_iscsi_name, (uint8_t *) &isns_attr->value[0]);
+		}
+		isns_attr = NEXT_ATTR(isns_attr);
+	}
+
+	if (!VALIDATE_ATTR(isns_attr, buffer_end) ||
+	    be32_to_cpu(isns_attr->tag) != ISNS_ATTR_TAG_DELIMITER) {
+		// There was no delimiter attribute in the response.
+		return(QLA_ERROR);
+	}
+
+	// Skip delimiter attribute.
+	isns_attr = NEXT_ATTR(isns_attr);
+
+	while (VALIDATE_ATTR(isns_attr, buffer_end)) {
+		// We only need to parse for the operating attributes that we
+		// requested in the DevAttrQuery.
+
+		switch (be32_to_cpu(isns_attr->tag)) {
+		case ISNS_ATTR_TAG_ENTITY_PROTOCOL:
+			if (be32_to_cpu(*(uint32_t *) isns_attr->value) != ENTITY_PROTOCOL_ISCSI) {
+				QL4PRINT(QLP2, printk("scsi%d: %s: Entity does not support iSCSI protocol\n", ha->host_no, __func__));
+			}
+			break;
+
+		case ISNS_ATTR_TAG_ISCSI_NODE_TYPE:
+			switch (be32_to_cpu(*(uint32_t *) isns_attr->value)) {
+			case ISCSI_NODE_TYPE_TARGET:
+				QL4PRINT(QLP20, printk("scsi%d: %s: iSCSI node type Target\n", ha->host_no, __func__));
+				*IsTarget = 1;
+				break;
+			case ISCSI_NODE_TYPE_INITIATOR:
+				QL4PRINT(QLP20, printk("scsi%d: %s: iSCSI node type Initiator\n", ha->host_no, __func__));
+				*IsTarget = 0;
+				break;
+			case ISCSI_NODE_TYPE_CONTROL:
+				QL4PRINT(QLP20, printk("scsi%d: %s: iSCSI node type Control\n", ha->host_no, __func__));
+				*IsTarget = 0;
+				break;
+			default:
+				QL4PRINT(QLP20, printk("scsi%d: %s: iSCSI node type unknown\n", ha->host_no, __func__));
+				*IsTarget = 0;
+				break;
+			}
+			break;
+
+		case ISNS_ATTR_TAG_MGMT_IP_ADDRESS:
+			// WARNING: This doesn't handle IPv6 addresses.
+			tmpptr = &isns_attr->value[0];
+			for (i = 0; i < 8; i++) {
+				if (tmpptr[i])
+					return(QLA_ERROR);
+			}
+
+			for (i = 8; i < 12; i++) {
+				if (tmpptr[i] != 0 && tmpptr[i] != 0xFF)
+					return(QLA_ERROR);
+			}
+
+			QL4PRINT(QLP20, printk("scsi%d: %s: Management IP address: %u.%u.%u.%u\n",
+					       ha->host_no, __func__, tmpptr[12],
+					       tmpptr[13], tmpptr[14], tmpptr[15]));
+			break;
+
+		case ISNS_ATTR_TAG_PORTAL_IP_ADDRESS:
+			// WARNING: This doesn't handle IPv6 addresses.
+			tmpptr = &isns_attr->value[0];
+			for (i = 0; i < 8; i++) {
+				if (tmpptr[i])
+					return(QLA_ERROR);
+			}
+
+			for (i = 8; i < 12; i++) {
+				if (tmpptr[i] != 0 && tmpptr[i] != 0xFF)
+					return(QLA_ERROR);
+			}
+
+			QL4PRINT(QLP20, printk("scsi%d: %s: Portal IP address: %u.%u.%u.%u\n",
+					       ha->host_no, __func__, tmpptr[12],
+					       tmpptr[13], tmpptr[14], tmpptr[15]));
+
+			if (isns_discovered_target->NumPortals >= ISNS_MAX_PORTALS)
+				break;
+			memcpy(isns_discovered_target->Portal[isns_discovered_target->NumPortals].IPAddr,
+			       &tmpptr[12], 4);
+			break;
+
+		case ISNS_ATTR_TAG_PORTAL_PORT:
+			wTmp = (uint16_t) (be32_to_cpu(*(uint32_t *) isns_attr->value));
+			QL4PRINT(QLP20, printk("scsi%d: %s: Portal port: %u\n",
+					       ha->host_no, __func__, be32_to_cpu(*(uint32_t *) isns_attr->value)));
+			if (isns_discovered_target->NumPortals >= ISNS_MAX_PORTALS)
+				break;
+			isns_discovered_target->Portal[isns_discovered_target->NumPortals].PortNumber = wTmp;
+			isns_discovered_target->NumPortals++;
+			break;
+
+		case ISNS_ATTR_TAG_PORTAL_SYMBOLIC_NAME:
+			// Note that this string is in UTF-8 format.  In production code,
+			// it would be necessary to convert from UTF-8 before using the
+			// string.
+			QL4PRINT(QLP20, printk("scsi%d: %s: Portal Symbolic Name: \"%s\"\n",
+					       ha->host_no, __func__, &isns_attr->value[0]));
+#if 0
+			if (isns_discovered_target->NumPortals >= ISNS_MAX_PORTALS)
+				break;
+			qlstrncpy(isns_discovered_target->Portal[isns_discovered_target->NumPortals].SymbolicName,
+				  (uint8_t *) isns_attr->value, 32);
+			isns_discovered_target->Portal[isns_discovered_target->NumPortals].SymbolicName[31] = 0;
+#endif
+			break;
+
+		case ISNS_ATTR_TAG_SCN_PORT:
+			QL4PRINT(QLP20, printk("scsi%d: %s: SCN port: %u\n",
+					       ha->host_no, __func__,
+					       be32_to_cpu(*(uint32_t *) isns_attr->value)));
+			break;
+
+		case ISNS_ATTR_TAG_ESI_PORT:
+			QL4PRINT(QLP20, printk("scsi%d: %s: ESI port: %u\n",
+					       ha->host_no, __func__,
+					       be32_to_cpu(*(uint32_t *) isns_attr->value)));
+			break;
+
+		case ISNS_ATTR_TAG_ESI_INTERVAL:
+			QL4PRINT(QLP20, printk("scsi%d: %s: ESI Interval: %u\n",
+					       ha->host_no, __func__,
+					       be32_to_cpu(*(uint32_t *) isns_attr->value)));
+			break;
+
+		case ISNS_ATTR_TAG_REGISTRATION_PERIOD:
+			QL4PRINT(QLP20, printk("scsi%d: %s: Entity Registration Period: %u\n",
+					       ha->host_no, __func__,
+					       be32_to_cpu(*(uint32_t *) isns_attr->value)));
+			break;
+
+		case ISNS_ATTR_TAG_PORTAL_SECURITY_BITMAP:
+			ulTmp = be32_to_cpu(*(uint32_t *) isns_attr->value);
+
+			QL4PRINT(QLP20, printk("scsi%d: %s: Portal Security Bitmap:\n", ha->host_no, __func__));
+			if (ulTmp & ISNS_SECURITY_BITMAP_VALID) {
+				QL4PRINT(QLP20, printk("scsi%d: %s:\tISNS_SECURITY_BITMAP_VALID\n", ha->host_no, __func__));
+			}
+			if (ulTmp & ISNS_SECURITY_IKE_IPSEC_ENABLED) {
+				QL4PRINT(QLP20, printk("scsi%d: %s:\tISNS_SECURITY_IKE_IPSEC_ENABLED\n", ha->host_no, __func__));
+			}
+			if (ulTmp & ISNS_SECURITY_MAIN_MODE_ENABLED) {
+				QL4PRINT(QLP20, printk("scsi%d: %s:\tISNS_SECURITY_MAIN_MODE_ENABLED\n", ha->host_no, __func__));
+			}
+			if (ulTmp & ISNS_SECURITY_AGGRESSIVE_MODE_ENABLED) {
+				QL4PRINT(QLP20, printk("scsi%d: %s:\tISNS_SECURITY_AGGRESSIVE_MODE_ENABLED\n", ha->host_no, __func__));
+			}
+			if (ulTmp & ISNS_SECURITY_PFS_ENABLED) {
+				QL4PRINT(QLP20, printk("scsi%d: %s:\tISNS_SECURITY_PFS_ENABLED\n", ha->host_no, __func__));
+			}
+			if (ulTmp & ISNS_SECURITY_TRANSPORT_MODE_PREFERRED) {
+				QL4PRINT(QLP20, printk("scsi%d: %s:\tISNS_SECURITY_TRANSPORT_MODE_PREFERRED\n", ha->host_no, __func__));
+			}
+			if (ulTmp & ISNS_SECURITY_TUNNEL_MODE_PREFERRED) {
+				QL4PRINT(QLP20, printk("scsi%d: %s:\tISNS_SECURITY_TUNNEL_MODE_PREFERRED\n", ha->host_no, __func__));
+			}
+			// isns_discovered_target->SecurityBitmap = ulTmp;
+			break;
+
+		case ISNS_ATTR_TAG_ENTITY_IDENTIFIER:
+			// Note that this string is in UTF-8 format.  In production code,
+			// it would be necessary to convert from UTF-8 before using the
+			// string.
+			QL4PRINT(QLP20, printk("scsi%d: %s: Entity Identifier: \"%s\"\n",
+					       ha->host_no, __func__, isns_attr->value));
+			break;
+
+		case ISNS_ATTR_TAG_ISCSI_NAME:
+			// Note that this string is in UTF-8 format.  In production code,
+			// it would be necessary to convert from UTF-8 before using the
+			// string.
+			QL4PRINT(QLP20, printk("scsi%d: %s: iSCSI Name: \"%s\"\n",
+					       ha->host_no, __func__, isns_attr->value));
+			if (strlen (isns_attr->value) > 256)
+				return(QLA_ERROR);
+			strcpy (isns_discovered_target->NameString, ( uint8_t *) isns_attr->value);
+			break;
+
+		case ISNS_ATTR_TAG_ISCSI_ALIAS:
+			// Note that this string is in UTF-8 format.  In production code,
+			// it would be necessary to convert from UTF-8 before using the
+			// string.
+			QL4PRINT(QLP20, printk("scsi%d: %s: Alias: \"%s\"\n",
+					       ha->host_no, __func__, isns_attr->value));
+			if (strlen (isns_attr->value) <= 32)
+				strcpy (isns_discovered_target->Alias, ( uint8_t *) isns_attr->value);
+			break;
+
+		case ISNS_ATTR_TAG_DD_ID:
+			ulTmp = be32_to_cpu(*(uint32_t *) isns_attr->value);
+			QL4PRINT(QLP20, printk("scsi%d: %s: DD ID: %u\n",
+					       ha->host_no, __func__,
+					       be32_to_cpu(*(uint32_t *) isns_attr->value)));
+			isns_discovered_target->DDID = ulTmp;
+			break;
+
+		default:
+			//QLASSERT (0);
+			break;
+		}
+
+		// Point to next attribute.
+
+		isns_attr = NEXT_ATTR(isns_attr);
+	}
+
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_process_response(scsi_qla_host_t *ha, PASSTHRU_STATUS_ENTRY *sts_entry)
+{
+	uint32_t handle = le32_to_cpu(sts_entry->handle);
+	uint32_t inResidual = le32_to_cpu(sts_entry->inResidual);
+	uint16_t connectionID = le16_to_cpu(sts_entry->connectionID);
+	PDU_ENTRY *pdu_entry = (PDU_ENTRY *) &ha->pdu_queue[IOCB_ISNS_PT_PDU_INDEX(handle)];
+	uint32_t pdu_type = IOCB_ISNS_PT_PDU_TYPE(handle);
+	uint8_t status = QLA_SUCCESS;
+
+	ENTER("qla4xxx_passthru_status_entry");
+
+	QL4PRINT(QLP20,
+		 printk("scsi%d: %s isns_flags 0x%lx to=0x%x "
+			"IOCS=0x%02x OutResidual/Len=0x%x/0x%x "
+			"InResidual/Len=0x%x/0x%x\n",
+			ha->host_no, __func__,
+			ha->isns_flags,
+			le16_to_cpu(sts_entry->timeout),
+			sts_entry->completionStatus,
+			le32_to_cpu(sts_entry->outResidual),
+			pdu_entry->SendBuffLen,
+			inResidual,
+			pdu_entry->RecvBuffLen));
+
+	if (pdu_entry->RecvBuffLen - inResidual) {
+		QL4PRINT(QLP19, printk("PDU (0x%p) <-\n", pdu_entry->Buff));
+		qla4xxx_dump_bytes(QLP19, pdu_entry->Buff, (pdu_entry->RecvBuffLen - inResidual));
+	}
+
+
+	if (sts_entry->completionStatus != PASSTHRU_STATUS_COMPLETE) {
+
+		qla4xxx_free_pdu(ha, pdu_entry);
+		set_bit(DPC_ISNS_RESTART, &ha->dpc_flags);
+		goto exit_pt_sts;
+	}
+
+	switch (pdu_type) {
+	case ISNS_ASYNCH_RSP_PDU:
+		qla4xxx_free_pdu(ha, pdu_entry);
+		break;
+
+	case ISNS_ASYNCH_REQ_PDU:
+		pdu_entry->RecvBuffLen -= inResidual;
+
+		QL4PRINT(QLP19, printk("scsi%d: %s ISNS_ASYNCH_REQ_PDU  PDU Buff=%p, PDU RecvLen=0x%X\n",
+				       ha->host_no, __func__, pdu_entry->Buff, pdu_entry->RecvBuffLen));
+
+		if (qla4xxx_isns_reassemble_pdu(ha, pdu_entry->Buff,
+						&pdu_entry->RecvBuffLen)
+		    != QLA_SUCCESS) {
+			QL4PRINT(QLP2,
+				 printk("scsi%d: %s ISNS_ASYNCH_REQ_PDU "
+					"reassemble_pdu failed!\n",
+					ha->host_no, __func__));
+			goto exit_pt_sts;
+		}
+
+		if (qla4xxx_isns_parse_and_dispatch_server_request(ha,
+								   pdu_entry->Buff,
+								   pdu_entry->RecvBuffLen,
+								   connectionID)
+		    != QLA_SUCCESS) {
+			QL4PRINT(QLP2,
+				 printk("scsi%d: %s ISNS_ASYNCH_REQ_PDU "
+					"parse_and_dispatch_server_request failed!\n",
+					ha->host_no, __func__));
+		}
+		qla4xxx_free_pdu(ha, pdu_entry);
+		break;
+
+	case ISNS_REQ_RSP_PDU:
+		pdu_entry->RecvBuffLen -= inResidual;
+
+		QL4PRINT(QLP19, printk("scsi%d: %s ISNS_REQ_RSP_PDU  PDU Buff=%p, PDU RecvLen=0x%X\n",
+				       ha->host_no, __func__, pdu_entry->Buff, pdu_entry->RecvBuffLen));
+
+
+		if (qla4xxx_isns_reassemble_pdu(ha, pdu_entry->Buff,
+						&pdu_entry->RecvBuffLen)
+		    != QLA_SUCCESS) {
+			QL4PRINT(QLP2,
+				 printk("scsi%d: %s ISNS_REQ_RSP_PDU "
+					"reassemble_pdu failed!\n",
+					ha->host_no, __func__));
+			goto exit_pt_sts;
+		}
+
+		if (qla4xxx_isns_parse_and_dispatch_server_response(ha,
+								    pdu_entry->Buff,
+								    pdu_entry->RecvBuffLen)
+		    != QLA_SUCCESS) {
+			QL4PRINT(QLP2,
+				 printk("scsi%d: %s ISNS_REQ_RSP_PDU "
+					"parse_and_dispatch_server_response failed!\n",
+					ha->host_no, __func__));
+		}
+		qla4xxx_free_pdu(ha, pdu_entry);
+		break;
+	default:
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s iSNS handle 0x%x invalid\n",
+				ha->host_no, __func__, handle));
+		status = QLA_ERROR;
+		break;
+	}
+
+	exit_pt_sts:
+	LEAVE("qla4xxx_passthru_status_entry");
+	return(status);
+}
+
+uint8_t
+qla4xxx_isns_reassemble_pdu(scsi_qla_host_t *ha, uint8_t *buffer, uint32_t *buffer_size)
+{
+	uint16_t copy_size = 0;
+	uint32_t new_pdu_length = 0;
+	uint32_t bytes_remaining;
+	uint32_t pdu_size;
+	uint8_t *dest_ptr = NULL;
+	uint8_t *src_ptr = NULL;
+	ISNSP_MESSAGE_HEADER *isns_message;
+	uint32_t i;
+
+	// We have read all the PDU's for this message.  Now reassemble them
+	// into a single PDU.
+	if (buffer == NULL || buffer_size == 0) {
+		return(QLA_ERROR);
+	}
+
+	if (*buffer_size == 0) {
+		QL4PRINT(QLP2,
+			 printk(KERN_WARNING "scsi%d: %s: Length 0.  "
+				"Nothing to reassemble\n",
+				ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+
+	new_pdu_length = 0;
+	bytes_remaining = *buffer_size;
+	isns_message = (ISNSP_MESSAGE_HEADER *) buffer;
+
+	if ((!be16_to_cpu(isns_message->flags) & ISNSP_FIRST_PDU)) {
+		QL4PRINT(QLP2,
+			 printk(KERN_WARNING "scsi%d: %s: ISNSP_FIRST_PDU "
+				"not set, discard PDU\n",
+				ha->host_no, __func__));
+		*buffer_size = 0;
+		return(QLA_ERROR);
+	}
+
+	// First, calculate the size of the payload for the collapsed PDU
+	do {
+		if (bytes_remaining < sizeof(ISNSP_MESSAGE_HEADER)) {
+			QL4PRINT(QLP2,
+				 printk(KERN_WARNING "scsi%d: %s: Length 0.  "
+					"bytes_remaining < "
+					"sizeof(ISNSP_MESSAGE_HEADER).  "
+					"BytesRemaining %x, discard PDU\n",
+					ha->host_no, __func__,
+					bytes_remaining));
+			*buffer_size = 0;
+			return(QLA_ERROR);
+		}
+		else if (be16_to_cpu(isns_message->isnsp_version) !=
+			 ISNSP_VERSION) {
+
+			QL4PRINT(QLP2,
+				 printk(KERN_WARNING "scsi%d: %s: Bad Version "
+					"number in iSNS Message Header "
+					"(%04x, expecting %04x), discard PDU\n",
+					ha->host_no, __func__,
+					be16_to_cpu(isns_message->isnsp_version),
+					ISNSP_VERSION));
+			*buffer_size = 0;
+			return(QLA_ERROR);
+		}
+		else if (bytes_remaining < sizeof(ISNSP_MESSAGE_HEADER) +
+			 be16_to_cpu(isns_message->pdu_length)) {
+
+			QL4PRINT(QLP2,
+				 printk(KERN_WARNING "scsi%d: %s: Short PDU "
+					"in sequence. BytesRemaining %x, "
+					"discard PDU\n",
+					ha->host_no, __func__,
+					bytes_remaining));
+			*buffer_size = 0;
+			return(QLA_ERROR);
+		}
+		else if ((bytes_remaining == sizeof(ISNSP_MESSAGE_HEADER) +
+                          be16_to_cpu(isns_message->pdu_length)) &&
+                         (!(be16_to_cpu(isns_message->flags) & ISNSP_LAST_PDU))) {
+
+			QL4PRINT(QLP2,
+				 printk(KERN_WARNING "scsi%d: %s: "
+					"Last PDU Flag not set at end "
+					"of sequence. discard PDU\n",
+					ha->host_no, __func__));
+			*buffer_size = 0;
+			return(QLA_ERROR);
+		}
+
+		new_pdu_length += be16_to_cpu(isns_message->pdu_length);
+		pdu_size = sizeof(ISNSP_MESSAGE_HEADER) +
+			be16_to_cpu(isns_message->pdu_length);
+
+		isns_message = (ISNSP_MESSAGE_HEADER *) ((uint8_t *)
+							 isns_message + pdu_size);
+
+		bytes_remaining = bytes_remaining > pdu_size ?
+			bytes_remaining - pdu_size : 0;
+	}
+	while (bytes_remaining);
+
+	dest_ptr = buffer;
+	bytes_remaining = *buffer_size;
+	isns_message = (ISNSP_MESSAGE_HEADER *) buffer;
+	i = 0;
+	QL4PRINT(QLP19, printk("scsi%d: %s: PDU%d=%p payloadLength=%04x\n",
+			       ha->host_no, __func__, i, dest_ptr,
+			       be16_to_cpu(isns_message->pdu_length)));
+
+	while (bytes_remaining) {
+		// If this is the first PDU perform no copy,
+		// otherwise copy just the payload.
+
+		pdu_size = sizeof(ISNSP_MESSAGE_HEADER) +
+			be16_to_cpu(isns_message->pdu_length);
+
+		bytes_remaining = bytes_remaining > pdu_size ?
+			bytes_remaining - pdu_size : 0;
+		
+		copy_size = be16_to_cpu(isns_message->pdu_length);
+
+		if (dest_ptr == buffer) {
+			src_ptr = (uint8_t *) isns_message;
+			copy_size += sizeof(ISNSP_MESSAGE_HEADER);
+		}
+		else {
+			src_ptr = (uint8_t *) isns_message->payload;
+			memcpy(dest_ptr, src_ptr, copy_size);
+		}
+		
+		QL4PRINT(QLP19,
+			 printk("scsi%d: %s: PDU%d %p <= %p (%04x)\n",
+				ha->host_no, __func__, i, dest_ptr,
+				src_ptr, copy_size));
+
+		dest_ptr += copy_size;
+		isns_message = (ISNSP_MESSAGE_HEADER *) ((uint8_t *)
+							 isns_message + pdu_size);
+		i++;
+
+	}
+
+	isns_message = (ISNSP_MESSAGE_HEADER *) buffer;
+
+	// Update pdu_length field in reassembled PDU to reflect actual
+	// combined PDU payload length.
+	isns_message->pdu_length = cpu_to_be16(new_pdu_length);
+
+	// Also set LAST_PDU flag in reassembled PDU
+	isns_message->flags |= cpu_to_be16(ISNSP_LAST_PDU);
+
+	// Return number of bytes in buffer to caller.
+	*buffer_size = new_pdu_length + sizeof(ISNSP_MESSAGE_HEADER);
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_scn (scsi_qla_host_t *ha,
+		  uint8_t * req_buffer,
+		  uint32_t req_buffer_size,
+		  uint16_t ConnectionId)
+{
+	ISNSP_MESSAGE_HEADER * isns_req_message;
+	ISNSP_MESSAGE_HEADER * isns_rsp_message;
+	ISNSP_RESPONSE_HEADER * isns_response;
+	PDU_ENTRY * pdu_entry;
+	ISNS_ATTRIBUTE * attr;
+	uint8_t * req_buffer_end;
+	uint8_t * rsp_buffer_end;
+	uint8_t * payload_start;
+	uint8_t * ptr;
+	uint32_t packet_size;
+	uint32_t copy_size;
+
+	isns_req_message = (ISNSP_MESSAGE_HEADER *) req_buffer;
+
+	if ((pdu_entry = qla4xxx_get_pdu (ha, PAGE_SIZE)) == NULL) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: qla4xxx_get_pdu failed\n",
+				      ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+
+	// First, setup the response packet.
+	if (qla4xxx_isns_build_server_request_response_packet(ha,
+							      pdu_entry->Buff,
+							      pdu_entry->BuffLen,
+							      (be16_to_cpu(isns_req_message->function_id) | 0x8000),
+							      ISNS_ERR_SUCCESS,
+							      be16_to_cpu(isns_req_message->transaction_id),
+							      &packet_size)
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: qla4xxx_isns_build_server_"
+				"request_response_packet failed\n",
+				ha->host_no, __func__));
+		qla4xxx_free_pdu (ha, pdu_entry);
+		return(QLA_ERROR);
+	}
+	isns_rsp_message = (ISNSP_MESSAGE_HEADER *) pdu_entry->Buff;
+	isns_response = (ISNSP_RESPONSE_HEADER *) &isns_rsp_message->payload[0];
+	payload_start = (uint8_t *) isns_response;
+	rsp_buffer_end = (uint8_t *) (pdu_entry->Buff + pdu_entry->BuffLen);
+
+	ptr = &isns_response->attributes[0];
+
+	req_buffer_end = (uint8_t *) ((uint8_t *) &isns_req_message->payload[0] +
+				      be16_to_cpu(isns_req_message->pdu_length));
+
+	// Point to the source attribute in the request.  We need to return only
+	// this attribute in the SCN Response.
+	attr = (ISNS_ATTRIBUTE *) &isns_req_message->payload[0];
+	if (!VALIDATE_ATTR(attr, req_buffer_end)) {
+		isns_response->error_code = cpu_to_be32(ISNS_ERR_MSG_FORMAT);
+		QL4PRINT(QLP2, printk("scsi%d: %s: Malformed packet\n",
+				      ha->host_no, __func__));
+	}
+
+	// Validate that this is an iSCSI Name attribute.
+	if (be32_to_cpu(attr->tag) != ISNS_ATTR_TAG_ISCSI_NAME) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: Did not find iSCSN Name attribute\n",
+				      ha->host_no, __func__));
+	}
+
+	// Copy source attribute to return buffer.
+	copy_size = sizeof(ISNS_ATTRIBUTE) + be32_to_cpu(attr->length);
+
+	if (ptr + copy_size < rsp_buffer_end) {
+		// Attribute will fit in the response buffer.  Go ahead
+		// and copy it.
+		memcpy(ptr, attr, copy_size);
+		ptr += copy_size;
+	}
+	else {
+		QL4PRINT(QLP2, printk("scsi%d: %s: Insufficient buffer size\n",
+				      ha->host_no, __func__));
+	}
+
+	// We've successfully finished building the response packet.
+	// Set the size field.
+
+	//QLASSERT (!((ptr - payload_start) % 4));
+
+	isns_rsp_message->pdu_length = cpu_to_be16((unsigned long) ptr -
+                                                   (unsigned long) payload_start);
+
+	packet_size = (unsigned long) ptr - (unsigned long) pdu_entry->Buff;
+
+	pdu_entry->SendBuffLen = packet_size;
+	pdu_entry->RecvBuffLen = 0;
+
+	QL4PRINT(QLP20, printk("---------------------------\n"));
+	QL4PRINT(QLP20, printk("scsi%d: %s:                            sending  %d SCNRsp\n",
+			       ha->host_no, __func__,
+			       be16_to_cpu(isns_rsp_message->transaction_id)));
+	QL4PRINT(QLP19, printk("PDU (0x%p) 0x%x ->\n", pdu_entry->Buff, pdu_entry->SendBuffLen));
+	qla4xxx_dump_bytes(QLP19, pdu_entry->Buff, pdu_entry->SendBuffLen);
+
+	if (qla4xxx_send_passthru0_iocb (ha, ISNS_DEVICE_INDEX, ConnectionId,
+					 pdu_entry->DmaBuff,
+					 pdu_entry->SendBuffLen,
+					 pdu_entry->RecvBuffLen,
+					 PT_FLAG_ISNS_PDU,
+					 qla4xxx_isns_build_iocb_handle(ha, ISNS_ASYNCH_RSP_PDU, pdu_entry))
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s:  qla4xxx_send_passthru0_iocb failed\n",
+				      ha->host_no, __func__));
+		qla4xxx_free_pdu (ha, pdu_entry);
+		return(QLA_ERROR);
+	}
+
+	if (test_bit(ISNS_FLAG_SCN_IN_PROGRESS, &ha->isns_flags)) {
+		set_bit(ISNS_FLAG_SCN_RESTART, &ha->isns_flags);
+	}
+	else {
+		set_bit(ISNS_FLAG_SCN_IN_PROGRESS, &ha->isns_flags);
+		clear_bit(ISNS_FLAG_SCN_RESTART, &ha->isns_flags);
+		ha->isns_num_discovered_targets = 0;
+		if (qla4xxx_isns_dev_get_next (ha, NULL) != QLA_SUCCESS) {
+			QL4PRINT(QLP2, printk("scsi%d: %s: qla4xxx_isns_dev_get_next failed\n",
+					      ha->host_no, __func__));
+			ISNS_CLEAR_FLAGS(ha);
+		}
+	}
+
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_esi (scsi_qla_host_t *ha,
+		  uint8_t *req_buffer,
+		  uint32_t req_buffer_size,
+		  uint16_t ConnectionId)
+{
+	ISNSP_MESSAGE_HEADER *isns_req_message;
+	ISNSP_MESSAGE_HEADER *isns_rsp_message;
+	ISNSP_RESPONSE_HEADER *isns_response;
+	PDU_ENTRY * pdu_entry;
+	ISNS_ATTRIBUTE *attr;
+	uint8_t * req_buffer_end;
+	uint8_t * rsp_buffer_end;
+	uint8_t * payload_start;
+	uint8_t * ptr;
+	uint32_t packet_size;
+	uint32_t copy_size;
+
+	isns_req_message = (ISNSP_MESSAGE_HEADER *) req_buffer;
+
+	if ((pdu_entry = qla4xxx_get_pdu (ha, req_buffer_size + sizeof(uint32_t))) == NULL) {
+		QL4PRINT(QLP2, printk("scsi%d: %s:  qla4xxx_get_pdu failed\n",
+				      ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+
+	// First, setup the response packet.
+	if (qla4xxx_isns_build_server_request_response_packet(ha,
+							      pdu_entry->Buff,
+							      pdu_entry->BuffLen,
+							      (be16_to_cpu(isns_req_message->function_id) | 0x8000),
+							      ISNS_ERR_SUCCESS,
+							      be16_to_cpu(isns_req_message->transaction_id),
+							      &packet_size)
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s:  qla4xxx_isns_build_server_request_response_packet failed\n",
+				      ha->host_no, __func__));
+		qla4xxx_free_pdu (ha, pdu_entry);
+		return(QLA_ERROR);
+	}
+	isns_rsp_message = (ISNSP_MESSAGE_HEADER *) pdu_entry->Buff;
+	isns_response = (ISNSP_RESPONSE_HEADER *) &isns_rsp_message->payload[0];
+	payload_start = ( uint8_t *) isns_response;
+	rsp_buffer_end = ( uint8_t *) (pdu_entry->Buff + pdu_entry->BuffLen);
+
+	ptr = &isns_response->attributes[0];
+
+	req_buffer_end =
+		( uint8_t *) (( uint8_t *) &isns_req_message->payload[0] +
+                              be16_to_cpu(isns_req_message->pdu_length));
+
+	// Point to the source attribute in the request.  We need to return
+	// all attributes in the ESI Response.
+	attr = (ISNS_ATTRIBUTE *) &isns_req_message->payload[0];
+
+	// Copy source attributes to return buffer.
+	copy_size = req_buffer_end - ( uint8_t *) attr;
+
+	if (ptr + copy_size < rsp_buffer_end) {
+		// Attributes will fit in the response buffer.  Go ahead
+		// and copy them.
+		memcpy(ptr, attr, copy_size);
+		ptr += copy_size;
+	}
+	else {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: Insufficient buffer size\n",
+				ha->host_no, __func__));
+	}
+
+	// We've successfully finished building the response packet.
+	// Set the size field.
+
+	//QLASSERT (!((ptr - payload_start) % 4));
+
+	isns_rsp_message->pdu_length = cpu_to_be16((unsigned long) ptr -
+                                                   (unsigned long) payload_start);
+
+	packet_size = (unsigned long) ptr - (unsigned long) pdu_entry->Buff;
+
+	pdu_entry->SendBuffLen = packet_size;
+	pdu_entry->RecvBuffLen = 0;
+
+	QL4PRINT(QLP20, printk("---------------------------\n"));
+	QL4PRINT(QLP20,
+		 printk("scsi%d: %s:                            sending  %d ESIRsp\n",
+			ha->host_no, __func__,
+			be16_to_cpu(isns_rsp_message->transaction_id)));
+	QL4PRINT(QLP19, printk("PDU (0x%p) 0x%x ->\n", pdu_entry->Buff, pdu_entry->SendBuffLen));
+	qla4xxx_dump_bytes(QLP19, pdu_entry->Buff, pdu_entry->SendBuffLen);
+
+	if (qla4xxx_send_passthru0_iocb(ha, ISNS_DEVICE_INDEX,
+					ConnectionId,
+					pdu_entry->DmaBuff,
+					pdu_entry->SendBuffLen,
+					pdu_entry->RecvBuffLen,
+					PT_FLAG_ISNS_PDU,
+					qla4xxx_isns_build_iocb_handle (ha, ISNS_ASYNCH_RSP_PDU, pdu_entry))
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s:  qla4xxx_send_passthru0_iocb failed\n",
+				      ha->host_no, __func__));
+		qla4xxx_free_pdu (ha, pdu_entry);
+		return(QLA_ERROR);
+	}
+
+	return(QLA_SUCCESS);
+}
+
+
+uint8_t
+qla4xxx_isns_server_request_error(scsi_qla_host_t *ha,
+				  uint8_t *buffer,
+				  uint32_t buffer_size,
+				  uint16_t connection_id,
+				  uint32_t error_code)	 //cpu
+{
+	PDU_ENTRY *pdu_entry;
+	ISNSP_MESSAGE_HEADER *isns_message;
+	uint16_t function_id;
+	uint32_t packet_size;
+
+	isns_message = (ISNSP_MESSAGE_HEADER *) buffer;
+	function_id = be16_to_cpu(isns_message->function_id);
+
+	// Return "Message Format Error"
+	if ((pdu_entry = qla4xxx_get_pdu(ha, sizeof(ISNSP_MESSAGE_HEADER) +
+					 sizeof(uint32_t))) == NULL) {
+		QL4PRINT(QLP2, printk("scsi%d: %s:  qla4xxx_get_pdu failed\n",
+				      ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+
+	if (qla4xxx_isns_build_server_request_response_packet(
+		ha, pdu_entry->Buff, pdu_entry->BuffLen,
+                (be16_to_cpu(isns_message->function_id) | 0x8000),
+                error_code,
+                be16_to_cpu(isns_message->transaction_id),
+                &packet_size) != QLA_SUCCESS) {
+
+		QL4PRINT(QLP2, printk("scsi%d: %s:  qla4xxx_isns_build_server_"
+				      "request_response_packet failed\n",
+				      ha->host_no, __func__));
+		qla4xxx_free_pdu(ha, pdu_entry);
+		return(QLA_ERROR);
+	}
+
+	pdu_entry->SendBuffLen = packet_size;
+	pdu_entry->RecvBuffLen = 0;
+
+	QL4PRINT(QLP19, printk("PDU (0x%p) 0x%x ->\n", pdu_entry->Buff, pdu_entry->SendBuffLen));
+	qla4xxx_dump_bytes(QLP19, pdu_entry->Buff, pdu_entry->SendBuffLen);
+
+	if (qla4xxx_send_passthru0_iocb(
+		ha, ISNS_DEVICE_INDEX, connection_id,
+					pdu_entry->DmaBuff,
+					pdu_entry->SendBuffLen,
+					pdu_entry->RecvBuffLen, PT_FLAG_ISNS_PDU,
+					qla4xxx_isns_build_iocb_handle(ha, ISNS_ASYNCH_RSP_PDU, pdu_entry))
+	    != QLA_SUCCESS) {
+
+		QL4PRINT(QLP2, printk("scsi%d: %s:  qla4xxx_send_passthru0_iocb "
+				      "failed\n, ha->host_no, __func__",
+				      ha->host_no, __func__));
+		qla4xxx_free_pdu(ha, pdu_entry);
+		return(QLA_ERROR);
+	}
+	return(QLA_SUCCESS);
+}
+
+
+uint8_t
+qla4xxx_isns_parse_and_dispatch_server_request(scsi_qla_host_t *ha,
+					       uint8_t *buffer,
+					       uint32_t buffer_size,
+					       uint16_t connection_id)
+{
+	ISNSP_MESSAGE_HEADER *isns_message;
+	uint16_t function_id;
+	uint16_t transaction_id;
+
+	isns_message = (ISNSP_MESSAGE_HEADER *) buffer;
+	function_id = be16_to_cpu(isns_message->function_id);
+	transaction_id = be16_to_cpu(isns_message->transaction_id);
+
+	// Validate pdu_length specified in the iSNS message header.
+	if ((offsetof (ISNSP_MESSAGE_HEADER, payload) +
+             be16_to_cpu(isns_message->pdu_length)) > buffer_size) {
+
+		QL4PRINT(QLP2, printk("scsi%d: %s: Invalid message size %u %u\n",
+				      ha->host_no, __func__,
+				      (uint32_t) (offsetof(ISNSP_MESSAGE_HEADER, payload) +
+                                       be16_to_cpu(isns_message->pdu_length)),
+				      buffer_size));
+
+		if (function_id <= ISNS_FCID_ESI) {
+			return(qla4xxx_isns_server_request_error(ha, buffer,
+								 buffer_size,
+								 connection_id,
+								 ISNS_ERR_MSG_FORMAT));
+		}
+		return(QLA_ERROR);
+	}
+
+	// It is safe to assume from this point on that the pdu_length value
+	// (and thus our idea about the end of the buffer) is valid.
+
+	switch (function_id) {
+	case ISNS_FCID_SCN:
+		QL4PRINT(QLP2, printk("scsi%d: %s:  received %d SCN\n",
+				      ha->host_no, __func__,
+				      transaction_id));
+		return(qla4xxx_isns_scn(ha, buffer, buffer_size, connection_id));
+		break;
+
+	case ISNS_FCID_ESI:
+		QL4PRINT(QLP2, printk("scsi%d: %s:  received %d ESI\n",
+				      ha->host_no, __func__,
+				      transaction_id));
+		return(qla4xxx_isns_esi(ha, buffer, buffer_size, connection_id));
+		break;
+
+	default:
+		QL4PRINT(QLP2, printk("scsi%d: %s:  received %d Unknown iSNS ServerRequest %x\n",
+				      ha->host_no, __func__,
+				      transaction_id, function_id));
+		if (function_id <= ISNS_FCID_ESI) {
+			// Return "Message Not Supported"
+			return(qla4xxx_isns_server_request_error (ha,
+								  buffer,
+								  buffer_size,
+								  connection_id,
+								  ISNS_ERR_MSG_NOT_SUPPORTED));
+		}
+		return(QLA_ERROR);
+		break;
+	}
+	return(QLA_SUCCESS);
+
+
+}
+
+uint8_t
+qla4xxx_isns_parse_and_dispatch_server_response(scsi_qla_host_t *ha,
+						uint8_t *buffer,
+						uint32_t buffer_size)
+{
+	ISNSP_MESSAGE_HEADER *isns_message;
+	ISNSP_RESPONSE_HEADER *isns_response;
+	ISNS_ATTRIBUTE *isns_attr;
+	uint16_t function_id;
+	uint16_t transaction_id;
+	uint8_t *buffer_end;
+
+	isns_message = (ISNSP_MESSAGE_HEADER *) buffer;
+	buffer_end = (uint8_t *) ((uint8_t *) isns_message->payload +
+				  be16_to_cpu(isns_message->pdu_length));
+
+	isns_attr = (ISNS_ATTRIBUTE *) isns_message->payload;
+
+	/* Validate pdu_length specified in the iSNS message header. */
+	if (((uint32_t *) buffer_end - (uint32_t *) buffer) > buffer_size) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: Invalid message size %u %u\n",
+				ha->host_no, __func__,
+				(unsigned int) ((uint32_t *) buffer_end - (uint32_t *) buffer),
+				buffer_size));
+		return(QLA_ERROR);
+	}
+
+	transaction_id = be16_to_cpu(isns_message->transaction_id);
+	function_id = be16_to_cpu(isns_message->function_id);
+	/*
+	 * It is safe to assume from this point on that the pdu_length value
+	 * (and thus our idea about the end of the buffer) is valid.
+	 */
+	if (transaction_id > ha->isns_transaction_id) {
+
+		QL4PRINT(QLP2, printk("scsi%d: %s: Invalid message transaction "
+				      "ID recv %x exp %x\n",
+				      ha->host_no, __func__,
+				      transaction_id,
+				      ha->isns_transaction_id));
+		qla4xxx_dump_bytes(QLP2, buffer, buffer_size);
+
+		set_bit(DPC_ISNS_RESTART, &ha->dpc_flags);
+		return(QLA_ERROR);
+	}
+
+
+	isns_response = (ISNSP_RESPONSE_HEADER *) &isns_message->payload[0];
+
+	//QL4PRINT(QLP20, printk("---------------------------\n"));
+	//QL4PRINT(QLP20, printk("scsi%d: %s: received function_id %x\n",
+	//		       ha->host_no, __func__, function_id));
+
+	switch (function_id) {
+	case ISNS_FCID_DevAttrRegRsp:
+		QL4PRINT(QLP20, printk("scsi%d: %s: received %d DevAttrRegRsp\n",
+				       ha->host_no, __func__,
+				       transaction_id));
+		return(qla4xxx_isns_dev_attr_reg_rsp(ha, buffer, buffer_size));
+
+	case ISNS_FCID_DevAttrQryRsp:
+		QL4PRINT(QLP20, printk("scsi%d: %s: received %d DevAttrQryRsp\n",
+				       ha->host_no, __func__,
+				       transaction_id));
+		return(qla4xxx_isns_dev_attr_qry_rsp(ha, buffer, buffer_size));
+
+	case ISNS_FCID_DevGetNextRsp:
+		QL4PRINT(QLP20, printk("scsi%d: %s: received %d DevGetNextRsp\n",
+				       ha->host_no, __func__,
+				       transaction_id));
+		return(qla4xxx_isns_dev_get_next_rsp(ha, buffer, buffer_size));
+
+	case ISNS_FCID_DevDeregRsp:
+		QL4PRINT(QLP20, printk("scsi%d: %s: received %d DevDeregRsp\n",
+				       ha->host_no, __func__,
+				       transaction_id));
+		return(qla4xxx_isns_dev_dereg_rsp(ha, buffer, buffer_size));
+
+	case ISNS_FCID_SCNRegRsp:
+		QL4PRINT(QLP20, printk("scsi%d: %s: received %d SCNRegRsp\n",
+				       ha->host_no, __func__,
+				       transaction_id));
+		return(qla4xxx_isns_scn_reg_rsp(ha, buffer, buffer_size));
+
+	case ISNS_FCID_SCNDeregRsp:
+		QL4PRINT(QLP20, printk("scsi%d: %s: received %d SCNDeregRsp\n",
+				       ha->host_no, __func__,
+				       transaction_id));
+		return(qla4xxx_isns_scn_dereg_rsp(ha, buffer, buffer_size));
+
+	default:
+		QL4PRINT(QLP2, printk("scsi%d: %s: Received %d Unknown iSNS function_id %x\n",
+				      ha->host_no, __func__,
+				      transaction_id, function_id));
+		break;
+	}
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_dev_attr_reg(scsi_qla_host_t *ha)
+{
+	PDU_ENTRY *pdu_entry;
+	uint32_t  packet_size;
+
+	pdu_entry = qla4xxx_get_pdu(ha, PAGE_SIZE);
+	if (pdu_entry == NULL) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: get pdu failed\n",
+				      ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+
+	if (qla4xxx_isns_build_registration_packet(ha, pdu_entry->Buff,
+						   pdu_entry->BuffLen,
+						   ha->isns_entity_id,
+						   ha->ip_address,
+						   ha->isns_remote_port_num,
+						   ha->isns_scn_port_num,
+						   ha->isns_esi_port_num,
+						   ha->alias, &packet_size)
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: "
+				"qla4xxx_isns_build_registration_packet failed\n",
+				ha->host_no, __func__));
+		qla4xxx_free_pdu(ha, pdu_entry);
+		return(QLA_ERROR);
+	}
+
+	pdu_entry->SendBuffLen = packet_size;
+	pdu_entry->RecvBuffLen = pdu_entry->BuffLen;
+
+	QL4PRINT(QLP20, printk("---------------------------\n"));
+	QL4PRINT(QLP20, printk("scsi%d: %s:                    sending %d DevAttrReg\n",
+			       ha->host_no, __func__, ha->isns_transaction_id));
+
+	QL4PRINT(QLP19, printk("PDU (0x%p) 0x%x ->\n", pdu_entry->Buff, pdu_entry->SendBuffLen));
+	qla4xxx_dump_bytes(QLP19, pdu_entry->Buff, pdu_entry->SendBuffLen);
+
+	QL4PRINT(QLP20, printk("scsi%d: %s: Registering iSNS . . .\n",
+			       ha->host_no, __func__));
+
+	if (qla4xxx_send_passthru0_iocb(
+		ha, ISNS_DEVICE_INDEX,
+					ISNS_DEFAULT_SERVER_CONN_ID,
+					pdu_entry->DmaBuff,
+					pdu_entry->SendBuffLen,
+					pdu_entry->RecvBuffLen,
+					PT_FLAG_ISNS_PDU|PT_FLAG_WAIT_4_RESPONSE,
+					qla4xxx_isns_build_iocb_handle(ha, ISNS_REQ_RSP_PDU, pdu_entry))
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: "
+				"qla4xxx_send_passthru0_iocb failed\n",
+				ha->host_no, __func__));
+		qla4xxx_free_pdu(ha, pdu_entry);
+		return(QLA_ERROR);
+	}
+
+	ha->isns_transaction_id++;
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_dev_attr_reg_rsp(scsi_qla_host_t *ha,
+			      uint8_t *buffer,
+			      uint32_t buffer_size)
+{
+	ISNSP_MESSAGE_HEADER *isns_message;
+	ISNSP_RESPONSE_HEADER *isns_response;
+	uint32_t error_code;
+
+	isns_message = (ISNSP_MESSAGE_HEADER *) buffer;
+	isns_response = (ISNSP_RESPONSE_HEADER *) &isns_message->payload[0];
+	error_code = be32_to_cpu(isns_response->error_code);
+
+	if (error_code) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: iSNS DevAttrReg failed, "
+				      "error code (%x) \"%s\"\n",
+				      ha->host_no, __func__,
+				      error_code,
+				      isns_error_code_msg[error_code]));
+		clear_bit(ISNS_FLAG_ISNS_SRV_REGISTERED, &ha->isns_flags);
+		return(QLA_ERROR);
+	}
+
+	set_bit(ISNS_FLAG_ISNS_SRV_REGISTERED, &ha->isns_flags);
+	if (qla4xxx_isns_scn_reg(ha) != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: qla4xxx_isns_scn_reg failed\n",
+				      ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_scn_reg(scsi_qla_host_t *ha)
+{
+	PDU_ENTRY *isns_pdu_entry;
+	uint32_t packet_size;
+
+	if ((isns_pdu_entry = qla4xxx_get_pdu (ha, PAGE_SIZE)) == NULL) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: qla4xxx_get_pdu failed\n",
+				      ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+
+	if (qla4xxx_isns_build_scn_registration_packet(
+		ha, isns_pdu_entry->Buff, isns_pdu_entry->BuffLen,
+						       &packet_size) != QLA_SUCCESS) {
+
+		QL4PRINT(QLP2, printk("scsi%d: %s: qla4xxx_isns_build_scn_"
+				      "registration_packet failed\n",
+				      ha->host_no, __func__));
+		qla4xxx_free_pdu(ha, isns_pdu_entry);
+		return(QLA_ERROR);
+	}
+
+	isns_pdu_entry->SendBuffLen = packet_size;
+	isns_pdu_entry->RecvBuffLen = isns_pdu_entry->BuffLen;
+	
+	QL4PRINT(QLP20, printk("---------------------------\n"));
+	QL4PRINT(QLP20, printk("scsi%d :%s:                        sending  %d SCNReg\n",
+			       ha->host_no, __func__, ha->isns_transaction_id));
+	QL4PRINT(QLP19, printk("PDU (0x%p) 0x%x ->\n", isns_pdu_entry->Buff, isns_pdu_entry->SendBuffLen));
+	qla4xxx_dump_bytes(QLP19, isns_pdu_entry->Buff, isns_pdu_entry->SendBuffLen);
+
+	if (qla4xxx_send_passthru0_iocb(
+		ha, ISNS_DEVICE_INDEX,
+					ISNS_DEFAULT_SERVER_CONN_ID,
+					isns_pdu_entry->DmaBuff,
+					isns_pdu_entry->SendBuffLen,
+					isns_pdu_entry->RecvBuffLen,
+					PT_FLAG_ISNS_PDU | PT_FLAG_WAIT_4_RESPONSE,
+					qla4xxx_isns_build_iocb_handle(ha, ISNS_REQ_RSP_PDU, isns_pdu_entry))
+	    != QLA_SUCCESS) {
+
+		QL4PRINT(QLP2, printk("scsi%d: %s: qla4xxx_send_passthru0_iocb failed\n",
+				      ha->host_no, __func__));
+		qla4xxx_free_pdu(ha, isns_pdu_entry);
+		return(QLA_ERROR);
+	}
+	ha->isns_transaction_id++;
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_scn_reg_rsp(scsi_qla_host_t *ha,
+			 uint8_t *buffer,
+			 uint32_t buffer_size)
+{
+	ISNSP_MESSAGE_HEADER *isns_message;
+	ISNSP_RESPONSE_HEADER *isns_response;
+
+	isns_message = (ISNSP_MESSAGE_HEADER *) buffer;
+	isns_response = (ISNSP_RESPONSE_HEADER *) isns_message->payload;
+
+	if (isns_response->error_code) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: iSNS SCNReg failed, error code %x\n",
+				ha->host_no, __func__,
+				be32_to_cpu(isns_response->error_code)));
+		clear_bit(ISNS_FLAG_ISNS_SCN_REGISTERED, &ha->isns_flags);
+		return(QLA_ERROR);
+	}
+
+	set_bit(ISNS_FLAG_ISNS_SCN_REGISTERED, &ha->isns_flags);
+
+	ha->isns_num_discovered_targets = 0;
+	if (qla4xxx_isns_dev_get_next(ha, NULL) != QLA_SUCCESS) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: qla4xxx_isns_dev_get_next failed\n",
+				      ha->host_no, __func__));
+	}
+
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_dev_attr_qry(scsi_qla_host_t *ha,
+			  uint8_t *last_iscsi_name)
+{
+	PDU_ENTRY *pdu_entry;
+	uint32_t packet_size;
+
+	if ((pdu_entry = qla4xxx_get_pdu(ha, PAGE_SIZE)) == NULL) {
+		QL4PRINT(QLP2, printk("scsi%d: %s:  qla4xxx_get_pdu failed\n",
+				      ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+
+	if (qla4xxx_isns_build_dev_attr_qry_packet(ha, pdu_entry->Buff,
+						   pdu_entry->BuffLen,
+						   last_iscsi_name,
+						   &packet_size)
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s:  qla4xxx_isns_build_dev_attr_qry_packet failed\n",
+				ha->host_no, __func__));
+		qla4xxx_free_pdu (ha, pdu_entry);
+		return(QLA_ERROR);
+	}
+
+	pdu_entry->SendBuffLen = packet_size;
+	pdu_entry->RecvBuffLen = pdu_entry->BuffLen;
+
+	QL4PRINT(QLP20, printk("---------------------------\n"));
+	QL4PRINT(QLP20,
+		 printk("scsi%d: %s:                     sending  %d DevAttrQry\n",
+			ha->host_no, __func__, ha->isns_transaction_id));
+	QL4PRINT(QLP19, printk("PDU (0x%p) 0x%x ->\n", pdu_entry->Buff, pdu_entry->SendBuffLen));
+	qla4xxx_dump_bytes(QLP19, pdu_entry->Buff, pdu_entry->SendBuffLen);
+
+	if (qla4xxx_send_passthru0_iocb(
+		ha, ISNS_DEVICE_INDEX,
+					ISNS_DEFAULT_SERVER_CONN_ID,
+					pdu_entry->DmaBuff,
+					pdu_entry->SendBuffLen,
+					pdu_entry->RecvBuffLen,
+					PT_FLAG_ISNS_PDU | PT_FLAG_WAIT_4_RESPONSE,
+					qla4xxx_isns_build_iocb_handle (ha, ISNS_REQ_RSP_PDU, pdu_entry))
+	    != QLA_SUCCESS) {
+
+		QL4PRINT(QLP2, printk("scsi%d: %s:  qla4xxx_send_passthru0_iocb "
+				      "failed\n", ha->host_no, __func__));
+		qla4xxx_free_pdu (ha, pdu_entry);
+		return(QLA_ERROR);
+	}
+	ha->isns_transaction_id++;
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_dev_attr_qry_rsp(scsi_qla_host_t *ha,
+			      uint8_t *buffer,
+			      uint32_t buffer_size)
+{
+	uint8_t *last_iscsi_name = NULL;
+	ISNS_DISCOVERED_TARGET *discovered_target = NULL;
+	uint32_t isns_error;
+	int i;
+	uint8_t bIsTarget = 1;
+	uint8_t bFound = 0;
+	uint8_t status = QLA_SUCCESS;
+
+	if (test_bit(ISNS_FLAG_SCN_RESTART, &ha->isns_flags)) {
+		clear_bit(ISNS_FLAG_SCN_RESTART, &ha->isns_flags);
+		ha->isns_num_discovered_targets = 0;
+		if (qla4xxx_isns_dev_get_next(ha, NULL) != QLA_SUCCESS) {
+			QL4PRINT(QLP2, printk("scsi%d: %s: qla4xxx_isns_dev_get_next failed\n",
+					      ha->host_no, __func__));
+			goto exit_qry_rsp_clear_flags;
+		}
+		goto exit_qry_rsp;
+	}
+
+	last_iscsi_name = kmalloc(256, GFP_ATOMIC);
+	discovered_target = kmalloc(sizeof(*discovered_target), GFP_ATOMIC);
+	if (!last_iscsi_name || !discovered_target) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: failed to allocate memory\n",
+				      ha->host_no, __func__));
+		status = QLA_ERROR;
+		goto exit_qry_rsp;
+	}
+
+	memset(last_iscsi_name, 0, 256);
+	memset(discovered_target, 0, sizeof(ISNS_DISCOVERED_TARGET));
+	if (qla4xxx_isns_parse_query_response(ha, buffer, buffer_size,
+					      &isns_error,
+					      discovered_target,
+					      &bIsTarget,
+					      last_iscsi_name)
+	    == QLA_SUCCESS) {
+
+		if (bIsTarget &&
+		    discovered_target->NameString[0] &&
+		    discovered_target->NumPortals) {
+
+			for (i = 0; i < ha->isns_num_discovered_targets; i++) {
+				if (!strcmp(discovered_target->NameString,
+					    ha->isns_disc_tgt_databasev[i].NameString)) {
+					QL4PRINT(QLP2, printk("scsi%d: %s: found at index %x\n",
+							      ha->host_no, __func__, i));
+					memcpy(&ha->isns_disc_tgt_databasev[i],
+					       discovered_target,
+					       sizeof(ISNS_DISCOVERED_TARGET));
+					ha->isns_disc_tgt_databasev[i] = *discovered_target;
+					bFound = 1;
+					break;
+				}
+			}
+			if (!bFound && i < MAX_ISNS_DISCOVERED_TARGETS) {
+				QL4PRINT(QLP20,
+					 printk("scsi%d: %s: not already present, "
+						"put in index %x\n",
+						ha->host_no, __func__, i));
+				memcpy(&ha->isns_disc_tgt_databasev[i],
+				       discovered_target,
+				       sizeof(ISNS_DISCOVERED_TARGET));
+				ha->isns_num_discovered_targets++;
+			}
+		}
+	}
+
+	if (test_bit(ISNS_FLAG_QUERY_SINGLE_OBJECT, &ha->isns_flags)) {
+		goto exit_qry_rsp_clear_flags;
+	}
+	else if (last_iscsi_name[0] == 0) {
+		goto exit_qry_rsp_clear_flags;
+	}
+	else {
+		if (qla4xxx_isns_dev_get_next (ha, last_iscsi_name) != QLA_SUCCESS) {
+			QL4PRINT(QLP2,
+				 printk("scsi%d: %s: "
+					"qla4xxx_isns_dev_get_next failed\n",
+					ha->host_no, __func__));
+			goto exit_qry_rsp_clear_flags;
+		}
+	}
+
+	goto exit_qry_rsp;
+
+	exit_qry_rsp_clear_flags:
+	ISNS_CLEAR_FLAGS(ha);
+
+	exit_qry_rsp:
+	if (last_iscsi_name) kfree(last_iscsi_name);
+	if (discovered_target) kfree (discovered_target);
+	return(status);
+}
+
+uint8_t
+qla4xxx_isns_dev_get_next(scsi_qla_host_t *ha,
+			  uint8_t *last_iscsi_name)
+{
+	PDU_ENTRY *pdu_entry;
+	uint32_t packet_size;
+
+	if ((pdu_entry = qla4xxx_get_pdu(ha, PAGE_SIZE)) == NULL) {
+		QL4PRINT(QLP2, printk("scsi%d: %s:  qla4xxx_get_pdu failed\n",
+				      ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+
+	if (qla4xxx_isns_build_dev_get_next_packet (ha, pdu_entry->Buff,
+						    pdu_entry->BuffLen,
+						    last_iscsi_name,
+						    &packet_size)
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s:  qla4xxx_isns_build_dev_get_next_packet failed\n",
+				      ha->host_no, __func__));
+		qla4xxx_free_pdu (ha, pdu_entry);
+		return(QLA_ERROR);
+	}
+
+	pdu_entry->SendBuffLen = packet_size;
+	pdu_entry->RecvBuffLen = pdu_entry->BuffLen;
+
+	QL4PRINT(QLP20, printk("---------------------------\n"));
+	QL4PRINT(QLP20, printk("scsi%d: %s:                     sending  %d DevGetNext\n",
+			       ha->host_no, __func__, ha->isns_transaction_id));
+	QL4PRINT(QLP19, printk("PDU (0x%p) 0x%x ->\n", pdu_entry->Buff, pdu_entry->SendBuffLen));
+	qla4xxx_dump_bytes(QLP19, pdu_entry->Buff, pdu_entry->SendBuffLen);
+
+	if (qla4xxx_send_passthru0_iocb(
+		ha, ISNS_DEVICE_INDEX,
+					ISNS_DEFAULT_SERVER_CONN_ID,
+					pdu_entry->DmaBuff,
+					pdu_entry->SendBuffLen,
+					pdu_entry->RecvBuffLen,
+					PT_FLAG_ISNS_PDU | PT_FLAG_WAIT_4_RESPONSE,
+					qla4xxx_isns_build_iocb_handle(ha, ISNS_REQ_RSP_PDU, pdu_entry))
+	    != QLA_SUCCESS) {
+
+		QL4PRINT(QLP2, printk("scsi%d: %s:  qla4xxx_send_passthru0_iocb failed\n",
+				      ha->host_no, __func__));
+		qla4xxx_free_pdu (ha, pdu_entry);
+		return(QLA_ERROR);
+	}
+	ha->isns_transaction_id++;
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_dev_get_next_rsp(scsi_qla_host_t *ha,
+			      uint8_t *buffer,
+			      uint32_t buffer_size)
+{
+	uint32_t isns_error = 0;
+	uint8_t bIsTarget;
+	static uint8_t last_iscsi_name[256];
+
+	if (test_bit(ISNS_FLAG_SCN_RESTART, &ha->isns_flags)) {
+		clear_bit(ISNS_FLAG_SCN_RESTART, &ha->isns_flags);
+		ha->isns_num_discovered_targets = 0;
+		if (qla4xxx_isns_dev_get_next(ha, NULL) != QLA_SUCCESS) {
+			QL4PRINT(QLP2, printk("scsi%d: %s: qla4xxx_isns_dev_get_next failed\n",
+					      ha->host_no, __func__));
+			goto exit_get_next_rsp;
+		}
+		return(QLA_SUCCESS);
+	}
+
+	if (qla4xxx_isns_parse_get_next_response(ha, buffer, buffer_size,
+						 &isns_error, &last_iscsi_name[0],
+						 sizeof(last_iscsi_name) - 1,
+						 &bIsTarget)
+	    != QLA_SUCCESS) {
+		if (isns_error != ISNS_ERR_NO_SUCH_ENTRY) {
+			QL4PRINT(QLP2, printk("scsi%d: %s: qla4xxx_isns_parse_get_next_response failed\n",
+					      ha->host_no, __func__));
+		}
+		goto exit_get_next_rsp;
+	}
+
+    #if 1
+	if (bIsTarget) {
+		if (qla4xxx_isns_dev_attr_qry(ha, &last_iscsi_name[0]) != QLA_SUCCESS) {
+			QL4PRINT(QLP2, printk("scsi%d: %s: qla4xxx_isns_dev_attr_qry failed\n",
+					      ha->host_no, __func__));
+			goto exit_get_next_rsp;
+		}
+	}
+	else {
+		if (qla4xxx_isns_dev_get_next(ha, &last_iscsi_name[0]) != QLA_SUCCESS) {
+			QL4PRINT(QLP2, printk("scsi%d: %s: qla4xxx_isns_dev_get_next failed\n",
+					      ha->host_no, __func__));
+			goto exit_get_next_rsp;
+		}
+	}
+    #else
+	if (qla4xxx_isns_dev_attr_qry(ha, &last_iscsi_name[0]) != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: qla4xxx_isns_dev_attr_qry failed\n",
+				      ha->host_no, __func__));
+		goto exit_get_next_rsp;
+	}
+    #endif
+
+	return(QLA_SUCCESS);
+
+	exit_get_next_rsp:
+	clear_bit(ISNS_FLAG_SCN_IN_PROGRESS, &ha->isns_flags);
+	clear_bit(ISNS_FLAG_SCN_RESTART, &ha->isns_flags);
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_dev_dereg(scsi_qla_host_t *ha)
+{
+	PDU_ENTRY *pdu_entry;
+	uint32_t packet_size;
+
+	if ((pdu_entry = qla4xxx_get_pdu (ha, PAGE_SIZE)) == NULL) {
+		QL4PRINT(QLP2, printk("scsi%d: %s:  qla4xxx_get_pdu failed\n",
+				      ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+
+	if (qla4xxx_isns_build_deregistration_packet(ha, pdu_entry->Buff,
+						     pdu_entry->BuffLen,
+						     ha->isns_entity_id,
+						     ha->isns_ip_address,
+						     ha->isns_server_port_number,
+						     &packet_size)
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s:  QLiSNSBuildDeregistrationPacket "
+				"failed\n", ha->host_no, __func__));
+		qla4xxx_free_pdu (ha, pdu_entry);
+		return(QLA_ERROR);
+	}
+
+	pdu_entry->SendBuffLen = packet_size;
+	pdu_entry->RecvBuffLen = pdu_entry->BuffLen;
+
+	QL4PRINT(QLP20, printk("---------------------------\n"));
+	QL4PRINT(QLP20,
+		 printk("scsi%d: %s:                       sending  %d DevDereg\n",
+			ha->host_no, __func__, ha->isns_transaction_id));
+	QL4PRINT(QLP19, printk("PDU (0x%p) 0x%x ->\n", pdu_entry->Buff, pdu_entry->SendBuffLen));
+	qla4xxx_dump_bytes(QLP19, pdu_entry->Buff, pdu_entry->SendBuffLen);
+
+	if (qla4xxx_send_passthru0_iocb(
+		ha, ISNS_DEVICE_INDEX,
+					ISNS_DEFAULT_SERVER_CONN_ID,
+					pdu_entry->DmaBuff,
+					pdu_entry->SendBuffLen,
+					pdu_entry->RecvBuffLen,
+					PT_FLAG_ISNS_PDU | PT_FLAG_WAIT_4_RESPONSE,
+					qla4xxx_isns_build_iocb_handle(ha, ISNS_REQ_RSP_PDU, pdu_entry))
+	    != QLA_SUCCESS) {
+
+		QL4PRINT(QLP2, printk("scsi%d: %s:  qla4xxx_send_passthru0_iocb failed\n",
+				      ha->host_no, __func__));
+		qla4xxx_free_pdu(ha, pdu_entry);
+		return(QLA_ERROR);
+	}
+	ha->isns_transaction_id++;
+	return(QLA_SUCCESS);
+}
+
+
+uint8_t
+qla4xxx_isns_dev_dereg_rsp(scsi_qla_host_t *ha,
+			   uint8_t *buffer,
+			   uint32_t buffer_size)
+{
+	ISNSP_MESSAGE_HEADER * isns_message;
+	ISNSP_RESPONSE_HEADER * isns_response;
+
+	isns_message = (ISNSP_MESSAGE_HEADER *) buffer;
+	isns_response = (ISNSP_RESPONSE_HEADER *) &isns_message->payload[0];
+
+	clear_bit(ISNS_FLAG_ISNS_SRV_REGISTERED, &ha->isns_flags);
+
+	if (be32_to_cpu(isns_response->error_code)) {
+		QL4PRINT(QLP10, printk("scsi%d: %s: iSNS SCNDereg rsp code %x\n",
+				       ha->host_no, __func__,
+				       be32_to_cpu(isns_response->error_code)));
+	}
+
+	if (test_bit(ISNS_FLAG_REREGISTER, &ha->isns_flags)) {
+		clear_bit(ISNS_FLAG_REREGISTER, &ha->isns_flags);
+
+		if (qla4xxx_isns_dev_attr_reg(ha) != QLA_SUCCESS) {
+			QL4PRINT(QLP2, printk("scsi%d: %s: qla4xxx_isns_dev_attr_reg failed\n",
+					      ha->host_no, __func__));
+			return(QLA_ERROR);
+		}
+	}
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_scn_dereg(scsi_qla_host_t *ha)
+{
+	PDU_ENTRY *pdu_entry;
+	uint32_t packet_size;
+
+	if ((pdu_entry = qla4xxx_get_pdu(ha, PAGE_SIZE)) == NULL) {
+		QL4PRINT(QLP2, printk("scsi%d: %s:  qla4xxx_get_pdu failed\n",
+				      ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+
+	if (qla4xxx_isns_build_scn_deregistration_packet(ha, pdu_entry->Buff,
+							 pdu_entry->BuffLen,
+							 &packet_size)
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s:  qla4xxx_isns_build_scn_"
+				      "deregistration_packet failed\n",
+				      ha->host_no, __func__));
+		qla4xxx_free_pdu (ha, pdu_entry);
+		return(QLA_ERROR);
+	}
+
+	pdu_entry->SendBuffLen = packet_size;
+	pdu_entry->RecvBuffLen = pdu_entry->BuffLen;
+
+	QL4PRINT(QLP20, printk("---------------------------\n"));
+	QL4PRINT(QLP20, printk("scsi%d: %s:                       sending  %d SCNDereg\n",
+			       ha->host_no, __func__, ha->isns_transaction_id));
+	QL4PRINT(QLP19, printk("PDU (0x%p) 0x%x ->\n", pdu_entry->Buff, pdu_entry->SendBuffLen));
+	qla4xxx_dump_bytes(QLP19, pdu_entry->Buff, pdu_entry->SendBuffLen);
+
+	clear_bit(ISNS_FLAG_DEV_SCAN_DONE, &ha->isns_flags);
+
+	if (qla4xxx_send_passthru0_iocb(ha, ISNS_DEVICE_INDEX,
+					 ISNS_DEFAULT_SERVER_CONN_ID,
+					 pdu_entry->DmaBuff,
+					 pdu_entry->SendBuffLen,
+					 pdu_entry->RecvBuffLen,
+					 PT_FLAG_ISNS_PDU | PT_FLAG_WAIT_4_RESPONSE,
+					 qla4xxx_isns_build_iocb_handle (ha, ISNS_REQ_RSP_PDU, pdu_entry))
+	    != QLA_SUCCESS) {
+
+		QL4PRINT(QLP2, printk("scsi%d: %s:  qla4xxx_send_passthru0_iocb "
+				      "failed\n", ha->host_no, __func__));
+		qla4xxx_free_pdu (ha, pdu_entry);
+		return(QLA_ERROR);
+	}
+	ha->isns_transaction_id++;
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_scn_dereg_rsp(scsi_qla_host_t *ha,
+			   uint8_t *buffer,
+			   uint32_t buffer_size)
+{
+	ISNSP_MESSAGE_HEADER *isns_message;
+	ISNSP_RESPONSE_HEADER *isns_response;
+
+	isns_message = (ISNSP_MESSAGE_HEADER *) buffer;
+	isns_response = (ISNSP_RESPONSE_HEADER *) &isns_message->payload[0];
+
+	clear_bit(ISNS_FLAG_ISNS_SCN_REGISTERED, &ha->isns_flags);
+
+	if (be32_to_cpu(isns_response->error_code)) {
+		QL4PRINT(QLP10, printk("scsi%d: %s: iSNS SCNDereg rsp code %x\n",
+				       ha->host_no, __func__,
+				       be32_to_cpu(isns_response->error_code)));
+	}
+
+	if (test_bit(ISNS_FLAG_REREGISTER, &ha->isns_flags)) {
+		if (qla4xxx_isns_dev_dereg(ha) != QLA_SUCCESS) {
+			QL4PRINT(QLP2, printk("scsi%d: %s: QLiSNSDevDereg failed\n",
+					      ha->host_no, __func__));
+			return(QLA_ERROR);
+		}
+	}
+	return(QLA_SUCCESS);
+}
+
+/*
+ * Overrides for Emacs so that we almost follow Linus's tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 2
+ * c-brace-imaginary-offset: 0
+ * c-brace-offset: -2
+ * c-argdecl-indent: 2
+ * c-label-offset: -2
+ * c-continued-statement-offset: 2
+ * c-continued-brace-offset: 0
+ * indent-tabs-mode: nil
+ * tab-width: 8
+ * End:
+ */
diff --git a/drivers/scsi/qla4xxx/ql4_isns.h b/drivers/scsi/qla4xxx/ql4_isns.h
new file mode 100644
index 0000000..1140fed
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_isns.h
@@ -0,0 +1,408 @@
+/******************************************************************************
+ *     Copyright (C)  2003 -2005 QLogic Corporation
+ * QLogic ISP4xxx Device Driver
+ *
+ * This program includes a device driver for Linux 2.6.x that may be
+ * distributed with QLogic hardware specific firmware binary file.
+ * You may modify and redistribute the device driver code under the
+ * GNU General Public License as published by the Free Software Foundation
+ * (version 2 or a later version) and/or under the following terms,
+ * as applicable:
+ *
+ * 	1. Redistribution of source code must retain the above copyright
+ *         notice, this list of conditions and the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above copyright
+ *         notice, this list of conditions and the following disclaimer in
+ *         the documentation and/or other materials provided with the
+ *         distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ * 	
+ * You may redistribute the hardware specific firmware binary file under
+ * the following terms:
+ * 	1. Redistribution of source code (only if applicable), must
+ *         retain the above copyright notice, this list of conditions and
+ *         the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above
+ *         copyright notice, this list of conditions and the following
+ *         disclaimer in the documentation and/or other materials provided
+ *         with the distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ *
+ * REGARDLESS OF WHAT LICENSING MECHANISM IS USED OR APPLICABLE,
+ * THIS PROGRAM IS PROVIDED BY QLOGIC CORPORATION "AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * USER ACKNOWLEDGES AND AGREES THAT USE OF THIS PROGRAM WILL NOT CREATE
+ * OR GIVE GROUNDS FOR A LICENSE BY IMPLICATION, ESTOPPEL, OR OTHERWISE
+ * IN ANY INTELLECTUAL PROPERTY RIGHTS (PATENT, COPYRIGHT, TRADE SECRET,
+ * MASK WORK, OR OTHER PROPRIETARY RIGHT) EMBODIED IN ANY OTHER QLOGIC
+ * HARDWARE OR SOFTWARE EITHER SOLELY OR IN COMBINATION WITH THIS PROGRAM
+ *
+ ******************************************************************************/
+#define ISNSP_VERSION           0x0001  // Current iSNS version as defined by
+// the latest spec that we support
+
+/* Swap Macros
+ *
+ * These are designed to be used on constants (such as the function codes
+ * below) such that the swapping is done by the compiler at compile time
+ * and not at run time.  Of course, they should also work on variables
+ * in which case the swapping will occur at run time.
+ */
+#define WSWAP(x) (uint16_t)(((((uint16_t)x)<<8)&0xFF00) | \
+                            ((((uint16_t)x)>>8)&0x00FF))
+#define DWSWAP(x) (uint32_t)(((((uint32_t)x)<<24)&0xFF000000) | \
+		             ((((uint32_t)x)<<8)&0x00FF0000) |  \
+		             ((((uint32_t)x)>>8)&0x0000FF00) |  \
+		             ((((uint32_t)x)>>24)&0x000000FF))
+
+/*
+ * Timeout Values
+ *******************/
+#define ISNS_RESTART_TOV	5
+
+#define IOCB_ISNS_PT_PDU_TYPE(x)                      ((x) & 0x0F000000)
+#define IOCB_ISNS_PT_PDU_INDEX(x)                     ((x) & (MAX_PDU_ENTRIES-1))
+
+#define ISNS_ASYNCH_REQ_PDU                           0x01000000
+#define ISNS_ASYNCH_RSP_PDU                           0x02000000
+#define ISNS_REQ_RSP_PDU                              0x03000000
+
+
+// Fake device indexes.  Used internally by the driver for indexing to other than a DDB entry
+#define ISNS_DEVICE_INDEX                             MAX_DEV_DB_ENTRIES + 0
+
+#define ISNS_CLEAR_FLAGS(ha) do {clear_bit(ISNS_FLAG_SCN_IN_PROGRESS |    \
+                                       ISNS_FLAG_SCN_RESTART | 	      \
+				       ISNS_FLAG_QUERY_SINGLE_OBJECT, \
+				       &ha->isns_flags);} while(0);
+
+
+
+// iSNS Message Function ID codes
+
+#define ISNS_FCID_DevAttrReg      0x0001      // Device Attribute Registration Request
+#define ISNS_FCID_DevAttrQry      0x0002      // Device Attribute Query Request
+#define ISNS_FCID_DevGetNext      0x0003      // Device Get Next Request
+#define ISNS_FCID_DevDereg        0x0004      // Device Deregister Request
+#define ISNS_FCID_SCNReg          0x0005      // SCN Register Request
+#define ISNS_FCID_SCNDereg        0x0006      // SCN Deregister Request
+#define ISNS_FCID_SCNEvent        0x0007      // SCN Event
+#define ISNS_FCID_SCN             0x0008      // State Change Notification
+#define ISNS_FCID_DDReg           0x0009      // DD Register
+#define ISNS_FCID_DDDereg         0x000A      // DD Deregister
+#define ISNS_FCID_DDSReg          0x000B      // DDS Register
+#define ISNS_FCID_DDSDereg        0x000C      // DDS Deregister
+#define ISNS_FCID_ESI             0x000D      // Entity Status Inquiry
+#define ISNS_FCID_Heartbeat       0x000E      // Name Service Heartbeat
+//NOT USED              0x000F-0x0010
+#define ISNS_FCID_RqstDomId       0x0011      // Request FC_DOMAIN_ID
+#define ISNS_FCID_RlseDomId       0x0012      // Release FC_DOMAIN_ID
+#define ISNS_FCID_GetDomId        0x0013      // Get FC_DOMAIN_IDs
+//RESERVED              0x0014-0x00FF
+//Vendor Specific       0x0100-0x01FF
+//RESERVED              0x0200-0x8000
+
+
+// iSNS Response Message Function ID codes
+
+#define ISNS_FCID_DevAttrRegRsp   0x8001      // Device Attribute Registration Response
+#define ISNS_FCID_DevAttrQryRsp   0x8002      // Device Attribute Query Response
+#define ISNS_FCID_DevGetNextRsp   0x8003      // Device Get Next Response
+#define ISNS_FCID_DevDeregRsp     0x8004      // Deregister Device Response
+#define ISNS_FCID_SCNRegRsp       0x8005      // SCN Register Response
+#define ISNS_FCID_SCNDeregRsp     0x8006      // SCN Deregister Response
+#define ISNS_FCID_SCNEventRsp     0x8007      // SCN Event Response
+#define ISNS_FCID_SCNRsp          0x8008      // SCN Response
+#define ISNS_FCID_DDRegRsp        0x8009      // DD Register Response
+#define ISNS_FCID_DDDeregRsp      0x800A      // DD Deregister Response
+#define ISNS_FCID_DDSRegRsp       0x800B      // DDS Register Response
+#define ISNS_FCID_DDSDeregRsp     0x800C      // DDS Deregister Response
+#define ISNS_FCID_ESIRsp          0x800D      // Entity Status Inquiry Response
+//NOT USED              0x800E-0x8010
+#define ISNS_FCID_RqstDomIdRsp    0x8011      // Request FC_DOMAIN_ID Response
+#define ISNS_FCID_RlseDomIdRsp    0x8012      // Release FC_DOMAIN_ID Response
+#define ISNS_FCID_GetDomIdRsp     0x8013      // Get FC_DOMAIN_IDs Response
+//RESERVED              0x8014-0x80FF
+//Vendor Specific       0x8100-0x81FF
+//RESERVED              0x8200-0xFFFF
+
+
+// iSNS Error Codes
+
+#define ISNS_ERR_SUCCESS                    0   // Successful
+#define ISNS_ERR_UNKNOWN                    1   // Unknown Error
+#define ISNS_ERR_MSG_FORMAT                 2   // Message Format Error
+#define ISNS_ERR_INVALID_REG                3   // Invalid Registration
+//RESERVED                                  4
+#define ISNS_ERR_INVALID_QUERY              5   // Invalid Query
+#define ISNS_ERR_SOURCE_UNKNOWN             6   // Source Unknown
+#define ISNS_ERR_SOURCE_ABSENT              7   // Source Absent
+#define ISNS_ERR_SOURCE_UNAUTHORIZED        8   // Source Unauthorized
+#define ISNS_ERR_NO_SUCH_ENTRY              9   // No Such Entry
+#define ISNS_ERR_VER_NOT_SUPPORTED          10  // Version Not Supported
+#define ISNS_ERR_INTERNAL_ERROR             11  // Internal Error
+#define ISNS_ERR_BUSY                       12  // Busy
+#define ISNS_ERR_OPT_NOT_UNDERSTOOD         13  // Option Not Understood
+#define ISNS_ERR_INVALID_UPDATE             14  // Invalid Update
+#define ISNS_ERR_MSG_NOT_SUPPORTED          15  // Message (FUNCTION_ID) Not Supported
+#define ISNS_ERR_SCN_EVENT_REJECTED         16  // SCN Event Rejected
+#define ISNS_ERR_SCN_REG_REJECTED           17  // SCN Registration Rejected
+#define ISNS_ERR_ATTR_NOT_IMPLEMENTED       18  // Attribute Not Implemented
+#define ISNS_ERR_FC_DOMAIN_ID_NOT_AVAIL     19  // FC_DOMAIN_ID Not Available
+#define ISNS_ERR_FC_DOMAIN_ID_NOT_ALLOC     20  // FC_DOMAIN_ID Not Allocated
+#define ISNS_ERR_ESI_NOT_AVAILABLE          21  // ESI Not Available
+#define ISNS_ERR_INVALID_DEREG              22  // Invalid Deregistration
+#define ISNS_ERR_REG_FEATURES_NOT_SUPPORTED 23  // Registration Features Not Supported
+
+#define ISNS_ERROR_CODE_TBL()	{  \
+	"SUCCESSFUL"	        		, \
+	"UNKNOWN ERROR"	        		, \
+	"MESSAGE FORMAT ERROR"	        	, \
+	"INVALID REGISTRATION"	        	, \
+	"RESERVED"	        		, \
+	"INVALID QUERY"	        		, \
+	"SOURCE UNKNOWN"	        	, \
+	"SOURCE ABSENT"	        		, \
+	"SOURCE UNAUTHORIZED"	        	, \
+	"NO SUCH ENTRY"	        		, \
+	"VERSION NOT SUPPORTED"	        	, \
+	"INTERNAL ERROR"	        	, \
+	"BUSY"	        			, \
+	"OPTION NOT UNDERSTOOD"	        	, \
+	"INVALID UPDATE"	        	, \
+	"MESSAGE (FUNCTION_ID) NOT SUPPORTED"	, \
+	"SCN EVENT REJECTED"	        	, \
+	"SCN REGISTRATION REJECTED"	        , \
+	"ATTRIBUTE NOT IMPLEMENTED"	        , \
+	"FC_DOMAIN_ID NOT AVAILABLE"	        , \
+	"FC_DOMAIN_ID NOT ALLOCATED"	        , \
+	"ESI NOT AVAILABLE"	        	, \
+	"INVALID DEREGISTRATION"	        , \
+	"REGISTRATION FEATURES NOT SUPPORTED"	, \
+	NULL			  \
+}
+
+
+// iSNS Protocol Structures
+
+typedef struct {
+	uint16_t isnsp_version;
+	uint16_t function_id;
+	uint16_t pdu_length;   // Length of the payload (does not include header)
+	uint16_t flags;
+	uint16_t transaction_id;
+	uint16_t sequence_id;
+	uint8_t payload[0];   // Variable payload data
+} ISNSP_MESSAGE_HEADER, *PISNSP_MESSAGE_HEADER;
+
+typedef struct {
+	uint32_t error_code;
+	uint8_t attributes[0];
+} ISNSP_RESPONSE_HEADER, *PISNSP_RESPONSE_HEADER;
+
+
+// iSNS Message Flags Definitions
+
+#define ISNSP_CLIENT_SENDER         0x8000
+#define ISNSP_SERVER_SENDER         0x4000
+#define ISNSP_AUTH_BLOCK_PRESENT    0x2000
+#define ISNSP_REPLACE_FLAG          0x1000
+#define ISNSP_LAST_PDU              0x0800
+#define ISNSP_FIRST_PDU             0x0400
+
+#define ISNSP_VALID_FLAGS_MASK  (ISNSP_CLIENT_SENDER | \
+                                 ISNSP_SERVER_SENDER | \
+                                 ISNSP_AUTH_BLOCK_PRESENT | \
+                                 ISNSP_REPLACE_FLAG | \
+                                 ISNSP_LAST_PDU | \
+                                 ISNSP_FIRST_PDU)
+
+
+// iSNS Attribute Structure
+
+typedef struct {
+	uint32_t tag;
+	uint32_t length;
+	uint8_t value[0];     // Variable length data
+} ISNS_ATTRIBUTE, *PISNS_ATTRIBUTE;
+
+
+
+
+// The following macro assumes that the attribute is wholly contained within
+// the buffer in question and is valid (see VALIDATE_ATTR below).
+
+static inline PISNS_ATTRIBUTE
+NEXT_ATTR(PISNS_ATTRIBUTE pattr)
+{
+	return (PISNS_ATTRIBUTE) (&pattr->value[0] + be32_to_cpu(pattr->length));
+}
+
+static inline uint8_t
+VALIDATE_ATTR(PISNS_ATTRIBUTE PAttr, uint8_t *buffer_end)
+{
+	// Ensure that the Length field of the current attribute is contained
+	// within the buffer before trying to read it, and then be sure that
+	// the entire attribute is contained within the buffer.
+
+	if ((((unsigned long)&PAttr->length + sizeof(PAttr->length)) <= (unsigned long)buffer_end) &&
+	    (unsigned long)NEXT_ATTR(PAttr) <= (unsigned long)buffer_end) {
+		return(1);
+	}
+
+	return(0);
+}
+
+
+// iSNS-defined Attribute Tags
+
+#define ISNS_ATTR_TAG_DELIMITER                     0
+#define ISNS_ATTR_TAG_ENTITY_IDENTIFIER             1
+#define ISNS_ATTR_TAG_ENTITY_PROTOCOL               2
+#define ISNS_ATTR_TAG_MGMT_IP_ADDRESS               3
+#define ISNS_ATTR_TAG_TIMESTAMP                     4
+#define ISNS_ATTR_TAG_PROTOCOL_VERSION_RANGE        5
+#define ISNS_ATTR_TAG_REGISTRATION_PERIOD           6
+#define ISNS_ATTR_TAG_ENTITY_INDEX                  7
+#define ISNS_ATTR_TAG_ENTITY_NEXT_INDEX             8
+#define ISNS_ATTR_TAG_ENTITY_ISAKMP_PHASE_1         11
+#define ISNS_ATTR_TAG_ENTITY_CERTIFICATE            12
+#define ISNS_ATTR_TAG_PORTAL_IP_ADDRESS             16
+#define ISNS_ATTR_TAG_PORTAL_PORT                   17
+#define ISNS_ATTR_TAG_PORTAL_SYMBOLIC_NAME          18
+#define ISNS_ATTR_TAG_ESI_INTERVAL                  19
+#define ISNS_ATTR_TAG_ESI_PORT                      20
+#define ISNS_ATTR_TAG_PORTAL_GROUP                  21
+#define ISNS_ATTR_TAG_PORTAL_INDEX                  22
+#define ISNS_ATTR_TAG_SCN_PORT                      23
+#define ISNS_ATTR_TAG_PORTAL_NEXT_INDEX             24
+#define ISNS_ATTR_TAG_PORTAL_SECURITY_BITMAP        27
+#define ISNS_ATTR_TAG_PORTAL_ISAKMP_PHASE_1         28
+#define ISNS_ATTR_TAG_PORTAL_ISAKMP_PHASE_2         29
+#define ISNS_ATTR_TAG_PORTAL_CERTIFICATE            31
+#define ISNS_ATTR_TAG_ISCSI_NAME                    32
+#define ISNS_ATTR_TAG_ISCSI_NODE_TYPE               33
+#define ISNS_ATTR_TAG_ISCSI_ALIAS                   34
+#define ISNS_ATTR_TAG_ISCSI_SCN_BITMAP              35
+#define ISNS_ATTR_TAG_ISCSI_NODE_INDEX              36
+#define ISNS_ATTR_TAG_WWNN_TOKEN                    37
+#define ISNS_ATTR_TAG_ISCSI_NODE_NEXT_INDEX         38
+#define ISNS_ATTR_TAG_ISCSI_AUTH_METHOD             42
+#define ISNS_ATTR_TAG_ISCSI_NODE_CERTIFICATE        43
+#define ISNS_ATTR_TAG_PG_TAG                        48
+#define ISNS_ATTR_TAG_PG_ISCSI_NAME                 49
+#define ISNS_ATTR_TAG_PG_PORTAL_IP_ADDRESS          50
+#define ISNS_ATTR_TAG_PG_PORTAL_PORT                51
+#define ISNS_ATTR_TAG_PG_INDEX                      52
+#define ISNS_ATTR_TAG_PG_NEXT_INDEX                 53
+#define ISNS_ATTR_TAG_FC_PORT_NAME_WWPN             64
+#define ISNS_ATTR_TAG_PORT_ID                       65
+#define ISNS_ATTR_TAG_FC_PORT_TYPE                  66
+#define ISNS_ATTR_TAG_SYMBOLIC_PORT_NAME            67
+#define ISNS_ATTR_TAG_FABRIC_PORT_NAME              68
+#define ISNS_ATTR_TAG_HARD_ADDRESS                  69
+#define ISNS_ATTR_TAG_PORT_IP_ADDRESS               70
+#define ISNS_ATTR_TAG_CLASS_OF_SERVICE              71
+#define ISNS_ATTR_TAG_FC4_TYPES                     72
+#define ISNS_ATTR_TAG_FC4_DESCRIPTOR                73
+#define ISNS_ATTR_TAG_FC4_FEATURES                  74
+#define ISNS_ATTR_TAG_IFCP_SCN_BITMAP               75
+#define ISNS_ATTR_TAG_PORT_ROLE                     76
+#define ISNS_ATTR_TAG_PERMANENT_PORT_NAME           77
+#define ISNS_ATTR_TAG_PORT_CERTIFICATE              83
+#define ISNS_ATTR_TAG_FC4_TYPE_CODE                 95
+#define ISNS_ATTR_TAG_FC_NODE_NAME_WWNN             96
+#define ISNS_ATTR_TAG_SYMBOLIC_NODE_NAME            97
+#define ISNS_ATTR_TAG_NODE_IP_ADDRESS               98
+#define ISNS_ATTR_TAG_NODE_IPA                      99
+#define ISNS_ATTR_TAG_NODE_CERTIFICATE              100
+#define ISNS_ATTR_TAG_PROXY_ISCSI_NAME              101
+#define ISNS_ATTR_TAG_SWITCH_NAME                   128
+#define ISNS_ATTR_TAG_PREFERRED_ID                  129
+#define ISNS_ATTR_TAG_ASSIGNED_ID                   130
+#define ISNS_ATTR_TAG_VIRTUAL_FABRIC_ID             131
+#define ISNS_ATTR_TAG_VENDOR_OUI                    256
+//Vendor-specific iSNS Server                       257-384
+//Vendor-specific Entity                            385-512
+//Vendor-specific Portal                            513-640
+//Vendor-specific iSCSI Node                        641-768
+//Vendor-specific FC Port Name                      769-896
+//Vendor-specific FC Node Name                      897-1024
+//Vendor-specific DDS                               1025-1280
+//Vendor-Specific DD                                1281-1536
+//Vendor-specific (other)                           1237-2048
+#define ISNS_ATTR_TAG_DD_SET_ID                     2049
+#define ISNS_ATTR_TAG_DD_SET_SYMBOLIC_NAME          2050
+#define ISNS_ATTR_TAG_DD_SET_STATUS                 2051
+#define ISNS_ATTR_TAG_DD_SET_NEXT_ID                2052
+#define ISNS_ATTR_TAG_DD_ID                         2065
+#define ISNS_ATTR_TAG_DD_SYMBOLIC_NAME              2066
+#define ISNS_ATTR_TAG_DD_MEMBER_ISCSI_INDEX         2067
+#define ISNS_ATTR_TAG_DD_MEMBER_ISCSI_NAME          2068
+#define ISNS_ATTR_TAG_DD_MEMBER_IFCP_NODE           2069
+#define ISNS_ATTR_TAG_DD_MEMBER_PORTAL_INDEX        2070
+#define ISNS_ATTR_TAG_DD_MEMBER_PORTAL_IP_ADDRESS   2071
+#define ISNS_ATTR_TAG_DD_MEMBER_PORTAL_PORT         2072
+#define ISNS_ATTR_TAG_DD_FEATURES                   2078
+#define ISNS_ATTR_TAG_DD_ID_NEXT_ID                 2079
+
+
+// Definitions used for Entity Protocol
+
+#define ENTITY_PROTOCOL_NEUTRAL                 1
+#define ENTITY_PROTOCOL_ISCSI                   2
+#define ENTITY_PROTOCOL_IFCP                    3
+
+
+// Definitions used for iSCSI Node Type
+
+#define ISCSI_NODE_TYPE_TARGET                  0x00000001
+#define ISCSI_NODE_TYPE_INITIATOR               0x00000002
+#define ISCSI_NODE_TYPE_CONTROL                 0x00000004
+
+
+// Definitions used for iSCSI Node SCN Bitmap
+
+#define ISCSI_SCN_DD_DDS_MEMBER_ADDED           0x00000001  // Management SCN only
+#define ISCSI_SCN_DD_DDS_MEMBER_REMOVED         0x00000002  // Management SCN only
+#define ISCSI_SCN_OBJECT_UPDATED                0x00000004
+#define ISCSI_SCN_OBJECT_ADDED                  0x00000008
+#define ISCSI_SCN_OBJECT_REMOVED                0x00000010
+#define ISCSI_SCN_MANAGEMENT_SCN                0x00000020
+#define ISCSI_SCN_TARGET_AND_SELF_INFO_ONLY     0x00000040
+#define ISCSI_SCN_INITIATOR_AND_SELF_INFO_ONLY  0x00000080
+
+#define ISCSI_SCN_OBJECT_MASK                   (ISCSI_SCN_OBJECT_UPDATED |     \
+                                                 ISCSI_SCN_OBJECT_ADDED |       \
+                                                 ISCSI_SCN_OBJECT_REMOVED)
+
+
+// Definitions used for iSCSI Security Bitmap
+
+#define ISNS_SECURITY_BITMAP_VALID              0x00000001
+#define ISNS_SECURITY_IKE_IPSEC_ENABLED         0x00000002
+#define ISNS_SECURITY_MAIN_MODE_ENABLED         0x00000004
+#define ISNS_SECURITY_AGGRESSIVE_MODE_ENABLED   0x00000008
+#define ISNS_SECURITY_PFS_ENABLED               0x00000010
+#define ISNS_SECURITY_TRANSPORT_MODE_PREFERRED  0x00000020
+#define ISNS_SECURITY_TUNNEL_MODE_PREFERRED     0x00000040
+
+
+// Definitions used for Portal Port
+
+#define PORTAL_PORT_NUMBER_MASK                 0x0000FFFF
+#define PORTAL_PORT_TYPE_UDP                    0x00010000
diff --git a/drivers/scsi/qla4xxx/ql4_isr.c b/drivers/scsi/qla4xxx/ql4_isr.c
new file mode 100644
index 0000000..7e28f3c
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_isr.c
@@ -0,0 +1,1409 @@
+/******************************************************************************
+ *     Copyright (C)  2003 -2005 QLogic Corporation
+ * QLogic ISP4xxx Device Driver
+ *
+ * This program includes a device driver for Linux 2.6.x that may be
+ * distributed with QLogic hardware specific firmware binary file.
+ * You may modify and redistribute the device driver code under the
+ * GNU General Public License as published by the Free Software Foundation
+ * (version 2 or a later version) and/or under the following terms,
+ * as applicable:
+ *
+ * 	1. Redistribution of source code must retain the above copyright
+ *         notice, this list of conditions and the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above copyright
+ *         notice, this list of conditions and the following disclaimer in
+ *         the documentation and/or other materials provided with the
+ *         distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ * 	
+ * You may redistribute the hardware specific firmware binary file under
+ * the following terms:
+ * 	1. Redistribution of source code (only if applicable), must
+ *         retain the above copyright notice, this list of conditions and
+ *         the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above
+ *         copyright notice, this list of conditions and the following
+ *         disclaimer in the documentation and/or other materials provided
+ *         with the distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ *
+ * REGARDLESS OF WHAT LICENSING MECHANISM IS USED OR APPLICABLE,
+ * THIS PROGRAM IS PROVIDED BY QLOGIC CORPORATION "AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * USER ACKNOWLEDGES AND AGREES THAT USE OF THIS PROGRAM WILL NOT CREATE
+ * OR GIVE GROUNDS FOR A LICENSE BY IMPLICATION, ESTOPPEL, OR OTHERWISE
+ * IN ANY INTELLECTUAL PROPERTY RIGHTS (PATENT, COPYRIGHT, TRADE SECRET,
+ * MASK WORK, OR OTHER PROPRIETARY RIGHT) EMBODIED IN ANY OTHER QLOGIC
+ * HARDWARE OR SOFTWARE EITHER SOLELY OR IN COMBINATION WITH THIS PROGRAM
+ *
+ ******************************************************************************
+ *             Please see release.txt for revision history.                   *
+ *                                                                            *
+ ******************************************************************************
+ * Function Table of Contents:
+ *      qla4xxx_suspend_lun
+ *      qla4xxx_status_entry
+ *      qla4xxx_process_response_queue
+ *	qla4xxx_isr_decode_mailbox
+ *      qla4xxx_interrupt_service_routine
+ *      qla4xxx_intr_handler
+ *	qla4xxx_ok2relogin
+ *	qla4xxx_process_aen
+ ****************************************************************************/
+
+#include "ql4_def.h"
+
+static void
+qla4xxx_process_completed_request(struct scsi_qla_host *ha, uint32_t index);
+
+/*
+ * String messages for various state values (used for print statements)
+ *---------------------------------------------------------------------------*/
+const char *host_sts_msg[] = HOST_STS_TBL();
+
+
+/**************************************************************************
+ * qla4xxx_suspend_lun
+ *	This routine suspends the lun queue for the specified lun and places
+ *	all requests for this lun onto the retry queue for a specified
+ *	amount of time.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	srb - Pointer to SCSI Request Block
+ *	lun_entry - lun structure
+ *	time - Number of seconds to suspend queue
+ *	retries - Max retry count for this lun
+ *  	delay = non-zero, if lun should be delayed rather than suspended
+ *
+ * Remarks:
+ *	The suspend queue algorithm is provided as a method to keep commands
+ *	within the driver while a device is attempting to recover from certain
+ *	failures.  By keeping the commands within the driver, it prevents the
+ *	kernel's retries from being exhausted so quickly and minimizes failures
+ *	at the application level.
+ *
+ * Returns:
+ *	None
+ *
+ * Context:
+ *	Interrupt context.
+ **************************************************************************/
+void
+__qla4xxx_suspend_lun(scsi_qla_host_t *ha,
+		    srb_t *srb,
+		    os_lun_t *lun_entry,
+		    uint16_t time,
+		    uint16_t retries, int delay)
+{
+	unsigned long flags;
+	uint8_t status = 0 ;
+
+	if (lun_entry == NULL)
+		return;
+
+	spin_lock_irqsave(&lun_entry->lun_lock, flags);
+
+	if (lun_entry->lun_state == LS_LUN_READY ||
+	    lun_entry->lun_state == LS_LUN_RETRY) {
+		if (lun_entry->lun_state == LS_LUN_READY) {
+			lun_entry->max_retry_count = retries;
+			lun_entry->retry_count = 0;
+		}
+
+		/* Set the suspend time */
+		atomic_set(&lun_entry->suspend_timer, time);
+		DEBUG2( printk("scsi%d: %s lun %d retry count = %d\n",
+				ha->host_no, __func__, lun_entry->lun,
+				lun_entry->retry_count));
+
+		/* now suspend the lun */
+		lun_entry->lun_state = LS_LUN_SUSPENDED;
+		lun_entry->fclun->fcport->vis_ha = ha;
+		if (delay) {
+			set_bit(LF_LUN_DELAYED, &lun_entry->flags);
+		}
+		status = 1;
+
+	}
+	spin_unlock_irqrestore(&lun_entry->lun_lock, flags);
+
+#if 0
+	if (status) {
+		spin_lock_irqsave(&ha->list_lock, flags);
+		list_for_each_entry_safe(sp, stemp, &ha->pending_srb_q,
+		    list_entry) {
+			if (sp->lun_queue != lun_entry)
+				continue;
+
+			__del_from_pending_srb_q(ha, sp);
+
+			if (retries > sp->cmd->allowed)
+				sp->cmd->allowed = retries;
+			__add_to_retry_srb_q(ha,sp);
+
+		}
+		spin_unlock_irqrestore(&ha->list_lock, flags);
+	}
+#endif
+	if( srb )
+		add_to_retry_srb_q(ha,srb);
+
+}
+
+/**************************************************************************
+ * qla4xxx_check_and_copy_sense
+ *	This routine processes Status IOCBs
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *      sts_entry - Pointer to status entry structure
+ *	srb - Pointer to internal SCSI request block structure.
+ *
+ * Returns:
+ *	QLA_SUCCESS - We want the caller to complete the command
+ *	QLA_ERROR - We do not want the caller to complete the request
+ *
+ * Context:
+ *	Interrupt context.
+ **************************************************************************/
+static uint8_t
+qla4xxx_check_and_copy_sense(scsi_qla_host_t *ha, STATUS_ENTRY *sts_entry, srb_t *srb)
+{
+	struct scsi_cmnd *cmd = srb->cmd;
+	scsi_qla_host_t *osha;
+	uint16_t        sensebytecnt;
+	fc_port_t *fcport;
+	os_lun_t *lun_entry = srb->lun_queue;
+	osha = (scsi_qla_host_t *) cmd->device->host->hostdata;
+
+	memset(cmd->sense_buffer, 0, sizeof(cmd->sense_buffer));
+
+	sensebytecnt = le16_to_cpu(sts_entry->senseDataByteCnt);
+	if (sensebytecnt == 0)
+		return(QLA_SUCCESS);
+
+	/* always perform the copy to cmd fields */
+	CMD_ACTUAL_SNSLEN(cmd) = sensebytecnt;
+
+	memcpy(cmd->sense_buffer,
+	       sts_entry->senseData,
+	       MIN(sensebytecnt, sizeof(cmd->sense_buffer)));
+
+	if ((srb->flags & (SRB_IOCTL_CMD | SRB_TAPE)))
+		return(QLA_SUCCESS);
+
+	/* check for vaild sense data */
+	if ((sts_entry->senseData[0] & 0x70) != 0x70)
+		return(QLA_SUCCESS);
+
+	DEBUG2(printk("scsi%d:%d:%d:%d: %s: "
+			"sense key = "
+			"%x, ASC/ASCQ = %02x/%02x\n",
+			ha->host_no, cmd->device->channel,
+			cmd->device->id, cmd->device->lun, __func__,
+			sts_entry->senseData[2] & 0x0f,
+			sts_entry->senseData[12],
+			sts_entry->senseData[13]));
+
+	srb->flags |= SRB_GOT_SENSE;
+
+	switch (sts_entry->senseData[2] & 0x0f) {
+	case RECOVERED_ERROR:
+		cmd->result = DID_OK << 16;
+		cmd->sense_buffer[0] = 0;
+		break;
+
+	case NOT_READY:
+	case HARDWARE_ERROR:
+		fcport = lun_entry->fclun->fcport;
+
+		/*
+		 * Suspend the lun only for hard disk device type.
+		 */
+		if (test_bit(AF_INIT_DONE, &ha->flags) &&
+		    lun_entry != NULL &&
+		    (fcport->flags & FCF_TAPE_PRESENT) == 0 &&
+		    lun_entry->lun_state != LS_LUN_TIMEOUT) {
+			/*
+			 * If target is in process of being ready then suspend
+			 * lun for 6 secs and retry all the commands.
+			 */
+			if (sts_entry->senseData[12] == 0x4 &&
+			    sts_entry->senseData[13] == 0x1) {
+				/* To give the lun more time to become ready,
+				 * suspend lun then retry command */
+				qla4xxx_suspend_lun(osha, srb, lun_entry,
+						    SUSPEND_SECONDS,
+						    SUSPEND_RETRIES);
+				return(QLA_ERROR);
+			}
+			else if (sts_entry->senseData[12] == 0x8 &&
+				 sts_entry->senseData[13] == 0x0) {
+				/* To give the lun more time to become ready,
+				 * suspend lun then retry command */
+				qla4xxx_suspend_lun(osha, srb, lun_entry,
+						    SUSPEND_SECONDS,
+						    (ha->port_down_retry_count /
+						     SUSPEND_SECONDS)) ;
+				return(QLA_ERROR);
+			}
+		}
+		break;
+	}
+
+	return(QLA_SUCCESS);
+}
+
+
+/**************************************************************************
+ * qla4xxx_status_entry
+ *	This routine processes Status IOCBs
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *      sts_entry - Pointer to status entry structure.
+ *
+ * Returns:
+ *	None
+ *
+ * Context:
+ *	Interrupt context.
+ **************************************************************************/
+static void
+qla4xxx_status_entry(scsi_qla_host_t *ha, STATUS_ENTRY *sts_entry)
+{
+	srb_t *srb;
+	uint8_t scsi_status;
+
+	ENTER("qla4xxx_status_entry");
+
+	/* Fast path completion. */
+	if (sts_entry->completionStatus == SCS_COMPLETE &&
+	    sts_entry->scsiStatus == 0) {
+		qla4xxx_process_completed_request(ha,
+		    le32_to_cpu(sts_entry->handle));
+		return;
+	}
+
+	srb = del_from_active_array(ha, le32_to_cpu(sts_entry->handle));
+	if (srb) {
+		struct scsi_cmnd *cmd = srb->cmd;
+		uint32_t residual = le32_to_cpu(sts_entry->residualByteCnt);
+		ddb_entry_t *ddb_entry = srb->fclun->fcport->ddbptr;
+
+		if (cmd == NULL) {
+			DEBUG2(printk("scsi%d: %s: Command already returned back to OS "
+				      "pkt->handle=%d srb=%p srb->state:%d\n",
+				      ha->host_no, __func__, sts_entry->handle, srb, srb->state));
+			printk(KERN_WARNING
+			       "Command is NULL: already returned to OS (srb=%p)\n", srb);
+
+			return;
+		}
+
+		if (srb->lun_queue == NULL) {
+			DEBUG2(printk("scsi%d: %s: Status Entry invalid lun pointer.\n",
+				      ha->host_no, __func__));
+			/* FIXMEdg: Don't we need to reset ISP in this case??? */
+		}
+
+		if (ddb_entry == NULL) {
+			cmd->result = DID_NO_CONNECT << 16;
+			goto status_entry_exit;
+		}
+		/*
+		 * Translate ISP error to a Linux SCSI error
+		 */
+		scsi_status = sts_entry->scsiStatus;
+
+		switch (sts_entry->completionStatus) {
+		case SCS_COMPLETE:
+
+			if (scsi_status == 0) {
+				cmd->result = DID_OK << 16;
+				break;
+			}
+
+			if (sts_entry->iscsiFlags &
+			    (ISCSI_FLAG_RESIDUAL_OVER |
+			     ISCSI_FLAG_RESIDUAL_UNDER)) {
+				cmd->resid = residual;
+			}
+
+			if (scsi_status == SCSISTAT_BUSY) {
+				cmd->result = DID_BUS_BUSY << 16 | scsi_status;
+				break;
+			}
+
+			if (scsi_status != SCSISTAT_CHECK_CONDITION)
+				break;
+
+			/* Check for sense errors */
+			if (qla4xxx_check_and_copy_sense(ha, sts_entry ,srb) == QLA_ERROR) {
+				LEAVE("qla4xxx_status_entry");
+				return;	 /* DO NOT complete request */
+			}
+
+			break;
+
+		case SCS_INCOMPLETE:
+			/* Always set the status to DID_ERROR, since
+			 * all conditions result in that status anyway */
+			cmd->result = DID_ERROR << 16;
+			break;
+
+		case SCS_RESET_OCCURRED:
+			DEBUG2(printk("scsi%d:%d:%d:%d: %s: "
+						   "Device RESET occurred\n",
+						   ha->host_no,
+						   cmd->device->channel,
+						   cmd->device->id,
+						   cmd->device->lun,
+						   __func__));
+
+			if (srb->flags & (SRB_IOCTL_CMD | SRB_TAPE)) {
+				cmd->result = DID_RESET << 16;
+			}
+			else {
+				qla4xxx_device_suspend(ha, srb->lun_queue, srb);
+				return;
+			}
+
+			break;
+
+		case SCS_ABORTED:
+			QL4PRINT(QLP2|QLP3, printk("scsi%d:%d:%d:%d: %s: "
+						   "Abort occurred\n",
+						   ha->host_no,
+						   cmd->device->channel,
+						   cmd->device->id,
+						   cmd->device->lun,
+						   __func__));
+
+			cmd->result = DID_ABORT << 16;
+			// ha->aborted_io_count++;
+			break;
+
+		case SCS_TIMEOUT:
+			QL4PRINT(QLP2, printk("scsi%d:%d:%d:%d: cmd=%p "
+					      "Timeout\n",
+					      ha->host_no, cmd->device->channel,
+					      cmd->device->id,
+					      cmd->device->lun, cmd));
+
+			/* F/W logout the connection when this occurs */
+			cmd->result = DID_BUS_BUSY << 16;
+
+			/*
+			 * Mark device missing so that we won't continue to send
+			 * I/O to this device.  We should get a ddb state change
+			 * AEN soon.
+			 */
+			if ((atomic_read(&ddb_entry->state) == DEV_STATE_ONLINE))
+				qla4xxx_mark_device_missing(ha, ddb_entry);
+			break;
+
+		case SCS_DATA_UNDERRUN:
+		case SCS_DATA_OVERRUN:
+			if ((sts_entry->iscsiFlags & ISCSI_FLAG_RESIDUAL_OVER) != 0) {
+				QL4PRINT(QLP2,
+					 printk("scsi%d:%d:%d:%d: %s: "
+						"Data overrun, "
+						"residual = 0x%x\n",
+						ha->host_no,
+						cmd->device->channel,
+						cmd->device->id,
+						cmd->device->lun,
+						__func__, residual));
+
+				QL4PRINT(QLP10,
+					 printk("scsi%d: %s: "
+						"response packet data\n",
+						ha->host_no, __func__));
+				qla4xxx_dump_bytes(QLP10, sts_entry,
+						   (sizeof(*sts_entry) *
+						    sts_entry->hdr.entryCount));
+
+				cmd->result = DID_ERROR << 16;
+				break;
+			}
+
+
+			if ((sts_entry->iscsiFlags & ISCSI_FLAG_RESIDUAL_UNDER) == 0) {
+				/*
+				 * Firmware detected a SCSI transport underrun condition
+				 */
+				cmd->resid = residual;
+				QL4PRINT(QLP2,
+					 printk("scsi%d:%d:%d:%d: %s: "
+						"UNDERRUN status detected, "
+						"xferlen = 0x%x, "
+						"residual = 0x%x\n",
+						ha->host_no,
+						cmd->device->channel,
+						cmd->device->id,
+						cmd->device->lun,
+						__func__, cmd->request_bufflen,
+						residual));
+			}
+
+			/*
+			 * If there is scsi_status, it takes precedense over
+			 * underflow condition.
+			 */
+			if (scsi_status != 0) {
+				if (scsi_status == SCSISTAT_BUSY) {
+					cmd->result = DID_BUS_BUSY << 16 | scsi_status;
+					break;
+				}
+				cmd->result = DID_OK << 16 | scsi_status;
+
+				if (scsi_status != SCSISTAT_CHECK_CONDITION)
+					break;
+
+				/* Check for sense errors */
+				if (qla4xxx_check_and_copy_sense(ha, sts_entry ,srb) == QLA_ERROR) {
+					LEAVE("qla4xxx_status_entry");
+					return;	 /* DO NOT complete request */
+				}
+			}
+			else {
+				/*
+				 * If RISC reports underrun and target does not
+				 * report it then we must have a lost frame, so
+				 * tell upper layer to retry it by reporting a
+				 * bus busy.
+				 */
+				if ((sts_entry->iscsiFlags & ISCSI_FLAG_RESIDUAL_UNDER) == 0) {
+					QL4PRINT(QLP2,
+						 printk("scsi%d:%d:%d:%d: "
+							"%s: Dropped frame(s) "
+							"detected (%x of %x bytes)..."
+							" retrying command.\n",
+							ha->host_no,
+							cmd->device->channel,
+							cmd->device->id,
+							cmd->device->lun,
+							__func__,
+							residual,
+							cmd->request_bufflen));
+
+					cmd->result = DID_BUS_BUSY << 16;
+				}
+				else if ((cmd->request_bufflen - residual) < cmd->underflow) {
+					/*
+					 * Handle mid-layer underflow???
+					 *
+					 * For kernels less than 2.4, the driver must
+					 * return an error if an underflow is detected.
+					 * For kernels equal-to and above 2.4, the
+					 * mid-layer will appearantly handle the
+					 * underflow by detecting the residual count --
+					 * unfortunately, we do not see where this is
+					 * actually being done.  In the interim, we
+					 * will return DID_ERROR.
+					 */
+					QL4PRINT(QLP2,
+						 printk("scsi%d:%d:%d:%d: %s: "
+							"Mid-layer Data underrun, "
+							"xferlen = 0x%x, "
+							"residual = 0x%x\n",
+							ha->host_no,
+							cmd->device->channel,
+							cmd->device->id,
+							cmd->device->lun,
+							__func__, cmd->request_bufflen,
+							residual));
+
+					cmd->result = DID_ERROR << 16;
+					CMD_RESID_LEN(cmd) = residual;
+				}
+				else {
+					cmd->result = DID_OK << 16;
+				}
+			}
+			break;
+
+		case SCS_DEVICE_LOGGED_OUT:
+		case SCS_DEVICE_UNAVAILABLE:
+			QL4PRINT(QLP2, printk("scsi%d:%d:%d:%d: cmd=%p %s,  req_q_cnt=%d, num_entries=%d\n",
+					      ha->host_no, cmd->device->channel,
+					      cmd->device->id,
+					      cmd->device->lun,	cmd,
+					      (sts_entry->completionStatus == SCS_DEVICE_LOGGED_OUT)?
+					      "DEVICE_LOGGED_OUT": "DEVICE_UNAVAILABLE",
+				ha->req_q_count, srb->entry_count));
+			/*
+			 * Mark device missing so that we won't continue to
+			 * send I/O to this device.  We should get a ddb
+			 * state change AEN soon.
+			 */
+
+			if ((atomic_read(&ddb_entry->state) ==
+			    	DEV_STATE_ONLINE))
+				qla4xxx_mark_device_missing(ha, ddb_entry);
+
+			if ((srb->flags & (SRB_IOCTL_CMD | SRB_TAPE)) ||
+			    (atomic_read(&ddb_entry->fcport->state)
+			     == FCS_DEVICE_DEAD)) {
+				cmd->result = DID_NO_CONNECT << 16;
+			}
+			else {
+				cmd->result = DID_ERROR << 16;
+				qla4xxx_extend_timeout(cmd, EXTEND_CMD_TOV);
+				add_to_retry_srb_q(ha, srb);
+				return;	 /* DO NOT complete request */
+			}
+
+			break;
+
+		case SCS_QUEUE_FULL:
+			/*
+			 * SCSI Mid-Layer handles device queue full
+			 */
+			cmd->result = DID_OK << 16 | sts_entry->scsiStatus;
+			DEBUG2( printk("scsi%d:%d:%d: %s: QUEUE FULL detected "
+					"compl=%02x, scsi=%02x, state=%02x, "
+					"iFlags=%02x, iResp=%02x\n",
+					ha->host_no, cmd->device->id,
+					cmd->device->lun,
+					__func__, sts_entry->completionStatus,
+					sts_entry->scsiStatus,
+					sts_entry->state_flags,
+					sts_entry->iscsiFlags,
+					sts_entry->iscsiResponse));
+			break;
+
+		case SCS_DMA_ERROR:
+		case SCS_TRANSPORT_ERROR:
+		case SCS_DATA_DIRECTION_ERROR:
+		case SCS_DEVICE_CONFIG_CHANGED:
+		default:
+			cmd->result = DID_ERROR << 16;
+			break;
+		}
+
+		status_entry_exit:
+
+
+		/* fill in info for passthru command */
+		CMD_SCSI_STATUS(cmd)    = sts_entry->scsiStatus;
+
+		if (srb->flags & (SRB_IOCTL_CMD | SRB_TAPE)) {
+			CMD_COMPL_STATUS(cmd)   = sts_entry->completionStatus;
+			CMD_ISCSI_RESPONSE(cmd) = sts_entry->iscsiResponse;
+			CMD_STATE_FLAGS(cmd)    = sts_entry->state_flags;
+			CMD_HOST_STATUS(cmd)    = host_byte(cmd->result);
+		}
+
+		/* complete the request */
+		srb->cc_stat   = sts_entry->completionStatus;
+		if (host_byte(cmd->result) == DID_RESET ||
+	    	    host_byte(cmd->result) == DID_BUS_BUSY ||
+	    	    host_byte(cmd->result) == DID_ABORT ||
+	    	    host_byte(cmd->result) == DID_ERROR) {
+			    DEBUG2(printk("scsi%d:%d:%d:%d: %s: "
+				"did_error=%d,  comp-scsi=0x%x-0x%x, "
+				"pid=%ld\n",
+				ha->host_no, cmd->device->channel, cmd->device->id,
+				cmd->device->lun,
+				__func__,
+				host_byte(cmd->result),
+				sts_entry->completionStatus,
+				sts_entry->scsiStatus,
+    				cmd->serial_number));
+		}
+
+
+		add_to_done_srb_q(ha, srb);
+	}
+	else {
+		/* FIXMEdg: Don't we need to reset ISP in this case??? */
+		DEBUG2(printk(KERN_WARNING "scsi%d: %s: Status Entry invalid "
+				"handle 0x%x, sp=%p. "
+				"This cmd may have already been completed.\n",
+				ha->host_no, __func__, le32_to_cpu(sts_entry->handle),
+				srb));
+
+		// QL4PRINT(QLP2, printk("scsi%d: %s: sts_entry 0x%p\n",
+				      // ha->host_no, __func__, sts_entry));
+		// qla4xxx_dump_bytes(QLP2, sts_entry, sizeof(*sts_entry));
+	}
+
+	LEAVE("qla4xxx_status_entry");
+}
+
+/**
+ * qla2x00_process_completed_request() - Process a Fast Post response.
+ * @ha: SCSI driver HA context
+ * @index: SRB index
+ */
+static void
+qla4xxx_process_completed_request(struct scsi_qla_host *ha, uint32_t index)
+{
+	srb_t *srb;
+
+	srb = del_from_active_array(ha, index);
+
+	if (srb) {
+		CMD_COMPL_STATUS(srb->cmd) = 0L;
+		CMD_SCSI_STATUS(srb->cmd) = 0L;
+
+		/* Save ISP completion status */
+		srb->cmd->result = DID_OK << 16;
+		add_to_done_srb_q(ha, srb);
+	}
+	else {
+		DEBUG2(printk(
+		    "scsi%d: Invalid ISP SCSI completion handle = %d\n",
+		      ha->host_no, index));
+		set_bit(DPC_RESET_HA, &ha->dpc_flags);
+	}
+}
+
+/**************************************************************************
+ * qla4xxx_process_response_queue
+ *	This routine handles the Response Queue Completion.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Output:
+ *	None
+ *
+ * Remarks:
+ *	hardware_lock locked upon entry
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully processed response queue
+ *	QLA_ERROR   - Failed to process response queue
+ *
+ * Context:
+ *	Interrupt context.
+ **************************************************************************/
+static uint32_t
+qla4xxx_process_response_queue(scsi_qla_host_t *ha)
+{
+	uint32_t count = 0;
+	srb_t    *srb = 0;
+	STATUS_ENTRY *sts_entry;
+
+	ENTER("qla4xxx_process_response_queue");
+
+	/* Process all responses from response queue */
+	while ((ha->response_in = (uint16_t)
+	    le32_to_cpu(ha->shadow_regs->rsp_q_in)) != ha->response_out) {
+		sts_entry = (STATUS_ENTRY *) ha->response_ptr;
+		count++;
+
+		/* Advance pointers for next entry */
+		if (ha->response_out == (RESPONSE_QUEUE_DEPTH - 1)) {
+			ha->response_out = 0;
+			ha->response_ptr = ha->response_ring;
+		}
+		else {
+			ha->response_out++;
+			ha->response_ptr++;
+		}
+
+		/* process entry */
+		switch (sts_entry->hdr.entryType) {
+		case ET_STATUS:
+			/* Common status - Single completion posted in single
+			 * IOSB */
+			qla4xxx_status_entry(ha, sts_entry);
+			break;
+		case ET_PASSTHRU_STATUS:
+			qla4xxx_isns_process_response(ha,
+			    (PASSTHRU_STATUS_ENTRY *) sts_entry);
+			break;
+
+		case ET_STATUS_CONTINUATION:
+			/* Just throw away the status continuation entries */
+			QL4PRINT(QLP2,
+				 printk("scsi%d: %s: Status Continuation entry "
+					"- ignoring\n", ha->host_no, __func__));
+			break;
+
+		case ET_COMMAND:
+			/* ISP device queue is full. Command not accepted by
+			 * ISP.  Queue command for later */
+
+			srb = del_from_active_array(ha, le32_to_cpu(sts_entry->handle));
+			if (srb == NULL)
+				goto exit_prq_invalid_handle;
+
+			QL4PRINT(QLP2, printk("scsi%d: %s: FW device queue full, "
+					      "srb %p\n",
+					      ha->host_no, __func__, srb));
+
+			/* Let's RETRY normally by sending it back with DID_BUS_BUSY */
+			srb->cmd->result = DID_BUS_BUSY << 16;
+			sp_put(ha, srb);
+			break;
+
+		case ET_CONTINUE:
+			/* Just throw away the continuation entries */
+			QL4PRINT(QLP2, printk("scsi%d: %s: Continuation entry - "
+					      "ignoring\n",
+					      ha->host_no, __func__));
+			break;
+
+		default:
+			/* Invalid entry in response queue, reset RISC
+			 * firmware */
+			QL4PRINT(QLP2, printk("scsi%d: %s: Invalid entry %x "
+					      "in response queue \n",
+					      ha->host_no, __func__,
+					      sts_entry->hdr.entryType));
+
+			QL4PRINT(QLP10, printk("scsi%d: %s: Dumping Response Entry "
+					       "%p:%x out %x in%x\n",
+					       ha->host_no, __func__,
+					       sts_entry,
+					       le32_to_cpu(((QUEUE_ENTRY*)sts_entry)->
+							   signature),
+					       ha->response_out,
+					       ha->response_in));
+
+			qla4xxx_dump_bytes(QLP10, sts_entry,
+					   sizeof(*sts_entry));
+			goto exit_prq_error;
+		}
+	}
+
+	if (ha->response_out == ha->response_in) {
+		QL4PRINT(QLP5,
+			 printk("scsi%d: %s: Response count %x out %x "
+				"in %x, next %p:%x.  Finished!\n",
+				ha->host_no, __func__, count,
+				ha->response_out, ha->response_in,
+				ha->request_ptr,
+				ha->response_ptr->signature));
+	}
+
+	/* Done with responses, update the ISP
+	 * For QLA4010, this also clears the interrupt.
+	 */
+	WRT_REG_DWORD(&ha->reg->rsp_q_out, ha->response_out);
+	PCI_POSTING(&ha->reg->rsp_q_out);
+
+	LEAVE("qla4xxx_process_response_queue");
+	return(QLA_SUCCESS);
+
+	exit_prq_invalid_handle:
+	DEBUG2(printk("scsi%d: %s: Invalid handle(srb)=%p type=%x "
+			      "IOCS=%x\n", ha->host_no, __func__,
+			      srb, sts_entry->hdr.entryType,
+			      sts_entry->completionStatus));
+
+	exit_prq_error:
+	WRT_REG_DWORD(&ha->reg->rsp_q_out, ha->response_out);
+	PCI_POSTING(&ha->reg->rsp_q_out);
+
+	set_bit(DPC_RESET_HA, &ha->dpc_flags);
+
+	LEAVE("qla4xxx_process_response_queue");
+	return(QLA_ERROR);
+}
+
+/**************************************************************************
+ * qla4xxx_isr_decode_mailbox
+ *	This routine decodes the mailbox status during the ISR.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	mailbox_status - Mailbox status.
+ *
+ * Remarks:
+ *      hardware_lock locked upon entry
+ *
+ * Returns:
+ *	None.
+ *
+ * Context:
+ *	Interrupt context.
+ **************************************************************************/
+static void
+qla4xxx_isr_decode_mailbox(scsi_qla_host_t *ha, uint32_t  mbox_status)
+{
+	/* used for MBOX_ASTS_ISNS_UNSOLICITED_PDU_RECEIVED */
+	static uint32_t   mbox_sts[MBOX_REG_COUNT];
+
+	if ((mbox_status == MBOX_STS_BUSY) ||
+	    (mbox_status == MBOX_STS_INTERMEDIATE_COMPLETION) ||
+	    (mbox_status >>12 == MBOX_COMPLETION_STATUS)) {
+		ha->mbox_status[0] = mbox_status;
+
+		if (test_bit(AF_MBOX_COMMAND, &ha->flags)) {
+			/*
+			 * Copy all mailbox registers to a temporary
+			 * location and set mailbox command done flag
+			 */
+			uint8_t i;
+
+			for (i = 1; i < ha->mbox_status_count; i++) {
+				ha->mbox_status[i] =
+				    RD_REG_DWORD(&ha->reg->mailbox[i]);
+			}
+
+			QL4PRINT(QLP11,
+				 printk("scsi%d: %s: mailbox cmd done!\n",
+					ha->host_no, __func__));
+
+			ha->f_end = jiffies;
+			set_bit(AF_MBOX_COMMAND_DONE, &ha->flags);
+			wake_up(&ha->mailbox_wait_queue);
+		}
+		#if 0
+		else {
+			QL4PRINT(QLP2,
+				 printk("scsi%d: ERROR: Receiving mailbox "
+					"status %08X when no mailbox command "
+					"active.\n",
+					ha->host_no, mbox_status));
+
+			__dump_registers(ha);
+		}
+		#endif
+	}
+	else if (mbox_status >> 12 == MBOX_ASYNC_EVENT_STATUS) {
+		/*
+		 * Only capture DATABASE_CHANGED AENs, as they need
+		 * to be processed in the DPC
+		 * ------------------------------------------------------*/
+		if (mbox_status == MBOX_ASTS_DATABASE_CHANGED) {
+			int i;
+
+			ha->aen_count++;
+			if (ha->aen_count == 0) {
+				/* We overflowed the counter */
+				ha->aen_report = 0;
+			}
+
+			if (ha->aen_count - ha->aen_report == MAX_AEN_ENTRIES) {
+				/* We wrapped the queue,
+				 * update starting point for SDMAPI copy */
+				ha->aen_report++;
+			}
+
+			if (ha->aen_in == (MAX_AEN_ENTRIES - 1))
+				ha->aen_in = 0;
+			else
+				ha->aen_in++;
+
+			for (i = 1; i < MBOX_AEN_REG_COUNT; i++) {
+				ha->aen_q[ha->aen_in].mbox_sts[i] =
+				    RD_REG_DWORD(&ha->reg->mailbox[i]);
+			}
+			ha->aen_q[ha->aen_in].mbox_sts[0] = mbox_status;
+		}
+
+
+		/*
+		 * Immediately process the non database_changed AENs.
+		 * The database_changed AENs will get processed in the DPC.
+		 * --------------------------------------------------------*/
+		switch (mbox_status) {
+		case MBOX_ASTS_SYSTEM_ERROR:
+			/* Log Mailbox registers */
+			QL4PRINT(QLP2,
+				 printk(
+					"scsi%d: AEN %04x, System Error, "
+					"Dump Mailboxes\n",
+					ha->host_no, mbox_status));
+			__dump_mailbox_registers(QLP2, ha);
+			if(ql4xdontresethba) {
+				DEBUG2(printk("%s:Dont Reset HBA\n",__func__);)
+			} else {
+				set_bit(AF_GET_CRASH_RECORD, &ha->flags);
+				set_bit(DPC_RESET_HA, &ha->dpc_flags);
+			}
+			break;
+
+		case MBOX_ASTS_REQUEST_TRANSFER_ERROR:
+		case MBOX_ASTS_RESPONSE_TRANSFER_ERROR:
+		case MBOX_ASTS_NVRAM_INVALID:
+		case MBOX_ASTS_IP_ADDRESS_CHANGED:
+		case MBOX_ASTS_DHCP_LEASE_EXPIRED:
+			QL4PRINT(QLP2,
+				 printk("scsi%d: AEN %04x, "
+					"ERROR Status, Reset HA\n",
+					ha->host_no, mbox_status));
+
+			set_bit(DPC_RESET_HA, &ha->dpc_flags);
+			break;
+
+		case MBOX_ASTS_LINK_UP:
+			QL4PRINT(QLP2,
+				 printk("scsi%d: AEN %04x "
+					"Adapter LINK UP\n",
+					ha->host_no, mbox_status));
+			set_bit(AF_LINK_UP, &ha->flags);
+			break;
+
+		case MBOX_ASTS_LINK_DOWN:
+			QL4PRINT(QLP2,
+				 printk("scsi%d: AEN %04x "
+					"Adapter LINK DOWN\n",
+					ha->host_no, mbox_status));
+			clear_bit(AF_LINK_UP, &ha->flags);
+			break;
+
+		case MBOX_ASTS_HEARTBEAT:
+			QL4PRINT(QLP7,
+				 printk("scsi%d: AEN %04x "
+					"HEARTBEAT\n",
+					ha->host_no, mbox_status));
+			ha->seconds_since_last_heartbeat = 0;
+			break;
+
+		case MBOX_ASTS_DHCP_LEASE_ACQUIRED:
+			QL4PRINT(QLP2, printk("scsi%d: AEN %04x DHCP LEASE ACQUIRED\n",
+					      ha->host_no, mbox_status));
+			set_bit(DPC_GET_DHCP_IP_ADDR, &ha->dpc_flags);
+			break;
+
+		case MBOX_ASTS_PROTOCOL_STATISTIC_ALARM:
+		case MBOX_ASTS_SCSI_COMMAND_PDU_REJECTED:	  /* Target mode only */
+		case MBOX_ASTS_UNSOLICITED_PDU_RECEIVED:	  /* connection mode only */
+		case MBOX_ASTS_IPSEC_SYSTEM_FATAL_ERROR:
+		case MBOX_ASTS_SUBNET_STATE_CHANGE:
+			/* No action */
+			QL4PRINT(QLP2, printk("scsi%d: AEN %04x\n",
+					      ha->host_no, mbox_status));
+			break;
+
+		case MBOX_ASTS_MAC_ADDRESS_CHANGED:
+		case MBOX_ASTS_DNS:
+			/* No action */
+			QL4PRINT(QLP2,
+				 printk("scsi%d: AEN %04x, "
+					"mbox_sts[1]=%04x, "
+					"mbox_sts[2]=%04x\n",
+					ha->host_no, mbox_status,
+					RD_REG_DWORD(&ha->reg->mailbox[1]),
+					RD_REG_DWORD(&ha->reg->mailbox[2])));
+			break;
+
+		case MBOX_ASTS_SELF_TEST_FAILED:
+		case MBOX_ASTS_LOGIN_FAILED:
+			/* No action */
+			QL4PRINT(QLP2,
+				 printk("scsi%d: AEN %04x, "
+					"mbox_sts[1]=%04x, "
+					"mbox_sts[2]=%04x, mbox_sts[3]=%04x\n",
+					ha->host_no, mbox_status,
+					RD_REG_DWORD(&ha->reg->mailbox[1]),
+					RD_REG_DWORD(&ha->reg->mailbox[2]),
+					RD_REG_DWORD(&ha->reg->mailbox[3])));
+			break;
+
+		case MBOX_ASTS_DATABASE_CHANGED:
+				DEBUG2( printk("scsi%d: AEN[%d] %04x queued"
+						" mb1:0x%x mb2:0x%x mb3:0x%x"
+						" mb4:0x%x\n",
+						ha->host_no, ha->aen_in,
+						mbox_status,
+					ha->aen_q[ha->aen_in].mbox_sts[1],
+					ha->aen_q[ha->aen_in].mbox_sts[2],
+					ha->aen_q[ha->aen_in].mbox_sts[3],
+					ha->aen_q[ha->aen_in].mbox_sts[4]);)
+
+				/* The DPC routine will process the aen */
+				set_bit(DPC_AEN, &ha->dpc_flags);
+			break;
+
+		case MBOX_ASTS_ISNS_UNSOLICITED_PDU_RECEIVED:
+			memset(&mbox_sts, 0, sizeof(mbox_sts));
+			mbox_sts[0] = mbox_status;
+			mbox_sts[1] = RD_REG_DWORD(&ha->reg->mailbox[1]);
+			mbox_sts[2] = RD_REG_DWORD(&ha->reg->mailbox[2]);
+			mbox_sts[3] = RD_REG_DWORD(&ha->reg->mailbox[3]);
+			mbox_sts[4] = RD_REG_DWORD(&ha->reg->mailbox[4]);
+			mbox_sts[5] = RD_REG_DWORD(&ha->reg->mailbox[5]);
+
+			if (mbox_sts[1] == ISNS_EVENT_DATA_RECEIVED) {
+				QL4PRINT(QLP2, printk("scsi%d: AEN %04x, mbox_sts[1]=%04x, "
+						      "mbox_sts[2]=%04x, mbox_sts[3]=%04x, mbox_sts[4]=%04x\n",
+						      ha->host_no, mbox_status, mbox_sts[1],
+						      mbox_sts[2], mbox_sts[3], mbox_sts[4]));
+
+				if (qla4xxx_isns_get_server_request(ha,
+								    mbox_sts[3],
+								    mbox_sts[2])
+				    != QLA_SUCCESS) {
+					QL4PRINT(QLP2,
+						 printk("scsi%d: %s: AEN %04x, "
+							"isns_get_server_request FAILED!!\n",
+							ha->host_no, __func__, mbox_status));
+				}
+			}
+			else if (mbox_sts[1] == ISNS_EVENT_CONNECTION_OPENED) {
+				QL4PRINT(QLP2, printk("scsi%d: AEN %04x, iSNS Service "
+						      "Connection Opened!\n"
+						      "mbox_sts[2]=%08x, mbox_sts[3]=%08x, "
+						      "mbox_sts[4]=%08x, mbox_sts[5]=%08x\n",
+						      ha->host_no, mbox_status, mbox_sts[2],
+						      mbox_sts[3], mbox_sts[4], mbox_sts[5]));
+
+				qla4xxx_isns_enable_callback(ha,
+							     mbox_sts[2],
+							     mbox_sts[3],
+							     mbox_sts[4],
+							     mbox_sts[5]);
+			}
+			else if (mbox_sts[1] == ISNS_EVENT_CONNECTION_FAILED) {
+				QL4PRINT(QLP2, printk("scsi%d: AEN %04x, iSNS Service"
+						      " Connection FAILED! reason %04x\n",
+						      ha->host_no, mbox_status, mbox_sts[2]));
+			}
+			break;
+		default:
+			QL4PRINT(QLP2,
+				 printk("scsi%d: AEN %04x UNKNOWN\n",
+					ha->host_no, mbox_status));
+		}
+	}
+	else {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: Unknown mailbox status %08X\n",
+				ha->host_no, mbox_status));
+
+		ha->mbox_status[0] = mbox_status;
+		__dump_registers(QLP2, ha);
+	}
+}
+
+/**************************************************************************
+ * qla4xxx_interrupt_service_routine
+ *	This routine services the interrupt
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Remarks:
+ *      hardware_lock locked upon entry
+ *
+ * Returns:
+ *      QLA_SUCCESS - success, An interrupt was found and processed
+ *	QLA_ERROR - failure, The adapter was not interrupting
+ *
+ * Context:
+ *	Interrupt context.
+ **************************************************************************/
+void
+qla4xxx_interrupt_service_routine(scsi_qla_host_t *ha, uint32_t intr_status)
+{
+	ENTER("qla4xxx_interrupt_service_routine");
+
+	/*
+	 * Process response queue interrupt.
+	 */
+	if (intr_status & CSR_SCSI_COMPLETION_INTR) {
+		qla4xxx_process_response_queue(ha);
+	}
+
+	/*
+	 * Process mailbox/asynch event  interrupt.
+	 */
+	if (intr_status & CSR_SCSI_PROCESSOR_INTR) {
+		uint32_t mbox_status = RD_REG_DWORD(&ha->reg->mailbox[0]);
+		qla4xxx_isr_decode_mailbox(ha, mbox_status);
+
+		/* Clear Mailbox Interrupt */
+		WRT_REG_DWORD(&ha->reg->ctrl_status,
+		    SET_RMASK(CSR_SCSI_PROCESSOR_INTR));
+		PCI_POSTING(&ha->reg->ctrl_status);
+
+	}
+
+
+	LEAVE("qla4xxx_interrupt_service_routine");
+}
+
+/**************************************************************************
+ * qla4xxx_intr_handler
+ *	This routine handles the H/W interrupt
+ *
+ * Input:
+ *	irq - Unused
+ *	dev_id - Pointer to host adapter structure
+ *	regs - Unused
+ *
+ * Returns:
+ *	None
+ *
+ * Context:
+ *	Interrupt context.
+ **************************************************************************/
+irqreturn_t
+qla4xxx_intr_handler(int irq, void *dev_id, struct pt_regs *regs)
+{
+	scsi_qla_host_t *ha;
+	uint32_t intr_status;
+	unsigned long flags = 0;
+	uint8_t reqs_count = 0;
+
+	ENTER("qla4xxx_intr_handler");
+	ha = (scsi_qla_host_t *) dev_id;
+	if (!ha) {
+		DEBUG2( printk("qla4xxx: Interrupt with NULL host ptr\n"));
+		return IRQ_NONE;
+	}
+
+	ha->isr_count++;
+
+	/*
+	 * Check for pending interrupts
+	 */
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+
+	/*
+	 * Repeatedly service interrupts up to a maximum of
+	 * MAX_REQS_SERVICED_PER_INTR
+	 */
+	while (1) {
+		/*
+		 * Read interrupt status
+		 */
+		if (le32_to_cpu(ha->shadow_regs->rsp_q_in) !=
+		    ha->response_out) {
+			intr_status = CSR_SCSI_COMPLETION_INTR;
+		}
+		else {
+			intr_status = RD_REG_DWORD(&ha->reg->ctrl_status);
+		}
+
+		if ((intr_status & (CSR_SCSI_RESET_INTR|CSR_FATAL_ERROR|INTR_PENDING)) == 0) {
+			if (reqs_count == 0)
+				ha->spurious_int_count++;
+			break;
+		}
+
+		/*
+		 * Service interrupt
+		 */
+		if (intr_status & CSR_FATAL_ERROR) {
+			QL4PRINT(QLP2,
+				 printk("scsi%d: Fatal Error, "
+					"Status 0x%04x\n", ha->host_no,
+					RD_REG_DWORD(ISP_PORT_ERROR_STATUS(ha))));
+
+			QL4PRINT(QLP2,
+				 printk("scsi%d: Dump Registers:\n", ha->host_no));
+			__dump_registers(QLP2, ha);
+
+			/* Issue Soft Reset to clear this error condition.
+			 * This will prevent the RISC from repeatedly
+			 * interrupting the driver; thus, allowing the DPC to
+			 * get scheduled to continue error recovery.
+			 * NOTE: Disabling RISC interrupts does not work in
+			 * this case, as CSR_FATAL_ERROR overrides
+			 * CSR_SCSI_INTR_ENABLE */
+			if ((RD_REG_DWORD(&ha->reg->ctrl_status) & CSR_SCSI_RESET_INTR) == 0) {
+				QL4PRINT(QLP2,
+					 printk("scsi%d: Issue soft reset\n",
+						ha->host_no));
+				WRT_REG_DWORD(&ha->reg->ctrl_status, SET_RMASK((CSR_SOFT_RESET|CSR_SCSI_RESET_INTR)));
+				PCI_POSTING(&ha->reg->ctrl_status);
+			}
+
+			QL4PRINT(QLP2,
+				 printk("scsi%d: Acknowledge fatal error\n",
+					ha->host_no));
+			WRT_REG_DWORD(&ha->reg->ctrl_status, SET_RMASK(CSR_FATAL_ERROR));
+			PCI_POSTING(&ha->reg->ctrl_status);
+
+			__qla4xxx_disable_intrs(ha);
+
+			set_bit(DPC_RESET_HA, &ha->dpc_flags);
+
+			break;
+		}
+		else if (intr_status & CSR_SCSI_RESET_INTR) {
+			QL4PRINT(QLP2,
+				 printk("scsi%d: Soft Reset requested by "
+					"Network function or RISC\n", ha->host_no));
+
+			clear_bit(AF_ONLINE, &ha->flags);
+			__qla4xxx_disable_intrs(ha);
+
+			QL4PRINT(QLP2,
+				 printk("scsi%d: Clear SCSI Reset Interrupt\n",
+					ha->host_no));
+			WRT_REG_DWORD(&ha->reg->ctrl_status, SET_RMASK(CSR_SCSI_RESET_INTR));
+			PCI_POSTING(&ha->reg->ctrl_status);
+
+			set_bit(DPC_RESET_HA_INTR, &ha->dpc_flags);
+
+			break;
+		}
+		else if (intr_status & INTR_PENDING) {
+			qla4xxx_interrupt_service_routine(ha, intr_status);
+			ha->total_io_count++;
+			if (++reqs_count == MAX_REQS_SERVICED_PER_INTR) {
+				QL4PRINT(QLP11,
+					 printk("scsi%d: %s: exiting, %d "
+						"requests serviced\n",
+						ha->host_no, __func__,
+						reqs_count));
+				break;
+			}
+			intr_status = 0;
+		}
+	}
+
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	if (!list_empty(&ha->done_srb_q))
+		qla4xxx_done(ha);
+
+	LEAVE("qla4xxx_intr_handler");
+
+	return IRQ_HANDLED;
+}
+
+/**************************************************************************
+ * qla4xxx_process_aen
+ *	This routine processes Asynchronous Events received from the firmware.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	process_aen -
+ *      	PROCESS_ALL_AENS	 0
+ *      	FLUSH_DDB_CHANGED_AENS	 1
+ *      	RELOGIN_DDB_CHANGED_AENS 2
+ *
+ * Returns:
+ *	None
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+void
+qla4xxx_process_aen(scsi_qla_host_t *ha, uint8_t process_aen)
+{
+	uint32_t mbox_sts[MBOX_AEN_REG_COUNT];
+	aen_t   *aen;
+	int     i;
+	unsigned long flags;
+
+	ENTER("qla4xxx_process_aen");
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	while (ha->aen_out != ha->aen_in) {
+
+		/* Advance pointers for next entry */
+		if (ha->aen_out == (MAX_AEN_ENTRIES - 1))
+			ha->aen_out = 0;
+		else
+			ha->aen_out++;
+
+		aen = &ha->aen_q[ha->aen_out];
+
+		/* copy aen information to local structure */
+		for (i=0; i < MBOX_AEN_REG_COUNT; i++)
+			mbox_sts[i] = aen->mbox_sts[i];
+
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+		QL4PRINT(QLP2|QLP7, printk(
+		    "scsi%d: AEN[%d] %04x, index [%d] state=%04x mod=%x conerr=%08x \n",
+		    ha->host_no, ha->aen_out, mbox_sts[0], mbox_sts[2],
+		    mbox_sts[3], mbox_sts[1], mbox_sts[4]));
+
+		switch (mbox_sts[0]) {
+		case MBOX_ASTS_DATABASE_CHANGED:
+			if (process_aen == FLUSH_DDB_CHANGED_AENS) {
+				DEBUG2(printk(
+				    "scsi%d: AEN[%d] %04x, index [%d] "
+				    "state=%04x FLUSHED!\n", ha->host_no,
+				    ha->aen_out, mbox_sts[0], mbox_sts[2],
+				    mbox_sts[3]));
+				break;
+				/* Process all the outstanding AEN's
+				 * to make sure that we dont have any
+				 * stale entries in the queue.
+				 */
+			}
+			else if (process_aen == RELOGIN_DDB_CHANGED_AENS) {
+				/* for use during init time, we only want to
+				 * relogin non-active ddbs */
+				ddb_entry_t *ddb_entry;
+
+				ddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, mbox_sts[2]);
+				if (ddb_entry) {
+					ddb_entry->dev_scan_wait_to_complete_relogin = 0;
+					ddb_entry->dev_scan_wait_to_start_relogin =
+						jiffies + ((ddb_entry->default_time2wait + 4) * HZ);
+
+					QL4PRINT(QLP3, printk(
+					    "scsi%d: index [%d] initate relogin "
+					    "after %d seconds\n", ha->host_no,
+					    ddb_entry->fw_ddb_index,
+					    ddb_entry->default_time2wait+4));
+				}
+				break;
+			}
+
+			if (mbox_sts[1] == 0) {		/* Global DB change. */
+				QL4PRINT(QLP2|QLP7, printk("scsi%d: %s: "
+				    "global database changed aen\n",
+				    ha->host_no, __func__));
+				qla4xxx_reinitialize_ddb_list(ha);
+			} else if (mbox_sts[1] == 1) {	/* Specific device. */
+				qla4xxx_process_ddb_changed(ha,
+							    mbox_sts[2],
+							    mbox_sts[3]);
+			} else {
+				QL4PRINT(QLP2|QLP7, printk("scsi%d: %s: "
+				    "invalid database changed aen modifier, "
+				    "mbox_sts[1]=%04x\n", ha->host_no,
+				    __func__, mbox_sts[1]));
+			}
+			break;
+		}
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+	}
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	LEAVE("qla4xxx_process_aen");
+}
+
+
+/*
+ * Overrides for Emacs so that we almost follow Linus's tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 2
+ * c-brace-imaginary-offset: 0
+ * c-brace-offset: -2
+ * c-argdecl-indent: 2
+ * c-label-offset: -2
+ * c-continued-statement-offset: 2
+ * c-continued-brace-offset: 0
+ * indent-tabs-mode: nil
+ * tab-width: 8
+ * End:
+ */
+
diff --git a/drivers/scsi/qla4xxx/ql4_listops.h b/drivers/scsi/qla4xxx/ql4_listops.h
new file mode 100644
index 0000000..c0dbf84
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_listops.h
@@ -0,0 +1,287 @@
+/******************************************************************************
+ *     Copyright (C)  2003 -2005 QLogic Corporation
+ * QLogic ISP4xxx Device Driver
+ *
+ * This program includes a device driver for Linux 2.6.x that may be
+ * distributed with QLogic hardware specific firmware binary file.
+ * You may modify and redistribute the device driver code under the
+ * GNU General Public License as published by the Free Software Foundation
+ * (version 2 or a later version) and/or under the following terms,
+ * as applicable:
+ *
+ * 	1. Redistribution of source code must retain the above copyright
+ *         notice, this list of conditions and the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above copyright
+ *         notice, this list of conditions and the following disclaimer in
+ *         the documentation and/or other materials provided with the
+ *         distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ * 	
+ * You may redistribute the hardware specific firmware binary file under
+ * the following terms:
+ * 	1. Redistribution of source code (only if applicable), must
+ *         retain the above copyright notice, this list of conditions and
+ *         the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above
+ *         copyright notice, this list of conditions and the following
+ *         disclaimer in the documentation and/or other materials provided
+ *         with the distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ *
+ * REGARDLESS OF WHAT LICENSING MECHANISM IS USED OR APPLICABLE,
+ * THIS PROGRAM IS PROVIDED BY QLOGIC CORPORATION "AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * USER ACKNOWLEDGES AND AGREES THAT USE OF THIS PROGRAM WILL NOT CREATE
+ * OR GIVE GROUNDS FOR A LICENSE BY IMPLICATION, ESTOPPEL, OR OTHERWISE
+ * IN ANY INTELLECTUAL PROPERTY RIGHTS (PATENT, COPYRIGHT, TRADE SECRET,
+ * MASK WORK, OR OTHER PROPRIETARY RIGHT) EMBODIED IN ANY OTHER QLOGIC
+ * HARDWARE OR SOFTWARE EITHER SOLELY OR IN COMBINATION WITH THIS PROGRAM
+ *
+ ******************************************************************************/
+
+/* Management functions for various lists */
+
+/*************************************/
+
+static inline void
+sp_put( scsi_qla_host_t *ha, srb_t *sp)
+{
+	if (atomic_read(&sp->ref_count) == 0) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: sp->ref_count zero\n",
+				      ha->host_no, __func__));
+		DEBUG2(BUG());
+		return;
+	}
+
+	if (!atomic_dec_and_test(&sp->ref_count)) {
+		return;
+	}
+	
+	qla4xxx_complete_request(ha, sp);
+}
+
+static inline void
+sp_get( scsi_qla_host_t *ha, srb_t *sp)
+{
+	atomic_inc(&sp->ref_count);
+
+	if (atomic_read(&sp->ref_count) > 2) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: sp->ref_count greater than 2\n",
+				      ha->host_no, __func__));
+		DEBUG2(BUG());
+		return;
+	}
+}
+
+static inline void
+__add_to_retry_srb_q(scsi_qla_host_t *ha, srb_t *srb)
+{
+	QL4PRINT(QLP8, printk("scsi%d: %s: ha %d, srb = %p\n",
+			      ha->host_no, __func__, ha->instance, srb));
+	list_add_tail(&srb->list_entry, &ha->retry_srb_q);
+	srb->state = SRB_RETRY_STATE;
+	ha->retry_srb_q_count++;
+	srb->ha = ha;
+}
+
+static inline void
+__del_from_retry_srb_q(scsi_qla_host_t *ha, srb_t *srb)
+{
+	QL4PRINT(QLP8, printk("scsi%d: %s: ha %d, srb = %p\n",
+			      ha->host_no, __func__, ha->instance, srb));
+	list_del_init(&srb->list_entry);
+	srb->state = SRB_NO_QUEUE_STATE;
+	ha->retry_srb_q_count--;
+}
+
+/*************************************/
+
+static inline void
+__add_to_done_srb_q(scsi_qla_host_t *ha, srb_t *srb)
+{
+	QL4PRINT(QLP8, printk("scsi%d: %s: ha %d, srb = %p\n",
+			      ha->host_no, __func__, ha->instance, srb));
+	list_add_tail(&srb->list_entry, &ha->done_srb_q);
+	srb->state = SRB_DONE_STATE;
+	ha->done_srb_q_count++;
+	srb->ha = ha;
+}
+
+static inline void
+__del_from_done_srb_q(scsi_qla_host_t *ha, srb_t *srb)
+{
+	QL4PRINT(QLP8, printk("scsi%d: %s: ha %d, srb = %p\n",
+			      ha->host_no, __func__, ha->instance, srb));
+	list_del_init(&srb->list_entry);
+	srb->state = SRB_NO_QUEUE_STATE;
+	ha->done_srb_q_count--;
+}
+
+static inline srb_t *__del_from_done_srb_q_head(scsi_qla_host_t *ha)
+{
+	struct list_head *ptr;
+	srb_t *srb = NULL;
+
+	if (!list_empty(&ha->done_srb_q)) {
+		/* Remove list entry from head of queue */
+		ptr = ha->done_srb_q.next;
+		list_del_init(ptr);
+
+		/* Return pointer to srb structure */
+		srb = list_entry(ptr, srb_t, list_entry);
+		srb->state = SRB_NO_QUEUE_STATE;
+		ha->done_srb_q_count--;
+	}
+	QL4PRINT(QLP8, printk("scsi%d: %s: ha %d, srb = %p\n",
+			      ha->host_no, __func__, ha->instance, srb));
+
+	return(srb);
+}
+
+/*************************************/
+
+static inline void
+__add_to_free_srb_q(scsi_qla_host_t *ha, srb_t *srb)
+{
+	DEBUG(printk("scsi%d: %s: instance %d, srb = %p\n",
+			      ha->host_no, __func__, ha->instance,
+			      srb ));
+
+	atomic_set(&srb->ref_count, 0);
+	list_add_tail(&srb->list_entry, &ha->free_srb_q);
+	ha->free_srb_q_count++;
+	srb->state = SRB_FREE_STATE;
+}
+
+static inline void __del_from_free_srb_q(scsi_qla_host_t *ha, srb_t *srb)
+{
+
+	DEBUG(printk("scsi%d: %s: instance %d, srb = %p\n",
+			      ha->host_no, __func__, ha->instance,
+			      srb ));
+	list_del_init(&srb->list_entry);
+	atomic_set(&srb->ref_count, 1);
+	srb->state = SRB_NO_QUEUE_STATE;
+	ha->free_srb_q_count--;
+}
+
+static inline srb_t *__del_from_free_srb_q_head(scsi_qla_host_t *ha)
+{
+	struct list_head *ptr;
+	srb_t *srb = NULL;
+
+	if (!list_empty(&ha->free_srb_q)) {
+		/* Remove list entry from head of queue */
+		ptr = ha->free_srb_q.next;
+		list_del_init(ptr);
+
+		/* Return pointer to srb structure */
+		srb = list_entry(ptr, srb_t, list_entry);
+		atomic_set(&srb->ref_count, 1);
+		srb->state = SRB_NO_QUEUE_STATE;
+		ha->free_srb_q_count--;
+	}
+	DEBUG(printk("scsi%d: %s: instance %d, srb = %p\n",
+			      ha->host_no, __func__, ha->instance,
+			      srb ));
+
+	return(srb);
+}
+
+
+/*************************************/
+
+static inline void
+add_to_retry_srb_q(scsi_qla_host_t *ha, srb_t *srb)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&ha->list_lock, flags);
+	__add_to_retry_srb_q(ha ,srb);
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+}
+
+static inline void
+del_from_retry_srb_q(scsi_qla_host_t *ha, srb_t *srb)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&ha->list_lock, flags);
+	__del_from_retry_srb_q(ha ,srb);
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+}
+
+/*************************************/
+
+static inline void
+add_to_done_srb_q(scsi_qla_host_t *ha, srb_t *srb)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&ha->list_lock, flags);
+	__add_to_done_srb_q(ha ,srb);
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+}
+
+static inline void
+del_from_done_srb_q(scsi_qla_host_t *ha, srb_t *srb)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&ha->list_lock, flags);
+	__del_from_done_srb_q(ha ,srb);
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+}
+
+static inline srb_t *
+del_from_done_srb_q_head(scsi_qla_host_t *ha)
+{
+	unsigned long flags;
+	srb_t *srb;
+
+	spin_lock_irqsave(&ha->list_lock, flags);
+	srb = __del_from_done_srb_q_head(ha);
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+	return(srb);
+}
+
+/*************************************/
+
+static inline void
+add_to_free_srb_q(scsi_qla_host_t *ha, srb_t *srb)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&ha->list_lock, flags);
+	__add_to_free_srb_q(ha ,srb);
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+}
+
+static inline srb_t *
+del_from_free_srb_q_head(scsi_qla_host_t *ha)
+{
+	unsigned long flags;
+	srb_t *srb;
+
+	spin_lock_irqsave(&ha->list_lock, flags);
+	srb = __del_from_free_srb_q_head(ha);
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+
+	return(srb);
+}
+
+/*************************************/
diff --git a/drivers/scsi/qla4xxx/ql4_mbx.c b/drivers/scsi/qla4xxx/ql4_mbx.c
new file mode 100644
index 0000000..fc212d5
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_mbx.c
@@ -0,0 +1,1689 @@
+/******************************************************************************
+ *     Copyright (C)  2003 -2005 QLogic Corporation
+ * QLogic ISP4xxx Device Driver
+ *
+ * This program includes a device driver for Linux 2.6.x that may be
+ * distributed with QLogic hardware specific firmware binary file.
+ * You may modify and redistribute the device driver code under the
+ * GNU General Public License as published by the Free Software Foundation
+ * (version 2 or a later version) and/or under the following terms,
+ * as applicable:
+ *
+ * 	1. Redistribution of source code must retain the above copyright
+ *         notice, this list of conditions and the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above copyright
+ *         notice, this list of conditions and the following disclaimer in
+ *         the documentation and/or other materials provided with the
+ *         distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ * 	
+ * You may redistribute the hardware specific firmware binary file under
+ * the following terms:
+ * 	1. Redistribution of source code (only if applicable), must
+ *         retain the above copyright notice, this list of conditions and
+ *         the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above
+ *         copyright notice, this list of conditions and the following
+ *         disclaimer in the documentation and/or other materials provided
+ *         with the distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ *
+ * REGARDLESS OF WHAT LICENSING MECHANISM IS USED OR APPLICABLE,
+ * THIS PROGRAM IS PROVIDED BY QLOGIC CORPORATION "AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * USER ACKNOWLEDGES AND AGREES THAT USE OF THIS PROGRAM WILL NOT CREATE
+ * OR GIVE GROUNDS FOR A LICENSE BY IMPLICATION, ESTOPPEL, OR OTHERWISE
+ * IN ANY INTELLECTUAL PROPERTY RIGHTS (PATENT, COPYRIGHT, TRADE SECRET,
+ * MASK WORK, OR OTHER PROPRIETARY RIGHT) EMBODIED IN ANY OTHER QLOGIC
+ * HARDWARE OR SOFTWARE EITHER SOLELY OR IN COMBINATION WITH THIS PROGRAM
+ *
+ ******************************************************************************
+ *             Please see release.txt for revision history.                   *
+ *                                                                            *
+ ******************************************************************************
+ * Function Table of Contents:
+ *	qla4xxx_mailbox_command
+ *	qla4xxx_mbx_test
+ *	qla4xxx_send_noop
+ *	qla4xxx_conn_close_sess_logout
+ *	qla4xxx_clear_database_entry
+ *	qla4xxx_initialize_fw_cb
+ *	qla4xxx_get_fw_version
+ *	qla4xxx_get_firmware_state
+ *	qla4xxx_get_fwddb_entry
+ *	qla4xxx_set_ddb_entry
+ *	qla4xxx_get_crash_record
+ *	qla4xxx_reset_lun
+ *	qla4xxx_isns_enable
+ *	qla4xxx_isns_disable
+ *	qla4xxx_isns_status
+ *	qla4xxx_get_flash
+ ****************************************************************************/
+
+#include "ql4_def.h"
+
+#include <linux/delay.h>
+
+extern int ql4xportdownretrycount;
+extern int ql4xdiscoverywait;
+extern void qla4xxx_isns_build_entity_id(scsi_qla_host_t *ha);
+extern int qla4xxx_eh_wait_for_active_target_commands(scsi_qla_host_t *ha, int target, int lun);
+
+/**************************************************************************
+ * qla4xxx_mailbox_command
+ *	This routine sssue mailbox commands and waits for completion.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	inCount	 - number of mailbox registers to load.
+ *      outCount - number of mailbox registers to return.
+ *      mbx_cmd  - data pointer for mailbox in registers.
+ *      mbx_sts  - data pointer for mailbox out registers.
+ *
+ * Output:
+ *      mbx_sts - returned mailbox out data.
+ *
+ * Remarks:
+ *	If outCount is 0, this routine completes successfully WITHOUT waiting
+ *	for the mailbox command to complete.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Mailbox command completed successfully
+ *	QLA_ERROR   - Mailbox command competed in error.
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_mailbox_command(scsi_qla_host_t *ha,
+			uint8_t inCount,
+			uint8_t outCount,
+			uint32_t *mbx_cmd,
+			uint32_t *mbx_sts)
+{
+	uint8_t      status = QLA_ERROR;
+	uint8_t      i;
+	u_long     wait_count;
+	uint32_t     intr_status;
+	unsigned long flags = 0;
+	DECLARE_WAITQUEUE(wait, current);
+
+
+	ENTER("qla4xxx_mailbox_command");
+
+	down(&ha->mbox_sem);
+
+
+	set_bit(AF_MBOX_COMMAND, &ha->flags);
+
+
+	/* Make sure that pointers are valid */
+	if (!mbx_cmd || !mbx_sts) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: Invalid mbx_cmd or mbx_sts pointer\n",
+				ha->host_no, __func__));
+
+		goto mbox_exit;
+	}
+
+	/* To prevent overwriting mailbox registers for a command that has
+	 * not yet been serviced, check to see if a previously issued
+	 * mailbox command is interrupting.
+	 * -----------------------------------------------------------------
+	 */
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	intr_status = RD_REG_DWORD(&ha->reg->ctrl_status);
+	if (intr_status & CSR_SCSI_PROCESSOR_INTR) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: Trying to execute a mailbox request, "
+				"while another one is interrupting\n"
+				"Service existing interrupt first\n",
+				ha->host_no, __func__));
+
+		/* Service existing interrupt */
+		qla4xxx_interrupt_service_routine(ha, intr_status);
+
+		clear_bit(AF_MBOX_COMMAND_DONE, &ha->flags);
+	}
+
+
+	/* Send the mailbox command to the firmware
+	 * ----------------------------------------
+	 */
+	ha->f_start = jiffies;
+	ha->mbox_status_count = outCount;
+	for (i=0; i < outCount; i++) {
+		ha->mbox_status[i] = 0;
+	}
+
+	for (i=0; i<inCount; i++) {
+		QL4PRINT(QLP11, printk("scsi%d: %s: Mailbox In[%d]  0x%08X\n",
+				       ha->host_no, __func__, i, mbx_cmd[i]));
+	}
+
+	/* Load all mailbox registers, except mailbox 0.*/
+	for (i = 1; i < inCount; i++) {
+		WRT_REG_DWORD(&ha->reg->mailbox[i], mbx_cmd[i]);
+	}
+
+	/* Write Mailbox 0 to alert the firmware that the mailbox registers
+	 * contain a command to be processed.  NOTE: We could be interrupted
+	 * here if system interrupts are enabled */
+	WRT_REG_DWORD(&ha->reg->mailbox[0], mbx_cmd[0]);
+	PCI_POSTING(&ha->reg->mailbox[0]);
+	WRT_REG_DWORD(&ha->reg->ctrl_status, SET_RMASK(CSR_INTR_RISC));
+	PCI_POSTING(&ha->reg->ctrl_status);
+
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	add_wait_queue(&ha->mailbox_wait_queue,&wait);
+
+	/*
+	 * If we don't want status, don't wait for the mailbox command to
+	 * complete.  For example, MBOX_CMD_RESET_FW doesn't return status,
+	 * you must poll the inbound Interrupt Mask for completion.
+	 */
+	if (outCount == 0) {
+		status = QLA_SUCCESS;
+		set_current_state(TASK_RUNNING);
+		remove_wait_queue(&ha->mailbox_wait_queue,&wait);
+		ha->f_end = jiffies;
+		goto mbox_exit;
+	}
+
+	/*
+	 * Wait for command to complete
+	 * -----------------------------
+	 */
+	wait_count = jiffies + MBOX_TOV * HZ;
+	while (test_bit(AF_MBOX_COMMAND_DONE, &ha->flags) == 0) {
+		if (time_after_eq(jiffies, wait_count)) {	
+			break;
+		}
+
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+
+		intr_status = RD_REG_DWORD(&ha->reg->ctrl_status);
+
+		QL4PRINT(QLP11, printk("scsi%d: %s: INTR_STATUS = 0x%X\n",
+				       ha->host_no, __func__, intr_status));
+
+		if (intr_status & INTR_PENDING) {
+			/*
+			 * Service the interrupt.
+			 * The ISR will save the mailbox status registers
+			 * to a temporary storage location in the adapter
+			 * structure.
+			 */
+			ha->mbox_status_count = outCount;
+			qla4xxx_interrupt_service_routine(ha, intr_status);
+		}
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+		/*
+		 * Delay for 10 microseconds
+		 * NOTE: Interrupt_handler may be called here,
+		 *       if interrupts are enabled
+		 */
+		schedule_timeout(10);
+	} /* wait loop */
+
+
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&ha->mailbox_wait_queue,&wait);
+
+	/*
+	 * Check for mailbox timeout
+	 */
+	if (!test_bit(AF_MBOX_COMMAND_DONE, &ha->flags)) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: Mailbox Cmd 0x%08X timed out ...,"
+				" Scheduling Adapter Reset\n",
+				ha->host_no, mbx_cmd[0]));
+
+		ha->mailbox_timeout_count++;
+		mbx_sts[0] = (-1);
+
+		set_bit(DPC_RESET_HA, &ha->dpc_flags);
+		goto mbox_exit;
+	}
+
+	QL4PRINT(QLP11,
+		 printk("scsi%d: %s: mailbox cmd done!\n",
+			ha->host_no, __func__));
+
+	/*
+	 * Copy the mailbox out registers to the caller's mailbox in/out
+	 * structure.
+	 */
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	for (i=0; i < outCount; i++) {
+		mbx_sts[i] = ha->mbox_status[i];
+		QL4PRINT(QLP11,
+			 printk("scsi%d: %s: Mailbox Status[%d]  0x%08X\n",
+				ha->host_no, __func__, i, mbx_sts[i]));
+	}
+
+	/*
+	 * Set return status and error flags (if applicable)
+	 */
+	switch (ha->mbox_status[0]) {
+	
+	case MBOX_STS_COMMAND_COMPLETE:
+		status = QLA_SUCCESS;
+		break;
+
+	case MBOX_STS_INTERMEDIATE_COMPLETION:
+		status = QLA_SUCCESS;
+		QL4PRINT(QLP5,
+			 printk("scsi%d: %s: Cmd = %08X, Intermediate completion\n",
+				ha->host_no, __func__, mbx_cmd[0]));
+		break;
+
+	case MBOX_STS_BUSY:
+		QL4PRINT(QLP2, printk("scsi%d: %s: Cmd = %08X, ISP BUSY\n",
+				      ha->host_no, __func__, mbx_cmd[0]));
+
+		ha->mailbox_timeout_count++;
+		break;
+
+	case MBOX_STS_INVALID_COMMAND:
+	case MBOX_STS_HOST_INTERFACE_ERROR:
+	case MBOX_STS_TEST_FAILED:
+	case MBOX_STS_COMMAND_ERROR:
+	case MBOX_STS_COMMAND_PARAMETER_ERROR:
+	default:
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: **** FAILED, cmd = %08X, "
+				"sts = %08X ****\n",
+				ha->host_no, __func__, mbx_cmd[0], mbx_sts[0]));
+
+
+		__dump_registers(QLP2, ha);
+		break;
+	} /* switch mbox status */
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	mbox_exit:
+	clear_bit(AF_MBOX_COMMAND, &ha->flags);
+	clear_bit(AF_MBOX_COMMAND_DONE, &ha->flags);
+	LEAVE("qla4xxx_mailbox_command");
+	up(&ha->mbox_sem);
+
+	return(status);
+}
+
+
+#if 0
+uint8_t qla4xxx_send_noop(scsi_qla_host_t *ha)
+{
+	uint32_t   mbox_cmd[MBOX_REG_COUNT];
+	uint32_t   mbox_sts[MBOX_REG_COUNT];
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_NOP;
+
+	if (qla4xxx_mailbox_command(ha, 1, 1, &mbox_cmd[0], &mbox_sts[0])
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: NOP failed\n", ha->host_no));
+		return(QLA_ERROR);
+	}
+	else {
+		QL4PRINT(QLP2, printk("scsi%d: NOP succeded\n", ha->host_no));
+		return(QLA_SUCCESS);
+	}
+}
+
+uint8_t qla4xxx_mbx_test(scsi_qla_host_t *ha)
+{
+	uint32_t   mbox_cmd[MBOX_REG_COUNT];
+	uint32_t   mbox_sts[MBOX_REG_COUNT];
+	int i;
+	uint8_t status;
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_REGISTER_TEST;
+	mbox_cmd[1] = 0x11111111;
+	mbox_cmd[2] = 0x22222222;
+	mbox_cmd[3] = 0x33333333;
+	mbox_cmd[4] = 0x44444444;
+	mbox_cmd[5] = 0x55555555;
+	mbox_cmd[6] = 0x66666666;
+	mbox_cmd[7] = 0x77777777;
+
+	if (qla4xxx_mailbox_command(ha, 8, 8, &mbox_cmd[0], &mbox_sts[0])
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: REGISTER_TEST failed, mbox_sts = 0x%x\n",
+				      ha->host_no, mbox_sts[0]));
+		return(QLA_ERROR);
+	}
+
+	if (mbox_sts[1] != 0x11111111 ||
+	    mbox_sts[2] != 0x22222222 ||
+	    mbox_sts[3] != 0x33333333 ||
+	    mbox_sts[4] != 0x44444444 ||
+	    mbox_sts[5] != 0x55555555 ||
+	    mbox_sts[6] != 0x66666666 ||
+	    mbox_sts[7] != 0x77777777) {
+		QL4PRINT(QLP2, printk("scsi%d: REGISTER_TEST failed\n", ha->host_no));
+		status = QLA_ERROR;
+
+	}
+	else {
+		QL4PRINT(QLP2, printk("scsi%d: REGISTER_TEST succeded\n", ha->host_no));
+		status = QLA_SUCCESS;
+	}
+
+	for (i = 0; i < 8; i++) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: MBX%d = 0x%x\n",
+				      ha->host_no, __func__, i, mbox_cmd[i]));
+	}
+	return(status);
+}
+#endif
+
+/*
+ * qla4xxx_issue_iocb
+ *	Issue IOCB using mailbox command
+ *
+ * Input:
+ *	ha = adapter state pointer.
+ *	buffer = buffer pointer.
+ *	phys_addr = physical address of buffer.
+ *	size = size of buffer.
+ *	TARGET_QUEUE_LOCK must be released.
+ *	ADAPTER_STATE_LOCK must be released.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+uint8_t
+qla4xxx_issue_iocb(scsi_qla_host_t *ha, void*  buffer,
+		   dma_addr_t phys_addr, size_t size)
+{
+	uint32_t   mbox_cmd[MBOX_REG_COUNT];
+	uint32_t   mbox_sts[MBOX_REG_COUNT];
+	uint8_t	   status;
+
+	ENTER("qla4xxx_issue_iocb: started");
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_EXECUTE_IOCB_A64;
+	mbox_cmd[1] = 0;
+	mbox_cmd[2] = LSDW(phys_addr);
+	mbox_cmd[3] = MSDW(phys_addr);
+	status = qla4xxx_mailbox_command(ha, 4, 1, &mbox_cmd[0], &mbox_sts[0]);
+
+	if (status != QLA_SUCCESS) {
+		/*EMPTY*/
+		QL4PRINT(QLP2, printk("qla4xxx_issue_iocb(%d): failed statis 0x%x",
+		    ha->host_no, status));
+	} else {
+		/*EMPTY*/
+		LEAVE("qla4xxx_issue_iocb: exiting normally");
+	}
+
+	return status;
+}
+
+uint8_t
+qla4xxx_conn_close_sess_logout(scsi_qla_host_t *ha, uint16_t fw_ddb_index,
+			       uint16_t connection_id, uint16_t option)
+{
+	uint32_t    mbox_cmd[MBOX_REG_COUNT];
+	uint32_t    mbox_sts[MBOX_REG_COUNT];
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_CONN_CLOSE_SESS_LOGOUT;
+	mbox_cmd[1] = fw_ddb_index;
+	mbox_cmd[2] = connection_id;
+	mbox_cmd[3] = LOGOUT_OPTION_RELOGIN;
+
+	if (qla4xxx_mailbox_command(ha, 4, 2, &mbox_cmd[0], &mbox_sts[0])
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: MBOX_CMD_CONN_CLOSE_SESS_LOGOUT "
+				"option %04x failed sts %04X %04X",
+				ha->host_no, __func__, option,
+				mbox_sts[0], mbox_sts[1]));
+
+		if (mbox_sts[0] == 0x4005) {
+			QL4PRINT(QLP2, printk(", reason %04X\n", mbox_sts[1]));
+		}
+		else {
+			QL4PRINT(QLP2, printk("\n"));
+		}
+	}
+
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_clear_database_entry(scsi_qla_host_t *ha, uint16_t fw_ddb_index)
+{
+	uint32_t    mbox_cmd[MBOX_REG_COUNT];
+	uint32_t    mbox_sts[MBOX_REG_COUNT];
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_CLEAR_DATABASE_ENTRY;
+	mbox_cmd[1] = fw_ddb_index;
+
+	if (qla4xxx_mailbox_command(ha, 2, 5, &mbox_cmd[0], &mbox_sts[0])
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2,
+		    printk("scsi%d: %s: MBOX_CMD_CLEAR_DATABASE_ENTRY "
+		    "failed sts %04X index [%d], state %04x\n",
+		    ha->host_no, __func__, mbox_sts[0], fw_ddb_index,
+		    mbox_sts[4]));
+		return(QLA_ERROR);
+	}
+
+	return(QLA_SUCCESS);
+}
+
+/**************************************************************************
+ * qla4xxx_initialize_fw_cb
+ *	This routine initializes the firmware control block for the
+ *	specified adapter.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully initialized firmware ctrl block
+ *	QLA_ERROR   - Failed to initialize firmware ctrl block
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_initialize_fw_cb(scsi_qla_host_t *ha)
+{
+	INIT_FW_CTRL_BLK  *init_fw_cb;
+	dma_addr_t	  init_fw_cb_dma;
+	uint32_t   mbox_cmd[MBOX_REG_COUNT];
+	uint32_t   mbox_sts[MBOX_REG_COUNT];
+	uint8_t    status = QLA_ERROR;
+
+	ENTER("qla4xxx_initialize_fw_cb");
+
+	init_fw_cb = pci_alloc_consistent(ha->pdev, sizeof(INIT_FW_CTRL_BLK),
+	  &init_fw_cb_dma);
+	if (init_fw_cb == NULL) {
+		printk("scsi%d: %s: Unable to alloc init_cb\n", ha->host_no,
+		    __func__);
+		return 10;
+	}
+	memset(init_fw_cb, 0, sizeof(INIT_FW_CTRL_BLK));
+
+	/*
+	 * Get Initialize Firmware Control Block
+	 */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_GET_INIT_FW_CTRL_BLOCK;
+	mbox_cmd[2] = LSDW(init_fw_cb_dma);
+	mbox_cmd[3] = MSDW(init_fw_cb_dma);
+
+	if (qla4xxx_mailbox_command(ha, 4, 1, &mbox_cmd[0], &mbox_sts[0])
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: Failed to get init_fw_ctrl_blk\n",
+				ha->host_no, __func__));
+		LEAVE("qla4xxx_initialize_fw_cb");
+		pci_free_consistent(ha->pdev, sizeof(INIT_FW_CTRL_BLK),
+		    init_fw_cb, init_fw_cb_dma);
+		return (status);
+	}
+
+	// QL4PRINT(QLP10, printk("scsi%d: Init Fw Ctrl Blk\n", ha->host_no));
+	// qla4xxx_dump_bytes(QLP10, init_fw_cb, sizeof(INIT_FW_CTRL_BLK));
+
+	/*
+	 * Initialize request and response queues
+	 */
+	qla4xxx_init_rings(ha);
+
+	/*
+	 * Fill in the request and response queue information
+	 */
+	init_fw_cb->ReqQConsumerIndex = cpu_to_le16(ha->request_out);
+	init_fw_cb->ComplQProducerIndex = cpu_to_le16(ha->response_in);
+	init_fw_cb->ReqQLen = __constant_cpu_to_le16(REQUEST_QUEUE_DEPTH);
+	init_fw_cb->ComplQLen = __constant_cpu_to_le16(RESPONSE_QUEUE_DEPTH);
+	init_fw_cb->ReqQAddrLo = cpu_to_le32(LSDW(ha->request_dma));
+	init_fw_cb->ReqQAddrHi = cpu_to_le32(MSDW(ha->request_dma));
+	init_fw_cb->ComplQAddrLo = cpu_to_le32(LSDW(ha->response_dma));
+	init_fw_cb->ComplQAddrHi = cpu_to_le32(MSDW(ha->response_dma));
+	init_fw_cb->ShadowRegBufAddrLo = cpu_to_le32(LSDW(ha->shadow_regs_dma));
+	init_fw_cb->ShadowRegBufAddrHi = cpu_to_le32(MSDW(ha->shadow_regs_dma));
+
+	/*
+	 * Set up required options
+	 */
+	init_fw_cb->FwOptions |=
+	    __constant_cpu_to_le16(FWOPT_SESSION_MODE | FWOPT_INITIATOR_MODE);
+	init_fw_cb->FwOptions &= __constant_cpu_to_le16(~FWOPT_TARGET_MODE);
+
+	/*
+	 * Save some info in adapter structure
+	 */
+	ha->firmware_options = le16_to_cpu(init_fw_cb->FwOptions);
+	ha->tcp_options = le16_to_cpu(init_fw_cb->TCPOptions);
+	ha->heartbeat_interval = init_fw_cb->HeartbeatInterval;
+	ha->isns_server_port_number =
+	    le16_to_cpu(init_fw_cb->iSNSServerPortNumber);
+
+	memcpy(ha->ip_address, init_fw_cb->IPAddr,
+	    MIN(sizeof(ha->ip_address), sizeof(init_fw_cb->IPAddr)));
+	memcpy(ha->subnet_mask, init_fw_cb->SubnetMask,
+	    MIN(sizeof(ha->subnet_mask), sizeof(init_fw_cb->SubnetMask)));
+	memcpy(ha->gateway, init_fw_cb->GatewayIPAddr,
+	    MIN(sizeof(ha->gateway), sizeof(init_fw_cb->GatewayIPAddr)));
+	memcpy(ha->isns_ip_address, init_fw_cb->iSNSIPAddr,
+	    MIN(sizeof(ha->isns_ip_address), sizeof(init_fw_cb->iSNSIPAddr)));
+	memcpy(ha->name_string, init_fw_cb->iSCSINameString,
+	    MIN(sizeof(ha->name_string), sizeof(init_fw_cb->iSCSINameString)));
+	memcpy(ha->alias, init_fw_cb->Alias,
+	    MIN(sizeof(ha->alias), sizeof(init_fw_cb->Alias)));
+
+	/* Save Command Line Paramater info */
+	ha->port_down_retry_count = le16_to_cpu(init_fw_cb->KeepAliveTimeout);
+	ha->discovery_wait = ql4xdiscoverywait;
+
+	/*
+	 * Send Initialize Firmware Control Block
+	 */
+	QL4PRINT(QLP7, printk("scsi%d: %s: init_fw cmd sent\n", ha->host_no,
+	    __func__));
+
+	mbox_cmd[0] = MBOX_CMD_INITIALIZE_FIRMWARE;
+	mbox_cmd[1] = 0;
+	mbox_cmd[2] = LSDW(init_fw_cb_dma);
+	mbox_cmd[3] = MSDW(init_fw_cb_dma);
+	if (qla4xxx_mailbox_command(ha, 4, 1, &mbox_cmd[0], &mbox_sts[0])
+	    == QLA_SUCCESS) {
+		QL4PRINT(QLP7, printk("scsi%d: Init Fw Ctrl Blk\n",
+		    ha->host_no));
+		qla4xxx_dump_bytes(QLP7, init_fw_cb, sizeof(INIT_FW_CTRL_BLK));
+		QL4PRINT(QLP7, printk("scsi%d: %s: "
+		    "IP Address            %d.%d.%d.%d\n", ha->host_no,
+		    __func__, ha->ip_address[0], ha->ip_address[1],
+		    ha->ip_address[2], ha->ip_address[3]));
+		QL4PRINT(QLP7, printk("scsi%d: %s: "
+		    "Subnet Mask           %d.%d.%d.%d\n", ha->host_no,
+		    __func__, init_fw_cb->SubnetMask[0],
+		    init_fw_cb->SubnetMask[1], init_fw_cb->SubnetMask[2],
+		    init_fw_cb->SubnetMask[3]));
+		QL4PRINT(QLP7, printk("scsi%d: %s: "
+		    "Default Gateway       %d.%d.%d.%d\n", ha->host_no,
+		    __func__, init_fw_cb->GatewayIPAddr[0],
+		    init_fw_cb->GatewayIPAddr[1], init_fw_cb->GatewayIPAddr[2],
+		    init_fw_cb->GatewayIPAddr[3]));
+		QL4PRINT(QLP7, printk("scsi%d: %s: "
+		    "Auto-Negotiate        %s\n", ha->host_no, __func__,
+		    ((le16_to_cpu(init_fw_cb->AddFwOptions) & 0x10) != 0) ?
+		    "ON" : "OFF"));
+		QL4PRINT(QLP7, printk("scsi%d: %s: "
+		    "SLP Use DA Enable     %s\n", ha->host_no, __func__,
+		    ((ha->tcp_options & TOPT_SLP_USE_DA_ENABLE) != 0) ?
+		    "ON" : "OFF"));
+		QL4PRINT(QLP7, printk("scsi%d: %s: "
+		    "SLP UA Enable         %s\n", ha->host_no, __func__,
+		    ((ha->tcp_options & TOPT_SLP_UA_ENABLE) != 0) ?
+		    "ON" : "OFF"));
+		QL4PRINT(QLP7, printk("scsi%d: %s: "
+		    "DHCP Enable           %s\n", ha->host_no, __func__,
+		    ((ha->tcp_options & TOPT_DHCP_ENABLE) != 0) ?
+		    "ON" : "OFF"));
+		QL4PRINT(QLP7, printk("scsi%d: %s: "
+		    "DNS via DHCP Enable   %s\n", ha->host_no, __func__,
+		    ((ha->tcp_options & TOPT_GET_DNS_VIA_DHCP_ENABLE) != 0) ?
+		    "ON" : "OFF"));
+		QL4PRINT(QLP7, printk("scsi%d: %s: "
+		    "SLP via DHCP Enable   %s\n", ha->host_no, __func__,
+		    ((ha->tcp_options & TOPT_GET_SLP_VIA_DHCP_ENABLE) != 0) ?
+		    "ON" : "OFF"));
+		QL4PRINT(QLP7, printk("scsi%d: %s: "
+		    "Auto Discovery Enable %s\n", ha->host_no, __func__,
+		    ((ha->tcp_options & TOPT_AUTO_DISCOVERY_ENABLE) != 0) ?
+		    "ON" : "OFF"));
+		QL4PRINT(QLP7|QLP20, printk("scsi%d: %s: "
+		    "iSNS Enable           %s\n", ha->host_no, __func__,
+		    ((ha->tcp_options & TOPT_ISNS_ENABLE) != 0) ?
+		    "ON" : "OFF"));
+		QL4PRINT(QLP7|QLP20, printk("scsi%d: %s: "
+		    "Learn iSNS IP Addr Enable %s\n", ha->host_no, __func__,
+		    ((ha->tcp_options & TOPT_LEARN_ISNS_IP_ADDR_ENABLE) != 0)
+		    ? "ON" : "OFF"));
+		if (ha->tcp_options & TOPT_ISNS_ENABLE) {
+			set_bit(ISNS_FLAG_ISNS_ENABLED_IN_ISP, &ha->isns_flags);
+
+			QL4PRINT(QLP7|QLP20, printk("scsi%d: %s: "
+			    "iSNS IP Address           %d.%d.%d.%d\n",
+			    ha->host_no, __func__, ha->isns_ip_address[0],
+			    ha->isns_ip_address[1], ha->isns_ip_address[2],
+			    ha->isns_ip_address[3]));
+			QL4PRINT(QLP7|QLP20, printk("scsi%d: %s: "
+			    "iSNS Server Port Number   %d\n", ha->host_no,
+			    __func__, ha->isns_server_port_number));
+		}
+
+		QL4PRINT(QLP7, printk("scsi%d: %s: "
+		    "Heartbeat Enable      %s\n", ha->host_no, __func__,
+		    ((ha->firmware_options & FWOPT_HEARTBEAT_ENABLE) != 0) ?
+		    "ON" : "OFF"));
+		if (ha->firmware_options & FWOPT_HEARTBEAT_ENABLE)
+			QL4PRINT(QLP7, printk("scsi%d: %s: "
+			    "Heartbeat Interval    %d\n", ha->host_no, __func__,
+			    ha->heartbeat_interval));
+
+		QL4PRINT(QLP7, printk("scsi%d: %s: "
+		    "Execution Throttle %d\n", ha->host_no, __func__,
+		    le16_to_cpu(init_fw_cb->ExecThrottle)));
+
+		status = QLA_SUCCESS;
+	} else {
+		QL4PRINT(QLP2, printk("scsi%d: %s: "
+		    "MBOX_CMD_INITIALIZE_FIRMWARE failed w/ status %04X\n",
+		    ha->host_no, __func__, mbox_sts[0]));
+	}
+
+	pci_free_consistent(ha->pdev, sizeof(INIT_FW_CTRL_BLK), init_fw_cb,
+	    init_fw_cb_dma);
+
+	LEAVE("qla4xxx_initialize_fw_cb");
+
+	return status;
+}
+
+
+/**************************************************************************
+ * qla4xxx_get_dhcp_ip_address
+ *	This routine retrieves the IP Address obtained via DHCP for the
+ *	specified adapter.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully obtained DHCP IP Address
+ *	QLA_ERROR   - Failed to obtained
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_get_dhcp_ip_address(scsi_qla_host_t *ha)
+{
+	INIT_FW_CTRL_BLK  *init_fw_cb;
+	dma_addr_t	  init_fw_cb_dma;
+	uint32_t   mbox_cmd[MBOX_REG_COUNT];
+	uint32_t   mbox_sts[MBOX_REG_COUNT];
+
+	ENTER(__func__);
+
+	init_fw_cb = pci_alloc_consistent(ha->pdev, sizeof(INIT_FW_CTRL_BLK),
+	  &init_fw_cb_dma);
+	if (init_fw_cb == NULL) {
+		printk("scsi%d: %s: Unable to alloc init_cb\n", ha->host_no,
+		    __func__);
+		return 10;
+	}
+
+	/*
+	 * Get Initialize Firmware Control Block
+	 */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	memset(init_fw_cb, 0, sizeof(INIT_FW_CTRL_BLK));
+	mbox_cmd[0] = MBOX_CMD_GET_INIT_FW_CTRL_BLOCK;
+	mbox_cmd[2] = LSDW(init_fw_cb_dma);
+	mbox_cmd[3] = MSDW(init_fw_cb_dma);
+
+	if (qla4xxx_mailbox_command(ha, 4, 1, &mbox_cmd[0], &mbox_sts[0])
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: Failed to get init_fw_ctrl_blk\n",
+				ha->host_no, __func__));
+		LEAVE(__func__);
+		pci_free_consistent(ha->pdev, sizeof(INIT_FW_CTRL_BLK),
+		    init_fw_cb, init_fw_cb_dma);
+		return QLA_ERROR;
+	}
+
+	/*
+	 * Save IP Address
+	 */
+	memcpy(ha->ip_address, init_fw_cb->IPAddr,
+	    MIN(sizeof(ha->ip_address), sizeof(init_fw_cb->IPAddr)));
+	memcpy(ha->subnet_mask, init_fw_cb->SubnetMask,
+	    MIN(sizeof(ha->subnet_mask), sizeof(init_fw_cb->SubnetMask)));
+	memcpy(ha->gateway, init_fw_cb->GatewayIPAddr,
+	    MIN(sizeof(ha->gateway), sizeof(init_fw_cb->GatewayIPAddr)));
+
+	QL4PRINT(QLP7, printk("scsi%d: %s: "
+	    "IP Address            %d.%d.%d.%d\n", ha->host_no,
+	    __func__, ha->ip_address[0], ha->ip_address[1],
+	    ha->ip_address[2], ha->ip_address[3]));
+	QL4PRINT(QLP7, printk("scsi%d: %s: "
+	    "Subnet Mask           %d.%d.%d.%d\n", ha->host_no,
+	    __func__, ha->subnet_mask[0], ha->subnet_mask[1],
+	    ha->subnet_mask[2], ha->subnet_mask[3]));
+	QL4PRINT(QLP7, printk("scsi%d: %s: "
+	    "Default Gateway       %d.%d.%d.%d\n", ha->host_no,
+	    __func__, ha->gateway[0], ha->gateway[1],
+	    ha->gateway[2], ha->gateway[3]));
+
+
+	pci_free_consistent(ha->pdev, sizeof(INIT_FW_CTRL_BLK), init_fw_cb,
+	    init_fw_cb_dma);
+
+	LEAVE(__func__);
+	return QLA_SUCCESS;
+}
+
+/**************************************************************************
+ * qla4xxx_get_firmware_state
+ *	This routine retrieves the firmware state for the specified adapter.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully retrieved firmware state
+ *	QLA_ERROR   - Failed to retrieve firmware state
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_get_firmware_state(scsi_qla_host_t *ha)
+{
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+
+	ENTER("qla4xxx_get_firmware_state");
+
+	/* Get firmware version */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_GET_FW_STATE;
+	if (qla4xxx_mailbox_command(ha, 1, 4, &mbox_cmd[0], &mbox_sts[0])
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: MBOX_CMD_GET_FW_STATE failed w/ "
+				"status %04X\n",
+				ha->host_no, __func__, mbox_sts[0]));
+		return(QLA_ERROR);
+	}
+
+	ha->firmware_state = mbox_sts[1];
+	ha->board_id       = mbox_sts[2];
+	ha->addl_fw_state  = mbox_sts[3];
+	DEBUG2(printk("scsi%d: %s firmware_state=0x%x\n",
+		      ha->host_no, __func__, ha->firmware_state);)
+	LEAVE("qla4xxx_get_firmware_state");
+	return(QLA_SUCCESS);
+}
+
+/**************************************************************************
+ * qla4xxx_get_firmware_status
+ *	This routine retrieves the firmware status for the specified adapter.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully retrieved firmware status
+ *	QLA_ERROR   - Failed to retrieve firmware status
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_get_firmware_status(scsi_qla_host_t *ha)
+{
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+
+	ENTER(__func__);
+
+	/* Get firmware version */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_GET_FW_STATUS;
+	if (qla4xxx_mailbox_command(ha, 1, 3, &mbox_cmd[0], &mbox_sts[0])
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: MBOX_CMD_GET_FW_STATUS failed w/ "
+				"status %04X\n",
+				ha->host_no, __func__, mbox_sts[0]));
+		return(QLA_ERROR);
+	}
+
+	/* High-water mark of IOCBs */
+	ha->iocb_hiwat = mbox_sts[2];
+	if (ha->iocb_hiwat > IOCB_HIWAT_CUSHION)
+		ha->iocb_hiwat -= IOCB_HIWAT_CUSHION;
+	else
+		ql4_printk(KERN_INFO, ha, "WARNING!!!  You have less "
+			   "than %d firmare IOCBs available (%d).\n",
+			   IOCB_HIWAT_CUSHION, ha->iocb_hiwat);
+
+	LEAVE(__func__);
+	return(QLA_SUCCESS);
+}
+
+/**************************************************************************
+ * qla4xxx_get_fwddb_entry
+ *	This routine retrieves the firmware's device database entry.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *      fw_ddb_index - Firmware's device database index
+ *      fw_ddb_entry - Pointer to firmware's device database entry structure
+ *      num_valid_ddb_entries - Pointer to number of valid ddb entries
+ *      next_ddb_index - Pointer to next valid device database index
+ *      fw_ddb_device_state - Pointer to device state
+ *
+ * Output:
+ *      fw_ddb_entry - Fills in structure if pointer is supplied
+ *      num_valid_ddb_entries - Fills in if pointer is supplied
+ *      next_ddb_index - Fills in if pointer is supplied
+ *      fw_ddb_device_state - Fills in if pointer is supplied
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully retrieved ddb info from firmware
+ *	QLA_ERROR   - Failed to retrieve ddb info from firmware
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_get_fwddb_entry(scsi_qla_host_t *ha,
+		      uint16_t        fw_ddb_index,
+		      DEV_DB_ENTRY    *fw_ddb_entry,
+		      dma_addr_t      fw_ddb_entry_dma,
+		      uint32_t        *num_valid_ddb_entries,
+		      uint32_t        *next_ddb_index,
+		      uint32_t        *fw_ddb_device_state,
+		      uint32_t        *conn_err_detail,
+		      uint16_t        *tcp_source_port_num,
+		      uint16_t        *connection_id)
+{
+	uint8_t         status = QLA_ERROR;
+	uint32_t	mbox_cmd[MBOX_REG_COUNT];
+	uint32_t	mbox_sts[MBOX_REG_COUNT];
+
+	ENTER(__func__);
+
+	/* Make sure the device index is valid */
+	if (fw_ddb_index >= MAX_DDB_ENTRIES) {
+		DEBUG2( printk("scsi%d: %s: index [%d] out of range.\n",
+				ha->host_no, __func__, fw_ddb_index));
+		goto exit_get_fwddb;
+	}
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_GET_DATABASE_ENTRY;
+	mbox_cmd[1] = (uint32_t) fw_ddb_index;
+	mbox_cmd[2] = LSDW(fw_ddb_entry_dma);
+	mbox_cmd[3] = MSDW(fw_ddb_entry_dma);
+
+	if (qla4xxx_mailbox_command(ha, 4, 7, &mbox_cmd[0], &mbox_sts[0])
+	    == QLA_ERROR) {
+		DEBUG2(printk("scsi%d: %s: MBOX_CMD_GET_DATABASE_ENTRY failed "
+		    "with status 0x%04X\n",
+		    ha->host_no, __func__, mbox_sts[0]));
+		goto exit_get_fwddb;
+	}
+
+	if (fw_ddb_index != mbox_sts[1]) {
+		DEBUG2(printk("scsi%d: %s: index mismatch [%d] != [%d].\n",
+		    ha->host_no, __func__, fw_ddb_index,
+		    mbox_sts[1]));
+		goto exit_get_fwddb;
+	}
+
+	if (fw_ddb_entry) {
+		ql4_printk(KERN_INFO, ha,
+		    "DDB[%d] MB0 %04x Tot %d Next %d "
+		    "State %04x ConnErr %08x %d.%d.%d.%d:%04d \"%s\"\n",
+		    fw_ddb_index,
+		    mbox_sts[0], mbox_sts[2], mbox_sts[3], mbox_sts[4], mbox_sts[5],
+		    fw_ddb_entry->ipAddr[0],
+		    fw_ddb_entry->ipAddr[1],
+		    fw_ddb_entry->ipAddr[2],
+		    fw_ddb_entry->ipAddr[3],
+		    le16_to_cpu(fw_ddb_entry->portNumber),
+		    fw_ddb_entry->iscsiName);
+	}
+
+	if (num_valid_ddb_entries)
+		*num_valid_ddb_entries = mbox_sts[2];
+
+	if (next_ddb_index)
+		*next_ddb_index = mbox_sts[3];
+
+	if (fw_ddb_device_state)
+		*fw_ddb_device_state = mbox_sts[4];
+	/* RA: This mailbox has been changed to pass connection error and details.
+	 * Its true for ISP4010 as per Version E - Not sure when it was changed.
+	 * Get the time2wait from the fw_dd_entry field : default_time2wait which
+ 	 * we call it as minTime2Wait DEV_DB_ENTRY struct.
+	 */
+	if (conn_err_detail)
+		*conn_err_detail = mbox_sts[5];
+
+	if (tcp_source_port_num)
+		*tcp_source_port_num = (uint16_t) mbox_sts[6] >> 16;
+
+	if (connection_id)
+		*connection_id = (uint16_t) mbox_sts[6] & 0x00FF;
+
+	status = QLA_SUCCESS;
+
+	exit_get_fwddb:
+
+	LEAVE(__func__);
+	return(status);
+}
+
+
+/**************************************************************************
+ * qla4xxx_set_fwddb_entry
+ *	This routine initializes or updates the adapter's device database
+ *	entry for the specified device.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *      fw_ddb_index - Firmware's device database index
+ *      fw_ddb_entry - Pointer to firmware's device database entry
+ *		       structure, or NULL.
+ *
+ * Output:
+ *	None
+ *
+ * Remarks:
+ *	This routine also triggers a login for the specified device.
+ *	Therefore, it may also be used as a secondary login routine when
+ *	a NULL pointer is specified for the fw_ddb_entry.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully set ddb_entry in firmware
+ *	QLA_ERROR   - Failed to set ddb_entry in firmware
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_set_ddb_entry(scsi_qla_host_t *ha,
+		      uint16_t        fw_ddb_index,
+		      DEV_DB_ENTRY    *fw_ddb_entry,
+		      dma_addr_t      fw_ddb_entry_dma)
+{
+	uint8_t         status = QLA_ERROR;
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+
+	ENTER("qla4xxx_set_fwddb_entry");
+
+	QL4PRINT(QLP7, printk("scsi%d: %s: index [%d]\n",
+			      ha->host_no, __func__, fw_ddb_index));
+
+	/* Do not wait for completion. The firmware will send us an
+	 * ASTS_DATABASE_CHANGED (0x8014) to notify us of the login status.
+	 */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_SET_DATABASE_ENTRY;
+	mbox_cmd[1] = (uint32_t) fw_ddb_index;
+	mbox_cmd[2] = LSDW(fw_ddb_entry_dma);
+	mbox_cmd[3] = MSDW(fw_ddb_entry_dma);
+
+	status = qla4xxx_mailbox_command(ha, 4, 1, &mbox_cmd[0], &mbox_sts[0]);
+	if (status == QLA_SUCCESS) {
+		QL4PRINT(QLP7, printk("scsi%d: %s: mbx[0] = 0x%04x\n",
+				      ha->host_no, __func__, mbox_sts[0]));
+	}
+
+	LEAVE("qla4xxx_set_fwddb_entry");
+	return(status);
+}
+
+uint8_t
+qla4xxx_conn_open_session_login(scsi_qla_host_t *ha,
+		      uint16_t        fw_ddb_index )
+{
+	uint8_t         status = QLA_ERROR;
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+
+	QL4PRINT(QLP7, printk("scsi%d: %s: index [%d]\n",
+			      ha->host_no, __func__, fw_ddb_index));
+
+	/* Do not wait for completion. The firmware will send us an
+	 * ASTS_DATABASE_CHANGED (0x8014) to notify us of the login status.
+	 */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_CONN_OPEN_SESS_LOGIN;
+	mbox_cmd[1] = (uint32_t) fw_ddb_index;
+	mbox_cmd[2] = 0;
+	mbox_cmd[3] = 0;
+	mbox_cmd[4] = 0;
+
+	if (qla4xxx_mailbox_command(ha, 4, 0, &mbox_cmd[0], &mbox_sts[0]) != QLA_SUCCESS) {
+		status = QLA_ERROR;
+	}
+	else {
+		status = QLA_SUCCESS;
+	}
+
+	printk("%s fw_ddb_index=%d status=%d mbx0_1=0x%x :0x%x\n",
+		__func__,fw_ddb_index, status, mbox_sts[0], mbox_sts[1]);
+	return(status);
+}
+
+/**************************************************************************
+ * qla4xxx_get_crash_record
+ *	This routine retrieves a crash record from the QLA4010 after an
+ *	8002h aen.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	None
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+void
+qla4xxx_get_crash_record(scsi_qla_host_t *ha)
+{
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+	CRASH_RECORD    *crash_record = NULL;
+	dma_addr_t      crash_record_dma = 0;
+	uint32_t        crash_record_size = 0;
+
+	ENTER("qla4xxx_get_crash_record");
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_cmd));
+
+	/*
+	 * Get size of crash record
+	 */
+	mbox_cmd[0] = MBOX_CMD_GET_CRASH_RECORD;
+
+	if (qla4xxx_mailbox_command(ha, 5, 5, &mbox_cmd[0], &mbox_sts[0])
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: ERROR: Unable to retrieve size!\n",
+				      ha->host_no, __func__));
+		goto exit_get_crash_record;
+	}
+
+	crash_record_size = mbox_sts[4];
+	if (crash_record_size == 0) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: ERROR: Crash record size is 0!\n",
+				      ha->host_no, __func__));
+		goto exit_get_crash_record;
+	}
+
+	/*
+	 * Alloc Memory for Crash Record
+	 */
+	crash_record = (CRASH_RECORD *) pci_alloc_consistent(ha->pdev,
+						crash_record_size,
+						&crash_record_dma);
+
+	if (crash_record == NULL){
+		QL4PRINT(QLP2, printk("scsi%d: %s: ERROR: Unable to allocate "
+				      " memory (%d bytes) for crash record!\n",
+				      ha->host_no, __func__, crash_record_size));
+		goto exit_get_crash_record;
+	}
+
+	/*
+	 * Get Crash Record
+	 */
+	mbox_cmd[0] = MBOX_CMD_GET_CRASH_RECORD;
+	mbox_cmd[2] = LSDW(crash_record_dma);
+	mbox_cmd[3] = MSDW(crash_record_dma);
+	mbox_cmd[4] = crash_record_size;
+
+	if (qla4xxx_mailbox_command(ha, 5, 5, &mbox_cmd[0], &mbox_sts[0])
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: ERROR: Unable to retrieve crash"
+				      " record!\n", ha->host_no, __func__));
+		goto exit_get_crash_record;
+	}
+
+	/*
+	 * Dump Crash Record
+	 */
+	QL4PRINT(QLP1, printk("scsi%d: Crash Record Dump:\n",
+			      ha->host_no));
+	QL4PRINT( QLP1,
+		  printk("Firmware Version: %02d.%02d.%02d.%02d\n",
+			 crash_record->fw_major_version,
+			 crash_record->fw_minor_version,
+			 crash_record->fw_patch_version,
+			 crash_record->fw_build_version));
+	QL4PRINT(QLP1, printk("Build Date: %s\n",
+			      crash_record->build_date));
+	QL4PRINT(QLP1, printk("Build Time: %s\n",
+			      crash_record->build_time));
+	QL4PRINT(QLP1, printk("Build User: %s\n",
+			      crash_record->build_user));
+	QL4PRINT(QLP1, printk("Card Serial #: %s\n",
+			      crash_record->card_serial_num));
+	QL4PRINT(QLP1, printk("Time of Crash (in seconds): %d (0x%x)\n",
+			crash_record->time_of_crash_in_secs,
+			crash_record->time_of_crash_in_secs));
+	QL4PRINT(QLP1, printk("Time of Crash (in milliseconds): "
+			"%d (0x%x)\n",
+			crash_record->time_of_crash_in_ms,
+			crash_record->time_of_crash_in_ms));
+	QL4PRINT(QLP1, printk("# frames in OUT RISC processor stack dump: "
+			"%d (0x%x)\n",
+			crash_record->out_RISC_sd_num_frames,
+			crash_record->out_RISC_sd_num_frames));
+	QL4PRINT(QLP1, printk("# words in OAP stack dump: %d (0x%x)\n",
+			crash_record->OAP_sd_num_words,
+			crash_record->OAP_sd_num_words));
+	QL4PRINT(QLP1, printk("# frames in IAP stack dump: %d (0x%x)\n",
+			crash_record->IAP_sd_num_frames,
+			crash_record->IAP_sd_num_frames));
+	QL4PRINT(QLP1, printk("# words in IN RISC processor stack dump: "
+			"%d (0x%x)\n",
+			crash_record->in_RISC_sd_num_words,
+			crash_record->in_RISC_sd_num_words));
+	QL4PRINT(QLP1, printk("\nOUT RISC processor register dump:\n"));
+	qla4xxx_dump_dwords(QLP1, &crash_record->out_RISC_reg_dump,
+			    sizeof(crash_record->out_RISC_reg_dump));
+	QL4PRINT(QLP1, printk("\nIN RISC processor register dump:\n"));
+	qla4xxx_dump_dwords(QLP1, &crash_record->in_RISC_reg_dump,
+			    sizeof(crash_record->in_RISC_reg_dump));
+	QL4PRINT(QLP1, printk("\nOUT RISC processor stack dump:\n"));
+	qla4xxx_dump_dwords(QLP1, &crash_record->in_out_RISC_stack_dump,
+			    crash_record->OAP_sd_num_words);
+	QL4PRINT(QLP1, printk("\nIN RISC processor stack dump:\n"));
+	qla4xxx_dump_dwords(QLP1, &crash_record->in_out_RISC_stack_dump[0] +
+			    crash_record->OAP_sd_num_words,
+			    crash_record->in_RISC_sd_num_words);
+
+
+	exit_get_crash_record:
+	if (crash_record)
+		pci_free_consistent(ha->pdev,
+				    crash_record_size,
+				    crash_record,
+				    crash_record_dma);
+	LEAVE("qla4xxx_get_crash_record");
+}
+
+/**************************************************************************
+ * qla4xxx_get_conn_event_log
+ *	This routine retrieves the connection event log
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	None
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+void
+qla4xxx_get_conn_event_log(scsi_qla_host_t *ha)
+{
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+	CONN_EVENT_LOG_ENTRY    *event_log = NULL;
+	dma_addr_t      event_log_dma = 0;
+	uint32_t        event_log_size = 0;
+	uint32_t	num_valid_entries;
+	uint32_t	oldest_entry = 0;
+	uint32_t	max_event_log_entries;
+	uint8_t		i;
+
+	ENTER(__func__);
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_cmd));
+
+	/*
+	 * Get size of crash record
+	 */
+	mbox_cmd[0] = MBOX_CMD_GET_CONN_EVENT_LOG;
+
+	if (qla4xxx_mailbox_command(ha, 4, 5, &mbox_cmd[0], &mbox_sts[0])
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: ERROR: Unable to retrieve size!\n",
+				      ha->host_no, __func__));
+		goto exit_get_event_log;
+	}
+
+	event_log_size = mbox_sts[4];
+	if (event_log_size == 0) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: ERROR: Event log size is 0!\n",
+				      ha->host_no, __func__));
+		goto exit_get_event_log;
+	}
+
+	/*
+	 * Alloc Memory for Crash Record
+	 */
+	event_log = (CONN_EVENT_LOG_ENTRY *) pci_alloc_consistent(ha->pdev,
+						event_log_size,
+						&event_log_dma);
+
+	if (event_log == NULL){
+		QL4PRINT(QLP2, printk("scsi%d: %s: ERROR: Unable to allocate "
+				      " memory (%d bytes) for event log!\n",
+				      ha->host_no, __func__, event_log_size));
+		goto exit_get_event_log;
+	}
+
+	/*
+	 * Get Crash Record
+	 */
+	mbox_cmd[0] = MBOX_CMD_GET_CONN_EVENT_LOG;
+	mbox_cmd[2] = LSDW(event_log_dma);
+	mbox_cmd[3] = MSDW(event_log_dma);
+
+	if (qla4xxx_mailbox_command(ha, 4, 5, &mbox_cmd[0], &mbox_sts[0])
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: ERROR: Unable to retrieve "
+				      "event log!\n", ha->host_no, __func__));
+		goto exit_get_event_log;
+	}
+
+	/*
+	 * Dump Event Log
+	 */
+	num_valid_entries = mbox_sts[1];
+	max_event_log_entries = event_log_size / sizeof(CONN_EVENT_LOG_ENTRY);
+
+	if (num_valid_entries > max_event_log_entries)
+		oldest_entry = num_valid_entries % max_event_log_entries;
+
+	QL4PRINT(QLP1, printk("scsi%d: Connection Event Log Dump (%d entries):\n",
+			      ha->host_no, num_valid_entries));
+
+	if (ql_dbg_level & QLP1) {
+		if (oldest_entry == 0) {
+			/* Circular Buffer has not wrapped around */
+			for (i=0; i < num_valid_entries; i++) {
+				qla4xxx_dump_buffer((uint8_t *)event_log+
+						    (i*sizeof(*event_log)),
+						    sizeof(*event_log));
+			}
+		}
+		else {
+			/* Circular Buffer has wrapped around - display accordingly*/
+			for (i=oldest_entry; i < max_event_log_entries; i++) {
+				qla4xxx_dump_buffer((uint8_t *)event_log+
+						    (i*sizeof(*event_log)),
+						    sizeof(*event_log));
+			}
+			for (i=0; i < oldest_entry; i++) {
+				qla4xxx_dump_buffer((uint8_t *)event_log+
+						    (i*sizeof(*event_log)),
+						    sizeof(*event_log));
+			}
+		}
+	}
+
+	exit_get_event_log:
+	if (event_log)
+		pci_free_consistent(ha->pdev,
+				    event_log_size,
+				    event_log,
+				    event_log_dma);
+	LEAVE(__func__);
+}
+
+/**************************************************************************
+ * qla4xxx_reset_lun
+ *	This routine performs a LUN RESET on the specified target/lun.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	ddb_entry - Pointer to device database entry
+ *	lun_entry - Pointer to lun entry structure
+ *
+ * Remarks:
+ *	The caller must ensure that the ddb_entry and lun_entry pointers
+ *	are valid before calling this routine.
+ *
+ * Returns:
+ *	QLA_SUCCESS - lun reset completed successfully
+ *	QLA_ERROR   - lun reset failed
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_reset_lun(scsi_qla_host_t *ha,
+		  ddb_entry_t *ddb_entry,
+		  fc_lun_t *lun_entry)
+{
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+	uint8_t target = ddb_entry->target;
+	uint8_t lun = lun_entry->lun;
+	uint8_t status = QLA_SUCCESS;
+
+	ENTER("qla4xxx_reset_lun");
+
+	//spin_unlock_irq(ha->host->host_lock);
+
+	QL4PRINT(QLP2, printk("scsi%d:%d:%d:%d: lun reset issued\n",
+			      ha->host_no, ddb_entry->bus, target, lun));
+
+	/*
+	 * Send lun reset command to ISP, so that the ISP will return all
+	 * outstanding requests with RESET status
+	 */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_LUN_RESET;
+	mbox_cmd[1] = ddb_entry->fw_ddb_index;
+	mbox_cmd[2] = lun << 8;
+	mbox_cmd[5] = 0x01; /* Immediate Command Enable */
+
+	qla4xxx_mailbox_command(ha, 6, 1, &mbox_cmd[0], &mbox_sts[0]);
+	if ((mbox_sts[0] == MBOX_STS_COMMAND_COMPLETE) ||
+	    (mbox_sts[0] == MBOX_STS_COMMAND_ERROR)) {
+		QL4PRINT(QLP2, printk(
+		    "scsi%d:%d:%d:%d: lun reset SUCCEEDED\n", ha->host_no,
+		    ddb_entry->bus, target, lun));
+	} else {
+		QL4PRINT(QLP2, printk(
+		    "scsi%d:%d:%d:%d: lun reset FAILED w/ status %04x\n",
+		    ha->host_no, ddb_entry->bus, target, lun, mbox_sts[0]));
+
+		status = QLA_ERROR;
+	}
+
+	//spin_lock_irq(ha->host->host_lock);
+
+	LEAVE("qla4xxx_reset_lun");
+
+	return (status);
+}
+
+uint8_t
+qla4xxx_isns_enable(scsi_qla_host_t *ha,
+		    uint32_t isns_ip_addr,
+		    uint16_t isns_server_port_num)
+{
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+
+	QL4PRINT(QLP20, printk("scsi%d: %s: isns_ip_addr %08x\n",
+			       ha->host_no, __func__, isns_ip_addr));
+
+	qla4xxx_isns_build_entity_id(ha);
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_SET_ISNS_SERVICE;
+	mbox_cmd[1] = ISNS_ENABLE;
+	mbox_cmd[2] = isns_ip_addr;
+	mbox_cmd[3] = isns_server_port_num;
+
+	if (qla4xxx_mailbox_command(ha, 4, 6, &mbox_cmd[0], &mbox_sts[0])
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: MBOX_CMD_SET_ISNS_SERVICE failed "
+				"w/ status %04X %04X\n",
+				ha->host_no, __func__, mbox_sts[0], mbox_sts[1]));
+		return(QLA_ERROR);
+	}
+
+	QL4PRINT(QLP7|QLP20, printk("scsi%d: Start iSNS Service "
+				    "%d.%d.%d.%d Port %04d . . .\n", ha->host_no,
+				    (isns_ip_addr & 0x000000FF),
+				    (isns_ip_addr & 0x0000FF00) >> 8,
+				    (isns_ip_addr & 0x00FF0000) >> 16,
+				    (isns_ip_addr & 0xFF000000) >> 24,
+				    isns_server_port_num));
+
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_disable(scsi_qla_host_t *ha)
+{
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+
+	if (test_bit(ISNS_FLAG_ISNS_SRV_ENABLED, &ha->isns_flags)) {
+		memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+		memset(&mbox_sts, 0, sizeof(mbox_sts));
+		mbox_cmd[0] = MBOX_CMD_SET_ISNS_SERVICE;
+		mbox_cmd[1] = ISNS_DISABLE;
+
+		if (qla4xxx_mailbox_command(ha, 2, 2, &mbox_cmd[0], &mbox_sts[0])
+		    != QLA_SUCCESS) {
+			QL4PRINT(QLP2,
+				 printk("scsi%d: %s: MBOX_CMD_SET_ISNS_SERVICE failed "
+					"w/ status %04X %04X\n",
+					ha->host_no, __func__, mbox_sts[0], mbox_sts[1]));
+			return(QLA_ERROR);
+		}
+	}
+
+	clear_bit(ISNS_FLAG_ISNS_SRV_ENABLED, &ha->isns_flags);
+	ISNS_CLEAR_FLAGS(ha);
+
+	ha->isns_connection_id   = 0;
+	//ha->isns_scn_conn_id     = 0;
+	//ha->isns_esi_conn_id     = 0;
+	//ha->isns_nsh_conn_id     = 0;
+
+	ha->isns_remote_port_num = 0;
+	ha->isns_scn_port_num    = 0;
+	ha->isns_esi_port_num    = 0;
+	ha->isns_nsh_port_num    = 0;
+
+	ha->isns_num_discovered_targets = 0;
+	memset(ha->isns_entity_id, 0, sizeof(ha->isns_entity_id));
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_status(scsi_qla_host_t *ha)
+{
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_SET_ISNS_SERVICE;
+	mbox_cmd[1] = ISNS_STATUS;
+
+	if (qla4xxx_mailbox_command(ha, 2, 2, &mbox_cmd[0], &mbox_sts[0])
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: MBOX_CMD_SET_ISNS_SERVICE failed "
+				"w/ status %04X %04X\n",
+				ha->host_no, __func__, mbox_sts[0], mbox_sts[1]));
+		return(QLA_ERROR);
+	}
+
+	QL4PRINT(QLP20, printk("scsi%d: %s: = %s\n",
+			       ha->host_no, __func__,
+			       ((mbox_sts[1] & 1) == 0) ? "DISABLED" : "ENABLED"));
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_get_flash(scsi_qla_host_t *ha, dma_addr_t dma_addr, uint32_t offset, uint32_t len)
+{
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+
+	mbox_cmd[0] = MBOX_CMD_READ_FLASH;
+	mbox_cmd[1] = LSDW(dma_addr);
+	mbox_cmd[2] = MSDW(dma_addr);
+	mbox_cmd[3] = offset;
+	mbox_cmd[4] = len;
+
+	if (qla4xxx_mailbox_command(ha, 5, 2, &mbox_cmd[0], &mbox_sts[0])
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: MBOX_CMD_READ_FLASH, failed w/ "
+				      "status %04X %04X, offset %08x, len %08x\n",
+				      ha->host_no, __func__, mbox_sts[0], mbox_sts[1],
+				      offset, len));
+		return(QLA_ERROR);
+	}
+	return(QLA_SUCCESS);
+}
+
+/**************************************************************************
+ * qla4xxx_get_fw_version
+ *	This routine retrieves the firmware version for the specified adapter.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Output:
+ *	None
+ *
+ * Remarks:
+ *	In QLA4010, mailboxes 2 & 3 may hold an address for data.  Make sure
+ *	that we write 0 to those mailboxes, if unused.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully retrieved firmware version
+ *	QLA_ERROR   - Failed to retrieve firmware version
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_get_fw_version(scsi_qla_host_t *ha)
+{
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+
+	/*
+	 * Get firmware version
+	 */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_ABOUT_FW;
+	if (qla4xxx_mailbox_command(ha, 4, 5, &mbox_cmd[0], &mbox_sts[0])
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: MBOX_CMD_ABOUT_FW failed w/ "
+				      "status %04X\n",
+				      ha->host_no, __func__, mbox_sts[0]));
+		return(QLA_ERROR);
+	}
+
+	/*
+	 * Save firmware version information
+	 */
+	ha->firmware_version[0] = mbox_sts[1];
+	ha->firmware_version[1] = mbox_sts[2];
+	ha->patch_number        = mbox_sts[3];
+	ha->build_number        = mbox_sts[4];
+
+	QL4PRINT(QLP7, printk("scsi%d: FW Version %02d.%02d Patch %02d Build %02d\n",
+			      ha->host_no, ha->firmware_version[0], ha->firmware_version[1],
+			      ha->patch_number, ha->build_number));
+
+	return(QLA_SUCCESS);
+}
+
+/**************************************************************************
+ * qla4xxx_restore_factory_defaults
+ *	This routine restores the factory defaults for the specified adapter.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully restored defaults
+ *	QLA_ERROR   - Failed to restore defaults
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_restore_factory_defaults(scsi_qla_host_t *ha, uint32_t block_mask, uint32_t ifcb_mask)
+{
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_RESTORE_FACTORY_DEFAULTS;
+	mbox_cmd[3] = block_mask;
+        mbox_cmd[4] = ifcb_mask;
+
+	if (qla4xxx_mailbox_command(ha, 5, 1, &mbox_cmd[0], &mbox_sts[0])
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: MBOX_CMD_RESTORE_FACTORY_DEFAULTS"
+				      " failed w/ status %04X\n",
+				      ha->host_no, __func__, mbox_sts[0]));
+		return(QLA_ERROR);
+	}
+
+	return(QLA_SUCCESS);
+}
+
+/*
+ * Overrides for Emacs so that we almost follow Linus's tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 2
+ * c-brace-imaginary-offset: 0
+ * c-brace-offset: -2
+ * c-argdecl-indent: 2
+ * c-label-offset: -2
+ * c-continued-statement-offset: 2
+ * c-continued-brace-offset: 0
+ * indent-tabs-mode: nil
+ * tab-width: 8
+ * End:
+ */
+
diff --git a/drivers/scsi/qla4xxx/ql4_nvram.c b/drivers/scsi/qla4xxx/ql4_nvram.c
new file mode 100644
index 0000000..e356fbd
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_nvram.c
@@ -0,0 +1,279 @@
+/******************************************************************************
+ *     Copyright (C)  2003 -2005 QLogic Corporation
+ * QLogic ISP4xxx Device Driver
+ *
+ * This program includes a device driver for Linux 2.6.x that may be
+ * distributed with QLogic hardware specific firmware binary file.
+ * You may modify and redistribute the device driver code under the
+ * GNU General Public License as published by the Free Software Foundation
+ * (version 2 or a later version) and/or under the following terms,
+ * as applicable:
+ *
+ * 	1. Redistribution of source code must retain the above copyright
+ *         notice, this list of conditions and the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above copyright
+ *         notice, this list of conditions and the following disclaimer in
+ *         the documentation and/or other materials provided with the
+ *         distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ * 	
+ * You may redistribute the hardware specific firmware binary file under
+ * the following terms:
+ * 	1. Redistribution of source code (only if applicable), must
+ *         retain the above copyright notice, this list of conditions and
+ *         the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above
+ *         copyright notice, this list of conditions and the following
+ *         disclaimer in the documentation and/or other materials provided
+ *         with the distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ *
+ * REGARDLESS OF WHAT LICENSING MECHANISM IS USED OR APPLICABLE,
+ * THIS PROGRAM IS PROVIDED BY QLOGIC CORPORATION "AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * USER ACKNOWLEDGES AND AGREES THAT USE OF THIS PROGRAM WILL NOT CREATE
+ * OR GIVE GROUNDS FOR A LICENSE BY IMPLICATION, ESTOPPEL, OR OTHERWISE
+ * IN ANY INTELLECTUAL PROPERTY RIGHTS (PATENT, COPYRIGHT, TRADE SECRET,
+ * MASK WORK, OR OTHER PROPRIETARY RIGHT) EMBODIED IN ANY OTHER QLOGIC
+ * HARDWARE OR SOFTWARE EITHER SOLELY OR IN COMBINATION WITH THIS PROGRAM
+ *
+ ******************************************************************************
+ *             Please see release.txt for revision history.                   *
+ *                                                                            *
+ ******************************************************************************
+ * Function Table of Contents:
+ *	FM93C56A_Select
+ *	FM93C56A_Cmd
+ *	FM93C56A_Deselect
+ *	FM93C56A_DataIn
+ *	EEPROM_ReadWord
+ *	RD_NVRAM_WORD
+ ****************************************************************************/
+
+#include "ql4_def.h"
+
+#define EEPROM_SIZE(ha) \
+	(IS_QLA4022(ha) ? \
+	 FM93C86A_SIZE_16 : \
+	 FM93C66A_SIZE_16)
+	
+#define EEPROM_NO_ADDR_BITS(ha) \
+	(IS_QLA4022(ha) ? \
+	 FM93C86A_NO_ADDR_BITS_16 : \
+	 FM93C56A_NO_ADDR_BITS_16)
+
+#define EEPROM_NO_DATA_BITS(ha) FM93C56A_DATA_BITS_16
+
+int   eepromCmdData = 0;
+
+
+static int FM93C56A_Select(scsi_qla_host_t *ha)
+{
+	QL4PRINT(QLP17, printk(KERN_ERR "FM93C56A_Select:\n"));
+	eepromCmdData = AUBURN_EEPROM_CS_1 | 0x000f0000;
+	WRT_REG_DWORD(ISP_NVRAM(ha), eepromCmdData);
+	PCI_POSTING(ISP_NVRAM(ha));
+	return(1);
+}
+
+static int FM93C56A_Cmd(scsi_qla_host_t *ha, int cmd, int addr)
+{
+	int   i;
+	int   mask;
+	int   dataBit;
+	int   previousBit;
+
+	QL4PRINT(QLP17, printk(KERN_ERR "FM93C56A_Cmd(%d, 0x%x)\n", cmd, addr));
+
+	// Clock in a zero, then do the start bit
+	WRT_REG_DWORD(ISP_NVRAM(ha), eepromCmdData | AUBURN_EEPROM_DO_1);
+	WRT_REG_DWORD(ISP_NVRAM(ha), eepromCmdData | AUBURN_EEPROM_DO_1 | AUBURN_EEPROM_CLK_RISE);
+	WRT_REG_DWORD(ISP_NVRAM(ha), eepromCmdData | AUBURN_EEPROM_DO_1 | AUBURN_EEPROM_CLK_FALL);
+	PCI_POSTING(ISP_NVRAM(ha));
+
+	mask = 1 << (FM93C56A_CMD_BITS-1);
+	// Force the previous data bit to be different
+	previousBit = 0xffff;
+	for (i = 0; i < FM93C56A_CMD_BITS; i++) {
+		dataBit = (cmd & mask) ? AUBURN_EEPROM_DO_1 : AUBURN_EEPROM_DO_0;
+		if (previousBit != dataBit) {
+			// If the bit changed, then change the DO state to match
+			WRT_REG_DWORD(ISP_NVRAM(ha), eepromCmdData | dataBit);
+			previousBit = dataBit;
+		}
+		WRT_REG_DWORD(ISP_NVRAM(ha), eepromCmdData | dataBit | AUBURN_EEPROM_CLK_RISE);
+		WRT_REG_DWORD(ISP_NVRAM(ha), eepromCmdData | dataBit | AUBURN_EEPROM_CLK_FALL);
+		PCI_POSTING(ISP_NVRAM(ha));
+		cmd = cmd << 1;
+	}
+
+	mask = 1 << (EEPROM_NO_ADDR_BITS(ha)-1);
+	// Force the previous data bit to be different
+	previousBit = 0xffff;
+	for (i = 0; i < EEPROM_NO_ADDR_BITS(ha); i++) {
+		dataBit = (addr & mask) ? AUBURN_EEPROM_DO_1 : AUBURN_EEPROM_DO_0;
+		if (previousBit != dataBit) {
+			// If the bit changed, then change the DO state to match
+			WRT_REG_DWORD(ISP_NVRAM(ha), eepromCmdData | dataBit);
+			previousBit = dataBit;
+		}
+		WRT_REG_DWORD(ISP_NVRAM(ha), eepromCmdData | dataBit | AUBURN_EEPROM_CLK_RISE);
+		WRT_REG_DWORD(ISP_NVRAM(ha), eepromCmdData | dataBit | AUBURN_EEPROM_CLK_FALL);
+		PCI_POSTING(ISP_NVRAM(ha));
+		addr = addr << 1;
+	}
+	return(1);
+}
+
+static int FM93C56A_Deselect(scsi_qla_host_t *ha)
+{
+	QL4PRINT(QLP17, printk(KERN_ERR "FM93C56A_Deselect:\n"));
+	eepromCmdData = AUBURN_EEPROM_CS_0 | 0x000f0000 ;
+	WRT_REG_DWORD(ISP_NVRAM(ha), eepromCmdData);
+	PCI_POSTING(ISP_NVRAM(ha));
+	return(1);
+}
+
+static int FM93C56A_DataIn(scsi_qla_host_t *ha, unsigned short *value)
+{
+	int   i;
+	int   data = 0;
+	int   dataBit;
+
+	// Read the data bits
+	// The first bit is a dummy.  Clock right over it.
+	for (i = 0; i < EEPROM_NO_DATA_BITS(ha); i++) {
+		WRT_REG_DWORD(ISP_NVRAM(ha), eepromCmdData | AUBURN_EEPROM_CLK_RISE);
+		WRT_REG_DWORD(ISP_NVRAM(ha), eepromCmdData | AUBURN_EEPROM_CLK_FALL);
+		dataBit = (RD_REG_DWORD(ISP_NVRAM(ha)) & AUBURN_EEPROM_DI_1) ? 1 : 0;
+		data = (data << 1) | dataBit;
+	}
+	*value = data;
+	QL4PRINT(QLP17, printk(KERN_ERR "FM93C56A_DataIn(0x%x)\n", *value));
+	return(1);
+}
+
+static int
+EEPROM_ReadWord(int eepromAddr, u16 *value, scsi_qla_host_t *ha)
+{
+	QL4PRINT(QLP17, printk(KERN_ERR "EEPROM_Reg addr %p\n", ISP_NVRAM(ha)));
+	QL4PRINT(QLP17, printk(KERN_ERR "EEPROM_ReadWord(0x%x)\n", eepromAddr));
+
+	FM93C56A_Select(ha);
+	FM93C56A_Cmd(ha, FM93C56A_READ, eepromAddr);
+	FM93C56A_DataIn(ha, value);
+	FM93C56A_Deselect(ha);
+	QL4PRINT(QLP17, printk(KERN_ERR "EEPROM_ReadWord(0x%x, %d)\n",
+			       eepromAddr, *value));
+	return(1);
+}
+
+/* Hardware_lock must be set before calling */
+u16
+RD_NVRAM_WORD(scsi_qla_host_t *ha, int offset)
+{
+	u16 val;
+	/* NOTE: NVRAM uses half-word addresses */
+	EEPROM_ReadWord(offset, &val, ha);
+	return(val);
+}
+
+uint8_t
+qla4xxx_is_NVRAM_configuration_valid(scsi_qla_host_t *ha)
+{
+	uint16_t checksum = 0;
+	uint32_t index;
+	unsigned long flags;
+	uint8_t status = QLA_ERROR;
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	for (index = 0;	index < EEPROM_SIZE(ha); index++) {
+		checksum += RD_NVRAM_WORD(ha, index);
+	}
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	if (checksum == 0)
+		status = QLA_SUCCESS;
+
+	return (status);
+}
+
+/*************************************************************************
+ *
+ *			Hardware Semaphore routines
+ *
+ *************************************************************************/
+int ql4xxx_sem_spinlock(scsi_qla_host_t *ha, u32 sem_mask, u32 sem_bits)
+{
+    uint32_t      value;
+
+    DEBUG2(printk("scsi%d: Trying to get SEM lock - mask= 0x%x, code = 0x%x\n",
+	ha->host_no, sem_mask, sem_bits);)
+    while ( 1 ) {
+        WRT_REG_DWORD(ISP_SEMAPHORE(ha), (sem_mask | sem_bits));
+        value = RD_REG_DWORD(ISP_SEMAPHORE(ha));
+        if ((value & (sem_mask >> 16)) == sem_bits) {
+    		DEBUG2(printk("scsi%d: Got SEM LOCK - mask= 0x%x, code = 0x%x\n",
+		ha->host_no, sem_mask, sem_bits);)
+            break;
+	}
+    }
+   return (1);
+}
+
+void ql4xxx_sem_unlock(scsi_qla_host_t *ha, u32 sem_mask)
+{
+
+    WRT_REG_DWORD(ISP_SEMAPHORE(ha), sem_mask);
+    PCI_POSTING(ISP_SEMAPHORE(ha));
+    DEBUG2(printk("scsi%d: UNLOCK SEM - mask= 0x%x\n",
+	 ha->host_no, sem_mask);)
+}
+
+int ql4xxx_sem_lock(scsi_qla_host_t *ha, u32 sem_mask, u32 sem_bits)
+{
+    uint32_t      value;
+
+    WRT_REG_DWORD(ISP_SEMAPHORE(ha), (sem_mask | sem_bits));
+    value = RD_REG_DWORD(ISP_SEMAPHORE(ha));
+    if ((value & (sem_mask >> 16)) == sem_bits) {
+    	DEBUG2(printk("scsi%d: Got SEM LOCK - mask= 0x%x, code = 0x%x, sema code=0x%x\n",
+		ha->host_no, sem_mask, sem_bits, value);)
+        return (1);
+    } else {
+        return (0);
+    }
+}
+
+/*
+ * Overrides for Emacs so that we get a uniform tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 4
+ * c-brace-imaginary-offset: 0
+ * c-brace-offset: -4
+ * c-argdecl-indent: 4
+ * c-label-offset: -4
+ * c-continued-statement-offset: 4
+ * c-continued-brace-offset: 0
+ * indent-tabs-mode: nil
+ * tab-width: 8
+ * End:
+ */
diff --git a/drivers/scsi/qla4xxx/ql4_nvram.h b/drivers/scsi/qla4xxx/ql4_nvram.h
new file mode 100644
index 0000000..29cd8e0
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_nvram.h
@@ -0,0 +1,406 @@
+/******************************************************************************
+ *     Copyright (C)  2003 -2005 QLogic Corporation
+ * QLogic ISP4xxx Device Driver
+ *
+ * This program includes a device driver for Linux 2.6.x that may be
+ * distributed with QLogic hardware specific firmware binary file.
+ * You may modify and redistribute the device driver code under the
+ * GNU General Public License as published by the Free Software Foundation
+ * (version 2 or a later version) and/or under the following terms,
+ * as applicable:
+ *
+ * 	1. Redistribution of source code must retain the above copyright
+ *         notice, this list of conditions and the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above copyright
+ *         notice, this list of conditions and the following disclaimer in
+ *         the documentation and/or other materials provided with the
+ *         distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ * 	
+ * You may redistribute the hardware specific firmware binary file under
+ * the following terms:
+ * 	1. Redistribution of source code (only if applicable), must
+ *         retain the above copyright notice, this list of conditions and
+ *         the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above
+ *         copyright notice, this list of conditions and the following
+ *         disclaimer in the documentation and/or other materials provided
+ *         with the distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ *
+ * REGARDLESS OF WHAT LICENSING MECHANISM IS USED OR APPLICABLE,
+ * THIS PROGRAM IS PROVIDED BY QLOGIC CORPORATION "AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * USER ACKNOWLEDGES AND AGREES THAT USE OF THIS PROGRAM WILL NOT CREATE
+ * OR GIVE GROUNDS FOR A LICENSE BY IMPLICATION, ESTOPPEL, OR OTHERWISE
+ * IN ANY INTELLECTUAL PROPERTY RIGHTS (PATENT, COPYRIGHT, TRADE SECRET,
+ * MASK WORK, OR OTHER PROPRIETARY RIGHT) EMBODIED IN ANY OTHER QLOGIC
+ * HARDWARE OR SOFTWARE EITHER SOLELY OR IN COMBINATION WITH THIS PROGRAM
+ *
+ ******************************************************************************/
+/*
+ * Module Name: ql4nvrm.h
+ */
+
+
+#ifndef _QL2XNVRM_H_
+#define _QL2XNVRM_H_
+
+
+//
+// AM29LV Flash definitions
+//
+#define  FM93C56A_SIZE_8      0x100
+#define  FM93C56A_SIZE_16     0x80
+#define  FM93C66A_SIZE_8      0x200
+#define  FM93C66A_SIZE_16     0x100  /* 4010 */
+#define  FM93C86A_SIZE_16     0x400  /* 4022 */
+	
+#define  FM93C56A_START       0x1
+
+// Commands
+#define  FM93C56A_READ        0x2
+#define  FM93C56A_WEN         0x0
+#define  FM93C56A_WRITE       0x1
+#define  FM93C56A_WRITE_ALL   0x0
+#define  FM93C56A_WDS         0x0
+#define  FM93C56A_ERASE       0x3
+#define  FM93C56A_ERASE_ALL   0x0
+
+// Command Extentions
+#define  FM93C56A_WEN_EXT        0x3
+#define  FM93C56A_WRITE_ALL_EXT  0x1
+#define  FM93C56A_WDS_EXT        0x0
+#define  FM93C56A_ERASE_ALL_EXT  0x2
+
+// Address Bits
+#define  FM93C56A_NO_ADDR_BITS_16   8  /* 4010 */
+#define  FM93C56A_NO_ADDR_BITS_8    9  /* 4010 */
+#define  FM93C86A_NO_ADDR_BITS_16   10 /* 4022 */
+
+
+// Data Bits
+#define  FM93C56A_DATA_BITS_16   16
+#define  FM93C56A_DATA_BITS_8    8
+
+// Special Bits
+#define  FM93C56A_READ_DUMMY_BITS   1
+#define  FM93C56A_READY             0
+#define  FM93C56A_BUSY              1
+#define  FM93C56A_CMD_BITS          2
+
+// Auburn Bits
+#define  AUBURN_EEPROM_DI           0x8
+#define  AUBURN_EEPROM_DI_0         0x0
+#define  AUBURN_EEPROM_DI_1         0x8
+#define  AUBURN_EEPROM_DO           0x4
+#define  AUBURN_EEPROM_DO_0         0x0
+#define  AUBURN_EEPROM_DO_1         0x4
+#define  AUBURN_EEPROM_CS           0x2
+#define  AUBURN_EEPROM_CS_0         0x0
+#define  AUBURN_EEPROM_CS_1         0x2
+#define  AUBURN_EEPROM_CLK_RISE     0x1
+#define  AUBURN_EEPROM_CLK_FALL     0x0
+
+
+//
+// EEPROM format
+//
+typedef struct _BIOS_PARAMS
+{
+    UINT16  SpinUpDelay                  :1;
+    UINT16  BIOSDisable                  :1;
+    UINT16  MMAPEnable                   :1;
+    UINT16  BootEnable                   :1;
+    UINT16  Reserved0                    :12;
+
+    UINT8   bootID0                      :7;
+    UINT8   bootID0Valid                 :1;
+
+    UINT8   bootLUN0[8];
+
+    UINT8   bootID1                      :7;
+    UINT8   bootID1Valid                 :1;
+
+    UINT8   bootLUN1[8];
+
+    UINT16  MaxLunsPerTarget;
+    UINT8   Reserved1[10];
+} BIOS_PARAMS, *PBIOS_PARAMS;
+
+typedef struct _EEPROM_PORT_CFG
+{
+   // MTU MAC 0
+   u16               etherMtu_mac;
+
+   // Flow Control MAC 0
+   u16               pauseThreshold_mac;
+   u16               resumeThreshold_mac;
+   u16               reserved[13];
+} EEPROM_PORT_CFG, *PEEPROM_PORT_CFG;
+
+typedef struct _EEPROM_FUNCTION_CFG
+{
+   u8                reserved[30];
+
+   // MAC ADDR
+   u8                macAddress[6];
+   u8                macAddressSecondary[6];
+
+   u16               subsysVendorId;
+   u16               subsysDeviceId;
+} EEPROM_FUNCTION_CFG;
+
+typedef struct {
+	union {
+		struct { /* isp4010 */
+			u8    asic_id[4];				// x00
+			u8    version;					// x04
+			u8    reserved;					// x05
+
+			u16   board_id;					// x06
+		     #  define   EEPROM_BOARDID_ELDORADO    1
+		     #  define   EEPROM_BOARDID_PLACER      2
+
+		     #  define EEPROM_SERIAL_NUM_SIZE       16
+			u8    serial_number[EEPROM_SERIAL_NUM_SIZE];	// x08
+
+		     // ExtHwConfig:
+		     // Offset = 24bytes
+		     //
+		     // | SSRAM Size|     |ST|PD|SDRAM SZ| W| B| SP  |  |
+		     // |15|14|13|12|11|10| 9| 8 | 7| 6| 5| 4| 3| 2| 1| 0|
+		     // +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+			u16   ext_hw_conf;				// x18
+
+			u8    mac0[6];					// x1A
+			u8    mac1[6];					// x20
+			u8    mac2[6];					// x26
+			u8    mac3[6];					// x2C
+	
+			u16   etherMtu;					// x32
+			u16   macConfig;				// x34
+		     #define  MAC_CONFIG_ENABLE_ANEG     0x0001
+		     #define  MAC_CONFIG_ENABLE_PAUSE    0x0002
+
+			u16   phyConfig;				// x36
+		     #define  PHY_CONFIG_PHY_ADDR_MASK             0x1f
+		     #define  PHY_CONFIG_ENABLE_FW_MANAGEMENT_MASK 0x20
+
+		        u16   topcat;					// x38
+		     #define TOPCAT_PRESENT		0x0100
+		     #define TOPCAT_MASK		0xFF00
+
+		     #  define EEPROM_UNUSED_1_SIZE   2
+			u8    unused_1[EEPROM_UNUSED_1_SIZE];		// x3A
+
+			u16   bufletSize;				// x3C
+			u16   bufletCount;				// x3E
+			u16   bufletPauseThreshold;			// x40
+			u16   tcpWindowThreshold50;			// x42
+			u16   tcpWindowThreshold25;			// x44
+			u16   tcpWindowThreshold0;			// x46
+			u16   ipHashTableBaseHi;			// x48
+			u16   ipHashTableBaseLo;			// x4A
+			u16   ipHashTableSize;				// x4C
+			u16   tcpHashTableBaseHi;			// x4E
+			u16   tcpHashTableBaseLo;			// x50
+			u16   tcpHashTableSize;				// x52
+			u16   ncbTableBaseHi;                        	// x54
+			u16   ncbTableBaseLo;                        	// x56
+			u16   ncbTableSize;                          	// x58
+			u16   drbTableBaseHi;                        	// x5A
+			u16   drbTableBaseLo;                        	// x5C
+			u16   drbTableSize;                          	// x5E
+
+		     #  define EEPROM_UNUSED_2_SIZE   4
+			u8    unused_2[EEPROM_UNUSED_2_SIZE];        	// x60
+
+			u16   ipReassemblyTimeout;                   	// x64
+			u16   tcpMaxWindowSizeHi;                    	// x66
+			u16   tcpMaxWindowSizeLo;                    	// x68
+
+			u32   net_ip_addr0 ;	               		// x6A /* Added for TOE functionality. */
+			u32   net_ip_addr1 ;	                        // x6E
+			u32   scsi_ip_addr0 ;	                	// x72
+			u32   scsi_ip_addr1 ;	                	// x76
+		     #  define EEPROM_UNUSED_3_SIZE   128	/* changed from 144 to account for ip addresses */
+			u8    unused_3[EEPROM_UNUSED_3_SIZE];        	// x7A
+
+			u16   subsysVendorId_f0;                     	// xFA
+			u16   subsysDeviceId_f0;                     	// xFC
+
+			// Address = 0x7F
+		     #  define FM93C56A_SIGNATURE  0x9356
+		     #  define FM93C66A_SIGNATURE  0x9366
+			u16   signature;                             	// xFE
+
+		     #  define EEPROM_UNUSED_4_SIZE   250
+			u8    unused_4[EEPROM_UNUSED_4_SIZE];        	// x100
+
+			u16   subsysVendorId_f1;                     	// x1FA
+			u16   subsysDeviceId_f1;                     	// x1FC
+
+			u16   checksum;                              	// x1FE
+		} __attribute__((packed)) isp4010;
+
+		struct { /* isp4022 */
+			u8                asicId[4];                    // x00
+			u8                version;                      // x04
+			u8                reserved_5;                   // x05
+
+			u16               boardId;                      // x06
+			u8                boardIdStr[16];               // x08
+			u8                serialNumber[16];             // x18
+
+			// External Hardware Configuration
+			u16               ext_hw_conf;                  // x28
+
+			// MAC 0 CONFIGURATION
+			EEPROM_PORT_CFG macCfg_port0;                   // x2A
+
+			// MAC 1 CONFIGURATION
+			EEPROM_PORT_CFG macCfg_port1;                   // x4A
+
+			// DDR SDRAM Configuration
+			u16               bufletSize;                   // x6A
+			u16               bufletCount;                  // x6C
+			u16               tcpWindowThreshold50;		// x6E
+			u16               tcpWindowThreshold25;         // x70
+			u16               tcpWindowThreshold0;          // x72
+			u16               ipHashTableBaseHi;            // x74
+			u16               ipHashTableBaseLo;            // x76
+			u16               ipHashTableSize;              // x78
+			u16               tcpHashTableBaseHi;           // x7A
+			u16               tcpHashTableBaseLo;           // x7C
+			u16               tcpHashTableSize;             // x7E
+			u16               ncbTableBaseHi;               // x80
+			u16               ncbTableBaseLo;               // x82
+			u16               ncbTableSize;                 // x84
+			u16               drbTableBaseHi;               // x86
+			u16               drbTableBaseLo;               // x88
+			u16               drbTableSize;                 // x8A
+			u16               reserved_142[4];              // x8C
+
+			// TCP/IP Parameters
+			u16               ipReassemblyTimeout;          // x94
+			u16               tcpMaxWindowSize;             // x96
+			u16               ipSecurity;                   // x98
+
+			u8                reserved_156[294];            // x9A
+			u16               qDebug[8];  // QLOGIC USE ONLY   x1C0
+
+			EEPROM_FUNCTION_CFG  funcCfg_fn0;               // x1D0
+			u16               reserved_510;                 // x1FE
+
+			// Address = 512
+			u8                oemSpace[432];                // x200
+
+			BIOS_PARAMS          sBIOSParams_fn1;           // x3B0
+			EEPROM_FUNCTION_CFG  funcCfg_fn1;               // x3D0
+			u16               reserved_1022;                // x3FE
+
+			// Address = 1024
+			u8                reserved_1024[464];           // x400
+			EEPROM_FUNCTION_CFG  funcCfg_fn2;               // x5D0
+
+			u16               reserved_1534;                // x5FE
+
+			// Address = 1536
+			u8                reserved_1536[432];           // x600
+			BIOS_PARAMS          sBIOSParams_fn3;           // x7B0
+			EEPROM_FUNCTION_CFG  funcCfg_fn3;               // x7D0
+
+			u16               checksum;                     // x7FE
+		} __attribute__((packed)) isp4022;
+	};
+
+} eeprom_data_t;
+
+#define EEPROM_EXT_HW_CONF_OFFSET() \
+	(IS_QLA4022(ha) ? \
+	 offsetof(eeprom_data_t, isp4022.ext_hw_conf) / 2 : \
+	 offsetof(eeprom_data_t, isp4010.ext_hw_conf) / 2)
+
+
+/*************************************************************************
+ *
+ *			Hardware Semaphore
+ *
+ *************************************************************************/
+#if 0
+//
+// Semaphore register definitions
+//
+#define SEM_AVAILABLE        	0x00
+#define SEM_OWNER_FIRMWARE   	0x01
+#define SEM_OWNER_STORAGE    	0x02
+#define SEM_OWNER_NETWORK    	0x03
+
+
+//
+// Private Semaphore definitions
+//
+typedef enum
+{
+	SEM_HW_LOCK
+	, SEM_GPO
+	, SEM_SDRAM_INIT
+	, SEM_PHY_GBIC
+	, SEM_NVRAM
+	, SEM_FLASH
+
+	, SEM_COUNT // Not a real semaphore, just indicates how many there are
+} ISP4XXX_SEMAPHORE;
+
+typedef struct {
+	UINT32   semId;
+	UINT32   semShift;
+} isp4xxxSemInfo_t;
+
+
+#define SEM_MASK  0x3
+
+/* Wait flag defines -- specifies type of wait to acquire semaphore */
+#define SEM_FLG_NO_WAIT		0
+#define SEM_FLG_WAIT_FOREVER	1
+#define SEM_FLG_TIMED_WAIT	2
+
+#endif
+
+
+
+#endif // _QL2XNVRM_H_
+
+/*
+ * Overrides for Emacs so that we get a uniform tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 4
+ * c-brace-imaginary-offset: 0
+ * c-brace-offset: -4
+ * c-argdecl-indent: 4
+ * c-label-offset: -4
+ * c-continued-statement-offset: 4
+ * c-continued-brace-offset: 0
+ * indent-tabs-mode: nil
+ * tab-width: 8
+ * End:
+ */
diff --git a/drivers/scsi/qla4xxx/ql4_os.c b/drivers/scsi/qla4xxx/ql4_os.c
new file mode 100644
index 0000000..f82f85c
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_os.c
@@ -0,0 +1,4746 @@
+/******************************************************************************
+ *     Copyright (C)  2003 -2005 QLogic Corporation
+ * QLogic ISP4xxx Device Driver
+ *
+ * This program includes a device driver for Linux 2.6.x that may be
+ * distributed with QLogic hardware specific firmware binary file.
+ * You may modify and redistribute the device driver code under the
+ * GNU General Public License as published by the Free Software Foundation
+ * (version 2 or a later version) and/or under the following terms,
+ * as applicable:
+ *
+ * 	1. Redistribution of source code must retain the above copyright
+ *         notice, this list of conditions and the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above copyright
+ *         notice, this list of conditions and the following disclaimer in
+ *         the documentation and/or other materials provided with the
+ *         distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ * 	
+ * You may redistribute the hardware specific firmware binary file under
+ * the following terms:
+ * 	1. Redistribution of source code (only if applicable), must
+ *         retain the above copyright notice, this list of conditions and
+ *         the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above
+ *         copyright notice, this list of conditions and the following
+ *         disclaimer in the documentation and/or other materials provided
+ *         with the distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ *
+ * REGARDLESS OF WHAT LICENSING MECHANISM IS USED OR APPLICABLE,
+ * THIS PROGRAM IS PROVIDED BY QLOGIC CORPORATION "AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * USER ACKNOWLEDGES AND AGREES THAT USE OF THIS PROGRAM WILL NOT CREATE
+ * OR GIVE GROUNDS FOR A LICENSE BY IMPLICATION, ESTOPPEL, OR OTHERWISE
+ * IN ANY INTELLECTUAL PROPERTY RIGHTS (PATENT, COPYRIGHT, TRADE SECRET,
+ * MASK WORK, OR OTHER PROPRIETARY RIGHT) EMBODIED IN ANY OTHER QLOGIC
+ * HARDWARE OR SOFTWARE EITHER SOLELY OR IN COMBINATION WITH THIS PROGRAM
+ *
+ ******************************************************************************
+ *             Please see release.txt for revision history.                   *
+ *                                                                            *
+ ******************************************************************************
+ * Function Table of Contents:
+ *      qla4xxx_get_hba_count
+ *      pci_set_dma_mask
+ *      qla4xxx_config_dma_addressing
+ *      qla4xxx_detect
+ *      qla4xxx_display_config
+ *      qla4xxx_alloc_srb_pool
+ *      qla4xxx_free_srb_pool
+ *      qla4xxx_mem_alloc
+ *      qla4xxx_mem_free
+ *      qla4xxx_register_resources
+ *      qla4xxx_set_info
+ *      copy_mem_info
+ *      copy_info
+ *      qla4xxx_proc_dump_srb_info
+ *      qla4xxx_proc_dump_discovered_devices
+ *      qla4xxx_proc_dump_scanned_devices
+ *      qla4xxx_proc_info
+ *      qla4xxx_get_adapter_handle
+ *      qla4xxx_release
+ *      del_from_active_array
+ *      qla4xxx_normalize_dma_addr
+ *      qla4xxx_alloc_cont_entry
+ *      qla4xxx_send_command_to_isp
+ *      qla4xxx_complete_request
+ *      qla4xxx_queuecommand
+ *      qla4xxx_extend_timeout
+ *      qla4xxx_start_io
+ *      qla4xxx_os_cmd_timeout
+ *      qla4xxx_add_timer_to_cmd
+ *      qla4xxx_delete_timer_from_cmd
+ *      qla4xxx_timer
+ *      qla4xxx_ioctl_error_recovery
+ *      qla4xxx_do_dpc
+ *      qla4xxx_panic
+ *      qla4xxx_eh_wait_on_command
+ *      qla4xxx_wait_for_hba_online
+ *      qla4xxx_eh_abort
+ *      qla4010_soft_reset
+ *      qla4xxx_topcat_reset
+ *      qla4xxx_soft_reset
+ *      qla4xxx_hard_reset
+ *      qla4xxx_cmd_wait
+ *      qla4xxx_recover_adapter
+ *      qla4xxx_eh_wait_for_active_target_commands
+ *      qla4xxx_eh_device_reset
+ *      qla4xxx_eh_bus_reset
+ *      qla4xxx_reset_target
+ *      qla4xxx_flush_active_srbs
+ *      qla4xxx_eh_host_reset
+ *      apidev_open
+ *      apidev_close
+ *      apidev_ioctl
+ *      apidev_init
+ *      apidev_cleanup
+ ****************************************************************************/
+
+#include "ql4_def.h"
+
+#include <linux/version.h>
+#include <linux/moduleparam.h>
+#include <linux/vmalloc.h>
+#include <linux/smp_lock.h>
+#include <linux/delay.h>
+
+#include <scsi/scsi_tcq.h>
+#include <scsi/scsicam.h>
+
+/*
+ * List of host adapters
+ *---------------------------------------------------------------------------*/
+/*
+ * True list of host adapters.  Available for use after qla4xxx_detect has completed
+ */
+LIST_HEAD(qla4xxx_hostlist);
+rwlock_t qla4xxx_hostlist_lock = RW_LOCK_UNLOCKED;
+
+struct list_head *qla4xxx_hostlist_ptr = &qla4xxx_hostlist;
+rwlock_t *qla4xxx_hostlist_lock_ptr = &qla4xxx_hostlist_lock;
+EXPORT_SYMBOL_GPL(qla4xxx_hostlist_ptr);
+EXPORT_SYMBOL_GPL(qla4xxx_hostlist_lock_ptr);
+
+int qla4xxx_hba_count = 0;
+int qla4xxx_hba_going_away = 0;
+
+/*
+ * Command line options
+ *---------------------------------------------------------------------------*/
+/*
+ * Just in case someone uses commas to separate items on the insmod
+ * command line, we define a dummy buffer here to avoid having insmod
+ * write wild stuff into our code segment
+ */
+int ql4xdiscoverywait=60;
+module_param(ql4xdiscoverywait, int, S_IRUGO|S_IRUSR);
+MODULE_PARM_DESC(ql4xdiscoverywait,
+		 "Discovery wait time");
+int ql4xdontresethba=0;
+module_param(ql4xdontresethba, int, S_IRUGO|S_IRUSR);
+MODULE_PARM_DESC(ql4xdontresethba,
+		 "Dont reset the HBA when the driver gets 0x8002 AEN "
+		 " default it will reset hba :0"
+		 " set to 1 to avoid resetting HBA");
+
+int ql4xcmdretrycount = 20;
+module_param(ql4xcmdretrycount, int, S_IRUGO|S_IRUSR);
+MODULE_PARM_DESC(ql4xcmdretrycount,
+		 "Maximum number of mid-layer retries allowed for a command.  "
+		 "Default value is 20");
+
+int ql4xmaxqdepth = 0;
+module_param(ql4xmaxqdepth, int, S_IRUGO|S_IRUSR);
+MODULE_PARM_DESC(ql4xmaxqdepth,
+		 "Maximum queue depth to report for target devices.");
+
+int extended_error_logging = 0;	/* 0 = off, 1 = log errors, 2 = debug logging */
+module_param(extended_error_logging, int, S_IRUGO|S_IRUSR);
+MODULE_PARM_DESC(extended_error_logging,
+		 "Option to enable extended error logging, "
+		 "Default is 0 - no logging. 1 - log errors. 2 - debug "
+		 "logging");
+
+int displayConfig = 0;
+module_param(displayConfig, int, S_IRUGO|S_IRUSR);
+MODULE_PARM_DESC(displayConfig,
+		 "If 1 then display the configuration used in "
+		 "/etc/modules.conf.");
+
+char *ql4xdevconf = NULL;
+
+MODULE_AUTHOR("QLogic Corporation");
+MODULE_DESCRIPTION("QLogic ISP4XXX iSCSI Host Bus Adapter driver");
+MODULE_LICENSE("GPL");
+
+/*
+ * Proc info processing
+ *---------------------------------------------------------------------------*/
+struct info_str {
+	char    *buffer;
+	int     length;
+	off_t   offset;
+	int     pos;
+};
+
+/*
+ * String messages for various state values (used for print statements)
+ *---------------------------------------------------------------------------*/
+const char *ddb_state_msg[] = DDB_STATE_TBL();
+const char *srb_state_msg[] = SRB_STATE_TBL();
+
+
+
+static uint8_t qla4xxx_mem_alloc(scsi_qla_host_t *ha);
+static void qla4xxx_mem_free(scsi_qla_host_t *ha);
+void qla4xxx_timer(unsigned long p);
+static int qla4xxx_do_dpc(void *data);
+void qla4xxx_display_config(void);
+void qla4xxx_add_timer_to_cmd(srb_t *srb, int timeout);
+static void qla4xxx_flush_active_srbs(scsi_qla_host_t *ha);
+uint8_t qla4xxx_reset_target(scsi_qla_host_t *ha, ddb_entry_t *ddb_entry);
+uint8_t qla4xxx_recover_adapter(scsi_qla_host_t *ha, uint8_t renew_ddb_list);
+void qla4xxx_config_dma_addressing(scsi_qla_host_t *ha);
+
+CONTINUE_ENTRY *qla4xxx_alloc_cont_entry(scsi_qla_host_t *ha);
+
+static void qla4xxx_free_other_mem(scsi_qla_host_t *ha);
+static int qla4xxx_iospace_config(scsi_qla_host_t *ha);
+extern fc_lun_t * qla4xxx_add_fclun(fc_port_t *fcport, uint16_t lun);
+
+
+/*
+ * PCI driver interface definitions
+ *---------------------------------------------------------------------------*/
+static struct pci_device_id qla4xxx_pci_tbl[] __devinitdata =
+{
+	{
+		.vendor		= PCI_VENDOR_ID_QLOGIC,
+		.device		= PCI_DEVICE_ID_QLOGIC_ISP4010,
+		.subvendor	= PCI_ANY_ID,
+		.subdevice	= PCI_ANY_ID,
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_QLOGIC,
+		.device		= PCI_DEVICE_ID_QLOGIC_ISP4022,
+		.subvendor	= PCI_ANY_ID,
+		.subdevice	= PCI_ANY_ID,
+	},
+	{0, 0},
+};
+MODULE_DEVICE_TABLE(pci, qla4xxx_pci_tbl);
+
+static int __devinit qla4xxx_probe_adapter(struct pci_dev *, const struct pci_device_id *);
+static void __devexit qla4xxx_remove_adapter(struct pci_dev *);
+static void qla4xxx_free_adapter(scsi_qla_host_t *ha);
+
+struct pci_driver qla4xxx_pci_driver = {
+	.name           = DRIVER_NAME,
+	.id_table       = qla4xxx_pci_tbl,
+	.probe          = qla4xxx_probe_adapter,
+	.remove         = qla4xxx_remove_adapter,
+};
+
+int qla4xxx_proc_info(struct Scsi_Host *, char *, char **, off_t, int, int);
+int qla4xxx_queuecommand(struct scsi_cmnd *cmd, void (*done_fn)(struct scsi_cmnd *));
+int qla4xxx_eh_abort(struct scsi_cmnd *cmd);
+int qla4xxx_eh_bus_reset(struct scsi_cmnd *cmd);
+int qla4xxx_eh_device_reset(struct scsi_cmnd *cmd);
+int qla4xxx_eh_host_reset(struct scsi_cmnd *cmd);
+int qla4xxx_slave_configure(struct scsi_device * device);
+
+static struct scsi_host_template qla4xxx_driver_template = {
+	.module			= THIS_MODULE,
+	.name			= "qla4xxx",
+	.proc_name		= "qla4xxx",
+	.proc_info		= qla4xxx_proc_info,
+	.queuecommand		= qla4xxx_queuecommand,
+
+	.eh_abort_handler	= qla4xxx_eh_abort,
+	.eh_device_reset_handler = qla4xxx_eh_device_reset,
+	.eh_bus_reset_handler	= qla4xxx_eh_bus_reset,
+	.eh_host_reset_handler	= qla4xxx_eh_host_reset,
+
+	.slave_configure	= qla4xxx_slave_configure,
+
+	.this_id		= -1,
+	.cmd_per_lun		= 3,
+	.use_clustering		= ENABLE_CLUSTERING,
+	.sg_tablesize		= SG_ALL,
+		
+	/* 2^32-1 size limit */
+	.max_sectors 		= 0xffff,
+};
+
+/**************************************************************************
+ * qla4xxx_set_info
+ *      This routine set parameters for the driver from the /proc filesystem.
+ *
+ * Input:
+ *      Unused
+ *
+ * Returns:
+ *      -ENOSYS - no-op
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+int
+qla4xxx_set_info(char *buffer, int length, struct Scsi_Host *host)
+{
+	return(-ENOSYS);  /* Currently this is a no-op */
+}
+
+
+/**************************************************************************
+ * qla4xxx_module_init
+ *    Module initialization.
+ **************************************************************************/
+static int __init
+qla4xxx_module_init(void)
+{
+	int status;
+
+	printk(KERN_INFO
+	    "QLogic iSCSI HBA Driver (%p)\n", qla4xxx_set_info);
+
+#if ISP_RESET_TEST
+	printk(KERN_INFO "qla4xxx: Adapter Reset Test Enabled!  "
+	       "Adapter Resets will be issued every 3 minutes!\n");
+#endif
+
+	status = pci_module_init(&qla4xxx_pci_driver);
+
+	return status;
+}
+
+/**************************************************************************
+ * qla4xxx_module_exit
+ *    Module cleanup.
+ **************************************************************************/
+static void __exit
+qla4xxx_module_exit(void)
+{
+	pci_unregister_driver(&qla4xxx_pci_driver);
+}
+module_init(qla4xxx_module_init);
+module_exit(qla4xxx_module_exit);
+
+
+/**************************************************************************
+ * qla4xxx_probe_adapter
+ *    This routine will probe for Qlogic 4010 iSCSI host adapters.
+ *    It returns the number of host adapters of a particular
+ *    type that were found.  It also initializes all data necessary for
+ *    the driver.  It is passed-in the host number, so that it
+ *    knows where its first entry is in the scsi_hosts[] array.
+ *
+ * Input:
+ *
+ * Returns:
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static int __devinit
+qla4xxx_probe_adapter(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	struct Scsi_Host *host;
+	scsi_qla_host_t *ha;
+	uint8_t status;
+	uint8_t init_retry_count = 0;
+
+	ENTER(__func__);
+
+	if (pci_enable_device(pdev))
+		return -1;
+
+	host = scsi_host_alloc(&qla4xxx_driver_template,
+	    sizeof(scsi_qla_host_t));
+	if (host == NULL) {
+		printk(KERN_WARNING
+		    "qla4xxx: Couldn't allocate host from scsi layer!\n");
+		goto probe_disable_device;
+	}
+
+
+	switch (extended_error_logging) {
+	case 2:
+		qla4xxx_set_debug_level(QLP1|QLP2|QLP7|QLP20|QLP19);
+		break;
+	case 1:
+		qla4xxx_set_debug_level(QLP1|QLP2);
+		break;
+	}
+
+	/* Clear our data area */
+	ha = (scsi_qla_host_t *)host->hostdata;
+	memset(ha, 0, sizeof(scsi_qla_host_t));
+
+	/* Save the information from PCI BIOS.  */
+	ha->pdev = pdev;
+	ha->host = host;
+	ha->host_no = host->host_no;
+	ha->instance = qla4xxx_hba_count;
+
+	/* Configure PCI I/O space. */
+	if (qla4xxx_iospace_config(ha) != QLA_SUCCESS)
+		goto probe_failed;
+
+	host->irq = pdev->irq;
+
+        ql4_printk(KERN_INFO, ha,
+	    "Found an ISP%04x, irq %d, iobase 0x%p\n", pdev->device, host->irq,
+	    ha->reg);
+
+	/* Configure OS DMA addressing method. */
+	qla4xxx_config_dma_addressing(ha);
+
+	/* Initialize lists and spinlocks. */
+	INIT_LIST_HEAD(&ha->ddb_list);
+	INIT_LIST_HEAD(&ha->free_srb_q);
+	INIT_LIST_HEAD(&ha->fcports);
+	INIT_LIST_HEAD(&ha->done_srb_q);
+	INIT_LIST_HEAD(&ha->retry_srb_q);
+
+	init_MUTEX(&ha->mbox_sem);
+	init_waitqueue_head(&ha->mailbox_wait_queue);
+
+	spin_lock_init(&ha->hardware_lock);
+	spin_lock_init(&ha->list_lock);
+
+	ha->dpc_pid = -1;
+	init_completion(&ha->dpc_inited);
+	init_completion(&ha->dpc_exited);
+
+	/* Verify iSCSI PCI Funcion Number */
+	if (IS_QLA4010(ha)) {
+		ha->function_number = ISP4010_ISCSI_FUNCTION;
+	} else if (IS_QLA4022(ha)) {
+		spin_lock_irq(&ha->hardware_lock);
+		ha->function_number = (RD_REG_DWORD(&ha->reg->ctrl_status) &
+		    CSR_PCI_FUNC_NUM_MASK) >> 8;
+		spin_unlock_irq(&ha->hardware_lock);
+	}
+	if (PCI_FUNC(pdev->devfn) != ha->function_number) {
+		ql4_printk(KERN_WARNING, ha, "HA function number (0x%x) does "
+		    "not match PCI function number (0x%x)\n",
+		    ha->function_number, PCI_FUNC(pdev->devfn));
+
+		goto probe_disable_device;
+	}
+
+	/*
+	 * Allocate memory for dma buffers
+	 */
+	if (qla4xxx_mem_alloc(ha) == QLA_ERROR) {
+		ql4_printk(KERN_WARNING, ha,
+		    "[ERROR] Failed to allocate memory for adapter\n");
+
+		goto probe_disable_device;
+	}
+
+	/*
+	 * Initialize the Host adapter request/response queues and
+	 * firmware
+	 * NOTE: interrupts enabled upon successful completion
+	 */
+	status = qla4xxx_initialize_adapter(ha, REBUILD_DDB_LIST);
+	while ((status == QLA_ERROR) &&
+	       (init_retry_count++ < MAX_INIT_RETRIES)) {
+		DEBUG2(printk("scsi: %s: retrying adapter "
+		    "initialization (%d)\n", __func__, init_retry_count));
+
+		qla4xxx_soft_reset(ha);
+		status = qla4xxx_initialize_adapter(ha, REBUILD_DDB_LIST);
+	}
+
+	if (status == QLA_ERROR) {
+		ql4_printk(KERN_WARNING, ha,"Failed to initialize adapter\n");
+
+		DEBUG2(printk("scsi: Failed to initialize adapter\n"));
+
+		goto probe_failed;
+	}
+
+	host->cmd_per_lun = 3;
+	host->io_port = ha->io_addr;
+	host->max_channel =  0;
+	host->max_lun = MAX_LUNS-1;
+	host->max_id = MAX_TARGETS;
+	host->unique_id = ha->instance;
+	host->max_cmd_len = IOCB_MAX_CDB_LEN;
+	host->can_queue = REQUEST_QUEUE_DEPTH + 128;
+
+	/* Startup the kernel thread for this host adapter. */
+	QL4PRINT(QLP7, printk("scsi: %s: Starting kernel thread for "
+	    "qla4xxx_dpc\n", __func__));
+	ha->dpc_should_die = 0;
+	ha->dpc_pid = kernel_thread(qla4xxx_do_dpc, ha, 0);
+	init_retry_count = 0;
+	while ((ha->dpc_pid < 0) &&
+	       (init_retry_count++ < MAX_INIT_RETRIES)) {
+		ha->dpc_pid = kernel_thread(qla4xxx_do_dpc, ha, 0);
+		if (ha->dpc_pid < 0) {
+			printk(KERN_WARNING
+				" host_no =%d Unable to start DPC thread!"
+				"init_retry_count =%d\n", ha->host_no,
+				init_retry_count);
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			schedule_timeout(1 * HZ);
+		} else {
+		 	break;	
+		}	
+	}
+	if (ha->dpc_pid < 0) {
+		ql4_printk(KERN_WARNING, ha, "Unable to start DPC thread!\n");
+
+		goto probe_failed;
+	}
+	wait_for_completion(&ha->dpc_inited);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12))
+	#if ENABLE_MSI
+	if (IS_QLA4022(ha)) {
+		if (pci_enable_msi(pdev)) {
+			ql4_printk(KERN_WARNING, ha,
+			    "Failed to Enable MSI!!!.\n");
+			goto probe_failed;
+		}
+	}
+	ql4_printk(KERN_INFO, ha, "MSI Enabled...\n");
+	set_bit(AF_MSI_ENABLED, &ha->flags);
+	#endif
+#endif
+
+	/* Install the interrupt handler with the new ha */
+	if (request_irq(ha->pdev->irq, qla4xxx_intr_handler,
+	    SA_INTERRUPT|SA_SHIRQ, "qla4xxx", ha)) {
+		ql4_printk(KERN_WARNING, ha,
+		    "Failed to reserve interrupt %d already in use.\n",
+		    host->irq);
+
+		goto probe_failed;
+	}
+	set_bit(AF_IRQ_ATTACHED, &ha->flags);
+	QL4PRINT(QLP7, printk("scsi%d: irq %d attached\n", ha->host_no,
+	    ha->pdev->irq));
+	qla4xxx_enable_intrs(ha);
+
+	/* Start timer thread. */
+	QL4PRINT(QLP7, printk("scsi: %s: Starting timer thread for adapter "
+	    "%d\n", __func__, ha->instance));
+	init_timer(&ha->timer);
+	ha->timer.expires = jiffies + HZ;
+	ha->timer.data = (unsigned long)ha;
+	ha->timer.function = (void (*)(unsigned long))qla4xxx_timer;
+	add_timer(&ha->timer);
+	ha->timer_active = 1;
+
+	strcpy(ha->driver_verstr, QLA4XXX_DRIVER_VERSION);
+	ha->driver_version[0] = QL4_DRIVER_MAJOR_VER;
+	ha->driver_version[1] = QL4_DRIVER_MINOR_VER;
+	ha->driver_version[2] = QL4_DRIVER_PATCH_VER;
+	ha->driver_version[3] = QL4_DRIVER_BETA_VER;
+
+	/* Insert new entry into the list of adapters. */
+	write_lock(&qla4xxx_hostlist_lock);
+	list_add_tail(&ha->list, &qla4xxx_hostlist);
+	write_unlock(&qla4xxx_hostlist_lock);
+
+	DEBUG(printk("qla4xxx: lock=%p listhead=%p, done adding ha list=%p.\n",
+	    &qla4xxx_hostlist_lock, &qla4xxx_hostlist, &ha->list);)
+
+	qla4xxx_display_config();
+
+	set_bit(AF_INIT_DONE, &ha->flags);
+	qla4xxx_hba_count++;
+
+	pci_set_drvdata(pdev, ha);
+
+	if (scsi_add_host(host, &pdev->dev))
+		goto probe_failed;
+
+	printk(KERN_INFO
+	    " QLogic iSCSI HBA Driver version: %s\n"
+	    "  QLogic ISP%04x @ %s hdma%c, host#=%d, fw=%02d.%02d.%02d.%02d\n",
+	    QLA4XXX_DRIVER_VERSION,
+	    ha->pdev->device, pci_name(ha->pdev),
+	    test_bit(AF_64BIT_PCI_ADDR, &ha->flags) ? '+': '-', ha->host_no,
+	    ha->firmware_version[0], ha->firmware_version[1],
+	    ha->patch_number, ha->build_number);
+	
+	scsi_scan_host(host);
+
+	return 0;
+
+probe_failed:
+	qla4xxx_free_adapter(ha);
+
+probe_disable_device:
+	pci_disable_device(pdev);
+
+	return -1;
+}
+
+/**************************************************************************
+ * qla4xxx_remove_adapter
+ *
+ * Input:
+ *	pci_dev - PCI device pointer
+ *
+ * Returns:
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static void __devexit
+qla4xxx_remove_adapter(struct pci_dev *pdev)
+{
+	scsi_qla_host_t *ha;
+
+	ha = pci_get_drvdata(pdev);
+
+	write_lock(&qla4xxx_hostlist_lock);
+	list_del_init(&ha->list);
+	write_unlock(&qla4xxx_hostlist_lock);
+
+	scsi_remove_host(ha->host);
+
+	qla4xxx_free_adapter(ha);
+
+	scsi_host_put(ha->host);
+
+	pci_set_drvdata(pdev, NULL);
+}
+
+static void
+qla4xxx_free_adapter(scsi_qla_host_t *ha)
+{
+	int ret;
+
+	ENTER(__func__);
+
+	qla4xxx_hba_going_away++;
+
+#if 0
+	/* Deregister with the iSNS Server */
+	if (test_bit(ISNS_FLAG_ISNS_SRV_REGISTERED, &ha->isns_flags)) {
+		u_long wait_cnt;
+
+		QL4PRINT(QLP7, printk("scsi%d: %s: deregister iSNS\n",
+				      ha->host_no, __func__));
+		qla4xxx_isns_scn_dereg(ha);
+		qla4xxx_isns_dev_dereg(ha);
+
+		wait_cnt = jiffies + ISNS_DEREG_TOV * HZ;
+		while (wait_cnt > jiffies) {
+			if (test_bit(ISNS_FLAG_ISNS_SRV_REGISTERED,
+				     &ha->isns_flags) == 0)
+				break;
+			QL4PRINT(QLP7, printk("."));
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			schedule_timeout(1 * HZ);
+		}
+	}
+#endif
+
+	if (test_bit(ISNS_FLAG_ISNS_ENABLED_IN_ISP, &ha->isns_flags)) {
+		QL4PRINT(QLP7, printk("scsi%d: %s: Stop iSNS service\n",
+		    ha->host_no, __func__));
+		qla4xxx_isns_disable(ha);
+	}
+
+	if (test_bit(AF_INTERRUPTS_ON, &ha->flags)) {
+		/* Turn-off interrupts on the card. */
+		qla4xxx_disable_intrs(ha);
+	}
+
+	/* Kill the kernel thread for this host */
+	if (ha->dpc_pid >= 0) {
+		ha->dpc_should_die = 1;
+		wmb();
+		ret = kill_proc(ha->dpc_pid, SIGHUP, 1);
+		if (ret) {
+			ql4_printk(KERN_ERR, ha,
+			    "Unable to signal DPC thread -- (%d)\n", ret);
+			
+			/* TODO: SOMETHING MORE??? */
+		} else
+			wait_for_completion(&ha->dpc_exited);
+	}
+
+	/* Issue Soft Reset to put firmware in unknown state */
+	QL4PRINT(QLP7, printk("scsi%d: %s: Soft Reset\n",ha->host_no,__func__));
+	qla4xxx_soft_reset(ha);
+
+	/* Remove timer thread, if present */
+	if (ha->timer_active) {
+		QL4PRINT(QLP7, printk("scsi%d: %s: Removing timer thread for "
+		    "adapter %d\n", ha->host_no, __func__, ha->instance));
+
+		del_timer_sync(&ha->timer);
+		ha->timer_active = 0;
+	}
+
+	/* free extra memory */
+	qla4xxx_mem_free(ha);
+
+	/* Detach interrupts */
+	if (test_and_clear_bit(AF_IRQ_ATTACHED, &ha->flags))
+		free_irq(ha->pdev->irq, ha);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,10))
+        #if ENABLE_MSI
+	if (test_and_clear_bit(AF_MSI_ENABLED, &ha->flags))
+		pci_disable_msi(ha->pdev);
+	#endif
+#endif	
+
+	/* Free I/O Region */
+	if (ha->io_addr) {
+		release_region(ha->io_addr, ha->io_len);
+		ha->io_addr = 0;
+	}
+
+	pci_disable_device(ha->pdev);
+
+	qla4xxx_hba_going_away--;
+
+	LEAVE(__func__);
+}
+
+/**************************************************************************
+ * qla4xxx_iospace_config
+ *    This routine
+ *
+ * Input:
+ *
+ * Returns:
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static int
+qla4xxx_iospace_config(scsi_qla_host_t *ha)
+{
+	int bar;
+
+	/* Search for I/O register. */
+	for (bar = 0; bar <= 5; bar++) {
+		unsigned long pci_base_address;
+
+		pci_base_address = pci_resource_start(ha->pdev, bar);
+		ha->pci_resource_flags = pci_resource_flags(ha->pdev, bar);
+
+#if MEMORY_MAPPED_IO
+		if (ha->pci_resource_flags & IORESOURCE_MEM) {
+			QL4PRINT(QLP7, printk("scsi%d: Assigned to Memory I/O "
+			    "0x%lx in PCI BAR%d\n", ha->host_no,
+			    pci_base_address, bar));
+
+			ha->mem_addr = pci_base_address;
+			ha->mem_len = pci_resource_len(ha->pdev, bar);
+			break;
+		}
+#else
+		if (ha->pci_resource_flags IORESOURCE_IO) {
+			QL4PRINT(QLP7, printk("scsi%d: Assigned to I/O Port "
+			    "0x%lx in PCI BAR%d\n", ha->host_no,
+			    pci_base_address, bar));
+
+			ha->io_addr = pci_base_address;
+			ha->io_len = pci_resource_len(ha->pdev, bar);
+			break;
+		}
+#endif
+	}
+
+	/* Map the Memory I/O register. */
+	if (ha->mem_addr) {
+		unsigned long  page_offset, base;
+
+		if (!request_mem_region(ha->mem_addr, ha->mem_len,
+		    DRIVER_NAME)) {
+			printk(KERN_WARNING
+			    "Could not allocate IO Memory space %lx len %ld.\n",
+			    ha->mem_addr, ha->mem_len);
+			return -1;
+		}
+
+		QL4PRINT(QLP7, printk("scsi%d: %s: base memory address = "
+		    "0x%lx\n", ha->host_no, __func__, ha->mem_addr));
+
+		/* Find proper memory chunk for memory map I/O reg. */
+		base = ha->mem_addr & PAGE_MASK;
+		page_offset = ha->mem_addr - base;
+
+		/* Get virtual address for I/O registers. */
+		ha->virt_mmapbase = ioremap(base, page_offset +
+		    sizeof(*ha->reg));
+		if (ha->virt_mmapbase == NULL) {
+			QL4PRINT(QLP2, printk("scsi%d: %s: I/O Remap Failed\n",
+			    ha->host_no, __func__));
+			return -1;
+		}
+
+		QL4PRINT(QLP7, printk("scsi%d: %s: virt memory_mapped_address "
+		    "= 0x%p\n", ha->host_no, __func__, ha->virt_mmapbase));
+
+		ha->reg = (isp_reg_t *)(ha->virt_mmapbase + page_offset);
+		QL4PRINT(QLP7, printk("scsi%d: %s: registers = 0x%p\n",
+		    ha->host_no, __func__, ha->reg));
+	}
+
+	if (ha->io_addr) {
+		if (!request_region(ha->io_addr, ha->io_len, DRIVER_NAME)) {
+			printk(KERN_WARNING
+			    "Could not allocate IO space %lx len %ld.\n",
+			    ha->io_addr, ha->io_len);
+
+			return -1;
+		}
+	}
+
+	return QLA_SUCCESS;
+}
+
+/**************************************************************************
+ * qla4xxx_display_config
+ *      This routine  displays the configuration information to be used in
+ *      modules.conf.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure
+ *
+ * Output:
+ *      None
+ *
+ * Returns:
+ *      None
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+void
+qla4xxx_display_config(void)
+{
+	scsi_qla_host_t *ha, *htemp;
+
+	read_lock(&qla4xxx_hostlist_lock);
+	list_for_each_entry_safe(ha, htemp, &qla4xxx_hostlist, list) {
+		/* Display the M.A.C. Address for adapter */
+		printk(KERN_INFO
+		    "scsi-qla%d-mac=%02x%02x%02x%02x%02x%02x\\;\n",
+		    ha->instance,
+		    ha->my_mac[0], ha->my_mac[1], ha->my_mac[2],
+		    ha->my_mac[3], ha->my_mac[4], ha->my_mac[5]);
+	}
+	read_unlock(&qla4xxx_hostlist_lock);
+
+}
+
+/**************************************************************************
+ * qla4xxx_get_hba_count
+ *      This routine returns the number of host adapters present.
+ *
+ * Input:
+ *      None
+ *
+ * Returns:
+ *    qla4xxx_hba_count - Number of host adapters present.
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+uint32_t
+qla4xxx_get_hba_count(void)
+{
+	return(qla4xxx_hba_count);
+}
+
+
+
+/****************************************************************************/
+/*  LINUX -  Loadable Module Functions.                                     */
+/****************************************************************************/
+
+/**
+ * qla4xxx_config_dma_addressing() - Configure OS DMA addressing method.
+ * @ha: HA context
+ *
+ * At exit, the @ha's flags.enable_64bit_addressing set to indicated
+ * supported addressing method.
+ */
+void
+qla4xxx_config_dma_addressing(scsi_qla_host_t *ha)
+{
+	int retval;
+
+	/* Assume 32bit DMA address. */
+	clear_bit(AF_64BIT_PCI_ADDR, &ha->flags);
+
+	/*
+	 * Given the two variants pci_set_dma_mask(), allow the compiler to
+	 * assist in setting the proper dma mask.
+	 */
+	if (sizeof(dma_addr_t) > 4) {
+		/* Update our PCI device dma_mask for full 64 bit mask */
+		if (pci_set_dma_mask(ha->pdev, DMA_64BIT_MASK) == 0) {
+			set_bit(AF_64BIT_PCI_ADDR, &ha->flags);
+
+			if (pci_set_consistent_dma_mask(ha->pdev,
+			    DMA_64BIT_MASK)) {
+				ql4_printk(KERN_DEBUG, ha,
+				    "Failed to set 64 bit PCI consistent mask; "
+				    "using 32 bit.\n");
+
+				retval = pci_set_consistent_dma_mask(ha->pdev,
+				    DMA_32BIT_MASK);
+			}
+		} else {
+			ql4_printk(KERN_DEBUG, ha,
+			    "Failed to set 64 bit PCI DMA mask, falling back "
+			    "to 32 bit MASK.\n");
+
+			retval = pci_set_dma_mask(ha->pdev, DMA_32BIT_MASK);
+		}
+	} else {
+		pci_set_dma_mask(ha->pdev, DMA_32BIT_MASK);
+	}
+}
+
+/**************************************************************************
+ * qla4xxx_alloc_srb_pool
+ *      This routine is called during driver initialization to allocate
+ *      memory for the local srb pool.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure
+ *
+ * Returns:
+ *      QLA_SUCCESS - Successfully allocated srbs
+ *      QLA_ERROR   - Failed to allocate any srbs
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+static uint8_t
+qla4xxx_alloc_srb_pool(scsi_qla_host_t *ha)
+{
+	srb_t *srb;
+	int i;
+	uint8_t status = QLA_ERROR;
+
+	ENTER("qla4xxx_alloc_srb_pool");
+
+	ha->num_srbs_allocated = 0;
+	ha->free_srb_q_count = 0; /* incremented in add_to_free_srb_q routine */
+
+	/*
+	 * NOTE: Need to allocate each SRB separately, as Kernel 2.4.4 seems to
+	 * have an error when allocating a large amount of memory.
+	 */
+	for (i=0; i < MAX_SRBS; i++) {
+		srb = (srb_t *) kmalloc(sizeof(srb_t), GFP_KERNEL);
+		if (srb == NULL) {
+			QL4PRINT(QLP2, printk(
+			    "scsi%d: %s: failed to allocate memory, count = "
+			    "%d\n", ha->host_no, __func__, i));
+		} else {
+			ha->num_srbs_allocated++;
+			memset(srb, 0, sizeof(srb_t));
+			atomic_set(&srb->ref_count, 1);
+			__add_to_free_srb_q(ha, srb);
+		}
+	}
+
+	if (ha->free_srb_q_count)
+		status = QLA_SUCCESS;
+
+	DEBUG2(printk("scsi%d: %s: Allocated %d SRB(s)\n",
+	    ha->host_no, __func__, ha->free_srb_q_count));
+
+	LEAVE("qla4xxx_alloc_srb_pool");
+
+	return (status);
+}
+
+/**************************************************************************
+ * qla4xxx_free_srb_pool
+ *      This routine is called during driver unload to deallocate the srb
+ *      pool.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure
+ *
+ * Returns:
+ *      None
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+static void
+qla4xxx_free_srb_pool(scsi_qla_host_t *ha)
+{
+	srb_t *srb, *stemp;
+	int cnt_free_srbs = 0;
+	unsigned long flags;
+
+	ENTER("qla4xxx_free_srb_pool");
+	spin_lock_irqsave(&ha->list_lock, flags);
+	list_for_each_entry_safe(srb, stemp, &ha->free_srb_q, list_entry) {
+		__del_from_free_srb_q(ha, srb);
+		kfree(srb);
+		cnt_free_srbs++;
+	}
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+
+	if (cnt_free_srbs != ha->num_srbs_allocated) {
+		QL4PRINT(QLP2, printk(KERN_WARNING
+		    "scsi%d: Did not free all srbs, Free'd srb count = %d, "
+		    "Alloc'd srb count %d\n", ha->host_no, cnt_free_srbs,
+		    ha->num_srbs_allocated));
+	}
+
+	LEAVE("qla4xxx_free_srb_pool");
+}
+
+/**************************************************************************
+ * qla4xxx_mem_alloc
+ *      This routine allocates memory use by the adapter.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure
+ *
+ * Returns:
+ *      QLA_SUCCESS - Successfully allocated adapter memory
+ *      QLA_ERROR   - Failed to allocate adapter memory
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+static uint8_t
+qla4xxx_mem_alloc(scsi_qla_host_t *ha)
+{
+	unsigned long	align;
+
+	ENTER("qla4xxx_mem_alloc");
+
+	/* Allocate contiguous block of DMA memory for queues. */
+	ha->queues_len = ((REQUEST_QUEUE_DEPTH * QUEUE_SIZE) +
+	    (RESPONSE_QUEUE_DEPTH * QUEUE_SIZE) + sizeof(shadow_regs_t) +
+	    MEM_ALIGN_VALUE + (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1);
+	ha->queues = pci_alloc_consistent(ha->pdev, ha->queues_len,
+	    &ha->queues_dma);
+	if (ha->queues == NULL) {
+		ql4_printk(KERN_WARNING, ha,
+		    "Memory Allocation failed - queues.\n");
+
+		goto mem_alloc_error_exit;
+	}
+	memset(ha->queues, 0, ha->queues_len);
+
+	/*
+	 * As per RISC alignment requirements -- the bus-address must be a
+	 * multiple of the request-ring size (in bytes).
+	 */
+	align = 0;
+	if ((unsigned long)ha->queues_dma & (MEM_ALIGN_VALUE - 1)) {
+		align = MEM_ALIGN_VALUE -
+		    ((unsigned long)ha->queues_dma & (MEM_ALIGN_VALUE - 1));
+	}
+
+	/* Update request and response queue pointers. */
+	ha->request_dma = ha->queues_dma + align;
+	ha->request_ring = (QUEUE_ENTRY *)(ha->queues + align);
+	ha->response_dma = ha->queues_dma + align +
+	    (REQUEST_QUEUE_DEPTH * QUEUE_SIZE);
+	ha->response_ring = (QUEUE_ENTRY *)(ha->queues + align +
+	    (REQUEST_QUEUE_DEPTH * QUEUE_SIZE));
+	ha->shadow_regs_dma = ha->queues_dma + align +
+	    (REQUEST_QUEUE_DEPTH * QUEUE_SIZE) +
+	    (RESPONSE_QUEUE_DEPTH * QUEUE_SIZE);
+	ha->shadow_regs = (shadow_regs_t *)(ha->queues + align +
+	    (REQUEST_QUEUE_DEPTH * QUEUE_SIZE) +
+	    (RESPONSE_QUEUE_DEPTH * QUEUE_SIZE));
+
+	QL4PRINT(QLP7, printk("scsi%d: %s: queues 0x%lx (%p) %lx\n",
+	    ha->host_no, __func__, (unsigned long)ha->queues_dma,
+	    ha->queues, ha->queues_len));
+	QL4PRINT(QLP7, printk("scsi%d: %s: request ring 0x%lx (%p)\n",
+	    ha->host_no, __func__, (unsigned long)ha->request_dma,
+	    ha->request_ring));
+	QL4PRINT(QLP7, printk("scsi%d: %s: response ring 0x%lx (%p)\n",
+	    ha->host_no, __func__, (unsigned long)ha->response_dma,
+	    ha->response_ring));
+	QL4PRINT(QLP7, printk("scsi%d: %s: shadow regs 0x%lx (%p)\n",
+	    ha->host_no, __func__, (unsigned long)ha->shadow_regs_dma,
+	    ha->shadow_regs));
+
+	/* Allocate iSNS Discovered Target Database
+	 * ---------------------------------------- */
+	ha->isns_disc_tgt_database_size = sizeof(ISNS_DISCOVERED_TARGET) *
+	    MAX_ISNS_DISCOVERED_TARGETS;
+	ha->isns_disc_tgt_databasev = pci_alloc_consistent(ha->pdev,
+	    ha->isns_disc_tgt_database_size, &ha->isns_disc_tgt_databasep);
+	if (ha->isns_disc_tgt_databasev == NULL) {
+		ql4_printk(KERN_WARNING, ha,
+		    "Memory Allocation failed - iSNS DB.\n");
+
+		goto mem_alloc_error_exit;
+	}
+	memset(ha->isns_disc_tgt_databasev, 0, ha->isns_disc_tgt_database_size);
+
+	QL4PRINT(QLP7, printk("scsi%d: %s: iSNS DB 0x%ld (%p)\n", ha->host_no,
+	    __func__, (unsigned long)ha->isns_disc_tgt_databasep,
+	    ha->isns_disc_tgt_databasev));
+
+	/*
+	 * Allocate memory for srb pool
+	 *-----------------------------*/
+	if (qla4xxx_alloc_srb_pool(ha) == QLA_ERROR)
+		goto mem_alloc_error_exit;
+
+	LEAVE("qla4xxx_mem_alloc");
+
+	return (QLA_SUCCESS);
+
+mem_alloc_error_exit:
+	qla4xxx_mem_free(ha);
+	LEAVE("qla4xxx_mem_alloc");
+	return (QLA_ERROR);
+}
+
+/**************************************************************************
+ * qla4xxx_mem_free
+ *      This routine frees adapter allocated memory
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *      None
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+static void
+qla4xxx_mem_free(scsi_qla_host_t *ha)
+{
+	ENTER("qla4xxx_mem_free");
+
+	if (ha->queues) {
+		QL4PRINT(QLP7, printk("scsi%d: %s: free queues.\n", ha->host_no,
+		    __func__));
+
+		pci_free_consistent(ha->pdev, ha->queues_len, ha->queues,
+		    ha->queues_dma);
+	}
+	ha->queues_len = 0;
+	ha->queues = NULL;
+	ha->queues_dma = 0;
+	ha->request_ring = NULL;
+	ha->request_dma = 0;
+	ha->response_ring = NULL;
+	ha->response_dma = 0;
+	ha->shadow_regs = NULL;
+	ha->shadow_regs_dma = 0;
+
+	if (ha->isns_disc_tgt_databasev) {
+		QL4PRINT(QLP7, printk("scsi%d: %s: free iSNS DB.\n",
+		    ha->host_no, __func__));
+
+		pci_free_consistent(ha->pdev, ha->isns_disc_tgt_database_size,
+		    ha->isns_disc_tgt_databasev, ha->isns_disc_tgt_databasep);
+	}
+	ha->isns_disc_tgt_database_size = 0;
+	ha->isns_disc_tgt_databasev = 0;
+	ha->isns_disc_tgt_databasep = 0;
+
+	/* Free srb pool */
+	if (ha->num_srbs_allocated) {
+		QL4PRINT(QLP7, printk("scsi%d: %s: free srb pool\n",
+		    ha->host_no, __func__));
+
+		qla4xxx_free_srb_pool(ha);
+	}
+
+	/* Free ddb list */
+	if (!list_empty(&ha->ddb_list)) {
+		QL4PRINT(QLP7, printk("scsi%d: %s: free ddb list\n",
+		    ha->host_no, __func__));
+
+		qla4xxx_free_ddb_list(ha);
+	}
+
+	/* Unmap Memory Mapped I/O region */
+	if (ha->virt_mmapbase) {
+		QL4PRINT(QLP7, printk("scsi%d: %s: unmap mem io region\n",
+		    ha->host_no, __func__));
+
+		iounmap(ha->virt_mmapbase);
+		ha->virt_mmapbase = NULL;
+	}
+
+	if (ha->mem_addr)
+		release_mem_region(ha->mem_addr, ha->mem_len);
+	ha->mem_addr = 0;
+
+	qla4xxx_free_other_mem(ha);
+
+	LEAVE("qla4xxx_mem_free");
+}
+
+
+/**************************************************************************
+* qla2xxx_slave_configure
+*
+* Description:
+**************************************************************************/
+int
+qla4xxx_slave_configure(struct scsi_device *sdev)
+{
+	scsi_qla_host_t *ha = to_qla_host(sdev->host);
+	int queue_depth;
+	os_tgt_t     *tgt_entry;
+	os_lun_t     *lun_entry;
+
+	queue_depth = 32;
+
+	/* Enable TCQ. */
+	if (sdev->tagged_supported) {
+		if (ql4xmaxqdepth != 0 && ql4xmaxqdepth <= 0xffffU)
+			queue_depth = ql4xmaxqdepth;
+
+		ql4xmaxqdepth = queue_depth;
+
+		scsi_activate_tcq(sdev, queue_depth);
+
+		ql4_printk(KERN_INFO, ha,
+		    "scsi(%d:%d:%d:%d): Enabled tagged queuing, queue "
+		    "depth %d.\n", sdev->host->host_no, sdev->channel,
+		    sdev->id, sdev->lun, sdev->queue_depth);
+	} else {
+		 scsi_adjust_queue_depth(sdev, 0 /* TCQ off */,
+		     sdev->host->hostt->cmd_per_lun /* 3 */);
+	}
+
+	/* Save misc. information. */
+	tgt_entry = qla4xxx_lookup_target_by_SCSIID(ha, sdev->channel,
+	    sdev->id);
+	if (tgt_entry != NULL) {
+		lun_entry = qla4xxx_lookup_lun_handle(ha, tgt_entry,
+		    sdev->lun);
+	        if (lun_entry != NULL) {
+			lun_entry->sdev = sdev;
+			if (sdev->type == TYPE_TAPE) {
+				tgt_entry->fcport->flags |= FCF_TAPE_PRESENT;
+			}
+		}
+	}
+
+	return (0);
+}
+
+
+/*
+ * The following support functions are adopted to handle
+ * the re-entrant qla4xxx_proc_info correctly.
+ */
+static void
+copy_mem_info(struct info_str *info, char *data, int len)
+{
+	if (info->pos + len > info->offset + info->length)
+		len = info->offset + info->length - info->pos;
+
+	if (info->pos + len < info->offset) {
+		info->pos += len;
+		return;
+	}
+
+	if (info->pos < info->offset) {
+		off_t partial;
+
+		partial = info->offset - info->pos;
+		data += partial;
+		info->pos += partial;
+		len  -= partial;
+	}
+
+	if (len > 0) {
+		memcpy(info->buffer, data, len);
+		info->pos += len;
+		info->buffer += len;
+	}
+}
+
+static int
+copy_info(struct info_str *info, char *fmt, ...)
+{
+	va_list args;
+	static char buf[256];
+	int len;
+
+	va_start(args, fmt);
+	len = vsprintf(buf, fmt, args);
+	va_end(args);
+
+	copy_mem_info(info, buf, len);
+
+	return(len);
+}
+
+/**************************************************************************
+ * qla4xxx_proc_dump_srb_info
+ *      This routine displays srb information in the proc buffer.
+ *
+ * Input:
+ *      len - length of proc buffer prior to this function's execution.
+ *      srb - Pointer to srb to display.
+ *
+ * Remarks:
+ *      This routine is dependent on the DISPLAY_SRBS_IN_PROC #define being
+ *      set to 1.
+ *
+ * Returns:
+ *      len - length of proc buffer after this function's execution.
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+inline void
+qla4xxx_proc_dump_srb_info(scsi_qla_host_t *ha, struct info_str *info, srb_t *srb)
+{
+	ddb_entry_t *ddb_entry;
+	os_lun_t *lun_entry;
+
+	ddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, srb->fw_ddb_index);
+	lun_entry = srb->lun_queue;
+
+	copy_info(info, "srb %p", srb);
+
+	if (ddb_entry && lun_entry && srb->cmd) {
+		struct scsi_cmnd *cmd = srb->cmd;
+		//int i;
+
+		copy_info(info, ", b%d,t%d,l%d, SS=%d, DS=%d, LS=%d, "
+			  "r_start=%ld, u_start=%ld",
+			  cmd->device->channel, cmd->device->id,
+			  cmd->device->lun,
+			  srb->state,
+			  atomic_read(&ddb_entry->state),
+			  lun_entry->lun_state,
+			  srb->r_start,srb->u_start);
+
+		//copy_info(info, ", cdb=");
+		//for (i=0; i<cmd->cmd_len; i++)
+		//        copy_info(info, "%02X ", cmd->cmnd[i]);
+	}
+
+	copy_info(info, "\n");
+}
+
+/**************************************************************************
+ * qla4xxx_proc_dump_discovered_devices
+ *      This routine displays information for discovered devices in the proc
+ *      buffer.
+ *
+ * Input:
+ *      info - length of proc buffer prior to this function's execution.
+ *
+ * Remarks:
+ *      This routine is dependent on the DISPLAY_SRBS_IN_PROC #define being
+ *      set to 1.
+ *
+ * Returns:
+ *      info - length of proc buffer after this function's execution.
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+inline void
+qla4xxx_proc_dump_discovered_devices(scsi_qla_host_t *ha, struct info_str *info)
+{
+	int i,j;
+
+	ENTER(__func__);
+
+	copy_info(info, "SCSI discovered device Information:\n");
+	copy_info(info, "Index: DID: NameString: Alias:\n");
+
+	for (i=0; i < ha->isns_num_discovered_targets; i++) {
+		ISNS_DISCOVERED_TARGET *isns_tgt =
+		&ha->isns_disc_tgt_databasev[i];
+
+		copy_info(info, "%2d: %4d:   %s: %s\n",
+			  i,
+			  isns_tgt->DDID,
+			  isns_tgt->NameString,
+			  isns_tgt->Alias);
+
+		for (j = 0; j < isns_tgt->NumPortals; j++) {
+			ISNS_DISCOVERED_TARGET_PORTAL *isns_portal =
+			&isns_tgt->Portal[j];
+
+			copy_info(info, "            Port %d: IP %d.%d.%d.%d\n",
+				  isns_portal->PortNumber,
+				  isns_portal->IPAddr[0],
+				  isns_portal->IPAddr[1],
+				  isns_portal->IPAddr[2],
+				  isns_portal->IPAddr[3]);
+		}
+	}
+	LEAVE(__func__);
+}
+
+/**************************************************************************
+ * qla4xxx_proc_dump_scanned_devices
+ *      This routine displays information for scanned devices in the proc
+ *      buffer.
+ *
+ * Input:
+ *      info - length of proc buffer prior to this function's execution.
+ *
+ * Remarks:
+ *      This routine is dependent on the DISPLAY_SRBS_IN_PROC #define being
+ *      set to 1.
+ *
+ * Returns:
+ *      info - length of proc buffer after this function's execution.
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+inline void
+qla4xxx_proc_dump_scanned_devices(scsi_qla_host_t *ha, struct info_str *info)
+{
+	os_lun_t        *up;
+	ddb_entry_t     *ddb_entry;
+	fc_port_t	*fcport;
+	int             t, l;
+
+	ENTER(__func__);
+	/* 2.25 node/port display to proc */
+	/* Display the node name for adapter */
+	copy_info(info, "\nSCSI Device Information:\n");
+	copy_info(info,
+                  "scsi-qla%d-adapter-port=\"%s\";\n",
+                  (int)ha->instance, ha->name_string);
+	copy_info(info,
+                  "scsi-qla%d-adapter-address=%d.%d.%d.%d: %d.%d.%d.%d;\n",
+                  (int)ha->instance, ha->ip_address[0], ha->ip_address[1],
+		  ha->ip_address[2], ha->ip_address[3], ha->subnet_mask[0],
+		  ha->subnet_mask[1], ha->subnet_mask[2], ha->subnet_mask[3]);
+	copy_info(info,
+                  "scsi-qla%d-adapter-gateway=%d.%d.%d.%d;\n",
+                  (int)ha->instance, ha->gateway[0], ha->gateway[1],
+		  ha->gateway[2], ha->gateway[3]);
+
+	list_for_each_entry(fcport, &ha->fcports, list) {
+		if(fcport->port_type != FCT_TARGET)
+			continue;
+
+		ddb_entry = fcport->ddbptr;
+			
+		copy_info(info,
+	    	"scsi-qla%d-target-%d=ddb 0x%04x: \"%s\": %d.%d.%d.%d;\n",
+	    	(int)ha->instance, ddb_entry->target, ddb_entry->fw_ddb_index,
+			fcport->iscsi_name,
+			ddb_entry->ip_addr[0],
+			ddb_entry->ip_addr[1],
+			ddb_entry->ip_addr[2],
+			ddb_entry->ip_addr[3]);
+	}
+
+	
+	//copy_info(info, "SCSI scanned device Information:\n");
+	copy_info(info, "\nSCSI LUN Information:\n");
+	copy_info(info, " (H: B: T: L) * - indicates lun is not registered with the OS.\n");
+
+	/* scan for all equipment stats */
+	for (t = 0; t < ha->host->max_id; t++) {
+		/* scan all luns */
+		for (l = 0; l < ha->host->max_lun; l++) {
+			up = (os_lun_t *) GET_LU_Q(ha, t, l);
+
+			if (up == NULL) {
+				continue;
+			}
+			if (up->fclun == NULL) {
+				continue;
+			}
+
+			if (up->fclun->fcport == NULL) {
+				continue;
+			}
+
+    			/* don't display luns if OS didn't probe */
+			if (up->tot_io_count < 4)
+				continue;
+
+			ddb_entry = up->fclun->fcport->ddbptr;
+			copy_info(info,
+				  "(%2d:%2d:%2d:%2d): Total reqs %ld,",
+				  ha->host_no, ddb_entry->bus,
+				  t,l,up->tot_io_count);
+
+			copy_info(info,
+				  " Active reqs %ld,",
+				  up->out_count);
+
+			copy_info(info, "states= %d:%d:%d ",
+				  atomic_read(&ddb_entry->state),
+				  up->lun_state,
+				  ddb_entry->fw_ddb_device_state);
+
+			if (up->tot_io_count < 4) {
+				copy_info(info,
+					  " flags 0x%lx*,",
+					  ddb_entry->flags);
+			}
+			else {
+				copy_info(info,
+					  " flags 0x%lx,",
+					  ddb_entry->flags);
+			}
+
+			copy_info(info,
+				  " %d:%d:%02x %02x",
+				  up->fclun->fcport->ha->instance,
+				  up->fclun->fcport->cur_path,
+				  ddb_entry->fw_ddb_index,
+				  up->fclun->device_type);
+
+			copy_info(info, "\n");
+
+			if (info->pos >= info->offset + info->length) {
+				/* No need to continue */
+				return;
+			}
+		}
+
+		if (info->pos >= info->offset + info->length) {
+			/* No need to continue */
+			break;
+		}
+	}
+	LEAVE(__func__);
+}
+
+/**************************************************************************
+ * qla4xxx_proc_info
+ *      This routine return information to handle /proc support for the driver
+ *
+ * Input:
+ * Output:
+ *      inout  - Decides on the direction of the dataflow and the meaning of
+ *               the variables.
+ *      buffer - If inout==0 data is being written to it else read from
+ *               it (ptrs to a page buffer).
+ *      *start - If inout==0 start of the valid data in the buffer.
+ *      offset - If inout==0 offset from the beginning of the imaginary
+ *               file from which we start writing into the buffer.
+ *      length - If inout==0 max number of bytes to be written into the
+ *               buffer else number of bytes in the buffer.
+ *      hostno - Host number
+ *
+ * Remarks:
+ *      None
+ *
+ * Returns:
+ *      Size of proc buffer.
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+int
+qla4xxx_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
+    off_t offset, int length, int inout)
+{
+	int             retval = -EINVAL;
+	scsi_qla_host_t *ha = NULL;
+	struct info_str info;
+	unsigned long   flags;
+	srb_t *srb, *stemp;
+
+	QL4PRINT(QLP16, printk("scsi%d: Entering %s: buff_in=%p, "
+			       "offset=0x%lx, length=0x%x\n",
+			       shost->host_no, __func__, buffer, offset,
+			       length));
+
+	ha = (scsi_qla_host_t *) shost->hostdata;
+
+	if (inout) {
+		/* Has data been written to the file? */
+		QL4PRINT(QLP3, printk("scsi%d: %s: has data been written "
+				      "to the file. \n",
+				      ha->host_no, __func__));
+		return(qla4xxx_set_info(buffer, length, ha->host));
+	}
+
+	if (start) {
+		*start = buffer;
+	}
+
+	info.buffer = buffer;
+	info.length = length;
+	info.offset = offset;
+	info.pos    = 0;
+
+	/* start building the print buffer */
+	copy_info(&info, "QLogic iSCSI Adapter for ISP %x:\n",
+	    ha->pdev->device);
+	copy_info(&info, "Driver version %s\n", QLA4XXX_DRIVER_VERSION);
+	copy_info(&info, "Firmware version %2d.%02d.%02d.%02d\n",
+	    ha->firmware_version[0], ha->firmware_version[1],
+	    ha->patch_number, ha->build_number);
+	copy_info(&info, "Code starts at address = %p\n", qla4xxx_set_info);
+
+	if (ha->mem_addr)
+		copy_info(&info, "Memory I/O = 0x%lx\n", ha->mem_addr);
+	else
+		copy_info(&info, "I/O Port = 0x%lx\n", ha->io_addr);
+
+	copy_info(&info, "IP Address = %d.%d.%d.%d\n",
+		  ha->ip_address[0], ha->ip_address[1],
+		  ha->ip_address[2], ha->ip_address[3]);
+
+	if (ha->tcp_options & TOPT_ISNS_ENABLE) {
+		copy_info(&info, "iSNS IP Address = %d.%d.%d.%d\n",
+			  ha->isns_ip_address[0], ha->isns_ip_address[1],
+			  ha->isns_ip_address[2], ha->isns_ip_address[3]);
+		copy_info(&info, "iSNS Server Port# = %d\n",
+			  ha->isns_server_port_number);
+	}
+#if 0
+	copy_info(&info, "ReqQ DMA= 0x%lx, virt= 0x%p, depth= 0x%x\n",
+		  (unsigned long)ha->request_dma, ha->request_ring, REQUEST_QUEUE_DEPTH);
+	copy_info(&info, "ComplQ DMA= 0x%lx, virt= 0x%p, depth= 0x%x\n",
+		  (unsigned long)ha->response_dma, ha->response_ring, RESPONSE_QUEUE_DEPTH);
+	copy_info(&info, "Shadow Regs DMA= 0x%lx, virt= 0x%p, size (bytes) = 0x%x\n",
+		  (unsigned long)ha->shadow_regs_dma, ha->shadow_regs, sizeof(shadow_regs_t));
+	copy_info(&info, "PDU Buffer Addr= 0x%x, size (bytes) = 0x%x\n",
+		  ha->pdu_buffsv, ha->pdu_buff_size);
+					
+	copy_info(&info, "Discovered Target Database Addr = 0x%x, size (bytes) = 0x%x\n",
+		  ha->isns_disc_tgt_databasev,
+		  sizeof(ha->isns_disc_tgt_databasev));
+#endif
+	copy_info(&info, "Number of free request entries  = %d of %d\n",
+		  ha->req_q_count, REQUEST_QUEUE_DEPTH);
+	//copy_info(&info, "Number of free aen entries    = %d of %d\n",
+	//	  ha->aen_q_count, MAX_AEN_ENTRIES);
+	copy_info(&info, "Number of Mailbox Timeouts = %d\n",
+		  ha->mailbox_timeout_count);
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	copy_info(&info, "Interrupt Status = %d\n",
+		  RD_REG_DWORD(&ha->reg->ctrl_status));
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+	
+	copy_info(&info, "ReqQptr=%p, ReqIn=%d, ReqOut=%d\n",
+		  ha->request_ptr, ha->request_in, ha->request_out);
+	copy_info(&info, "Device queue depth = 0x%x\n",
+		  (ql4xmaxqdepth == 0) ? 16 : ql4xmaxqdepth);
+	copy_info(&info, "Adapter flags = 0x%x, DPC flags = 0x%x\n",
+		  ha->flags, ha->dpc_flags);
+
+	copy_info(&info, "Number of commands in retry_srb_q = %d\n",
+		  ha->retry_srb_q_count);
+
+	if (((ql_dbg_level & QLP16) != 0) && (ha->retry_srb_q_count)) {
+		copy_info(&info, "\nDump retry_srb_q:\n");
+		spin_lock_irqsave(&ha->list_lock, flags);
+		list_for_each_entry_safe(srb, stemp, &ha->retry_srb_q,
+		    list_entry)
+			qla4xxx_proc_dump_srb_info(ha, &info, srb);
+		spin_unlock_irqrestore(&ha->list_lock, flags);
+		copy_info(&info, "\n");
+	}
+
+	copy_info(&info, "Number of commands in done_srb_q = %d\n",
+		  ha->done_srb_q_count);
+
+	if (((ql_dbg_level & QLP16) != 0) && (ha->done_srb_q_count)) {
+		copy_info(&info, "\nDump done_srb_q:\n");
+		spin_lock_irqsave(&ha->list_lock, flags);
+		list_for_each_entry_safe(srb, stemp, &ha->done_srb_q,
+		    list_entry)
+			qla4xxx_proc_dump_srb_info(ha, &info, srb);
+		spin_unlock_irqrestore(&ha->list_lock, flags);
+		copy_info(&info, "\n");
+	}
+	copy_info(&info, "Keep Alive Timeout = %d\n", ha->port_down_retry_count);
+	
+	copy_info(&info, "Number of active commands = %d\n",
+		  ha->active_srb_count);
+
+	if (((ql_dbg_level & QLP16) != 0) && (ha->active_srb_count)) {
+		int i;
+
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+		copy_info(&info, "\nDump active commands:\n");
+		for (i = 1; i < MAX_SRBS; i++) {
+			srb_t *srb = ha->active_srb_array[i];
+			if (srb)
+				qla4xxx_proc_dump_srb_info(ha, &info, srb);
+		}
+		copy_info(&info, "\n");
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+	}
+
+	copy_info(&info, "Total number of IOCBs (used/max) "
+		  "= (%d/%d)\n", ha->iocb_cnt, ha->iocb_hiwat);
+	copy_info(&info, "Number of free srbs    = %d of %d\n",
+		  ha->free_srb_q_count, ha->num_srbs_allocated);
+	copy_info(&info, "\n");
+
+	qla4xxx_proc_dump_scanned_devices(ha, &info);
+	copy_info(&info, "\n");
+
+	if (test_bit(ISNS_FLAG_ISNS_ENABLED_IN_ISP, &ha->isns_flags))
+		qla4xxx_proc_dump_discovered_devices(ha, &info);
+
+	copy_info(&info, "\0");
+
+	retval = info.pos > info.offset ? info.pos - info.offset : 0;
+
+	QL4PRINT(QLP16, printk("scsi%d: Exiting %s: info.pos=%d, "
+			       "offset=0x%lx, length=0x%x\n",
+			       ha->host_no, __func__, info.pos, offset, length));
+
+	return(retval);
+}
+
+
+/**************************************************************************
+ * del_from_active_array
+ *      This routine removes and returns the srb at the specified index
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *      index - index into to the active_array
+ *
+ * Returns:
+ *      Pointer to corresponding SCSI Request Block
+ *
+ * Context:
+ *      Kernel/Interrupt context.
+ **************************************************************************/
+srb_t *
+del_from_active_array(scsi_qla_host_t *ha, uint32_t index)
+{
+	srb_t *srb = NULL;
+
+	/* validate handle and remove from active array */
+	if (index < MAX_SRBS) {
+		srb = ha->active_srb_array[index];
+		ha->active_srb_array[index] = 0;
+
+		if (srb) {
+			os_lun_t *lun_entry = srb->lun_queue;
+
+			/* update counters */
+			if ((srb->flags & SRB_DMA_VALID) != 0) {
+				ha->req_q_count += srb->entry_count;
+				ha->iocb_cnt -= srb->entry_count;
+				if (ha->active_srb_count)
+					ha->active_srb_count--;
+				if (lun_entry)
+					lun_entry->out_count--;
+				if (srb->cmd)
+					srb->cmd->host_scribble = NULL;
+			}
+		}
+		else
+			QL4PRINT(QLP2,
+				 printk("scsi%d: %s: array_index=%d "
+					"already completed.\n",
+					ha->host_no, __func__, index));
+	}
+	else
+		QL4PRINT(QLP2, printk("scsi%d: %s: array_index=%d "
+				      "exceeded max index of %d\n",
+				      ha->host_no, __func__, index, MAX_SRBS));
+
+	return(srb);
+}
+
+uint16_t
+qla4xxx_calc_request_entries(uint16_t dsds)
+{
+	uint16_t iocbs;/* number of request queue entries */
+				/* (commamd + continue) */
+	iocbs = 1;
+	if (dsds > COMMAND_SEG) {
+		iocbs += (dsds - COMMAND_SEG) / CONTINUE_SEG;
+		if ((dsds - COMMAND_SEG) % CONTINUE_SEG)
+			iocbs++;
+	}
+	return (iocbs);
+}
+
+void
+qla4xxx_build_scsi_iocbs(srb_t *srb, COMMAND_ENTRY *cmd_entry, uint16_t tot_dsds)
+{
+	scsi_qla_host_t	*ha;
+	uint16_t	avail_dsds;
+	DATA_SEG_A64 *cur_dsd;
+	struct scsi_cmnd *cmd;
+
+	cmd = srb->cmd;
+	ha = srb->ha;
+
+	if (cmd->request_bufflen == 0 ||
+	    cmd->sc_data_direction == DMA_NONE) {
+		/* No data being transferred */
+		QL4PRINT(QLP5, printk("scsi%d:%d:%d:%d: %s: No data xfer\n",
+		    ha->host_no, cmd->device->channel, cmd->device->id,
+		    cmd->device->lun, __func__));
+
+		cmd_entry->ttlByteCnt = __constant_cpu_to_le32(0);
+		return;
+	}
+
+	avail_dsds = COMMAND_SEG;
+	cur_dsd = (DATA_SEG_A64 *) &(cmd_entry->dataseg[0]);
+
+	/* Load data segments */
+	if (cmd->use_sg) {
+		struct  scatterlist *cur_seg;
+		struct  scatterlist *end_seg;
+
+		/* Data transfer with Scatter/Gather
+		 *
+		 * We must build an SG list in adapter format, as the kernel's
+		 * SG list cannot be used directly because of data field size
+		 * (__alpha__) differences and the kernel SG list uses virtual
+		 * addresses where we need physical addresses.
+		 */
+		cur_seg = (struct scatterlist *) cmd->request_buffer;
+		end_seg = cur_seg + tot_dsds;
+
+		while (cur_seg < end_seg) {
+			dma_addr_t sle_dma;
+
+			/* Allocate additional continuation packets? */
+			if (avail_dsds == 0) {
+				CONTINUE_ENTRY *cont_entry;
+
+				cont_entry = qla4xxx_alloc_cont_entry(ha);
+				cur_dsd = (DATA_SEG_A64 *) &cont_entry->dataseg[0];
+				avail_dsds = CONTINUE_SEG;
+			}
+
+			sle_dma = sg_dma_address(cur_seg);
+			cur_dsd->base.addrLow = cpu_to_le32(LSDW(sle_dma));
+			cur_dsd->base.addrHigh = cpu_to_le32(MSDW(sle_dma));
+			cur_dsd->count = cpu_to_le32(sg_dma_len(cur_seg));
+			avail_dsds--;
+
+			DEBUG(printk("scsi%d:%d:%d:%d: %s: S/G "
+			    "DSD %p phys_addr=%x:%08x, len=0x%x, tot_dsd=0x%x, "
+			    "avail_dsd=0x%x\n", ha->host_no,
+			    cmd->device->channel, cmd->device->id,
+			    cmd->device->lun, __func__, cur_dsd,
+			    cur_dsd->base.addrHigh, cur_dsd->base.addrLow,
+			    cur_dsd->count, tot_dsds, avail_dsds));
+
+			cur_dsd++;
+			cur_seg++;
+	}
+	} else {
+		/* Data transfer without SG entries. */
+		dma_addr_t	req_dma;
+		struct page	*page;
+		unsigned long	offset;
+
+		page = virt_to_page(cmd->request_buffer);
+		offset = ((unsigned long) cmd->request_buffer & ~PAGE_MASK);
+		req_dma = pci_map_page(ha->pdev, page, offset,
+		    cmd->request_bufflen, cmd->sc_data_direction);
+		srb->saved_dma_handle = req_dma;
+
+		cur_dsd->base.addrLow = cpu_to_le32(LSDW(req_dma));
+		cur_dsd->base.addrHigh = cpu_to_le32(MSDW(req_dma));
+		cur_dsd->count = cpu_to_le32(cmd->request_bufflen);
+
+		QL4PRINT(QLP5, printk("scsi%d:%d:%d:%d: %s: No S/G transfer, "
+		    "DSD=%p cmd=%p dma_addr=%x:%08x, len=%x, tot_dsd=0x%x, "
+		    "avail_dsd=0x%x\n", ha->host_no, cmd->device->channel,
+		    cmd->device->id, cmd->device->lun, __func__, cur_dsd, cmd,
+		    cur_dsd->base.addrHigh, cur_dsd->base.addrLow,
+		    cur_dsd->count, tot_dsds, avail_dsds));
+
+		cur_dsd++;
+	}
+}
+
+CONTINUE_ENTRY *
+qla4xxx_alloc_cont_entry(scsi_qla_host_t *ha)
+{
+        CONTINUE_ENTRY *cont_entry;
+        ENTER("qla4xxx_alloc_cont_entry");
+
+        cont_entry = (CONTINUE_ENTRY *)ha->request_ptr;
+
+        /* Advance request queue pointer */
+        if (ha->request_in == (REQUEST_QUEUE_DEPTH - 1)) {
+                ha->request_in = 0;
+                ha->request_ptr = ha->request_ring;
+                QL4PRINT(QLP10, printk("scsi%d: %s: wraparound -- new "
+                    "request_in = %04x, new request_ptr = %p\n", ha->host_no,
+                    __func__, ha->request_in, ha->request_ptr));
+        } else {
+		ha->request_in++;
+                ha->request_ptr++;
+                QL4PRINT(QLP10, printk("scsi%d: %s: new request_in = %04x, new "
+                    "request_ptr = %p\n", ha->host_no, __func__, ha->request_in,
+                    ha->request_ptr));
+        }
+
+        /* Load packet defaults */
+        cont_entry->hdr.entryType = ET_CONTINUE;
+        cont_entry->hdr.entryCount = 1;
+        cont_entry->hdr.systemDefined =
+        (uint8_t) cpu_to_le16(ha->request_in);
+
+        LEAVE("qla4xxx_alloc_cont_entry");
+        return(cont_entry);
+}
+
+/**************************************************************************
+ * qla4xxx_send_command_to_isp
+ *      This routine is called by qla4xxx_queuecommand to build an ISP
+ *      command and pass it to the ISP for execution.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *      srb - pointer to SCSI Request Block to be sent to ISP
+ *
+ * Output:
+ *      None
+ *
+ * Remarks:
+ *      None
+ *
+ * Returns:
+ *      QLA_SUCCESS - Successfully sent command to ISP
+ *      QLA_ERROR   - Failed to send command to ISP
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_send_command_to_isp(scsi_qla_host_t *os_ha, srb_t *srb)
+{
+	struct scsi_cmnd     *cmd = srb->cmd;
+	ddb_entry_t   *ddb_entry;
+	os_lun_t   *lun_entry;
+	COMMAND_ENTRY *cmd_entry;
+	struct scatterlist *sg = NULL;
+
+	uint16_t      tot_dsds;	/* number of data segments */
+				/* (sg entries, if sg request) */
+	uint16_t	req_cnt;	/* number of request queue entries */
+
+	unsigned long flags;
+	uint16_t	cnt;
+	uint16_t      i;
+	uint32_t      index;
+	fc_lun_t                *fclun;
+	scsi_qla_host_t *ha;
+	char		tag[2];
+	uint32_t	timeout;
+
+	ENTER("qla4xxx_send_command_to_isp");
+
+	/* Get real lun and adapter */
+	fclun = srb->lun_queue->fclun;
+	ha = fclun->fcport->ha;
+
+	cmd = srb->cmd;
+	ddb_entry = fclun->fcport->ddbptr;
+	lun_entry = srb->lun_queue;
+
+	/* Send marker(s) if needed. */
+	if (ha->marker_needed == 1) {
+		if (qla4xxx_send_marker_iocb(ha, ddb_entry, fclun) !=
+		    QLA_SUCCESS) {
+			return(QLA_ERROR);
+		}
+		ha->marker_needed = 0;
+	}
+
+	/* Acquire hardware specific lock */
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+
+	/* Check for room in active srb array */
+	index = ha->current_active_index;
+	for (i = 0; i < MAX_SRBS; i++) {
+		index++;
+		if (index == MAX_SRBS)
+			index = 1;
+		if (ha->active_srb_array[index] == 0) {
+			ha->current_active_index = index;
+			break;
+		}
+	}
+	if (i >= MAX_SRBS) {
+		printk(KERN_INFO "scsi%d: %s: NO more SRB entries"
+		    "used iocbs=%d, \n reqs remaining=%d\n", ha->host_no,
+		    __func__, ha->iocb_cnt, ha->req_q_count);
+		goto queuing_error;
+	}
+
+
+	/* Calculate the number of request entries needed. */
+	tot_dsds = 0;
+	if (cmd->use_sg) {
+		sg = (struct scatterlist *) cmd->request_buffer;
+		tot_dsds = pci_map_sg(ha->pdev, sg, cmd->use_sg,
+		    cmd->sc_data_direction);
+		if (tot_dsds == 0)
+			goto queuing_error;
+	} else if (cmd->request_bufflen) {
+	    tot_dsds++;
+	}
+	req_cnt = qla4xxx_calc_request_entries(tot_dsds);
+
+	if (ha->req_q_count < (req_cnt + 2)) {
+		// cnt = RD_REG_WORD_RELAXED(ISP_REQ_Q_OUT(ha));
+	    	cnt = (uint16_t) le32_to_cpu(ha->shadow_regs->req_q_out);
+		if (ha->request_in < cnt) {
+			ha->req_q_count = cnt - ha->request_in;
+		}
+		else {
+			ha->req_q_count = REQUEST_QUEUE_DEPTH - (ha->request_in - cnt);
+		}
+
+		DEBUG(printk(KERN_INFO "scsi%d: %s: new request queue count -"
+		    "calc req_q_count=%d, reqs needed=%d, shadow reqs=%d, req_in =%d\n", ha->host_no,
+		    __func__, ha->req_q_count, req_cnt, cnt, ha->request_in));
+	}
+
+	if (ha->req_q_count < (req_cnt + 2)) {
+		/* free the resources */
+		if (cmd->use_sg)
+			pci_unmap_sg(ha->pdev, sg, cmd->use_sg, cmd->sc_data_direction);
+
+		DEBUG(printk(KERN_INFO "scsi%d: %s: No more request queues, "
+		    "used iocbs=%d, \n reqs remaining=%d, reqs needed=%d\n",
+	            ha->host_no,
+		    __func__, ha->iocb_cnt, ha->req_q_count, req_cnt));
+		goto queuing_error;
+	}
+
+	/* total iocbs active */
+	if ((ha->iocb_cnt + req_cnt)  >= REQUEST_QUEUE_DEPTH ) {
+		if (cmd->use_sg)
+			pci_unmap_sg(ha->pdev, sg, cmd->use_sg, cmd->sc_data_direction);
+		goto queuing_error;
+	}
+
+	/* Build command packet */
+	cmd_entry = (COMMAND_ENTRY *) ha->request_ptr;
+	memset(cmd_entry, 0, sizeof(COMMAND_ENTRY));
+	cmd_entry->hdr.entryType = ET_COMMAND;
+	cmd_entry->handle = cpu_to_le32(index);
+	cmd_entry->target = cpu_to_le16(ddb_entry->fw_ddb_index);
+	cmd_entry->connection_id = cpu_to_le16(ddb_entry->connection_id);
+	
+	cmd_entry->lun[1] = LSB(cmd->device->lun);	/* SAMII compliant. */
+	cmd_entry->lun[2] = MSB(cmd->device->lun);
+	cmd_entry->cmdSeqNum = cpu_to_le32(ddb_entry->CmdSn);
+	cmd_entry->ttlByteCnt = cpu_to_le32(cmd->request_bufflen);
+	memcpy(cmd_entry->cdb, cmd->cmnd, MIN(MAX_COMMAND_SIZE, cmd->cmd_len));
+	cmd_entry->dataSegCnt = cpu_to_le16(tot_dsds);
+	cmd_entry->hdr.entryCount = req_cnt;
+
+	/* We want the firmware to time out the command first.*/
+	timeout = (uint32_t)(cmd->timeout_per_command / HZ);
+	if (timeout > 65535)
+                cmd_entry->timeout = __constant_cpu_to_le16(0);
+	else if (timeout > MIN_CMD_TOV)
+		cmd_entry->timeout = cpu_to_le16((uint16_t) timeout -
+					 (QLA_CMD_TIMER_DELTA+1));
+	else
+		cmd_entry->timeout = cpu_to_le16((uint16_t)timeout);
+
+	srb->iocb_tov = cmd_entry->timeout;
+	srb->os_tov = timeout;
+
+	/* Set data transfer direction control flags
+	 * NOTE: Look at data_direction bits iff there is data to be
+	 *       transferred, as the data direction bit is sometimed filled
+	 *       in when there is no data to be transferred */
+	cmd_entry->control_flags = CF_NO_DATA;
+	if (cmd->request_bufflen) {
+		if (cmd->sc_data_direction == DMA_TO_DEVICE)
+			cmd_entry->control_flags = CF_WRITE;
+		else if (cmd->sc_data_direction == DMA_FROM_DEVICE)
+			cmd_entry->control_flags = CF_READ;
+	}
+
+	/* Set tagged queueing control flags */
+	cmd_entry->control_flags |= CF_SIMPLE_TAG;
+	if (scsi_populate_tag_msg(cmd, tag)) {
+		switch (tag[0]) {
+		case MSG_HEAD_TAG:
+			cmd_entry->control_flags |= CF_HEAD_TAG;
+			break;
+		case MSG_ORDERED_TAG:
+			cmd_entry->control_flags |= CF_ORDERED_TAG;
+			break;
+		}
+	}
+
+	/* Advance request queue pointer */
+	ha->request_in++;
+        if (ha->request_in == REQUEST_QUEUE_DEPTH ) {
+                ha->request_in = 0;
+                ha->request_ptr = ha->request_ring;
+        } else {
+                ha->request_ptr++;
+        }
+
+	qla4xxx_build_scsi_iocbs(srb, cmd_entry, tot_dsds);
+
+	wmb();
+
+	/*
+	 * Check to see if adapter is online before placing request on
+	 * request queue.  If a reset occurs and a request is in the queue,
+	 * the firmware will still attempt to process the request, retrieving
+	 * garbage for pointers.
+	 */
+	if (!test_bit(AF_ONLINE, &ha->flags)) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: Adapter OFFLINE! "
+				      "Do not issue command.\n",
+                                      ha->host_no, __func__));
+		goto queuing_error;
+	}
+
+	/* put command in active array */
+	ha->active_srb_array[index] = srb;
+	srb->cmd->host_scribble = (unsigned char *)(unsigned long)index;
+	//srb->active_array_index = index;
+
+	/* update counters */
+	ha->active_srb_count++;
+	lun_entry->out_count++;
+	lun_entry->tot_io_count++;
+	srb->state = SRB_ACTIVE_STATE;
+	srb->flags |= SRB_DMA_VALID;
+
+	/* Track IOCB used */
+	ha->iocb_cnt += req_cnt;
+	srb->entry_count = req_cnt;
+	ha->req_q_count -= req_cnt;
+
+	/* Debug print statements */
+#ifdef QL_DEBUG_LEVEL_3
+	printk("scsi%d:%d:%d:%d: %s: CDB = ", ha->host_no,
+	    cmd->device->channel, cmd->device->target, cmd->device->lun,
+	    __func__);
+	for (i = 0; i < cmd->cmd_len; i++)
+		printk("%02x ", cmd->cmnd[i]);
+	printk("\n");
+#endif
+	srb->u_start = jiffies;
+	WRT_REG_DWORD(&ha->reg->req_q_in, ha->request_in);
+	PCI_POSTING(&ha->reg->req_q_in);
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	LEAVE("qla4xxx_send_command_to_isp");
+
+	return(QLA_SUCCESS);
+
+queuing_error:
+	/* Release hardware specific lock */
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	LEAVE("qla4xxx_send_command_to_isp");
+
+	return(QLA_ERROR);
+}
+
+/**************************************************************************
+* qla4xxx_done
+*      Process completed commands.
+*
+* Input:
+*      old_ha           = adapter block pointer.
+*
+* Returns:
+* int
+**************************************************************************/
+int
+qla4xxx_done(scsi_qla_host_t *old_ha)
+{
+	os_lun_t        *lq;
+	struct scsi_cmnd       *cmd;
+	unsigned long   flags = 0;
+	scsi_qla_host_t *ha;
+	scsi_qla_host_t *vis_ha;
+	int             cnt;
+	srb_t           *srb, *stemp;
+	struct  list_head local_sp_list;
+
+	ENTER(__func__);
+
+	cnt = 0;
+
+	INIT_LIST_HEAD(&local_sp_list);
+
+	/*
+	 * Get into local queue such that we do not wind up calling done queue
+	 * takslet for the same IOs from DPC or any other place.
+	 */
+	spin_lock_irqsave(&old_ha->list_lock,flags);
+	list_splice_init(&old_ha->done_srb_q, &local_sp_list);
+	spin_unlock_irqrestore(&old_ha->list_lock, flags);
+
+	list_for_each_entry_safe(srb, stemp, &local_sp_list, list_entry) {
+		old_ha->done_srb_q_count--;
+		srb->state = SRB_NO_QUEUE_STATE;
+		list_del_init(&srb->list_entry);
+
+		cnt++;
+
+		cmd = srb->cmd;
+		if (cmd == NULL) {
+#if 0
+			panic("%s: SP %p already freed - %s %d.\n",
+			      __func__, srb, __FILE__,__LINE__);
+#else
+			continue;
+#endif
+		}
+
+		if (cmd->device == NULL) {
+#if 0
+			panic("%s: SP %p already freed - %s %d.\n",
+			      __func__, srb, __FILE__,__LINE__);
+#else
+			//DEBUG2(printk("%s: sp %p already freed\n", __func__, srb);)
+			//DEBUG2(__dump_dwords(srb, sizeof(*srb)));
+			continue;
+#endif
+		}
+
+		vis_ha = (scsi_qla_host_t *)cmd->device->host->hostdata;
+		lq = srb->lun_queue;
+		if( lq == NULL ) {
+			DEBUG2(printk("%s: lq == NULL  , sp= %p, %s %d \n",
+			      __func__, srb, __FILE__,__LINE__);)
+			continue;
+		}
+		if( lq->fclun == NULL ) {
+			DEBUG2(printk("%s: lq->fclun == NULL  , sp=%p %s %d \n",
+			       __func__, srb,__FILE__,__LINE__);)
+			continue;
+		}
+		if( lq->fclun->fcport == NULL ) {
+			DEBUG2(printk("%s: lq->fclun->fcport == NULL  , sp=%p %s %d \n",
+			       __func__, srb,__FILE__,__LINE__);)
+			continue;
+		}
+		ha = srb->ha;
+		/* Release memory used for this I/O */
+		if ((srb->flags & SRB_DMA_VALID) != 0) {
+			srb->flags &= ~SRB_DMA_VALID;
+	
+			/* Release memory used for this I/O */
+			if (cmd->use_sg) {
+				pci_unmap_sg(ha->pdev,
+					     cmd->request_buffer,
+					     cmd->use_sg,
+					     cmd->sc_data_direction);
+			} else if (cmd->request_bufflen) {
+				pci_unmap_page(ha->pdev,
+					       srb->saved_dma_handle,
+					       cmd->request_bufflen,
+					       cmd->sc_data_direction);
+			}
+	
+			ha->total_mbytes_xferred += cmd->request_bufflen / 1024;
+			}
+
+		sp_put(vis_ha, srb);
+
+	} /* end of while */
+
+	LEAVE(__func__);
+
+	return(cnt);
+}
+
+/**************************************************************************
+ * qla4xxx_request_cleanup
+ *      This routine frees resources for a command that
+ *      didn't get completed.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *      srb - Pointer to SCSI Request Block
+ *
+ * Remarks:
+ *    The srb pointer should be guaranteed to be nonzero before calling
+ *    this function.  The caller should also ensure that the list_lock is
+ *    released before calling this function.
+ *
+ * Returns:
+ *
+ * Context:
+ *      Kernel/Interrupt context.
+ **************************************************************************/
+void
+qla4xxx_request_cleanup(scsi_qla_host_t *ha, srb_t *srb)
+{
+	struct scsi_cmnd *cmd;
+
+	qla4xxx_delete_timer_from_cmd(srb);
+
+	cmd = srb->cmd;
+	/*  Let abort handler know we are completing the command */
+	CMD_SP(cmd) = NULL;
+
+	/* Release memory used for this I/O */
+	if ( (srb->flags & SRB_DMA_VALID) ) {
+		srb->flags &= ~SRB_DMA_VALID;
+
+		/* Release memory used for this I/O */
+		if (cmd->use_sg) {
+			pci_unmap_sg(ha->pdev,
+				     cmd->request_buffer,
+				     cmd->use_sg,
+				     cmd->sc_data_direction);
+		}
+		else if (cmd->request_bufflen) {
+			pci_unmap_page(ha->pdev,
+				       srb->saved_dma_handle,
+				       cmd->request_bufflen,
+				       srb->cmd->sc_data_direction);
+		}
+	}
+
+	srb->cmd = NULL;
+	add_to_free_srb_q(ha, srb);
+
+}
+
+/**************************************************************************
+ * qla4xxx_complete_request
+ *      This routine returns a command to the caller via the done_fn
+ *      specified in the cmd structure.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *      srb - Pointer to SCSI Request Block
+ *
+ * Remarks:
+ *    The srb pointer should be guaranteed to be nonzero before calling
+ *    this function.  The caller should also ensure that the list_lock is
+ *    released before calling this function.
+ *
+ * Returns:
+ *      QLA_SUCCESS - Successfully completed request
+ *      QLA_ERROR   - Failed to complete request
+ *
+ * Context:
+ *      Kernel/Interrupt context.
+ **************************************************************************/
+uint8_t
+qla4xxx_complete_request(scsi_qla_host_t *ha, srb_t *srb)
+{
+	uint8_t status = QLA_ERROR;
+	struct scsi_cmnd *cmd;
+
+	//ENTER("qla4xxx_complete_request");
+
+	/* Make sure the cmd pointer is valid */
+	if (srb == NULL) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: ERROR: NULL srb \n",
+				      ha->host_no, __func__));
+		goto exit_complete_request;
+	}
+	if ((srb->flags & SRB_FREE_STATE) == 0)
+		qla4xxx_delete_timer_from_cmd(srb);
+
+	cmd = srb->cmd;
+	if (cmd == NULL) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: ERROR: NULL cmd pointer in "
+				"srb=%p\n", ha->host_no, __func__, srb));
+
+		goto exit_complete_request;
+	}
+
+	/*  Let abort handler know we are completing the command */
+	CMD_SP(cmd) = NULL;
+
+
+	/* Release memory used for this I/O */
+	if ((srb->flags & SRB_DMA_VALID) != 0) {
+		srb->flags &= ~SRB_DMA_VALID;
+
+		/* Release memory used for this I/O */
+		if (cmd->use_sg) {
+			QL4PRINT(QLP5,
+				 printk("scsi%d: %s: S/G unmap_sg cmd=%p\n",
+					ha->host_no, __func__, cmd));
+
+			pci_unmap_sg(ha->pdev,
+				     cmd->request_buffer,
+				     cmd->use_sg,
+				     cmd->sc_data_direction);
+		}
+		else if (cmd->request_bufflen) {
+			QL4PRINT(QLP5,
+				 printk("scsi%d: %s: No S/G unmap_single "
+					"cmd=%p saved_dma_handle=%x\n",
+					ha->host_no, __func__, cmd,
+					(uint32_t) srb->saved_dma_handle));
+
+			pci_unmap_page(ha->pdev,
+				       srb->saved_dma_handle,
+				       cmd->request_bufflen,
+				       srb->cmd->sc_data_direction);
+		}
+
+		ha->total_mbytes_xferred += cmd->request_bufflen / 1024;
+	}
+
+	if (host_byte(cmd->result) == DID_OK) {
+		if (!(srb->flags & SRB_GOT_SENSE)) {
+			os_lun_t *lun_entry = srb->lun_queue;
+			unsigned long flags;
+
+			if (lun_entry) {
+				/*
+				 * If lun was not ready (suspended or timeout)
+				 * then change state to "READY".
+				 */
+				spin_lock_irqsave(&lun_entry->lun_lock, flags);
+				if (lun_entry->lun_state != LS_LUN_READY) {
+					lun_entry->lun_state = LS_LUN_READY;
+				}
+				spin_unlock_irqrestore(&lun_entry->lun_lock, flags);
+			}
+		}
+	}
+
+	#ifdef DEBUG
+	/* debug prints */
+	// qla4xxx_dump_command(ha, cmd);
+
+	#endif
+#if 0
+	if (host_byte(cmd->result) != DID_OK ) {
+			    DEBUG2(printk("scsi%d:%d:%d:%d: %s: "
+				"did_error=%d, cmd=%p cbd[0]=%02X, pid=%ld\n",
+				ha->host_no, cmd->device->channel, cmd->device->id,
+				cmd->device->lun,
+				__func__,
+				host_byte(cmd->result),
+				cmd, cmd->data_cmnd[0],
+    				cmd->serial_number));
+	}
+#endif
+	/*
+	 * WORKAROUND
+	 * A backdoor device-reset (via eh_resets) requires different
+	 * error handling.  This code differentiates between normal
+	 * error handling and the backdoor method
+	 */
+	if (host_byte(cmd->result) == DID_RESET) {
+		if (qla4xxx_is_eh_active(ha->host))
+			// srb->cmd->result = DID_IMM_RETRY << 16;
+			srb->cmd->result = DID_BUS_BUSY << 16;
+	}
+
+#ifdef QL_DEBUG_LEVEL_3
+	if (cmd->result & 0xff) {
+		QL4PRINT(QLP13,
+			 printk("REQUEST_SENSE data:  "
+				"(MAX 0x20 bytes displayed)\n"));
+
+		qla4xxx_dump_bytes(QLP13, cmd->sense_buffer,
+				   MIN(0x20, sizeof(cmd->sense_buffer)));
+	}
+#endif
+
+	/* Call the mid-level driver interrupt handler */
+	srb->cmd = NULL;
+	add_to_free_srb_q(ha, srb);
+
+
+	// CMD_SP(cmd) = NULL;
+	(*(cmd)->scsi_done)(cmd);
+
+	exit_complete_request:
+	//LEAVE("qla4xxx_complete_request");
+
+	return(status);
+}
+
+/**************************************************************************
+ * qla4xxx_queuecommand
+ *      This routine is invoked by Linux to send a SCSI command to the driver.
+ *
+ * Input:
+ *      cmd - Pointer to Linux's SCSI command structure
+ *      done_fn - Function that the driver calls to notify the SCSI mid-layer
+ *                that the command has been processed.
+ *
+ * Remarks:
+ *    The mid-level driver tries to ensure that queuecommand never gets
+ *    invoked concurrently with itself or the interrupt handler (although
+ *    the interrupt handler may call this routine as part of request-
+ *    completion handling).   Unfortunely, it sometimes calls the scheduler
+ *    in interrupt context which is a big NO! NO!.
+ *
+ * Returns:
+ *      None
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+int
+qla4xxx_queuecommand(struct scsi_cmnd *cmd, void (*done_fn)(struct scsi_cmnd *))
+{
+	scsi_qla_host_t *ha;
+	ddb_entry_t     *ddb_entry;
+	os_lun_t     *lun_entry;
+	os_tgt_t     *tgt_entry;
+	uint32_t        b, t, l;
+	int             return_status = 0;
+	srb_t           *srb;
+	fc_port_t       *fcport;
+	fc_lun_t       *fclun;
+
+	b = cmd->device->channel;
+	t = cmd->device->id;
+	l = cmd->device->lun;
+	ha = (scsi_qla_host_t *) cmd->device->host->hostdata;
+
+	cmd->scsi_done = done_fn;
+	spin_unlock_irq(ha->host->host_lock);
+
+	/*
+	 * Allocate a comand packet
+	 */
+	srb = del_from_free_srb_q_head(ha);
+	if (srb == NULL) {
+		DEBUG2(printk("scsi%d: %s: srb not available\n"
+		    , ha->host_no, __func__);)
+		DEBUG2(printk("Number of free srbs   = %d of %d\n",
+		  ha->free_srb_q_count, ha->num_srbs_allocated);)
+
+		spin_lock_irq(ha->host->host_lock);
+
+		return (1);
+	}
+
+	/* Link the srb with cmd */
+	srb->cmd = cmd;
+	CMD_SP(cmd) = (void *)srb;
+	srb->r_start = jiffies;
+	srb->flags = 0;
+	srb->err_id = 0;
+	srb->ha = ha;
+	srb->iocb_cnt = 0;
+
+	/* Start command timer. */
+	if ((cmd->timeout_per_command/HZ) > MIN_CMD_TOV)
+		qla4xxx_add_timer_to_cmd(srb, (cmd->timeout_per_command / HZ) -
+		    QLA_CMD_TIMER_DELTA);
+	else
+		qla4xxx_add_timer_to_cmd(srb, (cmd->timeout_per_command / HZ));
+
+	/* retrieve device and lun handles */
+	tgt_entry = qla4xxx_lookup_target_by_SCSIID(ha, b, t);
+	if (tgt_entry ==  NULL) {
+		cmd->result = DID_NO_CONNECT << 16;
+		goto qc_complete;
+	}
+	
+	lun_entry = qla4xxx_lookup_lun_handle(ha, tgt_entry, l);
+	if (lun_entry == NULL) {
+
+		/* If no target, don't create lun */
+		if (tgt_entry->fcport == NULL) {
+			cmd->result = DID_NO_CONNECT << 16;
+			goto qc_complete;
+		}
+
+		/* Only allocate luns for ddb device state SESSION_ACTIVE */
+		if (tgt_entry->fcport->ddbptr->fw_ddb_device_state != DDB_DS_SESSION_ACTIVE) {
+			cmd->result = DID_NO_CONNECT << 16;
+			goto qc_complete;
+		}
+
+		/*
+		 * Allocate a LUN queue for this request if we haven't
+		 * already did it on a previous command.
+		 */
+		fcport = tgt_entry->fcport;
+		fclun = qla4xxx_add_fclun(fcport, l);
+		if (fclun == NULL) {
+			DEBUG2(printk("%s: Can't get FCLUN queue.\n",
+			    __func__);)
+			cmd->result = DID_ERROR << 16;
+			goto qc_complete;
+		}
+		
+		/* Assume this type right now and fixup after command completes */
+		fclun->device_type = TYPE_DISK;
+		lun_entry = qla4xxx_fclun_bind(ha, fcport, fclun);
+		if( lun_entry  == NULL ) {
+			DEBUG2(printk("%s: Can't Bind or allocate LUN queue.\n",
+		    __func__);)
+			cmd->result = DID_ERROR << 16;
+			goto qc_complete;
+		}
+	}
+
+	srb->tgt_queue = tgt_entry;
+	srb->lun_queue = lun_entry;
+	srb->fclun = lun_entry->fclun;
+	if (lun_entry->fclun == NULL) {
+		cmd->result = DID_NO_CONNECT << 16;
+		DEBUG2(printk(
+		    "scsi%d: (lq->fclun == NULL) pid=%ld,lq=%p\n",
+    		ha->host_no, srb->cmd->serial_number, lun_entry));
+		goto qc_complete;
+	}
+	fcport = lun_entry->fclun->fcport;
+	if (fcport ==  NULL) {
+		cmd->result = DID_NO_CONNECT << 16;
+		DEBUG2(printk(
+		 "scsi%d: (lq->fclun->fcport == NULL) pid=%ld, lq=%p,"
+		 "lq->fclun=%p\n",
+    		ha->host_no, srb->cmd->serial_number,
+		lun_entry, lun_entry->fclun));
+		goto qc_complete;
+	}
+
+	ddb_entry = fcport->ddbptr;
+	if (ddb_entry ==  NULL) {
+		cmd->result = DID_NO_CONNECT << 16;
+		DEBUG2(printk("scsi%d: (ddbptr == NULL) pid=%ld, ddb entry=%p\n",
+    		ha->host_no, srb->cmd->serial_number, ddb_entry));
+		goto qc_complete;
+	}
+	srb->ha = fcport->ha;
+
+	/* Only modify the allowed count if the target is a *non* tape device */
+	if ( !(fcport->flags & FCF_TAPE_PRESENT) &&
+	    cmd->allowed < ql4xcmdretrycount)
+		cmd->allowed = ql4xcmdretrycount;
+	
+	if ( (fcport->flags & FCF_TAPE_PRESENT) ||
+		(fcport->flags & FCF_NONFO_DEVICE) )
+		srb->flags |= SRB_TAPE;
+	
+	if (atomic_read(&fcport->state) == FCS_DEVICE_DEAD) {
+		cmd->result = DID_NO_CONNECT << 16;
+		if (!test_bit(AF_LINK_UP, &fcport->ha->flags))
+			srb->err_id = SRB_ERR_LOOP;
+		else
+			srb->err_id = SRB_ERR_PORT;
+		DEBUG2(printk(
+		    "scsi%d: PORT DEAD cmd=%p cdb[0]=%02X, cmd_err_flag=0x%x "
+		    "errid=%d, fcport=%p, did_error=%x\n",
+    		ha->host_no, srb->cmd, srb->cmd->data_cmnd[0], srb->cmd->eh_eflags,
+		srb->err_id, fcport, host_byte(cmd->result)));
+		add_to_done_srb_q(ha, srb);
+		qla4xxx_done(ha);
+		spin_lock_irq(ha->host->host_lock);
+		return 0;
+	}
+
+	/*
+	 * If the device is missing or the adapter is OFFLINE,
+	 * put the request on the retry queue.
+	 */
+	if (atomic_read(&ddb_entry->state) == DEV_STATE_MISSING ||
+	    !ADAPTER_UP(fcport->ha)) {
+		DEBUG2(printk("scsi%d: PORT missing or HBA link-down"
+		    "-ddb state=0x%x, hba flags=0x%lx, pid=%ld"
+		    "\n", fcport->ha->host_no,
+		    atomic_read(&ddb_entry->state),
+		    fcport->ha->flags, srb->cmd->serial_number));
+
+		qla4xxx_device_suspend(ha, lun_entry, srb);
+		spin_lock_irq(ha->host->host_lock);
+		return 0;
+	}
+
+	/*
+	 * If this request's lun is suspended then put the request on
+	 * the  scsi_retry queue.
+	 */
+	if (lun_entry->lun_state == LS_LUN_SUSPENDED) {
+		DEBUG2(printk("scsi%d: Lun suspended - pid=%ld - "
+		    "retry_q\n", fcport->ha->host_no,
+		    srb->cmd->serial_number));
+
+		qla4xxx_device_suspend(ha, lun_entry, srb);
+		spin_lock_irq(ha->host->host_lock);
+		return 0;
+	}
+
+	DEBUG(printk(
+		    "scsi%d: %s pid=%ld, errid=%d, sp->flags=0x%x fcport=%p\n",
+    		ha->host_no, __func__, srb->cmd->serial_number, srb->err_id, srb->flags, fcport));
+
+	/* If target suspended put incoming I/O in retry_q. */
+	if (test_bit(TQF_SUSPENDED, &tgt_entry->flags) &&
+	    (srb->flags & SRB_TAPE) == 0) {
+		qla4xxx_device_suspend(ha, lun_entry, srb);
+		spin_lock_irq(ha->host->host_lock);
+		return 0;
+	}
+
+	if (qla4xxx_send_command_to_isp(ha, srb) != QLA_SUCCESS) {
+		/*
+		 * Unable to send command to the ISP at this time.
+		 * Notify the OS to queue commands.
+		 */
+		DEBUG(printk("scsi%d: %s: unable to send cmd "
+		    "to ISP, retry later\n", ha->host_no, __func__));
+		qla4xxx_request_cleanup(ha, srb);
+		return_status = SCSI_MLQUEUE_HOST_BUSY;	
+
+	}
+	spin_lock_irq(ha->host->host_lock);
+	return(return_status);
+
+qc_complete:
+	qla4xxx_complete_request(ha, srb);
+
+	spin_lock_irq(ha->host->host_lock);
+	return(return_status);
+}
+
+/**************************************************************************
+ * qla4xxx_device_suspend
+ *      This routine is invoked by driver to stall the request queue
+ *
+ * Input:
+ *
+ * Remarks:
+ *	This routine calls the scsi_device_quiesce which may go to sleep.
+ * Returns:
+ *      None
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+int
+qla4xxx_device_suspend( scsi_qla_host_t *ha, os_lun_t *lun_entry, srb_t *srb )
+{
+	qla4xxx_extend_timeout(srb->cmd, EXTEND_CMD_TOV);
+	add_to_retry_srb_q(ha, srb);
+	return 0;
+}
+
+/**************************************************************************
+ * qla4xxx_extend_timeout
+ *      This routine will extend the timeout to the specified value.
+ *
+ * Input:
+ *      cmd - Pointer to Linux's SCSI command structure
+ *      timeout - Amount of time to extend the OS timeout
+ *
+ * Returns:
+ *      None
+ *
+ * Context:
+ *      Kernel/Interrupt context.
+ **************************************************************************/
+void
+qla4xxx_extend_timeout(struct scsi_cmnd *cmd, int timeout)
+{
+	srb_t *srb = (srb_t *) CMD_SP(cmd);
+	u_long our_jiffies = (timeout * HZ) + jiffies;
+
+	if (timer_pending(&cmd->eh_timeout)) {
+		mod_timer(&cmd->eh_timeout,our_jiffies);
+	}
+	if (timer_pending(&srb->timer)) {
+		/*
+		 * Our internal timer should timeout before the midlayer has a
+		 * chance begin the abort process
+		 */
+		mod_timer(&srb->timer,
+			  our_jiffies - (QLA_CMD_TIMER_DELTA * HZ));
+	}
+}
+
+
+/**************************************************************************
+ * qla4xxx_os_cmd_timeout
+ *
+ * Description:
+ *       Handles the command if it times out in any state.
+ *
+ * Input:
+ *     sp - pointer to validate
+ *
+ * Returns:
+ * None.
+ **************************************************************************/
+void
+qla4xxx_os_cmd_timeout(srb_t *sp)
+{
+	int t, l;
+	int processed;
+	scsi_qla_host_t *vis_ha, *dest_ha;
+	struct scsi_cmnd *cmd;
+	ulong      flags;
+	ulong      cpu_flags;
+	fc_port_t       *fcport;
+
+	cmd = sp->cmd;
+	vis_ha = (scsi_qla_host_t *) cmd->device->host->hostdata;
+
+	DEBUG2(printk("scsi%d: %s: sp->state = %x\n",
+		      vis_ha->host_no, __func__, sp->state);)
+
+	t = cmd->device->id;
+	l = cmd->device->lun;
+	fcport = sp->fclun->fcport;
+	dest_ha = sp->ha;
+
+	/*
+	 * If IO is found either in retry Queue
+	 *    OR in Lun Queue
+	 * Return this IO back to host
+	 */
+	processed = 0;
+	spin_lock_irqsave(&dest_ha->list_lock, flags);
+	if ((sp->state == SRB_RETRY_STATE)
+	    ) {
+
+		DEBUG2(printk("scsi%d: Found in (Scsi) Retry queue "
+			      "pid %ld, State = %x., "
+			      "fcport state=%d jiffies=%lx retried=%d\n",
+			      dest_ha->host_no,
+			      sp->cmd->serial_number, sp->state,
+			      atomic_read(&fcport->state),
+			      jiffies, sp->cmd->retries);)
+
+		if ((sp->state == SRB_RETRY_STATE)) {
+			__del_from_retry_srb_q(dest_ha, sp);
+		}
+
+		/*
+		 * If FC_DEVICE is marked as dead return the cmd with
+		 * DID_NO_CONNECT status.  Otherwise set the host_byte to
+		 * DID_IMM_RETRY to let the OS  retry this cmd.
+		 */
+			if (atomic_read(&fcport->state) == FCS_DEVICE_DEAD) {
+				qla4xxx_extend_timeout(cmd, EXTEND_CMD_TOV);
+				cmd->result = DID_NO_CONNECT << 16;
+				if (!test_bit(AF_LINK_UP, &fcport->ha->flags))
+					sp->err_id = SRB_ERR_LOOP;
+				else
+					sp->err_id = SRB_ERR_PORT;
+			}
+			else {
+				cmd->result = DID_BUS_BUSY << 16;
+			}
+
+		__add_to_done_srb_q(dest_ha, sp);
+		processed++;
+	}
+	spin_unlock_irqrestore(&dest_ha->list_lock, flags);
+	if (processed) {
+		qla4xxx_done(dest_ha);
+		DEBUG2(printk("scsi%d: %s: Leaving 1\n", dest_ha->host_no, __func__);)
+		return;
+	}
+
+	spin_lock_irqsave(&dest_ha->list_lock, cpu_flags);
+	if (sp->state == SRB_DONE_STATE) {
+		/* IO in done_q  -- leave it */
+		DEBUG2(printk("scsi%d: %s: Found in Done queue pid %ld sp=%p.\n",
+			      dest_ha->host_no, __func__, sp->cmd->serial_number, sp);)
+	}
+	else if (sp->state == SRB_SUSPENDED_STATE) {
+		DEBUG2(printk("scsi%d: %s: Found SP %p in suspended state  "
+			      "- pid %ld:\n",
+			      dest_ha->host_no,__func__, sp,
+			      sp->cmd->serial_number);)
+	}
+	else if (sp->state == SRB_ACTIVE_STATE) {
+		/*
+		 * IO is with ISP find the command in our active list.
+		 */
+		spin_unlock_irqrestore(&dest_ha->list_lock, cpu_flags);	/* 01/03 */
+		spin_lock_irqsave(&dest_ha->hardware_lock, flags);
+		if (sp == dest_ha->active_srb_array
+		    [(unsigned long)sp->cmd->host_scribble]) {
+
+			if (sp->flags & SRB_TAPE) {
+				/*
+				 * We cannot allow the midlayer error handler
+				 * to wakeup and begin the abort process.
+				 * Extend the timer so that the firmware can
+				 * properly return the IOCB.
+				 */
+				DEBUG2(printk("scsi%d: %s: Extending timeout "
+					      "of FCP2 tape command!\n",
+					      dest_ha->host_no, __func__));
+				qla4xxx_extend_timeout(sp->cmd,
+						       EXTEND_CMD_TOV);
+			}
+
+			sp->state = SRB_ACTIVE_TIMEOUT_STATE;
+			spin_unlock_irqrestore(&dest_ha->hardware_lock, flags);
+		}
+		else {
+			spin_unlock_irqrestore(&dest_ha->hardware_lock, flags);
+			DEBUG2(printk(
+			       "scsi%d: %s: State indicates it is with "
+			       "ISP, But not in active array\n",
+			       dest_ha->host_no, __func__));
+		}
+		spin_lock_irqsave(&dest_ha->list_lock, cpu_flags);
+	}
+	else if (sp->state == SRB_ACTIVE_TIMEOUT_STATE) {
+		/* double timeout */
+	}
+	else {
+		/* EMPTY */
+		DEBUG3(printk("scsi%d: %s: LOST command state = "
+			      "0x%x, sp=%p\n",
+			      vis_ha->host_no, __func__, sp->state, sp);)
+
+		printk(KERN_INFO
+		       "scsi%d: %s: LOST command state = 0x%x\n",
+			dest_ha->host_no, __func__, sp->state);
+	}
+	spin_unlock_irqrestore(&dest_ha->list_lock, cpu_flags);
+}
+
+
+/**************************************************************************
+ * qla4xxx_add_timer_to_cmd
+ *      This routine creates a timer for the specified command. The timeout
+ *      is usually the command time from kernel minus 2 secs.
+ *
+ * Input:
+ *      srb - Pointer to SCSI Request Block
+ *      timeout - Number of seconds to extend command timeout.
+ *
+ * Returns:
+ *      None
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+void
+qla4xxx_add_timer_to_cmd(srb_t *srb, int timeout)
+{
+	init_timer(&srb->timer);
+	srb->timer.expires = jiffies + timeout * HZ;
+	srb->timer.data = (unsigned long) srb;
+	srb->timer.function = (void (*) (unsigned long))qla4xxx_os_cmd_timeout;
+	add_timer(&srb->timer);
+	QL4PRINT(QLP3, printk("%s: srb %p, timeout %d\n",
+			      __func__, srb, timeout));
+}
+
+/**************************************************************************
+ * qla4xxx_delete_timer_from_cmd
+ *      This routine deletes the timer for the specified command.
+ *
+ * Input:
+ *      srb - Pointer to SCSI Request Block
+ *
+ * Returns:
+ *      None
+ *
+ * Context:
+ *      Kernel/Interrupt context.
+ **************************************************************************/
+void
+qla4xxx_delete_timer_from_cmd(srb_t *srb )
+{
+	if (timer_pending(&srb->timer)) {
+		del_timer(&srb->timer);
+		srb->timer.function =  NULL;
+		srb->timer.data = (unsigned long) NULL;
+	}
+}
+
+
+/****************************************************************************/
+/*                        Interrupt Service Routine.                        */
+/****************************************************************************/
+
+/**************************************************************************
+ * qla4xxx_timer
+ *      This routine is scheduled to be invoked every second to search for
+ *      work to do.
+ *
+ * Input:
+ *      p - Pointer to host adapter structure.
+ *
+ * Returns:
+ *      None
+ *
+ * Context:
+ *      Interrupt context.
+ **************************************************************************/
+void
+qla4xxx_timer(unsigned long p)
+{
+	scsi_qla_host_t *ha = (scsi_qla_host_t *) p;
+	ddb_entry_t *ddb_entry, *dtemp;
+	int             start_dpc = 0;
+	os_lun_t *lun_entry;
+	unsigned long cpu_flags;
+	int             t, l;
+
+#if ISP_RESET_TEST
+	if (ha->isp_reset_timer++ == (60 *3)) {
+		printk("scsi%d: %s going to schedule BIG HAMMER\n",
+		       ha->host_no, __func__);
+
+		set_bit(DPC_RESET_HA, &ha->dpc_flags);
+		ha->isp_reset_timer = 0;
+	}
+#endif
+#if NIC_RESET_TEST
+	if (ha->nic_reset_timer++ == (60 *3)) {
+
+		printk("scsi%d: %s ********** simulated NIC Reset ***********\n",
+		       ha->host_no, __func__);
+
+		set_bit(DPC_RESET_NIC_TEST, &ha->dpc_flags);
+		ha->nic_reset_timer = 0;
+	}
+#endif
+
+	DEBUG3(printk("scsi%d: %s: Host%d=%d/%d flags=[%lx,%lx,%lx] <%d,%d> "
+	    "AEN in/out={%d/%d}, counters={%d,%d} %d\n", ha->host_no, __func__, ha->instance,
+	    ha->spurious_int_count, (uint32_t)ha->isr_count, ha->flags,
+	    ha->dpc_flags, ha->isns_flags, ha->aborted_io_count,
+	    ha->mailbox_timeout_count, ha->aen_in, ha->aen_out,
+	    ha->retry_srb_q_count,
+	    ha->active_srb_count, ha->seconds_since_last_intr));
+
+	/* Do we need to process the retry queue? */
+	if (!list_empty(&ha->retry_srb_q)) {
+		start_dpc++;
+	}
+
+	/* LUN suspension */
+	for (t = 0; t < MAX_TARGETS; t++) {
+		for (l = 0; l < MAX_LUNS ; l++) {
+			lun_entry = GET_LU_Q(ha, t, l);
+			if (lun_entry == NULL)
+				continue;
+
+			spin_lock_irqsave(&lun_entry->lun_lock, cpu_flags);
+			if (lun_entry->lun_state != LS_LUN_SUSPENDED ||
+			    !atomic_read(&lun_entry->suspend_timer)) {
+				spin_unlock_irqrestore(&lun_entry->lun_lock,
+				    cpu_flags);
+				continue;
+			}
+
+			DEBUG2(printk("scsi%d: %s:"
+			    "suspended lun_q - lun=%d, timer=%d "
+			    "retry_count=%d\n", ha->host_no, __func__,
+			    lun_entry->lun,
+			    atomic_read(&lun_entry->suspend_timer),
+			    lun_entry->retry_count));
+
+			if (!atomic_dec_and_test(&lun_entry->suspend_timer)) {
+				spin_unlock_irqrestore(&lun_entry->lun_lock,
+				    cpu_flags);
+				continue;
+			}
+
+			
+			if (test_and_clear_bit(LF_LUN_DELAYED,
+			    &lun_entry->flags)) {
+				lun_entry->lun_state = LS_LUN_READY;
+			} else {
+				lun_entry->retry_count++;
+				if (lun_entry->retry_count ==
+				    lun_entry->max_retry_count) {
+					DEBUG2(printk("scsi%d: %s: LUN "
+					    "%d TIMEOUT RETRY_CNT:%d\n",
+					    ha->host_no, __func__,
+					    lun_entry->lun,
+					    lun_entry->retry_count));
+
+					lun_entry->lun_state = LS_LUN_TIMEOUT;
+				} else {
+					DEBUG2(printk("scsi%d: %s: LUN "
+					    "%d RETRY\n", ha->host_no, __func__,
+					    lun_entry->lun));
+
+					lun_entry->lun_state = LS_LUN_RETRY;
+				}
+			}
+			spin_unlock_irqrestore(&lun_entry->lun_lock, cpu_flags);
+		}
+	}
+
+	/*
+	 * Search for relogin's to time-out and port down retry.
+	 */
+	list_for_each_entry_safe(ddb_entry, dtemp, &ha->ddb_list, list_entry) {
+		/* First check to see if the device has exhausted the
+		 * port down retry count */
+		if (atomic_read(&ddb_entry->state) == DEV_STATE_MISSING) {
+			if (atomic_read(&ddb_entry->port_down_timer) == 0)
+				continue;
+
+			if (atomic_dec_and_test(&ddb_entry->port_down_timer)) {
+				DEBUG2(printk("scsi%d: %s: index [%d] "
+				    "port down retry count of (%d) secs "
+				    "exhausted, marking device DEAD.\n",
+				    ha->host_no, __func__,
+				    ddb_entry->fw_ddb_index,
+				    ha->port_down_retry_count);)
+
+				atomic_set(&ddb_entry->state, DEV_STATE_DEAD);
+				if (ddb_entry->fcport)
+					atomic_set(&ddb_entry->fcport->state,
+					    FCS_DEVICE_DEAD);
+
+				DEBUG2(printk("scsi%d:%d:%d: "
+				    "%s: index [%d] marked DEAD\n", ha->host_no,
+				    ddb_entry->bus, ddb_entry->target, __func__,
+				    ddb_entry->fw_ddb_index);)
+				start_dpc++;
+			}
+		}
+
+
+		/* Count down time between sending relogins */
+		if (ADAPTER_UP(ha) && (!test_bit(DF_RELOGIN, &ddb_entry->flags) &&
+		    (atomic_read(&ddb_entry->state) != DEV_STATE_ONLINE))) {
+			if (atomic_read(&ddb_entry->retry_relogin_timer) !=
+			    INVALID_ENTRY) {
+				if (atomic_read(&ddb_entry->retry_relogin_timer) == 0) {
+					atomic_set(&ddb_entry->retry_relogin_timer, INVALID_ENTRY);
+					set_bit(DPC_RELOGIN_DEVICE,
+					    &ha->dpc_flags);
+					set_bit(DF_RELOGIN,
+					    &ddb_entry->flags);
+					DEBUG2(printk("scsi%d:%d:%d: "
+				    "%s: index [%d] login device\n", ha->host_no,
+				    ddb_entry->bus, ddb_entry->target, __func__,
+				    ddb_entry->fw_ddb_index);)
+				} else
+					atomic_dec(&ddb_entry->retry_relogin_timer);
+			}
+		}
+
+		/* Wait for relogin to timeout */
+		if (atomic_read(&ddb_entry->relogin_timer)  &&
+		    (atomic_dec_and_test(&ddb_entry->relogin_timer) != 0)) {
+			/*
+			 * If the relogin times out and the device is
+			 * still NOT ONLINE then try and relogin again.
+			 */
+			if (atomic_read(&ddb_entry->state) !=
+			    DEV_STATE_ONLINE &&
+			    ddb_entry->fw_ddb_device_state ==
+			    DDB_DS_SESSION_FAILED) {
+				/* Reset retry relogin timer */
+				atomic_inc(&ddb_entry->relogin_retry_count);
+				QL4PRINT(QLP2, printk(
+				    "scsi%d:%d:%d: index[%d] relogin timed "
+				    "out-retrying relogin (%d)\n", ha->host_no,
+				    ddb_entry->bus, ddb_entry->target,
+				    ddb_entry->fw_ddb_index,
+				    atomic_read(&ddb_entry->relogin_retry_count)));
+				start_dpc++;
+				QL4PRINT(QLP3, printk(
+				    "scsi%d:%d:%d: index [%d] initate relogin "
+				    "after %d seconds\n", ha->host_no,
+				    ddb_entry->bus, ddb_entry->target,
+				    ddb_entry->fw_ddb_index,
+				    ddb_entry->default_time2wait+4));
+
+				atomic_set(&ddb_entry->retry_relogin_timer,
+				    ddb_entry->default_time2wait + 4);
+			}
+		}
+	}
+
+	if (!list_empty(&ha->done_srb_q)) {
+		DEBUG2(printk("scsi%d: %s:"
+			   "Pending done_q requests, "
+			    "=%d\n", ha->host_no, __func__,
+			    ha->done_srb_q_count));
+		start_dpc++;
+	}
+
+	/*
+	 * Check for heartbeat interval
+	 */
+	if ((ha->firmware_options & FWOPT_HEARTBEAT_ENABLE) &&
+	    (ha->heartbeat_interval != 0)) {
+		ha->seconds_since_last_heartbeat ++;
+
+		if (ha->seconds_since_last_heartbeat >
+		    ha->heartbeat_interval+2) {
+			QL4PRINT(QLP2, printk(
+			    "scsi%d: Heartbeat not received for %d seconds. "
+			    "HeartbeatInterval = %d seconds. Scheduling SOFT "
+			    "RESET.\n", ha->host_no,
+			    ha->seconds_since_last_heartbeat,
+			    ha->heartbeat_interval));
+
+			set_bit(DPC_RESET_HA, &ha->dpc_flags);
+		}
+	}
+
+	/*
+	 * Check for iSNS actions
+	 */
+	if (test_bit(ISNS_FLAG_RESTART_SERVICE, &ha->isns_flags)) {
+		if (atomic_read(&ha->isns_restart_timer)) {
+			if (!atomic_dec_and_test(&ha->isns_restart_timer) &&
+			    test_bit(ISNS_FLAG_ISNS_SRV_ENABLED,
+				    &ha->isns_flags) &&
+			    !IPAddrIsZero(ha->isns_ip_address) &&
+			    ha->isns_server_port_number) {
+				set_bit(DPC_ISNS_RESTART_COMPLETION,
+				    &ha->dpc_flags);
+			}
+		} else
+			clear_bit(ISNS_FLAG_RESTART_SERVICE, &ha->isns_flags);
+	}
+
+	/* Wakeup the dpc routine for this adapter, if needed */
+	if ((start_dpc ||
+	     test_bit(DPC_RESET_HA, &ha->dpc_flags) ||
+	     test_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags) ||
+	     test_bit(DPC_RESET_NIC_TEST, &ha->dpc_flags) ||
+	     test_bit(DPC_RELOGIN_DEVICE, &ha->dpc_flags) ||
+	     test_bit(DPC_RESET_HA_DESTROY_DDB_LIST, &ha->dpc_flags) ||
+	     test_bit(DPC_RESET_HA_INTR, &ha->dpc_flags) ||
+	     test_bit(DPC_IOCTL_ERROR_RECOVERY, &ha->dpc_flags) ||
+	     test_bit(DPC_ISNS_RESTART, &ha->dpc_flags) ||
+	     test_bit(DPC_ISNS_RESTART_COMPLETION, &ha->dpc_flags) ||
+	     test_bit(DPC_GET_DHCP_IP_ADDR, &ha->dpc_flags) ||
+	     test_bit(DPC_AEN, &ha->dpc_flags)) &&
+	    !test_bit(AF_DPC_SCHEDULED, &ha->flags) &&
+	    !ha->dpc_active && ha->dpc_wait) {
+		DEBUG2(printk("scsi%d: %s: scheduling dpc routine - dpc flags = 0x%lx\n",
+		    ha->host_no, __func__, ha->dpc_flags));
+		set_bit(AF_DPC_SCHEDULED, &ha->flags);
+		up(ha->dpc_wait);
+	}
+
+	/* Reschedule timer thread to call us back in one second */
+	mod_timer(&ha->timer, jiffies + HZ);
+
+	DEBUG2(ha->seconds_since_last_intr++;)
+}
+
+
+/**************************************************************************
+ * qla4xxx_do_dpc
+ *      This routine is a task that is schedule by the interrupt handler
+ *      to perform the background processing for interrupts.  We put it
+ *      on a task queue that is consumed whenever the scheduler runs; that's
+ *      so you can do anything (i.e. put the process to sleep etc).  In fact,
+ *      the mid-level tries to sleep when it reaches the driver threshold
+ *      "host->can_queue". This can cause a panic if we were in our interrupt
+ *      code.
+ *
+ * Input:
+ *      p - Pointer to host adapter structure.
+ *
+ * Returns:
+ *      None
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+static int
+qla4xxx_do_dpc(void *data)
+{
+	DECLARE_MUTEX_LOCKED(sem);
+	scsi_qla_host_t *ha = (scsi_qla_host_t *) data;
+	ddb_entry_t *ddb_entry, *dtemp;
+	fc_port_t       *fcport;
+
+	ENTER("qla4xxx_do_dpc");
+
+	lock_kernel();
+
+	daemonize("qla4xxx_%d_dpc", ha->host_no);
+	allow_signal(SIGHUP);
+
+	ha->dpc_wait = &sem;
+
+	set_user_nice(current, -20);
+
+	unlock_kernel();
+
+	complete(&ha->dpc_inited);
+
+	while (1) {
+		DEBUG2(printk("scsi%d: %s: DPC handler sleeping "
+		    "*****************\n", ha->host_no, __func__));
+
+		if (down_interruptible(&sem))
+			break;
+
+		if (ha->dpc_should_die)
+			break;
+
+		DEBUG2(printk("scsi%d: %s: DPC handler waking up "
+		    "****************\n", ha->host_no, __func__));
+
+		DEBUG2(printk("scsi%d: %s: ha->flags = 0x%08lx\n",
+		    ha->host_no, __func__, ha->flags));
+		DEBUG2(printk("scsi%d: %s: ha->dpc_flags = 0x%08lx\n",
+		    ha->host_no, __func__, ha->dpc_flags));
+
+		/* Initialization not yet finished. Don't do anything yet. */
+		if (!test_bit(AF_INIT_DONE, &ha->flags) || ha->dpc_active)
+			continue;
+			
+		ha->dpc_active = 1;
+		clear_bit(AF_DPC_SCHEDULED, &ha->flags);
+
+		if (!list_empty(&ha->done_srb_q))
+			qla4xxx_done(ha);
+
+		/* ---- return cmds on retry_q? --- */
+		if (!list_empty(&ha->retry_srb_q)) {
+			srb_t    *srb, *stemp;
+			unsigned long flags;
+
+			spin_lock_irqsave(&ha->list_lock, flags);
+
+			DEBUG2(printk("scsi%d: %s: found %d srbs in "
+			    "retry_srb_q \n", ha->host_no, __func__,
+			    ha->retry_srb_q_count));
+
+			list_for_each_entry_safe(srb, stemp, &ha->retry_srb_q,
+			    list_entry) {
+				ddb_entry_t *ddb_entry;
+				os_lun_t *lun_entry;
+
+				lun_entry = srb->lun_queue;
+
+				if (lun_entry == NULL)
+					continue;
+
+				if (lun_entry->lun_state ==
+				    LS_LUN_SUSPENDED)
+					continue;
+				fcport = lun_entry->fclun->fcport;
+				ddb_entry = fcport->ddbptr;
+
+				if (ddb_entry == NULL)
+					continue;
+
+				DEBUG2(printk("scsi%d: %s: found srb %p cmd %p lun=%d srb_state=%d\n",
+						ha->host_no, __func__,
+						srb, srb->cmd, srb->cmd->device->lun, srb->state);)
+
+				if (atomic_read(&ddb_entry->state) ==
+				    DEV_STATE_DEAD) {
+					DEBUG2(printk("scsi%d: %s: found srb %p, "
+						      "cmd %p, "
+							"in retry_srb_q, "
+							"Device DEAD, returning\n",
+							ha->host_no, __func__,
+							srb, srb->cmd));
+
+					__del_from_retry_srb_q(ha, srb);
+					srb->cmd->result = DID_NO_CONNECT << 16;
+					__add_to_done_srb_q(ha,srb);
+				}
+
+				/*
+				 * Send requests to OS when device goes ONLINE
+				 * so that the OS will retry them via I/O thread.
+				 * We don't want to issue I/O via recovery thread.
+				 */
+				if (ADAPTER_UP(ha) &&
+				    (atomic_read(&ddb_entry->state)
+				     == DEV_STATE_ONLINE)) {
+					DEBUG2(printk("scsi%d: %s: found srb %p cmd %p lun=%d target=%d"
+							"in retry_srb_q, "
+							"Device ONLINE, returning\n",
+							ha->host_no, __func__,
+							srb, srb->cmd, srb->cmd->device->lun, srb->cmd->device->id));
+
+					__del_from_retry_srb_q(ha, srb);
+					// srb->cmd->result = DID_IMM_RETRY << 16;
+					srb->cmd->result = DID_BUS_BUSY << 16;
+					__add_to_done_srb_q(ha,srb);
+				}
+			}
+			spin_unlock_irqrestore(&ha->list_lock, flags);
+
+			if (!list_empty(&ha->done_srb_q))
+				qla4xxx_done(ha);
+
+		}
+
+
+
+		/*
+		 * Determine what action is necessary
+		 */
+
+		/* ---- recover adapter? --- */
+		if (ADAPTER_UP(ha) ||
+		    test_bit(DPC_RESET_HA, &ha->dpc_flags) ||
+		    test_bit(DPC_RESET_HA_INTR, &ha->dpc_flags) ||
+		    test_bit(DPC_RESET_HA_DESTROY_DDB_LIST, &ha->dpc_flags)) {
+
+#if	DISABLE_HBA_RESETS
+				QL4PRINT(QLP2, printk("scsi: %s: ignoring RESET_HA, "
+				    "rebootdisable=1 \n", __func__));
+				clear_bit(DPC_RESET_HA, &ha->dpc_flags);
+				clear_bit(DPC_RESET_HA_INTR, &ha->dpc_flags);
+				clear_bit(DPC_RESET_HA_DESTROY_DDB_LIST, &ha->dpc_flags);
+#else
+			if (test_bit(DPC_RESET_HA_DESTROY_DDB_LIST,
+			    &ha->dpc_flags))
+				/* dg 09/23 Never initialize ddb list once we up and running
+					qla4xxx_recover_adapter(ha, REBUILD_DDB_LIST); */
+				qla4xxx_recover_adapter(ha, PRESERVE_DDB_LIST);
+			
+			if (test_bit(DPC_RESET_HA, &ha->dpc_flags))
+				qla4xxx_recover_adapter(ha, PRESERVE_DDB_LIST);
+			
+			if (test_and_clear_bit(DPC_RESET_HA_INTR, &ha->dpc_flags)) {
+				uint8_t wait_time = RESET_INTR_TOV;
+				unsigned long flags = 0;
+
+				qla4xxx_flush_active_srbs(ha);
+
+				spin_lock_irqsave(&ha->hardware_lock, flags);
+				while ((RD_REG_DWORD(&ha->reg->ctrl_status) &
+				    (CSR_SOFT_RESET|CSR_FORCE_SOFT_RESET)) != 0) {
+					if (--wait_time == 0)
+						break;
+
+					spin_unlock_irqrestore(
+					    &ha->hardware_lock, flags);
+
+					set_current_state(TASK_UNINTERRUPTIBLE);
+					schedule_timeout(1 * HZ);
+
+					spin_lock_irqsave(&ha->hardware_lock,
+					    flags);
+				}
+				spin_unlock_irqrestore(&ha->hardware_lock,
+				    flags);
+
+				if (wait_time == 0) {
+					QL4PRINT(QLP2,
+						 printk("scsi%d: %s: SR|FSR bit not cleared-- resetting\n",
+							ha->host_no, __func__));
+
+					set_bit(DPC_RESET_HA, &ha->dpc_flags);
+				}
+				else if (!qla4xxx_hba_going_away) {
+					qla4xxx_initialize_adapter(
+							  ha,
+							  PRESERVE_DDB_LIST);
+					qla4xxx_enable_intrs(ha);
+				}
+			}
+#endif
+		}
+
+		/* ---- Reset NIC test? --- */
+		if (test_and_clear_bit(DPC_RESET_NIC_TEST, &ha->dpc_flags)) {
+			unsigned long flags;
+
+			/* reset from NIC's register space */
+			spin_lock_irqsave(&ha->hardware_lock, flags);
+			//FIXME: First get access to NIC's address space
+			//WRT_REG_DWORD(&ha->nic_reg->ctrl_status, SET_RMASK(CSR_SOFT_RESET));
+			//PCI_POSTING(&ha->nic_reg->ctrl_status);
+			spin_unlock_irqrestore(&ha->hardware_lock, flags);
+		}
+
+		/* ---- process AEN? --- */
+		if (test_and_clear_bit(DPC_AEN, &ha->dpc_flags))
+			qla4xxx_process_aen(ha, PROCESS_ALL_AENS);
+
+		/* ---- Get DHCP IP Address? --- */
+		if (test_and_clear_bit(DPC_GET_DHCP_IP_ADDR, &ha->dpc_flags))
+			qla4xxx_get_dhcp_ip_address(ha);
+
+		/* ---- relogin device? --- */
+		if (ADAPTER_UP(ha) &&
+		    test_and_clear_bit(DPC_RELOGIN_DEVICE, &ha->dpc_flags)) {
+			list_for_each_entry_safe(ddb_entry, dtemp,
+			    &ha->ddb_list, list_entry) {
+				if (test_and_clear_bit(DF_RELOGIN,
+				    &ddb_entry->flags) &&
+				    atomic_read(&ddb_entry->state) != DEV_STATE_ONLINE) {
+					qla4xxx_relogin_device(ha, ddb_entry);
+				}
+				    /* If mbx cmd times out there is no point
+				     * in continuing further.
+				     * With large no of targets this can hang
+				     * the system.
+				     */		
+				    if (test_bit(DPC_RESET_HA, &ha->dpc_flags)) {
+					QL4PRINT(QLP2, printk("scsi%d: %s: need to reset hba\n", ha->host_no, __func__));
+					printk("scsi%d: %s: need to reset hba\n", ha->host_no, __func__);
+					break;
+				    }	
+			}
+		}
+
+		/* ---- restart iSNS server? --- */
+		if (ADAPTER_UP(ha) &&
+		    test_and_clear_bit(DPC_ISNS_RESTART, &ha->dpc_flags)) {
+			qla4xxx_isns_restart_service(ha);
+		}
+
+		if (ADAPTER_UP(ha) &&
+		    test_and_clear_bit(DPC_ISNS_RESTART_COMPLETION,
+			    &ha->dpc_flags)) {
+			uint32_t ip_addr = 0;
+			IPAddr2Uint32(ha->isns_ip_address, &ip_addr);
+
+			if (qla4xxx_isns_restart_service_completion(ha,
+							    ip_addr,
+					    ha->isns_server_port_number)
+			    != QLA_SUCCESS) {
+				DEBUG2( printk(KERN_WARNING "scsi%d: %s: "
+						"restart service failed\n",
+						ha->host_no, __func__));
+			}
+		}
+
+		ha->dpc_active = 0;
+	}
+
+	/*
+	* Make sure that nobody tries to wake us up again.
+	*/
+	ha->dpc_wait = NULL;
+	ha->dpc_active = 0;
+
+	complete_and_exit(&ha->dpc_exited, 0);
+}
+
+/**************************************************************************
+ * qla4xxx_eh_wait_on_command
+ *      This routine waits for the command to be returned by the Firmware
+ *      for some max time.
+ *
+ * Input:
+ *    ha = actual ha whose done queue will contain the command
+ *            returned by firmware.
+ *    cmd = Scsi Command to wait on.
+ *
+ * Returns:
+ *    Not Found : 0
+ *    Found : 1
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+static int
+qla4xxx_eh_wait_on_command(scsi_qla_host_t *ha, struct scsi_cmnd *cmd)
+{
+#define ABORT_POLLING_PERIOD	HZ
+	
+	int		found = 0;
+	int 		done = 0;
+	srb_t 		*rp = NULL;
+	struct list_head *list, *temp;
+	uint32_t max_wait_time = EH_WAIT_CMD_TOV;
+
+	DEBUG2(printk("%s: ENTER,  cmd=%p\n", __func__, cmd);)
+
+	do {
+		/* Check on done queue */
+		spin_lock(&ha->list_lock);
+		list_for_each_safe(list, temp, &ha->done_srb_q) {
+			rp = list_entry(list, srb_t, list_entry);
+
+			/*
+			 * Found command. Just exit and wait for the cmd sent
+			 * to OS.
+			*/
+			if (cmd == rp->cmd) {
+				found++;
+				DEBUG2(printk("%s: found in done queue.\n",
+				    __func__);)
+				break;
+			}
+		}
+		spin_unlock(&ha->list_lock);
+
+		/* Complete the cmd right away. */
+		if (found) {
+			del_from_done_srb_q(ha, rp);
+			sp_put(ha, rp);
+			done++;
+			break;
+		}
+
+		/* Checking to see if its returned to OS */
+		rp = (srb_t *) CMD_SP(cmd);
+		if (rp == NULL ) {
+			done++;
+			break;
+		}
+
+		spin_unlock_irq(ha->host->host_lock);
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(ABORT_POLLING_PERIOD);
+		spin_lock_irq(ha->host->host_lock);
+
+	} while (max_wait_time--);
+
+	DEBUG2(printk("%s: EXIT done=%d cmd=%p cmd_sp=%p\n",
+		      __func__, done, cmd, CMD_SP(cmd));)
+	return done;
+}
+
+/**************************************************************************
+ * qla4xxx_wait_for_hba_online
+ *      This routine
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure
+ *
+ * Remarks:
+ *
+ * Returns:
+ *      SUCCESS - Adapter is ONLINE
+ *      FAILED  - Adapter is DEAD
+ *
+ * Context:
+ *      Kernel context.  Assume io_request_lock LOCKED upon entry
+ **************************************************************************/
+inline uint8_t
+qla4xxx_wait_for_hba_online(scsi_qla_host_t *ha)
+{
+	unsigned long wait_online;
+
+	wait_online = jiffies + (30 * HZ);
+	while (time_before(jiffies, wait_online)) {
+		if (ADAPTER_UP(ha))
+			return QLA_SUCCESS;
+
+		if (!ADAPTER_UP(ha) && (ha->retry_reset_ha_cnt == 0)) {
+			QL4PRINT(QLP2, printk("scsi%d: %s: adapter down, "
+			    "retry_reset_ha_cnt = %d\n", ha->host_no, __func__,
+			    ha->retry_reset_ha_cnt));
+
+			return QLA_ERROR;
+		}
+
+		QL4PRINT(QLP3, printk("scsi%d: %s: adapter down, "
+		    "retry_reset_ha_cnt = %d, delay 2 sec.\n", ha->host_no,
+		    __func__, ha->retry_reset_ha_cnt));
+
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(2 * HZ);
+	}
+
+	return QLA_ERROR;
+}
+
+/**************************************************************************
+ * qla4xxx_eh_abort
+ *      This routine aborts commands that currently held in the adapter's
+ *      internal queues.  Commands that are active are NOT aborted.
+ *
+ * Input:
+ *      cmd - Pointer to Linux's SCSI command structure
+ *
+ * Remarks:
+ *      Aborts get translated to "device resets" by the scsi switch
+ *      which will return a RESET status and not ABORT. Since the
+ *      mid-level is expecting an ABORT status during an abort(),
+ *      we always elevate to device reset.
+ *
+ * Returns:
+ *      SUCCESS - Successfully aborted non-active command
+ *      FAILED  - Command not found, or command currently active
+ *
+ * Context:
+ *      Kernel context.  io_request_lock LOCKED
+ **************************************************************************/
+int
+qla4xxx_eh_abort(struct scsi_cmnd *cmd)
+{
+	int return_status = FAILED;
+	scsi_qla_host_t *ha, *vis_ha;
+	srb_t *srb;
+	srb_t *stemp;
+
+	srb = (srb_t *) CMD_SP(cmd);
+	if (!srb) {
+		/* Already returned to upper-layers. */
+		ql4_printk(KERN_INFO, to_qla_host(cmd->device->host),
+		    "Command already completed cmd=%p, pid=%ld.\n",
+			   cmd, cmd->serial_number);
+		DEBUG2(printk("%s: Command already completed cmd=%p, pid=%ld.\n",
+			   __func__, cmd, cmd->serial_number);)
+		return SUCCESS;
+	}
+
+	vis_ha = (scsi_qla_host_t *) cmd->device->host->hostdata;
+		ha = vis_ha;
+
+	ha->aborted_io_count++;
+
+	/* Print statements
+	 * ---------------- */
+	QL4PRINT(QLP2, printk(
+			      "scsi%d:%d:%d:%d: abort srb=%p, cmd=%p, state=%s, r_start=%ld , "
+			      "u_start=%ld\n", ha->host_no, cmd->device->channel,
+			      cmd->device->id, cmd->device->lun, srb, cmd,
+			      srb_state_msg[srb->state],srb->r_start,srb->u_start));
+	DEBUG2(printk("scsi%d: %s: os_tov = %d, iocb_tov = %d\n",
+	       ha->host_no, __func__, srb->os_tov, srb->iocb_tov);)
+	DEBUG2(printk("scsi%d: pid=%ld, errid=%d\n",
+		     ha->host_no, srb->cmd->serial_number, srb->err_id));
+	// qla4xxx_dump_dwords(QLP10, srb, sizeof(*srb));
+	//__dump_registers(QLP2, ha);
+
+#if 0
+        spin_unlock_irq(ha->host->host_lock);
+        if (qla4xxx_wait_for_hba_online(ha) != QLA_SUCCESS) {
+                DEBUG2(printk("%s failed:board disabled\n", __func__);)
+                spin_lock_irq(ha->host->host_lock);
+                return FAILED;
+        }
+        spin_lock_irq(ha->host->host_lock);
+#endif
+
+	
+	/* If srb found in done_q, return the cmd with ABORTED status */
+	spin_lock(&ha->list_lock);
+	list_for_each_entry_safe(srb, stemp, &ha->done_srb_q, list_entry) {
+		if (srb->cmd != cmd)
+			continue;
+
+		QL4PRINT(QLP2, printk("scsi%d: %s: srb %p found on done "
+		    "queue\n", ha->host_no, __func__, srb));
+
+		__del_from_done_srb_q(ha, srb);
+		cmd->result = DID_ABORT << 16;
+
+		spin_unlock(&ha->list_lock);
+		spin_unlock_irq(ha->host->host_lock);
+		sp_put(ha, srb);
+		spin_lock_irq(ha->host->host_lock);
+		return SUCCESS;
+	}
+	spin_unlock(&ha->list_lock);
+	
+	/*
+         * If srb found in retry_q, return the cmd with ABORTED status
+         */
+	spin_lock(&ha->list_lock);
+	list_for_each_entry_safe(srb, stemp, &ha->retry_srb_q, list_entry) {
+		if (srb->cmd != cmd)
+			continue;
+
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: srb %p found on retry queue\n",
+				ha->host_no, __func__, srb));
+
+		__del_from_retry_srb_q(ha, srb);
+		cmd->result = DID_ABORT << 16;
+
+		spin_unlock(&ha->list_lock);
+		spin_unlock_irq(ha->host->host_lock);
+		sp_put(ha, srb);
+		spin_lock_irq(ha->host->host_lock);
+		return SUCCESS;
+	}
+	spin_unlock(&ha->list_lock);
+
+	if (qla4xxx_eh_wait_on_command(ha, cmd)) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: return with status = %x\n",
+		    ha->host_no, __func__, SUCCESS));
+		return SUCCESS;
+	}
+
+	/*
+	 * Aborts get translated to "device resets" by the scsi switch which
+	 * will return a RESET status and not ABORT. Since the mid-level is
+	 * expecting an ABORT status during an abort(), we always elevate to
+	 * device reset.
+	 */
+	sp_get(ha, srb);
+	return_status = FAILED;
+
+	QL4PRINT(QLP2, printk("scsi%d: %s: return with status = %x\n",
+	    ha->host_no, __func__, return_status));
+	QL4PRINT(QLP2, printk("scsi%d: %s: cmd=%p cmd_err_flags=0x%x\n",
+			      ha->host_no, __func__, cmd, cmd->eh_eflags));
+	return return_status;
+}
+
+/**************************************************************************
+ * qla4010_soft_reset
+ *      This routine performs a SOFT RESET.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *      QLA_SUCCESS - Successfully reset the firmware
+ *      QLA_ERROR   - Failed to reset the firmware
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+uint8_t
+qla4010_soft_reset(scsi_qla_host_t *ha){
+	uint32_t  max_wait_time;
+	unsigned long flags = 0;
+	uint8_t status = QLA_ERROR;
+	uint32_t ctrl_status;
+
+	ENTER(__func__);
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+
+	/*
+	 * If the SCSI Reset Interrupt bit is set, clear it.
+	 * Otherwise, the Soft Reset won't work.
+	 */
+	ctrl_status = RD_REG_DWORD(&ha->reg->ctrl_status);
+	if ((ctrl_status & CSR_SCSI_RESET_INTR) != 0)
+		WRT_REG_DWORD(&ha->reg->ctrl_status, SET_RMASK(CSR_SCSI_RESET_INTR));
+
+	/* Issue Soft Reset */
+	WRT_REG_DWORD(&ha->reg->ctrl_status, SET_RMASK(CSR_SOFT_RESET));
+	PCI_POSTING(&ha->reg->ctrl_status);
+
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	/* Wait until the Network Reset Intr bit is cleared */
+	max_wait_time = RESET_INTR_TOV;
+	do {
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+		ctrl_status = RD_REG_DWORD(&ha->reg->ctrl_status);
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+		if ((ctrl_status & CSR_NET_RESET_INTR) == 0)
+			break;
+
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(1 * HZ);
+	} while ((--max_wait_time));
+
+	if ((ctrl_status & CSR_NET_RESET_INTR) != 0) {
+		QL4PRINT(QLP2,
+			 printk(KERN_WARNING "scsi%d: Network Reset Intr not cleared "
+				"by Network function, clearing it now!\n", ha->host_no));
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+		WRT_REG_DWORD(&ha->reg->ctrl_status, SET_RMASK(CSR_NET_RESET_INTR));
+		PCI_POSTING(&ha->reg->ctrl_status);
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+	}
+
+	/* Wait until the firmware tells us the Soft Reset is done */
+	max_wait_time = SOFT_RESET_TOV;
+	do {
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+		ctrl_status = RD_REG_DWORD(&ha->reg->ctrl_status);
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+		if ((ctrl_status & CSR_SOFT_RESET) == 0) {
+			status = QLA_SUCCESS;
+			break;
+		}
+
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(1 * HZ);
+	} while ((--max_wait_time));
+
+	/*
+	 * Also, make sure that the SCSI Reset Interrupt bit has been cleared
+	 * after the soft reset has taken place.
+	 */
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	ctrl_status = RD_REG_DWORD(&ha->reg->ctrl_status);
+	if ((ctrl_status & CSR_SCSI_RESET_INTR) != 0) {
+		WRT_REG_DWORD(&ha->reg->ctrl_status, SET_RMASK(CSR_SCSI_RESET_INTR));
+		PCI_POSTING(&ha->reg->ctrl_status);
+	}
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	/* If soft reset fails then most probably the bios on other
+	 * function is also enabled.
+	 * Since the initialization is sequential the other fn
+	 * wont be able to acknowledge the soft reset.
+	 * Issue a force soft reset to workaround this scenario.
+	 */
+	if (max_wait_time == 0) {
+		/* Issue Force Soft Reset */
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+		WRT_REG_DWORD(&ha->reg->ctrl_status,
+			SET_RMASK(CSR_FORCE_SOFT_RESET));
+		PCI_POSTING(&ha->reg->ctrl_status);
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+		/* Wait until the firmware tells us the Soft Reset is done */
+		max_wait_time = SOFT_RESET_TOV;
+		do {
+			spin_lock_irqsave(&ha->hardware_lock, flags);
+			ctrl_status = RD_REG_DWORD(&ha->reg->ctrl_status);
+			spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+			if ((ctrl_status & CSR_FORCE_SOFT_RESET) == 0) {
+				status = QLA_SUCCESS;
+				break;
+			}
+
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			schedule_timeout(1 * HZ);
+		} while ((--max_wait_time));
+	}
+
+	QL4PRINT(QLP2, printk("scsi%d: %s status=%d\n",
+			      ha->host_no, __func__, status));
+	LEAVE(__func__);
+	return(status);
+}
+
+/**************************************************************************
+ * qla4xxx_topcat_reset
+ *      This routine performs a HARD RESET of the TopCat chip.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *      QLA_SUCCESS - Successfully reset the firmware
+ *      QLA_ERROR   - Failed to reset the firmware
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_topcat_reset(scsi_qla_host_t *ha){
+	unsigned long flags;
+
+	QL4PRINT(QLP2, printk(KERN_WARNING "scsi%d: %s: TopCat chip reset!\n",
+			      ha->host_no, __func__));
+
+	QL4XXX_LOCK_NVRAM(ha);
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+
+	WRT_REG_DWORD(ISP_GP_OUT(ha), SET_RMASK(GPOR_TOPCAT_RESET));
+	PCI_POSTING(ISP_GP_OUT(ha));
+	TOPCAT_RESET_DELAY();
+	WRT_REG_DWORD(ISP_GP_OUT(ha), CLR_RMASK(GPOR_TOPCAT_RESET));
+	PCI_POSTING(ISP_GP_OUT(ha));
+
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	TOPCAT_POST_RESET_DELAY();
+
+	/* qla4xxx_clear_hw_semaphore(ha, SEM_NVRAM); */
+	QL4XXX_UNLOCK_NVRAM(ha);
+	return(QLA_SUCCESS);
+}
+
+
+/**************************************************************************
+ * qla4xxx_soft_reset
+ *      This routine performs a SOFT RESET.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *      QLA_SUCCESS - Successfully reset the firmware
+ *      QLA_ERROR   - Failed to reset the firmware
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_soft_reset(scsi_qla_host_t *ha){
+
+	QL4PRINT(QLP2, printk(KERN_WARNING "scsi%d: %s: chip reset!\n",
+			      ha->host_no, __func__));
+	if (test_bit(AF_TOPCAT_CHIP_PRESENT, &ha->flags)) {
+		uint8_t status = QLA_ERROR;
+
+		if (qla4010_soft_reset(ha) == QLA_SUCCESS) {
+			if (qla4xxx_topcat_reset(ha) == QLA_SUCCESS) {
+				if (qla4010_soft_reset(ha) == QLA_SUCCESS) {
+					status = QLA_SUCCESS;
+				}
+			}
+		}
+		return(status);
+	}
+	else
+		return(qla4010_soft_reset(ha));
+}
+
+/**************************************************************************
+ * qla4xxx_hard_reset
+ *      This routine performs a HARD RESET.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *      QLA_SUCCESS - Successfully reset the firmware
+ *      QLA_ERROR   - Failed to reset the firmware
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+inline uint8_t
+qla4xxx_hard_reset(scsi_qla_host_t *ha){
+	/* The QLA4010 really doesn't have an equivalent to a hard reset */
+	qla4xxx_flush_active_srbs(ha);
+	if (test_bit(AF_TOPCAT_CHIP_PRESENT, &ha->flags)) {
+		uint8_t status = QLA_ERROR;
+
+		if (qla4010_soft_reset(ha)  == QLA_SUCCESS) {
+			if (qla4xxx_topcat_reset(ha)  == QLA_SUCCESS) {
+				if (qla4010_soft_reset(ha) == QLA_SUCCESS) {
+					status = QLA_SUCCESS;
+				}
+			}
+		}
+		return(status);
+	}
+	else
+                return(qla4010_soft_reset(ha));
+	}
+
+/**************************************************************************
+ * qla4xxx_cmd_wait
+ *      This routine stalls the driver until all outstanding commands are
+ *      returned.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *
+ * Remarks:
+ *       Caller must release the Hardware Lock prior to calling this routine.
+ *
+ * Returns:
+ *      QLA_SUCCESS - All outstanding commands completed
+ *      QLA_ERROR   - All outstanding commands did not complete
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+static uint8_t
+qla4xxx_cmd_wait(scsi_qla_host_t *ha){
+	uint32_t index = 0;
+	uint8_t stat = QLA_SUCCESS;
+	int wait_cnt = WAIT_CMD_TOV;			/* Initialized for 30 seconds as we expect all
+						 commands to retuned ASAP.*/
+	unsigned long flags;
+
+	ENTER("qla4xxx_cmd_wait: started\n");
+
+	while (wait_cnt) {
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+		/* Find a command that hasn't completed. */
+	for (index = 1; index < MAX_SRBS; index++) {
+			if (ha->active_srb_array[index] != NULL)
+				break;
+		}
+			spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+		/* If No Commands are pending, wait is complete */
+		if (index == MAX_SRBS) {
+			break;
+		}
+
+		/* If we timed out on waiting for commands to come back
+		 * return ERROR.
+		 */
+		wait_cnt--;
+		if (wait_cnt == 0)
+			stat =  QLA_ERROR;
+		else {
+			/* sleep a second */
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			schedule_timeout(1 * HZ);
+		}
+	}		     /* End of While (wait_cnt) */
+
+	QL4PRINT(QLP2,printk("(%d): %s: Done waiting on commands - array_index=%d\n",
+			     ha->host_no, __func__, index));
+
+	LEAVE("qla4xxx_cmd_wait");
+
+	return(stat);
+}
+
+/**************************************************************************
+ * qla4xxx_recover_adapter
+ *      This routine recovers that adapter from a fatal state.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *      renew_ddb_list - Indicates what to do with the adapter's ddb list
+ *                      after adapter recovery has completed.
+ *                      0=preserve ddb list, 1=destroy and rebuild ddb list
+ *
+ * Returns:
+ *      QLA_SUCCESS - Successfully recovered adapter
+ *      QLA_ERROR   - Failed to recover adapter
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_recover_adapter(scsi_qla_host_t *ha, uint8_t renew_ddb_list){
+	uint8_t status = QLA_SUCCESS;
+
+	ENTER("qla4xxx_recover_adapter");
+
+	QL4PRINT(QLP2,
+		 printk("scsi%d: recover adapter (begin)\n",
+			ha->host_no));
+
+	/* Stall incoming I/O until we are done */
+	clear_bit(AF_ONLINE, &ha->flags);
+	DEBUG2(printk("scsi%d: %s calling qla4xxx_cmd_wait\n",
+			      ha->host_no, __func__));
+
+	/* Wait for outstanding commands to complete.
+	 * Stalls the driver for max 30 secs
+	 */
+	status = qla4xxx_cmd_wait(ha);
+
+	qla4xxx_disable_intrs(ha);
+
+	/* Flush any pending ddb changed AENs */
+	qla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);
+
+	/* Reset the firmware.  If successful, function
+	 * returns with ISP interrupts enabled.
+	 */
+	if (status == QLA_SUCCESS) {
+		DEBUG2(printk(
+		    "scsi%d: %s - Performing soft reset..\n",
+				ha->host_no,__func__));
+		status = qla4xxx_soft_reset(ha);
+	}
+
+	/* If firmware (SOFT) reset failed, or if all outstanding
+	 * commands have not returned, then do a HARD reset.
+	 */
+	if (status == QLA_ERROR) {
+		DEBUG2(printk(
+		    "scsi%d: %s - Performing hard reset..\n",
+				ha->host_no,__func__));
+		status = qla4xxx_hard_reset(ha);
+	}
+
+	/* Flush any pending ddb changed AENs */
+	qla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);
+
+	/* Re-initialize firmware. If successful, function returns
+	 * with ISP interrupts enabled */
+	if (status == QLA_SUCCESS) {
+		DEBUG2(printk(
+		    "scsi%d: %s - Initializing adapter..\n",
+				ha->host_no, __func__));
+
+		/* If successful, AF_ONLINE flag set in
+		 * qla4xxx_initialize_adapter */
+		status = qla4xxx_initialize_adapter(ha, renew_ddb_list);
+	}
+
+	/* Failed adapter initialization?
+	 * Retry reset_ha only if invoked via DPC (DPC_RESET_HA) */
+	if ((test_bit(AF_ONLINE, &ha->flags) == 0) &&
+	    (test_bit(DPC_RESET_HA, &ha->dpc_flags))) {
+		/* Adapter initialization failed, see if we can retry
+		 * resetting the ha */
+		if (!test_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags)) {
+			ha->retry_reset_ha_cnt = MAX_RESET_HA_RETRIES;
+			DEBUG2(printk("scsi%d: recover adapter - "
+					"retrying (%d) more times\n",
+					ha->host_no, ha->retry_reset_ha_cnt));
+			set_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags);
+			status = QLA_ERROR;
+		}
+		else {
+			if (ha->retry_reset_ha_cnt > 0) {
+				/* Schedule another Reset HA -- DPC will retry */
+				ha->retry_reset_ha_cnt--;
+				DEBUG2(printk(
+					"scsi%d: recover adapter - "
+					"retry remaining %d\n", ha->host_no,
+						ha->retry_reset_ha_cnt));
+				status = QLA_ERROR;
+			}
+
+			if (ha->retry_reset_ha_cnt == 0) {
+				/* Recover adapter retries have been exhausted.
+				 * Adapter DEAD */
+				DEBUG2( printk(
+					"scsi%d: recover adapter failed - "
+					"board disabled\n", ha->host_no));
+				qla4xxx_flush_active_srbs(ha);
+				clear_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags);
+				clear_bit(DPC_RESET_HA, &ha->dpc_flags);
+				clear_bit(DPC_RESET_HA_DESTROY_DDB_LIST,
+				    &ha->dpc_flags);
+				status = QLA_ERROR;
+			}
+		}
+	}
+	else {
+		clear_bit(DPC_RESET_HA, &ha->dpc_flags);
+		clear_bit(DPC_RESET_HA_DESTROY_DDB_LIST, &ha->dpc_flags);
+		clear_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags);
+	}
+
+	ha->adapter_error_count++;
+
+ 	if (status == QLA_SUCCESS)
+ 		qla4xxx_enable_intrs(ha);
+
+	DEBUG2(printk("scsi%d: recover adapter .. DONE\n", ha->host_no));
+	LEAVE("qla4xxx_recover_adapter");
+	return(status);
+}
+
+/**************************************************************************
+ * qla4xxx_eh_wait_for_active_target_commands
+ *      This routine
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *      target - SCSI target ID
+ *
+ * Returns:
+ *      0 - All pending commands returned
+ *      non-zero - All pending commands did not return
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+int
+qla4xxx_eh_wait_for_active_target_commands(scsi_qla_host_t *ha, int t, int l)
+{
+	int cnt;
+	int status;
+	srb_t *sp;
+	struct scsi_cmnd *cmd;
+
+	/*
+	 * Waiting for all commands for the designated target in the active
+	 * array
+	 */
+	status = 0;
+	for (cnt = 1; cnt < MAX_SRBS; cnt++) {
+		spin_lock(&ha->hardware_lock);
+		sp = ha->active_srb_array[cnt];
+		if (sp) {
+			cmd = sp->cmd;
+			spin_unlock(&ha->hardware_lock);
+			if (cmd->device->id == t && cmd->device->lun == l) {
+				if (!qla4xxx_eh_wait_on_command(ha, cmd)) {
+					status++;
+					break;
+				}
+			}
+		} else {
+			spin_unlock(&ha->hardware_lock);
+		}
+	}
+	return status;
+}
+
+/**************************************************************************
+ * qla4xxx_eh_device_reset
+ *      This routine is called by the Linux OS to reset all luns on the
+ * 	specified target.
+ *
+ * Input:
+ *      cmd - Pointer to Linux's SCSI command structure
+ *
+ * Output:
+ *      None
+ *
+ * Remarks:
+ *      None
+ *
+ * Returns:
+ *      SUCCESS - Successfully reset target/lun
+ *      FAILED  - Failed to reset target/lun
+ *
+ * Context:
+ *      Kernel context.  io_request_lock LOCKED
+ **************************************************************************/
+ int
+qla4xxx_eh_device_reset(struct scsi_cmnd *cmd)
+{
+	int return_status = FAILED;
+ 	scsi_qla_host_t *ha;
+	os_lun_t *lun_entry;
+	os_tgt_t *tgt_entry;
+	fc_lun_t *fclun;
+	uint8_t stat;
+	srb_t		*srb;
+	struct list_head *list, *temp;
+
+	if (cmd == NULL) {
+		printk(KERN_INFO
+		    "%s(): **** SCSI mid-layer passing in NULL cmd\n",
+		    __func__);
+		return (return_status);
+	}
+
+	if (!CMD_SP(cmd)) {
+		/* Already returned to upper-layers. */
+		ql4_printk(KERN_INFO, to_qla_host(cmd->device->host),
+		    "Command already completed cmd=%p, pid=%ld.\n",
+			   cmd, cmd->serial_number);
+		DEBUG2(printk("%s: Command already completed cmd=%p, pid=%ld.\n",
+			   __func__, cmd, cmd->serial_number);)
+		return SUCCESS;
+	}
+
+ 	ha = (scsi_qla_host_t *) cmd->device->host->hostdata;
+
+	/* Retrieve device and lun handles */
+ 	tgt_entry = qla4xxx_lookup_target_by_SCSIID(ha, cmd->device->channel,
+ 	    cmd->device->id);
+	if (!tgt_entry)	{
+		DEBUG2(printk("scsi%d: %s: **** CMD derives a NULL TGT_Q\n",
+			   ha->host_no, __func__);)
+		return FAILED;
+	}
+
+	lun_entry = qla4xxx_lookup_lun_handle(ha, tgt_entry, cmd->device->lun);
+	if (!lun_entry)	{
+		DEBUG2(printk("scsi%d: %s: **** CMD derives a NULL LUN_Q\n",
+		       ha->host_no, __func__);)
+		return FAILED;
+	}
+
+	fclun = lun_entry->fclun;
+	if (!fclun) {
+		DEBUG2(printk("scsi%d: %s: **** CMD derives a NULL FC_LUN_Q\n",
+		       ha->host_no, __func__);)
+		return FAILED;
+	}
+
+	ql4_printk(KERN_INFO, ha,
+	    "scsi%d:%d:%d:%d: DEVICE RESET ISSUED.\n", ha->host_no,
+	    cmd->device->channel, cmd->device->id, cmd->device->lun);
+
+	DEBUG2(printk(
+	    "scsi%d: DEVICE_RESET cmd=%p jiffies = 0x%lx, timeout=%x, "
+	    "dpc_flags=%lx, status=%x allowed=%d\n",
+	    ha->host_no, cmd, jiffies, cmd->timeout_per_command / HZ,
+	    ha->dpc_flags, cmd->result, cmd->allowed));
+
+	/* If we are coming in from the back-door, stall I/O until complete. */
+	if (!qla4xxx_is_eh_active(cmd->device->host)) {
+		set_bit(TQF_SUSPENDED, &tgt_entry->flags);
+	}
+	
+ 	/* Clear commands from the retry queue. */
+ 	spin_lock(&ha->list_lock);
+ 	list_for_each_safe(list, temp, &ha->retry_srb_q) {
+ 		srb = list_entry(list, srb_t, list_entry);
+
+ 		if (tgt_entry->id != srb->cmd->device->id)
+ 			continue;
+
+ 		DEBUG2(printk(
+		    "scsi%d: %s: found in retry queue. SP=%p\n",
+		    ha->host_no, __func__, srb));
+
+ 		__del_from_retry_srb_q(ha, srb);
+ 		srb->cmd->result = DID_RESET << 16;
+ 		__add_to_done_srb_q(ha, srb);
+ 	}
+ 	spin_unlock(&ha->list_lock);
+	
+	spin_unlock_irq(ha->host->host_lock);
+	if (qla4xxx_wait_for_hba_online(ha) != QLA_SUCCESS) {
+		DEBUG2(printk(
+		    "scsi%d: %s:  failed:board disabled\n", ha->host_no, __func__));
+
+		spin_lock_irq(ha->host->host_lock);
+		goto eh_dev_reset_done;
+	}
+
+	stat = qla4xxx_reset_lun(ha, fclun->fcport->ddbptr, fclun);
+	spin_lock_irq(ha->host->host_lock);
+	if (stat != QLA_SUCCESS) {
+		ql4_printk(KERN_INFO, ha, "DEVICE RESET FAILED. %d\n", stat);
+
+		goto eh_dev_reset_done;
+	}
+
+	/* Send marker. */
+	ha->marker_needed = 1;
+
+	/*
+	 * If we are coming down the EH path, wait for all commands to complete
+	 * for the device.
+	 */
+	if (qla4xxx_is_eh_active(cmd->device->host)) {
+		if (qla4xxx_eh_wait_for_active_target_commands(ha,
+		    cmd->device->id, cmd->device->lun)) {
+			ql4_printk(KERN_INFO, ha, "DEVICE RESET FAILED - "
+			    "waiting for commands.\n");
+
+			goto eh_dev_reset_done;
+ 		}
+ 	}
+
+	ql4_printk(KERN_INFO, ha,
+	    "scsi(%d:%d:%d:%d): DEVICE RESET SUCCEEDED.\n", ha->host_no,
+	    cmd->device->channel, cmd->device->id, cmd->device->lun);
+
+	return_status = SUCCESS;
+
+eh_dev_reset_done:
+
+	if (!qla4xxx_is_eh_active(cmd->device->host))
+		clear_bit(TQF_SUSPENDED, &tgt_entry->flags);
+
+ 	QL4PRINT(QLP2, printk("scsi%d: %s: return with status %s\n",
+                              ha->host_no, __func__,
+			      (return_status == FAILED) ? "FAILED" : "SUCCEDED"));
+
+	return return_status;
+ }
+
+
+/**************************************************************************
+ * qla4xxx_eh_bus_reset
+ *      This routine is called by the Linux OS to reset the specified
+ *      adapter/bus.
+ *
+ * Input:
+ *      cmd - Pointer to Linux's SCSI command structure
+ *
+ * Returns:
+ *      SUCCESS - Successfully reset adapter/bus
+ *      FAILED  - Failed to reset adapter/bus
+ *
+ * Context:
+ *      Kernel context.  io_request_lock LOCKED
+ **************************************************************************/
+int
+qla4xxx_eh_bus_reset(struct scsi_cmnd *cmd)
+{
+	uint8_t status = QLA_SUCCESS;
+	int     return_status = FAILED;
+	scsi_qla_host_t *ha;
+	ddb_entry_t *ddb_entry, *dtemp;
+	ha = (scsi_qla_host_t *) cmd->device->host->hostdata;
+
+	ql4_printk(KERN_INFO, ha,
+	    "scsi(%d:%d:%d:%d): BUS RESET ISSUED.\n", ha->host_no,
+	    cmd->device->channel, cmd->device->id, cmd->device->lun);
+
+	spin_unlock_irq(ha->host->host_lock);
+	if (qla4xxx_wait_for_hba_online(ha) != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d:%d: %s: Unable to reset "
+		    "bus.  Adapter DEAD.\n", ha->host_no,
+		    cmd->device->channel, __func__));
+
+		spin_lock_irq(ha->host->host_lock);
+		return FAILED;
+	}
+	spin_lock_irq(ha->host->host_lock);
+
+	/* Attempt to reset all valid targets with outstanding commands */
+	list_for_each_entry_safe(ddb_entry, dtemp, &ha->ddb_list, list_entry) {
+		QL4PRINT(QLP5, printk("scsi%d: %s: reset target b%d, t%x, "
+		    "index [%d]\n", ha->host_no, __func__, ddb_entry->bus,
+		    ddb_entry->target, ddb_entry->fw_ddb_index));
+
+		/* Issue a reset */
+		status |= qla4xxx_reset_target(ha, ddb_entry);
+	}
+
+	/*
+	 * Status is QLA_SUCCESS if target resets for ALL devices completed
+	 * successfully.  Otherwise the status is QLA_ERROR.
+	 */
+	if (status == QLA_SUCCESS)
+		return_status = SUCCESS;
+
+	ql4_printk(KERN_INFO, ha, "BUS RESET %s.\n",
+	    (return_status == FAILED) ? "FAILED" : "SUCCEDED");
+	DEBUG2(printk("%s: EXIT (%s)\n", __func__,
+		    (return_status == FAILED) ? "FAILED" : "SUCCEDED");)
+	return return_status;
+}
+
+/**************************************************************************
+ * qla4xxx_reset_target
+ *      This routine issues either a warm or cold target reset to the
+ *      specified device.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *      ddb_entry - Pointer to device database entry
+ *
+ * Remarks:
+ *      The caller must ensure that the ddb_entry pointer is valid before
+ *      calling this routine.
+ *
+ * Returns:
+ *      QLA_SUCCESS - Successfully reset target
+ *      QLA_ERROR   - Failed to reset target
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_reset_target(scsi_qla_host_t *ha, ddb_entry_t *ddb_entry)
+{
+	uint8_t status = QLA_SUCCESS;
+	fc_lun_t *fclun;
+	fc_port_t *fcport;
+	uint8_t stat;
+
+	/* Reset all LUNs on this target */
+	fcport = ddb_entry->fcport;
+	list_for_each_entry(fclun, &fcport->fcluns, list) {
+		spin_unlock_irq(ha->host->host_lock);
+		stat = qla4xxx_reset_lun(ha, ddb_entry, fclun);
+		spin_lock_irq(ha->host->host_lock);
+		if (stat == QLA_SUCCESS) {
+			/* Send marker. */
+			ha->marker_needed =1;
+
+			/*
+			 * Waiting for all active commands to complete for the
+			 * device.
+			 */
+			status |= qla4xxx_eh_wait_for_active_target_commands(
+			    ha, ddb_entry->target, fclun->lun);
+		} else {
+			status |= QLA_ERROR;
+		}
+	}
+
+	if (status == QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d:%d:%d: device reset SUCCEEDED.\n",
+		    ha->host_no, ddb_entry->bus, fcport->os_target_id));
+	} else {
+		QL4PRINT(QLP2, printk("scsi%d:%d:%d: device reset FAILED.\n",
+		    ha->host_no, ddb_entry->bus, fcport->os_target_id));
+
+		status = QLA_ERROR;
+	}
+
+	return status;
+}
+
+/**************************************************************************
+ * qla4xxx_flush_active_srbs
+ *      This routine is called just prior to a HARD RESET to return all
+ *      outstanding commands back to the Operating System.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *
+ * Remarks:
+ *      Caller should make sure that the following locks are released
+ *      before this calling routine:
+ *              Hardware lock, io_request_lock, list_lock, and lun_lock.
+ *
+ * Returns:
+ *      None
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+static void
+qla4xxx_flush_active_srbs(scsi_qla_host_t *ha){
+	srb_t    *srb;
+	int      i;
+	unsigned long flags;
+
+	ENTER("qla4xxx_flush_active_srbs");
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	for (i = 1; i < MAX_SRBS; i++) {
+		if ((srb = ha->active_srb_array[i]) != NULL) {
+			QL4PRINT(QLP5,
+				 printk("scsi%d: %s: found srb %p in active array, "
+					"returning\n", ha->host_no, __func__, srb));
+			del_from_active_array(ha, i);
+			srb->cmd->result =  DID_RESET  <<  16;
+			sp_put(ha,srb);
+		}
+	}
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	// if (!list_empty(&ha->done_srb_q)) {
+	// while ((srb = del_from_done_srb_q_head(ha)) != NULL)
+	// sp_put(ha, srb);
+	// }
+
+	LEAVE("qla4xxx_flush_active_srbs");
+}
+
+/**************************************************************************
+ * qla4xxx_eh_host_reset
+ *      This routine is invoked by the Linux kernel to perform fatal error
+ *      recovery on the specified adapter.
+ *
+ * Input:
+ *      cmd - Pointer to Linux's SCSI command structure
+ *
+ * Returns:
+ *      SUCCESS - Successfully recovered host adapter
+ *      FAILED  - Failed to recover host adapter
+ *
+ * Context:
+ *      Kernel context.  io_request_lock LOCKED
+ **************************************************************************/
+int
+qla4xxx_eh_host_reset(struct scsi_cmnd *cmd)
+{
+	int return_status = FAILED;
+	scsi_qla_host_t *ha;
+
+	ha = (scsi_qla_host_t *) cmd->device->host->hostdata;
+
+	ql4_printk(KERN_INFO, ha,
+	    "scsi(%d:%d:%d:%d): HOST RESET ISSUED.\n", ha->host_no,
+	    cmd->device->channel, cmd->device->id, cmd->device->lun);
+	DEBUG2(printk("scsi(%d:%d:%d:%d): HOST RESET ISSUED.\n",
+		      ha->host_no, cmd->device->channel,
+		      cmd->device->id, cmd->device->lun);)
+
+	spin_unlock_irq(ha->host->host_lock);
+
+	if (qla4xxx_wait_for_hba_online(ha) != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d:%d: %s: Unable to reset "
+		    "host.  Adapter DEAD.\n", ha->host_no,
+		    cmd->device->channel, __func__));
+
+		spin_lock_irq(ha->host->host_lock);
+		return FAILED;
+	}
+
+	if (qla4xxx_recover_adapter(ha, PRESERVE_DDB_LIST) == QLA_SUCCESS) {
+		return_status = SUCCESS;
+	}
+
+	ql4_printk(KERN_INFO, ha, "HOST RESET %s.\n",
+	    (return_status == FAILED) ? "FAILED" : "SUCCEDED");
+	DEBUG2(printk("HOST RESET %s.\n",
+	    (return_status == FAILED) ? "FAILED" : "SUCCEDED");)
+
+	spin_lock_irq(ha->host->host_lock);
+
+	return return_status;
+}
+
+/*
+* qla4xxx_free_other_mem
+*      Frees all adapter allocated memory.
+*
+* Input:
+*      ha = adapter block pointer.
+*/
+static void
+qla4xxx_free_other_mem(scsi_qla_host_t *ha)
+{
+	uint32_t        t;
+	fc_port_t       *fcport, *fptemp;
+	fc_lun_t        *fclun, *fltemp;
+
+	if (ha == NULL) {
+		/* error */
+		DEBUG2(printk("%s: ERROR invalid ha pointer.\n", __func__));
+		return;
+	}
+
+	/* Free the target and lun queues */
+	for (t = 0; t < MAX_TARGETS; t++) {
+		qla4xxx_tgt_free(ha, t);
+	}
+
+	/* Free fcport and fcluns */
+	list_for_each_entry_safe(fcport, fptemp, &ha->fcports, list) {
+		list_for_each_entry_safe(fclun, fltemp, &fcport->fcluns, list) {
+			list_del_init(&fclun->list);
+			kfree(fclun);
+		}
+		list_del_init(&fcport->list);
+		kfree(fcport);
+	}
+	INIT_LIST_HEAD(&ha->fcports);
+}
+
+/*
+ * Overrides for Emacs so that we almost follow Linus's tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 2
+ * c-brace-imaginary-offset: 0
+ * c-brace-offset: -2
+ * c-argdecl-indent: 2
+ * c-label-offset: -2
+ * c-continued-statement-offset: 2
+ * c-continued-brace-offset: 0
+ * indent-tabs-mode: nil
+ * tab-width: 8
+ * End:
+ */
+
+
+
diff --git a/drivers/scsi/qla4xxx/ql4_os.h b/drivers/scsi/qla4xxx/ql4_os.h
new file mode 100644
index 0000000..7279015
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_os.h
@@ -0,0 +1,151 @@
+/******************************************************************************
+ *     Copyright (C)  2003 -2005 QLogic Corporation
+ * QLogic ISP4xxx Device Driver
+ *
+ * This program includes a device driver for Linux 2.6.x that may be
+ * distributed with QLogic hardware specific firmware binary file.
+ * You may modify and redistribute the device driver code under the
+ * GNU General Public License as published by the Free Software Foundation
+ * (version 2 or a later version) and/or under the following terms,
+ * as applicable:
+ *
+ * 	1. Redistribution of source code must retain the above copyright
+ *         notice, this list of conditions and the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above copyright
+ *         notice, this list of conditions and the following disclaimer in
+ *         the documentation and/or other materials provided with the
+ *         distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ * 	
+ * You may redistribute the hardware specific firmware binary file under
+ * the following terms:
+ * 	1. Redistribution of source code (only if applicable), must
+ *         retain the above copyright notice, this list of conditions and
+ *         the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above
+ *         copyright notice, this list of conditions and the following
+ *         disclaimer in the documentation and/or other materials provided
+ *         with the distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ *
+ * REGARDLESS OF WHAT LICENSING MECHANISM IS USED OR APPLICABLE,
+ * THIS PROGRAM IS PROVIDED BY QLOGIC CORPORATION "AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * USER ACKNOWLEDGES AND AGREES THAT USE OF THIS PROGRAM WILL NOT CREATE
+ * OR GIVE GROUNDS FOR A LICENSE BY IMPLICATION, ESTOPPEL, OR OTHERWISE
+ * IN ANY INTELLECTUAL PROPERTY RIGHTS (PATENT, COPYRIGHT, TRADE SECRET,
+ * MASK WORK, OR OTHER PROPRIETARY RIGHT) EMBODIED IN ANY OTHER QLOGIC
+ * HARDWARE OR SOFTWARE EITHER SOLELY OR IN COMBINATION WITH THIS PROGRAM
+ *
+ ******************************************************************************/
+#ifndef _QL4_OS_H_
+#define _QL4_OS_H_
+
+#define __KERNEL_SYSCALLS__
+#define SHUTDOWN_SIGS	(sigmask(SIGHUP))
+
+
+#define HOST_STS_TBL(){		  \
+	"DID_OK",                 \
+	"DID_NO_CONNECT",         \
+	"DID_BUS_BUSY",           \
+	"DID_TIME_OUT",           \
+	"DID_BAD_TARGET",         \
+	"DID_ABORT",              \
+	"DID_PARITY",             \
+	"DID_ERROR",              \
+	"DID_RESET",              \
+	"DID_BAD_INTR",           \
+	NULL			  \
+}
+
+/*---------------------------------------------------------------------------*/
+
+/* We use the Scsi_Pointer structure that's included with each command
+ * SCSI_Cmnd as a scratchpad for our SRB.
+ */
+#define CMD_SP(Cmnd)	    ((Cmnd)->SCp.ptr)
+
+/* Additional fields used by ioctl passthru */
+#define CMD_PASSTHRU_TYPE(Cmnd) (((Cmnd)->SCp.buffer))
+#define CMD_COMPL_STATUS(Cmnd)  ((Cmnd)->SCp.this_residual)
+#define CMD_RESID_LEN(Cmnd)     ((Cmnd)->SCp.buffers_residual)
+#define CMD_SCSI_STATUS(Cmnd)   ((Cmnd)->SCp.Status)
+#define CMD_ACTUAL_SNSLEN(Cmnd) ((Cmnd)->SCp.have_data_in)
+#define CMD_HOST_STATUS(Cmnd)   ((Cmnd)->SCp.Message)
+#define CMD_ISCSI_RESPONSE(Cmnd)((Cmnd)->SCp.sent_command)
+#define CMD_STATE_FLAGS(Cmnd)   ((Cmnd)->SCp.phase)
+
+
+/*
+ * SCSI definitions not defined in Linux's scsi.h
+ */
+
+/* The SCSISTAT values are defined in scsi.h,
+ * but the values are shifted by one bit.
+ * We re-define them here without bit shifting
+ * to minimize confusion */
+#define SCSISTAT_GOOD			0x00
+#define SCSISTAT_CHECK_CONDITION	0x02
+#define SCSISTAT_CONDITION_GOOD		0x04
+#define SCSISTAT_BUSY			0x08
+#define SCSISTAT_INTERMEDIATE_GOOD  	0x10
+#define SCSISTAT_INTERMEDIATE_C_GOOD  	0x14
+#define SCSISTAT_RESERVATION_CONFLICT 	0x18
+#define SCSISTAT_COMMAND_TERMINATED   	0x22
+#define SCSISTAT_QUEUE_FULL           	0x28
+
+
+/* SAM-II compliant lun structure */
+typedef struct {
+	uint8_t bus_identifier:6;
+	uint8_t address_method:2;
+
+	uint8_t single_level_lun;
+	uint16_t second_level_lun;
+	uint16_t third_level_lun;
+	uint16_t fourth_level_lun;
+} single_level_lun_t;
+
+typedef struct {
+	uint32_t lun_list_length;
+	uint8_t reserved[4];
+	single_level_lun_t lun[MAX_LUNS];
+} report_luns_t;
+
+#endif  /* _QL4_OS_H_ */
+
+/*
+ * Overrides for Emacs so that we almost follow Linus's tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 2
+ * c-brace-imaginary-offset: 0
+ * c-brace-offset: -2
+ * c-argdecl-indent: 2
+ * c-label-offset: -2
+ * c-continued-statement-offset: 2
+ * c-continued-brace-offset: 0
+ * indent-tabs-mode: nil
+ * tab-width: 8
+ * End:
+ */
+
+
diff --git a/drivers/scsi/qla4xxx/ql4_settings.h b/drivers/scsi/qla4xxx/ql4_settings.h
new file mode 100644
index 0000000..21e3374
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_settings.h
@@ -0,0 +1,85 @@
+/******************************************************************************
+ *     Copyright   2003 -2005 QLogic Corporation
+ * QLogic ISP4xxx Device Driver
+ *
+ * This program includes a device driver for Linux 2.6.x that may be
+ * distributed with QLogic hardware specific firmware binary file.
+ * You may modify and redistribute the device driver code under the
+ * GNU General Public License as published by the Free Software Foundation
+ * (version 2 or a later version) and/or under the following terms,
+ * as applicable:
+ *
+ * 	1. Redistribution of source code must retain the above copyright
+ *         notice, this list of conditions and the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above copyright
+ *         notice, this list of conditions and the following disclaimer in
+ *         the documentation and/or other materials provided with the
+ *         distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ * 	
+ * You may redistribute the hardware specific firmware binary file under
+ * the following terms:
+ * 	1. Redistribution of source code (only if applicable), must
+ *         retain the above copyright notice, this list of conditions and
+ *         the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above
+ *         copyright notice, this list of conditions and the following
+ *         disclaimer in the documentation and/or other materials provided
+ *         with the distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ *
+ * REGARDLESS OF WHAT LICENSING MECHANISM IS USED OR APPLICABLE,
+ * THIS PROGRAM IS PROVIDED BY QLOGIC CORPORATION "AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * USER ACKNOWLEDGES AND AGREES THAT USE OF THIS PROGRAM WILL NOT CREATE
+ * OR GIVE GROUNDS FOR A LICENSE BY IMPLICATION, ESTOPPEL, OR OTHERWISE
+ * IN ANY INTELLECTUAL PROPERTY RIGHTS (PATENT, COPYRIGHT, TRADE SECRET,
+ * MASK WORK, OR OTHER PROPRIETARY RIGHT) EMBODIED IN ANY OTHER QLOGIC
+ * HARDWARE OR SOFTWARE EITHER SOLELY OR IN COMBINATION WITH THIS PROGRAM
+ *
+ ******************************************************************************
+ *             Please see release.txt for revision history.                   *
+ *                                                                            *
+ ****************************************************************************/
+
+/*
+ * Compile time Options:
+ *            0 - Disable and 1 - Enable
+ ****************************************/
+
+/*
+ * The following compile time options are temporary,
+ * used for debug purposes only.
+ ****************************************/
+#define ISP_RESET_TEST		0 /* Issues BIG HAMMER (reset) every 3 minutes */
+#define NIC_RESET_TEST		0 /* Simulates NIC card reset every 3 minutes */
+#define EH_DISPLAY_INFO		0 /* Display misc active eh info every 3 minutes */
+
+/*
+ * Compile time Options:
+ *     0 - Disable and 1 - Enable
+ */
+#define DEBUG_QLA4xx		0	/* For Debug of qla4xxx */
+
+#define	DISABLE_HBA_RESETS	0
+
+#define ENABLE_MSI		0	/* Need kernel version 2.6.10 and newer */
+
+#define MSA1000_SUPPORTED	0
+
+#define EXTEND_CMD_TIMEOUT	60
+
diff --git a/drivers/scsi/qla4xxx/ql4_version.h b/drivers/scsi/qla4xxx/ql4_version.h
new file mode 100644
index 0000000..11e27fb
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_version.h
@@ -0,0 +1,60 @@
+/******************************************************************************
+ *     Copyright (C)  2003 -2005 QLogic Corporation
+ * QLogic ISP4xxx Device Driver
+ *
+ * This program includes a device driver for Linux 2.6.x that may be
+ * distributed with QLogic hardware specific firmware binary file.
+ * You may modify and redistribute the device driver code under the
+ * GNU General Public License as published by the Free Software Foundation
+ * (version 2 or a later version) and/or under the following terms,
+ * as applicable:
+ *
+ * 	1. Redistribution of source code must retain the above copyright
+ *         notice, this list of conditions and the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above copyright
+ *         notice, this list of conditions and the following disclaimer in
+ *         the documentation and/or other materials provided with the
+ *         distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ * 	
+ * You may redistribute the hardware specific firmware binary file under
+ * the following terms:
+ * 	1. Redistribution of source code (only if applicable), must
+ *         retain the above copyright notice, this list of conditions and
+ *         the following disclaimer.
+ * 	2. Redistribution in binary form must reproduce the above
+ *         copyright notice, this list of conditions and the following
+ *         disclaimer in the documentation and/or other materials provided
+ *         with the distribution.
+ * 	3. The name of QLogic Corporation may not be used to endorse or
+ *         promote products derived from this software without specific
+ *         prior written permission
+ *
+ * REGARDLESS OF WHAT LICENSING MECHANISM IS USED OR APPLICABLE,
+ * THIS PROGRAM IS PROVIDED BY QLOGIC CORPORATION "AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * USER ACKNOWLEDGES AND AGREES THAT USE OF THIS PROGRAM WILL NOT CREATE
+ * OR GIVE GROUNDS FOR A LICENSE BY IMPLICATION, ESTOPPEL, OR OTHERWISE
+ * IN ANY INTELLECTUAL PROPERTY RIGHTS (PATENT, COPYRIGHT, TRADE SECRET,
+ * MASK WORK, OR OTHER PROPRIETARY RIGHT) EMBODIED IN ANY OTHER QLOGIC
+ * HARDWARE OR SOFTWARE EITHER SOLELY OR IN COMBINATION WITH THIS PROGRAM
+ *
+ ******************************************************************************/
+#define QLA4XXX_DRIVER_VERSION      "5.00.04-d5"
+
+#define QL4_DRIVER_MAJOR_VER	5
+#define QL4_DRIVER_MINOR_VER	0
+#define QL4_DRIVER_PATCH_VER	4
+#define QL4_DRIVER_BETA_VER	0
